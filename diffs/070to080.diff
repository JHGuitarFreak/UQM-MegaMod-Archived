diff -ruNp src.orig/Makeinfo src/Makeinfo
--- src.orig/Makeinfo	2017-11-21 19:39:34 -0600
+++ src/Makeinfo	2017-11-21 19:39:51 -0600
@@ -1,4 +1,6 @@
 uqm_SUBDIRS="libs res uqm"
+uqm_CFILES="options.c port.c uqm.c"
+uqm_HFILES="config.h endian_uqm.h options.h port.h types.h uqmversion.h"
 
 if [ "$uqm_HAVE_GETOPT_LONG" = 0 ]; then
 	uqm_SUBDIRS="$uqm_SUBDIRS getopt"
@@ -8,11 +10,12 @@ case "$HOST_SYSTEM" in
 	Darwin)
 		uqm_SUBDIRS="$uqm_SUBDIRS darwin"
 		;;
+	MSVC)
+		uqm_HFILES="$uqm_HFILES config_vc6.h"
+		;;
 esac
 
 if [ "$uqm_HAVE_REGEX" = 0 ]; then
 	uqm_SUBDIRS="$uqm_SUBDIRS regex"
 fi
 
-uqm_CFILES="options.c port.c uqm.c"
-
diff -ruNp src.orig/darwin/Makeinfo src/darwin/Makeinfo
--- src.orig/darwin/Makeinfo	2017-11-21 19:39:28 -0600
+++ src/darwin/Makeinfo	2017-11-21 19:39:43 -0600
@@ -1,2 +1,2 @@
 uqm_MFILES="SDLMain.m"
-
+uqm_HFILES="SDLMain.h"
diff -ruNp src.orig/darwin/SDLMain.h src/darwin/SDLMain.h
--- src.orig/darwin/SDLMain.h	2017-11-21 19:39:28 -0600
+++ src/darwin/SDLMain.h	2017-11-21 19:39:43 -0600
@@ -1,19 +1,16 @@
-/*	SDLMain.m - main entry point for our Cocoa-ized SDL app
-	Initial Version: Darrell Walisser <dwaliss1@purdue.edu>
-	Non-NIB-Code & other changes: Max Horn <max@quendi.de>
+/*   SDLMain.m - main entry point for our Cocoa-ized SDL app
+       Initial Version: Darrell Walisser <dwaliss1@purdue.edu>
+       Non-NIB-Code & other changes: Max Horn <max@quendi.de>
 
-	Feel free to customize this file to suit your needs
+    Feel free to customize this file to suit your needs
 */
 
-#import <Cocoa/Cocoa.h>
+#ifndef _SDLMain_h_
+#define _SDLMain_h_
 
-/* An internal Apple class used to setup Apple menus */
-@interface NSAppleMenuController:NSObject {}
-- (void)controlMenu:(NSMenu *)aMenu;
-@end
+#import <Cocoa/Cocoa.h>
 
 @interface SDLMain : NSObject
 @end
 
-@interface SDLApplication : NSApplication
-@end
+#endif /* _SDLMain_h_ */
diff -ruNp src.orig/darwin/SDLMain.m src/darwin/SDLMain.m
--- src.orig/darwin/SDLMain.m	2017-11-21 19:39:28 -0600
+++ src/darwin/SDLMain.m	2017-11-21 19:39:43 -0600
@@ -1,285 +1,381 @@
-/*	SDLMain.m - main entry point for our Cocoa-ized SDL app
-	Initial Version: Darrell Walisser <dwaliss1@purdue.edu>
-	Non-NIB-Code & other changes: Max Horn <max@quendi.de>
+/*   SDLMain.m - main entry point for our Cocoa-ized SDL app
+       Initial Version: Darrell Walisser <dwaliss1@purdue.edu>
+       Non-NIB-Code & other changes: Max Horn <max@quendi.de>
 
-	Feel free to customize this file to suit your needs
-
-	Modified for use with The Ur-Quan Masters by Nicolas Simonds
-	<uqm at submedia dot net>
+    Feel free to customize this file to suit your needs
 */
 
-#import "port.h"
-#import SDL_INCLUDE(SDL.h)
-#import "SDLMain.h"
-#import <sys/param.h>
-		/* for PATH_MAX */
-#import <string.h>
-		/* for strrchr() */
-#import <unistd.h>
-
-static int gArgc;
-static char **gArgv;
-static BOOL gFinderLaunch;
-
-@implementation SDLApplication
-/* Invoked from the Quit menu item */
-- (void)terminate:(id)sender
-{
-	/* Post a SDL_QUIT event */
-	SDL_Event event;
-	event.type = SDL_QUIT;
-	SDL_PushEvent (&event);
-	(void) sender;  /* Get rid of unused variable warning */
-}
-
-/* override NSApplication:sendEvent, to keep Cocoa from beeping on
-   non-command keystrokes */
-- (void)sendEvent:(NSEvent *)anEvent {
-	if (NSKeyDown == [anEvent type] || NSKeyUp == [anEvent type]) {
-		if ([anEvent modifierFlags] & NSCommandKeyMask)
-			[super sendEvent: anEvent];
-	} else
-		[super sendEvent: anEvent];
-}
+#include "SDL.h"
+#include "SDLMain.h"
+#include <sys/param.h> /* for MAXPATHLEN */
+#include <unistd.h>
+
+/* For some reaon, Apple removed setAppleMenu from the headers in 10.4,
+ but the method still is there and works. To avoid warnings, we declare
+ it ourselves here. */
+@interface NSApplication(SDL_Missing_Methods)
+- (void)setAppleMenu:(NSMenu *)menu;
 @end
 
-/* The main class of the application, the application's delegate */
-@implementation SDLMain
+/* Use this flag to determine whether we use SDLMain.nib or not */
+#define		SDL_USE_NIB_FILE	0
 
-static char *
-basename (char *path)
+/* Use this flag to determine whether we use CPS (docking) or not */
+#define		SDL_USE_CPS		1
+#ifdef SDL_USE_CPS
+/* Portions of CPS.h */
+typedef struct CPSProcessSerNum
 {
-	char *base;
-
-	base = strrchr (path, '/');
-	if (base == NULL)
-		return path;
+	UInt32		lo;
+	UInt32		hi;
+} CPSProcessSerNum;
+
+extern OSErr	CPSGetCurrentProcess( CPSProcessSerNum *psn);
+extern OSErr 	CPSEnableForegroundOperation( CPSProcessSerNum *psn, UInt32 _arg2, UInt32 _arg3, UInt32 _arg4, UInt32 _arg5);
+extern OSErr	CPSSetFrontProcess( CPSProcessSerNum *psn);
+
+#endif /* SDL_USE_CPS */
+
+static int    gArgc;
+static char  **gArgv;
+static BOOL   gFinderLaunch;
+static BOOL   gCalledAppMainline = FALSE;
 
-	return (base + 1);
-}
-
-/* Set the working directory to the .app's parent directory */
-- (void) setupWorkingDirectory:(BOOL)shouldChdir
+static NSString *getApplicationName(void)
 {
-	char origindir[PATH_MAX];
-	char *c;
-
-	if (!shouldChdir)
-		return;
+    const NSDictionary *dict;
+    NSString *appName = 0;
 
-	strncpy (origindir, gArgv[0], sizeof origindir);
-	origindir[sizeof origindir - 1] = '\0';
+    /* Determine the application name */
+    dict = (const NSDictionary *)CFBundleGetInfoDictionary(CFBundleGetMainBundle());
+    if (dict)
+        appName = [dict objectForKey: @"CFBundleName"];
+    
+    if (![appName length])
+        appName = [[NSProcessInfo processInfo] processName];
 
-	c = basename (origindir);
-	if (c == origindir)
-		strcpy (origindir, ".");
-	else
-		*c = '\0';
-
-	/* chdir to the binary app's point of origin */
-	if (chdir (origindir) != 0)
-		abort ();
-	/* then chdir to the .app's parent */
-	if ( chdir ("../Resources/") != 0 )
-		abort();
+    return appName;
 }
 
-void
-setupAppleMenu (void)
-{
-	NSMenu *appleMenu;
-
-	NSMenuItem *menuItem;
-	NSString *title;
-	NSString *appName;
-
-	appName = [NSString stringWithUTF8String:basename (gArgv[0])];
-	appleMenu = [[NSMenu alloc] initWithTitle:appName];
+#if SDL_USE_NIB_FILE
+/* A helper category for NSString */
+@interface NSString (ReplaceSubString)
+- (NSString *)stringByReplacingRange:(NSRange)aRange with:(NSString *)aString;
+@end
+#endif
 
-	/* Add menu items */
-	title = [@"Hide " stringByAppendingString:appName];
-	[appleMenu addItemWithTitle:title action:@selector(hide:)
-			keyEquivalent:@"h"];
+@interface NSApplication (SDLApplication)
+@end
 
-	menuItem = (NSMenuItem *)[appleMenu addItemWithTitle:@"Hide Others"
-			action:@selector(hideOtherApplications:)
-			keyEquivalent:@"h"];
-	[menuItem setKeyEquivalentModifierMask:(NSAlternateKeyMask|NSCommandKeyMask)];
+@implementation NSApplication (SDLApplication)
+/* Invoked from the Quit menu item */
+- (void)terminate:(id)sender
+{
+    /* Post a SDL_QUIT event */
+    SDL_Event event;
+    event.type = SDL_QUIT;
+    SDL_PushEvent(&event);
+}
+@end
 
-	[appleMenu addItemWithTitle:@"Show All"
-			action:@selector(unhideAllApplications:)
-			keyEquivalent:@""];
+/* The main class of the application, the application's delegate */
+@implementation SDLMain
 
-	[appleMenu addItem:[NSMenuItem separatorItem]];
+/* Set the working directory to the .app's parent directory */
+- (void) setupWorkingDirectory:(BOOL)shouldChdir
+{
+    if (shouldChdir)
+    {
+        char parentdir[MAXPATHLEN];
+        CFURLRef url = CFBundleCopyBundleURL(CFBundleGetMainBundle());
+        CFURLRef url2 = CFURLCreateCopyDeletingLastPathComponent(0, url);
+        if (CFURLGetFileSystemRepresentation(url2, 1, (UInt8 *)parentdir, MAXPATHLEN)) {
+            chdir(parentdir);   /* chdir to the binary app's parent */
+        }
+        CFRelease(url);
+        CFRelease(url2);
+    }
+}
 
-	title = [@"Quit " stringByAppendingString:appName];
-	[appleMenu addItemWithTitle:title action:@selector(terminate:)
-			keyEquivalent:@"q"];
+#if SDL_USE_NIB_FILE
 
-	/* Put menu into the menubar */
-	menuItem = [[NSMenuItem alloc] initWithTitle:@"" action:nil
-			keyEquivalent:@""];
-	[menuItem setSubmenu:appleMenu];
-	[[NSApp mainMenu] addItem:menuItem];
+/* Fix menu to contain the real app name instead of "SDL App" */
+- (void)fixMenu:(NSMenu *)aMenu withAppName:(NSString *)appName
+{
+    NSRange aRange;
+    NSEnumerator *enumerator;
+    NSMenuItem *menuItem;
+
+    aRange = [[aMenu title] rangeOfString:@"SDL App"];
+    if (aRange.length != 0)
+        [aMenu setTitle: [[aMenu title] stringByReplacingRange:aRange with:appName]];
+
+    enumerator = [[aMenu itemArray] objectEnumerator];
+    while ((menuItem = [enumerator nextObject]))
+    {
+        aRange = [[menuItem title] rangeOfString:@"SDL App"];
+        if (aRange.length != 0)
+            [menuItem setTitle: [[menuItem title] stringByReplacingRange:aRange with:appName]];
+        if ([menuItem hasSubmenu])
+            [self fixMenu:[menuItem submenu] withAppName:appName];
+    }
+}
 
-	/* Tell the application object that this is now the application menu */
-	[NSApp setAppleMenu:appleMenu];
+#else
 
-	/* Finally give up our references to the objects */
-	[appleMenu release];
-	[menuItem release];
+static void setApplicationMenu(void)
+{
+    /* warning: this code is very odd */
+    NSMenu *appleMenu;
+    NSMenuItem *menuItem;
+    NSString *title;
+    NSString *appName;
+    
+    appName = getApplicationName();
+    appleMenu = [[NSMenu alloc] initWithTitle:@""];
+    
+    /* Add menu items */
+    title = [@"About " stringByAppendingString:appName];
+    [appleMenu addItemWithTitle:title action:@selector(orderFrontStandardAboutPanel:) keyEquivalent:@""];
+
+    [appleMenu addItem:[NSMenuItem separatorItem]];
+
+    title = [@"Hide " stringByAppendingString:appName];
+    [appleMenu addItemWithTitle:title action:@selector(hide:) keyEquivalent:@"h"];
+
+    menuItem = (NSMenuItem *)[appleMenu addItemWithTitle:@"Hide Others" action:@selector(hideOtherApplications:) keyEquivalent:@"h"];
+    [menuItem setKeyEquivalentModifierMask:(NSAlternateKeyMask|NSCommandKeyMask)];
+
+    [appleMenu addItemWithTitle:@"Show All" action:@selector(unhideAllApplications:) keyEquivalent:@""];
+
+    [appleMenu addItem:[NSMenuItem separatorItem]];
+
+    title = [@"Quit " stringByAppendingString:appName];
+    [appleMenu addItemWithTitle:title action:@selector(terminate:) keyEquivalent:@"q"];
+
+    
+    /* Put menu into the menubar */
+    menuItem = [[NSMenuItem alloc] initWithTitle:@"" action:nil keyEquivalent:@""];
+    [menuItem setSubmenu:appleMenu];
+    [[NSApp mainMenu] addItem:menuItem];
+
+    /* Tell the application object that this is now the application menu */
+    [NSApp setAppleMenu:appleMenu];
+
+    /* Finally give up our references to the objects */
+    [appleMenu release];
+    [menuItem release];
 }
 
 /* Create a window menu */
-void
-setupWindowMenu (void)
+static void setupWindowMenu(void)
 {
-	NSMenu *windowMenu;
-	NSMenuItem *windowMenuItem;
-	NSMenuItem *menuItem;
-
-	windowMenu = [[NSMenu alloc] initWithTitle:@"Window"];
-
-	/* "Minimize" item */
-	menuItem = [[NSMenuItem alloc] initWithTitle:@"Minimize"
-			action:@selector(performMiniaturize:)
-			keyEquivalent:@"m"];
-	[windowMenu addItem:menuItem];
-	[menuItem release];
-
-	/* Put menu into the menubar */
-	windowMenuItem = [[NSMenuItem alloc] initWithTitle:@"Window"
-			action:nil keyEquivalent:@""];
-	[windowMenuItem setSubmenu:windowMenu];
-	[[NSApp mainMenu] addItem:windowMenuItem];
-
-	/* Tell the application object that this is now the window menu */
-	[NSApp setWindowsMenu:windowMenu];
-
-	/* Finally give up our references to the objects */
-	[windowMenu release];
-	[windowMenuItem release];
+    NSMenu      *windowMenu;
+    NSMenuItem  *windowMenuItem;
+    NSMenuItem  *menuItem;
+
+    windowMenu = [[NSMenu alloc] initWithTitle:@"Window"];
+    
+    /* "Minimize" item */
+    menuItem = [[NSMenuItem alloc] initWithTitle:@"Minimize" action:@selector(performMiniaturize:) keyEquivalent:@"m"];
+    [windowMenu addItem:menuItem];
+    [menuItem release];
+    
+    /* Put menu into the menubar */
+    windowMenuItem = [[NSMenuItem alloc] initWithTitle:@"Window" action:nil keyEquivalent:@""];
+    [windowMenuItem setSubmenu:windowMenu];
+    [[NSApp mainMenu] addItem:windowMenuItem];
+    
+    /* Tell the application object that this is now the window menu */
+    [NSApp setWindowsMenu:windowMenu];
+
+    /* Finally give up our references to the objects */
+    [windowMenu release];
+    [windowMenuItem release];
 }
 
 /* Replacement for NSApplicationMain */
-void
-CustomApplicationMain (int argc, char **argv)
+static void CustomApplicationMain (int argc, char **argv)
 {
-	NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
-	SDLMain *sdlMain;
-
-	/* Ensure the application object is initialised */
-	[SDLApplication sharedApplication];
-
-	/* Set up the menubar */
-	[NSApp setMainMenu:[[NSMenu alloc] init]];
-	setupAppleMenu ();
-	setupWindowMenu ();
+    NSAutoreleasePool	*pool = [[NSAutoreleasePool alloc] init];
+    SDLMain				*sdlMain;
 
-	/* Create SDLMain and make it the app delegate */
-	sdlMain = [[SDLMain alloc] init];
-	[NSApp setDelegate:sdlMain];
+    /* Ensure the application object is initialised */
+    [NSApplication sharedApplication];
+    
+#ifdef SDL_USE_CPS
+    {
+        CPSProcessSerNum PSN;
+        /* Tell the dock about us */
+        if (!CPSGetCurrentProcess(&PSN))
+            if (!CPSEnableForegroundOperation(&PSN,0x03,0x3C,0x2C,0x1103))
+                if (!CPSSetFrontProcess(&PSN))
+                    [NSApplication sharedApplication];
+    }
+#endif /* SDL_USE_CPS */
+
+    /* Set up the menubar */
+    [NSApp setMainMenu:[[NSMenu alloc] init]];
+    setApplicationMenu();
+    setupWindowMenu();
+
+    /* Create SDLMain and make it the app delegate */
+    sdlMain = [[SDLMain alloc] init];
+    [NSApp setDelegate:sdlMain];
+    
+    /* Start the main event loop */
+    [NSApp run];
+    
+    [sdlMain release];
+    [pool release];
+}
 
-	/* Start the main event loop */
-	[NSApp run];
+#endif
 
-	[sdlMain release];
-	[pool release];
 
-	(void) argc;  /* Get rid of unused variable warning */
-	(void) argv;  /* Get rid of unused variable warning */
+/*
+ * Catch document open requests...this lets us notice files when the app
+ *  was launched by double-clicking a document, or when a document was
+ *  dragged/dropped on the app's icon. You need to have a
+ *  CFBundleDocumentsType section in your Info.plist to get this message,
+ *  apparently.
+ *
+ * Files are added to gArgv, so to the app, they'll look like command line
+ *  arguments. Previously, apps launched from the finder had nothing but
+ *  an argv[0].
+ *
+ * This message may be received multiple times to open several docs on launch.
+ *
+ * This message is ignored once the app's mainline has been called.
+ */
+- (BOOL)application:(NSApplication *)theApplication openFile:(NSString *)filename
+{
+    const char *temparg;
+    size_t arglen;
+    char *arg;
+    char **newargv;
+
+    if (!gFinderLaunch)  /* MacOS is passing command line args. */
+        return FALSE;
+
+    if (gCalledAppMainline)  /* app has started, ignore this document. */
+        return FALSE;
+
+    temparg = [filename UTF8String];
+    arglen = SDL_strlen(temparg) + 1;
+    arg = (char *) SDL_malloc(arglen);
+    if (arg == NULL)
+        return FALSE;
+
+    newargv = (char **) realloc(gArgv, sizeof (char *) * (gArgc + 2));
+    if (newargv == NULL)
+    {
+        SDL_free(arg);
+        return FALSE;
+    }
+    gArgv = newargv;
+
+    SDL_strlcpy(arg, temparg, arglen);
+    gArgv[gArgc++] = arg;
+    gArgv[gArgc] = NULL;
+    return TRUE;
 }
 
+
 /* Called when the internal event loop has just started running */
 - (void) applicationDidFinishLaunching: (NSNotification *) note
 {
-	int status;
-
-	/* Set the working directory to the .app's parent directory */
-	[self setupWorkingDirectory:gFinderLaunch];
+    int status;
 
-	/* allow Cocoa to hear keystrokes like Command-Q, etc. */
-	setenv ("SDL_ENABLEAPPEVENTS", "1", 1);
+    /* Set the working directory to the .app's parent directory */
+    [self setupWorkingDirectory:gFinderLaunch];
 
-	/* Hand off to main application code */
-	status = SDL_main (gArgc, gArgv);
+#if SDL_USE_NIB_FILE
+    /* Set the main menu to contain the real app name instead of "SDL App" */
+    [self fixMenu:[NSApp mainMenu] withAppName:getApplicationName()];
+#endif
 
-	/* We're done, thank you for playing */
-	exit (status);
+    /* Hand off to main application code */
+    gCalledAppMainline = TRUE;
+    status = SDL_main (gArgc, gArgv);
 
-	(void) note;  /* Get rid of unused variable warning */
+    /* We're done, thank you for playing */
+    exit(status);
 }
 @end
 
+
 @implementation NSString (ReplaceSubString)
 
-- (NSString *) stringByReplacingRange:(NSRange)aRange with:(NSString *)aString
+- (NSString *)stringByReplacingRange:(NSRange)aRange with:(NSString *)aString
 {
-	unsigned int bufferSize;
-	unsigned int selfLen = [self length];
-	unsigned int aStringLen = [aString length];
-	unichar *buffer;
-	NSRange localRange;
-	NSString *result;
-
-	bufferSize = selfLen + aStringLen - aRange.length;
-	buffer = NSAllocateMemoryPages (bufferSize * sizeof (unichar));
-
-	/* Get first part into buffer */
-	localRange.location = 0;
-	localRange.length = aRange.location;
-	[self getCharacters:buffer range:localRange];
-
-	/* Get middle part into buffer */
-	localRange.location = 0;
-	localRange.length = aStringLen;
-	[aString getCharacters:(buffer + aRange.location) range:localRange];
-
-	/* Get last part into buffer */
-	localRange.location = aRange.location + aRange.length;
-	localRange.length = selfLen - localRange.location;
-	[self getCharacters:(buffer + aRange.location+aStringLen)
-			range:localRange];
-
-	/* Build output string */
-	result = [NSString stringWithCharacters:buffer length:bufferSize];
-
-	NSDeallocateMemoryPages (buffer, bufferSize);
-
-	return result;
+    unsigned int bufferSize;
+    unsigned int selfLen = [self length];
+    unsigned int aStringLen = [aString length];
+    unichar *buffer;
+    NSRange localRange;
+    NSString *result;
+
+    bufferSize = selfLen + aStringLen - aRange.length;
+    buffer = (unichar *)NSAllocateMemoryPages(bufferSize*sizeof(unichar));
+    
+    /* Get first part into buffer */
+    localRange.location = 0;
+    localRange.length = aRange.location;
+    [self getCharacters:buffer range:localRange];
+    
+    /* Get middle part into buffer */
+    localRange.location = 0;
+    localRange.length = aStringLen;
+    [aString getCharacters:(buffer+aRange.location) range:localRange];
+     
+    /* Get last part into buffer */
+    localRange.location = aRange.location + aRange.length;
+    localRange.length = selfLen - localRange.location;
+    [self getCharacters:(buffer+aRange.location+aStringLen) range:localRange];
+    
+    /* Build output string */
+    result = [NSString stringWithCharacters:buffer length:bufferSize];
+    
+    NSDeallocateMemoryPages(buffer, bufferSize);
+    
+    return result;
 }
 
 @end
 
+
+
 #ifdef main
 #  undef main
 #endif
 
+
 /* Main entry point to executable - should *not* be SDL_main! */
-int
-main (int argc, char **argv)
+int main (int argc, char **argv)
 {
-	/* Copy the arguments into a global variable */
-	int i;
-
-	/* If we are launched by double-clicking, argv[1] is "-psn_<some_number> */
-	if ( argc >= 2 && strncmp (argv[1], "-psn_", 5) == 0 ) {
-		gArgc = 1;
-		gFinderLaunch = YES;
-	} else {
-		gArgc = argc;
-		gFinderLaunch = NO;
-	}
-	gArgv = (char **) malloc (sizeof *gArgv * (gArgc + 1));
-	if (gArgv == NULL)
-		abort ();
-	for (i = 0; i < gArgc; i++)
-		gArgv[i] = argv[i];
-	gArgv[i] = NULL;
-
-	CustomApplicationMain (argc, argv);
-	free (gArgv);
-	return 0;
+    /* Copy the arguments into a global variable */
+    /* This is passed if we are launched by double-clicking */
+    if ( argc >= 2 && strncmp (argv[1], "-psn", 4) == 0 ) {
+        gArgv = (char **) SDL_malloc(sizeof (char *) * 2);
+        gArgv[0] = argv[0];
+        gArgv[1] = NULL;
+        gArgc = 1;
+        gFinderLaunch = YES;
+    } else {
+        int i;
+        gArgc = argc;
+        gArgv = (char **) SDL_malloc(sizeof (char *) * (argc+1));
+        for (i = 0; i <= argc; i++)
+            gArgv[i] = argv[i];
+        gFinderLaunch = NO;
+    }
+
+#if SDL_USE_NIB_FILE
+    NSApplicationMain (argc, argv);
+#else
+    CustomApplicationMain (argc, argv);
+#endif
+    return 0;
 }
 
-
diff -ruNp src.orig/endian_uqm.h src/endian_uqm.h
--- src.orig/endian_uqm.h	2017-11-21 19:39:28 -0600
+++ src/endian_uqm.h	2017-11-21 19:39:43 -0600
@@ -61,6 +61,11 @@
 #define UQM_Swap32  __arch__swab32
 #endif
 #endif /* linux */
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 /* Use inline functions for compilers that support them, and static
    functions for those that do not.  Because these functions become
    static for compilers that do not support inline functions, this
@@ -124,4 +129,8 @@ static __inline__ uint64 UQM_Swap64(uint
 #define UQM_SwapBE64(X)	(X)
 #endif
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _ENDIAN_H */
diff -ruNp src.orig/getopt/Makeinfo src/getopt/Makeinfo
--- src.orig/getopt/Makeinfo	2017-11-21 19:39:28 -0600
+++ src/getopt/Makeinfo	2017-11-21 19:39:43 -0600
@@ -1 +1,2 @@
 uqm_CFILES="getopt.c getopt1.c"
+uqm_HFILES="getopt.h"
diff -ruNp src.orig/libs/Makeinfo src/libs/Makeinfo
--- src.orig/libs/Makeinfo	2017-11-21 19:39:30 -0600
+++ src/libs/Makeinfo	2017-11-21 19:39:46 -0600
@@ -1,9 +1,13 @@
 uqm_SUBDIRS="callback decomp file graphics heap input list math memory
-		resource sound strings task threads time uio video log"
+		resource sound strings task threads time uio video log luauqm"
 if [ -n "$uqm_USE_INTERNAL_MIKMOD" ]; then
 	uqm_SUBDIRS="$uqm_SUBDIRS mikmod"
 fi
 
+if [ -n "$uqm_USE_INTERNAL_LUA" ]; then
+	uqm_SUBDIRS="$uqm_SUBDIRS lua"
+fi
+
 if [ -n "$uqm_NETPLAY" ]; then
 	uqm_SUBDIRS="$uqm_SUBDIRS network"
 fi
@@ -12,3 +16,9 @@ fi
 #	uqm_SUBDIRS="$UQM_SUBDIRS debug"
 #fi
 
+uqm_HFILES="alarm.h async.h callback.h cdplib.h compiler.h declib.h file.h
+		gfxlib.h heap.h inplib.h list.h log.h mathlib.h md5.h memlib.h
+		misc.h net.h platform.h reslib.h scriptlib.h sndlib.h
+		strlib.h tasklib.h threadlib.h timelib.h uio.h uioutils.h
+		unicode.h vidlib.h"
+
diff -ruNp src.orig/libs/alarm.h src/libs/alarm.h
--- src.orig/libs/alarm.h	2017-11-21 19:39:28 -0600
+++ src/libs/alarm.h	2017-11-21 19:39:43 -0600
@@ -1,2 +1,9 @@
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #include "callback/alarm.h"
 
+#if defined(__cplusplus)
+}
+#endif
diff -ruNp src.orig/libs/async.h src/libs/async.h
--- src.orig/libs/async.h	1969-12-31 18:00:00 -0600
+++ src/libs/async.h	2017-11-21 19:39:43 -0600
@@ -0,0 +1,10 @@
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+#include "callback/async.h"
+
+#if defined(__cplusplus)
+}
+#endif
+
diff -ruNp src.orig/libs/callback/Makeinfo src/libs/callback/Makeinfo
--- src.orig/libs/callback/Makeinfo	2017-11-21 19:39:28 -0600
+++ src/libs/callback/Makeinfo	2017-11-21 19:39:43 -0600
@@ -1,2 +1,2 @@
-uqm_CFILES="alarm.c callback.c"
-
+uqm_CFILES="alarm.c async.c callback.c"
+uqm_HFILES="alarm.h async.h callback.h"
diff -ruNp src.orig/libs/callback/alarm.c src/libs/callback/alarm.c
--- src.orig/libs/callback/alarm.c	2017-11-21 19:39:28 -0600
+++ src/libs/callback/alarm.c	2017-11-21 19:39:43 -0600
@@ -18,6 +18,7 @@
 
 #include "alarm.h"
 
+#include SDL_INCLUDE(SDL.h)
 #include "libs/heap.h"
 
 #include <assert.h>
@@ -71,19 +72,36 @@ Alarm_uninit(void) {
 }
 
 static inline AlarmTime
-AlarmTime_nowMS(void) {
+AlarmTime_nowMs(void) {
 	return SDL_GetTicks();
 }
 
 Alarm *
-Alarm_addRelativeMs(Uint32 ms, AlarmCallback callback,
+Alarm_addAbsoluteMs(uint32 ms, AlarmCallback callback,
 		AlarmCallbackArg arg) {
 	Alarm *alarm;
 
 	assert(alarmHeap != NULL);
 
 	alarm = Alarm_alloc();
-	alarm->time = AlarmTime_nowMS() + ms;
+	alarm->time = ms;
+	alarm->callback = callback;
+	alarm->arg = arg;
+
+	Heap_add(alarmHeap, (HeapValue *) alarm);
+
+	return alarm;
+}
+
+Alarm *
+Alarm_addRelativeMs(uint32 ms, AlarmCallback callback,
+		AlarmCallbackArg arg) {
+	Alarm *alarm;
+
+	assert(alarmHeap != NULL);
+
+	alarm = Alarm_alloc();
+	alarm->time = AlarmTime_nowMs() + ms;
 	alarm->callback = callback;
 	alarm->arg = arg;
 
@@ -99,15 +117,40 @@ Alarm_remove(Alarm *alarm) {
 	Alarm_free(alarm);
 }
 
+// Process at most one alarm, if its time has come.
+// It is safe to call this function again from inside a callback function
+// that it called. It should not be called from multiple threads at once.
+bool
+Alarm_processOne(void)
+{
+	AlarmTime now;
+	Alarm *alarm;
+	
+	assert(alarmHeap != NULL);
+	if (!Heap_hasMore(alarmHeap))
+		return false;
+	
+	now = AlarmTime_nowMs();
+	alarm = (Alarm *) Heap_first(alarmHeap);
+	if (now < alarm->time)
+		return false;
+
+	Heap_pop(alarmHeap);
+	alarm->callback(alarm->arg);
+	Alarm_free(alarm);
+	return true;
+}
+
+#if 0
 // It is safe to call this function again from inside a callback function
 // that it called. It should not be called from multiple threads at once.
 void
-Alarm_process(void) {
+Alarm_processAll(void) {
 	AlarmTime now;
 
 	assert(alarmHeap != NULL);
 	
-	now = AlarmTime_nowMS();
+	now = AlarmTime_nowMs();
 	while (Heap_hasMore(alarmHeap)) {
 		Alarm *alarm = (Alarm *) Heap_first(alarmHeap);
 
@@ -119,8 +162,9 @@ Alarm_process(void) {
 		Alarm_free(alarm);
 	}
 }
+#endif
 
-Uint32
+uint32
 Alarm_timeBeforeNextMs(void) {
 	Alarm *alarm;
 
@@ -131,4 +175,3 @@ Alarm_timeBeforeNextMs(void) {
 	return alarmTimeToMsUint32(alarm->time);
 }
 
-
diff -ruNp src.orig/libs/callback/alarm.h src/libs/callback/alarm.h
--- src.orig/libs/callback/alarm.h	2017-11-21 19:39:28 -0600
+++ src/libs/callback/alarm.h	2017-11-21 19:39:43 -0600
@@ -22,11 +22,10 @@
 #include "port.h"
 #include "types.h"
 
-#include SDL_INCLUDE(SDL.h)
-typedef Uint32 AlarmTime;
-static inline Uint32
+typedef uint32 AlarmTime;
+static inline uint32
 alarmTimeToMsUint32(AlarmTime time) {
-	return (Uint32) time;
+	return (uint32) time;
 }
 
 typedef struct Alarm Alarm;
@@ -44,11 +43,14 @@ struct Alarm {
 
 void Alarm_init(void);
 void Alarm_uninit(void);
-Alarm *Alarm_addRelativeMs(Uint32 ms, AlarmCallback callback,
+Alarm *Alarm_addAbsoluteMs(uint32 ms, AlarmCallback callback,
+		AlarmCallbackArg arg);
+Alarm *Alarm_addRelativeMs(uint32 ms, AlarmCallback callback,
 		AlarmCallbackArg arg);
 void Alarm_remove(Alarm *alarm);
-void Alarm_process(void);
-Uint32 Alarm_timeBeforeNextMs(void);
+bool Alarm_processOne(void);
+void Alarm_processAll(void);
+uint32 Alarm_timeBeforeNextMs(void);
 
 #endif  /* _ALARM_H */
 
diff -ruNp src.orig/libs/callback/async.c src/libs/callback/async.c
--- src.orig/libs/callback/async.c	1969-12-31 18:00:00 -0600
+++ src/libs/callback/async.c	2017-11-21 19:39:43 -0600
@@ -0,0 +1,56 @@
+/*
+ *  Copyright 2012  Serge van den Boom <svdb@stack.nl>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "async.h"
+
+#include "libs/alarm.h"
+#include "libs/callback.h"
+
+
+// Process all alarms and callbacks.
+// First, all scheduled callbacks are called.
+// Then each alarm due is called, and after each of these alarms, the
+// callbacks scheduled by this alarm are called.
+void
+Async_process(void)
+{
+	// Call pending callbacks.
+	Callback_process();
+
+	for (;;) {
+		if (!Alarm_processOne())
+			return;
+
+		// Call callbacks scheduled from the last alarm.
+		Callback_process();
+	}
+}
+
+// Returns the next time that some asynchronous callback is
+// to be called. Note that all values lower than the current time
+// should be considered as 'somewhere in the past'.
+uint32
+Async_timeBeforeNextMs(void) {
+	if (Callback_haveMore()) {
+		// Any time before the current time is ok, though we reserve 0 so
+		// that the caller may use it as a special value in its own code.
+		return 1;
+	}
+	return Alarm_timeBeforeNextMs();
+}
+
diff -ruNp src.orig/libs/callback/async.h src/libs/callback/async.h
--- src.orig/libs/callback/async.h	1969-12-31 18:00:00 -0600
+++ src/libs/callback/async.h	2017-11-21 19:39:43 -0600
@@ -0,0 +1,28 @@
+/*
+ *  Copyright 2012  Serge van den Boom <svdb@stack.nl>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _ASYNC_H
+#define _ASYNC_H
+
+#include "types.h"
+
+void Async_process(void);
+uint32 Async_timeBeforeNextMs(void);
+
+#endif  /* _ASYNC_H */
+
diff -ruNp src.orig/libs/callback/callback.c src/libs/callback/callback.c
--- src.orig/libs/callback/callback.c	2017-11-21 19:39:28 -0600
+++ src/libs/callback/callback.c	2017-11-21 19:39:43 -0600
@@ -23,6 +23,8 @@
 #include <stdlib.h>
 #include <sys/types.h>
 
+#include "libs/threadlib.h"
+
 typedef struct CallbackLink CallbackLink;
 
 #define CALLBACK_INTERNAL
@@ -38,16 +40,16 @@ static CallbackLink *callbacks;
 static CallbackLink **callbacksEnd;
 static CallbackLink *const *callbacksProcessEnd;
 
+static Mutex callbackListLock;
+
 static inline void
 CallbackList_lock(void) {
-	// TODO
-	// Necessary for reentrant operation
+	LockMutex(callbackListLock);
 }
 
 static inline void
 CallbackList_unlock(void) {
-	// TODO
-	// Necessary for reentrant operation
+	UnlockMutex(callbackListLock);
 }
 
 #if 0
@@ -62,6 +64,14 @@ Callback_init(void) {
 	callbacks = NULL;
 	callbacksEnd = &callbacks;
 	callbacksProcessEnd = &callbacks;
+	callbackListLock = CreateMutex("Callback List Lock", SYNC_CLASS_TOPLEVEL);
+}
+
+void
+Callback_uninit(void) {
+	// TODO: cleanup the queue?
+	DestroyMutex (callbackListLock);
+	callbackListLock = 0;
 }
 
 // Callbacks are guaranteed to be called in the order that they are queued.
@@ -170,4 +180,14 @@ Callback_process(void) {
 	}
 }
 
+bool
+Callback_haveMore(void) {
+	bool result;
+
+	CallbackList_lock();
+	result = (callbacks != NULL);
+	CallbackList_unlock();
+
+	return result;
+}
 
diff -ruNp src.orig/libs/callback/callback.h src/libs/callback/callback.h
--- src.orig/libs/callback/callback.h	2017-11-21 19:39:28 -0600
+++ src/libs/callback/callback.h	2017-11-21 19:39:43 -0600
@@ -33,9 +33,11 @@ typedef void *CallbackArg;
 typedef void (*CallbackFunction)(CallbackArg arg);
 
 void Callback_init(void);
+void Callback_uninit(void);
 CallbackID Callback_add(CallbackFunction callback, CallbackArg arg);
 bool Callback_remove(CallbackID id);
 void Callback_process(void);
+bool Callback_haveMore(void);
 
 #endif  /* _CALLBACK_H */
 
diff -ruNp src.orig/libs/callback.h src/libs/callback.h
--- src.orig/libs/callback.h	2017-11-21 19:39:28 -0600
+++ src/libs/callback.h	2017-11-21 19:39:43 -0600
@@ -1,2 +1,10 @@
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #include "callback/callback.h"
 
+#if defined(__cplusplus)
+}
+#endif
+
diff -ruNp src.orig/libs/cdp/Makeinfo src/libs/cdp/Makeinfo
--- src.orig/libs/cdp/Makeinfo	2017-11-21 19:39:28 -0600
+++ src/libs/cdp/Makeinfo	2017-11-21 19:39:43 -0600
@@ -1 +1,3 @@
 uqm_CFILES="cdp.c cdpapi.c"
+uqm_HFILES="cdp_alli.h cdpapi.h cdp.h cdp_iio.h cdp_imem.h cdpint.h
+		cdp_isnd.h cdp_ivid.h cdpmod.h windl.h"
diff -ruNp src.orig/libs/cdplib.h src/libs/cdplib.h
--- src.orig/libs/cdplib.h	2017-11-21 19:39:29 -0600
+++ src/libs/cdplib.h	2017-11-21 19:39:43 -0600
@@ -19,6 +19,14 @@
 #ifndef _CDPLIB_H
 #define _CDPLIB_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #include "cdp/cdp.h"
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _CDPLIB_H */
diff -ruNp src.orig/libs/compiler.h src/libs/compiler.h
--- src.orig/libs/compiler.h	2017-11-21 19:39:29 -0600
+++ src/libs/compiler.h	2017-11-21 19:39:43 -0600
@@ -21,6 +21,10 @@
 
 #include "types.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef uint8             BYTE;
 typedef uint8             UBYTE;
 typedef sint8             SBYTE;
@@ -85,5 +89,9 @@ typedef DWORD    (*PDWORDFUNC) (void);
 #	define _ALIGNED_ON(bytes)
 #endif
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _COMPILER_H */
 
diff -ruNp src.orig/libs/declib.h src/libs/declib.h
--- src.orig/libs/declib.h	2017-11-21 19:39:29 -0600
+++ src/libs/declib.h	2017-11-21 19:39:44 -0600
@@ -20,6 +20,11 @@
 #define _DECLIB_H
 
 #include "libs/compiler.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef struct _LZHCODE_DESC* DECODE_REF;
 
 enum
@@ -45,4 +50,8 @@ extern COUNT cread (void *pStr, COUNT si
 extern COUNT cwrite (const void *pStr, COUNT size, COUNT count,
 		DECODE_REF DecodeRef);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _DECLIB_H */
diff -ruNp src.orig/libs/decomp/Makeinfo src/libs/decomp/Makeinfo
--- src.orig/libs/decomp/Makeinfo	2017-11-21 19:39:29 -0600
+++ src/libs/decomp/Makeinfo	2017-11-21 19:39:44 -0600
@@ -1 +1,2 @@
 uqm_CFILES="lzdecode.c lzencode.c update.c"
+uqm_HFILES="lzh.h"
diff -ruNp src.orig/libs/file/Makeinfo src/libs/file/Makeinfo
--- src.orig/libs/file/Makeinfo	2017-11-21 19:39:29 -0600
+++ src/libs/file/Makeinfo	2017-11-21 19:39:44 -0600
@@ -1 +1,2 @@
 uqm_CFILES="dirs.c files.c"
+uqm_HFILES="filintrn.h"
diff -ruNp src.orig/libs/file/dirs.c src/libs/file/dirs.c
--- src.orig/libs/file/dirs.c	2017-11-21 19:39:29 -0600
+++ src/libs/file/dirs.c	2017-11-21 19:39:44 -0600
@@ -142,7 +142,7 @@ mkdirhier (const char *path)
 
 	if (*pathstart == '\0') {
 		// path exists completely, nothing more to do
-		return 0;
+		goto success;
 	}
 
 	// walk through the path as long as the components exist
@@ -177,7 +177,7 @@ mkdirhier (const char *path)
 		}
 		
 		if (*pathend == '\0')
-			return 0;
+			goto success;
 
 		*ptr = '/';
 		ptr++;
@@ -187,7 +187,7 @@ mkdirhier (const char *path)
 		// pathstart is the next non-slash character
 
 		if (*pathstart == '\0')
-			return 0;
+			goto success;
 	}
 	
 	// create all components left
@@ -221,6 +221,9 @@ mkdirhier (const char *path)
 		ptr += pathend - pathstart;
 		*ptr = '\0';
 	}
+
+success:
+	HFree (buf);
 	return 0;
 
 err:
@@ -641,6 +644,7 @@ expandPath (char *dest, size_t len, cons
 		*destptr = '\0';
 	}
 	
+	HFree (buf);
 	return 0;
 
 err:
@@ -656,7 +660,7 @@ err:
 		// This code is only needed if we have a current working directory
 		// per drive.
 // letter is 0 based: 0 = A, 1 = B, ...
-bool
+static bool
 driveLetterExists(int letter)
 {
 	unsigned long drives;
diff -ruNp src.orig/libs/file/files.c src/libs/file/files.c
--- src.orig/libs/file/files.c	2017-11-21 19:39:29 -0600
+++ src/libs/file/files.c	2017-11-21 19:39:44 -0600
@@ -94,7 +94,7 @@ copyFile (uio_DirHandle *srcDir, const c
 	buf = HMalloc(BUFSIZE);
 			// This was originally a statically allocated buffer,
 			// but as this function might be run from a thread with
-			// a small Stack, this is better.
+			// a small stack, this is better.
 	while (1)
 	{
 		numInBuf = uio_read (src, buf, BUFSIZE);
diff -ruNp src.orig/libs/file.h src/libs/file.h
--- src.orig/libs/file.h	2017-11-21 19:39:29 -0600
+++ src/libs/file.h	2017-11-21 19:39:44 -0600
@@ -25,6 +25,10 @@
 // for bool
 #include "types.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #if 0
 // from temp.h
 void initTempDir (void);
@@ -83,5 +87,9 @@ static inline int isDriveLetter(int c)
 }
 #endif  /* HAVE_DRIVE_LETTERS */
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _FILE_H */
 
diff -ruNp src.orig/libs/gfxlib.h src/libs/gfxlib.h
--- src.orig/libs/gfxlib.h	2017-11-21 19:39:29 -0600
+++ src/libs/gfxlib.h	2017-11-21 19:39:44 -0600
@@ -32,6 +32,10 @@ struct Color {
 
 #include "libs/reslib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef struct context_desc CONTEXT_DESC;
 typedef struct frame_desc FRAME_DESC;
 typedef struct font_desc FONT_DESC;
@@ -227,8 +231,16 @@ typedef struct text
 	COUNT CharCount;
 } TEXT;
 
+#if defined(__cplusplus)
+}
+#endif
+
 #include "libs/strlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef STRING_TABLE COLORMAP_REF;
 typedef STRING COLORMAP;
 // COLORMAPPTR is really a pointer to colortable entry structure
@@ -237,6 +249,7 @@ typedef void *COLORMAPPTR;
 
 #include "graphics/prim.h"
 
+
 typedef BYTE BATCH_FLAGS;
 // This flag is currently unused but it might make sense to restore it
 #define BATCH_BUILD_PAGE (BATCH_FLAGS)(1 << 0)
@@ -454,4 +467,8 @@ extern COLORMAPPTR GetColorMapAddress (C
 void SetSystemRect (const RECT *pRect);
 void ClearSystemRect (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _GFXLIB_H */
diff -ruNp src.orig/libs/graphics/Makeinfo src/libs/graphics/Makeinfo
--- src.orig/libs/graphics/Makeinfo	2017-11-21 19:39:29 -0600
+++ src/libs/graphics/Makeinfo	2017-11-21 19:39:44 -0600
@@ -7,3 +7,6 @@ uqm_CFILES="boxint.c clipline.c cmap.c c
 		font.c frame.c gfx_common.c intersec.c loaddisp.c
 		pixmap.c resgfx.c tfb_draw.c tfb_prim.c widgets.c"
 
+uqm_HFILES="bbox.h cmap.h context.h dcqueue.h drawable.h drawcmd.h font.h
+		gfx_common.h gfxintrn.h prim.h tfb_draw.h tfb_prim.h widgets.h"
+
diff -ruNp src.orig/libs/graphics/cmap.c src/libs/graphics/cmap.c
--- src.orig/libs/graphics/cmap.c	2017-11-21 19:39:29 -0600
+++ src/libs/graphics/cmap.c	2017-11-21 19:39:44 -0600
@@ -64,6 +64,10 @@ static int mapcount;
 static Mutex maplock;
 
 
+static void release_colormap (TFB_ColorMap *map);
+static void delete_colormap (TFB_ColorMap *map);
+
+
 void
 InitColorMaps (void)
 {
@@ -84,13 +88,23 @@ InitColorMaps (void)
 void
 UninitColorMaps (void)
 {
+	int i;
 	TFB_ColorMap *next;
 
+	for (i = 0; i < MAX_COLORMAPS; ++i)
+	{
+		TFB_ColorMap *map = colormaps[i];
+		if (!map)
+			continue;
+		release_colormap (map);
+		colormaps[i] = 0;
+	}
+
 	// free spares
-	for ( ; poolhead; poolhead = next)
+	for ( ; poolhead; poolhead = next, --poolcount)
 	{
 		next = poolhead->next;
-		HFree (poolhead);
+		delete_colormap (poolhead);
 	}
 
 	DestroyMutex (fadeLock);
@@ -155,6 +169,13 @@ clone_colormap (TFB_ColorMap *from, int
 	return map;
 }
 
+static void
+delete_colormap (TFB_ColorMap *map)
+{
+	FreeNativePalette (map->palette);
+	HFree (map);
+}
+
 static inline void
 free_colormap (TFB_ColorMap *map)
 {
@@ -172,8 +193,7 @@ free_colormap (TFB_ColorMap *map)
 	}
 	else
 	{	// don't need any more spares
-		FreeNativePalette (map->palette);
-		HFree (map);
+		delete_colormap (map);
 	}
 }
 
@@ -193,7 +213,7 @@ get_colormap (int index)
 	return map;
 }
 
-static inline void
+static void
 release_colormap (TFB_ColorMap *map)
 {
 	if (!map)
diff -ruNp src.orig/libs/graphics/context.c src/libs/graphics/context.c
--- src.orig/libs/graphics/context.c	2017-11-21 19:39:29 -0600
+++ src/libs/graphics/context.c	2017-11-21 19:39:44 -0600
@@ -123,6 +123,8 @@ FindContextPtr (CONTEXT context) {
 BOOLEAN
 DestroyContext (CONTEXT ContextRef)
 {
+	TFB_Image *img;
+
 	if (ContextRef == 0)
 		return (FALSE);
 
@@ -139,6 +141,10 @@ DestroyContext (CONTEXT ContextRef)
 	}
 #endif  /* DEBUG */
 
+	img = ContextRef->FontBacking;
+	if (img)
+		TFB_DrawImage_Delete (img);
+
 	FreeContext (ContextRef);
 	return TRUE;
 }
diff -ruNp src.orig/libs/graphics/dcqueue.c src/libs/graphics/dcqueue.c
--- src.orig/libs/graphics/dcqueue.c	2017-11-21 19:39:29 -0600
+++ src/libs/graphics/dcqueue.c	2017-11-21 19:39:44 -0600
@@ -156,8 +156,17 @@ Init_DrawCommandQueue (void)
 void
 Uninit_DrawCommandQueue (void)
 {
-	DestroyCondVar (RenderingCond);
-	DestroyRecursiveMutex (DCQ_Mutex);
+	if (RenderingCond)
+	{
+		DestroyCondVar (RenderingCond);
+		RenderingCond = 0;
+	}
+
+	if (DCQ_Mutex)
+	{
+		DestroyRecursiveMutex (DCQ_Mutex);
+		DCQ_Mutex = 0;
+	}
 }
 
 void
@@ -216,6 +225,30 @@ TFB_DrawCommandQueue_Clear ()
 	UnlockRecursiveMutex (DCQ_Mutex);
 }
 
+static void
+checkExclusiveThread (TFB_DrawCommand* DrawCommand)
+{
+#ifdef DEBUG_DCQ_THREADS
+	static uint32 exclusiveThreadId;
+	extern uint32 SDL_ThreadID(void);
+
+	// Only one thread is currently allowed to enqueue commands
+	// This is not a technical limitation but rather a semantical one atm.
+	if (DrawCommand->Type == TFB_DRAWCOMMANDTYPE_REINITVIDEO)
+	{	// TFB_DRAWCOMMANDTYPE_REINITVIDEO is an exception
+		// It is queued from the main() thread, which is safe to do
+		return;
+	}
+	
+	if (!exclusiveThreadId)
+		exclusiveThreadId = SDL_ThreadID();
+	else
+		assert (SDL_ThreadID() == exclusiveThreadId);
+#else
+	(void) DrawCommand; // suppress unused warning
+#endif
+}
+
 void
 TFB_EnqueueDrawCommand (TFB_DrawCommand* DrawCommand)
 {
@@ -224,6 +257,8 @@ TFB_EnqueueDrawCommand (TFB_DrawCommand*
 		return;
 	}
 
+	checkExclusiveThread (DrawCommand);
+
 	if (DrawCommand->Type <= TFB_DRAWCOMMANDTYPE_COPYTOIMAGE
 			&& _CurFramePtr->Type == SCREEN_DRAWABLE)
 	{
@@ -587,3 +622,49 @@ TFB_FlushGraphics (void)
 	RenderedFrames++;
 	BroadcastCondVar (RenderingCond);
 }
+
+void
+TFB_PurgeDanglingGraphics (void)
+{
+	Lock_DCQ (-1);
+
+	for (;;)
+	{
+		TFB_DrawCommand DC;
+
+		if (!TFB_DrawCommandQueue_Pop (&DC))
+		{
+			// the Queue is now empty.
+			break;
+		}
+
+		switch (DC.Type)
+		{
+			case TFB_DRAWCOMMANDTYPE_DELETEIMAGE:
+			{
+				TFB_Image *DC_image = DC.data.deleteimage.image;
+				TFB_DrawImage_Delete (DC_image);
+				break;
+			}
+			case TFB_DRAWCOMMANDTYPE_DELETEDATA:
+			{
+				void *data = DC.data.deletedata.data;
+				HFree (data);
+				break;
+			}
+			case TFB_DRAWCOMMANDTYPE_IMAGE:
+			{
+				TFB_ColorMap *cmap = DC.data.image.colormap;
+				if (cmap)
+					TFB_ReturnColorMap (cmap);
+				break;
+			}
+			case TFB_DRAWCOMMANDTYPE_SENDSIGNAL:
+			{
+				ClearSemaphore (DC.data.sendsignal.sem);
+				break;
+			}
+		}
+	}
+	Unlock_DCQ ();
+}
diff -ruNp src.orig/libs/graphics/gfx_common.c src/libs/graphics/gfx_common.c
--- src.orig/libs/graphics/gfx_common.c	2017-11-21 19:39:29 -0600
+++ src/libs/graphics/gfx_common.c	2017-11-21 19:39:44 -0600
@@ -99,7 +99,7 @@ UnbatchGraphics (void)
    been processed. */
 
 void
-FlushGraphics ()
+FlushGraphics (void)
 {
 	TFB_DrawScreen_WaitForSignal ();
 }
diff -ruNp src.orig/libs/graphics/gfx_common.h src/libs/graphics/gfx_common.h
--- src.orig/libs/graphics/gfx_common.h	2017-11-21 19:39:29 -0600
+++ src/libs/graphics/gfx_common.h	2017-11-21 19:39:44 -0600
@@ -67,7 +67,7 @@ int TFB_InitGraphics (int driver, int fl
 int TFB_ReInitGraphics (int driver, int flags, int width, int height);
 void TFB_UninitGraphics (void);
 void TFB_ProcessEvents (void);
-void TFB_SetGamma (float gamma);
+bool TFB_SetGamma (float gamma);
 void TFB_UploadTransitionScreen (void);
 // This function should not be called directly
 void TFB_SwapBuffers (int force_full_redraw);
@@ -98,6 +98,7 @@ extern float FrameRate;
 extern int FrameRateTickBase;
 
 void TFB_FlushGraphics (void); // Only call from main thread!!
+void TFB_PurgeDanglingGraphics (void); // Only call from main thread as part of shutdown.
 
 extern int ScreenWidth;
 extern int ScreenHeight;
diff -ruNp src.orig/libs/graphics/gfxload.c src/libs/graphics/gfxload.c
--- src.orig/libs/graphics/gfxload.c	2017-11-21 19:39:29 -0600
+++ src/libs/graphics/gfxload.c	2017-11-21 19:39:44 -0600
@@ -321,15 +321,7 @@ _ReleaseCelData (void *handle)
 		return (FALSE);
 
 	cel_ct = DrawablePtr->MaxIndex + 1;
-
-	if (DrawablePtr->Frame)
-	{
-		FramePtr = DrawablePtr->Frame;
-		if (FramePtr->Type == SCREEN_DRAWABLE)
-		{
-			FramePtr = NULL;
-		}
-	}
+	FramePtr = DrawablePtr->Frame;
 
 	HFree (handle);
 	if (FramePtr)
diff -ruNp src.orig/libs/graphics/sdl/Makeinfo src/libs/graphics/sdl/Makeinfo
--- src.orig/libs/graphics/sdl/Makeinfo	2017-11-21 19:39:29 -0600
+++ src/libs/graphics/sdl/Makeinfo	2017-11-21 19:39:44 -0600
@@ -1,5 +1,8 @@
-uqm_CFILES="opengl.c palette.c primitives.c pure.c sdl_common.c
-		scalers.c 2xscalers.c
-		2xscalers_mmx.c 2xscalers_sse.c 2xscalers_3dnow.c
-		nearest2x.c bilinear2x.c biadv2x.c triscan2x.c hq2x.c
-		canvas.c sdluio.c rotozoom.c"
+uqm_CFILES="opengl.c palette.c primitives.c pure.c sdl_common.c scalers.c
+		2xscalers.c 2xscalers_mmx.c 2xscalers_sse.c 2xscalers_3dnow.c
+		nearest2x.c bilinear2x.c biadv2x.c triscan2x.c hq2x.c canvas.c
+		sdluio.c rotozoom.c"
+uqm_HFILES="2xscalers.h 2xscalers_mmx.h opengl.h palette.h primitives.h
+		pure.h rotozoom.h scaleint.h scalemmx.h scalers.h sdl_common.h
+		sdluio.h"
+
diff -ruNp src.orig/libs/graphics/sdl/opengl.c src/libs/graphics/sdl/opengl.c
--- src.orig/libs/graphics/sdl/opengl.c	2017-11-21 19:39:30 -0600
+++ src/libs/graphics/sdl/opengl.c	2017-11-21 19:39:44 -0600
@@ -69,30 +69,6 @@ static TFB_GRAPHICS_BACKEND opengl_unsca
 	TFB_GL_ColorLayer };
 
 
-static SDL_Surface *
-Create_Screen (SDL_Surface *template, int w, int h)
-{
-	SDL_Surface *newsurf = SDL_CreateRGBSurface(SDL_SWSURFACE, w, h,
-			template->format->BitsPerPixel,
-			template->format->Rmask, template->format->Gmask,
-			template->format->Bmask, 0);
-	if (newsurf == 0) {
-		log_add (log_Error, "Couldn't create screen buffers: %s",
-				SDL_GetError());
-	}
-	return newsurf;
-}
-
-static int
-ReInit_Screen (SDL_Surface **screen, SDL_Surface *template, int w, int h)
-{
-	if (*screen)
-		SDL_FreeSurface (*screen);
-	*screen = Create_Screen (template, w, h);
-	
-	return *screen == 0 ? -1 : 0;
-}
-
 static int
 AttemptColorDepth (int flags, int width, int height, int bpp)
 {
@@ -298,6 +274,15 @@ TFB_GL_InitGraphics (int driver, int fla
 	return 0;
 }
 
+void
+TFB_GL_UninitGraphics (void)
+{
+	int i;
+
+	for (i = 0; i < TFB_GFX_NUMSCREENS; i++)
+		UnInit_Screen (&GL_Screens[i].scaled);
+}
+
 void TFB_GL_UploadTransitionScreen (void)
 {
 	GL_Screens[TFB_SCREEN_TRANSITION].updated.x = 0;
@@ -307,7 +292,7 @@ void TFB_GL_UploadTransitionScreen (void
 	GL_Screens[TFB_SCREEN_TRANSITION].dirty = TRUE;
 }
 
-void
+static void
 TFB_GL_ScanLines (void)
 {
 	int y;
diff -ruNp src.orig/libs/graphics/sdl/opengl.h src/libs/graphics/sdl/opengl.h
--- src.orig/libs/graphics/sdl/opengl.h	2017-11-21 19:39:30 -0600
+++ src/libs/graphics/sdl/opengl.h	2017-11-21 19:39:44 -0600
@@ -22,6 +22,7 @@
 #include "libs/graphics/sdl/sdl_common.h"
 
 int TFB_GL_InitGraphics (int driver, int flags, int width, int height);
+void TFB_GL_UninitGraphics (void);
 int TFB_GL_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen);
 void TFB_GL_UploadTransitionScreen (void);
 
diff -ruNp src.orig/libs/graphics/sdl/pure.c src/libs/graphics/sdl/pure.c
--- src.orig/libs/graphics/sdl/pure.c	2017-11-21 19:39:30 -0600
+++ src/libs/graphics/sdl/pure.c	2017-11-21 19:39:44 -0600
@@ -47,30 +47,6 @@ static TFB_GRAPHICS_BACKEND pure_unscale
 	TFB_Pure_ScreenLayer,
 	TFB_Pure_ColorLayer };
 
-static SDL_Surface *
-Create_Screen (SDL_Surface *template, int w, int h)
-{
-	SDL_Surface *newsurf = SDL_CreateRGBSurface(SDL_SWSURFACE, w, h,
-			template->format->BitsPerPixel,
-			template->format->Rmask, template->format->Gmask,
-			template->format->Bmask, 0);
-	if (newsurf == 0) {
-		log_add (log_Error, "Couldn't create screen buffers: %s",
-				SDL_GetError());
-	}
-	return newsurf;
-}
-
-static int
-ReInit_Screen (SDL_Surface **screen, SDL_Surface *template, int w, int h)
-{
-	if (*screen)
-		SDL_FreeSurface (*screen);
-	*screen = Create_Screen (template, w, h);
-	
-	return *screen == 0 ? -1 : 0;
-}
-
 // We cannot rely on SDL_DisplayFormatAlpha() anymore. It can return
 // formats that we do not expect (SDL v1.2.14 on Mac OSX). Mac likes
 // ARGB surfaces, but SDL_DisplayFormatAlpha thinks that only RGBA are fast.
@@ -287,6 +263,14 @@ TFB_Pure_InitGraphics (int driver, int f
 	return 0;
 }
 
+void
+TFB_Pure_UninitGraphics (void)
+{
+	UnInit_Screen (&scaled_display);
+	UnInit_Screen (&fade_color_surface);
+	UnInit_Screen (&fade_temp);
+}
+
 static void
 ScanLines (SDL_Surface *dst, SDL_Rect *r)
 {
diff -ruNp src.orig/libs/graphics/sdl/pure.h src/libs/graphics/sdl/pure.h
--- src.orig/libs/graphics/sdl/pure.h	2017-11-21 19:39:30 -0600
+++ src/libs/graphics/sdl/pure.h	2017-11-21 19:39:45 -0600
@@ -22,6 +22,7 @@
 #include "libs/graphics/sdl/sdl_common.h"
 
 int TFB_Pure_InitGraphics (int driver, int flags, int width, int height);
+void TFB_Pure_UninitGraphics (void);
 int TFB_Pure_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen);
 void Scale_PerfTest (void);
 
diff -ruNp src.orig/libs/graphics/sdl/rotozoom.c src/libs/graphics/sdl/rotozoom.c
--- src.orig/libs/graphics/sdl/rotozoom.c	2017-11-21 19:39:30 -0600
+++ src/libs/graphics/sdl/rotozoom.c	2017-11-21 19:39:45 -0600
@@ -222,6 +222,7 @@ int zoomSurfaceRGBA(SDL_Surface * src, S
  
 */
 
+static
 int zoomSurfaceY(SDL_Surface * src, SDL_Surface * dst)
 {
     Uint32 sx, sy, *sax, *say, *csax, *csay, csx, csy;
@@ -342,6 +343,7 @@ int zoomSurfaceY(SDL_Surface * src, SDL_
  
 */
 
+static
 void transformSurfaceRGBA(SDL_Surface * src, SDL_Surface * dst, int cx, int cy, int isin, int icos, int smooth)
 {
     int x, y, t1, t2, dx, dy, xd, yd, sdx, sdy, ax, ay, ex, ey, sw, sh;
@@ -497,6 +499,7 @@ void transformSurfaceRGBA(SDL_Surface *
  
 */
 
+static
 void transformSurfaceY(SDL_Surface * src, SDL_Surface * dst, int cx, int cy, int isin, int icos)
 {
     int x, y, dx, dy, xd, yd, sdx, sdy, ax, ay, sw, sh;
@@ -557,6 +560,7 @@ void transformSurfaceY(SDL_Surface * src
 
 /* Local rotozoom-size function with trig result return */
 
+static
 void rotozoomSurfaceSizeTrig(int width, int height, double angle, double zoom, int *dstwidth, int *dstheight,
 			     double *canglezoom, double *sanglezoom)
 {
@@ -578,8 +582,8 @@ void rotozoomSurfaceSizeTrig(int width,
     cy = *canglezoom * y;
     sx = *sanglezoom * x;
     sy = *sanglezoom * y;
-    dstwidthhalf = MAX((int) ceil(fabs(cx) + fabs(sy)), 1);
-    dstheighthalf = MAX((int) ceil(fabs(sx) + fabs(cy)), 1);
+    dstwidthhalf = MAX(ceil(fabs(cx) + fabs(sy)), 1);
+    dstheighthalf = MAX(ceil(fabs(sx) + fabs(cy)), 1);
     *dstwidth = 2 * dstwidthhalf;
     *dstheight = 2 * dstheighthalf;
 }
diff -ruNp src.orig/libs/graphics/sdl/scalers.c src/libs/graphics/sdl/scalers.c
--- src.orig/libs/graphics/sdl/scalers.c	2017-11-21 19:39:30 -0600
+++ src/libs/graphics/sdl/scalers.c	2017-11-21 19:39:45 -0600
@@ -211,7 +211,7 @@ Scale_PrepPlatform (int flags, const SDL
 	// add better platform techs to the top
 #ifdef MMX_ASM
 	if ( (!force_platform && (SDL_HasSSE () || SDL_HasMMXExt ()))
-			|| force_platform == SCALEPLAT_SSE)
+			|| force_platform == PLATFORM_SSE)
 	{
 		log_add (log_Info, "Screen scalers are using SSE/MMX-Ext/MMX code");
 		Scale_Platform = SCALEPLAT_SSE;
@@ -220,7 +220,7 @@ Scale_PrepPlatform (int flags, const SDL
 	}
 	else
 	if ( (!force_platform && SDL_HasAltiVec ())
-			|| force_platform == SCALEPLAT_ALTIVEC)
+			|| force_platform == PLATFORM_ALTIVEC)
 	{
 		log_add (log_Info, "Screen scalers would use AltiVec code "
 				"if someone actually wrote it");
@@ -228,7 +228,7 @@ Scale_PrepPlatform (int flags, const SDL
 	}
 	else
 	if ( (!force_platform && SDL_Has3DNow ())
-			|| force_platform == SCALEPLAT_3DNOW)
+			|| force_platform == PLATFORM_3DNOW)
 	{
 		log_add (log_Info, "Screen scalers are using 3DNow/MMX code");
 		Scale_Platform = SCALEPLAT_3DNOW;
@@ -237,7 +237,7 @@ Scale_PrepPlatform (int flags, const SDL
 	}
 	else
 	if ( (!force_platform && SDL_HasMMX ())
-			|| force_platform == SCALEPLAT_MMX)
+			|| force_platform == PLATFORM_MMX)
 	{
 		log_add (log_Info, "Screen scalers are using MMX code");
 		Scale_Platform = SCALEPLAT_MMX;
diff -ruNp src.orig/libs/graphics/sdl/sdl_common.c src/libs/graphics/sdl/sdl_common.c
--- src.orig/libs/graphics/sdl/sdl_common.c	2017-11-21 19:39:30 -0600
+++ src/libs/graphics/sdl/sdl_common.c	2017-11-21 19:39:45 -0600
@@ -52,6 +52,8 @@ TFB_GRAPHICS_BACKEND *graphics_backend =
 volatile int QuitPosted = 0;
 volatile int GameActive = 1; // Track the SDL_ACTIVEEVENT state SDL_APPACTIVE
 
+static void TFB_PreQuit (void);
+
 void
 TFB_PreInit (void)
 {
@@ -76,6 +78,14 @@ TFB_PreInit (void)
 		log_add (log_Fatal, "Could not initialize SDL: %s.", SDL_GetError ());
 		exit (EXIT_FAILURE);
 	}
+
+	atexit (TFB_PreQuit);
+}
+
+static void
+TFB_PreQuit (void)
+{
+	SDL_Quit ();
 }
 
 int
@@ -129,15 +139,9 @@ TFB_ReInitGraphics (int driver, int flag
 int
 TFB_InitGraphics (int driver, int flags, int width, int height)
 {
-	int result, i;
+	int result;
 	char caption[200];
 
-	/* Null out screen pointers the first time */
-	for (i = 0; i < TFB_GFX_NUMSCREENS; i++)
-	{
-		SDL_Screens[i] = NULL;
-	}
-
 	GfxFlags = flags;
 
 	if (driver == TFB_GFXDRIVER_SDL_OPENGL)
@@ -168,17 +172,25 @@ TFB_InitGraphics (int driver, int flags,
 
 	TFB_DrawCanvas_Initialize ();
 
-	atexit (TFB_UninitGraphics);
-
 	return 0;
 }
 
 void
 TFB_UninitGraphics (void)
 {
+	int i;
+
 	Uninit_DrawCommandQueue ();
-	// TODO: Uninit whatever the drivers have set up for us
-	SDL_Quit ();
+
+	for (i = 0; i < TFB_GFX_NUMSCREENS; i++)
+		UnInit_Screen (&SDL_Screens[i]);
+
+	TFB_Pure_UninitGraphics ();
+#ifdef HAVE_OPENGL
+	TFB_GL_UninitGraphics ();
+#endif
+
+	UnInit_Screen (&format_conv_surf);
 }
 
 void
@@ -186,7 +198,7 @@ TFB_ProcessEvents ()
 {
 	SDL_Event Event;
 
-	while (SDL_PollEvent (&Event))
+	while (SDL_PollEvent (&Event) > 0)
 	{
 		/* Run through the InputEvent filter. */
 		ProcessInputEvent (&Event);
@@ -337,251 +349,6 @@ TFB_GetScreenCanvas (SCREEN screen)
 }
 
 void
-TFB_BlitSurface (SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst,
-		SDL_Rect *dstrect, int blend_numer, int blend_denom)
-{
-	BOOLEAN has_colorkey;
-	int x, y, x1, y1, x2, y2, dst_x2, dst_y2, nr, ng, nb;
-	int srcx, srcy, w, h;
-	Uint8 sr, sg, sb, dr, dg, db;
-	Uint32 src_pixval, dst_pixval, colorkey;
-	GetPixelFn src_getpix, dst_getpix;
-	PutPixelFn putpix;
-	SDL_Rect fulldst;
-
-	if (blend_numer == blend_denom)
-	{
-		// normal blit: dst = src
-		
-		// log_add (log_Debug, "normal blit\n");
-		SDL_BlitSurface (src, srcrect, dst, dstrect);
-		return;
-	}
-		
-	// NOTE: following clipping code is copied from SDL-1.2.4 sources
-
-	// If the destination rectangle is NULL, use the entire dest surface
-	if (dstrect == NULL)
-	{
-		fulldst.x = fulldst.y = 0;
-		dstrect = &fulldst;
-	}
-
-	// clip the source rectangle to the source surface
-	if (srcrect)
-	{
-		int maxw, maxh;
-
-		srcx = srcrect->x;
-		w = srcrect->w;
-		if (srcx < 0) 
-		{
-			w += srcx;
-			dstrect->x -= srcx;
-			srcx = 0;
-		}
-		maxw = src->w - srcx;
-		if (maxw < w)
-			w = maxw;
-
-		srcy = srcrect->y;
-		h = srcrect->h;
-		if (srcy < 0) 
-		{
-			h += srcy;
-			dstrect->y -= srcy;
-			srcy = 0;
-		}
-		maxh = src->h - srcy;
-		if (maxh < h)
-			h = maxh;
-	}
-	else
-	{
-		srcx = 0;
-		srcy = 0;
-		w = src->w;
-		h = src->h;
-	}
-
-	// clip the destination rectangle against the clip rectangle
-	{
-		SDL_Rect *clip = &dst->clip_rect;
-		int dx, dy;
-
-		dx = clip->x - dstrect->x;
-		if (dx > 0)
-		{
-			w -= dx;
-			dstrect->x += dx;
-			srcx += dx;
-		}
-		dx = dstrect->x + w - clip->x - clip->w;
-		if (dx > 0)
-			w -= dx;
-
-		dy = clip->y - dstrect->y;
-		if (dy > 0)
-		{
-			h -= dy;
-			dstrect->y += dy;
-			srcy += dy;
-		}
-		dy = dstrect->y + h - clip->y - clip->h;
-		if (dy > 0)
-			h -= dy;
-	}
-
-	dstrect->w = w;
-	dstrect->h = h;
-
-	if (w <= 0 || h <= 0)
-		return;
-
-	x1 = srcx;
-	y1 = srcy;
-	x2 = srcx + w;
-	y2 = srcy + h;
-
-	if (src->flags & SDL_SRCCOLORKEY)
-	{
-		has_colorkey = TRUE;
-		colorkey = src->format->colorkey;
-	}
-	else
-	{
-		has_colorkey = FALSE;
-		colorkey = 0;  /* Satisfying compiler */
-	}
-
-	src_getpix = getpixel_for (src);
-	dst_getpix = getpixel_for (dst);
-	putpix = putpixel_for (dst);
-
-	if (blend_denom < 0)
-	{
-		// additive blit: dst = src + dst
-#if 0
-		log_add (log_Debug, "additive blit %d %d, src %d %d %d %d dst %d %d,"
-				" srcbpp %d", blend_numer, blend_denom, x1, y1, x2, y2,
-				dstrect->x, dstrect->y, src->format->BitsPerPixel);
-#endif		
-		for (y = y1; y < y2; ++y)
-		{
-			dst_y2 = dstrect->y + (y - y1);
-			for (x = x1; x < x2; ++x)
-			{
-				dst_x2 = dstrect->x + (x - x1);
-				src_pixval = src_getpix (src, x, y);
-
-				if (has_colorkey && src_pixval == colorkey)
-					continue;
-
-				dst_pixval = dst_getpix (dst, dst_x2, dst_y2);
-				
-				SDL_GetRGB (src_pixval, src->format, &sr, &sg, &sb);
-				SDL_GetRGB (dst_pixval, dst->format, &dr, &dg, &db);
-
-				nr = sr + dr;
-				ng = sg + dg;
-				nb = sb + db;
-
-				if (nr > 255)
-					nr = 255;
-				if (ng > 255)
-					ng = 255;
-				if (nb > 255)
-					nb = 255;
-
-				putpix (dst, dst_x2, dst_y2,
-						SDL_MapRGB (dst->format, nr, ng, nb));
-			}
-		}
-	}
-	else if (blend_numer < 0)
-	{
-		// subtractive blit: dst = src - dst
-#if 0
-		log_add (log_Debug, "subtractive blit %d %d, src %d %d %d %d"
-				" dst %d %d, srcbpp %d", blend_numer, blend_denom,
-					x1, y1, x2, y2, dstrect->x, dstrect->y,
-					src->format->BitsPerPixel);
-#endif		
-		for (y = y1; y < y2; ++y)
-		{
-			dst_y2 = dstrect->y + (y - y1);
-			for (x = x1; x < x2; ++x)
-			{
-				dst_x2 = dstrect->x + (x - x1);
-				src_pixval = src_getpix (src, x, y);
-
-				if (has_colorkey && src_pixval == colorkey)
-					continue;
-
-				dst_pixval = dst_getpix (dst, dst_x2, dst_y2);
-
-				SDL_GetRGB (src_pixval, src->format, &sr, &sg, &sb);
-				SDL_GetRGB (dst_pixval, dst->format, &dr, &dg, &db);
-
-				nr = sr - dr;
-				ng = sg - dg;
-				nb = sb - db;
-
-				if (nr < 0)
-					nr = 0;
-				if (ng < 0)
-					ng = 0;
-				if (nb < 0)
-					nb = 0;
-
-				putpix (dst, dst_x2, dst_y2,
-						SDL_MapRGB (dst->format, nr, ng, nb));
-			}
-		}
-	}
-	else 
-	{
-		// modulated blit: dst = src * (blend_numer / blend_denom) 
-
-		float f = blend_numer / (float)blend_denom;
-#if 0
-		log_add (log_Debug, "modulated blit %d %d, f %f, src %d %d %d %d"
-				" dst %d %d, srcbpp %d\n", blend_numer, blend_denom, f,
-				x1, y1, x2, y2, dstrect->x, dstrect->y,
-				src->format->BitsPerPixel);
-#endif		
-		for (y = y1; y < y2; ++y)
-		{
-			dst_y2 = dstrect->y + (y - y1);
-			for (x = x1; x < x2; ++x)
-			{
-				dst_x2 = dstrect->x + (x - x1);
-				src_pixval = src_getpix (src, x, y);
-
-				if (has_colorkey && src_pixval == colorkey)
-					continue;
-				
-				SDL_GetRGB (src_pixval, src->format, &sr, &sg, &sb);
-
-				nr = (int)(sr * f);
-				ng = (int)(sg * f);
-				nb = (int)(sb * f);
-
-				if (nr > 255)
-					nr = 255;
-				if (ng > 255)
-					ng = 255;
-				if (nb > 255)
-					nb = 255;
-
-				putpix (dst, dst_x2, dst_y2,
-						SDL_MapRGB (dst->format, nr, ng, nb));
-			}
-		}
-	}
-}
-
-void
 TFB_UploadTransitionScreen (void)
 {
 #ifdef HAVE_OPENGL
@@ -592,16 +359,41 @@ TFB_UploadTransitionScreen (void)
 #endif
 }
 
-void
+bool
 TFB_SetGamma (float gamma)
 {
-	if (SDL_SetGamma (gamma, gamma, gamma) == -1)
-	{
-		log_add (log_Warning, "Unable to set gamma correction.");
-	}
-	else
-	{
-		log_add (log_Info, "Gamma correction set to %1.4f.", gamma);
+	return (SDL_SetGamma (gamma, gamma, gamma) == 0);
+}
+
+SDL_Surface *
+Create_Screen (SDL_Surface *templat, int w, int h)
+{
+	SDL_Surface *newsurf = SDL_CreateRGBSurface(SDL_SWSURFACE, w, h,
+			templat->format->BitsPerPixel,
+			templat->format->Rmask, templat->format->Gmask,
+			templat->format->Bmask, 0);
+	if (newsurf == 0) {
+		log_add (log_Error, "Couldn't create screen buffers: %s",
+				SDL_GetError());
 	}
+	return newsurf;
+}
+
+int
+ReInit_Screen (SDL_Surface **screen, SDL_Surface *templat, int w, int h)
+{
+	UnInit_Screen (screen);
+	*screen = Create_Screen (templat, w, h);
+	
+	return *screen == 0 ? -1 : 0;
 }
 
+void
+UnInit_Screen (SDL_Surface **screen)
+{
+	if (*screen == NULL)
+		return;
+
+	SDL_FreeSurface (*screen);
+	*screen = NULL;
+}
diff -ruNp src.orig/libs/graphics/sdl/sdl_common.h src/libs/graphics/sdl/sdl_common.h
--- src.orig/libs/graphics/sdl/sdl_common.h	2017-11-21 19:39:30 -0600
+++ src/libs/graphics/sdl/sdl_common.h	2017-11-21 19:39:45 -0600
@@ -48,4 +48,8 @@ extern SDL_Surface *format_conv_surf;
 
 SDL_Surface* TFB_DisplayFormatAlpha (SDL_Surface *surface);
 
+SDL_Surface* Create_Screen (SDL_Surface *templat, int w, int h);
+int ReInit_Screen (SDL_Surface **screen, SDL_Surface *templat, int w, int h);
+void UnInit_Screen (SDL_Surface **screen);
+
 #endif
diff -ruNp src.orig/libs/graphics/tfb_draw.c src/libs/graphics/tfb_draw.c
--- src.orig/libs/graphics/tfb_draw.c	2017-11-21 19:39:30 -0600
+++ src/libs/graphics/tfb_draw.c	2017-11-21 19:39:45 -0600
@@ -301,6 +301,7 @@ TFB_DrawImage_New (TFB_Canvas canvas)
 	img->last_scale_hs = NullHs;
 	img->last_scale_type = -1;
 	img->last_scale = 0;
+	img->dirty = FALSE;
 	TFB_DrawCanvas_GetExtent (canvas, &img->extent);
 
 	if (TFB_DrawCanvas_IsPaletted (canvas))
@@ -414,8 +415,16 @@ TFB_DrawImage_Delete (TFB_Image *image)
 
 	TFB_DrawCanvas_Delete (image->NormalImg);
 			
-	if (image->ScaledImg) {
+	if (image->ScaledImg)
+	{
 		TFB_DrawCanvas_Delete (image->ScaledImg);
+		image->ScaledImg = 0;
+	}
+
+	if (image->FilledImg)
+	{
+		TFB_DrawCanvas_Delete (image->FilledImg);
+		image->FilledImg = 0;
 	}
 
 	UnlockMutex (image->mutex);
diff -ruNp src.orig/libs/graphics/tfb_prim.c src/libs/graphics/tfb_prim.c
--- src.orig/libs/graphics/tfb_prim.c	2017-11-21 19:39:30 -0600
+++ src/libs/graphics/tfb_prim.c	2017-11-21 19:39:45 -0600
@@ -131,7 +131,7 @@ TFB_Prim_Stamp (STAMP *stmp, DrawMode mo
 	if (!SrcFramePtr)
 	{
 		log_add (log_Warning, "TFB_Prim_Stamp: Tried to draw a NULL frame"
-				" (Stamp address = %p)", stmp);
+				" (Stamp address = %p)", (void *) stmp);
 		return;
 	}
 	img = SrcFramePtr->image;
@@ -180,7 +180,7 @@ TFB_Prim_StampFill (STAMP *stmp, Color c
 	if (!SrcFramePtr)
 	{
 		log_add (log_Warning, "TFB_Prim_StampFill: Tried to draw a NULL frame"
-				" (Stamp address = %p)", stmp);
+				" (Stamp address = %p)", (void *) stmp);
 		return;
 	}
 	img = SrcFramePtr->image;
diff -ruNp src.orig/libs/heap/Makeinfo src/libs/heap/Makeinfo
--- src.orig/libs/heap/Makeinfo	2017-11-21 19:39:30 -0600
+++ src/libs/heap/Makeinfo	2017-11-21 19:39:45 -0600
@@ -1,2 +1,2 @@
 uqm_CFILES="heap.c"
-
+uqm_HFILES="heap.h"
diff -ruNp src.orig/libs/heap/heap.c src/libs/heap/heap.c
--- src.orig/libs/heap/heap.c	2017-11-21 19:39:30 -0600
+++ src/libs/heap/heap.c	2017-11-21 19:39:45 -0600
@@ -49,7 +49,7 @@ Heap_new(HeapValue_Comparator comparator
 	heap->minSize = minSize;
 	heap->minFillQuotient = minFillQuotient;
 	heap->size = nextPower2(initialSize);
-	heap->minFill = (size_t) ceil(((double) (heap->size >> 1))
+	heap->minFill = ceil(((double) (heap->size >> 1))
 			* heap->minFillQuotient);
 	heap->entries = malloc(heap->size * sizeof (HeapValue *));
 	heap->numEntries = 0;
diff -ruNp src.orig/libs/heap.h src/libs/heap.h
--- src.orig/libs/heap.h	2017-11-21 19:39:30 -0600
+++ src/libs/heap.h	2017-11-21 19:39:45 -0600
@@ -1,2 +1,9 @@
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #include "heap/heap.h"
 
+#if defined(__cplusplus)
+}
+#endif
diff -ruNp src.orig/libs/inplib.h src/libs/inplib.h
--- src.orig/libs/inplib.h	2017-11-21 19:39:30 -0600
+++ src/libs/inplib.h	2017-11-21 19:39:45 -0600
@@ -24,6 +24,10 @@
 #include "libs/uio.h"
 #include "libs/unicode.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 
 extern BOOLEAN AnyButtonPress (BOOLEAN DetectSpecial);
 
@@ -49,9 +53,9 @@ UniChar GetLastCharacter (void);
 
 /* Interrogating the current key configuration */
 
-void InterrogateInputState (int template, int control, int index, char *buffer, int maxlen);
-void RemoveInputState (int template, int control, int index);
-void RebindInputState (int template, int control, int index);
+void InterrogateInputState (int templat, int control, int index, char *buffer, int maxlen);
+void RemoveInputState (int templat, int control, int index);
+void RebindInputState (int templat, int control, int index);
 
 void SaveKeyConfiguration (uio_DirHandle *path, const char *fname);
 
@@ -59,5 +63,9 @@ void SaveKeyConfiguration (uio_DirHandle
 
 void BeginInputFrame (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _INPLIB_H */
 
diff -ruNp src.orig/libs/input/Makeinfo src/libs/input/Makeinfo
--- src.orig/libs/input/Makeinfo	2017-11-21 19:39:30 -0600
+++ src/libs/input/Makeinfo	2017-11-21 19:39:45 -0600
@@ -3,3 +3,4 @@ if [ "$uqm_GFXMODULE" = "sdl" ]; then
 fi
 
 uqm_CFILES="input_common.c"
+uqm_HFILES="inpintrn.h input_common.h"
diff -ruNp src.orig/libs/input/sdl/Makeinfo src/libs/input/sdl/Makeinfo
--- src.orig/libs/input/sdl/Makeinfo	2017-11-21 19:39:30 -0600
+++ src/libs/input/sdl/Makeinfo	2017-11-21 19:39:45 -0600
@@ -1 +1,2 @@
 uqm_CFILES="input.c keynames.c vcontrol.c"
+uqm_HFILES="input.h keynames.h vcontrol.h"
diff -ruNp src.orig/libs/input/sdl/input.c src/libs/input/sdl/input.c
--- src.orig/libs/input/sdl/input.c	2017-11-21 19:39:30 -0600
+++ src/libs/input/sdl/input.c	2017-11-21 19:39:45 -0600
@@ -18,8 +18,10 @@
 
 #include <assert.h>
 #include <errno.h>
+#include <string.h>
+#include "input.h"
 #include "../inpintrn.h"
-#include "libs/graphics/sdl/sdl_common.h"
+#include "libs/threadlib.h"
 #include "libs/input/sdl/vcontrol.h"
 #include "libs/input/sdl/keynames.h"
 #include "libs/memlib.h"
@@ -33,7 +35,7 @@
 static int kbdhead=0, kbdtail=0;
 static UniChar kbdbuf[KBDBUFSIZE];
 static UniChar lastchar;
-static unsigned int num_keys = 0;
+static int num_keys = 0;
 static int *kbdstate = NULL;
 		// Holds all SDL keys +1 for holding invalid values
 
@@ -213,20 +215,13 @@ TFB_SetInputVectors (volatile int menu[]
 	num_flight = num_flight_;
 }
 
-int 
-TFB_InitInput (int driver, int flags)
+#ifdef HAVE_JOYSTICK
+
+static void
+initJoystick (void)
 {
-	int i;
 	int nJoysticks;
-	(void)driver;
-	(void)flags;
 
-	SDL_EnableUNICODE(1);
-	(void)SDL_GetKeyState (&num_keys);
-	kbdstate = (int *)HMalloc (sizeof (int) * (num_keys + 1));
-	
-
-#ifdef HAVE_JOYSTICK
 	if ((SDL_InitSubSystem(SDL_INIT_JOYSTICK)) == -1)
 	{
 		log_add (log_Fatal, "Couldn't initialize joystick subsystem: %s",
@@ -239,6 +234,8 @@ TFB_InitInput (int driver, int flags)
 	nJoysticks = SDL_NumJoysticks ();
 	if (nJoysticks > 0)
 	{
+		int i;
+
 		log_add (log_Info, "The names of the joysticks are:");
 		for (i = 0; i < nJoysticks; i++)
 		{
@@ -246,6 +243,23 @@ TFB_InitInput (int driver, int flags)
 		}
 		SDL_JoystickEventState (SDL_ENABLE);
 	}
+}
+
+#endif /* HAVE_JOYSTICK */
+
+int 
+TFB_InitInput (int driver, int flags)
+{
+	(void)driver;
+	(void)flags;
+
+	SDL_EnableUNICODE(1);
+	(void)SDL_GetKeyState (&num_keys);
+	kbdstate = (int *)HMalloc (sizeof (int) * (num_keys + 1));
+	
+
+#ifdef HAVE_JOYSTICK
+	initJoystick ();
 #endif /* HAVE_JOYSTICK */
 
 	in_character_mode = FALSE;
@@ -259,7 +273,6 @@ TFB_InitInput (int driver, int flags)
 	VControl_ResetInput ();
 	InputInitialized = TRUE;
 
-	atexit (TFB_UninitInput);
 	return 0;
 }
 
@@ -308,7 +321,7 @@ GetLastCharacter (void)
 
 volatile int MouseButtonDown = 0;
 
-void
+static void
 ProcessMouseEvent (const SDL_Event *e)
 {
 	switch (e->type)
@@ -350,10 +363,12 @@ ProcessInputEvent (const SDL_Event *Even
 
 	if (Event->type == SDL_KEYDOWN || Event->type == SDL_KEYUP)
 	{	// process character input event, if any
-		SDLKey k = Event->key.keysym.sym;
+		// keysym.sym is an SDLKey type which is an enum and can be signed
+		// or unsigned on different platforms; we'll use a guaranteed type
+		int k = Event->key.keysym.sym;
 		UniChar map_key = Event->key.keysym.unicode;
 
-		if (k > num_keys)
+		if (k < 0 || k > num_keys)
 			k = num_keys; // for unknown keys
 
 		if (Event->type == SDL_KEYDOWN)
@@ -404,11 +419,11 @@ TFB_ResetControls (void)
 }
 
 void
-InterrogateInputState (int template, int control, int index, char *buffer, int maxlen)
+InterrogateInputState (int templat, int control, int index, char *buffer, int maxlen)
 {
-	VCONTROL_GESTURE *g = CONTROL_PTR(template, control, index);
+	VCONTROL_GESTURE *g = CONTROL_PTR(templat, control, index);
 
-	if (template >= num_templ || control >= num_flight
+	if (templat >= num_templ || control >= num_flight
 			|| index >= MAX_FLIGHT_ALTERNATES)
 	{
 		log_add (log_Warning, "InterrogateInputState(): invalid control index");
@@ -441,13 +456,13 @@ InterrogateInputState (int template, int
 }
 
 void
-RemoveInputState (int template, int control, int index)
+RemoveInputState (int templat, int control, int index)
 {
-	VCONTROL_GESTURE *g = CONTROL_PTR(template, control, index);
+	VCONTROL_GESTURE *g = CONTROL_PTR(templat, control, index);
 	char keybuf[40];
 	keybuf[39] = '\0';
 
-	if (template >= num_templ || control >= num_flight
+	if (templat >= num_templ || control >= num_flight
 			|| index >= MAX_FLIGHT_ALTERNATES)
 	{
 		log_add (log_Warning, "RemoveInputState(): invalid control index");
@@ -455,23 +470,23 @@ RemoveInputState (int template, int cont
 	}
 
 	VControl_RemoveGestureBinding (g,
-			(int *)(flight_vec + template * num_flight + control));
+			(int *)(flight_vec + templat * num_flight + control));
 	g->type = VCONTROL_NONE;
 
-	snprintf (keybuf, 39, "keys.%d.%s.%d", template+1, flight_res_names[control], index+1);
+	snprintf (keybuf, 39, "keys.%d.%s.%d", templat+1, flight_res_names[control], index+1);
 	res_Remove (keybuf);
 
 	return;
 }
 
 void
-RebindInputState (int template, int control, int index)
+RebindInputState (int templat, int control, int index)
 {
 	VCONTROL_GESTURE g;
 	char keybuf[40], valbuf[40];
 	keybuf[39] = valbuf[39] = '\0';
 
-	if (template >= num_templ || control >= num_flight
+	if (templat >= num_templ || control >= num_flight
 			|| index >= MAX_FLIGHT_ALTERNATES)
 	{
 		log_add (log_Warning, "RebindInputState(): invalid control index");
@@ -479,7 +494,7 @@ RebindInputState (int template, int cont
 	}
 
 	/* Remove the old binding on this spot */
-	RemoveInputState (template, control, index);
+	RemoveInputState (templat, control, index);
 
 	/* Wait for the next interesting bit of user input */
 	VControl_ClearGesture ();
@@ -490,9 +505,9 @@ RebindInputState (int template, int cont
 
 	/* And now, add the new binding. */
 	VControl_AddGestureBinding (&g,
-			(int *)(flight_vec + template * num_flight + control));
-	*CONTROL_PTR(template, control, index) = g;
-	snprintf (keybuf, 39, "keys.%d.%s.%d", template+1, flight_res_names[control], index+1);
+			(int *)(flight_vec + templat * num_flight + control));
+	*CONTROL_PTR(templat, control, index) = g;
+	snprintf (keybuf, 39, "keys.%d.%s.%d", templat+1, flight_res_names[control], index+1);
 	VControl_DumpGesture (valbuf, 39, &g);
 	res_PutString (keybuf, valbuf);
 }
diff -ruNp src.orig/libs/input/sdl/input.h src/libs/input/sdl/input.h
--- src.orig/libs/input/sdl/input.h	2017-11-21 19:39:30 -0600
+++ src/libs/input/sdl/input.h	2017-11-21 19:39:45 -0600
@@ -19,6 +19,9 @@
 #ifndef INPUT_H
 #define INPUT_H
 
+#include "port.h"
+#include SDL_INCLUDE(SDL.h)
+
 extern void ProcessInputEvent (const SDL_Event *Event);
 
 #endif
diff -ruNp src.orig/libs/input/sdl/keynames.c src/libs/input/sdl/keynames.c
--- src.orig/libs/input/sdl/keynames.c	2017-11-21 19:39:30 -0600
+++ src/libs/input/sdl/keynames.c	2017-11-21 19:39:45 -0600
@@ -33,7 +33,7 @@
  * tragedy. */
 
 typedef struct vcontrol_keyname {
-	/* const */ char *name;
+	const char *name;
 	int code;
 } keyname;
 
@@ -182,7 +182,7 @@ static keyname keynames[] = {
 	{"Unknown", 0}};
 /* Last element must have code zero */
 
-char *
+const char *
 VControl_code2name (int code)
 {
 	int i = 0;
@@ -198,12 +198,12 @@ VControl_code2name (int code)
 }
 
 int
-VControl_name2code (char *name)
+VControl_name2code (const char *name)
 {
 	int i = 0;
 	while (1)
 	{
-		char *test = keynames[i].name;
+		const char *test = keynames[i].name;
 		int code = keynames[i].code;
 		if (!strcasecmp(test, name) || !code)
 		{
diff -ruNp src.orig/libs/input/sdl/keynames.h src/libs/input/sdl/keynames.h
--- src.orig/libs/input/sdl/keynames.h	2017-11-21 19:39:30 -0600
+++ src/libs/input/sdl/keynames.h	2017-11-21 19:39:45 -0600
@@ -17,6 +17,6 @@
 #ifndef _KEYNAMES_H_
 #define _KEYNAMES_H_
 
-char *VControl_code2name (int code);
-int VControl_name2code (char *code);
+const char *VControl_code2name (int code);
+int VControl_name2code (const char *code);
 #endif
diff -ruNp src.orig/libs/input/sdl/vcontrol.c src/libs/input/sdl/vcontrol.c
--- src.orig/libs/input/sdl/vcontrol.c	2017-11-21 19:39:30 -0600
+++ src/libs/input/sdl/vcontrol.c	2017-11-21 19:39:45 -0600
@@ -184,8 +184,10 @@ static void
 key_init (void)
 {
 	unsigned int i;
+	int num_keys; // Temp to match type of param for SDL_GetKeyState().
 	pool = allocate_key_chunk ();
-	(void)SDL_GetKeyState (&num_sdl_keys);
+	(void)SDL_GetKeyState (&num_keys);
+	num_sdl_keys = num_keys;
 	bindings = (keybinding **) HMalloc (sizeof (keybinding *) * num_sdl_keys);
 	for (i = 0; i < num_sdl_keys; i++)
 		bindings[i] = NULL;
@@ -1263,7 +1265,7 @@ VControl_ParseGesture (VCONTROL_GESTURE
 	parse_state ps;
 
 	strncpy (ps.line, spec, LINE_SIZE);
-	ps.line[LINE_SIZE] = '\0';
+	ps.line[LINE_SIZE - 1] = '\0';
 	ps.index = ps.error = 0;
 	ps.linenum = -1;
 
diff -ruNp src.orig/libs/list/Makeinfo src/libs/list/Makeinfo
--- src.orig/libs/list/Makeinfo	2017-11-21 19:39:30 -0600
+++ src/libs/list/Makeinfo	2017-11-21 19:39:45 -0600
@@ -1 +1,2 @@
 uqm_CFILES="list.c"
+uqm_HFILES="list.h"
diff -ruNp src.orig/libs/list.h src/libs/list.h
--- src.orig/libs/list.h	2017-11-21 19:39:30 -0600
+++ src/libs/list.h	2017-11-21 19:39:45 -0600
@@ -16,5 +16,14 @@
  *
  */
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #include "list/list.h"
 
+#if defined(__cplusplus)
+}
+#endif
+
+
diff -ruNp src.orig/libs/log/Makeinfo src/libs/log/Makeinfo
--- src.orig/libs/log/Makeinfo	2017-11-21 19:39:30 -0600
+++ src/libs/log/Makeinfo	2017-11-21 19:39:45 -0600
@@ -1,4 +1,5 @@
 uqm_CFILES="uqmlog.c"
+uqm_HFILES="loginternal.h msgbox.h uqmlog.h"
 
 case "$HOST_SYSTEM" in
 	Darwin)
@@ -11,3 +12,4 @@ case "$HOST_SYSTEM" in
 		uqm_CFILES="$uqm_CFILES msgbox_stub.c"
 		;;
 esac
+
diff -ruNp src.orig/libs/log/uqmlog.c src/libs/log/uqmlog.c
--- src.orig/libs/log/uqmlog.c	2017-11-21 19:39:30 -0600
+++ src/libs/log/uqmlog.c	2017-11-21 19:39:45 -0600
@@ -26,7 +26,7 @@
 #include "libs/threadlib.h"
 
 #ifndef MAX_LOG_ENTRY_SIZE
-#	define MAX_LOG_ENTRY_SIZE 256
+#	define MAX_LOG_ENTRY_SIZE 1024
 #endif
 
 #ifndef MAX_LOG_ENTRIES
@@ -159,6 +159,7 @@ log_exit (int code)
 	{
 		qlock = 0;
 		DestroyMutex (qmutex);
+		qmutex = 0;
 	}
 
 	return code;
diff -ruNp src.orig/libs/log.h src/libs/log.h
--- src.orig/libs/log.h	2017-11-21 19:39:30 -0600
+++ src/libs/log.h	2017-11-21 19:39:45 -0600
@@ -14,4 +14,12 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #include "log/uqmlog.h"
+
+#if defined(__cplusplus)
+}
+#endif
diff -ruNp src.orig/libs/lua/Makeinfo src/libs/lua/Makeinfo
--- src.orig/libs/lua/Makeinfo	1969-12-31 18:00:00 -0600
+++ src/libs/lua/Makeinfo	2017-11-21 19:39:46 -0600
@@ -0,0 +1,3 @@
+uqm_CFILES="lapi.c lauxlib.c lbaselib.c lbitlib.c lcode.c lctype.c ldebug.c ldo.c ldump.c lfunc.c lgc.c llex.c lmathlib.c lmem.c lobject.c lopcodes.c lparser.c lstate.c lstring.c lstrlib.c ltable.c ltablib.c ltm.c lundump.c lvm.c lzio.c"
+uqm_HFILES="lapi.h lauxlib.h lcode.h lctype.h ldebug.h ldo.h lfunc.h lgc.h llex.h llimits.h lmem.h lobject.h lopcodes.h lparser.h lstate.h lstring.h ltable.h ltm.h luaconf.h lua.h lualib.h lundump.h lvm.h lzio.h"
+
diff -ruNp src.orig/libs/lua/lapi.c src/libs/lua/lapi.c
--- src.orig/libs/lua/lapi.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lapi.c	2017-11-21 19:39:45 -0600
@@ -0,0 +1,1284 @@
+/*
+** $Id: lapi.c,v 2.171 2013/03/16 21:10:18 roberto Exp $
+** Lua API
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdarg.h>
+#include <string.h>
+
+#define lapi_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lapi.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+#include "lundump.h"
+#include "lvm.h"
+
+
+
+const char lua_ident[] =
+  "$LuaVersion: " LUA_COPYRIGHT " $"
+  "$LuaAuthors: " LUA_AUTHORS " $";
+
+
+/* value at a non-valid index */
+#define NONVALIDVALUE		cast(TValue *, luaO_nilobject)
+
+/* corresponding test */
+#define isvalid(o)	((o) != luaO_nilobject)
+
+/* test for pseudo index */
+#define ispseudo(i)		((i) <= LUA_REGISTRYINDEX)
+
+/* test for valid but not pseudo index */
+#define isstackindex(i, o)	(isvalid(o) && !ispseudo(i))
+
+#define api_checkvalidindex(L, o)  api_check(L, isvalid(o), "invalid index")
+
+#define api_checkstackindex(L, i, o)  \
+	api_check(L, isstackindex(i, o), "index not in the stack")
+
+
+static TValue *index2addr (lua_State *L, int idx) {
+  CallInfo *ci = L->ci;
+  if (idx > 0) {
+    TValue *o = ci->func + idx;
+    api_check(L, idx <= ci->top - (ci->func + 1), "unacceptable index");
+    if (o >= L->top) return NONVALIDVALUE;
+    else return o;
+  }
+  else if (!ispseudo(idx)) {  /* negative index */
+    api_check(L, idx != 0 && -idx <= L->top - (ci->func + 1), "invalid index");
+    return L->top + idx;
+  }
+  else if (idx == LUA_REGISTRYINDEX)
+    return &G(L)->l_registry;
+  else {  /* upvalues */
+    idx = LUA_REGISTRYINDEX - idx;
+    api_check(L, idx <= MAXUPVAL + 1, "upvalue index too large");
+    if (ttislcf(ci->func))  /* light C function? */
+      return NONVALIDVALUE;  /* it has no upvalues */
+    else {
+      CClosure *func = clCvalue(ci->func);
+      return (idx <= func->nupvalues) ? &func->upvalue[idx-1] : NONVALIDVALUE;
+    }
+  }
+}
+
+
+/*
+** to be called by 'lua_checkstack' in protected mode, to grow stack
+** capturing memory errors
+*/
+static void growstack (lua_State *L, void *ud) {
+  int size = *(int *)ud;
+  luaD_growstack(L, size);
+}
+
+
+LUA_API int lua_checkstack (lua_State *L, int size) {
+  int res;
+  CallInfo *ci = L->ci;
+  lua_lock(L);
+  if (L->stack_last - L->top > size)  /* stack large enough? */
+    res = 1;  /* yes; check is OK */
+  else {  /* no; need to grow stack */
+    int inuse = cast_int(L->top - L->stack) + EXTRA_STACK;
+    if (inuse > LUAI_MAXSTACK - size)  /* can grow without overflow? */
+      res = 0;  /* no */
+    else  /* try to grow stack */
+      res = (luaD_rawrunprotected(L, &growstack, &size) == LUA_OK);
+  }
+  if (res && ci->top < L->top + size)
+    ci->top = L->top + size;  /* adjust frame top */
+  lua_unlock(L);
+  return res;
+}
+
+
+LUA_API void lua_xmove (lua_State *from, lua_State *to, int n) {
+  int i;
+  if (from == to) return;
+  lua_lock(to);
+  api_checknelems(from, n);
+  api_check(from, G(from) == G(to), "moving among independent states");
+  api_check(from, to->ci->top - to->top >= n, "not enough elements to move");
+  from->top -= n;
+  for (i = 0; i < n; i++) {
+    setobj2s(to, to->top++, from->top + i);
+  }
+  lua_unlock(to);
+}
+
+
+LUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf) {
+  lua_CFunction old;
+  lua_lock(L);
+  old = G(L)->panic;
+  G(L)->panic = panicf;
+  lua_unlock(L);
+  return old;
+}
+
+
+LUA_API const lua_Number *lua_version (lua_State *L) {
+  static const lua_Number version = LUA_VERSION_NUM;
+  if (L == NULL) return &version;
+  else return G(L)->version;
+}
+
+
+
+/*
+** basic stack manipulation
+*/
+
+
+/*
+** convert an acceptable stack index into an absolute index
+*/
+LUA_API int lua_absindex (lua_State *L, int idx) {
+  return (idx > 0 || ispseudo(idx))
+         ? idx
+         : cast_int(L->top - L->ci->func + idx);
+}
+
+
+LUA_API int lua_gettop (lua_State *L) {
+  return cast_int(L->top - (L->ci->func + 1));
+}
+
+
+LUA_API void lua_settop (lua_State *L, int idx) {
+  StkId func = L->ci->func;
+  lua_lock(L);
+  if (idx >= 0) {
+    api_check(L, idx <= L->stack_last - (func + 1), "new top too large");
+    while (L->top < (func + 1) + idx)
+      setnilvalue(L->top++);
+    L->top = (func + 1) + idx;
+  }
+  else {
+    api_check(L, -(idx+1) <= (L->top - (func + 1)), "invalid new top");
+    L->top += idx+1;  /* `subtract' index (index is negative) */
+  }
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_remove (lua_State *L, int idx) {
+  StkId p;
+  lua_lock(L);
+  p = index2addr(L, idx);
+  api_checkstackindex(L, idx, p);
+  while (++p < L->top) setobjs2s(L, p-1, p);
+  L->top--;
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_insert (lua_State *L, int idx) {
+  StkId p;
+  StkId q;
+  lua_lock(L);
+  p = index2addr(L, idx);
+  api_checkstackindex(L, idx, p);
+  for (q = L->top; q > p; q--)  /* use L->top as a temporary */
+    setobjs2s(L, q, q - 1);
+  setobjs2s(L, p, L->top);
+  lua_unlock(L);
+}
+
+
+static void moveto (lua_State *L, TValue *fr, int idx) {
+  TValue *to = index2addr(L, idx);
+  api_checkvalidindex(L, to);
+  setobj(L, to, fr);
+  if (idx < LUA_REGISTRYINDEX)  /* function upvalue? */
+    luaC_barrier(L, clCvalue(L->ci->func), fr);
+  /* LUA_REGISTRYINDEX does not need gc barrier
+     (collector revisits it before finishing collection) */
+}
+
+
+LUA_API void lua_replace (lua_State *L, int idx) {
+  lua_lock(L);
+  api_checknelems(L, 1);
+  moveto(L, L->top - 1, idx);
+  L->top--;
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_copy (lua_State *L, int fromidx, int toidx) {
+  TValue *fr;
+  lua_lock(L);
+  fr = index2addr(L, fromidx);
+  moveto(L, fr, toidx);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushvalue (lua_State *L, int idx) {
+  lua_lock(L);
+  setobj2s(L, L->top, index2addr(L, idx));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API int lua_type (lua_State *L, int idx) {
+  StkId o = index2addr(L, idx);
+  return (isvalid(o) ? ttypenv(o) : LUA_TNONE);
+}
+
+
+LUA_API const char *lua_typename (lua_State *L, int t) {
+  UNUSED(L);
+  return ttypename(t);
+}
+
+
+LUA_API int lua_iscfunction (lua_State *L, int idx) {
+  StkId o = index2addr(L, idx);
+  return (ttislcf(o) || (ttisCclosure(o)));
+}
+
+
+LUA_API int lua_isnumber (lua_State *L, int idx) {
+  TValue n;
+  const TValue *o = index2addr(L, idx);
+  return tonumber(o, &n);
+}
+
+
+LUA_API int lua_isstring (lua_State *L, int idx) {
+  int t = lua_type(L, idx);
+  return (t == LUA_TSTRING || t == LUA_TNUMBER);
+}
+
+
+LUA_API int lua_isuserdata (lua_State *L, int idx) {
+  const TValue *o = index2addr(L, idx);
+  return (ttisuserdata(o) || ttislightuserdata(o));
+}
+
+
+LUA_API int lua_rawequal (lua_State *L, int index1, int index2) {
+  StkId o1 = index2addr(L, index1);
+  StkId o2 = index2addr(L, index2);
+  return (isvalid(o1) && isvalid(o2)) ? luaV_rawequalobj(o1, o2) : 0;
+}
+
+
+LUA_API void lua_arith (lua_State *L, int op) {
+  StkId o1;  /* 1st operand */
+  StkId o2;  /* 2nd operand */
+  lua_lock(L);
+  if (op != LUA_OPUNM) /* all other operations expect two operands */
+    api_checknelems(L, 2);
+  else {  /* for unary minus, add fake 2nd operand */
+    api_checknelems(L, 1);
+    setobjs2s(L, L->top, L->top - 1);
+    L->top++;
+  }
+  o1 = L->top - 2;
+  o2 = L->top - 1;
+  if (ttisnumber(o1) && ttisnumber(o2)) {
+    setnvalue(o1, luaO_arith(op, nvalue(o1), nvalue(o2)));
+  }
+  else
+    luaV_arith(L, o1, o1, o2, cast(TMS, op - LUA_OPADD + TM_ADD));
+  L->top--;
+  lua_unlock(L);
+}
+
+
+LUA_API int lua_compare (lua_State *L, int index1, int index2, int op) {
+  StkId o1, o2;
+  int i = 0;
+  lua_lock(L);  /* may call tag method */
+  o1 = index2addr(L, index1);
+  o2 = index2addr(L, index2);
+  if (isvalid(o1) && isvalid(o2)) {
+    switch (op) {
+      case LUA_OPEQ: i = equalobj(L, o1, o2); break;
+      case LUA_OPLT: i = luaV_lessthan(L, o1, o2); break;
+      case LUA_OPLE: i = luaV_lessequal(L, o1, o2); break;
+      default: api_check(L, 0, "invalid option");
+    }
+  }
+  lua_unlock(L);
+  return i;
+}
+
+
+LUA_API lua_Number lua_tonumberx (lua_State *L, int idx, int *isnum) {
+  TValue n;
+  const TValue *o = index2addr(L, idx);
+  if (tonumber(o, &n)) {
+    if (isnum) *isnum = 1;
+    return nvalue(o);
+  }
+  else {
+    if (isnum) *isnum = 0;
+    return 0;
+  }
+}
+
+
+LUA_API lua_Integer lua_tointegerx (lua_State *L, int idx, int *isnum) {
+  TValue n;
+  const TValue *o = index2addr(L, idx);
+  if (tonumber(o, &n)) {
+    lua_Integer res;
+    lua_Number num = nvalue(o);
+    lua_number2integer(res, num);
+    if (isnum) *isnum = 1;
+    return res;
+  }
+  else {
+    if (isnum) *isnum = 0;
+    return 0;
+  }
+}
+
+
+LUA_API lua_Unsigned lua_tounsignedx (lua_State *L, int idx, int *isnum) {
+  TValue n;
+  const TValue *o = index2addr(L, idx);
+  if (tonumber(o, &n)) {
+    lua_Unsigned res;
+    lua_Number num = nvalue(o);
+    lua_number2unsigned(res, num);
+    if (isnum) *isnum = 1;
+    return res;
+  }
+  else {
+    if (isnum) *isnum = 0;
+    return 0;
+  }
+}
+
+
+LUA_API int lua_toboolean (lua_State *L, int idx) {
+  const TValue *o = index2addr(L, idx);
+  return !l_isfalse(o);
+}
+
+
+LUA_API const char *lua_tolstring (lua_State *L, int idx, size_t *len) {
+  StkId o = index2addr(L, idx);
+  if (!ttisstring(o)) {
+    lua_lock(L);  /* `luaV_tostring' may create a new string */
+    if (!luaV_tostring(L, o)) {  /* conversion failed? */
+      if (len != NULL) *len = 0;
+      lua_unlock(L);
+      return NULL;
+    }
+    luaC_checkGC(L);
+    o = index2addr(L, idx);  /* previous call may reallocate the stack */
+    lua_unlock(L);
+  }
+  if (len != NULL) *len = tsvalue(o)->len;
+  return svalue(o);
+}
+
+
+LUA_API size_t lua_rawlen (lua_State *L, int idx) {
+  StkId o = index2addr(L, idx);
+  switch (ttypenv(o)) {
+    case LUA_TSTRING: return tsvalue(o)->len;
+    case LUA_TUSERDATA: return uvalue(o)->len;
+    case LUA_TTABLE: return luaH_getn(hvalue(o));
+    default: return 0;
+  }
+}
+
+
+LUA_API lua_CFunction lua_tocfunction (lua_State *L, int idx) {
+  StkId o = index2addr(L, idx);
+  if (ttislcf(o)) return fvalue(o);
+  else if (ttisCclosure(o))
+    return clCvalue(o)->f;
+  else return NULL;  /* not a C function */
+}
+
+
+LUA_API void *lua_touserdata (lua_State *L, int idx) {
+  StkId o = index2addr(L, idx);
+  switch (ttypenv(o)) {
+    case LUA_TUSERDATA: return (rawuvalue(o) + 1);
+    case LUA_TLIGHTUSERDATA: return pvalue(o);
+    default: return NULL;
+  }
+}
+
+
+LUA_API lua_State *lua_tothread (lua_State *L, int idx) {
+  StkId o = index2addr(L, idx);
+  return (!ttisthread(o)) ? NULL : thvalue(o);
+}
+
+
+LUA_API const void *lua_topointer (lua_State *L, int idx) {
+  StkId o = index2addr(L, idx);
+  switch (ttype(o)) {
+    case LUA_TTABLE: return hvalue(o);
+    case LUA_TLCL: return clLvalue(o);
+    case LUA_TCCL: return clCvalue(o);
+    case LUA_TLCF: return cast(void *, cast(size_t, fvalue(o)));
+    case LUA_TTHREAD: return thvalue(o);
+    case LUA_TUSERDATA:
+    case LUA_TLIGHTUSERDATA:
+      return lua_touserdata(L, idx);
+    default: return NULL;
+  }
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushnil (lua_State *L) {
+  lua_lock(L);
+  setnilvalue(L->top);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushnumber (lua_State *L, lua_Number n) {
+  lua_lock(L);
+  setnvalue(L->top, n);
+  luai_checknum(L, L->top,
+    luaG_runerror(L, "C API - attempt to push a signaling NaN"));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushinteger (lua_State *L, lua_Integer n) {
+  lua_lock(L);
+  setnvalue(L->top, cast_num(n));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushunsigned (lua_State *L, lua_Unsigned u) {
+  lua_Number n;
+  lua_lock(L);
+  n = lua_unsigned2number(u);
+  setnvalue(L->top, n);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API const char *lua_pushlstring (lua_State *L, const char *s, size_t len) {
+  TString *ts;
+  lua_lock(L);
+  luaC_checkGC(L);
+  ts = luaS_newlstr(L, s, len);
+  setsvalue2s(L, L->top, ts);
+  api_incr_top(L);
+  lua_unlock(L);
+  return getstr(ts);
+}
+
+
+LUA_API const char *lua_pushstring (lua_State *L, const char *s) {
+  if (s == NULL) {
+    lua_pushnil(L);
+    return NULL;
+  }
+  else {
+    TString *ts;
+    lua_lock(L);
+    luaC_checkGC(L);
+    ts = luaS_new(L, s);
+    setsvalue2s(L, L->top, ts);
+    api_incr_top(L);
+    lua_unlock(L);
+    return getstr(ts);
+  }
+}
+
+
+LUA_API const char *lua_pushvfstring (lua_State *L, const char *fmt,
+                                      va_list argp) {
+  const char *ret;
+  lua_lock(L);
+  luaC_checkGC(L);
+  ret = luaO_pushvfstring(L, fmt, argp);
+  lua_unlock(L);
+  return ret;
+}
+
+
+LUA_API const char *lua_pushfstring (lua_State *L, const char *fmt, ...) {
+  const char *ret;
+  va_list argp;
+  lua_lock(L);
+  luaC_checkGC(L);
+  va_start(argp, fmt);
+  ret = luaO_pushvfstring(L, fmt, argp);
+  va_end(argp);
+  lua_unlock(L);
+  return ret;
+}
+
+
+LUA_API void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n) {
+  lua_lock(L);
+  if (n == 0) {
+    setfvalue(L->top, fn);
+  }
+  else {
+    Closure *cl;
+    api_checknelems(L, n);
+    api_check(L, n <= MAXUPVAL, "upvalue index too large");
+    luaC_checkGC(L);
+    cl = luaF_newCclosure(L, n);
+    cl->c.f = fn;
+    L->top -= n;
+    while (n--)
+      setobj2n(L, &cl->c.upvalue[n], L->top + n);
+    setclCvalue(L, L->top, cl);
+  }
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushboolean (lua_State *L, int b) {
+  lua_lock(L);
+  setbvalue(L->top, (b != 0));  /* ensure that true is 1 */
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushlightuserdata (lua_State *L, void *p) {
+  lua_lock(L);
+  setpvalue(L->top, p);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API int lua_pushthread (lua_State *L) {
+  lua_lock(L);
+  setthvalue(L, L->top, L);
+  api_incr_top(L);
+  lua_unlock(L);
+  return (G(L)->mainthread == L);
+}
+
+
+
+/*
+** get functions (Lua -> stack)
+*/
+
+
+LUA_API void lua_getglobal (lua_State *L, const char *var) {
+  Table *reg = hvalue(&G(L)->l_registry);
+  const TValue *gt;  /* global table */
+  lua_lock(L);
+  gt = luaH_getint(reg, LUA_RIDX_GLOBALS);
+  setsvalue2s(L, L->top++, luaS_new(L, var));
+  luaV_gettable(L, gt, L->top - 1, L->top - 1);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_gettable (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  t = index2addr(L, idx);
+  luaV_gettable(L, t, L->top - 1, L->top - 1);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_getfield (lua_State *L, int idx, const char *k) {
+  StkId t;
+  lua_lock(L);
+  t = index2addr(L, idx);
+  setsvalue2s(L, L->top, luaS_new(L, k));
+  api_incr_top(L);
+  luaV_gettable(L, t, L->top - 1, L->top - 1);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawget (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  t = index2addr(L, idx);
+  api_check(L, ttistable(t), "table expected");
+  setobj2s(L, L->top - 1, luaH_get(hvalue(t), L->top - 1));
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawgeti (lua_State *L, int idx, int n) {
+  StkId t;
+  lua_lock(L);
+  t = index2addr(L, idx);
+  api_check(L, ttistable(t), "table expected");
+  setobj2s(L, L->top, luaH_getint(hvalue(t), n));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawgetp (lua_State *L, int idx, const void *p) {
+  StkId t;
+  TValue k;
+  lua_lock(L);
+  t = index2addr(L, idx);
+  api_check(L, ttistable(t), "table expected");
+  setpvalue(&k, cast(void *, p));
+  setobj2s(L, L->top, luaH_get(hvalue(t), &k));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_createtable (lua_State *L, int narray, int nrec) {
+  Table *t;
+  lua_lock(L);
+  luaC_checkGC(L);
+  t = luaH_new(L);
+  sethvalue(L, L->top, t);
+  api_incr_top(L);
+  if (narray > 0 || nrec > 0)
+    luaH_resize(L, t, narray, nrec);
+  lua_unlock(L);
+}
+
+
+LUA_API int lua_getmetatable (lua_State *L, int objindex) {
+  const TValue *obj;
+  Table *mt = NULL;
+  int res;
+  lua_lock(L);
+  obj = index2addr(L, objindex);
+  switch (ttypenv(obj)) {
+    case LUA_TTABLE:
+      mt = hvalue(obj)->metatable;
+      break;
+    case LUA_TUSERDATA:
+      mt = uvalue(obj)->metatable;
+      break;
+    default:
+      mt = G(L)->mt[ttypenv(obj)];
+      break;
+  }
+  if (mt == NULL)
+    res = 0;
+  else {
+    sethvalue(L, L->top, mt);
+    api_incr_top(L);
+    res = 1;
+  }
+  lua_unlock(L);
+  return res;
+}
+
+
+LUA_API void lua_getuservalue (lua_State *L, int idx) {
+  StkId o;
+  lua_lock(L);
+  o = index2addr(L, idx);
+  api_check(L, ttisuserdata(o), "userdata expected");
+  if (uvalue(o)->env) {
+    sethvalue(L, L->top, uvalue(o)->env);
+  } else
+    setnilvalue(L->top);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+/*
+** set functions (stack -> Lua)
+*/
+
+
+LUA_API void lua_setglobal (lua_State *L, const char *var) {
+  Table *reg = hvalue(&G(L)->l_registry);
+  const TValue *gt;  /* global table */
+  lua_lock(L);
+  api_checknelems(L, 1);
+  gt = luaH_getint(reg, LUA_RIDX_GLOBALS);
+  setsvalue2s(L, L->top++, luaS_new(L, var));
+  luaV_settable(L, gt, L->top - 1, L->top - 2);
+  L->top -= 2;  /* pop value and key */
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_settable (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  api_checknelems(L, 2);
+  t = index2addr(L, idx);
+  luaV_settable(L, t, L->top - 2, L->top - 1);
+  L->top -= 2;  /* pop index and value */
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_setfield (lua_State *L, int idx, const char *k) {
+  StkId t;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  t = index2addr(L, idx);
+  setsvalue2s(L, L->top++, luaS_new(L, k));
+  luaV_settable(L, t, L->top - 1, L->top - 2);
+  L->top -= 2;  /* pop value and key */
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawset (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  api_checknelems(L, 2);
+  t = index2addr(L, idx);
+  api_check(L, ttistable(t), "table expected");
+  setobj2t(L, luaH_set(L, hvalue(t), L->top-2), L->top-1);
+  invalidateTMcache(hvalue(t));
+  luaC_barrierback(L, gcvalue(t), L->top-1);
+  L->top -= 2;
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawseti (lua_State *L, int idx, int n) {
+  StkId t;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  t = index2addr(L, idx);
+  api_check(L, ttistable(t), "table expected");
+  luaH_setint(L, hvalue(t), n, L->top - 1);
+  luaC_barrierback(L, gcvalue(t), L->top-1);
+  L->top--;
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawsetp (lua_State *L, int idx, const void *p) {
+  StkId t;
+  TValue k;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  t = index2addr(L, idx);
+  api_check(L, ttistable(t), "table expected");
+  setpvalue(&k, cast(void *, p));
+  setobj2t(L, luaH_set(L, hvalue(t), &k), L->top - 1);
+  luaC_barrierback(L, gcvalue(t), L->top - 1);
+  L->top--;
+  lua_unlock(L);
+}
+
+
+LUA_API int lua_setmetatable (lua_State *L, int objindex) {
+  TValue *obj;
+  Table *mt;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  obj = index2addr(L, objindex);
+  if (ttisnil(L->top - 1))
+    mt = NULL;
+  else {
+    api_check(L, ttistable(L->top - 1), "table expected");
+    mt = hvalue(L->top - 1);
+  }
+  switch (ttypenv(obj)) {
+    case LUA_TTABLE: {
+      hvalue(obj)->metatable = mt;
+      if (mt) {
+        luaC_objbarrierback(L, gcvalue(obj), mt);
+        luaC_checkfinalizer(L, gcvalue(obj), mt);
+      }
+      break;
+    }
+    case LUA_TUSERDATA: {
+      uvalue(obj)->metatable = mt;
+      if (mt) {
+        luaC_objbarrier(L, rawuvalue(obj), mt);
+        luaC_checkfinalizer(L, gcvalue(obj), mt);
+      }
+      break;
+    }
+    default: {
+      G(L)->mt[ttypenv(obj)] = mt;
+      break;
+    }
+  }
+  L->top--;
+  lua_unlock(L);
+  return 1;
+}
+
+
+LUA_API void lua_setuservalue (lua_State *L, int idx) {
+  StkId o;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  o = index2addr(L, idx);
+  api_check(L, ttisuserdata(o), "userdata expected");
+  if (ttisnil(L->top - 1))
+    uvalue(o)->env = NULL;
+  else {
+    api_check(L, ttistable(L->top - 1), "table expected");
+    uvalue(o)->env = hvalue(L->top - 1);
+    luaC_objbarrier(L, gcvalue(o), hvalue(L->top - 1));
+  }
+  L->top--;
+  lua_unlock(L);
+}
+
+
+/*
+** `load' and `call' functions (run Lua code)
+*/
+
+
+#define checkresults(L,na,nr) \
+     api_check(L, (nr) == LUA_MULTRET || (L->ci->top - L->top >= (nr) - (na)), \
+	"results from function overflow current stack size")
+
+
+LUA_API int lua_getctx (lua_State *L, int *ctx) {
+  if (L->ci->callstatus & CIST_YIELDED) {
+    if (ctx) *ctx = L->ci->u.c.ctx;
+    return L->ci->u.c.status;
+  }
+  else return LUA_OK;
+}
+
+
+LUA_API void lua_callk (lua_State *L, int nargs, int nresults, int ctx,
+                        lua_CFunction k) {
+  StkId func;
+  lua_lock(L);
+  api_check(L, k == NULL || !isLua(L->ci),
+    "cannot use continuations inside hooks");
+  api_checknelems(L, nargs+1);
+  api_check(L, L->status == LUA_OK, "cannot do calls on non-normal thread");
+  checkresults(L, nargs, nresults);
+  func = L->top - (nargs+1);
+  if (k != NULL && L->nny == 0) {  /* need to prepare continuation? */
+    L->ci->u.c.k = k;  /* save continuation */
+    L->ci->u.c.ctx = ctx;  /* save context */
+    luaD_call(L, func, nresults, 1);  /* do the call */
+  }
+  else  /* no continuation or no yieldable */
+    luaD_call(L, func, nresults, 0);  /* just do the call */
+  adjustresults(L, nresults);
+  lua_unlock(L);
+}
+
+
+
+/*
+** Execute a protected call.
+*/
+struct CallS {  /* data to `f_call' */
+  StkId func;
+  int nresults;
+};
+
+
+static void f_call (lua_State *L, void *ud) {
+  struct CallS *c = cast(struct CallS *, ud);
+  luaD_call(L, c->func, c->nresults, 0);
+}
+
+
+
+LUA_API int lua_pcallk (lua_State *L, int nargs, int nresults, int errfunc,
+                        int ctx, lua_CFunction k) {
+  struct CallS c;
+  int status;
+  ptrdiff_t func;
+  lua_lock(L);
+  api_check(L, k == NULL || !isLua(L->ci),
+    "cannot use continuations inside hooks");
+  api_checknelems(L, nargs+1);
+  api_check(L, L->status == LUA_OK, "cannot do calls on non-normal thread");
+  checkresults(L, nargs, nresults);
+  if (errfunc == 0)
+    func = 0;
+  else {
+    StkId o = index2addr(L, errfunc);
+    api_checkstackindex(L, errfunc, o);
+    func = savestack(L, o);
+  }
+  c.func = L->top - (nargs+1);  /* function to be called */
+  if (k == NULL || L->nny > 0) {  /* no continuation or no yieldable? */
+    c.nresults = nresults;  /* do a 'conventional' protected call */
+    status = luaD_pcall(L, f_call, &c, savestack(L, c.func), func);
+  }
+  else {  /* prepare continuation (call is already protected by 'resume') */
+    CallInfo *ci = L->ci;
+    ci->u.c.k = k;  /* save continuation */
+    ci->u.c.ctx = ctx;  /* save context */
+    /* save information for error recovery */
+    ci->extra = savestack(L, c.func);
+    ci->u.c.old_allowhook = L->allowhook;
+    ci->u.c.old_errfunc = L->errfunc;
+    L->errfunc = func;
+    /* mark that function may do error recovery */
+    ci->callstatus |= CIST_YPCALL;
+    luaD_call(L, c.func, nresults, 1);  /* do the call */
+    ci->callstatus &= ~CIST_YPCALL;
+    L->errfunc = ci->u.c.old_errfunc;
+    status = LUA_OK;  /* if it is here, there were no errors */
+  }
+  adjustresults(L, nresults);
+  lua_unlock(L);
+  return status;
+}
+
+
+LUA_API int lua_load (lua_State *L, lua_Reader reader, void *data,
+                      const char *chunkname, const char *mode) {
+  ZIO z;
+  int status;
+  lua_lock(L);
+  if (!chunkname) chunkname = "?";
+  luaZ_init(L, &z, reader, data);
+  status = luaD_protectedparser(L, &z, chunkname, mode);
+  if (status == LUA_OK) {  /* no errors? */
+    LClosure *f = clLvalue(L->top - 1);  /* get newly created function */
+    if (f->nupvalues == 1) {  /* does it have one upvalue? */
+      /* get global table from registry */
+      Table *reg = hvalue(&G(L)->l_registry);
+      const TValue *gt = luaH_getint(reg, LUA_RIDX_GLOBALS);
+      /* set global table as 1st upvalue of 'f' (may be LUA_ENV) */
+      setobj(L, f->upvals[0]->v, gt);
+      luaC_barrier(L, f->upvals[0], gt);
+    }
+  }
+  lua_unlock(L);
+  return status;
+}
+
+
+LUA_API int lua_dump (lua_State *L, lua_Writer writer, void *data) {
+  int status;
+  TValue *o;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  o = L->top - 1;
+  if (isLfunction(o))
+    status = luaU_dump(L, getproto(o), writer, data, 0);
+  else
+    status = 1;
+  lua_unlock(L);
+  return status;
+}
+
+
+LUA_API int lua_status (lua_State *L) {
+  return L->status;
+}
+
+
+/*
+** Garbage-collection function
+*/
+
+LUA_API int lua_gc (lua_State *L, int what, int data) {
+  int res = 0;
+  global_State *g;
+  lua_lock(L);
+  g = G(L);
+  switch (what) {
+    case LUA_GCSTOP: {
+      g->gcrunning = 0;
+      break;
+    }
+    case LUA_GCRESTART: {
+      luaE_setdebt(g, 0);
+      g->gcrunning = 1;
+      break;
+    }
+    case LUA_GCCOLLECT: {
+      luaC_fullgc(L, 0);
+      break;
+    }
+    case LUA_GCCOUNT: {
+      /* GC values are expressed in Kbytes: #bytes/2^10 */
+      res = cast_int(gettotalbytes(g) >> 10);
+      break;
+    }
+    case LUA_GCCOUNTB: {
+      res = cast_int(gettotalbytes(g) & 0x3ff);
+      break;
+    }
+    case LUA_GCSTEP: {
+      if (g->gckind == KGC_GEN) {  /* generational mode? */
+        res = (g->GCestimate == 0);  /* true if it will do major collection */
+        luaC_forcestep(L);  /* do a single step */
+      }
+      else {
+       lu_mem debt = cast(lu_mem, data) * 1024 - GCSTEPSIZE;
+       if (g->gcrunning)
+         debt += g->GCdebt;  /* include current debt */
+       luaE_setdebt(g, debt);
+       luaC_forcestep(L);
+       if (g->gcstate == GCSpause)  /* end of cycle? */
+         res = 1;  /* signal it */
+      }
+      break;
+    }
+    case LUA_GCSETPAUSE: {
+      res = g->gcpause;
+      g->gcpause = data;
+      break;
+    }
+    case LUA_GCSETMAJORINC: {
+      res = g->gcmajorinc;
+      g->gcmajorinc = data;
+      break;
+    }
+    case LUA_GCSETSTEPMUL: {
+      res = g->gcstepmul;
+      g->gcstepmul = data;
+      break;
+    }
+    case LUA_GCISRUNNING: {
+      res = g->gcrunning;
+      break;
+    }
+    case LUA_GCGEN: {  /* change collector to generational mode */
+      luaC_changemode(L, KGC_GEN);
+      break;
+    }
+    case LUA_GCINC: {  /* change collector to incremental mode */
+      luaC_changemode(L, KGC_NORMAL);
+      break;
+    }
+    default: res = -1;  /* invalid option */
+  }
+  lua_unlock(L);
+  return res;
+}
+
+
+
+/*
+** miscellaneous functions
+*/
+
+
+LUA_API int lua_error (lua_State *L) {
+  lua_lock(L);
+  api_checknelems(L, 1);
+  luaG_errormsg(L);
+  /* code unreachable; will unlock when control actually leaves the kernel */
+  return 0;  /* to avoid warnings */
+}
+
+
+LUA_API int lua_next (lua_State *L, int idx) {
+  StkId t;
+  int more;
+  lua_lock(L);
+  t = index2addr(L, idx);
+  api_check(L, ttistable(t), "table expected");
+  more = luaH_next(L, hvalue(t), L->top - 1);
+  if (more) {
+    api_incr_top(L);
+  }
+  else  /* no more elements */
+    L->top -= 1;  /* remove key */
+  lua_unlock(L);
+  return more;
+}
+
+
+LUA_API void lua_concat (lua_State *L, int n) {
+  lua_lock(L);
+  api_checknelems(L, n);
+  if (n >= 2) {
+    luaC_checkGC(L);
+    luaV_concat(L, n);
+  }
+  else if (n == 0) {  /* push empty string */
+    setsvalue2s(L, L->top, luaS_newlstr(L, "", 0));
+    api_incr_top(L);
+  }
+  /* else n == 1; nothing to do */
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_len (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  t = index2addr(L, idx);
+  luaV_objlen(L, L->top, t);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API lua_Alloc lua_getallocf (lua_State *L, void **ud) {
+  lua_Alloc f;
+  lua_lock(L);
+  if (ud) *ud = G(L)->ud;
+  f = G(L)->frealloc;
+  lua_unlock(L);
+  return f;
+}
+
+
+LUA_API void lua_setallocf (lua_State *L, lua_Alloc f, void *ud) {
+  lua_lock(L);
+  G(L)->ud = ud;
+  G(L)->frealloc = f;
+  lua_unlock(L);
+}
+
+
+LUA_API void *lua_newuserdata (lua_State *L, size_t size) {
+  Udata *u;
+  lua_lock(L);
+  luaC_checkGC(L);
+  u = luaS_newudata(L, size, NULL);
+  setuvalue(L, L->top, u);
+  api_incr_top(L);
+  lua_unlock(L);
+  return u + 1;
+}
+
+
+
+static const char *aux_upvalue (StkId fi, int n, TValue **val,
+                                GCObject **owner) {
+  switch (ttype(fi)) {
+    case LUA_TCCL: {  /* C closure */
+      CClosure *f = clCvalue(fi);
+      if (!(1 <= n && n <= f->nupvalues)) return NULL;
+      *val = &f->upvalue[n-1];
+      if (owner) *owner = obj2gco(f);
+      return "";
+    }
+    case LUA_TLCL: {  /* Lua closure */
+      LClosure *f = clLvalue(fi);
+      TString *name;
+      Proto *p = f->p;
+      if (!(1 <= n && n <= p->sizeupvalues)) return NULL;
+      *val = f->upvals[n-1]->v;
+      if (owner) *owner = obj2gco(f->upvals[n - 1]);
+      name = p->upvalues[n-1].name;
+      return (name == NULL) ? "" : getstr(name);
+    }
+    default: return NULL;  /* not a closure */
+  }
+}
+
+
+LUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n) {
+  const char *name;
+  TValue *val = NULL;  /* to avoid warnings */
+  lua_lock(L);
+  name = aux_upvalue(index2addr(L, funcindex), n, &val, NULL);
+  if (name) {
+    setobj2s(L, L->top, val);
+    api_incr_top(L);
+  }
+  lua_unlock(L);
+  return name;
+}
+
+
+LUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n) {
+  const char *name;
+  TValue *val = NULL;  /* to avoid warnings */
+  GCObject *owner = NULL;  /* to avoid warnings */
+  StkId fi;
+  lua_lock(L);
+  fi = index2addr(L, funcindex);
+  api_checknelems(L, 1);
+  name = aux_upvalue(fi, n, &val, &owner);
+  if (name) {
+    L->top--;
+    setobj(L, val, L->top);
+    luaC_barrier(L, owner, L->top);
+  }
+  lua_unlock(L);
+  return name;
+}
+
+
+static UpVal **getupvalref (lua_State *L, int fidx, int n, LClosure **pf) {
+  LClosure *f;
+  StkId fi = index2addr(L, fidx);
+  api_check(L, ttisLclosure(fi), "Lua function expected");
+  f = clLvalue(fi);
+  api_check(L, (1 <= n && n <= f->p->sizeupvalues), "invalid upvalue index");
+  if (pf) *pf = f;
+  return &f->upvals[n - 1];  /* get its upvalue pointer */
+}
+
+
+LUA_API void *lua_upvalueid (lua_State *L, int fidx, int n) {
+  StkId fi = index2addr(L, fidx);
+  switch (ttype(fi)) {
+    case LUA_TLCL: {  /* lua closure */
+      return *getupvalref(L, fidx, n, NULL);
+    }
+    case LUA_TCCL: {  /* C closure */
+      CClosure *f = clCvalue(fi);
+      api_check(L, 1 <= n && n <= f->nupvalues, "invalid upvalue index");
+      return &f->upvalue[n - 1];
+    }
+    default: {
+      api_check(L, 0, "closure expected");
+      return NULL;
+    }
+  }
+}
+
+
+LUA_API void lua_upvaluejoin (lua_State *L, int fidx1, int n1,
+                                            int fidx2, int n2) {
+  LClosure *f1;
+  UpVal **up1 = getupvalref(L, fidx1, n1, &f1);
+  UpVal **up2 = getupvalref(L, fidx2, n2, NULL);
+  *up1 = *up2;
+  luaC_objbarrier(L, f1, *up2);
+}
+
diff -ruNp src.orig/libs/lua/lapi.h src/libs/lua/lapi.h
--- src.orig/libs/lua/lapi.h	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lapi.h	2017-11-21 19:39:45 -0600
@@ -0,0 +1,24 @@
+/*
+** $Id: lapi.h,v 2.7 2009/11/27 15:37:59 roberto Exp $
+** Auxiliary functions from Lua API
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lapi_h
+#define lapi_h
+
+
+#include "llimits.h"
+#include "lstate.h"
+
+#define api_incr_top(L)   {L->top++; api_check(L, L->top <= L->ci->top, \
+				"stack overflow");}
+
+#define adjustresults(L,nres) \
+    { if ((nres) == LUA_MULTRET && L->ci->top < L->top) L->ci->top = L->top; }
+
+#define api_checknelems(L,n)	api_check(L, (n) < (L->top - L->ci->func), \
+				  "not enough elements in the stack")
+
+
+#endif
diff -ruNp src.orig/libs/lua/lauxlib.c src/libs/lua/lauxlib.c
--- src.orig/libs/lua/lauxlib.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lauxlib.c	2017-11-21 19:39:45 -0600
@@ -0,0 +1,959 @@
+/*
+** $Id: lauxlib.c,v 1.248 2013/03/21 13:54:57 roberto Exp $
+** Auxiliary functions for building Lua libraries
+** See Copyright Notice in lua.h
+*/
+
+
+#include <errno.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+
+/* This file uses only the official API of Lua.
+** Any function declared here could be written as an application function.
+*/
+
+#define lauxlib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+
+
+/*
+** {======================================================
+** Traceback
+** =======================================================
+*/
+
+
+#define LEVELS1	12	/* size of the first part of the stack */
+#define LEVELS2	10	/* size of the second part of the stack */
+
+
+
+/*
+** search for 'objidx' in table at index -1.
+** return 1 + string at top if find a good name.
+*/
+static int findfield (lua_State *L, int objidx, int level) {
+  if (level == 0 || !lua_istable(L, -1))
+    return 0;  /* not found */
+  lua_pushnil(L);  /* start 'next' loop */
+  while (lua_next(L, -2)) {  /* for each pair in table */
+    if (lua_type(L, -2) == LUA_TSTRING) {  /* ignore non-string keys */
+      if (lua_rawequal(L, objidx, -1)) {  /* found object? */
+        lua_pop(L, 1);  /* remove value (but keep name) */
+        return 1;
+      }
+      else if (findfield(L, objidx, level - 1)) {  /* try recursively */
+        lua_remove(L, -2);  /* remove table (but keep name) */
+        lua_pushliteral(L, ".");
+        lua_insert(L, -2);  /* place '.' between the two names */
+        lua_concat(L, 3);
+        return 1;
+      }
+    }
+    lua_pop(L, 1);  /* remove value */
+  }
+  return 0;  /* not found */
+}
+
+
+static int pushglobalfuncname (lua_State *L, lua_Debug *ar) {
+  int top = lua_gettop(L);
+  lua_getinfo(L, "f", ar);  /* push function */
+  lua_pushglobaltable(L);
+  if (findfield(L, top + 1, 2)) {
+    lua_copy(L, -1, top + 1);  /* move name to proper place */
+    lua_pop(L, 2);  /* remove pushed values */
+    return 1;
+  }
+  else {
+    lua_settop(L, top);  /* remove function and global table */
+    return 0;
+  }
+}
+
+
+static void pushfuncname (lua_State *L, lua_Debug *ar) {
+  if (*ar->namewhat != '\0')  /* is there a name? */
+    lua_pushfstring(L, "function " LUA_QS, ar->name);
+  else if (*ar->what == 'm')  /* main? */
+      lua_pushliteral(L, "main chunk");
+  else if (*ar->what == 'C') {
+    if (pushglobalfuncname(L, ar)) {
+      lua_pushfstring(L, "function " LUA_QS, lua_tostring(L, -1));
+      lua_remove(L, -2);  /* remove name */
+    }
+    else
+      lua_pushliteral(L, "?");
+  }
+  else
+    lua_pushfstring(L, "function <%s:%d>", ar->short_src, ar->linedefined);
+}
+
+
+static int countlevels (lua_State *L) {
+  lua_Debug ar;
+  int li = 1, le = 1;
+  /* find an upper bound */
+  while (lua_getstack(L, le, &ar)) { li = le; le *= 2; }
+  /* do a binary search */
+  while (li < le) {
+    int m = (li + le)/2;
+    if (lua_getstack(L, m, &ar)) li = m + 1;
+    else le = m;
+  }
+  return le - 1;
+}
+
+
+LUALIB_API void luaL_traceback (lua_State *L, lua_State *L1,
+                                const char *msg, int level) {
+  lua_Debug ar;
+  int top = lua_gettop(L);
+  int numlevels = countlevels(L1);
+  int mark = (numlevels > LEVELS1 + LEVELS2) ? LEVELS1 : 0;
+  if (msg) lua_pushfstring(L, "%s\n", msg);
+  lua_pushliteral(L, "stack traceback:");
+  while (lua_getstack(L1, level++, &ar)) {
+    if (level == mark) {  /* too many levels? */
+      lua_pushliteral(L, "\n\t...");  /* add a '...' */
+      level = numlevels - LEVELS2;  /* and skip to last ones */
+    }
+    else {
+      lua_getinfo(L1, "Slnt", &ar);
+      lua_pushfstring(L, "\n\t%s:", ar.short_src);
+      if (ar.currentline > 0)
+        lua_pushfstring(L, "%d:", ar.currentline);
+      lua_pushliteral(L, " in ");
+      pushfuncname(L, &ar);
+      if (ar.istailcall)
+        lua_pushliteral(L, "\n\t(...tail calls...)");
+      lua_concat(L, lua_gettop(L) - top);
+    }
+  }
+  lua_concat(L, lua_gettop(L) - top);
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Error-report functions
+** =======================================================
+*/
+
+LUALIB_API int luaL_argerror (lua_State *L, int narg, const char *extramsg) {
+  lua_Debug ar;
+  if (!lua_getstack(L, 0, &ar))  /* no stack frame? */
+    return luaL_error(L, "bad argument #%d (%s)", narg, extramsg);
+  lua_getinfo(L, "n", &ar);
+  if (strcmp(ar.namewhat, "method") == 0) {
+    narg--;  /* do not count `self' */
+    if (narg == 0)  /* error is in the self argument itself? */
+      return luaL_error(L, "calling " LUA_QS " on bad self (%s)",
+                           ar.name, extramsg);
+  }
+  if (ar.name == NULL)
+    ar.name = (pushglobalfuncname(L, &ar)) ? lua_tostring(L, -1) : "?";
+  return luaL_error(L, "bad argument #%d to " LUA_QS " (%s)",
+                        narg, ar.name, extramsg);
+}
+
+
+static int typeerror (lua_State *L, int narg, const char *tname) {
+  const char *msg = lua_pushfstring(L, "%s expected, got %s",
+                                    tname, luaL_typename(L, narg));
+  return luaL_argerror(L, narg, msg);
+}
+
+
+static void tag_error (lua_State *L, int narg, int tag) {
+  typeerror(L, narg, lua_typename(L, tag));
+}
+
+
+LUALIB_API void luaL_where (lua_State *L, int level) {
+  lua_Debug ar;
+  if (lua_getstack(L, level, &ar)) {  /* check function at level */
+    lua_getinfo(L, "Sl", &ar);  /* get info about it */
+    if (ar.currentline > 0) {  /* is there info? */
+      lua_pushfstring(L, "%s:%d: ", ar.short_src, ar.currentline);
+      return;
+    }
+  }
+  lua_pushliteral(L, "");  /* else, no information available... */
+}
+
+
+LUALIB_API int luaL_error (lua_State *L, const char *fmt, ...) {
+  va_list argp;
+  va_start(argp, fmt);
+  luaL_where(L, 1);
+  lua_pushvfstring(L, fmt, argp);
+  va_end(argp);
+  lua_concat(L, 2);
+  return lua_error(L);
+}
+
+
+LUALIB_API int luaL_fileresult (lua_State *L, int stat, const char *fname) {
+  int en = errno;  /* calls to Lua API may change this value */
+  if (stat) {
+    lua_pushboolean(L, 1);
+    return 1;
+  }
+  else {
+    lua_pushnil(L);
+    if (fname)
+      lua_pushfstring(L, "%s: %s", fname, strerror(en));
+    else
+      lua_pushstring(L, strerror(en));
+    lua_pushinteger(L, en);
+    return 3;
+  }
+}
+
+
+#if !defined(inspectstat)	/* { */
+
+#if defined(LUA_USE_POSIX)
+
+#include <sys/wait.h>
+
+/*
+** use appropriate macros to interpret 'pclose' return status
+*/
+#define inspectstat(stat,what)  \
+   if (WIFEXITED(stat)) { stat = WEXITSTATUS(stat); } \
+   else if (WIFSIGNALED(stat)) { stat = WTERMSIG(stat); what = "signal"; }
+
+#else
+
+#define inspectstat(stat,what)  /* no op */
+
+#endif
+
+#endif				/* } */
+
+
+LUALIB_API int luaL_execresult (lua_State *L, int stat) {
+  const char *what = "exit";  /* type of termination */
+  if (stat == -1)  /* error? */
+    return luaL_fileresult(L, 0, NULL);
+  else {
+    inspectstat(stat, what);  /* interpret result */
+    if (*what == 'e' && stat == 0)  /* successful termination? */
+      lua_pushboolean(L, 1);
+    else
+      lua_pushnil(L);
+    lua_pushstring(L, what);
+    lua_pushinteger(L, stat);
+    return 3;  /* return true/nil,what,code */
+  }
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Userdata's metatable manipulation
+** =======================================================
+*/
+
+LUALIB_API int luaL_newmetatable (lua_State *L, const char *tname) {
+  luaL_getmetatable(L, tname);  /* try to get metatable */
+  if (!lua_isnil(L, -1))  /* name already in use? */
+    return 0;  /* leave previous value on top, but return 0 */
+  lua_pop(L, 1);
+  lua_newtable(L);  /* create metatable */
+  lua_pushvalue(L, -1);
+  lua_setfield(L, LUA_REGISTRYINDEX, tname);  /* registry.name = metatable */
+  return 1;
+}
+
+
+LUALIB_API void luaL_setmetatable (lua_State *L, const char *tname) {
+  luaL_getmetatable(L, tname);
+  lua_setmetatable(L, -2);
+}
+
+
+LUALIB_API void *luaL_testudata (lua_State *L, int ud, const char *tname) {
+  void *p = lua_touserdata(L, ud);
+  if (p != NULL) {  /* value is a userdata? */
+    if (lua_getmetatable(L, ud)) {  /* does it have a metatable? */
+      luaL_getmetatable(L, tname);  /* get correct metatable */
+      if (!lua_rawequal(L, -1, -2))  /* not the same? */
+        p = NULL;  /* value is a userdata with wrong metatable */
+      lua_pop(L, 2);  /* remove both metatables */
+      return p;
+    }
+  }
+  return NULL;  /* value is not a userdata with a metatable */
+}
+
+
+LUALIB_API void *luaL_checkudata (lua_State *L, int ud, const char *tname) {
+  void *p = luaL_testudata(L, ud, tname);
+  if (p == NULL) typeerror(L, ud, tname);
+  return p;
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Argument check functions
+** =======================================================
+*/
+
+LUALIB_API int luaL_checkoption (lua_State *L, int narg, const char *def,
+                                 const char *const lst[]) {
+  const char *name = (def) ? luaL_optstring(L, narg, def) :
+                             luaL_checkstring(L, narg);
+  int i;
+  for (i=0; lst[i]; i++)
+    if (strcmp(lst[i], name) == 0)
+      return i;
+  return luaL_argerror(L, narg,
+                       lua_pushfstring(L, "invalid option " LUA_QS, name));
+}
+
+
+LUALIB_API void luaL_checkstack (lua_State *L, int space, const char *msg) {
+  /* keep some extra space to run error routines, if needed */
+  const int extra = LUA_MINSTACK;
+  if (!lua_checkstack(L, space + extra)) {
+    if (msg)
+      luaL_error(L, "stack overflow (%s)", msg);
+    else
+      luaL_error(L, "stack overflow");
+  }
+}
+
+
+LUALIB_API void luaL_checktype (lua_State *L, int narg, int t) {
+  if (lua_type(L, narg) != t)
+    tag_error(L, narg, t);
+}
+
+
+LUALIB_API void luaL_checkany (lua_State *L, int narg) {
+  if (lua_type(L, narg) == LUA_TNONE)
+    luaL_argerror(L, narg, "value expected");
+}
+
+
+LUALIB_API const char *luaL_checklstring (lua_State *L, int narg, size_t *len) {
+  const char *s = lua_tolstring(L, narg, len);
+  if (!s) tag_error(L, narg, LUA_TSTRING);
+  return s;
+}
+
+
+LUALIB_API const char *luaL_optlstring (lua_State *L, int narg,
+                                        const char *def, size_t *len) {
+  if (lua_isnoneornil(L, narg)) {
+    if (len)
+      *len = (def ? strlen(def) : 0);
+    return def;
+  }
+  else return luaL_checklstring(L, narg, len);
+}
+
+
+LUALIB_API lua_Number luaL_checknumber (lua_State *L, int narg) {
+  int isnum;
+  lua_Number d = lua_tonumberx(L, narg, &isnum);
+  if (!isnum)
+    tag_error(L, narg, LUA_TNUMBER);
+  return d;
+}
+
+
+LUALIB_API lua_Number luaL_optnumber (lua_State *L, int narg, lua_Number def) {
+  return luaL_opt(L, luaL_checknumber, narg, def);
+}
+
+
+LUALIB_API lua_Integer luaL_checkinteger (lua_State *L, int narg) {
+  int isnum;
+  lua_Integer d = lua_tointegerx(L, narg, &isnum);
+  if (!isnum)
+    tag_error(L, narg, LUA_TNUMBER);
+  return d;
+}
+
+
+LUALIB_API lua_Unsigned luaL_checkunsigned (lua_State *L, int narg) {
+  int isnum;
+  lua_Unsigned d = lua_tounsignedx(L, narg, &isnum);
+  if (!isnum)
+    tag_error(L, narg, LUA_TNUMBER);
+  return d;
+}
+
+
+LUALIB_API lua_Integer luaL_optinteger (lua_State *L, int narg,
+                                                      lua_Integer def) {
+  return luaL_opt(L, luaL_checkinteger, narg, def);
+}
+
+
+LUALIB_API lua_Unsigned luaL_optunsigned (lua_State *L, int narg,
+                                                        lua_Unsigned def) {
+  return luaL_opt(L, luaL_checkunsigned, narg, def);
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Generic Buffer manipulation
+** =======================================================
+*/
+
+/*
+** check whether buffer is using a userdata on the stack as a temporary
+** buffer
+*/
+#define buffonstack(B)	((B)->b != (B)->initb)
+
+
+/*
+** returns a pointer to a free area with at least 'sz' bytes
+*/
+LUALIB_API char *luaL_prepbuffsize (luaL_Buffer *B, size_t sz) {
+  lua_State *L = B->L;
+  if (B->size - B->n < sz) {  /* not enough space? */
+    char *newbuff;
+    size_t newsize = B->size * 2;  /* double buffer size */
+    if (newsize - B->n < sz)  /* not big enough? */
+      newsize = B->n + sz;
+    if (newsize < B->n || newsize - B->n < sz)
+      luaL_error(L, "buffer too large");
+    /* create larger buffer */
+    newbuff = (char *)lua_newuserdata(L, newsize * sizeof(char));
+    /* move content to new buffer */
+    memcpy(newbuff, B->b, B->n * sizeof(char));
+    if (buffonstack(B))
+      lua_remove(L, -2);  /* remove old buffer */
+    B->b = newbuff;
+    B->size = newsize;
+  }
+  return &B->b[B->n];
+}
+
+
+LUALIB_API void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l) {
+  char *b = luaL_prepbuffsize(B, l);
+  memcpy(b, s, l * sizeof(char));
+  luaL_addsize(B, l);
+}
+
+
+LUALIB_API void luaL_addstring (luaL_Buffer *B, const char *s) {
+  luaL_addlstring(B, s, strlen(s));
+}
+
+
+LUALIB_API void luaL_pushresult (luaL_Buffer *B) {
+  lua_State *L = B->L;
+  lua_pushlstring(L, B->b, B->n);
+  if (buffonstack(B))
+    lua_remove(L, -2);  /* remove old buffer */
+}
+
+
+LUALIB_API void luaL_pushresultsize (luaL_Buffer *B, size_t sz) {
+  luaL_addsize(B, sz);
+  luaL_pushresult(B);
+}
+
+
+LUALIB_API void luaL_addvalue (luaL_Buffer *B) {
+  lua_State *L = B->L;
+  size_t l;
+  const char *s = lua_tolstring(L, -1, &l);
+  if (buffonstack(B))
+    lua_insert(L, -2);  /* put value below buffer */
+  luaL_addlstring(B, s, l);
+  lua_remove(L, (buffonstack(B)) ? -2 : -1);  /* remove value */
+}
+
+
+LUALIB_API void luaL_buffinit (lua_State *L, luaL_Buffer *B) {
+  B->L = L;
+  B->b = B->initb;
+  B->n = 0;
+  B->size = LUAL_BUFFERSIZE;
+}
+
+
+LUALIB_API char *luaL_buffinitsize (lua_State *L, luaL_Buffer *B, size_t sz) {
+  luaL_buffinit(L, B);
+  return luaL_prepbuffsize(B, sz);
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Reference system
+** =======================================================
+*/
+
+/* index of free-list header */
+#define freelist	0
+
+
+LUALIB_API int luaL_ref (lua_State *L, int t) {
+  int ref;
+  if (lua_isnil(L, -1)) {
+    lua_pop(L, 1);  /* remove from stack */
+    return LUA_REFNIL;  /* `nil' has a unique fixed reference */
+  }
+  t = lua_absindex(L, t);
+  lua_rawgeti(L, t, freelist);  /* get first free element */
+  ref = (int)lua_tointeger(L, -1);  /* ref = t[freelist] */
+  lua_pop(L, 1);  /* remove it from stack */
+  if (ref != 0) {  /* any free element? */
+    lua_rawgeti(L, t, ref);  /* remove it from list */
+    lua_rawseti(L, t, freelist);  /* (t[freelist] = t[ref]) */
+  }
+  else  /* no free elements */
+    ref = (int)lua_rawlen(L, t) + 1;  /* get a new reference */
+  lua_rawseti(L, t, ref);
+  return ref;
+}
+
+
+LUALIB_API void luaL_unref (lua_State *L, int t, int ref) {
+  if (ref >= 0) {
+    t = lua_absindex(L, t);
+    lua_rawgeti(L, t, freelist);
+    lua_rawseti(L, t, ref);  /* t[ref] = t[freelist] */
+    lua_pushinteger(L, ref);
+    lua_rawseti(L, t, freelist);  /* t[freelist] = ref */
+  }
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Load functions
+** =======================================================
+*/
+
+typedef struct LoadF {
+  int n;  /* number of pre-read characters */
+  FILE *f;  /* file being read */
+  char buff[LUAL_BUFFERSIZE];  /* area for reading file */
+} LoadF;
+
+
+static const char *getF (lua_State *L, void *ud, size_t *size) {
+  LoadF *lf = (LoadF *)ud;
+  (void)L;  /* not used */
+  if (lf->n > 0) {  /* are there pre-read characters to be read? */
+    *size = lf->n;  /* return them (chars already in buffer) */
+    lf->n = 0;  /* no more pre-read characters */
+  }
+  else {  /* read a block from file */
+    /* 'fread' can return > 0 *and* set the EOF flag. If next call to
+       'getF' called 'fread', it might still wait for user input.
+       The next check avoids this problem. */
+    if (feof(lf->f)) return NULL;
+    *size = fread(lf->buff, 1, sizeof(lf->buff), lf->f);  /* read block */
+  }
+  return lf->buff;
+}
+
+
+static int errfile (lua_State *L, const char *what, int fnameindex) {
+  const char *serr = strerror(errno);
+  const char *filename = lua_tostring(L, fnameindex) + 1;
+  lua_pushfstring(L, "cannot %s %s: %s", what, filename, serr);
+  lua_remove(L, fnameindex);
+  return LUA_ERRFILE;
+}
+
+
+static int skipBOM (LoadF *lf) {
+  const char *p = "\xEF\xBB\xBF";  /* Utf8 BOM mark */
+  int c;
+  lf->n = 0;
+  do {
+    c = getc(lf->f);
+    if (c == EOF || c != *(const unsigned char *)p++) return c;
+    lf->buff[lf->n++] = c;  /* to be read by the parser */
+  } while (*p != '\0');
+  lf->n = 0;  /* prefix matched; discard it */
+  return getc(lf->f);  /* return next character */
+}
+
+
+/*
+** reads the first character of file 'f' and skips an optional BOM mark
+** in its beginning plus its first line if it starts with '#'. Returns
+** true if it skipped the first line.  In any case, '*cp' has the
+** first "valid" character of the file (after the optional BOM and
+** a first-line comment).
+*/
+static int skipcomment (LoadF *lf, int *cp) {
+  int c = *cp = skipBOM(lf);
+  if (c == '#') {  /* first line is a comment (Unix exec. file)? */
+    do {  /* skip first line */
+      c = getc(lf->f);
+    } while (c != EOF && c != '\n') ;
+    *cp = getc(lf->f);  /* skip end-of-line, if present */
+    return 1;  /* there was a comment */
+  }
+  else return 0;  /* no comment */
+}
+
+
+LUALIB_API int luaL_loadfilex (lua_State *L, const char *filename,
+                                             const char *mode) {
+  LoadF lf;
+  int status, readstatus;
+  int c;
+  int fnameindex = lua_gettop(L) + 1;  /* index of filename on the stack */
+  if (filename == NULL) {
+    lua_pushliteral(L, "=stdin");
+    lf.f = stdin;
+  }
+  else {
+    lua_pushfstring(L, "@%s", filename);
+    lf.f = fopen(filename, "r");
+    if (lf.f == NULL) return errfile(L, "open", fnameindex);
+  }
+  if (skipcomment(&lf, &c))  /* read initial portion */
+    lf.buff[lf.n++] = '\n';  /* add line to correct line numbers */
+  if (c == LUA_SIGNATURE[0] && filename) {  /* binary file? */
+    lf.f = freopen(filename, "rb", lf.f);  /* reopen in binary mode */
+    if (lf.f == NULL) return errfile(L, "reopen", fnameindex);
+    skipcomment(&lf, &c);  /* re-read initial portion */
+  }
+  if (c != EOF)
+    lf.buff[lf.n++] = c;  /* 'c' is the first character of the stream */
+  status = lua_load(L, getF, &lf, lua_tostring(L, -1), mode);
+  readstatus = ferror(lf.f);
+  if (filename) fclose(lf.f);  /* close file (even in case of errors) */
+  if (readstatus) {
+    lua_settop(L, fnameindex);  /* ignore results from `lua_load' */
+    return errfile(L, "read", fnameindex);
+  }
+  lua_remove(L, fnameindex);
+  return status;
+}
+
+
+typedef struct LoadS {
+  const char *s;
+  size_t size;
+} LoadS;
+
+
+static const char *getS (lua_State *L, void *ud, size_t *size) {
+  LoadS *ls = (LoadS *)ud;
+  (void)L;  /* not used */
+  if (ls->size == 0) return NULL;
+  *size = ls->size;
+  ls->size = 0;
+  return ls->s;
+}
+
+
+LUALIB_API int luaL_loadbufferx (lua_State *L, const char *buff, size_t size,
+                                 const char *name, const char *mode) {
+  LoadS ls;
+  ls.s = buff;
+  ls.size = size;
+  return lua_load(L, getS, &ls, name, mode);
+}
+
+
+LUALIB_API int luaL_loadstring (lua_State *L, const char *s) {
+  return luaL_loadbuffer(L, s, strlen(s), s);
+}
+
+/* }====================================================== */
+
+
+
+LUALIB_API int luaL_getmetafield (lua_State *L, int obj, const char *event) {
+  if (!lua_getmetatable(L, obj))  /* no metatable? */
+    return 0;
+  lua_pushstring(L, event);
+  lua_rawget(L, -2);
+  if (lua_isnil(L, -1)) {
+    lua_pop(L, 2);  /* remove metatable and metafield */
+    return 0;
+  }
+  else {
+    lua_remove(L, -2);  /* remove only metatable */
+    return 1;
+  }
+}
+
+
+LUALIB_API int luaL_callmeta (lua_State *L, int obj, const char *event) {
+  obj = lua_absindex(L, obj);
+  if (!luaL_getmetafield(L, obj, event))  /* no metafield? */
+    return 0;
+  lua_pushvalue(L, obj);
+  lua_call(L, 1, 1);
+  return 1;
+}
+
+
+LUALIB_API int luaL_len (lua_State *L, int idx) {
+  int l;
+  int isnum;
+  lua_len(L, idx);
+  l = (int)lua_tointegerx(L, -1, &isnum);
+  if (!isnum)
+    luaL_error(L, "object length is not a number");
+  lua_pop(L, 1);  /* remove object */
+  return l;
+}
+
+
+LUALIB_API const char *luaL_tolstring (lua_State *L, int idx, size_t *len) {
+  if (!luaL_callmeta(L, idx, "__tostring")) {  /* no metafield? */
+    switch (lua_type(L, idx)) {
+      case LUA_TNUMBER:
+      case LUA_TSTRING:
+        lua_pushvalue(L, idx);
+        break;
+      case LUA_TBOOLEAN:
+        lua_pushstring(L, (lua_toboolean(L, idx) ? "true" : "false"));
+        break;
+      case LUA_TNIL:
+        lua_pushliteral(L, "nil");
+        break;
+      default:
+        lua_pushfstring(L, "%s: %p", luaL_typename(L, idx),
+                                            lua_topointer(L, idx));
+        break;
+    }
+  }
+  return lua_tolstring(L, -1, len);
+}
+
+
+/*
+** {======================================================
+** Compatibility with 5.1 module functions
+** =======================================================
+*/
+#if defined(LUA_COMPAT_MODULE)
+
+static const char *luaL_findtable (lua_State *L, int idx,
+                                   const char *fname, int szhint) {
+  const char *e;
+  if (idx) lua_pushvalue(L, idx);
+  do {
+    e = strchr(fname, '.');
+    if (e == NULL) e = fname + strlen(fname);
+    lua_pushlstring(L, fname, e - fname);
+    lua_rawget(L, -2);
+    if (lua_isnil(L, -1)) {  /* no such field? */
+      lua_pop(L, 1);  /* remove this nil */
+      lua_createtable(L, 0, (*e == '.' ? 1 : szhint)); /* new table for field */
+      lua_pushlstring(L, fname, e - fname);
+      lua_pushvalue(L, -2);
+      lua_settable(L, -4);  /* set new table into field */
+    }
+    else if (!lua_istable(L, -1)) {  /* field has a non-table value? */
+      lua_pop(L, 2);  /* remove table and value */
+      return fname;  /* return problematic part of the name */
+    }
+    lua_remove(L, -2);  /* remove previous table */
+    fname = e + 1;
+  } while (*e == '.');
+  return NULL;
+}
+
+
+/*
+** Count number of elements in a luaL_Reg list.
+*/
+static int libsize (const luaL_Reg *l) {
+  int size = 0;
+  for (; l && l->name; l++) size++;
+  return size;
+}
+
+
+/*
+** Find or create a module table with a given name. The function
+** first looks at the _LOADED table and, if that fails, try a
+** global variable with that name. In any case, leaves on the stack
+** the module table.
+*/
+LUALIB_API void luaL_pushmodule (lua_State *L, const char *modname,
+                                 int sizehint) {
+  luaL_findtable(L, LUA_REGISTRYINDEX, "_LOADED", 1);  /* get _LOADED table */
+  lua_getfield(L, -1, modname);  /* get _LOADED[modname] */
+  if (!lua_istable(L, -1)) {  /* not found? */
+    lua_pop(L, 1);  /* remove previous result */
+    /* try global variable (and create one if it does not exist) */
+    lua_pushglobaltable(L);
+    if (luaL_findtable(L, 0, modname, sizehint) != NULL)
+      luaL_error(L, "name conflict for module " LUA_QS, modname);
+    lua_pushvalue(L, -1);
+    lua_setfield(L, -3, modname);  /* _LOADED[modname] = new table */
+  }
+  lua_remove(L, -2);  /* remove _LOADED table */
+}
+
+
+LUALIB_API void luaL_openlib (lua_State *L, const char *libname,
+                               const luaL_Reg *l, int nup) {
+  luaL_checkversion(L);
+  if (libname) {
+    luaL_pushmodule(L, libname, libsize(l));  /* get/create library table */
+    lua_insert(L, -(nup + 1));  /* move library table to below upvalues */
+  }
+  if (l)
+    luaL_setfuncs(L, l, nup);
+  else
+    lua_pop(L, nup);  /* remove upvalues */
+}
+
+#endif
+/* }====================================================== */
+
+/*
+** set functions from list 'l' into table at top - 'nup'; each
+** function gets the 'nup' elements at the top as upvalues.
+** Returns with only the table at the stack.
+*/
+LUALIB_API void luaL_setfuncs (lua_State *L, const luaL_Reg *l, int nup) {
+  luaL_checkversion(L);
+  luaL_checkstack(L, nup, "too many upvalues");
+  for (; l->name != NULL; l++) {  /* fill the table with given functions */
+    int i;
+    for (i = 0; i < nup; i++)  /* copy upvalues to the top */
+      lua_pushvalue(L, -nup);
+    lua_pushcclosure(L, l->func, nup);  /* closure with those upvalues */
+    lua_setfield(L, -(nup + 2), l->name);
+  }
+  lua_pop(L, nup);  /* remove upvalues */
+}
+
+
+/*
+** ensure that stack[idx][fname] has a table and push that table
+** into the stack
+*/
+LUALIB_API int luaL_getsubtable (lua_State *L, int idx, const char *fname) {
+  lua_getfield(L, idx, fname);
+  if (lua_istable(L, -1)) return 1;  /* table already there */
+  else {
+    lua_pop(L, 1);  /* remove previous result */
+    idx = lua_absindex(L, idx);
+    lua_newtable(L);
+    lua_pushvalue(L, -1);  /* copy to be left at top */
+    lua_setfield(L, idx, fname);  /* assign new table to field */
+    return 0;  /* false, because did not find table there */
+  }
+}
+
+
+/*
+** stripped-down 'require'. Calls 'openf' to open a module,
+** registers the result in 'package.loaded' table and, if 'glb'
+** is true, also registers the result in the global table.
+** Leaves resulting module on the top.
+*/
+LUALIB_API void luaL_requiref (lua_State *L, const char *modname,
+                               lua_CFunction openf, int glb) {
+  lua_pushcfunction(L, openf);
+  lua_pushstring(L, modname);  /* argument to open function */
+  lua_call(L, 1, 1);  /* open module */
+  luaL_getsubtable(L, LUA_REGISTRYINDEX, "_LOADED");
+  lua_pushvalue(L, -2);  /* make copy of module (call result) */
+  lua_setfield(L, -2, modname);  /* _LOADED[modname] = module */
+  lua_pop(L, 1);  /* remove _LOADED table */
+  if (glb) {
+    lua_pushvalue(L, -1);  /* copy of 'mod' */
+    lua_setglobal(L, modname);  /* _G[modname] = module */
+  }
+}
+
+
+LUALIB_API const char *luaL_gsub (lua_State *L, const char *s, const char *p,
+                                                               const char *r) {
+  const char *wild;
+  size_t l = strlen(p);
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  while ((wild = strstr(s, p)) != NULL) {
+    luaL_addlstring(&b, s, wild - s);  /* push prefix */
+    luaL_addstring(&b, r);  /* push replacement in place of pattern */
+    s = wild + l;  /* continue after `p' */
+  }
+  luaL_addstring(&b, s);  /* push last suffix */
+  luaL_pushresult(&b);
+  return lua_tostring(L, -1);
+}
+
+
+static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) {
+  (void)ud; (void)osize;  /* not used */
+  if (nsize == 0) {
+    free(ptr);
+    return NULL;
+  }
+  else
+    return realloc(ptr, nsize);
+}
+
+
+static int panic (lua_State *L) {
+  luai_writestringerror("PANIC: unprotected error in call to Lua API (%s)\n",
+                   lua_tostring(L, -1));
+  return 0;  /* return to Lua to abort */
+}
+
+
+LUALIB_API lua_State *luaL_newstate (void) {
+  lua_State *L = lua_newstate(l_alloc, NULL);
+  if (L) lua_atpanic(L, &panic);
+  return L;
+}
+
+
+LUALIB_API void luaL_checkversion_ (lua_State *L, lua_Number ver) {
+  const lua_Number *v = lua_version(L);
+  if (v != lua_version(NULL))
+    luaL_error(L, "multiple Lua VMs detected");
+  else if (*v != ver)
+    luaL_error(L, "version mismatch: app. needs %f, Lua core provides %f",
+                  ver, *v);
+  /* check conversions number -> integer types */
+  lua_pushnumber(L, -(lua_Number)0x1234);
+  if (lua_tointeger(L, -1) != -0x1234 ||
+      lua_tounsigned(L, -1) != (lua_Unsigned)-0x1234)
+    luaL_error(L, "bad conversion number->int;"
+                  " must recompile Lua with proper settings");
+  lua_pop(L, 1);
+}
+
diff -ruNp src.orig/libs/lua/lauxlib.h src/libs/lua/lauxlib.h
--- src.orig/libs/lua/lauxlib.h	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lauxlib.h	2017-11-21 19:39:45 -0600
@@ -0,0 +1,212 @@
+/*
+** $Id: lauxlib.h,v 1.120 2011/11/29 15:55:08 roberto Exp $
+** Auxiliary functions for building Lua libraries
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lauxlib_h
+#define lauxlib_h
+
+
+#include <stddef.h>
+#include <stdio.h>
+
+#include "lua.h"
+
+
+
+/* extra error code for `luaL_load' */
+#define LUA_ERRFILE     (LUA_ERRERR+1)
+
+
+typedef struct luaL_Reg {
+  const char *name;
+  lua_CFunction func;
+} luaL_Reg;
+
+
+LUALIB_API void (luaL_checkversion_) (lua_State *L, lua_Number ver);
+#define luaL_checkversion(L)	luaL_checkversion_(L, LUA_VERSION_NUM)
+
+LUALIB_API int (luaL_getmetafield) (lua_State *L, int obj, const char *e);
+LUALIB_API int (luaL_callmeta) (lua_State *L, int obj, const char *e);
+LUALIB_API const char *(luaL_tolstring) (lua_State *L, int idx, size_t *len);
+LUALIB_API int (luaL_argerror) (lua_State *L, int numarg, const char *extramsg);
+LUALIB_API const char *(luaL_checklstring) (lua_State *L, int numArg,
+                                                          size_t *l);
+LUALIB_API const char *(luaL_optlstring) (lua_State *L, int numArg,
+                                          const char *def, size_t *l);
+LUALIB_API lua_Number (luaL_checknumber) (lua_State *L, int numArg);
+LUALIB_API lua_Number (luaL_optnumber) (lua_State *L, int nArg, lua_Number def);
+
+LUALIB_API lua_Integer (luaL_checkinteger) (lua_State *L, int numArg);
+LUALIB_API lua_Integer (luaL_optinteger) (lua_State *L, int nArg,
+                                          lua_Integer def);
+LUALIB_API lua_Unsigned (luaL_checkunsigned) (lua_State *L, int numArg);
+LUALIB_API lua_Unsigned (luaL_optunsigned) (lua_State *L, int numArg,
+                                            lua_Unsigned def);
+
+LUALIB_API void (luaL_checkstack) (lua_State *L, int sz, const char *msg);
+LUALIB_API void (luaL_checktype) (lua_State *L, int narg, int t);
+LUALIB_API void (luaL_checkany) (lua_State *L, int narg);
+
+LUALIB_API int   (luaL_newmetatable) (lua_State *L, const char *tname);
+LUALIB_API void  (luaL_setmetatable) (lua_State *L, const char *tname);
+LUALIB_API void *(luaL_testudata) (lua_State *L, int ud, const char *tname);
+LUALIB_API void *(luaL_checkudata) (lua_State *L, int ud, const char *tname);
+
+LUALIB_API void (luaL_where) (lua_State *L, int lvl);
+LUALIB_API int (luaL_error) (lua_State *L, const char *fmt, ...);
+
+LUALIB_API int (luaL_checkoption) (lua_State *L, int narg, const char *def,
+                                   const char *const lst[]);
+
+LUALIB_API int (luaL_fileresult) (lua_State *L, int stat, const char *fname);
+LUALIB_API int (luaL_execresult) (lua_State *L, int stat);
+
+/* pre-defined references */
+#define LUA_NOREF       (-2)
+#define LUA_REFNIL      (-1)
+
+LUALIB_API int (luaL_ref) (lua_State *L, int t);
+LUALIB_API void (luaL_unref) (lua_State *L, int t, int ref);
+
+LUALIB_API int (luaL_loadfilex) (lua_State *L, const char *filename,
+                                               const char *mode);
+
+#define luaL_loadfile(L,f)	luaL_loadfilex(L,f,NULL)
+
+LUALIB_API int (luaL_loadbufferx) (lua_State *L, const char *buff, size_t sz,
+                                   const char *name, const char *mode);
+LUALIB_API int (luaL_loadstring) (lua_State *L, const char *s);
+
+LUALIB_API lua_State *(luaL_newstate) (void);
+
+LUALIB_API int (luaL_len) (lua_State *L, int idx);
+
+LUALIB_API const char *(luaL_gsub) (lua_State *L, const char *s, const char *p,
+                                                  const char *r);
+
+LUALIB_API void (luaL_setfuncs) (lua_State *L, const luaL_Reg *l, int nup);
+
+LUALIB_API int (luaL_getsubtable) (lua_State *L, int idx, const char *fname);
+
+LUALIB_API void (luaL_traceback) (lua_State *L, lua_State *L1,
+                                  const char *msg, int level);
+
+LUALIB_API void (luaL_requiref) (lua_State *L, const char *modname,
+                                 lua_CFunction openf, int glb);
+
+/*
+** ===============================================================
+** some useful macros
+** ===============================================================
+*/
+
+
+#define luaL_newlibtable(L,l)	\
+  lua_createtable(L, 0, sizeof(l)/sizeof((l)[0]) - 1)
+
+#define luaL_newlib(L,l)	(luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))
+
+#define luaL_argcheck(L, cond,numarg,extramsg)	\
+		((void)((cond) || luaL_argerror(L, (numarg), (extramsg))))
+#define luaL_checkstring(L,n)	(luaL_checklstring(L, (n), NULL))
+#define luaL_optstring(L,n,d)	(luaL_optlstring(L, (n), (d), NULL))
+#define luaL_checkint(L,n)	((int)luaL_checkinteger(L, (n)))
+#define luaL_optint(L,n,d)	((int)luaL_optinteger(L, (n), (d)))
+#define luaL_checklong(L,n)	((long)luaL_checkinteger(L, (n)))
+#define luaL_optlong(L,n,d)	((long)luaL_optinteger(L, (n), (d)))
+
+#define luaL_typename(L,i)	lua_typename(L, lua_type(L,(i)))
+
+#define luaL_dofile(L, fn) \
+	(luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))
+
+#define luaL_dostring(L, s) \
+	(luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))
+
+#define luaL_getmetatable(L,n)	(lua_getfield(L, LUA_REGISTRYINDEX, (n)))
+
+#define luaL_opt(L,f,n,d)	(lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))
+
+#define luaL_loadbuffer(L,s,sz,n)	luaL_loadbufferx(L,s,sz,n,NULL)
+
+
+/*
+** {======================================================
+** Generic Buffer manipulation
+** =======================================================
+*/
+
+typedef struct luaL_Buffer {
+  char *b;  /* buffer address */
+  size_t size;  /* buffer size */
+  size_t n;  /* number of characters in buffer */
+  lua_State *L;
+  char initb[LUAL_BUFFERSIZE];  /* initial buffer */
+} luaL_Buffer;
+
+
+#define luaL_addchar(B,c) \
+  ((void)((B)->n < (B)->size || luaL_prepbuffsize((B), 1)), \
+   ((B)->b[(B)->n++] = (c)))
+
+#define luaL_addsize(B,s)	((B)->n += (s))
+
+LUALIB_API void (luaL_buffinit) (lua_State *L, luaL_Buffer *B);
+LUALIB_API char *(luaL_prepbuffsize) (luaL_Buffer *B, size_t sz);
+LUALIB_API void (luaL_addlstring) (luaL_Buffer *B, const char *s, size_t l);
+LUALIB_API void (luaL_addstring) (luaL_Buffer *B, const char *s);
+LUALIB_API void (luaL_addvalue) (luaL_Buffer *B);
+LUALIB_API void (luaL_pushresult) (luaL_Buffer *B);
+LUALIB_API void (luaL_pushresultsize) (luaL_Buffer *B, size_t sz);
+LUALIB_API char *(luaL_buffinitsize) (lua_State *L, luaL_Buffer *B, size_t sz);
+
+#define luaL_prepbuffer(B)	luaL_prepbuffsize(B, LUAL_BUFFERSIZE)
+
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** File handles for IO library
+** =======================================================
+*/
+
+/*
+** A file handle is a userdata with metatable 'LUA_FILEHANDLE' and
+** initial structure 'luaL_Stream' (it may contain other fields
+** after that initial structure).
+*/
+
+#define LUA_FILEHANDLE          "FILE*"
+
+
+typedef struct luaL_Stream {
+  FILE *f;  /* stream (NULL for incompletely created streams) */
+  lua_CFunction closef;  /* to close stream (NULL for closed streams) */
+} luaL_Stream;
+
+/* }====================================================== */
+
+
+
+/* compatibility with old module system */
+#if defined(LUA_COMPAT_MODULE)
+
+LUALIB_API void (luaL_pushmodule) (lua_State *L, const char *modname,
+                                   int sizehint);
+LUALIB_API void (luaL_openlib) (lua_State *L, const char *libname,
+                                const luaL_Reg *l, int nup);
+
+#define luaL_register(L,n,l)	(luaL_openlib(L,(n),(l),0))
+
+#endif
+
+
+#endif
+
+
diff -ruNp src.orig/libs/lua/lbaselib.c src/libs/lua/lbaselib.c
--- src.orig/libs/lua/lbaselib.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lbaselib.c	2017-11-21 19:39:45 -0600
@@ -0,0 +1,458 @@
+/*
+** $Id: lbaselib.c,v 1.276 2013/02/21 13:44:53 roberto Exp $
+** Basic library
+** See Copyright Notice in lua.h
+*/
+
+
+
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define lbaselib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+static int luaB_print (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  int i;
+  lua_getglobal(L, "tostring");
+  for (i=1; i<=n; i++) {
+    const char *s;
+    size_t l;
+    lua_pushvalue(L, -1);  /* function to be called */
+    lua_pushvalue(L, i);   /* value to print */
+    lua_call(L, 1, 1);
+    s = lua_tolstring(L, -1, &l);  /* get result */
+    if (s == NULL)
+      return luaL_error(L,
+         LUA_QL("tostring") " must return a string to " LUA_QL("print"));
+    if (i>1) luai_writestring("\t", 1);
+    luai_writestring(s, l);
+    lua_pop(L, 1);  /* pop result */
+  }
+  luai_writeline();
+  return 0;
+}
+
+
+#define SPACECHARS	" \f\n\r\t\v"
+
+static int luaB_tonumber (lua_State *L) {
+  if (lua_isnoneornil(L, 2)) {  /* standard conversion */
+    int isnum;
+    lua_Number n = lua_tonumberx(L, 1, &isnum);
+    if (isnum) {
+      lua_pushnumber(L, n);
+      return 1;
+    }  /* else not a number; must be something */
+    luaL_checkany(L, 1);
+  }
+  else {
+    size_t l;
+    const char *s = luaL_checklstring(L, 1, &l);
+    const char *e = s + l;  /* end point for 's' */
+    int base = luaL_checkint(L, 2);
+    int neg = 0;
+    luaL_argcheck(L, 2 <= base && base <= 36, 2, "base out of range");
+    s += strspn(s, SPACECHARS);  /* skip initial spaces */
+    if (*s == '-') { s++; neg = 1; }  /* handle signal */
+    else if (*s == '+') s++;
+    if (isalnum((unsigned char)*s)) {
+      lua_Number n = 0;
+      do {
+        int digit = (isdigit((unsigned char)*s)) ? *s - '0'
+                       : toupper((unsigned char)*s) - 'A' + 10;
+        if (digit >= base) break;  /* invalid numeral; force a fail */
+        n = n * (lua_Number)base + (lua_Number)digit;
+        s++;
+      } while (isalnum((unsigned char)*s));
+      s += strspn(s, SPACECHARS);  /* skip trailing spaces */
+      if (s == e) {  /* no invalid trailing characters? */
+        lua_pushnumber(L, (neg) ? -n : n);
+        return 1;
+      }  /* else not a number */
+    }  /* else not a number */
+  }
+  lua_pushnil(L);  /* not a number */
+  return 1;
+}
+
+
+static int luaB_error (lua_State *L) {
+  int level = luaL_optint(L, 2, 1);
+  lua_settop(L, 1);
+  if (lua_isstring(L, 1) && level > 0) {  /* add extra information? */
+    luaL_where(L, level);
+    lua_pushvalue(L, 1);
+    lua_concat(L, 2);
+  }
+  return lua_error(L);
+}
+
+
+static int luaB_getmetatable (lua_State *L) {
+  luaL_checkany(L, 1);
+  if (!lua_getmetatable(L, 1)) {
+    lua_pushnil(L);
+    return 1;  /* no metatable */
+  }
+  luaL_getmetafield(L, 1, "__metatable");
+  return 1;  /* returns either __metatable field (if present) or metatable */
+}
+
+
+static int luaB_setmetatable (lua_State *L) {
+  int t = lua_type(L, 2);
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2,
+                    "nil or table expected");
+  if (luaL_getmetafield(L, 1, "__metatable"))
+    return luaL_error(L, "cannot change a protected metatable");
+  lua_settop(L, 2);
+  lua_setmetatable(L, 1);
+  return 1;
+}
+
+
+static int luaB_rawequal (lua_State *L) {
+  luaL_checkany(L, 1);
+  luaL_checkany(L, 2);
+  lua_pushboolean(L, lua_rawequal(L, 1, 2));
+  return 1;
+}
+
+
+static int luaB_rawlen (lua_State *L) {
+  int t = lua_type(L, 1);
+  luaL_argcheck(L, t == LUA_TTABLE || t == LUA_TSTRING, 1,
+                   "table or string expected");
+  lua_pushinteger(L, lua_rawlen(L, 1));
+  return 1;
+}
+
+
+static int luaB_rawget (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_checkany(L, 2);
+  lua_settop(L, 2);
+  lua_rawget(L, 1);
+  return 1;
+}
+
+static int luaB_rawset (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_checkany(L, 2);
+  luaL_checkany(L, 3);
+  lua_settop(L, 3);
+  lua_rawset(L, 1);
+  return 1;
+}
+
+
+static int luaB_collectgarbage (lua_State *L) {
+  static const char *const opts[] = {"stop", "restart", "collect",
+    "count", "step", "setpause", "setstepmul",
+    "setmajorinc", "isrunning", "generational", "incremental", NULL};
+  static const int optsnum[] = {LUA_GCSTOP, LUA_GCRESTART, LUA_GCCOLLECT,
+    LUA_GCCOUNT, LUA_GCSTEP, LUA_GCSETPAUSE, LUA_GCSETSTEPMUL,
+    LUA_GCSETMAJORINC, LUA_GCISRUNNING, LUA_GCGEN, LUA_GCINC};
+  int o = optsnum[luaL_checkoption(L, 1, "collect", opts)];
+  int ex = luaL_optint(L, 2, 0);
+  int res = lua_gc(L, o, ex);
+  switch (o) {
+    case LUA_GCCOUNT: {
+      int b = lua_gc(L, LUA_GCCOUNTB, 0);
+      lua_pushnumber(L, res + ((lua_Number)b/1024));
+      lua_pushinteger(L, b);
+      return 2;
+    }
+    case LUA_GCSTEP: case LUA_GCISRUNNING: {
+      lua_pushboolean(L, res);
+      return 1;
+    }
+    default: {
+      lua_pushinteger(L, res);
+      return 1;
+    }
+  }
+}
+
+
+static int luaB_type (lua_State *L) {
+  luaL_checkany(L, 1);
+  lua_pushstring(L, luaL_typename(L, 1));
+  return 1;
+}
+
+
+static int pairsmeta (lua_State *L, const char *method, int iszero,
+                      lua_CFunction iter) {
+  if (!luaL_getmetafield(L, 1, method)) {  /* no metamethod? */
+    luaL_checktype(L, 1, LUA_TTABLE);  /* argument must be a table */
+    lua_pushcfunction(L, iter);  /* will return generator, */
+    lua_pushvalue(L, 1);  /* state, */
+    if (iszero) lua_pushinteger(L, 0);  /* and initial value */
+    else lua_pushnil(L);
+  }
+  else {
+    lua_pushvalue(L, 1);  /* argument 'self' to metamethod */
+    lua_call(L, 1, 3);  /* get 3 values from metamethod */
+  }
+  return 3;
+}
+
+
+static int luaB_next (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  lua_settop(L, 2);  /* create a 2nd argument if there isn't one */
+  if (lua_next(L, 1))
+    return 2;
+  else {
+    lua_pushnil(L);
+    return 1;
+  }
+}
+
+
+static int luaB_pairs (lua_State *L) {
+  return pairsmeta(L, "__pairs", 0, luaB_next);
+}
+
+
+static int ipairsaux (lua_State *L) {
+  int i = luaL_checkint(L, 2);
+  luaL_checktype(L, 1, LUA_TTABLE);
+  i++;  /* next value */
+  lua_pushinteger(L, i);
+  lua_rawgeti(L, 1, i);
+  return (lua_isnil(L, -1)) ? 1 : 2;
+}
+
+
+static int luaB_ipairs (lua_State *L) {
+  return pairsmeta(L, "__ipairs", 1, ipairsaux);
+}
+
+
+static int load_aux (lua_State *L, int status, int envidx) {
+  if (status == LUA_OK) {
+    if (envidx != 0) {  /* 'env' parameter? */
+      lua_pushvalue(L, envidx);  /* environment for loaded function */
+      if (!lua_setupvalue(L, -2, 1))  /* set it as 1st upvalue */
+        lua_pop(L, 1);  /* remove 'env' if not used by previous call */
+    }
+    return 1;
+  }
+  else {  /* error (message is on top of the stack) */
+    lua_pushnil(L);
+    lua_insert(L, -2);  /* put before error message */
+    return 2;  /* return nil plus error message */
+  }
+}
+
+
+static int luaB_loadfile (lua_State *L) {
+  const char *fname = luaL_optstring(L, 1, NULL);
+  const char *mode = luaL_optstring(L, 2, NULL);
+  int env = (!lua_isnone(L, 3) ? 3 : 0);  /* 'env' index or 0 if no 'env' */
+  int status = luaL_loadfilex(L, fname, mode);
+  return load_aux(L, status, env);
+}
+
+
+/*
+** {======================================================
+** Generic Read function
+** =======================================================
+*/
+
+
+/*
+** reserved slot, above all arguments, to hold a copy of the returned
+** string to avoid it being collected while parsed. 'load' has four
+** optional arguments (chunk, source name, mode, and environment).
+*/
+#define RESERVEDSLOT	5
+
+
+/*
+** Reader for generic `load' function: `lua_load' uses the
+** stack for internal stuff, so the reader cannot change the
+** stack top. Instead, it keeps its resulting string in a
+** reserved slot inside the stack.
+*/
+static const char *generic_reader (lua_State *L, void *ud, size_t *size) {
+  (void)(ud);  /* not used */
+  luaL_checkstack(L, 2, "too many nested functions");
+  lua_pushvalue(L, 1);  /* get function */
+  lua_call(L, 0, 1);  /* call it */
+  if (lua_isnil(L, -1)) {
+    lua_pop(L, 1);  /* pop result */
+    *size = 0;
+    return NULL;
+  }
+  else if (!lua_isstring(L, -1))
+    luaL_error(L, "reader function must return a string");
+  lua_replace(L, RESERVEDSLOT);  /* save string in reserved slot */
+  return lua_tolstring(L, RESERVEDSLOT, size);
+}
+
+
+static int luaB_load (lua_State *L) {
+  int status;
+  size_t l;
+  const char *s = lua_tolstring(L, 1, &l);
+  const char *mode = luaL_optstring(L, 3, "bt");
+  int env = (!lua_isnone(L, 4) ? 4 : 0);  /* 'env' index or 0 if no 'env' */
+  if (s != NULL) {  /* loading a string? */
+    const char *chunkname = luaL_optstring(L, 2, s);
+    status = luaL_loadbufferx(L, s, l, chunkname, mode);
+  }
+  else {  /* loading from a reader function */
+    const char *chunkname = luaL_optstring(L, 2, "=(load)");
+    luaL_checktype(L, 1, LUA_TFUNCTION);
+    lua_settop(L, RESERVEDSLOT);  /* create reserved slot */
+    status = lua_load(L, generic_reader, NULL, chunkname, mode);
+  }
+  return load_aux(L, status, env);
+}
+
+/* }====================================================== */
+
+
+static int dofilecont (lua_State *L) {
+  return lua_gettop(L) - 1;
+}
+
+
+static int luaB_dofile (lua_State *L) {
+  const char *fname = luaL_optstring(L, 1, NULL);
+  lua_settop(L, 1);
+  if (luaL_loadfile(L, fname) != LUA_OK)
+    return lua_error(L);
+  lua_callk(L, 0, LUA_MULTRET, 0, dofilecont);
+  return dofilecont(L);
+}
+
+
+static int luaB_assert (lua_State *L) {
+  if (!lua_toboolean(L, 1))
+    return luaL_error(L, "%s", luaL_optstring(L, 2, "assertion failed!"));
+  return lua_gettop(L);
+}
+
+
+static int luaB_select (lua_State *L) {
+  int n = lua_gettop(L);
+  if (lua_type(L, 1) == LUA_TSTRING && *lua_tostring(L, 1) == '#') {
+    lua_pushinteger(L, n-1);
+    return 1;
+  }
+  else {
+    int i = luaL_checkint(L, 1);
+    if (i < 0) i = n + i;
+    else if (i > n) i = n;
+    luaL_argcheck(L, 1 <= i, 1, "index out of range");
+    return n - i;
+  }
+}
+
+
+static int finishpcall (lua_State *L, int status) {
+  if (!lua_checkstack(L, 1)) {  /* no space for extra boolean? */
+    lua_settop(L, 0);  /* create space for return values */
+    lua_pushboolean(L, 0);
+    lua_pushstring(L, "stack overflow");
+    return 2;  /* return false, msg */
+  }
+  lua_pushboolean(L, status);  /* first result (status) */
+  lua_replace(L, 1);  /* put first result in first slot */
+  return lua_gettop(L);
+}
+
+
+static int pcallcont (lua_State *L) {
+  int status = lua_getctx(L, NULL);
+  return finishpcall(L, (status == LUA_YIELD));
+}
+
+
+static int luaB_pcall (lua_State *L) {
+  int status;
+  luaL_checkany(L, 1);
+  lua_pushnil(L);
+  lua_insert(L, 1);  /* create space for status result */
+  status = lua_pcallk(L, lua_gettop(L) - 2, LUA_MULTRET, 0, 0, pcallcont);
+  return finishpcall(L, (status == LUA_OK));
+}
+
+
+static int luaB_xpcall (lua_State *L) {
+  int status;
+  int n = lua_gettop(L);
+  luaL_argcheck(L, n >= 2, 2, "value expected");
+  lua_pushvalue(L, 1);  /* exchange function... */
+  lua_copy(L, 2, 1);  /* ...and error handler */
+  lua_replace(L, 2);
+  status = lua_pcallk(L, n - 2, LUA_MULTRET, 1, 0, pcallcont);
+  return finishpcall(L, (status == LUA_OK));
+}
+
+
+static int luaB_tostring (lua_State *L) {
+  luaL_checkany(L, 1);
+  luaL_tolstring(L, 1, NULL);
+  return 1;
+}
+
+
+static const luaL_Reg base_funcs[] = {
+  {"assert", luaB_assert},
+  {"collectgarbage", luaB_collectgarbage},
+  {"dofile", luaB_dofile},
+  {"error", luaB_error},
+  {"getmetatable", luaB_getmetatable},
+  {"ipairs", luaB_ipairs},
+  {"loadfile", luaB_loadfile},
+  {"load", luaB_load},
+#if defined(LUA_COMPAT_LOADSTRING)
+  {"loadstring", luaB_load},
+#endif
+  {"next", luaB_next},
+  {"pairs", luaB_pairs},
+  {"pcall", luaB_pcall},
+  {"print", luaB_print},
+  {"rawequal", luaB_rawequal},
+  {"rawlen", luaB_rawlen},
+  {"rawget", luaB_rawget},
+  {"rawset", luaB_rawset},
+  {"select", luaB_select},
+  {"setmetatable", luaB_setmetatable},
+  {"tonumber", luaB_tonumber},
+  {"tostring", luaB_tostring},
+  {"type", luaB_type},
+  {"xpcall", luaB_xpcall},
+  {NULL, NULL}
+};
+
+
+LUAMOD_API int luaopen_base (lua_State *L) {
+  /* set global _G */
+  lua_pushglobaltable(L);
+  lua_pushglobaltable(L);
+  lua_setfield(L, -2, "_G");
+  /* open lib into global table */
+  luaL_setfuncs(L, base_funcs, 0);
+  lua_pushliteral(L, LUA_VERSION);
+  lua_setfield(L, -2, "_VERSION");  /* set global _VERSION */
+  return 1;
+}
+
diff -ruNp src.orig/libs/lua/lbitlib.c src/libs/lua/lbitlib.c
--- src.orig/libs/lua/lbitlib.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lbitlib.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,211 @@
+/*
+** $Id: lbitlib.c,v 1.18 2013/03/19 13:19:12 roberto Exp $
+** Standard library for bitwise operations
+** See Copyright Notice in lua.h
+*/
+
+#define lbitlib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+/* number of bits to consider in a number */
+#if !defined(LUA_NBITS)
+#define LUA_NBITS	32
+#endif
+
+
+#define ALLONES		(~(((~(lua_Unsigned)0) << (LUA_NBITS - 1)) << 1))
+
+/* macro to trim extra bits */
+#define trim(x)		((x) & ALLONES)
+
+
+/* builds a number with 'n' ones (1 <= n <= LUA_NBITS) */
+#define mask(n)		(~((ALLONES << 1) << ((n) - 1)))
+
+
+typedef lua_Unsigned b_uint;
+
+
+
+static b_uint andaux (lua_State *L) {
+  int i, n = lua_gettop(L);
+  b_uint r = ~(b_uint)0;
+  for (i = 1; i <= n; i++)
+    r &= luaL_checkunsigned(L, i);
+  return trim(r);
+}
+
+
+static int b_and (lua_State *L) {
+  b_uint r = andaux(L);
+  lua_pushunsigned(L, r);
+  return 1;
+}
+
+
+static int b_test (lua_State *L) {
+  b_uint r = andaux(L);
+  lua_pushboolean(L, r != 0);
+  return 1;
+}
+
+
+static int b_or (lua_State *L) {
+  int i, n = lua_gettop(L);
+  b_uint r = 0;
+  for (i = 1; i <= n; i++)
+    r |= luaL_checkunsigned(L, i);
+  lua_pushunsigned(L, trim(r));
+  return 1;
+}
+
+
+static int b_xor (lua_State *L) {
+  int i, n = lua_gettop(L);
+  b_uint r = 0;
+  for (i = 1; i <= n; i++)
+    r ^= luaL_checkunsigned(L, i);
+  lua_pushunsigned(L, trim(r));
+  return 1;
+}
+
+
+static int b_not (lua_State *L) {
+  b_uint r = ~luaL_checkunsigned(L, 1);
+  lua_pushunsigned(L, trim(r));
+  return 1;
+}
+
+
+static int b_shift (lua_State *L, b_uint r, int i) {
+  if (i < 0) {  /* shift right? */
+    i = -i;
+    r = trim(r);
+    if (i >= LUA_NBITS) r = 0;
+    else r >>= i;
+  }
+  else {  /* shift left */
+    if (i >= LUA_NBITS) r = 0;
+    else r <<= i;
+    r = trim(r);
+  }
+  lua_pushunsigned(L, r);
+  return 1;
+}
+
+
+static int b_lshift (lua_State *L) {
+  return b_shift(L, luaL_checkunsigned(L, 1), luaL_checkint(L, 2));
+}
+
+
+static int b_rshift (lua_State *L) {
+  return b_shift(L, luaL_checkunsigned(L, 1), -luaL_checkint(L, 2));
+}
+
+
+static int b_arshift (lua_State *L) {
+  b_uint r = luaL_checkunsigned(L, 1);
+  int i = luaL_checkint(L, 2);
+  if (i < 0 || !(r & ((b_uint)1 << (LUA_NBITS - 1))))
+    return b_shift(L, r, -i);
+  else {  /* arithmetic shift for 'negative' number */
+    if (i >= LUA_NBITS) r = ALLONES;
+    else
+      r = trim((r >> i) | ~(~(b_uint)0 >> i));  /* add signal bit */
+    lua_pushunsigned(L, r);
+    return 1;
+  }
+}
+
+
+static int b_rot (lua_State *L, int i) {
+  b_uint r = luaL_checkunsigned(L, 1);
+  i &= (LUA_NBITS - 1);  /* i = i % NBITS */
+  r = trim(r);
+  r = (r << i) | (r >> (LUA_NBITS - i));
+  lua_pushunsigned(L, trim(r));
+  return 1;
+}
+
+
+static int b_lrot (lua_State *L) {
+  return b_rot(L, luaL_checkint(L, 2));
+}
+
+
+static int b_rrot (lua_State *L) {
+  return b_rot(L, -luaL_checkint(L, 2));
+}
+
+
+/*
+** get field and width arguments for field-manipulation functions,
+** checking whether they are valid.
+** ('luaL_error' called without 'return' to avoid later warnings about
+** 'width' being used uninitialized.)
+*/
+static int fieldargs (lua_State *L, int farg, int *width) {
+  int f = luaL_checkint(L, farg);
+  int w = luaL_optint(L, farg + 1, 1);
+  luaL_argcheck(L, 0 <= f, farg, "field cannot be negative");
+  luaL_argcheck(L, 0 < w, farg + 1, "width must be positive");
+  if (f + w > LUA_NBITS)
+    luaL_error(L, "trying to access non-existent bits");
+  *width = w;
+  return f;
+}
+
+
+static int b_extract (lua_State *L) {
+  int w;
+  b_uint r = luaL_checkunsigned(L, 1);
+  int f = fieldargs(L, 2, &w);
+  r = (r >> f) & mask(w);
+  lua_pushunsigned(L, r);
+  return 1;
+}
+
+
+static int b_replace (lua_State *L) {
+  int w;
+  b_uint r = luaL_checkunsigned(L, 1);
+  b_uint v = luaL_checkunsigned(L, 2);
+  int f = fieldargs(L, 3, &w);
+  int m = mask(w);
+  v &= m;  /* erase bits outside given width */
+  r = (r & ~(m << f)) | (v << f);
+  lua_pushunsigned(L, r);
+  return 1;
+}
+
+
+static const luaL_Reg bitlib[] = {
+  {"arshift", b_arshift},
+  {"band", b_and},
+  {"bnot", b_not},
+  {"bor", b_or},
+  {"bxor", b_xor},
+  {"btest", b_test},
+  {"extract", b_extract},
+  {"lrotate", b_lrot},
+  {"lshift", b_lshift},
+  {"replace", b_replace},
+  {"rrotate", b_rrot},
+  {"rshift", b_rshift},
+  {NULL, NULL}
+};
+
+
+
+LUAMOD_API int luaopen_bit32 (lua_State *L) {
+  luaL_newlib(L, bitlib);
+  return 1;
+}
+
diff -ruNp src.orig/libs/lua/lcode.c src/libs/lua/lcode.c
--- src.orig/libs/lua/lcode.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lcode.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,881 @@
+/*
+** $Id: lcode.c,v 2.62 2012/08/16 17:34:28 roberto Exp $
+** Code generator for Lua
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdlib.h>
+
+#define lcode_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lcode.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lgc.h"
+#include "llex.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lparser.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "lvm.h"
+
+
+#define hasjumps(e)	((e)->t != (e)->f)
+
+
+static int isnumeral(expdesc *e) {
+  return (e->k == VKNUM && e->t == NO_JUMP && e->f == NO_JUMP);
+}
+
+
+void luaK_nil (FuncState *fs, int from, int n) {
+  Instruction *previous;
+  int l = from + n - 1;  /* last register to set nil */
+  if (fs->pc > fs->lasttarget) {  /* no jumps to current position? */
+    previous = &fs->f->code[fs->pc-1];
+    if (GET_OPCODE(*previous) == OP_LOADNIL) {
+      int pfrom = GETARG_A(*previous);
+      int pl = pfrom + GETARG_B(*previous);
+      if ((pfrom <= from && from <= pl + 1) ||
+          (from <= pfrom && pfrom <= l + 1)) {  /* can connect both? */
+        if (pfrom < from) from = pfrom;  /* from = min(from, pfrom) */
+        if (pl > l) l = pl;  /* l = max(l, pl) */
+        SETARG_A(*previous, from);
+        SETARG_B(*previous, l - from);
+        return;
+      }
+    }  /* else go through */
+  }
+  luaK_codeABC(fs, OP_LOADNIL, from, n - 1, 0);  /* else no optimization */
+}
+
+
+int luaK_jump (FuncState *fs) {
+  int jpc = fs->jpc;  /* save list of jumps to here */
+  int j;
+  fs->jpc = NO_JUMP;
+  j = luaK_codeAsBx(fs, OP_JMP, 0, NO_JUMP);
+  luaK_concat(fs, &j, jpc);  /* keep them on hold */
+  return j;
+}
+
+
+void luaK_ret (FuncState *fs, int first, int nret) {
+  luaK_codeABC(fs, OP_RETURN, first, nret+1, 0);
+}
+
+
+static int condjump (FuncState *fs, OpCode op, int A, int B, int C) {
+  luaK_codeABC(fs, op, A, B, C);
+  return luaK_jump(fs);
+}
+
+
+static void fixjump (FuncState *fs, int pc, int dest) {
+  Instruction *jmp = &fs->f->code[pc];
+  int offset = dest-(pc+1);
+  lua_assert(dest != NO_JUMP);
+  if (abs(offset) > MAXARG_sBx)
+    luaX_syntaxerror(fs->ls, "control structure too long");
+  SETARG_sBx(*jmp, offset);
+}
+
+
+/*
+** returns current `pc' and marks it as a jump target (to avoid wrong
+** optimizations with consecutive instructions not in the same basic block).
+*/
+int luaK_getlabel (FuncState *fs) {
+  fs->lasttarget = fs->pc;
+  return fs->pc;
+}
+
+
+static int getjump (FuncState *fs, int pc) {
+  int offset = GETARG_sBx(fs->f->code[pc]);
+  if (offset == NO_JUMP)  /* point to itself represents end of list */
+    return NO_JUMP;  /* end of list */
+  else
+    return (pc+1)+offset;  /* turn offset into absolute position */
+}
+
+
+static Instruction *getjumpcontrol (FuncState *fs, int pc) {
+  Instruction *pi = &fs->f->code[pc];
+  if (pc >= 1 && testTMode(GET_OPCODE(*(pi-1))))
+    return pi-1;
+  else
+    return pi;
+}
+
+
+/*
+** check whether list has any jump that do not produce a value
+** (or produce an inverted value)
+*/
+static int need_value (FuncState *fs, int list) {
+  for (; list != NO_JUMP; list = getjump(fs, list)) {
+    Instruction i = *getjumpcontrol(fs, list);
+    if (GET_OPCODE(i) != OP_TESTSET) return 1;
+  }
+  return 0;  /* not found */
+}
+
+
+static int patchtestreg (FuncState *fs, int node, int reg) {
+  Instruction *i = getjumpcontrol(fs, node);
+  if (GET_OPCODE(*i) != OP_TESTSET)
+    return 0;  /* cannot patch other instructions */
+  if (reg != NO_REG && reg != GETARG_B(*i))
+    SETARG_A(*i, reg);
+  else  /* no register to put value or register already has the value */
+    *i = CREATE_ABC(OP_TEST, GETARG_B(*i), 0, GETARG_C(*i));
+
+  return 1;
+}
+
+
+static void removevalues (FuncState *fs, int list) {
+  for (; list != NO_JUMP; list = getjump(fs, list))
+      patchtestreg(fs, list, NO_REG);
+}
+
+
+static void patchlistaux (FuncState *fs, int list, int vtarget, int reg,
+                          int dtarget) {
+  while (list != NO_JUMP) {
+    int next = getjump(fs, list);
+    if (patchtestreg(fs, list, reg))
+      fixjump(fs, list, vtarget);
+    else
+      fixjump(fs, list, dtarget);  /* jump to default target */
+    list = next;
+  }
+}
+
+
+static void dischargejpc (FuncState *fs) {
+  patchlistaux(fs, fs->jpc, fs->pc, NO_REG, fs->pc);
+  fs->jpc = NO_JUMP;
+}
+
+
+void luaK_patchlist (FuncState *fs, int list, int target) {
+  if (target == fs->pc)
+    luaK_patchtohere(fs, list);
+  else {
+    lua_assert(target < fs->pc);
+    patchlistaux(fs, list, target, NO_REG, target);
+  }
+}
+
+
+LUAI_FUNC void luaK_patchclose (FuncState *fs, int list, int level) {
+  level++;  /* argument is +1 to reserve 0 as non-op */
+  while (list != NO_JUMP) {
+    int next = getjump(fs, list);
+    lua_assert(GET_OPCODE(fs->f->code[list]) == OP_JMP &&
+                (GETARG_A(fs->f->code[list]) == 0 ||
+                 GETARG_A(fs->f->code[list]) >= level));
+    SETARG_A(fs->f->code[list], level);
+    list = next;
+  }
+}
+
+
+void luaK_patchtohere (FuncState *fs, int list) {
+  luaK_getlabel(fs);
+  luaK_concat(fs, &fs->jpc, list);
+}
+
+
+void luaK_concat (FuncState *fs, int *l1, int l2) {
+  if (l2 == NO_JUMP) return;
+  else if (*l1 == NO_JUMP)
+    *l1 = l2;
+  else {
+    int list = *l1;
+    int next;
+    while ((next = getjump(fs, list)) != NO_JUMP)  /* find last element */
+      list = next;
+    fixjump(fs, list, l2);
+  }
+}
+
+
+static int luaK_code (FuncState *fs, Instruction i) {
+  Proto *f = fs->f;
+  dischargejpc(fs);  /* `pc' will change */
+  /* put new instruction in code array */
+  luaM_growvector(fs->ls->L, f->code, fs->pc, f->sizecode, Instruction,
+                  MAX_INT, "opcodes");
+  f->code[fs->pc] = i;
+  /* save corresponding line information */
+  luaM_growvector(fs->ls->L, f->lineinfo, fs->pc, f->sizelineinfo, int,
+                  MAX_INT, "opcodes");
+  f->lineinfo[fs->pc] = fs->ls->lastline;
+  return fs->pc++;
+}
+
+
+int luaK_codeABC (FuncState *fs, OpCode o, int a, int b, int c) {
+  lua_assert(getOpMode(o) == iABC);
+  lua_assert(getBMode(o) != OpArgN || b == 0);
+  lua_assert(getCMode(o) != OpArgN || c == 0);
+  lua_assert(a <= MAXARG_A && b <= MAXARG_B && c <= MAXARG_C);
+  return luaK_code(fs, CREATE_ABC(o, a, b, c));
+}
+
+
+int luaK_codeABx (FuncState *fs, OpCode o, int a, unsigned int bc) {
+  lua_assert(getOpMode(o) == iABx || getOpMode(o) == iAsBx);
+  lua_assert(getCMode(o) == OpArgN);
+  lua_assert(a <= MAXARG_A && bc <= MAXARG_Bx);
+  return luaK_code(fs, CREATE_ABx(o, a, bc));
+}
+
+
+static int codeextraarg (FuncState *fs, int a) {
+  lua_assert(a <= MAXARG_Ax);
+  return luaK_code(fs, CREATE_Ax(OP_EXTRAARG, a));
+}
+
+
+int luaK_codek (FuncState *fs, int reg, int k) {
+  if (k <= MAXARG_Bx)
+    return luaK_codeABx(fs, OP_LOADK, reg, k);
+  else {
+    int p = luaK_codeABx(fs, OP_LOADKX, reg, 0);
+    codeextraarg(fs, k);
+    return p;
+  }
+}
+
+
+void luaK_checkstack (FuncState *fs, int n) {
+  int newstack = fs->freereg + n;
+  if (newstack > fs->f->maxstacksize) {
+    if (newstack >= MAXSTACK)
+      luaX_syntaxerror(fs->ls, "function or expression too complex");
+    fs->f->maxstacksize = cast_byte(newstack);
+  }
+}
+
+
+void luaK_reserveregs (FuncState *fs, int n) {
+  luaK_checkstack(fs, n);
+  fs->freereg += n;
+}
+
+
+static void freereg (FuncState *fs, int reg) {
+  if (!ISK(reg) && reg >= fs->nactvar) {
+    fs->freereg--;
+    lua_assert(reg == fs->freereg);
+  }
+}
+
+
+static void freeexp (FuncState *fs, expdesc *e) {
+  if (e->k == VNONRELOC)
+    freereg(fs, e->u.info);
+}
+
+
+static int addk (FuncState *fs, TValue *key, TValue *v) {
+  lua_State *L = fs->ls->L;
+  TValue *idx = luaH_set(L, fs->h, key);
+  Proto *f = fs->f;
+  int k, oldsize;
+  if (ttisnumber(idx)) {
+    lua_Number n = nvalue(idx);
+    lua_number2int(k, n);
+    if (luaV_rawequalobj(&f->k[k], v))
+      return k;
+    /* else may be a collision (e.g., between 0.0 and "\0\0\0\0\0\0\0\0");
+       go through and create a new entry for this value */
+  }
+  /* constant not found; create a new entry */
+  oldsize = f->sizek;
+  k = fs->nk;
+  /* numerical value does not need GC barrier;
+     table has no metatable, so it does not need to invalidate cache */
+  setnvalue(idx, cast_num(k));
+  luaM_growvector(L, f->k, k, f->sizek, TValue, MAXARG_Ax, "constants");
+  while (oldsize < f->sizek) setnilvalue(&f->k[oldsize++]);
+  setobj(L, &f->k[k], v);
+  fs->nk++;
+  luaC_barrier(L, f, v);
+  return k;
+}
+
+
+int luaK_stringK (FuncState *fs, TString *s) {
+  TValue o;
+  setsvalue(fs->ls->L, &o, s);
+  return addk(fs, &o, &o);
+}
+
+
+int luaK_numberK (FuncState *fs, lua_Number r) {
+  int n;
+  lua_State *L = fs->ls->L;
+  TValue o;
+  setnvalue(&o, r);
+  if (r == 0 || luai_numisnan(NULL, r)) {  /* handle -0 and NaN */
+    /* use raw representation as key to avoid numeric problems */
+    setsvalue(L, L->top++, luaS_newlstr(L, (char *)&r, sizeof(r)));
+    n = addk(fs, L->top - 1, &o);
+    L->top--;
+  }
+  else
+    n = addk(fs, &o, &o);  /* regular case */
+  return n;
+}
+
+
+static int boolK (FuncState *fs, int b) {
+  TValue o;
+  setbvalue(&o, b);
+  return addk(fs, &o, &o);
+}
+
+
+static int nilK (FuncState *fs) {
+  TValue k, v;
+  setnilvalue(&v);
+  /* cannot use nil as key; instead use table itself to represent nil */
+  sethvalue(fs->ls->L, &k, fs->h);
+  return addk(fs, &k, &v);
+}
+
+
+void luaK_setreturns (FuncState *fs, expdesc *e, int nresults) {
+  if (e->k == VCALL) {  /* expression is an open function call? */
+    SETARG_C(getcode(fs, e), nresults+1);
+  }
+  else if (e->k == VVARARG) {
+    SETARG_B(getcode(fs, e), nresults+1);
+    SETARG_A(getcode(fs, e), fs->freereg);
+    luaK_reserveregs(fs, 1);
+  }
+}
+
+
+void luaK_setoneret (FuncState *fs, expdesc *e) {
+  if (e->k == VCALL) {  /* expression is an open function call? */
+    e->k = VNONRELOC;
+    e->u.info = GETARG_A(getcode(fs, e));
+  }
+  else if (e->k == VVARARG) {
+    SETARG_B(getcode(fs, e), 2);
+    e->k = VRELOCABLE;  /* can relocate its simple result */
+  }
+}
+
+
+void luaK_dischargevars (FuncState *fs, expdesc *e) {
+  switch (e->k) {
+    case VLOCAL: {
+      e->k = VNONRELOC;
+      break;
+    }
+    case VUPVAL: {
+      e->u.info = luaK_codeABC(fs, OP_GETUPVAL, 0, e->u.info, 0);
+      e->k = VRELOCABLE;
+      break;
+    }
+    case VINDEXED: {
+      OpCode op = OP_GETTABUP;  /* assume 't' is in an upvalue */
+      freereg(fs, e->u.ind.idx);
+      if (e->u.ind.vt == VLOCAL) {  /* 't' is in a register? */
+        freereg(fs, e->u.ind.t);
+        op = OP_GETTABLE;
+      }
+      e->u.info = luaK_codeABC(fs, op, 0, e->u.ind.t, e->u.ind.idx);
+      e->k = VRELOCABLE;
+      break;
+    }
+    case VVARARG:
+    case VCALL: {
+      luaK_setoneret(fs, e);
+      break;
+    }
+    default: break;  /* there is one value available (somewhere) */
+  }
+}
+
+
+static int code_label (FuncState *fs, int A, int b, int jump) {
+  luaK_getlabel(fs);  /* those instructions may be jump targets */
+  return luaK_codeABC(fs, OP_LOADBOOL, A, b, jump);
+}
+
+
+static void discharge2reg (FuncState *fs, expdesc *e, int reg) {
+  luaK_dischargevars(fs, e);
+  switch (e->k) {
+    case VNIL: {
+      luaK_nil(fs, reg, 1);
+      break;
+    }
+    case VFALSE: case VTRUE: {
+      luaK_codeABC(fs, OP_LOADBOOL, reg, e->k == VTRUE, 0);
+      break;
+    }
+    case VK: {
+      luaK_codek(fs, reg, e->u.info);
+      break;
+    }
+    case VKNUM: {
+      luaK_codek(fs, reg, luaK_numberK(fs, e->u.nval));
+      break;
+    }
+    case VRELOCABLE: {
+      Instruction *pc = &getcode(fs, e);
+      SETARG_A(*pc, reg);
+      break;
+    }
+    case VNONRELOC: {
+      if (reg != e->u.info)
+        luaK_codeABC(fs, OP_MOVE, reg, e->u.info, 0);
+      break;
+    }
+    default: {
+      lua_assert(e->k == VVOID || e->k == VJMP);
+      return;  /* nothing to do... */
+    }
+  }
+  e->u.info = reg;
+  e->k = VNONRELOC;
+}
+
+
+static void discharge2anyreg (FuncState *fs, expdesc *e) {
+  if (e->k != VNONRELOC) {
+    luaK_reserveregs(fs, 1);
+    discharge2reg(fs, e, fs->freereg-1);
+  }
+}
+
+
+static void exp2reg (FuncState *fs, expdesc *e, int reg) {
+  discharge2reg(fs, e, reg);
+  if (e->k == VJMP)
+    luaK_concat(fs, &e->t, e->u.info);  /* put this jump in `t' list */
+  if (hasjumps(e)) {
+    int final;  /* position after whole expression */
+    int p_f = NO_JUMP;  /* position of an eventual LOAD false */
+    int p_t = NO_JUMP;  /* position of an eventual LOAD true */
+    if (need_value(fs, e->t) || need_value(fs, e->f)) {
+      int fj = (e->k == VJMP) ? NO_JUMP : luaK_jump(fs);
+      p_f = code_label(fs, reg, 0, 1);
+      p_t = code_label(fs, reg, 1, 0);
+      luaK_patchtohere(fs, fj);
+    }
+    final = luaK_getlabel(fs);
+    patchlistaux(fs, e->f, final, reg, p_f);
+    patchlistaux(fs, e->t, final, reg, p_t);
+  }
+  e->f = e->t = NO_JUMP;
+  e->u.info = reg;
+  e->k = VNONRELOC;
+}
+
+
+void luaK_exp2nextreg (FuncState *fs, expdesc *e) {
+  luaK_dischargevars(fs, e);
+  freeexp(fs, e);
+  luaK_reserveregs(fs, 1);
+  exp2reg(fs, e, fs->freereg - 1);
+}
+
+
+int luaK_exp2anyreg (FuncState *fs, expdesc *e) {
+  luaK_dischargevars(fs, e);
+  if (e->k == VNONRELOC) {
+    if (!hasjumps(e)) return e->u.info;  /* exp is already in a register */
+    if (e->u.info >= fs->nactvar) {  /* reg. is not a local? */
+      exp2reg(fs, e, e->u.info);  /* put value on it */
+      return e->u.info;
+    }
+  }
+  luaK_exp2nextreg(fs, e);  /* default */
+  return e->u.info;
+}
+
+
+void luaK_exp2anyregup (FuncState *fs, expdesc *e) {
+  if (e->k != VUPVAL || hasjumps(e))
+    luaK_exp2anyreg(fs, e);
+}
+
+
+void luaK_exp2val (FuncState *fs, expdesc *e) {
+  if (hasjumps(e))
+    luaK_exp2anyreg(fs, e);
+  else
+    luaK_dischargevars(fs, e);
+}
+
+
+int luaK_exp2RK (FuncState *fs, expdesc *e) {
+  luaK_exp2val(fs, e);
+  switch (e->k) {
+    case VTRUE:
+    case VFALSE:
+    case VNIL: {
+      if (fs->nk <= MAXINDEXRK) {  /* constant fits in RK operand? */
+        e->u.info = (e->k == VNIL) ? nilK(fs) : boolK(fs, (e->k == VTRUE));
+        e->k = VK;
+        return RKASK(e->u.info);
+      }
+      else break;
+    }
+    case VKNUM: {
+      e->u.info = luaK_numberK(fs, e->u.nval);
+      e->k = VK;
+      /* go through */
+    }
+    case VK: {
+      if (e->u.info <= MAXINDEXRK)  /* constant fits in argC? */
+        return RKASK(e->u.info);
+      else break;
+    }
+    default: break;
+  }
+  /* not a constant in the right range: put it in a register */
+  return luaK_exp2anyreg(fs, e);
+}
+
+
+void luaK_storevar (FuncState *fs, expdesc *var, expdesc *ex) {
+  switch (var->k) {
+    case VLOCAL: {
+      freeexp(fs, ex);
+      exp2reg(fs, ex, var->u.info);
+      return;
+    }
+    case VUPVAL: {
+      int e = luaK_exp2anyreg(fs, ex);
+      luaK_codeABC(fs, OP_SETUPVAL, e, var->u.info, 0);
+      break;
+    }
+    case VINDEXED: {
+      OpCode op = (var->u.ind.vt == VLOCAL) ? OP_SETTABLE : OP_SETTABUP;
+      int e = luaK_exp2RK(fs, ex);
+      luaK_codeABC(fs, op, var->u.ind.t, var->u.ind.idx, e);
+      break;
+    }
+    default: {
+      lua_assert(0);  /* invalid var kind to store */
+      break;
+    }
+  }
+  freeexp(fs, ex);
+}
+
+
+void luaK_self (FuncState *fs, expdesc *e, expdesc *key) {
+  int ereg;
+  luaK_exp2anyreg(fs, e);
+  ereg = e->u.info;  /* register where 'e' was placed */
+  freeexp(fs, e);
+  e->u.info = fs->freereg;  /* base register for op_self */
+  e->k = VNONRELOC;
+  luaK_reserveregs(fs, 2);  /* function and 'self' produced by op_self */
+  luaK_codeABC(fs, OP_SELF, e->u.info, ereg, luaK_exp2RK(fs, key));
+  freeexp(fs, key);
+}
+
+
+static void invertjump (FuncState *fs, expdesc *e) {
+  Instruction *pc = getjumpcontrol(fs, e->u.info);
+  lua_assert(testTMode(GET_OPCODE(*pc)) && GET_OPCODE(*pc) != OP_TESTSET &&
+                                           GET_OPCODE(*pc) != OP_TEST);
+  SETARG_A(*pc, !(GETARG_A(*pc)));
+}
+
+
+static int jumponcond (FuncState *fs, expdesc *e, int cond) {
+  if (e->k == VRELOCABLE) {
+    Instruction ie = getcode(fs, e);
+    if (GET_OPCODE(ie) == OP_NOT) {
+      fs->pc--;  /* remove previous OP_NOT */
+      return condjump(fs, OP_TEST, GETARG_B(ie), 0, !cond);
+    }
+    /* else go through */
+  }
+  discharge2anyreg(fs, e);
+  freeexp(fs, e);
+  return condjump(fs, OP_TESTSET, NO_REG, e->u.info, cond);
+}
+
+
+void luaK_goiftrue (FuncState *fs, expdesc *e) {
+  int pc;  /* pc of last jump */
+  luaK_dischargevars(fs, e);
+  switch (e->k) {
+    case VJMP: {
+      invertjump(fs, e);
+      pc = e->u.info;
+      break;
+    }
+    case VK: case VKNUM: case VTRUE: {
+      pc = NO_JUMP;  /* always true; do nothing */
+      break;
+    }
+    default: {
+      pc = jumponcond(fs, e, 0);
+      break;
+    }
+  }
+  luaK_concat(fs, &e->f, pc);  /* insert last jump in `f' list */
+  luaK_patchtohere(fs, e->t);
+  e->t = NO_JUMP;
+}
+
+
+void luaK_goiffalse (FuncState *fs, expdesc *e) {
+  int pc;  /* pc of last jump */
+  luaK_dischargevars(fs, e);
+  switch (e->k) {
+    case VJMP: {
+      pc = e->u.info;
+      break;
+    }
+    case VNIL: case VFALSE: {
+      pc = NO_JUMP;  /* always false; do nothing */
+      break;
+    }
+    default: {
+      pc = jumponcond(fs, e, 1);
+      break;
+    }
+  }
+  luaK_concat(fs, &e->t, pc);  /* insert last jump in `t' list */
+  luaK_patchtohere(fs, e->f);
+  e->f = NO_JUMP;
+}
+
+
+static void codenot (FuncState *fs, expdesc *e) {
+  luaK_dischargevars(fs, e);
+  switch (e->k) {
+    case VNIL: case VFALSE: {
+      e->k = VTRUE;
+      break;
+    }
+    case VK: case VKNUM: case VTRUE: {
+      e->k = VFALSE;
+      break;
+    }
+    case VJMP: {
+      invertjump(fs, e);
+      break;
+    }
+    case VRELOCABLE:
+    case VNONRELOC: {
+      discharge2anyreg(fs, e);
+      freeexp(fs, e);
+      e->u.info = luaK_codeABC(fs, OP_NOT, 0, e->u.info, 0);
+      e->k = VRELOCABLE;
+      break;
+    }
+    default: {
+      lua_assert(0);  /* cannot happen */
+      break;
+    }
+  }
+  /* interchange true and false lists */
+  { int temp = e->f; e->f = e->t; e->t = temp; }
+  removevalues(fs, e->f);
+  removevalues(fs, e->t);
+}
+
+
+void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k) {
+  lua_assert(!hasjumps(t));
+  t->u.ind.t = t->u.info;
+  t->u.ind.idx = luaK_exp2RK(fs, k);
+  t->u.ind.vt = (t->k == VUPVAL) ? VUPVAL
+                                 : check_exp(vkisinreg(t->k), VLOCAL);
+  t->k = VINDEXED;
+}
+
+
+static int constfolding (OpCode op, expdesc *e1, expdesc *e2) {
+  lua_Number r;
+  if (!isnumeral(e1) || !isnumeral(e2)) return 0;
+  if ((op == OP_DIV || op == OP_MOD) && e2->u.nval == 0)
+    return 0;  /* do not attempt to divide by 0 */
+  r = luaO_arith(op - OP_ADD + LUA_OPADD, e1->u.nval, e2->u.nval);
+  e1->u.nval = r;
+  return 1;
+}
+
+
+static void codearith (FuncState *fs, OpCode op,
+                       expdesc *e1, expdesc *e2, int line) {
+  if (constfolding(op, e1, e2))
+    return;
+  else {
+    int o2 = (op != OP_UNM && op != OP_LEN) ? luaK_exp2RK(fs, e2) : 0;
+    int o1 = luaK_exp2RK(fs, e1);
+    if (o1 > o2) {
+      freeexp(fs, e1);
+      freeexp(fs, e2);
+    }
+    else {
+      freeexp(fs, e2);
+      freeexp(fs, e1);
+    }
+    e1->u.info = luaK_codeABC(fs, op, 0, o1, o2);
+    e1->k = VRELOCABLE;
+    luaK_fixline(fs, line);
+  }
+}
+
+
+static void codecomp (FuncState *fs, OpCode op, int cond, expdesc *e1,
+                                                          expdesc *e2) {
+  int o1 = luaK_exp2RK(fs, e1);
+  int o2 = luaK_exp2RK(fs, e2);
+  freeexp(fs, e2);
+  freeexp(fs, e1);
+  if (cond == 0 && op != OP_EQ) {
+    int temp;  /* exchange args to replace by `<' or `<=' */
+    temp = o1; o1 = o2; o2 = temp;  /* o1 <==> o2 */
+    cond = 1;
+  }
+  e1->u.info = condjump(fs, op, cond, o1, o2);
+  e1->k = VJMP;
+}
+
+
+void luaK_prefix (FuncState *fs, UnOpr op, expdesc *e, int line) {
+  expdesc e2;
+  e2.t = e2.f = NO_JUMP; e2.k = VKNUM; e2.u.nval = 0;
+  switch (op) {
+    case OPR_MINUS: {
+      if (isnumeral(e))  /* minus constant? */
+        e->u.nval = luai_numunm(NULL, e->u.nval);  /* fold it */
+      else {
+        luaK_exp2anyreg(fs, e);
+        codearith(fs, OP_UNM, e, &e2, line);
+      }
+      break;
+    }
+    case OPR_NOT: codenot(fs, e); break;
+    case OPR_LEN: {
+      luaK_exp2anyreg(fs, e);  /* cannot operate on constants */
+      codearith(fs, OP_LEN, e, &e2, line);
+      break;
+    }
+    default: lua_assert(0);
+  }
+}
+
+
+void luaK_infix (FuncState *fs, BinOpr op, expdesc *v) {
+  switch (op) {
+    case OPR_AND: {
+      luaK_goiftrue(fs, v);
+      break;
+    }
+    case OPR_OR: {
+      luaK_goiffalse(fs, v);
+      break;
+    }
+    case OPR_CONCAT: {
+      luaK_exp2nextreg(fs, v);  /* operand must be on the `stack' */
+      break;
+    }
+    case OPR_ADD: case OPR_SUB: case OPR_MUL: case OPR_DIV:
+    case OPR_MOD: case OPR_POW: {
+      if (!isnumeral(v)) luaK_exp2RK(fs, v);
+      break;
+    }
+    default: {
+      luaK_exp2RK(fs, v);
+      break;
+    }
+  }
+}
+
+
+void luaK_posfix (FuncState *fs, BinOpr op,
+                  expdesc *e1, expdesc *e2, int line) {
+  switch (op) {
+    case OPR_AND: {
+      lua_assert(e1->t == NO_JUMP);  /* list must be closed */
+      luaK_dischargevars(fs, e2);
+      luaK_concat(fs, &e2->f, e1->f);
+      *e1 = *e2;
+      break;
+    }
+    case OPR_OR: {
+      lua_assert(e1->f == NO_JUMP);  /* list must be closed */
+      luaK_dischargevars(fs, e2);
+      luaK_concat(fs, &e2->t, e1->t);
+      *e1 = *e2;
+      break;
+    }
+    case OPR_CONCAT: {
+      luaK_exp2val(fs, e2);
+      if (e2->k == VRELOCABLE && GET_OPCODE(getcode(fs, e2)) == OP_CONCAT) {
+        lua_assert(e1->u.info == GETARG_B(getcode(fs, e2))-1);
+        freeexp(fs, e1);
+        SETARG_B(getcode(fs, e2), e1->u.info);
+        e1->k = VRELOCABLE; e1->u.info = e2->u.info;
+      }
+      else {
+        luaK_exp2nextreg(fs, e2);  /* operand must be on the 'stack' */
+        codearith(fs, OP_CONCAT, e1, e2, line);
+      }
+      break;
+    }
+    case OPR_ADD: case OPR_SUB: case OPR_MUL: case OPR_DIV:
+    case OPR_MOD: case OPR_POW: {
+      codearith(fs, cast(OpCode, op - OPR_ADD + OP_ADD), e1, e2, line);
+      break;
+    }
+    case OPR_EQ: case OPR_LT: case OPR_LE: {
+      codecomp(fs, cast(OpCode, op - OPR_EQ + OP_EQ), 1, e1, e2);
+      break;
+    }
+    case OPR_NE: case OPR_GT: case OPR_GE: {
+      codecomp(fs, cast(OpCode, op - OPR_NE + OP_EQ), 0, e1, e2);
+      break;
+    }
+    default: lua_assert(0);
+  }
+}
+
+
+void luaK_fixline (FuncState *fs, int line) {
+  fs->f->lineinfo[fs->pc - 1] = line;
+}
+
+
+void luaK_setlist (FuncState *fs, int base, int nelems, int tostore) {
+  int c =  (nelems - 1)/LFIELDS_PER_FLUSH + 1;
+  int b = (tostore == LUA_MULTRET) ? 0 : tostore;
+  lua_assert(tostore != 0);
+  if (c <= MAXARG_C)
+    luaK_codeABC(fs, OP_SETLIST, base, b, c);
+  else if (c <= MAXARG_Ax) {
+    luaK_codeABC(fs, OP_SETLIST, base, b, 0);
+    codeextraarg(fs, c);
+  }
+  else
+    luaX_syntaxerror(fs->ls, "constructor too long");
+  fs->freereg = base + 1;  /* free registers with list values */
+}
+
diff -ruNp src.orig/libs/lua/lcode.h src/libs/lua/lcode.h
--- src.orig/libs/lua/lcode.h	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lcode.h	2017-11-21 19:39:46 -0600
@@ -0,0 +1,83 @@
+/*
+** $Id: lcode.h,v 1.58 2011/08/30 16:26:41 roberto Exp $
+** Code generator for Lua
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lcode_h
+#define lcode_h
+
+#include "llex.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lparser.h"
+
+
+/*
+** Marks the end of a patch list. It is an invalid value both as an absolute
+** address, and as a list link (would link an element to itself).
+*/
+#define NO_JUMP (-1)
+
+
+/*
+** grep "ORDER OPR" if you change these enums  (ORDER OP)
+*/
+typedef enum BinOpr {
+  OPR_ADD, OPR_SUB, OPR_MUL, OPR_DIV, OPR_MOD, OPR_POW,
+  OPR_CONCAT,
+  OPR_EQ, OPR_LT, OPR_LE,
+  OPR_NE, OPR_GT, OPR_GE,
+  OPR_AND, OPR_OR,
+  OPR_NOBINOPR
+} BinOpr;
+
+
+typedef enum UnOpr { OPR_MINUS, OPR_NOT, OPR_LEN, OPR_NOUNOPR } UnOpr;
+
+
+#define getcode(fs,e)	((fs)->f->code[(e)->u.info])
+
+#define luaK_codeAsBx(fs,o,A,sBx)	luaK_codeABx(fs,o,A,(sBx)+MAXARG_sBx)
+
+#define luaK_setmultret(fs,e)	luaK_setreturns(fs, e, LUA_MULTRET)
+
+#define luaK_jumpto(fs,t)	luaK_patchlist(fs, luaK_jump(fs), t)
+
+LUAI_FUNC int luaK_codeABx (FuncState *fs, OpCode o, int A, unsigned int Bx);
+LUAI_FUNC int luaK_codeABC (FuncState *fs, OpCode o, int A, int B, int C);
+LUAI_FUNC int luaK_codek (FuncState *fs, int reg, int k);
+LUAI_FUNC void luaK_fixline (FuncState *fs, int line);
+LUAI_FUNC void luaK_nil (FuncState *fs, int from, int n);
+LUAI_FUNC void luaK_reserveregs (FuncState *fs, int n);
+LUAI_FUNC void luaK_checkstack (FuncState *fs, int n);
+LUAI_FUNC int luaK_stringK (FuncState *fs, TString *s);
+LUAI_FUNC int luaK_numberK (FuncState *fs, lua_Number r);
+LUAI_FUNC void luaK_dischargevars (FuncState *fs, expdesc *e);
+LUAI_FUNC int luaK_exp2anyreg (FuncState *fs, expdesc *e);
+LUAI_FUNC void luaK_exp2anyregup (FuncState *fs, expdesc *e);
+LUAI_FUNC void luaK_exp2nextreg (FuncState *fs, expdesc *e);
+LUAI_FUNC void luaK_exp2val (FuncState *fs, expdesc *e);
+LUAI_FUNC int luaK_exp2RK (FuncState *fs, expdesc *e);
+LUAI_FUNC void luaK_self (FuncState *fs, expdesc *e, expdesc *key);
+LUAI_FUNC void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k);
+LUAI_FUNC void luaK_goiftrue (FuncState *fs, expdesc *e);
+LUAI_FUNC void luaK_goiffalse (FuncState *fs, expdesc *e);
+LUAI_FUNC void luaK_storevar (FuncState *fs, expdesc *var, expdesc *e);
+LUAI_FUNC void luaK_setreturns (FuncState *fs, expdesc *e, int nresults);
+LUAI_FUNC void luaK_setoneret (FuncState *fs, expdesc *e);
+LUAI_FUNC int luaK_jump (FuncState *fs);
+LUAI_FUNC void luaK_ret (FuncState *fs, int first, int nret);
+LUAI_FUNC void luaK_patchlist (FuncState *fs, int list, int target);
+LUAI_FUNC void luaK_patchtohere (FuncState *fs, int list);
+LUAI_FUNC void luaK_patchclose (FuncState *fs, int list, int level);
+LUAI_FUNC void luaK_concat (FuncState *fs, int *l1, int l2);
+LUAI_FUNC int luaK_getlabel (FuncState *fs);
+LUAI_FUNC void luaK_prefix (FuncState *fs, UnOpr op, expdesc *v, int line);
+LUAI_FUNC void luaK_infix (FuncState *fs, BinOpr op, expdesc *v);
+LUAI_FUNC void luaK_posfix (FuncState *fs, BinOpr op, expdesc *v1,
+                            expdesc *v2, int line);
+LUAI_FUNC void luaK_setlist (FuncState *fs, int base, int nelems, int tostore);
+
+
+#endif
diff -ruNp src.orig/libs/lua/lcorolib.c src/libs/lua/lcorolib.c
--- src.orig/libs/lua/lcorolib.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lcorolib.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,155 @@
+/*
+** $Id: lcorolib.c,v 1.5 2013/02/21 13:44:53 roberto Exp $
+** Coroutine Library
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdlib.h>
+
+
+#define lcorolib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+static int auxresume (lua_State *L, lua_State *co, int narg) {
+  int status;
+  if (!lua_checkstack(co, narg)) {
+    lua_pushliteral(L, "too many arguments to resume");
+    return -1;  /* error flag */
+  }
+  if (lua_status(co) == LUA_OK && lua_gettop(co) == 0) {
+    lua_pushliteral(L, "cannot resume dead coroutine");
+    return -1;  /* error flag */
+  }
+  lua_xmove(L, co, narg);
+  status = lua_resume(co, L, narg);
+  if (status == LUA_OK || status == LUA_YIELD) {
+    int nres = lua_gettop(co);
+    if (!lua_checkstack(L, nres + 1)) {
+      lua_pop(co, nres);  /* remove results anyway */
+      lua_pushliteral(L, "too many results to resume");
+      return -1;  /* error flag */
+    }
+    lua_xmove(co, L, nres);  /* move yielded values */
+    return nres;
+  }
+  else {
+    lua_xmove(co, L, 1);  /* move error message */
+    return -1;  /* error flag */
+  }
+}
+
+
+static int luaB_coresume (lua_State *L) {
+  lua_State *co = lua_tothread(L, 1);
+  int r;
+  luaL_argcheck(L, co, 1, "coroutine expected");
+  r = auxresume(L, co, lua_gettop(L) - 1);
+  if (r < 0) {
+    lua_pushboolean(L, 0);
+    lua_insert(L, -2);
+    return 2;  /* return false + error message */
+  }
+  else {
+    lua_pushboolean(L, 1);
+    lua_insert(L, -(r + 1));
+    return r + 1;  /* return true + `resume' returns */
+  }
+}
+
+
+static int luaB_auxwrap (lua_State *L) {
+  lua_State *co = lua_tothread(L, lua_upvalueindex(1));
+  int r = auxresume(L, co, lua_gettop(L));
+  if (r < 0) {
+    if (lua_isstring(L, -1)) {  /* error object is a string? */
+      luaL_where(L, 1);  /* add extra info */
+      lua_insert(L, -2);
+      lua_concat(L, 2);
+    }
+    return lua_error(L);  /* propagate error */
+  }
+  return r;
+}
+
+
+static int luaB_cocreate (lua_State *L) {
+  lua_State *NL;
+  luaL_checktype(L, 1, LUA_TFUNCTION);
+  NL = lua_newthread(L);
+  lua_pushvalue(L, 1);  /* move function to top */
+  lua_xmove(L, NL, 1);  /* move function from L to NL */
+  return 1;
+}
+
+
+static int luaB_cowrap (lua_State *L) {
+  luaB_cocreate(L);
+  lua_pushcclosure(L, luaB_auxwrap, 1);
+  return 1;
+}
+
+
+static int luaB_yield (lua_State *L) {
+  return lua_yield(L, lua_gettop(L));
+}
+
+
+static int luaB_costatus (lua_State *L) {
+  lua_State *co = lua_tothread(L, 1);
+  luaL_argcheck(L, co, 1, "coroutine expected");
+  if (L == co) lua_pushliteral(L, "running");
+  else {
+    switch (lua_status(co)) {
+      case LUA_YIELD:
+        lua_pushliteral(L, "suspended");
+        break;
+      case LUA_OK: {
+        lua_Debug ar;
+        if (lua_getstack(co, 0, &ar) > 0)  /* does it have frames? */
+          lua_pushliteral(L, "normal");  /* it is running */
+        else if (lua_gettop(co) == 0)
+            lua_pushliteral(L, "dead");
+        else
+          lua_pushliteral(L, "suspended");  /* initial state */
+        break;
+      }
+      default:  /* some error occurred */
+        lua_pushliteral(L, "dead");
+        break;
+    }
+  }
+  return 1;
+}
+
+
+static int luaB_corunning (lua_State *L) {
+  int ismain = lua_pushthread(L);
+  lua_pushboolean(L, ismain);
+  return 2;
+}
+
+
+static const luaL_Reg co_funcs[] = {
+  {"create", luaB_cocreate},
+  {"resume", luaB_coresume},
+  {"running", luaB_corunning},
+  {"status", luaB_costatus},
+  {"wrap", luaB_cowrap},
+  {"yield", luaB_yield},
+  {NULL, NULL}
+};
+
+
+
+LUAMOD_API int luaopen_coroutine (lua_State *L) {
+  luaL_newlib(L, co_funcs);
+  return 1;
+}
+
diff -ruNp src.orig/libs/lua/lctype.c src/libs/lua/lctype.c
--- src.orig/libs/lua/lctype.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lctype.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,52 @@
+/*
+** $Id: lctype.c,v 1.11 2011/10/03 16:19:23 roberto Exp $
+** 'ctype' functions for Lua
+** See Copyright Notice in lua.h
+*/
+
+#define lctype_c
+#define LUA_CORE
+
+#include "lctype.h"
+
+#if !LUA_USE_CTYPE	/* { */
+
+#include <limits.h>
+
+LUAI_DDEF const lu_byte luai_ctype_[UCHAR_MAX + 2] = {
+  0x00,  /* EOZ */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* 0. */
+  0x00,  0x08,  0x08,  0x08,  0x08,  0x08,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* 1. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x0c,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,	/* 2. */
+  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,
+  0x16,  0x16,  0x16,  0x16,  0x16,  0x16,  0x16,  0x16,	/* 3. */
+  0x16,  0x16,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,
+  0x04,  0x15,  0x15,  0x15,  0x15,  0x15,  0x15,  0x05,	/* 4. */
+  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,
+  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,	/* 5. */
+  0x05,  0x05,  0x05,  0x04,  0x04,  0x04,  0x04,  0x05,
+  0x04,  0x15,  0x15,  0x15,  0x15,  0x15,  0x15,  0x05,	/* 6. */
+  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,
+  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,	/* 7. */
+  0x05,  0x05,  0x05,  0x04,  0x04,  0x04,  0x04,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* 8. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* 9. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* a. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* b. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* c. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* d. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* e. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* f. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+};
+
+#endif			/* } */
diff -ruNp src.orig/libs/lua/lctype.h src/libs/lua/lctype.h
--- src.orig/libs/lua/lctype.h	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lctype.h	2017-11-21 19:39:46 -0600
@@ -0,0 +1,95 @@
+/*
+** $Id: lctype.h,v 1.12 2011/07/15 12:50:29 roberto Exp $
+** 'ctype' functions for Lua
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lctype_h
+#define lctype_h
+
+#include "lua.h"
+
+
+/*
+** WARNING: the functions defined here do not necessarily correspond
+** to the similar functions in the standard C ctype.h. They are
+** optimized for the specific needs of Lua
+*/
+
+#if !defined(LUA_USE_CTYPE)
+
+#if 'A' == 65 && '0' == 48
+/* ASCII case: can use its own tables; faster and fixed */
+#define LUA_USE_CTYPE	0
+#else
+/* must use standard C ctype */
+#define LUA_USE_CTYPE	1
+#endif
+
+#endif
+
+
+#if !LUA_USE_CTYPE	/* { */
+
+#include <limits.h>
+
+#include "llimits.h"
+
+
+#define ALPHABIT	0
+#define DIGITBIT	1
+#define PRINTBIT	2
+#define SPACEBIT	3
+#define XDIGITBIT	4
+
+
+#define MASK(B)		(1 << (B))
+
+
+/*
+** add 1 to char to allow index -1 (EOZ)
+*/
+#define testprop(c,p)	(luai_ctype_[(c)+1] & (p))
+
+/*
+** 'lalpha' (Lua alphabetic) and 'lalnum' (Lua alphanumeric) both include '_'
+*/
+#define lislalpha(c)	testprop(c, MASK(ALPHABIT))
+#define lislalnum(c)	testprop(c, (MASK(ALPHABIT) | MASK(DIGITBIT)))
+#define lisdigit(c)	testprop(c, MASK(DIGITBIT))
+#define lisspace(c)	testprop(c, MASK(SPACEBIT))
+#define lisprint(c)	testprop(c, MASK(PRINTBIT))
+#define lisxdigit(c)	testprop(c, MASK(XDIGITBIT))
+
+/*
+** this 'ltolower' only works for alphabetic characters
+*/
+#define ltolower(c)	((c) | ('A' ^ 'a'))
+
+
+/* two more entries for 0 and -1 (EOZ) */
+LUAI_DDEC const lu_byte luai_ctype_[UCHAR_MAX + 2];
+
+
+#else			/* }{ */
+
+/*
+** use standard C ctypes
+*/
+
+#include <ctype.h>
+
+
+#define lislalpha(c)	(isalpha(c) || (c) == '_')
+#define lislalnum(c)	(isalnum(c) || (c) == '_')
+#define lisdigit(c)	(isdigit(c))
+#define lisspace(c)	(isspace(c))
+#define lisprint(c)	(isprint(c))
+#define lisxdigit(c)	(isxdigit(c))
+
+#define ltolower(c)	(tolower(c))
+
+#endif			/* } */
+
+#endif
+
diff -ruNp src.orig/libs/lua/ldblib.c src/libs/lua/ldblib.c
--- src.orig/libs/lua/ldblib.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/ldblib.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,398 @@
+/*
+** $Id: ldblib.c,v 1.132 2012/01/19 20:14:44 roberto Exp $
+** Interface from Lua to its debug API
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define ldblib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+#define HOOKKEY		"_HKEY"
+
+
+
+static int db_getregistry (lua_State *L) {
+  lua_pushvalue(L, LUA_REGISTRYINDEX);
+  return 1;
+}
+
+
+static int db_getmetatable (lua_State *L) {
+  luaL_checkany(L, 1);
+  if (!lua_getmetatable(L, 1)) {
+    lua_pushnil(L);  /* no metatable */
+  }
+  return 1;
+}
+
+
+static int db_setmetatable (lua_State *L) {
+  int t = lua_type(L, 2);
+  luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2,
+                    "nil or table expected");
+  lua_settop(L, 2);
+  lua_setmetatable(L, 1);
+  return 1;  /* return 1st argument */
+}
+
+
+static int db_getuservalue (lua_State *L) {
+  if (lua_type(L, 1) != LUA_TUSERDATA)
+    lua_pushnil(L);
+  else
+    lua_getuservalue(L, 1);
+  return 1;
+}
+
+
+static int db_setuservalue (lua_State *L) {
+  if (lua_type(L, 1) == LUA_TLIGHTUSERDATA)
+    luaL_argerror(L, 1, "full userdata expected, got light userdata");
+  luaL_checktype(L, 1, LUA_TUSERDATA);
+  if (!lua_isnoneornil(L, 2))
+    luaL_checktype(L, 2, LUA_TTABLE);
+  lua_settop(L, 2);
+  lua_setuservalue(L, 1);
+  return 1;
+}
+
+
+static void settabss (lua_State *L, const char *i, const char *v) {
+  lua_pushstring(L, v);
+  lua_setfield(L, -2, i);
+}
+
+
+static void settabsi (lua_State *L, const char *i, int v) {
+  lua_pushinteger(L, v);
+  lua_setfield(L, -2, i);
+}
+
+
+static void settabsb (lua_State *L, const char *i, int v) {
+  lua_pushboolean(L, v);
+  lua_setfield(L, -2, i);
+}
+
+
+static lua_State *getthread (lua_State *L, int *arg) {
+  if (lua_isthread(L, 1)) {
+    *arg = 1;
+    return lua_tothread(L, 1);
+  }
+  else {
+    *arg = 0;
+    return L;
+  }
+}
+
+
+static void treatstackoption (lua_State *L, lua_State *L1, const char *fname) {
+  if (L == L1) {
+    lua_pushvalue(L, -2);
+    lua_remove(L, -3);
+  }
+  else
+    lua_xmove(L1, L, 1);
+  lua_setfield(L, -2, fname);
+}
+
+
+static int db_getinfo (lua_State *L) {
+  lua_Debug ar;
+  int arg;
+  lua_State *L1 = getthread(L, &arg);
+  const char *options = luaL_optstring(L, arg+2, "flnStu");
+  if (lua_isnumber(L, arg+1)) {
+    if (!lua_getstack(L1, (int)lua_tointeger(L, arg+1), &ar)) {
+      lua_pushnil(L);  /* level out of range */
+      return 1;
+    }
+  }
+  else if (lua_isfunction(L, arg+1)) {
+    lua_pushfstring(L, ">%s", options);
+    options = lua_tostring(L, -1);
+    lua_pushvalue(L, arg+1);
+    lua_xmove(L, L1, 1);
+  }
+  else
+    return luaL_argerror(L, arg+1, "function or level expected");
+  if (!lua_getinfo(L1, options, &ar))
+    return luaL_argerror(L, arg+2, "invalid option");
+  lua_createtable(L, 0, 2);
+  if (strchr(options, 'S')) {
+    settabss(L, "source", ar.source);
+    settabss(L, "short_src", ar.short_src);
+    settabsi(L, "linedefined", ar.linedefined);
+    settabsi(L, "lastlinedefined", ar.lastlinedefined);
+    settabss(L, "what", ar.what);
+  }
+  if (strchr(options, 'l'))
+    settabsi(L, "currentline", ar.currentline);
+  if (strchr(options, 'u')) {
+    settabsi(L, "nups", ar.nups);
+    settabsi(L, "nparams", ar.nparams);
+    settabsb(L, "isvararg", ar.isvararg);
+  }
+  if (strchr(options, 'n')) {
+    settabss(L, "name", ar.name);
+    settabss(L, "namewhat", ar.namewhat);
+  }
+  if (strchr(options, 't'))
+    settabsb(L, "istailcall", ar.istailcall);
+  if (strchr(options, 'L'))
+    treatstackoption(L, L1, "activelines");
+  if (strchr(options, 'f'))
+    treatstackoption(L, L1, "func");
+  return 1;  /* return table */
+}
+
+
+static int db_getlocal (lua_State *L) {
+  int arg;
+  lua_State *L1 = getthread(L, &arg);
+  lua_Debug ar;
+  const char *name;
+  int nvar = luaL_checkint(L, arg+2);  /* local-variable index */
+  if (lua_isfunction(L, arg + 1)) {  /* function argument? */
+    lua_pushvalue(L, arg + 1);  /* push function */
+    lua_pushstring(L, lua_getlocal(L, NULL, nvar));  /* push local name */
+    return 1;
+  }
+  else {  /* stack-level argument */
+    if (!lua_getstack(L1, luaL_checkint(L, arg+1), &ar))  /* out of range? */
+      return luaL_argerror(L, arg+1, "level out of range");
+    name = lua_getlocal(L1, &ar, nvar);
+    if (name) {
+      lua_xmove(L1, L, 1);  /* push local value */
+      lua_pushstring(L, name);  /* push name */
+      lua_pushvalue(L, -2);  /* re-order */
+      return 2;
+    }
+    else {
+      lua_pushnil(L);  /* no name (nor value) */
+      return 1;
+    }
+  }
+}
+
+
+static int db_setlocal (lua_State *L) {
+  int arg;
+  lua_State *L1 = getthread(L, &arg);
+  lua_Debug ar;
+  if (!lua_getstack(L1, luaL_checkint(L, arg+1), &ar))  /* out of range? */
+    return luaL_argerror(L, arg+1, "level out of range");
+  luaL_checkany(L, arg+3);
+  lua_settop(L, arg+3);
+  lua_xmove(L, L1, 1);
+  lua_pushstring(L, lua_setlocal(L1, &ar, luaL_checkint(L, arg+2)));
+  return 1;
+}
+
+
+static int auxupvalue (lua_State *L, int get) {
+  const char *name;
+  int n = luaL_checkint(L, 2);
+  luaL_checktype(L, 1, LUA_TFUNCTION);
+  name = get ? lua_getupvalue(L, 1, n) : lua_setupvalue(L, 1, n);
+  if (name == NULL) return 0;
+  lua_pushstring(L, name);
+  lua_insert(L, -(get+1));
+  return get + 1;
+}
+
+
+static int db_getupvalue (lua_State *L) {
+  return auxupvalue(L, 1);
+}
+
+
+static int db_setupvalue (lua_State *L) {
+  luaL_checkany(L, 3);
+  return auxupvalue(L, 0);
+}
+
+
+static int checkupval (lua_State *L, int argf, int argnup) {
+  lua_Debug ar;
+  int nup = luaL_checkint(L, argnup);
+  luaL_checktype(L, argf, LUA_TFUNCTION);
+  lua_pushvalue(L, argf);
+  lua_getinfo(L, ">u", &ar);
+  luaL_argcheck(L, 1 <= nup && nup <= ar.nups, argnup, "invalid upvalue index");
+  return nup;
+}
+
+
+static int db_upvalueid (lua_State *L) {
+  int n = checkupval(L, 1, 2);
+  lua_pushlightuserdata(L, lua_upvalueid(L, 1, n));
+  return 1;
+}
+
+
+static int db_upvaluejoin (lua_State *L) {
+  int n1 = checkupval(L, 1, 2);
+  int n2 = checkupval(L, 3, 4);
+  luaL_argcheck(L, !lua_iscfunction(L, 1), 1, "Lua function expected");
+  luaL_argcheck(L, !lua_iscfunction(L, 3), 3, "Lua function expected");
+  lua_upvaluejoin(L, 1, n1, 3, n2);
+  return 0;
+}
+
+
+#define gethooktable(L)	luaL_getsubtable(L, LUA_REGISTRYINDEX, HOOKKEY)
+
+
+static void hookf (lua_State *L, lua_Debug *ar) {
+  static const char *const hooknames[] =
+    {"call", "return", "line", "count", "tail call"};
+  gethooktable(L);
+  lua_pushthread(L);
+  lua_rawget(L, -2);
+  if (lua_isfunction(L, -1)) {
+    lua_pushstring(L, hooknames[(int)ar->event]);
+    if (ar->currentline >= 0)
+      lua_pushinteger(L, ar->currentline);
+    else lua_pushnil(L);
+    lua_assert(lua_getinfo(L, "lS", ar));
+    lua_call(L, 2, 0);
+  }
+}
+
+
+static int makemask (const char *smask, int count) {
+  int mask = 0;
+  if (strchr(smask, 'c')) mask |= LUA_MASKCALL;
+  if (strchr(smask, 'r')) mask |= LUA_MASKRET;
+  if (strchr(smask, 'l')) mask |= LUA_MASKLINE;
+  if (count > 0) mask |= LUA_MASKCOUNT;
+  return mask;
+}
+
+
+static char *unmakemask (int mask, char *smask) {
+  int i = 0;
+  if (mask & LUA_MASKCALL) smask[i++] = 'c';
+  if (mask & LUA_MASKRET) smask[i++] = 'r';
+  if (mask & LUA_MASKLINE) smask[i++] = 'l';
+  smask[i] = '\0';
+  return smask;
+}
+
+
+static int db_sethook (lua_State *L) {
+  int arg, mask, count;
+  lua_Hook func;
+  lua_State *L1 = getthread(L, &arg);
+  if (lua_isnoneornil(L, arg+1)) {
+    lua_settop(L, arg+1);
+    func = NULL; mask = 0; count = 0;  /* turn off hooks */
+  }
+  else {
+    const char *smask = luaL_checkstring(L, arg+2);
+    luaL_checktype(L, arg+1, LUA_TFUNCTION);
+    count = luaL_optint(L, arg+3, 0);
+    func = hookf; mask = makemask(smask, count);
+  }
+  if (gethooktable(L) == 0) {  /* creating hook table? */
+    lua_pushstring(L, "k");
+    lua_setfield(L, -2, "__mode");  /** hooktable.__mode = "k" */
+    lua_pushvalue(L, -1);
+    lua_setmetatable(L, -2);  /* setmetatable(hooktable) = hooktable */
+  }
+  lua_pushthread(L1); lua_xmove(L1, L, 1);
+  lua_pushvalue(L, arg+1);
+  lua_rawset(L, -3);  /* set new hook */
+  lua_sethook(L1, func, mask, count);  /* set hooks */
+  return 0;
+}
+
+
+static int db_gethook (lua_State *L) {
+  int arg;
+  lua_State *L1 = getthread(L, &arg);
+  char buff[5];
+  int mask = lua_gethookmask(L1);
+  lua_Hook hook = lua_gethook(L1);
+  if (hook != NULL && hook != hookf)  /* external hook? */
+    lua_pushliteral(L, "external hook");
+  else {
+    gethooktable(L);
+    lua_pushthread(L1); lua_xmove(L1, L, 1);
+    lua_rawget(L, -2);   /* get hook */
+    lua_remove(L, -2);  /* remove hook table */
+  }
+  lua_pushstring(L, unmakemask(mask, buff));
+  lua_pushinteger(L, lua_gethookcount(L1));
+  return 3;
+}
+
+
+static int db_debug (lua_State *L) {
+  for (;;) {
+    char buffer[250];
+    luai_writestringerror("%s", "lua_debug> ");
+    if (fgets(buffer, sizeof(buffer), stdin) == 0 ||
+        strcmp(buffer, "cont\n") == 0)
+      return 0;
+    if (luaL_loadbuffer(L, buffer, strlen(buffer), "=(debug command)") ||
+        lua_pcall(L, 0, 0, 0))
+      luai_writestringerror("%s\n", lua_tostring(L, -1));
+    lua_settop(L, 0);  /* remove eventual returns */
+  }
+}
+
+
+static int db_traceback (lua_State *L) {
+  int arg;
+  lua_State *L1 = getthread(L, &arg);
+  const char *msg = lua_tostring(L, arg + 1);
+  if (msg == NULL && !lua_isnoneornil(L, arg + 1))  /* non-string 'msg'? */
+    lua_pushvalue(L, arg + 1);  /* return it untouched */
+  else {
+    int level = luaL_optint(L, arg + 2, (L == L1) ? 1 : 0);
+    luaL_traceback(L, L1, msg, level);
+  }
+  return 1;
+}
+
+
+static const luaL_Reg dblib[] = {
+  {"debug", db_debug},
+  {"getuservalue", db_getuservalue},
+  {"gethook", db_gethook},
+  {"getinfo", db_getinfo},
+  {"getlocal", db_getlocal},
+  {"getregistry", db_getregistry},
+  {"getmetatable", db_getmetatable},
+  {"getupvalue", db_getupvalue},
+  {"upvaluejoin", db_upvaluejoin},
+  {"upvalueid", db_upvalueid},
+  {"setuservalue", db_setuservalue},
+  {"sethook", db_sethook},
+  {"setlocal", db_setlocal},
+  {"setmetatable", db_setmetatable},
+  {"setupvalue", db_setupvalue},
+  {"traceback", db_traceback},
+  {NULL, NULL}
+};
+
+
+LUAMOD_API int luaopen_debug (lua_State *L) {
+  luaL_newlib(L, dblib);
+  return 1;
+}
+
diff -ruNp src.orig/libs/lua/ldebug.c src/libs/lua/ldebug.c
--- src.orig/libs/lua/ldebug.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/ldebug.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,580 @@
+/*
+** $Id: ldebug.c,v 2.90 2012/08/16 17:34:28 roberto Exp $
+** Debug Interface
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdarg.h>
+#include <stddef.h>
+#include <string.h>
+
+
+#define ldebug_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lapi.h"
+#include "lcode.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+#include "lvm.h"
+
+
+
+#define noLuaClosure(f)		((f) == NULL || (f)->c.tt == LUA_TCCL)
+
+
+static const char *getfuncname (lua_State *L, CallInfo *ci, const char **name);
+
+
+static int currentpc (CallInfo *ci) {
+  lua_assert(isLua(ci));
+  return pcRel(ci->u.l.savedpc, ci_func(ci)->p);
+}
+
+
+static int currentline (CallInfo *ci) {
+  return getfuncline(ci_func(ci)->p, currentpc(ci));
+}
+
+
+/*
+** this function can be called asynchronous (e.g. during a signal)
+*/
+LUA_API int lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {
+  if (func == NULL || mask == 0) {  /* turn off hooks? */
+    mask = 0;
+    func = NULL;
+  }
+  if (isLua(L->ci))
+    L->oldpc = L->ci->u.l.savedpc;
+  L->hook = func;
+  L->basehookcount = count;
+  resethookcount(L);
+  L->hookmask = cast_byte(mask);
+  return 1;
+}
+
+
+LUA_API lua_Hook lua_gethook (lua_State *L) {
+  return L->hook;
+}
+
+
+LUA_API int lua_gethookmask (lua_State *L) {
+  return L->hookmask;
+}
+
+
+LUA_API int lua_gethookcount (lua_State *L) {
+  return L->basehookcount;
+}
+
+
+LUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar) {
+  int status;
+  CallInfo *ci;
+  if (level < 0) return 0;  /* invalid (negative) level */
+  lua_lock(L);
+  for (ci = L->ci; level > 0 && ci != &L->base_ci; ci = ci->previous)
+    level--;
+  if (level == 0 && ci != &L->base_ci) {  /* level found? */
+    status = 1;
+    ar->i_ci = ci;
+  }
+  else status = 0;  /* no such level */
+  lua_unlock(L);
+  return status;
+}
+
+
+static const char *upvalname (Proto *p, int uv) {
+  TString *s = check_exp(uv < p->sizeupvalues, p->upvalues[uv].name);
+  if (s == NULL) return "?";
+  else return getstr(s);
+}
+
+
+static const char *findvararg (CallInfo *ci, int n, StkId *pos) {
+  int nparams = clLvalue(ci->func)->p->numparams;
+  if (n >= ci->u.l.base - ci->func - nparams)
+    return NULL;  /* no such vararg */
+  else {
+    *pos = ci->func + nparams + n;
+    return "(*vararg)";  /* generic name for any vararg */
+  }
+}
+
+
+static const char *findlocal (lua_State *L, CallInfo *ci, int n,
+                              StkId *pos) {
+  const char *name = NULL;
+  StkId base;
+  if (isLua(ci)) {
+    if (n < 0)  /* access to vararg values? */
+      return findvararg(ci, -n, pos);
+    else {
+      base = ci->u.l.base;
+      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));
+    }
+  }
+  else
+    base = ci->func + 1;
+  if (name == NULL) {  /* no 'standard' name? */
+    StkId limit = (ci == L->ci) ? L->top : ci->next->func;
+    if (limit - base >= n && n > 0)  /* is 'n' inside 'ci' stack? */
+      name = "(*temporary)";  /* generic name for any valid slot */
+    else
+      return NULL;  /* no name */
+  }
+  *pos = base + (n - 1);
+  return name;
+}
+
+
+LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n) {
+  const char *name;
+  lua_lock(L);
+  if (ar == NULL) {  /* information about non-active function? */
+    if (!isLfunction(L->top - 1))  /* not a Lua function? */
+      name = NULL;
+    else  /* consider live variables at function start (parameters) */
+      name = luaF_getlocalname(clLvalue(L->top - 1)->p, n, 0);
+  }
+  else {  /* active function; get information through 'ar' */
+    StkId pos = 0;  /* to avoid warnings */
+    name = findlocal(L, ar->i_ci, n, &pos);
+    if (name) {
+      setobj2s(L, L->top, pos);
+      api_incr_top(L);
+    }
+  }
+  lua_unlock(L);
+  return name;
+}
+
+
+LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {
+  StkId pos = 0;  /* to avoid warnings */
+  const char *name = findlocal(L, ar->i_ci, n, &pos);
+  lua_lock(L);
+  if (name)
+    setobjs2s(L, pos, L->top - 1);
+  L->top--;  /* pop value */
+  lua_unlock(L);
+  return name;
+}
+
+
+static void funcinfo (lua_Debug *ar, Closure *cl) {
+  if (noLuaClosure(cl)) {
+    ar->source = "=[C]";
+    ar->linedefined = -1;
+    ar->lastlinedefined = -1;
+    ar->what = "C";
+  }
+  else {
+    Proto *p = cl->l.p;
+    ar->source = p->source ? getstr(p->source) : "=?";
+    ar->linedefined = p->linedefined;
+    ar->lastlinedefined = p->lastlinedefined;
+    ar->what = (ar->linedefined == 0) ? "main" : "Lua";
+  }
+  luaO_chunkid(ar->short_src, ar->source, LUA_IDSIZE);
+}
+
+
+static void collectvalidlines (lua_State *L, Closure *f) {
+  if (noLuaClosure(f)) {
+    setnilvalue(L->top);
+    api_incr_top(L);
+  }
+  else {
+    int i;
+    TValue v;
+    int *lineinfo = f->l.p->lineinfo;
+    Table *t = luaH_new(L);  /* new table to store active lines */
+    sethvalue(L, L->top, t);  /* push it on stack */
+    api_incr_top(L);
+    setbvalue(&v, 1);  /* boolean 'true' to be the value of all indices */
+    for (i = 0; i < f->l.p->sizelineinfo; i++)  /* for all lines with code */
+      luaH_setint(L, t, lineinfo[i], &v);  /* table[line] = true */
+  }
+}
+
+
+static int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,
+                       Closure *f, CallInfo *ci) {
+  int status = 1;
+  for (; *what; what++) {
+    switch (*what) {
+      case 'S': {
+        funcinfo(ar, f);
+        break;
+      }
+      case 'l': {
+        ar->currentline = (ci && isLua(ci)) ? currentline(ci) : -1;
+        break;
+      }
+      case 'u': {
+        ar->nups = (f == NULL) ? 0 : f->c.nupvalues;
+        if (noLuaClosure(f)) {
+          ar->isvararg = 1;
+          ar->nparams = 0;
+        }
+        else {
+          ar->isvararg = f->l.p->is_vararg;
+          ar->nparams = f->l.p->numparams;
+        }
+        break;
+      }
+      case 't': {
+        ar->istailcall = (ci) ? ci->callstatus & CIST_TAIL : 0;
+        break;
+      }
+      case 'n': {
+        /* calling function is a known Lua function? */
+        if (ci && !(ci->callstatus & CIST_TAIL) && isLua(ci->previous))
+          ar->namewhat = getfuncname(L, ci->previous, &ar->name);
+        else
+          ar->namewhat = NULL;
+        if (ar->namewhat == NULL) {
+          ar->namewhat = "";  /* not found */
+          ar->name = NULL;
+        }
+        break;
+      }
+      case 'L':
+      case 'f':  /* handled by lua_getinfo */
+        break;
+      default: status = 0;  /* invalid option */
+    }
+  }
+  return status;
+}
+
+
+LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar) {
+  int status;
+  Closure *cl;
+  CallInfo *ci;
+  StkId func;
+  lua_lock(L);
+  if (*what == '>') {
+    ci = NULL;
+    func = L->top - 1;
+    api_check(L, ttisfunction(func), "function expected");
+    what++;  /* skip the '>' */
+    L->top--;  /* pop function */
+  }
+  else {
+    ci = ar->i_ci;
+    func = ci->func;
+    lua_assert(ttisfunction(ci->func));
+  }
+  cl = ttisclosure(func) ? clvalue(func) : NULL;
+  status = auxgetinfo(L, what, ar, cl, ci);
+  if (strchr(what, 'f')) {
+    setobjs2s(L, L->top, func);
+    api_incr_top(L);
+  }
+  if (strchr(what, 'L'))
+    collectvalidlines(L, cl);
+  lua_unlock(L);
+  return status;
+}
+
+
+/*
+** {======================================================
+** Symbolic Execution
+** =======================================================
+*/
+
+static const char *getobjname (Proto *p, int lastpc, int reg,
+                               const char **name);
+
+
+/*
+** find a "name" for the RK value 'c'
+*/
+static void kname (Proto *p, int pc, int c, const char **name) {
+  if (ISK(c)) {  /* is 'c' a constant? */
+    TValue *kvalue = &p->k[INDEXK(c)];
+    if (ttisstring(kvalue)) {  /* literal constant? */
+      *name = svalue(kvalue);  /* it is its own name */
+      return;
+    }
+    /* else no reasonable name found */
+  }
+  else {  /* 'c' is a register */
+    const char *what = getobjname(p, pc, c, name); /* search for 'c' */
+    if (what && *what == 'c') {  /* found a constant name? */
+      return;  /* 'name' already filled */
+    }
+    /* else no reasonable name found */
+  }
+  *name = "?";  /* no reasonable name found */
+}
+
+
+/*
+** try to find last instruction before 'lastpc' that modified register 'reg'
+*/
+static int findsetreg (Proto *p, int lastpc, int reg) {
+  int pc;
+  int setreg = -1;  /* keep last instruction that changed 'reg' */
+  for (pc = 0; pc < lastpc; pc++) {
+    Instruction i = p->code[pc];
+    OpCode op = GET_OPCODE(i);
+    int a = GETARG_A(i);
+    switch (op) {
+      case OP_LOADNIL: {
+        int b = GETARG_B(i);
+        if (a <= reg && reg <= a + b)  /* set registers from 'a' to 'a+b' */
+          setreg = pc;
+        break;
+      }
+      case OP_TFORCALL: {
+        if (reg >= a + 2) setreg = pc;  /* affect all regs above its base */
+        break;
+      }
+      case OP_CALL:
+      case OP_TAILCALL: {
+        if (reg >= a) setreg = pc;  /* affect all registers above base */
+        break;
+      }
+      case OP_JMP: {
+        int b = GETARG_sBx(i);
+        int dest = pc + 1 + b;
+        /* jump is forward and do not skip `lastpc'? */
+        if (pc < dest && dest <= lastpc)
+          pc += b;  /* do the jump */
+        break;
+      }
+      case OP_TEST: {
+        if (reg == a) setreg = pc;  /* jumped code can change 'a' */
+        break;
+      }
+      default:
+        if (testAMode(op) && reg == a)  /* any instruction that set A */
+          setreg = pc;
+        break;
+    }
+  }
+  return setreg;
+}
+
+
+static const char *getobjname (Proto *p, int lastpc, int reg,
+                               const char **name) {
+  int pc;
+  *name = luaF_getlocalname(p, reg + 1, lastpc);
+  if (*name)  /* is a local? */
+    return "local";
+  /* else try symbolic execution */
+  pc = findsetreg(p, lastpc, reg);
+  if (pc != -1) {  /* could find instruction? */
+    Instruction i = p->code[pc];
+    OpCode op = GET_OPCODE(i);
+    switch (op) {
+      case OP_MOVE: {
+        int b = GETARG_B(i);  /* move from 'b' to 'a' */
+        if (b < GETARG_A(i))
+          return getobjname(p, pc, b, name);  /* get name for 'b' */
+        break;
+      }
+      case OP_GETTABUP:
+      case OP_GETTABLE: {
+        int k = GETARG_C(i);  /* key index */
+        int t = GETARG_B(i);  /* table index */
+        const char *vn = (op == OP_GETTABLE)  /* name of indexed variable */
+                         ? luaF_getlocalname(p, t + 1, pc)
+                         : upvalname(p, t);
+        kname(p, pc, k, name);
+        return (vn && strcmp(vn, LUA_ENV) == 0) ? "global" : "field";
+      }
+      case OP_GETUPVAL: {
+        *name = upvalname(p, GETARG_B(i));
+        return "upvalue";
+      }
+      case OP_LOADK:
+      case OP_LOADKX: {
+        int b = (op == OP_LOADK) ? GETARG_Bx(i)
+                                 : GETARG_Ax(p->code[pc + 1]);
+        if (ttisstring(&p->k[b])) {
+          *name = svalue(&p->k[b]);
+          return "constant";
+        }
+        break;
+      }
+      case OP_SELF: {
+        int k = GETARG_C(i);  /* key index */
+        kname(p, pc, k, name);
+        return "method";
+      }
+      default: break;  /* go through to return NULL */
+    }
+  }
+  return NULL;  /* could not find reasonable name */
+}
+
+
+static const char *getfuncname (lua_State *L, CallInfo *ci, const char **name) {
+  TMS tm;
+  Proto *p = ci_func(ci)->p;  /* calling function */
+  int pc = currentpc(ci);  /* calling instruction index */
+  Instruction i = p->code[pc];  /* calling instruction */
+  switch (GET_OPCODE(i)) {
+    case OP_CALL:
+    case OP_TAILCALL:  /* get function name */
+      return getobjname(p, pc, GETARG_A(i), name);
+    case OP_TFORCALL: {  /* for iterator */
+      *name = "for iterator";
+       return "for iterator";
+    }
+    /* all other instructions can call only through metamethods */
+    case OP_SELF:
+    case OP_GETTABUP:
+    case OP_GETTABLE: tm = TM_INDEX; break;
+    case OP_SETTABUP:
+    case OP_SETTABLE: tm = TM_NEWINDEX; break;
+    case OP_EQ: tm = TM_EQ; break;
+    case OP_ADD: tm = TM_ADD; break;
+    case OP_SUB: tm = TM_SUB; break;
+    case OP_MUL: tm = TM_MUL; break;
+    case OP_DIV: tm = TM_DIV; break;
+    case OP_MOD: tm = TM_MOD; break;
+    case OP_POW: tm = TM_POW; break;
+    case OP_UNM: tm = TM_UNM; break;
+    case OP_LEN: tm = TM_LEN; break;
+    case OP_LT: tm = TM_LT; break;
+    case OP_LE: tm = TM_LE; break;
+    case OP_CONCAT: tm = TM_CONCAT; break;
+    default:
+      return NULL;  /* else no useful name can be found */
+  }
+  *name = getstr(G(L)->tmname[tm]);
+  return "metamethod";
+}
+
+/* }====================================================== */
+
+
+
+/*
+** only ANSI way to check whether a pointer points to an array
+** (used only for error messages, so efficiency is not a big concern)
+*/
+static int isinstack (CallInfo *ci, const TValue *o) {
+  StkId p;
+  for (p = ci->u.l.base; p < ci->top; p++)
+    if (o == p) return 1;
+  return 0;
+}
+
+
+static const char *getupvalname (CallInfo *ci, const TValue *o,
+                                 const char **name) {
+  LClosure *c = ci_func(ci);
+  int i;
+  for (i = 0; i < c->nupvalues; i++) {
+    if (c->upvals[i]->v == o) {
+      *name = upvalname(c->p, i);
+      return "upvalue";
+    }
+  }
+  return NULL;
+}
+
+
+l_noret luaG_typeerror (lua_State *L, const TValue *o, const char *op) {
+  CallInfo *ci = L->ci;
+  const char *name = NULL;
+  const char *t = objtypename(o);
+  const char *kind = NULL;
+  if (isLua(ci)) {
+    kind = getupvalname(ci, o, &name);  /* check whether 'o' is an upvalue */
+    if (!kind && isinstack(ci, o))  /* no? try a register */
+      kind = getobjname(ci_func(ci)->p, currentpc(ci),
+                        cast_int(o - ci->u.l.base), &name);
+  }
+  if (kind)
+    luaG_runerror(L, "attempt to %s %s " LUA_QS " (a %s value)",
+                op, kind, name, t);
+  else
+    luaG_runerror(L, "attempt to %s a %s value", op, t);
+}
+
+
+l_noret luaG_concaterror (lua_State *L, StkId p1, StkId p2) {
+  if (ttisstring(p1) || ttisnumber(p1)) p1 = p2;
+  lua_assert(!ttisstring(p1) && !ttisnumber(p2));
+  luaG_typeerror(L, p1, "concatenate");
+}
+
+
+l_noret luaG_aritherror (lua_State *L, const TValue *p1, const TValue *p2) {
+  TValue temp;
+  if (luaV_tonumber(p1, &temp) == NULL)
+    p2 = p1;  /* first operand is wrong */
+  luaG_typeerror(L, p2, "perform arithmetic on");
+}
+
+
+l_noret luaG_ordererror (lua_State *L, const TValue *p1, const TValue *p2) {
+  const char *t1 = objtypename(p1);
+  const char *t2 = objtypename(p2);
+  if (t1 == t2)
+    luaG_runerror(L, "attempt to compare two %s values", t1);
+  else
+    luaG_runerror(L, "attempt to compare %s with %s", t1, t2);
+}
+
+
+static void addinfo (lua_State *L, const char *msg) {
+  CallInfo *ci = L->ci;
+  if (isLua(ci)) {  /* is Lua code? */
+    char buff[LUA_IDSIZE];  /* add file:line information */
+    int line = currentline(ci);
+    TString *src = ci_func(ci)->p->source;
+    if (src)
+      luaO_chunkid(buff, getstr(src), LUA_IDSIZE);
+    else {  /* no source available; use "?" instead */
+      buff[0] = '?'; buff[1] = '\0';
+    }
+    luaO_pushfstring(L, "%s:%d: %s", buff, line, msg);
+  }
+}
+
+
+l_noret luaG_errormsg (lua_State *L) {
+  if (L->errfunc != 0) {  /* is there an error handling function? */
+    StkId errfunc = restorestack(L, L->errfunc);
+    if (!ttisfunction(errfunc)) luaD_throw(L, LUA_ERRERR);
+    setobjs2s(L, L->top, L->top - 1);  /* move argument */
+    setobjs2s(L, L->top - 1, errfunc);  /* push function */
+    L->top++;
+    luaD_call(L, L->top - 2, 1, 0);  /* call it */
+  }
+  luaD_throw(L, LUA_ERRRUN);
+}
+
+
+l_noret luaG_runerror (lua_State *L, const char *fmt, ...) {
+  va_list argp;
+  va_start(argp, fmt);
+  addinfo(L, luaO_pushvfstring(L, fmt, argp));
+  va_end(argp);
+  luaG_errormsg(L);
+}
+
diff -ruNp src.orig/libs/lua/ldebug.h src/libs/lua/ldebug.h
--- src.orig/libs/lua/ldebug.h	1969-12-31 18:00:00 -0600
+++ src/libs/lua/ldebug.h	2017-11-21 19:39:46 -0600
@@ -0,0 +1,34 @@
+/*
+** $Id: ldebug.h,v 2.7 2011/10/07 20:45:19 roberto Exp $
+** Auxiliary functions from Debug Interface module
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ldebug_h
+#define ldebug_h
+
+
+#include "lstate.h"
+
+
+#define pcRel(pc, p)	(cast(int, (pc) - (p)->code) - 1)
+
+#define getfuncline(f,pc)	(((f)->lineinfo) ? (f)->lineinfo[pc] : 0)
+
+#define resethookcount(L)	(L->hookcount = L->basehookcount)
+
+/* Active Lua function (given call info) */
+#define ci_func(ci)		(clLvalue((ci)->func))
+
+
+LUAI_FUNC l_noret luaG_typeerror (lua_State *L, const TValue *o,
+                                                const char *opname);
+LUAI_FUNC l_noret luaG_concaterror (lua_State *L, StkId p1, StkId p2);
+LUAI_FUNC l_noret luaG_aritherror (lua_State *L, const TValue *p1,
+                                                 const TValue *p2);
+LUAI_FUNC l_noret luaG_ordererror (lua_State *L, const TValue *p1,
+                                                 const TValue *p2);
+LUAI_FUNC l_noret luaG_runerror (lua_State *L, const char *fmt, ...);
+LUAI_FUNC l_noret luaG_errormsg (lua_State *L);
+
+#endif
diff -ruNp src.orig/libs/lua/ldo.c src/libs/lua/ldo.c
--- src.orig/libs/lua/ldo.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/ldo.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,673 @@
+/*
+** $Id: ldo.c,v 2.108 2012/10/01 14:05:04 roberto Exp $
+** Stack and Call structure of Lua
+** See Copyright Notice in lua.h
+*/
+
+
+#include <setjmp.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define ldo_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lapi.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lparser.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+#include "lundump.h"
+#include "lvm.h"
+#include "lzio.h"
+
+
+
+
+/*
+** {======================================================
+** Error-recovery functions
+** =======================================================
+*/
+
+/*
+** LUAI_THROW/LUAI_TRY define how Lua does exception handling. By
+** default, Lua handles errors with exceptions when compiling as
+** C++ code, with _longjmp/_setjmp when asked to use them, and with
+** longjmp/setjmp otherwise.
+*/
+#if !defined(LUAI_THROW)
+
+#if defined(__cplusplus) && !defined(LUA_USE_LONGJMP)
+/* C++ exceptions */
+#define LUAI_THROW(L,c)		throw(c)
+#define LUAI_TRY(L,c,a) \
+	try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }
+#define luai_jmpbuf		int  /* dummy variable */
+
+#elif defined(LUA_USE_ULONGJMP)
+/* in Unix, try _longjmp/_setjmp (more efficient) */
+#define LUAI_THROW(L,c)		_longjmp((c)->b, 1)
+#define LUAI_TRY(L,c,a)		if (_setjmp((c)->b) == 0) { a }
+#define luai_jmpbuf		jmp_buf
+
+#else
+/* default handling with long jumps */
+#define LUAI_THROW(L,c)		longjmp((c)->b, 1)
+#define LUAI_TRY(L,c,a)		if (setjmp((c)->b) == 0) { a }
+#define luai_jmpbuf		jmp_buf
+
+#endif
+
+#endif
+
+
+
+/* chain list of long jump buffers */
+struct lua_longjmp {
+  struct lua_longjmp *previous;
+  luai_jmpbuf b;
+  volatile int status;  /* error code */
+};
+
+
+static void seterrorobj (lua_State *L, int errcode, StkId oldtop) {
+  switch (errcode) {
+    case LUA_ERRMEM: {  /* memory error? */
+      setsvalue2s(L, oldtop, G(L)->memerrmsg); /* reuse preregistered msg. */
+      break;
+    }
+    case LUA_ERRERR: {
+      setsvalue2s(L, oldtop, luaS_newliteral(L, "error in error handling"));
+      break;
+    }
+    default: {
+      setobjs2s(L, oldtop, L->top - 1);  /* error message on current top */
+      break;
+    }
+  }
+  L->top = oldtop + 1;
+}
+
+
+l_noret luaD_throw (lua_State *L, int errcode) {
+  if (L->errorJmp) {  /* thread has an error handler? */
+    L->errorJmp->status = errcode;  /* set status */
+    LUAI_THROW(L, L->errorJmp);  /* jump to it */
+  }
+  else {  /* thread has no error handler */
+    L->status = cast_byte(errcode);  /* mark it as dead */
+    if (G(L)->mainthread->errorJmp) {  /* main thread has a handler? */
+      setobjs2s(L, G(L)->mainthread->top++, L->top - 1);  /* copy error obj. */
+      luaD_throw(G(L)->mainthread, errcode);  /* re-throw in main thread */
+    }
+    else {  /* no handler at all; abort */
+      if (G(L)->panic) {  /* panic function? */
+        lua_unlock(L);
+        G(L)->panic(L);  /* call it (last chance to jump out) */
+      }
+      abort();
+    }
+  }
+}
+
+
+int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {
+  unsigned short oldnCcalls = L->nCcalls;
+  struct lua_longjmp lj;
+  lj.status = LUA_OK;
+  lj.previous = L->errorJmp;  /* chain new error handler */
+  L->errorJmp = &lj;
+  LUAI_TRY(L, &lj,
+    (*f)(L, ud);
+  );
+  L->errorJmp = lj.previous;  /* restore old error handler */
+  L->nCcalls = oldnCcalls;
+  return lj.status;
+}
+
+/* }====================================================== */
+
+
+static void correctstack (lua_State *L, TValue *oldstack) {
+  CallInfo *ci;
+  GCObject *up;
+  L->top = (L->top - oldstack) + L->stack;
+  for (up = L->openupval; up != NULL; up = up->gch.next)
+    gco2uv(up)->v = (gco2uv(up)->v - oldstack) + L->stack;
+  for (ci = L->ci; ci != NULL; ci = ci->previous) {
+    ci->top = (ci->top - oldstack) + L->stack;
+    ci->func = (ci->func - oldstack) + L->stack;
+    if (isLua(ci))
+      ci->u.l.base = (ci->u.l.base - oldstack) + L->stack;
+  }
+}
+
+
+/* some space for error handling */
+#define ERRORSTACKSIZE	(LUAI_MAXSTACK + 200)
+
+
+void luaD_reallocstack (lua_State *L, int newsize) {
+  TValue *oldstack = L->stack;
+  int lim = L->stacksize;
+  lua_assert(newsize <= LUAI_MAXSTACK || newsize == ERRORSTACKSIZE);
+  lua_assert(L->stack_last - L->stack == L->stacksize - EXTRA_STACK);
+  luaM_reallocvector(L, L->stack, L->stacksize, newsize, TValue);
+  for (; lim < newsize; lim++)
+    setnilvalue(L->stack + lim); /* erase new segment */
+  L->stacksize = newsize;
+  L->stack_last = L->stack + newsize - EXTRA_STACK;
+  correctstack(L, oldstack);
+}
+
+
+void luaD_growstack (lua_State *L, int n) {
+  int size = L->stacksize;
+  if (size > LUAI_MAXSTACK)  /* error after extra size? */
+    luaD_throw(L, LUA_ERRERR);
+  else {
+    int needed = cast_int(L->top - L->stack) + n + EXTRA_STACK;
+    int newsize = 2 * size;
+    if (newsize > LUAI_MAXSTACK) newsize = LUAI_MAXSTACK;
+    if (newsize < needed) newsize = needed;
+    if (newsize > LUAI_MAXSTACK) {  /* stack overflow? */
+      luaD_reallocstack(L, ERRORSTACKSIZE);
+      luaG_runerror(L, "stack overflow");
+    }
+    else
+      luaD_reallocstack(L, newsize);
+  }
+}
+
+
+static int stackinuse (lua_State *L) {
+  CallInfo *ci;
+  StkId lim = L->top;
+  for (ci = L->ci; ci != NULL; ci = ci->previous) {
+    lua_assert(ci->top <= L->stack_last);
+    if (lim < ci->top) lim = ci->top;
+  }
+  return cast_int(lim - L->stack) + 1;  /* part of stack in use */
+}
+
+
+void luaD_shrinkstack (lua_State *L) {
+  int inuse = stackinuse(L);
+  int goodsize = inuse + (inuse / 8) + 2*EXTRA_STACK;
+  if (goodsize > LUAI_MAXSTACK) goodsize = LUAI_MAXSTACK;
+  if (inuse > LUAI_MAXSTACK ||  /* handling stack overflow? */
+      goodsize >= L->stacksize)  /* would grow instead of shrink? */
+    condmovestack(L);  /* don't change stack (change only for debugging) */
+  else
+    luaD_reallocstack(L, goodsize);  /* shrink it */
+}
+
+
+void luaD_hook (lua_State *L, int event, int line) {
+  lua_Hook hook = L->hook;
+  if (hook && L->allowhook) {
+    CallInfo *ci = L->ci;
+    ptrdiff_t top = savestack(L, L->top);
+    ptrdiff_t ci_top = savestack(L, ci->top);
+    lua_Debug ar;
+    ar.event = event;
+    ar.currentline = line;
+    ar.i_ci = ci;
+    luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */
+    ci->top = L->top + LUA_MINSTACK;
+    lua_assert(ci->top <= L->stack_last);
+    L->allowhook = 0;  /* cannot call hooks inside a hook */
+    ci->callstatus |= CIST_HOOKED;
+    lua_unlock(L);
+    (*hook)(L, &ar);
+    lua_lock(L);
+    lua_assert(!L->allowhook);
+    L->allowhook = 1;
+    ci->top = restorestack(L, ci_top);
+    L->top = restorestack(L, top);
+    ci->callstatus &= ~CIST_HOOKED;
+  }
+}
+
+
+static void callhook (lua_State *L, CallInfo *ci) {
+  int hook = LUA_HOOKCALL;
+  ci->u.l.savedpc++;  /* hooks assume 'pc' is already incremented */
+  if (isLua(ci->previous) &&
+      GET_OPCODE(*(ci->previous->u.l.savedpc - 1)) == OP_TAILCALL) {
+    ci->callstatus |= CIST_TAIL;
+    hook = LUA_HOOKTAILCALL;
+  }
+  luaD_hook(L, hook, -1);
+  ci->u.l.savedpc--;  /* correct 'pc' */
+}
+
+
+static StkId adjust_varargs (lua_State *L, Proto *p, int actual) {
+  int i;
+  int nfixargs = p->numparams;
+  StkId base, fixed;
+  lua_assert(actual >= nfixargs);
+  /* move fixed parameters to final position */
+  fixed = L->top - actual;  /* first fixed argument */
+  base = L->top;  /* final position of first argument */
+  for (i=0; i<nfixargs; i++) {
+    setobjs2s(L, L->top++, fixed + i);
+    setnilvalue(fixed + i);
+  }
+  return base;
+}
+
+
+static StkId tryfuncTM (lua_State *L, StkId func) {
+  const TValue *tm = luaT_gettmbyobj(L, func, TM_CALL);
+  StkId p;
+  ptrdiff_t funcr = savestack(L, func);
+  if (!ttisfunction(tm))
+    luaG_typeerror(L, func, "call");
+  /* Open a hole inside the stack at `func' */
+  for (p = L->top; p > func; p--) setobjs2s(L, p, p-1);
+  incr_top(L);
+  func = restorestack(L, funcr);  /* previous call may change stack */
+  setobj2s(L, func, tm);  /* tag method is the new function to be called */
+  return func;
+}
+
+
+
+#define next_ci(L) (L->ci = (L->ci->next ? L->ci->next : luaE_extendCI(L)))
+
+
+/*
+** returns true if function has been executed (C function)
+*/
+int luaD_precall (lua_State *L, StkId func, int nresults) {
+  lua_CFunction f;
+  CallInfo *ci;
+  int n;  /* number of arguments (Lua) or returns (C) */
+  ptrdiff_t funcr = savestack(L, func);
+  switch (ttype(func)) {
+    case LUA_TLCF:  /* light C function */
+      f = fvalue(func);
+      goto Cfunc;
+    case LUA_TCCL: {  /* C closure */
+      f = clCvalue(func)->f;
+     Cfunc:
+      luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */
+      ci = next_ci(L);  /* now 'enter' new function */
+      ci->nresults = nresults;
+      ci->func = restorestack(L, funcr);
+      ci->top = L->top + LUA_MINSTACK;
+      lua_assert(ci->top <= L->stack_last);
+      ci->callstatus = 0;
+      luaC_checkGC(L);  /* stack grow uses memory */
+      if (L->hookmask & LUA_MASKCALL)
+        luaD_hook(L, LUA_HOOKCALL, -1);
+      lua_unlock(L);
+      n = (*f)(L);  /* do the actual call */
+      lua_lock(L);
+      api_checknelems(L, n);
+      luaD_poscall(L, L->top - n);
+      return 1;
+    }
+    case LUA_TLCL: {  /* Lua function: prepare its call */
+      StkId base;
+      Proto *p = clLvalue(func)->p;
+      luaD_checkstack(L, p->maxstacksize);
+      func = restorestack(L, funcr);
+      n = cast_int(L->top - func) - 1;  /* number of real arguments */
+      for (; n < p->numparams; n++)
+        setnilvalue(L->top++);  /* complete missing arguments */
+      base = (!p->is_vararg) ? func + 1 : adjust_varargs(L, p, n);
+      ci = next_ci(L);  /* now 'enter' new function */
+      ci->nresults = nresults;
+      ci->func = func;
+      ci->u.l.base = base;
+      ci->top = base + p->maxstacksize;
+      lua_assert(ci->top <= L->stack_last);
+      ci->u.l.savedpc = p->code;  /* starting point */
+      ci->callstatus = CIST_LUA;
+      L->top = ci->top;
+      luaC_checkGC(L);  /* stack grow uses memory */
+      if (L->hookmask & LUA_MASKCALL)
+        callhook(L, ci);
+      return 0;
+    }
+    default: {  /* not a function */
+      func = tryfuncTM(L, func);  /* retry with 'function' tag method */
+      return luaD_precall(L, func, nresults);  /* now it must be a function */
+    }
+  }
+}
+
+
+int luaD_poscall (lua_State *L, StkId firstResult) {
+  StkId res;
+  int wanted, i;
+  CallInfo *ci = L->ci;
+  if (L->hookmask & (LUA_MASKRET | LUA_MASKLINE)) {
+    if (L->hookmask & LUA_MASKRET) {
+      ptrdiff_t fr = savestack(L, firstResult);  /* hook may change stack */
+      luaD_hook(L, LUA_HOOKRET, -1);
+      firstResult = restorestack(L, fr);
+    }
+    L->oldpc = ci->previous->u.l.savedpc;  /* 'oldpc' for caller function */
+  }
+  res = ci->func;  /* res == final position of 1st result */
+  wanted = ci->nresults;
+  L->ci = ci = ci->previous;  /* back to caller */
+  /* move results to correct place */
+  for (i = wanted; i != 0 && firstResult < L->top; i--)
+    setobjs2s(L, res++, firstResult++);
+  while (i-- > 0)
+    setnilvalue(res++);
+  L->top = res;
+  return (wanted - LUA_MULTRET);  /* 0 iff wanted == LUA_MULTRET */
+}
+
+
+/*
+** Call a function (C or Lua). The function to be called is at *func.
+** The arguments are on the stack, right after the function.
+** When returns, all the results are on the stack, starting at the original
+** function position.
+*/
+void luaD_call (lua_State *L, StkId func, int nResults, int allowyield) {
+  if (++L->nCcalls >= LUAI_MAXCCALLS) {
+    if (L->nCcalls == LUAI_MAXCCALLS)
+      luaG_runerror(L, "C stack overflow");
+    else if (L->nCcalls >= (LUAI_MAXCCALLS + (LUAI_MAXCCALLS>>3)))
+      luaD_throw(L, LUA_ERRERR);  /* error while handing stack error */
+  }
+  if (!allowyield) L->nny++;
+  if (!luaD_precall(L, func, nResults))  /* is a Lua function? */
+    luaV_execute(L);  /* call it */
+  if (!allowyield) L->nny--;
+  L->nCcalls--;
+}
+
+
+static void finishCcall (lua_State *L) {
+  CallInfo *ci = L->ci;
+  int n;
+  lua_assert(ci->u.c.k != NULL);  /* must have a continuation */
+  lua_assert(L->nny == 0);
+  if (ci->callstatus & CIST_YPCALL) {  /* was inside a pcall? */
+    ci->callstatus &= ~CIST_YPCALL;  /* finish 'lua_pcall' */
+    L->errfunc = ci->u.c.old_errfunc;
+  }
+  /* finish 'lua_callk'/'lua_pcall' */
+  adjustresults(L, ci->nresults);
+  /* call continuation function */
+  if (!(ci->callstatus & CIST_STAT))  /* no call status? */
+    ci->u.c.status = LUA_YIELD;  /* 'default' status */
+  lua_assert(ci->u.c.status != LUA_OK);
+  ci->callstatus = (ci->callstatus & ~(CIST_YPCALL | CIST_STAT)) | CIST_YIELDED;
+  lua_unlock(L);
+  n = (*ci->u.c.k)(L);
+  lua_lock(L);
+  api_checknelems(L, n);
+  /* finish 'luaD_precall' */
+  luaD_poscall(L, L->top - n);
+}
+
+
+static void unroll (lua_State *L, void *ud) {
+  UNUSED(ud);
+  for (;;) {
+    if (L->ci == &L->base_ci)  /* stack is empty? */
+      return;  /* coroutine finished normally */
+    if (!isLua(L->ci))  /* C function? */
+      finishCcall(L);
+    else {  /* Lua function */
+      luaV_finishOp(L);  /* finish interrupted instruction */
+      luaV_execute(L);  /* execute down to higher C 'boundary' */
+    }
+  }
+}
+
+
+/*
+** check whether thread has a suspended protected call
+*/
+static CallInfo *findpcall (lua_State *L) {
+  CallInfo *ci;
+  for (ci = L->ci; ci != NULL; ci = ci->previous) {  /* search for a pcall */
+    if (ci->callstatus & CIST_YPCALL)
+      return ci;
+  }
+  return NULL;  /* no pending pcall */
+}
+
+
+static int recover (lua_State *L, int status) {
+  StkId oldtop;
+  CallInfo *ci = findpcall(L);
+  if (ci == NULL) return 0;  /* no recovery point */
+  /* "finish" luaD_pcall */
+  oldtop = restorestack(L, ci->extra);
+  luaF_close(L, oldtop);
+  seterrorobj(L, status, oldtop);
+  L->ci = ci;
+  L->allowhook = ci->u.c.old_allowhook;
+  L->nny = 0;  /* should be zero to be yieldable */
+  luaD_shrinkstack(L);
+  L->errfunc = ci->u.c.old_errfunc;
+  ci->callstatus |= CIST_STAT;  /* call has error status */
+  ci->u.c.status = status;  /* (here it is) */
+  return 1;  /* continue running the coroutine */
+}
+
+
+/*
+** signal an error in the call to 'resume', not in the execution of the
+** coroutine itself. (Such errors should not be handled by any coroutine
+** error handler and should not kill the coroutine.)
+*/
+static l_noret resume_error (lua_State *L, const char *msg, StkId firstArg) {
+  L->top = firstArg;  /* remove args from the stack */
+  setsvalue2s(L, L->top, luaS_new(L, msg));  /* push error message */
+  api_incr_top(L);
+  luaD_throw(L, -1);  /* jump back to 'lua_resume' */
+}
+
+
+/*
+** do the work for 'lua_resume' in protected mode
+*/
+static void resume (lua_State *L, void *ud) {
+  int nCcalls = L->nCcalls;
+  StkId firstArg = cast(StkId, ud);
+  CallInfo *ci = L->ci;
+  if (nCcalls >= LUAI_MAXCCALLS)
+    resume_error(L, "C stack overflow", firstArg);
+  if (L->status == LUA_OK) {  /* may be starting a coroutine */
+    if (ci != &L->base_ci)  /* not in base level? */
+      resume_error(L, "cannot resume non-suspended coroutine", firstArg);
+    /* coroutine is in base level; start running it */
+    if (!luaD_precall(L, firstArg - 1, LUA_MULTRET))  /* Lua function? */
+      luaV_execute(L);  /* call it */
+  }
+  else if (L->status != LUA_YIELD)
+    resume_error(L, "cannot resume dead coroutine", firstArg);
+  else {  /* resuming from previous yield */
+    L->status = LUA_OK;
+    ci->func = restorestack(L, ci->extra);
+    if (isLua(ci))  /* yielded inside a hook? */
+      luaV_execute(L);  /* just continue running Lua code */
+    else {  /* 'common' yield */
+      if (ci->u.c.k != NULL) {  /* does it have a continuation? */
+        int n;
+        ci->u.c.status = LUA_YIELD;  /* 'default' status */
+        ci->callstatus |= CIST_YIELDED;
+        lua_unlock(L);
+        n = (*ci->u.c.k)(L);  /* call continuation */
+        lua_lock(L);
+        api_checknelems(L, n);
+        firstArg = L->top - n;  /* yield results come from continuation */
+      }
+      luaD_poscall(L, firstArg);  /* finish 'luaD_precall' */
+    }
+    unroll(L, NULL);
+  }
+  lua_assert(nCcalls == L->nCcalls);
+}
+
+
+LUA_API int lua_resume (lua_State *L, lua_State *from, int nargs) {
+  int status;
+  lua_lock(L);
+  luai_userstateresume(L, nargs);
+  L->nCcalls = (from) ? from->nCcalls + 1 : 1;
+  L->nny = 0;  /* allow yields */
+  api_checknelems(L, (L->status == LUA_OK) ? nargs + 1 : nargs);
+  status = luaD_rawrunprotected(L, resume, L->top - nargs);
+  if (status == -1)  /* error calling 'lua_resume'? */
+    status = LUA_ERRRUN;
+  else {  /* yield or regular error */
+    while (status != LUA_OK && status != LUA_YIELD) {  /* error? */
+      if (recover(L, status))  /* recover point? */
+        status = luaD_rawrunprotected(L, unroll, NULL);  /* run continuation */
+      else {  /* unrecoverable error */
+        L->status = cast_byte(status);  /* mark thread as `dead' */
+        seterrorobj(L, status, L->top);
+        L->ci->top = L->top;
+        break;
+      }
+    }
+    lua_assert(status == L->status);
+  }
+  L->nny = 1;  /* do not allow yields */
+  L->nCcalls--;
+  lua_assert(L->nCcalls == ((from) ? from->nCcalls : 0));
+  lua_unlock(L);
+  return status;
+}
+
+
+LUA_API int lua_yieldk (lua_State *L, int nresults, int ctx, lua_CFunction k) {
+  CallInfo *ci = L->ci;
+  luai_userstateyield(L, nresults);
+  lua_lock(L);
+  api_checknelems(L, nresults);
+  if (L->nny > 0) {
+    if (L != G(L)->mainthread)
+      luaG_runerror(L, "attempt to yield across a C-call boundary");
+    else
+      luaG_runerror(L, "attempt to yield from outside a coroutine");
+  }
+  L->status = LUA_YIELD;
+  ci->extra = savestack(L, ci->func);  /* save current 'func' */
+  if (isLua(ci)) {  /* inside a hook? */
+    api_check(L, k == NULL, "hooks cannot continue after yielding");
+  }
+  else {
+    if ((ci->u.c.k = k) != NULL)  /* is there a continuation? */
+      ci->u.c.ctx = ctx;  /* save context */
+    ci->func = L->top - nresults - 1;  /* protect stack below results */
+    luaD_throw(L, LUA_YIELD);
+  }
+  lua_assert(ci->callstatus & CIST_HOOKED);  /* must be inside a hook */
+  lua_unlock(L);
+  return 0;  /* return to 'luaD_hook' */
+}
+
+
+int luaD_pcall (lua_State *L, Pfunc func, void *u,
+                ptrdiff_t old_top, ptrdiff_t ef) {
+  int status;
+  CallInfo *old_ci = L->ci;
+  lu_byte old_allowhooks = L->allowhook;
+  unsigned short old_nny = L->nny;
+  ptrdiff_t old_errfunc = L->errfunc;
+  L->errfunc = ef;
+  status = luaD_rawrunprotected(L, func, u);
+  if (status != LUA_OK) {  /* an error occurred? */
+    StkId oldtop = restorestack(L, old_top);
+    luaF_close(L, oldtop);  /* close possible pending closures */
+    seterrorobj(L, status, oldtop);
+    L->ci = old_ci;
+    L->allowhook = old_allowhooks;
+    L->nny = old_nny;
+    luaD_shrinkstack(L);
+  }
+  L->errfunc = old_errfunc;
+  return status;
+}
+
+
+
+/*
+** Execute a protected parser.
+*/
+struct SParser {  /* data to `f_parser' */
+  ZIO *z;
+  Mbuffer buff;  /* dynamic structure used by the scanner */
+  Dyndata dyd;  /* dynamic structures used by the parser */
+  const char *mode;
+  const char *name;
+};
+
+
+static void checkmode (lua_State *L, const char *mode, const char *x) {
+  if (mode && strchr(mode, x[0]) == NULL) {
+    luaO_pushfstring(L,
+       "attempt to load a %s chunk (mode is " LUA_QS ")", x, mode);
+    luaD_throw(L, LUA_ERRSYNTAX);
+  }
+}
+
+
+static void f_parser (lua_State *L, void *ud) {
+  int i;
+  Closure *cl;
+  struct SParser *p = cast(struct SParser *, ud);
+  int c = zgetc(p->z);  /* read first character */
+  if (c == LUA_SIGNATURE[0]) {
+    checkmode(L, p->mode, "binary");
+    cl = luaU_undump(L, p->z, &p->buff, p->name);
+  }
+  else {
+    checkmode(L, p->mode, "text");
+    cl = luaY_parser(L, p->z, &p->buff, &p->dyd, p->name, c);
+  }
+  lua_assert(cl->l.nupvalues == cl->l.p->sizeupvalues);
+  for (i = 0; i < cl->l.nupvalues; i++) {  /* initialize upvalues */
+    UpVal *up = luaF_newupval(L);
+    cl->l.upvals[i] = up;
+    luaC_objbarrier(L, cl, up);
+  }
+}
+
+
+int luaD_protectedparser (lua_State *L, ZIO *z, const char *name,
+                                        const char *mode) {
+  struct SParser p;
+  int status;
+  L->nny++;  /* cannot yield during parsing */
+  p.z = z; p.name = name; p.mode = mode;
+  p.dyd.actvar.arr = NULL; p.dyd.actvar.size = 0;
+  p.dyd.gt.arr = NULL; p.dyd.gt.size = 0;
+  p.dyd.label.arr = NULL; p.dyd.label.size = 0;
+  luaZ_initbuffer(L, &p.buff);
+  status = luaD_pcall(L, f_parser, &p, savestack(L, L->top), L->errfunc);
+  luaZ_freebuffer(L, &p.buff);
+  luaM_freearray(L, p.dyd.actvar.arr, p.dyd.actvar.size);
+  luaM_freearray(L, p.dyd.gt.arr, p.dyd.gt.size);
+  luaM_freearray(L, p.dyd.label.arr, p.dyd.label.size);
+  L->nny--;
+  return status;
+}
+
+
diff -ruNp src.orig/libs/lua/ldo.h src/libs/lua/ldo.h
--- src.orig/libs/lua/ldo.h	1969-12-31 18:00:00 -0600
+++ src/libs/lua/ldo.h	2017-11-21 19:39:46 -0600
@@ -0,0 +1,46 @@
+/*
+** $Id: ldo.h,v 2.20 2011/11/29 15:55:08 roberto Exp $
+** Stack and Call structure of Lua
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ldo_h
+#define ldo_h
+
+
+#include "lobject.h"
+#include "lstate.h"
+#include "lzio.h"
+
+
+#define luaD_checkstack(L,n)	if (L->stack_last - L->top <= (n)) \
+				    luaD_growstack(L, n); else condmovestack(L);
+
+
+#define incr_top(L) {L->top++; luaD_checkstack(L,0);}
+
+#define savestack(L,p)		((char *)(p) - (char *)L->stack)
+#define restorestack(L,n)	((TValue *)((char *)L->stack + (n)))
+
+
+/* type of protected functions, to be ran by `runprotected' */
+typedef void (*Pfunc) (lua_State *L, void *ud);
+
+LUAI_FUNC int luaD_protectedparser (lua_State *L, ZIO *z, const char *name,
+                                                  const char *mode);
+LUAI_FUNC void luaD_hook (lua_State *L, int event, int line);
+LUAI_FUNC int luaD_precall (lua_State *L, StkId func, int nresults);
+LUAI_FUNC void luaD_call (lua_State *L, StkId func, int nResults,
+                                        int allowyield);
+LUAI_FUNC int luaD_pcall (lua_State *L, Pfunc func, void *u,
+                                        ptrdiff_t oldtop, ptrdiff_t ef);
+LUAI_FUNC int luaD_poscall (lua_State *L, StkId firstResult);
+LUAI_FUNC void luaD_reallocstack (lua_State *L, int newsize);
+LUAI_FUNC void luaD_growstack (lua_State *L, int n);
+LUAI_FUNC void luaD_shrinkstack (lua_State *L);
+
+LUAI_FUNC l_noret luaD_throw (lua_State *L, int errcode);
+LUAI_FUNC int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud);
+
+#endif
+
diff -ruNp src.orig/libs/lua/ldump.c src/libs/lua/ldump.c
--- src.orig/libs/lua/ldump.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/ldump.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,173 @@
+/*
+** $Id: ldump.c,v 2.17 2012/01/23 23:02:10 roberto Exp $
+** save precompiled Lua chunks
+** See Copyright Notice in lua.h
+*/
+
+#include <stddef.h>
+
+#define ldump_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lobject.h"
+#include "lstate.h"
+#include "lundump.h"
+
+typedef struct {
+ lua_State* L;
+ lua_Writer writer;
+ void* data;
+ int strip;
+ int status;
+} DumpState;
+
+#define DumpMem(b,n,size,D)	DumpBlock(b,(n)*(size),D)
+#define DumpVar(x,D)		DumpMem(&x,1,sizeof(x),D)
+
+static void DumpBlock(const void* b, size_t size, DumpState* D)
+{
+ if (D->status==0)
+ {
+  lua_unlock(D->L);
+  D->status=(*D->writer)(D->L,b,size,D->data);
+  lua_lock(D->L);
+ }
+}
+
+static void DumpChar(int y, DumpState* D)
+{
+ char x=(char)y;
+ DumpVar(x,D);
+}
+
+static void DumpInt(int x, DumpState* D)
+{
+ DumpVar(x,D);
+}
+
+static void DumpNumber(lua_Number x, DumpState* D)
+{
+ DumpVar(x,D);
+}
+
+static void DumpVector(const void* b, int n, size_t size, DumpState* D)
+{
+ DumpInt(n,D);
+ DumpMem(b,n,size,D);
+}
+
+static void DumpString(const TString* s, DumpState* D)
+{
+ if (s==NULL)
+ {
+  size_t size=0;
+  DumpVar(size,D);
+ }
+ else
+ {
+  size_t size=s->tsv.len+1;		/* include trailing '\0' */
+  DumpVar(size,D);
+  DumpBlock(getstr(s),size*sizeof(char),D);
+ }
+}
+
+#define DumpCode(f,D)	 DumpVector(f->code,f->sizecode,sizeof(Instruction),D)
+
+static void DumpFunction(const Proto* f, DumpState* D);
+
+static void DumpConstants(const Proto* f, DumpState* D)
+{
+ int i,n=f->sizek;
+ DumpInt(n,D);
+ for (i=0; i<n; i++)
+ {
+  const TValue* o=&f->k[i];
+  DumpChar(ttypenv(o),D);
+  switch (ttypenv(o))
+  {
+   case LUA_TNIL:
+	break;
+   case LUA_TBOOLEAN:
+	DumpChar(bvalue(o),D);
+	break;
+   case LUA_TNUMBER:
+	DumpNumber(nvalue(o),D);
+	break;
+   case LUA_TSTRING:
+	DumpString(rawtsvalue(o),D);
+	break;
+    default: lua_assert(0);
+  }
+ }
+ n=f->sizep;
+ DumpInt(n,D);
+ for (i=0; i<n; i++) DumpFunction(f->p[i],D);
+}
+
+static void DumpUpvalues(const Proto* f, DumpState* D)
+{
+ int i,n=f->sizeupvalues;
+ DumpInt(n,D);
+ for (i=0; i<n; i++)
+ {
+  DumpChar(f->upvalues[i].instack,D);
+  DumpChar(f->upvalues[i].idx,D);
+ }
+}
+
+static void DumpDebug(const Proto* f, DumpState* D)
+{
+ int i,n;
+ DumpString((D->strip) ? NULL : f->source,D);
+ n= (D->strip) ? 0 : f->sizelineinfo;
+ DumpVector(f->lineinfo,n,sizeof(int),D);
+ n= (D->strip) ? 0 : f->sizelocvars;
+ DumpInt(n,D);
+ for (i=0; i<n; i++)
+ {
+  DumpString(f->locvars[i].varname,D);
+  DumpInt(f->locvars[i].startpc,D);
+  DumpInt(f->locvars[i].endpc,D);
+ }
+ n= (D->strip) ? 0 : f->sizeupvalues;
+ DumpInt(n,D);
+ for (i=0; i<n; i++) DumpString(f->upvalues[i].name,D);
+}
+
+static void DumpFunction(const Proto* f, DumpState* D)
+{
+ DumpInt(f->linedefined,D);
+ DumpInt(f->lastlinedefined,D);
+ DumpChar(f->numparams,D);
+ DumpChar(f->is_vararg,D);
+ DumpChar(f->maxstacksize,D);
+ DumpCode(f,D);
+ DumpConstants(f,D);
+ DumpUpvalues(f,D);
+ DumpDebug(f,D);
+}
+
+static void DumpHeader(DumpState* D)
+{
+ lu_byte h[LUAC_HEADERSIZE];
+ luaU_header(h);
+ DumpBlock(h,LUAC_HEADERSIZE,D);
+}
+
+/*
+** dump Lua function as precompiled chunk
+*/
+int luaU_dump (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip)
+{
+ DumpState D;
+ D.L=L;
+ D.writer=w;
+ D.data=data;
+ D.strip=strip;
+ D.status=0;
+ DumpHeader(&D);
+ DumpFunction(f,&D);
+ return D.status;
+}
diff -ruNp src.orig/libs/lua/lfunc.c src/libs/lua/lfunc.c
--- src.orig/libs/lua/lfunc.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lfunc.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,161 @@
+/*
+** $Id: lfunc.c,v 2.30 2012/10/03 12:36:46 roberto Exp $
+** Auxiliary functions to manipulate prototypes and closures
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stddef.h>
+
+#define lfunc_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lfunc.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+
+
+
+Closure *luaF_newCclosure (lua_State *L, int n) {
+  Closure *c = &luaC_newobj(L, LUA_TCCL, sizeCclosure(n), NULL, 0)->cl;
+  c->c.nupvalues = cast_byte(n);
+  return c;
+}
+
+
+Closure *luaF_newLclosure (lua_State *L, int n) {
+  Closure *c = &luaC_newobj(L, LUA_TLCL, sizeLclosure(n), NULL, 0)->cl;
+  c->l.p = NULL;
+  c->l.nupvalues = cast_byte(n);
+  while (n--) c->l.upvals[n] = NULL;
+  return c;
+}
+
+
+UpVal *luaF_newupval (lua_State *L) {
+  UpVal *uv = &luaC_newobj(L, LUA_TUPVAL, sizeof(UpVal), NULL, 0)->uv;
+  uv->v = &uv->u.value;
+  setnilvalue(uv->v);
+  return uv;
+}
+
+
+UpVal *luaF_findupval (lua_State *L, StkId level) {
+  global_State *g = G(L);
+  GCObject **pp = &L->openupval;
+  UpVal *p;
+  UpVal *uv;
+  while (*pp != NULL && (p = gco2uv(*pp))->v >= level) {
+    GCObject *o = obj2gco(p);
+    lua_assert(p->v != &p->u.value);
+    lua_assert(!isold(o) || isold(obj2gco(L)));
+    if (p->v == level) {  /* found a corresponding upvalue? */
+      if (isdead(g, o))  /* is it dead? */
+        changewhite(o);  /* resurrect it */
+      return p;
+    }
+    pp = &p->next;
+  }
+  /* not found: create a new one */
+  uv = &luaC_newobj(L, LUA_TUPVAL, sizeof(UpVal), pp, 0)->uv;
+  uv->v = level;  /* current value lives in the stack */
+  uv->u.l.prev = &g->uvhead;  /* double link it in `uvhead' list */
+  uv->u.l.next = g->uvhead.u.l.next;
+  uv->u.l.next->u.l.prev = uv;
+  g->uvhead.u.l.next = uv;
+  lua_assert(uv->u.l.next->u.l.prev == uv && uv->u.l.prev->u.l.next == uv);
+  return uv;
+}
+
+
+static void unlinkupval (UpVal *uv) {
+  lua_assert(uv->u.l.next->u.l.prev == uv && uv->u.l.prev->u.l.next == uv);
+  uv->u.l.next->u.l.prev = uv->u.l.prev;  /* remove from `uvhead' list */
+  uv->u.l.prev->u.l.next = uv->u.l.next;
+}
+
+
+void luaF_freeupval (lua_State *L, UpVal *uv) {
+  if (uv->v != &uv->u.value)  /* is it open? */
+    unlinkupval(uv);  /* remove from open list */
+  luaM_free(L, uv);  /* free upvalue */
+}
+
+
+void luaF_close (lua_State *L, StkId level) {
+  UpVal *uv;
+  global_State *g = G(L);
+  while (L->openupval != NULL && (uv = gco2uv(L->openupval))->v >= level) {
+    GCObject *o = obj2gco(uv);
+    lua_assert(!isblack(o) && uv->v != &uv->u.value);
+    L->openupval = uv->next;  /* remove from `open' list */
+    if (isdead(g, o))
+      luaF_freeupval(L, uv);  /* free upvalue */
+    else {
+      unlinkupval(uv);  /* remove upvalue from 'uvhead' list */
+      setobj(L, &uv->u.value, uv->v);  /* move value to upvalue slot */
+      uv->v = &uv->u.value;  /* now current value lives here */
+      gch(o)->next = g->allgc;  /* link upvalue into 'allgc' list */
+      g->allgc = o;
+      luaC_checkupvalcolor(g, uv);
+    }
+  }
+}
+
+
+Proto *luaF_newproto (lua_State *L) {
+  Proto *f = &luaC_newobj(L, LUA_TPROTO, sizeof(Proto), NULL, 0)->p;
+  f->k = NULL;
+  f->sizek = 0;
+  f->p = NULL;
+  f->sizep = 0;
+  f->code = NULL;
+  f->cache = NULL;
+  f->sizecode = 0;
+  f->lineinfo = NULL;
+  f->sizelineinfo = 0;
+  f->upvalues = NULL;
+  f->sizeupvalues = 0;
+  f->numparams = 0;
+  f->is_vararg = 0;
+  f->maxstacksize = 0;
+  f->locvars = NULL;
+  f->sizelocvars = 0;
+  f->linedefined = 0;
+  f->lastlinedefined = 0;
+  f->source = NULL;
+  return f;
+}
+
+
+void luaF_freeproto (lua_State *L, Proto *f) {
+  luaM_freearray(L, f->code, f->sizecode);
+  luaM_freearray(L, f->p, f->sizep);
+  luaM_freearray(L, f->k, f->sizek);
+  luaM_freearray(L, f->lineinfo, f->sizelineinfo);
+  luaM_freearray(L, f->locvars, f->sizelocvars);
+  luaM_freearray(L, f->upvalues, f->sizeupvalues);
+  luaM_free(L, f);
+}
+
+
+/*
+** Look for n-th local variable at line `line' in function `func'.
+** Returns NULL if not found.
+*/
+const char *luaF_getlocalname (const Proto *f, int local_number, int pc) {
+  int i;
+  for (i = 0; i<f->sizelocvars && f->locvars[i].startpc <= pc; i++) {
+    if (pc < f->locvars[i].endpc) {  /* is variable active? */
+      local_number--;
+      if (local_number == 0)
+        return getstr(f->locvars[i].varname);
+    }
+  }
+  return NULL;  /* not found */
+}
+
diff -ruNp src.orig/libs/lua/lfunc.h src/libs/lua/lfunc.h
--- src.orig/libs/lua/lfunc.h	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lfunc.h	2017-11-21 19:39:46 -0600
@@ -0,0 +1,33 @@
+/*
+** $Id: lfunc.h,v 2.8 2012/05/08 13:53:33 roberto Exp $
+** Auxiliary functions to manipulate prototypes and closures
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lfunc_h
+#define lfunc_h
+
+
+#include "lobject.h"
+
+
+#define sizeCclosure(n)	(cast(int, sizeof(CClosure)) + \
+                         cast(int, sizeof(TValue)*((n)-1)))
+
+#define sizeLclosure(n)	(cast(int, sizeof(LClosure)) + \
+                         cast(int, sizeof(TValue *)*((n)-1)))
+
+
+LUAI_FUNC Proto *luaF_newproto (lua_State *L);
+LUAI_FUNC Closure *luaF_newCclosure (lua_State *L, int nelems);
+LUAI_FUNC Closure *luaF_newLclosure (lua_State *L, int nelems);
+LUAI_FUNC UpVal *luaF_newupval (lua_State *L);
+LUAI_FUNC UpVal *luaF_findupval (lua_State *L, StkId level);
+LUAI_FUNC void luaF_close (lua_State *L, StkId level);
+LUAI_FUNC void luaF_freeproto (lua_State *L, Proto *f);
+LUAI_FUNC void luaF_freeupval (lua_State *L, UpVal *uv);
+LUAI_FUNC const char *luaF_getlocalname (const Proto *func, int local_number,
+                                         int pc);
+
+
+#endif
diff -ruNp src.orig/libs/lua/lgc.c src/libs/lua/lgc.c
--- src.orig/libs/lua/lgc.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lgc.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,1213 @@
+/*
+** $Id: lgc.c,v 2.140 2013/03/16 21:10:18 roberto Exp $
+** Garbage Collector
+** See Copyright Notice in lua.h
+*/
+
+#include <string.h>
+
+#define lgc_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+
+
+
+/*
+** cost of sweeping one element (the size of a small object divided
+** by some adjust for the sweep speed)
+*/
+#define GCSWEEPCOST	((sizeof(TString) + 4) / 4)
+
+/* maximum number of elements to sweep in each single step */
+#define GCSWEEPMAX	(cast_int((GCSTEPSIZE / GCSWEEPCOST) / 4))
+
+/* maximum number of finalizers to call in each GC step */
+#define GCFINALIZENUM	4
+
+
+/*
+** macro to adjust 'stepmul': 'stepmul' is actually used like
+** 'stepmul / STEPMULADJ' (value chosen by tests)
+*/
+#define STEPMULADJ		200
+
+
+/*
+** macro to adjust 'pause': 'pause' is actually used like
+** 'pause / PAUSEADJ' (value chosen by tests)
+*/
+#define PAUSEADJ		100
+
+
+/*
+** 'makewhite' erases all color bits plus the old bit and then
+** sets only the current white bit
+*/
+#define maskcolors	(~(bit2mask(BLACKBIT, OLDBIT) | WHITEBITS))
+#define makewhite(g,x)	\
+ (gch(x)->marked = cast_byte((gch(x)->marked & maskcolors) | luaC_white(g)))
+
+#define white2gray(x)	resetbits(gch(x)->marked, WHITEBITS)
+#define black2gray(x)	resetbit(gch(x)->marked, BLACKBIT)
+
+
+#define isfinalized(x)		testbit(gch(x)->marked, FINALIZEDBIT)
+
+#define checkdeadkey(n)	lua_assert(!ttisdeadkey(gkey(n)) || ttisnil(gval(n)))
+
+
+#define checkconsistency(obj)  \
+  lua_longassert(!iscollectable(obj) || righttt(obj))
+
+
+#define markvalue(g,o) { checkconsistency(o); \
+  if (valiswhite(o)) reallymarkobject(g,gcvalue(o)); }
+
+#define markobject(g,t) { if ((t) && iswhite(obj2gco(t))) \
+		reallymarkobject(g, obj2gco(t)); }
+
+static void reallymarkobject (global_State *g, GCObject *o);
+
+
+/*
+** {======================================================
+** Generic functions
+** =======================================================
+*/
+
+
+/*
+** one after last element in a hash array
+*/
+#define gnodelast(h)	gnode(h, cast(size_t, sizenode(h)))
+
+
+/*
+** link table 'h' into list pointed by 'p'
+*/
+#define linktable(h,p)	((h)->gclist = *(p), *(p) = obj2gco(h))
+
+
+/*
+** if key is not marked, mark its entry as dead (therefore removing it
+** from the table)
+*/
+static void removeentry (Node *n) {
+  lua_assert(ttisnil(gval(n)));
+  if (valiswhite(gkey(n)))
+    setdeadvalue(gkey(n));  /* unused and unmarked key; remove it */
+}
+
+
+/*
+** tells whether a key or value can be cleared from a weak
+** table. Non-collectable objects are never removed from weak
+** tables. Strings behave as `values', so are never removed too. for
+** other objects: if really collected, cannot keep them; for objects
+** being finalized, keep them in keys, but not in values
+*/
+static int iscleared (global_State *g, const TValue *o) {
+  if (!iscollectable(o)) return 0;
+  else if (ttisstring(o)) {
+    markobject(g, rawtsvalue(o));  /* strings are `values', so are never weak */
+    return 0;
+  }
+  else return iswhite(gcvalue(o));
+}
+
+
+/*
+** barrier that moves collector forward, that is, mark the white object
+** being pointed by a black object.
+*/
+void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {
+  global_State *g = G(L);
+  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));
+  lua_assert(g->gcstate != GCSpause);
+  lua_assert(gch(o)->tt != LUA_TTABLE);
+  if (keepinvariantout(g))  /* must keep invariant? */
+    reallymarkobject(g, v);  /* restore invariant */
+  else {  /* sweep phase */
+    lua_assert(issweepphase(g));
+    makewhite(g, o);  /* mark main obj. as white to avoid other barriers */
+  }
+}
+
+
+/*
+** barrier that moves collector backward, that is, mark the black object
+** pointing to a white object as gray again. (Current implementation
+** only works for tables; access to 'gclist' is not uniform across
+** different types.)
+*/
+void luaC_barrierback_ (lua_State *L, GCObject *o) {
+  global_State *g = G(L);
+  lua_assert(isblack(o) && !isdead(g, o) && gch(o)->tt == LUA_TTABLE);
+  black2gray(o);  /* make object gray (again) */
+  gco2t(o)->gclist = g->grayagain;
+  g->grayagain = o;
+}
+
+
+/*
+** barrier for prototypes. When creating first closure (cache is
+** NULL), use a forward barrier; this may be the only closure of the
+** prototype (if it is a "regular" function, with a single instance)
+** and the prototype may be big, so it is better to avoid traversing
+** it again. Otherwise, use a backward barrier, to avoid marking all
+** possible instances.
+*/
+LUAI_FUNC void luaC_barrierproto_ (lua_State *L, Proto *p, Closure *c) {
+  global_State *g = G(L);
+  lua_assert(isblack(obj2gco(p)));
+  if (p->cache == NULL) {  /* first time? */
+    luaC_objbarrier(L, p, c);
+  }
+  else {  /* use a backward barrier */
+    black2gray(obj2gco(p));  /* make prototype gray (again) */
+    p->gclist = g->grayagain;
+    g->grayagain = obj2gco(p);
+  }
+}
+
+
+/*
+** check color (and invariants) for an upvalue that was closed,
+** i.e., moved into the 'allgc' list
+*/
+void luaC_checkupvalcolor (global_State *g, UpVal *uv) {
+  GCObject *o = obj2gco(uv);
+  lua_assert(!isblack(o));  /* open upvalues are never black */
+  if (isgray(o)) {
+    if (keepinvariant(g)) {
+      resetoldbit(o);  /* see MOVE OLD rule */
+      gray2black(o);  /* it is being visited now */
+      markvalue(g, uv->v);
+    }
+    else {
+      lua_assert(issweepphase(g));
+      makewhite(g, o);
+    }
+  }
+}
+
+
+/*
+** create a new collectable object (with given type and size) and link
+** it to '*list'. 'offset' tells how many bytes to allocate before the
+** object itself (used only by states).
+*/
+GCObject *luaC_newobj (lua_State *L, int tt, size_t sz, GCObject **list,
+                       int offset) {
+  global_State *g = G(L);
+  char *raw = cast(char *, luaM_newobject(L, novariant(tt), sz));
+  GCObject *o = obj2gco(raw + offset);
+  if (list == NULL)
+    list = &g->allgc;  /* standard list for collectable objects */
+  gch(o)->marked = luaC_white(g);
+  gch(o)->tt = tt;
+  gch(o)->next = *list;
+  *list = o;
+  return o;
+}
+
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** Mark functions
+** =======================================================
+*/
+
+
+/*
+** mark an object. Userdata, strings, and closed upvalues are visited
+** and turned black here. Other objects are marked gray and added
+** to appropriate list to be visited (and turned black) later. (Open
+** upvalues are already linked in 'headuv' list.)
+*/
+static void reallymarkobject (global_State *g, GCObject *o) {
+  lu_mem size;
+  white2gray(o);
+  switch (gch(o)->tt) {
+    case LUA_TSHRSTR:
+    case LUA_TLNGSTR: {
+      size = sizestring(gco2ts(o));
+      break;  /* nothing else to mark; make it black */
+    }
+    case LUA_TUSERDATA: {
+      Table *mt = gco2u(o)->metatable;
+      markobject(g, mt);
+      markobject(g, gco2u(o)->env);
+      size = sizeudata(gco2u(o));
+      break;
+    }
+    case LUA_TUPVAL: {
+      UpVal *uv = gco2uv(o);
+      markvalue(g, uv->v);
+      if (uv->v != &uv->u.value)  /* open? */
+        return;  /* open upvalues remain gray */
+      size = sizeof(UpVal);
+      break;
+    }
+    case LUA_TLCL: {
+      gco2lcl(o)->gclist = g->gray;
+      g->gray = o;
+      return;
+    }
+    case LUA_TCCL: {
+      gco2ccl(o)->gclist = g->gray;
+      g->gray = o;
+      return;
+    }
+    case LUA_TTABLE: {
+      linktable(gco2t(o), &g->gray);
+      return;
+    }
+    case LUA_TTHREAD: {
+      gco2th(o)->gclist = g->gray;
+      g->gray = o;
+      return;
+    }
+    case LUA_TPROTO: {
+      gco2p(o)->gclist = g->gray;
+      g->gray = o;
+      return;
+    }
+    default: lua_assert(0); return;
+  }
+  gray2black(o);
+  g->GCmemtrav += size;
+}
+
+
+/*
+** mark metamethods for basic types
+*/
+static void markmt (global_State *g) {
+  int i;
+  for (i=0; i < LUA_NUMTAGS; i++)
+    markobject(g, g->mt[i]);
+}
+
+
+/*
+** mark all objects in list of being-finalized
+*/
+static void markbeingfnz (global_State *g) {
+  GCObject *o;
+  for (o = g->tobefnz; o != NULL; o = gch(o)->next) {
+    makewhite(g, o);
+    reallymarkobject(g, o);
+  }
+}
+
+
+/*
+** mark all values stored in marked open upvalues. (See comment in
+** 'lstate.h'.)
+*/
+static void remarkupvals (global_State *g) {
+  UpVal *uv;
+  for (uv = g->uvhead.u.l.next; uv != &g->uvhead; uv = uv->u.l.next) {
+    if (isgray(obj2gco(uv)))
+      markvalue(g, uv->v);
+  }
+}
+
+
+/*
+** mark root set and reset all gray lists, to start a new
+** incremental (or full) collection
+*/
+static void restartcollection (global_State *g) {
+  g->gray = g->grayagain = NULL;
+  g->weak = g->allweak = g->ephemeron = NULL;
+  markobject(g, g->mainthread);
+  markvalue(g, &g->l_registry);
+  markmt(g);
+  markbeingfnz(g);  /* mark any finalizing object left from previous cycle */
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Traverse functions
+** =======================================================
+*/
+
+static void traverseweakvalue (global_State *g, Table *h) {
+  Node *n, *limit = gnodelast(h);
+  /* if there is array part, assume it may have white values (do not
+     traverse it just to check) */
+  int hasclears = (h->sizearray > 0);
+  for (n = gnode(h, 0); n < limit; n++) {
+    checkdeadkey(n);
+    if (ttisnil(gval(n)))  /* entry is empty? */
+      removeentry(n);  /* remove it */
+    else {
+      lua_assert(!ttisnil(gkey(n)));
+      markvalue(g, gkey(n));  /* mark key */
+      if (!hasclears && iscleared(g, gval(n)))  /* is there a white value? */
+        hasclears = 1;  /* table will have to be cleared */
+    }
+  }
+  if (hasclears)
+    linktable(h, &g->weak);  /* has to be cleared later */
+  else  /* no white values */
+    linktable(h, &g->grayagain);  /* no need to clean */
+}
+
+
+static int traverseephemeron (global_State *g, Table *h) {
+  int marked = 0;  /* true if an object is marked in this traversal */
+  int hasclears = 0;  /* true if table has white keys */
+  int prop = 0;  /* true if table has entry "white-key -> white-value" */
+  Node *n, *limit = gnodelast(h);
+  int i;
+  /* traverse array part (numeric keys are 'strong') */
+  for (i = 0; i < h->sizearray; i++) {
+    if (valiswhite(&h->array[i])) {
+      marked = 1;
+      reallymarkobject(g, gcvalue(&h->array[i]));
+    }
+  }
+  /* traverse hash part */
+  for (n = gnode(h, 0); n < limit; n++) {
+    checkdeadkey(n);
+    if (ttisnil(gval(n)))  /* entry is empty? */
+      removeentry(n);  /* remove it */
+    else if (iscleared(g, gkey(n))) {  /* key is not marked (yet)? */
+      hasclears = 1;  /* table must be cleared */
+      if (valiswhite(gval(n)))  /* value not marked yet? */
+        prop = 1;  /* must propagate again */
+    }
+    else if (valiswhite(gval(n))) {  /* value not marked yet? */
+      marked = 1;
+      reallymarkobject(g, gcvalue(gval(n)));  /* mark it now */
+    }
+  }
+  if (prop)
+    linktable(h, &g->ephemeron);  /* have to propagate again */
+  else if (hasclears)  /* does table have white keys? */
+    linktable(h, &g->allweak);  /* may have to clean white keys */
+  else  /* no white keys */
+    linktable(h, &g->grayagain);  /* no need to clean */
+  return marked;
+}
+
+
+static void traversestrongtable (global_State *g, Table *h) {
+  Node *n, *limit = gnodelast(h);
+  int i;
+  for (i = 0; i < h->sizearray; i++)  /* traverse array part */
+    markvalue(g, &h->array[i]);
+  for (n = gnode(h, 0); n < limit; n++) {  /* traverse hash part */
+    checkdeadkey(n);
+    if (ttisnil(gval(n)))  /* entry is empty? */
+      removeentry(n);  /* remove it */
+    else {
+      lua_assert(!ttisnil(gkey(n)));
+      markvalue(g, gkey(n));  /* mark key */
+      markvalue(g, gval(n));  /* mark value */
+    }
+  }
+}
+
+
+static lu_mem traversetable (global_State *g, Table *h) {
+  const char *weakkey, *weakvalue;
+  const TValue *mode = gfasttm(g, h->metatable, TM_MODE);
+  markobject(g, h->metatable);
+  if (mode && ttisstring(mode) &&  /* is there a weak mode? */
+      ((weakkey = strchr(svalue(mode), 'k')),
+       (weakvalue = strchr(svalue(mode), 'v')),
+       (weakkey || weakvalue))) {  /* is really weak? */
+    black2gray(obj2gco(h));  /* keep table gray */
+    if (!weakkey)  /* strong keys? */
+      traverseweakvalue(g, h);
+    else if (!weakvalue)  /* strong values? */
+      traverseephemeron(g, h);
+    else  /* all weak */
+      linktable(h, &g->allweak);  /* nothing to traverse now */
+  }
+  else  /* not weak */
+    traversestrongtable(g, h);
+  return sizeof(Table) + sizeof(TValue) * h->sizearray +
+                         sizeof(Node) * cast(size_t, sizenode(h));
+}
+
+
+static int traverseproto (global_State *g, Proto *f) {
+  int i;
+  if (f->cache && iswhite(obj2gco(f->cache)))
+    f->cache = NULL;  /* allow cache to be collected */
+  markobject(g, f->source);
+  for (i = 0; i < f->sizek; i++)  /* mark literals */
+    markvalue(g, &f->k[i]);
+  for (i = 0; i < f->sizeupvalues; i++)  /* mark upvalue names */
+    markobject(g, f->upvalues[i].name);
+  for (i = 0; i < f->sizep; i++)  /* mark nested protos */
+    markobject(g, f->p[i]);
+  for (i = 0; i < f->sizelocvars; i++)  /* mark local-variable names */
+    markobject(g, f->locvars[i].varname);
+  return sizeof(Proto) + sizeof(Instruction) * f->sizecode +
+                         sizeof(Proto *) * f->sizep +
+                         sizeof(TValue) * f->sizek +
+                         sizeof(int) * f->sizelineinfo +
+                         sizeof(LocVar) * f->sizelocvars +
+                         sizeof(Upvaldesc) * f->sizeupvalues;
+}
+
+
+static lu_mem traverseCclosure (global_State *g, CClosure *cl) {
+  int i;
+  for (i = 0; i < cl->nupvalues; i++)  /* mark its upvalues */
+    markvalue(g, &cl->upvalue[i]);
+  return sizeCclosure(cl->nupvalues);
+}
+
+static lu_mem traverseLclosure (global_State *g, LClosure *cl) {
+  int i;
+  markobject(g, cl->p);  /* mark its prototype */
+  for (i = 0; i < cl->nupvalues; i++)  /* mark its upvalues */
+    markobject(g, cl->upvals[i]);
+  return sizeLclosure(cl->nupvalues);
+}
+
+
+static lu_mem traversestack (global_State *g, lua_State *th) {
+  StkId o = th->stack;
+  if (o == NULL)
+    return 1;  /* stack not completely built yet */
+  for (; o < th->top; o++)
+    markvalue(g, o);
+  if (g->gcstate == GCSatomic) {  /* final traversal? */
+    StkId lim = th->stack + th->stacksize;  /* real end of stack */
+    for (; o < lim; o++)  /* clear not-marked stack slice */
+      setnilvalue(o);
+  }
+  return sizeof(lua_State) + sizeof(TValue) * th->stacksize;
+}
+
+
+/*
+** traverse one gray object, turning it to black (except for threads,
+** which are always gray).
+*/
+static void propagatemark (global_State *g) {
+  lu_mem size;
+  GCObject *o = g->gray;
+  lua_assert(isgray(o));
+  gray2black(o);
+  switch (gch(o)->tt) {
+    case LUA_TTABLE: {
+      Table *h = gco2t(o);
+      g->gray = h->gclist;  /* remove from 'gray' list */
+      size = traversetable(g, h);
+      break;
+    }
+    case LUA_TLCL: {
+      LClosure *cl = gco2lcl(o);
+      g->gray = cl->gclist;  /* remove from 'gray' list */
+      size = traverseLclosure(g, cl);
+      break;
+    }
+    case LUA_TCCL: {
+      CClosure *cl = gco2ccl(o);
+      g->gray = cl->gclist;  /* remove from 'gray' list */
+      size = traverseCclosure(g, cl);
+      break;
+    }
+    case LUA_TTHREAD: {
+      lua_State *th = gco2th(o);
+      g->gray = th->gclist;  /* remove from 'gray' list */
+      th->gclist = g->grayagain;
+      g->grayagain = o;  /* insert into 'grayagain' list */
+      black2gray(o);
+      size = traversestack(g, th);
+      break;
+    }
+    case LUA_TPROTO: {
+      Proto *p = gco2p(o);
+      g->gray = p->gclist;  /* remove from 'gray' list */
+      size = traverseproto(g, p);
+      break;
+    }
+    default: lua_assert(0); return;
+  }
+  g->GCmemtrav += size;
+}
+
+
+static void propagateall (global_State *g) {
+  while (g->gray) propagatemark(g);
+}
+
+
+static void propagatelist (global_State *g, GCObject *l) {
+  lua_assert(g->gray == NULL);  /* no grays left */
+  g->gray = l;
+  propagateall(g);  /* traverse all elements from 'l' */
+}
+
+/*
+** retraverse all gray lists. Because tables may be reinserted in other
+** lists when traversed, traverse the original lists to avoid traversing
+** twice the same table (which is not wrong, but inefficient)
+*/
+static void retraversegrays (global_State *g) {
+  GCObject *weak = g->weak;  /* save original lists */
+  GCObject *grayagain = g->grayagain;
+  GCObject *ephemeron = g->ephemeron;
+  g->weak = g->grayagain = g->ephemeron = NULL;
+  propagateall(g);  /* traverse main gray list */
+  propagatelist(g, grayagain);
+  propagatelist(g, weak);
+  propagatelist(g, ephemeron);
+}
+
+
+static void convergeephemerons (global_State *g) {
+  int changed;
+  do {
+    GCObject *w;
+    GCObject *next = g->ephemeron;  /* get ephemeron list */
+    g->ephemeron = NULL;  /* tables will return to this list when traversed */
+    changed = 0;
+    while ((w = next) != NULL) {
+      next = gco2t(w)->gclist;
+      if (traverseephemeron(g, gco2t(w))) {  /* traverse marked some value? */
+        propagateall(g);  /* propagate changes */
+        changed = 1;  /* will have to revisit all ephemeron tables */
+      }
+    }
+  } while (changed);
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Sweep Functions
+** =======================================================
+*/
+
+
+/*
+** clear entries with unmarked keys from all weaktables in list 'l' up
+** to element 'f'
+*/
+static void clearkeys (global_State *g, GCObject *l, GCObject *f) {
+  for (; l != f; l = gco2t(l)->gclist) {
+    Table *h = gco2t(l);
+    Node *n, *limit = gnodelast(h);
+    for (n = gnode(h, 0); n < limit; n++) {
+      if (!ttisnil(gval(n)) && (iscleared(g, gkey(n)))) {
+        setnilvalue(gval(n));  /* remove value ... */
+        removeentry(n);  /* and remove entry from table */
+      }
+    }
+  }
+}
+
+
+/*
+** clear entries with unmarked values from all weaktables in list 'l' up
+** to element 'f'
+*/
+static void clearvalues (global_State *g, GCObject *l, GCObject *f) {
+  for (; l != f; l = gco2t(l)->gclist) {
+    Table *h = gco2t(l);
+    Node *n, *limit = gnodelast(h);
+    int i;
+    for (i = 0; i < h->sizearray; i++) {
+      TValue *o = &h->array[i];
+      if (iscleared(g, o))  /* value was collected? */
+        setnilvalue(o);  /* remove value */
+    }
+    for (n = gnode(h, 0); n < limit; n++) {
+      if (!ttisnil(gval(n)) && iscleared(g, gval(n))) {
+        setnilvalue(gval(n));  /* remove value ... */
+        removeentry(n);  /* and remove entry from table */
+      }
+    }
+  }
+}
+
+
+static void freeobj (lua_State *L, GCObject *o) {
+  switch (gch(o)->tt) {
+    case LUA_TPROTO: luaF_freeproto(L, gco2p(o)); break;
+    case LUA_TLCL: {
+      luaM_freemem(L, o, sizeLclosure(gco2lcl(o)->nupvalues));
+      break;
+    }
+    case LUA_TCCL: {
+      luaM_freemem(L, o, sizeCclosure(gco2ccl(o)->nupvalues));
+      break;
+    }
+    case LUA_TUPVAL: luaF_freeupval(L, gco2uv(o)); break;
+    case LUA_TTABLE: luaH_free(L, gco2t(o)); break;
+    case LUA_TTHREAD: luaE_freethread(L, gco2th(o)); break;
+    case LUA_TUSERDATA: luaM_freemem(L, o, sizeudata(gco2u(o))); break;
+    case LUA_TSHRSTR:
+      G(L)->strt.nuse--;
+      /* go through */
+    case LUA_TLNGSTR: {
+      luaM_freemem(L, o, sizestring(gco2ts(o)));
+      break;
+    }
+    default: lua_assert(0);
+  }
+}
+
+
+#define sweepwholelist(L,p)	sweeplist(L,p,MAX_LUMEM)
+static GCObject **sweeplist (lua_State *L, GCObject **p, lu_mem count);
+
+
+/*
+** sweep the (open) upvalues of a thread and resize its stack and
+** list of call-info structures.
+*/
+static void sweepthread (lua_State *L, lua_State *L1) {
+  if (L1->stack == NULL) return;  /* stack not completely built yet */
+  sweepwholelist(L, &L1->openupval);  /* sweep open upvalues */
+  luaE_freeCI(L1);  /* free extra CallInfo slots */
+  /* should not change the stack during an emergency gc cycle */
+  if (G(L)->gckind != KGC_EMERGENCY)
+    luaD_shrinkstack(L1);
+}
+
+
+/*
+** sweep at most 'count' elements from a list of GCObjects erasing dead
+** objects, where a dead (not alive) object is one marked with the "old"
+** (non current) white and not fixed.
+** In non-generational mode, change all non-dead objects back to white,
+** preparing for next collection cycle.
+** In generational mode, keep black objects black, and also mark them as
+** old; stop when hitting an old object, as all objects after that
+** one will be old too.
+** When object is a thread, sweep its list of open upvalues too.
+*/
+static GCObject **sweeplist (lua_State *L, GCObject **p, lu_mem count) {
+  global_State *g = G(L);
+  int ow = otherwhite(g);
+  int toclear, toset;  /* bits to clear and to set in all live objects */
+  int tostop;  /* stop sweep when this is true */
+  if (isgenerational(g)) {  /* generational mode? */
+    toclear = ~0;  /* clear nothing */
+    toset = bitmask(OLDBIT);  /* set the old bit of all surviving objects */
+    tostop = bitmask(OLDBIT);  /* do not sweep old generation */
+  }
+  else {  /* normal mode */
+    toclear = maskcolors;  /* clear all color bits + old bit */
+    toset = luaC_white(g);  /* make object white */
+    tostop = 0;  /* do not stop */
+  }
+  while (*p != NULL && count-- > 0) {
+    GCObject *curr = *p;
+    int marked = gch(curr)->marked;
+    if (isdeadm(ow, marked)) {  /* is 'curr' dead? */
+      *p = gch(curr)->next;  /* remove 'curr' from list */
+      freeobj(L, curr);  /* erase 'curr' */
+    }
+    else {
+      if (testbits(marked, tostop))
+        return NULL;  /* stop sweeping this list */
+      if (gch(curr)->tt == LUA_TTHREAD)
+        sweepthread(L, gco2th(curr));  /* sweep thread's upvalues */
+      /* update marks */
+      gch(curr)->marked = cast_byte((marked & toclear) | toset);
+      p = &gch(curr)->next;  /* go to next element */
+    }
+  }
+  return (*p == NULL) ? NULL : p;
+}
+
+
+/*
+** sweep a list until a live object (or end of list)
+*/
+static GCObject **sweeptolive (lua_State *L, GCObject **p, int *n) {
+  GCObject ** old = p;
+  int i = 0;
+  do {
+    i++;
+    p = sweeplist(L, p, 1);
+  } while (p == old);
+  if (n) *n += i;
+  return p;
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Finalization
+** =======================================================
+*/
+
+static void checkSizes (lua_State *L) {
+  global_State *g = G(L);
+  if (g->gckind != KGC_EMERGENCY) {  /* do not change sizes in emergency */
+    int hs = g->strt.size / 2;  /* half the size of the string table */
+    if (g->strt.nuse < cast(lu_int32, hs))  /* using less than that half? */
+      luaS_resize(L, hs);  /* halve its size */
+    luaZ_freebuffer(L, &g->buff);  /* free concatenation buffer */
+  }
+}
+
+
+static GCObject *udata2finalize (global_State *g) {
+  GCObject *o = g->tobefnz;  /* get first element */
+  lua_assert(isfinalized(o));
+  g->tobefnz = gch(o)->next;  /* remove it from 'tobefnz' list */
+  gch(o)->next = g->allgc;  /* return it to 'allgc' list */
+  g->allgc = o;
+  resetbit(gch(o)->marked, SEPARATED);  /* mark that it is not in 'tobefnz' */
+  lua_assert(!isold(o));  /* see MOVE OLD rule */
+  if (!keepinvariantout(g))  /* not keeping invariant? */
+    makewhite(g, o);  /* "sweep" object */
+  return o;
+}
+
+
+static void dothecall (lua_State *L, void *ud) {
+  UNUSED(ud);
+  luaD_call(L, L->top - 2, 0, 0);
+}
+
+
+static void GCTM (lua_State *L, int propagateerrors) {
+  global_State *g = G(L);
+  const TValue *tm;
+  TValue v;
+  setgcovalue(L, &v, udata2finalize(g));
+  tm = luaT_gettmbyobj(L, &v, TM_GC);
+  if (tm != NULL && ttisfunction(tm)) {  /* is there a finalizer? */
+    int status;
+    lu_byte oldah = L->allowhook;
+    int running  = g->gcrunning;
+    L->allowhook = 0;  /* stop debug hooks during GC metamethod */
+    g->gcrunning = 0;  /* avoid GC steps */
+    setobj2s(L, L->top, tm);  /* push finalizer... */
+    setobj2s(L, L->top + 1, &v);  /* ... and its argument */
+    L->top += 2;  /* and (next line) call the finalizer */
+    status = luaD_pcall(L, dothecall, NULL, savestack(L, L->top - 2), 0);
+    L->allowhook = oldah;  /* restore hooks */
+    g->gcrunning = running;  /* restore state */
+    if (status != LUA_OK && propagateerrors) {  /* error while running __gc? */
+      if (status == LUA_ERRRUN) {  /* is there an error object? */
+        const char *msg = (ttisstring(L->top - 1))
+                            ? svalue(L->top - 1)
+                            : "no message";
+        luaO_pushfstring(L, "error in __gc metamethod (%s)", msg);
+        status = LUA_ERRGCMM;  /* error in __gc metamethod */
+      }
+      luaD_throw(L, status);  /* re-throw error */
+    }
+  }
+}
+
+
+/*
+** move all unreachable objects (or 'all' objects) that need
+** finalization from list 'finobj' to list 'tobefnz' (to be finalized)
+*/
+static void separatetobefnz (lua_State *L, int all) {
+  global_State *g = G(L);
+  GCObject **p = &g->finobj;
+  GCObject *curr;
+  GCObject **lastnext = &g->tobefnz;
+  /* find last 'next' field in 'tobefnz' list (to add elements in its end) */
+  while (*lastnext != NULL)
+    lastnext = &gch(*lastnext)->next;
+  while ((curr = *p) != NULL) {  /* traverse all finalizable objects */
+    lua_assert(!isfinalized(curr));
+    lua_assert(testbit(gch(curr)->marked, SEPARATED));
+    if (!(iswhite(curr) || all))  /* not being collected? */
+      p = &gch(curr)->next;  /* don't bother with it */
+    else {
+      l_setbit(gch(curr)->marked, FINALIZEDBIT); /* won't be finalized again */
+      *p = gch(curr)->next;  /* remove 'curr' from 'finobj' list */
+      gch(curr)->next = *lastnext;  /* link at the end of 'tobefnz' list */
+      *lastnext = curr;
+      lastnext = &gch(curr)->next;
+    }
+  }
+}
+
+
+/*
+** if object 'o' has a finalizer, remove it from 'allgc' list (must
+** search the list to find it) and link it in 'finobj' list.
+*/
+void luaC_checkfinalizer (lua_State *L, GCObject *o, Table *mt) {
+  global_State *g = G(L);
+  if (testbit(gch(o)->marked, SEPARATED) || /* obj. is already separated... */
+      isfinalized(o) ||                           /* ... or is finalized... */
+      gfasttm(g, mt, TM_GC) == NULL)                /* or has no finalizer? */
+    return;  /* nothing to be done */
+  else {  /* move 'o' to 'finobj' list */
+    GCObject **p;
+    GCheader *ho = gch(o);
+    if (g->sweepgc == &ho->next) {  /* avoid removing current sweep object */
+      lua_assert(issweepphase(g));
+      g->sweepgc = sweeptolive(L, g->sweepgc, NULL);
+    }
+    /* search for pointer pointing to 'o' */
+    for (p = &g->allgc; *p != o; p = &gch(*p)->next) { /* empty */ }
+    *p = ho->next;  /* remove 'o' from root list */
+    ho->next = g->finobj;  /* link it in list 'finobj' */
+    g->finobj = o;
+    l_setbit(ho->marked, SEPARATED);  /* mark it as such */
+    if (!keepinvariantout(g))  /* not keeping invariant? */
+      makewhite(g, o);  /* "sweep" object */
+    else
+      resetoldbit(o);  /* see MOVE OLD rule */
+  }
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** GC control
+** =======================================================
+*/
+
+
+/*
+** set a reasonable "time" to wait before starting a new GC cycle;
+** cycle will start when memory use hits threshold
+*/
+static void setpause (global_State *g, l_mem estimate) {
+  l_mem debt, threshold;
+  estimate = estimate / PAUSEADJ;  /* adjust 'estimate' */
+  threshold = (g->gcpause < MAX_LMEM / estimate)  /* overflow? */
+            ? estimate * g->gcpause  /* no overflow */
+            : MAX_LMEM;  /* overflow; truncate to maximum */
+  debt = -cast(l_mem, threshold - gettotalbytes(g));
+  luaE_setdebt(g, debt);
+}
+
+
+#define sweepphases  \
+	(bitmask(GCSsweepstring) | bitmask(GCSsweepudata) | bitmask(GCSsweep))
+
+
+/*
+** enter first sweep phase (strings) and prepare pointers for other
+** sweep phases.  The calls to 'sweeptolive' make pointers point to an
+** object inside the list (instead of to the header), so that the real
+** sweep do not need to skip objects created between "now" and the start
+** of the real sweep.
+** Returns how many objects it swept.
+*/
+static int entersweep (lua_State *L) {
+  global_State *g = G(L);
+  int n = 0;
+  g->gcstate = GCSsweepstring;
+  lua_assert(g->sweepgc == NULL && g->sweepfin == NULL);
+  /* prepare to sweep strings, finalizable objects, and regular objects */
+  g->sweepstrgc = 0;
+  g->sweepfin = sweeptolive(L, &g->finobj, &n);
+  g->sweepgc = sweeptolive(L, &g->allgc, &n);
+  return n;
+}
+
+
+/*
+** change GC mode
+*/
+void luaC_changemode (lua_State *L, int mode) {
+  global_State *g = G(L);
+  if (mode == g->gckind) return;  /* nothing to change */
+  if (mode == KGC_GEN) {  /* change to generational mode */
+    /* make sure gray lists are consistent */
+    luaC_runtilstate(L, bitmask(GCSpropagate));
+    g->GCestimate = gettotalbytes(g);
+    g->gckind = KGC_GEN;
+  }
+  else {  /* change to incremental mode */
+    /* sweep all objects to turn them back to white
+       (as white has not changed, nothing extra will be collected) */
+    g->gckind = KGC_NORMAL;
+    entersweep(L);
+    luaC_runtilstate(L, ~sweepphases);
+  }
+}
+
+
+/*
+** call all pending finalizers
+*/
+static void callallpendingfinalizers (lua_State *L, int propagateerrors) {
+  global_State *g = G(L);
+  while (g->tobefnz) {
+    resetoldbit(g->tobefnz);
+    GCTM(L, propagateerrors);
+  }
+}
+
+
+void luaC_freeallobjects (lua_State *L) {
+  global_State *g = G(L);
+  int i;
+  separatetobefnz(L, 1);  /* separate all objects with finalizers */
+  lua_assert(g->finobj == NULL);
+  callallpendingfinalizers(L, 0);
+  g->currentwhite = WHITEBITS; /* this "white" makes all objects look dead */
+  g->gckind = KGC_NORMAL;
+  sweepwholelist(L, &g->finobj);  /* finalizers can create objs. in 'finobj' */
+  sweepwholelist(L, &g->allgc);
+  for (i = 0; i < g->strt.size; i++)  /* free all string lists */
+    sweepwholelist(L, &g->strt.hash[i]);
+  lua_assert(g->strt.nuse == 0);
+}
+
+
+static l_mem atomic (lua_State *L) {
+  global_State *g = G(L);
+  l_mem work = -cast(l_mem, g->GCmemtrav);  /* start counting work */
+  GCObject *origweak, *origall;
+  lua_assert(!iswhite(obj2gco(g->mainthread)));
+  markobject(g, L);  /* mark running thread */
+  /* registry and global metatables may be changed by API */
+  markvalue(g, &g->l_registry);
+  markmt(g);  /* mark basic metatables */
+  /* remark occasional upvalues of (maybe) dead threads */
+  remarkupvals(g);
+  propagateall(g);  /* propagate changes */
+  work += g->GCmemtrav;  /* stop counting (do not (re)count grays) */
+  /* traverse objects caught by write barrier and by 'remarkupvals' */
+  retraversegrays(g);
+  work -= g->GCmemtrav;  /* restart counting */
+  convergeephemerons(g);
+  /* at this point, all strongly accessible objects are marked. */
+  /* clear values from weak tables, before checking finalizers */
+  clearvalues(g, g->weak, NULL);
+  clearvalues(g, g->allweak, NULL);
+  origweak = g->weak; origall = g->allweak;
+  work += g->GCmemtrav;  /* stop counting (objects being finalized) */
+  separatetobefnz(L, 0);  /* separate objects to be finalized */
+  markbeingfnz(g);  /* mark objects that will be finalized */
+  propagateall(g);  /* remark, to propagate `preserveness' */
+  work -= g->GCmemtrav;  /* restart counting */
+  convergeephemerons(g);
+  /* at this point, all resurrected objects are marked. */
+  /* remove dead objects from weak tables */
+  clearkeys(g, g->ephemeron, NULL);  /* clear keys from all ephemeron tables */
+  clearkeys(g, g->allweak, NULL);  /* clear keys from all allweak tables */
+  /* clear values from resurrected weak tables */
+  clearvalues(g, g->weak, origweak);
+  clearvalues(g, g->allweak, origall);
+  g->currentwhite = cast_byte(otherwhite(g));  /* flip current white */
+  work += g->GCmemtrav;  /* complete counting */
+  return work;  /* estimate of memory marked by 'atomic' */
+}
+
+
+static lu_mem singlestep (lua_State *L) {
+  global_State *g = G(L);
+  switch (g->gcstate) {
+    case GCSpause: {
+      /* start to count memory traversed */
+      g->GCmemtrav = g->strt.size * sizeof(GCObject*);
+      lua_assert(!isgenerational(g));
+      restartcollection(g);
+      g->gcstate = GCSpropagate;
+      return g->GCmemtrav;
+    }
+    case GCSpropagate: {
+      if (g->gray) {
+        lu_mem oldtrav = g->GCmemtrav;
+        propagatemark(g);
+        return g->GCmemtrav - oldtrav;  /* memory traversed in this step */
+      }
+      else {  /* no more `gray' objects */
+        lu_mem work;
+        int sw;
+        g->gcstate = GCSatomic;  /* finish mark phase */
+        g->GCestimate = g->GCmemtrav;  /* save what was counted */;
+        work = atomic(L);  /* add what was traversed by 'atomic' */
+        g->GCestimate += work;  /* estimate of total memory traversed */ 
+        sw = entersweep(L);
+        return work + sw * GCSWEEPCOST;
+      }
+    }
+    case GCSsweepstring: {
+      int i;
+      for (i = 0; i < GCSWEEPMAX && g->sweepstrgc + i < g->strt.size; i++)
+        sweepwholelist(L, &g->strt.hash[g->sweepstrgc + i]);
+      g->sweepstrgc += i;
+      if (g->sweepstrgc >= g->strt.size)  /* no more strings to sweep? */
+        g->gcstate = GCSsweepudata;
+      return i * GCSWEEPCOST;
+    }
+    case GCSsweepudata: {
+      if (g->sweepfin) {
+        g->sweepfin = sweeplist(L, g->sweepfin, GCSWEEPMAX);
+        return GCSWEEPMAX*GCSWEEPCOST;
+      }
+      else {
+        g->gcstate = GCSsweep;
+        return 0;
+      }
+    }
+    case GCSsweep: {
+      if (g->sweepgc) {
+        g->sweepgc = sweeplist(L, g->sweepgc, GCSWEEPMAX);
+        return GCSWEEPMAX*GCSWEEPCOST;
+      }
+      else {
+        /* sweep main thread */
+        GCObject *mt = obj2gco(g->mainthread);
+        sweeplist(L, &mt, 1);
+        checkSizes(L);
+        g->gcstate = GCSpause;  /* finish collection */
+        return GCSWEEPCOST;
+      }
+    }
+    default: lua_assert(0); return 0;
+  }
+}
+
+
+/*
+** advances the garbage collector until it reaches a state allowed
+** by 'statemask'
+*/
+void luaC_runtilstate (lua_State *L, int statesmask) {
+  global_State *g = G(L);
+  while (!testbit(statesmask, g->gcstate))
+    singlestep(L);
+}
+
+
+static void generationalcollection (lua_State *L) {
+  global_State *g = G(L);
+  lua_assert(g->gcstate == GCSpropagate);
+  if (g->GCestimate == 0) {  /* signal for another major collection? */
+    luaC_fullgc(L, 0);  /* perform a full regular collection */
+    g->GCestimate = gettotalbytes(g);  /* update control */
+  }
+  else {
+    lu_mem estimate = g->GCestimate;
+    luaC_runtilstate(L, bitmask(GCSpause));  /* run complete (minor) cycle */
+    g->gcstate = GCSpropagate;  /* skip restart */
+    if (gettotalbytes(g) > (estimate / 100) * g->gcmajorinc)
+      g->GCestimate = 0;  /* signal for a major collection */
+    else
+      g->GCestimate = estimate;  /* keep estimate from last major coll. */
+
+  }
+  setpause(g, gettotalbytes(g));
+  lua_assert(g->gcstate == GCSpropagate);
+}
+
+
+static void incstep (lua_State *L) {
+  global_State *g = G(L);
+  l_mem debt = g->GCdebt;
+  int stepmul = g->gcstepmul;
+  if (stepmul < 40) stepmul = 40;  /* avoid ridiculous low values (and 0) */
+  /* convert debt from Kb to 'work units' (avoid zero debt and overflows) */
+  debt = (debt / STEPMULADJ) + 1;
+  debt = (debt < MAX_LMEM / stepmul) ? debt * stepmul : MAX_LMEM;
+  do {  /* always perform at least one single step */
+    lu_mem work = singlestep(L);  /* do some work */
+    debt -= work;
+  } while (debt > -GCSTEPSIZE && g->gcstate != GCSpause);
+  if (g->gcstate == GCSpause)
+    setpause(g, g->GCestimate);  /* pause until next cycle */
+  else {
+    debt = (debt / stepmul) * STEPMULADJ;  /* convert 'work units' to Kb */
+    luaE_setdebt(g, debt);
+  }
+}
+
+
+/*
+** performs a basic GC step
+*/
+void luaC_forcestep (lua_State *L) {
+  global_State *g = G(L);
+  int i;
+  if (isgenerational(g)) generationalcollection(L);
+  else incstep(L);
+  /* run a few finalizers (or all of them at the end of a collect cycle) */
+  for (i = 0; g->tobefnz && (i < GCFINALIZENUM || g->gcstate == GCSpause); i++)
+    GCTM(L, 1);  /* call one finalizer */
+}
+
+
+/*
+** performs a basic GC step only if collector is running
+*/
+void luaC_step (lua_State *L) {
+  global_State *g = G(L);
+  if (g->gcrunning) luaC_forcestep(L);
+  else luaE_setdebt(g, -GCSTEPSIZE);  /* avoid being called too often */
+}
+
+
+
+/*
+** performs a full GC cycle; if "isemergency", does not call
+** finalizers (which could change stack positions)
+*/
+void luaC_fullgc (lua_State *L, int isemergency) {
+  global_State *g = G(L);
+  int origkind = g->gckind;
+  lua_assert(origkind != KGC_EMERGENCY);
+  if (isemergency)  /* do not run finalizers during emergency GC */
+    g->gckind = KGC_EMERGENCY;
+  else {
+    g->gckind = KGC_NORMAL;
+    callallpendingfinalizers(L, 1);
+  }
+  if (keepinvariant(g)) {  /* may there be some black objects? */
+    /* must sweep all objects to turn them back to white
+       (as white has not changed, nothing will be collected) */
+    entersweep(L);
+  }
+  /* finish any pending sweep phase to start a new cycle */
+  luaC_runtilstate(L, bitmask(GCSpause));
+  luaC_runtilstate(L, ~bitmask(GCSpause));  /* start new collection */
+  luaC_runtilstate(L, bitmask(GCSpause));  /* run entire collection */
+  if (origkind == KGC_GEN) {  /* generational mode? */
+    /* generational mode must be kept in propagate phase */
+    luaC_runtilstate(L, bitmask(GCSpropagate));
+  }
+  g->gckind = origkind;
+  setpause(g, gettotalbytes(g));
+  if (!isemergency)   /* do not run finalizers during emergency GC */
+    callallpendingfinalizers(L, 1);
+}
+
+/* }====================================================== */
+
+
diff -ruNp src.orig/libs/lua/lgc.h src/libs/lua/lgc.h
--- src.orig/libs/lua/lgc.h	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lgc.h	2017-11-21 19:39:46 -0600
@@ -0,0 +1,157 @@
+/*
+** $Id: lgc.h,v 2.58 2012/09/11 12:53:08 roberto Exp $
+** Garbage Collector
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lgc_h
+#define lgc_h
+
+
+#include "lobject.h"
+#include "lstate.h"
+
+/*
+** Collectable objects may have one of three colors: white, which
+** means the object is not marked; gray, which means the
+** object is marked, but its references may be not marked; and
+** black, which means that the object and all its references are marked.
+** The main invariant of the garbage collector, while marking objects,
+** is that a black object can never point to a white one. Moreover,
+** any gray object must be in a "gray list" (gray, grayagain, weak,
+** allweak, ephemeron) so that it can be visited again before finishing
+** the collection cycle. These lists have no meaning when the invariant
+** is not being enforced (e.g., sweep phase).
+*/
+
+
+
+/* how much to allocate before next GC step */
+#if !defined(GCSTEPSIZE)
+/* ~100 small strings */
+#define GCSTEPSIZE	(cast_int(100 * sizeof(TString)))
+#endif
+
+
+/*
+** Possible states of the Garbage Collector
+*/
+#define GCSpropagate	0
+#define GCSatomic	1
+#define GCSsweepstring	2
+#define GCSsweepudata	3
+#define GCSsweep	4
+#define GCSpause	5
+
+
+#define issweepphase(g)  \
+	(GCSsweepstring <= (g)->gcstate && (g)->gcstate <= GCSsweep)
+
+#define isgenerational(g)	((g)->gckind == KGC_GEN)
+
+/*
+** macros to tell when main invariant (white objects cannot point to black
+** ones) must be kept. During a non-generational collection, the sweep
+** phase may break the invariant, as objects turned white may point to
+** still-black objects. The invariant is restored when sweep ends and
+** all objects are white again. During a generational collection, the
+** invariant must be kept all times.
+*/
+
+#define keepinvariant(g)	(isgenerational(g) || g->gcstate <= GCSatomic)
+
+
+/*
+** Outside the collector, the state in generational mode is kept in
+** 'propagate', so 'keepinvariant' is always true.
+*/
+#define keepinvariantout(g)  \
+  check_exp(g->gcstate == GCSpropagate || !isgenerational(g),  \
+            g->gcstate <= GCSatomic)
+
+
+/*
+** some useful bit tricks
+*/
+#define resetbits(x,m)		((x) &= cast(lu_byte, ~(m)))
+#define setbits(x,m)		((x) |= (m))
+#define testbits(x,m)		((x) & (m))
+#define bitmask(b)		(1<<(b))
+#define bit2mask(b1,b2)		(bitmask(b1) | bitmask(b2))
+#define l_setbit(x,b)		setbits(x, bitmask(b))
+#define resetbit(x,b)		resetbits(x, bitmask(b))
+#define testbit(x,b)		testbits(x, bitmask(b))
+
+
+/* Layout for bit use in `marked' field: */
+#define WHITE0BIT	0  /* object is white (type 0) */
+#define WHITE1BIT	1  /* object is white (type 1) */
+#define BLACKBIT	2  /* object is black */
+#define FINALIZEDBIT	3  /* object has been separated for finalization */
+#define SEPARATED	4  /* object is in 'finobj' list or in 'tobefnz' */
+#define FIXEDBIT	5  /* object is fixed (should not be collected) */
+#define OLDBIT		6  /* object is old (only in generational mode) */
+/* bit 7 is currently used by tests (luaL_checkmemory) */
+
+#define WHITEBITS	bit2mask(WHITE0BIT, WHITE1BIT)
+
+
+#define iswhite(x)      testbits((x)->gch.marked, WHITEBITS)
+#define isblack(x)      testbit((x)->gch.marked, BLACKBIT)
+#define isgray(x)  /* neither white nor black */  \
+	(!testbits((x)->gch.marked, WHITEBITS | bitmask(BLACKBIT)))
+
+#define isold(x)	testbit((x)->gch.marked, OLDBIT)
+
+/* MOVE OLD rule: whenever an object is moved to the beginning of
+   a GC list, its old bit must be cleared */
+#define resetoldbit(o)	resetbit((o)->gch.marked, OLDBIT)
+
+#define otherwhite(g)	(g->currentwhite ^ WHITEBITS)
+#define isdeadm(ow,m)	(!(((m) ^ WHITEBITS) & (ow)))
+#define isdead(g,v)	isdeadm(otherwhite(g), (v)->gch.marked)
+
+#define changewhite(x)	((x)->gch.marked ^= WHITEBITS)
+#define gray2black(x)	l_setbit((x)->gch.marked, BLACKBIT)
+
+#define valiswhite(x)	(iscollectable(x) && iswhite(gcvalue(x)))
+
+#define luaC_white(g)	cast(lu_byte, (g)->currentwhite & WHITEBITS)
+
+
+#define luaC_condGC(L,c) \
+	{if (G(L)->GCdebt > 0) {c;}; condchangemem(L);}
+#define luaC_checkGC(L)		luaC_condGC(L, luaC_step(L);)
+
+
+#define luaC_barrier(L,p,v) { if (valiswhite(v) && isblack(obj2gco(p)))  \
+	luaC_barrier_(L,obj2gco(p),gcvalue(v)); }
+
+#define luaC_barrierback(L,p,v) { if (valiswhite(v) && isblack(obj2gco(p)))  \
+	luaC_barrierback_(L,p); }
+
+#define luaC_objbarrier(L,p,o)  \
+	{ if (iswhite(obj2gco(o)) && isblack(obj2gco(p))) \
+		luaC_barrier_(L,obj2gco(p),obj2gco(o)); }
+
+#define luaC_objbarrierback(L,p,o)  \
+   { if (iswhite(obj2gco(o)) && isblack(obj2gco(p))) luaC_barrierback_(L,p); }
+
+#define luaC_barrierproto(L,p,c) \
+   { if (isblack(obj2gco(p))) luaC_barrierproto_(L,p,c); }
+
+LUAI_FUNC void luaC_freeallobjects (lua_State *L);
+LUAI_FUNC void luaC_step (lua_State *L);
+LUAI_FUNC void luaC_forcestep (lua_State *L);
+LUAI_FUNC void luaC_runtilstate (lua_State *L, int statesmask);
+LUAI_FUNC void luaC_fullgc (lua_State *L, int isemergency);
+LUAI_FUNC GCObject *luaC_newobj (lua_State *L, int tt, size_t sz,
+                                 GCObject **list, int offset);
+LUAI_FUNC void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v);
+LUAI_FUNC void luaC_barrierback_ (lua_State *L, GCObject *o);
+LUAI_FUNC void luaC_barrierproto_ (lua_State *L, Proto *p, Closure *c);
+LUAI_FUNC void luaC_checkfinalizer (lua_State *L, GCObject *o, Table *mt);
+LUAI_FUNC void luaC_checkupvalcolor (global_State *g, UpVal *uv);
+LUAI_FUNC void luaC_changemode (lua_State *L, int mode);
+
+#endif
diff -ruNp src.orig/libs/lua/linit.c src/libs/lua/linit.c
--- src.orig/libs/lua/linit.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/linit.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,67 @@
+/*
+** $Id: linit.c,v 1.32 2011/04/08 19:17:36 roberto Exp $
+** Initialization of libraries for lua.c and other clients
+** See Copyright Notice in lua.h
+*/
+
+
+/*
+** If you embed Lua in your program and need to open the standard
+** libraries, call luaL_openlibs in your program. If you need a
+** different set of libraries, copy this file to your project and edit
+** it to suit your needs.
+*/
+
+
+#define linit_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lualib.h"
+#include "lauxlib.h"
+
+
+/*
+** these libs are loaded by lua.c and are readily available to any Lua
+** program
+*/
+static const luaL_Reg loadedlibs[] = {
+  {"_G", luaopen_base},
+  {LUA_LOADLIBNAME, luaopen_package},
+  {LUA_COLIBNAME, luaopen_coroutine},
+  {LUA_TABLIBNAME, luaopen_table},
+  {LUA_IOLIBNAME, luaopen_io},
+  {LUA_OSLIBNAME, luaopen_os},
+  {LUA_STRLIBNAME, luaopen_string},
+  {LUA_BITLIBNAME, luaopen_bit32},
+  {LUA_MATHLIBNAME, luaopen_math},
+  {LUA_DBLIBNAME, luaopen_debug},
+  {NULL, NULL}
+};
+
+
+/*
+** these libs are preloaded and must be required before used
+*/
+static const luaL_Reg preloadedlibs[] = {
+  {NULL, NULL}
+};
+
+
+LUALIB_API void luaL_openlibs (lua_State *L) {
+  const luaL_Reg *lib;
+  /* call open functions from 'loadedlibs' and set results to global table */
+  for (lib = loadedlibs; lib->func; lib++) {
+    luaL_requiref(L, lib->name, lib->func, 1);
+    lua_pop(L, 1);  /* remove lib */
+  }
+  /* add open functions from 'preloadedlibs' into 'package.preload' table */
+  luaL_getsubtable(L, LUA_REGISTRYINDEX, "_PRELOAD");
+  for (lib = preloadedlibs; lib->func; lib++) {
+    lua_pushcfunction(L, lib->func);
+    lua_setfield(L, -2, lib->name);
+  }
+  lua_pop(L, 1);  /* remove _PRELOAD table */
+}
+
diff -ruNp src.orig/libs/lua/liolib.c src/libs/lua/liolib.c
--- src.orig/libs/lua/liolib.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/liolib.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,665 @@
+/*
+** $Id: liolib.c,v 2.111 2013/03/21 13:57:27 roberto Exp $
+** Standard I/O (and system) library
+** See Copyright Notice in lua.h
+*/
+
+
+/*
+** POSIX idiosyncrasy!
+** This definition must come before the inclusion of 'stdio.h'; it
+** should not affect non-POSIX systems
+*/
+#if !defined(_FILE_OFFSET_BITS)
+#define _FILE_OFFSET_BITS 64
+#endif
+
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define liolib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+#if !defined(lua_checkmode)
+
+/*
+** Check whether 'mode' matches '[rwa]%+?b?'.
+** Change this macro to accept other modes for 'fopen' besides
+** the standard ones.
+*/
+#define lua_checkmode(mode) \
+	(*mode != '\0' && strchr("rwa", *(mode++)) != NULL &&	\
+	(*mode != '+' || ++mode) &&  /* skip if char is '+' */	\
+	(*mode != 'b' || ++mode) &&  /* skip if char is 'b' */	\
+	(*mode == '\0'))
+
+#endif
+
+/*
+** {======================================================
+** lua_popen spawns a new process connected to the current
+** one through the file streams.
+** =======================================================
+*/
+
+#if !defined(lua_popen)	/* { */
+
+#if defined(LUA_USE_POPEN)	/* { */
+
+#define lua_popen(L,c,m)	((void)L, fflush(NULL), popen(c,m))
+#define lua_pclose(L,file)	((void)L, pclose(file))
+
+#elif defined(LUA_WIN)		/* }{ */
+
+#define lua_popen(L,c,m)		((void)L, _popen(c,m))
+#define lua_pclose(L,file)		((void)L, _pclose(file))
+
+
+#else				/* }{ */
+
+#define lua_popen(L,c,m)		((void)((void)c, m),  \
+		luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
+#define lua_pclose(L,file)		((void)((void)L, file), -1)
+
+
+#endif				/* } */
+
+#endif			/* } */
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** lua_fseek/lua_ftell: configuration for longer offsets
+** =======================================================
+*/
+
+#if !defined(lua_fseek)	/* { */
+
+#if defined(LUA_USE_POSIX)
+
+#define l_fseek(f,o,w)		fseeko(f,o,w)
+#define l_ftell(f)		ftello(f)
+#define l_seeknum		off_t
+
+#elif defined(LUA_WIN) && !defined(_CRTIMP_TYPEINFO) \
+   && defined(_MSC_VER) && (_MSC_VER >= 1400)
+/* Windows (but not DDK) and Visual C++ 2005 or higher */
+
+#define l_fseek(f,o,w)		_fseeki64(f,o,w)
+#define l_ftell(f)		_ftelli64(f)
+#define l_seeknum		__int64
+
+#else
+
+#define l_fseek(f,o,w)		fseek(f,o,w)
+#define l_ftell(f)		ftell(f)
+#define l_seeknum		long
+
+#endif
+
+#endif			/* } */
+
+/* }====================================================== */
+
+
+#define IO_PREFIX	"_IO_"
+#define IO_INPUT	(IO_PREFIX "input")
+#define IO_OUTPUT	(IO_PREFIX "output")
+
+
+typedef luaL_Stream LStream;
+
+
+#define tolstream(L)	((LStream *)luaL_checkudata(L, 1, LUA_FILEHANDLE))
+
+#define isclosed(p)	((p)->closef == NULL)
+
+
+static int io_type (lua_State *L) {
+  LStream *p;
+  luaL_checkany(L, 1);
+  p = (LStream *)luaL_testudata(L, 1, LUA_FILEHANDLE);
+  if (p == NULL)
+    lua_pushnil(L);  /* not a file */
+  else if (isclosed(p))
+    lua_pushliteral(L, "closed file");
+  else
+    lua_pushliteral(L, "file");
+  return 1;
+}
+
+
+static int f_tostring (lua_State *L) {
+  LStream *p = tolstream(L);
+  if (isclosed(p))
+    lua_pushliteral(L, "file (closed)");
+  else
+    lua_pushfstring(L, "file (%p)", p->f);
+  return 1;
+}
+
+
+static FILE *tofile (lua_State *L) {
+  LStream *p = tolstream(L);
+  if (isclosed(p))
+    luaL_error(L, "attempt to use a closed file");
+  lua_assert(p->f);
+  return p->f;
+}
+
+
+/*
+** When creating file handles, always creates a `closed' file handle
+** before opening the actual file; so, if there is a memory error, the
+** file is not left opened.
+*/
+static LStream *newprefile (lua_State *L) {
+  LStream *p = (LStream *)lua_newuserdata(L, sizeof(LStream));
+  p->closef = NULL;  /* mark file handle as 'closed' */
+  luaL_setmetatable(L, LUA_FILEHANDLE);
+  return p;
+}
+
+
+static int aux_close (lua_State *L) {
+  LStream *p = tolstream(L);
+  lua_CFunction cf = p->closef;
+  p->closef = NULL;  /* mark stream as closed */
+  return (*cf)(L);  /* close it */
+}
+
+
+static int io_close (lua_State *L) {
+  if (lua_isnone(L, 1))  /* no argument? */
+    lua_getfield(L, LUA_REGISTRYINDEX, IO_OUTPUT);  /* use standard output */
+  tofile(L);  /* make sure argument is an open stream */
+  return aux_close(L);
+}
+
+
+static int f_gc (lua_State *L) {
+  LStream *p = tolstream(L);
+  if (!isclosed(p) && p->f != NULL)
+    aux_close(L);  /* ignore closed and incompletely open files */
+  return 0;
+}
+
+
+/*
+** function to close regular files
+*/
+static int io_fclose (lua_State *L) {
+  LStream *p = tolstream(L);
+  int res = fclose(p->f);
+  return luaL_fileresult(L, (res == 0), NULL);
+}
+
+
+static LStream *newfile (lua_State *L) {
+  LStream *p = newprefile(L);
+  p->f = NULL;
+  p->closef = &io_fclose;
+  return p;
+}
+
+
+static void opencheck (lua_State *L, const char *fname, const char *mode) {
+  LStream *p = newfile(L);
+  p->f = fopen(fname, mode);
+  if (p->f == NULL)
+    luaL_error(L, "cannot open file " LUA_QS " (%s)", fname, strerror(errno));
+}
+
+
+static int io_open (lua_State *L) {
+  const char *filename = luaL_checkstring(L, 1);
+  const char *mode = luaL_optstring(L, 2, "r");
+  LStream *p = newfile(L);
+  const char *md = mode;  /* to traverse/check mode */
+  luaL_argcheck(L, lua_checkmode(md), 2, "invalid mode");
+  p->f = fopen(filename, mode);
+  return (p->f == NULL) ? luaL_fileresult(L, 0, filename) : 1;
+}
+
+
+/*
+** function to close 'popen' files
+*/
+static int io_pclose (lua_State *L) {
+  LStream *p = tolstream(L);
+  return luaL_execresult(L, lua_pclose(L, p->f));
+}
+
+
+static int io_popen (lua_State *L) {
+  const char *filename = luaL_checkstring(L, 1);
+  const char *mode = luaL_optstring(L, 2, "r");
+  LStream *p = newprefile(L);
+  p->f = lua_popen(L, filename, mode);
+  p->closef = &io_pclose;
+  return (p->f == NULL) ? luaL_fileresult(L, 0, filename) : 1;
+}
+
+
+static int io_tmpfile (lua_State *L) {
+  LStream *p = newfile(L);
+  p->f = tmpfile();
+  return (p->f == NULL) ? luaL_fileresult(L, 0, NULL) : 1;
+}
+
+
+static FILE *getiofile (lua_State *L, const char *findex) {
+  LStream *p;
+  lua_getfield(L, LUA_REGISTRYINDEX, findex);
+  p = (LStream *)lua_touserdata(L, -1);
+  if (isclosed(p))
+    luaL_error(L, "standard %s file is closed", findex + strlen(IO_PREFIX));
+  return p->f;
+}
+
+
+static int g_iofile (lua_State *L, const char *f, const char *mode) {
+  if (!lua_isnoneornil(L, 1)) {
+    const char *filename = lua_tostring(L, 1);
+    if (filename)
+      opencheck(L, filename, mode);
+    else {
+      tofile(L);  /* check that it's a valid file handle */
+      lua_pushvalue(L, 1);
+    }
+    lua_setfield(L, LUA_REGISTRYINDEX, f);
+  }
+  /* return current value */
+  lua_getfield(L, LUA_REGISTRYINDEX, f);
+  return 1;
+}
+
+
+static int io_input (lua_State *L) {
+  return g_iofile(L, IO_INPUT, "r");
+}
+
+
+static int io_output (lua_State *L) {
+  return g_iofile(L, IO_OUTPUT, "w");
+}
+
+
+static int io_readline (lua_State *L);
+
+
+static void aux_lines (lua_State *L, int toclose) {
+  int i;
+  int n = lua_gettop(L) - 1;  /* number of arguments to read */
+  /* ensure that arguments will fit here and into 'io_readline' stack */
+  luaL_argcheck(L, n <= LUA_MINSTACK - 3, LUA_MINSTACK - 3, "too many options");
+  lua_pushvalue(L, 1);  /* file handle */
+  lua_pushinteger(L, n);  /* number of arguments to read */
+  lua_pushboolean(L, toclose);  /* close/not close file when finished */
+  for (i = 1; i <= n; i++) lua_pushvalue(L, i + 1);  /* copy arguments */
+  lua_pushcclosure(L, io_readline, 3 + n);
+}
+
+
+static int f_lines (lua_State *L) {
+  tofile(L);  /* check that it's a valid file handle */
+  aux_lines(L, 0);
+  return 1;
+}
+
+
+static int io_lines (lua_State *L) {
+  int toclose;
+  if (lua_isnone(L, 1)) lua_pushnil(L);  /* at least one argument */
+  if (lua_isnil(L, 1)) {  /* no file name? */
+    lua_getfield(L, LUA_REGISTRYINDEX, IO_INPUT);  /* get default input */
+    lua_replace(L, 1);  /* put it at index 1 */
+    tofile(L);  /* check that it's a valid file handle */
+    toclose = 0;  /* do not close it after iteration */
+  }
+  else {  /* open a new file */
+    const char *filename = luaL_checkstring(L, 1);
+    opencheck(L, filename, "r");
+    lua_replace(L, 1);  /* put file at index 1 */
+    toclose = 1;  /* close it after iteration */
+  }
+  aux_lines(L, toclose);
+  return 1;
+}
+
+
+/*
+** {======================================================
+** READ
+** =======================================================
+*/
+
+
+static int read_number (lua_State *L, FILE *f) {
+  lua_Number d;
+  if (fscanf(f, LUA_NUMBER_SCAN, &d) == 1) {
+    lua_pushnumber(L, d);
+    return 1;
+  }
+  else {
+   lua_pushnil(L);  /* "result" to be removed */
+   return 0;  /* read fails */
+  }
+}
+
+
+static int test_eof (lua_State *L, FILE *f) {
+  int c = getc(f);
+  ungetc(c, f);
+  lua_pushlstring(L, NULL, 0);
+  return (c != EOF);
+}
+
+
+static int read_line (lua_State *L, FILE *f, int chop) {
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  for (;;) {
+    size_t l;
+    char *p = luaL_prepbuffer(&b);
+    if (fgets(p, LUAL_BUFFERSIZE, f) == NULL) {  /* eof? */
+      luaL_pushresult(&b);  /* close buffer */
+      return (lua_rawlen(L, -1) > 0);  /* check whether read something */
+    }
+    l = strlen(p);
+    if (l == 0 || p[l-1] != '\n')
+      luaL_addsize(&b, l);
+    else {
+      luaL_addsize(&b, l - chop);  /* chop 'eol' if needed */
+      luaL_pushresult(&b);  /* close buffer */
+      return 1;  /* read at least an `eol' */
+    }
+  }
+}
+
+
+#define MAX_SIZE_T	(~(size_t)0)
+
+static void read_all (lua_State *L, FILE *f) {
+  size_t rlen = LUAL_BUFFERSIZE;  /* how much to read in each cycle */
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  for (;;) {
+    char *p = luaL_prepbuffsize(&b, rlen);
+    size_t nr = fread(p, sizeof(char), rlen, f);
+    luaL_addsize(&b, nr);
+    if (nr < rlen) break;  /* eof? */
+    else if (rlen <= (MAX_SIZE_T / 4))  /* avoid buffers too large */
+      rlen *= 2;  /* double buffer size at each iteration */
+  }
+  luaL_pushresult(&b);  /* close buffer */
+}
+
+
+static int read_chars (lua_State *L, FILE *f, size_t n) {
+  size_t nr;  /* number of chars actually read */
+  char *p;
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  p = luaL_prepbuffsize(&b, n);  /* prepare buffer to read whole block */
+  nr = fread(p, sizeof(char), n, f);  /* try to read 'n' chars */
+  luaL_addsize(&b, nr);
+  luaL_pushresult(&b);  /* close buffer */
+  return (nr > 0);  /* true iff read something */
+}
+
+
+static int g_read (lua_State *L, FILE *f, int first) {
+  int nargs = lua_gettop(L) - 1;
+  int success;
+  int n;
+  clearerr(f);
+  if (nargs == 0) {  /* no arguments? */
+    success = read_line(L, f, 1);
+    n = first+1;  /* to return 1 result */
+  }
+  else {  /* ensure stack space for all results and for auxlib's buffer */
+    luaL_checkstack(L, nargs+LUA_MINSTACK, "too many arguments");
+    success = 1;
+    for (n = first; nargs-- && success; n++) {
+      if (lua_type(L, n) == LUA_TNUMBER) {
+        size_t l = (size_t)lua_tointeger(L, n);
+        success = (l == 0) ? test_eof(L, f) : read_chars(L, f, l);
+      }
+      else {
+        const char *p = lua_tostring(L, n);
+        luaL_argcheck(L, p && p[0] == '*', n, "invalid option");
+        switch (p[1]) {
+          case 'n':  /* number */
+            success = read_number(L, f);
+            break;
+          case 'l':  /* line */
+            success = read_line(L, f, 1);
+            break;
+          case 'L':  /* line with end-of-line */
+            success = read_line(L, f, 0);
+            break;
+          case 'a':  /* file */
+            read_all(L, f);  /* read entire file */
+            success = 1; /* always success */
+            break;
+          default:
+            return luaL_argerror(L, n, "invalid format");
+        }
+      }
+    }
+  }
+  if (ferror(f))
+    return luaL_fileresult(L, 0, NULL);
+  if (!success) {
+    lua_pop(L, 1);  /* remove last result */
+    lua_pushnil(L);  /* push nil instead */
+  }
+  return n - first;
+}
+
+
+static int io_read (lua_State *L) {
+  return g_read(L, getiofile(L, IO_INPUT), 1);
+}
+
+
+static int f_read (lua_State *L) {
+  return g_read(L, tofile(L), 2);
+}
+
+
+static int io_readline (lua_State *L) {
+  LStream *p = (LStream *)lua_touserdata(L, lua_upvalueindex(1));
+  int i;
+  int n = (int)lua_tointeger(L, lua_upvalueindex(2));
+  if (isclosed(p))  /* file is already closed? */
+    return luaL_error(L, "file is already closed");
+  lua_settop(L , 1);
+  for (i = 1; i <= n; i++)  /* push arguments to 'g_read' */
+    lua_pushvalue(L, lua_upvalueindex(3 + i));
+  n = g_read(L, p->f, 2);  /* 'n' is number of results */
+  lua_assert(n > 0);  /* should return at least a nil */
+  if (!lua_isnil(L, -n))  /* read at least one value? */
+    return n;  /* return them */
+  else {  /* first result is nil: EOF or error */
+    if (n > 1) {  /* is there error information? */
+      /* 2nd result is error message */
+      return luaL_error(L, "%s", lua_tostring(L, -n + 1));
+    }
+    if (lua_toboolean(L, lua_upvalueindex(3))) {  /* generator created file? */
+      lua_settop(L, 0);
+      lua_pushvalue(L, lua_upvalueindex(1));
+      aux_close(L);  /* close it */
+    }
+    return 0;
+  }
+}
+
+/* }====================================================== */
+
+
+static int g_write (lua_State *L, FILE *f, int arg) {
+  int nargs = lua_gettop(L) - arg;
+  int status = 1;
+  for (; nargs--; arg++) {
+    if (lua_type(L, arg) == LUA_TNUMBER) {
+      /* optimization: could be done exactly as for strings */
+      status = status &&
+          fprintf(f, LUA_NUMBER_FMT, lua_tonumber(L, arg)) > 0;
+    }
+    else {
+      size_t l;
+      const char *s = luaL_checklstring(L, arg, &l);
+      status = status && (fwrite(s, sizeof(char), l, f) == l);
+    }
+  }
+  if (status) return 1;  /* file handle already on stack top */
+  else return luaL_fileresult(L, status, NULL);
+}
+
+
+static int io_write (lua_State *L) {
+  return g_write(L, getiofile(L, IO_OUTPUT), 1);
+}
+
+
+static int f_write (lua_State *L) {
+  FILE *f = tofile(L);
+  lua_pushvalue(L, 1);  /* push file at the stack top (to be returned) */
+  return g_write(L, f, 2);
+}
+
+
+static int f_seek (lua_State *L) {
+  static const int mode[] = {SEEK_SET, SEEK_CUR, SEEK_END};
+  static const char *const modenames[] = {"set", "cur", "end", NULL};
+  FILE *f = tofile(L);
+  int op = luaL_checkoption(L, 2, "cur", modenames);
+  lua_Number p3 = luaL_optnumber(L, 3, 0);
+  l_seeknum offset = (l_seeknum)p3;
+  luaL_argcheck(L, (lua_Number)offset == p3, 3,
+                  "not an integer in proper range");
+  op = l_fseek(f, offset, mode[op]);
+  if (op)
+    return luaL_fileresult(L, 0, NULL);  /* error */
+  else {
+    lua_pushnumber(L, (lua_Number)l_ftell(f));
+    return 1;
+  }
+}
+
+
+static int f_setvbuf (lua_State *L) {
+  static const int mode[] = {_IONBF, _IOFBF, _IOLBF};
+  static const char *const modenames[] = {"no", "full", "line", NULL};
+  FILE *f = tofile(L);
+  int op = luaL_checkoption(L, 2, NULL, modenames);
+  lua_Integer sz = luaL_optinteger(L, 3, LUAL_BUFFERSIZE);
+  int res = setvbuf(f, NULL, mode[op], sz);
+  return luaL_fileresult(L, res == 0, NULL);
+}
+
+
+
+static int io_flush (lua_State *L) {
+  return luaL_fileresult(L, fflush(getiofile(L, IO_OUTPUT)) == 0, NULL);
+}
+
+
+static int f_flush (lua_State *L) {
+  return luaL_fileresult(L, fflush(tofile(L)) == 0, NULL);
+}
+
+
+/*
+** functions for 'io' library
+*/
+static const luaL_Reg iolib[] = {
+  {"close", io_close},
+  {"flush", io_flush},
+  {"input", io_input},
+  {"lines", io_lines},
+  {"open", io_open},
+  {"output", io_output},
+  {"popen", io_popen},
+  {"read", io_read},
+  {"tmpfile", io_tmpfile},
+  {"type", io_type},
+  {"write", io_write},
+  {NULL, NULL}
+};
+
+
+/*
+** methods for file handles
+*/
+static const luaL_Reg flib[] = {
+  {"close", io_close},
+  {"flush", f_flush},
+  {"lines", f_lines},
+  {"read", f_read},
+  {"seek", f_seek},
+  {"setvbuf", f_setvbuf},
+  {"write", f_write},
+  {"__gc", f_gc},
+  {"__tostring", f_tostring},
+  {NULL, NULL}
+};
+
+
+static void createmeta (lua_State *L) {
+  luaL_newmetatable(L, LUA_FILEHANDLE);  /* create metatable for file handles */
+  lua_pushvalue(L, -1);  /* push metatable */
+  lua_setfield(L, -2, "__index");  /* metatable.__index = metatable */
+  luaL_setfuncs(L, flib, 0);  /* add file methods to new metatable */
+  lua_pop(L, 1);  /* pop new metatable */
+}
+
+
+/*
+** function to (not) close the standard files stdin, stdout, and stderr
+*/
+static int io_noclose (lua_State *L) {
+  LStream *p = tolstream(L);
+  p->closef = &io_noclose;  /* keep file opened */
+  lua_pushnil(L);
+  lua_pushliteral(L, "cannot close standard file");
+  return 2;
+}
+
+
+static void createstdfile (lua_State *L, FILE *f, const char *k,
+                           const char *fname) {
+  LStream *p = newprefile(L);
+  p->f = f;
+  p->closef = &io_noclose;
+  if (k != NULL) {
+    lua_pushvalue(L, -1);
+    lua_setfield(L, LUA_REGISTRYINDEX, k);  /* add file to registry */
+  }
+  lua_setfield(L, -2, fname);  /* add file to module */
+}
+
+
+LUAMOD_API int luaopen_io (lua_State *L) {
+  luaL_newlib(L, iolib);  /* new module */
+  createmeta(L);
+  /* create (and set) default files */
+  createstdfile(L, stdin, IO_INPUT, "stdin");
+  createstdfile(L, stdout, IO_OUTPUT, "stdout");
+  createstdfile(L, stderr, NULL, "stderr");
+  return 1;
+}
+
diff -ruNp src.orig/libs/lua/llex.c src/libs/lua/llex.c
--- src.orig/libs/lua/llex.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/llex.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,527 @@
+/*
+** $Id: llex.c,v 2.63 2013/03/16 21:10:18 roberto Exp $
+** Lexical Analyzer
+** See Copyright Notice in lua.h
+*/
+
+
+#include <locale.h>
+#include <string.h>
+
+#define llex_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lctype.h"
+#include "ldo.h"
+#include "llex.h"
+#include "lobject.h"
+#include "lparser.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "lzio.h"
+
+
+
+#define next(ls) (ls->current = zgetc(ls->z))
+
+
+
+#define currIsNewline(ls)	(ls->current == '\n' || ls->current == '\r')
+
+
+/* ORDER RESERVED */
+static const char *const luaX_tokens [] = {
+    "and", "break", "do", "else", "elseif",
+    "end", "false", "for", "function", "goto", "if",
+    "in", "local", "nil", "not", "or", "repeat",
+    "return", "then", "true", "until", "while",
+    "..", "...", "==", ">=", "<=", "~=", "::", "<eof>",
+    "<number>", "<name>", "<string>"
+};
+
+
+#define save_and_next(ls) (save(ls, ls->current), next(ls))
+
+
+static l_noret lexerror (LexState *ls, const char *msg, int token);
+
+
+static void save (LexState *ls, int c) {
+  Mbuffer *b = ls->buff;
+  if (luaZ_bufflen(b) + 1 > luaZ_sizebuffer(b)) {
+    size_t newsize;
+    if (luaZ_sizebuffer(b) >= MAX_SIZET/2)
+      lexerror(ls, "lexical element too long", 0);
+    newsize = luaZ_sizebuffer(b) * 2;
+    luaZ_resizebuffer(ls->L, b, newsize);
+  }
+  b->buffer[luaZ_bufflen(b)++] = cast(char, c);
+}
+
+
+void luaX_init (lua_State *L) {
+  int i;
+  for (i=0; i<NUM_RESERVED; i++) {
+    TString *ts = luaS_new(L, luaX_tokens[i]);
+    luaS_fix(ts);  /* reserved words are never collected */
+    ts->tsv.extra = cast_byte(i+1);  /* reserved word */
+  }
+}
+
+
+const char *luaX_token2str (LexState *ls, int token) {
+  if (token < FIRST_RESERVED) {  /* single-byte symbols? */
+    lua_assert(token == cast(unsigned char, token));
+    return (lisprint(token)) ? luaO_pushfstring(ls->L, LUA_QL("%c"), token) :
+                              luaO_pushfstring(ls->L, "char(%d)", token);
+  }
+  else {
+    const char *s = luaX_tokens[token - FIRST_RESERVED];
+    if (token < TK_EOS)  /* fixed format (symbols and reserved words)? */
+      return luaO_pushfstring(ls->L, LUA_QS, s);
+    else  /* names, strings, and numerals */
+      return s;
+  }
+}
+
+
+static const char *txtToken (LexState *ls, int token) {
+  switch (token) {
+    case TK_NAME:
+    case TK_STRING:
+    case TK_NUMBER:
+      save(ls, '\0');
+      return luaO_pushfstring(ls->L, LUA_QS, luaZ_buffer(ls->buff));
+    default:
+      return luaX_token2str(ls, token);
+  }
+}
+
+
+static l_noret lexerror (LexState *ls, const char *msg, int token) {
+  char buff[LUA_IDSIZE];
+  luaO_chunkid(buff, getstr(ls->source), LUA_IDSIZE);
+  msg = luaO_pushfstring(ls->L, "%s:%d: %s", buff, ls->linenumber, msg);
+  if (token)
+    luaO_pushfstring(ls->L, "%s near %s", msg, txtToken(ls, token));
+  luaD_throw(ls->L, LUA_ERRSYNTAX);
+}
+
+
+l_noret luaX_syntaxerror (LexState *ls, const char *msg) {
+  lexerror(ls, msg, ls->t.token);
+}
+
+
+/*
+** creates a new string and anchors it in function's table so that
+** it will not be collected until the end of the function's compilation
+** (by that time it should be anchored in function's prototype)
+*/
+TString *luaX_newstring (LexState *ls, const char *str, size_t l) {
+  lua_State *L = ls->L;
+  TValue *o;  /* entry for `str' */
+  TString *ts = luaS_newlstr(L, str, l);  /* create new string */
+  setsvalue2s(L, L->top++, ts);  /* temporarily anchor it in stack */
+  o = luaH_set(L, ls->fs->h, L->top - 1);
+  if (ttisnil(o)) {  /* not in use yet? (see 'addK') */
+    /* boolean value does not need GC barrier;
+       table has no metatable, so it does not need to invalidate cache */
+    setbvalue(o, 1);  /* t[string] = true */
+    luaC_checkGC(L);
+  }
+  L->top--;  /* remove string from stack */
+  return ts;
+}
+
+
+/*
+** increment line number and skips newline sequence (any of
+** \n, \r, \n\r, or \r\n)
+*/
+static void inclinenumber (LexState *ls) {
+  int old = ls->current;
+  lua_assert(currIsNewline(ls));
+  next(ls);  /* skip `\n' or `\r' */
+  if (currIsNewline(ls) && ls->current != old)
+    next(ls);  /* skip `\n\r' or `\r\n' */
+  if (++ls->linenumber >= MAX_INT)
+    luaX_syntaxerror(ls, "chunk has too many lines");
+}
+
+
+void luaX_setinput (lua_State *L, LexState *ls, ZIO *z, TString *source,
+                    int firstchar) {
+  ls->decpoint = '.';
+  ls->L = L;
+  ls->current = firstchar;
+  ls->lookahead.token = TK_EOS;  /* no look-ahead token */
+  ls->z = z;
+  ls->fs = NULL;
+  ls->linenumber = 1;
+  ls->lastline = 1;
+  ls->source = source;
+  ls->envn = luaS_new(L, LUA_ENV);  /* create env name */
+  luaS_fix(ls->envn);  /* never collect this name */
+  luaZ_resizebuffer(ls->L, ls->buff, LUA_MINBUFFER);  /* initialize buffer */
+}
+
+
+
+/*
+** =======================================================
+** LEXICAL ANALYZER
+** =======================================================
+*/
+
+
+
+static int check_next (LexState *ls, const char *set) {
+  if (ls->current == '\0' || !strchr(set, ls->current))
+    return 0;
+  save_and_next(ls);
+  return 1;
+}
+
+
+/*
+** change all characters 'from' in buffer to 'to'
+*/
+static void buffreplace (LexState *ls, char from, char to) {
+  size_t n = luaZ_bufflen(ls->buff);
+  char *p = luaZ_buffer(ls->buff);
+  while (n--)
+    if (p[n] == from) p[n] = to;
+}
+
+
+#if !defined(getlocaledecpoint)
+#define getlocaledecpoint()	(localeconv()->decimal_point[0])
+#endif
+
+
+#define buff2d(b,e)	luaO_str2d(luaZ_buffer(b), luaZ_bufflen(b) - 1, e)
+
+/*
+** in case of format error, try to change decimal point separator to
+** the one defined in the current locale and check again
+*/
+static void trydecpoint (LexState *ls, SemInfo *seminfo) {
+  char old = ls->decpoint;
+  ls->decpoint = getlocaledecpoint();
+  buffreplace(ls, old, ls->decpoint);  /* try new decimal separator */
+  if (!buff2d(ls->buff, &seminfo->r)) {
+    /* format error with correct decimal point: no more options */
+    buffreplace(ls, ls->decpoint, '.');  /* undo change (for error message) */
+    lexerror(ls, "malformed number", TK_NUMBER);
+  }
+}
+
+
+/* LUA_NUMBER */
+/*
+** this function is quite liberal in what it accepts, as 'luaO_str2d'
+** will reject ill-formed numerals.
+*/
+static void read_numeral (LexState *ls, SemInfo *seminfo) {
+  const char *expo = "Ee";
+  int first = ls->current;
+  lua_assert(lisdigit(ls->current));
+  save_and_next(ls);
+  if (first == '0' && check_next(ls, "Xx"))  /* hexadecimal? */
+    expo = "Pp";
+  for (;;) {
+    if (check_next(ls, expo))  /* exponent part? */
+      check_next(ls, "+-");  /* optional exponent sign */
+    if (lisxdigit(ls->current) || ls->current == '.')
+      save_and_next(ls);
+    else  break;
+  }
+  save(ls, '\0');
+  buffreplace(ls, '.', ls->decpoint);  /* follow locale for decimal point */
+  if (!buff2d(ls->buff, &seminfo->r))  /* format error? */
+    trydecpoint(ls, seminfo); /* try to update decimal point separator */
+}
+
+
+/*
+** skip a sequence '[=*[' or ']=*]' and return its number of '='s or
+** -1 if sequence is malformed
+*/
+static int skip_sep (LexState *ls) {
+  int count = 0;
+  int s = ls->current;
+  lua_assert(s == '[' || s == ']');
+  save_and_next(ls);
+  while (ls->current == '=') {
+    save_and_next(ls);
+    count++;
+  }
+  return (ls->current == s) ? count : (-count) - 1;
+}
+
+
+static void read_long_string (LexState *ls, SemInfo *seminfo, int sep) {
+  save_and_next(ls);  /* skip 2nd `[' */
+  if (currIsNewline(ls))  /* string starts with a newline? */
+    inclinenumber(ls);  /* skip it */
+  for (;;) {
+    switch (ls->current) {
+      case EOZ:
+        lexerror(ls, (seminfo) ? "unfinished long string" :
+                                 "unfinished long comment", TK_EOS);
+        break;  /* to avoid warnings */
+      case ']': {
+        if (skip_sep(ls) == sep) {
+          save_and_next(ls);  /* skip 2nd `]' */
+          goto endloop;
+        }
+        break;
+      }
+      case '\n': case '\r': {
+        save(ls, '\n');
+        inclinenumber(ls);
+        if (!seminfo) luaZ_resetbuffer(ls->buff);  /* avoid wasting space */
+        break;
+      }
+      default: {
+        if (seminfo) save_and_next(ls);
+        else next(ls);
+      }
+    }
+  } endloop:
+  if (seminfo)
+    seminfo->ts = luaX_newstring(ls, luaZ_buffer(ls->buff) + (2 + sep),
+                                     luaZ_bufflen(ls->buff) - 2*(2 + sep));
+}
+
+
+static void escerror (LexState *ls, int *c, int n, const char *msg) {
+  int i;
+  luaZ_resetbuffer(ls->buff);  /* prepare error message */
+  save(ls, '\\');
+  for (i = 0; i < n && c[i] != EOZ; i++)
+    save(ls, c[i]);
+  lexerror(ls, msg, TK_STRING);
+}
+
+
+static int readhexaesc (LexState *ls) {
+  int c[3], i;  /* keep input for error message */
+  int r = 0;  /* result accumulator */
+  c[0] = 'x';  /* for error message */
+  for (i = 1; i < 3; i++) {  /* read two hexadecimal digits */
+    c[i] = next(ls);
+    if (!lisxdigit(c[i]))
+      escerror(ls, c, i + 1, "hexadecimal digit expected");
+    r = (r << 4) + luaO_hexavalue(c[i]);
+  }
+  return r;
+}
+
+
+static int readdecesc (LexState *ls) {
+  int c[3], i;
+  int r = 0;  /* result accumulator */
+  for (i = 0; i < 3 && lisdigit(ls->current); i++) {  /* read up to 3 digits */
+    c[i] = ls->current;
+    r = 10*r + c[i] - '0';
+    next(ls);
+  }
+  if (r > UCHAR_MAX)
+    escerror(ls, c, i, "decimal escape too large");
+  return r;
+}
+
+
+static void read_string (LexState *ls, int del, SemInfo *seminfo) {
+  save_and_next(ls);  /* keep delimiter (for error messages) */
+  while (ls->current != del) {
+    switch (ls->current) {
+      case EOZ:
+        lexerror(ls, "unfinished string", TK_EOS);
+        break;  /* to avoid warnings */
+      case '\n':
+      case '\r':
+        lexerror(ls, "unfinished string", TK_STRING);
+        break;  /* to avoid warnings */
+      case '\\': {  /* escape sequences */
+        int c;  /* final character to be saved */
+        next(ls);  /* do not save the `\' */
+        switch (ls->current) {
+          case 'a': c = '\a'; goto read_save;
+          case 'b': c = '\b'; goto read_save;
+          case 'f': c = '\f'; goto read_save;
+          case 'n': c = '\n'; goto read_save;
+          case 'r': c = '\r'; goto read_save;
+          case 't': c = '\t'; goto read_save;
+          case 'v': c = '\v'; goto read_save;
+          case 'x': c = readhexaesc(ls); goto read_save;
+          case '\n': case '\r':
+            inclinenumber(ls); c = '\n'; goto only_save;
+          case '\\': case '\"': case '\'':
+            c = ls->current; goto read_save;
+          case EOZ: goto no_save;  /* will raise an error next loop */
+          case 'z': {  /* zap following span of spaces */
+            next(ls);  /* skip the 'z' */
+            while (lisspace(ls->current)) {
+              if (currIsNewline(ls)) inclinenumber(ls);
+              else next(ls);
+            }
+            goto no_save;
+          }
+          default: {
+            if (!lisdigit(ls->current))
+              escerror(ls, &ls->current, 1, "invalid escape sequence");
+            /* digital escape \ddd */
+            c = readdecesc(ls);
+            goto only_save;
+          }
+        }
+       read_save: next(ls);  /* read next character */
+       only_save: save(ls, c);  /* save 'c' */
+       no_save: break;
+      }
+      default:
+        save_and_next(ls);
+    }
+  }
+  save_and_next(ls);  /* skip delimiter */
+  seminfo->ts = luaX_newstring(ls, luaZ_buffer(ls->buff) + 1,
+                                   luaZ_bufflen(ls->buff) - 2);
+}
+
+
+static int llex (LexState *ls, SemInfo *seminfo) {
+  luaZ_resetbuffer(ls->buff);
+  for (;;) {
+    switch (ls->current) {
+      case '\n': case '\r': {  /* line breaks */
+        inclinenumber(ls);
+        break;
+      }
+      case ' ': case '\f': case '\t': case '\v': {  /* spaces */
+        next(ls);
+        break;
+      }
+      case '-': {  /* '-' or '--' (comment) */
+        next(ls);
+        if (ls->current != '-') return '-';
+        /* else is a comment */
+        next(ls);
+        if (ls->current == '[') {  /* long comment? */
+          int sep = skip_sep(ls);
+          luaZ_resetbuffer(ls->buff);  /* `skip_sep' may dirty the buffer */
+          if (sep >= 0) {
+            read_long_string(ls, NULL, sep);  /* skip long comment */
+            luaZ_resetbuffer(ls->buff);  /* previous call may dirty the buff. */
+            break;
+          }
+        }
+        /* else short comment */
+        while (!currIsNewline(ls) && ls->current != EOZ)
+          next(ls);  /* skip until end of line (or end of file) */
+        break;
+      }
+      case '[': {  /* long string or simply '[' */
+        int sep = skip_sep(ls);
+        if (sep >= 0) {
+          read_long_string(ls, seminfo, sep);
+          return TK_STRING;
+        }
+        else if (sep == -1) return '[';
+        else lexerror(ls, "invalid long string delimiter", TK_STRING);
+      }
+      case '=': {
+        next(ls);
+        if (ls->current != '=') return '=';
+        else { next(ls); return TK_EQ; }
+      }
+      case '<': {
+        next(ls);
+        if (ls->current != '=') return '<';
+        else { next(ls); return TK_LE; }
+      }
+      case '>': {
+        next(ls);
+        if (ls->current != '=') return '>';
+        else { next(ls); return TK_GE; }
+      }
+      case '~': {
+        next(ls);
+        if (ls->current != '=') return '~';
+        else { next(ls); return TK_NE; }
+      }
+      case ':': {
+        next(ls);
+        if (ls->current != ':') return ':';
+        else { next(ls); return TK_DBCOLON; }
+      }
+      case '"': case '\'': {  /* short literal strings */
+        read_string(ls, ls->current, seminfo);
+        return TK_STRING;
+      }
+      case '.': {  /* '.', '..', '...', or number */
+        save_and_next(ls);
+        if (check_next(ls, ".")) {
+          if (check_next(ls, "."))
+            return TK_DOTS;   /* '...' */
+          else return TK_CONCAT;   /* '..' */
+        }
+        else if (!lisdigit(ls->current)) return '.';
+        /* else go through */
+      }
+      case '0': case '1': case '2': case '3': case '4':
+      case '5': case '6': case '7': case '8': case '9': {
+        read_numeral(ls, seminfo);
+        return TK_NUMBER;
+      }
+      case EOZ: {
+        return TK_EOS;
+      }
+      default: {
+        if (lislalpha(ls->current)) {  /* identifier or reserved word? */
+          TString *ts;
+          do {
+            save_and_next(ls);
+          } while (lislalnum(ls->current));
+          ts = luaX_newstring(ls, luaZ_buffer(ls->buff),
+                                  luaZ_bufflen(ls->buff));
+          seminfo->ts = ts;
+          if (isreserved(ts))  /* reserved word? */
+            return ts->tsv.extra - 1 + FIRST_RESERVED;
+          else {
+            return TK_NAME;
+          }
+        }
+        else {  /* single-char tokens (+ - / ...) */
+          int c = ls->current;
+          next(ls);
+          return c;
+        }
+      }
+    }
+  }
+}
+
+
+void luaX_next (LexState *ls) {
+  ls->lastline = ls->linenumber;
+  if (ls->lookahead.token != TK_EOS) {  /* is there a look-ahead token? */
+    ls->t = ls->lookahead;  /* use this one */
+    ls->lookahead.token = TK_EOS;  /* and discharge it */
+  }
+  else
+    ls->t.token = llex(ls, &ls->t.seminfo);  /* read next token */
+}
+
+
+int luaX_lookahead (LexState *ls) {
+  lua_assert(ls->lookahead.token == TK_EOS);
+  ls->lookahead.token = llex(ls, &ls->lookahead.seminfo);
+  return ls->lookahead.token;
+}
+
diff -ruNp src.orig/libs/lua/llex.h src/libs/lua/llex.h
--- src.orig/libs/lua/llex.h	1969-12-31 18:00:00 -0600
+++ src/libs/lua/llex.h	2017-11-21 19:39:46 -0600
@@ -0,0 +1,78 @@
+/*
+** $Id: llex.h,v 1.72 2011/11/30 12:43:51 roberto Exp $
+** Lexical Analyzer
+** See Copyright Notice in lua.h
+*/
+
+#ifndef llex_h
+#define llex_h
+
+#include "lobject.h"
+#include "lzio.h"
+
+
+#define FIRST_RESERVED	257
+
+
+
+/*
+* WARNING: if you change the order of this enumeration,
+* grep "ORDER RESERVED"
+*/
+enum RESERVED {
+  /* terminal symbols denoted by reserved words */
+  TK_AND = FIRST_RESERVED, TK_BREAK,
+  TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,
+  TK_GOTO, TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,
+  TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,
+  /* other terminal symbols */
+  TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_DBCOLON, TK_EOS,
+  TK_NUMBER, TK_NAME, TK_STRING
+};
+
+/* number of reserved words */
+#define NUM_RESERVED	(cast(int, TK_WHILE-FIRST_RESERVED+1))
+
+
+typedef union {
+  lua_Number r;
+  TString *ts;
+} SemInfo;  /* semantics information */
+
+
+typedef struct Token {
+  int token;
+  SemInfo seminfo;
+} Token;
+
+
+/* state of the lexer plus state of the parser when shared by all
+   functions */
+typedef struct LexState {
+  int current;  /* current character (charint) */
+  int linenumber;  /* input line counter */
+  int lastline;  /* line of last token `consumed' */
+  Token t;  /* current token */
+  Token lookahead;  /* look ahead token */
+  struct FuncState *fs;  /* current function (parser) */
+  struct lua_State *L;
+  ZIO *z;  /* input stream */
+  Mbuffer *buff;  /* buffer for tokens */
+  struct Dyndata *dyd;  /* dynamic structures used by the parser */
+  TString *source;  /* current source name */
+  TString *envn;  /* environment variable name */
+  char decpoint;  /* locale decimal point */
+} LexState;
+
+
+LUAI_FUNC void luaX_init (lua_State *L);
+LUAI_FUNC void luaX_setinput (lua_State *L, LexState *ls, ZIO *z,
+                              TString *source, int firstchar);
+LUAI_FUNC TString *luaX_newstring (LexState *ls, const char *str, size_t l);
+LUAI_FUNC void luaX_next (LexState *ls);
+LUAI_FUNC int luaX_lookahead (LexState *ls);
+LUAI_FUNC l_noret luaX_syntaxerror (LexState *ls, const char *s);
+LUAI_FUNC const char *luaX_token2str (LexState *ls, int token);
+
+
+#endif
diff -ruNp src.orig/libs/lua/llimits.h src/libs/lua/llimits.h
--- src.orig/libs/lua/llimits.h	1969-12-31 18:00:00 -0600
+++ src/libs/lua/llimits.h	2017-11-21 19:39:46 -0600
@@ -0,0 +1,309 @@
+/*
+** $Id: llimits.h,v 1.103 2013/02/20 14:08:56 roberto Exp $
+** Limits, basic types, and some other `installation-dependent' definitions
+** See Copyright Notice in lua.h
+*/
+
+#ifndef llimits_h
+#define llimits_h
+
+
+#include <limits.h>
+#include <stddef.h>
+
+
+#include "lua.h"
+
+
+typedef unsigned LUA_INT32 lu_int32;
+
+typedef LUAI_UMEM lu_mem;
+
+typedef LUAI_MEM l_mem;
+
+
+
+/* chars used as small naturals (so that `char' is reserved for characters) */
+typedef unsigned char lu_byte;
+
+
+#define MAX_SIZET	((size_t)(~(size_t)0)-2)
+
+#define MAX_LUMEM	((lu_mem)(~(lu_mem)0)-2)
+
+#define MAX_LMEM	((l_mem) ((MAX_LUMEM >> 1) - 2))
+
+
+#define MAX_INT (INT_MAX-2)  /* maximum value of an int (-2 for safety) */
+
+/*
+** conversion of pointer to integer
+** this is for hashing only; there is no problem if the integer
+** cannot hold the whole pointer value
+*/
+#define IntPoint(p)  ((unsigned int)(lu_mem)(p))
+
+
+
+/* type to ensure maximum alignment */
+#if !defined(LUAI_USER_ALIGNMENT_T)
+#define LUAI_USER_ALIGNMENT_T	union { double u; void *s; long l; }
+#endif
+
+typedef LUAI_USER_ALIGNMENT_T L_Umaxalign;
+
+
+/* result of a `usual argument conversion' over lua_Number */
+typedef LUAI_UACNUMBER l_uacNumber;
+
+
+/* internal assertions for in-house debugging */
+#if defined(lua_assert)
+#define check_exp(c,e)		(lua_assert(c), (e))
+/* to avoid problems with conditions too long */
+#define lua_longassert(c)	{ if (!(c)) lua_assert(0); }
+#else
+#define lua_assert(c)		((void)0)
+#define check_exp(c,e)		(e)
+#define lua_longassert(c)	((void)0)
+#endif
+
+/*
+** assertion for checking API calls
+*/
+#if !defined(luai_apicheck)
+
+#if defined(LUA_USE_APICHECK)
+#include <assert.h>
+#define luai_apicheck(L,e)	assert(e)
+#else
+#define luai_apicheck(L,e)	lua_assert(e)
+#endif
+
+#endif
+
+#define api_check(l,e,msg)	luai_apicheck(l,(e) && msg)
+
+
+#if !defined(UNUSED)
+#define UNUSED(x)	((void)(x))	/* to avoid warnings */
+#endif
+
+
+#define cast(t, exp)	((t)(exp))
+
+#define cast_byte(i)	cast(lu_byte, (i))
+#define cast_num(i)	cast(lua_Number, (i))
+#define cast_int(i)	cast(int, (i))
+#define cast_uchar(i)	cast(unsigned char, (i))
+
+
+/*
+** non-return type
+*/
+#if defined(__GNUC__)
+#define l_noret		void __attribute__((noreturn))
+#elif defined(_MSC_VER)
+#define l_noret		void __declspec(noreturn)
+#else
+#define l_noret		void
+#endif
+
+
+
+/*
+** maximum depth for nested C calls and syntactical nested non-terminals
+** in a program. (Value must fit in an unsigned short int.)
+*/
+#if !defined(LUAI_MAXCCALLS)
+#define LUAI_MAXCCALLS		200
+#endif
+
+/*
+** maximum number of upvalues in a closure (both C and Lua). (Value
+** must fit in an unsigned char.)
+*/
+#define MAXUPVAL	UCHAR_MAX
+
+
+/*
+** type for virtual-machine instructions
+** must be an unsigned with (at least) 4 bytes (see details in lopcodes.h)
+*/
+typedef lu_int32 Instruction;
+
+
+
+/* maximum stack for a Lua function */
+#define MAXSTACK	250
+
+
+
+/* minimum size for the string table (must be power of 2) */
+#if !defined(MINSTRTABSIZE)
+#define MINSTRTABSIZE	32
+#endif
+
+
+/* minimum size for string buffer */
+#if !defined(LUA_MINBUFFER)
+#define LUA_MINBUFFER	32
+#endif
+
+
+#if !defined(lua_lock)
+#define lua_lock(L)     ((void) 0)
+#define lua_unlock(L)   ((void) 0)
+#endif
+
+#if !defined(luai_threadyield)
+#define luai_threadyield(L)     {lua_unlock(L); lua_lock(L);}
+#endif
+
+
+/*
+** these macros allow user-specific actions on threads when you defined
+** LUAI_EXTRASPACE and need to do something extra when a thread is
+** created/deleted/resumed/yielded.
+*/
+#if !defined(luai_userstateopen)
+#define luai_userstateopen(L)		((void)L)
+#endif
+
+#if !defined(luai_userstateclose)
+#define luai_userstateclose(L)		((void)L)
+#endif
+
+#if !defined(luai_userstatethread)
+#define luai_userstatethread(L,L1)	((void)L)
+#endif
+
+#if !defined(luai_userstatefree)
+#define luai_userstatefree(L,L1)	((void)L)
+#endif
+
+#if !defined(luai_userstateresume)
+#define luai_userstateresume(L,n)       ((void)L)
+#endif
+
+#if !defined(luai_userstateyield)
+#define luai_userstateyield(L,n)        ((void)L)
+#endif
+
+/*
+** lua_number2int is a macro to convert lua_Number to int.
+** lua_number2integer is a macro to convert lua_Number to lua_Integer.
+** lua_number2unsigned is a macro to convert a lua_Number to a lua_Unsigned.
+** lua_unsigned2number is a macro to convert a lua_Unsigned to a lua_Number.
+** luai_hashnum is a macro to hash a lua_Number value into an integer.
+** The hash must be deterministic and give reasonable values for
+** both small and large values (outside the range of integers).
+*/
+
+#if defined(MS_ASMTRICK) || defined(LUA_MSASMTRICK)	/* { */
+/* trick with Microsoft assembler for X86 */
+
+#define lua_number2int(i,n)  __asm {__asm fld n   __asm fistp i}
+#define lua_number2integer(i,n)		lua_number2int(i, n)
+#define lua_number2unsigned(i,n)  \
+  {__int64 l; __asm {__asm fld n   __asm fistp l} i = (unsigned int)l;}
+
+
+#elif defined(LUA_IEEE754TRICK)		/* }{ */
+/* the next trick should work on any machine using IEEE754 with
+   a 32-bit int type */
+
+union luai_Cast { double l_d; LUA_INT32 l_p[2]; };
+
+#if !defined(LUA_IEEEENDIAN)	/* { */
+#define LUAI_EXTRAIEEE	\
+  static const union luai_Cast ieeeendian = {-(33.0 + 6755399441055744.0)};
+#define LUA_IEEEENDIANLOC	(ieeeendian.l_p[1] == 33)
+#else
+#define LUA_IEEEENDIANLOC	LUA_IEEEENDIAN
+#define LUAI_EXTRAIEEE		/* empty */
+#endif				/* } */
+
+#define lua_number2int32(i,n,t) \
+  { LUAI_EXTRAIEEE \
+    volatile union luai_Cast u; u.l_d = (n) + 6755399441055744.0; \
+    (i) = (t)u.l_p[LUA_IEEEENDIANLOC]; }
+
+#define luai_hashnum(i,n)  \
+  { volatile union luai_Cast u; u.l_d = (n) + 1.0;  /* avoid -0 */ \
+    (i) = u.l_p[0]; (i) += u.l_p[1]; }  /* add double bits for his hash */
+
+#define lua_number2int(i,n)		lua_number2int32(i, n, int)
+#define lua_number2unsigned(i,n)	lua_number2int32(i, n, lua_Unsigned)
+
+/* the trick can be expanded to lua_Integer when it is a 32-bit value */
+#if defined(LUA_IEEELL)
+#define lua_number2integer(i,n)		lua_number2int32(i, n, lua_Integer)
+#endif
+
+#endif				/* } */
+
+
+/* the following definitions always work, but may be slow */
+
+#if !defined(lua_number2int)
+#define lua_number2int(i,n)	((i)=(int)(n))
+#endif
+
+#if !defined(lua_number2integer)
+#define lua_number2integer(i,n)	((i)=(lua_Integer)(n))
+#endif
+
+#if !defined(lua_number2unsigned)	/* { */
+/* the following definition assures proper modulo behavior */
+#if defined(LUA_NUMBER_DOUBLE) || defined(LUA_NUMBER_FLOAT)
+#include <math.h>
+#define SUPUNSIGNED	((lua_Number)(~(lua_Unsigned)0) + 1)
+#define lua_number2unsigned(i,n)  \
+	((i)=(lua_Unsigned)((n) - floor((n)/SUPUNSIGNED)*SUPUNSIGNED))
+#else
+#define lua_number2unsigned(i,n)	((i)=(lua_Unsigned)(n))
+#endif
+#endif				/* } */
+
+
+#if !defined(lua_unsigned2number)
+/* on several machines, coercion from unsigned to double is slow,
+   so it may be worth to avoid */
+#define lua_unsigned2number(u)  \
+    (((u) <= (lua_Unsigned)INT_MAX) ? (lua_Number)(int)(u) : (lua_Number)(u))
+#endif
+
+
+
+#if defined(ltable_c) && !defined(luai_hashnum)
+
+#include <float.h>
+#include <math.h>
+
+#define luai_hashnum(i,n) { int e;  \
+  n = l_mathop(frexp)(n, &e) * (lua_Number)(INT_MAX - DBL_MAX_EXP);  \
+  lua_number2int(i, n); i += e; }
+
+#endif
+
+
+
+/*
+** macro to control inclusion of some hard tests on stack reallocation
+*/
+#if !defined(HARDSTACKTESTS)
+#define condmovestack(L)	((void)0)
+#else
+/* realloc stack keeping its size */
+#define condmovestack(L)	luaD_reallocstack((L), (L)->stacksize)
+#endif
+
+#if !defined(HARDMEMTESTS)
+#define condchangemem(L)	condmovestack(L)
+#else
+#define condchangemem(L)  \
+	((void)(!(G(L)->gcrunning) || (luaC_fullgc(L, 0), 1)))
+#endif
+
+#endif
diff -ruNp src.orig/libs/lua/lmathlib.c src/libs/lua/lmathlib.c
--- src.orig/libs/lua/lmathlib.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lmathlib.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,279 @@
+/*
+** $Id: lmathlib.c,v 1.83 2013/03/07 18:21:32 roberto Exp $
+** Standard mathematical library
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdlib.h>
+#include <math.h>
+
+#define lmathlib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+#undef PI
+#define PI	((lua_Number)(3.1415926535897932384626433832795))
+#define RADIANS_PER_DEGREE	((lua_Number)(PI/180.0))
+
+
+
+static int math_abs (lua_State *L) {
+  lua_pushnumber(L, l_mathop(fabs)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_sin (lua_State *L) {
+  lua_pushnumber(L, l_mathop(sin)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_sinh (lua_State *L) {
+  lua_pushnumber(L, l_mathop(sinh)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_cos (lua_State *L) {
+  lua_pushnumber(L, l_mathop(cos)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_cosh (lua_State *L) {
+  lua_pushnumber(L, l_mathop(cosh)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_tan (lua_State *L) {
+  lua_pushnumber(L, l_mathop(tan)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_tanh (lua_State *L) {
+  lua_pushnumber(L, l_mathop(tanh)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_asin (lua_State *L) {
+  lua_pushnumber(L, l_mathop(asin)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_acos (lua_State *L) {
+  lua_pushnumber(L, l_mathop(acos)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_atan (lua_State *L) {
+  lua_pushnumber(L, l_mathop(atan)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_atan2 (lua_State *L) {
+  lua_pushnumber(L, l_mathop(atan2)(luaL_checknumber(L, 1),
+                                luaL_checknumber(L, 2)));
+  return 1;
+}
+
+static int math_ceil (lua_State *L) {
+  lua_pushnumber(L, l_mathop(ceil)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_floor (lua_State *L) {
+  lua_pushnumber(L, l_mathop(floor)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_fmod (lua_State *L) {
+  lua_pushnumber(L, l_mathop(fmod)(luaL_checknumber(L, 1),
+                               luaL_checknumber(L, 2)));
+  return 1;
+}
+
+static int math_modf (lua_State *L) {
+  lua_Number ip;
+  lua_Number fp = l_mathop(modf)(luaL_checknumber(L, 1), &ip);
+  lua_pushnumber(L, ip);
+  lua_pushnumber(L, fp);
+  return 2;
+}
+
+static int math_sqrt (lua_State *L) {
+  lua_pushnumber(L, l_mathop(sqrt)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_pow (lua_State *L) {
+  lua_Number x = luaL_checknumber(L, 1);
+  lua_Number y = luaL_checknumber(L, 2);
+  lua_pushnumber(L, l_mathop(pow)(x, y));
+  return 1;
+}
+
+static int math_log (lua_State *L) {
+  lua_Number x = luaL_checknumber(L, 1);
+  lua_Number res;
+  if (lua_isnoneornil(L, 2))
+    res = l_mathop(log)(x);
+  else {
+    lua_Number base = luaL_checknumber(L, 2);
+    if (base == (lua_Number)10.0) res = l_mathop(log10)(x);
+    else res = l_mathop(log)(x)/l_mathop(log)(base);
+  }
+  lua_pushnumber(L, res);
+  return 1;
+}
+
+#if defined(LUA_COMPAT_LOG10)
+static int math_log10 (lua_State *L) {
+  lua_pushnumber(L, l_mathop(log10)(luaL_checknumber(L, 1)));
+  return 1;
+}
+#endif
+
+static int math_exp (lua_State *L) {
+  lua_pushnumber(L, l_mathop(exp)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_deg (lua_State *L) {
+  lua_pushnumber(L, luaL_checknumber(L, 1)/RADIANS_PER_DEGREE);
+  return 1;
+}
+
+static int math_rad (lua_State *L) {
+  lua_pushnumber(L, luaL_checknumber(L, 1)*RADIANS_PER_DEGREE);
+  return 1;
+}
+
+static int math_frexp (lua_State *L) {
+  int e;
+  lua_pushnumber(L, l_mathop(frexp)(luaL_checknumber(L, 1), &e));
+  lua_pushinteger(L, e);
+  return 2;
+}
+
+static int math_ldexp (lua_State *L) {
+  lua_Number x = luaL_checknumber(L, 1);
+  int ep = luaL_checkint(L, 2);
+  lua_pushnumber(L, l_mathop(ldexp)(x, ep));
+  return 1;
+}
+
+
+
+static int math_min (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  lua_Number dmin = luaL_checknumber(L, 1);
+  int i;
+  for (i=2; i<=n; i++) {
+    lua_Number d = luaL_checknumber(L, i);
+    if (d < dmin)
+      dmin = d;
+  }
+  lua_pushnumber(L, dmin);
+  return 1;
+}
+
+
+static int math_max (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  lua_Number dmax = luaL_checknumber(L, 1);
+  int i;
+  for (i=2; i<=n; i++) {
+    lua_Number d = luaL_checknumber(L, i);
+    if (d > dmax)
+      dmax = d;
+  }
+  lua_pushnumber(L, dmax);
+  return 1;
+}
+
+
+static int math_random (lua_State *L) {
+  /* the `%' avoids the (rare) case of r==1, and is needed also because on
+     some systems (SunOS!) `rand()' may return a value larger than RAND_MAX */
+  lua_Number r = (lua_Number)(rand()%RAND_MAX) / (lua_Number)RAND_MAX;
+  switch (lua_gettop(L)) {  /* check number of arguments */
+    case 0: {  /* no arguments */
+      lua_pushnumber(L, r);  /* Number between 0 and 1 */
+      break;
+    }
+    case 1: {  /* only upper limit */
+      lua_Number u = luaL_checknumber(L, 1);
+      luaL_argcheck(L, (lua_Number)1.0 <= u, 1, "interval is empty");
+      lua_pushnumber(L, l_mathop(floor)(r*u) + (lua_Number)(1.0));  /* [1, u] */
+      break;
+    }
+    case 2: {  /* lower and upper limits */
+      lua_Number l = luaL_checknumber(L, 1);
+      lua_Number u = luaL_checknumber(L, 2);
+      luaL_argcheck(L, l <= u, 2, "interval is empty");
+      lua_pushnumber(L, l_mathop(floor)(r*(u-l+1)) + l);  /* [l, u] */
+      break;
+    }
+    default: return luaL_error(L, "wrong number of arguments");
+  }
+  return 1;
+}
+
+
+static int math_randomseed (lua_State *L) {
+  srand(luaL_checkunsigned(L, 1));
+  (void)rand(); /* discard first value to avoid undesirable correlations */
+  return 0;
+}
+
+
+static const luaL_Reg mathlib[] = {
+  {"abs",   math_abs},
+  {"acos",  math_acos},
+  {"asin",  math_asin},
+  {"atan2", math_atan2},
+  {"atan",  math_atan},
+  {"ceil",  math_ceil},
+  {"cosh",   math_cosh},
+  {"cos",   math_cos},
+  {"deg",   math_deg},
+  {"exp",   math_exp},
+  {"floor", math_floor},
+  {"fmod",   math_fmod},
+  {"frexp", math_frexp},
+  {"ldexp", math_ldexp},
+#if defined(LUA_COMPAT_LOG10)
+  {"log10", math_log10},
+#endif
+  {"log",   math_log},
+  {"max",   math_max},
+  {"min",   math_min},
+  {"modf",   math_modf},
+  {"pow",   math_pow},
+  {"rad",   math_rad},
+  {"random",     math_random},
+  {"randomseed", math_randomseed},
+  {"sinh",   math_sinh},
+  {"sin",   math_sin},
+  {"sqrt",  math_sqrt},
+  {"tanh",   math_tanh},
+  {"tan",   math_tan},
+  {NULL, NULL}
+};
+
+
+/*
+** Open math library
+*/
+LUAMOD_API int luaopen_math (lua_State *L) {
+  luaL_newlib(L, mathlib);
+  lua_pushnumber(L, PI);
+  lua_setfield(L, -2, "pi");
+  lua_pushnumber(L, HUGE_VAL);
+  lua_setfield(L, -2, "huge");
+  return 1;
+}
+
diff -ruNp src.orig/libs/lua/lmem.c src/libs/lua/lmem.c
--- src.orig/libs/lua/lmem.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lmem.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,99 @@
+/*
+** $Id: lmem.c,v 1.84 2012/05/23 15:41:53 roberto Exp $
+** Interface to Memory Manager
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stddef.h>
+
+#define lmem_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+
+
+
+/*
+** About the realloc function:
+** void * frealloc (void *ud, void *ptr, size_t osize, size_t nsize);
+** (`osize' is the old size, `nsize' is the new size)
+**
+** * frealloc(ud, NULL, x, s) creates a new block of size `s' (no
+** matter 'x').
+**
+** * frealloc(ud, p, x, 0) frees the block `p'
+** (in this specific case, frealloc must return NULL);
+** particularly, frealloc(ud, NULL, 0, 0) does nothing
+** (which is equivalent to free(NULL) in ANSI C)
+**
+** frealloc returns NULL if it cannot create or reallocate the area
+** (any reallocation to an equal or smaller size cannot fail!)
+*/
+
+
+
+#define MINSIZEARRAY	4
+
+
+void *luaM_growaux_ (lua_State *L, void *block, int *size, size_t size_elems,
+                     int limit, const char *what) {
+  void *newblock;
+  int newsize;
+  if (*size >= limit/2) {  /* cannot double it? */
+    if (*size >= limit)  /* cannot grow even a little? */
+      luaG_runerror(L, "too many %s (limit is %d)", what, limit);
+    newsize = limit;  /* still have at least one free place */
+  }
+  else {
+    newsize = (*size)*2;
+    if (newsize < MINSIZEARRAY)
+      newsize = MINSIZEARRAY;  /* minimum size */
+  }
+  newblock = luaM_reallocv(L, block, *size, newsize, size_elems);
+  *size = newsize;  /* update only when everything else is OK */
+  return newblock;
+}
+
+
+l_noret luaM_toobig (lua_State *L) {
+  luaG_runerror(L, "memory allocation error: block too big");
+}
+
+
+
+/*
+** generic allocation routine.
+*/
+void *luaM_realloc_ (lua_State *L, void *block, size_t osize, size_t nsize) {
+  void *newblock;
+  global_State *g = G(L);
+  size_t realosize = (block) ? osize : 0;
+  lua_assert((realosize == 0) == (block == NULL));
+#if defined(HARDMEMTESTS)
+  if (nsize > realosize && g->gcrunning)
+    luaC_fullgc(L, 1);  /* force a GC whenever possible */
+#endif
+  newblock = (*g->frealloc)(g->ud, block, osize, nsize);
+  if (newblock == NULL && nsize > 0) {
+    api_check(L, nsize > realosize,
+                 "realloc cannot fail when shrinking a block");
+    if (g->gcrunning) {
+      luaC_fullgc(L, 1);  /* try to free some memory... */
+      newblock = (*g->frealloc)(g->ud, block, osize, nsize);  /* try again */
+    }
+    if (newblock == NULL)
+      luaD_throw(L, LUA_ERRMEM);
+  }
+  lua_assert((nsize == 0) == (newblock == NULL));
+  g->GCdebt = (g->GCdebt + nsize) - realosize;
+  return newblock;
+}
+
diff -ruNp src.orig/libs/lua/lmem.h src/libs/lua/lmem.h
--- src.orig/libs/lua/lmem.h	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lmem.h	2017-11-21 19:39:46 -0600
@@ -0,0 +1,57 @@
+/*
+** $Id: lmem.h,v 1.40 2013/02/20 14:08:21 roberto Exp $
+** Interface to Memory Manager
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lmem_h
+#define lmem_h
+
+
+#include <stddef.h>
+
+#include "llimits.h"
+#include "lua.h"
+
+
+/*
+** This macro avoids the runtime division MAX_SIZET/(e), as 'e' is
+** always constant.
+** The macro is somewhat complex to avoid warnings:
+** +1 avoids warnings of "comparison has constant result";
+** cast to 'void' avoids warnings of "value unused".
+*/
+#define luaM_reallocv(L,b,on,n,e) \
+  (cast(void, \
+     (cast(size_t, (n)+1) > MAX_SIZET/(e)) ? (luaM_toobig(L), 0) : 0), \
+   luaM_realloc_(L, (b), (on)*(e), (n)*(e)))
+
+#define luaM_freemem(L, b, s)	luaM_realloc_(L, (b), (s), 0)
+#define luaM_free(L, b)		luaM_realloc_(L, (b), sizeof(*(b)), 0)
+#define luaM_freearray(L, b, n)   luaM_reallocv(L, (b), n, 0, sizeof((b)[0]))
+
+#define luaM_malloc(L,s)	luaM_realloc_(L, NULL, 0, (s))
+#define luaM_new(L,t)		cast(t *, luaM_malloc(L, sizeof(t)))
+#define luaM_newvector(L,n,t) \
+		cast(t *, luaM_reallocv(L, NULL, 0, n, sizeof(t)))
+
+#define luaM_newobject(L,tag,s)	luaM_realloc_(L, NULL, tag, (s))
+
+#define luaM_growvector(L,v,nelems,size,t,limit,e) \
+          if ((nelems)+1 > (size)) \
+            ((v)=cast(t *, luaM_growaux_(L,v,&(size),sizeof(t),limit,e)))
+
+#define luaM_reallocvector(L, v,oldn,n,t) \
+   ((v)=cast(t *, luaM_reallocv(L, v, oldn, n, sizeof(t))))
+
+LUAI_FUNC l_noret luaM_toobig (lua_State *L);
+
+/* not to be called directly */
+LUAI_FUNC void *luaM_realloc_ (lua_State *L, void *block, size_t oldsize,
+                                                          size_t size);
+LUAI_FUNC void *luaM_growaux_ (lua_State *L, void *block, int *size,
+                               size_t size_elem, int limit,
+                               const char *what);
+
+#endif
+
diff -ruNp src.orig/libs/lua/loadlib.c src/libs/lua/loadlib.c
--- src.orig/libs/lua/loadlib.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/loadlib.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,725 @@
+/*
+** $Id: loadlib.c,v 1.111 2012/05/30 12:33:44 roberto Exp $
+** Dynamic library loader for Lua
+** See Copyright Notice in lua.h
+**
+** This module contains an implementation of loadlib for Unix systems
+** that have dlfcn, an implementation for Windows, and a stub for other
+** systems.
+*/
+
+
+/*
+** if needed, includes windows header before everything else
+*/
+#if defined(_WIN32)
+#include <windows.h>
+#endif
+
+
+#include <stdlib.h>
+#include <string.h>
+
+
+#define loadlib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+/*
+** LUA_PATH and LUA_CPATH are the names of the environment
+** variables that Lua check to set its paths.
+*/
+#if !defined(LUA_PATH)
+#define LUA_PATH	"LUA_PATH"
+#endif
+
+#if !defined(LUA_CPATH)
+#define LUA_CPATH	"LUA_CPATH"
+#endif
+
+#define LUA_PATHSUFFIX		"_" LUA_VERSION_MAJOR "_" LUA_VERSION_MINOR
+
+#define LUA_PATHVERSION		LUA_PATH LUA_PATHSUFFIX
+#define LUA_CPATHVERSION	LUA_CPATH LUA_PATHSUFFIX
+
+/*
+** LUA_PATH_SEP is the character that separates templates in a path.
+** LUA_PATH_MARK is the string that marks the substitution points in a
+** template.
+** LUA_EXEC_DIR in a Windows path is replaced by the executable's
+** directory.
+** LUA_IGMARK is a mark to ignore all before it when building the
+** luaopen_ function name.
+*/
+#if !defined (LUA_PATH_SEP)
+#define LUA_PATH_SEP		";"
+#endif
+#if !defined (LUA_PATH_MARK)
+#define LUA_PATH_MARK		"?"
+#endif
+#if !defined (LUA_EXEC_DIR)
+#define LUA_EXEC_DIR		"!"
+#endif
+#if !defined (LUA_IGMARK)
+#define LUA_IGMARK		"-"
+#endif
+
+
+/*
+** LUA_CSUBSEP is the character that replaces dots in submodule names
+** when searching for a C loader.
+** LUA_LSUBSEP is the character that replaces dots in submodule names
+** when searching for a Lua loader.
+*/
+#if !defined(LUA_CSUBSEP)
+#define LUA_CSUBSEP		LUA_DIRSEP
+#endif
+
+#if !defined(LUA_LSUBSEP)
+#define LUA_LSUBSEP		LUA_DIRSEP
+#endif
+
+
+/* prefix for open functions in C libraries */
+#define LUA_POF		"luaopen_"
+
+/* separator for open functions in C libraries */
+#define LUA_OFSEP	"_"
+
+
+/* table (in the registry) that keeps handles for all loaded C libraries */
+#define CLIBS		"_CLIBS"
+
+#define LIB_FAIL	"open"
+
+
+/* error codes for ll_loadfunc */
+#define ERRLIB		1
+#define ERRFUNC		2
+
+#define setprogdir(L)		((void)0)
+
+
+/*
+** system-dependent functions
+*/
+static void ll_unloadlib (void *lib);
+static void *ll_load (lua_State *L, const char *path, int seeglb);
+static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym);
+
+
+
+#if defined(LUA_USE_DLOPEN)
+/*
+** {========================================================================
+** This is an implementation of loadlib based on the dlfcn interface.
+** The dlfcn interface is available in Linux, SunOS, Solaris, IRIX, FreeBSD,
+** NetBSD, AIX 4.2, HPUX 11, and  probably most other Unix flavors, at least
+** as an emulation layer on top of native functions.
+** =========================================================================
+*/
+
+#include <dlfcn.h>
+
+static void ll_unloadlib (void *lib) {
+  dlclose(lib);
+}
+
+
+static void *ll_load (lua_State *L, const char *path, int seeglb) {
+  void *lib = dlopen(path, RTLD_NOW | (seeglb ? RTLD_GLOBAL : RTLD_LOCAL));
+  if (lib == NULL) lua_pushstring(L, dlerror());
+  return lib;
+}
+
+
+static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
+  lua_CFunction f = (lua_CFunction)dlsym(lib, sym);
+  if (f == NULL) lua_pushstring(L, dlerror());
+  return f;
+}
+
+/* }====================================================== */
+
+
+
+#elif defined(LUA_DL_DLL)
+/*
+** {======================================================================
+** This is an implementation of loadlib for Windows using native functions.
+** =======================================================================
+*/
+
+#undef setprogdir
+
+/*
+** optional flags for LoadLibraryEx
+*/
+#if !defined(LUA_LLE_FLAGS)
+#define LUA_LLE_FLAGS	0
+#endif
+
+
+static void setprogdir (lua_State *L) {
+  char buff[MAX_PATH + 1];
+  char *lb;
+  DWORD nsize = sizeof(buff)/sizeof(char);
+  DWORD n = GetModuleFileNameA(NULL, buff, nsize);
+  if (n == 0 || n == nsize || (lb = strrchr(buff, '\\')) == NULL)
+    luaL_error(L, "unable to get ModuleFileName");
+  else {
+    *lb = '\0';
+    luaL_gsub(L, lua_tostring(L, -1), LUA_EXEC_DIR, buff);
+    lua_remove(L, -2);  /* remove original string */
+  }
+}
+
+
+static void pusherror (lua_State *L) {
+  int error = GetLastError();
+  char buffer[128];
+  if (FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
+      NULL, error, 0, buffer, sizeof(buffer)/sizeof(char), NULL))
+    lua_pushstring(L, buffer);
+  else
+    lua_pushfstring(L, "system error %d\n", error);
+}
+
+static void ll_unloadlib (void *lib) {
+  FreeLibrary((HMODULE)lib);
+}
+
+
+static void *ll_load (lua_State *L, const char *path, int seeglb) {
+  HMODULE lib = LoadLibraryExA(path, NULL, LUA_LLE_FLAGS);
+  (void)(seeglb);  /* not used: symbols are 'global' by default */
+  if (lib == NULL) pusherror(L);
+  return lib;
+}
+
+
+static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
+  lua_CFunction f = (lua_CFunction)GetProcAddress((HMODULE)lib, sym);
+  if (f == NULL) pusherror(L);
+  return f;
+}
+
+/* }====================================================== */
+
+
+#else
+/*
+** {======================================================
+** Fallback for other systems
+** =======================================================
+*/
+
+#undef LIB_FAIL
+#define LIB_FAIL	"absent"
+
+
+#define DLMSG	"dynamic libraries not enabled; check your Lua installation"
+
+
+static void ll_unloadlib (void *lib) {
+  (void)(lib);  /* not used */
+}
+
+
+static void *ll_load (lua_State *L, const char *path, int seeglb) {
+  (void)(path); (void)(seeglb);  /* not used */
+  lua_pushliteral(L, DLMSG);
+  return NULL;
+}
+
+
+static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
+  (void)(lib); (void)(sym);  /* not used */
+  lua_pushliteral(L, DLMSG);
+  return NULL;
+}
+
+/* }====================================================== */
+#endif
+
+
+static void *ll_checkclib (lua_State *L, const char *path) {
+  void *plib;
+  lua_getfield(L, LUA_REGISTRYINDEX, CLIBS);
+  lua_getfield(L, -1, path);
+  plib = lua_touserdata(L, -1);  /* plib = CLIBS[path] */
+  lua_pop(L, 2);  /* pop CLIBS table and 'plib' */
+  return plib;
+}
+
+
+static void ll_addtoclib (lua_State *L, const char *path, void *plib) {
+  lua_getfield(L, LUA_REGISTRYINDEX, CLIBS);
+  lua_pushlightuserdata(L, plib);
+  lua_pushvalue(L, -1);
+  lua_setfield(L, -3, path);  /* CLIBS[path] = plib */
+  lua_rawseti(L, -2, luaL_len(L, -2) + 1);  /* CLIBS[#CLIBS + 1] = plib */
+  lua_pop(L, 1);  /* pop CLIBS table */
+}
+
+
+/*
+** __gc tag method for CLIBS table: calls 'll_unloadlib' for all lib
+** handles in list CLIBS
+*/
+static int gctm (lua_State *L) {
+  int n = luaL_len(L, 1);
+  for (; n >= 1; n--) {  /* for each handle, in reverse order */
+    lua_rawgeti(L, 1, n);  /* get handle CLIBS[n] */
+    ll_unloadlib(lua_touserdata(L, -1));
+    lua_pop(L, 1);  /* pop handle */
+  }
+  return 0;
+}
+
+
+static int ll_loadfunc (lua_State *L, const char *path, const char *sym) {
+  void *reg = ll_checkclib(L, path);  /* check loaded C libraries */
+  if (reg == NULL) {  /* must load library? */
+    reg = ll_load(L, path, *sym == '*');
+    if (reg == NULL) return ERRLIB;  /* unable to load library */
+    ll_addtoclib(L, path, reg);
+  }
+  if (*sym == '*') {  /* loading only library (no function)? */
+    lua_pushboolean(L, 1);  /* return 'true' */
+    return 0;  /* no errors */
+  }
+  else {
+    lua_CFunction f = ll_sym(L, reg, sym);
+    if (f == NULL)
+      return ERRFUNC;  /* unable to find function */
+    lua_pushcfunction(L, f);  /* else create new function */
+    return 0;  /* no errors */
+  }
+}
+
+
+static int ll_loadlib (lua_State *L) {
+  const char *path = luaL_checkstring(L, 1);
+  const char *init = luaL_checkstring(L, 2);
+  int stat = ll_loadfunc(L, path, init);
+  if (stat == 0)  /* no errors? */
+    return 1;  /* return the loaded function */
+  else {  /* error; error message is on stack top */
+    lua_pushnil(L);
+    lua_insert(L, -2);
+    lua_pushstring(L, (stat == ERRLIB) ?  LIB_FAIL : "init");
+    return 3;  /* return nil, error message, and where */
+  }
+}
+
+
+
+/*
+** {======================================================
+** 'require' function
+** =======================================================
+*/
+
+
+static int readable (const char *filename) {
+  FILE *f = fopen(filename, "r");  /* try to open file */
+  if (f == NULL) return 0;  /* open failed */
+  fclose(f);
+  return 1;
+}
+
+
+static const char *pushnexttemplate (lua_State *L, const char *path) {
+  const char *l;
+  while (*path == *LUA_PATH_SEP) path++;  /* skip separators */
+  if (*path == '\0') return NULL;  /* no more templates */
+  l = strchr(path, *LUA_PATH_SEP);  /* find next separator */
+  if (l == NULL) l = path + strlen(path);
+  lua_pushlstring(L, path, l - path);  /* template */
+  return l;
+}
+
+
+static const char *searchpath (lua_State *L, const char *name,
+                                             const char *path,
+                                             const char *sep,
+                                             const char *dirsep) {
+  luaL_Buffer msg;  /* to build error message */
+  luaL_buffinit(L, &msg);
+  if (*sep != '\0')  /* non-empty separator? */
+    name = luaL_gsub(L, name, sep, dirsep);  /* replace it by 'dirsep' */
+  while ((path = pushnexttemplate(L, path)) != NULL) {
+    const char *filename = luaL_gsub(L, lua_tostring(L, -1),
+                                     LUA_PATH_MARK, name);
+    lua_remove(L, -2);  /* remove path template */
+    if (readable(filename))  /* does file exist and is readable? */
+      return filename;  /* return that file name */
+    lua_pushfstring(L, "\n\tno file " LUA_QS, filename);
+    lua_remove(L, -2);  /* remove file name */
+    luaL_addvalue(&msg);  /* concatenate error msg. entry */
+  }
+  luaL_pushresult(&msg);  /* create error message */
+  return NULL;  /* not found */
+}
+
+
+static int ll_searchpath (lua_State *L) {
+  const char *f = searchpath(L, luaL_checkstring(L, 1),
+                                luaL_checkstring(L, 2),
+                                luaL_optstring(L, 3, "."),
+                                luaL_optstring(L, 4, LUA_DIRSEP));
+  if (f != NULL) return 1;
+  else {  /* error message is on top of the stack */
+    lua_pushnil(L);
+    lua_insert(L, -2);
+    return 2;  /* return nil + error message */
+  }
+}
+
+
+static const char *findfile (lua_State *L, const char *name,
+                                           const char *pname,
+                                           const char *dirsep) {
+  const char *path;
+  lua_getfield(L, lua_upvalueindex(1), pname);
+  path = lua_tostring(L, -1);
+  if (path == NULL)
+    luaL_error(L, LUA_QL("package.%s") " must be a string", pname);
+  return searchpath(L, name, path, ".", dirsep);
+}
+
+
+static int checkload (lua_State *L, int stat, const char *filename) {
+  if (stat) {  /* module loaded successfully? */
+    lua_pushstring(L, filename);  /* will be 2nd argument to module */
+    return 2;  /* return open function and file name */
+  }
+  else
+    return luaL_error(L, "error loading module " LUA_QS
+                         " from file " LUA_QS ":\n\t%s",
+                          lua_tostring(L, 1), filename, lua_tostring(L, -1));
+}
+
+
+static int searcher_Lua (lua_State *L) {
+  const char *filename;
+  const char *name = luaL_checkstring(L, 1);
+  filename = findfile(L, name, "path", LUA_LSUBSEP);
+  if (filename == NULL) return 1;  /* module not found in this path */
+  return checkload(L, (luaL_loadfile(L, filename) == LUA_OK), filename);
+}
+
+
+static int loadfunc (lua_State *L, const char *filename, const char *modname) {
+  const char *funcname;
+  const char *mark;
+  modname = luaL_gsub(L, modname, ".", LUA_OFSEP);
+  mark = strchr(modname, *LUA_IGMARK);
+  if (mark) {
+    int stat;
+    funcname = lua_pushlstring(L, modname, mark - modname);
+    funcname = lua_pushfstring(L, LUA_POF"%s", funcname);
+    stat = ll_loadfunc(L, filename, funcname);
+    if (stat != ERRFUNC) return stat;
+    modname = mark + 1;  /* else go ahead and try old-style name */
+  }
+  funcname = lua_pushfstring(L, LUA_POF"%s", modname);
+  return ll_loadfunc(L, filename, funcname);
+}
+
+
+static int searcher_C (lua_State *L) {
+  const char *name = luaL_checkstring(L, 1);
+  const char *filename = findfile(L, name, "cpath", LUA_CSUBSEP);
+  if (filename == NULL) return 1;  /* module not found in this path */
+  return checkload(L, (loadfunc(L, filename, name) == 0), filename);
+}
+
+
+static int searcher_Croot (lua_State *L) {
+  const char *filename;
+  const char *name = luaL_checkstring(L, 1);
+  const char *p = strchr(name, '.');
+  int stat;
+  if (p == NULL) return 0;  /* is root */
+  lua_pushlstring(L, name, p - name);
+  filename = findfile(L, lua_tostring(L, -1), "cpath", LUA_CSUBSEP);
+  if (filename == NULL) return 1;  /* root not found */
+  if ((stat = loadfunc(L, filename, name)) != 0) {
+    if (stat != ERRFUNC)
+      return checkload(L, 0, filename);  /* real error */
+    else {  /* open function not found */
+      lua_pushfstring(L, "\n\tno module " LUA_QS " in file " LUA_QS,
+                         name, filename);
+      return 1;
+    }
+  }
+  lua_pushstring(L, filename);  /* will be 2nd argument to module */
+  return 2;
+}
+
+
+static int searcher_preload (lua_State *L) {
+  const char *name = luaL_checkstring(L, 1);
+  lua_getfield(L, LUA_REGISTRYINDEX, "_PRELOAD");
+  lua_getfield(L, -1, name);
+  if (lua_isnil(L, -1))  /* not found? */
+    lua_pushfstring(L, "\n\tno field package.preload['%s']", name);
+  return 1;
+}
+
+
+static void findloader (lua_State *L, const char *name) {
+  int i;
+  luaL_Buffer msg;  /* to build error message */
+  luaL_buffinit(L, &msg);
+  lua_getfield(L, lua_upvalueindex(1), "searchers");  /* will be at index 3 */
+  if (!lua_istable(L, 3))
+    luaL_error(L, LUA_QL("package.searchers") " must be a table");
+  /*  iterate over available searchers to find a loader */
+  for (i = 1; ; i++) {
+    lua_rawgeti(L, 3, i);  /* get a searcher */
+    if (lua_isnil(L, -1)) {  /* no more searchers? */
+      lua_pop(L, 1);  /* remove nil */
+      luaL_pushresult(&msg);  /* create error message */
+      luaL_error(L, "module " LUA_QS " not found:%s",
+                    name, lua_tostring(L, -1));
+    }
+    lua_pushstring(L, name);
+    lua_call(L, 1, 2);  /* call it */
+    if (lua_isfunction(L, -2))  /* did it find a loader? */
+      return;  /* module loader found */
+    else if (lua_isstring(L, -2)) {  /* searcher returned error message? */
+      lua_pop(L, 1);  /* remove extra return */
+      luaL_addvalue(&msg);  /* concatenate error message */
+    }
+    else
+      lua_pop(L, 2);  /* remove both returns */
+  }
+}
+
+
+static int ll_require (lua_State *L) {
+  const char *name = luaL_checkstring(L, 1);
+  lua_settop(L, 1);  /* _LOADED table will be at index 2 */
+  lua_getfield(L, LUA_REGISTRYINDEX, "_LOADED");
+  lua_getfield(L, 2, name);  /* _LOADED[name] */
+  if (lua_toboolean(L, -1))  /* is it there? */
+    return 1;  /* package is already loaded */
+  /* else must load package */
+  lua_pop(L, 1);  /* remove 'getfield' result */
+  findloader(L, name);
+  lua_pushstring(L, name);  /* pass name as argument to module loader */
+  lua_insert(L, -2);  /* name is 1st argument (before search data) */
+  lua_call(L, 2, 1);  /* run loader to load module */
+  if (!lua_isnil(L, -1))  /* non-nil return? */
+    lua_setfield(L, 2, name);  /* _LOADED[name] = returned value */
+  lua_getfield(L, 2, name);
+  if (lua_isnil(L, -1)) {   /* module did not set a value? */
+    lua_pushboolean(L, 1);  /* use true as result */
+    lua_pushvalue(L, -1);  /* extra copy to be returned */
+    lua_setfield(L, 2, name);  /* _LOADED[name] = true */
+  }
+  return 1;
+}
+
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** 'module' function
+** =======================================================
+*/
+#if defined(LUA_COMPAT_MODULE)
+
+/*
+** changes the environment variable of calling function
+*/
+static void set_env (lua_State *L) {
+  lua_Debug ar;
+  if (lua_getstack(L, 1, &ar) == 0 ||
+      lua_getinfo(L, "f", &ar) == 0 ||  /* get calling function */
+      lua_iscfunction(L, -1))
+    luaL_error(L, LUA_QL("module") " not called from a Lua function");
+  lua_pushvalue(L, -2);  /* copy new environment table to top */
+  lua_setupvalue(L, -2, 1);
+  lua_pop(L, 1);  /* remove function */
+}
+
+
+static void dooptions (lua_State *L, int n) {
+  int i;
+  for (i = 2; i <= n; i++) {
+    if (lua_isfunction(L, i)) {  /* avoid 'calling' extra info. */
+      lua_pushvalue(L, i);  /* get option (a function) */
+      lua_pushvalue(L, -2);  /* module */
+      lua_call(L, 1, 0);
+    }
+  }
+}
+
+
+static void modinit (lua_State *L, const char *modname) {
+  const char *dot;
+  lua_pushvalue(L, -1);
+  lua_setfield(L, -2, "_M");  /* module._M = module */
+  lua_pushstring(L, modname);
+  lua_setfield(L, -2, "_NAME");
+  dot = strrchr(modname, '.');  /* look for last dot in module name */
+  if (dot == NULL) dot = modname;
+  else dot++;
+  /* set _PACKAGE as package name (full module name minus last part) */
+  lua_pushlstring(L, modname, dot - modname);
+  lua_setfield(L, -2, "_PACKAGE");
+}
+
+
+static int ll_module (lua_State *L) {
+  const char *modname = luaL_checkstring(L, 1);
+  int lastarg = lua_gettop(L);  /* last parameter */
+  luaL_pushmodule(L, modname, 1);  /* get/create module table */
+  /* check whether table already has a _NAME field */
+  lua_getfield(L, -1, "_NAME");
+  if (!lua_isnil(L, -1))  /* is table an initialized module? */
+    lua_pop(L, 1);
+  else {  /* no; initialize it */
+    lua_pop(L, 1);
+    modinit(L, modname);
+  }
+  lua_pushvalue(L, -1);
+  set_env(L);
+  dooptions(L, lastarg);
+  return 1;
+}
+
+
+static int ll_seeall (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  if (!lua_getmetatable(L, 1)) {
+    lua_createtable(L, 0, 1); /* create new metatable */
+    lua_pushvalue(L, -1);
+    lua_setmetatable(L, 1);
+  }
+  lua_pushglobaltable(L);
+  lua_setfield(L, -2, "__index");  /* mt.__index = _G */
+  return 0;
+}
+
+#endif
+/* }====================================================== */
+
+
+
+/* auxiliary mark (for internal use) */
+#define AUXMARK		"\1"
+
+
+/*
+** return registry.LUA_NOENV as a boolean
+*/
+static int noenv (lua_State *L) {
+  int b;
+  lua_getfield(L, LUA_REGISTRYINDEX, "LUA_NOENV");
+  b = lua_toboolean(L, -1);
+  lua_pop(L, 1);  /* remove value */
+  return b;
+}
+
+
+static void setpath (lua_State *L, const char *fieldname, const char *envname1,
+                                   const char *envname2, const char *def) {
+  const char *path = getenv(envname1);
+  if (path == NULL)  /* no environment variable? */
+    path = getenv(envname2);  /* try alternative name */
+  if (path == NULL || noenv(L))  /* no environment variable? */
+    lua_pushstring(L, def);  /* use default */
+  else {
+    /* replace ";;" by ";AUXMARK;" and then AUXMARK by default path */
+    path = luaL_gsub(L, path, LUA_PATH_SEP LUA_PATH_SEP,
+                              LUA_PATH_SEP AUXMARK LUA_PATH_SEP);
+    luaL_gsub(L, path, AUXMARK, def);
+    lua_remove(L, -2);
+  }
+  setprogdir(L);
+  lua_setfield(L, -2, fieldname);
+}
+
+
+static const luaL_Reg pk_funcs[] = {
+  {"loadlib", ll_loadlib},
+  {"searchpath", ll_searchpath},
+#if defined(LUA_COMPAT_MODULE)
+  {"seeall", ll_seeall},
+#endif
+  {NULL, NULL}
+};
+
+
+static const luaL_Reg ll_funcs[] = {
+#if defined(LUA_COMPAT_MODULE)
+  {"module", ll_module},
+#endif
+  {"require", ll_require},
+  {NULL, NULL}
+};
+
+
+static void createsearcherstable (lua_State *L) {
+  static const lua_CFunction searchers[] =
+    {searcher_preload, searcher_Lua, searcher_C, searcher_Croot, NULL};
+  int i;
+  /* create 'searchers' table */
+  lua_createtable(L, sizeof(searchers)/sizeof(searchers[0]) - 1, 0);
+  /* fill it with pre-defined searchers */
+  for (i=0; searchers[i] != NULL; i++) {
+    lua_pushvalue(L, -2);  /* set 'package' as upvalue for all searchers */
+    lua_pushcclosure(L, searchers[i], 1);
+    lua_rawseti(L, -2, i+1);
+  }
+}
+
+
+LUAMOD_API int luaopen_package (lua_State *L) {
+  /* create table CLIBS to keep track of loaded C libraries */
+  luaL_getsubtable(L, LUA_REGISTRYINDEX, CLIBS);
+  lua_createtable(L, 0, 1);  /* metatable for CLIBS */
+  lua_pushcfunction(L, gctm);
+  lua_setfield(L, -2, "__gc");  /* set finalizer for CLIBS table */
+  lua_setmetatable(L, -2);
+  /* create `package' table */
+  luaL_newlib(L, pk_funcs);
+  createsearcherstable(L);
+#if defined(LUA_COMPAT_LOADERS)
+  lua_pushvalue(L, -1);  /* make a copy of 'searchers' table */
+  lua_setfield(L, -3, "loaders");  /* put it in field `loaders' */
+#endif
+  lua_setfield(L, -2, "searchers");  /* put it in field 'searchers' */
+  /* set field 'path' */
+  setpath(L, "path", LUA_PATHVERSION, LUA_PATH, LUA_PATH_DEFAULT);
+  /* set field 'cpath' */
+  setpath(L, "cpath", LUA_CPATHVERSION, LUA_CPATH, LUA_CPATH_DEFAULT);
+  /* store config information */
+  lua_pushliteral(L, LUA_DIRSEP "\n" LUA_PATH_SEP "\n" LUA_PATH_MARK "\n"
+                     LUA_EXEC_DIR "\n" LUA_IGMARK "\n");
+  lua_setfield(L, -2, "config");
+  /* set field `loaded' */
+  luaL_getsubtable(L, LUA_REGISTRYINDEX, "_LOADED");
+  lua_setfield(L, -2, "loaded");
+  /* set field `preload' */
+  luaL_getsubtable(L, LUA_REGISTRYINDEX, "_PRELOAD");
+  lua_setfield(L, -2, "preload");
+  lua_pushglobaltable(L);
+  lua_pushvalue(L, -2);  /* set 'package' as upvalue for next lib */
+  luaL_setfuncs(L, ll_funcs, 1);  /* open lib into global table */
+  lua_pop(L, 1);  /* pop global table */
+  return 1;  /* return 'package' table */
+}
+
diff -ruNp src.orig/libs/lua/lobject.c src/libs/lua/lobject.c
--- src.orig/libs/lua/lobject.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lobject.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,287 @@
+/*
+** $Id: lobject.c,v 2.58 2013/02/20 14:08:56 roberto Exp $
+** Some generic functions over Lua objects
+** See Copyright Notice in lua.h
+*/
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define lobject_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lctype.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "lvm.h"
+
+
+
+LUAI_DDEF const TValue luaO_nilobject_ = {NILCONSTANT};
+
+
+/*
+** converts an integer to a "floating point byte", represented as
+** (eeeeexxx), where the real value is (1xxx) * 2^(eeeee - 1) if
+** eeeee != 0 and (xxx) otherwise.
+*/
+int luaO_int2fb (unsigned int x) {
+  int e = 0;  /* exponent */
+  if (x < 8) return x;
+  while (x >= 0x10) {
+    x = (x+1) >> 1;
+    e++;
+  }
+  return ((e+1) << 3) | (cast_int(x) - 8);
+}
+
+
+/* converts back */
+int luaO_fb2int (int x) {
+  int e = (x >> 3) & 0x1f;
+  if (e == 0) return x;
+  else return ((x & 7) + 8) << (e - 1);
+}
+
+
+int luaO_ceillog2 (unsigned int x) {
+  static const lu_byte log_2[256] = {
+    0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
+    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
+    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
+    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8
+  };
+  int l = 0;
+  x--;
+  while (x >= 256) { l += 8; x >>= 8; }
+  return l + log_2[x];
+}
+
+
+lua_Number luaO_arith (int op, lua_Number v1, lua_Number v2) {
+  switch (op) {
+    case LUA_OPADD: return luai_numadd(NULL, v1, v2);
+    case LUA_OPSUB: return luai_numsub(NULL, v1, v2);
+    case LUA_OPMUL: return luai_nummul(NULL, v1, v2);
+    case LUA_OPDIV: return luai_numdiv(NULL, v1, v2);
+    case LUA_OPMOD: return luai_nummod(NULL, v1, v2);
+    case LUA_OPPOW: return luai_numpow(NULL, v1, v2);
+    case LUA_OPUNM: return luai_numunm(NULL, v1);
+    default: lua_assert(0); return 0;
+  }
+}
+
+
+int luaO_hexavalue (int c) {
+  if (lisdigit(c)) return c - '0';
+  else return ltolower(c) - 'a' + 10;
+}
+
+
+#if !defined(lua_strx2number)
+
+#include <math.h>
+
+
+static int isneg (const char **s) {
+  if (**s == '-') { (*s)++; return 1; }
+  else if (**s == '+') (*s)++;
+  return 0;
+}
+
+
+static lua_Number readhexa (const char **s, lua_Number r, int *count) {
+  for (; lisxdigit(cast_uchar(**s)); (*s)++) {  /* read integer part */
+    r = (r * cast_num(16.0)) + cast_num(luaO_hexavalue(cast_uchar(**s)));
+    (*count)++;
+  }
+  return r;
+}
+
+
+/*
+** convert an hexadecimal numeric string to a number, following
+** C99 specification for 'strtod'
+*/
+static lua_Number lua_strx2number (const char *s, char **endptr) {
+  lua_Number r = 0.0;
+  int e = 0, i = 0;
+  int neg = 0;  /* 1 if number is negative */
+  *endptr = cast(char *, s);  /* nothing is valid yet */
+  while (lisspace(cast_uchar(*s))) s++;  /* skip initial spaces */
+  neg = isneg(&s);  /* check signal */
+  if (!(*s == '0' && (*(s + 1) == 'x' || *(s + 1) == 'X')))  /* check '0x' */
+    return 0.0;  /* invalid format (no '0x') */
+  s += 2;  /* skip '0x' */
+  r = readhexa(&s, r, &i);  /* read integer part */
+  if (*s == '.') {
+    s++;  /* skip dot */
+    r = readhexa(&s, r, &e);  /* read fractional part */
+  }
+  if (i == 0 && e == 0)
+    return 0.0;  /* invalid format (no digit) */
+  e *= -4;  /* each fractional digit divides value by 2^-4 */
+  *endptr = cast(char *, s);  /* valid up to here */
+  if (*s == 'p' || *s == 'P') {  /* exponent part? */
+    int exp1 = 0;
+    int neg1;
+    s++;  /* skip 'p' */
+    neg1 = isneg(&s);  /* signal */
+    if (!lisdigit(cast_uchar(*s)))
+      goto ret;  /* must have at least one digit */
+    while (lisdigit(cast_uchar(*s)))  /* read exponent */
+      exp1 = exp1 * 10 + *(s++) - '0';
+    if (neg1) exp1 = -exp1;
+    e += exp1;
+  }
+  *endptr = cast(char *, s);  /* valid up to here */
+ ret:
+  if (neg) r = -r;
+  return l_mathop(ldexp)(r, e);
+}
+
+#endif
+
+
+int luaO_str2d (const char *s, size_t len, lua_Number *result) {
+  char *endptr;
+  if (strpbrk(s, "nN"))  /* reject 'inf' and 'nan' */
+    return 0;
+  else if (strpbrk(s, "xX"))  /* hexa? */
+    *result = lua_strx2number(s, &endptr);
+  else
+    *result = lua_str2number(s, &endptr);
+  if (endptr == s) return 0;  /* nothing recognized */
+  while (lisspace(cast_uchar(*endptr))) endptr++;
+  return (endptr == s + len);  /* OK if no trailing characters */
+}
+
+
+
+static void pushstr (lua_State *L, const char *str, size_t l) {
+  setsvalue2s(L, L->top++, luaS_newlstr(L, str, l));
+}
+
+
+/* this function handles only `%d', `%c', %f, %p, and `%s' formats */
+const char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp) {
+  int n = 0;
+  for (;;) {
+    const char *e = strchr(fmt, '%');
+    if (e == NULL) break;
+    luaD_checkstack(L, 2);  /* fmt + item */
+    pushstr(L, fmt, e - fmt);
+    switch (*(e+1)) {
+      case 's': {
+        const char *s = va_arg(argp, char *);
+        if (s == NULL) s = "(null)";
+        pushstr(L, s, strlen(s));
+        break;
+      }
+      case 'c': {
+        char buff;
+        buff = cast(char, va_arg(argp, int));
+        pushstr(L, &buff, 1);
+        break;
+      }
+      case 'd': {
+        setnvalue(L->top++, cast_num(va_arg(argp, int)));
+        break;
+      }
+      case 'f': {
+        setnvalue(L->top++, cast_num(va_arg(argp, l_uacNumber)));
+        break;
+      }
+      case 'p': {
+        char buff[4*sizeof(void *) + 8]; /* should be enough space for a `%p' */
+        int l = sprintf(buff, "%p", va_arg(argp, void *));
+        pushstr(L, buff, l);
+        break;
+      }
+      case '%': {
+        pushstr(L, "%", 1);
+        break;
+      }
+      default: {
+        luaG_runerror(L,
+            "invalid option " LUA_QL("%%%c") " to " LUA_QL("lua_pushfstring"),
+            *(e + 1));
+      }
+    }
+    n += 2;
+    fmt = e+2;
+  }
+  luaD_checkstack(L, 1);
+  pushstr(L, fmt, strlen(fmt));
+  if (n > 0) luaV_concat(L, n + 1);
+  return svalue(L->top - 1);
+}
+
+
+const char *luaO_pushfstring (lua_State *L, const char *fmt, ...) {
+  const char *msg;
+  va_list argp;
+  va_start(argp, fmt);
+  msg = luaO_pushvfstring(L, fmt, argp);
+  va_end(argp);
+  return msg;
+}
+
+
+/* number of chars of a literal string without the ending \0 */
+#define LL(x)	(sizeof(x)/sizeof(char) - 1)
+
+#define RETS	"..."
+#define PRE	"[string \""
+#define POS	"\"]"
+
+#define addstr(a,b,l)	( memcpy(a,b,(l) * sizeof(char)), a += (l) )
+
+void luaO_chunkid (char *out, const char *source, size_t bufflen) {
+  size_t l = strlen(source);
+  if (*source == '=') {  /* 'literal' source */
+    if (l <= bufflen)  /* small enough? */
+      memcpy(out, source + 1, l * sizeof(char));
+    else {  /* truncate it */
+      addstr(out, source + 1, bufflen - 1);
+      *out = '\0';
+    }
+  }
+  else if (*source == '@') {  /* file name */
+    if (l <= bufflen)  /* small enough? */
+      memcpy(out, source + 1, l * sizeof(char));
+    else {  /* add '...' before rest of name */
+      addstr(out, RETS, LL(RETS));
+      bufflen -= LL(RETS);
+      memcpy(out, source + 1 + l - bufflen, bufflen * sizeof(char));
+    }
+  }
+  else {  /* string; format as [string "source"] */
+    const char *nl = strchr(source, '\n');  /* find first new line (if any) */
+    addstr(out, PRE, LL(PRE));  /* add prefix */
+    bufflen -= LL(PRE RETS POS) + 1;  /* save space for prefix+suffix+'\0' */
+    if (l < bufflen && nl == NULL) {  /* small one-line source? */
+      addstr(out, source, l);  /* keep it */
+    }
+    else {
+      if (nl != NULL) l = nl - source;  /* stop at first newline */
+      if (l > bufflen) l = bufflen;
+      addstr(out, source, l);
+      addstr(out, RETS, LL(RETS));
+    }
+    memcpy(out, POS, (LL(POS) + 1) * sizeof(char));
+  }
+}
+
diff -ruNp src.orig/libs/lua/lobject.h src/libs/lua/lobject.h
--- src.orig/libs/lua/lobject.h	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lobject.h	2017-11-21 19:39:46 -0600
@@ -0,0 +1,607 @@
+/*
+** $Id: lobject.h,v 2.71 2012/09/11 18:21:44 roberto Exp $
+** Type definitions for Lua objects
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lobject_h
+#define lobject_h
+
+
+#include <stdarg.h>
+
+
+#include "llimits.h"
+#include "lua.h"
+
+
+/*
+** Extra tags for non-values
+*/
+#define LUA_TPROTO	LUA_NUMTAGS
+#define LUA_TUPVAL	(LUA_NUMTAGS+1)
+#define LUA_TDEADKEY	(LUA_NUMTAGS+2)
+
+/*
+** number of all possible tags (including LUA_TNONE but excluding DEADKEY)
+*/
+#define LUA_TOTALTAGS	(LUA_TUPVAL+2)
+
+
+/*
+** tags for Tagged Values have the following use of bits:
+** bits 0-3: actual tag (a LUA_T* value)
+** bits 4-5: variant bits
+** bit 6: whether value is collectable
+*/
+
+#define VARBITS		(3 << 4)
+
+
+/*
+** LUA_TFUNCTION variants:
+** 0 - Lua function
+** 1 - light C function
+** 2 - regular C function (closure)
+*/
+
+/* Variant tags for functions */
+#define LUA_TLCL	(LUA_TFUNCTION | (0 << 4))  /* Lua closure */
+#define LUA_TLCF	(LUA_TFUNCTION | (1 << 4))  /* light C function */
+#define LUA_TCCL	(LUA_TFUNCTION | (2 << 4))  /* C closure */
+
+
+/* Variant tags for strings */
+#define LUA_TSHRSTR	(LUA_TSTRING | (0 << 4))  /* short strings */
+#define LUA_TLNGSTR	(LUA_TSTRING | (1 << 4))  /* long strings */
+
+
+/* Bit mark for collectable types */
+#define BIT_ISCOLLECTABLE	(1 << 6)
+
+/* mark a tag as collectable */
+#define ctb(t)			((t) | BIT_ISCOLLECTABLE)
+
+
+/*
+** Union of all collectable objects
+*/
+typedef union GCObject GCObject;
+
+
+/*
+** Common Header for all collectable objects (in macro form, to be
+** included in other objects)
+*/
+#define CommonHeader	GCObject *next; lu_byte tt; lu_byte marked
+
+
+/*
+** Common header in struct form
+*/
+typedef struct GCheader {
+  CommonHeader;
+} GCheader;
+
+
+
+/*
+** Union of all Lua values
+*/
+typedef union Value Value;
+
+
+#define numfield	lua_Number n;    /* numbers */
+
+
+
+/*
+** Tagged Values. This is the basic representation of values in Lua,
+** an actual value plus a tag with its type.
+*/
+
+#define TValuefields	Value value_; int tt_
+
+typedef struct lua_TValue TValue;
+
+
+/* macro defining a nil value */
+#define NILCONSTANT	{NULL}, LUA_TNIL
+
+
+#define val_(o)		((o)->value_)
+#define num_(o)		(val_(o).n)
+
+
+/* raw type tag of a TValue */
+#define rttype(o)	((o)->tt_)
+
+/* tag with no variants (bits 0-3) */
+#define novariant(x)	((x) & 0x0F)
+
+/* type tag of a TValue (bits 0-3 for tags + variant bits 4-5) */
+#define ttype(o)	(rttype(o) & 0x3F)
+
+/* type tag of a TValue with no variants (bits 0-3) */
+#define ttypenv(o)	(novariant(rttype(o)))
+
+
+/* Macros to test type */
+#define checktag(o,t)		(rttype(o) == (t))
+#define checktype(o,t)		(ttypenv(o) == (t))
+#define ttisnumber(o)		checktag((o), LUA_TNUMBER)
+#define ttisnil(o)		checktag((o), LUA_TNIL)
+#define ttisboolean(o)		checktag((o), LUA_TBOOLEAN)
+#define ttislightuserdata(o)	checktag((o), LUA_TLIGHTUSERDATA)
+#define ttisstring(o)		checktype((o), LUA_TSTRING)
+#define ttisshrstring(o)	checktag((o), ctb(LUA_TSHRSTR))
+#define ttislngstring(o)	checktag((o), ctb(LUA_TLNGSTR))
+#define ttistable(o)		checktag((o), ctb(LUA_TTABLE))
+#define ttisfunction(o)		checktype(o, LUA_TFUNCTION)
+#define ttisclosure(o)		((rttype(o) & 0x1F) == LUA_TFUNCTION)
+#define ttisCclosure(o)		checktag((o), ctb(LUA_TCCL))
+#define ttisLclosure(o)		checktag((o), ctb(LUA_TLCL))
+#define ttislcf(o)		checktag((o), LUA_TLCF)
+#define ttisuserdata(o)		checktag((o), ctb(LUA_TUSERDATA))
+#define ttisthread(o)		checktag((o), ctb(LUA_TTHREAD))
+#define ttisdeadkey(o)		checktag((o), LUA_TDEADKEY)
+
+#define ttisequal(o1,o2)	(rttype(o1) == rttype(o2))
+
+/* Macros to access values */
+#define nvalue(o)	check_exp(ttisnumber(o), num_(o))
+#define gcvalue(o)	check_exp(iscollectable(o), val_(o).gc)
+#define pvalue(o)	check_exp(ttislightuserdata(o), val_(o).p)
+#define rawtsvalue(o)	check_exp(ttisstring(o), &val_(o).gc->ts)
+#define tsvalue(o)	(&rawtsvalue(o)->tsv)
+#define rawuvalue(o)	check_exp(ttisuserdata(o), &val_(o).gc->u)
+#define uvalue(o)	(&rawuvalue(o)->uv)
+#define clvalue(o)	check_exp(ttisclosure(o), &val_(o).gc->cl)
+#define clLvalue(o)	check_exp(ttisLclosure(o), &val_(o).gc->cl.l)
+#define clCvalue(o)	check_exp(ttisCclosure(o), &val_(o).gc->cl.c)
+#define fvalue(o)	check_exp(ttislcf(o), val_(o).f)
+#define hvalue(o)	check_exp(ttistable(o), &val_(o).gc->h)
+#define bvalue(o)	check_exp(ttisboolean(o), val_(o).b)
+#define thvalue(o)	check_exp(ttisthread(o), &val_(o).gc->th)
+/* a dead value may get the 'gc' field, but cannot access its contents */
+#define deadvalue(o)	check_exp(ttisdeadkey(o), cast(void *, val_(o).gc))
+
+#define l_isfalse(o)	(ttisnil(o) || (ttisboolean(o) && bvalue(o) == 0))
+
+
+#define iscollectable(o)	(rttype(o) & BIT_ISCOLLECTABLE)
+
+
+/* Macros for internal tests */
+#define righttt(obj)		(ttype(obj) == gcvalue(obj)->gch.tt)
+
+#define checkliveness(g,obj) \
+	lua_longassert(!iscollectable(obj) || \
+			(righttt(obj) && !isdead(g,gcvalue(obj))))
+
+
+/* Macros to set values */
+#define settt_(o,t)	((o)->tt_=(t))
+
+#define setnvalue(obj,x) \
+  { TValue *io=(obj); num_(io)=(x); settt_(io, LUA_TNUMBER); }
+
+#define setnilvalue(obj) settt_(obj, LUA_TNIL)
+
+#define setfvalue(obj,x) \
+  { TValue *io=(obj); val_(io).f=(x); settt_(io, LUA_TLCF); }
+
+#define setpvalue(obj,x) \
+  { TValue *io=(obj); val_(io).p=(x); settt_(io, LUA_TLIGHTUSERDATA); }
+
+#define setbvalue(obj,x) \
+  { TValue *io=(obj); val_(io).b=(x); settt_(io, LUA_TBOOLEAN); }
+
+#define setgcovalue(L,obj,x) \
+  { TValue *io=(obj); GCObject *i_g=(x); \
+    val_(io).gc=i_g; settt_(io, ctb(gch(i_g)->tt)); }
+
+#define setsvalue(L,obj,x) \
+  { TValue *io=(obj); \
+    TString *x_ = (x); \
+    val_(io).gc=cast(GCObject *, x_); settt_(io, ctb(x_->tsv.tt)); \
+    checkliveness(G(L),io); }
+
+#define setuvalue(L,obj,x) \
+  { TValue *io=(obj); \
+    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TUSERDATA)); \
+    checkliveness(G(L),io); }
+
+#define setthvalue(L,obj,x) \
+  { TValue *io=(obj); \
+    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TTHREAD)); \
+    checkliveness(G(L),io); }
+
+#define setclLvalue(L,obj,x) \
+  { TValue *io=(obj); \
+    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TLCL)); \
+    checkliveness(G(L),io); }
+
+#define setclCvalue(L,obj,x) \
+  { TValue *io=(obj); \
+    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TCCL)); \
+    checkliveness(G(L),io); }
+
+#define sethvalue(L,obj,x) \
+  { TValue *io=(obj); \
+    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TTABLE)); \
+    checkliveness(G(L),io); }
+
+#define setdeadvalue(obj)	settt_(obj, LUA_TDEADKEY)
+
+
+
+#define setobj(L,obj1,obj2) \
+	{ const TValue *io2=(obj2); TValue *io1=(obj1); \
+	  io1->value_ = io2->value_; io1->tt_ = io2->tt_; \
+	  checkliveness(G(L),io1); }
+
+
+/*
+** different types of assignments, according to destination
+*/
+
+/* from stack to (same) stack */
+#define setobjs2s	setobj
+/* to stack (not from same stack) */
+#define setobj2s	setobj
+#define setsvalue2s	setsvalue
+#define sethvalue2s	sethvalue
+#define setptvalue2s	setptvalue
+/* from table to same table */
+#define setobjt2t	setobj
+/* to table */
+#define setobj2t	setobj
+/* to new object */
+#define setobj2n	setobj
+#define setsvalue2n	setsvalue
+
+
+/* check whether a number is valid (useful only for NaN trick) */
+#define luai_checknum(L,o,c)	{ /* empty */ }
+
+
+/*
+** {======================================================
+** NaN Trick
+** =======================================================
+*/
+#if defined(LUA_NANTRICK)
+
+/*
+** numbers are represented in the 'd_' field. All other values have the
+** value (NNMARK | tag) in 'tt__'. A number with such pattern would be
+** a "signaled NaN", which is never generated by regular operations by
+** the CPU (nor by 'strtod')
+*/
+
+/* allows for external implementation for part of the trick */
+#if !defined(NNMARK)	/* { */
+
+
+#if !defined(LUA_IEEEENDIAN)
+#error option 'LUA_NANTRICK' needs 'LUA_IEEEENDIAN'
+#endif
+
+
+#define NNMARK		0x7FF7A500
+#define NNMASK		0x7FFFFF00
+
+#undef TValuefields
+#undef NILCONSTANT
+
+#if (LUA_IEEEENDIAN == 0)	/* { */
+
+/* little endian */
+#define TValuefields  \
+	union { struct { Value v__; int tt__; } i; double d__; } u
+#define NILCONSTANT	{{{NULL}, tag2tt(LUA_TNIL)}}
+/* field-access macros */
+#define v_(o)		((o)->u.i.v__)
+#define d_(o)		((o)->u.d__)
+#define tt_(o)		((o)->u.i.tt__)
+
+#else				/* }{ */
+
+/* big endian */
+#define TValuefields  \
+	union { struct { int tt__; Value v__; } i; double d__; } u
+#define NILCONSTANT	{{tag2tt(LUA_TNIL), {NULL}}}
+/* field-access macros */
+#define v_(o)		((o)->u.i.v__)
+#define d_(o)		((o)->u.d__)
+#define tt_(o)		((o)->u.i.tt__)
+
+#endif				/* } */
+
+#endif			/* } */
+
+
+/* correspondence with standard representation */
+#undef val_
+#define val_(o)		v_(o)
+#undef num_
+#define num_(o)		d_(o)
+
+
+#undef numfield
+#define numfield	/* no such field; numbers are the entire struct */
+
+/* basic check to distinguish numbers from non-numbers */
+#undef ttisnumber
+#define ttisnumber(o)	((tt_(o) & NNMASK) != NNMARK)
+
+#define tag2tt(t)	(NNMARK | (t))
+
+#undef rttype
+#define rttype(o)	(ttisnumber(o) ? LUA_TNUMBER : tt_(o) & 0xff)
+
+#undef settt_
+#define settt_(o,t)	(tt_(o) = tag2tt(t))
+
+#undef setnvalue
+#define setnvalue(obj,x) \
+	{ TValue *io_=(obj); num_(io_)=(x); lua_assert(ttisnumber(io_)); }
+
+#undef setobj
+#define setobj(L,obj1,obj2) \
+	{ const TValue *o2_=(obj2); TValue *o1_=(obj1); \
+	  o1_->u = o2_->u; \
+	  checkliveness(G(L),o1_); }
+
+
+/*
+** these redefinitions are not mandatory, but these forms are more efficient
+*/
+
+#undef checktag
+#undef checktype
+#define checktag(o,t)	(tt_(o) == tag2tt(t))
+#define checktype(o,t)	(ctb(tt_(o) | VARBITS) == ctb(tag2tt(t) | VARBITS))
+
+#undef ttisequal
+#define ttisequal(o1,o2)  \
+	(ttisnumber(o1) ? ttisnumber(o2) : (tt_(o1) == tt_(o2)))
+
+
+#undef luai_checknum
+#define luai_checknum(L,o,c)	{ if (!ttisnumber(o)) c; }
+
+#endif
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** types and prototypes
+** =======================================================
+*/
+
+
+union Value {
+  GCObject *gc;    /* collectable objects */
+  void *p;         /* light userdata */
+  int b;           /* booleans */
+  lua_CFunction f; /* light C functions */
+  numfield         /* numbers */
+};
+
+
+struct lua_TValue {
+  TValuefields;
+};
+
+
+typedef TValue *StkId;  /* index to stack elements */
+
+
+
+
+/*
+** Header for string value; string bytes follow the end of this structure
+*/
+typedef union TString {
+  L_Umaxalign dummy;  /* ensures maximum alignment for strings */
+  struct {
+    CommonHeader;
+    lu_byte extra;  /* reserved words for short strings; "has hash" for longs */
+    unsigned int hash;
+    size_t len;  /* number of characters in string */
+  } tsv;
+} TString;
+
+
+/* get the actual string (array of bytes) from a TString */
+#define getstr(ts)	cast(const char *, (ts) + 1)
+
+/* get the actual string (array of bytes) from a Lua value */
+#define svalue(o)       getstr(rawtsvalue(o))
+
+
+/*
+** Header for userdata; memory area follows the end of this structure
+*/
+typedef union Udata {
+  L_Umaxalign dummy;  /* ensures maximum alignment for `local' udata */
+  struct {
+    CommonHeader;
+    struct Table *metatable;
+    struct Table *env;
+    size_t len;  /* number of bytes */
+  } uv;
+} Udata;
+
+
+
+/*
+** Description of an upvalue for function prototypes
+*/
+typedef struct Upvaldesc {
+  TString *name;  /* upvalue name (for debug information) */
+  lu_byte instack;  /* whether it is in stack */
+  lu_byte idx;  /* index of upvalue (in stack or in outer function's list) */
+} Upvaldesc;
+
+
+/*
+** Description of a local variable for function prototypes
+** (used for debug information)
+*/
+typedef struct LocVar {
+  TString *varname;
+  int startpc;  /* first point where variable is active */
+  int endpc;    /* first point where variable is dead */
+} LocVar;
+
+
+/*
+** Function Prototypes
+*/
+typedef struct Proto {
+  CommonHeader;
+  TValue *k;  /* constants used by the function */
+  Instruction *code;
+  struct Proto **p;  /* functions defined inside the function */
+  int *lineinfo;  /* map from opcodes to source lines (debug information) */
+  LocVar *locvars;  /* information about local variables (debug information) */
+  Upvaldesc *upvalues;  /* upvalue information */
+  union Closure *cache;  /* last created closure with this prototype */
+  TString  *source;  /* used for debug information */
+  int sizeupvalues;  /* size of 'upvalues' */
+  int sizek;  /* size of `k' */
+  int sizecode;
+  int sizelineinfo;
+  int sizep;  /* size of `p' */
+  int sizelocvars;
+  int linedefined;
+  int lastlinedefined;
+  GCObject *gclist;
+  lu_byte numparams;  /* number of fixed parameters */
+  lu_byte is_vararg;
+  lu_byte maxstacksize;  /* maximum stack used by this function */
+} Proto;
+
+
+
+/*
+** Lua Upvalues
+*/
+typedef struct UpVal {
+  CommonHeader;
+  TValue *v;  /* points to stack or to its own value */
+  union {
+    TValue value;  /* the value (when closed) */
+    struct {  /* double linked list (when open) */
+      struct UpVal *prev;
+      struct UpVal *next;
+    } l;
+  } u;
+} UpVal;
+
+
+/*
+** Closures
+*/
+
+#define ClosureHeader \
+	CommonHeader; lu_byte nupvalues; GCObject *gclist
+
+typedef struct CClosure {
+  ClosureHeader;
+  lua_CFunction f;
+  TValue upvalue[1];  /* list of upvalues */
+} CClosure;
+
+
+typedef struct LClosure {
+  ClosureHeader;
+  struct Proto *p;
+  UpVal *upvals[1];  /* list of upvalues */
+} LClosure;
+
+
+typedef union Closure {
+  CClosure c;
+  LClosure l;
+} Closure;
+
+
+#define isLfunction(o)	ttisLclosure(o)
+
+#define getproto(o)	(clLvalue(o)->p)
+
+
+/*
+** Tables
+*/
+
+typedef union TKey {
+  struct {
+    TValuefields;
+    struct Node *next;  /* for chaining */
+  } nk;
+  TValue tvk;
+} TKey;
+
+
+typedef struct Node {
+  TValue i_val;
+  TKey i_key;
+} Node;
+
+
+typedef struct Table {
+  CommonHeader;
+  lu_byte flags;  /* 1<<p means tagmethod(p) is not present */
+  lu_byte lsizenode;  /* log2 of size of `node' array */
+  struct Table *metatable;
+  TValue *array;  /* array part */
+  Node *node;
+  Node *lastfree;  /* any free position is before this position */
+  GCObject *gclist;
+  int sizearray;  /* size of `array' array */
+} Table;
+
+
+
+/*
+** `module' operation for hashing (size is always a power of 2)
+*/
+#define lmod(s,size) \
+	(check_exp((size&(size-1))==0, (cast(int, (s) & ((size)-1)))))
+
+
+#define twoto(x)	(1<<(x))
+#define sizenode(t)	(twoto((t)->lsizenode))
+
+
+/*
+** (address of) a fixed nil value
+*/
+#define luaO_nilobject		(&luaO_nilobject_)
+
+
+LUAI_DDEC const TValue luaO_nilobject_;
+
+
+LUAI_FUNC int luaO_int2fb (unsigned int x);
+LUAI_FUNC int luaO_fb2int (int x);
+LUAI_FUNC int luaO_ceillog2 (unsigned int x);
+LUAI_FUNC lua_Number luaO_arith (int op, lua_Number v1, lua_Number v2);
+LUAI_FUNC int luaO_str2d (const char *s, size_t len, lua_Number *result);
+LUAI_FUNC int luaO_hexavalue (int c);
+LUAI_FUNC const char *luaO_pushvfstring (lua_State *L, const char *fmt,
+                                                       va_list argp);
+LUAI_FUNC const char *luaO_pushfstring (lua_State *L, const char *fmt, ...);
+LUAI_FUNC void luaO_chunkid (char *out, const char *source, size_t len);
+
+
+#endif
+
diff -ruNp src.orig/libs/lua/lopcodes.c src/libs/lua/lopcodes.c
--- src.orig/libs/lua/lopcodes.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lopcodes.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,107 @@
+/*
+** $Id: lopcodes.c,v 1.49 2012/05/14 13:34:18 roberto Exp $
+** Opcodes for Lua virtual machine
+** See Copyright Notice in lua.h
+*/
+
+
+#define lopcodes_c
+#define LUA_CORE
+
+
+#include "lopcodes.h"
+
+
+/* ORDER OP */
+
+LUAI_DDEF const char *const luaP_opnames[NUM_OPCODES+1] = {
+  "MOVE",
+  "LOADK",
+  "LOADKX",
+  "LOADBOOL",
+  "LOADNIL",
+  "GETUPVAL",
+  "GETTABUP",
+  "GETTABLE",
+  "SETTABUP",
+  "SETUPVAL",
+  "SETTABLE",
+  "NEWTABLE",
+  "SELF",
+  "ADD",
+  "SUB",
+  "MUL",
+  "DIV",
+  "MOD",
+  "POW",
+  "UNM",
+  "NOT",
+  "LEN",
+  "CONCAT",
+  "JMP",
+  "EQ",
+  "LT",
+  "LE",
+  "TEST",
+  "TESTSET",
+  "CALL",
+  "TAILCALL",
+  "RETURN",
+  "FORLOOP",
+  "FORPREP",
+  "TFORCALL",
+  "TFORLOOP",
+  "SETLIST",
+  "CLOSURE",
+  "VARARG",
+  "EXTRAARG",
+  NULL
+};
+
+
+#define opmode(t,a,b,c,m) (((t)<<7) | ((a)<<6) | ((b)<<4) | ((c)<<2) | (m))
+
+LUAI_DDEF const lu_byte luaP_opmodes[NUM_OPCODES] = {
+/*       T  A    B       C     mode		   opcode	*/
+  opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_MOVE */
+ ,opmode(0, 1, OpArgK, OpArgN, iABx)		/* OP_LOADK */
+ ,opmode(0, 1, OpArgN, OpArgN, iABx)		/* OP_LOADKX */
+ ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_LOADBOOL */
+ ,opmode(0, 1, OpArgU, OpArgN, iABC)		/* OP_LOADNIL */
+ ,opmode(0, 1, OpArgU, OpArgN, iABC)		/* OP_GETUPVAL */
+ ,opmode(0, 1, OpArgU, OpArgK, iABC)		/* OP_GETTABUP */
+ ,opmode(0, 1, OpArgR, OpArgK, iABC)		/* OP_GETTABLE */
+ ,opmode(0, 0, OpArgK, OpArgK, iABC)		/* OP_SETTABUP */
+ ,opmode(0, 0, OpArgU, OpArgN, iABC)		/* OP_SETUPVAL */
+ ,opmode(0, 0, OpArgK, OpArgK, iABC)		/* OP_SETTABLE */
+ ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_NEWTABLE */
+ ,opmode(0, 1, OpArgR, OpArgK, iABC)		/* OP_SELF */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_ADD */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_SUB */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_MUL */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_DIV */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_MOD */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_POW */
+ ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_UNM */
+ ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_NOT */
+ ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_LEN */
+ ,opmode(0, 1, OpArgR, OpArgR, iABC)		/* OP_CONCAT */
+ ,opmode(0, 0, OpArgR, OpArgN, iAsBx)		/* OP_JMP */
+ ,opmode(1, 0, OpArgK, OpArgK, iABC)		/* OP_EQ */
+ ,opmode(1, 0, OpArgK, OpArgK, iABC)		/* OP_LT */
+ ,opmode(1, 0, OpArgK, OpArgK, iABC)		/* OP_LE */
+ ,opmode(1, 0, OpArgN, OpArgU, iABC)		/* OP_TEST */
+ ,opmode(1, 1, OpArgR, OpArgU, iABC)		/* OP_TESTSET */
+ ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_CALL */
+ ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_TAILCALL */
+ ,opmode(0, 0, OpArgU, OpArgN, iABC)		/* OP_RETURN */
+ ,opmode(0, 1, OpArgR, OpArgN, iAsBx)		/* OP_FORLOOP */
+ ,opmode(0, 1, OpArgR, OpArgN, iAsBx)		/* OP_FORPREP */
+ ,opmode(0, 0, OpArgN, OpArgU, iABC)		/* OP_TFORCALL */
+ ,opmode(0, 1, OpArgR, OpArgN, iAsBx)		/* OP_TFORLOOP */
+ ,opmode(0, 0, OpArgU, OpArgU, iABC)		/* OP_SETLIST */
+ ,opmode(0, 1, OpArgU, OpArgN, iABx)		/* OP_CLOSURE */
+ ,opmode(0, 1, OpArgU, OpArgN, iABC)		/* OP_VARARG */
+ ,opmode(0, 0, OpArgU, OpArgU, iAx)		/* OP_EXTRAARG */
+};
+
diff -ruNp src.orig/libs/lua/lopcodes.h src/libs/lua/lopcodes.h
--- src.orig/libs/lua/lopcodes.h	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lopcodes.h	2017-11-21 19:39:46 -0600
@@ -0,0 +1,288 @@
+/*
+** $Id: lopcodes.h,v 1.142 2011/07/15 12:50:29 roberto Exp $
+** Opcodes for Lua virtual machine
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lopcodes_h
+#define lopcodes_h
+
+#include "llimits.h"
+
+
+/*===========================================================================
+  We assume that instructions are unsigned numbers.
+  All instructions have an opcode in the first 6 bits.
+  Instructions can have the following fields:
+	`A' : 8 bits
+	`B' : 9 bits
+	`C' : 9 bits
+	'Ax' : 26 bits ('A', 'B', and 'C' together)
+	`Bx' : 18 bits (`B' and `C' together)
+	`sBx' : signed Bx
+
+  A signed argument is represented in excess K; that is, the number
+  value is the unsigned value minus K. K is exactly the maximum value
+  for that argument (so that -max is represented by 0, and +max is
+  represented by 2*max), which is half the maximum for the corresponding
+  unsigned argument.
+===========================================================================*/
+
+
+enum OpMode {iABC, iABx, iAsBx, iAx};  /* basic instruction format */
+
+
+/*
+** size and position of opcode arguments.
+*/
+#define SIZE_C		9
+#define SIZE_B		9
+#define SIZE_Bx		(SIZE_C + SIZE_B)
+#define SIZE_A		8
+#define SIZE_Ax		(SIZE_C + SIZE_B + SIZE_A)
+
+#define SIZE_OP		6
+
+#define POS_OP		0
+#define POS_A		(POS_OP + SIZE_OP)
+#define POS_C		(POS_A + SIZE_A)
+#define POS_B		(POS_C + SIZE_C)
+#define POS_Bx		POS_C
+#define POS_Ax		POS_A
+
+
+/*
+** limits for opcode arguments.
+** we use (signed) int to manipulate most arguments,
+** so they must fit in LUAI_BITSINT-1 bits (-1 for sign)
+*/
+#if SIZE_Bx < LUAI_BITSINT-1
+#define MAXARG_Bx        ((1<<SIZE_Bx)-1)
+#define MAXARG_sBx        (MAXARG_Bx>>1)         /* `sBx' is signed */
+#else
+#define MAXARG_Bx        MAX_INT
+#define MAXARG_sBx        MAX_INT
+#endif
+
+#if SIZE_Ax < LUAI_BITSINT-1
+#define MAXARG_Ax	((1<<SIZE_Ax)-1)
+#else
+#define MAXARG_Ax	MAX_INT
+#endif
+
+
+#define MAXARG_A        ((1<<SIZE_A)-1)
+#define MAXARG_B        ((1<<SIZE_B)-1)
+#define MAXARG_C        ((1<<SIZE_C)-1)
+
+
+/* creates a mask with `n' 1 bits at position `p' */
+#define MASK1(n,p)	((~((~(Instruction)0)<<(n)))<<(p))
+
+/* creates a mask with `n' 0 bits at position `p' */
+#define MASK0(n,p)	(~MASK1(n,p))
+
+/*
+** the following macros help to manipulate instructions
+*/
+
+#define GET_OPCODE(i)	(cast(OpCode, ((i)>>POS_OP) & MASK1(SIZE_OP,0)))
+#define SET_OPCODE(i,o)	((i) = (((i)&MASK0(SIZE_OP,POS_OP)) | \
+		((cast(Instruction, o)<<POS_OP)&MASK1(SIZE_OP,POS_OP))))
+
+#define getarg(i,pos,size)	(cast(int, ((i)>>pos) & MASK1(size,0)))
+#define setarg(i,v,pos,size)	((i) = (((i)&MASK0(size,pos)) | \
+                ((cast(Instruction, v)<<pos)&MASK1(size,pos))))
+
+#define GETARG_A(i)	getarg(i, POS_A, SIZE_A)
+#define SETARG_A(i,v)	setarg(i, v, POS_A, SIZE_A)
+
+#define GETARG_B(i)	getarg(i, POS_B, SIZE_B)
+#define SETARG_B(i,v)	setarg(i, v, POS_B, SIZE_B)
+
+#define GETARG_C(i)	getarg(i, POS_C, SIZE_C)
+#define SETARG_C(i,v)	setarg(i, v, POS_C, SIZE_C)
+
+#define GETARG_Bx(i)	getarg(i, POS_Bx, SIZE_Bx)
+#define SETARG_Bx(i,v)	setarg(i, v, POS_Bx, SIZE_Bx)
+
+#define GETARG_Ax(i)	getarg(i, POS_Ax, SIZE_Ax)
+#define SETARG_Ax(i,v)	setarg(i, v, POS_Ax, SIZE_Ax)
+
+#define GETARG_sBx(i)	(GETARG_Bx(i)-MAXARG_sBx)
+#define SETARG_sBx(i,b)	SETARG_Bx((i),cast(unsigned int, (b)+MAXARG_sBx))
+
+
+#define CREATE_ABC(o,a,b,c)	((cast(Instruction, o)<<POS_OP) \
+			| (cast(Instruction, a)<<POS_A) \
+			| (cast(Instruction, b)<<POS_B) \
+			| (cast(Instruction, c)<<POS_C))
+
+#define CREATE_ABx(o,a,bc)	((cast(Instruction, o)<<POS_OP) \
+			| (cast(Instruction, a)<<POS_A) \
+			| (cast(Instruction, bc)<<POS_Bx))
+
+#define CREATE_Ax(o,a)		((cast(Instruction, o)<<POS_OP) \
+			| (cast(Instruction, a)<<POS_Ax))
+
+
+/*
+** Macros to operate RK indices
+*/
+
+/* this bit 1 means constant (0 means register) */
+#define BITRK		(1 << (SIZE_B - 1))
+
+/* test whether value is a constant */
+#define ISK(x)		((x) & BITRK)
+
+/* gets the index of the constant */
+#define INDEXK(r)	((int)(r) & ~BITRK)
+
+#define MAXINDEXRK	(BITRK - 1)
+
+/* code a constant index as a RK value */
+#define RKASK(x)	((x) | BITRK)
+
+
+/*
+** invalid register that fits in 8 bits
+*/
+#define NO_REG		MAXARG_A
+
+
+/*
+** R(x) - register
+** Kst(x) - constant (in constant table)
+** RK(x) == if ISK(x) then Kst(INDEXK(x)) else R(x)
+*/
+
+
+/*
+** grep "ORDER OP" if you change these enums
+*/
+
+typedef enum {
+/*----------------------------------------------------------------------
+name		args	description
+------------------------------------------------------------------------*/
+OP_MOVE,/*	A B	R(A) := R(B)					*/
+OP_LOADK,/*	A Bx	R(A) := Kst(Bx)					*/
+OP_LOADKX,/*	A 	R(A) := Kst(extra arg)				*/
+OP_LOADBOOL,/*	A B C	R(A) := (Bool)B; if (C) pc++			*/
+OP_LOADNIL,/*	A B	R(A), R(A+1), ..., R(A+B) := nil		*/
+OP_GETUPVAL,/*	A B	R(A) := UpValue[B]				*/
+
+OP_GETTABUP,/*	A B C	R(A) := UpValue[B][RK(C)]			*/
+OP_GETTABLE,/*	A B C	R(A) := R(B)[RK(C)]				*/
+
+OP_SETTABUP,/*	A B C	UpValue[A][RK(B)] := RK(C)			*/
+OP_SETUPVAL,/*	A B	UpValue[B] := R(A)				*/
+OP_SETTABLE,/*	A B C	R(A)[RK(B)] := RK(C)				*/
+
+OP_NEWTABLE,/*	A B C	R(A) := {} (size = B,C)				*/
+
+OP_SELF,/*	A B C	R(A+1) := R(B); R(A) := R(B)[RK(C)]		*/
+
+OP_ADD,/*	A B C	R(A) := RK(B) + RK(C)				*/
+OP_SUB,/*	A B C	R(A) := RK(B) - RK(C)				*/
+OP_MUL,/*	A B C	R(A) := RK(B) * RK(C)				*/
+OP_DIV,/*	A B C	R(A) := RK(B) / RK(C)				*/
+OP_MOD,/*	A B C	R(A) := RK(B) % RK(C)				*/
+OP_POW,/*	A B C	R(A) := RK(B) ^ RK(C)				*/
+OP_UNM,/*	A B	R(A) := -R(B)					*/
+OP_NOT,/*	A B	R(A) := not R(B)				*/
+OP_LEN,/*	A B	R(A) := length of R(B)				*/
+
+OP_CONCAT,/*	A B C	R(A) := R(B).. ... ..R(C)			*/
+
+OP_JMP,/*	A sBx	pc+=sBx; if (A) close all upvalues >= R(A) + 1	*/
+OP_EQ,/*	A B C	if ((RK(B) == RK(C)) ~= A) then pc++		*/
+OP_LT,/*	A B C	if ((RK(B) <  RK(C)) ~= A) then pc++		*/
+OP_LE,/*	A B C	if ((RK(B) <= RK(C)) ~= A) then pc++		*/
+
+OP_TEST,/*	A C	if not (R(A) <=> C) then pc++			*/
+OP_TESTSET,/*	A B C	if (R(B) <=> C) then R(A) := R(B) else pc++	*/
+
+OP_CALL,/*	A B C	R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1)) */
+OP_TAILCALL,/*	A B C	return R(A)(R(A+1), ... ,R(A+B-1))		*/
+OP_RETURN,/*	A B	return R(A), ... ,R(A+B-2)	(see note)	*/
+
+OP_FORLOOP,/*	A sBx	R(A)+=R(A+2);
+			if R(A) <?= R(A+1) then { pc+=sBx; R(A+3)=R(A) }*/
+OP_FORPREP,/*	A sBx	R(A)-=R(A+2); pc+=sBx				*/
+
+OP_TFORCALL,/*	A C	R(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2));	*/
+OP_TFORLOOP,/*	A sBx	if R(A+1) ~= nil then { R(A)=R(A+1); pc += sBx }*/
+
+OP_SETLIST,/*	A B C	R(A)[(C-1)*FPF+i] := R(A+i), 1 <= i <= B	*/
+
+OP_CLOSURE,/*	A Bx	R(A) := closure(KPROTO[Bx])			*/
+
+OP_VARARG,/*	A B	R(A), R(A+1), ..., R(A+B-2) = vararg		*/
+
+OP_EXTRAARG/*	Ax	extra (larger) argument for previous opcode	*/
+} OpCode;
+
+
+#define NUM_OPCODES	(cast(int, OP_EXTRAARG) + 1)
+
+
+
+/*===========================================================================
+  Notes:
+  (*) In OP_CALL, if (B == 0) then B = top. If (C == 0), then `top' is
+  set to last_result+1, so next open instruction (OP_CALL, OP_RETURN,
+  OP_SETLIST) may use `top'.
+
+  (*) In OP_VARARG, if (B == 0) then use actual number of varargs and
+  set top (like in OP_CALL with C == 0).
+
+  (*) In OP_RETURN, if (B == 0) then return up to `top'.
+
+  (*) In OP_SETLIST, if (B == 0) then B = `top'; if (C == 0) then next
+  'instruction' is EXTRAARG(real C).
+
+  (*) In OP_LOADKX, the next 'instruction' is always EXTRAARG.
+
+  (*) For comparisons, A specifies what condition the test should accept
+  (true or false).
+
+  (*) All `skips' (pc++) assume that next instruction is a jump.
+
+===========================================================================*/
+
+
+/*
+** masks for instruction properties. The format is:
+** bits 0-1: op mode
+** bits 2-3: C arg mode
+** bits 4-5: B arg mode
+** bit 6: instruction set register A
+** bit 7: operator is a test (next instruction must be a jump)
+*/
+
+enum OpArgMask {
+  OpArgN,  /* argument is not used */
+  OpArgU,  /* argument is used */
+  OpArgR,  /* argument is a register or a jump offset */
+  OpArgK   /* argument is a constant or register/constant */
+};
+
+LUAI_DDEC const lu_byte luaP_opmodes[NUM_OPCODES];
+
+#define getOpMode(m)	(cast(enum OpMode, luaP_opmodes[m] & 3))
+#define getBMode(m)	(cast(enum OpArgMask, (luaP_opmodes[m] >> 4) & 3))
+#define getCMode(m)	(cast(enum OpArgMask, (luaP_opmodes[m] >> 2) & 3))
+#define testAMode(m)	(luaP_opmodes[m] & (1 << 6))
+#define testTMode(m)	(luaP_opmodes[m] & (1 << 7))
+
+
+LUAI_DDEC const char *const luaP_opnames[NUM_OPCODES+1];  /* opcode names */
+
+
+/* number of list items to accumulate before a SETLIST instruction */
+#define LFIELDS_PER_FLUSH	50
+
+
+#endif
diff -ruNp src.orig/libs/lua/loslib.c src/libs/lua/loslib.c
--- src.orig/libs/lua/loslib.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/loslib.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,323 @@
+/*
+** $Id: loslib.c,v 1.40 2012/10/19 15:54:02 roberto Exp $
+** Standard Operating System library
+** See Copyright Notice in lua.h
+*/
+
+
+#include <errno.h>
+#include <locale.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+
+#define loslib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+/*
+** list of valid conversion specifiers for the 'strftime' function
+*/
+#if !defined(LUA_STRFTIMEOPTIONS)
+
+#if !defined(LUA_USE_POSIX)
+#define LUA_STRFTIMEOPTIONS	{ "aAbBcdHIjmMpSUwWxXyYz%", "" }
+#else
+#define LUA_STRFTIMEOPTIONS \
+	{ "aAbBcCdDeFgGhHIjmMnprRStTuUVwWxXyYzZ%", "" \
+	  "", "E", "cCxXyY",  \
+	  "O", "deHImMSuUVwWy" }
+#endif
+
+#endif
+
+
+
+/*
+** By default, Lua uses tmpnam except when POSIX is available, where it
+** uses mkstemp.
+*/
+#if defined(LUA_USE_MKSTEMP)
+#include <unistd.h>
+#define LUA_TMPNAMBUFSIZE	32
+#define lua_tmpnam(b,e) { \
+        strcpy(b, "/tmp/lua_XXXXXX"); \
+        e = mkstemp(b); \
+        if (e != -1) close(e); \
+        e = (e == -1); }
+
+#elif !defined(lua_tmpnam)
+
+#define LUA_TMPNAMBUFSIZE	L_tmpnam
+#define lua_tmpnam(b,e)		{ e = (tmpnam(b) == NULL); }
+
+#endif
+
+
+/*
+** By default, Lua uses gmtime/localtime, except when POSIX is available,
+** where it uses gmtime_r/localtime_r
+*/
+#if defined(LUA_USE_GMTIME_R)
+
+#define l_gmtime(t,r)		gmtime_r(t,r)
+#define l_localtime(t,r)	localtime_r(t,r)
+
+#elif !defined(l_gmtime)
+
+#define l_gmtime(t,r)		((void)r, gmtime(t))
+#define l_localtime(t,r)  	((void)r, localtime(t))
+
+#endif
+
+
+
+static int os_execute (lua_State *L) {
+  const char *cmd = luaL_optstring(L, 1, NULL);
+  int stat = system(cmd);
+  if (cmd != NULL)
+    return luaL_execresult(L, stat);
+  else {
+    lua_pushboolean(L, stat);  /* true if there is a shell */
+    return 1;
+  }
+}
+
+
+static int os_remove (lua_State *L) {
+  const char *filename = luaL_checkstring(L, 1);
+  return luaL_fileresult(L, remove(filename) == 0, filename);
+}
+
+
+static int os_rename (lua_State *L) {
+  const char *fromname = luaL_checkstring(L, 1);
+  const char *toname = luaL_checkstring(L, 2);
+  return luaL_fileresult(L, rename(fromname, toname) == 0, NULL);
+}
+
+
+static int os_tmpname (lua_State *L) {
+  char buff[LUA_TMPNAMBUFSIZE];
+  int err;
+  lua_tmpnam(buff, err);
+  if (err)
+    return luaL_error(L, "unable to generate a unique filename");
+  lua_pushstring(L, buff);
+  return 1;
+}
+
+
+static int os_getenv (lua_State *L) {
+  lua_pushstring(L, getenv(luaL_checkstring(L, 1)));  /* if NULL push nil */
+  return 1;
+}
+
+
+static int os_clock (lua_State *L) {
+  lua_pushnumber(L, ((lua_Number)clock())/(lua_Number)CLOCKS_PER_SEC);
+  return 1;
+}
+
+
+/*
+** {======================================================
+** Time/Date operations
+** { year=%Y, month=%m, day=%d, hour=%H, min=%M, sec=%S,
+**   wday=%w+1, yday=%j, isdst=? }
+** =======================================================
+*/
+
+static void setfield (lua_State *L, const char *key, int value) {
+  lua_pushinteger(L, value);
+  lua_setfield(L, -2, key);
+}
+
+static void setboolfield (lua_State *L, const char *key, int value) {
+  if (value < 0)  /* undefined? */
+    return;  /* does not set field */
+  lua_pushboolean(L, value);
+  lua_setfield(L, -2, key);
+}
+
+static int getboolfield (lua_State *L, const char *key) {
+  int res;
+  lua_getfield(L, -1, key);
+  res = lua_isnil(L, -1) ? -1 : lua_toboolean(L, -1);
+  lua_pop(L, 1);
+  return res;
+}
+
+
+static int getfield (lua_State *L, const char *key, int d) {
+  int res, isnum;
+  lua_getfield(L, -1, key);
+  res = (int)lua_tointegerx(L, -1, &isnum);
+  if (!isnum) {
+    if (d < 0)
+      return luaL_error(L, "field " LUA_QS " missing in date table", key);
+    res = d;
+  }
+  lua_pop(L, 1);
+  return res;
+}
+
+
+static const char *checkoption (lua_State *L, const char *conv, char *buff) {
+  static const char *const options[] = LUA_STRFTIMEOPTIONS;
+  unsigned int i;
+  for (i = 0; i < sizeof(options)/sizeof(options[0]); i += 2) {
+    if (*conv != '\0' && strchr(options[i], *conv) != NULL) {
+      buff[1] = *conv;
+      if (*options[i + 1] == '\0') {  /* one-char conversion specifier? */
+        buff[2] = '\0';  /* end buffer */
+        return conv + 1;
+      }
+      else if (*(conv + 1) != '\0' &&
+               strchr(options[i + 1], *(conv + 1)) != NULL) {
+        buff[2] = *(conv + 1);  /* valid two-char conversion specifier */
+        buff[3] = '\0';  /* end buffer */
+        return conv + 2;
+      }
+    }
+  }
+  luaL_argerror(L, 1,
+    lua_pushfstring(L, "invalid conversion specifier '%%%s'", conv));
+  return conv;  /* to avoid warnings */
+}
+
+
+static int os_date (lua_State *L) {
+  const char *s = luaL_optstring(L, 1, "%c");
+  time_t t = luaL_opt(L, (time_t)luaL_checknumber, 2, time(NULL));
+  struct tm tmr, *stm;
+  if (*s == '!') {  /* UTC? */
+    stm = l_gmtime(&t, &tmr);
+    s++;  /* skip `!' */
+  }
+  else
+    stm = l_localtime(&t, &tmr);
+  if (stm == NULL)  /* invalid date? */
+    lua_pushnil(L);
+  else if (strcmp(s, "*t") == 0) {
+    lua_createtable(L, 0, 9);  /* 9 = number of fields */
+    setfield(L, "sec", stm->tm_sec);
+    setfield(L, "min", stm->tm_min);
+    setfield(L, "hour", stm->tm_hour);
+    setfield(L, "day", stm->tm_mday);
+    setfield(L, "month", stm->tm_mon+1);
+    setfield(L, "year", stm->tm_year+1900);
+    setfield(L, "wday", stm->tm_wday+1);
+    setfield(L, "yday", stm->tm_yday+1);
+    setboolfield(L, "isdst", stm->tm_isdst);
+  }
+  else {
+    char cc[4];
+    luaL_Buffer b;
+    cc[0] = '%';
+    luaL_buffinit(L, &b);
+    while (*s) {
+      if (*s != '%')  /* no conversion specifier? */
+        luaL_addchar(&b, *s++);
+      else {
+        size_t reslen;
+        char buff[200];  /* should be big enough for any conversion result */
+        s = checkoption(L, s + 1, cc);
+        reslen = strftime(buff, sizeof(buff), cc, stm);
+        luaL_addlstring(&b, buff, reslen);
+      }
+    }
+    luaL_pushresult(&b);
+  }
+  return 1;
+}
+
+
+static int os_time (lua_State *L) {
+  time_t t;
+  if (lua_isnoneornil(L, 1))  /* called without args? */
+    t = time(NULL);  /* get current time */
+  else {
+    struct tm ts;
+    luaL_checktype(L, 1, LUA_TTABLE);
+    lua_settop(L, 1);  /* make sure table is at the top */
+    ts.tm_sec = getfield(L, "sec", 0);
+    ts.tm_min = getfield(L, "min", 0);
+    ts.tm_hour = getfield(L, "hour", 12);
+    ts.tm_mday = getfield(L, "day", -1);
+    ts.tm_mon = getfield(L, "month", -1) - 1;
+    ts.tm_year = getfield(L, "year", -1) - 1900;
+    ts.tm_isdst = getboolfield(L, "isdst");
+    t = mktime(&ts);
+  }
+  if (t == (time_t)(-1))
+    lua_pushnil(L);
+  else
+    lua_pushnumber(L, (lua_Number)t);
+  return 1;
+}
+
+
+static int os_difftime (lua_State *L) {
+  lua_pushnumber(L, difftime((time_t)(luaL_checknumber(L, 1)),
+                             (time_t)(luaL_optnumber(L, 2, 0))));
+  return 1;
+}
+
+/* }====================================================== */
+
+
+static int os_setlocale (lua_State *L) {
+  static const int cat[] = {LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY,
+                      LC_NUMERIC, LC_TIME};
+  static const char *const catnames[] = {"all", "collate", "ctype", "monetary",
+     "numeric", "time", NULL};
+  const char *l = luaL_optstring(L, 1, NULL);
+  int op = luaL_checkoption(L, 2, "all", catnames);
+  lua_pushstring(L, setlocale(cat[op], l));
+  return 1;
+}
+
+
+static int os_exit (lua_State *L) {
+  int status;
+  if (lua_isboolean(L, 1))
+    status = (lua_toboolean(L, 1) ? EXIT_SUCCESS : EXIT_FAILURE);
+  else
+    status = luaL_optint(L, 1, EXIT_SUCCESS);
+  if (lua_toboolean(L, 2))
+    lua_close(L);
+  if (L) exit(status);  /* 'if' to avoid warnings for unreachable 'return' */
+  return 0;
+}
+
+
+static const luaL_Reg syslib[] = {
+  {"clock",     os_clock},
+  {"date",      os_date},
+  {"difftime",  os_difftime},
+  {"execute",   os_execute},
+  {"exit",      os_exit},
+  {"getenv",    os_getenv},
+  {"remove",    os_remove},
+  {"rename",    os_rename},
+  {"setlocale", os_setlocale},
+  {"time",      os_time},
+  {"tmpname",   os_tmpname},
+  {NULL, NULL}
+};
+
+/* }====================================================== */
+
+
+
+LUAMOD_API int luaopen_os (lua_State *L) {
+  luaL_newlib(L, syslib);
+  return 1;
+}
+
diff -ruNp src.orig/libs/lua/lparser.c src/libs/lua/lparser.c
--- src.orig/libs/lua/lparser.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lparser.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,1638 @@
+/*
+** $Id: lparser.c,v 2.130 2013/02/06 13:37:39 roberto Exp $
+** Lua Parser
+** See Copyright Notice in lua.h
+*/
+
+
+#include <string.h>
+
+#define lparser_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lcode.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "llex.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lparser.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+
+
+
+/* maximum number of local variables per function (must be smaller
+   than 250, due to the bytecode format) */
+#define MAXVARS		200
+
+
+#define hasmultret(k)		((k) == VCALL || (k) == VVARARG)
+
+
+
+/*
+** nodes for block list (list of active blocks)
+*/
+typedef struct BlockCnt {
+  struct BlockCnt *previous;  /* chain */
+  short firstlabel;  /* index of first label in this block */
+  short firstgoto;  /* index of first pending goto in this block */
+  lu_byte nactvar;  /* # active locals outside the block */
+  lu_byte upval;  /* true if some variable in the block is an upvalue */
+  lu_byte isloop;  /* true if `block' is a loop */
+} BlockCnt;
+
+
+
+/*
+** prototypes for recursive non-terminal functions
+*/
+static void statement (LexState *ls);
+static void expr (LexState *ls, expdesc *v);
+
+
+static void anchor_token (LexState *ls) {
+  /* last token from outer function must be EOS */
+  lua_assert(ls->fs != NULL || ls->t.token == TK_EOS);
+  if (ls->t.token == TK_NAME || ls->t.token == TK_STRING) {
+    TString *ts = ls->t.seminfo.ts;
+    luaX_newstring(ls, getstr(ts), ts->tsv.len);
+  }
+}
+
+
+/* semantic error */
+static l_noret semerror (LexState *ls, const char *msg) {
+  ls->t.token = 0;  /* remove 'near to' from final message */
+  luaX_syntaxerror(ls, msg);
+}
+
+
+static l_noret error_expected (LexState *ls, int token) {
+  luaX_syntaxerror(ls,
+      luaO_pushfstring(ls->L, "%s expected", luaX_token2str(ls, token)));
+}
+
+
+static l_noret errorlimit (FuncState *fs, int limit, const char *what) {
+  lua_State *L = fs->ls->L;
+  const char *msg;
+  int line = fs->f->linedefined;
+  const char *where = (line == 0)
+                      ? "main function"
+                      : luaO_pushfstring(L, "function at line %d", line);
+  msg = luaO_pushfstring(L, "too many %s (limit is %d) in %s",
+                             what, limit, where);
+  luaX_syntaxerror(fs->ls, msg);
+}
+
+
+static void checklimit (FuncState *fs, int v, int l, const char *what) {
+  if (v > l) errorlimit(fs, l, what);
+}
+
+
+static int testnext (LexState *ls, int c) {
+  if (ls->t.token == c) {
+    luaX_next(ls);
+    return 1;
+  }
+  else return 0;
+}
+
+
+static void check (LexState *ls, int c) {
+  if (ls->t.token != c)
+    error_expected(ls, c);
+}
+
+
+static void checknext (LexState *ls, int c) {
+  check(ls, c);
+  luaX_next(ls);
+}
+
+
+#define check_condition(ls,c,msg)	{ if (!(c)) luaX_syntaxerror(ls, msg); }
+
+
+
+static void check_match (LexState *ls, int what, int who, int where) {
+  if (!testnext(ls, what)) {
+    if (where == ls->linenumber)
+      error_expected(ls, what);
+    else {
+      luaX_syntaxerror(ls, luaO_pushfstring(ls->L,
+             "%s expected (to close %s at line %d)",
+              luaX_token2str(ls, what), luaX_token2str(ls, who), where));
+    }
+  }
+}
+
+
+static TString *str_checkname (LexState *ls) {
+  TString *ts;
+  check(ls, TK_NAME);
+  ts = ls->t.seminfo.ts;
+  luaX_next(ls);
+  return ts;
+}
+
+
+static void init_exp (expdesc *e, expkind k, int i) {
+  e->f = e->t = NO_JUMP;
+  e->k = k;
+  e->u.info = i;
+}
+
+
+static void codestring (LexState *ls, expdesc *e, TString *s) {
+  init_exp(e, VK, luaK_stringK(ls->fs, s));
+}
+
+
+static void checkname (LexState *ls, expdesc *e) {
+  codestring(ls, e, str_checkname(ls));
+}
+
+
+static int registerlocalvar (LexState *ls, TString *varname) {
+  FuncState *fs = ls->fs;
+  Proto *f = fs->f;
+  int oldsize = f->sizelocvars;
+  luaM_growvector(ls->L, f->locvars, fs->nlocvars, f->sizelocvars,
+                  LocVar, SHRT_MAX, "local variables");
+  while (oldsize < f->sizelocvars) f->locvars[oldsize++].varname = NULL;
+  f->locvars[fs->nlocvars].varname = varname;
+  luaC_objbarrier(ls->L, f, varname);
+  return fs->nlocvars++;
+}
+
+
+static void new_localvar (LexState *ls, TString *name) {
+  FuncState *fs = ls->fs;
+  Dyndata *dyd = ls->dyd;
+  int reg = registerlocalvar(ls, name);
+  checklimit(fs, dyd->actvar.n + 1 - fs->firstlocal,
+                  MAXVARS, "local variables");
+  luaM_growvector(ls->L, dyd->actvar.arr, dyd->actvar.n + 1,
+                  dyd->actvar.size, Vardesc, MAX_INT, "local variables");
+  dyd->actvar.arr[dyd->actvar.n++].idx = cast(short, reg);
+}
+
+
+static void new_localvarliteral_ (LexState *ls, const char *name, size_t sz) {
+  new_localvar(ls, luaX_newstring(ls, name, sz));
+}
+
+#define new_localvarliteral(ls,v) \
+	new_localvarliteral_(ls, "" v, (sizeof(v)/sizeof(char))-1)
+
+
+static LocVar *getlocvar (FuncState *fs, int i) {
+  int idx = fs->ls->dyd->actvar.arr[fs->firstlocal + i].idx;
+  lua_assert(idx < fs->nlocvars);
+  return &fs->f->locvars[idx];
+}
+
+
+static void adjustlocalvars (LexState *ls, int nvars) {
+  FuncState *fs = ls->fs;
+  fs->nactvar = cast_byte(fs->nactvar + nvars);
+  for (; nvars; nvars--) {
+    getlocvar(fs, fs->nactvar - nvars)->startpc = fs->pc;
+  }
+}
+
+
+static void removevars (FuncState *fs, int tolevel) {
+  fs->ls->dyd->actvar.n -= (fs->nactvar - tolevel);
+  while (fs->nactvar > tolevel)
+    getlocvar(fs, --fs->nactvar)->endpc = fs->pc;
+}
+
+
+static int searchupvalue (FuncState *fs, TString *name) {
+  int i;
+  Upvaldesc *up = fs->f->upvalues;
+  for (i = 0; i < fs->nups; i++) {
+    if (luaS_eqstr(up[i].name, name)) return i;
+  }
+  return -1;  /* not found */
+}
+
+
+static int newupvalue (FuncState *fs, TString *name, expdesc *v) {
+  Proto *f = fs->f;
+  int oldsize = f->sizeupvalues;
+  checklimit(fs, fs->nups + 1, MAXUPVAL, "upvalues");
+  luaM_growvector(fs->ls->L, f->upvalues, fs->nups, f->sizeupvalues,
+                  Upvaldesc, MAXUPVAL, "upvalues");
+  while (oldsize < f->sizeupvalues) f->upvalues[oldsize++].name = NULL;
+  f->upvalues[fs->nups].instack = (v->k == VLOCAL);
+  f->upvalues[fs->nups].idx = cast_byte(v->u.info);
+  f->upvalues[fs->nups].name = name;
+  luaC_objbarrier(fs->ls->L, f, name);
+  return fs->nups++;
+}
+
+
+static int searchvar (FuncState *fs, TString *n) {
+  int i;
+  for (i = cast_int(fs->nactvar) - 1; i >= 0; i--) {
+    if (luaS_eqstr(n, getlocvar(fs, i)->varname))
+      return i;
+  }
+  return -1;  /* not found */
+}
+
+
+/*
+  Mark block where variable at given level was defined
+  (to emit close instructions later).
+*/
+static void markupval (FuncState *fs, int level) {
+  BlockCnt *bl = fs->bl;
+  while (bl->nactvar > level) bl = bl->previous;
+  bl->upval = 1;
+}
+
+
+/*
+  Find variable with given name 'n'. If it is an upvalue, add this
+  upvalue into all intermediate functions.
+*/
+static int singlevaraux (FuncState *fs, TString *n, expdesc *var, int base) {
+  if (fs == NULL)  /* no more levels? */
+    return VVOID;  /* default is global */
+  else {
+    int v = searchvar(fs, n);  /* look up locals at current level */
+    if (v >= 0) {  /* found? */
+      init_exp(var, VLOCAL, v);  /* variable is local */
+      if (!base)
+        markupval(fs, v);  /* local will be used as an upval */
+      return VLOCAL;
+    }
+    else {  /* not found as local at current level; try upvalues */
+      int idx = searchupvalue(fs, n);  /* try existing upvalues */
+      if (idx < 0) {  /* not found? */
+        if (singlevaraux(fs->prev, n, var, 0) == VVOID) /* try upper levels */
+          return VVOID;  /* not found; is a global */
+        /* else was LOCAL or UPVAL */
+        idx  = newupvalue(fs, n, var);  /* will be a new upvalue */
+      }
+      init_exp(var, VUPVAL, idx);
+      return VUPVAL;
+    }
+  }
+}
+
+
+static void singlevar (LexState *ls, expdesc *var) {
+  TString *varname = str_checkname(ls);
+  FuncState *fs = ls->fs;
+  if (singlevaraux(fs, varname, var, 1) == VVOID) {  /* global name? */
+    expdesc key;
+    singlevaraux(fs, ls->envn, var, 1);  /* get environment variable */
+    lua_assert(var->k == VLOCAL || var->k == VUPVAL);
+    codestring(ls, &key, varname);  /* key is variable name */
+    luaK_indexed(fs, var, &key);  /* env[varname] */
+  }
+}
+
+
+static void adjust_assign (LexState *ls, int nvars, int nexps, expdesc *e) {
+  FuncState *fs = ls->fs;
+  int extra = nvars - nexps;
+  if (hasmultret(e->k)) {
+    extra++;  /* includes call itself */
+    if (extra < 0) extra = 0;
+    luaK_setreturns(fs, e, extra);  /* last exp. provides the difference */
+    if (extra > 1) luaK_reserveregs(fs, extra-1);
+  }
+  else {
+    if (e->k != VVOID) luaK_exp2nextreg(fs, e);  /* close last expression */
+    if (extra > 0) {
+      int reg = fs->freereg;
+      luaK_reserveregs(fs, extra);
+      luaK_nil(fs, reg, extra);
+    }
+  }
+}
+
+
+static void enterlevel (LexState *ls) {
+  lua_State *L = ls->L;
+  ++L->nCcalls;
+  checklimit(ls->fs, L->nCcalls, LUAI_MAXCCALLS, "C levels");
+}
+
+
+#define leavelevel(ls)	((ls)->L->nCcalls--)
+
+
+static void closegoto (LexState *ls, int g, Labeldesc *label) {
+  int i;
+  FuncState *fs = ls->fs;
+  Labellist *gl = &ls->dyd->gt;
+  Labeldesc *gt = &gl->arr[g];
+  lua_assert(luaS_eqstr(gt->name, label->name));
+  if (gt->nactvar < label->nactvar) {
+    TString *vname = getlocvar(fs, gt->nactvar)->varname;
+    const char *msg = luaO_pushfstring(ls->L,
+      "<goto %s> at line %d jumps into the scope of local " LUA_QS,
+      getstr(gt->name), gt->line, getstr(vname));
+    semerror(ls, msg);
+  }
+  luaK_patchlist(fs, gt->pc, label->pc);
+  /* remove goto from pending list */
+  for (i = g; i < gl->n - 1; i++)
+    gl->arr[i] = gl->arr[i + 1];
+  gl->n--;
+}
+
+
+/*
+** try to close a goto with existing labels; this solves backward jumps
+*/
+static int findlabel (LexState *ls, int g) {
+  int i;
+  BlockCnt *bl = ls->fs->bl;
+  Dyndata *dyd = ls->dyd;
+  Labeldesc *gt = &dyd->gt.arr[g];
+  /* check labels in current block for a match */
+  for (i = bl->firstlabel; i < dyd->label.n; i++) {
+    Labeldesc *lb = &dyd->label.arr[i];
+    if (luaS_eqstr(lb->name, gt->name)) {  /* correct label? */
+      if (gt->nactvar > lb->nactvar &&
+          (bl->upval || dyd->label.n > bl->firstlabel))
+        luaK_patchclose(ls->fs, gt->pc, lb->nactvar);
+      closegoto(ls, g, lb);  /* close it */
+      return 1;
+    }
+  }
+  return 0;  /* label not found; cannot close goto */
+}
+
+
+static int newlabelentry (LexState *ls, Labellist *l, TString *name,
+                          int line, int pc) {
+  int n = l->n;
+  luaM_growvector(ls->L, l->arr, n, l->size,
+                  Labeldesc, SHRT_MAX, "labels/gotos");
+  l->arr[n].name = name;
+  l->arr[n].line = line;
+  l->arr[n].nactvar = ls->fs->nactvar;
+  l->arr[n].pc = pc;
+  l->n++;
+  return n;
+}
+
+
+/*
+** check whether new label 'lb' matches any pending gotos in current
+** block; solves forward jumps
+*/
+static void findgotos (LexState *ls, Labeldesc *lb) {
+  Labellist *gl = &ls->dyd->gt;
+  int i = ls->fs->bl->firstgoto;
+  while (i < gl->n) {
+    if (luaS_eqstr(gl->arr[i].name, lb->name))
+      closegoto(ls, i, lb);
+    else
+      i++;
+  }
+}
+
+
+/*
+** "export" pending gotos to outer level, to check them against
+** outer labels; if the block being exited has upvalues, and
+** the goto exits the scope of any variable (which can be the
+** upvalue), close those variables being exited.
+*/
+static void movegotosout (FuncState *fs, BlockCnt *bl) {
+  int i = bl->firstgoto;
+  Labellist *gl = &fs->ls->dyd->gt;
+  /* correct pending gotos to current block and try to close it
+     with visible labels */
+  while (i < gl->n) {
+    Labeldesc *gt = &gl->arr[i];
+    if (gt->nactvar > bl->nactvar) {
+      if (bl->upval)
+        luaK_patchclose(fs, gt->pc, bl->nactvar);
+      gt->nactvar = bl->nactvar;
+    }
+    if (!findlabel(fs->ls, i))
+      i++;  /* move to next one */
+  }
+}
+
+
+static void enterblock (FuncState *fs, BlockCnt *bl, lu_byte isloop) {
+  bl->isloop = isloop;
+  bl->nactvar = fs->nactvar;
+  bl->firstlabel = fs->ls->dyd->label.n;
+  bl->firstgoto = fs->ls->dyd->gt.n;
+  bl->upval = 0;
+  bl->previous = fs->bl;
+  fs->bl = bl;
+  lua_assert(fs->freereg == fs->nactvar);
+}
+
+
+/*
+** create a label named "break" to resolve break statements
+*/
+static void breaklabel (LexState *ls) {
+  TString *n = luaS_new(ls->L, "break");
+  int l = newlabelentry(ls, &ls->dyd->label, n, 0, ls->fs->pc);
+  findgotos(ls, &ls->dyd->label.arr[l]);
+}
+
+/*
+** generates an error for an undefined 'goto'; choose appropriate
+** message when label name is a reserved word (which can only be 'break')
+*/
+static l_noret undefgoto (LexState *ls, Labeldesc *gt) {
+  const char *msg = isreserved(gt->name)
+                    ? "<%s> at line %d not inside a loop"
+                    : "no visible label " LUA_QS " for <goto> at line %d";
+  msg = luaO_pushfstring(ls->L, msg, getstr(gt->name), gt->line);
+  semerror(ls, msg);
+}
+
+
+static void leaveblock (FuncState *fs) {
+  BlockCnt *bl = fs->bl;
+  LexState *ls = fs->ls;
+  if (bl->previous && bl->upval) {
+    /* create a 'jump to here' to close upvalues */
+    int j = luaK_jump(fs);
+    luaK_patchclose(fs, j, bl->nactvar);
+    luaK_patchtohere(fs, j);
+  }
+  if (bl->isloop)
+    breaklabel(ls);  /* close pending breaks */
+  fs->bl = bl->previous;
+  removevars(fs, bl->nactvar);
+  lua_assert(bl->nactvar == fs->nactvar);
+  fs->freereg = fs->nactvar;  /* free registers */
+  ls->dyd->label.n = bl->firstlabel;  /* remove local labels */
+  if (bl->previous)  /* inner block? */
+    movegotosout(fs, bl);  /* update pending gotos to outer block */
+  else if (bl->firstgoto < ls->dyd->gt.n)  /* pending gotos in outer block? */
+    undefgoto(ls, &ls->dyd->gt.arr[bl->firstgoto]);  /* error */
+}
+
+
+/*
+** adds a new prototype into list of prototypes
+*/
+static Proto *addprototype (LexState *ls) {
+  Proto *clp;
+  lua_State *L = ls->L;
+  FuncState *fs = ls->fs;
+  Proto *f = fs->f;  /* prototype of current function */
+  if (fs->np >= f->sizep) {
+    int oldsize = f->sizep;
+    luaM_growvector(L, f->p, fs->np, f->sizep, Proto *, MAXARG_Bx, "functions");
+    while (oldsize < f->sizep) f->p[oldsize++] = NULL;
+  }
+  f->p[fs->np++] = clp = luaF_newproto(L);
+  luaC_objbarrier(L, f, clp);
+  return clp;
+}
+
+
+/*
+** codes instruction to create new closure in parent function.
+** The OP_CLOSURE instruction must use the last available register,
+** so that, if it invokes the GC, the GC knows which registers
+** are in use at that time.
+*/
+static void codeclosure (LexState *ls, expdesc *v) {
+  FuncState *fs = ls->fs->prev;
+  init_exp(v, VRELOCABLE, luaK_codeABx(fs, OP_CLOSURE, 0, fs->np - 1));
+  luaK_exp2nextreg(fs, v);  /* fix it at the last register */
+}
+
+
+static void open_func (LexState *ls, FuncState *fs, BlockCnt *bl) {
+  lua_State *L = ls->L;
+  Proto *f;
+  fs->prev = ls->fs;  /* linked list of funcstates */
+  fs->ls = ls;
+  ls->fs = fs;
+  fs->pc = 0;
+  fs->lasttarget = 0;
+  fs->jpc = NO_JUMP;
+  fs->freereg = 0;
+  fs->nk = 0;
+  fs->np = 0;
+  fs->nups = 0;
+  fs->nlocvars = 0;
+  fs->nactvar = 0;
+  fs->firstlocal = ls->dyd->actvar.n;
+  fs->bl = NULL;
+  f = fs->f;
+  f->source = ls->source;
+  f->maxstacksize = 2;  /* registers 0/1 are always valid */
+  fs->h = luaH_new(L);
+  /* anchor table of constants (to avoid being collected) */
+  sethvalue2s(L, L->top, fs->h);
+  incr_top(L);
+  enterblock(fs, bl, 0);
+}
+
+
+static void close_func (LexState *ls) {
+  lua_State *L = ls->L;
+  FuncState *fs = ls->fs;
+  Proto *f = fs->f;
+  luaK_ret(fs, 0, 0);  /* final return */
+  leaveblock(fs);
+  luaM_reallocvector(L, f->code, f->sizecode, fs->pc, Instruction);
+  f->sizecode = fs->pc;
+  luaM_reallocvector(L, f->lineinfo, f->sizelineinfo, fs->pc, int);
+  f->sizelineinfo = fs->pc;
+  luaM_reallocvector(L, f->k, f->sizek, fs->nk, TValue);
+  f->sizek = fs->nk;
+  luaM_reallocvector(L, f->p, f->sizep, fs->np, Proto *);
+  f->sizep = fs->np;
+  luaM_reallocvector(L, f->locvars, f->sizelocvars, fs->nlocvars, LocVar);
+  f->sizelocvars = fs->nlocvars;
+  luaM_reallocvector(L, f->upvalues, f->sizeupvalues, fs->nups, Upvaldesc);
+  f->sizeupvalues = fs->nups;
+  lua_assert(fs->bl == NULL);
+  ls->fs = fs->prev;
+  /* last token read was anchored in defunct function; must re-anchor it */
+  anchor_token(ls);
+  L->top--;  /* pop table of constants */
+  luaC_checkGC(L);
+}
+
+
+
+/*============================================================*/
+/* GRAMMAR RULES */
+/*============================================================*/
+
+
+/*
+** check whether current token is in the follow set of a block.
+** 'until' closes syntactical blocks, but do not close scope,
+** so it handled in separate.
+*/
+static int block_follow (LexState *ls, int withuntil) {
+  switch (ls->t.token) {
+    case TK_ELSE: case TK_ELSEIF:
+    case TK_END: case TK_EOS:
+      return 1;
+    case TK_UNTIL: return withuntil;
+    default: return 0;
+  }
+}
+
+
+static void statlist (LexState *ls) {
+  /* statlist -> { stat [`;'] } */
+  while (!block_follow(ls, 1)) {
+    if (ls->t.token == TK_RETURN) {
+      statement(ls);
+      return;  /* 'return' must be last statement */
+    }
+    statement(ls);
+  }
+}
+
+
+static void fieldsel (LexState *ls, expdesc *v) {
+  /* fieldsel -> ['.' | ':'] NAME */
+  FuncState *fs = ls->fs;
+  expdesc key;
+  luaK_exp2anyregup(fs, v);
+  luaX_next(ls);  /* skip the dot or colon */
+  checkname(ls, &key);
+  luaK_indexed(fs, v, &key);
+}
+
+
+static void yindex (LexState *ls, expdesc *v) {
+  /* index -> '[' expr ']' */
+  luaX_next(ls);  /* skip the '[' */
+  expr(ls, v);
+  luaK_exp2val(ls->fs, v);
+  checknext(ls, ']');
+}
+
+
+/*
+** {======================================================================
+** Rules for Constructors
+** =======================================================================
+*/
+
+
+struct ConsControl {
+  expdesc v;  /* last list item read */
+  expdesc *t;  /* table descriptor */
+  int nh;  /* total number of `record' elements */
+  int na;  /* total number of array elements */
+  int tostore;  /* number of array elements pending to be stored */
+};
+
+
+static void recfield (LexState *ls, struct ConsControl *cc) {
+  /* recfield -> (NAME | `['exp1`]') = exp1 */
+  FuncState *fs = ls->fs;
+  int reg = ls->fs->freereg;
+  expdesc key, val;
+  int rkkey;
+  if (ls->t.token == TK_NAME) {
+    checklimit(fs, cc->nh, MAX_INT, "items in a constructor");
+    checkname(ls, &key);
+  }
+  else  /* ls->t.token == '[' */
+    yindex(ls, &key);
+  cc->nh++;
+  checknext(ls, '=');
+  rkkey = luaK_exp2RK(fs, &key);
+  expr(ls, &val);
+  luaK_codeABC(fs, OP_SETTABLE, cc->t->u.info, rkkey, luaK_exp2RK(fs, &val));
+  fs->freereg = reg;  /* free registers */
+}
+
+
+static void closelistfield (FuncState *fs, struct ConsControl *cc) {
+  if (cc->v.k == VVOID) return;  /* there is no list item */
+  luaK_exp2nextreg(fs, &cc->v);
+  cc->v.k = VVOID;
+  if (cc->tostore == LFIELDS_PER_FLUSH) {
+    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);  /* flush */
+    cc->tostore = 0;  /* no more items pending */
+  }
+}
+
+
+static void lastlistfield (FuncState *fs, struct ConsControl *cc) {
+  if (cc->tostore == 0) return;
+  if (hasmultret(cc->v.k)) {
+    luaK_setmultret(fs, &cc->v);
+    luaK_setlist(fs, cc->t->u.info, cc->na, LUA_MULTRET);
+    cc->na--;  /* do not count last expression (unknown number of elements) */
+  }
+  else {
+    if (cc->v.k != VVOID)
+      luaK_exp2nextreg(fs, &cc->v);
+    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);
+  }
+}
+
+
+static void listfield (LexState *ls, struct ConsControl *cc) {
+  /* listfield -> exp */
+  expr(ls, &cc->v);
+  checklimit(ls->fs, cc->na, MAX_INT, "items in a constructor");
+  cc->na++;
+  cc->tostore++;
+}
+
+
+static void field (LexState *ls, struct ConsControl *cc) {
+  /* field -> listfield | recfield */
+  switch(ls->t.token) {
+    case TK_NAME: {  /* may be 'listfield' or 'recfield' */
+      if (luaX_lookahead(ls) != '=')  /* expression? */
+        listfield(ls, cc);
+      else
+        recfield(ls, cc);
+      break;
+    }
+    case '[': {
+      recfield(ls, cc);
+      break;
+    }
+    default: {
+      listfield(ls, cc);
+      break;
+    }
+  }
+}
+
+
+static void constructor (LexState *ls, expdesc *t) {
+  /* constructor -> '{' [ field { sep field } [sep] ] '}'
+     sep -> ',' | ';' */
+  FuncState *fs = ls->fs;
+  int line = ls->linenumber;
+  int pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);
+  struct ConsControl cc;
+  cc.na = cc.nh = cc.tostore = 0;
+  cc.t = t;
+  init_exp(t, VRELOCABLE, pc);
+  init_exp(&cc.v, VVOID, 0);  /* no value (yet) */
+  luaK_exp2nextreg(ls->fs, t);  /* fix it at stack top */
+  checknext(ls, '{');
+  do {
+    lua_assert(cc.v.k == VVOID || cc.tostore > 0);
+    if (ls->t.token == '}') break;
+    closelistfield(fs, &cc);
+    field(ls, &cc);
+  } while (testnext(ls, ',') || testnext(ls, ';'));
+  check_match(ls, '}', '{', line);
+  lastlistfield(fs, &cc);
+  SETARG_B(fs->f->code[pc], luaO_int2fb(cc.na)); /* set initial array size */
+  SETARG_C(fs->f->code[pc], luaO_int2fb(cc.nh));  /* set initial table size */
+}
+
+/* }====================================================================== */
+
+
+
+static void parlist (LexState *ls) {
+  /* parlist -> [ param { `,' param } ] */
+  FuncState *fs = ls->fs;
+  Proto *f = fs->f;
+  int nparams = 0;
+  f->is_vararg = 0;
+  if (ls->t.token != ')') {  /* is `parlist' not empty? */
+    do {
+      switch (ls->t.token) {
+        case TK_NAME: {  /* param -> NAME */
+          new_localvar(ls, str_checkname(ls));
+          nparams++;
+          break;
+        }
+        case TK_DOTS: {  /* param -> `...' */
+          luaX_next(ls);
+          f->is_vararg = 1;
+          break;
+        }
+        default: luaX_syntaxerror(ls, "<name> or " LUA_QL("...") " expected");
+      }
+    } while (!f->is_vararg && testnext(ls, ','));
+  }
+  adjustlocalvars(ls, nparams);
+  f->numparams = cast_byte(fs->nactvar);
+  luaK_reserveregs(fs, fs->nactvar);  /* reserve register for parameters */
+}
+
+
+static void body (LexState *ls, expdesc *e, int ismethod, int line) {
+  /* body ->  `(' parlist `)' block END */
+  FuncState new_fs;
+  BlockCnt bl;
+  new_fs.f = addprototype(ls);
+  new_fs.f->linedefined = line;
+  open_func(ls, &new_fs, &bl);
+  checknext(ls, '(');
+  if (ismethod) {
+    new_localvarliteral(ls, "self");  /* create 'self' parameter */
+    adjustlocalvars(ls, 1);
+  }
+  parlist(ls);
+  checknext(ls, ')');
+  statlist(ls);
+  new_fs.f->lastlinedefined = ls->linenumber;
+  check_match(ls, TK_END, TK_FUNCTION, line);
+  codeclosure(ls, e);
+  close_func(ls);
+}
+
+
+static int explist (LexState *ls, expdesc *v) {
+  /* explist -> expr { `,' expr } */
+  int n = 1;  /* at least one expression */
+  expr(ls, v);
+  while (testnext(ls, ',')) {
+    luaK_exp2nextreg(ls->fs, v);
+    expr(ls, v);
+    n++;
+  }
+  return n;
+}
+
+
+static void funcargs (LexState *ls, expdesc *f, int line) {
+  FuncState *fs = ls->fs;
+  expdesc args;
+  int base, nparams;
+  switch (ls->t.token) {
+    case '(': {  /* funcargs -> `(' [ explist ] `)' */
+      luaX_next(ls);
+      if (ls->t.token == ')')  /* arg list is empty? */
+        args.k = VVOID;
+      else {
+        explist(ls, &args);
+        luaK_setmultret(fs, &args);
+      }
+      check_match(ls, ')', '(', line);
+      break;
+    }
+    case '{': {  /* funcargs -> constructor */
+      constructor(ls, &args);
+      break;
+    }
+    case TK_STRING: {  /* funcargs -> STRING */
+      codestring(ls, &args, ls->t.seminfo.ts);
+      luaX_next(ls);  /* must use `seminfo' before `next' */
+      break;
+    }
+    default: {
+      luaX_syntaxerror(ls, "function arguments expected");
+    }
+  }
+  lua_assert(f->k == VNONRELOC);
+  base = f->u.info;  /* base register for call */
+  if (hasmultret(args.k))
+    nparams = LUA_MULTRET;  /* open call */
+  else {
+    if (args.k != VVOID)
+      luaK_exp2nextreg(fs, &args);  /* close last argument */
+    nparams = fs->freereg - (base+1);
+  }
+  init_exp(f, VCALL, luaK_codeABC(fs, OP_CALL, base, nparams+1, 2));
+  luaK_fixline(fs, line);
+  fs->freereg = base+1;  /* call remove function and arguments and leaves
+                            (unless changed) one result */
+}
+
+
+
+
+/*
+** {======================================================================
+** Expression parsing
+** =======================================================================
+*/
+
+
+static void primaryexp (LexState *ls, expdesc *v) {
+  /* primaryexp -> NAME | '(' expr ')' */
+  switch (ls->t.token) {
+    case '(': {
+      int line = ls->linenumber;
+      luaX_next(ls);
+      expr(ls, v);
+      check_match(ls, ')', '(', line);
+      luaK_dischargevars(ls->fs, v);
+      return;
+    }
+    case TK_NAME: {
+      singlevar(ls, v);
+      return;
+    }
+    default: {
+      luaX_syntaxerror(ls, "unexpected symbol");
+    }
+  }
+}
+
+
+static void suffixedexp (LexState *ls, expdesc *v) {
+  /* suffixedexp ->
+       primaryexp { '.' NAME | '[' exp ']' | ':' NAME funcargs | funcargs } */
+  FuncState *fs = ls->fs;
+  int line = ls->linenumber;
+  primaryexp(ls, v);
+  for (;;) {
+    switch (ls->t.token) {
+      case '.': {  /* fieldsel */
+        fieldsel(ls, v);
+        break;
+      }
+      case '[': {  /* `[' exp1 `]' */
+        expdesc key;
+        luaK_exp2anyregup(fs, v);
+        yindex(ls, &key);
+        luaK_indexed(fs, v, &key);
+        break;
+      }
+      case ':': {  /* `:' NAME funcargs */
+        expdesc key;
+        luaX_next(ls);
+        checkname(ls, &key);
+        luaK_self(fs, v, &key);
+        funcargs(ls, v, line);
+        break;
+      }
+      case '(': case TK_STRING: case '{': {  /* funcargs */
+        luaK_exp2nextreg(fs, v);
+        funcargs(ls, v, line);
+        break;
+      }
+      default: return;
+    }
+  }
+}
+
+
+static void simpleexp (LexState *ls, expdesc *v) {
+  /* simpleexp -> NUMBER | STRING | NIL | TRUE | FALSE | ... |
+                  constructor | FUNCTION body | suffixedexp */
+  switch (ls->t.token) {
+    case TK_NUMBER: {
+      init_exp(v, VKNUM, 0);
+      v->u.nval = ls->t.seminfo.r;
+      break;
+    }
+    case TK_STRING: {
+      codestring(ls, v, ls->t.seminfo.ts);
+      break;
+    }
+    case TK_NIL: {
+      init_exp(v, VNIL, 0);
+      break;
+    }
+    case TK_TRUE: {
+      init_exp(v, VTRUE, 0);
+      break;
+    }
+    case TK_FALSE: {
+      init_exp(v, VFALSE, 0);
+      break;
+    }
+    case TK_DOTS: {  /* vararg */
+      FuncState *fs = ls->fs;
+      check_condition(ls, fs->f->is_vararg,
+                      "cannot use " LUA_QL("...") " outside a vararg function");
+      init_exp(v, VVARARG, luaK_codeABC(fs, OP_VARARG, 0, 1, 0));
+      break;
+    }
+    case '{': {  /* constructor */
+      constructor(ls, v);
+      return;
+    }
+    case TK_FUNCTION: {
+      luaX_next(ls);
+      body(ls, v, 0, ls->linenumber);
+      return;
+    }
+    default: {
+      suffixedexp(ls, v);
+      return;
+    }
+  }
+  luaX_next(ls);
+}
+
+
+static UnOpr getunopr (int op) {
+  switch (op) {
+    case TK_NOT: return OPR_NOT;
+    case '-': return OPR_MINUS;
+    case '#': return OPR_LEN;
+    default: return OPR_NOUNOPR;
+  }
+}
+
+
+static BinOpr getbinopr (int op) {
+  switch (op) {
+    case '+': return OPR_ADD;
+    case '-': return OPR_SUB;
+    case '*': return OPR_MUL;
+    case '/': return OPR_DIV;
+    case '%': return OPR_MOD;
+    case '^': return OPR_POW;
+    case TK_CONCAT: return OPR_CONCAT;
+    case TK_NE: return OPR_NE;
+    case TK_EQ: return OPR_EQ;
+    case '<': return OPR_LT;
+    case TK_LE: return OPR_LE;
+    case '>': return OPR_GT;
+    case TK_GE: return OPR_GE;
+    case TK_AND: return OPR_AND;
+    case TK_OR: return OPR_OR;
+    default: return OPR_NOBINOPR;
+  }
+}
+
+
+static const struct {
+  lu_byte left;  /* left priority for each binary operator */
+  lu_byte right; /* right priority */
+} priority[] = {  /* ORDER OPR */
+   {6, 6}, {6, 6}, {7, 7}, {7, 7}, {7, 7},  /* `+' `-' `*' `/' `%' */
+   {10, 9}, {5, 4},                 /* ^, .. (right associative) */
+   {3, 3}, {3, 3}, {3, 3},          /* ==, <, <= */
+   {3, 3}, {3, 3}, {3, 3},          /* ~=, >, >= */
+   {2, 2}, {1, 1}                   /* and, or */
+};
+
+#define UNARY_PRIORITY	8  /* priority for unary operators */
+
+
+/*
+** subexpr -> (simpleexp | unop subexpr) { binop subexpr }
+** where `binop' is any binary operator with a priority higher than `limit'
+*/
+static BinOpr subexpr (LexState *ls, expdesc *v, int limit) {
+  BinOpr op;
+  UnOpr uop;
+  enterlevel(ls);
+  uop = getunopr(ls->t.token);
+  if (uop != OPR_NOUNOPR) {
+    int line = ls->linenumber;
+    luaX_next(ls);
+    subexpr(ls, v, UNARY_PRIORITY);
+    luaK_prefix(ls->fs, uop, v, line);
+  }
+  else simpleexp(ls, v);
+  /* expand while operators have priorities higher than `limit' */
+  op = getbinopr(ls->t.token);
+  while (op != OPR_NOBINOPR && priority[op].left > limit) {
+    expdesc v2;
+    BinOpr nextop;
+    int line = ls->linenumber;
+    luaX_next(ls);
+    luaK_infix(ls->fs, op, v);
+    /* read sub-expression with higher priority */
+    nextop = subexpr(ls, &v2, priority[op].right);
+    luaK_posfix(ls->fs, op, v, &v2, line);
+    op = nextop;
+  }
+  leavelevel(ls);
+  return op;  /* return first untreated operator */
+}
+
+
+static void expr (LexState *ls, expdesc *v) {
+  subexpr(ls, v, 0);
+}
+
+/* }==================================================================== */
+
+
+
+/*
+** {======================================================================
+** Rules for Statements
+** =======================================================================
+*/
+
+
+static void block (LexState *ls) {
+  /* block -> statlist */
+  FuncState *fs = ls->fs;
+  BlockCnt bl;
+  enterblock(fs, &bl, 0);
+  statlist(ls);
+  leaveblock(fs);
+}
+
+
+/*
+** structure to chain all variables in the left-hand side of an
+** assignment
+*/
+struct LHS_assign {
+  struct LHS_assign *prev;
+  expdesc v;  /* variable (global, local, upvalue, or indexed) */
+};
+
+
+/*
+** check whether, in an assignment to an upvalue/local variable, the
+** upvalue/local variable is begin used in a previous assignment to a
+** table. If so, save original upvalue/local value in a safe place and
+** use this safe copy in the previous assignment.
+*/
+static void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v) {
+  FuncState *fs = ls->fs;
+  int extra = fs->freereg;  /* eventual position to save local variable */
+  int conflict = 0;
+  for (; lh; lh = lh->prev) {  /* check all previous assignments */
+    if (lh->v.k == VINDEXED) {  /* assigning to a table? */
+      /* table is the upvalue/local being assigned now? */
+      if (lh->v.u.ind.vt == v->k && lh->v.u.ind.t == v->u.info) {
+        conflict = 1;
+        lh->v.u.ind.vt = VLOCAL;
+        lh->v.u.ind.t = extra;  /* previous assignment will use safe copy */
+      }
+      /* index is the local being assigned? (index cannot be upvalue) */
+      if (v->k == VLOCAL && lh->v.u.ind.idx == v->u.info) {
+        conflict = 1;
+        lh->v.u.ind.idx = extra;  /* previous assignment will use safe copy */
+      }
+    }
+  }
+  if (conflict) {
+    /* copy upvalue/local value to a temporary (in position 'extra') */
+    OpCode op = (v->k == VLOCAL) ? OP_MOVE : OP_GETUPVAL;
+    luaK_codeABC(fs, op, extra, v->u.info, 0);
+    luaK_reserveregs(fs, 1);
+  }
+}
+
+
+static void assignment (LexState *ls, struct LHS_assign *lh, int nvars) {
+  expdesc e;
+  check_condition(ls, vkisvar(lh->v.k), "syntax error");
+  if (testnext(ls, ',')) {  /* assignment -> ',' suffixedexp assignment */
+    struct LHS_assign nv;
+    nv.prev = lh;
+    suffixedexp(ls, &nv.v);
+    if (nv.v.k != VINDEXED)
+      check_conflict(ls, lh, &nv.v);
+    checklimit(ls->fs, nvars + ls->L->nCcalls, LUAI_MAXCCALLS,
+                    "C levels");
+    assignment(ls, &nv, nvars+1);
+  }
+  else {  /* assignment -> `=' explist */
+    int nexps;
+    checknext(ls, '=');
+    nexps = explist(ls, &e);
+    if (nexps != nvars) {
+      adjust_assign(ls, nvars, nexps, &e);
+      if (nexps > nvars)
+        ls->fs->freereg -= nexps - nvars;  /* remove extra values */
+    }
+    else {
+      luaK_setoneret(ls->fs, &e);  /* close last expression */
+      luaK_storevar(ls->fs, &lh->v, &e);
+      return;  /* avoid default */
+    }
+  }
+  init_exp(&e, VNONRELOC, ls->fs->freereg-1);  /* default assignment */
+  luaK_storevar(ls->fs, &lh->v, &e);
+}
+
+
+static int cond (LexState *ls) {
+  /* cond -> exp */
+  expdesc v;
+  expr(ls, &v);  /* read condition */
+  if (v.k == VNIL) v.k = VFALSE;  /* `falses' are all equal here */
+  luaK_goiftrue(ls->fs, &v);
+  return v.f;
+}
+
+
+static void gotostat (LexState *ls, int pc) {
+  int line = ls->linenumber;
+  TString *label;
+  int g;
+  if (testnext(ls, TK_GOTO))
+    label = str_checkname(ls);
+  else {
+    luaX_next(ls);  /* skip break */
+    label = luaS_new(ls->L, "break");
+  }
+  g = newlabelentry(ls, &ls->dyd->gt, label, line, pc);
+  findlabel(ls, g);  /* close it if label already defined */
+}
+
+
+/* check for repeated labels on the same block */
+static void checkrepeated (FuncState *fs, Labellist *ll, TString *label) {
+  int i;
+  for (i = fs->bl->firstlabel; i < ll->n; i++) {
+    if (luaS_eqstr(label, ll->arr[i].name)) {
+      const char *msg = luaO_pushfstring(fs->ls->L,
+                          "label " LUA_QS " already defined on line %d",
+                          getstr(label), ll->arr[i].line);
+      semerror(fs->ls, msg);
+    }
+  }
+}
+
+
+/* skip no-op statements */
+static void skipnoopstat (LexState *ls) {
+  while (ls->t.token == ';' || ls->t.token == TK_DBCOLON)
+    statement(ls);
+}
+
+
+static void labelstat (LexState *ls, TString *label, int line) {
+  /* label -> '::' NAME '::' */
+  FuncState *fs = ls->fs;
+  Labellist *ll = &ls->dyd->label;
+  int l;  /* index of new label being created */
+  checkrepeated(fs, ll, label);  /* check for repeated labels */
+  checknext(ls, TK_DBCOLON);  /* skip double colon */
+  /* create new entry for this label */
+  l = newlabelentry(ls, ll, label, line, fs->pc);
+  skipnoopstat(ls);  /* skip other no-op statements */
+  if (block_follow(ls, 0)) {  /* label is last no-op statement in the block? */
+    /* assume that locals are already out of scope */
+    ll->arr[l].nactvar = fs->bl->nactvar;
+  }
+  findgotos(ls, &ll->arr[l]);
+}
+
+
+static void whilestat (LexState *ls, int line) {
+  /* whilestat -> WHILE cond DO block END */
+  FuncState *fs = ls->fs;
+  int whileinit;
+  int condexit;
+  BlockCnt bl;
+  luaX_next(ls);  /* skip WHILE */
+  whileinit = luaK_getlabel(fs);
+  condexit = cond(ls);
+  enterblock(fs, &bl, 1);
+  checknext(ls, TK_DO);
+  block(ls);
+  luaK_jumpto(fs, whileinit);
+  check_match(ls, TK_END, TK_WHILE, line);
+  leaveblock(fs);
+  luaK_patchtohere(fs, condexit);  /* false conditions finish the loop */
+}
+
+
+static void repeatstat (LexState *ls, int line) {
+  /* repeatstat -> REPEAT block UNTIL cond */
+  int condexit;
+  FuncState *fs = ls->fs;
+  int repeat_init = luaK_getlabel(fs);
+  BlockCnt bl1, bl2;
+  enterblock(fs, &bl1, 1);  /* loop block */
+  enterblock(fs, &bl2, 0);  /* scope block */
+  luaX_next(ls);  /* skip REPEAT */
+  statlist(ls);
+  check_match(ls, TK_UNTIL, TK_REPEAT, line);
+  condexit = cond(ls);  /* read condition (inside scope block) */
+  if (bl2.upval)  /* upvalues? */
+    luaK_patchclose(fs, condexit, bl2.nactvar);
+  leaveblock(fs);  /* finish scope */
+  luaK_patchlist(fs, condexit, repeat_init);  /* close the loop */
+  leaveblock(fs);  /* finish loop */
+}
+
+
+static int exp1 (LexState *ls) {
+  expdesc e;
+  int reg;
+  expr(ls, &e);
+  luaK_exp2nextreg(ls->fs, &e);
+  lua_assert(e.k == VNONRELOC);
+  reg = e.u.info;
+  return reg;
+}
+
+
+static void forbody (LexState *ls, int base, int line, int nvars, int isnum) {
+  /* forbody -> DO block */
+  BlockCnt bl;
+  FuncState *fs = ls->fs;
+  int prep, endfor;
+  adjustlocalvars(ls, 3);  /* control variables */
+  checknext(ls, TK_DO);
+  prep = isnum ? luaK_codeAsBx(fs, OP_FORPREP, base, NO_JUMP) : luaK_jump(fs);
+  enterblock(fs, &bl, 0);  /* scope for declared variables */
+  adjustlocalvars(ls, nvars);
+  luaK_reserveregs(fs, nvars);
+  block(ls);
+  leaveblock(fs);  /* end of scope for declared variables */
+  luaK_patchtohere(fs, prep);
+  if (isnum)  /* numeric for? */
+    endfor = luaK_codeAsBx(fs, OP_FORLOOP, base, NO_JUMP);
+  else {  /* generic for */
+    luaK_codeABC(fs, OP_TFORCALL, base, 0, nvars);
+    luaK_fixline(fs, line);
+    endfor = luaK_codeAsBx(fs, OP_TFORLOOP, base + 2, NO_JUMP);
+  }
+  luaK_patchlist(fs, endfor, prep + 1);
+  luaK_fixline(fs, line);
+}
+
+
+static void fornum (LexState *ls, TString *varname, int line) {
+  /* fornum -> NAME = exp1,exp1[,exp1] forbody */
+  FuncState *fs = ls->fs;
+  int base = fs->freereg;
+  new_localvarliteral(ls, "(for index)");
+  new_localvarliteral(ls, "(for limit)");
+  new_localvarliteral(ls, "(for step)");
+  new_localvar(ls, varname);
+  checknext(ls, '=');
+  exp1(ls);  /* initial value */
+  checknext(ls, ',');
+  exp1(ls);  /* limit */
+  if (testnext(ls, ','))
+    exp1(ls);  /* optional step */
+  else {  /* default step = 1 */
+    luaK_codek(fs, fs->freereg, luaK_numberK(fs, 1));
+    luaK_reserveregs(fs, 1);
+  }
+  forbody(ls, base, line, 1, 1);
+}
+
+
+static void forlist (LexState *ls, TString *indexname) {
+  /* forlist -> NAME {,NAME} IN explist forbody */
+  FuncState *fs = ls->fs;
+  expdesc e;
+  int nvars = 4;  /* gen, state, control, plus at least one declared var */
+  int line;
+  int base = fs->freereg;
+  /* create control variables */
+  new_localvarliteral(ls, "(for generator)");
+  new_localvarliteral(ls, "(for state)");
+  new_localvarliteral(ls, "(for control)");
+  /* create declared variables */
+  new_localvar(ls, indexname);
+  while (testnext(ls, ',')) {
+    new_localvar(ls, str_checkname(ls));
+    nvars++;
+  }
+  checknext(ls, TK_IN);
+  line = ls->linenumber;
+  adjust_assign(ls, 3, explist(ls, &e), &e);
+  luaK_checkstack(fs, 3);  /* extra space to call generator */
+  forbody(ls, base, line, nvars - 3, 0);
+}
+
+
+static void forstat (LexState *ls, int line) {
+  /* forstat -> FOR (fornum | forlist) END */
+  FuncState *fs = ls->fs;
+  TString *varname;
+  BlockCnt bl;
+  enterblock(fs, &bl, 1);  /* scope for loop and control variables */
+  luaX_next(ls);  /* skip `for' */
+  varname = str_checkname(ls);  /* first variable name */
+  switch (ls->t.token) {
+    case '=': fornum(ls, varname, line); break;
+    case ',': case TK_IN: forlist(ls, varname); break;
+    default: luaX_syntaxerror(ls, LUA_QL("=") " or " LUA_QL("in") " expected");
+  }
+  check_match(ls, TK_END, TK_FOR, line);
+  leaveblock(fs);  /* loop scope (`break' jumps to this point) */
+}
+
+
+static void test_then_block (LexState *ls, int *escapelist) {
+  /* test_then_block -> [IF | ELSEIF] cond THEN block */
+  BlockCnt bl;
+  FuncState *fs = ls->fs;
+  expdesc v;
+  int jf;  /* instruction to skip 'then' code (if condition is false) */
+  luaX_next(ls);  /* skip IF or ELSEIF */
+  expr(ls, &v);  /* read condition */
+  checknext(ls, TK_THEN);
+  if (ls->t.token == TK_GOTO || ls->t.token == TK_BREAK) {
+    luaK_goiffalse(ls->fs, &v);  /* will jump to label if condition is true */
+    enterblock(fs, &bl, 0);  /* must enter block before 'goto' */
+    gotostat(ls, v.t);  /* handle goto/break */
+    skipnoopstat(ls);  /* skip other no-op statements */
+    if (block_follow(ls, 0)) {  /* 'goto' is the entire block? */
+      leaveblock(fs);
+      return;  /* and that is it */
+    }
+    else  /* must skip over 'then' part if condition is false */
+      jf = luaK_jump(fs);
+  }
+  else {  /* regular case (not goto/break) */
+    luaK_goiftrue(ls->fs, &v);  /* skip over block if condition is false */
+    enterblock(fs, &bl, 0);
+    jf = v.f;
+  }
+  statlist(ls);  /* `then' part */
+  leaveblock(fs);
+  if (ls->t.token == TK_ELSE ||
+      ls->t.token == TK_ELSEIF)  /* followed by 'else'/'elseif'? */
+    luaK_concat(fs, escapelist, luaK_jump(fs));  /* must jump over it */
+  luaK_patchtohere(fs, jf);
+}
+
+
+static void ifstat (LexState *ls, int line) {
+  /* ifstat -> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */
+  FuncState *fs = ls->fs;
+  int escapelist = NO_JUMP;  /* exit list for finished parts */
+  test_then_block(ls, &escapelist);  /* IF cond THEN block */
+  while (ls->t.token == TK_ELSEIF)
+    test_then_block(ls, &escapelist);  /* ELSEIF cond THEN block */
+  if (testnext(ls, TK_ELSE))
+    block(ls);  /* `else' part */
+  check_match(ls, TK_END, TK_IF, line);
+  luaK_patchtohere(fs, escapelist);  /* patch escape list to 'if' end */
+}
+
+
+static void localfunc (LexState *ls) {
+  expdesc b;
+  FuncState *fs = ls->fs;
+  new_localvar(ls, str_checkname(ls));  /* new local variable */
+  adjustlocalvars(ls, 1);  /* enter its scope */
+  body(ls, &b, 0, ls->linenumber);  /* function created in next register */
+  /* debug information will only see the variable after this point! */
+  getlocvar(fs, b.u.info)->startpc = fs->pc;
+}
+
+
+static void localstat (LexState *ls) {
+  /* stat -> LOCAL NAME {`,' NAME} [`=' explist] */
+  int nvars = 0;
+  int nexps;
+  expdesc e;
+  do {
+    new_localvar(ls, str_checkname(ls));
+    nvars++;
+  } while (testnext(ls, ','));
+  if (testnext(ls, '='))
+    nexps = explist(ls, &e);
+  else {
+    e.k = VVOID;
+    nexps = 0;
+  }
+  adjust_assign(ls, nvars, nexps, &e);
+  adjustlocalvars(ls, nvars);
+}
+
+
+static int funcname (LexState *ls, expdesc *v) {
+  /* funcname -> NAME {fieldsel} [`:' NAME] */
+  int ismethod = 0;
+  singlevar(ls, v);
+  while (ls->t.token == '.')
+    fieldsel(ls, v);
+  if (ls->t.token == ':') {
+    ismethod = 1;
+    fieldsel(ls, v);
+  }
+  return ismethod;
+}
+
+
+static void funcstat (LexState *ls, int line) {
+  /* funcstat -> FUNCTION funcname body */
+  int ismethod;
+  expdesc v, b;
+  luaX_next(ls);  /* skip FUNCTION */
+  ismethod = funcname(ls, &v);
+  body(ls, &b, ismethod, line);
+  luaK_storevar(ls->fs, &v, &b);
+  luaK_fixline(ls->fs, line);  /* definition `happens' in the first line */
+}
+
+
+static void exprstat (LexState *ls) {
+  /* stat -> func | assignment */
+  FuncState *fs = ls->fs;
+  struct LHS_assign v;
+  suffixedexp(ls, &v.v);
+  if (ls->t.token == '=' || ls->t.token == ',') { /* stat -> assignment ? */
+    v.prev = NULL;
+    assignment(ls, &v, 1);
+  }
+  else {  /* stat -> func */
+    check_condition(ls, v.v.k == VCALL, "syntax error");
+    SETARG_C(getcode(fs, &v.v), 1);  /* call statement uses no results */
+  }
+}
+
+
+static void retstat (LexState *ls) {
+  /* stat -> RETURN [explist] [';'] */
+  FuncState *fs = ls->fs;
+  expdesc e;
+  int first, nret;  /* registers with returned values */
+  if (block_follow(ls, 1) || ls->t.token == ';')
+    first = nret = 0;  /* return no values */
+  else {
+    nret = explist(ls, &e);  /* optional return values */
+    if (hasmultret(e.k)) {
+      luaK_setmultret(fs, &e);
+      if (e.k == VCALL && nret == 1) {  /* tail call? */
+        SET_OPCODE(getcode(fs,&e), OP_TAILCALL);
+        lua_assert(GETARG_A(getcode(fs,&e)) == fs->nactvar);
+      }
+      first = fs->nactvar;
+      nret = LUA_MULTRET;  /* return all values */
+    }
+    else {
+      if (nret == 1)  /* only one single value? */
+        first = luaK_exp2anyreg(fs, &e);
+      else {
+        luaK_exp2nextreg(fs, &e);  /* values must go to the `stack' */
+        first = fs->nactvar;  /* return all `active' values */
+        lua_assert(nret == fs->freereg - first);
+      }
+    }
+  }
+  luaK_ret(fs, first, nret);
+  testnext(ls, ';');  /* skip optional semicolon */
+}
+
+
+static void statement (LexState *ls) {
+  int line = ls->linenumber;  /* may be needed for error messages */
+  enterlevel(ls);
+  switch (ls->t.token) {
+    case ';': {  /* stat -> ';' (empty statement) */
+      luaX_next(ls);  /* skip ';' */
+      break;
+    }
+    case TK_IF: {  /* stat -> ifstat */
+      ifstat(ls, line);
+      break;
+    }
+    case TK_WHILE: {  /* stat -> whilestat */
+      whilestat(ls, line);
+      break;
+    }
+    case TK_DO: {  /* stat -> DO block END */
+      luaX_next(ls);  /* skip DO */
+      block(ls);
+      check_match(ls, TK_END, TK_DO, line);
+      break;
+    }
+    case TK_FOR: {  /* stat -> forstat */
+      forstat(ls, line);
+      break;
+    }
+    case TK_REPEAT: {  /* stat -> repeatstat */
+      repeatstat(ls, line);
+      break;
+    }
+    case TK_FUNCTION: {  /* stat -> funcstat */
+      funcstat(ls, line);
+      break;
+    }
+    case TK_LOCAL: {  /* stat -> localstat */
+      luaX_next(ls);  /* skip LOCAL */
+      if (testnext(ls, TK_FUNCTION))  /* local function? */
+        localfunc(ls);
+      else
+        localstat(ls);
+      break;
+    }
+    case TK_DBCOLON: {  /* stat -> label */
+      luaX_next(ls);  /* skip double colon */
+      labelstat(ls, str_checkname(ls), line);
+      break;
+    }
+    case TK_RETURN: {  /* stat -> retstat */
+      luaX_next(ls);  /* skip RETURN */
+      retstat(ls);
+      break;
+    }
+    case TK_BREAK:   /* stat -> breakstat */
+    case TK_GOTO: {  /* stat -> 'goto' NAME */
+      gotostat(ls, luaK_jump(ls->fs));
+      break;
+    }
+    default: {  /* stat -> func | assignment */
+      exprstat(ls);
+      break;
+    }
+  }
+  lua_assert(ls->fs->f->maxstacksize >= ls->fs->freereg &&
+             ls->fs->freereg >= ls->fs->nactvar);
+  ls->fs->freereg = ls->fs->nactvar;  /* free registers */
+  leavelevel(ls);
+}
+
+/* }====================================================================== */
+
+
+/*
+** compiles the main function, which is a regular vararg function with an
+** upvalue named LUA_ENV
+*/
+static void mainfunc (LexState *ls, FuncState *fs) {
+  BlockCnt bl;
+  expdesc v;
+  open_func(ls, fs, &bl);
+  fs->f->is_vararg = 1;  /* main function is always vararg */
+  init_exp(&v, VLOCAL, 0);  /* create and... */
+  newupvalue(fs, ls->envn, &v);  /* ...set environment upvalue */
+  luaX_next(ls);  /* read first token */
+  statlist(ls);  /* parse main body */
+  check(ls, TK_EOS);
+  close_func(ls);
+}
+
+
+Closure *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff,
+                      Dyndata *dyd, const char *name, int firstchar) {
+  LexState lexstate;
+  FuncState funcstate;
+  Closure *cl = luaF_newLclosure(L, 1);  /* create main closure */
+  /* anchor closure (to avoid being collected) */
+  setclLvalue(L, L->top, cl);
+  incr_top(L);
+  funcstate.f = cl->l.p = luaF_newproto(L);
+  funcstate.f->source = luaS_new(L, name);  /* create and anchor TString */
+  lexstate.buff = buff;
+  lexstate.dyd = dyd;
+  dyd->actvar.n = dyd->gt.n = dyd->label.n = 0;
+  luaX_setinput(L, &lexstate, z, funcstate.f->source, firstchar);
+  mainfunc(&lexstate, &funcstate);
+  lua_assert(!funcstate.prev && funcstate.nups == 1 && !lexstate.fs);
+  /* all scopes should be correctly finished */
+  lua_assert(dyd->actvar.n == 0 && dyd->gt.n == 0 && dyd->label.n == 0);
+  return cl;  /* it's on the stack too */
+}
+
diff -ruNp src.orig/libs/lua/lparser.h src/libs/lua/lparser.h
--- src.orig/libs/lua/lparser.h	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lparser.h	2017-11-21 19:39:46 -0600
@@ -0,0 +1,119 @@
+/*
+** $Id: lparser.h,v 1.70 2012/05/08 13:53:33 roberto Exp $
+** Lua Parser
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lparser_h
+#define lparser_h
+
+#include "llimits.h"
+#include "lobject.h"
+#include "lzio.h"
+
+
+/*
+** Expression descriptor
+*/
+
+typedef enum {
+  VVOID,	/* no value */
+  VNIL,
+  VTRUE,
+  VFALSE,
+  VK,		/* info = index of constant in `k' */
+  VKNUM,	/* nval = numerical value */
+  VNONRELOC,	/* info = result register */
+  VLOCAL,	/* info = local register */
+  VUPVAL,       /* info = index of upvalue in 'upvalues' */
+  VINDEXED,	/* t = table register/upvalue; idx = index R/K */
+  VJMP,		/* info = instruction pc */
+  VRELOCABLE,	/* info = instruction pc */
+  VCALL,	/* info = instruction pc */
+  VVARARG	/* info = instruction pc */
+} expkind;
+
+
+#define vkisvar(k)	(VLOCAL <= (k) && (k) <= VINDEXED)
+#define vkisinreg(k)	((k) == VNONRELOC || (k) == VLOCAL)
+
+typedef struct expdesc {
+  expkind k;
+  union {
+    struct {  /* for indexed variables (VINDEXED) */
+      short idx;  /* index (R/K) */
+      lu_byte t;  /* table (register or upvalue) */
+      lu_byte vt;  /* whether 't' is register (VLOCAL) or upvalue (VUPVAL) */
+    } ind;
+    int info;  /* for generic use */
+    lua_Number nval;  /* for VKNUM */
+  } u;
+  int t;  /* patch list of `exit when true' */
+  int f;  /* patch list of `exit when false' */
+} expdesc;
+
+
+/* description of active local variable */
+typedef struct Vardesc {
+  short idx;  /* variable index in stack */
+} Vardesc;
+
+
+/* description of pending goto statements and label statements */
+typedef struct Labeldesc {
+  TString *name;  /* label identifier */
+  int pc;  /* position in code */
+  int line;  /* line where it appeared */
+  lu_byte nactvar;  /* local level where it appears in current block */
+} Labeldesc;
+
+
+/* list of labels or gotos */
+typedef struct Labellist {
+  Labeldesc *arr;  /* array */
+  int n;  /* number of entries in use */
+  int size;  /* array size */
+} Labellist;
+
+
+/* dynamic structures used by the parser */
+typedef struct Dyndata {
+  struct {  /* list of active local variables */
+    Vardesc *arr;
+    int n;
+    int size;
+  } actvar;
+  Labellist gt;  /* list of pending gotos */
+  Labellist label;   /* list of active labels */
+} Dyndata;
+
+
+/* control of blocks */
+struct BlockCnt;  /* defined in lparser.c */
+
+
+/* state needed to generate code for a given function */
+typedef struct FuncState {
+  Proto *f;  /* current function header */
+  Table *h;  /* table to find (and reuse) elements in `k' */
+  struct FuncState *prev;  /* enclosing function */
+  struct LexState *ls;  /* lexical state */
+  struct BlockCnt *bl;  /* chain of current blocks */
+  int pc;  /* next position to code (equivalent to `ncode') */
+  int lasttarget;   /* 'label' of last 'jump label' */
+  int jpc;  /* list of pending jumps to `pc' */
+  int nk;  /* number of elements in `k' */
+  int np;  /* number of elements in `p' */
+  int firstlocal;  /* index of first local var (in Dyndata array) */
+  short nlocvars;  /* number of elements in 'f->locvars' */
+  lu_byte nactvar;  /* number of active local variables */
+  lu_byte nups;  /* number of upvalues */
+  lu_byte freereg;  /* first free register */
+} FuncState;
+
+
+LUAI_FUNC Closure *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff,
+                                Dyndata *dyd, const char *name, int firstchar);
+
+
+#endif
diff -ruNp src.orig/libs/lua/lstate.c src/libs/lua/lstate.c
--- src.orig/libs/lua/lstate.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lstate.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,322 @@
+/*
+** $Id: lstate.c,v 2.99 2012/10/02 17:40:53 roberto Exp $
+** Global State
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stddef.h>
+#include <string.h>
+
+#define lstate_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lapi.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "llex.h"
+#include "lmem.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+
+
+#if !defined(LUAI_GCPAUSE)
+#define LUAI_GCPAUSE	200  /* 200% */
+#endif
+
+#if !defined(LUAI_GCMAJOR)
+#define LUAI_GCMAJOR	200  /* 200% */
+#endif
+
+#if !defined(LUAI_GCMUL)
+#define LUAI_GCMUL	200 /* GC runs 'twice the speed' of memory allocation */
+#endif
+
+
+#define MEMERRMSG	"not enough memory"
+
+
+/*
+** a macro to help the creation of a unique random seed when a state is
+** created; the seed is used to randomize hashes.
+*/
+#if !defined(luai_makeseed)
+#include <time.h>
+#define luai_makeseed()		cast(unsigned int, time(NULL))
+#endif
+
+
+
+/*
+** thread state + extra space
+*/
+typedef struct LX {
+#if defined(LUAI_EXTRASPACE)
+  char buff[LUAI_EXTRASPACE];
+#endif
+  lua_State l;
+} LX;
+
+
+/*
+** Main thread combines a thread state and the global state
+*/
+typedef struct LG {
+  LX l;
+  global_State g;
+} LG;
+
+
+
+#define fromstate(L)	(cast(LX *, cast(lu_byte *, (L)) - offsetof(LX, l)))
+
+
+/*
+** Compute an initial seed as random as possible. In ANSI, rely on
+** Address Space Layout Randomization (if present) to increase
+** randomness..
+*/
+#define addbuff(b,p,e) \
+  { size_t t = cast(size_t, e); \
+    memcpy(buff + p, &t, sizeof(t)); p += sizeof(t); }
+
+static unsigned int makeseed (lua_State *L) {
+  char buff[4 * sizeof(size_t)];
+  unsigned int h = luai_makeseed();
+  int p = 0;
+  addbuff(buff, p, L);  /* heap variable */
+  addbuff(buff, p, &h);  /* local variable */
+  addbuff(buff, p, luaO_nilobject);  /* global variable */
+  addbuff(buff, p, &lua_newstate);  /* public function */
+  lua_assert(p == sizeof(buff));
+  return luaS_hash(buff, p, h);
+}
+
+
+/*
+** set GCdebt to a new value keeping the value (totalbytes + GCdebt)
+** invariant
+*/
+void luaE_setdebt (global_State *g, l_mem debt) {
+  g->totalbytes -= (debt - g->GCdebt);
+  g->GCdebt = debt;
+}
+
+
+CallInfo *luaE_extendCI (lua_State *L) {
+  CallInfo *ci = luaM_new(L, CallInfo);
+  lua_assert(L->ci->next == NULL);
+  L->ci->next = ci;
+  ci->previous = L->ci;
+  ci->next = NULL;
+  return ci;
+}
+
+
+void luaE_freeCI (lua_State *L) {
+  CallInfo *ci = L->ci;
+  CallInfo *next = ci->next;
+  ci->next = NULL;
+  while ((ci = next) != NULL) {
+    next = ci->next;
+    luaM_free(L, ci);
+  }
+}
+
+
+static void stack_init (lua_State *L1, lua_State *L) {
+  int i; CallInfo *ci;
+  /* initialize stack array */
+  L1->stack = luaM_newvector(L, BASIC_STACK_SIZE, TValue);
+  L1->stacksize = BASIC_STACK_SIZE;
+  for (i = 0; i < BASIC_STACK_SIZE; i++)
+    setnilvalue(L1->stack + i);  /* erase new stack */
+  L1->top = L1->stack;
+  L1->stack_last = L1->stack + L1->stacksize - EXTRA_STACK;
+  /* initialize first ci */
+  ci = &L1->base_ci;
+  ci->next = ci->previous = NULL;
+  ci->callstatus = 0;
+  ci->func = L1->top;
+  setnilvalue(L1->top++);  /* 'function' entry for this 'ci' */
+  ci->top = L1->top + LUA_MINSTACK;
+  L1->ci = ci;
+}
+
+
+static void freestack (lua_State *L) {
+  if (L->stack == NULL)
+    return;  /* stack not completely built yet */
+  L->ci = &L->base_ci;  /* free the entire 'ci' list */
+  luaE_freeCI(L);
+  luaM_freearray(L, L->stack, L->stacksize);  /* free stack array */
+}
+
+
+/*
+** Create registry table and its predefined values
+*/
+static void init_registry (lua_State *L, global_State *g) {
+  TValue mt;
+  /* create registry */
+  Table *registry = luaH_new(L);
+  sethvalue(L, &g->l_registry, registry);
+  luaH_resize(L, registry, LUA_RIDX_LAST, 0);
+  /* registry[LUA_RIDX_MAINTHREAD] = L */
+  setthvalue(L, &mt, L);
+  luaH_setint(L, registry, LUA_RIDX_MAINTHREAD, &mt);
+  /* registry[LUA_RIDX_GLOBALS] = table of globals */
+  sethvalue(L, &mt, luaH_new(L));
+  luaH_setint(L, registry, LUA_RIDX_GLOBALS, &mt);
+}
+
+
+/*
+** open parts of the state that may cause memory-allocation errors
+*/
+static void f_luaopen (lua_State *L, void *ud) {
+  global_State *g = G(L);
+  UNUSED(ud);
+  stack_init(L, L);  /* init stack */
+  init_registry(L, g);
+  luaS_resize(L, MINSTRTABSIZE);  /* initial size of string table */
+  luaT_init(L);
+  luaX_init(L);
+  /* pre-create memory-error message */
+  g->memerrmsg = luaS_newliteral(L, MEMERRMSG);
+  luaS_fix(g->memerrmsg);  /* it should never be collected */
+  g->gcrunning = 1;  /* allow gc */
+}
+
+
+/*
+** preinitialize a state with consistent values without allocating
+** any memory (to avoid errors)
+*/
+static void preinit_state (lua_State *L, global_State *g) {
+  G(L) = g;
+  L->stack = NULL;
+  L->ci = NULL;
+  L->stacksize = 0;
+  L->errorJmp = NULL;
+  L->nCcalls = 0;
+  L->hook = NULL;
+  L->hookmask = 0;
+  L->basehookcount = 0;
+  L->allowhook = 1;
+  resethookcount(L);
+  L->openupval = NULL;
+  L->nny = 1;
+  L->status = LUA_OK;
+  L->errfunc = 0;
+}
+
+
+static void close_state (lua_State *L) {
+  global_State *g = G(L);
+  luaF_close(L, L->stack);  /* close all upvalues for this thread */
+  luaC_freeallobjects(L);  /* collect all objects */
+  luaM_freearray(L, G(L)->strt.hash, G(L)->strt.size);
+  luaZ_freebuffer(L, &g->buff);
+  freestack(L);
+  lua_assert(gettotalbytes(g) == sizeof(LG));
+  (*g->frealloc)(g->ud, fromstate(L), sizeof(LG), 0);  /* free main block */
+}
+
+
+LUA_API lua_State *lua_newthread (lua_State *L) {
+  lua_State *L1;
+  lua_lock(L);
+  luaC_checkGC(L);
+  L1 = &luaC_newobj(L, LUA_TTHREAD, sizeof(LX), NULL, offsetof(LX, l))->th;
+  setthvalue(L, L->top, L1);
+  api_incr_top(L);
+  preinit_state(L1, G(L));
+  L1->hookmask = L->hookmask;
+  L1->basehookcount = L->basehookcount;
+  L1->hook = L->hook;
+  resethookcount(L1);
+  luai_userstatethread(L, L1);
+  stack_init(L1, L);  /* init stack */
+  lua_unlock(L);
+  return L1;
+}
+
+
+void luaE_freethread (lua_State *L, lua_State *L1) {
+  LX *l = fromstate(L1);
+  luaF_close(L1, L1->stack);  /* close all upvalues for this thread */
+  lua_assert(L1->openupval == NULL);
+  luai_userstatefree(L, L1);
+  freestack(L1);
+  luaM_free(L, l);
+}
+
+
+LUA_API lua_State *lua_newstate (lua_Alloc f, void *ud) {
+  int i;
+  lua_State *L;
+  global_State *g;
+  LG *l = cast(LG *, (*f)(ud, NULL, LUA_TTHREAD, sizeof(LG)));
+  if (l == NULL) return NULL;
+  L = &l->l.l;
+  g = &l->g;
+  L->next = NULL;
+  L->tt = LUA_TTHREAD;
+  g->currentwhite = bit2mask(WHITE0BIT, FIXEDBIT);
+  L->marked = luaC_white(g);
+  g->gckind = KGC_NORMAL;
+  preinit_state(L, g);
+  g->frealloc = f;
+  g->ud = ud;
+  g->mainthread = L;
+  g->seed = makeseed(L);
+  g->uvhead.u.l.prev = &g->uvhead;
+  g->uvhead.u.l.next = &g->uvhead;
+  g->gcrunning = 0;  /* no GC while building state */
+  g->GCestimate = 0;
+  g->strt.size = 0;
+  g->strt.nuse = 0;
+  g->strt.hash = NULL;
+  setnilvalue(&g->l_registry);
+  luaZ_initbuffer(L, &g->buff);
+  g->panic = NULL;
+  g->version = lua_version(NULL);
+  g->gcstate = GCSpause;
+  g->allgc = NULL;
+  g->finobj = NULL;
+  g->tobefnz = NULL;
+  g->sweepgc = g->sweepfin = NULL;
+  g->gray = g->grayagain = NULL;
+  g->weak = g->ephemeron = g->allweak = NULL;
+  g->totalbytes = sizeof(LG);
+  g->GCdebt = 0;
+  g->gcpause = LUAI_GCPAUSE;
+  g->gcmajorinc = LUAI_GCMAJOR;
+  g->gcstepmul = LUAI_GCMUL;
+  for (i=0; i < LUA_NUMTAGS; i++) g->mt[i] = NULL;
+  if (luaD_rawrunprotected(L, f_luaopen, NULL) != LUA_OK) {
+    /* memory allocation error: free partial state */
+    close_state(L);
+    L = NULL;
+  }
+  else
+    luai_userstateopen(L);
+  return L;
+}
+
+
+LUA_API void lua_close (lua_State *L) {
+  L = G(L)->mainthread;  /* only the main thread can be closed */
+  lua_lock(L);
+  luai_userstateclose(L);
+  close_state(L);
+}
+
+
diff -ruNp src.orig/libs/lua/lstate.h src/libs/lua/lstate.h
--- src.orig/libs/lua/lstate.h	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lstate.h	2017-11-21 19:39:46 -0600
@@ -0,0 +1,228 @@
+/*
+** $Id: lstate.h,v 2.82 2012/07/02 13:37:04 roberto Exp $
+** Global State
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lstate_h
+#define lstate_h
+
+#include "lua.h"
+
+#include "lobject.h"
+#include "ltm.h"
+#include "lzio.h"
+
+
+/*
+
+** Some notes about garbage-collected objects:  All objects in Lua must
+** be kept somehow accessible until being freed.
+**
+** Lua keeps most objects linked in list g->allgc. The link uses field
+** 'next' of the CommonHeader.
+**
+** Strings are kept in several lists headed by the array g->strt.hash.
+**
+** Open upvalues are not subject to independent garbage collection. They
+** are collected together with their respective threads. Lua keeps a
+** double-linked list with all open upvalues (g->uvhead) so that it can
+** mark objects referred by them. (They are always gray, so they must
+** be remarked in the atomic step. Usually their contents would be marked
+** when traversing the respective threads, but the thread may already be
+** dead, while the upvalue is still accessible through closures.)
+**
+** Objects with finalizers are kept in the list g->finobj.
+**
+** The list g->tobefnz links all objects being finalized.
+
+*/
+
+
+struct lua_longjmp;  /* defined in ldo.c */
+
+
+
+/* extra stack space to handle TM calls and some other extras */
+#define EXTRA_STACK   5
+
+
+#define BASIC_STACK_SIZE        (2*LUA_MINSTACK)
+
+
+/* kinds of Garbage Collection */
+#define KGC_NORMAL	0
+#define KGC_EMERGENCY	1	/* gc was forced by an allocation failure */
+#define KGC_GEN		2	/* generational collection */
+
+
+typedef struct stringtable {
+  GCObject **hash;
+  lu_int32 nuse;  /* number of elements */
+  int size;
+} stringtable;
+
+
+/*
+** information about a call
+*/
+typedef struct CallInfo {
+  StkId func;  /* function index in the stack */
+  StkId	top;  /* top for this function */
+  struct CallInfo *previous, *next;  /* dynamic call link */
+  short nresults;  /* expected number of results from this function */
+  lu_byte callstatus;
+  ptrdiff_t extra;
+  union {
+    struct {  /* only for Lua functions */
+      StkId base;  /* base for this function */
+      const Instruction *savedpc;
+    } l;
+    struct {  /* only for C functions */
+      int ctx;  /* context info. in case of yields */
+      lua_CFunction k;  /* continuation in case of yields */
+      ptrdiff_t old_errfunc;
+      lu_byte old_allowhook;
+      lu_byte status;
+    } c;
+  } u;
+} CallInfo;
+
+
+/*
+** Bits in CallInfo status
+*/
+#define CIST_LUA	(1<<0)	/* call is running a Lua function */
+#define CIST_HOOKED	(1<<1)	/* call is running a debug hook */
+#define CIST_REENTRY	(1<<2)	/* call is running on same invocation of
+                                   luaV_execute of previous call */
+#define CIST_YIELDED	(1<<3)	/* call reentered after suspension */
+#define CIST_YPCALL	(1<<4)	/* call is a yieldable protected call */
+#define CIST_STAT	(1<<5)	/* call has an error status (pcall) */
+#define CIST_TAIL	(1<<6)	/* call was tail called */
+#define CIST_HOOKYIELD	(1<<7)	/* last hook called yielded */
+
+
+#define isLua(ci)	((ci)->callstatus & CIST_LUA)
+
+
+/*
+** `global state', shared by all threads of this state
+*/
+typedef struct global_State {
+  lua_Alloc frealloc;  /* function to reallocate memory */
+  void *ud;         /* auxiliary data to `frealloc' */
+  lu_mem totalbytes;  /* number of bytes currently allocated - GCdebt */
+  l_mem GCdebt;  /* bytes allocated not yet compensated by the collector */
+  lu_mem GCmemtrav;  /* memory traversed by the GC */
+  lu_mem GCestimate;  /* an estimate of the non-garbage memory in use */
+  stringtable strt;  /* hash table for strings */
+  TValue l_registry;
+  unsigned int seed;  /* randomized seed for hashes */
+  lu_byte currentwhite;
+  lu_byte gcstate;  /* state of garbage collector */
+  lu_byte gckind;  /* kind of GC running */
+  lu_byte gcrunning;  /* true if GC is running */
+  int sweepstrgc;  /* position of sweep in `strt' */
+  GCObject *allgc;  /* list of all collectable objects */
+  GCObject *finobj;  /* list of collectable objects with finalizers */
+  GCObject **sweepgc;  /* current position of sweep in list 'allgc' */
+  GCObject **sweepfin;  /* current position of sweep in list 'finobj' */
+  GCObject *gray;  /* list of gray objects */
+  GCObject *grayagain;  /* list of objects to be traversed atomically */
+  GCObject *weak;  /* list of tables with weak values */
+  GCObject *ephemeron;  /* list of ephemeron tables (weak keys) */
+  GCObject *allweak;  /* list of all-weak tables */
+  GCObject *tobefnz;  /* list of userdata to be GC */
+  UpVal uvhead;  /* head of double-linked list of all open upvalues */
+  Mbuffer buff;  /* temporary buffer for string concatenation */
+  int gcpause;  /* size of pause between successive GCs */
+  int gcmajorinc;  /* pause between major collections (only in gen. mode) */
+  int gcstepmul;  /* GC `granularity' */
+  lua_CFunction panic;  /* to be called in unprotected errors */
+  struct lua_State *mainthread;
+  const lua_Number *version;  /* pointer to version number */
+  TString *memerrmsg;  /* memory-error message */
+  TString *tmname[TM_N];  /* array with tag-method names */
+  struct Table *mt[LUA_NUMTAGS];  /* metatables for basic types */
+} global_State;
+
+
+/*
+** `per thread' state
+*/
+struct lua_State {
+  CommonHeader;
+  lu_byte status;
+  StkId top;  /* first free slot in the stack */
+  global_State *l_G;
+  CallInfo *ci;  /* call info for current function */
+  const Instruction *oldpc;  /* last pc traced */
+  StkId stack_last;  /* last free slot in the stack */
+  StkId stack;  /* stack base */
+  int stacksize;
+  unsigned short nny;  /* number of non-yieldable calls in stack */
+  unsigned short nCcalls;  /* number of nested C calls */
+  lu_byte hookmask;
+  lu_byte allowhook;
+  int basehookcount;
+  int hookcount;
+  lua_Hook hook;
+  GCObject *openupval;  /* list of open upvalues in this stack */
+  GCObject *gclist;
+  struct lua_longjmp *errorJmp;  /* current error recover point */
+  ptrdiff_t errfunc;  /* current error handling function (stack index) */
+  CallInfo base_ci;  /* CallInfo for first level (C calling Lua) */
+};
+
+
+#define G(L)	(L->l_G)
+
+
+/*
+** Union of all collectable objects
+*/
+union GCObject {
+  GCheader gch;  /* common header */
+  union TString ts;
+  union Udata u;
+  union Closure cl;
+  struct Table h;
+  struct Proto p;
+  struct UpVal uv;
+  struct lua_State th;  /* thread */
+};
+
+
+#define gch(o)		(&(o)->gch)
+
+/* macros to convert a GCObject into a specific value */
+#define rawgco2ts(o)  \
+	check_exp(novariant((o)->gch.tt) == LUA_TSTRING, &((o)->ts))
+#define gco2ts(o)	(&rawgco2ts(o)->tsv)
+#define rawgco2u(o)	check_exp((o)->gch.tt == LUA_TUSERDATA, &((o)->u))
+#define gco2u(o)	(&rawgco2u(o)->uv)
+#define gco2lcl(o)	check_exp((o)->gch.tt == LUA_TLCL, &((o)->cl.l))
+#define gco2ccl(o)	check_exp((o)->gch.tt == LUA_TCCL, &((o)->cl.c))
+#define gco2cl(o)  \
+	check_exp(novariant((o)->gch.tt) == LUA_TFUNCTION, &((o)->cl))
+#define gco2t(o)	check_exp((o)->gch.tt == LUA_TTABLE, &((o)->h))
+#define gco2p(o)	check_exp((o)->gch.tt == LUA_TPROTO, &((o)->p))
+#define gco2uv(o)	check_exp((o)->gch.tt == LUA_TUPVAL, &((o)->uv))
+#define gco2th(o)	check_exp((o)->gch.tt == LUA_TTHREAD, &((o)->th))
+
+/* macro to convert any Lua object into a GCObject */
+#define obj2gco(v)	(cast(GCObject *, (v)))
+
+
+/* actual number of total bytes allocated */
+#define gettotalbytes(g)	((g)->totalbytes + (g)->GCdebt)
+
+LUAI_FUNC void luaE_setdebt (global_State *g, l_mem debt);
+LUAI_FUNC void luaE_freethread (lua_State *L, lua_State *L1);
+LUAI_FUNC CallInfo *luaE_extendCI (lua_State *L);
+LUAI_FUNC void luaE_freeCI (lua_State *L);
+
+
+#endif
+
diff -ruNp src.orig/libs/lua/lstring.c src/libs/lua/lstring.c
--- src.orig/libs/lua/lstring.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lstring.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,185 @@
+/*
+** $Id: lstring.c,v 2.26 2013/01/08 13:50:10 roberto Exp $
+** String table (keeps all strings handled by Lua)
+** See Copyright Notice in lua.h
+*/
+
+
+#include <string.h>
+
+#define lstring_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+
+
+/*
+** Lua will use at most ~(2^LUAI_HASHLIMIT) bytes from a string to
+** compute its hash
+*/
+#if !defined(LUAI_HASHLIMIT)
+#define LUAI_HASHLIMIT		5
+#endif
+
+
+/*
+** equality for long strings
+*/
+int luaS_eqlngstr (TString *a, TString *b) {
+  size_t len = a->tsv.len;
+  lua_assert(a->tsv.tt == LUA_TLNGSTR && b->tsv.tt == LUA_TLNGSTR);
+  return (a == b) ||  /* same instance or... */
+    ((len == b->tsv.len) &&  /* equal length and ... */
+     (memcmp(getstr(a), getstr(b), len) == 0));  /* equal contents */
+}
+
+
+/*
+** equality for strings
+*/
+int luaS_eqstr (TString *a, TString *b) {
+  return (a->tsv.tt == b->tsv.tt) &&
+         (a->tsv.tt == LUA_TSHRSTR ? eqshrstr(a, b) : luaS_eqlngstr(a, b));
+}
+
+
+unsigned int luaS_hash (const char *str, size_t l, unsigned int seed) {
+  unsigned int h = seed ^ cast(unsigned int, l);
+  size_t l1;
+  size_t step = (l >> LUAI_HASHLIMIT) + 1;
+  for (l1 = l; l1 >= step; l1 -= step)
+    h = h ^ ((h<<5) + (h>>2) + cast_byte(str[l1 - 1]));
+  return h;
+}
+
+
+/*
+** resizes the string table
+*/
+void luaS_resize (lua_State *L, int newsize) {
+  int i;
+  stringtable *tb = &G(L)->strt;
+  /* cannot resize while GC is traversing strings */
+  luaC_runtilstate(L, ~bitmask(GCSsweepstring));
+  if (newsize > tb->size) {
+    luaM_reallocvector(L, tb->hash, tb->size, newsize, GCObject *);
+    for (i = tb->size; i < newsize; i++) tb->hash[i] = NULL;
+  }
+  /* rehash */
+  for (i=0; i<tb->size; i++) {
+    GCObject *p = tb->hash[i];
+    tb->hash[i] = NULL;
+    while (p) {  /* for each node in the list */
+      GCObject *next = gch(p)->next;  /* save next */
+      unsigned int h = lmod(gco2ts(p)->hash, newsize);  /* new position */
+      gch(p)->next = tb->hash[h];  /* chain it */
+      tb->hash[h] = p;
+      resetoldbit(p);  /* see MOVE OLD rule */
+      p = next;
+    }
+  }
+  if (newsize < tb->size) {
+    /* shrinking slice must be empty */
+    lua_assert(tb->hash[newsize] == NULL && tb->hash[tb->size - 1] == NULL);
+    luaM_reallocvector(L, tb->hash, tb->size, newsize, GCObject *);
+  }
+  tb->size = newsize;
+}
+
+
+/*
+** creates a new string object
+*/
+static TString *createstrobj (lua_State *L, const char *str, size_t l,
+                              int tag, unsigned int h, GCObject **list) {
+  TString *ts;
+  size_t totalsize;  /* total size of TString object */
+  totalsize = sizeof(TString) + ((l + 1) * sizeof(char));
+  ts = &luaC_newobj(L, tag, totalsize, list, 0)->ts;
+  ts->tsv.len = l;
+  ts->tsv.hash = h;
+  ts->tsv.extra = 0;
+  memcpy(ts+1, str, l*sizeof(char));
+  ((char *)(ts+1))[l] = '\0';  /* ending 0 */
+  return ts;
+}
+
+
+/*
+** creates a new short string, inserting it into string table
+*/
+static TString *newshrstr (lua_State *L, const char *str, size_t l,
+                                       unsigned int h) {
+  GCObject **list;  /* (pointer to) list where it will be inserted */
+  stringtable *tb = &G(L)->strt;
+  TString *s;
+  if (tb->nuse >= cast(lu_int32, tb->size) && tb->size <= MAX_INT/2)
+    luaS_resize(L, tb->size*2);  /* too crowded */
+  list = &tb->hash[lmod(h, tb->size)];
+  s = createstrobj(L, str, l, LUA_TSHRSTR, h, list);
+  tb->nuse++;
+  return s;
+}
+
+
+/*
+** checks whether short string exists and reuses it or creates a new one
+*/
+static TString *internshrstr (lua_State *L, const char *str, size_t l) {
+  GCObject *o;
+  global_State *g = G(L);
+  unsigned int h = luaS_hash(str, l, g->seed);
+  for (o = g->strt.hash[lmod(h, g->strt.size)];
+       o != NULL;
+       o = gch(o)->next) {
+    TString *ts = rawgco2ts(o);
+    if (h == ts->tsv.hash &&
+        l == ts->tsv.len &&
+        (memcmp(str, getstr(ts), l * sizeof(char)) == 0)) {
+      if (isdead(G(L), o))  /* string is dead (but was not collected yet)? */
+        changewhite(o);  /* resurrect it */
+      return ts;
+    }
+  }
+  return newshrstr(L, str, l, h);  /* not found; create a new string */
+}
+
+
+/*
+** new string (with explicit length)
+*/
+TString *luaS_newlstr (lua_State *L, const char *str, size_t l) {
+  if (l <= LUAI_MAXSHORTLEN)  /* short string? */
+    return internshrstr(L, str, l);
+  else {
+    if (l + 1 > (MAX_SIZET - sizeof(TString))/sizeof(char))
+      luaM_toobig(L);
+    return createstrobj(L, str, l, LUA_TLNGSTR, G(L)->seed, NULL);
+  }
+}
+
+
+/*
+** new zero-terminated string
+*/
+TString *luaS_new (lua_State *L, const char *str) {
+  return luaS_newlstr(L, str, strlen(str));
+}
+
+
+Udata *luaS_newudata (lua_State *L, size_t s, Table *e) {
+  Udata *u;
+  if (s > MAX_SIZET - sizeof(Udata))
+    luaM_toobig(L);
+  u = &luaC_newobj(L, LUA_TUSERDATA, sizeof(Udata) + s, NULL, 0)->u;
+  u->uv.len = s;
+  u->uv.metatable = NULL;
+  u->uv.env = e;
+  return u;
+}
+
diff -ruNp src.orig/libs/lua/lstring.h src/libs/lua/lstring.h
--- src.orig/libs/lua/lstring.h	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lstring.h	2017-11-21 19:39:46 -0600
@@ -0,0 +1,46 @@
+/*
+** $Id: lstring.h,v 1.49 2012/02/01 21:57:15 roberto Exp $
+** String table (keep all strings handled by Lua)
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lstring_h
+#define lstring_h
+
+#include "lgc.h"
+#include "lobject.h"
+#include "lstate.h"
+
+
+#define sizestring(s)	(sizeof(union TString)+((s)->len+1)*sizeof(char))
+
+#define sizeudata(u)	(sizeof(union Udata)+(u)->len)
+
+#define luaS_newliteral(L, s)	(luaS_newlstr(L, "" s, \
+                                 (sizeof(s)/sizeof(char))-1))
+
+#define luaS_fix(s)	l_setbit((s)->tsv.marked, FIXEDBIT)
+
+
+/*
+** test whether a string is a reserved word
+*/
+#define isreserved(s)	((s)->tsv.tt == LUA_TSHRSTR && (s)->tsv.extra > 0)
+
+
+/*
+** equality for short strings, which are always internalized
+*/
+#define eqshrstr(a,b)	check_exp((a)->tsv.tt == LUA_TSHRSTR, (a) == (b))
+
+
+LUAI_FUNC unsigned int luaS_hash (const char *str, size_t l, unsigned int seed);
+LUAI_FUNC int luaS_eqlngstr (TString *a, TString *b);
+LUAI_FUNC int luaS_eqstr (TString *a, TString *b);
+LUAI_FUNC void luaS_resize (lua_State *L, int newsize);
+LUAI_FUNC Udata *luaS_newudata (lua_State *L, size_t s, Table *e);
+LUAI_FUNC TString *luaS_newlstr (lua_State *L, const char *str, size_t l);
+LUAI_FUNC TString *luaS_new (lua_State *L, const char *str);
+
+
+#endif
diff -ruNp src.orig/libs/lua/lstrlib.c src/libs/lua/lstrlib.c
--- src.orig/libs/lua/lstrlib.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lstrlib.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,1019 @@
+/*
+** $Id: lstrlib.c,v 1.178 2012/08/14 18:12:34 roberto Exp $
+** Standard library for string operations and pattern-matching
+** See Copyright Notice in lua.h
+*/
+
+
+#include <ctype.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define lstrlib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+/*
+** maximum number of captures that a pattern can do during
+** pattern-matching. This limit is arbitrary.
+*/
+#if !defined(LUA_MAXCAPTURES)
+#define LUA_MAXCAPTURES		32
+#endif
+
+
+/* macro to `unsign' a character */
+#define uchar(c)	((unsigned char)(c))
+
+
+
+static int str_len (lua_State *L) {
+  size_t l;
+  luaL_checklstring(L, 1, &l);
+  lua_pushinteger(L, (lua_Integer)l);
+  return 1;
+}
+
+
+/* translate a relative string position: negative means back from end */
+static size_t posrelat (ptrdiff_t pos, size_t len) {
+  if (pos >= 0) return (size_t)pos;
+  else if (0u - (size_t)pos > len) return 0;
+  else return len - ((size_t)-pos) + 1;
+}
+
+
+static int str_sub (lua_State *L) {
+  size_t l;
+  const char *s = luaL_checklstring(L, 1, &l);
+  size_t start = posrelat(luaL_checkinteger(L, 2), l);
+  size_t end = posrelat(luaL_optinteger(L, 3, -1), l);
+  if (start < 1) start = 1;
+  if (end > l) end = l;
+  if (start <= end)
+    lua_pushlstring(L, s + start - 1, end - start + 1);
+  else lua_pushliteral(L, "");
+  return 1;
+}
+
+
+static int str_reverse (lua_State *L) {
+  size_t l, i;
+  luaL_Buffer b;
+  const char *s = luaL_checklstring(L, 1, &l);
+  char *p = luaL_buffinitsize(L, &b, l);
+  for (i = 0; i < l; i++)
+    p[i] = s[l - i - 1];
+  luaL_pushresultsize(&b, l);
+  return 1;
+}
+
+
+static int str_lower (lua_State *L) {
+  size_t l;
+  size_t i;
+  luaL_Buffer b;
+  const char *s = luaL_checklstring(L, 1, &l);
+  char *p = luaL_buffinitsize(L, &b, l);
+  for (i=0; i<l; i++)
+    p[i] = tolower(uchar(s[i]));
+  luaL_pushresultsize(&b, l);
+  return 1;
+}
+
+
+static int str_upper (lua_State *L) {
+  size_t l;
+  size_t i;
+  luaL_Buffer b;
+  const char *s = luaL_checklstring(L, 1, &l);
+  char *p = luaL_buffinitsize(L, &b, l);
+  for (i=0; i<l; i++)
+    p[i] = toupper(uchar(s[i]));
+  luaL_pushresultsize(&b, l);
+  return 1;
+}
+
+
+/* reasonable limit to avoid arithmetic overflow */
+#define MAXSIZE		((~(size_t)0) >> 1)
+
+static int str_rep (lua_State *L) {
+  size_t l, lsep;
+  const char *s = luaL_checklstring(L, 1, &l);
+  int n = luaL_checkint(L, 2);
+  const char *sep = luaL_optlstring(L, 3, "", &lsep);
+  if (n <= 0) lua_pushliteral(L, "");
+  else if (l + lsep < l || l + lsep >= MAXSIZE / n)  /* may overflow? */
+    return luaL_error(L, "resulting string too large");
+  else {
+    size_t totallen = n * l + (n - 1) * lsep;
+    luaL_Buffer b;
+    char *p = luaL_buffinitsize(L, &b, totallen);
+    while (n-- > 1) {  /* first n-1 copies (followed by separator) */
+      memcpy(p, s, l * sizeof(char)); p += l;
+      if (lsep > 0) {  /* avoid empty 'memcpy' (may be expensive) */
+        memcpy(p, sep, lsep * sizeof(char)); p += lsep;
+      }
+    }
+    memcpy(p, s, l * sizeof(char));  /* last copy (not followed by separator) */
+    luaL_pushresultsize(&b, totallen);
+  }
+  return 1;
+}
+
+
+static int str_byte (lua_State *L) {
+  size_t l;
+  const char *s = luaL_checklstring(L, 1, &l);
+  size_t posi = posrelat(luaL_optinteger(L, 2, 1), l);
+  size_t pose = posrelat(luaL_optinteger(L, 3, posi), l);
+  int n, i;
+  if (posi < 1) posi = 1;
+  if (pose > l) pose = l;
+  if (posi > pose) return 0;  /* empty interval; return no values */
+  n = (int)(pose -  posi + 1);
+  if (posi + n <= pose)  /* (size_t -> int) overflow? */
+    return luaL_error(L, "string slice too long");
+  luaL_checkstack(L, n, "string slice too long");
+  for (i=0; i<n; i++)
+    lua_pushinteger(L, uchar(s[posi+i-1]));
+  return n;
+}
+
+
+static int str_char (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  int i;
+  luaL_Buffer b;
+  char *p = luaL_buffinitsize(L, &b, n);
+  for (i=1; i<=n; i++) {
+    int c = luaL_checkint(L, i);
+    luaL_argcheck(L, uchar(c) == c, i, "value out of range");
+    p[i - 1] = uchar(c);
+  }
+  luaL_pushresultsize(&b, n);
+  return 1;
+}
+
+
+static int writer (lua_State *L, const void* b, size_t size, void* B) {
+  (void)L;
+  luaL_addlstring((luaL_Buffer*) B, (const char *)b, size);
+  return 0;
+}
+
+
+static int str_dump (lua_State *L) {
+  luaL_Buffer b;
+  luaL_checktype(L, 1, LUA_TFUNCTION);
+  lua_settop(L, 1);
+  luaL_buffinit(L,&b);
+  if (lua_dump(L, writer, &b) != 0)
+    return luaL_error(L, "unable to dump given function");
+  luaL_pushresult(&b);
+  return 1;
+}
+
+
+
+/*
+** {======================================================
+** PATTERN MATCHING
+** =======================================================
+*/
+
+
+#define CAP_UNFINISHED	(-1)
+#define CAP_POSITION	(-2)
+
+
+typedef struct MatchState {
+  int matchdepth;  /* control for recursive depth (to avoid C stack overflow) */
+  const char *src_init;  /* init of source string */
+  const char *src_end;  /* end ('\0') of source string */
+  const char *p_end;  /* end ('\0') of pattern */
+  lua_State *L;
+  int level;  /* total number of captures (finished or unfinished) */
+  struct {
+    const char *init;
+    ptrdiff_t len;
+  } capture[LUA_MAXCAPTURES];
+} MatchState;
+
+
+/* recursive function */
+static const char *match (MatchState *ms, const char *s, const char *p);
+
+
+/* maximum recursion depth for 'match' */
+#if !defined(MAXCCALLS)
+#define MAXCCALLS	200
+#endif
+
+
+#define L_ESC		'%'
+#define SPECIALS	"^$*+?.([%-"
+
+
+static int check_capture (MatchState *ms, int l) {
+  l -= '1';
+  if (l < 0 || l >= ms->level || ms->capture[l].len == CAP_UNFINISHED)
+    return luaL_error(ms->L, "invalid capture index %%%d", l + 1);
+  return l;
+}
+
+
+static int capture_to_close (MatchState *ms) {
+  int level = ms->level;
+  for (level--; level>=0; level--)
+    if (ms->capture[level].len == CAP_UNFINISHED) return level;
+  return luaL_error(ms->L, "invalid pattern capture");
+}
+
+
+static const char *classend (MatchState *ms, const char *p) {
+  switch (*p++) {
+    case L_ESC: {
+      if (p == ms->p_end)
+        luaL_error(ms->L, "malformed pattern (ends with " LUA_QL("%%") ")");
+      return p+1;
+    }
+    case '[': {
+      if (*p == '^') p++;
+      do {  /* look for a `]' */
+        if (p == ms->p_end)
+          luaL_error(ms->L, "malformed pattern (missing " LUA_QL("]") ")");
+        if (*(p++) == L_ESC && p < ms->p_end)
+          p++;  /* skip escapes (e.g. `%]') */
+      } while (*p != ']');
+      return p+1;
+    }
+    default: {
+      return p;
+    }
+  }
+}
+
+
+static int match_class (int c, int cl) {
+  int res;
+  switch (tolower(cl)) {
+    case 'a' : res = isalpha(c); break;
+    case 'c' : res = iscntrl(c); break;
+    case 'd' : res = isdigit(c); break;
+    case 'g' : res = isgraph(c); break;
+    case 'l' : res = islower(c); break;
+    case 'p' : res = ispunct(c); break;
+    case 's' : res = isspace(c); break;
+    case 'u' : res = isupper(c); break;
+    case 'w' : res = isalnum(c); break;
+    case 'x' : res = isxdigit(c); break;
+    case 'z' : res = (c == 0); break;  /* deprecated option */
+    default: return (cl == c);
+  }
+  return (islower(cl) ? res : !res);
+}
+
+
+static int matchbracketclass (int c, const char *p, const char *ec) {
+  int sig = 1;
+  if (*(p+1) == '^') {
+    sig = 0;
+    p++;  /* skip the `^' */
+  }
+  while (++p < ec) {
+    if (*p == L_ESC) {
+      p++;
+      if (match_class(c, uchar(*p)))
+        return sig;
+    }
+    else if ((*(p+1) == '-') && (p+2 < ec)) {
+      p+=2;
+      if (uchar(*(p-2)) <= c && c <= uchar(*p))
+        return sig;
+    }
+    else if (uchar(*p) == c) return sig;
+  }
+  return !sig;
+}
+
+
+static int singlematch (MatchState *ms, const char *s, const char *p,
+                        const char *ep) {
+  if (s >= ms->src_end)
+    return 0;
+  else {
+    int c = uchar(*s);
+    switch (*p) {
+      case '.': return 1;  /* matches any char */
+      case L_ESC: return match_class(c, uchar(*(p+1)));
+      case '[': return matchbracketclass(c, p, ep-1);
+      default:  return (uchar(*p) == c);
+    }
+  }
+}
+
+
+static const char *matchbalance (MatchState *ms, const char *s,
+                                   const char *p) {
+  if (p >= ms->p_end - 1)
+    luaL_error(ms->L, "malformed pattern "
+                      "(missing arguments to " LUA_QL("%%b") ")");
+  if (*s != *p) return NULL;
+  else {
+    int b = *p;
+    int e = *(p+1);
+    int cont = 1;
+    while (++s < ms->src_end) {
+      if (*s == e) {
+        if (--cont == 0) return s+1;
+      }
+      else if (*s == b) cont++;
+    }
+  }
+  return NULL;  /* string ends out of balance */
+}
+
+
+static const char *max_expand (MatchState *ms, const char *s,
+                                 const char *p, const char *ep) {
+  ptrdiff_t i = 0;  /* counts maximum expand for item */
+  while (singlematch(ms, s + i, p, ep))
+    i++;
+  /* keeps trying to match with the maximum repetitions */
+  while (i>=0) {
+    const char *res = match(ms, (s+i), ep+1);
+    if (res) return res;
+    i--;  /* else didn't match; reduce 1 repetition to try again */
+  }
+  return NULL;
+}
+
+
+static const char *min_expand (MatchState *ms, const char *s,
+                                 const char *p, const char *ep) {
+  for (;;) {
+    const char *res = match(ms, s, ep+1);
+    if (res != NULL)
+      return res;
+    else if (singlematch(ms, s, p, ep))
+      s++;  /* try with one more repetition */
+    else return NULL;
+  }
+}
+
+
+static const char *start_capture (MatchState *ms, const char *s,
+                                    const char *p, int what) {
+  const char *res;
+  int level = ms->level;
+  if (level >= LUA_MAXCAPTURES) luaL_error(ms->L, "too many captures");
+  ms->capture[level].init = s;
+  ms->capture[level].len = what;
+  ms->level = level+1;
+  if ((res=match(ms, s, p)) == NULL)  /* match failed? */
+    ms->level--;  /* undo capture */
+  return res;
+}
+
+
+static const char *end_capture (MatchState *ms, const char *s,
+                                  const char *p) {
+  int l = capture_to_close(ms);
+  const char *res;
+  ms->capture[l].len = s - ms->capture[l].init;  /* close capture */
+  if ((res = match(ms, s, p)) == NULL)  /* match failed? */
+    ms->capture[l].len = CAP_UNFINISHED;  /* undo capture */
+  return res;
+}
+
+
+static const char *match_capture (MatchState *ms, const char *s, int l) {
+  size_t len;
+  l = check_capture(ms, l);
+  len = ms->capture[l].len;
+  if ((size_t)(ms->src_end-s) >= len &&
+      memcmp(ms->capture[l].init, s, len) == 0)
+    return s+len;
+  else return NULL;
+}
+
+
+static const char *match (MatchState *ms, const char *s, const char *p) {
+  if (ms->matchdepth-- == 0)
+    luaL_error(ms->L, "pattern too complex");
+  init: /* using goto's to optimize tail recursion */
+  if (p != ms->p_end) {  /* end of pattern? */
+    switch (*p) {
+      case '(': {  /* start capture */
+        if (*(p + 1) == ')')  /* position capture? */
+          s = start_capture(ms, s, p + 2, CAP_POSITION);
+        else
+          s = start_capture(ms, s, p + 1, CAP_UNFINISHED);
+        break;
+      }
+      case ')': {  /* end capture */
+        s = end_capture(ms, s, p + 1);
+        break;
+      }
+      case '$': {
+        if ((p + 1) != ms->p_end)  /* is the `$' the last char in pattern? */
+          goto dflt;  /* no; go to default */
+        s = (s == ms->src_end) ? s : NULL;  /* check end of string */
+        break;
+      }
+      case L_ESC: {  /* escaped sequences not in the format class[*+?-]? */
+        switch (*(p + 1)) {
+          case 'b': {  /* balanced string? */
+            s = matchbalance(ms, s, p + 2);
+            if (s != NULL) {
+              p += 4; goto init;  /* return match(ms, s, p + 4); */
+            }  /* else fail (s == NULL) */
+            break;
+          }
+          case 'f': {  /* frontier? */
+            const char *ep; char previous;
+            p += 2;
+            if (*p != '[')
+              luaL_error(ms->L, "missing " LUA_QL("[") " after "
+                                 LUA_QL("%%f") " in pattern");
+            ep = classend(ms, p);  /* points to what is next */
+            previous = (s == ms->src_init) ? '\0' : *(s - 1);
+            if (!matchbracketclass(uchar(previous), p, ep - 1) &&
+               matchbracketclass(uchar(*s), p, ep - 1)) {
+              p = ep; goto init;  /* return match(ms, s, ep); */
+            }
+            s = NULL;  /* match failed */
+            break;
+          }
+          case '0': case '1': case '2': case '3':
+          case '4': case '5': case '6': case '7':
+          case '8': case '9': {  /* capture results (%0-%9)? */
+            s = match_capture(ms, s, uchar(*(p + 1)));
+            if (s != NULL) {
+              p += 2; goto init;  /* return match(ms, s, p + 2) */
+            }
+            break;
+          }
+          default: goto dflt;
+        }
+        break;
+      }
+      default: dflt: {  /* pattern class plus optional suffix */
+        const char *ep = classend(ms, p);  /* points to optional suffix */
+        /* does not match at least once? */
+        if (!singlematch(ms, s, p, ep)) {
+          if (*ep == '*' || *ep == '?' || *ep == '-') {  /* accept empty? */
+            p = ep + 1; goto init;  /* return match(ms, s, ep + 1); */
+          }
+          else  /* '+' or no suffix */
+            s = NULL;  /* fail */
+        }
+        else {  /* matched once */
+          switch (*ep) {  /* handle optional suffix */
+            case '?': {  /* optional */
+              const char *res;
+              if ((res = match(ms, s + 1, ep + 1)) != NULL)
+                s = res;
+              else {
+                p = ep + 1; goto init;  /* else return match(ms, s, ep + 1); */
+              }
+              break;
+            }
+            case '+':  /* 1 or more repetitions */
+              s++;  /* 1 match already done */
+              /* go through */
+            case '*':  /* 0 or more repetitions */
+              s = max_expand(ms, s, p, ep);
+              break;
+            case '-':  /* 0 or more repetitions (minimum) */
+              s = min_expand(ms, s, p, ep);
+              break;
+            default:  /* no suffix */
+              s++; p = ep; goto init;  /* return match(ms, s + 1, ep); */
+          }
+        }
+        break;
+      }
+    }
+  }
+  ms->matchdepth++;
+  return s;
+}
+
+
+
+static const char *lmemfind (const char *s1, size_t l1,
+                               const char *s2, size_t l2) {
+  if (l2 == 0) return s1;  /* empty strings are everywhere */
+  else if (l2 > l1) return NULL;  /* avoids a negative `l1' */
+  else {
+    const char *init;  /* to search for a `*s2' inside `s1' */
+    l2--;  /* 1st char will be checked by `memchr' */
+    l1 = l1-l2;  /* `s2' cannot be found after that */
+    while (l1 > 0 && (init = (const char *)memchr(s1, *s2, l1)) != NULL) {
+      init++;   /* 1st char is already checked */
+      if (memcmp(init, s2+1, l2) == 0)
+        return init-1;
+      else {  /* correct `l1' and `s1' to try again */
+        l1 -= init-s1;
+        s1 = init;
+      }
+    }
+    return NULL;  /* not found */
+  }
+}
+
+
+static void push_onecapture (MatchState *ms, int i, const char *s,
+                                                    const char *e) {
+  if (i >= ms->level) {
+    if (i == 0)  /* ms->level == 0, too */
+      lua_pushlstring(ms->L, s, e - s);  /* add whole match */
+    else
+      luaL_error(ms->L, "invalid capture index");
+  }
+  else {
+    ptrdiff_t l = ms->capture[i].len;
+    if (l == CAP_UNFINISHED) luaL_error(ms->L, "unfinished capture");
+    if (l == CAP_POSITION)
+      lua_pushinteger(ms->L, ms->capture[i].init - ms->src_init + 1);
+    else
+      lua_pushlstring(ms->L, ms->capture[i].init, l);
+  }
+}
+
+
+static int push_captures (MatchState *ms, const char *s, const char *e) {
+  int i;
+  int nlevels = (ms->level == 0 && s) ? 1 : ms->level;
+  luaL_checkstack(ms->L, nlevels, "too many captures");
+  for (i = 0; i < nlevels; i++)
+    push_onecapture(ms, i, s, e);
+  return nlevels;  /* number of strings pushed */
+}
+
+
+/* check whether pattern has no special characters */
+static int nospecials (const char *p, size_t l) {
+  size_t upto = 0;
+  do {
+    if (strpbrk(p + upto, SPECIALS))
+      return 0;  /* pattern has a special character */
+    upto += strlen(p + upto) + 1;  /* may have more after \0 */
+  } while (upto <= l);
+  return 1;  /* no special chars found */
+}
+
+
+static int str_find_aux (lua_State *L, int find) {
+  size_t ls, lp;
+  const char *s = luaL_checklstring(L, 1, &ls);
+  const char *p = luaL_checklstring(L, 2, &lp);
+  size_t init = posrelat(luaL_optinteger(L, 3, 1), ls);
+  if (init < 1) init = 1;
+  else if (init > ls + 1) {  /* start after string's end? */
+    lua_pushnil(L);  /* cannot find anything */
+    return 1;
+  }
+  /* explicit request or no special characters? */
+  if (find && (lua_toboolean(L, 4) || nospecials(p, lp))) {
+    /* do a plain search */
+    const char *s2 = lmemfind(s + init - 1, ls - init + 1, p, lp);
+    if (s2) {
+      lua_pushinteger(L, s2 - s + 1);
+      lua_pushinteger(L, s2 - s + lp);
+      return 2;
+    }
+  }
+  else {
+    MatchState ms;
+    const char *s1 = s + init - 1;
+    int anchor = (*p == '^');
+    if (anchor) {
+      p++; lp--;  /* skip anchor character */
+    }
+    ms.L = L;
+    ms.matchdepth = MAXCCALLS;
+    ms.src_init = s;
+    ms.src_end = s + ls;
+    ms.p_end = p + lp;
+    do {
+      const char *res;
+      ms.level = 0;
+      lua_assert(ms.matchdepth == MAXCCALLS);
+      if ((res=match(&ms, s1, p)) != NULL) {
+        if (find) {
+          lua_pushinteger(L, s1 - s + 1);  /* start */
+          lua_pushinteger(L, res - s);   /* end */
+          return push_captures(&ms, NULL, 0) + 2;
+        }
+        else
+          return push_captures(&ms, s1, res);
+      }
+    } while (s1++ < ms.src_end && !anchor);
+  }
+  lua_pushnil(L);  /* not found */
+  return 1;
+}
+
+
+static int str_find (lua_State *L) {
+  return str_find_aux(L, 1);
+}
+
+
+static int str_match (lua_State *L) {
+  return str_find_aux(L, 0);
+}
+
+
+static int gmatch_aux (lua_State *L) {
+  MatchState ms;
+  size_t ls, lp;
+  const char *s = lua_tolstring(L, lua_upvalueindex(1), &ls);
+  const char *p = lua_tolstring(L, lua_upvalueindex(2), &lp);
+  const char *src;
+  ms.L = L;
+  ms.matchdepth = MAXCCALLS;
+  ms.src_init = s;
+  ms.src_end = s+ls;
+  ms.p_end = p + lp;
+  for (src = s + (size_t)lua_tointeger(L, lua_upvalueindex(3));
+       src <= ms.src_end;
+       src++) {
+    const char *e;
+    ms.level = 0;
+    lua_assert(ms.matchdepth == MAXCCALLS);
+    if ((e = match(&ms, src, p)) != NULL) {
+      lua_Integer newstart = e-s;
+      if (e == src) newstart++;  /* empty match? go at least one position */
+      lua_pushinteger(L, newstart);
+      lua_replace(L, lua_upvalueindex(3));
+      return push_captures(&ms, src, e);
+    }
+  }
+  return 0;  /* not found */
+}
+
+
+static int gmatch (lua_State *L) {
+  luaL_checkstring(L, 1);
+  luaL_checkstring(L, 2);
+  lua_settop(L, 2);
+  lua_pushinteger(L, 0);
+  lua_pushcclosure(L, gmatch_aux, 3);
+  return 1;
+}
+
+
+static void add_s (MatchState *ms, luaL_Buffer *b, const char *s,
+                                                   const char *e) {
+  size_t l, i;
+  const char *news = lua_tolstring(ms->L, 3, &l);
+  for (i = 0; i < l; i++) {
+    if (news[i] != L_ESC)
+      luaL_addchar(b, news[i]);
+    else {
+      i++;  /* skip ESC */
+      if (!isdigit(uchar(news[i]))) {
+        if (news[i] != L_ESC)
+          luaL_error(ms->L, "invalid use of " LUA_QL("%c")
+                           " in replacement string", L_ESC);
+        luaL_addchar(b, news[i]);
+      }
+      else if (news[i] == '0')
+          luaL_addlstring(b, s, e - s);
+      else {
+        push_onecapture(ms, news[i] - '1', s, e);
+        luaL_addvalue(b);  /* add capture to accumulated result */
+      }
+    }
+  }
+}
+
+
+static void add_value (MatchState *ms, luaL_Buffer *b, const char *s,
+                                       const char *e, int tr) {
+  lua_State *L = ms->L;
+  switch (tr) {
+    case LUA_TFUNCTION: {
+      int n;
+      lua_pushvalue(L, 3);
+      n = push_captures(ms, s, e);
+      lua_call(L, n, 1);
+      break;
+    }
+    case LUA_TTABLE: {
+      push_onecapture(ms, 0, s, e);
+      lua_gettable(L, 3);
+      break;
+    }
+    default: {  /* LUA_TNUMBER or LUA_TSTRING */
+      add_s(ms, b, s, e);
+      return;
+    }
+  }
+  if (!lua_toboolean(L, -1)) {  /* nil or false? */
+    lua_pop(L, 1);
+    lua_pushlstring(L, s, e - s);  /* keep original text */
+  }
+  else if (!lua_isstring(L, -1))
+    luaL_error(L, "invalid replacement value (a %s)", luaL_typename(L, -1));
+  luaL_addvalue(b);  /* add result to accumulator */
+}
+
+
+static int str_gsub (lua_State *L) {
+  size_t srcl, lp;
+  const char *src = luaL_checklstring(L, 1, &srcl);
+  const char *p = luaL_checklstring(L, 2, &lp);
+  int tr = lua_type(L, 3);
+  size_t max_s = luaL_optinteger(L, 4, srcl+1);
+  int anchor = (*p == '^');
+  size_t n = 0;
+  MatchState ms;
+  luaL_Buffer b;
+  luaL_argcheck(L, tr == LUA_TNUMBER || tr == LUA_TSTRING ||
+                   tr == LUA_TFUNCTION || tr == LUA_TTABLE, 3,
+                      "string/function/table expected");
+  luaL_buffinit(L, &b);
+  if (anchor) {
+    p++; lp--;  /* skip anchor character */
+  }
+  ms.L = L;
+  ms.matchdepth = MAXCCALLS;
+  ms.src_init = src;
+  ms.src_end = src+srcl;
+  ms.p_end = p + lp;
+  while (n < max_s) {
+    const char *e;
+    ms.level = 0;
+    lua_assert(ms.matchdepth == MAXCCALLS);
+    e = match(&ms, src, p);
+    if (e) {
+      n++;
+      add_value(&ms, &b, src, e, tr);
+    }
+    if (e && e>src) /* non empty match? */
+      src = e;  /* skip it */
+    else if (src < ms.src_end)
+      luaL_addchar(&b, *src++);
+    else break;
+    if (anchor) break;
+  }
+  luaL_addlstring(&b, src, ms.src_end-src);
+  luaL_pushresult(&b);
+  lua_pushinteger(L, n);  /* number of substitutions */
+  return 2;
+}
+
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** STRING FORMAT
+** =======================================================
+*/
+
+/*
+** LUA_INTFRMLEN is the length modifier for integer conversions in
+** 'string.format'; LUA_INTFRM_T is the integer type corresponding to
+** the previous length
+*/
+#if !defined(LUA_INTFRMLEN)	/* { */
+#if defined(LUA_USE_LONGLONG)
+
+#define LUA_INTFRMLEN		"ll"
+#define LUA_INTFRM_T		long long
+
+#else
+
+#define LUA_INTFRMLEN		"l"
+#define LUA_INTFRM_T		long
+
+#endif
+#endif				/* } */
+
+
+/*
+** LUA_FLTFRMLEN is the length modifier for float conversions in
+** 'string.format'; LUA_FLTFRM_T is the float type corresponding to
+** the previous length
+*/
+#if !defined(LUA_FLTFRMLEN)
+
+#define LUA_FLTFRMLEN		""
+#define LUA_FLTFRM_T		double
+
+#endif
+
+
+/* maximum size of each formatted item (> len(format('%99.99f', -1e308))) */
+#define MAX_ITEM	512
+/* valid flags in a format specification */
+#define FLAGS	"-+ #0"
+/*
+** maximum size of each format specification (such as '%-099.99d')
+** (+10 accounts for %99.99x plus margin of error)
+*/
+#define MAX_FORMAT	(sizeof(FLAGS) + sizeof(LUA_INTFRMLEN) + 10)
+
+
+static void addquoted (lua_State *L, luaL_Buffer *b, int arg) {
+  size_t l;
+  const char *s = luaL_checklstring(L, arg, &l);
+  luaL_addchar(b, '"');
+  while (l--) {
+    if (*s == '"' || *s == '\\' || *s == '\n') {
+      luaL_addchar(b, '\\');
+      luaL_addchar(b, *s);
+    }
+    else if (*s == '\0' || iscntrl(uchar(*s))) {
+      char buff[10];
+      if (!isdigit(uchar(*(s+1))))
+        sprintf(buff, "\\%d", (int)uchar(*s));
+      else
+        sprintf(buff, "\\%03d", (int)uchar(*s));
+      luaL_addstring(b, buff);
+    }
+    else
+      luaL_addchar(b, *s);
+    s++;
+  }
+  luaL_addchar(b, '"');
+}
+
+static const char *scanformat (lua_State *L, const char *strfrmt, char *form) {
+  const char *p = strfrmt;
+  while (*p != '\0' && strchr(FLAGS, *p) != NULL) p++;  /* skip flags */
+  if ((size_t)(p - strfrmt) >= sizeof(FLAGS)/sizeof(char))
+    luaL_error(L, "invalid format (repeated flags)");
+  if (isdigit(uchar(*p))) p++;  /* skip width */
+  if (isdigit(uchar(*p))) p++;  /* (2 digits at most) */
+  if (*p == '.') {
+    p++;
+    if (isdigit(uchar(*p))) p++;  /* skip precision */
+    if (isdigit(uchar(*p))) p++;  /* (2 digits at most) */
+  }
+  if (isdigit(uchar(*p)))
+    luaL_error(L, "invalid format (width or precision too long)");
+  *(form++) = '%';
+  memcpy(form, strfrmt, (p - strfrmt + 1) * sizeof(char));
+  form += p - strfrmt + 1;
+  *form = '\0';
+  return p;
+}
+
+
+/*
+** add length modifier into formats
+*/
+static void addlenmod (char *form, const char *lenmod) {
+  size_t l = strlen(form);
+  size_t lm = strlen(lenmod);
+  char spec = form[l - 1];
+  strcpy(form + l - 1, lenmod);
+  form[l + lm - 1] = spec;
+  form[l + lm] = '\0';
+}
+
+
+static int str_format (lua_State *L) {
+  int top = lua_gettop(L);
+  int arg = 1;
+  size_t sfl;
+  const char *strfrmt = luaL_checklstring(L, arg, &sfl);
+  const char *strfrmt_end = strfrmt+sfl;
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  while (strfrmt < strfrmt_end) {
+    if (*strfrmt != L_ESC)
+      luaL_addchar(&b, *strfrmt++);
+    else if (*++strfrmt == L_ESC)
+      luaL_addchar(&b, *strfrmt++);  /* %% */
+    else { /* format item */
+      char form[MAX_FORMAT];  /* to store the format (`%...') */
+      char *buff = luaL_prepbuffsize(&b, MAX_ITEM);  /* to put formatted item */
+      int nb = 0;  /* number of bytes in added item */
+      if (++arg > top)
+        luaL_argerror(L, arg, "no value");
+      strfrmt = scanformat(L, strfrmt, form);
+      switch (*strfrmt++) {
+        case 'c': {
+          nb = sprintf(buff, form, luaL_checkint(L, arg));
+          break;
+        }
+        case 'd': case 'i': {
+          lua_Number n = luaL_checknumber(L, arg);
+          LUA_INTFRM_T ni = (LUA_INTFRM_T)n;
+          lua_Number diff = n - (lua_Number)ni;
+          luaL_argcheck(L, -1 < diff && diff < 1, arg,
+                        "not a number in proper range");
+          addlenmod(form, LUA_INTFRMLEN);
+          nb = sprintf(buff, form, ni);
+          break;
+        }
+        case 'o': case 'u': case 'x': case 'X': {
+          lua_Number n = luaL_checknumber(L, arg);
+          unsigned LUA_INTFRM_T ni = (unsigned LUA_INTFRM_T)n;
+          lua_Number diff = n - (lua_Number)ni;
+          luaL_argcheck(L, -1 < diff && diff < 1, arg,
+                        "not a non-negative number in proper range");
+          addlenmod(form, LUA_INTFRMLEN);
+          nb = sprintf(buff, form, ni);
+          break;
+        }
+        case 'e': case 'E': case 'f':
+#if defined(LUA_USE_AFORMAT)
+        case 'a': case 'A':
+#endif
+        case 'g': case 'G': {
+          addlenmod(form, LUA_FLTFRMLEN);
+          nb = sprintf(buff, form, (LUA_FLTFRM_T)luaL_checknumber(L, arg));
+          break;
+        }
+        case 'q': {
+          addquoted(L, &b, arg);
+          break;
+        }
+        case 's': {
+          size_t l;
+          const char *s = luaL_tolstring(L, arg, &l);
+          if (!strchr(form, '.') && l >= 100) {
+            /* no precision and string is too long to be formatted;
+               keep original string */
+            luaL_addvalue(&b);
+            break;
+          }
+          else {
+            nb = sprintf(buff, form, s);
+            lua_pop(L, 1);  /* remove result from 'luaL_tolstring' */
+            break;
+          }
+        }
+        default: {  /* also treat cases `pnLlh' */
+          return luaL_error(L, "invalid option " LUA_QL("%%%c") " to "
+                               LUA_QL("format"), *(strfrmt - 1));
+        }
+      }
+      luaL_addsize(&b, nb);
+    }
+  }
+  luaL_pushresult(&b);
+  return 1;
+}
+
+/* }====================================================== */
+
+
+static const luaL_Reg strlib[] = {
+  {"byte", str_byte},
+  {"char", str_char},
+  {"dump", str_dump},
+  {"find", str_find},
+  {"format", str_format},
+  {"gmatch", gmatch},
+  {"gsub", str_gsub},
+  {"len", str_len},
+  {"lower", str_lower},
+  {"match", str_match},
+  {"rep", str_rep},
+  {"reverse", str_reverse},
+  {"sub", str_sub},
+  {"upper", str_upper},
+  {NULL, NULL}
+};
+
+
+static void createmetatable (lua_State *L) {
+  lua_createtable(L, 0, 1);  /* table to be metatable for strings */
+  lua_pushliteral(L, "");  /* dummy string */
+  lua_pushvalue(L, -2);  /* copy table */
+  lua_setmetatable(L, -2);  /* set table as metatable for strings */
+  lua_pop(L, 1);  /* pop dummy string */
+  lua_pushvalue(L, -2);  /* get string library */
+  lua_setfield(L, -2, "__index");  /* metatable.__index = string */
+  lua_pop(L, 1);  /* pop metatable */
+}
+
+
+/*
+** Open string library
+*/
+LUAMOD_API int luaopen_string (lua_State *L) {
+  luaL_newlib(L, strlib);
+  createmetatable(L);
+  return 1;
+}
+
diff -ruNp src.orig/libs/lua/ltable.c src/libs/lua/ltable.c
--- src.orig/libs/lua/ltable.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/ltable.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,588 @@
+/*
+** $Id: ltable.c,v 2.72 2012/09/11 19:37:16 roberto Exp $
+** Lua tables (hash)
+** See Copyright Notice in lua.h
+*/
+
+
+/*
+** Implementation of tables (aka arrays, objects, or hash tables).
+** Tables keep its elements in two parts: an array part and a hash part.
+** Non-negative integer keys are all candidates to be kept in the array
+** part. The actual size of the array is the largest `n' such that at
+** least half the slots between 0 and n are in use.
+** Hash uses a mix of chained scatter table with Brent's variation.
+** A main invariant of these tables is that, if an element is not
+** in its main position (i.e. the `original' position that its hash gives
+** to it), then the colliding element is in its own main position.
+** Hence even when the load factor reaches 100%, performance remains good.
+*/
+
+#include <string.h>
+
+#define ltable_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "lvm.h"
+
+
+/*
+** max size of array part is 2^MAXBITS
+*/
+#if LUAI_BITSINT >= 32
+#define MAXBITS		30
+#else
+#define MAXBITS		(LUAI_BITSINT-2)
+#endif
+
+#define MAXASIZE	(1 << MAXBITS)
+
+
+#define hashpow2(t,n)		(gnode(t, lmod((n), sizenode(t))))
+
+#define hashstr(t,str)		hashpow2(t, (str)->tsv.hash)
+#define hashboolean(t,p)	hashpow2(t, p)
+
+
+/*
+** for some types, it is better to avoid modulus by power of 2, as
+** they tend to have many 2 factors.
+*/
+#define hashmod(t,n)	(gnode(t, ((n) % ((sizenode(t)-1)|1))))
+
+
+#define hashpointer(t,p)	hashmod(t, IntPoint(p))
+
+
+#define dummynode		(&dummynode_)
+
+#define isdummy(n)		((n) == dummynode)
+
+static const Node dummynode_ = {
+  {NILCONSTANT},  /* value */
+  {{NILCONSTANT, NULL}}  /* key */
+};
+
+
+/*
+** hash for lua_Numbers
+*/
+static Node *hashnum (const Table *t, lua_Number n) {
+  int i;
+  luai_hashnum(i, n);
+  if (i < 0) {
+    if (cast(unsigned int, i) == 0u - i)  /* use unsigned to avoid overflows */
+      i = 0;  /* handle INT_MIN */
+    i = -i;  /* must be a positive value */
+  }
+  return hashmod(t, i);
+}
+
+
+
+/*
+** returns the `main' position of an element in a table (that is, the index
+** of its hash value)
+*/
+static Node *mainposition (const Table *t, const TValue *key) {
+  switch (ttype(key)) {
+    case LUA_TNUMBER:
+      return hashnum(t, nvalue(key));
+    case LUA_TLNGSTR: {
+      TString *s = rawtsvalue(key);
+      if (s->tsv.extra == 0) {  /* no hash? */
+        s->tsv.hash = luaS_hash(getstr(s), s->tsv.len, s->tsv.hash);
+        s->tsv.extra = 1;  /* now it has its hash */
+      }
+      return hashstr(t, rawtsvalue(key));
+    }
+    case LUA_TSHRSTR:
+      return hashstr(t, rawtsvalue(key));
+    case LUA_TBOOLEAN:
+      return hashboolean(t, bvalue(key));
+    case LUA_TLIGHTUSERDATA:
+      return hashpointer(t, pvalue(key));
+    case LUA_TLCF:
+      return hashpointer(t, fvalue(key));
+    default:
+      return hashpointer(t, gcvalue(key));
+  }
+}
+
+
+/*
+** returns the index for `key' if `key' is an appropriate key to live in
+** the array part of the table, -1 otherwise.
+*/
+static int arrayindex (const TValue *key) {
+  if (ttisnumber(key)) {
+    lua_Number n = nvalue(key);
+    int k;
+    lua_number2int(k, n);
+    if (luai_numeq(cast_num(k), n))
+      return k;
+  }
+  return -1;  /* `key' did not match some condition */
+}
+
+
+/*
+** returns the index of a `key' for table traversals. First goes all
+** elements in the array part, then elements in the hash part. The
+** beginning of a traversal is signaled by -1.
+*/
+static int findindex (lua_State *L, Table *t, StkId key) {
+  int i;
+  if (ttisnil(key)) return -1;  /* first iteration */
+  i = arrayindex(key);
+  if (0 < i && i <= t->sizearray)  /* is `key' inside array part? */
+    return i-1;  /* yes; that's the index (corrected to C) */
+  else {
+    Node *n = mainposition(t, key);
+    for (;;) {  /* check whether `key' is somewhere in the chain */
+      /* key may be dead already, but it is ok to use it in `next' */
+      if (luaV_rawequalobj(gkey(n), key) ||
+            (ttisdeadkey(gkey(n)) && iscollectable(key) &&
+             deadvalue(gkey(n)) == gcvalue(key))) {
+        i = cast_int(n - gnode(t, 0));  /* key index in hash table */
+        /* hash elements are numbered after array ones */
+        return i + t->sizearray;
+      }
+      else n = gnext(n);
+      if (n == NULL)
+        luaG_runerror(L, "invalid key to " LUA_QL("next"));  /* key not found */
+    }
+  }
+}
+
+
+int luaH_next (lua_State *L, Table *t, StkId key) {
+  int i = findindex(L, t, key);  /* find original element */
+  for (i++; i < t->sizearray; i++) {  /* try first array part */
+    if (!ttisnil(&t->array[i])) {  /* a non-nil value? */
+      setnvalue(key, cast_num(i+1));
+      setobj2s(L, key+1, &t->array[i]);
+      return 1;
+    }
+  }
+  for (i -= t->sizearray; i < sizenode(t); i++) {  /* then hash part */
+    if (!ttisnil(gval(gnode(t, i)))) {  /* a non-nil value? */
+      setobj2s(L, key, gkey(gnode(t, i)));
+      setobj2s(L, key+1, gval(gnode(t, i)));
+      return 1;
+    }
+  }
+  return 0;  /* no more elements */
+}
+
+
+/*
+** {=============================================================
+** Rehash
+** ==============================================================
+*/
+
+
+static int computesizes (int nums[], int *narray) {
+  int i;
+  int twotoi;  /* 2^i */
+  int a = 0;  /* number of elements smaller than 2^i */
+  int na = 0;  /* number of elements to go to array part */
+  int n = 0;  /* optimal size for array part */
+  for (i = 0, twotoi = 1; twotoi/2 < *narray; i++, twotoi *= 2) {
+    if (nums[i] > 0) {
+      a += nums[i];
+      if (a > twotoi/2) {  /* more than half elements present? */
+        n = twotoi;  /* optimal size (till now) */
+        na = a;  /* all elements smaller than n will go to array part */
+      }
+    }
+    if (a == *narray) break;  /* all elements already counted */
+  }
+  *narray = n;
+  lua_assert(*narray/2 <= na && na <= *narray);
+  return na;
+}
+
+
+static int countint (const TValue *key, int *nums) {
+  int k = arrayindex(key);
+  if (0 < k && k <= MAXASIZE) {  /* is `key' an appropriate array index? */
+    nums[luaO_ceillog2(k)]++;  /* count as such */
+    return 1;
+  }
+  else
+    return 0;
+}
+
+
+static int numusearray (const Table *t, int *nums) {
+  int lg;
+  int ttlg;  /* 2^lg */
+  int ause = 0;  /* summation of `nums' */
+  int i = 1;  /* count to traverse all array keys */
+  for (lg=0, ttlg=1; lg<=MAXBITS; lg++, ttlg*=2) {  /* for each slice */
+    int lc = 0;  /* counter */
+    int lim = ttlg;
+    if (lim > t->sizearray) {
+      lim = t->sizearray;  /* adjust upper limit */
+      if (i > lim)
+        break;  /* no more elements to count */
+    }
+    /* count elements in range (2^(lg-1), 2^lg] */
+    for (; i <= lim; i++) {
+      if (!ttisnil(&t->array[i-1]))
+        lc++;
+    }
+    nums[lg] += lc;
+    ause += lc;
+  }
+  return ause;
+}
+
+
+static int numusehash (const Table *t, int *nums, int *pnasize) {
+  int totaluse = 0;  /* total number of elements */
+  int ause = 0;  /* summation of `nums' */
+  int i = sizenode(t);
+  while (i--) {
+    Node *n = &t->node[i];
+    if (!ttisnil(gval(n))) {
+      ause += countint(gkey(n), nums);
+      totaluse++;
+    }
+  }
+  *pnasize += ause;
+  return totaluse;
+}
+
+
+static void setarrayvector (lua_State *L, Table *t, int size) {
+  int i;
+  luaM_reallocvector(L, t->array, t->sizearray, size, TValue);
+  for (i=t->sizearray; i<size; i++)
+     setnilvalue(&t->array[i]);
+  t->sizearray = size;
+}
+
+
+static void setnodevector (lua_State *L, Table *t, int size) {
+  int lsize;
+  if (size == 0) {  /* no elements to hash part? */
+    t->node = cast(Node *, dummynode);  /* use common `dummynode' */
+    lsize = 0;
+  }
+  else {
+    int i;
+    lsize = luaO_ceillog2(size);
+    if (lsize > MAXBITS)
+      luaG_runerror(L, "table overflow");
+    size = twoto(lsize);
+    t->node = luaM_newvector(L, size, Node);
+    for (i=0; i<size; i++) {
+      Node *n = gnode(t, i);
+      gnext(n) = NULL;
+      setnilvalue(gkey(n));
+      setnilvalue(gval(n));
+    }
+  }
+  t->lsizenode = cast_byte(lsize);
+  t->lastfree = gnode(t, size);  /* all positions are free */
+}
+
+
+void luaH_resize (lua_State *L, Table *t, int nasize, int nhsize) {
+  int i;
+  int oldasize = t->sizearray;
+  int oldhsize = t->lsizenode;
+  Node *nold = t->node;  /* save old hash ... */
+  if (nasize > oldasize)  /* array part must grow? */
+    setarrayvector(L, t, nasize);
+  /* create new hash part with appropriate size */
+  setnodevector(L, t, nhsize);
+  if (nasize < oldasize) {  /* array part must shrink? */
+    t->sizearray = nasize;
+    /* re-insert elements from vanishing slice */
+    for (i=nasize; i<oldasize; i++) {
+      if (!ttisnil(&t->array[i]))
+        luaH_setint(L, t, i + 1, &t->array[i]);
+    }
+    /* shrink array */
+    luaM_reallocvector(L, t->array, oldasize, nasize, TValue);
+  }
+  /* re-insert elements from hash part */
+  for (i = twoto(oldhsize) - 1; i >= 0; i--) {
+    Node *old = nold+i;
+    if (!ttisnil(gval(old))) {
+      /* doesn't need barrier/invalidate cache, as entry was
+         already present in the table */
+      setobjt2t(L, luaH_set(L, t, gkey(old)), gval(old));
+    }
+  }
+  if (!isdummy(nold))
+    luaM_freearray(L, nold, cast(size_t, twoto(oldhsize))); /* free old array */
+}
+
+
+void luaH_resizearray (lua_State *L, Table *t, int nasize) {
+  int nsize = isdummy(t->node) ? 0 : sizenode(t);
+  luaH_resize(L, t, nasize, nsize);
+}
+
+
+static void rehash (lua_State *L, Table *t, const TValue *ek) {
+  int nasize, na;
+  int nums[MAXBITS+1];  /* nums[i] = number of keys with 2^(i-1) < k <= 2^i */
+  int i;
+  int totaluse;
+  for (i=0; i<=MAXBITS; i++) nums[i] = 0;  /* reset counts */
+  nasize = numusearray(t, nums);  /* count keys in array part */
+  totaluse = nasize;  /* all those keys are integer keys */
+  totaluse += numusehash(t, nums, &nasize);  /* count keys in hash part */
+  /* count extra key */
+  nasize += countint(ek, nums);
+  totaluse++;
+  /* compute new size for array part */
+  na = computesizes(nums, &nasize);
+  /* resize the table to new computed sizes */
+  luaH_resize(L, t, nasize, totaluse - na);
+}
+
+
+
+/*
+** }=============================================================
+*/
+
+
+Table *luaH_new (lua_State *L) {
+  Table *t = &luaC_newobj(L, LUA_TTABLE, sizeof(Table), NULL, 0)->h;
+  t->metatable = NULL;
+  t->flags = cast_byte(~0);
+  t->array = NULL;
+  t->sizearray = 0;
+  setnodevector(L, t, 0);
+  return t;
+}
+
+
+void luaH_free (lua_State *L, Table *t) {
+  if (!isdummy(t->node))
+    luaM_freearray(L, t->node, cast(size_t, sizenode(t)));
+  luaM_freearray(L, t->array, t->sizearray);
+  luaM_free(L, t);
+}
+
+
+static Node *getfreepos (Table *t) {
+  while (t->lastfree > t->node) {
+    t->lastfree--;
+    if (ttisnil(gkey(t->lastfree)))
+      return t->lastfree;
+  }
+  return NULL;  /* could not find a free place */
+}
+
+
+
+/*
+** inserts a new key into a hash table; first, check whether key's main
+** position is free. If not, check whether colliding node is in its main
+** position or not: if it is not, move colliding node to an empty place and
+** put new key in its main position; otherwise (colliding node is in its main
+** position), new key goes to an empty position.
+*/
+TValue *luaH_newkey (lua_State *L, Table *t, const TValue *key) {
+  Node *mp;
+  if (ttisnil(key)) luaG_runerror(L, "table index is nil");
+  else if (ttisnumber(key) && luai_numisnan(L, nvalue(key)))
+    luaG_runerror(L, "table index is NaN");
+  mp = mainposition(t, key);
+  if (!ttisnil(gval(mp)) || isdummy(mp)) {  /* main position is taken? */
+    Node *othern;
+    Node *n = getfreepos(t);  /* get a free place */
+    if (n == NULL) {  /* cannot find a free place? */
+      rehash(L, t, key);  /* grow table */
+      /* whatever called 'newkey' take care of TM cache and GC barrier */
+      return luaH_set(L, t, key);  /* insert key into grown table */
+    }
+    lua_assert(!isdummy(n));
+    othern = mainposition(t, gkey(mp));
+    if (othern != mp) {  /* is colliding node out of its main position? */
+      /* yes; move colliding node into free position */
+      while (gnext(othern) != mp) othern = gnext(othern);  /* find previous */
+      gnext(othern) = n;  /* redo the chain with `n' in place of `mp' */
+      *n = *mp;  /* copy colliding node into free pos. (mp->next also goes) */
+      gnext(mp) = NULL;  /* now `mp' is free */
+      setnilvalue(gval(mp));
+    }
+    else {  /* colliding node is in its own main position */
+      /* new node will go into free position */
+      gnext(n) = gnext(mp);  /* chain new position */
+      gnext(mp) = n;
+      mp = n;
+    }
+  }
+  setobj2t(L, gkey(mp), key);
+  luaC_barrierback(L, obj2gco(t), key);
+  lua_assert(ttisnil(gval(mp)));
+  return gval(mp);
+}
+
+
+/*
+** search function for integers
+*/
+const TValue *luaH_getint (Table *t, int key) {
+  /* (1 <= key && key <= t->sizearray) */
+  if (cast(unsigned int, key-1) < cast(unsigned int, t->sizearray))
+    return &t->array[key-1];
+  else {
+    lua_Number nk = cast_num(key);
+    Node *n = hashnum(t, nk);
+    do {  /* check whether `key' is somewhere in the chain */
+      if (ttisnumber(gkey(n)) && luai_numeq(nvalue(gkey(n)), nk))
+        return gval(n);  /* that's it */
+      else n = gnext(n);
+    } while (n);
+    return luaO_nilobject;
+  }
+}
+
+
+/*
+** search function for short strings
+*/
+const TValue *luaH_getstr (Table *t, TString *key) {
+  Node *n = hashstr(t, key);
+  lua_assert(key->tsv.tt == LUA_TSHRSTR);
+  do {  /* check whether `key' is somewhere in the chain */
+    if (ttisshrstring(gkey(n)) && eqshrstr(rawtsvalue(gkey(n)), key))
+      return gval(n);  /* that's it */
+    else n = gnext(n);
+  } while (n);
+  return luaO_nilobject;
+}
+
+
+/*
+** main search function
+*/
+const TValue *luaH_get (Table *t, const TValue *key) {
+  switch (ttype(key)) {
+    case LUA_TSHRSTR: return luaH_getstr(t, rawtsvalue(key));
+    case LUA_TNIL: return luaO_nilobject;
+    case LUA_TNUMBER: {
+      int k;
+      lua_Number n = nvalue(key);
+      lua_number2int(k, n);
+      if (luai_numeq(cast_num(k), n)) /* index is int? */
+        return luaH_getint(t, k);  /* use specialized version */
+      /* else go through */
+    }
+    default: {
+      Node *n = mainposition(t, key);
+      do {  /* check whether `key' is somewhere in the chain */
+        if (luaV_rawequalobj(gkey(n), key))
+          return gval(n);  /* that's it */
+        else n = gnext(n);
+      } while (n);
+      return luaO_nilobject;
+    }
+  }
+}
+
+
+/*
+** beware: when using this function you probably need to check a GC
+** barrier and invalidate the TM cache.
+*/
+TValue *luaH_set (lua_State *L, Table *t, const TValue *key) {
+  const TValue *p = luaH_get(t, key);
+  if (p != luaO_nilobject)
+    return cast(TValue *, p);
+  else return luaH_newkey(L, t, key);
+}
+
+
+void luaH_setint (lua_State *L, Table *t, int key, TValue *value) {
+  const TValue *p = luaH_getint(t, key);
+  TValue *cell;
+  if (p != luaO_nilobject)
+    cell = cast(TValue *, p);
+  else {
+    TValue k;
+    setnvalue(&k, cast_num(key));
+    cell = luaH_newkey(L, t, &k);
+  }
+  setobj2t(L, cell, value);
+}
+
+
+static int unbound_search (Table *t, unsigned int j) {
+  unsigned int i = j;  /* i is zero or a present index */
+  j++;
+  /* find `i' and `j' such that i is present and j is not */
+  while (!ttisnil(luaH_getint(t, j))) {
+    i = j;
+    j *= 2;
+    if (j > cast(unsigned int, MAX_INT)) {  /* overflow? */
+      /* table was built with bad purposes: resort to linear search */
+      i = 1;
+      while (!ttisnil(luaH_getint(t, i))) i++;
+      return i - 1;
+    }
+  }
+  /* now do a binary search between them */
+  while (j - i > 1) {
+    unsigned int m = (i+j)/2;
+    if (ttisnil(luaH_getint(t, m))) j = m;
+    else i = m;
+  }
+  return i;
+}
+
+
+/*
+** Try to find a boundary in table `t'. A `boundary' is an integer index
+** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).
+*/
+int luaH_getn (Table *t) {
+  unsigned int j = t->sizearray;
+  if (j > 0 && ttisnil(&t->array[j - 1])) {
+    /* there is a boundary in the array part: (binary) search for it */
+    unsigned int i = 0;
+    while (j - i > 1) {
+      unsigned int m = (i+j)/2;
+      if (ttisnil(&t->array[m - 1])) j = m;
+      else i = m;
+    }
+    return i;
+  }
+  /* else must find a boundary in hash part */
+  else if (isdummy(t->node))  /* hash part is empty? */
+    return j;  /* that is easy... */
+  else return unbound_search(t, j);
+}
+
+
+
+#if defined(LUA_DEBUG)
+
+Node *luaH_mainposition (const Table *t, const TValue *key) {
+  return mainposition(t, key);
+}
+
+int luaH_isdummy (Node *n) { return isdummy(n); }
+
+#endif
diff -ruNp src.orig/libs/lua/ltable.h src/libs/lua/ltable.h
--- src.orig/libs/lua/ltable.h	1969-12-31 18:00:00 -0600
+++ src/libs/lua/ltable.h	2017-11-21 19:39:46 -0600
@@ -0,0 +1,41 @@
+/*
+** $Id: ltable.h,v 2.16 2011/08/17 20:26:47 roberto Exp $
+** Lua tables (hash)
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ltable_h
+#define ltable_h
+
+#include "lobject.h"
+
+
+#define gnode(t,i)	(&(t)->node[i])
+#define gkey(n)		(&(n)->i_key.tvk)
+#define gval(n)		(&(n)->i_val)
+#define gnext(n)	((n)->i_key.nk.next)
+
+#define invalidateTMcache(t)	((t)->flags = 0)
+
+
+LUAI_FUNC const TValue *luaH_getint (Table *t, int key);
+LUAI_FUNC void luaH_setint (lua_State *L, Table *t, int key, TValue *value);
+LUAI_FUNC const TValue *luaH_getstr (Table *t, TString *key);
+LUAI_FUNC const TValue *luaH_get (Table *t, const TValue *key);
+LUAI_FUNC TValue *luaH_newkey (lua_State *L, Table *t, const TValue *key);
+LUAI_FUNC TValue *luaH_set (lua_State *L, Table *t, const TValue *key);
+LUAI_FUNC Table *luaH_new (lua_State *L);
+LUAI_FUNC void luaH_resize (lua_State *L, Table *t, int nasize, int nhsize);
+LUAI_FUNC void luaH_resizearray (lua_State *L, Table *t, int nasize);
+LUAI_FUNC void luaH_free (lua_State *L, Table *t);
+LUAI_FUNC int luaH_next (lua_State *L, Table *t, StkId key);
+LUAI_FUNC int luaH_getn (Table *t);
+
+
+#if defined(LUA_DEBUG)
+LUAI_FUNC Node *luaH_mainposition (const Table *t, const TValue *key);
+LUAI_FUNC int luaH_isdummy (Node *n);
+#endif
+
+
+#endif
diff -ruNp src.orig/libs/lua/ltablib.c src/libs/lua/ltablib.c
--- src.orig/libs/lua/ltablib.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/ltablib.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,283 @@
+/*
+** $Id: ltablib.c,v 1.65 2013/03/07 18:17:24 roberto Exp $
+** Library for Table Manipulation
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stddef.h>
+
+#define ltablib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+#define aux_getn(L,n)	(luaL_checktype(L, n, LUA_TTABLE), luaL_len(L, n))
+
+
+
+#if defined(LUA_COMPAT_MAXN)
+static int maxn (lua_State *L) {
+  lua_Number max = 0;
+  luaL_checktype(L, 1, LUA_TTABLE);
+  lua_pushnil(L);  /* first key */
+  while (lua_next(L, 1)) {
+    lua_pop(L, 1);  /* remove value */
+    if (lua_type(L, -1) == LUA_TNUMBER) {
+      lua_Number v = lua_tonumber(L, -1);
+      if (v > max) max = v;
+    }
+  }
+  lua_pushnumber(L, max);
+  return 1;
+}
+#endif
+
+
+static int tinsert (lua_State *L) {
+  int e = aux_getn(L, 1) + 1;  /* first empty element */
+  int pos;  /* where to insert new element */
+  switch (lua_gettop(L)) {
+    case 2: {  /* called with only 2 arguments */
+      pos = e;  /* insert new element at the end */
+      break;
+    }
+    case 3: {
+      int i;
+      pos = luaL_checkint(L, 2);  /* 2nd argument is the position */
+      luaL_argcheck(L, 1 <= pos && pos <= e, 2, "position out of bounds");
+      for (i = e; i > pos; i--) {  /* move up elements */
+        lua_rawgeti(L, 1, i-1);
+        lua_rawseti(L, 1, i);  /* t[i] = t[i-1] */
+      }
+      break;
+    }
+    default: {
+      return luaL_error(L, "wrong number of arguments to " LUA_QL("insert"));
+    }
+  }
+  lua_rawseti(L, 1, pos);  /* t[pos] = v */
+  return 0;
+}
+
+
+static int tremove (lua_State *L) {
+  int size = aux_getn(L, 1);
+  int pos = luaL_optint(L, 2, size);
+  if (pos != size)  /* validate 'pos' if given */
+    luaL_argcheck(L, 1 <= pos && pos <= size + 1, 1, "position out of bounds");
+  lua_rawgeti(L, 1, pos);  /* result = t[pos] */
+  for ( ; pos < size; pos++) {
+    lua_rawgeti(L, 1, pos+1);
+    lua_rawseti(L, 1, pos);  /* t[pos] = t[pos+1] */
+  }
+  lua_pushnil(L);
+  lua_rawseti(L, 1, pos);  /* t[pos] = nil */
+  return 1;
+}
+
+
+static void addfield (lua_State *L, luaL_Buffer *b, int i) {
+  lua_rawgeti(L, 1, i);
+  if (!lua_isstring(L, -1))
+    luaL_error(L, "invalid value (%s) at index %d in table for "
+                  LUA_QL("concat"), luaL_typename(L, -1), i);
+  luaL_addvalue(b);
+}
+
+
+static int tconcat (lua_State *L) {
+  luaL_Buffer b;
+  size_t lsep;
+  int i, last;
+  const char *sep = luaL_optlstring(L, 2, "", &lsep);
+  luaL_checktype(L, 1, LUA_TTABLE);
+  i = luaL_optint(L, 3, 1);
+  last = luaL_opt(L, luaL_checkint, 4, luaL_len(L, 1));
+  luaL_buffinit(L, &b);
+  for (; i < last; i++) {
+    addfield(L, &b, i);
+    luaL_addlstring(&b, sep, lsep);
+  }
+  if (i == last)  /* add last value (if interval was not empty) */
+    addfield(L, &b, i);
+  luaL_pushresult(&b);
+  return 1;
+}
+
+
+/*
+** {======================================================
+** Pack/unpack
+** =======================================================
+*/
+
+static int pack (lua_State *L) {
+  int n = lua_gettop(L);  /* number of elements to pack */
+  lua_createtable(L, n, 1);  /* create result table */
+  lua_pushinteger(L, n);
+  lua_setfield(L, -2, "n");  /* t.n = number of elements */
+  if (n > 0) {  /* at least one element? */
+    int i;
+    lua_pushvalue(L, 1);
+    lua_rawseti(L, -2, 1);  /* insert first element */
+    lua_replace(L, 1);  /* move table into index 1 */
+    for (i = n; i >= 2; i--)  /* assign other elements */
+      lua_rawseti(L, 1, i);
+  }
+  return 1;  /* return table */
+}
+
+
+static int unpack (lua_State *L) {
+  int i, e, n;
+  luaL_checktype(L, 1, LUA_TTABLE);
+  i = luaL_optint(L, 2, 1);
+  e = luaL_opt(L, luaL_checkint, 3, luaL_len(L, 1));
+  if (i > e) return 0;  /* empty range */
+  n = e - i + 1;  /* number of elements */
+  if (n <= 0 || !lua_checkstack(L, n))  /* n <= 0 means arith. overflow */
+    return luaL_error(L, "too many results to unpack");
+  lua_rawgeti(L, 1, i);  /* push arg[i] (avoiding overflow problems) */
+  while (i++ < e)  /* push arg[i + 1...e] */
+    lua_rawgeti(L, 1, i);
+  return n;
+}
+
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** Quicksort
+** (based on `Algorithms in MODULA-3', Robert Sedgewick;
+**  Addison-Wesley, 1993.)
+** =======================================================
+*/
+
+
+static void set2 (lua_State *L, int i, int j) {
+  lua_rawseti(L, 1, i);
+  lua_rawseti(L, 1, j);
+}
+
+static int sort_comp (lua_State *L, int a, int b) {
+  if (!lua_isnil(L, 2)) {  /* function? */
+    int res;
+    lua_pushvalue(L, 2);
+    lua_pushvalue(L, a-1);  /* -1 to compensate function */
+    lua_pushvalue(L, b-2);  /* -2 to compensate function and `a' */
+    lua_call(L, 2, 1);
+    res = lua_toboolean(L, -1);
+    lua_pop(L, 1);
+    return res;
+  }
+  else  /* a < b? */
+    return lua_compare(L, a, b, LUA_OPLT);
+}
+
+static void auxsort (lua_State *L, int l, int u) {
+  while (l < u) {  /* for tail recursion */
+    int i, j;
+    /* sort elements a[l], a[(l+u)/2] and a[u] */
+    lua_rawgeti(L, 1, l);
+    lua_rawgeti(L, 1, u);
+    if (sort_comp(L, -1, -2))  /* a[u] < a[l]? */
+      set2(L, l, u);  /* swap a[l] - a[u] */
+    else
+      lua_pop(L, 2);
+    if (u-l == 1) break;  /* only 2 elements */
+    i = (l+u)/2;
+    lua_rawgeti(L, 1, i);
+    lua_rawgeti(L, 1, l);
+    if (sort_comp(L, -2, -1))  /* a[i]<a[l]? */
+      set2(L, i, l);
+    else {
+      lua_pop(L, 1);  /* remove a[l] */
+      lua_rawgeti(L, 1, u);
+      if (sort_comp(L, -1, -2))  /* a[u]<a[i]? */
+        set2(L, i, u);
+      else
+        lua_pop(L, 2);
+    }
+    if (u-l == 2) break;  /* only 3 elements */
+    lua_rawgeti(L, 1, i);  /* Pivot */
+    lua_pushvalue(L, -1);
+    lua_rawgeti(L, 1, u-1);
+    set2(L, i, u-1);
+    /* a[l] <= P == a[u-1] <= a[u], only need to sort from l+1 to u-2 */
+    i = l; j = u-1;
+    for (;;) {  /* invariant: a[l..i] <= P <= a[j..u] */
+      /* repeat ++i until a[i] >= P */
+      while (lua_rawgeti(L, 1, ++i), sort_comp(L, -1, -2)) {
+        if (i>=u) luaL_error(L, "invalid order function for sorting");
+        lua_pop(L, 1);  /* remove a[i] */
+      }
+      /* repeat --j until a[j] <= P */
+      while (lua_rawgeti(L, 1, --j), sort_comp(L, -3, -1)) {
+        if (j<=l) luaL_error(L, "invalid order function for sorting");
+        lua_pop(L, 1);  /* remove a[j] */
+      }
+      if (j<i) {
+        lua_pop(L, 3);  /* pop pivot, a[i], a[j] */
+        break;
+      }
+      set2(L, i, j);
+    }
+    lua_rawgeti(L, 1, u-1);
+    lua_rawgeti(L, 1, i);
+    set2(L, u-1, i);  /* swap pivot (a[u-1]) with a[i] */
+    /* a[l..i-1] <= a[i] == P <= a[i+1..u] */
+    /* adjust so that smaller half is in [j..i] and larger one in [l..u] */
+    if (i-l < u-i) {
+      j=l; i=i-1; l=i+2;
+    }
+    else {
+      j=i+1; i=u; u=j-2;
+    }
+    auxsort(L, j, i);  /* call recursively the smaller one */
+  }  /* repeat the routine for the larger one */
+}
+
+static int sort (lua_State *L) {
+  int n = aux_getn(L, 1);
+  luaL_checkstack(L, 40, "");  /* assume array is smaller than 2^40 */
+  if (!lua_isnoneornil(L, 2))  /* is there a 2nd argument? */
+    luaL_checktype(L, 2, LUA_TFUNCTION);
+  lua_settop(L, 2);  /* make sure there is two arguments */
+  auxsort(L, 1, n);
+  return 0;
+}
+
+/* }====================================================== */
+
+
+static const luaL_Reg tab_funcs[] = {
+  {"concat", tconcat},
+#if defined(LUA_COMPAT_MAXN)
+  {"maxn", maxn},
+#endif
+  {"insert", tinsert},
+  {"pack", pack},
+  {"unpack", unpack},
+  {"remove", tremove},
+  {"sort", sort},
+  {NULL, NULL}
+};
+
+
+LUAMOD_API int luaopen_table (lua_State *L) {
+  luaL_newlib(L, tab_funcs);
+#if defined(LUA_COMPAT_UNPACK)
+  /* _G.unpack = table.unpack */
+  lua_getfield(L, -1, "unpack");
+  lua_setglobal(L, "unpack");
+#endif
+  return 1;
+}
+
diff -ruNp src.orig/libs/lua/ltm.c src/libs/lua/ltm.c
--- src.orig/libs/lua/ltm.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/ltm.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,77 @@
+/*
+** $Id: ltm.c,v 2.14 2011/06/02 19:31:40 roberto Exp $
+** Tag methods
+** See Copyright Notice in lua.h
+*/
+
+
+#include <string.h>
+
+#define ltm_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+
+
+static const char udatatypename[] = "userdata";
+
+LUAI_DDEF const char *const luaT_typenames_[LUA_TOTALTAGS] = {
+  "no value",
+  "nil", "boolean", udatatypename, "number",
+  "string", "table", "function", udatatypename, "thread",
+  "proto", "upval"  /* these last two cases are used for tests only */
+};
+
+
+void luaT_init (lua_State *L) {
+  static const char *const luaT_eventname[] = {  /* ORDER TM */
+    "__index", "__newindex",
+    "__gc", "__mode", "__len", "__eq",
+    "__add", "__sub", "__mul", "__div", "__mod",
+    "__pow", "__unm", "__lt", "__le",
+    "__concat", "__call"
+  };
+  int i;
+  for (i=0; i<TM_N; i++) {
+    G(L)->tmname[i] = luaS_new(L, luaT_eventname[i]);
+    luaS_fix(G(L)->tmname[i]);  /* never collect these names */
+  }
+}
+
+
+/*
+** function to be used with macro "fasttm": optimized for absence of
+** tag methods
+*/
+const TValue *luaT_gettm (Table *events, TMS event, TString *ename) {
+  const TValue *tm = luaH_getstr(events, ename);
+  lua_assert(event <= TM_EQ);
+  if (ttisnil(tm)) {  /* no tag method? */
+    events->flags |= cast_byte(1u<<event);  /* cache this fact */
+    return NULL;
+  }
+  else return tm;
+}
+
+
+const TValue *luaT_gettmbyobj (lua_State *L, const TValue *o, TMS event) {
+  Table *mt;
+  switch (ttypenv(o)) {
+    case LUA_TTABLE:
+      mt = hvalue(o)->metatable;
+      break;
+    case LUA_TUSERDATA:
+      mt = uvalue(o)->metatable;
+      break;
+    default:
+      mt = G(L)->mt[ttypenv(o)];
+  }
+  return (mt ? luaH_getstr(mt, G(L)->tmname[event]) : luaO_nilobject);
+}
+
diff -ruNp src.orig/libs/lua/ltm.h src/libs/lua/ltm.h
--- src.orig/libs/lua/ltm.h	1969-12-31 18:00:00 -0600
+++ src/libs/lua/ltm.h	2017-11-21 19:39:46 -0600
@@ -0,0 +1,57 @@
+/*
+** $Id: ltm.h,v 2.11 2011/02/28 17:32:10 roberto Exp $
+** Tag methods
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ltm_h
+#define ltm_h
+
+
+#include "lobject.h"
+
+
+/*
+* WARNING: if you change the order of this enumeration,
+* grep "ORDER TM"
+*/
+typedef enum {
+  TM_INDEX,
+  TM_NEWINDEX,
+  TM_GC,
+  TM_MODE,
+  TM_LEN,
+  TM_EQ,  /* last tag method with `fast' access */
+  TM_ADD,
+  TM_SUB,
+  TM_MUL,
+  TM_DIV,
+  TM_MOD,
+  TM_POW,
+  TM_UNM,
+  TM_LT,
+  TM_LE,
+  TM_CONCAT,
+  TM_CALL,
+  TM_N		/* number of elements in the enum */
+} TMS;
+
+
+
+#define gfasttm(g,et,e) ((et) == NULL ? NULL : \
+  ((et)->flags & (1u<<(e))) ? NULL : luaT_gettm(et, e, (g)->tmname[e]))
+
+#define fasttm(l,et,e)	gfasttm(G(l), et, e)
+
+#define ttypename(x)	luaT_typenames_[(x) + 1]
+#define objtypename(x)	ttypename(ttypenv(x))
+
+LUAI_DDEC const char *const luaT_typenames_[LUA_TOTALTAGS];
+
+
+LUAI_FUNC const TValue *luaT_gettm (Table *events, TMS event, TString *ename);
+LUAI_FUNC const TValue *luaT_gettmbyobj (lua_State *L, const TValue *o,
+                                                       TMS event);
+LUAI_FUNC void luaT_init (lua_State *L);
+
+#endif
diff -ruNp src.orig/libs/lua/lua.c src/libs/lua/lua.c
--- src.orig/libs/lua/lua.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lua.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,497 @@
+/*
+** $Id: lua.c,v 1.206 2012/09/29 20:07:06 roberto Exp $
+** Lua stand-alone interpreter
+** See Copyright Notice in lua.h
+*/
+
+
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define lua_c
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+#if !defined(LUA_PROMPT)
+#define LUA_PROMPT		"> "
+#define LUA_PROMPT2		">> "
+#endif
+
+#if !defined(LUA_PROGNAME)
+#define LUA_PROGNAME		"lua"
+#endif
+
+#if !defined(LUA_MAXINPUT)
+#define LUA_MAXINPUT		512
+#endif
+
+#if !defined(LUA_INIT)
+#define LUA_INIT		"LUA_INIT"
+#endif
+
+#define LUA_INITVERSION  \
+	LUA_INIT "_" LUA_VERSION_MAJOR "_" LUA_VERSION_MINOR
+
+
+/*
+** lua_stdin_is_tty detects whether the standard input is a 'tty' (that
+** is, whether we're running lua interactively).
+*/
+#if defined(LUA_USE_ISATTY)
+#include <unistd.h>
+#define lua_stdin_is_tty()	isatty(0)
+#elif defined(LUA_WIN)
+#include <io.h>
+#include <stdio.h>
+#define lua_stdin_is_tty()	_isatty(_fileno(stdin))
+#else
+#define lua_stdin_is_tty()	1  /* assume stdin is a tty */
+#endif
+
+
+/*
+** lua_readline defines how to show a prompt and then read a line from
+** the standard input.
+** lua_saveline defines how to "save" a read line in a "history".
+** lua_freeline defines how to free a line read by lua_readline.
+*/
+#if defined(LUA_USE_READLINE)
+
+#include <stdio.h>
+#include <readline/readline.h>
+#include <readline/history.h>
+#define lua_readline(L,b,p)	((void)L, ((b)=readline(p)) != NULL)
+#define lua_saveline(L,idx) \
+        if (lua_rawlen(L,idx) > 0)  /* non-empty line? */ \
+          add_history(lua_tostring(L, idx));  /* add it to history */
+#define lua_freeline(L,b)	((void)L, free(b))
+
+#elif !defined(lua_readline)
+
+#define lua_readline(L,b,p) \
+        ((void)L, fputs(p, stdout), fflush(stdout),  /* show prompt */ \
+        fgets(b, LUA_MAXINPUT, stdin) != NULL)  /* get line */
+#define lua_saveline(L,idx)	{ (void)L; (void)idx; }
+#define lua_freeline(L,b)	{ (void)L; (void)b; }
+
+#endif
+
+
+
+
+static lua_State *globalL = NULL;
+
+static const char *progname = LUA_PROGNAME;
+
+
+
+static void lstop (lua_State *L, lua_Debug *ar) {
+  (void)ar;  /* unused arg. */
+  lua_sethook(L, NULL, 0, 0);
+  luaL_error(L, "interrupted!");
+}
+
+
+static void laction (int i) {
+  signal(i, SIG_DFL); /* if another SIGINT happens before lstop,
+                              terminate process (default action) */
+  lua_sethook(globalL, lstop, LUA_MASKCALL | LUA_MASKRET | LUA_MASKCOUNT, 1);
+}
+
+
+static void print_usage (const char *badoption) {
+  luai_writestringerror("%s: ", progname);
+  if (badoption[1] == 'e' || badoption[1] == 'l')
+    luai_writestringerror("'%s' needs argument\n", badoption);
+  else
+    luai_writestringerror("unrecognized option '%s'\n", badoption);
+  luai_writestringerror(
+  "usage: %s [options] [script [args]]\n"
+  "Available options are:\n"
+  "  -e stat  execute string " LUA_QL("stat") "\n"
+  "  -i       enter interactive mode after executing " LUA_QL("script") "\n"
+  "  -l name  require library " LUA_QL("name") "\n"
+  "  -v       show version information\n"
+  "  -E       ignore environment variables\n"
+  "  --       stop handling options\n"
+  "  -        stop handling options and execute stdin\n"
+  ,
+  progname);
+}
+
+
+static void l_message (const char *pname, const char *msg) {
+  if (pname) luai_writestringerror("%s: ", pname);
+  luai_writestringerror("%s\n", msg);
+}
+
+
+static int report (lua_State *L, int status) {
+  if (status != LUA_OK && !lua_isnil(L, -1)) {
+    const char *msg = lua_tostring(L, -1);
+    if (msg == NULL) msg = "(error object is not a string)";
+    l_message(progname, msg);
+    lua_pop(L, 1);
+    /* force a complete garbage collection in case of errors */
+    lua_gc(L, LUA_GCCOLLECT, 0);
+  }
+  return status;
+}
+
+
+/* the next function is called unprotected, so it must avoid errors */
+static void finalreport (lua_State *L, int status) {
+  if (status != LUA_OK) {
+    const char *msg = (lua_type(L, -1) == LUA_TSTRING) ? lua_tostring(L, -1)
+                                                       : NULL;
+    if (msg == NULL) msg = "(error object is not a string)";
+    l_message(progname, msg);
+    lua_pop(L, 1);
+  }
+}
+
+
+static int traceback (lua_State *L) {
+  const char *msg = lua_tostring(L, 1);
+  if (msg)
+    luaL_traceback(L, L, msg, 1);
+  else if (!lua_isnoneornil(L, 1)) {  /* is there an error object? */
+    if (!luaL_callmeta(L, 1, "__tostring"))  /* try its 'tostring' metamethod */
+      lua_pushliteral(L, "(no error message)");
+  }
+  return 1;
+}
+
+
+static int docall (lua_State *L, int narg, int nres) {
+  int status;
+  int base = lua_gettop(L) - narg;  /* function index */
+  lua_pushcfunction(L, traceback);  /* push traceback function */
+  lua_insert(L, base);  /* put it under chunk and args */
+  globalL = L;  /* to be available to 'laction' */
+  signal(SIGINT, laction);
+  status = lua_pcall(L, narg, nres, base);
+  signal(SIGINT, SIG_DFL);
+  lua_remove(L, base);  /* remove traceback function */
+  return status;
+}
+
+
+static void print_version (void) {
+  luai_writestring(LUA_COPYRIGHT, strlen(LUA_COPYRIGHT));
+  luai_writeline();
+}
+
+
+static int getargs (lua_State *L, char **argv, int n) {
+  int narg;
+  int i;
+  int argc = 0;
+  while (argv[argc]) argc++;  /* count total number of arguments */
+  narg = argc - (n + 1);  /* number of arguments to the script */
+  luaL_checkstack(L, narg + 3, "too many arguments to script");
+  for (i=n+1; i < argc; i++)
+    lua_pushstring(L, argv[i]);
+  lua_createtable(L, narg, n + 1);
+  for (i=0; i < argc; i++) {
+    lua_pushstring(L, argv[i]);
+    lua_rawseti(L, -2, i - n);
+  }
+  return narg;
+}
+
+
+static int dofile (lua_State *L, const char *name) {
+  int status = luaL_loadfile(L, name);
+  if (status == LUA_OK) status = docall(L, 0, 0);
+  return report(L, status);
+}
+
+
+static int dostring (lua_State *L, const char *s, const char *name) {
+  int status = luaL_loadbuffer(L, s, strlen(s), name);
+  if (status == LUA_OK) status = docall(L, 0, 0);
+  return report(L, status);
+}
+
+
+static int dolibrary (lua_State *L, const char *name) {
+  int status;
+  lua_getglobal(L, "require");
+  lua_pushstring(L, name);
+  status = docall(L, 1, 1);  /* call 'require(name)' */
+  if (status == LUA_OK)
+    lua_setglobal(L, name);  /* global[name] = require return */
+  return report(L, status);
+}
+
+
+static const char *get_prompt (lua_State *L, int firstline) {
+  const char *p;
+  lua_getglobal(L, firstline ? "_PROMPT" : "_PROMPT2");
+  p = lua_tostring(L, -1);
+  if (p == NULL) p = (firstline ? LUA_PROMPT : LUA_PROMPT2);
+  return p;
+}
+
+/* mark in error messages for incomplete statements */
+#define EOFMARK		"<eof>"
+#define marklen		(sizeof(EOFMARK)/sizeof(char) - 1)
+
+static int incomplete (lua_State *L, int status) {
+  if (status == LUA_ERRSYNTAX) {
+    size_t lmsg;
+    const char *msg = lua_tolstring(L, -1, &lmsg);
+    if (lmsg >= marklen && strcmp(msg + lmsg - marklen, EOFMARK) == 0) {
+      lua_pop(L, 1);
+      return 1;
+    }
+  }
+  return 0;  /* else... */
+}
+
+
+static int pushline (lua_State *L, int firstline) {
+  char buffer[LUA_MAXINPUT];
+  char *b = buffer;
+  size_t l;
+  const char *prmt = get_prompt(L, firstline);
+  int readstatus = lua_readline(L, b, prmt);
+  lua_pop(L, 1);  /* remove result from 'get_prompt' */
+  if (readstatus == 0)
+    return 0;  /* no input */
+  l = strlen(b);
+  if (l > 0 && b[l-1] == '\n')  /* line ends with newline? */
+    b[l-1] = '\0';  /* remove it */
+  if (firstline && b[0] == '=')  /* first line starts with `=' ? */
+    lua_pushfstring(L, "return %s", b+1);  /* change it to `return' */
+  else
+    lua_pushstring(L, b);
+  lua_freeline(L, b);
+  return 1;
+}
+
+
+static int loadline (lua_State *L) {
+  int status;
+  lua_settop(L, 0);
+  if (!pushline(L, 1))
+    return -1;  /* no input */
+  for (;;) {  /* repeat until gets a complete line */
+    size_t l;
+    const char *line = lua_tolstring(L, 1, &l);
+    status = luaL_loadbuffer(L, line, l, "=stdin");
+    if (!incomplete(L, status)) break;  /* cannot try to add lines? */
+    if (!pushline(L, 0))  /* no more input? */
+      return -1;
+    lua_pushliteral(L, "\n");  /* add a new line... */
+    lua_insert(L, -2);  /* ...between the two lines */
+    lua_concat(L, 3);  /* join them */
+  }
+  lua_saveline(L, 1);
+  lua_remove(L, 1);  /* remove line */
+  return status;
+}
+
+
+static void dotty (lua_State *L) {
+  int status;
+  const char *oldprogname = progname;
+  progname = NULL;
+  while ((status = loadline(L)) != -1) {
+    if (status == LUA_OK) status = docall(L, 0, LUA_MULTRET);
+    report(L, status);
+    if (status == LUA_OK && lua_gettop(L) > 0) {  /* any result to print? */
+      luaL_checkstack(L, LUA_MINSTACK, "too many results to print");
+      lua_getglobal(L, "print");
+      lua_insert(L, 1);
+      if (lua_pcall(L, lua_gettop(L)-1, 0, 0) != LUA_OK)
+        l_message(progname, lua_pushfstring(L,
+                               "error calling " LUA_QL("print") " (%s)",
+                               lua_tostring(L, -1)));
+    }
+  }
+  lua_settop(L, 0);  /* clear stack */
+  luai_writeline();
+  progname = oldprogname;
+}
+
+
+static int handle_script (lua_State *L, char **argv, int n) {
+  int status;
+  const char *fname;
+  int narg = getargs(L, argv, n);  /* collect arguments */
+  lua_setglobal(L, "arg");
+  fname = argv[n];
+  if (strcmp(fname, "-") == 0 && strcmp(argv[n-1], "--") != 0)
+    fname = NULL;  /* stdin */
+  status = luaL_loadfile(L, fname);
+  lua_insert(L, -(narg+1));
+  if (status == LUA_OK)
+    status = docall(L, narg, LUA_MULTRET);
+  else
+    lua_pop(L, narg);
+  return report(L, status);
+}
+
+
+/* check that argument has no extra characters at the end */
+#define noextrachars(x)		{if ((x)[2] != '\0') return -1;}
+
+
+/* indices of various argument indicators in array args */
+#define has_i		0	/* -i */
+#define has_v		1	/* -v */
+#define has_e		2	/* -e */
+#define has_E		3	/* -E */
+
+#define num_has		4	/* number of 'has_*' */
+
+
+static int collectargs (char **argv, int *args) {
+  int i;
+  for (i = 1; argv[i] != NULL; i++) {
+    if (argv[i][0] != '-')  /* not an option? */
+        return i;
+    switch (argv[i][1]) {  /* option */
+      case '-':
+        noextrachars(argv[i]);
+        return (argv[i+1] != NULL ? i+1 : 0);
+      case '\0':
+        return i;
+      case 'E':
+        args[has_E] = 1;
+        break;
+      case 'i':
+        noextrachars(argv[i]);
+        args[has_i] = 1;  /* go through */
+      case 'v':
+        noextrachars(argv[i]);
+        args[has_v] = 1;
+        break;
+      case 'e':
+        args[has_e] = 1;  /* go through */
+      case 'l':  /* both options need an argument */
+        if (argv[i][2] == '\0') {  /* no concatenated argument? */
+          i++;  /* try next 'argv' */
+          if (argv[i] == NULL || argv[i][0] == '-')
+            return -(i - 1);  /* no next argument or it is another option */
+        }
+        break;
+      default:  /* invalid option; return its index... */
+        return -i;  /* ...as a negative value */
+    }
+  }
+  return 0;
+}
+
+
+static int runargs (lua_State *L, char **argv, int n) {
+  int i;
+  for (i = 1; i < n; i++) {
+    lua_assert(argv[i][0] == '-');
+    switch (argv[i][1]) {  /* option */
+      case 'e': {
+        const char *chunk = argv[i] + 2;
+        if (*chunk == '\0') chunk = argv[++i];
+        lua_assert(chunk != NULL);
+        if (dostring(L, chunk, "=(command line)") != LUA_OK)
+          return 0;
+        break;
+      }
+      case 'l': {
+        const char *filename = argv[i] + 2;
+        if (*filename == '\0') filename = argv[++i];
+        lua_assert(filename != NULL);
+        if (dolibrary(L, filename) != LUA_OK)
+          return 0;  /* stop if file fails */
+        break;
+      }
+      default: break;
+    }
+  }
+  return 1;
+}
+
+
+static int handle_luainit (lua_State *L) {
+  const char *name = "=" LUA_INITVERSION;
+  const char *init = getenv(name + 1);
+  if (init == NULL) {
+    name = "=" LUA_INIT;
+    init = getenv(name + 1);  /* try alternative name */
+  }
+  if (init == NULL) return LUA_OK;
+  else if (init[0] == '@')
+    return dofile(L, init+1);
+  else
+    return dostring(L, init, name);
+}
+
+
+static int pmain (lua_State *L) {
+  int argc = (int)lua_tointeger(L, 1);
+  char **argv = (char **)lua_touserdata(L, 2);
+  int script;
+  int args[num_has];
+  args[has_i] = args[has_v] = args[has_e] = args[has_E] = 0;
+  if (argv[0] && argv[0][0]) progname = argv[0];
+  script = collectargs(argv, args);
+  if (script < 0) {  /* invalid arg? */
+    print_usage(argv[-script]);
+    return 0;
+  }
+  if (args[has_v]) print_version();
+  if (args[has_E]) {  /* option '-E'? */
+    lua_pushboolean(L, 1);  /* signal for libraries to ignore env. vars. */
+    lua_setfield(L, LUA_REGISTRYINDEX, "LUA_NOENV");
+  }
+  /* open standard libraries */
+  luaL_checkversion(L);
+  lua_gc(L, LUA_GCSTOP, 0);  /* stop collector during initialization */
+  luaL_openlibs(L);  /* open libraries */
+  lua_gc(L, LUA_GCRESTART, 0);
+  if (!args[has_E] && handle_luainit(L) != LUA_OK)
+    return 0;  /* error running LUA_INIT */
+  /* execute arguments -e and -l */
+  if (!runargs(L, argv, (script > 0) ? script : argc)) return 0;
+  /* execute main script (if there is one) */
+  if (script && handle_script(L, argv, script) != LUA_OK) return 0;
+  if (args[has_i])  /* -i option? */
+    dotty(L);
+  else if (script == 0 && !args[has_e] && !args[has_v]) {  /* no arguments? */
+    if (lua_stdin_is_tty()) {
+      print_version();
+      dotty(L);
+    }
+    else dofile(L, NULL);  /* executes stdin as a file */
+  }
+  lua_pushboolean(L, 1);  /* signal no errors */
+  return 1;
+}
+
+
+int main (int argc, char **argv) {
+  int status, result;
+  lua_State *L = luaL_newstate();  /* create state */
+  if (L == NULL) {
+    l_message(argv[0], "cannot create state: not enough memory");
+    return EXIT_FAILURE;
+  }
+  /* call 'pmain' in protected mode */
+  lua_pushcfunction(L, &pmain);
+  lua_pushinteger(L, argc);  /* 1st argument */
+  lua_pushlightuserdata(L, argv); /* 2nd argument */
+  status = lua_pcall(L, 2, 1, 0);
+  result = lua_toboolean(L, -1);  /* get result */
+  finalreport(L, status);
+  lua_close(L);
+  return (result && status == LUA_OK) ? EXIT_SUCCESS : EXIT_FAILURE;
+}
+
diff -ruNp src.orig/libs/lua/lua.h src/libs/lua/lua.h
--- src.orig/libs/lua/lua.h	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lua.h	2017-11-21 19:39:46 -0600
@@ -0,0 +1,444 @@
+/*
+** $Id: lua.h,v 1.285 2013/03/15 13:04:22 roberto Exp $
+** Lua - A Scripting Language
+** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
+** See Copyright Notice at the end of this file
+*/
+
+
+#ifndef lua_h
+#define lua_h
+
+#include <stdarg.h>
+#include <stddef.h>
+
+
+#include "luaconf.h"
+
+
+#define LUA_VERSION_MAJOR	"5"
+#define LUA_VERSION_MINOR	"2"
+#define LUA_VERSION_NUM		502
+#define LUA_VERSION_RELEASE	"2"
+
+#define LUA_VERSION	"Lua " LUA_VERSION_MAJOR "." LUA_VERSION_MINOR
+#define LUA_RELEASE	LUA_VERSION "." LUA_VERSION_RELEASE
+#define LUA_COPYRIGHT	LUA_RELEASE "  Copyright (C) 1994-2013 Lua.org, PUC-Rio"
+#define LUA_AUTHORS	"R. Ierusalimschy, L. H. de Figueiredo, W. Celes"
+
+
+/* mark for precompiled code ('<esc>Lua') */
+#define LUA_SIGNATURE	"\033Lua"
+
+/* option for multiple returns in 'lua_pcall' and 'lua_call' */
+#define LUA_MULTRET	(-1)
+
+
+/*
+** pseudo-indices
+*/
+#define LUA_REGISTRYINDEX	LUAI_FIRSTPSEUDOIDX
+#define lua_upvalueindex(i)	(LUA_REGISTRYINDEX - (i))
+
+
+/* thread status */
+#define LUA_OK		0
+#define LUA_YIELD	1
+#define LUA_ERRRUN	2
+#define LUA_ERRSYNTAX	3
+#define LUA_ERRMEM	4
+#define LUA_ERRGCMM	5
+#define LUA_ERRERR	6
+
+
+typedef struct lua_State lua_State;
+
+typedef int (*lua_CFunction) (lua_State *L);
+
+
+/*
+** functions that read/write blocks when loading/dumping Lua chunks
+*/
+typedef const char * (*lua_Reader) (lua_State *L, void *ud, size_t *sz);
+
+typedef int (*lua_Writer) (lua_State *L, const void* p, size_t sz, void* ud);
+
+
+/*
+** prototype for memory-allocation functions
+*/
+typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);
+
+
+/*
+** basic types
+*/
+#define LUA_TNONE		(-1)
+
+#define LUA_TNIL		0
+#define LUA_TBOOLEAN		1
+#define LUA_TLIGHTUSERDATA	2
+#define LUA_TNUMBER		3
+#define LUA_TSTRING		4
+#define LUA_TTABLE		5
+#define LUA_TFUNCTION		6
+#define LUA_TUSERDATA		7
+#define LUA_TTHREAD		8
+
+#define LUA_NUMTAGS		9
+
+
+
+/* minimum Lua stack available to a C function */
+#define LUA_MINSTACK	20
+
+
+/* predefined values in the registry */
+#define LUA_RIDX_MAINTHREAD	1
+#define LUA_RIDX_GLOBALS	2
+#define LUA_RIDX_LAST		LUA_RIDX_GLOBALS
+
+
+/* type of numbers in Lua */
+typedef LUA_NUMBER lua_Number;
+
+
+/* type for integer functions */
+typedef LUA_INTEGER lua_Integer;
+
+/* unsigned integer type */
+typedef LUA_UNSIGNED lua_Unsigned;
+
+
+
+/*
+** generic extra include file
+*/
+#if defined(LUA_USER_H)
+#include LUA_USER_H
+#endif
+
+
+/*
+** RCS ident string
+*/
+extern const char lua_ident[];
+
+
+/*
+** state manipulation
+*/
+LUA_API lua_State *(lua_newstate) (lua_Alloc f, void *ud);
+LUA_API void       (lua_close) (lua_State *L);
+LUA_API lua_State *(lua_newthread) (lua_State *L);
+
+LUA_API lua_CFunction (lua_atpanic) (lua_State *L, lua_CFunction panicf);
+
+
+LUA_API const lua_Number *(lua_version) (lua_State *L);
+
+
+/*
+** basic stack manipulation
+*/
+LUA_API int   (lua_absindex) (lua_State *L, int idx);
+LUA_API int   (lua_gettop) (lua_State *L);
+LUA_API void  (lua_settop) (lua_State *L, int idx);
+LUA_API void  (lua_pushvalue) (lua_State *L, int idx);
+LUA_API void  (lua_remove) (lua_State *L, int idx);
+LUA_API void  (lua_insert) (lua_State *L, int idx);
+LUA_API void  (lua_replace) (lua_State *L, int idx);
+LUA_API void  (lua_copy) (lua_State *L, int fromidx, int toidx);
+LUA_API int   (lua_checkstack) (lua_State *L, int sz);
+
+LUA_API void  (lua_xmove) (lua_State *from, lua_State *to, int n);
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API int             (lua_isnumber) (lua_State *L, int idx);
+LUA_API int             (lua_isstring) (lua_State *L, int idx);
+LUA_API int             (lua_iscfunction) (lua_State *L, int idx);
+LUA_API int             (lua_isuserdata) (lua_State *L, int idx);
+LUA_API int             (lua_type) (lua_State *L, int idx);
+LUA_API const char     *(lua_typename) (lua_State *L, int tp);
+
+LUA_API lua_Number      (lua_tonumberx) (lua_State *L, int idx, int *isnum);
+LUA_API lua_Integer     (lua_tointegerx) (lua_State *L, int idx, int *isnum);
+LUA_API lua_Unsigned    (lua_tounsignedx) (lua_State *L, int idx, int *isnum);
+LUA_API int             (lua_toboolean) (lua_State *L, int idx);
+LUA_API const char     *(lua_tolstring) (lua_State *L, int idx, size_t *len);
+LUA_API size_t          (lua_rawlen) (lua_State *L, int idx);
+LUA_API lua_CFunction   (lua_tocfunction) (lua_State *L, int idx);
+LUA_API void	       *(lua_touserdata) (lua_State *L, int idx);
+LUA_API lua_State      *(lua_tothread) (lua_State *L, int idx);
+LUA_API const void     *(lua_topointer) (lua_State *L, int idx);
+
+
+/*
+** Comparison and arithmetic functions
+*/
+
+#define LUA_OPADD	0	/* ORDER TM */
+#define LUA_OPSUB	1
+#define LUA_OPMUL	2
+#define LUA_OPDIV	3
+#define LUA_OPMOD	4
+#define LUA_OPPOW	5
+#define LUA_OPUNM	6
+
+LUA_API void  (lua_arith) (lua_State *L, int op);
+
+#define LUA_OPEQ	0
+#define LUA_OPLT	1
+#define LUA_OPLE	2
+
+LUA_API int   (lua_rawequal) (lua_State *L, int idx1, int idx2);
+LUA_API int   (lua_compare) (lua_State *L, int idx1, int idx2, int op);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void        (lua_pushnil) (lua_State *L);
+LUA_API void        (lua_pushnumber) (lua_State *L, lua_Number n);
+LUA_API void        (lua_pushinteger) (lua_State *L, lua_Integer n);
+LUA_API void        (lua_pushunsigned) (lua_State *L, lua_Unsigned n);
+LUA_API const char *(lua_pushlstring) (lua_State *L, const char *s, size_t l);
+LUA_API const char *(lua_pushstring) (lua_State *L, const char *s);
+LUA_API const char *(lua_pushvfstring) (lua_State *L, const char *fmt,
+                                                      va_list argp);
+LUA_API const char *(lua_pushfstring) (lua_State *L, const char *fmt, ...);
+LUA_API void  (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n);
+LUA_API void  (lua_pushboolean) (lua_State *L, int b);
+LUA_API void  (lua_pushlightuserdata) (lua_State *L, void *p);
+LUA_API int   (lua_pushthread) (lua_State *L);
+
+
+/*
+** get functions (Lua -> stack)
+*/
+LUA_API void  (lua_getglobal) (lua_State *L, const char *var);
+LUA_API void  (lua_gettable) (lua_State *L, int idx);
+LUA_API void  (lua_getfield) (lua_State *L, int idx, const char *k);
+LUA_API void  (lua_rawget) (lua_State *L, int idx);
+LUA_API void  (lua_rawgeti) (lua_State *L, int idx, int n);
+LUA_API void  (lua_rawgetp) (lua_State *L, int idx, const void *p);
+LUA_API void  (lua_createtable) (lua_State *L, int narr, int nrec);
+LUA_API void *(lua_newuserdata) (lua_State *L, size_t sz);
+LUA_API int   (lua_getmetatable) (lua_State *L, int objindex);
+LUA_API void  (lua_getuservalue) (lua_State *L, int idx);
+
+
+/*
+** set functions (stack -> Lua)
+*/
+LUA_API void  (lua_setglobal) (lua_State *L, const char *var);
+LUA_API void  (lua_settable) (lua_State *L, int idx);
+LUA_API void  (lua_setfield) (lua_State *L, int idx, const char *k);
+LUA_API void  (lua_rawset) (lua_State *L, int idx);
+LUA_API void  (lua_rawseti) (lua_State *L, int idx, int n);
+LUA_API void  (lua_rawsetp) (lua_State *L, int idx, const void *p);
+LUA_API int   (lua_setmetatable) (lua_State *L, int objindex);
+LUA_API void  (lua_setuservalue) (lua_State *L, int idx);
+
+
+/*
+** 'load' and 'call' functions (load and run Lua code)
+*/
+LUA_API void  (lua_callk) (lua_State *L, int nargs, int nresults, int ctx,
+                           lua_CFunction k);
+#define lua_call(L,n,r)		lua_callk(L, (n), (r), 0, NULL)
+
+LUA_API int   (lua_getctx) (lua_State *L, int *ctx);
+
+LUA_API int   (lua_pcallk) (lua_State *L, int nargs, int nresults, int errfunc,
+                            int ctx, lua_CFunction k);
+#define lua_pcall(L,n,r,f)	lua_pcallk(L, (n), (r), (f), 0, NULL)
+
+LUA_API int   (lua_load) (lua_State *L, lua_Reader reader, void *dt,
+                                        const char *chunkname,
+                                        const char *mode);
+
+LUA_API int (lua_dump) (lua_State *L, lua_Writer writer, void *data);
+
+
+/*
+** coroutine functions
+*/
+LUA_API int  (lua_yieldk) (lua_State *L, int nresults, int ctx,
+                           lua_CFunction k);
+#define lua_yield(L,n)		lua_yieldk(L, (n), 0, NULL)
+LUA_API int  (lua_resume) (lua_State *L, lua_State *from, int narg);
+LUA_API int  (lua_status) (lua_State *L);
+
+/*
+** garbage-collection function and options
+*/
+
+#define LUA_GCSTOP		0
+#define LUA_GCRESTART		1
+#define LUA_GCCOLLECT		2
+#define LUA_GCCOUNT		3
+#define LUA_GCCOUNTB		4
+#define LUA_GCSTEP		5
+#define LUA_GCSETPAUSE		6
+#define LUA_GCSETSTEPMUL	7
+#define LUA_GCSETMAJORINC	8
+#define LUA_GCISRUNNING		9
+#define LUA_GCGEN		10
+#define LUA_GCINC		11
+
+LUA_API int (lua_gc) (lua_State *L, int what, int data);
+
+
+/*
+** miscellaneous functions
+*/
+
+LUA_API int   (lua_error) (lua_State *L);
+
+LUA_API int   (lua_next) (lua_State *L, int idx);
+
+LUA_API void  (lua_concat) (lua_State *L, int n);
+LUA_API void  (lua_len)    (lua_State *L, int idx);
+
+LUA_API lua_Alloc (lua_getallocf) (lua_State *L, void **ud);
+LUA_API void      (lua_setallocf) (lua_State *L, lua_Alloc f, void *ud);
+
+
+
+/*
+** ===============================================================
+** some useful macros
+** ===============================================================
+*/
+
+#define lua_tonumber(L,i)	lua_tonumberx(L,i,NULL)
+#define lua_tointeger(L,i)	lua_tointegerx(L,i,NULL)
+#define lua_tounsigned(L,i)	lua_tounsignedx(L,i,NULL)
+
+#define lua_pop(L,n)		lua_settop(L, -(n)-1)
+
+#define lua_newtable(L)		lua_createtable(L, 0, 0)
+
+#define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))
+
+#define lua_pushcfunction(L,f)	lua_pushcclosure(L, (f), 0)
+
+#define lua_isfunction(L,n)	(lua_type(L, (n)) == LUA_TFUNCTION)
+#define lua_istable(L,n)	(lua_type(L, (n)) == LUA_TTABLE)
+#define lua_islightuserdata(L,n)	(lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
+#define lua_isnil(L,n)		(lua_type(L, (n)) == LUA_TNIL)
+#define lua_isboolean(L,n)	(lua_type(L, (n)) == LUA_TBOOLEAN)
+#define lua_isthread(L,n)	(lua_type(L, (n)) == LUA_TTHREAD)
+#define lua_isnone(L,n)		(lua_type(L, (n)) == LUA_TNONE)
+#define lua_isnoneornil(L, n)	(lua_type(L, (n)) <= 0)
+
+#define lua_pushliteral(L, s)	\
+	lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
+
+#define lua_pushglobaltable(L)  \
+	lua_rawgeti(L, LUA_REGISTRYINDEX, LUA_RIDX_GLOBALS)
+
+#define lua_tostring(L,i)	lua_tolstring(L, (i), NULL)
+
+
+
+/*
+** {======================================================================
+** Debug API
+** =======================================================================
+*/
+
+
+/*
+** Event codes
+*/
+#define LUA_HOOKCALL	0
+#define LUA_HOOKRET	1
+#define LUA_HOOKLINE	2
+#define LUA_HOOKCOUNT	3
+#define LUA_HOOKTAILCALL 4
+
+
+/*
+** Event masks
+*/
+#define LUA_MASKCALL	(1 << LUA_HOOKCALL)
+#define LUA_MASKRET	(1 << LUA_HOOKRET)
+#define LUA_MASKLINE	(1 << LUA_HOOKLINE)
+#define LUA_MASKCOUNT	(1 << LUA_HOOKCOUNT)
+
+typedef struct lua_Debug lua_Debug;  /* activation record */
+
+
+/* Functions to be called by the debugger in specific events */
+typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);
+
+
+LUA_API int (lua_getstack) (lua_State *L, int level, lua_Debug *ar);
+LUA_API int (lua_getinfo) (lua_State *L, const char *what, lua_Debug *ar);
+LUA_API const char *(lua_getlocal) (lua_State *L, const lua_Debug *ar, int n);
+LUA_API const char *(lua_setlocal) (lua_State *L, const lua_Debug *ar, int n);
+LUA_API const char *(lua_getupvalue) (lua_State *L, int funcindex, int n);
+LUA_API const char *(lua_setupvalue) (lua_State *L, int funcindex, int n);
+
+LUA_API void *(lua_upvalueid) (lua_State *L, int fidx, int n);
+LUA_API void  (lua_upvaluejoin) (lua_State *L, int fidx1, int n1,
+                                               int fidx2, int n2);
+
+LUA_API int (lua_sethook) (lua_State *L, lua_Hook func, int mask, int count);
+LUA_API lua_Hook (lua_gethook) (lua_State *L);
+LUA_API int (lua_gethookmask) (lua_State *L);
+LUA_API int (lua_gethookcount) (lua_State *L);
+
+
+struct lua_Debug {
+  int event;
+  const char *name;	/* (n) */
+  const char *namewhat;	/* (n) 'global', 'local', 'field', 'method' */
+  const char *what;	/* (S) 'Lua', 'C', 'main', 'tail' */
+  const char *source;	/* (S) */
+  int currentline;	/* (l) */
+  int linedefined;	/* (S) */
+  int lastlinedefined;	/* (S) */
+  unsigned char nups;	/* (u) number of upvalues */
+  unsigned char nparams;/* (u) number of parameters */
+  char isvararg;        /* (u) */
+  char istailcall;	/* (t) */
+  char short_src[LUA_IDSIZE]; /* (S) */
+  /* private part */
+  struct CallInfo *i_ci;  /* active function */
+};
+
+/* }====================================================================== */
+
+
+/******************************************************************************
+* Copyright (C) 1994-2013 Lua.org, PUC-Rio.
+*
+* Permission is hereby granted, free of charge, to any person obtaining
+* a copy of this software and associated documentation files (the
+* "Software"), to deal in the Software without restriction, including
+* without limitation the rights to use, copy, modify, merge, publish,
+* distribute, sublicense, and/or sell copies of the Software, and to
+* permit persons to whom the Software is furnished to do so, subject to
+* the following conditions:
+*
+* The above copyright notice and this permission notice shall be
+* included in all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+******************************************************************************/
+
+
+#endif
diff -ruNp src.orig/libs/lua/lua.hpp src/libs/lua/lua.hpp
--- src.orig/libs/lua/lua.hpp	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lua.hpp	2017-11-21 19:39:46 -0600
@@ -0,0 +1,9 @@
+// lua.hpp
+// Lua header files for C++
+// <<extern "C">> not supplied automatically because Lua also compiles as C++
+
+extern "C" {
+#include "lua.h"
+#include "lualib.h"
+#include "lauxlib.h"
+}
diff -ruNp src.orig/libs/lua/luac.c src/libs/lua/luac.c
--- src.orig/libs/lua/luac.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/luac.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,432 @@
+/*
+** $Id: luac.c,v 1.69 2011/11/29 17:46:33 lhf Exp $
+** Lua compiler (saves bytecodes to files; also list bytecodes)
+** See Copyright Notice in lua.h
+*/
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define luac_c
+#define LUA_CORE
+
+#include "lua.h"
+#include "lauxlib.h"
+
+#include "lobject.h"
+#include "lstate.h"
+#include "lundump.h"
+
+static void PrintFunction(const Proto* f, int full);
+#define luaU_print	PrintFunction
+
+#define PROGNAME	"luac"		/* default program name */
+#define OUTPUT		PROGNAME ".out"	/* default output file */
+
+static int listing=0;			/* list bytecodes? */
+static int dumping=1;			/* dump bytecodes? */
+static int stripping=0;			/* strip debug information? */
+static char Output[]={ OUTPUT };	/* default output file name */
+static const char* output=Output;	/* actual output file name */
+static const char* progname=PROGNAME;	/* actual program name */
+
+static void fatal(const char* message)
+{
+ fprintf(stderr,"%s: %s\n",progname,message);
+ exit(EXIT_FAILURE);
+}
+
+static void cannot(const char* what)
+{
+ fprintf(stderr,"%s: cannot %s %s: %s\n",progname,what,output,strerror(errno));
+ exit(EXIT_FAILURE);
+}
+
+static void usage(const char* message)
+{
+ if (*message=='-')
+  fprintf(stderr,"%s: unrecognized option " LUA_QS "\n",progname,message);
+ else
+  fprintf(stderr,"%s: %s\n",progname,message);
+ fprintf(stderr,
+  "usage: %s [options] [filenames]\n"
+  "Available options are:\n"
+  "  -l       list (use -l -l for full listing)\n"
+  "  -o name  output to file " LUA_QL("name") " (default is \"%s\")\n"
+  "  -p       parse only\n"
+  "  -s       strip debug information\n"
+  "  -v       show version information\n"
+  "  --       stop handling options\n"
+  "  -        stop handling options and process stdin\n"
+  ,progname,Output);
+ exit(EXIT_FAILURE);
+}
+
+#define IS(s)	(strcmp(argv[i],s)==0)
+
+static int doargs(int argc, char* argv[])
+{
+ int i;
+ int version=0;
+ if (argv[0]!=NULL && *argv[0]!=0) progname=argv[0];
+ for (i=1; i<argc; i++)
+ {
+  if (*argv[i]!='-')			/* end of options; keep it */
+   break;
+  else if (IS("--"))			/* end of options; skip it */
+  {
+   ++i;
+   if (version) ++version;
+   break;
+  }
+  else if (IS("-"))			/* end of options; use stdin */
+   break;
+  else if (IS("-l"))			/* list */
+   ++listing;
+  else if (IS("-o"))			/* output file */
+  {
+   output=argv[++i];
+   if (output==NULL || *output==0 || (*output=='-' && output[1]!=0))
+    usage(LUA_QL("-o") " needs argument");
+   if (IS("-")) output=NULL;
+  }
+  else if (IS("-p"))			/* parse only */
+   dumping=0;
+  else if (IS("-s"))			/* strip debug information */
+   stripping=1;
+  else if (IS("-v"))			/* show version */
+   ++version;
+  else					/* unknown option */
+   usage(argv[i]);
+ }
+ if (i==argc && (listing || !dumping))
+ {
+  dumping=0;
+  argv[--i]=Output;
+ }
+ if (version)
+ {
+  printf("%s\n",LUA_COPYRIGHT);
+  if (version==argc-1) exit(EXIT_SUCCESS);
+ }
+ return i;
+}
+
+#define FUNCTION "(function()end)();"
+
+static const char* reader(lua_State *L, void *ud, size_t *size)
+{
+ UNUSED(L);
+ if ((*(int*)ud)--)
+ {
+  *size=sizeof(FUNCTION)-1;
+  return FUNCTION;
+ }
+ else
+ {
+  *size=0;
+  return NULL;
+ }
+}
+
+#define toproto(L,i) getproto(L->top+(i))
+
+static const Proto* combine(lua_State* L, int n)
+{
+ if (n==1)
+  return toproto(L,-1);
+ else
+ {
+  Proto* f;
+  int i=n;
+  if (lua_load(L,reader,&i,"=(" PROGNAME ")",NULL)!=LUA_OK) fatal(lua_tostring(L,-1));
+  f=toproto(L,-1);
+  for (i=0; i<n; i++)
+  {
+   f->p[i]=toproto(L,i-n-1);
+   if (f->p[i]->sizeupvalues>0) f->p[i]->upvalues[0].instack=0;
+  }
+  f->sizelineinfo=0;
+  return f;
+ }
+}
+
+static int writer(lua_State* L, const void* p, size_t size, void* u)
+{
+ UNUSED(L);
+ return (fwrite(p,size,1,(FILE*)u)!=1) && (size!=0);
+}
+
+static int pmain(lua_State* L)
+{
+ int argc=(int)lua_tointeger(L,1);
+ char** argv=(char**)lua_touserdata(L,2);
+ const Proto* f;
+ int i;
+ if (!lua_checkstack(L,argc)) fatal("too many input files");
+ for (i=0; i<argc; i++)
+ {
+  const char* filename=IS("-") ? NULL : argv[i];
+  if (luaL_loadfile(L,filename)!=LUA_OK) fatal(lua_tostring(L,-1));
+ }
+ f=combine(L,argc);
+ if (listing) luaU_print(f,listing>1);
+ if (dumping)
+ {
+  FILE* D= (output==NULL) ? stdout : fopen(output,"wb");
+  if (D==NULL) cannot("open");
+  lua_lock(L);
+  luaU_dump(L,f,writer,D,stripping);
+  lua_unlock(L);
+  if (ferror(D)) cannot("write");
+  if (fclose(D)) cannot("close");
+ }
+ return 0;
+}
+
+int main(int argc, char* argv[])
+{
+ lua_State* L;
+ int i=doargs(argc,argv);
+ argc-=i; argv+=i;
+ if (argc<=0) usage("no input files given");
+ L=luaL_newstate();
+ if (L==NULL) fatal("cannot create state: not enough memory");
+ lua_pushcfunction(L,&pmain);
+ lua_pushinteger(L,argc);
+ lua_pushlightuserdata(L,argv);
+ if (lua_pcall(L,2,0,0)!=LUA_OK) fatal(lua_tostring(L,-1));
+ lua_close(L);
+ return EXIT_SUCCESS;
+}
+
+/*
+** $Id: print.c,v 1.68 2011/09/30 10:21:20 lhf Exp $
+** print bytecodes
+** See Copyright Notice in lua.h
+*/
+
+#include <ctype.h>
+#include <stdio.h>
+
+#define luac_c
+#define LUA_CORE
+
+#include "ldebug.h"
+#include "lobject.h"
+#include "lopcodes.h"
+
+#define VOID(p)		((const void*)(p))
+
+static void PrintString(const TString* ts)
+{
+ const char* s=getstr(ts);
+ size_t i,n=ts->tsv.len;
+ printf("%c",'"');
+ for (i=0; i<n; i++)
+ {
+  int c=(int)(unsigned char)s[i];
+  switch (c)
+  {
+   case '"':  printf("\\\""); break;
+   case '\\': printf("\\\\"); break;
+   case '\a': printf("\\a"); break;
+   case '\b': printf("\\b"); break;
+   case '\f': printf("\\f"); break;
+   case '\n': printf("\\n"); break;
+   case '\r': printf("\\r"); break;
+   case '\t': printf("\\t"); break;
+   case '\v': printf("\\v"); break;
+   default:	if (isprint(c))
+   			printf("%c",c);
+		else
+			printf("\\%03d",c);
+  }
+ }
+ printf("%c",'"');
+}
+
+static void PrintConstant(const Proto* f, int i)
+{
+ const TValue* o=&f->k[i];
+ switch (ttype(o))
+ {
+  case LUA_TNIL:
+	printf("nil");
+	break;
+  case LUA_TBOOLEAN:
+	printf(bvalue(o) ? "true" : "false");
+	break;
+  case LUA_TNUMBER:
+	printf(LUA_NUMBER_FMT,nvalue(o));
+	break;
+  case LUA_TSTRING:
+	PrintString(rawtsvalue(o));
+	break;
+  default:				/* cannot happen */
+	printf("? type=%d",ttype(o));
+	break;
+ }
+}
+
+#define UPVALNAME(x) ((f->upvalues[x].name) ? getstr(f->upvalues[x].name) : "-")
+#define MYK(x)		(-1-(x))
+
+static void PrintCode(const Proto* f)
+{
+ const Instruction* code=f->code;
+ int pc,n=f->sizecode;
+ for (pc=0; pc<n; pc++)
+ {
+  Instruction i=code[pc];
+  OpCode o=GET_OPCODE(i);
+  int a=GETARG_A(i);
+  int b=GETARG_B(i);
+  int c=GETARG_C(i);
+  int ax=GETARG_Ax(i);
+  int bx=GETARG_Bx(i);
+  int sbx=GETARG_sBx(i);
+  int line=getfuncline(f,pc);
+  printf("\t%d\t",pc+1);
+  if (line>0) printf("[%d]\t",line); else printf("[-]\t");
+  printf("%-9s\t",luaP_opnames[o]);
+  switch (getOpMode(o))
+  {
+   case iABC:
+    printf("%d",a);
+    if (getBMode(o)!=OpArgN) printf(" %d",ISK(b) ? (MYK(INDEXK(b))) : b);
+    if (getCMode(o)!=OpArgN) printf(" %d",ISK(c) ? (MYK(INDEXK(c))) : c);
+    break;
+   case iABx:
+    printf("%d",a);
+    if (getBMode(o)==OpArgK) printf(" %d",MYK(bx));
+    if (getBMode(o)==OpArgU) printf(" %d",bx);
+    break;
+   case iAsBx:
+    printf("%d %d",a,sbx);
+    break;
+   case iAx:
+    printf("%d",MYK(ax));
+    break;
+  }
+  switch (o)
+  {
+   case OP_LOADK:
+    printf("\t; "); PrintConstant(f,bx);
+    break;
+   case OP_GETUPVAL:
+   case OP_SETUPVAL:
+    printf("\t; %s",UPVALNAME(b));
+    break;
+   case OP_GETTABUP:
+    printf("\t; %s",UPVALNAME(b));
+    if (ISK(c)) { printf(" "); PrintConstant(f,INDEXK(c)); }
+    break;
+   case OP_SETTABUP:
+    printf("\t; %s",UPVALNAME(a));
+    if (ISK(b)) { printf(" "); PrintConstant(f,INDEXK(b)); }
+    if (ISK(c)) { printf(" "); PrintConstant(f,INDEXK(c)); }
+    break;
+   case OP_GETTABLE:
+   case OP_SELF:
+    if (ISK(c)) { printf("\t; "); PrintConstant(f,INDEXK(c)); }
+    break;
+   case OP_SETTABLE:
+   case OP_ADD:
+   case OP_SUB:
+   case OP_MUL:
+   case OP_DIV:
+   case OP_POW:
+   case OP_EQ:
+   case OP_LT:
+   case OP_LE:
+    if (ISK(b) || ISK(c))
+    {
+     printf("\t; ");
+     if (ISK(b)) PrintConstant(f,INDEXK(b)); else printf("-");
+     printf(" ");
+     if (ISK(c)) PrintConstant(f,INDEXK(c)); else printf("-");
+    }
+    break;
+   case OP_JMP:
+   case OP_FORLOOP:
+   case OP_FORPREP:
+   case OP_TFORLOOP:
+    printf("\t; to %d",sbx+pc+2);
+    break;
+   case OP_CLOSURE:
+    printf("\t; %p",VOID(f->p[bx]));
+    break;
+   case OP_SETLIST:
+    if (c==0) printf("\t; %d",(int)code[++pc]); else printf("\t; %d",c);
+    break;
+   case OP_EXTRAARG:
+    printf("\t; "); PrintConstant(f,ax);
+    break;
+   default:
+    break;
+  }
+  printf("\n");
+ }
+}
+
+#define SS(x)	((x==1)?"":"s")
+#define S(x)	(int)(x),SS(x)
+
+static void PrintHeader(const Proto* f)
+{
+ const char* s=f->source ? getstr(f->source) : "=?";
+ if (*s=='@' || *s=='=')
+  s++;
+ else if (*s==LUA_SIGNATURE[0])
+  s="(bstring)";
+ else
+  s="(string)";
+ printf("\n%s <%s:%d,%d> (%d instruction%s at %p)\n",
+ 	(f->linedefined==0)?"main":"function",s,
+	f->linedefined,f->lastlinedefined,
+	S(f->sizecode),VOID(f));
+ printf("%d%s param%s, %d slot%s, %d upvalue%s, ",
+	(int)(f->numparams),f->is_vararg?"+":"",SS(f->numparams),
+	S(f->maxstacksize),S(f->sizeupvalues));
+ printf("%d local%s, %d constant%s, %d function%s\n",
+	S(f->sizelocvars),S(f->sizek),S(f->sizep));
+}
+
+static void PrintDebug(const Proto* f)
+{
+ int i,n;
+ n=f->sizek;
+ printf("constants (%d) for %p:\n",n,VOID(f));
+ for (i=0; i<n; i++)
+ {
+  printf("\t%d\t",i+1);
+  PrintConstant(f,i);
+  printf("\n");
+ }
+ n=f->sizelocvars;
+ printf("locals (%d) for %p:\n",n,VOID(f));
+ for (i=0; i<n; i++)
+ {
+  printf("\t%d\t%s\t%d\t%d\n",
+  i,getstr(f->locvars[i].varname),f->locvars[i].startpc+1,f->locvars[i].endpc+1);
+ }
+ n=f->sizeupvalues;
+ printf("upvalues (%d) for %p:\n",n,VOID(f));
+ for (i=0; i<n; i++)
+ {
+  printf("\t%d\t%s\t%d\t%d\n",
+  i,UPVALNAME(i),f->upvalues[i].instack,f->upvalues[i].idx);
+ }
+}
+
+static void PrintFunction(const Proto* f, int full)
+{
+ int i,n=f->sizep;
+ PrintHeader(f);
+ PrintCode(f);
+ if (full) PrintDebug(f);
+ for (i=0; i<n; i++) PrintFunction(f->p[i],full);
+}
diff -ruNp src.orig/libs/lua/luaconf.h src/libs/lua/luaconf.h
--- src.orig/libs/lua/luaconf.h	1969-12-31 18:00:00 -0600
+++ src/libs/lua/luaconf.h	2017-11-21 19:39:46 -0600
@@ -0,0 +1,551 @@
+/*
+** $Id: luaconf.h,v 1.176 2013/03/16 21:10:18 roberto Exp $
+** Configuration file for Lua
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lconfig_h
+#define lconfig_h
+
+#include <limits.h>
+#include <stddef.h>
+
+
+/*
+** ==================================================================
+** Search for "@@" to find all configurable definitions.
+** ===================================================================
+*/
+
+
+/*
+@@ LUA_ANSI controls the use of non-ansi features.
+** CHANGE it (define it) if you want Lua to avoid the use of any
+** non-ansi feature or library.
+*/
+#if !defined(LUA_ANSI) && defined(__STRICT_ANSI__)
+#define LUA_ANSI
+#endif
+
+
+#if !defined(LUA_ANSI) && defined(_WIN32) && !defined(_WIN32_WCE)
+#define LUA_WIN		/* enable goodies for regular Windows platforms */
+#endif
+
+#if defined(LUA_WIN)
+#define LUA_DL_DLL
+#define LUA_USE_AFORMAT		/* assume 'printf' handles 'aA' specifiers */
+#endif
+
+
+
+#if defined(LUA_USE_LINUX)
+#define LUA_USE_POSIX
+#define LUA_USE_DLOPEN		/* needs an extra library: -ldl */
+#define LUA_USE_READLINE	/* needs some extra libraries */
+#define LUA_USE_STRTODHEX	/* assume 'strtod' handles hex formats */
+#define LUA_USE_AFORMAT		/* assume 'printf' handles 'aA' specifiers */
+#define LUA_USE_LONGLONG	/* assume support for long long */
+#endif
+
+#if defined(LUA_USE_MACOSX)
+#define LUA_USE_POSIX
+#define LUA_USE_DLOPEN		/* does not need -ldl */
+#define LUA_USE_READLINE	/* needs an extra library: -lreadline */
+#define LUA_USE_STRTODHEX	/* assume 'strtod' handles hex formats */
+#define LUA_USE_AFORMAT		/* assume 'printf' handles 'aA' specifiers */
+#define LUA_USE_LONGLONG	/* assume support for long long */
+#endif
+
+
+
+/*
+@@ LUA_USE_POSIX includes all functionality listed as X/Open System
+@* Interfaces Extension (XSI).
+** CHANGE it (define it) if your system is XSI compatible.
+*/
+#if defined(LUA_USE_POSIX)
+#define LUA_USE_MKSTEMP
+#define LUA_USE_ISATTY
+#define LUA_USE_POPEN
+#define LUA_USE_ULONGJMP
+#define LUA_USE_GMTIME_R
+#endif
+
+
+
+/*
+@@ LUA_PATH_DEFAULT is the default path that Lua uses to look for
+@* Lua libraries.
+@@ LUA_CPATH_DEFAULT is the default path that Lua uses to look for
+@* C libraries.
+** CHANGE them if your machine has a non-conventional directory
+** hierarchy or if you want to install your libraries in
+** non-conventional directories.
+*/
+#if defined(_WIN32)	/* { */
+/*
+** In Windows, any exclamation mark ('!') in the path is replaced by the
+** path of the directory of the executable file of the current process.
+*/
+#define LUA_LDIR	"!\\lua\\"
+#define LUA_CDIR	"!\\"
+#define LUA_PATH_DEFAULT  \
+		LUA_LDIR"?.lua;"  LUA_LDIR"?\\init.lua;" \
+		LUA_CDIR"?.lua;"  LUA_CDIR"?\\init.lua;" ".\\?.lua"
+#define LUA_CPATH_DEFAULT \
+		LUA_CDIR"?.dll;" LUA_CDIR"loadall.dll;" ".\\?.dll"
+
+#else			/* }{ */
+
+#define LUA_VDIR	LUA_VERSION_MAJOR "." LUA_VERSION_MINOR "/"
+#define LUA_ROOT	"/usr/local/"
+#define LUA_LDIR	LUA_ROOT "share/lua/" LUA_VDIR
+#define LUA_CDIR	LUA_ROOT "lib/lua/" LUA_VDIR
+#define LUA_PATH_DEFAULT  \
+		LUA_LDIR"?.lua;"  LUA_LDIR"?/init.lua;" \
+		LUA_CDIR"?.lua;"  LUA_CDIR"?/init.lua;" "./?.lua"
+#define LUA_CPATH_DEFAULT \
+		LUA_CDIR"?.so;" LUA_CDIR"loadall.so;" "./?.so"
+#endif			/* } */
+
+
+/*
+@@ LUA_DIRSEP is the directory separator (for submodules).
+** CHANGE it if your machine does not use "/" as the directory separator
+** and is not Windows. (On Windows Lua automatically uses "\".)
+*/
+#if defined(_WIN32)
+#define LUA_DIRSEP	"\\"
+#else
+#define LUA_DIRSEP	"/"
+#endif
+
+
+/*
+@@ LUA_ENV is the name of the variable that holds the current
+@@ environment, used to access global names.
+** CHANGE it if you do not like this name.
+*/
+#define LUA_ENV		"_ENV"
+
+
+/*
+@@ LUA_API is a mark for all core API functions.
+@@ LUALIB_API is a mark for all auxiliary library functions.
+@@ LUAMOD_API is a mark for all standard library opening functions.
+** CHANGE them if you need to define those functions in some special way.
+** For instance, if you want to create one Windows DLL with the core and
+** the libraries, you may want to use the following definition (define
+** LUA_BUILD_AS_DLL to get it).
+*/
+#if defined(LUA_BUILD_AS_DLL)	/* { */
+
+#if defined(LUA_CORE) || defined(LUA_LIB)	/* { */
+#define LUA_API __declspec(dllexport)
+#else						/* }{ */
+#define LUA_API __declspec(dllimport)
+#endif						/* } */
+
+#else				/* }{ */
+
+#define LUA_API		extern
+
+#endif				/* } */
+
+
+/* more often than not the libs go together with the core */
+#define LUALIB_API	LUA_API
+#define LUAMOD_API	LUALIB_API
+
+
+/*
+@@ LUAI_FUNC is a mark for all extern functions that are not to be
+@* exported to outside modules.
+@@ LUAI_DDEF and LUAI_DDEC are marks for all extern (const) variables
+@* that are not to be exported to outside modules (LUAI_DDEF for
+@* definitions and LUAI_DDEC for declarations).
+** CHANGE them if you need to mark them in some special way. Elf/gcc
+** (versions 3.2 and later) mark them as "hidden" to optimize access
+** when Lua is compiled as a shared library. Not all elf targets support
+** this attribute. Unfortunately, gcc does not offer a way to check
+** whether the target offers that support, and those without support
+** give a warning about it. To avoid these warnings, change to the
+** default definition.
+*/
+#if defined(__GNUC__) && ((__GNUC__*100 + __GNUC_MINOR__) >= 302) && \
+    defined(__ELF__)		/* { */
+#define LUAI_FUNC	__attribute__((visibility("hidden"))) extern
+#define LUAI_DDEC	LUAI_FUNC
+#define LUAI_DDEF	/* empty */
+
+#else				/* }{ */
+#define LUAI_FUNC	extern
+#define LUAI_DDEC	extern
+#define LUAI_DDEF	/* empty */
+#endif				/* } */
+
+
+
+/*
+@@ LUA_QL describes how error messages quote program elements.
+** CHANGE it if you want a different appearance.
+*/
+#define LUA_QL(x)	"'" x "'"
+#define LUA_QS		LUA_QL("%s")
+
+
+/*
+@@ LUA_IDSIZE gives the maximum size for the description of the source
+@* of a function in debug information.
+** CHANGE it if you want a different size.
+*/
+#define LUA_IDSIZE	60
+
+
+/*
+@@ luai_writestring/luai_writeline define how 'print' prints its results.
+** They are only used in libraries and the stand-alone program. (The #if
+** avoids including 'stdio.h' everywhere.)
+*/
+#if defined(LUA_LIB) || defined(lua_c)
+#include <stdio.h>
+#define luai_writestring(s,l)	fwrite((s), sizeof(char), (l), stdout)
+#define luai_writeline()	(luai_writestring("\n", 1), fflush(stdout))
+#endif
+
+/*
+@@ luai_writestringerror defines how to print error messages.
+** (A format string with one argument is enough for Lua...)
+*/
+#define luai_writestringerror(s,p) \
+	(fprintf(stderr, (s), (p)), fflush(stderr))
+
+
+/*
+@@ LUAI_MAXSHORTLEN is the maximum length for short strings, that is,
+** strings that are internalized. (Cannot be smaller than reserved words
+** or tags for metamethods, as these strings must be internalized;
+** #("function") = 8, #("__newindex") = 10.)
+*/
+#define LUAI_MAXSHORTLEN        40
+
+
+
+/*
+** {==================================================================
+** Compatibility with previous versions
+** ===================================================================
+*/
+
+/*
+@@ LUA_COMPAT_ALL controls all compatibility options.
+** You can define it to get all options, or change specific options
+** to fit your specific needs.
+*/
+#if defined(LUA_COMPAT_ALL)	/* { */
+
+/*
+@@ LUA_COMPAT_UNPACK controls the presence of global 'unpack'.
+** You can replace it with 'table.unpack'.
+*/
+#define LUA_COMPAT_UNPACK
+
+/*
+@@ LUA_COMPAT_LOADERS controls the presence of table 'package.loaders'.
+** You can replace it with 'package.searchers'.
+*/
+#define LUA_COMPAT_LOADERS
+
+/*
+@@ macro 'lua_cpcall' emulates deprecated function lua_cpcall.
+** You can call your C function directly (with light C functions).
+*/
+#define lua_cpcall(L,f,u)  \
+	(lua_pushcfunction(L, (f)), \
+	 lua_pushlightuserdata(L,(u)), \
+	 lua_pcall(L,1,0,0))
+
+
+/*
+@@ LUA_COMPAT_LOG10 defines the function 'log10' in the math library.
+** You can rewrite 'log10(x)' as 'log(x, 10)'.
+*/
+#define LUA_COMPAT_LOG10
+
+/*
+@@ LUA_COMPAT_LOADSTRING defines the function 'loadstring' in the base
+** library. You can rewrite 'loadstring(s)' as 'load(s)'.
+*/
+#define LUA_COMPAT_LOADSTRING
+
+/*
+@@ LUA_COMPAT_MAXN defines the function 'maxn' in the table library.
+*/
+#define LUA_COMPAT_MAXN
+
+/*
+@@ The following macros supply trivial compatibility for some
+** changes in the API. The macros themselves document how to
+** change your code to avoid using them.
+*/
+#define lua_strlen(L,i)		lua_rawlen(L, (i))
+
+#define lua_objlen(L,i)		lua_rawlen(L, (i))
+
+#define lua_equal(L,idx1,idx2)		lua_compare(L,(idx1),(idx2),LUA_OPEQ)
+#define lua_lessthan(L,idx1,idx2)	lua_compare(L,(idx1),(idx2),LUA_OPLT)
+
+/*
+@@ LUA_COMPAT_MODULE controls compatibility with previous
+** module functions 'module' (Lua) and 'luaL_register' (C).
+*/
+#define LUA_COMPAT_MODULE
+
+#endif				/* } */
+
+/* }================================================================== */
+
+
+
+/*
+@@ LUAI_BITSINT defines the number of bits in an int.
+** CHANGE here if Lua cannot automatically detect the number of bits of
+** your machine. Probably you do not need to change this.
+*/
+/* avoid overflows in comparison */
+#if INT_MAX-20 < 32760		/* { */
+#define LUAI_BITSINT	16
+#elif INT_MAX > 2147483640L	/* }{ */
+/* int has at least 32 bits */
+#define LUAI_BITSINT	32
+#else				/* }{ */
+#error "you must define LUA_BITSINT with number of bits in an integer"
+#endif				/* } */
+
+
+/*
+@@ LUA_INT32 is an signed integer with exactly 32 bits.
+@@ LUAI_UMEM is an unsigned integer big enough to count the total
+@* memory used by Lua.
+@@ LUAI_MEM is a signed integer big enough to count the total memory
+@* used by Lua.
+** CHANGE here if for some weird reason the default definitions are not
+** good enough for your machine. Probably you do not need to change
+** this.
+*/
+#if LUAI_BITSINT >= 32		/* { */
+#define LUA_INT32	int
+#define LUAI_UMEM	size_t
+#define LUAI_MEM	ptrdiff_t
+#else				/* }{ */
+/* 16-bit ints */
+#define LUA_INT32	long
+#define LUAI_UMEM	unsigned long
+#define LUAI_MEM	long
+#endif				/* } */
+
+
+/*
+@@ LUAI_MAXSTACK limits the size of the Lua stack.
+** CHANGE it if you need a different limit. This limit is arbitrary;
+** its only purpose is to stop Lua to consume unlimited stack
+** space (and to reserve some numbers for pseudo-indices).
+*/
+#if LUAI_BITSINT >= 32
+#define LUAI_MAXSTACK		1000000
+#else
+#define LUAI_MAXSTACK		15000
+#endif
+
+/* reserve some space for error handling */
+#define LUAI_FIRSTPSEUDOIDX	(-LUAI_MAXSTACK - 1000)
+
+
+
+
+/*
+@@ LUAL_BUFFERSIZE is the buffer size used by the lauxlib buffer system.
+** CHANGE it if it uses too much C-stack space.
+*/
+#define LUAL_BUFFERSIZE		BUFSIZ
+
+
+
+
+/*
+** {==================================================================
+@@ LUA_NUMBER is the type of numbers in Lua.
+** CHANGE the following definitions only if you want to build Lua
+** with a number type different from double. You may also need to
+** change lua_number2int & lua_number2integer.
+** ===================================================================
+*/
+
+#define LUA_NUMBER_DOUBLE
+#define LUA_NUMBER	double
+
+/*
+@@ LUAI_UACNUMBER is the result of an 'usual argument conversion'
+@* over a number.
+*/
+#define LUAI_UACNUMBER	double
+
+
+/*
+@@ LUA_NUMBER_SCAN is the format for reading numbers.
+@@ LUA_NUMBER_FMT is the format for writing numbers.
+@@ lua_number2str converts a number to a string.
+@@ LUAI_MAXNUMBER2STR is maximum size of previous conversion.
+*/
+#define LUA_NUMBER_SCAN		"%lf"
+#define LUA_NUMBER_FMT		"%.14g"
+#define lua_number2str(s,n)	sprintf((s), LUA_NUMBER_FMT, (n))
+#define LUAI_MAXNUMBER2STR	32 /* 16 digits, sign, point, and \0 */
+
+
+/*
+@@ l_mathop allows the addition of an 'l' or 'f' to all math operations
+*/
+#define l_mathop(x)		(x)
+
+
+/*
+@@ lua_str2number converts a decimal numeric string to a number.
+@@ lua_strx2number converts an hexadecimal numeric string to a number.
+** In C99, 'strtod' does both conversions. C89, however, has no function
+** to convert floating hexadecimal strings to numbers. For these
+** systems, you can leave 'lua_strx2number' undefined and Lua will
+** provide its own implementation.
+*/
+#define lua_str2number(s,p)	strtod((s), (p))
+
+#if defined(LUA_USE_STRTODHEX)
+#define lua_strx2number(s,p)	strtod((s), (p))
+#endif
+
+
+/*
+@@ The luai_num* macros define the primitive operations over numbers.
+*/
+
+/* the following operations need the math library */
+#if defined(lobject_c) || defined(lvm_c)
+#include <math.h>
+#define luai_nummod(L,a,b)	((a) - l_mathop(floor)((a)/(b))*(b))
+#define luai_numpow(L,a,b)	(l_mathop(pow)(a,b))
+#endif
+
+/* these are quite standard operations */
+#if defined(LUA_CORE)
+#define luai_numadd(L,a,b)	((a)+(b))
+#define luai_numsub(L,a,b)	((a)-(b))
+#define luai_nummul(L,a,b)	((a)*(b))
+#define luai_numdiv(L,a,b)	((a)/(b))
+#define luai_numunm(L,a)	(-(a))
+#define luai_numeq(a,b)		((a)==(b))
+#define luai_numlt(L,a,b)	((a)<(b))
+#define luai_numle(L,a,b)	((a)<=(b))
+#define luai_numisnan(L,a)	(!luai_numeq((a), (a)))
+#endif
+
+
+
+/*
+@@ LUA_INTEGER is the integral type used by lua_pushinteger/lua_tointeger.
+** CHANGE that if ptrdiff_t is not adequate on your machine. (On most
+** machines, ptrdiff_t gives a good choice between int or long.)
+*/
+#define LUA_INTEGER	ptrdiff_t
+
+/*
+@@ LUA_UNSIGNED is the integral type used by lua_pushunsigned/lua_tounsigned.
+** It must have at least 32 bits.
+*/
+#define LUA_UNSIGNED	unsigned LUA_INT32
+
+
+
+/*
+** Some tricks with doubles
+*/
+
+#if defined(LUA_NUMBER_DOUBLE) && !defined(LUA_ANSI)	/* { */
+/*
+** The next definitions activate some tricks to speed up the
+** conversion from doubles to integer types, mainly to LUA_UNSIGNED.
+**
+@@ LUA_MSASMTRICK uses Microsoft assembler to avoid clashes with a
+** DirectX idiosyncrasy.
+**
+@@ LUA_IEEE754TRICK uses a trick that should work on any machine
+** using IEEE754 with a 32-bit integer type.
+**
+@@ LUA_IEEELL extends the trick to LUA_INTEGER; should only be
+** defined when LUA_INTEGER is a 32-bit integer.
+**
+@@ LUA_IEEEENDIAN is the endianness of doubles in your machine
+** (0 for little endian, 1 for big endian); if not defined, Lua will
+** check it dynamically for LUA_IEEE754TRICK (but not for LUA_NANTRICK).
+**
+@@ LUA_NANTRICK controls the use of a trick to pack all types into
+** a single double value, using NaN values to represent non-number
+** values. The trick only works on 32-bit machines (ints and pointers
+** are 32-bit values) with numbers represented as IEEE 754-2008 doubles
+** with conventional endianess (12345678 or 87654321), in CPUs that do
+** not produce signaling NaN values (all NaNs are quiet).
+*/
+
+/* Microsoft compiler on a Pentium (32 bit) ? */
+#if defined(LUA_WIN) && defined(_MSC_VER) && defined(_M_IX86)	/* { */
+
+#define LUA_MSASMTRICK
+#define LUA_IEEEENDIAN		0
+#define LUA_NANTRICK
+
+
+/* pentium 32 bits? */
+#elif defined(__i386__) || defined(__i386) || defined(__X86__) /* }{ */
+
+#define LUA_IEEE754TRICK
+#define LUA_IEEELL
+#define LUA_IEEEENDIAN		0
+#define LUA_NANTRICK
+
+/* pentium 64 bits? */
+#elif defined(__x86_64)						/* }{ */
+
+#define LUA_IEEE754TRICK
+#define LUA_IEEEENDIAN		0
+
+#elif defined(__POWERPC__) || defined(__ppc__)			/* }{ */
+
+#define LUA_IEEE754TRICK
+#define LUA_IEEEENDIAN		1
+
+#else								/* }{ */
+
+/* assume IEEE754 and a 32-bit integer type */
+#define LUA_IEEE754TRICK
+
+#endif								/* } */
+
+#endif							/* } */
+
+/* }================================================================== */
+
+
+
+
+/* =================================================================== */
+
+/*
+** Local configuration. You can use this space to add your redefinitions
+** without modifying the main part of the file.
+*/
+
+
+
+#endif
+
diff -ruNp src.orig/libs/lua/lualib.h src/libs/lua/lualib.h
--- src.orig/libs/lua/lualib.h	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lualib.h	2017-11-21 19:39:46 -0600
@@ -0,0 +1,55 @@
+/*
+** $Id: lualib.h,v 1.43 2011/12/08 12:11:37 roberto Exp $
+** Lua standard libraries
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lualib_h
+#define lualib_h
+
+#include "lua.h"
+
+
+
+LUAMOD_API int (luaopen_base) (lua_State *L);
+
+#define LUA_COLIBNAME	"coroutine"
+LUAMOD_API int (luaopen_coroutine) (lua_State *L);
+
+#define LUA_TABLIBNAME	"table"
+LUAMOD_API int (luaopen_table) (lua_State *L);
+
+#define LUA_IOLIBNAME	"io"
+LUAMOD_API int (luaopen_io) (lua_State *L);
+
+#define LUA_OSLIBNAME	"os"
+LUAMOD_API int (luaopen_os) (lua_State *L);
+
+#define LUA_STRLIBNAME	"string"
+LUAMOD_API int (luaopen_string) (lua_State *L);
+
+#define LUA_BITLIBNAME	"bit32"
+LUAMOD_API int (luaopen_bit32) (lua_State *L);
+
+#define LUA_MATHLIBNAME	"math"
+LUAMOD_API int (luaopen_math) (lua_State *L);
+
+#define LUA_DBLIBNAME	"debug"
+LUAMOD_API int (luaopen_debug) (lua_State *L);
+
+#define LUA_LOADLIBNAME	"package"
+LUAMOD_API int (luaopen_package) (lua_State *L);
+
+
+/* open all previous libraries */
+LUALIB_API void (luaL_openlibs) (lua_State *L);
+
+
+
+#if !defined(lua_assert)
+#define lua_assert(x)	((void)0)
+#endif
+
+
+#endif
diff -ruNp src.orig/libs/lua/lundump.c src/libs/lua/lundump.c
--- src.orig/libs/lua/lundump.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lundump.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,258 @@
+/*
+** $Id: lundump.c,v 2.22 2012/05/08 13:53:33 roberto Exp $
+** load precompiled Lua chunks
+** See Copyright Notice in lua.h
+*/
+
+#include <string.h>
+
+#define lundump_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstring.h"
+#include "lundump.h"
+#include "lzio.h"
+
+typedef struct {
+ lua_State* L;
+ ZIO* Z;
+ Mbuffer* b;
+ const char* name;
+} LoadState;
+
+static l_noret error(LoadState* S, const char* why)
+{
+ luaO_pushfstring(S->L,"%s: %s precompiled chunk",S->name,why);
+ luaD_throw(S->L,LUA_ERRSYNTAX);
+}
+
+#define LoadMem(S,b,n,size)	LoadBlock(S,b,(n)*(size))
+#define LoadByte(S)		(lu_byte)LoadChar(S)
+#define LoadVar(S,x)		LoadMem(S,&x,1,sizeof(x))
+#define LoadVector(S,b,n,size)	LoadMem(S,b,n,size)
+
+#if !defined(luai_verifycode)
+#define luai_verifycode(L,b,f)	/* empty */
+#endif
+
+static void LoadBlock(LoadState* S, void* b, size_t size)
+{
+ if (luaZ_read(S->Z,b,size)!=0) error(S,"truncated");
+}
+
+static int LoadChar(LoadState* S)
+{
+ char x;
+ LoadVar(S,x);
+ return x;
+}
+
+static int LoadInt(LoadState* S)
+{
+ int x;
+ LoadVar(S,x);
+ if (x<0) error(S,"corrupted");
+ return x;
+}
+
+static lua_Number LoadNumber(LoadState* S)
+{
+ lua_Number x;
+ LoadVar(S,x);
+ return x;
+}
+
+static TString* LoadString(LoadState* S)
+{
+ size_t size;
+ LoadVar(S,size);
+ if (size==0)
+  return NULL;
+ else
+ {
+  char* s=luaZ_openspace(S->L,S->b,size);
+  LoadBlock(S,s,size*sizeof(char));
+  return luaS_newlstr(S->L,s,size-1);		/* remove trailing '\0' */
+ }
+}
+
+static void LoadCode(LoadState* S, Proto* f)
+{
+ int n=LoadInt(S);
+ f->code=luaM_newvector(S->L,n,Instruction);
+ f->sizecode=n;
+ LoadVector(S,f->code,n,sizeof(Instruction));
+}
+
+static void LoadFunction(LoadState* S, Proto* f);
+
+static void LoadConstants(LoadState* S, Proto* f)
+{
+ int i,n;
+ n=LoadInt(S);
+ f->k=luaM_newvector(S->L,n,TValue);
+ f->sizek=n;
+ for (i=0; i<n; i++) setnilvalue(&f->k[i]);
+ for (i=0; i<n; i++)
+ {
+  TValue* o=&f->k[i];
+  int t=LoadChar(S);
+  switch (t)
+  {
+   case LUA_TNIL:
+	setnilvalue(o);
+	break;
+   case LUA_TBOOLEAN:
+	setbvalue(o,LoadChar(S));
+	break;
+   case LUA_TNUMBER:
+	setnvalue(o,LoadNumber(S));
+	break;
+   case LUA_TSTRING:
+	setsvalue2n(S->L,o,LoadString(S));
+	break;
+    default: lua_assert(0);
+  }
+ }
+ n=LoadInt(S);
+ f->p=luaM_newvector(S->L,n,Proto*);
+ f->sizep=n;
+ for (i=0; i<n; i++) f->p[i]=NULL;
+ for (i=0; i<n; i++)
+ {
+  f->p[i]=luaF_newproto(S->L);
+  LoadFunction(S,f->p[i]);
+ }
+}
+
+static void LoadUpvalues(LoadState* S, Proto* f)
+{
+ int i,n;
+ n=LoadInt(S);
+ f->upvalues=luaM_newvector(S->L,n,Upvaldesc);
+ f->sizeupvalues=n;
+ for (i=0; i<n; i++) f->upvalues[i].name=NULL;
+ for (i=0; i<n; i++)
+ {
+  f->upvalues[i].instack=LoadByte(S);
+  f->upvalues[i].idx=LoadByte(S);
+ }
+}
+
+static void LoadDebug(LoadState* S, Proto* f)
+{
+ int i,n;
+ f->source=LoadString(S);
+ n=LoadInt(S);
+ f->lineinfo=luaM_newvector(S->L,n,int);
+ f->sizelineinfo=n;
+ LoadVector(S,f->lineinfo,n,sizeof(int));
+ n=LoadInt(S);
+ f->locvars=luaM_newvector(S->L,n,LocVar);
+ f->sizelocvars=n;
+ for (i=0; i<n; i++) f->locvars[i].varname=NULL;
+ for (i=0; i<n; i++)
+ {
+  f->locvars[i].varname=LoadString(S);
+  f->locvars[i].startpc=LoadInt(S);
+  f->locvars[i].endpc=LoadInt(S);
+ }
+ n=LoadInt(S);
+ for (i=0; i<n; i++) f->upvalues[i].name=LoadString(S);
+}
+
+static void LoadFunction(LoadState* S, Proto* f)
+{
+ f->linedefined=LoadInt(S);
+ f->lastlinedefined=LoadInt(S);
+ f->numparams=LoadByte(S);
+ f->is_vararg=LoadByte(S);
+ f->maxstacksize=LoadByte(S);
+ LoadCode(S,f);
+ LoadConstants(S,f);
+ LoadUpvalues(S,f);
+ LoadDebug(S,f);
+}
+
+/* the code below must be consistent with the code in luaU_header */
+#define N0	LUAC_HEADERSIZE
+#define N1	(sizeof(LUA_SIGNATURE)-sizeof(char))
+#define N2	N1+2
+#define N3	N2+6
+
+static void LoadHeader(LoadState* S)
+{
+ lu_byte h[LUAC_HEADERSIZE];
+ lu_byte s[LUAC_HEADERSIZE];
+ luaU_header(h);
+ memcpy(s,h,sizeof(char));			/* first char already read */
+ LoadBlock(S,s+sizeof(char),LUAC_HEADERSIZE-sizeof(char));
+ if (memcmp(h,s,N0)==0) return;
+ if (memcmp(h,s,N1)!=0) error(S,"not a");
+ if (memcmp(h,s,N2)!=0) error(S,"version mismatch in");
+ if (memcmp(h,s,N3)!=0) error(S,"incompatible"); else error(S,"corrupted");
+}
+
+/*
+** load precompiled chunk
+*/
+Closure* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff, const char* name)
+{
+ LoadState S;
+ Closure* cl;
+ if (*name=='@' || *name=='=')
+  S.name=name+1;
+ else if (*name==LUA_SIGNATURE[0])
+  S.name="binary string";
+ else
+  S.name=name;
+ S.L=L;
+ S.Z=Z;
+ S.b=buff;
+ LoadHeader(&S);
+ cl=luaF_newLclosure(L,1);
+ setclLvalue(L,L->top,cl); incr_top(L);
+ cl->l.p=luaF_newproto(L);
+ LoadFunction(&S,cl->l.p);
+ if (cl->l.p->sizeupvalues != 1)
+ {
+  Proto* p=cl->l.p;
+  cl=luaF_newLclosure(L,cl->l.p->sizeupvalues);
+  cl->l.p=p;
+  setclLvalue(L,L->top-1,cl);
+ }
+ luai_verifycode(L,buff,cl->l.p);
+ return cl;
+}
+
+#define MYINT(s)	(s[0]-'0')
+#define VERSION		MYINT(LUA_VERSION_MAJOR)*16+MYINT(LUA_VERSION_MINOR)
+#define FORMAT		0		/* this is the official format */
+
+/*
+* make header for precompiled chunks
+* if you change the code below be sure to update LoadHeader and FORMAT above
+* and LUAC_HEADERSIZE in lundump.h
+*/
+void luaU_header (lu_byte* h)
+{
+ int x=1;
+ memcpy(h,LUA_SIGNATURE,sizeof(LUA_SIGNATURE)-sizeof(char));
+ h+=sizeof(LUA_SIGNATURE)-sizeof(char);
+ *h++=cast_byte(VERSION);
+ *h++=cast_byte(FORMAT);
+ *h++=cast_byte(*(char*)&x);			/* endianness */
+ *h++=cast_byte(sizeof(int));
+ *h++=cast_byte(sizeof(size_t));
+ *h++=cast_byte(sizeof(Instruction));
+ *h++=cast_byte(sizeof(lua_Number));
+ *h++=cast_byte(((lua_Number)0.5)==0);		/* is lua_Number integral? */
+ memcpy(h,LUAC_TAIL,sizeof(LUAC_TAIL)-sizeof(char));
+}
diff -ruNp src.orig/libs/lua/lundump.h src/libs/lua/lundump.h
--- src.orig/libs/lua/lundump.h	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lundump.h	2017-11-21 19:39:46 -0600
@@ -0,0 +1,28 @@
+/*
+** $Id: lundump.h,v 1.39 2012/05/08 13:53:33 roberto Exp $
+** load precompiled Lua chunks
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lundump_h
+#define lundump_h
+
+#include "lobject.h"
+#include "lzio.h"
+
+/* load one chunk; from lundump.c */
+LUAI_FUNC Closure* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff, const char* name);
+
+/* make header; from lundump.c */
+LUAI_FUNC void luaU_header (lu_byte* h);
+
+/* dump one chunk; from ldump.c */
+LUAI_FUNC int luaU_dump (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip);
+
+/* data to catch conversion errors */
+#define LUAC_TAIL		"\x19\x93\r\n\x1a\n"
+
+/* size in bytes of header of binary files */
+#define LUAC_HEADERSIZE		(sizeof(LUA_SIGNATURE)-sizeof(char)+2+6+sizeof(LUAC_TAIL)-sizeof(char))
+
+#endif
diff -ruNp src.orig/libs/lua/lvm.c src/libs/lua/lvm.c
--- src.orig/libs/lua/lvm.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lvm.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,867 @@
+/*
+** $Id: lvm.c,v 2.155 2013/03/16 21:10:18 roberto Exp $
+** Lua virtual machine
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define lvm_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+#include "lvm.h"
+
+
+
+/* limit for table tag-method chains (to avoid loops) */
+#define MAXTAGLOOP	100
+
+
+const TValue *luaV_tonumber (const TValue *obj, TValue *n) {
+  lua_Number num;
+  if (ttisnumber(obj)) return obj;
+  if (ttisstring(obj) && luaO_str2d(svalue(obj), tsvalue(obj)->len, &num)) {
+    setnvalue(n, num);
+    return n;
+  }
+  else
+    return NULL;
+}
+
+
+int luaV_tostring (lua_State *L, StkId obj) {
+  if (!ttisnumber(obj))
+    return 0;
+  else {
+    char s[LUAI_MAXNUMBER2STR];
+    lua_Number n = nvalue(obj);
+    int l = lua_number2str(s, n);
+    setsvalue2s(L, obj, luaS_newlstr(L, s, l));
+    return 1;
+  }
+}
+
+
+static void traceexec (lua_State *L) {
+  CallInfo *ci = L->ci;
+  lu_byte mask = L->hookmask;
+  int counthook = ((mask & LUA_MASKCOUNT) && L->hookcount == 0);
+  if (counthook)
+    resethookcount(L);  /* reset count */
+  if (ci->callstatus & CIST_HOOKYIELD) {  /* called hook last time? */
+    ci->callstatus &= ~CIST_HOOKYIELD;  /* erase mark */
+    return;  /* do not call hook again (VM yielded, so it did not move) */
+  }
+  if (counthook)
+    luaD_hook(L, LUA_HOOKCOUNT, -1);  /* call count hook */
+  if (mask & LUA_MASKLINE) {
+    Proto *p = ci_func(ci)->p;
+    int npc = pcRel(ci->u.l.savedpc, p);
+    int newline = getfuncline(p, npc);
+    if (npc == 0 ||  /* call linehook when enter a new function, */
+        ci->u.l.savedpc <= L->oldpc ||  /* when jump back (loop), or when */
+        newline != getfuncline(p, pcRel(L->oldpc, p)))  /* enter a new line */
+      luaD_hook(L, LUA_HOOKLINE, newline);  /* call line hook */
+  }
+  L->oldpc = ci->u.l.savedpc;
+  if (L->status == LUA_YIELD) {  /* did hook yield? */
+    if (counthook)
+      L->hookcount = 1;  /* undo decrement to zero */
+    ci->u.l.savedpc--;  /* undo increment (resume will increment it again) */
+    ci->callstatus |= CIST_HOOKYIELD;  /* mark that it yielded */
+    ci->func = L->top - 1;  /* protect stack below results */
+    luaD_throw(L, LUA_YIELD);
+  }
+}
+
+
+static void callTM (lua_State *L, const TValue *f, const TValue *p1,
+                    const TValue *p2, TValue *p3, int hasres) {
+  ptrdiff_t result = savestack(L, p3);
+  setobj2s(L, L->top++, f);  /* push function */
+  setobj2s(L, L->top++, p1);  /* 1st argument */
+  setobj2s(L, L->top++, p2);  /* 2nd argument */
+  if (!hasres)  /* no result? 'p3' is third argument */
+    setobj2s(L, L->top++, p3);  /* 3rd argument */
+  /* metamethod may yield only when called from Lua code */
+  luaD_call(L, L->top - (4 - hasres), hasres, isLua(L->ci));
+  if (hasres) {  /* if has result, move it to its place */
+    p3 = restorestack(L, result);
+    setobjs2s(L, p3, --L->top);
+  }
+}
+
+
+void luaV_gettable (lua_State *L, const TValue *t, TValue *key, StkId val) {
+  int loop;
+  for (loop = 0; loop < MAXTAGLOOP; loop++) {
+    const TValue *tm;
+    if (ttistable(t)) {  /* `t' is a table? */
+      Table *h = hvalue(t);
+      const TValue *res = luaH_get(h, key); /* do a primitive get */
+      if (!ttisnil(res) ||  /* result is not nil? */
+          (tm = fasttm(L, h->metatable, TM_INDEX)) == NULL) { /* or no TM? */
+        setobj2s(L, val, res);
+        return;
+      }
+      /* else will try the tag method */
+    }
+    else if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_INDEX)))
+      luaG_typeerror(L, t, "index");
+    if (ttisfunction(tm)) {
+      callTM(L, tm, t, key, val, 1);
+      return;
+    }
+    t = tm;  /* else repeat with 'tm' */
+  }
+  luaG_runerror(L, "loop in gettable");
+}
+
+
+void luaV_settable (lua_State *L, const TValue *t, TValue *key, StkId val) {
+  int loop;
+  for (loop = 0; loop < MAXTAGLOOP; loop++) {
+    const TValue *tm;
+    if (ttistable(t)) {  /* `t' is a table? */
+      Table *h = hvalue(t);
+      TValue *oldval = cast(TValue *, luaH_get(h, key));
+      /* if previous value is not nil, there must be a previous entry
+         in the table; moreover, a metamethod has no relevance */
+      if (!ttisnil(oldval) ||
+         /* previous value is nil; must check the metamethod */
+         ((tm = fasttm(L, h->metatable, TM_NEWINDEX)) == NULL &&
+         /* no metamethod; is there a previous entry in the table? */
+         (oldval != luaO_nilobject ||
+         /* no previous entry; must create one. (The next test is
+            always true; we only need the assignment.) */
+         (oldval = luaH_newkey(L, h, key), 1)))) {
+        /* no metamethod and (now) there is an entry with given key */
+        setobj2t(L, oldval, val);  /* assign new value to that entry */
+        invalidateTMcache(h);
+        luaC_barrierback(L, obj2gco(h), val);
+        return;
+      }
+      /* else will try the metamethod */
+    }
+    else  /* not a table; check metamethod */
+      if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_NEWINDEX)))
+        luaG_typeerror(L, t, "index");
+    /* there is a metamethod */
+    if (ttisfunction(tm)) {
+      callTM(L, tm, t, key, val, 0);
+      return;
+    }
+    t = tm;  /* else repeat with 'tm' */
+  }
+  luaG_runerror(L, "loop in settable");
+}
+
+
+static int call_binTM (lua_State *L, const TValue *p1, const TValue *p2,
+                       StkId res, TMS event) {
+  const TValue *tm = luaT_gettmbyobj(L, p1, event);  /* try first operand */
+  if (ttisnil(tm))
+    tm = luaT_gettmbyobj(L, p2, event);  /* try second operand */
+  if (ttisnil(tm)) return 0;
+  callTM(L, tm, p1, p2, res, 1);
+  return 1;
+}
+
+
+static const TValue *get_equalTM (lua_State *L, Table *mt1, Table *mt2,
+                                  TMS event) {
+  const TValue *tm1 = fasttm(L, mt1, event);
+  const TValue *tm2;
+  if (tm1 == NULL) return NULL;  /* no metamethod */
+  if (mt1 == mt2) return tm1;  /* same metatables => same metamethods */
+  tm2 = fasttm(L, mt2, event);
+  if (tm2 == NULL) return NULL;  /* no metamethod */
+  if (luaV_rawequalobj(tm1, tm2))  /* same metamethods? */
+    return tm1;
+  return NULL;
+}
+
+
+static int call_orderTM (lua_State *L, const TValue *p1, const TValue *p2,
+                         TMS event) {
+  if (!call_binTM(L, p1, p2, L->top, event))
+    return -1;  /* no metamethod */
+  else
+    return !l_isfalse(L->top);
+}
+
+
+static int l_strcmp (const TString *ls, const TString *rs) {
+  const char *l = getstr(ls);
+  size_t ll = ls->tsv.len;
+  const char *r = getstr(rs);
+  size_t lr = rs->tsv.len;
+  for (;;) {
+    int temp = strcoll(l, r);
+    if (temp != 0) return temp;
+    else {  /* strings are equal up to a `\0' */
+      size_t len = strlen(l);  /* index of first `\0' in both strings */
+      if (len == lr)  /* r is finished? */
+        return (len == ll) ? 0 : 1;
+      else if (len == ll)  /* l is finished? */
+        return -1;  /* l is smaller than r (because r is not finished) */
+      /* both strings longer than `len'; go on comparing (after the `\0') */
+      len++;
+      l += len; ll -= len; r += len; lr -= len;
+    }
+  }
+}
+
+
+int luaV_lessthan (lua_State *L, const TValue *l, const TValue *r) {
+  int res;
+  if (ttisnumber(l) && ttisnumber(r))
+    return luai_numlt(L, nvalue(l), nvalue(r));
+  else if (ttisstring(l) && ttisstring(r))
+    return l_strcmp(rawtsvalue(l), rawtsvalue(r)) < 0;
+  else if ((res = call_orderTM(L, l, r, TM_LT)) < 0)
+    luaG_ordererror(L, l, r);
+  return res;
+}
+
+
+int luaV_lessequal (lua_State *L, const TValue *l, const TValue *r) {
+  int res;
+  if (ttisnumber(l) && ttisnumber(r))
+    return luai_numle(L, nvalue(l), nvalue(r));
+  else if (ttisstring(l) && ttisstring(r))
+    return l_strcmp(rawtsvalue(l), rawtsvalue(r)) <= 0;
+  else if ((res = call_orderTM(L, l, r, TM_LE)) >= 0)  /* first try `le' */
+    return res;
+  else if ((res = call_orderTM(L, r, l, TM_LT)) < 0)  /* else try `lt' */
+    luaG_ordererror(L, l, r);
+  return !res;
+}
+
+
+/*
+** equality of Lua values. L == NULL means raw equality (no metamethods)
+*/
+int luaV_equalobj_ (lua_State *L, const TValue *t1, const TValue *t2) {
+  const TValue *tm;
+  lua_assert(ttisequal(t1, t2));
+  switch (ttype(t1)) {
+    case LUA_TNIL: return 1;
+    case LUA_TNUMBER: return luai_numeq(nvalue(t1), nvalue(t2));
+    case LUA_TBOOLEAN: return bvalue(t1) == bvalue(t2);  /* true must be 1 !! */
+    case LUA_TLIGHTUSERDATA: return pvalue(t1) == pvalue(t2);
+    case LUA_TLCF: return fvalue(t1) == fvalue(t2);
+    case LUA_TSHRSTR: return eqshrstr(rawtsvalue(t1), rawtsvalue(t2));
+    case LUA_TLNGSTR: return luaS_eqlngstr(rawtsvalue(t1), rawtsvalue(t2));
+    case LUA_TUSERDATA: {
+      if (uvalue(t1) == uvalue(t2)) return 1;
+      else if (L == NULL) return 0;
+      tm = get_equalTM(L, uvalue(t1)->metatable, uvalue(t2)->metatable, TM_EQ);
+      break;  /* will try TM */
+    }
+    case LUA_TTABLE: {
+      if (hvalue(t1) == hvalue(t2)) return 1;
+      else if (L == NULL) return 0;
+      tm = get_equalTM(L, hvalue(t1)->metatable, hvalue(t2)->metatable, TM_EQ);
+      break;  /* will try TM */
+    }
+    default:
+      lua_assert(iscollectable(t1));
+      return gcvalue(t1) == gcvalue(t2);
+  }
+  if (tm == NULL) return 0;  /* no TM? */
+  callTM(L, tm, t1, t2, L->top, 1);  /* call TM */
+  return !l_isfalse(L->top);
+}
+
+
+void luaV_concat (lua_State *L, int total) {
+  lua_assert(total >= 2);
+  do {
+    StkId top = L->top;
+    int n = 2;  /* number of elements handled in this pass (at least 2) */
+    if (!(ttisstring(top-2) || ttisnumber(top-2)) || !tostring(L, top-1)) {
+      if (!call_binTM(L, top-2, top-1, top-2, TM_CONCAT))
+        luaG_concaterror(L, top-2, top-1);
+    }
+    else if (tsvalue(top-1)->len == 0)  /* second operand is empty? */
+      (void)tostring(L, top - 2);  /* result is first operand */
+    else if (ttisstring(top-2) && tsvalue(top-2)->len == 0) {
+      setobjs2s(L, top - 2, top - 1);  /* result is second op. */
+    }
+    else {
+      /* at least two non-empty string values; get as many as possible */
+      size_t tl = tsvalue(top-1)->len;
+      char *buffer;
+      int i;
+      /* collect total length */
+      for (i = 1; i < total && tostring(L, top-i-1); i++) {
+        size_t l = tsvalue(top-i-1)->len;
+        if (l >= (MAX_SIZET/sizeof(char)) - tl)
+          luaG_runerror(L, "string length overflow");
+        tl += l;
+      }
+      buffer = luaZ_openspace(L, &G(L)->buff, tl);
+      tl = 0;
+      n = i;
+      do {  /* concat all strings */
+        size_t l = tsvalue(top-i)->len;
+        memcpy(buffer+tl, svalue(top-i), l * sizeof(char));
+        tl += l;
+      } while (--i > 0);
+      setsvalue2s(L, top-n, luaS_newlstr(L, buffer, tl));
+    }
+    total -= n-1;  /* got 'n' strings to create 1 new */
+    L->top -= n-1;  /* popped 'n' strings and pushed one */
+  } while (total > 1);  /* repeat until only 1 result left */
+}
+
+
+void luaV_objlen (lua_State *L, StkId ra, const TValue *rb) {
+  const TValue *tm;
+  switch (ttypenv(rb)) {
+    case LUA_TTABLE: {
+      Table *h = hvalue(rb);
+      tm = fasttm(L, h->metatable, TM_LEN);
+      if (tm) break;  /* metamethod? break switch to call it */
+      setnvalue(ra, cast_num(luaH_getn(h)));  /* else primitive len */
+      return;
+    }
+    case LUA_TSTRING: {
+      setnvalue(ra, cast_num(tsvalue(rb)->len));
+      return;
+    }
+    default: {  /* try metamethod */
+      tm = luaT_gettmbyobj(L, rb, TM_LEN);
+      if (ttisnil(tm))  /* no metamethod? */
+        luaG_typeerror(L, rb, "get length of");
+      break;
+    }
+  }
+  callTM(L, tm, rb, rb, ra, 1);
+}
+
+
+void luaV_arith (lua_State *L, StkId ra, const TValue *rb,
+                 const TValue *rc, TMS op) {
+  TValue tempb, tempc;
+  const TValue *b, *c;
+  if ((b = luaV_tonumber(rb, &tempb)) != NULL &&
+      (c = luaV_tonumber(rc, &tempc)) != NULL) {
+    lua_Number res = luaO_arith(op - TM_ADD + LUA_OPADD, nvalue(b), nvalue(c));
+    setnvalue(ra, res);
+  }
+  else if (!call_binTM(L, rb, rc, ra, op))
+    luaG_aritherror(L, rb, rc);
+}
+
+
+/*
+** check whether cached closure in prototype 'p' may be reused, that is,
+** whether there is a cached closure with the same upvalues needed by
+** new closure to be created.
+*/
+static Closure *getcached (Proto *p, UpVal **encup, StkId base) {
+  Closure *c = p->cache;
+  if (c != NULL) {  /* is there a cached closure? */
+    int nup = p->sizeupvalues;
+    Upvaldesc *uv = p->upvalues;
+    int i;
+    for (i = 0; i < nup; i++) {  /* check whether it has right upvalues */
+      TValue *v = uv[i].instack ? base + uv[i].idx : encup[uv[i].idx]->v;
+      if (c->l.upvals[i]->v != v)
+        return NULL;  /* wrong upvalue; cannot reuse closure */
+    }
+  }
+  return c;  /* return cached closure (or NULL if no cached closure) */
+}
+
+
+/*
+** create a new Lua closure, push it in the stack, and initialize
+** its upvalues. Note that the call to 'luaC_barrierproto' must come
+** before the assignment to 'p->cache', as the function needs the
+** original value of that field.
+*/
+static void pushclosure (lua_State *L, Proto *p, UpVal **encup, StkId base,
+                         StkId ra) {
+  int nup = p->sizeupvalues;
+  Upvaldesc *uv = p->upvalues;
+  int i;
+  Closure *ncl = luaF_newLclosure(L, nup);
+  ncl->l.p = p;
+  setclLvalue(L, ra, ncl);  /* anchor new closure in stack */
+  for (i = 0; i < nup; i++) {  /* fill in its upvalues */
+    if (uv[i].instack)  /* upvalue refers to local variable? */
+      ncl->l.upvals[i] = luaF_findupval(L, base + uv[i].idx);
+    else  /* get upvalue from enclosing function */
+      ncl->l.upvals[i] = encup[uv[i].idx];
+  }
+  luaC_barrierproto(L, p, ncl);
+  p->cache = ncl;  /* save it on cache for reuse */
+}
+
+
+/*
+** finish execution of an opcode interrupted by an yield
+*/
+void luaV_finishOp (lua_State *L) {
+  CallInfo *ci = L->ci;
+  StkId base = ci->u.l.base;
+  Instruction inst = *(ci->u.l.savedpc - 1);  /* interrupted instruction */
+  OpCode op = GET_OPCODE(inst);
+  switch (op) {  /* finish its execution */
+    case OP_ADD: case OP_SUB: case OP_MUL: case OP_DIV:
+    case OP_MOD: case OP_POW: case OP_UNM: case OP_LEN:
+    case OP_GETTABUP: case OP_GETTABLE: case OP_SELF: {
+      setobjs2s(L, base + GETARG_A(inst), --L->top);
+      break;
+    }
+    case OP_LE: case OP_LT: case OP_EQ: {
+      int res = !l_isfalse(L->top - 1);
+      L->top--;
+      /* metamethod should not be called when operand is K */
+      lua_assert(!ISK(GETARG_B(inst)));
+      if (op == OP_LE &&  /* "<=" using "<" instead? */
+          ttisnil(luaT_gettmbyobj(L, base + GETARG_B(inst), TM_LE)))
+        res = !res;  /* invert result */
+      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_JMP);
+      if (res != GETARG_A(inst))  /* condition failed? */
+        ci->u.l.savedpc++;  /* skip jump instruction */
+      break;
+    }
+    case OP_CONCAT: {
+      StkId top = L->top - 1;  /* top when 'call_binTM' was called */
+      int b = GETARG_B(inst);      /* first element to concatenate */
+      int total = cast_int(top - 1 - (base + b));  /* yet to concatenate */
+      setobj2s(L, top - 2, top);  /* put TM result in proper position */
+      if (total > 1) {  /* are there elements to concat? */
+        L->top = top - 1;  /* top is one after last element (at top-2) */
+        luaV_concat(L, total);  /* concat them (may yield again) */
+      }
+      /* move final result to final position */
+      setobj2s(L, ci->u.l.base + GETARG_A(inst), L->top - 1);
+      L->top = ci->top;  /* restore top */
+      break;
+    }
+    case OP_TFORCALL: {
+      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_TFORLOOP);
+      L->top = ci->top;  /* correct top */
+      break;
+    }
+    case OP_CALL: {
+      if (GETARG_C(inst) - 1 >= 0)  /* nresults >= 0? */
+        L->top = ci->top;  /* adjust results */
+      break;
+    }
+    case OP_TAILCALL: case OP_SETTABUP: case OP_SETTABLE:
+      break;
+    default: lua_assert(0);
+  }
+}
+
+
+
+/*
+** some macros for common tasks in `luaV_execute'
+*/
+
+#if !defined luai_runtimecheck
+#define luai_runtimecheck(L, c)		/* void */
+#endif
+
+
+#define RA(i)	(base+GETARG_A(i))
+/* to be used after possible stack reallocation */
+#define RB(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i))
+#define RC(i)	check_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i))
+#define RKB(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgK, \
+	ISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i))
+#define RKC(i)	check_exp(getCMode(GET_OPCODE(i)) == OpArgK, \
+	ISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i))
+#define KBx(i)  \
+  (k + (GETARG_Bx(i) != 0 ? GETARG_Bx(i) - 1 : GETARG_Ax(*ci->u.l.savedpc++)))
+
+
+/* execute a jump instruction */
+#define dojump(ci,i,e) \
+  { int a = GETARG_A(i); \
+    if (a > 0) luaF_close(L, ci->u.l.base + a - 1); \
+    ci->u.l.savedpc += GETARG_sBx(i) + e; }
+
+/* for test instructions, execute the jump instruction that follows it */
+#define donextjump(ci)	{ i = *ci->u.l.savedpc; dojump(ci, i, 1); }
+
+
+#define Protect(x)	{ {x;}; base = ci->u.l.base; }
+
+#define checkGC(L,c)  \
+  Protect( luaC_condGC(L,{L->top = (c);  /* limit of live values */ \
+                          luaC_step(L); \
+                          L->top = ci->top;})  /* restore top */ \
+           luai_threadyield(L); )
+
+
+#define arith_op(op,tm) { \
+        TValue *rb = RKB(i); \
+        TValue *rc = RKC(i); \
+        if (ttisnumber(rb) && ttisnumber(rc)) { \
+          lua_Number nb = nvalue(rb), nc = nvalue(rc); \
+          setnvalue(ra, op(L, nb, nc)); \
+        } \
+        else { Protect(luaV_arith(L, ra, rb, rc, tm)); } }
+
+
+#define vmdispatch(o)	switch(o)
+#define vmcase(l,b)	case l: {b}  break;
+#define vmcasenb(l,b)	case l: {b}		/* nb = no break */
+
+void luaV_execute (lua_State *L) {
+  CallInfo *ci = L->ci;
+  LClosure *cl;
+  TValue *k;
+  StkId base;
+ newframe:  /* reentry point when frame changes (call/return) */
+  lua_assert(ci == L->ci);
+  cl = clLvalue(ci->func);
+  k = cl->p->k;
+  base = ci->u.l.base;
+  /* main loop of interpreter */
+  for (;;) {
+    Instruction i = *(ci->u.l.savedpc++);
+    StkId ra;
+    if ((L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT)) &&
+        (--L->hookcount == 0 || L->hookmask & LUA_MASKLINE)) {
+      Protect(traceexec(L));
+    }
+    /* WARNING: several calls may realloc the stack and invalidate `ra' */
+    ra = RA(i);
+    lua_assert(base == ci->u.l.base);
+    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
+    vmdispatch (GET_OPCODE(i)) {
+      vmcase(OP_MOVE,
+        setobjs2s(L, ra, RB(i));
+      )
+      vmcase(OP_LOADK,
+        TValue *rb = k + GETARG_Bx(i);
+        setobj2s(L, ra, rb);
+      )
+      vmcase(OP_LOADKX,
+        TValue *rb;
+        lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
+        rb = k + GETARG_Ax(*ci->u.l.savedpc++);
+        setobj2s(L, ra, rb);
+      )
+      vmcase(OP_LOADBOOL,
+        setbvalue(ra, GETARG_B(i));
+        if (GETARG_C(i)) ci->u.l.savedpc++;  /* skip next instruction (if C) */
+      )
+      vmcase(OP_LOADNIL,
+        int b = GETARG_B(i);
+        do {
+          setnilvalue(ra++);
+        } while (b--);
+      )
+      vmcase(OP_GETUPVAL,
+        int b = GETARG_B(i);
+        setobj2s(L, ra, cl->upvals[b]->v);
+      )
+      vmcase(OP_GETTABUP,
+        int b = GETARG_B(i);
+        Protect(luaV_gettable(L, cl->upvals[b]->v, RKC(i), ra));
+      )
+      vmcase(OP_GETTABLE,
+        Protect(luaV_gettable(L, RB(i), RKC(i), ra));
+      )
+      vmcase(OP_SETTABUP,
+        int a = GETARG_A(i);
+        Protect(luaV_settable(L, cl->upvals[a]->v, RKB(i), RKC(i)));
+      )
+      vmcase(OP_SETUPVAL,
+        UpVal *uv = cl->upvals[GETARG_B(i)];
+        setobj(L, uv->v, ra);
+        luaC_barrier(L, uv, ra);
+      )
+      vmcase(OP_SETTABLE,
+        Protect(luaV_settable(L, ra, RKB(i), RKC(i)));
+      )
+      vmcase(OP_NEWTABLE,
+        int b = GETARG_B(i);
+        int c = GETARG_C(i);
+        Table *t = luaH_new(L);
+        sethvalue(L, ra, t);
+        if (b != 0 || c != 0)
+          luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
+        checkGC(L, ra + 1);
+      )
+      vmcase(OP_SELF,
+        StkId rb = RB(i);
+        setobjs2s(L, ra+1, rb);
+        Protect(luaV_gettable(L, rb, RKC(i), ra));
+      )
+      vmcase(OP_ADD,
+        arith_op(luai_numadd, TM_ADD);
+      )
+      vmcase(OP_SUB,
+        arith_op(luai_numsub, TM_SUB);
+      )
+      vmcase(OP_MUL,
+        arith_op(luai_nummul, TM_MUL);
+      )
+      vmcase(OP_DIV,
+        arith_op(luai_numdiv, TM_DIV);
+      )
+      vmcase(OP_MOD,
+        arith_op(luai_nummod, TM_MOD);
+      )
+      vmcase(OP_POW,
+        arith_op(luai_numpow, TM_POW);
+      )
+      vmcase(OP_UNM,
+        TValue *rb = RB(i);
+        if (ttisnumber(rb)) {
+          lua_Number nb = nvalue(rb);
+          setnvalue(ra, luai_numunm(L, nb));
+        }
+        else {
+          Protect(luaV_arith(L, ra, rb, rb, TM_UNM));
+        }
+      )
+      vmcase(OP_NOT,
+        TValue *rb = RB(i);
+        int res = l_isfalse(rb);  /* next assignment may change this value */
+        setbvalue(ra, res);
+      )
+      vmcase(OP_LEN,
+        Protect(luaV_objlen(L, ra, RB(i)));
+      )
+      vmcase(OP_CONCAT,
+        int b = GETARG_B(i);
+        int c = GETARG_C(i);
+        StkId rb;
+        L->top = base + c + 1;  /* mark the end of concat operands */
+        Protect(luaV_concat(L, c - b + 1));
+        ra = RA(i);  /* 'luav_concat' may invoke TMs and move the stack */
+        rb = b + base;
+        setobjs2s(L, ra, rb);
+        checkGC(L, (ra >= rb ? ra + 1 : rb));
+        L->top = ci->top;  /* restore top */
+      )
+      vmcase(OP_JMP,
+        dojump(ci, i, 0);
+      )
+      vmcase(OP_EQ,
+        TValue *rb = RKB(i);
+        TValue *rc = RKC(i);
+        Protect(
+          if (cast_int(equalobj(L, rb, rc)) != GETARG_A(i))
+            ci->u.l.savedpc++;
+          else
+            donextjump(ci);
+        )
+      )
+      vmcase(OP_LT,
+        Protect(
+          if (luaV_lessthan(L, RKB(i), RKC(i)) != GETARG_A(i))
+            ci->u.l.savedpc++;
+          else
+            donextjump(ci);
+        )
+      )
+      vmcase(OP_LE,
+        Protect(
+          if (luaV_lessequal(L, RKB(i), RKC(i)) != GETARG_A(i))
+            ci->u.l.savedpc++;
+          else
+            donextjump(ci);
+        )
+      )
+      vmcase(OP_TEST,
+        if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra))
+            ci->u.l.savedpc++;
+          else
+          donextjump(ci);
+      )
+      vmcase(OP_TESTSET,
+        TValue *rb = RB(i);
+        if (GETARG_C(i) ? l_isfalse(rb) : !l_isfalse(rb))
+          ci->u.l.savedpc++;
+        else {
+          setobjs2s(L, ra, rb);
+          donextjump(ci);
+        }
+      )
+      vmcase(OP_CALL,
+        int b = GETARG_B(i);
+        int nresults = GETARG_C(i) - 1;
+        if (b != 0) L->top = ra+b;  /* else previous instruction set top */
+        if (luaD_precall(L, ra, nresults)) {  /* C function? */
+          if (nresults >= 0) L->top = ci->top;  /* adjust results */
+          base = ci->u.l.base;
+        }
+        else {  /* Lua function */
+          ci = L->ci;
+          ci->callstatus |= CIST_REENTRY;
+          goto newframe;  /* restart luaV_execute over new Lua function */
+        }
+      )
+      vmcase(OP_TAILCALL,
+        int b = GETARG_B(i);
+        if (b != 0) L->top = ra+b;  /* else previous instruction set top */
+        lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
+        if (luaD_precall(L, ra, LUA_MULTRET))  /* C function? */
+          base = ci->u.l.base;
+        else {
+          /* tail call: put called frame (n) in place of caller one (o) */
+          CallInfo *nci = L->ci;  /* called frame */
+          CallInfo *oci = nci->previous;  /* caller frame */
+          StkId nfunc = nci->func;  /* called function */
+          StkId ofunc = oci->func;  /* caller function */
+          /* last stack slot filled by 'precall' */
+          StkId lim = nci->u.l.base + getproto(nfunc)->numparams;
+          int aux;
+          /* close all upvalues from previous call */
+          if (cl->p->sizep > 0) luaF_close(L, oci->u.l.base);
+          /* move new frame into old one */
+          for (aux = 0; nfunc + aux < lim; aux++)
+            setobjs2s(L, ofunc + aux, nfunc + aux);
+          oci->u.l.base = ofunc + (nci->u.l.base - nfunc);  /* correct base */
+          oci->top = L->top = ofunc + (L->top - nfunc);  /* correct top */
+          oci->u.l.savedpc = nci->u.l.savedpc;
+          oci->callstatus |= CIST_TAIL;  /* function was tail called */
+          ci = L->ci = oci;  /* remove new frame */
+          lua_assert(L->top == oci->u.l.base + getproto(ofunc)->maxstacksize);
+          goto newframe;  /* restart luaV_execute over new Lua function */
+        }
+      )
+      vmcasenb(OP_RETURN,
+        int b = GETARG_B(i);
+        if (b != 0) L->top = ra+b-1;
+        if (cl->p->sizep > 0) luaF_close(L, base);
+        b = luaD_poscall(L, ra);
+        if (!(ci->callstatus & CIST_REENTRY))  /* 'ci' still the called one */
+          return;  /* external invocation: return */
+        else {  /* invocation via reentry: continue execution */
+          ci = L->ci;
+          if (b) L->top = ci->top;
+          lua_assert(isLua(ci));
+          lua_assert(GET_OPCODE(*((ci)->u.l.savedpc - 1)) == OP_CALL);
+          goto newframe;  /* restart luaV_execute over new Lua function */
+        }
+      )
+      vmcase(OP_FORLOOP,
+        lua_Number step = nvalue(ra+2);
+        lua_Number idx = luai_numadd(L, nvalue(ra), step); /* increment index */
+        lua_Number limit = nvalue(ra+1);
+        if (luai_numlt(L, 0, step) ? luai_numle(L, idx, limit)
+                                   : luai_numle(L, limit, idx)) {
+          ci->u.l.savedpc += GETARG_sBx(i);  /* jump back */
+          setnvalue(ra, idx);  /* update internal index... */
+          setnvalue(ra+3, idx);  /* ...and external index */
+        }
+      )
+      vmcase(OP_FORPREP,
+        const TValue *init = ra;
+        const TValue *plimit = ra+1;
+        const TValue *pstep = ra+2;
+        if (!tonumber(init, ra))
+          luaG_runerror(L, LUA_QL("for") " initial value must be a number");
+        else if (!tonumber(plimit, ra+1))
+          luaG_runerror(L, LUA_QL("for") " limit must be a number");
+        else if (!tonumber(pstep, ra+2))
+          luaG_runerror(L, LUA_QL("for") " step must be a number");
+        setnvalue(ra, luai_numsub(L, nvalue(ra), nvalue(pstep)));
+        ci->u.l.savedpc += GETARG_sBx(i);
+      )
+      vmcasenb(OP_TFORCALL,
+        StkId cb = ra + 3;  /* call base */
+        setobjs2s(L, cb+2, ra+2);
+        setobjs2s(L, cb+1, ra+1);
+        setobjs2s(L, cb, ra);
+        L->top = cb + 3;  /* func. + 2 args (state and index) */
+        Protect(luaD_call(L, cb, GETARG_C(i), 1));
+        L->top = ci->top;
+        i = *(ci->u.l.savedpc++);  /* go to next instruction */
+        ra = RA(i);
+        lua_assert(GET_OPCODE(i) == OP_TFORLOOP);
+        goto l_tforloop;
+      )
+      vmcase(OP_TFORLOOP,
+        l_tforloop:
+        if (!ttisnil(ra + 1)) {  /* continue loop? */
+          setobjs2s(L, ra, ra + 1);  /* save control variable */
+           ci->u.l.savedpc += GETARG_sBx(i);  /* jump back */
+        }
+      )
+      vmcase(OP_SETLIST,
+        int n = GETARG_B(i);
+        int c = GETARG_C(i);
+        int last;
+        Table *h;
+        if (n == 0) n = cast_int(L->top - ra) - 1;
+        if (c == 0) {
+          lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
+          c = GETARG_Ax(*ci->u.l.savedpc++);
+        }
+        luai_runtimecheck(L, ttistable(ra));
+        h = hvalue(ra);
+        last = ((c-1)*LFIELDS_PER_FLUSH) + n;
+        if (last > h->sizearray)  /* needs more space? */
+          luaH_resizearray(L, h, last);  /* pre-allocate it at once */
+        for (; n > 0; n--) {
+          TValue *val = ra+n;
+          luaH_setint(L, h, last--, val);
+          luaC_barrierback(L, obj2gco(h), val);
+        }
+        L->top = ci->top;  /* correct top (in case of previous open call) */
+      )
+      vmcase(OP_CLOSURE,
+        Proto *p = cl->p->p[GETARG_Bx(i)];
+        Closure *ncl = getcached(p, cl->upvals, base);  /* cached closure */
+        if (ncl == NULL)  /* no match? */
+          pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
+        else
+          setclLvalue(L, ra, ncl);  /* push cashed closure */
+        checkGC(L, ra + 1);
+      )
+      vmcase(OP_VARARG,
+        int b = GETARG_B(i) - 1;
+        int j;
+        int n = cast_int(base - ci->func) - cl->p->numparams - 1;
+        if (b < 0) {  /* B == 0? */
+          b = n;  /* get all var. arguments */
+          Protect(luaD_checkstack(L, n));
+          ra = RA(i);  /* previous call may change the stack */
+          L->top = ra + n;
+        }
+        for (j = 0; j < b; j++) {
+          if (j < n) {
+            setobjs2s(L, ra + j, base - n + j);
+          }
+          else {
+            setnilvalue(ra + j);
+          }
+        }
+      )
+      vmcase(OP_EXTRAARG,
+        lua_assert(0);
+      )
+    }
+  }
+}
+
diff -ruNp src.orig/libs/lua/lvm.h src/libs/lua/lvm.h
--- src.orig/libs/lua/lvm.h	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lvm.h	2017-11-21 19:39:46 -0600
@@ -0,0 +1,44 @@
+/*
+** $Id: lvm.h,v 2.18 2013/01/08 14:06:55 roberto Exp $
+** Lua virtual machine
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lvm_h
+#define lvm_h
+
+
+#include "ldo.h"
+#include "lobject.h"
+#include "ltm.h"
+
+
+#define tostring(L,o) (ttisstring(o) || (luaV_tostring(L, o)))
+
+#define tonumber(o,n)	(ttisnumber(o) || (((o) = luaV_tonumber(o,n)) != NULL))
+
+#define equalobj(L,o1,o2)  (ttisequal(o1, o2) && luaV_equalobj_(L, o1, o2))
+
+#define luaV_rawequalobj(o1,o2)		equalobj(NULL,o1,o2)
+
+
+/* not to called directly */
+LUAI_FUNC int luaV_equalobj_ (lua_State *L, const TValue *t1, const TValue *t2);
+
+
+LUAI_FUNC int luaV_lessthan (lua_State *L, const TValue *l, const TValue *r);
+LUAI_FUNC int luaV_lessequal (lua_State *L, const TValue *l, const TValue *r);
+LUAI_FUNC const TValue *luaV_tonumber (const TValue *obj, TValue *n);
+LUAI_FUNC int luaV_tostring (lua_State *L, StkId obj);
+LUAI_FUNC void luaV_gettable (lua_State *L, const TValue *t, TValue *key,
+                                            StkId val);
+LUAI_FUNC void luaV_settable (lua_State *L, const TValue *t, TValue *key,
+                                            StkId val);
+LUAI_FUNC void luaV_finishOp (lua_State *L);
+LUAI_FUNC void luaV_execute (lua_State *L);
+LUAI_FUNC void luaV_concat (lua_State *L, int total);
+LUAI_FUNC void luaV_arith (lua_State *L, StkId ra, const TValue *rb,
+                           const TValue *rc, TMS op);
+LUAI_FUNC void luaV_objlen (lua_State *L, StkId ra, const TValue *rb);
+
+#endif
diff -ruNp src.orig/libs/lua/lzio.c src/libs/lua/lzio.c
--- src.orig/libs/lua/lzio.c	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lzio.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,76 @@
+/*
+** $Id: lzio.c,v 1.35 2012/05/14 13:34:18 roberto Exp $
+** Buffered streams
+** See Copyright Notice in lua.h
+*/
+
+
+#include <string.h>
+
+#define lzio_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "llimits.h"
+#include "lmem.h"
+#include "lstate.h"
+#include "lzio.h"
+
+
+int luaZ_fill (ZIO *z) {
+  size_t size;
+  lua_State *L = z->L;
+  const char *buff;
+  lua_unlock(L);
+  buff = z->reader(L, z->data, &size);
+  lua_lock(L);
+  if (buff == NULL || size == 0)
+    return EOZ;
+  z->n = size - 1;  /* discount char being returned */
+  z->p = buff;
+  return cast_uchar(*(z->p++));
+}
+
+
+void luaZ_init (lua_State *L, ZIO *z, lua_Reader reader, void *data) {
+  z->L = L;
+  z->reader = reader;
+  z->data = data;
+  z->n = 0;
+  z->p = NULL;
+}
+
+
+/* --------------------------------------------------------------- read --- */
+size_t luaZ_read (ZIO *z, void *b, size_t n) {
+  while (n) {
+    size_t m;
+    if (z->n == 0) {  /* no bytes in buffer? */
+      if (luaZ_fill(z) == EOZ)  /* try to read more */
+        return n;  /* no more input; return number of missing bytes */
+      else {
+        z->n++;  /* luaZ_fill consumed first byte; put it back */
+        z->p--;
+      }
+    }
+    m = (n <= z->n) ? n : z->n;  /* min. between n and z->n */
+    memcpy(b, z->p, m);
+    z->n -= m;
+    z->p += m;
+    b = (char *)b + m;
+    n -= m;
+  }
+  return 0;
+}
+
+/* ------------------------------------------------------------------------ */
+char *luaZ_openspace (lua_State *L, Mbuffer *buff, size_t n) {
+  if (n > buff->buffsize) {
+    if (n < LUA_MINBUFFER) n = LUA_MINBUFFER;
+    luaZ_resizebuffer(L, buff, n);
+  }
+  return buff->buffer;
+}
+
+
diff -ruNp src.orig/libs/lua/lzio.h src/libs/lua/lzio.h
--- src.orig/libs/lua/lzio.h	1969-12-31 18:00:00 -0600
+++ src/libs/lua/lzio.h	2017-11-21 19:39:46 -0600
@@ -0,0 +1,65 @@
+/*
+** $Id: lzio.h,v 1.26 2011/07/15 12:48:03 roberto Exp $
+** Buffered streams
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lzio_h
+#define lzio_h
+
+#include "lua.h"
+
+#include "lmem.h"
+
+
+#define EOZ	(-1)			/* end of stream */
+
+typedef struct Zio ZIO;
+
+#define zgetc(z)  (((z)->n--)>0 ?  cast_uchar(*(z)->p++) : luaZ_fill(z))
+
+
+typedef struct Mbuffer {
+  char *buffer;
+  size_t n;
+  size_t buffsize;
+} Mbuffer;
+
+#define luaZ_initbuffer(L, buff) ((buff)->buffer = NULL, (buff)->buffsize = 0)
+
+#define luaZ_buffer(buff)	((buff)->buffer)
+#define luaZ_sizebuffer(buff)	((buff)->buffsize)
+#define luaZ_bufflen(buff)	((buff)->n)
+
+#define luaZ_resetbuffer(buff) ((buff)->n = 0)
+
+
+#define luaZ_resizebuffer(L, buff, size) \
+	(luaM_reallocvector(L, (buff)->buffer, (buff)->buffsize, size, char), \
+	(buff)->buffsize = size)
+
+#define luaZ_freebuffer(L, buff)	luaZ_resizebuffer(L, buff, 0)
+
+
+LUAI_FUNC char *luaZ_openspace (lua_State *L, Mbuffer *buff, size_t n);
+LUAI_FUNC void luaZ_init (lua_State *L, ZIO *z, lua_Reader reader,
+                                        void *data);
+LUAI_FUNC size_t luaZ_read (ZIO* z, void* b, size_t n);	/* read next n bytes */
+
+
+
+/* --------- Private Part ------------------ */
+
+struct Zio {
+  size_t n;			/* bytes still unread */
+  const char *p;		/* current position in buffer */
+  lua_Reader reader;		/* reader function */
+  void* data;			/* additional data */
+  lua_State *L;			/* Lua state (for reader) */
+};
+
+
+LUAI_FUNC int luaZ_fill (ZIO *z);
+
+#endif
diff -ruNp src.orig/libs/luauqm/Makeinfo src/libs/luauqm/Makeinfo
--- src.orig/libs/luauqm/Makeinfo	1969-12-31 18:00:00 -0600
+++ src/libs/luauqm/Makeinfo	2017-11-21 19:39:46 -0600
@@ -0,0 +1,2 @@
+uqm_CFILES="luauqm.c scriptres.c"
+uqm_HFILES="luauqm.h scriptres.h"
diff -ruNp src.orig/libs/luauqm/luauqm.c src/libs/luauqm/luauqm.c
--- src.orig/libs/luauqm/luauqm.c	1969-12-31 18:00:00 -0600
+++ src/libs/luauqm/luauqm.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,318 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <stdlib.h>
+#ifdef USE_INTERNAL_LUA
+#   include "libs/lua/lualib.h"
+#else
+#	include <lualib.h>
+#endif
+
+#define LUAUQM_INTERNAL
+#include "luauqm.h"
+
+#include "libs/log.h"
+
+
+#define LOADSCRIPT_BUFSIZE	0x10000
+
+
+// We want to give the UQM module writer a good set of functions to work
+// with, but we must be careful not to give access to functions which may
+// break security. Bad Lua scripts should not be able to affect anything
+// outside of UQM.
+// XXX TODO: a better sandbox: http://lua-users.org/wiki/SandBoxes
+static const luaL_Reg safeLibs[] = {
+	{ "",                luaopen_base },
+	{ LUA_BITLIBNAME,    luaopen_bit32 },
+	//{ LUA_COLIBNAME,     luaopen_coroutine },
+	//{ LUA_DBLIBNAME,     luaopen_debug },
+	//{ LUA_LUA_IOLIBNAME, luaopen_io },
+	{ LUA_MATHLIBNAME,   luaopen_math },
+	//{ LUA_LUA_OSLIBNAME, luaopen_os },
+	//{ LUA_LUA_LOADLIBNAME, luaopen_package },
+	{ LUA_STRLIBNAME,    luaopen_string },
+	{ LUA_TABLIBNAME,    luaopen_table },
+	{ NULL, NULL }
+};
+
+void
+luaUqm_loadLib(lua_State *luaState, const luaL_Reg *lib) {
+	lua_pushglobaltable(luaState);
+
+	lua_pushcfunction(luaState, lib->func);
+	lua_pushstring(luaState, lib->name);
+	lua_call(luaState, 1, 1);
+
+	// [-2] -> table globalTable
+	// [-1] -> string libTable
+	lua_setfield(luaState, -2, lib->name);
+	lua_pop(luaState, 1);
+}
+
+void
+luaUqm_loadLibs(lua_State *luaState, const luaL_Reg *libs) {
+	while (libs->func != NULL) {
+		luaUqm_loadLib(luaState, libs);
+		libs++;
+	}
+}
+
+void
+luaUqm_loadSafeDefaultLibs(lua_State *luaState) {
+	luaUqm_loadLibs(luaState, safeLibs);
+}
+
+// Init the lua UQM system.
+void
+luaUqm_init(void) {
+	InstallScriptResType();
+}
+
+// Uninit the lua UQM system. No-op for now.
+void
+luaUqm_uninit(void) {
+}
+
+typedef struct {
+	const char *fileName;
+	uio_Stream *in;
+	char *buf;
+} luaUqm_ReaderState;
+
+static const char *
+luaUqm_reader(lua_State *luaState, void *data, size_t *size) {
+	luaUqm_ReaderState *readerState = (luaUqm_ReaderState *) data;
+
+	size_t numRead = uio_fread(readerState->buf, 1, LOADSCRIPT_BUFSIZE,
+			readerState->in);
+	if (numRead == (size_t) -1) {
+		log_add(log_Error, "luaUqm_loadScript(): Read error readin "
+				"script file '%s'.", readerState->fileName);
+		*size = 0;
+		return NULL;
+	}
+
+	(void) luaState;
+	*size = numRead;
+	return readerState->buf;
+}
+
+void
+luaUqm_prepareEnvironment(lua_State *luaState) {
+	// Redefines _G, to which the global environment (_ENV) of loaded code
+	// is initialised.
+	lua_newtable(luaState);
+	lua_rawseti(luaState, LUA_REGISTRYINDEX, LUA_RIDX_GLOBALS);
+	luaUqm_loadSafeDefaultLibs(luaState);
+}
+
+// On success, the script is on the stack as a function.
+// Returns TRUE on success, and FALSE on error.
+BOOLEAN
+luaUqm_loadScript(lua_State *luaState, uio_DirHandle *dir,
+		const char *fileName) {
+	uio_Stream *in = NULL;
+	char *buf = NULL;
+	luaUqm_ReaderState readerState;
+	
+	log_add(log_Debug, "Loading script '%s'.", fileName);
+	
+	in = uio_fopen(dir, fileName, "rt");
+	if (in == NULL) {
+		log_add(log_Error, "luaUqm_loadScript(): Unable to open script file "
+				"'%s' for reading.", fileName);
+		goto err;
+	}
+
+	buf = malloc(LOADSCRIPT_BUFSIZE);
+	if (buf == NULL)
+		goto err;
+
+	readerState.fileName = fileName;
+	readerState.in = in;
+	readerState.buf = buf;
+
+	if (lua_load (luaState, luaUqm_reader, (void *) &readerState, NULL, NULL)
+			!= LUA_OK) {
+		log_add(log_Error, "luaUqm_loadScript(): lua_load() failed: %s",
+				lua_tostring(luaState, -1));
+		lua_pop(luaState, 1);
+		goto err;
+	}
+
+	free(buf);
+	uio_fclose(in);
+	return TRUE;
+
+err:
+	if (buf != NULL)
+		free(buf);
+
+	if (in != NULL)
+		uio_fclose(in);
+
+	return FALSE;
+}
+
+// Load a script from file and run it.
+BOOLEAN
+luaUqm_runScript(lua_State *luaState, uio_DirHandle *dir,
+		const char *fileName) {
+	if (!luaUqm_loadScript(luaState, dir, fileName)) {
+		// Could not load script. Error is already printed.
+		return FALSE;
+	}
+
+	return luaUqm_callStackFunction(luaState);
+}
+
+// Run all Lua scripts in a directory.
+// Currently, all scripts are run in the same environment.
+// Maybe we do not want this.
+void
+luaUqm_runLuaDir(lua_State *luaState, uio_DirHandle *dirHandle,
+		const char *luaDirName) {
+	uio_DirHandle *luaDir = NULL;
+	uio_DirList *luaFiles = NULL;
+	int fileI;
+
+	luaDir = uio_openDirRelative(dirHandle, luaDirName, 0);
+	if (luaDir == NULL) {
+		log_add(log_Warning, "Warning: Could not open Lua script directory "
+				"'%s'.", luaDirName);
+		goto err;
+	}
+		
+	luaFiles = uio_getDirList(luaDir, "", ".lua", match_MATCH_SUFFIX);
+	if (luaFiles == NULL) {
+		log_add(log_Warning, "Warning: Could not read Lua script directory "
+				"'%s'.", luaDirName);
+		goto err;
+	}
+
+	log_add(log_Debug, "Script directory '%s': loading %d file(s).",
+			luaDirName, luaFiles->numNames);
+	for (fileI = 0; fileI < luaFiles->numNames; fileI++) {
+		const char *fileName = luaFiles->names[fileI];
+		luaUqm_runScript(luaState, luaDir, fileName);
+	}
+
+	uio_DirList_free(luaFiles);
+	uio_closeDir(luaDir);
+	return;
+
+err:
+	if (luaFiles != NULL)
+		uio_DirList_free(luaFiles);
+	if (luaDir != NULL)
+		uio_closeDir(luaDir);
+}
+
+// [-1] -> function fun
+// Call a Lua function which is on the stack, taking no parameters and
+// returning no value.
+// returns FALSE on failure and TRUE on success.
+BOOLEAN
+luaUqm_callStackFunction(lua_State *luaState) {
+	if (lua_pcall(luaState, 0, 0, 0) != 0) {
+		log_add(log_Error, "[script] A script error occurred in "
+				"luaUqm_callStackFunction(): %s", lua_tostring(luaState, -1));
+		lua_pop(luaState, 1);
+				// Pop the error.
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+// Call a Lua function by (char *) name, taking no parameters and returning
+// no value. returns FALSE on failure and TRUE on success.
+BOOLEAN
+luaUqm_callFunction(lua_State *luaState, const char *str) {
+	lua_getglobal(luaState, str);
+	if (!lua_isfunction(luaState, -1)) {
+		lua_pop(luaState, 1);
+		return FALSE;
+	}
+
+	return luaUqm_callStackFunction(luaState);
+}
+
+// Pushes a table on the stack with properties with names and values
+// from enumVals;
+void
+luaUqm_makeEnum(lua_State *luaState, const luaUqm_EnumValue *enumVals) {
+	const luaUqm_EnumValue *enumPtr;
+	size_t enumCount = 0;
+
+	// Count the number of enum values.
+	for (enumPtr = enumVals; enumPtr->name != NULL; enumPtr++)
+		enumCount++;
+
+	lua_createtable(luaState, 0, enumCount);
+	for (enumPtr = enumVals; enumPtr->name != NULL; enumPtr++) {
+		lua_pushinteger(luaState, enumPtr->value);
+
+		// [-2] -> table enumTable
+		// [-1] -> int enumValue
+		lua_setfield(luaState, -2, enumPtr->name);
+	}
+}
+
+#ifdef DEBUG
+void
+luaUqm_dumpStack(lua_State *luaState)
+{
+	int top = lua_gettop(luaState);
+	int stackI;
+
+	for (stackI = 1; stackI <= top; stackI++)
+	{
+		int type = lua_type(luaState, stackI);
+		const char *typeName = lua_typename(luaState, type);
+		log_add(log_Debug, "[%d] (%s)", stackI, typeName);
+		switch (type) {
+			case LUA_TNONE:
+				break;
+			case LUA_TNIL:
+				break;
+			case LUA_TBOOLEAN:
+				log_add(log_Debug, "    %s",
+						lua_toboolean(luaState, stackI) ? "true" : "false");
+				break;
+			case LUA_TLIGHTUSERDATA:
+				break;
+			case LUA_TNUMBER:
+				log_add(log_Debug, "    %g", lua_tonumber(luaState, stackI));
+				break;
+			case LUA_TSTRING:
+				log_add(log_Debug, "    \"%s\"",
+						lua_tostring(luaState, stackI));
+				break;
+			case LUA_TTABLE:
+				break;
+			case LUA_TFUNCTION:
+				break;
+			case LUA_TUSERDATA:
+				break;
+			case LUA_TTHREAD:
+				break;
+		}
+	}
+}
+#endif
+
diff -ruNp src.orig/libs/luauqm/luauqm.h src/libs/luauqm/luauqm.h
--- src.orig/libs/luauqm/luauqm.h	1969-12-31 18:00:00 -0600
+++ src/libs/luauqm/luauqm.h	2017-11-21 19:39:46 -0600
@@ -0,0 +1,79 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _LUAUQM_H
+#define _LUAUQM_H
+
+#ifdef USE_INTERNAL_LUA
+#   include "libs/lua/lua.h"
+#   include "libs/lua/lauxlib.h"
+#else
+#	include <lua.h>
+#	include <lauxlib.h>
+#endif
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+typedef struct luaUqm_EnumValue luaUqm_EnumValue;
+
+#if defined(__cplusplus)
+}
+#endif
+
+#include "libs/compiler.h"
+#include "libs/uio.h"
+
+#include "scriptres.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+struct luaUqm_EnumValue {
+	const char *name;
+	int value;
+};
+
+void luaUqm_init(void);
+void luaUqm_uninit(void);
+
+void luaUqm_prepareEnvironment(lua_State *luaState);
+BOOLEAN luaUqm_loadScript(lua_State *luaState, uio_DirHandle *dir,
+		const char *fileName);
+BOOLEAN luaUqm_runScript(lua_State *luaState, uio_DirHandle *dir,
+		const char *fileName);
+void luaUqm_runLuaDir(lua_State *luaState, uio_DirHandle *dirHandle,
+		const char *luaDirName);
+
+void luaUqm_loadLib(lua_State *luaState, const luaL_Reg *lib);
+void luaUqm_loadLibs(lua_State *luaState, const luaL_Reg *libs);
+void luaUqm_loadSafeDefaultLibs(lua_State *luaState);
+BOOLEAN luaUqm_callStackFunction(lua_State *luaState);
+BOOLEAN luaUqm_callFunction(lua_State *luaState, const char *str);
+void luaUqm_makeEnum(lua_State *luaState, const luaUqm_EnumValue *enumVals);
+
+#ifdef DEBUG
+void luaUqm_dumpStack(lua_State *luaState);
+#endif
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif  /* _LUAUQM_H */
+
diff -ruNp src.orig/libs/luauqm/scriptres.c src/libs/luauqm/scriptres.c
--- src.orig/libs/luauqm/scriptres.c	1969-12-31 18:00:00 -0600
+++ src/libs/luauqm/scriptres.c	2017-11-21 19:39:46 -0600
@@ -0,0 +1,60 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "scriptres.h"
+
+#include <string.h>
+
+
+BOOLEAN
+ReleaseScriptResData (void *data)
+{
+	HFree (data);
+	return TRUE;
+}
+
+static void
+GetScriptResData (const char *pathName, RESOURCE_DATA *resdata)
+{
+	// We don't actually load the data here. We determine the file name, and
+	// load the data when we need it, directly onto the Lua stack.
+	size_t pathNameLen = strlen (pathName);
+	resdata->ptr = HMalloc (pathNameLen + 1);
+	if (resdata->ptr == NULL)
+		return;
+
+	memcpy (resdata->ptr, pathName, pathNameLen + 1);
+}
+
+BOOLEAN
+InstallScriptResType (void)
+{
+	InstallResTypeVectors ("SCRIPT", GetScriptResData, ReleaseScriptResData,
+			NULL);
+	return TRUE;
+}
+
+// Actually just returns the file name of the script.
+char *
+LoadScriptInstance (RESOURCE res)
+{
+	void *data = res_GetResource (res);
+	if (data)
+		res_DetachResource (res);
+
+	return (char *) data;
+}
+
diff -ruNp src.orig/libs/luauqm/scriptres.h src/libs/luauqm/scriptres.h
--- src.orig/libs/luauqm/scriptres.h	1969-12-31 18:00:00 -0600
+++ src/libs/luauqm/scriptres.h	2017-11-21 19:39:46 -0600
@@ -0,0 +1,38 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _SCRIPTRES_H
+#define _SCRIPTRES_H
+
+#include "libs/compiler.h"
+#include "libs/reslib.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+#define LoadScript LoadScriptRes
+
+BOOLEAN ReleaseScriptResData (void *data);
+BOOLEAN InstallScriptResType (void);
+char *LoadScriptInstance (RESOURCE res);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif  /* SCRIPTRES_H */
+
diff -ruNp src.orig/libs/math/Makeinfo src/libs/math/Makeinfo
--- src.orig/libs/math/Makeinfo	2017-11-21 19:39:30 -0600
+++ src/libs/math/Makeinfo	2017-11-21 19:39:47 -0600
@@ -1 +1,2 @@
 uqm_CFILES="random.c random2.c sqrt.c"
+uqm_HFILES="mthintrn.h random.h"
diff -ruNp src.orig/libs/math/random.h src/libs/math/random.h
--- src.orig/libs/math/random.h	2017-11-21 19:39:30 -0600
+++ src/libs/math/random.h	2017-11-21 19:39:47 -0600
@@ -29,13 +29,6 @@
 #ifndef _RANDOM_H
 #define _RANDOM_H
 
-/* ----------------------------DEFINES------------------------------------ */
-
-#define RAND(n) ( (int) ( (unsigned int)TFB_Random() % (n) ) )
-#define SRAND(n) ( (int)TFB_Random() % (n) )
-#define AND_RAND(n) ( (int)TFB_Random() & (n) )
-
-
 /* ----------------------------GLOBALS/EXTERNS---------------------------- */
 
 DWORD TFB_SeedRandom (DWORD seed);
@@ -55,6 +48,7 @@ void RandomContext_Delete (RandomContext
 RandomContext *RandomContext_Copy (const RandomContext *source);
 DWORD RandomContext_Random (RandomContext *context);
 DWORD RandomContext_SeedRandom (RandomContext *context, DWORD new_seed);
+DWORD RandomContext_GetSeed (RandomContext *context);
 
 
 #endif  /* _RANDOM_H */
diff -ruNp src.orig/libs/math/random2.c src/libs/math/random2.c
--- src.orig/libs/math/random2.c	2017-11-21 19:39:30 -0600
+++ src/libs/math/random2.c	2017-11-21 19:39:47 -0600
@@ -82,4 +82,8 @@ RandomContext_SeedRandom (RandomContext
 	return old_seed;
 }
 
-
+DWORD
+RandomContext_GetSeed (RandomContext *context)
+{
+	return context->seed;
+}
diff -ruNp src.orig/libs/mathlib.h src/libs/mathlib.h
--- src.orig/libs/mathlib.h	2017-11-21 19:39:31 -0600
+++ src/libs/mathlib.h	2017-11-21 19:39:47 -0600
@@ -20,10 +20,19 @@
 #define _MATHLIB_H
 
 #include "libs/compiler.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #include "math/random.h"
 
 extern COUNT square_root (DWORD value);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _MATHLIB_H */
 
 
diff -ruNp src.orig/libs/md5/Makeinfo src/libs/md5/Makeinfo
--- src.orig/libs/md5/Makeinfo	2017-11-21 19:39:31 -0600
+++ src/libs/md5/Makeinfo	2017-11-21 19:39:47 -0600
@@ -1,2 +1,2 @@
 uqm_CFILES="md5.c"
-
+uqm_HFILES="md5.h"
diff -ruNp src.orig/libs/md5.h src/libs/md5.h
--- src.orig/libs/md5.h	2017-11-21 19:39:31 -0600
+++ src/libs/md5.h	2017-11-21 19:39:47 -0600
@@ -19,7 +19,15 @@
 #ifndef _LIB_MD5_H
 #define _LIB_MD5_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #include "md5/md5.h"
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _LIB_MD5_H */
 
diff -ruNp src.orig/libs/memlib.h src/libs/memlib.h
--- src.orig/libs/memlib.h	2017-11-21 19:39:31 -0600
+++ src/libs/memlib.h	2017-11-21 19:39:47 -0600
@@ -19,15 +19,25 @@
 #ifndef _MEMLIB_H
 #define _MEMLIB_H
 
+#include <stddef.h>
+
 #include "types.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern bool mem_init (void);
 extern bool mem_uninit (void);
 
-extern void *HMalloc (int size);
+extern void *HMalloc (size_t size);
 extern void HFree (void *p);
-extern void *HCalloc (int size);
-extern void *HRealloc (void *p, int size);
+extern void *HCalloc (size_t size);
+extern void *HRealloc (void *p, size_t size);
+
+#if defined(__cplusplus)
+}
+#endif
 
 #endif /* _MEMLIB_H */
 
diff -ruNp src.orig/libs/memory/w_memlib.c src/libs/memory/w_memlib.c
--- src.orig/libs/memory/w_memlib.c	2017-11-21 19:39:31 -0600
+++ src/libs/memory/w_memlib.c	2017-11-21 19:39:47 -0600
@@ -38,68 +38,47 @@ mem_uninit (void)
 }
 
 void *
-HMalloc (int size)
+HMalloc (size_t size)
 {
-	void *p;
-
-	if (size == 0)
-		return NULL;
-
-	if (size < 0) 
-	{
-		log_add (log_Fatal, "HMalloc() FATAL: "
-				"request for negative amount of memory %d!", size);
-		fflush (stderr);
-		explode ();
-	}
-
-	p = malloc (size);
-	if (p == NULL) 
+	void *p = malloc (size);
+	if (p == NULL && size > 0)
 	{
 		log_add (log_Fatal, "HMalloc() FATAL: out of memory.");
 		fflush (stderr);
 		explode ();
 	}
-	return (p);
+
+	return p;
 }
 
 void
 HFree (void *p)
 {
-	if (p)
-	{
-		free (p);
-	}
+	free (p);
 }
 
 void *
-HCalloc (int size)
+HCalloc (size_t size)
 {
 	void *p;
 
 	p = HMalloc (size);
 	memset (p, 0, size);
 
-	return (p);
+	return p;
 }
 
 void *
-HRealloc (void *p, int size)
+HRealloc (void *p, size_t size)
 {
-	if (size < 0) 
-	{
-		log_add (log_Fatal, "HRealloc() FATAL: "
-				"request for negative amount of memory %d!", size);
-		fflush (stderr);
-		explode ();
-	}
-
 	p = realloc (p, size);
-	if (!p && size > 0) 
+	if (p == NULL && size > 0)
 	{
 		log_add (log_Fatal, "HRealloc() FATAL: out of memory.");
 		fflush (stderr);
 		explode ();
 	}
+
 	return p;
 }
+
diff -ruNp src.orig/libs/mikmod/Makeinfo src/libs/mikmod/Makeinfo
--- src.orig/libs/mikmod/Makeinfo	2017-11-21 19:39:31 -0600
+++ src/libs/mikmod/Makeinfo	2017-11-21 19:39:47 -0600
@@ -2,3 +2,4 @@ uqm_CFILES="drv_nos.c load_it.c load_mod
 		mdreg.c mdriver.c mloader.c
 		mlreg.c mlutil.c mmalloc.c mmerror.c mmio.c mplayer.c munitrk.c
 		mwav.c npertab.c sloader.c virtch.c virtch2.c virtch_common.c"
+uqm_HFILES="mikmod_build.h mikmod.h mikmod_internals.h"
diff -ruNp src.orig/libs/mikmod/drv_nos.c src/libs/mikmod/drv_nos.c
--- src.orig/libs/mikmod/drv_nos.c	2017-11-21 19:39:31 -0600
+++ src/libs/mikmod/drv_nos.c	2017-11-21 19:39:47 -0600
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: drv_nos.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   Driver for no output
 
diff -ruNp src.orig/libs/mikmod/load_it.c src/libs/mikmod/load_it.c
--- src.orig/libs/mikmod/load_it.c	2017-11-21 19:39:31 -0600
+++ src/libs/mikmod/load_it.c	2017-11-21 19:39:47 -0600
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_it.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   Impulse tracker (IT) module loader
 
diff -ruNp src.orig/libs/mikmod/load_mod.c src/libs/mikmod/load_mod.c
--- src.orig/libs/mikmod/load_mod.c	2017-11-21 19:39:31 -0600
+++ src/libs/mikmod/load_mod.c	2017-11-21 19:39:47 -0600
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_mod.c 2421 2006-08-19 00:36:21Z avolkov $
+  $Id$
 
   Generic MOD loader (Protracker, StarTracker, FastTracker, etc)
 
diff -ruNp src.orig/libs/mikmod/load_s3m.c src/libs/mikmod/load_s3m.c
--- src.orig/libs/mikmod/load_s3m.c	2017-11-21 19:39:31 -0600
+++ src/libs/mikmod/load_s3m.c	2017-11-21 19:39:47 -0600
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_s3m.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   Screamtracker (S3M) module loader
 
diff -ruNp src.orig/libs/mikmod/load_stm.c src/libs/mikmod/load_stm.c
--- src.orig/libs/mikmod/load_stm.c	2017-11-21 19:39:31 -0600
+++ src/libs/mikmod/load_stm.c	2017-11-21 19:39:47 -0600
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_stm.c 2421 2006-08-19 00:36:21Z avolkov $
+  $Id$
 
   Screamtracker 2 (STM) module loader
 
diff -ruNp src.orig/libs/mikmod/load_xm.c src/libs/mikmod/load_xm.c
--- src.orig/libs/mikmod/load_xm.c	2017-11-21 19:39:31 -0600
+++ src/libs/mikmod/load_xm.c	2017-11-21 19:39:47 -0600
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_xm.c 2421 2006-08-19 00:36:21Z avolkov $
+  $Id$
 
   Fasttracker (XM) module loader
 
diff -ruNp src.orig/libs/mikmod/mdreg.c src/libs/mikmod/mdreg.c
--- src.orig/libs/mikmod/mdreg.c	2017-11-21 19:39:31 -0600
+++ src/libs/mikmod/mdreg.c	2017-11-21 19:39:47 -0600
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mdreg.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   Routine for registering all drivers in libmikmod for the current platform.
 
diff -ruNp src.orig/libs/mikmod/mdriver.c src/libs/mikmod/mdriver.c
--- src.orig/libs/mikmod/mdriver.c	2017-11-21 19:39:31 -0600
+++ src/libs/mikmod/mdriver.c	2017-11-21 19:39:47 -0600
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mdriver.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   These routines are used to access the available soundcard drivers.
 
diff -ruNp src.orig/libs/mikmod/mikmod.h src/libs/mikmod/mikmod.h
--- src.orig/libs/mikmod/mikmod.h	2017-11-21 19:39:31 -0600
+++ src/libs/mikmod/mikmod.h	2017-11-21 19:39:47 -0600
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mikmod.h 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   MikMod sound library include file
 
diff -ruNp src.orig/libs/mikmod/mikmod_internals.h src/libs/mikmod/mikmod_internals.h
--- src.orig/libs/mikmod/mikmod_internals.h	2017-11-21 19:39:31 -0600
+++ src/libs/mikmod/mikmod_internals.h	2017-11-21 19:39:47 -0600
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mikmod_internals.h 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   MikMod sound library internal definitions
 
diff -ruNp src.orig/libs/mikmod/mloader.c src/libs/mikmod/mloader.c
--- src.orig/libs/mikmod/mloader.c	2017-11-21 19:39:31 -0600
+++ src/libs/mikmod/mloader.c	2017-11-21 19:39:47 -0600
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mloader.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   These routines are used to access the available module loaders
 
diff -ruNp src.orig/libs/mikmod/mlreg.c src/libs/mikmod/mlreg.c
--- src.orig/libs/mikmod/mlreg.c	2017-11-21 19:39:31 -0600
+++ src/libs/mikmod/mlreg.c	2017-11-21 19:39:47 -0600
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mlreg.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   Routine for registering all loaders in libmikmod for the current platform.
 
diff -ruNp src.orig/libs/mikmod/mlutil.c src/libs/mikmod/mlutil.c
--- src.orig/libs/mikmod/mlutil.c	2017-11-21 19:39:31 -0600
+++ src/libs/mikmod/mlutil.c	2017-11-21 19:39:47 -0600
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mlutil.c 2421 2006-08-19 00:36:21Z avolkov $
+  $Id$
 
   Utility functions for the module loader
 
diff -ruNp src.orig/libs/mikmod/mmalloc.c src/libs/mikmod/mmalloc.c
--- src.orig/libs/mikmod/mmalloc.c	2017-11-21 19:39:31 -0600
+++ src/libs/mikmod/mmalloc.c	2017-11-21 19:39:47 -0600
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mmalloc.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   Dynamic memory routines
 
diff -ruNp src.orig/libs/mikmod/mmerror.c src/libs/mikmod/mmerror.c
--- src.orig/libs/mikmod/mmerror.c	2017-11-21 19:39:31 -0600
+++ src/libs/mikmod/mmerror.c	2017-11-21 19:39:47 -0600
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mmerror.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   Error handling functions.
   Register an error handler with _mm_RegisterErrorHandler() and you're all set.
diff -ruNp src.orig/libs/mikmod/mmio.c src/libs/mikmod/mmio.c
--- src.orig/libs/mikmod/mmio.c	2017-11-21 19:39:31 -0600
+++ src/libs/mikmod/mmio.c	2017-11-21 19:39:47 -0600
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mmio.c 2421 2006-08-19 00:36:21Z avolkov $
+  $Id$
 
   Portable file I/O routines
 
diff -ruNp src.orig/libs/mikmod/mplayer.c src/libs/mikmod/mplayer.c
--- src.orig/libs/mikmod/mplayer.c	2017-11-21 19:39:31 -0600
+++ src/libs/mikmod/mplayer.c	2017-11-21 19:39:47 -0600
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mplayer.c 2421 2006-08-19 00:36:21Z avolkov $
+  $Id$
 
   The Protracker Player Driver
 
diff -ruNp src.orig/libs/mikmod/munitrk.c src/libs/mikmod/munitrk.c
--- src.orig/libs/mikmod/munitrk.c	2017-11-21 19:39:31 -0600
+++ src/libs/mikmod/munitrk.c	2017-11-21 19:39:47 -0600
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: munitrk.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   All routines dealing with the manipulation of UNITRK streams
 
diff -ruNp src.orig/libs/mikmod/mwav.c src/libs/mikmod/mwav.c
--- src.orig/libs/mikmod/mwav.c	2017-11-21 19:39:31 -0600
+++ src/libs/mikmod/mwav.c	2017-11-21 19:39:47 -0600
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mwav.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   WAV sample loader
 
diff -ruNp src.orig/libs/mikmod/npertab.c src/libs/mikmod/npertab.c
--- src.orig/libs/mikmod/npertab.c	2017-11-21 19:39:31 -0600
+++ src/libs/mikmod/npertab.c	2017-11-21 19:39:47 -0600
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: npertab.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   MOD format period table.  Used by both the MOD and M15 (15-inst mod) Loaders.
 
diff -ruNp src.orig/libs/mikmod/sloader.c src/libs/mikmod/sloader.c
--- src.orig/libs/mikmod/sloader.c	2017-11-21 19:39:31 -0600
+++ src/libs/mikmod/sloader.c	2017-11-21 19:39:47 -0600
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: sloader.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   Routines for loading samples. The sample loader utilizes the routines
   provided by the "registered" sample loader.
diff -ruNp src.orig/libs/mikmod/virtch.c src/libs/mikmod/virtch.c
--- src.orig/libs/mikmod/virtch.c	2017-11-21 19:39:31 -0600
+++ src/libs/mikmod/virtch.c	2017-11-21 19:39:47 -0600
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: virtch.c 2421 2006-08-19 00:36:21Z avolkov $
+  $Id$
 
   Sample mixing routines, using a 32 bits mixing buffer.
 
diff -ruNp src.orig/libs/mikmod/virtch2.c src/libs/mikmod/virtch2.c
--- src.orig/libs/mikmod/virtch2.c	2017-11-21 19:39:31 -0600
+++ src/libs/mikmod/virtch2.c	2017-11-21 19:39:47 -0600
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: virtch2.c 2421 2006-08-19 00:36:21Z avolkov $
+  $Id$
 
   High-quality sample mixing routines, using a 32 bits mixing buffer,
   interpolation, and sample smoothing to improve sound quality and remove
diff -ruNp src.orig/libs/mikmod/virtch_common.c src/libs/mikmod/virtch_common.c
--- src.orig/libs/mikmod/virtch_common.c	2017-11-21 19:39:31 -0600
+++ src/libs/mikmod/virtch_common.c	2017-11-21 19:39:47 -0600
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: virtch_common.c 2421 2006-08-19 00:36:21Z avolkov $
+  $Id$
 
   Common source parts between the two software mixers.
   This file is probably the ugliest part of libmikmod...
diff -ruNp src.orig/libs/misc.h src/libs/misc.h
--- src.orig/libs/misc.h	2017-11-21 19:39:31 -0600
+++ src/libs/misc.h	2017-11-21 19:39:47 -0600
@@ -26,6 +26,10 @@
 #include <stdlib.h>
 #include "port.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 
 extern int TFB_DEBUG_HALT;
 
@@ -47,12 +51,16 @@ static inline void explode (void)
 static inline void *
 unconst(const void *arg) {
 	union {
-		char *c;
-		const char *cc;
+		void *c;
+		const void *cc;
 	} u;
 	u.cc = arg;
 	return u.c;
 }
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif
 
diff -ruNp src.orig/libs/net.h src/libs/net.h
--- src.orig/libs/net.h	2017-11-21 19:39:31 -0600
+++ src/libs/net.h	2017-11-21 19:39:47 -0600
@@ -19,11 +19,19 @@
 #ifndef _NET_H
 #define _NET_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #include "network/network.h"
 #include "network/netmanager/netmanager.h"
 #include "network/connect/connect.h"
 #include "network/connect/listen.h"
 #include "network/connect/resolve.h"
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _NET_H */
 
diff -ruNp src.orig/libs/network/Makeinfo src/libs/network/Makeinfo
--- src.orig/libs/network/Makeinfo	2017-11-21 19:39:31 -0600
+++ src/libs/network/Makeinfo	2017-11-21 19:39:47 -0600
@@ -1,9 +1,12 @@
 uqm_SUBDIRS="connect netmanager socket"
 uqm_CFILES="netport.c"
+uqm_HFILES="bytesex.h netport.h network.h"
+
 if [ -n "$uqm_USE_WINSOCK" ]; then
 	uqm_CFILES="$uqm_CFILES network_win.c"
 	if [ -n "$MACRO___MINGW32__" ]; then
 		uqm_CFILES="$uqm_CFILES wspiapiwrap.c"
+		uqm_HFILES="$uqm_HFILES wspiapiwrap.h"
 	fi
 else
 	uqm_CFILES="$uqm_CFILES network_bsd.c"
diff -ruNp src.orig/libs/network/connect/Makeinfo src/libs/network/connect/Makeinfo
--- src.orig/libs/network/connect/Makeinfo	2017-11-21 19:39:31 -0600
+++ src/libs/network/connect/Makeinfo	2017-11-21 19:39:47 -0600
@@ -1,2 +1,2 @@
 uqm_CFILES="connect.c listen.c resolve.c"
-
+uqm_HFILES="connect.h listen.h resolve.h"
diff -ruNp src.orig/libs/network/connect/connect.c src/libs/network/connect/connect.c
--- src.orig/libs/network/connect/connect.c	2017-11-21 19:39:31 -0600
+++ src/libs/network/connect/connect.c	2017-11-21 19:39:47 -0600
@@ -57,7 +57,7 @@ static void doConnectErrorCallback(Conne
 static ConnectState *
 ConnectState_alloc(void) {
 	return (ConnectState *) malloc(sizeof (ConnectState));
-};
+}
 
 static void
 ConnectState_free(ConnectState *connectState) {
diff -ruNp src.orig/libs/network/connect/listen.c src/libs/network/connect/listen.c
--- src.orig/libs/network/connect/listen.c	2017-11-21 19:39:31 -0600
+++ src/libs/network/connect/listen.c	2017-11-21 19:39:47 -0600
@@ -56,7 +56,7 @@ static void doListenErrorCallback(Listen
 static ListenState *
 ListenState_alloc(void) {
 	return (ListenState *) malloc(sizeof (ListenState));
-};
+}
 
 static void
 ListenState_free(ListenState *listenState) {
diff -ruNp src.orig/libs/network/connect/resolve.c src/libs/network/connect/resolve.c
--- src.orig/libs/network/connect/resolve.c	2017-11-21 19:39:31 -0600
+++ src/libs/network/connect/resolve.c	2017-11-21 19:39:47 -0600
@@ -33,7 +33,7 @@
 static ResolveState *
 ResolveState_new(void) {
 	return (ResolveState *) malloc(sizeof (ResolveState));
-};
+}
 
 static void
 ResolveState_free(ResolveState *resolveState) {
diff -ruNp src.orig/libs/network/netmanager/Makeinfo src/libs/network/netmanager/Makeinfo
--- src.orig/libs/network/netmanager/Makeinfo	2017-11-21 19:39:31 -0600
+++ src/libs/network/netmanager/Makeinfo	2017-11-21 19:39:47 -0600
@@ -1,8 +1,11 @@
 uqm_CFILES="ndesc.c"
+uqm_HFILES="ndesc.h netmanager.h"
+
 if [ -n "$uqm_USE_WINSOCK" ]; then
 	uqm_CFILES="$uqm_CFILES netmanager_win.c"
+	uqm_HFILES="$uqm_HFILES netmanager_win.h"
 else
 	uqm_CFILES="$uqm_CFILES netmanager_bsd.c"
+	uqm_HFILES="$uqm_HFILES netmanager_bsd.h"
 fi
 
-
diff -ruNp src.orig/libs/network/socket/Makeinfo src/libs/network/socket/Makeinfo
--- src.orig/libs/network/socket/Makeinfo	2017-11-21 19:39:32 -0600
+++ src/libs/network/socket/Makeinfo	2017-11-21 19:39:48 -0600
@@ -1,7 +1,11 @@
 uqm_CFILES="socket.c"
+uqm_HFILES="socket.h"
+
 if [ -n "$uqm_USE_WINSOCK" ]; then
 	uqm_CFILES="$uqm_CFILES socket_win.c"
+	uqm_HFILES="$uqm_HFILES socket_win.h"
 else
 	uqm_CFILES="$uqm_CFILES socket_bsd.c"
+	uqm_HFILES="$uqm_CFILES socket_bsd.h"
 fi
 
diff -ruNp src.orig/libs/network/socket/socket.h src/libs/network/socket/socket.h
--- src.orig/libs/network/socket/socket.h	2017-11-21 19:39:32 -0600
+++ src/libs/network/socket/socket.h	2017-11-21 19:39:48 -0600
@@ -80,7 +80,11 @@ int Socket_bind(Socket *sock, const stru
 int Socket_listen(Socket *sock, int backlog);
 Socket *Socket_accept(Socket *sock, struct sockaddr *addr, socklen_t *addrLen);
 ssize_t Socket_send(Socket *sock, const void *buf, size_t len, int flags);
+ssize_t Socket_sendto(Socket *sock, const void *buf, size_t len, int flags,
+		const struct sockaddr *addr, socklen_t addrLen);
 ssize_t Socket_recv(Socket *sock, void *buf, size_t len, int flags);
+ssize_t Socket_recvfrom(Socket *sock, void *buf, size_t len, int flags,
+		struct sockaddr *from, socklen_t *fromLen);
 
 int Socket_setNonBlocking(Socket *sock);
 int Socket_setReuseAddr(Socket *sock);
diff -ruNp src.orig/libs/network/socket/socket_bsd.c src/libs/network/socket/socket_bsd.c
--- src.orig/libs/network/socket/socket_bsd.c	2017-11-21 19:39:32 -0600
+++ src/libs/network/socket/socket_bsd.c	2017-11-21 19:39:48 -0600
@@ -130,10 +130,22 @@ Socket_send(Socket *sock, const void *bu
 }
 
 ssize_t
+Socket_sendto(Socket *sock, const void *buf, size_t len, int flags,
+		const struct sockaddr *addr, socklen_t addrLen) {
+	return sendto(sock->fd, buf, len, flags, addr, addrLen);
+}
+
+ssize_t
 Socket_recv(Socket *sock, void *buf, size_t len, int flags) {
 	return recv(sock->fd, buf, len, flags);
 }
 
+ssize_t
+Socket_recvfrom(Socket *sock, void *buf, size_t len, int flags,
+		struct sockaddr *from, socklen_t *fromLen) {
+	return recvfrom(sock->fd, buf, len, flags, from, fromLen);
+}
+
 int
 Socket_setNonBlocking(Socket *sock) {
 	int flags;
diff -ruNp src.orig/libs/network/socket/socket_win.c src/libs/network/socket/socket_win.c
--- src.orig/libs/network/socket/socket_win.c	2017-11-21 19:39:32 -0600
+++ src/libs/network/socket/socket_win.c	2017-11-21 19:39:48 -0600
@@ -160,6 +160,20 @@ Socket_send(Socket *sock, const void *bu
 }
 
 ssize_t
+Socket_sendto(Socket *sock, const void *buf, size_t len, int flags,
+		const struct sockaddr *addr, socklen_t addrLen) {
+	int sendResult;
+
+	sendResult = sendto(sock->sock, buf, len, flags, addr, addrLen);
+	if (sendResult == SOCKET_ERROR) {
+		errno = getWinsockErrno();
+		return -1;
+	}
+
+	return sendResult;
+}
+
+ssize_t
 Socket_recv(Socket *sock, void *buf, size_t len, int flags) {
 	int recvResult;
 
@@ -167,6 +181,20 @@ Socket_recv(Socket *sock, void *buf, siz
 	if (recvResult == SOCKET_ERROR) {
 		errno = getWinsockErrno();
 		return -1;
+	}
+
+	return recvResult;
+}
+
+ssize_t
+Socket_recvfrom(Socket *sock, void *buf, size_t len, int flags,
+		struct sockaddr *from, socklen_t *fromLen) {
+	int recvResult;
+
+	recvResult = recvfrom(sock->sock, buf, len, flags, from, fromLen);
+	if (recvResult == SOCKET_ERROR) {
+		errno = getWinsockErrno();
+		return -1;
 	}
 
 	return recvResult;
diff -ruNp src.orig/libs/platform.h src/libs/platform.h
--- src.orig/libs/platform.h	2017-11-21 19:39:32 -0600
+++ src/libs/platform.h	2017-11-21 19:39:48 -0600
@@ -17,6 +17,10 @@
 #ifndef PLATFORM_H_
 #define PLATFORM_H_
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #if defined(USE_PLATFORM_ACCEL)
 #	if defined(__GNUC__) && (defined(i386) || defined(__x86_64__))
 #		define MMX_ASM
@@ -46,4 +50,8 @@ typedef enum
 
 extern PLATFORM_TYPE force_platform;
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* PLATFORM_H_ */
diff -ruNp src.orig/libs/reslib.h src/libs/reslib.h
--- src.orig/libs/reslib.h	2017-11-21 19:39:32 -0600
+++ src/libs/reslib.h	2017-11-21 19:39:48 -0600
@@ -25,6 +25,10 @@
 #include "libs/memlib.h"
 #include "libs/uio.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef struct resource_index_desc RESOURCE_INDEX_DESC;
 typedef RESOURCE_INDEX_DESC *RESOURCE_INDEX;
 
@@ -33,6 +37,7 @@ typedef const char *RESOURCE;
 typedef union {
 	DWORD num;
 	void *ptr;
+	const char *str;
 } RESOURCE_DATA;
 
 #define NULL_RESOURCE NULL
@@ -78,8 +83,16 @@ void *GetResourceData (uio_Stream *fp, D
 #define AllocResourceData HMalloc
 BOOLEAN FreeResourceData (void *);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #include "libs/strlib.h"
 #include "libs/gfxlib.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
 		// For Color
 
 typedef STRING_TABLE DIRENTRY_REF;
@@ -120,4 +133,8 @@ void res_PutColor (const char *key, Colo
 
 BOOLEAN res_Remove (const char *key);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _RESLIB_H */
diff -ruNp src.orig/libs/resource/Makeinfo src/libs/resource/Makeinfo
--- src.orig/libs/resource/Makeinfo	2017-11-21 19:39:32 -0600
+++ src/libs/resource/Makeinfo	2017-11-21 19:39:48 -0600
@@ -1,2 +1,3 @@
 uqm_CFILES="direct.c filecntl.c getres.c loadres.c stringbank.c
 		propfile.c resinit.c"
+uqm_HFILES="index.h propfile.h resintrn.h stringbank.h"
diff -ruNp src.orig/libs/resource/index.h src/libs/resource/index.h
--- src.orig/libs/resource/index.h	2017-11-21 19:39:32 -0600
+++ src/libs/resource/index.h	2017-11-21 19:39:48 -0600
@@ -19,19 +19,22 @@
 #ifndef _INDEX_H
 #define _INDEX_H
 
+typedef struct resource_handlers ResourceHandlers;
+typedef struct resource_desc ResourceDesc;
+
 #include <stdio.h>
 #include "libs/reslib.h"
 #include "libs/uio/charhashtable.h"
 
-typedef struct resource_handlers
+struct resource_handlers
 {
 	const char *resType;
 	ResourceLoadFun *loadFun;
 	ResourceFreeFun *freeFun;
 	ResourceStringFun *toString;
-} ResourceHandlers;
+};
 
-typedef struct resource_desc
+struct resource_desc
 {
 	RESOURCE res_id;
 	char *fname;
@@ -39,7 +42,7 @@ typedef struct resource_desc
 	RESOURCE_DATA resdata;
 	// refcount is rudimentary as nothing really frees the descriptors
 	unsigned refcount;
-} ResourceDesc;
+};
 
 struct resource_index_desc
 {
diff -ruNp src.orig/libs/resource/resinit.c src/libs/resource/resinit.c
--- src.orig/libs/resource/resinit.c	2017-11-21 19:39:32 -0600
+++ src/libs/resource/resinit.c	2017-11-21 19:39:48 -0600
@@ -34,7 +34,8 @@
 static RESOURCE_INDEX
 allocResourceIndex (void) {
 	RESOURCE_INDEX ndx = HMalloc (sizeof (RESOURCE_INDEX_DESC));
-	ndx->map = CharHashTable_newHashTable (NULL, NULL, NULL, NULL, 0, 0.85, 0.9);
+	ndx->map = CharHashTable_newHashTable (NULL, NULL, NULL, NULL, NULL,
+			0, 0.85, 0.9);
 	return ndx;
 }
 
@@ -138,7 +139,7 @@ process_resource_desc (const char *key,
 static void
 UseDescriptorAsRes (const char *descriptor, RESOURCE_DATA *resdata)
 {
-	resdata->ptr = (void *)descriptor;
+	resdata->str = descriptor;
 }
 
 static void
@@ -285,7 +286,7 @@ fail:
 static void
 RawDescriptor (RESOURCE_DATA *resdata, char *buf, unsigned int size)
 {
-	snprintf (buf, size, "%s", (char *)resdata->ptr);
+	snprintf (buf, size, "%s", resdata->str);
 }
 
 static void
@@ -474,12 +475,12 @@ res_GetString (const char *key)
 {
 	RESOURCE_INDEX idx = _get_current_index_header ();
 	ResourceDesc *desc = lookupResourceDesc (idx, key);
-	if (!desc || !desc->resdata.ptr || strcmp(desc->vtable->resType, "STRING"))
+	if (!desc || !desc->resdata.str || strcmp(desc->vtable->resType, "STRING"))
 		return "";
 	/* TODO: Work out exact STRING semantics, specifically, the lifetime of
 	 *   the returned value. If caller is allowed to reference the returned
 	 *   value forever, STRING has to be ref-counted. */
-	return (const char *)desc->resdata.ptr;
+	return desc->resdata.str;
 }
 
 void
@@ -488,24 +489,24 @@ res_PutString (const char *key, const ch
 	RESOURCE_INDEX idx = _get_current_index_header ();
 	ResourceDesc *desc = lookupResourceDesc (idx, key);
 	int srclen, dstlen;
-	if (!desc || !desc->resdata.ptr || strcmp(desc->vtable->resType, "STRING"))
+	if (!desc || !desc->resdata.str || strcmp(desc->vtable->resType, "STRING"))
 	{
 		/* TODO: This is kind of roundabout. We can do better by refactoring newResourceDesc */
 		process_resource_desc(key, "STRING:undefined");
 		desc = lookupResourceDesc (idx, key);
 	}
 	srclen = strlen (value);
-	dstlen = strlen (desc->resdata.ptr);
+	dstlen = strlen (desc->fname);
 	if (srclen > dstlen) {
 		char *newValue = HMalloc(srclen + 1);
 		char *oldValue = desc->fname;
 		log_add(log_Warning, "Reallocating string space for '%s'", key);
 		strncpy (newValue, value, srclen + 1);
-		desc->resdata.ptr = newValue;
+		desc->resdata.str = newValue;
 		desc->fname = newValue;
 		HFree (oldValue);
 	} else {
-		strncpy (desc->resdata.ptr, value, srclen + 1);
+		strncpy (desc->fname, value, srclen + 1);
 	}
 }
 
diff -ruNp src.orig/libs/scriptlib.h src/libs/scriptlib.h
--- src.orig/libs/scriptlib.h	1969-12-31 18:00:00 -0600
+++ src/libs/scriptlib.h	2017-11-21 19:39:48 -0600
@@ -0,0 +1,23 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _SCRIPTLIB_H
+#define _SCRIPTLIB_H
+
+#include "luauqm/luauqm.h"
+
+#endif  /* _SCRIPTLIB_H */
+
diff -ruNp src.orig/libs/sndlib.h src/libs/sndlib.h
--- src.orig/libs/sndlib.h	2017-11-21 19:39:32 -0600
+++ src/libs/sndlib.h	2017-11-21 19:39:48 -0600
@@ -22,6 +22,10 @@
 #include "port.h"
 #include "libs/strlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef STRING_TABLE SOUND_REF;
 typedef STRING SOUND;
 // SOUNDPTR is really a TFB_SoundSample**
@@ -95,5 +99,9 @@ extern void WaitForSoundEnd (COUNT Chann
 
 extern DWORD FadeMusic (BYTE end_vol, SIZE TimeInterval);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _SNDLIB_H */
 
diff -ruNp src.orig/libs/sound/Makeinfo src/libs/sound/Makeinfo
--- src.orig/libs/sound/Makeinfo	2017-11-21 19:39:32 -0600
+++ src/libs/sound/Makeinfo	2017-11-21 19:39:49 -0600
@@ -6,4 +6,4 @@ else
 fi
 
 uqm_CFILES="audiocore.c fileinst.c resinst.c sound.c sfx.c music.c stream.c trackplayer.c"
-
+uqm_HFILES="audiocore.h sndintrn.h sound.h stream.h trackint.h trackplayer.h"
diff -ruNp src.orig/libs/sound/audiocore.c src/libs/sound/audiocore.c
--- src.orig/libs/sound/audiocore.c	2017-11-21 19:39:32 -0600
+++ src/libs/sound/audiocore.c	2017-11-21 19:39:48 -0600
@@ -20,6 +20,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include "audiocore.h"
+#include "sound.h"
 #include "libs/log.h"
 
 static audio_Driver audiodrv;
@@ -76,6 +77,10 @@ initAudio (sint32 driver, sint32 flags)
 				"NOTICE: Try running UQM with '--sound=none' option");
 		exit (EXIT_FAILURE);
 	}
+
+	SetSFXVolume (sfxVolumeScale);
+	SetSpeechVolume (speechVolumeScale);
+	SetMusicVolume (musicVolume);
 	
 	audio_inited = true;
 	
diff -ruNp src.orig/libs/sound/decoders/Makeinfo src/libs/sound/decoders/Makeinfo
--- src.orig/libs/sound/decoders/Makeinfo	2017-11-21 19:39:32 -0600
+++ src/libs/sound/decoders/Makeinfo	2017-11-21 19:39:49 -0600
@@ -1,6 +1,8 @@
 uqm_CFILES="decoder.c aiffaud.c wav.c dukaud.c modaud.c"
+uqm_HFILES="aiffaud.h decoder.h dukaud.h modaud.h wav.h"
 
 if [ "$uqm_OGGVORBIS" '!=' "none" ]; then
 	uqm_CFILES="$uqm_CFILES oggaud.c"
+	uqm_HFILES="$uqm_HFILES oggaud.h"
 fi
 
diff -ruNp src.orig/libs/sound/decoders/aiffaud.c src/libs/sound/decoders/aiffaud.c
--- src.orig/libs/sound/decoders/aiffaud.c	2017-11-21 19:39:32 -0600
+++ src/libs/sound/decoders/aiffaud.c	2017-11-21 19:39:48 -0600
@@ -307,7 +307,7 @@ aifa_readCommonChunk (TFB_AiffSoundDecod
 {
 	int bytes;
 
-	memset(fmt, sizeof(*fmt), 0);
+	memset(fmt, 0, sizeof(*fmt));
 	if (size < AIFF_COMM_SIZE)
 	{
 		aifa->last_error = aifae_BadFile;
@@ -369,7 +369,7 @@ aifa_Open (THIS_PTR, uio_DirHandle *dir,
 	aifa->max_pcm = 0;
 	aifa->data_ofs = 0;
 	memset(&aifa->fmtHdr, 0, sizeof(aifa->fmtHdr));
-	memset(aifa->prev_val, sizeof(aifa->prev_val), 0);
+	memset(aifa->prev_val, 0, sizeof(aifa->prev_val));
 
 	// read wave header
 	if (!aifa_readFileHeader (aifa, &fileHdr))
@@ -635,7 +635,7 @@ aifa_Seek (THIS_PTR, uint32 pcm_pos)
 
 	// reset previous values for SDX2 on seek ops
 	// the delta will recover faster with reset
-	memset(aifa->prev_val, sizeof(aifa->prev_val), 0);
+	memset(aifa->prev_val, 0, sizeof(aifa->prev_val));
 
 	return pcm_pos;
 }
diff -ruNp src.orig/libs/sound/decoders/dukaud.c src/libs/sound/decoders/dukaud.c
--- src.orig/libs/sound/decoders/dukaud.c	2017-11-21 19:39:32 -0600
+++ src/libs/sound/decoders/dukaud.c	2017-11-21 19:39:48 -0600
@@ -105,7 +105,7 @@ typedef struct
 
 static const TFB_DecoderFormats* duka_formats = NULL;
 
-sint32
+static sint32
 duka_readAudFrameHeader (TFB_DuckSoundDecoder* duka, uint32 iframe,
 		DukAud_AudSubframe* aud)
 {
@@ -246,7 +246,7 @@ decode_nibbles (sint16 *output, sint32 o
 }
 // *** END part copied from MPlayer ***
 
-sint32
+static sint32
 duka_decodeFrame (TFB_DuckSoundDecoder* duka, DukAud_AudSubframe* header,
 		uint8* input)
 {
@@ -273,7 +273,7 @@ duka_decodeFrame (TFB_DuckSoundDecoder*
 }
 
 
-sint32
+static sint32
 duka_readNextFrame (TFB_DuckSoundDecoder* duka)
 {
 	DukAud_FrameHeader hdr;
diff -ruNp src.orig/libs/sound/decoders/modaud.c src/libs/sound/decoders/modaud.c
--- src.orig/libs/sound/decoders/modaud.c	2017-11-21 19:39:32 -0600
+++ src/libs/sound/decoders/modaud.c	2017-11-21 19:39:49 -0600
@@ -88,7 +88,7 @@ static void* buffer;
 static ULONG bufsize;
 static ULONG written;
 
-ULONG*
+static ULONG*
 moda_mmout_SetOutputBuffer (void* buf, ULONG size)
 {
 	buffer = buf;
@@ -132,12 +132,18 @@ moda_mmout_Reset (void)
     return 0;
 }
 
+static char MDRIVER_name[] = "Mem Buffer";
+static char MDRIVER_version[] = "Mem Buffer driver v1.1";
+static char MDRIVER_alias[] = "membuf";
+
 static MDRIVER moda_mmout_drv =
-{   NULL,
-    "Mem Buffer",              // Name
-    "Mem Buffer driver v1.1",  // Version
-    0, 255,                    // Voice limits
-    "membuf",                  // Alias
+{
+	NULL,
+	//xxx libmikmod does not declare these fields const; it probably should.
+	MDRIVER_name,              // Name
+	MDRIVER_version,           // Version
+	0, 255,                    // Voice limits
+	MDRIVER_alias,             // Alias
 
 // The minimum mikmod version we support is 3.1.8
 #if (LIBMIKMOD_VERSION_MAJOR > 3) || \
@@ -215,7 +221,7 @@ moda_uioReader_Tell (MREADER* reader)
 	return uio_ftell (((MUIOREADER*)reader)->file);
 }
 
-MREADER*
+static MREADER*
 moda_new_uioReader (uio_Stream* fp)
 {
 	MUIOREADER* reader = (MUIOREADER*) HMalloc (sizeof(MUIOREADER));
@@ -231,7 +237,7 @@ moda_new_uioReader (uio_Stream* fp)
 	return (MREADER*)reader;
 }
 
-void
+static void
 moda_delete_uioReader (MREADER* reader)
 {
 	if (reader)
@@ -276,7 +282,7 @@ moda_InitModule (int flags, const TFB_De
 	
 	md_pansep = 64;
 
-	if (MikMod_Init (""))
+	if (MikMod_Init (NULL))
 	{
 		log_add (log_Error, "MikMod_Init() failed, %s", 
 			MikMod_strerror (MikMod_errno));
diff -ruNp src.orig/libs/sound/mixer/Makeinfo src/libs/sound/mixer/Makeinfo
--- src.orig/libs/sound/mixer/Makeinfo	2017-11-21 19:39:32 -0600
+++ src/libs/sound/mixer/Makeinfo	2017-11-21 19:39:49 -0600
@@ -1,2 +1,3 @@
 uqm_SUBDIRS="sdl nosound"
 uqm_CFILES="mixer.c"
+uqm_HFILES="mixer.h mixerint.h"
diff -ruNp src.orig/libs/sound/mixer/mixer.c src/libs/sound/mixer/mixer.c
--- src.orig/libs/sound/mixer/mixer.c	2017-11-21 19:39:32 -0600
+++ src/libs/sound/mixer/mixer.c	2017-11-21 19:39:49 -0600
@@ -1569,7 +1569,7 @@ mixer_ResampleNone (mixer_Source *src, b
 	uint8 *d0 = src->nextqueued->data + src->pos;
 	src->pos += mixer_chansize;
 	(void) left; // satisfying compiler - unused arg
-	return (float)mixer_GetSampleInt (d0, mixer_chansize);
+	return mixer_GetSampleInt (d0, mixer_chansize);
 }
 
 /* get a resampled (up/down) sample from source (nearest neighbor) */
@@ -1578,7 +1578,7 @@ mixer_ResampleNearest (mixer_Source *src
 {
 	uint8 *d0 = src->nextqueued->data + src->pos;
 	d0 += mixer_SourceAdvance (src, left);
-	return (float)mixer_GetSampleInt (d0, mixer_chansize);
+	return mixer_GetSampleInt (d0, mixer_chansize);
 }
 
 /* get an upsampled sample from source (linear interpolation) */
@@ -1608,8 +1608,8 @@ mixer_UpsampleLinear (mixer_Source *src,
 	else
 		d1 = d0 + curr->sampsize;
 
-	s0 = (float)mixer_GetSampleInt (d0, mixer_chansize);
-	s1 = (float)mixer_GetSampleInt (d1, mixer_chansize);
+	s0 = mixer_GetSampleInt (d0, mixer_chansize);
+	s1 = mixer_GetSampleInt (d1, mixer_chansize);
 	return s0 + t * (s1 - s0);
 }
 
@@ -1672,10 +1672,10 @@ mixer_UpsampleCubic (mixer_Source *src,
 			d3 = d2 + curr->sampsize;
 	}
 
-	s0 = (float)mixer_GetSampleInt (d0, mixer_chansize);
-	s1 = (float)mixer_GetSampleInt (d1, mixer_chansize);
-	s2 = (float)mixer_GetSampleInt (d2, mixer_chansize);
-	s3 = (float)mixer_GetSampleInt (d3, mixer_chansize);
+	s0 = mixer_GetSampleInt (d0, mixer_chansize);
+	s1 = mixer_GetSampleInt (d1, mixer_chansize);
+	s2 = mixer_GetSampleInt (d2, mixer_chansize);
+	s3 = mixer_GetSampleInt (d3, mixer_chansize);
 
 	a = (3.0f * (s1 - s2) - s0 + s3) * 0.5f;
 	b = 2.0f * s2 + s0 - ((5.0f * s1 + s3) * 0.5f);
diff -ruNp src.orig/libs/sound/mixer/nosound/Makeinfo src/libs/sound/mixer/nosound/Makeinfo
--- src.orig/libs/sound/mixer/nosound/Makeinfo	2017-11-21 19:39:32 -0600
+++ src/libs/sound/mixer/nosound/Makeinfo	2017-11-21 19:39:49 -0600
@@ -1 +1,2 @@
 uqm_CFILES="audiodrv_nosound.c"
+uqm_HFILES="audiodrv_nosound.h"
diff -ruNp src.orig/libs/sound/mixer/nosound/audiodrv_nosound.c src/libs/sound/mixer/nosound/audiodrv_nosound.c
--- src.orig/libs/sound/mixer/nosound/audiodrv_nosound.c	2017-11-21 19:39:32 -0600
+++ src/libs/sound/mixer/nosound/audiodrv_nosound.c	2017-11-21 19:39:49 -0600
@@ -146,12 +146,6 @@ noSound_Init (audio_Driver *driver, sint
 		return -1;
 	}
 
-	atexit (unInitAudio);
-
-	SetSFXVolume (sfxVolumeScale);
-	SetSpeechVolume (speechVolumeScale);
-	SetMusicVolume ((COUNT)musicVolume);
-		
 	PlaybackTask = AssignTask (PlaybackTaskFunc, 1024, 
 		"nosound audio playback");
 
@@ -215,7 +209,7 @@ PlaybackTaskFunc (void *data)
 		mixer_MixFake (NULL, stream, len);
 		delay = period - (GetTimeCounter () - entryTime);
 		if (delay > 0)
-			SleepThread (delay);
+			HibernateThread (delay);
 	}
 
 	HFree (stream);
diff -ruNp src.orig/libs/sound/mixer/sdl/Makeinfo src/libs/sound/mixer/sdl/Makeinfo
--- src.orig/libs/sound/mixer/sdl/Makeinfo	2017-11-21 19:39:32 -0600
+++ src/libs/sound/mixer/sdl/Makeinfo	2017-11-21 19:39:49 -0600
@@ -1 +1,2 @@
 uqm_CFILES="audiodrv_sdl.c"
+uqm_HFILES="audiodrv_sdl.h"
diff -ruNp src.orig/libs/sound/mixer/sdl/audiodrv_sdl.c src/libs/sound/mixer/sdl/audiodrv_sdl.c
--- src.orig/libs/sound/mixer/sdl/audiodrv_sdl.c	2017-11-21 19:39:32 -0600
+++ src/libs/sound/mixer/sdl/audiodrv_sdl.c	2017-11-21 19:39:49 -0600
@@ -90,6 +90,8 @@ static const audio_Driver mixSDL_Driver
 };
 
 
+static void audioCallback (void *userdata, Uint8 *stream, int len);
+
 /*
  * Initialization
  */
@@ -143,7 +145,7 @@ mixSDL_Init (audio_Driver *driver, sint3
 
 	desired.format = AUDIO_S16SYS;
 	desired.channels = 2;
-	desired.callback = mixer_MixChannels;
+	desired.callback = audioCallback;
 	
 	log_add (log_Info, "Opening SDL audio device.");
 	if (SDL_OpenAudio (&desired, &obtained) < 0)
@@ -210,12 +212,6 @@ mixSDL_Init (audio_Driver *driver, sint3
 		return -1;
 	}
 
-	atexit (unInitAudio);
-
-	SetSFXVolume (sfxVolumeScale);
-	SetSpeechVolume (speechVolumeScale);
-	SetMusicVolume ((COUNT)musicVolume);
-				
 	SDL_PauseAudio (0);
 		
 	return 0;
@@ -241,6 +237,7 @@ mixSDL_Uninit (void)
 			HFree (sbuffer);
 		}
 		DestroyMutex (soundSource[i].stream_mutex);
+		soundSource[i].stream_mutex = 0;
 
 		mixSDL_DeleteSources (1, &soundSource[i].handle);
 	}
@@ -251,6 +248,11 @@ mixSDL_Uninit (void)
 	SDL_QuitSubSystem (SDL_INIT_AUDIO);
 }
 
+static void
+audioCallback (void *userdata, Uint8 *stream, int len)
+{
+	mixer_MixChannels (userdata, stream, len);
+}
 
 /*
  * General
diff -ruNp src.orig/libs/sound/openal/Makeinfo src/libs/sound/openal/Makeinfo
--- src.orig/libs/sound/openal/Makeinfo	2017-11-21 19:39:32 -0600
+++ src/libs/sound/openal/Makeinfo	2017-11-21 19:39:49 -0600
@@ -1 +1,2 @@
 uqm_CFILES="audiodrv_openal.c"
+uqm_HFILES="audiodrv_openal.h"
diff -ruNp src.orig/libs/sound/openal/audiodrv_openal.c src/libs/sound/openal/audiodrv_openal.c
--- src.orig/libs/sound/openal/audiodrv_openal.c	2017-11-21 19:39:32 -0600
+++ src/libs/sound/openal/audiodrv_openal.c	2017-11-21 19:39:49 -0600
@@ -126,7 +126,6 @@ openAL_Init (audio_Driver *driver, sint3
 	}
 
 	*driver = openAL_Driver;
-	atexit (unInitAudio);
 
 	alcContext = alcCreateContext (alcDevice, NULL);
 	if (!alcContext)
@@ -193,14 +192,7 @@ openAL_Init (audio_Driver *driver, sint3
 		return -1;
 	}
 	
-	SetSFXVolume (sfxVolumeScale);
-	SetSpeechVolume (speechVolumeScale);
-	SetMusicVolume ((COUNT) musicVolume);
-
-	if (optStereoSFX)
-		alDistanceModel (AL_INVERSE_DISTANCE);
-	else
-		alDistanceModel (AL_NONE);
+	alDistanceModel (AL_INVERSE_DISTANCE);
 
 	(void) driver; // eat compiler warning
 
diff -ruNp src.orig/libs/sound/openal/audiodrv_openal.h src/libs/sound/openal/audiodrv_openal.h
--- src.orig/libs/sound/openal/audiodrv_openal.h	2017-11-21 19:39:32 -0600
+++ src/libs/sound/openal/audiodrv_openal.h	2017-11-21 19:39:49 -0600
@@ -22,7 +22,6 @@
 
 #include "config.h"
 #include "libs/sound/sound.h"
-#include "options.h"
 #include "endian_uqm.h"
 
 #if defined (__APPLE__)
diff -ruNp src.orig/libs/sound/sfx.c src/libs/sound/sfx.c
--- src.orig/libs/sound/sfx.c	2017-11-21 19:39:32 -0600
+++ src/libs/sound/sfx.c	2017-11-21 19:39:49 -0600
@@ -29,6 +29,7 @@
 
 static void CheckFinishedChannels (void);
 
+static const SoundPosition notPositional = {FALSE, 0, 0};
 
 void
 PlayChannel (COUNT channel, SOUND snd, SoundPosition pos,
@@ -50,8 +51,7 @@ PlayChannel (COUNT channel, SOUND snd, S
 	soundSource[channel].sample = sample;
 	soundSource[channel].positional_object = positional_object;
 	
-	if (optStereoSFX)
-		UpdateSoundPosition (channel, pos);
+	UpdateSoundPosition (channel, optStereoSFX ? pos : notPositional);
 
 	audio_Sourcei (soundSource[channel].handle, audio_BUFFER,
 			sample->buffer[0]);
diff -ruNp src.orig/libs/sound/sndintrn.h src/libs/sound/sndintrn.h
--- src.orig/libs/sound/sndintrn.h	2017-11-21 19:39:32 -0600
+++ src/libs/sound/sndintrn.h	2017-11-21 19:39:49 -0600
@@ -46,7 +46,7 @@ struct tfb_soundsample
 	uint32 num_buffers;
 	TFB_SoundTag *buffer_tag;
 	sint32 offset; // initial offset
-	intptr_t data; // user-defined data
+	void* data; // user-defined data
 	TFB_SoundCallbacks callbacks; // user-defined callbacks
 };
 
diff -ruNp src.orig/libs/sound/sound.h src/libs/sound/sound.h
--- src.orig/libs/sound/sound.h	2017-11-21 19:39:33 -0600
+++ src/libs/sound/sound.h	2017-11-21 19:39:49 -0600
@@ -66,8 +66,8 @@ void SetSpeechVolume (float volume);
 TFB_SoundSample *TFB_CreateSoundSample (TFB_SoundDecoder*, uint32 num_buffers,
 		const TFB_SoundCallbacks* /* can be NULL */);
 void TFB_DestroySoundSample (TFB_SoundSample*);
-void TFB_SetSoundSampleData (TFB_SoundSample*, intptr_t data);
-intptr_t TFB_GetSoundSampleData (TFB_SoundSample*);
+void TFB_SetSoundSampleData (TFB_SoundSample*, void* data);
+void* TFB_GetSoundSampleData (TFB_SoundSample*);
 void TFB_SetSoundSampleCallbacks (TFB_SoundSample*,
 		const TFB_SoundCallbacks* /* can be NULL */);
 TFB_SoundDecoder* TFB_GetSoundSampleDecoder (TFB_SoundSample*);
diff -ruNp src.orig/libs/sound/stream.c src/libs/sound/stream.c
--- src.orig/libs/sound/stream.c	2017-11-21 19:39:33 -0600
+++ src/libs/sound/stream.c	2017-11-21 19:39:49 -0600
@@ -225,12 +225,12 @@ TFB_DestroySoundSample (TFB_SoundSample
 }
 
 void
-TFB_SetSoundSampleData (TFB_SoundSample *sample, intptr_t data)
+TFB_SetSoundSampleData (TFB_SoundSample *sample, void* data)
 {
 	sample->data = data;
 }
 
-intptr_t
+void*
 TFB_GetSoundSampleData (TFB_SoundSample *sample)
 {
 	return sample->data;
@@ -568,7 +568,7 @@ StreamDecoderTaskFunc (void *data)
 
 		if (active_streams == 0) 
 		{	// Throttle down the thread when there are no active streams
-			SleepThread (ONE_SECOND / 10);
+			HibernateThread (ONE_SECOND / 10);
 		}
 		else
 			TaskSwitch ();
@@ -593,7 +593,8 @@ readSoundSample (void *ptr, int sample_s
 // We use AGC because different pieces of music and speech can easily be
 // at very different gain levels, because the game is moddable.
 int
-GraphForegroundStream (uint8 *data, sint32 width, sint32 height)
+GraphForegroundStream (uint8 *data, sint32 width, sint32 height,
+		bool wantSpeech)
 {
 	int source_num;
 	TFB_SoundSource *source;
@@ -634,7 +635,7 @@ GraphForegroundStream (uint8 *data, sint
 	source_num = SPEECH_SOURCE;
 	source = &soundSource[source_num];
 	LockMutex (source->stream_mutex);
-	if (speechVolumeScale != 0.0f && (!source->sample ||
+	if (wantSpeech && (!source->sample ||
 			!source->sample->decoder || !source->sample->decoder->is_null))
 	{	// Use speech waveform, since it's available
 		// Step is picked experimentally. Using step of 1 sample at 11025Hz,
@@ -642,9 +643,10 @@ GraphForegroundStream (uint8 *data, sint
 		// better this way.
 		step = 1;
 	}
-	else if (musicVolumeScale != 0.0f)
+	else
 	{	// We do not have speech -- use music waveform
 		UnlockMutex (source->stream_mutex);
+
 		source_num = MUSIC_SOURCE;
 		source = &soundSource[source_num];
 		LockMutex (source->stream_mutex);
@@ -653,11 +655,6 @@ GraphForegroundStream (uint8 *data, sint
 		// It looks better this way.
 		step = 4;
 	}
-	else
-	{	// We do not have anything usable
-		UnlockMutex (source->stream_mutex);
-		return 0;
-	}
 
 	if (!PlayingStream (source_num) || !source->sample
 			|| !source->sample->decoder || !source->sbuffer
diff -ruNp src.orig/libs/sound/stream.h src/libs/sound/stream.h
--- src.orig/libs/sound/stream.h	2017-11-21 19:39:33 -0600
+++ src/libs/sound/stream.h	2017-11-21 19:39:49 -0600
@@ -28,7 +28,8 @@ void ResumeStream (uint32 source);
 void SeekStream (uint32 source, uint32 pos);
 BOOLEAN PlayingStream (uint32 source);
 
-int GraphForegroundStream (uint8 *data, sint32 width, sint32 height);
+int GraphForegroundStream (uint8 *data, sint32 width, sint32 height,
+		bool wantSpeech);
 
 // returns TRUE if the fade was accepted by stream decoder
 bool SetMusicStreamFade (sint32 howLong, int endVolume);
diff -ruNp src.orig/libs/sound/trackint.h src/libs/sound/trackint.h
--- src.orig/libs/sound/trackint.h	2017-11-21 19:39:33 -0600
+++ src/libs/sound/trackint.h	2017-11-21 19:39:49 -0600
@@ -17,6 +17,8 @@
 #ifndef TRACKINT_H
 #define TRACKINT_H
 
+#include "libs/callback.h"
+
 struct tfb_soundchunk
 {
 	TFB_SoundDecoder *decoder;  // decoder for this chunk
@@ -24,7 +26,7 @@ struct tfb_soundchunk
 	int tag_me;                 // set for chunks with subtitles
 	uint32 track_num;           // logical track #, comm code needs this
 	UNICODE *text;              // subtitle text
-	TFB_TrackCB callback;       // comm callback, executed on chunk start
+	CallbackFunction callback;  // comm callback, executed on chunk start
 	struct tfb_soundchunk *next;
 };
 
diff -ruNp src.orig/libs/sound/trackplayer.c src/libs/sound/trackplayer.c
--- src.orig/libs/sound/trackplayer.c	2017-11-21 19:39:33 -0600
+++ src/libs/sound/trackplayer.c	2017-11-21 19:39:49 -0600
@@ -199,7 +199,8 @@ static void
 DoTrackTag (TFB_SoundChunk *chunk)
 {
 	if (chunk->callback)
-		chunk->callback ();
+		Callback_add(chunk->callback, 0);
+	
 	cur_sub_chunk = chunk;
 }
 
@@ -421,7 +422,7 @@ SpliceMultiTrack (UNICODE *TrackNames[],
 
 // XXX: This code and the entire trackplayer are begging to be overhauled
 void
-SpliceTrack (UNICODE *TrackName, UNICODE *TrackText, UNICODE *TimeStamp, TFB_TrackCB cb)
+SpliceTrack (UNICODE *TrackName, UNICODE *TrackText, UNICODE *TimeStamp, CallbackFunction cb)
 {
 	static UNICODE last_track_name[128] = "";
 	static unsigned long dec_offset = 0;
diff -ruNp src.orig/libs/sound/trackplayer.h src/libs/sound/trackplayer.h
--- src.orig/libs/sound/trackplayer.h	2017-11-21 19:39:33 -0600
+++ src/libs/sound/trackplayer.h	2017-11-21 19:39:49 -0600
@@ -20,8 +20,7 @@
 #define TRACKPLAYER_H
 
 #include "libs/compiler.h"
-
-typedef void (*TFB_TrackCB) (void);
+#include "libs/callback.h"
 
 #define ACCEL_SCROLL_SPEED 300
 
@@ -37,7 +36,7 @@ extern void FastForward_Smooth (void);
 extern void FastReverse_Page (void);
 extern void FastForward_Page (void);
 
-extern void SpliceTrack (UNICODE *filespec, UNICODE *textspec, UNICODE *TimeStamp, TFB_TrackCB cb);
+extern void SpliceTrack (UNICODE *filespec, UNICODE *textspec, UNICODE *TimeStamp, CallbackFunction cb);
 extern void SpliceMultiTrack (UNICODE *TrackNames[], UNICODE *TrackText);
 
 extern int GetTrackPosition (int in_units);
diff -ruNp src.orig/libs/strings/Makeinfo src/libs/strings/Makeinfo
--- src.orig/libs/strings/Makeinfo	2017-11-21 19:39:33 -0600
+++ src/libs/strings/Makeinfo	2017-11-21 19:39:49 -0600
@@ -1 +1,2 @@
-uqm_CFILES="getstr.c sfileins.c sresins.c strings.c unicode.c"
+uqm_CFILES="getstr.c sfileins.c sresins.c stringhashtable.c strings.c unicode.c"
+uqm_HFILES="stringhashtable.c strintrn.h"
diff -ruNp src.orig/libs/strings/getstr.c src/libs/strings/getstr.c
--- src.orig/libs/strings/getstr.c	2017-11-21 19:39:33 -0600
+++ src/libs/strings/getstr.c	2017-11-21 19:39:49 -0600
@@ -42,8 +42,9 @@ dword_convert (DWORD *dword_array, COUNT
 	} while (--num_dwords);
 }
 
-static void
-set_strtab_entry (STRING_TABLE_DESC *strtab, int index, const char *value, int len)
+static STRING
+set_strtab_entry (STRING_TABLE_DESC *strtab, int index, const char *value,
+		int len)
 {
 	STRING str = &strtab->strings[index];
 
@@ -59,23 +60,107 @@ set_strtab_entry (STRING_TABLE_DESC *str
 		str->length = len;
 		memcpy (str->data, value, len);
 	}
+	return str;
+}
+
+static void
+copy_strings_to_strtab (STRING_TABLE_DESC *strtab, size_t firstIndex,
+		size_t count, const char *data, const DWORD *lens)
+{
+	size_t stringI;
+	const char *off = data;
+
+	for (stringI = 0; stringI < count; stringI++)
+	{
+		set_strtab_entry(strtab, firstIndex + stringI,
+				off, lens[stringI]);
+		off += lens[stringI];
+	}
+}
+
+// Check whether a buffer has a certain minimum size, and enlarge it
+// if necessary.
+// buf: pointer to the pointer to the buffer. May be NULL.
+// curSize: pointer to the current size (multiple of 'increment')
+// minSize: required minimum size
+// increment: size to increment the buffer with if necessary
+// On success, *buf and *curSize are updated. On failure, they are
+// unchanged.
+// returns FALSE if and only if the buffer needs to be enlarged but
+// memory allocation failed.
+static BOOLEAN
+ensureBufSize (char **buf, size_t *curSize, size_t minSize, size_t increment)
+{
+	char *newBuf;
+	size_t newSize;
+
+	if (minSize <= *curSize)
+	{
+		// Buffer is large enough as it is.
+		return TRUE;
+	}
+
+	newSize = ((minSize + (increment - 1)) / increment) * increment;
+			// Smallest multiple of 'increment' larger or equal to minSize.
+	newBuf = HRealloc (*buf, newSize);
+	if (newBuf == NULL)
+		return FALSE;
+
+	// Success
+	*buf = newBuf;
+	*curSize = newSize;
+	return TRUE;
 }
 
 void
 _GetConversationData (const char *path, RESOURCE_DATA *resdata)
 {
-	uio_Stream *fp;
 	unsigned long dataLen;
 	void *result;
-	int n, path_len, num_data_sets;
-	DWORD opos,
-		slen[MAX_STRINGS], StringOffs, tot_string_size,
-		clen[MAX_STRINGS], ClipOffs, tot_clip_size,
-		tslen[MAX_STRINGS], TSOffs;
-	DWORD tot_ts_size = 0;
-	char CurrentLine[1024], paths[1024], *clip_path, *ts_path,
-		*strdata, *clipdata, *ts_data;
+	int stringI;
+	int path_len;
+	int num_data_sets;
+	DWORD opos;
+	
+	char *namedata = NULL;
+			// Contains the names (indexes) of the dialogs.
+	DWORD nlen[MAX_STRINGS];
+			// Length of each of the names.
+	DWORD NameOffs;
+	size_t tot_name_size;
+
+	char *strdata = NULL;
+			// Contains the dialog strings.
+	DWORD slen[MAX_STRINGS];
+			// Length of each of the dialog strings.
+	DWORD StringOffs;
+	size_t tot_string_size;
+
+	char *clipdata = NULL;
+			// Contains the file names of the speech files.
+	DWORD clen[MAX_STRINGS];
+			// Length of each of the speech file names.
+	DWORD ClipOffs;
+	size_t tot_clip_size;
+
+	char *ts_data = NULL;
+			// Contains the timestamp data for synching the text with the
+			// speech.
+	DWORD tslen[MAX_STRINGS];
+			// Length of each of the timestamp strings.
+	DWORD TSOffs;
+	size_t tot_ts_size = 0;
+
+	char CurrentLine[1024];
+	char paths[1024];
+	char *clip_path;
+	char *ts_path;
+
+	uio_Stream *fp = NULL;
 	uio_Stream *timestamp_fp = NULL;
+	StringHashTable_HashTable *nameHashTable = NULL;
+			// Hash table of string names (such as "GLAD_WHEN_YOU_COME_BACK")
+			// to a STRING.
 
 	/* Parse out the conversation components. */
 	strncpy (paths, path, 1023);
@@ -107,7 +192,8 @@ _GetConversationData (const char *path,
 	}
 
 	dataLen = LengthResFile (fp);
-	log_add (log_Info, "\t'%s' -- conversation phrases -- %lu bytes", paths, dataLen);
+	log_add (log_Info, "\t'%s' -- conversation phrases -- %lu bytes", paths,
+			dataLen);
 	if (clip_path)
 		log_add (log_Info, "\t'%s' -- voice clip directory", clip_path);
 	else
@@ -117,90 +203,135 @@ _GetConversationData (const char *path,
 	else
 		log_add (log_Info, "\tNo associated timestamp file");
 
-	
 	if (dataLen == 0)
 	{
-		log_add (log_Warning, "Warning: Trying to load empty file '%s'.", path);
+		log_add (log_Warning, "Warning: Trying to load empty file '%s'.",
+				path);
 		goto err;
 	}
 	
-	if ((strdata = HMalloc (tot_string_size = POOL_SIZE)) == 0)
+	tot_string_size = POOL_SIZE;
+	strdata = HMalloc (tot_string_size);
+	if (strdata == 0)
 		goto err;
 	
-	if ((clipdata = HMalloc (tot_clip_size = POOL_SIZE)) == 0)
-	{
-		HFree (strdata);
+	tot_name_size = POOL_SIZE;
+	namedata = HMalloc (tot_name_size);
+	if (namedata == 0)
+		goto err;
+	
+	tot_clip_size = POOL_SIZE;
+	clipdata = HMalloc (tot_clip_size);
+	if (clipdata == 0)
 		goto err;
-	}
 	ts_data = NULL;
+
+	nameHashTable = StringHashTable_newHashTable(
+			NULL, NULL, NULL, NULL, NULL, 0, 0.85, 0.9);
+	if (nameHashTable == NULL)
+		goto err;
 	
 	path_len = clip_path ? strlen (clip_path) : 0;
 
-	if (ts_path && (timestamp_fp = uio_fopen (contentDir, ts_path,
-			"rb")))
+	if (ts_path)
 	{
-		if ((ts_data = HMalloc (tot_ts_size = POOL_SIZE)) == 0)
-			goto err;
+		timestamp_fp = uio_fopen (contentDir, ts_path, "rb");
+		if (timestamp_fp != NULL)
+		{
+			tot_ts_size = POOL_SIZE;
+			ts_data = HMalloc (tot_ts_size);
+			if (ts_data == 0)
+				goto err;
+		}
 	}
 	
 	opos = uio_ftell (fp);
-	n = -1;
-	StringOffs = ClipOffs = TSOffs = 0;
-	while (uio_fgets (CurrentLine, sizeof (CurrentLine), fp) && n < MAX_STRINGS - 1)
+	stringI = -1;
+	NameOffs = 0;
+	StringOffs = 0;
+	ClipOffs = 0;
+	TSOffs = 0;
+	for (;;)
 	{
 		int l;
 
+		if (uio_fgets (CurrentLine, sizeof (CurrentLine), fp) == NULL)
+		{
+			// EOF or read error.
+			break;
+		}
+	
+		if (stringI >= MAX_STRINGS - 1)
+		{
+			// Too many strings.
+			break;
+		}
+
 		if (CurrentLine[0] == '#')
 		{
+			// String header, of the following form:
+			//     #(GLAD_WHEN_YOU_COME_BACK) commander-000.ogg
 			char CopyLine[1024];
-			char *s;
+			char *name;
+			char *ts;
 
 			strcpy (CopyLine, CurrentLine);
-			s = strtok (&CopyLine[1], "()");
-			if (s)
+			name = strtok (&CopyLine[1], "()");
+			if (name)
 			{
-				if (n >= 0)
+				if (stringI >= 0)
 				{
-					while (slen[n] > 1 && 
+					while (slen[stringI] > 1 &&
 							(strdata[StringOffs - 2] == '\n' ||
 							strdata[StringOffs - 2] == '\r'))
 					{
-						--slen[n];
+						--slen[stringI];
 						--StringOffs;
 						strdata[StringOffs - 1] = '\0';
 					}
 				}
 
-				slen[++n] = 0;
+				slen[++stringI] = 0;
+
+				// Store the string name.
+				l = strlen (name) + 1;
+				if (!ensureBufSize (&namedata, &tot_name_size,
+						NameOffs + l, POOL_SIZE))
+					goto err;
+				strcpy (&namedata[NameOffs], name);
+				NameOffs += l;
+				nlen[stringI] = l;
+
 				// now lets check for timestamp data
 				if (timestamp_fp)
 				{
-					char TimeStampLine[1024], *tsptr;
+					// We have a time stamp file.
+					char TimeStampLine[1024];
+					char *tsptr;
 					BOOLEAN ts_ok = FALSE;
 					uio_fgets (TimeStampLine, sizeof (TimeStampLine), timestamp_fp);
 					if (TimeStampLine[0] == '#')
 					{
-						tslen[n] = 0;
-						if ((tsptr = strstr (TimeStampLine,s)) 
-								&& (tsptr += strlen(s))
-								&& (++tsptr))
+						// Line is of the following form:
+						//     #(GIVE_FUEL_AGAIN) 3304,3255
+						tslen[stringI] = 0;
+						tsptr = strstr (TimeStampLine, name);
+						if (tsptr)
 						{
+							tsptr += strlen(name) + 1;
 							ts_ok = TRUE;
 							while (! strcspn(tsptr," \t\r\n") && *tsptr)
 								tsptr++;
 							if (*tsptr)
 							{
-								l = strlen (tsptr)  + 1;
-								if (TSOffs + l > tot_ts_size
-									&& (ts_data = HRealloc (ts_data,
-										tot_ts_size += POOL_SIZE)) == 0)
-								{
-									HFree (strdata);
+								l = strlen (tsptr) + 1;
+								if (!ensureBufSize (&ts_data, &tot_ts_size, TSOffs + l,
+										POOL_SIZE))
 									goto err;
-								}
+
 								strcpy (&ts_data[TSOffs], tsptr);
 								TSOffs += l;
-								tslen[n] = l;
+								tslen[stringI] = l;
 							}
 						}
 					}
@@ -208,7 +339,7 @@ _GetConversationData (const char *path,
 					{
 						// timestamp data is invalid, remove all of it
 						log_add (log_Warning, "Invalid timestamp data "
-								"for '%s'.  Disabling timestamps", s);
+								"for '%s'.  Disabling timestamps", name);
 						HFree (ts_data);
 						ts_data = NULL;
 						uio_fclose (timestamp_fp);
@@ -216,46 +347,39 @@ _GetConversationData (const char *path,
 						TSOffs = 0;
 					}
 				}
-				clen[n] = 0;
-				s = strtok (NULL, " \t\r\n)");
-				if (s)
+				clen[stringI] = 0;
+				ts = strtok (NULL, " \t\r\n)");
+				if (ts)
 				{
-					l = path_len + strlen (s) + 1;
-					if (ClipOffs + l > tot_clip_size
-							&& (clipdata = HRealloc (clipdata,
-							tot_clip_size += POOL_SIZE)) == 0)
-					{
-						HFree (strdata);
+					l = path_len + strlen (ts) + 1;
+					if (!ensureBufSize (&clipdata, &tot_clip_size,
+							ClipOffs + l, POOL_SIZE))
 						goto err;
-					}
 
 					if (clip_path)
 						strcpy (&clipdata[ClipOffs], clip_path);
-					strcpy (&clipdata[ClipOffs + path_len], s);
+					strcpy (&clipdata[ClipOffs + path_len], ts);
 					ClipOffs += l;
-					clen[n] = l;
+					clen[stringI] = l;
 				}
 			}
 		}
-		else if (n >= 0)
+		else if (stringI >= 0)
 		{
 			char *s;
 			l = strlen (CurrentLine) + 1;
-			if (StringOffs + l > tot_string_size
-					&& (strdata = HRealloc (strdata,
-					tot_string_size += POOL_SIZE)) == 0)
-			{
-				HFree (clipdata);
+
+			if (!ensureBufSize (&strdata, &tot_string_size, StringOffs + l,
+					POOL_SIZE))
 				goto err;
-			}
 
-			if (slen[n])
+			if (slen[stringI])
 			{
-				--slen[n];
+				--slen[stringI];
 				--StringOffs;
 			}
 			s = &strdata[StringOffs];
-			slen[n] += l;
+			slen[stringI] += l;
 			StringOffs += l;
 
 			strcpy (s, CurrentLine);
@@ -264,12 +388,12 @@ _GetConversationData (const char *path,
 		if ((int)uio_ftell (fp) - (int)opos >= (int)dataLen)
 			break;
 	}
-	if (n >= 0)
+	if (stringI >= 0)
 	{
-		while (slen[n] > 1 && (strdata[StringOffs - 2] == '\n'
+		while (slen[stringI] > 1 && (strdata[StringOffs - 2] == '\n'
 				|| strdata[StringOffs - 2] == '\r'))
 		{
-			--slen[n];
+			--slen[stringI];
 			--StringOffs;
 			strdata[StringOffs - 1] = '\0';
 		}
@@ -280,57 +404,83 @@ _GetConversationData (const char *path,
 
 	result = NULL;
 	num_data_sets = (ClipOffs ? 1 : 0) + (TSOffs ? 1 : 0) + 1;
-	if (++n)
+	if (++stringI)
 	{
 		int flags = 0;
+		int stringCount = stringI;
+
 		if (ClipOffs)
 			flags |= HAS_SOUND_CLIPS;
 		if (TSOffs)
 			flags |= HAS_TIMESTAMP;
-		result = AllocStringTable (n, flags);
+		flags |= HAS_NAMEINDEX;
+
+		result = AllocStringTable (stringCount, flags);
 		if (result)
 		{
-			int StringIndex, ClipIndex, TSIndex;
-			STRING_TABLE_DESC *lpST;
-
-			lpST = (STRING_TABLE) result;
-
-			StringIndex = 0;
-			ClipIndex = n;
-			TSIndex = n * ((flags & HAS_SOUND_CLIPS) ? 2 : 1);
+			// Copy all the gatherered data in a STRING_TABLE
+			STRING_TABLE_DESC *lpST = (STRING_TABLE) result;
+			STRING str;
+			stringI = 0;
+
+			// Store the dialog string.
+			copy_strings_to_strtab (
+					lpST, stringI, stringCount, strdata, slen);
+			stringI += stringCount;
+			
+			// Store the dialog names.
+			copy_strings_to_strtab (
+					lpST, stringI, stringCount, namedata, nlen);
+			stringI += stringCount;
+				
+			// Store sound clip file names.
+			if (lpST->flags & HAS_SOUND_CLIPS)
+			{
+				copy_strings_to_strtab (
+						lpST, stringI, stringCount, clipdata, clen);
+				stringI += stringCount;
+			}
 
-			StringOffs = ClipOffs = TSOffs = 0;
+			// Store time stamp data.
+			if (lpST->flags & HAS_TIMESTAMP)
+			{
+				copy_strings_to_strtab (
+						lpST, stringI, stringCount, ts_data, tslen);
+				//stringI += stringCount;
+			}
 
-			for (n = 0; n < (int)lpST->size;
-					++n, ++StringIndex, ++ClipIndex, ++TSIndex)
+			// Store the STRING in the hash table indexed by the dialog
+			// name.
+			str = &lpST->strings[stringCount];
+			for (stringI = 0; stringI < stringCount; stringI++)
 			{
-				set_strtab_entry(lpST, StringIndex, strdata + StringOffs, slen[n]);
-				StringOffs += slen[n];
-				if (lpST->flags & HAS_SOUND_CLIPS)
-				{
-					set_strtab_entry(lpST, ClipIndex, clipdata + ClipOffs, clen[n]);
-					ClipOffs += clen[n];
-				}
-				if (lpST->flags & HAS_TIMESTAMP)
-				{
-					set_strtab_entry(lpST, TSIndex, ts_data + TSOffs, tslen[n]);
-					TSOffs += tslen[n];
-				}
+				StringHashTable_add (nameHashTable, str[stringI].data,
+						&str[stringI]);
 			}
+
+			lpST->nameIndex = nameHashTable;
 		}
 	}
 	HFree (strdata);
-	HFree (clipdata);
-	if (ts_data)
+	if (clipdata != NULL)
+		HFree (clipdata);
+	if (ts_data != NULL)
 		HFree (ts_data);
 
 	resdata->ptr = result;
 	return;
 
 err:
+	if (nameHashTable != NULL)
+		StringHashTable_deleteHashTable (nameHashTable);
+	if (ts_data != NULL)
+		HFree (ts_data);
+	if (clipdata != NULL)
+		HFree (clipdata);
+	if (strdata != NULL)
+		HFree (strdata);
 	res_CloseResFile (fp);
 	resdata->ptr = NULL;
-
 }
 
 void *
@@ -338,20 +488,38 @@ _GetStringData (uio_Stream *fp, DWORD le
 {
 	void *result;
 
-	int n;
-	DWORD opos, slen[MAX_STRINGS], StringOffs, tot_string_size;
-	char CurrentLine[1024], *strdata;
-
-	if ((strdata = HMalloc (tot_string_size = POOL_SIZE)) == 0)
-		return (0);
+	int stringI;
+	DWORD opos;
+	DWORD slen[MAX_STRINGS];
+	DWORD StringOffs;
+	size_t tot_string_size;
+	char CurrentLine[1024];
+	char *strdata = NULL;
+
+	tot_string_size = POOL_SIZE;
+	strdata = HMalloc (tot_string_size);
+	if (strdata == 0)
+		goto err;
 
 	opos = uio_ftell (fp);
-	n = -1;
+	stringI = -1;
 	StringOffs = 0;
-	while (uio_fgets (CurrentLine, sizeof (CurrentLine), fp) && n < MAX_STRINGS - 1)
+	for (;;)
 	{
 		int l;
 
+		if (uio_fgets (CurrentLine, sizeof (CurrentLine), fp) == NULL)
+		{
+			// EOF or read error.
+			break;
+		}
+	
+		if (stringI >= MAX_STRINGS - 1)
+		{
+			// Too many strings.
+			break;
+		}
+
 		if (CurrentLine[0] == '#')
 		{
 			char CopyLine[1024];
@@ -361,39 +529,37 @@ _GetStringData (uio_Stream *fp, DWORD le
 			s = strtok (&CopyLine[1], "()");
 			if (s)
 			{
-				if (n >= 0)
+				if (stringI >= 0)
 				{
-					while (slen[n] > 1 && 
+					while (slen[stringI] > 1 && 
 							(strdata[StringOffs - 2] == '\n' ||
 							strdata[StringOffs - 2] == '\r'))
 					{
-						--slen[n];
+						--slen[stringI];
 						--StringOffs;
 						strdata[StringOffs - 1] = '\0';
 					}
 				}
 
-				slen[++n] = 0;
+				slen[++stringI] = 0;
 			}
 		}
-		else if (n >= 0)
+		else if (stringI >= 0)
 		{
 			char *s;
 			l = strlen (CurrentLine) + 1;
-			if (StringOffs + l > tot_string_size
-					&& (strdata = HRealloc (strdata,
-					tot_string_size += POOL_SIZE)) == 0)
-			{
-				return (0);
-			}
 
-			if (slen[n])
+			if (!ensureBufSize (&strdata, &tot_string_size, StringOffs + l,
+					POOL_SIZE))
+				goto err;
+
+			if (slen[stringI])
 			{
-				--slen[n];
+				--slen[stringI];
 				--StringOffs;
 			}
 			s = &strdata[StringOffs];
-			slen[n] += l;
+			slen[stringI] += l;
 			StringOffs += l;
 
 			strcpy (s, CurrentLine);
@@ -402,44 +568,38 @@ _GetStringData (uio_Stream *fp, DWORD le
 		if ((int)uio_ftell (fp) - (int)opos >= (int)length)
 			break;
 	}
-	if (n >= 0)
+	if (stringI >= 0)
 	{
-		while (slen[n] > 1 && (strdata[StringOffs - 2] == '\n'
+		while (slen[stringI] > 1 && (strdata[StringOffs - 2] == '\n'
 				|| strdata[StringOffs - 2] == '\r'))
 		{
-			--slen[n];
+			--slen[stringI];
 			--StringOffs;
 			strdata[StringOffs - 1] = '\0';
 		}
 	}
 
 	result = NULL;
-	if (++n)
+	if (++stringI)
 	{
 		int flags = 0;
-		result = AllocStringTable (n, flags);
+		int stringCount = stringI;
+
+		result = AllocStringTable (stringI, flags);
 		if (result)
 		{
-			int StringIndex;
-			STRING_TABLE_DESC *lpST;
-
-			lpST = (STRING_TABLE) result;
-
-			StringIndex = 0;
-
-			StringOffs = 0;
-
-			for (n = 0; n < (int)lpST->size;
-					++n, ++StringIndex)
-			{
-				set_strtab_entry(lpST, StringIndex, strdata + StringOffs, slen[n]);
-				StringOffs += slen[n];
-			}
+			STRING_TABLE_DESC *lpST = (STRING_TABLE) result;
+			copy_strings_to_strtab (lpST, 0, stringCount, strdata, slen);
 		}
 	}
 	HFree (strdata);
 
-	return (result);
+	return result;
+
+err:
+	if (strdata != NULL)
+		HFree (strdata);
+	return 0;
 }
 
 
@@ -478,6 +638,6 @@ _GetBinaryTableData (uio_Stream *fp, DWO
 		result = lpST;
 	}
 
-	return (result);
+	return result;
 }
 
diff -ruNp src.orig/libs/strings/stringhashtable.c src/libs/strings/stringhashtable.c
--- src.orig/libs/strings/stringhashtable.c	1969-12-31 18:00:00 -0600
+++ src/libs/strings/stringhashtable.c	2017-11-21 19:39:49 -0600
@@ -0,0 +1,67 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ * Nota bene: later versions of the GNU General Public License do not apply
+ * to this program.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#define HASHTABLE_INTERNAL
+#include "stringhashtable.h"
+#include "types.h"
+#include "libs/misc.h"
+		// For unconst()
+#include "libs/uio/uioport.h"
+
+static inline uio_uint32 StringHashTable_hash(
+		StringHashTable_HashTable *hashTable, const char *string);
+static inline uio_bool StringHashTable_equal(
+		StringHashTable_HashTable *hashTable,
+		const char *key1, const char *key2);
+static inline char *StringHashTable_copy(
+		StringHashTable_HashTable *hashTable, const char *key);
+
+#include "libs/uio/hashtable.c"
+
+
+static inline uio_uint32
+StringHashTable_hash(StringHashTable_HashTable *hashTable, const char *key) {
+	uio_uint32 hash;
+
+	(void) hashTable;
+	// Rotating hash, variation of something on the web which
+	// wasn't original itself.
+	hash = 0;
+			// Hash was on that web page initialised as the length,
+			// but that isn't known at this time.
+	while (*key != '\0') {
+		hash = (hash << 4) ^ (hash >> 28) ^ *key;
+		key++;
+	}
+	return hash ^ (hash >> 10) ^ (hash >> 20);
+}
+
+static inline uio_bool
+StringHashTable_equal(StringHashTable_HashTable *hashTable,
+		const char *key1, const char *key2) {
+	(void) hashTable;
+	return strcmp(key1, key2) == 0;
+}
+
+static inline char *
+StringHashTable_copy(StringHashTable_HashTable *hashTable,
+		const char *key) {
+	(void) hashTable;
+	return unconst(key);
+}
+
diff -ruNp src.orig/libs/strings/stringhashtable.h src/libs/strings/stringhashtable.h
--- src.orig/libs/strings/stringhashtable.h	1969-12-31 18:00:00 -0600
+++ src/libs/strings/stringhashtable.h	2017-11-21 19:39:49 -0600
@@ -0,0 +1,43 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ * Nota bene: later versions of the GNU General Public License do not apply
+ * to this program.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef _STRINGHASHTABLE_H
+#define _STRINGHASHTABLE_H
+
+// HashTable from 'char *' to STRING.
+// We don't actually copy the index, which means that the caller is
+// responsible for keeping them unchanged during the time that it is used in
+// the hash table.
+
+#include "libs/strlib.h"
+
+#define HASHTABLE_(identifier) StringHashTable ## _ ## identifier
+typedef char HASHTABLE_(Key);
+typedef STRING_TABLE_ENTRY_DESC HASHTABLE_(Value);
+#define StringHashTable_HASH StringHashTable_hash
+#define StringHashTable_EQUAL StringHashTable_equal
+#define StringHashTable_COPY StringHashTable_copy
+#define StringHashTable_FREEKEY(hashTable, key) \
+		((void) (hashTable), (void) (key))
+#define StringHashTable_FREEVALUE(hashTable, value) \
+		((void) (hashTable), (void) (value))
+
+#include "libs/uio/hashtable.h"
+
+
+#endif  /* _STRINGHASHTABLE_H */
diff -ruNp src.orig/libs/strings/strings.c src/libs/strings/strings.c
--- src.orig/libs/strings/strings.c	2017-11-21 19:39:33 -0600
+++ src/libs/strings/strings.c	2017-11-21 19:39:49 -0600
@@ -25,6 +25,10 @@ AllocStringTable (int num_entries, int f
 	STRING_TABLE strtab = HMalloc (sizeof (STRING_TABLE_DESC));
 	int i, multiplier = 1;
 
+	if (flags & HAS_NAMEINDEX)
+	{
+		multiplier++;
+	}
 	if (flags & HAS_SOUND_CLIPS)
 	{
 		multiplier++;
@@ -44,6 +48,7 @@ AllocStringTable (int num_entries, int f
 		strtab->strings[i].parent = strtab;
 		strtab->strings[i].index = i;
 	}
+	strtab->nameIndex = NULL;
 	return strtab;
 }
 
@@ -209,6 +214,40 @@ GetStringLengthBin (STRING String)
 }
 
 STRINGPTR
+GetStringName (STRING String)
+{
+	STRING_TABLE StringTablePtr;
+	COUNT StringIndex;
+
+	if (String == NULL)
+	{
+		return NULL;
+	}
+
+	StringTablePtr = String->parent;
+	if (StringTablePtr == NULL)
+	{
+		return NULL;
+	}
+
+	StringIndex = String->index;
+
+	if (!(StringTablePtr->flags & HAS_NAMEINDEX))
+	{
+		return NULL;
+	}
+	StringIndex += StringTablePtr->size;
+
+	String = &StringTablePtr->strings[StringIndex];
+	if (String->length == 0)
+	{
+		return NULL;
+	}
+
+	return String->data;
+}
+
+STRINGPTR
 GetStringSoundClip (STRING String)
 {
 	STRING_TABLE StringTablePtr;
@@ -230,8 +269,13 @@ GetStringSoundClip (STRING String)
 	{
 		return NULL;
 	}
-
 	StringIndex += StringTablePtr->size;
+
+	if (StringTablePtr->flags & HAS_NAMEINDEX)
+	{
+		StringIndex += StringTablePtr->size;
+	}
+
 	String = &StringTablePtr->strings[StringIndex];
 	if (String->length == 0)
 	{
@@ -246,7 +290,6 @@ GetStringTimeStamp (STRING String)
 {
 	STRING_TABLE StringTablePtr;
 	COUNT StringIndex;
-	int offset;
 
 	if (String == NULL)
 	{
@@ -264,9 +307,18 @@ GetStringTimeStamp (STRING String)
 	{
 		return NULL;
 	}
+	StringIndex += StringTablePtr->size;
+
+	if (StringTablePtr->flags & HAS_NAMEINDEX)
+	{
+		StringIndex += StringTablePtr->size;
+	}
+	
+	if (StringTablePtr->flags & HAS_SOUND_CLIPS)
+	{
+		StringIndex += StringTablePtr->size;
+	}
 
-	offset = (StringTablePtr->flags & HAS_SOUND_CLIPS) ? 1 : 0;
-	StringIndex += StringTablePtr->size << offset;
 	String = &StringTablePtr->strings[StringIndex];
 	if (String->length == 0)
 	{
@@ -285,3 +337,11 @@ GetStringAddress (STRING String)
 	}
 	return String->data;
 }
+
+STRING
+GetStringByName (STRING_TABLE StringTable, const char *index)
+{
+	return (STRING) StringHashTable_find (StringTable->nameIndex, index);
+}
+
+
diff -ruNp src.orig/libs/strings/strintrn.h src/libs/strings/strintrn.h
--- src.orig/libs/strings/strintrn.h	2017-11-21 19:39:33 -0600
+++ src/libs/strings/strintrn.h	2017-11-21 19:39:49 -0600
@@ -23,6 +23,7 @@
 #include <string.h>
 #include "libs/strlib.h"
 #include "libs/reslib.h"
+#include "stringhashtable.h"
 
 struct string_table_entry
 {
@@ -37,10 +38,12 @@ struct string_table
 	unsigned short flags;
 	int size;
 	STRING_TABLE_ENTRY_DESC *strings;
+	StringHashTable_HashTable *nameIndex;
 };
 
-#define HAS_SOUND_CLIPS (1 << 0)
-#define HAS_TIMESTAMP (1 << 1)
+#define HAS_SOUND_CLIPS  (1 << 0)
+#define HAS_TIMESTAMP    (1 << 1)
+#define HAS_NAMEINDEX    (1 << 2)
 
 STRING_TABLE AllocStringTable (int num_entries, int flags);
 void FreeStringTable (STRING_TABLE strtab);
diff -ruNp src.orig/libs/strlib.h src/libs/strlib.h
--- src.orig/libs/strlib.h	2017-11-21 19:39:33 -0600
+++ src/libs/strlib.h	2017-11-21 19:39:49 -0600
@@ -36,6 +36,10 @@ typedef char *STRINGPTR;
 /* This has to go here because reslib requires the above typedefs. */
 #include "libs/reslib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern BOOLEAN InstallStringTableResType (void);
 extern STRING_TABLE LoadStringTableInstance (RESOURCE res);
 extern STRING_TABLE LoadStringTableFile (uio_DirHandle *dir,
@@ -53,8 +57,10 @@ extern STRING SetRelStringTableIndex (ST
 extern COUNT GetStringLength (STRING String);
 extern COUNT GetStringLengthBin (STRING String);
 extern STRINGPTR GetStringAddress (STRING String);
+extern STRINGPTR GetStringName (STRING String);
 extern STRINGPTR GetStringSoundClip (STRING String);
 extern STRINGPTR GetStringTimeStamp (STRING String);
+extern STRING GetStringByName (STRING_TABLE StringTable, const char *index);
 
 #define UNICHAR_DEGREE_SIGN   0x00b0
 #define STR_DEGREE_SIGN     "\xC2\xB0"
@@ -67,5 +73,9 @@ extern STRINGPTR GetStringTimeStamp (STR
 #define UNICHAR_BULLET        0x2022
 #define STR_BULLET          "\xE2\x80\xA2"
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _STRLIB_H */
 
diff -ruNp src.orig/libs/task/tasklib.c src/libs/task/tasklib.c
--- src.orig/libs/task/tasklib.c	2017-11-21 19:39:33 -0600
+++ src/libs/task/tasklib.c	2017-11-21 19:39:49 -0600
@@ -124,7 +124,6 @@ InitTaskSystem (void)
 	{
 		task_array[i].state_mutex = CreateMutex ("task manager lock", SYNC_CLASS_TOPLEVEL | SYNC_CLASS_RESOURCE);
 	}
-	atexit (CleanupTaskSystem);
 }
 
 void 
@@ -134,6 +133,7 @@ CleanupTaskSystem (void)
 	for (i = 0; i < TASK_MAX; ++i)
 	{
 		DestroyMutex (task_array[i].state_mutex);
+		task_array[i].state_mutex = 0;
 	}
 }
 
diff -ruNp src.orig/libs/tasklib.h src/libs/tasklib.h
--- src.orig/libs/tasklib.h	2017-11-21 19:39:33 -0600
+++ src/libs/tasklib.h	2017-11-21 19:39:49 -0600
@@ -26,6 +26,10 @@
 
 #include "libs/threadlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 /* Bitmasks for setting task state. */
 #define TASK_INUSE       1
 #define TASK_EXIT        2
@@ -50,5 +54,9 @@ extern DWORD Task_ReadState (Task task,
 extern void  FinishTask (Task task);
 extern void  ConcludeTask (Task task);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif
 
diff -ruNp src.orig/libs/threadlib.h src/libs/threadlib.h
--- src.orig/libs/threadlib.h	2017-11-21 19:39:33 -0600
+++ src/libs/threadlib.h	2017-11-21 19:39:49 -0600
@@ -45,6 +45,10 @@
 #include <sys/types.h>
 #include "libs/timelib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #if defined (PROFILE_THREADS) || defined (DEBUG_THREADS)
 #define THREAD_NAMES
 #endif
@@ -141,6 +145,8 @@ ThreadLocal *CreateThreadLocal (void);
 void DestroyThreadLocal (ThreadLocal *tl);
 ThreadLocal *GetMyThreadLocal (void);
 
+void HibernateThread (TimePeriod timePeriod);
+void HibernateThreadUntil (TimeCount wakeTime);
 void SleepThread (TimePeriod timePeriod);
 void SleepThreadUntil (TimeCount wakeTime);
 void DestroyThread (Thread);
@@ -173,5 +179,9 @@ void WaitCondVar (CondVar);
 void SignalCondVar (CondVar);
 void BroadcastCondVar (CondVar);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _THREADLIB_H */
 
diff -ruNp src.orig/libs/threads/Makeinfo src/libs/threads/Makeinfo
--- src.orig/libs/threads/Makeinfo	2017-11-21 19:39:33 -0600
+++ src/libs/threads/Makeinfo	2017-11-21 19:39:49 -0600
@@ -6,4 +6,6 @@ case "$uqm_THREADLIB" in
 		uqm_SUBDIRS="pthread"
 		;;
 esac
+
 uqm_CFILES="thrcommon.c"
+uqm_HFILES="thrcommon.h"
diff -ruNp src.orig/libs/threads/pthread/Makeinfo src/libs/threads/pthread/Makeinfo
--- src.orig/libs/threads/pthread/Makeinfo	2017-11-21 19:39:33 -0600
+++ src/libs/threads/pthread/Makeinfo	2017-11-21 19:39:49 -0600
@@ -1 +1,2 @@
 uqm_CFILES="posixthreads.c"
+uqm_HFILES="posixthreads.h"
diff -ruNp src.orig/libs/threads/sdl/Makeinfo src/libs/threads/sdl/Makeinfo
--- src.orig/libs/threads/sdl/Makeinfo	2017-11-21 19:39:33 -0600
+++ src/libs/threads/sdl/Makeinfo	2017-11-21 19:39:49 -0600
@@ -1 +1,2 @@
 uqm_CFILES="sdlthreads.c"
+uqm_HFILES="sdlthreads.h"
diff -ruNp src.orig/libs/threads/thrcommon.c src/libs/threads/thrcommon.c
--- src.orig/libs/threads/thrcommon.c	2017-11-21 19:39:33 -0600
+++ src/libs/threads/thrcommon.c	2017-11-21 19:39:50 -0600
@@ -19,6 +19,7 @@
 #include "libs/threadlib.h"
 #include "libs/timelib.h"
 #include "libs/log.h"
+#include "libs/async.h"
 #include "libs/memlib.h"
 #include "thrcommon.h"
 
@@ -284,16 +285,79 @@ WaitThread (Thread thread, int *status)
 	NativeWaitThread (thread, status);
 }
 
+#ifdef DEBUG_SLEEP
+extern uint32 mainThreadId;
+extern uint32 SDL_ThreadID(void);
+#endif  /* DEBUG_SLEEP */
+
+void
+HibernateThread (TimePeriod timePeriod)
+{
+#ifdef DEBUG_SLEEP
+	if (SDL_ThreadID() == mainThreadId)
+		log_add (log_Debug, "HibernateThread called from main thread.\n");
+#endif  /* DEBUG_SLEEP */
+
+	NativeSleepThread (timePeriod);
+}
+
+void
+HibernateThreadUntil (TimeCount wakeTime)
+{
+#ifdef DEBUG_SLEEP
+	if (SDL_ThreadID() == mainThreadId)
+		log_add (log_Debug, "HibernateThreadUntil called from main "
+				"thread.\n");
+#endif  /* DEBUG_SLEEP */
+
+	NativeSleepThreadUntil (wakeTime);
+}
+
 void
 SleepThread (TimePeriod timePeriod)
 {
-	NativeSleepThread (timePeriod);
+	TimeCount now;
+
+#ifdef DEBUG_SLEEP
+	if (SDL_ThreadID() != mainThreadId)
+		log_add (log_Debug, "SleepThread called from non-main "
+				"thread.\n");
+#endif  /* DEBUG_SLEEP */
+
+	now = GetTimeCounter ();
+	SleepThreadUntil (now + timePeriod);
 }
 
+// Sleep until wakeTime, but call asynchrounous operations until then.
 void
 SleepThreadUntil (TimeCount wakeTime)
 {
-	NativeSleepThreadUntil (wakeTime);
+#ifdef DEBUG_SLEEP
+	if (SDL_ThreadID() != mainThreadId)
+		log_add (log_Debug, "SleepThreadUntil called from non-main "
+				"thread.\n");
+#endif  /* DEBUG_SLEEP */
+
+	for (;;) {
+		uint32 nextTimeMs;
+		TimeCount nextTime;
+		TimeCount now;
+
+		Async_process ();
+
+		now = GetTimeCounter ();
+		if (wakeTime <= now)
+			return;
+		
+		nextTimeMs = Async_timeBeforeNextMs ();
+		nextTime = (nextTimeMs / 1000) * ONE_SECOND +
+				((nextTimeMs % 1000) * ONE_SECOND / 1000);
+				// Overflow-safe conversion.
+		if (wakeTime < nextTime)
+			nextTime = wakeTime;
+
+		NativeSleepThreadUntil (nextTime);
+	}
 }
 
 void
diff -ruNp src.orig/libs/time/Makeinfo src/libs/time/Makeinfo
--- src.orig/libs/time/Makeinfo	2017-11-21 19:39:33 -0600
+++ src/libs/time/Makeinfo	2017-11-21 19:39:50 -0600
@@ -1,2 +1,3 @@
 uqm_SUBDIRS="sdl"
 uqm_CFILES="timecommon.c"
+uqm_HFILES="timecommon.h"
diff -ruNp src.orig/libs/time/sdl/Makeinfo src/libs/time/sdl/Makeinfo
--- src.orig/libs/time/sdl/Makeinfo	2017-11-21 19:39:33 -0600
+++ src/libs/time/sdl/Makeinfo	2017-11-21 19:39:50 -0600
@@ -1 +1,2 @@
 uqm_CFILES="sdltime.c"
+uqm_HFILES="sdltime.h"
diff -ruNp src.orig/libs/timelib.h src/libs/timelib.h
--- src.orig/libs/timelib.h	2017-11-21 19:39:33 -0600
+++ src/libs/timelib.h	2017-11-21 19:39:50 -0600
@@ -21,6 +21,10 @@
 
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 /* ONE_SECOND is the LCM of all the fractions of a second the game uses.
  * Battle is 24 FPS, Landers are 35 FPS, most UI-level things are 15 FPS,
  * The Interplanetary flight is 30 FPS, Comm ambient animation is 40 FPS,
@@ -38,5 +42,9 @@ extern void InitTimeSystem (void);
 extern void UnInitTimeSystem (void);
 extern TimeCount GetTimeCounter (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _TIMLIB_H */
 
diff -ruNp src.orig/libs/uio/Makeinfo src/libs/uio/Makeinfo
--- src.orig/libs/uio/Makeinfo	2017-11-21 19:39:34 -0600
+++ src/libs/uio/Makeinfo	2017-11-21 19:39:50 -0600
@@ -1,8 +1,10 @@
 uqm_SUBDIRS="stdio"
-uqm_CFILES="charhashtable.c defaultfs.c fileblock.c fstypes.c
-		gphys.c io.c ioaux.c match.c mount.c
-		mounttree.c paths.c physical.c uiostream.c uioutils.c
-		utils.c"
+uqm_CFILES="charhashtable.c defaultfs.c fileblock.c fstypes.c gphys.c io.c
+		ioaux.c match.c mount.c mounttree.c paths.c physical.c uiostream.c
+		uioutils.c utils.c"
+uqm_HFILES="charhashtable.h defaultfs.h fileblock.h fstypes.h getint.h
+		gphys.h ioaux.h io.h iointrn.h match.h mem.h mount.h mounttree.h
+		paths.h physical.h types.h uioport.h uiostream.h uioutils.h utils.h"
 
 if [ -n "$uqm_USE_ZIP_IO" ]; then
 	uqm_SUBDIRS="$uqm_SUBDIRS zip"
@@ -10,9 +12,11 @@ fi
 
 #if [ -n "$DEBUG" -o -n "$uqm_UIO_DEBUG" ]; then
 	uqm_CFILES="$uqm_CFILES debug.c"
+	uqm_HFILES="$uqm_HFILES debug.h"
 #fi
 
 if [ -n "$MEMDEBUG" ]; then
 	uqm_CFILES="$uqm_CFILES hashtable.c memdebug.c"
+	uqm_HFILES="$uqm_HFILES hashtable.h memdebug.h"
 fi
 
diff -ruNp src.orig/libs/uio/charhashtable.c src/libs/uio/charhashtable.c
--- src.orig/libs/uio/charhashtable.c	2017-11-21 19:39:33 -0600
+++ src/libs/uio/charhashtable.c	2017-11-21 19:39:50 -0600
@@ -30,7 +30,7 @@ static inline uio_bool CharHashTable_equ
 		const char *key1, const char *key2);
 static inline char *CharHashTable_copy(CharHashTable_HashTable *hashTable,
 		const char *key);
-static inline void CharHashTable_free(CharHashTable_HashTable *hashTable,
+static inline void CharHashTable_freeKey(CharHashTable_HashTable *hashTable,
 		char *key);
 
 #include "hashtable.c"
@@ -56,21 +56,21 @@ CharHashTable_hash(CharHashTable_HashTab
 static inline uio_bool
 CharHashTable_equal(CharHashTable_HashTable *hashTable,
 		const char *key1, const char *key2) {
-	(void) *hashTable;
+	(void) hashTable;
 	return strcmp(key1, key2) == 0;
 }
 
 static inline char *
 CharHashTable_copy(CharHashTable_HashTable *hashTable,
 		const char *key) {
-	(void) *hashTable;
+	(void) hashTable;
 	return uio_strdup(key);
 }
 
 static inline void
-CharHashTable_free(CharHashTable_HashTable *hashTable,
+CharHashTable_freeKey(CharHashTable_HashTable *hashTable,
 		char *key) {
-	(void) *hashTable;
+	(void) hashTable;
 	uio_free(key);
 }
 
diff -ruNp src.orig/libs/uio/charhashtable.h src/libs/uio/charhashtable.h
--- src.orig/libs/uio/charhashtable.h	2017-11-21 19:39:33 -0600
+++ src/libs/uio/charhashtable.h	2017-11-21 19:39:50 -0600
@@ -28,10 +28,12 @@ typedef void HASHTABLE_(Value);
 #define CharHashTable_HASH CharHashTable_hash
 #define CharHashTable_EQUAL CharHashTable_equal
 #define CharHashTable_COPY CharHashTable_copy
-#define CharHashTable_FREE CharHashTable_free
+#define CharHashTable_FREEKEY CharHashTable_freeKey
+#define CharHashTable_FREEVALUE(hashTable, value) \
+		((void) (hashTable), (void) (value))
 
 #include "hashtable.h"
 
 
-#endif  /* _HASHTABLE_H */
+#endif  /* _CHARHASHTABLE_H */
 
diff -ruNp src.orig/libs/uio/debug.c src/libs/uio/debug.c
--- src.orig/libs/uio/debug.c	2017-11-21 19:39:33 -0600
+++ src/libs/uio/debug.c	2017-11-21 19:39:50 -0600
@@ -473,7 +473,7 @@ debugCmdExec(DebugContext *debugContext,
 				O_RDONLY, tempDir);
 		if (handles[i - 1] == NULL) {
 			if (errno == ENOENT) {
-				// No match; we keep what's typed litterally.
+				// No match; we keep what's typed literally.
 				newArgs[i - 1] = argv[i];
 				continue;
 			}
@@ -703,7 +703,7 @@ listOneDir(DebugContext *debugContext, c
 				match_MATCH_PREFIX);
 	} else {
 		dirList = uio_getDirList(debugContext->cwd, cpath, pattern,
-				match_MATCH_LITTERAL);
+				match_MATCH_LITERAL);
 	}
 #endif
 	if (dirList == NULL) {
diff -ruNp src.orig/libs/uio/doc/basics src/libs/uio/doc/basics
--- src.orig/libs/uio/doc/basics	2017-11-21 19:39:33 -0600
+++ src/libs/uio/doc/basics	2017-11-21 19:39:50 -0600
@@ -123,18 +123,56 @@ no problem, as long as the repositories
 -= Internals =-
 
 Types:
-uio_MountTree - A node in a data structure describing the mounted directories.
-uio_PRoot - A struct describing the a physical file system.
-uio_PRootExtra - Filesystem-dependant extra data for a PRoot.
-uio_GPRoot - Generic filesystem-dependant data for a PRoot, used as
-            uio_PRootExtra.
-uio_GPRootExtra - Extra filesystem-dependant data for a PRoot, when using
-                 uio_GPRoot for generic filesystem-dependant data.
-uio_GPDir - Generic structure representing a node in a physical directory
-           structure describing one directory.
-uio_GPFile - Generic structure describing a file in a physical file system.
 
+uio_MountTree
+    A node in a data structure describing the mounted directories.
 
-TODO: functions
+uio_PRoot
+    A struct describing the a physical file system.
+
+uio_PRootExtra
+    Filesystem-dependant extra data for a PRoot.
+
+uio_GPRoot
+    Generic filesystem-dependant data for a PRoot, used as uio_PRootExtra.
+
+uio_GPRootExtra
+    Extra filesystem-dependant data for a PRoot, when using uio_GPRoot for
+    generic filesystem-dependant data.
+
+uio_GPDir
+    Generic structure representing a node in a physical directory structure
+    describing one directory.
+
+uio_GPFile
+    Generic structure describing a file in a physical file system.
+
+
+Helper functions (defined in ioaux.c):
+
+uio_copyFilePhysical
+    Copy a file from one physical directory to another.
+
+uio_getPathPhysicalDirs
+    Get handles to the (existing) physical dirs that are effective in a
+    path 'path' relative from 'dirHandle'
+
+uio_getPhysicalAccess
+    Find PDirHandle and MountInfo structures for reading and writing for a path
+    from a DirHandle.
+
+uio_makePath
+    Create a directory inside a physical directory. All non-existant
+    parent directories will be created as well.
+
+uio_resolvePath
+    Determine the absolute path given a path relative to a given directory.
+
+uio_verifyPath
+    Test whether a path is valid and exists.
+
+uio_walkPhysicalPath
+    Follow a path starting from a specified physical dir for as long as
+    possible.
 
 
diff -ruNp src.orig/libs/uio/gphys.h src/libs/uio/gphys.h
--- src.orig/libs/uio/gphys.h	2017-11-21 19:39:33 -0600
+++ src/libs/uio/gphys.h	2017-11-21 19:39:50 -0600
@@ -33,7 +33,7 @@ typedef struct CharHashTable_HashTable u
 
 #define uio_GPDirEntries_new() \
 		((uio_GPDirEntries *) CharHashTable_newHashTable(NULL, NULL, NULL, \
-		NULL, 0, 0.85, 0.9))
+		NULL, NULL, 0, 0.85, 0.9))
 #define uio_GPDirEntries_add(hashTable, name, item) \
 		CharHashTable_add((CharHashTable_HashTable *) hashTable, name, \
 		(void *) item)
diff -ruNp src.orig/libs/uio/hashtable.c src/libs/uio/hashtable.c
--- src.orig/libs/uio/hashtable.c	2017-11-21 19:39:33 -0600
+++ src/libs/uio/hashtable.c	2017-11-21 19:39:50 -0600
@@ -46,12 +46,14 @@ static inline HASHTABLE_(HashEntry) *HAS
 static inline void HASHTABLE_(freeHashEntry)(
 		HASHTABLE_(HashEntry) *entry);
 
+// Create a new HashTable.
 HASHTABLE_(HashTable) *
 HASHTABLE_(newHashTable)(
 		HASHTABLE_(HashFunction) hashFunction,
 		HASHTABLE_(EqualFunction) equalFunction,
 		HASHTABLE_(CopyFunction) copyFunction,
-		HASHTABLE_(FreeFunction) freeFunction,
+		HASHTABLE_(FreeKeyFunction) freeKeyFunction,
+		HASHTABLE_(FreeValueFunction) freeValueFunction,
 		uio_uint32 initialSize,
 		double minFillQuotient,
 		double maxFillQuotient) {
@@ -63,7 +65,8 @@ HASHTABLE_(newHashTable)(
 	hashTable->hashFunction = hashFunction;
 	hashTable->equalFunction = equalFunction;
 	hashTable->copyFunction = copyFunction;
-	hashTable->freeFunction = freeFunction;
+	hashTable->freeKeyFunction = freeKeyFunction;
+	hashTable->freeValueFunction = freeValueFunction;
 
 	hashTable->minFillQuotient = minFillQuotient;
 	hashTable->maxFillQuotient = maxFillQuotient;
@@ -72,6 +75,7 @@ HASHTABLE_(newHashTable)(
 	return hashTable;
 }
 
+// Add an entry to the HashTable.
 uio_bool
 HASHTABLE_(add)(HASHTABLE_(HashTable) *hashTable,
 		const HASHTABLE_(Key) *key, HASHTABLE_(Value) *value) {
@@ -104,6 +108,7 @@ HASHTABLE_(add)(HASHTABLE_(HashTable) *h
 	return true;
 }
 
+// Remove an entry with a specified Key from the HashTable.
 uio_bool
 HASHTABLE_(remove)(HASHTABLE_(HashTable) *hashTable,
 		const HASHTABLE_(Key) *key) {
@@ -122,7 +127,8 @@ HASHTABLE_(remove)(HASHTABLE_(HashTable)
 		entry = &(*entry)->next;
 	}
 	next = (*entry)->next;
-	HASHTABLE_(FREE)(hashTable, (*entry)->key);
+	HASHTABLE_(FREEKEY)(hashTable, (*entry)->key);
+	HASHTABLE_(FREEVALUE)(hashTable, (*entry)->value);
 	HASHTABLE_(freeHashEntry)(*entry);
 	*entry = next;
 
@@ -133,6 +139,7 @@ HASHTABLE_(remove)(HASHTABLE_(HashTable)
 	return true;
 }
 
+// Find the Value stored for some Key.
 HASHTABLE_(Value) *
 HASHTABLE_(find)(HASHTABLE_(HashTable) *hashTable,
 		const HASHTABLE_(Key) *key) {
@@ -151,21 +158,23 @@ HASHTABLE_(find)(HASHTABLE_(HashTable) *
 	return NULL;
 }
 
+// Returns the number of entries in the HashTable.
 uio_uint32
 HASHTABLE_(count)(const HASHTABLE_(HashTable) *hashTable) {
 	return hashTable->numEntries;
 }
 
+// Auxiliary function to (re)initialise the buckets in the HashTable.
 static void
 HASHTABLE_(setup)(HASHTABLE_(HashTable) *hashTable, uio_uint32 initialSize) {
 	if (initialSize < 4)
 		initialSize = 4;
-	hashTable->size = nextPower2((uio_uint32) ceil(
-				((double) initialSize) / hashTable->maxFillQuotient));
+	hashTable->size = nextPower2(ceil(((double) initialSize) /
+			hashTable->maxFillQuotient));
 	hashTable->hashMask = hashTable->size - 1;
-	hashTable->minSize = (uio_uint32) ceil(((double) (hashTable->size >> 1))
+	hashTable->minSize = ceil(((double) (hashTable->size >> 1))
 			* hashTable->minFillQuotient);
-	hashTable->maxSize = (uio_uint32) floor(((double) hashTable->size)
+	hashTable->maxSize = floor(((double) hashTable->size)
 			* hashTable->maxFillQuotient);
 	hashTable->entries = uio_calloc(hashTable->size,
 			sizeof (HASHTABLE_(HashEntry) *));
@@ -175,6 +184,7 @@ HASHTABLE_(setup)(HASHTABLE_(HashTable)
 #endif
 }
 
+// Resize the buckets in the HashTable.
 static void
 HASHTABLE_(resize)(HASHTABLE_(HashTable) *hashTable) {
 	HASHTABLE_(HashEntry) **oldEntries;
@@ -224,6 +234,7 @@ nextPower2(uio_uint32 x) {
 	return x + 1;
 }
 
+// Get an iterator to iterate through all the entries in the HashTable.
 // NB: Iterator should be considered invalid if the HashTable is changed.
 // TODO: change this (make it thread-safe)
 //       this can be done by only marking items as deleted when
@@ -252,21 +263,26 @@ HASHTABLE_(getIterator)(const HASHTABLE_
 	return iterator;
 }
 
+// Returns true if and only if there are no more entries in the hash table
+// for the Iterator to find.
 int
 HASHTABLE_(iteratorDone)(const HASHTABLE_(Iterator) *iterator) {
 	return iterator->bucketNr >= iterator->hashTable->size;
 }
 
+// Get the Key of the entry pointed to by an Iterator.
 HASHTABLE_(Key) *
 HASHTABLE_(iteratorKey)(HASHTABLE_(Iterator) *iterator) {
 	return iterator->entry->key;
 }
 
+// Get the Value of the entry pointed to by an Iterator.
 HASHTABLE_(Value) *
 HASHTABLE_(iteratorValue)(HASHTABLE_(Iterator) *iterator) {
 	return iterator->entry->value;
 }
 
+// Move the Iterator to the next entry in the HashTable.
 // Should not be called if the iterator is already past the last entry.
 HASHTABLE_(Iterator) *
 HASHTABLE_(iteratorNext)(HASHTABLE_(Iterator) *iterator) {
@@ -293,16 +309,19 @@ HASHTABLE_(iteratorNext)(HASHTABLE_(Iter
 	return iterator;
 }
 
+// Free the Iterator.
 void
 HASHTABLE_(freeIterator)(HASHTABLE_(Iterator) *iterator) {
 	uio_free(iterator);
 }
 
+// Auxiliary function to allocate a HashTable.
 static inline HASHTABLE_(HashTable) *
 HASHTABLE_(allocHashTable)(void) {
 	return uio_malloc(sizeof (HASHTABLE_(HashTable)));
 }
 
+// Auxiliary function to create a HashEntry.
 static inline HASHTABLE_(HashEntry) *
 HASHTABLE_(newHashEntry)(uio_uint32 hash, HASHTABLE_(Key) *key,
 		HASHTABLE_(Value) *value, HASHTABLE_(HashEntry) *next) {
@@ -316,11 +335,13 @@ HASHTABLE_(newHashEntry)(uio_uint32 hash
 	return result;
 }
 
+// Allocate a new HashEntry.
 static inline HASHTABLE_(HashEntry) *
 HASHTABLE_(allocHashEntry)(void) {
 	return uio_malloc(sizeof (HASHTABLE_(HashEntry)));
 }
 
+// Delete the HashTable.
 void
 HASHTABLE_(deleteHashTable)(HASHTABLE_(HashTable) *hashTable) {
 	uio_uint32 i;
@@ -333,7 +354,8 @@ HASHTABLE_(deleteHashTable)(HASHTABLE_(H
 		entry = *bucketPtr;
 		while (entry != NULL) {
 			next = entry->next;
-			HASHTABLE_(FREE)(hashTable, entry->key);
+			HASHTABLE_(FREEKEY)(hashTable, entry->key);
+			HASHTABLE_(FREEVALUE)(hashTable, entry->value);
 			HASHTABLE_(freeHashEntry)(entry);
 			entry = next;
 			i--;
@@ -344,6 +366,7 @@ HASHTABLE_(deleteHashTable)(HASHTABLE_(H
 	uio_free(hashTable);
 }
 
+// Auxiliary function to deallocate a HashEntry.
 static inline void
 HASHTABLE_(freeHashEntry)(HASHTABLE_(HashEntry) *entry) {
 	uio_free(entry);
diff -ruNp src.orig/libs/uio/hashtable.h src/libs/uio/hashtable.h
--- src.orig/libs/uio/hashtable.h	2017-11-21 19:39:33 -0600
+++ src/libs/uio/hashtable.h	2017-11-21 19:39:50 -0600
@@ -39,6 +39,8 @@
 // (and typedefs) from the HASHTABLE_ block below.
 // In the .c file, #define HASHTABLE_INTERNAL, #include the .h file
 // and hashtable.c (in this order), and add the necessary functions.
+// If you do not need to free the Value, you can define HashTable_FREEVALUE
+// as a no-op.
 #ifndef HASHTABLE_
 #	define HASHTABLE_(identifier) HashTable ## _ ## identifier
 	typedef void HashTable_Key;
@@ -49,8 +51,10 @@
 		(hashTable)->equalFunction(hashKey1, hashKey2)
 #	define HashTable_COPY(hashTable, hashKey) \
 		(hashTable)->copyFunction(hashKey)
-#	define HashTable_FREE(hashTable, hashKey) \
-		(hashTable)->freeFunction(hashKey)
+#	define HashTable_FREEKEY(hashTable, hashKey) \
+		(hashTable)->freeKeyFunction(hashKey)
+#	define HashTable_FREEVALUE(hashTable, hashValue) \
+		(hashTable)->freeValueFunction(hashValue)
 #endif
 
 
@@ -59,8 +63,9 @@ typedef uio_uint32 (*HASHTABLE_(HashFunc
 typedef uio_bool (*HASHTABLE_(EqualFunction))(const HASHTABLE_(Key) *,
 		const HASHTABLE_(Key) *);
 typedef HASHTABLE_(Value) *(*HASHTABLE_(CopyFunction))(
-		const HASHTABLE_(Value) *);
-typedef void (*HASHTABLE_(FreeFunction))(HASHTABLE_(Value) *);
+		const HASHTABLE_(Key) *);
+typedef void (*HASHTABLE_(FreeKeyFunction))(HASHTABLE_(Key) *);
+typedef void (*HASHTABLE_(FreeValueFunction))(HASHTABLE_(Value) *);
 
 typedef struct HASHTABLE_(HashTable) HASHTABLE_(HashTable);
 typedef struct HASHTABLE_(HashEntry) HASHTABLE_(HashEntry);
@@ -68,9 +73,17 @@ typedef struct HASHTABLE_(Iterator) HASH
 
 struct HASHTABLE_(HashTable) {
 	HASHTABLE_(HashFunction) hashFunction;	
+			// Function creating a uio_uint32 hash of a key.
 	HASHTABLE_(EqualFunction) equalFunction;
+			// Function used to compare two keys.
 	HASHTABLE_(CopyFunction) copyFunction;
-	HASHTABLE_(FreeFunction) freeFunction;
+			// Function used to copy a key.
+	HASHTABLE_(FreeKeyFunction) freeKeyFunction;
+			// Function used to free a key.
+	HASHTABLE_(FreeValueFunction) freeValueFunction;
+			// Function used to free a value. Called when an entry is
+			// removed using the remove function, or for entries
+			// still in the HashTable when the HashTable is deleted.
 
 	double minFillQuotient;
 			// How much of half of the hashtable needs to be filled
@@ -114,7 +127,9 @@ HASHTABLE_(HashTable) *HASHTABLE_(newHas
 		HASHTABLE_(HashFunction) hashFunction,
 		HASHTABLE_(EqualFunction) equalFunction,
 		HASHTABLE_(CopyFunction) copyFunction,
-		HASHTABLE_(FreeFunction) freeFunction, uio_uint32 initialSize,
+		HASHTABLE_(FreeKeyFunction) freeKeyFunction,
+		HASHTABLE_(FreeValueFunction) freeValueFunction,
+		uio_uint32 initialSize,
 		double minFillQuotient, double maxFillQuotient);
 uio_bool HASHTABLE_(add)(HASHTABLE_(HashTable) *hashTable,
 		const HASHTABLE_(Key) *key, HASHTABLE_(Value) *value);
diff -ruNp src.orig/libs/uio/io.c src/libs/uio/io.c
--- src.orig/libs/uio/io.c	2017-11-21 19:39:33 -0600
+++ src/libs/uio/io.c	2017-11-21 19:39:50 -0600
@@ -287,6 +287,103 @@ uio_mountDir(uio_Repository *destRep, co
 	}
 }
 
+// Mount a repository directory into same repository at a different location
+// From fossil.
+uio_MountHandle *
+uio_transplantDir(const char *mountPoint, uio_DirHandle *sourceDir, int flags,
+		uio_MountHandle *relative) {
+	uio_MountInfo *relativeInfo;
+	int numPDirHandles;
+	uio_PDirHandle **pDirHandles;
+	uio_MountTreeItem **treeItems;
+	int i;
+	uio_MountHandle *handle = NULL;
+
+	if ((flags & uio_MOUNT_RDONLY) != uio_MOUNT_RDONLY) {
+		// Only read-only transplants supported atm
+		errno = ENOSYS;
+		return NULL;
+	}
+
+	switch (flags & uio_MOUNT_LOCATION_MASK) {
+		case uio_MOUNT_TOP:
+		case uio_MOUNT_BOTTOM:
+			if (relative != NULL) {
+				errno = EINVAL;
+				return NULL;
+			}
+			relativeInfo = NULL;
+			break;
+		case uio_MOUNT_BELOW:
+		case uio_MOUNT_ABOVE:
+			if (relative == NULL) {
+				errno = EINVAL;
+				return NULL;
+			}
+			relativeInfo = relative->mountInfo;
+			break;
+		default:
+			abort();
+	}
+
+	if (mountPoint[0] == '/')
+		mountPoint++;
+	if (!validPathName(mountPoint, strlen(mountPoint))) {
+		errno = EINVAL;
+		return NULL;
+	}
+
+	if (uio_getPathPhysicalDirs(sourceDir, "", 0,
+			&pDirHandles, &numPDirHandles, &treeItems) == -1) {
+		// errno is set
+		return NULL;
+	}
+	if (numPDirHandles == 0) {
+		errno = ENOENT;
+		return NULL;
+	}
+	
+	// TODO: We only transplant the first read-only physical dir that we find
+	//    Maybe transplant all of them? We would then have several
+	//    uio_MountHandles to return.
+	for (i = 0; i < numPDirHandles; ++i) {
+		uio_PDirHandle *pDirHandle = pDirHandles[i];
+		uio_MountInfo *oldMountInfo = treeItems[i]->mountInfo;
+		uio_Repository *rep = oldMountInfo->mountHandle->repository;
+		uio_MountInfo *mountInfo;
+		uio_MountTree *mountTree;
+
+		// Only interested in read-only dirs in this incarnation
+		if (!uio_mountInfoIsReadOnly(oldMountInfo))
+			continue;
+	
+		mountInfo = uio_MountInfo_new(oldMountInfo->fsID, NULL, pDirHandle,
+				uio_strdup(""), oldMountInfo->autoMount, NULL, flags);
+		// New mount references the same handles
+		uio_PDirHandle_ref(pDirHandle);
+		uio_PRoot_refMount(pDirHandle->pRoot);
+
+		uio_repositoryAddMount(rep, mountInfo,
+				flags & uio_MOUNT_LOCATION_MASK, relativeInfo);
+		mountTree = uio_mountTreeAddMountInfo(rep, rep->mountTree,
+				mountInfo, mountPoint, flags & uio_MOUNT_LOCATION_MASK,
+				relativeInfo);
+		// mountTree is the node in rep->mountTree where mountInfo leads to
+		mountInfo->mountTree = mountTree;
+		mountInfo->mountHandle = uio_MountHandle_new(rep, mountInfo);
+		handle = mountInfo->mountHandle;
+		break;
+	}
+
+	uio_PDirHandles_delete(pDirHandles, numPDirHandles);
+	uio_free(treeItems);
+	
+	if (handle == NULL)
+		errno = ENOENT;
+
+	return handle;
+}
+
 int
 uio_unmountDir(uio_MountHandle *mountHandle) {
 	uio_PRoot *pRoot;
diff -ruNp src.orig/libs/uio/io.h src/libs/uio/io.h
--- src.orig/libs/uio/io.h	2017-11-21 19:39:33 -0600
+++ src/libs/uio/io.h	2017-11-21 19:39:50 -0600
@@ -82,6 +82,12 @@ uio_MountHandle *uio_mountDir(uio_Reposi
 		const char *inPath, uio_AutoMount **autoMount, int flags,
 		uio_MountHandle *relative);
 
+// Mount a repository directory into same repository at a different
+// location.
+// From fossil.
+uio_MountHandle *uio_transplantDir(const char *mountPoint,
+		uio_DirHandle *sourceDir, int flags, uio_MountHandle *relative);
+
 // Unmount a previously mounted dir.
 int uio_unmountDir(uio_MountHandle *mountHandle);
 
diff -ruNp src.orig/libs/uio/ioaux.c src/libs/uio/ioaux.c
--- src.orig/libs/uio/ioaux.c	2017-11-21 19:39:34 -0600
+++ src/libs/uio/ioaux.c	2017-11-21 19:39:50 -0600
@@ -260,7 +260,7 @@ uio_copyFilePhysical(uio_PDirHandle *fro
  * Closes fromHandle if it's not -1.
  * Removes 'toName' from 'toDir' if it's not NULL.
  * Frees 'buf' if not NULL.
- * Always returns -1.
+ * Always returns -1, setting errno to 'error'.
  */
 static int
 copyError(int error,
@@ -605,15 +605,26 @@ uio_getPhysicalAccess(uio_DirHandle *dir
 	return 0;
 }
 
-// Get handles to the (existing) physical dirs that are effective in a
-// path 'path' relative from 'dirHandle'
-// returns the PDirHandles through '*pDirHandles'. It is NULL if none
-// were found.
-// If resItems != NULL, it returns the MountTreeItems belonging to those
-// PDIrHandles through *resItems. It is NULL if none were found.
-// numPDirHandles will contain the number of PDirHandles found.
-// returns 0 if everything went ok.
-// returns -1 in case of an error; errno is set.
+
+/**
+ * Get handles to the (existing) physical dirs that are effective in a
+ * path 'path' relative from 'dirHandle'
+ *
+ * @param[in]  pDirHandle The physical directory to which 'path' is
+ * 		relative.
+ * @param[in]  path       The path to get the physical dirs for, relative to
+ * 		'pDirHandle'
+ * @param[in]  pathLen    The string length of 'path'.
+ * @param[out] resPDirHandles *resPDirHandles is set to the handles to the
+ * 		(existing) physical dirs that are effective in 'path' (relative to
+ * 		pDirHandle), or NULL if there are none.
+ * @param[out] resNumPDirHandles The number of PDirHandles found.
+ * @param[out] resItems If 'resItems' != NULL, *resItems is set to the
+ * 		MountTreeItems belonging to $pDirHandles, or NULL if none were found.
+ *
+ * @retval 0   if everything went ok.
+ * @retval -1  if an error occurred; #errno is set.
+ */
 int
 uio_getPathPhysicalDirs(uio_DirHandle *dirHandle, const char *path,
 		size_t pathLen, uio_PDirHandle ***resPDirHandles,
diff -ruNp src.orig/libs/uio/match.c src/libs/uio/match.c
--- src.orig/libs/uio/match.c	2017-11-21 19:39:34 -0600
+++ src/libs/uio/match.c	2017-11-21 19:39:50 -0600
@@ -37,9 +37,9 @@
 static inline match_MatchContext *match_allocMatchContext(void);
 static inline void match_freeMatchContext(match_MatchContext *context);
 
-static inline match_LitteralContext *match_newLitteralContext(char *pattern);
-static inline match_LitteralContext *match_allocLitteralContext(void);
-static inline void match_freeLitteralContext(match_LitteralContext *context);
+static inline match_LiteralContext *match_newLiteralContext(char *pattern);
+static inline match_LiteralContext *match_allocLiteralContext(void);
+static inline void match_freeLiteralContext(match_LiteralContext *context);
 static inline match_PrefixContext *match_newPrefixContext(char *pattern);
 static inline match_PrefixContext *match_allocPrefixContext(void);
 static inline void match_freePrefixContext(match_PrefixContext *context);
@@ -85,9 +85,9 @@ match_prepareContext(const char *pattern
 	*contextPtr = match_allocMatchContext();
 	(*contextPtr)->type = type;
 	switch (type) {
-		case match_MATCH_LITTERAL:
-			result = match_prepareLitteral(pattern,
-					&(*contextPtr)->u.litteral);
+		case match_MATCH_LITERAL:
+			result = match_prepareLiteral(pattern,
+					&(*contextPtr)->u.literal);
 			break;
 		case match_MATCH_PREFIX:
 			result = match_preparePrefix(pattern, &(*contextPtr)->u.prefix);
@@ -122,8 +122,8 @@ match_prepareContext(const char *pattern
 match_Result
 match_matchPattern(match_MatchContext *context, const char *string) {
 	switch (context->type) {
-		case match_MATCH_LITTERAL:
-			return match_matchLitteral(context->u.litteral, string);
+		case match_MATCH_LITERAL:
+			return match_matchLiteral(context->u.literal, string);
 		case match_MATCH_PREFIX:
 			return match_matchPrefix(context->u.prefix, string);
 		case match_MATCH_SUFFIX:
@@ -168,8 +168,8 @@ match_errorString(match_MatchContext *co
 
 	switch (context->type) {
 #if 0
-		case match_MATCH_LITTERAL:
-			return match_errorStringLitteral(context->u.litteral, result);
+		case match_MATCH_LITERAL:
+			return match_errorStringLiteral(context->u.literal, result);
 		case match_MATCH_PREFIX:
 			return match_errorStringPrefix(context->u.prefix, result);
 		case match_MATCH_SUFFIX:
@@ -193,8 +193,8 @@ match_errorString(match_MatchContext *co
 void
 match_freeContext(match_MatchContext *context) {
 	switch (context->type) {
-		case match_MATCH_LITTERAL:
-			match_freeLitteral(context->u.litteral);
+		case match_MATCH_LITERAL:
+			match_freeLiteral(context->u.literal);
 			break;
 		case match_MATCH_PREFIX:
 			match_freePrefix(context->u.prefix);
@@ -239,43 +239,43 @@ out:
 }
 
 
-// *** Litteral part ***
+// *** Literal part ***
 
 match_Result
-match_prepareLitteral(const char *pattern,
-		match_LitteralContext **contextPtr) {
-	*contextPtr = match_newLitteralContext(uio_strdup(pattern));
+match_prepareLiteral(const char *pattern,
+		match_LiteralContext **contextPtr) {
+	*contextPtr = match_newLiteralContext(uio_strdup(pattern));
 	return match_OK;
 }
 
 match_Result
-match_matchLitteral(match_LitteralContext *context, const char *string) {
+match_matchLiteral(match_LiteralContext *context, const char *string) {
 	return (strcmp(context->pattern, string) == 0) ?
 			match_MATCH : match_NOMATCH;
 }
 
 void
-match_freeLitteral(match_LitteralContext *context) {
+match_freeLiteral(match_LiteralContext *context) {
 	uio_free(context->pattern);
-	match_freeLitteralContext(context);
+	match_freeLiteralContext(context);
 }
 
-static inline match_LitteralContext *
-match_newLitteralContext(char *pattern) {
-	match_LitteralContext *result;
+static inline match_LiteralContext *
+match_newLiteralContext(char *pattern) {
+	match_LiteralContext *result;
 
-	result = match_allocLitteralContext();
+	result = match_allocLiteralContext();
 	result->pattern = pattern;
 	return result;
 }
 
-static inline match_LitteralContext *
-match_allocLitteralContext(void) {
-	return uio_malloc(sizeof (match_LitteralContext));
+static inline match_LiteralContext *
+match_allocLiteralContext(void) {
+	return uio_malloc(sizeof (match_LiteralContext));
 }
 
 static inline void
-match_freeLitteralContext(match_LitteralContext *context) {
+match_freeLiteralContext(match_LiteralContext *context) {
 	uio_free(context);
 }
 
diff -ruNp src.orig/libs/uio/match.h src/libs/uio/match.h
--- src.orig/libs/uio/match.h	2017-11-21 19:39:34 -0600
+++ src/libs/uio/match.h	2017-11-21 19:39:50 -0600
@@ -31,7 +31,7 @@ typedef struct match_MatchContext match_
 
 
 typedef enum {
-	match_MATCH_LITTERAL = 0,
+	match_MATCH_LITERAL = 0,
 	match_MATCH_PREFIX,
 	match_MATCH_SUFFIX,
 	match_MATCH_SUBSTRING,
@@ -52,7 +52,7 @@ typedef int match_Result;
 #define match_ECUSTOM   -3
 #define match_ENOTINIT  -4
 
-typedef struct match_LitteralContext match_LitteralContext;
+typedef struct match_LiteralContext match_LiteralContext;
 typedef struct match_PrefixContext match_PrefixContext;
 typedef struct match_SuffixContext match_SuffixContext;
 typedef struct match_SubStringContext match_SubStringContext;
@@ -87,7 +87,7 @@ match_Result match_matchPatternOnce(cons
 struct match_MatchContext {
 	match_MatchType type;
 	union {
-		match_LitteralContext *litteral;
+		match_LiteralContext *literal;
 		match_PrefixContext *prefix;
 		match_SuffixContext *suffix;
 		match_SubStringContext *subString;
@@ -100,7 +100,7 @@ struct match_MatchContext {
 	} u;
 };
 
-struct match_LitteralContext {
+struct match_LiteralContext {
 	char *pattern;
 };
 
@@ -134,11 +134,11 @@ struct match_RegexContext {
 };
 #endif
 
-match_Result match_prepareLitteral(const char *pattern,
-		match_LitteralContext **contextPtr);
-match_Result match_matchLitteral(match_LitteralContext *context,
+match_Result match_prepareLiteral(const char *pattern,
+		match_LiteralContext **contextPtr);
+match_Result match_matchLiteral(match_LiteralContext *context,
 		const char *string);
-void match_freeLitteral(match_LitteralContext *context);
+void match_freeLiteral(match_LiteralContext *context);
 
 match_Result match_preparePrefix(const char *pattern,
 		match_PrefixContext **contextPtr);
diff -ruNp src.orig/libs/uio/mount.c src/libs/uio/mount.c
--- src.orig/libs/uio/mount.c	2017-11-21 19:39:34 -0600
+++ src/libs/uio/mount.c	2017-11-21 19:39:50 -0600
@@ -61,7 +61,7 @@ uio_repositoryAddMount(uio_Repository *r
 			repository->mounts[repository->numMounts] = mountInfo;
 			repository->numMounts++;
 			break;
-		case uio_MOUNT_BELOW: {
+		case uio_MOUNT_ABOVE: {
 			int i;
 			uio_MountInfo **newMounts;
 
@@ -76,7 +76,7 @@ uio_repositoryAddMount(uio_Repository *r
 			repository->numMounts++;
 			break;
 		}
-		case uio_MOUNT_ABOVE: {
+		case uio_MOUNT_BELOW: {
 			int i;
 			uio_MountInfo **newMounts;
 
diff -ruNp src.orig/libs/uio/physical.c src/libs/uio/physical.c
--- src.orig/libs/uio/physical.c	2017-11-21 19:39:34 -0600
+++ src/libs/uio/physical.c	2017-11-21 19:39:51 -0600
@@ -157,7 +157,7 @@ uio_PRoot_refMount(uio_PRoot *pRoot) {
 #ifdef uio_MEM_DEBUG
 	uio_MemDebug_debugRef(uio_PRoot, (void *) pRoot);
 #endif
-	pRoot->handleRef++;
+	pRoot->mountRef++;
 }
 
 void
diff -ruNp src.orig/libs/uio/stdio/Makeinfo src/libs/uio/stdio/Makeinfo
--- src.orig/libs/uio/stdio/Makeinfo	2017-11-21 19:39:34 -0600
+++ src/libs/uio/stdio/Makeinfo	2017-11-21 19:39:51 -0600
@@ -1,3 +1,2 @@
 uqm_CFILES="stdio.c"
-
-
+uqm_HFILES="stdio.h"
diff -ruNp src.orig/libs/uio/uioutils.h src/libs/uio/uioutils.h
--- src.orig/libs/uio/uioutils.h	2017-11-21 19:39:34 -0600
+++ src/libs/uio/uioutils.h	2017-11-21 19:39:51 -0600
@@ -44,8 +44,8 @@ char *dosToUnixPath(const char *path);
 static inline void *
 unconst(const void *arg) {
 	union {
-		char *c;
-		const char *cc;
+		void *c;
+		const void *cc;
 	} u;
 	u.cc = arg;
 	return u.c;
diff -ruNp src.orig/libs/uio/zip/Makeinfo src/libs/uio/zip/Makeinfo
--- src.orig/libs/uio/zip/Makeinfo	2017-11-21 19:39:34 -0600
+++ src/libs/uio/zip/Makeinfo	2017-11-21 19:39:51 -0600
@@ -1,3 +1,2 @@
 uqm_CFILES="zip.c"
-
-
+uqm_HFILES="zip.h"
diff -ruNp src.orig/libs/uio.h src/libs/uio.h
--- src.orig/libs/uio.h	2017-11-21 19:39:34 -0600
+++ src/libs/uio.h	2017-11-21 19:39:51 -0600
@@ -21,7 +21,15 @@
 #ifndef _UIO_H
 #define _UIO_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #include "uio/io.h"
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _UIO_H */
 
diff -ruNp src.orig/libs/uioutils.h src/libs/uioutils.h
--- src.orig/libs/uioutils.h	2017-11-21 19:39:34 -0600
+++ src/libs/uioutils.h	2017-11-21 19:39:51 -0600
@@ -21,7 +21,15 @@
 #ifndef _UIOUTILS_H
 #define _UIOUTILS_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #include "uio/utils.h"
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _UIOUTILS_H */
 
diff -ruNp src.orig/libs/unicode.h src/libs/unicode.h
--- src.orig/libs/unicode.h	2017-11-21 19:39:34 -0600
+++ src/libs/unicode.h	2017-11-21 19:39:51 -0600
@@ -23,6 +23,10 @@
 #include <sys/types.h>
 		// For size_t
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef uint32 UniChar;
 
 #ifdef UNICODE_INTERNAL
@@ -60,5 +64,9 @@ UniChar UniChar_toLower(UniChar ch);
 
 #undef UNICODE_CHAR
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* UNICODE_H */
 
diff -ruNp src.orig/libs/video/Makeinfo src/libs/video/Makeinfo
--- src.orig/libs/video/Makeinfo	2017-11-21 19:39:34 -0600
+++ src/libs/video/Makeinfo	2017-11-21 19:39:51 -0600
@@ -1,2 +1,3 @@
 uqm_CFILES="vfileins.c vresins.c video.c videodec.c vidplayer.c dukvid.c \
             legacyplayer.c"
+uqm_HFILES="dukvid.h videodec.h video.h vidintrn.h vidplayer.h"
diff -ruNp src.orig/libs/video/dukvid.c src/libs/video/dukvid.c
--- src.orig/libs/video/dukvid.c	2017-11-21 19:39:34 -0600
+++ src/libs/video/dukvid.c	2017-11-21 19:39:51 -0600
@@ -727,7 +727,8 @@ dukv_SeekTime (THIS_PTR, float time)
 	//TFB_DuckVideoDecoder* dukv = (TFB_DuckVideoDecoder*) This;
 	uint32 frame = (uint32) (time * DUCK_GENERAL_FPS);
 	
-	return (float) dukv_SeekFrame (This, frame) / DUCK_GENERAL_FPS;
+	// Note that DUCK_GENERAL_FPS is a float constant
+	return dukv_SeekFrame (This, frame) / DUCK_GENERAL_FPS;
 }
 
 static uint32
diff -ruNp src.orig/libs/video/video.c src/libs/video/video.c
--- src.orig/libs/video/video.c	2017-11-21 19:39:34 -0600
+++ src/libs/video/video.c	2017-11-21 19:39:51 -0600
@@ -127,7 +127,6 @@ VidPlayEx (VIDEO_REF vid, MUSIC_REF AudR
 	_cur_speech = 0;
 	_cur_video = NULL_VIDEO_REF;
 
-	LockMutex (GraphicsLock);
 	// play video in the center of the screen
 	if (TFB_PlayVideo (vid, (ScreenWidth - vid->w) / 2,
 			(ScreenHeight - vid->h) / 2))
@@ -144,7 +143,6 @@ VidPlayEx (VIDEO_REF vid, MUSIC_REF AudR
 	{
 		ret = NO_FMV;
 	}
-	UnlockMutex (GraphicsLock);
 
 	return ret;
 }
diff -ruNp src.orig/libs/video/vidintrn.h src/libs/video/vidintrn.h
--- src.orig/libs/video/vidintrn.h	2017-11-21 19:39:34 -0600
+++ src/libs/video/vidintrn.h	2017-11-21 19:39:51 -0600
@@ -38,10 +38,4 @@ struct legacy_video_ref
 	MUSIC_REF speechref;
 };
 
-// XXX: There has to be a better way to synchronize gfx calls with the rest
-//   of the game. The only thing we need to sync is the current context, and
-//   even there only the cliprect. Perhaps a DCQ command that takes an
-//   explicit cliprect would be better.
-extern Mutex GraphicsLock;
-
 #endif
diff -ruNp src.orig/libs/video/vidplayer.c src/libs/video/vidplayer.c
--- src.orig/libs/video/vidplayer.c	2017-11-21 19:39:34 -0600
+++ src/libs/video/vidplayer.c	2017-11-21 19:39:51 -0600
@@ -143,14 +143,12 @@ processAudioSyncedFrame (VIDEO_REF vid)
 	vid->cur_frame = vid->decoder->cur_frame;
 
 	// draw the frame
-	LockMutex (GraphicsLock);
 	// We have the cliprect precalculated and don't need the rest
 	oldContext = SetContext (NULL);
 	TFB_DrawScreen_Image (vid->frame,
 			vid->dst_rect.corner.x, vid->dst_rect.corner.y, 0, 0,
 			NULL, DRAW_REPLACE_MODE, TFB_SCREEN_MAIN);
 	SetContext (oldContext);
-	UnlockMutex (GraphicsLock);
 	FlushGraphics (); // needed to prevent half-frame updates
 
 	// increase interframe with positive lag-count to allow audio to catch up
@@ -195,14 +193,12 @@ processMuteFrame (VIDEO_REF vid)
 		
 		vid->cur_frame = vid->decoder->cur_frame;
 
-		LockMutex (GraphicsLock);
 		// We have the cliprect precalculated and don't need the rest
 		oldContext = SetContext (NULL);
 		TFB_DrawScreen_Image (vid->frame,
 				vid->dst_rect.corner.x, vid->dst_rect.corner.y, 0, 0,
 				NULL, DRAW_REPLACE_MODE, TFB_SCREEN_MAIN);
 		SetContext (oldContext);
-		UnlockMutex (GraphicsLock);
 		FlushGraphics (); // needed to prevent half-frame updates
 
 		if (vid->cur_frame == vid->loop_frame)
@@ -273,7 +269,7 @@ TFB_PlayVideo (VIDEO_REF vid, uint32 x,
 		}
 
 		TFB_SetSoundSampleCallbacks (*vid->hAudio, &vp_AudioCBs);
-		TFB_SetSoundSampleData (*vid->hAudio, (intptr_t)vid);
+		TFB_SetSoundSampleData (*vid->hAudio, vid);
 	}
 
 	// get the first frame
@@ -432,7 +428,7 @@ vp_SetTimer (TFB_VideoDecoder* decoder,
 static bool
 vp_AudioStart (TFB_SoundSample* sample)
 {
-	TFB_VideoClip* vid = (TFB_VideoClip*) TFB_GetSoundSampleData (sample);
+	TFB_VideoClip* vid = TFB_GetSoundSampleData (sample);
 	TFB_SoundDecoder *decoder;
 
 	assert (sizeof (intptr_t) >= sizeof (vid));
@@ -450,7 +446,7 @@ vp_AudioStart (TFB_SoundSample* sample)
 static void
 vp_AudioEnd (TFB_SoundSample* sample)
 {
-	TFB_VideoClip* vid = (TFB_VideoClip*) TFB_GetSoundSampleData (sample);
+	TFB_VideoClip* vid = TFB_GetSoundSampleData (sample);
 
 	assert (vid != NULL);
 
@@ -462,7 +458,7 @@ vp_AudioEnd (TFB_SoundSample* sample)
 static void
 vp_BufferTag (TFB_SoundSample* sample, TFB_SoundTag* tag)
 {
-	TFB_VideoClip* vid = (TFB_VideoClip*) TFB_GetSoundSampleData (sample);
+	TFB_VideoClip* vid = TFB_GetSoundSampleData (sample);
 	uint32 frame = (uint32) tag->data;
 
 	assert (sizeof (tag->data) >= sizeof (frame));
diff -ruNp src.orig/libs/vidlib.h src/libs/vidlib.h
--- src.orig/libs/vidlib.h	2017-11-21 19:39:34 -0600
+++ src/libs/vidlib.h	2017-11-21 19:39:51 -0600
@@ -23,6 +23,10 @@
 #include "libs/sndlib.h"
 #include "libs/reslib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef enum
 {
 	NO_FMV = 0,
@@ -57,4 +61,8 @@ extern LEGACY_VIDEO_REF PlayLegacyVideo
 extern void StopLegacyVideo (LEGACY_VIDEO_REF ref);
 extern BOOLEAN PlayingLegacyVideo (LEGACY_VIDEO_REF ref);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _VIDLIB_H */
diff -ruNp src.orig/options.c src/options.c
--- src.orig/options.c	2017-11-21 19:39:35 -0600
+++ src/options.c	2017-11-21 19:39:51 -0600
@@ -54,9 +54,13 @@ const char **optAddons;
 
 BOOLEAN opt3doMusic;
 BOOLEAN optRemixMusic;
+BOOLEAN optSpeech;
 BOOLEAN optSubtitles;
 BOOLEAN optStereoSFX;
 BOOLEAN optKeepAspectRatio;
+
+float optGamma;
+
 uio_DirHandle *contentDir;
 uio_DirHandle *configDir;
 uio_DirHandle *saveDir;
@@ -416,7 +420,7 @@ mountAddonDir (uio_Repository *repositor
 		count = 0;
 		for (i = 0; i < availableAddons->numNames; ++i)
 		{
-			static char mountname[128];
+			char mountname[128];
 			uio_DirHandle *addonDir;
 			const char *addon = availableAddons->names[i];
 			
@@ -426,8 +430,7 @@ mountAddonDir (uio_Repository *repositor
 			++count;
 			log_add (log_Info, "    %d. %s", count, addon);
 		
-			snprintf(mountname, 128, "addons/%s", addon);
-			mountname[127]=0;
+			snprintf (mountname, sizeof mountname, "addons/%s", addon);
 
 			addonDir = uio_openDirRelative (addonsDir, addon, 0);
 			if (addonDir == NULL)
@@ -528,6 +531,11 @@ loadAddon (const char *addon)
 	}
 
 	numLoaded = loadIndices (addonDir);
+	if (!numLoaded)
+	{
+		log_add (log_Error, "No RMP index files were loaded for addon '%s'",
+				addon);
+	}
 
 	uio_closeDir (addonDir);
 	uio_closeDir (addonsDir);
@@ -563,6 +571,14 @@ prepareShadowAddons (const char **addons
 		{
 			log_add (log_Debug, "Mounting shadow content of '%s' addon", addon);
 			mountDirZips (shadowDir, "/", uio_MOUNT_ABOVE, contentMountHandle);
+			// Mount non-zipped shadow content
+			if (uio_transplantDir ("/", shadowDir, uio_MOUNT_RDONLY |
+					uio_MOUNT_ABOVE, contentMountHandle) == NULL)
+			{
+				log_add (log_Warning, "Warning: Could not mount shadow content"
+						" of '%s': %s.", addon, strerror (errno));
+			}
+
 			uio_closeDir (shadowDir);
 		}
 		uio_closeDir (addonDir);
@@ -579,7 +595,46 @@ prepareAddons (const char **addons)
 		log_add (log_Info, "Loading addon '%s'", *addons);
 		if (!loadAddon (*addons))
 		{
+			// TODO: Should we do something like inform the user?
+			//   Why simply refuse to load other addons?
+			//   Maybe exit() to inform the user of the failure?
 			break;
 		}
 	}
 }
+
+void
+unprepareAllDirs (void)
+{
+	if (saveDir)
+	{
+		uio_closeDir (saveDir);
+		saveDir = 0;
+	}
+	if (meleeDir)
+	{
+		uio_closeDir (meleeDir);
+		meleeDir = 0;
+	}
+	if (contentDir)
+	{
+		uio_closeDir (contentDir);
+		contentDir = 0;
+	}
+	if (configDir)
+	{
+		uio_closeDir (configDir);
+		configDir = 0;
+	}
+}
+
+bool
+setGammaCorrection (float gamma)
+{
+	bool set = TFB_SetGamma (gamma);
+	if (set)
+		log_add (log_Info, "Gamma correction set to %.4f.", gamma);
+	else
+		log_add (log_Warning, "Unable to set gamma correction.");
+	return set;
+}
diff -ruNp src.orig/options.h src/options.h
--- src.orig/options.h	2017-11-21 19:39:35 -0600
+++ src/options.h	2017-11-21 19:39:51 -0600
@@ -26,6 +26,10 @@
 #include "libs/compiler.h"
 #include "libs/uio.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #define OPT_3DO 0x01
 #define OPT_PC  0x02
 #define OPT_ALL 0xFF
@@ -40,10 +44,14 @@ extern int optMeleeScale;
 
 extern BOOLEAN opt3doMusic;
 extern BOOLEAN optRemixMusic;
+extern BOOLEAN optSpeech;
 extern BOOLEAN optSubtitles;
 extern BOOLEAN optStereoSFX;
 extern BOOLEAN optKeepAspectRatio;
 
+#define GAMMA_SCALE  1000
+extern float optGamma;
+
 extern uio_DirHandle *contentDir;
 extern uio_DirHandle *configDir;
 extern uio_DirHandle *saveDir;
@@ -71,9 +79,16 @@ void prepareMeleeDir (void);
 void prepareSaveDir (void);
 void prepareAddons (const char **addons);
 void prepareShadowAddons (const char **addons);
+void unprepareAllDirs (void);
 
 BOOLEAN loadAddon (const char *addon);
 int loadIndices (uio_DirHandle *baseDir);
 
+bool setGammaCorrection (float gamma);
+
+#if defined(__cplusplus)
+}
+#endif
+
 #endif
 
diff -ruNp src.orig/port.h src/port.h
--- src.orig/port.h	2017-11-21 19:39:35 -0600
+++ src/port.h	2017-11-21 19:39:51 -0600
@@ -79,12 +79,24 @@
 
 
 #ifndef HAVE_STRUPR
+#if defined(__cplusplus)
+extern "C" {
+#endif
 char *strupr (char *str);
+#if defined(__cplusplus)
+}
+#endif
 #endif
 
 #if !defined (_MSC_VER) && !defined (HAVE_READDIR_R)
 #	include <dirent.h>
+#if defined(__cplusplus)
+extern "C" {
+#endif
 int readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result);
+#if defined(__cplusplus)
+}
+#endif
 #endif
 
 // Directories
@@ -161,10 +173,21 @@ typedef unsigned short mode_t;
 #ifdef _MSC_VER
 #	include <stdarg.h>
 // Defined in port.c
+#if defined(__cplusplus)
+extern "C" {
+#endif
 int snprintf(char *str, size_t size, const char *format, ...);
 int vsnprintf(char *str, size_t size, const char *format, va_list args);
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _MSC_VER */
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 // setenv()
 #ifndef HAVE_SETENV
 int setenv (const char *name, const char *value, int overwrite);
@@ -178,6 +201,10 @@ typedef unsigned short wchar_t;
 typedef unsigned int wint_t;
 #endif
 
+#if defined(__cplusplus)
+}
+#endif
+
 #if defined (_MSC_VER) || defined(__MINGW32__)
 #	define USE_WINSOCK
 #endif
diff -ruNp src.orig/regex/Makeinfo src/regex/Makeinfo
--- src.orig/regex/Makeinfo	2017-11-21 19:39:35 -0600
+++ src/regex/Makeinfo	2017-11-21 19:39:51 -0600
@@ -1,2 +1,2 @@
 uqm_CFILES="regex.c"
-
+uqm_HFILES="regex.h regex_internal.h"
diff -ruNp src.orig/types.h src/types.h
--- src.orig/types.h	2017-11-21 19:39:35 -0600
+++ src/types.h	2017-11-21 19:39:52 -0600
@@ -50,6 +50,10 @@
 #	endif  /* defined(PRIxPTR) */
 #endif
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #if defined(__arch64__) || defined(__alpha) || defined(__x86_64) \
 		|| defined(_M_IA64) || defined(_M_AMD64)
 	/* 64-bit platforms */
@@ -177,4 +181,8 @@ UQM_COMPILE_TIME_ASSERT(uint64, sizeof(u
 #define UINT16_MAX 0xffff /* 65535U */
 #define UINT32_MAX 0xffffffff /* 4294967295U */
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _TYPES_H */
diff -ruNp src.orig/uqm/Makeinfo src/uqm/Makeinfo
--- src.orig/uqm/Makeinfo	2017-11-21 19:39:38 -0600
+++ src/uqm/Makeinfo	2017-11-21 19:39:56 -0600
@@ -1,12 +1,24 @@
-uqm_SUBDIRS="comm planets ships supermelee"
+uqm_SUBDIRS="comm lua planets ships supermelee"
 uqm_CFILES="battle.c battlecontrols.c border.c build.c cleanup.c clock.c
 		cnctdlg.c collide.c comm.c commanim.c commglue.c confirm.c credits.c
 		cyborg.c demo.c displist.c dummy.c encount.c flash.c fmv.c galaxy.c
 		gameev.c gameinp.c gameopt.c gendef.c getchar.c globdata.c gravity.c
 		cons_res.c grpinfo.c hyper.c init.c intel.c intro.c ipdisp.c load.c
+		load_legacy.c
 		loadship.c master.c menu.c misc.c oscill.c outfit.c pickship.c
 		plandata.c process.c restart.c save.c settings.c setup.c setupmenu.c
 		ship.c shipstat.c shipyard.c sis.c sounds.c starbase.c starcon.c
 		starmap.c state.c status.c tactrans.c trans.c uqmdebug.c util.c
 		velocity.c weapon.c"
+uqm_HFILES="battlecontrols.h battle.h build.h clock.h cnctdlg.h coderes.h
+		collide.h colors.h commanim.h commglue.h comm.h cons_res.h controls.h
+		corecode.h credits.h demo.h displist.h dummy.h element.h encount.h
+		flash.h fmv.h gameev.h gameopt.h gamestr.h gendef.h globdata.h
+		grpinfo.h hyper.h ifontres.h igfxres.h ikey_con.h imusicre.h init.h
+		intel.h ipdisp.h isndres.h istrtab.h master.h menustat.h
+		nameref.h oscill.h pickship.h process.h races.h resinst.h respkg.h
+		restart.h save.h settings.h setup.h setupmenu.h shipcont.h ship.h
+		sis.h sounds.h starbase.h starcon.h state.h status.h tactrans.h
+		starmap.h
+		units.h uqmdebug.h util.h velocity.h weapon.h"
 
diff -ruNp src.orig/uqm/battle.c src/uqm/battle.c
--- src.orig/uqm/battle.c	2017-11-21 19:39:35 -0600
+++ src/uqm/battle.c	2017-11-21 19:39:52 -0600
@@ -40,6 +40,7 @@
 #include "setup.h"
 #include "settings.h"
 #include "sounds.h"
+#include "libs/async.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/log.h"
 #include "libs/mathlib.h"
@@ -235,12 +236,12 @@ BattleSong (BOOLEAN DoPlay)
 {
 	if (BattleRef == 0)
 	{
-		if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
-			BattleRef = LoadMusic (BATTLE_MUSIC);
-		else if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
+		if (inHyperSpace ())
 			BattleRef = LoadMusic (HYPERSPACE_MUSIC);
-		else
+		else if (inQuasiSpace ())
 			BattleRef = LoadMusic (QUASISPACE_MUSIC);
+		else
+			BattleRef = LoadMusic (BATTLE_MUSIC);
 	}
 
 	if (DoPlay)
@@ -301,7 +302,6 @@ DoBattle (BATTLE_STATE *bs)
 	}
 #endif
 
-	LockMutex (GraphicsLock);
 	if (bs->first_time)
 	{
 		r.corner.x = SIS_ORG_X;
@@ -324,7 +324,6 @@ DoBattle (BATTLE_STATE *bs)
 		ScreenTransition (3, &r);
 	}
 	UnbatchGraphics ();
-	UnlockMutex (GraphicsLock);
 	if ((!(GLOBAL (CurrentActivity) & IN_BATTLE)) ||
 			(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD)))
 	{
@@ -334,6 +333,7 @@ DoBattle (BATTLE_STATE *bs)
 	battle_speed = HIBYTE (nth_frame);
 	if (battle_speed == (BYTE)~0)
 	{	// maximum speed, nothing rendered at all
+		Async_process ();
 		TaskSwitch ();
 	}
 	else
@@ -397,7 +397,6 @@ Battle (BattleFrameCallback *callback)
 {
 	SIZE num_ships;
 
-	LockMutex (GraphicsLock);
 
 #if !(DEMO_MODE || CREATE_JOURNAL)
 	if (LOBYTE (GLOBAL (CurrentActivity)) != SUPER_MELEE) {
@@ -464,12 +463,9 @@ Battle (BattleFrameCallback *callback)
 #endif  /* NETPLAY */
 		bs.InputFunc = DoBattle;
 		bs.frame_cb = callback;
-		bs.first_time = (BOOLEAN)(LOBYTE (GLOBAL (CurrentActivity)) ==
-				IN_HYPERSPACE);
+		bs.first_time = inHQSpace ();
 
-		UnlockMutex (GraphicsLock);
 		DoInput (&bs, FALSE);
-		LockMutex (GraphicsLock);
 
 AbortBattle:
 		if (LOBYTE (GLOBAL (CurrentActivity)) == SUPER_MELEE)
@@ -479,12 +475,10 @@ AbortBattle:
 				// Do not return to the main menu when a game is aborted,
 				// (just to the supermelee menu).
 #ifdef NETPLAY
-				UnlockMutex (GraphicsLock);
 				waitResetConnections(NetState_inSetup);
 						// A connection may already be in inSetup (set from
 						// GetMeleeStarship). This is not a problem, although
 						// it will generate a warning in debug mode.
-				LockMutex (GraphicsLock);
 #endif
 
 				GLOBAL (CurrentActivity) &= ~CHECK_ABORT;
@@ -512,7 +506,6 @@ AbortBattle:
 	UninitShips ();
 	FreeBattleSong ();
 
-	UnlockMutex (GraphicsLock);
 	
 	return (BOOLEAN) (num_ships < 0);
 }
diff -ruNp src.orig/uqm/battle.h src/uqm/battle.h
--- src.orig/uqm/battle.h	2017-11-21 19:39:35 -0600
+++ src/uqm/battle.h	2017-11-21 19:39:52 -0600
@@ -26,9 +26,12 @@ typedef DWORD BattleFrameCounter;
 #include "init.h"
 		// For NUM_SIDES
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 // The callback function is called on every battle frame
-// with GraphicsLock held, just before the display queue
-// is drawn
+// just before the display queue is drawn
 typedef void (BattleFrameCallback) (void);
 
 typedef struct battlestate_struct {
@@ -56,4 +59,8 @@ BOOLEAN Battle (BattleFrameCallback *);
 extern void BattleSong (BOOLEAN DoPlay);
 extern void FreeBattleSong (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _BATTLE_H */
diff -ruNp src.orig/uqm/battlecontrols.h src/uqm/battlecontrols.h
--- src.orig/uqm/battlecontrols.h	2017-11-21 19:39:35 -0600
+++ src/uqm/battlecontrols.h	2017-11-21 19:39:52 -0600
@@ -30,6 +30,10 @@ typedef struct NetworkInputContext Netwo
 #include "races.h"
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef BATTLE_INPUT_STATE (*BattleFrameInputFunction) (
 		InputContext *context, STARSHIP *StarShipPtr);
 typedef BOOLEAN (*SelectShipFunction) (InputContext *context,
@@ -88,6 +92,10 @@ void InputContext_delete (InputContext *
 		// Call InputContext->handlers->freeContext() to release an
 		// InputContext.
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _BATTLECONTROLS_H */
 
 
diff -ruNp src.orig/uqm/build.c src/uqm/build.c
--- src.orig/uqm/build.c	2017-11-21 19:39:35 -0600
+++ src/uqm/build.c	2017-11-21 19:39:52 -0600
@@ -25,6 +25,8 @@
 #include "libs/compiler.h"
 #include "libs/mathlib.h"
 
+#include <stdlib.h>
+
 
 // Allocate a new STARSHIP or SHIP_FRAGMENT and put it in the queue
 HLINK
@@ -68,233 +70,475 @@ GetStarShipFromIndex (QUEUE *pShipQ, COU
 	return (hStarShip);
 }
 
+HSHIPFRAG
+GetEscortByStarShipIndex (COUNT index)
+{
+	HSHIPFRAG hStarShip;
+	HSHIPFRAG hNextShip;
+	SHIP_FRAGMENT *StarShipPtr;
+
+	for (hStarShip = GetHeadLink (&GLOBAL (built_ship_q));
+			hStarShip; hStarShip = hNextShip)
+	{
+		StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+
+		if (StarShipPtr->index == index)
+		{
+			UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+			break;
+		}
+
+		hNextShip = _GetSuccLink (StarShipPtr);
+		UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+	}
+
+	return hStarShip;
+}
+
+SPECIES_ID
+ShipIdStrToIndex (const char *shipIdStr)
+{
+	HMASTERSHIP hStarShip;
+	HMASTERSHIP hNextShip;
+	SPECIES_ID result = NO_ID;
+
+	for (hStarShip = GetHeadLink (&master_q);
+			hStarShip != 0; hStarShip = hNextShip)
+	{
+		MASTER_SHIP_INFO *MasterPtr;
+
+		MasterPtr = LockMasterShip (&master_q, hStarShip);
+		hNextShip = _GetSuccLink (MasterPtr);
+
+		if (strcmp (shipIdStr, MasterPtr->ShipInfo.idStr) == 0)
+		{
+			result = MasterPtr->SpeciesID;
+			UnlockMasterShip (&master_q, hStarShip);
+			break;
+		}
+
+		UnlockMasterShip (&master_q, hStarShip);
+	}
+
+	return result;
+}
+
+typedef struct {
+	const char *idStr;
+	RACE_ID id;
+} RaceIdMap;
+
+// We would eventually want to unhardcode this.
+static RaceIdMap raceIdMap[] = {
+	// Sorted on the name, for the binary search.
+	{ /* .idStr = */ "arilou",      /* .id = */ ARILOU_SHIP },
+	{ /* .idStr = */ "chmmr",       /* .id = */ CHMMR_SHIP },
+	{ /* .idStr = */ "druuge",      /* .id = */ DRUUGE_SHIP },
+	{ /* .idStr = */ "human",       /* .id = */ HUMAN_SHIP },
+	{ /* .idStr = */ "ilwrath",     /* .id = */ ILWRATH_SHIP },
+	{ /* .idStr = */ "kohrah",      /* .id = */ BLACK_URQUAN_SHIP },
+	{ /* .idStr = */ "melnorme",    /* .id = */ MELNORME_SHIP },
+	{ /* .idStr = */ "mycon",       /* .id = */ MYCON_SHIP },
+	{ /* .idStr = */ "orz",         /* .id = */ ORZ_SHIP },
+	{ /* .idStr = */ "pkunk",       /* .id = */ PKUNK_SHIP },
+	{ /* .idStr = */ "samatra",     /* .id = */ SAMATRA_SHIP },
+	{ /* .idStr = */ "shofixti",    /* .id = */ SHOFIXTI_SHIP },
+	{ /* .idStr = */ "slylandro",   /* .id = */ SLYLANDRO_SHIP },
+	{ /* .idStr = */ "spathi",      /* .id = */ SPATHI_SHIP },
+	{ /* .idStr = */ "supox",       /* .id = */ SUPOX_SHIP },
+	{ /* .idStr = */ "syreen",      /* .id = */ SYREEN_SHIP },
+	{ /* .idStr = */ "thraddash",   /* .id = */ THRADDASH_SHIP },
+	{ /* .idStr = */ "umgah",       /* .id = */ UMGAH_SHIP },
+	{ /* .idStr = */ "urquandrone", /* .id = */ URQUAN_DRONE_SHIP },
+	{ /* .idStr = */ "urquan",      /* .id = */ URQUAN_SHIP },
+	{ /* .idStr = */ "utwig",       /* .id = */ UTWIG_SHIP },
+	{ /* .idStr = */ "vux",         /* .id = */ VUX_SHIP },
+	{ /* .idStr = */ "yehat",       /* .id = */ YEHAT_SHIP },
+	{ /* .idStr = */ "yehatrebel",  /* .id = */ YEHAT_REBEL_SHIP },
+	{ /* .idStr = */ "zoqfotpik",   /* .id = */ ZOQFOTPIK_SHIP },
+			// Same as URQUAN_DRONE_SHIP
+};
+
+static int
+RaceIdCompare (const void *id1, const void *id2)
+{
+	return strcmp (((RaceIdMap *) id1)->idStr, ((RaceIdMap *) id2)->idStr);
+}
+
+RACE_ID
+RaceIdStrToIndex (const char *raceIdStr)
+{
+	RaceIdMap key = { /* .idStr = */ raceIdStr, /* .id = */ -1 };
+	RaceIdMap *found = bsearch (&key, raceIdMap,
+			sizeof raceIdMap / sizeof raceIdMap[0],
+			sizeof raceIdMap[0], RaceIdCompare);
+
+	if (found == NULL)
+		return (RACE_ID) -1;
+
+	return found->id;
+}
+
 /*
- * What this function does depends on the value of the 'state' argument:
- * SPHERE_TRACKING:
- * 	The sphere of influence for the race for 'which_ship' will be shown
- * 	on the starmap in the future.
- * 	The value returned is 'which_ship', unless the type of ship is only
- * 	available in SuperMelee, in which case 0 is returned.
- * SPHERE_KNOWN:
- * 	The size of the fleet of the race of 'which_ship' when the starmap was
- * 	last checked is returned.
- * ESCORT_WORTH:
- * 	The total value of all the ships escorting the SIS is returned.
- * 	'which_ship' is ignored.
- * ESCORTING_FLAGSHIP:
- * 	Test if a ship of type 'which_ship' is among the escorts of the SIS
- * 	0 is returned if false, 1 if true.
- * FEASIBILITY_STUDY:
- * 	Test if the SIS can have an escort of type 'which_ship'.
- * 	0 is returned if 'which_ship' is not available.
- * 	Otherwise, the number of ships that can be added is returned.
- * CHECK_ALLIANCE:
- * 	Test the alliance status of the race of 'which_ship'.
- *      Either GOOD_GUY (allied) or BAD_GUY (not allied) is returned.
- * SET_ALLIED (0):
- * 	Ally with the race of 'which_ship'. This makes their ship available
- *  for building in the shipyard.
- * SET_NOT_ALLIED:
- * 	End an alliance with the race of 'which_ship'. This ends the possibility
- * 	of building their ships in the shipyard.
- * REMOVE_BUILT: 
- *  Make the already built escorts of the race of 'which_ship' disappear.
- *   (as for the Orz when the alliance with them ends)
- * any other positive number:
- * 	Give the player this many ships of type 'which_ship'.
+ * Give the player 'count' ships of the specified race,
+ * limited by the number of free slots.
+ * Returns the number of ships added.
  */
 COUNT
-ActivateStarShip (COUNT which_ship, SIZE state)
+AddEscortShips (RACE_ID race, SIZE count)
 {
 	HFLEETINFO hFleet;
+	BYTE which_window;
+	COUNT i;
 
-	hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q), which_ship);
+	hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q), race);
 	if (!hFleet)
 		return 0;
 
-	switch (state)
+	assert (count > 0);
+
+	which_window = 0;
+	for (i = 0; i < (COUNT) count; i++)
 	{
-		case SPHERE_TRACKING:
-		case SPHERE_KNOWN:
-		{
-			FLEET_INFO *FleetPtr;
+		HSHIPFRAG hStarShip;
+		HSHIPFRAG hOldShip;
+		SHIP_FRAGMENT *StarShipPtr;
 
-			FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hFleet);
-			if (state == SPHERE_KNOWN)
-				which_ship = FleetPtr->known_strength;
-			else if (FleetPtr->actual_strength == 0)
-			{
-				if (FleetPtr->allied_state == DEAD_GUY)
-					which_ship = 0;
-			}
-			else if (FleetPtr->known_strength == 0
-					&& FleetPtr->actual_strength != INFINITE_RADIUS)
-			{
-				FleetPtr->known_strength = 1;
-				FleetPtr->known_loc = FleetPtr->loc;
-			}
-			UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
-			return (which_ship);
-		}
-		case ESCORT_WORTH:
-		{
-			COUNT ShipCost[] =
-			{
-				RACE_SHIP_COST
-			};
-			COUNT total = 0;
-			HSHIPFRAG hStarShip, hNextShip;
-
-			for (hStarShip = GetHeadLink (&GLOBAL (built_ship_q));
-					hStarShip; hStarShip = hNextShip)
-			{
-				SHIP_FRAGMENT *StarShipPtr;
-
-				StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
-				hNextShip = _GetSuccLink (StarShipPtr);
-				total += ShipCost[StarShipPtr->race_id];
-				UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
-			}
-			return total;
-		}
-		case ESCORTING_FLAGSHIP:
-		{
-			HSHIPFRAG hStarShip, hNextShip;
+		hStarShip = CloneShipFragment (race, &GLOBAL (built_ship_q), 0);
+		if (!hStarShip)
+			break;
 
-			for (hStarShip = GetHeadLink (&GLOBAL (built_ship_q));
-					hStarShip; hStarShip = hNextShip)
-			{
-				BYTE ship_type;
-				SHIP_FRAGMENT *StarShipPtr;
-
-				StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
-				hNextShip = _GetSuccLink (StarShipPtr);
-				ship_type = StarShipPtr->race_id;
-				UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
-
-				if (ship_type == which_ship)
-					return 1;
-			}
-			return 0;
-		}
-		case FEASIBILITY_STUDY:
+		RemoveQueue (&GLOBAL (built_ship_q), hStarShip);
+
+		/* Find first available escort window */
+		while ((hOldShip = GetStarShipFromIndex (
+				&GLOBAL (built_ship_q), which_window++)))
 		{
-			return (MAX_BUILT_SHIPS - CountLinks (&GLOBAL (built_ship_q)));
+			BYTE win_loc;
+
+			StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hOldShip);
+			win_loc = StarShipPtr->index;
+			UnlockShipFrag (&GLOBAL (built_ship_q), hOldShip);
+			if (which_window <= win_loc)
+				break;
 		}
-		case CHECK_ALLIANCE:
+
+		StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+		StarShipPtr->index = which_window - 1;
+		UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+
+		InsertQueue (&GLOBAL (built_ship_q), hStarShip, hOldShip);
+	}
+
+	DeltaSISGauges (UNDEFINED_DELTA, UNDEFINED_DELTA, UNDEFINED_DELTA);
+	return i;
+}
+
+/*
+ * Returns the total value of all the ships escorting the SIS.
+ */
+COUNT
+CalculateEscortsWorth (void)
+{
+	COUNT ShipCost[] =
+	{
+		RACE_SHIP_COST
+	};
+	COUNT total = 0;
+	HSHIPFRAG hStarShip, hNextShip;
+
+	for (hStarShip = GetHeadLink (&GLOBAL (built_ship_q));
+			hStarShip; hStarShip = hNextShip)
+	{
+		SHIP_FRAGMENT *StarShipPtr;
+
+		StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+		hNextShip = _GetSuccLink (StarShipPtr);
+		total += ShipCost[StarShipPtr->race_id];
+		UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+	}
+	return total;
+}
+
+#if 0
+/*
+ * Returns the size of the fleet of the specified race when the starmap was
+ * last checked. If the race has no SoI, 0 is returned.
+ */
+COUNT
+GetRaceKnownSize (RACE_ID race)
+{
+	HFLEETINFO hFleet;
+	FLEET_INFO *FleetPtr;
+	COUNT result;
+
+	hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q), race);
+	if (!hFleet)
+		return 0;
+
+	FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+
+	result = FleetPtr->known_strength;
+
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+	return result;
+}
+#endif
+
+/*
+ * Start or end an alliance with the specified race.
+ * Being in an alliance with a race makes their ships available for building
+ * in the shipyard.
+ * flag == TRUE: start an alliance
+ * flag == TRUE: end an alliance
+ */
+BOOLEAN
+SetRaceAllied (RACE_ID race, BOOLEAN flag) {
+	HFLEETINFO hFleet;
+	FLEET_INFO *FleetPtr;
+
+	hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q), race);
+	if (!hFleet)
+		return FALSE;
+
+	FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+
+	if (FleetPtr->allied_state == DEAD_GUY)
+	{
+		/* Strange request, silently ignore it */
+	}
+	else
+	{
+		FleetPtr->allied_state = (flag ? GOOD_GUY : BAD_GUY);
+	}
+
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+	return TRUE;
+}
+
+/*
+ * 	Make the sphere of influence for the specified race shown on the starmap
+ * 	in the future.
+ * 	Does nothing for races without a SoI, or for races which have an
+ * 	infinite SoI.
+ * 	The value returned is 'race', unless the type of ship is only available
+ * 	in SuperMelee, in which case 0 is returned.
+ */
+COUNT
+StartSphereTracking (RACE_ID race)
+{
+	HFLEETINFO hFleet;
+	FLEET_INFO *FleetPtr;
+
+	hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q), race);
+	if (!hFleet)
+		return 0;
+
+	FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+
+	if (FleetPtr->actual_strength == 0)
+	{
+		// Race has no Sphere of Influence.
+		if (FleetPtr->allied_state == DEAD_GUY)
 		{
-			UWORD flags;
-			FLEET_INFO *FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q),
-					hFleet);
-			flags = FleetPtr->allied_state;
+			// Race is extinct.
 			UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
-			return flags;
+			return 0;
 		}
-		case SET_ALLIED:
-		case SET_NOT_ALLIED:
-		{
-			FLEET_INFO *FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q),
-					hFleet);
+	}
+	else if (FleetPtr->known_strength == 0
+			&& FleetPtr->actual_strength != INFINITE_RADIUS)
+	{
+		FleetPtr->known_strength = 1;
+		FleetPtr->known_loc = FleetPtr->loc;
+	}
 
-			if (FleetPtr->allied_state == DEAD_GUY)
-			{	/* Strange request, silently ignore it */
-				UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
-				break;
-			}
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+	return race;
+}
 
-			if (state == SET_ALLIED)
-				FleetPtr->allied_state = GOOD_GUY;
-			else
-				FleetPtr->allied_state = BAD_GUY;
-			
-			UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
-			break;
-		}
-		case REMOVE_BUILT:
-		{
-			HSHIPFRAG hStarShip, hNextShip;
-			BOOLEAN ShipRemoved = FALSE;
+/*
+ * 	Check whether we are tracking the SoI of a race.
+ * 	If a race has no SoI, this function will always return false.
+ */
+BOOLEAN
+CheckSphereTracking (RACE_ID race)
+{
+	HFLEETINFO hFleet;
+	FLEET_INFO *FleetPtr;
+	COUNT result;
 
-			for (hStarShip = GetHeadLink (&GLOBAL (built_ship_q));
-					hStarShip; hStarShip = hNextShip)
-			{
-				BOOLEAN RemoveShip;
-				SHIP_FRAGMENT *StarShipPtr;
-
-				StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
-				hNextShip = _GetSuccLink (StarShipPtr);
-				RemoveShip = (StarShipPtr->race_id == which_ship);
-				UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
-
-				if (RemoveShip)
-				{
-					ShipRemoved = TRUE;
-
-					RemoveQueue (&GLOBAL (built_ship_q), hStarShip);
-					FreeShipFrag (&GLOBAL (built_ship_q), hStarShip);
-				}
-			}
-			
-			if (ShipRemoved)
-			{
-				LockMutex (GraphicsLock);
-				DeltaSISGauges (UNDEFINED_DELTA, UNDEFINED_DELTA,
-						UNDEFINED_DELTA);
-				UnlockMutex (GraphicsLock);
-			}
-			break;
-		}
-		default:
-		{
-			BYTE which_window;
-			COUNT i;
+	hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q), race);
+	if (!hFleet)
+		return FALSE;
+
+	FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+
+	if (FleetPtr->actual_strength == 0) {
+		// Race has no Sphere of Influence.
+		// Maybe it never had one, or maybe the race is extinct.
+		result = FALSE;
+	}
+	else
+	{
+		result = (FleetPtr->known_strength > 0);
+	}
+
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+	return result;
+}
 
-			assert (state > 0);
-			/* Add ships to the escorts */
-			which_window = 0;
-			for (i = 0; i < (COUNT)state; i++)
-			{
-				HSHIPFRAG hStarShip;
-				HSHIPFRAG hOldShip;
-				SHIP_FRAGMENT *StarShipPtr;
-
-				hStarShip = CloneShipFragment (which_ship,
-						&GLOBAL (built_ship_q), 0);
-				if (!hStarShip)
-					break;
-
-				RemoveQueue (&GLOBAL (built_ship_q), hStarShip);
-
-				/* Find first available escort window */
-				while ((hOldShip = GetStarShipFromIndex (
-						&GLOBAL (built_ship_q), which_window++)))
-				{
-					BYTE win_loc;
-
-					StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q),
-							hOldShip);
-					win_loc = StarShipPtr->index;
-					UnlockShipFrag (&GLOBAL (built_ship_q), hOldShip);
-					if (which_window <= win_loc)
-						break;
-				}
-
-				StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
-				StarShipPtr->index = which_window - 1;
-				UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
-
-				InsertQueue (&GLOBAL (built_ship_q), hStarShip, hOldShip);
-			}
-
-			LockMutex (GraphicsLock);
-			DeltaSISGauges (UNDEFINED_DELTA,
-					UNDEFINED_DELTA, UNDEFINED_DELTA);
-			UnlockMutex (GraphicsLock);
-			return i;
+BOOLEAN
+KillRace (RACE_ID race)
+{
+	HFLEETINFO hFleet;
+	FLEET_INFO *FleetPtr;
+
+	hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q), race);
+	if (!hFleet)
+		return FALSE;
+
+	FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+
+	FleetPtr->allied_state = DEAD_GUY;
+	FleetPtr->actual_strength = 0;
+
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+	return TRUE;
+}
+
+/*
+ * Returns the number of ships of the specified race among the
+ * escort ships.
+ */
+COUNT
+CountEscortShips (RACE_ID race)
+{
+	HFLEETINFO hFleet;
+	HSHIPFRAG hStarShip, hNextShip;
+	COUNT result = 0;
+
+	hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q), race);
+	if (!hFleet)
+		return 0;
+
+	for (hStarShip = GetHeadLink (&GLOBAL (built_ship_q)); hStarShip;
+			hStarShip = hNextShip)
+	{
+		BYTE ship_type;
+		SHIP_FRAGMENT *StarShipPtr;
+
+		StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+		hNextShip = _GetSuccLink (StarShipPtr);
+		ship_type = StarShipPtr->race_id;
+		UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+
+		if (ship_type == race)
+			result++;
+	}
+	return result;
+}
+
+/*
+ * Returns true if and only if a ship of the specified race is among the
+ * escort ships.
+ */
+BOOLEAN
+HaveEscortShip (RACE_ID race)
+{
+	return (CountEscortShips (race) > 0);
+}
+
+/*
+ * Test if the SIS can have an escort of the specified race.
+ * Returns 0 if 'race' is not available.
+ * Otherwise, returns the number of ships that can be added.
+ */
+COUNT
+EscortFeasibilityStudy (RACE_ID race)
+{
+	HFLEETINFO hFleet;
+
+	hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q), race);
+	if (!hFleet)
+		return 0;
+
+	return (MAX_BUILT_SHIPS - CountLinks (&GLOBAL (built_ship_q)));
+}
+
+/*
+ * Test the alliance status of the specified race.
+ * Either DEAD_GUY (extinct), GOOD_GUY (allied), or BAD_GUY (not allied) is
+ * returned.
+ */
+COUNT
+CheckAlliance (RACE_ID race)
+{
+	HFLEETINFO hFleet;
+	UWORD flags;
+	FLEET_INFO *FleetPtr;
+
+	hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q), race);
+	if (!hFleet)
+		return 0;
+
+	FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+	flags = FleetPtr->allied_state;
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+
+	return flags;
+}
+
+/*
+ * Remove a number of escort ships of the specified race (if present).
+ * Returns the number of escort ships removed.
+ */
+COUNT
+RemoveSomeEscortShips (RACE_ID race, COUNT count)
+{
+	HSHIPFRAG hStarShip;
+	HSHIPFRAG hNextShip;
+
+	if (count == 0)
+		return 0;
+
+	for (hStarShip = GetHeadLink (&GLOBAL (built_ship_q)); hStarShip;
+			hStarShip = hNextShip)
+	{
+		BOOLEAN RemoveShip;
+		SHIP_FRAGMENT *StarShipPtr;
+
+		StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+		hNextShip = _GetSuccLink (StarShipPtr);
+		RemoveShip = (StarShipPtr->race_id == race);
+		UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+
+		if (RemoveShip)
+		{
+			RemoveQueue (&GLOBAL (built_ship_q), hStarShip);
+			FreeShipFrag (&GLOBAL (built_ship_q), hStarShip);
+			count--;
+			if (count == 0)
+				break;
 		}
 	}
+	
+	if (count > 0)
+	{
+		// Update the display.
+		DeltaSISGauges (UNDEFINED_DELTA, UNDEFINED_DELTA, UNDEFINED_DELTA);
+	}
 
-	return 1;
+	return count;
+}
+
+/*
+ * Remove all escort ships of the specified race.
+ */
+COUNT
+RemoveEscortShips (RACE_ID race)
+{
+	return RemoveSomeEscortShips (race, (COUNT) -1);
 }
 
 COUNT
@@ -356,7 +600,7 @@ NameCaptain (QUEUE *pQueue, SPECIES_ID S
 // crew_level can be set to INFINITE_FLEET for a ship which is to
 // represent an infinite number of ships.
 HSHIPFRAG
-CloneShipFragment (COUNT shipIndex, QUEUE *pDstQueue, COUNT crew_level)
+CloneShipFragment (RACE_ID shipIndex, QUEUE *pDstQueue, COUNT crew_level)
 {
 	HFLEETINFO hFleet;
 	HSHIPFRAG hBuiltShip;
@@ -404,7 +648,7 @@ CloneShipFragment (COUNT shipIndex, QUEU
 /* Set the crew and captain's name on the first fully-crewed escort
  * ship of race 'which_ship' */
 int
-SetEscortCrewComplement (COUNT which_ship, COUNT crew_level, BYTE captain)
+SetEscortCrewComplement (RACE_ID which_ship, COUNT crew_level, BYTE captain)
 {
 	HFLEETINFO hFleet;
 	FLEET_INFO *TemplatePtr;
@@ -440,3 +684,4 @@ SetEscortCrewComplement (COUNT which_shi
 	UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
 	return Index;
 }
+
diff -ruNp src.orig/uqm/build.h src/uqm/build.h
--- src.orig/uqm/build.h	2017-11-21 19:39:35 -0600
+++ src/uqm/build.h	2017-11-21 19:39:52 -0600
@@ -23,6 +23,10 @@
 #include "displist.h"
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #define NAME_OFFSET 5
 #define NUM_CAPTAINS_NAMES 16
 
@@ -31,34 +35,39 @@
 								+ NAME_OFFSET)
 
 extern HLINK Build (QUEUE *pQueue, SPECIES_ID SpeciesID);
-extern HSHIPFRAG CloneShipFragment (COUNT shipIndex, QUEUE *pDstQueue,
+extern HSHIPFRAG CloneShipFragment (RACE_ID shipIndex, QUEUE *pDstQueue,
 		COUNT crew_level);
 extern HLINK GetStarShipFromIndex (QUEUE *pShipQ, COUNT Index);
+extern HSHIPFRAG GetEscortByStarShipIndex (COUNT index);
 extern BYTE NameCaptain (QUEUE *pQueue, SPECIES_ID SpeciesID);
 
-/* Possible values for the 'state' argument of
- * COUNT ActivateStarShip (COUNT which_ship, SIZE state)
- * See that function for more information.
- */
-#define SET_ALLIED          0
-#define SET_NOT_ALLIED     -1
-#define CHECK_ALLIANCE     -2
-#define REMOVE_BUILT       -3
-#define ESCORT_WORTH       -4
-#define SPHERE_KNOWN       -5
-#define SPHERE_TRACKING    -6
-#define ESCORTING_FLAGSHIP -7
-#define FEASIBILITY_STUDY  -8
-		/* Check for how many escort ships there's still space */
-
-extern COUNT ActivateStarShip (COUNT which_ship, SIZE state);
 extern COUNT GetIndexFromStarShip (QUEUE *pShipQ, HLINK hStarShip);
-extern int SetEscortCrewComplement (COUNT which_ship, COUNT crew_level,
+extern int SetEscortCrewComplement (RACE_ID which_ship, COUNT crew_level,
 		BYTE captain);
 
+extern SPECIES_ID ShipIdStrToIndex (const char *shipIdStr);
+extern RACE_ID RaceIdStrToIndex (const char *raceIdStr);
+extern COUNT AddEscortShips (RACE_ID race, SIZE count);
+extern COUNT CalculateEscortsWorth (void);
+//extern COUNT GetRaceKnownSize (RACE_ID race);
+extern BOOLEAN SetRaceAllied (RACE_ID race, BOOLEAN flag);
+extern COUNT StartSphereTracking (RACE_ID race);
+extern BOOLEAN CheckSphereTracking (RACE_ID race);
+extern BOOLEAN KillRace (RACE_ID race);
+extern COUNT CountEscortShips (RACE_ID race);
+extern BOOLEAN HaveEscortShip (RACE_ID race);
+extern COUNT EscortFeasibilityStudy (RACE_ID race);
+extern COUNT CheckAlliance (RACE_ID race);
+extern COUNT RemoveSomeEscortShips (RACE_ID race, COUNT count);
+extern COUNT RemoveEscortShips (RACE_ID race);
+
 extern RACE_DESC *load_ship (SPECIES_ID SpeciesID, BOOLEAN LoadBattleData);
 extern void free_ship (RACE_DESC *RaceDescPtr, BOOLEAN FreeIconData,
 		BOOLEAN FreeBattleData);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _BUILD_H */
 
diff -ruNp src.orig/uqm/cleanup.c src/uqm/cleanup.c
--- src.orig/uqm/cleanup.c	2017-11-21 19:39:35 -0600
+++ src/uqm/cleanup.c	2017-11-21 19:39:52 -0600
@@ -25,14 +25,11 @@
 #include "planets/lander.h"
 #include "starcon.h"
 #include "setup.h"
+#include "planets/solarsys.h"
 #include "sounds.h"
 #include "libs/sndlib.h"
 #include "libs/vidlib.h"
 
-// XXX: we do not current have a header for this prototype to live in
-//  should be something like solarsys.h
-extern void FreeIPData (void);
-
 
 void
 FreeKernel (void)
@@ -42,7 +39,9 @@ FreeKernel (void)
 	UninitResourceSystem ();
 
 	DestroyDrawable (ReleaseDrawable (Screen));
+	Screen = 0;
 	DestroyContext (ScreenContext);
+	ScreenContext = 0;
 
 	UninitVideoPlayer ();
 	UninitSound ();
diff -ruNp src.orig/uqm/clock.c src/uqm/clock.c
--- src.orig/uqm/clock.c	2017-11-21 19:39:35 -0600
+++ src/uqm/clock.c	2017-11-21 19:39:52 -0600
@@ -157,22 +157,16 @@ UnlockGameClock (void)
 BOOLEAN
 GameClockRunning (void)
 {
-	SIZE prev_tick, cur_tick;
+	SIZE day_in_ticks;
 
 	if (!clock_mutex)
 		return FALSE;
 
 	LockMutex (clock_mutex);
-	prev_tick = GLOBAL (GameClock.tick_count);
+	day_in_ticks = GLOBAL (GameClock.day_in_ticks);
 	UnlockMutex (clock_mutex);
 	
-	SleepThread (ONE_SECOND / 5);
-	
-	LockMutex (clock_mutex);
-	cur_tick = GLOBAL (GameClock.tick_count);
-	UnlockMutex (clock_mutex);
-
-	return cur_tick != prev_tick;
+	return day_in_ticks != 0;
 }
 
 void
@@ -282,7 +276,6 @@ AddEvent (EVENT_TYPE type, COUNT month_i
 	return (0);
 }
 
-// This function must be called with GraphicsLock held.
 void
 GameClockTick (void)
 {
@@ -305,7 +298,6 @@ GameClockTick (void)
 	UnlockMutex (clock_mutex);
 }
 
-// This function must be called with GraphicsLock held.
 void
 MoveGameClockDays (COUNT days)
 {
diff -ruNp src.orig/uqm/clock.h src/uqm/clock.h
--- src.orig/uqm/clock.h	2017-11-21 19:39:35 -0600
+++ src/uqm/clock.h	2017-11-21 19:39:52 -0600
@@ -22,12 +22,12 @@
 #include "libs/tasklib.h"
 #include "displist.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
-#define START_YEAR 2155
 
-#define UPDATE_DAY (1 << 0)
-#define UPDATE_MONTH (1 << 1)
-#define UPDATE_YEAR (1 << 2)
+#define START_YEAR 2155
 
 typedef struct
 {
@@ -100,5 +100,9 @@ extern void UnlockGameClock (void);
 // but not much else
 extern BOOLEAN GameClockRunning (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _CLOCK_H */
 
diff -ruNp src.orig/uqm/cnctdlg.c src/uqm/cnctdlg.c
--- src.orig/uqm/cnctdlg.c	2017-11-21 19:39:35 -0600
+++ src/uqm/cnctdlg.c	2017-11-21 19:39:52 -0600
@@ -531,14 +531,12 @@ DrawConnectDialog (void)
 	r.corner.x = (SCREEN_WIDTH - r.extent.width) >> 1;
 	r.corner.y = (SCREEN_HEIGHT - r.extent.height) >> 1;
 
-	LockMutex (GraphicsLock);
 
 	DrawShadowedBox (&r, SHADOWBOX_BACKGROUND_COLOR,
 			SHADOWBOX_DARK_COLOR, SHADOWBOX_MEDIUM_COLOR);
 
 	menu.draw ((WIDGET *)&menu, r.corner.x + 10, r.corner.y + 10);
 
-	UnlockMutex (GraphicsLock);
 }
 
 static BOOLEAN
diff -ruNp src.orig/uqm/cnctdlg.h src/uqm/cnctdlg.h
--- src.orig/uqm/cnctdlg.h	2017-11-21 19:39:35 -0600
+++ src/uqm/cnctdlg.h	2017-11-21 19:39:52 -0600
@@ -16,16 +16,23 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-#ifdef NETPLAY
-
 #ifndef _CNCTDLG_H
 #define _CNCTDLG_H
 
+#ifdef NETPLAY
+
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 BOOLEAN MeleeConnectDialog (int side);
 
-#endif /* _CNCTDLG_H */
+#if defined(__cplusplus)
+}
+#endif
 
 #endif /* NETPLAY */
 
+#endif /* _CNCTDLG_H */
diff -ruNp src.orig/uqm/coderes.h src/uqm/coderes.h
--- src.orig/uqm/coderes.h	2017-11-21 19:39:35 -0600
+++ src/uqm/coderes.h	2017-11-21 19:39:52 -0600
@@ -21,6 +21,10 @@
 
 #include "libs/reslib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern BOOLEAN InstallCodeResType (void);
 extern void *LoadCodeResInstance (RESOURCE res);
 extern void *CaptureCodeRes (void *hCode, void *pData, void **ppLocData);
@@ -32,5 +36,9 @@ typedef struct
 	UWORD size;
 } CODE_REF;
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _CODERES_H */
 
diff -ruNp src.orig/uqm/collide.h src/uqm/collide.h
--- src.orig/uqm/collide.h	2017-11-21 19:39:35 -0600
+++ src/uqm/collide.h	2017-11-21 19:39:52 -0600
@@ -21,6 +21,10 @@
 
 #include "element.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #define COLLISION_TURN_WAIT 1
 #define COLLISION_THRUST_WAIT 3
 
@@ -59,5 +63,9 @@
 
 extern void collide (ELEMENT *ElementPtr0, ELEMENT *ElementPtr1);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _COLLIDE_H */
 
diff -ruNp src.orig/uqm/comm/Makeinfo src/uqm/comm/Makeinfo
--- src.orig/uqm/comm/Makeinfo	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/Makeinfo	2017-11-21 19:39:53 -0600
@@ -1,3 +1,4 @@
 uqm_SUBDIRS="arilou blackur chmmr comandr druuge ilwrath melnorm mycon
 		orz pkunk rebel shofixt slyhome slyland spahome spathi starbas supox
 		syreen talkpet thradd umgah urquan utwig vux yehat zoqfot"
+uqm_HFILES="commall.h"
diff -ruNp src.orig/uqm/comm/arilou/Makeinfo src/uqm/comm/arilou/Makeinfo
--- src.orig/uqm/comm/arilou/Makeinfo	2017-11-21 19:39:35 -0600
+++ src/uqm/comm/arilou/Makeinfo	2017-11-21 19:39:52 -0600
@@ -1 +1,2 @@
 uqm_CFILES="arilouc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.orig/uqm/comm/arilou/arilouc.c src/uqm/comm/arilou/arilouc.c
--- src.orig/uqm/comm/arilou/arilouc.c	2017-11-21 19:39:35 -0600
+++ src/uqm/comm/arilou/arilouc.c	2017-11-21 19:39:52 -0600
@@ -230,7 +230,7 @@ static LOCDATA arilou_desc =
 static void
 ExitConversation (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 
 	if (PLAYER_SAID (R, bye_angry_space))
 		NPCPhrase (GOODBYE_ANGRY_SPACE);
@@ -644,7 +644,7 @@ Intro (void)
 	{
 		NPCPhrase (OUT_TAKES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 	else if (!GET_GAME_STATE (MET_ARILOU))
@@ -691,7 +691,7 @@ Intro (void)
 		}
 		SET_GAME_STATE (ARILOU_VISITS, NumVisits);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else if (Manner == 1)
 	{
@@ -801,7 +801,7 @@ post_arilou_enc (void)
 {
 	BYTE Manner;
 
-	if (GET_GAME_STATE (BATTLE_SEGUE) == 1
+	if (getSegue () == Segue_hostile
 			&& (Manner = GET_GAME_STATE (ARILOU_MANNER)) != 2)
 	{
 		SET_GAME_STATE (ARILOU_MANNER, 1);
@@ -843,11 +843,11 @@ init_arilou_comm (void)
 			|| GET_GAME_STATE (ARILOU_MANNER) == 3
 			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	retval = &arilou_desc;
 
diff -ruNp src.orig/uqm/comm/arilou/resinst.h src/uqm/comm/arilou/resinst.h
--- src.orig/uqm/comm/arilou/resinst.h	2017-11-21 19:39:35 -0600
+++ src/uqm/comm/arilou/resinst.h	2017-11-21 19:39:52 -0600
@@ -1,5 +1,10 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define ARILOU_COLOR_MAP "comm.arilou.colortable"
-#define ARILOU_PMAP_ANIM "comm.arilou.graphics"
-#define ARILOU_FONT "comm.arilou.font"
 #define ARILOU_CONVERSATION_PHRASES "comm.arilou.dialogue"
+#define ARILOU_FONT "comm.arilou.font"
 #define ARILOU_MUSIC "comm.arilou.music"
+#define ARILOU_PMAP_ANIM "comm.arilou.graphics"
+#define ARILOU_SCRIPT "comm.arilou.script"
diff -ruNp src.orig/uqm/comm/blackur/Makeinfo src/uqm/comm/blackur/Makeinfo
--- src.orig/uqm/comm/blackur/Makeinfo	2017-11-21 19:39:35 -0600
+++ src/uqm/comm/blackur/Makeinfo	2017-11-21 19:39:52 -0600
@@ -1 +1,2 @@
 uqm_CFILES="blackurc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.orig/uqm/comm/blackur/blackurc.c src/uqm/comm/blackur/blackurc.c
--- src.orig/uqm/comm/blackur/blackurc.c	2017-11-21 19:39:35 -0600
+++ src/uqm/comm/blackur/blackurc.c	2017-11-21 19:39:52 -0600
@@ -134,7 +134,7 @@ CombatIsInevitable (RESPONSE_REF R)
 {
 	BYTE NumVisits;
 
-	SET_GAME_STATE (BATTLE_SEGUE, 1);
+	setSegue (Segue_hostile);
 
 	if (PLAYER_SAID (R, bye))
 	{
@@ -447,7 +447,7 @@ Intro (void)
 	{
 		NPCPhrase (OUT_TAKES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
@@ -455,7 +455,7 @@ Intro (void)
 	{
 		NPCPhrase (GAME_OVER_DUDE);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
@@ -466,7 +466,7 @@ Intro (void)
 		SET_GAME_STATE (KOHR_AH_SENSES_EVIL, 1);
 	}
 
-	GrpOffs = GET_GAME_STATE_32 (SAMATRA_GRPOFFS0);
+	GrpOffs = GET_GAME_STATE (SAMATRA_GRPOFFS);
 	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
 			&& GLOBAL (BattleGroupRef)
 			&& GLOBAL (BattleGroupRef) == GrpOffs)
@@ -474,7 +474,7 @@ Intro (void)
 		NPCPhrase (HELLO_SAMATRA);
 
 		SET_GAME_STATE (AWARE_OF_SAMATRA, 1);
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else
 	{
@@ -555,11 +555,11 @@ init_blackurq_comm (void)
 	if (!GET_GAME_STATE (KOHR_AH_KILLED_ALL)
 			&& LOBYTE (GLOBAL (CurrentActivity)) != WON_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	retval = &blackurq_desc;
 
diff -ruNp src.orig/uqm/comm/blackur/resinst.h src/uqm/comm/blackur/resinst.h
--- src.orig/uqm/comm/blackur/resinst.h	2017-11-21 19:39:35 -0600
+++ src/uqm/comm/blackur/resinst.h	2017-11-21 19:39:52 -0600
@@ -1,5 +1,10 @@
-#define BLACKURQ_PMAP_ANIM "comm.kohrah.graphics"
-#define BLACKURQ_FONT "comm.kohrah.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define BLACKURQ_COLOR_MAP "comm.kohrah.colortable"
 #define BLACKURQ_CONVERSATION_PHRASES "comm.kohrah.dialogue"
+#define BLACKURQ_FONT "comm.kohrah.font"
 #define BLACKURQ_MUSIC "comm.kohrah.music"
+#define BLACKURQ_PMAP_ANIM "comm.kohrah.graphics"
+#define BLACKURQ_SCRIPT "comm.kohrah.script"
diff -ruNp src.orig/uqm/comm/chmmr/Makeinfo src/uqm/comm/chmmr/Makeinfo
--- src.orig/uqm/comm/chmmr/Makeinfo	2017-11-21 19:39:35 -0600
+++ src/uqm/comm/chmmr/Makeinfo	2017-11-21 19:39:52 -0600
@@ -1 +1,2 @@
 uqm_CFILES="chmmrc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.orig/uqm/comm/chmmr/chmmrc.c src/uqm/comm/chmmr/chmmrc.c
--- src.orig/uqm/comm/chmmr/chmmrc.c	2017-11-21 19:39:35 -0600
+++ src/uqm/comm/chmmr/chmmrc.c	2017-11-21 19:39:52 -0600
@@ -20,6 +20,7 @@
 #include "resinst.h"
 #include "strings.h"
 
+#include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
 #include "uqm/hyper.h"
 			// for SOL_X/SOL_Y
@@ -120,7 +121,7 @@ static LOCDATA chmmr_desc =
 static void
 ExitConversation (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 
 	if (PLAYER_SAID (R, bye))
 		NPCPhrase (GOODBYE);
@@ -134,7 +135,7 @@ ExitConversation (RESPONSE_REF R)
 
 		NPCPhrase (TAKE_2_WEEKS);
 
-		ActivateStarShip (CHMMR_SHIP, SET_ALLIED);
+		SetRaceAllied (CHMMR_SHIP, TRUE);
 
 		SET_GAME_STATE (CHMMR_HOME_VISITS, 0);
 		SET_GAME_STATE (CHMMR_STACK, 0);
@@ -248,7 +249,7 @@ NotReady (RESPONSE_REF R)
 	{
 		NPCPhrase (USE_OUR_SHIPS_BEFORE);
 
-		ActivateStarShip (CHMMR_SHIP, SET_ALLIED);
+		SetRaceAllied (CHMMR_SHIP, TRUE);
 	}
 	else if (PLAYER_SAID (R, where_weapon))
 	{
@@ -263,7 +264,7 @@ NotReady (RESPONSE_REF R)
 		DISABLE_PHRASE (where_distraction);
 	}
 
-	if (ActivateStarShip (CHMMR_SHIP, CHECK_ALLIANCE) != GOOD_GUY)
+	if (CheckAlliance (CHMMR_SHIP) != GOOD_GUY)
 		Response (tech_help, NotReady);
 	else if (PHRASE_ENABLED (further_assistance))
 		Response (further_assistance, NotReady);
@@ -301,7 +302,7 @@ ImproveBomb (RESPONSE_REF R)
 	{
 		NPCPhrase (USE_OUR_SHIPS_AFTER);
 
-		ActivateStarShip (CHMMR_SHIP, SET_ALLIED);
+		SetRaceAllied (CHMMR_SHIP, TRUE);
 	}
 
 	if (PHRASE_ENABLED (what_now))
@@ -310,7 +311,7 @@ ImproveBomb (RESPONSE_REF R)
 		Response (wont_hurt_my_ship, ImproveBomb);
 	else if (PHRASE_ENABLED (bummer_about_my_ship))
 		Response (bummer_about_my_ship, ImproveBomb);
-	if (ActivateStarShip (CHMMR_SHIP, CHECK_ALLIANCE) != GOOD_GUY)
+	if (CheckAlliance (CHMMR_SHIP) != GOOD_GUY)
 		Response (other_assistance, ImproveBomb);
 	Response (proceed, ExitConversation);
 }
@@ -319,7 +320,7 @@ static void
 ChmmrFree (RESPONSE_REF R)
 {
 	if (R == 0
-			|| PLAYER_SAID (R, i_am_captain0)
+			|| PLAYER_SAID (R, i_am_captain)
 			|| PLAYER_SAID (R, i_am_savior)
 			|| PLAYER_SAID (R, i_am_silly))
 	{
@@ -591,14 +592,7 @@ Intro (void)
 			{
 				NPCPhrase (WHO_ARE_YOU);
 
-				construct_response (shared_phrase_buf,
-						i_am_captain0,
-						GLOBAL_SIS (CommanderName),
-						i_am_captain1,
-						GLOBAL_SIS (ShipName),
-						i_am_captain2,
-						(UNICODE*)NULL);
-				DoResponsePhrase (i_am_captain0, ChmmrFree, shared_phrase_buf);
+				Response (i_am_captain, ChmmrFree);
 				Response (i_am_savior, ChmmrFree);
 				Response (i_am_silly, ChmmrFree);
 			}
@@ -612,6 +606,7 @@ Intro (void)
 static COUNT
 uninit_chmmr (void)
 {
+	luaUqm_comm_uninit ();
 	return (0);
 }
 
@@ -630,11 +625,15 @@ init_chmmr_comm (void)
 	chmmr_desc.post_encounter_func = post_chmmr_enc;
 	chmmr_desc.uninit_encounter_func = uninit_chmmr;
 
+	luaUqm_comm_init (NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	chmmr_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
 	chmmr_desc.AlienTextBaseline.y = 0;
 	chmmr_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
 
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 	retval = &chmmr_desc;
 
 	return (retval);
diff -ruNp src.orig/uqm/comm/chmmr/resinst.h src/uqm/comm/chmmr/resinst.h
--- src.orig/uqm/comm/chmmr/resinst.h	2017-11-21 19:39:35 -0600
+++ src/uqm/comm/chmmr/resinst.h	2017-11-21 19:39:52 -0600
@@ -1,5 +1,10 @@
-#define CHMMR_PMAP_ANIM "comm.chmmr.graphics"
-#define CHMMR_FONT "comm.chmmr.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define CHMMR_COLOR_MAP "comm.chmmr.colortable"
 #define CHMMR_CONVERSATION_PHRASES "comm.chmmr.dialogue"
+#define CHMMR_FONT "comm.chmmr.font"
 #define CHMMR_MUSIC "comm.chmmr.music"
+#define CHMMR_PMAP_ANIM "comm.chmmr.graphics"
+#define CHMMR_SCRIPT "comm.chmmr.script"
diff -ruNp src.orig/uqm/comm/chmmr/strings.h src/uqm/comm/chmmr/strings.h
--- src.orig/uqm/comm/chmmr/strings.h	2017-11-21 19:39:35 -0600
+++ src/uqm/comm/chmmr/strings.h	2017-11-21 19:39:52 -0600
@@ -52,9 +52,7 @@ enum
 	GOODBYE_SHIELDED,
 	WE_ARE_FREE,
 	WHO_ARE_YOU,
-	i_am_captain0,
-	i_am_captain1,
-	i_am_captain2,
+	i_am_captain,
 	i_am_savior,
 	i_am_silly,
 	WHY_HAVE_YOU_FREED_US,
diff -ruNp src.orig/uqm/comm/comandr/Makeinfo src/uqm/comm/comandr/Makeinfo
--- src.orig/uqm/comm/comandr/Makeinfo	2017-11-21 19:39:35 -0600
+++ src/uqm/comm/comandr/Makeinfo	2017-11-21 19:39:52 -0600
@@ -1 +1,2 @@
 uqm_CFILES="comandr.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.orig/uqm/comm/comandr/comandr.c src/uqm/comm/comandr/comandr.c
--- src.orig/uqm/comm/comandr/comandr.c	2017-11-21 19:39:35 -0600
+++ src/uqm/comm/comandr/comandr.c	2017-11-21 19:39:52 -0600
@@ -24,6 +24,7 @@
 #include "uqm/sis.h"
 		// for DeltaSISGauges(), DrawLanders()
 #include "libs/graphics/gfx_common.h"
+#include "uqm/lua/luacomm.h"
 
 static LOCDATA commander_desc =
 {
@@ -143,18 +144,12 @@ ByeBye (RESPONSE_REF R)
 		else /* if (R == annihilate_those_monsters) */
 			NPCPhrase (KILL_MONSTERS);
 
-		construct_response (shared_phrase_buf,
-				name_40,
-				GLOBAL_SIS (CommanderName),
-				name_41,
-				(UNICODE*)NULL);
-
 		NPCPhrase (THIS_MAY_SEEM_SILLY);
 
 		Response (name_1, ByeBye);
 		Response (name_2, ByeBye);
 		Response (name_3, ByeBye);
-		DoResponsePhrase (name_40, ByeBye, shared_phrase_buf);
+		Response (name_4, ByeBye);
 
 		SET_GAME_STATE (STARBASE_AVAILABLE, 1);
 	}
@@ -180,9 +175,7 @@ ByeBye (RESPONSE_REF R)
 		}
 		else /* if (PLAYER_SAID (R, name_4)) */
 		{
-			NPCPhrase (OK_THE_NAME_IS_EMPIRE0);
-			NPCPhrase (GLOBAL_PLAYER_NAME);
-			NPCPhrase (OK_THE_NAME_IS_EMPIRE1);
+			NPCPhrase (OK_THE_NAME_IS_EMPIRE);
 
 			SET_GAME_STATE (NEW_ALLIANCE_NAME, 3);
 		}
@@ -216,7 +209,7 @@ NoRadioactives (RESPONSE_REF R)
 
 			DISABLE_PHRASE (where_can_i_get_radios);
 		}
-		else if (PLAYER_SAID (R, no_but_well_help0))
+		else if (PLAYER_SAID (R, no_but_well_help))
 			NPCPhrase (THE_WHAT_FROM_WHERE);
 		else if (PLAYER_SAID (R, what_slave_planet)
 				|| PLAYER_SAID (R, i_lied))
@@ -227,10 +220,8 @@ NoRadioactives (RESPONSE_REF R)
 		{
 			NPCPhrase (HERE_IS_A_NEW_LANDER);
 			++GLOBAL_SIS (NumLanders);
-			LockMutex (GraphicsLock);
 			DrawLanders ();
 			DeltaSISGauges (4, 0, 0);
-			UnlockMutex (GraphicsLock);
 
 			SET_GAME_STATE (LANDERS_LOST, 1);
 		}
@@ -238,27 +229,21 @@ NoRadioactives (RESPONSE_REF R)
 		{
 			NPCPhrase (HERE_IS_ANOTHER_LANDER);
 			++GLOBAL_SIS (NumLanders);
-			LockMutex (GraphicsLock);
 			DrawLanders ();
 			DeltaSISGauges (4, 0, 0);
-			UnlockMutex (GraphicsLock);
 		}
 		else if (PLAYER_SAID (R, need_fuel_mercury) ||
 				PLAYER_SAID (R, need_fuel_luna))
 		{
 			NPCPhrase (GIVE_FUEL);
-			LockMutex (GraphicsLock);
 			DeltaSISGauges (0, 5 * FUEL_TANK_SCALE, 0);
-			UnlockMutex (GraphicsLock);
 
 			SET_GAME_STATE (GIVEN_FUEL_BEFORE, 1);
 		}
 		else if (PLAYER_SAID (R, need_fuel_again))
 		{
 			NPCPhrase (GIVE_FUEL_AGAIN);
-			LockMutex (GraphicsLock);
 			DeltaSISGauges (0, 5 * FUEL_TANK_SCALE, 0);
-			UnlockMutex (GraphicsLock);
 		}
 
 		if (GLOBAL_SIS (ElementAmounts[RADIOACTIVE]))
@@ -297,10 +282,8 @@ AskAfterRadios (RESPONSE_REF R)
 	{
 		NPCPhrase (HERE_IS_A_NEW_LANDER);
 		++GLOBAL_SIS (NumLanders);
-		LockMutex (GraphicsLock);
 		DrawLanders ();
 		DeltaSISGauges (4, 0, 0);
-		UnlockMutex (GraphicsLock);
 
 		SET_GAME_STATE (LANDERS_LOST, 1);
 	}
@@ -308,27 +291,21 @@ AskAfterRadios (RESPONSE_REF R)
 	{
 		NPCPhrase (HERE_IS_ANOTHER_LANDER);
 		++GLOBAL_SIS (NumLanders);
-		LockMutex (GraphicsLock);
 		DrawLanders ();
 		DeltaSISGauges (4, 0, 0);
-		UnlockMutex (GraphicsLock);
 	}
 	else if (PLAYER_SAID (R, need_fuel_mercury) ||
 			PLAYER_SAID (R, need_fuel_luna))
 	{
 		NPCPhrase (GIVE_FUEL);
-		LockMutex (GraphicsLock);
 		DeltaSISGauges (0, 5 * FUEL_TANK_SCALE, 0);
-		UnlockMutex (GraphicsLock);
 
 		SET_GAME_STATE (GIVEN_FUEL_BEFORE, 1);
 	}
 	else if (PLAYER_SAID (R, need_fuel_again))
 	{
 		NPCPhrase (GIVE_FUEL_AGAIN);
-		LockMutex (GraphicsLock);
 		DeltaSISGauges (0, 5 * FUEL_TANK_SCALE, 0);
-		UnlockMutex (GraphicsLock);
 	}
 	else if (PLAYER_SAID (R, where_get_radios))
 	{
@@ -399,10 +376,8 @@ TellMoonBase (RESPONSE_REF R)
 	{
 		NPCPhrase (HERE_IS_A_NEW_LANDER);
 		++GLOBAL_SIS (NumLanders);
-		LockMutex (GraphicsLock);
 		DrawLanders ();
 		DeltaSISGauges (4, 0, 0);
-		UnlockMutex (GraphicsLock);
 
 		SET_GAME_STATE (LANDERS_LOST, 1);
 	}
@@ -410,27 +385,21 @@ TellMoonBase (RESPONSE_REF R)
 	{
 		NPCPhrase (HERE_IS_ANOTHER_LANDER);
 		++GLOBAL_SIS (NumLanders);
-		LockMutex (GraphicsLock);
 		DrawLanders ();
 		DeltaSISGauges (4, 0, 0);
-		UnlockMutex (GraphicsLock);
 	}
 	else if (PLAYER_SAID (R, need_fuel_mercury) ||
 			PLAYER_SAID (R, need_fuel_luna))
 	{
 		NPCPhrase (GIVE_FUEL);
-		LockMutex (GraphicsLock);
 		DeltaSISGauges (0, 5 * FUEL_TANK_SCALE, 0);
-		UnlockMutex (GraphicsLock);
 
 		SET_GAME_STATE (GIVEN_FUEL_BEFORE, 1);
 	}
 	else if (PLAYER_SAID (R, need_fuel_again))
 	{
 		NPCPhrase (GIVE_FUEL_AGAIN);
-		LockMutex (GraphicsLock);
 		DeltaSISGauges (0, 5 * FUEL_TANK_SCALE, 0);
-		UnlockMutex (GraphicsLock);
 	}
 	else if (PLAYER_SAID (R, we_are_here_to_help))
 	{
@@ -492,11 +461,11 @@ RevealSelf (RESPONSE_REF R)
 	BYTE i, stack;
 
 	stack = 0;
-	if (PLAYER_SAID (R, we_are_vindicator0))
+	if (PLAYER_SAID (R, we_are_vindicator))
 	{
 		NPCPhrase (THATS_IMPOSSIBLE);
 
-		DISABLE_PHRASE (we_are_vindicator0);
+		DISABLE_PHRASE (we_are_vindicator);
 	}
 	else if (PLAYER_SAID (R, our_mission_was_secret))
 	{
@@ -558,17 +527,8 @@ RevealSelf (RESPONSE_REF R)
 		}
 		else
 		{
-			if (PHRASE_ENABLED (we_are_vindicator0))
-			{
-				construct_response (shared_phrase_buf,
-						we_are_vindicator0,
-						GLOBAL_SIS (CommanderName),
-						we_are_vindicator1,
-						GLOBAL_SIS (ShipName),
-						we_are_vindicator2,
-						(UNICODE*)NULL);
-				DoResponsePhrase (we_are_vindicator0, RevealSelf, shared_phrase_buf);
-			}
+			if (PHRASE_ENABLED (we_are_vindicator))
+				Response (we_are_vindicator, RevealSelf);
 			else if (PHRASE_ENABLED (our_mission_was_secret))
 				Response (our_mission_was_secret, RevealSelf);
 			else
@@ -593,9 +553,7 @@ GiveRadios (RESPONSE_REF R)
 		NPCPhrase (FUEL_UP1);		
 		AlienTalkSegue (1);
 
-		LockMutex (GraphicsLock);
 		CommData.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
-		UnlockMutex (GraphicsLock);
 
 		XFormColorMap (GetColorMapAddress (
 				SetAbsColorMapIndex (CommData.AlienColorMap, 0)
@@ -662,13 +620,7 @@ Intro (void)
 		SET_GAME_STATE (STARBASE_VISITED, 1);
 
 		NPCPhrase (ARE_YOU_SUPPLY_SHIP);
-		construct_response (
-				shared_phrase_buf,
-				no_but_well_help0,
-				GLOBAL_SIS (ShipName),
-				no_but_well_help1,
-				(UNICODE*)NULL);
-		DoResponsePhrase (no_but_well_help0, NoRadioactives, shared_phrase_buf);
+		Response (no_but_well_help, NoRadioactives);
 		Response (yes_this_is_supply_ship, NoRadioactives);
 		Response (what_slave_planet, NoRadioactives);
 	}
@@ -677,6 +629,7 @@ Intro (void)
 static COUNT
 uninit_commander (void)
 {
+	luaUqm_comm_uninit();
 	return (0);
 }
 
@@ -695,6 +648,10 @@ init_commander_comm ()
 	commander_desc.post_encounter_func = post_commander_enc;
 	commander_desc.uninit_encounter_func = uninit_commander;
 
+	luaUqm_comm_init(NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	if (GET_GAME_STATE (RADIOACTIVES_PROVIDED))
 	{
 		commander_desc.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
@@ -713,7 +670,7 @@ init_commander_comm ()
 	commander_desc.AlienTextBaseline.x = 164;
 	commander_desc.AlienTextBaseline.y = 20;
 
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 	retval = &commander_desc;
 
 	return (retval);
diff -ruNp src.orig/uqm/comm/comandr/resinst.h src/uqm/comm/comandr/resinst.h
--- src.orig/uqm/comm/comandr/resinst.h	2017-11-21 19:39:35 -0600
+++ src/uqm/comm/comandr/resinst.h	2017-11-21 19:39:52 -0600
@@ -1,8 +1,14 @@
-#define COMMANDER_PMAP_ANIM "comm.commander.graphics"
-#define COMMANDER_FONT "comm.commander.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define COMMANDER_COLOR_MAP "comm.commander.colortable"
 #define COMMANDER_CONVERSATION_PHRASES "comm.commander.dialogue"
-#define STARBASE_CONVERSATION_PHRASES "comm.starbase.dialogue"
+#define COMMANDER_FONT "comm.commander.font"
 #define COMMANDER_LOWPOW_MUSIC "comm.commander.lowpower.music"
 #define COMMANDER_MUSIC "comm.commander.music"
+#define COMMANDER_PMAP_ANIM "comm.commander.graphics"
+#define COMMANDER_SCRIPT "comm.commander.script"
 #define STARBASE_ALT_MUSIC "comm.starbase.music"
+#define STARBASE_CONVERSATION_PHRASES "comm.starbase.dialogue"
+#define STARBASE_SCRIPT "comm.starbase.script"
diff -ruNp src.orig/uqm/comm/comandr/strings.h src/uqm/comm/comandr/strings.h
--- src.orig/uqm/comm/comandr/strings.h	2017-11-21 19:39:35 -0600
+++ src/uqm/comm/comandr/strings.h	2017-11-21 19:39:52 -0600
@@ -37,8 +37,7 @@ enum
 	OK_THE_NAFS,
 	OK_THE_CAN,
 	OK_THE_UFW,
-	OK_THE_NAME_IS_EMPIRE0,
-	OK_THE_NAME_IS_EMPIRE1,
+	OK_THE_NAME_IS_EMPIRE,
 	FUEL_UP0,
 	FUEL_UP1,
 	WHAT_KIND_OF_IDIOT,
@@ -80,15 +79,12 @@ enum
 	we_will_transfer_now,
 	what_will_you_give_us,
 	before_radios_we_need_info,
-	no_but_well_help0,
-	no_but_well_help1,
+	no_but_well_help,
 	yes_this_is_supply_ship,
 	what_slave_planet,
 	i_lied,
 	plumb_out,
-	we_are_vindicator0,
-	we_are_vindicator1,
-	we_are_vindicator2,
+	we_are_vindicator,
 	first_give_info,
 	we_must_go_now,
 	where_can_i_get_radios,
@@ -109,8 +105,7 @@ enum
 	name_1,
 	name_2,
 	name_3,
-	name_40,
-	name_41,
+	name_4,
 	i_lost_my_lander,
 	i_lost_another_lander,
 	need_fuel_mercury,
diff -ruNp src.orig/uqm/comm/druuge/Makeinfo src/uqm/comm/druuge/Makeinfo
--- src.orig/uqm/comm/druuge/Makeinfo	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/druuge/Makeinfo	2017-11-21 19:39:52 -0600
@@ -1 +1,2 @@
 uqm_CFILES="druugec.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.orig/uqm/comm/druuge/druugec.c src/uqm/comm/druuge/druugec.c
--- src.orig/uqm/comm/druuge/druugec.c	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/druuge/druugec.c	2017-11-21 19:39:52 -0600
@@ -166,7 +166,7 @@ ExitConversation (RESPONSE_REF R)
 {
 	if (PLAYER_SAID (R, bye))
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 
 		if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 7))
 		{
@@ -210,7 +210,7 @@ ExitConversation (RESPONSE_REF R)
 	}
 	else /* if (R == then_we_take_bomb) */
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 
 		NPCPhrase (FIGHT_FOR_BOMB);
 	}
@@ -240,15 +240,13 @@ Buy (RESPONSE_REF R)
 #define SHIP_CREW_COST 100
 		if (GLOBAL_SIS (CrewEnlisted) < SHIP_CREW_COST)
 			NPCPhrase (NOT_ENOUGH_CREW);
-		else if (ActivateStarShip (DRUUGE_SHIP, FEASIBILITY_STUDY) == 0)
+		else if (EscortFeasibilityStudy (DRUUGE_SHIP) == 0)
 			NPCPhrase (NOT_ENOUGH_ROOM);
 		else
 		{
-			LockMutex (GraphicsLock);
 			DeltaSISGauges (-SHIP_CREW_COST, 0, 0);
-			UnlockMutex (GraphicsLock);
 			SlaveryCount += SHIP_CREW_COST;
-			ActivateStarShip (DRUUGE_SHIP, 1);
+			AddEscortShips (DRUUGE_SHIP, 1);
 
 			NPCPhrase (BOUGHT_SHIP);
 		}
@@ -260,9 +258,7 @@ Buy (RESPONSE_REF R)
 			NPCPhrase (NOT_ENOUGH_CREW);
 		else
 		{
-			LockMutex (GraphicsLock);
 			DeltaSISGauges (-ARTIFACT_CREW_COST, 0, 0);
-			UnlockMutex (GraphicsLock);
 			SlaveryCount += ARTIFACT_CREW_COST;
 			SET_GAME_STATE (ROSY_SPHERE_ON_SHIP, 1);
 			SET_GAME_STATE (ROSY_SPHERE, 1);
@@ -276,9 +272,7 @@ Buy (RESPONSE_REF R)
 			NPCPhrase (NOT_ENOUGH_CREW);
 		else
 		{
-			LockMutex (GraphicsLock);
 			DeltaSISGauges (-ARTIFACT_CREW_COST, 0, 0);
-			UnlockMutex (GraphicsLock);
 			SlaveryCount += ARTIFACT_CREW_COST;
 			SET_GAME_STATE (ARTIFACT_2_ON_SHIP, 1);
 
@@ -291,9 +285,7 @@ Buy (RESPONSE_REF R)
 			NPCPhrase (NOT_ENOUGH_CREW);
 		else
 		{
-			LockMutex (GraphicsLock);
 			DeltaSISGauges (-ARTIFACT_CREW_COST, 0, 0);
-			UnlockMutex (GraphicsLock);
 			SlaveryCount += ARTIFACT_CREW_COST;
 			SET_GAME_STATE (ARTIFACT_3_ON_SHIP, 1);
 
@@ -307,10 +299,8 @@ Buy (RESPONSE_REF R)
 			NPCPhrase (NOT_ENOUGH_CREW);
 		else
 		{
-			LockMutex (GraphicsLock);
 			DeltaSISGauges (-FUEL_CREW_COST,
 					FUEL_CREW_COST * FUEL_TANK_SCALE, 0);
-			UnlockMutex (GraphicsLock);
 			SlaveryCount += FUEL_CREW_COST;
 
 			NPCPhrase (BOUGHT_FUEL);
@@ -403,7 +393,7 @@ DoTransaction (RESPONSE_REF R)
 
 		trade_gas = 0;
 		ships_to_trade = 0;
-		ship_slots = ActivateStarShip (DRUUGE_SHIP, FEASIBILITY_STUDY);
+		ship_slots = EscortFeasibilityStudy (DRUUGE_SHIP);
 		if (PLAYER_SAID (R, sell_maidens))
 		{
 			NPCPhrase (BOUGHT_MAIDENS);
@@ -430,7 +420,7 @@ DoTransaction (RESPONSE_REF R)
 		NPCPhrase (YOU_GET);
 		if (ships_to_trade)
 		{
-			ActivateStarShip (DRUUGE_SHIP, ships_to_trade);
+			AddEscortShips (DRUUGE_SHIP, ships_to_trade);
 
 			if (ship_slots >= ships_to_trade)
 				NPCPhrase (DEAL_FOR_STATED_SHIPS);
@@ -466,14 +456,12 @@ DoTransaction (RESPONSE_REF R)
 			capacity -= GLOBAL_SIS (FuelOnBoard);
 			f = (COUNT)((capacity + (FUEL_TANK_SCALE >> 1)) / FUEL_TANK_SCALE);
 
-			LockMutex (GraphicsLock);
 			while (capacity > 0x3FFFL)
 			{
 				DeltaSISGauges (0, 0x3FFF, 0);
 				capacity -= 0x3FFF;
 			}
 			DeltaSISGauges (0, (SIZE)capacity, 0);
-			UnlockMutex (GraphicsLock);
 
 			NPCPhrase (FUEL0);
 			NPCNumber (f, NULL);
@@ -695,7 +683,7 @@ Intro (void)
 	{
 		NPCPhrase (OUT_TAKES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
@@ -732,7 +720,7 @@ Intro (void)
 			SET_GAME_STATE (DRUUGE_VISITS, NumVisits);
 		}
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 7))
 	{
@@ -826,7 +814,7 @@ Intro (void)
 		}
 		SET_GAME_STATE (DRUUGE_VISITS, NumVisits);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else
 	{
@@ -862,7 +850,7 @@ Intro (void)
 			}
 			SET_GAME_STATE (DRUUGE_SALVAGE, NumVisits);
 
-			SET_GAME_STATE (BATTLE_SEGUE, 1);
+			setSegue (Segue_hostile);
 			AttemptedSalvage = TRUE;
 		}
 		else
@@ -894,7 +882,7 @@ uninit_druuge (void)
 static void
 post_druuge_enc (void)
 {
-	if (GET_GAME_STATE (BATTLE_SEGUE) == 1
+	if (getSegue () == Segue_hostile
 			&& !AttemptedSalvage
 			&& !GET_GAME_STATE (DRUUGE_MANNER))
 	{
@@ -926,11 +914,11 @@ init_druuge_comm (void)
 			&& (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 7)))
 			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	retval = &druuge_desc;
 
diff -ruNp src.orig/uqm/comm/druuge/resinst.h src/uqm/comm/druuge/resinst.h
--- src.orig/uqm/comm/druuge/resinst.h	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/druuge/resinst.h	2017-11-21 19:39:52 -0600
@@ -1,5 +1,10 @@
-#define DRUUGE_PMAP_ANIM "comm.druuge.graphics"
-#define DRUUGE_FONT "comm.druuge.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define DRUUGE_COLOR_MAP "comm.druuge.colortable"
 #define DRUUGE_CONVERSATION_PHRASES "comm.druuge.dialogue"
+#define DRUUGE_FONT "comm.druuge.font"
 #define DRUUGE_MUSIC "comm.druuge.music"
+#define DRUUGE_PMAP_ANIM "comm.druuge.graphics"
+#define DRUUGE_SCRIPT "comm.druuge.script"
diff -ruNp src.orig/uqm/comm/ilwrath/Makeinfo src/uqm/comm/ilwrath/Makeinfo
--- src.orig/uqm/comm/ilwrath/Makeinfo	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/ilwrath/Makeinfo	2017-11-21 19:39:52 -0600
@@ -1 +1,2 @@
 uqm_CFILES="ilwrathc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.orig/uqm/comm/ilwrath/ilwrathc.c src/uqm/comm/ilwrath/ilwrathc.c
--- src.orig/uqm/comm/ilwrath/ilwrathc.c	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/ilwrath/ilwrathc.c	2017-11-21 19:39:52 -0600
@@ -102,7 +102,7 @@ static LOCDATA ilwrath_desc =
 static void
 CombatIsInevitable (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 1);
+	setSegue (Segue_hostile);
 
 	if (PLAYER_SAID (R, you_are_weak))
 		NPCPhrase (STRENGTH_NOT_ALL);
@@ -124,7 +124,7 @@ CombatIsInevitable (RESPONSE_REF R)
 	{
 		NPCPhrase (GOODBYE_GODS);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	if (PLAYER_SAID (R, whats_up))
 	{
@@ -586,7 +586,7 @@ Intro (void)
 		else
 			NPCPhrase (JUST_GRUNTS);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 4))
 	{
@@ -596,7 +596,7 @@ Intro (void)
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 
 		if (GET_GAME_STATE (ILWRATH_FIGHT_THRADDASH))
 			NPCPhrase (HAPPY_FIGHTING_THRADDASH);
@@ -637,11 +637,11 @@ init_ilwrath_comm (void)
 			& ((1 << 4) | (1 << 5)))
 			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	retval = &ilwrath_desc;
 
diff -ruNp src.orig/uqm/comm/ilwrath/resinst.h src/uqm/comm/ilwrath/resinst.h
--- src.orig/uqm/comm/ilwrath/resinst.h	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/ilwrath/resinst.h	2017-11-21 19:39:52 -0600
@@ -1,5 +1,10 @@
-#define ILWRATH_PMAP_ANIM "comm.ilwrath.graphics"
-#define ILWRATH_FONT "comm.ilwrath.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define ILWRATH_COLOR_MAP "comm.ilwrath.colortable"
 #define ILWRATH_CONVERSATION_PHRASES "comm.ilwrath.dialogue"
+#define ILWRATH_FONT "comm.ilwrath.font"
 #define ILWRATH_MUSIC "comm.ilwrath.music"
+#define ILWRATH_PMAP_ANIM "comm.ilwrath.graphics"
+#define ILWRATH_SCRIPT "comm.ilwrath.script"
diff -ruNp src.orig/uqm/comm/melnorm/Makeinfo src/uqm/comm/melnorm/Makeinfo
--- src.orig/uqm/comm/melnorm/Makeinfo	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/melnorm/Makeinfo	2017-11-21 19:39:53 -0600
@@ -1 +1,2 @@
 uqm_CFILES="melnorm.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.orig/uqm/comm/melnorm/melnorm.c src/uqm/comm/melnorm/melnorm.c
--- src.orig/uqm/comm/melnorm/melnorm.c	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/melnorm/melnorm.c	2017-11-21 19:39:53 -0600
@@ -21,12 +21,11 @@
 #include "strings.h"
 
 #include "uqm/gameev.h"
-#include "uqm/setup.h"
-		// for GraphicsLock
 #include "uqm/shipcont.h"
 #include "libs/inplib.h"
 #include "libs/mathlib.h"
 
+#include "uqm/lua/luacomm.h"
 #include "uqm/hyper.h"
 			// for SOL_X/SOL_Y
 #include "uqm/planets/planets.h"
@@ -34,11 +33,6 @@
 #include "uqm/sis.h"
 
 
-#define NUM_HISTORY_ITEMS 9
-#define NUM_EVENT_ITEMS 8
-#define NUM_ALIEN_RACE_ITEMS 16
-#define NUM_TECH_ITEMS 13
-
 static const NUMBER_SPEECH_DESC melnorme_numbers_english;
 
 static LOCDATA melnorme_desc =
@@ -201,6 +195,294 @@ static const NUMBER_SPEECH_DESC melnorme
 	}
 };
 
+#define ARRAY_SIZE(array) (sizeof(array) / sizeof (*array))
+
+
+//////////////Technology System///////////////////////
+// This section deals with enabling and checking for
+// various technologies.  It should probably be
+// migrated to its own file.
+
+// Identifiers for the various technologies
+typedef enum 
+{
+	TECH_MODULE_BLASTER,
+	TECH_LANDER_SPEED,
+	TECH_MODULE_ANTIMISSILE,
+	TECH_LANDER_SHIELD_BIO,
+	TECH_LANDER_CARGO,
+	TECH_MODULE_BIGFUELTANK,
+	TECH_LANDER_RAPIDFIRE,
+	TECH_LANDER_SHIELD_QUAKE,
+	TECH_MODULE_TRACKING,
+	TECH_LANDER_SHIELD_LIGHTNING,
+	TECH_LANDER_SHIELD_HEAT,
+	TECH_MODULE_CANNON,
+	TECH_MODULE_FURNACE,
+} TechId_t;
+
+// Group the technologies into three subtypes
+typedef enum
+{
+	TECH_TYPE_MODULE,         // Flagship modules
+	                          //  subtype = moduleId, info = cost
+                              //   Cost will be scaled by MODULE_COST_SCALE.
+	TECH_TYPE_LANDER_SHIELD,  // Lander shield enhancements
+                              //  subtype = disaster type, info = unused
+	TECH_TYPE_STATE           // Other game state changes
+	                          //  subtype = stateId, info = state value
+} TechType_t;
+
+
+// Define the information specifying a particular technology
+typedef struct
+{
+	TechId_t   id;      // ID of the technology
+	TechType_t type;    // Type of the technology
+	int        subtype; // Subtype of the technology
+	int        info;    // Supplemental information
+} TechData;
+
+
+// A table of the available technologies.
+// This should really be an associative map of TechIds to tech data records,
+// but implementing that would be excessive.
+static const TechData tech_data_table[] = 
+{
+	// Tech ID                      Tech Type,               Supplemental info
+	{ TECH_MODULE_BLASTER,          TECH_TYPE_MODULE,        BLASTER_WEAPON,        4000 },
+	{ TECH_LANDER_SPEED,            TECH_TYPE_STATE,         IMPROVED_LANDER_SPEED,    1 },
+	{ TECH_MODULE_ANTIMISSILE,      TECH_TYPE_MODULE,        ANTIMISSILE_DEFENSE,   4000 },
+	{ TECH_LANDER_SHIELD_BIO,       TECH_TYPE_LANDER_SHIELD, BIOLOGICAL_DISASTER,     -1 },
+	{ TECH_LANDER_CARGO,            TECH_TYPE_STATE,         IMPROVED_LANDER_CARGO,    1 },
+	{ TECH_MODULE_BIGFUELTANK,      TECH_TYPE_MODULE,        HIGHEFF_FUELSYS,       1000 },
+	{ TECH_LANDER_RAPIDFIRE,        TECH_TYPE_STATE,         IMPROVED_LANDER_SHOT,     1 },
+	{ TECH_LANDER_SHIELD_QUAKE,     TECH_TYPE_LANDER_SHIELD, EARTHQUAKE_DISASTER,     -1 },
+	{ TECH_MODULE_TRACKING,         TECH_TYPE_MODULE,        TRACKING_SYSTEM,       5000 },
+	{ TECH_LANDER_SHIELD_LIGHTNING, TECH_TYPE_LANDER_SHIELD, LIGHTNING_DISASTER,      -1 },
+	{ TECH_LANDER_SHIELD_HEAT,      TECH_TYPE_LANDER_SHIELD, LAVASPOT_DISASTER,       -1 },
+	{ TECH_MODULE_CANNON,           TECH_TYPE_MODULE,        CANNON_WEAPON,         6000 },
+	{ TECH_MODULE_FURNACE,          TECH_TYPE_MODULE,        SHIVA_FURNACE,         4000 },
+};
+const size_t NUM_TECHNOLOGIES = ARRAY_SIZE (tech_data_table);
+
+// Lookup function to get the data for a particular tech
+static const TechData* 
+GetTechData (TechId_t techId)
+{
+	size_t i = 0;
+	for (i = 0; i < NUM_TECHNOLOGIES; ++i)
+	{
+		if (tech_data_table[i].id == techId)
+			return &tech_data_table[i];
+	}
+	return NULL;
+}
+
+
+// We have to explicitly switch on the state ID because the xxx_GAME_STATE
+// macros use preprocessor stringizing.
+static bool
+HasStateTech (int stateId)
+{
+	switch (stateId)
+	{
+		case IMPROVED_LANDER_SPEED:
+			return GET_GAME_STATE (IMPROVED_LANDER_SPEED);
+		case IMPROVED_LANDER_CARGO:
+			return GET_GAME_STATE (IMPROVED_LANDER_CARGO);
+		case IMPROVED_LANDER_SHOT:
+			return GET_GAME_STATE (IMPROVED_LANDER_SHOT);
+	}
+	return false;
+}
+
+static void
+GrantStateTech (int stateId, BYTE value)
+{
+	switch (stateId)
+	{
+		case IMPROVED_LANDER_SPEED:
+			SET_GAME_STATE (IMPROVED_LANDER_SPEED, value);
+			return;
+		case IMPROVED_LANDER_CARGO:
+			SET_GAME_STATE (IMPROVED_LANDER_CARGO, value);
+			return;
+		case IMPROVED_LANDER_SHOT:
+			SET_GAME_STATE (IMPROVED_LANDER_SHOT, value);
+			return;
+	}
+}
+
+static bool
+HasTech (TechId_t techId)
+{
+	const TechData* techData = GetTechData (techId);
+	if (!techData)
+		return false;
+
+	switch (techData->type)
+	{
+		case TECH_TYPE_MODULE:
+			return GLOBAL (ModuleCost[techData->subtype]) != 0;
+		case TECH_TYPE_LANDER_SHIELD:
+			return (GET_GAME_STATE (LANDER_SHIELDS) & (1 << techData->subtype)) != 0;
+		case TECH_TYPE_STATE:
+			return HasStateTech (techData->subtype);
+	}
+	return false;
+}
+
+static void
+GrantTech (TechId_t techId)
+{
+	const TechData* techData = GetTechData (techId);
+	if (!techData)
+		return;
+
+	switch (techData->type)
+	{
+		case TECH_TYPE_MODULE:
+			GLOBAL (ModuleCost[techData->subtype]) = techData->info / MODULE_COST_SCALE;
+			return;
+		case TECH_TYPE_LANDER_SHIELD:
+		{
+			COUNT state = GET_GAME_STATE (LANDER_SHIELDS) | (1 << techData->subtype);
+			SET_GAME_STATE (LANDER_SHIELDS, state);
+			return;
+		}
+		case TECH_TYPE_STATE:
+			GrantStateTech (techData->subtype, techData->info);
+			return;
+	}
+}
+
+
+////////////Melnorme Sales System///////////
+// This section contains code related to Melnorme sales
+
+// Many of the conversation lines in strings.h fall into groups
+// of sequential responses.  These structures allow those
+// responses to be interated through.
+static const int ok_buy_event_lines[] =
+{
+	OK_BUY_EVENT_1, OK_BUY_EVENT_2, OK_BUY_EVENT_3, OK_BUY_EVENT_4,
+	OK_BUY_EVENT_5, OK_BUY_EVENT_6, OK_BUY_EVENT_7, OK_BUY_EVENT_8
+};
+const size_t NUM_EVENT_ITEMS = ARRAY_SIZE (ok_buy_event_lines);
+
+static const int ok_buy_alien_race_lines[] =
+{
+	OK_BUY_ALIEN_RACE_1,  OK_BUY_ALIEN_RACE_2,  OK_BUY_ALIEN_RACE_3, 
+	OK_BUY_ALIEN_RACE_4,  OK_BUY_ALIEN_RACE_5,  OK_BUY_ALIEN_RACE_6, 
+	OK_BUY_ALIEN_RACE_7,  OK_BUY_ALIEN_RACE_8,  OK_BUY_ALIEN_RACE_9, 
+	OK_BUY_ALIEN_RACE_10, OK_BUY_ALIEN_RACE_11, OK_BUY_ALIEN_RACE_12,
+	OK_BUY_ALIEN_RACE_13, OK_BUY_ALIEN_RACE_14, OK_BUY_ALIEN_RACE_15, 
+	OK_BUY_ALIEN_RACE_16
+};
+const size_t NUM_ALIEN_RACE_ITEMS = ARRAY_SIZE (ok_buy_alien_race_lines);
+
+static const int ok_buy_history_lines[] =
+{
+	OK_BUY_HISTORY_1, OK_BUY_HISTORY_2, OK_BUY_HISTORY_3, 
+	OK_BUY_HISTORY_4, OK_BUY_HISTORY_5, OK_BUY_HISTORY_6, 
+	OK_BUY_HISTORY_7, OK_BUY_HISTORY_8, OK_BUY_HISTORY_9
+};
+const size_t NUM_HISTORY_ITEMS = ARRAY_SIZE (ok_buy_history_lines);
+
+static const int hello_and_down_to_business_lines[] =
+{
+	HELLO_AND_DOWN_TO_BUSINESS_1, HELLO_AND_DOWN_TO_BUSINESS_2,
+	HELLO_AND_DOWN_TO_BUSINESS_3, HELLO_AND_DOWN_TO_BUSINESS_4,
+	HELLO_AND_DOWN_TO_BUSINESS_5, HELLO_AND_DOWN_TO_BUSINESS_6,
+	HELLO_AND_DOWN_TO_BUSINESS_7, HELLO_AND_DOWN_TO_BUSINESS_8,
+	HELLO_AND_DOWN_TO_BUSINESS_9, HELLO_AND_DOWN_TO_BUSINESS_10
+};
+const size_t NUM_HELLO_LINES = ARRAY_SIZE (hello_and_down_to_business_lines);
+
+static const int rescue_lines[] =
+{
+	RESCUE_EXPLANATION, RESCUE_AGAIN_1, RESCUE_AGAIN_2,
+	RESCUE_AGAIN_3,     RESCUE_AGAIN_4, RESCUE_AGAIN_5
+};
+const size_t NUM_RESCUE_LINES = ARRAY_SIZE (rescue_lines);
+
+// How many lines are available in the given array?
+static size_t
+GetNumLines (const int array[])
+{
+	if (array == ok_buy_event_lines)
+		return NUM_EVENT_ITEMS;
+	else if (array == ok_buy_alien_race_lines)
+		return NUM_ALIEN_RACE_ITEMS;
+	else if (array == ok_buy_history_lines)
+		return NUM_HISTORY_ITEMS;
+	else if (array == hello_and_down_to_business_lines)
+		return NUM_HELLO_LINES;
+	else if (array == rescue_lines)
+		return NUM_RESCUE_LINES;
+	return 0;
+}
+
+// Get the line, with range checking.
+// Returns the last line if the desired one is out of range.
+static int 
+GetLineSafe (const int array[], size_t linenum)
+{
+	const size_t array_size = GetNumLines (array);
+	assert (array_size > 0);
+	if (linenum >= array_size)
+		linenum = array_size - 1;
+	return array[linenum];
+}
+
+// Data structure to hold the Melnorme's info on a technology
+typedef struct
+{
+	TechId_t techId;  // ID of technology
+	int price;        // Melnorme's price to sell
+	int sale_line;    // Sales pitch line ID
+	int sold_line;    // Post-sale line ID
+} TechSaleData;
+
+// Right now, all techs have the same price.
+#define TECHPRICE (75 * BIO_CREDIT_VALUE)
+
+static const TechSaleData tech_sale_catalog[] =
+{
+	{ TECH_MODULE_BLASTER,          TECHPRICE, NEW_TECH_1,  OK_BUY_NEW_TECH_1 },
+	{ TECH_LANDER_SPEED,            TECHPRICE, NEW_TECH_2,  OK_BUY_NEW_TECH_2 },
+	{ TECH_MODULE_ANTIMISSILE,      TECHPRICE, NEW_TECH_3,  OK_BUY_NEW_TECH_3 },
+	{ TECH_LANDER_SHIELD_BIO,       TECHPRICE, NEW_TECH_4,  OK_BUY_NEW_TECH_4 },
+	{ TECH_LANDER_CARGO,            TECHPRICE, NEW_TECH_5,  OK_BUY_NEW_TECH_5 },
+	{ TECH_MODULE_BIGFUELTANK,      TECHPRICE, NEW_TECH_6,  OK_BUY_NEW_TECH_6 },
+	{ TECH_LANDER_RAPIDFIRE,        TECHPRICE, NEW_TECH_7,  OK_BUY_NEW_TECH_7 },
+	{ TECH_LANDER_SHIELD_QUAKE,     TECHPRICE, NEW_TECH_8,  OK_BUY_NEW_TECH_8 },
+	{ TECH_MODULE_TRACKING,         TECHPRICE, NEW_TECH_9,  OK_BUY_NEW_TECH_9 },
+	{ TECH_LANDER_SHIELD_LIGHTNING, TECHPRICE, NEW_TECH_10, OK_BUY_NEW_TECH_10 },
+	{ TECH_LANDER_SHIELD_HEAT,      TECHPRICE, NEW_TECH_11, OK_BUY_NEW_TECH_11 },
+	{ TECH_MODULE_CANNON,           TECHPRICE, NEW_TECH_12, OK_BUY_NEW_TECH_12 },
+	{ TECH_MODULE_FURNACE,          TECHPRICE, NEW_TECH_13, OK_BUY_NEW_TECH_13 },
+};
+const size_t NUM_TECH_ITEMS = ARRAY_SIZE (tech_sale_catalog);
+
+// Return the next tech for sale that the player doesn't already have.
+// Returns NULL if the player has all the techs.
+static const TechSaleData*
+GetNextTechForSale (void)
+{
+	size_t i = 0;
+	for (i = 0; i < NUM_TECH_ITEMS; ++i)
+	{
+		if (!HasTech (tech_sale_catalog[i].techId))
+			return &tech_sale_catalog[i];
+	}
+
+	return NULL;
+}
+
+///////////End Melnorme Sales Section//////////////////
+
 static StatMsgMode prevMsgMode;
 
 static void DoFirstMeeting (RESPONSE_REF R);
@@ -247,6 +529,51 @@ ShipWorth (void)
 static COUNT rescue_fuel;
 static SIS_STATE SIS_copy;
 
+// Extract method to return the response string index
+// for stripping a given module.
+static int 
+GetStripModuleRef (int moduleID)
+{
+	switch (moduleID)
+	{
+		case PLANET_LANDER:       return LANDERS;
+		case FUSION_THRUSTER:     return THRUSTERS;
+		case TURNING_JETS:        return JETS;
+		case CREW_POD:            return PODS;
+		case STORAGE_BAY:         return BAYS;
+		case DYNAMO_UNIT:         return DYNAMOS;
+		case SHIVA_FURNACE:       return FURNACES;
+		case GUN_WEAPON:          return GUNS;
+		case BLASTER_WEAPON:      return BLASTERS;
+		case CANNON_WEAPON:       return CANNONS;
+		case TRACKING_SYSTEM:     return TRACKERS;
+		case ANTIMISSILE_DEFENSE: return DEFENSES;
+		// If a modder has added new modules, should it really
+		// be a fatal error if the Melnorme don't know about
+		// them?
+		default:
+			assert (0 && "Unknown module");
+	}
+	return 0;
+}
+
+static DWORD
+getStripRandomSeed (void)
+{
+	DWORD x, y;
+	// We truncate the location because encounters move the ship slightly in
+	// HSpace, and throw some other relatively immutable values in the mix to
+	// vary the deal when stuck at the same general location again.
+	// It is still possible but unlikely for encounters to move the ship into
+	// another truncation sector so the player could choose from 2 deals.
+	x = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x)) / 100;
+	y = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y)) / 100;
+	// prime numbers help randomness
+	return y * 1013 + x + GLOBAL_SIS (NumLanders)
+			+ GLOBAL_SIS (ModuleSlots[1]) + GLOBAL_SIS (ModuleSlots[4])
+			+ GLOBAL_SIS (ModuleSlots[7]) + GLOBAL_SIS (ModuleSlots[10]);
+}
+
 static BOOLEAN
 StripShip (COUNT fuel_required)
 {
@@ -262,9 +589,7 @@ StripShip (COUNT fuel_required)
 	if (fuel_required == 0)
 	{
 		GlobData.SIS_state = SIS_copy;
-		LockMutex (GraphicsLock);
 		DeltaSISGauges (UNDEFINED_DELTA, rescue_fuel, UNDEFINED_DELTA);
-		UnlockMutex (GraphicsLock);
 	}
 	else if (fuel_required == (COUNT)~0)
 	{
@@ -288,9 +613,7 @@ StripShip (COUNT fuel_required)
 				GLOBAL_SIS (ModuleSlots[i]) = EMPTY_SLOT + 2;
 		}
 
-		LockMutex (GraphicsLock);
 		DeltaSISGauges (UNDEFINED_DELTA, UNDEFINED_DELTA, UNDEFINED_DELTA);
-		UnlockMutex (GraphicsLock);
 	}
 	else if (fuel_required)
 	{
@@ -300,6 +623,15 @@ StripShip (COUNT fuel_required)
 		BYTE module_count[BOMB_MODULE_0];
 		BYTE slot;
 		DWORD capacity;
+		RandomContext *rc;
+		
+		// Bug #567
+		// In order to offer the same deal each time if it is refused, we seed
+		// the random number generator with our location, thus making the deal
+		// a repeatable pseudo-random function of where we got stuck and what,
+		// exactly, is on our ship.
+		rc = RandomContext_New();
+		RandomContext_SeedRandom (rc, getStripRandomSeed ());
 
 		SIS_copy = GlobData.SIS_state;
 		for (i = PLANET_LANDER; i < BOMB_MODULE_0; ++i)
@@ -343,7 +675,7 @@ StripShip (COUNT fuel_required)
 		{
 			DWORD rand_val;
 
-			rand_val = TFB_Random ();
+			rand_val = RandomContext_Random (rc);
 			switch (which_module = LOBYTE (LOWORD (rand_val)) % (CREW_POD + 1))
 			{
 				case PLANET_LANDER:
@@ -393,13 +725,12 @@ StripShip (COUNT fuel_required)
 			++module_count[which_module];
 			total += GLOBAL (ModuleCost[which_module]);
 		}
+		RandomContext_Delete (rc);
 
 		if (total == 0)
 		{
 			NPCPhrase (CHARITY);
-			LockMutex (GraphicsLock);
 			DeltaSISGauges (0, fuel_required, 0);
-			UnlockMutex (GraphicsLock);
 			return (FALSE);
 		}
 		else
@@ -414,54 +745,10 @@ StripShip (COUNT fuel_required)
 			{
 				if (module_count[i])
 				{
-					RESPONSE_REF pStr = 0;
-
-					switch (i)
-					{
-						case PLANET_LANDER:
-							pStr = LANDERS;
-							break;
-						case FUSION_THRUSTER:
-							pStr = THRUSTERS;
-							break;
-						case TURNING_JETS:
-							pStr = JETS;
-							break;
-						case CREW_POD:
-							pStr = PODS;
-							break;
-						case STORAGE_BAY:
-							pStr = BAYS;
-							break;
-						case DYNAMO_UNIT:
-							pStr = DYNAMOS;
-							break;
-						case SHIVA_FURNACE:
-							pStr = FURNACES;
-							break;
-						case GUN_WEAPON:
-							pStr = GUNS;
-							break;
-						case BLASTER_WEAPON:
-							pStr = BLASTERS;
-							break;
-						case CANNON_WEAPON:
-							pStr = CANNONS;
-							break;
-						case TRACKING_SYSTEM:
-							pStr = TRACKERS;
-							break;
-						case ANTIMISSILE_DEFENSE:
-							pStr = DEFENSES;
-							break;
-						default:
-							assert (0 && "Unknown module");
-					}
-
 					if (i == end_mod && i != beg_mod)
 						NPCPhrase (END_LIST_WITH_AND);
 					NPCPhrase (ENUMERATE_ONE + (module_count[i] - 1));
-					NPCPhrase (pStr);
+					NPCPhrase (GetStripModuleRef (i));
 				}
 			}
 		}
@@ -480,14 +767,14 @@ ExitConversation (RESPONSE_REF R)
 		NPCPhrase (YOU_GIVE_US_NO_CHOICE);
 
 		SET_GAME_STATE (MELNORME_ANGER, 1);
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, so_we_can_attack))
 	{
 		NPCPhrase (DECEITFUL_HUMAN);
 
 		SET_GAME_STATE (MELNORME_ANGER, 2);
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, bye_melnorme_slightly_angry))
 		NPCPhrase (MELNORME_SLIGHTLY_ANGRY_GOODBYE);
@@ -509,7 +796,7 @@ ExitConversation (RESPONSE_REF R)
 		NPCPhrase (OK_FIGHT_SOME_MORE);
 
 		SET_GAME_STATE (MELNORME_ANGER, 3);
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, bye_melnorme_pissed_off))
 		NPCPhrase (MELNORME_PISSED_OFF_GOODBYE);
@@ -517,7 +804,7 @@ ExitConversation (RESPONSE_REF R)
 	{
 		NPCPhrase (WE_FIGHT_AGAIN);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, you_hate_us_so_we_go_away))
 		NPCPhrase (HATE_YOU_GOODBYE);
@@ -569,183 +856,108 @@ DoRescue (RESPONSE_REF R)
 	}
 }
 
-static COUNT
+// Extract method for getting the player's current credits.
+static COUNT 
+GetAvailableCredits (void)
+{
+	return MAKE_WORD (GET_GAME_STATE (MELNORME_CREDIT0),
+			GET_GAME_STATE (MELNORME_CREDIT1));
+}
+
+// Extract method for setting the player's current credits.
+static void
+SetAvailableCredits (COUNT credits)
+{
+	SET_GAME_STATE (MELNORME_CREDIT0, LOBYTE (credits));
+	SET_GAME_STATE (MELNORME_CREDIT1, HIBYTE (credits));
+}
+
+// Now returns whether the purchase succeeded instead of the remaining
+// credit balance.  Use GetAvailableCredits() to get the latter.
+static bool
 DeltaCredit (SIZE delta_credit)
 {
-	COUNT Credit;
+	COUNT Credit = GetAvailableCredits ();
 
-	Credit = MAKE_WORD (
-			GET_GAME_STATE (MELNORME_CREDIT0),
-			GET_GAME_STATE (MELNORME_CREDIT1)
-			);
+	// Can they afford it?
 	if ((int)delta_credit >= 0 || ((int)(-delta_credit) <= (int)(Credit)))
 	{
 		Credit += delta_credit;
-		SET_GAME_STATE (MELNORME_CREDIT0, LOBYTE (Credit));
-		SET_GAME_STATE (MELNORME_CREDIT1, HIBYTE (Credit));
-		LockMutex (GraphicsLock);
+		SetAvailableCredits (Credit);
 		DrawStatusMessage (NULL);
-		UnlockMutex (GraphicsLock);
-	}
-	else
-	{
-		NPCPhrase (NEED_MORE_CREDIT0);
-		NPCNumber (-delta_credit - Credit, NULL);
-		NPCPhrase (NEED_MORE_CREDIT1);
+		return true;
 	}
+
+	// Fail
+	NPCPhrase (NEED_MORE_CREDIT0);
+	NPCNumber (-delta_credit - Credit, NULL);
+	NPCPhrase (NEED_MORE_CREDIT1);
 	
-	return (Credit);
+	return false;
 }
 
+
+// Extract methods to process the giving of various bits of information to the
+// player.  Ideally, we'd want to merge these three into a single parameterized
+// function, but the nature of the XXX_GAME_STATE() code makes that tricky.
 static void
 CurrentEvents (void)
 {
-	BYTE stack;
-
-	stack = GET_GAME_STATE (MELNORME_EVENTS_INFO_STACK);
-	switch (stack++)
-	{
-		case 0:
-			NPCPhrase (OK_BUY_EVENT_1);
-			break;
-		case 1:
-			NPCPhrase (OK_BUY_EVENT_2);
-			break;
-		case 2:
-			NPCPhrase (OK_BUY_EVENT_3);
-			break;
-		case 3:
-			NPCPhrase (OK_BUY_EVENT_4);
-			break;
-		case 4:
-			NPCPhrase (OK_BUY_EVENT_5);
-			break;
-		case 5:
-			NPCPhrase (OK_BUY_EVENT_6);
-			break;
-		case 6:
-			NPCPhrase (OK_BUY_EVENT_7);
-			break;
-		case 7:
-			NPCPhrase (OK_BUY_EVENT_8);
-			break;
-	}
-	SET_GAME_STATE (MELNORME_EVENTS_INFO_STACK, stack);
+	BYTE stack = GET_GAME_STATE (MELNORME_EVENTS_INFO_STACK);
+	const int phraseId = GetLineSafe (ok_buy_event_lines, stack);
+	NPCPhrase (phraseId);
+	SET_GAME_STATE (MELNORME_EVENTS_INFO_STACK, stack + 1);
 }
 
 static void
 AlienRaces (void)
 {
-	BYTE stack;
-
-	stack = GET_GAME_STATE (MELNORME_ALIEN_INFO_STACK);
-	switch (stack++)
+	BYTE stack = GET_GAME_STATE (MELNORME_ALIEN_INFO_STACK);
+	const int phraseId = GetLineSafe (ok_buy_alien_race_lines, stack);
+	// Two pieces of alien knowledge trigger state changes.
+	switch (phraseId)
 	{
-		case 0:
-			NPCPhrase (OK_BUY_ALIEN_RACE_1);
-			break;
-		case 1:
-			NPCPhrase (OK_BUY_ALIEN_RACE_2);
-			break;
-		case 2:
-			NPCPhrase (OK_BUY_ALIEN_RACE_3);
-			break;
-		case 3:
-			NPCPhrase (OK_BUY_ALIEN_RACE_4);
-			break;
-		case 4:
-			NPCPhrase (OK_BUY_ALIEN_RACE_5);
-			break;
-		case 5:
-			NPCPhrase (OK_BUY_ALIEN_RACE_6);
-			break;
-		case 6:
-			NPCPhrase (OK_BUY_ALIEN_RACE_7);
-			break;
-		case 7:
-			NPCPhrase (OK_BUY_ALIEN_RACE_8);
-			break;
-		case 8:
-			NPCPhrase (OK_BUY_ALIEN_RACE_9);
-			break;
-		case 9:
-			NPCPhrase (OK_BUY_ALIEN_RACE_10);
-			break;
-		case 10:
-			NPCPhrase (OK_BUY_ALIEN_RACE_11);
-			break;
-		case 11:
-			NPCPhrase (OK_BUY_ALIEN_RACE_12);
-			break;
-		case 12:
-			NPCPhrase (OK_BUY_ALIEN_RACE_13);
-			break;
-		case 13:
-			NPCPhrase (OK_BUY_ALIEN_RACE_14);
+		case OK_BUY_ALIEN_RACE_14:
 			if (!GET_GAME_STATE (FOUND_PLUTO_SPATHI))
 			{
 				SET_GAME_STATE (KNOW_SPATHI_PASSWORD, 1);
 				SET_GAME_STATE (SPATHI_HOME_VISITS, 7);
 			}
 			break;
-		case 14:
-			NPCPhrase (OK_BUY_ALIEN_RACE_15);
+		case OK_BUY_ALIEN_RACE_15:
 			if (GET_GAME_STATE (KNOW_ABOUT_SHATTERED) < 2)
 			{
 				SET_GAME_STATE (KNOW_ABOUT_SHATTERED, 2);
 			}
 			SET_GAME_STATE (KNOW_SYREEN_WORLD_SHATTERED, 1);
 			break;
-		case 15:
-			NPCPhrase (OK_BUY_ALIEN_RACE_16);
-			break;
 	}
-	SET_GAME_STATE (MELNORME_ALIEN_INFO_STACK, stack);
+	NPCPhrase (phraseId);
+	SET_GAME_STATE (MELNORME_ALIEN_INFO_STACK, stack + 1);
 }
 
 static void
 History (void)
 {
-	BYTE stack;
+	BYTE stack = GET_GAME_STATE (MELNORME_HISTORY_INFO_STACK);
+	const int phraseId = GetLineSafe (ok_buy_history_lines, stack);
+	NPCPhrase (phraseId);
+	SET_GAME_STATE (MELNORME_HISTORY_INFO_STACK, stack + 1);
+}
 
-	stack = GET_GAME_STATE (MELNORME_HISTORY_INFO_STACK);
-	switch (stack++)
-	{
-		case 0:
-			NPCPhrase (OK_BUY_HISTORY_1);
-			break;
-		case 1:
-			NPCPhrase (OK_BUY_HISTORY_2);
-			break;
-		case 2:
-			NPCPhrase (OK_BUY_HISTORY_3);
-			break;
-		case 3:
-			NPCPhrase (OK_BUY_HISTORY_4);
-			break;
-		case 4:
-			NPCPhrase (OK_BUY_HISTORY_5);
-			break;
-		case 5:
-			NPCPhrase (OK_BUY_HISTORY_6);
-			break;
-		case 6:
-			NPCPhrase (OK_BUY_HISTORY_7);
-			break;
-		case 7:
-			NPCPhrase (OK_BUY_HISTORY_8);
-			break;
-		case 8:
-			NPCPhrase (OK_BUY_HISTORY_9);
-			break;
-	}
-	SET_GAME_STATE (MELNORME_HISTORY_INFO_STACK, stack);
+// extract method to tell if we have any information left to sell to the player.
+static bool AnyInfoLeftToSell (void)
+{
+	return GET_GAME_STATE (MELNORME_EVENTS_INFO_STACK) < NUM_EVENT_ITEMS
+			|| GET_GAME_STATE (MELNORME_ALIEN_INFO_STACK) < NUM_ALIEN_RACE_ITEMS
+			|| GET_GAME_STATE (MELNORME_HISTORY_INFO_STACK) < NUM_HISTORY_ITEMS;
 }
 
 static void NatureOfConversation (RESPONSE_REF R);
 
 static BYTE AskedToBuy;
 
+
 static void
 DoBuy (RESPONSE_REF R)
 {
@@ -754,10 +966,7 @@ DoBuy (RESPONSE_REF R)
 	BYTE slot;
 	DWORD capacity;
 
-	credit = MAKE_WORD (
-			GET_GAME_STATE (MELNORME_CREDIT0),
-			GET_GAME_STATE (MELNORME_CREDIT1)
-			);
+	credit = GetAvailableCredits ();
 
 	capacity = FUEL_RESERVE;
 	slot = NUM_MODULE_SLOTS - 1;
@@ -774,6 +983,7 @@ DoBuy (RESPONSE_REF R)
 		}
 	} while (slot--);
 
+	// If they're out of credits, educate them on how commerce works.
 	if (credit == 0)
 	{
 		AskedToBuy = TRUE;
@@ -826,14 +1036,12 @@ DoBuy (RESPONSE_REF R)
 				NPCPhrase (GOT_FUEL);
 
 				f = (DWORD)needed_credit * FUEL_TANK_SCALE;
-				LockMutex (GraphicsLock);
 				while (f > 0x3FFFL)
 				{
 					DeltaSISGauges (0, 0x3FFF, 0);
 					f -= 0x3FFF;
 				}
 				DeltaSISGauges (0, (SIZE)f, 0);
-				UnlockMutex (GraphicsLock);
 			}
 			needed_credit *= (BIO_CREDIT_VALUE / 2);
 		}
@@ -856,223 +1064,43 @@ TryFuelAgain:
 	else if (PLAYER_SAID (R, buy_technology)
 			|| PLAYER_SAID (R, buy_new_tech))
 	{
-		BYTE stack;
+		// Note that this code no longer uses the MELNORME_TECH_STACK state
+		// buts, as they're not needed; we can tell what technologies the
+		// player has by using the technology API above.  This opens the
+		// possibility of the player acquiring tech from someplace other than
+		// the Melnorme.
+		const TechSaleData* nextTech;
 
-		needed_credit = 0;
-		if (PLAYER_SAID (R, buy_technology))
+		// If it's our first time, give an introduction.
+		if (!GET_GAME_STATE (MELNORME_TECH_PROCEDURE))
 		{
-			if (!GET_GAME_STATE (MELNORME_TECH_PROCEDURE))
-			{
-				NPCPhrase (BUY_NEW_TECH_INTRO);
-				SET_GAME_STATE (MELNORME_TECH_PROCEDURE, 1);
-			}
-			stack = 0;
+			NPCPhrase (BUY_NEW_TECH_INTRO);
+			SET_GAME_STATE (MELNORME_TECH_PROCEDURE, 1);
 		}
-		else
+
+		// Did the player just attempt to buy a tech?
+		if (PLAYER_SAID (R, buy_new_tech))
 		{
-			RESPONSE_REF pStr = 0;
+			nextTech = GetNextTechForSale ();
+			if (!nextTech)
+				goto BuyBuyBuy; // No tech left to buy
 
-			stack = GET_GAME_STATE (MELNORME_TECH_STACK);
-			switch (stack)
-			{
-				case 0:
-					pStr = OK_BUY_NEW_TECH_1;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 1:
-					pStr = OK_BUY_NEW_TECH_2;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 2:
-					pStr = OK_BUY_NEW_TECH_3;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 3:
-					pStr = OK_BUY_NEW_TECH_4;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 4:
-					pStr = OK_BUY_NEW_TECH_5;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 5:
-					pStr = OK_BUY_NEW_TECH_6;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 6:
-					pStr = OK_BUY_NEW_TECH_7;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 7:
-					pStr = OK_BUY_NEW_TECH_8;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 8:
-					pStr = OK_BUY_NEW_TECH_9;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 9:
-					pStr = OK_BUY_NEW_TECH_10;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 10:
-					pStr = OK_BUY_NEW_TECH_11;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 11:
-					pStr = OK_BUY_NEW_TECH_12;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 12:
-					pStr = OK_BUY_NEW_TECH_13;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				default:
-					assert (0 && "Unknown tech");
-			}
-			if ((int)needed_credit > (int)credit)
-			{
-				DeltaCredit (-needed_credit);
-				goto BuyBuyBuy;
-			}
-			else
-			{
-				++stack;
-				NPCPhrase (pStr);
-				DeltaCredit (-needed_credit);
-			}
+			if (!DeltaCredit (-nextTech->price))
+				goto BuyBuyBuy;  // Can't afford it
+
+			// Make the sale
+			GrantTech (nextTech->techId);
+			NPCPhrase (nextTech->sold_line);
 		}
 
-		switch (stack)
+		nextTech = GetNextTechForSale ();
+		if (!nextTech)
 		{
-			case 0:
-				if (GLOBAL (ModuleCost[BLASTER_WEAPON]) == 0)
-				{
-					NPCPhrase (NEW_TECH_1);
-					break;
-				}
-				++stack;
-			case 1:
-				GLOBAL (ModuleCost[BLASTER_WEAPON]) =
-						4000 / MODULE_COST_SCALE;
-				if (!GET_GAME_STATE (IMPROVED_LANDER_SPEED))
-				{
-					NPCPhrase (NEW_TECH_2);
-					break;
-				}
-				++stack;
-			case 2:
-				SET_GAME_STATE (IMPROVED_LANDER_SPEED, 1);
-				if (GLOBAL (ModuleCost[ANTIMISSILE_DEFENSE]) == 0)
-				{
-					NPCPhrase (NEW_TECH_3);
-					break;
-				}
-				++stack;
-			case 3:
-				GLOBAL (ModuleCost[ANTIMISSILE_DEFENSE]) =
-						4000 / MODULE_COST_SCALE;
-				if (!(GET_GAME_STATE (LANDER_SHIELDS)
-						& (1 << BIOLOGICAL_DISASTER)))
-				{
-					NPCPhrase (NEW_TECH_4);
-					break;
-				}
-				++stack;
-			case 4:
-				credit = GET_GAME_STATE (LANDER_SHIELDS)
-						| (1 << BIOLOGICAL_DISASTER);
-				SET_GAME_STATE (LANDER_SHIELDS, credit);
-				if (!GET_GAME_STATE (IMPROVED_LANDER_CARGO))
-				{
-					NPCPhrase (NEW_TECH_5);
-					break;
-				}
-				++stack;
-			case 5:
-				SET_GAME_STATE (IMPROVED_LANDER_CARGO, 1);
-				if (GLOBAL (ModuleCost[HIGHEFF_FUELSYS]) == 0)
-				{
-					NPCPhrase (NEW_TECH_6);
-					break;
-				}
-				++stack;
-			case 6:
-				GLOBAL (ModuleCost[HIGHEFF_FUELSYS]) =
-						1000 / MODULE_COST_SCALE;
-				if (!GET_GAME_STATE (IMPROVED_LANDER_SHOT))
-				{
-					NPCPhrase (NEW_TECH_7);
-					break;
-				}
-				++stack;
-			case 7:
-				SET_GAME_STATE (IMPROVED_LANDER_SHOT, 1);
-				if (!(GET_GAME_STATE (LANDER_SHIELDS)
-						& (1 << EARTHQUAKE_DISASTER)))
-				{
-					NPCPhrase (NEW_TECH_8);
-					break;
-				}
-				++stack;
-			case 8:
-				credit = GET_GAME_STATE (LANDER_SHIELDS)
-						| (1 << EARTHQUAKE_DISASTER);
-				SET_GAME_STATE (LANDER_SHIELDS, credit);
-				if (GLOBAL (ModuleCost[TRACKING_SYSTEM]) == 0)
-				{
-					NPCPhrase (NEW_TECH_9);
-					break;
-				}
-				++stack;
-			case 9:
-				GLOBAL (ModuleCost[TRACKING_SYSTEM]) =
-						5000 / MODULE_COST_SCALE;
-				if (!(GET_GAME_STATE (LANDER_SHIELDS)
-						& (1 << LIGHTNING_DISASTER)))
-				{
-					NPCPhrase (NEW_TECH_10);
-					break;
-				}
-				++stack;
-			case 10:
-				credit = GET_GAME_STATE (LANDER_SHIELDS)
-						| (1 << LIGHTNING_DISASTER);
-				SET_GAME_STATE (LANDER_SHIELDS, credit);
-				if (!(GET_GAME_STATE (LANDER_SHIELDS)
-						& (1 << LAVASPOT_DISASTER)))
-				{
-					NPCPhrase (NEW_TECH_11);
-					break;
-				}
-				++stack;
-			case 11:
-				credit = GET_GAME_STATE (LANDER_SHIELDS)
-						| (1 << LAVASPOT_DISASTER);
-				SET_GAME_STATE (LANDER_SHIELDS, credit);
-				if (GLOBAL (ModuleCost[CANNON_WEAPON]) == 0)
-				{
-					NPCPhrase (NEW_TECH_12);
-					break;
-				}
-				++stack;
-			case 12:
-				GLOBAL (ModuleCost[CANNON_WEAPON]) =
-						6000 / MODULE_COST_SCALE;
-				if (GLOBAL (ModuleCost[SHIVA_FURNACE]) == 0)
-				{
-					NPCPhrase (NEW_TECH_13);
-					break;
-				}
-				++stack;
-			case 13:
-				GLOBAL (ModuleCost[SHIVA_FURNACE]) =
-						4000 / MODULE_COST_SCALE;
-				NPCPhrase (NEW_TECH_ALL_GONE);
-				SET_GAME_STATE (MELNORME_TECH_STACK, stack);
-				goto BuyBuyBuy;
+			NPCPhrase (NEW_TECH_ALL_GONE);
+			goto BuyBuyBuy; // No tech left to buy
 		}
-		SET_GAME_STATE (MELNORME_TECH_STACK, stack);
+
+		NPCPhrase (nextTech->sale_line);
 
 		Response (buy_new_tech, DoBuy);
 		Response (no_buy_new_tech, DoBuy);
@@ -1082,42 +1110,33 @@ TryFuelAgain:
 			|| PLAYER_SAID (R, buy_alien_races)
 			|| PLAYER_SAID (R, buy_history))
 	{
-		needed_credit = 0;
-		if (PLAYER_SAID (R, buy_info))
+		if (!GET_GAME_STATE (MELNORME_INFO_PROCEDURE))
 		{
-			if (GET_GAME_STATE (MELNORME_INFO_PROCEDURE))
-				NPCPhrase (OK_BUY_INFO);
-			else
-			{
-				NPCPhrase (BUY_INFO_INTRO);
-				SET_GAME_STATE (MELNORME_INFO_PROCEDURE, 1);
-			}
+			NPCPhrase (BUY_INFO_INTRO);
+			SET_GAME_STATE (MELNORME_INFO_PROCEDURE, 1);
+		}
+		else if (PLAYER_SAID (R, buy_info))
+		{
+			NPCPhrase (OK_BUY_INFO);
 		}
 		else
 		{
 #define INFO_COST 75
-			needed_credit = INFO_COST;
-			if ((int)credit >= (int)needed_credit)
-			{
-				if (PLAYER_SAID (R, buy_current_events))
-					CurrentEvents ();
-				else if (PLAYER_SAID (R, buy_alien_races))
-					AlienRaces ();
-				else /* if (R == buy_history) */
-					History ();
-			}
-
-			DeltaCredit (-needed_credit);
-			if (GET_GAME_STATE (MELNORME_EVENTS_INFO_STACK) < NUM_EVENT_ITEMS
-					 || GET_GAME_STATE (MELNORME_ALIEN_INFO_STACK) < NUM_ALIEN_RACE_ITEMS
-					 || GET_GAME_STATE (MELNORME_HISTORY_INFO_STACK) < NUM_HISTORY_ITEMS)
-			{
-			}
-			else
-			{
-				NPCPhrase (INFO_ALL_GONE);
+			if (!DeltaCredit (-INFO_COST))
 				goto BuyBuyBuy;
-			}
+
+			if (PLAYER_SAID (R, buy_current_events))
+				CurrentEvents ();
+			else if (PLAYER_SAID (R, buy_alien_races))
+				AlienRaces ();
+			else if (PLAYER_SAID (R, buy_history))
+				History ();
+		}
+
+		if (!AnyInfoLeftToSell ())
+		{
+			NPCPhrase (INFO_ALL_GONE);
+			goto BuyBuyBuy;
 		}
 
 		if (GET_GAME_STATE (MELNORME_EVENTS_INFO_STACK) < NUM_EVENT_ITEMS)
@@ -1142,12 +1161,11 @@ TryFuelAgain:
 BuyBuyBuy:
 		if (GLOBAL_SIS (FuelOnBoard) < capacity)
 			Response (buy_fuel, DoBuy);
-		if (GET_GAME_STATE (MELNORME_TECH_STACK) < NUM_TECH_ITEMS)
+		if (GetNextTechForSale ())
 			Response (buy_technology, DoBuy);
-		if (GET_GAME_STATE (MELNORME_ALIEN_INFO_STACK) < NUM_ALIEN_RACE_ITEMS
-				|| GET_GAME_STATE (MELNORME_HISTORY_INFO_STACK) < NUM_HISTORY_ITEMS
-				|| GET_GAME_STATE (MELNORME_EVENTS_INFO_STACK) < NUM_EVENT_ITEMS)
+		if (AnyInfoLeftToSell ())
 			Response (buy_info, DoBuy);
+
 		Response (done_buying, NatureOfConversation);
 		Response (be_leaving_now, ExitConversation);
 	}
@@ -1222,9 +1240,7 @@ DoSell (RESPONSE_REF R)
 			} while (GLOBAL_SIS (TotalBioMass));
 			SleepThread (ONE_SECOND / 2);
 
-			LockMutex (GraphicsLock);
 			ClearSISRect (DRAW_SIS_DISPLAY);
-			UnlockMutex (GraphicsLock);
 		}
 		else /* if (R == sell_rainbow_locations) */
 		{
@@ -1267,6 +1283,7 @@ DoSell (RESPONSE_REF R)
 	}
 }
 
+
 static void
 NatureOfConversation (RESPONSE_REF R)
 {
@@ -1280,46 +1297,15 @@ NatureOfConversation (RESPONSE_REF R)
 		R = 0;
 	}
 
-	Credit = DeltaCredit (0);
+	// Draw credits display
+	DeltaCredit (0);
+	Credit = GetAvailableCredits ();
 	if (R == 0)
 	{
-		BYTE stack;
-
-		stack = (BYTE)(GET_GAME_STATE (MELNORME_YACK_STACK2) - 5);
-		switch (stack++)
-		{
-			case 0:
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_1);
-				break;
-			case 1:
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_2);
-				break;
-			case 2:
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_3);
-				break;
-			case 3:
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_4);
-				break;
-			case 4:
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_5);
-				break;
-			case 5:
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_6);
-				break;
-			case 6:
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_7);
-				break;
-			case 7:
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_8);
-				break;
-			case 8:
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_9);
-				break;
-			default:
-				--stack;
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_10);
-				break;
-		}
+		BYTE stack = GET_GAME_STATE (MELNORME_YACK_STACK2) - 5;
+		NPCPhrase (GetLineSafe (hello_and_down_to_business_lines, stack));
+		if (stack < (NUM_HELLO_LINES - 1))
+			++stack;
 		SET_GAME_STATE (MELNORME_YACK_STACK2, stack + 5);
 	}
 
@@ -1352,11 +1338,11 @@ NatureOfConversation (RESPONSE_REF R)
 		{
 				/* Melnorme reports any news and turns purple */
 			NPCPhrase (BUY_OR_SELL);
-			AlienTalkSegue(1);
+			AlienTalkSegue (1);
 			XFormColorMap (GetColorMapAddress (
 					SetAbsColorMapIndex (CommData.AlienColorMap, 1)
 					), ONE_SECOND / 2);
-			AlienTalkSegue((COUNT)~0);
+			AlienTalkSegue ((COUNT)~0);
 		}
 		else if (PLAYER_SAID (R, why_turned_purple))
 		{
@@ -1394,32 +1380,10 @@ NatureOfConversation (RESPONSE_REF R)
 		}
 		else
 		{
-			BYTE num_rescues;
+			BYTE num_rescues = GET_GAME_STATE (MELNORME_RESCUE_COUNT);
+			NPCPhrase (GetLineSafe (rescue_lines, num_rescues));
 
-			num_rescues = GET_GAME_STATE (MELNORME_RESCUE_COUNT);
-			switch (num_rescues)
-			{
-				case 0:
-					NPCPhrase (RESCUE_EXPLANATION);
-					break;
-				case 1:
-					NPCPhrase (RESCUE_AGAIN_1);
-					break;
-				case 2:
-					NPCPhrase (RESCUE_AGAIN_2);
-					break;
-				case 3:
-					NPCPhrase (RESCUE_AGAIN_3);
-					break;
-				case 4:
-					NPCPhrase (RESCUE_AGAIN_4);
-					break;
-				case 5:
-					NPCPhrase (RESCUE_AGAIN_5);
-					break;
-			 }
-
-			if (num_rescues < 5)
+			if (num_rescues < NUM_RESCUE_LINES - 1)
 			{
 				++num_rescues;
 				SET_GAME_STATE (MELNORME_RESCUE_COUNT, num_rescues);
@@ -1509,18 +1473,8 @@ yack0_respond (void)
 	switch (GET_GAME_STATE (MELNORME_YACK_STACK0))
 	{
 		case 0:
-		{
-			UNICODE buf[ALLIANCE_NAME_BUFSIZE];
-
-			GetAllianceName (buf, name_1);
-			construct_response (
-					shared_phrase_buf,
-					we_are_from_alliance0,
-					buf,
-					(RESPONSE_REF)-1);
-			DoResponsePhrase (we_are_from_alliance0, DoFirstMeeting, shared_phrase_buf);
+			Response (we_are_from_alliance, DoFirstMeeting);
 			break;
-		}
 		case 1:
 			Response (how_know, DoFirstMeeting);
 			break;
@@ -1594,7 +1548,7 @@ DoFirstMeeting (RESPONSE_REF R)
 		}
 		SET_GAME_STATE (MELNORME_BUSINESS_COUNT, business_count);
 	}
-	else if (PLAYER_SAID (R, we_are_from_alliance0))
+	else if (PLAYER_SAID (R, we_are_from_alliance))
 	{
 		SET_GAME_STATE (MELNORME_YACK_STACK0, 1);
 		NPCPhrase (KNOW_OF_YOU);
@@ -1855,17 +1809,16 @@ Intro (void)
 static COUNT
 uninit_melnorme (void)
 {
+	luaUqm_comm_uninit ();
 	return 0;
 }
 
 static void
 post_melnorme_enc (void)
 {
-	LockMutex (GraphicsLock);
 	if (prevMsgMode != SMM_UNDEFINED)
 		SetStatusMessageMode (prevMsgMode);
 	DrawStatusMessage (NULL);
-	UnlockMutex (GraphicsLock);
 }
 
 LOCDATA*
@@ -1877,6 +1830,10 @@ init_melnorme_comm (void)
 	melnorme_desc.post_encounter_func = post_melnorme_enc;
 	melnorme_desc.uninit_encounter_func = uninit_melnorme;
 
+	luaUqm_comm_init (NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	melnorme_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
 	melnorme_desc.AlienTextBaseline.y = 0;
 	melnorme_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
@@ -1886,7 +1843,7 @@ init_melnorme_comm (void)
 
 	prevMsgMode = SMM_UNDEFINED;
 
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 	AskedToBuy = FALSE;
 	retval = &melnorme_desc;
 
diff -ruNp src.orig/uqm/comm/melnorm/resinst.h src/uqm/comm/melnorm/resinst.h
--- src.orig/uqm/comm/melnorm/resinst.h	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/melnorm/resinst.h	2017-11-21 19:39:53 -0600
@@ -1,5 +1,10 @@
-#define MELNORME_PMAP_ANIM "comm.melnorme.graphics"
-#define MELNORME_FONT "comm.melnorme.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define MELNORME_COLOR_MAP "comm.melnorme.colortable"
 #define MELNORME_CONVERSATION_PHRASES "comm.melnorme.dialogue"
+#define MELNORME_FONT "comm.melnorme.font"
 #define MELNORME_MUSIC "comm.melnorme.music"
+#define MELNORME_PMAP_ANIM "comm.melnorme.graphics"
+#define MELNORME_SCRIPT "comm.melnorme.script"
diff -ruNp src.orig/uqm/comm/melnorm/strings.h src/uqm/comm/melnorm/strings.h
--- src.orig/uqm/comm/melnorm/strings.h	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/melnorm/strings.h	2017-11-21 19:39:53 -0600
@@ -254,7 +254,7 @@ enum
 	OK_BUY_NEW_TECH_13,
 	CHARITY,
 	NEW_TECH_ALL_GONE,
-	we_are_from_alliance0,
+	we_are_from_alliance,
 	STRIP_HEAD,
 	LANDERS,
 	THRUSTERS,
@@ -271,8 +271,7 @@ enum
 	name_1,
 	name_2,
 	name_3,
-	name_40,
-	name_41,
+	name_4,
 	ENUMERATE_ONE,
 	ENUMERATE_TWO,
 	ENUMERATE_THREE,
diff -ruNp src.orig/uqm/comm/mycon/Makeinfo src/uqm/comm/mycon/Makeinfo
--- src.orig/uqm/comm/mycon/Makeinfo	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/mycon/Makeinfo	2017-11-21 19:39:53 -0600
@@ -1 +1,2 @@
 uqm_CFILES="myconc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.orig/uqm/comm/mycon/myconc.c src/uqm/comm/mycon/myconc.c
--- src.orig/uqm/comm/mycon/myconc.c	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/mycon/myconc.c	2017-11-21 19:39:53 -0600
@@ -245,7 +245,7 @@ DoRamble (RESPONSE_REF R)
 static void
 CombatIsInevitable (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 1);
+	setSegue (Segue_hostile);
 
 	if (PLAYER_SAID (R, bye_space))
 		NPCPhrase (BYE_AND_DIE_SPACE);
@@ -257,7 +257,7 @@ CombatIsInevitable (RESPONSE_REF R)
 	{
 		NPCPhrase (GOODBYE_SUN_DEVICE);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
@@ -340,7 +340,7 @@ TrickMycon (RESPONSE_REF R)
 	{
 		NPCPhrase (WE_GO_TO_IMPLANT);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		SET_GAME_STATE (MYCON_FELL_FOR_AMBUSH, 1);
 		AddEvent (RELATIVE_EVENT, 0, 0, 0, ADVANCE_MYCON_MISSION);
 	}
@@ -371,7 +371,7 @@ NormalMycon (RESPONSE_REF R)
 		DoRamble (R);
 		NPCPhrase (RAMBLE_TAIL);
 
-		DISABLE_PHRASE (RESPONSE_TO_REF (R));
+		DISABLE_PHRASE (R);
 	}
 
 	if ((BYTE)TFB_Random () < 256 * 30 / 100)
@@ -505,13 +505,13 @@ Intro (void)
 		}
 		SET_GAME_STATE (MYCON_VISITS, NumVisits);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (GET_GAME_STATE (MYCON_KNOW_AMBUSH))
 	{
 		NPCPhrase (DIE_LIAR);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 6))
 	{
@@ -631,11 +631,11 @@ init_mycon_comm (void)
 
 	if (LOBYTE (GLOBAL (CurrentActivity)) != WON_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	retval = &mycon_desc;
 
diff -ruNp src.orig/uqm/comm/mycon/resinst.h src/uqm/comm/mycon/resinst.h
--- src.orig/uqm/comm/mycon/resinst.h	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/mycon/resinst.h	2017-11-21 19:39:53 -0600
@@ -1,5 +1,10 @@
-#define MYCON_PMAP_ANIM "comm.mycon.graphics"
-#define MYCON_FONT "comm.mycon.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define MYCON_COLOR_MAP "comm.mycon.colortable"
 #define MYCON_CONVERSATION_PHRASES "comm.mycon.dialogue"
+#define MYCON_FONT "comm.mycon.font"
 #define MYCON_MUSIC "comm.mycon.music"
+#define MYCON_PMAP_ANIM "comm.mycon.graphics"
+#define MYCON_SCRIPT "comm.mycon.script"
diff -ruNp src.orig/uqm/comm/orz/Makeinfo src/uqm/comm/orz/Makeinfo
--- src.orig/uqm/comm/orz/Makeinfo	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/orz/Makeinfo	2017-11-21 19:39:53 -0600
@@ -1 +1,2 @@
 uqm_CFILES="orzc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.orig/uqm/comm/orz/orzc.c src/uqm/comm/orz/orzc.c
--- src.orig/uqm/comm/orz/orzc.c	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/orz/orzc.c	2017-11-21 19:39:53 -0600
@@ -20,6 +20,7 @@
 #include "resinst.h"
 #include "strings.h"
 
+#include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
 
 
@@ -174,7 +175,7 @@ static LOCDATA orz_desc =
 static void
 ExitConversation (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 
 	if (PLAYER_SAID (R, bye_ally))
 		NPCPhrase (GOODBYE_ALLY);
@@ -193,7 +194,7 @@ ExitConversation (RESPONSE_REF R)
 	{
 		NPCPhrase (HOSTILITY_IS_BAD_2);
 		
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, may_we_land))
 	{
@@ -213,13 +214,13 @@ ExitConversation (RESPONSE_REF R)
 		SET_GAME_STATE (ORZ_GENERAL_INFO, 0);
 		SET_GAME_STATE (ORZ_PERSONAL_INFO, 0);
 		SET_GAME_STATE (ORZ_MANNER, 3);
-		ActivateStarShip (ORZ_SHIP, SET_ALLIED);
+		SetRaceAllied (ORZ_SHIP, TRUE);
 	}
 	else if (PLAYER_SAID (R, demand_to_land))
 	{
 		NPCPhrase (NO_DEMAND);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, about_andro_3)
 			|| PLAYER_SAID (R, must_know_about_androsyn))
@@ -231,11 +232,11 @@ ExitConversation (RESPONSE_REF R)
 
 		SET_GAME_STATE (ORZ_VISITS, 0);
 		SET_GAME_STATE (ORZ_MANNER, 2);
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 		if (PLAYER_SAID (R, about_andro_3))
 		{
-			ActivateStarShip (ORZ_SHIP, SET_NOT_ALLIED);
-			ActivateStarShip (ORZ_SHIP, REMOVE_BUILT);
+			SetRaceAllied (ORZ_SHIP, FALSE);
+			RemoveEscortShips (ORZ_SHIP);
 		}
 
 		XFormColorMap (GetColorMapAddress (
@@ -257,13 +258,13 @@ ExitConversation (RESPONSE_REF R)
 				break;
 			case 2:
 				NPCPhrase (INSULTED_3);
-				SET_GAME_STATE (BATTLE_SEGUE, 1);
+				setSegue (Segue_hostile);
 				break;
 			case 7:
 				--NumVisits;
 			default:
 				NPCPhrase (INSULTED_4);
-				SET_GAME_STATE (BATTLE_SEGUE, 1);
+				setSegue (Segue_hostile);
 				break;
 		}
 		SET_GAME_STATE (ORZ_PERSONAL_INFO, NumVisits);
@@ -322,8 +323,7 @@ TaaloWorld (RESPONSE_REF R)
 
 	if (PHRASE_ENABLED (may_we_land))
 	{
-		if (Manner == 3 &&
-				ActivateStarShip (ORZ_SHIP, CHECK_ALLIANCE) == GOOD_GUY)
+		if (Manner == 3 && CheckAlliance (ORZ_SHIP) == GOOD_GUY)
 			Response (may_we_land, ExitConversation);
 		else
 			Response (may_we_land, TaaloWorld);
@@ -476,7 +476,7 @@ OrzNeutral (RESPONSE_REF R)
 		DISABLE_PHRASE (hostile_1);
 		LastStack = 2;
 	}
-	else if (PLAYER_SAID (R, we_are_vindicator0))
+	else if (PLAYER_SAID (R, we_are_vindicator))
 	{
 		NPCPhrase (NICE_TO_MEET_YOU);
 
@@ -541,14 +541,7 @@ OrzNeutral (RESPONSE_REF R)
 	}
 	else if (GET_GAME_STATE (ORZ_STACK0) == 0)
 	{
-		construct_response (shared_phrase_buf,
-				we_are_vindicator0,
-				GLOBAL_SIS (CommanderName),
-				we_are_vindicator1,
-				GLOBAL_SIS (ShipName),
-				we_are_vindicator2,
-				(UNICODE*)NULL);
-		pStr[1] = we_are_vindicator0;
+		pStr[1] = we_are_vindicator;
 	}
 	else
 		pStr[1] = seem_like_nice_guys;
@@ -558,21 +551,12 @@ OrzNeutral (RESPONSE_REF R)
 		pStr[2] = hostile_2;
 
 	if (pStr[LastStack])
-	{
-		if (pStr[LastStack] != we_are_vindicator0)
-			Response (pStr[LastStack], OrzNeutral);
-		else
-			DoResponsePhrase (pStr[LastStack], OrzNeutral, shared_phrase_buf);
-	}
+		Response (pStr[LastStack], OrzNeutral);
+
 	for (i = 0; i < 3; ++i)
 	{
 		if (i != LastStack && pStr[i])
-		{
-			if (pStr[i] != we_are_vindicator0)
-				Response (pStr[i], OrzNeutral);
-			else
-				DoResponsePhrase (pStr[i], OrzNeutral, shared_phrase_buf);
-		}
+			Response (pStr[i], OrzNeutral);
 	}
 	Response (bye_neutral, ExitConversation);
 }
@@ -644,7 +628,7 @@ Intro (void)
 	{
 		NPCPhrase (OUT_TAKES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
@@ -670,7 +654,7 @@ Intro (void)
 		}
 		SET_GAME_STATE (ORZ_VISITS, NumVisits);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 6))
 	{
@@ -705,8 +689,7 @@ Intro (void)
 
 		TaaloWorld ((RESPONSE_REF)0);
 	}
-	else if (Manner == 3 &&
-			ActivateStarShip (ORZ_SHIP, CHECK_ALLIANCE) == GOOD_GUY)
+	else if (Manner == 3 && CheckAlliance (ORZ_SHIP) == GOOD_GUY)
 	{
 		if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 7))
 		{
@@ -851,6 +834,7 @@ Intro (void)
 static COUNT
 uninit_orz (void)
 {
+	luaUqm_comm_uninit();
 	return (0);
 }
 
@@ -859,7 +843,7 @@ post_orz_enc (void)
 {
 	BYTE Manner;
 
-	if (GET_GAME_STATE (BATTLE_SEGUE) == 1
+	if (getSegue () == Segue_hostile
 			&& (Manner = GET_GAME_STATE (ORZ_MANNER)) != 2)
 	{
 		SET_GAME_STATE (ORZ_MANNER, 1);
@@ -881,6 +865,10 @@ init_orz_comm (void)
 	orz_desc.post_encounter_func = post_orz_enc;
 	orz_desc.uninit_encounter_func = uninit_orz;
 
+	luaUqm_comm_init(NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	orz_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
 	orz_desc.AlienTextBaseline.y = 0;
 	orz_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
@@ -888,13 +876,14 @@ init_orz_comm (void)
 	if (GET_GAME_STATE (ORZ_MANNER) == 3
 			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	retval = &orz_desc;
 
 	return (retval);
 }
+
diff -ruNp src.orig/uqm/comm/orz/resinst.h src/uqm/comm/orz/resinst.h
--- src.orig/uqm/comm/orz/resinst.h	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/orz/resinst.h	2017-11-21 19:39:53 -0600
@@ -1,5 +1,10 @@
-#define ORZ_PMAP_ANIM "comm.orz.graphics"
-#define ORZ_FONT "comm.orz.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define ORZ_COLOR_MAP "comm.orz.colortable"
 #define ORZ_CONVERSATION_PHRASES "comm.orz.dialogue"
+#define ORZ_FONT "comm.orz.font"
 #define ORZ_MUSIC "comm.orz.music"
+#define ORZ_PMAP_ANIM "comm.orz.graphics"
+#define ORZ_SCRIPT "comm.orz.script"
diff -ruNp src.orig/uqm/comm/orz/strings.h src/uqm/comm/orz/strings.h
--- src.orig/uqm/comm/orz/strings.h	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/orz/strings.h	2017-11-21 19:39:53 -0600
@@ -69,9 +69,7 @@ enum
 	HOSTILITY_IS_BAD_1,
 	hostile_2,
 	HOSTILITY_IS_BAD_2,
-	we_are_vindicator0,
-	we_are_vindicator1,
-	we_are_vindicator2,
+	we_are_vindicator,
 	NICE_TO_MEET_YOU,
 	seem_like_nice_guys,
 	ARE_NICE_WANT_ALLY,
diff -ruNp src.orig/uqm/comm/pkunk/Makeinfo src/uqm/comm/pkunk/Makeinfo
--- src.orig/uqm/comm/pkunk/Makeinfo	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/pkunk/Makeinfo	2017-11-21 19:39:53 -0600
@@ -1 +1,2 @@
 uqm_CFILES="pkunkc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.orig/uqm/comm/pkunk/pkunkc.c src/uqm/comm/pkunk/pkunkc.c
--- src.orig/uqm/comm/pkunk/pkunkc.c	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/pkunk/pkunkc.c	2017-11-21 19:39:53 -0600
@@ -20,6 +20,7 @@
 #include "resinst.h"
 #include "strings.h"
 
+#include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
 #include "uqm/gameev.h"
 
@@ -110,7 +111,7 @@ static void
 PrepareShip (void)
 {
 #define MAX_PKUNK_SHIPS 4
-	if (ActivateStarShip (PKUNK_SHIP, MAX_PKUNK_SHIPS))
+	if (AddEscortShips (PKUNK_SHIP, MAX_PKUNK_SHIPS))
 	{
 		BYTE mi, di, yi;
 
@@ -132,7 +133,7 @@ PrepareShip (void)
 static void
 ExitConversation (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 
 	if (PLAYER_SAID (R, friendly_bye_space))
 		NPCPhrase (FRIENDLY_GOODBYE_SPACE);
@@ -157,7 +158,7 @@ ExitConversation (RESPONSE_REF R)
 		SET_GAME_STATE (PKUNK_INFO, 0);
 
 		AddEvent (RELATIVE_EVENT, 6, 0, 0, ADVANCE_PKUNK_MISSION);
-		if (ActivateStarShip (PKUNK_SHIP, FEASIBILITY_STUDY) == 0)
+		if (EscortFeasibilityStudy (PKUNK_SHIP) == 0)
 			NPCPhrase (INIT_NO_ROOM);
 		else
 		{
@@ -187,13 +188,13 @@ ExitConversation (RESPONSE_REF R)
 
 			SET_GAME_STATE (PKUNK_MANNER, 2);
 		}
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, die_idiot_fools))
 	{
 		NPCPhrase (VERY_WELL);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, suit_yourself))
 		NPCPhrase (GOODBYE_MIGRATION);
@@ -324,7 +325,7 @@ DiscussConquer (RESPONSE_REF R)
 static void
 OfferAlliance (RESPONSE_REF R)
 {
-	if (PLAYER_SAID (R, we_are_vindicator0))
+	if (PLAYER_SAID (R, we_are_vindicator))
 		NPCPhrase (WHY_YOU_HERE);
 	else if (PLAYER_SAID (R, exploring_universe))
 	{
@@ -621,14 +622,7 @@ PkunkHome (RESPONSE_REF R)
 	}
 	if (!GET_GAME_STATE (PKUNK_SHIP_MONTH))
 	{
-		construct_response (shared_phrase_buf,
-				we_are_vindicator0,
-				GLOBAL_SIS (CommanderName),
-				we_are_vindicator1,
-				GLOBAL_SIS (ShipName),
-				we_are_vindicator2,
-				(UNICODE*)NULL);
-		DoResponsePhrase (we_are_vindicator0, OfferAlliance, shared_phrase_buf);
+		Response (we_are_vindicator, OfferAlliance);
 	}
 	if (PHRASE_ENABLED (what_about_you))
 	{
@@ -853,7 +847,7 @@ Intro (void)
 	{
 		NPCPhrase (OUT_TAKES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
@@ -880,7 +874,7 @@ Intro (void)
 		}
 		SET_GAME_STATE (PKUNK_VISITS, NumVisits);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (Manner == 1)
 	{
@@ -949,7 +943,7 @@ Intro (void)
 		{
 			if (NumVisits && ShipsReady ())
 			{
-				if (ActivateStarShip (PKUNK_SHIP, FEASIBILITY_STUDY) == 0)
+				if (EscortFeasibilityStudy (PKUNK_SHIP) == 0)
 					NPCPhrase (NO_ROOM);
 				else
 				{
@@ -1096,6 +1090,7 @@ Intro (void)
 static COUNT
 uninit_pkunk (void)
 {
+	luaUqm_comm_uninit();
 	return (0);
 }
 
@@ -1104,7 +1099,7 @@ post_pkunk_enc (void)
 {
 	BYTE Manner;
 
-	if (GET_GAME_STATE (BATTLE_SEGUE) == 1
+	if (getSegue () == Segue_hostile
 			&& (Manner = GET_GAME_STATE (PKUNK_MANNER)) != 2)
 	{
 		SET_GAME_STATE (PKUNK_MANNER, 1);
@@ -1125,6 +1120,10 @@ init_pkunk_comm (void)
 	pkunk_desc.post_encounter_func = post_pkunk_enc;
 	pkunk_desc.uninit_encounter_func = uninit_pkunk;
 
+	luaUqm_comm_init(NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	pkunk_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
 	pkunk_desc.AlienTextBaseline.y = 0;
 	pkunk_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
@@ -1133,12 +1132,12 @@ init_pkunk_comm (void)
 			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 	{
 		// Enter communications immediately.
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
 		// Ask the player whether to attack or talk.
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	retval = &pkunk_desc;
 
diff -ruNp src.orig/uqm/comm/pkunk/resinst.h src/uqm/comm/pkunk/resinst.h
--- src.orig/uqm/comm/pkunk/resinst.h	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/pkunk/resinst.h	2017-11-21 19:39:53 -0600
@@ -1,5 +1,10 @@
-#define PKUNK_PMAP_ANIM "comm.pkunk.graphics"
-#define PKUNK_FONT "comm.pkunk.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define PKUNK_COLOR_MAP "comm.pkunk.colortable"
 #define PKUNK_CONVERSATION_PHRASES "comm.pkunk.dialogue"
+#define PKUNK_FONT "comm.pkunk.font"
 #define PKUNK_MUSIC "comm.pkunk.music"
+#define PKUNK_PMAP_ANIM "comm.pkunk.graphics"
+#define PKUNK_SCRIPT "comm.pkunk.script"
diff -ruNp src.orig/uqm/comm/pkunk/strings.h src/uqm/comm/pkunk/strings.h
--- src.orig/uqm/comm/pkunk/strings.h	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/pkunk/strings.h	2017-11-21 19:39:53 -0600
@@ -112,9 +112,7 @@ enum
 	BAD_IDEA,
 	no_conquest,
 	GOOD_IDEA,
-	we_are_vindicator0,
-	we_are_vindicator1,
-	we_are_vindicator2,
+	we_are_vindicator,
 	WHY_YOU_HERE,
 	we_here_to_help,
 	NEED_HELP,
diff -ruNp src.orig/uqm/comm/rebel/Makeinfo src/uqm/comm/rebel/Makeinfo
--- src.orig/uqm/comm/rebel/Makeinfo	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/rebel/Makeinfo	2017-11-21 19:39:53 -0600
@@ -1 +1,2 @@
 uqm_CFILES="rebel.c"
+uqm_HFILES="strings.h"
diff -ruNp src.orig/uqm/comm/rebel/rebel.c src/uqm/comm/rebel/rebel.c
--- src.orig/uqm/comm/rebel/rebel.c	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/rebel/rebel.c	2017-11-21 19:39:53 -0600
@@ -324,7 +324,7 @@ Rebels (RESPONSE_REF R)
 			|| ((NumVisits == 0 && (NumVisits = GLOBAL (GameClock.month_index) - GET_GAME_STATE (YEHAT_SHIP_MONTH)) < 0) 
 			    || (NumVisits == 0 && GLOBAL (GameClock.day_index) < GET_GAME_STATE (YEHAT_SHIP_DAY)))))
 			NPCPhrase (NO_SHIPS_YET);
-		else if ((NumVisits = ActivateStarShip (YEHAT_SHIP, FEASIBILITY_STUDY)) == 0)
+		else if ((NumVisits = EscortFeasibilityStudy (YEHAT_SHIP)) == 0)
 			NPCPhrase (NO_ROOM);
 		else
 		{
@@ -338,7 +338,7 @@ Rebels (RESPONSE_REF R)
 			}
 
 			AlienTalkSegue ((COUNT)~0);
-			ActivateStarShip (YEHAT_SHIP, NumVisits);
+			AddEscortShips (YEHAT_SHIP, NumVisits);
 			PrepareShip ();
 		}
 
@@ -376,18 +376,17 @@ Intro (void)
 {
 	BYTE NumVisits;
 
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_LAST_BATTLE)
 	{
 		NPCPhrase (YEHAT_CAVALRY);
 		AlienTalkSegue ((COUNT)~0);
 
-		if ((NumVisits = (BYTE)ActivateStarShip (
-				YEHAT_REBEL_SHIP, FEASIBILITY_STUDY
-				)) > 8)
+		NumVisits = (BYTE) EscortFeasibilityStudy (YEHAT_REBEL_SHIP);
+		if (NumVisits > 8)
 			NumVisits = 8;
-		ActivateStarShip (YEHAT_REBEL_SHIP, NumVisits - (NumVisits >> 1));
-		ActivateStarShip (PKUNK_SHIP, NumVisits >> 1);
+		AddEscortShips (YEHAT_REBEL_SHIP, NumVisits - (NumVisits >> 1));
+		AddEscortShips (PKUNK_SHIP, NumVisits >> 1);
 	}
 	else
 	{
@@ -443,7 +442,7 @@ init_rebel_yehat_comm (void)
 	yehat_desc.AlienAltSongRes = REBEL_MUSIC;
 	yehat_desc.AlienSongFlags |= LDASF_USE_ALTERNATE;
 
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 	retval = &yehat_desc;
 
 	return (retval);
diff -ruNp src.orig/uqm/comm/shofixt/Makeinfo src/uqm/comm/shofixt/Makeinfo
--- src.orig/uqm/comm/shofixt/Makeinfo	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/shofixt/Makeinfo	2017-11-21 19:39:53 -0600
@@ -1 +1,2 @@
 uqm_CFILES="shofixt.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.orig/uqm/comm/shofixt/resinst.h src/uqm/comm/shofixt/resinst.h
--- src.orig/uqm/comm/shofixt/resinst.h	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/shofixt/resinst.h	2017-11-21 19:39:53 -0600
@@ -1,5 +1,10 @@
-#define SHOFIXTI_PMAP_ANIM "comm.shofixti.graphics"
-#define SHOFIXTI_FONT "comm.shofixti.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SHOFIXTI_COLOR_MAP "comm.shofixti.colortable"
 #define SHOFIXTI_CONVERSATION_PHRASES "comm.shofixti.dialogue"
+#define SHOFIXTI_FONT "comm.shofixti.font"
 #define SHOFIXTI_MUSIC "comm.shofixti.music"
+#define SHOFIXTI_PMAP_ANIM "comm.shofixti.graphics"
+#define SHOFIXTI_SCRIPT "comm.shofixti.script"
diff -ruNp src.orig/uqm/comm/shofixt/shofixt.c src/uqm/comm/shofixt/shofixt.c
--- src.orig/uqm/comm/shofixt/shofixt.c	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/shofixt/shofixt.c	2017-11-21 19:39:53 -0600
@@ -20,6 +20,7 @@
 #include "resinst.h"
 #include "strings.h"
 
+#include "uqm/lua/luacomm.h"
 #include "uqm/gameev.h"
 
 
@@ -170,25 +171,25 @@ GetShofixtiName (void)
 static void
 ExitConversation (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 1);
+	setSegue (Segue_hostile);
 
 	if (PLAYER_SAID (R, bye0))
 	{
 		NPCPhrase (GOODBYE);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else if (PLAYER_SAID (R, go_ahead))
 	{
 		NPCPhrase (ON_SECOND_THOUGHT);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else if (PLAYER_SAID (R, need_you_for_duty))
 	{
 		NPCPhrase (OK_WILL_BE_SENTRY);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else if (PLAYER_SAID (R, females)
 			|| PLAYER_SAID (R, nubiles)
@@ -198,7 +199,7 @@ ExitConversation (RESPONSE_REF R)
 
 		SET_GAME_STATE (SHOFIXTI_RECRUITED, 1);
 		SET_GAME_STATE (MAIDENS_ON_SHIP, 0);
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 
 		AddEvent (RELATIVE_EVENT, 2, 0, 0, SHOFIXTI_RETURN_EVENT);
 	}
@@ -326,7 +327,7 @@ ExplainDefeat (RESPONSE_REF R)
 		NPCPhrase (MUST_UNDERSTAND);
 	else if (PLAYER_SAID (R, i_am_guy))
 		NPCPhrase (NICE_BUT_WHAT_IS_DONKEY);
-	else /* if (PLAYER_SAID (R, i_am_captain0)) */
+	else /* if (PLAYER_SAID (R, i_am_captain)) */
 		NPCPhrase (SO_SORRY);
 	NPCPhrase (IS_DEFEAT_TRUE);
 
@@ -344,22 +345,7 @@ RealizeMistake (RESPONSE_REF R)
 	SET_GAME_STATE (SHOFIXTI_STACK3, 0);
 	SET_GAME_STATE (SHOFIXTI_STACK2, 3);
 
-	{
-		UNICODE buf[ALLIANCE_NAME_BUFSIZE];
-
-		GetAllianceName (buf, name_1);
-		construct_response (
-				shared_phrase_buf,
-				i_am_captain0,
-				GLOBAL_SIS (CommanderName),
-				i_am_captain1,
-				buf,
-				i_am_captain2,
-				GLOBAL_SIS (ShipName),
-				i_am_captain3,
-				(UNICODE*)NULL);
-	}
-	DoResponsePhrase (i_am_captain0, ExplainDefeat, shared_phrase_buf);
+	Response (i_am_captain, ExplainDefeat);
 	Response (i_am_nice, ExplainDefeat);
 	Response (i_am_guy, ExplainDefeat);
 }
@@ -546,7 +532,7 @@ Intro (void)
 	{
 		NPCPhrase (OUT_TAKES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
@@ -622,6 +608,7 @@ Intro (void)
 static COUNT
 uninit_shofixti (void)
 {
+	luaUqm_comm_uninit ();
 	return(0);
 }
 
@@ -640,11 +627,15 @@ init_shofixti_comm (void)
 	shofixti_desc.post_encounter_func = post_shofixti_enc;
 	shofixti_desc.uninit_encounter_func = uninit_shofixti;
 
+	luaUqm_comm_init (NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	shofixti_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
 	shofixti_desc.AlienTextBaseline.y = 0;
 	shofixti_desc.AlienTextWidth = SIS_TEXT_WIDTH;
 
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 
 	retval = &shofixti_desc;
 
diff -ruNp src.orig/uqm/comm/shofixt/strings.h src/uqm/comm/shofixt/strings.h
--- src.orig/uqm/comm/shofixt/strings.h	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/shofixt/strings.h	2017-11-21 19:39:53 -0600
@@ -25,8 +25,7 @@ enum
 	name_1,
 	name_2,
 	name_3,
-	name_40,
-	name_41,
+	name_4,
 	tanaka,
 	katana,
 	HOSTILE_KATANA_1,
@@ -65,10 +64,7 @@ enum
 	HANG_YOUR,
 	donkey_breath,
 	DGRUNTI,
-	i_am_captain0,
-	i_am_captain1,
-	i_am_captain2,
-	i_am_captain3,
+	i_am_captain,
 	i_am_nice,
 	i_am_guy,
 	SO_SORRY,
diff -ruNp src.orig/uqm/comm/slyhome/Makeinfo src/uqm/comm/slyhome/Makeinfo
--- src.orig/uqm/comm/slyhome/Makeinfo	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/slyhome/Makeinfo	2017-11-21 19:39:53 -0600
@@ -1 +1,2 @@
 uqm_CFILES="slyhome.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.orig/uqm/comm/slyhome/resinst.h src/uqm/comm/slyhome/resinst.h
--- src.orig/uqm/comm/slyhome/resinst.h	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/slyhome/resinst.h	2017-11-21 19:39:53 -0600
@@ -1,5 +1,10 @@
-#define SLYLANDRO_PMAP_ANIM "comm.slylandro.graphics"
-#define SLYLANDRO_FONT "comm.slylandro.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SLYLANDRO_COLOR_MAP "comm.slylandro.colortable"
 #define SLYLANDRO_CONVERSATION_PHRASES "comm.slylandro.dialogue"
+#define SLYLANDRO_FONT "comm.slylandro.font"
 #define SLYLANDRO_MUSIC "comm.slylandro.music"
+#define SLYLANDRO_PMAP_ANIM "comm.slylandro.graphics"
+#define SLYLANDRO_SCRIPT "comm.slylandro.script"
diff -ruNp src.orig/uqm/comm/slyhome/slyhome.c src/uqm/comm/slyhome/slyhome.c
--- src.orig/uqm/comm/slyhome/slyhome.c	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/slyhome/slyhome.c	2017-11-21 19:39:53 -0600
@@ -20,6 +20,7 @@
 #include "resinst.h"
 #include "strings.h"
 
+#include "uqm/lua/luacomm.h"
 #include "uqm/gameev.h"
 
 
@@ -175,7 +176,7 @@ static void
 ExitConversation (RESPONSE_REF R)
 {
 	(void) R;  // ignored
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 
 	switch (GET_GAME_STATE (SLYLANDRO_HOME_VISITS))
 	{
@@ -658,12 +659,12 @@ HomeWorld (RESPONSE_REF R)
 
 	LastStack = 0;
 	pStr[0] = pStr[1] = pStr[2] = 0;
-	if (PLAYER_SAID (R, we_are_us0))
+	if (PLAYER_SAID (R, we_are_us))
 	{
 		NPCPhrase (TERRIBLY_EXCITING);
 
 		SET_GAME_STATE (SLYLANDRO_STACK1, 1);
-		DISABLE_PHRASE (we_are_us0);
+		DISABLE_PHRASE (we_are_us);
 	}
 	else if (PLAYER_SAID (R, what_other_visitors))
 	{
@@ -755,14 +756,7 @@ HomeWorld (RESPONSE_REF R)
 	switch (GET_GAME_STATE (SLYLANDRO_STACK1))
 	{
 		case 0:
-			construct_response (shared_phrase_buf,
-					we_are_us0,
-					GLOBAL_SIS (CommanderName),
-					we_are_us1,
-					GLOBAL_SIS (ShipName),
-					we_are_us2,
-					(UNICODE*)NULL);
-			pStr[0] = we_are_us0;
+			pStr[0] = we_are_us;
 			break;
 		case 1:
 			pStr[0] = what_other_visitors;
@@ -807,21 +801,11 @@ HomeWorld (RESPONSE_REF R)
 	}
 
 	if (pStr[LastStack])
-	{
-		if (pStr[LastStack] != we_are_us0)
-			Response (pStr[LastStack], HomeWorld);
-		else
-			DoResponsePhrase (pStr[LastStack], HomeWorld, shared_phrase_buf);
-	}
+		Response (pStr[LastStack], HomeWorld);
 	for (i = 0; i < 3; ++i)
 	{
 		if (i != LastStack && pStr[i])
-		{
-			if (pStr[i] != we_are_us0)
-				Response (pStr[i], HomeWorld);
-			else
-				DoResponsePhrase (pStr[i], HomeWorld, shared_phrase_buf);
-		}
+			Response (pStr[i], HomeWorld);
 	}
 	if (GET_GAME_STATE (SLYLANDRO_STACK1))
 	{
@@ -892,6 +876,7 @@ Intro (void)
 static COUNT
 uninit_slylandro (void)
 {
+	luaUqm_comm_uninit ();
 	return (0);
 }
 
@@ -910,11 +895,15 @@ init_slylandro_comm (void)
 	slylandro_desc.post_encounter_func = post_slylandro_enc;
 	slylandro_desc.uninit_encounter_func = uninit_slylandro;
 
+	luaUqm_comm_init (NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	slylandro_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
 	slylandro_desc.AlienTextBaseline.y = 0;
 	slylandro_desc.AlienTextWidth = SIS_TEXT_WIDTH;
 
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 	retval = &slylandro_desc;
 
 	return (retval);
diff -ruNp src.orig/uqm/comm/slyhome/strings.h src/uqm/comm/slyhome/strings.h
--- src.orig/uqm/comm/slyhome/strings.h	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/slyhome/strings.h	2017-11-21 19:39:53 -0600
@@ -27,9 +27,7 @@ enum
 	HELLO_3,
 	HELLO_4,
 	RECALL_PROGRAM_1,
-	we_are_us0,
-	we_are_us1,
-	we_are_us2,
+	we_are_us,
 	TERRIBLY_EXCITING,
 	happy_to_tell_more,
 	TELL_MORE,
diff -ruNp src.orig/uqm/comm/slyland/Makeinfo src/uqm/comm/slyland/Makeinfo
--- src.orig/uqm/comm/slyland/Makeinfo	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/slyland/Makeinfo	2017-11-21 19:39:53 -0600
@@ -1 +1,2 @@
 uqm_CFILES="slyland.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.orig/uqm/comm/slyland/resinst.h src/uqm/comm/slyland/resinst.h
--- src.orig/uqm/comm/slyland/resinst.h	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/slyland/resinst.h	2017-11-21 19:39:53 -0600
@@ -1,5 +1,10 @@
-#define SLYLAND_PMAP_ANIM "comm.probe.graphics"
-#define SLYLAND_FONT "comm.probe.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SLYLAND_COLOR_MAP "comm.probe.colortable"
 #define SLYLAND_CONVERSATION_PHRASES "comm.probe.dialogue"
+#define SLYLAND_FONT "comm.probe.font"
 #define SLYLAND_MUSIC "comm.probe.music"
+#define SLYLAND_PMAP_ANIM "comm.probe.graphics"
+#define SLYLAND_SCRIPT "comm.probe.script"
diff -ruNp src.orig/uqm/comm/slyland/slyland.c src/uqm/comm/slyland/slyland.c
--- src.orig/uqm/comm/slyland/slyland.c	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/slyland/slyland.c	2017-11-21 19:39:53 -0600
@@ -314,8 +314,7 @@ CombatIsInevitable (RESPONSE_REF R)
 	else if (PLAYER_SAID (R, destruct_code))
 	{
 		NPCPhrase (DESTRUCT_SEQUENCE);
-		instantVictory = TRUE;
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_victory);
 	}
 	else
 	{
@@ -443,7 +442,7 @@ CombatIsInevitable (RESPONSE_REF R)
 		NPCPhrase (HOSTILE);
 
 		SET_GAME_STATE (PROBE_EXHIBITED_BUG, 1);
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 }
 
@@ -511,7 +510,7 @@ init_slyland_comm (void)
 	slylandro_desc.AlienTextBaseline.y = 0;
 	slylandro_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
 
-	SET_GAME_STATE (BATTLE_SEGUE, 1);
+	setSegue (Segue_hostile);
 	retval = &slylandro_desc;
 
 	return (retval);
diff -ruNp src.orig/uqm/comm/spahome/Makeinfo src/uqm/comm/spahome/Makeinfo
--- src.orig/uqm/comm/spahome/Makeinfo	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/spahome/Makeinfo	2017-11-21 19:39:53 -0600
@@ -1 +1,2 @@
 uqm_CFILES="spahome.c"
+uqm_HFILES="strings.h"
diff -ruNp src.orig/uqm/comm/spahome/spahome.c src/uqm/comm/spahome/spahome.c
--- src.orig/uqm/comm/spahome/spahome.c	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/spahome/spahome.c	2017-11-21 19:39:53 -0600
@@ -20,6 +20,7 @@
 #include "../spathi/resinst.h"
 #include "strings.h"
 
+#include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
 #include "uqm/gameev.h"
 
@@ -186,24 +187,24 @@ static LOCDATA spahome_desc =
 static void
 ExitConversation (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 	if (PLAYER_SAID (R, we_attack_again))
 	{
 		NPCPhrase (WE_FIGHT_AGAIN);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, surrender_or_die))
 	{
 		NPCPhrase (DEFEND_OURSELVES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
-	else if (PLAYER_SAID (R, we_are_vindicator0))
+	else if (PLAYER_SAID (R, we_are_vindicator))
 	{
 		NPCPhrase (NO_PASSWORD);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, gort_merenga)
 			|| PLAYER_SAID (R, guph_florp)
@@ -212,13 +213,13 @@ ExitConversation (RESPONSE_REF R)
 	{
 		NPCPhrase (WRONG_PASSWORD);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, screw_password))
 	{
 		NPCPhrase (NO_PASSWORD);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, bye_no_ally_offer))
 		NPCPhrase (GOODBYE_NO_ALLY_OFFER);
@@ -251,7 +252,7 @@ ExitConversation (RESPONSE_REF R)
 	{
 		NPCPhrase (DEPART_FOR_EARTH);
 
-		ActivateStarShip (SPATHI_SHIP, SET_ALLIED);
+		SetRaceAllied (SPATHI_SHIP, TRUE);
 		AddEvent (RELATIVE_EVENT, 6, 0, 0, SPATHI_SHIELD_EVENT);
 		SET_GAME_STATE (SPATHI_HOME_VISITS, 0);
 		SET_GAME_STATE (SPATHI_VISITS, 0);
@@ -821,7 +822,7 @@ SpathiCouncil (RESPONSE_REF R)
 	{
 		if (PHRASE_ENABLED (spathi_on_pluto))
 			Response (spathi_on_pluto, SpathiCouncil);
-		else if (ActivateStarShip (SPATHI_SHIP, ESCORTING_FLAGSHIP))
+		else if (HaveEscortShip (SPATHI_SHIP))
 		{
 			if (PHRASE_ENABLED (hostage))
 				Response (hostage, SpathiCouncil);
@@ -881,14 +882,7 @@ SpathiPassword (RESPONSE_REF R)
 	}
 	else
 	{
-		construct_response (shared_phrase_buf,
-				we_are_vindicator0,
-				GLOBAL_SIS (CommanderName),
-				we_are_vindicator1,
-				GLOBAL_SIS (ShipName),
-				we_are_vindicator2,
-				(UNICODE*)NULL);
-		DoResponsePhrase (we_are_vindicator0, ExitConversation, shared_phrase_buf);
+		Response (we_are_vindicator, ExitConversation);
 		Response (gort_merenga, ExitConversation);
 		Response (guph_florp, ExitConversation);
 		Response (wagngl_fthagn, ExitConversation);
@@ -906,7 +900,7 @@ Intro (void)
 	if (Manner == 2)
 	{
 		NPCPhrase (HATE_YOU_FOREVER);
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (Manner == 1
 			&& GET_GAME_STATE (KNOW_SPATHI_PASSWORD)
@@ -915,7 +909,7 @@ Intro (void)
 	{
 		SpathiAngry ((RESPONSE_REF)0);
 	}
-	else if (ActivateStarShip (SPATHI_SHIP, CHECK_ALLIANCE) == GOOD_GUY)
+	else if (CheckAlliance (SPATHI_SHIP) == GOOD_GUY)
 	{
 		CommData.AlienColorMap =
 				SetAbsColorMapIndex (CommData.AlienColorMap, 1);
@@ -940,7 +934,7 @@ Intro (void)
 			NPCPhrase (YOU_LIED_2);
 
 			SET_GAME_STATE (SPATHI_MANNER, 2);
-			SET_GAME_STATE (BATTLE_SEGUE, 1);
+			setSegue (Segue_hostile);
 		}
 	}
 	else if (GET_GAME_STATE (KNOW_SPATHI_QUEST))
@@ -966,6 +960,7 @@ Intro (void)
 static COUNT
 uninit_spahome (void)
 {
+	luaUqm_comm_uninit ();
 	return (0);
 }
 
@@ -974,7 +969,7 @@ post_spahome_enc (void)
 {
 	BYTE Manner;
 
-	if (GET_GAME_STATE (BATTLE_SEGUE) == 1
+	if (getSegue () == Segue_hostile
 			&& (Manner = GET_GAME_STATE (SPATHI_MANNER)) != 2)
 	{
 		SET_GAME_STATE (SPATHI_MANNER, 1);
@@ -995,6 +990,10 @@ init_spahome_comm ()
 	spahome_desc.post_encounter_func = post_spahome_enc;
 	spahome_desc.uninit_encounter_func = uninit_spahome;
 
+	luaUqm_comm_init (NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	spahome_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
 	spahome_desc.AlienTextBaseline.y = 0;
 	spahome_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
@@ -1005,11 +1004,11 @@ init_spahome_comm ()
 
 	if (GET_GAME_STATE (SPATHI_MANNER) == 3)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 
 	retval = &spahome_desc;
diff -ruNp src.orig/uqm/comm/spahome/strings.h src/uqm/comm/spahome/strings.h
--- src.orig/uqm/comm/spahome/strings.h	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/spahome/strings.h	2017-11-21 19:39:53 -0600
@@ -41,9 +41,7 @@ enum
 	HATE_YOU_FOREVER,
 	WHAT_IS_PASSWORD,
 	WHAT_IS_PASSWORD_AGAIN,
-	we_are_vindicator0,
-	we_are_vindicator1,
-	we_are_vindicator2,
+	we_are_vindicator,
 	gort_merenga,
 	guph_florp,
 	pleeese,
diff -ruNp src.orig/uqm/comm/spathi/Makeinfo src/uqm/comm/spathi/Makeinfo
--- src.orig/uqm/comm/spathi/Makeinfo	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/spathi/Makeinfo	2017-11-21 19:39:53 -0600
@@ -1 +1,2 @@
 uqm_CFILES="spathic.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.orig/uqm/comm/spathi/resinst.h src/uqm/comm/spathi/resinst.h
--- src.orig/uqm/comm/spathi/resinst.h	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/spathi/resinst.h	2017-11-21 19:39:53 -0600
@@ -1,10 +1,15 @@
-#define SPATHI_HOME_PMAP_ANIM "comm.safeones.graphics"
-#define SPATHI_PMAP_ANIM "comm.spathi.graphics"
-#define SPATHI_FONT "comm.spathi.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
+#define FWIFFO_MUSIC "comm.fwiffo.music"
+#define SPAHOME_MUSIC "comm.safeones.music"
 #define SPATHI_COLOR_MAP "comm.spathi.colortable"
 #define SPATHI_CONVERSATION_PHRASES "comm.spathi.dialogue"
+#define SPATHI_FONT "comm.spathi.font"
 #define SPATHI_HOME_COLOR_MAP "comm.safeones.colortable"
 #define SPATHI_HOME_CONVERSATION_PHRASES "comm.safeones.dialogue"
-#define FWIFFO_MUSIC "comm.fwiffo.music"
-#define SPAHOME_MUSIC "comm.safeones.music"
+#define SPATHI_HOME_PMAP_ANIM "comm.safeones.graphics"
 #define SPATHI_MUSIC "comm.spathi.music"
+#define SPATHI_PMAP_ANIM "comm.spathi.graphics"
+#define SPATHI_SCRIPT "comm.spathi.script"
diff -ruNp src.orig/uqm/comm/spathi/spathic.c src/uqm/comm/spathi/spathic.c
--- src.orig/uqm/comm/spathi/spathic.c	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/spathi/spathic.c	2017-11-21 19:39:53 -0600
@@ -147,7 +147,7 @@ static LOCDATA spathi_desc =
 static void
 ExitConversation (RESPONSE_REF Response)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 
 	if (PLAYER_SAID (Response, bye_ally_space))
 		NPCPhrase (GOODBYE_ALLY_SPACE);
@@ -165,13 +165,13 @@ ExitConversation (RESPONSE_REF Response)
 	{
 		NPCPhrase (YIPES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (Response, we_fight_again_space))
 	{
 		NPCPhrase (OK_FIGHT_AGAIN_SPACE);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (Response, die_slugboy)
 			|| PLAYER_SAID (Response, we_fight_1)
@@ -184,18 +184,18 @@ ExitConversation (RESPONSE_REF Response)
 			NPCPhrase (FAKE_COORDINATES);
 		NPCPhrase (OK_WE_FIGHT_AT_PLUTO);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (Response, join_us))
 	{
-		if (ActivateStarShip (SPATHI_SHIP, FEASIBILITY_STUDY) == 0)
+		if (EscortFeasibilityStudy (SPATHI_SHIP) == 0)
 			NPCPhrase (TOO_SCARY);
 		else
 		{
 			NPCPhrase (WILL_JOIN);
 
 			AlienTalkSegue ((COUNT)~0);
-			ActivateStarShip (SPATHI_SHIP, 1);
+			AddEscortShips (SPATHI_SHIP, 1);
 			/* Make the Eluder escort captained by Fwiffo alone */
 			SetEscortCrewComplement (SPATHI_SHIP, 1,
 					NAME_OFFSET + NUM_CAPTAINS_NAMES);
@@ -726,7 +726,7 @@ Intro (void)
 	else if (Manner == 2)
 	{
 		NPCPhrase (HATE_YOU_FOREVER_SPACE);
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (Manner == 1)
 	{
@@ -750,7 +750,7 @@ Intro (void)
 		Response (we_fight_again_space, ExitConversation);
 		Response (bye_angry_space, ExitConversation);
 	}
-	else if (ActivateStarShip (SPATHI_SHIP, CHECK_ALLIANCE) == GOOD_GUY)
+	else if (CheckAlliance (SPATHI_SHIP) == GOOD_GUY)
 	{
 		SpathiAllies ((RESPONSE_REF)0);
 	}
@@ -779,7 +779,7 @@ post_spathi_enc (void)
 	{
 		SET_GAME_STATE (FOUND_PLUTO_SPATHI, 2);
 	}
-	else if (GET_GAME_STATE (BATTLE_SEGUE) == 1
+	else if (getSegue () == Segue_hostile
 			&& (Manner = GET_GAME_STATE (SPATHI_MANNER)) != 2)
 	{
 		SET_GAME_STATE (SPATHI_MANNER, 1);
@@ -822,11 +822,11 @@ init_spathi_comm (void)
 			|| GET_GAME_STATE (SPATHI_MANNER) == 3
 			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	retval = &spathi_desc;
 
diff -ruNp src.orig/uqm/comm/starbas/Makeinfo src/uqm/comm/starbas/Makeinfo
--- src.orig/uqm/comm/starbas/Makeinfo	2017-11-21 19:39:36 -0600
+++ src/uqm/comm/starbas/Makeinfo	2017-11-21 19:39:53 -0600
@@ -1 +1,2 @@
 uqm_CFILES="starbas.c"
+uqm_HFILES="strings.h"
diff -ruNp src.orig/uqm/comm/starbas/starbas.c src/uqm/comm/starbas/starbas.c
--- src.orig/uqm/comm/starbas/starbas.c	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/starbas/starbas.c	2017-11-21 19:39:53 -0600
@@ -20,6 +20,7 @@
 #include "../comandr/resinst.h"
 #include "strings.h"
 
+#include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
 #include "uqm/setup.h"
 #include "uqm/shipcont.h"
@@ -28,7 +29,6 @@
 #include "libs/graphics/gfx_common.h"
 #include "libs/mathlib.h"
 #include "libs/inplib.h"
-#include "libs/sound/sound.h"
 
 
 static void TellMission (RESPONSE_REF R);
@@ -166,60 +166,29 @@ ByeBye (RESPONSE_REF R)
 {
 	(void) R;  // ignored
 
-	CurBulletinMask |= GET_GAME_STATE_32 (STARBASE_BULLETS0);
-	SET_GAME_STATE_32 (STARBASE_BULLETS0, CurBulletinMask);
+	CurBulletinMask |= GET_GAME_STATE (STARBASE_BULLETS);
+	SET_GAME_STATE (STARBASE_BULLETS, CurBulletinMask);
 
 	/* if (R == goodbye_starbase_commander) */
 	if (GET_GAME_STATE (CHMMR_BOMB_STATE) >= 2)
 		NPCPhrase (GOOD_LUCK_AGAIN);
 	else
 	{
-		RESPONSE_REF pStr0 = 0;
-		RESPONSE_REF pStr1 = 0;
+		RESPONSE_REF pStr = 0;
 		
 		switch ((BYTE)TFB_Random () & 7)
 		{
-			case 0:
-				pStr0 = NORMAL_GOODBYE_A0;
-				pStr1 = NORMAL_GOODBYE_A1;
-				break;
-			case 1:
-				pStr0 = NORMAL_GOODBYE_B0;
-				pStr1 = NORMAL_GOODBYE_B1;
-				break;
-			case 2:
-				pStr0 = NORMAL_GOODBYE_C0;
-				pStr1 = NORMAL_GOODBYE_C1;
-				break;
-			case 3:
-				pStr0 = NORMAL_GOODBYE_D0;
-				pStr1 = NORMAL_GOODBYE_D1;
-				break;
-			case 4:
-				pStr0 = NORMAL_GOODBYE_E0;
-				pStr1 = NORMAL_GOODBYE_E1;
-				break;
-			case 5:
-				pStr0 = NORMAL_GOODBYE_F0;
-				pStr1 = NORMAL_GOODBYE_F1;
-				break;
-			case 6:
-				pStr0 = NORMAL_GOODBYE_G0;
-				pStr1 = NORMAL_GOODBYE_G1;
-				break;
-			case 7:
-				pStr0 = NORMAL_GOODBYE_H0;
-				pStr1 = NORMAL_GOODBYE_H1;
-				break;
+			case 0: pStr = NORMAL_GOODBYE_A; break;
+			case 1: pStr = NORMAL_GOODBYE_B; break;
+			case 2: pStr = NORMAL_GOODBYE_C; break;
+			case 3: pStr = NORMAL_GOODBYE_D; break;
+			case 4: pStr = NORMAL_GOODBYE_E; break;
+			case 5: pStr = NORMAL_GOODBYE_F; break;
+			case 6: pStr = NORMAL_GOODBYE_G; break;
+			case 7: pStr = NORMAL_GOODBYE_H; break;
 		}
 
-		NPCPhrase (pStr0);
-		if (speechVolumeScale == 0.0f)
-		{
-			NPCPhrase (SPACE);
-			NPCPhrase (GLOBAL_PLAYER_NAME);
-		}
-		NPCPhrase (pStr1);
+		NPCPhrase (pStr);
 	}
 }
 
@@ -303,6 +272,7 @@ HierarchyInfo (RESPONSE_REF R)
 #define HIERARCHY_ANDROSYNTH (1 << 3)
 #define HIERARCHY_ILWRATH (1 << 4)
 #define HIERARCHY_VUX (1 << 5)
+#define HIERARCHY_URQUAN (1 << 6)
 	static BYTE HierarchyMask = 0;
 
 	if (PLAYER_SAID (R, what_about_hierarchy))
@@ -310,6 +280,11 @@ HierarchyInfo (RESPONSE_REF R)
 		NPCPhrase (WHICH_HIERARCHY);
 		HierarchyMask = 0;
 	}
+	else if (PLAYER_SAID (R, urquan))
+	{
+		NPCPhrase (ABOUT_URQUAN);
+		HierarchyMask |= HIERARCHY_URQUAN;
+	}
 	else if (PLAYER_SAID (R, mycon))
 	{
 		NPCPhrase (ABOUT_MYCON);
@@ -341,6 +316,8 @@ HierarchyInfo (RESPONSE_REF R)
 		HierarchyMask |= HIERARCHY_VUX;
 	}
 
+	if (!(HierarchyMask & HIERARCHY_URQUAN))
+		Response (urquan, HierarchyInfo);
 	if (!(HierarchyMask & HIERARCHY_MYCON))
 		Response (mycon, HierarchyInfo);
 	if (!(HierarchyMask & HIERARCHY_SPATHI))
@@ -678,7 +655,7 @@ AnalyzeCondition (void)
 		if (num_bays < 1)
 			NPCPhrase (NEED_STORAGE_1);
 		if (GLOBAL_SIS (NumLanders) == 0)
-			NPCPhrase (NEED_LANDERS_1);
+			NPCPhrase (NEED_LANDERS_2);
 		if (num_batts < 1)
 			NPCPhrase (NEED_DYNAMOS_1);
 
@@ -693,11 +670,10 @@ AnalyzeCondition (void)
 		COUNT FleetStrength;
 		BOOLEAN HasMaximum;
 
-		FleetStrength = ActivateStarShip (0, ESCORT_WORTH);
+		FleetStrength = CalculateEscortsWorth ();
 		for (i = 0; i < NUM_AVAILABLE_RACES; ++i)
 		{
-			if (i != HUMAN_SHIP
-					&& ActivateStarShip (i, CHECK_ALLIANCE) == GOOD_GUY)
+			if (i != HUMAN_SHIP && CheckAlliance (i) == GOOD_GUY)
 				++num_aliens;
 		}
 
@@ -755,7 +731,7 @@ AnalyzeCondition (void)
 					if (GLOBAL_SIS (FuelOnBoard) < FUEL_TANK_CAPACITY * 3)
 						NPCPhrase (NEED_FUEL_2);
 					if (GLOBAL_SIS (NumLanders) < 3)
-						NPCPhrase (NEED_LANDERS_2);
+						NPCPhrase (NEED_LANDERS_1);
 					if (num_batts < 4)
 						NPCPhrase (NEED_DYNAMOS_2);
 					if (num_defense < 2)
@@ -881,7 +857,6 @@ static void
 TellStarBase (RESPONSE_REF R)
 {
 	RESPONSE_REF pstack[4];
-	static UNICODE buf0[80];
 
 	if (PLAYER_SAID (R, starbase_functions))
 	{
@@ -891,7 +866,7 @@ TellStarBase (RESPONSE_REF R)
 		stack2 = 0;
 		stack3 = 0;
 	}
-	else if (PLAYER_SAID (R, tell_me_about_fuel0))
+	else if (PLAYER_SAID (R, tell_me_about_fuel))
 	{
 		NPCPhrase (ABOUT_FUEL);
 
@@ -899,18 +874,11 @@ TellStarBase (RESPONSE_REF R)
 	}
 	else if (PLAYER_SAID (R, tell_me_about_crew))
 	{
-		NPCPhrase (ABOUT_CREW0);
-		if (speechVolumeScale > 0.0f)
-			NPCPhrase (YOUR_FLAGSHIP_3DO2);
-		else {
-			NPCPhrase (YOUR_FLAGSHIP_PC);
-			NPCPhrase (GLOBAL_SHIP_NAME);
-		}
-		NPCPhrase (ABOUT_CREW1);
+		NPCPhrase (ABOUT_CREW);
 
 		stack2 = 2;
 	}
-	else if (PLAYER_SAID (R, tell_me_about_modules0))
+	else if (PLAYER_SAID (R, tell_me_about_modules))
 	{
 		NPCPhrase (ABOUT_MODULES);
 
@@ -944,13 +912,7 @@ TellStarBase (RESPONSE_REF R)
 	switch (stack0)
 	{
 		case 0:
-			construct_response (
-					buf0,
-					tell_me_about_modules0,
-					GLOBAL_SIS (ShipName),
-					tell_me_about_modules1,
-					(UNICODE*)NULL);
-			pstack[0] = tell_me_about_modules0;
+			pstack[0] = tell_me_about_modules;
 			break;
 		default:
 			pstack[0] = 0;
@@ -959,13 +921,7 @@ TellStarBase (RESPONSE_REF R)
 	switch (stack1)
 	{
 		case 0:
-			construct_response (
-					shared_phrase_buf,
-					tell_me_about_fuel0,
-					GLOBAL_SIS (ShipName),
-					tell_me_about_fuel1,
-					(UNICODE*)NULL);
-			pstack[1] = tell_me_about_fuel0;
+			pstack[1] = tell_me_about_fuel;
 			break;
 		default:
 			pstack[1] = 0;
@@ -1000,9 +956,9 @@ TellStarBase (RESPONSE_REF R)
 	}
 
 	if (pstack[0])
-		DoResponsePhrase (pstack[0], TellStarBase, buf0);
+		Response (pstack[0], TellStarBase);
 	if (pstack[1])
-		DoResponsePhrase (pstack[1], TellStarBase, shared_phrase_buf);
+		Response (pstack[1], TellStarBase);
 	if (pstack[2])
 		Response (pstack[2], TellStarBase);
 	if (pstack[3])
@@ -1357,7 +1313,7 @@ CheckBulletins (BOOLEAN Repeat)
 	if (Repeat)
 		BulletinMask = CurBulletinMask ^ 0xFFFFFFFFL;
 	else
-		BulletinMask = GET_GAME_STATE_32 (STARBASE_BULLETS0);
+		BulletinMask = GET_GAME_STATE (STARBASE_BULLETS);
 
 	pIntro = 0;
 	for (b0 = 0; b0 < 32; ++b0)
@@ -1370,36 +1326,31 @@ CheckBulletins (BOOLEAN Repeat)
 			switch (b0)
 			{
 				case 0:
-					if (ActivateStarShip (SPATHI_SHIP, CHECK_ALLIANCE)
-							== GOOD_GUY)
+					if (CheckAlliance (SPATHI_SHIP) == GOOD_GUY)
 					{
 						pStr = STARBASE_BULLETIN_1;
 					}
 					break;
 				case 1:
-					if (ActivateStarShip (ZOQFOTPIK_SHIP, CHECK_ALLIANCE)
-							== GOOD_GUY)
+					if (CheckAlliance (ZOQFOTPIK_SHIP) == GOOD_GUY)
 					{
 						pStr = STARBASE_BULLETIN_2;
 					}
 					break;
 				case 2:
-					if (ActivateStarShip (SUPOX_SHIP, CHECK_ALLIANCE)
-							== GOOD_GUY)
+					if (CheckAlliance (SUPOX_SHIP) == GOOD_GUY)
 					{
 						pStr = STARBASE_BULLETIN_3;
 					}
 					break;
 				case 3:
-					if (ActivateStarShip (UTWIG_SHIP, CHECK_ALLIANCE)
-							== GOOD_GUY)
+					if (CheckAlliance (UTWIG_SHIP) == GOOD_GUY)
 					{
 						pStr = STARBASE_BULLETIN_4;
 					}
 					break;
 				case 4:
-					if (ActivateStarShip (ORZ_SHIP, CHECK_ALLIANCE)
-							== GOOD_GUY)
+					if (CheckAlliance (ORZ_SHIP) == GOOD_GUY)
 					{
 						pStr = STARBASE_BULLETIN_5;
 					}
@@ -1408,14 +1359,13 @@ CheckBulletins (BOOLEAN Repeat)
 					if (GET_GAME_STATE (ARILOU_MANNER) == 2)
 						BulletinMask |= 1L << b0;
 					else if (GET_GAME_STATE (PORTAL_SPAWNER)
-							&& (Repeat || ActivateStarShip (
-									ARILOU_SHIP, FEASIBILITY_STUDY
-									)))
+							&& (Repeat || EscortFeasibilityStudy (
+									ARILOU_SHIP)))
 					{
 #define NUM_GIFT_ARILOUS 3
 						pStr = STARBASE_BULLETIN_6;
 						if (!Repeat)
-							ActivateStarShip (ARILOU_SHIP, NUM_GIFT_ARILOUS);
+							AddEscortShips (ARILOU_SHIP, NUM_GIFT_ARILOUS);
 					}
 					break;
 				case 6:
@@ -1456,7 +1406,7 @@ CheckBulletins (BOOLEAN Repeat)
 					break;
 				case 11:
 					if (GET_GAME_STATE (ZOQFOT_HOME_VISITS)
-							|| GET_GAME_STATE_32 (ZOQFOT_GRPOFFS0))
+							|| GET_GAME_STATE (ZOQFOT_GRPOFFS))
 						BulletinMask |= 1L << b0;
 					else if (CheckTiming (0, 42))
 					{
@@ -1464,15 +1414,13 @@ CheckBulletins (BOOLEAN Repeat)
 					}
 					break;
 				case 12:
-					if (ActivateStarShip (CHMMR_SHIP, CHECK_ALLIANCE)
-							== GOOD_GUY)
+					if (CheckAlliance (CHMMR_SHIP) == GOOD_GUY)
 					{
 						pStr = STARBASE_BULLETIN_13;
 					}
 					break;
 				case 13:
-					if (ActivateStarShip (SHOFIXTI_SHIP, CHECK_ALLIANCE)
-							== GOOD_GUY)
+					if (CheckAlliance (SHOFIXTI_SHIP) == GOOD_GUY)
 					{
 						pStr = STARBASE_BULLETIN_14;
 					}
@@ -1629,7 +1577,7 @@ CheckBulletins (BOOLEAN Repeat)
 	if (pIntro == 0 && GET_GAME_STATE (STARBASE_VISITED))
 		NPCPhrase (RETURN_HELLO);
 	else if (!Repeat)
-		SET_GAME_STATE_32 (STARBASE_BULLETS0, BulletinMask);
+		SET_GAME_STATE (STARBASE_BULLETS, BulletinMask);
 }
 
 static void
@@ -1645,22 +1593,8 @@ NormalStarbase (RESPONSE_REF R)
 	{
 		if (GET_GAME_STATE (MOONBASE_ON_SHIP))
 		{
-			NPCPhrase (STARBASE_IS_READY_A);
-			if (speechVolumeScale > 0.0f)
-				NPCPhrase (YOUR_FLAGSHIP_3DO1);
-			else {
-				NPCPhrase (YOUR_FLAGSHIP_PC);
-				NPCPhrase (GLOBAL_SHIP_NAME);
-			}
-			NPCPhrase (STARBASE_IS_READY_B);
-			if (speechVolumeScale > 0.0f)
-				NPCPhrase (YOUR_FLAGSHIP_3DO0);
-			else
-				NPCPhrase (GLOBAL_SHIP_NAME);
-			NPCPhrase (STARBASE_IS_READY_C);
-			LockMutex (GraphicsLock);
+			NPCPhrase (STARBASE_IS_READY);
 			DeltaSISGauges (0, 0, 2500);
-			UnlockMutex (GraphicsLock);
 			SET_GAME_STATE (STARBASE_MONTH,
 					GLOBAL (GameClock.month_index));
 			SET_GAME_STATE (STARBASE_DAY,
@@ -1672,51 +1606,21 @@ NormalStarbase (RESPONSE_REF R)
 		}
 		else
 		{
-			RESPONSE_REF pStr0 = 0;
-			RESPONSE_REF pStr1 = 0;
+			// XXX TODO: This can be simplified now.
+			RESPONSE_REF pStr = 0;
 
 			switch ((BYTE)TFB_Random () & 7)
 			{
-				case 0:
-					pStr0 = NORMAL_HELLO_A0;
-					pStr1 = NORMAL_HELLO_A1;
-					break;
-				case 1:
-					pStr0 = NORMAL_HELLO_B0;
-					pStr1 = NORMAL_HELLO_B1;
-					break;
-				case 2:
-					pStr0 = NORMAL_HELLO_C0;
-					pStr1 = NORMAL_HELLO_C1;
-					break;
-				case 3:
-					pStr0 = NORMAL_HELLO_D0;
-					pStr1 = NORMAL_HELLO_D1;
-					break;
-				case 4:
-					pStr0 = NORMAL_HELLO_E0;
-					pStr1 = NORMAL_HELLO_E1;
-					break;
-				case 5:
-					pStr0 = NORMAL_HELLO_F0;
-					pStr1 = NORMAL_HELLO_F1;
-					break;
-				case 6:
-					pStr0 = NORMAL_HELLO_G0;
-					pStr1 = NORMAL_HELLO_G1;
-					break;
-				case 7:
-					pStr0 = NORMAL_HELLO_H0;
-					pStr1 = NORMAL_HELLO_H1;
-					break;
+				case 0: pStr = NORMAL_HELLO_A; break;
+				case 1: pStr = NORMAL_HELLO_B; break;
+				case 2: pStr = NORMAL_HELLO_C; break;
+				case 3: pStr = NORMAL_HELLO_D; break;
+				case 4: pStr = NORMAL_HELLO_E; break;
+				case 5: pStr = NORMAL_HELLO_F; break;
+				case 6: pStr = NORMAL_HELLO_G; break;
+				case 7: pStr = NORMAL_HELLO_H; break;
 			}
-			NPCPhrase (pStr0);
-			if (speechVolumeScale == 0.0f)
-			{
-				NPCPhrase (SPACE);
-				NPCPhrase (GLOBAL_PLAYER_NAME);
-			}
-			NPCPhrase (pStr1);
+			NPCPhrase (pStr);
 			CheckBulletins (FALSE);
 		}
 
@@ -1772,9 +1676,7 @@ SellMinerals (RESPONSE_REF R)
 					Sleepy = FALSE;
 					GLOBAL_SIS (ElementAmounts[i]) = 0;
 					GLOBAL_SIS (TotalElementMass) -= amount;
-					LockMutex (GraphicsLock);
 					DeltaSISGauges (0, 0, amount * GLOBAL (ElementWorth[i]));
-					UnlockMutex (GraphicsLock);
 					break;
 				}
 				
@@ -1783,10 +1685,8 @@ SellMinerals (RESPONSE_REF R)
 				TaskSwitch ();
 				TimeIn = GetTimeCounter ();
 				DrawCargoStrings ((BYTE)i, (BYTE)i);
-				LockMutex (GraphicsLock);
 				ShowRemainingCapacity ();
 				DeltaSISGauges (0, 0, GLOBAL (ElementWorth[i]));
-				UnlockMutex (GraphicsLock);
 			} while (--amount);
 		}
 		if (Sleepy) {
@@ -1796,9 +1696,7 @@ SellMinerals (RESPONSE_REF R)
 	}
 	SleepThread (ONE_SECOND / 2);
 
-	LockMutex (GraphicsLock);
 	ClearSISRect (DRAW_SIS_DISPLAY);
-	UnlockMutex (GraphicsLock);
 // DrawStorageBays (FALSE);
 
 	if (total < 1000)
@@ -1806,34 +1704,18 @@ SellMinerals (RESPONSE_REF R)
 		total = GET_GAME_STATE (LIGHT_MINERAL_LOAD);
 		switch (total++)
 		{
-			case 0:
-				pStr1 = LIGHT_LOAD_A0;
-				pStr2 = LIGHT_LOAD_A1;
-				break;
-			case 1:
-				pStr1 = LIGHT_LOAD_B0;
-				pStr2 = LIGHT_LOAD_B1;
-				break;
+			case 0: pStr1 = LIGHT_LOAD_A; break;
+			case 1: pStr1 = LIGHT_LOAD_B; break;
 			case 2:
+				// There are two separate sound samples in this case.
 				pStr1 = LIGHT_LOAD_C0;
 				pStr2 = LIGHT_LOAD_C1;
 				break;
-			case 3:
-				pStr1 = LIGHT_LOAD_D0;
-				pStr2 = LIGHT_LOAD_D1;
-				break;
-			case 4:
-				pStr1 = LIGHT_LOAD_E0;
-				pStr2 = LIGHT_LOAD_E1;
-				break;
-			case 5:
-				pStr1 = LIGHT_LOAD_F0;
-				pStr2 = LIGHT_LOAD_F1;
-				break;
-			case 6:
-				--total;
-				pStr1 = LIGHT_LOAD_G0;
-				pStr2 = LIGHT_LOAD_G1;
+			case 3: pStr1 = LIGHT_LOAD_D; break;
+			case 4: pStr1 = LIGHT_LOAD_E; break;
+			case 5: pStr1 = LIGHT_LOAD_F; break;
+			case 6: --total;
+				pStr1 = LIGHT_LOAD_G;
 				break;
 		}
 		SET_GAME_STATE (LIGHT_MINERAL_LOAD, total);
@@ -1843,34 +1725,15 @@ SellMinerals (RESPONSE_REF R)
 		total = GET_GAME_STATE (MEDIUM_MINERAL_LOAD);
 		switch (total++)
 		{
-			case 0:
-				pStr1 = MEDIUM_LOAD_A0;
-				pStr2 = MEDIUM_LOAD_A1;
-				break;
-			case 1:
-				pStr1 = MEDIUM_LOAD_B0;
-				pStr2 = MEDIUM_LOAD_B1;
-				break;
-			case 2:
-				pStr1 = MEDIUM_LOAD_C0;
-				pStr2 = MEDIUM_LOAD_C1;
-				break;
-			case 3:
-				pStr1 = MEDIUM_LOAD_D0;
-				pStr2 = MEDIUM_LOAD_D1;
-				break;
-			case 4:
-				pStr1 = MEDIUM_LOAD_E0;
-				pStr2 = MEDIUM_LOAD_E1;
-				break;
-			case 5:
-				pStr1 = MEDIUM_LOAD_F0;
-				pStr2 = MEDIUM_LOAD_F1;
-				break;
+			case 0: pStr1 = MEDIUM_LOAD_A; break;
+			case 1: pStr1 = MEDIUM_LOAD_B; break;
+			case 2: pStr1 = MEDIUM_LOAD_C; break;
+			case 3: pStr1 = MEDIUM_LOAD_D; break;
+			case 4: pStr1 = MEDIUM_LOAD_E; break;
+			case 5: pStr1 = MEDIUM_LOAD_F; break;
 			case 6:
 				--total;
-				pStr1 = MEDIUM_LOAD_G0;
-				pStr2 = MEDIUM_LOAD_G1;
+				pStr1 = MEDIUM_LOAD_G;
 				break;
 		}
 		SET_GAME_STATE (MEDIUM_MINERAL_LOAD, total);
@@ -1880,46 +1743,23 @@ SellMinerals (RESPONSE_REF R)
 		total = GET_GAME_STATE (HEAVY_MINERAL_LOAD);
 		switch (total++)
 		{
-			case 0:
-				pStr1 = HEAVY_LOAD_A0;
-				pStr2 = HEAVY_LOAD_A1;
-				break;
-			case 1:
-				pStr1 = HEAVY_LOAD_B0;
-				pStr2 = HEAVY_LOAD_B1;
-				break;
-			case 2:
-				pStr1 = HEAVY_LOAD_C0;
-				pStr2 = HEAVY_LOAD_C1;
-				break;
-			case 3:
-				pStr1 = HEAVY_LOAD_D0;
-				pStr2 = HEAVY_LOAD_D1;
-				break;
-			case 4:
-				pStr1 = HEAVY_LOAD_E0;
-				pStr2 = HEAVY_LOAD_E1;
-				break;
-			case 5:
-				pStr1 = HEAVY_LOAD_F0;
-				pStr2 = HEAVY_LOAD_F1;
-				break;
+			case 0: pStr1 = HEAVY_LOAD_A; break;
+			case 1: pStr1 = HEAVY_LOAD_B; break;
+			case 2: pStr1 = HEAVY_LOAD_C; break;
+			case 3: pStr1 = HEAVY_LOAD_D; break;
+			case 4: pStr1 = HEAVY_LOAD_E; break;
+			case 5: pStr1 = HEAVY_LOAD_F; break;
 			case 6:
 				--total;
-				pStr1 = HEAVY_LOAD_G0;
-				pStr2 = HEAVY_LOAD_G1;
+				pStr1 = HEAVY_LOAD_G;
 				break;
 		}
 		SET_GAME_STATE (HEAVY_MINERAL_LOAD, total);
 	}
 
 	NPCPhrase (pStr1);
-	if (speechVolumeScale == 0.0f)
-	{
-		NPCPhrase (SPACE);
-		NPCPhrase (GLOBAL_PLAYER_NAME);
-	}
-	NPCPhrase (pStr2);
+	if (pStr2 != (RESPONSE_REF) 0)
+		NPCPhrase (pStr2);
 
 	NormalStarbase (R);
 }
@@ -1933,6 +1773,7 @@ Intro (void)
 static COUNT
 uninit_starbase (void)
 {
+	luaUqm_comm_uninit ();
 	return (0);
 }
 
@@ -1955,6 +1796,10 @@ init_starbase_comm ()
 	commander_desc.post_encounter_func = post_starbase_enc;
 	commander_desc.uninit_encounter_func = uninit_starbase;
 
+	luaUqm_comm_init (NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	commander_desc.AlienTextWidth = 143;
 	commander_desc.AlienTextBaseline.x = 164;
 	commander_desc.AlienTextBaseline.y = 20;
@@ -1964,7 +1809,7 @@ init_starbase_comm ()
 	commander_desc.AlienSongFlags |= LDASF_USE_ALTERNATE;
 
 	CurBulletinMask = 0;
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 	retval = &commander_desc;
 
 	return (retval);
diff -ruNp src.orig/uqm/comm/starbas/strings.h src/uqm/comm/starbas/strings.h
--- src.orig/uqm/comm/starbas/strings.h	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/starbas/strings.h	2017-11-21 19:39:53 -0600
@@ -28,85 +28,46 @@ enum
 	BEFORE_WE_GO_ON_5,
 	BEFORE_WE_GO_ON_6,
 	BEFORE_WE_GO_ON_7,
-	NORMAL_HELLO_A0,
-	NORMAL_HELLO_A1,
-	NORMAL_HELLO_B0,
-	NORMAL_HELLO_B1,
-	NORMAL_HELLO_C0,
-	NORMAL_HELLO_C1,
-	NORMAL_HELLO_D0,
-	NORMAL_HELLO_D1,
-	NORMAL_HELLO_E0,
-	NORMAL_HELLO_E1,
-	NORMAL_HELLO_F0,
-	NORMAL_HELLO_F1,
-	NORMAL_HELLO_G0,
-	NORMAL_HELLO_G1,
-	NORMAL_HELLO_H0,
-	NORMAL_HELLO_H1,
+	NORMAL_HELLO_A,
+	NORMAL_HELLO_B,
+	NORMAL_HELLO_C,
+	NORMAL_HELLO_D,
+	NORMAL_HELLO_E,
+	NORMAL_HELLO_F,
+	NORMAL_HELLO_G,
+	NORMAL_HELLO_H,
 	RETURN_HELLO,
-	NORMAL_HELLO_TAIL,
-	NORMAL_GOODBYE_A0,
-	NORMAL_GOODBYE_A1,
-	NORMAL_GOODBYE_B0,
-	NORMAL_GOODBYE_B1,
-	NORMAL_GOODBYE_C0,
-	NORMAL_GOODBYE_C1,
-	NORMAL_GOODBYE_D0,
-	NORMAL_GOODBYE_D1,
-	NORMAL_GOODBYE_E0,
-	NORMAL_GOODBYE_E1,
-	NORMAL_GOODBYE_F0,
-	NORMAL_GOODBYE_F1,
-	NORMAL_GOODBYE_G0,
-	NORMAL_GOODBYE_G1,
-	NORMAL_GOODBYE_H0,
-	NORMAL_GOODBYE_H1,
-	LIGHT_LOAD_A0,
-	LIGHT_LOAD_A1,
-	LIGHT_LOAD_B0,
-	LIGHT_LOAD_B1,
+	NORMAL_GOODBYE_A,
+	NORMAL_GOODBYE_B,
+	NORMAL_GOODBYE_C,
+	NORMAL_GOODBYE_D,
+	NORMAL_GOODBYE_E,
+	NORMAL_GOODBYE_F,
+	NORMAL_GOODBYE_G,
+	NORMAL_GOODBYE_H,
+	LIGHT_LOAD_A,
+	LIGHT_LOAD_B,
 	LIGHT_LOAD_C0,
 	LIGHT_LOAD_C1,
-	LIGHT_LOAD_D0,
-	LIGHT_LOAD_D1,
-	LIGHT_LOAD_E0,
-	LIGHT_LOAD_E1,
-	LIGHT_LOAD_F0,
-	LIGHT_LOAD_F1,
-	LIGHT_LOAD_G0,
-	LIGHT_LOAD_G1,
-	MEDIUM_LOAD_A0,
-	MEDIUM_LOAD_A1,
-	MEDIUM_LOAD_B0,
-	MEDIUM_LOAD_B1,
-	MEDIUM_LOAD_C0,
-	MEDIUM_LOAD_C1,
-	MEDIUM_LOAD_D0,
-	MEDIUM_LOAD_D1,
-	MEDIUM_LOAD_E0,
-	MEDIUM_LOAD_E1,
-	MEDIUM_LOAD_F0,
-	MEDIUM_LOAD_F1,
-	MEDIUM_LOAD_G0,
-	MEDIUM_LOAD_G1,
-	HEAVY_LOAD_A0,
-	HEAVY_LOAD_A1,
-	HEAVY_LOAD_B0,
-	HEAVY_LOAD_B1,
-	HEAVY_LOAD_C0,
-	HEAVY_LOAD_C1,
-	HEAVY_LOAD_D0,
-	HEAVY_LOAD_D1,
-	HEAVY_LOAD_E0,
-	HEAVY_LOAD_E1,
-	HEAVY_LOAD_F0,
-	HEAVY_LOAD_F1,
-	HEAVY_LOAD_G0 ,
-	HEAVY_LOAD_G1,
-	STARBASE_IS_READY_A,
-	STARBASE_IS_READY_B,
-	STARBASE_IS_READY_C,
+	LIGHT_LOAD_D,
+	LIGHT_LOAD_E,
+	LIGHT_LOAD_F,
+	LIGHT_LOAD_G,
+	MEDIUM_LOAD_A,
+	MEDIUM_LOAD_B,
+	MEDIUM_LOAD_C,
+	MEDIUM_LOAD_D,
+	MEDIUM_LOAD_E,
+	MEDIUM_LOAD_F,
+	MEDIUM_LOAD_G,
+	HEAVY_LOAD_A,
+	HEAVY_LOAD_B,
+	HEAVY_LOAD_C,
+	HEAVY_LOAD_D,
+	HEAVY_LOAD_E,
+	HEAVY_LOAD_F,
+	HEAVY_LOAD_G,
+	STARBASE_IS_READY,
 	WHAT_KIND_OF_INFO,
 	WHICH_FUNCTION,
 	WHICH_HISTORY,
@@ -114,8 +75,7 @@ enum
 	OK_NO_NEED_INFO,
 	ABOUT_FUEL,
 	ABOUT_MODULES,
-	ABOUT_CREW0,
-	ABOUT_CREW1,
+	ABOUT_CREW,
 	ABOUT_SHIPS,
 	ABOUT_RU,
 	ABOUT_MINERALS,
@@ -265,10 +225,8 @@ enum
 	no_need_info,
 	enough_starbase,
 	enough_mission,
-	tell_me_about_fuel0,
-	tell_me_about_fuel1,
-	tell_me_about_modules0,
-	tell_me_about_modules1,
+	tell_me_about_fuel,
+	tell_me_about_modules,
 	tell_me_about_crew,
 	tell_me_about_ships,
 	tell_me_about_ru,
@@ -317,11 +275,6 @@ enum
 	new_devices,
 	how_get_strong,
 	what_do_now,
-	YOUR_FLAGSHIP_PC,
-	YOUR_FLAGSHIP_3DO0,
-	YOUR_FLAGSHIP_3DO1,
-	YOUR_FLAGSHIP_3DO2,
-	SPACE,
 };
 
 #endif /* _STRINGS_H */
diff -ruNp src.orig/uqm/comm/supox/Makeinfo src/uqm/comm/supox/Makeinfo
--- src.orig/uqm/comm/supox/Makeinfo	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/supox/Makeinfo	2017-11-21 19:39:53 -0600
@@ -1 +1,2 @@
 uqm_CFILES="supoxc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.orig/uqm/comm/supox/resinst.h src/uqm/comm/supox/resinst.h
--- src.orig/uqm/comm/supox/resinst.h	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/supox/resinst.h	2017-11-21 19:39:53 -0600
@@ -1,5 +1,10 @@
-#define SUPOX_PMAP_ANIM "comm.supox.graphics"
-#define SUPOX_FONT "comm.supox.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SUPOX_COLOR_MAP "comm.supox.colortable"
 #define SUPOX_CONVERSATION_PHRASES "comm.supox.dialogue"
+#define SUPOX_FONT "comm.supox.font"
 #define SUPOX_MUSIC "comm.supox.music"
+#define SUPOX_PMAP_ANIM "comm.supox.graphics"
+#define SUPOX_SCRIPT "comm.supox.script"
diff -ruNp src.orig/uqm/comm/supox/strings.h src/uqm/comm/supox/strings.h
--- src.orig/uqm/comm/supox/strings.h	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/supox/strings.h	2017-11-21 19:39:53 -0600
@@ -32,14 +32,11 @@ enum
 	ALLIED_HOMEWORLD_HELLO_2,
 	ALLIED_HOMEWORLD_HELLO_3,
 	ALLIED_HOMEWORLD_HELLO_4,
-	i_am0,
-	i_am1,
+	i_am,
 	WE_ARE_SUPOX,
-	my_ship0,
-	my_ship1,
+	my_ship,
 	OUR_SHIP,
-	from_alliance0,
-	from_alliance1,
+	from_alliance,
 	FROM_SUPOX,
 	are_you_copying,
 	YEAH_SORRY,
@@ -116,8 +113,7 @@ enum
 	name_1,
 	name_2,
 	name_3,
-	name_40,
-	name_41,
+	name_4,
 	OUT_TAKES,
 };
 
diff -ruNp src.orig/uqm/comm/supox/supoxc.c src/uqm/comm/supox/supoxc.c
--- src.orig/uqm/comm/supox/supoxc.c	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/supox/supoxc.c	2017-11-21 19:39:53 -0600
@@ -20,6 +20,7 @@
 #include "resinst.h"
 #include "strings.h"
 
+#include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
 
 
@@ -103,7 +104,7 @@ static LOCDATA supox_desc =
 static void
 ExitConversation (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 
 	if (PLAYER_SAID (R, bye_neutral))
 		NPCPhrase (GOODBYE_NEUTRAL);
@@ -126,14 +127,14 @@ ExitConversation (RESPONSE_REF R)
 	else if (PLAYER_SAID (R, can_you_help))
 	{
 		NPCPhrase (HOW_HELP);
-		if (ActivateStarShip (SUPOX_SHIP, FEASIBILITY_STUDY) == 0)
+		if (EscortFeasibilityStudy (SUPOX_SHIP) == 0)
 			NPCPhrase (DONT_NEED);
 		else
 		{
 			NPCPhrase (HAVE_4_SHIPS);
 
 			AlienTalkSegue ((COUNT)~0);
-			ActivateStarShip (SUPOX_SHIP, 4);
+			AddEscortShips (SUPOX_SHIP, 4);
 		}
 	}
 }
@@ -305,26 +306,26 @@ NeutralSupox (RESPONSE_REF R)
 
 	LastStack = 0;
 	pStr[0] = pStr[1] = pStr[2] = 0;
-	if (PLAYER_SAID (R, i_am0))
+	if (PLAYER_SAID (R, i_am))
 	{
 		NPCPhrase (WE_ARE_SUPOX);
 
 		SET_GAME_STATE (SUPOX_STACK1, 1);
-		DISABLE_PHRASE (i_am0);
+		DISABLE_PHRASE (i_am);
 	}
-	else if (PLAYER_SAID (R, my_ship0))
+	else if (PLAYER_SAID (R, my_ship))
 	{
 		NPCPhrase (OUR_SHIP);
 
 		SET_GAME_STATE (SUPOX_STACK1, 2);
-		DISABLE_PHRASE (my_ship0);
+		DISABLE_PHRASE (my_ship);
 	}
-	else if (PLAYER_SAID (R, from_alliance0))
+	else if (PLAYER_SAID (R, from_alliance))
 	{
 		NPCPhrase (FROM_SUPOX);
 
 		SET_GAME_STATE (SUPOX_STACK1, 3);
-		DISABLE_PHRASE (from_alliance0);
+		DISABLE_PHRASE (from_alliance);
 	}
 	else if (PLAYER_SAID (R, are_you_copying))
 	{
@@ -357,7 +358,7 @@ NeutralSupox (RESPONSE_REF R)
 
 		LastStack = 2;
 		SET_GAME_STATE (SUPOX_WAR_NEWS, 1);
-		ActivateStarShip (UTWIG_SHIP, SPHERE_TRACKING);
+		StartSphereTracking (UTWIG_SHIP);
 	}
 	else if (PLAYER_SAID (R, what_relation_to_utwig))
 	{
@@ -422,36 +423,15 @@ NeutralSupox (RESPONSE_REF R)
 	switch (GET_GAME_STATE (SUPOX_STACK1))
 	{
 		case 0:
-			construct_response (shared_phrase_buf,
-					i_am0,
-					GLOBAL_SIS (CommanderName),
-					i_am1,
-					(UNICODE*)NULL);
-			pStr[0] = i_am0;
+			pStr[0] = i_am;
 			pStr[1] = 0;
 			break;
 		case 1:
-			construct_response (shared_phrase_buf,
-					my_ship0,
-					GLOBAL_SIS (ShipName),
-					my_ship1,
-					(UNICODE*)NULL);
-			pStr[0] = my_ship0;
+			pStr[0] = my_ship;
 			pStr[1] = 0;
 			break;
 		case 2:
-			{
-				UNICODE buf[ALLIANCE_NAME_BUFSIZE];
-
-				GetAllianceName (buf, name_1);
-				construct_response (
-						shared_phrase_buf,
-						from_alliance0,
-						buf,
-						from_alliance1,
-						(UNICODE*)NULL);
-			}
-			pStr[0] = from_alliance0;
+			pStr[0] = from_alliance;
 			pStr[1] = 0;
 			break;
 		case 3:
@@ -485,21 +465,11 @@ NeutralSupox (RESPONSE_REF R)
 		}
 	}
 	if (pStr[LastStack])
-	{
-		if (LastStack != 0 || GET_GAME_STATE (SUPOX_STACK1) > 2)
-			Response (pStr[LastStack], NeutralSupox);
-		else
-			DoResponsePhrase (pStr[LastStack], NeutralSupox, shared_phrase_buf);
-	}
+		Response (pStr[LastStack], NeutralSupox);
 	for (i = 0; i < 3; ++i)
 	{
 		if (i != LastStack && pStr[i])
-		{
-			if (i != 0 || GET_GAME_STATE (SUPOX_STACK1) > 2)
-				Response (pStr[i], NeutralSupox);
-			else
-				DoResponsePhrase (pStr[i], NeutralSupox, shared_phrase_buf);
-		}
+			Response (pStr[i], NeutralSupox);
 	}
 	if (!GET_GAME_STATE (SUPOX_ULTRON_HELP))
 	{
@@ -531,7 +501,7 @@ Intro (void)
 	{
 		NPCPhrase (OUT_TAKES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
@@ -550,9 +520,9 @@ Intro (void)
 		}
 		SET_GAME_STATE (SUPOX_VISITS, NumVisits);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
-	else if (ActivateStarShip (SUPOX_SHIP, CHECK_ALLIANCE) == GOOD_GUY)
+	else if (CheckAlliance (SUPOX_SHIP) == GOOD_GUY)
 	{
 		if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 7))
 		{
@@ -671,6 +641,7 @@ Intro (void)
 static COUNT
 uninit_supox (void)
 {
+	luaUqm_comm_uninit ();
 	return (0);
 }
 
@@ -689,6 +660,10 @@ init_supox_comm (void)
 	supox_desc.post_encounter_func = post_supox_enc;
 	supox_desc.uninit_encounter_func = uninit_supox;
 
+	luaUqm_comm_init (NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	supox_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
 	supox_desc.AlienTextBaseline.y = 0;
 	supox_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
@@ -696,11 +671,11 @@ init_supox_comm (void)
 	if (!GET_GAME_STATE (SUPOX_HOSTILE)
 			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	retval = &supox_desc;
 
diff -ruNp src.orig/uqm/comm/syreen/Makeinfo src/uqm/comm/syreen/Makeinfo
--- src.orig/uqm/comm/syreen/Makeinfo	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/syreen/Makeinfo	2017-11-21 19:39:53 -0600
@@ -1 +1,2 @@
 uqm_CFILES="syreenc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.orig/uqm/comm/syreen/resinst.h src/uqm/comm/syreen/resinst.h
--- src.orig/uqm/comm/syreen/resinst.h	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/syreen/resinst.h	2017-11-21 19:39:53 -0600
@@ -1,5 +1,10 @@
-#define SYREEN_PMAP_ANIM "comm.syreen.graphics"
-#define SYREEN_FONT "comm.syreen.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SYREEN_COLOR_MAP "comm.syreen.colortable"
 #define SYREEN_CONVERSATION_PHRASES "comm.syreen.dialogue"
+#define SYREEN_FONT "comm.syreen.font"
 #define SYREEN_MUSIC "comm.syreen.music"
+#define SYREEN_PMAP_ANIM "comm.syreen.graphics"
+#define SYREEN_SCRIPT "comm.syreen.script"
diff -ruNp src.orig/uqm/comm/syreen/strings.h src/uqm/comm/syreen/strings.h
--- src.orig/uqm/comm/syreen/strings.h	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/syreen/strings.h	2017-11-21 19:39:53 -0600
@@ -30,12 +30,8 @@ enum
 	OK_VICE,
 	we_are_the_one_for_you_baby,
 	MAYBE_CAPTAIN,
-	we_are_vindicator0,
-	we_are_vindicator1,
-	we_are_vindicator2,
-	WELCOME_VINDICATOR0,
-	WELCOME_VINDICATOR1,
-	WELCOME_VINDICATOR2,
+	we_are_vindicator,
+	WELCOME_VINDICATOR,
 	we_are_impressed,
 	SO_AM_I_CAPTAIN,
 	HOW_CAN_YOU_BE_HERE,
diff -ruNp src.orig/uqm/comm/syreen/syreenc.c src/uqm/comm/syreen/syreenc.c
--- src.orig/uqm/comm/syreen/syreenc.c	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/syreen/syreenc.c	2017-11-21 19:39:53 -0600
@@ -20,8 +20,9 @@
 #include "resinst.h"
 #include "strings.h"
 
-#include "libs/sound/sound.h"
+#include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
+#include "uqm/setup.h"
 
 
 static LOCDATA syreen_desc =
@@ -193,7 +194,7 @@ static LOCDATA syreen_desc =
 static void
 FriendlyExit (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 
 	if (PLAYER_SAID (R, bye))
 		NPCPhrase (GOODBYE);
@@ -555,7 +556,7 @@ NormalSyreen (RESPONSE_REF R)
 	{
 		NPCPhrase (HORRIBLE_TRUTH);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		SET_GAME_STATE (SYREEN_HOME_VISITS, 0);
 		SET_GAME_STATE (SYREEN_KNOW_ABOUT_MYCON, 1);
 
@@ -649,16 +650,9 @@ InitialSyreen (RESPONSE_REF R)
 		NPCPhrase (MAYBE_CAPTAIN);
 		NPCPhrase (HOW_CAN_YOU_BE_HERE);
 	}
-	else if (PLAYER_SAID (R, we_are_vindicator0))
+	else if (PLAYER_SAID (R, we_are_vindicator))
 	{
-		NPCPhrase (WELCOME_VINDICATOR0);
-		if (speechVolumeScale == 0.0f)
-		{
-			NPCPhrase (GLOBAL_PLAYER_NAME);
-			NPCPhrase (WELCOME_VINDICATOR1);
-			NPCPhrase (GLOBAL_SHIP_NAME);
-			NPCPhrase (WELCOME_VINDICATOR2);
-		}
+		NPCPhrase (WELCOME_VINDICATOR);
 		NPCPhrase (HOW_CAN_YOU_BE_HERE);
 	}
 	else if (PLAYER_SAID (R, we_are_impressed))
@@ -729,7 +723,7 @@ Intro (void)
 	{
 		NPCPhrase (OUT_TAKES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
@@ -740,7 +734,7 @@ Intro (void)
 		{
 			case 0:
 				NPCPhrase (HELLO_AFTER_AMBUSH_1);
-				ActivateStarShip (SYREEN_SHIP, SET_ALLIED);
+				SetRaceAllied (SYREEN_SHIP, TRUE);
 				break;
 			case 1:
 				NPCPhrase (HELLO_AFTER_AMBUSH_2);
@@ -791,16 +785,9 @@ Intro (void)
 			NormalSyreen ((RESPONSE_REF)0);
 		else
 		{
-			construct_response (shared_phrase_buf,
-					we_are_vindicator0,
-					GLOBAL_SIS (CommanderName),
-					we_are_vindicator1,
-					GLOBAL_SIS (ShipName),
-					we_are_vindicator2,
-					(UNICODE*)NULL);
 			Response (we_are_vice_squad, InitialSyreen);
 			Response (we_are_the_one_for_you_baby, InitialSyreen);
-			DoResponsePhrase (we_are_vindicator0, InitialSyreen, shared_phrase_buf);
+			Response (we_are_vindicator, InitialSyreen);
 			Response (we_are_impressed, InitialSyreen);
 		}
 	}
@@ -849,6 +836,7 @@ Intro (void)
 static COUNT
 uninit_syreen (void)
 {
+	luaUqm_comm_uninit ();
 	return (0);
 }
 
@@ -867,11 +855,15 @@ init_syreen_comm (void)
 	syreen_desc.post_encounter_func = post_syreen_enc;
 	syreen_desc.uninit_encounter_func = uninit_syreen;
 
+	luaUqm_comm_init (NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be 
+			// generalised in the future.
+
 	syreen_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
 	syreen_desc.AlienTextBaseline.y = 0;
 	syreen_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
 
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 	retval = &syreen_desc;
 
 	return (retval);
diff -ruNp src.orig/uqm/comm/talkpet/Makeinfo src/uqm/comm/talkpet/Makeinfo
--- src.orig/uqm/comm/talkpet/Makeinfo	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/talkpet/Makeinfo	2017-11-21 19:39:53 -0600
@@ -1 +1,2 @@
 uqm_CFILES="talkpet.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.orig/uqm/comm/talkpet/resinst.h src/uqm/comm/talkpet/resinst.h
--- src.orig/uqm/comm/talkpet/resinst.h	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/talkpet/resinst.h	2017-11-21 19:39:53 -0600
@@ -1,5 +1,10 @@
-#define TALKING_PET_PMAP_ANIM "comm.talkingpet.graphics"
-#define TALKING_PET_FONT "comm.talkingpet.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define TALKING_PET_COLOR_MAP "comm.talkingpet.colortable"
 #define TALKING_PET_CONVERSATION_PHRASES "comm.talkingpet.dialogue"
+#define TALKING_PET_FONT "comm.talkingpet.font"
 #define TALKING_PET_MUSIC "comm.talkingpet.music"
+#define TALKING_PET_PMAP_ANIM "comm.talkingpet.graphics"
+#define TALKING_PET_SCRIPT "comm.talkingpet.script"
diff -ruNp src.orig/uqm/comm/talkpet/strings.h src/uqm/comm/talkpet/strings.h
--- src.orig/uqm/comm/talkpet/strings.h	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/talkpet/strings.h	2017-11-21 19:39:54 -0600
@@ -31,8 +31,7 @@ enum
 	DID_NOTHING,
 	umgah_zombies,
 	WORKS_LIKE_THIS,
-	we_are_vindicator0,
-	we_are_vindicator1,
+	we_are_vindicator,
 	GOOD_FOR_YOU,
 	must_explain_presence,
 	EXPLAIN_NOTHING_MONKEY_BOY,
diff -ruNp src.orig/uqm/comm/talkpet/talkpet.c src/uqm/comm/talkpet/talkpet.c
--- src.orig/uqm/comm/talkpet/talkpet.c	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/talkpet/talkpet.c	2017-11-21 19:39:54 -0600
@@ -20,6 +20,7 @@
 #include "resinst.h"
 #include "strings.h"
 
+#include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
 
 #define STROBE_RATE   10
@@ -213,7 +214,7 @@ static LOCDATA talkpet_desc =
 static void
 ExitConversation (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 	SET_GAME_STATE (SHIP_TO_COMPEL, 0);
 
 	if (PLAYER_SAID (R, compel_urquan))
@@ -471,11 +472,11 @@ CompelPlayer (RESPONSE_REF R)
 		DISABLE_PHRASE (what_do_to_umgah);
 		LastStack = 1;
 	}
-	else if (PLAYER_SAID (R, we_are_vindicator0))
+	else if (PLAYER_SAID (R, we_are_vindicator))
 	{
 		NPCPhrase (GOOD_FOR_YOU);
 
-		DISABLE_PHRASE (we_are_vindicator0);
+		DISABLE_PHRASE (we_are_vindicator);
 		LastStack = 2;
 	}
 	else if (R != 0)
@@ -498,7 +499,7 @@ CompelPlayer (RESPONSE_REF R)
 		{
 			NPCPhrase (CANT_COMPEL);
 
-			SET_GAME_STATE (BATTLE_SEGUE, 1);
+			setSegue (Segue_hostile);
 		}
 
 		return;
@@ -515,35 +516,17 @@ CompelPlayer (RESPONSE_REF R)
 		else
 			pStr[1] = umgah_zombies;
 	}
-	if (PHRASE_ENABLED (we_are_vindicator0))
-	{
-		construct_response (
-				shared_phrase_buf,
-				we_are_vindicator0,
-				GLOBAL_SIS (ShipName),
-				we_are_vindicator1,
-				(UNICODE*)NULL);
-		pStr[2] = we_are_vindicator0;
-	}
+	if (PHRASE_ENABLED (we_are_vindicator))
+		pStr[2] = we_are_vindicator;
 	else
 		pStr[2] = must_explain_presence;
 
 	if (pStr[LastStack])
-	{
-		if (pStr[LastStack] != we_are_vindicator0)
-			Response (pStr[LastStack], CompelPlayer);
-		else
-			DoResponsePhrase (pStr[LastStack], CompelPlayer, shared_phrase_buf);
-	}
+		Response (pStr[LastStack], CompelPlayer);
 	for (i = 0; i < 3; ++i)
 	{
 		if (i != LastStack && pStr[i])
-		{
-			if (pStr[i] != we_are_vindicator0)
-				Response (pStr[i], CompelPlayer);
-			else
-				DoResponsePhrase (pStr[i], CompelPlayer, shared_phrase_buf);
-		}
+			Response (pStr[i], CompelPlayer);
 	}
 	Response (bye_at_umgah, CompelPlayer);
 }
@@ -649,14 +632,14 @@ Intro (void)
 	{
 		NPCPhrase (OUT_TAKES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
 	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_LAST_BATTLE)
 	{
 		SET_GAME_STATE (SHIP_TO_COMPEL, 0);
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 		if (!(GLOBAL (glob_flags) & CYBORG_ENABLED))
 		{
 			NPCPhrase (HUMAN_PEP_TALK);
@@ -679,13 +662,13 @@ Intro (void)
 			else
 				NPCPhrase (SOUP_UP_BOMB);
 
-			SET_GAME_STATE (BATTLE_SEGUE, 0);
+			setSegue (Segue_peace);
 		}
 		else if (GET_GAME_STATE (URQUAN_MESSED_UP))
 		{
 			NPCPhrase (HELLO_AFTER_COMPEL_URQUAN);
 
-			SET_GAME_STATE (BATTLE_SEGUE, 0);
+			setSegue (Segue_peace);
 		}
 		else
 		{
@@ -769,18 +752,18 @@ Intro (void)
 		else if (!GET_GAME_STATE (TAALO_PROTECTOR_ON_SHIP))
 		{
 			SET_GAME_STATE (PLAYER_HYPNOTIZED, 1);
-			SET_GAME_STATE (BATTLE_SEGUE, 0);
+			setSegue (Segue_peace);
 		}
 		else
 		{
 			NPCPhrase (CANT_COMPEL);
 
-			SET_GAME_STATE (BATTLE_SEGUE, 1);
+			setSegue (Segue_hostile);
 		}
 	}
 	else
 	{
-		if (ActivateStarShip (UMGAH_SHIP, SPHERE_TRACKING))
+		if (StartSphereTracking (UMGAH_SHIP))
 		{
 			NPCPhrase (LETS_MAKE_A_DEAL);
 		}
@@ -804,6 +787,7 @@ Intro (void)
 static COUNT
 uninit_talkpet (void)
 {
+	luaUqm_comm_uninit ();
 	return (0);
 }
 
@@ -822,17 +806,21 @@ init_talkpet_comm (void)
 	talkpet_desc.post_encounter_func = post_talkpet_enc;
 	talkpet_desc.uninit_encounter_func = uninit_talkpet;
 
+	luaUqm_comm_init (NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be 
+			// generalised in the future.
+
 	talkpet_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
 	talkpet_desc.AlienTextBaseline.y = 0;
 	talkpet_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
 
 	if (LOBYTE (GLOBAL (CurrentActivity)) != IN_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 
 	retval = &talkpet_desc;
diff -ruNp src.orig/uqm/comm/thradd/Makeinfo src/uqm/comm/thradd/Makeinfo
--- src.orig/uqm/comm/thradd/Makeinfo	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/thradd/Makeinfo	2017-11-21 19:39:54 -0600
@@ -1 +1,2 @@
 uqm_CFILES="thraddc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.orig/uqm/comm/thradd/resinst.h src/uqm/comm/thradd/resinst.h
--- src.orig/uqm/comm/thradd/resinst.h	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/thradd/resinst.h	2017-11-21 19:39:54 -0600
@@ -1,5 +1,10 @@
-#define THRADD_PMAP_ANIM "comm.thraddash.graphics"
-#define THRADD_FONT "comm.thraddash.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define THRADD_COLOR_MAP "comm.thraddash.colortable"
 #define THRADD_CONVERSATION_PHRASES "comm.thraddash.dialogue"
+#define THRADD_FONT "comm.thraddash.font"
 #define THRADD_MUSIC "comm.thraddash.music"
+#define THRADD_PMAP_ANIM "comm.thraddash.graphics"
+#define THRADD_SCRIPT "comm.thraddash.script"
diff -ruNp src.orig/uqm/comm/thradd/strings.h src/uqm/comm/thradd/strings.h
--- src.orig/uqm/comm/thradd/strings.h	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/thradd/strings.h	2017-11-21 19:39:54 -0600
@@ -160,8 +160,7 @@ enum
 	OK_CULTURE_20,
 	fat,
 	OK_FAT,
-	the_slave_empire0,
-	the_slave_empire1,
+	the_slave_empire,
 	OK_SLAVE,
 	FAT_JERKS,
 	CULTURE,
@@ -169,8 +168,7 @@ enum
 	name_1,
 	name_2,
 	name_3,
-	name_40,
-	name_41,
+	name_4,
 	HAVING_FUN_WITH_ILWRATH_1,
 	HAVING_FUN_WITH_ILWRATH_2,
 	GO_AWAY_FIGHTING_ILWRATH_1,
diff -ruNp src.orig/uqm/comm/thradd/thraddc.c src/uqm/comm/thradd/thraddc.c
--- src.orig/uqm/comm/thradd/thraddc.c	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/thradd/thraddc.c	2017-11-21 19:39:54 -0600
@@ -20,6 +20,7 @@
 #include "resinst.h"
 #include "strings.h"
 
+#include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
 #include "uqm/gameev.h"
 
@@ -239,7 +240,7 @@ LikeYouPhrase (BYTE which_phrase)
 static void
 ExitConversation (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 1);
+	setSegue (Segue_hostile);
 
 	if (PLAYER_SAID (R, bye_hostile_2))
 		NPCPhrase (GOODBYE_HOSTILE_2);
@@ -261,7 +262,7 @@ ExitConversation (RESPONSE_REF R)
 	{
 		NPCPhrase (GOOD_IDEA);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		AddEvent (RELATIVE_EVENT, 0, 0, 0, ADVANCE_THRADD_MISSION);
 		SET_GAME_STATE (THRADD_STACK_1, 5);
 	}
@@ -289,14 +290,14 @@ ExitConversation (RESPONSE_REF R)
 				break;
 		}
 		SET_GAME_STATE (THRADD_STACK_1, NumVisits);
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else if (PLAYER_SAID (R, may_i_land))
 	{
 		NPCPhrase (SURE_LAND);
 
 		SET_GAME_STATE (HELIX_UNPROTECTED, 1);
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else if (PLAYER_SAID (R, demand_to_land))
 		NPCPhrase (NO_DEMAND);
@@ -330,7 +331,7 @@ ExitConversation (RESPONSE_REF R)
 		}
 		NPCPhrase (WORK_TO_DO);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 }
 
@@ -443,7 +444,7 @@ ThraddDemeanor (RESPONSE_REF R)
 
 		SET_GAME_STATE (THRADD_CULTURE, 2);
 	}
-	else if (PLAYER_SAID (R, the_slave_empire0))
+	else if (PLAYER_SAID (R, the_slave_empire))
 	{
 		SET_GAME_STATE (THRADD_CULTURE, 3);
 
@@ -486,16 +487,9 @@ ThraddCulture (RESPONSE_REF R)
 	}
 	NPCPhrase (WHAT_NAME_FOR_CULTURE);
 
-	construct_response (
-			shared_phrase_buf,
-			the_slave_empire0,
-			GLOBAL_SIS (CommanderName),
-			the_slave_empire1,
-			(UNICODE*)NULL);
-
 	Response (you_decide, ThraddDemeanor);
 	Response (fat, ThraddDemeanor);
-	DoResponsePhrase (the_slave_empire0, ThraddDemeanor, shared_phrase_buf);
+	Response (the_slave_empire, ThraddDemeanor);
 }
 
 static void
@@ -505,7 +499,7 @@ ThraddWorship (RESPONSE_REF R)
 	SET_GAME_STATE (THRADD_VISITS, 0);
 	SET_GAME_STATE (THRADD_MANNER, 1);
 	SET_GAME_STATE (THRADD_STACK_1, 0);
-	ActivateStarShip (THRADDASH_SHIP, SET_ALLIED);
+	SetRaceAllied (THRADDASH_SHIP, TRUE);
 
 	Response (be_polite, ThraddCulture);
 	Response (speak_pig_latin, ThraddCulture);
@@ -700,7 +694,7 @@ Intro (void)
 	{
 		NPCPhrase (OUT_TAKES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
@@ -719,7 +713,7 @@ Intro (void)
 		}
 		SET_GAME_STATE (HELIX_VISITS, NumVisits);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (GET_GAME_STATE (ILWRATH_FIGHT_THRADDASH))
 	{
@@ -752,7 +746,7 @@ Intro (void)
 		}
 		SET_GAME_STATE (THRADD_VISITS, NumVisits);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else if (GET_GAME_STATE (THRADD_MANNER))
 	{
@@ -917,6 +911,7 @@ Intro (void)
 static COUNT
 uninit_thradd (void)
 {
+	luaUqm_comm_uninit ();
 	return (0);
 }
 
@@ -935,6 +930,10 @@ init_thradd_comm (void)
 	thradd_desc.post_encounter_func = post_thradd_enc;
 	thradd_desc.uninit_encounter_func = uninit_thradd;
 
+	luaUqm_comm_init (NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	thradd_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
 	thradd_desc.AlienTextBaseline.y = 0;
 	thradd_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
@@ -942,11 +941,11 @@ init_thradd_comm (void)
 	if (GET_GAME_STATE (THRADD_MANNER)
 			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	retval = &thradd_desc;
 
diff -ruNp src.orig/uqm/comm/umgah/Makeinfo src/uqm/comm/umgah/Makeinfo
--- src.orig/uqm/comm/umgah/Makeinfo	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/umgah/Makeinfo	2017-11-21 19:39:54 -0600
@@ -1 +1,2 @@
 uqm_CFILES="umgahc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.orig/uqm/comm/umgah/resinst.h src/uqm/comm/umgah/resinst.h
--- src.orig/uqm/comm/umgah/resinst.h	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/umgah/resinst.h	2017-11-21 19:39:54 -0600
@@ -1,5 +1,10 @@
-#define UMGAH_PMAP_ANIM "comm.umgah.graphics"
-#define UMGAH_FONT "comm.umgah.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define UMGAH_COLOR_MAP "comm.umgah.colortable"
 #define UMGAH_CONVERSATION_PHRASES "comm.umgah.dialogue"
+#define UMGAH_FONT "comm.umgah.font"
 #define UMGAH_MUSIC "comm.umgah.music"
+#define UMGAH_PMAP_ANIM "comm.umgah.graphics"
+#define UMGAH_SCRIPT "comm.umgah.script"
diff -ruNp src.orig/uqm/comm/umgah/strings.h src/uqm/comm/umgah/strings.h
--- src.orig/uqm/comm/umgah/strings.h	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/umgah/strings.h	2017-11-21 19:39:54 -0600
@@ -93,9 +93,7 @@ enum
 	YES_VERY_EVIL,
 	give_up_or_die,
 	NOT_GIVE_UP,
-	we_vindicator0,
-	we_vindicator1,
-	we_vindicator2,
+	we_vindicator,
 	GOOD_FOR_YOU_1,
 	come_in_peace,
 	GOOD_FOR_YOU_2,
diff -ruNp src.orig/uqm/comm/umgah/umgahc.c src/uqm/comm/umgah/umgahc.c
--- src.orig/uqm/comm/umgah/umgahc.c	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/umgah/umgahc.c	2017-11-21 19:39:54 -0600
@@ -20,6 +20,7 @@
 #include "resinst.h"
 #include "strings.h"
 
+#include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
 
 
@@ -198,13 +199,13 @@ static LOCDATA umgah_desc =
 static void
 CombatIsInevitable (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 1);
+	setSegue (Segue_hostile);
 
 	if (PLAYER_SAID (R, bye_zombie))
 	{
 		NPCPhrase (GOODBYE_ZOMBIE);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else if (PLAYER_SAID (R, bye_pre_zombie))
 		NPCPhrase (GOODBYE_PRE_ZOMBIE);
@@ -235,14 +236,14 @@ CombatIsInevitable (RESPONSE_REF R)
 	{
 		NPCPhrase (GOODBYE_UNKNOWN);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else if (PLAYER_SAID (R, bye_post_zombie))
 	{
 		NPCPhrase (FUNNY_IDEA);
 
 		AlienTalkSegue ((COUNT)~0);
-		ActivateStarShip (UMGAH_SHIP, 4);
+		AddEscortShips (UMGAH_SHIP, 4);
 		SET_GAME_STATE (UMGAH_HOSTILE, 1);
 	}
 }
@@ -300,11 +301,11 @@ Zombies (RESPONSE_REF R)
 			DISABLE_PHRASE (evil_blobbies);
 			LastStack = 0;
 		}
-		else if (PLAYER_SAID (R, we_vindicator0))
+		else if (PLAYER_SAID (R, we_vindicator))
 		{
 			NPCPhrase (GOOD_FOR_YOU_1);
 
-			DISABLE_PHRASE (we_vindicator0);
+			DISABLE_PHRASE (we_vindicator);
 			LastStack = 1;
 		}
 		else if (PLAYER_SAID (R, come_in_peace))
@@ -346,14 +347,14 @@ Zombies (RESPONSE_REF R)
 		{
 			NPCPhrase (NOT_GIVE_UP);
 
-			SET_GAME_STATE (BATTLE_SEGUE, 1);
+			setSegue (Segue_hostile);
 			return;
 		}
 		else if (PLAYER_SAID (R, arilou_told_us))
 		{
 			NPCPhrase (THEN_DIE);
 
-			SET_GAME_STATE (BATTLE_SEGUE, 1);
+			setSegue (Segue_hostile);
 			SET_GAME_STATE (KNOW_UMGAH_ZOMBIES, 1);
 			SET_GAME_STATE (UMGAH_VISITS, 0);
 			return;
@@ -364,17 +365,8 @@ Zombies (RESPONSE_REF R)
 		else
 			pStr[0] = give_up_or_die;
 
-		if (PHRASE_ENABLED (we_vindicator0))
-		{
-			construct_response (shared_phrase_buf,
-					we_vindicator0,
-					GLOBAL_SIS (CommanderName),
-					we_vindicator1,
-					GLOBAL_SIS (ShipName),
-					we_vindicator2,
-					(UNICODE*)NULL);
-			pStr[1] = we_vindicator0;
-		}
+		if (PHRASE_ENABLED (we_vindicator))
+			pStr[1] = we_vindicator;
 		else if (PHRASE_ENABLED (come_in_peace))
 			pStr[1] = come_in_peace;
 
@@ -391,21 +383,11 @@ Zombies (RESPONSE_REF R)
 			pStr[3] = arilou_told_us;
 
 		if (pStr[LastStack])
-		{
-			if (pStr[LastStack] != we_vindicator0)
-				Response (pStr[LastStack], Zombies);
-			else
-				DoResponsePhrase (pStr[LastStack], Zombies, shared_phrase_buf);
-		}
+			Response (pStr[LastStack], Zombies);
 		for (i = 0; i < 4; ++i)
 		{
 			if (i != LastStack && pStr[i])
-			{
-				if (pStr[i] != we_vindicator0)
-					Response (pStr[i], Zombies);
-				else
-					DoResponsePhrase (pStr[i], Zombies, shared_phrase_buf);
-			}
+				Response (pStr[i], Zombies);
 		}
 		Response (bye_zombie, CombatIsInevitable);
 	}
@@ -541,7 +523,7 @@ Intro (void)
 		}
 		SET_GAME_STATE (UMGAH_VISITS, NumVisits);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (GET_GAME_STATE (UMGAH_ZOMBIE_BLOBBIES))
 	{
@@ -565,7 +547,7 @@ Intro (void)
 					break;
 			}
 
-			SET_GAME_STATE (BATTLE_SEGUE, 1);
+			setSegue (Segue_hostile);
 		}
 		else if (GET_GAME_STATE (KNOW_UMGAH_ZOMBIES))
 		{
@@ -586,7 +568,7 @@ Intro (void)
 					break;
 			}
 
-			SET_GAME_STATE (BATTLE_SEGUE, 1);
+			setSegue (Segue_hostile);
 		}
 		else
 		{
@@ -681,7 +663,7 @@ Intro (void)
 			}
 			SET_GAME_STATE (UMGAH_VISITS, NumVisits);
 
-			SET_GAME_STATE (BATTLE_SEGUE, 0);
+			setSegue (Segue_peace);
 		}
 	}
 }
@@ -689,6 +671,7 @@ Intro (void)
 static COUNT
 uninit_umgah (void)
 {
+	luaUqm_comm_uninit ();
 	return (0);
 }
 
@@ -710,6 +693,10 @@ init_umgah_comm (void)
 	umgah_desc.post_encounter_func = post_umgah_enc;
 	umgah_desc.uninit_encounter_func = uninit_umgah;
 
+	luaUqm_comm_init (NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	umgah_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
 	umgah_desc.AlienTextBaseline.y = 0;
 	umgah_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
@@ -717,11 +704,11 @@ init_umgah_comm (void)
 	if ((GET_GAME_STATE (TALKING_PET) && !GET_GAME_STATE (UMGAH_HOSTILE))
 			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	retval = &umgah_desc;
 
diff -ruNp src.orig/uqm/comm/urquan/Makeinfo src/uqm/comm/urquan/Makeinfo
--- src.orig/uqm/comm/urquan/Makeinfo	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/urquan/Makeinfo	2017-11-21 19:39:54 -0600
@@ -1 +1,2 @@
 uqm_CFILES="urquanc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.orig/uqm/comm/urquan/resinst.h src/uqm/comm/urquan/resinst.h
--- src.orig/uqm/comm/urquan/resinst.h	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/urquan/resinst.h	2017-11-21 19:39:54 -0600
@@ -1,5 +1,10 @@
-#define URQUAN_PMAP_ANIM "comm.urquan.graphics"
-#define URQUAN_FONT "comm.urquan.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define URQUAN_COLOR_MAP "comm.urquan.colortable"
 #define URQUAN_CONVERSATION_PHRASES "comm.urquan.dialogue"
+#define URQUAN_FONT "comm.urquan.font"
 #define URQUAN_MUSIC "comm.urquan.music"
+#define URQUAN_PMAP_ANIM "comm.urquan.graphics"
+#define URQUAN_SCRIPT "comm.urquan.script"
diff -ruNp src.orig/uqm/comm/urquan/urquanc.c src/uqm/comm/urquan/urquanc.c
--- src.orig/uqm/comm/urquan/urquanc.c	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/urquan/urquanc.c	2017-11-21 19:39:54 -0600
@@ -123,7 +123,7 @@ static LOCDATA urquan_desc =
 static void
 CombatIsInevitable (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 1);
+	setSegue (Segue_hostile);
 
 	if (PLAYER_SAID (R, you_must_surrender))
 		NPCPhrase (NOPE);
@@ -159,9 +159,7 @@ CombatIsInevitable (RESPONSE_REF R)
 	{
 		NPCPhrase (GOOD_CHOICE);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
-		GLOBAL_SIS (CrewEnlisted) = (COUNT)~0;
-		GLOBAL (CurrentActivity) |= CHECK_RESTART;
+		setSegue (Segue_defeat);
 	}
 	else if (PLAYER_SAID (R, like_to_leave))
 		NPCPhrase (INDEPENDENCE_IS_BAD);
@@ -169,7 +167,7 @@ CombatIsInevitable (RESPONSE_REF R)
 	{
 		NPCPhrase (GOODBYE_WARS_OVER);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else if (PLAYER_SAID (R, bye_sub_hypno))
 		NPCPhrase (GOODBYE_AND_DIE_SUB_HYPNO);
@@ -184,7 +182,7 @@ CombatIsInevitable (RESPONSE_REF R)
 	{
 		NPCPhrase (BAD_NEWS);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		SET_GAME_STATE (URQUAN_HYPNO_VISITS, 1);
 	}
 	else if (PLAYER_SAID (R, falling_asleep)
@@ -192,7 +190,7 @@ CombatIsInevitable (RESPONSE_REF R)
 	{
 		NPCPhrase (SOUNDS_FAMILIAR);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		SET_GAME_STATE (URQUAN_HYPNO_VISITS, 1);
 	}
 }
@@ -415,11 +413,11 @@ Intro (void)
 	{
 		NPCPhrase (OUT_TAKES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
-	GrpOffs = GET_GAME_STATE_32 (URQUAN_PROBE_GRPOFFS0);
+	GrpOffs = GET_GAME_STATE (URQUAN_PROBE_GRPOFFS);
 	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
 			&& GLOBAL (BattleGroupRef)
 			&& GLOBAL (BattleGroupRef) == GrpOffs)
@@ -443,18 +441,18 @@ Intro (void)
 			SET_GAME_STATE (URQUAN_SENSES_EVIL, 1);
 		}
 
-		GrpOffs = GET_GAME_STATE_32 (COLONY_GRPOFFS0);
+		GrpOffs = GET_GAME_STATE (COLONY_GRPOFFS);
 		if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
 				&& GLOBAL (BattleGroupRef)
 				&& GLOBAL (BattleGroupRef) == GrpOffs)
 		{
 			NPCPhrase (CAUGHT_YA);
 
-			SET_GAME_STATE (BATTLE_SEGUE, 1);
+			setSegue (Segue_hostile);
 			return;
 		}
 
-		GrpOffs = GET_GAME_STATE_32 (SAMATRA_GRPOFFS0);
+		GrpOffs = GET_GAME_STATE (SAMATRA_GRPOFFS);
 		if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
 				&& GLOBAL (BattleGroupRef)
 				&& GLOBAL (BattleGroupRef) == GrpOffs)
@@ -462,7 +460,7 @@ Intro (void)
 			NPCPhrase (HELLO_SAMATRA);
 
 			SET_GAME_STATE (AWARE_OF_SAMATRA, 1);
-			SET_GAME_STATE (BATTLE_SEGUE, 1);
+			setSegue (Segue_hostile);
 		}
 		else
 		{
@@ -501,7 +499,7 @@ Intro (void)
 						break;
 					case 1:
 						NPCPhrase (SUBSEQUENT_FLEE_HUMAN);
-						SET_GAME_STATE (BATTLE_SEGUE, 0);
+						setSegue (Segue_peace);
 						--NumVisits;
 						break;
 				}
@@ -538,18 +536,18 @@ init_urquan_comm (void)
 	urquan_desc.AlienTextBaseline.y = 0;
 	urquan_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
 
-	GrpOffs = GET_GAME_STATE_32 (URQUAN_PROBE_GRPOFFS0);
+	GrpOffs = GET_GAME_STATE (URQUAN_PROBE_GRPOFFS);
 	if (GET_GAME_STATE (PLAYER_HYPNOTIZED)
 			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE
 			|| (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
 			&& GLOBAL (BattleGroupRef)
 			&& GLOBAL (BattleGroupRef) == GrpOffs))
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	retval = &urquan_desc;
 
diff -ruNp src.orig/uqm/comm/utwig/Makeinfo src/uqm/comm/utwig/Makeinfo
--- src.orig/uqm/comm/utwig/Makeinfo	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/utwig/Makeinfo	2017-11-21 19:39:54 -0600
@@ -1 +1,2 @@
 uqm_CFILES="utwigc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.orig/uqm/comm/utwig/resinst.h src/uqm/comm/utwig/resinst.h
--- src.orig/uqm/comm/utwig/resinst.h	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/utwig/resinst.h	2017-11-21 19:39:54 -0600
@@ -1,6 +1,11 @@
-#define UTWIG_PMAP_ANIM "comm.utwig.graphics"
-#define UTWIG_FONT "comm.utwig.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define UTWIG_COLOR_MAP "comm.utwig.colortable"
 #define UTWIG_CONVERSATION_PHRASES "comm.utwig.dialogue"
+#define UTWIG_FONT "comm.utwig.font"
 #define UTWIG_MUSIC "comm.utwig.music"
+#define UTWIG_PMAP_ANIM "comm.utwig.graphics"
+#define UTWIG_SCRIPT "comm.utwig.script"
 #define UTWIG_ULTRON_MUSIC "comm.utwig.ultron.music"
diff -ruNp src.orig/uqm/comm/utwig/strings.h src/uqm/comm/utwig/strings.h
--- src.orig/uqm/comm/utwig/strings.h	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/utwig/strings.h	2017-11-21 19:39:54 -0600
@@ -57,9 +57,7 @@ enum
 	TAUNT_US_BUT_WE_LOOK,
 	TRICKED_US_1,
 	TRICKED_US_2,
-	we_are_vindicator0,
-	we_are_vindicator1,
-	we_are_vindicator2,
+	we_are_vindicator,
 	WOULD_BE_HAPPY_BUT,
 	why_sad,
 	ULTRON_BROKE,
@@ -89,8 +87,7 @@ enum
 	name_1,
 	name_2,
 	name_3,
-	name_40,
-	name_41,
+	name_4,
 	HAPPY_DAYS,
 	OK_ATTACK_KOHRAH,
 	whats_up_after_space,
diff -ruNp src.orig/uqm/comm/utwig/utwigc.c src/uqm/comm/utwig/utwigc.c
--- src.orig/uqm/comm/utwig/utwigc.c	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/utwig/utwigc.c	2017-11-21 19:39:54 -0600
@@ -20,6 +20,7 @@
 #include "resinst.h"
 #include "strings.h"
 
+#include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
 #include "uqm/gameev.h"
 
@@ -200,7 +201,7 @@ static LOCDATA utwig_desc =
 static void
 ExitConversation (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 
 	if (PLAYER_SAID (R, bye_neutral))
 		NPCPhrase (GOODBYE_NEUTRAL);
@@ -216,7 +217,7 @@ ExitConversation (RESPONSE_REF R)
 	{
 		NPCPhrase (GUARDS_FIGHT);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, got_ultron)
 			|| PLAYER_SAID (R, hey_wait_got_ultron))
@@ -244,7 +245,7 @@ ExitConversation (RESPONSE_REF R)
 						{
 							NPCPhrase (TRICKED_US_1);
 
-							SET_GAME_STATE (BATTLE_SEGUE, 1);
+							setSegue (Segue_hostile);
 						}
 						break;
 					case 1:
@@ -254,7 +255,7 @@ ExitConversation (RESPONSE_REF R)
 						{
 							NPCPhrase (TRICKED_US_2);
 
-							SET_GAME_STATE (BATTLE_SEGUE, 1);
+							setSegue (Segue_hostile);
 						}
 						break;
 				}
@@ -288,22 +289,22 @@ ExitConversation (RESPONSE_REF R)
 				SET_GAME_STATE (SUPOX_HOSTILE, 0);
 				SET_GAME_STATE (UTWIG_HOSTILE, 0);
 
-				ActivateStarShip (UTWIG_SHIP, SET_ALLIED);
-				ActivateStarShip (SUPOX_SHIP, SET_ALLIED);
+				SetRaceAllied (UTWIG_SHIP, TRUE);
+				SetRaceAllied (SUPOX_SHIP, TRUE);
 			}
 		}
 	}
 	else if (PLAYER_SAID (R, can_you_help))
 	{
 		NPCPhrase (HOW_HELP);
-		if (ActivateStarShip (UTWIG_SHIP, FEASIBILITY_STUDY) == 0)
+		if (EscortFeasibilityStudy (UTWIG_SHIP) == 0)
 			NPCPhrase (DONT_NEED);
 		else
 		{
 			NPCPhrase (HAVE_4_SHIPS);
 
 			AlienTalkSegue ((COUNT)~0);
-			ActivateStarShip (UTWIG_SHIP, 4);
+			AddEscortShips (UTWIG_SHIP, 4);
 		}
 	}
 }
@@ -390,7 +391,7 @@ AlliedHome (RESPONSE_REF R)
 		Response (what_now_homeworld, AlliedHome);
 	if (PHRASE_ENABLED (how_is_ultron))
 		Response (how_is_ultron, AlliedHome);
-	if (NumVisits == 0)
+	if (NumVisits == 0 && EscortFeasibilityStudy (UTWIG_SHIP) != 0)
 		Response (can_you_help, ExitConversation);
 	Response (bye_allied_homeworld, ExitConversation);
 }
@@ -475,7 +476,7 @@ NeutralUtwig (RESPONSE_REF R)
 
 	LastStack = 0;
 	pStr[0] = pStr[1] = pStr[2] = pStr[3] = 0;
-	if (PLAYER_SAID (R, we_are_vindicator0))
+	if (PLAYER_SAID (R, we_are_vindicator))
 	{
 		NPCPhrase (WOULD_BE_HAPPY_BUT);
 
@@ -497,7 +498,7 @@ NeutralUtwig (RESPONSE_REF R)
 	{
 		NPCPhrase (MOCK_OUR_PAIN);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 		SET_GAME_STATE (UTWIG_STACK1, 4);
 		SET_GAME_STATE (UTWIG_HOSTILE, 1);
 		SET_GAME_STATE (UTWIG_INFO, 0);
@@ -525,7 +526,7 @@ NeutralUtwig (RESPONSE_REF R)
 		NPCPhrase (ABOUT_US_2);
 
 		LastStack = 2;
-		ActivateStarShip (SUPOX_SHIP, SPHERE_TRACKING);
+		StartSphereTracking (SUPOX_SHIP);
 		SET_GAME_STATE (UTWIG_WAR_NEWS, 2);
 	}
 	else if (PLAYER_SAID (R, what_about_you_3))
@@ -551,20 +552,7 @@ NeutralUtwig (RESPONSE_REF R)
 	switch (GET_GAME_STATE (UTWIG_STACK1))
 	{
 		case 0:
-			{
-				UNICODE buf[ALLIANCE_NAME_BUFSIZE];
-
-				GetAllianceName (buf, name_1);
-				construct_response (
-						shared_phrase_buf,
-						we_are_vindicator0,
-						GLOBAL_SIS (CommanderName),
-						we_are_vindicator1,
-						buf,
-						we_are_vindicator2,
-						(UNICODE*)NULL);
-			}
-			pStr[0] = we_are_vindicator0;
+			pStr[0] = we_are_vindicator;
 			break;
 		case 1:
 			pStr[0] = why_sad;
@@ -600,21 +588,11 @@ NeutralUtwig (RESPONSE_REF R)
 	}
 
 	if (pStr[LastStack])
-	{
-		if (pStr[LastStack] != we_are_vindicator0)
-			Response (pStr[LastStack], NeutralUtwig);
-		else
-			DoResponsePhrase (pStr[LastStack], NeutralUtwig, shared_phrase_buf);
-	}
+		Response (pStr[LastStack], NeutralUtwig);
 	for (i = 0; i < 4; ++i)
 	{
 		if (i != LastStack && pStr[i])
-		{
-			if (pStr[i] != we_are_vindicator0)
-				Response (pStr[i], NeutralUtwig);
-			else
-				DoResponsePhrase (pStr[i], NeutralUtwig, shared_phrase_buf);
-		}
+			Response (pStr[i], NeutralUtwig);
 	}
 	if (GET_GAME_STATE (ULTRON_CONDITION))
 		Response (got_ultron, ExitConversation);
@@ -651,7 +629,7 @@ BombWorld (RESPONSE_REF R)
 	{
 		NPCPhrase (GUARDS_FIGHT);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 		SET_GAME_STATE (UTWIG_HOSTILE, 1);
 		SET_GAME_STATE (UTWIG_INFO, 0);
 		SET_GAME_STATE (UTWIG_HOME_VISITS, 0);
@@ -745,7 +723,7 @@ Intro (void)
 	{
 		NPCPhrase (OUT_TAKES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
@@ -800,14 +778,14 @@ Intro (void)
 		if (!GET_GAME_STATE (ULTRON_CONDITION)
 				|| (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 6)))
 		{
-			SET_GAME_STATE (BATTLE_SEGUE, 1);
+			setSegue (Segue_hostile);
 		}
 		else
 		{
 			Response (hey_wait_got_ultron, ExitConversation);
 		}
 	}
-	else if (ActivateStarShip (UTWIG_SHIP, CHECK_ALLIANCE) == GOOD_GUY)
+	else if (CheckAlliance (UTWIG_SHIP) == GOOD_GUY)
 	{
 		if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 7))
 		{
@@ -949,6 +927,7 @@ Intro (void)
 static COUNT
 uninit_utwig (void)
 {
+	luaUqm_comm_uninit ();
 	return (0);
 }
 
@@ -967,6 +946,10 @@ init_utwig_comm (void)
 	utwig_desc.post_encounter_func = post_utwig_enc;
 	utwig_desc.uninit_encounter_func = uninit_utwig;
 
+	luaUqm_comm_init (NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	utwig_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
 	utwig_desc.AlienTextBaseline.y = 70;
 	utwig_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
@@ -984,11 +967,11 @@ init_utwig_comm (void)
 	if (GET_GAME_STATE (UTWIG_HAVE_ULTRON)
 			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	retval = &utwig_desc;
 
diff -ruNp src.orig/uqm/comm/vux/Makeinfo src/uqm/comm/vux/Makeinfo
--- src.orig/uqm/comm/vux/Makeinfo	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/vux/Makeinfo	2017-11-21 19:39:54 -0600
@@ -1 +1,2 @@
 uqm_CFILES="vuxc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.orig/uqm/comm/vux/resinst.h src/uqm/comm/vux/resinst.h
--- src.orig/uqm/comm/vux/resinst.h	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/vux/resinst.h	2017-11-21 19:39:54 -0600
@@ -1,5 +1,10 @@
-#define VUX_PMAP_ANIM "comm.vux.graphics"
-#define VUX_FONT "comm.vux.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define VUX_COLOR_MAP "comm.vux.colortable"
 #define VUX_CONVERSATION_PHRASES "comm.vux.dialogue"
+#define VUX_FONT "comm.vux.font"
 #define VUX_MUSIC "comm.vux.music"
+#define VUX_PMAP_ANIM "comm.vux.graphics"
+#define VUX_SCRIPT "comm.vux.script"
diff -ruNp src.orig/uqm/comm/vux/vuxc.c src/uqm/comm/vux/vuxc.c
--- src.orig/uqm/comm/vux/vuxc.c	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/vux/vuxc.c	2017-11-21 19:39:54 -0600
@@ -205,7 +205,7 @@ CombatIsInevitable (RESPONSE_REF R)
 {
 	BYTE NumVisits;
 
-	SET_GAME_STATE (BATTLE_SEGUE, 1);
+	setSegue (Segue_hostile);
 
 	if (PLAYER_SAID (R, ok_take_beast))
 	{
@@ -220,7 +220,7 @@ CombatIsInevitable (RESPONSE_REF R)
 
 		SET_GAME_STATE (VUX_BEAST_ON_SHIP, 0);
 		SET_GAME_STATE (ZEX_IS_DEAD, 1);
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else if (PLAYER_SAID (R, try_any_way))
 	{
@@ -290,7 +290,7 @@ CombatIsInevitable (RESPONSE_REF R)
 	{
 		NPCPhrase (GOODBYE_ZEX);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
@@ -376,13 +376,13 @@ Menagerie (RESPONSE_REF R)
 	{
 		NPCPhrase (FIGHT_AGAIN);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, regardless))
 	{
 		NPCPhrase (THEN_FIGHT);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 		SET_GAME_STATE (ZEX_STACK_3, 2);
 		SET_GAME_STATE (ZEX_VISITS, 0);
 	}
@@ -696,7 +696,7 @@ Intro (void)
 	{
 		NPCPhrase (OUT_TAKES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
@@ -784,11 +784,11 @@ init_vux_comm (void)
 	if ((GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 6))
 			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	retval = &vux_desc;
 
diff -ruNp src.orig/uqm/comm/yehat/Makeinfo src/uqm/comm/yehat/Makeinfo
--- src.orig/uqm/comm/yehat/Makeinfo	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/yehat/Makeinfo	2017-11-21 19:39:54 -0600
@@ -1 +1,2 @@
 uqm_CFILES="yehatc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.orig/uqm/comm/yehat/resinst.h src/uqm/comm/yehat/resinst.h
--- src.orig/uqm/comm/yehat/resinst.h	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/yehat/resinst.h	2017-11-21 19:39:54 -0600
@@ -1,7 +1,12 @@
-#define YEHAT_PMAP_ANIM "comm.yehat.graphics"
-#define YEHAT_FONT "comm.yehat.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define REBEL_CONVERSATION_PHRASES "comm.yehat.rebel.dialogue"
+#define REBEL_MUSIC "comm.yehat.rebel.music"
 #define YEHAT_COLOR_MAP "comm.yehat.colortable"
 #define YEHAT_CONVERSATION_PHRASES "comm.yehat.dialogue"
-#define REBEL_MUSIC "comm.yehat.rebel.music"
+#define YEHAT_FONT "comm.yehat.font"
 #define YEHAT_MUSIC "comm.yehat.music"
+#define YEHAT_PMAP_ANIM "comm.yehat.graphics"
+#define YEHAT_SCRIPT "comm.yehat.script"
diff -ruNp src.orig/uqm/comm/yehat/strings.h src/uqm/comm/yehat/strings.h
--- src.orig/uqm/comm/yehat/strings.h	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/yehat/strings.h	2017-11-21 19:39:54 -0600
@@ -27,10 +27,7 @@ enum
 	whats_up_homeworld,
 	GENERAL_INFO_HOMEWORLD_1,
 	GENERAL_INFO_HOMEWORLD_2,
-	i_demand_you_ally_homeworld0,
-	i_demand_you_ally_homeworld1,
-	i_demand_you_ally_homeworld2,
-	i_demand_you_ally_homeworld3,
+	i_demand_you_ally_homeworld,
 	ENEMY_MUST_DIE,
 	at_least_help_us_homeworld,
 	NO_HELP_ENEMY,
@@ -53,10 +50,7 @@ enum
 	GENERAL_INFO_SPACE_3,
 	whats_up_space_4,
 	GENERAL_INFO_SPACE_4,
-	i_demand_you_ally_space0,
-	i_demand_you_ally_space1,
-	i_demand_you_ally_space2,
-	i_demand_you_ally_space3,
+	i_demand_you_ally_space,
 	WE_CANNOT_1,
 	obligation,
 	WE_CANNOT_2,
@@ -94,8 +88,7 @@ enum
 	name_1,
 	name_2,
 	name_3,
-	name_40,
-	name_41,
+	name_4,
 	OUT_TAKES,
 };
 
diff -ruNp src.orig/uqm/comm/yehat/yehatc.c src/uqm/comm/yehat/yehatc.c
--- src.orig/uqm/comm/yehat/yehatc.c	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/yehat/yehatc.c	2017-11-21 19:39:54 -0600
@@ -20,6 +20,7 @@
 #include "resinst.h"
 #include "strings.h"
 
+#include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
 #include "uqm/gameev.h"
 #include "libs/mathlib.h"
@@ -194,13 +195,13 @@ static LOCDATA yehat_desc =
 static void
 ExitConversation (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 1);
+	setSegue (Segue_hostile);
 
 	if (PLAYER_SAID (R, bye_homeworld))
 		NPCPhrase (GOODBYE_AND_DIE_HOMEWORLD);
 	else if (PLAYER_SAID (R, bye_royalist))
 		NPCPhrase (GOODBYE_AND_DIE_ROYALIST);
-	else if (PLAYER_SAID (R, i_demand_you_ally_homeworld0))
+	else if (PLAYER_SAID (R, i_demand_you_ally_homeworld))
 	{
 		NPCPhrase (ENEMY_MUST_DIE);
 
@@ -214,7 +215,7 @@ ExitConversation (RESPONSE_REF R)
 		{
 			NPCPhrase (GO_IN_PEACE);
 
-			SET_GAME_STATE (BATTLE_SEGUE, 0);
+			setSegue (Segue_peace);
 		}
 	}
 	else if (PLAYER_SAID (R, not_here)
@@ -235,7 +236,7 @@ ExitConversation (RESPONSE_REF R)
 	{
 		NPCPhrase (WE_REVOLT);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		SET_GAME_STATE (YEHAT_CIVIL_WAR, 1);
 		SET_GAME_STATE (YEHAT_VISITS, 0);
 		SET_GAME_STATE (YEHAT_HOME_VISITS, 0);
@@ -309,7 +310,7 @@ StartRevolt (RESPONSE_REF R)
 	else if (PLAYER_SAID (R, shofixti_alive_2))
 		NPCPhrase (SEND_HIM_OVER_2);
 
-	if (ActivateStarShip (SHOFIXTI_SHIP, ESCORTING_FLAGSHIP))
+	if (HaveEscortShip (SHOFIXTI_SHIP))
 		Response (ok_send, ExitConversation);
 	else
 		Response (not_here, ExitConversation);
@@ -372,23 +373,7 @@ YehatHome (RESPONSE_REF R)
 	if (!GET_GAME_STATE (NO_YEHAT_INFO))
 		Response (give_info, YehatHome);
 	if (!GET_GAME_STATE (NO_YEHAT_ALLY_HOME))
-	{
-		UNICODE buf[ALLIANCE_NAME_BUFSIZE];
-
-		GetAllianceName (buf, name_1);
-		construct_response (
-				shared_phrase_buf,
-				i_demand_you_ally_homeworld0,
-				GLOBAL_SIS (CommanderName),
-				i_demand_you_ally_homeworld1,
-				buf,
-				i_demand_you_ally_homeworld2,
-				GLOBAL_SIS (ShipName),
-				i_demand_you_ally_homeworld3,
-				(UNICODE*)NULL);
-		DoResponsePhrase (i_demand_you_ally_homeworld0,
-				ExitConversation, shared_phrase_buf);
-	}
+		Response (i_demand_you_ally_homeworld, ExitConversation);
 	Response (bye_homeworld, ExitConversation);
 }
 
@@ -428,7 +413,7 @@ YehatSpace (RESPONSE_REF R)
 
 		DISABLE_PHRASE (whats_up_space_1);
 	}
-	else if (PLAYER_SAID (R, i_demand_you_ally_space0))
+	else if (PLAYER_SAID (R, i_demand_you_ally_space))
 	{
 		NPCPhrase (WE_CANNOT_1);
 
@@ -439,7 +424,7 @@ YehatSpace (RESPONSE_REF R)
 	{
 		NPCPhrase (WE_CANNOT_2);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		SET_GAME_STATE (NO_YEHAT_ALLY_SPACE, 2);
 
 		return;
@@ -499,20 +484,7 @@ YehatSpace (RESPONSE_REF R)
 	{
 		case 0:
 		{
-			UNICODE buf[ALLIANCE_NAME_BUFSIZE];
-
-			GetAllianceName (buf, name_1);
-			construct_response (
-					shared_phrase_buf,
-					i_demand_you_ally_space0,
-					GLOBAL_SIS (CommanderName),
-					i_demand_you_ally_space1,
-					GLOBAL_SIS (ShipName),
-					i_demand_you_ally_space2,
-					buf,
-					i_demand_you_ally_space3,
-					(UNICODE*)NULL);
-			pStr[2] = i_demand_you_ally_space0;
+			pStr[2] = i_demand_you_ally_space;
 			break;
 		}
 		case 1:
@@ -521,21 +493,11 @@ YehatSpace (RESPONSE_REF R)
 	}
 
 	if (pStr[LastStack])
-	{
-		if (pStr[LastStack] != i_demand_you_ally_space0)
-			Response (pStr[LastStack], YehatSpace);
-		else
-			DoResponsePhrase (pStr[LastStack], YehatSpace, shared_phrase_buf);
-	}
+		Response (pStr[LastStack], YehatSpace);
 	for (i = 0; i < 3; ++i)
 	{
 		if (i != LastStack && pStr[i])
-		{
-			if (pStr[i] != i_demand_you_ally_space0)
-				Response (pStr[i], YehatSpace);
-			else
-				DoResponsePhrase (pStr[i], YehatSpace, shared_phrase_buf);
-		}
+			Response (pStr[i], YehatSpace);
 	}
 	if (!GET_GAME_STATE (YEHAT_ROYALIST_TOLD_PKUNK)
 			&& GET_GAME_STATE (PKUNK_VISITS)
@@ -565,7 +527,7 @@ Intro (void)
 	{
 		NPCPhrase (OUT_TAKES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
@@ -649,6 +611,7 @@ Intro (void)
 static COUNT
 uninit_yehat (void)
 {
+	luaUqm_comm_uninit();
 	return (0);
 }
 
@@ -667,17 +630,21 @@ init_yehat_comm (void)
 	yehat_desc.post_encounter_func = post_yehat_enc;
 	yehat_desc.uninit_encounter_func = uninit_yehat;
 
+	luaUqm_comm_init(NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	yehat_desc.AlienTextBaseline.x = SIS_SCREEN_WIDTH * 2 / 3;
 	yehat_desc.AlienTextBaseline.y = 60;
 	yehat_desc.AlienTextWidth = (SIS_TEXT_WIDTH - 16) * 2 / 3;
 
 	if (LOBYTE (GLOBAL (CurrentActivity)) != WON_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	retval = &yehat_desc;
 
diff -ruNp src.orig/uqm/comm/zoqfot/Makeinfo src/uqm/comm/zoqfot/Makeinfo
--- src.orig/uqm/comm/zoqfot/Makeinfo	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/zoqfot/Makeinfo	2017-11-21 19:39:54 -0600
@@ -1 +1,2 @@
 uqm_CFILES="zoqfotc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.orig/uqm/comm/zoqfot/resinst.h src/uqm/comm/zoqfot/resinst.h
--- src.orig/uqm/comm/zoqfot/resinst.h	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/zoqfot/resinst.h	2017-11-21 19:39:54 -0600
@@ -1,5 +1,10 @@
-#define ZOQFOTPIK_PMAP_ANIM "comm.zoqfotpik.graphics"
-#define ZOQFOTPIK_FONT "comm.zoqfotpik.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define ZOQFOTPIK_COLOR_MAP "comm.zoqfotpik.colortable"
 #define ZOQFOTPIK_CONVERSATION_PHRASES "comm.zoqfotpik.dialogue"
+#define ZOQFOTPIK_FONT "comm.zoqfotpik.font"
 #define ZOQFOTPIK_MUSIC "comm.zoqfotpik.music"
+#define ZOQFOTPIK_PMAP_ANIM "comm.zoqfotpik.graphics"
+#define ZOQFOTPIK_SCRIPT "comm.zoqfotpik.script"
diff -ruNp src.orig/uqm/comm/zoqfot/strings.h src/uqm/comm/zoqfot/strings.h
--- src.orig/uqm/comm/zoqfot/strings.h	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/zoqfot/strings.h	2017-11-21 19:39:54 -0600
@@ -47,9 +47,7 @@ enum
 	HE_IS5,
 	HE_IS6,
 	HE_IS7,
-	we_are_vindicator0,
-	we_are_vindicator1,
-	we_are_vindicator2,
+	we_are_vindicator,
 	WE_GLAD0,
 	WE_GLAD1,
 	WE_GLAD2,
@@ -343,8 +341,7 @@ enum
 	name_1,
 	name_2,
 	name_3,
-	name_40,
-	name_41,
+	name_4,
 	OUT_TAKES0,
 	OUT_TAKES1,
 	OUT_TAKES2,
diff -ruNp src.orig/uqm/comm/zoqfot/zoqfotc.c src/uqm/comm/zoqfot/zoqfotc.c
--- src.orig/uqm/comm/zoqfot/zoqfotc.c	2017-11-21 19:39:37 -0600
+++ src/uqm/comm/zoqfot/zoqfotc.c	2017-11-21 19:39:54 -0600
@@ -20,6 +20,7 @@
 #include "resinst.h"
 #include "strings.h"
 
+#include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
 #include "uqm/gameev.h"
 
@@ -118,15 +119,12 @@ enum
 
 static int LastAlien;
 
+// Queued and executes synchronously on the Starcon2Main thread
 static void
-SelectAlienZOQ (void)
+SelectAlienZOQ (CallbackArg arg)
 {
 	if (LastAlien != ZOQ_ALIEN)
 	{
-		// XXX: This should hold the GraphicsLock to block comm anims and
-		//   prevent CommData half-updates, but if we do so, the stream
-		//   decoder will deadlock with the drawing thread.
-
 		// Transition to neutral state first if Pik was talking
 		if (LastAlien != FOT_ALIEN)
 			CommData.AlienTransitionDesc.AnimFlags |= TALK_DONE;
@@ -142,17 +140,16 @@ SelectAlienZOQ (void)
 		CommData.AlienTextFColor = ZOQ_FG_COLOR;
 		CommData.AlienTextBColor = ZOQ_BG_COLOR;
 	}
+
+	(void)arg; // ignored
 }
 
+// Queued and executes synchronously on the Starcon2Main thread
 static void
-SelectAlienPIK (void)
+SelectAlienPIK (CallbackArg arg)
 {
 	if (LastAlien != PIK_ALIEN)
 	{
-		// XXX: This should hold the GraphicsLock to block comm anims and
-		//   prevent CommData half-updates, but if we do so, the stream
-		//   decoder will deadlock with the drawing thread.
-
 		// Transition to neutral state first if Zoq was talking
 		if (LastAlien != FOT_ALIEN)
 			CommData.AlienTransitionDesc.AnimFlags |= TALK_DONE;
@@ -168,20 +165,22 @@ SelectAlienPIK (void)
 		CommData.AlienTextFColor = PIK_FG_COLOR;
 		CommData.AlienTextBColor = PIK_BG_COLOR;
 	}
+
+	(void)arg; // ignored
 }
 
 static void
 ZFPTalkSegue (COUNT wait_track)
 {
 	LastAlien = FOT_ALIEN;
-	SelectAlienZOQ ();
+	SelectAlienZOQ (0);
 	AlienTalkSegue (wait_track);
 }
 
 static void
 ExitConversation (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 
 	if (PLAYER_SAID (R, bye_homeworld))
 	{
@@ -224,7 +223,7 @@ ExitConversation (RESPONSE_REF R)
 		NPCPhrase_cb (WE_ALLY4, &SelectAlienZOQ);
 		NPCPhrase_cb (WE_ALLY5, &SelectAlienPIK);
 		ZFPTalkSegue ((COUNT)~0);
-		ActivateStarShip (ZOQFOTPIK_SHIP, SET_ALLIED);
+		SetRaceAllied (ZOQFOTPIK_SHIP, TRUE);
 		AddEvent (RELATIVE_EVENT, 3, 0, 0, ZOQFOT_DISTRESS_EVENT);
 		SET_GAME_STATE (ZOQFOT_HOME_VISITS, 0);
 	}
@@ -238,7 +237,7 @@ ExitConversation (RESPONSE_REF R)
 
 		SET_GAME_STATE (ZOQFOT_HOSTILE, 1);
 		SET_GAME_STATE (ZOQFOT_HOME_VISITS, 0);
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, never))
 	{
@@ -248,7 +247,7 @@ ExitConversation (RESPONSE_REF R)
 
 		SET_GAME_STATE (ZOQFOT_HOME_VISITS, 0);
 		SET_GAME_STATE (ZOQFOT_HOSTILE, 1);
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 }
 
@@ -272,7 +271,7 @@ FormAlliance (RESPONSE_REF R)
 static void
 ZoqFotIntro (RESPONSE_REF R)
 {
-	if (PLAYER_SAID (R, we_are_vindicator0))
+	if (PLAYER_SAID (R, we_are_vindicator))
 	{
 		NPCPhrase_cb (WE_GLAD0, &SelectAlienZOQ);
 		NPCPhrase_cb (WE_GLAD1, &SelectAlienPIK);
@@ -282,7 +281,7 @@ ZoqFotIntro (RESPONSE_REF R)
 		NPCPhrase_cb (WE_GLAD5, &SelectAlienPIK);
 		ZFPTalkSegue ((COUNT)~0);
 		
-		DISABLE_PHRASE (we_are_vindicator0);
+		DISABLE_PHRASE (we_are_vindicator);
 	}
 	else if (PLAYER_SAID (R, your_race))
 	{
@@ -419,25 +418,10 @@ AquaintZoqFot (RESPONSE_REF R)
 		DISABLE_PHRASE (quiet_toadies);
 	}
 
-	if (PHRASE_ENABLED (we_are_vindicator0))
-	{
-		UNICODE buf[ALLIANCE_NAME_BUFSIZE];
-
-		GetAllianceName (buf, name_1);
-		construct_response (
-				shared_phrase_buf,
-				we_are_vindicator0,
-				buf,
-				we_are_vindicator1,
-				GLOBAL_SIS (ShipName),
-				we_are_vindicator2,
-				(UNICODE*)NULL);
-	}
-
 	if (PHRASE_ENABLED (which_fot))
 		Response (which_fot, AquaintZoqFot);
-	if (PHRASE_ENABLED (we_are_vindicator0))
-		DoResponsePhrase (we_are_vindicator0, ZoqFotIntro, shared_phrase_buf);
+	if (PHRASE_ENABLED (we_are_vindicator))
+		Response (we_are_vindicator, ZoqFotIntro);
 	if (PHRASE_ENABLED (quiet_toadies))
 		Response (quiet_toadies, AquaintZoqFot);
 	Response (all_very_interesting, ExitConversation);
@@ -735,7 +719,7 @@ ZoqFotHome (RESPONSE_REF R)
 		NPCPhrase_cb (GOOD9, &SelectAlienPIK);
 		ZFPTalkSegue ((COUNT)~0);
 
-		ActivateStarShip (ZOQFOTPIK_SHIP, SET_ALLIED);
+		SetRaceAllied (ZOQFOTPIK_SHIP, TRUE);
 		AddEvent (RELATIVE_EVENT, 3, 0, 0, ZOQFOT_DISTRESS_EVENT);
 	}
 	else if (PLAYER_SAID (R, enough_info))
@@ -748,7 +732,7 @@ ZoqFotHome (RESPONSE_REF R)
 		Response (whats_up_homeworld, ZoqFotHome);
 	if (PHRASE_ENABLED (any_war_news))
 		Response (any_war_news, ZoqFotHome);
-	if (ActivateStarShip (ZOQFOTPIK_SHIP, CHECK_ALLIANCE) != GOOD_GUY)
+	if (CheckAlliance (ZOQFOTPIK_SHIP) != GOOD_GUY)
 		Response (i_want_alliance, ZoqFotHome);
 	else if (PHRASE_ENABLED (want_specific_info))
 	{
@@ -779,7 +763,7 @@ Intro (void)
 		NPCPhrase_cb (OUT_TAKES12, &SelectAlienZOQ);
 		NPCPhrase_cb (OUT_TAKES13, &SelectAlienPIK);
 		ZFPTalkSegue ((COUNT)~0);
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
@@ -816,7 +800,7 @@ Intro (void)
 		}
 		SET_GAME_STATE (ZOQFOT_HOME_VISITS, NumVisits);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (!GET_GAME_STATE (MET_ZOQFOT))
 	{
@@ -870,12 +854,12 @@ Intro (void)
 			ZFPTalkSegue ((COUNT)~0);
 
 			SET_GAME_STATE (ZOQFOT_DISTRESS, 0);
-			ActivateStarShip (ZOQFOTPIK_SHIP, MAX_ZFP_SHIPS);
+			AddEscortShips (ZOQFOTPIK_SHIP, MAX_ZFP_SHIPS);
 		}
 		else
 		{
 			NumVisits = GET_GAME_STATE (ZOQFOT_HOME_VISITS);
-			if (ActivateStarShip (ZOQFOTPIK_SHIP, CHECK_ALLIANCE) != GOOD_GUY)
+			if (CheckAlliance (ZOQFOTPIK_SHIP) != GOOD_GUY)
 			{
 				switch (NumVisits++)
 				{
@@ -940,6 +924,7 @@ Intro (void)
 static COUNT
 uninit_zoqfot (void)
 {
+	luaUqm_comm_uninit ();
 	return (0);
 }
 
@@ -958,16 +943,20 @@ init_zoqfot_comm (void)
 	zoqfot_desc.post_encounter_func = post_zoqfot_enc;
 	zoqfot_desc.uninit_encounter_func = uninit_zoqfot;
 
+	luaUqm_comm_init (NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	zoqfot_desc.AlienTextWidth = (SIS_TEXT_WIDTH >> 1) - TEXT_X_OFFS;
 
-	if (ActivateStarShip (ZOQFOTPIK_SHIP, CHECK_ALLIANCE) == GOOD_GUY
+	if (CheckAlliance (ZOQFOTPIK_SHIP) == GOOD_GUY
 			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	
 	retval = &zoqfot_desc;
diff -ruNp src.orig/uqm/comm.c src/uqm/comm.c
--- src.orig/uqm/comm.c	2017-11-21 19:39:37 -0600
+++ src/uqm/comm.c	2017-11-21 19:39:54 -0600
@@ -27,16 +27,18 @@
 #include "sis.h"
 #include "units.h"
 #include "encount.h"
+#include "starmap.h"
 #include "endian_uqm.h"
 #include "gamestr.h"
 #include "options.h"
-#include "load.h"
 #include "oscill.h"
+#include "save.h"
 #include "settings.h"
 #include "setup.h"
 #include "sounds.h"
 #include "nameref.h"
 #include "uqmdebug.h"
+#include "lua/luacomm.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/inplib.h"
 #include "libs/sound/sound.h"
@@ -46,8 +48,7 @@
 #include <ctype.h>
 
 #define MAX_RESPONSES 8
-#define BACKGROUND_VOL \
-		(speechVolumeScale == 0.0f ? NORMAL_VOLUME : (NORMAL_VOLUME >> 1))
+#define BACKGROUND_VOL (usingSpeech ? (NORMAL_VOLUME / 2) : NORMAL_VOLUME)
 #define FOREGROUND_VOL NORMAL_VOLUME
 
 // Oscilloscope frame rate
@@ -77,6 +78,7 @@ typedef struct response_entry
 	RESPONSE_REF response_ref;
 	TEXT response_text;
 	RESPONSE_FUNC response_func;
+	char *allocedResponse;
 } RESPONSE_ENTRY;
 
 typedef struct encounter_state
@@ -632,13 +634,11 @@ DoTalkSegue (TALKING_STATE *pTS)
 		CheckSubtitles ();
 	}
 
-	LockMutex (GraphicsLock);
 	// XXX: When seeking, all animations (talking and ambient) stop
 	// progressing. This is an original 3DO behavior, and I see no
 	// reason why the animations cannot continue while seeking.
 	UpdateAnimations (pTS->seeking);
 	UpdateSpeechGraphics ();
-	UnlockMutex (GraphicsLock);
 
 	curTrack = PlayingTrack ();
 	pTS->ended = !pTS->seeking && !curTrack;
@@ -653,9 +653,7 @@ DoTalkSegue (TALKING_STATE *pTS)
 static void
 runCommAnimFrame (void)
 {
-	LockMutex (GraphicsLock);
 	UpdateCommGraphics ();
-	UnlockMutex (GraphicsLock);
 	SleepThread (COMM_ANIM_RATE);
 }
 
@@ -687,7 +685,6 @@ TalkSegue (COUNT wait_track)
 	else if (!PlayingTrack ())
 	{	// initial start of player
 		PlayTrack ();
-		assert (PlayingTrack ());
 	}
 
 	// Run the talking controls
@@ -764,13 +761,11 @@ AlienTalkSegue (COUNT wait_track)
 	if (!pCurInputState->Initialized)
 	{
 		InitSpeechGraphics ();
-		LockMutex (GraphicsLock);
 		SetColorMap (GetColorMapAddress (CommData.AlienColorMap));
 		SetContext (AnimContext);
 		DrawAlienFrame (NULL, 0, TRUE);
 		UpdateSpeechGraphics ();
 		CommIntroTransition ();
-		UnlockMutex (GraphicsLock);
 		
 		pCurInputState->Initialized = TRUE;
 
@@ -845,7 +840,6 @@ DoConvSummary (SUMMARY_STATE *pSS)
 		r.extent.width = SIS_SCREEN_WIDTH;
 		r.extent.height = SIS_SCREEN_HEIGHT - SLIDER_Y - SLIDER_HEIGHT + 2;
 
-		LockMutex (GraphicsLock);
 		SetContext (AnimContext);
 		SetContextForeGroundColor (COMM_HISTORY_BACKGROUND_COLOR);
 		DrawFilledRectangle (&r);
@@ -914,7 +908,6 @@ DoConvSummary (SUMMARY_STATE *pSS)
 			font_DrawText (&mt);
 		}
 
-		UnlockMutex (GraphicsLock);
 
 		pSS->PrintNext = FALSE;
 	}
@@ -926,6 +919,21 @@ DoConvSummary (SUMMARY_STATE *pSS)
 	return TRUE; // keep going
 }
 
+static void
+ClearResponses (ENCOUNTER_STATE *pES)
+{
+	size_t responseI;
+
+	for (responseI = 0; responseI < MAX_RESPONSES; responseI++) {
+		RESPONSE_ENTRY *response = &pES->response_list[responseI];
+		if (response->allocedResponse != NULL)
+		{
+			HFree (response->allocedResponse);
+			response->allocedResponse = NULL;
+		}
+	}
+}
+
 // Called when the player presses the select button on a response.
 static void
 SelectResponse (ENCOUNTER_STATE *pES)
@@ -934,9 +942,7 @@ SelectResponse (ENCOUNTER_STATE *pES)
 			&pES->response_list[pES->cur_response].response_text;
 	utf8StringCopy (pES->phrase_buf, sizeof pES->phrase_buf,
 			response_text->pStr);
-	LockMutex (GraphicsLock);
 	FeedbackPlayerPhrase (pES->phrase_buf);
-	UnlockMutex (GraphicsLock);
 	StopTrack ();
 	ClearSubtitles ();
 	SetSliderImage (SetAbsFrameIndex (ActivityFrame, 2));
@@ -945,6 +951,7 @@ SelectResponse (ENCOUNTER_STATE *pES)
 
 	TalkingFinished = FALSE;
 	pES->num_responses = 0;
+	ClearResponses (pES);
 	(*pES->response_list[pES->cur_response].response_func)
 			(pES->response_list[pES->cur_response].response_ref);
 }
@@ -955,29 +962,23 @@ SelectConversationSummary (ENCOUNTER_STA
 {
 	SUMMARY_STATE SummaryState;
 	
-	LockMutex (GraphicsLock);
 	if (pES)
 		FeedbackPlayerPhrase (pES->phrase_buf);
-	UnlockMutex (GraphicsLock);
 
 	SummaryState.Initialized = FALSE;
 	DoConvSummary (&SummaryState);
 
-	LockMutex (GraphicsLock);
 	if (pES)
 		RefreshResponses (pES);
 	clear_subtitles = TRUE;
-	UnlockMutex (GraphicsLock);
 }
 
 static void
 SelectReplay (ENCOUNTER_STATE *pES)
 {
 	FadeMusic (BACKGROUND_VOL, ONE_SECOND);
-	LockMutex (GraphicsLock);
 	if (pES)
 		FeedbackPlayerPhrase (pES->phrase_buf);
-	UnlockMutex (GraphicsLock);
 
 	TalkSegue (0);
 }
@@ -990,9 +991,7 @@ PlayerResponseInput (ENCOUNTER_STATE *pE
 	if (pES->top_response == (BYTE)~0)
 	{
 		pES->top_response = 0;
-		LockMutex (GraphicsLock);
 		RefreshResponses (pES);
-		UnlockMutex (GraphicsLock);
 	}
 
 	if (PulsedInputState.menu[KEY_MENU_SELECT])
@@ -1013,9 +1012,7 @@ PlayerResponseInput (ENCOUNTER_STATE *pE
 
 			if (!(GLOBAL (CurrentActivity) & CHECK_ABORT))
 			{
-				LockMutex (GraphicsLock);
 				RefreshResponses (pES);
-				UnlockMutex (GraphicsLock);
 				FadeMusic (FOREGROUND_VOL, ONE_SECOND);
 			}
 		}
@@ -1029,7 +1026,6 @@ PlayerResponseInput (ENCOUNTER_STATE *pE
 		{
 			COORD y;
 
-			LockMutex (GraphicsLock);
 			BatchGraphics ();
 			add_text (-2,
 					&pES->response_list[pES->cur_response].response_text);
@@ -1049,12 +1045,9 @@ PlayerResponseInput (ENCOUNTER_STATE *pE
 				RefreshResponses (pES);
 			}
 			UnbatchGraphics ();
-			UnlockMutex (GraphicsLock);
 		}
 
-		LockMutex (GraphicsLock);
 		UpdateCommGraphics ();
-		UnlockMutex (GraphicsLock);
 
 		SleepThreadUntil (pES->NextTime);
 		pES->NextTime = GetTimeCounter () + COMM_ANIM_RATE;
@@ -1094,9 +1087,7 @@ DoLastReplay (LAST_REPLAY_STATE *pLRS)
 		pLRS->TimeOut = FadeMusic (0, ONE_SECOND * 2) + ONE_SECOND / 60;
 	}
 
-	LockMutex (GraphicsLock);
 	UpdateCommGraphics ();
-	UnlockMutex (GraphicsLock);
 	
 	SleepThreadUntil (pLRS->NextTime);
 	pLRS->NextTime = GetTimeCounter () + COMM_ANIM_RATE;
@@ -1135,11 +1126,9 @@ DoCommunication (ENCOUNTER_STATE *pES)
 		return TRUE;
 	}
 
-	LockMutex (GraphicsLock);
 	SetContext (SpaceContext);
 	DestroyContext (AnimContext);
 	AnimContext = NULL;
-	UnlockMutex (GraphicsLock);
 
 	FlushColorXForms ();
 	ClearSubtitles ();
@@ -1181,13 +1170,15 @@ DoResponsePhrase (RESPONSE_REF R, RESPON
 				(COUNT) (R - 1));
 		pEntry->response_text.pStr =
 				(UNICODE *) GetStringAddress (locString);
-		pEntry->response_text.CharCount = GetStringLength (locString);
-//#define BVT_PROBLEM
-#ifdef BVT_PROBLEM
-		if (pEntry->response_text.pStr[pEntry->response_text.CharCount - 1]
-				== '\0')
-			--pEntry->response_text.CharCount;
-#endif /* BVT_PROBLEM */
+
+		if (luaUqm_comm_stringNeedsInterpolate (pEntry->response_text.pStr))
+		{
+			pEntry->allocedResponse = luaUqm_comm_stringInterpolate(
+					pEntry->response_text.pStr);
+			pEntry->response_text.pStr = pEntry->allocedResponse;
+		}
+
+		pEntry->response_text.CharCount = (COUNT)~0;
 	}
 	pEntry->response_func = response_func;
 	++pES->num_responses;
@@ -1228,7 +1219,6 @@ HailAlien (void)
 	SubtitleText.baseline = CommData.AlienTextBaseline;
 	SubtitleText.align = CommData.AlienTextAlign;
 
-	LockMutex (GraphicsLock);
 
 	// init subtitle cache context
 	TextCacheContext = CreateContext ("TextCacheContext");
@@ -1293,7 +1283,6 @@ HailAlien (void)
 		DrawSISComWindow ();
 	}
 
-	UnlockMutex (GraphicsLock);
 
 	LastActivity |= CHECK_LOAD; /* prevent spurious input */
 	(*CommData.init_encounter_func) ();
@@ -1302,10 +1291,9 @@ HailAlien (void)
 		(*CommData.post_encounter_func) ();
 	(*CommData.uninit_encounter_func) ();
 
-	LockMutex (GraphicsLock);
+	ClearResponses (&ES);
 	SetContext (SpaceContext);
 	SetContextFont (OldFont);
-	UnlockMutex (GraphicsLock);
 
 	DestroyStringTable (ReleaseStringTable (CommData.ConversationPhrases));
 	DestroyMusic (CommData.AlienSong);
@@ -1343,7 +1331,6 @@ InitCommunication (CONVERSATION which_co
 		return 0;
 #endif
 	
-	LockMutex (GraphicsLock);
 
 	if (LastActivity & CHECK_LOAD)
 	{
@@ -1360,7 +1347,7 @@ InitCommunication (CONVERSATION which_co
 				RepairSISBorder ();
 			}
 			DrawSISMessage (NULL);
-			if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+			if (inHQSpace ())
 				DrawHyperCoords (GLOBAL (ShipStamp.origin));
 			else if (GLOBAL (ip_planet) == 0)
 				DrawHyperCoords (CurStarDescPtr->star_pt);
@@ -1369,7 +1356,6 @@ InitCommunication (CONVERSATION which_co
 		}
 	}
 
-	UnlockMutex (GraphicsLock);
 
 	if (which_comm == URQUAN_DRONE_CONVERSATION)
 	{
@@ -1394,7 +1380,7 @@ InitCommunication (CONVERSATION which_co
 				status = HUMAN_SHIP;
 			}
 		}
-		ActivateStarShip (status, SPHERE_TRACKING);
+		StartSphereTracking (status);
 
 		if (which_comm == ORZ_CONVERSATION
 				|| (which_comm == TALKING_PET_CONVERSATION
@@ -1402,7 +1388,7 @@ InitCommunication (CONVERSATION which_co
 				|| LOBYTE (GLOBAL (CurrentActivity)) == IN_LAST_BATTLE))
 				|| (which_comm != CHMMR_CONVERSATION
 				&& which_comm != SYREEN_CONVERSATION
-				))//&& ActivateStarShip (status, CHECK_ALLIANCE) == BAD_GUY))
+				))//&& CheckAlliance (status) == BAD_GUY))
 			BuildBattle (NPC_PLAYER_NUM);
 	}
 
@@ -1526,7 +1512,7 @@ RaceCommunication (void)
 		SET_GAME_STATE (ESCAPE_COUNTER, ec);
 		return;
 	}
-	else if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+	else if (inHQSpace ())
 	{
 		ReinitQueue (&GLOBAL (npc_built_ship_q));
 		if (GET_GAME_STATE (ARILOU_SPACE_SIDE) >= 2)
@@ -1537,7 +1523,6 @@ RaceCommunication (void)
 		else
 		{
 			/* Encounter with a black globe in HS, prepare enemy ship list */
-			COUNT NumShips;
 			ENCOUNTER *EncounterPtr;
 
 			// The encounter globe that the flagship collided with is moved
@@ -1545,10 +1530,9 @@ RaceCommunication (void)
 			hEncounter = GetHeadEncounter ();
 			LockEncounter (hEncounter, &EncounterPtr);
 
-			NumShips = LONIBBLE (EncounterPtr->SD.Index);
-			for (i = 0; i < NumShips; ++i)
+			for (i = 0; i < EncounterPtr->num_ships; ++i)
 			{
-				CloneShipFragment (EncounterPtr->SD.Type,
+				CloneShipFragment (EncounterPtr->race_id,
 						&GLOBAL (npc_built_ship_q),
 						EncounterPtr->ShipList[i].crew_level);
 			}
@@ -1589,12 +1573,11 @@ RaceCommunication (void)
 
 		LockEncounter (hEncounter, &EncounterPtr);
 
-		NumShips = (BYTE)CountLinks (&GLOBAL (npc_built_ship_q));
-		EncounterPtr->SD.Index = MAKE_BYTE (NumShips,
-				HINIBBLE (EncounterPtr->SD.Index));
-		EncounterPtr->SD.Index |= ENCOUNTER_REFORMING;
+		NumShips = CountLinks (&GLOBAL (npc_built_ship_q));
+		EncounterPtr->num_ships = NumShips;
+		EncounterPtr->flags |= ENCOUNTER_REFORMING;
 		if (status == 0)
-			EncounterPtr->SD.Index |= ONE_SHOT_ENCOUNTER;
+			EncounterPtr->flags |= ONE_SHOT_ENCOUNTER;
 
 		for (i = 0; i < NumShips; ++i)
 		{
diff -ruNp src.orig/uqm/comm.h src/uqm/comm.h
--- src.orig/uqm/comm.h	2017-11-21 19:39:37 -0600
+++ src/uqm/comm.h	2017-11-21 19:39:54 -0600
@@ -31,6 +31,10 @@
 
 #include "commanim.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern LOCDATA CommData;
 
 static inline BOOLEAN
@@ -131,6 +135,10 @@ extern void SetCommIntroMode (CommIntroM
 
 extern void EnableTalkingAnim (BOOLEAN enable);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _COMM_H */
 
 
diff -ruNp src.orig/uqm/commanim.h src/uqm/commanim.h
--- src.orig/uqm/commanim.h	2017-11-21 19:39:37 -0600
+++ src/uqm/commanim.h	2017-11-21 19:39:54 -0600
@@ -20,6 +20,10 @@
 #include "libs/compiler.h"
 #include "libs/gfxlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 // Some background: every animation has a neutral frame which returns
 // the image to the state it was in before the animation began. Which
 // frame is neutral depends on the animation type.
@@ -130,6 +134,10 @@ extern BOOLEAN DrawAlienFrame (SEQUENCE
 extern void InitCommAnimations (void);
 extern BOOLEAN ProcessCommAnimations (BOOLEAN fullRedraw, BOOLEAN paused);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _COMMANIM_H */
 
 
diff -ruNp src.orig/uqm/commglue.c src/uqm/commglue.c
--- src.orig/uqm/commglue.c	2017-11-21 19:39:37 -0600
+++ src/uqm/commglue.c	2017-11-21 19:39:54 -0600
@@ -18,72 +18,49 @@
 
 #include "commglue.h"
 
+#include "battle.h"
+		// For instantVictory
 #include "races.h"
+#include "lua/luacomm.h"
+#include "libs/log.h"
 
 #include <stdarg.h>
 #include <stdlib.h>
 #include <stddef.h>
 #include <assert.h>
-#include "libs/log.h"
 
 static int NPCNumberPhrase (int number, const char *fmt, UNICODE **ptrack);
 
+// The CallbackFunction is queued and executes synchronously
+// on the Starcon2Main thread
 void
-NPCPhrase_cb (int index,  TFB_TrackCB cb)
+NPCPhrase_cb (int index, CallbackFunction cb)
 {
-	UNICODE *pStr, buf[400];
-	void *pClip, *pTimeStamp;
+	char *pStr;
+	void *pClip;
+	void *pTimeStamp;
+	BOOLEAN isPStrAlloced = FALSE;
+
+	if (index == 0)
+		return;
 
-	switch (index)
+	pStr = (UNICODE *)GetStringAddress (
+			SetAbsStringTableIndex (CommData.ConversationPhrases, index - 1));
+	pClip = GetStringSoundClip (
+			SetAbsStringTableIndex (CommData.ConversationPhrases, index - 1));
+	pTimeStamp = GetStringTimeStamp (
+			SetAbsStringTableIndex (CommData.ConversationPhrases, index - 1));
+		
+	if (luaUqm_comm_stringNeedsInterpolate (pStr))
 	{
-		case GLOBAL_PLAYER_NAME:
-			pStr = GLOBAL_SIS (CommanderName);
-			pClip = 0;
-			pTimeStamp = 0;
-			break;
-		case GLOBAL_SHIP_NAME:
-			pStr = GLOBAL_SIS (ShipName);
-			pClip = 0;
-			pTimeStamp = 0;
-			break;
-		case 0:
-		{
-			return;
-		}
-		default:
-			if (index < 0)
-			{	// One of the alliance name variants
-				COUNT i;
-				STRING S;
-
-				index -= GLOBAL_ALLIANCE_NAME;
-
-				i = GET_GAME_STATE (NEW_ALLIANCE_NAME);
-				S = SetAbsStringTableIndex (CommData.ConversationPhrases, (index - 1) + i);
-				strcpy (buf, (UNICODE *)GetStringAddress (S));
-				if (i == 3)
-					strcat (buf, GLOBAL_SIS (CommanderName));
-
-				pStr = buf;
-				pClip = 0;
-				pTimeStamp = 0;
-			}
-			else
-			{
-				pStr = (UNICODE *)GetStringAddress (
-						SetAbsStringTableIndex (CommData.ConversationPhrases, index - 1)
-						);
-				pClip = GetStringSoundClip (
-						SetAbsStringTableIndex (CommData.ConversationPhrases, index - 1)
-						);
-				pTimeStamp = GetStringTimeStamp (
-						SetAbsStringTableIndex (CommData.ConversationPhrases, index - 1)
-						);
-			}
-			break;
+		pStr = luaUqm_comm_stringInterpolate (pStr);
+		isPStrAlloced = TRUE;
 	}
 
 	SpliceTrack (pClip, pStr, pTimeStamp, cb);
+
+	if (isPStrAlloced)
+		HFree (pStr);
 }
 
 // Special case variant: prevents page breaks.
@@ -236,24 +213,6 @@ NPCNumberPhrase (int number, const char
 }
 
 void
-GetAllianceName (UNICODE *buf, RESPONSE_REF name_1)
-{
-	COUNT i;
-	STRING S;
-
-	i = GET_GAME_STATE (NEW_ALLIANCE_NAME);
-	S = SetAbsStringTableIndex (CommData.ConversationPhrases, (name_1 - 1) + i);
-	// XXX: this should someday be changed so that the function takes
-	//   the buffer size as an argument
-	strcpy (buf, (UNICODE *)GetStringAddress (S));
-	if (i == 3)
-	{
-		strcat (buf, GLOBAL_SIS (CommanderName));
-		strcat (buf, (UNICODE *)GetStringAddress (SetRelStringTableIndex (S, 1)));
-	}
-}
-
-void
 construct_response (UNICODE *buf, int R /* promoted from RESPONSE_REF */, ...)
 {
 	UNICODE *buf_start = buf;
@@ -308,6 +267,48 @@ construct_response (UNICODE *buf, int R
 	}
 }
 
+void
+setSegue (Segue segue)
+{
+	switch (segue)
+	{
+		case Segue_peace:
+			SET_GAME_STATE (BATTLE_SEGUE, 0);
+			break;
+		case Segue_hostile:
+			SET_GAME_STATE (BATTLE_SEGUE, 1);
+			break;
+		case Segue_victory:
+			instantVictory = TRUE;
+			SET_GAME_STATE (BATTLE_SEGUE, 1);
+			break;
+		case Segue_defeat:
+			SET_GAME_STATE (BATTLE_SEGUE, 0);
+			GLOBAL_SIS(CrewEnlisted) = (COUNT)~0;
+			GLOBAL(CurrentActivity) |= CHECK_RESTART;
+			break;
+	}
+}
+
+Segue
+getSegue (void)
+{
+	if (GET_GAME_STATE(BATTLE_SEGUE) == 0) {
+		if (GLOBAL_SIS(CrewEnlisted) == (COUNT)~0 &&
+				(GLOBAL(CurrentActivity) & CHECK_RESTART)) {
+			return Segue_defeat;
+		} else {
+			return Segue_peace;
+		}
+	} else /* GET_GAME_STATE(BATTLE_SEGUE) == 1) */ {
+		if (instantVictory) {
+			return Segue_victory;
+		} else {
+			return Segue_hostile;
+		}
+	}
+}
+
 LOCDATA*
 init_race (CONVERSATION comm_id)
 {
@@ -373,3 +374,27 @@ init_race (CONVERSATION comm_id)
 			return init_chmmr_comm ();
 	}
 }
+
+RESPONSE_REF
+phraseIdStrToNum(const char *phraseIdStr)
+{
+	STRING phrase = GetStringByName (GetStringTable(
+			CommData.ConversationPhrases), phraseIdStr);
+	if (phrase == NULL)
+		return (RESPONSE_REF) -1;
+
+	return GetStringTableIndex (phrase) + 1;
+			// Index 0 is for NULL_PHRASE, hence the '+ 1"
+}
+
+const char *
+phraseIdNumToStr (RESPONSE_REF response)
+{
+	STRING phrase = SetAbsStringTableIndex (
+			CommData.ConversationPhrases, response - 1);
+			// Index 0 is for NULL_PHRASE, hence the '- 1'.
+	if (phrase == NULL)
+		return NULL;
+	return GetStringName (phrase);
+}
+
diff -ruNp src.orig/uqm/commglue.h src/uqm/commglue.h
--- src.orig/uqm/commglue.h	2017-11-21 19:39:37 -0600
+++ src/uqm/commglue.h	2017-11-21 19:39:54 -0600
@@ -22,6 +22,11 @@
 #include "globdata.h"
 #include "resinst.h"
 #include "libs/sound/trackplayer.h"
+#include "libs/callback.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
 typedef enum {
 	ARILOU_CONVERSATION,
@@ -65,37 +70,46 @@ extern UNICODE shared_phrase_buf[2048];
 		(*(UNICODE *)GetStringAddress ( \
 				SetAbsStringTableIndex (CommData.ConversationPhrases, (p)-1) \
 				) = '\0')
-#define RESPONSE_TO_REF(R) (R)
 
 #define Response(i,a) \
 		DoResponsePhrase(i,(RESPONSE_FUNC)a,0)
 
-enum
-{
-	GLOBAL_PLAYER_NAME = -1000000,
-	GLOBAL_SHIP_NAME,
-	GLOBAL_ALLIANCE_NAME,
-};
-
 typedef COUNT RESPONSE_REF;
 
 typedef void (*RESPONSE_FUNC) (RESPONSE_REF R);
 
 extern void DoResponsePhrase (RESPONSE_REF R, RESPONSE_FUNC
 		response_func, UNICODE *ContstructStr);
-extern void DoNPCPhrase (UNICODE *pStr);
 
-extern void NPCPhrase_cb (int index, TFB_TrackCB cb);
+// The CallbackFunction is queued and executes synchronously
+// on the Starcon2Main thread
+extern void NPCPhrase_cb (int index, CallbackFunction cb);
 #define NPCPhrase(index) NPCPhrase_cb ((index), NULL)
 extern void NPCPhrase_splice (int index);
 extern void NPCNumber (int number, const char *fmt);
 
-#define ALLIANCE_NAME_BUFSIZE 256
-extern void GetAllianceName (UNICODE *buf, RESPONSE_REF name_1);
-
 extern void construct_response (UNICODE *buf, int R /* promoted from
 		RESPONSE_REF */, ...);
 
+typedef enum {
+	Segue_peace,
+			// When initiating a conversation, open comms directly.
+			// When terminating a conversation, depart in peace.
+	Segue_hostile,
+			// When initiating a conversation, offer the choice to attack.
+			// When terminating a conversation, go into battle.
+	Segue_victory,
+			// (when terminating a conversation) instant victory
+	Segue_defeat,
+			// (when terminating a conversation) game over
+} Segue;
+
+void setSegue (Segue segue);
+Segue getSegue (void);
+
+extern RESPONSE_REF phraseIdStrToNum(const char *phraseId);
+extern const char *phraseIdNumToStr (RESPONSE_REF response);
+
 extern LOCDATA* init_race (CONVERSATION comm_id);
 
 extern LOCDATA* init_arilou_comm (void);
@@ -154,5 +168,9 @@ extern LOCDATA* init_zoqfot_comm (void);
 
 extern LOCDATA* init_umgah_comm (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _COMMGLUE_H */
 
diff -ruNp src.orig/uqm/confirm.c src/uqm/confirm.c
--- src.orig/uqm/confirm.c	2017-11-21 19:39:37 -0600
+++ src/uqm/confirm.c	2017-11-21 19:39:54 -0600
@@ -83,7 +83,8 @@ DoConfirmExit (void)
 	if (PlayingTrack ())
 		PauseTrack ();
 
-	LockMutex (GraphicsLock);
+	PauseFlash ();
+
 	{
 		RECT r;
 		STAMP s;
@@ -158,7 +159,8 @@ DoConfirmExit (void)
 		SetContextClipRect (&oldRect);
 		SetContext (oldContext);
 	}
-	UnlockMutex (GraphicsLock);
+
+	ContinueFlash ();
 
 	if (PlayingTrack ())
 		ResumeTrack ();
@@ -212,7 +214,7 @@ DoPopupWindow (const char *msg)
 	label.line_count = SplitString (msg, '\n', 30, lines, bank);
 	label.lines = lines;
 
-	LockMutex (GraphicsLock);
+	PauseFlash ();
 
 	oldContext = SetContext (ScreenContext);
 	GetContextClipRect (&oldRect);
@@ -241,7 +243,8 @@ DoPopupWindow (const char *msg)
 	DestroyDrawable (ReleaseDrawable (s.frame));
 	SetContextClipRect (&oldRect);
 	SetContext (oldContext);
-	UnlockMutex (GraphicsLock);
+	ContinueFlash ();
 	SetMenuSounds (s0, s1);
 	StringBank_Free (bank);
 }
+
diff -ruNp src.orig/uqm/cons_res.h src/uqm/cons_res.h
--- src.orig/uqm/cons_res.h	2017-11-21 19:39:37 -0600
+++ src/uqm/cons_res.h	2017-11-21 19:39:54 -0600
@@ -20,6 +20,10 @@
 #include "libs/gfxlib.h"
 #include "libs/sndlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 void load_gravity_well (BYTE selector);
 void free_gravity_well (void);
 
@@ -27,4 +31,8 @@ FRAME load_life_form (BYTE selector);
 
 MUSIC_REF load_orbit_theme (BYTE selector);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* CONS_RES_H_ */
diff -ruNp src.orig/uqm/controls.h src/uqm/controls.h
--- src.orig/uqm/controls.h	2017-11-21 19:39:37 -0600
+++ src/uqm/controls.h	2017-11-21 19:39:54 -0600
@@ -23,6 +23,10 @@
 #include "libs/strlib.h"
 #include "libs/timelib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 // Enumerated type for controls
 enum {
 	KEY_UP,
@@ -115,9 +119,6 @@ BOOLEAN WaitForNoInputUntil (TimeCount t
 void DoPopupWindow(const char *msg);
 
 typedef void (InputFrameCallback) (void);
-// Anything using input callbacks MUST NOT keep GraphicsLock across
-// InputFunc executions. This also means NOT holding GraphicsLock
-// when calling DoInput().
 InputFrameCallback* SetInputCallback (InputFrameCallback *);
 // pInputState must point to a struct derived from INPUT_STATE_DESC
 void DoInput (void *pInputState, BOOLEAN resetInput);
@@ -162,6 +163,10 @@ typedef struct textentry_state
 
 extern BOOLEAN DoTextEntry (TEXTENTRY_STATE *pTES);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif
 
 
diff -ruNp src.orig/uqm/credits.c src/uqm/credits.c
--- src.orig/uqm/credits.c	2017-11-21 19:39:37 -0600
+++ src/uqm/credits.c	2017-11-21 19:39:54 -0600
@@ -240,7 +240,6 @@ Credits_RenderTextFrame (CONTEXT TempCon
 	t.pStr = " ";
 	t.CharCount = 1;
 
-	LockMutex (GraphicsLock);
 	OldContext = SetContext (TempContext);
 
 	// get font dimensions
@@ -312,7 +311,6 @@ Credits_RenderTextFrame (CONTEXT TempCon
 	
 	SetContextFGFrame (OldFrame);
 	SetContext (OldContext);
-	UnlockMutex (GraphicsLock);
 
 	return f;
 }
@@ -331,7 +329,6 @@ RenderCreditsScreen (CONTEXT targetConte
 	STAMP s;
 	int i;
 
-	LockMutex (GraphicsLock);
 	oldContext = SetContext (targetContext);
 	// draw background
 	s.origin.x = 0;
@@ -358,7 +355,6 @@ RenderCreditsScreen (CONTEXT targetConte
 	}
 	
 	SetContext (oldContext);
-	UnlockMutex (GraphicsLock);
 }
 
 static void
@@ -373,7 +369,6 @@ InitCredits (void)
 	LocalContext = CreateContext ("Credits.LocalContext");
 	DrawContext = CreateContext ("Credits.DrawContext");
 
-	LockMutex (GraphicsLock);
 	targetFrame = GetContextFGFrame ();
 	GetContextClipRect (&ctxRect);
 	CreditsExtent = ctxRect.extent;
@@ -402,7 +397,6 @@ InitCredits (void)
 	SetContextFGFrame (targetFrame);
 
 	SetContext (oldContext);
-	UnlockMutex (GraphicsLock);
 
 	// Prepare the first screen frame
 	RenderCreditsScreen (LocalContext);
@@ -493,12 +487,10 @@ processCreditsFrame (void)
 		s.origin.y = 0;
 		s.frame = CreditsFrame;
 
-		LockMutex (GraphicsLock);
 		OldContext = SetContext (DrawContext);
 		DrawStamp (&s);
 		SetContext (OldContext);
 		FlushGraphics ();
-		UnlockMutex (GraphicsLock);
 
 		// prepare next screen frame
 		deficitHeight = calcDeficitHeight ();
@@ -782,13 +774,11 @@ Credits (BOOLEAN WithOuttakes)
 
 	hMusic = LoadMusic (CREDITS_MUSIC);
 
-	LockMutex (GraphicsLock);
 	SetContext (ScreenContext);
 	SetContextClipRect (NULL);
 	GetContextClipRect (&screenRect);
 	SetContextBackGroundColor (BLACK_COLOR);
 	ClearDrawable ();
-	UnlockMutex (GraphicsLock);
 
 	if (!LoadCredits ())
 		return;
@@ -797,10 +787,8 @@ Credits (BOOLEAN WithOuttakes)
 	s.origin.x = 0;
 	s.origin.y = 0;
 	s.frame = CreditsBack;
-	LockMutex (GraphicsLock);
 	DrawStamp (&s);
 	FadeScreen (FadeAllToColor, ONE_SECOND / 2);
-	UnlockMutex (GraphicsLock);
 
 	// set the position of outtakes comm
 	CommWndRect.corner.x = (screenRect.extent.width - CommWndRect.extent.width)
@@ -836,11 +824,9 @@ Credits (BOOLEAN WithOuttakes)
 	FadeMusic (0, ONE_SECOND / 2);
 	UninitCredits ();
 
-	LockMutex (GraphicsLock);
 	SetContext (ScreenContext);
 	SleepThreadUntil (FadeScreen (FadeAllToBlack, ONE_SECOND / 2));
 	FlushColorXForms ();
-	UnlockMutex (GraphicsLock);
 
 	if (hMusic)
 	{
diff -ruNp src.orig/uqm/credits.h src/uqm/credits.h
--- src.orig/uqm/credits.h	2017-11-21 19:39:38 -0600
+++ src/uqm/credits.h	2017-11-21 19:39:54 -0600
@@ -19,7 +19,15 @@
 
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern void Credits (BOOLEAN WithOuttakes);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _CREDITS_H */
 
diff -ruNp src.orig/uqm/cyborg.c src/uqm/cyborg.c
--- src.orig/uqm/cyborg.c	2017-11-21 19:39:38 -0600
+++ src/uqm/cyborg.c	2017-11-21 19:39:54 -0600
@@ -1092,7 +1092,7 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 			if (GRAVITY_MASS (ed.ObjectPtr->mass_points))
 			{
 				COUNT maneuver_turn, ship_bounds;
-				RECT ship_footprint;
+				RECT ship_footprint = {{0, 0}, {0, 0}};
 
 				if (UltraManeuverable)
 					maneuver_turn = 16;
diff -ruNp src.orig/uqm/demo.h src/uqm/demo.h
--- src.orig/uqm/demo.h	2017-11-21 19:39:38 -0600
+++ src/uqm/demo.h	2017-11-21 19:39:54 -0600
@@ -19,6 +19,10 @@
 #ifndef _DEMO_H
 #define _DEMO_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #ifndef DEMO_MODE
 #define DEMO_MODE 0
 #endif /* DEMO_MODE */
@@ -44,5 +48,9 @@ extern void JournalInput (INPUT_STATE In
 
 #endif
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _DEMO_H */
 
diff -ruNp src.orig/uqm/displist.h src/uqm/displist.h
--- src.orig/uqm/displist.h	2017-11-21 19:39:38 -0600
+++ src/uqm/displist.h	2017-11-21 19:39:54 -0600
@@ -24,6 +24,10 @@
 #include "libs/compiler.h"
 #include "libs/memlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 // Note that we MUST use the QUEUE_TABLE variant at this time, because
 // certain gameplay elements depend on it. Namely, the maximum number
 // of HyperSpace encounter globes chasing the player is defined by the
@@ -120,5 +124,9 @@ extern void RemoveQueue (QUEUE *pq, HLIN
 extern COUNT CountLinks (QUEUE *pq);
 void ForAllLinks(QUEUE *pq, void (*callback)(LINK *, void *), void *arg);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _DISPLIST_H */
 
diff -ruNp src.orig/uqm/element.h src/uqm/element.h
--- src.orig/uqm/element.h	2017-11-21 19:39:38 -0600
+++ src/uqm/element.h	2017-11-21 19:39:55 -0600
@@ -24,6 +24,10 @@
 #include "velocity.h"
 #include "libs/gfxlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 
 #define NORMAL_LIFE 1
 
@@ -92,7 +96,8 @@ typedef struct state
 
 typedef struct element ELEMENT;
 
-typedef void (CollisionFunc) (ELEMENT *ElementPtr0, POINT *pPt0,
+typedef void (ElementProcessFunc) (ELEMENT *ElementPtr);
+typedef void (ElementCollisionFunc) (ELEMENT *ElementPtr0, POINT *pPt0,
 			ELEMENT *ElementPtr1, POINT *pPt1);
 
 // Any physical object in the simulation.
@@ -101,10 +106,10 @@ struct element
 	// LINK elements; must be first
 	HELEMENT pred, succ;
 
-	void (*preprocess_func) (struct element *ElementPtr);
-	void (*postprocess_func) (struct element *ElementPtr);
-	CollisionFunc *collision_func;
-	void (*death_func) (struct element *ElementPtr);
+	ElementProcessFunc *preprocess_func;
+	ElementProcessFunc *postprocess_func;
+	ElementCollisionFunc *collision_func;
+	ElementProcessFunc *death_func;
 
 	// Player this element belongs to
 	// -1: neutral (planets, asteroids, crew, etc.)
@@ -230,5 +235,9 @@ extern void MoveGalaxy (VIEW_STATE view_
 extern BOOLEAN CalculateGravity (ELEMENT *ElementPtr);
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _ELEMENT_H */
 
diff -ruNp src.orig/uqm/encount.c src/uqm/encount.c
--- src.orig/uqm/encount.c	2017-11-21 19:39:38 -0600
+++ src/uqm/encount.c	2017-11-21 19:39:55 -0600
@@ -22,6 +22,7 @@
 #include "battlecontrols.h"
 #include "build.h"
 #include "colors.h"
+#include "starmap.h"
 #include "cons_res.h"
 #include "controls.h"
 #include "menustat.h"
@@ -77,9 +78,7 @@ DoSelectAction (MENU_STATE *pMS)
 				if (!GameOptions ())
 					return FALSE;
 				DrawMenuStateStrings (PM_CONVERSE, pMS->CurState);
-				LockMutex (GraphicsLock);
 				SetFlashRect (SFR_MENU_3DO);
-				UnlockMutex (GraphicsLock);
 				break;
 			default:
 				printf ("Unknown option: %d\n", pMS->CurState);
@@ -269,7 +268,6 @@ InitEncounter (void)
 	extern FRAME planet[];
 	MUSIC_REF MR;
 
-	LockMutex (GraphicsLock);
 
 	SetContext (SpaceContext);
 	SetContextFont (TinyFont);
@@ -277,11 +275,9 @@ InitEncounter (void)
 	MR = LoadMusic (REDALERT_MUSIC);
 	PlayMusic (MR, FALSE, 1);
 	SegueFrame = CaptureDrawable (LoadGraphic (SEGUE_PMAP_ANIM));
-	UnlockMutex (GraphicsLock);
 	WaitForSoundEnd (TFBSOUND_WAIT_ALL);
 	StopMusic ();
 	DestroyMusic (MR);
-	LockMutex (GraphicsLock);
 	s.origin.x = s.origin.y = 0;
 
 	SetTransitionSource (NULL);
@@ -300,7 +296,7 @@ InitEncounter (void)
 	SetContextFont (MicroFont);
 	SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01));
-	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+	if (inHQSpace ())
 	{
 		t.pStr = GAME_STRING (ENCOUNTER_STRING_BASE + 0);
 				// "ENCOUNTER IN"
@@ -393,7 +389,6 @@ InitEncounter (void)
 	DestroyDrawable (ReleaseDrawable (SegueFrame));
 	ScreenTransition (3, NULL);
 
-	UnlockMutex (GraphicsLock);
 
 	{
 		MENU_STATE MenuState;
@@ -402,15 +397,11 @@ InitEncounter (void)
 		MenuState.Initialized = FALSE;
 
 		DrawMenuStateStrings (PM_CONVERSE, MenuState.CurState = HAIL);
-		LockMutex (GraphicsLock);
 		SetFlashRect (SFR_MENU_3DO);
-		UnlockMutex (GraphicsLock);
 
 		DoInput (&MenuState, TRUE);
 
-		LockMutex (GraphicsLock);
 		SetFlashRect (NULL);
-		UnlockMutex (GraphicsLock);
 
 		return (MenuState.CurState);
 	}
@@ -450,10 +441,8 @@ DrawFadeText (const UNICODE *str1, const
 	{
 		for (i = 0; i < (SIZE) NUM_FADES; ++i)
 		{
-			UnlockMutex (GraphicsLock);
 			if (AnyButtonPress (TRUE))
 				i = NUM_FADES - 1;
-			LockMutex (GraphicsLock);
 
 			SetContextForeGroundColor (fade_cycle[i]);
 			font_DrawText (&t1);
@@ -466,10 +455,8 @@ DrawFadeText (const UNICODE *str1, const
 	{
 		for (i = NUM_FADES - 1; i >= 0; --i)
 		{
-			UnlockMutex (GraphicsLock);
 			if (AnyButtonPress (TRUE))
 				i = 0;
-			LockMutex (GraphicsLock);
 
 			SetContextForeGroundColor (fade_cycle[i]);
 			font_DrawText (&t1);
@@ -491,7 +478,6 @@ UninitEncounter (void)
 
 	ships_killed = 0;
 
-	LockMutex (GraphicsLock);
 	free_gravity_well ();
 
 	if ((GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD))
@@ -580,7 +566,7 @@ UninitEncounter (void)
 				{
 					DrawSISFrame ();
 					DrawSISMessage (NULL);
-					if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+					if (inHQSpace ())
 						DrawHyperCoords (GLOBAL (ShipStamp.origin));
 					else if (GLOBAL (ip_planet) == 0)
 						DrawHyperCoords (CurStarDescPtr->star_pt);
@@ -701,10 +687,8 @@ UninitEncounter (void)
 								TimeCount Time = GetTimeCounter ();
 								for (j = 0; j < NUM_SHIP_FADES; ++j)
 								{
-									UnlockMutex (GraphicsLock);
 									Sleepy = (BOOLEAN)!AnyButtonPress (TRUE) &&
 											!(GLOBAL (CurrentActivity) & CHECK_ABORT);
-									LockMutex (GraphicsLock);
 									if (!Sleepy)
 										break;
 
@@ -737,9 +721,7 @@ UninitEncounter (void)
 			DestroyDrawable (ReleaseDrawable (s.frame));
 #endif /* NEVER */
 
-			UnlockMutex (GraphicsLock);
 			WaitForAnyButton (TRUE, ONE_SECOND * 3, FALSE);
-			LockMutex (GraphicsLock);
 			if (!CurrentInputState.key[PlayerControls[0]][KEY_ESCAPE])
 			{
 				DrawFadeText (str1, str2, FALSE, &scavenge_r);
@@ -765,9 +747,7 @@ UninitEncounter (void)
 					str2 = GAME_STRING (ENCOUNTER_STRING_BASE + 7);
 							// "Scavenged"
 					DrawFadeText (str1, str2, TRUE, &scavenge_r);
-					UnlockMutex (GraphicsLock);
 					WaitForAnyButton (TRUE, ONE_SECOND * 2, FALSE);
-					LockMutex (GraphicsLock);
 					if (!CurrentInputState.key[PlayerControls[0]][KEY_ESCAPE])
 						DrawFadeText (str1, str2, FALSE, &scavenge_r);
 				}
@@ -786,7 +766,6 @@ UninitEncounter (void)
 		}
 	}
 ExitUninitEncounter:
-	UnlockMutex (GraphicsLock);
 
 	return (ships_killed);
 }
@@ -798,7 +777,6 @@ EncounterBattle (void)
 	extern UWORD nth_frame;
 	InputContext *savedPlayerInput = NULL;
 
-	LockMutex (GraphicsLock);
 
 	SET_GAME_STATE (BATTLE_SEGUE, 1);
 
@@ -837,9 +815,7 @@ EncounterBattle (void)
 
 	GameSounds = CaptureSound (LoadSound (GAME_SOUNDS));
 
-	UnlockMutex (GraphicsLock);
 	Battle (NULL);
-	LockMutex (GraphicsLock);
 
 	DestroySound (ReleaseSound (GameSounds));
 	GameSounds = 0;
@@ -863,6 +839,5 @@ EncounterBattle (void)
 
 	GLOBAL (CurrentActivity) = OldActivity;
 
-	UnlockMutex (GraphicsLock);
 }
 
diff -ruNp src.orig/uqm/encount.h src/uqm/encount.h
--- src.orig/uqm/encount.h	2017-11-21 19:39:38 -0600
+++ src/uqm/encount.h	2017-11-21 19:39:55 -0600
@@ -30,12 +30,24 @@ typedef struct encounter ENCOUNTER;
 #include "element.h"
 #include "races.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 
 typedef HLINK HENCOUNTER;
 
 #define MAX_HYPER_SHIPS 7
+
+// ENCOUNTER.flags
+// XXX: Currently, the flags are combined with num_ships into a single BYTE
+//   in the savegames: num_ships occupy the low nibble and flags the high one.
+//   Bits 4 and 5 are available for more flags in the savegames,
+//   and bits 0-3 available in the game but will not be saved.
 #define ONE_SHOT_ENCOUNTER (1 << 7)
 #define ENCOUNTER_REFORMING (1 << 6)
+#define ENCOUNTER_SHIPS_MASK  0x0f
+#define ENCOUNTER_FLAGS_MASK  0xf0
 
 struct brief_ship_info
 {
@@ -57,9 +69,14 @@ struct encounter
 	SIZE transition_state;
 	POINT origin;
 	COUNT radius;
+	BYTE race_id;
+	BYTE num_ships;
+	BYTE flags;
+			// See ENCOUNTER.flags above
+	POINT loc_pt;
 
-	STAR_DESC SD;
 	BRIEF_SHIP_INFO ShipList[MAX_HYPER_SHIPS];
+			// Only the crew_level member is currently used
 
 	SDWORD log_x, log_y;
 };
@@ -78,76 +95,10 @@ struct encounter
 
 enum
 {
-	SOL_DEFINED = 1,
-	SHOFIXTI_DEFINED,
-	MAIDENS_DEFINED,
-	START_COLONY_DEFINED,
-	SPATHI_DEFINED,
-	ZOQFOT_DEFINED,
-
-	MELNORME0_DEFINED,
-	MELNORME1_DEFINED,
-	MELNORME2_DEFINED,
-	MELNORME3_DEFINED,
-	MELNORME4_DEFINED,
-	MELNORME5_DEFINED,
-	MELNORME6_DEFINED,
-	MELNORME7_DEFINED,
-	MELNORME8_DEFINED,
-
-	TALKING_PET_DEFINED,
-	CHMMR_DEFINED,
-	SYREEN_DEFINED,
-	BURVIXESE_DEFINED,
-	SLYLANDRO_DEFINED,
-	DRUUGE_DEFINED,
-	BOMB_DEFINED,
-	AQUA_HELIX_DEFINED,
-	SUN_DEVICE_DEFINED,
-	TAALO_PROTECTOR_DEFINED,
-	SHIP_VAULT_DEFINED,
-	URQUAN_WRECK_DEFINED,
-	VUX_BEAST_DEFINED,
-	SAMATRA_DEFINED,
-	ZOQ_SCOUT_DEFINED,
-	MYCON_DEFINED,
-	EGG_CASE0_DEFINED,
-	EGG_CASE1_DEFINED,
-	EGG_CASE2_DEFINED,
-	PKUNK_DEFINED,
-	UTWIG_DEFINED,
-	SUPOX_DEFINED,
-	YEHAT_DEFINED,
-	VUX_DEFINED,
-	ORZ_DEFINED,
-	THRADD_DEFINED,
-	RAINBOW_DEFINED,
-	ILWRATH_DEFINED,
-	ANDROSYNTH_DEFINED,
-	MYCON_TRAP_DEFINED
-};
-
-#define UMGAH_DEFINED TALKING_PET_DEFINED
-
-// XXX: The stuff till EOC does not belong here
-extern STAR_DESC *CurStarDescPtr;
-extern STAR_DESC *star_array;
-
-#define NUM_SOLAR_SYSTEMS 502
-
-extern STAR_DESC* FindStar (STAR_DESC *pLastStar, POINT *puniverse,
-		SIZE xbounds, SIZE ybounds);
-
-extern void GetClusterName (const STAR_DESC *pSD, UNICODE buf[]);
-// <<< EOC
-
-enum
-{
 	HAIL = 0,
 	ATTACK
 };
 
-
 extern void EncounterBattle (void);
 extern void BuildBattle (COUNT which_player);
 extern COUNT InitEncounter (void);
@@ -155,40 +106,15 @@ extern COUNT UninitEncounter (void);
 extern BOOLEAN FleetIsInfinite (COUNT playerNr);
 extern void UpdateShipFragCrew (STARSHIP *);
 
-// XXX: in comm.h, temporary, until solsys generation code is redone
-extern COUNT InitCommunication (CONVERSATION which_comm);
-
-extern void GenerateSOL (BYTE control);
-extern void GenerateShofixti (BYTE control);
-extern void GenerateColony (BYTE control);
-extern void GenerateSpathi (BYTE control);
-extern void GenerateZoqFotPik (BYTE control);
-extern void GenerateMelnorme (BYTE control);
-extern void GenerateTalkingPet (BYTE control);
-extern void GenerateChmmr (BYTE control);
-extern void GenerateSyreen (BYTE control);
-extern void GenerateBurvixes (BYTE control);
-extern void GenerateSlylandro (BYTE control);
-extern void GenerateDruuge (BYTE control);
-extern void GenerateUtwig (BYTE control);
-extern void GenerateThradd (BYTE control);
-extern void GenerateMycon (BYTE control);
-extern void GenerateOrz (BYTE control);
-extern void GenerateShipVault (BYTE control);
-extern void GenerateUrquanWreck (BYTE control);
-extern void GenerateVUX (BYTE control);
-extern void GenerateSamatra (BYTE control);
-extern void GenerateYehat (BYTE control);
-extern void GeneratePkunk (BYTE control);
-extern void GenerateSupox (BYTE control);
-extern void GenerateRainbow (BYTE control);
-extern void GenerateIlwrath (BYTE control);
-
 // Last race the player battled with, or -1 if no battle took place.
 // Set to -1 by some funcs to inhibit IP groups from intercepting
 // the flagship.
 extern SIZE EncounterRace;
 extern BYTE EncounterGroup;
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _ENCOUNT_H */
 
diff -ruNp src.orig/uqm/flash.c src/uqm/flash.c
--- src.orig/uqm/flash.c	2017-11-21 19:39:38 -0600
+++ src/uqm/flash.c	2017-11-21 19:39:55 -0600
@@ -18,6 +18,12 @@
 //       areas, drawing directly to the screen, using a cache, are
 //       currently in use.
 
+// NOTE:
+// - If you change the properties of the original CONTEXT, specifically the
+//   dimensions and origin, you'll need to call Flash_preUpdate() before and
+//   Flash_postUpdate() after that change. Note that this may change which
+//   part of the screen is flashing.
+
 // TODO:
 // - During a few frames during the sequence, the frame to be displayed
 //   is equal to a frame which was supplied as a parameter to the flash
@@ -30,8 +36,6 @@
 #define FLASH_INTERNAL
 #include "flash.h"
 
-#include "setup.h"
-		// For GraphicsLock.
 #include "libs/log.h"
 #include "libs/memlib.h"
 #include "libs/threadlib.h"
@@ -211,6 +215,7 @@ Flash_terminate (FlashContext *context)
 		Flash_drawFrame (context, context->original);
 
 		Flash_clearCache (context);
+		HFree (context->cache);
 		DestroyDrawable (ReleaseDrawable (context->original));
 	}
 
@@ -274,37 +279,36 @@ Flash_process (FlashContext *context)
 	
 	now = GetTimeCounter ();
 
-	if (context->state == FlashState_fadeIn)
+	switch (context->state)
 	{
-		if (now >= context->lastStateTime + context->fadeInTime)
-		{
+		case FlashState_fadeIn:
+			if (now >= context->lastStateTime + context->fadeInTime)
+			{
+				Flash_nextState (context);
+				context->lastStateTime = now;
+			}
+			context->lastFrameTime = now;
+			break;
+		case FlashState_on:
+			if (now < context->lastStateTime + context->onTime)
+				return;
 			Flash_nextState (context);
 			context->lastStateTime = now;
-		}
-		context->lastFrameTime = now;
-	}
-	else if (context->state == FlashState_on)
-	{
-		if (now < context->lastStateTime + context->onTime)
-			return;
-		Flash_nextState (context);
-		context->lastStateTime = now;
-	}
-	else if (context->state == FlashState_fadeOut)
-	{
-		if (now >= context->lastStateTime + context->fadeOutTime)
-		{
+			break;
+		case FlashState_fadeOut:
+			if (now >= context->lastStateTime + context->fadeOutTime)
+			{
+				Flash_nextState (context);
+				context->lastStateTime = now;
+			}
+			context->lastFrameTime = now;
+			break;
+		case FlashState_off:
+			if (now < context->lastStateTime + context->offTime)
+				return;
 			Flash_nextState (context);
 			context->lastStateTime = now;
-		}
-		context->lastFrameTime = now;
-	}
-	else /* context->state == FlashState_off */
-	{
-		if (now < context->lastStateTime + context->offTime)
-			return;
-		Flash_nextState (context);
-		context->lastStateTime = now;
+			break;
 	}
 
 	Flash_drawCurrentFrame (context);
@@ -472,7 +476,8 @@ Flash_setOverlay (FlashContext *context,
 	}
 }
 
-// Call before you update the graphics in the currently flashing area.
+// Call before you update the graphics in the currently flashing area,
+// or before you change the dimensions or origin of the graphics context.
 void
 Flash_preUpdate (FlashContext *context)
 {
@@ -483,7 +488,8 @@ Flash_preUpdate (FlashContext *context)
 	}
 }
 
-// Call after you update the graphics in the currently flashing area.
+// Call after you update the graphics in the currently flashing area,
+// or after you change the dimensions or origin of the graphics context.
 void
 Flash_postUpdate (FlashContext *context)
 {
@@ -537,7 +543,6 @@ Flash_grabOriginal (FlashContext *contex
 	if (context->original != (FRAME) 0)
 		DestroyDrawable (ReleaseDrawable (context->original));
 
-	LockMutex (GraphicsLock);
 	oldGfxContext = SetContext (context->gfxContext);
 	context->original = CaptureDrawable (CopyContextRect (&context->rect));
 	SetContext (oldGfxContext);
@@ -545,7 +550,6 @@ Flash_grabOriginal (FlashContext *contex
 			// CopyContextRect() may have queued the command to read
 			// a rectangle from the screen; a FlushGraphics()
 			// is necessary to ensure that it can actually be used.
-	UnlockMutex (GraphicsLock);
 }
 
 static inline void
@@ -581,7 +585,6 @@ Flash_makeFrame (FlashContext *context,
 
 	Flash_blendFraction (context, numer, denom, &blendedNumer, &blendedDenom);
 
-	LockMutex (GraphicsLock);
 	oldGfxContext = SetContext (workGfxContext);
 	SetContextFGFrame (dest);
 
@@ -642,7 +645,6 @@ Flash_makeFrame (FlashContext *context,
 	}
 
 	SetContext (oldGfxContext);
-	UnlockMutex (GraphicsLock);
 }
 
 // Prepare an entry in the cache.
@@ -678,7 +680,6 @@ Flash_drawFrame (FlashContext *context,
 	CONTEXT oldGfxContext;
 	STAMP stamp;
 
-	LockMutex (GraphicsLock);
 	oldGfxContext = SetContext (context->gfxContext);
 
 	stamp.origin = context->rect.corner;
@@ -686,7 +687,6 @@ Flash_drawFrame (FlashContext *context,
 	DrawStamp(&stamp);
 
 	SetContext (oldGfxContext);
-	UnlockMutex (GraphicsLock);
 }
 
 static void
@@ -803,5 +803,3 @@ Flash_drawCurrentFrame (FlashContext *co
 		Flash_drawCachedFrame (context, numer, denom);
 }
 
-
-
diff -ruNp src.orig/uqm/flash.h src/uqm/flash.h
--- src.orig/uqm/flash.h	2017-11-21 19:39:38 -0600
+++ src/uqm/flash.h	2017-11-21 19:39:55 -0600
@@ -31,18 +31,17 @@
  *
  * // We create the flash context; it is used to manipulate the flash
  * // rectangle while it exists.
- * FlashContext *fc = Flash_createHighlight (context, (FRAME) 0, rect);
+ * FlashContext *fc = Flash_createHighlight (gfxContext, rect);
  * 
  * // Specify how bright the flash is at the beginning and ending of the
  * // sequence.
- * Flash_setMergeFactors(context, 2, 3, 2);
+ * Flash_setMergeFactors(fc, 2, 3, 2);
  *
  * // We change the flashing speed from the defaults.
- * Flash_setSpeed (ONE_SECOND, ONE_SECOND, ONE_SECOND, ONE_SECOND);
+ * Flash_setSpeed (fc, ONE_SECOND, ONE_SECOND, ONE_SECOND, ONE_SECOND);
  * 
  * // During cross-fades, update 8 times per second.
- * Flash_setFrameTime (gmstate.player[playerI].flashContext,
- *         ONE_SECOND / 8);
+ * Flash_setFrameTime (fc, ONE_SECOND / 8);
  *
  * // We start the flashing. The default is to start from the "off" state.
  * Flash_start (fc);
@@ -63,7 +62,7 @@
  * ...
  * // Modifying the graphics of the area that is flashing:
  * void Flash_preUpdate (fc);
- * ... // do Drawing
+ * ... // do drawing
  * void Flash_postUpdate (fc);
  * ...
  * // We're done. Terminating the flash restores the flash area to its
@@ -78,18 +77,24 @@
  *
  * Limitations:
  *
- * 2) Functions that draw to the gfxContext or read the original gfxContext
- * contents, which is most of them, must be called with gfxContext having
- * the same clip-rect as it did when other drawing functions were called.
- * Otherwise, original contents restoration may draw to the wrong area, or
- * the wrong area may be read.
- * There may be cases where one would *want* that to happen, and such
- * cases are not covered by this limitation.
+ * * Functions that draw to the gfxContext or read the original gfxContext
+ *   contents, which is most of them, must be called with gfxContext having
+ *   the same clip-rect as it did when other drawing functions were called.
+ *   Otherwise, original contents restoration may draw to the wrong area, or
+ *   the wrong area may be read.
+ *   There may be cases where one would *want* that to happen, and such
+ *   cases are not covered by this limitation.
+ * * Multiple flashes may be used simultaneously, but don't let them
+ *   overlap; artifacts would occur.
  */
 
 #include "libs/gfxlib.h"
 #include "libs/timelib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef enum {
 	FlashState_fadeIn = 0,
 			// Someway between on and off, going towards on.
@@ -159,8 +164,8 @@ struct FlashContext {
 	TimeCount lastFrameTime;
 			// Time of the last frame draw.
 
-	BOOLEAN started : 1;
-	BOOLEAN paused : 1;
+	BOOLEAN started;
+	BOOLEAN paused;
 
 	FRAME *cache;
 	COUNT cacheSize;
@@ -211,5 +216,9 @@ void Flash_setCacheSize (FlashContext *c
 COUNT Flash_getCacheSize (const FlashContext *context);
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _FLASH_H */
 
diff -ruNp src.orig/uqm/fmv.c src/uqm/fmv.c
--- src.orig/uqm/fmv.c	2017-11-21 19:39:38 -0600
+++ src/uqm/fmv.c	2017-11-21 19:39:55 -0600
@@ -79,13 +79,11 @@ SplashScreen (void (* DoProcessing)(DWOR
 	DWORD TimeOut;
 
 	SleepThreadUntil (FadeScreen (FadeAllToBlack, ONE_SECOND / 120));
-	LockMutex (GraphicsLock);
 	SetContext (ScreenContext);
 	s.origin.x = s.origin.y = 0;
 	s.frame = CaptureDrawable (LoadGraphic (TITLE_ANIM));
 	DrawStamp (&s);
 	DestroyDrawable (ReleaseDrawable (s.frame));
-	UnlockMutex (GraphicsLock);
 
 	TimeOut = FadeScreen (FadeAllToColor, ONE_SECOND / 2);
 
diff -ruNp src.orig/uqm/fmv.h src/uqm/fmv.h
--- src.orig/uqm/fmv.h	2017-11-21 19:39:38 -0600
+++ src/uqm/fmv.h	2017-11-21 19:39:55 -0600
@@ -20,6 +20,11 @@
 #include "libs/compiler.h"
 #include "libs/sndlib.h"
 #include "libs/gfxlib.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #define WANT_SHIP_SPINS
 
 extern void SplashScreen (void (* DoProcessing)(DWORD TimeOut));
@@ -29,5 +34,9 @@ extern void DoShipSpin (COUNT index, MUS
 
 extern BOOLEAN ShowPresentation (RESOURCE presentation);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _FMV_H */
 
diff -ruNp src.orig/uqm/galaxy.c src/uqm/galaxy.c
--- src.orig/uqm/galaxy.c	2017-11-21 19:39:38 -0600
+++ src/uqm/galaxy.c	2017-11-21 19:39:55 -0600
@@ -268,7 +268,7 @@ InitGalaxy (void)
 		else
 		{
 			SetPrimType (&DisplayArray[p], POINT_PRIM);
-			if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
+			if (!inHQSpace ())
 				SetPrimColor (&DisplayArray[p],
 						BUILD_COLOR (MAKE_RGB15 (0x15, 0x15, 0x15), 0x07));
 			else if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
@@ -327,7 +327,7 @@ MoveGalaxy (VIEW_STATE view_state, SIZE
 
 		if (view_state == VIEW_CHANGE)
 		{
-			if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+			if (inHQSpace ())
 			{
 				for (iss = 0, pprim = DisplayArray; iss < 2; ++iss)
 				{
@@ -385,7 +385,7 @@ MoveGalaxy (VIEW_STATE view_state, SIZE
 			}
 		}
 
-		if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+		if (inHQSpace ())
 		{
 			for (i = BIG_STAR_COUNT + MED_STAR_COUNT, pprim = DisplayArray;
 					i > 0; --i, ++pprim)
@@ -406,7 +406,7 @@ MoveGalaxy (VIEW_STATE view_state, SIZE
 		WrapStarBlock (1, dx, dy);
 		WrapStarBlock (0, dx, dy);
 
-		if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
+		if (!inHQSpace ())
 		{
 			dx = SpaceOrg.x;
 			dy = SpaceOrg.y;
diff -ruNp src.orig/uqm/gameev.c src/uqm/gameev.c
--- src.orig/uqm/gameev.c	2017-11-21 19:39:38 -0600
+++ src/uqm/gameev.c	2017-11-21 19:39:55 -0600
@@ -19,27 +19,123 @@
 
 #include "build.h"
 #include "clock.h"
-// XXX: for CurStarDescPtr and XXX_DEFINED constants
-#include "encount.h"
+#include "starmap.h"
+#include "gendef.h"
 #include "globdata.h"
 #include "hyper.h"
+#include "resinst.h"
+#include "lua/luaevent.h"
+#include "lua/luafuncs/customfuncs.h"
 #include "libs/compiler.h"
+#include "libs/log.h"
 #include "libs/mathlib.h"
 
+#include <stdlib.h>
 
-static void arilou_entrance_event (void);
-static void arilou_exit_event (void);
+
+static int arilou_entrance_event (int arg);
+static int arilou_exit_event (int arg);
 static void check_race_growth (void);
-static void black_urquan_genocide (void);
-static void pkunk_mission (void);
-static void thradd_mission (void);
-static void ilwrath_mission (void);
-static void utwig_supox_mission (void);
-static void mycon_mission (void);
+static int hyperspace_encounter_event (int arg);
+static int kohr_ah_victorious_event (int arg);
+static int advance_pkunk_mission (int arg);
+static int advance_thradd_mission (int arg);
+static int zoqfot_distress_event (int arg);
+static int zoqfot_death_event (int arg);
+static int shofixti_return_event (int arg);
+static int advance_utwig_supox_mission (int arg);
+static int kohr_ah_genocide_event (int arg);
+static int spathi_shield_event (int arg);
+static int advance_ilwrath_mission (int arg);
+static int advance_mycon_mission (int arg);
+static int arilou_umgah_check (int arg);
+static int yehat_rebel_event (int arg);
+static int slylandro_ramp_up (int arg);
+static int slylandro_ramp_down (int arg);
+
+static const char *eventNames[] = {
+	"ARILOU_ENTRANCE_EVENT",
+	"ARILOU_EXIT_EVENT",
+	"HYPERSPACE_ENCOUNTER_EVENT",
+	"KOHR_AH_VICTORIOUS_EVENT",
+	"ADVANCE_PKUNK_MISSION",
+	"ADVANCE_THRADD_MISSION",
+	"ZOQFOT_DISTRESS_EVENT",
+	"ZOQFOT_DEATH_EVENT",
+	"SHOFIXTI_RETURN_EVENT",
+	"ADVANCE_UTWIG_SUPOX_MISSION",
+	"KOHR_AH_GENOCIDE_EVENT",
+	"SPATHI_SHIELD_EVENT",
+	"ADVANCE_ILWRATH_MISSION",
+	"ADVANCE_MYCON_MISSION",
+	"ARILOU_UMGAH_CHECK",
+	"YEHAT_REBEL_EVENT",
+	"SLYLANDRO_RAMP_UP",
+	"SLYLANDRO_RAMP_DOWN"
+};
+
+void
+initEventSystem (void) {
+	// Register functions which can be called from Lua through
+	// 'custom.<functionName>'. Right now, these are the event functions
+	// which have not been converted to Lua yet.
+	static const luaUqm_custom_Function eventFuncs[] = {
+		{ "arilou_entrance_event",       arilou_entrance_event },
+		{ "arilou_exit_event",           arilou_exit_event },
+		{ "hyperspace_encounter_event",  hyperspace_encounter_event },
+		{ "kohr_ah_victorious_event",    kohr_ah_victorious_event },
+		{ "advance_pkunk_mission",       advance_pkunk_mission },
+		{ "advance_thradd_mission",      advance_thradd_mission },
+		{ "zoqfot_distress_event",       zoqfot_distress_event },
+		{ "zoqfot_death_event",          zoqfot_death_event },
+		{ "shofixti_return_event",       shofixti_return_event },
+		{ "advance_utwig_supox_mission", advance_utwig_supox_mission },
+		{ "kohr_ah_genocide_event",      kohr_ah_genocide_event },
+		{ "spathi_shield_event",         spathi_shield_event },
+		{ "advance_ilwrath_mission",     advance_ilwrath_mission },
+		{ "advance_mycon_mission",       advance_mycon_mission },
+		{ "arilou_umgah_check",          arilou_umgah_check },
+		{ "yehat_rebel_event",           yehat_rebel_event },
+		{ "slylandro_ramp_up",           slylandro_ramp_up },
+		{ "slylandro_ramp_down",         slylandro_ramp_down },
+		{ NULL, NULL }
+	};
 
+	luaUqm_event_init (eventFuncs, EVENT_SCRIPT);
+}
 
 void
-AddInitialGameEvents (void) {
+uninitEventSystem (void) {
+	luaUqm_event_uninit ();
+}
+
+int
+eventIdStrToNum (const char *eventIdStr)
+{
+	size_t eventCount = sizeof eventNames / sizeof eventNames[0];
+	size_t eventI;
+
+	// Linear search; acceptable for such a small number of events.
+	for (eventI = 0; eventI < eventCount; eventI++)
+	{
+		if (strcmp (eventIdStr, eventNames[eventI]) == 0)
+			return eventI;
+	}
+	return -1;
+}
+
+const char *
+eventIdNumToStr (int eventNum)
+{
+	size_t eventCount = sizeof eventNames / sizeof eventNames[0];
+	if (eventNum < 0 || (size_t) eventNum >= eventCount)
+		return NULL;
+	return eventNames[eventNum];
+}
+
+void
+AddInitialGameEvents (void)
+{
 	AddEvent (RELATIVE_EVENT, 0, 1, 0, HYPERSPACE_ENCOUNTER_EVENT);
 	AddEvent (ABSOLUTE_EVENT, 3, 17, START_YEAR, ARILOU_ENTRANCE_EVENT);
 	AddEvent (RELATIVE_EVENT, 0, 0, YEARS_TO_KOHRAH_VICTORY,
@@ -50,169 +146,21 @@ AddInitialGameEvents (void) {
 void
 EventHandler (BYTE selector)
 {
-	switch (selector)
-	{
-		case ARILOU_ENTRANCE_EVENT:
-			arilou_entrance_event ();
-			break;
-		case ARILOU_EXIT_EVENT:
-			arilou_exit_event ();
-			break;
-		case HYPERSPACE_ENCOUNTER_EVENT:
-			check_race_growth ();
-			if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE
-					&& GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
-				check_hyperspace_encounter ();
-
-			AddEvent (RELATIVE_EVENT, 0, 1, 0, HYPERSPACE_ENCOUNTER_EVENT);
-			break;
-		case KOHR_AH_VICTORIOUS_EVENT:
-			if (GET_GAME_STATE (UTWIG_SUPOX_MISSION))
-			{
-				AddEvent (RELATIVE_EVENT, 0, 0, 1, KOHR_AH_GENOCIDE_EVENT);
-				break;
-			}
-			/* FALLTHROUGH */
-		case KOHR_AH_GENOCIDE_EVENT:
-			if (!GET_GAME_STATE (KOHR_AH_FRENZY)
-					&& LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
-			                && CurStarDescPtr
-					&& CurStarDescPtr->Index == SAMATRA_DEFINED)
-				AddEvent (RELATIVE_EVENT, 0, 7, 0, KOHR_AH_GENOCIDE_EVENT);
-			else
-				black_urquan_genocide ();
-			break;
-		case ADVANCE_PKUNK_MISSION:
-			pkunk_mission ();
-			break;
-		case ADVANCE_THRADD_MISSION:
-			thradd_mission ();
-			break;
-		case ZOQFOT_DISTRESS_EVENT:
-			if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
-			                && CurStarDescPtr
-					&& CurStarDescPtr->Index == ZOQFOT_DEFINED)
-				AddEvent (RELATIVE_EVENT, 0, 7, 0, ZOQFOT_DISTRESS_EVENT);
-			else
-			{
-				SET_GAME_STATE (ZOQFOT_DISTRESS, 1);
-				AddEvent (RELATIVE_EVENT, 6, 0, 0, ZOQFOT_DEATH_EVENT);
-			}
-			break;
-		case ZOQFOT_DEATH_EVENT:
-			if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
-			                && CurStarDescPtr
-					&& CurStarDescPtr->Index == ZOQFOT_DEFINED)
-				AddEvent (RELATIVE_EVENT, 0, 7, 0, ZOQFOT_DEATH_EVENT);
-			else if (GET_GAME_STATE (ZOQFOT_DISTRESS))
-			{
-				HFLEETINFO hZoqFot;
-				FLEET_INFO *ZoqFotPtr;
-
-				hZoqFot = GetStarShipFromIndex (&GLOBAL (avail_race_q),
-						ZOQFOTPIK_SHIP);
-				ZoqFotPtr = LockFleetInfo (&GLOBAL (avail_race_q), hZoqFot);
-				ZoqFotPtr->actual_strength = 0;
-				ZoqFotPtr->allied_state = DEAD_GUY;
-				UnlockFleetInfo (&GLOBAL (avail_race_q), hZoqFot);
-
-				SET_GAME_STATE (ZOQFOT_DISTRESS, 2);
-			}
-			break;
-		case SHOFIXTI_RETURN_EVENT:
-			ActivateStarShip (SHOFIXTI_SHIP, SET_ALLIED);
-			GLOBAL (CrewCost) -= 2;
-					/* crew is not an issue anymore */
-			SET_GAME_STATE (CREW_PURCHASED0, 0);
-			SET_GAME_STATE (CREW_PURCHASED1, 0);
-			break;
-		case ADVANCE_UTWIG_SUPOX_MISSION:
-			utwig_supox_mission ();
-			break;
-		case SPATHI_SHIELD_EVENT:
-			if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
-			                && CurStarDescPtr
-					&& CurStarDescPtr->Index == SPATHI_DEFINED)
-				AddEvent (RELATIVE_EVENT, 0, 7, 0, SPATHI_SHIELD_EVENT);
-			else
-			{
-				HFLEETINFO hSpathi;
-				FLEET_INFO *SpathiPtr;
+	const char *eventIdStr;
 
-				hSpathi = GetStarShipFromIndex (&GLOBAL (avail_race_q),
-						SPATHI_SHIP);
-				SpathiPtr = LockFleetInfo (&GLOBAL (avail_race_q), hSpathi);
-
-				if (SpathiPtr->actual_strength)
-				{
-					ActivateStarShip (SPATHI_SHIP, SET_NOT_ALLIED);
-					SET_GAME_STATE (SPATHI_SHIELDED_SELVES, 1);
-					SpathiPtr->actual_strength = 0;
-				}
-
-				UnlockFleetInfo (&GLOBAL (avail_race_q), hSpathi);
-			}
-			break;
-		case ADVANCE_ILWRATH_MISSION:
-			ilwrath_mission ();
-			break;
-		case ADVANCE_MYCON_MISSION:
-			mycon_mission ();
-			break;
-		case ARILOU_UMGAH_CHECK:
-			SET_GAME_STATE (ARILOU_CHECKED_UMGAH, 2);
-			break;
-		case YEHAT_REBEL_EVENT:
-		{
-			HFLEETINFO hRebel, hRoyalist;
-			FLEET_INFO *RebelPtr;
-			FLEET_INFO *RoyalistPtr;
-
-			hRebel = GetStarShipFromIndex (&GLOBAL (avail_race_q),
-					YEHAT_REBEL_SHIP);
-			RebelPtr = LockFleetInfo (&GLOBAL (avail_race_q), hRebel);
-			hRoyalist = GetStarShipFromIndex (&GLOBAL (avail_race_q),
-					YEHAT_SHIP);
-			RoyalistPtr = LockFleetInfo (&GLOBAL (avail_race_q), hRoyalist);
-			RoyalistPtr->actual_strength = RoyalistPtr->actual_strength *
-					2 / 3;
-			RebelPtr->actual_strength = RoyalistPtr->actual_strength;
-			RebelPtr->loc.x = 5150;
-			RebelPtr->loc.y = 0;
-			UnlockFleetInfo (&GLOBAL (avail_race_q), hRoyalist);
-			UnlockFleetInfo (&GLOBAL (avail_race_q), hRebel);
-			ActivateStarShip (YEHAT_REBEL_SHIP, SPHERE_TRACKING);
-			break;
-		}
-		case SLYLANDRO_RAMP_UP:
-			if (!GET_GAME_STATE (DESTRUCT_CODE_ON_SHIP))
-			{
-				BYTE ramp_factor;
-
-				ramp_factor = GET_GAME_STATE (SLYLANDRO_MULTIPLIER);
-				if (++ramp_factor <= 4)
-				{
-					SET_GAME_STATE (SLYLANDRO_MULTIPLIER, ramp_factor);
-					AddEvent (RELATIVE_EVENT, 0, 182, 0, SLYLANDRO_RAMP_UP);
-				}
-			}
-			break;
-		case SLYLANDRO_RAMP_DOWN:
-		{
-			BYTE ramp_factor;
-
-			ramp_factor = GET_GAME_STATE (SLYLANDRO_MULTIPLIER);
-			if (--ramp_factor)
-				AddEvent (RELATIVE_EVENT, 0, 23, 0, SLYLANDRO_RAMP_DOWN);
-			SET_GAME_STATE (SLYLANDRO_MULTIPLIER, ramp_factor);
-			break;
-		}
+	eventIdStr = eventIdNumToStr (selector);
+	if (eventIdStr == NULL) {
+		log_add(log_Warning, "Warning: EventHandler(): Event %d is "
+				"unknown.", selector);
+		return;
 	}
+
+	luaUqm_event_callEvent(eventIdStr);
 }
 
 void
-SetRaceDest (BYTE which_race, COORD x, COORD y, BYTE days_left, BYTE
-		func_index)
+SetRaceDest (BYTE which_race, COORD x, COORD y, BYTE days_left,
+		BYTE func_index)
 {
 	HFLEETINFO hFleet;
 	FLEET_INFO *FleetPtr;
@@ -229,16 +177,17 @@ SetRaceDest (BYTE which_race, COORD x, C
 }
 
 
-
-static void
-arilou_entrance_event (void)
+static int
+arilou_entrance_event (int arg)
 {
 	SET_GAME_STATE (ARILOU_SPACE, OPENING);
 	AddEvent (RELATIVE_EVENT, 0, 3, 0, ARILOU_EXIT_EVENT);
+	(void) arg;
+	return 0;
 }
 
-static void
-arilou_exit_event (void)
+static int
+arilou_exit_event (int arg)
 {
 	COUNT month_index, year_index;
 
@@ -250,6 +199,9 @@ arilou_exit_event (void)
 	SET_GAME_STATE (ARILOU_SPACE, CLOSING);
 	AddEvent (ABSOLUTE_EVENT,
 			month_index, 17, year_index, ARILOU_ENTRANCE_EVENT);
+
+	(void) arg;
+	return 0;
 }
 
 static void
@@ -307,104 +259,36 @@ check_race_growth (void)
 	}
 }
 
-static void
-black_urquan_genocide (void)
+static int
+hyperspace_encounter_event (int arg)
 {
-	BYTE Index;
-	long best_dist;
-	SIZE best_dx, best_dy;
-	HFLEETINFO hStarShip, hNextShip;
-	HFLEETINFO hBlackUrquan;
-	FLEET_INFO *BlackUrquanPtr;
-
-	hBlackUrquan = GetStarShipFromIndex (&GLOBAL (avail_race_q),
-			BLACK_URQUAN_SHIP);
-	BlackUrquanPtr = LockFleetInfo (&GLOBAL (avail_race_q), hBlackUrquan);
-
-	best_dist = -1;
-	best_dx = SOL_X - BlackUrquanPtr->loc.x;
-	best_dy = SOL_Y - BlackUrquanPtr->loc.y;
-	for (Index = 0, hStarShip = GetHeadLink (&GLOBAL (avail_race_q));
-			hStarShip; ++Index, hStarShip = hNextShip)
-	{
-		FLEET_INFO *FleetPtr;
+	check_race_growth ();
+	if (inHyperSpace ())
+		check_hyperspace_encounter ();
 
-		FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
-		hNextShip = _GetSuccLink (FleetPtr);
-
-		if (Index != BLACK_URQUAN_SHIP
-				&& Index != URQUAN_SHIP
-				&& FleetPtr->actual_strength != INFINITE_RADIUS)
-		{
-			SIZE dx, dy;
-
-			dx = FleetPtr->loc.x - BlackUrquanPtr->loc.x;
-			dy = FleetPtr->loc.y - BlackUrquanPtr->loc.y;
-			if (dx == 0 && dy == 0)
-			{
-				// Arrived at the victim's home world. Cleanse it.
-				FleetPtr->allied_state = DEAD_GUY;
-				FleetPtr->actual_strength = 0;
-			}
-			else if (FleetPtr->actual_strength)
-			{
-				long dist;
-
-				dist = (long)dx * dx + (long)dy * dy;
-				if (best_dist < 0 || dist < best_dist || Index == DRUUGE_SHIP)
-				{
-					best_dist = dist;
-					best_dx = dx;
-					best_dy = dy;
-
-					if (Index == DRUUGE_SHIP)
-						hNextShip = 0;
-				}
-			}
-		}
-
-		UnlockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
-	}
-
-	if (best_dist < 0 && best_dx == 0 && best_dy == 0)
-	{
-		// All spheres of influence are gone - game over.
-		GLOBAL (CurrentActivity) &= ~IN_BATTLE;
-		GLOBAL_SIS (CrewEnlisted) = (COUNT)~0;
+	AddEvent (RELATIVE_EVENT, 0, 1, 0, HYPERSPACE_ENCOUNTER_EVENT);
+	
+	(void) arg;
+	return 0;
+}
 
-		SET_GAME_STATE (KOHR_AH_KILLED_ALL, 1);
-	}
-	else
+static int
+kohr_ah_victorious_event (int arg)
+{
+	if (GET_GAME_STATE (UTWIG_SUPOX_MISSION))
 	{
-		// Moving towards new race to cleanse.
-		COUNT speed;
-
-		if (best_dist < 0)
-			best_dist = (long)best_dx * best_dx + (long)best_dy * best_dy;
-
-		speed = square_root (best_dist) / 158;
-		if (speed == 0)
-			speed = 1;
-		else if (speed > 255)
-			speed = 255;
-
-		SET_GAME_STATE (KOHR_AH_FRENZY, 1);
-		SET_GAME_STATE (KOHR_AH_VISITS, 0);
-		SET_GAME_STATE (KOHR_AH_REASONS, 0);
-		SET_GAME_STATE (KOHR_AH_PLEAD, 0);
-		SET_GAME_STATE (KOHR_AH_INFO, 0);
-		SET_GAME_STATE (URQUAN_VISITS, 0);
-		SetRaceDest (BLACK_URQUAN_SHIP,
-				BlackUrquanPtr->loc.x + best_dx,
-				BlackUrquanPtr->loc.y + best_dy,
-				(BYTE)speed, KOHR_AH_GENOCIDE_EVENT);
+		// The Utwig/Supox mission delayed the genocide.
+		// Try again in one year.
+		AddEvent (RELATIVE_EVENT, 0, 0, 1, KOHR_AH_GENOCIDE_EVENT);
+		return 0;
 	}
 
-	UnlockFleetInfo (&GLOBAL (avail_race_q), hBlackUrquan);
+	// No more delay; start the genocide.
+	return kohr_ah_genocide_event (arg);
 }
 
-static void
-pkunk_mission (void)
+static int
+advance_pkunk_mission (int arg)
 {
 	HFLEETINFO hPkunk;
 	FLEET_INFO *PkunkPtr;
@@ -431,7 +315,7 @@ pkunk_mission (void)
 				SET_GAME_STATE (PKUNK_ON_THE_MOVE, 0);
 				AddEvent (RELATIVE_EVENT, 3, 0, 0, ADVANCE_PKUNK_MISSION);
 				UnlockFleetInfo (&GLOBAL (avail_race_q), hPkunk);
-				return;
+				return 0;
 			}
 		}
 
@@ -439,7 +323,7 @@ pkunk_mission (void)
 		{
 			SET_GAME_STATE (YEHAT_ABSORBED_PKUNK, 1);
 			PkunkPtr->allied_state = DEAD_GUY;
-			ActivateStarShip (YEHAT_SHIP, SPHERE_TRACKING);
+			StartSphereTracking (YEHAT_SHIP);
 		}
 		else
 		{
@@ -465,10 +349,14 @@ pkunk_mission (void)
 	}
 
 	UnlockFleetInfo (&GLOBAL (avail_race_q), hPkunk);
+
+	(void) arg;
+	return 0;
 }
 
-static void
-thradd_mission (void)
+// Send the Thraddash to fight the Kohr-Ah.
+static int
+advance_thradd_mission (int arg)
 {
 	BYTE MissionState;
 	HFLEETINFO hThradd;
@@ -521,87 +409,73 @@ thradd_mission (void)
 	}
 
 	UnlockFleetInfo (&GLOBAL (avail_race_q), hThradd);
+
+	(void) arg;
+	return 0;
 }
 
-static void
-ilwrath_mission (void)
+static int
+zoqfot_distress_event (int arg)
 {
-	BYTE ThraddState;
-	HFLEETINFO hIlwrath, hThradd;
-	FLEET_INFO *IlwrathPtr;
-	FLEET_INFO *ThraddPtr;
+	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
+			&& CurStarDescPtr
+			&& CurStarDescPtr->Index == ZOQFOT_DEFINED)
+	{
+		AddEvent (RELATIVE_EVENT, 0, 7, 0, ZOQFOT_DISTRESS_EVENT);
+	}
+	else
+	{
+		SET_GAME_STATE (ZOQFOT_DISTRESS, 1);
+		AddEvent (RELATIVE_EVENT, 6, 0, 0, ZOQFOT_DEATH_EVENT);
+	}
 
-	hIlwrath = GetStarShipFromIndex (&GLOBAL (avail_race_q), ILWRATH_SHIP);
-	IlwrathPtr = LockFleetInfo (&GLOBAL (avail_race_q), hIlwrath);
-	hThradd = GetStarShipFromIndex (&GLOBAL (avail_race_q), THRADDASH_SHIP);
-	ThraddPtr = LockFleetInfo (&GLOBAL (avail_race_q), hThradd);
+	(void) arg;
+	return 0;
+}
 
-	if (IlwrathPtr->loc.x == ((2500 + 2535) >> 1)
-			&& IlwrathPtr->loc.y == ((8070 + 8358) >> 1))
+static int
+zoqfot_death_event (int arg)
+{
+	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
+			&& CurStarDescPtr
+			&& CurStarDescPtr->Index == ZOQFOT_DEFINED)
 	{
-		IlwrathPtr->actual_strength = 0;
-		ThraddPtr->actual_strength = 0;
-		IlwrathPtr->allied_state = DEAD_GUY;
-		ThraddPtr->allied_state = DEAD_GUY;
+		AddEvent (RELATIVE_EVENT, 0, 7, 0, ZOQFOT_DEATH_EVENT);
 	}
-	else if (IlwrathPtr->actual_strength)
+	else if (GET_GAME_STATE (ZOQFOT_DISTRESS))
 	{
-		if (!GET_GAME_STATE (ILWRATH_FIGHT_THRADDASH)
-				&& (IlwrathPtr->dest_loc.x != 2500
-				|| IlwrathPtr->dest_loc.y != 8070))
-		{
-			SetRaceDest (ILWRATH_SHIP, 2500, 8070, 90,
-					ADVANCE_ILWRATH_MISSION);
-		}
-		else
-		{
-#define MADD_LENGTH 128
-			SIZE strength_loss;
+		HFLEETINFO hZoqFot;
+		FLEET_INFO *ZoqFotPtr;
 
-			if (IlwrathPtr->days_left == 0)
-			{	/* arrived for battle */
-				SET_GAME_STATE (ILWRATH_FIGHT_THRADDASH, 1);
-				SET_GAME_STATE (HELIX_UNPROTECTED, 1);
-				strength_loss = (SIZE)IlwrathPtr->actual_strength;
-				IlwrathPtr->growth = (BYTE)(-strength_loss / MADD_LENGTH);
-				IlwrathPtr->growth_fract =
-						(BYTE)(((strength_loss % MADD_LENGTH) << 8) / MADD_LENGTH);
-				SetRaceDest (ILWRATH_SHIP,
-						(2500 + 2535) >> 1, (8070 + 8358) >> 1,
-						MADD_LENGTH - 1, ADVANCE_ILWRATH_MISSION);
+		hZoqFot = GetStarShipFromIndex (&GLOBAL (avail_race_q),
+				ZOQFOTPIK_SHIP);
+		ZoqFotPtr = LockFleetInfo (&GLOBAL (avail_race_q), hZoqFot);
+		ZoqFotPtr->actual_strength = 0;
+		ZoqFotPtr->allied_state = DEAD_GUY;
+		UnlockFleetInfo (&GLOBAL (avail_race_q), hZoqFot);
 
-				strength_loss = (SIZE)ThraddPtr->actual_strength;
-				ThraddPtr->growth = (BYTE)(-strength_loss / MADD_LENGTH);
-				ThraddPtr->growth_fract =
-						(BYTE)(((strength_loss % MADD_LENGTH) << 8) / MADD_LENGTH);
+		SET_GAME_STATE (ZOQFOT_DISTRESS, 2);
+	}
 
-				SET_GAME_STATE (THRADD_VISITS, 0);
-				if (ThraddPtr->allied_state == GOOD_GUY)
-					ActivateStarShip (THRADDASH_SHIP, SET_NOT_ALLIED);
-			}
+	(void) arg;
+	return 0;
+}
 
-			ThraddState = GET_GAME_STATE (THRADD_MISSION);
-			if (ThraddState == 0 || ThraddState > 3)
-			{	/* never went to Kohr-Ah or returned */
-				SetRaceDest (THRADDASH_SHIP,
-						(2500 + 2535) >> 1, (8070 + 8358) >> 1,
-						IlwrathPtr->days_left + 1, (BYTE)~0);
-			}
-			else if (ThraddState < 3)
-			{	/* recall on the double */
-				SetRaceDest (THRADDASH_SHIP, 2535, 8358, 10,
-						ADVANCE_THRADD_MISSION);
-				SET_GAME_STATE (THRADD_MISSION, 3);
-			}
-		}
-	}
+static int
+shofixti_return_event (int arg)
+{
+	SetRaceAllied (SHOFIXTI_SHIP, TRUE);
+	GLOBAL (CrewCost) -= 2;
+			/* crew is not an issue anymore */
+	SET_GAME_STATE (CREW_PURCHASED0, 0);
+	SET_GAME_STATE (CREW_PURCHASED1, 0);
 
-	UnlockFleetInfo (&GLOBAL (avail_race_q), hThradd);
-	UnlockFleetInfo (&GLOBAL (avail_race_q), hIlwrath);
+	(void) arg;
+	return 0;
 }
 
-static void
-utwig_supox_mission (void)
+static int
+advance_utwig_supox_mission (int arg)
 {
 	BYTE MissionState;
 	HFLEETINFO hUtwig, hSupox;
@@ -687,10 +561,232 @@ utwig_supox_mission (void)
 
 	UnlockFleetInfo (&GLOBAL (avail_race_q), hSupox);
 	UnlockFleetInfo (&GLOBAL (avail_race_q), hUtwig);
+
+	(void) arg;
+	return 0;
 }
 
-static void
-mycon_mission (void)
+static int
+kohr_ah_genocide_event (int arg)
+{
+	BYTE Index;
+	long best_dist;
+	SIZE best_dx, best_dy;
+	HFLEETINFO hStarShip, hNextShip;
+	HFLEETINFO hBlackUrquan;
+	FLEET_INFO *BlackUrquanPtr;
+
+	if (!GET_GAME_STATE (KOHR_AH_FRENZY)
+			&& LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
+					&& CurStarDescPtr
+			&& CurStarDescPtr->Index == SAMATRA_DEFINED) {
+		AddEvent (RELATIVE_EVENT, 0, 7, 0, KOHR_AH_GENOCIDE_EVENT);
+		return 0;
+	}
+
+	hBlackUrquan = GetStarShipFromIndex (&GLOBAL (avail_race_q),
+			BLACK_URQUAN_SHIP);
+	BlackUrquanPtr = LockFleetInfo (&GLOBAL (avail_race_q), hBlackUrquan);
+
+	best_dist = -1;
+	best_dx = SOL_X - BlackUrquanPtr->loc.x;
+	best_dy = SOL_Y - BlackUrquanPtr->loc.y;
+	for (Index = 0, hStarShip = GetHeadLink (&GLOBAL (avail_race_q));
+			hStarShip; ++Index, hStarShip = hNextShip)
+	{
+		FLEET_INFO *FleetPtr;
+
+		FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
+		hNextShip = _GetSuccLink (FleetPtr);
+
+		if (Index != BLACK_URQUAN_SHIP
+				&& Index != URQUAN_SHIP
+				&& FleetPtr->actual_strength != INFINITE_RADIUS)
+		{
+			SIZE dx, dy;
+
+			dx = FleetPtr->loc.x - BlackUrquanPtr->loc.x;
+			dy = FleetPtr->loc.y - BlackUrquanPtr->loc.y;
+			if (dx == 0 && dy == 0)
+			{
+				// Arrived at the victim's home world. Cleanse it.
+				FleetPtr->allied_state = DEAD_GUY;
+				FleetPtr->actual_strength = 0;
+			}
+			else if (FleetPtr->actual_strength)
+			{
+				long dist;
+
+				dist = (long)dx * dx + (long)dy * dy;
+				if (best_dist < 0 || dist < best_dist || Index == DRUUGE_SHIP)
+				{
+					best_dist = dist;
+					best_dx = dx;
+					best_dy = dy;
+
+					if (Index == DRUUGE_SHIP)
+						hNextShip = 0;
+				}
+			}
+		}
+
+		UnlockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
+	}
+
+	if (best_dist < 0 && best_dx == 0 && best_dy == 0)
+	{
+		// All spheres of influence are gone - game over.
+		GLOBAL (CurrentActivity) &= ~IN_BATTLE;
+		GLOBAL_SIS (CrewEnlisted) = (COUNT)~0;
+
+		SET_GAME_STATE (KOHR_AH_KILLED_ALL, 1);
+	}
+	else
+	{
+		// Moving towards new race to cleanse.
+		COUNT speed;
+
+		if (best_dist < 0)
+			best_dist = (long)best_dx * best_dx + (long)best_dy * best_dy;
+
+		speed = square_root (best_dist) / 158;
+		if (speed == 0)
+			speed = 1;
+		else if (speed > 255)
+			speed = 255;
+
+		SET_GAME_STATE (KOHR_AH_FRENZY, 1);
+		SET_GAME_STATE (KOHR_AH_VISITS, 0);
+		SET_GAME_STATE (KOHR_AH_REASONS, 0);
+		SET_GAME_STATE (KOHR_AH_PLEAD, 0);
+		SET_GAME_STATE (KOHR_AH_INFO, 0);
+		SET_GAME_STATE (URQUAN_VISITS, 0);
+		SetRaceDest (BLACK_URQUAN_SHIP,
+				BlackUrquanPtr->loc.x + best_dx,
+				BlackUrquanPtr->loc.y + best_dy,
+				(BYTE)speed, KOHR_AH_GENOCIDE_EVENT);
+	}
+
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hBlackUrquan);
+
+	(void) arg;
+	return 0;
+}
+
+static int
+spathi_shield_event (int arg)
+{
+	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
+			&& CurStarDescPtr
+			&& CurStarDescPtr->Index == SPATHI_DEFINED)
+	{
+		AddEvent (RELATIVE_EVENT, 0, 7, 0, SPATHI_SHIELD_EVENT);
+	}
+	else
+	{
+		HFLEETINFO hSpathi;
+		FLEET_INFO *SpathiPtr;
+
+		hSpathi = GetStarShipFromIndex (&GLOBAL (avail_race_q),
+				SPATHI_SHIP);
+		SpathiPtr = LockFleetInfo (&GLOBAL (avail_race_q), hSpathi);
+
+		if (SpathiPtr->actual_strength)
+		{
+			SetRaceAllied (SPATHI_SHIP, FALSE);
+			SET_GAME_STATE (SPATHI_SHIELDED_SELVES, 1);
+			SpathiPtr->actual_strength = 0;
+		}
+
+		UnlockFleetInfo (&GLOBAL (avail_race_q), hSpathi);
+	}
+
+	(void) arg;
+	return 0;
+}
+
+static int
+advance_ilwrath_mission (int arg)
+{
+	BYTE ThraddState;
+	HFLEETINFO hIlwrath, hThradd;
+	FLEET_INFO *IlwrathPtr;
+	FLEET_INFO *ThraddPtr;
+
+	hIlwrath = GetStarShipFromIndex (&GLOBAL (avail_race_q), ILWRATH_SHIP);
+	IlwrathPtr = LockFleetInfo (&GLOBAL (avail_race_q), hIlwrath);
+	hThradd = GetStarShipFromIndex (&GLOBAL (avail_race_q), THRADDASH_SHIP);
+	ThraddPtr = LockFleetInfo (&GLOBAL (avail_race_q), hThradd);
+
+	if (IlwrathPtr->loc.x == ((2500 + 2535) >> 1)
+			&& IlwrathPtr->loc.y == ((8070 + 8358) >> 1))
+	{
+		IlwrathPtr->actual_strength = 0;
+		ThraddPtr->actual_strength = 0;
+		IlwrathPtr->allied_state = DEAD_GUY;
+		ThraddPtr->allied_state = DEAD_GUY;
+	}
+	else if (IlwrathPtr->actual_strength)
+	{
+		if (!GET_GAME_STATE (ILWRATH_FIGHT_THRADDASH)
+				&& (IlwrathPtr->dest_loc.x != 2500
+				|| IlwrathPtr->dest_loc.y != 8070))
+		{
+			SetRaceDest (ILWRATH_SHIP, 2500, 8070, 90,
+					ADVANCE_ILWRATH_MISSION);
+		}
+		else
+		{
+#define MADD_LENGTH 128
+			SIZE strength_loss;
+
+			if (IlwrathPtr->days_left == 0)
+			{	/* arrived for battle */
+				SET_GAME_STATE (ILWRATH_FIGHT_THRADDASH, 1);
+				SET_GAME_STATE (HELIX_UNPROTECTED, 1);
+				strength_loss = (SIZE)IlwrathPtr->actual_strength;
+				IlwrathPtr->growth = (BYTE)(-strength_loss / MADD_LENGTH);
+				IlwrathPtr->growth_fract =
+						(BYTE)(((strength_loss % MADD_LENGTH) << 8) / MADD_LENGTH);
+				SetRaceDest (ILWRATH_SHIP,
+						(2500 + 2535) >> 1, (8070 + 8358) >> 1,
+						MADD_LENGTH - 1, ADVANCE_ILWRATH_MISSION);
+
+				strength_loss = (SIZE)ThraddPtr->actual_strength;
+				ThraddPtr->growth = (BYTE)(-strength_loss / MADD_LENGTH);
+				ThraddPtr->growth_fract =
+						(BYTE)(((strength_loss % MADD_LENGTH) << 8) / MADD_LENGTH);
+
+				SET_GAME_STATE (THRADD_VISITS, 0);
+				if (ThraddPtr->allied_state == GOOD_GUY)
+					SetRaceAllied (THRADDASH_SHIP, FALSE);
+			}
+
+			ThraddState = GET_GAME_STATE (THRADD_MISSION);
+			if (ThraddState == 0 || ThraddState > 3)
+			{	/* never went to Kohr-Ah or returned */
+				SetRaceDest (THRADDASH_SHIP,
+						(2500 + 2535) >> 1, (8070 + 8358) >> 1,
+						IlwrathPtr->days_left + 1, (BYTE)~0);
+			}
+			else if (ThraddState < 3)
+			{	/* recall on the double */
+				SetRaceDest (THRADDASH_SHIP, 2535, 8358, 10,
+						ADVANCE_THRADD_MISSION);
+				SET_GAME_STATE (THRADD_MISSION, 3);
+			}
+		}
+	}
+
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hThradd);
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hIlwrath);
+	
+	(void) arg;
+	return 0;
+}
+
+static int
+advance_mycon_mission (int arg)
 {
 	HFLEETINFO hMycon;
 	FLEET_INFO *MyconPtr;
@@ -726,5 +822,73 @@ mycon_mission (void)
 	}
 
 	UnlockFleetInfo (&GLOBAL (avail_race_q), hMycon);
+	
+	(void) arg;
+	return 0;
+}
+
+static int
+arilou_umgah_check (int arg)
+{
+	SET_GAME_STATE (ARILOU_CHECKED_UMGAH, 2);
+
+	(void) arg;
+	return 0;
+}
+
+static int
+yehat_rebel_event (int arg)
+{
+	HFLEETINFO hRebel, hRoyalist;
+	FLEET_INFO *RebelPtr;
+	FLEET_INFO *RoyalistPtr;
+
+	hRebel = GetStarShipFromIndex (&GLOBAL (avail_race_q), YEHAT_REBEL_SHIP);
+	RebelPtr = LockFleetInfo (&GLOBAL (avail_race_q), hRebel);
+	hRoyalist = GetStarShipFromIndex (&GLOBAL (avail_race_q), YEHAT_SHIP);
+	RoyalistPtr = LockFleetInfo (&GLOBAL (avail_race_q), hRoyalist);
+	RoyalistPtr->actual_strength = RoyalistPtr->actual_strength * 2 / 3;
+	RebelPtr->actual_strength = RoyalistPtr->actual_strength;
+	RebelPtr->loc.x = 5150;
+	RebelPtr->loc.y = 0;
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hRoyalist);
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hRebel);
+	StartSphereTracking (YEHAT_REBEL_SHIP);
+
+	(void) arg;
+	return 0;
+}
+
+static int
+slylandro_ramp_up (int arg)
+{
+	if (!GET_GAME_STATE (DESTRUCT_CODE_ON_SHIP))
+	{
+		BYTE ramp_factor;
+
+		ramp_factor = GET_GAME_STATE (SLYLANDRO_MULTIPLIER);
+		if (++ramp_factor <= 4)
+		{
+			SET_GAME_STATE (SLYLANDRO_MULTIPLIER, ramp_factor);
+			AddEvent (RELATIVE_EVENT, 0, 182, 0, SLYLANDRO_RAMP_UP);
+		}
+	}
+
+	(void) arg;
+	return 0;
+}
+
+static int
+slylandro_ramp_down (int arg)
+{
+	BYTE ramp_factor;
+
+	ramp_factor = GET_GAME_STATE (SLYLANDRO_MULTIPLIER);
+	if (--ramp_factor)
+		AddEvent (RELATIVE_EVENT, 0, 23, 0, SLYLANDRO_RAMP_DOWN);
+	SET_GAME_STATE (SLYLANDRO_MULTIPLIER, ramp_factor);
+
+	(void) arg;
+	return 0;
 }
 
diff -ruNp src.orig/uqm/gameev.h src/uqm/gameev.h
--- src.orig/uqm/gameev.h	2017-11-21 19:39:38 -0600
+++ src/uqm/gameev.h	2017-11-21 19:39:55 -0600
@@ -20,6 +20,10 @@
 #include "libs/compiler.h"
 #include "libs/gfxlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 
 enum
 {
@@ -51,11 +55,21 @@ typedef enum
 	OPENING
 } ARILOU_GATE_STATE;
 
+extern int eventIdStrToNum (const char *eventIdStr);
+extern const char *eventIdNumToStr (int eventNum);
+
+extern void initEventSystem (void);
+extern void uninitEventSystem (void);
+
 extern void AddInitialGameEvents (void);
 extern void EventHandler (BYTE selector);
 extern void SetRaceDest (BYTE which_race, COORD x, COORD y, BYTE days_left,
 		BYTE func_index);
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _GAMEEV_H */
 
diff -ruNp src.orig/uqm/gameinp.c src/uqm/gameinp.c
--- src.orig/uqm/gameinp.c	2017-11-21 19:39:38 -0600
+++ src/uqm/gameinp.c	2017-11-21 19:39:55 -0600
@@ -28,6 +28,7 @@
 #include "sounds.h"
 #include "tactrans.h"
 #include "uqmdebug.h"
+#include "libs/async.h"
 #include "libs/inplib.h"
 #include "libs/timelib.h"
 #include "libs/threadlib.h"
@@ -274,6 +275,11 @@ UpdateInputState (void)
 
 	if (CurrentInputState.menu[KEY_EXIT])
 		ExitRequested = TRUE;
+
+#if defined(DEBUG) || defined(USE_DEBUG_KEY)
+	if (PulsedInputState.menu[KEY_DEBUG])
+		debugKeyPressedSynchronous ();
+#endif
 }
 
 InputFrameCallback *
@@ -359,23 +365,11 @@ DoInput (void *pInputState, BOOLEAN rese
 	do
 	{
 		MENU_SOUND_FLAGS soundFlags;
+		Async_process ();
 		TaskSwitch ();
 
 		UpdateInputState ();
 
-#ifdef DEBUG
-		if (doInputDebugHook != NULL)
-		{
-			void (*saveDebugHook) (void);
-			saveDebugHook = doInputDebugHook;
-			doInputDebugHook = NULL;
-					// No further debugHook calls unless the called
-					// function resets doInputDebugHook.
-			(*saveDebugHook) ();
-			continue;
-		}
-#endif
-
 #if DEMO_MODE || CREATE_JOURNAL
 		if (ArrowInput != DemoInput)
 #endif
diff -ruNp src.orig/uqm/gameopt.c src/uqm/gameopt.c
--- src.orig/uqm/gameopt.c	2017-11-21 19:39:38 -0600
+++ src/uqm/gameopt.c	2017-11-21 19:39:55 -0600
@@ -21,13 +21,11 @@
 #include "build.h"
 #include "colors.h"
 #include "controls.h"
-// XXX: for FindStart(), GetClusterName()
-#include "encount.h"
+#include "starmap.h"
 #include "menustat.h"
 #include "sis.h"
 #include "units.h"
 #include "gamestr.h"
-#include "load.h"
 #include "options.h"
 #include "save.h"
 #include "settings.h"
@@ -168,15 +166,33 @@ FeedbackSetting (BYTE which_setting)
 			break;
 	}
 
-	LockMutex (GraphicsLock);
 	DrawStatusMessage (buf);
-	UnlockMutex (GraphicsLock);
 }
 
 #define DDSHS_NORMAL   0
 #define DDSHS_EDIT     1
 #define DDSHS_BLOCKCUR 2
 
+static const RECT captainNameRect = {
+	/* .corner = */ {
+		/* .x = */ 3,
+		/* .y = */ 10
+	}, /* .extent = */ {
+		/* .width = */ SHIP_NAME_WIDTH - 2,
+		/* .height = */ SHIP_NAME_HEIGHT
+	}
+};
+static const RECT shipNameRect = {
+	/* .corner = */ {
+		/* .x = */ 2,
+		/* .y = */ 20
+	}, /* .extent = */ {
+		/* .width = */ SHIP_NAME_WIDTH,
+		/* .height = */ SHIP_NAME_HEIGHT
+	}
+};
+
+
 static BOOLEAN
 DrawNameString (bool nameCaptain, UNICODE *Str, COUNT CursorPos,
 		COUNT state)
@@ -186,20 +202,11 @@ DrawNameString (bool nameCaptain, UNICOD
 	Color BackGround, ForeGround;
 	FONT Font;
 
-	LockMutex (GraphicsLock);
-
 	{
-		r.corner.x = 2;
-		r.extent.width = SHIP_NAME_WIDTH;
-		r.extent.height = SHIP_NAME_HEIGHT;
-
-		SetContext (StatusContext);
 		if (nameCaptain)
 		{	// Naming the captain
 			Font = TinyFont;
-			r.corner.y = 10;
-			++r.corner.x;
-			r.extent.width -= 2;
+			r = captainNameRect;
 			lf.baseline.x = r.corner.x + (r.extent.width >> 1) - 1;
 
 			BackGround = BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x1F), 0x09);
@@ -208,7 +215,7 @@ DrawNameString (bool nameCaptain, UNICOD
 		else
 		{	// Naming the flagship
 			Font = StarConFont;
-			r.corner.y = 20;
+			r = shipNameRect;
 			lf.baseline.x = r.corner.x + (r.extent.width >> 1);
 
 			BackGround = BUILD_COLOR (MAKE_RGB15 (0x0F, 0x00, 0x00), 0x2D);
@@ -219,6 +226,7 @@ DrawNameString (bool nameCaptain, UNICOD
 		lf.align = ALIGN_CENTER;
 	}
 
+	SetContext (StatusContext);
 	SetContextFont (Font);
 	lf.pStr = Str;
 	lf.CharCount = (COUNT)~0;
@@ -241,11 +249,12 @@ DrawNameString (bool nameCaptain, UNICOD
 		if ((text_r.extent.width + 2) >= r.extent.width)
 		{	// the text does not fit the input box size and so
 			// will not fit when displayed later
-			UnlockMutex (GraphicsLock);
 			// disallow the change
 			return (FALSE);
 		}
 
+		PreUpdateFlashRect ();
+
 		SetContextForeGroundColor (BackGround);
 		DrawFilledRectangle (&r);
 
@@ -254,7 +263,7 @@ DrawNameString (bool nameCaptain, UNICOD
 			text_r.corner.x += *pchar_deltas++;
 		if (CursorPos < lf.CharCount) /* end of line */
 			--text_r.corner.x;
-		
+
 		if (state & DDSHS_BLOCKCUR)
 		{	// Use block cursor for keyboardless systems
 			if (CursorPos == lf.CharCount)
@@ -274,7 +283,7 @@ DrawNameString (bool nameCaptain, UNICOD
 		{	// Insertion point cursor
 			text_r.extent.width = 1;
 		}
-		
+
 		text_r.corner.y = r.corner.y;
 		text_r.extent.height = r.extent.height;
 		SetContextForeGroundColor (BLACK_COLOR);
@@ -283,10 +292,9 @@ DrawNameString (bool nameCaptain, UNICOD
 		SetContextForeGroundColor (ForeGround);
 		font_DrawText (&lf);
 
-		SetFlashRect (&r);
+		PostUpdateFlashRect ();
 	}
 
-	UnlockMutex (GraphicsLock);
 	return (TRUE);
 }
 
@@ -309,15 +317,11 @@ NameCaptainOrShip (bool nameCaptain)
 	TEXTENTRY_STATE tes;
 	UNICODE *Setting;
 
-	LockMutex (GraphicsLock);
-	SetFlashRect (NULL);
-	UnlockMutex (GraphicsLock);
+	SetFlashRect (nameCaptain ? &captainNameRect : &shipNameRect);
 
 	DrawNameString (nameCaptain, buf, 0, DDSHS_EDIT);
 
-	LockMutex (GraphicsLock);
 	DrawStatusMessage (GAME_STRING (NAMING_STRING_BASE + 0));
-	UnlockMutex (GraphicsLock);
 
 	if (nameCaptain)
 	{
@@ -342,17 +346,190 @@ NameCaptainOrShip (bool nameCaptain)
 		utf8StringCopy (Setting, tes.MaxSize, buf);
 	else
 		utf8StringCopy (buf, sizeof (buf), Setting);
-	
-	LockMutex (GraphicsLock);
+
 	SetFlashRect (SFR_MENU_3DO);
-	UnlockMutex (GraphicsLock);
-	
+
 	DrawNameString (nameCaptain, buf, 0, DDSHS_NORMAL);
 
 	if (namingCB)
 		namingCB ();
+}
+
+static BOOLEAN
+DrawSaveNameString (UNICODE *Str, COUNT CursorPos, COUNT state, COUNT gameIndex)
+{
+	RECT r;
+	TEXT lf;
+	Color BackGround, ForeGround;
+	FONT Font;
+	UNICODE fullStr[256], dateStr[80];
+
+	DateToString (dateStr, sizeof dateStr, GLOBAL(GameClock.month_index),
+			GLOBAL(GameClock.day_index), GLOBAL(GameClock.year_index));
+	strncat (dateStr, ": ", sizeof(dateStr) - strlen(dateStr) -1);
+	snprintf (fullStr, sizeof fullStr, "%s%s", dateStr, Str);
+
+	SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x1B, 0x00, 0x1B), 0x33));
+	r.extent.width = 15;
+	if (MAX_SAVED_GAMES > 99)
+		r.extent.width += 5;
+	r.extent.height = 11;
+	r.corner.x = 8;
+	r.corner.y = (160 + ((gameIndex % SAVES_PER_PAGE) * 13));
+	DrawRectangle (&r);
+
+	r.extent.width = (204 - SAFE_X);
+	r.corner.x = (30 + SAFE_X);
+	DrawRectangle (&r);
+
+	Font = TinyFont;
+	lf.baseline.x = r.corner.x + 3;
+	lf.baseline.y = r.corner.y + 8;
+
+	BackGround = BUILD_COLOR (MAKE_RGB15 (0x1B, 0x00, 0x1B), 0x33);
+	ForeGround = BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01);
+
+	lf.align = ALIGN_LEFT;
+
+	SetContextFont (Font);
+	lf.pStr = fullStr;
+	lf.CharCount = (COUNT)~0;
+
+	if (!(state & DDSHS_EDIT))
+	{
+		TEXT t;
+
+		SetContextForeGroundColor (BLACK_COLOR);
+		DrawFilledRectangle (&r);
+
+		t.baseline.x = r.corner.x + 3;
+		t.baseline.y = r.corner.y + 8;
+		t.align = ALIGN_LEFT;
+		t.pStr = Str;
+		t.CharCount = (COUNT)~0;
+		SetContextForeGroundColor (CAPTAIN_NAME_TEXT_COLOR);
+		font_DrawText (&lf);
+	}
+	else
+	{	// editing state
+		COUNT i, FullCursorPos;
+		RECT text_r;
+		BYTE char_deltas[256];
+		BYTE *pchar_deltas;
+
+		TextRect (&lf, &text_r, char_deltas);
+		if ((text_r.extent.width + 2) >= r.extent.width)
+		{	// the text does not fit the input box size and so
+			// will not fit when displayed later
+			// disallow the change
+			return (FALSE);
+		}
+
+		PreUpdateFlashRect ();
+
+		SetContextForeGroundColor (BackGround);
+		DrawFilledRectangle (&r);
+
+		pchar_deltas = char_deltas;
+
+		FullCursorPos = CursorPos + strlen(dateStr) - 1;
+		for (i = FullCursorPos; i > 0; --i)
+			text_r.corner.x += *pchar_deltas++;
+
+		if (FullCursorPos < lf.CharCount) /* end of line */
+			--text_r.corner.x;
+
+		if (state & DDSHS_BLOCKCUR)
+		{	// Use block cursor for keyboardless systems
+			if (FullCursorPos == lf.CharCount)
+			{	// cursor at end-line -- use insertion point
+				text_r.extent.width = 1;
+			}
+			else if (FullCursorPos + 1 == lf.CharCount)
+			{	// extra pixel for last char margin
+				text_r.extent.width = (SIZE)*pchar_deltas + 2;
+			}
+			else
+			{	// normal mid-line char
+				text_r.extent.width = (SIZE)*pchar_deltas + 1;
+			}
+		}
+		else
+		{	// Insertion point cursor
+			text_r.extent.width = 1;
+		}
+
+		text_r.corner.y = r.corner.y;
+		text_r.extent.height = r.extent.height;
+		SetContextForeGroundColor (BLACK_COLOR);
+		DrawFilledRectangle (&text_r);
+
+		SetContextForeGroundColor (ForeGround);
+		font_DrawText (&lf);
+		PostUpdateFlashRect ();
+	}
+
+	return (TRUE);
+}
+
+static BOOLEAN
+OnSaveNameChange (TEXTENTRY_STATE *pTES)
+{
+	COUNT hl = DDSHS_EDIT;
+	COUNT *gameIndex = pTES->CbParam;
+
+	if (pTES->JoystickMode)
+		hl |= DDSHS_BLOCKCUR;
+
+	return DrawSaveNameString (pTES->BaseStr, pTES->CursorPos, hl, *gameIndex);
+}
+
+static BOOLEAN
+NameSaveGame (COUNT gameIndex, UNICODE *buf)
+{
+	TEXTENTRY_STATE tes;
+	COUNT CursPos = strlen(buf);
+	COUNT *gIndex = HMalloc (sizeof (COUNT));
+	RECT r;
+	*gIndex = gameIndex;
+
+	DrawSaveNameString (buf, CursPos, DDSHS_EDIT, gameIndex);
+
+	tes.MaxSize = SAVE_NAME_SIZE;
+
+	// text entry setup
+	tes.Initialized = FALSE;
+	tes.BaseStr = buf;
+	tes.CursorPos = CursPos;
+	tes.CbParam = gIndex;
+	tes.ChangeCallback = OnSaveNameChange;
+	tes.FrameCallback = 0;
+	r.extent.width = (204 - SAFE_X);
+	r.extent.height = 11;
+	r.corner.x = (30 + SAFE_X);
+	r.corner.y = (160 + ((gameIndex % SAVES_PER_PAGE) * 13));
+	SetFlashRect (&r);
+
+	if (!DoTextEntry (&tes))
+		buf[0] = 0;
+
+	SetFlashRect(NULL);
+
+	DrawSaveNameString (buf, CursPos, DDSHS_NORMAL, gameIndex);
+
+	if (namingCB)
+		namingCB ();
 
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
+
+	HFree (gIndex);
+
+	SetFlashRect (NULL);
+
+	if (tes.Success)
+		return (TRUE);
+	else
+		return (FALSE);
 }
 
 void
@@ -434,9 +611,7 @@ SettingsMenu (void)
 	MenuState.InputFunc = DoSettings;
 	DoInput (&MenuState, FALSE);
 
-	LockMutex (GraphicsLock);
 	DrawStatusMessage (NULL);
-	UnlockMutex (GraphicsLock);
 }
 
 typedef struct
@@ -610,7 +785,7 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 		UninitQueue (&GLOBAL (built_ship_q));
 
 		SetContextClipRect (&OldRect);
-		
+
 		SetContext (SpaceContext);
 		// draw devices
 		s.origin.y = 13;
@@ -661,10 +836,8 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 			r.corner.y = SIS_ORG_Y + 84;
 			r.extent = OldRect.extent;
 			SetContextClipRect (&r);
-			UnlockMutex (GraphicsLock);
 			// draw the lander with upgrades
 			InitLander (pSD->Flags | OVERRIDE_LANDER_FLAGS);
-			LockMutex (GraphicsLock);
 			SetContextClipRect (&OldRect);
 			SetContext (SpaceContext);
 
@@ -681,7 +854,7 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 		SetContextForeGroundColor (
 				BUILD_COLOR (MAKE_RGB15 (0x10, 0x00, 0x10), 0x01));
 		font_DrawText (&t);
-		
+
 		// print the location
 		t.baseline.x = 6;
 		t.baseline.y = 139 + 6;
@@ -698,7 +871,7 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 			{
 				BYTE QuasiState;
 				STAR_DESC *SDPtr;
-				
+
 				QuasiState = GET_GAME_STATE (ARILOU_SPACE_SIDE);
 				SET_GAME_STATE (ARILOU_SPACE_SIDE, 0);
 				SDPtr = FindStar (NULL, &starPt, 1, 1);
@@ -771,11 +944,11 @@ DrawGameSelection (PICK_GAME_STATE *pick
 	COUNT curSlot;
 	UNICODE buf[256];
 	UNICODE buf2[80];
-	
+
 	BatchGraphics ();
 
 	SetContextFont (TinyFont);
-	
+
 	// Erase the selection menu
 	r.extent.width = 240;
 	r.extent.height = 65;
@@ -826,9 +999,7 @@ DrawGameSelection (PICK_GAME_STATE *pick
 		{
 			DateToString (buf2, sizeof buf2, desc->month_index,
 					desc->day_index, desc->year_index);
-			snprintf (buf, sizeof buf, "%s %s",
-					GAME_STRING (SAVEGAME_STRING_BASE + 4), buf2);
-						// "Saved Game - Date:"
+			snprintf (buf, sizeof buf, "%s: %s", buf2, desc->SaveName[0] ? desc->SaveName : GAME_STRING (SAVEGAME_STRING_BASE + 4));
 		}
 		font_DrawText (&t);
 	}
@@ -925,13 +1096,11 @@ DoPickGame (MENU_STATE *pMS)
 
 		if (NewState != pMS->CurState)
 		{
-			LockMutex (GraphicsLock);
 			pMS->CurState = NewState;
 			SetContext (SpaceContext);
 			RedrawPickDisplay (pickState, pMS->CurState);
-			UnlockMutex (GraphicsLock);
 		}
-		
+
 		SleepThreadUntil (TimeIn + ONE_SECOND / 30);
 	}
 
@@ -939,32 +1108,44 @@ DoPickGame (MENU_STATE *pMS)
 }
 
 static BOOLEAN
-SaveLoadGame (PICK_GAME_STATE *pickState, COUNT gameIndex)
+SaveLoadGame (PICK_GAME_STATE *pickState, COUNT gameIndex, BOOLEAN *canceled_by_user)
 {
 	SUMMARY_DESC *desc = pickState->summary + gameIndex;
+	UNICODE nameBuf[256];
 	STAMP saveStamp;
 	BOOLEAN success;
 
 	saveStamp.frame = NULL;
 
-	// TODO: fix ConfirmSaveLoad() interface so it does not rely on
-	//   MsgStamp != NULL parameter.
-	LockMutex (GraphicsLock);
-	ConfirmSaveLoad (pickState->saving ? &saveStamp : NULL);
-	UnlockMutex (GraphicsLock);
-
 	if (pickState->saving)
-		success = SaveGame (gameIndex, desc);
+	{
+		// Initialize the save name with whatever name is there already
+		// SAVE_NAME_SIZE is less than 256, so this is safe.
+		strncpy(nameBuf, desc->SaveName, SAVE_NAME_SIZE);
+		nameBuf[SAVE_NAME_SIZE] = 0;
+		if (NameSaveGame (gameIndex, nameBuf))
+		{
+			PlayMenuSound (MENU_SOUND_SUCCESS);
+			ConfirmSaveLoad (pickState->saving ? &saveStamp : NULL);
+			success = SaveGame (gameIndex, desc, nameBuf);
+		}
+		else
+		{
+			success = FALSE;
+			*canceled_by_user = TRUE;
+		}
+	}
 	else
+	{
+		ConfirmSaveLoad (pickState->saving ? &saveStamp : NULL);
 		success = LoadGame (gameIndex, NULL);
+	}
 
 	// TODO: the same should be done for both save and load if we also
 	//   display a load problem message
 	if (pickState->saving)
 	{	// restore the screen under "SAVING..." message
-		LockMutex (GraphicsLock);
 		DrawStamp (&saveStamp);
-		UnlockMutex (GraphicsLock);
 	}
 
 	DestroyDrawable (ReleaseDrawable (saveStamp.frame));
@@ -999,12 +1180,10 @@ PickGame (BOOLEAN saving, BOOLEAN fromMa
 
 	LoadGameDescriptions (pickState.summary);
 
-	LockMutex (GraphicsLock);
 	OldContext = SetContext (SpaceContext);
 	// Save the current state of the screen for later restoration
 	DlgStamp = SaveContextFrame (NULL);
 	GetContextClipRect (&DlgRect);
-	UnlockMutex (GraphicsLock);
 
 	SleepThreadUntil (TimeOut);
 	PauseMusic ();
@@ -1012,15 +1191,14 @@ PickGame (BOOLEAN saving, BOOLEAN fromMa
 	FadeMusic (NORMAL_VOLUME, 0);
 
 	// draw the current savegame and fade in
-	LockMutex (GraphicsLock);
 	SetTransitionSource (NULL);
 	BatchGraphics ();
-	
+
 	SetContextBackGroundColor (BLACK_COLOR);
 	ClearDrawable ();
 	RedrawPickDisplay (&pickState, MenuState.CurState);
 	DrawSaveLoad (&pickState);
-	
+
 	if (fromMainMenu)
 	{
 		UnbatchGraphics ();
@@ -1034,15 +1212,16 @@ PickGame (BOOLEAN saving, BOOLEAN fromMa
 		ScreenTransition (3, &ctxRect);
 		UnbatchGraphics ();
 	}
-	UnlockMutex (GraphicsLock);
 
 	SetMenuSounds (MENU_SOUND_ARROWS | MENU_SOUND_PAGEUP | MENU_SOUND_PAGEDOWN,
 			0);
 	MenuState.InputFunc = DoPickGame;
-	
+
 	// Save/load retry loop
 	while (1)
 	{
+		BOOLEAN canceled_by_user = FALSE;
+
 		pickState.success = FALSE;
 		DoInput (&MenuState, TRUE);
 		if (!pickState.success)
@@ -1050,19 +1229,17 @@ PickGame (BOOLEAN saving, BOOLEAN fromMa
 
 		lastUsedSlot = MenuState.CurState;
 
-		if (SaveLoadGame (&pickState, MenuState.CurState))
+		if (SaveLoadGame (&pickState, MenuState.CurState, &canceled_by_user))
 			break; // all good
 
 		// something broke
-		if (saving)
+		if (saving && !canceled_by_user)
 			SaveProblem ();
 		// TODO: Shouldn't we have a Problem() equivalent for Load too?
 
 		// reload and redraw everything
 		LoadGameDescriptions (pickState.summary);
-		LockMutex (GraphicsLock);
 		RedrawPickDisplay (&pickState, MenuState.CurState);
-		UnlockMutex (GraphicsLock);
 	}
 
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
@@ -1071,24 +1248,20 @@ PickGame (BOOLEAN saving, BOOLEAN fromMa
 	{	// Load succeeded, signal up the chain
 		GLOBAL (CurrentActivity) |= CHECK_LOAD;
 	}
-	
+
 	if (!(GLOBAL (CurrentActivity) & CHECK_ABORT) &&
 			(saving || (!pickState.success && !fromMainMenu)))
 	{	// Restore previous screen
-		LockMutex (GraphicsLock);
 		SetTransitionSource (&DlgRect);
 		BatchGraphics ();
 		DrawStamp (&DlgStamp);
 		ScreenTransition (3, &DlgRect);
 		UnbatchGraphics ();
-		UnlockMutex (GraphicsLock);
 	}
 
 	DestroyDrawable (ReleaseDrawable (DlgStamp.frame));
 
-	LockMutex (GraphicsLock);
 	SetContext (OldContext);
-	UnlockMutex (GraphicsLock);
 
 	ResumeMusic ();
 
@@ -1116,14 +1289,10 @@ DoGameOptions (MENU_STATE *pMS)
 		{
 			case SAVE_GAME:
 			case LOAD_GAME:
-				LockMutex (GraphicsLock);
 				SetFlashRect (NULL);
-				UnlockMutex (GraphicsLock);
 				if (PickGame (pMS->CurState == SAVE_GAME, FALSE))
 					return FALSE;
-				LockMutex (GraphicsLock);
 				SetFlashRect (SFR_MENU_3DO);
-				UnlockMutex (GraphicsLock);
 				break;
 			case QUIT_GAME:
 				if (ConfirmExit ())
@@ -1165,18 +1334,13 @@ GameOptions (void)
 	MenuState.CurState = SAVE_GAME;
 	DrawMenuStateStrings (PM_SAVE_GAME, MenuState.CurState);
 
-	LockMutex (GraphicsLock);
 	SetFlashRect (SFR_MENU_3DO);
-	UnlockMutex (GraphicsLock);
-	
+
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
 	MenuState.InputFunc = DoGameOptions;
 	DoInput (&MenuState, TRUE);
 
-	LockMutex (GraphicsLock);
 	SetFlashRect (NULL);
-	UnlockMutex (GraphicsLock);
 
 	return !(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD));
 }
-
diff -ruNp src.orig/uqm/gameopt.h src/uqm/gameopt.h
--- src.orig/uqm/gameopt.h	2017-11-21 19:39:38 -0600
+++ src/uqm/gameopt.h	2017-11-21 19:39:55 -0600
@@ -19,11 +19,19 @@
 #include "libs/compiler.h"
 #include "libs/gfxlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern void ConfirmSaveLoad (STAMP *MsgStamp);
 extern BOOLEAN GameOptions (void);
 
 typedef void (NamingCallback) (void);
 extern void SetNamingCallback (NamingCallback *);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _GAMEOPT_H */
 
diff -ruNp src.orig/uqm/gamestr.h src/uqm/gamestr.h
--- src.orig/uqm/gamestr.h	2017-11-21 19:39:38 -0600
+++ src/uqm/gamestr.h	2017-11-21 19:39:55 -0600
@@ -25,6 +25,10 @@
 
 #include "libs/strlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #define STAR_STRING_COUNT       133
 #define DEVICE_STRING_COUNT      29
 #define CARGO_STRING_COUNT       10
@@ -82,5 +86,9 @@ extern STRING GameStrings;
 
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _GAMESTR_H */
 
diff -ruNp src.orig/uqm/gendef.c src/uqm/gendef.c
--- src.orig/uqm/gendef.c	2017-11-21 19:39:38 -0600
+++ src/uqm/gendef.c	2017-11-21 19:39:55 -0600
@@ -17,7 +17,6 @@
  */
 
 #include "gendef.h"
-#include "encount.h"
 #include "planets/generate.h"
 
 
diff -ruNp src.orig/uqm/gendef.h src/uqm/gendef.h
--- src.orig/uqm/gendef.h	2017-11-21 19:39:38 -0600
+++ src/uqm/gendef.h	2017-11-21 19:39:55 -0600
@@ -4,7 +4,68 @@
 #include "planets/generate.h"
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 const GenerateFunctions *getGenerateFunctions (BYTE Index);
 
+enum
+{
+	SOL_DEFINED = 1,
+	SHOFIXTI_DEFINED,
+	MAIDENS_DEFINED,
+	START_COLONY_DEFINED,
+	SPATHI_DEFINED,
+	ZOQFOT_DEFINED,
+
+	MELNORME0_DEFINED,
+	MELNORME1_DEFINED,
+	MELNORME2_DEFINED,
+	MELNORME3_DEFINED,
+	MELNORME4_DEFINED,
+	MELNORME5_DEFINED,
+	MELNORME6_DEFINED,
+	MELNORME7_DEFINED,
+	MELNORME8_DEFINED,
+
+	TALKING_PET_DEFINED,
+	CHMMR_DEFINED,
+	SYREEN_DEFINED,
+	BURVIXESE_DEFINED,
+	SLYLANDRO_DEFINED,
+	DRUUGE_DEFINED,
+	BOMB_DEFINED,
+	AQUA_HELIX_DEFINED,
+	SUN_DEVICE_DEFINED,
+	TAALO_PROTECTOR_DEFINED,
+	SHIP_VAULT_DEFINED,
+	URQUAN_WRECK_DEFINED,
+	VUX_BEAST_DEFINED,
+	SAMATRA_DEFINED,
+	ZOQ_SCOUT_DEFINED,
+	MYCON_DEFINED,
+	EGG_CASE0_DEFINED,
+	EGG_CASE1_DEFINED,
+	EGG_CASE2_DEFINED,
+	PKUNK_DEFINED,
+	UTWIG_DEFINED,
+	SUPOX_DEFINED,
+	YEHAT_DEFINED,
+	VUX_DEFINED,
+	ORZ_DEFINED,
+	THRADD_DEFINED,
+	RAINBOW_DEFINED,
+	ILWRATH_DEFINED,
+	ANDROSYNTH_DEFINED,
+	MYCON_TRAP_DEFINED
+};
+
+#define UMGAH_DEFINED TALKING_PET_DEFINED
+
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* GENDEF_H */
 
diff -ruNp src.orig/uqm/globdata.c src/uqm/globdata.c
--- src.orig/uqm/globdata.c	2017-11-21 19:39:38 -0600
+++ src/uqm/globdata.c	2017-11-21 19:39:55 -0600
@@ -20,6 +20,7 @@
 
 #include "coderes.h"
 #include "encount.h"
+#include "starmap.h"
 #include "master.h"
 #include "setup.h"
 #include "units.h"
@@ -30,11 +31,11 @@
 #include "state.h"
 #include "grpinfo.h"
 #include "gamestr.h"
+#include "libs/scriptlib.h"
+#include "libs/log.h"
 
+#include <assert.h>
 #include <stdlib.h>
-#ifdef STATE_DEBUG
-#	include "libs/log.h"
-#endif
 
 
 static void CreateRadar (void);
@@ -44,79 +45,241 @@ FRAME PlayFrame;
 
 GLOBDATA GlobData;
 
-static BOOLEAN initedGameStructs = FALSE;
 
+// Pre: 0 <= bits <= 32
+// This function is necessary because expressions such as '(1 << bits) - 1'
+// or '~(~0 << bits)' may shift by 32 bits, which is undefined (for 32 bits
+// integers). This is not a hypothetical issue; 'uint8_t numBits = 32;
+// printf("%u\n", (1 << numBits));' will return 1 on x86 when compiled with
+// gcc (4.4.3).
+static inline DWORD
+bitmask32 (BYTE bits)
+{
+	return (bits >= 32) ? 0xffffffff : ((1U << bits) - 1);
+}
 
-BYTE
-getGameState (int startBit, int endBit)
+// Pre: 0 <= bits <= 32
+// This function is necessary because shifting by 32 bits is undefined (for
+// 32 bits integers). This is not a hypothetical issue; 'uint8_t numBits =
+// 32; printf("%u\n", (1 << numBits));' will return 1 on x86 when compiled
+// with gcc (4.4.3).
+static inline DWORD
+shl32 (DWORD value, BYTE shift)
 {
-	return (BYTE) (((startBit >> 3) == (endBit >> 3)
-			? (GLOBAL (GameState[startBit >> 3]) >> (startBit & 7))
-			: ((GLOBAL (GameState[startBit >> 3]) >> (startBit & 7))
-			  | (GLOBAL (GameState[endBit >> 3])
-			  << (endBit - startBit - (endBit & 7)))))
-			& ((1 << (endBit - startBit + 1)) - 1));
+	return (shift >= 32) ? 0 : (value << shift);
 }
 
-void
-setGameState (int startBit, int endBit, BYTE val
-#ifdef STATE_DEBUG
-		, const char *name
-#endif
-)
+// Returns the total number of bits which are needed to store a game state
+// according to 'bm'.
+static size_t
+totalBitsForGameState (const GameStateBitMap *bm)
 {
-	GLOBAL (GameState[startBit >> 3]) =
-			(GLOBAL (GameState[startBit >> 3])
-			& (BYTE) ~(((1 << (endBit - startBit + 1)) - 1) << (startBit & 7)))
-			| (BYTE)((val) << (startBit & 7));
-
-	if ((startBit >> 3) < (endBit >> 3)) {
-		GLOBAL (GameState[endBit >> 3]) =
-				(GLOBAL (GameState[endBit >> 3])
-				& (BYTE)~((1 << ((endBit & 7) + 1)) - 1))
-				| (BYTE)((val) >> (endBit - startBit - (endBit & 7)));
+	size_t totalBits = 0;
+	const GameStateBitMap *bmPtr;
+
+	for (bmPtr = bm; bmPtr->name != NULL; bmPtr++)
+		totalBits += bmPtr->numBits;
+
+	return totalBits;
+}
+
+// Write 'valueBitCount' bits from 'value' into the buffer pointed to
+// by '*bufPtrPtr'.
+// '*restBitsPtr' is used to store the bits in which do not make up
+// a byte yet. The number of bits stored is kept in '*restBitCount'.
+static inline void
+serialiseBits (BYTE **bufPtrPtr, DWORD *restBitsPtr, size_t *restBitCount,
+		BYTE value, size_t valueBitCount)
+{
+	BYTE valueBitMask;
+
+	assert (*restBitCount < 8);
+	assert (valueBitCount <= 8);
+
+	valueBitMask = (1 << valueBitCount) - 1;
+
+	// Add the bits from 'value' to the working 'buffer' (*restBits).
+	*restBitsPtr |= (value & valueBitMask) << *restBitCount;
+	*restBitCount += valueBitCount;
+
+	// Write out restBits (possibly partialy), if we have enough bits to
+	// make a byte.
+	if (*restBitCount >= 8)
+	{
+		**bufPtrPtr = *restBitsPtr & 0xff;
+		*restBitsPtr >>= 8;
+		(*bufPtrPtr)++;
+		*restBitCount -= 8;
 	}
-#ifdef STATE_DEBUG
-	log_add (log_Debug, "State '%s' set to %d.", name, (int)val);
-#endif
 }
 
-DWORD
-getGameState32 (int startBit)
+// Serialise the current game state into a newly allocated buffer,
+// according to the GameStateBitMap 'bm'.
+// Only the (integer) values from 'bm' are saved, in the specified order.
+// This function fills in '*buf' with the newly allocated buffer, and
+// '*numBytes' with its size. The caller becomes the owner of '*buf' and
+// is responsible for freeing it.
+BOOLEAN
+serialiseGameState (const GameStateBitMap *bm, BYTE **buf, size_t *numBytes)
 {
-	DWORD v;
-	int shift;
+	size_t totalBits;
+	size_t totalBytes;
+	const GameStateBitMap *bmPtr;
+	BYTE *result;
+	BYTE *bufPtr;
+
+	DWORD restBits = 0;
+			// Bits which have not yet been stored because they did not form
+			// an entire byte.
+	size_t restBitCount = 0;
+
+	// Determine the total number of bits/bytes required.
+	totalBits = totalBitsForGameState (bm);
+	totalBytes = (totalBits + 7) / 8;
+
+	// Allocate memory for the serialised data.
+	result = HMalloc (totalBytes);
+	if (result == NULL)
+		return FALSE;
 
-	for (v = 0, shift = 0; shift < 32; shift += 8, startBit += 8)
+	bufPtr = result;
+	for (bmPtr = bm; bmPtr->name != NULL; bmPtr++)
 	{
-		v |= getGameState (startBit, startBit + 7) << shift;
+		DWORD value = getGameStateUint (bmPtr->name);
+		BYTE numBits = bmPtr->numBits;
+
+#ifdef STATE_DEBUG
+		log_add (log_Debug, "Saving: GameState[\'%s\'] = %u", bmPtr->name,
+				value);
+#endif  /* STATE_DEBUG */
+
+		if (value > bitmask32(numBits))
+		{
+			log_add (log_Error, "Warning: serialiseGameState(): the value "
+					"of the property '%s' (%u) does not fit in the reserved "
+					"number of bits (%d).", bmPtr->name, value, numBits);
+		}
+
+		// Store multi-byte values with the least significant byte first.
+		while (numBits >= 8)
+		{
+		
+			serialiseBits (&bufPtr, &restBits, &restBitCount, value & 0xff, 8);
+			value >>= 8;
+			numBits -= 8;
+		}
+		if (numBits > 0)
+			serialiseBits (&bufPtr, &restBits, &restBitCount, value, numBits);
 	}
 
-	return v;
+	// Pad the end up to a byte.
+	if (restBitCount > 0)
+		serialiseBits (&bufPtr, &restBits, &restBitCount, 0, 8 - restBitCount);
+
+	*buf = result;
+	*numBytes = totalBytes;
+	return TRUE;
 }
 
-void
-setGameState32 (int startBit, DWORD val
-#ifdef STATE_DEBUG
-		, const char *name
-#endif
-)
+// Read 'numBits' bits from '*bytePtr', starting at the bit offset
+// '*bitPtr'. The result is returned.
+// '*bitPtr' and '*bytePtr' are updated by this function.
+static inline DWORD
+deserialiseBits (const BYTE **bytePtr, BYTE *bitPtr, size_t numBits) {
+	assert (*bitPtr < 8);
+	assert (numBits <= 8);
+
+	if (numBits <= (size_t) (8 - *bitPtr))
+	{
+		// Can get the entire value from one byte.
+		// We want bits *bitPtr through (excluding) *bitPtr+numBits
+		DWORD result = ((*bytePtr)[0] >> *bitPtr) & bitmask32(numBits);
+
+		// Update the pointers.
+		if (numBits == (size_t) (8 - *bitPtr))
+		{
+			// The entire (rest of the) byte is read. Go to the next byte.
+			(*bytePtr)++;
+			*bitPtr = 0;
+		}
+		else
+		{
+			// There are still unread bits in the byte.
+			*bitPtr += numBits;
+		}
+		return result;
+	}
+	else
+	{
+		// The result comes from two bytes.
+		// We get the *bitPtr most significant bits from [0], as the least
+		// significant bits of the result, and the (numBits - *bitPtr) least
+		// significant bits from [1], as the most significant bits of the
+		// result.
+		DWORD result = (((*bytePtr)[0] >> *bitPtr)
+				| ((*bytePtr)[1] << (8 - *bitPtr))) &
+				bitmask32(numBits);
+		(*bytePtr)++;
+		*bitPtr += numBits - 8;
+		return result;
+	}
+}
+
+// Deserialise the current game state from the bit array in 'buf', which
+// has size 'numBytes', according to the GameStateBitMap 'bm'.
+BOOLEAN
+deserialiseGameState (const GameStateBitMap *bm,
+		const BYTE *buf, size_t numBytes)
 {
-	DWORD v = val;
-	int i;
+	size_t totalBits;
+	const GameStateBitMap *bmPtr;
 
-	for (i = 0; i < 4; ++i, v >>= 8, startBit += 8)
+	const BYTE *bytePtr = buf;
+	BYTE bitPtr = 0;
+			// Number of bits already processed from the byte pointed at by
+			// bytePtr.
+
+	// Sanity check: determine the number of bits required, and check
+	// whether 'numBytes' is large enough.
+	totalBits = totalBitsForGameState (bm);
+	if (numBytes * 8 < totalBits)
 	{
-		setGameState (startBit, startBit + 7, v & 0xff
-#ifdef STATE_DEBUG
-				, "(ignored)"
-#endif
-				);
+		log_add (log_Error, "Warning: deserialiseGameState(): Corrupt "
+				"save game: state: less bytes available than expected.");
+		return FALSE;
 	}
 
+	for (bmPtr = bm; bmPtr->name != NULL; bmPtr++)
+	{
+		DWORD value = 0;
+		BYTE numBits = bmPtr->numBits;
+		BYTE bitsLeft = numBits;
+
+		// Multi-byte values are stored with the least significant byte
+		// first.
+		while (bitsLeft >= 8)
+		{
+			DWORD bits = deserialiseBits (&bytePtr, &bitPtr, 8);
+			value |= shl32(bits, numBits - bitsLeft);
+			bitsLeft -= 8;
+		}
+		if (bitsLeft > 0) {
+			value |= shl32(deserialiseBits (&bytePtr, &bitPtr, bitsLeft),
+					numBits - bitsLeft);
+		}
+	
+#ifdef STATE_DEBUG
+		log_add (log_Debug, "Loading: GameState[\'%s\'] = %u", bmPtr->name,
+				value);
+#endif  /* STATE_DEBUG */
+
+		setGameStateUint (bmPtr->name, value);
+	}
 #ifdef STATE_DEBUG
-	log_add (log_Debug, "State '%s' set to %u.", name, (unsigned)val);
-#endif
+	fflush (stderr);
+#endif  /* STATE_DEBUG */
+
+	return TRUE;
 }
 
 static void
@@ -177,6 +340,7 @@ copyFleetInfo (FLEET_INFO *dst, SHIP_INF
 	dst->max_crew = src->max_crew;
 	dst->max_energy = src->max_energy;
 
+	dst->shipIdStr = src->idStr;
 	dst->race_strings = src->race_strings;
 	dst->icons = src->icons;
 	dst->melee_icon = src->melee_icon;
@@ -336,7 +500,7 @@ InitGameStructures (void)
 			sizeof (GLOBAL_SIS (CommanderName)),
 			GAME_STRING (NAMING_STRING_BASE + 3));
 
-	ActivateStarShip (HUMAN_SHIP, SET_ALLIED);
+	SetRaceAllied (HUMAN_SHIP, TRUE);
 	CloneShipFragment (HUMAN_SHIP, &GLOBAL (built_ship_q), 0);
 
 	GLOBAL_SIS (log_x) = UNIVERSE_TO_LOGX (SOL_X);
@@ -345,17 +509,6 @@ InitGameStructures (void)
 	GLOBAL (autopilot.x) = ~0;
 	GLOBAL (autopilot.y) = ~0;
 
-	/* In case the program is exited before the full game is terminated,
-	 * make sure that the temporary files are deleted.
-	 * This can be removed if we make sure if the full game is terminated
-	 * before the game is exited.
-	 * The initedSIS variable is added so the uninit won't happen more
-	 * than once, as you can't remove the atexit function (when the full game
-	 * ends).
-	 */
-	initedGameStructs = TRUE;
-	atexit (UninitGameStructures);
-
 	return (TRUE);
 }
 
@@ -377,9 +530,6 @@ UninitGameStructures (void)
 {
 	HFLEETINFO hStarShip;
 
-	if (!initedGameStructs)
-		return;
-
 	UninitQueue (&GLOBAL (encounter_q));
 	UninitQueue (&GLOBAL (ip_group_q));
 	UninitQueue (&GLOBAL (npc_built_ship_q));
@@ -407,7 +557,6 @@ UninitGameStructures (void)
 	
 	DestroyDrawable (ReleaseDrawable (PlayFrame));
 	PlayFrame = 0;
-	initedGameStructs = FALSE;
 }
 
 void
@@ -423,4 +572,88 @@ InitGlobData (void)
 }
 
 
+BOOLEAN
+inFullGame (void)
+{
+	ACTIVITY act = LOBYTE (GLOBAL (CurrentActivity));
+	return (act == IN_LAST_BATTLE || act == IN_ENCOUNTER ||
+			act == IN_HYPERSPACE || act == IN_INTERPLANETARY ||
+			act == WON_LAST_BATTLE);
+}
+
+BOOLEAN
+inSuperMelee (void)
+{
+	return (LOBYTE (GLOBAL (CurrentActivity)) == SUPER_MELEE);
+			// TODO: && !inMainMenu ()
+}
+
+#if 0
+BOOLEAN
+inBattle (void)
+{
+	// TODO: IN_BATTLE is also set while in HyperSpace/QuasiSpace.
+	return ((GLOBAL (CurrentActivity) & IN_BATTLE) != 0);
+}
+#endif
+
+#if 0
+// Disabled for now as there are similar functions in uqm/planets/planets.h
+// Pre: inFullGame()
+BOOLEAN
+inInterPlanetary (void)
+{
+	assert (inFullGame ());
+	return (pSolarSysState != NULL);
+}
+
+// Pre: inFullGame()
+BOOLEAN
+inSolarSystem (void)
+{
+	assert (inFullGame ());
+	return (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY);
+}
+
+// Pre: inFullGame()
+BOOLEAN
+inOrbit (void)
+{
+	assert (inFullGame ());
+	return (pSolarSysState != NULL) &&
+			(pSolarSysState->pOrbitalDesc != NULL);
+}
+#endif
+
+// In HyperSpace or QuasiSpace
+// Pre: inFullGame()
+BOOLEAN
+inHQSpace (void)
+{
+	//assert (inFullGame ());
+	return (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE);
+			// IN_HYPERSPACE is also set for QuasiSpace
+}
+
+// In HyperSpace
+// Pre: inFullGame()
+BOOLEAN
+inHyperSpace (void)
+{
+	//assert (inFullGame ());
+	return (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE) &&
+				(GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1);
+			// IN_HYPERSPACE is also set for QuasiSpace
+}
+
+// In QuasiSpace
+// Pre: inFullGame()
+BOOLEAN
+inQuasiSpace (void)
+{
+	//assert (inFullGame ());
+	return (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE) &&
+				(GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1);
+			// IN_HYPERSPACE is also set for QuasiSpace
+}
 
diff -ruNp src.orig/uqm/globdata.h src/uqm/globdata.h
--- src.orig/uqm/globdata.h	2017-11-21 19:39:38 -0600
+++ src/uqm/globdata.h	2017-11-21 19:39:55 -0600
@@ -26,6 +26,11 @@
 #include "sis.h"
 #include "velocity.h"
 #include "commanim.h"
+#include "lua/luastate.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
 
 // general numbers-speech generator info
@@ -168,10 +173,26 @@ enum
 
 #define YEARS_TO_KOHRAH_VICTORY 4
 
+// A structure describing how many bits are used for each game state value.
+typedef struct GameStateBitMap GameStateBitMap;
+struct GameStateBitMap {
+	const char *name;
+	BYTE numBits;
+};
+
+BOOLEAN serialiseGameState (const GameStateBitMap *bm,
+		BYTE **buf, size_t *numBytes);
+BOOLEAN deserialiseGameState (const GameStateBitMap *bm,
+		const BYTE *buf, size_t numBytes);
+
 #define START_GAME_STATE enum {
 #define ADD_GAME_STATE(SName,NumBits) SName, END_##SName = SName + NumBits - 1,
 #define END_GAME_STATE NUM_GAME_STATE_BITS };
 
+// This enum is now only used for the symbolic names, and the comments.
+// XXX: When all the dialogs are moved to Lua scripts, this will become
+// obsolete. Perhaps it would be best to move the comments to
+// content/base/script/initgame/initprops.lua then.
 START_GAME_STATE
 		/* Shofixti states */
 	ADD_GAME_STATE (SHOFIXTI_VISITS, 3)
@@ -251,61 +272,6 @@ START_GAME_STATE
 
 	ADD_GAME_STATE (LANDER_SHIELDS, 4)
 
-	ADD_GAME_STATE (SHOFIXTI_GRPOFFS0, 8)
-	ADD_GAME_STATE (SHOFIXTI_GRPOFFS1, 8)
-	ADD_GAME_STATE (SHOFIXTI_GRPOFFS2, 8)
-	ADD_GAME_STATE (SHOFIXTI_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (ZOQFOT_GRPOFFS0, 8)
-	ADD_GAME_STATE (ZOQFOT_GRPOFFS1, 8)
-	ADD_GAME_STATE (ZOQFOT_GRPOFFS2, 8)
-	ADD_GAME_STATE (ZOQFOT_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (MELNORME0_GRPOFFS0, 8)
-	ADD_GAME_STATE (MELNORME0_GRPOFFS1, 8)
-	ADD_GAME_STATE (MELNORME0_GRPOFFS2, 8)
-	ADD_GAME_STATE (MELNORME0_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (MELNORME1_GRPOFFS0, 8)
-	ADD_GAME_STATE (MELNORME1_GRPOFFS1, 8)
-	ADD_GAME_STATE (MELNORME1_GRPOFFS2, 8)
-	ADD_GAME_STATE (MELNORME1_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (MELNORME2_GRPOFFS0, 8)
-	ADD_GAME_STATE (MELNORME2_GRPOFFS1, 8)
-	ADD_GAME_STATE (MELNORME2_GRPOFFS2, 8)
-	ADD_GAME_STATE (MELNORME2_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (MELNORME3_GRPOFFS0, 8)
-	ADD_GAME_STATE (MELNORME3_GRPOFFS1, 8)
-	ADD_GAME_STATE (MELNORME3_GRPOFFS2, 8)
-	ADD_GAME_STATE (MELNORME3_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (MELNORME4_GRPOFFS0, 8)
-	ADD_GAME_STATE (MELNORME4_GRPOFFS1, 8)
-	ADD_GAME_STATE (MELNORME4_GRPOFFS2, 8)
-	ADD_GAME_STATE (MELNORME4_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (MELNORME5_GRPOFFS0, 8)
-	ADD_GAME_STATE (MELNORME5_GRPOFFS1, 8)
-	ADD_GAME_STATE (MELNORME5_GRPOFFS2, 8)
-	ADD_GAME_STATE (MELNORME5_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (MELNORME6_GRPOFFS0, 8)
-	ADD_GAME_STATE (MELNORME6_GRPOFFS1, 8)
-	ADD_GAME_STATE (MELNORME6_GRPOFFS2, 8)
-	ADD_GAME_STATE (MELNORME6_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (MELNORME7_GRPOFFS0, 8)
-	ADD_GAME_STATE (MELNORME7_GRPOFFS1, 8)
-	ADD_GAME_STATE (MELNORME7_GRPOFFS2, 8)
-	ADD_GAME_STATE (MELNORME7_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (MELNORME8_GRPOFFS0, 8)
-	ADD_GAME_STATE (MELNORME8_GRPOFFS1, 8)
-	ADD_GAME_STATE (MELNORME8_GRPOFFS2, 8)
-	ADD_GAME_STATE (MELNORME8_GRPOFFS3, 8)
-
 	ADD_GAME_STATE (MET_MELNORME, 1)
 	ADD_GAME_STATE (MELNORME_RESCUE_REFUSED, 1)
 	ADD_GAME_STATE (MELNORME_RESCUE_COUNT, 3)
@@ -325,10 +291,6 @@ START_GAME_STATE
 	ADD_GAME_STATE (MELNORME_PISSED_COUNT, 2)
 	ADD_GAME_STATE (MELNORME_HATE_COUNT, 2)
 
-	ADD_GAME_STATE (URQUAN_PROBE_GRPOFFS0, 8)
-	ADD_GAME_STATE (URQUAN_PROBE_GRPOFFS1, 8)
-	ADD_GAME_STATE (URQUAN_PROBE_GRPOFFS2, 8)
-	ADD_GAME_STATE (URQUAN_PROBE_GRPOFFS3, 8)
 	ADD_GAME_STATE (PROBE_MESSAGE_DELIVERED, 1)
 	ADD_GAME_STATE (PROBE_ILWRATH_ENCOUNTER, 1)
 
@@ -595,6 +557,7 @@ START_GAME_STATE
 	ADD_GAME_STATE (MELNORME_INFO_PROCEDURE, 1)
 
 	ADD_GAME_STATE (MELNORME_TECH_STACK, 4)
+			/* MELNORME_TECH_STACK is now unused */
 	ADD_GAME_STATE (MELNORME_EVENTS_INFO_STACK, 5)
 	ADD_GAME_STATE (MELNORME_ALIEN_INFO_STACK, 5)
 	ADD_GAME_STATE (MELNORME_HISTORY_INFO_STACK, 5)
@@ -625,13 +588,16 @@ START_GAME_STATE
 	ADD_GAME_STATE (UMGAH_BROADCASTERS_ON_SHIP, 1)
 
 	ADD_GAME_STATE (LIGHT_MINERAL_LOAD, 3)
+			/* Number of times the captain has brought in a light mineral
+			 * load (<1000 RU). Max 6. */
 	ADD_GAME_STATE (MEDIUM_MINERAL_LOAD, 3)
+			/* Number of times the captain has brought in a medium mineral
+			 * load (>=1000 RU, <2500 RU). Max 6. */
 	ADD_GAME_STATE (HEAVY_MINERAL_LOAD, 3)
+			/* Number of times the captain has brought in a heavy mineral
+			 * load (>=2500 RU). Max 6. */
 
-	ADD_GAME_STATE (STARBASE_BULLETS0, 8)
-	ADD_GAME_STATE (STARBASE_BULLETS1, 8)
-	ADD_GAME_STATE (STARBASE_BULLETS2, 8)
-	ADD_GAME_STATE (STARBASE_BULLETS3, 8)
+	ADD_GAME_STATE (STARBASE_BULLETS, 32)
 
 	ADD_GAME_STATE (STARBASE_MONTH, 4)
 	ADD_GAME_STATE (STARBASE_DAY, 5)
@@ -642,11 +608,6 @@ START_GAME_STATE
 
 	ADD_GAME_STATE (URQUAN_PROTECTING_SAMATRA, 1)
 
-	ADD_GAME_STATE (COLONY_GRPOFFS0, 8)
-	ADD_GAME_STATE (COLONY_GRPOFFS1, 8)
-	ADD_GAME_STATE (COLONY_GRPOFFS2, 8)
-	ADD_GAME_STATE (COLONY_GRPOFFS3, 8)
-
 #define THRADDASH_BODY_THRESHOLD 25
 	ADD_GAME_STATE (THRADDASH_BODY_COUNT, 5)
 
@@ -666,11 +627,6 @@ START_GAME_STATE
 	ADD_GAME_STATE (ILWRATH_WORSHIP, 2)
 	ADD_GAME_STATE (ILWRATH_FIGHT_THRADDASH, 1)
 
-	ADD_GAME_STATE (SAMATRA_GRPOFFS0, 8)
-	ADD_GAME_STATE (SAMATRA_GRPOFFS1, 8)
-	ADD_GAME_STATE (SAMATRA_GRPOFFS2, 8)
-	ADD_GAME_STATE (SAMATRA_GRPOFFS3, 8)
-
 	ADD_GAME_STATE (READY_TO_CONFUSE_URQUAN, 1)
 	ADD_GAME_STATE (URQUAN_HYPNO_VISITS, 1)
 	ADD_GAME_STATE (MENTIONED_PET_COMPULSION, 1)
@@ -872,6 +828,24 @@ START_GAME_STATE
 
 	ADD_GAME_STATE (ORZ_STACK0, 1)
 	ADD_GAME_STATE (ORZ_STACK1, 1)
+
+/* These state bits are actually offsets into defgrp.dat. They really
+ * shouldn't be part of the serialized Game State array! --MCM */
+	ADD_GAME_STATE (SHOFIXTI_GRPOFFS, 32)
+	ADD_GAME_STATE (ZOQFOT_GRPOFFS, 32)
+	ADD_GAME_STATE (MELNORME0_GRPOFFS, 32)
+	ADD_GAME_STATE (MELNORME1_GRPOFFS, 32)
+	ADD_GAME_STATE (MELNORME2_GRPOFFS, 32)
+	ADD_GAME_STATE (MELNORME3_GRPOFFS, 32)
+	ADD_GAME_STATE (MELNORME4_GRPOFFS, 32)
+	ADD_GAME_STATE (MELNORME5_GRPOFFS, 32)
+	ADD_GAME_STATE (MELNORME6_GRPOFFS, 32)
+	ADD_GAME_STATE (MELNORME7_GRPOFFS, 32)
+	ADD_GAME_STATE (MELNORME8_GRPOFFS, 32)
+	ADD_GAME_STATE (URQUAN_PROBE_GRPOFFS, 32)
+	ADD_GAME_STATE (COLONY_GRPOFFS, 32)
+	ADD_GAME_STATE (SAMATRA_GRPOFFS, 32)
+
 END_GAME_STATE
 
 // Values for GAME_STATE.glob_flags:
@@ -887,7 +861,7 @@ enum
 	SUPER_MELEE = 0, /* Is also used while in the main menu */
 	IN_LAST_BATTLE,
 	IN_ENCOUNTER,
-	IN_HYPERSPACE /* in Hyperspace or Quasispace */,
+	IN_HYPERSPACE /* in HyperSpace or QuasiSpace */,
 	IN_INTERPLANETARY,
 	WON_LAST_BATTLE,
 
@@ -899,6 +873,7 @@ enum
 
 	CHECK_PAUSE = MAKE_WORD (0, (1 << 0)),
 	IN_BATTLE = MAKE_WORD (0, (1 << 1)),
+			/* Is also set while in HyperSpace/QuasiSpace */
 	START_ENCOUNTER = MAKE_WORD (0, (1 << 2)),
 	START_INTERPLANETARY = MAKE_WORD (0, (1 << 3)),
 	CHECK_LOAD = MAKE_WORD (0, (1 << 4)),
@@ -947,8 +922,6 @@ typedef struct
 	QUEUE built_ship_q;
 			/* List of SIS escort ships;
 			 * queue element is SHIP_FRAGMENT */
-
-	BYTE GameState[(NUM_GAME_STATE_BITS + 7) >> 3];
 } GAME_STATE;
 
 typedef struct
@@ -964,41 +937,35 @@ extern GLOBDATA GlobData;
 #define MAX_ENCOUNTERS  16
 #define MAX_BATTLE_GROUPS 32
 
-//#define STATE_DEBUG
-	
-extern BYTE getGameState (int startBit, int endBit);
-extern void setGameState (int startBit, int endBit, BYTE val
-#ifdef STATE_DEBUG
-		, const char *name
-#endif
-		);
-
-#define GET_GAME_STATE(SName) getGameState ((SName), (END_##SName))
-#ifdef STATE_DEBUG
-#	define SET_GAME_STATE(SName, val) \
-			setGameState ((SName), (END_##SName), (val), #SName)
-#else
-#	define SET_GAME_STATE(SName, val) \
-			setGameState ((SName), (END_##SName), (val))
-#endif
+/* DEFGRP enumeration. These identify scripted TrueSpace encounters
+ * more consistently than offsets into the DEFGRPINFO_FILE state
+ * file. */
+enum {
+	DEFGRP_NONE,
+	DEFGRP_SHOFIXTI,
+	DEFGRP_ZOQFOT,
+	DEFGRP_MELNORME0,
+	DEFGRP_MELNORME1,
+	DEFGRP_MELNORME2,
+	DEFGRP_MELNORME3,
+	DEFGRP_MELNORME4,
+	DEFGRP_MELNORME5,
+	DEFGRP_MELNORME6,
+	DEFGRP_MELNORME7,
+	DEFGRP_MELNORME8,
+	DEFGRP_URQUAN_PROBE,
+	DEFGRP_COLONY,
+	DEFGRP_SAMATRA,
+	NUM_DEFGRPS
+};
 
-extern DWORD getGameState32 (int startBit);
-extern void setGameState32 (int startBit, DWORD val
-#ifdef STATE_DEBUG
-		, const char *name
-#endif
-		);
+//#define STATE_DEBUG
 
-#define GET_GAME_STATE_32(SName) getGameState32 ((SName))
-#ifdef STATE_DEBUG
-#	define SET_GAME_STATE_32(SName, val) \
-			setGameState32 ((SName), (val), #SName)
-#else
-#	define SET_GAME_STATE_32(SName, val) \
-			setGameState32 ((SName), (val))
-#endif
+#define SET_GAME_STATE(SName, val) \
+		setGameStateUint (#SName, (val))
+#define GET_GAME_STATE(SName) \
+		getGameStateUint (#SName)
 
-	
 extern CONTEXT RadarContext;
 
 extern void FreeSC2Data (void);
@@ -1006,8 +973,22 @@ extern BOOLEAN LoadSC2Data (void);
 
 extern void InitGlobData (void);
 
+BOOLEAN inFullGame (void);
+BOOLEAN inSuperMelee (void);
+//BOOLEAN inBattle (void);
+//BOOLEAN inInterPlanetary (void);
+//BOOLEAN inSolarSystem (void);
+//BOOLEAN inOrbit (void);
+BOOLEAN inHQSpace (void);
+BOOLEAN inHyperSpace (void);
+BOOLEAN inQuasiSpace (void);
+
 extern BOOLEAN InitGameStructures (void);
 extern void UninitGameStructures (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _GLOBDATA_H */
 
diff -ruNp src.orig/uqm/grpinfo.c src/uqm/grpinfo.c
--- src.orig/uqm/grpinfo.c	2017-11-21 19:39:38 -0600
+++ src/uqm/grpinfo.c	2017-11-21 19:39:55 -0600
@@ -17,13 +17,13 @@
  */
 
 #include "build.h"
-// XXX: for CurStarDescPtr and XXX_DEFINED constants
-#include "encount.h"
+#include "starmap.h"
+#include "gendef.h"
 #include "libs/file.h"
 #include "globdata.h"
 #include "intel.h"
 #include "state.h"
-#include "grpinfo.h"
+#include "grpintrn.h"
 
 #include "libs/mathlib.h"
 #include "libs/log.h"
@@ -35,43 +35,8 @@
 static BYTE LastEncGroup;
 		// Last encountered group, saved into state files
 
-//#define DEBUG_GROUPS
-
-// A group header describes battle groups present in a star system. There is
-//    at most 1 group header per system.
-// 'Random' group info file (RANDGRPINFO_FILE) always contains only one
-//    group header record, which describes the last-visited star system,
-//    (which may be the current system). Thus the randomly generated groups
-//    are valid for 7 days (set in PutGroupInfo) after the player leaves 
-//    the system, or until the player enters another star system.
-typedef struct
-{
-	BYTE NumGroups;
-	BYTE day_index, month_index;
-	COUNT star_index, year_index;
-			// day_index, month_index, year_index specify when
-			//   random groups expire (if you were to leave the system
-			//   by going to HSpace and stay there till such time)
-			// star_index is the index of a star this group header
-			//   applies to; ~0 means uninited
-	DWORD GroupOffset[NUM_SAVED_BATTLE_GROUPS + 1];
-			// Absolute offsets of group definitions in a state file
-			// Group 0 is a list of groups present in solarsys
-			//    (RANDGRPINFO_FILE only)
-			// Groups 1..max are definitions of actual battle groups
-			//    containing ship makeup and status
-
-	// Each group has the following format:
-	// 1 byte, RaceType (LastEncGroup in Group 0)
-	// 1 byte, NumShips (NumGroups in Group 0)
-	// Ships follow:
-	// 1 byte, RaceType
-	// 16 bytes, part of SHIP_FRAGMENT struct
-
-} GROUP_HEADER;
-
-static void
-ReadGroupHeader (void *fp, GROUP_HEADER *pGH)
+void
+ReadGroupHeader (GAME_STATE_FILE *fp, GROUP_HEADER *pGH)
 {
 	sread_8   (fp, &pGH->NumGroups);
 	sread_8   (fp, &pGH->day_index);
@@ -82,8 +47,8 @@ ReadGroupHeader (void *fp, GROUP_HEADER
 	sread_a32 (fp, pGH->GroupOffset, NUM_SAVED_BATTLE_GROUPS + 1);
 }
 
-static void
-WriteGroupHeader (void *fp, const GROUP_HEADER *pGH)
+void
+WriteGroupHeader (GAME_STATE_FILE *fp, const GROUP_HEADER *pGH)
 {
 	swrite_8   (fp, pGH->NumGroups);
 	swrite_8   (fp, pGH->day_index);
@@ -94,8 +59,8 @@ WriteGroupHeader (void *fp, const GROUP_
 	swrite_a32 (fp, pGH->GroupOffset, NUM_SAVED_BATTLE_GROUPS + 1);
 }
 
-static void
-ReadShipFragment (void *fp, SHIP_FRAGMENT *FragPtr)
+void
+ReadShipFragment (GAME_STATE_FILE *fp, SHIP_FRAGMENT *FragPtr)
 {
 	BYTE tmpb;
 
@@ -116,8 +81,8 @@ ReadShipFragment (void *fp, SHIP_FRAGMEN
 	sread_16 (fp, NULL); /* unused; was loc.y */
 }
 
-static void
-WriteShipFragment (void *fp, const SHIP_FRAGMENT *FragPtr)
+void
+WriteShipFragment (GAME_STATE_FILE *fp, const SHIP_FRAGMENT *FragPtr)
 {
 	swrite_16 (fp, 0); /* unused: was which_side */
 	swrite_8  (fp, FragPtr->captains_name_index);
@@ -134,8 +99,8 @@ WriteShipFragment (void *fp, const SHIP_
 	swrite_16 (fp, 0); /* unused; was loc.y */
 }
 
-static void
-ReadIpGroup (void *fp, IP_GROUP *GroupPtr)
+void
+ReadIpGroup (GAME_STATE_FILE *fp, IP_GROUP *GroupPtr)
 {
 	BYTE tmpb;
 
@@ -157,8 +122,8 @@ ReadIpGroup (void *fp, IP_GROUP *GroupPt
 	sread_16s(fp, &GroupPtr->loc.y);
 }
 
-static void
-WriteIpGroup (void *fp, const IP_GROUP *GroupPtr)
+void
+WriteIpGroup (GAME_STATE_FILE *fp, const IP_GROUP *GroupPtr)
 {
 	swrite_16 (fp, 0); /* unused; was which_side */
 	swrite_8  (fp, 0); /* unused; was captains_name_index */
@@ -181,7 +146,7 @@ WriteIpGroup (void *fp, const IP_GROUP *
 void
 InitGroupInfo (BOOLEAN FirstTime)
 {
-	void *fp;
+	GAME_STATE_FILE *fp;
 
 	assert (NUM_SAVED_BATTLE_GROUPS >= MAX_BATTLE_GROUPS);
 
@@ -413,7 +378,7 @@ FoundHome:
 }
 
 static void
-FlushGroupInfo (GROUP_HEADER* pGH, DWORD offset, BYTE which_group, void *fp)
+FlushGroupInfo (GROUP_HEADER* pGH, DWORD offset, BYTE which_group, GAME_STATE_FILE *fp)
 {
 	if (which_group == GROUP_LIST)
 	{
@@ -549,7 +514,7 @@ FlushGroupInfo (GROUP_HEADER* pGH, DWORD
 BOOLEAN
 GetGroupInfo (DWORD offset, BYTE which_group)
 {
-	void *fp;
+	GAME_STATE_FILE *fp;
 	GROUP_HEADER GH;
 
 	if (offset != GROUPS_RANDOM && which_group != GROUP_LIST)
@@ -828,7 +793,7 @@ GetGroupInfo (DWORD offset, BYTE which_g
 DWORD
 PutGroupInfo (DWORD offset, BYTE which_group)
 {
-	void *fp;
+	GAME_STATE_FILE *fp;
 	GROUP_HEADER GH;
 
 	if (offset != GROUPS_RANDOM && which_group != GROUP_LIST)
diff -ruNp src.orig/uqm/grpinfo.h src/uqm/grpinfo.h
--- src.orig/uqm/grpinfo.h	2017-11-21 19:39:38 -0600
+++ src/uqm/grpinfo.h	2017-11-21 19:39:55 -0600
@@ -24,6 +24,10 @@
 		// for POINT
 #include <assert.h>
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 // XXX: Needed to maintain savegame compatibility
 #define NUM_SAVED_BATTLE_GROUPS 64
 
@@ -82,4 +86,8 @@ LockIpGroup (const QUEUE *pq, HIPGROUP h
 
 extern HIPGROUP BuildGroup (QUEUE *pDstQueue, BYTE race_id);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _GRPINFO_H */
diff -ruNp src.orig/uqm/grpintrn.h src/uqm/grpintrn.h
--- src.orig/uqm/grpintrn.h	1969-12-31 18:00:00 -0600
+++ src/uqm/grpintrn.h	2017-11-21 19:39:55 -0600
@@ -0,0 +1,56 @@
+#ifndef _GRPINTRN_H
+#define _GRPINTRN_H
+
+// For IPGROUP
+#include "grpinfo.h"
+
+// For SHIP_FRAGMENT
+#include "races.h"
+
+// For GAME_STATE_FILE
+#include "state.h"
+
+//#define DEBUG_GROUPS
+
+// A group header describes battle groups present in a star system. There is
+//    at most 1 group header per system.
+// 'Random' group info file (RANDGRPINFO_FILE) always contains only one
+//    group header record, which describes the last-visited star system,
+//    (which may be the current system). Thus the randomly generated groups
+//    are valid for 7 days (set in PutGroupInfo) after the player leaves 
+//    the system, or until the player enters another star system.
+typedef struct
+{
+	BYTE NumGroups;
+	BYTE day_index, month_index;
+	COUNT star_index, year_index;
+			// day_index, month_index, year_index specify when
+			//   random groups expire (if you were to leave the system
+			//   by going to HSpace and stay there till such time)
+			// star_index is the index of a star this group header
+			//   applies to; ~0 means uninited
+	DWORD GroupOffset[NUM_SAVED_BATTLE_GROUPS + 1];
+			// Absolute offsets of group definitions in a state file
+			// Group 0 is a list of groups present in solarsys
+			//    (RANDGRPINFO_FILE only)
+			// Groups 1..max are definitions of actual battle groups
+			//    containing ship makeup and status
+
+	// Each group has the following format:
+	// 1 byte, RaceType (LastEncGroup in Group 0)
+	// 1 byte, NumShips (NumGroups in Group 0)
+	// Ships follow:
+	// 1 byte, RaceType
+	// 16 bytes, part of SHIP_FRAGMENT struct 
+        //                  (part of IP_GROUP struct in Group 0)
+
+} GROUP_HEADER;
+
+void ReadGroupHeader (GAME_STATE_FILE *fp, GROUP_HEADER *pGH);
+void WriteGroupHeader (GAME_STATE_FILE *fp, const GROUP_HEADER *pGH);
+void ReadShipFragment (GAME_STATE_FILE *fp, SHIP_FRAGMENT *FragPtr);
+void WriteShipFragment (GAME_STATE_FILE *fp, const SHIP_FRAGMENT *FragPtr);
+void ReadIpGroup (GAME_STATE_FILE *fp, IP_GROUP *GroupPtr);
+void WriteIpGroup (GAME_STATE_FILE *fp, const IP_GROUP *GroupPtr);
+
+#endif
diff -ruNp src.orig/uqm/hyper.c src/uqm/hyper.c
--- src.orig/uqm/hyper.c	2017-11-21 19:39:38 -0600
+++ src/uqm/hyper.c	2017-11-21 19:39:55 -0600
@@ -26,6 +26,7 @@
 #include "menustat.h"
 		// for DrawMenuStateStrings()
 #include "encount.h"
+#include "starmap.h"
 #include "ship.h"
 #include "shipcont.h"
 #include "process.h"
@@ -225,13 +226,13 @@ check_hyperspace_encounter (void)
 					encounter_flags = ONE_SHOT_ENCOUNTER;
 				}
 
-
+				// There can be only one! (of either Slylandro or Melnorme)
 				for (hEncounter = GetHeadEncounter ();
 						hEncounter; hEncounter = hNextEncounter)
 				{
 					LockEncounter (hEncounter, &EncounterPtr);
 					hNextEncounter = GetSuccEncounter (EncounterPtr);
-					if (EncounterPtr->SD.Type == Type)
+					if (EncounterPtr->race_id == Type)
 					{
 						percent = 0;
 						hNextEncounter = 0;
@@ -266,8 +267,8 @@ check_hyperspace_encounter (void)
 					memset (EncounterPtr, 0, sizeof (*EncounterPtr));
 					EncounterPtr->origin = FleetPtr->loc;
 					EncounterPtr->radius = encounter_radius;
-					EncounterPtr->SD.Index = encounter_flags;
-					EncounterPtr->SD.Type = Type;
+					EncounterPtr->flags = encounter_flags;
+					EncounterPtr->race_id = Type;
 					UnlockEncounter (hEncounter);
 
 					PutEncounter (hEncounter);
@@ -758,7 +759,7 @@ arilou_space_collision (ELEMENT *Element
 }
 
 static HELEMENT
-AllocHyperElement (STAR_DESC *SDPtr)
+AllocHyperElement (const POINT *elem_pt)
 {
 	HELEMENT hHyperSpaceElement;
 
@@ -776,11 +777,11 @@ AllocHyperElement (STAR_DESC *SDPtr)
 		{
 			long lx, ly;
 
-			lx = UNIVERSE_TO_LOGX (SDPtr->star_pt.x)
+			lx = UNIVERSE_TO_LOGX (elem_pt->x)
 					+ (LOG_SPACE_WIDTH >> 1) - GLOBAL_SIS (log_x);
 			HyperSpaceElementPtr->current.location.x = WRAP_X (lx);
 
-			ly = UNIVERSE_TO_LOGY (SDPtr->star_pt.y)
+			ly = UNIVERSE_TO_LOGY (elem_pt->y)
 					+ (LOG_SPACE_HEIGHT >> 1) - GLOBAL_SIS (log_y);
 			HyperSpaceElementPtr->current.location.y = WRAP_Y (ly);
 		}
@@ -951,25 +952,25 @@ AddEncounterElement (ENCOUNTER *Encounte
 {
 	BOOLEAN NewEncounter;
 	HELEMENT hElement;
-	STAR_DESC SD;
+	POINT enc_pt;
 	
 	if (GET_GAME_STATE (ARILOU_SPACE_SIDE) >= 2)
 		return 0;
 
-	if (EncounterPtr->SD.Index & ENCOUNTER_REFORMING)
+	if (EncounterPtr->flags & ENCOUNTER_REFORMING)
 	{
-		EncounterPtr->SD.Index &= ~ENCOUNTER_REFORMING;
+		EncounterPtr->flags &= ~ENCOUNTER_REFORMING;
 
 		EncounterPtr->transition_state = 100;
-		if ((EncounterPtr->SD.Index & ONE_SHOT_ENCOUNTER)
-				|| LONIBBLE (EncounterPtr->SD.Index) == 0)
+		if ((EncounterPtr->flags & ONE_SHOT_ENCOUNTER)
+				|| EncounterPtr->num_ships == 0)
 			return 0;
 	}
 
-	if (LONIBBLE (EncounterPtr->SD.Index))
+	if (EncounterPtr->num_ships)
 	{
 		NewEncounter = FALSE;
-		SD.star_pt = EncounterPtr->SD.star_pt;
+		enc_pt = EncounterPtr->loc_pt;
 	}
 	else
 	{
@@ -987,7 +988,7 @@ AddEncounterElement (ENCOUNTER *Encounte
 
 		radius_squared = (DWORD)EncounterPtr->radius * EncounterPtr->radius;
 
-		Type = EncounterPtr->SD.Type;
+		Type = EncounterPtr->race_id;
 		NumShips = LONIBBLE (EncounterMakeup[Type]);
 		for (i = HINIBBLE (EncounterMakeup[Type]) - NumShips; i; --i)
 		{
@@ -998,9 +999,7 @@ AddEncounterElement (ENCOUNTER *Encounte
 		if (NumShips > MAX_HYPER_SHIPS)
 			NumShips = MAX_HYPER_SHIPS;
 
-
-		EncounterPtr->SD.Index =
-				MAKE_BYTE (NumShips, HINIBBLE (EncounterPtr->SD.Index));
+		EncounterPtr->num_ships = NumShips;
 		for (i = 0; i < NumShips; ++i)
 		{
 			BRIEF_SHIP_INFO *BSIPtr = &EncounterPtr->ShipList[i];
@@ -1021,29 +1020,29 @@ AddEncounterElement (ENCOUNTER *Encounte
 
 			rand_val = TFB_Random ();
 
-			SD.star_pt.x = puniverse->x
+			enc_pt.x = puniverse->x
 					+ (LOWORD (rand_val) % (XOFFS << 1)) - XOFFS;
-			if (SD.star_pt.x < 0)
-				SD.star_pt.x = 0;
-			else if (SD.star_pt.x > MAX_X_UNIVERSE)
-				SD.star_pt.x = MAX_X_UNIVERSE;
-			SD.star_pt.y = puniverse->y
+			if (enc_pt.x < 0)
+				enc_pt.x = 0;
+			else if (enc_pt.x > MAX_X_UNIVERSE)
+				enc_pt.x = MAX_X_UNIVERSE;
+			enc_pt.y = puniverse->y
 					+ (HIWORD (rand_val) % (YOFFS << 1)) - YOFFS;
-			if (SD.star_pt.y < 0)
-				SD.star_pt.y = 0;
-			else if (SD.star_pt.y > MAX_Y_UNIVERSE)
-				SD.star_pt.y = MAX_Y_UNIVERSE;
+			if (enc_pt.y < 0)
+				enc_pt.y = 0;
+			else if (enc_pt.y > MAX_Y_UNIVERSE)
+				enc_pt.y = MAX_Y_UNIVERSE;
 
-			dx = SD.star_pt.x - EncounterPtr->origin.x;
-			dy = SD.star_pt.y - EncounterPtr->origin.y;
+			dx = enc_pt.x - EncounterPtr->origin.x;
+			dy = enc_pt.y - EncounterPtr->origin.y;
 		} while ((DWORD)((long)dx * dx + (long)dy * dy) > radius_squared);
 
-		EncounterPtr->SD.star_pt = SD.star_pt;
-		EncounterPtr->log_x = UNIVERSE_TO_LOGX (SD.star_pt.x);
-		EncounterPtr->log_y = UNIVERSE_TO_LOGY (SD.star_pt.y);
+		EncounterPtr->loc_pt = enc_pt;
+		EncounterPtr->log_x = UNIVERSE_TO_LOGX (enc_pt.x);
+		EncounterPtr->log_y = UNIVERSE_TO_LOGY (enc_pt.y);
 	}
 
-	hElement = AllocHyperElement (&SD);
+	hElement = AllocHyperElement (&enc_pt);
 	if (hElement)
 	{
 		SIZE i;
@@ -1197,8 +1196,8 @@ ProcessEncounter (ENCOUNTER *EncounterPt
 			cur_facing = ANGLE_TO_FACING (
 					GetVelocityTravelAngle (&ElementPtr->velocity));
 			delta_facing = NORMALIZE_FACING (cur_facing - ANGLE_TO_FACING (
-					ARCTAN (puniverse->x - EncounterPtr->SD.star_pt.x,
-					puniverse->y - EncounterPtr->SD.star_pt.y)));
+					ARCTAN (puniverse->x - EncounterPtr->loc_pt.x,
+					puniverse->y - EncounterPtr->loc_pt.y)));
 			if (delta_facing || (delta_x == 0 && delta_y == 0))
 			{
 				SIZE speed;
@@ -1208,7 +1207,7 @@ ProcessEncounter (ENCOUNTER *EncounterPt
 				};
 
 #define ENCOUNTER_TRACK_WAIT 3
-				speed = RaceHyperSpeed[EncounterPtr->SD.Type];
+				speed = RaceHyperSpeed[EncounterPtr->race_id];
 				if (delta_facing < ANGLE_TO_FACING (HALF_CIRCLE))
 					--cur_facing;
 				else
@@ -1233,14 +1232,14 @@ ProcessEncounter (ENCOUNTER *EncounterPt
 		}
 		EncounterPtr->log_x += delta_x;
 		EncounterPtr->log_y -= delta_y;
-		EncounterPtr->SD.star_pt.x = LOGX_TO_UNIVERSE (EncounterPtr->log_x);
-		EncounterPtr->SD.star_pt.y = LOGY_TO_UNIVERSE (EncounterPtr->log_y);
+		EncounterPtr->loc_pt.x = LOGX_TO_UNIVERSE (EncounterPtr->log_x);
+		EncounterPtr->loc_pt.y = LOGY_TO_UNIVERSE (EncounterPtr->log_y);
 
 		encounter_radius = EncounterPtr->radius + (GRID_OFFSET >> 1);
-		delta_x = EncounterPtr->SD.star_pt.x - EncounterPtr->origin.x;
+		delta_x = EncounterPtr->loc_pt.x - EncounterPtr->origin.x;
 		if (delta_x < 0)
 			delta_x = -delta_x;
-		delta_y = EncounterPtr->SD.star_pt.y - EncounterPtr->origin.y;
+		delta_y = EncounterPtr->loc_pt.y - EncounterPtr->origin.y;
 		if (delta_y < 0)
 			delta_y = -delta_y;
 		if ((COUNT)delta_x >= encounter_radius
@@ -1248,6 +1247,7 @@ ProcessEncounter (ENCOUNTER *EncounterPt
 				|| (DWORD)delta_x * delta_x + (DWORD)delta_y * delta_y >=
 				(DWORD)encounter_radius * encounter_radius)
 		{
+			// Encounter globe traveled outside the SoI and now disappears
 			ElementPtr->state_flags |= NONSOLID;
 			ElementPtr->life_span = 0;
 
@@ -1266,8 +1266,8 @@ ProcessEncounter (ENCOUNTER *EncounterPt
 		}
 	}
 
-	ex = EncounterPtr->SD.star_pt.x;
-	ey = EncounterPtr->SD.star_pt.y;
+	ex = EncounterPtr->loc_pt.x;
+	ey = EncounterPtr->loc_pt.y;
 	if (ex - puniverse->x >= -UNIT_SCREEN_WIDTH
 			&& ex - puniverse->x <= UNIT_SCREEN_WIDTH
 			&& ey - puniverse->y >= -UNIT_SCREEN_HEIGHT
@@ -1482,7 +1482,7 @@ SeedUniverse (void)
 					|| ey > (YOFFS / NUM_RADAR_SCREENS))
 				continue;
 
-			hHyperSpaceElement = AllocHyperElement (&SD[i]);
+			hHyperSpaceElement = AllocHyperElement (&SD[i].star_pt);
 			if (hHyperSpaceElement == 0)
 				continue;
 
@@ -1527,7 +1527,7 @@ SeedUniverse (void)
 					|| ey > (YOFFS / NUM_RADAR_SCREENS))
 				continue;
 
-			hHyperSpaceElement = AllocHyperElement (SDPtr);
+			hHyperSpaceElement = AllocHyperElement (&SDPtr->star_pt);
 			if (hHyperSpaceElement == 0)
 				continue;
 
@@ -1633,9 +1633,7 @@ DoHyperspaceMenu (MENU_STATE *pMS)
 	if (!select)
 		return TRUE;
 
-	LockMutex (GraphicsLock);
 	SetFlashRect (NULL);
-	UnlockMutex (GraphicsLock);
 
 	switch (pMS->CurState)
 	{
@@ -1675,9 +1673,7 @@ DoHyperspaceMenu (MENU_STATE *pMS)
 				pMS->CurState = NAVIGATION;
 			DrawMenuStateStrings (PM_STARMAP, pMS->CurState);
 		}
-		LockMutex (GraphicsLock);
 		SetFlashRect (SFR_MENU_3DO);
-		UnlockMutex (GraphicsLock);
 	}
 
 	return TRUE;
@@ -1695,7 +1691,6 @@ UnbatchGraphics ();
 	OldContext = SetContext (SpaceContext);
 	OldColor = SetContextBackGroundColor (BLACK_COLOR);
 
-	UnlockMutex (GraphicsLock);
 
 	memset (&MenuState, 0, sizeof (MenuState));
 	MenuState.InputFunc = DoHyperspaceMenu;
@@ -1703,14 +1698,11 @@ UnbatchGraphics ();
 	MenuState.CurState = STARMAP;
 
 	DrawMenuStateStrings (PM_STARMAP, STARMAP);
-	LockMutex (GraphicsLock);
 	SetFlashRect (SFR_MENU_3DO);
-	UnlockMutex (GraphicsLock);
 
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
 	DoInput (&MenuState, TRUE);
 
-	LockMutex (GraphicsLock);
 	SetFlashRect (NULL);
 
 	SetContext (SpaceContext);
@@ -1718,9 +1710,7 @@ UnbatchGraphics ();
 	if (!(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD)))
 	{
 		ClearSISRect (CLEAR_SIS_RADAR);
-		UnlockMutex (GraphicsLock);
 		WaitForNoInput (ONE_SECOND / 2, FALSE);
-		LockMutex (GraphicsLock);
 	}
 
 	SetContextBackGroundColor (OldColor);
diff -ruNp src.orig/uqm/hyper.h src/uqm/hyper.h
--- src.orig/uqm/hyper.h	2017-11-21 19:39:38 -0600
+++ src/uqm/hyper.h	2017-11-21 19:39:55 -0600
@@ -23,6 +23,10 @@
 #include "units.h"
 		// for UNIT_SCREEN_WIDTH/HEIGHT
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #define NUM_RADAR_SCREENS 12
 
 #define RADAR_SCAN_WIDTH (UNIT_SCREEN_WIDTH * NUM_RADAR_SCREENS)
@@ -79,5 +83,9 @@ extern BOOLEAN hyper_transition (ELEMENT
 extern void HyperspaceMenu (void);
 extern void SaveSisHyperState (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _HYPER_H */
 
diff -ruNp src.orig/uqm/init.c src/uqm/init.c
--- src.orig/uqm/init.c	2017-11-21 19:39:38 -0600
+++ src/uqm/init.c	2017-11-21 19:39:55 -0600
@@ -187,7 +187,7 @@ InitShips (void)
 	InitDisplayList ();
 	InitGalaxy ();
 
-	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+	if (inHQSpace ())
 	{
 		ReinitQueue (&race_q[0]);
 		ReinitQueue (&race_q[1]);
@@ -311,9 +311,6 @@ UninitShips (void)
 							crew_retrieved;
 			}
 
-			if (StarShipPtr->RaceDescPtr->uninit_func != NULL)
-				(*StarShipPtr->RaceDescPtr->uninit_func) (
-						StarShipPtr->RaceDescPtr);
 			/* Record crew left after battle */
 			StarShipPtr->crew_level =
 					StarShipPtr->RaceDescPtr->ship_info.crew_level;
@@ -346,7 +343,7 @@ UninitShips (void)
 		for (i = 0; i < NUM_PLAYERS; i++)
 			ReinitQueue (&race_q[i]);
 
-		if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+		if (inHQSpace ())
 			FreeHyperspace ();
 	}
 }
diff -ruNp src.orig/uqm/init.h src/uqm/init.h
--- src.orig/uqm/init.h	2017-11-21 19:39:38 -0600
+++ src/uqm/init.h	2017-11-21 19:39:55 -0600
@@ -20,6 +20,10 @@
 #include "libs/gfxlib.h"
 #include "libs/reslib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #define NUM_PLAYERS 2
 #define NUM_SIDES 2
 
@@ -35,5 +39,9 @@ extern BOOLEAN load_animation (FRAME *pi
 		RESOURCE med_res, RESOURCE sml_res);
 extern BOOLEAN free_image (FRAME *pixarray);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _INIT_H */
 
diff -ruNp src.orig/uqm/intel.h src/uqm/intel.h
--- src.orig/uqm/intel.h	2017-11-21 19:39:38 -0600
+++ src/uqm/intel.h	2017-11-21 19:39:55 -0600
@@ -24,6 +24,10 @@
 #include "element.h"
 #include "races.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #define MANEUVERABILITY(pi) ((pi)->ManeuverabilityIndex)
 #define WEAPON_RANGE(pi) ((pi)->WeaponRange)
 
@@ -74,6 +78,10 @@ extern BOOLEAN ThrustShip (ELEMENT *Ship
 #define AWESOME_RATING (BYTE)(1 << 6)
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _INTEL_H */
 
 
diff -ruNp src.orig/uqm/intro.c src/uqm/intro.c
--- src.orig/uqm/intro.c	2017-11-21 19:39:38 -0600
+++ src/uqm/intro.c	2017-11-21 19:39:55 -0600
@@ -160,7 +160,6 @@ Present_BatchGraphics (PRESENTATION_INPU
 	if (!pPIS->Batched)
 	{
 		pPIS->Batched = TRUE;
-		LockMutex (GraphicsLock);
 		BatchGraphics ();
 	}
 }
@@ -171,7 +170,6 @@ Present_UnbatchGraphics (PRESENTATION_IN
 	if (pPIS->Batched)
 	{
 		UnbatchGraphics ();
-		UnlockMutex (GraphicsLock);
 		pPIS->Batched = FALSE;
 		if (bYield)
 			TaskSwitch ();
@@ -196,7 +194,6 @@ Present_GenerateSIS (PRESENTATION_INPUT_
 	COUNT piece;
 	Color SisBack;
 
-	LockMutex (GraphicsLock);
 	OldContext = SetContext (OffScreenContext);
 
 	SkelFrame = CaptureDrawable (LoadGraphic (SISSKEL_MASK_PMAP_ANIM));
@@ -264,7 +261,6 @@ Present_GenerateSIS (PRESENTATION_INPUT_
 
 	SetContext (OldContext);
 	FlushGraphics ();
-	UnlockMutex (GraphicsLock);
 
 	pPIS->SisFrame = SisFrame;
 }
@@ -277,9 +273,7 @@ Present_DrawMovieFrame (PRESENTATION_INP
 	s.origin.x = 0;
 	s.origin.y = 0;
 	s.frame = SetAbsFrameIndex (pPIS->Frame, pPIS->MovieFrame);
-	LockMutex (GraphicsLock);
 	DrawStamp (&s);
-	UnlockMutex (GraphicsLock);
 }
 
 static BOOLEAN
@@ -362,9 +356,7 @@ DoPresentation (void *pIS)
 				/* center on screen */
 				pPIS->clip_r.corner.x = (SCREEN_WIDTH - w) / 2;
 				pPIS->clip_r.corner.y = (SCREEN_HEIGHT - h) / 2;
-				LockMutex (GraphicsLock);
 				SetContextClipRect (&pPIS->clip_r);
-				UnlockMutex (GraphicsLock);
 			}
 		}
 		else if (strcmp (Opcode, "FONT") == 0)
@@ -390,11 +382,7 @@ DoPresentation (void *pIS)
 				*pFont = LoadFontFile (pPIS->Buffer);
 			}
 
-			if (!pPIS->Batched)
-				LockMutex (GraphicsLock);
 			SetContextFont (*pFont);
-			if (!pPIS->Batched)
-				UnlockMutex (GraphicsLock);
 		}
 		else if (strcmp (Opcode, "ANI") == 0)
 		{	/* set ani */
@@ -490,12 +478,8 @@ DoPresentation (void *pIS)
 				t.CharCount = (COUNT)~0;
 				t.baseline.x = x;
 				t.baseline.y = y;
-				if (!pPIS->Batched)
-					LockMutex (GraphicsLock);
 				DrawTextEffect (&t, pPIS->TextColor, pPIS->TextBackColor,
 						pPIS->TextEffect);
-				if (!pPIS->Batched)
-					UnlockMutex (GraphicsLock);
 			}
 		}
 		else if (strcmp (Opcode, "TFI") == 0)
@@ -510,9 +494,7 @@ DoPresentation (void *pIS)
 			
 			Present_UnbatchGraphics (pPIS, TRUE);
 
-			LockMutex (GraphicsLock);
 			GetContextFontLeading (&leading);
-			UnlockMutex (GraphicsLock);
 
 			switch (pPIS->TextVPos)
 			{
@@ -536,7 +518,6 @@ DoPresentation (void *pIS)
 				pPIS->TextLines[i].baseline.y = y;
 			}
 
-			LockMutex (GraphicsLock);
 			for (i = 0; i < pPIS->LinesCount; ++i)
 				DrawTextEffect (pPIS->TextLines + i, pPIS->TextFadeColor,
 						pPIS->TextFadeColor, pPIS->TextEffect);
@@ -550,7 +531,6 @@ DoPresentation (void *pIS)
 			ScreenTransition (3, &pPIS->tfade_r);
 			UnbatchGraphics ();
 			
-			UnlockMutex (GraphicsLock);
 		}
 		else if (strcmp (Opcode, "TFO") == 0)
 		{	/* text fade-out */
@@ -558,7 +538,6 @@ DoPresentation (void *pIS)
 			
 			Present_UnbatchGraphics (pPIS, TRUE);
 
-			LockMutex (GraphicsLock);
 			/* do transition */
 			SetTransitionSource (&pPIS->tfade_r);
 			BatchGraphics ();
@@ -567,7 +546,6 @@ DoPresentation (void *pIS)
 						pPIS->TextFadeColor, pPIS->TextEffect);
 			ScreenTransition (3, &pPIS->tfade_r);
 			UnbatchGraphics ();
-			UnlockMutex (GraphicsLock);
 		}
 		else if (strcmp (Opcode, "SAVEBG") == 0)
 		{	/* save background */
@@ -652,15 +630,11 @@ DoPresentation (void *pIS)
 			}
 			s.origin.x = x;
 			s.origin.y = y;
-			if (!pPIS->Batched)
-				LockMutex (GraphicsLock);
 			old_mode = SetGraphicScaleMode (scale_mode);
 			old_scale = SetGraphicScale (scale);
 			DrawStamp (&s);
 			SetGraphicScale (old_scale);
 			SetGraphicScaleMode (old_mode);
-			if (!pPIS->Batched)
-				UnlockMutex (GraphicsLock);
 		}
 		else if (strcmp (Opcode, "BATCH") == 0)
 		{	/* batch graphics */
@@ -689,9 +663,7 @@ DoPresentation (void *pIS)
 		{	/* clear screen */
 			Present_UnbatchGraphics (pPIS, TRUE);
 
-			LockMutex (GraphicsLock);
 			ClearDrawable ();	
-			UnlockMutex (GraphicsLock);
 		}
 		else if (strcmp (Opcode, "CALL") == 0)
 		{	/* call another script */
@@ -712,12 +684,8 @@ DoPresentation (void *pIS)
 				l.second.x = x2;
 				l.second.y = y2;
 				
-				if (!pPIS->Batched)
-					LockMutex (GraphicsLock);
 				SetContextForeGroundColor (pPIS->TextColor);
 				DrawLine (&l);
-				if (!pPIS->Batched)
-					UnlockMutex (GraphicsLock);
 			}
 			else
 			{
@@ -771,12 +739,10 @@ ShowSlidePresentation (STRING PresStr)
 	pis.SlideShow = SetAbsStringTableIndex (pis.SlideShow, 0);
 	pis.OperIndex = 0;
 
-	LockMutex (GraphicsLock);
 	OldContext = SetContext (ScreenContext);
 	GetContextClipRect (&OldRect);
 	OldFont = SetContextFont (NULL);
 	SetContextBackGroundColor (BLACK_COLOR);
-	UnlockMutex (GraphicsLock);
 
 	SetMenuSounds (MENU_SOUND_NONE, MENU_SOUND_NONE);
 	pis.InputFunc = DoPresentation;
@@ -797,11 +763,9 @@ ShowSlidePresentation (STRING PresStr)
 	for (i = 0; i < MAX_FONTS; ++i)
 		DestroyFont (pis.Fonts[i]);
 
-	LockMutex (GraphicsLock);
 	SetContextFont (OldFont);
 	SetContextClipRect (&OldRect);
 	SetContext (OldContext);
-	UnlockMutex (GraphicsLock);
 
 	return TRUE;
 }
@@ -853,11 +817,9 @@ FadeClearScreen (void)
 	SleepThreadUntil (FadeScreen (FadeAllToBlack, ONE_SECOND / 2));
 	
 	// clear the screen with black
-	LockMutex (GraphicsLock);
 	SetContext (ScreenContext);
 	SetContextBackGroundColor (BLACK_COLOR);
 	ClearDrawable ();
-	UnlockMutex (GraphicsLock);
 
 	FadeScreen (FadeAllToColor, 0);
 }
diff -ruNp src.orig/uqm/ipdisp.h src/uqm/ipdisp.h
--- src.orig/uqm/ipdisp.h	2017-11-21 19:39:38 -0600
+++ src/uqm/ipdisp.h	2017-11-21 19:39:55 -0600
@@ -19,6 +19,10 @@
 
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern void NotifyOthers (COUNT which_race, BYTE target_loc);
 // Special target locations for NotifyOthers()
 #define IPNL_INTERCEPT_PLAYER   0
@@ -26,4 +30,8 @@ extern void NotifyOthers (COUNT which_ra
 
 extern void DoMissions (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* UQM_IPDISP_H_INCL_ */
diff -ruNp src.orig/uqm/iscriptres.h src/uqm/iscriptres.h
--- src.orig/uqm/iscriptres.h	1969-12-31 18:00:00 -0600
+++ src/uqm/iscriptres.h	2017-11-21 19:39:55 -0600
@@ -0,0 +1,6 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
+#define EVENT_SCRIPT "event.script"
+#define SCRIPT_DIR_INITGAME "script.dir.initgame"
diff -ruNp src.orig/uqm/load.c src/uqm/load.c
--- src.orig/uqm/load.c	2017-11-21 19:39:38 -0600
+++ src/uqm/load.c	2017-11-21 19:39:55 -0600
@@ -18,18 +18,17 @@
 
 #include <assert.h>
 
-#include "load.h"
-
 #include "build.h"
-#include "libs/declib.h"
 #include "encount.h"
+#include "gameev.h"
+#include "starmap.h"
 #include "libs/file.h"
 #include "globdata.h"
-#include "load.h"
 #include "options.h"
+#include "save.h"
 #include "setup.h"
 #include "state.h"
-#include "grpinfo.h"
+#include "grpintrn.h"
 
 #include "libs/tasklib.h"
 #include "libs/log.h"
@@ -39,119 +38,63 @@
 
 ACTIVITY NextActivity;
 
-// XXX: these should handle endian conversions later
-static inline COUNT
-cread_8 (DECODE_REF fh, BYTE *v)
+static inline size_t
+read_8 (void *fp, BYTE *v)
 {
 	BYTE t;
 	if (!v) /* read value ignored */
 		v = &t;
-	return cread (v, 1, 1, fh);
-}
-
-static inline COUNT
-cread_16 (DECODE_REF fh, UWORD *v)
-{
-	UWORD t;
-	if (!v) /* read value ignored */
-		v = &t;
-	return cread (v, 2, 1, fh);
-}
-
-static inline COUNT
-cread_16s (DECODE_REF fh, SWORD *v)
-{
-	UWORD t;
-	COUNT ret;
-	// value was converted to unsigned when saved
-	ret = cread_16 (fh, &t);
-	// unsigned to signed conversion
-	if (v)
-		*v = t;
-	return ret;
+	return ReadResFile (v, 1, 1, fp);
 }
 
-static inline COUNT
-cread_32 (DECODE_REF fh, DWORD *v)
+static inline size_t
+read_16 (void *fp, UWORD *v)
 {
-	DWORD t;
-	if (!v) /* read value ignored */
-		v = &t;
-	return cread (v, 4, 1, fh);
-}
+	UWORD t = 0;
+	int shift, i;
+	for (i = 0, shift = 0; i < 2; ++i, shift += 8)
+	{
+		BYTE b;
+		if (read_8 (fp, &b) != 1)
+			return 0;
+		t |= ((UWORD)b) << shift;
+	}
 
-static inline COUNT
-cread_32s (DECODE_REF fh, SDWORD *v)
-{
-	DWORD t;
-	COUNT ret;
-	// value was converted to unsigned when saved
-	ret = cread_32 (fh, &t);
-	// unsigned to signed conversion
 	if (v)
 		*v = t;
-	return ret;
-}
-
-static inline COUNT
-cread_ptr (DECODE_REF fh)
-{
-	DWORD t;
-	return cread_32 (fh, &t); /* ptrs are useless in saves */
-}
-
-static inline COUNT
-cread_a8 (DECODE_REF fh, BYTE *ar, COUNT count)
-{
-	assert (ar != NULL);
-	return cread (ar, 1, count, fh) == count;
-}
 
-static inline size_t
-read_8 (void *fp, BYTE *v)
-{
-	BYTE t;
-	if (!v) /* read value ignored */
-		v = &t;
-	return ReadResFile (v, 1, 1, fp);
+	return 1;
 }
 
 static inline size_t
-read_16 (void *fp, UWORD *v)
+read_16s (void *fp, SWORD *v)
 {
-	UWORD t;
-	if (!v) /* read value ignored */
-		v = &t;
-	return ReadResFile (v, 2, 1, fp);
+	return read_16 (fp, v);
 }
 
 static inline size_t
 read_32 (void *fp, DWORD *v)
 {
-	DWORD t;
-	if (!v) /* read value ignored */
-		v = &t;
-	return ReadResFile (v, 4, 1, fp);
-}
+	DWORD t = 0;
+	int shift, i;
+	for (i = 0, shift = 0; i < 4; ++i, shift += 8)
+	{
+		BYTE b;
+		if (read_8 (fp, &b) != 1)
+			return 0;
+		t |= ((DWORD)b) << shift;
+	}
 
-static inline size_t
-read_32s (void *fp, SDWORD *v)
-{
-	DWORD t;
-	COUNT ret;
-	// value was converted to unsigned when saved
-	ret = read_32 (fp, &t);
-	// unsigned to signed conversion
 	if (v)
 		*v = t;
-	return ret;
+
+	return 1;
 }
 
 static inline size_t
-read_ptr (void *fp)
+read_32s (void *fp, SDWORD *v)
 {
-	DWORD t;
-	return read_32 (fp, &t); /* ptrs are useless in saves */
+	return read_32 (fp, v);
 }
 
 static inline size_t
@@ -162,6 +105,18 @@ read_a8 (void *fp, BYTE *ar, COUNT count
 }
 
 static inline size_t
+skip_8 (void *fp, COUNT count)
+{
+	int i;
+	for (i = 0; i < count; ++i)
+	{
+		if (read_8(fp, NULL) != 1)
+			return 0;
+	}
+	return 1;
+}
+
+static inline size_t
 read_str (void *fp, char *str, COUNT count)
 {
 	// no type conversion needed for strings
@@ -182,298 +137,246 @@ read_a16 (void *fp, UWORD *ar, COUNT cou
 }
 
 static void
-LoadEmptyQueue (DECODE_REF fh)
-{
-	COUNT num_links;
-
-	cread_16 (fh, &num_links);
-	if (num_links)
-	{
-		log_add (log_Error, "LoadEmptyQueue(): BUG: the queue is not empty!");
-#ifdef DEBUG
-		explode ();
-#endif
-	}
-}
-
-static void
-LoadShipQueue (DECODE_REF fh, QUEUE *pQueue)
+LoadShipQueue (void *fh, QUEUE *pQueue, DWORD size)
 {
-	COUNT num_links;
-
-	cread_16 (fh, &num_links);
+	COUNT num_links = size / 11;
 
 	while (num_links--)
 	{
 		HSHIPFRAG hStarShip;
 		SHIP_FRAGMENT *FragPtr;
 		COUNT Index;
-		BYTE tmpb;
 
-		cread_16 (fh, &Index);
+		read_16 (fh, &Index);
 
 		hStarShip = CloneShipFragment (Index, pQueue, 0);
 		FragPtr = LockShipFrag (pQueue, hStarShip);
 
 		// Read SHIP_FRAGMENT elements
-		cread_16 (fh, NULL); /* unused: was which_side */
-		cread_8  (fh, &FragPtr->captains_name_index);
-		cread_8  (fh, NULL); /* padding */
-		cread_16 (fh, NULL); /* unused: was ship_flags */
-		cread_8  (fh, &FragPtr->race_id);
-		cread_8  (fh, &FragPtr->index);
-		// XXX: reading crew as BYTE to maintain savegame compatibility
-		cread_8  (fh, &tmpb);
-		FragPtr->crew_level = tmpb;
-		cread_8  (fh, &tmpb);
-		FragPtr->max_crew = tmpb;
-		cread_8  (fh, &FragPtr->energy_level);
-		cread_8  (fh, &FragPtr->max_energy);
-		cread_16 (fh, NULL); /* unused; was loc.x */
-		cread_16 (fh, NULL); /* unused; was loc.y */
+		read_8  (fh, &FragPtr->captains_name_index);
+		read_8  (fh, &FragPtr->race_id);
+		read_8  (fh, &FragPtr->index);
+		read_16 (fh, &FragPtr->crew_level);
+		read_16 (fh, &FragPtr->max_crew);
+		read_8  (fh, &FragPtr->energy_level);
+		read_8  (fh, &FragPtr->max_energy);
 
 		UnlockShipFrag (pQueue, hStarShip);
 	}
 }
 
 static void
-LoadRaceQueue (DECODE_REF fh, QUEUE *pQueue)
+LoadRaceQueue (void *fh, QUEUE *pQueue, DWORD size)
 {
-	COUNT num_links;
-
-	cread_16 (fh, &num_links);
+	COUNT num_links = size / 30;
 
 	while (num_links--)
 	{
 		HFLEETINFO hStarShip;
 		FLEET_INFO *FleetPtr;
 		COUNT Index;
-		BYTE tmpb;
 
-		cread_16 (fh, &Index);
+		read_16 (fh, &Index);
 
 		hStarShip = GetStarShipFromIndex (pQueue, Index);
 		FleetPtr = LockFleetInfo (pQueue, hStarShip);
 
 		// Read FLEET_INFO elements
-		cread_16 (fh, &FleetPtr->allied_state);
-		cread_8  (fh, &FleetPtr->days_left);
-		cread_8  (fh, &FleetPtr->growth_fract);
-		cread_8  (fh, &tmpb);
-		FleetPtr->crew_level = tmpb;
-		cread_8  (fh, &tmpb);
-		FleetPtr->max_crew = tmpb;
-		cread_8  (fh, &FleetPtr->growth);
-		cread_8  (fh, &FleetPtr->max_energy);
-		cread_16s(fh, &FleetPtr->loc.x);
-		cread_16s(fh, &FleetPtr->loc.y);
-
-		cread_16 (fh, &FleetPtr->actual_strength);
-		cread_16 (fh, &FleetPtr->known_strength);
-		cread_16s(fh, &FleetPtr->known_loc.x);
-		cread_16s(fh, &FleetPtr->known_loc.y);
-		cread_8  (fh, &FleetPtr->growth_err_term);
-		cread_8  (fh, &FleetPtr->func_index);
-		cread_16s(fh, &FleetPtr->dest_loc.x);
-		cread_16s(fh, &FleetPtr->dest_loc.y);
-		cread_16 (fh, NULL); /* alignment padding */
+		read_16 (fh, &FleetPtr->allied_state);
+		read_8  (fh, &FleetPtr->days_left);
+		read_8  (fh, &FleetPtr->growth_fract);
+		read_16 (fh, &FleetPtr->crew_level);
+		read_16 (fh, &FleetPtr->max_crew);
+		read_8  (fh, &FleetPtr->growth);
+		read_8  (fh, &FleetPtr->max_energy);
+		read_16s(fh, &FleetPtr->loc.x);
+		read_16s(fh, &FleetPtr->loc.y);
+
+		read_16 (fh, &FleetPtr->actual_strength);
+		read_16 (fh, &FleetPtr->known_strength);
+		read_16s(fh, &FleetPtr->known_loc.x);
+		read_16s(fh, &FleetPtr->known_loc.y);
+		read_8  (fh, &FleetPtr->growth_err_term);
+		read_8  (fh, &FleetPtr->func_index);
+		read_16s(fh, &FleetPtr->dest_loc.x);
+		read_16s(fh, &FleetPtr->dest_loc.y);
 
 		UnlockFleetInfo (pQueue, hStarShip);
 	}
 }
 
 static void
-LoadGroupQueue (DECODE_REF fh, QUEUE *pQueue)
+LoadGroupQueue (void *fh, QUEUE *pQueue, DWORD size)
 {
-	COUNT num_links;
-
-	cread_16 (fh, &num_links);
+	COUNT num_links = size / 13;
 
 	while (num_links--)
 	{
 		HIPGROUP hGroup;
 		IP_GROUP *GroupPtr;
-		BYTE tmpb;
-
-		cread_16 (fh, NULL); /* unused; was race_id */
 
 		hGroup = BuildGroup (pQueue, 0);
 		GroupPtr = LockIpGroup (pQueue, hGroup);
 
-		cread_16 (fh, NULL); /* unused; was which_side */
-		cread_8  (fh, NULL); /* unused; was captains_name_index */
-		cread_8  (fh, NULL); /* padding; for savegame compat */
-		cread_16 (fh, &GroupPtr->group_counter);
-		cread_8  (fh, &GroupPtr->race_id);
-		cread_8  (fh, &tmpb); /* was var2 */
-		GroupPtr->sys_loc = LONIBBLE (tmpb);
-		GroupPtr->task = HINIBBLE (tmpb);
-		cread_8  (fh, &GroupPtr->in_system); /* was crew_level */
-		cread_8  (fh, NULL); /* unused; was max_crew */
-		cread_8  (fh, &tmpb); /* was energy_level */
-		GroupPtr->dest_loc = LONIBBLE (tmpb);
-		GroupPtr->orbit_pos = HINIBBLE (tmpb);
-		cread_8  (fh, &GroupPtr->group_id); /* was max_energy */
-		cread_16s(fh, &GroupPtr->loc.x);
-		cread_16s(fh, &GroupPtr->loc.y);
+		read_16 (fh, &GroupPtr->group_counter);
+		read_8  (fh, &GroupPtr->race_id);
+		read_8  (fh, &GroupPtr->sys_loc);
+		read_8  (fh, &GroupPtr->task);
+		read_8  (fh, &GroupPtr->in_system); /* was crew_level */
+		read_8  (fh, &GroupPtr->dest_loc);
+		read_8  (fh, &GroupPtr->orbit_pos);
+		read_8  (fh, &GroupPtr->group_id); /* was max_energy */
+		read_16s(fh, &GroupPtr->loc.x);
+		read_16s(fh, &GroupPtr->loc.y);
 
 		UnlockIpGroup (pQueue, hGroup);
 	}
 }
 
 static void
-LoadEncounter (ENCOUNTER *EncounterPtr, DECODE_REF fh)
+LoadEncounter (ENCOUNTER *EncounterPtr, void *fh)
 {
 	COUNT i;
 
-	cread_ptr (fh); /* useless ptr; HENCOUNTER pred */
 	EncounterPtr->pred = 0;
-	cread_ptr (fh); /* useless ptr; HENCOUNTER succ */
 	EncounterPtr->succ = 0;
-	cread_ptr (fh); /* useless ptr; HELEMENT hElement */
 	EncounterPtr->hElement = 0;
-	cread_16s (fh, &EncounterPtr->transition_state);
-	cread_16s (fh, &EncounterPtr->origin.x);
-	cread_16s (fh, &EncounterPtr->origin.y);
-	cread_16  (fh, &EncounterPtr->radius);
-	// STAR_DESC fields
-	cread_16s (fh, &EncounterPtr->SD.star_pt.x);
-	cread_16s (fh, &EncounterPtr->SD.star_pt.y);
-	cread_8   (fh, &EncounterPtr->SD.Type);
-	cread_8   (fh, &EncounterPtr->SD.Index);
-	cread_16  (fh, NULL); /* alignment padding */
+	read_16s (fh, &EncounterPtr->transition_state);
+	read_16s (fh, &EncounterPtr->origin.x);
+	read_16s (fh, &EncounterPtr->origin.y);
+	read_16  (fh, &EncounterPtr->radius);
+	// former STAR_DESC fields
+	read_16s (fh, &EncounterPtr->loc_pt.x);
+	read_16s (fh, &EncounterPtr->loc_pt.y);
+	read_8   (fh, &EncounterPtr->race_id);
+	read_8   (fh, &EncounterPtr->num_ships);
+	read_8   (fh, &EncounterPtr->flags);
 
 	// Load each entry in the BRIEF_SHIP_INFO array
 	for (i = 0; i < MAX_HYPER_SHIPS; i++)
 	{
 		BRIEF_SHIP_INFO *ShipInfo = &EncounterPtr->ShipList[i];
-		BYTE tmpb;
 
-		cread_16  (fh, NULL); /* useless; was SHIP_INFO.ship_flags */
-		cread_8   (fh, &ShipInfo->race_id);
-		cread_8   (fh, NULL); /* useless; was SHIP_INFO.var2 */
-		// XXX: reading crew as BYTE to maintain savegame compatibility
-		cread_8   (fh, &tmpb);
-		ShipInfo->crew_level = tmpb;
-		cread_8   (fh, &tmpb);
-		ShipInfo->max_crew = tmpb;
-		cread_8   (fh, NULL); /* useless; was SHIP_INFO.energy_level */
-		cread_8   (fh, &ShipInfo->max_energy);
-		cread_16  (fh, NULL); /* useless; was SHIP_INFO.loc.x */
-		cread_16  (fh, NULL); /* useless; was SHIP_INFO.loc.y */
-		cread_32  (fh, NULL); /* useless val; STRING race_strings */
-		cread_ptr (fh); /* useless ptr; FRAME icons */
-		cread_ptr (fh); /* useless ptr; FRAME melee_icon */
+		read_8   (fh, &ShipInfo->race_id);
+		read_16  (fh, &ShipInfo->crew_level);
+		read_16  (fh, &ShipInfo->max_crew);
+		read_8   (fh, &ShipInfo->max_energy);
 	}
-	
+
 	// Load the stuff after the BRIEF_SHIP_INFO array
-	cread_32s (fh, &EncounterPtr->log_x);
-	cread_32s (fh, &EncounterPtr->log_y);
+	read_32s (fh, &EncounterPtr->log_x);
+	read_32s (fh, &EncounterPtr->log_y);
 }
 
 static void
-LoadEvent (EVENT *EventPtr, DECODE_REF fh)
+LoadEvent (EVENT *EventPtr, void *fh)
 {
-	cread_ptr (fh); /* useless ptr; HEVENT pred */
 	EventPtr->pred = 0;
-	cread_ptr (fh); /* useless ptr; HEVENT succ */
 	EventPtr->succ = 0;
-	cread_8   (fh, &EventPtr->day_index);
-	cread_8   (fh, &EventPtr->month_index);
-	cread_16  (fh, &EventPtr->year_index);
-	cread_8   (fh, &EventPtr->func_index);
-	cread_8   (fh, NULL); /* padding */
-	cread_16  (fh, NULL); /* padding */
-}
-
-static void
-DummyLoadQueue (QUEUE *QueuePtr, DECODE_REF fh)
-{
-	/* QUEUE should never actually be loaded since it contains
-	 * purely internal representation and the lists
-	 * involved are actually loaded separately */
-	(void)QueuePtr; /* silence compiler */
-
-	/* QUEUE format with QUEUE_TABLE defined -- UQM default */
-	cread_ptr (fh); /* HLINK head */
-	cread_ptr (fh); /* HLINK tail */
-	cread_ptr (fh); /* BYTE* pq_tab */
-	cread_ptr (fh); /* HLINK free_list */
-	cread_16  (fh, NULL); /* MEM_HANDLE hq_tab */
-	cread_16  (fh, NULL); /* COUNT object_size */
-	cread_8   (fh, NULL); /* BYTE num_objects */
-	
-	cread_8   (fh, NULL); /* padding */
-	cread_16  (fh, NULL); /* padding */
+	read_8   (fh, &EventPtr->day_index);
+	read_8   (fh, &EventPtr->month_index);
+	read_16  (fh, &EventPtr->year_index);
+	read_8   (fh, &EventPtr->func_index);
 }
 
 static void
-LoadClockState (CLOCK_STATE *ClockPtr, DECODE_REF fh)
+LoadClockState (CLOCK_STATE *ClockPtr, void *fh)
 {
-	cread_8   (fh, &ClockPtr->day_index);
-	cread_8   (fh, &ClockPtr->month_index);
-	cread_16  (fh, &ClockPtr->year_index);
-	cread_16s (fh, &ClockPtr->tick_count);
-	cread_16s (fh, &ClockPtr->day_in_ticks);
-	cread_ptr (fh); /* not loading ptr; Semaphore clock_sem */
-	cread_ptr (fh); /* not loading ptr; Task clock_task */
-	cread_32  (fh, NULL); /* not loading; DWORD TimeCounter */
-
-	DummyLoadQueue (&ClockPtr->event_q, fh);
+	read_8   (fh, &ClockPtr->day_index);
+	read_8   (fh, &ClockPtr->month_index);
+	read_16  (fh, &ClockPtr->year_index);
+	read_16s (fh, &ClockPtr->tick_count);
+	read_16s (fh, &ClockPtr->day_in_ticks);
 }
 
-static void
-LoadGameState (GAME_STATE *GSPtr, DECODE_REF fh)
+static BOOLEAN
+LoadGameState (GAME_STATE *GSPtr, void *fh)
 {
-	BYTE dummy8;
+	DWORD magic;
+	read_32 (fh, &magic);
+	if (magic != GLOBAL_STATE_TAG)
+	{
+		return FALSE;
+	}
+	read_32 (fh, &magic);
+	if (magic != 75)
+	{
+		/* Chunk is the wrong size. */
+		return FALSE;
+	}
+	read_8   (fh, &GSPtr->glob_flags);
+	read_8   (fh, &GSPtr->CrewCost);
+	read_8   (fh, &GSPtr->FuelCost);
+	read_a8  (fh, GSPtr->ModuleCost, NUM_MODULES);
+	read_a8  (fh, GSPtr->ElementWorth, NUM_ELEMENT_CATEGORIES);
+	read_16  (fh, &GSPtr->CurrentActivity);
 
-	cread_8   (fh, &dummy8); /* obsolete */
-	cread_8   (fh, &GSPtr->glob_flags);
-	cread_8   (fh, &GSPtr->CrewCost);
-	cread_8   (fh, &GSPtr->FuelCost);
-	cread_a8  (fh, GSPtr->ModuleCost, NUM_MODULES);
-	cread_a8  (fh, GSPtr->ElementWorth, NUM_ELEMENT_CATEGORIES);
-	cread_ptr (fh); /* not loading ptr; PRIMITIVE *DisplayArray */
-	cread_16  (fh, &GSPtr->CurrentActivity);
-	
-	cread_16  (fh, NULL); /* CLOCK_STATE alignment padding */
 	LoadClockState (&GSPtr->GameClock, fh);
 
-	cread_16s (fh, &GSPtr->autopilot.x);
-	cread_16s (fh, &GSPtr->autopilot.y);
-	cread_16s (fh, &GSPtr->ip_location.x);
-	cread_16s (fh, &GSPtr->ip_location.y);
+	read_16s (fh, &GSPtr->autopilot.x);
+	read_16s (fh, &GSPtr->autopilot.y);
+	read_16s (fh, &GSPtr->ip_location.x);
+	read_16s (fh, &GSPtr->ip_location.y);
 	/* STAMP ShipStamp */
-	cread_16s (fh, &GSPtr->ShipStamp.origin.x);
-	cread_16s (fh, &GSPtr->ShipStamp.origin.y);
-	cread_16  (fh, &GSPtr->ShipFacing);
-	cread_8   (fh, &GSPtr->ip_planet);
-	cread_8   (fh, &GSPtr->in_orbit);
+	read_16s (fh, &GSPtr->ShipStamp.origin.x);
+	read_16s (fh, &GSPtr->ShipStamp.origin.y);
+	read_16  (fh, &GSPtr->ShipFacing);
+	read_8   (fh, &GSPtr->ip_planet);
+	read_8   (fh, &GSPtr->in_orbit);
 
 	/* VELOCITY_DESC velocity */
-	cread_16  (fh, &GSPtr->velocity.TravelAngle);
-	cread_16s (fh, &GSPtr->velocity.vector.width);
-	cread_16s (fh, &GSPtr->velocity.vector.height);
-	cread_16s (fh, &GSPtr->velocity.fract.width);
-	cread_16s (fh, &GSPtr->velocity.fract.height);
-	cread_16s (fh, &GSPtr->velocity.error.width);
-	cread_16s (fh, &GSPtr->velocity.error.height);
-	cread_16s (fh, &GSPtr->velocity.incr.width);
-	cread_16s (fh, &GSPtr->velocity.incr.height);
-	cread_16  (fh, NULL); /* VELOCITY_DESC padding */
+	read_16  (fh, &GSPtr->velocity.TravelAngle);
+	read_16s (fh, &GSPtr->velocity.vector.width);
+	read_16s (fh, &GSPtr->velocity.vector.height);
+	read_16s (fh, &GSPtr->velocity.fract.width);
+	read_16s (fh, &GSPtr->velocity.fract.height);
+	read_16s (fh, &GSPtr->velocity.error.width);
+	read_16s (fh, &GSPtr->velocity.error.height);
+	read_16s (fh, &GSPtr->velocity.incr.width);
+	read_16s (fh, &GSPtr->velocity.incr.height);
 
-	cread_32  (fh, &GSPtr->BattleGroupRef);
-	
-	DummyLoadQueue (&GSPtr->avail_race_q, fh);
-	DummyLoadQueue (&GSPtr->npc_built_ship_q, fh);
-	// Not loading ip_group_q, was not there originally
-	DummyLoadQueue (&GSPtr->encounter_q, fh);
-	DummyLoadQueue (&GSPtr->built_ship_q, fh);
+	read_32 (fh, &magic);
+	if (magic != GAME_STATE_TAG)
+	{
+		return FALSE;
+	}
+	{
+		size_t gameStateByteCount = (NUM_GAME_STATE_BITS + 7) >> 3;
+		BYTE *buf;
+		BOOLEAN result;
 
-	cread_a8  (fh, GSPtr->GameState, sizeof (GSPtr->GameState));
+		read_32 (fh, &magic);
+		if (magic < gameStateByteCount)
+		{
+			log_add (log_Error, "Warning: Savegame is corrupt: saved game "
+					"state is too small.");
+			return FALSE;
+		}
 
-	assert (sizeof (GSPtr->GameState) % 4 == 3);
-	cread_8  (fh, NULL); /* GAME_STATE alignment padding */
+		buf = HMalloc (gameStateByteCount);
+		if (buf == NULL)
+		{
+			log_add (log_Error, "Warning: Cannot allocate enough bytes for "
+					"the saved game state (%zu bytes).", gameStateByteCount);
+			return FALSE;
+		}
+
+		read_a8 (fh, buf, gameStateByteCount);
+		result = deserialiseGameState (gameStateBitMap, buf,
+				gameStateByteCount);
+		HFree(buf);
+		if (result == FALSE)
+		{
+			// An error message is already printed.
+			return FALSE;
+		}
+
+		if (magic > gameStateByteCount)
+		{
+			skip_8 (fh, magic - gameStateByteCount);
+		}
+	}
+	return TRUE;
 }
 
 static BOOLEAN
@@ -495,18 +398,32 @@ LoadSisState (SIS_STATE *SSPtr, void *fp
 
 			read_str (fp, SSPtr->ShipName, SIS_NAME_SIZE) != 1 ||
 			read_str (fp, SSPtr->CommanderName, SIS_NAME_SIZE) != 1 ||
-			read_str (fp, SSPtr->PlanetName, SIS_NAME_SIZE) != 1 ||
-
-			read_16  (fp, NULL) != 1 /* padding */
+			read_str (fp, SSPtr->PlanetName, SIS_NAME_SIZE) != 1
 		)
 		return FALSE;
-	else
-		return TRUE;
+	return TRUE;
 }
 
 static BOOLEAN
 LoadSummary (SUMMARY_DESC *SummPtr, void *fp)
 {
+	SDWORD magic;
+	DWORD nameSize = 0;
+	if (!read_32s (fp, &magic))
+		return FALSE;
+	if (magic == SAVEFILE_TAG)
+	{
+		if (read_32 (fp, &magic) != 1 || magic != SUMMARY_TAG)
+			return FALSE;
+		if (read_32 (fp, &magic) != 1 || magic < 160)
+			return FALSE;
+		nameSize = magic - 160;
+	}
+	else
+	{
+		return FALSE;
+	}
+
 	if (!LoadSisState (&SummPtr->SS, fp))
 		return FALSE;
 
@@ -521,24 +438,220 @@ LoadSummary (SUMMARY_DESC *SummPtr, void
 			read_8  (fp, &SummPtr->NumShips) != 1 ||
 			read_8  (fp, &SummPtr->NumDevices) != 1 ||
 			read_a8 (fp, SummPtr->ShipList, MAX_BUILT_SHIPS) != 1 ||
-			read_a8 (fp, SummPtr->DeviceList, MAX_EXCLUSIVE_DEVICES) != 1 ||
-
-			read_16  (fp, NULL) != 1 /* padding */
+			read_a8 (fp, SummPtr->DeviceList, MAX_EXCLUSIVE_DEVICES) != 1
 		)
 		return FALSE;
+	
+	if (nameSize < SAVE_NAME_SIZE)
+	{
+		if (read_a8 (fp, SummPtr->SaveName, nameSize) != 1)
+			return FALSE;
+		SummPtr->SaveName[nameSize] = 0;
+	}
 	else
-		return TRUE;
+	{
+		DWORD remaining = nameSize - SAVE_NAME_SIZE + 1;
+		if (read_a8 (fp, SummPtr->SaveName, SAVE_NAME_SIZE-1) != 1)
+			return FALSE;
+		SummPtr->SaveName[SAVE_NAME_SIZE-1] = 0;
+		if (skip_8 (fp, remaining) != 1)
+			return FALSE;
+	}
+	return TRUE;
 }
 
 static void
-LoadStarDesc (STAR_DESC *SDPtr, DECODE_REF fh)
+LoadStarDesc (STAR_DESC *SDPtr, void *fh)
 {
-	cread_16s(fh, &SDPtr->star_pt.x);
-	cread_16s(fh, &SDPtr->star_pt.y);
-	cread_8  (fh, &SDPtr->Type);
-	cread_8  (fh, &SDPtr->Index);
-	cread_8  (fh, &SDPtr->Prefix);
-	cread_8  (fh, &SDPtr->Postfix);
+	read_16s(fh, &SDPtr->star_pt.x);
+	read_16s(fh, &SDPtr->star_pt.y);
+	read_8  (fh, &SDPtr->Type);
+	read_8  (fh, &SDPtr->Index);
+	read_8  (fh, &SDPtr->Prefix);
+	read_8  (fh, &SDPtr->Postfix);
+}
+
+static void
+LoadScanInfo (uio_Stream *fh, DWORD flen)
+{
+	GAME_STATE_FILE *fp = OpenStateFile (STARINFO_FILE, "wb");
+	if (fp)
+	{
+		while (flen)
+		{
+			DWORD val;
+			read_32 (fh, &val);
+			swrite_32 (fp, val);
+			flen -= 4;
+		}
+		CloseStateFile (fp);
+	}
+}
+
+static void
+LoadGroupList (uio_Stream *fh, DWORD chunksize)
+{
+	GAME_STATE_FILE *fp = OpenStateFile (RANDGRPINFO_FILE, "rb");
+	if (fp)
+	{
+		GROUP_HEADER h;
+		BYTE LastEnc, NumGroups;
+		int i;
+		ReadGroupHeader (fp, &h);
+		/* There's only supposed to be one of these, so group 0 should be
+		 * zero here whenever we're here. We add the group list to the
+		 * end here. */
+		h.GroupOffset[0] = LengthStateFile (fp);
+		SeekStateFile (fp, 0, SEEK_SET);
+		WriteGroupHeader (fp, &h);
+		SeekStateFile (fp, h.GroupOffset[0], SEEK_SET);
+		read_8 (fh, &LastEnc);
+		NumGroups = (chunksize - 1) / 14;
+		swrite_8 (fp, LastEnc);
+		swrite_8 (fp, NumGroups);
+		for (i = 0; i < NumGroups; ++i)
+		{
+			BYTE race_outer;
+			IP_GROUP ip;
+			read_8  (fh, &race_outer);
+			read_16 (fh, &ip.group_counter);
+			read_8  (fh, &ip.race_id);
+			read_8  (fh, &ip.sys_loc);
+			read_8  (fh, &ip.task);
+			read_8  (fh, &ip.in_system);
+			read_8  (fh, &ip.dest_loc);
+			read_8  (fh, &ip.orbit_pos);
+			read_8  (fh, &ip.group_id);
+			read_16 (fh, &ip.loc.x);
+			read_16 (fh, &ip.loc.y);
+
+			swrite_8 (fp, race_outer);
+			WriteIpGroup (fp, &ip);
+		}
+		CloseStateFile (fp);
+	}
+}
+
+static void
+SetBattleGroupOffset (int encounterIndex, DWORD offset)
+{
+	// The reason for this switch, even though the group offsets are
+	// successive, is because SET_GAME_STATE is a #define, which stringizes
+	// its first argument.
+	switch (encounterIndex)
+	{
+		case  1: SET_GAME_STATE (SHOFIXTI_GRPOFFS,     offset); break;
+		case  2: SET_GAME_STATE (ZOQFOT_GRPOFFS,       offset); break;
+		case  3: SET_GAME_STATE (MELNORME0_GRPOFFS,    offset); break;
+		case  4: SET_GAME_STATE (MELNORME1_GRPOFFS,    offset); break;
+		case  5: SET_GAME_STATE (MELNORME2_GRPOFFS,    offset); break;
+		case  6: SET_GAME_STATE (MELNORME3_GRPOFFS,    offset); break;
+		case  7: SET_GAME_STATE (MELNORME4_GRPOFFS,    offset); break;
+		case  8: SET_GAME_STATE (MELNORME5_GRPOFFS,    offset); break;
+		case  9: SET_GAME_STATE (MELNORME6_GRPOFFS,    offset); break;
+		case 10: SET_GAME_STATE (MELNORME7_GRPOFFS,    offset); break;
+		case 11: SET_GAME_STATE (MELNORME8_GRPOFFS,    offset); break;
+		case 12: SET_GAME_STATE (URQUAN_PROBE_GRPOFFS, offset); break;
+		case 13: SET_GAME_STATE (COLONY_GRPOFFS,       offset); break;
+		case 14: SET_GAME_STATE (SAMATRA_GRPOFFS,      offset); break;
+		default:
+			log_add (log_Warning, "SetBattleGroupOffset: invalid encounter "
+					"index.\n");
+			break;
+	}
+}
+
+static void
+LoadBattleGroup (uio_Stream *fh, DWORD chunksize)
+{
+	GAME_STATE_FILE *fp;
+	GROUP_HEADER h;
+	DWORD encounter, offset;
+	BYTE current;
+	int i;
+
+	read_32 (fh, &encounter);
+	read_8 (fh, &current);
+	chunksize -= 5;
+	if (encounter)
+	{
+		/* This is a defined group, so it's new */
+		fp = OpenStateFile (DEFGRPINFO_FILE, "rb");
+		offset = LengthStateFile (fp);
+		memset (&h, 0, sizeof (GROUP_HEADER));
+	}
+	else
+	{
+		/* This is the random group. Load in what was there,
+		 * as we might have already seen the Group List. */
+		fp = OpenStateFile (RANDGRPINFO_FILE, "rb");
+		current = FALSE;
+		offset = 0;
+		ReadGroupHeader (fp, &h);
+	}
+	if (!fp)
+	{
+		skip_8 (fh, chunksize);
+		return;
+	}
+	read_16 (fh, &h.star_index);
+	read_8  (fh, &h.day_index);
+	read_8  (fh, &h.month_index);
+	read_16 (fh, &h.year_index);
+	read_8  (fh, &h.NumGroups);
+	chunksize -= 7;
+	/* Write out the half-finished state file so that we can use
+	 * the file size to compute group offsets */
+	SeekStateFile (fp, offset, SEEK_SET);
+	WriteGroupHeader (fp, &h);
+	for (i = 1; i <= h.NumGroups; ++i)
+	{
+		int j;
+		BYTE icon, NumShips;
+		read_8 (fh, &icon);
+		read_8 (fh, &NumShips);
+		chunksize -= 2;
+		h.GroupOffset[i] = LengthStateFile (fp);
+		SeekStateFile (fp, h.GroupOffset[i], SEEK_SET);
+		swrite_8 (fp, icon);
+		swrite_8 (fp, NumShips);
+		for (j = 0; j < NumShips; ++j)
+		{
+			BYTE race_outer;
+			SHIP_FRAGMENT sf;
+			read_8  (fh, &race_outer);
+			read_8  (fh, &sf.captains_name_index);
+			read_8  (fh, &sf.race_id);
+			read_8  (fh, &sf.index);
+			read_16 (fh, &sf.crew_level);
+			read_16 (fh, &sf.max_crew);
+			read_8  (fh, &sf.energy_level);
+			read_8  (fh, &sf.max_energy);
+			chunksize -= 10;
+
+			swrite_8 (fp, race_outer);
+			WriteShipFragment (fp, &sf);
+		}
+	}
+	/* Now that the GroupOffset array is properly initialized,
+	 * write the header back out. */
+	SeekStateFile (fp, offset, SEEK_SET);
+	WriteGroupHeader (fp, &h);
+	CloseStateFile (fp);
+	/* And update the gamestate accordingly, if we're a defined group. */
+	if (encounter)
+	{
+		SetBattleGroupOffset (encounter, offset);
+		if (current)
+		{
+			GLOBAL (BattleGroupRef) = offset;
+		}
+	}
+	/* Consistency check. */
+	if (chunksize)
+	{
+		log_add (log_Warning, "BattleGroup chunk mis-sized!");
+	}
 }
 
 BOOLEAN
@@ -546,24 +659,22 @@ LoadGame (COUNT which_game, SUMMARY_DESC
 {
 	uio_Stream *in_fp;
 	char file[PATH_MAX];
-	char buf[256];
 	SUMMARY_DESC loc_sd;
-	GAME_STATE_FILE *fp;
-	DECODE_REF fh;
 	COUNT num_links;
 	STAR_DESC SD;
 	ACTIVITY Activity;
+	DWORD chunk, chunkSize;
+	BOOLEAN first_group_spec = TRUE;
 
-	sprintf (file, "starcon2.%02u", which_game);
+	sprintf (file, "uqmsave.%02u", which_game);
 	in_fp = res_OpenResFile (saveDir, file, "rb");
 	if (!in_fp)
-		return FALSE;
+		return LoadLegacyGame (which_game, SummPtr);
 
 	if (!LoadSummary (&loc_sd, in_fp))
 	{
-		log_add (log_Error, "Warning: Savegame is corrupt");
 		res_CloseResFile (in_fp);
-		return FALSE;
+		return LoadLegacyGame (which_game, SummPtr);
 	}
 
 	if (!SummPtr)
@@ -577,172 +688,130 @@ LoadGame (COUNT which_game, SUMMARY_DESC
 		return TRUE;
 	}
 
-	// Crude check for big-endian/little-endian incompatibilities.
-	// year_index is suitable as it's a multi-byte value within
-	// a specific recognisable range.
-	if (SummPtr->year_index < START_YEAR ||
-			SummPtr->year_index >= START_YEAR +
-			YEARS_TO_KOHRAH_VICTORY + 1 /* Utwig intervention */ +
-			1 /* time to destroy all races, plenty */ +
-			25 /* for cheaters */)
-	{
-		log_add (log_Error, "Warning: Savegame corrupt or from "
-				"an incompatible platform.");
-		res_CloseResFile (in_fp);
-		return FALSE;
-	}
-
 	GlobData.SIS_state = SummPtr->SS;
 
-	if ((fh = copen (in_fp, FILE_STREAM, STREAM_READ)) == 0)
-	{
-		res_CloseResFile (in_fp);
-		return FALSE;
-	}
-
 	ReinitQueue (&GLOBAL (GameClock.event_q));
 	ReinitQueue (&GLOBAL (encounter_q));
 	ReinitQueue (&GLOBAL (ip_group_q));
 	ReinitQueue (&GLOBAL (npc_built_ship_q));
 	ReinitQueue (&GLOBAL (built_ship_q));
+	
+	uninitEventSystem ();
+	luaUqm_uninitState();
+	luaUqm_initState();
+	initEventSystem ();
 
-	memset (&GLOBAL (GameState[0]), 0, sizeof (GLOBAL (GameState)));
 	Activity = GLOBAL (CurrentActivity);
-	LoadGameState (&GlobData.Game_state, fh);
+	if (!LoadGameState (&GlobData.Game_state, in_fp))
+	{
+		res_CloseResFile (in_fp);
+		return FALSE;
+	}
 	NextActivity = GLOBAL (CurrentActivity);
 	GLOBAL (CurrentActivity) = Activity;
 
-	LoadRaceQueue (fh, &GLOBAL (avail_race_q));
-	// START_INTERPLANETARY is only set when saving from Homeworld
-	//   encounter screen. When the game is loaded, the
-	//   GenerateOrbitalFunction for the current star system will
-	//   create the encounter anew and populate the npc queue.
-	if (!(NextActivity & START_INTERPLANETARY))
-	{
-		if (NextActivity & START_ENCOUNTER)
-			LoadShipQueue (fh, &GLOBAL (npc_built_ship_q));
-		else if (LOBYTE (NextActivity) == IN_INTERPLANETARY)
-			// XXX: Technically, this queue does not need to be
-			//   saved/loaded at all. IP groups will be reloaded
-			//   from group state files. But the original code did,
-			//   and so will we until we can prove we do not need to.
-			LoadGroupQueue (fh, &GLOBAL (ip_group_q));
-		else
-			// XXX: The empty queue read is only needed to maintain
-			//   the savegame compatibility
-			LoadEmptyQueue (fh);
-	}
-	LoadShipQueue (fh, &GLOBAL (built_ship_q));
-
-	// Load the game events (compressed)
-	cread_16 (fh, &num_links);
+	chunk = 0;
+	while (TRUE)
 	{
-#ifdef DEBUG_LOAD
-		log_add (log_Debug, "EVENTS:");
-#endif /* DEBUG_LOAD */
-		while (num_links--)
+		if (read_32(in_fp, &chunk) != 1)
 		{
-			HEVENT hEvent;
-			EVENT *EventPtr;
-
-			hEvent = AllocEvent ();
-			LockEvent (hEvent, &EventPtr);
-
-			LoadEvent (EventPtr, fh);
-
-#ifdef DEBUG_LOAD
-		log_add (log_Debug, "\t%u/%u/%u -- %u",
-				EventPtr->month_index,
-				EventPtr->day_index,
-				EventPtr->year_index,
-				EventPtr->func_index);
-#endif /* DEBUG_LOAD */
-			UnlockEvent (hEvent);
-			PutEvent (hEvent);
+			break;
 		}
-	}
-
-	// Load the encounters (black globes in HS/QS (compressed))
-	cread_16 (fh, &num_links);
-	{
-		while (num_links--)
+		if (read_32(in_fp, &chunkSize) != 1)
 		{
-			HENCOUNTER hEncounter;
-			ENCOUNTER *EncounterPtr;
-
-			hEncounter = AllocEncounter ();
-			LockEncounter (hEncounter, &EncounterPtr);
-
-			LoadEncounter (EncounterPtr, fh);
-
-			UnlockEncounter (hEncounter);
-			PutEncounter (hEncounter);
+			res_CloseResFile (in_fp);
+			return FALSE;
 		}
-	}
-
-	// Copy the star info file from the compressed stream
-	fp = OpenStateFile (STARINFO_FILE, "wb");
-	if (fp)
-	{
-		DWORD flen;
-
-		cread_32 (fh, &flen);
-		while (flen)
+		switch (chunk)
 		{
-			COUNT num_bytes;
-
-			num_bytes = flen >= sizeof (buf) ? sizeof (buf) : (COUNT)flen;
-			cread (buf, num_bytes, 1, fh);
-			WriteStateFile (buf, num_bytes, 1, fp);
-
-			flen -= num_bytes;
-		}
-		CloseStateFile (fp);
-	}
-
-	// Copy the defined groupinfo file from the compressed stream
-	fp = OpenStateFile (DEFGRPINFO_FILE, "wb");
-	if (fp)
-	{
-		DWORD flen;
-
-		cread_32 (fh, &flen);
-		while (flen)
-		{
-			COUNT num_bytes;
-
-			num_bytes = flen >= sizeof (buf) ? sizeof (buf) : (COUNT)flen;
-			cread (buf, num_bytes, 1, fh);
-			WriteStateFile (buf, num_bytes, 1, fp);
-
-			flen -= num_bytes;
-		}
-		CloseStateFile (fp);
-	}
-
-	// Copy the random groupinfo file from the compressed stream
-	fp = OpenStateFile (RANDGRPINFO_FILE, "wb");
-	if (fp)
-	{
-		DWORD flen;
+		case RACE_Q_TAG:
+			LoadRaceQueue (in_fp, &GLOBAL (avail_race_q), chunkSize);
+			break;
+		case IP_GRP_Q_TAG:
+			LoadGroupQueue (in_fp, &GLOBAL (ip_group_q), chunkSize);
+			break;
+		case ENCOUNTERS_TAG:
+			num_links = chunkSize / 65;
+			while (num_links--)
+			{
+				HENCOUNTER hEncounter;
+				ENCOUNTER *EncounterPtr;
+
+				hEncounter = AllocEncounter ();
+				LockEncounter (hEncounter, &EncounterPtr);
+
+				LoadEncounter (EncounterPtr, in_fp);
+
+				UnlockEncounter (hEncounter);
+				PutEncounter (hEncounter);
+			}
+			break;
+		case EVENTS_TAG:
+			num_links = chunkSize / 5;
+#ifdef DEBUG_LOAD
+			log_add (log_Debug, "EVENTS:");
+#endif /* DEBUG_LOAD */
+			while (num_links--)
+			{
+				HEVENT hEvent;
+				EVENT *EventPtr;
 
-		cread_32 (fh, &flen);
-		while (flen)
-		{
-			COUNT num_bytes;
+				hEvent = AllocEvent ();
+				LockEvent (hEvent, &EventPtr);
 
-			num_bytes = flen >= sizeof (buf) ? sizeof (buf) : (COUNT)flen;
-			cread (buf, num_bytes, 1, fh);
-			WriteStateFile (buf, num_bytes, 1, fp);
+				LoadEvent (EventPtr, in_fp);
 
-			flen -= num_bytes;
+#ifdef DEBUG_LOAD
+				log_add (log_Debug, "\t%u/%u/%u -- %u",
+						 EventPtr->month_index,
+						 EventPtr->day_index,
+						 EventPtr->year_index,
+						 EventPtr->func_index);
+#endif /* DEBUG_LOAD */
+				UnlockEvent (hEvent);
+				PutEvent (hEvent);
+			}
+			break;
+		case STAR_TAG:
+			LoadStarDesc (&SD, in_fp);
+			break;
+		case NPC_SHIP_Q_TAG:
+			LoadShipQueue (in_fp, &GLOBAL (npc_built_ship_q), chunkSize);
+			break;
+		case SHIP_Q_TAG:
+			LoadShipQueue (in_fp, &GLOBAL (built_ship_q), chunkSize);
+			break;
+		case SCAN_TAG:
+			LoadScanInfo (in_fp, chunkSize);
+			break;
+		case GROUP_LIST_TAG:
+			if (first_group_spec)
+			{
+				InitGroupInfo (TRUE);
+				GLOBAL (BattleGroupRef) = 0;
+				first_group_spec = FALSE;
+			}
+			LoadGroupList (in_fp, chunkSize);
+			break;
+		case BATTLE_GROUP_TAG:
+			if (first_group_spec)
+			{
+				InitGroupInfo (TRUE);
+				GLOBAL (BattleGroupRef) = 0;
+				first_group_spec = FALSE;
+			}
+			LoadBattleGroup (in_fp, chunkSize);
+			break;
+		default:
+			log_add (log_Debug, "Skipping chunk of tag %08X (size %u)", chunk, chunkSize);
+			if (skip_8(in_fp, chunkSize) != 1)
+			{
+				res_CloseResFile (in_fp);
+				return FALSE;
+			}
+			break;
 		}
-		CloseStateFile (fp);
 	}
-
-	LoadStarDesc (&SD, fh);
-
-	cclose (fh);
 	res_CloseResFile (in_fp);
 
 	EncounterGroup = 0;
@@ -757,5 +826,3 @@ LoadGame (COUNT which_game, SUMMARY_DESC
 
 	return TRUE;
 }
-
-
diff -ruNp src.orig/uqm/load.h src/uqm/load.h
--- src.orig/uqm/load.h	2017-11-21 19:39:38 -0600
+++ src/uqm/load.h	1969-12-31 18:00:00 -0600
@@ -1,31 +0,0 @@
-/*
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _LOAD_H
-#define _LOAD_H
-
-#include "sis.h"
-		// for SUMMARY_DESC
-#include "libs/compiler.h"
-#include "globdata.h"
-
-extern ACTIVITY NextActivity;
-
-extern BOOLEAN LoadGame (COUNT which_game, SUMMARY_DESC *summary_desc);
-
-
-#endif  /* _LOAD_H */
-
diff -ruNp src.orig/uqm/load_legacy.c src/uqm/load_legacy.c
--- src.orig/uqm/load_legacy.c	1969-12-31 18:00:00 -0600
+++ src/uqm/load_legacy.c	2017-11-21 19:39:55 -0600
@@ -0,0 +1,1189 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <assert.h>
+
+#include "build.h"
+#include "libs/declib.h"
+#include "encount.h"
+#include "gameev.h"
+#include "starmap.h"
+#include "libs/file.h"
+#include "globdata.h"
+#include "options.h"
+#include "save.h"
+#include "setup.h"
+#include "state.h"
+#include "grpinfo.h"
+
+#include "libs/tasklib.h"
+#include "libs/log.h"
+#include "libs/misc.h"
+#include "libs/scriptlib.h"
+
+//#define DEBUG_LOAD
+
+
+// This defines the order and the number of bits in which the game state
+// properties are saved.
+static const GameStateBitMap legacyGameStateBitMap[] = {
+	{ "SHOFIXTI_VISITS", 3 },
+	{ "SHOFIXTI_STACK1", 2 },
+	{ "SHOFIXTI_STACK2", 3 },
+	{ "SHOFIXTI_STACK3", 2 },
+	{ "SHOFIXTI_KIA", 1 },
+	{ "SHOFIXTI_BRO_KIA", 1 },
+	{ "SHOFIXTI_RECRUITED", 1 },
+	{ "SHOFIXTI_MAIDENS", 1 },
+	{ "MAIDENS_ON_SHIP", 1 },
+	{ "BATTLE_SEGUE", 1 },
+	{ "PLANETARY_LANDING", 1 },
+	{ "PLANETARY_CHANGE", 1 },
+	{ "SPATHI_VISITS", 3 },
+	{ "SPATHI_HOME_VISITS", 3 },
+	{ "FOUND_PLUTO_SPATHI", 2 },
+	{ "SPATHI_SHIELDED_SELVES", 1 },
+	{ "SPATHI_CREATURES_EXAMINED", 1 },
+	{ "SPATHI_CREATURES_ELIMINATED", 1 },
+	{ "UMGAH_BROADCASTERS", 1 },
+	{ "SPATHI_MANNER", 2 },
+	{ "SPATHI_QUEST", 1 },
+	{ "LIED_ABOUT_CREATURES", 2 },
+	{ "SPATHI_PARTY", 1 },
+	{ "KNOW_SPATHI_PASSWORD", 1 },
+	{ "ILWRATH_HOME_VISITS", 3 },
+	{ "ILWRATH_CHMMR_VISITS", 1 },
+	{ "ARILOU_SPACE", 1 },
+	{ "ARILOU_SPACE_SIDE", 2 },
+	{ "ARILOU_SPACE_COUNTER", 4 },
+	{ "LANDER_SHIELDS", 4 },
+	{ "SHOFIXTI_GRPOFFS", 32 },
+	{ "ZOQFOT_GRPOFFS", 32 },
+	{ "MELNORME0_GRPOFFS", 32 },
+	{ "MELNORME1_GRPOFFS", 32 },
+	{ "MELNORME2_GRPOFFS", 32 },
+	{ "MELNORME3_GRPOFFS", 32 },
+	{ "MELNORME4_GRPOFFS", 32 },
+	{ "MELNORME5_GRPOFFS", 32 },
+	{ "MELNORME6_GRPOFFS", 32 },
+	{ "MELNORME7_GRPOFFS", 32 },
+	{ "MELNORME8_GRPOFFS", 32 },
+	{ "MET_MELNORME", 1 },
+	{ "MELNORME_RESCUE_REFUSED", 1 },
+	{ "MELNORME_RESCUE_COUNT", 3 },
+	{ "TRADED_WITH_MELNORME", 1 },
+	{ "WHY_MELNORME_PURPLE", 1 },
+	{ "MELNORME_CREDIT0", 8 },
+	{ "MELNORME_CREDIT1", 8 },
+	{ "MELNORME_BUSINESS_COUNT", 2 },
+	{ "MELNORME_YACK_STACK0", 2 },
+	{ "MELNORME_YACK_STACK1", 2 },
+	{ "MELNORME_YACK_STACK2", 4 },
+	{ "MELNORME_YACK_STACK3", 3 },
+	{ "MELNORME_YACK_STACK4", 2 },
+	{ "WHY_MELNORME_BLUE", 1 },
+	{ "MELNORME_ANGER", 2 },
+	{ "MELNORME_MIFFED_COUNT", 2 },
+	{ "MELNORME_PISSED_COUNT", 2 },
+	{ "MELNORME_HATE_COUNT", 2 },
+	{ "URQUAN_PROBE_GRPOFFS", 32 },
+	{ "PROBE_MESSAGE_DELIVERED", 1 },
+	{ "PROBE_ILWRATH_ENCOUNTER", 1 },
+	{ "STARBASE_AVAILABLE", 1 },
+	{ "STARBASE_VISITED", 1 },
+	{ "RADIOACTIVES_PROVIDED", 1 },
+	{ "LANDERS_LOST", 1 },
+	{ "GIVEN_FUEL_BEFORE", 1 },
+	{ "AWARE_OF_SAMATRA", 1 },
+	{ "YEHAT_CAVALRY_ARRIVED", 1 },
+	{ "URQUAN_MESSED_UP", 1 },
+	{ "MOONBASE_DESTROYED", 1 },
+	{ "WILL_DESTROY_BASE", 1 },
+	{ "ARTIFACT_2_ON_SHIP", 1 },
+	{ "ARTIFACT_3_ON_SHIP", 1 },
+	{ "KOHR_AH_KILLED_ALL", 1 },
+	{ "STARBASE_YACK_STACK1", 1 },
+	{ "DISCUSSED_PORTAL_SPAWNER", 1 },
+	{ "DISCUSSED_TALKING_PET", 1 },
+	{ "DISCUSSED_UTWIG_BOMB", 1 },
+	{ "DISCUSSED_SUN_EFFICIENCY", 1 },
+	{ "DISCUSSED_ROSY_SPHERE", 1 },
+	{ "DISCUSSED_AQUA_HELIX", 1 },
+	{ "DISCUSSED_CLEAR_SPINDLE", 1 },
+	{ "DISCUSSED_ULTRON", 1 },
+	{ "DISCUSSED_MAIDENS", 1 },
+	{ "DISCUSSED_UMGAH_HYPERWAVE", 1 },
+	{ "DISCUSSED_BURVIX_HYPERWAVE", 1 },
+	{ "SYREEN_WANT_PROOF", 1 },
+	{ "PLAYER_HAVING_SEX", 1 },
+	{ "MET_ARILOU", 1 },
+	{ "DISCUSSED_TAALO_PROTECTOR", 1 },
+	{ "DISCUSSED_EGG_CASING0", 1 },
+	{ "DISCUSSED_EGG_CASING1", 1 },
+	{ "DISCUSSED_EGG_CASING2", 1 },
+	{ "DISCUSSED_SYREEN_SHUTTLE", 1 },
+	{ "DISCUSSED_VUX_BEAST", 1 },
+	{ "DISCUSSED_DESTRUCT_CODE", 1 },
+	{ "DISCUSSED_URQUAN_WARP", 1 },
+	{ "DISCUSSED_ARTIFACT_2", 1 },
+	{ "DISCUSSED_ARTIFACT_3", 1 },
+	{ "ATTACKED_DRUUGE", 1 },
+	{ "NEW_ALLIANCE_NAME", 2 },
+	{ "PORTAL_COUNTER", 4 },
+	{ "BURVIXESE_BROADCASTERS", 1 },
+	{ "BURV_BROADCASTERS_ON_SHIP", 1 },
+	{ "UTWIG_BOMB", 1 },
+	{ "UTWIG_BOMB_ON_SHIP", 1 },
+	{ "AQUA_HELIX", 1 },
+	{ "AQUA_HELIX_ON_SHIP", 1 },
+	{ "SUN_DEVICE", 1 },
+	{ "SUN_DEVICE_ON_SHIP", 1 },
+	{ "TAALO_PROTECTOR", 1 },
+	{ "TAALO_PROTECTOR_ON_SHIP", 1 },
+	{ "SHIP_VAULT_UNLOCKED", 1 },
+	{ "SYREEN_SHUTTLE", 1 },
+	{ "PORTAL_KEY", 1 },
+	{ "PORTAL_KEY_ON_SHIP", 1 },
+	{ "VUX_BEAST", 1 },
+	{ "VUX_BEAST_ON_SHIP", 1 },
+	{ "TALKING_PET", 1 },
+	{ "TALKING_PET_ON_SHIP", 1 },
+	{ "MOONBASE_ON_SHIP", 1 },
+	{ "KOHR_AH_FRENZY", 1 },
+	{ "KOHR_AH_VISITS", 2 },
+	{ "KOHR_AH_BYES", 1 },
+	{ "SLYLANDRO_HOME_VISITS", 3 },
+	{ "DESTRUCT_CODE_ON_SHIP", 1 },
+	{ "ILWRATH_VISITS", 3 },
+	{ "ILWRATH_DECEIVED", 1 },
+	{ "FLAGSHIP_CLOAKED", 1 },
+	{ "MYCON_VISITS", 3 },
+	{ "MYCON_HOME_VISITS", 3 },
+	{ "MYCON_AMBUSH", 1 },
+	{ "MYCON_FELL_FOR_AMBUSH", 1 },
+	{ "GLOBAL_FLAGS_AND_DATA", 8 },
+	{ "ORZ_VISITS", 3 },
+	{ "TAALO_VISITS", 3 },
+	{ "ORZ_MANNER", 2 },
+	{ "PROBE_EXHIBITED_BUG", 1 },
+	{ "CLEAR_SPINDLE_ON_SHIP", 1 },
+	{ "URQUAN_VISITS", 3 },
+	{ "PLAYER_HYPNOTIZED", 1 },
+	{ "VUX_VISITS", 3 },
+	{ "VUX_HOME_VISITS", 3 },
+	{ "ZEX_VISITS", 3 },
+	{ "ZEX_IS_DEAD", 1 },
+	{ "KNOW_ZEX_WANTS_MONSTER", 1 },
+	{ "UTWIG_VISITS", 3 },
+	{ "UTWIG_HOME_VISITS", 3 },
+	{ "BOMB_VISITS", 3 },
+	{ "ULTRON_CONDITION", 3 },
+	{ "UTWIG_HAVE_ULTRON", 1 },
+	{ "BOMB_UNPROTECTED", 1 },
+	{ "TAALO_UNPROTECTED", 1 },
+	{ "TALKING_PET_VISITS", 3 },
+	{ "TALKING_PET_HOME_VISITS", 3 },
+	{ "UMGAH_ZOMBIE_BLOBBIES", 1 },
+	{ "KNOW_UMGAH_ZOMBIES", 1 },
+	{ "ARILOU_VISITS", 3 },
+	{ "ARILOU_HOME_VISITS", 3 },
+	{ "KNOW_ARILOU_WANT_WRECK", 1 },
+	{ "ARILOU_CHECKED_UMGAH", 2 },
+	{ "PORTAL_SPAWNER", 1 },
+	{ "PORTAL_SPAWNER_ON_SHIP", 1 },
+	{ "UMGAH_VISITS", 3 },
+	{ "UMGAH_HOME_VISITS", 3 },
+	{ "MET_NORMAL_UMGAH", 1 },
+	{ "SYREEN_HOME_VISITS", 3 },
+	{ "SYREEN_SHUTTLE_ON_SHIP", 1 },
+	{ "KNOW_SYREEN_VAULT", 1 },
+	{ "EGG_CASE0_ON_SHIP", 1 },
+	{ "SUN_DEVICE_UNGUARDED", 1 },
+	{ "ROSY_SPHERE_ON_SHIP", 1 },
+	{ "CHMMR_HOME_VISITS", 3 },
+	{ "CHMMR_EMERGING", 1 },
+	{ "CHMMR_UNLEASHED", 1 },
+	{ "CHMMR_BOMB_STATE", 2 },
+	{ "DRUUGE_DISCLAIMER", 1 },
+	{ "YEHAT_VISITS", 3 },
+	{ "YEHAT_REBEL_VISITS", 3 },
+	{ "YEHAT_HOME_VISITS", 3 },
+	{ "YEHAT_CIVIL_WAR", 1 },
+	{ "YEHAT_ABSORBED_PKUNK", 1 },
+	{ "YEHAT_SHIP_MONTH", 4 },
+	{ "YEHAT_SHIP_DAY", 5 },
+	{ "YEHAT_SHIP_YEAR", 5 },
+	{ "CLEAR_SPINDLE", 1 },
+	{ "PKUNK_VISITS", 3 },
+	{ "PKUNK_HOME_VISITS", 3 },
+	{ "PKUNK_SHIP_MONTH", 4 },
+	{ "PKUNK_SHIP_DAY", 5 },
+	{ "PKUNK_SHIP_YEAR", 5 },
+	{ "PKUNK_MISSION", 3 },
+	{ "SUPOX_VISITS", 3 },
+	{ "SUPOX_HOME_VISITS", 3 },
+	{ "THRADD_VISITS", 3 },
+	{ "THRADD_HOME_VISITS", 3 },
+	{ "HELIX_VISITS", 3 },
+	{ "HELIX_UNPROTECTED", 1 },
+	{ "THRADD_CULTURE", 2 },
+	{ "THRADD_MISSION", 3 },
+	{ "DRUUGE_VISITS", 3 },
+	{ "DRUUGE_HOME_VISITS", 3 },
+	{ "ROSY_SPHERE", 1 },
+	{ "SCANNED_MAIDENS", 1 },
+	{ "SCANNED_FRAGMENTS", 1 },
+	{ "SCANNED_CASTER", 1 },
+	{ "SCANNED_SPAWNER", 1 },
+	{ "SCANNED_ULTRON", 1 },
+	{ "ZOQFOT_INFO", 2 },
+	{ "ZOQFOT_HOSTILE", 1 },
+	{ "ZOQFOT_HOME_VISITS", 3 },
+	{ "MET_ZOQFOT", 1 },
+	{ "ZOQFOT_DISTRESS", 2 },
+	{ "EGG_CASE1_ON_SHIP", 1 },
+	{ "EGG_CASE2_ON_SHIP", 1 },
+	{ "MYCON_SUN_VISITS", 3 },
+	{ "ORZ_HOME_VISITS", 3 },
+	{ "MELNORME_FUEL_PROCEDURE", 1 },
+	{ "MELNORME_TECH_PROCEDURE", 1 },
+	{ "MELNORME_INFO_PROCEDURE", 1 },
+	{ "MELNORME_TECH_STACK", 4 },
+	{ "MELNORME_EVENTS_INFO_STACK", 5 },
+	{ "MELNORME_ALIEN_INFO_STACK", 5 },
+	{ "MELNORME_HISTORY_INFO_STACK", 5 },
+	{ "RAINBOW_WORLD0", 8 },
+	{ "RAINBOW_WORLD1", 2 },
+	{ "MELNORME_RAINBOW_COUNT", 4 },
+	{ "USED_BROADCASTER", 1 },
+	{ "BROADCASTER_RESPONSE", 1 },
+	{ "IMPROVED_LANDER_SPEED", 1 },
+	{ "IMPROVED_LANDER_CARGO", 1 },
+	{ "IMPROVED_LANDER_SHOT", 1 },
+	{ "MET_ORZ_BEFORE", 1 },
+	{ "YEHAT_REBEL_TOLD_PKUNK", 1 },
+	{ "PLAYER_HAD_SEX", 1 },
+	{ "UMGAH_BROADCASTERS_ON_SHIP", 1 },
+	{ "LIGHT_MINERAL_LOAD", 3 },
+	{ "MEDIUM_MINERAL_LOAD", 3 },
+	{ "HEAVY_MINERAL_LOAD", 3 },
+	{ "STARBASE_BULLETS", 32 },
+	{ "STARBASE_MONTH", 4 },
+	{ "STARBASE_DAY", 5 },
+	{ "CREW_SOLD_TO_DRUUGE0", 8 },
+	{ "CREW_PURCHASED0", 8 },
+	{ "CREW_PURCHASED1", 8 },
+	{ "URQUAN_PROTECTING_SAMATRA", 1 },
+	{ "COLONY_GRPOFFS", 32 },
+	{ "THRADDASH_BODY_COUNT", 5 },
+	{ "UTWIG_SUPOX_MISSION", 3 },
+	{ "SPATHI_INFO", 3 },
+	{ "ILWRATH_INFO", 2 },
+	{ "ILWRATH_GODS_SPOKEN", 4 },
+	{ "ILWRATH_WORSHIP", 2 },
+	{ "ILWRATH_FIGHT_THRADDASH", 1 },
+	{ "SAMATRA_GRPOFFS", 32 },
+	{ "READY_TO_CONFUSE_URQUAN", 1 },
+	{ "URQUAN_HYPNO_VISITS", 1 },
+	{ "MENTIONED_PET_COMPULSION", 1 },
+	{ "URQUAN_INFO", 2 },
+	{ "KNOW_URQUAN_STORY", 2 },
+	{ "MYCON_INFO", 4 },
+	{ "MYCON_RAMBLE", 5 },
+	{ "KNOW_ABOUT_SHATTERED", 2 },
+	{ "MYCON_INSULTS", 3 },
+	{ "MYCON_KNOW_AMBUSH", 1 },
+	{ "SYREEN_INFO", 2 },
+	{ "KNOW_SYREEN_WORLD_SHATTERED", 1 },
+	{ "SYREEN_KNOW_ABOUT_MYCON", 1 },
+	{ "TALKING_PET_INFO", 3 },
+	{ "TALKING_PET_SUGGESTIONS", 3 },
+	{ "LEARNED_TALKING_PET", 1 },
+	{ "DNYARRI_LIED", 1 },
+	{ "SHIP_TO_COMPEL", 1 },
+	{ "ORZ_GENERAL_INFO", 2 },
+	{ "ORZ_PERSONAL_INFO", 3 },
+	{ "ORZ_ANDRO_STATE", 2 },
+	{ "REFUSED_ORZ_ALLIANCE", 1 },
+	{ "PKUNK_MANNER", 2 },
+	{ "PKUNK_ON_THE_MOVE", 1 },
+	{ "PKUNK_FLEET", 2 },
+	{ "PKUNK_MIGRATE", 2 },
+	{ "PKUNK_RETURN", 1 },
+	{ "PKUNK_WORRY", 2 },
+	{ "PKUNK_INFO", 3 },
+	{ "PKUNK_WAR", 2 },
+	{ "PKUNK_FORTUNE", 3 },
+	{ "PKUNK_MIGRATE_VISITS", 3 },
+	{ "PKUNK_REASONS", 4 },
+	{ "PKUNK_SWITCH", 1 },
+	{ "PKUNK_SENSE_VICTOR", 1 },
+	{ "KOHR_AH_REASONS", 2 },
+	{ "KOHR_AH_PLEAD", 2 },
+	{ "KOHR_AH_INFO", 2 },
+	{ "KNOW_KOHR_AH_STORY", 2 },
+	{ "KOHR_AH_SENSES_EVIL", 1 },
+	{ "URQUAN_SENSES_EVIL", 1 },
+	{ "SLYLANDRO_PROBE_VISITS", 3 },
+	{ "SLYLANDRO_PROBE_THREAT", 2 },
+	{ "SLYLANDRO_PROBE_WRONG", 2 },
+	{ "SLYLANDRO_PROBE_ID", 2 },
+	{ "SLYLANDRO_PROBE_INFO", 2 },
+	{ "SLYLANDRO_PROBE_EXIT", 2 },
+	{ "UMGAH_HOSTILE", 1 },
+	{ "UMGAH_EVIL_BLOBBIES", 1 },
+	{ "UMGAH_MENTIONED_TRICKS", 2 },
+	{ "BOMB_CARRIER", 1 },
+	{ "THRADD_MANNER", 1 },
+	{ "THRADD_INTRO", 2 },
+	{ "THRADD_DEMEANOR", 3 },
+	{ "THRADD_INFO", 2 },
+	{ "THRADD_BODY_LEVEL", 2 },
+	{ "THRADD_MISSION_VISITS", 1 },
+	{ "THRADD_STACK_1", 3 },
+	{ "THRADD_HOSTILE_STACK_2", 1 },
+	{ "THRADD_HOSTILE_STACK_3", 1 },
+	{ "THRADD_HOSTILE_STACK_4", 1 },
+	{ "THRADD_HOSTILE_STACK_5", 1 },
+	{ "CHMMR_STACK", 2 },
+	{ "ARILOU_MANNER", 2 },
+	{ "NO_PORTAL_VISITS", 1 },
+	{ "ARILOU_STACK_1", 2 },
+	{ "ARILOU_STACK_2", 1 },
+	{ "ARILOU_STACK_3", 2 },
+	{ "ARILOU_STACK_4", 1 },
+	{ "ARILOU_STACK_5", 2 },
+	{ "ARILOU_INFO", 2 },
+	{ "ARILOU_HINTS", 2 },
+	{ "DRUUGE_MANNER", 1 },
+	{ "DRUUGE_SPACE_INFO", 2 },
+	{ "DRUUGE_HOME_INFO", 2 },
+	{ "DRUUGE_SALVAGE", 1 },
+	{ "KNOW_DRUUGE_SLAVERS", 2 },
+	{ "FRAGMENTS_BOUGHT", 2 },
+	{ "ZEX_STACK_1", 2 },
+	{ "ZEX_STACK_2", 2 },
+	{ "ZEX_STACK_3", 2 },
+	{ "VUX_INFO", 2 },
+	{ "VUX_STACK_1", 4 },
+	{ "VUX_STACK_2", 2 },
+	{ "VUX_STACK_3", 2 },
+	{ "VUX_STACK_4", 2 },
+	{ "SHOFIXTI_STACK4", 2 },
+	{ "YEHAT_REBEL_INFO", 3 },
+	{ "YEHAT_ROYALIST_INFO", 1 },
+	{ "YEHAT_ROYALIST_TOLD_PKUNK", 1 },
+	{ "NO_YEHAT_ALLY_HOME", 1 },
+	{ "NO_YEHAT_HELP_HOME", 1 },
+	{ "NO_YEHAT_INFO", 1 },
+	{ "NO_YEHAT_ALLY_SPACE", 2 },
+	{ "NO_YEHAT_HELP_SPACE", 2 },
+	{ "ZOQFOT_KNOW_MASK", 4 },
+	{ "SUPOX_HOSTILE", 1 },
+	{ "SUPOX_INFO", 1 },
+	{ "SUPOX_WAR_NEWS", 2 },
+	{ "SUPOX_ULTRON_HELP", 1 },
+	{ "SUPOX_STACK1", 3 },
+	{ "SUPOX_STACK2", 2 },
+	{ "UTWIG_HOSTILE", 1 },
+	{ "UTWIG_INFO", 1 },
+	{ "UTWIG_WAR_NEWS", 2 },
+	{ "UTWIG_STACK1", 3 },
+	{ "UTWIG_STACK2", 2 },
+	{ "BOMB_INFO", 1 },
+	{ "BOMB_STACK1", 2 },
+	{ "BOMB_STACK2", 2 },
+	{ "SLYLANDRO_KNOW_BROKEN", 1 },
+	{ "PLAYER_KNOWS_PROBE", 1 },
+	{ "PLAYER_KNOWS_PROGRAM", 1 },
+	{ "PLAYER_KNOWS_EFFECTS", 1 },
+	{ "PLAYER_KNOWS_PRIORITY", 1 },
+	{ "SLYLANDRO_STACK1", 3 },
+	{ "SLYLANDRO_STACK2", 1 },
+	{ "SLYLANDRO_STACK3", 2 },
+	{ "SLYLANDRO_STACK4", 2 },
+	{ "SLYLANDRO_STACK5", 1 },
+	{ "SLYLANDRO_STACK6", 1 },
+	{ "SLYLANDRO_STACK7", 2 },
+	{ "SLYLANDRO_STACK8", 2 },
+	{ "SLYLANDRO_STACK9", 2 },
+	{ "SLYLANDRO_KNOW_EARTH", 1 },
+	{ "SLYLANDRO_KNOW_EXPLORE", 1 },
+	{ "SLYLANDRO_KNOW_GATHER", 1 },
+	{ "SLYLANDRO_KNOW_URQUAN", 2 },
+	{ "RECALL_VISITS", 2 },
+	{ "SLYLANDRO_MULTIPLIER", 3 },
+	{ "KNOW_SPATHI_QUEST", 1 },
+	{ "KNOW_SPATHI_EVIL", 1 },
+	{ "BATTLE_PLANET", 8 },
+	{ "ESCAPE_COUNTER", 8 },
+	{ "CREW_SOLD_TO_DRUUGE1", 8 },
+	{ "PKUNK_DONE_WAR", 1 },
+	{ "SYREEN_STACK0", 2 },
+	{ "SYREEN_STACK1", 2 },
+	{ "SYREEN_STACK2", 2 },
+	{ "REFUSED_ULTRON_AT_BOMB", 1 },
+	{ "NO_TRICK_AT_SUN", 1 },
+	{ "SPATHI_STACK0", 2 },
+	{ "SPATHI_STACK1", 1 },
+	{ "SPATHI_STACK2", 1 },
+	{ "ORZ_STACK0", 1 },
+	{ "ORZ_STACK1", 1 },
+	{ NULL, 0 },
+};
+
+
+// XXX: these should handle endian conversions later
+static inline COUNT
+cread_8 (DECODE_REF fh, BYTE *v)
+{
+	BYTE t;
+	if (!v) /* read value ignored */
+		v = &t;
+	return cread (v, 1, 1, fh);
+}
+
+static inline COUNT
+cread_16 (DECODE_REF fh, UWORD *v)
+{
+	UWORD t;
+	if (!v) /* read value ignored */
+		v = &t;
+	return cread (v, 2, 1, fh);
+}
+
+static inline COUNT
+cread_16s (DECODE_REF fh, SWORD *v)
+{
+	UWORD t;
+	COUNT ret;
+	// value was converted to unsigned when saved
+	ret = cread_16 (fh, &t);
+	// unsigned to signed conversion
+	if (v)
+		*v = t;
+	return ret;
+}
+
+static inline COUNT
+cread_32 (DECODE_REF fh, DWORD *v)
+{
+	DWORD t;
+	if (!v) /* read value ignored */
+		v = &t;
+	return cread (v, 4, 1, fh);
+}
+
+static inline COUNT
+cread_32s (DECODE_REF fh, SDWORD *v)
+{
+	DWORD t;
+	COUNT ret;
+	// value was converted to unsigned when saved
+	ret = cread_32 (fh, &t);
+	// unsigned to signed conversion
+	if (v)
+		*v = t;
+	return ret;
+}
+
+static inline COUNT
+cread_ptr (DECODE_REF fh)
+{
+	DWORD t;
+	return cread_32 (fh, &t); /* ptrs are useless in saves */
+}
+
+static inline COUNT
+cread_a8 (DECODE_REF fh, BYTE *ar, COUNT count)
+{
+	assert (ar != NULL);
+	return cread (ar, 1, count, fh) == count;
+}
+
+static inline size_t
+read_8 (void *fp, BYTE *v)
+{
+	BYTE t;
+	if (!v) /* read value ignored */
+		v = &t;
+	return ReadResFile (v, 1, 1, fp);
+}
+
+static inline size_t
+read_16 (void *fp, UWORD *v)
+{
+	UWORD t;
+	if (!v) /* read value ignored */
+		v = &t;
+	return ReadResFile (v, 2, 1, fp);
+}
+
+static inline size_t
+read_32 (void *fp, DWORD *v)
+{
+	DWORD t;
+	if (!v) /* read value ignored */
+		v = &t;
+	return ReadResFile (v, 4, 1, fp);
+}
+
+static inline size_t
+read_32s (void *fp, SDWORD *v)
+{
+	DWORD t;
+	COUNT ret;
+	// value was converted to unsigned when saved
+	ret = read_32 (fp, &t);
+	// unsigned to signed conversion
+	if (v)
+		*v = t;
+	return ret;
+}
+
+static inline size_t
+read_ptr (void *fp)
+{
+	DWORD t;
+	return read_32 (fp, &t); /* ptrs are useless in saves */
+}
+
+static inline size_t
+read_a8 (void *fp, BYTE *ar, COUNT count)
+{
+	assert (ar != NULL);
+	return ReadResFile (ar, 1, count, fp) == count;
+}
+
+static inline size_t
+read_str (void *fp, char *str, COUNT count)
+{
+	// no type conversion needed for strings
+	return read_a8 (fp, (BYTE *)str, count);
+}
+
+static inline size_t
+read_a16 (void *fp, UWORD *ar, COUNT count)
+{
+	assert (ar != NULL);
+
+	for ( ; count > 0; --count, ++ar)
+	{
+		if (read_16 (fp, ar) != 1)
+			return 0;
+	}
+	return 1;
+}
+
+static void
+LoadEmptyQueue (DECODE_REF fh)
+{
+	COUNT num_links;
+
+	cread_16 (fh, &num_links);
+	if (num_links)
+	{
+		log_add (log_Error, "LoadEmptyQueue(): BUG: the queue is not empty!");
+#ifdef DEBUG
+		explode ();
+#endif
+	}
+}
+
+static void
+LoadShipQueue (DECODE_REF fh, QUEUE *pQueue)
+{
+	COUNT num_links;
+
+	cread_16 (fh, &num_links);
+
+	while (num_links--)
+	{
+		HSHIPFRAG hStarShip;
+		SHIP_FRAGMENT *FragPtr;
+		COUNT Index;
+		BYTE tmpb;
+
+		cread_16 (fh, &Index);
+
+		hStarShip = CloneShipFragment (Index, pQueue, 0);
+		FragPtr = LockShipFrag (pQueue, hStarShip);
+
+		// Read SHIP_FRAGMENT elements
+		cread_16 (fh, NULL); /* unused: was which_side */
+		cread_8  (fh, &FragPtr->captains_name_index);
+		cread_8  (fh, NULL); /* padding */
+		cread_16 (fh, NULL); /* unused: was ship_flags */
+		cread_8  (fh, &FragPtr->race_id);
+		cread_8  (fh, &FragPtr->index);
+		// XXX: reading crew as BYTE to maintain savegame compatibility
+		cread_8  (fh, &tmpb);
+		FragPtr->crew_level = tmpb;
+		cread_8  (fh, &tmpb);
+		FragPtr->max_crew = tmpb;
+		cread_8  (fh, &FragPtr->energy_level);
+		cread_8  (fh, &FragPtr->max_energy);
+		cread_16 (fh, NULL); /* unused; was loc.x */
+		cread_16 (fh, NULL); /* unused; was loc.y */
+
+		UnlockShipFrag (pQueue, hStarShip);
+	}
+}
+
+static void
+LoadRaceQueue (DECODE_REF fh, QUEUE *pQueue)
+{
+	COUNT num_links;
+
+	cread_16 (fh, &num_links);
+
+	while (num_links--)
+	{
+		HFLEETINFO hStarShip;
+		FLEET_INFO *FleetPtr;
+		COUNT Index;
+		BYTE tmpb;
+
+		cread_16 (fh, &Index);
+
+		hStarShip = GetStarShipFromIndex (pQueue, Index);
+		FleetPtr = LockFleetInfo (pQueue, hStarShip);
+
+		// Read FLEET_INFO elements
+		cread_16 (fh, &FleetPtr->allied_state);
+		cread_8  (fh, &FleetPtr->days_left);
+		cread_8  (fh, &FleetPtr->growth_fract);
+		cread_8  (fh, &tmpb);
+		FleetPtr->crew_level = tmpb;
+		cread_8  (fh, &tmpb);
+		FleetPtr->max_crew = tmpb;
+		cread_8  (fh, &FleetPtr->growth);
+		cread_8  (fh, &FleetPtr->max_energy);
+		cread_16s(fh, &FleetPtr->loc.x);
+		cread_16s(fh, &FleetPtr->loc.y);
+
+		cread_16 (fh, &FleetPtr->actual_strength);
+		cread_16 (fh, &FleetPtr->known_strength);
+		cread_16s(fh, &FleetPtr->known_loc.x);
+		cread_16s(fh, &FleetPtr->known_loc.y);
+		cread_8  (fh, &FleetPtr->growth_err_term);
+		cread_8  (fh, &FleetPtr->func_index);
+		cread_16s(fh, &FleetPtr->dest_loc.x);
+		cread_16s(fh, &FleetPtr->dest_loc.y);
+		cread_16 (fh, NULL); /* alignment padding */
+
+		UnlockFleetInfo (pQueue, hStarShip);
+	}
+}
+
+static void
+LoadGroupQueue (DECODE_REF fh, QUEUE *pQueue)
+{
+	COUNT num_links;
+
+	cread_16 (fh, &num_links);
+
+	while (num_links--)
+	{
+		HIPGROUP hGroup;
+		IP_GROUP *GroupPtr;
+		BYTE tmpb;
+
+		cread_16 (fh, NULL); /* unused; was race_id */
+
+		hGroup = BuildGroup (pQueue, 0);
+		GroupPtr = LockIpGroup (pQueue, hGroup);
+
+		cread_16 (fh, NULL); /* unused; was which_side */
+		cread_8  (fh, NULL); /* unused; was captains_name_index */
+		cread_8  (fh, NULL); /* padding; for savegame compat */
+		cread_16 (fh, &GroupPtr->group_counter);
+		cread_8  (fh, &GroupPtr->race_id);
+		cread_8  (fh, &tmpb); /* was var2 */
+		GroupPtr->sys_loc = LONIBBLE (tmpb);
+		GroupPtr->task = HINIBBLE (tmpb);
+		cread_8  (fh, &GroupPtr->in_system); /* was crew_level */
+		cread_8  (fh, NULL); /* unused; was max_crew */
+		cread_8  (fh, &tmpb); /* was energy_level */
+		GroupPtr->dest_loc = LONIBBLE (tmpb);
+		GroupPtr->orbit_pos = HINIBBLE (tmpb);
+		cread_8  (fh, &GroupPtr->group_id); /* was max_energy */
+		cread_16s(fh, &GroupPtr->loc.x);
+		cread_16s(fh, &GroupPtr->loc.y);
+
+		UnlockIpGroup (pQueue, hGroup);
+	}
+}
+
+static void
+LoadEncounter (ENCOUNTER *EncounterPtr, DECODE_REF fh)
+{
+	COUNT i;
+	BYTE tmpb;
+
+	cread_ptr (fh); /* useless ptr; HENCOUNTER pred */
+	EncounterPtr->pred = 0;
+	cread_ptr (fh); /* useless ptr; HENCOUNTER succ */
+	EncounterPtr->succ = 0;
+	cread_ptr (fh); /* useless ptr; HELEMENT hElement */
+	EncounterPtr->hElement = 0;
+	cread_16s (fh, &EncounterPtr->transition_state);
+	cread_16s (fh, &EncounterPtr->origin.x);
+	cread_16s (fh, &EncounterPtr->origin.y);
+	cread_16  (fh, &EncounterPtr->radius);
+	// former STAR_DESC fields
+	cread_16s (fh, &EncounterPtr->loc_pt.x);
+	cread_16s (fh, &EncounterPtr->loc_pt.y);
+	cread_8   (fh, &EncounterPtr->race_id);
+	cread_8   (fh, &tmpb);
+	EncounterPtr->num_ships = tmpb & ENCOUNTER_SHIPS_MASK;
+	EncounterPtr->flags = tmpb & ENCOUNTER_FLAGS_MASK;
+	cread_16  (fh, NULL); /* alignment padding */
+
+	// Load each entry in the BRIEF_SHIP_INFO array
+	for (i = 0; i < MAX_HYPER_SHIPS; i++)
+	{
+		BRIEF_SHIP_INFO *ShipInfo = &EncounterPtr->ShipList[i];
+
+		cread_16  (fh, NULL); /* useless; was SHIP_INFO.ship_flags */
+		cread_8   (fh, &ShipInfo->race_id);
+		cread_8   (fh, NULL); /* useless; was SHIP_INFO.var2 */
+		// XXX: reading crew as BYTE to maintain savegame compatibility
+		cread_8   (fh, &tmpb);
+		ShipInfo->crew_level = tmpb;
+		cread_8   (fh, &tmpb);
+		ShipInfo->max_crew = tmpb;
+		cread_8   (fh, NULL); /* useless; was SHIP_INFO.energy_level */
+		cread_8   (fh, &ShipInfo->max_energy);
+		cread_16  (fh, NULL); /* useless; was SHIP_INFO.loc.x */
+		cread_16  (fh, NULL); /* useless; was SHIP_INFO.loc.y */
+		cread_32  (fh, NULL); /* useless val; STRING race_strings */
+		cread_ptr (fh); /* useless ptr; FRAME icons */
+		cread_ptr (fh); /* useless ptr; FRAME melee_icon */
+	}
+	
+	// Load the stuff after the BRIEF_SHIP_INFO array
+	cread_32s (fh, &EncounterPtr->log_x);
+	cread_32s (fh, &EncounterPtr->log_y);
+}
+
+static void
+LoadEvent (EVENT *EventPtr, DECODE_REF fh)
+{
+	cread_ptr (fh); /* useless ptr; HEVENT pred */
+	EventPtr->pred = 0;
+	cread_ptr (fh); /* useless ptr; HEVENT succ */
+	EventPtr->succ = 0;
+	cread_8   (fh, &EventPtr->day_index);
+	cread_8   (fh, &EventPtr->month_index);
+	cread_16  (fh, &EventPtr->year_index);
+	cread_8   (fh, &EventPtr->func_index);
+	cread_8   (fh, NULL); /* padding */
+	cread_16  (fh, NULL); /* padding */
+}
+
+static void
+DummyLoadQueue (QUEUE *QueuePtr, DECODE_REF fh)
+{
+	/* QUEUE should never actually be loaded since it contains
+	 * purely internal representation and the lists
+	 * involved are actually loaded separately */
+	(void)QueuePtr; /* silence compiler */
+
+	/* QUEUE format with QUEUE_TABLE defined -- UQM default */
+	cread_ptr (fh); /* HLINK head */
+	cread_ptr (fh); /* HLINK tail */
+	cread_ptr (fh); /* BYTE* pq_tab */
+	cread_ptr (fh); /* HLINK free_list */
+	cread_16  (fh, NULL); /* MEM_HANDLE hq_tab */
+	cread_16  (fh, NULL); /* COUNT object_size */
+	cread_8   (fh, NULL); /* BYTE num_objects */
+	
+	cread_8   (fh, NULL); /* padding */
+	cread_16  (fh, NULL); /* padding */
+}
+
+static void
+LoadClockState (CLOCK_STATE *ClockPtr, DECODE_REF fh)
+{
+	cread_8   (fh, &ClockPtr->day_index);
+	cread_8   (fh, &ClockPtr->month_index);
+	cread_16  (fh, &ClockPtr->year_index);
+	cread_16s (fh, &ClockPtr->tick_count);
+	cread_16s (fh, &ClockPtr->day_in_ticks);
+	cread_ptr (fh); /* not loading ptr; Semaphore clock_sem */
+	cread_ptr (fh); /* not loading ptr; Task clock_task */
+	cread_32  (fh, NULL); /* not loading; DWORD TimeCounter */
+
+	DummyLoadQueue (&ClockPtr->event_q, fh);
+}
+
+static void
+LoadGameState (GAME_STATE *GSPtr, DECODE_REF fh)
+{
+	BYTE dummy8;
+
+	cread_8   (fh, &dummy8); /* obsolete */
+	cread_8   (fh, &GSPtr->glob_flags);
+	cread_8   (fh, &GSPtr->CrewCost);
+	cread_8   (fh, &GSPtr->FuelCost);
+	cread_a8  (fh, GSPtr->ModuleCost, NUM_MODULES);
+	cread_a8  (fh, GSPtr->ElementWorth, NUM_ELEMENT_CATEGORIES);
+	cread_ptr (fh); /* not loading ptr; PRIMITIVE *DisplayArray */
+	cread_16  (fh, &GSPtr->CurrentActivity);
+	
+	cread_16  (fh, NULL); /* CLOCK_STATE alignment padding */
+	LoadClockState (&GSPtr->GameClock, fh);
+
+	cread_16s (fh, &GSPtr->autopilot.x);
+	cread_16s (fh, &GSPtr->autopilot.y);
+	cread_16s (fh, &GSPtr->ip_location.x);
+	cread_16s (fh, &GSPtr->ip_location.y);
+	/* STAMP ShipStamp */
+	cread_16s (fh, &GSPtr->ShipStamp.origin.x);
+	cread_16s (fh, &GSPtr->ShipStamp.origin.y);
+	cread_16  (fh, &GSPtr->ShipFacing);
+	cread_8   (fh, &GSPtr->ip_planet);
+	cread_8   (fh, &GSPtr->in_orbit);
+
+	/* VELOCITY_DESC velocity */
+	cread_16  (fh, &GSPtr->velocity.TravelAngle);
+	cread_16s (fh, &GSPtr->velocity.vector.width);
+	cread_16s (fh, &GSPtr->velocity.vector.height);
+	cread_16s (fh, &GSPtr->velocity.fract.width);
+	cread_16s (fh, &GSPtr->velocity.fract.height);
+	cread_16s (fh, &GSPtr->velocity.error.width);
+	cread_16s (fh, &GSPtr->velocity.error.height);
+	cread_16s (fh, &GSPtr->velocity.incr.width);
+	cread_16s (fh, &GSPtr->velocity.incr.height);
+	cread_16  (fh, NULL); /* VELOCITY_DESC padding */
+
+	cread_32  (fh, &GSPtr->BattleGroupRef);
+	
+	DummyLoadQueue (&GSPtr->avail_race_q, fh);
+	DummyLoadQueue (&GSPtr->npc_built_ship_q, fh);
+	// Not loading ip_group_q, was not there originally
+	DummyLoadQueue (&GSPtr->encounter_q, fh);
+	DummyLoadQueue (&GSPtr->built_ship_q, fh);
+
+	{
+		size_t numBytes = (NUM_GAME_STATE_BITS + 7) >> 3;
+		BYTE *buf;
+
+		assert (numBytes % 4 == 3);
+				// We should have one byte padding.
+		buf = HMalloc (numBytes);
+		if (buf != NULL)
+		{
+			cread_a8  (fh, buf, numBytes);
+			deserialiseGameState (legacyGameStateBitMap, buf, numBytes);
+			HFree(buf);
+		}
+	}
+
+	cread_8  (fh, NULL); /* GAME_STATE alignment padding */
+}
+
+static BOOLEAN
+LoadSisState (SIS_STATE *SSPtr, void *fp)
+{
+	if (
+			read_32s (fp, &SSPtr->log_x) != 1 ||
+			read_32s (fp, &SSPtr->log_y) != 1 ||
+			read_32  (fp, &SSPtr->ResUnits) != 1 ||
+			read_32  (fp, &SSPtr->FuelOnBoard) != 1 ||
+			read_16  (fp, &SSPtr->CrewEnlisted) != 1 ||
+			read_16  (fp, &SSPtr->TotalElementMass) != 1 ||
+			read_16  (fp, &SSPtr->TotalBioMass) != 1 ||
+			read_a8  (fp, SSPtr->ModuleSlots, NUM_MODULE_SLOTS) != 1 ||
+			read_a8  (fp, SSPtr->DriveSlots, NUM_DRIVE_SLOTS) != 1 ||
+			read_a8  (fp, SSPtr->JetSlots, NUM_JET_SLOTS) != 1 ||
+			read_8   (fp, &SSPtr->NumLanders) != 1 ||
+			read_a16 (fp, SSPtr->ElementAmounts, NUM_ELEMENT_CATEGORIES) != 1 ||
+
+			read_str (fp, SSPtr->ShipName, SIS_NAME_SIZE) != 1 ||
+			read_str (fp, SSPtr->CommanderName, SIS_NAME_SIZE) != 1 ||
+			read_str (fp, SSPtr->PlanetName, SIS_NAME_SIZE) != 1 ||
+
+			read_16  (fp, NULL) != 1 /* padding */
+		)
+		return FALSE;
+	else
+		return TRUE;
+}
+
+static BOOLEAN
+LoadSummary (SUMMARY_DESC *SummPtr, void *fp)
+{
+	if (!LoadSisState (&SummPtr->SS, fp))
+		return FALSE;
+
+	if (
+			read_8  (fp, &SummPtr->Activity) != 1 ||
+			read_8  (fp, &SummPtr->Flags) != 1 ||
+			read_8  (fp, &SummPtr->day_index) != 1 ||
+			read_8  (fp, &SummPtr->month_index) != 1 ||
+			read_16 (fp, &SummPtr->year_index) != 1 ||
+			read_8  (fp, &SummPtr->MCreditLo) != 1 ||
+			read_8  (fp, &SummPtr->MCreditHi) != 1 ||
+			read_8  (fp, &SummPtr->NumShips) != 1 ||
+			read_8  (fp, &SummPtr->NumDevices) != 1 ||
+			read_a8 (fp, SummPtr->ShipList, MAX_BUILT_SHIPS) != 1 ||
+			read_a8 (fp, SummPtr->DeviceList, MAX_EXCLUSIVE_DEVICES) != 1 ||
+
+			read_16  (fp, NULL) != 1 /* padding */
+		)
+		return FALSE;
+	else
+		return TRUE;
+}
+
+static void
+LoadStarDesc (STAR_DESC *SDPtr, DECODE_REF fh)
+{
+	cread_16s(fh, &SDPtr->star_pt.x);
+	cread_16s(fh, &SDPtr->star_pt.y);
+	cread_8  (fh, &SDPtr->Type);
+	cread_8  (fh, &SDPtr->Index);
+	cread_8  (fh, &SDPtr->Prefix);
+	cread_8  (fh, &SDPtr->Postfix);
+}
+
+BOOLEAN
+LoadLegacyGame (COUNT which_game, SUMMARY_DESC *SummPtr)
+{
+	uio_Stream *in_fp;
+	char file[PATH_MAX];
+	char buf[256];
+	SUMMARY_DESC loc_sd;
+	GAME_STATE_FILE *fp;
+	DECODE_REF fh;
+	COUNT num_links;
+	STAR_DESC SD;
+	ACTIVITY Activity;
+
+	sprintf (file, "starcon2.%02u", which_game);
+	in_fp = res_OpenResFile (saveDir, file, "rb");
+	if (!in_fp)
+		return FALSE;
+
+	loc_sd.SaveName[0] = '\0';
+	if (!LoadSummary (&loc_sd, in_fp))
+	{
+		log_add (log_Error, "Warning: Savegame is corrupt");
+		res_CloseResFile (in_fp);
+		return FALSE;
+	}
+
+	if (!SummPtr)
+	{
+		SummPtr = &loc_sd;
+	}
+	else
+	{	// only need summary for displaying to user
+		memcpy (SummPtr, &loc_sd, sizeof (*SummPtr));
+		res_CloseResFile (in_fp);
+		return TRUE;
+	}
+
+	// Crude check for big-endian/little-endian incompatibilities.
+	// year_index is suitable as it's a multi-byte value within
+	// a specific recognisable range.
+	if (SummPtr->year_index < START_YEAR ||
+			SummPtr->year_index >= START_YEAR +
+			YEARS_TO_KOHRAH_VICTORY + 1 /* Utwig intervention */ +
+			1 /* time to destroy all races, plenty */ +
+			25 /* for cheaters */)
+	{
+		log_add (log_Error, "Warning: Savegame corrupt or from "
+				"an incompatible platform.");
+		res_CloseResFile (in_fp);
+		return FALSE;
+	}
+
+	GlobData.SIS_state = SummPtr->SS;
+
+	if ((fh = copen (in_fp, FILE_STREAM, STREAM_READ)) == 0)
+	{
+		res_CloseResFile (in_fp);
+		return FALSE;
+	}
+
+	ReinitQueue (&GLOBAL (GameClock.event_q));
+	ReinitQueue (&GLOBAL (encounter_q));
+	ReinitQueue (&GLOBAL (ip_group_q));
+	ReinitQueue (&GLOBAL (npc_built_ship_q));
+	ReinitQueue (&GLOBAL (built_ship_q));
+
+	uninitEventSystem ();
+	luaUqm_uninitState();
+	luaUqm_initState();
+	initEventSystem ();
+
+	Activity = GLOBAL (CurrentActivity);
+	LoadGameState (&GlobData.Game_state, fh);
+	NextActivity = GLOBAL (CurrentActivity);
+	GLOBAL (CurrentActivity) = Activity;
+
+	LoadRaceQueue (fh, &GLOBAL (avail_race_q));
+	// START_INTERPLANETARY is only set when saving from Homeworld
+	//   encounter screen. When the game is loaded, the
+	//   GenerateOrbitalFunction for the current star system will
+	//   create the encounter anew and populate the npc queue.
+	if (!(NextActivity & START_INTERPLANETARY))
+	{
+		if (NextActivity & START_ENCOUNTER)
+			LoadShipQueue (fh, &GLOBAL (npc_built_ship_q));
+		else if (LOBYTE (NextActivity) == IN_INTERPLANETARY)
+			// XXX: Technically, this queue does not need to be
+			//   saved/loaded at all. IP groups will be reloaded
+			//   from group state files. But the original code did,
+			//   and so will we until we can prove we do not need to.
+			LoadGroupQueue (fh, &GLOBAL (ip_group_q));
+		else
+			// XXX: The empty queue read is only needed to maintain
+			//   the savegame compatibility
+			LoadEmptyQueue (fh);
+	}
+	LoadShipQueue (fh, &GLOBAL (built_ship_q));
+
+	// Load the game events (compressed)
+	cread_16 (fh, &num_links);
+	{
+#ifdef DEBUG_LOAD
+		log_add (log_Debug, "EVENTS:");
+#endif /* DEBUG_LOAD */
+		while (num_links--)
+		{
+			HEVENT hEvent;
+			EVENT *EventPtr;
+
+			hEvent = AllocEvent ();
+			LockEvent (hEvent, &EventPtr);
+
+			LoadEvent (EventPtr, fh);
+
+#ifdef DEBUG_LOAD
+		log_add (log_Debug, "\t%u/%u/%u -- %u",
+				EventPtr->month_index,
+				EventPtr->day_index,
+				EventPtr->year_index,
+				EventPtr->func_index);
+#endif /* DEBUG_LOAD */
+			UnlockEvent (hEvent);
+			PutEvent (hEvent);
+		}
+	}
+
+	// Load the encounters (black globes in HS/QS (compressed))
+	cread_16 (fh, &num_links);
+	{
+		while (num_links--)
+		{
+			HENCOUNTER hEncounter;
+			ENCOUNTER *EncounterPtr;
+
+			hEncounter = AllocEncounter ();
+			LockEncounter (hEncounter, &EncounterPtr);
+
+			LoadEncounter (EncounterPtr, fh);
+
+			UnlockEncounter (hEncounter);
+			PutEncounter (hEncounter);
+		}
+	}
+
+	// Copy the star info file from the compressed stream
+	fp = OpenStateFile (STARINFO_FILE, "wb");
+	if (fp)
+	{
+		DWORD flen;
+
+		cread_32 (fh, &flen);
+		while (flen)
+		{
+			COUNT num_bytes;
+
+			num_bytes = flen >= sizeof (buf) ? sizeof (buf) : (COUNT)flen;
+			cread (buf, num_bytes, 1, fh);
+			WriteStateFile (buf, num_bytes, 1, fp);
+
+			flen -= num_bytes;
+		}
+		CloseStateFile (fp);
+	}
+
+	// Copy the defined groupinfo file from the compressed stream
+	fp = OpenStateFile (DEFGRPINFO_FILE, "wb");
+	if (fp)
+	{
+		DWORD flen;
+
+		cread_32 (fh, &flen);
+		while (flen)
+		{
+			COUNT num_bytes;
+
+			num_bytes = flen >= sizeof (buf) ? sizeof (buf) : (COUNT)flen;
+			cread (buf, num_bytes, 1, fh);
+			WriteStateFile (buf, num_bytes, 1, fp);
+
+			flen -= num_bytes;
+		}
+		CloseStateFile (fp);
+	}
+
+	// Copy the random groupinfo file from the compressed stream
+	fp = OpenStateFile (RANDGRPINFO_FILE, "wb");
+	if (fp)
+	{
+		DWORD flen;
+
+		cread_32 (fh, &flen);
+		while (flen)
+		{
+			COUNT num_bytes;
+
+			num_bytes = flen >= sizeof (buf) ? sizeof (buf) : (COUNT)flen;
+			cread (buf, num_bytes, 1, fh);
+			WriteStateFile (buf, num_bytes, 1, fp);
+
+			flen -= num_bytes;
+		}
+		CloseStateFile (fp);
+	}
+
+	LoadStarDesc (&SD, fh);
+
+	cclose (fh);
+	res_CloseResFile (in_fp);
+
+	EncounterGroup = 0;
+	EncounterRace = -1;
+
+	ReinitQueue (&race_q[0]);
+	ReinitQueue (&race_q[1]);
+	CurStarDescPtr = FindStar (NULL, &SD.star_pt, 0, 0);
+	if (!(NextActivity & START_ENCOUNTER)
+			&& LOBYTE (NextActivity) == IN_INTERPLANETARY)
+		NextActivity |= START_INTERPLANETARY;
+
+	return TRUE;
+}
+
+
diff -ruNp src.orig/uqm/loadship.c src/uqm/loadship.c
--- src.orig/uqm/loadship.c	2017-11-21 19:39:38 -0600
+++ src/uqm/loadship.c	2017-11-21 19:39:55 -0600
@@ -170,6 +170,9 @@ void
 free_ship (RACE_DESC *raceDescPtr, BOOLEAN FreeIconData,
 		BOOLEAN FreeBattleData)
 {
+	if (raceDescPtr->uninit_func != NULL)
+		(*raceDescPtr->uninit_func) (raceDescPtr);
+
 	if (FreeBattleData)
 	{
 		DATA_STUFF *shipData = &raceDescPtr->ship_data;
diff -ruNp src.orig/uqm/lua/Makeinfo src/uqm/lua/Makeinfo
--- src.orig/uqm/lua/Makeinfo	1969-12-31 18:00:00 -0600
+++ src/uqm/lua/Makeinfo	2017-11-21 19:39:56 -0600
@@ -0,0 +1,9 @@
+uqm_SUBDIRS="luafuncs"
+uqm_CFILES="luacomm.c luaevent.c luainit.c luastate.c"
+uqm_HFILES="luacomm.h luaevent.h luainit.h luastate.h"
+
+if [ -n "$DEBUG" ]; then
+	uqm_CFILES="$uqm_CFILES luadebug.c"
+	uqm_HFILES="$uqm_HFILES luadebug.h"
+fi
+
diff -ruNp src.orig/uqm/lua/luacomm.c src/uqm/lua/luacomm.c
--- src.orig/uqm/lua/luacomm.c	1969-12-31 18:00:00 -0600
+++ src/uqm/lua/luacomm.c	2017-11-21 19:39:55 -0600
@@ -0,0 +1,288 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * This file contains code for using Lua with the game conversations.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+
+#define LUAUQM_INTERNAL
+#include "port.h"
+#include "luacomm.h"
+
+#include "options.h"
+		// For contentDir
+#include "libs/scriptlib.h"
+#include "uqm/lua/luastate.h"
+#include "luafuncs/commfuncs.h"
+#include "luafuncs/customfuncs.h"
+#include "luafuncs/eventfuncs.h"
+#include "luafuncs/logfuncs.h"
+#include "luafuncs/statefuncs.h"
+#include "libs/log.h"
+
+lua_State *luaUqm_commState = NULL;
+	
+static const luaL_Reg commLibs[] = {
+	{ "comm",  luaUqm_comm_open },
+	{ "event", luaUqm_event_open },
+	{ "log",   luaUqm_log_open },
+	{ "state", luaUqm_state_open },
+	{ NULL, NULL }
+};
+
+// Not reentrant.
+// If 'customFuncs' is NULL, no 'custom' table is added to the Lua environment.
+// If 'scriptRes' is NULL_RESOURCE, then no script is loaded. Lua is only
+// available for string interpolation in this case.
+BOOLEAN
+luaUqm_comm_init(const luaUqm_custom_Function *customFuncs,
+		RESOURCE scriptRes) {
+	assert(luaUqm_commState == NULL);
+
+	luaUqm_commState = luaUqm_globalState;
+
+	// Prepare the global environment.
+	luaUqm_prepareEnvironment(luaUqm_commState);
+	luaUqm_loadLibs(luaUqm_commState, commLibs);
+	if (customFuncs != NULL) {
+		luaUqm_custom_init(luaUqm_commState, customFuncs);
+		lua_pop(luaUqm_commState, 1);
+	}
+
+	if (scriptRes != NULL_RESOURCE) {
+		// Load the script.
+		char *scriptFileName;
+		BOOLEAN loadOk;
+
+		// Get the name of the script.
+		scriptFileName = LoadScriptInstance(scriptRes);
+		if (scriptFileName == NULL)
+			return FALSE;
+
+		// Load the script.
+		loadOk = luaUqm_loadScript(luaUqm_commState, contentDir,
+				scriptFileName);
+		ReleaseScriptResData(scriptFileName);
+		if (!loadOk)
+			return FALSE;
+
+		// Call the script.
+		luaUqm_callStackFunction(luaUqm_commState);
+	}
+
+	return TRUE;
+}
+
+void
+luaUqm_comm_uninit(void) {
+	assert(luaUqm_commState != NULL);
+	luaUqm_commState = NULL;
+}
+
+// Use as LOCDATA.init_encounter_func
+void
+luaUqm_comm_genericInit(void) {
+	assert(luaUqm_commState != NULL);
+	luaUqm_callFunction(luaUqm_commState, "init");
+}
+
+// Use as LOCDATA.post_encounter_func
+void
+luaUqm_comm_genericPost(void) {
+	assert(luaUqm_commState != NULL);
+	luaUqm_callFunction(luaUqm_commState, "post");
+}
+
+// Use as LOCDATA.uninit_encounter_func
+void
+luaUqm_comm_genericUninit(void) {
+	assert(luaUqm_commState != NULL);
+	luaUqm_callFunction(luaUqm_commState, "uninit");
+
+	luaUqm_comm_uninit();
+}
+
+BOOLEAN
+luaUqm_comm_stringNeedsInterpolate (const char *str)
+{
+	return strstr (str, "<%") != NULL;
+}
+
+// Resizes *buf if necessary. Makes sure that there is always enough
+// space for a final '\0' to be added.
+static void
+luaUqm_comm_addToBuffer  (char **buf, size_t *bufLen, char **bufPtr,
+		const char *add, size_t addLen)
+{
+	size_t bufFill = *bufPtr - *buf;
+	size_t newLen = *bufLen;
+
+	while ((size_t) (bufFill + addLen >= newLen)) {
+			// Need enough space for the terminating '\0' too.
+		newLen = newLen * 2;
+	}
+
+	if (newLen != *bufLen) {
+		char *newBuf = HRealloc (*buf, newLen);
+		if (newBuf == NULL)
+		{
+			log_add (log_Error, "Error: luaUqm_addToBuffer(): could not "
+					"allocate memory.\n");
+			return;
+					// We continue, without adding 'add' to the buffer.
+		}
+
+		*bufLen = newLen;
+		*buf = newBuf;
+		*bufPtr = newBuf + bufFill;
+	}
+
+	memcpy (*bufPtr, add, addLen);
+	*bufPtr += addLen;
+}
+
+// Pre: *bufLen contains the space available in buf.
+// Post: *bufLen contains the size of the string in *buf.
+char *
+luaUqm_comm_stringInterpolate (const char *str)
+{
+	const char *strPtr;
+	size_t interI;
+			// Interpolation counter.
+	char *buf;
+			//
+	char *bufPtr;
+	size_t bufLen;
+	const char *part;
+	size_t partLen;
+	
+	assert(luaUqm_commState != NULL);
+
+	bufLen = 2048;
+	buf = HMalloc (bufLen);
+	if (buf == NULL)
+		return NULL;
+
+	strPtr = str;
+	bufPtr = buf;
+
+	// We go through the string and put all the parts into a Lua table.
+	for (interI = 0; ; interI++) {
+		const char *startTag;
+		const char *endTag;
+		const char *luaStart;
+
+		startTag = strstr (strPtr, "<%");
+		if (startTag == NULL)
+			break;
+		luaStart = startTag + 2;
+
+		// Store the string before the '<%'.
+		luaUqm_comm_addToBuffer (&buf, &bufLen, &bufPtr,
+				strPtr, startTag - strPtr);
+		
+		endTag = strstr (startTag + 2, "%>");
+		if (endTag == NULL) {
+			log_add (log_Error, "luaUqm_stringInterpolate(): Unterminated "
+					"'<%% .. %%>' sequence in string '%s'.", str);
+			// We ignore the rest of the string.
+			goto out;
+		}
+
+		strPtr = endTag + 2;
+		interI++;
+
+		// Compile the string to a Lua function.
+		{
+			size_t exprLen = endTag - luaStart;
+#define LUAEXPR_START "return "
+			char *exprBuf = HMalloc(sizeof LUAEXPR_START + exprLen);
+					// 'sizeof LUAEXPR_START' includes a null byte
+			char *exprBufPtr = exprBuf;
+			strcpy(exprBuf, LUAEXPR_START);
+			exprBufPtr += sizeof LUAEXPR_START - 1;
+			memcpy(exprBufPtr, luaStart, exprLen);
+			exprBufPtr += exprLen;
+			*exprBufPtr = '\0';
+
+			if (luaL_loadstring (luaUqm_commState, exprBuf) != LUA_OK) {
+				log_add (log_Error, "luaUqm_stringInterpolate(): "
+						"lua_loadstring() failed: %s",
+						lua_tostring (luaUqm_commState, -1));
+				lua_pop (luaUqm_commState, 1);
+						// Pop the error.
+				continue;
+			}
+		}
+	
+		// Call the Lua function.
+		if (lua_pcall (luaUqm_commState, 0, 1, 0) != 0) {
+			log_add (log_Error, "[script] luaUqm_stringInterpolate(): A "
+					"script error occurred in interpolation %d in string "
+					"'%s': %s.", interI, str,
+					lua_tostring (luaUqm_commState, -1));
+			lua_pop (luaUqm_commState, 1);
+					// Pop the error.
+			continue;
+		}
+		// Success. Result is on the stack.
+
+		// Convert the result to a string, and get the length.
+		part = lua_tolstring (luaUqm_commState, -1, &partLen);
+		if (part == NULL) {
+			// Not a string and not convertable to a string.
+			log_add (log_Error, "[script] luaUqm_stringInterpolate(): Value "
+					"returned by interpolation %d has type %s, which can not "
+					"be converted to a string, in string " "'%s'.",
+					interI, lua_typename(luaUqm_commState,
+					lua_type(luaUqm_commState, -1)), str);
+			lua_pop (luaUqm_commState, 1);
+			continue;
+		}
+
+		// Store the result of the Lua expression in '<% .. %>'.
+		luaUqm_comm_addToBuffer (&buf, &bufLen, &bufPtr, part, partLen);
+
+		// Pop the result from the stack.
+		lua_pop (luaUqm_commState, 1);
+	}
+
+	// Store the part of the string after the last '<% .. %>'.
+	luaUqm_comm_addToBuffer (&buf, &bufLen, &bufPtr,
+			strPtr, strlen (strPtr));
+
+out:
+	*bufPtr = '\0';
+			// luaUqm_addToBuffer() always leaves one byte for the '\0'.
+
+	{
+		char *newBuf = HRealloc (buf, bufPtr - buf + 1);
+		if (newBuf == NULL)
+		{
+			// If we can't shorten 'newBuf', we'll just keep using the
+			// unnecessarilly long 'buf', and let the next allocating
+			// function worry about the impending memory shortage.
+		}
+		else
+			buf = newBuf;
+	}
+
+	return buf;
+}
+
diff -ruNp src.orig/uqm/lua/luacomm.h src/uqm/lua/luacomm.h
--- src.orig/uqm/lua/luacomm.h	1969-12-31 18:00:00 -0600
+++ src/uqm/lua/luacomm.h	2017-11-21 19:39:55 -0600
@@ -0,0 +1,46 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _LUACOMM_H
+#define _LUACOMM_H
+
+#include "libs/compiler.h"
+#include "libs/reslib.h"
+#include "luafuncs/customfuncs.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+BOOLEAN luaUqm_comm_init(const luaUqm_custom_Function *customFuncs,
+		RESOURCE scriptRes);
+void luaUqm_comm_uninit(void);
+
+void luaUqm_comm_genericInit(void);
+void luaUqm_comm_genericPost(void);
+void luaUqm_comm_genericUninit(void);
+
+BOOLEAN luaUqm_comm_stringNeedsInterpolate(const char *str);
+char *luaUqm_comm_stringInterpolate(const char *str);
+
+extern lua_State *luaUqm_commState;
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif  /* _LUACOMM_H */
+
diff -ruNp src.orig/uqm/lua/luadebug.c src/uqm/lua/luadebug.c
--- src.orig/uqm/lua/luadebug.c	1969-12-31 18:00:00 -0600
+++ src/uqm/lua/luadebug.c	2017-11-21 19:39:55 -0600
@@ -0,0 +1,207 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+//#include <stdlib.h>
+//#include <lauxlib.h>
+#include <string.h>
+
+#define LUAUQM_INTERNAL
+#include "port.h"
+#include "luadebug.h"
+
+//#include "libs/scriptlib.h"
+//#include "libs/misc.h"
+#include "uqm/lua/luastate.h"
+#include "luafuncs/commfuncs.h"
+#include "luafuncs/eventfuncs.h"
+#include "luafuncs/logfuncs.h"
+#include "luafuncs/statefuncs.h"
+
+
+#define LINEBUFLEN 2048
+		// Maximum size of one input line.
+		// Long enough for long oneliners.
+
+typedef struct luaUqm_DebugContext {
+	FILE *in;
+	FILE *out;
+	FILE *err;
+	lua_State *debugState;
+} luaUqm_DebugContext;
+
+
+static void luaUqm_debug_interactive(FILE *in, FILE *out, FILE *err);
+static void luaUqm_debug_outputCallback(void *extra,
+		const char *format, ...);
+static void luaUqm_debug_errorCallback(void *extra,
+		const char *format, ...);
+
+
+lua_State *luaUqm_debugState = NULL;
+	
+static const luaL_Reg debugLibs[] = {
+	{ "comm",    luaUqm_comm_open },
+	{ "event",   luaUqm_event_open },
+	{ "log",     luaUqm_log_open },
+	//{ "package", luaUqm_package_open },
+	{ "state",   luaUqm_state_open },
+	{ NULL, NULL }
+};
+
+// Not reentrant.
+// If 'customFuncs' is NULL, no 'custom' table is added to the Lua environment.
+// If 'scriptRes' is NULL_RESOURCE, then no script is loaded. Lua is only
+// available for string interpolation in this case.
+void
+luaUqm_debug_init(void) {
+	assert(luaUqm_debugState == NULL);
+
+	luaUqm_debugState = luaUqm_globalState;
+
+	// Prepare the global environment.
+	luaUqm_prepareEnvironment(luaUqm_debugState);
+	luaUqm_loadLibs(luaUqm_debugState, debugLibs);
+}
+
+void
+luaUqm_debug_uninit(void) {
+	assert(luaUqm_debugState != NULL);
+	luaUqm_debugState = NULL;
+}
+
+void
+luaUqm_debug_run(void) {
+	luaUqm_debug_init();
+
+	luaUqm_debug_interactive(stdin, stdout, stderr);
+
+	luaUqm_debug_uninit();
+}
+
+static void
+luaUqm_debug_interactive(FILE *in, FILE *out, FILE *err) {
+	char lineBuf[LINEBUFLEN];
+	size_t lineLen;
+	luaUqm_DebugContext debugContext;
+	memset(&debugContext, '\0', sizeof (luaUqm_DebugContext));
+	debugContext.in = in;
+	debugContext.out = out;
+	debugContext.err = err;
+	debugContext.debugState = luaUqm_debugState;
+
+	for (;;) {
+		fprintf(out, "> ");
+
+		if (fgets(lineBuf, LINEBUFLEN, in) == NULL) {
+			if (feof(in)) {
+				// user pressed ^D
+				break;
+			}
+			// error occured
+			clearerr(in);
+			continue;
+		}
+		lineLen = strlen(lineBuf);
+		if (lineBuf[lineLen - 1] != '\n' && lineBuf[lineLen - 1] != '\r') {
+			fprintf(err, "Error: Too long command line.\n");
+			// TODO: read until EOL
+			continue;
+		}
+
+		luaUqm_debug_runLine(lineBuf,
+				luaUqm_debug_outputCallback,
+				luaUqm_debug_errorCallback,
+				(void *) &debugContext);
+	}
+}
+
+// Run a Lua command.
+// This function is currently used by luaUqm_debug_interactive, but should
+// also be suitable if we have some graphical console, when different
+// callback functions than luaUqm_debug_outputCallback() and
+// luaUqm_debug_errorCallback are used.
+void
+luaUqm_debug_runLine(const char *exprBuf,
+		void (*outputCallback)(void *extra, const char *format, ...),
+		void (*errorCallback)(void *extra, const char *format, ...),
+		void *extra) {
+	int resultType;
+	const char *resultStr;
+	const char *resultTypeStr;
+
+	// Compile the string to a Lua function.
+	{
+		if (luaL_loadstring (luaUqm_debugState, exprBuf) != LUA_OK) {
+			// An error occurred during parsing.
+			errorCallback(extra, "Syntax error: %s\n",
+					lua_tostring (luaUqm_debugState, -1));
+			lua_pop(luaUqm_debugState, 1);
+					// Pop the error.
+			return;
+		}
+	}
+
+	// Call the Lua function.
+	if (lua_pcall (luaUqm_debugState, 0, 1, 0) != 0) {
+		// An error occurred during execution.
+		errorCallback(extra, "Runtime error: %s\n",
+				lua_tostring (luaUqm_debugState, -1));
+		lua_pop(luaUqm_debugState, 1);
+				// Pop the error.
+		return;
+	}
+	// Success. Result is on the stack.
+
+	// Convert the result to a string.
+	resultType = lua_type(luaUqm_debugState, -1);
+	resultTypeStr = lua_typename(luaUqm_debugState, resultType);
+	resultStr = lua_tolstring (luaUqm_debugState, -1, NULL);
+			// Memory for 'resultStr' lasts until the lua_pop().
+	if (resultStr == NULL) {
+		// Not a string and not convertable to a string.
+		// The command was executed ok though, and we treat this as such.
+		outputCallback(extra, "(%s)\n", resultTypeStr);
+	} else {
+		outputCallback(extra, "(%s) %s\n", resultTypeStr, resultStr);
+	}
+
+	// Pop the result from the stack.
+	lua_pop (luaUqm_debugState, 1);
+}
+
+// Called to output regular output messages.
+static void
+luaUqm_debug_outputCallback(void *extra, const char *format, ...) {
+	va_list args;
+	luaUqm_DebugContext *debugContext = (luaUqm_DebugContext *) extra;
+
+	va_start(args, format);
+	vfprintf(debugContext->out, format, args);
+	va_end(args);
+}
+
+// Called to output error messages.
+static void
+luaUqm_debug_errorCallback(void *extra, const char *format, ...) {
+	va_list args;
+	luaUqm_DebugContext *debugContext = (luaUqm_DebugContext *) extra;
+
+	va_start(args, format);
+	vfprintf(debugContext->err, format, args);
+	va_end(args);
+}
+
+
diff -ruNp src.orig/uqm/lua/luadebug.h src/uqm/lua/luadebug.h
--- src.orig/uqm/lua/luadebug.h	1969-12-31 18:00:00 -0600
+++ src/uqm/lua/luadebug.h	2017-11-21 19:39:55 -0600
@@ -0,0 +1,30 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef LUADEBUG_H
+#define LUADEBUG_H
+
+void luaUqm_debug_init(void);
+void luaUqm_debug_uninit(void);
+void luaUqm_debug_run(void);
+void luaUqm_debug_runLine(const char *exprBuf,
+		void (*outputCallback)(void *extra, const char *format, ...),
+		void (*errorCallback)(void *extra, const char *format, ...),
+		void *extra);
+
+#endif  /* LUADEBUG_H */
+
+
diff -ruNp src.orig/uqm/lua/luaevent.c src/uqm/lua/luaevent.c
--- src.orig/uqm/lua/luaevent.c	1969-12-31 18:00:00 -0600
+++ src/uqm/lua/luaevent.c	2017-11-21 19:39:55 -0600
@@ -0,0 +1,126 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * This file contains code for using Lua for game event scripts.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+
+#define LUAUQM_INTERNAL
+#include "port.h"
+#include "luaevent.h"
+
+#include "options.h"
+		// For contentDir
+#include "libs/scriptlib.h"
+#include "uqm/lua/luastate.h"
+#include "luafuncs/customfuncs.h"
+#include "luafuncs/eventfuncs.h"
+#include "luafuncs/logfuncs.h"
+#include "luafuncs/statefuncs.h"
+#include "libs/log.h"
+
+lua_State *luaUqm_eventState = NULL;
+	
+static const luaL_Reg eventLibs[] = {
+	{ "event", luaUqm_event_open },
+	{ "log",   luaUqm_log_open },
+	{ "state", luaUqm_state_open },
+	{ NULL, NULL }
+};
+
+// Not reentrant.
+BOOLEAN
+luaUqm_event_init(const luaUqm_custom_Function *customFuncs,
+		RESOURCE scriptRes) {
+	char *scriptFileName;
+	BOOLEAN loadOk;
+
+	assert(luaUqm_eventState == NULL);
+
+#ifdef EVENT_DEBUG
+	log_add(log_Debug, "[script] Calling luaUqm_event_init()");
+#endif
+
+	luaUqm_eventState = luaUqm_globalState;
+
+	// Prepare the global environment.
+	luaUqm_prepareEnvironment(luaUqm_eventState);
+	luaUqm_loadLibs(luaUqm_eventState, eventLibs);
+	luaUqm_custom_init(luaUqm_eventState, customFuncs);
+	lua_pop(luaUqm_eventState, 1);
+
+	// Get the name of the script.
+	scriptFileName = LoadScriptInstance(scriptRes);
+	if (scriptFileName == NULL)
+		return FALSE;
+
+	// Load the script.
+	loadOk = luaUqm_loadScript(luaUqm_eventState, contentDir, scriptFileName);
+	ReleaseScriptResData(scriptFileName);
+	if (!loadOk)
+		return FALSE;
+
+	// Call the script.
+	luaUqm_callStackFunction(luaUqm_eventState);
+	return TRUE;
+}
+
+void
+luaUqm_event_uninit(void) {
+	assert(luaUqm_eventState != NULL);
+
+#ifdef EVENT_DEBUG
+	log_add(log_Debug, "[script] Calling luaUqm_event_uninit()");
+#endif
+
+	luaUqm_eventState = NULL;
+}
+
+void
+luaUqm_event_callEvent(const char *eventIdStr) {
+	assert(luaUqm_eventState != NULL);
+
+#ifdef EVENT_DEBUG
+	log_add(log_Debug, "[script] Calling luaUqm_event_callEvent(\"%s\")",
+			eventIdStr);
+#endif
+
+	luaUqm_getEventTable(luaUqm_eventState);
+	lua_pushstring(luaUqm_eventState, eventIdStr);
+	// [-2] -> table eventTable
+	// [-1] -> string eventIdStr
+	lua_gettable(luaUqm_eventState, -2);
+
+	// [-2] -> table eventTable
+	// [-1] -> function eventFun
+	if (lua_isnil(luaUqm_eventState, -1)) {
+		log_add(log_Warning, "[script] Warning: luaUqm_event_callEvent(): "
+				"Event '%s' is not registered.", eventIdStr);
+		lua_pop(luaUqm_eventState, 2);
+		return;
+	}
+
+	// [-2] -> table eventTable
+	// [-1] -> function eventFun
+	lua_replace(luaUqm_eventState, -2);
+
+	// [-1] -> function eventFun
+	luaUqm_callStackFunction(luaUqm_eventState);
+}
+
diff -ruNp src.orig/uqm/lua/luaevent.h src/uqm/lua/luaevent.h
--- src.orig/uqm/lua/luaevent.h	1969-12-31 18:00:00 -0600
+++ src/uqm/lua/luaevent.h	2017-11-21 19:39:55 -0600
@@ -0,0 +1,43 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _LUAEVENT_H
+#define _LUAEVENT_H
+
+//#define EVENT_DEBUG
+
+#include "libs/compiler.h"
+#include "libs/reslib.h"
+#include "luafuncs/customfuncs.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+BOOLEAN luaUqm_event_init(const luaUqm_custom_Function *customFuncs,
+		RESOURCE scriptRes);
+void luaUqm_event_uninit(void);
+
+void luaUqm_event_callEvent(const char *eventIdStr);
+
+extern lua_State *luaUqm_commState;
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif  /* _LUAEVENT_H */
+
diff -ruNp src.orig/uqm/lua/luafuncs/Makeinfo src/uqm/lua/luafuncs/Makeinfo
--- src.orig/uqm/lua/luafuncs/Makeinfo	1969-12-31 18:00:00 -0600
+++ src/uqm/lua/luafuncs/Makeinfo	2017-11-21 19:39:55 -0600
@@ -0,0 +1,2 @@
+uqm_CFILES="commfuncs.c customfuncs.c eventfuncs.c logfuncs.c statefuncs.c"
+uqm_HFILES="commfuncs.h customfuncs.h eventfuncs.h logfuncs.h statefuncs.h"
diff -ruNp src.orig/uqm/lua/luafuncs/README.txt src/uqm/lua/luafuncs/README.txt
--- src.orig/uqm/lua/luafuncs/README.txt	1969-12-31 18:00:00 -0600
+++ src/uqm/lua/luafuncs/README.txt	2017-11-21 19:39:55 -0600
@@ -0,0 +1 @@
+This directory contains bindings exposing UQM functionality to Lua scripts.
diff -ruNp src.orig/uqm/lua/luafuncs/commfuncs.c src/uqm/lua/luafuncs/commfuncs.c
--- src.orig/uqm/lua/luafuncs/commfuncs.c	1969-12-31 18:00:00 -0600
+++ src/uqm/lua/luafuncs/commfuncs.c	2017-11-21 19:39:55 -0600
@@ -0,0 +1,339 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * Right now, the functions to call as a callback for responses are stored
+ * in the Lua registry. This could however also be handled in Lua code
+ * itself: one generic Lua function which is called after a response, which
+ * then calls the appropriate function which was registered for the response
+ * in Lua code.
+ */
+
+#include <stdlib.h>
+
+#define LUAUQM_INTERNAL
+#include "commfuncs.h"
+#include "libs/scriptlib.h"
+#include "libs/log.h"
+
+#include "uqm/lua/luacomm.h"
+#include "uqm/commglue.h"
+#include "uqm/battle.h"
+		// For instantVictory
+
+
+static const char npcPhraseCallbackRegistryKey[] =
+		"uqm_comm_npcPhraseCallback";
+		// Key in the registry storing the callback function for
+		// after an NPC phrase is complete.
+static const char responseCallbackRegistryKey[] =
+		"uqm_comm_responseCallback";
+		// Key in the registry storing a table callback function for
+		// after an NPC phrase is complete.
+
+
+static int luaUqm_comm_isPhraseEnabled(lua_State *luaState);
+static int luaUqm_comm_disablePhrase(lua_State *luaState);
+static int luaUqm_comm_doNpcPhrase(lua_State *luaState);
+static int luaUqm_comm_addResponse(lua_State *luaState);
+static int luaUqm_comm_getPhrase(lua_State *luaState);
+static int luaUqm_comm_getSegue(lua_State *luaState);
+static int luaUqm_comm_setSegue(lua_State *luaState);
+static int luaUqm_comm_isInOuttakes(lua_State *luaState);
+
+static const luaL_Reg commFuncs[] = {
+	{ "addResponse",     luaUqm_comm_addResponse },
+	{ "disablePhrase",   luaUqm_comm_disablePhrase },
+	{ "doNpcPhrase",     luaUqm_comm_doNpcPhrase },
+	{ "getPhrase",       luaUqm_comm_getPhrase },
+	{ "getSegue",        luaUqm_comm_getSegue },
+	{ "isInOuttakes",    luaUqm_comm_isInOuttakes },
+	{ "isPhraseEnabled", luaUqm_comm_isPhraseEnabled },
+	{ "setSegue",        luaUqm_comm_setSegue },
+	{ NULL,              NULL },
+};
+
+static const luaUqm_EnumValue segueEnum[] = {
+	{ /* .name = */ "peace",   /* .value = */ Segue_peace  },
+	{ /* .name = */ "hostile", /* .value = */ Segue_hostile  },
+	{ /* .name = */ "victory", /* .value = */ Segue_victory },
+	{ /* .name = */ "defeat",  /* .value = */ Segue_defeat  },
+	{ /* .name = */ NULL,      /* .value = */ 0             },
+};
+
+int
+luaUqm_comm_open(lua_State *luaState) {
+	luaL_newlib(luaState, commFuncs);
+
+	luaUqm_makeEnum(luaState, segueEnum);
+	// [-2] -> table commTable
+	// [-1] -> table segueEnum
+	lua_setfield(luaState, -2, "segue");
+			// comm.segue = segueEnum
+	
+	// Prepare a table to store the callback functions for each response in.
+	lua_newtable(luaState);
+    lua_setfield(luaState, LUA_REGISTRYINDEX, responseCallbackRegistryKey);
+
+	return 1;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+
+// Helper function. Returns the value of the RESPONSE_REF for the
+// phrase given as a string on stack position [1].
+// If it does not exist, -1 is returned and a warning is printed.
+// [1] -> string phraseIdStr
+static int
+testPhraseId(lua_State *luaState, int argn) {
+	const char *phraseIdStr = luaL_checkstring(luaState, argn);
+	RESPONSE_REF phraseId = phraseIdStrToNum(phraseIdStr);
+	if (phraseId == (RESPONSE_REF) -1) {
+		// TODO: print script file name.
+		log_add(log_Error, "[script] Warning: testPhraseId(): No phrase "
+				"exists with id '%s'.", phraseIdStr);
+		return -1;
+	}
+
+	return (int) phraseId;
+}
+
+// Pushes the string, or nil if the string is not known.
+static void
+pushPhraseId(lua_State *luaState, RESPONSE_REF response) {
+	const char *phraseIdStr = phraseIdNumToStr(response);
+	if (phraseIdStr != NULL) {
+		lua_pushstring(luaState, phraseIdStr);
+	} else {
+		lua_pushnil(luaState);
+	}
+}
+
+// Store a Lua callback function to be called from npcPhraseCallback(),
+// which is used as a callback for NPCPhrase_cb().
+// [n] -> function callback
+static void
+setNpcPhraseCallback(lua_State *luaState, int argn) {
+	lua_pushvalue(luaState, argn);
+    lua_setfield(luaState, LUA_REGISTRYINDEX, npcPhraseCallbackRegistryKey);
+}
+
+// The callback function is pushed on the stack.
+static void
+pushNpcPhraseCallback(lua_State *luaState) {
+    lua_getfield(luaState, LUA_REGISTRYINDEX, npcPhraseCallbackRegistryKey);
+}
+
+static void
+pushResponseCallbackRegistry(lua_State *luaState) {
+    lua_getfield(luaState, LUA_REGISTRYINDEX, responseCallbackRegistryKey);
+}
+
+// [n] -> function callback
+// Store a Lua callback function to be called from responseCallback(),
+// which is used as a callback for Response().
+static void
+setResponseCallback(lua_State *luaState, int responseArgN,
+		int callbackArgN) {
+	pushResponseCallbackRegistry(luaState);
+	// [-1] -> table responseCallbackRegistry
+
+	lua_pushvalue(luaState, responseArgN);
+	lua_pushvalue(luaState, callbackArgN);
+	// [-3] -> table responseCallbackRegistry
+	// [-2] -> string response
+	// [-1] -> function callback
+    lua_settable(luaState, -3);
+	
+	// [-3] -> table responseCallbackRegistry
+	lua_pop(luaState, 1);
+}
+
+// The callback function is pushed on the stack.
+static void
+pushResponseCallback(lua_State *luaState, RESPONSE_REF response) {
+	pushResponseCallbackRegistry(luaState);
+	pushPhraseId(luaState, response);
+	// [-2] -> table responseCallbackRegistry
+	// [-1] -> string response
+	lua_gettable(luaState, -2);
+
+	// [-2] -> table responseCallbackRegistry
+	// [-1] -> function callback
+	lua_replace(luaState, -2);
+	// [-1] -> function callback
+}
+
+// Used as a callback function for NPCPhrase_cb().
+// It in turn calls the registered Lua callback function.
+static void
+npcPhraseCallback(CallbackArg extra) {
+	pushNpcPhraseCallback(luaUqm_commState);
+	if (lua_pcall(luaUqm_commState, 0, 0, 0) != 0) {
+		// An error occurred. We continue nonetheless.
+		log_add(log_Error, "[script] An error occurred during a "
+				"doNpcPhrase() callback: %s",
+				lua_tostring(luaUqm_commState, -1));
+		lua_pop(luaUqm_commState, 1);
+	}
+	(void) extra;
+}
+
+// Used as a callback function for Response().
+// It in turn calls the registered Lua callback function.
+static void
+responseCallback(RESPONSE_REF response) {
+	pushResponseCallback(luaUqm_commState, response);
+	pushPhraseId(luaUqm_commState, response);
+	if (lua_pcall(luaUqm_commState, 1, 0, 0) != 0) {
+		// An error occurred. We continue nonetheless.
+		log_add(log_Error, "[script] An error occurred during an "
+				"addResponse() callback: %s",
+				lua_tostring(luaUqm_commState, -1));
+		lua_pop(luaUqm_commState, 1);
+	}
+}
+
+/////////////////////////////////////////////////////////////////////////////
+
+// [1] -> string phraseIdStr
+static int
+luaUqm_comm_isPhraseEnabled(lua_State *luaState) {
+	int phraseId = testPhraseId(luaState, 1);
+	if (phraseId == -1) {
+		lua_pushboolean(luaState, FALSE);
+		return 1;
+	}
+
+	lua_pushboolean(luaState, PHRASE_ENABLED(phraseId));
+	return 1;
+}
+
+// [1] -> string phraseIdStr
+static int
+luaUqm_comm_disablePhrase(lua_State *luaState) {
+	int phraseId = testPhraseId(luaState, 1);
+	if (phraseId == -1)
+		return 0;
+
+	DISABLE_PHRASE(phraseId);
+	return 0;
+}
+
+// [1] -> string phraseIdStr
+static int
+luaUqm_comm_doNpcPhrase(lua_State *luaState) {
+	CallbackFunction callback;
+	int phraseId = testPhraseId(luaState, 1);
+	if (phraseId == -1)
+		return 0;
+
+	if (lua_gettop(luaState) >= 2) {
+		// Callback function specified in second argument.
+		setNpcPhraseCallback(luaState, 2);
+		callback = npcPhraseCallback;
+	} else {
+		callback = NULL;
+	}
+
+	NPCPhrase_cb(phraseId, callback);
+	return 0;
+}
+
+// [1] -> string phraseIdStr
+// [2] -> function callback
+static int
+luaUqm_comm_addResponse(lua_State *luaState) {
+	int phraseId = testPhraseId(luaState, 1);
+	if (phraseId == -1)
+		return 0;
+
+	luaL_checktype(luaState, 2, LUA_TFUNCTION);
+
+	setResponseCallback(luaState, 1, 2);
+	Response(phraseId, responseCallback);
+	return 0;
+}
+
+// [1] -> string phraseIdStr
+static int
+luaUqm_comm_getPhrase(lua_State *luaState) {
+	int phraseId;
+	STRING str;
+	const char *strBuf;
+
+	phraseId = testPhraseId(luaState, 1);
+	if (phraseId == -1) {
+		// A warning is already printed in testPhraseId().
+		lua_pushnil(luaState);
+		return 1;
+	}
+
+	// Find the string.
+	str = SetAbsStringTableIndex(CommData.ConversationPhrases,
+			phraseId - 1);
+	strBuf = GetStringAddress(str);
+
+	if (luaUqm_comm_stringNeedsInterpolate(strBuf))
+	{
+		char *interpolated = luaUqm_comm_stringInterpolate(strBuf);
+		lua_pushstring(luaState, interpolated);  // This makes a copy.
+		HFree(interpolated);
+	}
+	else
+	{
+		// No interpolation is necessary.
+		lua_pushstring(luaState, strBuf);
+	}
+
+	// [1] -> string phrase
+	return 1;
+}
+
+static int
+luaUqm_comm_getSegue(lua_State *luaState) {
+	int result = getSegue();
+	lua_pushinteger(luaState, result);
+	return 1;
+}
+
+// [1] -> string phraseIdStr
+static int
+luaUqm_comm_setSegue(lua_State *luaState) {
+	int what = luaL_checkint(luaState, 1);
+	switch ((Segue) what) {
+		case Segue_peace:
+		case Segue_hostile:
+		case Segue_victory:
+		case Segue_defeat:
+			break;
+		default:
+			log_add(log_Error, "[script] Warning: setSegue(): Invalid "
+					"parameter value (%d).", what);
+			break;
+	};
+	setSegue((Segue) what);
+
+	return 0;
+}
+
+static int
+luaUqm_comm_isInOuttakes(lua_State *luaState) {
+	BOOLEAN result = (LOBYTE(GLOBAL(CurrentActivity)) == WON_LAST_BATTLE);
+	lua_pushboolean(luaState, result);
+	return 1;
+}
+
diff -ruNp src.orig/uqm/lua/luafuncs/commfuncs.h src/uqm/lua/luafuncs/commfuncs.h
--- src.orig/uqm/lua/luafuncs/commfuncs.h	1969-12-31 18:00:00 -0600
+++ src/uqm/lua/luafuncs/commfuncs.h	2017-11-21 19:39:55 -0600
@@ -0,0 +1,33 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _COMMFUNCS_H
+#define _COMMFUNCS_H
+
+#include "libs/scriptlib.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+int luaUqm_comm_open(lua_State *luaState);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif  /* _COMMFUNCS_H */
+
diff -ruNp src.orig/uqm/lua/luafuncs/customfuncs.c src/uqm/lua/luafuncs/customfuncs.c
--- src.orig/uqm/lua/luafuncs/customfuncs.c	1969-12-31 18:00:00 -0600
+++ src/uqm/lua/luafuncs/customfuncs.c	2017-11-21 19:39:55 -0600
@@ -0,0 +1,92 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <stdlib.h>
+
+#define LUAUQM_INTERNAL
+#include "customfuncs.h"
+#include "libs/scriptlib.h"
+#include "libs/log.h"
+
+
+// We use a wrapper, so that we can call the custom function with the
+// arguments of our choice (i.e. no arguments).
+static int
+luaFunctionWrapper(lua_State *luaState) {
+	int arg;
+	int result;
+	int isNum;
+	int (*fun)(int) = lua_topointer(luaState, lua_upvalueindex(1));
+
+	if (lua_gettop(luaState) == 0) {
+		arg = 0;
+	} else {
+		arg = lua_tointegerx (luaState, -1, &isNum);
+		if (!isNum) {
+			log_add(log_Error, "[script] Warning: luaFunctionWrapper(): "
+					"Invalid type of argument to custom function (%s).",
+					lua_typename(luaState, lua_type(luaState, -1)));
+			// arg will be 0
+		}
+	}
+	
+	result = (*fun)(arg);
+	lua_pushinteger(luaState, result);
+	return 1;
+}
+
+// [-1]  -> table t
+// We keep the actual pointer as an upvalue in the closure.
+static int
+luaUqm_custom_addFunction(lua_State *luaState,
+		const luaUqm_custom_Function *fun) {
+	lua_pushlightuserdata (luaState, (void *) fun->fun);
+	lua_pushcclosure(luaState, luaFunctionWrapper, 1);
+	// [-2] -> table t
+	// [-1] -> function fun
+	lua_setfield(luaState, -2, fun->name);
+	return 1;
+}
+
+// Returns with the new table on the stack.
+int
+luaUqm_custom_init(lua_State *luaState,
+		const luaUqm_custom_Function *funs) {
+	// Count the number of functions.
+	size_t funCount = 0;
+	const luaUqm_custom_Function *ptr;
+
+	for (ptr = funs; ptr->name != NULL; ptr++)
+		funCount++;
+
+	lua_pushglobaltable(luaState);
+
+	// Create a table for 'custom'.
+	lua_createtable(luaState, 0, funCount);
+
+	// Fill the 'custom' table.
+	for (ptr = funs; ptr->name != NULL; ptr++)
+		luaUqm_custom_addFunction(luaState, ptr);
+
+	// Set 'custom' to the custom table.
+	// [-2] -> table globalTable
+	// [-1] -> table custom
+	lua_setfield(luaState, -2, "custom");
+	
+	// [-1] -> table custom
+	return 0;
+}
+
diff -ruNp src.orig/uqm/lua/luafuncs/customfuncs.h src/uqm/lua/luafuncs/customfuncs.h
--- src.orig/uqm/lua/luafuncs/customfuncs.h	1969-12-31 18:00:00 -0600
+++ src/uqm/lua/luafuncs/customfuncs.h	2017-11-21 19:39:55 -0600
@@ -0,0 +1,50 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _CUSTOMFUNCS_H
+#define _CUSTOMFUNCS_H
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+typedef struct luaUqm_custom_Function luaUqm_custom_Function;
+
+#if defined(__cplusplus)
+}
+#endif
+
+#include "libs/scriptlib.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+struct
+luaUqm_custom_Function {
+	const char *name;
+	int (*fun)(int);
+};
+
+int luaUqm_custom_init(lua_State *luaState,
+		const luaUqm_custom_Function *funs);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif  /* CUSTOMFUNCS_H */
+
diff -ruNp src.orig/uqm/lua/luafuncs/eventfuncs.c src/uqm/lua/luafuncs/eventfuncs.c
--- src.orig/uqm/lua/luafuncs/eventfuncs.c	1969-12-31 18:00:00 -0600
+++ src/uqm/lua/luafuncs/eventfuncs.c	2017-11-21 19:39:55 -0600
@@ -0,0 +1,194 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <stdlib.h>
+
+#define LUAUQM_INTERNAL
+#include "eventfuncs.h"
+#include "uqm/clock.h"
+#include "uqm/gameev.h"
+#include "uqm/lua/luastate.h"
+#include "libs/scriptlib.h"
+#include "libs/log.h"
+
+
+static int luaUqm_event_addAbsolute(lua_State *luaState);
+static int luaUqm_event_addRelative(lua_State *luaState);
+static int luaUqm_event_register(lua_State *luaState);
+static int luaUqm_event_unregister(lua_State *luaState);
+
+static const luaL_Reg eventFuncs[] = {
+	{ "addAbsolute", luaUqm_event_addAbsolute },
+	{ "addRelative", luaUqm_event_addRelative },
+	{ "register",    luaUqm_event_register },
+	{ "unregister",  luaUqm_event_unregister },
+	{ NULL,          NULL },
+};
+
+int
+luaUqm_event_open(lua_State *luaState) {
+	luaL_newlib(luaState, eventFuncs);
+
+	return 1;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+
+// argn -> the relative index on the lua stack which contains the Lua
+//         string identifying the event.
+// Returns true if and only if an event is registered.
+static BOOLEAN
+isEventRegistered(lua_State *luaState, int argn)
+{
+	BOOLEAN result;
+	argn = lua_absindex(luaState, argn);
+
+	luaUqm_getEventTable(luaState);
+	lua_pushvalue(luaState, argn);
+	// [-2] -> table eventTable
+	// [-1] -> string eventIdStr
+	lua_gettable(luaState, -2);
+
+	// [-2] -> table eventTable
+	// [-1] -> function eventFun
+	result = !lua_isnil(luaState, -1);
+
+	// [-2] -> table eventTable
+	// [-1] -> function eventFun
+	lua_pop(luaState, 2);
+
+	return result;
+}
+
+// [1] -> int year
+// [2] -> int month
+// [3] -> int day
+// [4] -> string eventIdStr
+// Returns -1 on error, and a different value otherwise (currently 0, but
+// don't rely on this).
+// TODO: make this function return an identifier for the event, so that it
+// can be removed.
+static int
+addEvent(lua_State *luaState, EVENT_TYPE type) {
+	int year = luaL_checkint(luaState, 1);
+	int month = luaL_checkint(luaState, 2);
+	int day = luaL_checkint(luaState, 3);
+	const char *eventIdStr = luaL_checkstring(luaState, 4);
+	int eventNum;
+	HEVENT event;
+
+	if (!isEventRegistered(luaState, 4)) {
+		log_add(log_Warning, "[script] event.%s(): Event '%s' is "
+				"not registered.",
+				(type == RELATIVE_EVENT) ? "addRelative" : "addAbsolute",
+				lua_tostring(luaState, 1));
+		lua_pushinteger(luaState, -1);
+		return 1;
+	}
+	
+	eventNum = eventIdStrToNum(eventIdStr);
+	if (eventNum == -1) {
+		log_add(log_Warning, "[script] event.%s(): Event '%s' is "
+				"not known. It must currently be one of the hard-coded "
+				"strings.",
+				(type == RELATIVE_EVENT) ? "addRelative" : "addAbsolute",
+				lua_tostring(luaState, 1));
+		lua_pushinteger(luaState, -1);
+		return 1;
+	}
+
+	event = AddEvent(type, month, day, year, eventNum);
+	lua_pushinteger(luaState, (event == NULL) ? -1 : 0);
+	return 1;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+
+// [1] -> int year
+// [2] -> int month
+// [3] -> int day
+// [4] -> string eventIdStr
+// TODO: make this function return an identifier for the event, so that it
+// can be removed.
+static int
+luaUqm_event_addAbsolute(lua_State *luaState) {
+	return addEvent(luaState, ABSOLUTE_EVENT);
+}
+
+// [1] -> int years
+// [2] -> int months
+// [3] -> int days
+// [4] -> string eventIdStr
+// Returns -1 on error, and 0 otherwise.
+// TODO: make this function return an identifier for the event, so that it
+// can be removed.
+static int
+luaUqm_event_addRelative(lua_State *luaState) {
+	return addEvent(luaState, RELATIVE_EVENT);
+}
+
+// [1] -> string eventIdStr
+// [2] -> function eventFun
+static int
+luaUqm_event_register(lua_State *luaState) {
+	(void) luaL_checkstring(luaState, 1);
+	luaL_checktype(luaState, 2, LUA_TFUNCTION);
+
+	if (isEventRegistered(luaState, 1)) {
+		log_add(log_Warning, "[script] event.register(): Event '%s' is "
+				"already registered.", lua_tostring(luaState, 1));
+		return 0;
+	}
+	
+	luaUqm_getEventTable(luaState);
+	lua_pushvalue(luaState, 1);
+	lua_pushvalue(luaState, 2);
+	// [-3] -> table eventTable
+	// [-2] -> string eventIdStr
+	// [-1] -> function eventFun
+	lua_settable(luaState, -3);
+
+	// [-1] -> table eventTable
+	lua_pop(luaState, 1);
+
+	return 0;
+}
+
+// [1] -> string eventIdStr
+static int
+luaUqm_event_unregister(lua_State *luaState) {
+	(void) luaL_checkstring(luaState, 1);
+
+	if (!isEventRegistered(luaState, 1)) {
+		log_add(log_Warning, "[script] event.unregister(): Event '%s' was "
+				"not registered.", lua_tostring(luaState, 1));
+		return 0;
+	}
+	
+	luaUqm_getEventTable(luaState);
+	lua_pushvalue(luaState, 1);
+	lua_pushnil(luaState);
+	// [-3] -> table eventTable
+	// [-2] -> string eventIdStr
+	// [-1] -> nil
+	lua_settable(luaState, -3);
+
+	// [-1] -> table eventTable
+	lua_pop(luaState, 1);
+
+	return 0;
+}
+
diff -ruNp src.orig/uqm/lua/luafuncs/eventfuncs.h src/uqm/lua/luafuncs/eventfuncs.h
--- src.orig/uqm/lua/luafuncs/eventfuncs.h	1969-12-31 18:00:00 -0600
+++ src/uqm/lua/luafuncs/eventfuncs.h	2017-11-21 19:39:55 -0600
@@ -0,0 +1,33 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _EVENTFUNCS_H
+#define _EVENTFUNCS_H
+
+#include "libs/scriptlib.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+int luaUqm_event_open(lua_State *luaState);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif  /* _EVENTFUNCS_H */
+
diff -ruNp src.orig/uqm/lua/luafuncs/logfuncs.c src/uqm/lua/luafuncs/logfuncs.c
--- src.orig/uqm/lua/luafuncs/logfuncs.c	1969-12-31 18:00:00 -0600
+++ src/uqm/lua/luafuncs/logfuncs.c	2017-11-21 19:39:55 -0600
@@ -0,0 +1,82 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define LUAUQM_INTERNAL
+#include "logfuncs.h"
+#include "libs/scriptlib.h"
+#include "libs/log.h"
+
+static int luaUqm_log_debug (lua_State *luaState);
+static int luaUqm_log_error (lua_State *luaState);
+static int luaUqm_log_fatal (lua_State *luaState);
+static int luaUqm_log_info (lua_State *luaState);
+static int luaUqm_log_warn (lua_State *luaState);
+
+static const luaL_Reg logFuncs[] = {
+	{ "debug", luaUqm_log_debug },
+	{ "error", luaUqm_log_error },
+	{ "fatal", luaUqm_log_fatal },
+	{ "info",  luaUqm_log_info },
+	{ "warn",  luaUqm_log_warn },
+	{ NULL,    NULL },
+};
+
+int
+luaUqm_log_open(lua_State *luaState) {
+	luaL_newlib(luaState, logFuncs);
+	return 1;
+}
+
+// [1] -> string logMessage
+static int
+logHelper(lua_State *luaState, log_Level level) {
+	//const char *str = luaL_checkstring(luaState, 1);
+	const char *str = lua_tostring(luaState, 1);
+	// TODO: print the file name of the Lua script being executed.
+	log_add(level, "Lua: %s", str);
+	return 0;
+}
+
+// [1] -> string logMessage
+static int
+luaUqm_log_debug (lua_State *luaState) {
+	return logHelper(luaState, log_Debug);
+}
+
+// [1] -> string logMessage
+static int
+luaUqm_log_error (lua_State *luaState) {
+	return logHelper(luaState, log_Error);
+}
+
+// [1] -> string logMessage
+static int
+luaUqm_log_fatal (lua_State *luaState) {
+	return logHelper(luaState, log_Fatal);
+}
+
+// [1] -> string logMessage
+static int
+luaUqm_log_info (lua_State *luaState) {
+	return logHelper(luaState, log_Info);
+}
+
+// [1] -> string logMessage
+static int
+luaUqm_log_warn (lua_State *luaState) {
+	return logHelper(luaState, log_Warning);
+}
+
diff -ruNp src.orig/uqm/lua/luafuncs/logfuncs.h src/uqm/lua/luafuncs/logfuncs.h
--- src.orig/uqm/lua/luafuncs/logfuncs.h	1969-12-31 18:00:00 -0600
+++ src/uqm/lua/luafuncs/logfuncs.h	2017-11-21 19:39:55 -0600
@@ -0,0 +1,32 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _LOGFUNCS_H
+#define _LOGFUNCS_H
+
+#include "libs/scriptlib.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+int luaUqm_log_open(lua_State *luaState);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif  /* _LOGFUNCS_H */
diff -ruNp src.orig/uqm/lua/luafuncs/statefuncs.c src/uqm/lua/luafuncs/statefuncs.c
--- src.orig/uqm/lua/luafuncs/statefuncs.c	1969-12-31 18:00:00 -0600
+++ src/uqm/lua/luafuncs/statefuncs.c	2017-11-21 19:39:55 -0600
@@ -0,0 +1,545 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <stdlib.h>
+
+#define LUAUQM_INTERNAL
+#include "statefuncs.h"
+#include "libs/scriptlib.h"
+#include "libs/log.h"
+
+#include "uqm/build.h"
+#include "uqm/globdata.h"
+#include "uqm/lua/luastate.h"
+
+
+static int luaUqm_state_clock_getDate(lua_State *luaState);
+static int luaUqm_state_escort_addShips(lua_State *luaState);
+static int luaUqm_state_escort_canAddShips(lua_State *luaState);
+static int luaUqm_state_escort_removeShips (lua_State *luaState);
+static int luaUqm_state_escort_shipCount(lua_State *luaState);
+static int luaUqm_state_escort_totalValue(lua_State *luaState);
+static int luaUqm_state_race_isAlive(lua_State *luaState);
+static int luaUqm_state_race_isAllied(lua_State *luaState);
+static int luaUqm_state_race_isKnown(lua_State *luaState);
+static int luaUqm_state_race_setAlive(lua_State *luaState);
+static int luaUqm_state_race_setAllied(lua_State *luaState);
+static int luaUqm_state_race_setKnown(lua_State *luaState);
+static int luaUqm_state_sis_addCrew(lua_State *luaState);
+static int luaUqm_state_sis_addFuel(lua_State *luaState);
+static int luaUqm_state_sis_addLanders(lua_State *luaState);
+static int luaUqm_state_sis_addResUnits(lua_State *luaState);
+static int luaUqm_state_sis_getCaptainName(lua_State *luaState);
+static int luaUqm_state_sis_getCrew(lua_State *luaState);
+static int luaUqm_state_sis_getFuel(lua_State *luaState);
+static int luaUqm_state_sis_getLanders(lua_State *luaState);
+static int luaUqm_state_sis_getResUnits(lua_State *luaState);
+static int luaUqm_state_sis_getShipName(lua_State *luaState);
+static int luaUqm_state_prop_get(lua_State *luaState);
+static int luaUqm_state_prop_set(lua_State *luaState);
+
+static const luaL_Reg stateClockFuncs[] = {
+	{ "getDate",         luaUqm_state_clock_getDate },
+	{ NULL,              NULL },
+};
+
+static const luaL_Reg stateEscortFuncs[] = {
+	{ "addShips",        luaUqm_state_escort_addShips },
+	{ "canAddShips",     luaUqm_state_escort_canAddShips },
+	{ "removeShips",     luaUqm_state_escort_removeShips },
+	{ "shipCount",       luaUqm_state_escort_shipCount },
+	{ "totalValue",      luaUqm_state_escort_totalValue },
+	{ NULL,              NULL },
+};
+
+static const luaL_Reg statePropFuncs[] = {
+	{ "get",             luaUqm_state_prop_get },
+	{ "set",             luaUqm_state_prop_set },
+	{ NULL,              NULL },
+};
+
+static const luaL_Reg stateRaceFuncs[] = {
+	{ "isAlive",         luaUqm_state_race_isAlive },
+	{ "isAllied",        luaUqm_state_race_isAllied },
+	{ "isKnown",         luaUqm_state_race_isKnown },
+	{ "setAlive",        luaUqm_state_race_setAlive },
+	{ "setAllied",       luaUqm_state_race_setAllied },
+	{ "setKnown",        luaUqm_state_race_setKnown },
+	{ NULL,              NULL },
+};
+
+static const luaL_Reg stateSisFuncs[] = {
+	{ "addCrew",         luaUqm_state_sis_addCrew },
+	{ "addFuel",         luaUqm_state_sis_addFuel },
+	{ "addLanders",      luaUqm_state_sis_addLanders },
+	{ "addResUnits",     luaUqm_state_sis_addResUnits },
+	{ "getCaptainName",  luaUqm_state_sis_getCaptainName },
+	{ "getCrew",         luaUqm_state_sis_getCrew },
+	{ "getFuel",         luaUqm_state_sis_getFuel },
+	{ "getLanders",      luaUqm_state_sis_getLanders },
+	{ "getResUnits",     luaUqm_state_sis_getResUnits },
+	{ "getShipName",     luaUqm_state_sis_getShipName },
+	{ NULL,              NULL },
+};
+
+int
+luaUqm_state_open(lua_State *luaState) {
+	// Create a table on the stack with space reserved for five fields.
+	lua_createtable(luaState, 0, 5);
+
+	luaL_newlib(luaState, stateClockFuncs);
+	lua_setfield(luaState, -2, "clock");
+	
+	luaL_newlib(luaState, stateEscortFuncs);
+	lua_setfield(luaState, -2, "escort");
+	
+	luaL_newlib(luaState, statePropFuncs);
+	lua_setfield(luaState, -2, "prop");
+
+	luaL_newlib(luaState, stateRaceFuncs);
+	lua_setfield(luaState,  -2,"race");
+
+	luaL_newlib(luaState, stateSisFuncs);
+	lua_setfield(luaState, -2, "sis");
+
+	return 1;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+
+// Helper function. Returns an index for the race in the avail_race_q
+// for the race given as a string on stack position [1].
+// If it does not exist, -1 is returned and a warning is printed.
+// [1] -> string raceIdStr
+static COUNT
+testRaceId(lua_State *luaState, int argn) {
+	const char *raceIdStr = luaL_checkstring(luaState, argn);
+	COUNT raceId = RaceIdStrToIndex(raceIdStr);
+	if (raceId == (COUNT) -1) {
+		// TODO: print script file name.
+		log_add(log_Error, "[script] Warning: testRaceId(): No race exists "
+				"with id '%s'.", raceIdStr);
+		return (COUNT) -1;
+	}
+
+	return (COUNT) raceId;
+}
+
+// Helper function. Returns an index for the ship in the avail_race_q
+// for the ship given as a string on stack position [1].
+// If it does not exist, -1 is returned and a warning is printed.
+// [1] -> string shipIdStr
+static COUNT
+testShipId(lua_State *luaState, int argn) {
+	const char *shipIdStr = luaL_checkstring(luaState, argn);
+	COUNT shipId = ShipIdStrToIndex(shipIdStr);
+	if (shipId == (COUNT) -1) {
+		// TODO: print script file name.
+		log_add(log_Error, "[script] Warning: testShipId(): No ship exists "
+				"with id '%s'.", shipIdStr);
+		return (COUNT) -1;
+	}
+
+	return (COUNT) shipId;
+}
+
+#if 0
+// Pushes the string, or nil if the string is not known.
+static void
+pushRaceId(lua_State *luaState, COUNT raceId) {
+	const char *raceIdStr = raceIdNumToStr(raceId);
+	if (raceIdStr != NULL) {
+		lua_pushstring(luaState, raceIdStr);
+	} else {
+		lua_pushnil(luaState);
+	}
+}
+#endif
+
+/////////////////////////////////////////////////////////////////////////////
+
+// Returns a table with the fields 'year', 'month', and 'day'.
+static int
+luaUqm_state_clock_getDate(lua_State *luaState) {
+	// Create a table on the stack with space reserved for 3 fields.
+	lua_createtable(luaState, 0, 3);
+
+	lua_pushinteger(luaState, GLOBAL(GameClock.year_index));
+	lua_setfield(luaState, -2, "year");
+	
+	lua_pushinteger(luaState, GLOBAL(GameClock.month_index));
+	lua_setfield(luaState, -2, "month");
+
+	lua_pushinteger(luaState, GLOBAL(GameClock.day_index));
+	lua_setfield(luaState, -2, "day");
+
+	return 1;
+}
+
+// [1] -> string shipIdStr
+// [2] -> int count
+static int
+luaUqm_state_escort_addShips(lua_State *luaState) {
+	COUNT shipId;
+	int count;
+	int numAdded;
+
+	shipId = testShipId(luaState, 1);
+	if (shipId == (COUNT) -1) {
+		lua_pushboolean(luaState, FALSE);
+		return 1;
+	}
+
+	count = luaL_checkint(luaState, 2);
+
+	numAdded = AddEscortShips(shipId, count);
+	lua_pushinteger(luaState, numAdded);
+	return 1;
+}
+
+// [1] -> string shipIdStr
+static int
+luaUqm_state_escort_canAddShips(lua_State *luaState) {
+	COUNT shipId;
+	int result;
+
+	shipId = testShipId(luaState, 1);
+	if (shipId == (COUNT) -1) {
+		lua_pushboolean(luaState, FALSE);
+		return 1;
+	}
+
+	result = EscortFeasibilityStudy(shipId);
+	lua_pushinteger(luaState, result);
+	return 1;
+}
+
+// [1] -> string shipIdStr
+// [2] -> int count
+static int
+luaUqm_state_escort_removeShips(lua_State *luaState) {
+	COUNT shipId;
+	int numRemoved;
+
+	shipId = testShipId(luaState, 1);
+	if (shipId == (COUNT) -1) {
+		lua_pushboolean(luaState, FALSE);
+		return 1;
+	}
+
+	if (lua_isnil(luaState, 2)) {
+		numRemoved = RemoveEscortShips(shipId);
+	} else {
+		int count = luaL_checkint(luaState, 2);
+		numRemoved = RemoveSomeEscortShips(shipId, count);
+	}
+
+	lua_pushinteger(luaState, numRemoved);
+	return 1;
+}
+
+// [1] -> string shipIdStr
+static int
+luaUqm_state_escort_shipCount(lua_State *luaState) {
+	COUNT shipId;
+	int result;
+
+	shipId = testShipId(luaState, 1);
+	if (shipId == (COUNT) -1) {
+		lua_pushboolean(luaState, FALSE);
+		return 1;
+	}
+
+	result = CountEscortShips(shipId);
+	lua_pushinteger(luaState, result);
+	return 1;
+}
+
+// No arguments
+static int
+luaUqm_state_escort_totalValue(lua_State *luaState) {
+	COUNT result = CalculateEscortsWorth();
+	lua_pushinteger(luaState, result);
+	return 1;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+
+// [1] -> string raceIdStr
+static int
+luaUqm_state_race_isAlive(lua_State *luaState) {
+	COUNT raceId;
+	BOOLEAN result;
+
+	raceId = testRaceId(luaState, 1);
+	if (raceId == (COUNT) -1) {
+		lua_pushboolean(luaState, FALSE);
+		return 1;
+	}
+
+	result = (CheckAlliance(raceId) != DEAD_GUY);
+	lua_pushboolean(luaState, result);
+	return 1;
+}
+
+// [1] -> string raceIdStr
+static int
+luaUqm_state_race_isAllied(lua_State *luaState) {
+	COUNT raceId;
+	BOOLEAN result;
+
+	raceId = testRaceId(luaState, 1);
+	if (raceId == (COUNT) -1) {
+		lua_pushboolean(luaState, FALSE);
+		return 1;
+	}
+
+	result = (CheckAlliance(raceId) == GOOD_GUY);
+	lua_pushboolean(luaState, result);
+	return 1;
+}
+
+// [1] -> string raceIdStr
+// Note that if a race has no SoI, this function will return false.
+static int
+luaUqm_state_race_isKnown(lua_State *luaState) {
+	COUNT raceId;
+	BOOLEAN result;
+
+	raceId = testRaceId(luaState, 1);
+	if (raceId == (COUNT) -1) {
+		lua_pushboolean(luaState, FALSE);
+		return 1;
+	}
+
+	result = CheckSphereTracking(raceId);
+	lua_pushboolean(luaState, result);
+	return 1;
+}
+
+// [1] -> string raceIdStr
+// [2] -> boolean flag
+static int
+luaUqm_state_race_setAlive(lua_State *luaState) {
+	COUNT raceId;
+	int flag;
+	BOOLEAN result;
+
+	raceId = testRaceId(luaState, 1);
+	if (raceId == (COUNT) -1) {
+		lua_pushboolean(luaState, FALSE);
+		return 1;
+	}
+
+	flag = lua_toboolean(luaState, 2);
+	if (flag != 0) {
+		log_add(log_Error, "[script] Warning: luaUqm_state_race_setAlive(): "
+				"setAlive(true) is not implemented.");
+		lua_pushboolean(luaState, FALSE);
+		return 1;
+	}
+
+	result = KillRace(raceId);
+	lua_pushboolean(luaState, result);
+	return 1;
+}
+
+// [1] -> string raceIdStr
+// [2] -> boolean flag
+static int
+luaUqm_state_race_setAllied(lua_State *luaState) {
+	COUNT raceId;
+	int flag;
+	BOOLEAN result;
+
+	raceId = testRaceId(luaState, 1);
+	if (raceId == (COUNT) -1) {
+		lua_pushboolean(luaState, FALSE);
+		return 1;
+	}
+
+	flag = lua_toboolean(luaState, 2);
+
+	result = SetRaceAllied(raceId, flag);
+	lua_pushboolean(luaState, result);
+	return 1;
+}
+
+// [1] -> string raceIdStr
+// [2] -> boolean flag
+static int
+luaUqm_state_race_setKnown(lua_State *luaState) {
+	COUNT raceId;
+	int flag;
+	BOOLEAN result;
+
+	raceId = testRaceId(luaState, 1);
+	if (raceId == (COUNT) -1) {
+		lua_pushboolean(luaState, FALSE);
+		return 1;
+	}
+
+	flag = lua_toboolean(luaState, 2);
+	if (flag == 0) {
+		log_add(log_Error, "[script] Warning: luaUqm_state_race_setKnown(): "
+				"setKnown(false) is not implemented.");
+		lua_pushboolean(luaState, FALSE);
+		return 1;
+	}
+
+	result = (StartSphereTracking(raceId) != 0);
+	lua_pushboolean(luaState, result);
+	return 1;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+
+// [1] -> int delta
+static int
+luaUqm_state_sis_addCrew(lua_State *luaState) {
+	int delta;
+	COUNT oldCrew;
+	COUNT newCrew;
+	
+	delta = luaL_checkint(luaState, 1);
+
+	oldCrew = GLOBAL_SIS(CrewEnlisted);
+	DeltaSISGauges(delta, 0, 0);
+	newCrew = GLOBAL_SIS(CrewEnlisted);
+
+	lua_pushinteger(luaState, newCrew - oldCrew);
+	return 1;
+}
+
+// [1] -> int delta
+static int
+luaUqm_state_sis_addFuel(lua_State *luaState) {
+	int delta;
+	COUNT oldFuel;
+	COUNT newFuel;
+	
+	delta = luaL_checkint(luaState, 1);
+
+	oldFuel = GLOBAL_SIS(FuelOnBoard);
+	DeltaSISGauges(0, delta, 0);
+	newFuel = GLOBAL_SIS(FuelOnBoard);
+
+	lua_pushinteger(luaState, newFuel - oldFuel);
+	return 1;
+}
+
+// [1] -> int delta
+static int
+luaUqm_state_sis_addLanders(lua_State *luaState) {
+	int delta;
+	int oldCount;
+	int newCount;
+	
+	delta = luaL_checkint(luaState, 1);
+
+	oldCount = GLOBAL_SIS(NumLanders);
+	newCount = oldCount + delta;
+	if (newCount < 0) {
+		newCount = 0;
+	} else if (newCount > MAX_LANDERS) {
+		newCount = MAX_LANDERS;
+	}
+
+	if (newCount != oldCount)
+	{
+		GLOBAL_SIS(NumLanders) = newCount;
+		DrawLanders();
+	}
+
+	lua_pushinteger(luaState, newCount - oldCount);
+	return 1;
+}
+
+// [1] -> int delta
+static int
+luaUqm_state_sis_addResUnits(lua_State *luaState) {
+	int delta;
+	COUNT oldResUnits;
+	COUNT newResUnits;
+	
+	delta = luaL_checkint(luaState, 1);
+
+	oldResUnits = GLOBAL_SIS(ResUnits);
+	DeltaSISGauges(0, delta, 0);
+	newResUnits = GLOBAL_SIS(ResUnits);
+
+	lua_pushinteger(luaState, newResUnits - oldResUnits);
+	return 1;
+}
+
+static int
+luaUqm_state_sis_getCaptainName(lua_State *luaState) {
+	lua_pushstring(luaState, GLOBAL_SIS (CommanderName));
+	return 1;
+}
+
+static int
+luaUqm_state_sis_getCrew(lua_State *luaState) {
+	lua_pushinteger(luaState, GLOBAL_SIS (CrewEnlisted));
+	return 1;
+}
+
+static int
+luaUqm_state_sis_getFuel(lua_State *luaState) {
+	lua_pushinteger(luaState, GLOBAL_SIS (FuelOnBoard));
+	return 1;
+}
+
+static int
+luaUqm_state_sis_getResUnits(lua_State *luaState) {
+	lua_pushinteger(luaState, GLOBAL_SIS (ResUnits));
+	return 1;
+}
+
+static int
+luaUqm_state_sis_getLanders(lua_State *luaState) {
+	lua_pushinteger(luaState, GLOBAL_SIS (NumLanders));
+	return 1;
+}
+
+static int
+luaUqm_state_sis_getShipName(lua_State *luaState) {
+	lua_pushstring(luaState, GLOBAL_SIS (ShipName));
+	return 1;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+
+// [1] -> int name
+static int
+luaUqm_state_prop_get(lua_State *luaState) {
+	luaL_checktype(luaState, 1, LUA_TSTRING);
+
+	luaUqm_getProp(luaState, 1);
+	return 1;
+}
+
+// [1] -> int name
+// [2] -> int|bool|string value
+static int
+luaUqm_state_prop_set(lua_State *luaState) {
+	luaL_checktype(luaState, 1, LUA_TSTRING);
+	luaUqm_checkPropValueType(luaState, "state.prop.set", 2);
+
+	luaUqm_setProp(luaState, 1, 2);
+	return 0;
+}
+
diff -ruNp src.orig/uqm/lua/luafuncs/statefuncs.h src/uqm/lua/luafuncs/statefuncs.h
--- src.orig/uqm/lua/luafuncs/statefuncs.h	1969-12-31 18:00:00 -0600
+++ src/uqm/lua/luafuncs/statefuncs.h	2017-11-21 19:39:55 -0600
@@ -0,0 +1,32 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _STATEUNCS_H
+#define _STATEUNCS_H
+
+#include "libs/scriptlib.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+int luaUqm_state_open(lua_State *luaState);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif  /* _STATEUNCS_H */
diff -ruNp src.orig/uqm/lua/luainit.c src/uqm/lua/luainit.c
--- src.orig/uqm/lua/luainit.c	1969-12-31 18:00:00 -0600
+++ src/uqm/lua/luainit.c	2017-11-21 19:39:56 -0600
@@ -0,0 +1,61 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * This file contains code for running scripts when a new game is started
+ * or an old game is loaded.
+ */
+
+#define LUAUQM_INTERNAL
+#include "port.h"
+#include "luacomm.h"
+
+#include "luainit.h"
+#include "options.h"
+		// for contentDir
+#include "uqm/resinst.h"
+#include "uqm/lua/luastate.h"
+#include "luafuncs/eventfuncs.h"
+#include "luafuncs/logfuncs.h"
+#include "luafuncs/statefuncs.h"
+#include "libs/log.h"
+
+static const luaL_Reg initLibs[] = {
+	{ "event",  luaUqm_event_open },
+	{ "log",    luaUqm_log_open },
+	{ "state",  luaUqm_state_open },
+	{ NULL, NULL }
+};
+
+void
+luaUqm_runInitScripts(void) {
+	const char *scriptDir;
+
+	// Set up an environment and run the init scripts in this environment.
+	// Note that the environment will not be used after this; when a script
+	// is run for eg. communication, a new environment will be set up.
+	luaUqm_prepareEnvironment(luaUqm_globalState);
+	luaUqm_loadLibs(luaUqm_globalState, initLibs);
+
+	scriptDir = res_GetString (SCRIPT_DIR_INITGAME);
+	if (scriptDir == NULL) {
+		log_add(log_Warning, "Location of game initialisation scripts ('%s')"
+				" was not specified.", SCRIPT_DIR_INITGAME);
+	} else {
+		luaUqm_runLuaDir(luaUqm_globalState, contentDir, scriptDir);
+	}
+}
+
diff -ruNp src.orig/uqm/lua/luainit.h src/uqm/lua/luainit.h
--- src.orig/uqm/lua/luainit.h	1969-12-31 18:00:00 -0600
+++ src/uqm/lua/luainit.h	2017-11-21 19:39:56 -0600
@@ -0,0 +1,33 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _LUAINIT_H
+#define _LUAINIT_H
+
+#include "libs/compiler.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+void luaUqm_runInitScripts(void);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif  /* _LUAINIT_H */
+
diff -ruNp src.orig/uqm/lua/luastate.c src/uqm/lua/luastate.c
--- src.orig/uqm/lua/luastate.c	1969-12-31 18:00:00 -0600
+++ src/uqm/lua/luastate.c	2017-11-21 19:39:56 -0600
@@ -0,0 +1,217 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * This file contains code for connecting storing the game state in Lua.
+ */
+
+#include "luastate.h"
+#include "luainit.h"
+#include "uqm/globdata.h"
+#include "libs/log.h"
+#include "libs/scriptlib.h"
+
+
+// We store the game state in the global Lua context, in the Lua registry.
+
+static void luaUqm_initStatePropertyTable(lua_State *luaState);
+static void luaUqm_initEventTable(lua_State *luaState);
+
+lua_State *luaUqm_globalState = NULL;
+static const char statePropRegistryKey[] =
+		"uqm_state_prop_registryKey";
+static const char eventRegistryKey[] =
+		"uqm_event_registryKey";
+
+
+// Init the global Lua state. Called at the start of the main loop.
+void
+luaUqm_initState(void) {
+	if (luaUqm_globalState != NULL) {
+		log_add(log_Warning, "Lua state multiply uninitialized");
+		luaUqm_uninitState ();
+	}
+	luaUqm_globalState = luaL_newstate();
+	luaUqm_initStatePropertyTable(luaUqm_globalState);
+	luaUqm_initEventTable(luaUqm_globalState);
+
+	// XXX TODO: set up an alternative to the Lua 'require' function,
+	// which makes use of uio.
+
+	luaUqm_runInitScripts();
+}
+
+// Uninit the global Lua state.
+void
+luaUqm_uninitState(void) {
+	if (luaUqm_globalState != NULL) {
+		lua_close(luaUqm_globalState);
+		luaUqm_globalState = NULL;
+	} else {
+		log_add(log_Warning, "Lua state multiply uninitialized");
+	}
+}
+
+// Reinit the global Lua state. This does nothing that initState doesn't
+// do, but unlike initState it warns only if you call it without having
+// old data to dispose of. Called at the start of a new game, or when a
+// game is loaded.
+
+void
+luaUqm_reinitState(void) {
+	if (luaUqm_globalState == NULL) {
+		log_add(log_Warning, "Lua state reinitialized while NULL");
+	} else {
+		luaUqm_uninitState ();
+	}
+	luaUqm_initState ();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Game state
+/////////////////////////////////////////////////////////////////////////////
+
+static void
+luaUqm_initStatePropertyTable(lua_State *luaState)
+{
+	lua_pushstring(luaState, statePropRegistryKey);
+	lua_newtable(luaState);
+	lua_settable(luaState, LUA_REGISTRYINDEX);
+}
+
+// Check whether a lua value has a type acceptable as a property value.
+int
+luaUqm_checkPropValueType(lua_State *luaState, const char *funName,
+		int nameIndex) {
+	int type = lua_type(luaState, nameIndex);
+	switch (type) {
+		case LUA_TNUMBER:
+		case LUA_TBOOLEAN:
+		case LUA_TSTRING:
+			// Ok
+			return 0;
+		default: {
+			const char *typeName = lua_typename(luaState, nameIndex);
+			return luaL_error(luaState, "Property value has an invalid "
+					"type, in parameter to %s() (%s)", funName, typeName);
+		}
+	}
+}
+
+// Set the value of the property with the name on the stack on position
+// 'nameIndex' to the value on the stack with index 'valueIndex'.
+// Pre: nameIndex points to a string, and valueIndex points to a valid
+// value.
+void
+luaUqm_setProp(lua_State *luaState, int nameIndex, int valueIndex) {
+	nameIndex = lua_absindex(luaState, nameIndex);
+	valueIndex = lua_absindex(luaState, valueIndex);
+
+	lua_getfield(luaState, LUA_REGISTRYINDEX, statePropRegistryKey);
+	lua_pushvalue(luaState, nameIndex);
+	lua_pushvalue(luaState, valueIndex);
+	// [-3] -> registry[statePropRegistrykey]
+	// [-2] -> name
+	// [-1] -> value
+	lua_settable(luaState, -3);
+	// [-1] -> registry[statePropRegistrykey]
+	lua_pop(luaState, 1);
+}
+
+// Get the value of the property with the name on the stack on position
+// 'nameIndex'.
+// Pushes the property value on the stack.
+// Pre: nameIndex points to a string.
+void
+luaUqm_getProp(lua_State *luaState, int nameIndex) {
+	nameIndex = lua_absindex(luaState, nameIndex);
+
+	lua_getfield(luaState, LUA_REGISTRYINDEX, statePropRegistryKey);
+	// [-1] -> registry[statePropRegistrykey]
+	lua_pushvalue(luaState, nameIndex);
+	// [-2] -> registry[statePropRegistrykey]
+	// [-1] -> name
+	lua_gettable(luaState, -2);
+	// [-2] -> registry[statePropRegistrykey]
+	// [-1] -> registry[statePropRegistrykey][name]
+	lua_replace(luaState, -2);
+	// [-1] -> registry[statePropRegistrykey][name]
+}
+
+void
+setGameStateUint(const char *name, DWORD val)
+{
+	lua_pushstring(luaUqm_globalState, name);
+	lua_pushinteger(luaUqm_globalState, val);
+	luaUqm_setProp(luaUqm_globalState, -2, -1);
+	lua_pop(luaUqm_globalState, 2);
+
+#ifdef STATE_DEBUG
+	log_add(log_Debug, "State '%s' set to %u.", name, val);
+#endif
+}
+
+DWORD
+getGameStateUint(const char *name)
+{
+	DWORD result;
+	int resultType;
+
+	lua_pushstring(luaUqm_globalState, name);
+	luaUqm_getProp(luaUqm_globalState, -1);
+	// [-2] -> name
+	// [-1] -> propValue
+
+	resultType = lua_type(luaUqm_globalState, -1);
+	switch (resultType) {
+		case LUA_TNIL:
+			// Unitialised properties are 0.
+			lua_pop(luaUqm_globalState, 2);
+			return 0;
+		case LUA_TNUMBER:
+			// Ok.
+			break;
+		default:
+			log_add(log_Error, "Warning: getGameState(): property '%s' has "
+					"a non-number value (%s).", name,
+					lua_typename(luaUqm_globalState, -1));
+			lua_pop(luaUqm_globalState, 2);
+			return 0;
+	}
+
+	result = (DWORD) lua_tointeger(luaUqm_globalState, -1);
+	lua_pop(luaUqm_globalState, 2);
+	return result;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Game events
+/////////////////////////////////////////////////////////////////////////////
+
+static void
+luaUqm_initEventTable(lua_State *luaState)
+{
+	lua_pushstring(luaState, eventRegistryKey);
+	lua_newtable(luaState);
+	lua_settable(luaState, LUA_REGISTRYINDEX);
+}
+
+void
+luaUqm_getEventTable(lua_State *luaState)
+{
+	lua_getfield(luaState, LUA_REGISTRYINDEX, eventRegistryKey);
+}
+
diff -ruNp src.orig/uqm/lua/luastate.h src/uqm/lua/luastate.h
--- src.orig/uqm/lua/luastate.h	1969-12-31 18:00:00 -0600
+++ src/uqm/lua/luastate.h	2017-11-21 19:39:56 -0600
@@ -0,0 +1,47 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _LUASTATE_H
+#define _LUASTATE_H
+
+#include "libs/compiler.h"
+#include "libs/scriptlib.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+extern lua_State *luaUqm_globalState;
+
+void luaUqm_initState(void);
+void luaUqm_uninitState(void);
+void luaUqm_reinitState(void);
+void luaUqm_getProp(lua_State *luaState, int nameIndex);
+void luaUqm_setProp(lua_State *luaState, int nameIndex, int valueIndex);
+int luaUqm_checkPropValueType (lua_State *luaState, const char *funName,
+		int nameIndex);
+
+void setGameStateUint (const char *name, DWORD val);
+DWORD getGameStateUint (const char *name);
+
+void luaUqm_getEventTable (lua_State *luaState);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif  /* _LUASTATE_H */
+
diff -ruNp src.orig/uqm/master.h src/uqm/master.h
--- src.orig/uqm/master.h	2017-11-21 19:39:38 -0600
+++ src/uqm/master.h	2017-11-21 19:39:56 -0600
@@ -20,6 +20,10 @@
 #include "races.h"
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef HLINK HMASTERSHIP;
 
 typedef struct
@@ -58,5 +62,9 @@ COUNT GetShipCostFromIndex (unsigned Ind
 FRAME GetShipIconsFromIndex (unsigned Index);
 FRAME GetShipMeleeIconsFromIndex (unsigned Index);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _MASTER_H */
 
diff -ruNp src.orig/uqm/menu.c src/uqm/menu.c
--- src.orig/uqm/menu.c	2017-11-21 19:39:38 -0600
+++ src/uqm/menu.c	2017-11-21 19:39:56 -0600
@@ -28,9 +28,6 @@
 #include "libs/tasklib.h"
 #include "libs/log.h"
 
-extern Task flash_task;
-extern RECT flash_rect;
-
 static BYTE GetEndMenuState (BYTE BaseState);
 static BYTE GetBeginMenuState (BYTE BaseState);
 static BYTE FixMenuState (BYTE BadState);
@@ -500,7 +497,7 @@ DrawMenuStateStrings (BYTE beg_index, SW
 	if (NewState <= end_index - beg_index)
 		s.frame = SetAbsFrameIndex (PlayFrame, beg_index + NewState);
 
-	LockMutex (GraphicsLock);
+	PreUpdateFlashRect ();
 	OldContext = SetContext (StatusContext);
 	GetContextClipRect (&r);
 	s.origin.x = RADAR_X - r.corner.x;
@@ -600,13 +597,7 @@ DrawMenuStateStrings (BYTE beg_index, SW
 		}
 	}
 	UnbatchGraphics ();
-	if (flash_task
-			&& flash_rect.corner.x == RADAR_X
-			&& flash_rect.corner.y == RADAR_Y
-			&& flash_rect.extent.width == RADAR_WIDTH
-			&& flash_rect.extent.height == RADAR_HEIGHT)
-		SetFlashRect (SFR_MENU_3DO);
 	SetContext (OldContext);
-	UnlockMutex (GraphicsLock);
+	PostUpdateFlashRect ();
 }
 
diff -ruNp src.orig/uqm/menustat.h src/uqm/menustat.h
--- src.orig/uqm/menustat.h	2017-11-21 19:39:38 -0600
+++ src/uqm/menustat.h	2017-11-21 19:39:56 -0600
@@ -23,6 +23,10 @@
 #include "libs/sndlib.h"
 #include "flash.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef struct menu_state
 {
 	// Standard field required by DoInput()
@@ -120,5 +124,9 @@ enum
 extern BOOLEAN DoMenuChooser (MENU_STATE *pMS, BYTE BaseState);
 extern void DrawMenuStateStrings (BYTE beg_index, SWORD NewState);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _MENUSTAT_H */
 
diff -ruNp src.orig/uqm/oscill.c src/uqm/oscill.c
--- src.orig/uqm/oscill.c	2017-11-21 19:39:38 -0600
+++ src/uqm/oscill.c	2017-11-21 19:39:56 -0600
@@ -79,7 +79,8 @@ DrawOscilloscope (void)
 	assert ((size_t)scopeSize.width <= sizeof scope_data);
 	assert (scopeSize.height < 256);
 
-	if (GraphForegroundStream (scope_data, scopeSize.width, scopeSize.height))
+	if (GraphForegroundStream (scope_data, scopeSize.width, scopeSize.height,
+			usingSpeech))
 	{
 		int i;
 		CONTEXT oldContext;
diff -ruNp src.orig/uqm/oscill.h src/uqm/oscill.h
--- src.orig/uqm/oscill.h	2017-11-21 19:39:38 -0600
+++ src/uqm/oscill.h	2017-11-21 19:39:56 -0600
@@ -20,6 +20,10 @@
 #include "libs/compiler.h"
 #include "libs/gfxlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern BOOLEAN sliderDisabled;
 extern BOOLEAN oscillDisabled;
 
@@ -32,5 +36,9 @@ extern void InitSlider (int x, int y, in
 extern void SetSliderImage (FRAME f);
 void DrawSlider (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _OSCILL_H */
 
diff -ruNp src.orig/uqm/outfit.c src/uqm/outfit.c
--- src.orig/uqm/outfit.c	2017-11-21 19:39:38 -0600
+++ src/uqm/outfit.c	2017-11-21 19:39:56 -0600
@@ -85,7 +85,8 @@ DrawModuleStrings (MENU_STATE *pMS, BYTE
 		t.align = ALIGN_RIGHT;
 		t.CharCount = (COUNT)~0;
 		t.pStr = buf;
-		sprintf (buf, "%u", GLOBAL (ModuleCost[NewModule]) * MODULE_COST_SCALE);
+		sprintf (buf, "%u",
+				GLOBAL (ModuleCost[NewModule]) * MODULE_COST_SCALE);
 		SetContextFont (TinyFont);
 		SetContextForeGroundColor (
 				BUILD_COLOR (MAKE_RGB15 (0x00, 0x1F, 0x00), 0x02));
@@ -98,43 +99,38 @@ DrawModuleStrings (MENU_STATE *pMS, BYTE
 static void
 RedistributeFuel (void)
 {
-	COUNT m;
-	DWORD FuelVolume;
+	const DWORD FuelVolume = GLOBAL_SIS (FuelOnBoard);
+	const CONTEXT OldContext = SetContext (SpaceContext);
 	RECT r;
-
-	FuelVolume = GLOBAL_SIS (FuelOnBoard);
-	if (FuelVolume <= FUEL_RESERVE)
-		return;
-
-	GLOBAL_SIS (FuelOnBoard) = 0;
-	m = FUEL_VOLUME_PER_ROW;
-
-	r.extent.width = 3;
 	r.extent.height = 1;
-	while (FuelVolume -= m)
-	{
-		GLOBAL_SIS (FuelOnBoard) += FUEL_VOLUME_PER_ROW;
-		GetFTankCapacity (&r.corner);
-		DrawPoint (&r.corner);
-		r.corner.x += r.extent.width + 1;
-		DrawPoint (&r.corner);
-		r.corner.x -= r.extent.width;
-		SetContextForeGroundColor (SetContextBackGroundColor (BLACK_COLOR));
-		DrawFilledRectangle (&r);
-		if (FuelVolume < FUEL_VOLUME_PER_ROW)
-			m = (COUNT)FuelVolume;
-	}
-
-	FuelVolume = GLOBAL_SIS (FuelOnBoard) + m;
 
-	r.extent.width = 5;
-	while ((GLOBAL_SIS (FuelOnBoard) += FUEL_VOLUME_PER_ROW) <
-			GetFTankCapacity (&r.corner))
-	{
-		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x0B, 0x00, 0x00), 0x2E));
+	// Loop through all the rows to draw
+	BatchGraphics ();
+	for (GLOBAL_SIS (FuelOnBoard) = FUEL_RESERVE;
+			GLOBAL_SIS (FuelOnBoard) < GetFTankCapacity (&r.corner);
+			GLOBAL_SIS (FuelOnBoard) += FUEL_VOLUME_PER_ROW)
+	{
+		// If we're less than the fuel level, draw fuel.
+		if (GLOBAL_SIS (FuelOnBoard) < FuelVolume)
+		{
+			r.extent.width = 3;
+			DrawPoint (&r.corner);
+			r.corner.x += r.extent.width + 1;
+			DrawPoint (&r.corner);
+			r.corner.x -= r.extent.width;
+			SetContextForeGroundColor (
+					SetContextBackGroundColor (BLACK_COLOR));
+		}
+		else // Otherwise, draw an empty bar.
+		{
+			r.extent.width = 5;
+			SetContextForeGroundColor (
+					BUILD_COLOR (MAKE_RGB15 (0x0B, 0x00, 0x00), 0x2E));
+		}
 		DrawFilledRectangle (&r);
 	}
+	UnbatchGraphics ();
+	SetContext (OldContext);
 
 	GLOBAL_SIS (FuelOnBoard) = FuelVolume;
 }
@@ -238,7 +234,6 @@ DoInstallModule (MENU_STATE *pMS)
 
 		pMS->InputFunc = DoInstallModule;
 
-		LockMutex (GraphicsLock);
 
 		SetContext (SpaceContext);
 		ClearSISRect (CLEAR_SIS_RADAR);
@@ -300,7 +295,6 @@ DoInstallModule (MENU_STATE *pMS)
 			}
 		}
 
-		LockMutex (GraphicsLock);
 		SetContext (SpaceContext);
 
 		SetFlashRect (NULL);
@@ -348,7 +342,8 @@ DoInstallModule (MENU_STATE *pMS)
 							GLOBAL (ModuleCost[old_slot_piece])
 							* MODULE_COST_SCALE);
 
-				if (pMS->CurState == PLANET_LANDER || pMS->CurState == EMPTY_SLOT + 3)
+				if (pMS->CurState == PLANET_LANDER ||
+						pMS->CurState == EMPTY_SLOT + 3)
 					DisplayLanders (pMS);
 				else
 				{
@@ -385,15 +380,12 @@ DoInstallModule (MENU_STATE *pMS)
 		else
 		{
 			SetContext (StatusContext);
-			UnlockMutex (GraphicsLock);
 			DrawMenuStateStrings (PM_FUEL, pMS->CurState = OUTFIT_MODULES);
-			LockMutex (GraphicsLock);
 			SetFlashRect (SFR_MENU_3DO);
 
 			pMS->InputFunc = DoOutfit;
 			ClearSISRect (DRAW_SIS_DISPLAY);
 		}
-		UnlockMutex (GraphicsLock);
 	}
 	else if (motion)
 	{
@@ -402,7 +394,8 @@ DoInstallModule (MENU_STATE *pMS)
 		NewItem = NewState < EMPTY_SLOT ? pMS->CurState : pMS->delta_item;
 		do
 		{
-			if (NewState >= EMPTY_SLOT && (PulsedInputState.menu[KEY_MENU_UP] || PulsedInputState.menu[KEY_MENU_DOWN]))
+			if (NewState >= EMPTY_SLOT && (PulsedInputState.menu[KEY_MENU_UP]
+					|| PulsedInputState.menu[KEY_MENU_DOWN]))
 			{
 				if (PulsedInputState.menu[KEY_MENU_UP])
 				{
@@ -442,15 +435,14 @@ DoInstallModule (MENU_STATE *pMS)
 				|| (NewItem >= GUN_WEAPON && NewItem <= CANNON_WEAPON
 				&& pMS->delta_item > 0 && pMS->delta_item < 13)));
 
-		LockMutex (GraphicsLock);
 		if (NewState < EMPTY_SLOT)
 		{
 			if (NewItem != pMS->CurState)
 			{
 				pMS->CurState = NewItem;
+				PreUpdateFlashRect ();
 				DrawModuleStrings (pMS, NewItem);
-				// flash with PC menus too
-				SetFlashRect (SFR_MENU_ANY);
+				PostUpdateFlashRect ();
 			}
 		}
 		else if (NewItem != pMS->delta_item || NewState != pMS->CurState)
@@ -542,7 +534,6 @@ InitFlash:
 			else
 				SetFlashRect (&pMS->flash_rect0);
 		}
-		UnlockMutex (GraphicsLock);
 	}
 
 	return (TRUE);
@@ -551,64 +542,55 @@ InitFlash:
 static void
 ChangeFuelQuantity (void)
 {
-	RECT r;
-	
-	r.extent.height = 1;
+	int incr = 0; // Fuel increment in fuel points (not units).
 	
-	if (PulsedInputState.menu[KEY_MENU_UP])
+	if      (PulsedInputState.menu[KEY_MENU_UP])
+		incr = FUEL_TANK_SCALE;  // +1 Unit
+	else if (PulsedInputState.menu[KEY_MENU_DOWN])
+		incr = -FUEL_TANK_SCALE; // -1 Unit
+	else if (PulsedInputState.menu[KEY_MENU_PAGE_UP])
+		incr = FUEL_VOLUME_PER_ROW;  // +1 Bar
+	else if (PulsedInputState.menu[KEY_MENU_PAGE_DOWN])
+		incr = -FUEL_VOLUME_PER_ROW; // -1 Bar
+	else
+		return;
+
+	// Clamp incr to what we can afford/hold/have.
 	{
-		LockMutex (GraphicsLock);
-		SetContext (SpaceContext);
-		if (GetFTankCapacity (&r.corner) > GLOBAL_SIS (FuelOnBoard)
-			&& GLOBAL_SIS (ResUnits) >= (DWORD)GLOBAL (FuelCost))
-		{
-			if (GLOBAL_SIS (FuelOnBoard) >= FUEL_RESERVE)
-			{
-				r.extent.width = 3;
-				DrawPoint (&r.corner);
-				r.corner.x += r.extent.width + 1;
-				DrawPoint (&r.corner);
-				r.corner.x -= r.extent.width;
-				SetContextForeGroundColor (
-						SetContextBackGroundColor (BLACK_COLOR));
-				DrawFilledRectangle (&r);
-			}
-			DeltaSISGauges (0, FUEL_TANK_SCALE, -GLOBAL (FuelCost));
-			SetContext (StatusContext);
-			GetGaugeRect (&r, FALSE);
-			SetFlashRect (&r);
-		}
-		else
-		{	// no more room for fuel or not enough RUs
-			PlayMenuSound (MENU_SOUND_FAILURE);
-		}
-		UnlockMutex (GraphicsLock);
+		const int maxFit = GetFuelTankCapacity () - GLOBAL_SIS (FuelOnBoard);
+		const int maxAfford = GLOBAL_SIS (ResUnits) / GLOBAL (FuelCost);
+		const int minFit = - (int) GLOBAL_SIS (FuelOnBoard);
+
+		if (incr > maxFit)
+			incr = maxFit; // All we can hold.
+
+		if (incr > maxAfford * FUEL_TANK_SCALE)
+			incr = maxAfford * FUEL_TANK_SCALE; // All we can afford.
+
+		if (incr < minFit)
+			incr = minFit; // All we have.
 	}
-	else if (PulsedInputState.menu[KEY_MENU_DOWN])
+
+	if (!incr)
 	{
-		LockMutex (GraphicsLock);
-		SetContext (SpaceContext);
-		if (GLOBAL_SIS (FuelOnBoard))
-		{
-			DeltaSISGauges (0, -FUEL_TANK_SCALE, GLOBAL (FuelCost));
-			if (GLOBAL_SIS (FuelOnBoard) % FUEL_VOLUME_PER_ROW == 0 &&
-					GLOBAL_SIS (FuelOnBoard) >= FUEL_RESERVE)
-			{
-				GetFTankCapacity (&r.corner);
-				SetContextForeGroundColor (
-						BUILD_COLOR (MAKE_RGB15 (0x0B, 0x00, 0x00), 0x2E));
-				r.extent.width = 5;
-				DrawFilledRectangle (&r);
-			}
-		}
-		else
-		{	// no fuel left to drain
-			PlayMenuSound (MENU_SOUND_FAILURE);
-		}
-		SetContext (StatusContext);
+		// No more room, not enough RUs, or no fuel left to drain.
+		PlayMenuSound (MENU_SOUND_FAILURE);
+	}
+	else
+	{
+		const int cost = (incr / FUEL_TANK_SCALE) * GLOBAL (FuelCost);
+		PreUpdateFlashRect ();
+		DeltaSISGauges (0, incr, -cost);
+		PostUpdateFlashRect ();
+		RedistributeFuel ();
+	}
+
+	{   // Make fuel gauge flash.
+		RECT r;
+		CONTEXT oldContext = SetContext (StatusContext);
 		GetGaugeRect (&r, FALSE);
 		SetFlashRect (&r);
-		UnlockMutex (GraphicsLock);
+		SetContext (oldContext);
 	}
 }
 
@@ -616,9 +598,7 @@ static void
 onNamingDone (void)
 {
 	// In case player just named a ship, redraw it
-	LockMutex (GraphicsLock);
 	DrawFlagshipName (FALSE);
-	UnlockMutex (GraphicsLock);
 }
 
 BOOLEAN
@@ -648,7 +628,6 @@ DoOutfit (MENU_STATE *pMS)
 			s.frame = CaptureDrawable (
 					LoadGraphic (OUTFIT_PMAP_ANIM));
 
-			LockMutex (GraphicsLock);
 			SetTransitionSource (NULL);
 			BatchGraphics ();
 			DrawSISFrame ();
@@ -710,21 +689,16 @@ DoOutfit (MENU_STATE *pMS)
 					DrawStamp (&s);
 			}
 
-			UnlockMutex (GraphicsLock);
 			DrawMenuStateStrings (PM_FUEL, pMS->CurState);
-			LockMutex (GraphicsLock);
 			DrawFlagshipName (FALSE);
 			if (optWhichFonts == OPT_PC)
 				DrawFlagshipStats ();
-			UnlockMutex (GraphicsLock);
 
 			ScreenTransition (3, NULL);
 			PlayMusic (pMS->hMusic, TRUE, 1);
 			UnbatchGraphics ();
 			
-			LockMutex (GraphicsLock);
 			SetFlashRect (SFR_MENU_3DO);
-			UnlockMutex (GraphicsLock);
 
 			GLOBAL_SIS (FuelOnBoard) =
 					(GLOBAL_SIS (FuelOnBoard)
@@ -741,9 +715,7 @@ DoOutfit (MENU_STATE *pMS)
 		if (pMS->CurState == OUTFIT_DOFUEL)
 		{
 			pMS->CurState = OUTFIT_FUEL;
-			LockMutex (GraphicsLock);
 			SetFlashRect (SFR_MENU_3DO);
-			UnlockMutex (GraphicsLock);
 		}
 		else
 		{
@@ -767,18 +739,14 @@ ExitOutfit:
 				RECT r;
 
 				pMS->CurState = OUTFIT_DOFUEL;
-				LockMutex (GraphicsLock);
 				SetContext (StatusContext);
 				GetGaugeRect (&r, FALSE);
 				SetFlashRect (&r);
-				UnlockMutex (GraphicsLock);
 				break;
 			}
 			case OUTFIT_DOFUEL:
 				pMS->CurState = OUTFIT_FUEL;
-				LockMutex (GraphicsLock);
 				SetFlashRect (SFR_MENU_3DO);
-				UnlockMutex (GraphicsLock);
 				break;
 			case OUTFIT_MODULES:
 				pMS->CurState = EMPTY_SLOT + 2;
@@ -795,9 +763,7 @@ ExitOutfit:
 				if (!GameOptions ())
 					goto ExitOutfit;
 				DrawMenuStateStrings (PM_FUEL, pMS->CurState);
-				LockMutex (GraphicsLock);
 				SetFlashRect (SFR_MENU_3DO);
-				UnlockMutex (GraphicsLock);
 				break;
 		}
 	}
@@ -806,7 +772,9 @@ ExitOutfit:
 		switch (pMS->CurState)
 		{
 			case OUTFIT_DOFUEL:
-				SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
+				SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN |
+						MENU_SOUND_PAGEUP | MENU_SOUND_PAGEDOWN,
+						MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
 				break;
 			default:
 				SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
diff -ruNp src.orig/uqm/pickship.c src/uqm/pickship.c
--- src.orig/uqm/pickship.c	2017-11-21 19:39:38 -0600
+++ src/uqm/pickship.c	2017-11-21 19:39:56 -0600
@@ -61,7 +61,6 @@ DoPickBattleShip (MENU_STATE *pMS)
 		pMS->Initialized = TRUE;
 		pMS->InputFunc = DoPickBattleShip;
 
-		LockMutex (GraphicsLock);
 
 		goto ChangeSelection;
 	}
@@ -106,7 +105,6 @@ DoPickBattleShip (MENU_STATE *pMS)
 
 			PlayMenuSound (MENU_SOUND_MOVE);
 
-			LockMutex (GraphicsLock);
 
 #ifdef NEVER
 			SetContextForeGroundColor (
@@ -240,7 +238,6 @@ ChangeSelection:
 
 			SetFlashRect (NULL);
 			SetFlashRect (&pMS->flash_rect0);
-			UnlockMutex (GraphicsLock);
 		}
 	}
 
@@ -278,10 +275,8 @@ OldContext = SetContext (SpaceContext);
 		MenuState.flash_rect1.corner = pick_r.corner;
 		MenuState.flash_rect1.extent.width = 0;
 
-		UnlockMutex (GraphicsLock);
 		SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
 		DoInput (&MenuState, FALSE);
-		LockMutex (GraphicsLock);
 
 		SetFlashRect (NULL);
 
@@ -309,7 +304,7 @@ SetContext (OldContext);
 HSTARSHIP
 GetEncounterStarShip (STARSHIP *LastStarShipPtr, COUNT which_player)
 {
-	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+	if (inHQSpace ())
 	{
 		assert (which_player == RPG_PLAYER_NUM);
 		// SIS for the Hyperspace flight
diff -ruNp src.orig/uqm/pickship.h src/uqm/pickship.h
--- src.orig/uqm/pickship.h	2017-11-21 19:39:38 -0600
+++ src/uqm/pickship.h	2017-11-21 19:39:56 -0600
@@ -20,8 +20,16 @@
 #include "libs/compiler.h"
 #include "races.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern HSTARSHIP GetEncounterStarShip (STARSHIP *LastStarShipPtr,
 		COUNT which_player);
 extern void DrawArmadaPickShip (BOOLEAN draw_salvage_frame, RECT *pPickRect);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* UQM_PICKSHIP_H_INCL_ */
diff -ruNp src.orig/uqm/plandata.c src/uqm/plandata.c
--- src.orig/uqm/plandata.c	2017-11-21 19:39:39 -0600
+++ src/uqm/plandata.c	2017-11-21 19:39:56 -0600
@@ -16,8 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// XXX: for XXX_DEFINED constants
-#include "encount.h"
+#include "gendef.h"
 #include "resinst.h"
 #include "planets/planets.h"
 #include "planets/elemdata.h"
diff -ruNp src.orig/uqm/planets/Makeinfo src/uqm/planets/Makeinfo
--- src.orig/uqm/planets/Makeinfo	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/Makeinfo	2017-11-21 19:39:57 -0600
@@ -2,3 +2,6 @@ uqm_SUBDIRS="generate"
 uqm_CFILES="calc.c cargo.c devices.c gentopo.c lander.c orbits.c
 		oval.c pl_stuff.c planets.c plangen.c pstarmap.c report.c
 		roster.c scan.c solarsys.c surface.c"
+uqm_HFILES="elemdata.h generate.h lander.h lifeform.h plandata.h planets.h
+		scan.h solarsys.h sundata.h"
+
diff -ruNp src.orig/uqm/planets/calc.c src/uqm/planets/calc.c
--- src.orig/uqm/planets/calc.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/calc.c	2017-11-21 19:39:56 -0600
@@ -17,7 +17,8 @@
  */
 
 /* ----------------------------- INCLUDES ---------------------------- */
-#include "../encount.h"
+#include "planets.h"
+#include "uqm/starmap.h"
 #include "libs/mathlib.h"
 #include "libs/log.h"
 /* -------------------------------- DATA -------------------------------- */
@@ -26,9 +27,6 @@
 
 //#define DEBUG_PLANET_CALC
 
-#define CalcMass(b) CalcFromBase (b, b)
-#define CalcRadius(b) CalcFromBase (b, ((b) >> 1) + 1)
-
 #define LOW_TEMP 0
 #define MED_TEMP 500
 #define HIGH_TEMP 1500
@@ -36,15 +34,6 @@
 #define MED_TEMP_BONUS 25
 #define HIGH_TEMP_BONUS 50
 #define MAX_TECTONICS 255
-#ifdef OLD
-#define CalcTectonics(b,t) (CalcFromBase(b, 3 << 5) \
-										+ (UWORD)((t) < LOW_TEMP ? 0 : \
-										((t) < MED_TEMP ? LOW_TEMP_BONUS : \
-										((t) < HIGH_TEMP ? MED_TEMP_BONUS : \
-										HIGH_TEMP_BONUS))))
-#else /* OLD */
-#define CalcTectonics(b,t) CalcFromBase(b, 3 << 5)
-#endif /* OLD */
 
 enum
 {
@@ -56,6 +45,18 @@ enum
 	WHITE_SUN_INTENSITY
 };
 
+static UWORD
+CalcFromBase (UWORD base, UWORD variance)
+{
+	return base + LOWORD (RandomContext_Random (SysGenRNG)) % variance;
+}
+
+static inline UWORD
+CalcHalfBaseVariance (UWORD base)
+{
+	return CalcFromBase (base, (base >> 1) + 1);
+}
+
 static void
 CalcSysInfo (SYSTEM_INFO *SysInfoPtr)
 {
@@ -149,7 +150,7 @@ GeneratePlanetComposition (PLANET_INFO *
 					PlanetInfoPtr->Weather += 1 << 5;
 				else if (radius > 10)
 					PlanetInfoPtr->Weather -= 1 << 5;
-				atmo = CalcFromBase (atmo, (atmo >> 1) + 1);
+				atmo = CalcHalfBaseVariance (atmo);
 			}
 		}
 
@@ -165,6 +166,11 @@ GeneratePlanetComposition (PLANET_INFO *
 // have the colour you'd expect based on the true temperature.
 // (eg. Beta Corvi I). I don't know what the idea behind this is,
 // but the if statement must be there for a reason. -- SvdB
+// Update 2013-03-28: The contents of the if() block is probably there to
+// model a greenhouse effect. It seems that it is taken into account when
+// calculating the actual temperature (when landing or scanning), but not
+// when determining the colors of the drawn orbits. (Thanks to James Scott
+// for this insight.)
 static SIZE
 CalcTemp (SYSTEM_INFO *SysInfoPtr, SIZE radius)
 {
@@ -194,7 +200,7 @@ CalcTemp (SYSTEM_INFO *SysInfoPtr, SIZE
 			bonus = COLD_BONUS;
 
 		bonus <<= HINIBBLE (SysInfoPtr->PlanetInfo.PlanDataPtr->AtmoAndDensity);
-		bonus = CalcFromBase (bonus, (bonus >> 1) + 1);
+		bonus = CalcHalfBaseVariance (bonus);
 	}
 
 	return (centigrade + bonus);
@@ -204,11 +210,11 @@ static COUNT
 CalcRotation (PLANET_INFO *PlanetInfoPtr)
 {
 	if (PLANSIZE (PlanetInfoPtr->PlanDataPtr->Type) == GAS_GIANT)
-		return ((COUNT)CalcFromBase (80, 80));
-	else if (((BYTE)TFB_Random () % 10) == 0)
-		return ((COUNT)CalcFromBase ((UWORD)50 * 240, (UWORD)200 * 240));
+		return CalcFromBase (80, 80);
+	else if (LOBYTE (RandomContext_Random (SysGenRNG)) % 10 == 0)
+		return CalcFromBase (50 * 240, 200 * 240);
 	else
-		return ((COUNT)CalcFromBase (150, 150));
+		return CalcFromBase (150, 150);
 }
 
 static SIZE
@@ -223,22 +229,138 @@ CalcTilt (void)
 	i = NUM_TOSSES;
 	do /* Using added Randomom values to give bell curve */
 	{
-		tilt += (UWORD)TFB_Random () % ((TILT_RANGE / NUM_TOSSES) + 1);
+		tilt += LOWORD (RandomContext_Random (SysGenRNG))
+				% ((TILT_RANGE / NUM_TOSSES) + 1);
 	} while (--i);
 
 	return (tilt);
 }
 
-// NB. Returns the RNG to the state it found it in.
-DWORD
-DoPlanetaryAnalysis (SYSTEM_INFO *SysInfoPtr, PLANET_DESC *pPlanetDesc)
+UWORD
+CalcGravity (const PLANET_INFO *PlanetInfoPtr)
+{
+	return (DWORD)PlanetInfoPtr->PlanetDensity * PlanetInfoPtr->PlanetRadius
+				/ 100;
+}
+
+static UWORD
+CalcTectonics (UWORD base, UWORD temp)
+{
+	UWORD tect = CalcFromBase (base, 3 << 5);
+#ifdef OLD
+	if (temp >= HIGH_TEMP)
+		tect += HIGH_TEMP_BONUS;
+	else if (temp >= MED_TEMP)
+		tect += MED_TEMP_BONUS;
+	else if (temp >= LOW_TEMP)
+		tect += LOW_TEMP_BONUS;
+#else /* !OLD */
+	(void) temp; /* silence compiler whining */
+#endif /* OLD */
+	return tect;
+}
+
+// This code moved from planets/surface.c:CalcLifeForms()
+static int
+CalcLifeChance (const PLANET_INFO *PlanetInfoPtr)
 {
-	DWORD old_seed;
+	SIZE life_var = 0;
+
+	if (PLANSIZE (PlanetInfoPtr->PlanDataPtr->Type) == GAS_GIANT)
+		return -1;
+
+	if (PlanetInfoPtr->SurfaceTemperature < -151)
+		life_var -= 300;
+	else if (PlanetInfoPtr->SurfaceTemperature < -51)
+		life_var -= 100;
+	else if (PlanetInfoPtr->SurfaceTemperature < 0)
+		life_var += 100;
+	else if (PlanetInfoPtr->SurfaceTemperature < 50)
+		life_var += 300;
+	else if (PlanetInfoPtr->SurfaceTemperature < 150)
+		life_var += 50;
+	else if (PlanetInfoPtr->SurfaceTemperature < 250)
+		life_var -= 100;
+	else if (PlanetInfoPtr->SurfaceTemperature < 500)
+		life_var -= 400;
+	else
+		life_var -= 800;
 
-	if (pPlanetDesc->data_index == HIERARCHY_STARBASE)
-		return (0);
+	if (PlanetInfoPtr->AtmoDensity == 0)
+		life_var -= 1000;
+	else if (PlanetInfoPtr->AtmoDensity < 15)
+		life_var += 100;
+	else if (PlanetInfoPtr->AtmoDensity < 30)
+		life_var += 200;
+	else if (PlanetInfoPtr->AtmoDensity < 100)
+		life_var += 300;
+	else if (PlanetInfoPtr->AtmoDensity < 1000)
+		life_var += 150;
+	else if (PlanetInfoPtr->AtmoDensity < 2500)
+		;
+	else
+		life_var -= 100;
 
-	old_seed = TFB_SeedRandom (pPlanetDesc->rand_seed);
+#ifndef NOTYET
+	life_var += 200 + 80 + 80;
+#else /* NOTYET */
+	if (PlanetInfoPtr->SurfaceGravity < 10)
+		;
+	else if (PlanetInfoPtr->SurfaceGravity < 35)
+		life_var += 50;
+	else if (PlanetInfoPtr->SurfaceGravity < 75)
+		life_var += 100;
+	else if (PlanetInfoPtr->SurfaceGravity < 150)
+		life_var += 200;
+	else if (PlanetInfoPtr->SurfaceGravity < 400)
+		life_var += 50;
+	else if (PlanetInfoPtr->SurfaceGravity < 800)
+		;
+	else
+		life_var -= 100;
+
+	if (PlanetInfoPtr->Tectonics < 1)
+		life_var += 80;
+	else if (PlanetInfoPtr->Tectonics < 2)
+		life_var += 70;
+	else if (PlanetInfoPtr->Tectonics < 3)
+		life_var += 60;
+	else if (PlanetInfoPtr->Tectonics < 4)
+		life_var += 50;
+	else if (PlanetInfoPtr->Tectonics < 5)
+		life_var += 25;
+	else if (PlanetInfoPtr->Tectonics < 6)
+		;
+	else
+		life_var -= 100;
+
+	if (PlanetInfoPtr->Weather < 1)
+		life_var += 80;
+	else if (PlanetInfoPtr->Weather < 2)
+		life_var += 70;
+	else if (PlanetInfoPtr->Weather < 3)
+		life_var += 60;
+	else if (PlanetInfoPtr->Weather < 4)
+		life_var += 50;
+	else if (PlanetInfoPtr->Weather < 5)
+		life_var += 25;
+	else if (PlanetInfoPtr->Weather < 6)
+		;
+	else
+		life_var -= 100;
+#endif /* NOTYET */
+
+	return life_var;
+}
+
+// Sets the SysGenRNG to the required state first.
+void
+DoPlanetaryAnalysis (SYSTEM_INFO *SysInfoPtr, PLANET_DESC *pPlanetDesc)
+{
+	assert ((pPlanetDesc->data_index & ~WORLD_TYPE_SPECIAL)
+			< NUMBER_OF_PLANET_TYPES);
+
+	RandomContext_SeedRandom (SysGenRNG, pPlanetDesc->rand_seed);
 
 	CalcSysInfo (SysInfoPtr);
 
@@ -303,18 +425,18 @@ DoPlanetaryAnalysis (SYSTEM_INFO *SysInf
 		}
 		SysInfoPtr->PlanetInfo.PlanetDensity +=
 				(SysInfoPtr->PlanetInfo.PlanetDensity / 20)
-				- ((COUNT)TFB_Random ()
+				- (LOWORD (RandomContext_Random (SysGenRNG))
 				% (SysInfoPtr->PlanetInfo.PlanetDensity / 10));
 
 		switch (PLANSIZE (SysInfoPtr->PlanetInfo.PlanDataPtr->Type))
 		{
 			case SMALL_ROCKY_WORLD:
 #define SMALL_RADIUS 25
-				SysInfoPtr->PlanetInfo.PlanetRadius = CalcRadius (SMALL_RADIUS);
+				SysInfoPtr->PlanetInfo.PlanetRadius = CalcHalfBaseVariance (SMALL_RADIUS);
 				break;
 			case LARGE_ROCKY_WORLD:
 #define LARGE_RADIUS 75
-				SysInfoPtr->PlanetInfo.PlanetRadius = CalcRadius (LARGE_RADIUS);
+				SysInfoPtr->PlanetInfo.PlanetRadius = CalcHalfBaseVariance (LARGE_RADIUS);
 				break;
 			case GAS_GIANT:
 #define MIN_GAS_RADIUS 300
@@ -325,9 +447,7 @@ DoPlanetaryAnalysis (SYSTEM_INFO *SysInf
 		}
 
 		SysInfoPtr->PlanetInfo.RotationPeriod = CalcRotation (&SysInfoPtr->PlanetInfo);
-		SysInfoPtr->PlanetInfo.SurfaceGravity =
-				CalcGravity (SysInfoPtr->PlanetInfo.PlanetDensity,
-				SysInfoPtr->PlanetInfo.PlanetRadius);
+		SysInfoPtr->PlanetInfo.SurfaceGravity = CalcGravity (&SysInfoPtr->PlanetInfo);
 		SysInfoPtr->PlanetInfo.AxialTilt = CalcTilt ();
 		if ((SysInfoPtr->PlanetInfo.Tectonics =
 				CalcTectonics (SysInfoPtr->PlanetInfo.PlanDataPtr->BaseTectonics,
@@ -341,6 +461,8 @@ DoPlanetaryAnalysis (SYSTEM_INFO *SysInf
 		SysInfoPtr->PlanetInfo.Tectonics >>= 5;
 		SysInfoPtr->PlanetInfo.Weather >>= 5;
 
+		SysInfoPtr->PlanetInfo.LifeChance = CalcLifeChance (&SysInfoPtr->PlanetInfo);
+
 #ifdef DEBUG_PLANET_CALC
 		radius = (SIZE)((DWORD)UNSCALE_RADIUS (radius) * 100 / UNSCALE_RADIUS (EARTH_RADIUS));
 		log_add (log_Debug, "\tOrbital Distance   : %d.%02d AU", radius / 100, radius % 100);
@@ -404,7 +526,5 @@ DoPlanetaryAnalysis (SYSTEM_INFO *SysInf
 		}
 #endif /* DEBUG_PLANET_CALC */
 	}
-
-	return (TFB_SeedRandom (old_seed));
 }
 
diff -ruNp src.orig/uqm/planets/cargo.c src/uqm/planets/cargo.c
--- src.orig/uqm/planets/cargo.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/cargo.c	2017-11-21 19:39:56 -0600
@@ -239,8 +239,6 @@ DrawCargoStrings (BYTE OldElement, BYTE
 {
 	CONTEXT OldContext;
 
-	LockMutex (GraphicsLock);
-
 	OldContext = SetContext (StatusContext);
 	SetContextFont (TinyFont);
 
@@ -266,15 +264,12 @@ DrawCargoStrings (BYTE OldElement, BYTE
 
 	UnbatchGraphics ();
 	SetContext (OldContext);
-	UnlockMutex (GraphicsLock);
 }
 
 static void
 DrawElementDescription (COUNT element)
 {
-	LockMutex (GraphicsLock);
 	DrawStatusMessage (GAME_STRING (element + (CARGO_STRING_BASE + 2)));
-	UnlockMutex (GraphicsLock);
 }
 
 static BOOLEAN
@@ -302,10 +297,8 @@ DoDiscardCargo (MENU_STATE *pMS)
 			--GLOBAL_SIS (ElementAmounts[pMS->CurState]);
 			DrawCargoStrings (pMS->CurState, pMS->CurState);
 
-			LockMutex (GraphicsLock);
 			--GLOBAL_SIS (TotalElementMass);
 			ShowRemainingCapacity ();
-			UnlockMutex (GraphicsLock);
 		}
 		else
 		{	// no element left in cargo hold
@@ -358,8 +351,6 @@ CargoMenu (void)
 	DoInput (&MenuState, TRUE);
 
 	// erase the cargo display
-	LockMutex (GraphicsLock);
 	ClearSISRect (DRAW_SIS_DISPLAY);
-	UnlockMutex (GraphicsLock);
 }
 
diff -ruNp src.orig/uqm/planets/devices.c src/uqm/planets/devices.c
--- src.orig/uqm/planets/devices.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/devices.c	2017-11-21 19:39:56 -0600
@@ -18,12 +18,14 @@
 
 #include "../build.h"
 #include "../colors.h"
+#include "../gendef.h"
+#include "../starmap.h"
 #include "../encount.h"
 #include "../gamestr.h"
 #include "../controls.h"
+#include "../save.h"
 #include "../settings.h"
 #include "../shipcont.h"
-#include "../load.h"
 #include "../setup.h"
 #include "../state.h"
 #include "../sis.h"
@@ -183,7 +185,6 @@ DrawDevicesDisplay (DEVICES_STATE *devSt
 static void
 DrawDevices (DEVICES_STATE *devState, COUNT OldDevice, COUNT NewDevice)
 {
-	LockMutex (GraphicsLock);
 	BatchGraphics ();
 
 	SetContext (StatusContext);
@@ -209,7 +210,6 @@ DrawDevices (DEVICES_STATE *devState, CO
 	}
 
 	UnbatchGraphics ();
-	UnlockMutex (GraphicsLock);
 }
 
 // Returns TRUE if the broadcaster has been successfully activated,
@@ -217,7 +217,7 @@ DrawDevices (DEVICES_STATE *devState, CO
 static BOOLEAN
 UseCaster (void)
 {
-	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+	if (inHQSpace ())
 	{
 		if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
 		{
@@ -256,7 +256,7 @@ UseCaster (void)
 		HIPGROUP hGroup;
 
 		FoundIlwrath = (CurStarDescPtr->Index == ILWRATH_DEFINED)
-				&& ActivateStarShip (ILWRATH_SHIP, SPHERE_TRACKING);
+				&& StartSphereTracking (ILWRATH_SHIP);
 				// In the Ilwrath home system and they are alive?
 
 		if (!FoundIlwrath &&
@@ -372,7 +372,7 @@ InvokeDevice (BYTE which_device)
 			NextActivity |= CHECK_LOAD; /* fake a load game */
 			GLOBAL (CurrentActivity) |= START_ENCOUNTER;
 			SET_GAME_STATE (GLOBAL_FLAGS_AND_DATA, 0);
-			if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+			if (inHQSpace ())
 			{
 				if (GetHeadEncounter ())
 				{
@@ -443,8 +443,7 @@ InvokeDevice (BYTE which_device)
 			break;
 		case PORTAL_SPAWNER_DEVICE:
 #define PORTAL_FUEL_COST (10 * FUEL_TANK_SCALE)
-			if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE
-					&& GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1
+			if (inHyperSpace ()
 					&& GLOBAL_SIS (FuelOnBoard) >= PORTAL_FUEL_COST)
 			{
 				/* No DeltaSISGauges because the flagship picture
@@ -491,13 +490,11 @@ DoManipulateDevices (MENU_STATE *pMS)
 	{
 		DeviceStatus status;
 
-		LockMutex (GraphicsLock);
 		status = InvokeDevice (devState->list[pMS->CurState]);
 		if (status == DEVICE_FAILURE)
 			PlayMenuSound (MENU_SOUND_FAILURE);
 		else if (status == DEVICE_SUCCESS)
 			PlayMenuSound (MENU_SOUND_INVOKED);
-		UnlockMutex (GraphicsLock);
 
 		return (status == DEVICE_FAILURE);
 	}
@@ -680,9 +677,7 @@ DevicesMenu (void)
 	if (GLOBAL_SIS (CrewEnlisted) != (COUNT)~0
 			&& !(GLOBAL (CurrentActivity) & CHECK_ABORT))
 	{
-		LockMutex (GraphicsLock);
 		ClearSISRect (DRAW_SIS_DISPLAY);
-		UnlockMutex (GraphicsLock);
 
 		if (!GET_GAME_STATE (PORTAL_COUNTER)
 				&& !(GLOBAL (CurrentActivity) & START_ENCOUNTER)
diff -ruNp src.orig/uqm/planets/elemdata.h src/uqm/planets/elemdata.h
--- src.orig/uqm/planets/elemdata.h	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/elemdata.h	2017-11-21 19:39:56 -0600
@@ -21,6 +21,9 @@
 
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
 /*------------------------------ Type Defines ----------------------------- */
 enum
@@ -205,5 +208,9 @@ enum
 
 extern const BYTE *Elements;
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _ELEMDATA_H */
 
diff -ruNp src.orig/uqm/planets/generate/Makeinfo src/uqm/planets/generate/Makeinfo
--- src.orig/uqm/planets/generate/Makeinfo	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/generate/Makeinfo	2017-11-21 19:39:56 -0600
@@ -3,3 +3,4 @@ uqm_CFILES="gendefault.c genand.c genbur
 		gensam.c genshof.c gensly.c gensol.c genspa.c gensup.c gensyr.c
 		genthrad.c gentrap.c genutw.c genvault.c genvux.c genwreck.c
 		genyeh.c genzfpscout.c genzoq.c"
+uqm_HFILES="genall.h gendefault.h"
diff -ruNp src.orig/uqm/planets/generate/genand.c src/uqm/planets/generate/genand.c
--- src.orig/uqm/planets/generate/genand.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/generate/genand.c	2017-11-21 19:39:56 -0600
@@ -30,8 +30,8 @@
 static bool GenerateAndrosynth_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateAndrosynth_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateAndrosynth_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateAndrosynth_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateAndrosynth_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -152,12 +152,12 @@ GenerateAndrosynth_pickupEnergy (SOLARSY
 }
 
 static COUNT
-GenerateAndrosynth_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateAndrosynth_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 1, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
+		return GenerateDefault_generateRuins (solarSys, whichNode, info);
 	}
 
 	return 0;
diff -ruNp src.orig/uqm/planets/generate/genburv.c src/uqm/planets/generate/genburv.c
--- src.orig/uqm/planets/generate/genburv.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/generate/genburv.c	2017-11-21 19:39:56 -0600
@@ -30,8 +30,8 @@ static bool GenerateBurvixese_generateMo
 		PLANET_DESC *planet);
 static bool GenerateBurvixese_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateBurvixese_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateBurvixese_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateBurvixese_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -85,7 +85,7 @@ GenerateBurvixese_generateMoons (SOLARSY
 		solarSys->MoonDesc[0].data_index = SELENIC_WORLD;
 		solarSys->MoonDesc[0].radius = MIN_MOON_RADIUS
 				+ (MAX_MOONS - 1) * MOON_DELTA;
-		rand_val = TFB_Random ();
+		rand_val = RandomContext_Random (SysGenRNG);
 		angle = NORMALIZE_ANGLE (LOWORD (rand_val));
 		solarSys->MoonDesc[0].location.x =
 				COSINE (angle, solarSys->MoonDesc[0].radius);
@@ -98,18 +98,17 @@ GenerateBurvixese_generateMoons (SOLARSY
 static bool
 GenerateBurvixese_generateOrbital (SOLARSYS_STATE *solarSys, PLANET_DESC *world)
 {
-	COUNT i;
 	DWORD rand_val;
 
-	rand_val = DoPlanetaryAnalysis (&solarSys->SysInfo, world);
+	DoPlanetaryAnalysis (&solarSys->SysInfo, world);
+	rand_val = RandomContext_GetSeed (SysGenRNG);
 
 	solarSys->SysInfo.PlanetInfo.ScanSeed[BIOLOGICAL_SCAN] = rand_val;
-	i = (COUNT)~0;
-	rand_val = GenerateLifeForms (&solarSys->SysInfo, &i);
+	GenerateLifeForms (&solarSys->SysInfo, GENERATE_ALL, NULL);
+	rand_val = RandomContext_GetSeed (SysGenRNG);
 
 	solarSys->SysInfo.PlanetInfo.ScanSeed[MINERAL_SCAN] = rand_val;
-	i = (COUNT)~0;
-	GenerateMineralDeposits (&solarSys->SysInfo, &i);
+	GenerateMineralDeposits (&solarSys->SysInfo, GENERATE_ALL, NULL);
 
 	solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN] = rand_val;
 
@@ -141,12 +140,12 @@ GenerateBurvixese_generateOrbital (SOLAR
 }
 
 static COUNT
-GenerateBurvixese_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateBurvixese_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
+		return GenerateDefault_generateRuins (solarSys, whichNode, info);
 	}
 
 	if (matchWorld (solarSys, world, 0, 0))
@@ -158,7 +157,7 @@ GenerateBurvixese_generateEnergy (SOLARS
 			return 0;
 		}
 		
-		return GenerateDefault_generateArtifact (solarSys, whichNode);
+		return GenerateDefault_generateArtifact (solarSys, whichNode, info);
 	}
 
 	return 0;
diff -ruNp src.orig/uqm/planets/generate/genchmmr.c src/uqm/planets/generate/genchmmr.c
--- src.orig/uqm/planets/generate/genchmmr.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/generate/genchmmr.c	2017-11-21 19:39:56 -0600
@@ -77,7 +77,7 @@ GenerateChmmr_generateMoons (SOLARSYS_ST
 
 		solarSys->MoonDesc[0].data_index = HIERARCHY_STARBASE;
 		solarSys->MoonDesc[0].radius = MIN_MOON_RADIUS;
-		rand_val = TFB_Random ();
+		rand_val = RandomContext_Random (SysGenRNG);
 		angle = NORMALIZE_ANGLE (LOWORD (rand_val));
 		solarSys->MoonDesc[0].location.x =
 				COSINE (angle, solarSys->MoonDesc[0].radius);
@@ -107,7 +107,7 @@ GenerateChmmr_generateOrbital (SOLARSYS_
 		}
 		else if (GET_GAME_STATE (SUN_DEVICE_ON_SHIP)
 				&& !GET_GAME_STATE (ILWRATH_DECEIVED)
-				&& ActivateStarShip (ILWRATH_SHIP, SPHERE_TRACKING))
+				&& StartSphereTracking (ILWRATH_SHIP))
 		{
 			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
 			ReinitQueue (&GLOBAL (ip_group_q));
@@ -133,8 +133,6 @@ GenerateChmmr_generateOrbital (SOLARSYS_
 	else if (matchWorld (solarSys, world, 1, 0))
 	{
 		/* Starbase */
-		LockMutex (GraphicsLock);
-
 		LoadStdLanderFont (&solarSys->SysInfo.PlanetInfo);
 		solarSys->SysInfo.PlanetInfo.DiscoveryString =
 				CaptureStringTable (LoadStringTable (CHMMR_BASE_STRTAB));
@@ -146,8 +144,6 @@ GenerateChmmr_generateOrbital (SOLARSYS_
 		solarSys->SysInfo.PlanetInfo.DiscoveryString = 0;
 		FreeLanderFont (&solarSys->SysInfo.PlanetInfo);
 
-		UnlockMutex (GraphicsLock);
-
 		return true;
 	}
 
diff -ruNp src.orig/uqm/planets/generate/gencol.c src/uqm/planets/generate/gencol.c
--- src.orig/uqm/planets/generate/gencol.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/generate/gencol.c	2017-11-21 19:39:56 -0600
@@ -53,14 +53,14 @@ GenerateColony_initNpcs (SOLARSYS_STATE
 {
 	HIPGROUP hGroup;
 
-	GLOBAL (BattleGroupRef) = GET_GAME_STATE_32 (COLONY_GRPOFFS0);
+	GLOBAL (BattleGroupRef) = GET_GAME_STATE (COLONY_GRPOFFS);
 	if (GLOBAL (BattleGroupRef) == 0)
 	{
 		CloneShipFragment (URQUAN_SHIP,
 				&GLOBAL (npc_built_ship_q), 0);
 		GLOBAL (BattleGroupRef) = PutGroupInfo (GROUPS_ADD_NEW, 1);
 		ReinitQueue (&GLOBAL (npc_built_ship_q));
-		SET_GAME_STATE_32 (COLONY_GRPOFFS0, GLOBAL (BattleGroupRef));
+		SET_GAME_STATE (COLONY_GRPOFFS, GLOBAL (BattleGroupRef));
 	}
 
 	GenerateDefault_initNpcs (solarSys);
diff -ruNp src.orig/uqm/planets/generate/gendefault.c src/uqm/planets/generate/gendefault.c
--- src.orig/uqm/planets/generate/gendefault.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/generate/gendefault.c	2017-11-21 19:39:56 -0600
@@ -27,17 +27,6 @@
 #include "libs/mathlib.h"
 
 
-bool GenerateDefault_initNpcs (SOLARSYS_STATE *solarSys);
-bool GenerateDefault_reinitNpcs (SOLARSYS_STATE *solarSys);
-bool GenerateDefault_uninitNpcs (SOLARSYS_STATE *solarSys);
-bool GenerateDefault_generatePlanets (SOLARSYS_STATE *solarSys);
-bool GenerateDefault_generateMoons (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *planet);
-bool GenerateDefault_generateName (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world);
-bool GenerateDefault_generateOrbital (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world);
-
 static void GeneratePlanets (SOLARSYS_STATE *system);
 static void check_yehat_rebellion (void);
 
@@ -113,7 +102,8 @@ GenerateDefault_generateMoons (SOLARSYS_
 }
 
 bool
-GenerateDefault_generateName (SOLARSYS_STATE *solarSys, PLANET_DESC *world)
+GenerateDefault_generateName (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world)
 {
 	COUNT i = planetIndex (solarSys, world);
 	utf8StringCopy (GLOBAL_SIS (PlanetName), sizeof (GLOBAL_SIS (PlanetName)),
@@ -126,7 +116,6 @@ GenerateDefault_generateName (SOLARSYS_S
 bool
 GenerateDefault_generateOrbital (SOLARSYS_STATE *solarSys, PLANET_DESC *world)
 {
-	COUNT i;
 	DWORD rand_val;
 	SYSTEM_INFO *sysInfo;
 
@@ -146,15 +135,15 @@ GenerateDefault_generateOrbital (SOLARSY
 
 	sysInfo = &solarSys->SysInfo;
 
-	rand_val = DoPlanetaryAnalysis (sysInfo, world);
+	DoPlanetaryAnalysis (sysInfo, world);
+	rand_val = RandomContext_GetSeed (SysGenRNG);
 
 	sysInfo->PlanetInfo.ScanSeed[BIOLOGICAL_SCAN] = rand_val;
-	i = (COUNT)~0;
-	rand_val = GenerateLifeForms (sysInfo, &i);
+	GenerateLifeForms (sysInfo, GENERATE_ALL, NULL);
+	rand_val = RandomContext_GetSeed (SysGenRNG);
 
 	sysInfo->PlanetInfo.ScanSeed[MINERAL_SCAN] = rand_val;
-	i = (COUNT)~0;
-	GenerateMineralDeposits (sysInfo, &i);
+	GenerateMineralDeposits (sysInfo, GENERATE_ALL, NULL);
 
 	sysInfo->PlanetInfo.ScanSeed[ENERGY_SCAN] = rand_val;
 	LoadPlanet (NULL);
@@ -163,12 +152,11 @@ GenerateDefault_generateOrbital (SOLARSY
 }
 
 COUNT
-GenerateDefault_generateMinerals (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode)
+GenerateDefault_generateMinerals (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
-	GenerateMineralDeposits (&solarSys->SysInfo, &whichNode);
+	return GenerateMineralDeposits (&solarSys->SysInfo, whichNode, info);
 	(void) world;
-	return whichNode;
 }
 
 bool
@@ -183,12 +171,13 @@ GenerateDefault_pickupMinerals (SOLARSYS
 }
 
 COUNT
-GenerateDefault_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateDefault_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	(void) whichNode;
 	(void) solarSys;
 	(void) world;
+	(void) info;
 	return 0;
 }
 
@@ -206,12 +195,11 @@ GenerateDefault_pickupEnergy (SOLARSYS_S
 }
 
 COUNT
-GenerateDefault_generateLife (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateDefault_generateLife (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
-	GenerateLifeForms (&solarSys->SysInfo, &whichNode);
+	return GenerateLifeForms (&solarSys->SysInfo, whichNode, info);
 	(void) world;
-	return whichNode;
 }
 
 bool
@@ -226,20 +214,21 @@ GenerateDefault_pickupLife (SOLARSYS_STA
 }
 
 COUNT
-GenerateDefault_generateArtifact (SOLARSYS_STATE *solarSys, COUNT whichNode)
+GenerateDefault_generateArtifact (const SOLARSYS_STATE *solarSys,
+		COUNT whichNode, NODE_INFO *info)
 {
 	// Generate an energy node at a random location
-	GenerateRandomNodes (&solarSys->SysInfo, ENERGY_SCAN, 1, 0, &whichNode);
-	return whichNode;
+	return GenerateRandomNodes (&solarSys->SysInfo, ENERGY_SCAN, 1, 0,
+			whichNode, info);
 }
 
 COUNT
-GenerateDefault_generateRuins (SOLARSYS_STATE *solarSys, COUNT whichNode)
+GenerateDefault_generateRuins (const SOLARSYS_STATE *solarSys,
+		COUNT whichNode, NODE_INFO *info)
 {
 	// Generate a standard spread of city ruins of a destroyed civilization
-	GenerateRandomNodes (&solarSys->SysInfo, ENERGY_SCAN, NUM_RACE_RUINS,
-			0, &whichNode);
-	return whichNode;
+	return GenerateRandomNodes (&solarSys->SysInfo, ENERGY_SCAN, NUM_RACE_RUINS,
+			0, whichNode, info);
 }
 
 static inline void
@@ -309,7 +298,7 @@ GeneratePlanets (SOLARSYS_STATE *solarSy
 		BYTE num_moons;
 		BYTE type;
 
-		rand_val = TFB_Random ();
+		rand_val = RandomContext_Random (SysGenRNG);
 		byte_val = LOBYTE (rand_val);
 
 		num_moons = 0;
diff -ruNp src.orig/uqm/planets/generate/gendefault.h src/uqm/planets/generate/gendefault.h
--- src.orig/uqm/planets/generate/gendefault.h	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/generate/gendefault.h	2017-11-21 19:39:56 -0600
@@ -21,22 +21,26 @@
 #include "../planets.h"
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 bool GenerateDefault_initNpcs (SOLARSYS_STATE *solarSys);
 bool GenerateDefault_reinitNpcs (SOLARSYS_STATE *solarSys);
 bool GenerateDefault_uninitNpcs (SOLARSYS_STATE *solarSys);
 bool GenerateDefault_generatePlanets (SOLARSYS_STATE *solarSys);
 bool GenerateDefault_generateMoons (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *planet);
-bool GenerateDefault_generateName (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world);
+bool GenerateDefault_generateName (const SOLARSYS_STATE *,
+		const PLANET_DESC *world);
 bool GenerateDefault_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-COUNT GenerateDefault_generateMinerals (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-COUNT GenerateDefault_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-COUNT GenerateDefault_generateLife (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+COUNT GenerateDefault_generateMinerals (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
+COUNT GenerateDefault_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
+COUNT GenerateDefault_generateLife (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 bool GenerateDefault_pickupMinerals (SOLARSYS_STATE *, PLANET_DESC *world,
 		COUNT whichNode);
 bool GenerateDefault_pickupEnergy (SOLARSYS_STATE *, PLANET_DESC *world,
@@ -44,13 +48,19 @@ bool GenerateDefault_pickupEnergy (SOLAR
 bool GenerateDefault_pickupLife (SOLARSYS_STATE *, PLANET_DESC *world,
 		COUNT whichNode);
 
-COUNT GenerateDefault_generateArtifact (SOLARSYS_STATE *, COUNT whichNode);
-COUNT GenerateDefault_generateRuins (SOLARSYS_STATE *, COUNT whichNode);
+COUNT GenerateDefault_generateArtifact (const SOLARSYS_STATE *,
+		COUNT whichNode, NODE_INFO *info);
+COUNT GenerateDefault_generateRuins (const SOLARSYS_STATE *,
+		COUNT whichNode, NODE_INFO *info);
 bool GenerateDefault_landerReport (SOLARSYS_STATE *);
 bool GenerateDefault_landerReportCycle (SOLARSYS_STATE *);
 
 
 extern const GenerateFunctions generateDefaultFunctions;
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* GENDEFAULT_H */
 
diff -ruNp src.orig/uqm/planets/generate/gendru.c src/uqm/planets/generate/gendru.c
--- src.orig/uqm/planets/generate/gendru.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/generate/gendru.c	2017-11-21 19:39:56 -0600
@@ -33,8 +33,8 @@
 static bool GenerateDruuge_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateDruuge_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateDruuge_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateDruuge_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateDruuge_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -88,7 +88,7 @@ GenerateDruuge_generateOrbital (SOLARSYS
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		if (ActivateStarShip (DRUUGE_SHIP, SPHERE_TRACKING))
+		if (StartSphereTracking (DRUUGE_SHIP))
 		{
 			NotifyOthers (DRUUGE_SHIP, IPNL_ALL_CLEAR);
 			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
@@ -156,12 +156,12 @@ GenerateDruuge_pickupEnergy (SOLARSYS_ST
 }
 
 static COUNT
-GenerateDruuge_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateDruuge_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
+		return GenerateDefault_generateRuins (solarSys, whichNode, info);
 	}
 
 	return 0;
diff -ruNp src.orig/uqm/planets/generate/genilw.c src/uqm/planets/generate/genilw.c
--- src.orig/uqm/planets/generate/genilw.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/generate/genilw.c	2017-11-21 19:39:56 -0600
@@ -30,8 +30,8 @@
 static bool GenerateIlwrath_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateIlwrath_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateIlwrath_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateIlwrath_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateIlwrath_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -78,7 +78,7 @@ GenerateIlwrath_generateOrbital (SOLARSY
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		if (ActivateStarShip (ILWRATH_SHIP, SPHERE_TRACKING))
+		if (StartSphereTracking (ILWRATH_SHIP))
 		{
 			NotifyOthers (ILWRATH_SHIP, IPNL_ALL_CLEAR);
 			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
@@ -123,12 +123,12 @@ GenerateIlwrath_generateOrbital (SOLARSY
 }
 
 static COUNT
-GenerateIlwrath_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateIlwrath_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
+		return GenerateDefault_generateRuins (solarSys, whichNode, info);
 	}
 
 	return 0;
diff -ruNp src.orig/uqm/planets/generate/genmel.c src/uqm/planets/generate/genmel.c
--- src.orig/uqm/planets/generate/genmel.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/generate/genmel.c	2017-11-21 19:39:56 -0600
@@ -18,7 +18,8 @@
 
 #include "genall.h"
 #include "../../build.h"
-#include "../../encount.h"
+#include "../../gendef.h"
+#include "../../starmap.h"
 #include "../../globdata.h"
 #include "../../state.h"
 #include "libs/log.h"
@@ -26,7 +27,6 @@
 
 static bool GenerateMelnorme_initNpcs (SOLARSYS_STATE *solarSys);
 
-static int SelectMelnormeRefVar (void);
 static DWORD GetMelnormeRef (void);
 static void SetMelnormeRef (DWORD Ref);
 
@@ -65,49 +65,43 @@ GenerateMelnorme_initNpcs (SOLARSYS_STAT
 	return true;
 }
 
-
-static int
-SelectMelnormeRefVar (void)
-{
-	switch (CurStarDescPtr->Index)
-	{
-		case MELNORME0_DEFINED: return MELNORME0_GRPOFFS0;
-		case MELNORME1_DEFINED: return MELNORME1_GRPOFFS0;
-		case MELNORME2_DEFINED: return MELNORME2_GRPOFFS0;
-		case MELNORME3_DEFINED: return MELNORME3_GRPOFFS0;
-		case MELNORME4_DEFINED: return MELNORME4_GRPOFFS0;
-		case MELNORME5_DEFINED: return MELNORME5_GRPOFFS0;
-		case MELNORME6_DEFINED: return MELNORME6_GRPOFFS0;
-		case MELNORME7_DEFINED: return MELNORME7_GRPOFFS0;
-		case MELNORME8_DEFINED: return MELNORME8_GRPOFFS0;
-		default:
-			return -1;
-	}
-}
-
 static DWORD
 GetMelnormeRef (void)
 {
-	int RefVar = SelectMelnormeRefVar ();
-	if (RefVar < 0)
+	switch (CurStarDescPtr->Index)
 	{
-		log_add (log_Warning, "GetMelnormeRef(): reference unknown");
-		return 0;
+		case MELNORME0_DEFINED: return GET_GAME_STATE (MELNORME0_GRPOFFS);
+		case MELNORME1_DEFINED: return GET_GAME_STATE (MELNORME1_GRPOFFS);
+		case MELNORME2_DEFINED: return GET_GAME_STATE (MELNORME2_GRPOFFS);
+		case MELNORME3_DEFINED: return GET_GAME_STATE (MELNORME3_GRPOFFS);
+		case MELNORME4_DEFINED: return GET_GAME_STATE (MELNORME4_GRPOFFS);
+		case MELNORME5_DEFINED: return GET_GAME_STATE (MELNORME5_GRPOFFS);
+		case MELNORME6_DEFINED: return GET_GAME_STATE (MELNORME6_GRPOFFS);
+		case MELNORME7_DEFINED: return GET_GAME_STATE (MELNORME7_GRPOFFS);
+		case MELNORME8_DEFINED: return GET_GAME_STATE (MELNORME8_GRPOFFS);
+		default:
+			log_add (log_Warning, "GetMelnormeRef(): reference unknown");
+			return 0;
 	}
-
-	return GET_GAME_STATE_32 (RefVar);
 }
 
 static void
 SetMelnormeRef (DWORD Ref)
 {
-	int RefVar = SelectMelnormeRefVar ();
-	if (RefVar < 0)
+	switch (CurStarDescPtr->Index)
 	{
-		log_add (log_Warning, "SetMelnormeRef(): reference unknown");
-		return;
+		case MELNORME0_DEFINED: SET_GAME_STATE (MELNORME0_GRPOFFS, Ref); break;
+		case MELNORME1_DEFINED: SET_GAME_STATE (MELNORME1_GRPOFFS, Ref); break;
+		case MELNORME2_DEFINED: SET_GAME_STATE (MELNORME2_GRPOFFS, Ref); break;
+		case MELNORME3_DEFINED: SET_GAME_STATE (MELNORME3_GRPOFFS, Ref); break;
+		case MELNORME4_DEFINED: SET_GAME_STATE (MELNORME4_GRPOFFS, Ref); break;
+		case MELNORME5_DEFINED: SET_GAME_STATE (MELNORME5_GRPOFFS, Ref); break;
+		case MELNORME6_DEFINED: SET_GAME_STATE (MELNORME6_GRPOFFS, Ref); break;
+		case MELNORME7_DEFINED: SET_GAME_STATE (MELNORME7_GRPOFFS, Ref); break;
+		case MELNORME8_DEFINED: SET_GAME_STATE (MELNORME8_GRPOFFS, Ref); break;
+		default:
+			log_add (log_Warning, "SetMelnormeRef(): reference unknown");
+			return;
 	}
-
-	SET_GAME_STATE_32 (RefVar, Ref);
 }
 
diff -ruNp src.orig/uqm/planets/generate/genmyc.c src/uqm/planets/generate/genmyc.c
--- src.orig/uqm/planets/generate/genmyc.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/generate/genmyc.c	2017-11-21 19:39:56 -0600
@@ -22,7 +22,8 @@
 #include "../scan.h"
 #include "../../build.h"
 #include "../../comm.h"
-#include "../../encount.h"
+#include "../../gendef.h"
+#include "../../starmap.h"
 #include "../../globdata.h"
 #include "../../ipdisp.h"
 #include "../../nameref.h"
@@ -34,10 +35,10 @@
 static bool GenerateMycon_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateMycon_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateMycon_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static COUNT GenerateMycon_generateLife (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateMycon_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
+static COUNT GenerateMycon_generateLife (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateMycon_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -88,7 +89,7 @@ GenerateMycon_generateOrbital (SOLARSYS_
 	{
 		if ((CurStarDescPtr->Index == MYCON_DEFINED
 				|| CurStarDescPtr->Index == SUN_DEVICE_DEFINED)
-				&& ActivateStarShip (MYCON_SHIP, SPHERE_TRACKING))
+				&& StartSphereTracking (MYCON_SHIP))
 		{
 			if (CurStarDescPtr->Index == MYCON_DEFINED
 					|| !GET_GAME_STATE (SUN_DEVICE_UNGUARDED))
@@ -141,9 +142,7 @@ GenerateMycon_generateOrbital (SOLARSYS_
 						return true;
 
 					SET_GAME_STATE (SUN_DEVICE_UNGUARDED, 1);
-					LockMutex (GraphicsLock);
 					RepairSISBorder ();
-					UnlockMutex (GraphicsLock);
 				}
 			}
 		}
@@ -188,8 +187,8 @@ GenerateMycon_generateOrbital (SOLARSYS_
 }
 
 static COUNT
-GenerateMycon_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateMycon_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (CurStarDescPtr->Index == SUN_DEVICE_DEFINED
 			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
@@ -201,7 +200,7 @@ GenerateMycon_generateEnergy (SOLARSYS_S
 			return 0;
 		}
 
-		return GenerateDefault_generateArtifact (solarSys, whichNode);
+		return GenerateDefault_generateArtifact (solarSys, whichNode, info);
 	}
 
 	if ((CurStarDescPtr->Index == EGG_CASE0_DEFINED
@@ -218,7 +217,7 @@ GenerateMycon_generateEnergy (SOLARSYS_S
 			return 0;
 		}
 
-		return GenerateDefault_generateArtifact (solarSys, whichNode);
+		return GenerateDefault_generateArtifact (solarSys, whichNode, info);
 	}
 
 	return 0;
@@ -274,12 +273,14 @@ GenerateMycon_pickupEnergy (SOLARSYS_STA
 }
 
 static COUNT
-GenerateMycon_generateLife (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateMycon_generateLife (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
+	// Gee, I wonder why there isn't any life in Mycon systems...
 	(void) whichNode;
 	(void) solarSys;
 	(void) world;
+	(void) info;
 	return 0;
 }
 
diff -ruNp src.orig/uqm/planets/generate/genorz.c src/uqm/planets/generate/genorz.c
--- src.orig/uqm/planets/generate/genorz.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/generate/genorz.c	2017-11-21 19:39:56 -0600
@@ -21,7 +21,8 @@
 #include "../planets.h"
 #include "../../build.h"
 #include "../../comm.h"
-#include "../../encount.h"
+#include "../../gendef.h"
+#include "../../starmap.h"
 #include "../../globdata.h"
 #include "../../ipdisp.h"
 #include "../../nameref.h"
@@ -33,8 +34,8 @@
 static bool GenerateOrz_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateOrz_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateOrz_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateOrz_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateOrz_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -92,7 +93,7 @@ GenerateOrz_generateOrbital (SOLARSYS_ST
 
 		if ((CurStarDescPtr->Index == ORZ_DEFINED
 				|| !GET_GAME_STATE (TAALO_UNPROTECTED))
-				&& ActivateStarShip (ORZ_SHIP, SPHERE_TRACKING))
+				&& StartSphereTracking (ORZ_SHIP))
 		{
 			NotifyOthers (ORZ_SHIP, IPNL_ALL_CLEAR);
 			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
@@ -134,9 +135,7 @@ GenerateOrz_generateOrbital (SOLARSYS_ST
 				if (OrzSurvivors)
 					return true;
 
-				LockMutex (GraphicsLock);
 				RepairSISBorder ();
-				UnlockMutex (GraphicsLock);
 			}
 		}
 
@@ -167,8 +166,8 @@ GenerateOrz_generateOrbital (SOLARSYS_ST
 }
 
 static COUNT
-GenerateOrz_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateOrz_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (CurStarDescPtr->Index == TAALO_PROTECTOR_DEFINED
 			&& matchWorld (solarSys, world, 1, 2))
@@ -180,13 +179,13 @@ GenerateOrz_generateEnergy (SOLARSYS_STA
 			return 0;
 		}
 
-		return GenerateDefault_generateArtifact (solarSys, whichNode);
+		return GenerateDefault_generateArtifact (solarSys, whichNode, info);
 	}
 
 	if (CurStarDescPtr->Index == ORZ_DEFINED
 			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
+		return GenerateDefault_generateRuins (solarSys, whichNode, info);
 	}
 
 	return 0;
diff -ruNp src.orig/uqm/planets/generate/genpet.c src/uqm/planets/generate/genpet.c
--- src.orig/uqm/planets/generate/genpet.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/generate/genpet.c	2017-11-21 19:39:56 -0600
@@ -21,6 +21,7 @@
 #include "../../build.h"
 #include "../../comm.h"
 #include "../../encount.h"
+#include "../../starmap.h"
 #include "../../globdata.h"
 #include "../../ipdisp.h"
 #include "../../nameref.h"
@@ -32,8 +33,8 @@
 static bool GenerateTalkingPet_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateTalkingPet_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateTalkingPet_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateTalkingPet_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateTalkingPet_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -82,14 +83,14 @@ GenerateTalkingPet_generateOrbital (SOLA
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET)
 			&& (GET_GAME_STATE (UMGAH_ZOMBIE_BLOBBIES)
 			|| !GET_GAME_STATE (TALKING_PET)
-			|| ActivateStarShip (UMGAH_SHIP, SPHERE_TRACKING)))
+			|| StartSphereTracking (UMGAH_SHIP)))
 	{
 		NotifyOthers (UMGAH_SHIP, IPNL_ALL_CLEAR);
 		PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
 		ReinitQueue (&GLOBAL (ip_group_q));
 		assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
 
-		if (ActivateStarShip (UMGAH_SHIP, SPHERE_TRACKING))
+		if (StartSphereTracking (UMGAH_SHIP))
 		{
 			GLOBAL (CurrentActivity) |= START_INTERPLANETARY;
 			SET_GAME_STATE (GLOBAL_FLAGS_AND_DATA, 1 << 7);
@@ -128,7 +129,7 @@ GenerateTalkingPet_generateOrbital (SOLA
 				// Defeated the zombie fleet.
 				InitCommunication (TALKING_PET_CONVERSATION);
 			}
-			else if (!(ActivateStarShip (UMGAH_SHIP, SPHERE_TRACKING)))
+			else if (!(StartSphereTracking (UMGAH_SHIP)))
 			{
 				// The Kohr-Ah have destroyed the Umgah, but the
 				// talking pet survived.
@@ -160,12 +161,12 @@ GenerateTalkingPet_generateOrbital (SOLA
 }
 
 static COUNT
-GenerateTalkingPet_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateTalkingPet_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
+		return GenerateDefault_generateRuins (solarSys, whichNode, info);
 	}
 
 	return 0;
@@ -211,17 +212,18 @@ ZapToUrquanEncounter (void)
 		TemplatePtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
 		EncounterPtr->origin = TemplatePtr->loc;
 		EncounterPtr->radius = TemplatePtr->actual_strength;
-		EncounterPtr->SD.Type = URQUAN_SHIP;
-		EncounterPtr->SD.Index = MAKE_BYTE (1, 0) | ONE_SHOT_ENCOUNTER;
+		EncounterPtr->race_id = URQUAN_SHIP;
+		EncounterPtr->num_ships = 1;
+		EncounterPtr->flags = ONE_SHOT_ENCOUNTER;
 		BSIPtr = &EncounterPtr->ShipList[0];
 		BSIPtr->race_id = URQUAN_SHIP;
 		BSIPtr->crew_level = TemplatePtr->crew_level;
 		BSIPtr->max_crew = TemplatePtr->max_crew;
 		BSIPtr->max_energy = TemplatePtr->max_energy;
-		EncounterPtr->SD.star_pt.x = 5288;
-		EncounterPtr->SD.star_pt.y = 4892;
-		EncounterPtr->log_x = UNIVERSE_TO_LOGX (EncounterPtr->SD.star_pt.x);
-		EncounterPtr->log_y = UNIVERSE_TO_LOGY (EncounterPtr->SD.star_pt.y);
+		EncounterPtr->loc_pt.x = 5288;
+		EncounterPtr->loc_pt.y = 4892;
+		EncounterPtr->log_x = UNIVERSE_TO_LOGX (EncounterPtr->loc_pt.x);
+		EncounterPtr->log_y = UNIVERSE_TO_LOGY (EncounterPtr->loc_pt.y);
 		GLOBAL_SIS (log_x) = EncounterPtr->log_x;
 		GLOBAL_SIS (log_y) = EncounterPtr->log_y;
 		UnlockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
@@ -229,19 +231,16 @@ ZapToUrquanEncounter (void)
 		{
 #define LOST_DAYS 15
 			SleepThreadUntil (FadeScreen (FadeAllToBlack, ONE_SECOND * 2));
-			LockMutex (GraphicsLock);
 			MoveGameClockDays (LOST_DAYS);
-			UnlockMutex (GraphicsLock);
 		}
 
 		GLOBAL (CurrentActivity) = MAKE_WORD (IN_HYPERSPACE, 0) | START_ENCOUNTER;
 
-		dx = CurStarDescPtr->star_pt.x - EncounterPtr->SD.star_pt.x;
-		dy = CurStarDescPtr->star_pt.y - EncounterPtr->SD.star_pt.y;
+		dx = CurStarDescPtr->star_pt.x - EncounterPtr->loc_pt.x;
+		dy = CurStarDescPtr->star_pt.y - EncounterPtr->loc_pt.y;
 		dx = (SIZE)square_root ((long)dx * dx + (long)dy * dy)
 				+ (FUEL_TANK_SCALE >> 1);
 
-		LockMutex (GraphicsLock);
 		DeltaSISGauges (0, -dx, 0);
 		if (GLOBAL_SIS (FuelOnBoard) < 5 * FUEL_TANK_SCALE)
 		{
@@ -250,8 +249,7 @@ ZapToUrquanEncounter (void)
 			DeltaSISGauges (0, dx, 0);
 		}
 		DrawSISMessage (NULL);
-		DrawHyperCoords (EncounterPtr->SD.star_pt);
-		UnlockMutex (GraphicsLock);
+		DrawHyperCoords (EncounterPtr->loc_pt);
 
 		UnlockEncounter (hEncounter);
 	}
diff -ruNp src.orig/uqm/planets/generate/genpku.c src/uqm/planets/generate/genpku.c
--- src.orig/uqm/planets/generate/genpku.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/generate/genpku.c	2017-11-21 19:39:56 -0600
@@ -31,8 +31,8 @@
 static bool GeneratePkunk_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GeneratePkunk_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GeneratePkunk_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GeneratePkunk_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GeneratePkunk_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -79,7 +79,7 @@ GeneratePkunk_generateOrbital (SOLARSYS_
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		if (ActivateStarShip (PKUNK_SHIP, SPHERE_TRACKING))
+		if (StartSphereTracking (PKUNK_SHIP))
 		{
 			NotifyOthers (PKUNK_SHIP, IPNL_ALL_CLEAR);
 			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
@@ -146,12 +146,12 @@ GeneratePkunk_pickupEnergy (SOLARSYS_STA
 }
 
 static COUNT
-GeneratePkunk_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GeneratePkunk_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
+		return GenerateDefault_generateRuins (solarSys, whichNode, info);
 	}
 
 	return 0;
diff -ruNp src.orig/uqm/planets/generate/genrain.c src/uqm/planets/generate/genrain.c
--- src.orig/uqm/planets/generate/genrain.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/generate/genrain.c	2017-11-21 19:39:56 -0600
@@ -18,7 +18,8 @@
 
 #include "genall.h"
 #include "../planets.h"
-#include "../../encount.h"
+#include "../../gendef.h"
+#include "../../starmap.h"
 #include "../../globdata.h"
 #include "libs/mathlib.h"
 
diff -ruNp src.orig/uqm/planets/generate/gensam.c src/uqm/planets/generate/gensam.c
--- src.orig/uqm/planets/generate/gensam.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/generate/gensam.c	2017-11-21 19:39:56 -0600
@@ -150,7 +150,7 @@ GenerateSaMatra_generateMoons (SOLARSYS_
 
 		solarSys->MoonDesc[0].data_index = SA_MATRA;
 		solarSys->MoonDesc[0].radius = MIN_MOON_RADIUS + (2 * MOON_DELTA);
-		rand_val = TFB_Random ();
+		rand_val = RandomContext_Random (SysGenRNG);
 		angle = NORMALIZE_ANGLE (LOWORD (rand_val));
 		solarSys->MoonDesc[0].location.x =
 				COSINE (angle, solarSys->MoonDesc[0].radius);
@@ -215,9 +215,8 @@ GenerateSaMatra_generateOrbital (SOLARSY
 				EncounterRace = -1;
 				GLOBAL (CurrentActivity) = IN_LAST_BATTLE | START_ENCOUNTER;
 				if (GET_GAME_STATE (YEHAT_CIVIL_WAR)
-						&& ActivateStarShip (YEHAT_SHIP, SPHERE_TRACKING)
-						&& ActivateStarShip (YEHAT_REBEL_SHIP,
-						FEASIBILITY_STUDY))
+						&& StartSphereTracking (YEHAT_SHIP)
+						&& EscortFeasibilityStudy (YEHAT_REBEL_SHIP))
 					InitCommunication (YEHAT_REBEL_CONVERSATION);
 			}
 		}
@@ -236,7 +235,7 @@ BuildUrquanGuard (SOLARSYS_STATE *solarS
 	POINT org;
 	HIPGROUP hGroup, hNextGroup;
 
-	GLOBAL (BattleGroupRef) = GET_GAME_STATE_32 (SAMATRA_GRPOFFS0);
+	GLOBAL (BattleGroupRef) = GET_GAME_STATE (SAMATRA_GRPOFFS);
 
 	if (!GET_GAME_STATE (KOHR_AH_FRENZY))
 	{
@@ -257,7 +256,7 @@ BuildUrquanGuard (SOLARSYS_STATE *solarS
 	if (GLOBAL (BattleGroupRef) == 0)
 	{
 		GLOBAL (BattleGroupRef) = PutGroupInfo (GROUPS_ADD_NEW, 1);
-		SET_GAME_STATE_32 (SAMATRA_GRPOFFS0, GLOBAL (BattleGroupRef));
+		SET_GAME_STATE (SAMATRA_GRPOFFS, GLOBAL (BattleGroupRef));
 	}
 
 #define NUM_URQUAN_GUARDS0 12
diff -ruNp src.orig/uqm/planets/generate/genshof.c src/uqm/planets/generate/genshof.c
--- src.orig/uqm/planets/generate/genshof.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/generate/genshof.c	2017-11-21 19:39:56 -0600
@@ -57,7 +57,7 @@ GenerateShofixti_initNpcs (SOLARSYS_STAT
 			|| (!GET_GAME_STATE (SHOFIXTI_BRO_KIA)
 			&& GET_GAME_STATE (MAIDENS_ON_SHIP))))
 	{
-		GLOBAL (BattleGroupRef) = GET_GAME_STATE_32 (SHOFIXTI_GRPOFFS0);
+		GLOBAL (BattleGroupRef) = GET_GAME_STATE (SHOFIXTI_GRPOFFS);
 		if (GLOBAL (BattleGroupRef) == 0
 				|| !GetGroupInfo (GLOBAL (BattleGroupRef), GROUP_INIT_IP))
 		{
@@ -82,7 +82,7 @@ GenerateShofixti_initNpcs (SOLARSYS_STAT
 			GLOBAL (BattleGroupRef) = PutGroupInfo (
 					GLOBAL (BattleGroupRef), 1);
 			ReinitQueue (&GLOBAL (npc_built_ship_q));
-			SET_GAME_STATE_32 (SHOFIXTI_GRPOFFS0, GLOBAL (BattleGroupRef));
+			SET_GAME_STATE (SHOFIXTI_GRPOFFS, GLOBAL (BattleGroupRef));
 		}
 	}
 
diff -ruNp src.orig/uqm/planets/generate/gensol.c src/uqm/planets/generate/gensol.c
--- src.orig/uqm/planets/generate/gensol.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/generate/gensol.c	2017-11-21 19:39:56 -0600
@@ -35,14 +35,14 @@ static bool GenerateSol_reinitNpcs (SOLA
 static bool GenerateSol_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateSol_generateMoons (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *planet);
-static bool GenerateSol_generateName (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world);
+static bool GenerateSol_generateName (const SOLARSYS_STATE *,
+		const PLANET_DESC *world);
 static bool GenerateSol_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateSol_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static COUNT GenerateSol_generateLife (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateSol_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
+static COUNT GenerateSol_generateLife (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateSol_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -70,13 +70,13 @@ const GenerateFunctions generateSolFunct
 static bool
 GenerateSol_initNpcs (SOLARSYS_STATE *solarSys)
 {
-	GLOBAL (BattleGroupRef) = GET_GAME_STATE_32 (URQUAN_PROBE_GRPOFFS0);
+	GLOBAL (BattleGroupRef) = GET_GAME_STATE (URQUAN_PROBE_GRPOFFS);
 	if (GLOBAL (BattleGroupRef) == 0)
 	{
 		CloneShipFragment (URQUAN_DRONE_SHIP, &GLOBAL (npc_built_ship_q), 0);
 		GLOBAL (BattleGroupRef) = PutGroupInfo (GROUPS_ADD_NEW, 1);
 		ReinitQueue (&GLOBAL (npc_built_ship_q));
-		SET_GAME_STATE_32 (URQUAN_PROBE_GRPOFFS0, GLOBAL (BattleGroupRef));
+		SET_GAME_STATE (URQUAN_PROBE_GRPOFFS, GLOBAL (BattleGroupRef));
 	}
 
 	if (!init_probe ())
@@ -108,7 +108,7 @@ GenerateSol_generatePlanets (SOLARSYS_ST
 	COUNT planetI;
 
 #define SOL_SEED 334241042L
-	TFB_SeedRandom (SOL_SEED);
+	RandomContext_SeedRandom (SysGenRNG, SOL_SEED);
 
 	solarSys->SunDesc[0].NumPlanets = 9;
 	for (planetI = 0; planetI < 9; ++planetI)
@@ -118,7 +118,8 @@ GenerateSol_generatePlanets (SOLARSYS_ST
 		UWORD word_val;
 		PLANET_DESC *pCurDesc = &solarSys->PlanetDesc[planetI];
 
-		pCurDesc->rand_seed = rand_val = TFB_Random ();
+		pCurDesc->rand_seed = RandomContext_Random (SysGenRNG);
+		rand_val = pCurDesc->rand_seed;
 		word_val = LOWORD (rand_val);
 		angle = NORMALIZE_ANGLE ((COUNT)HIBYTE (word_val));
 
@@ -208,7 +209,7 @@ GenerateSol_generateMoons (SOLARSYS_STAT
 			solarSys->MoonDesc[1].data_index = SELENIC_WORLD;
 			solarSys->MoonDesc[1].radius = MIN_MOON_RADIUS
 					+ (MAX_MOONS - 1) * MOON_DELTA;
-			rand_val = TFB_Random ();
+			rand_val = RandomContext_Random (SysGenRNG);
 			angle = NORMALIZE_ANGLE (LOWORD (rand_val));
 			solarSys->MoonDesc[1].location.x =
 					COSINE (angle, solarSys->MoonDesc[1].radius);
@@ -240,7 +241,8 @@ GenerateSol_generateMoons (SOLARSYS_STAT
 }
 
 static bool
-GenerateSol_generateName (SOLARSYS_STATE *solarSys, PLANET_DESC *world)
+GenerateSol_generateName (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world)
 {
 	COUNT planetNr = planetIndex (solarSys, world);
 	utf8StringCopy (GLOBAL_SIS (PlanetName), sizeof (GLOBAL_SIS (PlanetName)),
@@ -269,15 +271,12 @@ GenerateSol_generateOrbital (SOLARSYS_ST
 		return true;
 	}
 
-	rand_val = DoPlanetaryAnalysis (&solarSys->SysInfo, world);
-	if (rand_val)
-	{
-		COUNT i;
+	DoPlanetaryAnalysis (&solarSys->SysInfo, world);
+	rand_val = RandomContext_GetSeed (SysGenRNG);
 
-		solarSys->SysInfo.PlanetInfo.ScanSeed[MINERAL_SCAN] = rand_val;
-		i = (COUNT)~0;
-		rand_val = GenerateMineralDeposits (&solarSys->SysInfo, &i);
-	}
+	solarSys->SysInfo.PlanetInfo.ScanSeed[MINERAL_SCAN] = rand_val;
+	GenerateMineralDeposits (&solarSys->SysInfo, GENERATE_ALL, NULL);
+	rand_val = RandomContext_GetSeed (SysGenRNG);
 
 	planetNr = planetIndex (solarSys, world);
 	if (worldIsPlanet (solarSys, world))
@@ -405,8 +404,7 @@ GenerateSol_generateOrbital (SOLARSYS_ST
 		}
 
 		solarSys->SysInfo.PlanetInfo.SurfaceGravity =
-				CalcGravity (solarSys->SysInfo.PlanetInfo.PlanetDensity,
-				solarSys->SysInfo.PlanetInfo.PlanetRadius);
+				CalcGravity (&solarSys->SysInfo.PlanetInfo);
 		LoadPlanet (planetNr == 2 ?
 				CaptureDrawable (LoadGraphic (EARTH_MASK_ANIM)) : NULL);
 	}
@@ -421,6 +419,10 @@ GenerateSol_generateOrbital (SOLARSYS_ST
 		switch (planetNr)
 		{
 			case 2: /* moons of EARTH */
+				// NOTE: Even though we save the seed here, it is irrelevant.
+				//   The seed will be used to randomly place the tractors, but
+				//   since they are mobile, they will be moved to different
+				//   locations not governed by this seed.
 				solarSys->SysInfo.PlanetInfo.ScanSeed[BIOLOGICAL_SCAN] =
 						rand_val;
 
@@ -505,8 +507,7 @@ GenerateSol_generateOrbital (SOLARSYS_ST
 		}
 
 		solarSys->SysInfo.PlanetInfo.SurfaceGravity =
-				CalcGravity (solarSys->SysInfo.PlanetInfo.PlanetDensity,
-				solarSys->SysInfo.PlanetInfo.PlanetRadius);
+				CalcGravity (&solarSys->SysInfo.PlanetInfo);
 		LoadPlanet (NULL);
 	}
 
@@ -514,8 +515,8 @@ GenerateSol_generateOrbital (SOLARSYS_ST
 }
 
 static COUNT
-GenerateSol_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateSol_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 8, MATCH_PLANET))
 	{
@@ -527,8 +528,11 @@ GenerateSol_generateEnergy (SOLARSYS_STA
 			return 0;
 		}
 
-		solarSys->SysInfo.PlanetInfo.CurPt.x = 20;
-		solarSys->SysInfo.PlanetInfo.CurPt.y = MAP_HEIGHT - 8;
+		if (info)
+		{
+			info->loc_pt.x = 20;
+			info->loc_pt.y = MAP_HEIGHT - 8;
+		}
 
 		return 1; // only matters when count is requested
 	}
@@ -543,8 +547,11 @@ GenerateSol_generateEnergy (SOLARSYS_STA
 			return 0;
 		}
 
-		solarSys->SysInfo.PlanetInfo.CurPt.x = MAP_WIDTH * 3 / 4;
-		solarSys->SysInfo.PlanetInfo.CurPt.y = MAP_HEIGHT * 1 / 4;
+		if (info)
+		{
+			info->loc_pt.x = MAP_WIDTH * 3 / 4;
+			info->loc_pt.y = MAP_HEIGHT * 1 / 4;
+		}
 
 		return 1; // only matters when count is requested
 	}
@@ -595,15 +602,14 @@ GenerateSol_pickupEnergy (SOLARSYS_STATE
 }
 
 static COUNT
-GenerateSol_generateLife (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateSol_generateLife (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 2, 1))
 	{
 		/* Earth Moon */
-		GenerateRandomNodes (&solarSys->SysInfo, BIOLOGICAL_SCAN, 10,
-				NUM_CREATURE_TYPES + 1, &whichNode);
-		return whichNode;
+		return GenerateRandomNodes (&solarSys->SysInfo, BIOLOGICAL_SCAN, 10,
+				NUM_CREATURE_TYPES + 1, whichNode, info);
 	}
 
 	return 0;
diff -ruNp src.orig/uqm/planets/generate/genspa.c src/uqm/planets/generate/genspa.c
--- src.orig/uqm/planets/generate/genspa.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/generate/genspa.c	2017-11-21 19:39:56 -0600
@@ -35,10 +35,10 @@ static bool GenerateSpathi_generateMoons
 		PLANET_DESC *planet);
 static bool GenerateSpathi_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateSpathi_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static COUNT GenerateSpathi_generateLife (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateSpathi_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
+static COUNT GenerateSpathi_generateLife (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateSpathi_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 static bool GenerateSpathi_pickupLife (SOLARSYS_STATE *solarSys,
@@ -102,7 +102,7 @@ GenerateSpathi_generateMoons (SOLARSYS_S
 
 		solarSys->MoonDesc[0].data_index = PELLUCID_WORLD;
 		solarSys->MoonDesc[0].radius = MIN_MOON_RADIUS + MOON_DELTA;
-		angle = NORMALIZE_ANGLE (LOWORD (TFB_Random ()));
+		angle = NORMALIZE_ANGLE (LOWORD (RandomContext_Random (SysGenRNG)));
 		solarSys->MoonDesc[0].location.x =
 				COSINE (angle, solarSys->MoonDesc[0].radius);
 		solarSys->MoonDesc[0].location.y =
@@ -116,13 +116,12 @@ static bool
 GenerateSpathi_generateOrbital (SOLARSYS_STATE *solarSys, PLANET_DESC *world)
 {
 	DWORD rand_val;
-	COUNT i;
 
 	if (matchWorld (solarSys, world, 0, 0))
 	{
 		/* Spathiwa's moon */
 		if (!GET_GAME_STATE (SPATHI_SHIELDED_SELVES)
-				&& ActivateStarShip (SPATHI_SHIP, SPHERE_TRACKING))
+				&& StartSphereTracking (SPATHI_SHIP))
 		{
 			NotifyOthers (SPATHI_SHIP, IPNL_ALL_CLEAR);
 			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
@@ -144,15 +143,16 @@ GenerateSpathi_generateOrbital (SOLARSYS
 			}
 			return true;
 		}
-		rand_val = DoPlanetaryAnalysis (&solarSys->SysInfo, world);
+		
+		DoPlanetaryAnalysis (&solarSys->SysInfo, world);
+		rand_val = RandomContext_GetSeed (SysGenRNG);
 
 		solarSys->SysInfo.PlanetInfo.ScanSeed[BIOLOGICAL_SCAN] = rand_val;
-		i = (COUNT)~0;
-		rand_val = GenerateLifeForms (&solarSys->SysInfo, &i);
+		GenerateLifeForms (&solarSys->SysInfo, GENERATE_ALL, NULL);
+		rand_val = RandomContext_GetSeed (SysGenRNG);
 
 		solarSys->SysInfo.PlanetInfo.ScanSeed[MINERAL_SCAN] = rand_val;
-		i = (COUNT)~0;
-		GenerateMineralDeposits (&solarSys->SysInfo, &i);
+		GenerateMineralDeposits (&solarSys->SysInfo, GENERATE_ALL, NULL);
 
 		solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN] = rand_val;
 
@@ -181,18 +181,18 @@ GenerateSpathi_generateOrbital (SOLARSYS
 	else if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
 		/* visiting Spathiwa */
-		rand_val = DoPlanetaryAnalysis (&solarSys->SysInfo, world);
+		DoPlanetaryAnalysis (&solarSys->SysInfo, world);
+		rand_val = RandomContext_GetSeed (SysGenRNG);
 
 		solarSys->SysInfo.PlanetInfo.ScanSeed[MINERAL_SCAN] = rand_val;
-		i = (COUNT)~0;
-		rand_val = GenerateMineralDeposits (&solarSys->SysInfo, &i);
+		GenerateMineralDeposits (&solarSys->SysInfo, GENERATE_ALL, NULL);
+		rand_val = RandomContext_GetSeed (SysGenRNG);
 
 		solarSys->SysInfo.PlanetInfo.ScanSeed[BIOLOGICAL_SCAN] = rand_val;
 
 		solarSys->SysInfo.PlanetInfo.PlanetRadius = 120;
 		solarSys->SysInfo.PlanetInfo.SurfaceGravity =
-				CalcGravity (solarSys->SysInfo.PlanetInfo.PlanetDensity,
-				solarSys->SysInfo.PlanetInfo.PlanetRadius);
+				CalcGravity (&solarSys->SysInfo.PlanetInfo);
 		solarSys->SysInfo.PlanetInfo.Weather = 0;
 		solarSys->SysInfo.PlanetInfo.Tectonics = 0;
 		solarSys->SysInfo.PlanetInfo.SurfaceTemperature = 31;
@@ -207,8 +207,8 @@ GenerateSpathi_generateOrbital (SOLARSYS
 }
 
 static COUNT
-GenerateSpathi_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateSpathi_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 0, 0))
 	{
@@ -219,7 +219,7 @@ GenerateSpathi_generateEnergy (SOLARSYS_
 			return 0;
 		}
 
-		return GenerateDefault_generateArtifact (solarSys, whichNode);
+		return GenerateDefault_generateArtifact (solarSys, whichNode, info);
 	}
 
 	return 0;
@@ -247,15 +247,14 @@ GenerateSpathi_pickupEnergy (SOLARSYS_ST
 }
 
 static COUNT
-GenerateSpathi_generateLife (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateSpathi_generateLife (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
 		#define NUM_EVIL_ONES  32
-		GenerateRandomNodes (&solarSys->SysInfo, BIOLOGICAL_SCAN, NUM_EVIL_ONES,
-				NUM_CREATURE_TYPES, &whichNode);
-		return whichNode;
+		return GenerateRandomNodes (&solarSys->SysInfo, BIOLOGICAL_SCAN, NUM_EVIL_ONES,
+				NUM_CREATURE_TYPES, whichNode, info);
 	}
 
 	return 0;
diff -ruNp src.orig/uqm/planets/generate/gensup.c src/uqm/planets/generate/gensup.c
--- src.orig/uqm/planets/generate/gensup.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/generate/gensup.c	2017-11-21 19:39:56 -0600
@@ -31,8 +31,8 @@
 static bool GenerateSupox_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateSupox_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateSupox_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateSupox_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateSupox_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -79,7 +79,7 @@ GenerateSupox_generateOrbital (SOLARSYS_
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		if (ActivateStarShip (SUPOX_SHIP, SPHERE_TRACKING))
+		if (StartSphereTracking (SUPOX_SHIP))
 		{
 			NotifyOthers (SUPOX_SHIP, IPNL_ALL_CLEAR);
 			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
@@ -146,12 +146,12 @@ GenerateSupox_pickupEnergy (SOLARSYS_STA
 }
 
 static COUNT
-GenerateSupox_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateSupox_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
+		return GenerateDefault_generateRuins (solarSys, whichNode, info);
 	}
 
 	return 0;
diff -ruNp src.orig/uqm/planets/generate/genthrad.c src/uqm/planets/generate/genthrad.c
--- src.orig/uqm/planets/generate/genthrad.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/generate/genthrad.c	2017-11-21 19:39:56 -0600
@@ -21,7 +21,8 @@
 #include "../planets.h"
 #include "../../build.h"
 #include "../../comm.h"
-#include "../../encount.h"
+#include "../../gendef.h"
+#include "../../starmap.h"
 #include "../../globdata.h"
 #include "../../ipdisp.h"
 #include "../../nameref.h"
@@ -33,8 +34,8 @@
 static bool GenerateThraddash_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateThraddash_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateThraddash_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateThraddash_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateThraddash_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -95,7 +96,7 @@ GenerateThraddash_generateOrbital (SOLAR
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		if (ActivateStarShip (THRADDASH_SHIP, SPHERE_TRACKING)
+		if (StartSphereTracking (THRADDASH_SHIP)
 				&& (CurStarDescPtr->Index == THRADD_DEFINED
 				|| (!GET_GAME_STATE (HELIX_UNPROTECTED)
 				&& (BYTE)(GET_GAME_STATE (THRADD_MISSION) - 1) >= 3)))
@@ -131,9 +132,7 @@ GenerateThraddash_generateOrbital (SOLAR
 					&& (BYTE)(GET_GAME_STATE (THRADD_MISSION) - 1) >= 3))
 				return true;
 
-			LockMutex (GraphicsLock);
 			RepairSISBorder ();
-			UnlockMutex (GraphicsLock);
 		}
 
 		if (CurStarDescPtr->Index == AQUA_HELIX_DEFINED
@@ -160,13 +159,13 @@ GenerateThraddash_generateOrbital (SOLAR
 }
 
 static COUNT
-GenerateThraddash_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode)
+GenerateThraddash_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (CurStarDescPtr->Index == THRADD_DEFINED
 			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
+		return GenerateDefault_generateRuins (solarSys, whichNode, info);
 	}
 
 	if (CurStarDescPtr->Index == AQUA_HELIX_DEFINED
@@ -179,7 +178,7 @@ GenerateThraddash_generateEnergy (SOLARS
 			return 0;
 		}
 
-		return GenerateDefault_generateArtifact (solarSys, whichNode);
+		return GenerateDefault_generateArtifact (solarSys, whichNode, info);
 	}
 
 	return 0;
diff -ruNp src.orig/uqm/planets/generate/genutw.c src/uqm/planets/generate/genutw.c
--- src.orig/uqm/planets/generate/genutw.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/generate/genutw.c	2017-11-21 19:39:56 -0600
@@ -21,7 +21,8 @@
 #include "../planets.h"
 #include "../../build.h"
 #include "../../comm.h"
-#include "../../encount.h"
+#include "../../gendef.h"
+#include "../../starmap.h"
 #include "../../globdata.h"
 #include "../../ipdisp.h"
 #include "../../nameref.h"
@@ -34,8 +35,8 @@ static bool GenerateUtwig_initNpcs (SOLA
 static bool GenerateUtwig_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateUtwig_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateUtwig_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateUtwig_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateUtwig_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -108,7 +109,7 @@ GenerateUtwig_generateOrbital (SOLARSYS_
 	{
 		if ((CurStarDescPtr->Index == UTWIG_DEFINED
 				|| !GET_GAME_STATE (UTWIG_HAVE_ULTRON))
-				&& ActivateStarShip (UTWIG_SHIP, SPHERE_TRACKING))
+				&& StartSphereTracking (UTWIG_SHIP))
 		{
 			NotifyOthers (UTWIG_SHIP, IPNL_ALL_CLEAR);
 			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
@@ -140,7 +141,7 @@ GenerateUtwig_generateOrbital (SOLARSYS_
 
 		if (CurStarDescPtr->Index == BOMB_DEFINED
 				&& !GET_GAME_STATE (BOMB_UNPROTECTED)
-				&& ActivateStarShip (DRUUGE_SHIP, SPHERE_TRACKING))
+				&& StartSphereTracking (DRUUGE_SHIP))
 		{
 			COUNT i;
 
@@ -173,9 +174,7 @@ GenerateUtwig_generateOrbital (SOLARSYS_
 				if (DruugeSurvivors)
 					return true;
 
-				LockMutex (GraphicsLock);
 				RepairSISBorder ();
-				UnlockMutex (GraphicsLock);
 				SET_GAME_STATE (BOMB_UNPROTECTED, 1);
 			}
 		}
@@ -211,13 +210,13 @@ GenerateUtwig_generateOrbital (SOLARSYS_
 }
 
 static COUNT
-GenerateUtwig_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateUtwig_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (CurStarDescPtr->Index == UTWIG_DEFINED
 			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
+		return GenerateDefault_generateRuins (solarSys, whichNode, info);
 	}
 
 	if (CurStarDescPtr->Index == BOMB_DEFINED
@@ -230,7 +229,7 @@ GenerateUtwig_generateEnergy (SOLARSYS_S
 			return 0;
 		}
 
-		return GenerateDefault_generateArtifact (solarSys, whichNode);
+		return GenerateDefault_generateArtifact (solarSys, whichNode, info);
 	}
 
 	return 0;
diff -ruNp src.orig/uqm/planets/generate/genvault.c src/uqm/planets/generate/genvault.c
--- src.orig/uqm/planets/generate/genvault.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/generate/genvault.c	2017-11-21 19:39:56 -0600
@@ -27,8 +27,8 @@
 
 static bool GenerateVault_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateVault_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateVault_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateVault_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -79,12 +79,12 @@ GenerateVault_generateOrbital (SOLARSYS_
 }
 
 static COUNT
-GenerateVault_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateVault_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 0, 0))
 	{
-		return GenerateDefault_generateArtifact (solarSys, whichNode);
+		return GenerateDefault_generateArtifact (solarSys, whichNode, info);
 	}
 
 	return 0;
diff -ruNp src.orig/uqm/planets/generate/genvux.c src/uqm/planets/generate/genvux.c
--- src.orig/uqm/planets/generate/genvux.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/generate/genvux.c	2017-11-21 19:39:56 -0600
@@ -22,7 +22,8 @@
 #include "../planets.h"
 #include "../../build.h"
 #include "../../comm.h"
-#include "../../encount.h"
+#include "../../gendef.h"
+#include "../../starmap.h"
 #include "../../globdata.h"
 #include "../../ipdisp.h"
 #include "../../nameref.h"
@@ -35,10 +36,10 @@
 static bool GenerateVux_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateVux_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateVux_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static COUNT GenerateVux_generateLife (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateVux_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
+static COUNT GenerateVux_generateLife (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateVux_pickupEnergy (SOLARSYS_STATE *, PLANET_DESC *world,
 		COUNT whichNode);
 static bool GenerateVux_pickupLife (SOLARSYS_STATE *, PLANET_DESC *world,
@@ -124,7 +125,7 @@ GenerateVux_generateOrbital (SOLARSYS_ST
 			&& (CurStarDescPtr->Index == VUX_DEFINED
 			|| (CurStarDescPtr->Index == MAIDENS_DEFINED
 			&& !GET_GAME_STATE (ZEX_IS_DEAD))))
-			&& ActivateStarShip (VUX_SHIP, SPHERE_TRACKING))
+			&& StartSphereTracking (VUX_SHIP))
 	{
 		NotifyOthers (VUX_SHIP, IPNL_ALL_CLEAR);
 		PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
@@ -157,9 +158,7 @@ GenerateVux_generateOrbital (SOLARSYS_ST
 					|| !GET_GAME_STATE (ZEX_IS_DEAD))
 				return true;
 
-			LockMutex (GraphicsLock);
 			RepairSISBorder ();
-			UnlockMutex (GraphicsLock);
 		}
 	}
 
@@ -210,8 +209,8 @@ GenerateVux_generateOrbital (SOLARSYS_ST
 }
 
 static COUNT
-GenerateVux_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateVux_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (CurStarDescPtr->Index == MAIDENS_DEFINED
 			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
@@ -223,8 +222,11 @@ GenerateVux_generateEnergy (SOLARSYS_STA
 			return 0;
 		}
 
-		solarSys->SysInfo.PlanetInfo.CurPt.x = MAP_WIDTH / 3;
-		solarSys->SysInfo.PlanetInfo.CurPt.y = MAP_HEIGHT * 5 / 8;
+		if (info)
+		{
+			info->loc_pt.x = MAP_WIDTH / 3;
+			info->loc_pt.y = MAP_HEIGHT * 5 / 8;
+		}
 		
 		return 1; // only matters when count is requested
 	}
@@ -232,7 +234,7 @@ GenerateVux_generateEnergy (SOLARSYS_STA
 	if (CurStarDescPtr->Index == VUX_DEFINED
 			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
+		return GenerateDefault_generateRuins (solarSys, whichNode, info);
 	}
 
 	return 0;
@@ -269,62 +271,37 @@ GenerateVux_pickupEnergy (SOLARSYS_STATE
 }
 
 static COUNT
-GenerateVux_generateLife (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateVux_generateLife (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (CurStarDescPtr->Index == MAIDENS_DEFINED
 			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		COUNT i;
-		DWORD old_rand;
-
-		old_rand = TFB_SeedRandom (
-				solarSys->SysInfo.PlanetInfo.ScanSeed[BIOLOGICAL_SCAN]);
-
-		for (i = 0; i <= whichNode && i < 12; ++i)
+		static const SBYTE life[] =
 		{
-			GenerateRandomLocation (&solarSys->SysInfo);
-			if (i < 4)
-				solarSys->SysInfo.PlanetInfo.CurType = 9;
-			else if (i < 8)
-				solarSys->SysInfo.PlanetInfo.CurType = 14;
-			else /* if (i < 12) */
-				solarSys->SysInfo.PlanetInfo.CurType = 18;
-		}
-		
-		TFB_SeedRandom (old_rand);
-
-		return 12; // only matters when count is requested
+			 9,  9,  9,  9, /* Carousel Beast */
+			14, 14, 14, 14, /* Amorphous Trandicula */
+			18, 18, 18, 18, /* Penguin Cyclops */
+			-1 /* term */
+		};
+		return GeneratePresetLife (&solarSys->SysInfo, life, whichNode, info);
 	}
 
 	if (CurStarDescPtr->Index == VUX_BEAST_DEFINED
 			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		COUNT i;
-		DWORD old_rand;
-
-		old_rand = TFB_SeedRandom (
-				solarSys->SysInfo.PlanetInfo.ScanSeed[BIOLOGICAL_SCAN]);
-
-		for (i = 0; i <= whichNode && i < 11; ++i)
+		static const SBYTE life[] =
 		{
-			GenerateRandomLocation (&solarSys->SysInfo);
-			if (i == 0) /* VUX Beast */
-				solarSys->SysInfo.PlanetInfo.CurType = NUM_CREATURE_TYPES + 2;
-			else if (i <= 5)
-					/* {SPEED_MOTIONLESS | DANGER_NORMAL, MAKE_BYTE (5, 3)}, */
-				solarSys->SysInfo.PlanetInfo.CurType = 3;
-			else /* if (i <= 10) */
-					/* {BEHAVIOR_UNPREDICTABLE | SPEED_SLOW | DANGER_NORMAL, MAKE_BYTE (3, 8)}, */
-				solarSys->SysInfo.PlanetInfo.CurType = 8;
-		}
-		
-		TFB_SeedRandom (old_rand);
-
-		return  11; // only matters when count is requested
+			NUM_CREATURE_TYPES + 2, /* VUX Beast */
+					// Must be the first node, see pickupLife() below
+			3, 3, 3, 3, 3, /* Whackin' Bush */
+			8, 8, 8, 8, 8, /* Glowing Medusa */
+			-1 /* term */
+		};
+		return GeneratePresetLife (&solarSys->SysInfo, life, whichNode, info);
 	}
 
-	return GenerateDefault_generateLife (solarSys, world, whichNode);
+	return GenerateDefault_generateLife (solarSys, world, whichNode, info);
 }
 
 static bool
diff -ruNp src.orig/uqm/planets/generate/genwreck.c src/uqm/planets/generate/genwreck.c
--- src.orig/uqm/planets/generate/genwreck.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/generate/genwreck.c	2017-11-21 19:39:56 -0600
@@ -27,8 +27,8 @@
 
 static bool GenerateWreck_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateWreck_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateWreck_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateWreck_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -73,12 +73,12 @@ GenerateWreck_generateOrbital (SOLARSYS_
 }
 
 static COUNT
-GenerateWreck_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateWreck_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 6, MATCH_PLANET))
 	{
-		return GenerateDefault_generateArtifact (solarSys, whichNode);
+		return GenerateDefault_generateArtifact (solarSys, whichNode, info);
 	}
 
 	return 0;
diff -ruNp src.orig/uqm/planets/generate/genyeh.c src/uqm/planets/generate/genyeh.c
--- src.orig/uqm/planets/generate/genyeh.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/generate/genyeh.c	2017-11-21 19:39:56 -0600
@@ -30,8 +30,8 @@
 static bool GenerateYehat_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateYehat_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateYehat_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateYehat_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateYehat_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -77,7 +77,7 @@ GenerateYehat_generateOrbital (SOLARSYS_
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		if (ActivateStarShip (YEHAT_SHIP, SPHERE_TRACKING))
+		if (StartSphereTracking (YEHAT_SHIP))
 		{
 			NotifyOthers (YEHAT_SHIP, IPNL_ALL_CLEAR);
 			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
@@ -113,12 +113,12 @@ GenerateYehat_generateOrbital (SOLARSYS_
 }
 
 static COUNT
-GenerateYehat_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateYehat_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
+		return GenerateDefault_generateRuins (solarSys, whichNode, info);
 	}
 
 	return 0;
diff -ruNp src.orig/uqm/planets/generate/genzfpscout.c src/uqm/planets/generate/genzfpscout.c
--- src.orig/uqm/planets/generate/genzfpscout.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/generate/genzfpscout.c	2017-11-21 19:39:56 -0600
@@ -49,14 +49,14 @@ GenerateZoqFotPikScout_initNpcs (SOLARSY
 {
 	if (!GET_GAME_STATE (MET_ZOQFOT))
 	{
-		GLOBAL (BattleGroupRef) = GET_GAME_STATE_32 (ZOQFOT_GRPOFFS0);
+		GLOBAL (BattleGroupRef) = GET_GAME_STATE (ZOQFOT_GRPOFFS);
 		if (GLOBAL (BattleGroupRef) == 0)
 		{
 			CloneShipFragment (ZOQFOTPIK_SHIP,
 					&GLOBAL (npc_built_ship_q), 0);
 			GLOBAL (BattleGroupRef) = PutGroupInfo (GROUPS_ADD_NEW, 1);
 			ReinitQueue (&GLOBAL (npc_built_ship_q));
-			SET_GAME_STATE_32 (ZOQFOT_GRPOFFS0, GLOBAL (BattleGroupRef));
+			SET_GAME_STATE (ZOQFOT_GRPOFFS, GLOBAL (BattleGroupRef));
 		}
 	}
 
diff -ruNp src.orig/uqm/planets/generate/genzoq.c src/uqm/planets/generate/genzoq.c
--- src.orig/uqm/planets/generate/genzoq.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/generate/genzoq.c	2017-11-21 19:39:56 -0600
@@ -30,8 +30,8 @@ static bool GenerateZoqFotPik_initNpcs (
 static bool GenerateZoqFotPik_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateZoqFotPik_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateZoqFotPik_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateZoqFotPik_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateZoqFotPik_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -87,7 +87,7 @@ GenerateZoqFotPik_generateOrbital (SOLAR
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		if (ActivateStarShip (ZOQFOTPIK_SHIP, SPHERE_TRACKING))
+		if (StartSphereTracking (ZOQFOTPIK_SHIP))
 		{
 			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
 			ReinitQueue (&GLOBAL (ip_group_q));
@@ -143,12 +143,12 @@ GenerateZoqFotPik_generateOrbital (SOLAR
 }
 
 static COUNT
-GenerateZoqFotPik_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateZoqFotPik_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
+		return GenerateDefault_generateRuins (solarSys, whichNode, info);
 	}
 
 	return 0;
diff -ruNp src.orig/uqm/planets/generate.h src/uqm/planets/generate.h
--- src.orig/uqm/planets/generate.h	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/generate.h	2017-11-21 19:39:56 -0600
@@ -23,6 +23,10 @@ typedef struct GenerateFunctions Generat
 #include "planets.h"
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 /*
  * To do (for further cleanups):
  * - split off generateOrbital in a calculation and an activation
@@ -52,16 +56,16 @@ typedef bool (*GenerateMoonsFunction)(SO
 		PLANET_DESC *planet);
 typedef bool (*GenerateOrbitalFunction)(SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-typedef bool (*GenerateNameFunction)(SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world);
+typedef bool (*GenerateNameFunction)(const SOLARSYS_STATE *,
+		const PLANET_DESC *world);
 // The following functions return the number of objects being generated
 // (or the index of the current object in some cases)
-typedef COUNT (*GenerateMineralsFunction)(SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-typedef COUNT (*GenerateEnergyFunction)(SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-typedef COUNT (*GenerateLifeFunction)(SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+typedef COUNT (*GenerateMineralsFunction)(const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
+typedef COUNT (*GenerateEnergyFunction)(const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
+typedef COUNT (*GenerateLifeFunction)(const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 // The following functions return true if the node should be removed
 // from the surface, i.e. picked up.
 typedef bool (*PickupMineralsFunction)(SOLARSYS_STATE *solarSys,
@@ -98,6 +102,9 @@ struct GenerateFunctions {
 	PickupLifeFunction pickupLife;
 };
 
+#if defined(__cplusplus)
+}
+#endif
 
 #endif  /* GENERATE_H */
 
diff -ruNp src.orig/uqm/planets/gentopo.c src/uqm/planets/gentopo.c
--- src.orig/uqm/planets/gentopo.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/gentopo.c	2017-11-21 19:39:57 -0600
@@ -43,9 +43,10 @@ DeltaTopography (COUNT num_iterations, S
 		DWORD rand_val;
 		SBYTE *lpDst;
 
-		depth_delta = ((((SIZE)TFB_Random () & 1) << 1) - 1) * depth_delta;
+		if ((RandomContext_Random (SysGenRNG) & 1) == 0)
+			depth_delta = -depth_delta;
 
-		rand_val = TFB_Random ();
+		rand_val = RandomContext_Random (SysGenRNG);
 		w1 = LOWORD (rand_val);
 		w2 = HIWORD (rand_val);
 
diff -ruNp src.orig/uqm/planets/lander.c src/uqm/planets/lander.c
--- src.orig/uqm/planets/lander.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/lander.c	2017-11-21 19:39:57 -0600
@@ -23,8 +23,6 @@
 #include "../cons_res.h"
 #include "../controls.h"
 #include "../colors.h"
-// XXX: for CurStarDescPtr and XXX_DEFINED
-#include "../encount.h"
 #include "../process.h"
 #include "../units.h"
 #include "../gamestr.h"
@@ -1144,7 +1142,6 @@ ScrollPlanetSide (SIZE dx, SIZE dy, int
 	
 	curLanderLoc = new_pt;
 
-	LockMutex (GraphicsLock);
 	OldContext = SetContext (PlanetContext);
 
 	BatchGraphics ();
@@ -1254,7 +1251,6 @@ ScrollPlanetSide (SIZE dx, SIZE dy, int
 	UnbatchGraphics ();
 
 	SetContext (OldContext);
-	UnlockMutex (GraphicsLock);
 }
 
 static void
@@ -1264,9 +1260,7 @@ animationInterframe (TimeCount *TimeIn,
 
 	for ( ; periods; --periods)
 	{
-		LockMutex (GraphicsLock);
 		RotatePlanetSphere (TRUE);
-		UnlockMutex (GraphicsLock);
 
 		SleepThreadUntil (*TimeIn + ANIM_FRAME_RATE);
 		*TimeIn = GetTimeCounter ();
@@ -1281,12 +1275,12 @@ AnimateLaunch (FRAME farray)
 	COUNT num_frames;
 	TimeCount NextTime;
 
-	LockMutex (GraphicsLock);
 	SetContext (PlanetContext);
 
 	r.corner.x = 0;
 	r.corner.y = 0;
 	r.extent.width = 0;
+	r.extent.height = 0;
 	s.origin.x = 0;
 	s.origin.y = 0;
 	s.frame = farray;
@@ -1304,18 +1298,14 @@ AnimateLaunch (FRAME farray)
 #endif
 		DrawStamp (&s);
 		UnbatchGraphics ();
-		UnlockMutex (GraphicsLock);
 
 		GetFrameRect (s.frame, &r);
 		s.frame = IncFrameIndex (s.frame);
 
 		SleepThreadUntil (NextTime);
-
-		LockMutex (GraphicsLock);
 	}
 
 	RepairBackRect (&r);
-	UnlockMutex (GraphicsLock);
 }
 
 static void
@@ -1326,18 +1316,14 @@ AnimateLanderWarmup (void)
 	CONTEXT OldContext;
 	TimeCount TimeIn = GetTimeCounter ();
 
-	LockMutex (GraphicsLock);
 	OldContext = SetContext (RadarContext);
-	UnlockMutex (GraphicsLock);
 
 	s.origin.x = 0;
 	s.origin.y = 0;
 	s.frame = SetAbsFrameIndex (LanderFrame[0],
 			(ANGLE_TO_FACING (FULL_CIRCLE) << 1) + 1);
 
-	LockMutex (GraphicsLock);
 	DrawStamp (&s);
-	UnlockMutex (GraphicsLock);
 
 	animationInterframe (&TimeIn, 2);
 
@@ -1346,10 +1332,8 @@ AnimateLanderWarmup (void)
 	{
 		animationInterframe (&TimeIn, 1);
 		
-		LockMutex (GraphicsLock);
 		DeltaSISGauges (-1, 0, 0);
 		DeltaLanderCrew (1, 0);
-		UnlockMutex (GraphicsLock);
 	}
 
 	animationInterframe (&TimeIn, 2);
@@ -1359,9 +1343,7 @@ AnimateLanderWarmup (void)
 	else
 		s.frame = SetAbsFrameIndex (s.frame,
 				(ANGLE_TO_FACING (FULL_CIRCLE) << 1) + 2);
-	LockMutex (GraphicsLock);
 	DrawStamp (&s);
-	UnlockMutex (GraphicsLock);
 
 	animationInterframe (&TimeIn, 2);
 
@@ -1371,26 +1353,20 @@ AnimateLanderWarmup (void)
 	{
 		s.frame = SetAbsFrameIndex (s.frame,
 				(ANGLE_TO_FACING (FULL_CIRCLE) << 1) + 3);
-		LockMutex (GraphicsLock);
 		DrawStamp (&s);
-		UnlockMutex (GraphicsLock);
 
 		animationInterframe (&TimeIn, 2);
 
 		s.frame = IncFrameIndex (s.frame);
 	}
-	LockMutex (GraphicsLock);
 	DrawStamp (&s);
-	UnlockMutex (GraphicsLock);
 
 	if (GET_GAME_STATE (IMPROVED_LANDER_CARGO))
 	{
 		animationInterframe (&TimeIn, 2);
 
 		s.frame = SetAbsFrameIndex (s.frame, 59);
-		LockMutex (GraphicsLock);
 		DrawStamp (&s);
-		UnlockMutex (GraphicsLock);
 	}
 
 	animationInterframe (&TimeIn, 2);
@@ -1420,7 +1396,6 @@ InitPlanetSide (POINT pt)
 
 	curLanderLoc = pt;
 
-	LockMutex (GraphicsLock);
 	SetContext (PlanetContext);
 	SetContextFont (TinyFont);
 
@@ -1453,7 +1428,6 @@ InitPlanetSide (POINT pt)
 		UnbatchGraphics ();
 	}
 
-	UnlockMutex (GraphicsLock);
 
 	SET_GAME_STATE (PLANETARY_LANDING, 1);
 }
@@ -1750,7 +1724,6 @@ ReturnToOrbit (void)
 	CONTEXT OldContext;
 	RECT r;
 
-	LockMutex (GraphicsLock);
 	OldContext = SetContext (PlanetContext);
 	GetContextClipRect (&r);
 
@@ -1763,7 +1736,6 @@ ReturnToOrbit (void)
 	UnbatchGraphics ();
 
 	SetContext (OldContext);
-	UnlockMutex (GraphicsLock);
 }
 
 static void
@@ -1857,40 +1829,65 @@ KillLanderCrewSeq (COUNT numKilled, DWOR
 	return crew_left > 0;
 }
 
+// Maps a temperature to a (0-7) hazard rating.
+// Thermal hazards aren't exposed to the user as a hazard number,
+// but the code still works with them that way.
+#define ARRAY_SIZE(array) (sizeof(array) / sizeof (*array))
+unsigned
+GetThermalHazardRating (int temp)
+{
+	static const int tempBreakpoints[] = { 50, 100, 150, 250, 350, 550, 800 };
+	const size_t numBreakpoints = ARRAY_SIZE (tempBreakpoints);
+	unsigned i;
+
+	for (i = 0; i < numBreakpoints; ++i)
+	{
+		if (temp < tempBreakpoints[i])
+			return i;
+	}
+
+	return numBreakpoints;
+}
+
+// Given a hazard type and rating, return the chance (out of 256) of the hazard
+// being generated.
+static BYTE
+GetHazardChance (int hazardType, unsigned HazardRating)
+{
+	static const BYTE TectonicsChanceTab[] = {0*3, 0*3, 1*3, 2*3, 4*3,  8*3, 16*3, 32*3};
+	static const BYTE WeatherChanceTab  [] = {0*3, 0*3, 1*3, 2*3, 3*3,  6*3, 12*3, 24*3};
+	static const BYTE FireChanceTab     [] = {0*3, 0*3, 1*3, 2*3, 4*3, 12*3, 24*3, 48*3};
+
+	switch (hazardType)
+	{
+		case EARTHQUAKE_DISASTER:
+			return TectonicsChanceTab[HazardRating];
+		case LIGHTNING_DISASTER:
+			return WeatherChanceTab[HazardRating];
+		case LAVASPOT_DISASTER:
+			return FireChanceTab[HazardRating];
+	}
+
+	return 0;
+}
+
 void
 PlanetSide (POINT planetLoc)
 {
 	SIZE index;
 	LanderInputState landerInputState;
 	PLANETSIDE_DESC PSD;
-	BYTE TectonicsChanceTab[] = {0*3, 0*3, 1*3, 2*3, 4*3, 8*3, 16*3, 32*3};
-	BYTE WeatherChanceTab[] = {0*3, 0*3, 1*3, 2*3, 3*3, 6*3, 12*3, 24*3};
-	BYTE FireChanceTab[] = {0*3, 0*3, 1*3, 2*3, 4*3, 12*3, 24*3, 48*3};
 
 	memset (&PSD, 0, sizeof (PSD));
 	PSD.InTransit = TRUE;
 
-	PSD.TectonicsChance =
-			TectonicsChanceTab[pSolarSysState->SysInfo.PlanetInfo.Tectonics];
-	PSD.WeatherChance =
-			WeatherChanceTab[pSolarSysState->SysInfo.PlanetInfo.Weather];
-	index = pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature;
-	if (index < 50)
-		PSD.FireChance = FireChanceTab[0];
-	else if (index < 100)
-		PSD.FireChance = FireChanceTab[1];
-	else if (index < 150)
-		PSD.FireChance = FireChanceTab[2];
-	else if (index < 250)
-		PSD.FireChance = FireChanceTab[3];
-	else if (index < 350)
-		PSD.FireChance = FireChanceTab[4];
-	else if (index < 550)
-		PSD.FireChance = FireChanceTab[5];
-	else if (index < 800)
-		PSD.FireChance = FireChanceTab[6];
-	else
-		PSD.FireChance = FireChanceTab[7];
+	// Set our chances of hazards occurring.
+	PSD.TectonicsChance = GetHazardChance (EARTHQUAKE_DISASTER,
+			pSolarSysState->SysInfo.PlanetInfo.Tectonics);
+	PSD.WeatherChance = GetHazardChance (LIGHTNING_DISASTER,
+			pSolarSysState->SysInfo.PlanetInfo.Weather);
+	PSD.FireChance = GetHazardChance (LAVASPOT_DISASTER, GetThermalHazardRating (
+			pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature));
 
 	PSD.ElementLevel = GetStorageBayCapacity () - GLOBAL_SIS (TotalElementMass);
 	PSD.MaxElementLevel = MAX_SCROUNGED;
@@ -1948,9 +1945,7 @@ PlanetSide (POINT planetLoc)
 		if (crew_left == 0)
 		{
 			--GLOBAL_SIS (NumLanders);
-			LockMutex (GraphicsLock);
 			DrawLanders ();
-			UnlockMutex (GraphicsLock);
 
 			ReturnToOrbit ();
 		}
@@ -1964,7 +1959,6 @@ PlanetSide (POINT planetLoc)
 			ReturnToOrbit ();
 			AnimateLaunch (LanderFrame[6]);
 			
-			LockMutex (GraphicsLock);
 			DeltaSISGauges (crew_left, 0, 0);
 
 			if (PSD.ElementLevel)
@@ -1978,7 +1972,6 @@ PlanetSide (POINT planetLoc)
 				}
 				DrawStorageBays (FALSE);
 			}
-			UnlockMutex (GraphicsLock);
 
 			GLOBAL_SIS (TotalBioMass) += PSD.BiologicalLevel;
 		}
@@ -2018,10 +2011,7 @@ InitLander (BYTE LanderFlags)
 {
 	RECT r;
 
-	LockMutex (GraphicsLock);
-
 	SetContext (RadarContext);
-	
 	BatchGraphics ();
 	
 	r.corner.x = 0;
@@ -2108,6 +2098,4 @@ InitLander (BYTE LanderFlags)
 	}
 
 	UnbatchGraphics ();
-
-	UnlockMutex (GraphicsLock);
 }
diff -ruNp src.orig/uqm/planets/lander.h src/uqm/planets/lander.h
--- src.orig/uqm/planets/lander.h	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/lander.h	2017-11-21 19:39:57 -0600
@@ -26,6 +26,9 @@
 #include "libs/timelib.h"
 #include "../element.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
 // Surface magnification shift (x4)
 #define MAG_SHIFT 2
@@ -69,6 +72,8 @@ extern void object_animation (ELEMENT *E
 extern void SetLanderTakeoff (void);
 extern bool KillLanderCrewSeq (COUNT numKilled, DWORD period);
 
+extern unsigned GetThermalHazardRating (int temp);
+
 // ELEMENT.playerNr constants
 enum
 {
@@ -76,5 +81,9 @@ enum
 	PS_NON_PLAYER,
 };
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _LANDER_H */
 
diff -ruNp src.orig/uqm/planets/lifeform.h src/uqm/planets/lifeform.h
--- src.orig/uqm/planets/lifeform.h	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/lifeform.h	2017-11-21 19:39:57 -0600
@@ -21,6 +21,9 @@
 
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
 #define BEHAVIOR_HUNT (0 << 0)
 #define BEHAVIOR_FLEE (1 << 0)
@@ -65,5 +68,9 @@ typedef struct
 
 extern const LIFEFORM_DESC CreatureData[];
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _LIFEFORM_H */
 
diff -ruNp src.orig/uqm/planets/orbits.c src/uqm/planets/orbits.c
--- src.orig/uqm/planets/orbits.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/orbits.c	2017-11-21 19:39:57 -0600
@@ -17,8 +17,7 @@
  */
 
 #include "planets.h"
-// XXX: for CurStarDescPtr
-#include "../encount.h"
+#include "../starmap.h"
 #include "libs/compiler.h"
 #include "libs/mathlib.h"
 #include "libs/log.h"
@@ -499,10 +498,15 @@ char scolor[] = {'B', 'G', 'O', 'R', 'W'
 
 	if (NumPlanets == (BYTE)~0)
 	{
-#define MAX_GENERATED_PLANETS 10
-		while ((NumPlanets = (BYTE)(LOWORD (TFB_Random())
-				% MAX_GENERATED_PLANETS)) == 0)
-			;
+#define MAX_GENERATED_PLANETS 9
+		// XXX: This is pretty funny. Instead of calling RNG once, like so:
+		//     1 + Random % MAX_GENERATED_PLANETS
+		//   we spin in a loop until the result > 0.
+		//   Note that this behavior must be kept to preserve the universe.
+		do
+			NumPlanets = LOWORD (RandomContext_Random (SysGenRNG))
+					% (MAX_GENERATED_PLANETS + 1);
+		while (NumPlanets == 0);
 		system->SunDesc[0].NumPlanets = NumPlanets;
 	}
 
@@ -528,7 +532,7 @@ char scolor[] = {'B', 'G', 'O', 'R', 'W'
 
 		do
 		{
-			rand_val = TFB_Random ();
+			rand_val = RandomContext_Random (SysGenRNG);
 			if (TypesDefined)
 				rand_val = 0;
 			else
@@ -564,7 +568,7 @@ char scolor[] = {'B', 'G', 'O', 'R', 'W'
 		else
 			min_radius = Suns[StarSize].MinGasGDist;
 RelocatePlanet:
-		rand_val = TFB_Random ();
+		rand_val = RandomContext_Random (SysGenRNG);
 		if (GeneratingMoons)
 		{
 			pPD->radius = MIN_MOON_RADIUS
@@ -592,7 +596,7 @@ RelocatePlanet:
 			}
 		}
 
-		rand_val = TFB_Random ();
+		rand_val = RandomContext_Random (SysGenRNG);
 		angle = NORMALIZE_ANGLE (LOWORD (rand_val));
 		pPD->location.x = COSINE (angle, pPD->radius);
 		pPD->location.y = SINE (angle, pPD->radius);
diff -ruNp src.orig/uqm/planets/oval.c src/uqm/planets/oval.c
--- src.orig/uqm/planets/oval.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/oval.c	2017-11-21 19:39:57 -0600
@@ -21,6 +21,7 @@
 #include "libs/graphics/context.h"
 #include "libs/graphics/drawable.h"
 
+#include "planets.h"
 
 #define NUM_QUADS 4
 
diff -ruNp src.orig/uqm/planets/pl_stuff.c src/uqm/planets/pl_stuff.c
--- src.orig/uqm/planets/pl_stuff.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/pl_stuff.c	2017-11-21 19:39:57 -0600
@@ -192,7 +192,6 @@ ZoomInPlanetSphere (void)
 		pt.y = PLANET_ORG_Y + (int) (dy * (1.0 - scale)
 				* (SCAN_SCREEN_HEIGHT * 6 / 10) + 0.5);
 
-		LockMutex (GraphicsLock);
 		SetContext (PlanetContext);
 
 		BatchGraphics ();
@@ -206,7 +205,6 @@ ZoomInPlanetSphere (void)
 		SetGraphicScaleMode (oldMode);
 
 		UnbatchGraphics ();
-		UnlockMutex (GraphicsLock);
 
 		repairRect.corner.x = pt.x + frameRect.corner.x;
 		repairRect.corner.y = pt.y + frameRect.corner.y;
diff -ruNp src.orig/uqm/planets/plandata.h src/uqm/planets/plandata.h
--- src.orig/uqm/planets/plandata.h	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/plandata.h	2017-11-21 19:39:57 -0600
@@ -21,6 +21,9 @@
 
 #include "libs/reslib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
 /*------------------------------ Type Defines ----------------------------- */
 #define NUMBER_OF_ORBITS 16
@@ -276,25 +279,6 @@ typedef struct
 	DWORD ScanSeed[NUM_SCAN_TYPES];
 	DWORD ScanRetrieveMask[NUM_SCAN_TYPES];
 
-	// The CurPt, CurDensity and CurType fields are filled in
-	// when a GENERATE_MINERAL, GENERATE_ENERGY, or GENERATE_LIFE
-	// call is made.
-	POINT CurPt;
-			// Position of the mineral/bio/energy node on the planet.
-	COUNT CurDensity;
-			// For bio and energy: undefined
-			// For minerals the low byte is the gross size of the
-			// deposit (this determines the image), and the high
-			// byte is the fine size (the actual quantity).
-	COUNT CurType;
-			// For minerals: the type of element
-			// For bio: the type of the creature.
-			//          0 through NUM_CREATURE_TYPES - 1 are normal creatures,
-			//          NUM_CREATURE_TYPES     is an Evil One
-			//          NUM_CREATURE_TYPES + 1 is a Brainbox Bulldozer
-			//          NUM_CREATURE_TYPES + 2 is Zex' Beauty
-			// For energy: undefined
-
 	STRING DiscoveryString;
 	FONT LanderFont;
 	FRAME LanderFontEff;
@@ -310,8 +294,7 @@ enum
 	SUPER_DENSITY
 };
 
-#define CalcGravity(d,r) (UWORD)((DWORD)(d) * (r) / 100)
-#define CalcFromBase(b,v) ((UWORD)(b) + ((UWORD)TFB_Random () % (v)))
+extern UWORD CalcGravity (const PLANET_INFO*);
 
 #define EARTH_ATMOSPHERE 50
 
@@ -328,5 +311,9 @@ enum
 
 extern const PlanetFrame *PlanData;
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _PLANDATA_H */
 
diff -ruNp src.orig/uqm/planets/planets.c src/uqm/planets/planets.c
--- src.orig/uqm/planets/planets.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/planets.c	2017-11-21 19:39:57 -0600
@@ -59,8 +59,6 @@ CreatePlanetContext (void)
 
 	assert (PlanetContext == NULL);
 
-	LockMutex (GraphicsLock);
-
 	// PlanetContext rect is relative to SpaceContext
 	oldContext = SetContext (SpaceContext);
 	GetContextClipRect (&r);
@@ -72,7 +70,6 @@ CreatePlanetContext (void)
 	SetContextClipRect (&r);
 
 	SetContext (oldContext);
-	UnlockMutex (GraphicsLock);
 }
 
 static void
@@ -263,9 +260,7 @@ LoadPlanet (FRAME SurfDefFrame)
 
 	if (WaitMode)
 	{
-		LockMutex (GraphicsLock);
 		DrawOrbitalDisplay (DRAW_ORBITAL_WAIT);
-		UnlockMutex (GraphicsLock);
 	}
 
 	StopMusic ();
@@ -281,15 +276,11 @@ LoadPlanet (FRAME SurfDefFrame)
 	if (WaitMode)
 	{
 		ZoomInPlanetSphere ();
-		LockMutex (GraphicsLock);
 		DrawOrbitalDisplay (DRAW_ORBITAL_UPDATE);
-		UnlockMutex (GraphicsLock);
 	}
 	else
 	{
-		LockMutex (GraphicsLock);
 		DrawOrbitalDisplay (DRAW_ORBITAL_FULL);
-		UnlockMutex (GraphicsLock);
 	}
 }
 
@@ -302,7 +293,6 @@ FreePlanet (void)
 	UninitSphereRotation ();
 
 	StopMusic ();
-	LockMutex (GraphicsLock);
 
 	for (i = 0; i < sizeof (pSolarSysState->PlanetSideFrame)
 			/ sizeof (pSolarSysState->PlanetSideFrame[0]); ++i)
@@ -353,7 +343,6 @@ FreePlanet (void)
 	DestroyPlanetContext ();
 	DestroyScanContext ();
 
-	UnlockMutex (GraphicsLock);
 }
 
 void
@@ -391,9 +380,7 @@ DoPlanetOrbit (MENU_STATE *pMS)
 	if (!select)
 		return TRUE;
 
-	LockMutex (GraphicsLock);
 	SetFlashRect (NULL);
-	UnlockMutex (GraphicsLock);
 
 	switch (pMS->CurState)
 	{
@@ -431,9 +418,7 @@ DoPlanetOrbit (MENU_STATE *pMS)
 			// Deactivate planet rotation
 			oldCallback = SetInputCallback (NULL);
 
-			LockMutex (GraphicsLock);
 			RepairSISBorder ();
-			UnlockMutex (GraphicsLock);
 
 			AutoPilotSet = StarMap ();
 			if (GLOBAL (CurrentActivity) & CHECK_ABORT)
@@ -444,9 +429,7 @@ DoPlanetOrbit (MENU_STATE *pMS)
 
 			if (!AutoPilotSet)
 			{	// Redraw the orbital display
-				LockMutex (GraphicsLock);
 				DrawOrbitalDisplay (DRAW_ORBITAL_FULL);
-				UnlockMutex (GraphicsLock);
 				break;
 			}
 			// Fall through !!!
@@ -463,9 +446,7 @@ DoPlanetOrbit (MENU_STATE *pMS)
 				pMS->CurState = NAVIGATION;
 			DrawMenuStateStrings (PM_SCAN, pMS->CurState);
 		}
-		LockMutex (GraphicsLock);
 		SetFlashRect (SFR_MENU_3DO);
-		UnlockMutex (GraphicsLock);
 	}
 
 	return TRUE;
@@ -474,9 +455,7 @@ DoPlanetOrbit (MENU_STATE *pMS)
 static void
 on_input_frame (void)
 {
-	LockMutex (GraphicsLock);
 	RotatePlanetSphere (TRUE);
-	UnlockMutex (GraphicsLock);
 }
 
 void
@@ -488,9 +467,7 @@ PlanetOrbitMenu (void)
 	memset (&MenuState, 0, sizeof MenuState);
 
 	DrawMenuStateStrings (PM_SCAN, SCAN);
-	LockMutex (GraphicsLock);
 	SetFlashRect (SFR_MENU_3DO);
-	UnlockMutex (GraphicsLock);
 
 	MenuState.CurState = SCAN;
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
@@ -501,8 +478,6 @@ PlanetOrbitMenu (void)
 
 	SetInputCallback (oldCallback);
 
-	LockMutex (GraphicsLock);
 	SetFlashRect (NULL);
-	UnlockMutex (GraphicsLock);
 	DrawMenuStateStrings (PM_STARMAP, -NAVIGATION);
 }
diff -ruNp src.orig/uqm/planets/planets.h src/uqm/planets/planets.h
--- src.orig/uqm/planets/planets.h	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/planets.h	2017-11-21 19:39:57 -0600
@@ -19,6 +19,8 @@
 #ifndef _PLANETS_H
 #define _PLANETS_H
 
+#include "libs/mathlib.h"
+
 #define END_INTERPLANETARY START_INTERPLANETARY
 
 enum PlanetScanTypes
@@ -86,6 +88,7 @@ enum
 
 typedef struct planet_desc PLANET_DESC;
 typedef struct star_desc STAR_DESC;
+typedef struct node_info NODE_INFO;
 typedef struct planet_orbit PLANET_ORBIT;
 typedef struct solarsys_state SOLARSYS_STATE;
 
@@ -99,6 +102,9 @@ typedef struct solarsys_state SOLARSYS_S
 #include "plandata.h"
 #include "sundata.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
 struct planet_desc
 {
@@ -126,7 +132,26 @@ struct star_desc
 	BYTE Postfix;
 };
 
-typedef void (*PLAN_GEN_FUNC) (BYTE control);
+struct node_info
+{
+	// This structire is filled in when a generateMinerals, generateEnergy,
+	// or generateLife call is made.
+	POINT loc_pt;
+			// Position of the mineral/bio/energy node on the planet.
+	COUNT density;
+			// For bio and energy: undefined
+			// For minerals the low byte is the gross size of the
+			// deposit (this determines the image), and the high
+			// byte is the fine size (the actual quantity).
+	COUNT type;
+			// For minerals: the type of element
+			// For bio: the type of the creature.
+			//          0 through NUM_CREATURE_TYPES - 1 are normal creatures,
+			//          NUM_CREATURE_TYPES     is an Evil One
+			//          NUM_CREATURE_TYPES + 1 is a Brainbox Bulldozer
+			//          NUM_CREATURE_TYPES + 2 is Zex' Beauty
+			// For energy: undefined
+};
 
 struct planet_orbit
 {
@@ -230,6 +255,9 @@ extern SOLARSYS_STATE *pSolarSysState;
 extern MUSIC_REF SpaceMusic;
 extern CONTEXT PlanetContext;
 
+// Random context used for all solar system, planets and surfaces generation
+extern RandomContext *SysGenRNG;
+
 bool playerInSolarSystem (void);
 bool playerInPlanetOrbit (void);
 bool playerInInnerSystem (void);
@@ -241,6 +269,8 @@ COUNT moonIndex (const SOLARSYS_STATE *s
 bool matchWorld (const SOLARSYS_STATE *solarSys, const PLANET_DESC *world,
 		BYTE planetI, BYTE moonI);
 
+DWORD GetRandomSeedForStar (const STAR_DESC *star);
+
 POINT locationToDisplay (POINT pt, SIZE scaleRadius);
 POINT displayToLocation (POINT pt, SIZE scaleRadius);
 POINT planetOuterLocation (COUNT planetI);
@@ -254,7 +284,6 @@ extern void FreeLanderFont (PLANET_INFO
 extern void ExploreSolarSys (void);
 extern void DrawStarBackGround (void);
 extern void XFormIPLoc (POINT *pIn, POINT *pOut, BOOLEAN ToDisplay);
-extern PLAN_GEN_FUNC GenerateIP (BYTE Index);
 extern void DrawOval (RECT *pRect, BYTE num_off_pixels);
 extern void DrawFilledOval (RECT *pRect);
 extern void FillOrbits (SOLARSYS_STATE *system, BYTE NumPlanets,
@@ -286,5 +315,9 @@ extern void GetPlanetOrMoonName (UNICODE
 extern void PlanetOrbitMenu (void);
 extern void SaveSolarSysLocation (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _PLANETS_H */
 
diff -ruNp src.orig/uqm/planets/plangen.c src/uqm/planets/plangen.c
--- src.orig/uqm/planets/plangen.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/plangen.c	2017-11-21 19:39:57 -0600
@@ -842,7 +842,7 @@ DitherMap (SBYTE *DepthArray)
 	{
 		// Use up the random value byte by byte
 		if ((i & 3) == 0)
-			rand_val = TFB_Random ();
+			rand_val = RandomContext_Random (SysGenRNG);
 		else
 			rand_val >>= 8;
 
@@ -1066,7 +1066,7 @@ MakeStorms (COUNT storm_count, SBYTE *De
 
 			intersect = FALSE;
 
-			rand_val = TFB_Random ();
+			rand_val = RandomContext_Random (SysGenRNG);
 			loword = LOWORD (rand_val);
 			hiword = HIWORD (rand_val);
 			switch (HIBYTE (hiword) & 31)
@@ -1094,7 +1094,7 @@ MakeStorms (COUNT storm_count, SBYTE *De
 			if (pstorm_r->extent.height <= 4)
 				pstorm_r->extent.height += 4;
 
-			rand_val = TFB_Random ();
+			rand_val = RandomContext_Random (SysGenRNG);
 			loword = LOWORD (rand_val);
 			hiword = HIWORD (rand_val);
 
@@ -1183,7 +1183,7 @@ MakeGasGiant (COUNT num_bands, SBYTE *De
 	band_error = num_bands >> 1;
 	lpDst = DepthArray;
 
-	band_delta = ((LOWORD (TFB_Random ())
+	band_delta = ((LOWORD (RandomContext_Random (SysGenRNG))
 			& (NUM_BAND_COLORS - 1)) << RANGE_SHIFT)
 			+ (1 << (RANGE_SHIFT - 1));
 	last_y = next_y = 0;
@@ -1191,7 +1191,7 @@ MakeGasGiant (COUNT num_bands, SBYTE *De
 	{
 		COORD cur_y;
 
-		rand_val = TFB_Random ();
+		rand_val = RandomContext_Random (SysGenRNG);
 		loword = LOWORD (rand_val);
 		hiword = HIWORD (rand_val);
 
@@ -1232,7 +1232,7 @@ MakeGasGiant (COUNT num_bands, SBYTE *De
 				& (((1 << RANGE_SHIFT) * NUM_BAND_COLORS) - 1);
 	}
 
-	MakeStorms (4 + (TFB_Random () & 3) + 1, DepthArray);
+	MakeStorms (4 + (RandomContext_Random (SysGenRNG) & 3) + 1, DepthArray);
 
 	DitherMap (DepthArray);
 }
@@ -1572,8 +1572,8 @@ get_vblock_avg (elev_block_t *pblk, SBYT
 	if (y1 > MAP_HEIGHT)
 		y1 = MAP_HEIGHT;
 
-	elev = pTopo + y0 * MAP_HEIGHT + x;
-	for (i = y0; i < y1; ++i, elev += MAP_HEIGHT)
+	elev = pTopo + y0 * MAP_WIDTH + x;
+	for (i = y0; i < y1; ++i, elev += MAP_WIDTH)
 	{
 		int delta = abs (i - y);
 		int weight = 255; // full weight
@@ -1589,7 +1589,7 @@ get_vblock_avg (elev_block_t *pblk, SBYT
 			max = v;
 		if (v < min)
 			min = v;
-		avg += pblk->avg * weight;
+		avg += v * weight;
 		total_weight += weight;
 	}
 	avg /= total_weight;
@@ -1718,11 +1718,11 @@ GenerateLightMap (SBYTE *pTopo, int w, i
 	}
 }
 
+// Sets the SysGenRNG to the required state first.
 void
 GeneratePlanetSurface (PLANET_DESC *pPlanetDesc, FRAME SurfDefFrame)
 {
 	RECT r;
-	DWORD old_seed;
 	const PlanetFrame *PlanDataPtr;
 	PLANET_INFO *PlanetInfo = &pSolarSysState->SysInfo.PlanetInfo;
 	COUNT i, y;
@@ -1732,10 +1732,9 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
 	BOOLEAN shielded = (pPlanetDesc->data_index & PLANET_SHIELDED) != 0;
 
-	old_seed = TFB_SeedRandom (pPlanetDesc->rand_seed);
+	RandomContext_SeedRandom (SysGenRNG, pPlanetDesc->rand_seed);
 
 	TopoContext = CreateContext ("Plangen.TopoContext");
-	LockMutex (GraphicsLock);
 	OldContext = SetContext (TopoContext);
 	planet_orbit_init ();
 
@@ -1818,7 +1817,7 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 						RECT crater_r;
 						UWORD loword;
 				
-						loword = LOWORD (TFB_Random ());
+						loword = LOWORD (RandomContext_Random (SysGenRNG));
 						switch (HIBYTE (loword) & 31)
 						{
 							case 0:
@@ -1841,7 +1840,7 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 								break;
 						}
 					
-						loword = LOWORD (TFB_Random ());
+						loword = LOWORD (RandomContext_Random (SysGenRNG));
 						crater_r.extent.height = crater_r.extent.width;
 						crater_r.corner.x = HIBYTE (loword)
 								% (MAP_WIDTH - crater_r.extent.width);
@@ -1950,9 +1949,6 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 	}
 
 	SetContext (OldContext);
-	UnlockMutex (GraphicsLock);
 	DestroyContext (TopoContext);
-
-	TFB_SeedRandom (old_seed);
 }
 
diff -ruNp src.orig/uqm/planets/pstarmap.c src/uqm/planets/pstarmap.c
--- src.orig/uqm/planets/pstarmap.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/pstarmap.c	2017-11-21 19:39:57 -0600
@@ -20,8 +20,7 @@
 #include "../colors.h"
 #include "../controls.h"
 #include "../menustat.h"
-// XXX: for stuff that does not belong there
-#include "../encount.h"
+#include "../starmap.h"
 #include "../races.h"
 #include "../gameopt.h"
 #include "../gamestr.h"
@@ -68,18 +67,18 @@ signedDivWithError (long val, long divis
 #define MAP_FIT_X ((MAX_X_UNIVERSE + 1) / SIS_SCREEN_WIDTH + 1)
 
 static inline COORD
-universeToDispx (COORD ux)
+universeToDispx (long ux)
 {
-	return signedDivWithError ((((long)ux - mapOrigin.x) << zoomLevel)
+	return signedDivWithError (((ux - mapOrigin.x) << zoomLevel)
 			* SIS_SCREEN_WIDTH, MAX_X_UNIVERSE + MAP_FIT_X)
 			+ ((SIS_SCREEN_WIDTH - 1) >> 1);
 }
 #define UNIVERSE_TO_DISPX(ux)  universeToDispx(ux)
 
 static inline COORD
-universeToDispy (COORD uy)
+universeToDispy (long uy)
 {
-	return signedDivWithError ((((long)mapOrigin.y - uy) << zoomLevel)
+	return signedDivWithError (((mapOrigin.y - uy) << zoomLevel)
 			* SIS_SCREEN_HEIGHT, MAX_Y_UNIVERSE + 2)
 			+ ((SIS_SCREEN_HEIGHT - 1) >> 1);
 }
@@ -124,7 +123,6 @@ flashCurrentLocation (POINT *where)
 
 		NextTime = GetTimeCounter () + (ONE_SECOND / 16);
 		
-		LockMutex (GraphicsLock);
 		OldContext = SetContext (SpaceContext);
 
 		if (c == 0x00 || c == 0x1A)
@@ -139,7 +137,6 @@ flashCurrentLocation (POINT *where)
 		SetContextForeGroundColor (OldColor);
 
 		SetContext (OldContext);
-		UnlockMutex (GraphicsLock);
 	}
 }
 
@@ -164,7 +161,7 @@ DrawAutoPilot (POINT *pDstPt)
 				cycle, delta;
 	POINT pt;
 
-	if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
+	if (!inHQSpace ())
 		pt = CurStarDescPtr->star_pt;
 	else
 	{
@@ -300,7 +297,6 @@ DrawStarMap (COUNT race_update, RECT *pC
 	}
 	else
 	{
-		LockMutex (GraphicsLock);
 		draw_cursor = TRUE;
 	}
 
@@ -343,13 +339,14 @@ DrawStarMap (COUNT race_update, RECT *pC
 	}
 	ClearDrawable ();
 
+	// Draw the fuel range circle
 	if (race_update == 0
 			&& which_space < 2
 			&& (diameter = (long)GLOBAL_SIS (FuelOnBoard) << 1))
 	{
 		Color OldColor;
 
-		if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
+		if (!inHQSpace ())
 			r.corner = CurStarDescPtr->star_pt;
 		else
 		{
@@ -357,6 +354,10 @@ DrawStarMap (COUNT race_update, RECT *pC
 			r.corner.y = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
 		}
 
+		// Cap the diameter to a sane range
+		if (diameter > MAX_X_UNIVERSE * 4)
+			diameter = MAX_X_UNIVERSE * 4;
+
 		r.extent.width = UNIVERSE_TO_DISPX (diameter)
 				- UNIVERSE_TO_DISPX (0);
 		if (r.extent.width < 0)
@@ -555,9 +556,6 @@ DrawStarMap (COUNT race_update, RECT *pC
 					UNIVERSE_TO_DISPY (cursorLoc.y));
 		}
 	}
-
-	if (draw_cursor)
-		UnlockMutex (GraphicsLock);
 }
 
 static void
@@ -587,9 +585,7 @@ EraseCursor (COORD curs_x, COORD curs_y)
 #else /* NEW */
 	r.extent.height += r.corner.y & 1;
 	r.corner.y &= ~1;
-	UnlockMutex (GraphicsLock);
 	DrawStarMap (0, &r);
-	LockMutex (GraphicsLock);
 #endif /* OLD */
 }
 
@@ -689,11 +685,9 @@ UpdateCursorLocation (int sx, int sy, co
 	}
 	else
 	{
-		LockMutex (GraphicsLock);
 		EraseCursor (pt.x, pt.y);
 		// ClearDrawable ();
 		DrawCursor (s.origin.x, s.origin.y);
-		UnlockMutex (GraphicsLock);
 	}
 }
 
@@ -763,14 +757,12 @@ UpdateCursorInfo (UNICODE *prevbuf)
 		}
 	}
 
-	LockMutex (GraphicsLock);
 	DrawHyperCoords (cursorLoc);
 	if (strcmp (buf, prevbuf) != 0)
 	{
 		strcpy (prevbuf, buf);
 		DrawSISMessage (buf);
 	}
-	UnlockMutex (GraphicsLock);
 }
 
 static void
@@ -781,7 +773,7 @@ UpdateFuelRequirement (void)
 	DWORD f;
 	POINT pt;
 
-	if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
+	if (!inHQSpace ())
 		pt = CurStarDescPtr->star_pt;
 	else
 	{
@@ -802,9 +794,7 @@ UpdateFuelRequirement (void)
 			fuel_required / FUEL_TANK_SCALE,
 			(fuel_required % FUEL_TANK_SCALE) / 10);
 
-	LockMutex (GraphicsLock);
 	DrawStatusMessage (buf);
-	UnlockMutex (GraphicsLock);
 }
 
 #define STAR_SEARCH_BUFSIZE 256
@@ -1055,10 +1045,8 @@ DrawMatchedStarName (TEXTENTRY_STATE *pT
 			flags |= DSME_BLOCKCUR;
 	}
 	
-	LockMutex (GraphicsLock);
 	DrawSISMessageEx (buf, CurPos, ExPos, flags);
 	DrawHyperCoords (cursorLoc);
-	UnlockMutex (GraphicsLock);
 }
 
 static void
@@ -1129,9 +1117,7 @@ OnStarNameChange (TEXTENTRY_STATE *pTES)
 		if (pTES->JoystickMode)
 			flags |= DSME_BLOCKCUR;
 
-		LockMutex (GraphicsLock);
 		ret = DrawSISMessageEx (pSS->Text, pTES->CursorPos, -1, flags);
-		UnlockMutex (GraphicsLock);
 	}
 	else
 	{
@@ -1192,9 +1178,7 @@ DoStarSearch (MENU_STATE *pMS)
 	if (!pss)
 		return FALSE;
 
-	LockMutex (GraphicsLock);
 	DrawSISMessageEx ("", 0, 0, DSME_SETFR);
-	UnlockMutex (GraphicsLock);
 
 	pss->pMS = pMS;
 	pss->LastChangeTime = 0;
@@ -1216,9 +1200,7 @@ DoStarSearch (MENU_STATE *pMS)
 	SetDefaultMenuRepeatDelay ();
 	success = DoTextEntry (&tes);
 
-	LockMutex (GraphicsLock);
 	DrawSISMessageEx (pss->Text, -1, -1, DSME_CLEARFR);
-	UnlockMutex (GraphicsLock);
 
 	HFree (pss);
 
@@ -1241,7 +1223,7 @@ DoMoveCursor (MENU_STATE *pMS)
 		pMS->Initialized = TRUE;
 		pMS->InputFunc = DoMoveCursor;
 
-		if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
+		if (!inHQSpace ())
 			universe = CurStarDescPtr->star_pt;
 		else
 		{
@@ -1268,7 +1250,7 @@ DoMoveCursor (MENU_STATE *pMS)
 		{
 			PlayMenuSound (MENU_SOUND_INVOKED);
 
-			if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+			if (inHQSpace ())
 			{
 				// Move to the new location immediately.
 				doInstantMove ();
@@ -1597,7 +1579,7 @@ StarMap (void)
 	mapOrigin.y = MAX_Y_UNIVERSE >> 1;
 	StarMapFrame = SetAbsFrameIndex (MiscDataFrame, 48);
 
-	if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
+	if (!inHQSpace ())
 		universe = CurStarDescPtr->star_pt;
 	else
 	{
@@ -1616,8 +1598,6 @@ StarMap (void)
 	if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
 		UpdateMap ();
 
-	LockMutex (GraphicsLock);
-	
 	DrawStarMap (0, (RECT*)-1);
 	transition_pending = FALSE;
 	
@@ -1629,7 +1609,6 @@ StarMap (void)
 	DrawCursor (UNIVERSE_TO_DISPX (cursorLoc.x),
 			UNIVERSE_TO_DISPY (cursorLoc.y));
 	UnbatchGraphics ();
-	UnlockMutex (GraphicsLock);
 
 	SetMenuSounds (MENU_SOUND_NONE, MENU_SOUND_NONE);
 	SetMenuRepeatDelay (MIN_ACCEL_DELAY, MAX_ACCEL_DELAY, STEP_ACCEL_DELAY,
@@ -1638,11 +1617,9 @@ StarMap (void)
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
 	SetDefaultMenuRepeatDelay ();
 
-	LockMutex (GraphicsLock);
 	DrawHyperCoords (universe);
 	DrawSISMessage (NULL);
 	DrawStatusMessage (NULL);
-	UnlockMutex (GraphicsLock);
 
 	if (GLOBAL (autopilot.x) == universe.x
 			&& GLOBAL (autopilot.y) == universe.y)
diff -ruNp src.orig/uqm/planets/report.c src/uqm/planets/report.c
--- src.orig/uqm/planets/report.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/report.c	2017-11-21 19:39:57 -0600
@@ -102,7 +102,6 @@ MakeReport (SOUND ReadOutSounds, UNICODE
 	t.pStr = pStr;
 
 	Sleepy = TRUE;
-	UnlockMutex (GraphicsLock);
 
 	FlushInput ();
 	// XXX: this is a pretty ugly goto
@@ -163,9 +162,7 @@ MakeReport (SOUND ReadOutSounds, UNICODE
 						font_DrawText (&t);
 					else
 					{
-						LockMutex (GraphicsLock);
 						font_DrawText (&t);
-						UnlockMutex (GraphicsLock);
 
 						PlaySound (ReadOutSounds, NotPositional (), NULL,
 								GAME_SOUND_PRIORITY);
@@ -183,7 +180,6 @@ MakeReport (SOUND ReadOutSounds, UNICODE
 						{
 							Sleepy = FALSE;
 							// We draw the whole thing at once after this
-							LockMutex (GraphicsLock);
 							BatchGraphics ();
 						}
 					}
@@ -204,7 +200,6 @@ MakeReport (SOUND ReadOutSounds, UNICODE
 			if (!Sleepy)
 			{
 				UnbatchGraphics ();
-				UnlockMutex (GraphicsLock);
 			}
 
 			if (!WaitForAnyButton (TRUE, WAIT_INFINITE, FALSE))
@@ -216,18 +211,14 @@ InitPageCell:
 			row_cells = 0;
 			if (StrLen)
 			{
-				LockMutex (GraphicsLock);
 				if (!Sleepy)
 					BatchGraphics ();
 				ClearReportArea();
 				SetContextForeGroundColor (
 						BUILD_COLOR (MAKE_RGB15 (0x00, 0x1F, 0x00), 0xFF));
-				if (Sleepy)
-					UnlockMutex (GraphicsLock);
 			}
 		}
 	}
-	LockMutex (GraphicsLock);
 }
 
 void
@@ -274,9 +265,7 @@ DoDiscoveryReport (SOUND ReadOutSounds)
 
 	DestroyDrawable (ReleaseDrawable (saveStamp.frame));
 
-	UnlockMutex (GraphicsLock);
 	WaitForNoInput (WAIT_INFINITE, TRUE);
-	LockMutex (GraphicsLock);
 }
 
 
diff -ruNp src.orig/uqm/planets/roster.c src/uqm/planets/roster.c
--- src.orig/uqm/planets/roster.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/roster.c	2017-11-21 19:39:57 -0600
@@ -198,7 +198,9 @@ DeltaSupportCrew (ROSTER_STATE *rosterSt
 					StarShipPtr->crew_level,
 					TemplatePtr->crew_level);
 
+		PreUpdateFlashRect ();
 		DrawStatusMessage (buf);
+		PostUpdateFlashRect ();
 		DeltaSISGauges (-crew_delta, 0, 0);
 		if (crew_delta)
 		{
@@ -252,7 +254,6 @@ DoModifyRoster (MENU_STATE *pMS)
 	}
 	else if (select || cancel)
 	{
-		LockMutex (GraphicsLock);
 		rosterState->modifyingCrew ^= true;
 		if (!rosterState->modifyingCrew)
 		{
@@ -266,7 +267,6 @@ DoModifyRoster (MENU_STATE *pMS)
 			SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN,
 					MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
 		}
-		UnlockMutex (GraphicsLock);
 	}
 	else if (rosterState->modifyingCrew)
 	{
@@ -290,9 +290,7 @@ DoModifyRoster (MENU_STATE *pMS)
 		
 		if (delta != 0)
 		{
-			LockMutex (GraphicsLock);
 			failed = !DeltaSupportCrew (rosterState, delta);
-			UnlockMutex (GraphicsLock);
 		}
 
 		if (failed)
@@ -348,7 +346,6 @@ DoModifyRoster (MENU_STATE *pMS)
 				--NewState;
 		}
 
-		LockMutex (GraphicsLock);
 		BatchGraphics ();
 		SetContext (StatusContext);
 
@@ -364,7 +361,6 @@ DoModifyRoster (MENU_STATE *pMS)
 		flashSupportShip (rosterState);
 
 		UnbatchGraphics ();
-		UnlockMutex (GraphicsLock);
 	}
 
 	SleepThread (ONE_SECOND / 30);
@@ -414,22 +410,18 @@ RosterMenu (void)
 	qsort (RosterState.shipPos, RosterState.count,
 			sizeof (RosterState.shipPos[0]), compShipPos);
 
-	LockMutex (GraphicsLock);
 	SetContext (StatusContext);
 	selectSupportShip (&RosterState, MenuState.CurState);
-	UnlockMutex (GraphicsLock);
 
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
 
 	MenuState.InputFunc = DoModifyRoster;
 	DoInput (&MenuState, TRUE);
 
-	LockMutex (GraphicsLock);
 	SetContext (StatusContext);
 	// unselect the last ship
 	drawSupportShip (&RosterState, FALSE);
 	DrawStatusMessage (NULL);
-	UnlockMutex (GraphicsLock);
 
 	return TRUE;
 }
diff -ruNp src.orig/uqm/planets/scan.c src/uqm/planets/scan.c
--- src.orig/uqm/planets/scan.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/scan.c	2017-11-21 19:39:57 -0600
@@ -30,13 +30,13 @@
 #include "../nameref.h"
 #include "../resinst.h"
 #include "../settings.h"
-#include "../load.h"
 #include "../util.h"
 #include "../process.h"
 #include "../setup.h"
 #include "../sounds.h"
 #include "../state.h"
 #include "../sis.h"
+#include "../save.h"
 #include "options.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/graphics/drawable.h"
@@ -85,15 +85,12 @@ RepairBackRect (RECT *pRect)
 static void
 EraseCoarseScan (void)
 {
-	LockMutex (GraphicsLock);
 	SetContext (PlanetContext);
 	
 	BatchGraphics ();
 	DrawStarBackGround ();
 	DrawDefaultPlanetSphere ();
 	UnbatchGraphics ();
-	
-	UnlockMutex (GraphicsLock);
 }
 
 static void
@@ -160,7 +157,6 @@ PrintCoarseScanPC (void)
 
 	GetPlanetTitle (buf, sizeof (buf));
 
-	LockMutex (GraphicsLock);
 	SetContext (PlanetContext);
 
 	t.align = ALIGN_CENTER;
@@ -174,7 +170,6 @@ PrintCoarseScanPC (void)
 	font_DrawText (&t);
 
 	SetContextFont (TinyFont);
-	UnlockMutex (GraphicsLock);
 
 #define LEFT_SIDE_BASELINE_X_PC 5
 #define RIGHT_SIDE_BASELINE_X_PC (SIS_SCREEN_WIDTH - 75)
@@ -183,7 +178,6 @@ PrintCoarseScanPC (void)
 	t.baseline.y = SCAN_BASELINE_Y_PC;
 	t.align = ALIGN_LEFT;
 
-	LockMutex (GraphicsLock);
 	PrintScanTitlePC (&t, &r, GAME_STRING (ORBITSCAN_STRING_BASE),
 			LEFT_SIDE_BASELINE_X_PC); // "Orbit: "
 	val = ((pSolarSysState->SysInfo.PlanetInfo.PlanetToSunDist * 100L
@@ -194,9 +188,7 @@ PrintCoarseScanPC (void)
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING_PC;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	PrintScanTitlePC (&t, &r, GAME_STRING (ORBITSCAN_STRING_BASE + 2),
 			LEFT_SIDE_BASELINE_X_PC); // "Atmo: "
 	if (pSolarSysState->SysInfo.PlanetInfo.AtmoDensity == GAS_GIANT_ATMOSPHERE)
@@ -216,9 +208,7 @@ PrintCoarseScanPC (void)
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING_PC;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	PrintScanTitlePC (&t, &r, GAME_STRING (ORBITSCAN_STRING_BASE + 6),
 			LEFT_SIDE_BASELINE_X_PC); // "Temp: "
 	sprintf (buf, "%d" STR_DEGREE_SIGN " c",
@@ -227,9 +217,7 @@ PrintCoarseScanPC (void)
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING_PC;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	PrintScanTitlePC (&t, &r, GAME_STRING (ORBITSCAN_STRING_BASE + 7),
 			LEFT_SIDE_BASELINE_X_PC); // "Weather: "
 	if (pSolarSysState->SysInfo.PlanetInfo.AtmoDensity == 0)
@@ -244,9 +232,7 @@ PrintCoarseScanPC (void)
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING_PC;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	PrintScanTitlePC (&t, &r, GAME_STRING (ORBITSCAN_STRING_BASE + 10),
 			LEFT_SIDE_BASELINE_X_PC); // "Tectonics: "
 	if (PLANSIZE (pSolarSysState->SysInfo.PlanetInfo.PlanDataPtr->Type) ==
@@ -261,11 +247,9 @@ PrintCoarseScanPC (void)
 	}
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
-	UnlockMutex (GraphicsLock);
 
 	t.baseline.y = SCAN_BASELINE_Y_PC;
 
-	LockMutex (GraphicsLock);
 	PrintScanTitlePC (&t, &r, GAME_STRING (ORBITSCAN_STRING_BASE + 11),
 			RIGHT_SIDE_BASELINE_X_PC); // "Mass: "
 	val = pSolarSysState->SysInfo.PlanetInfo.PlanetRadius;
@@ -280,9 +264,7 @@ PrintCoarseScanPC (void)
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING_PC;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	PrintScanTitlePC (&t, &r, GAME_STRING (ORBITSCAN_STRING_BASE + 13),
 			RIGHT_SIDE_BASELINE_X_PC); // "Radius: "
 	val = pSolarSysState->SysInfo.PlanetInfo.PlanetRadius;
@@ -292,9 +274,7 @@ PrintCoarseScanPC (void)
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING_PC;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	PrintScanTitlePC (&t, &r, GAME_STRING (ORBITSCAN_STRING_BASE + 14),
 			RIGHT_SIDE_BASELINE_X_PC); // "Gravity: "
 	val = pSolarSysState->SysInfo.PlanetInfo.SurfaceGravity;
@@ -306,9 +286,7 @@ PrintCoarseScanPC (void)
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING_PC;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	PrintScanTitlePC (&t, &r, GAME_STRING (ORBITSCAN_STRING_BASE + 16),
 			RIGHT_SIDE_BASELINE_X_PC); // "Day: "
 	val = (SDWORD)pSolarSysState->SysInfo.PlanetInfo.RotationPeriod
@@ -319,9 +297,7 @@ PrintCoarseScanPC (void)
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING_PC;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	PrintScanTitlePC (&t, &r, GAME_STRING (ORBITSCAN_STRING_BASE + 18),
 			RIGHT_SIDE_BASELINE_X_PC); // "Tilt: "
 	val = pSolarSysState->SysInfo.PlanetInfo.AxialTilt;
@@ -331,7 +307,6 @@ PrintCoarseScanPC (void)
 	sprintf (buf, "%d" STR_DEGREE_SIGN, val);
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
-	UnlockMutex (GraphicsLock);
 }
 
 static void
@@ -345,7 +320,6 @@ PrintCoarseScan3DO (void)
 
 	GetPlanetTitle (buf, sizeof (buf));
 
-	LockMutex (GraphicsLock);
 	SetContext (PlanetContext);
 
 	t.align = ALIGN_CENTER;
@@ -363,8 +337,6 @@ PrintCoarseScan3DO (void)
 	s.frame = SetAbsFrameIndex (SpaceJunkFrame, 20);
 	DrawStamp (&s);
 
-	UnlockMutex (GraphicsLock);
-
 #define LEFT_SIDE_BASELINE_X (27 + (16 - SAFE_X))
 #define RIGHT_SIDE_BASELINE_X (SIS_SCREEN_WIDTH - LEFT_SIDE_BASELINE_X)
 #define SCAN_BASELINE_Y 25
@@ -373,7 +345,6 @@ PrintCoarseScan3DO (void)
 	t.baseline.y = SCAN_BASELINE_Y;
 	t.align = ALIGN_LEFT;
 
-	LockMutex (GraphicsLock);
 	t.pStr = buf;
 	val = ((pSolarSysState->SysInfo.PlanetInfo.PlanetToSunDist * 100L
 			+ (EARTH_RADIUS >> 1)) / EARTH_RADIUS);
@@ -381,9 +352,7 @@ PrintCoarseScan3DO (void)
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	t.pStr = buf;
 	if (pSolarSysState->SysInfo.PlanetInfo.AtmoDensity == GAS_GIANT_ATMOSPHERE)
 		strcpy (buf, STR_INFINITY_SIGN);
@@ -396,27 +365,21 @@ PrintCoarseScan3DO (void)
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	t.pStr = buf;
 	sprintf (buf, "%d" STR_DEGREE_SIGN,
 			pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature);
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	t.pStr = buf;
 	sprintf (buf, "<%u>", pSolarSysState->SysInfo.PlanetInfo.AtmoDensity == 0
 			? 0 : (pSolarSysState->SysInfo.PlanetInfo.Weather + 1));
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	t.pStr = buf;
 	sprintf (buf, "<%u>",
 			PLANSIZE (
@@ -425,13 +388,11 @@ PrintCoarseScan3DO (void)
 			? 0 : (pSolarSysState->SysInfo.PlanetInfo.Tectonics + 1));
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
-	UnlockMutex (GraphicsLock);
 
 	t.baseline.x = RIGHT_SIDE_BASELINE_X;
 	t.baseline.y = SCAN_BASELINE_Y;
 	t.align = ALIGN_RIGHT;
 
-	LockMutex (GraphicsLock);
 	t.pStr = buf;
 	val = pSolarSysState->SysInfo.PlanetInfo.PlanetRadius;
 	val = ((DWORD) val * (DWORD) val * (DWORD) val / 100L
@@ -443,9 +404,7 @@ PrintCoarseScan3DO (void)
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	t.pStr = buf;
 	val = pSolarSysState->SysInfo.PlanetInfo.PlanetRadius;
 	MakeScanValue (buf, val, STR_EARTH_SIGN);
@@ -453,9 +412,7 @@ PrintCoarseScan3DO (void)
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	t.pStr = buf;
 	val = pSolarSysState->SysInfo.PlanetInfo.SurfaceGravity;
 	if (val == 0)
@@ -464,9 +421,7 @@ PrintCoarseScan3DO (void)
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	t.pStr = buf;
 	val = pSolarSysState->SysInfo.PlanetInfo.AxialTilt;
 	if (val < 0)
@@ -475,16 +430,13 @@ PrintCoarseScan3DO (void)
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	t.pStr = buf;
 	val = (SDWORD)pSolarSysState->SysInfo.PlanetInfo.RotationPeriod
 			* 10 / 24;
 	MakeScanValue (buf, val, STR_EARTH_SIGN);
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
-	UnlockMutex (GraphicsLock);
 }
 
 static void
@@ -667,11 +619,9 @@ DispatchLander (void)
 	// Deactivate planet rotation callback
 	oldCallback = SetInputCallback (NULL);
 
-	LockMutex (GraphicsLock);
 	DeltaSISGauges (0, -landingFuel, 0);
 	SetContext (ScanContext);
 	drawPlanetCursor (FALSE);
-	UnlockMutex (GraphicsLock);
 
 	PlanetSide (planetLoc);
 	if (GLOBAL (CurrentActivity) & CHECK_ABORT)
@@ -749,7 +699,6 @@ DoPickPlanetSide (MENU_STATE *pMS)
 		if (CurrentInputState.menu[KEY_MENU_DOWN])
 			dy = 1;
 
-		LockMutex (GraphicsLock);
 		BatchGraphics ();
 
 		dx = dx << MAG_SHIFT;
@@ -777,7 +726,6 @@ DoPickPlanetSide (MENU_STATE *pMS)
 		flashPlanetLocation ();
 
 		UnbatchGraphics ();
-		UnlockMutex (GraphicsLock);
 
 		SleepThreadUntil (TimeIn + ONE_SECOND / 40);
 	}
@@ -799,9 +747,7 @@ drawLandingFuelUsage (COUNT fuel)
 static void
 eraseLandingFuelUsage (void)
 {
-	LockMutex (GraphicsLock);
 	DrawStatusMessage (NULL);
-	UnlockMutex (GraphicsLock);
 }
 
 static BOOLEAN
@@ -815,7 +761,6 @@ PickPlanetSide (void)
 	memset (&MenuState, 0, sizeof MenuState);
 	MenuState.privData = &PickState;
 
-	LockMutex (GraphicsLock);
 	ClearSISRect (CLEAR_SIS_RADAR);
 	SetContext (ScanContext);
 	BatchGraphics ();
@@ -827,7 +772,6 @@ PickPlanetSide (void)
 	// Set the current flash location
 	setPlanetCursorLoc (planetLoc);
 	savePlanetLocationImage ();
-	UnlockMutex (GraphicsLock);
 
 	InitLander (0);
 
@@ -844,9 +788,7 @@ PickPlanetSide (void)
 	}
 	else
 	{	// player bailed out
-		LockMutex (GraphicsLock);
 		restorePlanetLocationImage ();
-		UnlockMutex (GraphicsLock);
 	}
 
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
@@ -935,20 +877,20 @@ DrawScannedStuff (COUNT y, COUNT scan)
 }
 
 COUNT
-callGenerateForScanType (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT node, BYTE scanType)
+callGenerateForScanType (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT node, BYTE scanType, NODE_INFO *info)
 {
 	switch (scanType)
 	{
 		case MINERAL_SCAN:
 			return (*solarSys->genFuncs->generateMinerals) (
-					solarSys, world, node);
+					solarSys, world, node, info);
 		case ENERGY_SCAN:
 			return (*solarSys->genFuncs->generateEnergy) (
-					solarSys, world, node);
+					solarSys, world, node, info);
 		case BIOLOGICAL_SCAN:
 			return (*solarSys->genFuncs->generateLife) (
-					solarSys, world, node);
+					solarSys, world, node, info);
 	}
 
 	assert (false);
@@ -1026,7 +968,6 @@ ScanPlanet (COUNT scanType)
 
 		t.pStr = GAME_STRING (SCAN_STRING_BASE + scan);
 
-		LockMutex (GraphicsLock);
 		SetContext (PlanetContext);
 		r.corner.x = 0;
 		r.corner.y = t.baseline.y - 10;
@@ -1041,14 +982,11 @@ ScanPlanet (COUNT scanType)
 		font_DrawText (&t);
 
 		SetContext (ScanContext);
-		UnlockMutex (GraphicsLock);
 
 		// Draw a virgin surface
-		LockMutex (GraphicsLock);
 		BatchGraphics ();
 		DrawPlanet (0, BLACK_COLOR);
 		UnbatchGraphics ();
-		UnlockMutex (GraphicsLock);
 
 		tintColor = tintColors[scan];
 
@@ -1060,7 +998,6 @@ ScanPlanet (COUNT scanType)
 			if (WaitForAnyButtonUntil (TRUE, TimeOut, FALSE))
 				break;
 
-			LockMutex (GraphicsLock);
 			BatchGraphics ();
 			DrawPlanet (i, tintColor);
 			DrawScannedStuff (i, scan);
@@ -1068,21 +1005,17 @@ ScanPlanet (COUNT scanType)
 #ifdef SPIN_ON_SCAN
 			RotatePlanetSphere (TRUE);
 #endif
-			UnlockMutex (GraphicsLock);
 		}
 
 		if (i < SCAN_LINES)
 		{	// Aborted by a keypress; draw in finished state
-			LockMutex (GraphicsLock);
 			BatchGraphics ();
 			DrawPlanet (SCAN_LINES - 1, tintColor);
 			DrawScannedStuff (SCAN_LINES - 1, scan);
 			UnbatchGraphics ();
-			UnlockMutex (GraphicsLock);
 		}
 	}
 
-	LockMutex (GraphicsLock);
 	SetContext (PlanetContext);
 	RepairBackRect (&r);
 
@@ -1093,7 +1026,6 @@ ScanPlanet (COUNT scanType)
 		DrawScannedObjects (FALSE);
 	}
 
-	UnlockMutex (GraphicsLock);
 	FlushInput ();
 }
 
@@ -1135,17 +1067,13 @@ DoScan (MENU_STATE *pMS)
 				return TRUE;
 			}
 
-			LockMutex (GraphicsLock);
 			SetFlashRect (NULL);
-			UnlockMutex (GraphicsLock);
 
 			if (!PickPlanetSide ())
 				return FALSE;
 
 			DrawMenuStateStrings (PM_MIN_SCAN, pMS->CurState);
-			LockMutex (GraphicsLock);
 			SetFlashRect (SFR_MENU_3DO);
-			UnlockMutex (GraphicsLock);
 
 			return TRUE;
 		}
@@ -1235,9 +1163,7 @@ ScanSystem (void)
 
 	memset (&MenuState, 0, sizeof MenuState);
 
-	LockMutex (GraphicsLock);
 	GetScanContext (NULL);
-	UnlockMutex (GraphicsLock);
 
 	if (optWhichMenu == OPT_3DO &&
 			((pSolarSysState->pOrbitalDesc->data_index & PLANET_SHIELDED)
@@ -1252,17 +1178,13 @@ ScanSystem (void)
 		planetLoc.x = (MAP_WIDTH >> 1) << MAG_SHIFT;
 		planetLoc.y = (MAP_HEIGHT >> 1) << MAG_SHIFT;
 
-		LockMutex (GraphicsLock);
 		initPlanetLocationImage ();
 		SetContext (ScanContext);
 		DrawScannedObjects (FALSE);
-		UnlockMutex (GraphicsLock);
 	}
 
 	DrawMenuStateStrings (PM_MIN_SCAN, MenuState.CurState);
-	LockMutex (GraphicsLock);
 	SetFlashRect (SFR_MENU_3DO);
-	UnlockMutex (GraphicsLock);
 
 	if (optWhichCoarseScan == OPT_PC)
 		PrintCoarseScanPC ();
@@ -1274,18 +1196,14 @@ ScanSystem (void)
 	MenuState.InputFunc = DoScan;
 	DoInput (&MenuState, FALSE);
 
-	LockMutex (GraphicsLock);
 	SetFlashRect (NULL);
-	UnlockMutex (GraphicsLock);
 
 	// cleanup scan graphics
-	LockMutex (GraphicsLock);
 	BatchGraphics ();
 	SetContext (ScanContext);
 	DrawPlanet (0, BLACK_COLOR);
 	EraseCoarseScan ();
 	UnbatchGraphics ();
-	UnlockMutex (GraphicsLock);
 
 	DestroyDrawable (ReleaseDrawable (eraseFrame));
 	eraseFrame = NULL;
@@ -1293,17 +1211,16 @@ ScanSystem (void)
 
 static void
 generateBioNode (SOLARSYS_STATE *system, ELEMENT *NodeElementPtr,
-		BYTE *life_init_tab)
+		BYTE *life_init_tab, COUNT creatureType)
 {
 	COUNT i;
-	COUNT creatureType;
-
-	creatureType = system->SysInfo.PlanetInfo.CurType;
 
+	// NOTE: TFB_Random() calls here are NOT part of the deterministic planet
+	//   generation PRNG flow.
 	if (CreatureData[creatureType].Attributes & SPEED_MASK)
 	{
 		// Place moving creatures at a random location.
-		i = (COUNT)TFB_Random ();
+		i = TFB_Random ();
 		NodeElementPtr->current.location.x =
 				(LOBYTE (i) % (MAP_WIDTH - (8 << 1))) + 8;
 		NodeElementPtr->current.location.y =
@@ -1359,12 +1276,13 @@ GeneratePlanetSide (void)
 				NUM_SCANDOT_TRANSITIONS * (scan - ENERGY_SCAN));
 
 		num_nodes = callGenerateForScanType (pSolarSysState,
-				pSolarSysState->pOrbitalDesc, ~0, scan);
+				pSolarSysState->pOrbitalDesc, GENERATE_ALL, scan, NULL);
 
 		while (num_nodes--)
 		{
 			HELEMENT hNodeElement;
 			ELEMENT *NodeElementPtr;
+			NODE_INFO info;
 
 			if (isNodeRetrieved (&pSolarSysState->SysInfo.PlanetInfo,
 					scan, num_nodes))
@@ -1378,30 +1296,24 @@ GeneratePlanetSide (void)
 
 			callGenerateForScanType (pSolarSysState,
 					pSolarSysState->pOrbitalDesc, num_nodes,
-					scan);
+					scan, &info);
 
 			NodeElementPtr->scan_node = MAKE_WORD (scan, num_nodes + 1);
 			NodeElementPtr->playerNr = PS_NON_PLAYER;
-			NodeElementPtr->current.location.x =
-					pSolarSysState->SysInfo.PlanetInfo.CurPt.x;
-			NodeElementPtr->current.location.y =
-					pSolarSysState->SysInfo.PlanetInfo.CurPt.y;
+			NodeElementPtr->current.location.x = info.loc_pt.x;
+			NodeElementPtr->current.location.y = info.loc_pt.y;
 
 			SetPrimType (&DisplayArray[NodeElementPtr->PrimIndex], STAMP_PRIM);
 			if (scan == MINERAL_SCAN)
 			{
-				COUNT EType;
-
-				EType = pSolarSysState->SysInfo.PlanetInfo.CurType;
-				NodeElementPtr->turn_wait = (BYTE)EType;
-				NodeElementPtr->mass_points = HIBYTE (
-						pSolarSysState->SysInfo.PlanetInfo.CurDensity);
+				NodeElementPtr->turn_wait = info.type;
+				NodeElementPtr->mass_points = HIBYTE (info.density);
 				NodeElementPtr->current.image.frame = SetAbsFrameIndex (
 						MiscDataFrame, (NUM_SCANDOT_TRANSITIONS * 2)
-						+ ElementCategory (EType) * 5);
+						+ ElementCategory (info.type) * 5);
 				NodeElementPtr->next.image.frame = SetRelFrameIndex (
-						NodeElementPtr->current.image.frame, LOBYTE (
-						pSolarSysState->SysInfo.PlanetInfo.CurDensity) + 1);
+						NodeElementPtr->current.image.frame,
+						LOBYTE (info.density) + 1);
 				DisplayArray[NodeElementPtr->PrimIndex].Object.Stamp.frame =
 						IncFrameIndex (NodeElementPtr->next.image.frame);
 			}
@@ -1421,7 +1333,7 @@ GeneratePlanetSide (void)
 				else /* (scan == BIOLOGICAL_SCAN) */
 				{
 					generateBioNode (pSolarSysState, NodeElementPtr,
-							life_init_tab);
+							life_init_tab, info.type);
 				}
 			}
 
diff -ruNp src.orig/uqm/planets/scan.h src/uqm/planets/scan.h
--- src.orig/uqm/planets/scan.h	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/scan.h	2017-11-21 19:39:57 -0600
@@ -26,6 +26,9 @@ typedef struct scan_block SCAN_BLOCK;
 #include "libs/gfxlib.h"
 #include "planets.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
 struct scan_desc
 {
@@ -47,8 +50,8 @@ extern void ScanSystem (void);
 
 extern void RepairBackRect (RECT *pRect);
 extern void GeneratePlanetSide (void);
-extern COUNT callGenerateForScanType (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT node, BYTE scanType);
+extern COUNT callGenerateForScanType (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT node, BYTE scanType, NODE_INFO *);
 // Returns true if the node should be removed from the surface
 extern bool callPickupForScanType (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT node, BYTE scanType);
@@ -62,5 +65,9 @@ COUNT countNodesRetrieved (PLANET_INFO *
 void setNodeRetrieved (PLANET_INFO *planetInfo, BYTE scanType, BYTE nodeNr);
 void setNodeNotRetrieved (PLANET_INFO *planetInfo, BYTE scanType, BYTE nodeNr);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _SCAN_H */
 
diff -ruNp src.orig/uqm/planets/solarsys.c src/uqm/planets/solarsys.c
--- src.orig/uqm/planets/solarsys.c	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/solarsys.c	2017-11-21 19:39:57 -0600
@@ -16,12 +16,13 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+#include "solarsys.h"
 #include "lander.h"
 #include "../colors.h"
 #include "../controls.h"
 #include "../menustat.h"
 		// for DrawMenuStateStrings()
-#include "../encount.h"
+#include "../starmap.h"
 #include "../races.h"
 #include "../gamestr.h"
 #include "../gendef.h"
@@ -36,11 +37,11 @@
 #include "../ipdisp.h"
 #include "../grpinfo.h"
 #include "../process.h"
-#include "../load.h"
 #include "../setup.h"
 #include "../sounds.h"
 #include "../state.h"
 #include "../uqmdebug.h"
+#include "../save.h"
 #include "options.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/mathlib.h"
@@ -94,6 +95,7 @@ static FRAME SolarSysFrame;
 static RECT scaleRect;
 		// system zooms in when the flagship enters this rect
 
+RandomContext *SysGenRNG;
 
 #define DISPLAY_TO_LOC  (DISPLAY_FACTOR >> 1)
 
@@ -210,15 +212,15 @@ playerInInnerSystem (void)
 	return pSolarSysState->pBaseDesc != pSolarSysState->PlanetDesc;
 }
 
+// Sets the SysGenRNG to the required state first.
 static void
 GenerateMoons (SOLARSYS_STATE *system, PLANET_DESC *planet)
 {
 	COUNT i;
 	COUNT facing;
 	PLANET_DESC *pMoonDesc;
-	DWORD old_seed;
 
-	old_seed = TFB_SeedRandom (planet->rand_seed);
+	RandomContext_SeedRandom (SysGenRNG, planet->rand_seed);
 
 	(*system->genFuncs->generateName) (system, planet);
 	(*system->genFuncs->generateMoons) (system, planet);
@@ -234,8 +236,6 @@ GenerateMoons (SOLARSYS_STATE *system, P
 		
 		pMoonDesc->temp_color = planet->temp_color;
 	}
-
-	TFB_SeedRandom (old_seed);
 }
 
 void
@@ -255,6 +255,9 @@ FreeIPData (void)
 	SpaceJunkFrame = 0;
 	DestroyMusic (SpaceMusic);
 	SpaceMusic = 0;
+
+	RandomContext_Delete (SysGenRNG);
+	SysGenRNG = NULL;
 }
 
 void
@@ -274,6 +277,11 @@ LoadIPData (void)
 
 		SpaceMusic = LoadMusic (IP_MUSIC);
 	}
+
+	if (!SysGenRNG)
+	{
+		SysGenRNG = RandomContext_New ();
+	}
 }
 	
 
@@ -349,11 +357,10 @@ initSolarSysSISCharacteristics (void)
 	}
 }
 
-static DWORD
-seedRandomForSolarSys (void)
+DWORD
+GetRandomSeedForStar (const STAR_DESC *star)
 {
-	return TFB_SeedRandom (MAKE_DWORD (CurStarDescPtr->star_pt.x,
-			CurStarDescPtr->star_pt.y));
+	return MAKE_DWORD (star->star_pt.x, star->star_pt.y);
 }
 
 // Returns an orbital PLANET_DESC when player is in orbit
@@ -363,7 +370,6 @@ LoadSolarSys (void)
 	COUNT i;
 	PLANET_DESC *orbital = NULL;
 	PLANET_DESC *pCurDesc;
-	DWORD old_seed;
 #define NUM_TEMP_RANGES 5
 	static const Color temp_color_array[NUM_TEMP_RANGES] =
 	{
@@ -374,13 +380,13 @@ LoadSolarSys (void)
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x08, 0x00), 0x75),
 	};
 
-	old_seed = seedRandomForSolarSys ();
+	RandomContext_SeedRandom (SysGenRNG, GetRandomSeedForStar (CurStarDescPtr));
 
 	SunFrame = SetAbsFrameIndex (SunFrame, STAR_TYPE (CurStarDescPtr->Type));
 
 	pCurDesc = &pSolarSysState->SunDesc[0];
 	pCurDesc->pPrevDesc = 0;
-	pCurDesc->rand_seed = TFB_Random ();
+	pCurDesc->rand_seed = RandomContext_Random (SysGenRNG);
 
 	pCurDesc->data_index = STAR_TYPE (CurStarDescPtr->Type);
 	pCurDesc->location.x = 0;
@@ -466,9 +472,6 @@ LoadSolarSys (void)
 		GLOBAL (ShipStamp.frame) = SetAbsFrameIndex (SISIPFrame, i - 1);
 	}
 
-	// Restore RNG state:
-	TFB_SeedRandom (old_seed);
-
 	return orbital;
 }
 
@@ -527,7 +530,7 @@ getCollisionFrame (PLANET_DESC *planet,
 
 // Returns the planet with which the flagship is colliding
 static PLANET_DESC *
-CheckIntersect (BOOLEAN just_checking)
+CheckIntersect (void)
 {
 	COUNT i;
 	PLANET_DESC *pCurDesc;
@@ -618,16 +621,9 @@ CheckIntersect (BOOLEAN just_checking)
 				continue;
 			}
 			
-			if (playerInInnerSystem ())
-			{	// Collision in the inner system (starts orbital)
-				pSolarSysState->WaitIntersect = NewWaitPlanet;
-			}
-			else
-			{	// Going into an inner system
-				// So there is now no existing collision
-				if (!just_checking)
-					pSolarSysState->WaitIntersect = 0;
-			}
+			// Collision with a new planet/moon. This may cause a transition
+			// to an inner system or start an orbital view.
+			pSolarSysState->WaitIntersect = NewWaitPlanet;
 			return pCurDesc;
 		}
 	}
@@ -942,7 +938,7 @@ leaveInnerSystem (PLANET_DESC *planet)
 	// See if we also intersect with another planet, and if we do,
 	// disable collisions comletely until we stop intersecting
 	// with any planet at all.
-	CheckIntersect (TRUE);
+	CheckIntersect ();
 	if (pSolarSysState->WaitIntersect != outerPlanetWait)
 		pSolarSysState->WaitIntersect = (COUNT)~0;
 }
@@ -998,7 +994,7 @@ CheckShipLocation (SIZE *newRadius)
 
 	if (GLOBAL (autopilot.x) == ~0 && GLOBAL (autopilot.y) == ~0)
 	{	// Not on autopilot -- may collide with a planet
-		PLANET_DESC *planet = CheckIntersect (FALSE);
+		PLANET_DESC *planet = CheckIntersect ();
 		if (planet)
 		{	// Collision with a planet
 			if (playerInInnerSystem ())
@@ -1034,10 +1030,8 @@ DrawSystemTransition (BOOLEAN inner)
 static void
 TransitionSystemIn (void)
 {
-	LockMutex (GraphicsLock);
 	SetContext (SpaceContext);
 	DrawSystemTransition (playerInInnerSystem ());
-	UnlockMutex (GraphicsLock);
 }
 
 static void
@@ -1121,7 +1115,6 @@ IP_frame (void)
 	BOOLEAN locChange;
 	SIZE newRadius;
 
-	LockMutex (GraphicsLock);
 	SetContext (SpaceContext);
 
 	GameClockTick ();
@@ -1152,7 +1145,6 @@ IP_frame (void)
 		UnbatchGraphics ();
 	}
 	
-	UnlockMutex (GraphicsLock);
 }
 
 static BOOLEAN
@@ -1241,7 +1233,12 @@ ResetSolarSys (void)
 	DoMissions ();
 
 	// Figure out and note which planet/moon we just left, if any
-	CheckIntersect (TRUE);
+	// This records any existing collision and prevents the ship
+	// from entering planets until a new collision occurs.
+	// TODO: this may need logic similar to one in leaveInnerSystem()
+	//   for when the ship collides with more than one planet at
+	//   the same time. While quite rare, it's still possible.
+	CheckIntersect ();
 	
 	pSolarSysState->InIpFlight = TRUE;
 
@@ -1310,9 +1307,7 @@ EnterPlanetOrbit (void)
 		ValidateInnerOrbits ();
 		ResetSolarSys ();
 
-		LockMutex (GraphicsLock);
 		RepairSISBorder ();
-		UnlockMutex (GraphicsLock);
 		TransitionSystemIn ();
 	}
 }
@@ -1324,11 +1319,9 @@ InitSolarSys (void)
 	BOOLEAN Reentry;
 	PLANET_DESC *orbital;
 
-	LockMutex (GraphicsLock);
 
 	LoadIPData ();
 	LoadLanderData ();
-	UnlockMutex (GraphicsLock);
 
 	Reentry = (GLOBAL (ShipFacing) != 0);
 	if (!Reentry)
@@ -1343,7 +1336,6 @@ InitSolarSys (void)
 				MAX_ZOOM_RADIUS);
 	}
 
-	LockMutex (GraphicsLock);
 
 	StarsFrame = CreateStarBackGround ();
 	
@@ -1351,7 +1343,6 @@ InitSolarSys (void)
 	SetContextFGFrame (Screen);
 	SetContextBackGroundColor (BLACK_COLOR);
 	
-	UnlockMutex (GraphicsLock);
 
 	orbital = LoadSolarSys ();
 	InnerSystem = CheckZoomLevel ();
@@ -1379,7 +1370,6 @@ InitSolarSys (void)
 	}
 	else
 	{	// Draw the borders, the system (inner or outer) and fade/transition
-		LockMutex (GraphicsLock);
 		SetContext (SpaceContext);
 
 		SetTransitionSource (NULL);
@@ -1417,8 +1407,6 @@ InitSolarSys (void)
 
 			LastActivity &= ~CHECK_LOAD;
 		}
-		
-		UnlockMutex (GraphicsLock);
 	}
 }
 
@@ -1657,11 +1645,11 @@ CreateStarBackGround (void)
 	COUNT i, j;
 	DWORD rand_val;
 	STAMP s;
-	DWORD old_seed;
 	CONTEXT oldContext;
 	RECT clipRect;
 	FRAME frame;
 
+	// Use SpaceContext to find out the dimensions of the background
 	oldContext = SetContext (SpaceContext);
 	GetContextClipRect (&clipRect);
 
@@ -1675,7 +1663,7 @@ CreateStarBackGround (void)
 
 	ClearDrawable ();
 
-	old_seed = seedRandomForSolarSys ();
+	RandomContext_SeedRandom (SysGenRNG, GetRandomSeedForStar (CurStarDescPtr));
 
 #define NUM_DIM_PIECES 8
 	s.frame = SpaceJunkFrame;
@@ -1684,7 +1672,7 @@ CreateStarBackGround (void)
 #define NUM_DIM_DRAWN 5
 		for (j = 0; j < NUM_DIM_DRAWN; ++j)
 		{
-			rand_val = TFB_Random ();
+			rand_val = RandomContext_Random (SysGenRNG);
 			s.origin.x = LOWORD (rand_val) % SIS_SCREEN_WIDTH;
 			s.origin.y = HIWORD (rand_val) % SIS_SCREEN_HEIGHT;
 
@@ -1698,7 +1686,7 @@ CreateStarBackGround (void)
 #define NUM_BRT_DRAWN 30
 		for (j = 0; j < NUM_BRT_DRAWN; ++j)
 		{
-			rand_val = TFB_Random ();
+			rand_val = RandomContext_Random (SysGenRNG);
 			s.origin.x = LOWORD (rand_val) % SIS_SCREEN_WIDTH;
 			s.origin.y = HIWORD (rand_val) % SIS_SCREEN_HEIGHT;
 
@@ -1707,8 +1695,6 @@ CreateStarBackGround (void)
 		s.frame = IncFrameIndex (s.frame);
 	}
 
-	TFB_SeedRandom (old_seed);
-
 	SetContext (oldContext);
 
 	return frame;
@@ -1929,9 +1915,7 @@ DoSolarSysMenu (MENU_STATE *pMS)
 	if (!select)
 		return TRUE;
 
-	LockMutex (GraphicsLock);
 	SetFlashRect (NULL);
-	UnlockMutex (GraphicsLock);
 
 	switch (pMS->CurState)
 	{
@@ -1972,9 +1956,7 @@ DoSolarSysMenu (MENU_STATE *pMS)
 				pMS->CurState = NAVIGATION;
 			DrawMenuStateStrings (PM_STARMAP, pMS->CurState);
 		}
-		LockMutex (GraphicsLock);
 		SetFlashRect (SFR_MENU_3DO);
-		UnlockMutex (GraphicsLock);
 	}
 
 	return TRUE;
@@ -1997,10 +1979,8 @@ SolarSysMenu (void)
 		MenuState.CurState = STARMAP;
 	}
 
-	LockMutex (GraphicsLock);
 	DrawStatusMessage (NULL);
 	SetFlashRect (SFR_MENU_3DO);
-	UnlockMutex (GraphicsLock);
 
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
 	MenuState.InputFunc = DoSolarSysMenu;
diff -ruNp src.orig/uqm/planets/solarsys.h src/uqm/planets/solarsys.h
--- src.orig/uqm/planets/solarsys.h	1969-12-31 18:00:00 -0600
+++ src/uqm/planets/solarsys.h	2017-11-21 19:39:57 -0600
@@ -0,0 +1,34 @@
+//Copyright (C) 2011, Scott A. Colcord
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef SOLARSYS_H
+#define SOLARSYS_H
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+extern void LoadIPData (void);
+extern void FreeIPData (void);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif /* SOLARSYS_H */
+
diff -ruNp src.orig/uqm/planets/sundata.h src/uqm/planets/sundata.h
--- src.orig/uqm/planets/sundata.h	2017-11-21 19:39:39 -0600
+++ src/uqm/planets/sundata.h	2017-11-21 19:39:57 -0600
@@ -22,6 +22,9 @@
 #include "plandata.h"
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
 /*------------------------------ Global Data ------------------------------ */
 
@@ -39,13 +42,19 @@ typedef struct
 
 	PLANET_INFO PlanetInfo;
 } SYSTEM_INFO;
+
+#define GENERATE_ALL  ((COUNT)~0)
 		
-extern DWORD GenerateMineralDeposits (SYSTEM_INFO *SysInfoPtr,
-		COUNT *pwhich_deposit);
-extern DWORD GenerateLifeForms (SYSTEM_INFO *SysInfoPtr, COUNT *pwhich_life);
-extern void GenerateRandomLocation (SYSTEM_INFO *);
-extern DWORD GenerateRandomNodes (SYSTEM_INFO *, COUNT scan, COUNT numNodes,
-		COUNT type, COUNT *whichNode);
+extern COUNT GenerateMineralDeposits (const SYSTEM_INFO *, COUNT whichDeposit,
+		NODE_INFO *info);
+extern COUNT GenerateLifeForms (const SYSTEM_INFO *, COUNT whichLife,
+		NODE_INFO *info);
+extern void GenerateRandomLocation (POINT *loc);
+extern COUNT GenerateRandomNodes (const SYSTEM_INFO *, COUNT scan, COUNT numNodes,
+		COUNT type, COUNT whichNode, NODE_INFO *info);
+// Generate lifeforms from a preset lifeTypes[] array
+extern COUNT GeneratePresetLife (const SYSTEM_INFO *,
+		const SBYTE *lifeTypes, COUNT whichLife, NODE_INFO *info);
 
 #define DWARF_ELEMENT_DENSITY  1
 #define GIANT_ELEMENT_DENSITY 3
@@ -53,10 +62,12 @@ extern DWORD GenerateRandomNodes (SYSTEM
 
 #define MAX_ELEMENT_DENSITY ((MAX_ELEMENT_UNITS * SUPERGIANT_ELEMENT_DENSITY) << 1)
 
-extern DWORD DoPlanetaryAnalysis (SYSTEM_INFO *SysInfoPtr,
+extern void DoPlanetaryAnalysis (SYSTEM_INFO *SysInfoPtr,
 		PLANET_DESC *pPlanetDesc);
 
-extern SYSTEM_INFO CurSysInfo;
+#if defined(__cplusplus)
+}
+#endif
 
 #endif /* _SUNDATA_H */
 
diff -ruNp src.orig/uqm/planets/surface.c src/uqm/planets/surface.c
--- src.orig/uqm/planets/surface.c	2017-11-21 19:39:40 -0600
+++ src/uqm/planets/surface.c	2017-11-21 19:39:57 -0600
@@ -28,7 +28,8 @@ const BYTE *Elements;
 const PlanetFrame *PlanData;
 
 static COUNT
-CalcMineralDeposits (SYSTEM_INFO *SysInfoPtr, COUNT which_deposit)
+CalcMineralDeposits (const SYSTEM_INFO *SysInfoPtr, COUNT which_deposit,
+		NODE_INFO *info)
 {
 	BYTE j;
 	COUNT num_deposits;
@@ -41,16 +42,16 @@ CalcMineralDeposits (SYSTEM_INFO *SysInf
 	{
 		BYTE num_possible;
 
-		num_possible = (BYTE)((BYTE)TFB_Random ()
-				% (DEPOSIT_QUANTITY (eptr->Density) + 1));
+		num_possible = LOBYTE (RandomContext_Random (SysGenRNG))
+				% (DEPOSIT_QUANTITY (eptr->Density) + 1);
 		while (num_possible--)
 		{
 #define MEDIUM_DEPOSIT_THRESHOLD 150
 #define LARGE_DEPOSIT_THRESHOLD 225
-			COUNT deposit_quality_fine,
-						deposit_quality_gross;
+			COUNT deposit_quality_fine;
+			COUNT deposit_quality_gross;
 
-			deposit_quality_fine = ((COUNT)TFB_Random () % 100)
+			deposit_quality_fine = (LOWORD (RandomContext_Random (SysGenRNG)) % 100)
 					+ (
 					DEPOSIT_QUALITY (eptr->Density)
 					+ SysInfoPtr->StarSize
@@ -62,222 +63,189 @@ CalcMineralDeposits (SYSTEM_INFO *SysInf
 			else
 				deposit_quality_gross = 2;
 
-			GenerateRandomLocation (SysInfoPtr);
+			GenerateRandomLocation (&info->loc_pt);
 
-			SysInfoPtr->PlanetInfo.CurDensity =
-					MAKE_WORD (
-					deposit_quality_gross, deposit_quality_fine / 10 + 1
-					);
-			SysInfoPtr->PlanetInfo.CurType = eptr->ElementType;
+			info->density = MAKE_WORD (
+					deposit_quality_gross, deposit_quality_fine / 10 + 1);
+			info->type = eptr->ElementType;
 #ifdef DEBUG_SURFACE
 			log_add (log_Debug, "\t\t%d units of %Fs",
-					SysInfoPtr->PlanetInfo.CurDensity,
+					info->density,
 					Elements[eptr->ElementType].name);
 #endif /* DEBUG_SURFACE */
 			if (num_deposits >= which_deposit
 					|| ++num_deposits == sizeof (DWORD) * 8)
-				goto ExitCalcMinerals;
+			{	// reached the maximum or the requested node
+				return num_deposits;
+			}
 		}
 		++eptr;
 	} while (--j);
 
-ExitCalcMinerals:
-	return (num_deposits);
+	return num_deposits;
 }
 
-DWORD
-GenerateMineralDeposits (SYSTEM_INFO *SysInfoPtr, COUNT *pwhich_deposit)
-{
-	DWORD old_rand;
-
-	old_rand = TFB_SeedRandom (SysInfoPtr->PlanetInfo.ScanSeed[MINERAL_SCAN]);
-	*pwhich_deposit = CalcMineralDeposits (SysInfoPtr, *pwhich_deposit);
-	return (TFB_SeedRandom (old_rand));
+// Returns:
+//   for whichLife==~0 : the number of nodes generated
+//   for whichLife<32  : the index of the last node (no known usage exists)
+// Sets the SysGenRNG to the required state first.
+COUNT
+GenerateMineralDeposits (const SYSTEM_INFO *SysInfoPtr, COUNT whichDeposit,
+		NODE_INFO *info)
+{
+	NODE_INFO temp_info;
+	if (!info) // user not interested in info but we need space for it
+		info = &temp_info;
+	RandomContext_SeedRandom (SysGenRNG,
+			SysInfoPtr->PlanetInfo.ScanSeed[MINERAL_SCAN]);
+	return CalcMineralDeposits (SysInfoPtr, whichDeposit, info);
 }
 
 static COUNT
-CalcLifeForms (SYSTEM_INFO *SysInfoPtr, COUNT which_life)
+CalcLifeForms (const SYSTEM_INFO *SysInfoPtr, COUNT which_life,
+		NODE_INFO *info)
 {
 	COUNT num_life_forms;
 
 	num_life_forms = 0;
-	if (PLANSIZE (SysInfoPtr->PlanetInfo.PlanDataPtr->Type) == GAS_GIANT)
-		SysInfoPtr->PlanetInfo.LifeChance = -1;
-	else
+	if (PLANSIZE (SysInfoPtr->PlanetInfo.PlanDataPtr->Type) != GAS_GIANT)
 	{
 #define MIN_LIFE_CHANCE 10
 		SIZE life_var;
 
-		life_var = 0;
-
-		if (SysInfoPtr->PlanetInfo.SurfaceTemperature < -151)
-			life_var -= 300;
-		else if (SysInfoPtr->PlanetInfo.SurfaceTemperature < -51)
-			life_var -= 100;
-		else if (SysInfoPtr->PlanetInfo.SurfaceTemperature < 0)
-			life_var += 100;
-		else if (SysInfoPtr->PlanetInfo.SurfaceTemperature < 50)
-			life_var += 300;
-		else if (SysInfoPtr->PlanetInfo.SurfaceTemperature < 150)
-			life_var += 50;
-		else if (SysInfoPtr->PlanetInfo.SurfaceTemperature < 250)
-			life_var -= 100;
-		else if (SysInfoPtr->PlanetInfo.SurfaceTemperature < 500)
-			life_var -= 400;
-		else
-			life_var -= 800;
-
-		if (SysInfoPtr->PlanetInfo.AtmoDensity == 0)
-			life_var -= 1000;
-		else if (SysInfoPtr->PlanetInfo.AtmoDensity < 15)
-			life_var += 100;
-		else if (SysInfoPtr->PlanetInfo.AtmoDensity < 30)
-			life_var += 200;
-		else if (SysInfoPtr->PlanetInfo.AtmoDensity < 100)
-			life_var += 300;
-		else if (SysInfoPtr->PlanetInfo.AtmoDensity < 1000)
-			life_var += 150;
-		else if (SysInfoPtr->PlanetInfo.AtmoDensity < 2500)
-			;
-		else
-			life_var -= 100;
-
-#ifndef NOTYET
-		life_var += 200 + 80 + 80;
-#else /* NOTYET */
-		if (SysInfoPtr->PlanetInfo.SurfaceGravity < 10)
-			;
-		else if (SysInfoPtr->PlanetInfo.SurfaceGravity < 35)
-			life_var += 50;
-		else if (SysInfoPtr->PlanetInfo.SurfaceGravity < 75)
-			life_var += 100;
-		else if (SysInfoPtr->PlanetInfo.SurfaceGravity < 150)
-			life_var += 200;
-		else if (SysInfoPtr->PlanetInfo.SurfaceGravity < 400)
-			life_var += 50;
-		else if (SysInfoPtr->PlanetInfo.SurfaceGravity < 800)
-			;
-		else
-			life_var -= 100;
-
-		if (SysInfoPtr->PlanetInfo.Tectonics < 1)
-			life_var += 80;
-		else if (SysInfoPtr->PlanetInfo.Tectonics < 2)
-			life_var += 70;
-		else if (SysInfoPtr->PlanetInfo.Tectonics < 3)
-			life_var += 60;
-		else if (SysInfoPtr->PlanetInfo.Tectonics < 4)
-			life_var += 50;
-		else if (SysInfoPtr->PlanetInfo.Tectonics < 5)
-			life_var += 25;
-		else if (SysInfoPtr->PlanetInfo.Tectonics < 6)
-			;
-		else
-			life_var -= 100;
-
-		if (SysInfoPtr->PlanetInfo.Weather < 1)
-			life_var += 80;
-		else if (SysInfoPtr->PlanetInfo.Weather < 2)
-			life_var += 70;
-		else if (SysInfoPtr->PlanetInfo.Weather < 3)
-			life_var += 60;
-		else if (SysInfoPtr->PlanetInfo.Weather < 4)
-			life_var += 50;
-		else if (SysInfoPtr->PlanetInfo.Weather < 5)
-			life_var += 25;
-		else if (SysInfoPtr->PlanetInfo.Weather < 6)
-			;
-		else
-			life_var -= 100;
-#endif /* NOTYET */
-
-		SysInfoPtr->PlanetInfo.LifeChance = life_var;
-
-		life_var = (COUNT)TFB_Random () & 1023;
+		life_var = RandomContext_Random (SysGenRNG) & 1023;
 		if (life_var < SysInfoPtr->PlanetInfo.LifeChance
 				|| (SysInfoPtr->PlanetInfo.LifeChance < MIN_LIFE_CHANCE
 				&& life_var < MIN_LIFE_CHANCE))
 		{
 			BYTE num_types;
 
-			num_types = (BYTE)(((BYTE)TFB_Random () % MAX_LIFE_VARIATION) + 1);
+			num_types = 1 + LOBYTE (RandomContext_Random (SysGenRNG))
+					% MAX_LIFE_VARIATION;
 			do
 			{
 				BYTE index, num_creatures;
 				UWORD rand_val;
 
-				rand_val = (UWORD)TFB_Random ();
+				rand_val = RandomContext_Random (SysGenRNG);
 				index = LOBYTE (rand_val) % NUM_CREATURE_TYPES;
-				num_creatures = (BYTE)((HIBYTE (rand_val) % 10) + 1);
+				num_creatures = 1 + HIBYTE (rand_val) % 10;
 				do
 				{
-					GenerateRandomLocation (SysInfoPtr);
-					SysInfoPtr->PlanetInfo.CurType = index;
+					GenerateRandomLocation (&info->loc_pt);
+					info->type = index;
+					info->density = 0;
 
 					if (num_life_forms >= which_life
 							|| ++num_life_forms == sizeof (DWORD) * 8)
-					{
-						num_types = 1;
-						break;
+					{	// reached the maximum or the requested node
+						return num_life_forms;
 					}
 				} while (--num_creatures);
 			} while (--num_types);
 		}
 #ifdef DEBUG_SURFACE
 		else
+		{
 			log_add (log_Debug, "It's dead, Jim! (%d >= %d)", life_var,
 				SysInfoPtr->PlanetInfo.LifeChance);
+		}
 #endif /* DEBUG_SURFACE */
 	}
 
-	return (num_life_forms);
+	return num_life_forms;
+}
+
+// Returns:
+//   for whichLife==~0 : the number of lifeforms generated
+//   for whichLife<32  : the index of the last lifeform (no known usage exists)
+// Sets the SysGenRNG to the required state first.
+COUNT
+GenerateLifeForms (const SYSTEM_INFO *SysInfoPtr, COUNT whichLife,
+		NODE_INFO *info)
+{
+	NODE_INFO temp_info;
+	if (!info) // user not interested in info but we need space for it
+		info = &temp_info;
+	RandomContext_SeedRandom (SysGenRNG,
+			SysInfoPtr->PlanetInfo.ScanSeed[BIOLOGICAL_SCAN]);
+	return CalcLifeForms (SysInfoPtr, whichLife, info);
 }
 
-DWORD
-GenerateLifeForms (SYSTEM_INFO *SysInfoPtr, COUNT *pwhich_life)
+// Returns:
+//   for whichLife==~0 : the number of lifeforms generated
+//   for whichLife<32  : the index of the last lifeform (no known usage exists)
+// Sets the SysGenRNG to the required state first.
+// lifeTypes[] is terminated with -1
+COUNT
+GeneratePresetLife (const SYSTEM_INFO *SysInfoPtr, const SBYTE *lifeTypes,
+		COUNT whichLife, NODE_INFO *info)
 {
-	DWORD old_rand;
+	COUNT i;
+	NODE_INFO temp_info;
+
+	if (!info) // user not interested in info but we need space for it
+		info = &temp_info;
 
-	old_rand = TFB_SeedRandom (
+	// This function may look unnecessarily complicated, but it must be
+	// kept this way to preserve the universe. That is done by preserving
+	// the order and number of Random() calls.
+
+	RandomContext_SeedRandom (SysGenRNG,
 			SysInfoPtr->PlanetInfo.ScanSeed[BIOLOGICAL_SCAN]);
-	*pwhich_life = CalcLifeForms (SysInfoPtr, *pwhich_life);
-	return (TFB_SeedRandom (old_rand));
+
+	for (i = 0; lifeTypes[i] >= 0; ++i)
+	{
+		GenerateRandomLocation (&info->loc_pt);
+		info->type = lifeTypes[i];
+		// density is irrelevant for bio nodes
+		info->density = 0;
+
+		if (i >= whichLife)
+			break;
+	}
+	
+	return i;
 }
 
 void
-GenerateRandomLocation (SYSTEM_INFO *SysInfoPtr)
+GenerateRandomLocation (POINT *loc)
 {
 	UWORD rand_val;
 
-	rand_val = (UWORD)TFB_Random ();
-	SysInfoPtr->PlanetInfo.CurPt.x =
-			(LOBYTE (rand_val) % (MAP_WIDTH - (8 << 1))) + 8;
-	SysInfoPtr->PlanetInfo.CurPt.y =
-			(HIBYTE (rand_val) % (MAP_HEIGHT - (8 << 1))) + 8;
+	rand_val = RandomContext_Random (SysGenRNG);
+	loc->x = 8 + LOBYTE (rand_val) % (MAP_WIDTH - (8 << 1));
+	loc->y = 8 + HIBYTE (rand_val) % (MAP_HEIGHT - (8 << 1));
 }
 
-DWORD
-GenerateRandomNodes (SYSTEM_INFO *SysInfoPtr, COUNT scan, COUNT numNodes,
-		COUNT type, COUNT *whichNode)
+// Returns:
+//   for whichNode==~0 : the number of nodes generated
+//   for whichNode<32  : the index of the last node (no known usage exists)
+// Sets the SysGenRNG to the required state first.
+COUNT
+GenerateRandomNodes (const SYSTEM_INFO *SysInfoPtr, COUNT scan, COUNT numNodes,
+		COUNT type, COUNT whichNode, NODE_INFO *info)
 {
-	DWORD old_rand;
 	COUNT i;
+	NODE_INFO temp_info;
+
+	if (!info) // user not interested in info but we need space for it
+		info = &temp_info;
 
-	old_rand = TFB_SeedRandom (SysInfoPtr->PlanetInfo.ScanSeed[scan]);
+	RandomContext_SeedRandom (SysGenRNG,
+			SysInfoPtr->PlanetInfo.ScanSeed[scan]);
 
 	for (i = 0; i < numNodes; ++i)
 	{
-		GenerateRandomLocation (SysInfoPtr);
-		// CurType is irrelevant for energy nodes
-		SysInfoPtr->PlanetInfo.CurType = type;
-		// CurDensity is irrelevant for energy and bio nodes
-		SysInfoPtr->PlanetInfo.CurDensity = 0;
+		GenerateRandomLocation (&info->loc_pt);
+		// type is irrelevant for energy nodes
+		info->type = type;
+		// density is irrelevant for energy and bio nodes
+		info->density = 0;
 
-		if (i >= *whichNode)
+		if (i >= whichNode)
 			break;
 	}
 	
-	*whichNode = i; // only matters when count is requested
-
-	return (TFB_SeedRandom (old_rand));
+	return i;
 }
diff -ruNp src.orig/uqm/process.c src/uqm/process.c
--- src.orig/uqm/process.c	2017-11-21 19:39:40 -0600
+++ src/uqm/process.c	2017-11-21 19:39:57 -0600
@@ -308,12 +308,11 @@ CalcView (POINT *pNewScrollPt, SIZE next
 			dy = -ORG_JUMP_Y;
 	}
 
-	if ((dx || dy) && LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+	if ((dx || dy) && inHQSpace ())
 		MoveSIS (&dx, &dy);
 
 	if (zoom_out == next_reduction)
-		view_state = dx == 0 && dy == 0
-				&& LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE
+		view_state = dx == 0 && dy == 0 && !inHQSpace ()
 				? VIEW_STABLE : VIEW_SCROLL;
 	else
 	{
diff -ruNp src.orig/uqm/process.h src/uqm/process.h
--- src.orig/uqm/process.h	2017-11-21 19:39:40 -0600
+++ src/uqm/process.h	2017-11-21 19:39:57 -0600
@@ -21,9 +21,17 @@
 #include "libs/gfxlib.h"
 #include "element.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern void RedrawQueue (BOOLEAN clear);
 extern void InitDisplayList (void);
 extern void SetUpElement (ELEMENT *ElementPtr);
 extern void InsertPrim (PRIM_LINKS *pLinks, COUNT primIndex, COUNT iPI);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* UQM_PROCESS_H_INCL_ */
diff -ruNp src.orig/uqm/races.h src/uqm/races.h
--- src.orig/uqm/races.h	2017-11-21 19:39:40 -0600
+++ src/uqm/races.h	2017-11-21 19:39:57 -0600
@@ -31,6 +31,10 @@ typedef HLINK HSTARSHIP;
 #include "libs/sndlib.h"
 #include "libs/reslib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 
 // TODO: remove RACES_PER_PLAYER remnant of SC1
 #define RACES_PER_PLAYER 7
@@ -155,6 +159,7 @@ typedef struct
 
 typedef struct
 {
+	const char *idStr;
 	UWORD ship_flags;
 	BYTE ship_cost;
 	
@@ -217,7 +222,7 @@ struct race_desc
 	POSTPROCESS_FUNC *postprocess_func;
 	INIT_WEAPON_FUNC *init_weapon_func;
 
-	intptr_t data;  // private ship data, ship code owns this
+	void* data;  // private ship data, ship code owns this
 
 	void *CodeRef;
 };
@@ -339,6 +344,7 @@ typedef struct
 	HFLEETINFO succ;
 
 	SPECIES_ID SpeciesID;
+	const char *shipIdStr;
 
 	UWORD allied_state; /* GOOD_GUY, BAD_GUY or DEAD_GUY */
 	BYTE days_left;   /* Days left before the fleet reachers 'dest_loc'. */
@@ -380,9 +386,9 @@ typedef struct
 // Values for FLEET_INFO.allied_state
 enum
 {
-	DEAD_GUY = 0,
-	GOOD_GUY,
-	BAD_GUY,
+	DEAD_GUY = 0,  // Race is extinct
+	GOOD_GUY,      // Race is allied with the player
+	BAD_GUY,       // Race is not allied with the player
 };
 
 static inline FLEET_INFO *
@@ -394,7 +400,8 @@ LockFleetInfo (const QUEUE *pq, HFLEETIN
 
 #define UnlockFleetInfo(pq, h) UnlockLink (pq, h)
 
-enum
+// Used as index into avail_race_q.
+typedef enum
 {
 	ARILOU_SHIP,
 	CHMMR_SHIP,
@@ -424,7 +431,7 @@ enum
 	SAMATRA_SHIP = URQUAN_DRONE_SHIP,
 
 	NUM_AVAILABLE_RACES
-};
+} RACE_ID;
 
 #define RACE_COMMUNICATION \
 		ARILOU_CONVERSATION,       /* ARILOU_SHIP */ \
@@ -664,5 +671,9 @@ enum
 		BUILD_COLOR (MAKE_RGB15_INIT (0x06, 0x06, 0x06), 0x20),  /* BLACK_URQUAN_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x14, 0x07, 0x1F), 0x39),  /* YEHAT_REBEL_SHIP */
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _RACES_H */
 
diff -ruNp src.orig/uqm/resinst.h src/uqm/resinst.h
--- src.orig/uqm/resinst.h	2017-11-21 19:39:40 -0600
+++ src/uqm/resinst.h	2017-11-21 19:39:57 -0600
@@ -22,3 +22,4 @@
 #include "istrtab.h"
 #include "isndres.h"
 #include "imusicre.h"
+#include "iscriptres.h"
diff -ruNp src.orig/uqm/restart.c src/uqm/restart.c
--- src.orig/uqm/restart.c	2017-11-21 19:39:40 -0600
+++ src/uqm/restart.c	2017-11-21 19:39:57 -0600
@@ -21,8 +21,7 @@
 #include "colors.h"
 #include "controls.h"
 #include "credits.h"
-// XXX: for star_array[]
-#include "encount.h"
+#include "starmap.h"
 #include "fmv.h"
 #include "menustat.h"
 #include "gamestr.h"
@@ -31,8 +30,8 @@
 #include "supermelee/melee.h"
 #include "resinst.h"
 #include "nameref.h"
+#include "save.h"
 #include "settings.h"
-#include "load.h"
 #include "setup.h"
 #include "sounds.h"
 #include "setupmenu.h"
@@ -43,10 +42,6 @@
 #include "libs/inplib.h"
 
 
-// TODO: This entire module fails to uphold the GraphicsLock semantics
-//   This either has to be fixed, or GraphicsLock completely ignored,
-//   or will become irrelevant if GraphicsLock completely removed.
-
 enum
 {
 	START_NEW_GAME = 0,
@@ -65,8 +60,7 @@ DrawRestartMenuGraphic (MENU_STATE *pMS)
 	TEXT t;
 	UNICODE buf[64];
 
-	s.frame = CaptureDrawable (LoadGraphic (RESTART_PMAP_ANIM));
-	pMS->CurFrame = s.frame;
+	s.frame = pMS->CurFrame;
 	GetFrameRect (s.frame, &r);
 	s.origin.x = (SCREEN_WIDTH - r.extent.width) >> 1;
 	s.origin.y = (SCREEN_HEIGHT - r.extent.height) >> 1;
@@ -75,7 +69,6 @@ DrawRestartMenuGraphic (MENU_STATE *pMS)
 	BatchGraphics ();
 	ClearDrawable ();
 	FlushColorXForms ();
-	LockMutex (GraphicsLock);
 	DrawStamp (&s);
 
 	// Put the version number in the bottom right corner.
@@ -90,7 +83,6 @@ DrawRestartMenuGraphic (MENU_STATE *pMS)
 	SetContextForeGroundColor (WHITE_COLOR);
 	font_DrawText (&t);
 
-	UnlockMutex (GraphicsLock);
 	UnbatchGraphics ();
 }
 
@@ -307,6 +299,9 @@ RestartMenu (MENU_STATE *pMS)
 	SleepThreadUntil (FadeScreen (FadeAllToBlack, TimeOut));
 	if (TimeOut == ONE_SECOND / 8)
 		SleepThread (ONE_SECOND * 3);
+
+	pMS->CurFrame = CaptureDrawable (LoadGraphic (RESTART_PMAP_ANIM));
+
 	DrawRestartMenuGraphic (pMS);
 	GLOBAL (CurrentActivity) &= ~CHECK_ABORT;
 	SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);
@@ -321,7 +316,9 @@ RestartMenu (MENU_STATE *pMS)
 	}
 
 	Flash_terminate (pMS->flashContext);
+	pMS->flashContext = 0;
 	DestroyDrawable (ReleaseDrawable (pMS->CurFrame));
+	pMS->CurFrame = 0;
 
 	if (GLOBAL (CurrentActivity) == (ACTIVITY)~0)
 		return (FALSE); // timed out
diff -ruNp src.orig/uqm/restart.h src/uqm/restart.h
--- src.orig/uqm/restart.h	2017-11-21 19:39:40 -0600
+++ src/uqm/restart.h	2017-11-21 19:39:57 -0600
@@ -19,8 +19,16 @@
 
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 
 extern BOOLEAN StartGame (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _RESTART_H */
 
diff -ruNp src.orig/uqm/save.c src/uqm/save.c
--- src.orig/uqm/save.c	2017-11-21 19:39:40 -0600
+++ src/uqm/save.c	2017-11-21 19:39:57 -0600
@@ -22,6 +22,7 @@
 
 #include "build.h"
 #include "controls.h"
+#include "starmap.h"
 #include "encount.h"
 #include "libs/file.h"
 #include "gamestr.h"
@@ -31,7 +32,7 @@
 #include "shipcont.h"
 #include "setup.h"
 #include "state.h"
-#include "grpinfo.h"
+#include "grpintrn.h"
 #include "util.h"
 #include "hyper.h"
 		// for SaveSisHyperState()
@@ -40,106 +41,729 @@
 #include "libs/inplib.h"
 #include "libs/log.h"
 #include "libs/memlib.h"
-#include "libs/declib.h"
 
+// Status boolean. If for some insane reason you need to
+// save games in different threads, you'll need to
+// protect your calls to SaveGame with a mutex.
+
+// It's arguably over-paranoid to check for error on
+// every single write, but this preserves the older
+// behavior.
+
+static BOOLEAN io_ok = TRUE;
+
+// This defines the order and the number of bits in which the game state
+// properties are saved.
+const GameStateBitMap gameStateBitMap[] = {
+		/* Shofixti states */
+	{ "SHOFIXTI_VISITS", 3 },
+	{ "SHOFIXTI_STACK1", 2 },
+	{ "SHOFIXTI_STACK2", 3 },
+	{ "SHOFIXTI_STACK3", 2 },
+	{ "SHOFIXTI_KIA", 1 },
+	{ "SHOFIXTI_BRO_KIA", 1 },
+	{ "SHOFIXTI_RECRUITED", 1 },
+
+	{ "SHOFIXTI_MAIDENS", 1 }, /* Did you find the babes yet? */
+	{ "MAIDENS_ON_SHIP", 1 },
+	{ "BATTLE_SEGUE", 1 },
+			/* Set to 0 in init_xxx_comm() if communications directly
+			 * follows an encounter.
+			 * Set to 1 in init_xxx_comm() if the player gets to decide
+			 * whether to attack or talk.
+			 * Set to 1 in communication when battle follows the
+			 * communication. It is still valid when uninit_xxx_comm() gets
+			 * called after combat or communication.
+			 */
+	{ "PLANETARY_LANDING", 1 },
+	{ "PLANETARY_CHANGE", 1 },
+			/* Flag set to 1 when the planet information for the current
+			 * world is changed since it was last saved to the starinfo.dat
+			 * file. Set when picking up bio, mineral, or energy nodes.
+			 * When there's no current world, it should be 0.
+			 */
+
+		/* Spathi states */
+	{ "SPATHI_VISITS", 3 },
+	{ "SPATHI_HOME_VISITS", 3 },
+	{ "FOUND_PLUTO_SPATHI", 2 },
+			/* 0 - Haven't met Fwiffo.
+			 * 1 - Met Fwiffo on Pluto, now talking to him.
+			 * 2 - Met Fwiffo on Pluto, after dialog.
+			 * 3 - Met Fwiffo, and have reported to the Safe Ones on
+			 *     the Spathi moon that he was either killed, or that
+			 *     you have him on board.
+			 */
+	{ "SPATHI_SHIELDED_SELVES", 1 },
+	{ "SPATHI_CREATURES_EXAMINED", 1 },
+	{ "SPATHI_CREATURES_ELIMINATED", 1 },
+	{ "UMGAH_BROADCASTERS", 1 },
+	{ "SPATHI_MANNER", 2 },
+	{ "SPATHI_QUEST", 1 },
+	{ "LIED_ABOUT_CREATURES", 2 },
+	{ "SPATHI_PARTY", 1 },
+	{ "KNOW_SPATHI_PASSWORD", 1 },
+
+	{ "ILWRATH_HOME_VISITS", 3 },
+	{ "ILWRATH_CHMMR_VISITS", 1 },
+
+	{ "ARILOU_SPACE", 1 },
+			/* 0 if the periodically opening QuasiSpace portal is
+			 * closed or closing.
+			 * 1 if the periodically opening QuasiSpace portal is
+			 * open or opening.
+			 */
+	{ "ARILOU_SPACE_SIDE", 2 },
+			/* 0 if in HyperSpace and not just emerged from the periodically
+			 * opening QuasiSpace portal.
+			 * 1 if in HyperSpace and just emerged from the periodically
+			 * QuasiSpace portal (still on the portal).
+			 * 2 if in QuasiSpace and just emerged from the periodically
+			 * opening portal (still on the portal).
+			 * 3 if in QuasiSpace and not just emerged from the
+			 * periodically opening portal.
+			 */
+	{ "ARILOU_SPACE_COUNTER", 4 },
+			/* Keeps track of how far the periodically opening QuasiSpace
+			 * portal is open. (This determines the image)
+			 * 0 <= ARILOU_SPACE_COUNTER <= 9
+			 * 0 means totally closed.
+			 * 9 means completely open.
+			 */
+
+	{ "LANDER_SHIELDS", 4 },
+
+	{ "MET_MELNORME", 1 },
+	{ "MELNORME_RESCUE_REFUSED", 1 },
+	{ "MELNORME_RESCUE_COUNT", 3 },
+	{ "TRADED_WITH_MELNORME", 1 },
+	{ "WHY_MELNORME_PURPLE", 1 },
+	{ "MELNORME_CREDIT0", 8 },
+	{ "MELNORME_CREDIT1", 8 },
+	{ "MELNORME_BUSINESS_COUNT", 2 },
+	{ "MELNORME_YACK_STACK0", 2 },
+	{ "MELNORME_YACK_STACK1", 2 },
+	{ "MELNORME_YACK_STACK2", 4 },
+	{ "MELNORME_YACK_STACK3", 3 },
+	{ "MELNORME_YACK_STACK4", 2 },
+	{ "WHY_MELNORME_BLUE", 1 },
+	{ "MELNORME_ANGER", 2 },
+	{ "MELNORME_MIFFED_COUNT", 2 },
+	{ "MELNORME_PISSED_COUNT", 2 },
+	{ "MELNORME_HATE_COUNT", 2 },
+
+	{ "PROBE_MESSAGE_DELIVERED", 1 },
+	{ "PROBE_ILWRATH_ENCOUNTER", 1 },
+
+	{ "STARBASE_AVAILABLE", 1 },
+	{ "STARBASE_VISITED", 1 },
+	{ "RADIOACTIVES_PROVIDED", 1 },
+	{ "LANDERS_LOST", 1 },
+	{ "GIVEN_FUEL_BEFORE", 1 },
+
+	{ "AWARE_OF_SAMATRA", 1 },
+	{ "YEHAT_CAVALRY_ARRIVED", 1 },
+	{ "URQUAN_MESSED_UP", 1 },
+
+	{ "MOONBASE_DESTROYED", 1 },
+	{ "WILL_DESTROY_BASE", 1 },
+
+	{ "ARTIFACT_2_ON_SHIP", 1 },
+	{ "ARTIFACT_3_ON_SHIP", 1 },
+
+	{ "KOHR_AH_KILLED_ALL", 1 },
+
+	{ "STARBASE_YACK_STACK1", 1 },
+
+	{ "DISCUSSED_PORTAL_SPAWNER", 1 },
+	{ "DISCUSSED_TALKING_PET", 1 },
+	{ "DISCUSSED_UTWIG_BOMB", 1 },
+	{ "DISCUSSED_SUN_EFFICIENCY", 1 },
+	{ "DISCUSSED_ROSY_SPHERE", 1 },
+	{ "DISCUSSED_AQUA_HELIX", 1 },
+	{ "DISCUSSED_CLEAR_SPINDLE", 1 },
+	{ "DISCUSSED_ULTRON", 1 },
+	{ "DISCUSSED_MAIDENS", 1 },
+	{ "DISCUSSED_UMGAH_HYPERWAVE", 1 },
+	{ "DISCUSSED_BURVIX_HYPERWAVE", 1 },
+	{ "SYREEN_WANT_PROOF", 1 },
+	{ "PLAYER_HAVING_SEX", 1 },
+	{ "MET_ARILOU", 1 },
+	{ "DISCUSSED_TAALO_PROTECTOR", 1 },
+	{ "DISCUSSED_EGG_CASING0", 1 },
+	{ "DISCUSSED_EGG_CASING1", 1 },
+	{ "DISCUSSED_EGG_CASING2", 1 },
+	{ "DISCUSSED_SYREEN_SHUTTLE", 1 },
+	{ "DISCUSSED_VUX_BEAST", 1 },
+	{ "DISCUSSED_DESTRUCT_CODE", 1 },
+	{ "DISCUSSED_URQUAN_WARP", 1 },
+	{ "DISCUSSED_ARTIFACT_2", 1 },
+	{ "DISCUSSED_ARTIFACT_3", 1 },
+
+	{ "ATTACKED_DRUUGE", 1 },
+
+	{ "NEW_ALLIANCE_NAME", 2 },
+
+	{ "PORTAL_COUNTER", 4 },
+			/* Set to 1 when the player opens a QuasiSpace portal.
+			 * It will then be increased to 10, at which time
+			 * the portal is completely open. (This determines the image).
+			 */
+
+	{ "BURVIXESE_BROADCASTERS", 1 },
+	{ "BURV_BROADCASTERS_ON_SHIP", 1 },
+
+	{ "UTWIG_BOMB", 1 },
+	{ "UTWIG_BOMB_ON_SHIP", 1 },
+
+	{ "AQUA_HELIX", 1 },
+	{ "AQUA_HELIX_ON_SHIP", 1 },
+
+	{ "SUN_DEVICE", 1 },
+	{ "SUN_DEVICE_ON_SHIP", 1 },
+
+	{ "TAALO_PROTECTOR", 1 },
+	{ "TAALO_PROTECTOR_ON_SHIP", 1 },
+
+	{ "SHIP_VAULT_UNLOCKED", 1 },
+	{ "SYREEN_SHUTTLE", 1 },
+
+	{ "PORTAL_KEY", 1 },
+	{ "PORTAL_KEY_ON_SHIP", 1 },
+
+	{ "VUX_BEAST", 1 },
+	{ "VUX_BEAST_ON_SHIP", 1 },
+
+	{ "TALKING_PET", 1 },
+	{ "TALKING_PET_ON_SHIP", 1 },
+
+	{ "MOONBASE_ON_SHIP", 1 },
+
+	{ "KOHR_AH_FRENZY", 1 },
+	{ "KOHR_AH_VISITS", 2 },
+	{ "KOHR_AH_BYES", 1 },
+
+	{ "SLYLANDRO_HOME_VISITS", 3 },
+	{ "DESTRUCT_CODE_ON_SHIP", 1 },
+
+	{ "ILWRATH_VISITS", 3 },
+	{ "ILWRATH_DECEIVED", 1 },
+	{ "FLAGSHIP_CLOAKED", 1 },
+
+	{ "MYCON_VISITS", 3 },
+	{ "MYCON_HOME_VISITS", 3 },
+	{ "MYCON_AMBUSH", 1 },
+	{ "MYCON_FELL_FOR_AMBUSH", 1 },
+			/* Set to 1 when the Mycon have been told about Organon
+			 * and are moving towards it.
+			 */
+
+	{ "GLOBAL_FLAGS_AND_DATA", 8 },
+			/* This state seems to be used to distinguish between different
+			 * places where one may have an conversation with an alien.
+			 * Like home world, other world, space.
+			 * Why this needs 8 bits I don't know. Only specific
+			 * combinations of bits seem to be used (0, 1, or all bits).
+			 * A closer investigation is desirable. - SvdB
+			 * Bit 4 is set when initiating communication with the Ilwrath
+			 * 		homeworld by means of a HyperWave Broadcaster.
+			 * Bit 5 is set when initiating communication with an Ilwrath
+			 * 		ship by means of a HyperWave Broadcaster.
+			 * All bits are cleared when communication is over.
+			 */
+
+	{ "ORZ_VISITS", 3 },
+	{ "TAALO_VISITS", 3 },
+	{ "ORZ_MANNER", 2 },
+
+	{ "PROBE_EXHIBITED_BUG", 1 },
+	{ "CLEAR_SPINDLE_ON_SHIP", 1 },
+
+	{ "URQUAN_VISITS", 3 },
+	{ "PLAYER_HYPNOTIZED", 1 },
+
+	{ "VUX_VISITS", 3 },
+	{ "VUX_HOME_VISITS", 3 },
+	{ "ZEX_VISITS", 3 },
+	{ "ZEX_IS_DEAD", 1 },
+	{ "KNOW_ZEX_WANTS_MONSTER", 1 },
+
+	{ "UTWIG_VISITS", 3 },
+	{ "UTWIG_HOME_VISITS", 3 },
+	{ "BOMB_VISITS", 3 },
+	{ "ULTRON_CONDITION", 3 },
+			/* 0 if the Supox still have the Ultron
+			 * 1 if the Captain has the Ultron, completely broken
+			 * 2 if the Captain has the Ultron, with 1 fix
+			 * 3 if the Captain has the Ultron, with 2 fixes
+			 * 4 if the Captain has the Ultron, completely restored
+			 * 5 if the Ultron has been returned to the Utwig
+			 */
+	{ "UTWIG_HAVE_ULTRON", 1 },
+	{ "BOMB_UNPROTECTED", 1 },
+
+	{ "TAALO_UNPROTECTED", 1 },
+
+	{ "TALKING_PET_VISITS", 3 },
+	{ "TALKING_PET_HOME_VISITS", 3 },
+	{ "UMGAH_ZOMBIE_BLOBBIES", 1 },
+			/* The Umgah have come under the influence of the Talking Pet */
+	{ "KNOW_UMGAH_ZOMBIES", 1 },
+			/* The Captain is aware that something is up with the Umgah */
+
+	{ "ARILOU_VISITS", 3 },
+	{ "ARILOU_HOME_VISITS", 3 },
+	{ "KNOW_ARILOU_WANT_WRECK", 1 },
+	{ "ARILOU_CHECKED_UMGAH", 2 },
+	{ "PORTAL_SPAWNER", 1 },
+	{ "PORTAL_SPAWNER_ON_SHIP", 1 },
+
+	{ "UMGAH_VISITS", 3 },
+	{ "UMGAH_HOME_VISITS", 3 },
+	{ "MET_NORMAL_UMGAH", 1 },
+
+	{ "SYREEN_HOME_VISITS", 3 },
+	{ "SYREEN_SHUTTLE_ON_SHIP", 1 },
+	{ "KNOW_SYREEN_VAULT", 1 },
+
+	{ "EGG_CASE0_ON_SHIP", 1 },
+	{ "SUN_DEVICE_UNGUARDED", 1 },
+
+	{ "ROSY_SPHERE_ON_SHIP", 1 },
+			/* The Rosy Sphere is aboard the flagship, i.e. It has been
+			 * acquired from the Druuge, but not yet inserted in the broken
+			 * Ultron. cf. ROSY_SPHERE */
+
+	{ "CHMMR_HOME_VISITS", 3 },
+	{ "CHMMR_EMERGING", 1 },
+	{ "CHMMR_UNLEASHED", 1 },
+	{ "CHMMR_BOMB_STATE", 2 },
+			/* 0 - Nothing is known about the Precursor Bomb.
+			 * 1 - The captain knows from the Chmmr that some extremely
+			 *     powerful weapon is needed to destroy the Sa-Matra.
+			 * 2 - Installation of the precursor bomb has started.
+			 * 3 - Left the starbase after installation of the Precursor bomb.
+			 */
+
+	{ "DRUUGE_DISCLAIMER", 1 },
+
+	{ "YEHAT_VISITS", 3 },
+	{ "YEHAT_REBEL_VISITS", 3 },
+	{ "YEHAT_HOME_VISITS", 3 },
+	{ "YEHAT_CIVIL_WAR", 1 },
+	{ "YEHAT_ABSORBED_PKUNK", 1 },
+	{ "YEHAT_SHIP_MONTH", 4 },
+	{ "YEHAT_SHIP_DAY", 5 },
+	{ "YEHAT_SHIP_YEAR", 5 },
+
+	{ "CLEAR_SPINDLE", 1 },
+	{ "PKUNK_VISITS", 3 },
+	{ "PKUNK_HOME_VISITS", 3 },
+	{ "PKUNK_SHIP_MONTH", 4 },
+			/* The month in PKUNK_SHIP_YEAR that new ships are available
+			 * from the Pkunk. */
+	{ "PKUNK_SHIP_DAY", 5 },
+			/* The day of the month in PKUNK_SHIP_MONTH in PKUNK_SHIP_YEAR
+			 * that new ships are available. */
+	{ "PKUNK_SHIP_YEAR", 5 },
+			/* The year that new ships are available from the Pkunk
+			 * (stored as an offset from the year the game starts). */
+	{ "PKUNK_MISSION", 3 },
+
+	{ "SUPOX_VISITS", 3 },
+	{ "SUPOX_HOME_VISITS", 3 },
+
+	{ "THRADD_VISITS", 3 },
+	{ "THRADD_HOME_VISITS", 3 },
+	{ "HELIX_VISITS", 3 },
+	{ "HELIX_UNPROTECTED", 1 },
+	{ "THRADD_CULTURE", 2 },
+	{ "THRADD_MISSION", 3 },
+			/* 0 if the Thraddash fleet hasn't left the Thraddash home world.
+			 * 1 if the Thraddash are heading towards Kohr-Ah territory.
+			 * 2 if the Thraddash are fighting the Kohr-Ah.
+			 * 3 if the Thraddash are returning from Kohr-Ah territory.
+			 * 4 if the Thraddash fleet is back at the Thraddash home world.
+			 */
+
+	{ "DRUUGE_VISITS", 3 },
+	{ "DRUUGE_HOME_VISITS", 3 },
+	{ "ROSY_SPHERE", 1 },
+			/* The play has or has had the Rosy Sphere.
+			 * cf. ROSY_SHERE_ON_SHIP */
+	{ "SCANNED_MAIDENS", 1 },
+	{ "SCANNED_FRAGMENTS", 1 },
+	{ "SCANNED_CASTER", 1 },
+	{ "SCANNED_SPAWNER", 1 },
+	{ "SCANNED_ULTRON", 1 },
+
+	{ "ZOQFOT_INFO", 2 },
+	{ "ZOQFOT_HOSTILE", 1 },
+	{ "ZOQFOT_HOME_VISITS", 3 },
+	{ "MET_ZOQFOT", 1 },
+	{ "ZOQFOT_DISTRESS", 2 },
+			/* 0 if the Zoq-Fot-Pik aren't in distress
+			 * 1 if the Zoq-Fot-Pik are under attack by the Kohr-Ah
+			 * 2 if the Zoq-Fot-Pik have been destroyed because of this
+			 *   attack (not by the Kohr-Ah final victory cleansing)
+			 */
+
+	{ "EGG_CASE1_ON_SHIP", 1 },
+	{ "EGG_CASE2_ON_SHIP", 1 },
+	{ "MYCON_SUN_VISITS", 3 },
+	{ "ORZ_HOME_VISITS", 3 },
+
+	{ "MELNORME_FUEL_PROCEDURE", 1 },
+	{ "MELNORME_TECH_PROCEDURE", 1 },
+	{ "MELNORME_INFO_PROCEDURE", 1 },
+
+	{ "MELNORME_TECH_STACK", 4 },
+			/* MELNORME_TECH_STACK is now unused */
+	{ "MELNORME_EVENTS_INFO_STACK", 5 },
+	{ "MELNORME_ALIEN_INFO_STACK", 5 },
+	{ "MELNORME_HISTORY_INFO_STACK", 5 },
+
+	{ "RAINBOW_WORLD0", 8 },
+			/* Low byte of a bit array, one bit per rainbow world.
+			 * Each bit is set if the rainbow world has been visited.
+			 * The lowest bit is for the first star in the star_array
+			 * with RAINBOW_DEFINED, and so on.
+			 */
+	{ "RAINBOW_WORLD1", 2 },
+			/* High 2 bits of the bit array of which RAINBOW_WORLD0
+			 * is the low byte.
+			 */
+	{ "MELNORME_RAINBOW_COUNT", 4 },
+			/* The number of rainbow world locations sold to the Melnorme. */
+
+	{ "USED_BROADCASTER", 1 },
+	{ "BROADCASTER_RESPONSE", 1 },
+
+	{ "IMPROVED_LANDER_SPEED", 1 },
+	{ "IMPROVED_LANDER_CARGO", 1 },
+	{ "IMPROVED_LANDER_SHOT", 1 },
+
+	{ "MET_ORZ_BEFORE", 1 },
+	{ "YEHAT_REBEL_TOLD_PKUNK", 1 },
+	{ "PLAYER_HAD_SEX", 1 },
+	{ "UMGAH_BROADCASTERS_ON_SHIP", 1 },
+
+	{ "LIGHT_MINERAL_LOAD", 3 },
+	{ "MEDIUM_MINERAL_LOAD", 3 },
+	{ "HEAVY_MINERAL_LOAD", 3 },
+
+	{ "STARBASE_BULLETS", 32 },
+
+	{ "STARBASE_MONTH", 4 },
+	{ "STARBASE_DAY", 5 },
+
+	{ "CREW_SOLD_TO_DRUUGE0", 8 },
+	{ "CREW_PURCHASED0", 8 },
+	{ "CREW_PURCHASED1", 8 },
+
+	{ "URQUAN_PROTECTING_SAMATRA", 1 },
+
+	{ "THRADDASH_BODY_COUNT", 5 },
+
+	{ "UTWIG_SUPOX_MISSION", 3 },
+			/* 0 if the Utwig and Supox fleet haven't left their home world.
+			 * 1 if the U&S are on their way towards the Kohr-Ah
+			 * 2 if the U&S are fighting the Kohr-Ah (first 80 days)
+			 * 3 does not occur
+             * 4 if the U&S are fighting the Kohr-Ah (second 80 days)
+			 * 5 if the U&S are returning home.
+			 * 6 if the U&S are back at their home world.
+			 */
+	{ "SPATHI_INFO", 3 },
+
+	{ "ILWRATH_INFO", 2 },
+	{ "ILWRATH_GODS_SPOKEN", 4 },
+	{ "ILWRATH_WORSHIP", 2 },
+	{ "ILWRATH_FIGHT_THRADDASH", 1 },
+
+	{ "READY_TO_CONFUSE_URQUAN", 1 },
+	{ "URQUAN_HYPNO_VISITS", 1 },
+	{ "MENTIONED_PET_COMPULSION", 1 },
+	{ "URQUAN_INFO", 2 },
+	{ "KNOW_URQUAN_STORY", 2 },
+
+	{ "MYCON_INFO", 4 },
+	{ "MYCON_RAMBLE", 5 },
+	{ "KNOW_ABOUT_SHATTERED", 2 },
+			/* 0 if the player doesn't known about shattered worlds
+			 * 1 if the player has encountered a shattered world
+			 * 2 if the player knows that shatterred worlds are caused
+			 *   by Mycon deep children.
+			 * 3 if the player has told the Syreen that Mycon Deep Children
+			 *   cause shattered worlds. Proof doesn't have to be presented
+			 *   yet at this time.
+			 */
+	{ "MYCON_INSULTS", 3 },
+	{ "MYCON_KNOW_AMBUSH", 1 },
+			/* Set to 1 when the Mycon have been butchered at Organon,
+			 * just before the remaining Mycon head back home.
+			 */
+
+	{ "SYREEN_INFO", 2 },
+	{ "KNOW_SYREEN_WORLD_SHATTERED", 1 },
+	{ "SYREEN_KNOW_ABOUT_MYCON", 1 },
+
+	{ "TALKING_PET_INFO", 3 },
+	{ "TALKING_PET_SUGGESTIONS", 3 },
+	{ "LEARNED_TALKING_PET", 1 },
+	{ "DNYARRI_LIED", 1 },
+			/* Set when the Talking Pet tells you his version of their
+			 * race's history with the Ur-Quan.
+			 * Cleared once you confront him about this lie.
+			 */
+	{ "SHIP_TO_COMPEL", 1 },
+
+	{ "ORZ_GENERAL_INFO", 2 },
+	{ "ORZ_PERSONAL_INFO", 3 },
+	{ "ORZ_ANDRO_STATE", 2 },
+	{ "REFUSED_ORZ_ALLIANCE", 1 },
+
+	{ "PKUNK_MANNER", 2 },
+			/* 0 not met the Pkunk
+			 * 1 fought the Pkunk, but relations are still salvagable.
+			 * 2 hostile relations with the Pkunk, no way back.
+			 * 3 friendly relations with the Pkunk
+			 */
+	{ "PKUNK_ON_THE_MOVE", 1 },
+	{ "PKUNK_FLEET", 2 },
+	{ "PKUNK_MIGRATE", 2 },
+	{ "PKUNK_RETURN", 1 },
+	{ "PKUNK_WORRY", 2 },
+	{ "PKUNK_INFO", 3 },
+	{ "PKUNK_WAR", 2 },
+	{ "PKUNK_FORTUNE", 3 },
+	{ "PKUNK_MIGRATE_VISITS", 3 },
+	{ "PKUNK_REASONS", 4 },
+	{ "PKUNK_SWITCH", 1 },
+	{ "PKUNK_SENSE_VICTOR", 1 },
+
+	{ "KOHR_AH_REASONS", 2 },
+	{ "KOHR_AH_PLEAD", 2 },
+	{ "KOHR_AH_INFO", 2 },
+	{ "KNOW_KOHR_AH_STORY", 2 },
+	{ "KOHR_AH_SENSES_EVIL", 1 },
+	{ "URQUAN_SENSES_EVIL", 1 },
+
+	{ "SLYLANDRO_PROBE_VISITS", 3 },
+	{ "SLYLANDRO_PROBE_THREAT", 2 },
+	{ "SLYLANDRO_PROBE_WRONG", 2 },
+	{ "SLYLANDRO_PROBE_ID", 2 },
+	{ "SLYLANDRO_PROBE_INFO", 2 },
+	{ "SLYLANDRO_PROBE_EXIT", 2 },
+
+	{ "UMGAH_HOSTILE", 1 },
+	{ "UMGAH_EVIL_BLOBBIES", 1 },
+	{ "UMGAH_MENTIONED_TRICKS", 2 },
+
+	{ "BOMB_CARRIER", 1 },
+			/* 0 when the flagship is not in battle, or it doesn't have the
+			 *   enhanced precursor bomb installed.
+			 * 1 when the flagship is in battle and the bomb is installed.
+			 * This determines whether you can flee (if the warp escape unit
+			 * is installed at all), and whether taking the ship into the
+			 * Sa-Matra defense structure will trigger the end of the game.
+			 */
+	
+	{ "THRADD_MANNER", 1 },
+	{ "THRADD_INTRO", 2 },
+	{ "THRADD_DEMEANOR", 3 },
+	{ "THRADD_INFO", 2 },
+	{ "THRADD_BODY_LEVEL", 2 },
+	{ "THRADD_MISSION_VISITS", 1 },
+	{ "THRADD_STACK_1", 3 },
+	{ "THRADD_HOSTILE_STACK_2", 1 },
+	{ "THRADD_HOSTILE_STACK_3", 1 },
+	{ "THRADD_HOSTILE_STACK_4", 1 },
+	{ "THRADD_HOSTILE_STACK_5", 1 },
+
+	{ "CHMMR_STACK", 2 },
+
+	{ "ARILOU_MANNER", 2 },
+	{ "NO_PORTAL_VISITS", 1 },
+	{ "ARILOU_STACK_1", 2 },
+	{ "ARILOU_STACK_2", 1 },
+	{ "ARILOU_STACK_3", 2 },
+	{ "ARILOU_STACK_4", 1 },
+	{ "ARILOU_STACK_5", 2 },
+	{ "ARILOU_INFO", 2 },
+	{ "ARILOU_HINTS", 2 },
+
+	{ "DRUUGE_MANNER", 1 },
+	{ "DRUUGE_SPACE_INFO", 2 },
+	{ "DRUUGE_HOME_INFO", 2 },
+	{ "DRUUGE_SALVAGE", 1 },
+	{ "KNOW_DRUUGE_SLAVERS", 2 },
+	{ "FRAGMENTS_BOUGHT", 2 },
+
+	{ "ZEX_STACK_1", 2 },
+	{ "ZEX_STACK_2", 2 },
+	{ "ZEX_STACK_3", 2 },
+
+	{ "VUX_INFO", 2 },
+	{ "VUX_STACK_1", 4 },
+	{ "VUX_STACK_2", 2 },
+	{ "VUX_STACK_3", 2 },
+	{ "VUX_STACK_4", 2 },
+
+	{ "SHOFIXTI_STACK4", 2 },
+
+	{ "YEHAT_REBEL_INFO", 3 },
+	{ "YEHAT_ROYALIST_INFO", 1 },
+	{ "YEHAT_ROYALIST_TOLD_PKUNK", 1 },
+	{ "NO_YEHAT_ALLY_HOME", 1 },
+	{ "NO_YEHAT_HELP_HOME", 1 },
+	{ "NO_YEHAT_INFO", 1 },
+	{ "NO_YEHAT_ALLY_SPACE", 2 },
+	{ "NO_YEHAT_HELP_SPACE", 2 },
+
+	{ "ZOQFOT_KNOW_MASK", 4 },
+
+	{ "SUPOX_HOSTILE", 1 },
+	{ "SUPOX_INFO", 1 },
+	{ "SUPOX_WAR_NEWS", 2 },
+	{ "SUPOX_ULTRON_HELP", 1 },
+	{ "SUPOX_STACK1", 3 },
+	{ "SUPOX_STACK2", 2 },
+
+	{ "UTWIG_HOSTILE", 1 },
+	{ "UTWIG_INFO", 1 },
+	{ "UTWIG_WAR_NEWS", 2 },
+	{ "UTWIG_STACK1", 3 },
+	{ "UTWIG_STACK2", 2 },
+	{ "BOMB_INFO", 1 },
+	{ "BOMB_STACK1", 2 },
+	{ "BOMB_STACK2", 2 },
+
+	{ "SLYLANDRO_KNOW_BROKEN", 1 },
+	{ "PLAYER_KNOWS_PROBE", 1 },
+	{ "PLAYER_KNOWS_PROGRAM", 1 },
+	{ "PLAYER_KNOWS_EFFECTS", 1 },
+	{ "PLAYER_KNOWS_PRIORITY", 1 },
+	{ "SLYLANDRO_STACK1", 3 },
+	{ "SLYLANDRO_STACK2", 1 },
+	{ "SLYLANDRO_STACK3", 2 },
+	{ "SLYLANDRO_STACK4", 2 },
+	{ "SLYLANDRO_STACK5", 1 },
+	{ "SLYLANDRO_STACK6", 1 },
+	{ "SLYLANDRO_STACK7", 2 },
+	{ "SLYLANDRO_STACK8", 2 },
+	{ "SLYLANDRO_STACK9", 2 },
+	{ "SLYLANDRO_KNOW_EARTH", 1 },
+	{ "SLYLANDRO_KNOW_EXPLORE", 1 },
+	{ "SLYLANDRO_KNOW_GATHER", 1 },
+	{ "SLYLANDRO_KNOW_URQUAN", 2 },
+	{ "RECALL_VISITS", 2 },
+
+	{ "SLYLANDRO_MULTIPLIER", 3 },
+	{ "KNOW_SPATHI_QUEST", 1 },
+	{ "KNOW_SPATHI_EVIL", 1 },
+
+	{ "BATTLE_PLANET", 8 },
+	{ "ESCAPE_COUNTER", 8 },
+
+	{ "CREW_SOLD_TO_DRUUGE1", 8 },
+	{ "PKUNK_DONE_WAR", 1 },
+
+	{ "SYREEN_STACK0", 2 },
+	{ "SYREEN_STACK1", 2 },
+	{ "SYREEN_STACK2", 2 },
+
+	{ "REFUSED_ULTRON_AT_BOMB", 1 },
+	{ "NO_TRICK_AT_SUN", 1 },
+
+	{ "SPATHI_STACK0", 2 },
+	{ "SPATHI_STACK1", 1 },
+	{ "SPATHI_STACK2", 1 },
+
+	{ "ORZ_STACK0", 1 },
+	{ "ORZ_STACK1", 1 },
+
+	{ "SHOFIXTI_GRPOFFS", 32 },
+	{ "ZOQFOT_GRPOFFS", 32 },
+	{ "MELNORME0_GRPOFFS", 32 },
+	{ "MELNORME1_GRPOFFS", 32 },
+	{ "MELNORME2_GRPOFFS", 32 },
+	{ "MELNORME3_GRPOFFS", 32 },
+	{ "MELNORME4_GRPOFFS", 32 },
+	{ "MELNORME5_GRPOFFS", 32 },
+	{ "MELNORME6_GRPOFFS", 32 },
+	{ "MELNORME7_GRPOFFS", 32 },
+	{ "MELNORME8_GRPOFFS", 32 },
+	{ "URQUAN_PROBE_GRPOFFS", 32 },
+	{ "COLONY_GRPOFFS", 32 },
+	{ "SAMATRA_GRPOFFS", 32 },
+	
+	{ NULL, 0 },
+};
 
-// XXX: these should handle endian conversions later
-static inline COUNT
-cwrite_8 (DECODE_REF fh, BYTE v)
-{
-	return cwrite (&v, 1, 1, fh);
-}
-
-static inline COUNT
-cwrite_16 (DECODE_REF fh, UWORD v)
-{
-	return cwrite (&v, 2, 1, fh);
-}
-
-static inline COUNT
-cwrite_32 (DECODE_REF fh, DWORD v)
-{
-	return cwrite (&v, 4, 1, fh);
-}
-
-static inline COUNT
-cwrite_ptr (DECODE_REF fh)
-{
-	return cwrite_32 (fh, 0); /* ptrs are useless in saves */
-}
-
-static inline COUNT
-cwrite_a8 (DECODE_REF fh, const BYTE *ar, COUNT count)
-{
-	return cwrite (ar, 1, count, fh) == count;
-}
 
-static inline size_t
+// XXX: these should handle endian conversions later
+static inline void
 write_8 (void *fp, BYTE v)
 {
-	return WriteResFile (&v, 1, 1, fp);
+	if (io_ok)
+		if (WriteResFile (&v, 1, 1, fp) != 1)
+			io_ok = FALSE;
 }
 
-static inline size_t
+static inline void
 write_16 (void *fp, UWORD v)
 {
-	return WriteResFile (&v, 2, 1, fp);
+	write_8 (fp, (BYTE)( v        & 0xff));
+	write_8 (fp, (BYTE)((v >>  8) & 0xff));
 }
 
-static inline size_t
+static inline void
 write_32 (void *fp, DWORD v)
 {
-	return WriteResFile (&v, 4, 1, fp);
+	write_8 (fp, (BYTE)( v        & 0xff));
+	write_8 (fp, (BYTE)((v >>  8) & 0xff));
+	write_8 (fp, (BYTE)((v >> 16) & 0xff));
+	write_8 (fp, (BYTE)((v >> 24) & 0xff));
 }
 
-static inline size_t
-write_ptr (void *fp)
-{
-	return write_32 (fp, 0); /* ptrs are useless in saves */
-}
-
-static inline size_t
+static inline void
 write_a8 (void *fp, const BYTE *ar, COUNT count)
 {
-	return WriteResFile (ar, 1, count, fp) == count;
+	if (io_ok)
+		if (WriteResFile (ar, 1, count, fp) != count)
+			io_ok = FALSE;
 }
 
-static inline size_t
+static inline void
 write_str (void *fp, const char *str, COUNT count)
 {
 	// no type conversion needed for strings
-	return write_a8 (fp, (const BYTE *)str, count);
+	write_a8 (fp, (const BYTE *)str, count);
 }
 
-static inline size_t
+static inline void
 write_a16 (void *fp, const UWORD *ar, COUNT count)
 {
 	for ( ; count > 0; --count, ++ar)
 	{
-		if (write_16 (fp, *ar) != 1)
-			return 0;
+		if (!io_ok)
+			break;
+		write_16 (fp, *ar);
 	}
-	return 1;
 }
 
 static void
-SaveEmptyQueue (DECODE_REF fh)
-{
-	COUNT num_links = 0;
-
-	// Write the number of entries in the queue.
-	cwrite_16 (fh, num_links);
-}
-
-static void
-SaveShipQueue (DECODE_REF fh, QUEUE *pQueue)
+SaveShipQueue (uio_Stream *fh, QUEUE *pQueue, DWORD tag)
 {
 	COUNT num_links;
 	HSHIPFRAG hStarShip;
 
-	// Write the number of entries in the queue.
 	num_links = CountLinks (pQueue);
-	cwrite_16 (fh, num_links);
+	if (num_links == 0)
+		return;
+	write_32 (fh, tag);
+	write_32 (fh, num_links * 11); // Size of chunk: each entry is 11 bytes long.
 
 	hStarShip = GetHeadLink (pQueue);
 	while (num_links--)
@@ -154,22 +778,16 @@ SaveShipQueue (DECODE_REF fh, QUEUE *pQu
 		Index = FragPtr->race_id;
 		// Write the number identifying this ship type.
 		// See races.h; look for the enum containing NUM_AVAILABLE_RACES.
-		cwrite_16 (fh, Index);
+		write_16 (fh, Index);
 
 		// Write SHIP_FRAGMENT elements
-		cwrite_16 (fh, 0); /* unused; was which_side */
-		cwrite_8  (fh, FragPtr->captains_name_index);
-		cwrite_8  (fh, 0); /* padding */
-		cwrite_16 (fh, 0); /* unused: was ship_flags */
-		cwrite_8  (fh, FragPtr->race_id);
-		cwrite_8  (fh, FragPtr->index);
-		// XXX: writing crew as BYTE to maintain savegame compatibility
-		cwrite_8  (fh, FragPtr->crew_level);
-		cwrite_8  (fh, FragPtr->max_crew);
-		cwrite_8  (fh, FragPtr->energy_level);
-		cwrite_8  (fh, FragPtr->max_energy);
-		cwrite_16 (fh, 0); /* unused; was loc.x */
-		cwrite_16 (fh, 0); /* unused; was loc.y */
+		write_8  (fh, FragPtr->captains_name_index);
+		write_8  (fh, FragPtr->race_id);
+		write_8  (fh, FragPtr->index);
+		write_16 (fh, FragPtr->crew_level);
+		write_16 (fh, FragPtr->max_crew);
+		write_8  (fh, FragPtr->energy_level);
+		write_8  (fh, FragPtr->max_energy);
 
 		UnlockShipFrag (pQueue, hStarShip);
 		hStarShip = hNextShip;
@@ -177,14 +795,17 @@ SaveShipQueue (DECODE_REF fh, QUEUE *pQu
 }
 
 static void
-SaveRaceQueue (DECODE_REF fh, QUEUE *pQueue)
+SaveRaceQueue (uio_Stream *fh, QUEUE *pQueue)
 {
 	COUNT num_links;
 	HFLEETINFO hFleet;
 
-	// Write the number of entries in the queue.
 	num_links = CountLinks (pQueue);
-	cwrite_16 (fh, num_links);
+	if (num_links == 0)
+		return;
+	write_32 (fh, RACE_Q_TAG);
+	// Write chunk size: 30 bytes per entry
+	write_32 (fh, num_links * 30);
 
 	hFleet = GetHeadLink (pQueue);
 	while (num_links--)
@@ -198,28 +819,27 @@ SaveRaceQueue (DECODE_REF fh, QUEUE *pQu
 
 		Index = GetIndexFromStarShip (pQueue, hFleet);
 		// The index is the position in the queue.
-		cwrite_16 (fh, Index);
+		write_16 (fh, Index);
 
 		// Write FLEET_INFO elements
-		cwrite_16 (fh, FleetPtr->allied_state);
-		cwrite_8  (fh, FleetPtr->days_left);
-		cwrite_8  (fh, FleetPtr->growth_fract);
-		cwrite_8  (fh, FleetPtr->crew_level);
-		cwrite_8  (fh, FleetPtr->max_crew);
-		cwrite_8  (fh, FleetPtr->growth);
-		cwrite_8  (fh, FleetPtr->max_energy);
-		cwrite_16 (fh, FleetPtr->loc.x);
-		cwrite_16 (fh, FleetPtr->loc.y);
-
-		cwrite_16 (fh, FleetPtr->actual_strength);
-		cwrite_16 (fh, FleetPtr->known_strength);
-		cwrite_16 (fh, FleetPtr->known_loc.x);
-		cwrite_16 (fh, FleetPtr->known_loc.y);
-		cwrite_8  (fh, FleetPtr->growth_err_term);
-		cwrite_8  (fh, FleetPtr->func_index);
-		cwrite_16 (fh, FleetPtr->dest_loc.x);
-		cwrite_16 (fh, FleetPtr->dest_loc.y);
-		cwrite_16 (fh, 0); /* alignment padding */
+		write_16 (fh, FleetPtr->allied_state);
+		write_8  (fh, FleetPtr->days_left);
+		write_8  (fh, FleetPtr->growth_fract);
+		write_16 (fh, FleetPtr->crew_level);
+		write_16 (fh, FleetPtr->max_crew);
+		write_8  (fh, FleetPtr->growth);
+		write_8  (fh, FleetPtr->max_energy);
+		write_16 (fh, FleetPtr->loc.x);
+		write_16 (fh, FleetPtr->loc.y);
+
+		write_16 (fh, FleetPtr->actual_strength);
+		write_16 (fh, FleetPtr->known_strength);
+		write_16 (fh, FleetPtr->known_loc.x);
+		write_16 (fh, FleetPtr->known_loc.y);
+		write_8  (fh, FleetPtr->growth_err_term);
+		write_8  (fh, FleetPtr->func_index);
+		write_16 (fh, FleetPtr->dest_loc.x);
+		write_16 (fh, FleetPtr->dest_loc.y);
 
 		UnlockFleetInfo (pQueue, hFleet);
 		hFleet = hNextFleet;
@@ -227,12 +847,16 @@ SaveRaceQueue (DECODE_REF fh, QUEUE *pQu
 }
 
 static void
-SaveGroupQueue (DECODE_REF fh, QUEUE *pQueue)
+SaveGroupQueue (uio_Stream *fh, QUEUE *pQueue)
 {
 	HIPGROUP hGroup, hNextGroup;
+	COUNT num_links;
 
-	// Write the number of entries in the queue.
-	cwrite_16 (fh, CountLinks (pQueue));
+	num_links = CountLinks (pQueue);
+	if (num_links == 0)
+		return;
+	write_32 (fh, IP_GRP_Q_TAG);
+	write_32 (fh, num_links * 13); // 13 bytes per element right now
 
 	for (hGroup = GetHeadLink (pQueue); hGroup; hGroup = hNextGroup)
 	{
@@ -241,241 +865,235 @@ SaveGroupQueue (DECODE_REF fh, QUEUE *pQ
 		GroupPtr = LockIpGroup (pQueue, hGroup);
 		hNextGroup = _GetSuccLink (GroupPtr);
 
-		cwrite_16 (fh, GroupPtr->race_id); /* unused; for old versions */
-
-		cwrite_16 (fh, 0); /* unused; was which_side */
-		cwrite_8  (fh, 0); /* unused; was captains_name_index */
-		cwrite_8  (fh, 0); /* padding; for savegame compat */
-		cwrite_16 (fh, GroupPtr->group_counter);
-		cwrite_8  (fh, GroupPtr->race_id);
-		assert (GroupPtr->sys_loc < 0x10 && GroupPtr->task < 0x10);
-		cwrite_8  (fh, MAKE_BYTE (GroupPtr->sys_loc, GroupPtr->task));
-				/* was var2 */
-		cwrite_8  (fh, GroupPtr->in_system); /* was crew_level */
-		cwrite_8  (fh, 0); /* unused; was max_crew */
-		assert (GroupPtr->dest_loc < 0x10 && GroupPtr->orbit_pos < 0x10);
-		cwrite_8  (fh, MAKE_BYTE (GroupPtr->dest_loc, GroupPtr->orbit_pos));
-				/* was energy_level */
-		cwrite_8  (fh, GroupPtr->group_id); /* was max_energy */
-		cwrite_16 (fh, GroupPtr->loc.x);
-		cwrite_16 (fh, GroupPtr->loc.y);
+		write_16 (fh, GroupPtr->group_counter);
+		write_8  (fh, GroupPtr->race_id);
+		write_8  (fh, GroupPtr->sys_loc);
+		write_8  (fh, GroupPtr->task);
+		write_8  (fh, GroupPtr->in_system); /* was crew_level */
+		write_8  (fh, GroupPtr->dest_loc);
+		write_8  (fh, GroupPtr->orbit_pos);
+		write_8  (fh, GroupPtr->group_id); /* was max_energy */
+		write_16 (fh, GroupPtr->loc.x);
+		write_16 (fh, GroupPtr->loc.y);
 
 		UnlockIpGroup (pQueue, hGroup);
 	}
 }
 
 static void
-SaveEncounter (const ENCOUNTER *EncounterPtr, DECODE_REF fh)
+SaveEncounters (uio_Stream *fh)
 {
-	COUNT i;
+	COUNT num_links;
+	HENCOUNTER hEncounter;
+	num_links = CountLinks (&GLOBAL (encounter_q));
+	if (num_links == 0)
+		return;
+	write_32 (fh, ENCOUNTERS_TAG);
+	write_32 (fh, 65 * num_links);
+
+	hEncounter = GetHeadLink (&GLOBAL (encounter_q));
+	while (num_links--)
+	{
+		HENCOUNTER hNextEncounter;
+		ENCOUNTER *EncounterPtr;
+		COUNT i;
+
+		LockEncounter (hEncounter, &EncounterPtr);
+		hNextEncounter = GetSuccEncounter (EncounterPtr);
+
+		write_16  (fh, EncounterPtr->transition_state);
+		write_16  (fh, EncounterPtr->origin.x);
+		write_16  (fh, EncounterPtr->origin.y);
+		write_16  (fh, EncounterPtr->radius);
+		// former STAR_DESC fields
+		write_16  (fh, EncounterPtr->loc_pt.x);
+		write_16  (fh, EncounterPtr->loc_pt.y);
+		write_8   (fh, EncounterPtr->race_id);
+		write_8   (fh, EncounterPtr->num_ships);
+		write_8   (fh, EncounterPtr->flags);
 
-	cwrite_ptr (fh); /* useless ptr; HENCOUNTER pred */
-	cwrite_ptr (fh); /* useless ptr; HENCOUNTER succ */
-	cwrite_ptr (fh); /* useless ptr; HELEMENT hElement */
-	cwrite_16  (fh, EncounterPtr->transition_state);
-	cwrite_16  (fh, EncounterPtr->origin.x);
-	cwrite_16  (fh, EncounterPtr->origin.y);
-	cwrite_16  (fh, EncounterPtr->radius);
-	// STAR_DESC fields
-	cwrite_16  (fh, EncounterPtr->SD.star_pt.x);
-	cwrite_16  (fh, EncounterPtr->SD.star_pt.y);
-	cwrite_8   (fh, EncounterPtr->SD.Type);
-	cwrite_8   (fh, EncounterPtr->SD.Index);
-	cwrite_16  (fh, 0); /* alignment padding */
-
-	// Save each entry in the BRIEF_SHIP_INFO array
-	for (i = 0; i < MAX_HYPER_SHIPS; i++)
-	{
-		const BRIEF_SHIP_INFO *ShipInfo = &EncounterPtr->ShipList[i];
-
-		cwrite_16  (fh, 0); /* useless; was SHIP_INFO.ship_flags */
-		cwrite_8   (fh, ShipInfo->race_id);
-		cwrite_8   (fh, 0); /* useless; was SHIP_INFO.var2 */
-		// XXX: writing crew as BYTE to maintain savegame compatibility
-		cwrite_8   (fh, ShipInfo->crew_level);
-		cwrite_8   (fh, ShipInfo->max_crew);
-		cwrite_8   (fh, 0); /* useless; was SHIP_INFO.energy_level */
-		cwrite_8   (fh, ShipInfo->max_energy);
-		cwrite_16  (fh, 0); /* useless; was SHIP_INFO.loc.x */
-		cwrite_16  (fh, 0); /* useless; was SHIP_INFO.loc.y */
-		cwrite_32  (fh, 0); /* useless val; STRING race_strings */
-		cwrite_ptr (fh); /* useless ptr; FRAME icons */
-		cwrite_ptr (fh); /* useless ptr; FRAME melee_icon */
+		// Save each entry in the BRIEF_SHIP_INFO array
+		for (i = 0; i < MAX_HYPER_SHIPS; i++)
+		{
+			const BRIEF_SHIP_INFO *ShipInfo = &EncounterPtr->ShipList[i];
+
+			write_8   (fh, ShipInfo->race_id);
+			write_16  (fh, ShipInfo->crew_level);
+			write_16  (fh, ShipInfo->max_crew);
+			write_8   (fh, ShipInfo->max_energy);
+		}
+
+		// Save the stuff after the BRIEF_SHIP_INFO array
+		write_32  (fh, EncounterPtr->log_x);
+		write_32  (fh, EncounterPtr->log_y);
+
+		UnlockEncounter (hEncounter);
+		hEncounter = hNextEncounter;
 	}
-	
-	// Save the stuff after the BRIEF_SHIP_INFO array
-	cwrite_32  (fh, EncounterPtr->log_x);
-	cwrite_32  (fh, EncounterPtr->log_y);
 }
 
 static void
-SaveEvent (const EVENT *EventPtr, DECODE_REF fh)
+SaveEvents (uio_Stream *fh)
 {
-	cwrite_ptr (fh); /* useless ptr; HEVENT pred */
-	cwrite_ptr (fh); /* useless ptr; HEVENT succ */
-	cwrite_8   (fh, EventPtr->day_index);
-	cwrite_8   (fh, EventPtr->month_index);
-	cwrite_16  (fh, EventPtr->year_index);
-	cwrite_8   (fh, EventPtr->func_index);
-	cwrite_8   (fh, 0); /* padding */
-	cwrite_16  (fh, 0); /* padding */
-}
+	COUNT num_links;
+	HEVENT hEvent;
+	num_links = CountLinks (&GLOBAL (GameClock.event_q));
+	if (num_links == 0)
+		return;
+	write_32 (fh, EVENTS_TAG);
+	write_32 (fh, num_links * 5); /* Event chunks are five bytes each */
 
-static void
-DummySaveQueue (const QUEUE *QueuePtr, DECODE_REF fh)
-{
-	/* QUEUE should never actually be saved since it contains
-	 * purely internal representation and the lists
-	 * involved are actually saved separately */
-	(void)QueuePtr; /* silence compiler */
+	hEvent = GetHeadLink (&GLOBAL (GameClock.event_q));
+	while (num_links--)
+	{
+		HEVENT hNextEvent;
+		EVENT *EventPtr;
 
-	/* QUEUE format with QUEUE_TABLE defined -- UQM default */
-	cwrite_ptr (fh); /* HLINK head */
-	cwrite_ptr (fh); /* HLINK tail */
-	cwrite_ptr (fh); /* BYTE* pq_tab */
-	cwrite_ptr (fh); /* HLINK free_list */
-	cwrite_16  (fh, 0); /* MEM_HANDLE hq_tab */
-	cwrite_16  (fh, 0); /* COUNT object_size */
-	cwrite_8   (fh, 0); /* BYTE num_objects */
-	
-	cwrite_8   (fh, 0); /* padding */
-	cwrite_16  (fh, 0); /* padding */
+		LockEvent (hEvent, &EventPtr);
+		hNextEvent = GetSuccEvent (EventPtr);
+
+		write_8   (fh, EventPtr->day_index);
+		write_8   (fh, EventPtr->month_index);
+		write_16  (fh, EventPtr->year_index);
+		write_8   (fh, EventPtr->func_index);
+
+		UnlockEvent (hEvent);
+		hEvent = hNextEvent;
+	}
 }
 
+/* The clock state is folded in with the game state chunk. */
 static void
-SaveClockState (const CLOCK_STATE *ClockPtr, DECODE_REF fh)
+SaveClockState (const CLOCK_STATE *ClockPtr, uio_Stream *fh)
 {
-	cwrite_8   (fh, ClockPtr->day_index);
-	cwrite_8   (fh, ClockPtr->month_index);
-	cwrite_16  (fh, ClockPtr->year_index);
-	cwrite_16  (fh, ClockPtr->tick_count);
-	cwrite_16  (fh, ClockPtr->day_in_ticks);
-	cwrite_ptr (fh); /* useless ptr; Semaphore clock_sem */
-	cwrite_ptr (fh); /* useless ptr; Task clock_task */
-	cwrite_32  (fh, 0); /* useless value; DWORD TimeCounter */
-
-	DummySaveQueue (&ClockPtr->event_q, fh);
+	write_8   (fh, ClockPtr->day_index);
+	write_8   (fh, ClockPtr->month_index);
+	write_16  (fh, ClockPtr->year_index);
+	write_16  (fh, ClockPtr->tick_count);
+	write_16  (fh, ClockPtr->day_in_ticks);
 }
 
-static void
-SaveGameState (const GAME_STATE *GSPtr, DECODE_REF fh)
+/* Save out the game state chunks. There are two of these; the Global
+ * State chunk is fixed size, but the Game State tag can be extended
+ * by modders. */
+static BOOLEAN
+SaveGameState (const GAME_STATE *GSPtr, uio_Stream *fh)
 {
-	cwrite_8   (fh, 0); /* obsolete; BYTE cur_state */
-	cwrite_8   (fh, GSPtr->glob_flags);
-	cwrite_8   (fh, GSPtr->CrewCost);
-	cwrite_8   (fh, GSPtr->FuelCost);
-	cwrite_a8  (fh, GSPtr->ModuleCost, NUM_MODULES);
-	cwrite_a8  (fh, GSPtr->ElementWorth, NUM_ELEMENT_CATEGORIES);
-	cwrite_ptr (fh); /* useless ptr; PRIMITIVE *DisplayArray */
-	cwrite_16  (fh, GSPtr->CurrentActivity);
-	
-	cwrite_16  (fh, 0); /* CLOCK_STATE alignment padding */
+	write_32  (fh, GLOBAL_STATE_TAG);
+	write_32  (fh, 75);
+	write_8   (fh, GSPtr->glob_flags);
+	write_8   (fh, GSPtr->CrewCost);
+	write_8   (fh, GSPtr->FuelCost);
+	write_a8  (fh, GSPtr->ModuleCost, NUM_MODULES);
+	write_a8  (fh, GSPtr->ElementWorth, NUM_ELEMENT_CATEGORIES);
+	write_16  (fh, GSPtr->CurrentActivity);
+
 	SaveClockState (&GSPtr->GameClock, fh);
 
-	cwrite_16  (fh, GSPtr->autopilot.x);
-	cwrite_16  (fh, GSPtr->autopilot.y);
-	cwrite_16  (fh, GSPtr->ip_location.x);
-	cwrite_16  (fh, GSPtr->ip_location.y);
+	write_16  (fh, GSPtr->autopilot.x);
+	write_16  (fh, GSPtr->autopilot.y);
+	write_16  (fh, GSPtr->ip_location.x);
+	write_16  (fh, GSPtr->ip_location.y);
 	/* STAMP ShipStamp */
-	cwrite_16  (fh, GSPtr->ShipStamp.origin.x);
-	cwrite_16  (fh, GSPtr->ShipStamp.origin.y);
-	cwrite_16  (fh, GSPtr->ShipFacing);
-	cwrite_8   (fh, GSPtr->ip_planet);
-	cwrite_8   (fh, GSPtr->in_orbit);
+	write_16  (fh, GSPtr->ShipStamp.origin.x);
+	write_16  (fh, GSPtr->ShipStamp.origin.y);
+	write_16  (fh, GSPtr->ShipFacing);
+	write_8   (fh, GSPtr->ip_planet);
+	write_8   (fh, GSPtr->in_orbit);
 
 	/* VELOCITY_DESC velocity */
-	cwrite_16  (fh, GSPtr->velocity.TravelAngle);
-	cwrite_16  (fh, GSPtr->velocity.vector.width);
-	cwrite_16  (fh, GSPtr->velocity.vector.height);
-	cwrite_16  (fh, GSPtr->velocity.fract.width);
-	cwrite_16  (fh, GSPtr->velocity.fract.height);
-	cwrite_16  (fh, GSPtr->velocity.error.width);
-	cwrite_16  (fh, GSPtr->velocity.error.height);
-	cwrite_16  (fh, GSPtr->velocity.incr.width);
-	cwrite_16  (fh, GSPtr->velocity.incr.height);
-	cwrite_16  (fh, 0); /* VELOCITY_DESC padding */
-
-	cwrite_32  (fh, GSPtr->BattleGroupRef);
-	
-	DummySaveQueue (&GSPtr->avail_race_q, fh);
-	DummySaveQueue (&GSPtr->npc_built_ship_q, fh);
-	// Not saving ip_group_q, was not there originally
-	DummySaveQueue (&GSPtr->encounter_q, fh);
-	DummySaveQueue (&GSPtr->built_ship_q, fh);
-
-	cwrite_a8  (fh, GSPtr->GameState, sizeof (GSPtr->GameState));
-
-	assert (sizeof (GSPtr->GameState) % 4 == 3);
-	cwrite_8  (fh, 0); /* GAME_STATE alignment padding */
+	write_16  (fh, GSPtr->velocity.TravelAngle);
+	write_16  (fh, GSPtr->velocity.vector.width);
+	write_16  (fh, GSPtr->velocity.vector.height);
+	write_16  (fh, GSPtr->velocity.fract.width);
+	write_16  (fh, GSPtr->velocity.fract.height);
+	write_16  (fh, GSPtr->velocity.error.width);
+	write_16  (fh, GSPtr->velocity.error.height);
+	write_16  (fh, GSPtr->velocity.incr.width);
+	write_16  (fh, GSPtr->velocity.incr.height);
+
+	/* The Game state bits. Vanilla UQM uses 155 bytes here at
+	 * present. Only the first 99 bytes are significant, though;
+	 * the rest will be overwritten by the BtGp chunks. */
+	write_32  (fh, GAME_STATE_TAG);
+	{
+		uint8 *buf = NULL;
+		size_t bufSize;
+		if (serialiseGameState (gameStateBitMap, &buf, &bufSize))
+		{
+			write_32  (fh, bufSize);
+			write_a8  (fh, buf, bufSize);
+			HFree(buf);
+		}
+		else
+			return FALSE;
+	}
+	return TRUE;
 }
 
-static BOOLEAN
+/* This is folded into the Summary chunk */
+static void
 SaveSisState (const SIS_STATE *SSPtr, void *fp)
 {
-	if (
-			write_32  (fp, SSPtr->log_x) != 1 ||
-			write_32  (fp, SSPtr->log_y) != 1 ||
-			write_32  (fp, SSPtr->ResUnits) != 1 ||
-			write_32  (fp, SSPtr->FuelOnBoard) != 1 ||
-			write_16  (fp, SSPtr->CrewEnlisted) != 1 ||
-			write_16  (fp, SSPtr->TotalElementMass) != 1 ||
-			write_16  (fp, SSPtr->TotalBioMass) != 1 ||
-			write_a8  (fp, SSPtr->ModuleSlots, NUM_MODULE_SLOTS) != 1 ||
-			write_a8  (fp, SSPtr->DriveSlots, NUM_DRIVE_SLOTS) != 1 ||
-			write_a8  (fp, SSPtr->JetSlots, NUM_JET_SLOTS) != 1 ||
-			write_8   (fp, SSPtr->NumLanders) != 1 ||
-			write_a16 (fp, SSPtr->ElementAmounts, NUM_ELEMENT_CATEGORIES) != 1 ||
-
-			write_str (fp, SSPtr->ShipName, SIS_NAME_SIZE) != 1 ||
-			write_str (fp, SSPtr->CommanderName, SIS_NAME_SIZE) != 1 ||
-			write_str (fp, SSPtr->PlanetName, SIS_NAME_SIZE) != 1 ||
-
-			write_16  (fp, 0) != 1 /* padding */
-		)
-		return FALSE;
-	else
-		return TRUE;
+	write_32  (fp, SSPtr->log_x);
+	write_32  (fp, SSPtr->log_y);
+	write_32  (fp, SSPtr->ResUnits);
+	write_32  (fp, SSPtr->FuelOnBoard);
+	write_16  (fp, SSPtr->CrewEnlisted);
+	write_16  (fp, SSPtr->TotalElementMass);
+	write_16  (fp, SSPtr->TotalBioMass);
+	write_a8  (fp, SSPtr->ModuleSlots, NUM_MODULE_SLOTS);
+	write_a8  (fp, SSPtr->DriveSlots, NUM_DRIVE_SLOTS);
+	write_a8  (fp, SSPtr->JetSlots, NUM_JET_SLOTS);
+	write_8   (fp, SSPtr->NumLanders);
+	write_a16 (fp, SSPtr->ElementAmounts, NUM_ELEMENT_CATEGORIES);
+
+	write_str (fp, SSPtr->ShipName, SIS_NAME_SIZE);
+	write_str (fp, SSPtr->CommanderName, SIS_NAME_SIZE);
+	write_str (fp, SSPtr->PlanetName, SIS_NAME_SIZE);
 }
 
-static BOOLEAN
+/* Write out the Summary Chunk. This is variable length because of the
+   savegame name */
+static void
 SaveSummary (const SUMMARY_DESC *SummPtr, void *fp)
 {
-	if (!SaveSisState (&SummPtr->SS, fp))
-		return FALSE;
-
-	if (
-			write_8  (fp, SummPtr->Activity) != 1 ||
-			write_8  (fp, SummPtr->Flags) != 1 ||
-			write_8  (fp, SummPtr->day_index) != 1 ||
-			write_8  (fp, SummPtr->month_index) != 1 ||
-			write_16 (fp, SummPtr->year_index) != 1 ||
-			write_8  (fp, SummPtr->MCreditLo) != 1 ||
-			write_8  (fp, SummPtr->MCreditHi) != 1 ||
-			write_8  (fp, SummPtr->NumShips) != 1 ||
-			write_8  (fp, SummPtr->NumDevices) != 1 ||
-			write_a8 (fp, SummPtr->ShipList, MAX_BUILT_SHIPS) != 1 ||
-			write_a8 (fp, SummPtr->DeviceList, MAX_EXCLUSIVE_DEVICES) != 1 ||
-
-			write_16  (fp, 0) != 1 /* padding */
-		)
-		return FALSE;
-	else
-		return TRUE;
-}
-
+	write_32 (fp, SUMMARY_TAG);
+	write_32 (fp, 160 + strlen(SummPtr->SaveName));
+	SaveSisState (&SummPtr->SS, fp);
+
+	write_8  (fp, SummPtr->Activity);
+	write_8  (fp, SummPtr->Flags);
+	write_8  (fp, SummPtr->day_index);
+	write_8  (fp, SummPtr->month_index);
+	write_16 (fp, SummPtr->year_index);
+	write_8  (fp, SummPtr->MCreditLo);
+	write_8  (fp, SummPtr->MCreditHi);
+	write_8  (fp, SummPtr->NumShips);
+	write_8  (fp, SummPtr->NumDevices);
+	write_a8 (fp, SummPtr->ShipList, MAX_BUILT_SHIPS);
+	write_a8 (fp, SummPtr->DeviceList, MAX_EXCLUSIVE_DEVICES);
+	write_a8 (fp, SummPtr->SaveName, strlen(SummPtr->SaveName));
+}
+
+/* Save the Star Description chunk. This is not to be confused with
+ * the Star *Info* chunk, which records which planetary features you
+ * have exploited with your lander */
 static void
-SaveStarDesc (const STAR_DESC *SDPtr, DECODE_REF fh)
+SaveStarDesc (const STAR_DESC *SDPtr, uio_Stream *fh)
 {
-	cwrite_16 (fh, SDPtr->star_pt.x);
-	cwrite_16 (fh, SDPtr->star_pt.y);
-	cwrite_8  (fh, SDPtr->Type);
-	cwrite_8  (fh, SDPtr->Index);
-	cwrite_8  (fh, SDPtr->Prefix);
-	cwrite_8  (fh, SDPtr->Postfix);
+	write_32 (fh, STAR_TAG);
+	write_32 (fh, 8);
+	write_16 (fh, SDPtr->star_pt.x);
+	write_16 (fh, SDPtr->star_pt.y);
+	write_8  (fh, SDPtr->Type);
+	write_8  (fh, SDPtr->Index);
+	write_8  (fh, SDPtr->Prefix);
+	write_8  (fh, SDPtr->Postfix);
 }
 
 static void
-PrepareSummary (SUMMARY_DESC *SummPtr)
+PrepareSummary (SUMMARY_DESC *SummPtr, const char *name)
 {
 	SummPtr->SS = GlobData.SIS_state;
 
@@ -483,7 +1101,7 @@ PrepareSummary (SUMMARY_DESC *SummPtr)
 	switch (SummPtr->Activity)
 	{
 		case IN_HYPERSPACE:
-			if (GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1)
+			if (inQuasiSpace ())
 				SummPtr->Activity = IN_QUASISPACE;
 			break;
 		case IN_INTERPLANETARY:
@@ -532,6 +1150,8 @@ PrepareSummary (SUMMARY_DESC *SummPtr)
 	SummPtr->day_index = GLOBAL (GameClock.day_index);
 	SummPtr->month_index = GLOBAL (GameClock.month_index);
 	SummPtr->year_index = GLOBAL (GameClock.year_index);
+	SummPtr->SaveName[SAVE_NAME_SIZE-1] = 0;
+	strncpy (SummPtr->SaveName, name, SAVE_NAME_SIZE-1);
 }
 
 static void
@@ -546,7 +1166,7 @@ SaveProblemMessage (STAMP *MsgStamp)
 	// TODO: This should probably just use DoPopupWindow()
 
 	ppStr[0] = GAME_STRING (SAVEGAME_STRING_BASE + 2);
- 
+
 	SetContextFont (StarConFont);
 
 	t.baseline.x = t.baseline.y = 0;
@@ -576,7 +1196,7 @@ SaveProblemMessage (STAMP *MsgStamp)
 	r.extent.height += 8;
 
 	*MsgStamp = SaveContextFrame (&r);
-	
+
 	BatchGraphics ();
 	DrawStarConBox (&r, 2,
 			BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19),
@@ -602,27 +1222,23 @@ SaveProblem (void)
 {
 	STAMP s;
 	CONTEXT OldContext;
-	
-	LockMutex (GraphicsLock);
+
 	OldContext = SetContext (SpaceContext);
 	SaveProblemMessage (&s);
 	FlushGraphics ();
-	UnlockMutex (GraphicsLock);
 
 	WaitForAnyButton (TRUE, WAIT_INFINITE, FALSE);
 
-	LockMutex (GraphicsLock);
 	// Restore the screen under the message
 	DrawStamp (&s);
 	SetContext (OldContext);
 	DestroyDrawable (ReleaseDrawable (s.frame));
-	UnlockMutex (GraphicsLock);
 }
 
 static void
 SaveFlagshipState (void)
 {
-	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+	if (inHQSpace ())
 	{
 		// Player is in HyperSpace or QuasiSpace.
 		SaveSisHyperState ();
@@ -633,68 +1249,212 @@ SaveFlagshipState (void)
 	}
 }
 
-// This function first writes to a memory file, and then writes the whole
-// lot to the actual save file at once.
-BOOLEAN
-SaveGame (COUNT which_game, SUMMARY_DESC *SummPtr)
+static void
+SaveStarInfo (uio_Stream *fh)
 {
-	BOOLEAN success, made_room;
-	void *out_fp, *h;
-	DECODE_REF fh;
-
-	success = TRUE;
-	made_room = FALSE;
-RetrySave:
-	h = HMalloc (10 * 1024);
-	if (h == 0
-			|| (fh = copen (h, MEMORY_STREAM, STREAM_WRITE)) == 0)
+	GAME_STATE_FILE *fp;
+	fp = OpenStateFile (STARINFO_FILE, "rb");
+	if (fp)
 	{
-		if (success)
+		DWORD flen = LengthStateFile (fp);
+		if (flen % 4)
 		{
-			success = FALSE;
-			made_room = TRUE;
-			HFree (h);
-
-			FreeSC2Data ();
-			log_add (log_Debug, "Insufficient room for save buffers"
-					" -- RETRYING");
-			goto RetrySave;
+			log_add (log_Warning, "Unexpected Star Info length! Expected an integral number of DWORDS.\n");
 		}
 		else
-			log_add (log_Debug, "Insufficient room for save buffers"
-					" -- GIVING UP!");
+		{
+			write_32 (fh, SCAN_TAG);
+			write_32 (fh, flen);
+			while (flen)
+			{
+				DWORD val;
+				sread_32 (fp, &val);
+				write_32 (fh, val);
+				flen -= 4;
+			}
+		}
+		CloseStateFile (fp);
+	}
+}
+
+static void
+SaveBattleGroup (GAME_STATE_FILE *fp, DWORD encounter_id, DWORD grpoffs, uio_Stream *fh)
+{
+	GROUP_HEADER h;
+	DWORD size = 12;
+	int i;
+	SeekStateFile (fp, grpoffs, SEEK_SET);
+	ReadGroupHeader (fp, &h);
+	for (i = 1; i <= h.NumGroups; ++i)
+	{
+		BYTE NumShips;
+		SeekStateFile (fp, h.GroupOffset[i], SEEK_SET);
+		sread_8 (fp, NULL);
+		sread_8 (fp, &NumShips);
+		size += 2 + 10 * NumShips;
+	}
+	write_32 (fh, BATTLE_GROUP_TAG);
+	write_32 (fh, size);
+	write_32 (fh, encounter_id);
+	write_8  (fh, (grpoffs && (GLOBAL (BattleGroupRef) == grpoffs)) ? 1 : 0); // current
+	write_16 (fh, h.star_index);
+	write_8  (fh, h.day_index);
+	write_8  (fh, h.month_index);
+	write_16 (fh, h.year_index);
+	write_8  (fh, h.NumGroups);
+	for (i = 1; i <= h.NumGroups; ++i)
+	{
+		int j;
+		BYTE b;
+		SeekStateFile (fp, h.GroupOffset[i], SEEK_SET);
+		sread_8 (fp, &b); // Group race icon
+		write_8 (fh, b);
+		sread_8 (fp, &b); // NumShips
+		write_8 (fh, b);
+		for (j = 0; j < b; ++j)
+		{
+			BYTE race_outer;
+			SHIP_FRAGMENT sf;
+			sread_8 (fp, &race_outer);
+			ReadShipFragment (fp, &sf);
+			write_8  (fh, race_outer);
+			write_8  (fh, sf.captains_name_index);
+			write_8  (fh, sf.race_id);
+			write_8  (fh, sf.index);
+			write_16 (fh, sf.crew_level);
+			write_16 (fh, sf.max_crew);
+			write_8  (fh, sf.energy_level);
+			write_8  (fh, sf.max_energy);
+		}
+	}
+}
+
+static DWORD
+GetBattleGroupOffset (int encounterIndex)
+{
+	// The reason for this switch, even though the group offsets are
+	// successive, is because GET_GAME_STATE is a #define, which stringizes
+	// its argument.
+	switch (encounterIndex)
+	{
+		case  1: return GET_GAME_STATE (SHOFIXTI_GRPOFFS);
+		case  2: return GET_GAME_STATE (ZOQFOT_GRPOFFS);
+		case  3: return GET_GAME_STATE (MELNORME0_GRPOFFS);
+		case  4: return GET_GAME_STATE (MELNORME1_GRPOFFS);
+		case  5: return GET_GAME_STATE (MELNORME2_GRPOFFS);
+		case  6: return GET_GAME_STATE (MELNORME3_GRPOFFS);
+		case  7: return GET_GAME_STATE (MELNORME4_GRPOFFS);
+		case  8: return GET_GAME_STATE (MELNORME5_GRPOFFS);
+		case  9: return GET_GAME_STATE (MELNORME6_GRPOFFS);
+		case 10: return GET_GAME_STATE (MELNORME7_GRPOFFS);
+		case 11: return GET_GAME_STATE (MELNORME8_GRPOFFS);
+		case 12: return GET_GAME_STATE (URQUAN_PROBE_GRPOFFS);
+		case 13: return GET_GAME_STATE (COLONY_GRPOFFS);
+		case 14: return GET_GAME_STATE (SAMATRA_GRPOFFS);
+		default:
+			log_add (log_Warning, "SetBattleGroupOffset: invalid encounter "
+					"index.\n");
+			return 0;
+	}
+}
+
+static void
+SaveGroups (uio_Stream *fh)
+{
+	GAME_STATE_FILE *fp;
+	fp = OpenStateFile (RANDGRPINFO_FILE, "rb");
+	if (fp && LengthStateFile (fp) > 0)
+	{
+		GROUP_HEADER h;
+		BYTE lastenc, count;
+		int i;
+		ReadGroupHeader (fp, &h);
+		/* Group List */
+		SeekStateFile (fp, h.GroupOffset[0], SEEK_SET);	
+		sread_8 (fp, &lastenc);
+		sread_8 (fp, &count);
+		write_32 (fh, GROUP_LIST_TAG);
+		write_32 (fh, 1 + 14 * count); // Chunk size
+		write_8 (fh, lastenc);
+		for (i = 0; i < count; ++i)
+		{
+			BYTE race_outer;
+			IP_GROUP ip;
+			sread_8 (fp, &race_outer);
+			ReadIpGroup (fp, &ip);
+
+			write_8  (fh, race_outer);
+			write_16 (fh, ip.group_counter);
+			write_8  (fh, ip.race_id);
+			write_8  (fh, ip.sys_loc);
+			write_8  (fh, ip.task);
+			write_8  (fh, ip.in_system);
+			write_8  (fh, ip.dest_loc);
+			write_8  (fh, ip.orbit_pos);
+			write_8  (fh, ip.group_id);
+			write_16 (fh, ip.loc.x);
+			write_16 (fh, ip.loc.y);
+		}
+		SaveBattleGroup (fp, 0, 0, fh);
+		CloseStateFile (fp);
+	}
+	fp = OpenStateFile (DEFGRPINFO_FILE, "rb");
+	if (fp && LengthStateFile (fp) > 0)
+	{
+		int encounter_index;
+		for (encounter_index = 1; encounter_index < 15; encounter_index++)
+		{
+			DWORD grpoffs = GetBattleGroupOffset (encounter_index);
+			if (grpoffs)
+			{
+				SaveBattleGroup (fp, encounter_index, grpoffs, fh);
+			}
+		}
+		CloseStateFile (fp);
 	}
+}
+
+// This function first writes to a memory file, and then writes the whole
+// lot to the actual save file at once.
+BOOLEAN
+SaveGame (COUNT which_game, SUMMARY_DESC *SummPtr, const char *name)
+{
+	uio_Stream *out_fp;
+	POINT pt;
+	STAR_DESC SD;
+	char file[PATH_MAX];
+	if (CurStarDescPtr)
+		SD = *CurStarDescPtr;
 	else
+		memset (&SD, 0, sizeof (SD));
+
+	// XXX: Backup: SaveFlagshipState() overwrites ip_location
+	pt = GLOBAL (ip_location);
+	SaveFlagshipState ();
+	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
+			&& !(GLOBAL (CurrentActivity)
+			& (START_ENCOUNTER | START_INTERPLANETARY)))
+		PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
+
+	// Write the memory file to the actual savegame file.
+	sprintf (file, "uqmsave.%02u", which_game);
+	if ((out_fp = res_OpenResFile (saveDir, file, "wb")))
 	{
-		GAME_STATE_FILE *fp;
-		DWORD flen;
-		COUNT num_links;
-		POINT pt;
-		STAR_DESC SD;
-		char buf[256], file[PATH_MAX];
-
-		success = TRUE;
-		if (CurStarDescPtr)
-			SD = *CurStarDescPtr;
-		else
-			memset (&SD, 0, sizeof (SD));
+		io_ok = TRUE;
+		write_32 (out_fp, SAVEFILE_TAG);
 
-		// XXX: Backup: SaveFlagshipState() overwrites ip_location
-		pt = GLOBAL (ip_location);
-		SaveFlagshipState ();
-		if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
-				&& !(GLOBAL (CurrentActivity)
-				& (START_ENCOUNTER | START_INTERPLANETARY)))
-			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
+		PrepareSummary (SummPtr, name);
+		SaveSummary (SummPtr, out_fp);
 
-		SaveGameState (&GlobData.Game_state, fh);
+		if (!SaveGameState (&GlobData.Game_state, out_fp))
+			io_ok = FALSE;
 
 		// XXX: Restore
 		GLOBAL (ip_location) = pt;
 		// Only relevant when loading a game and must be cleaned
 		GLOBAL (in_orbit) = 0;
 
-		SaveRaceQueue (fh, &GLOBAL (avail_race_q));
+		SaveRaceQueue (out_fp, &GLOBAL (avail_race_q));
 		// START_INTERPLANETARY is only set when saving from Homeworld
 		//   encounter screen. When the game is loaded, the
 		//   GenerateOrbitalFunction for the current star system
@@ -702,161 +1462,40 @@ RetrySave:
 		if (!(GLOBAL (CurrentActivity) & START_INTERPLANETARY))
 		{
 			if (GLOBAL (CurrentActivity) & START_ENCOUNTER)
-				SaveShipQueue (fh, &GLOBAL (npc_built_ship_q));
+				SaveShipQueue (out_fp, &GLOBAL (npc_built_ship_q), NPC_SHIP_Q_TAG);
 			else if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY)
 				// XXX: Technically, this queue does not need to be
 				//   saved/loaded at all. IP groups will be reloaded
 				//   from group state files. But the original code did,
 				//   and so will we until we can prove we do not need to.
-				SaveGroupQueue (fh, &GLOBAL (ip_group_q));
-				//SaveEmptyQueue (fh);
-			else
-				// XXX: empty queue write-out is only needed to maintain
-				//   the savegame compatibility
-				SaveEmptyQueue (fh);
-		}
-		SaveShipQueue (fh, &GLOBAL (built_ship_q));
-
-		// Save the number of game events (compressed).
-		num_links = CountLinks (&GLOBAL (GameClock.event_q));
-		cwrite_16 (fh, num_links);
-		// Save the game events themselves (compressed):
-		{
-			HEVENT hEvent;
-
-			hEvent = GetHeadLink (&GLOBAL (GameClock.event_q));
-			while (num_links--)
-			{
-				HEVENT hNextEvent;
-				EVENT *EventPtr;
-
-				LockEvent (hEvent, &EventPtr);
-				hNextEvent = GetSuccEvent (EventPtr);
-
-				SaveEvent (EventPtr, fh);
-
-				UnlockEvent (hEvent);
-				hEvent = hNextEvent;
-			}
-		}
-
-		// Save the number of encounters (black globes in HS/QS (compressed))
-		num_links = CountLinks (&GLOBAL (encounter_q));
-		// Save the encounters themselves (compressed):
-		cwrite_16 (fh, num_links);
-		{
-			HENCOUNTER hEncounter;
-
-			hEncounter = GetHeadLink (&GLOBAL (encounter_q));
-			while (num_links--)
-			{
-				HENCOUNTER hNextEncounter;
-				ENCOUNTER *EncounterPtr;
-
-				LockEncounter (hEncounter, &EncounterPtr);
-				hNextEncounter = GetSuccEncounter (EncounterPtr);
-
-				SaveEncounter (EncounterPtr, fh);
-
-				UnlockEncounter (hEncounter);
-				hEncounter = hNextEncounter;
-			}
-		}
-
-		// Copy the star info file to the memory file (compressed).
-		fp = OpenStateFile (STARINFO_FILE, "rb");
-		if (fp)
-		{
-			flen = LengthStateFile (fp);
-			// Write the uncompressed size.
-			cwrite_32 (fh, flen);
-			while (flen)
-			{
-				COUNT num_bytes;
-
-				num_bytes = flen >= sizeof (buf) ? sizeof (buf) : (COUNT)flen;
-				ReadStateFile (buf, num_bytes, 1, fp);
-				cwrite (buf, num_bytes, 1, fh);
-
-				flen -= num_bytes;
-			}
-			CloseStateFile (fp);
-		}
-
-		// Copy the defined groupinfo file into the memory file (compressed)
-		fp = OpenStateFile (DEFGRPINFO_FILE, "rb");
-		if (fp)
-		{
-			flen = LengthStateFile (fp);
-			// Write the uncompressed size.
-			cwrite_32 (fh, flen);
-			while (flen)
-			{
-				COUNT num_bytes;
-
-				num_bytes = flen >= sizeof (buf) ? sizeof (buf) : (COUNT)flen;
-				ReadStateFile (buf, num_bytes, 1, fp);
-				cwrite (buf, num_bytes, 1, fh);
-
-				flen -= num_bytes;
-			}
-			CloseStateFile (fp);
-		}
-
-		// Copy the random groupinfo file into the memory file (compressed)
-		fp = OpenStateFile (RANDGRPINFO_FILE, "rb");
-		if (fp)
-		{
-			flen = LengthStateFile (fp);
-			// Write the uncompressed size.
-			cwrite_32 (fh, flen);
-			while (flen)
-			{
-				COUNT num_bytes;
-
-				num_bytes = flen >= sizeof (buf) ? sizeof (buf) : (COUNT)flen;
-				ReadStateFile (buf, num_bytes, 1, fp);
-				cwrite (buf, num_bytes, 1, fh);
-
-				flen -= num_bytes;
-			}
-			CloseStateFile (fp);
+				SaveGroupQueue (out_fp, &GLOBAL (ip_group_q));
 		}
+		SaveShipQueue (out_fp, &GLOBAL (built_ship_q), SHIP_Q_TAG);
 
-		// Write the current star desc into the memory file (compressed).
-		SaveStarDesc (&SD, fh);
+		// Save the game event chunk
+		SaveEvents (out_fp);
 
-		flen = cclose (fh);
+		// Save the encounter chunk (black globes in HS/QS)
+		SaveEncounters (out_fp);
 
-		// Write the memory file to the actual savegame file.
-		sprintf (file, "starcon2.%02u", which_game);
-		log_add (log_Debug, "'%s' is %u bytes long", file,
-				flen + sizeof (*SummPtr));
-		if (flen && (out_fp = res_OpenResFile (saveDir, file, "wb")))
+		// Save out the data that used to be in state files
+		SaveStarInfo (out_fp);
+		SaveGroups (out_fp);
+
+		// Save out the Star Descriptor
+		SaveStarDesc (&SD, out_fp);
+		
+		res_CloseResFile (out_fp);
+		if (!io_ok)
 		{
-			PrepareSummary (SummPtr);
-
-			success = SaveSummary (SummPtr, out_fp);
-			// Then write the rest of the data.
-			if (success && WriteResFile (h, flen, 1, out_fp) != 1)
-				success = FALSE;
-
-			if (res_CloseResFile ((uio_Stream *)out_fp) == 0)
-				success = FALSE;
-
+			DeleteResFile(saveDir, file);
+			return FALSE;
 		}
-		else
-			success = FALSE;
-			
-		if (!success)
-			DeleteResFile (saveDir, file);
+	}
+	else
+	{
+		return FALSE;
 	}
 
-	HFree (h);
-
-	if (made_room)
-		LoadSC2Data ();
-
-	return (success);
+	return TRUE;
 }
-
diff -ruNp src.orig/uqm/save.h src/uqm/save.h
--- src.orig/uqm/save.h	2017-11-21 19:39:40 -0600
+++ src/uqm/save.h	2017-11-21 19:39:57 -0600
@@ -17,12 +17,65 @@
 #ifndef _SAVE_H
 #define _SAVE_H
 
-#include "sis.h"
-		// for SUMMARY_DESC
+#include "sis.h" // SUMMARY_DESC includes SIS_STATE in it
+#include "globdata.h"
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+// XXX: Theoretically, a player can have 17 devices on board without
+//   cheating. We only provide
+//   room for 16 below, which is not really a problem since this
+//   is only used for displaying savegame summaries. There is also
+//   room for only 16 devices on screen.
+#define MAX_EXCLUSIVE_DEVICES 16
+#define SAVE_NAME_SIZE 64
+
+// The savefile tag numbers.
+#define SAVEFILE_TAG     0x01534d55 // "UMS\x01": UQM Save version 1
+#define SUMMARY_TAG      0x6d6d7553 // "Summ": Summary. Must be first!
+#define GLOBAL_STATE_TAG 0x74536c47 // "GlSt": Global State. Must be 2nd!
+#define GAME_STATE_TAG   0x74536d47 // "GmSt": Game State Bits. Must be 3rd!
+#define EVENTS_TAG       0x73747645 // "Evts": Events
+#define ENCOUNTERS_TAG   0x74636e45 // "Enct": Encounters
+#define RACE_Q_TAG       0x51636152 // "RacQ": avail_race_q
+#define IP_GRP_Q_TAG     0x51704749 // "IGpQ": ip_group_q
+#define NPC_SHIP_Q_TAG   0x5163704e // "NpcQ": npc_built_ship_q
+#define SHIP_Q_TAG       0x51706853 // "ShpQ": built_ship_q
+#define STAR_TAG         0x72617453 // "Star": STAR_DESC
+#define SCAN_TAG         0x6e616353 // "Scan": Scan Masks (stuff picked up)
+#define BATTLE_GROUP_TAG 0x70477442 // "BtGp": Battle Group definition
+#define GROUP_LIST_TAG   0x73707247 // "Grps": Group List
+
+typedef struct
+{
+	SIS_STATE SS;
+	BYTE Activity;
+	BYTE Flags;
+	BYTE day_index, month_index;
+	COUNT year_index;
+	BYTE MCreditLo, MCreditHi;
+	BYTE NumShips, NumDevices;
+	BYTE ShipList[MAX_BUILT_SHIPS];
+	BYTE DeviceList[MAX_EXCLUSIVE_DEVICES];
+	UNICODE SaveName[SAVE_NAME_SIZE];
+} SUMMARY_DESC;
+
+extern ACTIVITY NextActivity;
+
+extern BOOLEAN LoadGame (COUNT which_game, SUMMARY_DESC *summary_desc);
+extern BOOLEAN LoadLegacyGame (COUNT which_game, SUMMARY_DESC *summary_desc);
+
 extern void SaveProblem (void);
-extern BOOLEAN SaveGame (COUNT which_game, SUMMARY_DESC *summary_desc);
+extern BOOLEAN SaveGame (COUNT which_game, SUMMARY_DESC *summary_desc, const char *name);
+
+extern const GameStateBitMap gameStateBitMap[];
+
+#if defined(__cplusplus)
+}
+#endif
 
 #endif  /* _SAVE_H */
 
diff -ruNp src.orig/uqm/settings.h src/uqm/settings.h
--- src.orig/uqm/settings.h	2017-11-21 19:39:40 -0600
+++ src/uqm/settings.h	2017-11-21 19:39:57 -0600
@@ -19,6 +19,10 @@
 
 #include "libs/sndlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern void ToggleMusic (void);
 extern void StopMusic (void);
 extern void ResumeMusic (void);
@@ -30,5 +34,9 @@ extern void PlaySoundEffect (SOUND S, CO
 		void *PositionalObject, BYTE Priority);
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _SETTINGS_H */
 
diff -ruNp src.orig/uqm/setup.c src/uqm/setup.c
--- src.orig/uqm/setup.c	2017-11-21 19:39:40 -0600
+++ src/uqm/setup.c	2017-11-21 19:39:57 -0600
@@ -65,13 +65,14 @@ FRAME StatusFrame;
 FRAME FlagStatFrame;
 FRAME MiscDataFrame;
 FRAME FontGradFrame;
-Mutex GraphicsLock;
 STRING GameStrings;
 QUEUE disp_q;
 
 uio_Repository *repository;
 uio_DirHandle *rootDir;
 
+BOOLEAN usingSpeech;
+
 
 static void
 InitPlayerInput (void)
@@ -119,9 +120,11 @@ LoadKernel (int argc, char *argv[])
 		loadAddon ("3domusic");
 	}
 
-	/* Always try to use voice data */
-	if (!loadAddon ("3dovoice"))
-		speechVolumeScale = 0.0f; // XXX: need better no-speech indicator
+	usingSpeech = optSpeech;
+	if (optSpeech && !loadAddon ("3dovoice"))
+	{
+		usingSpeech = FALSE;
+	}
 
 	if (optRemixMusic)
 	{
diff -ruNp src.orig/uqm/setup.h src/uqm/setup.h
--- src.orig/uqm/setup.h	2017-11-21 19:39:40 -0600
+++ src/uqm/setup.h	2017-11-21 19:39:57 -0600
@@ -24,6 +24,10 @@
 #include "libs/gfxlib.h"
 #include "libs/threadlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern RESOURCE_INDEX hResIndex;
 
 extern FRAME Screen;
@@ -47,7 +51,6 @@ extern FONT StarConFont;
 extern FONT MicroFont;
 extern FONT TinyFont;
 
-extern Mutex GraphicsLock;
 extern CondVar RenderingCond;
 
 extern QUEUE race_q[];
@@ -58,6 +61,10 @@ extern ACTIVITY LastActivity;
 
 extern BYTE PlayerControl[];
 
+extern BOOLEAN usingSpeech;
+		// Actual speech presence indicator which decouples reality from
+		// the user option, thus the user option remains as pure intent
+
 BOOLEAN InitContexts (void);
 void UninitPlayerInput (void);
 BOOLEAN InitGameKernel (void);
@@ -75,6 +82,10 @@ void ClearPlayerInput (COUNT playerI);
 void ClearPlayerInputAll (void);
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _SETUP_H */
 
 
diff -ruNp src.orig/uqm/setupmenu.c src/uqm/setupmenu.c
--- src.orig/uqm/setupmenu.c	2017-11-21 19:39:40 -0600
+++ src/uqm/setupmenu.c	2017-11-21 19:39:57 -0600
@@ -37,6 +37,8 @@
 #include "libs/memlib.h"
 #include "resinst.h"
 #include "nameref.h"
+#include <math.h>
+
 
 static STRING SetupTab;
 
@@ -73,8 +75,8 @@ static void clear_control (WIDGET_CONTRO
 #endif
 
 #define MENU_COUNT          8
-#define CHOICE_COUNT       22
-#define SLIDER_COUNT        3
+#define CHOICE_COUNT       24
+#define SLIDER_COUNT        4
 #define BUTTON_COUNT       10
 #define LABEL_COUNT         4
 #define TEXTENTRY_COUNT     1
@@ -96,25 +98,13 @@ typedef int (*HANDLER)(WIDGET *, int);
 static int choice_widths[CHOICE_COUNT] = {
 	3, 2, 3, 3, 2, 2, 2, 2, 2, 2, 
 	2, 2, 3, 2, 2, 3, 3, 2,	3, 3, 
-	3, 2 };
+	3, 2, 2, 2 };
 
 static HANDLER button_handlers[BUTTON_COUNT] = {
 	quit_main_menu, quit_sub_menu, do_graphics, do_engine,
 	do_audio, do_resources, do_keyconfig, do_advanced, do_editkeys, 
 	do_keyconfig };
 
-static int menu_sizes[MENU_COUNT] = {
-	7, 5, 7, 9, 2, 5,
-#ifdef HAVE_OPENGL
-	5,
-#else
-	4,
-#endif
-	11
-};
-
-static int menu_bgs[MENU_COUNT] = { 0, 1, 1, 2, 3, 1, 2, 1 };
-
 /* These refer to uninitialized widgets, but that's OK; we'll fill
  * them in before we touch them */
 static WIDGET *main_widgets[] = {
@@ -124,14 +114,18 @@ static WIDGET *main_widgets[] = {
 	(WIDGET *)(&buttons[5]),
 	(WIDGET *)(&buttons[6]),
 	(WIDGET *)(&buttons[7]),
-	(WIDGET *)(&buttons[0]) };
+	(WIDGET *)(&buttons[0]),
+	NULL };
 
 static WIDGET *graphics_widgets[] = {
 	(WIDGET *)(&choices[0]),
+	(WIDGET *)(&choices[23]),
 	(WIDGET *)(&choices[10]),
+	(WIDGET *)(&sliders[3]),
 	(WIDGET *)(&choices[2]),
 	(WIDGET *)(&choices[3]),
-	(WIDGET *)(&buttons[1]) };
+	(WIDGET *)(&buttons[1]),
+	NULL };
 
 static WIDGET *audio_widgets[] = {
 	(WIDGET *)(&sliders[0]),
@@ -140,7 +134,9 @@ static WIDGET *audio_widgets[] = {
 	(WIDGET *)(&choices[14]),
 	(WIDGET *)(&choices[9]),
 	(WIDGET *)(&choices[21]),
-	(WIDGET *)(&buttons[1]) };
+	(WIDGET *)(&choices[22]),
+	(WIDGET *)(&buttons[1]),
+	NULL };
 
 static WIDGET *engine_widgets[] = {
 	(WIDGET *)(&choices[4]),
@@ -151,7 +147,8 @@ static WIDGET *engine_widgets[] = {
 	(WIDGET *)(&choices[13]),
 	(WIDGET *)(&choices[11]),
 	(WIDGET *)(&choices[17]),
-	(WIDGET *)(&buttons[1]) };
+	(WIDGET *)(&buttons[1]),
+	NULL };
 
 static WIDGET *advanced_widgets[] = {
 #ifdef HAVE_OPENGL
@@ -160,14 +157,16 @@ static WIDGET *advanced_widgets[] = {
 	(WIDGET *)(&choices[12]),
 	(WIDGET *)(&choices[15]),
 	(WIDGET *)(&choices[16]),
-	(WIDGET *)(&buttons[1]) };
+	(WIDGET *)(&buttons[1]),
+	NULL };
 	
 static WIDGET *keyconfig_widgets[] = {
 	(WIDGET *)(&choices[18]),
 	(WIDGET *)(&choices[19]),
 	(WIDGET *)(&labels[1]),
 	(WIDGET *)(&buttons[8]),
-	(WIDGET *)(&buttons[1]) };
+	(WIDGET *)(&buttons[1]),
+	NULL };
 
 static WIDGET *editkeys_widgets[] = {
 	(WIDGET *)(&choices[20]),
@@ -180,15 +179,43 @@ static WIDGET *editkeys_widgets[] = {
 	(WIDGET *)(&controlentries[4]),
 	(WIDGET *)(&controlentries[5]),
 	(WIDGET *)(&controlentries[6]),
-	(WIDGET *)(&buttons[9]) };
+	(WIDGET *)(&buttons[9]),
+	NULL };
 
 static WIDGET *incomplete_widgets[] = {
 	(WIDGET *)(&labels[0]),
-	(WIDGET *)(&buttons[1]) };
+	(WIDGET *)(&buttons[1]),
+	NULL };
+
+static const struct
+{
+	WIDGET **widgets;
+	int bgIndex;
+}
+menu_defs[] =
+{
+	{main_widgets, 0},
+	{graphics_widgets, 1},
+	{audio_widgets, 1},
+	{engine_widgets, 2},
+	{incomplete_widgets, 3},
+	{keyconfig_widgets, 1},
+	{advanced_widgets, 2},
+	{editkeys_widgets, 1},
+	{NULL, 0}
+};
+
+// Start with reasonable gamma bounds. These will get updated
+// as we find out the actual bounds.
+static float minGamma = 0.4f;
+static float maxGamma = 2.5f;
+// The gamma slider uses an exponential curve
+// We use y = e^(2.1972*(x-1)) curve to give us a nice spread of
+// gamma values 0.11 < g < 9.0 centered at g=1.0
+#define GAMMA_CURVE_B  2.1972f
+static float minGammaX;
+static float maxGammaX;
 
-static WIDGET **menu_widgets[MENU_COUNT] = {
-	main_widgets, graphics_widgets, audio_widgets, engine_widgets, 
-	incomplete_widgets, keyconfig_widgets, advanced_widgets, editkeys_widgets };
 
 static int
 quit_main_menu (WIDGET *self, int event)
@@ -294,18 +321,18 @@ do_advanced (WIDGET *self, int event)
 }
 
 static void
-populate_editkeys (int template)
+populate_editkeys (int templat)
 {
 	int i, j;
 	
-	strncpy (textentries[0].value, input_templates[template].name, textentries[0].maxlen);
+	strncpy (textentries[0].value, input_templates[templat].name, textentries[0].maxlen);
 	textentries[0].value[textentries[0].maxlen-1] = 0;
 	
 	for (i = 0; i < NUM_KEYS; i++)
 	{
 		for (j = 0; j < 2; j++)
 		{
-			InterrogateInputState (template, i, j, controlentries[i].controlname[j], WIDGET_CONTROLENTRY_WIDTH);
+			InterrogateInputState (templat, i, j, controlentries[i].controlname[j], WIDGET_CONTROLENTRY_WIDTH);
 		}
 	}
 }
@@ -387,10 +414,13 @@ SetDefaults (void)
 	choices[19].selected = opts.player2;
 	choices[20].selected = 0;
 	choices[21].selected = opts.musicremix;
+	choices[22].selected = opts.speech;
+	choices[23].selected = opts.keepaspect;
 
 	sliders[0].value = opts.musicvol;
 	sliders[1].value = opts.sfxvol;
 	sliders[2].value = opts.speechvol;
+	sliders[3].value = opts.gamma;
 }
 
 static void
@@ -418,10 +448,13 @@ PropagateResults (void)
 	opts.player1 = choices[18].selected;
 	opts.player2 = choices[19].selected;
 	opts.musicremix = choices[21].selected;
+	opts.speech = choices[22].selected;
+	opts.keepaspect = choices[23].selected;
 
 	opts.musicvol = sliders[0].value;
 	opts.sfxvol = sliders[1].value;
 	opts.speechvol = sliders[2].value;
+	opts.gamma = sliders[3].value;
 	SetGlobalOptions (&opts);
 }
 
@@ -578,31 +611,170 @@ OnTextEntryEvent (WIDGET_TEXTENTRY *widg
 	return TRUE; // event handled
 }
 
+static inline float
+gammaCurve (float x)
+{
+	// The slider uses an exponential curve
+	return exp ((x - 1) * GAMMA_CURVE_B);
+}
+
+static inline float
+solveGammaCurve (float y)
+{
+	return log (y) / GAMMA_CURVE_B + 1;
+}
+
+static int
+gammaToSlider (float gamma)
+{
+	const float x = solveGammaCurve (gamma);
+	const float step = (maxGammaX - minGammaX) / 100;
+	return (int) ((x - minGammaX) / step + 0.5);
+}
+
+static float
+sliderToGamma (int value)
+{
+	const float step = (maxGammaX - minGammaX) / 100;
+	const float x = minGammaX + step * value;
+	const float g = gammaCurve (x);
+	// report any value that is close enough as 1.0
+	return (fabs (g - 1.0f) < 0.001f) ? 1.0f : g;
+}
+
+static void
+updateGammaBounds (bool useUpper)
+{
+	float g, x;
+	int slider;
+	
+	// The slider uses an exponential curve.
+	// Calculate where on the curve the min and max gamma values are
+	minGammaX = solveGammaCurve (minGamma);
+	maxGammaX = solveGammaCurve (maxGamma);
+
+	// We have 100 discrete steps through the range, so the slider may
+	// skip over a 1.0 gamma. We need to ensure that there always is
+	// a 1.0 on the slider by tweaking the range (expanding/contracting).
+	slider = gammaToSlider (1.0f);
+	g = sliderToGamma (slider);
+	if (g == 1.0f)
+		return; // no adjustment needed
+
+	x = solveGammaCurve (g);
+	if (useUpper)
+	{	// Move the upper bound up or down to land on 1.0
+		const float d = (x - 1.0f) * 100 / slider;
+		maxGammaX -= d;
+		maxGamma = gammaCurve (maxGammaX);
+	}
+	else
+	{	// Move the lower bound up or down to land on 1.0
+		const float d = (x - 1.0f) * 100 / (100 - slider);
+		minGammaX -= d;
+		minGamma = gammaCurve (minGammaX);
+	}
+}
+
+static int
+gamma_HandleEventSlider (WIDGET *_self, int event)
+{
+	WIDGET_SLIDER *self = (WIDGET_SLIDER *)_self;
+	int prevValue = self->value;
+	float gamma;
+	bool set;
+
+	switch (event)
+	{
+	case WIDGET_EVENT_LEFT:
+		self->value -= self->step;
+		break;
+	case WIDGET_EVENT_RIGHT:
+		self->value += self->step;
+		break;
+	default:
+		return FALSE;
+	}
+
+	// Limit the slider to values accepted by gfx subsys
+	gamma = sliderToGamma (self->value);
+	set = TFB_SetGamma (gamma);
+	if (!set)
+	{	// revert
+		self->value = prevValue;
+		gamma = sliderToGamma (self->value);
+	}
+
+	// Grow or shrink the range based on accepted values
+	if (gamma < minGamma || (!set && event == WIDGET_EVENT_LEFT))
+	{
+		minGamma = gamma;
+		updateGammaBounds (true);
+		// at the lowest end
+		self->value = 0;
+	}
+	else if (gamma > maxGamma || (!set && event == WIDGET_EVENT_RIGHT))
+	{
+		maxGamma = gamma;
+		updateGammaBounds (false);
+		// at the highest end
+		self->value = 100;
+	}
+	return TRUE;
+}
+
+static void
+gamma_DrawValue (WIDGET_SLIDER *self, int x, int y)
+{
+	TEXT t;
+	char buf[16];
+	float gamma = sliderToGamma (self->value);
+	snprintf (buf, sizeof buf, "%.4f", gamma);
+
+	t.baseline.x = x;
+	t.baseline.y = y;
+	t.align = ALIGN_CENTER;
+	t.CharCount = ~0;
+	t.pStr = buf;
+
+	font_DrawText (&t);
+}
+
 static void
 rebind_control (WIDGET_CONTROLENTRY *widget)
 {
-	int template = choices[20].selected;
+	int templat = choices[20].selected;
 	int control = widget->controlindex;
 	int index = widget->highlighted;
 
 	FlushInput ();
 	DrawLabelAsWindow (&labels[3], NULL);
-	RebindInputState (template, control, index);
-	populate_editkeys (template);
+	RebindInputState (templat, control, index);
+	populate_editkeys (templat);
 	FlushInput ();
 }
 
 static void
 clear_control (WIDGET_CONTROLENTRY *widget)
 {
-	int template = choices[20].selected;
+	int templat = choices[20].selected;
 	int control = widget->controlindex;
 	int index = widget->highlighted;
       
-	RemoveInputState (template, control, index);
-	populate_editkeys (template);
+	RemoveInputState (templat, control, index);
+	populate_editkeys (templat);
 }	
 
+static int
+count_widgets (WIDGET **widgets)
+{
+	int count;
+
+	for (count = 0; *widgets != NULL; ++widgets, ++count)
+		;
+	return count;
+}
+
 static stringbank *bank = NULL;
 static FRAME setup_frame = NULL;
 
@@ -652,11 +824,15 @@ init_widgets (void)
 		menus[i].subtitle = buffer[i];
 		menus[i].bgStamp.origin.x = 0;
 		menus[i].bgStamp.origin.y = 0;
-		menus[i].bgStamp.frame = SetAbsFrameIndex (setup_frame, menu_bgs[i]);
-		menus[i].num_children = menu_sizes[i];
-		menus[i].child = menu_widgets[i];
+		menus[i].bgStamp.frame = SetAbsFrameIndex (setup_frame, menu_defs[i].bgIndex);
+		menus[i].num_children = count_widgets (menu_defs[i].widgets);
+		menus[i].child = menu_defs[i].widgets;
 		menus[i].highlighted = 0;
 	}
+	if (menu_defs[i].widgets != NULL)
+	{
+		log_add (log_Error, "Menu definition array has more items!");
+	}
 		
 	/* Options */
 	if (SplitString (GetStringAddress (SetAbsStringTableIndex (SetupTab, 2)), '\n', 100, buffer, bank) != CHOICE_COUNT)
@@ -774,6 +950,10 @@ init_widgets (void)
 		sliders[i].tooltip[1] = "";
 		sliders[i].tooltip[2] = "";
 	}
+	// gamma is a special case
+	sliders[3].step = 1;
+	sliders[3].handleEvent = gamma_HandleEventSlider;
+	sliders[3].draw_value = gamma_DrawValue;
 
 	for (i = 0; i < SLIDER_COUNT; i++)
 	{
@@ -1050,6 +1230,8 @@ SetupMenu (void)
 void
 GetGlobalOptions (GLOBALOPTS *opts)
 {
+	bool whichBound;
+
 	if (GfxFlags & TFB_GFXFLAGS_SCALE_BILINEAR) 
 	{
 		opts->scaler = OPTVAL_BILINEAR_SCALE;
@@ -1093,6 +1275,8 @@ GetGlobalOptions (GLOBALOPTS *opts)
 	/* These values are read in, but won't change during a run. */
 	opts->music3do = opt3doMusic ? OPTVAL_ENABLED : OPTVAL_DISABLED;
 	opts->musicremix = optRemixMusic ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->speech = optSpeech ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->keepaspect = optKeepAspectRatio ? OPTVAL_ENABLED : OPTVAL_DISABLED;
 	switch (snddriver) {
 	case audio_DRIVER_OPENAL:
 		opts->adriver = OPTVAL_OPENAL;
@@ -1195,13 +1379,22 @@ GetGlobalOptions (GLOBALOPTS *opts)
 		}
 	}
 
+	whichBound = (optGamma < maxGamma);
+	// The option supplied by the user may be beyond our starting range
+	// but valid nonetheless. We need to account for that.
+	if (optGamma <= minGamma)
+		minGamma = optGamma - 0.03f;
+	else if (optGamma >= maxGamma)
+		maxGamma = optGamma + 0.3f;
+	updateGammaBounds (whichBound);
+	opts->gamma = gammaToSlider (optGamma);
+
 	opts->player1 = PlayerControls[0];
 	opts->player2 = PlayerControls[1];
 
 	opts->musicvol = (((int)(musicVolumeScale * 100.0f) + 2) / 5) * 5;
 	opts->sfxvol = (((int)(sfxVolumeScale * 100.0f) + 2) / 5) * 5;
 	opts->speechvol = (((int)(speechVolumeScale * 100.0f) + 2) / 5) * 5;
-	
 }
 
 void
@@ -1304,15 +1497,27 @@ SetGlobalOptions (GLOBALOPTS *opts)
 		FlushGraphics ();
 		InitVideoPlayer (TRUE);
 	}
+
+	// Avoid setting gamma when it is not necessary
+	if (optGamma != 1.0f || sliderToGamma (opts->gamma) != 1.0f)
+	{
+		optGamma = sliderToGamma (opts->gamma);
+		setGammaCorrection (optGamma);
+	}
+
 	optSubtitles = (opts->subtitles == OPTVAL_ENABLED) ? TRUE : FALSE;
-	// optWhichMusic = (opts->music == OPTVAL_3DO) ? OPT_3DO : OPT_PC;
 	optWhichMenu = (opts->menu == OPTVAL_3DO) ? OPT_3DO : OPT_PC;
 	optWhichFonts = (opts->text == OPTVAL_3DO) ? OPT_3DO : OPT_PC;
 	optWhichCoarseScan = (opts->cscan == OPTVAL_3DO) ? OPT_3DO : OPT_PC;
 	optSmoothScroll = (opts->scroll == OPTVAL_3DO) ? OPT_3DO : OPT_PC;
 	optWhichShield = (opts->shield == OPTVAL_3DO) ? OPT_3DO : OPT_PC;
 	optMeleeScale = (opts->meleezoom == OPTVAL_3DO) ? TFB_SCALE_TRILINEAR : TFB_SCALE_STEP;
+	opt3doMusic = (opts->music3do == OPTVAL_ENABLED);
+	optRemixMusic = (opts->musicremix == OPTVAL_ENABLED);
+	optSpeech = (opts->speech == OPTVAL_ENABLED);
 	optWhichIntro = (opts->intro == OPTVAL_3DO) ? OPT_3DO : OPT_PC;
+	optStereoSFX = (opts->stereo == OPTVAL_ENABLED);
+	optKeepAspectRatio = (opts->keepaspect == OPTVAL_ENABLED);
 	PlayerControls[0] = opts->player1;
 	PlayerControls[1] = opts->player2;
 
@@ -1324,11 +1529,14 @@ SetGlobalOptions (GLOBALOPTS *opts)
 
 	res_PutBoolean ("config.3domusic", opts->music3do == OPTVAL_ENABLED);
 	res_PutBoolean ("config.remixmusic", opts->musicremix == OPTVAL_ENABLED);
+	res_PutBoolean ("config.speech", opts->speech == OPTVAL_ENABLED);
 	res_PutBoolean ("config.3domovies", opts->intro == OPTVAL_3DO);
 	res_PutBoolean ("config.showfps", opts->fps == OPTVAL_ENABLED);
 	res_PutBoolean ("config.smoothmelee", opts->meleezoom == OPTVAL_3DO);
 	res_PutBoolean ("config.positionalsfx", opts->stereo == OPTVAL_ENABLED); 
 	res_PutBoolean ("config.pulseshield", opts->shield == OPTVAL_3DO);
+	res_PutBoolean ("config.keepaspectratio", opts->keepaspect == OPTVAL_ENABLED);
+	res_PutInteger ("config.gamma", (int) (optGamma * GAMMA_SCALE + 0.5));
 	res_PutInteger ("config.player1control", opts->player1);
 	res_PutInteger ("config.player2control", opts->player2);
 
diff -ruNp src.orig/uqm/setupmenu.h src/uqm/setupmenu.h
--- src.orig/uqm/setupmenu.h	2017-11-21 19:39:40 -0600
+++ src/uqm/setupmenu.h	2017-11-21 19:39:57 -0600
@@ -21,6 +21,10 @@
 
 #include "controls.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef enum {
 	OPTVAL_DISABLED,
 	OPTVAL_ENABLED
@@ -74,10 +78,13 @@ typedef struct globalopts_struct {
 	OPT_DRIVERTYPE driver;
 	OPT_ADRIVERTYPE adriver;
 	OPT_AQUALITYTYPE aquality;
-	OPT_ENABLABLE fullscreen, subtitles, scanlines, fps, stereo, music3do, musicremix;
+	OPT_ENABLABLE fullscreen, subtitles, scanlines, fps, stereo;
+	OPT_ENABLABLE music3do, musicremix, speech;
+	OPT_ENABLABLE keepaspect;
 	OPT_CONSOLETYPE menu, text, cscan, scroll, intro, meleezoom, shield;
 	CONTROL_TEMPLATE player1, player2;
 	int speechvol, musicvol, sfxvol;
+	int gamma;
 } GLOBALOPTS;
 
 void SetupMenu (void);
@@ -85,4 +92,8 @@ void SetupMenu (void);
 void GetGlobalOptions (GLOBALOPTS *opts);
 void SetGlobalOptions (GLOBALOPTS *opts);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif // _SETUPMENU_H
diff -ruNp src.orig/uqm/ship.c src/uqm/ship.c
--- src.orig/uqm/ship.c	2017-11-21 19:39:40 -0600
+++ src/uqm/ship.c	2017-11-21 19:39:57 -0600
@@ -193,6 +193,9 @@ ship_preprocess (ELEMENT *ElementPtr)
 			if (RDPtr->preprocess_func)
 				(*RDPtr->preprocess_func) (ElementPtr);
 
+			// XXX: Hack: Pkunk sets hTarget!=0 when it reincarnates. In that
+			//   case there is no ship_transition() but a Phoenix transition
+			//   instead.
 			if (ElementPtr->hTarget == 0)
 			{
 				ship_transition (ElementPtr);
@@ -451,7 +454,7 @@ spawn_ship (STARSHIP *StarShipPtr)
 		else
 		{
 			StarShipPtr->ShipFacing = NORMALIZE_FACING (TFB_Random ());
-			if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+			if (inHQSpace ())
 			{	// Only one ship is ever spawned in HyperSpace -- flagship
 				COUNT facing = GLOBAL (ShipFacing);
 				// XXX: Solar system reentry test depends on ShipFacing != 0
diff -ruNp src.orig/uqm/ship.h src/uqm/ship.h
--- src.orig/uqm/ship.h	2017-11-21 19:39:40 -0600
+++ src/uqm/ship.h	2017-11-21 19:39:57 -0600
@@ -21,6 +21,10 @@
 #include "races.h"
 #include "element.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern BOOLEAN GetNextStarShip (STARSHIP *LastStarShipPtr, COUNT which_side);
 extern BOOLEAN GetInitialStarShips (void);
 
@@ -32,4 +36,8 @@ extern void collision (ELEMENT *ElementP
 
 extern STATUS_FLAGS inertial_thrust (ELEMENT *ElementPtr);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* UQM_SHIP_H_INCL_ */
diff -ruNp src.orig/uqm/shipcont.h src/uqm/shipcont.h
--- src.orig/uqm/shipcont.h	2017-11-21 19:39:40 -0600
+++ src/uqm/shipcont.h	2017-11-21 19:39:57 -0600
@@ -21,6 +21,10 @@
 
 #include "menustat.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #define FIELD_WIDTH (STATUS_WIDTH - 5)
 
 extern void CargoMenu (void);
@@ -33,5 +37,9 @@ extern void ShowRemainingCapacity (void)
 
 extern SIZE InventoryDevices (BYTE *pDeviceMap, COUNT Size);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _SHIPCONT_H */
 
diff -ruNp src.orig/uqm/ships/Makeinfo src/uqm/ships/Makeinfo
--- src.orig/uqm/ships/Makeinfo	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/Makeinfo	2017-11-21 19:39:58 -0600
@@ -2,3 +2,4 @@ uqm_SUBDIRS="androsyn arilou blackurq ch
 		lastbat melnorme mmrnmhrm mycon orz pkunk probe shofixti sis_ship
 		slylandr spathi supox syreen thradd umgah urquan utwig vux yehat
 		zoqfot"
+uqm_HFILES="ship.h"
diff -ruNp src.orig/uqm/ships/androsyn/Makeinfo src/uqm/ships/androsyn/Makeinfo
--- src.orig/uqm/ships/androsyn/Makeinfo	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/androsyn/Makeinfo	2017-11-21 19:39:57 -0600
@@ -1 +1,2 @@
 uqm_CFILES="androsyn.c"
+uqm_HFILES="androsyn.h icode.h resinst.h"
diff -ruNp src.orig/uqm/ships/androsyn/androsyn.c src/uqm/ships/androsyn/androsyn.c
--- src.orig/uqm/ships/androsyn/androsyn.c	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/androsyn/androsyn.c	2017-11-21 19:39:57 -0600
@@ -22,25 +22,42 @@
 
 #include "libs/mathlib.h"
 
-
+// Core characteristics
 #define MAX_CREW 20
 #define MAX_ENERGY 24
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 3
-#define SPECIAL_ENERGY_COST 2
 #define ENERGY_WAIT 8
 #define MAX_THRUST 24
 #define THRUST_INCREMENT 3
 #define TURN_WAIT 4
 #define THRUST_WAIT 0
+#define SHIP_MASS 6
+
+// Bubbles
+#define WEAPON_ENERGY_COST 3
 #define WEAPON_WAIT 0
-#define SPECIAL_WAIT 0
+#define ANDROSYNTH_OFFSET 14
+#define MISSILE_OFFSET 3
+#define MISSILE_SPEED DISPLAY_TO_WORLD (8)
+#define MISSILE_LIFE 200
+#define MISSILE_HITS 3
+#define MISSILE_DAMAGE 2
+#define TRACK_WAIT 2
 
-#define SHIP_MASS 6
+// Blazer
+#define SPECIAL_ENERGY_COST 2
+#define BLAZER_DEGENERATION (-1)
+#define SPECIAL_WAIT 0
+#define BLAZER_OFFSET 10
+#define BLAZER_THRUST 60
+#define BLAZER_TURN_WAIT 1
+#define BLAZER_DAMAGE 3
+#define BLAZER_MASS 1
 
 static RACE_DESC androsynth_desc =
 {
 	{ /* SHIP_INFO */
+		"guardian",
 		FIRES_FORE | SEEKING_WEAPON,
 		15, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -110,14 +127,49 @@ static RACE_DESC androsynth_desc =
 	0, /* CodeRef */
 };
 
-#define BLAZER_DAMAGE 3
-#define BLAZER_MASS 1
+
+// Private per-instance ship data
+typedef struct
+{
+	ElementCollisionFunc* collision_func;
+} ANDROSYNTH_DATA;
+
+// Local typedef
+typedef ANDROSYNTH_DATA CustomShipData_t;
+
+// Retrieve race-specific ship data from a race desc
+static CustomShipData_t *
+GetCustomShipData (RACE_DESC *pRaceDesc)
+{
+	return pRaceDesc->data;
+}
+
+// Set the race-specific data in a race desc
+// (Re)Allocates its own storage for the data.
+static void
+SetCustomShipData (RACE_DESC *pRaceDesc, const CustomShipData_t *data)
+{
+	if (pRaceDesc->data == data) 
+		return;  // no-op
+
+	if (pRaceDesc->data) // Out with the old
+	{
+		HFree (pRaceDesc->data);
+		pRaceDesc->data = NULL;
+	}
+
+	if (data) // In with the new
+	{
+		CustomShipData_t* newData = HMalloc (sizeof (*data));
+		*newData = *data;
+		pRaceDesc->data = newData;
+	}
+}
 
 static void
 blazer_collision (ELEMENT *ElementPtr0, POINT *pPt0,
 		ELEMENT *ElementPtr1, POINT *pPt1)
 {
-#define BLAZER_OFFSET 10
 	BYTE old_offs;
 	COUNT old_crew_level;
 	COUNT old_life;
@@ -137,8 +189,6 @@ blazer_collision (ELEMENT *ElementPtr0,
 	collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
 }
 
-#define MISSILE_SPEED DISPLAY_TO_WORLD (8)
-
 static void
 bubble_preprocess (ELEMENT *ElementPtr)
 {
@@ -174,23 +224,15 @@ bubble_preprocess (ELEMENT *ElementPtr)
 			facing -= (COUNT)TFB_Random () & (ANGLE_TO_FACING (HALF_CIRCLE) - 1);
 		SetVelocityVector (&ElementPtr->velocity,
 				MISSILE_SPEED, facing);
-
-#define TRACK_WAIT 2
 		turn_wait = TRACK_WAIT;
 	}
 
 	ElementPtr->turn_wait = MAKE_BYTE (turn_wait, thrust_wait);
 }
 
-#define MISSILE_DAMAGE 2
-#define MISSILE_LIFE 200
-
 static COUNT
 initialize_bubble (ELEMENT *ShipPtr, HELEMENT BubbleArray[])
 {
-#define ANDROSYNTH_OFFSET 14
-#define MISSILE_OFFSET 3
-#define MISSILE_HITS 3
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -324,8 +366,6 @@ androsynth_intelligence (ELEMENT *ShipPt
 	}
 }
 
-#define BLAZER_TURN_WAIT 1
-
 static void
 androsynth_postprocess (ELEMENT *ElementPtr)
 {
@@ -335,7 +375,6 @@ androsynth_postprocess (ELEMENT *Element
 			/* take care of blazer effect */
 	if (ElementPtr->next.image.farray == StarShipPtr->RaceDescPtr->ship_data.special)
 	{
-#define BLAZER_DEGENERATION (-1)
 		if ((StarShipPtr->cur_status_flags & SPECIAL)
 				|| StarShipPtr->RaceDescPtr->ship_info.energy_level == 0)
 		{
@@ -355,11 +394,14 @@ androsynth_postprocess (ELEMENT *Element
 				ElementPtr->mass_points = BLAZER_MASS;
 				StarShipPtr->RaceDescPtr->characteristics.turn_wait
 						= BLAZER_TURN_WAIT;
+
 				/* Save the current collision func because we were not the
 				 * ones who set it */
-				StarShipPtr->RaceDescPtr->data = (intptr_t)
-						ElementPtr->collision_func;
-				ElementPtr->collision_func = blazer_collision;
+				{
+					const ANDROSYNTH_DATA shipData = { ElementPtr->collision_func };
+					SetCustomShipData (StarShipPtr->RaceDescPtr, &shipData);
+					ElementPtr->collision_func = blazer_collision;
+				}
 			}
 		}
 
@@ -426,8 +468,8 @@ androsynth_preprocess (ELEMENT *ElementP
 					StarShipPtr->RaceDescPtr->characteristics.special_wait;
 			StarShipPtr->RaceDescPtr->characteristics.energy_regeneration = ENERGY_REGENERATION;
 			ElementPtr->mass_points = SHIP_MASS;
-			ElementPtr->collision_func = (CollisionFunc *)
-					StarShipPtr->RaceDescPtr->data;
+			ElementPtr->collision_func = 
+					GetCustomShipData (StarShipPtr->RaceDescPtr)->collision_func;
 			ElementPtr->next.image.farray =
 					StarShipPtr->RaceDescPtr->ship_data.ship;
 			ElementPtr->next.image.frame =
@@ -441,7 +483,6 @@ androsynth_preprocess (ELEMENT *ElementP
 				--ElementPtr->thrust_wait;
 			else
 			{
-#define BLAZER_THRUST 60
 				COUNT facing;
 
 				facing = StarShipPtr->ShipFacing;
@@ -463,11 +504,19 @@ androsynth_preprocess (ELEMENT *ElementP
 	StarShipPtr->cur_status_flags = cur_status_flags;
 }
 
+static void
+uninit_androsynth (RACE_DESC *pRaceDesc)
+{
+	SetCustomShipData (pRaceDesc, NULL);
+}
+
+
 RACE_DESC*
 init_androsynth (void)
 {
 	RACE_DESC *RaceDescPtr;
 
+	androsynth_desc.uninit_func = uninit_androsynth;
 	androsynth_desc.preprocess_func = androsynth_preprocess;
 	androsynth_desc.postprocess_func = androsynth_postprocess;
 	androsynth_desc.init_weapon_func = initialize_bubble;
diff -ruNp src.orig/uqm/ships/androsyn/androsyn.h src/uqm/ships/androsyn/androsyn.h
--- src.orig/uqm/ships/androsyn/androsyn.h	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/androsyn/androsyn.h	2017-11-21 19:39:57 -0600
@@ -17,7 +17,15 @@
 #ifndef ANDROSYN_H
 #define ANDROSYN_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_androsynth (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* ANDROSYN_H */
 
diff -ruNp src.orig/uqm/ships/androsyn/icode.h src/uqm/ships/androsyn/icode.h
--- src.orig/uqm/ships/androsyn/icode.h	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/androsyn/icode.h	2017-11-21 19:39:57 -0600
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define ANDROSYNTH_CODE "ship.androsynth.code"
diff -ruNp src.orig/uqm/ships/androsyn/resinst.h src/uqm/ships/androsyn/resinst.h
--- src.orig/uqm/ships/androsyn/resinst.h	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/androsyn/resinst.h	2017-11-21 19:39:57 -0600
@@ -1,17 +1,19 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define ANDROSYNTH_BIG_MASK_PMAP_ANIM "ship.androsynth.graphics.guardian.large"
 #define ANDROSYNTH_CAPT_MASK_PMAP_ANIM "ship.androsynth.graphics.captain"
 #define ANDROSYNTH_ICON_MASK_PMAP_ANIM "ship.androsynth.icons"
 #define ANDROSYNTH_MED_MASK_PMAP_ANIM "ship.androsynth.graphics.guardian.medium"
 #define ANDROSYNTH_MICON_MASK_PMAP_ANIM "ship.androsynth.meleeicons"
+#define ANDROSYNTH_RACE_STRINGS "ship.androsynth.text"
+#define ANDROSYNTH_SHIP_SOUNDS "ship.androsynth.sounds"
 #define ANDROSYNTH_SML_MASK_PMAP_ANIM "ship.androsynth.graphics.guardian.small"
+#define ANDROSYNTH_VICTORY_SONG "ship.androsynth.ditty"
 #define BLAZER_BIG_MASK_PMAP_ANIM "ship.androsynth.graphics.blazer.large"
 #define BLAZER_MED_MASK_PMAP_ANIM "ship.androsynth.graphics.blazer.medium"
 #define BLAZER_SML_MASK_PMAP_ANIM "ship.androsynth.graphics.blazer.small"
 #define BUBBLE_BIG_MASK_PMAP_ANIM "ship.androsynth.graphics.bubble.large"
 #define BUBBLE_MED_MASK_PMAP_ANIM "ship.androsynth.graphics.bubble.medium"
 #define BUBBLE_SML_MASK_PMAP_ANIM "ship.androsynth.graphics.bubble.small"
-#define ANDROSYNTH_RACE_STRINGS "ship.androsynth.text"
-#define ANDROSYNTH_SHIP_SOUNDS "ship.androsynth.sounds"
-#define ANDROSYNTH_VICTORY_SONG "ship.androsynth.ditty"
-
-#include "icode.h"
diff -ruNp src.orig/uqm/ships/arilou/Makeinfo src/uqm/ships/arilou/Makeinfo
--- src.orig/uqm/ships/arilou/Makeinfo	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/arilou/Makeinfo	2017-11-21 19:39:57 -0600
@@ -1 +1,2 @@
 uqm_CFILES="arilou.c"
+uqm_HFILES="arilou.h icode.h resinst.h"
diff -ruNp src.orig/uqm/ships/arilou/arilou.c src/uqm/ships/arilou/arilou.c
--- src.orig/uqm/ships/arilou/arilou.c	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/arilou/arilou.c	2017-11-21 19:39:57 -0600
@@ -22,27 +22,32 @@
 
 #include "libs/mathlib.h"
 
-
+// Core characteristics
 #define MAX_CREW 6
 #define MAX_ENERGY 20
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 2
-#define SPECIAL_ENERGY_COST 3
 #define ENERGY_WAIT 6
 #define MAX_THRUST /* DISPLAY_TO_WORLD (10) */ 40
 #define THRUST_INCREMENT MAX_THRUST
-#define TURN_WAIT 0
 #define THRUST_WAIT 0
-#define WEAPON_WAIT 1
-#define SPECIAL_WAIT 2
-
+#define TURN_WAIT 0
 #define SHIP_MASS 1
+
+// Tracking Laser
+#define WEAPON_ENERGY_COST 2
+#define WEAPON_WAIT 1
 #define ARILOU_OFFSET 9
 #define LASER_RANGE DISPLAY_TO_WORLD (100 + ARILOU_OFFSET)
 
+// Teleporter
+#define SPECIAL_ENERGY_COST 3
+#define SPECIAL_WAIT 2
+#define HYPER_LIFE 5
+
 static RACE_DESC arilou_desc =
 {
 	{ /* SHIP_INFO */
+		"skiff",
 		/* FIRES_FORE | */ IMMEDIATE_WEAPON,
 		16, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -209,7 +214,6 @@ arilou_preprocess (ELEMENT *ElementPtr)
 				&& DeltaEnergy (ElementPtr, -SPECIAL_ENERGY_COST))
 		{
 			/* Special key is pressed; start teleport */
-#define HYPER_LIFE 5
 			ZeroVelocityComponents (&ElementPtr->velocity);
 			StarShipPtr->cur_status_flags &=
 					~(SHIP_AT_MAX_SPEED | LEFT | RIGHT | THRUST | WEAPON);
diff -ruNp src.orig/uqm/ships/arilou/arilou.h src/uqm/ships/arilou/arilou.h
--- src.orig/uqm/ships/arilou/arilou.h	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/arilou/arilou.h	2017-11-21 19:39:57 -0600
@@ -17,7 +17,15 @@
 #ifndef ARILOU_H
 #define ARILOU_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_arilou (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* ARILOU_H */
 
diff -ruNp src.orig/uqm/ships/arilou/icode.h src/uqm/ships/arilou/icode.h
--- src.orig/uqm/ships/arilou/icode.h	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/arilou/icode.h	2017-11-21 19:39:57 -0600
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define ARILOU_CODE "ship.arilou.code"
diff -ruNp src.orig/uqm/ships/arilou/resinst.h src/uqm/ships/arilou/resinst.h
--- src.orig/uqm/ships/arilou/resinst.h	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/arilou/resinst.h	2017-11-21 19:39:57 -0600
@@ -1,14 +1,16 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define ARILOU_BIG_MASK_PMAP_ANIM "ship.arilou.graphics.skiff.large"
 #define ARILOU_CAPTAIN_MASK_PMAP_ANIM "ship.arilou.graphics.captain"
 #define ARILOU_ICON_MASK_PMAP_ANIM "ship.arilou.icons"
 #define ARILOU_MED_MASK_PMAP_ANIM "ship.arilou.graphics.skiff.medium"
 #define ARILOU_MICON_MASK_PMAP_ANIM "ship.arilou.meleeicons"
+#define ARILOU_RACE_STRINGS "ship.arilou.text"
+#define ARILOU_SHIP_SOUNDS "ship.arilou.sounds"
 #define ARILOU_SML_MASK_PMAP_ANIM "ship.arilou.graphics.skiff.small"
+#define ARILOU_VICTORY_SONG "ship.arilou.ditty"
 #define WARP_BIG_MASK_PMAP_ANIM "ship.arilou.graphics.warp.large"
 #define WARP_MED_MASK_PMAP_ANIM "ship.arilou.graphics.warp.medium"
 #define WARP_SML_MASK_PMAP_ANIM "ship.arilou.graphics.warp.small"
-#define ARILOU_RACE_STRINGS "ship.arilou.text"
-#define ARILOU_SHIP_SOUNDS "ship.arilou.sounds"
-#define ARILOU_VICTORY_SONG "ship.arilou.ditty"
-
-#include "icode.h"
diff -ruNp src.orig/uqm/ships/blackurq/Makeinfo src/uqm/ships/blackurq/Makeinfo
--- src.orig/uqm/ships/blackurq/Makeinfo	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/blackurq/Makeinfo	2017-11-21 19:39:57 -0600
@@ -1 +1,2 @@
 uqm_CFILES="blackurq.c"
+uqm_HFILES="blackurq.h icode.h resinst.h"
diff -ruNp src.orig/uqm/ships/blackurq/blackurq.c src/uqm/ships/blackurq/blackurq.c
--- src.orig/uqm/ships/blackurq/blackurq.c	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/blackurq/blackurq.c	2017-11-21 19:39:57 -0600
@@ -22,29 +22,53 @@
 
 #include "uqm/globdata.h"
 
-
+// Core characteristics
 #define MAX_CREW MAX_CREW_SIZE
 #define MAX_ENERGY MAX_ENERGY_SIZE
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 6
-#define SPECIAL_ENERGY_COST (MAX_ENERGY_SIZE / 2)
 #define ENERGY_WAIT 4
 #define MAX_THRUST 30
 #define THRUST_INCREMENT 6
 #define TURN_WAIT 4
 #define THRUST_WAIT 6
-#define WEAPON_WAIT 6
-#define SPECIAL_WAIT 9
-
 #define SHIP_MASS 10
+
+// Buzzsaw
+#define WEAPON_ENERGY_COST 6
+#define WEAPON_WAIT 6
+#define MISSILE_OFFSET 9
+#define KOHR_AH_OFFSET 28
 #define MISSILE_SPEED 64
-#define MISSILE_LIFE 64 /* actually, it's as long as you
-										 * hold the button down.
-										 */
+#define MISSILE_LIFE 64
+		/* actually, it's as long as you hold the button down.*/
+#define MISSILE_HITS 10
+#define MISSILE_DAMAGE 4
+#define SAW_RATE 0
+#define MAX_SAWS 8
+#define ACTIVATE_RANGE 224
+		/* Originally SPACE_WIDTH - the distance within which
+		 * stationary sawblades will home */
+#define TRACK_WAIT 4
+#define FRAGMENT_SPEED MISSILE_SPEED
+#define FRAGMENT_LIFE 10
+#define FRAGMENT_RANGE (FRAGMENT_LIFE * FRAGMENT_SPEED)
+
+// F.R.I.E.D.
+#define SPECIAL_ENERGY_COST (MAX_ENERGY_SIZE / 2)
+#define SPECIAL_WAIT 9
+#define GAS_OFFSET 2
+#define GAS_SPEED 16
+#define GAS_RATE 2 /* Controls animation of the gas cloud decay - the decay
+                    * animation advances one frame every GAS_RATE frames. */
+#define GAS_HITS 100
+#define GAS_DAMAGE 3
+#define GAS_ALT_DAMAGE 50
+#define NUM_GAS_CLOUDS 16
 
 static RACE_DESC black_urquan_desc =
 {
 	{ /* SHIP_INFO */
+		"marauder",
 		FIRES_FORE,
 		30, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -113,9 +137,6 @@ static RACE_DESC black_urquan_desc =
 	0, /* CodeRef */
 };
 
-#define SAW_RATE 0
-#define MAX_SAWS 8
-
 static void
 spin_preprocess (ELEMENT *ElementPtr)
 {
@@ -154,8 +175,6 @@ spin_preprocess (ELEMENT *ElementPtr)
 	UnlockElement (StarShipPtr->hShip);
 }
 
-#define TRACK_WAIT 4
-
 static void
 buzztrack_preprocess (ELEMENT *ElementPtr)
 {
@@ -172,7 +191,6 @@ buzztrack_preprocess (ELEMENT *ElementPt
 		}
 		else
 		{
-#define ACTIVATE_RANGE 224 /* Originally SPACE_WIDTH */
 			SIZE delta_x, delta_y;
 			ELEMENT *eptr;
 
@@ -311,10 +329,6 @@ buzzsaw_postprocess (ELEMENT *ElementPtr
 static COUNT
 initialize_buzzsaw (ELEMENT *ShipPtr, HELEMENT SawArray[])
 {
-#define MISSILE_HITS 10
-#define MISSILE_DAMAGE 4
-#define MISSILE_OFFSET 9
-#define KOHR_AH_OFFSET 28
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -379,9 +393,6 @@ black_urquan_intelligence (ELEMENT *Ship
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
 	if (lpEvalDesc->ObjectPtr)
 	{
-#define FRAGMENT_LIFE 10
-#define FRAGMENT_SPEED MISSILE_SPEED
-#define FRAGMENT_RANGE (FRAGMENT_LIFE * FRAGMENT_SPEED)
 		HELEMENT h, hNext;
 		ELEMENT *BuzzSawPtr;
 
@@ -433,8 +444,6 @@ black_urquan_intelligence (ELEMENT *Ship
 	}
 }
 
-#define GAS_RATE 2
-
 static void
 gas_cloud_preprocess (ELEMENT *ElementPtr)
 {
@@ -450,8 +459,6 @@ gas_cloud_preprocess (ELEMENT *ElementPt
 	}
 }
 
-#define GAS_DAMAGE 3
-
 static void
 gas_cloud_collision (ELEMENT *ElementPtr0, POINT *pPt0,
 		ELEMENT *ElementPtr1, POINT *pPt1)
@@ -459,7 +466,7 @@ gas_cloud_collision (ELEMENT *ElementPtr
 	if (ElementPtr1->state_flags & PLAYER_SHIP)
 		ElementPtr0->mass_points = GAS_DAMAGE;
 	else
-		ElementPtr0->mass_points = 50;
+		ElementPtr0->mass_points = GAS_ALT_DAMAGE;
 
 	weapon_collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
 }
@@ -467,10 +474,6 @@ gas_cloud_collision (ELEMENT *ElementPtr
 static void
 spawn_gas_cloud (ELEMENT *ElementPtr)
 {
-#define GAS_SPEED 16
-#define GAS_HITS 100
-#define GAS_OFFSET 2
-#define NUM_GAS_CLOUDS 16
 	SIZE dx, dy;
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
diff -ruNp src.orig/uqm/ships/blackurq/blackurq.h src/uqm/ships/blackurq/blackurq.h
--- src.orig/uqm/ships/blackurq/blackurq.h	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/blackurq/blackurq.h	2017-11-21 19:39:57 -0600
@@ -17,7 +17,15 @@
 #ifndef BLACKURQ_H
 #define BLACKURQ_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_black_urquan (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* BLACKURQ_H */
 
diff -ruNp src.orig/uqm/ships/blackurq/icode.h src/uqm/ships/blackurq/icode.h
--- src.orig/uqm/ships/blackurq/icode.h	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/blackurq/icode.h	2017-11-21 19:39:57 -0600
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define KOHR_AH_CODE "ship.kohrah.code"
diff -ruNp src.orig/uqm/ships/blackurq/resinst.h src/uqm/ships/blackurq/resinst.h
--- src.orig/uqm/ships/blackurq/resinst.h	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/blackurq/resinst.h	2017-11-21 19:39:57 -0600
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define BUZZSAW_BIG_MASK_PMAP_ANIM "ship.kohrah.graphics.buzzsaw.large"
 #define BUZZSAW_MED_MASK_PMAP_ANIM "ship.kohrah.graphics.buzzsaw.medium"
 #define BUZZSAW_SML_MASK_PMAP_ANIM "ship.kohrah.graphics.buzzsaw.small"
@@ -9,9 +13,7 @@
 #define KOHR_AH_ICON_MASK_PMAP_ANIM "ship.kohrah.icons"
 #define KOHR_AH_MED_MASK_PMAP_ANIM "ship.kohrah.graphics.marauder.medium"
 #define KOHR_AH_MICON_MASK_PMAP_ANIM "ship.kohrah.meleeicons"
-#define KOHR_AH_SML_MASK_PMAP_ANIM "ship.kohrah.graphics.marauder.small"
 #define KOHR_AH_RACE_STRINGS "ship.kohrah.text"
 #define KOHR_AH_SHIP_SOUNDS "ship.kohrah.sounds"
+#define KOHR_AH_SML_MASK_PMAP_ANIM "ship.kohrah.graphics.marauder.small"
 #define KOHR_AH_VICTORY_SONG "ship.kohrah.ditty"
-
-#include "icode.h"
diff -ruNp src.orig/uqm/ships/chenjesu/Makeinfo src/uqm/ships/chenjesu/Makeinfo
--- src.orig/uqm/ships/chenjesu/Makeinfo	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/chenjesu/Makeinfo	2017-11-21 19:39:58 -0600
@@ -1 +1,2 @@
 uqm_CFILES="chenjesu.c"
+uqm_HFILES="chenjesu.h icode.h resinst.h"
diff -ruNp src.orig/uqm/ships/chenjesu/chenjesu.c src/uqm/ships/chenjesu/chenjesu.c
--- src.orig/uqm/ships/chenjesu/chenjesu.c	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/chenjesu/chenjesu.c	2017-11-21 19:39:57 -0600
@@ -23,31 +23,53 @@
 #include "uqm/globdata.h"
 #include "libs/mathlib.h"
 
-
+// Core characteristics
 #define MAX_CREW 36
 #define MAX_ENERGY 30
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 5
-#define SPECIAL_ENERGY_COST MAX_ENERGY
 #define ENERGY_WAIT 4
 #define MAX_THRUST /* DISPLAY_TO_WORLD (7) */ 27
 #define THRUST_INCREMENT /* DISPLAY_TO_WORLD (2) */ 3
-#define TURN_WAIT 6
 #define THRUST_WAIT 4
+#define TURN_WAIT 6
+#define SHIP_MASS 10
+
+// Photon Shard
+#define WEAPON_ENERGY_COST 5
 #define WEAPON_WAIT 0
-#define SPECIAL_WAIT 0
+#define CHENJESU_OFFSET 16
+#define MISSILE_OFFSET 0
+#define MISSILE_SPEED DISPLAY_TO_WORLD (16)
+#define MISSILE_LIFE 90
+		/* actually, it's as long as you hold the button down. */
+#define MISSILE_HITS 10
+#define MISSILE_DAMAGE 6
+#define NUM_SPARKLES 8
 
-#define MAX_DOGGIES 4
+// Shrapnel
+#define FRAGMENT_OFFSET 2
+#define NUM_FRAGMENTS 8
+#define FRAGMENT_LIFE 10
+#define FRAGMENT_SPEED MISSILE_SPEED
+#define FRAGMENT_RANGE (FRAGMENT_LIFE * FRAGMENT_SPEED)
+		/* This bit is for the cyborg only. */
+#define FRAGMENT_HITS 1
+#define FRAGMENT_DAMAGE 2
 
-#define SHIP_MASS 10
-#define MISSILE_SPEED DISPLAY_TO_WORLD (16)
-#define MISSILE_LIFE 90 /* actually, it's as long as you
-										 * hold the button down.
-										 */
+// DOGI
+#define SPECIAL_ENERGY_COST MAX_ENERGY
+#define SPECIAL_WAIT 0
+#define DOGGY_OFFSET 18
+#define DOGGY_SPEED DISPLAY_TO_WORLD (8)
+#define ENERGY_DRAIN 10
+#define MAX_DOGGIES 4
+#define DOGGY_HITS 3
+#define DOGGY_MASS 4
 
 static RACE_DESC chenjesu_desc =
 {
 	{ /* SHIP_INFO */
+		"broodhome",
 		FIRES_FORE | SEEKING_SPECIAL | SEEKING_WEAPON,
 		28, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -116,17 +138,9 @@ static RACE_DESC chenjesu_desc =
 	0, /* CodeRef */
 };
 
-#define FRAGMENT_LIFE 10
-#define FRAGMENT_SPEED MISSILE_SPEED
-#define FRAGMENT_RANGE (FRAGMENT_LIFE * FRAGMENT_SPEED)
-
 static void
 crystal_postprocess (ELEMENT *ElementPtr)
 {
-#define FRAGMENT_HITS 1
-#define FRAGMENT_DAMAGE 2
-#define FRAGMENT_OFFSET 2
-#define NUM_FRAGMENTS 8
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -212,7 +226,6 @@ crystal_collision (ELEMENT *ElementPtr0,
 	{
 		ELEMENT *BlastElementPtr;
 
-#define NUM_SPARKLES 8
 		LockElement (hBlastElement, &BlastElementPtr);
 		BlastElementPtr->current.location = ElementPtr1->current.location;
 
@@ -231,9 +244,6 @@ crystal_collision (ELEMENT *ElementPtr0,
 	}
 }
 
-#define DOGGY_OFFSET 18
-#define DOGGY_SPEED DISPLAY_TO_WORLD (8)
-
 static void
 doggy_preprocess (ELEMENT *ElementPtr)
 {
@@ -314,7 +324,6 @@ static void
 doggy_collision (ELEMENT *ElementPtr0, POINT *pPt0,
 		ELEMENT *ElementPtr1, POINT *pPt1)
 {
-#define ENERGY_DRAIN 10
 	collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
 	if ((ElementPtr1->state_flags & PLAYER_SHIP)
 			&& !elementsOfSamePlayer (ElementPtr0, ElementPtr1))
@@ -335,8 +344,6 @@ doggy_collision (ELEMENT *ElementPtr0, P
 		ElementPtr0->thrust_wait += COLLISION_THRUST_WAIT << 1;
 }
 
-#define CHENJESU_OFFSET 16
-
 static void
 spawn_doggy (ELEMENT *ElementPtr)
 {
@@ -352,8 +359,8 @@ spawn_doggy (ELEMENT *ElementPtr)
 
 		PutElement (hDoggyElement);
 		LockElement (hDoggyElement, &DoggyElementPtr);
-		DoggyElementPtr->hit_points = 3;
-		DoggyElementPtr->mass_points = 4;
+		DoggyElementPtr->hit_points = DOGGY_HITS;
+		DoggyElementPtr->mass_points = DOGGY_MASS;
 		DoggyElementPtr->thrust_wait = 0;
 		DoggyElementPtr->playerNr = ElementPtr->playerNr;
 		DoggyElementPtr->state_flags = APPEARING;
@@ -499,9 +506,6 @@ chenjesu_intelligence (ELEMENT *ShipPtr,
 static COUNT
 initialize_crystal (ELEMENT *ShipPtr, HELEMENT CrystalArray[])
 {
-#define MISSILE_HITS 10
-#define MISSILE_DAMAGE 6
-#define MISSILE_OFFSET 0
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
diff -ruNp src.orig/uqm/ships/chenjesu/chenjesu.h src/uqm/ships/chenjesu/chenjesu.h
--- src.orig/uqm/ships/chenjesu/chenjesu.h	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/chenjesu/chenjesu.h	2017-11-21 19:39:57 -0600
@@ -17,7 +17,15 @@
 #ifndef CHENJESU_H
 #define CHENJESU_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_chenjesu (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* CHENJESU_H */
 
diff -ruNp src.orig/uqm/ships/chenjesu/icode.h src/uqm/ships/chenjesu/icode.h
--- src.orig/uqm/ships/chenjesu/icode.h	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/chenjesu/icode.h	2017-11-21 19:39:58 -0600
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define CHENJESU_CODE "ship.chenjesu.code"
diff -ruNp src.orig/uqm/ships/chenjesu/resinst.h src/uqm/ships/chenjesu/resinst.h
--- src.orig/uqm/ships/chenjesu/resinst.h	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/chenjesu/resinst.h	2017-11-21 19:39:58 -0600
@@ -1,17 +1,19 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define CHENJESU_BIG_MASK_PMAP_ANIM "ship.chenjesu.graphics.broodhome.large"
 #define CHENJESU_CAPTAIN_MASK_PMAP_ANIM "ship.chenjesu.graphics.captain"
 #define CHENJESU_ICON_MASK_PMAP_ANIM "ship.chenjesu.icons"
 #define CHENJESU_MED_MASK_PMAP_ANIM "ship.chenjesu.graphics.broodhome.medium"
 #define CHENJESU_MICON_MASK_PMAP_ANIM "ship.chenjesu.meleeicons"
+#define CHENJESU_RACE_STRINGS "ship.chenjesu.text"
+#define CHENJESU_SHIP_SOUNDS "ship.chenjesu.sounds"
 #define CHENJESU_SML_MASK_PMAP_ANIM "ship.chenjesu.graphics.broodhome.small"
+#define CHENJESU_VICTORY_SONG "ship.chenjesu.ditty"
 #define DOGGY_BIG_MASK_PMAP_ANIM "ship.chenjesu.graphics.doggy.large"
 #define DOGGY_MED_MASK_PMAP_ANIM "ship.chenjesu.graphics.doggy.medium"
 #define DOGGY_SML_MASK_PMAP_ANIM "ship.chenjesu.graphics.doggy.small"
 #define SPARK_BIG_MASK_PMAP_ANIM "ship.chenjesu.graphics.spark.large"
 #define SPARK_MED_MASK_PMAP_ANIM "ship.chenjesu.graphics.spark.medium"
 #define SPARK_SML_MASK_PMAP_ANIM "ship.chenjesu.graphics.spark.small"
-#define CHENJESU_RACE_STRINGS "ship.chenjesu.text"
-#define CHENJESU_SHIP_SOUNDS "ship.chenjesu.sounds"
-#define CHENJESU_VICTORY_SONG "ship.chenjesu.ditty"
-
-#include "icode.h"
diff -ruNp src.orig/uqm/ships/chmmr/Makeinfo src/uqm/ships/chmmr/Makeinfo
--- src.orig/uqm/ships/chmmr/Makeinfo	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/chmmr/Makeinfo	2017-11-21 19:39:58 -0600
@@ -1 +1,2 @@
 uqm_CFILES="chmmr.c"
+uqm_HFILES="chmmr.h icode.h resinst.h"
diff -ruNp src.orig/uqm/ships/chmmr/chmmr.c src/uqm/ships/chmmr/chmmr.c
--- src.orig/uqm/ships/chmmr/chmmr.c	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/chmmr/chmmr.c	2017-11-21 19:39:58 -0600
@@ -24,27 +24,41 @@
 #include "uqm/globdata.h"
 #include "libs/mathlib.h"
 
-
+// Core characteristics
 #define MAX_CREW MAX_CREW_SIZE
 #define MAX_ENERGY MAX_ENERGY_SIZE
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 2
-#define SPECIAL_ENERGY_COST 1
 #define ENERGY_WAIT 1
 #define MAX_THRUST 35
 #define THRUST_INCREMENT 7
-#define TURN_WAIT 3
 #define THRUST_WAIT 5
-#define WEAPON_WAIT 0
-#define SPECIAL_WAIT 0
-
+#define TURN_WAIT 3
 #define SHIP_MASS 10
+
+// Laser
+#define WEAPON_ENERGY_COST 2
+#define WEAPON_WAIT 0
 #define CHMMR_OFFSET 18
 #define LASER_RANGE DISPLAY_TO_WORLD (150)
+#define NUM_CYCLES 4
+
+// Tractor Beam
+#define SPECIAL_ENERGY_COST 1
+#define SPECIAL_WAIT 0
+#define NUM_SHADOWS 5
+
+// Satellites
+#define NUM_SATELLITES 3
+#define SATELLITE_OFFSET DISPLAY_TO_WORLD (64)
+#define SATELLITE_HITPOINTS 10
+#define SATELLITE_MASS 10
+#define DEFENSE_RANGE (UWORD)64
+#define DEFENSE_WAIT 2
 
 static RACE_DESC chmmr_desc =
 {
 	{ /* SHIP_INFO */
+		"avatar",
 		FIRES_FORE | IMMEDIATE_WEAPON | SEEKING_SPECIAL | POINT_DEFENSE,
 		30, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -202,7 +216,6 @@ laser_death (ELEMENT *ElementPtr)
 static COUNT
 initialize_megawatt_laser (ELEMENT *ShipPtr, HELEMENT LaserArray[])
 {
-#define NUM_CYCLES 4
 	RECT r;
 	STARSHIP *StarShipPtr;
 	LASER_BLOCK LaserBlock;
@@ -337,8 +350,6 @@ chmmr_postprocess (ELEMENT *ElementPtr)
 		facing = 0;
 		if (TrackShip (ElementPtr, &facing) >= 0)
 		{
-#define NUM_SHADOWS 5
-					
 			ELEMENT *ShipElementPtr;
 
 			LockElement (ElementPtr->hTarget, &ShipElementPtr);
@@ -444,8 +455,6 @@ chmmr_postprocess (ELEMENT *ElementPtr)
 	StarShipPtr->special_counter = 0;
 }
 
-#define SATELLITE_OFFSET DISPLAY_TO_WORLD (64)
-
 static void
 satellite_preprocess (ELEMENT *ElementPtr)
 {
@@ -502,8 +511,6 @@ satellite_preprocess (ELEMENT *ElementPt
 static void
 spawn_point_defense (ELEMENT *ElementPtr)
 {
-#define DEFENSE_RANGE (UWORD)64
-#define DEFENSE_WAIT 2
 	BYTE weakest;
 	UWORD best_dist;
 	STARSHIP *StarShipPtr;
@@ -674,7 +681,6 @@ satellite_death (ELEMENT *ElementPtr)
 static void
 spawn_satellites (ELEMENT *ElementPtr)
 {
-#define NUM_SATELLITES 3
 	COUNT i;
 	STARSHIP *StarShipPtr;
 
@@ -697,8 +703,8 @@ spawn_satellites (ELEMENT *ElementPtr)
 				SattPtr->state_flags = IGNORE_SIMILAR | APPEARING
 						| FINITE_LIFE;
 				SattPtr->life_span = NORMAL_LIFE + 1;
-				SattPtr->hit_points = 10;
-				SattPtr->mass_points = 10;
+				SattPtr->hit_points = SATELLITE_HITPOINTS;
+				SattPtr->mass_points = SATELLITE_MASS;
 
 				angle = (i * FULL_CIRCLE + (NUM_SATELLITES >> 1))
 						/ NUM_SATELLITES;
diff -ruNp src.orig/uqm/ships/chmmr/chmmr.h src/uqm/ships/chmmr/chmmr.h
--- src.orig/uqm/ships/chmmr/chmmr.h	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/chmmr/chmmr.h	2017-11-21 19:39:58 -0600
@@ -17,7 +17,15 @@
 #ifndef CHMMR_H
 #define CHMMR_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_chmmr (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* CHMMR_H */
 
diff -ruNp src.orig/uqm/ships/chmmr/icode.h src/uqm/ships/chmmr/icode.h
--- src.orig/uqm/ships/chmmr/icode.h	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/chmmr/icode.h	2017-11-21 19:39:58 -0600
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define CHMMR_CODE "ship.chmmr.code"
diff -ruNp src.orig/uqm/ships/chmmr/resinst.h src/uqm/ships/chmmr/resinst.h
--- src.orig/uqm/ships/chmmr/resinst.h	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/chmmr/resinst.h	2017-11-21 19:39:58 -0600
@@ -1,17 +1,19 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define CHMMR_BIG_MASK_PMAP_ANIM "ship.chmmr.graphics.avatar.large"
 #define CHMMR_CAPTAIN_MASK_PMAP_ANIM "ship.chmmr.graphics.captain"
 #define CHMMR_ICON_MASK_PMAP_ANIM "ship.chmmr.icons"
 #define CHMMR_MED_MASK_PMAP_ANIM "ship.chmmr.graphics.avatar.medium"
 #define CHMMR_MICON_MASK_PMAP_ANIM "ship.chmmr.meleeicons"
+#define CHMMR_RACE_STRINGS "ship.chmmr.text"
+#define CHMMR_SHIP_SOUNDS "ship.chmmr.sounds"
 #define CHMMR_SML_MASK_PMAP_ANIM "ship.chmmr.graphics.avatar.small"
+#define CHMMR_VICTORY_SONG "ship.chmmr.ditty"
 #define MUZZLE_BIG_MASK_PMAP_ANIM "ship.chmmr.graphics.muzzle.large"
 #define MUZZLE_MED_MASK_PMAP_ANIM "ship.chmmr.graphics.muzzle.medium"
 #define MUZZLE_SML_MASK_PMAP_ANIM "ship.chmmr.graphics.muzzle.small"
 #define SATELLITE_BIG_MASK_PMAP_ANIM "ship.chmmr.graphics.satellite.large"
 #define SATELLITE_MED_MASK_PMAP_ANIM "ship.chmmr.graphics.satellite.medium"
 #define SATELLITE_SML_MASK_PMAP_ANIM "ship.chmmr.graphics.satellite.small"
-#define CHMMR_RACE_STRINGS "ship.chmmr.text"
-#define CHMMR_SHIP_SOUNDS "ship.chmmr.sounds"
-#define CHMMR_VICTORY_SONG "ship.chmmr.ditty"
-
-#include "icode.h"
diff -ruNp src.orig/uqm/ships/druuge/Makeinfo src/uqm/ships/druuge/Makeinfo
--- src.orig/uqm/ships/druuge/Makeinfo	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/druuge/Makeinfo	2017-11-21 19:39:58 -0600
@@ -1 +1,2 @@
 uqm_CFILES="druuge.c"
+uqm_HFILES="druuge.h icode.h resinst.h"
diff -ruNp src.orig/uqm/ships/druuge/druuge.c src/uqm/ships/druuge/druuge.c
--- src.orig/uqm/ships/druuge/druuge.c	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/druuge/druuge.c	2017-11-21 19:39:58 -0600
@@ -20,27 +20,38 @@
 #include "druuge.h"
 #include "resinst.h"
 
+// Core characteristics
 #define MAX_CREW 14
 #define MAX_ENERGY 32
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 4
-#define SPECIAL_ENERGY_COST 16
 #define ENERGY_WAIT 50
 #define MAX_THRUST 20
 #define THRUST_INCREMENT 2
-#define TURN_WAIT 4
 #define THRUST_WAIT 1
-#define WEAPON_WAIT 10
-#define SPECIAL_WAIT 30
-
+#define TURN_WAIT 4
 #define SHIP_MASS 5
+
+// Mass Driver
+#define WEAPON_ENERGY_COST 4
+#define WEAPON_WAIT 10
+#define DRUUGE_OFFSET 24
+#define MISSILE_OFFSET 6
 #define MISSILE_SPEED DISPLAY_TO_WORLD (30)
 #define MISSILE_LIFE 20
 #define MISSILE_RANGE (MISSILE_SPEED * MISSILE_LIFE)
+#define MISSILE_HITS 4
+#define MISSILE_DAMAGE 6
+#define RECOIL_VELOCITY WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (6))
+#define MAX_RECOIL_VELOCITY (RECOIL_VELOCITY * 4)
+
+// Furnace
+#define SPECIAL_ENERGY_COST 16
+#define SPECIAL_WAIT 30
 
 static RACE_DESC druuge_desc =
 {
 	{ /* SHIP_INFO */
+		"mauler",
 		FIRES_FORE,
 		17, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -109,9 +120,6 @@ static RACE_DESC druuge_desc =
 	0, /* CodeRef */
 };
 
-#define RECOIL_VELOCITY WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (6))
-#define MAX_RECOIL_VELOCITY (RECOIL_VELOCITY * 4)
-
 static void
 cannon_collision (ELEMENT *ElementPtr0, POINT *pPt0,
 		ELEMENT *ElementPtr1, POINT *pPt1)
@@ -153,10 +161,6 @@ cannon_collision (ELEMENT *ElementPtr0,
 static COUNT
 initialize_cannon (ELEMENT *ShipPtr, HELEMENT CannonArray[])
 {
-#define DRUUGE_OFFSET 24
-#define MISSILE_OFFSET 6
-#define MISSILE_HITS 4
-#define MISSILE_DAMAGE 6
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
diff -ruNp src.orig/uqm/ships/druuge/druuge.h src/uqm/ships/druuge/druuge.h
--- src.orig/uqm/ships/druuge/druuge.h	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/druuge/druuge.h	2017-11-21 19:39:58 -0600
@@ -17,7 +17,15 @@
 #ifndef DRUUGE_H
 #define DRUUGE_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_druuge (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* DRUUGE_H */
 
diff -ruNp src.orig/uqm/ships/druuge/icode.h src/uqm/ships/druuge/icode.h
--- src.orig/uqm/ships/druuge/icode.h	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/druuge/icode.h	2017-11-21 19:39:58 -0600
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define DRUUGE_CODE "ship.druuge.code"
diff -ruNp src.orig/uqm/ships/druuge/resinst.h src/uqm/ships/druuge/resinst.h
--- src.orig/uqm/ships/druuge/resinst.h	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/druuge/resinst.h	2017-11-21 19:39:58 -0600
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define DRUUGE_BIG_MASK_PMAP_ANIM "ship.druuge.graphics.mauler.large"
 #define DRUUGE_CANNON_BIG_MASK_PMAP_ANIM "ship.druuge.graphics.cannon.large"
 #define DRUUGE_CANNON_MED_MASK_PMAP_ANIM "ship.druuge.graphics.cannon.medium"
@@ -6,9 +10,7 @@
 #define DRUUGE_ICON_MASK_PMAP_ANIM "ship.druuge.icons"
 #define DRUUGE_MED_MASK_PMAP_ANIM "ship.druuge.graphics.mauler.medium"
 #define DRUUGE_MICON_MASK_PMAP_ANIM "ship.druuge.meleeicons"
-#define DRUUGE_SML_MASK_PMAP_ANIM "ship.druuge.graphics.mauler.small"
 #define DRUUGE_RACE_STRINGS "ship.druuge.text"
 #define DRUUGE_SHIP_SOUNDS "ship.druuge.sounds"
+#define DRUUGE_SML_MASK_PMAP_ANIM "ship.druuge.graphics.mauler.small"
 #define DRUUGE_VICTORY_SONG "ship.druuge.ditty"
-
-#include "icode.h"
diff -ruNp src.orig/uqm/ships/human/Makeinfo src/uqm/ships/human/Makeinfo
--- src.orig/uqm/ships/human/Makeinfo	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/human/Makeinfo	2017-11-21 19:39:58 -0600
@@ -1 +1,2 @@
 uqm_CFILES="human.c"
+uqm_HFILES="human.h icode.h resinst.h"
diff -ruNp src.orig/uqm/ships/human/human.c src/uqm/ships/human/human.c
--- src.orig/uqm/ships/human/human.c	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/human/human.c	2017-11-21 19:39:58 -0600
@@ -23,28 +23,41 @@
 #include "uqm/colors.h"
 #include "uqm/globdata.h"
 
-
+// Core characteristics
 #define MAX_CREW 18
 #define MAX_ENERGY 18
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 9
-#define SPECIAL_ENERGY_COST 4
 #define ENERGY_WAIT 8
 #define MAX_THRUST /* DISPLAY_TO_WORLD (6) */ 24
 #define THRUST_INCREMENT /* DISPLAY_TO_WORLD (2) */ 3
-#define TURN_WAIT 1
 #define THRUST_WAIT 4
-#define WEAPON_WAIT 10
-#define SPECIAL_WAIT 9
-
+#define TURN_WAIT 1
 #define SHIP_MASS 6
-#define MISSILE_LIFE 60
+
+// Nuke
+#define WEAPON_ENERGY_COST 9
+#define WEAPON_WAIT 10
+#define HUMAN_OFFSET 42
+#define NUKE_OFFSET 8
 #define MIN_MISSILE_SPEED DISPLAY_TO_WORLD (10)
 #define MAX_MISSILE_SPEED DISPLAY_TO_WORLD (20)
+#define MISSILE_SPEED (MAX_THRUST >= MIN_MISSILE_SPEED ? \
+		MAX_THRUST : MIN_MISSILE_SPEED)
+#define THRUST_SCALE DISPLAY_TO_WORLD (1)
+#define MISSILE_LIFE 60
+#define MISSILE_HITS 1
+#define MISSILE_DAMAGE 4
+#define TRACK_WAIT 3
+
+// Point-Defense Laser
+#define SPECIAL_ENERGY_COST 4
+#define SPECIAL_WAIT 9
+#define LASER_RANGE (UWORD)100
 
 static RACE_DESC human_desc =
 {
 	{ /* SHIP_INFO */
+		"cruiser",
 		FIRES_FORE | SEEKING_WEAPON | POINT_DEFENSE,
 		11, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -113,10 +126,6 @@ static RACE_DESC human_desc =
 	0, /* CodeRef */
 };
 
-#define MISSILE_SPEED (MAX_THRUST >= MIN_MISSILE_SPEED ? \
-										MAX_THRUST : MIN_MISSILE_SPEED)
-#define TRACK_WAIT 3
-
 static void
 nuke_preprocess (ELEMENT *ElementPtr)
 {
@@ -141,7 +150,6 @@ nuke_preprocess (ELEMENT *ElementPtr)
 	{
 		SIZE speed;
 
-#define THRUST_SCALE DISPLAY_TO_WORLD (1)
 		if ((speed = MISSILE_SPEED +
 				((MISSILE_LIFE - ElementPtr->life_span) *
 				THRUST_SCALE)) > MAX_MISSILE_SPEED)
@@ -196,7 +204,6 @@ spawn_point_defense (ELEMENT *ElementPtr
 			if (ObjectPtr != ShipPtr && CollidingElement (ObjectPtr) &&
 					!OBJECT_CLOAKED (ObjectPtr))
 			{
-#define LASER_RANGE (UWORD)100
 				SIZE delta_x, delta_y;
 
 				delta_x = ObjectPtr->next.location.x -
@@ -265,10 +272,6 @@ spawn_point_defense (ELEMENT *ElementPtr
 static COUNT
 initialize_nuke (ELEMENT *ShipPtr, HELEMENT NukeArray[])
 {
-#define HUMAN_OFFSET 42
-#define MISSILE_DAMAGE 4
-#define MISSILE_HITS 1
-#define NUKE_OFFSET 8
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
diff -ruNp src.orig/uqm/ships/human/human.h src/uqm/ships/human/human.h
--- src.orig/uqm/ships/human/human.h	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/human/human.h	2017-11-21 19:39:58 -0600
@@ -17,7 +17,15 @@
 #ifndef HUMAN_H
 #define HUMAN_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_human (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* HUMAN_H */
 
diff -ruNp src.orig/uqm/ships/human/icode.h src/uqm/ships/human/icode.h
--- src.orig/uqm/ships/human/icode.h	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/human/icode.h	2017-11-21 19:39:58 -0600
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define HUMAN_CODE "ship.earthling.code"
diff -ruNp src.orig/uqm/ships/human/resinst.h src/uqm/ships/human/resinst.h
--- src.orig/uqm/ships/human/resinst.h	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/human/resinst.h	2017-11-21 19:39:58 -0600
@@ -1,14 +1,16 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define HUMAN_BIG_MASK_PMAP_ANIM "ship.earthling.graphics.human.large"
 #define HUMAN_CAPTAIN_MASK_PMAP_ANIM "ship.earthling.graphics.captain"
 #define HUMAN_ICON_MASK_PMAP_ANIM "ship.earthling.icons"
 #define HUMAN_MED_MASK_PMAP_ANIM "ship.earthling.graphics.human.medium"
 #define HUMAN_MICON_MASK_PMAP_ANIM "ship.earthling.meleeicons"
+#define HUMAN_RACE_STRINGS "ship.earthling.text"
+#define HUMAN_SHIP_SOUNDS "ship.earthling.sounds"
 #define HUMAN_SML_MASK_PMAP_ANIM "ship.earthling.graphics.human.small"
+#define HUMAN_VICTORY_SONG "ship.earthling.ditty"
 #define SATURN_BIG_MASK_PMAP_ANIM "ship.earthling.graphics.saturn.large"
 #define SATURN_MED_MASK_PMAP_ANIM "ship.earthling.graphics.saturn.medium"
 #define SATURN_SML_MASK_PMAP_ANIM "ship.earthling.graphics.saturn.small"
-#define HUMAN_RACE_STRINGS "ship.earthling.text"
-#define HUMAN_SHIP_SOUNDS "ship.earthling.sounds"
-#define HUMAN_VICTORY_SONG "ship.earthling.ditty"
-
-#include "icode.h"
diff -ruNp src.orig/uqm/ships/ilwrath/Makeinfo src/uqm/ships/ilwrath/Makeinfo
--- src.orig/uqm/ships/ilwrath/Makeinfo	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/ilwrath/Makeinfo	2017-11-21 19:39:58 -0600
@@ -1 +1,2 @@
 uqm_CFILES="ilwrath.c"
+uqm_HFILES="icode.h ilwrath.h resinst.h"
diff -ruNp src.orig/uqm/ships/ilwrath/icode.h src/uqm/ships/ilwrath/icode.h
--- src.orig/uqm/ships/ilwrath/icode.h	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/ilwrath/icode.h	2017-11-21 19:39:58 -0600
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define ILWRATH_CODE "ship.ilwrath.code"
diff -ruNp src.orig/uqm/ships/ilwrath/ilwrath.c src/uqm/ships/ilwrath/ilwrath.c
--- src.orig/uqm/ships/ilwrath/ilwrath.c	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/ilwrath/ilwrath.c	2017-11-21 19:39:58 -0600
@@ -24,25 +24,38 @@
 #include "uqm/globdata.h"
 
 
+// Core characteristics
 #define MAX_CREW 22
 #define MAX_ENERGY 16
 #define ENERGY_REGENERATION 4
-#define WEAPON_ENERGY_COST 1
-#define SPECIAL_ENERGY_COST 3
 #define ENERGY_WAIT 4
 #define MAX_THRUST 25
 #define THRUST_INCREMENT 5
-#define TURN_WAIT 2
 #define THRUST_WAIT 0
-#define WEAPON_WAIT 0
-#define SPECIAL_WAIT 13
-
+#define TURN_WAIT 2
 #define SHIP_MASS 7
+#define LOOK_AHEAD 4
+		/* Controls how much the auto-turn will attempt to "lead"
+		 * its target. */
+
+// Hellfire Spout
+#define WEAPON_ENERGY_COST 1
+#define WEAPON_WAIT 0
 #define MISSILE_LIFE 8
+#define ILWRATH_OFFSET 29
+#define MISSILE_SPEED MAX_THRUST
+#define MISSILE_HITS 1
+#define MISSILE_DAMAGE 1
+#define MISSILE_OFFSET 0
+
+// Cloaking Device
+#define SPECIAL_ENERGY_COST 3
+#define SPECIAL_WAIT 13
 
 static RACE_DESC ilwrath_desc =
 {
 	{ /* SHIP_INFO */
+		"avenger",
 		FIRES_FORE,
 		10, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -178,11 +191,6 @@ ilwrath_intelligence (ELEMENT *ShipPtr,
 static COUNT
 initialize_flame (ELEMENT *ShipPtr, HELEMENT FlameArray[])
 {
-#define ILWRATH_OFFSET 29
-#define MISSILE_SPEED MAX_THRUST
-#define MISSILE_HITS 1
-#define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET 0
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -278,7 +286,6 @@ ilwrath_preprocess (ELEMENT *ElementPtr)
 					facing = StarShipPtr->ShipFacing;
 					if (TrackShip (ElementPtr, &facing) >= 0)
 					{
-#define LOOK_AHEAD 4
 						ELEMENT *eptr;
 						SIZE dx0, dy0, dx1, dy1;
 						VELOCITY_DESC v;
diff -ruNp src.orig/uqm/ships/ilwrath/ilwrath.h src/uqm/ships/ilwrath/ilwrath.h
--- src.orig/uqm/ships/ilwrath/ilwrath.h	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/ilwrath/ilwrath.h	2017-11-21 19:39:58 -0600
@@ -17,7 +17,15 @@
 #ifndef ILWRATH_H
 #define ILWRATH_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_ilwrath (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* ILWRATH_H */
 
diff -ruNp src.orig/uqm/ships/ilwrath/resinst.h src/uqm/ships/ilwrath/resinst.h
--- src.orig/uqm/ships/ilwrath/resinst.h	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/ilwrath/resinst.h	2017-11-21 19:39:58 -0600
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define FIRE_BIG_MASK_PMAP_ANIM "ship.ilwrath.graphics.fire.large"
 #define FIRE_MED_MASK_PMAP_ANIM "ship.ilwrath.graphics.fire.medium"
 #define FIRE_SML_MASK_PMAP_ANIM "ship.ilwrath.graphics.fire.small"
@@ -6,9 +10,7 @@
 #define ILWRATH_ICON_MASK_PMAP_ANIM "ship.ilwrath.icons"
 #define ILWRATH_MED_MASK_PMAP_ANIM "ship.ilwrath.graphics.avenger.medium"
 #define ILWRATH_MICON_MASK_PMAP_ANIM "ship.ilwrath.meleeicons"
-#define ILWRATH_SML_MASK_PMAP_ANIM "ship.ilwrath.graphics.avenger.small"
 #define ILWRATH_RACE_STRINGS "ship.ilwrath.text"
 #define ILWRATH_SHIP_SOUNDS "ship.ilwrath.sounds"
+#define ILWRATH_SML_MASK_PMAP_ANIM "ship.ilwrath.graphics.avenger.small"
 #define ILWRATH_VICTORY_SONG "ship.ilwrath.ditty"
-
-#include "icode.h"
diff -ruNp src.orig/uqm/ships/lastbat/Makeinfo src/uqm/ships/lastbat/Makeinfo
--- src.orig/uqm/ships/lastbat/Makeinfo	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/lastbat/Makeinfo	2017-11-21 19:39:58 -0600
@@ -1 +1,2 @@
 uqm_CFILES="lastbat.c"
+uqm_HFILES="icode.h lastbat.h resinst.h"
diff -ruNp src.orig/uqm/ships/lastbat/icode.h src/uqm/ships/lastbat/icode.h
--- src.orig/uqm/ships/lastbat/icode.h	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/lastbat/icode.h	2017-11-21 19:39:58 -0600
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SAMATRA_CODE "ship.samatra.code"
diff -ruNp src.orig/uqm/ships/lastbat/lastbat.c src/uqm/ships/lastbat/lastbat.c
--- src.orig/uqm/ships/lastbat/lastbat.c	2017-11-21 19:39:40 -0600
+++ src/uqm/ships/lastbat/lastbat.c	2017-11-21 19:39:58 -0600
@@ -27,29 +27,63 @@
 #include "libs/mathlib.h"
 #include "libs/timelib.h"
 
-
 #define num_generators characteristics.max_thrust
 
+// Core characteristics
 #define MAX_CREW 1
 #define MAX_ENERGY MAX_ENERGY_SIZE
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 2
-#define SPECIAL_ENERGY_COST 3
 #define ENERGY_WAIT 6
 #define MAX_THRUST 0
 #define THRUST_INCREMENT 0
 #define TURN_WAIT 0
 #define THRUST_WAIT 0
+#define SHIP_MASS (MAX_SHIP_MASS * 10)
+#define TURRET_WAIT 0 /* Controls animation of the Sa-Matra's central
+                       * 'furnace', a new frame is displayed once every
+                       * TURRET_WAIT frames. */
+
+// Yellow comet
 #define WEAPON_WAIT ((ONE_SECOND / BATTLE_FRAME_RATE) * 10)
+#define COMET_DAMAGE 2
+#define COMET_OFFSET 0
+#define COMET_HITS 12
+#define COMET_SPEED DISPLAY_TO_WORLD (12)
+#define COMET_LIFE 2
+#define COMET_TURN_WAIT 3
+#define MAX_COMETS 3
+#define WEAPON_ENERGY_COST 2
+		/* Used for samatra_desc.weapon_energy_cost, but the value isn't
+		 * actually used. */
+
+// Green sentinel
 #define SPECIAL_WAIT ((ONE_SECOND / BATTLE_FRAME_RATE) * 3)
+#define SENTINEL_SPEED DISPLAY_TO_WORLD (8)
+#define SENTINEL_LIFE 2
+#define SENTINEL_OFFSET 0
+#define SENTINEL_HITS 10
+#define SENTINEL_DAMAGE 1
+#define TRACK_WAIT 1
+#define ANIMATION_WAIT 1
+#define RECOIL_VELOCITY WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (10))
+#define MAX_RECOIL_VELOCITY (RECOIL_VELOCITY * 4)
+#define MAX_SENTINELS 4
+#define SPECIAL_ENERGY_COST 3
+		/* Used for samatra_desc.special_energy_cost, but the value isn't
+		 * actually used. */
 
-#define SHIP_MASS (MAX_SHIP_MASS * 10)
-#define SAMATRA_OFFSET 9
-#define MISSILE_SPEED DISPLAY_TO_WORLD (8)
+// Blue force field
+#define GATE_DAMAGE 1
+#define GATE_HITS 100
+
+// Red generators
+#define GENERATOR_HITS 15
+#define MAX_GENERATORS 8
 
 static RACE_DESC samatra_desc =
 {
 	{ /* SHIP_INFO */
+		"samatra",
 		/* FIRES_FORE | */ IMMEDIATE_WEAPON | CREW_IMMUNE,
 		16, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -153,8 +187,6 @@ comet_preprocess (ELEMENT *ElementPtr)
 	ElementPtr->state_flags |= CHANGING;
 }
 
-#define COMET_DAMAGE 2
-
 static void
 comet_collision (ELEMENT *ElementPtr0, POINT *pPt0,
 		ELEMENT *ElementPtr1, POINT *pPt1)
@@ -199,10 +231,6 @@ comet_collision (ELEMENT *ElementPtr0, P
 static HELEMENT
 spawn_comet (ELEMENT *ElementPtr)
 {
-#define COMET_OFFSET 0
-#define COMET_HITS 12
-#define COMET_SPEED DISPLAY_TO_WORLD (12)
-#define COMET_LIFE 2
 	MISSILE_BLOCK MissileBlock;
 	HELEMENT hComet;
 	STARSHIP *StarShipPtr;
@@ -258,12 +286,11 @@ spawn_comet (ELEMENT *ElementPtr)
 				--CometPtr->turn_wait;
 			else
 			{
-#define COMET_WAIT 3
 				facing = NORMALIZE_FACING (facing);
 				if (TrackShip (CometPtr, &facing) > 0)
 					SetVelocityVector (&CometPtr->velocity,
 							COMET_SPEED, facing);
-				CometPtr->turn_wait = COMET_WAIT;
+				CometPtr->turn_wait = COMET_TURN_WAIT;
 			}
 		}
 		UnlockElement (hComet);
@@ -279,7 +306,6 @@ turret_preprocess (ELEMENT *ElementPtr)
 		--ElementPtr->turn_wait;
 	else
 	{
-#define TURRET_WAIT 0
 		ElementPtr->next.image.frame =
 				SetAbsFrameIndex (ElementPtr->current.image.frame,
 				(GetFrameIndex (ElementPtr->current.image.frame) % 10) + 1);
@@ -289,9 +315,6 @@ turret_preprocess (ELEMENT *ElementPtr)
 	}
 }
 
-#define GATE_DAMAGE 1
-#define GATE_HITS 100
-
 static void
 gate_collision (ELEMENT *ElementPtr0, POINT *pPt0,
 		ELEMENT *ElementPtr1, POINT *pPt1)
@@ -413,8 +436,6 @@ generator_death (ELEMENT *ElementPtr)
 	}
 }
 
-#define GENERATOR_HITS 15
-
 static void
 generator_preprocess (ELEMENT *ElementPtr)
 {
@@ -443,8 +464,6 @@ generator_collision (ELEMENT *ElementPtr
 	(void) pPt1;  /* Satisfying compiler (unused parameter) */
 }
 
-#define TRACK_WAIT 1
-
 static void
 sentinel_preprocess (ELEMENT *ElementPtr)
 {
@@ -458,7 +477,6 @@ sentinel_preprocess (ELEMENT *ElementPtr
 		--ElementPtr->thrust_wait;
 	else
 	{
-#define ANIMATION_WAIT 1
 		ElementPtr->next.image.frame =
 				SetAbsFrameIndex (ElementPtr->current.image.frame,
 				(GetFrameIndex (ElementPtr->current.image.frame) + 1) % 6);
@@ -483,7 +501,7 @@ sentinel_preprocess (ELEMENT *ElementPtr
 			ElementPtr->state_flags &= ~NONSOLID;
 			facing = (COUNT)TFB_Random ();
 			SetVelocityVector (&ElementPtr->velocity,
-					MISSILE_SPEED, facing);
+					SENTINEL_SPEED, facing);
 		}
 		facing = NORMALIZE_FACING (facing);
 		if (ElementPtr->hTarget == 0)
@@ -577,16 +595,13 @@ sentinel_preprocess (ELEMENT *ElementPtr
 			}
 
 			SetVelocityVector (&ElementPtr->velocity,
-					MISSILE_SPEED, facing);
+					SENTINEL_SPEED, facing);
 		}
 
 		ElementPtr->turn_wait = TRACK_WAIT;
 	}
 }
 
-#define RECOIL_VELOCITY WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (10))
-#define MAX_RECOIL_VELOCITY (RECOIL_VELOCITY * 4)
-
 static void
 sentinel_collision (ELEMENT *ElementPtr0, POINT *pPt0,
 		ELEMENT *ElementPtr1, POINT *pPt1)
@@ -604,8 +619,8 @@ sentinel_collision (ELEMENT *ElementPtr0
 			angle = ARCTAN (pPt0->x - pPt1->x, pPt0->y - pPt1->y);
 
 			SetVelocityComponents (&ElementPtr0->velocity,
-					COSINE (angle, WORLD_TO_VELOCITY (MISSILE_SPEED)),
-					SINE (angle, WORLD_TO_VELOCITY (MISSILE_SPEED)));
+					COSINE (angle, WORLD_TO_VELOCITY (SENTINEL_SPEED)),
+					SINE (angle, WORLD_TO_VELOCITY (SENTINEL_SPEED)));
 			ElementPtr0->turn_wait = TRACK_WAIT;
 			ElementPtr0->state_flags |= COLLISION | DEFY_PHYSICS;
 		}
@@ -688,9 +703,6 @@ samatra_intelligence (ELEMENT *ShipPtr,
 	ship_intelligence (ShipPtr, ObjectsOfConcern, ConcernCounter);
 }
 
-#define MAX_COMETS 3
-#define MAX_SENTINELS 4
-
 static void
 samatra_postprocess (ELEMENT *ElementPtr)
 {
@@ -709,10 +721,6 @@ samatra_postprocess (ELEMENT *ElementPtr
 		if (StarShipPtr->special_counter == 0
 				&& StarShipPtr->RaceDescPtr->characteristics.special_wait < MAX_SENTINELS)
 		{
-#define MISSILE_LIFE 2
-#define MISSILE_OFFSET 0
-#define MISSILE_HITS 10
-#define MISSILE_DAMAGE 1
 			MISSILE_BLOCK MissileBlock;
 			HELEMENT hSentinel;
 
@@ -724,12 +732,12 @@ samatra_postprocess (ELEMENT *ElementPtr
 			MissileBlock.sender = ElementPtr->playerNr;
 			MissileBlock.flags = 0;
 			MissileBlock.pixoffs = 0;
-			MissileBlock.speed = MISSILE_SPEED;
-			MissileBlock.hit_points = MISSILE_HITS;
-			MissileBlock.damage = MISSILE_DAMAGE;
-			MissileBlock.life = MISSILE_LIFE;
+			MissileBlock.speed = SENTINEL_SPEED;
+			MissileBlock.hit_points = SENTINEL_HITS;
+			MissileBlock.damage = SENTINEL_DAMAGE;
+			MissileBlock.life = SENTINEL_LIFE;
 			MissileBlock.preprocess_func = sentinel_preprocess;
-			MissileBlock.blast_offs = MISSILE_OFFSET;
+			MissileBlock.blast_offs = SENTINEL_OFFSET;
 			hSentinel = initialize_missile (&MissileBlock);
 
 			if (hSentinel)
@@ -765,7 +773,6 @@ samatra_preprocess (ELEMENT *ElementPtr)
 	}
 	else
 	{
-#define MAX_GENERATORS 8
 		POINT offs[] =
 		{
 			{-127-9,  -53+18},
diff -ruNp src.orig/uqm/ships/lastbat/lastbat.h src/uqm/ships/lastbat/lastbat.h
--- src.orig/uqm/ships/lastbat/lastbat.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/lastbat/lastbat.h	2017-11-21 19:39:58 -0600
@@ -17,7 +17,15 @@
 #ifndef LASTBAT_H
 #define LASTBAT_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_samatra (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* LASTBAT_H */
 
diff -ruNp src.orig/uqm/ships/lastbat/resinst.h src/uqm/ships/lastbat/resinst.h
--- src.orig/uqm/ships/lastbat/resinst.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/lastbat/resinst.h	2017-11-21 19:39:58 -0600
@@ -1,14 +1,16 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define GENERATOR_BIG_MASK_ANIM "ship.samatra.graphics.generator.large"
 #define GENERATOR_MED_MASK_PMAP_ANIM "ship.samatra.graphics.generator.medium"
 #define GENERATOR_SML_MASK_PMAP_ANIM "ship.samatra.graphics.generator.small"
 #define SAMATRA_BIG_MASK_ANIM "ship.samatra.graphics.samatra.large"
 #define SAMATRA_CAPTAIN_MASK_PMAP_ANIM "ship.samatra.graphics.captain"
 #define SAMATRA_MED_MASK_PMAP_ANIM "ship.samatra.graphics.samatra.medium"
+#define SAMATRA_SHIP_SOUNDS "ship.samatra.sounds"
 #define SAMATRA_SML_MASK_PMAP_ANIM "ship.samatra.graphics.samatra.small"
+#define SAMATRA_VICTORY_SONG "ship.samatra.ditty"
 #define SENTINEL_BIG_MASK_ANIM "ship.samatra.graphics.sentinel.large"
 #define SENTINEL_MED_MASK_PMAP_ANIM "ship.samatra.graphics.sentinel.medium"
 #define SENTINEL_SML_MASK_PMAP_ANIM "ship.samatra.graphics.sentinel.small"
-#define SAMATRA_SHIP_SOUNDS "ship.samatra.sounds"
-#define SAMATRA_VICTORY_SONG "ship.samatra.ditty"
-
-#include "icode.h"
diff -ruNp src.orig/uqm/ships/melnorme/Makeinfo src/uqm/ships/melnorme/Makeinfo
--- src.orig/uqm/ships/melnorme/Makeinfo	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/melnorme/Makeinfo	2017-11-21 19:39:58 -0600
@@ -1 +1,2 @@
 uqm_CFILES="melnorme.c"
+uqm_HFILES="icode.h melnorme.h resinst.h"
diff -ruNp src.orig/uqm/ships/melnorme/icode.h src/uqm/ships/melnorme/icode.h
--- src.orig/uqm/ships/melnorme/icode.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/melnorme/icode.h	2017-11-21 19:39:58 -0600
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define MELNORME_CODE "ship.melnorme.code"
diff -ruNp src.orig/uqm/ships/melnorme/melnorme.c src/uqm/ships/melnorme/melnorme.c
--- src.orig/uqm/ships/melnorme/melnorme.c	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/melnorme/melnorme.c	2017-11-21 19:39:58 -0600
@@ -23,27 +23,43 @@
 #include "uqm/globdata.h"
 #include "libs/mathlib.h"
 
-
+// Core characteristics
 #define MAX_CREW 20
 #define MAX_ENERGY MAX_ENERGY_SIZE
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 5
-#define SPECIAL_ENERGY_COST 20
 #define ENERGY_WAIT 4
 #define MAX_THRUST 36
 #define THRUST_INCREMENT 6
-#define TURN_WAIT 4
 #define THRUST_WAIT 4
-#define WEAPON_WAIT 1
-#define SPECIAL_WAIT 20
-
+#define TURN_WAIT 4
 #define SHIP_MASS 7
+
+// Blaster Pulse
+#define WEAPON_ENERGY_COST 5
+#define WEAPON_WAIT 1
+#define MELNORME_OFFSET 24
+#define LEVEL_COUNTER 72
+#define MAX_PUMP 4
 #define PUMPUP_SPEED DISPLAY_TO_WORLD (45)
 #define PUMPUP_LIFE 10
+#define PUMPUP_DAMAGE 2
+#define MIN_PUMPITUDE_ANIMS 3
+#define NUM_PUMP_ANIMS 5
+#define REVERSE_DIR (BYTE)(1 << 7)
+
+// Confusion Pulse
+#define SPECIAL_ENERGY_COST 20
+#define SPECIAL_WAIT 20
+#define CMISSILE_SPEED DISPLAY_TO_WORLD (30)
+#define CMISSILE_LIFE 20
+#define CMISSILE_HITS 200
+#define CMISSILE_DAMAGE 0
+#define CMISSILE_OFFSET 4
 
 static RACE_DESC melnorme_desc =
 {
 	{ /* SHIP_INFO */
+		"trader",
 		FIRES_FORE,
 		18, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -112,9 +128,6 @@ static RACE_DESC melnorme_desc =
 	0, /* CodeRef */
 };
 
-#define NUM_PUMP_ANIMS 5
-#define REVERSE_DIR (BYTE)(1 << 7)
-
 static void
 pump_up_preprocess (ELEMENT *ElementPtr)
 {
@@ -146,11 +159,6 @@ pump_up_preprocess (ELEMENT *ElementPtr)
 
 static COUNT initialize_pump_up (ELEMENT *ShipPtr, HELEMENT PumpUpArray[]);
 
-#define MELNORME_OFFSET 24
-#define LEVEL_COUNTER 72
-#define MAX_PUMP 4
-#define PUMPUP_DAMAGE 2
-
 static void
 pump_up_postprocess (ELEMENT *ElementPtr)
 {
@@ -282,7 +290,6 @@ pump_up_collision (ELEMENT *ElementPtr0,
 	{
 		ELEMENT *BlastElementPtr;
 
-#define MIN_PUMPITUDE_ANIMS 3
 		LockElement (hBlastElement, &BlastElementPtr);
 
 		BlastElementPtr->life_span =
@@ -474,11 +481,6 @@ confusion_collision (ELEMENT *ElementPtr
 static COUNT
 initialize_confusion (ELEMENT *ShipPtr, HELEMENT ConfusionArray[])
 {
-#define CMISSILE_SPEED DISPLAY_TO_WORLD (30)
-#define CMISSILE_HITS 200
-#define CMISSILE_DAMAGE 0
-#define CMISSILE_LIFE 20
-#define CMISSILE_OFFSET 4
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK ConfusionBlock;
 
diff -ruNp src.orig/uqm/ships/melnorme/melnorme.h src/uqm/ships/melnorme/melnorme.h
--- src.orig/uqm/ships/melnorme/melnorme.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/melnorme/melnorme.h	2017-11-21 19:39:58 -0600
@@ -17,7 +17,15 @@
 #ifndef MELNORME_H
 #define MELNORME_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_melnorme (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* MELNORME_H */
 
diff -ruNp src.orig/uqm/ships/melnorme/resinst.h src/uqm/ships/melnorme/resinst.h
--- src.orig/uqm/ships/melnorme/resinst.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/melnorme/resinst.h	2017-11-21 19:39:58 -0600
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define CONFUSE_BIG_MASK_PMAP_ANIM "ship.melnorme.graphics.confuse.large"
 #define CONFUSE_MED_MASK_PMAP_ANIM "ship.melnorme.graphics.confuse.medium"
 #define CONFUSE_SML_MASK_PMAP_ANIM "ship.melnorme.graphics.confuse.small"
@@ -6,12 +10,10 @@
 #define MELNORME_ICON_MASK_PMAP_ANIM "ship.melnorme.icons"
 #define MELNORME_MED_MASK_PMAP_ANIM "ship.melnorme.graphics.trader.medium"
 #define MELNORME_MICON_MASK_PMAP_ANIM "ship.melnorme.meleeicons"
+#define MELNORME_RACE_STRINGS "ship.melnorme.text"
+#define MELNORME_SHIP_SOUNDS "ship.melnorme.sounds"
 #define MELNORME_SML_MASK_PMAP_ANIM "ship.melnorme.graphics.trader.small"
+#define MELNORME_VICTORY_SONG "ship.melnorme.ditty"
 #define PUMPUP_BIG_MASK_PMAP_ANIM "ship.melnorme.graphics.pumpup.large"
 #define PUMPUP_MED_MASK_PMAP_ANIM "ship.melnorme.graphics.pumpup.medium"
 #define PUMPUP_SML_MASK_PMAP_ANIM "ship.melnorme.graphics.pumpup.small"
-#define MELNORME_RACE_STRINGS "ship.melnorme.text"
-#define MELNORME_SHIP_SOUNDS "ship.melnorme.sounds"
-#define MELNORME_VICTORY_SONG "ship.melnorme.ditty"
-
-#include "icode.h"
diff -ruNp src.orig/uqm/ships/mmrnmhrm/Makeinfo src/uqm/ships/mmrnmhrm/Makeinfo
--- src.orig/uqm/ships/mmrnmhrm/Makeinfo	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/mmrnmhrm/Makeinfo	2017-11-21 19:39:58 -0600
@@ -1 +1,2 @@
 uqm_CFILES="mmrnmhrm.c"
+uqm_HFILES="icode.h mmrnmhrm.h resinst.h"
diff -ruNp src.orig/uqm/ships/mmrnmhrm/icode.h src/uqm/ships/mmrnmhrm/icode.h
--- src.orig/uqm/ships/mmrnmhrm/icode.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/mmrnmhrm/icode.h	2017-11-21 19:39:58 -0600
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define MMRNMHRM_CODE "ship.mmrnmhrm.code"
diff -ruNp src.orig/uqm/ships/mmrnmhrm/mmrnmhrm.c src/uqm/ships/mmrnmhrm/mmrnmhrm.c
--- src.orig/uqm/ships/mmrnmhrm/mmrnmhrm.c	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/mmrnmhrm/mmrnmhrm.c	2017-11-21 19:39:58 -0600
@@ -20,39 +20,56 @@
 #include "mmrnmhrm.h"
 #include "resinst.h"
 
-
+// Core characteristics
 #define MAX_CREW 20
 #define MAX_ENERGY 10
+#define SHIP_MASS 3
+
+// X-Wing characteristics
 #define ENERGY_REGENERATION 2
-#define WEAPON_ENERGY_COST 1
-#define SPECIAL_ENERGY_COST MAX_ENERGY
 #define ENERGY_WAIT 6
 #define MAX_THRUST 20
 #define THRUST_INCREMENT 5
-#define TURN_WAIT 2
 #define THRUST_WAIT 1
-#define WEAPON_WAIT 0
-#define SPECIAL_WAIT 0
+#define TURN_WAIT 2
 
+// Y-Wing characteristics
 #define YWING_ENERGY_REGENERATION 1
-#define YWING_WEAPON_ENERGY_COST 1
 #define YWING_SPECIAL_ENERGY_COST MAX_ENERGY
 #define YWING_ENERGY_WAIT 6
 #define YWING_MAX_THRUST 50
 #define YWING_THRUST_INCREMENT 10
-#define YWING_TURN_WAIT 14
 #define YWING_THRUST_WAIT 0
-#define YWING_WEAPON_WAIT 20
-#define YWING_SPECIAL_WAIT 0
+#define YWING_TURN_WAIT 14
 
-#define SHIP_MASS 3
+// X-Wing Lasers
 #define MMRNMHRM_OFFSET 16
+#define WEAPON_ENERGY_COST 1
+#define WEAPON_WAIT 0
+#define CENTER_OFFS DISPLAY_TO_WORLD (4)
+#define WING_OFFS DISPLAY_TO_WORLD (10)
 #define LASER_RANGE DISPLAY_TO_WORLD (125 + MMRNMHRM_OFFSET)
 
+// Y-Wing Missiles
+#define YWING_WEAPON_ENERGY_COST 1
+#define YWING_WEAPON_WAIT 20
+#define LAUNCH_OFFS DISPLAY_TO_WORLD (4)
+#define MISSILE_OFFSET 0
+#define MISSILE_SPEED DISPLAY_TO_WORLD (20)
+#define MISSILE_LIFE 40
+#define MISSILE_HITS 1
+#define MISSILE_DAMAGE 1
+#define TRACK_WAIT 5
+
+// Transform
+#define SPECIAL_ENERGY_COST MAX_ENERGY
+#define SPECIAL_WAIT 0
+#define YWING_SPECIAL_WAIT 0
 
 static RACE_DESC mmrnmhrm_desc =
 {
 	{ /* SHIP_INFO */
+		"xform",
 		FIRES_FORE | IMMEDIATE_WEAPON,
 		19, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -121,8 +138,40 @@ static RACE_DESC mmrnmhrm_desc =
 	0, /* CodeRef */
 };
 
-#define MISSILE_SPEED DISPLAY_TO_WORLD (20)
-#define TRACK_WAIT 5
+// Private per-instance ship data
+typedef CHARACTERISTIC_STUFF MMRNMHRM_DATA;
+
+// Local typedef
+typedef MMRNMHRM_DATA CustomShipData_t;
+
+// Retrieve race-specific ship data from a race desc
+static CustomShipData_t *
+GetCustomShipData (RACE_DESC *pRaceDesc)
+{
+	return pRaceDesc->data;
+}
+
+// Set the race-specific data in a race desc
+// (Re)Allocates its own storage for the data.
+static void
+SetCustomShipData (RACE_DESC *pRaceDesc, const CustomShipData_t *data)
+{
+	if (pRaceDesc->data == data) 
+		return;  // no-op
+
+	if (pRaceDesc->data) // Out with the old
+	{
+		HFree (pRaceDesc->data);
+		pRaceDesc->data = NULL;
+	}
+
+	if (data) // In with the new
+	{
+		CustomShipData_t* newData = HMalloc (sizeof (*data));
+		*newData = *data;
+		pRaceDesc->data = newData;
+	}
+}
 
 static void
 missile_preprocess (ELEMENT *ElementPtr)
@@ -253,7 +302,6 @@ twin_laser_collision (ELEMENT *ElementPt
 static COUNT
 initialize_dual_weapons (ELEMENT *ShipPtr, HELEMENT WeaponArray[])
 {
-#define CENTER_OFFS DISPLAY_TO_WORLD (4)
 	COORD cx, cy;
 	COUNT facing, angle;
 	SIZE offs_x, offs_y;
@@ -267,7 +315,6 @@ initialize_dual_weapons (ELEMENT *ShipPt
 
 	if (ShipPtr->next.image.farray == StarShipPtr->RaceDescPtr->ship_data.ship)
 	{
-#define WING_OFFS DISPLAY_TO_WORLD (10)
 		COORD ex, ey;
 		LASER_BLOCK LaserBlock;
 		ELEMENT *LaserPtr;
@@ -307,11 +354,6 @@ initialize_dual_weapons (ELEMENT *ShipPt
 	}
 	else
 	{
-#define MISSILE_HITS 1
-#define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET 0
-#define MISSILE_LIFE 40
-#define LAUNCH_OFFS DISPLAY_TO_WORLD (4)
 		MISSILE_BLOCK TorpBlock;
 		ELEMENT *TorpPtr;
 
@@ -363,8 +405,8 @@ mmrnmhrm_postprocess (ELEMENT *ElementPt
 			/* take care of transform effect */
 	if (ElementPtr->next.image.farray != ElementPtr->current.image.farray)
 	{
-		CHARACTERISTIC_STUFF t;
-		CHARACTERISTIC_STUFF *otherwing_desc;
+		MMRNMHRM_DATA tempShipData;
+		MMRNMHRM_DATA *otherwing_desc;
 
 		ProcessSound (SetAbsSoundIndex (
 						/* TRANSFORM */
@@ -373,11 +415,13 @@ mmrnmhrm_postprocess (ELEMENT *ElementPt
 		StarShipPtr->weapon_counter = 0;
 
 		/* Swap characteristics descriptors around */
-		otherwing_desc = (CHARACTERISTIC_STUFF *)
-				StarShipPtr->RaceDescPtr->data;
-		t = *otherwing_desc;
-		*otherwing_desc = StarShipPtr->RaceDescPtr->characteristics;
-		StarShipPtr->RaceDescPtr->characteristics = t;
+		otherwing_desc = GetCustomShipData (StarShipPtr->RaceDescPtr);
+		if (!otherwing_desc)
+			return;  // No ship data (?!)
+
+		tempShipData = *otherwing_desc;
+		SetCustomShipData (StarShipPtr->RaceDescPtr, &StarShipPtr->RaceDescPtr->characteristics);
+		StarShipPtr->RaceDescPtr->characteristics = tempShipData;
 		StarShipPtr->RaceDescPtr->cyborg_control.ManeuverabilityIndex = 0;
 
 		if (ElementPtr->next.image.farray == StarShipPtr->RaceDescPtr->ship_data.special)
@@ -444,17 +488,16 @@ mmrnmhrm_preprocess (ELEMENT *ElementPtr
 static void
 uninit_mmrnmhrm (RACE_DESC *pRaceDesc)
 {
-	HFree ((void *)pRaceDesc->data);
-	pRaceDesc->data = 0;
+	SetCustomShipData (pRaceDesc, NULL);
 }
 
 RACE_DESC*
 init_mmrnmhrm (void)
 {
 	RACE_DESC *RaceDescPtr;
-
+	// The caller of this func will copy the struct
 	static RACE_DESC new_mmrnmhrm_desc;
-	CHARACTERISTIC_STUFF *otherwing_desc;
+	MMRNMHRM_DATA otherwing_desc;
 
 	mmrnmhrm_desc.uninit_func = uninit_mmrnmhrm;
 	mmrnmhrm_desc.preprocess_func = mmrnmhrm_preprocess;
@@ -464,20 +507,19 @@ init_mmrnmhrm (void)
 
 	new_mmrnmhrm_desc = mmrnmhrm_desc;
 
-	otherwing_desc = HMalloc (sizeof (*otherwing_desc));
-	otherwing_desc->max_thrust = YWING_MAX_THRUST;
-	otherwing_desc->thrust_increment = YWING_THRUST_INCREMENT;
-	otherwing_desc->energy_regeneration = YWING_ENERGY_REGENERATION;
-	otherwing_desc->weapon_energy_cost = YWING_WEAPON_ENERGY_COST;
-	otherwing_desc->special_energy_cost = YWING_SPECIAL_ENERGY_COST;
-	otherwing_desc->energy_wait = YWING_ENERGY_WAIT;
-	otherwing_desc->turn_wait = YWING_TURN_WAIT;
-	otherwing_desc->thrust_wait = YWING_THRUST_WAIT;
-	otherwing_desc->weapon_wait = YWING_WEAPON_WAIT;
-	otherwing_desc->special_wait = YWING_SPECIAL_WAIT;
-	otherwing_desc->ship_mass = SHIP_MASS;
+	otherwing_desc.max_thrust = YWING_MAX_THRUST;
+	otherwing_desc.thrust_increment = YWING_THRUST_INCREMENT;
+	otherwing_desc.energy_regeneration = YWING_ENERGY_REGENERATION;
+	otherwing_desc.weapon_energy_cost = YWING_WEAPON_ENERGY_COST;
+	otherwing_desc.special_energy_cost = YWING_SPECIAL_ENERGY_COST;
+	otherwing_desc.energy_wait = YWING_ENERGY_WAIT;
+	otherwing_desc.turn_wait = YWING_TURN_WAIT;
+	otherwing_desc.thrust_wait = YWING_THRUST_WAIT;
+	otherwing_desc.weapon_wait = YWING_WEAPON_WAIT;
+	otherwing_desc.special_wait = YWING_SPECIAL_WAIT;
+	otherwing_desc.ship_mass = SHIP_MASS;
 
-	new_mmrnmhrm_desc.data = (intptr_t) otherwing_desc;
+	SetCustomShipData (&new_mmrnmhrm_desc, &otherwing_desc);
 
 	RaceDescPtr = &new_mmrnmhrm_desc;
 
diff -ruNp src.orig/uqm/ships/mmrnmhrm/mmrnmhrm.h src/uqm/ships/mmrnmhrm/mmrnmhrm.h
--- src.orig/uqm/ships/mmrnmhrm/mmrnmhrm.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/mmrnmhrm/mmrnmhrm.h	2017-11-21 19:39:58 -0600
@@ -17,7 +17,15 @@
 #ifndef MMRNMHRM_H
 #define MMRNMHRM_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_mmrnmhrm (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* MMRNMHRM_H */
 
diff -ruNp src.orig/uqm/ships/mmrnmhrm/resinst.h src/uqm/ships/mmrnmhrm/resinst.h
--- src.orig/uqm/ships/mmrnmhrm/resinst.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/mmrnmhrm/resinst.h	2017-11-21 19:39:58 -0600
@@ -1,17 +1,19 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define MMRNMHRM_BIG_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.xform.large"
 #define MMRNMHRM_CAPTAIN_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.captain"
 #define MMRNMHRM_ICON_MASK_PMAP_ANIM "ship.mmrnmhrm.icons"
 #define MMRNMHRM_MED_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.xform.medium"
 #define MMRNMHRM_MICON_MASK_PMAP_ANIM "ship.mmrnmhrm.meleeicons"
+#define MMRNMHRM_RACE_STRINGS "ship.mmrnmhrm.text"
+#define MMRNMHRM_SHIP_SOUNDS "ship.mmrnmhrm.sounds"
 #define MMRNMHRM_SML_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.xform.small"
+#define MMRNMHRM_VICTORY_SONG "ship.mmrnmhrm.ditty"
 #define TORP_BIG_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.torpedo.large"
 #define TORP_MED_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.torpedo.medium"
 #define TORP_SML_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.torpedo.small"
 #define YWING_BIG_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.ywing.large"
 #define YWING_MED_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.ywing.medium"
 #define YWING_SML_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.ywing.small"
-#define MMRNMHRM_RACE_STRINGS "ship.mmrnmhrm.text"
-#define MMRNMHRM_SHIP_SOUNDS "ship.mmrnmhrm.sounds"
-#define MMRNMHRM_VICTORY_SONG "ship.mmrnmhrm.ditty"
-
-#include "icode.h"
diff -ruNp src.orig/uqm/ships/mycon/Makeinfo src/uqm/ships/mycon/Makeinfo
--- src.orig/uqm/ships/mycon/Makeinfo	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/mycon/Makeinfo	2017-11-21 19:39:58 -0600
@@ -1 +1,2 @@
 uqm_CFILES="mycon.c"
+uqm_HFILES="icode.h mycon.h resinst.h"
diff -ruNp src.orig/uqm/ships/mycon/icode.h src/uqm/ships/mycon/icode.h
--- src.orig/uqm/ships/mycon/icode.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/mycon/icode.h	2017-11-21 19:39:58 -0600
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define MYCON_CODE "ship.mycon.code"
diff -ruNp src.orig/uqm/ships/mycon/mycon.c src/uqm/ships/mycon/mycon.c
--- src.orig/uqm/ships/mycon/mycon.c	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/mycon/mycon.c	2017-11-21 19:39:58 -0600
@@ -20,30 +20,39 @@
 #include "mycon.h"
 #include "resinst.h"
 
+// Core characteristics
 #define MAX_CREW 20
 #define MAX_ENERGY 40
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 20
-#define SPECIAL_ENERGY_COST MAX_ENERGY
 #define ENERGY_WAIT 4
 #define MAX_THRUST /* DISPLAY_TO_WORLD (7) */ 27
 #define THRUST_INCREMENT /* DISPLAY_TO_WORLD (2) */ 9
-#define TURN_WAIT 6
 #define THRUST_WAIT 6
-#define WEAPON_WAIT 5
-#define SPECIAL_WAIT 0
-
+#define TURN_WAIT 6
 #define SHIP_MASS 7
 
+// Plasmoid
+#define WEAPON_ENERGY_COST 20
+#define WEAPON_WAIT 5
+#define MYCON_OFFSET 24
+#define MISSILE_OFFSET 0
 #define NUM_PLASMAS 11
 #define NUM_GLOBALLS 8
 #define PLASMA_DURATION 13
 #define MISSILE_LIFE (NUM_PLASMAS * PLASMA_DURATION)
 #define MISSILE_SPEED DISPLAY_TO_WORLD (8)
+#define MISSILE_DAMAGE 10
+#define TRACK_WAIT 1
+
+// Regenerate
+#define SPECIAL_ENERGY_COST MAX_ENERGY
+#define SPECIAL_WAIT 0
+#define REGENERATION_AMOUNT 4
 
 static RACE_DESC mycon_desc =
 {
 	{ /* SHIP_INFO */
+		"podship",
 		FIRES_FORE | SEEKING_WEAPON,
 		21, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -112,10 +121,6 @@ static RACE_DESC mycon_desc =
 	0, /* CodeRef */
 };
 
-#define MISSILE_DAMAGE 10
-
-#define TRACK_WAIT 1
-
 static void
 plasma_preprocess (ELEMENT *ElementPtr)
 {
@@ -297,8 +302,6 @@ mycon_intelligence (ELEMENT *ShipPtr, EV
 static COUNT
 initialize_plasma (ELEMENT *ShipPtr, HELEMENT PlasmaArray[])
 {
-#define MYCON_OFFSET 24
-#define MISSILE_OFFSET 0
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -343,7 +346,6 @@ mycon_postprocess (ELEMENT *ElementPtr)
 			&& ElementPtr->crew_level != StarShipPtr->RaceDescPtr->ship_info.max_crew
 			&& DeltaEnergy (ElementPtr, -SPECIAL_ENERGY_COST))
 	{
-#define REGENERATION_AMOUNT 4
 		SIZE add_crew;
 
 		ProcessSound (SetAbsSoundIndex (
diff -ruNp src.orig/uqm/ships/mycon/mycon.h src/uqm/ships/mycon/mycon.h
--- src.orig/uqm/ships/mycon/mycon.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/mycon/mycon.h	2017-11-21 19:39:58 -0600
@@ -17,7 +17,15 @@
 #ifndef MYCON_H
 #define MYCON_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_mycon (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* MYCON_H */
 
diff -ruNp src.orig/uqm/ships/mycon/resinst.h src/uqm/ships/mycon/resinst.h
--- src.orig/uqm/ships/mycon/resinst.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/mycon/resinst.h	2017-11-21 19:39:58 -0600
@@ -1,14 +1,16 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define MYCON_BIG_MASK_PMAP_ANIM "ship.mycon.graphics.podship.large"
 #define MYCON_CAPTAIN_MASK_PMAP_ANIM "ship.mycon.graphics.captain"
 #define MYCON_ICON_MASK_PMAP_ANIM "ship.mycon.icons"
 #define MYCON_MED_MASK_PMAP_ANIM "ship.mycon.graphics.podship.medium"
 #define MYCON_MICON_MASK_PMAP_ANIM "ship.mycon.meleeicons"
+#define MYCON_RACE_STRINGS "ship.mycon.text"
+#define MYCON_SHIP_SOUNDS "ship.mycon.sounds"
 #define MYCON_SML_MASK_PMAP_ANIM "ship.mycon.graphics.podship.small"
+#define MYCON_VICTORY_SONG "ship.mycon.ditty"
 #define PLASMA_BIG_MASK_PMAP_ANIM "ship.mycon.graphics.plasma.large"
 #define PLASMA_MED_MASK_PMAP_ANIM "ship.mycon.graphics.plasma.medium"
 #define PLASMA_SML_MASK_PMAP_ANIM "ship.mycon.graphics.plasma.small"
-#define MYCON_RACE_STRINGS "ship.mycon.text"
-#define MYCON_SHIP_SOUNDS "ship.mycon.sounds"
-#define MYCON_VICTORY_SONG "ship.mycon.ditty"
-
-#include "icode.h"
diff -ruNp src.orig/uqm/ships/orz/Makeinfo src/uqm/ships/orz/Makeinfo
--- src.orig/uqm/ships/orz/Makeinfo	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/orz/Makeinfo	2017-11-21 19:39:58 -0600
@@ -1 +1,2 @@
 uqm_CFILES="orz.c"
+uqm_HFILES="icode.h orz.h resinst.h"
diff -ruNp src.orig/uqm/ships/orz/icode.h src/uqm/ships/orz/icode.h
--- src.orig/uqm/ships/orz/icode.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/orz/icode.h	2017-11-21 19:39:58 -0600
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define ORZ_CODE "ship.orz.code"
diff -ruNp src.orig/uqm/ships/orz/orz.c src/uqm/ships/orz/orz.c
--- src.orig/uqm/ships/orz/orz.c	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/orz/orz.c	2017-11-21 19:39:58 -0600
@@ -24,28 +24,47 @@
 #include "uqm/globdata.h"
 #include "libs/mathlib.h"
 
-
+// Core characteristics
 #define MAX_CREW 16
 #define MAX_ENERGY 20
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST (MAX_ENERGY / 3)
-#define SPECIAL_ENERGY_COST 0
 #define ENERGY_WAIT 6
 #define MAX_THRUST 35
 #define THRUST_INCREMENT 5
-#define TURN_WAIT 1
 #define THRUST_WAIT 0
-#define WEAPON_WAIT 4
-#define SPECIAL_WAIT 12
-
+#define TURN_WAIT 1
 #define SHIP_MASS 4
+
+// Howitzer
+#define WEAPON_ENERGY_COST (MAX_ENERGY / 3)
+#define WEAPON_WAIT 4
 #define ORZ_OFFSET 9
 #define MISSILE_SPEED DISPLAY_TO_WORLD (30)
 #define MISSILE_LIFE 12
+#define MISSILE_HITS 2
+#define MISSILE_DAMAGE 3
+#define MISSILE_OFFSET 1
+
+// Marine
+#define SPECIAL_ENERGY_COST 0
+#define SPECIAL_WAIT 12
+#define MARINE_MAX_THRUST 32
+#define MARINE_THRUST_INCREMENT 8
+#define MARINE_HIT_POINTS 3
+#define MARINE_MASS_POINTS 1
+#define MAX_MARINES 8
+#define MARINE_WAIT 12
+#define ION_LIFE 1
+#define START_ION_COLOR BUILD_COLOR (MAKE_RGB15 (0x1F, 0x15, 0x00), 0x7A)
+
+// Rotating Turret
+#define TURRET_OFFSET 14
+#define TURRET_WAIT 3
 
 static RACE_DESC orz_desc =
 {
 	{ /* SHIP_INFO */
+		"nemesis",
 		FIRES_FORE | SEEKING_SPECIAL,
 		23, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -122,15 +141,9 @@ howitzer_collision (ELEMENT *ElementPtr0
 		weapon_collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
 }
 
-#define TURRET_OFFSET 14
-#define TURRET_WAIT 3
-
 static COUNT
 initialize_turret_missile (ELEMENT *ShipPtr, HELEMENT MissileArray[])
 {
-#define MISSILE_HITS 2
-#define MISSILE_DAMAGE 3
-#define MISSILE_OFFSET 1
 	ELEMENT *TurretPtr;
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
@@ -180,8 +193,6 @@ initialize_turret_missile (ELEMENT *Ship
 	return (1);
 }
 
-#define MAX_MARINES 8
-
 static BYTE
 count_marines (STARSHIP *StarShipPtr, BOOLEAN FindSpot)
 {
@@ -310,8 +321,6 @@ orz_intelligence (ELEMENT *ShipPtr, EVAL
 	UnlockElement (GetSuccElement (ShipPtr));
 }
 
-#define START_ION_COLOR BUILD_COLOR (MAKE_RGB15 (0x1F, 0x15, 0x00), 0x7A)
-
 static void
 ion_preprocess (ELEMENT *ElementPtr)
 {
@@ -352,8 +361,6 @@ ion_preprocess (ELEMENT *ElementPtr)
 
 static void marine_preprocess (ELEMENT *ElementPtr);
 
-#define MARINE_WAIT 12
-
 void
 intruder_preprocess (ELEMENT *ElementPtr)
 {
@@ -475,7 +482,6 @@ spawn_marine_ion_trail (ELEMENT *Element
 	hIonElement = AllocElement ();
 	if (hIonElement)
 	{
-#define ION_LIFE 1
 		COUNT angle;
 		ELEMENT *IonElementPtr;
 
@@ -698,8 +704,10 @@ marine_preprocess (ELEMENT *ElementPtr)
 			// XXX: thrust_wait is abused to store marine speed and
 			//   gravity well flags
 			StarShipPtr->cur_status_flags = ElementPtr->thrust_wait << 6;
-			StarShipPtr->RaceDescPtr->characteristics.thrust_increment = 8;
-			StarShipPtr->RaceDescPtr->characteristics.max_thrust = 32;
+			StarShipPtr->RaceDescPtr->characteristics.thrust_increment =
+					MARINE_THRUST_INCREMENT;
+			StarShipPtr->RaceDescPtr->characteristics.max_thrust =
+					MARINE_MAX_THRUST;
 
 			thrust_status = inertial_thrust (ElementPtr);
 
@@ -965,8 +973,8 @@ turret_postprocess (ELEMENT *ElementPtr)
 				SpaceMarinePtr->state_flags = IGNORE_SIMILAR | APPEARING
 						| CREW_OBJECT;
 				SpaceMarinePtr->life_span = NORMAL_LIFE;
-				SpaceMarinePtr->hit_points = 3;
-				SpaceMarinePtr->mass_points = 1;
+				SpaceMarinePtr->hit_points = MARINE_HIT_POINTS;
+				SpaceMarinePtr->mass_points = MARINE_MASS_POINTS;
 
 				facing = FACING_TO_ANGLE (StarShipPtr->ShipFacing);
 				SpaceMarinePtr->current.location.x =
diff -ruNp src.orig/uqm/ships/orz/orz.h src/uqm/ships/orz/orz.h
--- src.orig/uqm/ships/orz/orz.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/orz/orz.h	2017-11-21 19:39:58 -0600
@@ -17,11 +17,19 @@
 #ifndef ORZ_H
 #define ORZ_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_orz (void);
 
 void intruder_preprocess (ELEMENT *ElementPtr);
 void marine_collision (ELEMENT *ElementPtr0, POINT *pPt0,
 		ELEMENT *ElementPtr1, POINT *pPt1);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* ORZ_H */
 
diff -ruNp src.orig/uqm/ships/orz/resinst.h src/uqm/ships/orz/resinst.h
--- src.orig/uqm/ships/orz/resinst.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/orz/resinst.h	2017-11-21 19:39:58 -0600
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define HOWITZER_BIG_MASK_PMAP_ANIM "ship.orz.graphics.howitzer.large"
 #define HOWITZER_MED_MASK_PMAP_ANIM "ship.orz.graphics.howitzer.medium"
 #define HOWITZER_SML_MASK_PMAP_ANIM "ship.orz.graphics.howitzer.small"
@@ -6,12 +10,10 @@
 #define ORZ_ICON_MASK_PMAP_ANIM "ship.orz.icons"
 #define ORZ_MED_MASK_PMAP_ANIM "ship.orz.graphics.nemesis.medium"
 #define ORZ_MICON_MASK_PMAP_ANIM "ship.orz.meleeicons"
+#define ORZ_RACE_STRINGS "ship.orz.text"
+#define ORZ_SHIP_SOUNDS "ship.orz.sounds"
 #define ORZ_SML_MASK_PMAP_ANIM "ship.orz.graphics.nemesis.small"
+#define ORZ_VICTORY_SONG "ship.orz.ditty"
 #define TURRET_BIG_MASK_PMAP_ANIM "ship.orz.graphics.turret.large"
 #define TURRET_MED_MASK_PMAP_ANIM "ship.orz.graphics.turret.medium"
 #define TURRET_SML_MASK_PMAP_ANIM "ship.orz.graphics.turret.small"
-#define ORZ_RACE_STRINGS "ship.orz.text"
-#define ORZ_SHIP_SOUNDS "ship.orz.sounds"
-#define ORZ_VICTORY_SONG "ship.orz.ditty"
-
-#include "icode.h"
diff -ruNp src.orig/uqm/ships/pkunk/Makeinfo src/uqm/ships/pkunk/Makeinfo
--- src.orig/uqm/ships/pkunk/Makeinfo	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/pkunk/Makeinfo	2017-11-21 19:39:58 -0600
@@ -1 +1,2 @@
 uqm_CFILES="pkunk.c"
+uqm_HFILES="icode.h pkunk.h resinst.h"
diff -ruNp src.orig/uqm/ships/pkunk/icode.h src/uqm/ships/pkunk/icode.h
--- src.orig/uqm/ships/pkunk/icode.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/pkunk/icode.h	2017-11-21 19:39:58 -0600
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define PKUNK_CODE "ship.pkunk.code"
diff -ruNp src.orig/uqm/ships/pkunk/pkunk.c src/uqm/ships/pkunk/pkunk.c
--- src.orig/uqm/ships/pkunk/pkunk.c	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/pkunk/pkunk.c	2017-11-21 19:39:58 -0600
@@ -21,29 +21,44 @@
 #include "resinst.h"
 
 #include "uqm/globdata.h"
+#include "uqm/tactrans.h"
 #include "libs/mathlib.h"
 
-
+// Core characteristics
 #define MAX_CREW 8
 #define MAX_ENERGY 12
 #define ENERGY_REGENERATION 0
-#define WEAPON_ENERGY_COST 1
-#define SPECIAL_ENERGY_COST 2
 #define ENERGY_WAIT 0
 #define MAX_THRUST 64
 #define THRUST_INCREMENT 16
-#define TURN_WAIT 0
 #define THRUST_WAIT 0
-#define WEAPON_WAIT 0
-#define SPECIAL_WAIT 16
-
+#define TURN_WAIT 0
 #define SHIP_MASS 1
+
+// Triple Miniguns
+#define WEAPON_ENERGY_COST 1
+#define WEAPON_WAIT 0
+#define PKUNK_OFFSET 15
+#define MISSILE_OFFSET 1
 #define MISSILE_SPEED DISPLAY_TO_WORLD (24)
 #define MISSILE_LIFE 5
+#define MISSILE_HITS 1
+#define MISSILE_DAMAGE 1
+
+// Taunt
+#define SPECIAL_ENERGY_COST 2
+#define SPECIAL_WAIT 16
+
+// Respawn
+#define PHOENIX_LIFE 12
+#define START_PHOENIX_COLOR BUILD_COLOR (MAKE_RGB15 (0x1F, 0x15, 0x00), 0x7A)
+#define TRANSITION_LIFE 1
+#define TRANSITION_SPEED DISPLAY_TO_WORLD (20)
 
 static RACE_DESC pkunk_desc =
 {
 	{ /* SHIP_INFO */
+		"fury",
 		FIRES_FORE | FIRES_LEFT | FIRES_RIGHT,
 		20, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -112,6 +127,48 @@ static RACE_DESC pkunk_desc =
 	0, /* CodeRef */
 };
 
+// Private per-instance ship data
+typedef struct
+{
+	HELEMENT hPhoenix;
+	ElementProcessFunc *saved_preprocess_func;
+	ElementProcessFunc *saved_postprocess_func;
+	ElementProcessFunc *saved_death_func;
+	
+} PKUNK_DATA;
+
+// Local typedef
+typedef PKUNK_DATA CustomShipData_t;
+
+// Retrieve race-specific ship data from a race desc
+static CustomShipData_t *
+GetCustomShipData (RACE_DESC *pRaceDesc)
+{
+	return pRaceDesc->data;
+}
+
+// Set the race-specific data in a race desc
+// (Re)Allocates its own storage for the data.
+static void
+SetCustomShipData (RACE_DESC *pRaceDesc, const CustomShipData_t *data)
+{
+	if (pRaceDesc->data == data) 
+		return;  // no-op
+
+	if (pRaceDesc->data) // Out with the old
+	{
+		HFree (pRaceDesc->data);
+		pRaceDesc->data = NULL;
+	}
+
+	if (data) // In with the new
+	{
+		CustomShipData_t* newData = HMalloc (sizeof (*data));
+		*newData = *data;
+		pRaceDesc->data = newData;
+	}
+}
+
 static void
 animate (ELEMENT *ElementPtr)
 {
@@ -130,10 +187,6 @@ animate (ELEMENT *ElementPtr)
 static COUNT
 initialize_bug_missile (ELEMENT *ShipPtr, HELEMENT MissileArray[])
 {
-#define PKUNK_OFFSET 15
-#define MISSILE_HITS 1
-#define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET 1
 	COUNT i;
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
@@ -186,15 +239,15 @@ pkunk_intelligence (ELEMENT *ShipPtr, EV
 		COUNT ConcernCounter)
 {
 	STARSHIP *StarShipPtr;
-	HELEMENT hPhoenix;
+	PKUNK_DATA *PkunkData;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
-	hPhoenix = (HELEMENT) StarShipPtr->RaceDescPtr->data;
-	if (hPhoenix && (StarShipPtr->control & STANDARD_RATING))
+	PkunkData = GetCustomShipData (StarShipPtr->RaceDescPtr);
+	if (PkunkData->hPhoenix && (StarShipPtr->control & STANDARD_RATING))
 	{
-		RemoveElement (hPhoenix);
-		FreeElement (hPhoenix);
-		StarShipPtr->RaceDescPtr->data = 0;
+		RemoveElement (PkunkData->hPhoenix);
+		FreeElement (PkunkData->hPhoenix);
+		PkunkData->hPhoenix = 0;
 	}
 
 	if (StarShipPtr->RaceDescPtr->ship_info.energy_level <
@@ -208,113 +261,118 @@ pkunk_intelligence (ELEMENT *ShipPtr, EV
 }
 
 static void pkunk_preprocess (ELEMENT *ElementPtr);
-static void pkunk_postprocess (ELEMENT *ElementPtr);
 
 static void
 new_pkunk (ELEMENT *ElementPtr)
 {
 	STARSHIP *StarShipPtr;
+	PKUNK_DATA *PkunkData;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
-	if (!(ElementPtr->state_flags & PLAYER_SHIP))
-	{
-		ELEMENT *ShipPtr;
+	PkunkData = GetCustomShipData (StarShipPtr->RaceDescPtr);
 
-		LockElement (StarShipPtr->hShip, &ShipPtr);
-		ShipPtr->death_func = new_pkunk;
-		UnlockElement (StarShipPtr->hShip);
-	}
-	else
-	{
-		ElementPtr->state_flags = APPEARING | PLAYER_SHIP | IGNORE_SIMILAR;
-		ElementPtr->mass_points = SHIP_MASS;
-		ElementPtr->preprocess_func = StarShipPtr->RaceDescPtr->preprocess_func;
-		ElementPtr->postprocess_func = StarShipPtr->RaceDescPtr->postprocess_func;
-		ElementPtr->death_func =
-				(void (*) (ELEMENT *ElementPtr))
-						StarShipPtr->RaceDescPtr->init_weapon_func;
-		StarShipPtr->RaceDescPtr->preprocess_func = pkunk_preprocess;
-		StarShipPtr->RaceDescPtr->postprocess_func = pkunk_postprocess;
-		StarShipPtr->RaceDescPtr->init_weapon_func = initialize_bug_missile;
-		StarShipPtr->RaceDescPtr->ship_info.crew_level = MAX_CREW;
-		StarShipPtr->RaceDescPtr->ship_info.energy_level = MAX_ENERGY;
-					/* fix vux impairment */
-		StarShipPtr->RaceDescPtr->characteristics.max_thrust = MAX_THRUST;
-		StarShipPtr->RaceDescPtr->characteristics.thrust_increment = THRUST_INCREMENT;
-		StarShipPtr->RaceDescPtr->characteristics.turn_wait = TURN_WAIT;
-		StarShipPtr->RaceDescPtr->characteristics.thrust_wait = THRUST_WAIT;
-		StarShipPtr->RaceDescPtr->characteristics.special_wait = 0;
-
-		StarShipPtr->ship_input_state = 0;
-		StarShipPtr->cur_status_flags = 0;
-		StarShipPtr->old_status_flags = 0;
-		StarShipPtr->energy_counter = 0;
-		StarShipPtr->weapon_counter = 0;
-		StarShipPtr->special_counter = 0;
-		ElementPtr->crew_level = 0;
-		ElementPtr->turn_wait = 0;
-		ElementPtr->thrust_wait = 0;
-		ElementPtr->life_span = NORMAL_LIFE;
-
-		StarShipPtr->ShipFacing = NORMALIZE_FACING (TFB_Random ());
-		ElementPtr->current.image.farray = StarShipPtr->RaceDescPtr->ship_data.ship;
-		ElementPtr->current.image.frame =
-				SetAbsFrameIndex (StarShipPtr->RaceDescPtr->ship_data.ship[0],
-				StarShipPtr->ShipFacing);
-		SetPrimType (&(GLOBAL (DisplayArray))[
-				ElementPtr->PrimIndex
-				], STAMP_PRIM);
-
-		do
-		{
-			ElementPtr->current.location.x =
-					WRAP_X (DISPLAY_ALIGN_X (TFB_Random ()));
-			ElementPtr->current.location.y =
-					WRAP_Y (DISPLAY_ALIGN_Y (TFB_Random ()));
-		} while (CalculateGravity (ElementPtr)
-				|| TimeSpaceMatterConflict (ElementPtr));
+	ElementPtr->state_flags = APPEARING | PLAYER_SHIP | IGNORE_SIMILAR;
+	ElementPtr->mass_points = SHIP_MASS;
+	// Restore the element processing callbacks after the explosion.
+	// The callbacks were changed for the explosion sequence
+	ElementPtr->preprocess_func = PkunkData->saved_preprocess_func;
+	ElementPtr->postprocess_func = PkunkData->saved_postprocess_func;
+	ElementPtr->death_func = PkunkData->saved_death_func;
+	// preprocess_func() is called during the phoenix transition and
+	// then cleared, so we need to restore it
+	StarShipPtr->RaceDescPtr->preprocess_func = pkunk_preprocess;
+	StarShipPtr->RaceDescPtr->ship_info.crew_level = MAX_CREW;
+	StarShipPtr->RaceDescPtr->ship_info.energy_level = MAX_ENERGY;
+				/* fix vux impairment */
+	StarShipPtr->RaceDescPtr->characteristics.max_thrust = MAX_THRUST;
+	StarShipPtr->RaceDescPtr->characteristics.thrust_increment = THRUST_INCREMENT;
+	StarShipPtr->RaceDescPtr->characteristics.turn_wait = TURN_WAIT;
+	StarShipPtr->RaceDescPtr->characteristics.thrust_wait = THRUST_WAIT;
+	StarShipPtr->RaceDescPtr->characteristics.special_wait = 0;
+
+	StarShipPtr->ship_input_state = 0;
+	// Pkunk wins in a simultaneous destruction if it reincarnates
+	StarShipPtr->cur_status_flags &= PLAY_VICTORY_DITTY;
+	StarShipPtr->old_status_flags = 0;
+	StarShipPtr->energy_counter = 0;
+	StarShipPtr->weapon_counter = 0;
+	StarShipPtr->special_counter = 0;
+	ElementPtr->crew_level = 0;
+	ElementPtr->turn_wait = 0;
+	ElementPtr->thrust_wait = 0;
+	ElementPtr->life_span = NORMAL_LIFE;
+
+	StarShipPtr->ShipFacing = NORMALIZE_FACING (TFB_Random ());
+	ElementPtr->current.image.farray = StarShipPtr->RaceDescPtr->ship_data.ship;
+	ElementPtr->current.image.frame = SetAbsFrameIndex (
+			StarShipPtr->RaceDescPtr->ship_data.ship[0],
+			StarShipPtr->ShipFacing);
+	SetPrimType (&(GLOBAL (DisplayArray))[ElementPtr->PrimIndex], STAMP_PRIM);
+
+	do
+	{
+		ElementPtr->current.location.x =
+				WRAP_X (DISPLAY_ALIGN_X (TFB_Random ()));
+		ElementPtr->current.location.y =
+				WRAP_Y (DISPLAY_ALIGN_Y (TFB_Random ()));
+	} while (CalculateGravity (ElementPtr)
+			|| TimeSpaceMatterConflict (ElementPtr));
+
+	// XXX: Hack: Set hTarget!=0 so that ship_preprocess() does not
+	//   call ship_transition() for us.
+	ElementPtr->hTarget = StarShipPtr->hShip;
+}
 
-		ElementPtr->hTarget = StarShipPtr->hShip;
-	}
+// This function is called when the ship dies but reincarnates.
+// The generic ship_death() function is not called for the ship in this case.
+static void
+pkunk_reincarnation_death (ELEMENT *ShipPtr)
+{
+	// Simulate ship death
+	StopAllBattleMusic ();
+	StartShipExplosion (ShipPtr, true);
+	// Once the explosion ends, we will get a brand new ship
+	ShipPtr->death_func = new_pkunk;
 }
 
 static void
 intercept_pkunk_death (ELEMENT *ElementPtr)
 {
 	STARSHIP *StarShipPtr;
-
-	ElementPtr->state_flags &= ~DISAPPEARING;
-	ElementPtr->life_span = 1;
+	PKUNK_DATA *PkunkData;
+	ELEMENT *ShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
-	if (StarShipPtr->RaceDescPtr->ship_info.crew_level == 0)
-	{
-		ELEMENT *ShipPtr;
+	PkunkData = GetCustomShipData (StarShipPtr->RaceDescPtr);
+	
+	if (StarShipPtr->RaceDescPtr->ship_info.crew_level != 0)
+	{	// Ship not dead yet.
+		// Keep the Phoenix element alive.
+		ElementPtr->state_flags &= ~DISAPPEARING;
+		ElementPtr->life_span = 1;
+		return;
+	}
 
-		LockElement (StarShipPtr->hShip, &ShipPtr);
-		if (GRAVITY_MASS (ShipPtr->mass_points + 1))
-		{
-			ElementPtr->state_flags |= DISAPPEARING;
-			ElementPtr->life_span = 0;
-		}
-		else
-		{
-			ShipPtr->mass_points = MAX_SHIP_MASS + 1;
-			StarShipPtr->RaceDescPtr->preprocess_func = ShipPtr->preprocess_func;
-			StarShipPtr->RaceDescPtr->postprocess_func = ShipPtr->postprocess_func;
-			StarShipPtr->RaceDescPtr->init_weapon_func =
-					(COUNT (*) (ELEMENT *ElementPtr, HELEMENT Weapon[]))
-							ShipPtr->death_func;
+	LockElement (StarShipPtr->hShip, &ShipPtr);
+	// GRAVITY_MASS() indicates a warp-out here. If Pkunk dies while warping
+	// out, there is no reincarnation.
+	if (!GRAVITY_MASS (ShipPtr->mass_points + 1))
+	{
+		// XXX: Hack: Set mass_points to indicate a reincarnation to
+		//   FindAliveStarShip()
+		ShipPtr->mass_points = MAX_SHIP_MASS + 1;
+		// Save the various element processing callbacks before the
+		// explosion happens, because we were not the ones who set
+		// these callbacks and they are about to be changed.
+		PkunkData->saved_preprocess_func = ShipPtr->preprocess_func;
+		PkunkData->saved_postprocess_func = ShipPtr->postprocess_func;
+		PkunkData->saved_death_func = ShipPtr->death_func;
 
-			ElementPtr->death_func = new_pkunk;
-		}
-		UnlockElement (StarShipPtr->hShip);
+		ShipPtr->death_func = pkunk_reincarnation_death;
 	}
+	UnlockElement (StarShipPtr->hShip);
 }
 
-#define START_PHOENIX_COLOR BUILD_COLOR (MAKE_RGB15 (0x1F, 0x15, 0x00), 0x7A)
-#define TRANSITION_LIFE 1
-
 static void
 spawn_phoenix_trail (ELEMENT *ElementPtr)
 {
@@ -348,8 +406,6 @@ spawn_phoenix_trail (ELEMENT *ElementPtr
 	} // else, the element disappears.
 }
 
-#define PHOENIX_LIFE 12
-
 static void
 phoenix_transition (ELEMENT *ElementPtr)
 {
@@ -366,7 +422,6 @@ phoenix_transition (ELEMENT *ElementPtr)
 	}
 	else if ((hShipImage = AllocElement ()))
 	{
-#define TRANSITION_SPEED DISPLAY_TO_WORLD (20)
 		COUNT angle;
 
 		PutElement (hShipImage);
@@ -425,15 +480,22 @@ static void
 pkunk_preprocess (ELEMENT *ElementPtr)
 {
 	STARSHIP *StarShipPtr;
+	PKUNK_DATA *PkunkData;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
+	PkunkData = GetCustomShipData (StarShipPtr->RaceDescPtr);
 	if (ElementPtr->state_flags & APPEARING)
 	{
 		HELEMENT hPhoenix = 0;
 
-		if ((BYTE)TFB_Random () & 1)
+		if (TFB_Random () & 1)
 			hPhoenix = AllocElement ();
 
+		// The hPhoenix element is created and placed at the head of the
+		// queue so that it is preprocessed before any of the ships' elements
+		// are, and so before death_func() is called for the dead Pkunk.
+		// hPhoenix detects when the Pkunk ship dies and tweaks the ship,
+		// starting the death + reincarnation sequence.
 		if (hPhoenix)
 		{
 			ELEMENT *PhoenixPtr;
@@ -450,12 +512,17 @@ pkunk_preprocess (ELEMENT *ElementPtr)
 			UnlockElement (hPhoenix);
 			InsertElement (hPhoenix, GetHeadElement ());
 		}
-		StarShipPtr->RaceDescPtr->data = (intptr_t) hPhoenix;
+		PkunkData->hPhoenix = hPhoenix;
 
+		// XXX: Hack: new_pkunk() sets hTarget!=0 which indicates a
+		//   reincarnation to us.
 		if (ElementPtr->hTarget == 0)
+		{
+			// A brand new ship is preprocessed only once
 			StarShipPtr->RaceDescPtr->preprocess_func = 0;
+		}
 		else
-		{
+		{	// Start the reincarnation sequence
 			COUNT angle, facing;
 
 			ProcessSound (SetAbsSoundIndex (
@@ -538,17 +605,32 @@ pkunk_postprocess (ELEMENT *ElementPtr)
 	}
 }
 
+static void
+uninit_pkunk (RACE_DESC *pRaceDesc)
+{
+	SetCustomShipData (pRaceDesc, NULL);
+}
+
 RACE_DESC*
 init_pkunk (void)
 {
 	RACE_DESC *RaceDescPtr;
+	// The caller of this func will copy the struct
+	static RACE_DESC new_pkunk_desc;
+	PKUNK_DATA empty_data;
+	memset (&empty_data, 0, sizeof (empty_data));
 
+	pkunk_desc.uninit_func = uninit_pkunk;
 	pkunk_desc.preprocess_func = pkunk_preprocess;
 	pkunk_desc.postprocess_func = pkunk_postprocess;
 	pkunk_desc.init_weapon_func = initialize_bug_missile;
 	pkunk_desc.cyborg_control.intelligence_func = pkunk_intelligence;
 
-	RaceDescPtr = &pkunk_desc;
+	/* copy initial ship settings to the new descriptor */
+	new_pkunk_desc = pkunk_desc;
+	SetCustomShipData (&new_pkunk_desc, &empty_data);
+
+	RaceDescPtr = &new_pkunk_desc;
 
 	LastSound = 0;
 			// We need to reinitialise it at least each battle, to ensure
@@ -557,4 +639,3 @@ init_pkunk (void)
 
 	return (RaceDescPtr);
 }
-
diff -ruNp src.orig/uqm/ships/pkunk/pkunk.h src/uqm/ships/pkunk/pkunk.h
--- src.orig/uqm/ships/pkunk/pkunk.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/pkunk/pkunk.h	2017-11-21 19:39:58 -0600
@@ -17,7 +17,15 @@
 #ifndef PKUNK_H
 #define PKUNK_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_pkunk (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* PKUNK_H */
 
diff -ruNp src.orig/uqm/ships/pkunk/resinst.h src/uqm/ships/pkunk/resinst.h
--- src.orig/uqm/ships/pkunk/resinst.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/pkunk/resinst.h	2017-11-21 19:39:58 -0600
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define BUG_BIG_MASK_PMAP_ANIM "ship.pkunk.graphics.bug.large"
 #define BUG_MED_MASK_PMAP_ANIM "ship.pkunk.graphics.bug.medium"
 #define BUG_SML_MASK_PMAP_ANIM "ship.pkunk.graphics.bug.small"
@@ -6,9 +10,7 @@
 #define PKUNK_ICON_MASK_PMAP_ANIM "ship.pkunk.icons"
 #define PKUNK_MED_MASK_PMAP_ANIM "ship.pkunk.graphics.fury.medium"
 #define PKUNK_MICON_MASK_PMAP_ANIM "ship.pkunk.meleeicons"
-#define PKUNK_SML_MASK_PMAP_ANIM "ship.pkunk.graphics.fury.small"
 #define PKUNK_RACE_STRINGS "ship.pkunk.text"
 #define PKUNK_SHIP_SOUNDS "ship.pkunk.sounds"
+#define PKUNK_SML_MASK_PMAP_ANIM "ship.pkunk.graphics.fury.small"
 #define PKUNK_VICTORY_SONG "ship.pkunk.ditty"
-
-#include "icode.h"
diff -ruNp src.orig/uqm/ships/probe/Makeinfo src/uqm/ships/probe/Makeinfo
--- src.orig/uqm/ships/probe/Makeinfo	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/probe/Makeinfo	2017-11-21 19:39:58 -0600
@@ -1 +1,2 @@
 uqm_CFILES="probe.c"
+uqm_HFILES="icode.h probe.h resinst.h"
diff -ruNp src.orig/uqm/ships/probe/icode.h src/uqm/ships/probe/icode.h
--- src.orig/uqm/ships/probe/icode.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/probe/icode.h	2017-11-21 19:39:58 -0600
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define URQUAN_DRONE_CODE "ship.drone.code"
diff -ruNp src.orig/uqm/ships/probe/probe.c src/uqm/ships/probe/probe.c
--- src.orig/uqm/ships/probe/probe.c	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/probe/probe.c	2017-11-21 19:39:59 -0600
@@ -38,6 +38,7 @@
 static RACE_DESC probe_desc =
 {
 	{ /* SHIP_INFO */
+		"urquanprobe",
 		0,
 		0, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
diff -ruNp src.orig/uqm/ships/probe/probe.h src/uqm/ships/probe/probe.h
--- src.orig/uqm/ships/probe/probe.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/probe/probe.h	2017-11-21 19:39:59 -0600
@@ -17,7 +17,15 @@
 #ifndef PROBE_H
 #define PROBE_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_probe (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* PROBE_H */
 
diff -ruNp src.orig/uqm/ships/probe/resinst.h src/uqm/ships/probe/resinst.h
--- src.orig/uqm/ships/probe/resinst.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/probe/resinst.h	2017-11-21 19:39:59 -0600
@@ -1,3 +1,5 @@
-#define URQUAN_DRONE_MICON_MASK_PMAP_ANIM "ship.drone.meleeicons"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
-#include "icode.h"
+#define URQUAN_DRONE_MICON_MASK_PMAP_ANIM "ship.drone.meleeicons"
diff -ruNp src.orig/uqm/ships/shofixti/Makeinfo src/uqm/ships/shofixti/Makeinfo
--- src.orig/uqm/ships/shofixti/Makeinfo	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/shofixti/Makeinfo	2017-11-21 19:39:59 -0600
@@ -1 +1,2 @@
 uqm_CFILES="shofixti.c"
+uqm_HFILES="icode.h resinst.h shofixti.h"
diff -ruNp src.orig/uqm/ships/shofixti/icode.h src/uqm/ships/shofixti/icode.h
--- src.orig/uqm/ships/shofixti/icode.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/shofixti/icode.h	2017-11-21 19:39:59 -0600
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SHOFIXTI_CODE "ship.shofixti.code"
diff -ruNp src.orig/uqm/ships/shofixti/resinst.h src/uqm/ships/shofixti/resinst.h
--- src.orig/uqm/ships/shofixti/resinst.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/shofixti/resinst.h	2017-11-21 19:39:59 -0600
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define DART_BIG_MASK_PMAP_ANIM "ship.shofixti.graphics.missile.large"
 #define DART_MED_MASK_PMAP_ANIM "ship.shofixti.graphics.missile.medium"
 #define DART_SML_MASK_PMAP_ANIM "ship.shofixti.graphics.missile.small"
@@ -13,9 +17,7 @@
 #define SHOFIXTI_ICON_MASK_PMAP_ANIM "ship.shofixti.icons"
 #define SHOFIXTI_MED_MASK_PMAP_ANIM "ship.shofixti.graphics.scout.medium"
 #define SHOFIXTI_MICON_MASK_PMAP_ANIM "ship.shofixti.meleeicons"
-#define SHOFIXTI_SML_MASK_PMAP_ANIM "ship.shofixti.graphics.scout.small"
 #define SHOFIXTI_RACE_STRINGS "ship.shofixti.text"
 #define SHOFIXTI_SHIP_SOUNDS "ship.shofixti.sounds"
+#define SHOFIXTI_SML_MASK_PMAP_ANIM "ship.shofixti.graphics.scout.small"
 #define SHOFIXTI_VICTORY_SONG "ship.shofixti.ditty"
-
-#include "icode.h"
diff -ruNp src.orig/uqm/ships/shofixti/shofixti.c src/uqm/ships/shofixti/shofixti.c
--- src.orig/uqm/ships/shofixti/shofixti.c	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/shofixti/shofixti.c	2017-11-21 19:39:59 -0600
@@ -21,14 +21,13 @@
 #include "resinst.h"
 
 #include "uqm/globdata.h"
+#include "uqm/tactrans.h"
 #include "libs/mathlib.h"
 
-
+// Core characteristics
 #define MAX_CREW 6
 #define MAX_ENERGY 4
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 1
-#define SPECIAL_ENERGY_COST 0
 #define ENERGY_WAIT 9
 #define MAX_THRUST 35
 #define THRUST_INCREMENT 5
@@ -36,14 +35,29 @@
 #define THRUST_WAIT 0
 #define WEAPON_WAIT 3
 #define SPECIAL_WAIT 0
-
 #define SHIP_MASS 1
+
+// Dart Gun
+#define WEAPON_ENERGY_COST 1
+#define SHOFIXTI_OFFSET 15
+#define MISSILE_OFFSET 1
 #define MISSILE_SPEED DISPLAY_TO_WORLD (24)
 #define MISSILE_LIFE 10
+#define MISSILE_HITS 1
+#define MISSILE_DAMAGE 1
+
+// Glory Device
+#define SPECIAL_ENERGY_COST 0
+#define DESTRUCT_RANGE 180
+#define MAX_DESTRUCTION (DESTRUCT_RANGE / 10)
+
+// Full game: Tanaka/Katana's damaged ships
+#define NUM_LIMPETS 3
 
 static RACE_DESC shofixti_desc =
 {
 	{ /* SHIP_INFO */
+		"scout",
 		FIRES_FORE,
 		5, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -115,10 +129,7 @@ static RACE_DESC shofixti_desc =
 static COUNT
 initialize_standard_missile (ELEMENT *ShipPtr, HELEMENT MissileArray[])
 {
-#define SHOFIXTI_OFFSET 15
-#define MISSILE_HITS 1
-#define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET 1
+
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -212,10 +223,10 @@ destruct_preprocess (ELEMENT *ElementPtr
 			PutElement (hDestruct);
 			LockElement (hDestruct, &DestructPtr);
 			SetElementStarShip (DestructPtr, StarShipPtr);
-			DestructPtr->hit_points = DestructPtr->mass_points = 0;
+			DestructPtr->hit_points = 0;
+			DestructPtr->mass_points = 0;
 			DestructPtr->playerNr = NEUTRAL_PLAYER_NUM;
 			DestructPtr->state_flags = APPEARING | FINITE_LIFE | NONSOLID;
-			DestructPtr->life_span = (NUM_EXPLOSION_FRAMES - 3) - 1;
 			SetPrimType (&(GLOBAL (DisplayArray))[DestructPtr->PrimIndex],
 					STAMPFILL_PRIM);
 			SetPrimColor (&(GLOBAL (DisplayArray))[DestructPtr->PrimIndex],
@@ -224,6 +235,8 @@ destruct_preprocess (ELEMENT *ElementPtr
 					StarShipPtr->RaceDescPtr->ship_data.special;
 			DestructPtr->current.image.frame =
 					StarShipPtr->RaceDescPtr->ship_data.special[0];
+			DestructPtr->life_span = GetFrameCount (
+					DestructPtr->current.image.frame);
 			DestructPtr->current.location = ElementPtr->current.location;
 			DestructPtr->preprocess_func = destruct_preprocess;
 			DestructPtr->postprocess_func = NULL;
@@ -240,110 +253,145 @@ destruct_preprocess (ELEMENT *ElementPtr
 #define ORZ_MARINE(ptr) (ptr->preprocess_func == intruder_preprocess && \
 		ptr->collision_func == marine_collision)
 
-// XXX: This function should be split into two
 static void
-self_destruct (ELEMENT *ElementPtr)
+self_destruct_kill_objects (ELEMENT *ElementPtr)
 {
-	STARSHIP *StarShipPtr;
+	// This is called during PostProcessQueue(), close to or at the end,
+	// for the temporary destruct element to apply the effects of glory
+	// explosion. The effects are not seen until the next frame.
+	HELEMENT hElement, hNextElement;
 
-	GetElementStarShip (ElementPtr, &StarShipPtr);
-	if (ElementPtr->state_flags & PLAYER_SHIP)
+	for (hElement = GetHeadElement (); hElement != 0; hElement = hNextElement)
 	{
-		HELEMENT hDestruct;
-		
-		// Spawn a temporary element, which dies in this same frame, in order
-		// to defer the effects of the glory explosion.
-		// It will be the last element (or one of the last) for which the
-		// death_func will be called from PostProcessQueue() in this frame.
-		hDestruct = AllocElement ();
-		if (hDestruct)
-		{
-			ELEMENT *DestructPtr;
+		ELEMENT *ObjPtr;
+		SIZE delta_x, delta_y;
+		DWORD dist;
 
-			LockElement (hDestruct, &DestructPtr);
-			DestructPtr->playerNr = ElementPtr->playerNr;
-			DestructPtr->state_flags = APPEARING | NONSOLID | FINITE_LIFE;
-			DestructPtr->next.location = ElementPtr->next.location;
-			DestructPtr->life_span = 0;
-			DestructPtr->pParent = ElementPtr->pParent;
-			DestructPtr->hTarget = 0;
+		LockElement (hElement, &ObjPtr);
+		hNextElement = GetSuccElement (ObjPtr);
 
-			DestructPtr->death_func = self_destruct;
+		if (!CollidingElement (ObjPtr) && !ORZ_MARINE (ObjPtr))
+		{
+			UnlockElement (hElement);
+			continue;
+		}
 
-			UnlockElement (hDestruct);
+		delta_x = ObjPtr->next.location.x - ElementPtr->next.location.x;
+		if (delta_x < 0)
+			delta_x = -delta_x;
+		delta_y = ObjPtr->next.location.y - ElementPtr->next.location.y;
+		if (delta_y < 0)
+			delta_y = -delta_y;
+		delta_x = WORLD_TO_DISPLAY (delta_x);
+		delta_y = WORLD_TO_DISPLAY (delta_y);
+		dist = delta_x * delta_x + delta_y * delta_y;
+		if (delta_x <= DESTRUCT_RANGE && delta_y <= DESTRUCT_RANGE
+				&& dist <= DESTRUCT_RANGE * DESTRUCT_RANGE)
+		{
+			int destruction = 1 + MAX_DESTRUCTION *
+					(DESTRUCT_RANGE - square_root (dist)) / DESTRUCT_RANGE;
 
-			PutElement (hDestruct);
+			// XXX: Why not simply call do_damage()?
+			if (ObjPtr->state_flags & PLAYER_SHIP)
+			{
+				if (!DeltaCrew (ObjPtr, -destruction))
+					ObjPtr->life_span = 0;
+			}
+			else if (!GRAVITY_MASS (ObjPtr->mass_points))
+			{
+				if (destruction < ObjPtr->hit_points)
+					ObjPtr->hit_points -= destruction;
+				else
+				{
+					ObjPtr->hit_points = 0;
+					ObjPtr->life_span = 0;
+				}
+			}
 		}
 
-		ElementPtr->state_flags |= NONSOLID;
-		// The ship is now dead. It's death_func, i.e. ship_death(), will be
-		// called the next frame.
-		ElementPtr->life_span = 0;
-
-		ElementPtr->preprocess_func = destruct_preprocess;
+		UnlockElement (hElement);
 	}
-	else
-	{
-		// This is called during PostProcessQueue(), close to or at the end,
-		// for the temporary destruct element to apply the effects of glory
-		// explosion. The effects are not seen until the next frame.
-		HELEMENT hElement, hNextElement;
+}
 
-		for (hElement = GetHeadElement ();
-				hElement != 0; hElement = hNextElement)
-		{
-			ELEMENT *ObjPtr;
+// This function is called when the ship dies via Glory Device.
+// The generic ship_death() function is not called for the ship in this case.
+static void
+shofixti_destruct_death (ELEMENT *ShipPtr)
+{
+	STARSHIP *StarShip;
+	STARSHIP *winner;
 
-			LockElement (hElement, &ObjPtr);
-			hNextElement = GetSuccElement (ObjPtr);
+	GetElementStarShip (ShipPtr, &StarShip);
 
-			if (CollidingElement (ObjPtr) || ORZ_MARINE (ObjPtr))
-			{
-#define DESTRUCT_RANGE 180
-				SIZE delta_x, delta_y;
-				DWORD dist;
+	StopAllBattleMusic ();
 
-				if ((delta_x = ObjPtr->next.location.x
-						- ElementPtr->next.location.x) < 0)
-					delta_x = -delta_x;
-				if ((delta_y = ObjPtr->next.location.y
-						- ElementPtr->next.location.y) < 0)
-					delta_y = -delta_y;
-				delta_x = WORLD_TO_DISPLAY (delta_x);
-				delta_y = WORLD_TO_DISPLAY (delta_y);
-				if (delta_x <= DESTRUCT_RANGE && delta_y <= DESTRUCT_RANGE
-						&& (dist = (DWORD)(delta_x * delta_x)
-						+ (DWORD)(delta_y * delta_y)) <=
-						(DWORD)(DESTRUCT_RANGE * DESTRUCT_RANGE))
-				{
-#define MAX_DESTRUCTION (DESTRUCT_RANGE / 10)
-					SIZE destruction;
+	StartShipExplosion (ShipPtr, false);
+	// We process the explosion ourselves because it is different
+	ShipPtr->preprocess_func = destruct_preprocess;
+	
+	PlaySound (SetAbsSoundIndex (StarShip->RaceDescPtr->ship_data.ship_sounds,
+			1), CalcSoundPosition (ShipPtr), ShipPtr, GAME_SOUND_PRIORITY + 1);
+
+	winner = GetWinnerStarShip ();
+	if (winner == NULL)
+	{	// No winner determined yet
+		winner = FindAliveStarShip (ShipPtr);
+		if (winner == NULL)
+		{	// No ships left alive after the Glory Device thus Shofixti wins
+			winner = StarShip;
+		}
+		SetWinnerStarShip (winner);
+	}
+	else if (winner == StarShip)
+	{	// This ship is the winner
+		// It may have self-destructed before the ditty started playing,
+		// and in that case, there should be no ditty
+		StarShip->cur_status_flags &= ~PLAY_VICTORY_DITTY;
+	}
+	RecordShipDeath (ShipPtr);
+}
 
-					destruction = ((MAX_DESTRUCTION
-							* (DESTRUCT_RANGE - square_root (dist)))
-							/ DESTRUCT_RANGE) + 1;
-
-					if (ObjPtr->state_flags & PLAYER_SHIP)
-					{
-						if (!DeltaCrew (ObjPtr, -destruction))
-							ObjPtr->life_span = 0;
-					}
-					else if (!GRAVITY_MASS (ObjPtr->mass_points))
-					{
-						if ((BYTE)destruction < ObjPtr->hit_points)
-							ObjPtr->hit_points -= (BYTE)destruction;
-						else
-						{
-							ObjPtr->hit_points = 0;
-							ObjPtr->life_span = 0;
-						}
-					}
-				}
-			}
+static void
+self_destruct (ELEMENT *ElementPtr)
+{
+	STARSHIP *StarShipPtr;
+	HELEMENT hDestruct;
 
-			UnlockElement (hElement);
-		}
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+		
+	// Spawn a temporary element, which dies in this same frame, in order
+	// to defer the effects of the glory explosion.
+	// It will be the last element (or one of the last) for which the
+	// death_func() will be called from PostProcessQueue() in this frame.
+	// XXX: Why at the end? Why not just do it now?
+	hDestruct = AllocElement ();
+	if (hDestruct)
+	{
+		ELEMENT *DestructPtr;
+
+		LockElement (hDestruct, &DestructPtr);
+		DestructPtr->playerNr = ElementPtr->playerNr;
+		DestructPtr->state_flags = APPEARING | NONSOLID | FINITE_LIFE;
+		DestructPtr->next.location = ElementPtr->next.location;
+		DestructPtr->life_span = 0;
+		DestructPtr->pParent = ElementPtr->pParent;
+		DestructPtr->hTarget = 0;
+
+		DestructPtr->death_func = self_destruct_kill_objects;
+
+		UnlockElement (hDestruct);
+
+		PutElement (hDestruct);
 	}
+
+	// Must kill off the remaining crew ourselves
+	DeltaCrew (ElementPtr, -(int)ElementPtr->crew_level);
+
+	ElementPtr->state_flags |= NONSOLID;
+	ElementPtr->life_span = 0;
+	// The ship is now dead. It's death_func, i.e. shofixti_destruct_death(),
+	// will be called the next frame.
+	ElementPtr->death_func = shofixti_destruct_death;
 }
 
 static void
@@ -410,7 +458,7 @@ RACE_DESC*
 init_shofixti (void)
 {
 	RACE_DESC *RaceDescPtr;
-
+	// The caller of this func will copy the struct
 	static RACE_DESC new_shofixti_desc;
 
 	shofixti_desc.postprocess_func = shofixti_postprocess;
@@ -422,7 +470,6 @@ init_shofixti (void)
 			&& !GET_GAME_STATE (SHOFIXTI_RECRUITED))
 	{
 		// Tanaka/Katana flies in a damaged ship.
-#define NUM_LIMPETS 3
 		COUNT i;
 
 		new_shofixti_desc.ship_data.ship_rsc[0] = OLDSHOF_BIG_MASK_PMAP_ANIM;
@@ -444,7 +491,10 @@ init_shofixti (void)
 				--new_shofixti_desc.characteristics.turn_wait;
 			if (++new_shofixti_desc.characteristics.thrust_wait == 0)
 				--new_shofixti_desc.characteristics.thrust_wait;
+
+/* This should be the same as MIN_THRUST_INCREMENT in vux.c */
 #define MIN_THRUST_INCREMENT DISPLAY_TO_WORLD (1)
+
 			if (new_shofixti_desc.characteristics.thrust_increment <=
 					MIN_THRUST_INCREMENT)
 			{
diff -ruNp src.orig/uqm/ships/shofixti/shofixti.h src/uqm/ships/shofixti/shofixti.h
--- src.orig/uqm/ships/shofixti/shofixti.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/shofixti/shofixti.h	2017-11-21 19:39:59 -0600
@@ -17,7 +17,15 @@
 #ifndef SHOFIXTI_H
 #define SHOFIXTI_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_shofixti (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* SHOFIXTI_H */
 
diff -ruNp src.orig/uqm/ships/sis_ship/Makeinfo src/uqm/ships/sis_ship/Makeinfo
--- src.orig/uqm/ships/sis_ship/Makeinfo	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/sis_ship/Makeinfo	2017-11-21 19:39:59 -0600
@@ -1 +1,2 @@
 uqm_CFILES="sis_ship.c"
+uqm_HFILES="icode.h resinst.h sis_ship.h"
diff -ruNp src.orig/uqm/ships/sis_ship/icode.h src/uqm/ships/sis_ship/icode.h
--- src.orig/uqm/ships/sis_ship/icode.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/sis_ship/icode.h	2017-11-21 19:39:59 -0600
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SIS_CODE "ship.flagship.code"
diff -ruNp src.orig/uqm/ships/sis_ship/resinst.h src/uqm/ships/sis_ship/resinst.h
--- src.orig/uqm/ships/sis_ship/resinst.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/sis_ship/resinst.h	2017-11-21 19:39:59 -0600
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define BLASTER_BIG_MASK_PMAP_ANIM "ship.flagship.graphics.blaster.large"
 #define BLASTER_MED_MASK_PMAP_ANIM "ship.flagship.graphics.blaster.medium"
 #define BLASTER_SML_MASK_PMAP_ANIM "ship.flagship.graphics.blaster.small"
@@ -6,8 +10,6 @@
 #define SIS_HYPER_MASK_PMAP_ANIM "ship.flagship.graphics.hyperspace"
 #define SIS_ICON_MASK_PMAP_ANIM "ship.flagship.icons"
 #define SIS_MED_MASK_PMAP_ANIM "ship.flagship.graphics.flagship.medium"
-#define SIS_SML_MASK_PMAP_ANIM "ship.flagship.graphics.flagship.small"
 #define SIS_SHIP_SOUNDS "ship.flagship.sounds"
+#define SIS_SML_MASK_PMAP_ANIM "ship.flagship.graphics.flagship.small"
 #define SIS_VICTORY_SONG "ship.flagship.ditty"
-
-#include "icode.h"
diff -ruNp src.orig/uqm/ships/sis_ship/sis_ship.c src/uqm/ships/sis_ship/sis_ship.c
--- src.orig/uqm/ships/sis_ship/sis_ship.c	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/sis_ship/sis_ship.c	2017-11-21 19:39:59 -0600
@@ -26,31 +26,78 @@
 #include "uqm/hyper.h"
 #include "libs/mathlib.h"
 
-
-#define MAX_TRACKING 3
-#define MAX_DEFENSE 8
+/* Core characteristics.
+ * All of these are changed at init time by some module, except for
+ * MAX_ENERGY, THRUST_INCREMENT, and SHIP_MASS. */
 
 #define MAX_CREW MAX_CREW_SIZE
+		/* This value gets thrown out - actual max crew is determined by the
+		 * number of crew pods. The minimum value is 1 (just the Captain). */
+
 #define MAX_ENERGY MAX_ENERGY_SIZE
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 1
-#define SPECIAL_ENERGY_COST 0
+		/* Shiva furnaces increase this by 1 each. */
+#define SHIVA_ENERGY_REGEN_INC 1
+
 #define ENERGY_WAIT 10
+		/* Dynamos decrease this by 2 each, to a minimum of 4. */
+#define MIN_ENERGY_WAIT 4
+#define DYNAMO_UNIT_ENERGY_WAIT_DEC 2
+
 #define MAX_THRUST 10
+		/* Thrusters increase this and decrease THRUST_WAIT based on
+		 * THRUST_INCREMENT, see InitDriveSlots near the bottom of this file
+		 * for details. */
 #define THRUST_INCREMENT 4
-#define TURN_WAIT 17
 #define THRUST_WAIT 6
-#define WEAPON_WAIT 6
-#define SPECIAL_WAIT 9
-
+#define TURN_WAIT 17
+		/* Turning jets decrease by 2 each */
 #define SHIP_MASS MAX_SHIP_MASS
 
+
+/* Primary weapon - energy cost and damage change at init time based on
+ * the number and type of weapon modules installed. */
+
+#define BLASTER_DAMAGE 2
+		/* This is the damage value for the basic ion bolt guns. Fusion
+		 * blasters and hellbore cannons end up doing (BLASTER_DAMAGE * 2)
+		 * and (BLASTER_DAMAGE * 3) damage, respectively, but this depends
+		 * on enum values. */
+
+#define BLASTER_HITS 2 /* Hitpoints for ion bolt guns, see BLASTER_DAMAGE */
+
+#define WEAPON_ENERGY_COST 1
+		/* This value gets thrown out and reset in an ugly manner based on
+		 * the enum that is used for module IDs. Bigger gun = higher value.
+		 */
+#define WEAPON_WAIT 6
 #define BLASTER_SPEED DISPLAY_TO_WORLD (24)
 #define BLASTER_LIFE 12
+		/* This value is greatly increased, based in part on the enum used
+		 * for module IDs (bigger gun == longer life). See the first half of
+		 * InitWeaponSlots */
+#define MAX_TRACKING 3
+#define TRACKER_ENERGY_COST 3
+#define BLASTER_OFFSET 8
+#define SIS_VERT_OFFSET 28
+		/* Used for foward, spread, and rear slots */
+#define SIS_HORZ_OFFSET 20
+		/* Used for side slot */
+
+
+/* Secondary weapon */
+#define SPECIAL_ENERGY_COST 0
+		/* Increased by 1 for each point defense module */
+#define ANTIMISSILE_ENERGY_INC 1
+#define SPECIAL_WAIT 9
+#define LASER_RANGE (UWORD)100
+#define MAX_DEFENSE 8
+
 
 static RACE_DESC sis_desc =
 {
 	{ /* SHIP_INFO */
+		"flagship",
 		0,
 		16, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -136,8 +183,40 @@ static void InitDriveSlots (RACE_DESC *R
 		const BYTE *DriveSlots);
 static void InitJetSlots (RACE_DESC *RaceDescPtr,
 		const BYTE *JetSlots);
-void uninit_sis (RACE_DESC *pRaceDesc);
+static void uninit_sis (RACE_DESC *pRaceDesc);
+
+
+// Local typedef
+typedef SIS_DATA CustomShipData_t;
+
+// Retrieve race-specific ship data from a race desc
+static CustomShipData_t *
+GetCustomShipData (RACE_DESC *pRaceDesc)
+{
+	return pRaceDesc->data;
+}
+
+// Set the race-specific data in a race desc
+// (Re)Allocates its own storage for the data.
+static void
+SetCustomShipData (RACE_DESC *pRaceDesc, const CustomShipData_t *data)
+{
+	if (pRaceDesc->data == data)
+		return;  // no-op
+
+	if (pRaceDesc->data) // Out with the old
+	{
+		HFree (pRaceDesc->data);
+		pRaceDesc->data = NULL;
+	}
 
+	if (data) // In with the new
+	{
+		CustomShipData_t* newData = HMalloc (sizeof (*data));
+		*newData = *data;
+		pRaceDesc->data = newData;
+	}
+}
 
 static void
 sis_hyper_preprocess (ELEMENT *ElementPtr)
@@ -372,7 +451,6 @@ spawn_point_defense (ELEMENT *ElementPtr
 			if (ObjectPtr != ShipPtr && CollidingElement (ObjectPtr) &&
 					!OBJECT_CLOAKED (ObjectPtr))
 			{
-#define LASER_RANGE (UWORD)100
 				SIZE delta_x, delta_y;
 
 				delta_x = ObjectPtr->next.location.x -
@@ -475,8 +553,6 @@ sis_battle_postprocess (ELEMENT *Element
 	}
 }
 
-#define BLASTER_DAMAGE 2
-
 static void
 blaster_collision (ELEMENT *ElementPtr0, POINT *pPt0,
 		ELEMENT *ElementPtr1, POINT *pPt1)
@@ -556,17 +632,13 @@ blaster_preprocess (ELEMENT *ElementPtr)
 static COUNT
 initialize_blasters (ELEMENT *ShipPtr, HELEMENT BlasterArray[])
 {
-#define SIS_VERT_OFFSET 28
-#define SIS_HORZ_OFFSET 20
-#define BLASTER_HITS 2
-#define BLASTER_OFFSET 8
 	BYTE nt;
 	COUNT i;
 	STARSHIP *StarShipPtr;
 	SIS_DATA *SisData;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
-	SisData = (SIS_DATA *) StarShipPtr->RaceDescPtr->data;
+	SisData = GetCustomShipData (StarShipPtr->RaceDescPtr);
 
 	nt = (BYTE)((4 - SisData->num_trackers) & 3);
 
@@ -606,7 +678,7 @@ sis_intelligence (ELEMENT *ShipPtr, EVAL
 	SIS_DATA *SisData;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
-	SisData = (SIS_DATA *) StarShipPtr->RaceDescPtr->data;
+	SisData = GetCustomShipData (StarShipPtr->RaceDescPtr);
 
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_WEAPON_INDEX];
 	if (lpEvalDesc->ObjectPtr)
@@ -675,12 +747,8 @@ sis_intelligence (ELEMENT *ShipPtr, EVAL
 static void
 InitWeaponSlots (RACE_DESC *RaceDescPtr, const BYTE *ModuleSlots)
 {
-#define SIS_VERT_OFFSET 28
-#define SIS_HORZ_OFFSET 20
-#define BLASTER_HITS 2
-#define BLASTER_OFFSET 8
 	COUNT i;
-	SIS_DATA *SisData = (SIS_DATA *) RaceDescPtr->data;
+	SIS_DATA *SisData = GetCustomShipData (RaceDescPtr);
 	MISSILE_BLOCK *lpMB = SisData->MissileBlock;
 
 	SisData->num_blasters = 0;
@@ -760,7 +828,7 @@ InitModuleSlots (RACE_DESC *RaceDescPtr,
 {
 	COUNT i;
 	COUNT num_trackers;
-	SIS_DATA *SisData = (SIS_DATA *) RaceDescPtr->data;
+	SIS_DATA *SisData = GetCustomShipData (RaceDescPtr);
 
 	RaceDescPtr->ship_info.max_crew = 0;
 	num_trackers = 0;
@@ -778,22 +846,26 @@ InitModuleSlots (RACE_DESC *RaceDescPtr,
 				++num_trackers;
 				break;
 			case ANTIMISSILE_DEFENSE:
-				++RaceDescPtr->characteristics.special_energy_cost;
+				RaceDescPtr->characteristics.special_energy_cost +=
+						ANTIMISSILE_ENERGY_INC;
 				break;
 			case SHIVA_FURNACE:
-				++RaceDescPtr->characteristics.energy_regeneration;
+				RaceDescPtr->characteristics.energy_regeneration +=
+						SHIVA_ENERGY_REGEN_INC;
 				break;
 			case DYNAMO_UNIT:
-				RaceDescPtr->characteristics.energy_wait -= 2;
-				if (RaceDescPtr->characteristics.energy_wait < 4)
-					RaceDescPtr->characteristics.energy_wait = 4;
+				RaceDescPtr->characteristics.energy_wait -=
+						DYNAMO_UNIT_ENERGY_WAIT_DEC;
+				if (RaceDescPtr->characteristics.energy_wait < MIN_ENERGY_WAIT)
+					RaceDescPtr->characteristics.energy_wait = MIN_ENERGY_WAIT;
 				break;
 		}
 	}
 
 	if (num_trackers > MAX_TRACKING)
 		num_trackers = MAX_TRACKING;
-	RaceDescPtr->characteristics.weapon_energy_cost += num_trackers * 3;
+	RaceDescPtr->characteristics.weapon_energy_cost +=
+			num_trackers * TRACKER_ENERGY_COST;
 	SisData->num_trackers = num_trackers;
 	if (RaceDescPtr->characteristics.special_energy_cost)
 	{
@@ -848,16 +920,18 @@ RACE_DESC*
 init_sis (void)
 {
 	RACE_DESC *RaceDescPtr;
-
 	COUNT i;
+	// The caller of this func will copy the struct
 	static RACE_DESC new_sis_desc;
+	SIS_DATA empty_data;
+	memset (&empty_data, 0, sizeof (empty_data));
 
 	/* copy initial ship settings to new_sis_desc */
 	new_sis_desc = sis_desc;
 	
 	new_sis_desc.uninit_func = uninit_sis;
 
-	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+	if (inHQSpace ())
 	{
 		for (i = 0; i < NUM_VIEWS; ++i)
 		{
@@ -888,7 +962,7 @@ init_sis (void)
 			SET_GAME_STATE (BOMB_CARRIER, 1);
 	}
 
-	new_sis_desc.data = (intptr_t) HCalloc (sizeof (SIS_DATA));
+	SetCustomShipData (&new_sis_desc, &empty_data);
 	InitModuleSlots (&new_sis_desc, GLOBAL_SIS (ModuleSlots));
 	InitWeaponSlots (&new_sis_desc, GLOBAL_SIS (ModuleSlots));
 	InitDriveSlots (&new_sis_desc, GLOBAL_SIS (DriveSlots));
@@ -913,18 +987,17 @@ init_sis (void)
 	return (RaceDescPtr);
 }
 
-void
+static void
 uninit_sis (RACE_DESC *pRaceDesc)
 {
-	if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
+	if (!inHQSpace ())
 	{
 		GLOBAL_SIS (CrewEnlisted) = pRaceDesc->ship_info.crew_level;
 		if (pRaceDesc->ship_info.ship_flags & PLAYER_CAPTAIN)
 			GLOBAL_SIS (CrewEnlisted)--;
 	}
 
-	HFree ((void *)pRaceDesc->data);
-	pRaceDesc->data = 0;
+	SetCustomShipData (pRaceDesc, NULL);
 }
 
 
diff -ruNp src.orig/uqm/ships/sis_ship/sis_ship.h src/uqm/ships/sis_ship/sis_ship.h
--- src.orig/uqm/ships/sis_ship/sis_ship.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/sis_ship/sis_ship.h	2017-11-21 19:39:59 -0600
@@ -17,7 +17,15 @@
 #ifndef SIS_SHIP_H
 #define SIS_SHIP_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_sis (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* SIS_SHIP_H */
 
diff -ruNp src.orig/uqm/ships/slylandr/Makeinfo src/uqm/ships/slylandr/Makeinfo
--- src.orig/uqm/ships/slylandr/Makeinfo	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/slylandr/Makeinfo	2017-11-21 19:39:59 -0600
@@ -1 +1,2 @@
 uqm_CFILES="slylandr.c"
+uqm_HFILES="icode.h resinst.h slylandr.h"
diff -ruNp src.orig/uqm/ships/slylandr/icode.h src/uqm/ships/slylandr/icode.h
--- src.orig/uqm/ships/slylandr/icode.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/slylandr/icode.h	2017-11-21 19:39:59 -0600
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SLYLANDRO_CODE "ship.slylandro.code"
diff -ruNp src.orig/uqm/ships/slylandr/resinst.h src/uqm/ships/slylandr/resinst.h
--- src.orig/uqm/ships/slylandr/resinst.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/slylandr/resinst.h	2017-11-21 19:39:59 -0600
@@ -1,11 +1,13 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SLYLANDRO_BIG_MASK_PMAP_ANIM "ship.slylandro.graphics.probe.large"
 #define SLYLANDRO_CAPTAIN_MASK_PMAP_ANIM "ship.slylandro.graphics.captain"
 #define SLYLANDRO_ICON_MASK_PMAP_ANIM "ship.slylandro.icons"
 #define SLYLANDRO_MED_MASK_PMAP_ANIM "ship.slylandro.graphics.probe.medium"
 #define SLYLANDRO_MICON_MASK_PMAP_ANIM "ship.slylandro.meleeicons"
-#define SLYLANDRO_SML_MASK_PMAP_ANIM "ship.slylandro.graphics.probe.small"
 #define SLYLANDRO_RACE_STRINGS "ship.slylandro.text"
 #define SLYLANDRO_SHIP_SOUNDS "ship.slylandro.sounds"
+#define SLYLANDRO_SML_MASK_PMAP_ANIM "ship.slylandro.graphics.probe.small"
 #define SLYLANDRO_VICTORY_SONG "ship.slylandro.ditty"
-
-#include "icode.h"
diff -ruNp src.orig/uqm/ships/slylandr/slylandr.c src/uqm/ships/slylandr/slylandr.c
--- src.orig/uqm/ships/slylandr/slylandr.c	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/slylandr/slylandr.c	2017-11-21 19:39:59 -0600
@@ -23,26 +23,35 @@
 #include "uqm/globdata.h"
 #include "libs/mathlib.h"
 
-
+// Core characteristics
 #define MAX_CREW 12
 #define MAX_ENERGY 20
 #define ENERGY_REGENERATION 0
-#define WEAPON_ENERGY_COST 2
-#define SPECIAL_ENERGY_COST 0
 #define ENERGY_WAIT 10
 #define MAX_THRUST 60
 #define THRUST_INCREMENT MAX_THRUST
-#define TURN_WAIT 0
 #define THRUST_WAIT 0
-#define WEAPON_WAIT 17
-#define SPECIAL_WAIT 20
-
+#define TURN_WAIT 0
 #define SHIP_MASS 1
+
+// Lightning weapon
+#define WEAPON_ENERGY_COST 2
+#define WEAPON_WAIT 17
 #define SLYLANDRO_OFFSET 9
+#define LASER_LENGTH 32
+		/* Total length of lighting bolts. Actual range is usually less than
+		 * this, since the lightning rarely is straight. */
+
+// Harvester
+#define SPECIAL_ENERGY_COST 0
+#define SPECIAL_WAIT 20
+#define HARVEST_RANGE (208 * 3 / 8)
+		/* Was originally (SPACE_HEIGHT * 3 / 8) */
 
 static RACE_DESC slylandro_desc =
 {
 	{ /* SHIP_INFO */
+		"probe",
 		SEEKING_WEAPON | CREW_IMMUNE,
 		17, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -238,9 +247,8 @@ initialize_lightning (ELEMENT *ElementPt
 			angle += LOWORD (rand_val) & (QUADRANT - 1);
 		else
 			angle -= LOWORD (rand_val) & (QUADRANT - 1);
-#define LASER_RANGE 32
 		delta = WORLD_TO_VELOCITY (
-				DISPLAY_TO_WORLD ((HIWORD (rand_val) & (LASER_RANGE - 1)) + 4)
+				DISPLAY_TO_WORLD ((HIWORD (rand_val) & (LASER_LENGTH - 1)) + 4)
 				);
 		SetVelocityComponents (&LaserPtr->velocity,
 				COSINE (angle, delta), SINE (angle, delta));
@@ -313,8 +321,6 @@ harvest_space_junk (ELEMENT *ElementPtr)
 				&& !GRAVITY_MASS (ObjPtr->mass_points)
 				&& CollisionPossible (ObjPtr, ElementPtr))
 		{
-//HARVEST_RANGE was originally (SPACE_HEIGHT * 3 / 8)
-#define HARVEST_RANGE (208 * 3 / 8)
 			SIZE dx, dy;
 
 			if ((dx = ObjPtr->next.location.x
diff -ruNp src.orig/uqm/ships/slylandr/slylandr.h src/uqm/ships/slylandr/slylandr.h
--- src.orig/uqm/ships/slylandr/slylandr.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/slylandr/slylandr.h	2017-11-21 19:39:59 -0600
@@ -17,7 +17,15 @@
 #ifndef SLYLANDR_H
 #define SLYLANDR_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_slylandro (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* SLYLANDR_H */
 
diff -ruNp src.orig/uqm/ships/spathi/Makeinfo src/uqm/ships/spathi/Makeinfo
--- src.orig/uqm/ships/spathi/Makeinfo	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/spathi/Makeinfo	2017-11-21 19:39:59 -0600
@@ -1 +1,2 @@
 uqm_CFILES="spathi.c"
+uqm_HFILES="icode.h resinst.h spathi.h"
diff -ruNp src.orig/uqm/ships/spathi/icode.h src/uqm/ships/spathi/icode.h
--- src.orig/uqm/ships/spathi/icode.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/spathi/icode.h	2017-11-21 19:39:59 -0600
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SPATHI_CODE "ship.spathi.code"
diff -ruNp src.orig/uqm/ships/spathi/resinst.h src/uqm/ships/spathi/resinst.h
--- src.orig/uqm/ships/spathi/resinst.h	2017-11-21 19:39:41 -0600
+++ src/uqm/ships/spathi/resinst.h	2017-11-21 19:39:59 -0600
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define DISCRIM_BIG_MASK_PMAP_ANIM "ship.spathi.graphics.butt.large"
 #define DISCRIM_MED_MASK_PMAP_ANIM "ship.spathi.graphics.butt.medium"
 #define DISCRIM_SML_MASK_PMAP_ANIM "ship.spathi.graphics.butt.small"
@@ -9,9 +13,7 @@
 #define SPATHI_ICON_MASK_PMAP_ANIM "ship.spathi.icons"
 #define SPATHI_MED_MASK_PMAP_ANIM "ship.spathi.graphics.eluder.medium"
 #define SPATHI_MICON_MASK_PMAP_ANIM "ship.spathi.meleeicons"
-#define SPATHI_SML_MASK_PMAP_ANIM "ship.spathi.graphics.eluder.small"
 #define SPATHI_RACE_STRINGS "ship.spathi.text"
 #define SPATHI_SHIP_SOUNDS "ship.spathi.sounds"
+#define SPATHI_SML_MASK_PMAP_ANIM "ship.spathi.graphics.eluder.small"
 #define SPATHI_VICTORY_SONG "ship.spathi.ditty"
-
-#include "icode.h"
diff -ruNp src.orig/uqm/ships/spathi/spathi.c src/uqm/ships/spathi/spathi.c
--- src.orig/uqm/ships/spathi/spathi.c	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/spathi/spathi.c	2017-11-21 19:39:59 -0600
@@ -20,27 +20,44 @@
 #include "spathi.h"
 #include "resinst.h"
 
+// Core characteristics
 #define MAX_CREW 30
 #define MAX_ENERGY 10
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 2
-#define SPECIAL_ENERGY_COST 3
 #define ENERGY_WAIT 10
 #define MAX_THRUST 48
 #define THRUST_INCREMENT 12
-#define TURN_WAIT 1
 #define THRUST_WAIT 1
-#define WEAPON_WAIT 0
-#define SPECIAL_WAIT 7
-
+#define TURN_WAIT 1
 #define SHIP_MASS 5
+
+// Forward gun
+#define WEAPON_ENERGY_COST 2
+#define WEAPON_WAIT 0
+#define SPATHI_FORWARD_OFFSET 16
 #define MISSILE_SPEED DISPLAY_TO_WORLD (30)
 #define MISSILE_LIFE 10
+#define MISSILE_HITS 1
+#define MISSILE_DAMAGE 1
+#define MISSILE_OFFSET 1
 #define MISSILE_RANGE (MISSILE_SPEED * MISSILE_LIFE)
+		/* This is for the cyborg only. */
+
+// B.U.T.T.
+#define SPECIAL_ENERGY_COST 3
+#define SPECIAL_WAIT 7
+#define SPATHI_REAR_OFFSET 20
+#define DISCRIMINATOR_SPEED DISPLAY_TO_WORLD (8)
+#define DISCRIMINATOR_LIFE 30
+#define DISCRIMINATOR_HITS 1
+#define DISCRIMINATOR_DAMAGE 2
+#define DISCRIMINATOR_OFFSET 4
+#define TRACK_WAIT 1
 
 static RACE_DESC spathi_desc =
 {
 	{ /* SHIP_INFO */
+		"eluder",
 		FIRES_FORE | FIRES_AFT | SEEKING_SPECIAL | DONT_CHASE,
 		18, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -109,9 +126,6 @@ static RACE_DESC spathi_desc =
 	0, /* CodeRef */
 };
 
-#define DISCRIMINATOR_SPEED DISPLAY_TO_WORLD (8)
-#define TRACK_WAIT 1
-
 static void
 butt_missile_preprocess (ELEMENT *ElementPtr)
 {
@@ -140,11 +154,6 @@ butt_missile_preprocess (ELEMENT *Elemen
 static void
 spawn_butt_missile (ELEMENT *ShipPtr)
 {
-#define SPATHI_REAR_OFFSET 20
-#define DISCRIMINATOR_LIFE 30
-#define DISCRIMINATOR_HITS 1
-#define DISCRIMINATOR_DAMAGE 2
-#define DISCRIMINATOR_OFFSET 4
 	HELEMENT ButtMissile;
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK ButtMissileBlock;
@@ -239,10 +248,6 @@ spathi_intelligence (ELEMENT *ShipPtr, E
 static COUNT
 initialize_standard_missile (ELEMENT *ShipPtr, HELEMENT MissileArray[])
 {
-#define SPATHI_FORWARD_OFFSET 16
-#define MISSILE_HITS 1
-#define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET 1
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
diff -ruNp src.orig/uqm/ships/spathi/spathi.h src/uqm/ships/spathi/spathi.h
--- src.orig/uqm/ships/spathi/spathi.h	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/spathi/spathi.h	2017-11-21 19:39:59 -0600
@@ -17,7 +17,15 @@
 #ifndef SPATHI_H
 #define SPATHI_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_spathi (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* SPATHI_H */
 
diff -ruNp src.orig/uqm/ships/supox/Makeinfo src/uqm/ships/supox/Makeinfo
--- src.orig/uqm/ships/supox/Makeinfo	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/supox/Makeinfo	2017-11-21 19:39:59 -0600
@@ -1 +1,2 @@
 uqm_CFILES="supox.c"
+uqm_HFILES="icode.h resinst.h supox.h"
diff -ruNp src.orig/uqm/ships/supox/icode.h src/uqm/ships/supox/icode.h
--- src.orig/uqm/ships/supox/icode.h	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/supox/icode.h	2017-11-21 19:39:59 -0600
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SUPOX_CODE "ship.supox.code"
diff -ruNp src.orig/uqm/ships/supox/resinst.h src/uqm/ships/supox/resinst.h
--- src.orig/uqm/ships/supox/resinst.h	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/supox/resinst.h	2017-11-21 19:39:59 -0600
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define GOB_BIG_MASK_PMAP_ANIM "ship.supox.graphics.glob.large"
 #define GOB_MED_MASK_PMAP_ANIM "ship.supox.graphics.glob.medium"
 #define GOB_SML_MASK_PMAP_ANIM "ship.supox.graphics.glob.small"
@@ -6,9 +10,7 @@
 #define SUPOX_ICON_MASK_PMAP_ANIM "ship.supox.icons"
 #define SUPOX_MED_MASK_PMAP_ANIM "ship.supox.graphics.blade.medium"
 #define SUPOX_MICON_MASK_PMAP_ANIM "ship.supox.meleeicons"
-#define SUPOX_SML_MASK_PMAP_ANIM "ship.supox.graphics.blade.small"
 #define SUPOX_RACE_STRINGS "ship.supox.text"
 #define SUPOX_SHIP_SOUNDS "ship.supox.sounds"
+#define SUPOX_SML_MASK_PMAP_ANIM "ship.supox.graphics.blade.small"
 #define SUPOX_VICTORY_SONG "ship.supox.ditty"
-
-#include "icode.h"
diff -ruNp src.orig/uqm/ships/supox/supox.c src/uqm/ships/supox/supox.c
--- src.orig/uqm/ships/supox/supox.c	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/supox/supox.c	2017-11-21 19:39:59 -0600
@@ -22,27 +22,37 @@
 
 #include "libs/mathlib.h"
 
-
+// Core characteristics
 #define MAX_CREW 12
 #define MAX_ENERGY 16
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 1
-#define SPECIAL_ENERGY_COST 1
 #define ENERGY_WAIT 4
 #define MAX_THRUST 40
 #define THRUST_INCREMENT 8
-#define TURN_WAIT 1
 #define THRUST_WAIT 0
-#define WEAPON_WAIT 2
-#define SPECIAL_WAIT 0
-
+#define TURN_WAIT 1
 #define SHIP_MASS 4
+
+// Gob launcher
+#define WEAPON_ENERGY_COST 1
+#define WEAPON_WAIT 2
+#define SUPOX_OFFSET 23
+#define MISSILE_OFFSET 2
 #define MISSILE_SPEED DISPLAY_TO_WORLD (30)
 #define MISSILE_LIFE 10
+#define MISSILE_HITS 1
+#define MISSILE_DAMAGE 1
+
+// Lateral/reverse thrust
+#define SPECIAL_ENERGY_COST 1
+		/* Unused - uncomment below to enable. */
+#define SPECIAL_WAIT 0
+		/* Unused except to initialize supox_desc.special_wait */
 
 static RACE_DESC supox_desc =
 {
 	{ /* SHIP_INFO */
+		"blade",
 		FIRES_FORE,
 		16, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -179,10 +189,6 @@ supox_intelligence (ELEMENT *ShipPtr, EV
 static COUNT
 initialize_horn (ELEMENT *ShipPtr, HELEMENT HornArray[])
 {
-#define MISSILE_HITS 1
-#define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET 2
-#define SUPOX_OFFSET 23
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
diff -ruNp src.orig/uqm/ships/supox/supox.h src/uqm/ships/supox/supox.h
--- src.orig/uqm/ships/supox/supox.h	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/supox/supox.h	2017-11-21 19:39:59 -0600
@@ -17,7 +17,15 @@
 #ifndef SUPOX_H
 #define SUPOX_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_supox (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* SUPOX_H */
 
diff -ruNp src.orig/uqm/ships/syreen/Makeinfo src/uqm/ships/syreen/Makeinfo
--- src.orig/uqm/ships/syreen/Makeinfo	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/syreen/Makeinfo	2017-11-21 19:39:59 -0600
@@ -1 +1,2 @@
 uqm_CFILES="syreen.c"
+uqm_HFILES="icode.h resinst.h syreen.h"
diff -ruNp src.orig/uqm/ships/syreen/icode.h src/uqm/ships/syreen/icode.h
--- src.orig/uqm/ships/syreen/icode.h	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/syreen/icode.h	2017-11-21 19:39:59 -0600
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SYREEN_CODE "ship.syreen.code"
diff -ruNp src.orig/uqm/ships/syreen/resinst.h src/uqm/ships/syreen/resinst.h
--- src.orig/uqm/ships/syreen/resinst.h	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/syreen/resinst.h	2017-11-21 19:39:59 -0600
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define DAGGER_BIG_MASK_PMAP_ANIM "ship.syreen.graphics.dagger.large"
 #define DAGGER_MED_MASK_PMAP_ANIM "ship.syreen.graphics.dagger.medium"
 #define DAGGER_SML_MASK_PMAP_ANIM "ship.syreen.graphics.dagger.small"
@@ -6,9 +10,7 @@
 #define SYREEN_ICON_MASK_PMAP_ANIM "ship.syreen.icons"
 #define SYREEN_MED_MASK_PMAP_ANIM "ship.syreen.graphics.penetrator.medium"
 #define SYREEN_MICON_MASK_PMAP_ANIM "ship.syreen.meleeicons"
-#define SYREEN_SML_MASK_PMAP_ANIM "ship.syreen.graphics.penetrator.small"
 #define SYREEN_RACE_STRINGS "ship.syreen.text"
 #define SYREEN_SHIP_SOUNDS "ship.syreen.sounds"
+#define SYREEN_SML_MASK_PMAP_ANIM "ship.syreen.graphics.penetrator.small"
 #define SYREEN_VICTORY_SONG "ship.syreen.ditty"
-
-#include "icode.h"
diff -ruNp src.orig/uqm/ships/syreen/syreen.c src/uqm/ships/syreen/syreen.c
--- src.orig/uqm/ships/syreen/syreen.c	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/syreen/syreen.c	2017-11-21 19:39:59 -0600
@@ -22,28 +22,38 @@
 
 #include "libs/mathlib.h"
 
-
+// Core characteristics
 #define SYREEN_MAX_CREW_SIZE MAX_CREW_SIZE
 #define MAX_CREW 12
 #define MAX_ENERGY 16
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 1
-#define SPECIAL_ENERGY_COST 5
 #define ENERGY_WAIT 6
 #define MAX_THRUST /* DISPLAY_TO_WORLD (8) */ 36
 #define THRUST_INCREMENT /* DISPLAY_TO_WORLD (2) */ 9
-#define TURN_WAIT 1
 #define THRUST_WAIT 1
-#define WEAPON_WAIT 8
-#define SPECIAL_WAIT 20
-
+#define TURN_WAIT 1
 #define SHIP_MASS 2
+
+// Particle Beam Stiletto
+#define WEAPON_ENERGY_COST 1
+#define WEAPON_WAIT 8
+#define SYREEN_OFFSET 30
 #define MISSILE_SPEED DISPLAY_TO_WORLD (30)
 #define MISSILE_LIFE 10
+#define MISSILE_HITS 1
+#define MISSILE_DAMAGE 2
+#define MISSILE_OFFSET 3
+
+// Syreen song
+#define SPECIAL_ENERGY_COST 5
+#define SPECIAL_WAIT 20
+#define ABANDONER_RANGE 208 /* originally SPACE_HEIGHT */
+#define MAX_ABANDONERS 8
 
 static RACE_DESC syreen_desc =
 {
 	{ /* SHIP_INFO */
+		"penetrator",
 		FIRES_FORE,
 		13, /* Super Melee cost */
 		MAX_CREW, SYREEN_MAX_CREW_SIZE,
@@ -115,10 +125,6 @@ static RACE_DESC syreen_desc =
 static COUNT
 initialize_dagger (ELEMENT *ShipPtr, HELEMENT DaggerArray[])
 {
-#define SYREEN_OFFSET 30
-#define MISSILE_HITS 1
-#define MISSILE_DAMAGE 2
-#define MISSILE_OFFSET 3
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -194,13 +200,11 @@ spawn_crew (ELEMENT *ElementPtr)
 
 				dx = WORLD_TO_DISPLAY (dx);
 				dy = WORLD_TO_DISPLAY (dy);
-#define ABANDONER_RANGE 208 /* originally SPACE_HEIGHT */
 				if (dx <= ABANDONER_RANGE && dy <= ABANDONER_RANGE
 						&& (d_squared = (DWORD)((UWORD)dx * (UWORD)dx)
 						+ (DWORD)((UWORD)dy * (UWORD)dy)) <=
 						(DWORD)((UWORD)ABANDONER_RANGE * (UWORD)ABANDONER_RANGE))
 				{
-#define MAX_ABANDONERS 8
 					COUNT crew_loss;
 
 					crew_loss = ((MAX_ABANDONERS
diff -ruNp src.orig/uqm/ships/syreen/syreen.h src/uqm/ships/syreen/syreen.h
--- src.orig/uqm/ships/syreen/syreen.h	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/syreen/syreen.h	2017-11-21 19:39:59 -0600
@@ -17,7 +17,15 @@
 #ifndef SYREEN_H
 #define SYREEN_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_syreen (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* SYREEN_H */
 
diff -ruNp src.orig/uqm/ships/thradd/Makeinfo src/uqm/ships/thradd/Makeinfo
--- src.orig/uqm/ships/thradd/Makeinfo	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/thradd/Makeinfo	2017-11-21 19:39:59 -0600
@@ -1 +1,2 @@
 uqm_CFILES="thradd.c"
+uqm_HFILES="icode.h resinst.h thradd.h"
diff -ruNp src.orig/uqm/ships/thradd/icode.h src/uqm/ships/thradd/icode.h
--- src.orig/uqm/ships/thradd/icode.h	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/thradd/icode.h	2017-11-21 19:39:59 -0600
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define THRADDASH_CODE "ship.thraddash.code"
diff -ruNp src.orig/uqm/ships/thradd/resinst.h src/uqm/ships/thradd/resinst.h
--- src.orig/uqm/ships/thradd/resinst.h	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/thradd/resinst.h	2017-11-21 19:39:59 -0600
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define HORN_BIG_MASK_PMAP_ANIM "ship.thraddash.graphics.horn.large"
 #define HORN_MED_MASK_PMAP_ANIM "ship.thraddash.graphics.horn.medium"
 #define HORN_SML_MASK_PMAP_ANIM "ship.thraddash.graphics.horn.small"
@@ -9,9 +13,7 @@
 #define THRADDASH_ICON_MASK_PMAP_ANIM "ship.thraddash.icons"
 #define THRADDASH_MED_MASK_PMAP_ANIM "ship.thraddash.graphics.torch.medium"
 #define THRADDASH_MICON_MASK_PMAP_ANIM "ship.thraddash.meleeicons"
-#define THRADDASH_SML_MASK_PMAP_ANIM "ship.thraddash.graphics.torch.small"
 #define THRADDASH_RACE_STRINGS "ship.thraddash.text"
 #define THRADDASH_SHIP_SOUNDS "ship.thraddash.sounds"
+#define THRADDASH_SML_MASK_PMAP_ANIM "ship.thraddash.graphics.torch.small"
 #define THRADDASH_VICTORY_SONG "ship.thraddash.ditty"
-
-#include "icode.h"
diff -ruNp src.orig/uqm/ships/thradd/thradd.c src/uqm/ships/thradd/thradd.c
--- src.orig/uqm/ships/thradd/thradd.c	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/thradd/thradd.c	2017-11-21 19:39:59 -0600
@@ -22,28 +22,47 @@
 
 #include "uqm/globdata.h"
 
-
+// Core characteristics
 #define MAX_CREW 8
 #define MAX_ENERGY 24
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 2
-#define SPECIAL_ENERGY_COST 1
 #define ENERGY_WAIT 6
 #define MAX_THRUST 28
 #define THRUST_INCREMENT 7
-#define TURN_WAIT 1
 #define THRUST_WAIT 0
-#define WEAPON_WAIT 12
-#define SPECIAL_WAIT 0
-
+#define TURN_WAIT 1
 #define SHIP_MASS 7
-#define THRADDASH_OFFSET 9
+
+// Ion Blasters
+#define WEAPON_ENERGY_COST 2
+#define WEAPON_WAIT 12
 #define MISSILE_SPEED DISPLAY_TO_WORLD (30)
 #define MISSILE_LIFE 15
+#define MISSILE_OFFSET 3
+#define THRADDASH_OFFSET 9
+#define MISSILE_HITS 2
+#define MISSILE_DAMAGE 1
+
+// Afterburner
+#define SPECIAL_ENERGY_COST 1
+#define SPECIAL_WAIT 0
+#define SPECIAL_THRUST_INCREMENT 12
+#define SPECIAL_MAX_THRUST 72
+#define NAPALM_LIFE 48
+#define NAPALM_OFFSET 0
+#define NAPALM_HITS 1
+#define NAPALM_DAMAGE 2
+#define NAPALM_DECAY_RATE 5
+		/* Controls the speed of the afterburner "decay" animation; it will
+		 * decay one step (one animation frame) per NAPALM_DECAY_RATE
+		 * frames. */
+#define NUM_NAPALM_FADES 6
+
 
 static RACE_DESC thraddash_desc =
 {
 	{ /* SHIP_INFO */
+		"torch",
 		FIRES_FORE,
 		10, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -202,8 +221,6 @@ thraddash_intelligence (ELEMENT *ShipPtr
 	}
 }
 
-#define NAPALM_WAIT 1
-
 static void
 flame_napalm_preprocess (ELEMENT *ElementPtr)
 {
@@ -220,24 +237,26 @@ flame_napalm_preprocess (ELEMENT *Elemen
 		InitIntersectEndPoint (ElementPtr);
 		InitIntersectFrame (ElementPtr);
 	}
+	/* turn_wait is abused here to store the speed of the decay animation */
 	else if (ElementPtr->turn_wait > 0)
 		--ElementPtr->turn_wait;
 	else
 	{
-#define NUM_NAPALM_FADES 6
-		if (ElementPtr->life_span <= NUM_NAPALM_FADES * (NAPALM_WAIT + 1)
+		if (ElementPtr->life_span <= NUM_NAPALM_FADES * (NAPALM_DECAY_RATE + 1)
 				|| GetFrameIndex (
 				ElementPtr->current.image.frame
 				) != NUM_NAPALM_FADES)
 			ElementPtr->next.image.frame =
 					DecFrameIndex (ElementPtr->current.image.frame);
-		else if (ElementPtr->life_span > NUM_NAPALM_FADES * (NAPALM_WAIT + 1))
+		else if (ElementPtr->life_span > NUM_NAPALM_FADES * (NAPALM_DECAY_RATE + 1))
 			ElementPtr->next.image.frame = SetAbsFrameIndex (
 					ElementPtr->current.image.frame,
 					GetFrameCount (ElementPtr->current.image.frame) - 1
 					);
 
-		ElementPtr->turn_wait = NAPALM_WAIT;
+		/* turn_wait is abused here to store the speed of the decay
+		 * animation. */
+		ElementPtr->turn_wait = NAPALM_DECAY_RATE;
 		ElementPtr->state_flags |= CHANGING;
 	}
 }
@@ -245,9 +264,6 @@ flame_napalm_preprocess (ELEMENT *Elemen
 static COUNT
 initialize_horn (ELEMENT *ShipPtr, HELEMENT HornArray[])
 {
-#define MISSILE_HITS 2
-#define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET 3
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -284,8 +300,6 @@ thraddash_preprocess (ELEMENT *ElementPt
 	}
 	else if (DeltaEnergy (ElementPtr, -SPECIAL_ENERGY_COST))
 	{
-#define SPECIAL_THRUST_INCREMENT 12
-#define SPECIAL_MAX_THRUST 72
 		COUNT max_thrust, thrust_increment;
 		STATUS_FLAGS thrust_status;
 		HELEMENT hTrailElement;
@@ -317,10 +331,6 @@ thraddash_preprocess (ELEMENT *ElementPt
 		StarShipPtr->RaceDescPtr->characteristics.max_thrust = max_thrust;
 
 		{
-#define NAPALM_HITS 1
-#define NAPALM_DAMAGE 2
-#define NAPALM_LIFE 48
-#define NAPALM_OFFSET 0
 			MISSILE_BLOCK MissileBlock;
 
 			MissileBlock.cx = ElementPtr->next.location.x;
@@ -348,7 +358,10 @@ thraddash_preprocess (ELEMENT *ElementPt
 				LockElement (hTrailElement, &TrailElementPtr);
 				SetElementStarShip (TrailElementPtr, StarShipPtr);
 				TrailElementPtr->hTarget = 0;
-				TrailElementPtr->turn_wait = NAPALM_WAIT;
+
+				/* turn_wait is abused here to store the speed of the decay
+				 * animation */
+				TrailElementPtr->turn_wait = NAPALM_DECAY_RATE;
 
 				TrailElementPtr->state_flags |= NONSOLID;
 				SetPrimType (
diff -ruNp src.orig/uqm/ships/thradd/thradd.h src/uqm/ships/thradd/thradd.h
--- src.orig/uqm/ships/thradd/thradd.h	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/thradd/thradd.h	2017-11-21 19:39:59 -0600
@@ -17,7 +17,15 @@
 #ifndef THRADD_H
 #define THRADD_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_thraddash (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* THRADD_H */
 
diff -ruNp src.orig/uqm/ships/umgah/Makeinfo src/uqm/ships/umgah/Makeinfo
--- src.orig/uqm/ships/umgah/Makeinfo	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/umgah/Makeinfo	2017-11-21 19:39:59 -0600
@@ -1 +1,2 @@
 uqm_CFILES="umgah.c"
+uqm_HFILES="icode.h resinst.h umgah.h"
diff -ruNp src.orig/uqm/ships/umgah/icode.h src/uqm/ships/umgah/icode.h
--- src.orig/uqm/ships/umgah/icode.h	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/umgah/icode.h	2017-11-21 19:39:59 -0600
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define UMGAH_CODE "ship.umgah.code"
diff -ruNp src.orig/uqm/ships/umgah/resinst.h src/uqm/ships/umgah/resinst.h
--- src.orig/uqm/ships/umgah/resinst.h	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/umgah/resinst.h	2017-11-21 19:39:59 -0600
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define CONE_BIG_MASK_ANIM "ship.umgah.graphics.cone.large"
 #define CONE_MED_MASK_ANIM "ship.umgah.graphics.cone.medium"
 #define CONE_SML_MASK_ANIM "ship.umgah.graphics.cone.small"
@@ -7,9 +11,7 @@
 #define UMGAH_ICON_MASK_PMAP_ANIM "ship.umgah.icons"
 #define UMGAH_MED_MASK_PMAP_ANIM "ship.umgah.graphics.drone.medium"
 #define UMGAH_MICON_MASK_PMAP_ANIM "ship.umgah.meleeicons"
-#define UMGAH_SML_MASK_PMAP_ANIM "ship.umgah.graphics.drone.small"
 #define UMGAH_RACE_STRINGS "ship.umgah.text"
 #define UMGAH_SHIP_SOUNDS "ship.umgah.sounds"
+#define UMGAH_SML_MASK_PMAP_ANIM "ship.umgah.graphics.drone.small"
 #define UMGAH_VICTORY_SONG "ship.umgah.ditty"
-
-#include "icode.h"
diff -ruNp src.orig/uqm/ships/umgah/umgah.c src/uqm/ships/umgah/umgah.c
--- src.orig/uqm/ships/umgah/umgah.c	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/umgah/umgah.c	2017-11-21 19:39:59 -0600
@@ -22,26 +22,36 @@
 
 #include "libs/mathlib.h"
 
-
+// Core characteristics
 #define MAX_CREW 10
 #define MAX_ENERGY 30
 #define ENERGY_REGENERATION MAX_ENERGY
-#define WEAPON_ENERGY_COST 0
-#define SPECIAL_ENERGY_COST 1
 #define ENERGY_WAIT 150
 #define MAX_THRUST /* DISPLAY_TO_WORLD (5) */ 18
 #define THRUST_INCREMENT /* DISPLAY_TO_WORLD (2) */ 6
-#define TURN_WAIT 4
 #define THRUST_WAIT 3
-#define WEAPON_WAIT 0
-#define SPECIAL_WAIT 2
-
+#define TURN_WAIT 4
 #define SHIP_MASS 1
 
+// Antimatter cone
+#define WEAPON_ENERGY_COST 0
+#define WEAPON_WAIT 0
+#define UMGAH_OFFSET 0
+#define CONE_OFFSET 0
+#define CONE_SPEED 0
+#define CONE_HITS 100
+#define CONE_DAMAGE 1
+#define CONE_LIFE 1
+
+// Retropropulsion
+#define SPECIAL_ENERGY_COST 1
+#define SPECIAL_WAIT 2
+#define JUMP_DIST DISPLAY_TO_WORLD (40)
 
 static RACE_DESC umgah_desc =
 {
 	{ /* SHIP_INFO */
+		"drone",
 		FIRES_FORE | IMMEDIATE_WEAPON,
 		7, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -110,6 +120,46 @@ static RACE_DESC umgah_desc =
 	0, /* CodeRef */
 };
 
+
+// Private per-instance ship data
+typedef struct
+{
+	UWORD prevFacing;
+} UMGAH_DATA;
+
+// Local typedef
+typedef UMGAH_DATA CustomShipData_t;
+
+// Retrieve race-specific ship data from a race desc
+static CustomShipData_t *
+GetCustomShipData (RACE_DESC *pRaceDesc)
+{
+	return pRaceDesc->data;
+}
+
+// Set the race-specific data in a race desc
+// (Re)Allocates its own storage for the data.
+static void
+SetCustomShipData (RACE_DESC *pRaceDesc, const CustomShipData_t *data)
+{
+	if (pRaceDesc->data == data) 
+		return;  // no-op
+
+	if (pRaceDesc->data) // Out with the old
+	{
+		HFree (pRaceDesc->data);
+		pRaceDesc->data = NULL;
+	}
+
+	if (data) // In with the new
+	{
+		CustomShipData_t* newData = HMalloc (sizeof (*data));
+		*newData = *data;
+		pRaceDesc->data = newData;
+	}
+}
+
+
 static void
 cone_preprocess (ELEMENT *ElementPtr)
 {
@@ -139,8 +189,6 @@ cone_collision (ELEMENT *ElementPtr0, PO
 	}
 }
 
-#define JUMP_DIST DISPLAY_TO_WORLD (40)
-
 static void
 umgah_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
 		COUNT ConcernCounter)
@@ -259,13 +307,8 @@ umgah_intelligence (ELEMENT *ShipPtr, EV
 static COUNT
 initialize_cone (ELEMENT *ShipPtr, HELEMENT ConeArray[])
 {
-#define UMGAH_OFFSET 0
-#define MISSILE_SPEED 0
-#define MISSILE_HITS 100
-#define MISSILE_DAMAGE 1
-#define MISSILE_LIFE 1
-#define MISSILE_OFFSET 0
 	STARSHIP *StarShipPtr;
+	UMGAH_DATA* UmgahData;
 	MISSILE_BLOCK MissileBlock;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
@@ -276,24 +319,26 @@ initialize_cone (ELEMENT *ShipPtr, HELEM
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = UMGAH_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
-	MissileBlock.hit_points = MISSILE_HITS;
-	MissileBlock.damage = MISSILE_DAMAGE;
-	MissileBlock.life = MISSILE_LIFE;
+	MissileBlock.speed = CONE_SPEED;
+	MissileBlock.hit_points = CONE_HITS;
+	MissileBlock.damage = CONE_DAMAGE;
+	MissileBlock.life = CONE_LIFE;
 	MissileBlock.preprocess_func = cone_preprocess;
-	MissileBlock.blast_offs = MISSILE_OFFSET;
+	MissileBlock.blast_offs = CONE_OFFSET;
 
 	// This func is called every frame while the player is holding down WEAPON
 	// Don't reset the cone FRAME to the first image every time
-	if (ShipPtr->next.image.frame != (FRAME) StarShipPtr->RaceDescPtr->data)
+	UmgahData = GetCustomShipData (StarShipPtr->RaceDescPtr);
+	if (!UmgahData || StarShipPtr->ShipFacing != UmgahData->prevFacing)
 	{
-		StarShipPtr->RaceDescPtr->data = (intptr_t) ShipPtr->next.image.frame;
+		const UMGAH_DATA shipData = {StarShipPtr->ShipFacing};
+
+		SetCustomShipData (StarShipPtr->RaceDescPtr, &shipData);
 
 		StarShipPtr->RaceDescPtr->ship_data.special[0] =
 				SetAbsFrameIndex (
 				StarShipPtr->RaceDescPtr->ship_data.special[0],
-				StarShipPtr->ShipFacing
-				);
+				StarShipPtr->ShipFacing);
 	}
 	
 	MissileBlock.index = GetFrameIndex (StarShipPtr->RaceDescPtr->ship_data.special[0]);
@@ -341,7 +386,7 @@ umgah_preprocess (ELEMENT *ElementPtr)
 	if (ElementPtr->state_flags & APPEARING)
 	{
 		// Reset the value just in case
-		StarShipPtr->RaceDescPtr->data = 0;
+		SetCustomShipData (StarShipPtr->RaceDescPtr, NULL);
 	}
 	else
 	{
@@ -366,11 +411,18 @@ umgah_preprocess (ELEMENT *ElementPtr)
 	}
 }
 
+static void
+uninit_umgah (RACE_DESC *pRaceDesc)
+{
+	SetCustomShipData (pRaceDesc, NULL);
+}
+
 RACE_DESC*
 init_umgah (void)
 {
 	RACE_DESC *RaceDescPtr;
 
+	umgah_desc.uninit_func = uninit_umgah;
 	umgah_desc.preprocess_func = umgah_preprocess;
 	umgah_desc.postprocess_func = umgah_postprocess;
 	umgah_desc.init_weapon_func = initialize_cone;
diff -ruNp src.orig/uqm/ships/umgah/umgah.h src/uqm/ships/umgah/umgah.h
--- src.orig/uqm/ships/umgah/umgah.h	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/umgah/umgah.h	2017-11-21 19:39:59 -0600
@@ -17,7 +17,15 @@
 #ifndef UMGAH_H
 #define UMGAH_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_umgah (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* UMGAH_H */
 
diff -ruNp src.orig/uqm/ships/urquan/Makeinfo src/uqm/ships/urquan/Makeinfo
--- src.orig/uqm/ships/urquan/Makeinfo	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/urquan/Makeinfo	2017-11-21 19:39:59 -0600
@@ -1 +1,2 @@
 uqm_CFILES="urquan.c"
+uqm_HFILES="icode.h resinst.h urquan.h"
diff -ruNp src.orig/uqm/ships/urquan/icode.h src/uqm/ships/urquan/icode.h
--- src.orig/uqm/ships/urquan/icode.h	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/urquan/icode.h	2017-11-21 19:39:59 -0600
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define URQUAN_CODE "ship.urquan.code"
diff -ruNp src.orig/uqm/ships/urquan/resinst.h src/uqm/ships/urquan/resinst.h
--- src.orig/uqm/ships/urquan/resinst.h	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/urquan/resinst.h	2017-11-21 19:39:59 -0600
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define FIGHTER_BIG_MASK_PMAP_ANIM "ship.urquan.graphics.fighter.large"
 #define FIGHTER_MED_MASK_PMAP_ANIM "ship.urquan.graphics.fighter.medium"
 #define FIGHTER_SML_MASK_PMAP_ANIM "ship.urquan.graphics.fighter.small"
@@ -9,9 +13,7 @@
 #define URQUAN_ICON_MASK_PMAP_ANIM "ship.urquan.icons"
 #define URQUAN_MED_MASK_PMAP_ANIM "ship.urquan.graphics.dreadnought.medium"
 #define URQUAN_MICON_MASK_PMAP_ANIM "ship.urquan.meleeicons"
-#define URQUAN_SML_MASK_PMAP_ANIM "ship.urquan.graphics.dreadnought.small"
 #define URQUAN_RACE_STRINGS "ship.urquan.text"
 #define URQUAN_SHIP_SOUNDS "ship.urquan.sounds"
+#define URQUAN_SML_MASK_PMAP_ANIM "ship.urquan.graphics.dreadnought.small"
 #define URQUAN_VICTORY_SONG "ship.urquan.ditty"
-
-#include "icode.h"
diff -ruNp src.orig/uqm/ships/urquan/urquan.c src/uqm/ships/urquan/urquan.c
--- src.orig/uqm/ships/urquan/urquan.c	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/urquan/urquan.c	2017-11-21 19:39:59 -0600
@@ -24,27 +24,44 @@
 
 #include <stdlib.h>
 
-
+// Core characteristics
 #define MAX_CREW MAX_CREW_SIZE
 #define MAX_ENERGY MAX_ENERGY_SIZE
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 6
-#define SPECIAL_ENERGY_COST 8
 #define ENERGY_WAIT 4
 #define MAX_THRUST 30
 #define THRUST_INCREMENT 6
-#define TURN_WAIT 4
 #define THRUST_WAIT 6
-#define WEAPON_WAIT 6
-#define SPECIAL_WAIT 9
-
+#define TURN_WAIT 4
 #define SHIP_MASS 10
+
+// Fusion blast
+#define WEAPON_ENERGY_COST 6
+#define WEAPON_WAIT 6
 #define MISSILE_SPEED DISPLAY_TO_WORLD (20)
 #define MISSILE_LIFE 20
+#define MISSILE_HITS 10
+#define MISSILE_DAMAGE 6
+#define MISSILE_OFFSET 8
+#define URQUAN_OFFSET 32
+
+// Fighters
+#define SPECIAL_ENERGY_COST 8
+#define SPECIAL_WAIT 9
+#define FIGHTER_OFFSET 4
+#define FIGHTER_SPEED DISPLAY_TO_WORLD (8)
+#define ONE_WAY_FLIGHT 125
+#define TRACK_THRESHOLD 6
+#define FIGHTER_LIFE (ONE_WAY_FLIGHT + ONE_WAY_FLIGHT + 150)
+#define FIGHTER_HITS 1
+#define FIGHTER_MASS 0
+#define FIGHTER_WEAPON_WAIT 8
+#define FIGHTER_LASER_RANGE DISPLAY_TO_WORLD (40 + FIGHTER_OFFSET)
 
 static RACE_DESC urquan_desc =
 {
 	{ /* SHIP_INFO */
+		"dreadnought",
 		FIRES_FORE | SEEKING_SPECIAL,
 		30, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -116,10 +133,6 @@ static RACE_DESC urquan_desc =
 static COUNT
 initialize_fusion (ELEMENT *ShipPtr, HELEMENT FusionArray[])
 {
-#define MISSILE_HITS 10
-#define MISSILE_DAMAGE 6
-#define MISSILE_OFFSET 8
-#define URQUAN_OFFSET 32
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -142,15 +155,6 @@ initialize_fusion (ELEMENT *ShipPtr, HEL
 	return (1);
 }
 
-#define TRACK_THRESHOLD 6
-#define FIGHTER_SPEED DISPLAY_TO_WORLD (8)
-#define ONE_WAY_FLIGHT 125
-#define FIGHTER_LIFE (ONE_WAY_FLIGHT + ONE_WAY_FLIGHT + 150)
-
-#define FIGHTER_WEAPON_WAIT 8
-#define FIGHTER_OFFSET 4
-#define LASER_RANGE DISPLAY_TO_WORLD (40 + FIGHTER_OFFSET)
-
 static void
 fighter_postprocess (ELEMENT *ElementPtr)
 {
@@ -162,8 +166,8 @@ fighter_postprocess (ELEMENT *ElementPtr
 	LaserBlock.cx = ElementPtr->next.location.x;
 	LaserBlock.cy = ElementPtr->next.location.y;
 	LaserBlock.face = ElementPtr->thrust_wait;
-	LaserBlock.ex = COSINE (FACING_TO_ANGLE (LaserBlock.face), LASER_RANGE);
-	LaserBlock.ey = SINE (FACING_TO_ANGLE (LaserBlock.face), LASER_RANGE);
+	LaserBlock.ex = COSINE (FACING_TO_ANGLE (LaserBlock.face), FIGHTER_LASER_RANGE);
+	LaserBlock.ey = SINE (FACING_TO_ANGLE (LaserBlock.face), FIGHTER_LASER_RANGE);
 	LaserBlock.sender = ElementPtr->playerNr;
 	LaserBlock.flags = IGNORE_SIMILAR;
 	LaserBlock.pixoffs = FIGHTER_OFFSET;
@@ -256,10 +260,10 @@ fighter_preprocess (ELEMENT *ElementPtr)
 			delta_y = WRAP_DELTA_Y (delta_y);
 
 			if (ElementPtr->thrust_wait == 0
-					&& abs (delta_x) < LASER_RANGE * 3 / 4
-					&& abs (delta_y) < LASER_RANGE * 3 / 4
+					&& abs (delta_x) < FIGHTER_LASER_RANGE * 3 / 4
+					&& abs (delta_y) < FIGHTER_LASER_RANGE * 3 / 4
 					&& delta_x * delta_x + delta_y * delta_y <
-					(LASER_RANGE * 3 / 4) * (LASER_RANGE * 3 / 4))
+					(FIGHTER_LASER_RANGE * 3 / 4) * (FIGHTER_LASER_RANGE * 3 / 4))
 			{
 				ElementPtr->thrust_wait =
 						(BYTE)NORMALIZE_FACING (
@@ -414,8 +418,8 @@ spawn_fighters (ELEMENT *ElementPtr)
 
 		PutElement (hFighterElement);
 		LockElement (hFighterElement, &FighterElementPtr);
-		FighterElementPtr->hit_points = 1;
-		FighterElementPtr->mass_points = 0;
+		FighterElementPtr->hit_points = FIGHTER_HITS;
+		FighterElementPtr->mass_points = FIGHTER_MASS;
 		FighterElementPtr->thrust_wait = TRACK_THRESHOLD + 1;
 		FighterElementPtr->playerNr = ElementPtr->playerNr;
 		FighterElementPtr->state_flags = APPEARING | FINITE_LIFE
diff -ruNp src.orig/uqm/ships/urquan/urquan.h src/uqm/ships/urquan/urquan.h
--- src.orig/uqm/ships/urquan/urquan.h	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/urquan/urquan.h	2017-11-21 19:39:59 -0600
@@ -17,7 +17,15 @@
 #ifndef URQUAN_H
 #define URQUAN_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_urquan (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* URQUAN_H */
 
diff -ruNp src.orig/uqm/ships/utwig/Makeinfo src/uqm/ships/utwig/Makeinfo
--- src.orig/uqm/ships/utwig/Makeinfo	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/utwig/Makeinfo	2017-11-21 19:39:59 -0600
@@ -1 +1,2 @@
 uqm_CFILES="utwig.c"
+uqm_HFILES="icode.h resinst.h utwig.h"
diff -ruNp src.orig/uqm/ships/utwig/icode.h src/uqm/ships/utwig/icode.h
--- src.orig/uqm/ships/utwig/icode.h	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/utwig/icode.h	2017-11-21 19:39:59 -0600
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define UTWIG_CODE "ship.utwig.code"
diff -ruNp src.orig/uqm/ships/utwig/resinst.h src/uqm/ships/utwig/resinst.h
--- src.orig/uqm/ships/utwig/resinst.h	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/utwig/resinst.h	2017-11-21 19:39:59 -0600
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define LANCE_BIG_MASK_PMAP_ANIM "ship.utwig.graphics.lance.large"
 #define LANCE_MED_MASK_PMAP_ANIM "ship.utwig.graphics.lance.medium"
 #define LANCE_SML_MASK_PMAP_ANIM "ship.utwig.graphics.lance.small"
@@ -6,9 +10,7 @@
 #define UTWIG_ICON_MASK_PMAP_ANIM "ship.utwig.icons"
 #define UTWIG_MED_MASK_PMAP_ANIM "ship.utwig.graphics.jugger.medium"
 #define UTWIG_MICON_MASK_PMAP_ANIM "ship.utwig.meleeicons"
-#define UTWIG_SML_MASK_PMAP_ANIM "ship.utwig.graphics.jugger.small"
 #define UTWIG_RACE_STRINGS "ship.utwig.text"
 #define UTWIG_SHIP_SOUNDS "ship.utwig.sounds"
+#define UTWIG_SML_MASK_PMAP_ANIM "ship.utwig.graphics.jugger.small"
 #define UTWIG_VICTORY_SONG "ship.utwig.ditty"
-
-#include "icode.h"
diff -ruNp src.orig/uqm/ships/utwig/utwig.c src/uqm/ships/utwig/utwig.c
--- src.orig/uqm/ships/utwig/utwig.c	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/utwig/utwig.c	2017-11-21 19:39:59 -0600
@@ -23,28 +23,41 @@
 #include "uqm/globdata.h"
 #include "libs/mathlib.h"
 
-
+// Core characteristics
 #define MAX_CREW 20
 #define MAX_ENERGY 20
 #define ENERGY_REGENERATION 0
-#define WEAPON_ENERGY_COST 0
-#define SPECIAL_ENERGY_COST 1
 #define ENERGY_WAIT 255
 #define MAX_THRUST 36
 #define THRUST_INCREMENT 6
-#define TURN_WAIT 1
 #define THRUST_WAIT 6
-#define WEAPON_WAIT 7
-#define SPECIAL_WAIT 12
-
+#define TURN_WAIT 1
 #define SHIP_MASS 8
+
+// Weapon
+#define WEAPON_ENERGY_COST 0
+#define WEAPON_WAIT 7
 #define UTWIG_OFFSET 9
 #define MISSILE_SPEED DISPLAY_TO_WORLD (30)
 #define MISSILE_LIFE 10
+#define MISSILE_HITS 1
+#define MISSILE_DAMAGE 1
+#define MISSILE_OFFSET 1
+#define LAUNCH_XOFFS0 DISPLAY_TO_WORLD (5)
+#define LAUNCH_YOFFS0 -DISPLAY_TO_WORLD (18)
+#define LAUNCH_XOFFS1 DISPLAY_TO_WORLD (13)
+#define LAUNCH_YOFFS1 -DISPLAY_TO_WORLD (9)
+#define LAUNCH_XOFFS2 DISPLAY_TO_WORLD (17)
+#define LAUNCH_YOFFS2 -DISPLAY_TO_WORLD (4)
+
+// Shield
+#define SPECIAL_ENERGY_COST 1
+#define SPECIAL_WAIT 12
 
 static RACE_DESC utwig_desc =
 {
 	{ /* SHIP_INFO */
+		"jugger",
 		FIRES_FORE | POINT_DEFENSE | SHIELD_DEFENSE,
 		22, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -116,15 +129,6 @@ static RACE_DESC utwig_desc =
 static COUNT
 initialize_lance (ELEMENT *ShipPtr, HELEMENT WeaponArray[])
 {
-#define LAUNCH_XOFFS0 DISPLAY_TO_WORLD (5)
-#define LAUNCH_YOFFS0 -DISPLAY_TO_WORLD (18)
-#define LAUNCH_XOFFS1 DISPLAY_TO_WORLD (13)
-#define LAUNCH_YOFFS1 -DISPLAY_TO_WORLD (9)
-#define LAUNCH_XOFFS2 DISPLAY_TO_WORLD (17)
-#define LAUNCH_YOFFS2 -DISPLAY_TO_WORLD (4)
-#define MISSILE_HITS 1
-#define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET 1
 	COUNT i;
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
diff -ruNp src.orig/uqm/ships/utwig/utwig.h src/uqm/ships/utwig/utwig.h
--- src.orig/uqm/ships/utwig/utwig.h	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/utwig/utwig.h	2017-11-21 19:39:59 -0600
@@ -17,7 +17,15 @@
 #ifndef UTWIG_H
 #define UTWIG_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_utwig (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* UTWIG_H */
 
diff -ruNp src.orig/uqm/ships/vux/Makeinfo src/uqm/ships/vux/Makeinfo
--- src.orig/uqm/ships/vux/Makeinfo	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/vux/Makeinfo	2017-11-21 19:40:00 -0600
@@ -1 +1,2 @@
 uqm_CFILES="vux.c"
+uqm_HFILES="icode.h resinst.h vux.h"
diff -ruNp src.orig/uqm/ships/vux/icode.h src/uqm/ships/vux/icode.h
--- src.orig/uqm/ships/vux/icode.h	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/vux/icode.h	2017-11-21 19:40:00 -0600
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define VUX_CODE "ship.vux.code"
diff -ruNp src.orig/uqm/ships/vux/resinst.h src/uqm/ships/vux/resinst.h
--- src.orig/uqm/ships/vux/resinst.h	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/vux/resinst.h	2017-11-21 19:40:00 -0600
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define LIMPETS_BIG_MASK_PMAP_ANIM "ship.vux.graphics.limpets.large"
 #define LIMPETS_MED_MASK_PMAP_ANIM "ship.vux.graphics.limpets.medium"
 #define LIMPETS_SML_MASK_PMAP_ANIM "ship.vux.graphics.limpets.small"
@@ -7,9 +11,7 @@
 #define VUX_ICON_MASK_PMAP_ANIM "ship.vux.icons"
 #define VUX_MED_MASK_PMAP_ANIM "ship.vux.graphics.intruder.medium"
 #define VUX_MICON_MASK_PMAP_ANIM "ship.vux.meleeicons"
-#define VUX_SML_MASK_PMAP_ANIM "ship.vux.graphics.intruder.small"
 #define VUX_RACE_STRINGS "ship.vux.text"
 #define VUX_SHIP_SOUNDS "ship.vux.sounds"
+#define VUX_SML_MASK_PMAP_ANIM "ship.vux.graphics.intruder.small"
 #define VUX_VICTORY_SONG "ship.vux.ditty"
-
-#include "icode.h"
diff -ruNp src.orig/uqm/ships/vux/vux.c src/uqm/ships/vux/vux.c
--- src.orig/uqm/ships/vux/vux.c	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/vux/vux.c	2017-11-21 19:40:00 -0600
@@ -23,29 +23,48 @@
 #include "uqm/globdata.h"
 #include "libs/mathlib.h"
 
-
+// Core characteristics
 #define MAX_CREW 20
 #define MAX_ENERGY 40
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 1
-#define SPECIAL_ENERGY_COST 2
 #define ENERGY_WAIT 8
 #define MAX_THRUST /* DISPLAY_TO_WORLD (5) */ 21
 #define THRUST_INCREMENT /* DISPLAY_TO_WORLD (2) */ 7
-#define TURN_WAIT 6
 #define THRUST_WAIT 4
-#define WEAPON_WAIT 0
-#define SPECIAL_WAIT 7
-
+#define TURN_WAIT 6
 #define SHIP_MASS 6
-#define WARP_OFFSET 46 /* How far outside of laser-range ship can warp in */
+
+// Laser
+#define WEAPON_ENERGY_COST 1
+#define WEAPON_WAIT 0
 #define VUX_OFFSET 12
 #define LASER_BASE 150
 #define LASER_RANGE DISPLAY_TO_WORLD (LASER_BASE + VUX_OFFSET)
 
+// Limpet
+#define SPECIAL_ENERGY_COST 2
+#define SPECIAL_WAIT 7
+#define LIMPET_SPEED 25
+#define LIMPET_OFFSET 8
+#define LIMPET_LIFE 80
+#define LIMPET_HITS 1
+#define LIMPET_DAMAGE 0
+#define MIN_THRUST_INCREMENT DISPLAY_TO_WORLD (1)
+
+// Aggressive Entry
+#define WARP_OFFSET 46
+		/* How far outside of the laser range can the ship warp in. */
+#define MAXX_ENTRY_DIST DISPLAY_TO_WORLD ((LASER_BASE + VUX_OFFSET + WARP_OFFSET) << 1)
+#define MAXY_ENTRY_DIST DISPLAY_TO_WORLD ((LASER_BASE + VUX_OFFSET + WARP_OFFSET) << 1)
+		/* Originally, the warp distance was:
+		 * DISPLAY_TO_WORLD (SPACE_HEIGHT << 1)
+		 * where SPACE_HEIGHT = SCREEN_HEIGHT - (SAFE_Y * 2)
+		 * But in reality this should be relative to the laser-range. */
+
 static RACE_DESC vux_desc =
 {
 	{ /* SHIP_INFO */
+		"intruder",
 		FIRES_FORE | SEEKING_SPECIAL | IMMEDIATE_WEAPON,
 		12, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -114,7 +133,6 @@ static RACE_DESC vux_desc =
 	0, /* CodeRef */
 };
 
-#define LIMPET_SPEED 25
 
 static void
 limpet_preprocess (ELEMENT *ElementPtr)
@@ -128,8 +146,7 @@ limpet_preprocess (ELEMENT *ElementPtr)
 	if ((delta_facing = TrackShip (ElementPtr, &facing)) > 0)
 	{
 		facing = orig_facing + delta_facing;
-		SetVelocityVector (&ElementPtr->velocity,
-				LIMPET_SPEED, facing);
+		SetVelocityVector (&ElementPtr->velocity, LIMPET_SPEED, facing);
 	}
 	ElementPtr->next.image.frame =
 			 IncFrameIndex (ElementPtr->next.image.frame);
@@ -154,7 +171,6 @@ limpet_collision (ELEMENT *ElementPtr0,
 			--RDPtr->characteristics.turn_wait;
 		if (++RDPtr->characteristics.thrust_wait == 0)
 			--RDPtr->characteristics.thrust_wait;
-#define MIN_THRUST_INCREMENT DISPLAY_TO_WORLD (1)
 		if (RDPtr->characteristics.thrust_increment <= MIN_THRUST_INCREMENT)
 		{
 			RDPtr->characteristics.max_thrust =
@@ -193,10 +209,6 @@ limpet_collision (ELEMENT *ElementPtr0,
 static void
 spawn_limpets (ELEMENT *ElementPtr)
 {
-#define LIMPET_OFFSET 8
-#define LIMPET_LIFE 80
-#define LIMPET_HITS 1
-#define LIMPET_DAMAGE 0
 	HELEMENT Limpet;
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
@@ -327,12 +339,6 @@ vux_preprocess (ELEMENT *ElementPtr)
 
 			do
 			{
-				// Originally, the warp distance was:
-				// DISPLAY_TO_WORLD (SPACE_HEIGHT << 1)
-				// where SPACE_HEIGHT = SCREEN_HEIGHT - (SAFE_Y * 2)
-				// But in reality this should be relative to the laser-range
-#define MAXX_ENTRY_DIST DISPLAY_TO_WORLD ((LASER_BASE + VUX_OFFSET + WARP_OFFSET) << 1)
-#define MAXY_ENTRY_DIST DISPLAY_TO_WORLD ((LASER_BASE + VUX_OFFSET + WARP_OFFSET) << 1)
 				SIZE dx, dy;
 
 				ElementPtr->current.location.x =
diff -ruNp src.orig/uqm/ships/vux/vux.h src/uqm/ships/vux/vux.h
--- src.orig/uqm/ships/vux/vux.h	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/vux/vux.h	2017-11-21 19:40:00 -0600
@@ -17,7 +17,15 @@
 #ifndef VUX_H
 #define VUX_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_vux (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* VUX_H */
 
diff -ruNp src.orig/uqm/ships/yehat/Makeinfo src/uqm/ships/yehat/Makeinfo
--- src.orig/uqm/ships/yehat/Makeinfo	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/yehat/Makeinfo	2017-11-21 19:40:00 -0600
@@ -1 +1,2 @@
 uqm_CFILES="yehat.c"
+uqm_HFILES="icode.h resinst.h yehat.h"
diff -ruNp src.orig/uqm/ships/yehat/icode.h src/uqm/ships/yehat/icode.h
--- src.orig/uqm/ships/yehat/icode.h	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/yehat/icode.h	2017-11-21 19:40:00 -0600
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define YEHAT_CODE "ship.yehat.code"
diff -ruNp src.orig/uqm/ships/yehat/resinst.h src/uqm/ships/yehat/resinst.h
--- src.orig/uqm/ships/yehat/resinst.h	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/yehat/resinst.h	2017-11-21 19:40:00 -0600
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SHIELD_BIG_MASK_ANIM "ship.yehat.graphics.shield.large"
 #define SHIELD_MED_MASK_ANIM "ship.yehat.graphics.shield.medium"
 #define SHIELD_SML_MASK_ANIM "ship.yehat.graphics.shield.small"
@@ -9,9 +13,7 @@
 #define YEHAT_ICON_MASK_PMAP_ANIM "ship.yehat.icons"
 #define YEHAT_MED_MASK_PMAP_ANIM "ship.yehat.graphics.terminator.medium"
 #define YEHAT_MICON_MASK_PMAP_ANIM "ship.yehat.meleeicons"
-#define YEHAT_SML_MASK_PMAP_ANIM "ship.yehat.graphics.terminator.small"
 #define YEHAT_RACE_STRINGS "ship.yehat.text"
 #define YEHAT_SHIP_SOUNDS "ship.yehat.sounds"
+#define YEHAT_SML_MASK_PMAP_ANIM "ship.yehat.graphics.terminator.small"
 #define YEHAT_VICTORY_SONG "ship.yehat.ditty"
-
-#include "icode.h"
diff -ruNp src.orig/uqm/ships/yehat/yehat.c src/uqm/ships/yehat/yehat.c
--- src.orig/uqm/ships/yehat/yehat.c	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/yehat/yehat.c	2017-11-21 19:40:00 -0600
@@ -22,27 +22,37 @@
 
 #include "libs/mathlib.h"
 
-
+// Core characteristics
 #define MAX_CREW 20
 #define MAX_ENERGY 10
 #define ENERGY_REGENERATION 2
-#define WEAPON_ENERGY_COST 1
-#define SPECIAL_ENERGY_COST 3
 #define ENERGY_WAIT 6
 #define MAX_THRUST 30
 #define THRUST_INCREMENT 6
-#define TURN_WAIT 2
 #define THRUST_WAIT 2
-#define WEAPON_WAIT 0
-#define SPECIAL_WAIT 2
-
+#define TURN_WAIT 2
 #define SHIP_MASS 3
+
+// Twin Pulse Cannon
+#define WEAPON_ENERGY_COST 1
+#define WEAPON_WAIT 0
+#define YEHAT_OFFSET 16
+#define LAUNCH_OFFS DISPLAY_TO_WORLD (8)
 #define MISSILE_SPEED DISPLAY_TO_WORLD (20)
 #define MISSILE_LIFE 10
+#define MISSILE_HITS 1
+#define MISSILE_DAMAGE 1
+#define MISSILE_OFFSET 1
+
+// Force Shield
+#define SPECIAL_ENERGY_COST 3
+#define SPECIAL_WAIT 2
+#define SHIELD_LIFE 10
 
 static RACE_DESC yehat_desc =
 {
 	{ /* SHIP_INFO */
+		"terminator",
 		FIRES_FORE | SHIELD_DEFENSE,
 		23, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -114,11 +124,6 @@ static RACE_DESC yehat_desc =
 static COUNT
 initialize_standard_missiles (ELEMENT *ShipPtr, HELEMENT MissileArray[])
 {
-#define YEHAT_OFFSET 16
-#define LAUNCH_OFFS DISPLAY_TO_WORLD (8)
-#define MISSILE_HITS 1
-#define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET 1
 	SIZE offs_x, offs_y;
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
@@ -334,7 +339,6 @@ yehat_preprocess (ELEMENT *ElementPtr)
 				DeltaEnergy (ElementPtr, -SPECIAL_ENERGY_COST); /* so text will flash */
 			else
 			{
-#define SHIELD_LIFE 10
 				ElementPtr->life_span = SHIELD_LIFE + NORMAL_LIFE;
 
 				ElementPtr->next.image.farray = StarShipPtr->RaceDescPtr->ship_data.special;
diff -ruNp src.orig/uqm/ships/yehat/yehat.h src/uqm/ships/yehat/yehat.h
--- src.orig/uqm/ships/yehat/yehat.h	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/yehat/yehat.h	2017-11-21 19:40:00 -0600
@@ -17,7 +17,15 @@
 #ifndef YEHAT_H
 #define YEHAT_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_yehat (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* YEHAT_H */
 
diff -ruNp src.orig/uqm/ships/zoqfot/Makeinfo src/uqm/ships/zoqfot/Makeinfo
--- src.orig/uqm/ships/zoqfot/Makeinfo	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/zoqfot/Makeinfo	2017-11-21 19:40:00 -0600
@@ -1 +1,2 @@
 uqm_CFILES="zoqfot.c"
+uqm_HFILES="icode.h resinst.h zoqfot.h"
diff -ruNp src.orig/uqm/ships/zoqfot/icode.h src/uqm/ships/zoqfot/icode.h
--- src.orig/uqm/ships/zoqfot/icode.h	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/zoqfot/icode.h	2017-11-21 19:40:00 -0600
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define ZOQFOTPIK_CODE "ship.zoqfotpik.code"
diff -ruNp src.orig/uqm/ships/zoqfot/resinst.h src/uqm/ships/zoqfot/resinst.h
--- src.orig/uqm/ships/zoqfot/resinst.h	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/zoqfot/resinst.h	2017-11-21 19:40:00 -0600
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SPIT_BIG_MASK_PMAP_ANIM "ship.zoqfotpik.graphics.spit.large"
 #define SPIT_MED_MASK_PMAP_ANIM "ship.zoqfotpik.graphics.spit.medium"
 #define SPIT_SML_MASK_PMAP_ANIM "ship.zoqfotpik.graphics.spit.small"
@@ -9,9 +13,7 @@
 #define ZOQFOTPIK_ICON_MASK_PMAP_ANIM "ship.zoqfotpik.icons"
 #define ZOQFOTPIK_MED_MASK_PMAP_ANIM "ship.zoqfotpik.graphics.stinger.medium"
 #define ZOQFOTPIK_MICON_MASK_PMAP_ANIM "ship.zoqfotpik.meleeicons"
-#define ZOQFOTPIK_SML_MASK_PMAP_ANIM "ship.zoqfotpik.graphics.stinger.small"
 #define ZOQFOTPIK_RACE_STRINGS "ship.zoqfotpik.text"
 #define ZOQFOTPIK_SHIP_SOUNDS "ship.zoqfotpik.sounds"
+#define ZOQFOTPIK_SML_MASK_PMAP_ANIM "ship.zoqfotpik.graphics.stinger.small"
 #define ZOQFOTPIK_VICTORY_SONG "ship.zoqfotpik.ditty"
-
-#include "icode.h"
diff -ruNp src.orig/uqm/ships/zoqfot/zoqfot.c src/uqm/ships/zoqfot/zoqfot.c
--- src.orig/uqm/ships/zoqfot/zoqfot.c	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/zoqfot/zoqfot.c	2017-11-21 19:40:00 -0600
@@ -22,28 +22,44 @@
 
 #include "libs/mathlib.h"
 
-
+// Core characteristics
 #define MAX_CREW 10
 #define MAX_ENERGY 10
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 1
-#define SPECIAL_ENERGY_COST (MAX_ENERGY * 3 / 4)
 #define ENERGY_WAIT 4
 #define MAX_THRUST 40
 #define THRUST_INCREMENT 10
-#define TURN_WAIT 1
 #define THRUST_WAIT 0
-#define WEAPON_WAIT 0
-#define SPECIAL_WAIT 6
-
+#define TURN_WAIT 1
 #define SHIP_MASS 5
+
+// Main weapon
+#define WEAPON_ENERGY_COST 1
+#define WEAPON_WAIT 0
+#define ZOQFOTPIK_OFFSET 13
+#define MISSILE_OFFSET 0
 #define MISSILE_SPEED DISPLAY_TO_WORLD (10)
+		/* Used by the cyborg only. */
 #define MISSILE_LIFE 10
 #define MISSILE_RANGE (MISSILE_SPEED * MISSILE_LIFE)
+#define MISSILE_DAMAGE 1
+#define MISSILE_HITS 1
+#define SPIT_WAIT 2
+		/* Controls the main weapon color change animation's speed.
+		 * The animation advances one frame every SPIT_WAIT frames. */
+
+// Tongue
+#define SPECIAL_ENERGY_COST (MAX_ENERGY * 3 / 4)
+#define SPECIAL_WAIT 6
+#define TONGUE_SPEED 0
+#define TONGUE_HITS 1
+#define TONGUE_DAMAGE 12
+#define TONGUE_OFFSET 4
 
 static RACE_DESC zoqfotpik_desc =
 {
 	{ /* SHIP_INFO */
+		"stinger",
 		FIRES_FORE,
 		6, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -112,12 +128,10 @@ static RACE_DESC zoqfotpik_desc =
 	0, /* CodeRef */
 };
 
-#define ZOQFOTPIK_OFFSET 13
-#define SPIT_WAIT 2
-
 static void
 spit_preprocess (ELEMENT *ElementPtr)
 {
+	/* turn_wait is abused here to control the animation speed. */
 	if (ElementPtr->turn_wait > 0)
 		--ElementPtr->turn_wait;
 	else
@@ -136,6 +150,7 @@ spit_preprocess (ELEMENT *ElementPtr)
 				(SIZE)COSINE (angle, speed),
 				(SIZE)SINE (angle, speed));
 
+		/* turn_wait is abused here to control the animation speed. */
 		ElementPtr->turn_wait = SPIT_WAIT;
 		ElementPtr->state_flags |= CHANGING;
 	}
@@ -144,9 +159,6 @@ spit_preprocess (ELEMENT *ElementPtr)
 static COUNT
 initialize_spit (ELEMENT *ShipPtr, HELEMENT SpitArray[])
 {
-#define MISSILE_DAMAGE 1
-#define MISSILE_HITS 1
-#define MISSILE_OFFSET 0
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -199,10 +211,6 @@ tongue_collision (ELEMENT *ElementPtr0,
 static void
 spawn_tongue (ELEMENT *ElementPtr)
 {
-#define TONGUE_SPEED 0
-#define TONGUE_HITS 1
-#define TONGUE_DAMAGE 12
-#define TONGUE_OFFSET 4
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK TongueBlock;
 	HELEMENT Tongue;
diff -ruNp src.orig/uqm/ships/zoqfot/zoqfot.h src/uqm/ships/zoqfot/zoqfot.h
--- src.orig/uqm/ships/zoqfot/zoqfot.h	2017-11-21 19:39:42 -0600
+++ src/uqm/ships/zoqfot/zoqfot.h	2017-11-21 19:40:00 -0600
@@ -17,7 +17,15 @@
 #ifndef ZOQFOT_H
 #define ZOQFOT_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_zoqfotpik (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* ZOQFOT_H */
 
diff -ruNp src.orig/uqm/shipyard.c src/uqm/shipyard.c
--- src.orig/uqm/shipyard.c	2017-11-21 19:39:42 -0600
+++ src/uqm/shipyard.c	2017-11-21 19:40:00 -0600
@@ -73,6 +73,20 @@ enum
 	SHIPYARD_EXIT
 };
 
+// Editing mode for DoModifyShips()
+typedef enum {
+	DMS_Mode_navigate,   // Navigating the ship slots.
+	DMS_Mode_addEscort,  // Selecting a ship to add to an empty slot.
+	DMS_Mode_editCrew,   // Hiring or dismissing crew.
+	DMS_Mode_exit,       // Leaving DoModifyShips() mode.
+} DMS_Mode;
+
+static COUNT ShipCost[] =
+{
+	RACE_SHIP_COST
+};
+
+
 static void
 animatePowerLines (MENU_STATE *pMS)
 {
@@ -105,11 +119,9 @@ on_input_frame (void)
 {
 	CONTEXT oldContext;
 
-	LockMutex (GraphicsLock);
 	oldContext = SetContext (SpaceContext);
 	animatePowerLines (NULL);
 	SetContext (oldContext);
-	UnlockMutex (GraphicsLock);
 }
 
 #ifdef WANT_SHIP_SPINS
@@ -125,9 +137,7 @@ SpinStarShip (MENU_STATE *pMS, HFLEETINF
 				
 	if (Index >= 0 && Index < NUM_MELEE_SHIPS)
 	{
-		UnlockMutex (GraphicsLock);
 		DoShipSpin (Index, pMS->hMusic);
-		LockMutex (GraphicsLock);
 	}
 }
 #endif
@@ -187,7 +197,6 @@ DrawRaceStrings (MENU_STATE *pMS, BYTE N
 	STAMP s;
 	CONTEXT OldContext;
 	
-	LockMutex (GraphicsLock);
 
 	OldContext = SetContext (StatusContext);
 	GetContextClipRect (&r);
@@ -205,8 +214,7 @@ DrawRaceStrings (MENU_STATE *pMS, BYTE N
 	r.corner = s.origin;
 	r.extent.width = RADAR_WIDTH;
 	r.extent.height = RADAR_HEIGHT;
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x00), 0x00));
+	SetContextForeGroundColor (BLACK_COLOR);
 	DrawFilledRectangle (&r);
 	if (NewRaceItem != (BYTE)~0)
 	{
@@ -214,25 +222,26 @@ DrawRaceStrings (MENU_STATE *pMS, BYTE N
 		HFLEETINFO hStarShip;
 		FLEET_INFO *FleetPtr;
 		UNICODE buf[30];
-		COUNT ShipCost[] =
-		{
-			RACE_SHIP_COST
-		};
 
 		hStarShip = GetAvailableRaceFromIndex (NewRaceItem);
 		NewRaceItem = GetIndexFromStarShip (&GLOBAL (avail_race_q),
 				hStarShip);
+
+		// Draw the ship name, above the ship image.
 		s.frame = SetAbsFrameIndex (pMS->ModuleFrame, 3 + NewRaceItem);
 		DrawStamp (&s);
+
+		// Draw the ship image.
 		FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
 		s.frame = FleetPtr->melee_icon;
 		UnlockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
-
 		t.baseline.x = s.origin.x + RADAR_WIDTH - 2;
 		t.baseline.y = s.origin.y + RADAR_HEIGHT - 2;
 		s.origin.x += (RADAR_WIDTH >> 1);
 		s.origin.y += (RADAR_HEIGHT >> 1);
 		DrawStamp (&s);
+
+		// Print the ship cost.
 		t.align = ALIGN_RIGHT;
 		t.CharCount = (COUNT)~0;
 		t.pStr = buf;
@@ -245,37 +254,39 @@ DrawRaceStrings (MENU_STATE *pMS, BYTE N
 	UnbatchGraphics ();
 	SetContext (OldContext);
 
-	// Flash the ship purchase menu even when optMenu == OPT_PC
-	SetFlashRect (SFR_MENU_ANY);
-	UnlockMutex (GraphicsLock);
 }
 
 #define SHIP_WIN_WIDTH 34
 #define SHIP_WIN_HEIGHT (SHIP_WIN_WIDTH + 6)
 #define SHIP_WIN_FRAMES ((SHIP_WIN_WIDTH >> 1) + 1)
 
+// Print the crew count of an escort ship on top of its (already drawn)
+// image, either as '30' (full), '28/30' (partially full), or 'SCRAP'
+// (empty).
+// pRect is the rectangle of the ship image.
 static void
-ShowShipCrew (SHIP_FRAGMENT *StarShipPtr, RECT *pRect)
+ShowShipCrew (SHIP_FRAGMENT *StarShipPtr, const RECT *pRect)
 {
 	RECT r;
 	TEXT t;
 	UNICODE buf[80];
 	HFLEETINFO hTemplate;
 	FLEET_INFO *TemplatePtr;
+	COUNT maxCrewLevel;
 
 	hTemplate = GetStarShipFromIndex (&GLOBAL (avail_race_q),
 			StarShipPtr->race_id);
 	TemplatePtr = LockFleetInfo (&GLOBAL (avail_race_q), hTemplate);
-	if (StarShipPtr->crew_level >= TemplatePtr->crew_level)
+	maxCrewLevel = TemplatePtr->crew_level;
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hTemplate);
+
+	if (StarShipPtr->crew_level >= maxCrewLevel)
 		sprintf (buf, "%u", StarShipPtr->crew_level);
 	else if (StarShipPtr->crew_level == 0)
 		// XXX: "SCRAP" needs to be moved to starcon.txt
 		utf8StringCopy (buf, sizeof (buf), "SCRAP");
 	else
-		sprintf (buf, "%u/%u",
-				StarShipPtr->crew_level,
-				TemplatePtr->crew_level);
-	UnlockFleetInfo (&GLOBAL (avail_race_q), hTemplate);
+		sprintf (buf, "%u/%u", StarShipPtr->crew_level, maxCrewLevel);
 
 	r = *pRect;
 	t.baseline.x = r.corner.x + (r.extent.width >> 1);
@@ -301,14 +312,17 @@ static void
 ShowCombatShip (MENU_STATE *pMS, COUNT which_window,
 		SHIP_FRAGMENT *YankedStarShipPtr)
 {
-	COUNT i, num_ships;
+	COUNT i;
+	COUNT num_ships;
 	HSHIPFRAG hStarShip, hNextShip;
 	SHIP_FRAGMENT *StarShipPtr;
 	struct
 	{
 		SHIP_FRAGMENT *StarShipPtr;
 		POINT finished_s;
-		STAMP ship_s, lfdoor_s, rtdoor_s;
+		STAMP ship_s;
+		STAMP lfdoor_s;
+		STAMP rtdoor_s;
 	} ship_win_info[MAX_BUILT_SHIPS], *pship_win_info;
 
 	num_ships = 1;
@@ -376,6 +390,10 @@ ShowCombatShip (MENU_STATE *pMS, COUNT w
 			hNextShip = _GetSuccLink (StarShipPtr);
 
 			pship_win_info->StarShipPtr = StarShipPtr;
+					// XXX BUG: this looks wrong according to the original
+					// semantics of LockShipFrag(): StarShipPtr is not valid
+					// anymore after UnlockShipFrag() is called, but it is
+					// used thereafter.
 
 			pship_win_info->lfdoor_s.origin.x = -1;
 			pship_win_info->rtdoor_s.origin.x = 1;
@@ -431,7 +449,6 @@ ShowCombatShip (MENU_STATE *pMS, COUNT w
 				AllDoorsFinished = TRUE;
 			}
 
-			LockMutex (GraphicsLock);
 			OldContext = SetContext (SpaceContext);
 			GetContextClipRect (&OldClipRect);
 			SetContextBackGroundColor (BLACK_COLOR);
@@ -479,7 +496,6 @@ ShowCombatShip (MENU_STATE *pMS, COUNT w
 #endif
 			UnbatchGraphics ();
 			SetContext (OldContext);
-			UnlockMutex (GraphicsLock);
 		}
 	}
 }
@@ -507,10 +523,7 @@ CrewTransaction (SIZE crew_delta)
 					&& crew_bought - crew_delta < CREW_EXPENSE_THRESHOLD)
 			{
 				GLOBAL (CrewCost) += 2;
-
-				UnlockMutex (GraphicsLock);
 				DrawMenuStateStrings (PM_CREW, SHIPYARD_CREW);
-				LockMutex (GraphicsLock);
 			}
 		}
 		else
@@ -519,13 +532,10 @@ CrewTransaction (SIZE crew_delta)
 					&& crew_bought - crew_delta >= CREW_EXPENSE_THRESHOLD)
 			{
 				GLOBAL (CrewCost) -= 2;
-
-				UnlockMutex (GraphicsLock);
 				DrawMenuStateStrings (PM_CREW, SHIPYARD_CREW);
-				LockMutex (GraphicsLock);
 			}
 		}
-		if (ActivateStarShip (SHOFIXTI_SHIP, CHECK_ALLIANCE) != GOOD_GUY)
+		if (CheckAlliance (SHOFIXTI_SHIP) != GOOD_GUY)
 		{
 			SET_GAME_STATE (CREW_PURCHASED0, LOBYTE (crew_bought));
 			SET_GAME_STATE (CREW_PURCHASED1, HIBYTE (crew_bought));
@@ -533,510 +543,726 @@ CrewTransaction (SIZE crew_delta)
 	}
 }
 
-/* in this routine, the least significant byte of pMS->CurState is used
- * to store the current selected ship index
- * a special case for the row is hi-nibble == -1 (0xf), which specifies
- * SIS as the selected ship
- * some bitwise math is still done to scroll through ships, for it to work
- * ships per row number must divide 0xf0 without remainder
- */
-static BOOLEAN
-DoModifyShips (MENU_STATE *pMS)
+static void
+DMS_FlashFlagShip (void)
+{
+	RECT r;
+	r.corner.x = 0;
+	r.corner.y = 0;
+	r.extent.width = SIS_SCREEN_WIDTH;
+	r.extent.height = 61;
+	SetFlashRect (&r);
+}
+
+static void
+DMS_GetEscortShipRect (RECT *rOut, BYTE slotNr)
+{
+	BYTE row = slotNr / HANGAR_SHIPS_ROW;
+	BYTE col = slotNr % HANGAR_SHIPS_ROW;
+
+	rOut->corner.x = hangar_x_coords[col];
+	rOut->corner.y = HANGAR_Y + (HANGAR_DY * row);
+	rOut->extent.width = SHIP_WIN_WIDTH;
+	rOut->extent.height = SHIP_WIN_HEIGHT;
+}
+
+static void
+DMS_FlashEscortShip (BYTE slotNr)
+{
+	RECT r;
+	DMS_GetEscortShipRect (&r, slotNr);
+	SetFlashRect (&r);
+}
+
+static void
+DMS_FlashFlagShipCrewCount (void)
+{
+	RECT r;
+	SetContext (StatusContext);
+	GetGaugeRect (&r, TRUE);
+	SetFlashRect (&r);
+	SetContext (SpaceContext);
+}
+
+static void
+DMS_FlashEscortShipCrewCount (BYTE slotNr)
 {
+	RECT r;
+	BYTE row = slotNr / HANGAR_SHIPS_ROW;
+	BYTE col = slotNr % HANGAR_SHIPS_ROW;
+
+	r.corner.x = hangar_x_coords[col];
+	r.corner.y = (HANGAR_Y + (HANGAR_DY * row)) + (SHIP_WIN_HEIGHT - 6);
+	r.extent.width = SHIP_WIN_WIDTH;
+	r.extent.height = 5;
+
+	SetContext (SpaceContext);
+	SetFlashRect (&r);
+}
+
+// Helper function for DoModifyShips(). Called to change the flash
+// rectangle to the currently selected ship (flagship or escort ship).
+static void
+DMS_FlashActiveShip (MENU_STATE *pMS)
+{
+	if (HINIBBLE (pMS->CurState))
+	{
+		// Flash the flag ship.
+		DMS_FlashFlagShip ();
+	}
+	else
+	{
+		// Flash the current escort ship slot.
+		DMS_FlashEscortShip (pMS->CurState);
+	}
+}
+
+// Helper function for DoModifyShips(). Called to switch between
+// the various edit modes.
+// XXX: right now, this only switches the sound and flash rectangle.
+// Perhaps we should move more of the code to modify other aspects
+// here too.
+static void
+DMS_SetMode (MENU_STATE *pMS, DMS_Mode mode)
+{
+	switch (mode) {
+		case DMS_Mode_navigate:
+			SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
+			DMS_FlashActiveShip (pMS);
+			break;
+		case DMS_Mode_addEscort:
+			SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
+			SetFlashRect (SFR_MENU_ANY);
+			break;
+		case DMS_Mode_editCrew:
+			SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN,
+					MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
+			if (HINIBBLE (pMS->CurState))
+			{
+				// Enter crew editing mode for the flagship.
+				DMS_FlashFlagShipCrewCount ();
+			}
+			else
+			{
+				// Enter crew editing mode for an escort ship.
+				DMS_FlashEscortShipCrewCount (pMS->CurState);
+			}
+			break;
+		case DMS_Mode_exit:
+			SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
+			SetFlashRect (SFR_MENU_3DO);
+			break;
+	}
+}
+
 #define MODIFY_CREW_FLAG (1 << 8)
-	BOOLEAN select, cancel;
 #ifdef WANT_SHIP_SPINS
-	BOOLEAN special;
+// Helper function for DoModifyShips(), called when the player presses the
+// special button.
+// It works both when the cursor is over an escort ship, while not editing
+// the crew, and when a new ship is added.
+// hStarShip is the ship in the slot under the cursor (or 0 if no such ship).
+static BOOLEAN
+DMS_SpinShip (MENU_STATE *pMS, HSHIPFRAG hStarShip)
+{
+	HFLEETINFO hSpinShip = 0;
+	CONTEXT OldContext;
+	RECT OldClipRect;
+	
+	// No spinning the flagship.
+	if (HINIBBLE (pMS->CurState) != 0)
+		return FALSE;
 
-	special = PulsedInputState.menu[KEY_MENU_SPECIAL];
-#endif /* WANT_SHIP_SPINS */
-	select = PulsedInputState.menu[KEY_MENU_SELECT];
-	cancel = PulsedInputState.menu[KEY_MENU_CANCEL];
+	// We must either be hovering over a used ship slot, or adding a new
+	// ship to the fleet.
+	if ((hStarShip == 0) == !(pMS->delta_item & MODIFY_CREW_FLAG))
+		return FALSE;
 
-	if (GLOBAL (CurrentActivity) & CHECK_ABORT)
+	if (!hStarShip)
 	{
-		pMS->InputFunc = DoShipyard;
-		return TRUE;
+		// Selecting a ship to build.
+		hSpinShip = GetAvailableRaceFromIndex (LOBYTE (pMS->delta_item));
+		if (!hSpinShip)
+			return FALSE;
 	}
+	else
+	{
+		// Hovering over an escort ship.
+		SHIP_FRAGMENT *FragPtr = LockShipFrag (
+				&GLOBAL (built_ship_q), hStarShip);
+		hSpinShip = GetStarShipFromIndex (
+				&GLOBAL (avail_race_q), FragPtr->race_id);
+		UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+	}
+	
+	SetFlashRect (NULL);
 
-	if (!pMS->Initialized)
+	OldContext = SetContext (ScreenContext);
+	GetContextClipRect (&OldClipRect);
+
+	SpinStarShip (pMS, hSpinShip);
+
+	SetContextClipRect (&OldClipRect);
+	SetContext (OldContext);
+
+	return TRUE;
+}
+#endif  /* WANT_SHIP_SPINS */
+
+// Helper function for DoModifyShips(), called when the player presses the
+// up button when modifying the crew of the flagship.
+// Buy crew for the flagship.
+// Returns the change in crew (1 on success, 0 on failure).
+static SIZE
+DMS_HireFlagShipCrew (void)
+{
+	RECT r;
+	
+	if (GetCPodCapacity (&r.corner) <= GetCrewCount ())
 	{
-		pMS->InputFunc = DoModifyShips;
-		pMS->Initialized = TRUE;
-		pMS->CurState = MAKE_BYTE (0, 0xF);
-		pMS->delta_item = 0;
+		// At capacity.
+		return 0;
+	}
+		
+	if (GLOBAL_SIS (ResUnits) < (DWORD)GLOBAL (CrewCost))
+	{
+		// Not enough RUs.
+		return 0;
+	}
 
-		LockMutex (GraphicsLock);
-		SetContext (SpaceContext);
-		goto ChangeFlashRect;
+	// Draw a crew member.
+	DrawPoint (&r.corner);
+
+	// Update the crew counter and RU. Note that the crew counter is
+	// flashing.
+	PreUpdateFlashRect ();
+	DeltaSISGauges (1, 0, -GLOBAL (CrewCost));
+	PostUpdateFlashRect ();
+
+	return 1;
+}
+
+// Helper function for DoModifyShips(), called when the player presses the
+// down button when modifying the crew of the flagship.
+// Dismiss crew from the flagship.
+// Returns the change in crew (-1 on success, 0 on failure).
+static SIZE
+DMS_DismissFlagShipCrew (void)
+{
+	SIZE crew_bought;
+	RECT r;
+
+	if (GetCrewCount () == 0)
+	{
+		// No crew to dismiss.
+		return 0;
+	}
+
+	crew_bought = (SIZE)MAKE_WORD (
+			GET_GAME_STATE (CREW_PURCHASED0),
+			GET_GAME_STATE (CREW_PURCHASED1));
+
+	// Update the crew counter and RU. Note that the crew counter is
+	// flashing.
+	PreUpdateFlashRect ();
+	DeltaSISGauges (-1, 0, GLOBAL (CrewCost) -
+			(crew_bought == CREW_EXPENSE_THRESHOLD ? 2 : 0));
+	PostUpdateFlashRect ();
+
+	// Remove the pixel representing the crew member.
+	GetCPodCapacity (&r.corner);
+	SetContextForeGroundColor (BLACK_COLOR);
+	DrawPoint (&r.corner);
+
+	return -1;
+}
+
+// Helper function for DoModifyShips(), called when the player presses the
+// up button when modifying the crew of an escort ship.
+// Buy crew for an escort ship
+// Returns the change in crew (1 on success, 0 on failure).
+static SIZE
+DMS_HireEscortShipCrew (SHIP_FRAGMENT *StarShipPtr)
+{
+	COUNT templateMaxCrew;
+	RECT r;
+
+	{
+		// XXX Split this off into a separate function?
+		HFLEETINFO hTemplate = GetStarShipFromIndex (&GLOBAL (avail_race_q),
+				StarShipPtr->race_id);
+		FLEET_INFO *TemplatePtr =
+				LockFleetInfo (&GLOBAL (avail_race_q), hTemplate);
+		templateMaxCrew = TemplatePtr->crew_level;
+		UnlockFleetInfo (&GLOBAL (avail_race_q), hTemplate);
+	}
+	
+	if (GLOBAL_SIS (ResUnits) < (DWORD)GLOBAL (CrewCost))
+	{
+		// Not enough money to hire a crew member.
+		return 0;
+	}
+
+	if (StarShipPtr->crew_level >= StarShipPtr->max_crew)
+	{
+		// This ship cannot handle more crew.
+		return 0;
+	}
+
+	if (StarShipPtr->crew_level >= templateMaxCrew)
+	{
+		// A ship of this type cannot handle more crew.
+		return 0;
+	}
+
+	if (StarShipPtr->crew_level > 0)
+	{
+		DeltaSISGauges (0, 0, -GLOBAL (CrewCost));
 	}
 	else
 	{
-		SBYTE dx = 0;
-		SBYTE dy = 0;
-		BYTE NewState;
+		// Buy a ship.
+		DeltaSISGauges (0, 0, -(COUNT)ShipCost[StarShipPtr->race_id]);
+	}
 
-		if (!(pMS->delta_item & MODIFY_CREW_FLAG))
+	++StarShipPtr->crew_level;
+
+	PreUpdateFlashRect ();
+	DMS_GetEscortShipRect (&r, StarShipPtr->index);
+	ShowShipCrew (StarShipPtr, &r);
+	PostUpdateFlashRect ();
+
+	return 1;
+}
+
+// Helper function for DoModifyShips(), called when the player presses the
+// down button when modifying the crew of an escort ship.
+// Dismiss crew from an escort ship
+// Returns the change in crew (-1 on success, 0 on failure).
+static SIZE
+DMS_DismissEscortShipCrew (SHIP_FRAGMENT *StarShipPtr)
+{
+	SIZE crew_delta = 0;
+	RECT r;
+
+	if (StarShipPtr->crew_level > 0)
+	{
+		if (StarShipPtr->crew_level > 1)
 		{
-			SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
+			// The ship was not at 'scrap'.
+			// Give one crew member worth of RU.
+			SIZE crew_bought = (SIZE)MAKE_WORD (
+					GET_GAME_STATE (CREW_PURCHASED0),
+					GET_GAME_STATE (CREW_PURCHASED1));
+
+			DeltaSISGauges (0, 0, GLOBAL (CrewCost)
+					- (crew_bought == CREW_EXPENSE_THRESHOLD ? 2 : 0));
 		}
+		else
+		{
+			// With the last crew member, the ship will be scrapped.
+			// Give RU for the ship.
+			DeltaSISGauges (0, 0, (COUNT)ShipCost[StarShipPtr->race_id]);
+		}
+		crew_delta = -1;
+		--StarShipPtr->crew_level;
+	}
+	else
+	{	// no crew to dismiss
+		PlayMenuSound (MENU_SOUND_FAILURE);
+	}
+
+	PreUpdateFlashRect ();
+	DMS_GetEscortShipRect (&r, StarShipPtr->index);
+	ShowShipCrew (StarShipPtr, &r);
+	PostUpdateFlashRect ();
 
-		if (PulsedInputState.menu[KEY_MENU_RIGHT]) dx = 1;
-		if (PulsedInputState.menu[KEY_MENU_LEFT]) dx = -1;
-		if (PulsedInputState.menu[KEY_MENU_UP]) dy = -1;
-		if (PulsedInputState.menu[KEY_MENU_DOWN]) dy = 1;
-		NewState = pMS->CurState;
-		if (pMS->delta_item & MODIFY_CREW_FLAG)
+	return crew_delta;
+}
+
+// Helper function for DoModifyShips(), called when the player presses the
+// up or down button when modifying the crew of the flagship or of an escort
+// ship.
+// 'hStarShip' is the currently escort ship, or 0 if no ship is
+// selected.
+// 'dy' is -1 if the 'up' button was pressed, or '1' if the down button was
+// pressed.
+static void
+DMS_ModifyCrew (MENU_STATE *pMS, HSHIPFRAG hStarShip, SBYTE dy)
+{
+	SIZE crew_delta = 0;
+	SHIP_FRAGMENT *StarShipPtr = NULL;
+
+	if (hStarShip)
+		StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+
+	if (hStarShip == 0)
+	{
+		// Add/Dismiss crew for the flagship.
+		if (dy < 0)
 		{
+			// Add crew for the flagship.
+			crew_delta = DMS_HireFlagShipCrew ();
 		}
-		else if (dy)
+		else
 		{
-			if (HINIBBLE (NewState))
-				NewState = pMS->CurState % HANGAR_SHIPS_ROW;
-			else
-				NewState = (unsigned char)(pMS->CurState + HANGAR_SHIPS_ROW);
+			// Dismiss crew from the flagship.
+			crew_delta = DMS_DismissFlagShipCrew ();
+		}
 
-			NewState += dy * HANGAR_SHIPS_ROW;
-			if (NewState / HANGAR_SHIPS_ROW > 0
-					&& NewState / HANGAR_SHIPS_ROW <= HANGAR_ROWS)
-				NewState -= HANGAR_SHIPS_ROW;
-			else if (NewState / HANGAR_SHIPS_ROW > HANGAR_ROWS + 1)
-				/* negative number - select last row */
-				NewState = pMS->CurState % HANGAR_SHIPS_ROW
-						+ HANGAR_SHIPS_ROW * (HANGAR_ROWS - 1);
-			else
-				// select SIS
-				NewState = MAKE_BYTE (pMS->CurState, 0xF);
+		if (crew_delta != 0)
+			DMS_FlashFlagShipCrewCount ();
+	}
+	else
+	{
+		// Add/Dismiss crew for an escort ship.
+		if (dy < 0)
+		{
+			// Add crew for an escort ship.
+			crew_delta = DMS_HireEscortShipCrew (StarShipPtr);
 		}
-		else if (dx && !HINIBBLE (NewState))
+		else
 		{
-			NewState = NewState % HANGAR_SHIPS_ROW;
-			if ((dx += NewState) < 0)
-				NewState = (BYTE)(pMS->CurState + (HANGAR_SHIPS_ROW - 1));
-			else if (dx > HANGAR_SHIPS_ROW - 1)
-				NewState = (BYTE)(pMS->CurState - (HANGAR_SHIPS_ROW - 1));
-			else
-				NewState = (BYTE)(pMS->CurState - NewState + dx);
+			// Dismiss crew from an escort ship.
+			crew_delta = DMS_DismissEscortShipCrew (StarShipPtr);
 		}
+		
+		if (crew_delta != 0)
+			DMS_FlashEscortShipCrewCount (StarShipPtr->index);
+	}
+
+	if (crew_delta == 0)
+		PlayMenuSound (MENU_SOUND_FAILURE);
+
+	if (hStarShip)
+	{
+		UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+		
+		// Clear out the bought ship index so that flash rects work
+		// correctly.
+		pMS->delta_item &= MODIFY_CREW_FLAG;
+	}
+
+	CrewTransaction (crew_delta);
+}
+
+// Helper function for DoModifyShips(), called when the player presses the
+// select button when the cursor is over an empty escort ship slot.
+// Try to add the currently selected ship as an escort ship.
+static void
+DMS_TryAddEscortShip (MENU_STATE *pMS)
+{
+	HFLEETINFO shipInfo = GetAvailableRaceFromIndex (
+			LOBYTE (pMS->delta_item));
+	COUNT Index = GetIndexFromStarShip (&GLOBAL (avail_race_q), shipInfo);
+
+	if (GLOBAL_SIS (ResUnits) >= (DWORD)ShipCost[Index]
+			&& CloneShipFragment (Index, &GLOBAL (built_ship_q), 1))
+	{
+		ShowCombatShip (pMS, pMS->CurState, NULL);
+				// Reset flash rectangle
+		DrawMenuStateStrings (PM_CREW, SHIPYARD_CREW);
+
+		DeltaSISGauges (UNDEFINED_DELTA, UNDEFINED_DELTA,
+				-((int)ShipCost[Index]));
+		DMS_SetMode (pMS, DMS_Mode_editCrew);
+	}
+	else
+	{
+		// not enough RUs to build, or cloning the ship failed.
+		PlayMenuSound (MENU_SOUND_FAILURE);
+	}
+}
+
+// Helper function for DoModifyShips(), called when the player is in the
+// mode to add a new escort ship to the fleet (after pressing select on an
+// empty slot).
+// LOBYTE (pMS->delta_item) is used to store the currently highlighted ship.
+// Returns FALSE if the flash rectangle needs to be updated.
+static void
+DMS_AddEscortShip (MENU_STATE *pMS, BOOLEAN special, BOOLEAN select,
+		BOOLEAN cancel, SBYTE dx, SBYTE dy)
+{
+	assert (pMS->delta_item & MODIFY_CREW_FLAG);
 
-		if (select || cancel
 #ifdef WANT_SHIP_SPINS
-				|| special
-#endif
-				|| NewState != pMS->CurState
-				|| ((pMS->delta_item & MODIFY_CREW_FLAG) && (dx || dy)))
+	if (special)
+	{
+		HSHIPFRAG hStarShip = GetEscortByStarShipIndex (pMS->delta_item);
+		if (DMS_SpinShip (pMS, hStarShip))
+			DMS_SetMode (pMS, DMS_Mode_addEscort);
+		return;
+	}
+#else
+	(void) special;  // Satisfying compiler.
+#endif  /* WANT_SHIP_SPINS */
+
+	if (cancel)
+	{
+		// Cancel selecting an escort ship.
+		pMS->delta_item &= ~MODIFY_CREW_FLAG;
+		SetFlashRect (NULL);
+		DrawMenuStateStrings (PM_CREW, SHIPYARD_CREW);
+		DMS_SetMode (pMS, DMS_Mode_navigate);
+	}
+	else if (select)
+	{
+		// Selected a ship to be inserted in an empty escort
+		// ship slot.
+		DMS_TryAddEscortShip (pMS);
+	}
+	else if (dx || dy)
+	{
+		// Motion key pressed while selecting a ship to be
+		// inserted in an empty escort ship slot.
+		COUNT availableCount = GetAvailableRaceCount ();
+		BYTE currentShip = LOBYTE (pMS->delta_item);
+		if (dx < 0 || dy < 0)
+		{
+			if (currentShip-- == 0)
+				currentShip = availableCount - 1;
+		}
+		else if (dx > 0 || dy > 0)
 		{
-			HSHIPFRAG hStarShip, hNextShip;
-			SHIP_FRAGMENT *StarShipPtr;
-			RECT r;
+			if (++currentShip == availableCount)
+				currentShip = 0;
+		}
+		
+		if (currentShip != LOBYTE (pMS->delta_item))
+		{
+			PreUpdateFlashRect ();
+			DrawRaceStrings (pMS, currentShip);
+			PostUpdateFlashRect ();
+			pMS->delta_item = currentShip | MODIFY_CREW_FLAG;
+		}
+	}
+}
 
-			for (hStarShip = GetHeadLink (&GLOBAL (built_ship_q));
-					hStarShip; hStarShip = hNextShip)
-			{
-				StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+// Helper function for DoModifyShips(), called when the player presses
+// 'select' or 'cancel' after selling all the crew.
+static void
+DMS_ScrapEscortShip (MENU_STATE *pMS, HSHIPFRAG hStarShip)
+{
+	SHIP_FRAGMENT *StarShipPtr =
+			LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+	BYTE slotNr;
+
+	SetFlashRect (NULL);
+	ShowCombatShip (pMS, pMS->CurState, StarShipPtr);
+
+	slotNr = StarShipPtr->index;
+	UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+
+	RemoveQueue (&GLOBAL (built_ship_q), hStarShip);
+	FreeShipFrag (&GLOBAL (built_ship_q), hStarShip);
+	// refresh SIS display
+	DeltaSISGauges (UNDEFINED_DELTA, UNDEFINED_DELTA, UNDEFINED_DELTA);
 
-				if (StarShipPtr->index == pMS->CurState)
-				{
-					UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
-					break;
-				}
+	SetContext (SpaceContext);
+	DMS_SetMode (pMS, DMS_Mode_navigate);
+}
 
-				hNextShip = _GetSuccLink (StarShipPtr);
-				UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
-			}
-			if ((pMS->delta_item & MODIFY_CREW_FLAG) && (hStarShip))
-			{
-				SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN,
-						MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
-			}
-			else
-			{
-				SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
-			}
+// Helper function for DoModifyShips(), called when the player presses
+// one of the motion keys when not in crew modification mode.
+static BYTE
+DMS_MoveCursor (BYTE curState, SBYTE dx, SBYTE dy)
+{
+	BYTE row = LONIBBLE(curState) / HANGAR_SHIPS_ROW;
+	BYTE col = LONIBBLE(curState) % HANGAR_SHIPS_ROW;
+	BOOLEAN isFlagShipSelected = (HINIBBLE(curState) != 0);
+
+	if (dy)
+	{
+		// Vertical motion.
 	
-			LockMutex (GraphicsLock);
+		// We consider the flagship an extra row (on the bottom),
+		// to ease operations.
+		if (isFlagShipSelected)
+			row = HANGAR_ROWS;
+
+		// Move up/down, wrapping around:
+		row = (row + (HANGAR_ROWS + 1) + dy) % (HANGAR_ROWS + 1);
+
+		// If we moved to the 'extra row', this means the flag ship.
+		isFlagShipSelected = (row == HANGAR_ROWS);
+		if (isFlagShipSelected)
+			row = 0;
+	}
+	else if (dx)
+	{
+		// Horizontal motion.
+		if (!isFlagShipSelected)
+		{
+			// Moving horizontally through the escort ship slots,
+			// wrapping around if necessary.
+			col = (col + HANGAR_SHIPS_ROW + dx) % HANGAR_SHIPS_ROW;
+		}
+	}
+		
+	return MAKE_BYTE(row * HANGAR_SHIPS_ROW + col,
+			isFlagShipSelected ? 0xf : 0);
+}
 
-#ifdef WANT_SHIP_SPINS
-			if (special)
-			{
-				HFLEETINFO hSpinShip = 0;
-				
-				if ((special && (((hStarShip == 0
-						   && HINIBBLE (pMS->CurState) == 0)
-						  && (pMS->delta_item & MODIFY_CREW_FLAG))
-						 || ((hStarShip != 0 &&
-						      HINIBBLE (pMS->CurState) == 0)
-						     && !(pMS->delta_item & MODIFY_CREW_FLAG))))
-				    && (hStarShip
-					|| (HINIBBLE (pMS->CurState) == 0
-					    && (hSpinShip = GetAvailableRaceFromIndex (
-							LOBYTE (pMS->delta_item))))))
-				{
-					CONTEXT OldContext;
-					RECT OldClipRect;
+// Helper function for DoModifyShips(), called every time DoModifyShip() is
+// called when we are in crew editing mode.
+static void
+DMS_EditCrewMode (MENU_STATE *pMS, HSHIPFRAG hStarShip,
+		BOOLEAN select, BOOLEAN cancel, SBYTE dy)
+{
+	if (select || cancel)
+	{
+		// Leave crew editing mode.
+		if (hStarShip != 0)
+		{
+			// Exiting crew editing mode for an escort ship.
+			SHIP_FRAGMENT *StarShipPtr = LockShipFrag (
+					&GLOBAL (built_ship_q), hStarShip);
+			COUNT crew_level = StarShipPtr->crew_level;
+			UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 
-					if (!hSpinShip)
-					{	/* Get fleet info from selected escort */
-						SHIP_FRAGMENT *FragPtr = LockShipFrag (
-								&GLOBAL (built_ship_q), hStarShip);
-						hSpinShip = GetStarShipFromIndex (
-								&GLOBAL (avail_race_q), FragPtr->race_id);
-						UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
-					}
-					
-					SetFlashRect (NULL);
+			if (crew_level == 0)
+			{
+				// Scrapping the escort ship before exiting crew edit
+				// mode.
+				DMS_ScrapEscortShip (pMS, hStarShip);
+			}
+		}
 
-					OldContext = SetContext (ScreenContext);
-					GetContextClipRect (&OldClipRect);
+		pMS->delta_item &= ~MODIFY_CREW_FLAG;
+		DMS_SetMode (pMS, DMS_Mode_navigate);
+	}
+	else if (dy)
+	{
+		// Hire or dismiss crew for the flagship or an escort
+		// ship.
+		DMS_ModifyCrew (pMS, hStarShip, dy);
+	}
+}
 
-					SpinStarShip (pMS, hSpinShip);
+// Helper function for DoModifyShips(), called every time DoModifyShip() is
+// called when we are in the mode where you can select a ship or empty slot.
+static void
+DMS_NavigateShipSlots (MENU_STATE *pMS, BOOLEAN special, BOOLEAN select,
+		BOOLEAN cancel, SBYTE dx, SBYTE dy)
+{
+	HSHIPFRAG hStarShip = GetEscortByStarShipIndex (pMS->CurState);
 
-					SetContextClipRect (&OldClipRect);
-					SetContext (OldContext);
+	if (dx || dy)
+	{
+		// Moving through the ship slots.
+		BYTE NewState = DMS_MoveCursor (pMS->CurState, dx, dy);
+		if (NewState != pMS->CurState)
+		{
+			pMS->CurState = NewState;
+			DMS_FlashActiveShip(pMS);
+		}
+	}
 
-					if (hStarShip)
-						goto ChangeFlashRect;
+#ifndef WANT_SHIP_SPINS
+	(void) special;  // Satisfying compiler.
+#else
+	if (special)
+	{
+		if (DMS_SpinShip (pMS, hStarShip))
+			DMS_SetMode (pMS, DMS_Mode_navigate);
+	}
+	else
+#endif  /* WANT_SHIP_SPINS */
+	if (select)
+	{
+		if (hStarShip == 0 && HINIBBLE (pMS->CurState) == 0)
+		{
+			// Select button was pressed over an empty escort
+			// ship slot. Switch to 'add escort ship' mode.
+			pMS->delta_item = MODIFY_CREW_FLAG;
+			DrawRaceStrings (pMS, 0);
+			DMS_SetMode (pMS, DMS_Mode_addEscort);
+		}
+		else
+		{
+			// Select button was pressed over an escort ship or
+			// the flagship. Entering crew editing mode
+			pMS->delta_item |= MODIFY_CREW_FLAG;
+			DMS_SetMode (pMS, DMS_Mode_editCrew);
+		}
+	}
+	else if (cancel)
+	{
+		// Leave escort ship editor.
+		pMS->InputFunc = DoShipyard;
+		pMS->CurState = SHIPYARD_CREW;
+		DrawMenuStateStrings (PM_CREW, pMS->CurState);
+		DMS_SetMode (pMS, DMS_Mode_exit);
+	}
+}
 
-					SetFlashRect (SFR_MENU_3DO);
-				}
-			}
-			else
-#endif
-			if (select || ((pMS->delta_item & MODIFY_CREW_FLAG)
-					&& (dx || dy || cancel)))
-			{
-				COUNT ShipCost[] =
-				{
-					RACE_SHIP_COST
-				};
+/* In this routine, the least significant byte of pMS->CurState is used
+ * to store the current selected ship index
+ * a special case for the row is hi-nibble == -1 (0xf), which specifies
+ * SIS as the selected ship
+ * some bitwise math is still done to scroll through ships, for it to work
+ * ships per row number must divide 0xf0 without remainder
+ */
+static BOOLEAN
+DoModifyShips (MENU_STATE *pMS)
+{
+	if (GLOBAL (CurrentActivity) & CHECK_ABORT)
+	{
+		pMS->InputFunc = DoShipyard;
+		return TRUE;
+	}
 
-				if (hStarShip == 0 && HINIBBLE (pMS->CurState) == 0)
-				{
-					COUNT Index;
+	if (!pMS->Initialized)
+	{
+		pMS->InputFunc = DoModifyShips;
+		pMS->Initialized = TRUE;
+		pMS->CurState = MAKE_BYTE (0, 0xF);
+		pMS->delta_item = 0;
 
-// SetFlashRect (NULL);
-					UnlockMutex (GraphicsLock);
-					if (!(pMS->delta_item & MODIFY_CREW_FLAG))
-					{
-						pMS->delta_item = MODIFY_CREW_FLAG;
-						DrawRaceStrings (pMS, 0);
-						return TRUE;
-					}
-					else if (cancel)
-					{
-						pMS->delta_item ^= MODIFY_CREW_FLAG;
-						LockMutex (GraphicsLock);
-						SetFlashRect (SFR_MENU_3DO);
-						UnlockMutex (GraphicsLock);
-						DrawMenuStateStrings (PM_CREW, SHIPYARD_CREW);
-						SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
-					}
-					else if (select)
-					{
-						Index = GetIndexFromStarShip (&GLOBAL (avail_race_q),
-								GetAvailableRaceFromIndex (
-								LOBYTE (pMS->delta_item)));
-
-						if (GLOBAL_SIS (ResUnits) >= (DWORD)ShipCost[Index]
-								&& CloneShipFragment (Index,
-								&GLOBAL (built_ship_q), 1))
-						{
-							ShowCombatShip (pMS, pMS->CurState, NULL);
-							//Reset flash rectangle
-							LockMutex (GraphicsLock);
-							SetFlashRect (SFR_MENU_3DO);
-							UnlockMutex (GraphicsLock);
-							DrawMenuStateStrings (PM_CREW, SHIPYARD_CREW);
-
-							LockMutex (GraphicsLock);
-							DeltaSISGauges (UNDEFINED_DELTA, UNDEFINED_DELTA,
-									-((int)ShipCost[Index]));
-							r.corner.x = pMS->flash_rect0.corner.x;
-							r.corner.y = pMS->flash_rect0.corner.y
-									+ pMS->flash_rect0.extent.height - 6;
-							r.extent.width = SHIP_WIN_WIDTH;
-							r.extent.height = 5;
-							SetContext (SpaceContext);
-							SetFlashRect (&r);
-							UnlockMutex (GraphicsLock);
-						}
-						else
-						{	// not enough RUs to build
-							PlayMenuSound (MENU_SOUND_FAILURE);
-						}
-						SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN,
-								MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
-							
-						return TRUE;
-					}
-					else
-					{
-						Index = GetAvailableRaceCount ();
-						NewState = LOBYTE (pMS->delta_item);
-						if (dx < 0 || dy < 0)
-						{
-							if (NewState-- == 0)
-								NewState = Index - 1;
-						}
-						else if (dx > 0 || dy > 0)
-						{
-							if (++NewState == Index)
-								NewState = 0;
-						}
-						
-						if (NewState != LOBYTE (pMS->delta_item))
-						{
-							DrawRaceStrings (pMS, NewState);
-							pMS->delta_item = NewState | MODIFY_CREW_FLAG;
-						}
-						
-						return TRUE;
-					}
-					LockMutex (GraphicsLock);
-					goto ChangeFlashRect;
-				}
-				else if (select || cancel)
-				{
-					if ((pMS->delta_item & MODIFY_CREW_FLAG)
-							&& hStarShip != 0)
-					{
-						StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q),
-								hStarShip);
-						if (StarShipPtr->crew_level == 0)
-						{
-							SetFlashRect (NULL);
-							UnlockMutex (GraphicsLock);
-							ShowCombatShip (pMS, pMS->CurState, StarShipPtr);
-							LockMutex (GraphicsLock);
-							UnlockShipFrag (&GLOBAL (built_ship_q),
-									hStarShip);
-							RemoveQueue (&GLOBAL (built_ship_q), hStarShip);
-							FreeShipFrag (&GLOBAL (built_ship_q), hStarShip);
-							// refresh SIS display
-							DeltaSISGauges (UNDEFINED_DELTA, UNDEFINED_DELTA,
-									UNDEFINED_DELTA);
-							r.corner.x = pMS->flash_rect0.corner.x;
-							r.corner.y = pMS->flash_rect0.corner.y;
-							r.extent.width = SHIP_WIN_WIDTH;
-							r.extent.height = SHIP_WIN_HEIGHT;
-							SetContext (SpaceContext);
-							SetFlashRect (&r);
-						}
-						else
-						{
-							UnlockShipFrag (&GLOBAL (built_ship_q),
-									hStarShip);
-						}
-					}
-					
-					if (!(pMS->delta_item ^= MODIFY_CREW_FLAG))
-					{
-						goto ChangeFlashRect;
-					}
-					else if (hStarShip == 0)
-					{
-						SetContext (StatusContext);
-						GetGaugeRect (&r, TRUE);
-						SetFlashRect (&r);
-						SetContext (SpaceContext);
-						SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN,
-								MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
-					}
-					else
-					{
-						r.corner.x = pMS->flash_rect0.corner.x;
-						r.corner.y = pMS->flash_rect0.corner.y
-								+ pMS->flash_rect0.extent.height - 6;
-						r.extent.width = SHIP_WIN_WIDTH;
-						r.extent.height = 5;
-						SetContext (SpaceContext);
-						SetFlashRect (&r);
-						SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN,
-								MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
-					}
-				}
-				else if (pMS->delta_item & MODIFY_CREW_FLAG)
-				{
-					SIZE crew_delta, crew_bought;
+		SetContext (SpaceContext);
+		DMS_SetMode (pMS, DMS_Mode_navigate);
+	}
+	else
+	{
+		BOOLEAN special = (PulsedInputState.menu[KEY_MENU_SPECIAL] != 0);
+		BOOLEAN select = (PulsedInputState.menu[KEY_MENU_SELECT] != 0);
+		BOOLEAN cancel = (PulsedInputState.menu[KEY_MENU_CANCEL] != 0);
+		SBYTE dx = 0;
+		SBYTE dy = 0;
 
-					if (hStarShip)
-						StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q),
-								hStarShip);
-					else
-						StarShipPtr = NULL;  // Keeping compiler quiet.
-
-					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN,
-							MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
-					crew_delta = 0;
-					if (dy < 0)
-					{
-						if (hStarShip == 0)
-						{
-							if (GetCPodCapacity (&r.corner) > GetCrewCount ()
-									&& GLOBAL_SIS (ResUnits) >=
-									(DWORD)GLOBAL (CrewCost))
-							{
-								DrawPoint (&r.corner);
-								DeltaSISGauges (1, 0, -GLOBAL (CrewCost));
-								crew_delta = 1;
-
-								SetContext (StatusContext);
-								GetGaugeRect (&r, TRUE);
-								SetFlashRect (&r);
-								SetContext (SpaceContext);
-							}
-							else
-							{	// at capacity or not enough RUs
-								PlayMenuSound (MENU_SOUND_FAILURE);
-							}
-						}
-						else
-						{
-							HFLEETINFO hTemplate;
-							FLEET_INFO *TemplatePtr;
-
-							hTemplate = GetStarShipFromIndex (
-									&GLOBAL (avail_race_q),
-									StarShipPtr->race_id);
-							TemplatePtr = LockFleetInfo (
-									&GLOBAL (avail_race_q), hTemplate);
-							if (GLOBAL_SIS (ResUnits) >=
-									(DWORD)GLOBAL (CrewCost)
-									&& StarShipPtr->crew_level <
-									StarShipPtr->max_crew &&
-									StarShipPtr->crew_level <
-									TemplatePtr->crew_level)
-							{
-								if (StarShipPtr->crew_level > 0)
-									DeltaSISGauges (0, 0, -GLOBAL (CrewCost));
-								else
-									DeltaSISGauges (0, 0, -(COUNT)ShipCost[
-											StarShipPtr->race_id]);
-								++StarShipPtr->crew_level;
-								crew_delta = 1;
-								ShowShipCrew (StarShipPtr, &pMS->flash_rect0);
-								r.corner.x = pMS->flash_rect0.corner.x;
-								r.corner.y = pMS->flash_rect0.corner.y
-										+ pMS->flash_rect0.extent.height - 6;
-								r.extent.width = SHIP_WIN_WIDTH;
-								r.extent.height = 5;
-								SetContext (SpaceContext);
-								SetFlashRect (&r);
-							}
-							else
-							{	// at capacity or not enough RUs
-								PlayMenuSound (MENU_SOUND_FAILURE);
-							}
-							UnlockFleetInfo (&GLOBAL (avail_race_q),
-									hTemplate);
-						}
-					}
-					else if (dy > 0)
-					{
-						crew_bought = (SIZE)MAKE_WORD (
-								GET_GAME_STATE (CREW_PURCHASED0),
-								GET_GAME_STATE (CREW_PURCHASED1));
-						if (hStarShip == 0)
-						{
-							if (GetCrewCount ())
-							{
-								DeltaSISGauges (-1, 0, GLOBAL (CrewCost)
-										- (crew_bought ==
-										CREW_EXPENSE_THRESHOLD ? 2 : 0));
-								crew_delta = -1;
-
-								GetCPodCapacity (&r.corner);
-								SetContextForeGroundColor (BLACK_COLOR);
-								DrawPoint (&r.corner);
-
-								SetContext (StatusContext);
-								GetGaugeRect (&r, TRUE);
-								SetFlashRect (&r);
-								SetContext (SpaceContext);
-							}
-							else
-							{	// no crew to dismiss
-								PlayMenuSound (MENU_SOUND_FAILURE);
-							}
-						}
-						else
-						{
-							if (StarShipPtr->crew_level > 0)
-							{
-								if (StarShipPtr->crew_level > 1)
-									DeltaSISGauges (0, 0, GLOBAL (CrewCost)
-											- (crew_bought ==
-											CREW_EXPENSE_THRESHOLD ? 2 : 0));
-								else
-									DeltaSISGauges (0, 0, (COUNT)ShipCost[
-											StarShipPtr->race_id]);
-								crew_delta = -1;
-								--StarShipPtr->crew_level;
-							}
-							else
-							{	// no crew to dismiss
-								PlayMenuSound (MENU_SOUND_FAILURE);
-							}
-							ShowShipCrew (StarShipPtr, &pMS->flash_rect0);
-							r.corner.x = pMS->flash_rect0.corner.x;
-							r.corner.y = pMS->flash_rect0.corner.y
-									+ pMS->flash_rect0.extent.height - 6;
-							r.extent.width = SHIP_WIN_WIDTH;
-							r.extent.height = 5;
-							SetContext (SpaceContext);
-							SetFlashRect (&r);
-						}
-					}
+		if (PulsedInputState.menu[KEY_MENU_RIGHT])
+			dx = 1;
+		if (PulsedInputState.menu[KEY_MENU_LEFT])
+			dx = -1;
+		if (PulsedInputState.menu[KEY_MENU_UP])
+			dy = -1;
+		if (PulsedInputState.menu[KEY_MENU_DOWN])
+			dy = 1;
 
-					if (hStarShip)
-					{
-						UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
-						
-						// clear out the bought ship index
-						// so that flash rects work correctly
-						pMS->delta_item &= MODIFY_CREW_FLAG;
-					}
-					CrewTransaction (crew_delta);
-				}
-			}
-			else if (cancel)
-			{
-				UnlockMutex (GraphicsLock);
 
-				pMS->InputFunc = DoShipyard;
-				pMS->CurState = SHIPYARD_CREW;
-				DrawMenuStateStrings (PM_CREW, pMS->CurState);
-				LockMutex (GraphicsLock);
-				SetFlashRect (SFR_MENU_3DO);
-				UnlockMutex (GraphicsLock);
+		if (!(pMS->delta_item & MODIFY_CREW_FLAG))
+		{
+			// Navigating through the ship slots.
+			DMS_NavigateShipSlots (pMS, special, select, cancel, dx, dy);
+		}
+		else
+		{
+			// Add an escort ship or edit the crew of a ship.
+			HSHIPFRAG hStarShip = GetEscortByStarShipIndex (pMS->CurState);
 
-				return TRUE;
+			if (hStarShip == 0 && HINIBBLE (pMS->CurState) == 0)
+			{
+				// Cursor is over an empty escort ship slot, while we're
+				// in 'add escort ship' mode.
+				DMS_AddEscortShip (pMS, special, select, cancel, dx, dy);
 			}
 			else
 			{
-				pMS->CurState = NewState;
-
-ChangeFlashRect:
-				if (HINIBBLE (pMS->CurState))
-				{
-					pMS->flash_rect0.corner.x =
-							pMS->flash_rect0.corner.y = 0;
-					pMS->flash_rect0.extent.width = SIS_SCREEN_WIDTH;
-					pMS->flash_rect0.extent.height = 61;
-				}
-				else
-				{
-					pMS->flash_rect0.corner.x = hangar_x_coords[
-							pMS->CurState % HANGAR_SHIPS_ROW];
-					pMS->flash_rect0.corner.y = HANGAR_Y + (HANGAR_DY *
-							(pMS->CurState / HANGAR_SHIPS_ROW));
-					pMS->flash_rect0.extent.width = SHIP_WIN_WIDTH;
-					pMS->flash_rect0.extent.height = SHIP_WIN_HEIGHT;
-				}
-				SetFlashRect (&pMS->flash_rect0);
+				// Crew editing mode.
+				DMS_EditCrewMode (pMS, hStarShip, select, cancel, dy);
 			}
-			UnlockMutex (GraphicsLock);
 		}
+
 	}
 
 	SleepThread (ONE_SECOND / 30);
@@ -1184,7 +1410,6 @@ DoShipyard (MENU_STATE *pMS)
 
 			pMS->hMusic = LoadMusic (SHIPYARD_MUSIC);
 
-			LockMutex (GraphicsLock);
 			SetTransitionSource (NULL);
 			BatchGraphics ();
 			DrawSISFrame ();
@@ -1192,12 +1417,10 @@ DoShipyard (MENU_STATE *pMS)
 			DrawSISTitle (GAME_STRING (STARBASE_STRING_BASE));
 			SetContext (SpaceContext);
 			DrawBluePrint (pMS);
-			UnlockMutex (GraphicsLock);
 
 			pMS->CurState = SHIPYARD_CREW;
 			DrawMenuStateStrings (PM_CREW, pMS->CurState);
 
-			LockMutex (GraphicsLock);
 			SetContext (SpaceContext);
 			s.origin.x = 0;
 			s.origin.y = 0;
@@ -1222,7 +1445,6 @@ DoShipyard (MENU_STATE *pMS)
 
 			ScreenTransition (3, NULL);
 			UnbatchGraphics ();
-			UnlockMutex (GraphicsLock);
 
 			PlayMusic (pMS->hMusic, TRUE, 1);
 
@@ -1230,9 +1452,7 @@ DoShipyard (MENU_STATE *pMS)
 
 			SetInputCallback (on_input_frame);
 
-			LockMutex (GraphicsLock);
 			SetFlashRect (SFR_MENU_3DO);
-			UnlockMutex (GraphicsLock);
 		}
 
 		pMS->Initialized = TRUE;
@@ -1242,12 +1462,10 @@ DoShipyard (MENU_STATE *pMS)
 ExitShipyard:
 		SetInputCallback (NULL);
 
-		LockMutex (GraphicsLock);
 		DestroyDrawable (ReleaseDrawable (pMS->ModuleFrame));
 		pMS->ModuleFrame = 0;
 		DestroyColorMap (ReleaseColorMap (pMS->CurString));
 		pMS->CurString = 0;
-		UnlockMutex (GraphicsLock);
 
 		return FALSE;
 	}
@@ -1264,9 +1482,7 @@ ExitShipyard:
 			if (!GameOptions ())
 				goto ExitShipyard;
 			DrawMenuStateStrings (PM_CREW, pMS->CurState);
-			LockMutex (GraphicsLock);
 			SetFlashRect (SFR_MENU_3DO);
-			UnlockMutex (GraphicsLock);
 		}
 	}
 	else
diff -ruNp src.orig/uqm/sis.c src/uqm/sis.c
--- src.orig/uqm/sis.c	2017-11-21 19:39:42 -0600
+++ src/uqm/sis.c	2017-11-21 19:40:00 -0600
@@ -20,8 +20,7 @@
 
 #include "colors.h"
 #include "races.h"
-// XXX: including encount.h for stuff that does not belong there
-#include "encount.h"
+#include "starmap.h"
 #include "units.h"
 #include "menustat.h"
 		// for DrawMenuStateStrings()
@@ -32,8 +31,10 @@
 #include "element.h"
 #include "setup.h"
 #include "state.h"
+#include "flash.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/tasklib.h"
+#include "libs/alarm.h"
 #include "libs/log.h"
 
 #include <stdio.h>
@@ -99,9 +100,7 @@ ClearSISRect (BYTE ClearFlags)
 
 	if (ClearFlags & CLEAR_SIS_RADAR)
 	{
-		UnlockMutex (GraphicsLock);
 		DrawMenuStateStrings ((BYTE)~0, 1);
-		LockMutex (GraphicsLock);
 #ifdef NEVER
 		r.corner.x = RADAR_X - 1;
 		r.corner.y = RADAR_Y - 1;
@@ -215,7 +214,7 @@ DrawSISMessageEx (const UNICODE *pStr, S
 				pStr = buf;
 				break;
 			case IN_HYPERSPACE:
-				if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
+				if (inHyperSpace ())
 				{
 					pStr = GAME_STRING (NAVIGATION_STRING_BASE);
 							// "HyperSpace"
@@ -950,7 +949,6 @@ DrawModules (void)
 	}
 }
 
-// Pre: GraphicsLock is unlocked
 static void
 DrawSupportShips (void)
 {
@@ -974,9 +972,7 @@ DrawSupportShips (void)
 
 		s.origin = *pship_pos;
 		s.frame = StarShipPtr->icons;
-		LockMutex (GraphicsLock);
 		DrawStamp (&s);
-		UnlockMutex (GraphicsLock);
 
 		UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 	}
@@ -1141,9 +1137,7 @@ DeltaSISGauges (SIZE crew_delta, SIZE fu
 		DrawTurningJets ();
 		DrawModules ();
 
-		UnlockMutex (GraphicsLock);
 		DrawSupportShips ();
-		LockMutex (GraphicsLock);
 	}
 
 	SetContextFont (TinyFont);
@@ -1590,248 +1584,158 @@ DrawAutoPilotMessage (BOOLEAN Reset)
 }
 
 
-Task flash_task = 0;
-RECT flash_rect;
-static FRAME flash_screen_frame = 0;
-		// The original contents of the flash rectangle.
-static int flash_changed;
-Mutex flash_mutex = 0;
-
-static int
-flash_rect_func (void *data)
-{
-#define NORMAL_STRENGTH 4
-#define NORMAL_F_STRENGTH 0
-#define CACHE_SIZE 10
-	DWORD TimeIn;
-	const DWORD WaitTime = ONE_SECOND / 16;
-	SIZE strength;
-	RECT cached_rect = {{0, 0}, {0, 0}};
-	FRAME cached_screen_frame = 0;
-	Task task = (Task)data;
-	bool cached[CACHE_SIZE];
-	STAMP cached_stamp[CACHE_SIZE];
-	int i;
-
-	// Init cache
-	for (i = 0; i < CACHE_SIZE; i++)
-	{
-		cached[i] = false;
-		cached_stamp[i].frame = 0;
-	}
-
-	strength = NORMAL_STRENGTH;
-	TimeIn = GetTimeCounter ();
-	while (!Task_ReadState(task, TASK_EXIT))
-	{
-		CONTEXT OldContext;
-
-		LockMutex (flash_mutex);
-		if (flash_changed)
-		{
-			cached_rect = flash_rect;
-			if (cached_screen_frame)
-				DestroyDrawable (ReleaseDrawable (cached_screen_frame));
-			flash_changed = 0;
-			//  Wait for the  flash_screen_frame to get initialized
-			FlushGraphics ();
-			cached_screen_frame = CaptureDrawable (
-					CloneFrame (flash_screen_frame));
-			UnlockMutex (flash_mutex);
+static FlashContext *flashContext = NULL;
+static RECT flash_rect;
+static Alarm *flashAlarm = NULL;
+static BOOLEAN flashPaused = FALSE;
 
-			// Clear the cache.
-			for (i = 0; i < CACHE_SIZE; i++)
-			{
-				cached[i] = false;
-				if (cached_stamp[i].frame)
-					DestroyDrawable (ReleaseDrawable (cached_stamp[i].frame));
-				cached_stamp[i].frame = 0;
-			}
-		}
-		else
-			UnlockMutex (flash_mutex);
-		
-		if (cached_rect.extent.width)
-		{
-			STAMP *pStamp;
+static void scheduleFlashAlarm (void);
 
-#define MIN_STRENGTH 4
-#define MAX_STRENGTH 6
-			strength += 2;
-			if (strength > MAX_STRENGTH)
-				strength = MIN_STRENGTH;
-			if (cached[strength - MIN_STRENGTH])
-				pStamp = &cached_stamp[strength - MIN_STRENGTH];
-			else
-			{
-				pStamp = &cached_stamp[strength - MIN_STRENGTH];
-				cached[strength - MIN_STRENGTH] = true;
-				pStamp->frame = CaptureDrawable (
-						CloneFrame (cached_screen_frame));
-				pStamp->origin.x = 0;
-				pStamp->origin.y = 0;
-
-				if (strength != 4)
-				{	// brighten the frame with an additive
-					DrawMode oldMode;
-					STAMP s;
-					int factor;
-
-					s.origin.x = 0;
-					s.origin.y = 0;
-					s.frame = cached_screen_frame;
-
-					factor = (strength - MIN_STRENGTH) * DRAW_FACTOR_1 / 4;
-
-					LockMutex (GraphicsLock);
-					OldContext = SetContext (OffScreenContext);
-					SetContextFGFrame (pStamp->frame);
-					SetContextClipRect (NULL);
-					oldMode	= SetContextDrawMode (MAKE_DRAW_MODE (
-							DRAW_ADDITIVE, factor));
-					DrawStamp (&s);
-					SetContextDrawMode (oldMode);
-					SetContext (OldContext);
-					UnlockMutex (GraphicsLock);
-				}
-			}
-
-			LockMutex (GraphicsLock);
-			OldContext = SetContext (ScreenContext);
-			SetContextClipRect (&cached_rect);
-			// flash changed_can't be modified while GraphicSem is held
-			if (!flash_changed)
-				DrawStamp (pStamp);
-			// XXX: Shouldn't we save and restore the original cliprect?
-			SetContextClipRect (NULL);
-			SetContext (OldContext);
-			UnlockMutex (GraphicsLock);
-		}
-		FlushGraphics ();
-		SleepThreadUntil (TimeIn + WaitTime);
-		TimeIn = GetTimeCounter ();
-	}
-
-	// Clear cache
-	{
-		if (cached_screen_frame)
-			DestroyDrawable (ReleaseDrawable (cached_screen_frame));
+static void
+updateFlashRect (void *arg)
+{
+	if (flashContext == NULL)
+		return;
 
-		for (i = 0; i < CACHE_SIZE; i++)
-		{
-			if(cached_stamp[i].frame)
-				DestroyDrawable (ReleaseDrawable (cached_stamp[i].frame));
-		}
-	}
-	LockMutex (flash_mutex);
-	flash_task = 0;
-	UnlockMutex (flash_mutex);
+	Flash_process (flashContext);
+	scheduleFlashAlarm ();
+	(void) arg;
+}
 
-	FinishTask (task);
-	return 0;
+static void
+scheduleFlashAlarm (void)
+{
+	TimeCount nextTime = Flash_nextTime (flashContext);
+	DWORD nextTimeMs = (nextTime / ONE_SECOND) * 1000 +
+			((nextTime % ONE_SECOND) * 1000 / ONE_SECOND);
+			// Overflow-safe conversion.
+	flashAlarm = Alarm_addAbsoluteMs (nextTimeMs, updateFlashRect, NULL);
 }
 
 void
-SetFlashRect (RECT *pRect)
+SetFlashRect (const RECT *pRect)
 {
 	RECT clip_r = {{0, 0}, {0, 0}};
-	RECT temp_r, flash_rect1, old_r;
-	CONTEXT OldContext;
-	int create_flash = 0;
-
-	if (!flash_mutex)
-		flash_mutex = CreateMutex ("FlashRect Lock",
-				SYNC_CLASS_TOPLEVEL | SYNC_CLASS_VIDEO);
-
-	old_r = flash_rect;
-	flash_rect1 = flash_rect;
-		
+	RECT temp_r;
+	
 	if (pRect != SFR_MENU_3DO && pRect != SFR_MENU_ANY)
 	{
+		// The caller specified their own flash area, or NULL (stop flashing).
 		GetContextClipRect (&clip_r);
-		OldContext = SetContext (ScreenContext);
 	}
 	else
 	{
-		//Don't flash when using the PC menu
  		if (optWhichMenu == OPT_PC && pRect != SFR_MENU_ANY)
  		{
- 			OldContext = SetContext (ScreenContext);
+			// The player wants PC menus and this flash is not used
+			// for a PC menu.
+			// Don't flash.
  			pRect = 0;
  		}
  		else
  		{
- 			OldContext = SetContext (StatusContext);
+			// The player wants 3DO menus, or the flash is used in both
+			// 3DO and PC mode.
+			CONTEXT OldContext = SetContext (StatusContext);
  			GetContextClipRect (&clip_r);
  			pRect = &temp_r;
  			temp_r.corner.x = RADAR_X - clip_r.corner.x;
  			temp_r.corner.y = RADAR_Y - clip_r.corner.y;
  			temp_r.extent.width = RADAR_WIDTH;
  			temp_r.extent.height = RADAR_HEIGHT;
- 			SetContext (ScreenContext);
+ 			SetContext (OldContext);
 		}
 	}
 
-	if (pRect == 0 || pRect->extent.width == 0)
+	if (pRect != 0 && pRect->extent.width != 0)
 	{
-		// End the flashing.
-		flash_rect1.extent.width = 0;
-		if (flash_task)
+		// Flash rectangle is not empty, start or continue flashing.
+		flash_rect = *pRect;
+		flash_rect.corner.x += clip_r.corner.x;
+		flash_rect.corner.y += clip_r.corner.y;
+
+		if (flashContext == NULL)
 		{
-			UnlockMutex (GraphicsLock);
-			ConcludeTask (flash_task);
-			LockMutex (GraphicsLock);
+			// Create a new flash context.
+			flashContext = Flash_createHighlight (ScreenContext, &flash_rect);
+			Flash_setMergeFactors(flashContext, 3, 2, 2);
+			Flash_setSpeed (flashContext, 0, ONE_SECOND / 16, 0, ONE_SECOND / 16);
+			Flash_setFrameTime (flashContext, ONE_SECOND / 16);
+			Flash_start (flashContext);
+			scheduleFlashAlarm ();
+		}
+		else
+		{
+			// Reuse an existing flash context
+			Flash_setRect (flashContext, &flash_rect);
 		}
 	}
 	else
 	{
-		flash_rect1 = *pRect;
-		flash_rect1.corner.x += clip_r.corner.x;
-		flash_rect1.corner.y += clip_r.corner.y;
-		create_flash = 1;
+		// Flash rectangle is empty. Stop flashing.
+		if (flashContext != NULL)
+		{
+			Alarm_remove(flashAlarm);
+			flashAlarm = 0;
+			
+			Flash_terminate (flashContext);
+			flashContext = NULL;
+		}
 	}
-	
-	LockMutex (flash_mutex);
-	flash_rect = flash_rect1;
+}
 
-	if (old_r.extent.width && !rectsEqual (old_r, flash_rect))
+COUNT updateFlashRectRecursion = 0;
+// XXX This is necessary at least because DMS_AddEscortShip() calls
+// DrawRaceStrings() in an UpdateFlashRect block, which calls
+// ClearSISRect(), which calls DrawMenuStateStrings(), which starts its own
+// UpdateFlashRect block. This should probably be cleaned up.
+
+void
+PreUpdateFlashRect (void)
+{
+	if (flashAlarm)
 	{
-		// We had a flash rectangle, and now a different one is set.
-		if (flash_screen_frame)
-		{
-			// The screen contents may have changed; we grab a new copy.
-			STAMP old_s;
-			old_s.origin.x = old_r.corner.x;
-			old_s.origin.y = old_r.corner.y;
-			old_s.frame = flash_screen_frame;
-			DrawStamp (&old_s);
-			DestroyDrawable (ReleaseDrawable (flash_screen_frame));
-			flash_screen_frame = 0;
-		}
-		else
-			log_add (log_Debug, "Couldn't locate flash_screen_rect");
+		updateFlashRectRecursion++;
+		if (updateFlashRectRecursion > 1)
+			return;
+		Flash_preUpdate (flashContext);
 	}
-	
-	if (flash_rect.extent.width)
+}
+
+void
+PostUpdateFlashRect (void)
+{
+	if (flashAlarm)
 	{
-		// A new flash rectangle is set.
-		// Copy the original contents of the rectangle from the screen.
-		if (flash_screen_frame)
-			DestroyDrawable (ReleaseDrawable (flash_screen_frame));
-		flash_screen_frame =
-				CaptureDrawable (LoadDisplayPixmap (&flash_rect, (FRAME)0));
-	}
-	flash_changed = 1;
-	UnlockMutex (flash_mutex);
-	// we create the thread after the LoadDisplayPixmap()
-	// so there is no race between the FlushGraphics in flash_task
-	// and the Enqueue in LoadDisplayPixmap()
-	if (create_flash && flash_task == 0)
+		updateFlashRectRecursion--;
+		if (updateFlashRectRecursion > 0)
+			return;
+
+		Flash_postUpdate (flashContext);
+	}
+}
+
+// Stop flashing if flashing is active.
+void
+PauseFlash (void)
+{
+	if (flashContext != NULL)
 	{
-		flash_task = AssignTask (flash_rect_func, 2048,
-				"flash rectangle");
+		Alarm_remove(flashAlarm);
+		flashAlarm = 0;
+		flashPaused = TRUE;
 	}
+}
 
-	SetContext (OldContext);
+// Continue flashing after PauseFlash (), if flashing was active.
+void
+ContinueFlash (void)
+{
+	if (flashPaused)
+	{
+		scheduleFlashAlarm ();
+		flashPaused = FALSE;
+	}
 }
 
+
diff -ruNp src.orig/uqm/sis.h src/uqm/sis.h
--- src.orig/uqm/sis.h	2017-11-21 19:39:42 -0600
+++ src/uqm/sis.h	2017-11-21 19:40:00 -0600
@@ -22,6 +22,10 @@
 #include "planets/elemdata.h"
 		// for NUM_ELEMENT_CATEGORIES
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #define CLEAR_SIS_RADAR (1 << 2)
 #define DRAW_SIS_DISPLAY (1 << 3)
 
@@ -72,7 +76,7 @@ enum
 	CANNON_WEAPON,
 	TRACKING_SYSTEM,
 	ANTIMISSILE_DEFENSE,
-	
+
 	NUM_PURCHASE_MODULES,
 
 	BOMB_MODULE_0 = NUM_PURCHASE_MODULES,
@@ -150,26 +154,6 @@ typedef struct
 	UNICODE PlanetName[SIS_NAME_SIZE];
 } SIS_STATE;
 
-// XXX: Theoretically, a player can have 17 devices on board without
-//   cheating. We only provide
-//   room for 16 below, which is not really a problem since this
-//   is only used for displaying savegame summaries. There is also
-//   room for only 16 devices on screen.
-#define MAX_EXCLUSIVE_DEVICES 16
-
-typedef struct
-{
-	SIS_STATE SS;
-	BYTE Activity;
-	BYTE Flags;
-	BYTE day_index, month_index;
-	COUNT year_index;
-	BYTE MCreditLo, MCreditHi;
-	BYTE NumShips, NumDevices;
-	BYTE ShipList[MAX_BUILT_SHIPS];
-	BYTE DeviceList[MAX_EXCLUSIVE_DEVICES];
-} SUMMARY_DESC;
-
 #define OVERRIDE_LANDER_FLAGS (1 << 7)
 #define AFTER_BOMB_INSTALLED (1 << 7)
 
@@ -177,7 +161,12 @@ extern void RepairSISBorder (void);
 extern void InitSISContexts (void);
 extern void DrawSISFrame (void);
 extern void ClearSISRect (BYTE ClearFlags);
-extern void SetFlashRect (RECT *pRect);
+extern void SetFlashRect (const RECT *pRect);
+extern void PreUpdateFlashRect (void);
+extern void PostUpdateFlashRect (void);
+extern void PauseFlash (void);
+extern void ContinueFlash (void);
+
 #define SFR_MENU_3DO ((RECT*)~0L)
 #define SFR_MENU_ANY ((RECT*)~1L)
 extern void DrawHyperCoords (POINT puniverse);
@@ -244,5 +233,9 @@ extern COUNT CountSISPieces (BYTE piece_
 extern void DrawFlagshipName (BOOLEAN InStatusArea);
 extern void DrawCaptainsName (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* SIS_H_INCL__ */
 
diff -ruNp src.orig/uqm/sounds.h src/uqm/sounds.h
--- src.orig/uqm/sounds.h	2017-11-21 19:39:42 -0600
+++ src/uqm/sounds.h	2017-11-21 19:40:00 -0600
@@ -23,6 +23,10 @@
 #include "libs/compiler.h"
 #include "libs/sndlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef enum
 {
 	GRAB_CREW = 0,
@@ -74,6 +78,10 @@ extern void UpdateSoundPositions (void);
 extern void FlushSounds (void);
 extern void RemoveSoundsForObject (ELEMENT *PosObj);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _SOUNDS_H */
 
 
diff -ruNp src.orig/uqm/starbase.c src/uqm/starbase.c
--- src.orig/uqm/starbase.c	2017-11-21 19:39:42 -0600
+++ src/uqm/starbase.c	2017-11-21 19:40:00 -0600
@@ -19,11 +19,10 @@
 #include "build.h"
 #include "colors.h"
 #include "controls.h"
-// XXX: for CurStarDescPtr
-#include "encount.h"
+#include "starmap.h"
 #include "comm.h"
 #include "gamestr.h"
-#include "load.h"
+#include "save.h"
 #include "starbase.h"
 #include "sis.h"
 #include "resinst.h"
@@ -308,7 +307,6 @@ DoStarBase (MENU_STATE *pMS)
 		LastActivity &= ~CHECK_LOAD;
 		pMS->InputFunc = DoStarBase;
 
-		LockMutex (GraphicsLock);
 		SetFlashRect (NULL);
 
 		if (pMS->hMusic)
@@ -319,12 +317,10 @@ DoStarBase (MENU_STATE *pMS)
 		}
 
 		pMS->Initialized = TRUE;
-		UnlockMutex (GraphicsLock);
 
 		pMS->CurFrame = CaptureDrawable (LoadGraphic (STARBASE_ANIM));
 		pMS->hMusic = LoadMusic (STARBASE_MUSIC);
 
-		LockMutex (GraphicsLock);
 		SetContext (ScreenContext);
 		SetTransitionSource (NULL);
 		BatchGraphics ();
@@ -335,7 +331,6 @@ DoStarBase (MENU_STATE *pMS)
 		ScreenTransition (3, NULL);
 		PlayMusic (pMS->hMusic, TRUE, 1);
 		UnbatchGraphics ();
-		UnlockMutex (GraphicsLock);
 	}
 	else if (PulsedInputState.menu[KEY_MENU_SELECT])
 	{
@@ -405,7 +400,6 @@ ExitStarBase:
 				NewState = TALK_COMMANDER;
 		}
 
-		LockMutex (GraphicsLock);
 		BatchGraphics ();
 		SetContext (ScreenContext);
 
@@ -418,7 +412,6 @@ ExitStarBase:
 		rotateStarbase (pMS, NULL);
 
 		UnbatchGraphics ();
-		UnlockMutex (GraphicsLock);
 
 		SleepThread (ONE_SECOND / 30);
 	}
@@ -431,9 +424,7 @@ DoTimePassage (void)
 {
 #define LOST_DAYS 14
 	SleepThreadUntil (FadeScreen (FadeAllToBlack, ONE_SECOND * 2));
-	LockMutex (GraphicsLock);
 	MoveGameClockDays (LOST_DAYS);
-	UnlockMutex (GraphicsLock);
 }
 
 void
@@ -542,12 +533,10 @@ InstallBombAtEarth (void)
 {
 	DoTimePassage ();
 
-	LockMutex (GraphicsLock);
 	SetContext (ScreenContext);
 	SetTransitionSource (NULL);
 	SetContextBackGroundColor (BLACK_COLOR);
 	ClearDrawable ();
-	UnlockMutex (GraphicsLock);
 	
 	SleepThreadUntil (FadeScreen (FadeAllToColor, 0));
 	
diff -ruNp src.orig/uqm/starbase.h src/uqm/starbase.h
--- src.orig/uqm/starbase.h	2017-11-21 19:39:42 -0600
+++ src/uqm/starbase.h	2017-11-21 19:40:00 -0600
@@ -21,6 +21,10 @@
 
 #include "menustat.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 enum
 {
 	TALK_COMMANDER = 0,
@@ -44,5 +48,9 @@ extern COUNT WrapText (const UNICODE *pS
 		field_width);
 		// XXX: Doesn't really belong in this file.
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _STARBASE_H */
 
diff -ruNp src.orig/uqm/starcon.c src/uqm/starcon.c
--- src.orig/uqm/starcon.c	2017-11-21 19:39:42 -0600
+++ src/uqm/starcon.c	2017-11-21 19:40:00 -0600
@@ -24,10 +24,10 @@
 #include "gameev.h"
 #include "types.h"
 #include "globdata.h"
-#include "load.h"
 #include "resinst.h"
 #include "restart.h"
 #include "starbase.h"
+#include "save.h"
 #include "setup.h"
 #include "master.h"
 #include "controls.h"
@@ -39,17 +39,23 @@
 #include "planets/planets.h"
 		// for ExploreSolarSys()
 #include "uqmdebug.h"
+#include "uqm/lua/luastate.h"
 #include "libs/tasklib.h"
 #include "libs/log.h"
 #include "libs/gfxlib.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/graphics/tfb_draw.h"
 #include "libs/misc.h"
+#include "libs/scriptlib.h"
 
 #include "uqmversion.h"
 #include "options.h"
 
 volatile int MainExited = FALSE;
+#ifdef DEBUG_SLEEP
+uint32 mainThreadId;
+extern uint32 SDL_ThreadID(void);
+#endif
 
 // Open or close the periodically occuring QuasiSpace portal.
 // It changes the appearant portal size when necessary.
@@ -73,7 +79,6 @@ checkArilouGate (void)
 }
 
 // Battle frame callback function.
-// Called with GraphicsLock held
 static void
 on_battle_frame (void)
 {
@@ -101,6 +106,7 @@ BackgroundInitKernel (DWORD TimeOut)
 	}
 }
 
+// Executes on the main() thread
 void
 SignalStopMainThread (void)
 {
@@ -109,6 +115,7 @@ SignalStopMainThread (void)
 	TaskSwitch ();
 }
 
+// Executes on the main() thread
 void
 ProcessUtilityKeys (void)
 {
@@ -128,11 +135,17 @@ ProcessUtilityKeys (void)
 	}
 
 #if defined(DEBUG) || defined(USE_DEBUG_KEY)
-	if (ImmediateInputState.menu[KEY_DEBUG])
-	{
-		// clear ImmediateInputState so we don't repeat this next frame
-		FlushInput ();
-		debugKeyPressed ();
+	{	// Only call the debug func on the rising edge of
+		// ImmediateInputState[KEY_DEBUG] so it does not execute repeatedly.
+		// This duplicates the PulsedInputState somewhat, but we cannot
+		// use PulsedInputState here because it is meant for another thread.
+		static int debugKeyState;
+
+		if (ImmediateInputState.menu[KEY_DEBUG] && debugKeyState == 0)
+		{
+			debugKeyPressed ();
+		}
+		debugKeyState = ImmediateInputState.menu[KEY_DEBUG];
 	}
 #endif  /* DEBUG */
 }
@@ -143,6 +156,10 @@ extern int snddriver, soundflags;
 int
 Starcon2Main (void *threadArg)
 {
+#ifdef DEBUG_SLEEP
+	mainThreadId = SDL_ThreadID();
+#endif
+
 #if CREATE_JOURNAL
 {
 int ac = argc;
@@ -188,6 +205,7 @@ while (--ac > 0)
 	log_add (log_Info, "We've loaded the Kernel");
 
 	GLOBAL (CurrentActivity) = 0;
+	luaUqm_initState ();
 	// show splash and init the kernel in the meantime
 	SplashScreen (BackgroundInitKernel);
 
@@ -199,8 +217,11 @@ while (--ac > 0)
 			log_add (log_Fatal, "Could not set player input.");
 			explode ();  // Does not return;
 		}
+
+		luaUqm_reinitState ();
 		InitGameStructures ();
 		InitGameClock ();
+		initEventSystem ();
 		AddInitialGameEvents();
 
 		do
@@ -270,9 +291,7 @@ while (--ac > 0)
 				Battle (&on_battle_frame);
 			}
 
-			LockMutex (GraphicsLock);
 			SetFlashRect (NULL);
-			UnlockMutex (GraphicsLock);
 
 			LastActivity = GLOBAL (CurrentActivity);
 
@@ -291,11 +310,13 @@ while (--ac > 0)
 		} while (!(GLOBAL (CurrentActivity) & CHECK_ABORT));
 
 		StopSound ();
+		uninitEventSystem ();
 		UninitGameClock ();
 		UninitGameStructures ();
 		ClearPlayerInputAll ();
 	}
 //	CloseJournal ();
+	luaUqm_uninitState ();
 
 	UninitGameKernel ();
 	FreeMasterShipList ();
diff -ruNp src.orig/uqm/starcon.h src/uqm/starcon.h
--- src.orig/uqm/starcon.h	2017-11-21 19:39:42 -0600
+++ src/uqm/starcon.h	2017-11-21 19:40:00 -0600
@@ -17,6 +17,10 @@
 #ifndef _STARCON_H
 #define _STARCON_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern volatile int MainExited;
 extern void SignalStopMainThread (void);
 extern void ProcessUtilityKeys (void);
@@ -24,5 +28,9 @@ extern void ProcessUtilityKeys (void);
 extern int Starcon2Main (void *threadArg);
 extern void FreeGameData (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _STARCON_H */
 
diff -ruNp src.orig/uqm/starmap.c src/uqm/starmap.c
--- src.orig/uqm/starmap.c	2017-11-21 19:39:43 -0600
+++ src/uqm/starmap.c	2017-11-21 19:40:00 -0600
@@ -16,10 +16,9 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-#include "encount.h"
+#include "starmap.h"
 #include "gamestr.h"
 #include "globdata.h"
-#include "libs/compiler.h"
 #include "libs/gfxlib.h"
 
 
diff -ruNp src.orig/uqm/starmap.h src/uqm/starmap.h
--- src.orig/uqm/starmap.h	1969-12-31 18:00:00 -0600
+++ src/uqm/starmap.h	2017-11-21 19:40:00 -0600
@@ -0,0 +1,42 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef STARMAP_H_INCL_
+#define STARMAP_H_INCL_
+
+#include "libs/compiler.h"
+#include "planets/planets.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+extern STAR_DESC *CurStarDescPtr;
+extern STAR_DESC *star_array;
+
+#define NUM_SOLAR_SYSTEMS 502
+
+extern STAR_DESC* FindStar (STAR_DESC *pLastStar, POINT *puniverse,
+		SIZE xbounds, SIZE ybounds);
+
+extern void GetClusterName (const STAR_DESC *pSD, UNICODE buf[]);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif  /* STARMAP_H_INCL_ */
+
diff -ruNp src.orig/uqm/state.c src/uqm/state.c
--- src.orig/uqm/state.c	2017-11-21 19:39:43 -0600
+++ src/uqm/state.c	2017-11-21 19:40:00 -0600
@@ -18,12 +18,13 @@
 
 #include "state.h"
 
-#include "encount.h"
+#include "starmap.h"
 #include "libs/memlib.h"
 #include "libs/log.h"
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
+#include <memory.h>
 
 // in-memory file i/o
 struct GAME_STATE_FILE
@@ -123,6 +124,8 @@ DeleteStateFile (int stateFile)
 
 	fp->used = 0;
 	fp->ptr = 0;
+	HFree (fp->data);
+	fp->data = 0;
 }
 
 DWORD
@@ -238,7 +241,7 @@ UninitPlanetInfo (void)
 void
 GetPlanetInfo (void)
 {
-	void *fp;
+	GAME_STATE_FILE *fp;
 
 	pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[BIOLOGICAL_SCAN] = 0;
 	pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[MINERAL_SCAN] = 0;
@@ -286,7 +289,7 @@ GetPlanetInfo (void)
 void
 PutPlanetInfo (void)
 {
-	void *fp;
+	GAME_STATE_FILE *fp;
 
 	fp = OpenStateFile (STARINFO_FILE, "r+b");
 	if (fp)
diff -ruNp src.orig/uqm/state.h src/uqm/state.h
--- src.orig/uqm/state.h	2017-11-21 19:39:43 -0600
+++ src/uqm/state.h	2017-11-21 19:40:00 -0600
@@ -23,6 +23,10 @@
 #include "libs/compiler.h"
 #include <assert.h>
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern void InitPlanetInfo (void);
 extern void UninitPlanetInfo (void);
 extern void GetPlanetInfo (void);
@@ -75,7 +79,7 @@ int WriteStateFile (const void *lpBuf, C
 int SeekStateFile (GAME_STATE_FILE *fp, long offset, int whence);
 
 static inline COUNT
-sread_8 (void *fp, BYTE *v)
+sread_8 (GAME_STATE_FILE *fp, BYTE *v)
 {
 	BYTE t;
 	if (!v) /* read value ignored */
@@ -84,7 +88,7 @@ sread_8 (void *fp, BYTE *v)
 }
 
 static inline COUNT
-sread_16 (void *fp, UWORD *v)
+sread_16 (GAME_STATE_FILE *fp, UWORD *v)
 {
 	UWORD t;
 	if (!v) /* read value ignored */
@@ -93,7 +97,7 @@ sread_16 (void *fp, UWORD *v)
 }
 
 static inline COUNT
-sread_16s (void *fp, SWORD *v)
+sread_16s (GAME_STATE_FILE *fp, SWORD *v)
 {
 	UWORD t;
 	COUNT ret;
@@ -105,7 +109,7 @@ sread_16s (void *fp, SWORD *v)
 }
 
 static inline COUNT
-sread_32 (void *fp, DWORD *v)
+sread_32 (GAME_STATE_FILE *fp, DWORD *v)
 {
 	DWORD t;
 	if (!v) /* read value ignored */
@@ -114,7 +118,7 @@ sread_32 (void *fp, DWORD *v)
 }
 
 static inline COUNT
-sread_a32 (void *fp, DWORD *ar, COUNT count)
+sread_a32 (GAME_STATE_FILE *fp, DWORD *ar, COUNT count)
 {
 	assert (ar != NULL);
 
@@ -127,25 +131,25 @@ sread_a32 (void *fp, DWORD *ar, COUNT co
 }
 
 static inline COUNT
-swrite_8 (void *fp, BYTE v)
+swrite_8 (GAME_STATE_FILE *fp, BYTE v)
 {
 	return WriteStateFile (&v, 1, 1, fp);
 }
 
 static inline COUNT
-swrite_16 (void *fp, UWORD v)
+swrite_16 (GAME_STATE_FILE *fp, UWORD v)
 {
 	return WriteStateFile (&v, 2, 1, fp);
 }
 
 static inline COUNT
-swrite_32 (void *fp, DWORD v)
+swrite_32 (GAME_STATE_FILE *fp, DWORD v)
 {
 	return WriteStateFile (&v, 4, 1, fp);
 }
 
 static inline COUNT
-swrite_a32 (void *fp, const DWORD *ar, COUNT count)
+swrite_a32 (GAME_STATE_FILE *fp, const DWORD *ar, COUNT count)
 {
 	for ( ; count > 0; --count, ++ar)
 	{
@@ -155,5 +159,9 @@ swrite_a32 (void *fp, const DWORD *ar, C
 	return 1;
 }
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _STATE_H */
 
diff -ruNp src.orig/uqm/status.h src/uqm/status.h
--- src.orig/uqm/status.h	2017-11-21 19:39:43 -0600
+++ src/uqm/status.h	2017-11-21 19:40:00 -0600
@@ -22,6 +22,10 @@
 #include "races.h"
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #define CREW_XOFFS 4
 #define ENERGY_XOFFS 52
 #define GAUGE_YOFFS (SHIP_INFO_HEIGHT - 10)
@@ -64,4 +68,8 @@ extern BOOLEAN DeltaCrew (ELEMENT *Eleme
 extern void PreProcessStatus (ELEMENT *ShipPtr);
 extern void PostProcessStatus (ELEMENT *ShipPtr);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* UQM_STATUS_H_INCL_ */
diff -ruNp src.orig/uqm/supermelee/Makeinfo src/uqm/supermelee/Makeinfo
--- src.orig/uqm/supermelee/Makeinfo	2017-11-21 19:39:43 -0600
+++ src/uqm/supermelee/Makeinfo	2017-11-21 19:40:00 -0600
@@ -1,4 +1,5 @@
 uqm_CFILES="buildpick.c loadmele.c melee.c meleesetup.c pickmele.c"
+uqm_HFILES="buildpick.h loadmele.h melee.h meleesetup.h meleeship.h pickmele.h"
 if [ -n "$uqm_NETPLAY" ]; then
 	uqm_SUBDIRS="$uqm_SUBDIRS netplay"
 fi
diff -ruNp src.orig/uqm/supermelee/buildpick.c src/uqm/supermelee/buildpick.c
--- src.orig/uqm/supermelee/buildpick.c	2017-11-21 19:39:43 -0600
+++ src/uqm/supermelee/buildpick.c	2017-11-21 19:40:00 -0600
@@ -86,7 +86,6 @@ DrawPickIcon (MeleeShip ship, bool DrawE
 	}
 }
 
-// Pre: the called holds the GraphicsLock
 void
 DrawPickFrame (MELEE_STATE *pMS)
 {
@@ -187,11 +186,9 @@ DoPickShip (MELEE_STATE *pMS)
 		if (newSelectedShip != pMS->currentShip)
 		{
 			// A new ship has been selected.
-			LockMutex (GraphicsLock);
 			DrawPickIcon (pMS->currentShip, true);
 			pMS->currentShip = newSelectedShip;
 			DrawMeleeShipStrings (pMS, newSelectedShip);
-			UnlockMutex (GraphicsLock);
 		}
 	}
 
@@ -214,9 +211,7 @@ BuildPickShip (MELEE_STATE *pMS)
 	if (pMS->currentShip == MELEE_NONE)
 		pMS->currentShip = 0;
 
-	LockMutex (GraphicsLock);
 	DrawPickFrame (pMS);
-	UnlockMutex (GraphicsLock);
 
 	pMS->InputFunc = DoPickShip;
 	DoInput (pMS, FALSE);
diff -ruNp src.orig/uqm/supermelee/buildpick.h src/uqm/supermelee/buildpick.h
--- src.orig/uqm/supermelee/buildpick.h	2017-11-21 19:39:43 -0600
+++ src/uqm/supermelee/buildpick.h	2017-11-21 19:40:00 -0600
@@ -4,6 +4,10 @@
 #include "types.h"
 #include "melee.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 void BuildBuildPickFrame (void);
 void DestroyBuildPickFrame (void);
 bool BuildPickShip (MELEE_STATE *pMS);
@@ -13,5 +17,9 @@ void DrawPickFrame (MELEE_STATE *pMS);
 void DrawPickIcon (MeleeShip ship, bool DrawErase);
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* BUILDPICK_H */
 
diff -ruNp src.orig/uqm/supermelee/loadmele.c src/uqm/supermelee/loadmele.c
--- src.orig/uqm/supermelee/loadmele.c	2017-11-21 19:39:43 -0600
+++ src/uqm/supermelee/loadmele.c	2017-11-21 19:40:00 -0600
@@ -311,11 +311,9 @@ flashSelectedTeam (MELEE_STATE *pMS)
 		NextTime = Now + FLASH_RATE;
 		hilite ^= 1;
 
-		LockMutex (GraphicsLock);
 		OldContext = SetContext (SpaceContext);
 		SelectFileString (pMS, hilite);
 		SetContext (OldContext);
-		UnlockMutex (GraphicsLock);
 	}
 }
 
@@ -335,12 +333,10 @@ DoLoadTeam (MELEE_STATE *pMS)
 
 	if (!pMS->Initialized)
 	{
-		LockMutex (GraphicsLock);
 		DrawFileStrings (pMS);
 		SelectFileString (pMS, true);
 		pMS->Initialized = TRUE;
 		pMS->InputFunc = DoLoadTeam;
-		UnlockMutex (GraphicsLock);
 		return TRUE;
 	}
 
@@ -360,9 +356,7 @@ DoLoadTeam (MELEE_STATE *pMS)
 			RECT r;
 			
 			GetFrameRect (SetAbsFrameIndex (MeleeFrame, 28), &r);
-			LockMutex (GraphicsLock);
 			RepairMeleeFrame (&r);
-			UnlockMutex (GraphicsLock);
 		}
 		return TRUE;
 	}
@@ -418,7 +412,6 @@ DoLoadTeam (MELEE_STATE *pMS)
 		if (newIndex != pMS->load.cur)
 		{
 			// The cursor has been moved.
-			LockMutex (GraphicsLock);
 			if (newTop == pMS->load.top)
 			{
 				// The view itself hasn't changed.
@@ -431,7 +424,6 @@ DoLoadTeam (MELEE_STATE *pMS)
 				DrawFileStrings (pMS);
 			}
 			pMS->load.cur = newIndex;
-			UnlockMutex (GraphicsLock);
 		}
 	}
 
@@ -482,11 +474,9 @@ DoSaveTeam (MELEE_STATE *pMS)
 	snprintf (file, sizeof file, "%s.mle",
 			MeleeSetup_getTeamName (pMS->meleeSetup, pMS->side));
 
-	LockMutex (GraphicsLock);
 	OldContext = SetContext (ScreenContext);
 	ConfirmSaveLoad (&MsgStamp);
 			// Show the "Saving . . ." message.
-	UnlockMutex (GraphicsLock);
 
 	stream = uio_fopen (meleeDir, file, "wb");
 	if (stream != NULL)
@@ -503,11 +493,9 @@ DoSaveTeam (MELEE_STATE *pMS)
 	pMS->load.cur = 0;
 
 	// Undo the screen damage done by the "Saving . . ." message.
-	LockMutex (GraphicsLock);
 	DrawStamp (&MsgStamp);
 	DestroyDrawable (ReleaseDrawable (MsgStamp.frame));
 	SetContext (OldContext);
-	UnlockMutex (GraphicsLock);
 
 	if (!saveOk)
 		SaveProblem ();
diff -ruNp src.orig/uqm/supermelee/loadmele.h src/uqm/supermelee/loadmele.h
--- src.orig/uqm/supermelee/loadmele.h	2017-11-21 19:39:43 -0600
+++ src/uqm/supermelee/loadmele.h	2017-11-21 19:40:00 -0600
@@ -26,6 +26,10 @@ struct melee_load_state;
 #include "melee.h"
 #include "meleesetup.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 struct melee_load_state
 {
 	MeleeTeam **preBuiltList;
@@ -56,6 +60,10 @@ bool ReadTeamImage (MeleeTeam *pTI, uio_
 int WriteTeamImage (const MeleeTeam *pTI, uio_Stream *save_fp);
 void LoadTeamList (MELEE_STATE *pMS);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _LOADMELE_H */
 
 
diff -ruNp src.orig/uqm/supermelee/melee.c src/uqm/supermelee/melee.c
--- src.orig/uqm/supermelee/melee.c	2017-11-21 19:39:43 -0600
+++ src/uqm/supermelee/melee.c	2017-11-21 19:40:00 -0600
@@ -250,7 +250,6 @@ GetShipBox (RECT *pRect, COUNT side, COU
 	pRect->extent.height = MELEE_BOX_HEIGHT;
 }
 
-// The caller must hold the GraphicsLock.
 static void
 DrawShipBox (COUNT side, FleetShipIndex index, MeleeShip ship, BOOLEAN HiLite)
 {
@@ -286,7 +285,6 @@ DrawShipBox (COUNT side, FleetShipIndex
 	UnbatchGraphics ();
 }
 
-// The caller must hold the GraphicsLock.
 static void
 ClearShipBox (COUNT side, FleetShipIndex index)
 {
@@ -570,7 +568,6 @@ DrawTeamString (MELEE_STATE *pMS, COUNT
 
 #ifdef NETPLAY
 // This function is generic. It should probably be moved to elsewhere.
-// The caller should hold the GraphicsLock.
 static void
 multiLineDrawText (TEXT *textIn, RECT *clipRect) {
 	RECT oldRect;
@@ -617,7 +614,6 @@ DrawMeleeStatusMessage (const char *mess
 	CONTEXT oldContext;
 	RECT r;
 
-	LockMutex (GraphicsLock);
 	oldContext = SetContext (SpaceContext);
 
 	r.corner.x = MELEE_STATUS_X_OFFS;
@@ -643,7 +639,6 @@ DrawMeleeStatusMessage (const char *mess
 	}
 
 	SetContext (oldContext);
-	UnlockMutex (GraphicsLock);
 }
 
 static void
@@ -697,7 +692,6 @@ UpdateMeleeStatusMessage (ssize_t player
 #endif  /* NETPLAY */
 
 // XXX: this function is called when the current selection is blinking off.
-// The caller should hold the GraphicsLock.
 static void
 Deselect (BYTE opt)
 {
@@ -760,7 +754,6 @@ Deselect (BYTE opt)
 }
 
 // XXX: this function is called when the current selection is blinking off.
-// The caller should hold the GraphicsLock.
 static void
 Select (BYTE opt)
 {
@@ -837,14 +830,12 @@ Melee_flashSelection (MELEE_STATE *pMS)
 		NextTime = Now + FLASH_RATE;
 		select = !select;
 
-		LockMutex (GraphicsLock);
 		OldContext = SetContext (SpaceContext);
 		if (select)
 			Select (pMS->MeleeOption);
 		else
 			Deselect (pMS->MeleeOption);
 		SetContext (OldContext);
-		UnlockMutex (GraphicsLock);
 	}
 }
 
@@ -870,7 +861,6 @@ InitMelee (MELEE_STATE *pMS)
 	(void) pMS;
 }
 
-// Pre: The caller holds the GraphicsLock.
 void
 DrawMeleeShipStrings (MELEE_STATE *pMS, MeleeShip NewStarShip)
 {
@@ -957,9 +947,7 @@ UpdateCurrentShip (MELEE_STATE *pMS)
 				MeleeSetup_getShip (pMS->meleeSetup, pMS->side, slotNr);
 	}
 
-	LockMutex (GraphicsLock);
 	DrawMeleeShipStrings (pMS, pMS->currentShip);
-	UnlockMutex (GraphicsLock);
 }
 
 // returns (COUNT) ~0 for an invalid ship.
@@ -1025,9 +1013,7 @@ OnTeamNameChange (TEXTENTRY_STATE *pTES)
 	if (pTES->JoystickMode)
 		hl |= DTSHS_BLOCKCUR;
 
-	LockMutex (GraphicsLock);
 	ret = DrawTeamString (pMS, pMS->side, hl, pTES->BaseStr);
-	UnlockMutex (GraphicsLock);
 
 	return ret;
 }
@@ -1074,9 +1060,7 @@ BuildPickShipPopup (MELEE_STATE *pMS)
 		RECT r;
 			
 		GetBuildPickFrameRect (&r);
-		LockMutex (GraphicsLock);
 		RepairMeleeFrame (&r);
-		UnlockMutex (GraphicsLock);
 	}
 
 	UpdateCurrentShip (pMS);
@@ -1113,12 +1097,10 @@ DoEdit (MELEE_STATE *pMS)
 			|| pMS->row == NUM_MELEE_ROWS))))
 	{
 		// Done editing the teams.
-		LockMutex (GraphicsLock);
 		Deselect (EDIT_MELEE);
 		pMS->currentShip = MELEE_NONE;
 		pMS->MeleeOption = START_MELEE;
 		pMS->InputFunc = DoMelee;
-		UnlockMutex (GraphicsLock);
 		pMS->LastInputTime = GetTimeCounter ();
 	}
 	else if (pMS->row < NUM_MELEE_ROWS
@@ -1132,13 +1114,11 @@ DoEdit (MELEE_STATE *pMS)
 			&& PulsedInputState.menu[KEY_MENU_SPECIAL])
 	{
 		// TODO: this is a stub; Should we display a ship spin?
-		LockMutex (GraphicsLock);
 		Deselect (EDIT_MELEE);
 		if (pMS->currentShip != MELEE_NONE)
 		{
 			// Do something with pMS->currentShip here
 		}
-		UnlockMutex (GraphicsLock);
 	}
 	else if (pMS->row < NUM_MELEE_ROWS &&
 			PulsedInputState.menu[KEY_MENU_DELETE])
@@ -1165,9 +1145,7 @@ DoEdit (MELEE_STATE *pMS)
 
 				// going to enter text
 				pMS->CurIndex = 0;
-				LockMutex (GraphicsLock);
 				DrawTeamString (pMS, pMS->side, DTSHS_EDIT, NULL);
-				UnlockMutex (GraphicsLock);
 
 				strncpy (buf, MeleeSetup_getTeamName (
 						pMS->meleeSetup, pMS->side), MAX_TEAM_CHARS);
@@ -1238,12 +1216,10 @@ DoEdit (MELEE_STATE *pMS)
 
 		if (col != pMS->col || row != pMS->row || side != pMS->side)
 		{
-			LockMutex (GraphicsLock);
 			Deselect (EDIT_MELEE);
 			pMS->side = side;
 			pMS->row = row;
 			pMS->col = col;
-			UnlockMutex (GraphicsLock);
 
 			UpdateCurrentShip (pMS);
 		}
@@ -1488,9 +1464,7 @@ StartMelee (MELEE_STATE *pMS)
 	{
 		if (!SetPlayerInputAll ())
 			break;
-		LockMutex (GraphicsLock);
 		BuildAndDrawShipList (pMS);
-		UnlockMutex (GraphicsLock);
 
 		WaitForSoundEnd (TFBSOUND_WAIT_ALL);
 
@@ -1638,7 +1612,6 @@ DoConnectingDialog (MELEE_STATE *pMS)
 		pMS->InputFunc = DoConnectingDialog;
 
 		/* Draw the dialog box here */
-		LockMutex (GraphicsLock);
 		oldfont = SetContextFont (StarConFont);
 		oldcolor = SetContextForeGroundColor (BLACK_COLOR);
 		BatchGraphics ();
@@ -1674,7 +1647,6 @@ DoConnectingDialog (MELEE_STATE *pMS)
 		SetContextFont (oldfont);
 		SetContextForeGroundColor (oldcolor);
 		UnbatchGraphics ();
-		UnlockMutex (GraphicsLock);
 	}
 
 	netInput ();
@@ -1882,9 +1854,7 @@ DoMelee (MELEE_STATE *pMS)
 		
 		pMS->MeleeOption = START_MELEE;
 		PlayMusic (pMS->hMusic, TRUE, 1);
-		LockMutex (GraphicsLock);
 		InitMelee (pMS);
-		UnlockMutex (GraphicsLock);
 
 		FadeScreen (FadeAllToColor, ONE_SECOND / 2);
 		pMS->LastInputTime = GetTimeCounter ();
@@ -1899,10 +1869,8 @@ DoMelee (MELEE_STATE *pMS)
 			PulsedInputState.menu[KEY_MENU_LEFT])
 	{
 		// Start editing the teams.
-		LockMutex (GraphicsLock);
 		pMS->LastInputTime = GetTimeCounter ();
 		Deselect (pMS->MeleeOption);
-		UnlockMutex (GraphicsLock);
 		pMS->MeleeOption = EDIT_MELEE;
 		pMS->Initialized = FALSE;
 		if (PulsedInputState.menu[KEY_MENU_CANCEL])
@@ -1949,11 +1917,9 @@ DoMelee (MELEE_STATE *pMS)
 					pMS->MeleeOption == CONTROLS_BOT)
 				UpdateMeleeStatusMessage (-1);
 #endif
-			LockMutex (GraphicsLock);
 			Deselect (pMS->MeleeOption);
 			pMS->MeleeOption = NewMeleeOption;
 			Select (pMS->MeleeOption);
-			UnlockMutex (GraphicsLock);
 #ifdef NETPLAY
 			if (NewMeleeOption == CONTROLS_TOP ||
 					NewMeleeOption == CONTROLS_BOT)
@@ -2148,14 +2114,12 @@ updateRandomSeed (MELEE_STATE *pMS, COUN
 void
 confirmationCancelled (MELEE_STATE *pMS, COUNT side)
 {
-	LockMutex (GraphicsLock);
 	if (side == 0)
 		DrawMeleeStatusMessage (GAME_STRING (NETMELEE_STRING_BASE + 16));
 				// "Bottom player changed something -- need to reconfirm."
 	else
 		DrawMeleeStatusMessage (GAME_STRING (NETMELEE_STRING_BASE + 17));
 				// "Top player changed something -- need to reconfirm."
-	UnlockMutex (GraphicsLock);
 
 	if (pMS->InputFunc == DoConfirmSettings)
 		pMS->InputFunc = DoMelee;
@@ -2168,9 +2132,7 @@ connectionFeedback (NetConnection *conn,
 	if (bs == NULL && !forcePopup)
 	{
 		// bs == NULL means the game has not started yet.
-		LockMutex (GraphicsLock);
 		DrawMeleeStatusMessage (str);
-		UnlockMutex (GraphicsLock);
 	}
 	else
 	{
@@ -2314,10 +2276,8 @@ Melee_UpdateView_fleetValue (MELEE_STATE
 	if (pMS->meleeStarted)
 		return;
 
-	LockMutex (GraphicsLock);
 	DrawFleetValue (pMS, side, DTSHS_REPAIR);
 			// BUG: The fleet value is always drawn as deselected.
-	UnlockMutex (GraphicsLock);
 }
 
 static void
@@ -2330,7 +2290,6 @@ Melee_UpdateView_ship (MELEE_STATE *pMS,
 
 	ship = MeleeSetup_getShip (pMS->meleeSetup, side, index);
 
-	LockMutex (GraphicsLock);
 	if (ship == MELEE_NONE)
 	{
 		ClearShipBox (side, index);
@@ -2339,7 +2298,6 @@ Melee_UpdateView_ship (MELEE_STATE *pMS,
 	{
 		DrawShipBox (side, index, ship, FALSE);
 	}
-	UnlockMutex (GraphicsLock);
 }
 
 static void
@@ -2348,9 +2306,7 @@ Melee_UpdateView_teamName (MELEE_STATE *
 	if (pMS->meleeStarted)
 		return;
 
-	LockMutex (GraphicsLock);
 	DrawTeamString (pMS, side, DTSHS_REPAIR, NULL);
-	UnlockMutex (GraphicsLock);
 }
 
 ///////////////////////////////////////////////////////////////////////////
@@ -2378,9 +2334,7 @@ Melee_Change_ship (MELEE_STATE *pMS, COU
 	if (isShipSlotSelected (pMS, side, index))
 	{
 		pMS->currentShip = ship;
-		LockMutex (GraphicsLock);
 		DrawMeleeShipStrings (pMS, ship);
-		UnlockMutex (GraphicsLock);
 	}
 
 	return true;
diff -ruNp src.orig/uqm/supermelee/melee.h src/uqm/supermelee/melee.h
--- src.orig/uqm/supermelee/melee.h	2017-11-21 19:39:43 -0600
+++ src/uqm/supermelee/melee.h	2017-11-21 19:40:00 -0600
@@ -28,6 +28,10 @@
 #include "netplay/packet.h"
 		// for NetplayAbortReason and NetplayResetReason.
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef struct melee_state MELEE_STATE;
 
 #define NUM_MELEE_ROWS 2
@@ -50,10 +54,18 @@ extern FRAME PickMeleeFrame;
 
 typedef BYTE MELEE_OPTIONS;
 
+#if defined(__cplusplus)
+}
+#endif
+
 #include "loadmele.h"
 #include "meleesetup.h"
 #include "meleeship.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 struct melee_state
 {
 	BOOLEAN (*InputFunc) (struct melee_state *pInputState);
@@ -125,5 +137,9 @@ void Melee_RemoteChange_ship (MELEE_STAT
 void Melee_RemoteChange_teamName (MELEE_STATE *pMS, NetConnection *conn,
 		COUNT side, const char *name);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _MELEE_H */
 
diff -ruNp src.orig/uqm/supermelee/meleesetup.h src/uqm/supermelee/meleesetup.h
--- src.orig/uqm/supermelee/meleesetup.h	2017-11-21 19:39:43 -0600
+++ src/uqm/supermelee/meleesetup.h	2017-11-21 19:40:00 -0600
@@ -32,6 +32,10 @@ typedef COUNT FleetShipIndex;
 #include "melee.h"
 #include "meleeship.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #ifdef MELEETEAM_INTERNAL
 struct MeleeTeam
 {
@@ -131,5 +135,9 @@ void MeleeState_setTeamName (MELEE_STATE
 void MeleeState_setTeam (MELEE_STATE *pMS, size_t teamNr,
 		const MeleeTeam *team);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* MELEESETUP_H */
 
diff -ruNp src.orig/uqm/supermelee/meleeship.h src/uqm/supermelee/meleeship.h
--- src.orig/uqm/supermelee/meleeship.h	2017-11-21 19:39:43 -0600
+++ src/uqm/supermelee/meleeship.h	2017-11-21 19:40:00 -0600
@@ -3,6 +3,10 @@
 
 #include "types.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef enum MeleeShip {
 	MELEE_ANDROSYNTH,
 	MELEE_ARILOU,
@@ -43,5 +47,9 @@ MeleeShip_valid (MeleeShip ship)
 	return (ship < NUM_MELEE_SHIPS) || (ship == MELEE_NONE);
 }
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* MELEESHIP_H */
 
diff -ruNp src.orig/uqm/supermelee/netplay/Makeinfo src/uqm/supermelee/netplay/Makeinfo
--- src.orig/uqm/supermelee/netplay/Makeinfo	2017-11-21 19:39:43 -0600
+++ src/uqm/supermelee/netplay/Makeinfo	2017-11-21 19:40:00 -0600
@@ -1,3 +1,4 @@
 uqm_SUBDIRS="proto"
 uqm_CFILES="checkbuf.c checksum.c crc.c netconnection.c netinput.c netmelee.c netmisc.c netoptions.c netrcv.c netsend.c netstate.c notify.c notifyall.c packet.c packethandlers.c packetsenders.c packetq.c"
+uqm_HFILES="checkbuf.h checksum.h crc.h netconnection.h netinput.h netmelee.h netmisc.h netoptions.h netplay.h netrcv.h netsend.h netstate.h notifyall.h notify.h packet.h packethandlers.h packetq.h packetsenders.h"
 
diff -ruNp src.orig/uqm/supermelee/netplay/checkbuf.h src/uqm/supermelee/netplay/checkbuf.h
--- src.orig/uqm/supermelee/netplay/checkbuf.h	2017-11-21 19:39:43 -0600
+++ src/uqm/supermelee/netplay/checkbuf.h	2017-11-21 19:40:00 -0600
@@ -19,13 +19,25 @@
 #ifndef _CHECKBUF_H
 #define _CHECKBUF_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef struct ChecksumEntry ChecksumEntry;
 typedef struct ChecksumBuffer ChecksumBuffer;
 
+#if defined(__cplusplus)
+}
+#endif
+
 #include "../../battle.h"
 		// for BattleFrameCounter
 #include "checksum.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 
 struct ChecksumEntry {
 #ifdef NETPLAY_DEBUG
@@ -58,5 +70,9 @@ bool ChecksumBuffer_addChecksum(Checksum
 bool ChecksumBuffer_getChecksum(ChecksumBuffer *cb,
 		BattleFrameCounter frameNr, Checksum *result);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _CHECKBUF_H */
 
diff -ruNp src.orig/uqm/supermelee/netplay/checksum.h src/uqm/supermelee/netplay/checksum.h
--- src.orig/uqm/supermelee/netplay/checksum.h	2017-11-21 19:39:43 -0600
+++ src/uqm/supermelee/netplay/checksum.h	2017-11-21 19:40:00 -0600
@@ -33,6 +33,10 @@ typedef uint32 Checksum;
 
 #include "netconnection.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 
 static inline void
 crc_processELEMENT_FLAGS(crc_State *state, ELEMENT_FLAGS val) {
@@ -88,6 +92,10 @@ void addRemoteChecksum(NetConnection *co
 		Checksum checksum);
 bool verifyChecksums(BattleFrameCounter frameNr);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _CHECKSUM_H */
 
 
diff -ruNp src.orig/uqm/supermelee/netplay/crc.h src/uqm/supermelee/netplay/crc.h
--- src.orig/uqm/supermelee/netplay/crc.h	2017-11-21 19:39:43 -0600
+++ src/uqm/supermelee/netplay/crc.h	2017-11-21 19:40:00 -0600
@@ -25,6 +25,10 @@ typedef struct crc_State crc_State;
 
 #include <stddef.h>
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 struct crc_State {
 	uint32 crc;
 };
@@ -36,6 +40,9 @@ void crc_processUint16(crc_State *state,
 void crc_processUint32(crc_State *state, uint32 val);
 uint32 crc_finish(const crc_State *state);
 
+#if defined(__cplusplus)
+}
+#endif
 
 #ifdef DUMP_CRC_OPS
 #include "netconnection.h"
diff -ruNp src.orig/uqm/supermelee/netplay/netconnection.h src/uqm/supermelee/netplay/netconnection.h
--- src.orig/uqm/supermelee/netplay/netconnection.h	2017-11-21 19:39:43 -0600
+++ src/uqm/supermelee/netplay/netconnection.h	2017-11-21 19:40:00 -0600
@@ -22,6 +22,10 @@
 #include "netplay.h"
 		// for NETPLAY_STATISTICS
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef struct NetConnection NetConnection;
 typedef struct NetConnectionError NetConnectionError;
 typedef struct ConnectStateData ConnectStateData;
@@ -38,6 +42,10 @@ typedef void (*NetConnection_DeleteCallb
 typedef void (*NetConnection_ReadyCallback)(NetConnection *conn, void *arg);
 typedef void (*NetConnection_ResetCallback)(NetConnection *conn, void *arg);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #include "netstate.h"
 #include "netoptions.h"
 #ifdef NETPLAY_CHECKSUM
@@ -50,6 +58,10 @@ typedef void (*NetConnection_ResetCallba
 #	include "libs/uio.h"
 #endif
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 struct NetConnectionError {
 	NetState state;
 	int err;
@@ -68,11 +80,18 @@ struct NetStatistics {
 };
 #endif
 
+#if defined(__cplusplus)
+}
+#endif
 
 #ifdef NETCONNECTION_INTERNAL
 #include "libs/net.h"
 #include "packetq.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef struct {
 	// For actions that require agreement by both parties.
 	bool localOk : 1;    /* Action confirmed by us */
@@ -232,6 +251,9 @@ void *NetConnection_getResetCallbackArg(
 extern uio_Stream *netplayDebugFile;
 #endif
 
+#if defined(__cplusplus)
+}
+#endif
 
 #endif  /* _NETCONNECTION_H */
 
diff -ruNp src.orig/uqm/supermelee/netplay/netinput.h src/uqm/supermelee/netplay/netinput.h
--- src.orig/uqm/supermelee/netplay/netinput.h	2017-11-21 19:39:43 -0600
+++ src/uqm/supermelee/netplay/netinput.h	2017-11-21 19:40:00 -0600
@@ -22,6 +22,10 @@
 #include "../../controls.h"
 		// for BATTLE_INPUT_STATE
 #include "../../init.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
 		// for NUM_PLAYERS
 
 typedef struct BattleInputBuffer {
@@ -46,5 +50,9 @@ bool BattleInputBuffer_pop(BattleInputBu
 
 BattleInputBuffer *getBattleInputBuffer(size_t player);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _NETINPUT_H */
 
diff -ruNp src.orig/uqm/supermelee/netplay/netmelee.c src/uqm/supermelee/netplay/netmelee.c
--- src.orig/uqm/supermelee/netplay/netmelee.c	2017-11-21 19:39:43 -0600
+++ src/uqm/supermelee/netplay/netmelee.c	2017-11-21 19:40:00 -0600
@@ -17,7 +17,7 @@
  */
 
 #include "netmelee.h"
-#include "libs/alarm.h"
+#include "libs/async.h"
 #include "libs/callback.h"
 #include "libs/log.h"
 #include "libs/net.h"
@@ -146,8 +146,7 @@ netInputAux(uint32 timeoutMs) {
 	NetManager_process(&timeoutMs);
 			// This may cause more packets to be queued, hence the
 			// flushPacketQueues().
-	Alarm_process();
-	Callback_process();
+	Async_process();
 	flushPacketQueues();
 			// During the flush, a disconnect may be noticed, which triggers
 			// another callback. It must be handled immediately, before
@@ -166,11 +165,11 @@ netInput(void) {
 
 void
 netInputBlocking(uint32 timeoutMs) {
-	uint32 nextAlarmMs;
+	uint32 nextAsyncMs;
 		
-	nextAlarmMs = Alarm_timeBeforeNextMs();
-	if (nextAlarmMs < timeoutMs)
-		timeoutMs = nextAlarmMs;
+	nextAsyncMs = Async_timeBeforeNextMs();
+	if (nextAsyncMs < timeoutMs)
+		timeoutMs = nextAsyncMs;
 
 	netInputAux(timeoutMs);
 }
diff -ruNp src.orig/uqm/supermelee/netplay/netmelee.h src/uqm/supermelee/netplay/netmelee.h
--- src.orig/uqm/supermelee/netplay/netmelee.h	2017-11-21 19:39:43 -0600
+++ src/uqm/supermelee/netplay/netmelee.h	2017-11-21 19:40:00 -0600
@@ -31,6 +31,9 @@
 #include "../../races.h"
 		// for STARSHIP
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
 extern struct NetConnection *netConnections[];
 
@@ -80,6 +83,10 @@ bool waitReady(NetConnection *conn);
 bool waitReset(NetConnection *conn, NetState nextState);
 bool waitResetConnections(NetState nextState);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _NETMELEE_H */
 
 
diff -ruNp src.orig/uqm/supermelee/netplay/netmisc.h src/uqm/supermelee/netplay/netmisc.h
--- src.orig/uqm/supermelee/netplay/netmisc.h	2017-11-21 19:39:43 -0600
+++ src/uqm/supermelee/netplay/netmisc.h	2017-11-21 19:40:01 -0600
@@ -28,6 +28,10 @@ typedef struct BattleStateData BattleSta
 #include "../../battle.h"
 		// for BattleFrameCounter, BATTLE_FRAME_RATE
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 struct BattleStateData {
 	NETCONNECTION_STATE_DATA_COMMON
 
@@ -66,6 +70,10 @@ readyFlagsMeaningful(NetState state) {
 }
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _NETMISC_H */
 
 
diff -ruNp src.orig/uqm/supermelee/netplay/netoptions.h src/uqm/supermelee/netplay/netoptions.h
--- src.orig/uqm/supermelee/netplay/netoptions.h	2017-11-21 19:39:43 -0600
+++ src/uqm/supermelee/netplay/netoptions.h	2017-11-21 19:40:01 -0600
@@ -23,6 +23,10 @@
 
 #include <stddef.h>
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #define NETPLAY_NUM_PLAYERS 2
 		// Not using NUM_PLAYERS because that would mean we'd have
 		// to include init.h, and all that comes with it.
@@ -45,6 +49,10 @@ typedef struct {
 extern NetplayOptions netplayOptions;
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _NETOPTIONS_H */
 
 
diff -ruNp src.orig/uqm/supermelee/netplay/netrcv.h src/uqm/supermelee/netplay/netrcv.h
--- src.orig/uqm/supermelee/netplay/netrcv.h	2017-11-21 19:39:43 -0600
+++ src/uqm/supermelee/netplay/netrcv.h	2017-11-21 19:40:01 -0600
@@ -21,7 +21,15 @@
 
 #include "libs/net.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 void dataReadyCallback(NetDescriptor *nd);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _NETRCV_H */
 
diff -ruNp src.orig/uqm/supermelee/netplay/netsend.h src/uqm/supermelee/netplay/netsend.h
--- src.orig/uqm/supermelee/netplay/netsend.h	2017-11-21 19:39:43 -0600
+++ src/uqm/supermelee/netplay/netsend.h	2017-11-21 19:40:01 -0600
@@ -21,8 +21,16 @@
 
 #include "packet.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 int sendPacket(NetConnection *conn, Packet *packet);
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _NETSEND_H */
 
diff -ruNp src.orig/uqm/supermelee/netplay/netstate.h src/uqm/supermelee/netplay/netstate.h
--- src.orig/uqm/supermelee/netplay/netstate.h	2017-11-21 19:39:43 -0600
+++ src/uqm/supermelee/netplay/netstate.h	2017-11-21 19:40:01 -0600
@@ -21,6 +21,9 @@
 
 #include "port.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
 typedef struct NetConnectionStateData NetConnectionStateData;
 
@@ -38,8 +41,16 @@ typedef enum {
 	NetState_endingBattle2,  /* Waiting for the final synchronisation */
 } NetState;
 
+#if defined(__cplusplus)
+}
+#endif
+
 #include "types.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef struct {
 	const char *name;
 } NetStateData;
@@ -65,5 +76,9 @@ NetState_battleActive(NetState state) {
 }
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _NETSTATE_H */
 
diff -ruNp src.orig/uqm/supermelee/netplay/notify.h src/uqm/supermelee/netplay/notify.h
--- src.orig/uqm/supermelee/netplay/notify.h	2017-11-21 19:39:43 -0600
+++ src/uqm/supermelee/netplay/notify.h	2017-11-21 19:40:01 -0600
@@ -32,6 +32,10 @@
 #include "../meleesetup.h"
 		// for FleetShipIndex
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 void Netplay_Notify_shipSelected(NetConnection *conn, FleetShipIndex index);
 void Netplay_Notify_battleInput(NetConnection *conn,
 		BATTLE_INPUT_STATE input);
@@ -51,5 +55,9 @@ void Netplay_Notify_checksum(NetConnecti
 #endif
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _NOTIFY_H */
 
diff -ruNp src.orig/uqm/supermelee/netplay/notifyall.h src/uqm/supermelee/netplay/notifyall.h
--- src.orig/uqm/supermelee/netplay/notifyall.h	2017-11-21 19:39:43 -0600
+++ src/uqm/supermelee/netplay/notifyall.h	2017-11-21 19:40:01 -0600
@@ -24,6 +24,10 @@
 #	include "checksum.h"
 #endif  /* NETPLAY_CHECKSUM */
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 void Netplay_NotifyAll_setTeamName (MELEE_STATE *pMS, size_t playerNr);
 void Netplay_NotifyAll_setFleet (MELEE_STATE *pMS, size_t playerNr);
 void Netplay_NotifyAll_setShip (MELEE_STATE *pMS, size_t playerNr,
@@ -37,5 +41,9 @@ void Netplay_NotifyAll_checksum(BattleFr
 void Netplay_NotifyAll_battleInput(BATTLE_INPUT_STATE input);
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* NOTIFYALL_H */
 
diff -ruNp src.orig/uqm/supermelee/netplay/packet.h src/uqm/supermelee/netplay/packet.h
--- src.orig/uqm/supermelee/netplay/packet.h	2017-11-21 19:39:43 -0600
+++ src/uqm/supermelee/netplay/packet.h	2017-11-21 19:40:01 -0600
@@ -19,6 +19,10 @@
 #ifndef _PACKET_H
 #define _PACKET_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef struct Packet Packet;
 
 typedef enum PacketType {
@@ -60,12 +64,19 @@ typedef enum NetplayResetReason {
 	ResetReason_manualReset,
 } NetplayResetReason;
 
+#if defined(__cplusplus)
+}
+#endif
+
 #ifndef PACKET_H_STANDALONE
 #include "netconnection.h"
 
 #include "types.h"
 #include "libs/network/bytesex.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
 /* NB: These handlers are expected not to modify the state if an
  *     error occurs.
@@ -81,8 +92,16 @@ typedef struct {
 } PacketTypeData;
 
 extern PacketTypeData packetTypeData[];
+
+#if defined(__cplusplus)
+}
+#endif
+
 #endif
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
 // When adding new packets, be sure to have all the fields properly aligned,
 // and that the size of a packet is a multiple of 4 bytes in length.
@@ -272,6 +291,9 @@ Packet_Abort *Packet_Abort_create(uint16
 Packet_Reset *Packet_Reset_create(uint16 reason);
 #endif
 
+#if defined(__cplusplus)
+}
+#endif
 
 #endif  /* _PACKET_H */
 
diff -ruNp src.orig/uqm/supermelee/netplay/packethandlers.h src/uqm/supermelee/netplay/packethandlers.h
--- src.orig/uqm/supermelee/netplay/packethandlers.h	2017-11-21 19:39:43 -0600
+++ src/uqm/supermelee/netplay/packethandlers.h	2017-11-21 19:40:01 -0600
@@ -21,9 +21,13 @@
 
 #include "packet.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #define DECLARE_PACKETHANDLER(type) \
 		int PacketHandler_##type(NetConnection *conn, \
-				const Packet_##type *packet);
+				const Packet_##type *packet)
 
 DECLARE_PACKETHANDLER(Init);
 DECLARE_PACKETHANDLER(Ping);
@@ -45,4 +49,8 @@ DECLARE_PACKETHANDLER(Abort);
 DECLARE_PACKETHANDLER(Reset);
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _PACKETHANDLERS_H */
diff -ruNp src.orig/uqm/supermelee/netplay/packetq.h src/uqm/supermelee/netplay/packetq.h
--- src.orig/uqm/supermelee/netplay/packetq.h	2017-11-21 19:39:43 -0600
+++ src/uqm/supermelee/netplay/packetq.h	2017-11-21 19:40:01 -0600
@@ -26,6 +26,10 @@ typedef struct PacketQueue PacketQueue;
 
 #include <sys/types.h>
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef struct PacketQueueLink PacketQueueLink;
 struct PacketQueueLink {
 	PacketQueueLink *next;
@@ -47,5 +51,9 @@ void queuePacket(NetConnection *conn, Pa
 int flushPacketQueue(NetConnection *conn);
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif
 
diff -ruNp src.orig/uqm/supermelee/netplay/packetsenders.h src/uqm/supermelee/netplay/packetsenders.h
--- src.orig/uqm/supermelee/netplay/packetsenders.h	2017-11-21 19:39:43 -0600
+++ src/uqm/supermelee/netplay/packetsenders.h	2017-11-21 19:40:01 -0600
@@ -31,6 +31,10 @@
 #include "../meleesetup.h"
 		// for FleetShipIndex
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 void sendInit(NetConnection *conn);
 void sendPing(NetConnection *conn, uint32 id);
 void sendAck(NetConnection *conn, uint32 id);
@@ -56,6 +60,10 @@ void sendAbort(NetConnection *conn, Netp
 void sendReset(NetConnection *conn, NetplayResetReason reason);
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _PACKETSENDERS_H */
 
 
diff -ruNp src.orig/uqm/supermelee/netplay/proto/Makeinfo src/uqm/supermelee/netplay/proto/Makeinfo
--- src.orig/uqm/supermelee/netplay/proto/Makeinfo	2017-11-21 19:39:43 -0600
+++ src/uqm/supermelee/netplay/proto/Makeinfo	2017-11-21 19:40:01 -0600
@@ -1,2 +1,2 @@
 uqm_CFILES="npconfirm.c ready.c reset.c"
-
+uqm_HFILES="npconfirm.h ready.h reset.h"
diff -ruNp src.orig/uqm/supermelee/netplay/proto/npconfirm.h src/uqm/supermelee/netplay/proto/npconfirm.h
--- src.orig/uqm/supermelee/netplay/proto/npconfirm.h	2017-11-21 19:39:44 -0600
+++ src/uqm/supermelee/netplay/proto/npconfirm.h	2017-11-21 19:40:01 -0600
@@ -22,9 +22,17 @@
 #include "../netplay.h"
 #include "../netconnection.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 int Netplay_confirm(NetConnection *conn);
 int Netplay_cancelConfirmation(NetConnection *conn);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _NPCONFIRM_H */
 
 
diff -ruNp src.orig/uqm/supermelee/netplay/proto/ready.h src/uqm/supermelee/netplay/proto/ready.h
--- src.orig/uqm/supermelee/netplay/proto/ready.h	2017-11-21 19:39:44 -0600
+++ src/uqm/supermelee/netplay/proto/ready.h	2017-11-21 19:40:01 -0600
@@ -21,11 +21,19 @@
 
 #include "../netconnection.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 bool Netplay_localReady(NetConnection *conn,
 		NetConnection_ReadyCallback callback, void *arg, bool notifyRemote);
 bool Netplay_remoteReady(NetConnection *conn);
 bool Netplay_isLocalReady(const NetConnection *conn);
 bool Netplay_isRemoteReady(const NetConnection *conn);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _READY_H */
 
diff -ruNp src.orig/uqm/supermelee/netplay/proto/reset.h src/uqm/supermelee/netplay/proto/reset.h
--- src.orig/uqm/supermelee/netplay/proto/reset.h	2017-11-21 19:39:44 -0600
+++ src/uqm/supermelee/netplay/proto/reset.h	2017-11-21 19:40:01 -0600
@@ -22,6 +22,10 @@
 #include "../netconnection.h"
 #include "../packet.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 void Netplay_setResetCallback(NetConnection *conn,
 		NetConnection_ResetCallback callback, void *resetArg);
 void Netplay_localReset(NetConnection *conn, NetplayResetReason reason);
@@ -29,6 +33,9 @@ void Netplay_remoteReset(NetConnection *
 bool Netplay_isLocalReset(const NetConnection *conn);
 bool Netplay_isRemoteReset(const NetConnection *conn);
 
+#if defined(__cplusplus)
+}
+#endif
 
 #endif  /* _RESET_H */
 
diff -ruNp src.orig/uqm/supermelee/pickmele.c src/uqm/supermelee/pickmele.c
--- src.orig/uqm/supermelee/pickmele.c	2017-11-21 19:39:44 -0600
+++ src/uqm/supermelee/pickmele.c	2017-11-21 19:40:01 -0600
@@ -37,6 +37,7 @@
 #include "../races.h"
 #include "../setup.h"
 #include "../sounds.h"
+#include "libs/async.h"
 #include "libs/log.h"
 #include "libs/mathlib.h"
 
@@ -655,7 +656,6 @@ MeleeGameOver (void)
 	for (playerI = 0; playerI < NUM_PLAYERS; playerI++)
 		DrawPickMeleeFrame (playerI);
 	
-	UnlockMutex (GraphicsLock);
 
 #ifdef NETPLAY
 	negotiateReadyConnections(true, NetState_inSetup);
@@ -676,12 +676,12 @@ MeleeGameOver (void)
 			ButtonState = FALSE;
 		}
 
+		Async_process ();
 		TaskSwitch ();
 	} while (!(GLOBAL (CurrentActivity) & CHECK_ABORT) && (!ButtonState
 			&& (!(PlayerControl[0] & PlayerControl[1] & PSYTRON_CONTROL)
 			|| GetTimeCounter () < TimeOut)));
 
-	LockMutex (GraphicsLock);
 }
 
 void
@@ -794,12 +794,10 @@ GetMeleeStarShips (COUNT playerMask, HST
 	
 	SetContext (OffScreenContext);
 
-	UnlockMutex (GraphicsLock);
 
 	DoInput (&gmstate, FALSE);
 	WaitForSoundEnd (0);
 
-	LockMutex (GraphicsLock);
 
 	for (playerI = 0; playerI < NUM_PLAYERS; playerI++)
 	{
diff -ruNp src.orig/uqm/supermelee/pickmele.h src/uqm/supermelee/pickmele.h
--- src.orig/uqm/supermelee/pickmele.h	2017-11-21 19:39:44 -0600
+++ src/uqm/supermelee/pickmele.h	2017-11-21 19:40:01 -0600
@@ -24,6 +24,10 @@ typedef struct getmelee_struct GETMELEE_
 #include "meleesetup.h"
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 void MeleeShipDeath (STARSHIP *);
 void BuildPickMeleeFrame (void);
 void DestroyPickMeleeFrame (void);
@@ -41,12 +45,20 @@ BOOLEAN selectShipComputer (ComputerInpu
 BOOLEAN selectShipNetwork (NetworkInputContext *context, GETMELEE_STATE *gms);
 #endif  /* NETPLAY */
 
+#if defined(__cplusplus)
+}
+#endif
+
 #ifdef PICKMELE_INTERNAL
 
 #include "../flash.h"
 #include "libs/timelib.h"
 #include "../init.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 struct getmelee_struct {
 	BOOLEAN (*InputFunc) (struct getmelee_struct *pInputState);
 
@@ -80,6 +92,10 @@ struct getmelee_struct {
 bool setShipSelected(GETMELEE_STATE *gms, COUNT playerI, COUNT choice,
 		bool reportNetwork);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* PICKMELE_INTERNAL */
 
 #endif  /* _PICKMELE_H */
diff -ruNp src.orig/uqm/tactrans.c src/uqm/tactrans.c
--- src.orig/uqm/tactrans.c	2017-11-21 19:39:44 -0600
+++ src/uqm/tactrans.c	2017-11-21 19:40:01 -0600
@@ -47,6 +47,8 @@ static void cleanup_dead_ship (ELEMENT *
 
 static BOOLEAN dittyIsPlaying;
 static STARSHIP *winnerStarShip;
+		// Indicates which ship is the winner of the current battle.
+		// The winner will be last to pick the next ship.
 
 
 BOOLEAN
@@ -471,9 +473,6 @@ new_ship (ELEMENT *DeadShipPtr)
 		SetElementStarShip (DeadShipPtr, 0);
 		RestartMusic = OpponentAlive (DeadStarShipPtr);
 
-		if (DeadStarShipPtr->RaceDescPtr->uninit_func != NULL)
-			(*DeadStarShipPtr->RaceDescPtr->uninit_func) (
-					DeadStarShipPtr->RaceDescPtr);
 		free_ship (DeadStarShipPtr->RaceDescPtr, TRUE, TRUE);
 		DeadStarShipPtr->RaceDescPtr = 0;
 		
@@ -617,38 +616,37 @@ explosion_preprocess (ELEMENT *ShipPtr)
 }
 
 void
-ship_death (ELEMENT *ShipPtr)
+StopAllBattleMusic (void)
 {
-	STARSHIP *StarShipPtr;
-	STARSHIP *VictoriousStarShipPtr;
-	HELEMENT hElement, hNextElement;
-	ELEMENT *ElementPtr;
-
 	StopDitty ();
 	StopMusic ();
+}
 
-	GetElementStarShip (ShipPtr, &StarShipPtr);
-
-	if (ShipPtr->mass_points <= MAX_SHIP_MASS)
-	{	// Not running away and not reincarnating (Pkunk)
-		// When a ship tries to run away, it is (dis)counted in DoRunAway(),
-		// so when it dies while running away, we will not count it again
-		assert (StarShipPtr->playerNr >= 0);
-		battle_counter[StarShipPtr->playerNr]--;
-	}
+STARSHIP *
+FindAliveStarShip (ELEMENT *deadShip)
+{
+	STARSHIP *aliveShip = NULL;
+	HELEMENT hElement, hNextElement;
 
-	VictoriousStarShipPtr = NULL;
+	// Find the remaining ship, if any, and see if it is still alive.
 	for (hElement = GetHeadElement (); hElement; hElement = hNextElement)
 	{
+		ELEMENT *ElementPtr;
+
 		LockElement (hElement, &ElementPtr);
 		if ((ElementPtr->state_flags & PLAYER_SHIP)
-				&& ElementPtr != ShipPtr
+				&& ElementPtr != deadShip
 						/* and not running away */
-				&& ElementPtr->mass_points <= MAX_SHIP_MASS)
+				&& ElementPtr->mass_points <= MAX_SHIP_MASS + 1)
 		{
-			GetElementStarShip (ElementPtr, &VictoriousStarShipPtr);
-			if (VictoriousStarShipPtr->RaceDescPtr->ship_info.crew_level == 0)
-				VictoriousStarShipPtr = NULL;
+			GetElementStarShip (ElementPtr, &aliveShip);
+			assert (aliveShip != NULL);
+			if (aliveShip->RaceDescPtr->ship_info.crew_level == 0
+					/* reincarnating Pkunk is not actually dead */
+					&& ElementPtr->mass_points != MAX_SHIP_MASS + 1)
+			{
+				aliveShip = NULL;
+			}
 
 			UnlockElement (hElement);
 			break;
@@ -656,8 +654,59 @@ ship_death (ELEMENT *ShipPtr)
 		hNextElement = GetSuccElement (ElementPtr);
 		UnlockElement (hElement);
 	}
+	
+	return aliveShip;
+}
 
-	StarShipPtr->cur_status_flags &= ~PLAY_VICTORY_DITTY;
+STARSHIP *
+GetWinnerStarShip (void)
+{
+	return winnerStarShip;
+}
+
+void
+SetWinnerStarShip (STARSHIP *winner)
+{
+	if (winner == NULL)
+		return; // nothing to do
+	
+	winner->cur_status_flags |= PLAY_VICTORY_DITTY;
+
+	// The winner is set once per battle. If both ships die, this function is
+	// called twice, once for each ship. We need to preserve the winner
+	// determined on the first call.
+	if (winnerStarShip == NULL)
+		winnerStarShip = winner;
+}
+
+void
+RecordShipDeath (ELEMENT *deadShip)
+{
+	STARSHIP *deadStarShip;
+
+	GetElementStarShip (deadShip, &deadStarShip);
+	assert (deadStarShip != NULL);
+
+	if (deadShip->mass_points <= MAX_SHIP_MASS)
+	{	// Not running away.
+		// When a ship tries to run away, it is (dis)counted in DoRunAway(),
+		// so when it dies while running away, we will not count it again
+		assert (deadStarShip->playerNr >= 0);
+		battle_counter[deadStarShip->playerNr]--;
+	}
+
+	if (LOBYTE (GLOBAL (CurrentActivity)) == SUPER_MELEE)
+		MeleeShipDeath (deadStarShip);
+}
+
+void
+StartShipExplosion (ELEMENT *ShipPtr, bool playSound)
+{
+	STARSHIP *StarShipPtr;
+
+	GetElementStarShip (ShipPtr, &StarShipPtr);
+
+	ZeroVelocityComponents (&ShipPtr->velocity);
 
 	DeltaEnergy (ShipPtr,
 			-(SIZE)StarShipPtr->RaceDescPtr->ship_info.energy_level);
@@ -665,43 +714,38 @@ ship_death (ELEMENT *ShipPtr)
 	ShipPtr->life_span = NUM_EXPLOSION_FRAMES * 3;
 	ShipPtr->state_flags &= ~DISAPPEARING;
 	ShipPtr->state_flags |= FINITE_LIFE | NONSOLID;
+	ShipPtr->preprocess_func = explosion_preprocess;
 	ShipPtr->postprocess_func = PostProcessStatus;
 	ShipPtr->death_func = cleanup_dead_ship;
 	ShipPtr->hTarget = 0;
-	ZeroVelocityComponents (&ShipPtr->velocity);
-	if (ShipPtr->crew_level) /* only happens for shofixti self-destruct */
-	{
-		PlaySound (SetAbsSoundIndex (
-				StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 1),
-				CalcSoundPosition (ShipPtr), ShipPtr,
-				GAME_SOUND_PRIORITY + 1);
 
-		DeltaCrew (ShipPtr, -(SIZE)ShipPtr->crew_level);
-		if (VictoriousStarShipPtr == NULL)
-		{	// No ships left alive after a Shofixti Glory device,
-			// thus Shofixti wins
-			VictoriousStarShipPtr = StarShipPtr;
-		}
-	}
-	else
+	if (playSound)
 	{
-		ShipPtr->preprocess_func = explosion_preprocess;
-
 		PlaySound (SetAbsSoundIndex (GameSounds, SHIP_EXPLODES),
 				CalcSoundPosition (ShipPtr), ShipPtr, GAME_SOUND_PRIORITY + 1);
 	}
+}
 
-	if (VictoriousStarShipPtr != NULL)
-		VictoriousStarShipPtr->cur_status_flags |= PLAY_VICTORY_DITTY;
+void
+ship_death (ELEMENT *ShipPtr)
+{
+	STARSHIP *StarShipPtr;
+	STARSHIP *winner;
 
-	// The winner is set once per battle. If both ships die, this function is
-	// called twice, once for each ship. We need to preserve the winner
-	// determined on the first call.
-	if (winnerStarShip == NULL)
-		winnerStarShip = VictoriousStarShipPtr;
+	GetElementStarShip (ShipPtr, &StarShipPtr);
 
-	if (LOBYTE (GLOBAL (CurrentActivity)) == SUPER_MELEE)
-		MeleeShipDeath (StarShipPtr);
+	StopAllBattleMusic ();
+
+	// If the winning ship dies before the ditty starts, do not play it.
+	// e.g. a ship can die after the opponent begins exploding but
+	// before the explosion is over.
+	StarShipPtr->cur_status_flags &= ~PLAY_VICTORY_DITTY;
+
+	StartShipExplosion (ShipPtr, true);
+
+	winner = FindAliveStarShip (ShipPtr);
+	SetWinnerStarShip (winner);
+	RecordShipDeath (ShipPtr);
 }
 
 #define START_ION_COLOR BUILD_COLOR (MAKE_RGB15 (0x1F, 0x15, 0x00), 0x7A)
diff -ruNp src.orig/uqm/tactrans.h src/uqm/tactrans.h
--- src.orig/uqm/tactrans.h	2017-11-21 19:39:44 -0600
+++ src/uqm/tactrans.h	2017-11-21 19:40:01 -0600
@@ -24,6 +24,10 @@
 #include "element.h"
 #include "battlecontrols.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 bool battleEndReadyHuman (HumanInputContext *context);
 bool battleEndReadyComputer (ComputerInputContext *context);
 #ifdef NETPLAY
@@ -39,6 +43,16 @@ extern void flee_preprocess (ELEMENT *El
 
 extern void StopDitty (void);
 extern void ResetWinnerStarShip (void);
+extern void StopAllBattleMusic (void);
+extern STARSHIP* FindAliveStarShip (ELEMENT *deadShip);
+extern STARSHIP* GetWinnerStarShip (void);
+extern void SetWinnerStarShip (STARSHIP *winner);
+extern void RecordShipDeath (ELEMENT *deadShip);
+extern void StartShipExplosion (ELEMENT *ShipPtr, bool playSound);
+
+#if defined(__cplusplus)
+}
+#endif
 
 #endif  /* _TACTRANS_H */
 
diff -ruNp src.orig/uqm/units.h src/uqm/units.h
--- src.orig/uqm/units.h	2017-11-21 19:39:44 -0600
+++ src/uqm/units.h	2017-11-21 19:40:01 -0600
@@ -21,6 +21,10 @@
 
 #include "libs/gfxlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern int ScreenWidth;
 extern int ScreenHeight;
 
@@ -216,5 +220,10 @@ extern COUNT ARCTAN (SIZE delta_x, SIZE
 #define WRAP_DELTA_Y(dy) ((dy)<0 ? \
 				((-(dy)<=LOG_SPACE_HEIGHT>>1)?(dy):(LOG_SPACE_HEIGHT+(dy))) : \
 				(((dy)<=LOG_SPACE_HEIGHT>>1)?(dy):((dy)-LOG_SPACE_HEIGHT)))
+
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _UNITS_H */
 
diff -ruNp src.orig/uqm/uqmdebug.c src/uqm/uqmdebug.c
--- src.orig/uqm/uqmdebug.c	2017-11-21 19:39:44 -0600
+++ src/uqm/uqmdebug.c	2017-11-21 19:40:01 -0600
@@ -22,7 +22,7 @@
 #include "colors.h"
 #include "controls.h"
 #include "clock.h"
-#include "encount.h"
+#include "starmap.h"
 #include "element.h"
 #include "sis.h"
 #include "status.h"
@@ -36,6 +36,7 @@
 #include "setup.h"
 #include "state.h"
 #include "libs/mathlib.h"
+#include "lua/luadebug.h"
 
 #include <stdio.h>
 #include <errno.h>
@@ -72,11 +73,12 @@ static void dumpPlanetTypeCallback (int
 BOOLEAN instantMove = FALSE;
 BOOLEAN disableInteractivity = FALSE;
 void (* volatile debugHook) (void) = NULL;
-void (* volatile doInputDebugHook) (void) = NULL;
 
 
+// Must be called on the Starcon2Main thread.
+// This function is called synchronously wrt the game logic thread.
 void
-debugKeyPressed (void)
+debugKeyPressedSynchronous (void)
 {
 	// State modifying:
 	equipShip ();
@@ -85,18 +87,18 @@ debugKeyPressed (void)
 	// Give the player the ships you can't ally with under normal
 	// conditions.
 	clearEscorts ();
-	ActivateStarShip (ARILOU_SHIP, 1);
-	ActivateStarShip (PKUNK_SHIP, 1);
-	ActivateStarShip (VUX_SHIP, 1);
-	ActivateStarShip (YEHAT_SHIP, 1);
-	ActivateStarShip (MELNORME_SHIP, 1);
-	ActivateStarShip (DRUUGE_SHIP, 1);
-	ActivateStarShip (ILWRATH_SHIP, 1);
-	ActivateStarShip (MYCON_SHIP, 1);
-	ActivateStarShip (SLYLANDRO_SHIP, 1);
-	ActivateStarShip (UMGAH_SHIP, 1);
-	ActivateStarShip (URQUAN_SHIP, 1);
-	ActivateStarShip (BLACK_URQUAN_SHIP, 1);
+	AddEscortShips (ARILOU_SHIP, 1);
+	AddEscortShips (PKUNK_SHIP, 1);
+	AddEscortShips (VUX_SHIP, 1);
+	AddEscortShips (YEHAT_SHIP, 1);
+	AddEscortShips (MELNORME_SHIP, 1);
+	AddEscortShips (DRUUGE_SHIP, 1);
+	AddEscortShips (ILWRATH_SHIP, 1);
+	AddEscortShips (MYCON_SHIP, 1);
+	AddEscortShips (SLYLANDRO_SHIP, 1);
+	AddEscortShips (UMGAH_SHIP, 1);
+	AddEscortShips (URQUAN_SHIP, 1);
+	AddEscortShips (BLACK_URQUAN_SHIP, 1);
 
 	resetCrewBattle ();
 	resetEnergyBattle ();
@@ -107,36 +109,48 @@ debugKeyPressed (void)
 //	SET_GAME_STATE (MELNORME_CREDIT1, 100);
 //	GLOBAL_SIS (ResUnits) = 100000;
 
+	// Informational:
+//	dumpEvents (stderr);
+
+	// Graphical and textual:
+//	debugContexts();
+}
+
+// Can be called on any thread, but usually on main()
+// This function is called asynchronously wrt the game logic thread,
+// which means locking applies. Use carefully.
+// TODO: Once game logic thread is purged of graphics and clock locks,
+//   this function may not call graphics and game clock functions at all.
+void
+debugKeyPressed (void)
+{
 	// Tests
 //	Scale_PerfTest ();
 
 	// Informational:
 //	dumpStrings (stdout);
-//	dumpEvents (stderr);
 //	dumpPlanetTypes(stderr);
 //	debugHook = dumpUniverseToFile;
 			// This will cause dumpUniverseToFile to be called from the
-			// main loop. Calling it from here would give threading
+			// Starcon2Main loop. Calling it from here would give threading
 			// problems.
 //	debugHook = tallyResourcesToFile;
 			// This will cause tallyResourcesToFile to be called from the
-			// main loop. Calling it from here would give threading
+			// Starcon2Main loop. Calling it from here would give threading
 			// problems.
 
-	// Graphical and textual:
-	//doInputDebugHook = debugContexts;
-			// This will cause debugContexts to be called from the
-			// Starcon2Main thread, from DoInput(). Calling it from here
-			// would give threading problems.
-
 	// Interactive:
 //	uio_debugInteractive(stdin, stdout, stderr);
+//	luaUqm_debug_run();
 }
 
 ////////////////////////////////////////////////////////////////////////////
 
 // Fast forwards to the next event.
 // If skipHEE is set, HYPERSPACE_ENCOUNTER_EVENTs are skipped.
+// Must be called from the Starcon2Main thread.
+// TODO: LockGameClock may be removed since it is only
+//   supposed to be called synchronously wrt the game logic thread.
 void
 forwardToNextEvent (BOOLEAN skipHEE)
 {
@@ -149,9 +163,6 @@ forwardToNextEvent (BOOLEAN skipHEE)
 	if (!GameClockRunning ())
 		return;
 
-	// Must hold GraphicsLock for MoveGameClockDays()
-	// Must acquire GraphicsLock *before* the game clock lock
-	LockMutex (GraphicsLock);
 	LockGameClock ();
 
 	done = !skipHEE;
@@ -180,7 +191,6 @@ forwardToNextEvent (BOOLEAN skipHEE)
 	} while (!done);
 
 	UnlockGameClock ();
-	UnlockMutex (GraphicsLock);
 }
 
 const char *
@@ -361,12 +371,10 @@ equipShip (void)
 	}
 
 	// Make sure everything is redrawn:
-	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE ||
+	if (inHQSpace () ||
 			LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY)
 	{
-		LockMutex (GraphicsLock);
 		DeltaSISGauges (UNDEFINED_DELTA, UNDEFINED_DELTA, UNDEFINED_DELTA);
-		UnlockMutex (GraphicsLock);
 	}
 }
 
@@ -423,9 +431,7 @@ clearEscorts (void)
 		FreeShipFrag (&GLOBAL (built_ship_q), hStarShip);
 	}
 
-	LockMutex (GraphicsLock);
 	DeltaSISGauges (UNDEFINED_DELTA, UNDEFINED_DELTA, UNDEFINED_DELTA);
-	UnlockMutex (GraphicsLock);
 }
 
 ////////////////////////////////////////////////////////////////////////////
@@ -596,6 +602,8 @@ forAllMoons (STAR_DESC *star, SOLARSYS_S
 
 ////////////////////////////////////////////////////////////////////////////
 
+// Must be called from the Starcon2Main thread.
+// TODO: LockGameClock may be removed
 void
 UniverseRecurse (UniverseRecurseArg *universeRecurseArg)
 {
@@ -627,15 +635,14 @@ starRecurse (STAR_DESC *star, void *arg)
 
 	SOLARSYS_STATE SolarSysState;
 	SOLARSYS_STATE *oldPSolarSysState = pSolarSysState;
-	DWORD oldSeed =
-			TFB_SeedRandom (MAKE_DWORD (star->star_pt.x, star->star_pt.y));
-
 	STAR_DESC *oldStarDescPtr = CurStarDescPtr;
 	CurStarDescPtr = star;
 
+	RandomContext_SeedRandom (SysGenRNG, GetRandomSeedForStar (star));
+
 	memset (&SolarSysState, 0, sizeof (SolarSysState));
 	SolarSysState.SunDesc[0].pPrevDesc = 0;
-	SolarSysState.SunDesc[0].rand_seed = TFB_Random ();
+	SolarSysState.SunDesc[0].rand_seed = RandomContext_Random (SysGenRNG);
 	SolarSysState.SunDesc[0].data_index = STAR_TYPE (star->Type);
 	SolarSysState.SunDesc[0].location.x = 0;
 	SolarSysState.SunDesc[0].location.y = 0;
@@ -667,7 +674,6 @@ starRecurse (STAR_DESC *star, void *arg)
 	
 	pSolarSysState = oldPSolarSysState;
 	CurStarDescPtr = oldStarDescPtr;
-	TFB_SeedRandom (oldSeed);
 }
 
 static void
@@ -695,14 +701,12 @@ planetRecurse (STAR_DESC *star, SOLARSYS
 
 	if (universeRecurseArg->moonFunc != NULL)
 	{
-		DWORD oldSeed = TFB_SeedRandom (planet->rand_seed);
+		RandomContext_SeedRandom (SysGenRNG, planet->rand_seed);
 		
 		(*system->genFuncs->generateMoons) (system, planet);
 
 		forAllMoons (star, system, planet, moonRecurse,
 				(void *) universeRecurseArg);
-
-		TFB_SeedRandom (oldSeed);
 	}
 	
 	if (universeRecurseArg->planetFuncPost != NULL)
@@ -732,10 +736,13 @@ moonRecurse (STAR_DESC *star, SOLARSYS_S
 	if (universeRecurseArg->moonFunc != NULL)
 	{
 		system->pOrbitalDesc = moon;
-		DoPlanetaryAnalysis (&system->SysInfo, moon);
+		if (moon->data_index != HIERARCHY_STARBASE && moon->data_index != SA_MATRA)
+		{
+			DoPlanetaryAnalysis (&system->SysInfo, moon);
 				// When GenerateDefaultFunctions is used as genFuncs,
 				// generateOrbital will also call DoPlanetaryAnalysis,
 				// but with other GenerateFunctions this is not guaranteed.
+		}
 		(*system->genFuncs->generateOrbital) (system, moon);
 		(*universeRecurseArg->moonFunc) (
 				moon, universeRecurseArg->arg);
@@ -749,6 +756,7 @@ typedef struct
 	FILE *out;
 } DumpUniverseArg;
 
+// Must be called from the Starcon2Main thread.
 void
 dumpUniverse (FILE *out)
 {
@@ -767,7 +775,7 @@ dumpUniverse (FILE *out)
 	UniverseRecurse (&universeRecurseArg);
 }
 
-// Must be called from the main thread.
+// Must be called from the Starcon2Main thread.
 void
 dumpUniverseToFile (void)
 {
@@ -977,8 +985,7 @@ dumpPlanetCallback (const PLANET_DESC *p
 void
 dumpPlanet (FILE *out, const PLANET_DESC *planet)
 {
-	(*pSolarSysState->genFuncs->generateName) (
-			pSolarSysState, (PLANET_DESC *) planet);
+	(*pSolarSysState->genFuncs->generateName) (pSolarSysState, planet);
 	fprintf (out, "- %-37s  %s\n", GLOBAL_SIS (PlanetName),
 			planetTypeString (planet->data_index & ~PLANET_SHIELDED));
 	dumpWorld (out, planet);
@@ -1059,16 +1066,16 @@ calculateBioValue (const SOLARSYS_STATE
 
 	assert (system->pOrbitalDesc == world);
 	
-	numBio = callGenerateForScanType ((SOLARSYS_STATE *) system,
-			(PLANET_DESC *) world, ~0, BIOLOGICAL_SCAN);
+	numBio = callGenerateForScanType (system, world, GENERATE_ALL,
+			BIOLOGICAL_SCAN, NULL);
 
 	result = 0;
 	for (i = 0; i < numBio; i++)
 	{
-		callGenerateForScanType ((SOLARSYS_STATE *) system,
-				(PLANET_DESC *) world, i, BIOLOGICAL_SCAN);
-		result += BIO_CREDIT_VALUE * LONIBBLE (CreatureData[
-				system->SysInfo.PlanetInfo.CurType].ValueAndHitPoints);
+		NODE_INFO info;
+		callGenerateForScanType (system, world, i, BIOLOGICAL_SCAN, &info);
+		result += BIO_CREDIT_VALUE *
+				LONIBBLE (CreatureData[info.type].ValueAndHitPoints);
 	}
 	return result;
 }
@@ -1082,17 +1089,17 @@ generateBioIndex(const SOLARSYS_STATE *s
 
 	assert (system->pOrbitalDesc == world);
 	
-	numBio = callGenerateForScanType ((SOLARSYS_STATE *) system,
-			(PLANET_DESC *) world, ~0, BIOLOGICAL_SCAN);
+	numBio = callGenerateForScanType (system, world, GENERATE_ALL,
+			BIOLOGICAL_SCAN, NULL);
 
 	for (i = 0; i < NUM_CREATURE_TYPES + NUM_SPECIAL_CREATURE_TYPES; i++)
 		bio[i] = 0;
 	
 	for (i = 0; i < numBio; i++)
 	{
-		callGenerateForScanType ((SOLARSYS_STATE *) system,
-				(PLANET_DESC *) world, i, BIOLOGICAL_SCAN);
-		bio[system->SysInfo.PlanetInfo.CurType]++;
+		NODE_INFO info;
+		callGenerateForScanType (system, world, i, BIOLOGICAL_SCAN, &info);
+		bio[info.type]++;
 	}
 }
 
@@ -1105,17 +1112,16 @@ calculateMineralValue (const SOLARSYS_ST
 
 	assert (system->pOrbitalDesc == world);
 	
-	numDeposits = callGenerateForScanType ((SOLARSYS_STATE *) system,
-			(PLANET_DESC *) world, ~0, MINERAL_SCAN);
+	numDeposits = callGenerateForScanType (system, world, GENERATE_ALL,
+			MINERAL_SCAN, NULL);
 
 	result = 0;
 	for (i = 0; i < numDeposits; i++)
 	{
-		callGenerateForScanType ((SOLARSYS_STATE *) system,
-				(PLANET_DESC *) world, i, MINERAL_SCAN);
-		result += HIBYTE (system->SysInfo.PlanetInfo.CurDensity) *
-				GLOBAL (ElementWorth[ElementCategory (
-				system->SysInfo.PlanetInfo.CurType)]);
+		NODE_INFO info;
+		callGenerateForScanType (system, world, i, MINERAL_SCAN, &info);
+		result += HIBYTE (info.density) *
+				GLOBAL (ElementWorth[ElementCategory (info.type)]);
 	}
 	return result;
 }
@@ -1129,18 +1135,17 @@ generateMineralIndex(const SOLARSYS_STAT
 
 	assert (system->pOrbitalDesc == world);
 	
-	numDeposits = callGenerateForScanType ((SOLARSYS_STATE *) system,
-			(PLANET_DESC *) world, ~0, MINERAL_SCAN);
+	numDeposits = callGenerateForScanType (system, world, GENERATE_ALL,
+			MINERAL_SCAN, NULL);
 
 	for (i = 0; i < NUM_ELEMENT_CATEGORIES; i++)
 		minerals[i] = 0;
 	
 	for (i = 0; i < numDeposits; i++)
 	{
-		callGenerateForScanType ((SOLARSYS_STATE *) system,
-				(PLANET_DESC *) world, i, MINERAL_SCAN);
-		minerals[ElementCategory(system->SysInfo.PlanetInfo.CurType)] +=
-				HIBYTE (system->SysInfo.PlanetInfo.CurDensity);
+		NODE_INFO info;
+		callGenerateForScanType (system, world, i, MINERAL_SCAN, &info);
+		minerals[ElementCategory (info.type)] += HIBYTE (info.density);
 	}
 }
 
@@ -1153,6 +1158,7 @@ struct TallyResourcesArg
 	COUNT bioCount;
 };
 
+// Must be called from the Starcon2Main thread.
 void
 tallyResources (FILE *out)
 {
@@ -1171,7 +1177,7 @@ tallyResources (FILE *out)
 	UniverseRecurse (&universeRecurseArg);
 }
 
-// Must be called from the main thread.
+// Must be called from the Starcon2Main thread.
 void
 tallyResourcesToFile (void)
 {
@@ -1504,7 +1510,7 @@ resetCrewBattle (void)
 	CONTEXT OldContext;
 	
 	if (!(GLOBAL (CurrentActivity) & IN_BATTLE) ||
-			(LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE))
+			(inHQSpace ()))
 		return;
 	
 	StarShipPtr = findPlayerShip (RPG_PLAYER_NUM);
@@ -1527,7 +1533,7 @@ resetEnergyBattle (void)
 	CONTEXT OldContext;
 	
 	if (!(GLOBAL (CurrentActivity) & IN_BATTLE) ||
-			(LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE))
+			(inHQSpace ()))
 		return;
 	
 	StarShipPtr = findPlayerShip (RPG_PLAYER_NUM);
@@ -1853,16 +1859,13 @@ debugContexts (void)
 		return;
 	inDebugContexts = true;
 
-	LockMutex (GraphicsLock);
 	contextCount = countVisibleContexts ();
 	if (contextCount == 0)
 	{
-		UnlockMutex (GraphicsLock);
 		goto out;
 	}
 	
 	savedScreen = getScreen ();
-	//UnlockMutex (GraphicsLock);
 	FlushGraphics ();
 			// Make sure that the screen has actually been captured,
 			// before we use the frame.
@@ -1876,7 +1879,6 @@ debugContexts (void)
 
 	hueIncrement = 360.0 / contextCount;
 
-	//LockMutex (GraphicsLock);
 	visibleContextI = 0;
 	for (context = GetFirstContext (); context != NULL;
 			context = GetNextContext (context))
@@ -1898,7 +1900,6 @@ debugContexts (void)
 
 	// Blit the final debugging frame to the screen.
 	putScreen (debugDrawFrame);
-	UnlockMutex (GraphicsLock);
 
 	// Wait for a key:
 	{
@@ -1907,9 +1908,7 @@ debugContexts (void)
 		DoInput(&state, TRUE);
 	}
 
-	LockMutex (GraphicsLock);
 	SetContext (orgContext);
-	UnlockMutex (GraphicsLock);
 
 	// Destroy the debugging frame and context.
 	DestroyContext (debugDrawContext);
@@ -1917,9 +1916,7 @@ debugContexts (void)
 			// SetContextFGFrame().
 	DestroyDrawable (ReleaseDrawable (debugDrawFrame));
 	
-	LockMutex (GraphicsLock);
 	putScreen (savedScreen);
-	UnlockMutex (GraphicsLock);
 
 	DestroyDrawable (ReleaseDrawable (savedScreen));
 
diff -ruNp src.orig/uqm/uqmdebug.h src/uqm/uqmdebug.h
--- src.orig/uqm/uqmdebug.h	2017-11-21 19:39:44 -0600
+++ src/uqm/uqmdebug.h	2017-11-21 19:40:01 -0600
@@ -33,19 +33,19 @@ extern BOOLEAN disableInteractivity;
 // Starcon2Main thread, in the main game loop.
 extern void (* volatile debugHook) (void);
 
-// If a function is assigned to this, it will be called from the
-// Starcon2Main thread, in doInput().
-extern void (* volatile doInputDebugHook) (void);
-
-
-// Called when the debug key (symbol 'Debug' in the keys.cfg) is pressed.
+// Called on the main() thread when the debug key (symbol 'Debug' in the
+// keys.cfg) is pressed
 void debugKeyPressed (void);
+// Called on the Starcon2Main() thread when the debug key (symbol 'Debug'
+// in the keys.cfg) is pressed.
+void debugKeyPressedSynchronous (void);
 
 // Forward time to the next event. If skipHEE is set, the event named
 // HYPERSPACE_ENCOUNTER_EVENT, which normally occurs every game day,
-// is skipped.
+// is skipped. Must be called on the Starcon2Main thread.
 void forwardToNextEvent (BOOLEAN skipHEE);
 // Generate a list of all events in the event queue.
+// Must be called on the Starcon2Main thread.
 void dumpEvents (FILE *out);
 // Describe one event.
 void dumpEvent (FILE *out, const EVENT *eventPtr);
@@ -102,11 +102,13 @@ typedef struct
 			// User data.
 } UniverseRecurseArg;
 // Recurse through all systems, planets, and moons in the universe.
+// Must be called on the Starcon2Main thread.
 void UniverseRecurse (UniverseRecurseArg *universeRecurseArg);
 
-// Describe the entire universe.
+// Describe the entire universe. Must be called on the Starcon2Main thread.
 void dumpUniverse (FILE *out);
 // Describe the entire universe, output to a file "./PlanetInfo".
+// Must be called on the Starcon2Main thread.
 void dumpUniverseToFile (void);
 // Describe one star system.
 void dumpSystem (FILE *out, const STAR_DESC *star,
@@ -137,9 +139,10 @@ void generateBioIndex(const SOLARSYS_STA
 		const PLANET_DESC *world, COUNT bio[]);
 
 // Tally the resources for each star system.
+// Must be called on the Starcon2Main thread.
 void tallyResources (FILE *out);
 // Tally the resources for each star system, output to a file
-// "./ResourceTally".
+// "./ResourceTally". Must be called on the Starcon2Main thread.
 void tallyResourcesToFile (void);
 
 
@@ -186,7 +189,7 @@ void dumpStrings(FILE *out);
 
 
 // Graphically and textually show all the contexts.
-// Should be called from debugHook.
+// Must be called on the Starcon2Main thread.
 void debugContexts (void);
 
 
diff -ruNp src.orig/uqm/util.c src/uqm/util.c
--- src.orig/uqm/util.c	2017-11-21 19:39:44 -0600
+++ src/uqm/util.c	2017-11-21 19:40:01 -0600
@@ -152,7 +152,6 @@ PauseGame (void)
 	if (PlayingTrack ())
 		PauseTrack ();
 
-	LockMutex (GraphicsLock);
 	OldContext = SetContext (ScreenContext);
 	oldOrigin = SetContextOrigin (MAKE_POINT (0, 0));
 	GetContextClipRect (&OldRect);
@@ -170,11 +169,7 @@ PauseGame (void)
 	SetSystemRect (&r);
 	DrawStamp (&s);
 
-	// It is safer to just not release the lock so any graphics tasks
-	// would be blocked
-	//UnlockMutex (GraphicsLock);
 	FlushGraphics ();
-	//LockMutex (GraphicsLock);
 
 	while (ImmediateInputState.menu[KEY_PAUSE] && GamePaused)
 	{
@@ -209,7 +204,6 @@ PauseGame (void)
 	if (PlayingTrack ())
 		ResumeTrack ();
 
-	UnlockMutex (GraphicsLock);
 
 	TaskSwitch ();
 	GLOBAL (CurrentActivity) &= ~CHECK_PAUSE;
@@ -300,7 +294,6 @@ SleepGame (void)
 		PauseTrack ();
 	PauseMusic ();
 
-	LockMutex (GraphicsLock);
 
 	while (!GameActive && !QuitPosted)
 		SleepThread (ONE_SECOND / 2);
@@ -314,7 +307,6 @@ SleepGame (void)
 	if (PlayingTrack ())
 		ResumeTrack ();
 
-	UnlockMutex (GraphicsLock);
 
 	TaskSwitch ();
 }
diff -ruNp src.orig/uqm/util.h src/uqm/util.h
--- src.orig/uqm/util.h	2017-11-21 19:39:44 -0600
+++ src/uqm/util.h	2017-11-21 19:40:01 -0600
@@ -20,6 +20,10 @@
 #include "libs/compiler.h"
 #include "libs/gfxlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern void DrawStarConBox (RECT *pRect, SIZE BorderWidth,
 		Color TopLeftColor, Color BottomRightColor, BOOLEAN FillInterior,
 		Color InteriorColor);
@@ -28,5 +32,9 @@ extern DWORD SeedRandomNumbers (void);
 // saveRect can be NULL to save the entire context frame
 extern STAMP SaveContextFrame (const RECT *saveRect);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _UTIL_H */
 
diff -ruNp src.orig/uqm/velocity.h src/uqm/velocity.h
--- src.orig/uqm/velocity.h	2017-11-21 19:39:44 -0600
+++ src/uqm/velocity.h	2017-11-21 19:40:01 -0600
@@ -22,6 +22,10 @@
 #include <string.h> /* for memset */
 #include "libs/gfxlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef struct velocity_desc
 {
 	COUNT TravelAngle;
@@ -45,7 +49,7 @@ extern void SetVelocityComponents (VELOC
 extern void DeltaVelocityComponents (VELOCITY_DESC *velocityptr, SIZE dx,
 		SIZE dy);
 
-static inline BOOLEAN
+static inline bool
 IsVelocityZero (VELOCITY_DESC *vptr)
 {
 	return vptr->vector.width == 0 && vptr->vector.height == 0 &&
@@ -65,5 +69,9 @@ VelocitySquared (SIZE dx, SIZE dy)
 #define VELOCITY_TO_WORLD(v) ((v)>>VELOCITY_SHIFT)
 #define WORLD_TO_VELOCITY(l) ((l)<<VELOCITY_SHIFT)
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _VELOCITY_H */
 
diff -ruNp src.orig/uqm/weapon.c src/uqm/weapon.c
--- src.orig/uqm/weapon.c	2017-11-21 19:39:44 -0600
+++ src/uqm/weapon.c	2017-11-21 19:40:01 -0600
@@ -31,6 +31,15 @@
 
 #include <stdio.h>
 
+// A wrapper function for weapon_collision that discards the return value.
+// This makes its signature match ElementCollisionFunc.
+static void
+weapon_collision_cb (ELEMENT *WeaponElementPtr, POINT *pWPt,
+		ELEMENT *HitElementPtr, POINT *pHPt)
+{
+	weapon_collision (WeaponElementPtr, pWPt, HitElementPtr, pHPt);
+}
+
 
 HELEMENT
 initialize_laser (LASER_BLOCK *pLaserBlock)
@@ -50,7 +59,7 @@ initialize_laser (LASER_BLOCK *pLaserBlo
 		LaserElementPtr->state_flags = APPEARING | FINITE_LIFE
 				| pLaserBlock->flags;
 		LaserElementPtr->life_span = LASER_LIFE;
-		LaserElementPtr->collision_func = (CollisionFunc*)weapon_collision;
+		LaserElementPtr->collision_func = weapon_collision_cb;
 		LaserElementPtr->blast_offset = 1;
 
 		LaserElementPtr->current.location.x = pLaserBlock->cx
@@ -100,7 +109,7 @@ initialize_missile (MISSILE_BLOCK *pMiss
 				SetAbsFrameIndex (pMissileBlock->farray[0],
 				pMissileBlock->index);
 		MissileElementPtr->preprocess_func = pMissileBlock->preprocess_func;
-		MissileElementPtr->collision_func = (CollisionFunc*)weapon_collision;
+		MissileElementPtr->collision_func = weapon_collision_cb;
 		MissileElementPtr->blast_offset = (BYTE)pMissileBlock->blast_offs;
 
 		angle = FACING_TO_ANGLE (pMissileBlock->face);
diff -ruNp src.orig/uqm/weapon.h src/uqm/weapon.h
--- src.orig/uqm/weapon.h	2017-11-21 19:39:44 -0600
+++ src/uqm/weapon.h	2017-11-21 19:40:01 -0600
@@ -22,6 +22,10 @@
 #include "element.h"
 #include "libs/gfxlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef struct
 {
 	COORD cx, cy, ex, ey;
@@ -57,5 +61,9 @@ extern void Untarget (ELEMENT *ElementPt
 extern FRAME ModifySilhouette (ELEMENT *ElementPtr, STAMP *modify_stamp,
 		BYTE modify_flags);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _WEAPON_H */
 
diff -ruNp src.orig/uqm.c src/uqm.c
--- src.orig/uqm.c	2017-11-21 19:39:44 -0600
+++ src/uqm.c	2017-11-21 19:40:01 -0600
@@ -27,12 +27,14 @@
 #endif
 
 #include <stdarg.h>
+#include <errno.h>
 #include "libs/graphics/gfx_common.h"
 #include "libs/graphics/cmap.h"
 #include "libs/sound/sound.h"
 #include "libs/input/input_common.h"
 #include "libs/inplib.h"
 #include "libs/tasklib.h"
+#include "libs/scriptlib.h"
 #include "uqm/controls.h"
 #include "uqm/battle.h"
 		// For BATTLE_FRAME_RATE
@@ -114,6 +116,7 @@ struct options_struct
 	DECL_CONFIG_OPTION(int, soundQuality);
 	DECL_CONFIG_OPTION(bool, use3doMusic);
 	DECL_CONFIG_OPTION(bool, useRemixMusic);
+	DECL_CONFIG_OPTION(bool, useSpeech);
 	DECL_CONFIG_OPTION(int, whichCoarseScan);
 	DECL_CONFIG_OPTION(int, whichMenu);
 	DECL_CONFIG_OPTION(int, whichFonts);
@@ -242,11 +245,12 @@ main (int argc, char *argv[])
 		INIT_CONFIG_OPTION(  scaler,            0 ),
 		INIT_CONFIG_OPTION(  showFps,           false ),
 		INIT_CONFIG_OPTION(  keepAspectRatio,   false ),
-		INIT_CONFIG_OPTION(  gamma,             0.0f ),
+		INIT_CONFIG_OPTION(  gamma,             1.0f ),
 		INIT_CONFIG_OPTION(  soundDriver,       audio_DRIVER_MIXSDL ),
 		INIT_CONFIG_OPTION(  soundQuality,      audio_QUALITY_MEDIUM ),
 		INIT_CONFIG_OPTION(  use3doMusic,       true ),
 		INIT_CONFIG_OPTION(  useRemixMusic,     false ),
+		INIT_CONFIG_OPTION(  useSpeech,         true ),
 		INIT_CONFIG_OPTION(  whichCoarseScan,   OPT_PC ),
 		INIT_CONFIG_OPTION(  whichMenu,         OPT_PC ),
 		INIT_CONFIG_OPTION(  whichFonts,        OPT_PC ),
@@ -277,7 +281,11 @@ main (int argc, char *argv[])
 	if (options.logFile != NULL)
 	{
 		int i;
-		freopen (options.logFile, "w", stderr);
+		if (!freopen (options.logFile, "w", stderr))
+		{
+			printf ("Error %d calling freopen() on stderr\n", errno);
+			return EXIT_FAILURE;
+		}
 #ifdef UNBUFFERED_LOGFILE
 		setbuf (stderr, NULL);
 #endif
@@ -368,6 +376,7 @@ main (int argc, char *argv[])
 	// Fill in global variables:
 	opt3doMusic = options.use3doMusic.value;
 	optRemixMusic = options.useRemixMusic.value;
+	optSpeech = options.useSpeech.value;
 	optWhichCoarseScan = options.whichCoarseScan.value;
 	optWhichMenu = options.whichMenu.value;
 	optWhichFonts = options.whichFonts.value;
@@ -393,17 +402,17 @@ main (int argc, char *argv[])
 
 	InitTimeSystem ();
 	InitTaskSystem ();
+	
+	luaUqm_init ();
 
-#ifdef NETPLAY
-	Network_init ();
 	Alarm_init ();
 	Callback_init ();
+
+#ifdef NETPLAY
+	Network_init ();
 	NetManager_init ();
 #endif
 
-	GraphicsLock = CreateMutex ("Graphics",
-			SYNC_CLASS_TOPLEVEL | SYNC_CLASS_VIDEO);
-
 	gfxDriver = options.opengl.value ?
 			TFB_GFXDRIVER_SDL_OPENGL : TFB_GFXDRIVER_SDL_PURE;
 	gfxFlags = options.scaler.value;
@@ -415,8 +424,11 @@ main (int argc, char *argv[])
 		gfxFlags |= TFB_GFXFLAGS_SHOWFPS;
 	TFB_InitGraphics (gfxDriver, gfxFlags, options.resolution.width,
 			options.resolution.height);
-	if (options.gamma.set)
-		TFB_SetGamma (options.gamma.value);
+	if (options.gamma.set && setGammaCorrection (options.gamma.value))
+		optGamma = options.gamma.value;
+	else
+		optGamma = 1.0f; // failed or default
+	
 	InitColorMaps ();
 	init_communication ();
 	/* TODO: Once threading is gone, restore initAudio here.
@@ -441,7 +453,7 @@ main (int argc, char *argv[])
 		}
 		else if (!GameActive)
 		{	// Throttle down the main loop when game is inactive
-			SleepThread (ONE_SECOND / 4);
+			HibernateThread (ONE_SECOND / 4);
 		}
 
 		TFB_ProcessEvents ();
@@ -455,27 +467,37 @@ main (int argc, char *argv[])
 	 *   tasks might still be using it */
 	if (MainExited)
 	{
-		// Not yet: TFB_UninitInput ();
+		TFB_UninitInput ();
 		unInitAudio ();
 		uninit_communication ();
+		
+		TFB_PurgeDanglingGraphics ();
+		// Purge above refers to colormaps which have to be still up
 		UninitColorMaps ();
-		// Not yet: TFB_UninitGraphics ();
+		TFB_UninitGraphics ();
 
 #ifdef NETPLAY
 		NetManager_uninit ();
-		Alarm_uninit ();
 		Network_uninit ();
 #endif
 
-		// Not yet: CleanupTaskSystem ();
+		Callback_uninit ();
+		Alarm_uninit ();
+		
+		luaUqm_uninit ();
+
+		CleanupTaskSystem ();
 		UnInitTimeSystem ();
 #if 0
 		unInitTempDir ();
 #endif
+		unprepareAllDirs ();
 		uninitIO ();
 		UnInitThreadSystem ();
 		mem_uninit ();
 	}
+
+	HFree (options.addons);
 	
 	return EXIT_SUCCESS;
 }
@@ -554,6 +576,25 @@ getVolumeConfigValue (struct float_optio
 	option->set = true;
 }
 
+static void
+getGammaConfigValue (struct float_option *option, const char *config_val)
+{
+	int val;
+
+	if (option->set || !res_IsInteger (config_val))
+		return;
+
+	val = res_GetInteger (config_val);
+	// gamma config option is a fixed-point number
+	// ignore ridiculously out-of-range values
+	if (val < (int)(0.03 * GAMMA_SCALE) || val > (int)(9.9 * GAMMA_SCALE))
+		return;
+	option->value = val / (float)GAMMA_SCALE;
+	// avoid setting gamma when not necessary
+	if (option->value != 1.0f)
+		option->set = true;
+}
+
 static bool
 getListConfigValue (struct int_option *option, const char *config_val,
 		const struct option_list_value *list)
@@ -602,6 +643,7 @@ getUserConfigOptions (struct options_str
 	getBoolConfigValue (&options->scanlines, "config.scanlines");
 	getBoolConfigValue (&options->showFps, "config.showfps");
 	getBoolConfigValue (&options->keepAspectRatio, "config.keepaspectratio");
+	getGammaConfigValue (&options->gamma, "config.gamma");
 
 	getBoolConfigValue (&options->subtitles, "config.subtitles");
 	
@@ -620,19 +662,13 @@ getUserConfigOptions (struct options_str
 
 	getBoolConfigValue (&options->use3doMusic, "config.3domusic");
 	getBoolConfigValue (&options->useRemixMusic, "config.remixmusic");
+	getBoolConfigValue (&options->useSpeech, "config.speech");
 
 	getBoolConfigValueXlat (&options->meleeScale, "config.smoothmelee",
 			TFB_SCALE_TRILINEAR, TFB_SCALE_STEP);
 
-	if (getListConfigValue (&options->soundDriver, "config.audiodriver",
-			audioDriverList))
-	{
-		// XXX: I don't know if we should turn speech off in this case.
-		//   This affects which version of the alien script will be used.
-		if (options->soundDriver.value == audio_DRIVER_NOSOUND)
-			options->speechVolumeScale.value = 0.0f;
-	}
-	
+	getListConfigValue (&options->soundDriver, "config.audiodriver",
+			audioDriverList);
 	getListConfigValue (&options->soundQuality, "config.audioquality",
 			audioQualityList);
 	getBoolConfigValue (&options->stereoSFX, "config.positionalsfx");
@@ -687,7 +723,7 @@ enum
 #endif
 };
 
-static const char *optString = "+r:foc:b:spC:n:?hM:S:T:m:q:ug:l:i:vwxk";
+static const char *optString = "+r:foc:b:spC:n:?hM:S:T:q:ug:l:i:vwxk";
 static struct option longOptions[] = 
 {
 	{"res", 1, NULL, 'r'},
@@ -971,17 +1007,9 @@ parseOptions (int argc, char *argv[], st
 				}
 				break;
 			case SOUND_OPT:
-				if (setListOption (&options->soundDriver, optarg,
+				if (!setListOption (&options->soundDriver, optarg,
 						audioDriverList))
 				{
-					// XXX: I don't know if we should turn speech off in
-					//   this case. This affects which version of the alien
-					//   script will be used.
-					if (options->soundDriver.value == audio_DRIVER_NOSOUND)
-						options->speechVolumeScale.value = 0.0f;
-				}
-				else
-				{
 					InvalidArgument (optarg, "--sound");
 					badArg = true;
 				}
@@ -1013,7 +1041,7 @@ parseOptions (int argc, char *argv[], st
 				}
 				break;
 			}
-	                case SAFEMODE_OPT:
+			case SAFEMODE_OPT:
 				setBoolOption (&options->safeMode, true);
 				break;
 #ifdef NETPLAY
@@ -1239,3 +1267,4 @@ boolNotOptString (const struct bool_opti
 {
 	return option->value ? "off" : "on";
 }
+
diff -ruNp src.orig/uqmversion.h src/uqmversion.h
--- src.orig/uqmversion.h	2017-11-21 19:39:44 -0600
+++ src/uqmversion.h	2017-11-21 19:40:01 -0600
@@ -33,6 +33,4 @@
 		UQM_MAJOR_VERSION_S "." UQM_MINOR_VERSION_S "." UQM_PATCH_VERSION_S \
 		UQM_EXTRA_VERSION
 
-#define UQM_SVN_REVISION "$Revision: 3628 $"
-
 #endif
