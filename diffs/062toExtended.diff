diff -ruNp src.orig/Makeinfo src/Makeinfo
--- src.orig/Makeinfo	2017-11-08 16:49:22 -0600
+++ src/Makeinfo	2017-11-08 16:49:50 -0600
@@ -1,4 +1,9 @@
-uqm_SUBDIRS="sc2code getopt res"
+uqm_SUBDIRS="sc2code res"
+
+if [ "$uqm_HAVE_GETOPT_LONG" = 0 ]; then
+	uqm_SUBDIRS="$uqm_SUBDIRS getopt"
+fi
+
 case "$HOST_SYSTEM" in
 	Darwin)
 		uqm_SUBDIRS="$uqm_SUBDIRS darwin"
diff -ruNp src.orig/config.h src/config.h
--- src.orig/config.h	2017-11-08 16:49:22 -0600
+++ src/config.h	2017-11-08 16:49:49 -0600
@@ -7,9 +7,11 @@
 	 * If you want anything else than the defaults, you'll have to edit
 	 * that file manually. */
 #	include "msvc++/config.h"
+#elif defined(__SYMBIAN32__)
+#	include "symbian/config.h"
 #elif defined (__MINGW32__) || defined (__CYGWIN__)
 	/* If we're compiling on MS Windows using build.sh, use
-	 * config_win.h, generated from * src/config_win.h.in. */
+	 * config_win.h, generated from src/config_win.h.in. */
 #	include "config_win.h"
 #else
 	/* If we're compiling in unix, use config_unix.h, generated from
diff -ruNp src.orig/config_unix.h.in src/config_unix.h.in
--- src.orig/config_unix.h.in	2017-11-08 16:49:22 -0600
+++ src/config_unix.h.in	2017-11-08 16:49:49 -0600
@@ -37,6 +37,10 @@
 /* Defined if your system has strupr of its own */
 @HAVE_STRUPR@
 
+/* Defined if your system has strcasecmp of its own */
+@HAVE_STRCASECMP_UQM@
+		// Not using "HAVE_STRCASECMP" as that conflicts with SDL.
+
 /* Defined if your system has stricmp of its own */
 @HAVE_STRICMP@
 
@@ -52,6 +56,8 @@
 /* Defined if your system has wint_t of its own */
 @HAVE_WINT_T@
 
-#endif  /* _CONFIG_UNIX_H */
+/* Defined if your system has _Bool of its own */
+@HAVE__BOOL@
 
+#endif  /* _CONFIG_UNIX_H */
 
diff -ruNp src.orig/config_win.h.in src/config_win.h.in
--- src.orig/config_win.h.in	2017-11-08 16:49:22 -0600
+++ src/config_win.h.in	2017-11-08 16:49:49 -0600
@@ -38,6 +38,10 @@
 /* Defined if your system has strupr of its own */
 @HAVE_STRUPR@
 
+/* Defined if your system has strcasecmp of its own */
+@HAVE_STRCASECMP_UQM@
+		// Not using "HAVE_STRCASECMP" as that conflicts with SDL.
+
 /* Defined if your system has stricmp of its own */
 @HAVE_STRICMP@
 
@@ -53,6 +57,9 @@
 /* Defined if your system has wint_t of its own */
 @HAVE_WINT_T@
 
+/* Defined if your system has _Bool of its own */
+@HAVE__BOOL@
+
 #endif  /* _CONFIG_WIN_H */
 
 
diff -ruNp src.orig/getopt/getopt.c src/getopt/getopt.c
--- src.orig/getopt/getopt.c	2017-11-08 16:49:22 -0600
+++ src/getopt/getopt.c	2017-11-08 16:49:50 -0600
@@ -28,6 +28,7 @@
 #endif
 
 #include <config.h>
+#include <string.h>
 
 #ifndef HAVE_GETOPT_LONG
 #if !defined __STDC__ || !__STDC__
diff -ruNp src.orig/msvc++/UrQuanMasters.dsp src/msvc++/UrQuanMasters.dsp
--- src.orig/msvc++/UrQuanMasters.dsp	2017-11-08 16:49:22 -0600
+++ src/msvc++/UrQuanMasters.dsp	2017-11-08 16:49:50 -0600
@@ -44,7 +44,7 @@ RSC=rc.exe
 # PROP Ignore_Export_Lib 0
 # PROP Target_Dir ""
 # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
-# ADD CPP /nologo /MD /W3 /GX /Zi /O2 /I "." /I ".." /I "..\sc2code" /I "..\sc2code\libs" /I "..\sc2code\ships" /I "..\regex" /D "NDEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D _VW=320 /D _VH=240 /D "HAVE_OPENGL" /D "GFXMODULE_SDL" /D "HAVE_OPENAL" /D "HAVE_ZIP" /D "HAVE_JOYSTICK" /D "NETPLAY" /D "ZLIB_DLL" /D "USE_INTERNAL_MIKMOD" /D "USE_PLATFORM_ACCEL" /FD /c
+# ADD CPP /nologo /MD /W3 /GX /Zi /O2 /I "." /I ".." /I "..\sc2code" /I "..\sc2code\libs" /I "..\sc2code\ships" /I "..\regex" /D "NDEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D _VW=320 /D _VH=240 /D "HAVE_OPENGL" /D "GFXMODULE_SDL" /D "THREADLIB_SDL" /D "HAVE_OPENAL" /D "HAVE_ZIP" /D "HAVE_JOYSTICK" /D "NETPLAY" /D "ZLIB_DLL" /D "USE_INTERNAL_MIKMOD" /D "USE_PLATFORM_ACCEL" /FD /c
 # SUBTRACT CPP /YX
 # ADD BASE RSC /l 0x409 /d "NDEBUG"
 # ADD RSC /l 0x409 /d "NDEBUG"
@@ -74,7 +74,7 @@ PostBuild_Cmds=rebase -b 0x400000 -x . "
 # PROP Ignore_Export_Lib 0
 # PROP Target_Dir ""
 # ADD BASE CPP /nologo /W3 /GX /Zi /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
-# ADD CPP /nologo /MDd /W3 /GX /Zi /Od /I "." /I ".." /I "..\sc2code" /I "..\sc2code\libs" /I "..\sc2code\ships" /I "..\regex" /D "DEBUG" /D "_DEBUG" /D "DEBUG_TRACK_SEM" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D _VW=320 /D _VH=240 /D "HAVE_OPENGL" /D "GFXMODULE_SDL" /D "HAVE_OPENAL" /D "HAVE_ZIP" /D "HAVE_JOYSTICK" /D "NETPLAY" /D "ZLIB_DLL" /D "USE_INTERNAL_MIKMOD" /D "USE_PLATFORM_ACCEL" /FR /FD /GZ /c
+# ADD CPP /nologo /MDd /W3 /GX /Zi /Od /I "." /I ".." /I "..\sc2code" /I "..\sc2code\libs" /I "..\sc2code\ships" /I "..\regex" /D "DEBUG" /D "_DEBUG" /D "DEBUG_TRACK_SEM" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D _VW=320 /D _VH=240 /D "HAVE_OPENGL" /D "GFXMODULE_SDL" /D "THREADLIB_SDL" /D "HAVE_OPENAL" /D "HAVE_ZIP" /D "HAVE_JOYSTICK" /D "NETPLAY" /D "ZLIB_DLL" /D "USE_INTERNAL_MIKMOD" /D "USE_PLATFORM_ACCEL" /FR /FD /GZ /c
 # SUBTRACT CPP /YX
 # ADD BASE RSC /l 0x409 /d "_DEBUG"
 # ADD RSC /l 0x409 /d "_DEBUG"
@@ -100,9 +100,9 @@ LINK32=link.exe
 # PROP Intermediate_Dir "Debug_NoAccel"
 # PROP Ignore_Export_Lib 0
 # PROP Target_Dir ""
-# ADD BASE CPP /nologo /MDd /W3 /GX /Zi /Od /I "." /I ".." /I "..\sc2code" /I "..\sc2code\libs" /I "..\sc2code\ships" /I "..\regex" /D "DEBUG" /D "_DEBUG" /D "DEBUG_TRACK_SEM" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D _VW=320 /D _VH=240 /D "HAVE_OPENGL" /D "GFXMODULE_SDL" /D "HAVE_OPENAL" /D "HAVE_ZIP" /D "ZLIB_DLL" /D "USE_PLATFORM_ACCEL" /FR /FD /GZ /c
+# ADD BASE CPP /nologo /MDd /W3 /GX /Zi /Od /I "." /I ".." /I "..\sc2code" /I "..\sc2code\libs" /I "..\sc2code\ships" /I "..\regex" /D "DEBUG" /D "_DEBUG" /D "DEBUG_TRACK_SEM" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D _VW=320 /D _VH=240 /D "HAVE_OPENGL" /D "GFXMODULE_SDL" /D "THREADLIB_SDL" /D "HAVE_OPENAL" /D "HAVE_ZIP" /D "ZLIB_DLL" /D "USE_PLATFORM_ACCEL" /FR /FD /GZ /c
 # SUBTRACT BASE CPP /YX
-# ADD CPP /nologo /MDd /W3 /GX /Zi /Od /I "." /I ".." /I "..\sc2code" /I "..\sc2code\libs" /I "..\sc2code\ships" /I "..\regex" /D "DEBUG" /D "_DEBUG" /D "DEBUG_TRACK_SEM" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D _VW=320 /D _VH=240 /D "HAVE_OPENGL" /D "GFXMODULE_SDL" /D "HAVE_OPENAL" /D "HAVE_ZIP" /D "HAVE_JOYSTICK" /D "NETPLAY" /D "ZLIB_DLL" /D "USE_INTERNAL_MIKMOD" /FR /FD /GZ /c
+# ADD CPP /nologo /MDd /W3 /GX /Zi /Od /I "." /I ".." /I "..\sc2code" /I "..\sc2code\libs" /I "..\sc2code\ships" /I "..\regex" /D "DEBUG" /D "_DEBUG" /D "DEBUG_TRACK_SEM" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D _VW=320 /D _VH=240 /D "HAVE_OPENGL" /D "GFXMODULE_SDL" /D "THREADLIB_SDL" /D "HAVE_OPENAL" /D "HAVE_ZIP" /D "HAVE_JOYSTICK" /D "NETPLAY" /D "ZLIB_DLL" /D "USE_INTERNAL_MIKMOD" /FR /FD /GZ /c
 # SUBTRACT CPP /YX
 # ADD BASE RSC /l 0x409 /d "_DEBUG"
 # ADD RSC /l 0x409 /d "_DEBUG"
@@ -128,9 +128,9 @@ LINK32=link.exe
 # PROP Intermediate_Dir "Release_NoAccel"
 # PROP Ignore_Export_Lib 0
 # PROP Target_Dir ""
-# ADD BASE CPP /nologo /MD /W3 /GX /Zi /O2 /I "." /I ".." /I "..\sc2code" /I "..\sc2code\libs" /I "..\sc2code\ships" /I "..\regex" /D "NDEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D _VW=320 /D _VH=240 /D "HAVE_OPENGL" /D "GFXMODULE_SDL" /D "HAVE_OPENAL" /D "HAVE_ZIP" /D "ZLIB_DLL" /D "USE_PLATFORM_ACCEL" /FD /c
+# ADD BASE CPP /nologo /MD /W3 /GX /Zi /O2 /I "." /I ".." /I "..\sc2code" /I "..\sc2code\libs" /I "..\sc2code\ships" /I "..\regex" /D "NDEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D _VW=320 /D _VH=240 /D "HAVE_OPENGL" /D "GFXMODULE_SDL" /D "THREADLIB_SDL" /D "HAVE_OPENAL" /D "HAVE_ZIP" /D "ZLIB_DLL" /D "USE_PLATFORM_ACCEL" /FD /c
 # SUBTRACT BASE CPP /YX
-# ADD CPP /nologo /MD /W3 /GX /Zi /O2 /I "." /I ".." /I "..\sc2code" /I "..\sc2code\libs" /I "..\sc2code\ships" /I "..\regex" /D "NDEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D _VW=320 /D _VH=240 /D "HAVE_OPENGL" /D "GFXMODULE_SDL" /D "HAVE_OPENAL" /D "HAVE_ZIP" /D "HAVE_JOYSTICK" /D "NETPLAY" /D "ZLIB_DLL" /D "USE_INTERNAL_MIKMOD" /FR /FD /c
+# ADD CPP /nologo /MD /W3 /GX /Zi /O2 /I "." /I ".." /I "..\sc2code" /I "..\sc2code\libs" /I "..\sc2code\ships" /I "..\regex" /D "NDEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D _VW=320 /D _VH=240 /D "HAVE_OPENGL" /D "GFXMODULE_SDL" /D "THREADLIB_SDL" /D "HAVE_OPENAL" /D "HAVE_ZIP" /D "HAVE_JOYSTICK" /D "NETPLAY" /D "ZLIB_DLL" /D "USE_INTERNAL_MIKMOD" /FR /FD /c
 # SUBTRACT CPP /YX
 # ADD BASE RSC /l 0x409 /d "NDEBUG"
 # ADD RSC /l 0x409 /d "NDEBUG"
@@ -262,10 +262,6 @@ SOURCE=..\sc2code\libs\file\files.c
 
 SOURCE=..\sc2code\libs\file\filintrn.h
 # End Source File
-# Begin Source File
-
-SOURCE=..\sc2code\libs\file\temp.c
-# End Source File
 # End Group
 # Begin Group "graphics"
 
@@ -632,28 +628,36 @@ SOURCE=..\sc2code\libs\math\random.h
 # End Source File
 # Begin Source File
 
+SOURCE=..\sc2code\libs\math\random2.c
+# End Source File
+# Begin Source File
+
 SOURCE=..\sc2code\libs\math\sqrt.c
 # End Source File
 # End Group
-# Begin Group "memory"
+# Begin Group "md5"
 
 # PROP Default_Filter ""
 # Begin Source File
 
-SOURCE=..\sc2code\libs\memory\w_memlib.c
+SOURCE=..\sc2code\libs\md5\md5.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\sc2code\libs\md5\md5.h
 # End Source File
 # End Group
-# Begin Group "resource"
+# Begin Group "memory"
 
 # PROP Default_Filter ""
 # Begin Source File
 
-SOURCE=..\sc2code\libs\resource\alist.c
+SOURCE=..\sc2code\libs\memory\w_memlib.c
 # End Source File
-# Begin Source File
+# End Group
+# Begin Group "resource"
 
-SOURCE=..\sc2code\libs\resource\alist.h
-# End Source File
+# PROP Default_Filter ""
 # Begin Source File
 
 SOURCE=..\sc2code\libs\resource\direct.c
@@ -680,6 +684,14 @@ SOURCE=..\sc2code\libs\resource\mapres.c
 # End Source File
 # Begin Source File
 
+SOURCE=..\sc2code\libs\resource\propfile.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\sc2code\libs\resource\propfile.h
+# End Source File
+# Begin Source File
+
 SOURCE=..\sc2code\libs\resource\resdata.c
 # End Source File
 # Begin Source File
@@ -719,6 +731,14 @@ SOURCE=..\sc2code\libs\sound\openal\audi
 # PROP Default_Filter ""
 # Begin Source File
 
+SOURCE=..\sc2code\libs\sound\decoders\aiffaud.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\sc2code\libs\sound\decoders\aiffaud.h
+# End Source File
+# Begin Source File
+
 SOURCE=..\sc2code\libs\sound\decoders\decoder.c
 # End Source File
 # Begin Source File
@@ -896,6 +916,10 @@ SOURCE=..\sc2code\libs\video\dukvid.h
 # End Source File
 # Begin Source File
 
+SOURCE=..\sc2code\libs\video\legacyplayer.c
+# End Source File
+# Begin Source File
+
 SOURCE=..\sc2code\libs\video\vfileins.c
 # End Source File
 # Begin Source File
@@ -916,12 +940,20 @@ SOURCE=..\sc2code\libs\video\videodec.h
 # End Source File
 # Begin Source File
 
+SOURCE=..\sc2code\libs\video\vidintrn.h
+# End Source File
+# Begin Source File
+
 SOURCE=..\sc2code\libs\video\vidplayer.c
 # End Source File
 # Begin Source File
 
 SOURCE=..\sc2code\libs\video\vidplayer.h
 # End Source File
+# Begin Source File
+
+SOURCE=..\sc2code\libs\video\vresins.c
+# End Source File
 # End Group
 # Begin Group "threads"
 
@@ -1064,6 +1096,10 @@ SOURCE=..\sc2code\libs\uio\fstypes.h
 # End Source File
 # Begin Source File
 
+SOURCE=..\sc2code\libs\uio\getint.h
+# End Source File
+# Begin Source File
+
 SOURCE=..\sc2code\libs\uio\gphys.c
 # End Source File
 # Begin Source File
@@ -1332,10 +1368,6 @@ SOURCE=..\sc2code\libs\mikmod\virtch_com
 # Begin Group "network"
 
 # PROP Default_Filter ""
-# Begin Source File
-
-SOURCE=..\sc2code\libs\network\bytesex.h
-# End Source File
 # Begin Group "connect"
 
 # PROP Default_Filter ""
@@ -1364,7 +1396,6 @@ SOURCE=..\sc2code\libs\network\connect\r
 SOURCE=..\sc2code\libs\network\connect\resolve.h
 # End Source File
 # End Group
-
 # Begin Group "netmanager"
 
 # PROP Default_Filter ""
@@ -1382,11 +1413,11 @@ SOURCE=..\sc2code\libs\network\netmanage
 # End Source File
 # Begin Source File
 
-SOURCE=..\sc2code\libs\network\netmanager\netmanager_common.ci
+SOURCE=..\sc2code\libs\network\netmanager\netmanager.h
 # End Source File
 # Begin Source File
 
-SOURCE=..\sc2code\libs\network\netmanager\netmanager.h
+SOURCE=..\sc2code\libs\network\netmanager\netmanager_common.ci
 # End Source File
 # Begin Source File
 
@@ -1397,50 +1428,51 @@ SOURCE=..\sc2code\libs\network\netmanage
 SOURCE=..\sc2code\libs\network\netmanager\netmanager_win.h
 # End Source File
 # End Group
+# Begin Group "socket"
 
+# PROP Default_Filter ""
 # Begin Source File
 
-SOURCE=..\sc2code\libs\network\netport.c
+SOURCE=..\sc2code\libs\network\socket\socket.c
 # End Source File
 # Begin Source File
 
-SOURCE=..\sc2code\libs\network\netport.h
+SOURCE=..\sc2code\libs\network\socket\socket.h
 # End Source File
 # Begin Source File
 
-SOURCE=..\sc2code\libs\network\network_win.c
+SOURCE=..\sc2code\libs\network\socket\socket_win.c
 # End Source File
 # Begin Source File
 
-SOURCE=..\sc2code\libs\network\network.h
+SOURCE=..\sc2code\libs\network\socket\socket_win.h
 # End Source File
-# Begin Group "socket"
-
-# PROP Default_Filter ""
+# End Group
 # Begin Source File
 
-SOURCE=..\sc2code\libs\network\socket\socket.c
+SOURCE=..\sc2code\libs\network\bytesex.h
 # End Source File
 # Begin Source File
 
-SOURCE=..\sc2code\libs\network\socket\socket.h
+SOURCE=..\sc2code\libs\network\netport.c
 # End Source File
 # Begin Source File
 
-SOURCE=..\sc2code\libs\network\socket\socket_win.c
+SOURCE=..\sc2code\libs\network\netport.h
 # End Source File
 # Begin Source File
 
-SOURCE=..\sc2code\libs\network\socket\socket_win.h
+SOURCE=..\sc2code\libs\network\network.h
 # End Source File
-# End Group
+# Begin Source File
 
+SOURCE=..\sc2code\libs\network\network_win.c
+# End Source File
 # Begin Source File
 
 SOURCE=..\sc2code\libs\network\wspiapiwrap.h
 # End Source File
 # End Group
-
 # Begin Source File
 
 SOURCE=..\sc2code\libs\alarm.h
@@ -1487,6 +1519,10 @@ SOURCE=..\sc2code\libs\mathlib.h
 # End Source File
 # Begin Source File
 
+SOURCE=..\sc2code\libs\md5.h
+# End Source File
+# Begin Source File
+
 SOURCE=..\sc2code\libs\memlib.h
 # End Source File
 # Begin Source File
@@ -2449,16 +2485,36 @@ SOURCE=..\sc2code\comm\commall.h
 # Begin Group "netplay"
 
 # PROP Default_Filter ""
+# Begin Group "proto"
+
+# PROP Default_Filter ""
 # Begin Source File
 
-SOURCE=..\sc2code\netplay\checksum.c
+SOURCE=..\sc2code\netplay\proto\npconfirm.c
 # End Source File
 # Begin Source File
 
-SOURCE=..\sc2code\netplay\checksum.h
+SOURCE=..\sc2code\netplay\proto\npconfirm.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\sc2code\netplay\proto\ready.c
 # End Source File
 # Begin Source File
 
+SOURCE=..\sc2code\netplay\proto\ready.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\sc2code\netplay\proto\reset.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\sc2code\netplay\proto\reset.h
+# End Source File
+# End Group
+# Begin Source File
+
 SOURCE=..\sc2code\netplay\checkbuf.c
 # End Source File
 # Begin Source File
@@ -2467,6 +2523,14 @@ SOURCE=..\sc2code\netplay\checkbuf.h
 # End Source File
 # Begin Source File
 
+SOURCE=..\sc2code\netplay\checksum.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\sc2code\netplay\checksum.h
+# End Source File
+# Begin Source File
+
 SOURCE=..\sc2code\netplay\crc.c
 # End Source File
 # Begin Source File
@@ -2495,27 +2559,27 @@ SOURCE=..\sc2code\netplay\netinput.h
 # End Source File
 # Begin Source File
 
-SOURCE=..\sc2code\netplay\netoptions.c
+SOURCE=..\sc2code\netplay\netmelee.c
 # End Source File
 # Begin Source File
 
-SOURCE=..\sc2code\netplay\netoptions.h
+SOURCE=..\sc2code\netplay\netmelee.h
 # End Source File
 # Begin Source File
 
-SOURCE=..\sc2code\netplay\netmelee.c
+SOURCE=..\sc2code\netplay\netmisc.c
 # End Source File
 # Begin Source File
 
-SOURCE=..\sc2code\netplay\netmelee.h
+SOURCE=..\sc2code\netplay\netmisc.h
 # End Source File
 # Begin Source File
 
-SOURCE=..\sc2code\netplay\netmisc.c
+SOURCE=..\sc2code\netplay\netoptions.c
 # End Source File
 # Begin Source File
 
-SOURCE=..\sc2code\netplay\netmisc.h
+SOURCE=..\sc2code\netplay\netoptions.h
 # End Source File
 # Begin Source File
 
@@ -2571,50 +2635,21 @@ SOURCE=..\sc2code\netplay\packethandlers
 # End Source File
 # Begin Source File
 
-SOURCE=..\sc2code\netplay\packetsenders.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\sc2code\netplay\packetsenders.h
-# End Source File
-# Begin Source File
-
 SOURCE=..\sc2code\netplay\packetq.c
 # End Source File
 # Begin Source File
 
 SOURCE=..\sc2code\netplay\packetq.h
 # End Source File
-# Begin Group "proto"
-
-# PROP Default_Filter ""
-# Begin Source File
-
-SOURCE=..\sc2code\netplay\proto\npconfirm.c
-# End Source File
 # Begin Source File
 
-SOURCE=..\sc2code\netplay\proto\npconfirm.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\sc2code\netplay\proto\ready.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\sc2code\netplay\proto\ready.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\sc2code\netplay\proto\reset.c
+SOURCE=..\sc2code\netplay\packetsenders.c
 # End Source File
 # Begin Source File
 
-SOURCE=..\sc2code\netplay\proto\reset.h
+SOURCE=..\sc2code\netplay\packetsenders.h
 # End Source File
 # End Group
-
-# End Group
 # Begin Group "planets"
 
 # PROP Default_Filter ""
@@ -3837,6 +3872,14 @@ SOURCE=..\sc2code\battle.h
 # End Source File
 # Begin Source File
 
+SOURCE=..\sc2code\battlecontrols.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\sc2code\battlecontrols.h
+# End Source File
+# Begin Source File
+
 SOURCE=..\sc2code\border.c
 # End Source File
 # Begin Source File
@@ -3913,6 +3956,14 @@ SOURCE=..\sc2code\confirm.c
 # End Source File
 # Begin Source File
 
+SOURCE=..\sc2code\cons_res.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\sc2code\cons_res.h
+# End Source File
+# Begin Source File
+
 SOURCE=..\sc2code\controls.h
 # End Source File
 # Begin Source File
@@ -3957,6 +4008,14 @@ SOURCE=..\sc2code\encount.h
 # End Source File
 # Begin Source File
 
+SOURCE=..\sc2code\flash.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\sc2code\flash.h
+# End Source File
+# Begin Source File
+
 SOURCE=..\sc2code\fmv.c
 # End Source File
 # Begin Source File
@@ -4013,11 +4072,11 @@ SOURCE=..\sc2code\gravity.c
 # End Source File
 # Begin Source File
 
-SOURCE=..\sc2code\gravwell.c
+SOURCE=..\sc2code\grpinfo.c
 # End Source File
 # Begin Source File
 
-SOURCE=..\sc2code\grpinfo.c
+SOURCE=..\sc2code\grpinfo.h
 # End Source File
 # Begin Source File
 
@@ -4081,6 +4140,14 @@ SOURCE=..\sc2code\load.h
 # End Source File
 # Begin Source File
 
+SOURCE=..\sc2code\loadmele.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\sc2code\loadmele.h
+# End Source File
+# Begin Source File
+
 SOURCE=..\sc2code\loadship.c
 # End Source File
 # Begin Source File
@@ -4113,10 +4180,6 @@ SOURCE=..\sc2code\misc.c
 # End Source File
 # Begin Source File
 
-SOURCE=..\sc2code\mouse_err.c
-# End Source File
-# Begin Source File
-
 SOURCE=..\sc2code\nameref.h
 # End Source File
 # Begin Source File
@@ -4277,6 +4340,10 @@ SOURCE=..\sc2code\tactrans.c
 # End Source File
 # Begin Source File
 
+SOURCE=..\sc2code\tactrans.h
+# End Source File
+# Begin Source File
+
 SOURCE=..\sc2code\trans.c
 # End Source File
 # Begin Source File
diff -ruNp src.orig/msvc++/config.h src/msvc++/config.h
--- src.orig/msvc++/config.h	2017-11-08 16:49:22 -0600
+++ src/msvc++/config.h	2017-11-08 16:49:50 -0600
@@ -38,6 +38,10 @@
 /* Defined if your system has strupr of its own */
 #define HAVE_STRUPR
 
+/* Defined if your system has strcasecmp of its own */
+#undef HAVE_STRCASECMP_UQM
+		// Not using "HAVE_STRCASECMP" as that conflicts with SDL.
+
 /* Defined if your system has stricmp of its own */
 #define HAVE_STRICMP
 
diff -ruNp src.orig/options.c src/options.c
--- src.orig/options.c	2017-11-08 16:49:22 -0600
+++ src/options.c	2017-11-08 16:49:50 -0600
@@ -29,15 +29,19 @@
 #include "libs/uio.h"
 #include "libs/strlib.h"
 #include "libs/log.h"
+#include "libs/reslib.h"
 
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
 #include <errno.h>
 #include <locale.h>
+#ifdef __APPLE__
+#	include <libgen.h>
+			/* for dirname() */
+#endif
 
 
-int optWhichMusic;
 int optWhichCoarseScan;
 int optWhichMenu;
 int optWhichFonts;
@@ -45,9 +49,14 @@ int optWhichIntro;
 int optWhichShield;
 int optSmoothScroll;
 int optMeleeScale;
+float gammaCorrection = 1.0f;
+const char **optAddons;
 
+BOOLEAN opt3doMusic;
+BOOLEAN optPrecursorsMusic;
 BOOLEAN optSubtitles;
 BOOLEAN optStereoSFX;
+BOOLEAN optKeepAspectRatio;
 uio_DirHandle *contentDir;
 uio_DirHandle *configDir;
 uio_DirHandle *saveDir;
@@ -64,10 +73,13 @@ INPUT_TEMPLATE input_templates[6];
 
 static const char *findFileInDirs (const char *locs[], int numLocs,
 		const char *file);
-static void mountContentDir (uio_Repository *repository,
-		const char *contentPath, const char **addons);
+static uio_MountHandle *mountContentDir (uio_Repository *repository,
+		const char *contentPath);
+static void mountAddonDir (uio_Repository *repository,
+		uio_MountHandle *contentMountHandle, const char *addonDirName);
+
 static void mountDirZips (uio_MountHandle *contentHandle,
-		uio_DirHandle *dirHandle);
+		uio_DirHandle *dirHandle, const char *mountPoint);
 
 
 // Looks for a file 'file' in all 'numLocs' locations from 'locs'.
@@ -113,22 +125,41 @@ findFileInDirs (const char *locs[], int
 	return NULL;
 }
 
+// contentDirName is an explicitely specified location for the content,
+// or NULL if none was explicitely specified.
+// execFile is the path to the uqm executable, as acquired through
+// main()'s argv[0].
 void
-prepareContentDir (const char *contentDirName, const char **addons)
+prepareContentDir (const char *contentDirName, const char* addonDirName, const char *execFile)
 {
 	const char *testFile = "version";
 	const char *loc;
+	uio_MountHandle* contentMountHandle;
 
 	if (contentDirName == NULL)
 	{
 		// Try the default content locations.
 		const char *locs[] = {
 			CONTENTDIR, /* defined in config.h */
-			""
+			"",
 			"content",
 			"../../content" /* For running from MSVC */
 		};
 		loc = findFileInDirs (locs, sizeof locs / sizeof locs[0], testFile);
+
+#ifdef __APPLE__
+		/* On OSX, if the content can't be found in any of the static
+		 * locations, attempt to look inside the application bundle,
+		 * by looking relative to the location of the uqm executable. */
+		if (loc == NULL)
+		{
+			char *tempDir = (char *) HMalloc (PATH_MAX);
+			snprintf (tempDir, PATH_MAX, "%s/../Resources/content",
+					dirname (execFile));
+			loc = findFileInDirs ((const char **) &tempDir, 1, testFile);
+			HFree (tempDir);
+		}
+#endif
 	}
 	else
 	{
@@ -141,7 +172,8 @@ prepareContentDir (const char *contentDi
 		exit (EXIT_FAILURE);
 	}
 
-	if (expandPath (baseContentPath, sizeof baseContentPath, loc, EP_ALL_SYSTEM) == -1)
+	if (expandPath (baseContentPath, sizeof baseContentPath, loc,
+			EP_ALL_SYSTEM) == -1)
 	{
 		log_add (log_Fatal, "Fatal error: Could not expand path to content "
 				"directory: %s", strerror (errno));
@@ -149,8 +181,15 @@ prepareContentDir (const char *contentDi
 	}
 	
 	log_add (log_Debug, "Using '%s' as base content dir.", baseContentPath);
+	contentMountHandle = mountContentDir (repository, baseContentPath);
 
-	mountContentDir (repository, baseContentPath, addons);
+	if (addonDirName)
+		log_add (log_Debug, "Using '%s' as addon dir.", addonDirName);
+	mountAddonDir (repository, contentMountHandle, addonDirName);
+
+#ifndef __APPLE__
+	(void) execFile;
+#endif
 }
 
 void
@@ -278,18 +317,17 @@ prepareMeleeDir (void) {
 	}
 }
 
-static void
-mountContentDir (uio_Repository *repository, const char *contentPath,
-		const char **addons) {
-	uio_MountHandle *contentHandle;
-	uio_DirHandle *packagesDir, *addonsDir, *addonDir;
+static uio_MountHandle *
+mountContentDir (uio_Repository *repository, const char *contentPath)
+{
+	uio_DirHandle *packagesDir;
 	static uio_AutoMount *autoMount[] = { NULL };
-	availableAddons = NULL;
+	uio_MountHandle *contentMountHandle;
 
-	contentHandle = uio_mountDir (repository, "/",
+	contentMountHandle = uio_mountDir (repository, "/",
 			uio_FSTYPE_STDIO, NULL, NULL, contentPath, autoMount,
 			uio_MOUNT_TOP | uio_MOUNT_RDONLY, NULL);
-	if (contentHandle == NULL)
+	if (contentMountHandle == NULL)
 	{
 		log_add (log_Fatal, "Fatal error: Could not mount content dir: %s",
 				strerror (errno));
@@ -305,35 +343,56 @@ mountContentDir (uio_Repository *reposit
 	}
 
 	packagesDir = uio_openDir (repository, "/packages", 0);
-	if (packagesDir == NULL)
-	{	// No packages dir means no packages to load.
-		if (addons[0] != NULL)
-		{	// addons were specified, but there's no /packages dir,
-			// let alone a /packages/addons dir.
-			log_add (log_Error, "Warning: There's no 'packages/addons' "
-					"directory in the 'content' directory;\n\t'--addon' "
-					"options are ignored.");
-		}
-		return;
+	if (packagesDir != NULL)
+	{
+		mountDirZips (contentMountHandle, packagesDir, "/");
+		uio_closeDir (packagesDir);	
 	}
 
-	mountDirZips (contentHandle, packagesDir);
+	return contentMountHandle;
+}
+
+static void
+mountAddonDir (uio_Repository *repository, uio_MountHandle *contentMountHandle,
+		const char *addonDirName)
+{
+	uio_DirHandle *addonsDir;
+	static uio_AutoMount *autoMount[] = { NULL };
+	uio_MountHandle *mountHandle;
+
+	availableAddons = NULL;
+
+	if (addonDirName != NULL)
+	{
+		mountHandle = uio_mountDir (repository, "addons",
+				uio_FSTYPE_STDIO, NULL, NULL, addonDirName, autoMount,
+				uio_MOUNT_TOP | uio_MOUNT_RDONLY, NULL);
+		if (mountHandle == NULL)
+		{
+			log_add (log_Warning, "Warning: Could not mount addon directory: %s"
+					";\n\t'--addon' options are ignored.", strerror (errno));
+			return;
+		}
+	}
+	else
+	{
+		mountHandle = contentMountHandle;
+	}
 
 	// NB: note the difference between addonsDir and addonDir.
-	//     the former is the dir 'packages/addons', the latter a directory
+	//     the former is the dir 'addons', the latter a directory
 	//     in that dir.
-	addonsDir = uio_openDirRelative (packagesDir, "addons", 0);
+	addonsDir = uio_openDirRelative (contentDir, "addons", 0);
 	if (addonsDir == NULL)
 	{	// No addon dir found.
-		log_add (log_Error, "Warning: There's no 'packages/addons' "
+		log_add (log_Warning, "Warning: There's no 'addons' "
 				"directory in the 'content' directory;\n\t'--addon' "
 				"options are ignored.");
-		uio_closeDir (packagesDir);
 		return;
 	}
-			
-	uio_closeDir (packagesDir);
 
+	mountDirZips (mountHandle, addonsDir, "addons");
+			
 	availableAddons = uio_getDirList (addonsDir, "", "", match_MATCH_PREFIX);
 	if (availableAddons != NULL)
 	{
@@ -350,8 +409,23 @@ mountContentDir (uio_Repository *reposit
 		}
 		for (i = 0; i < count; i++)
 		{
-			log_add (log_Info, "    %d. %s", i+1,
-				availableAddons->names[i]);
+			static char mountname[128];
+			uio_DirHandle *addonDir;
+			const char *addon = availableAddons->names[i];
+			log_add (log_Info, "    %d. %s", i+1, addon);
+		
+			snprintf(mountname, 128, "addons/%s", addon);
+			mountname[127]=0;
+
+			addonDir = uio_openDirRelative (addonsDir, addon, 0);
+			if (addonDir == NULL)
+			{
+				log_add (log_Warning, "Warning: directory 'addons/%s' "
+					 "not found; addon skipped.", addon);
+				continue;
+			}
+			mountDirZips (mountHandle, addonDir, mountname);
+			uio_closeDir (addonDir);
 		}
 	}
 	else
@@ -359,31 +433,19 @@ mountContentDir (uio_Repository *reposit
 		log_add (log_Info, "0 available addon packs.");
 	}
 
-	for (; *addons != NULL; addons++)
-	{
-		addonDir = uio_openDirRelative (addonsDir, *addons, 0);
-		if (addonDir == NULL)
-		{
-			log_add (log_Error, "Warning: directory 'packages/addons/%s' "
-					"not found; addon skipped.", *addons);
-			continue;
-		}
-		
-		mountDirZips (contentHandle, addonDir);
-
-		uio_closeDir (addonDir);
-	}
+	uio_DirList_free (availableAddons);
+	availableAddons = NULL;
 
 	uio_closeDir (addonsDir);
 }
 
 static void
-mountDirZips (uio_MountHandle *contentHandle, uio_DirHandle *dirHandle)
+mountDirZips (uio_MountHandle *contentHandle, uio_DirHandle *dirHandle, const char *mountPoint)
 {
 	static uio_AutoMount *autoMount[] = { NULL };
 	uio_DirList *dirList;
 
-	dirList = uio_getDirList (dirHandle, "", ".(zip|uqm)$",
+	dirList = uio_getDirList (dirHandle, "", "\\.([zZ][iI][pP]|[uU][qQ][mM])$",
 			match_MATCH_REGEX);
 	if (dirList != NULL)
 	{
@@ -391,12 +453,12 @@ mountDirZips (uio_MountHandle *contentHa
 		
 		for (i = 0; i < dirList->numNames; i++)
 		{
-			if (uio_mountDir (repository, "/", uio_FSTYPE_ZIP,
+			if (uio_mountDir (repository, mountPoint, uio_FSTYPE_ZIP,
 					dirHandle, dirList->names[i], "/", autoMount,
 					uio_MOUNT_BELOW | uio_MOUNT_RDONLY,
 					contentHandle) == NULL)
 			{
-				log_add (log_Error, "Warning: Could not mount '%s': %s.",
+				log_add (log_Warning, "Warning: Could not mount '%s': %s.",
 						dirList->names[i], strerror (errno));
 			}
 		}
@@ -404,3 +466,69 @@ mountDirZips (uio_MountHandle *contentHa
 	uio_DirList_free (dirList);
 }
 
+int
+loadIndices (uio_DirHandle *dir)
+{
+	uio_DirList *indices;
+	int numLoaded = 0;
+
+	indices = uio_getDirList (dir, "", "\\.[rR][mM][pP]$",
+			match_MATCH_REGEX);		
+
+	if (indices != NULL)
+	{
+		int i;
+		
+		for (i = 0; i < indices->numNames; i++)
+		{
+			log_add (log_Debug, "Loading resouce index '%s'", indices->names[i]);
+			LoadResourceIndex (dir, indices->names[i]);
+			numLoaded++;
+		}			
+	}
+	uio_DirList_free (indices);
+	
+	/* Return the number of index files loaded. */
+	return numLoaded;
+}
+
+BOOLEAN
+loadAddon (const char *addon)
+{
+	uio_DirHandle *addonsDir, *addonDir;
+
+	addonsDir = uio_openDirRelative (contentDir, "addons", 0);
+	if (addonsDir == NULL)
+	{
+		// No addon dir found.
+		log_add (log_Warning, "Warning: There's no 'addons' "
+				"directory in the 'content' directory;\n\t'--addon' "
+				"options are ignored.");
+		return FALSE;
+	}
+	addonDir = uio_openDirRelative (addonsDir, addon, 0);
+	if (addonDir == NULL)
+	{
+		log_add (log_Warning, "Warning: Addon '%s' not found", addon);
+		uio_closeDir (addonsDir);
+		return FALSE;
+	}
+
+	loadIndices (addonDir);		
+
+	uio_closeDir (addonDir);
+	uio_closeDir (addonsDir);
+	return TRUE;
+}
+
+void
+prepareAddons (const char **addons)
+{
+	for (; *addons != NULL; addons++)
+	{
+		if (!loadAddon (*addons))
+		{
+			break;
+		}
+	}
+}
diff -ruNp src.orig/options.h src/options.h
--- src.orig/options.h	2017-11-08 16:49:22 -0600
+++ src/options.h	2017-11-08 16:49:50 -0600
@@ -30,7 +30,6 @@
 #define OPT_PC  0x02
 #define OPT_ALL 0xFF
 
-extern int optWhichMusic;
 extern int optWhichCoarseScan;
 extern int optWhichMenu;
 extern int optWhichFonts;
@@ -38,9 +37,13 @@ extern int optWhichIntro;
 extern int optWhichShield;
 extern int optSmoothScroll;
 extern int optMeleeScale;
+extern float gammaCorrection;
 
+extern BOOLEAN opt3doMusic;
+extern BOOLEAN optPrecursorsMusic;
 extern BOOLEAN optSubtitles;
 extern BOOLEAN optStereoSFX;
+extern BOOLEAN optKeepAspectRatio;
 
 extern uio_DirHandle *contentDir;
 extern uio_DirHandle *configDir;
@@ -49,6 +52,7 @@ extern uio_DirHandle *meleeDir;
 extern char baseContentPath[PATH_MAX];
 
 extern uio_DirList *availableAddons;
+extern const char **optAddons;
 
 /* These get edited by TEXTENTRY widgets, so they should have room to
  * hold as much as one of them allows by default. */
@@ -63,10 +67,14 @@ typedef struct _input_template {
 
 extern INPUT_TEMPLATE input_templates[6];
 
-void prepareContentDir (const char *contentDirName, const char **addons);
+void prepareContentDir (const char *contentDirName, const char *addonDirName, const char *execFile);
 void prepareConfigDir (const char *configDirName);
 void prepareMeleeDir (void);
 void prepareSaveDir (void);
+void prepareAddons (const char **addons);
+
+BOOLEAN loadAddon (const char *addon);
+int loadIndices (uio_DirHandle *baseDir);
 
 #endif
 
diff -ruNp src.orig/port.h src/port.h
--- src.orig/port.h	2017-11-08 16:49:22 -0600
+++ src/port.h	2017-11-08 16:49:50 -0600
@@ -12,6 +12,7 @@
 #		define _M_IA64
 #	elif defined(__amd64__)
 #		define _M_AMD64
+#		define _M_X64
 #	elif defined(__m68k__)
 #		define _68K_
 #	elif defined(__ppc__)
@@ -23,6 +24,7 @@
 // Compilation related
 #ifdef _MSC_VER
 #	define inline __inline
+#elif defined(__SYMBIAN32__)
 #else
 #	define inline __inline__
 #	ifdef __MINGW32__
@@ -45,12 +47,20 @@
 #	include <unistd.h>
 #endif
 
-#ifndef HAVE_STRICMP
+// Using "HAVE_STRCASECMP_UQM" instead of "HAVE_STRCASECMP" as the latter
+// conflicts with SDL.
+#if !defined(HAVE_STRICMP) && !defined(HAVE_STRCASECMP_UQM)
+#	error Neither stricmp() nor strcasecmp() is available.
+#elif !defined(HAVE_STRICMP)
 #	define stricmp strcasecmp
-#else
+#elif !defined(HAVE_STRCASECMP_UQM)
 #	define strcasecmp stricmp
+#else
+	// We should take care not to define anything if both strcasecmp() and
+	// stricmp() are defined, as one might exist as a macro to the other.
 #endif
 
+
 #ifndef HAVE_STRUPR
 char *strupr (char *str);
 #endif
@@ -68,6 +78,8 @@ int readdir_r(DIR *dirp, struct dirent *
 		// _MAX_DIR and FILENAME_MAX could also be candidates.
 		// If anyone can tell me which one matches NAME_MAX, please
 		// let me know. - SvdB
+#elif defined(_WIN32_WCE)
+#	include <sys/syslimits.h>
 #else
 #	include <limits.h>
 		/* PATH_MAX is per POSIX defined in <limits.h>, but:
@@ -112,18 +124,9 @@ typedef unsigned short mode_t;
 #	define open _open
 #	define read _read
 //#	define fstat _fstat
-#	define O_ACCMODE (O_RDONLY | O_WRONLY | O_RDWR)
-#	define S_IRWXU (S_IREAD | S_IWRITE | S_IEXEC)
-#	define S_IRWXG 0
-#	define S_IRWXO 0
-#	define S_ISDIR(mode) (((mode) & _S_IFMT) == _S_IFDIR)
-#	define S_ISREG(mode) (((mode) & _S_IFMT) == _S_IFREG)
 #	define write _write
 //#	define stat _stat
 #	define unlink _unlink
-#elif defined (__MINGW32__)
-#	define S_IRWXG 0
-#	define S_IRWXO 0
 #endif
 
 // Memory
@@ -487,5 +490,41 @@ typedef unsigned int wint_t;
 #	define _NORETURN
 #endif
 
+// Buffered vs. unbuffered logfile
+// stderr is normally unbuffered when connected to a terminal, but it
+// will be buffered when connected to a file, when a --logfile argument
+// is passed to uqm.
+// Unbuffered output is slower, which can be significant if much debug output
+// is requested, but after a crash occurs the logfile will still be up to
+// date.
+// On platforms where there is no console, having up-to-date log files
+// after a crash is valuable enough to make the logfile unbuffered by
+// default there.
+#if defined(_WIN32_WCE)
+#	define UNBUFFERED_LOGFILE
+#endif
+
+// Variations in path handling
+#if defined(WIN32) || defined(__SYMBIAN32__)
+	// HAVE_DRIVE_LETTERS is defined to signify that DOS/Windows style drive
+	// letters are to be recognised on this platform.
+#	define HAVE_DRIVE_LETTERS
+	// BACKSLASH_IS_PATH_SEPARATOR is defined to signify that the backslash
+	// character is to be recognised as a path separator on this platform.
+	// This does not affect the acceptance of forward slashes as path
+	// separators.
+#	define BACKSLASH_IS_PATH_SEPARATOR
+#endif
+#if defined(WIN32)
+	// HAVE_UNC_PATHS is defined to signify that Universal Naming Convention
+	// style paths are to be recognised on this platform.
+#	define HAVE_UNC_PATHS
+	// HAVE_CWD_PER_DRIVE is defined to signify that every drive has its own
+	// current working directory.
+#	define HAVE_CWD_PER_DRIVE
+#endif
+// REJECT_DRIVE_PATH_WITHOUT_SLASH can also be defined, if paths of the form
+// "d:foo/bar" (without a slash after the drive letter) are to be rejected.
+
 #endif  /* _PORT_H */
 
diff -ruNp src.orig/res/UrQuanMasters.rc src/res/UrQuanMasters.rc
--- src.orig/res/UrQuanMasters.rc	2017-11-08 16:49:22 -0600
+++ src/res/UrQuanMasters.rc	2017-11-08 16:49:50 -0600
@@ -42,7 +42,7 @@ BEGIN
             VALUE "FileDescription", "The Ur-Quan Masters main executable\0"
             VALUE "FileVersion", UQM_STRING_VERSION "\0"
             VALUE "InternalName", "uqm\0"
-            VALUE "LegalCopyright", "(C) 1992-1993, 2002-2005 by respective authors\0"
+            VALUE "LegalCopyright", "(C) 1992-1993, 2002-2007 by respective authors\0"
 #ifdef _DEBUG
             VALUE "OriginalFilename", "uqmdebug.exe\0"
 #else
diff -ruNp src.orig/res/darwin/Info.plist src/res/darwin/Info.plist
--- src.orig/res/darwin/Info.plist	2017-11-08 16:49:22 -0600
+++ src/res/darwin/Info.plist	1969-12-31 18:00:00 -0600
@@ -1,22 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
-<plist version="1.0">
-<dict>
-	<key>CFBundleDevelopmentRegion</key>
-	<string>English</string>
-	<key>CFBundleExecutable</key>
-	<string>The Ur-Quan Masters</string>
-	<key>CFBundleIconFile</key>
-	<string>The Ur-Quan Masters.icns</string>
-	<key>CFBundleInfoDictionaryVersion</key>
-	<string>6.0</string>
-	<key>CFBundlePackageType</key>
-	<string>APPL</string>
-	<key>CFBundleShortVersionString</key>
-	<string>@@VERSION@@</string>
-	<key>CFBundleSignature</key>
-	<string>????</string>
-	<key>CFBundleVersion</key>
-	<string>@@VERSION@@</string>
-</dict>
-</plist>
diff -ruNp src.orig/res/darwin/PkgInfo src/res/darwin/PkgInfo
--- src.orig/res/darwin/PkgInfo	2017-11-08 16:49:22 -0600
+++ src/res/darwin/PkgInfo	1969-12-31 18:00:00 -0600
@@ -1 +0,0 @@
-APPL????
\ No newline at end of file
Files src.orig/res/darwin/The Ur-Quan Masters.icns and src/res/darwin/The Ur-Quan Masters.icns differ
diff -ruNp src.orig/res/darwin/uqm.r src/res/darwin/uqm.r
--- src.orig/res/darwin/uqm.r	2017-11-08 16:49:22 -0600
+++ src/res/darwin/uqm.r	1969-12-31 18:00:00 -0600
@@ -1,3 +0,0 @@
-data 'MBAR' (128) {
-	$"0001 0080"                                          /* ...€ */
-};
diff -ruNp src.orig/sc2code/Makeinfo src/sc2code/Makeinfo
--- src.orig/sc2code/Makeinfo	2017-11-08 16:49:34 -0600
+++ src/sc2code/Makeinfo	2017-11-08 16:50:01 -0600
@@ -1,15 +1,14 @@
 uqm_SUBDIRS="comm libs planets ships"
-uqm_CFILES="battle.c border.c build.c cleanup.c clock.c cnctdlg.c collide.c 
-		comm.c commanim.c commglue.c confirm.c credits.c cyborg.c
-		demo.c displist.c dummy.c encount.c fmv.c galaxy.c gameev.c
-		gameinp.c gameopt.c gendef.c getchar.c globdata.c gravity.c
-		gravwell.c grpinfo.c hyper.c init.c intel.c intro.c ipdisp.c
-		load.c loadship.c master.c melee.c menu.c misc.c mouse_err.c
-		oscill.c outfit.c pickmele.c pickship.c plandata.c process.c
-		restart.c save.c settings.c setup.c setupmenu.c ship.c
-		shipstat.c shipyard.c sis.c sounds.c starbase.c starcon.c
-		starmap.c state.c status.c tactrans.c trans.c uqmdebug.c
-		util.c velocity.c weapon.c"
+uqm_CFILES="battle.c battlecontrols.c border.c build.c cleanup.c clock.c
+		cnctdlg.c collide.c comm.c commanim.c commglue.c confirm.c credits.c
+		cyborg.c demo.c displist.c dummy.c encount.c flash.c fmv.c galaxy.c
+		gameev.c gameinp.c gameopt.c gendef.c getchar.c globdata.c gravity.c
+		cons_res.c grpinfo.c hyper.c init.c intel.c intro.c ipdisp.c load.c
+		loadmele.c loadship.c master.c melee.c menu.c misc.c oscill.c
+		outfit.c pickmele.c pickship.c plandata.c process.c restart.c save.c
+		settings.c setup.c setupmenu.c ship.c shipstat.c shipyard.c sis.c
+		sounds.c starbase.c starcon.c starmap.c state.c status.c tactrans.c
+		trans.c uqmdebug.c util.c velocity.c weapon.c"
 if [ -n "$uqm_NETPLAY" ]; then
 	uqm_SUBDIRS="$uqm_SUBDIRS netplay"
 fi
diff -ruNp src.orig/sc2code/battle.c src/sc2code/battle.c
--- src.orig/sc2code/battle.c	2017-11-08 16:49:22 -0600
+++ src/sc2code/battle.c	2017-11-08 16:49:50 -0600
@@ -18,6 +18,7 @@
 
 #include "battle.h"
 
+#include "battlecontrols.h"
 #include "controls.h"
 #include "init.h"
 #include "intel.h"
@@ -27,6 +28,7 @@
 #		include "netplay/checksum.h"
 #	endif
 #endif
+#include "pickmele.h"
 #include "resinst.h"
 #include "nameref.h"
 #include "setup.h"
@@ -38,7 +40,9 @@
 
 
 QUEUE disp_q;
-SIZE battle_counter;
+BYTE battle_counter[NUM_SIDES];
+		// The number of ships still available for battle to each side.
+		// A ship that has warped out is no longer available.
 BOOLEAN instantVictory;
 size_t battleInputOrder[NUM_SIDES];
 		// Indices of the sides in the order their input is processed.
@@ -66,9 +70,9 @@ RunAwayAllowed (void)
 }
 
 static void
-DoRunAway (STARSHIPPTR StarShipPtr)
+DoRunAway (STARSHIP *StarShipPtr)
 {
-	ELEMENTPTR ElementPtr;
+	ELEMENT *ElementPtr;
 
 	LockElement (StarShipPtr->hShip, &ElementPtr);
 	if (GetPrimType (&DisplayArray[ElementPtr->PrimIndex]) == STAMP_PRIM
@@ -77,9 +81,9 @@ DoRunAway (STARSHIPPTR StarShipPtr)
 			&& ElementPtr->mass_points != MAX_SHIP_MASS * 10
 			&& !(ElementPtr->state_flags & APPEARING))
 	{
-		extern void flee_preprocess (PELEMENT);
+		extern void flee_preprocess (ELEMENT *);
 
-		battle_counter -= MAKE_WORD (1, 0);
+		battle_counter[0]--;
 
 		ElementPtr->turn_wait = 3;
 		ElementPtr->thrust_wait = MAKE_BYTE (4, 0);
@@ -128,6 +132,13 @@ setupBattleInputOrder(void)
 #endif
 }
 
+BATTLE_INPUT_STATE
+frameInputHuman (HumanInputContext *context, STARSHIP *StarShipPtr)
+{
+	(void) StarShipPtr;
+	return CurrentInputToBattleInput (context->playerNr);
+}
+
 static void
 ProcessInput (void)
 {
@@ -150,7 +161,7 @@ ProcessInput (void)
 				hBattleShip != 0; hBattleShip = hNextShip)
 		{
 			BATTLE_INPUT_STATE InputState;
-			STARSHIPPTR StarShipPtr;
+			STARSHIP *StarShipPtr;
 
 			StarShipPtr = LockStarShip (&race_q[cur_player], hBattleShip);
 			hNextShip = _GetSuccLink (StarShipPtr);
@@ -159,8 +170,9 @@ ProcessInput (void)
 			{
 				CyborgDescPtr = StarShipPtr;
 
-				InputState = (*(PlayerInput[cur_player]))(cur_player,
-						StarShipPtr);
+				InputState = PlayerInput[cur_player]->handlers->frameInput (
+						PlayerInput[cur_player], StarShipPtr);
+
 #if CREATE_JOURNAL
 				JournalInput (InputState);
 #endif /* CREATE_JOURNAL */
@@ -181,7 +193,6 @@ ProcessInput (void)
 				CyborgDescPtr->ship_input_state = 0;
 				if (CyborgDescPtr->RaceDescPtr->ship_info.crew_level)
 				{
-					
 					if (InputState & BATTLE_LEFT)
 						CyborgDescPtr->ship_input_state |= LEFT;
 					else if (InputState & BATTLE_RIGHT)
@@ -338,34 +349,34 @@ DoBattle (BATTLE_STATE *bs)
 	return TRUE;
 }
 
+#ifdef NETPLAY
+COUNT
+GetPlayerOrder (COUNT i)
+{
+	// Iff 'myTurn' is set on a connection, the local party will be
+	// processed first.
+	// If neither is network controlled, the top player (1) is handled
+	// first.
+	if (((PlayerControl[0] & NETWORK_CONTROL) &&
+			!NetConnection_getDiscriminant (netConnections[0])) ||
+			((PlayerControl[1] & NETWORK_CONTROL) &&
+			NetConnection_getDiscriminant (netConnections[1])))
+		return i;
+	else
+		return 1 - i;
+}
+#endif
+
 // Let each player pick his ship.
 static BOOLEAN
 selectAllShips (SIZE num_ships)
 {
-#ifndef NETPLAY
-	while (num_ships--)
-	{
-		if (!GetNextStarShip (NULL_PTR, num_ships == 1))
-			return FALSE;
-	}
-	return TRUE;
-#else
-	// On network play, what is the top player to one party may be
-	// the bottom player the other. To keep both sides synchronised
-	// the order is always the same.
-	SIZE order[2];
-
 	if (num_ships == 1) {
 		// HyperSpace in full game.
-		return GetNextStarShip (NULL_PTR, 0);
-	}
-
-	if (num_ships != 2)
-	{
-		log_add (log_Error, "More than two players is not supported.\n");
-		return FALSE;
+		return GetNextStarShip (NULL, 0);
 	}
-
+	
+#ifdef NETPLAY
 	if ((PlayerControl[0] & NETWORK_CONTROL) &&
 			(PlayerControl[1] & NETWORK_CONTROL))
 	{
@@ -373,34 +384,9 @@ selectAllShips (SIZE num_ships)
 				"controlled.\n");
 		return FALSE;
 	}
+#endif
 
-	// Iff 'myTurn' is set on a connection, the local party will be
-	// processed first.
-	// If neither is network controlled, the top player (1) is handled first.
-	if (((PlayerControl[0] & NETWORK_CONTROL) &&
-			!NetConnection_getDiscriminant (netConnections[0])) ||
-			((PlayerControl[1] & NETWORK_CONTROL) &&
-			NetConnection_getDiscriminant (netConnections[1])))
-	{
-		order[0] = 0;
-		order[1] = 1;
-	}
-	else
-	{
-		order[0] = 1;
-		order[1] = 0;
-	}
-
-	{
-		size_t i;
-		for (i = 0; i < 2; i++)
-		{
-			if (!GetNextStarShip (NULL_PTR, order[i]))
-				return FALSE;
-		}
-	}
-	return TRUE;
-#endif	
+	return GetInitialStarShips ();
 }
 
 BOOLEAN
@@ -410,8 +396,6 @@ Battle (void)
 
 	LockMutex (GraphicsLock);
 
-	SetResourceIndex (hResIndex);
-
 #if !(DEMO_MODE || CREATE_JOURNAL)
 	if (LOBYTE (GLOBAL (CurrentActivity)) != SUPER_MELEE) {
 		// In Supermelee, the RNG is already initialised.
@@ -430,8 +414,9 @@ Battle (void)
 
 	if (instantVictory)
 	{
-		num_ships = 0;  // no ships were harmed in the making of this battle
-		battle_counter = 1;  // a winner is you!
+		num_ships = 0;
+		battle_counter[0] = 1;
+		battle_counter[1] = 0;
 		instantVictory = FALSE;
 	}
 	
@@ -440,10 +425,11 @@ Battle (void)
 		BATTLE_STATE bs;
 
 		GLOBAL (CurrentActivity) |= IN_BATTLE;
-		battle_counter = MAKE_WORD (
-				CountLinks (&race_q[0]),
-				CountLinks (&race_q[1])
-				);
+		battle_counter[0] = CountLinks (&race_q[0]);
+		battle_counter[1] = CountLinks (&race_q[1]);
+
+		if (optMeleeScale != TFB_SCALE_STEP)
+			SetGraphicScaleMode (optMeleeScale);
 
 		setupBattleInputOrder ();
 #ifdef NETPLAY
@@ -478,25 +464,32 @@ Battle (void)
 				IN_HYPERSPACE);
 
 		UnlockMutex (GraphicsLock);
-		DoInput ((PVOID)&bs, FALSE);
+		DoInput (&bs, FALSE);
 		LockMutex (GraphicsLock);
 
 AbortBattle:
-		if (LOBYTE (GLOBAL (CurrentActivity)) == SUPER_MELEE &&
-				(GLOBAL (CurrentActivity) & CHECK_ABORT))
+		if (LOBYTE (GLOBAL (CurrentActivity)) == SUPER_MELEE)
 		{
-			// Do not return to the main menu when a game is aborted,
-			// (just to the supermelee menu).
+			if (GLOBAL (CurrentActivity) & CHECK_ABORT)
+			{
+				// Do not return to the main menu when a game is aborted,
+				// (just to the supermelee menu).
 #ifdef NETPLAY
-			UnlockMutex (GraphicsLock);
-			waitResetConnections(NetState_inSetup);
-					// A connection may already be in inSetup (set from
-					// GetMeleeStarship). This is not a problem, although
-					// it will generate a warning in debug mode.
-			LockMutex (GraphicsLock);
+				UnlockMutex (GraphicsLock);
+				waitResetConnections(NetState_inSetup);
+						// A connection may already be in inSetup (set from
+						// GetMeleeStarship). This is not a problem, although
+						// it will generate a warning in debug mode.
+				LockMutex (GraphicsLock);
 #endif
 
-			GLOBAL (CurrentActivity) &= ~CHECK_ABORT;
+				GLOBAL (CurrentActivity) &= ~CHECK_ABORT;
+			}
+			else
+			{
+				// Show the result of the battle.
+				MeleeGameOver ();
+			}
 		}
 
 #ifdef NETPLAY
diff -ruNp src.orig/sc2code/battle.h src/sc2code/battle.h
--- src.orig/sc2code/battle.h	2017-11-08 16:49:22 -0600
+++ src/sc2code/battle.h	2017-11-08 16:49:50 -0600
@@ -16,8 +16,17 @@
 #ifndef _BATTLE_H
 #define _BATTLE_H
 
+#include "options.h"
 #include "libs/compiler.h"
+
+#if defined (NETPLAY)
+typedef DWORD BattleFrameCounter;
+#endif
+
 #include "displist.h"
+		// for QUEUE
+#include "init.h"
+		// For NUM_SIDES
 
 typedef struct battlestate_struct {
 	BOOLEAN (*InputFunc) (struct battlestate_struct *pInputState);
@@ -27,15 +36,23 @@ typedef struct battlestate_struct {
 } BATTLE_STATE;
 
 extern QUEUE disp_q;
-extern SIZE battle_counter;
+// The maximum number of elements is chosen to provide a slight margin.
+// Currently, it is maximum *known used* in Melee + 30
+#define MAX_DISPLAY_ELEMENTS 150
+
+extern BYTE battle_counter[NUM_SIDES];
 extern BOOLEAN instantVictory;
-#ifdef NETPLAY
-typedef DWORD BattleFrameCounter;
+#if defined (NETPLAY)
 extern BattleFrameCounter battleFrameCount;
+#endif
+#ifdef NETPLAY
 extern COUNT currentDeadSide;
+COUNT GetPlayerOrder (COUNT i);
+#else
+#	define GetPlayerOrder(i) (i)
 #endif
 
-extern BOOLEAN Battle (void);
+BOOLEAN Battle (void);
 
 #endif  /* _BATTLE_H */
 
diff -ruNp src.orig/sc2code/battlecontrols.c src/sc2code/battlecontrols.c
--- src.orig/sc2code/battlecontrols.c	1969-12-31 18:00:00 -0600
+++ src/sc2code/battlecontrols.c	2017-11-08 16:49:50 -0600
@@ -0,0 +1,98 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "battlecontrols.h"
+
+#include "intel.h"
+		// For computer_intelligence()
+#include "tactrans.h"
+		// For battleEndReady*
+#include "libs/misc.h"
+		// For HFree()
+#ifdef NETPLAY
+#	include "netplay/netmelee.h"
+#endif  /* NETPLAY */
+
+InputContext *PlayerInput[NUM_PLAYERS];
+
+BattleInputHandlers ComputerInputHandlers = {
+	/* .frameInput     = */ (BattleFrameInputFunction) computer_intelligence,
+	/* .selectShip     = */ (SelectShipFunction) selectShipComputer,
+	/* .battleEndReady = */ (BattleEndReadyFunction) battleEndReadyComputer,
+	/* .deleteContext  = */ InputContext_delete,
+};
+
+BattleInputHandlers HumanInputHandlers = {
+	/* .frameInput     = */ (BattleFrameInputFunction) frameInputHuman,
+	/* .selectShip     = */ (SelectShipFunction) selectShipHuman,
+	/* .battleEndReady = */ (BattleEndReadyFunction) battleEndReadyHuman,
+	/* .deleteContext  = */ InputContext_delete,
+};
+
+#ifdef NETPLAY
+BattleInputHandlers NetworkInputHandlers = {
+	/* .frameInput     = */ (BattleFrameInputFunction) networkBattleInput,
+	/* .selectShip     = */ (SelectShipFunction) selectShipNetwork,
+	/* .battleEndReady = */ (BattleEndReadyFunction) battleEndReadyNetwork,
+	/* .deleteContext  = */ InputContext_delete,
+};
+#endif
+
+
+void
+InputContext_init (InputContext *context, BattleInputHandlers *handlers,
+		COUNT playerNr)
+{
+	context->handlers = handlers;
+	context->playerNr = playerNr;
+}
+
+void
+InputContext_delete (InputContext *context)
+{
+	HFree (context);
+}
+
+ComputerInputContext *
+ComputerInputContext_new (COUNT playerNr)
+{
+	ComputerInputContext *result = HMalloc (sizeof (ComputerInputContext));
+	InputContext_init ((InputContext *) result,
+			&ComputerInputHandlers, playerNr);
+	return result;
+}
+
+HumanInputContext *
+HumanInputContext_new (COUNT playerNr)
+{
+	HumanInputContext *result = HMalloc (sizeof (HumanInputContext));
+	InputContext_init ((InputContext *) result,
+			&HumanInputHandlers, playerNr);
+	return result;
+}
+
+#ifdef NETPLAY
+NetworkInputContext *
+NetworkInputContext_new (COUNT playerNr)
+{
+	NetworkInputContext *result = HMalloc (sizeof (NetworkInputContext));
+	InputContext_init ((InputContext *) result,
+			&NetworkInputHandlers, playerNr);
+	return result;
+}
+#endif
+
+
diff -ruNp src.orig/sc2code/battlecontrols.h src/sc2code/battlecontrols.h
--- src.orig/sc2code/battlecontrols.h	1969-12-31 18:00:00 -0600
+++ src/sc2code/battlecontrols.h	2017-11-08 16:49:50 -0600
@@ -0,0 +1,93 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _BATTLECONTROLS_H
+#define _BATTLECONTROLS_H
+
+typedef struct BattleInputHandlers BattleInputHandlers;
+typedef struct InputContext InputContext;
+typedef struct ComputerInputContext ComputerInputContext;
+typedef struct HumanInputContext HumanInputContext;
+#ifdef NETPLAY
+typedef struct NetworkInputContext NetworkInputContext;
+#endif  /* NETPLAY */
+
+#include "controls.h"
+#include "pickmele.h"
+#include "races.h"
+#include "libs/compiler.h"
+
+typedef BATTLE_INPUT_STATE (*BattleFrameInputFunction) (
+		InputContext *context, STARSHIP *StarShipPtr);
+typedef BOOLEAN (*SelectShipFunction) (InputContext *context,
+		GETMELEE_STATE *gms);
+typedef bool (*BattleEndReadyFunction) (InputContext *context);
+typedef void (*DeleteInputContextFunction) (InputContext *context);
+
+
+struct BattleInputHandlers {
+	BattleFrameInputFunction frameInput;
+	SelectShipFunction selectShip;
+	BattleEndReadyFunction battleEndReady;
+	DeleteInputContextFunction deleteContext;
+};
+
+#define INPUT_CONTEXT_COMMON \
+		BattleInputHandlers *handlers; \
+		COUNT playerNr;
+
+// Base "class" for all ...InputContext structures
+struct InputContext {
+	INPUT_CONTEXT_COMMON
+};
+
+struct ComputerInputContext {
+	INPUT_CONTEXT_COMMON
+	// TODO: Put RNG Context used for the AI here.
+};
+
+struct HumanInputContext {
+	INPUT_CONTEXT_COMMON
+};
+
+#ifdef NETPLAY
+struct NetworkInputContext {
+	INPUT_CONTEXT_COMMON
+	// TODO: put NetworkConnection for this player here.
+};
+#endif  /* NETPLAY */
+
+ComputerInputContext *ComputerInputContext_new (COUNT playerNr);
+HumanInputContext *HumanInputContext_new (COUNT playerNr);
+#ifdef NETPLAY
+NetworkInputContext *NetworkInputContext_new (COUNT playerNr);
+#endif  /* NETPLAY */
+
+extern InputContext *PlayerInput[];
+
+
+BATTLE_INPUT_STATE frameInputHuman (HumanInputContext *context,
+		STARSHIP *StarShipPtr);
+void InputContext_init(InputContext *context, BattleInputHandlers *handlers,
+		COUNT playerNr);
+void InputContext_delete (InputContext *context);
+		// Do not call directly, only from the FreeInputContextFunction.
+		// Call InputContext->handlers->freeContext() to release an
+		// InputContext.
+
+#endif  /* _BATTLECONTROLS_H */
+
+
diff -ruNp src.orig/sc2code/build.c src/sc2code/build.c
--- src.orig/sc2code/build.c	2017-11-08 16:49:22 -0600
+++ src/sc2code/build.c	2017-11-08 16:49:50 -0600
@@ -19,47 +19,49 @@
 #include "build.h"
 
 #include "races.h"
+#include "master.h"
 #include "setup.h"
 #include "libs/compiler.h"
 #include "libs/mathlib.h"
 
 
-HSTARSHIP
-Build (PQUEUE pQueue, DWORD RaceResIndex, COUNT which_player, BYTE
-		captains_name_index)
+// Allocate a new STARSHIP or SHIP_FRAGMENT and put it in the queue
+HLINK
+Build (QUEUE *pQueue, SPECIES_ID SpeciesID)
 {
-	HSTARSHIP hNewShip;
+	HLINK hNewShip;
+	SHIP_BASE *ShipPtr;
 
-	if ((hNewShip = AllocStarShip (pQueue)) != 0)
-	{
-		STARSHIPPTR StarShipPtr;
+	assert (GetLinkSize (pQueue) == sizeof (STARSHIP) ||
+			GetLinkSize (pQueue) == sizeof (SHIP_FRAGMENT));
 
-		StarShipPtr = LockStarShip (pQueue, hNewShip);
-		memset (StarShipPtr, 0, GetLinkSize (pQueue));
+	hNewShip = AllocLink (pQueue);
+	if (!hNewShip)
+		return 0;
 
-		StarShipPtr->RaceResIndex = RaceResIndex;
-		OwnStarShip (StarShipPtr, which_player, captains_name_index);
+	ShipPtr = (SHIP_BASE *) LockLink (pQueue, hNewShip);
+	memset (ShipPtr, 0, GetLinkSize (pQueue));
+	ShipPtr->SpeciesID = SpeciesID;
 
-		UnlockStarShip (pQueue, hNewShip);
-		PutQueue (pQueue, hNewShip);
-	}
+	UnlockLink (pQueue, hNewShip);
+	PutQueue (pQueue, hNewShip);
 
-	return (hNewShip);
+	return hNewShip;
 }
 
-HSTARSHIP
-GetStarShipFromIndex (PQUEUE pShipQ, COUNT Index)
+HLINK
+GetStarShipFromIndex (QUEUE *pShipQ, COUNT Index)
 {
-	HSTARSHIP hStarShip, hNextShip;
+	HLINK hStarShip, hNextShip;
 
 	for (hStarShip = GetHeadLink (pShipQ);
 			Index > 0 && hStarShip; hStarShip = hNextShip, --Index)
 	{
-		STARSHIPPTR StarShipPtr;
+		LINK *StarShipPtr;
 
-		StarShipPtr = LockStarShip (pShipQ, hStarShip);
+		StarShipPtr = LockLink (pShipQ, hStarShip);
 		hNextShip = _GetSuccLink (StarShipPtr);
-		UnlockStarShip (pShipQ, hStarShip);
+		UnlockLink (pShipQ, hStarShip);
 	}
 
 	return (hStarShip);
@@ -88,250 +90,227 @@ GetStarShipFromIndex (PQUEUE pShipQ, COU
  * CHECK_ALLIANCE:
  * 	Test the alliance status of the race of 'which_ship'.
  *      Either GOOD_GUY (allied) or BAD_GUY (not allied) is returned.
- * 0:
+ * SET_ALLIED (0):
  * 	Ally with the race of 'which_ship'. This makes their ship available
  *  for building in the shipyard.
- * -1:
+ * SET_NOT_ALLIED:
  * 	End an alliance with the race of 'which_ship'. This ends the possibility
- * 	of building their ships in the shipyard. For the Orz also the ships the
- * 	player has with him will disappear.
+ * 	of building their ships in the shipyard.
+ * REMOVE_BUILT: 
+ *  Make the already built escorts of the race of 'which_ship' disappear.
+ *   (as for the Orz when the alliance with them ends)
  * any other positive number:
- * 	Give the player this much ships of type 'which_ship'. If it's
+ * 	Give the player this many ships of type 'which_ship'.
  */
 COUNT
 ActivateStarShip (COUNT which_ship, SIZE state)
 {
-	HSTARSHIP hStarShip, hNextShip;
+	HFLEETINFO hFleet;
 
-	hStarShip = GetStarShipFromIndex (
-			&GLOBAL (avail_race_q), which_ship
-			);
-	if (hStarShip)
+	hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q), which_ship);
+	if (!hFleet)
+		return 0;
+
+	switch (state)
 	{
-		switch (state)
+		case SPHERE_TRACKING:
+		case SPHERE_KNOWN:
 		{
-			case SPHERE_TRACKING:
-			case SPHERE_KNOWN:
-			{
-				EXTENDED_SHIP_FRAGMENTPTR StarShipPtr;
+			FLEET_INFO *FleetPtr;
 
-				StarShipPtr = (EXTENDED_SHIP_FRAGMENTPTR)LockStarShip (
-						&GLOBAL (avail_race_q), hStarShip);
-				if (state == SPHERE_KNOWN)
-					which_ship = StarShipPtr->ShipInfo.known_strength;
-				else if (StarShipPtr->ShipInfo.actual_strength == 0)
-				{
-					if (!(StarShipPtr->ShipInfo.ship_flags
-							& (GOOD_GUY | BAD_GUY)))
-						which_ship = 0;
-				}
-				else if (StarShipPtr->ShipInfo.known_strength == 0
-						&& StarShipPtr->ShipInfo.actual_strength != (COUNT)~0)
-				{
-					StarShipPtr->ShipInfo.known_strength = 1;
-					StarShipPtr->ShipInfo.known_loc =
-							StarShipPtr->ShipInfo.loc;
-				}
-				UnlockStarShip (&GLOBAL (avail_race_q), hStarShip);
-				return (which_ship);
+			FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+			if (state == SPHERE_KNOWN)
+				which_ship = FleetPtr->known_strength;
+			else if (FleetPtr->actual_strength == 0)
+			{
+				if (!(FleetPtr->ship_flags & (GOOD_GUY | BAD_GUY)))
+					which_ship = 0;
 			}
-			case ESCORT_WORTH:
+			else if (FleetPtr->known_strength == 0
+					&& FleetPtr->actual_strength != INFINITE_RADIUS)
 			{
-				COUNT ShipCost[] =
-				{
-					RACE_SHIP_COST
-				};
-				COUNT total = 0;
+				FleetPtr->known_strength = 1;
+				FleetPtr->known_loc = FleetPtr->loc;
+			}
+			UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+			return (which_ship);
+		}
+		case ESCORT_WORTH:
+		{
+			COUNT ShipCost[] =
+			{
+				RACE_SHIP_COST
+			};
+			COUNT total = 0;
+			HSHIPFRAG hStarShip, hNextShip;
 
-				for (hStarShip = GetHeadLink (&GLOBAL (built_ship_q));
-						hStarShip; hStarShip = hNextShip)
-				{
-					SHIP_FRAGMENTPTR StarShipPtr;
+			for (hStarShip = GetHeadLink (&GLOBAL (built_ship_q));
+					hStarShip; hStarShip = hNextShip)
+			{
+				SHIP_FRAGMENT *StarShipPtr;
 
-					StarShipPtr = (SHIP_FRAGMENTPTR) LockStarShip (
-							&GLOBAL (built_ship_q), hStarShip);
-					hNextShip = _GetSuccLink (StarShipPtr);
-					total += ShipCost[GET_RACE_ID (StarShipPtr)];
-					UnlockStarShip (&GLOBAL (built_ship_q), hStarShip);
-				}
-				return total;
+				StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+				hNextShip = _GetSuccLink (StarShipPtr);
+				total += ShipCost[StarShipPtr->race_id];
+				UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 			}
-			case ESCORTING_FLAGSHIP:
+			return total;
+		}
+		case ESCORTING_FLAGSHIP:
+		{
+			HSHIPFRAG hStarShip, hNextShip;
+
+			for (hStarShip = GetHeadLink (&GLOBAL (built_ship_q));
+					hStarShip; hStarShip = hNextShip)
 			{
-				for (hStarShip = GetHeadLink (&GLOBAL (built_ship_q));
-						hStarShip; hStarShip = hNextShip)
-				{
-					BYTE ship_type;
-					SHIP_FRAGMENTPTR StarShipPtr;
+				BYTE ship_type;
+				SHIP_FRAGMENT *StarShipPtr;
 
-					StarShipPtr = (SHIP_FRAGMENTPTR) LockStarShip (
-							&GLOBAL (built_ship_q), hStarShip);
-					hNextShip = _GetSuccLink (StarShipPtr);
-					ship_type = GET_RACE_ID (StarShipPtr);
-					UnlockStarShip (&GLOBAL (built_ship_q), hStarShip);
+				StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+				hNextShip = _GetSuccLink (StarShipPtr);
+				ship_type = StarShipPtr->race_id;
+				UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 
-					if ((COUNT) ship_type == which_ship)
-						return 1;
-				}
-				return 0;
+				if (ship_type == which_ship)
+					return 1;
 			}
-			case FEASIBILITY_STUDY:
-				return (MAX_BUILT_SHIPS
-						- CountLinks (&GLOBAL (built_ship_q)));
-			default:
+			return 0;
+		}
+		case FEASIBILITY_STUDY:
+		{
+			return (MAX_BUILT_SHIPS - CountLinks (&GLOBAL (built_ship_q)));
+		}
+		case CHECK_ALLIANCE:
+		{
+			COUNT flags;
+			FLEET_INFO *FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q),
+					hFleet);
+			flags = FleetPtr->ship_flags & (GOOD_GUY | BAD_GUY);
+			UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+			return flags;
+		}
+		case SET_ALLIED:
+		case SET_NOT_ALLIED:
+		{
+			FLEET_INFO *FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q),
+					hFleet);
+
+			if (!(FleetPtr->ship_flags & (GOOD_GUY | BAD_GUY)))
+			{	/* Strange request, silently ignore it */
+				UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+				break;
+			}
+
+			FleetPtr->ship_flags &= ~(GOOD_GUY | BAD_GUY);
+			if (state == SET_ALLIED)
+				FleetPtr->ship_flags |= GOOD_GUY;
+			else
+				FleetPtr->ship_flags |= BAD_GUY;
+			
+			UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+			break;
+		}
+		case REMOVE_BUILT:
+		{
+			HSHIPFRAG hStarShip, hNextShip;
+			BOOLEAN ShipRemoved = FALSE;
+
+			for (hStarShip = GetHeadLink (&GLOBAL (built_ship_q));
+					hStarShip; hStarShip = hNextShip)
 			{
-				SHIP_FRAGMENTPTR StarShipPtr;
+				BOOLEAN RemoveShip;
+				SHIP_FRAGMENT *StarShipPtr;
 
-				if (state <= 0)
+				StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+				hNextShip = _GetSuccLink (StarShipPtr);
+				RemoveShip = (StarShipPtr->race_id == which_ship);
+				UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+
+				if (RemoveShip)
 				{
-					StarShipPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-							&GLOBAL (avail_race_q), hStarShip
-							);
-					if (state == CHECK_ALLIANCE)
-					{
-						state = StarShipPtr->ShipInfo.ship_flags
-								& (GOOD_GUY | BAD_GUY);
-						UnlockStarShip (&GLOBAL (avail_race_q), hStarShip);
-						return ((COUNT)state);
-					}
-					else if (StarShipPtr->ShipInfo.ship_flags
-							& (GOOD_GUY | BAD_GUY))
-					{
-						StarShipPtr->ShipInfo.ship_flags &= ~(GOOD_GUY | BAD_GUY);
-						if (state == 0)
-							StarShipPtr->ShipInfo.ship_flags |= GOOD_GUY;
-						else
-						{
-							StarShipPtr->ShipInfo.ship_flags |= BAD_GUY;
-							if (which_ship == ORZ_SHIP)
-							{
-								BOOLEAN ShipRemoved;
-
-								ShipRemoved = FALSE;
-								for (hStarShip = GetHeadLink (
-										&GLOBAL (built_ship_q));
-										hStarShip; hStarShip = hNextShip)
-								{
-									BOOLEAN RemoveShip;
-									SHIP_FRAGMENTPTR StarShipPtr2;
-
-									StarShipPtr2 =
-											(SHIP_FRAGMENTPTR)LockStarShip (
-											&GLOBAL (built_ship_q), hStarShip);
-									hNextShip = _GetSuccLink (StarShipPtr2);
-									RemoveShip = (BOOLEAN) (
-											GET_RACE_ID (StarShipPtr2) ==
-											ORZ_SHIP);
-									UnlockStarShip (&GLOBAL (built_ship_q),
-											hStarShip);
-
-									if (RemoveShip)
-									{
-										ShipRemoved = TRUE;
-
-										RemoveQueue (&GLOBAL (built_ship_q),
-												hStarShip);
-										FreeStarShip (&GLOBAL (built_ship_q),
-												hStarShip);
-									}
-								}
-								
-								if (ShipRemoved)
-								{
-									LockMutex (GraphicsLock);
-									DeltaSISGauges (UNDEFINED_DELTA,
-											UNDEFINED_DELTA, UNDEFINED_DELTA);
-									UnlockMutex (GraphicsLock);
-								}
-							}
-						}
-					}
-					UnlockStarShip (&GLOBAL (avail_race_q), hStarShip);
+					ShipRemoved = TRUE;
+
+					RemoveQueue (&GLOBAL (built_ship_q), hStarShip);
+					FreeShipFrag (&GLOBAL (built_ship_q), hStarShip);
 				}
-				else
+			}
+			
+			if (ShipRemoved)
+			{
+				LockMutex (GraphicsLock);
+				DeltaSISGauges (UNDEFINED_DELTA, UNDEFINED_DELTA,
+						UNDEFINED_DELTA);
+				UnlockMutex (GraphicsLock);
+			}
+			break;
+		}
+		default:
+		{
+			BYTE which_window;
+			COUNT i;
+
+			assert (state > 0);
+			/* Add ships to the escorts */
+			which_window = 0;
+			for (i = 0; i < (COUNT)state; i++)
+			{
+				HSHIPFRAG hStarShip;
+				HSHIPFRAG hOldShip;
+				SHIP_FRAGMENT *StarShipPtr;
+
+				hStarShip = CloneShipFragment (which_ship,
+						&GLOBAL (built_ship_q), 0);
+				if (!hStarShip)
+					break;
+
+				RemoveQueue (&GLOBAL (built_ship_q), hStarShip);
+
+				/* Find first available escort window */
+				while ((hOldShip = GetStarShipFromIndex (
+						&GLOBAL (built_ship_q), which_window++)))
 				{
-					/* 'state > 0', add ships to the escorts */
-					BYTE which_window;
-					COUNT i;
-
-					which_window = 0;
-					for (i = 0; i < (COUNT)state; i++)
-					{
-						HSTARSHIP hOldShip;
-						BYTE crewLevel;
-
-						if (which_ship == SPATHI_SHIP &&
-								GET_GAME_STATE (FOUND_PLUTO_SPATHI) == 1)
-							crewLevel = 1;  // Only Fwiffo is on board.
-						else
-							crewLevel = 0;  // Crewed to the max
-								
-						hStarShip = CloneShipFragment((COUNT) which_ship,
-								&GLOBAL (built_ship_q), crewLevel);
-						if (!hStarShip)
-							break;
-
-						RemoveQueue (&GLOBAL (built_ship_q), hStarShip);
-
-						while ((hOldShip = GetStarShipFromIndex (
-								&GLOBAL (built_ship_q), which_window++)))
-						{
-							BYTE win_loc;
-
-							StarShipPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-									&GLOBAL (built_ship_q), hOldShip);
-							win_loc = GET_GROUP_LOC (StarShipPtr);
-							UnlockStarShip (&GLOBAL (built_ship_q),
-									hOldShip);
-							if (which_window <= win_loc)
-								break;
-						}
-
-						StarShipPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-								&GLOBAL (built_ship_q), hStarShip);
-						SET_GROUP_LOC (StarShipPtr, which_window - 1);
-						if (which_ship == SPATHI_SHIP
-								&& GET_GAME_STATE (FOUND_PLUTO_SPATHI) == 1)
-						{
-							OwnStarShip (StarShipPtr, GOOD_GUY,
-									NAME_OFFSET + NUM_CAPTAINS_NAMES);
-						}
-						UnlockStarShip (&GLOBAL (built_ship_q), hStarShip);
-
-						InsertQueue (&GLOBAL (built_ship_q), hStarShip,
-								hOldShip);
-					}
-
-					LockMutex (GraphicsLock);
-					DeltaSISGauges (UNDEFINED_DELTA,
-							UNDEFINED_DELTA, UNDEFINED_DELTA);
-					UnlockMutex (GraphicsLock);
-					return (i);
+					BYTE win_loc;
+
+					StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q),
+							hOldShip);
+					win_loc = StarShipPtr->index;
+					UnlockShipFrag (&GLOBAL (built_ship_q), hOldShip);
+					if (which_window <= win_loc)
+						break;
 				}
-				break;
+
+				StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+				StarShipPtr->index = which_window - 1;
+				UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+
+				InsertQueue (&GLOBAL (built_ship_q), hStarShip, hOldShip);
 			}
-		}
 
-		return 1;
+			LockMutex (GraphicsLock);
+			DeltaSISGauges (UNDEFINED_DELTA,
+					UNDEFINED_DELTA, UNDEFINED_DELTA);
+			UnlockMutex (GraphicsLock);
+			return i;
+		}
 	}
 
-	return 0;
+	return 1;
 }
 
 COUNT
-GetIndexFromStarShip (PQUEUE pShipQ, HSTARSHIP hStarShip)
+GetIndexFromStarShip (QUEUE *pShipQ, HLINK hStarShip)
 {
 	COUNT Index;
 
 	Index = 0;
 	while (hStarShip != GetHeadLink (pShipQ))
 	{
-		HSTARSHIP hNextShip;
-		STARSHIPPTR StarShipPtr;
+		HLINK hNextShip;
+		LINK *StarShipPtr;
 
-		StarShipPtr = LockStarShip (pShipQ, hStarShip);
+		StarShipPtr = LockLink (pShipQ, hStarShip);
 		hNextShip = _GetPredLink (StarShipPtr);
-		UnlockStarShip (pShipQ, hStarShip);
+		UnlockLink (pShipQ, hStarShip);
 
 		hStarShip = hNextShip;
 		++Index;
@@ -341,85 +320,125 @@ GetIndexFromStarShip (PQUEUE pShipQ, HST
 }
 
 BYTE
-NameCaptain (PQUEUE pQueue, STARSHIPPTR StarShipPtr)
+NameCaptain (QUEUE *pQueue, SPECIES_ID SpeciesID)
 {
 	BYTE name_index;
-	HSTARSHIP hStarShip;
+	HLINK hStarShip;
+
+	assert (GetLinkSize (pQueue) == sizeof (STARSHIP) ||
+			GetLinkSize (pQueue) == sizeof (SHIP_FRAGMENT));
 
 	do
 	{
-		HSTARSHIP hNextShip;
+		HLINK hNextShip;
 
 		name_index = PickCaptainName ();
-		for (hStarShip = GetHeadLink (pQueue); hStarShip; hStarShip = hNextShip)
+		for (hStarShip = GetHeadLink (pQueue); hStarShip;
+				hStarShip = hNextShip)
 		{
-			STARSHIPPTR TestShipPtr;
+			SHIP_BASE *ShipPtr;
+			BYTE test_name_index = -1;
 
-			TestShipPtr = LockStarShip (pQueue, hStarShip);
-			hNextShip = _GetSuccLink (TestShipPtr);
-			if (TestShipPtr->RaceResIndex == StarShipPtr->RaceResIndex)
-			{
-				BOOLEAN SameName;
-
-				if (LOBYTE (GLOBAL (CurrentActivity)) == SUPER_MELEE)
-					SameName = (BOOLEAN)(
-							name_index == TestShipPtr->captains_name_index
-							);
-				else
-					SameName = (BOOLEAN)(
-							name_index == StarShipCaptain (TestShipPtr)
-							);
-
-				if (SameName)
-				{
-					UnlockStarShip (pQueue, hStarShip);
-					break;
-				}
-			}
-			UnlockStarShip (pQueue, hStarShip);
+			ShipPtr = (SHIP_BASE *) LockLink (pQueue, hStarShip);
+			hNextShip = _GetSuccLink (ShipPtr);
+			if (ShipPtr->SpeciesID == SpeciesID)
+				test_name_index = ShipPtr->captains_name_index;
+			UnlockLink (pQueue, hStarShip);
+			
+			if (name_index == test_name_index)
+				break;
 		}
-	} while (hStarShip);
+	} while (hStarShip /* name matched another ship */);
 
 	return name_index;
 }
 
 // crew_level can be set to INFINITE_FLEET for a ship which is to
 // represent an infinite number of ships.
-HSTARSHIP
-CloneShipFragment (COUNT shipIndex, PQUEUE pDstQueue, COUNT crew_level)
+HSHIPFRAG
+CloneShipFragment (COUNT shipIndex, QUEUE *pDstQueue, COUNT crew_level)
 {
-	HSTARSHIP hStarShip, hBuiltShip;
-	SHIP_FRAGMENTPTR TemplatePtr;
+	HFLEETINFO hFleet;
+	HSHIPFRAG hBuiltShip;
+	FLEET_INFO *TemplatePtr;
+	BYTE captains_name_index;
 
-	hStarShip = GetStarShipFromIndex (&GLOBAL (avail_race_q), shipIndex);
-	if (hStarShip == 0)
+	assert (GetLinkSize (pDstQueue) == sizeof (SHIP_FRAGMENT));
+
+	hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q), shipIndex);
+	if (!hFleet)
 		return 0;
 
-	TemplatePtr = (SHIP_FRAGMENTPTR)LockStarShip (
-			&GLOBAL (avail_race_q), hStarShip);
-	hBuiltShip =
-			Build (pDstQueue,
-			TemplatePtr->RaceResIndex,
-			TemplatePtr->ShipInfo.ship_flags & (GOOD_GUY | BAD_GUY),
-			(BYTE)(shipIndex == SAMATRA_SHIP ?
-					0 : NameCaptain (pDstQueue, (STARSHIPPTR)TemplatePtr)));
+	TemplatePtr = LockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+	if (shipIndex == SAMATRA_SHIP)
+		captains_name_index = 0;
+	else
+		captains_name_index = NameCaptain (pDstQueue,
+				TemplatePtr->SpeciesID);
+	hBuiltShip = Build (pDstQueue, TemplatePtr->SpeciesID);
 	if (hBuiltShip)
 	{
-		SHIP_FRAGMENTPTR ShipFragPtr;
+		SHIP_FRAGMENT *ShipFragPtr;
 
-		ShipFragPtr = (SHIP_FRAGMENTPTR)LockStarShip (pDstQueue, hBuiltShip);
-		ShipFragPtr->ShipInfo = TemplatePtr->ShipInfo;
+		ShipFragPtr = LockShipFrag (pDstQueue, hBuiltShip);
+		ShipFragPtr->which_side = TemplatePtr->ship_flags &
+				(GOOD_GUY | BAD_GUY);
+		ShipFragPtr->captains_name_index = captains_name_index;
+		ShipFragPtr->race_strings = TemplatePtr->race_strings;
+		ShipFragPtr->icons = TemplatePtr->icons;
+		ShipFragPtr->melee_icon = TemplatePtr->melee_icon;
 		if (crew_level)
-			ShipFragPtr->ShipInfo.crew_level = crew_level;
-		ShipFragPtr->ShipInfo.energy_level = 0;
-		ShipFragPtr->ShipInfo.ship_flags = 0;
-		ShipFragPtr->ShipInfo.var1 = ShipFragPtr->ShipInfo.var2 = 0;
-		ShipFragPtr->ShipInfo.loc.x = ShipFragPtr->ShipInfo.loc.y = 0;
-		SET_RACE_ID (ShipFragPtr, (BYTE)shipIndex);
-		UnlockStarShip (pDstQueue, hBuiltShip);
+			ShipFragPtr->crew_level = crew_level;
+		else
+			ShipFragPtr->crew_level = TemplatePtr->crew_level;
+		ShipFragPtr->max_crew = TemplatePtr->max_crew;
+		ShipFragPtr->energy_level = 0;
+		ShipFragPtr->max_energy = TemplatePtr->max_energy;
+		ShipFragPtr->race_id = (BYTE)shipIndex;
+		ShipFragPtr->index = 0;
+		UnlockShipFrag (pDstQueue, hBuiltShip);
 	}
-	UnlockStarShip (&GLOBAL (avail_race_q), hStarShip);
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
 
 	return hBuiltShip;
 }
 
+/* Set the crew and captain's name on the first fully-crewed escort
+ * ship of race 'which_ship' */
+int
+SetEscortCrewComplement (COUNT which_ship, COUNT crew_level, BYTE captain)
+{
+	HFLEETINFO hFleet;
+	FLEET_INFO *TemplatePtr;
+	HSHIPFRAG hStarShip, hNextShip;
+	SHIP_FRAGMENT *StarShipPtr = 0;
+	int Index;
+
+	hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q), which_ship);
+	if (!hFleet)
+		return -1;
+	TemplatePtr = LockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+
+	/* Find first ship of which_ship race */
+	for (hStarShip = GetHeadLink (&GLOBAL (built_ship_q)), Index = 0;
+			hStarShip; hStarShip = hNextShip, ++Index)
+	{
+		StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+		hNextShip = _GetSuccLink (StarShipPtr);
+		if (which_ship == StarShipPtr->race_id &&
+				StarShipPtr->crew_level == TemplatePtr->crew_level)
+			break; /* found one */
+		UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+	}
+	if (hStarShip)
+	{
+		StarShipPtr->crew_level = crew_level;
+		StarShipPtr->captains_name_index = captain;
+		UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+	}
+	else
+		Index = -1;
+
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+	return Index;
+}
diff -ruNp src.orig/sc2code/build.h src/sc2code/build.h
--- src.orig/sc2code/build.h	2017-11-08 16:49:22 -0600
+++ src/sc2code/build.h	2017-11-08 16:49:50 -0600
@@ -33,50 +33,48 @@
 #define NAME_OFFSET 5
 #define NUM_CAPTAINS_NAMES 16
 
-#define OwnStarShip(S,p,n) \
-		(S)->s.Player = (p); \
-		(S)->s.Captain = (n);
-#define StarShipCaptain(S) \
-		(S)->s.Captain
-#define StarShipPlayer(S) \
-		(S)->s.Player
 #define PickCaptainName() (((COUNT)TFB_Random () \
 								& (NUM_CAPTAINS_NAMES - 1)) \
 								+ NAME_OFFSET)
 
-extern HSTARSHIP Build (PQUEUE pQueue, DWORD RaceResIndex, COUNT
-		which_player, BYTE captains_name_index);
-extern HSTARSHIP CloneShipFragment (COUNT shipIndex, PQUEUE pDstQueue,
+extern HLINK Build (QUEUE *pQueue, SPECIES_ID SpeciesID);
+extern HSHIPFRAG CloneShipFragment (COUNT shipIndex, QUEUE *pDstQueue,
 		COUNT crew_level);
-extern HSTARSHIP GetStarShipFromIndex (PQUEUE pShipQ, COUNT Index);
-extern BYTE NameCaptain (PQUEUE pQueue, STARSHIPPTR StarShipPtr);
+extern HLINK GetStarShipFromIndex (QUEUE *pShipQ, COUNT Index);
+extern BYTE NameCaptain (QUEUE *pQueue, SPECIES_ID SpeciesID);
 
 /* Possible values for the 'state' argument of
  * COUNT ActivateStarShip (COUNT which_ship, SIZE state)
  * See that function for more information.
  */
-#define CHECK_ALLIANCE -2
-#define ESCORT_WORTH 9995
-#define SPHERE_KNOWN 9996
-#define SPHERE_TRACKING 9997
-#define ESCORTING_FLAGSHIP 9998
-#define FEASIBILITY_STUDY 9999
+#define SET_ALLIED          0
+#define SET_NOT_ALLIED     -1
+#define CHECK_ALLIANCE     -2
+#define REMOVE_BUILT       -3
+#define ESCORT_WORTH       -4
+#define SPHERE_KNOWN       -5
+#define SPHERE_TRACKING    -6
+#define ESCORTING_FLAGSHIP -7
+#define FEASIBILITY_STUDY  -8
 		/* Check for how many escort ships there's still space */
 
 extern COUNT ActivateStarShip (COUNT which_ship, SIZE state);
-extern COUNT GetIndexFromStarShip (PQUEUE pShipQ, HSTARSHIP hStarShip);
-
-extern MEM_HANDLE load_ship (STARSHIPPTR StarShipPtr, BOOLEAN
-		LoadBattleData);
-extern void free_ship (STARSHIPPTR StarShipPtr, BOOLEAN FreeBattleData);
+extern COUNT GetIndexFromStarShip (QUEUE *pShipQ, HLINK hStarShip);
+extern int SetEscortCrewComplement (COUNT which_ship, COUNT crew_level,
+		BYTE captain);
+
+extern RACE_DESC *load_ship (SPECIES_ID SpeciesID, BOOLEAN LoadBattleData);
+extern void free_ship (RACE_DESC *RaceDescPtr, BOOLEAN FreeIconData,
+		BOOLEAN FreeBattleData);
 
 extern void DrawCrewFuelString (COORD y, SIZE state);
 extern void ClearShipStatus (COORD y);
 extern void OutlineShipStatus (COORD y);
-extern void InitShipStatus (STARSHIPPTR StarShipPtr, PRECT pClipRect);
-extern void DeltaStatistics (STARSHIPPTR StarShipPtr, SIZE crew_delta,
+extern void InitShipStatus (SHIP_INFO *ShipInfoPtr, BYTE captains_name_index,
+		RECT *pClipRect);
+extern void DeltaStatistics (SHIP_INFO *ShipInfoPtr, SIZE crew_delta,
 		SIZE energy_delta);
-extern void DrawBattleCrewAmount (STARSHIPPTR StarShipPtr);
+extern void DrawBattleCrewAmount (SHIP_INFO *ShipInfoPtr);
 
 #endif /* _BUILD_H */
 
diff -ruNp src.orig/sc2code/cleanup.c src/sc2code/cleanup.c
--- src.orig/sc2code/cleanup.c	2017-11-08 16:49:22 -0600
+++ src/sc2code/cleanup.c	2017-11-08 16:49:50 -0600
@@ -45,15 +45,14 @@ FreeKernel (void)
 	UninitKernel (TRUE);
 	UninitContexts ();
 
-	UNINIT_INSTANCES ();
 	UninitResourceSystem ();
 
 	UninitPlayerInput ();
 
 	DestroyDrawable (ReleaseDrawable (Screen));
-	DestroyContext (ReleaseContext (ScreenContext));
+	DestroyContext (ScreenContext);
 
-	UninitVideo ();
+	UninitVideoPlayer ();
 	UninitSound ();
 	UninitGraphics ();
 }
@@ -63,9 +62,9 @@ UninitContexts (void)
 {
 	UninitQueue (&disp_q);
 
-	DestroyContext (ReleaseContext (OffScreenContext));
-	DestroyContext (ReleaseContext (SpaceContext));
-	DestroyContext (ReleaseContext (StatusContext));
+	DestroyContext (OffScreenContext);
+	DestroyContext (SpaceContext);
+	DestroyContext (StatusContext);
 }
 
 static void
@@ -74,12 +73,12 @@ UninitKernel (BOOLEAN ships)
 	UninitSpace ();
 
 	DestroySound (ReleaseSound (MenuSounds));
-	DestroyFont (ReleaseFont (MicroFont));
+	DestroyFont (MicroFont);
 	DestroyStringTable (ReleaseStringTable (GameStrings));
 	DestroyDrawable (ReleaseDrawable (StatusFrame));
 	DestroyDrawable (ReleaseDrawable (ActivityFrame));
-	DestroyFont (ReleaseFont (TinyFont));
-	DestroyFont (ReleaseFont (StarConFont));
+	DestroyFont (TinyFont);
+	DestroyFont (StarConFont);
 
 	UninitQueue (&race_q[0]);
 	UninitQueue (&race_q[1]);
diff -ruNp src.orig/sc2code/clock.c src/sc2code/clock.c
--- src.orig/sc2code/clock.c	2017-11-08 16:49:22 -0600
+++ src/sc2code/clock.c	2017-11-08 16:49:50 -0600
@@ -113,13 +113,13 @@ clock_task_func(void* data)
 			}
 
 			LockMutex (GraphicsLock);
-			DrawStatusMessage (NULL_PTR);
+			DrawStatusMessage (NULL);
 			{
 				HEVENT hEvent;
 
 				while ((hEvent = GetHeadEvent ()))
 				{
-					EVENTPTR EventPtr;
+					EVENT *EventPtr;
 
 					LockEvent (hEvent, &EventPtr);
 
@@ -153,7 +153,7 @@ clock_task_func(void* data)
 			num_ticks = GetTimeCounter () - LastTime;
 			if (!OnAutoPilot)
 			{
-				DrawSISMessage (NULL_PTR);
+				DrawSISMessage (NULL);
 				cycle_index = delay_count = 0;
 			}
 			else if (delay_count > num_ticks)
@@ -301,8 +301,8 @@ SetGameClockRate (COUNT seconds_per_day)
 }
 
 BOOLEAN
-ValidateEvent (EVENT_TYPE type, PCOUNT pmonth_index, PCOUNT pday_index,
-		PCOUNT pyear_index)
+ValidateEvent (EVENT_TYPE type, COUNT *pmonth_index, COUNT *pday_index,
+		COUNT *pyear_index)
 {
 	COUNT month_index, day_index, year_index;
 
@@ -353,7 +353,7 @@ AddEvent (EVENT_TYPE type, COUNT month_i
 	else if (ValidateEvent (type, &month_index, &day_index, &year_index)
 			&& (hNewEvent = AllocEvent ()))
 	{
-		EVENTPTR EventPtr;
+		EVENT *EventPtr;
 
 		LockEvent (hNewEvent, &EventPtr);
 		EventPtr->day_index = (BYTE)day_index;
diff -ruNp src.orig/sc2code/clock.h src/sc2code/clock.h
--- src.orig/sc2code/clock.h	2017-11-08 16:49:22 -0600
+++ src/sc2code/clock.h	2017-11-08 16:49:50 -0600
@@ -39,20 +39,20 @@ typedef struct
 	DWORD TimeCounter;
 
 	QUEUE event_q;
+			/* Queue element is EVENT */
 } CLOCK_STATE;
-typedef CLOCK_STATE *PCLOCK_STATE;
 
-typedef QUEUE_HANDLE HEVENT;
+typedef HLINK HEVENT;
 
 typedef struct event
 {
+	// LINK elements; must be first
 	HEVENT pred, succ;
 
 	BYTE day_index, month_index;
 	COUNT year_index;
 	BYTE func_index;
 } EVENT;
-typedef EVENT *PEVENT;
 
 typedef enum
 {
@@ -60,22 +60,19 @@ typedef enum
 	RELATIVE_EVENT
 } EVENT_TYPE;
 
-#define EVENTPTR PEVENT
-
 #define AllocEvent() AllocLink (&GLOBAL (GameClock.event_q))
 #define PutEvent(h) PutQueue (&GLOBAL (GameClock.event_q), (h))
 #define InsertEvent(h,i) InsertQueue (&GLOBAL (GameClock.event_q), (h), (i))
 #define GetHeadEvent() GetHeadLink (&GLOBAL (GameClock.event_q))
 #define GetTailEvent() GetTailLink (&GLOBAL (GameClock.event_q))
-#define LockEvent(h,eptr) *(eptr) = (EVENTPTR)LockLink ( \
-		&GLOBAL (GameClock.event_q), (h))
+#define LockEvent(h,ppe) (*(ppe) = (EVENT*)LockLink (&GLOBAL (GameClock.event_q), h))
 #define UnlockEvent(h) UnlockLink (&GLOBAL (GameClock.event_q), (h))
 #define RemoveEvent(h) RemoveQueue (&GLOBAL (GameClock.event_q), (h))
 #define FreeEvent(h) FreeLink (&GLOBAL (GameClock.event_q), (h))
 #define GetPredEvent(l) _GetPredLink (l)
 #define GetSuccEvent(l) _GetSuccLink (l)
 #define ForAllEvents(callback, arg) ForAllLinks(&GLOBAL (GameClock.event_q), \
-		(void (*)(LINKPTR, void *)) (callback), (arg))
+		(void (*)(LINK *, void *)) (callback), (arg))
 
 				/* rates are in seconds per game day */
 #define HYPERSPACE_CLOCK_RATE 5
@@ -87,8 +84,8 @@ extern void SuspendGameClock (void);
 extern void ResumeGameClock (void);
 extern BOOLEAN GameClockRunning (void);
 extern void SetGameClockRate (COUNT seconds_per_day);
-extern BOOLEAN ValidateEvent (EVENT_TYPE type, PCOUNT pmonth_index,
-		PCOUNT pday_index, PCOUNT pyear_index);
+extern BOOLEAN ValidateEvent (EVENT_TYPE type, COUNT *pmonth_index,
+		COUNT *pday_index, COUNT *pyear_index);
 extern HEVENT AddEvent (EVENT_TYPE type, COUNT month_index, COUNT
 		day_index, COUNT year_index, BYTE func_index);
 extern void EventHandler (BYTE selector);
diff -ruNp src.orig/sc2code/cnctdlg.c src/sc2code/cnctdlg.c
--- src.orig/sc2code/cnctdlg.c	2017-11-08 16:49:22 -0600
+++ src/sc2code/cnctdlg.c	2017-11-08 16:49:50 -0600
@@ -47,8 +47,6 @@ typedef struct connect_dialog_state
 
 static void DrawConnectDialog (void);
 
-typedef CONNECT_DIALOG_STATE *PCONNECT_DIALOG_STATE;
-
 static WIDGET_MENU_SCREEN menu;
 static WIDGET_BUTTON buttons[3];
 static WIDGET_SLIDER slider;
@@ -67,7 +65,7 @@ static BOOLEAN done;
 /* This kind of sucks, but the Button callbacks need access to the
  * CONNECT_DIALOG_STATE, so we need a pointer to it */
 
-static PCONNECT_DIALOG_STATE current_state;
+static CONNECT_DIALOG_STATE *current_state;
 
 static FONT PlayerFont;
 
@@ -232,7 +230,7 @@ MCD_DrawTextEntry (WIDGET *_self, int x,
 		COUNT i;
 		RECT text_r;
 		BYTE char_deltas[WIDGET_TEXTENTRY_WIDTH];
-		PBYTE pchar_deltas;
+		BYTE *pchar_deltas;
 		RECT r;
 		SIZE leading;
 
@@ -311,7 +309,7 @@ MCD_DrawTextEntry (WIDGET *_self, int x,
  * refactoring, as redraw_menu () is the only real change. */
 
 static BOOLEAN
-OnTextEntryChange (PTEXTENTRY_STATE pTES)
+OnTextEntryChange (TEXTENTRY_STATE *pTES)
 {
 	WIDGET_TEXTENTRY *widget = (WIDGET_TEXTENTRY *) pTES->CbParam;
 
@@ -329,7 +327,7 @@ OnTextEntryChange (PTEXTENTRY_STATE pTES
 }
 
 static BOOLEAN
-OnTextEntryFrame (PTEXTENTRY_STATE pTES)
+OnTextEntryFrame (TEXTENTRY_STATE *pTES)
 {
 	WIDGET_TEXTENTRY *widget = (WIDGET_TEXTENTRY *) pTES->CbParam;
 
@@ -546,7 +544,7 @@ DrawConnectDialog (void)
 }
 
 static BOOLEAN
-DoMeleeConnectDialog (PCONNECT_DIALOG_STATE state)
+DoMeleeConnectDialog (CONNECT_DIALOG_STATE *state)
 {
 	BOOLEAN changed;
 
@@ -611,7 +609,7 @@ MeleeConnectDialog (int side)
 {
 	CONNECT_DIALOG_STATE state;
 
-	PlayerFont = CaptureFont ((FONT_REF)LoadFont (PLAYER_FONT));
+	PlayerFont = LoadFont (PLAYER_FONT);
 
 	state.Initialized = FALSE;
 	state.which_side = side;
@@ -620,11 +618,11 @@ MeleeConnectDialog (int side)
 
 	current_state = &state;
 
-	DoInput ((PVOID)&state, TRUE);
+	DoInput (&state, TRUE);
 
 	current_state = NULL;
 
-	DestroyFont (ReleaseFont (PlayerFont));
+	DestroyFont (PlayerFont);
 
 	return state.confirmed;
 }
diff -ruNp src.orig/sc2code/coderes.h src/sc2code/coderes.h
--- src.orig/sc2code/coderes.h	2017-11-08 16:49:22 -0600
+++ src/sc2code/coderes.h	2017-11-08 16:49:50 -0600
@@ -21,19 +21,16 @@
 
 #include "reslib.h"
 
-extern MEM_HANDLE LoadCodeResFile (PSTR pStr);
-extern BOOLEAN InstallCodeResType (COUNT code_type);
-extern MEM_HANDLE LoadCodeResInstance (RESOURCE res);
-extern PVOID CaptureCodeRes (MEM_HANDLE hCode, PVOID pData, PVOID *ppLocData);
-extern MEM_HANDLE ReleaseCodeRes (PVOID CodeRef);
-extern BOOLEAN DestroyCodeRes (MEM_HANDLE hCode);
+extern BOOLEAN InstallCodeResType (void);
+extern void *LoadCodeResInstance (RESOURCE res);
+extern void *CaptureCodeRes (void *hCode, void *pData, void **ppLocData);
+extern void *ReleaseCodeRes (void *CodeRef);
+extern BOOLEAN DestroyCodeRes (void *hCode);
 
 typedef struct
 {
-	MEM_HANDLE hCode;
 	UWORD size;
 } CODE_REF;
-typedef CODE_REF *PCODE_REF;
 
 #endif /* _CODERES_H */
 
diff -ruNp src.orig/sc2code/collide.c src/sc2code/collide.c
--- src.orig/sc2code/collide.c	2017-11-08 16:49:22 -0600
+++ src/sc2code/collide.c	2017-11-08 16:49:50 -0600
@@ -27,7 +27,7 @@
 //#define DEBUG_COLLIDE
 
 void
-collide (ELEMENTPTR ElementPtr0, ELEMENTPTR ElementPtr1)
+collide (ELEMENT *ElementPtr0, ELEMENT *ElementPtr1)
 {
 	SIZE speed;
 	SIZE dx0, dy0, dx1, dy1, dx_rel, dy_rel;
@@ -103,7 +103,7 @@ collide (ELEMENTPTR ElementPtr0, ELEMENT
 		{
 			if (ElementPtr0->state_flags & PLAYER_SHIP)
 			{
-				STARSHIPPTR StarShipPtr;
+				STARSHIP *StarShipPtr;
 
 				GetElementStarShip (ElementPtr0, &StarShipPtr);
 				StarShipPtr->cur_status_flags &=
@@ -140,7 +140,7 @@ collide (ELEMENTPTR ElementPtr0, ELEMENT
 		{
 			if (ElementPtr1->state_flags & PLAYER_SHIP)
 			{
-				STARSHIPPTR StarShipPtr;
+				STARSHIP *StarShipPtr;
 
 				GetElementStarShip (ElementPtr1, &StarShipPtr);
 				StarShipPtr->cur_status_flags &=
diff -ruNp src.orig/sc2code/collide.h src/sc2code/collide.h
--- src.orig/sc2code/collide.h	2017-11-08 16:49:22 -0600
+++ src/sc2code/collide.h	2017-11-08 16:49:50 -0600
@@ -57,7 +57,7 @@
 			 (eptr)->next.image.frame); \
 }
 
-extern void collide (ELEMENTPTR ElementPtr0, ELEMENTPTR ElementPtr1);
+extern void collide (ELEMENT *ElementPtr0, ELEMENT *ElementPtr1);
 
 #endif /* _COLLIDE_H */
 
diff -ruNp src.orig/sc2code/comm/arilou/arilouc.c src/sc2code/comm/arilou/arilouc.c
--- src.orig/sc2code/comm/arilou/arilouc.c	2017-11-08 16:49:22 -0600
+++ src/sc2code/comm/arilou/arilouc.c	2017-11-08 16:49:50 -0600
@@ -25,20 +25,20 @@
 
 static LOCDATA arilou_desc =
 {
-	NULL_PTR, /* init_encounter_func */
-	NULL_PTR, /* post_encounter_func */
-	NULL_PTR, /* uninit_encounter_func */
-	(FRAME)ARILOU_PMAP_ANIM, /* AlienFrame */
-	(FONT)ARILOU_FONT, /* AlienFont */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	ARILOU_PMAP_ANIM, /* AlienFrame */
+	ARILOU_FONT, /* AlienFont */
 	WHITE_COLOR, /* AlienTextFColor */
 	BLACK_COLOR, /* AlienTextBColor */
 	{0, 0}, /* AlienTextBaseline */
 	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
 	ALIGN_CENTER, /* AlienTextAlign */
 	VALIGN_TOP, /* AlienTextValign */
-	(COLORMAP)ARILOU_COLOR_MAP, /* AlienColorMap */
+	ARILOU_COLOR_MAP, /* AlienColorMap */
 	ARILOU_MUSIC, /* AlienSong */
-	0, /* AlienAltSong */
+	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	ARILOU_CONVERSATION_PHRASES, /* PlayerPhrases */
 	20, /* NumAnimations */
@@ -220,7 +220,11 @@ static LOCDATA arilou_desc =
 		ONE_SECOND / 12, 0, /* RestartRate */
 		0, /* BlockMask */
 	},
-	NULL_PTR, /* AlienNumberSpeech - none */
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
 };
 
 static void
@@ -822,10 +826,10 @@ post_arilou_enc (void)
 	}
 }
 
-LOCDATAPTR
+LOCDATA*
 init_arilou_comm (void)
 {
-	LOCDATAPTR retval;
+	LOCDATA *retval;
 
 	arilou_desc.init_encounter_func = Intro;
 	arilou_desc.post_encounter_func = post_arilou_enc;
diff -ruNp src.orig/sc2code/comm/arilou/ifontres.h src/sc2code/comm/arilou/ifontres.h
--- src.orig/sc2code/comm/arilou/ifontres.h	2017-11-08 16:49:22 -0600
+++ src/sc2code/comm/arilou/ifontres.h	2017-11-08 16:49:50 -0600
@@ -1,3 +1,5 @@
-#define ARILOU_FONT 0x00200003L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ARILOU_FONT "comm.arilou.font"
diff -ruNp src.orig/sc2code/comm/arilou/igfxres.h src/sc2code/comm/arilou/igfxres.h
--- src.orig/sc2code/comm/arilou/igfxres.h	2017-11-08 16:49:22 -0600
+++ src/sc2code/comm/arilou/igfxres.h	2017-11-08 16:49:50 -0600
@@ -1,4 +1,6 @@
-#define ARILOU_PMAP_ANIM 0x00200002L
-#define ARILOU_COLOR_MAP 0x00200104L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ARILOU_COLOR_MAP "comm.arilou.colortable"
+#define ARILOU_PMAP_ANIM "comm.arilou.graphics"
diff -ruNp src.orig/sc2code/comm/arilou/imusicre.h src/sc2code/comm/arilou/imusicre.h
--- src.orig/sc2code/comm/arilou/imusicre.h	2017-11-08 16:49:22 -0600
+++ src/sc2code/comm/arilou/imusicre.h	2017-11-08 16:49:50 -0600
@@ -1,3 +1,5 @@
-#define ARILOU_MUSIC 0x00200006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ARILOU_MUSIC "comm.arilou.music"
diff -ruNp src.orig/sc2code/comm/arilou/istrtab.h src/sc2code/comm/arilou/istrtab.h
--- src.orig/sc2code/comm/arilou/istrtab.h	2017-11-08 16:49:22 -0600
+++ src/sc2code/comm/arilou/istrtab.h	2017-11-08 16:49:50 -0600
@@ -1,3 +1,5 @@
-#define ARILOU_CONVERSATION_PHRASES 0x00200004L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ARILOU_CONVERSATION_PHRASES "comm.arilou.dialogue"
diff -ruNp src.orig/sc2code/comm/blackur/blackurc.c src/sc2code/comm/blackur/blackurc.c
--- src.orig/sc2code/comm/blackur/blackurc.c	2017-11-08 16:49:23 -0600
+++ src/sc2code/comm/blackur/blackurc.c	2017-11-08 16:49:50 -0600
@@ -22,20 +22,20 @@
 
 static LOCDATA blackurq_desc =
 {
-	NULL_PTR, /* init_encounter_func */
-	NULL_PTR, /* post_encounter_func */
-	NULL_PTR, /* uninit_encounter_func */
-	(FRAME)BLACKURQ_PMAP_ANIM, /* AlienFrame */
-	(FONT)BLACKURQ_FONT, /* AlienFont */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	BLACKURQ_PMAP_ANIM, /* AlienFrame */
+	BLACKURQ_FONT, /* AlienFont */
 	WHITE_COLOR, /* AlienTextFColor */
 	BLACK_COLOR, /* AlienTextBColor */
 	{0, 0}, /* AlienTextBaseline */
 	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
 	ALIGN_CENTER, /* AlienTextAlign */
 	VALIGN_TOP, /* AlienTextValign */
-	(COLORMAP)BLACKURQ_COLOR_MAP, /* AlienColorMap */
+	BLACKURQ_COLOR_MAP, /* AlienColorMap */
 	BLACKURQ_MUSIC, /* AlienSong */
-	0, /* AlienAltSong */
+	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	BLACKURQ_CONVERSATION_PHRASES, /* PlayerPhrases */
 	8, /* NumAnimations */
@@ -122,7 +122,11 @@ static LOCDATA blackurq_desc =
 		ONE_SECOND / 12, 0, /* RestartRate */
 		0, /* BlockMask */
 	},
-	NULL_PTR, /* AlienNumberSpeech - none */
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
 };
 
 static void
@@ -535,10 +539,10 @@ post_blackurq_enc (void)
 	// nothing defined so far
 }
 
-LOCDATAPTR
+LOCDATA*
 init_blackurq_comm (void)
 {
-	LOCDATAPTR retval;
+	LOCDATA *retval;
 
 	blackurq_desc.init_encounter_func = Intro;
 	blackurq_desc.post_encounter_func = post_blackurq_enc;
diff -ruNp src.orig/sc2code/comm/blackur/ifontres.h src/sc2code/comm/blackur/ifontres.h
--- src.orig/sc2code/comm/blackur/ifontres.h	2017-11-08 16:49:23 -0600
+++ src/sc2code/comm/blackur/ifontres.h	2017-11-08 16:49:50 -0600
@@ -1,3 +1,5 @@
-#define BLACKURQ_FONT 0x00200003L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define BLACKURQ_FONT "comm.kohrah.font"
diff -ruNp src.orig/sc2code/comm/blackur/igfxres.h src/sc2code/comm/blackur/igfxres.h
--- src.orig/sc2code/comm/blackur/igfxres.h	2017-11-08 16:49:23 -0600
+++ src/sc2code/comm/blackur/igfxres.h	2017-11-08 16:49:50 -0600
@@ -1,3 +1,5 @@
-#define BLACKURQ_PMAP_ANIM 0x00200002L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define BLACKURQ_PMAP_ANIM "comm.kohrah.graphics"
diff -ruNp src.orig/sc2code/comm/blackur/imusicre.h src/sc2code/comm/blackur/imusicre.h
--- src.orig/sc2code/comm/blackur/imusicre.h	2017-11-08 16:49:23 -0600
+++ src/sc2code/comm/blackur/imusicre.h	2017-11-08 16:49:50 -0600
@@ -1,3 +1,5 @@
-#define BLACKURQ_MUSIC 0x00200006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define BLACKURQ_MUSIC "comm.kohrah.music"
diff -ruNp src.orig/sc2code/comm/blackur/istrtab.h src/sc2code/comm/blackur/istrtab.h
--- src.orig/sc2code/comm/blackur/istrtab.h	2017-11-08 16:49:23 -0600
+++ src/sc2code/comm/blackur/istrtab.h	2017-11-08 16:49:50 -0600
@@ -1,3 +1,6 @@
-#define BLACKURQ_CONVERSATION_PHRASES 0x00200004L
-#define BLACKURQ_COLOR_MAP 0x00200104L
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define BLACKURQ_COLOR_MAP "comm.kohrah.colortable"
+#define BLACKURQ_CONVERSATION_PHRASES "comm.kohrah.dialogue"
diff -ruNp src.orig/sc2code/comm/chmmr/chmmrc.c src/sc2code/comm/chmmr/chmmrc.c
--- src.orig/sc2code/comm/chmmr/chmmrc.c	2017-11-08 16:49:23 -0600
+++ src/sc2code/comm/chmmr/chmmrc.c	2017-11-08 16:49:51 -0600
@@ -25,20 +25,20 @@
 
 static LOCDATA chmmr_desc =
 {
-	NULL_PTR, /* init_encounter_func */
-	NULL_PTR, /* post_encounter_func */
-	NULL_PTR, /* uninit_encounter_func */
-	(FRAME)CHMMR_PMAP_ANIM, /* AlienFrame */
-	(FONT)CHMMR_FONT, /* AlienFont */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	CHMMR_PMAP_ANIM, /* AlienFrame */
+	CHMMR_FONT, /* AlienFont */
 	WHITE_COLOR, /* AlienTextFColor */
 	BLACK_COLOR, /* AlienTextBColor */
 	{0, 0}, /* AlienTextBaseline */
 	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
 	ALIGN_CENTER, /* AlienTextAlign */
 	VALIGN_TOP, /* AlienTextValign */
-	(COLORMAP)CHMMR_COLOR_MAP, /* AlienColorMap */
+	CHMMR_COLOR_MAP, /* AlienColorMap */
 	CHMMR_MUSIC, /* AlienSong */
-	0, /* AlienAltSong */
+	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	CHMMR_CONVERSATION_PHRASES, /* PlayerPhrases */
 	6, /* NumAnimations */
@@ -108,7 +108,11 @@ static LOCDATA chmmr_desc =
 		ONE_SECOND / 60, 0, /* RestartRate */
 		0, /* BlockMask */
 	},
-	NULL_PTR, /* AlienNumberSpeech - none */
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
 };
 
 static void
@@ -128,7 +132,7 @@ ExitConversation (RESPONSE_REF R)
 
 		NPCPhrase (TAKE_2_WEEKS);
 
-		ActivateStarShip (CHMMR_SHIP, 0);
+		ActivateStarShip (CHMMR_SHIP, SET_ALLIED);
 
 		SET_GAME_STATE (CHMMR_HOME_VISITS, 0);
 		SET_GAME_STATE (CHMMR_STACK, 0);
@@ -239,7 +243,7 @@ NotReady (RESPONSE_REF R)
 	{
 		NPCPhrase (USE_OUR_SHIPS_BEFORE);
 
-		ActivateStarShip (CHMMR_SHIP, 0);
+		ActivateStarShip (CHMMR_SHIP, SET_ALLIED);
 	}
 	else if (PLAYER_SAID (R, where_weapon))
 	{
@@ -292,7 +296,7 @@ ImproveBomb (RESPONSE_REF R)
 	{
 		NPCPhrase (USE_OUR_SHIPS_AFTER);
 
-		ActivateStarShip (CHMMR_SHIP, 0);
+		ActivateStarShip (CHMMR_SHIP, SET_ALLIED);
 	}
 
 	if (PHRASE_ENABLED (what_now))
@@ -570,6 +574,9 @@ Intro (void)
 		}
 		else
 		{
+			HFLEETINFO hChmmr;
+			FLEET_INFO *ChmmrPtr;
+
 			NPCPhrase (WE_ARE_FREE);
 
 			if (NumVisits)
@@ -587,13 +594,27 @@ Intro (void)
 						i_am_captain1,
 						GLOBAL_SIS (ShipName),
 						i_am_captain2,
-						NULL_PTR);
+						(UNICODE*)NULL);
 				DoResponsePhrase (i_am_captain0, ChmmrFree, shared_phrase_buf);
 				Response (i_am_savior, ChmmrFree);
 				Response (i_am_silly, ChmmrFree);
 			}
 
 			SET_GAME_STATE (CHMMR_UNLEASHED, 1);
+
+			// Setup a Chmmr sphere-of-influence, now that they're out
+			// of their shell.  EncounterPercent for the Chmmr is 0,
+			// so this is purely decorative.
+			hChmmr = GetStarShipFromIndex (&GLOBAL (avail_race_q), CHMMR_SHIP);
+			ChmmrPtr = LockFleetInfo (&GLOBAL (avail_race_q), hChmmr);
+			if (ChmmrPtr)
+			{
+				ChmmrPtr->actual_strength = 1800 / SPHERE_RADIUS_INCREMENT * 2;
+				ChmmrPtr->loc.x = 742;
+				ChmmrPtr->loc.y = 2268;
+				ActivateStarShip (CHMMR_SHIP, SPHERE_TRACKING);
+			}
+			UnlockFleetInfo (&GLOBAL (avail_race_q), hChmmr);
 		}
 		SET_GAME_STATE (CHMMR_HOME_VISITS, NumVisits);
 	}
@@ -611,10 +632,10 @@ post_chmmr_enc (void)
 	// nothing defined so far
 }
 
-LOCDATAPTR
+LOCDATA*
 init_chmmr_comm (void)
 {
-	LOCDATAPTR retval;
+	LOCDATA *retval;
 
 	chmmr_desc.init_encounter_func = Intro;
 	chmmr_desc.post_encounter_func = post_chmmr_enc;
diff -ruNp src.orig/sc2code/comm/chmmr/ifontres.h src/sc2code/comm/chmmr/ifontres.h
--- src.orig/sc2code/comm/chmmr/ifontres.h	2017-11-08 16:49:23 -0600
+++ src/sc2code/comm/chmmr/ifontres.h	2017-11-08 16:49:51 -0600
@@ -1,3 +1,5 @@
-#define CHMMR_FONT 0x00200003L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define CHMMR_FONT "comm.chmmr.font"
diff -ruNp src.orig/sc2code/comm/chmmr/igfxres.h src/sc2code/comm/chmmr/igfxres.h
--- src.orig/sc2code/comm/chmmr/igfxres.h	2017-11-08 16:49:23 -0600
+++ src/sc2code/comm/chmmr/igfxres.h	2017-11-08 16:49:51 -0600
@@ -1,3 +1,5 @@
-#define CHMMR_PMAP_ANIM 0x00200002L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define CHMMR_PMAP_ANIM "comm.chmmr.graphics"
diff -ruNp src.orig/sc2code/comm/chmmr/imusicre.h src/sc2code/comm/chmmr/imusicre.h
--- src.orig/sc2code/comm/chmmr/imusicre.h	2017-11-08 16:49:23 -0600
+++ src/sc2code/comm/chmmr/imusicre.h	2017-11-08 16:49:51 -0600
@@ -1,3 +1,5 @@
-#define CHMMR_MUSIC 0x00200006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define CHMMR_MUSIC "comm.chmmr.music"
diff -ruNp src.orig/sc2code/comm/chmmr/istrtab.h src/sc2code/comm/chmmr/istrtab.h
--- src.orig/sc2code/comm/chmmr/istrtab.h	2017-11-08 16:49:23 -0600
+++ src/sc2code/comm/chmmr/istrtab.h	2017-11-08 16:49:51 -0600
@@ -1,4 +1,6 @@
-#define CHMMR_CONVERSATION_PHRASES 0x00200004L
-#define CHMMR_COLOR_MAP 0x00200104L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define CHMMR_COLOR_MAP "comm.chmmr.colortable"
+#define CHMMR_CONVERSATION_PHRASES "comm.chmmr.dialogue"
diff -ruNp src.orig/sc2code/comm/comandr/comandr.c src/sc2code/comm/comandr/comandr.c
--- src.orig/sc2code/comm/comandr/comandr.c	2017-11-08 16:49:23 -0600
+++ src/sc2code/comm/comandr/comandr.c	2017-11-08 16:49:51 -0600
@@ -24,11 +24,11 @@
 
 static LOCDATA commander_desc =
 {
-	NULL_PTR, /* init_encounter_func */
-	NULL_PTR, /* post_encounter_func */
-	NULL_PTR, /* uninit_encounter_func */
-	(FRAME)COMMANDER_PMAP_ANIM, /* AlienFrame */
-	(FONT)COMMANDER_FONT, /* AlienFont */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	COMMANDER_PMAP_ANIM, /* AlienFrame */
+	COMMANDER_FONT, /* AlienFont */
 	WHITE_COLOR, /* AlienTextFColor */
 	BLACK_COLOR, /* AlienTextBColor */
 	{0, 0}, /* AlienTextBaseline */
@@ -37,7 +37,7 @@ static LOCDATA commander_desc =
 	VALIGN_MIDDLE, /* AlienTextValign */
 	COMMANDER_COLOR_MAP, /* AlienColorMap */
 	COMMANDER_MUSIC, /* AlienSong */
-	0, /* AlienAltSong */
+	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	COMMANDER_CONVERSATION_PHRASES, /* PlayerPhrases */
 	3, /* NumAnimations */
@@ -83,7 +83,11 @@ static LOCDATA commander_desc =
 		ONE_SECOND * 7 / 60, ONE_SECOND / 12, /* RestartRate */
 		0, /* BlockMask */
 	},
-	NULL_PTR, /* AlienNumberSpeech - none */
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
 };
 
 static void
@@ -140,7 +144,7 @@ ByeBye (RESPONSE_REF R)
 				name_40,
 				GLOBAL_SIS (CommanderName),
 				name_41,
-				NULL_PTR);
+				(UNICODE*)NULL);
 
 		NPCPhrase (THIS_MAY_SEEM_SILLY);
 
@@ -194,7 +198,7 @@ NoRadioactives (RESPONSE_REF R)
 		NPCPhrase (ABOUT_TIME);
 
 		if (GLOBAL_SIS (ElementAmounts[RADIOACTIVE]))
-			GiveRadios (NULL_PTR);
+			GiveRadios (0);
 		else
 		{
 			Response (i_lied, NoRadioactives);
@@ -255,7 +259,7 @@ NoRadioactives (RESPONSE_REF R)
 		}
 
 		if (GLOBAL_SIS (ElementAmounts[RADIOACTIVE]))
-			GiveRadios (NULL_PTR);
+			GiveRadios (0);
 		else
 		{
 			if (GLOBAL_SIS (NumLanders) == 0
@@ -559,7 +563,7 @@ RevealSelf (RESPONSE_REF R)
 						we_are_vindicator1,
 						GLOBAL_SIS (ShipName),
 						we_are_vindicator2,
-						NULL_PTR);
+						(UNICODE*)NULL);
 				DoResponsePhrase (we_are_vindicator0, RevealSelf, shared_phrase_buf);
 			}
 			else if (PHRASE_ENABLED (our_mission_was_secret))
@@ -596,7 +600,7 @@ GiveRadios (RESPONSE_REF R)
 
 		AlienTalkSegue ((COUNT)~0);
 
-		RevealSelf (NULL_PTR);
+		RevealSelf (0);
 	}
 	else
 	{
@@ -628,11 +632,11 @@ Intro (void)
 		{
 			if (GET_GAME_STATE (MOONBASE_DESTROYED) == 0)
 			{
-				TellMoonBase (NULL_PTR);
+				TellMoonBase (0);
 			}
 			else
 			{
-				BaseDestroyed (NULL_PTR);
+				BaseDestroyed (0);
 			}
 		}
 		else
@@ -642,9 +646,9 @@ Intro (void)
 			NPCPhrase (DO_YOU_HAVE_RADIO_THIS_TIME);
 
 			if (GLOBAL_SIS (ElementAmounts[RADIOACTIVE]))
-				GiveRadios (NULL_PTR);
+				GiveRadios (0);
 			else
-				AskAfterRadios (NULL_PTR);
+				AskAfterRadios (0);
 		}
 	}
 	else /* first visit */
@@ -660,8 +664,7 @@ Intro (void)
 				no_but_well_help0,
 				GLOBAL_SIS (ShipName),
 				no_but_well_help1,
-				NULL_PTR
-				);
+				(UNICODE*)NULL);
 		DoResponsePhrase (no_but_well_help0, NoRadioactives, shared_phrase_buf);
 		Response (yes_this_is_supply_ship, NoRadioactives);
 		Response (what_slave_planet, NoRadioactives);
@@ -680,10 +683,10 @@ post_commander_enc (void)
 	// nothing defined so far
 }
 
-LOCDATAPTR
+LOCDATA*
 init_commander_comm ()
 {
-	LOCDATAPTR retval;
+	LOCDATA *retval;
 
 	commander_desc.init_encounter_func = Intro;
 	commander_desc.post_encounter_func = post_commander_enc;
@@ -699,7 +702,7 @@ init_commander_comm ()
 	{	
 		commander_desc.AlienAmbientArray[2].AnimFlags &= ~ANIM_DISABLED;
 		// use alternate 'low-power' track if available
-		commander_desc.AlienAltSong = COMMANDER_LOWPOW_MUSIC;
+		commander_desc.AlienAltSongRes = COMMANDER_LOWPOW_MUSIC;
 		commander_desc.AlienSongFlags |= LDASF_USE_ALTERNATE;
 	}
 
diff -ruNp src.orig/sc2code/comm/comandr/ifontres.h src/sc2code/comm/comandr/ifontres.h
--- src.orig/sc2code/comm/comandr/ifontres.h	2017-11-08 16:49:23 -0600
+++ src/sc2code/comm/comandr/ifontres.h	2017-11-08 16:49:51 -0600
@@ -1,3 +1,5 @@
-#define COMMANDER_FONT 0x00200003L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define COMMANDER_FONT "comm.commander.font"
diff -ruNp src.orig/sc2code/comm/comandr/igfxres.h src/sc2code/comm/comandr/igfxres.h
--- src.orig/sc2code/comm/comandr/igfxres.h	2017-11-08 16:49:23 -0600
+++ src/sc2code/comm/comandr/igfxres.h	2017-11-08 16:49:51 -0600
@@ -1,3 +1,5 @@
-#define COMMANDER_PMAP_ANIM 0x00200002L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define COMMANDER_PMAP_ANIM "comm.commander.graphics"
diff -ruNp src.orig/sc2code/comm/comandr/imusicre.h src/sc2code/comm/comandr/imusicre.h
--- src.orig/sc2code/comm/comandr/imusicre.h	2017-11-08 16:49:23 -0600
+++ src/sc2code/comm/comandr/imusicre.h	2017-11-08 16:49:51 -0600
@@ -1,5 +1,7 @@
-#define COMMANDER_MUSIC 0x00200006L
-
-#define STARBASE_ALT_MUSIC 0x00800106L
-#define COMMANDER_LOWPOW_MUSIC 0x00a00206L
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define COMMANDER_LOWPOW_MUSIC "comm.comlowpw.music"
+#define COMMANDER_MUSIC "comm.commander.music"
+#define STARBASE_ALT_MUSIC "comm.starbase.music"
diff -ruNp src.orig/sc2code/comm/comandr/istrtab.h src/sc2code/comm/comandr/istrtab.h
--- src.orig/sc2code/comm/comandr/istrtab.h	2017-11-08 16:49:23 -0600
+++ src/sc2code/comm/comandr/istrtab.h	2017-11-08 16:49:51 -0600
@@ -1,5 +1,7 @@
-#define COMMANDER_COLOR_MAP 0x00200004L
-#define COMMANDER_CONVERSATION_PHRASES 0x00400104L
-#define STARBASE_CONVERSATION_PHRASES 0x00600204L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define COMMANDER_COLOR_MAP "comm.commander.colortable"
+#define COMMANDER_CONVERSATION_PHRASES "comm.commander.dialogue"
+#define STARBASE_CONVERSATION_PHRASES "comm.starbase.dialogue"
diff -ruNp src.orig/sc2code/comm/druuge/druugec.c src/sc2code/comm/druuge/druugec.c
--- src.orig/sc2code/comm/druuge/druugec.c	2017-11-08 16:49:23 -0600
+++ src/sc2code/comm/druuge/druugec.c	2017-11-08 16:49:51 -0600
@@ -26,20 +26,20 @@
 
 static LOCDATA druuge_desc =
 {
-	NULL_PTR, /* init_encounter_func */
-	NULL_PTR, /* post_encounter_func */
-	NULL_PTR, /* uninit_encounter_func */
-	(FRAME)DRUUGE_PMAP_ANIM, /* AlienFrame */
-	(FONT)DRUUGE_FONT, /* AlienFont */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	DRUUGE_PMAP_ANIM, /* AlienFrame */
+	DRUUGE_FONT, /* AlienFont */
 	WHITE_COLOR, /* AlienTextFColor */
 	BLACK_COLOR, /* AlienTextBColor */
 	{0, 0}, /* AlienTextBaseline */
 	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
 	ALIGN_CENTER, /* AlienTextAlign */
 	VALIGN_MIDDLE, /* AlienTextValign */
-	(COLORMAP)DRUUGE_COLOR_MAP, /* AlienColorMap */
+	DRUUGE_COLOR_MAP, /* AlienColorMap */
 	DRUUGE_MUSIC, /* AlienSong */
-	0, /* AlienAltSong */
+	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	DRUUGE_CONVERSATION_PHRASES, /* PlayerPhrases */
 	11, /* NumAnimations */
@@ -149,7 +149,11 @@ static LOCDATA druuge_desc =
 		ONE_SECOND / 12, ONE_SECOND / 12, /* RestartRate */
 		0, /* BlockMask */
 	},
-	NULL_PTR, /* AlienNumberSpeech - none */
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
 };
 
 static COUNT SlaveryCount = 0;
@@ -897,10 +901,10 @@ post_druuge_enc (void)
 	}
 }
 
-LOCDATAPTR
+LOCDATA*
 init_druuge_comm (void)
 {
-	LOCDATAPTR retval;
+	LOCDATA *retval;
 
 	druuge_desc.init_encounter_func = Intro;
 	druuge_desc.post_encounter_func = post_druuge_enc;
diff -ruNp src.orig/sc2code/comm/druuge/ifontres.h src/sc2code/comm/druuge/ifontres.h
--- src.orig/sc2code/comm/druuge/ifontres.h	2017-11-08 16:49:23 -0600
+++ src/sc2code/comm/druuge/ifontres.h	2017-11-08 16:49:51 -0600
@@ -1,3 +1,5 @@
-#define DRUUGE_FONT 0x00200003L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define DRUUGE_FONT "comm.druuge.font"
diff -ruNp src.orig/sc2code/comm/druuge/igfxres.h src/sc2code/comm/druuge/igfxres.h
--- src.orig/sc2code/comm/druuge/igfxres.h	2017-11-08 16:49:23 -0600
+++ src/sc2code/comm/druuge/igfxres.h	2017-11-08 16:49:51 -0600
@@ -1,3 +1,5 @@
-#define DRUUGE_PMAP_ANIM 0x00200002L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define DRUUGE_PMAP_ANIM "comm.druuge.graphics"
diff -ruNp src.orig/sc2code/comm/druuge/imusicre.h src/sc2code/comm/druuge/imusicre.h
--- src.orig/sc2code/comm/druuge/imusicre.h	2017-11-08 16:49:23 -0600
+++ src/sc2code/comm/druuge/imusicre.h	2017-11-08 16:49:51 -0600
@@ -1,3 +1,5 @@
-#define DRUUGE_MUSIC 0x00200006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define DRUUGE_MUSIC "comm.druuge.music"
diff -ruNp src.orig/sc2code/comm/druuge/istrtab.h src/sc2code/comm/druuge/istrtab.h
--- src.orig/sc2code/comm/druuge/istrtab.h	2017-11-08 16:49:23 -0600
+++ src/sc2code/comm/druuge/istrtab.h	2017-11-08 16:49:51 -0600
@@ -1,3 +1,6 @@
-#define DRUUGE_CONVERSATION_PHRASES 0x00200004L
-#define DRUUGE_COLOR_MAP 0x00200104L
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define DRUUGE_COLOR_MAP "comm.druuge.colortable"
+#define DRUUGE_CONVERSATION_PHRASES "comm.druuge.dialogue"
diff -ruNp src.orig/sc2code/comm/ilwrath/ifontres.h src/sc2code/comm/ilwrath/ifontres.h
--- src.orig/sc2code/comm/ilwrath/ifontres.h	2017-11-08 16:49:23 -0600
+++ src/sc2code/comm/ilwrath/ifontres.h	2017-11-08 16:49:51 -0600
@@ -1,3 +1,5 @@
-#define ILWRATH_FONT 0x00200003L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ILWRATH_FONT "comm.ilwrath.font"
diff -ruNp src.orig/sc2code/comm/ilwrath/igfxres.h src/sc2code/comm/ilwrath/igfxres.h
--- src.orig/sc2code/comm/ilwrath/igfxres.h	2017-11-08 16:49:23 -0600
+++ src/sc2code/comm/ilwrath/igfxres.h	2017-11-08 16:49:51 -0600
@@ -1,3 +1,5 @@
-#define ILWRATH_PMAP_ANIM 0x00200002L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ILWRATH_PMAP_ANIM "comm.ilwrath.graphics"
diff -ruNp src.orig/sc2code/comm/ilwrath/ilwrathc.c src/sc2code/comm/ilwrath/ilwrathc.c
--- src.orig/sc2code/comm/ilwrath/ilwrathc.c	2017-11-08 16:49:23 -0600
+++ src/sc2code/comm/ilwrath/ilwrathc.c	2017-11-08 16:49:51 -0600
@@ -25,20 +25,20 @@
 
 static LOCDATA ilwrath_desc =
 {
-	NULL_PTR, /* init_encounter_func */
-	NULL_PTR, /* post_encounter_func */
-	NULL_PTR, /* uninit_encounter_func */
-	(FRAME)ILWRATH_PMAP_ANIM, /* AlienFrame */
-	(FONT)ILWRATH_FONT, /* AlienFont */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	ILWRATH_PMAP_ANIM, /* AlienFrame */
+	ILWRATH_FONT, /* AlienFont */
 	WHITE_COLOR, /* AlienTextFColor */
 	BLACK_COLOR, /* AlienTextBColor */
 	{0, 0}, /* AlienTextBaseline */
 	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
 	ALIGN_CENTER, /* AlienTextAlign */
 	VALIGN_MIDDLE, /* AlienTextValign */
-	(COLORMAP)ILWRATH_COLOR_MAP, /* AlienColorMap */
+	ILWRATH_COLOR_MAP, /* AlienColorMap */
 	ILWRATH_MUSIC, /* AlienSong */
-	0, /* AlienAltSong */
+	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	ILWRATH_CONVERSATION_PHRASES, /* PlayerPhrases */
 	4, /* NumAnimations */
@@ -92,7 +92,11 @@ static LOCDATA ilwrath_desc =
 		ONE_SECOND / 12, 0, /* RestartRate */
 		0, /* BlockMask */
 	},
-	NULL_PTR, /* AlienNumberSpeech - none */
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
 };
 
 static void
@@ -615,10 +619,10 @@ post_ilwrath_enc (void)
 	// nothing defined so far
 }
 
-LOCDATAPTR
+LOCDATA*
 init_ilwrath_comm (void)
 {
-	LOCDATAPTR retval;
+	LOCDATA *retval;
 
 	ilwrath_desc.init_encounter_func = Intro;
 	ilwrath_desc.post_encounter_func = post_ilwrath_enc;
diff -ruNp src.orig/sc2code/comm/ilwrath/imusicre.h src/sc2code/comm/ilwrath/imusicre.h
--- src.orig/sc2code/comm/ilwrath/imusicre.h	2017-11-08 16:49:23 -0600
+++ src/sc2code/comm/ilwrath/imusicre.h	2017-11-08 16:49:51 -0600
@@ -1,3 +1,5 @@
-#define ILWRATH_MUSIC 0x00200006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ILWRATH_MUSIC "comm.ilwrath.music"
diff -ruNp src.orig/sc2code/comm/ilwrath/istrtab.h src/sc2code/comm/ilwrath/istrtab.h
--- src.orig/sc2code/comm/ilwrath/istrtab.h	2017-11-08 16:49:23 -0600
+++ src/sc2code/comm/ilwrath/istrtab.h	2017-11-08 16:49:51 -0600
@@ -1,3 +1,6 @@
-#define ILWRATH_CONVERSATION_PHRASES 0x00200004L
-#define ILWRATH_COLOR_MAP 0x00200104L
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ILWRATH_COLOR_MAP "comm.ilwrath.colortable"
+#define ILWRATH_CONVERSATION_PHRASES "comm.ilwrath.dialogue"
diff -ruNp src.orig/sc2code/comm/melnorm/ifontres.h src/sc2code/comm/melnorm/ifontres.h
--- src.orig/sc2code/comm/melnorm/ifontres.h	2017-11-08 16:49:24 -0600
+++ src/sc2code/comm/melnorm/ifontres.h	2017-11-08 16:49:51 -0600
@@ -1,3 +1,5 @@
-#define MELNORME_FONT 0x00200003L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define MELNORME_FONT "comm.melnorme.font"
diff -ruNp src.orig/sc2code/comm/melnorm/igfxres.h src/sc2code/comm/melnorm/igfxres.h
--- src.orig/sc2code/comm/melnorm/igfxres.h	2017-11-08 16:49:24 -0600
+++ src/sc2code/comm/melnorm/igfxres.h	2017-11-08 16:49:51 -0600
@@ -1,3 +1,5 @@
-#define MELNORME_PMAP_ANIM 0x00200002L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define MELNORME_PMAP_ANIM "comm.melnorme.graphics"
diff -ruNp src.orig/sc2code/comm/melnorm/imusicre.h src/sc2code/comm/melnorm/imusicre.h
--- src.orig/sc2code/comm/melnorm/imusicre.h	2017-11-08 16:49:24 -0600
+++ src/sc2code/comm/melnorm/imusicre.h	2017-11-08 16:49:51 -0600
@@ -1,3 +1,5 @@
-#define MELNORME_MUSIC 0x00200006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define MELNORME_MUSIC "comm.melnorme.music"
diff -ruNp src.orig/sc2code/comm/melnorm/istrtab.h src/sc2code/comm/melnorm/istrtab.h
--- src.orig/sc2code/comm/melnorm/istrtab.h	2017-11-08 16:49:24 -0600
+++ src/sc2code/comm/melnorm/istrtab.h	2017-11-08 16:49:51 -0600
@@ -1,4 +1,6 @@
-#define MELNORME_CONVERSATION_PHRASES 0x00200004L
-#define MELNORME_COLOR_MAP 0x00200104L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define MELNORME_COLOR_MAP "comm.melnorme.colortable"
+#define MELNORME_CONVERSATION_PHRASES "comm.melnorme.dialogue"
diff -ruNp src.orig/sc2code/comm/melnorm/melnorm.c src/sc2code/comm/melnorm/melnorm.c
--- src.orig/sc2code/comm/melnorm/melnorm.c	2017-11-08 16:49:24 -0600
+++ src/sc2code/comm/melnorm/melnorm.c	2017-11-08 16:49:51 -0600
@@ -36,11 +36,11 @@ static NUMBER_SPEECH_DESC melnorme_numbe
 
 static LOCDATA melnorme_desc =
 {
-	NULL_PTR, /* init_encounter_func */
-	NULL_PTR, /* post_encounter_func */
-	NULL_PTR, /* uninit_encounter_func */
-	(FRAME)MELNORME_PMAP_ANIM, /* AlienFrame */
-	(FONT)MELNORME_FONT, /* AlienFont */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	MELNORME_PMAP_ANIM, /* AlienFrame */
+	MELNORME_FONT, /* AlienFont */
 	WHITE_COLOR, /* AlienTextFColor */
 	BLACK_COLOR, /* AlienTextBColor */
 	{0, 0}, /* AlienTextBaseline */
@@ -49,7 +49,7 @@ static LOCDATA melnorme_desc =
 	VALIGN_TOP, /* AlienTextValign */
 	MELNORME_COLOR_MAP, /* AlienColorMap */
 	MELNORME_MUSIC, /* AlienSong */
-	0, /* AlienAltSong */
+	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	MELNORME_CONVERSATION_PHRASES, /* PlayerPhrases */
 	4, /* NumAnimations */
@@ -104,6 +104,10 @@ static LOCDATA melnorme_desc =
 		0, /* BlockMask */
 	},
 	&melnorme_numbers_english, /* AlienNumberSpeech - default */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
 };
 
 static COUNT melnorme_digit_names[] =
@@ -1501,8 +1505,7 @@ yack0_respond (void)
 					shared_phrase_buf,
 					we_are_from_alliance0,
 					buf,
-					(RESPONSE_REF)-1
-					);
+					(RESPONSE_REF)-1);
 			DoResponsePhrase (we_are_from_alliance0, DoFirstMeeting, shared_phrase_buf);
 			break;
 		}
@@ -1849,10 +1852,10 @@ post_melnorme_enc (void)
 	UnlockMutex (GraphicsLock);
 }
 
-LOCDATAPTR
+LOCDATA*
 init_melnorme_comm (void)
 {
-	LOCDATAPTR retval;
+	LOCDATA *retval;
 
 	melnorme_desc.init_encounter_func = Intro;
 	melnorme_desc.post_encounter_func = post_melnorme_enc;
diff -ruNp src.orig/sc2code/comm/mycon/ifontres.h src/sc2code/comm/mycon/ifontres.h
--- src.orig/sc2code/comm/mycon/ifontres.h	2017-11-08 16:49:24 -0600
+++ src/sc2code/comm/mycon/ifontres.h	2017-11-08 16:49:51 -0600
@@ -1,3 +1,5 @@
-#define MYCON_FONT 0x00200003L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define MYCON_FONT "comm.mycon.font"
diff -ruNp src.orig/sc2code/comm/mycon/igfxres.h src/sc2code/comm/mycon/igfxres.h
--- src.orig/sc2code/comm/mycon/igfxres.h	2017-11-08 16:49:24 -0600
+++ src/sc2code/comm/mycon/igfxres.h	2017-11-08 16:49:51 -0600
@@ -1,3 +1,5 @@
-#define MYCON_PMAP_ANIM 0x00200002L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define MYCON_PMAP_ANIM "comm.mycon.graphics"
diff -ruNp src.orig/sc2code/comm/mycon/imusicre.h src/sc2code/comm/mycon/imusicre.h
--- src.orig/sc2code/comm/mycon/imusicre.h	2017-11-08 16:49:24 -0600
+++ src/sc2code/comm/mycon/imusicre.h	2017-11-08 16:49:51 -0600
@@ -1,3 +1,5 @@
-#define MYCON_MUSIC 0x00200006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define MYCON_MUSIC "comm.mycon.music"
diff -ruNp src.orig/sc2code/comm/mycon/istrtab.h src/sc2code/comm/mycon/istrtab.h
--- src.orig/sc2code/comm/mycon/istrtab.h	2017-11-08 16:49:24 -0600
+++ src/sc2code/comm/mycon/istrtab.h	2017-11-08 16:49:51 -0600
@@ -1,3 +1,6 @@
-#define MYCON_CONVERSATION_PHRASES 0x00200004L
-#define MYCON_COLOR_MAP 0x00200104L
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define MYCON_COLOR_MAP "comm.mycon.colortable"
+#define MYCON_CONVERSATION_PHRASES "comm.mycon.dialogue"
diff -ruNp src.orig/sc2code/comm/mycon/myconc.c src/sc2code/comm/mycon/myconc.c
--- src.orig/sc2code/comm/mycon/myconc.c	2017-11-08 16:49:24 -0600
+++ src/sc2code/comm/mycon/myconc.c	2017-11-08 16:49:52 -0600
@@ -26,20 +26,20 @@
 
 static LOCDATA mycon_desc =
 {
-	NULL_PTR, /* init_encounter_func */
-	NULL_PTR, /* post_encounter_func */
-	NULL_PTR, /* uninit_encounter_func */
-	(FRAME)MYCON_PMAP_ANIM, /* AlienFrame */
-	(FONT)MYCON_FONT, /* AlienFont */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	MYCON_PMAP_ANIM, /* AlienFrame */
+	MYCON_FONT, /* AlienFont */
 	WHITE_COLOR, /* AlienTextFColor */
 	BLACK_COLOR, /* AlienTextBColor */
 	{0, 0}, /* AlienTextBaseline */
 	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
 	ALIGN_CENTER, /* AlienTextAlign */
 	VALIGN_TOP, /* AlienTextValign */
-	(COLORMAP)MYCON_COLOR_MAP, /* AlienColorMap */
+	MYCON_COLOR_MAP, /* AlienColorMap */
 	MYCON_MUSIC, /* AlienSong */
-	0, /* AlienAltSong */
+	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	MYCON_CONVERSATION_PHRASES, /* PlayerPhrases */
 	5, /* NumAnimations */
@@ -101,7 +101,11 @@ static LOCDATA mycon_desc =
 		ONE_SECOND / 12, 0, /* RestartRate */
 		0, /* BlockMask */
 	},
-	NULL_PTR, /* AlienNumberSpeech - none */
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
 };
 
 static BYTE MadeChoice;
@@ -610,10 +614,10 @@ post_mycon_enc (void)
 	// nothing defined so far
 }
 
-LOCDATAPTR
+LOCDATA*
 init_mycon_comm (void)
 {
-	LOCDATAPTR retval;
+	LOCDATA *retval;
 
 	mycon_desc.init_encounter_func = Intro;
 	mycon_desc.post_encounter_func = post_mycon_enc;
diff -ruNp src.orig/sc2code/comm/orz/ifontres.h src/sc2code/comm/orz/ifontres.h
--- src.orig/sc2code/comm/orz/ifontres.h	2017-11-08 16:49:24 -0600
+++ src/sc2code/comm/orz/ifontres.h	2017-11-08 16:49:52 -0600
@@ -1,3 +1,5 @@
-#define ORZ_FONT 0x00200003L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ORZ_FONT "comm.orz.font"
diff -ruNp src.orig/sc2code/comm/orz/igfxres.h src/sc2code/comm/orz/igfxres.h
--- src.orig/sc2code/comm/orz/igfxres.h	2017-11-08 16:49:24 -0600
+++ src/sc2code/comm/orz/igfxres.h	2017-11-08 16:49:52 -0600
@@ -1,3 +1,5 @@
-#define ORZ_PMAP_ANIM 0x00200002L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ORZ_PMAP_ANIM "comm.orz.graphics"
diff -ruNp src.orig/sc2code/comm/orz/imusicre.h src/sc2code/comm/orz/imusicre.h
--- src.orig/sc2code/comm/orz/imusicre.h	2017-11-08 16:49:24 -0600
+++ src/sc2code/comm/orz/imusicre.h	2017-11-08 16:49:52 -0600
@@ -1,3 +1,5 @@
-#define ORZ_MUSIC 0x00200006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ORZ_MUSIC "comm.orz.music"
diff -ruNp src.orig/sc2code/comm/orz/istrtab.h src/sc2code/comm/orz/istrtab.h
--- src.orig/sc2code/comm/orz/istrtab.h	2017-11-08 16:49:24 -0600
+++ src/sc2code/comm/orz/istrtab.h	2017-11-08 16:49:52 -0600
@@ -1,4 +1,6 @@
-#define ORZ_CONVERSATION_PHRASES 0x00200004L
-#define ORZ_COLOR_MAP 0x00200104L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ORZ_COLOR_MAP "comm.orz.colortable"
+#define ORZ_CONVERSATION_PHRASES "comm.orz.dialogue"
diff -ruNp src.orig/sc2code/comm/orz/orzc.c src/sc2code/comm/orz/orzc.c
--- src.orig/sc2code/comm/orz/orzc.c	2017-11-08 16:49:24 -0600
+++ src/sc2code/comm/orz/orzc.c	2017-11-08 16:49:52 -0600
@@ -24,20 +24,20 @@
 
 static LOCDATA orz_desc =
 {
-	NULL_PTR, /* init_encounter_func */
-	NULL_PTR, /* post_encounter_func */
-	NULL_PTR, /* uninit_encounter_func */
-	(FRAME)ORZ_PMAP_ANIM, /* AlienFrame */
-	(FONT)ORZ_FONT, /* AlienFont */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	ORZ_PMAP_ANIM, /* AlienFrame */
+	ORZ_FONT, /* AlienFont */
 	WHITE_COLOR, /* AlienTextFColor */
 	BLACK_COLOR, /* AlienTextBColor */
 	{0, 0}, /* AlienTextBaseline */
 	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
 	ALIGN_CENTER, /* AlienTextAlign */
 	VALIGN_TOP, /* AlienTextValign */
-	(COLORMAP)ORZ_COLOR_MAP, /* AlienColorMap */
+	ORZ_COLOR_MAP, /* AlienColorMap */
 	ORZ_MUSIC, /* AlienSong */
-	0, /* AlienAltSong */
+	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	ORZ_CONVERSATION_PHRASES, /* PlayerPhrases */
 	12 /* 13 */, /* NumAnimations */
@@ -163,7 +163,11 @@ static LOCDATA orz_desc =
 		ONE_SECOND / 12, ONE_SECOND * 3 / 8, /* RestartRate */
 		0, /* BlockMask */
 	},
-	NULL_PTR, /* AlienNumberSpeech - none */
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
 };
 
 static void
@@ -208,7 +212,7 @@ ExitConversation (RESPONSE_REF R)
 		SET_GAME_STATE (ORZ_GENERAL_INFO, 0);
 		SET_GAME_STATE (ORZ_PERSONAL_INFO, 0);
 		SET_GAME_STATE (ORZ_MANNER, 3);
-		ActivateStarShip (ORZ_SHIP, 0);
+		ActivateStarShip (ORZ_SHIP, SET_ALLIED);
 	}
 	else if (PLAYER_SAID (R, demand_to_land))
 	{
@@ -228,7 +232,10 @@ ExitConversation (RESPONSE_REF R)
 		SET_GAME_STATE (ORZ_MANNER, 2);
 		SET_GAME_STATE (BATTLE_SEGUE, 1);
 		if (PLAYER_SAID (R, about_andro_3))
-			ActivateStarShip (ORZ_SHIP, -1);
+		{
+			ActivateStarShip (ORZ_SHIP, SET_NOT_ALLIED);
+			ActivateStarShip (ORZ_SHIP, REMOVE_BUILT);
+		}
 
 		XFormColorMap (GetColorMapAddress (
 				SetAbsColorMapIndex (CommData.AlienColorMap, 1)
@@ -314,9 +321,8 @@ TaaloWorld (RESPONSE_REF R)
 
 	if (PHRASE_ENABLED (may_we_land))
 	{
-		if (Manner == 3 && (ActivateStarShip (
-				ORZ_SHIP, CHECK_ALLIANCE
-				) & GOOD_GUY))
+		if (Manner == 3 && (ActivateStarShip (ORZ_SHIP, CHECK_ALLIANCE)
+				& GOOD_GUY))
 			Response (may_we_land, ExitConversation);
 		else
 			Response (may_we_land, TaaloWorld);
@@ -330,7 +336,7 @@ TaaloWorld (RESPONSE_REF R)
 		if (Manner == 1)
 			Response (demand_to_land, ExitConversation);
 		else
-				Response (demand_to_land, TaaloWorld);
+			Response (demand_to_land, TaaloWorld);
 	}
 	if (PHRASE_ENABLED (why_you_here))
 		Response (why_you_here, TaaloWorld);
@@ -540,7 +546,7 @@ OrzNeutral (RESPONSE_REF R)
 				we_are_vindicator1,
 				GLOBAL_SIS (ShipName),
 				we_are_vindicator2,
-				NULL_PTR);
+				(UNICODE*)NULL);
 		pStr[1] = we_are_vindicator0;
 	}
 	else
@@ -642,7 +648,12 @@ Intro (void)
 	}
 
 	if (!GET_GAME_STATE (MET_ORZ_BEFORE))
-		NPCPhrase (INIT_HELLO);
+	{
+		if (optSubtitles)
+			NPCPhrase (INIT_HELLO_PC);
+		else
+			NPCPhrase (INIT_HELLO_3DO);
+	}
 
 	Manner = GET_GAME_STATE (ORZ_MANNER);
 	if (Manner == 2)
@@ -698,9 +709,8 @@ Intro (void)
 
 		TaaloWorld ((RESPONSE_REF)0);
 	}
-	else if (Manner == 3 && (ActivateStarShip (
-			ORZ_SHIP, CHECK_ALLIANCE
-			) & GOOD_GUY))
+	else if (Manner == 3 && (ActivateStarShip (ORZ_SHIP, CHECK_ALLIANCE)
+			& GOOD_GUY))
 	{
 		if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 7))
 		{
@@ -867,10 +877,10 @@ post_orz_enc (void)
 	}
 }
 
-LOCDATAPTR
+LOCDATA*
 init_orz_comm (void)
 {
-	LOCDATAPTR retval;
+	LOCDATA *retval;
 
 	orz_desc.init_encounter_func = Intro;
 	orz_desc.post_encounter_func = post_orz_enc;
diff -ruNp src.orig/sc2code/comm/orz/strings.h src/sc2code/comm/orz/strings.h
--- src.orig/sc2code/comm/orz/strings.h	2017-11-08 16:49:24 -0600
+++ src/sc2code/comm/orz/strings.h	2017-11-08 16:49:52 -0600
@@ -22,7 +22,8 @@
 enum
 {
 	NULL_PHRASE,
-	INIT_HELLO,
+	INIT_HELLO_3DO,
+	INIT_HELLO_PC,
 	who_you,
 	WE_ARE_ORZ,
 	why_here,
diff -ruNp src.orig/sc2code/comm/pkunk/ifontres.h src/sc2code/comm/pkunk/ifontres.h
--- src.orig/sc2code/comm/pkunk/ifontres.h	2017-11-08 16:49:24 -0600
+++ src/sc2code/comm/pkunk/ifontres.h	2017-11-08 16:49:52 -0600
@@ -1,3 +1,5 @@
-#define PKUNK_FONT 0x00200003L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define PKUNK_FONT "comm.pkunk.font"
diff -ruNp src.orig/sc2code/comm/pkunk/igfxres.h src/sc2code/comm/pkunk/igfxres.h
--- src.orig/sc2code/comm/pkunk/igfxres.h	2017-11-08 16:49:24 -0600
+++ src/sc2code/comm/pkunk/igfxres.h	2017-11-08 16:49:52 -0600
@@ -1,3 +1,5 @@
-#define PKUNK_PMAP_ANIM 0x00200002L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define PKUNK_PMAP_ANIM "comm.pkunk.graphics"
diff -ruNp src.orig/sc2code/comm/pkunk/imusicre.h src/sc2code/comm/pkunk/imusicre.h
--- src.orig/sc2code/comm/pkunk/imusicre.h	2017-11-08 16:49:24 -0600
+++ src/sc2code/comm/pkunk/imusicre.h	2017-11-08 16:49:52 -0600
@@ -1,3 +1,5 @@
-#define PKUNK_MUSIC 0x00200006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define PKUNK_MUSIC "comm.pkunk.music"
diff -ruNp src.orig/sc2code/comm/pkunk/istrtab.h src/sc2code/comm/pkunk/istrtab.h
--- src.orig/sc2code/comm/pkunk/istrtab.h	2017-11-08 16:49:24 -0600
+++ src/sc2code/comm/pkunk/istrtab.h	2017-11-08 16:49:52 -0600
@@ -1,3 +1,6 @@
-#define PKUNK_CONVERSATION_PHRASES 0x00200004L
-#define PKUNK_COLOR_MAP 0x00200104L
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define PKUNK_COLOR_MAP "comm.pkunk.colortable"
+#define PKUNK_CONVERSATION_PHRASES "comm.pkunk.dialogue"
diff -ruNp src.orig/sc2code/comm/pkunk/pkunkc.c src/sc2code/comm/pkunk/pkunkc.c
--- src.orig/sc2code/comm/pkunk/pkunkc.c	2017-11-08 16:49:24 -0600
+++ src/sc2code/comm/pkunk/pkunkc.c	2017-11-08 16:49:52 -0600
@@ -26,20 +26,20 @@
 
 static LOCDATA pkunk_desc =
 {
-	NULL_PTR, /* init_encounter_func */
-	NULL_PTR, /* post_encounter_func */
-	NULL_PTR, /* uninit_encounter_func */
-	(FRAME)PKUNK_PMAP_ANIM, /* AlienFrame */
-	(FONT)PKUNK_FONT, /* AlienFont */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	PKUNK_PMAP_ANIM, /* AlienFrame */
+	PKUNK_FONT, /* AlienFont */
 	WHITE_COLOR, /* AlienTextFColor */
 	BLACK_COLOR, /* AlienTextBColor */
 	{0, 0}, /* AlienTextBaseline */
 	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
 	ALIGN_CENTER, /* AlienTextAlign */
 	VALIGN_TOP, /* AlienTextValign */
-	(COLORMAP)PKUNK_COLOR_MAP, /* AlienColorMap */
+	PKUNK_COLOR_MAP, /* AlienColorMap */
 	PKUNK_MUSIC, /* AlienSong */
-	0, /* AlienAltSong */
+	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	PKUNK_CONVERSATION_PHRASES, /* PlayerPhrases */
 	3, /* NumAnimations */
@@ -88,7 +88,11 @@ static LOCDATA pkunk_desc =
 		ONE_SECOND / 12, ONE_SECOND / 2, /* RestartRate */
 		0, /* BlockMask */
 	},
-	NULL_PTR, /* AlienNumberSpeech - none */
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
 };
 
 static BOOLEAN
@@ -306,8 +310,7 @@ DiscussConquer (RESPONSE_REF R)
 				shared_phrase_buf,
 				conquer_because_1,
 				buf,
-				(RESPONSE_REF)-1
-				);
+				(RESPONSE_REF)-1);
 		DoResponsePhrase (conquer_because_1, DiscussConquer, shared_phrase_buf);
 #endif
 		Response(conquer_because_1, DiscussConquer);
@@ -624,7 +627,7 @@ PkunkHome (RESPONSE_REF R)
 				we_are_vindicator1,
 				GLOBAL_SIS (ShipName),
 				we_are_vindicator2,
-				NULL_PTR);
+				(UNICODE*)NULL);
 		DoResponsePhrase (we_are_vindicator0, OfferAlliance, shared_phrase_buf);
 	}
 	if (PHRASE_ENABLED (what_about_you))
@@ -1113,10 +1116,10 @@ post_pkunk_enc (void)
 	}
 }
 
-LOCDATAPTR
+LOCDATA*
 init_pkunk_comm (void)
 {
-	LOCDATAPTR retval;
+	LOCDATA *retval;
 
 	pkunk_desc.init_encounter_func = Intro;
 	pkunk_desc.post_encounter_func = post_pkunk_enc;
diff -ruNp src.orig/sc2code/comm/rebel/rebel.c src/sc2code/comm/rebel/rebel.c
--- src.orig/sc2code/comm/rebel/rebel.c	2017-11-08 16:49:24 -0600
+++ src/sc2code/comm/rebel/rebel.c	2017-11-08 16:49:52 -0600
@@ -25,20 +25,20 @@
 
 static LOCDATA yehat_desc =
 {
-	NULL_PTR, /* init_encounter_func */
-	NULL_PTR, /* post_encounter_func */
-	NULL_PTR, /* uninit_encounter_func */
-	(FRAME)YEHAT_PMAP_ANIM, /* AlienFrame */
-	(FONT)YEHAT_FONT, /* AlienFont */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	YEHAT_PMAP_ANIM, /* AlienFrame */
+	YEHAT_FONT, /* AlienFont */
 	WHITE_COLOR, /* AlienTextFColor */
 	BLACK_COLOR, /* AlienTextBColor */
 	{0, 0}, /* AlienTextBaseline */
 	0, /* (SIS_TEXT_WIDTH - 16) * 2 / 3, */ /* AlienTextWidth */
 	ALIGN_CENTER, /* AlienTextAlign */
 	VALIGN_MIDDLE, /* AlienTextValign */
-	(COLORMAP)YEHAT_COLOR_MAP, /* AlienColorMap */
+	YEHAT_COLOR_MAP, /* AlienColorMap */
 	YEHAT_MUSIC, /* AlienSong */
-	0, /* AlienAltSong */
+	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	REBEL_CONVERSATION_PHRASES, /* PlayerPhrases */
 	15, /* NumAnimations */
@@ -185,7 +185,11 @@ static LOCDATA yehat_desc =
 		ONE_SECOND / 12, 0, /* RestartRate */
 		0, /* BlockMask */
 	},
-	NULL_PTR, /* AlienNumberSpeech - none */
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
 };
 
 static void
@@ -422,10 +426,10 @@ post_yehat_enc (void)
 	// nothing defined so far
 }
 
-LOCDATAPTR
+LOCDATA*
 init_rebel_yehat_comm (void)
 {
-	LOCDATAPTR retval;
+	LOCDATA *retval;
 
 	yehat_desc.init_encounter_func = Intro;
 	yehat_desc.post_encounter_func = post_yehat_enc;
@@ -436,7 +440,7 @@ init_rebel_yehat_comm (void)
 	yehat_desc.AlienTextWidth = (SIS_TEXT_WIDTH - 16) * 2 / 3;
 
 	// use alternate "Rebels" track if available
-	yehat_desc.AlienAltSong = REBEL_MUSIC;
+	yehat_desc.AlienAltSongRes = REBEL_MUSIC;
 	yehat_desc.AlienSongFlags |= LDASF_USE_ALTERNATE;
 
 	SET_GAME_STATE (BATTLE_SEGUE, 0);
diff -ruNp src.orig/sc2code/comm/shofixt/ifontres.h src/sc2code/comm/shofixt/ifontres.h
--- src.orig/sc2code/comm/shofixt/ifontres.h	2017-11-08 16:49:24 -0600
+++ src/sc2code/comm/shofixt/ifontres.h	2017-11-08 16:49:52 -0600
@@ -1,3 +1,5 @@
-#define SHOFIXTI_FONT 0x00200003L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SHOFIXTI_FONT "comm.shofixti.font"
diff -ruNp src.orig/sc2code/comm/shofixt/igfxres.h src/sc2code/comm/shofixt/igfxres.h
--- src.orig/sc2code/comm/shofixt/igfxres.h	2017-11-08 16:49:24 -0600
+++ src/sc2code/comm/shofixt/igfxres.h	2017-11-08 16:49:52 -0600
@@ -1,3 +1,5 @@
-#define SHOFIXTI_PMAP_ANIM 0x00200002L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SHOFIXTI_PMAP_ANIM "comm.shofixti.graphics"
diff -ruNp src.orig/sc2code/comm/shofixt/imusicre.h src/sc2code/comm/shofixt/imusicre.h
--- src.orig/sc2code/comm/shofixt/imusicre.h	2017-11-08 16:49:24 -0600
+++ src/sc2code/comm/shofixt/imusicre.h	2017-11-08 16:49:52 -0600
@@ -1,3 +1,5 @@
-#define SHOFIXTI_MUSIC 0x00200006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SHOFIXTI_MUSIC "comm.shofixti.music"
diff -ruNp src.orig/sc2code/comm/shofixt/istrtab.h src/sc2code/comm/shofixt/istrtab.h
--- src.orig/sc2code/comm/shofixt/istrtab.h	2017-11-08 16:49:24 -0600
+++ src/sc2code/comm/shofixt/istrtab.h	2017-11-08 16:49:52 -0600
@@ -1,3 +1,6 @@
-#define SHOFIXTI_CONVERSATION_PHRASES 0x00200004L
-#define SHOFIXTI_COLOR_MAP 0x00200104L
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SHOFIXTI_COLOR_MAP "comm.shofixti.colortable"
+#define SHOFIXTI_CONVERSATION_PHRASES "comm.shofixti.dialogue"
diff -ruNp src.orig/sc2code/comm/shofixt/shofixt.c src/sc2code/comm/shofixt/shofixt.c
--- src.orig/sc2code/comm/shofixt/shofixt.c	2017-11-08 16:49:25 -0600
+++ src/sc2code/comm/shofixt/shofixt.c	2017-11-08 16:49:52 -0600
@@ -25,20 +25,20 @@
 
 static LOCDATA shofixti_desc =
 {
-	NULL_PTR, /* init_encounter_func */
-	NULL_PTR, /* post_encounter_func */
-	NULL_PTR, /* uninit_encounter_func */
-	(FRAME)SHOFIXTI_PMAP_ANIM, /* AlienFrame */
-	(FONT)SHOFIXTI_FONT, /* AlienFont */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	SHOFIXTI_PMAP_ANIM, /* AlienFrame */
+	SHOFIXTI_FONT, /* AlienFont */
 	WHITE_COLOR, /* AlienTextFColor */
 	BLACK_COLOR, /* AlienTextBColor */
 	{0, 0}, /* AlienTextBaseline */
 	0, /* SIS_TEXT_WIDTH, */ /* AlienTextWidth */
 	ALIGN_CENTER, /* AlienTextAlign */
 	VALIGN_TOP, /* AlienTextValign */
-	(COLORMAP)SHOFIXTI_COLOR_MAP, /* AlienColorMap */
+	SHOFIXTI_COLOR_MAP, /* AlienColorMap */
 	SHOFIXTI_MUSIC, /* AlienSong */
-	0, /* AlienAltSong */
+	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	SHOFIXTI_CONVERSATION_PHRASES, /* PlayerPhrases */
 	11, /* NumAnimations */
@@ -149,7 +149,11 @@ static LOCDATA shofixti_desc =
 		ONE_SECOND / 15, 0, /* RestartRate */
 		0, /* BlockMask */
 	},
-	NULL_PTR, /* AlienNumberSpeech - none */
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
 };
 
 static RESPONSE_REF shofixti_name;
@@ -353,8 +357,7 @@ RealizeMistake (RESPONSE_REF R)
 				i_am_captain2,
 				GLOBAL_SIS (ShipName),
 				i_am_captain3,
-				NULL_PTR
-				);
+				(UNICODE*)NULL);
 	}
 	DoResponsePhrase (i_am_captain0, ExplainDefeat, shared_phrase_buf);
 	Response (i_am_nice, ExplainDefeat);
@@ -403,8 +406,7 @@ Hostile (RESPONSE_REF R)
 					shofixti_name,
 					"",
 					look1,
-					NULL_PTR
-					);
+					(UNICODE*)NULL);
 			DoResponsePhrase (look0, ExitConversation, shared_phrase_buf);
 			break;
 		}
@@ -477,8 +479,7 @@ Friendly (RESPONSE_REF R)
 				shofixti_name,
 				"",
 				report1,
-				NULL_PTR
-				);
+				(UNICODE*)NULL);
 		Resp[0].pStr = report0;
 		Resp[0].c_buf = buf0;
 	}
@@ -493,8 +494,7 @@ Friendly (RESPONSE_REF R)
 					shofixti_name,
 					"",
 					why_here1,
-					NULL_PTR
-					);
+					(UNICODE*)NULL);
 			Resp[1].pStr = why_here0;
 			Resp[1].c_buf = buf1;
 			break;
@@ -535,8 +535,7 @@ Friendly (RESPONSE_REF R)
 			shofixti_name,
 			"",
 			bye1,
-			NULL_PTR
-			);
+			(UNICODE*)NULL);
 	DoResponsePhrase (bye0, ExitConversation, shared_phrase_buf);
 }
 
@@ -632,10 +631,10 @@ post_shofixti_enc (void)
 	// nothing defined so far
 }
 
-LOCDATAPTR
+LOCDATA*
 init_shofixti_comm (void)
 {
-	LOCDATAPTR retval;
+	LOCDATA *retval;
 
 	shofixti_desc.init_encounter_func = Intro;
 	shofixti_desc.post_encounter_func = post_shofixti_enc;
diff -ruNp src.orig/sc2code/comm/slyhome/ifontres.h src/sc2code/comm/slyhome/ifontres.h
--- src.orig/sc2code/comm/slyhome/ifontres.h	2017-11-08 16:49:25 -0600
+++ src/sc2code/comm/slyhome/ifontres.h	2017-11-08 16:49:52 -0600
@@ -1,3 +1,5 @@
-#define SLYLANDRO_FONT 0x00200003L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SLYLANDRO_FONT "comm.slyhome.font"
diff -ruNp src.orig/sc2code/comm/slyhome/igfxres.h src/sc2code/comm/slyhome/igfxres.h
--- src.orig/sc2code/comm/slyhome/igfxres.h	2017-11-08 16:49:25 -0600
+++ src/sc2code/comm/slyhome/igfxres.h	2017-11-08 16:49:52 -0600
@@ -1,3 +1,5 @@
-#define SLYLANDRO_PMAP_ANIM 0x00200002L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SLYLANDRO_PMAP_ANIM "comm.slyhome.graphics"
diff -ruNp src.orig/sc2code/comm/slyhome/imusicre.h src/sc2code/comm/slyhome/imusicre.h
--- src.orig/sc2code/comm/slyhome/imusicre.h	2017-11-08 16:49:25 -0600
+++ src/sc2code/comm/slyhome/imusicre.h	2017-11-08 16:49:52 -0600
@@ -1,3 +1,5 @@
-#define SLYLANDRO_MUSIC 0x00200006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SLYLANDRO_MUSIC "comm.slyhome.music"
diff -ruNp src.orig/sc2code/comm/slyhome/istrtab.h src/sc2code/comm/slyhome/istrtab.h
--- src.orig/sc2code/comm/slyhome/istrtab.h	2017-11-08 16:49:25 -0600
+++ src/sc2code/comm/slyhome/istrtab.h	2017-11-08 16:49:52 -0600
@@ -1,4 +1,6 @@
-#define SLYLANDRO_CONVERSATION_PHRASES 0x00200004L
-#define SLYLANDRO_COLOR_MAP 0x00200104L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SLYLANDRO_COLOR_MAP "comm.slyhome.colortable"
+#define SLYLANDRO_CONVERSATION_PHRASES "comm.slyhome.dialogue"
diff -ruNp src.orig/sc2code/comm/slyhome/slyhome.c src/sc2code/comm/slyhome/slyhome.c
--- src.orig/sc2code/comm/slyhome/slyhome.c	2017-11-08 16:49:25 -0600
+++ src/sc2code/comm/slyhome/slyhome.c	2017-11-08 16:49:52 -0600
@@ -24,20 +24,20 @@
 
 static LOCDATA slylandro_desc =
 {
-	NULL_PTR, /* init_encounter_func */
-	NULL_PTR, /* post_encounter_func */
-	NULL_PTR, /* uninit_encounter_func */
-	(FRAME)SLYLANDRO_PMAP_ANIM, /* AlienFrame */
-	(FONT)SLYLANDRO_FONT, /* AlienFont */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	SLYLANDRO_PMAP_ANIM, /* AlienFrame */
+	SLYLANDRO_FONT, /* AlienFont */
 	WHITE_COLOR, /* AlienTextFColor */
 	BLACK_COLOR, /* AlienTextBColor */
 	{0, 0}, /* AlienTextBaseline */
 	0, /* SIS_TEXT_WIDTH, */ /* AlienTextWidth */
 	ALIGN_CENTER, /* AlienTextAlign */
 	VALIGN_TOP, /* AlienTextValign */
-	(COLORMAP)SLYLANDRO_COLOR_MAP, /* AlienColorMap */
+	SLYLANDRO_COLOR_MAP, /* AlienColorMap */
 	SLYLANDRO_MUSIC, /* AlienSong */
-	0, /* AlienAltSong */
+	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	SLYLANDRO_CONVERSATION_PHRASES, /* PlayerPhrases */
 	13, /* NumAnimations */
@@ -163,7 +163,11 @@ static LOCDATA slylandro_desc =
 		0, 0, /* RestartRate */
 		0, /* BlockMask */
 	},
-	NULL_PTR, /* AlienNumberSpeech - none */
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
 };
 
 static void
@@ -756,7 +760,7 @@ HomeWorld (RESPONSE_REF R)
 					we_are_us1,
 					GLOBAL_SIS (ShipName),
 					we_are_us2,
-					NULL_PTR);
+					(UNICODE*)NULL);
 			pStr[0] = we_are_us0;
 			break;
 		case 1:
@@ -896,10 +900,10 @@ post_slylandro_enc (void)
 	// nothing defined so far
 }
 
-LOCDATAPTR
+LOCDATA*
 init_slylandro_comm (void)
 {
-	LOCDATAPTR retval;
+	LOCDATA *retval;
 
 	slylandro_desc.init_encounter_func = Intro;
 	slylandro_desc.post_encounter_func = post_slylandro_enc;
diff -ruNp src.orig/sc2code/comm/slyland/ifontres.h src/sc2code/comm/slyland/ifontres.h
--- src.orig/sc2code/comm/slyland/ifontres.h	2017-11-08 16:49:25 -0600
+++ src/sc2code/comm/slyland/ifontres.h	2017-11-08 16:49:52 -0600
@@ -1,3 +1,5 @@
-#define SLYLAND_FONT 0x00200003L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SLYLAND_FONT "comm.slylandro.font"
diff -ruNp src.orig/sc2code/comm/slyland/igfxres.h src/sc2code/comm/slyland/igfxres.h
--- src.orig/sc2code/comm/slyland/igfxres.h	2017-11-08 16:49:25 -0600
+++ src/sc2code/comm/slyland/igfxres.h	2017-11-08 16:49:52 -0600
@@ -1,3 +1,5 @@
-#define SLYLAND_PMAP_ANIM 0x00200002L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SLYLAND_PMAP_ANIM "comm.slylandro.graphics"
diff -ruNp src.orig/sc2code/comm/slyland/imusicre.h src/sc2code/comm/slyland/imusicre.h
--- src.orig/sc2code/comm/slyland/imusicre.h	2017-11-08 16:49:25 -0600
+++ src/sc2code/comm/slyland/imusicre.h	2017-11-08 16:49:52 -0600
@@ -1,3 +1,5 @@
-#define SLYLAND_MUSIC 0x00200006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SLYLAND_MUSIC "comm.slylandro.music"
diff -ruNp src.orig/sc2code/comm/slyland/istrtab.h src/sc2code/comm/slyland/istrtab.h
--- src.orig/sc2code/comm/slyland/istrtab.h	2017-11-08 16:49:25 -0600
+++ src/sc2code/comm/slyland/istrtab.h	2017-11-08 16:49:52 -0600
@@ -1,3 +1,6 @@
-#define SLYLAND_CONVERSATION_PHRASES 0x00200004L
-#define SLYLAND_COLOR_MAP 0x00200104L
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SLYLAND_COLOR_MAP "comm.slylandro.colortable"
+#define SLYLAND_CONVERSATION_PHRASES "comm.slylandro.dialogue"
diff -ruNp src.orig/sc2code/comm/slyland/slyland.c src/sc2code/comm/slyland/slyland.c
--- src.orig/sc2code/comm/slyland/slyland.c	2017-11-08 16:49:25 -0600
+++ src/sc2code/comm/slyland/slyland.c	2017-11-08 16:49:52 -0600
@@ -24,23 +24,26 @@
 #include "battle.h"
 #include "setup.h"
 
+extern int NPCNumberPhrase (int number, UNICODE **ptrack);
+
+static NUMBER_SPEECH_DESC probe_numbers_english;
 
 static LOCDATA slylandro_desc =
 {
-	NULL_PTR, /* init_encounter_func */
-	NULL_PTR, /* post_encounter_func */
-	NULL_PTR, /* uninit_encounter_func */
-	(FRAME)SLYLAND_PMAP_ANIM, /* AlienFrame */
-	(FONT)SLYLAND_FONT, /* AlienFont */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	SLYLAND_PMAP_ANIM, /* AlienFrame */
+	SLYLAND_FONT, /* AlienFont */
 	WHITE_COLOR, /* AlienTextFColor */
 	BLACK_COLOR, /* AlienTextBColor */
 	{0, 0}, /* AlienTextBaseline */
 	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
 	ALIGN_CENTER, /* AlienTextAlign */
 	VALIGN_TOP, /* AlienTextValign */
-	(COLORMAP)SLYLAND_COLOR_MAP, /* AlienColorMap */
+	SLYLAND_COLOR_MAP, /* AlienColorMap */
 	SLYLAND_MUSIC, /* AlienSong */
-	0, /* AlienAltSong */
+	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	SLYLAND_CONVERSATION_PHRASES, /* PlayerPhrases */
 	6, /* NumAnimations */
@@ -110,7 +113,107 @@ static LOCDATA slylandro_desc =
 		0, 0, /* RestartRate */
 		0, /* BlockMask */
 	},
-	NULL_PTR, /* AlienNumberSpeech - none */
+	&probe_numbers_english, /* AlienNumberSpeech - default */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+};
+
+static COUNT probe_digit_names[] =
+{
+	ENUMERATE_ZERO,
+	ENUMERATE_ONE,
+	ENUMERATE_TWO,
+	ENUMERATE_THREE,
+	ENUMERATE_FOUR,
+	ENUMERATE_FIVE,
+	ENUMERATE_SIX,
+	ENUMERATE_SEVEN,
+	ENUMERATE_EIGHT,
+	ENUMERATE_NINE
+};
+
+static COUNT probe_teen_names[] =
+{
+	ENUMERATE_TEN,
+	ENUMERATE_ELEVEN,
+	ENUMERATE_TWELVE,
+	ENUMERATE_THIRTEEN,
+	ENUMERATE_FOURTEEN,
+	ENUMERATE_FIFTEEN,
+	ENUMERATE_SIXTEEN,
+	ENUMERATE_SEVENTEEN,
+	ENUMERATE_EIGHTEEN,
+	ENUMERATE_NINETEEN
+};
+
+static COUNT probe_tens_names[] =
+{
+	0, /* invalid */
+	0, /* skip digit */
+	ENUMERATE_TWENTY,
+	ENUMERATE_THIRTY,
+	ENUMERATE_FORTY,
+	ENUMERATE_FIFTY,
+	ENUMERATE_SIXTY,
+	ENUMERATE_SEVENTY,
+	ENUMERATE_EIGHTY,
+	ENUMERATE_NINETY
+};
+
+static COUNT probe_extras_names[] =
+{
+	ENUMERATE_BY,
+	ENUMERATE_MINUS,
+	ENUMERATE_PLUS,
+	ENUMERATE_POINT
+};
+
+static NUMBER_SPEECH_DESC probe_numbers_english =
+{
+	4, /* NumDigits, note that we lie here and short the length by 1 */
+	{
+		{ /* 100-999 */
+			100, /* Divider */
+			0, /* Subtrahend */
+			probe_digit_names, /* StrDigits */
+			NULL, /* Names - not used */
+			ENUMERATE_HUNDRED /* CommonIndex */
+		},
+		{ /* 20-99 */
+			10, /* Divider */
+			0, /* Subtrahend */
+			probe_tens_names, /* StrDigits */
+			NULL, /* Names - not used */
+			0 /* CommonIndex - not used */
+		},
+		{ /* 10-19 */
+			1, /* Divider */
+			10, /* Subtrahend */
+			probe_teen_names, /* StrDigits */
+			NULL, /* Names - not used */
+			0 /* CommonIndex - not used */
+		},
+		{ /* 0-9 */
+			1, /* Divider */
+			0, /* Subtrahend */
+			probe_digit_names, /* StrDigits */
+			NULL, /* Names - not used */
+			0 /* CommonIndex - not used */
+		},
+		{	/* symbols and punctuation, not automatically
+			 * walked by NPCNumberPhrase() due to the lie
+			 * above.  We'll dig into this by hand in
+			 * the callback function below.
+			 */
+			1, /* Divider */
+			0, /* Subtrahend */
+			probe_extras_names, /* StrDigits */
+			NULL, /* Names - not used */
+			0 /* CommonIndex - not used */
+		}
+	}
 };
 
 static RESPONSE_REF threat,
@@ -119,6 +222,54 @@ static RESPONSE_REF threat,
 			why_attack,
 			bye;
 
+/* This callback function allows the probes to say their coordinates
+ * in their coordinate system.  Since in their coordinate system,
+ * position(0,0) is in the middle of the game starmap, this means
+ * positive and negative values must be allowed.  Since NPCNumberPhrase()
+ * is only cognisant of how to pronounce positive integers, some
+ * subtle abuse is warranted here.  Feeding him negative numbers will
+ * cause him to speak the appropriate odds and ends.
+ */
+static void
+speak_coords_cb (void)
+{
+	SIZE dx, dy;
+	COUNT adx, ady;
+
+	/* Generate coordinates */
+	dx = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x)) - 333;
+	adx = dx >= 0 ? dx : -dx;
+	dy = 9812 - LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
+	ady = dy >= 0 ? dy : -dy;
+
+	/* + or - */
+	NPCNumberPhrase (dy == ady ? -ENUMERATE_PLUS : -ENUMERATE_MINUS, NULL);
+
+	/* whole portion of y-coord */
+	NPCNumberPhrase ((SIZE)(ady / 10), NULL);
+
+	/* decimal point */
+	NPCNumberPhrase (-ENUMERATE_POINT, NULL);
+
+	/* fractional portion of y-coord */
+	NPCNumberPhrase ((COUNT)(ady % 10), NULL);
+
+	/* separator */
+	NPCNumberPhrase (-ENUMERATE_BY, NULL);
+
+	/* again, again! + or - */
+	NPCNumberPhrase (dx == adx ? -ENUMERATE_PLUS : -ENUMERATE_MINUS, NULL);
+
+	/* whole portion of x-coord */
+	NPCNumberPhrase ((SIZE)(adx / 10), NULL);
+
+	/* decimal point */
+	NPCNumberPhrase (-ENUMERATE_POINT, NULL);
+
+	/* fractional portion of x-coord */
+	NPCNumberPhrase ((COUNT)(adx % 10), NULL);
+}
+
 static void
 CombatIsInevitable (RESPONSE_REF R)
 {
@@ -262,13 +413,6 @@ CombatIsInevitable (RESPONSE_REF R)
 		else if (PLAYER_SAID (R, we_are_us))
 		{
 			NumVisits = GET_GAME_STATE (SLYLANDRO_PROBE_ID);
-			if (NumVisits == 3 && !optSubtitles)
-			{
-				/* If playing without subtitles, don't use the
-				 * last item in the conversation tree, which mentions
-				 * coordinates which can't be spoken. */
-				NumVisits--;
-			}
 			switch (NumVisits++)
 			{
 				case 0:
@@ -284,7 +428,7 @@ CombatIsInevitable (RESPONSE_REF R)
 				{
 					NPCPhrase (THIS_IS_PROBE_40);
 					NPCPhrase (THIS_IS_PROBE_41);
-					NPCPhrase (GLOBAL_PLAYER_LOCATION);
+					NPCPhrase_cb (GLOBAL_PLAYER_LOCATION, &speak_coords_cb);
 					NPCPhrase (THIS_IS_PROBE_42);
 
 					--NumVisits;
@@ -394,10 +538,10 @@ post_slyland_enc (void)
 	// nothing defined so far
 }
 
-LOCDATAPTR
+LOCDATA*
 init_slyland_comm (void)
 {
-	LOCDATAPTR retval;
+	LOCDATA *retval;
 
 	slylandro_desc.init_encounter_func = Intro;
 	slylandro_desc.post_encounter_func = post_slyland_enc;
diff -ruNp src.orig/sc2code/comm/slyland/strings.h src/sc2code/comm/slyland/strings.h
--- src.orig/sc2code/comm/slyland/strings.h	2017-11-08 16:49:25 -0600
+++ src/sc2code/comm/slyland/strings.h	2017-11-08 16:49:53 -0600
@@ -75,6 +75,39 @@ enum
 	HOSTILE,
 	DESTRUCT_SEQUENCE,
 	destruct_code,
+	ENUMERATE_BY,
+	ENUMERATE_EIGHT,
+	ENUMERATE_EIGHTEEN,
+	ENUMERATE_EIGHTY,
+	ENUMERATE_ELEVEN,
+	ENUMERATE_FIFTEEN,
+	ENUMERATE_FIFTY,
+	ENUMERATE_FIVE,
+	ENUMERATE_FORTY,
+	ENUMERATE_FOUR,
+	ENUMERATE_FOURTEEN,
+	ENUMERATE_HUNDRED,
+	ENUMERATE_MINUS,
+	ENUMERATE_NINE,
+	ENUMERATE_NINETEEN,
+	ENUMERATE_NINETY,
+	ENUMERATE_ONE,
+	ENUMERATE_PLUS,
+	ENUMERATE_POINT,
+	ENUMERATE_SEVEN,
+	ENUMERATE_SEVENTEEN,
+	ENUMERATE_SEVENTY,
+	ENUMERATE_SIX,
+	ENUMERATE_SIXTEEN,
+	ENUMERATE_SIXTY,
+	ENUMERATE_TEN,
+	ENUMERATE_THIRTEEN,
+	ENUMERATE_THIRTY,
+	ENUMERATE_THREE,
+	ENUMERATE_TWELVE,
+	ENUMERATE_TWENTY,
+	ENUMERATE_TWO,
+	ENUMERATE_ZERO,
 };
 
 #endif /* _STRINGS_H */
diff -ruNp src.orig/sc2code/comm/spahome/spahome.c src/sc2code/comm/spahome/spahome.c
--- src.orig/sc2code/comm/spahome/spahome.c	2017-11-08 16:49:25 -0600
+++ src/sc2code/comm/spahome/spahome.c	2017-11-08 16:49:53 -0600
@@ -26,20 +26,20 @@
 
 static LOCDATA spahome_desc =
 {
-	NULL_PTR, /* init_encounter_func */
-	NULL_PTR, /* post_encounter_func */
-	NULL_PTR, /* uninit_encounter_func */
-	(FRAME)SPATHI_HOME_PMAP_ANIM, /* AlienFrame */
-	(FONT)SPATHI_FONT, /* AlienFont */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	SPATHI_HOME_PMAP_ANIM, /* AlienFrame */
+	SPATHI_FONT, /* AlienFont */
 	WHITE_COLOR, /* AlienTextFColor */
 	BLACK_COLOR, /* AlienTextBColor */
 	{0, 0}, /* AlienTextBaseline */
 	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
 	ALIGN_CENTER, /* AlienTextAlign */
 	VALIGN_TOP, /* AlienTextValign */
-	(COLORMAP)SPATHI_HOME_COLOR_MAP, /* AlienColorMap */
+	SPATHI_HOME_COLOR_MAP, /* AlienColorMap */
 	SPATHI_MUSIC, /* AlienSong */
-	0, /* AlienAltSong */
+	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	SPATHI_HOME_CONVERSATION_PHRASES, /* PlayerPhrases */
 	14, /* NumAnimations */
@@ -176,7 +176,11 @@ static LOCDATA spahome_desc =
 		0, 0, /* RestartRate */
 		0, /* BlockMask */
 	},
-	NULL_PTR, /* AlienNumberSpeech - none */
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
 };
 
 static void
@@ -247,7 +251,7 @@ ExitConversation (RESPONSE_REF R)
 	{
 		NPCPhrase (DEPART_FOR_EARTH);
 
-		ActivateStarShip (SPATHI_SHIP, 0);
+		ActivateStarShip (SPATHI_SHIP, SET_ALLIED);
 		AddEvent (RELATIVE_EVENT, 6, 0, 0, SPATHI_SHIELD_EVENT);
 		SET_GAME_STATE (SPATHI_HOME_VISITS, 0);
 		SET_GAME_STATE (SPATHI_VISITS, 0);
@@ -883,7 +887,7 @@ SpathiPassword (RESPONSE_REF R)
 				we_are_vindicator1,
 				GLOBAL_SIS (ShipName),
 				we_are_vindicator2,
-				NULL_PTR);
+				(UNICODE*)NULL);
 		DoResponsePhrase (we_are_vindicator0, ExitConversation, shared_phrase_buf);
 		Response (gort_merenga, ExitConversation);
 		Response (guph_florp, ExitConversation);
@@ -982,10 +986,10 @@ post_spahome_enc (void)
 	}
 }
 
-LOCDATAPTR
+LOCDATA*
 init_spahome_comm ()
 {
-	LOCDATAPTR retval;
+	LOCDATA *retval;
 
 	spahome_desc.init_encounter_func = Intro;
 	spahome_desc.post_encounter_func = post_spahome_enc;
@@ -996,7 +1000,7 @@ init_spahome_comm ()
 	spahome_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
 
 	// use alternate "Safe Ones" track if available
-	spahome_desc.AlienAltSong = SPAHOME_MUSIC;
+	spahome_desc.AlienAltSongRes = SPAHOME_MUSIC;
 	spahome_desc.AlienSongFlags |= LDASF_USE_ALTERNATE;
 
 	if (GET_GAME_STATE (SPATHI_MANNER) == 3)
diff -ruNp src.orig/sc2code/comm/spathi/ifontres.h src/sc2code/comm/spathi/ifontres.h
--- src.orig/sc2code/comm/spathi/ifontres.h	2017-11-08 16:49:25 -0600
+++ src/sc2code/comm/spathi/ifontres.h	2017-11-08 16:49:53 -0600
@@ -1,3 +1,5 @@
-#define SPATHI_FONT 0x00200003L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SPATHI_FONT "comm.spathi.font"
diff -ruNp src.orig/sc2code/comm/spathi/igfxres.h src/sc2code/comm/spathi/igfxres.h
--- src.orig/sc2code/comm/spathi/igfxres.h	2017-11-08 16:49:25 -0600
+++ src/sc2code/comm/spathi/igfxres.h	2017-11-08 16:49:53 -0600
@@ -1,4 +1,6 @@
-#define SPATHI_PMAP_ANIM 0x00200002L
-#define SPATHI_HOME_PMAP_ANIM 0x00400102L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SPATHI_HOME_PMAP_ANIM "comm.spahome.graphics"
+#define SPATHI_PMAP_ANIM "comm.spathi.graphics"
diff -ruNp src.orig/sc2code/comm/spathi/imusicre.h src/sc2code/comm/spathi/imusicre.h
--- src.orig/sc2code/comm/spathi/imusicre.h	2017-11-08 16:49:25 -0600
+++ src/sc2code/comm/spathi/imusicre.h	2017-11-08 16:49:53 -0600
@@ -1,6 +1,7 @@
-#define SPATHI_MUSIC 0x00600006L
-
-#define SPAHOME_MUSIC 0x00800106L
-#define FWIFFO_MUSIC 0x00a00206L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define FWIFFO_MUSIC "comm.spafwiff.music"
+#define SPAHOME_MUSIC "comm.spahome.music"
+#define SPATHI_MUSIC "comm.spathi.music"
diff -ruNp src.orig/sc2code/comm/spathi/istrtab.h src/sc2code/comm/spathi/istrtab.h
--- src.orig/sc2code/comm/spathi/istrtab.h	2017-11-08 16:49:25 -0600
+++ src/sc2code/comm/spathi/istrtab.h	2017-11-08 16:49:53 -0600
@@ -1,6 +1,8 @@
-#define SPATHI_CONVERSATION_PHRASES 0x00200004L
-#define SPATHI_HOME_COLOR_MAP 0x00400104L
-#define SPATHI_HOME_CONVERSATION_PHRASES 0x00400204L
-#define SPATHI_COLOR_MAP 0x00200304L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SPATHI_COLOR_MAP "comm.spathi.colortable"
+#define SPATHI_CONVERSATION_PHRASES "comm.spathi.dialogue"
+#define SPATHI_HOME_COLOR_MAP "comm.spahome.colortable"
+#define SPATHI_HOME_CONVERSATION_PHRASES "comm.spahome.dialogue"
diff -ruNp src.orig/sc2code/comm/spathi/spathic.c src/sc2code/comm/spathi/spathic.c
--- src.orig/sc2code/comm/spathi/spathic.c	2017-11-08 16:49:25 -0600
+++ src/sc2code/comm/spathi/spathic.c	2017-11-08 16:49:53 -0600
@@ -25,20 +25,20 @@
 
 static LOCDATA spathi_desc =
 {
-	NULL_PTR, /* init_encounter_func */
-	NULL_PTR, /* post_encounter_func */
-	NULL_PTR, /* uninit_encounter_func */
-	(FRAME)SPATHI_PMAP_ANIM, /* AlienFrame */
-	(FONT)SPATHI_FONT, /* AlienFont */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	SPATHI_PMAP_ANIM, /* AlienFrame */
+	SPATHI_FONT, /* AlienFont */
 	WHITE_COLOR, /* AlienTextFColor */
 	BLACK_COLOR, /* AlienTextBColor */
 	{0, 0}, /* AlienTextBaseline */
 	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
 	ALIGN_CENTER, /* AlienTextAlign */
 	VALIGN_TOP, /* AlienTextValign */
-	(COLORMAP)SPATHI_COLOR_MAP, /* AlienColorMap */
+	SPATHI_COLOR_MAP, /* AlienColorMap */
 	SPATHI_MUSIC, /* AlienSong */
-	0, /* AlienAltSong */
+	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	SPATHI_CONVERSATION_PHRASES, /* PlayerPhrases */
 	8, /* NumAnimations */
@@ -116,7 +116,7 @@ static LOCDATA spathi_desc =
 		0, /* AnimFlags */
 		0, 0, /* FrameRate */
 		0, 0, /* RestartRate */
-			0, /* BlockMask */
+		0, /* BlockMask */
 	},
 #ifdef NEVER
 	{ /* AlienTalkDesc */
@@ -137,7 +137,11 @@ static LOCDATA spathi_desc =
 		0, /* BlockMask */
 	},
 #endif /* NEVER */
-	NULL_PTR, /* AlienNumberSpeech - none */
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
 };
 
 static void
@@ -192,6 +196,9 @@ ExitConversation (RESPONSE_REF Response)
 
 			AlienTalkSegue ((COUNT)~0);
 			ActivateStarShip (SPATHI_SHIP, 1);
+			/* Make the Eluder escort captained by Fwiffo alone */
+			SetEscortCrewComplement (SPATHI_SHIP, 1,
+					NAME_OFFSET + NUM_CAPTAINS_NAMES);
 		}
 	}
 }
@@ -788,10 +795,10 @@ post_spathi_enc (void)
 	}
 }
 
-LOCDATAPTR
+LOCDATA*
 init_spathi_comm (void)
 {
-	LOCDATAPTR retval;
+	LOCDATA *retval;
 
 	spathi_desc.init_encounter_func = Intro;
 	spathi_desc.post_encounter_func = post_spathi_enc;
@@ -803,7 +810,7 @@ init_spathi_comm (void)
 
 	if (GET_GAME_STATE (FOUND_PLUTO_SPATHI) == 1)
 	{	// use alternate Fwiffo track if available
-		spathi_desc.AlienAltSong = FWIFFO_MUSIC;
+		spathi_desc.AlienAltSongRes = FWIFFO_MUSIC;
 		spathi_desc.AlienSongFlags |= LDASF_USE_ALTERNATE;
 	}
 	else
diff -ruNp src.orig/sc2code/comm/starbas/starbas.c src/sc2code/comm/starbas/starbas.c
--- src.orig/sc2code/comm/starbas/starbas.c	2017-11-08 16:49:25 -0600
+++ src/sc2code/comm/starbas/starbas.c	2017-11-08 16:49:53 -0600
@@ -36,20 +36,20 @@ static void SellMinerals (RESPONSE_REF R
 
 static LOCDATA commander_desc =
 {
-	NULL_PTR, /* init_encounter_func */
-	NULL_PTR, /* post_encounter_func */
-	NULL_PTR, /* uninit_encounter_func */
-	(FRAME)COMMANDER_PMAP_ANIM, /* AlienFrame */
-	(FONT)COMMANDER_FONT, /* AlienFont */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	COMMANDER_PMAP_ANIM, /* AlienFrame */
+	COMMANDER_FONT, /* AlienFont */
 	WHITE_COLOR, /* AlienTextFColor */
 	BLACK_COLOR, /* AlienTextBColor */
 	{0, 0}, /* AlienTextBaseline */
 	0, /* SIS_TEXT_WIDTH, */ /* AlienTextWidth */
 	ALIGN_CENTER, /* AlienTextAlign */
 	VALIGN_MIDDLE, /* AlienTextValign */
-	(COLORMAP)COMMANDER_COLOR_MAP, /* AlienColorMap */
+	COMMANDER_COLOR_MAP, /* AlienColorMap */
 	COMMANDER_MUSIC, /* AlienSong */
-	0, /* AlienAltSong */
+	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	STARBASE_CONVERSATION_PHRASES, /* PlayerPhrases */
 	10, /* NumAnimations */
@@ -151,7 +151,11 @@ static LOCDATA commander_desc =
 		ONE_SECOND * 7 / 60, ONE_SECOND / 12, /* RestartRate */
 		0, /* BlockMask */
 	},
-	NULL_PTR, /* AlienNumberSpeech - none */
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
 };
 
 static DWORD CurBulletinMask;
@@ -935,8 +939,7 @@ TellStarBase (RESPONSE_REF R)
 					tell_me_about_modules0,
 					GLOBAL_SIS (ShipName),
 					tell_me_about_modules1,
-					NULL_PTR
-					);
+					(UNICODE*)NULL);
 			pstack[0] = tell_me_about_modules0;
 			break;
 		default:
@@ -951,8 +954,7 @@ TellStarBase (RESPONSE_REF R)
 					tell_me_about_fuel0,
 					GLOBAL_SIS (ShipName),
 					tell_me_about_fuel1,
-					NULL_PTR
-					);
+					(UNICODE*)NULL);
 			pstack[1] = tell_me_about_fuel0;
 			break;
 		default:
@@ -1155,7 +1157,7 @@ DiscussDevices (BOOLEAN TalkAbout)
 				if (GET_GAME_STATE (DATA_PLATE_1_ON_SHIP)
 						&& !GET_GAME_STATE (DISCUSSED_DATA_PLATE_1))
 				{
-					pStr = (PSTR)ABOUT_DATAPLATE_1;
+					pStr = ABOUT_DATAPLATE_1;
 					SET_GAME_STATE (DISCUSSED_DATA_PLATE_1, TalkAbout);
 				}
 				break;
@@ -1163,7 +1165,7 @@ DiscussDevices (BOOLEAN TalkAbout)
 				if (GET_GAME_STATE (DATA_PLATE_2_ON_SHIP)
 						&& !GET_GAME_STATE (DISCUSSED_DATA_PLATE_2))
 				{
-					pStr = (PSTR)ABOUT_DATAPLATE_2;
+					pStr = ABOUT_DATAPLATE_2;
 					SET_GAME_STATE (DISCUSSED_DATA_PLATE_2, TalkAbout);
 				}
 				break;
@@ -1171,7 +1173,7 @@ DiscussDevices (BOOLEAN TalkAbout)
 				if (GET_GAME_STATE (DATA_PLATE_3_ON_SHIP)
 						&& !GET_GAME_STATE (DISCUSSED_DATA_PLATE_3))
 				{
-					pStr = (PSTR)ABOUT_DATAPLATE_3;
+					pStr = ABOUT_DATAPLATE_3;
 					SET_GAME_STATE (DISCUSSED_DATA_PLATE_3, TalkAbout);
 				}
 				break;
@@ -1911,7 +1913,7 @@ SellMinerals (RESPONSE_REF R)
 static void
 Intro (void)
 {
-	NormalStarbase (NULL_PTR);
+	NormalStarbase (0);
 }
 
 static COUNT
@@ -1930,10 +1932,10 @@ post_starbase_enc (void)
 	}
 }
 
-LOCDATAPTR
+LOCDATA*
 init_starbase_comm ()
 {
-	LOCDATAPTR retval;
+	LOCDATA *retval;
 
 	commander_desc.init_encounter_func = Intro;
 	commander_desc.post_encounter_func = post_starbase_enc;
@@ -1944,7 +1946,7 @@ init_starbase_comm ()
 	commander_desc.AlienTextBaseline.y = 20;
 
 	// use alternate Starbase track if available
-	commander_desc.AlienAltSong = STARBASE_ALT_MUSIC;
+	commander_desc.AlienAltSongRes = STARBASE_ALT_MUSIC;
 	commander_desc.AlienSongFlags |= LDASF_USE_ALTERNATE;
 
 	CurBulletinMask = 0;
diff -ruNp src.orig/sc2code/comm/supox/ifontres.h src/sc2code/comm/supox/ifontres.h
--- src.orig/sc2code/comm/supox/ifontres.h	2017-11-08 16:49:25 -0600
+++ src/sc2code/comm/supox/ifontres.h	2017-11-08 16:49:53 -0600
@@ -1,3 +1,5 @@
-#define SUPOX_FONT 0x00200003L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SUPOX_FONT "comm.supox.font"
diff -ruNp src.orig/sc2code/comm/supox/igfxres.h src/sc2code/comm/supox/igfxres.h
--- src.orig/sc2code/comm/supox/igfxres.h	2017-11-08 16:49:25 -0600
+++ src/sc2code/comm/supox/igfxres.h	2017-11-08 16:49:53 -0600
@@ -1,3 +1,5 @@
-#define SUPOX_PMAP_ANIM 0x00200002L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SUPOX_PMAP_ANIM "comm.supox.graphics"
diff -ruNp src.orig/sc2code/comm/supox/imusicre.h src/sc2code/comm/supox/imusicre.h
--- src.orig/sc2code/comm/supox/imusicre.h	2017-11-08 16:49:25 -0600
+++ src/sc2code/comm/supox/imusicre.h	2017-11-08 16:49:53 -0600
@@ -1,3 +1,5 @@
-#define SUPOX_MUSIC 0x00200006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SUPOX_MUSIC "comm.supox.music"
diff -ruNp src.orig/sc2code/comm/supox/istrtab.h src/sc2code/comm/supox/istrtab.h
--- src.orig/sc2code/comm/supox/istrtab.h	2017-11-08 16:49:25 -0600
+++ src/sc2code/comm/supox/istrtab.h	2017-11-08 16:49:53 -0600
@@ -1,3 +1,6 @@
-#define SUPOX_CONVERSATION_PHRASES 0x00200004L
-#define SUPOX_COLOR_MAP 0x00200104L
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SUPOX_COLOR_MAP "comm.supox.colortable"
+#define SUPOX_CONVERSATION_PHRASES "comm.supox.dialogue"
diff -ruNp src.orig/sc2code/comm/supox/supoxc.c src/sc2code/comm/supox/supoxc.c
--- src.orig/sc2code/comm/supox/supoxc.c	2017-11-08 16:49:25 -0600
+++ src/sc2code/comm/supox/supoxc.c	2017-11-08 16:49:53 -0600
@@ -25,20 +25,20 @@
 
 static LOCDATA supox_desc =
 {
-	NULL_PTR, /* init_encounter_func */
-	NULL_PTR, /* post_encounter_func */
-	NULL_PTR, /* uninit_encounter_func */
-	(FRAME)SUPOX_PMAP_ANIM, /* AlienFrame */
-	(FONT)SUPOX_FONT, /* AlienFont */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	SUPOX_PMAP_ANIM, /* AlienFrame */
+	SUPOX_FONT, /* AlienFont */
 	WHITE_COLOR, /* AlienTextFColor */
 	BLACK_COLOR, /* AlienTextBColor */
 	{0, 0}, /* AlienTextBaseline */
 	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
 	ALIGN_CENTER, /* AlienTextAlign */
 	VALIGN_TOP, /* AlienTextValign */
-	(COLORMAP)SUPOX_COLOR_MAP, /* AlienColorMap */
+	SUPOX_COLOR_MAP, /* AlienColorMap */
 	SUPOX_MUSIC, /* AlienSong */
-	0, /* AlienAltSong */
+	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	SUPOX_CONVERSATION_PHRASES, /* PlayerPhrases */
 	4, /* NumAnimations */
@@ -93,7 +93,11 @@ static LOCDATA supox_desc =
 		ONE_SECOND / 12, 0, /* RestartRate */	
 		0, /* BlockMask */
 	},
-	NULL_PTR, /* AlienNumberSpeech - none */
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
 };
 
 static void
@@ -422,7 +426,7 @@ NeutralSupox (RESPONSE_REF R)
 					i_am0,
 					GLOBAL_SIS (CommanderName),
 					i_am1,
-					NULL_PTR);
+					(UNICODE*)NULL);
 			pStr[0] = i_am0;
 			pStr[1] = 0;
 			break;
@@ -431,7 +435,7 @@ NeutralSupox (RESPONSE_REF R)
 					my_ship0,
 					GLOBAL_SIS (ShipName),
 					my_ship1,
-					NULL_PTR);
+					(UNICODE*)NULL);
 			pStr[0] = my_ship0;
 			pStr[1] = 0;
 			break;
@@ -445,8 +449,7 @@ NeutralSupox (RESPONSE_REF R)
 						from_alliance0,
 						buf,
 						from_alliance1,
-						NULL_PTR
-						);
+						(UNICODE*)NULL);
 			}
 			pStr[0] = from_alliance0;
 			pStr[1] = 0;
@@ -677,10 +680,10 @@ post_supox_enc (void)
 	// nothing defined so far
 }
 
-LOCDATAPTR
+LOCDATA*
 init_supox_comm (void)
 {
-	LOCDATAPTR retval;
+	LOCDATA *retval;
 
 	supox_desc.init_encounter_func = Intro;
 	supox_desc.post_encounter_func = post_supox_enc;
diff -ruNp src.orig/sc2code/comm/syreen/ifontres.h src/sc2code/comm/syreen/ifontres.h
--- src.orig/sc2code/comm/syreen/ifontres.h	2017-11-08 16:49:25 -0600
+++ src/sc2code/comm/syreen/ifontres.h	2017-11-08 16:49:53 -0600
@@ -1,3 +1,5 @@
-#define SYREEN_FONT 0x00200003L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SYREEN_FONT "comm.syreen.font"
diff -ruNp src.orig/sc2code/comm/syreen/igfxres.h src/sc2code/comm/syreen/igfxres.h
--- src.orig/sc2code/comm/syreen/igfxres.h	2017-11-08 16:49:25 -0600
+++ src/sc2code/comm/syreen/igfxres.h	2017-11-08 16:49:53 -0600
@@ -1,3 +1,5 @@
-#define SYREEN_PMAP_ANIM 0x00200002L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SYREEN_PMAP_ANIM "comm.syreen.graphics"
diff -ruNp src.orig/sc2code/comm/syreen/imusicre.h src/sc2code/comm/syreen/imusicre.h
--- src.orig/sc2code/comm/syreen/imusicre.h	2017-11-08 16:49:25 -0600
+++ src/sc2code/comm/syreen/imusicre.h	2017-11-08 16:49:53 -0600
@@ -1,3 +1,5 @@
-#define SYREEN_MUSIC 0x00200006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SYREEN_MUSIC "comm.syreen.music"
diff -ruNp src.orig/sc2code/comm/syreen/istrtab.h src/sc2code/comm/syreen/istrtab.h
--- src.orig/sc2code/comm/syreen/istrtab.h	2017-11-08 16:49:25 -0600
+++ src/sc2code/comm/syreen/istrtab.h	2017-11-08 16:49:53 -0600
@@ -1,4 +1,6 @@
-#define SYREEN_CONVERSATION_PHRASES 0x00200004L
-#define SYREEN_COLOR_MAP 0x00200104L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SYREEN_COLOR_MAP "comm.syreen.colortable"
+#define SYREEN_CONVERSATION_PHRASES "comm.syreen.dialogue"
diff -ruNp src.orig/sc2code/comm/syreen/syreenc.c src/sc2code/comm/syreen/syreenc.c
--- src.orig/sc2code/comm/syreen/syreenc.c	2017-11-08 16:49:26 -0600
+++ src/sc2code/comm/syreen/syreenc.c	2017-11-08 16:49:53 -0600
@@ -21,25 +21,26 @@
 #include "comm/syreen/strings.h"
 #include "libs/sound/sound.h"
 
+#include "gameev.h"
 #include "build.h"
 
 
 static LOCDATA syreen_desc =
 {
-	NULL_PTR, /* init_encounter_func */
-	NULL_PTR, /* post_encounter_func */
-	NULL_PTR, /* uninit_encounter_func */
-	(FRAME)SYREEN_PMAP_ANIM, /* AlienFrame */
-	(FONT)SYREEN_FONT, /* AlienFont */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	SYREEN_PMAP_ANIM, /* AlienFrame */
+	SYREEN_FONT, /* AlienFont */
 	WHITE_COLOR, /* AlienTextFColor */
 	BLACK_COLOR, /* AlienTextBColor */
 	{0, 0}, /* AlienTextBaseline */
 	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
 	ALIGN_CENTER, /* AlienTextAlign */
 	VALIGN_TOP, /* AlienTextValign */
-	(COLORMAP)SYREEN_COLOR_MAP, /* AlienColorMap */
+	SYREEN_COLOR_MAP, /* AlienColorMap */
 	SYREEN_MUSIC, /* AlienSong */
-	0, /* AlienAltSong */
+	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	SYREEN_CONVERSATION_PHRASES, /* PlayerPhrases */
 	15, /* NumAnimations */
@@ -183,7 +184,11 @@ static LOCDATA syreen_desc =
 		ONE_SECOND / 12, 0, /* RestartRate */
 		0, /* BlockMask */
 	},
-	NULL_PTR, /* AlienNumberSpeech - none */
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
 };
 
 static void
@@ -687,12 +692,29 @@ InitialSyreen (RESPONSE_REF R)
 static void
 PlanAmbush (RESPONSE_REF R)
 {
+	HFLEETINFO hSyreen;
+	FLEET_INFO *SyreenPtr;
+
 	(void) R;  // ignored
 	NPCPhrase (OK_FOUND_VAULT);
 
 	SET_GAME_STATE (MYCON_AMBUSH, 1);
 	SET_GAME_STATE (SYREEN_HOME_VISITS, 0);
 
+	// Send ambush fleet to Organon.  EncounterPercent for the
+	// Syreen is 0, so this is purely decorative.
+	hSyreen = GetStarShipFromIndex (&GLOBAL (avail_race_q), SYREEN_SHIP);
+	SyreenPtr = LockFleetInfo (&GLOBAL (avail_race_q), hSyreen);
+	if (SyreenPtr)
+	{
+		SyreenPtr->actual_strength = 300 / SPHERE_RADIUS_INCREMENT * 2;
+		SyreenPtr->loc.x = 4125;
+		SyreenPtr->loc.y = 3770;
+		ActivateStarShip (SYREEN_SHIP, SPHERE_TRACKING);
+		SetRaceDest (SYREEN_SHIP, 6858, 577, 15, (BYTE)~0);
+	}
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hSyreen);
+
 	Response (whats_my_reward, Foreplay);
 	Response (bye_after_vault, FriendlyExit);
 }
@@ -734,7 +756,7 @@ Intro (void)
 		{
 			case 0:
 				NPCPhrase (HELLO_AFTER_AMBUSH_1);
-				ActivateStarShip (SYREEN_SHIP, 0);
+				ActivateStarShip (SYREEN_SHIP, SET_ALLIED);
 				break;
 			case 1:
 				NPCPhrase (HELLO_AFTER_AMBUSH_2);
@@ -791,7 +813,7 @@ Intro (void)
 					we_are_vindicator1,
 					GLOBAL_SIS (ShipName),
 					we_are_vindicator2,
-					NULL_PTR);
+					(UNICODE*)NULL);
 			Response (we_are_vice_squad, InitialSyreen);
 			Response (we_are_the_one_for_you_baby, InitialSyreen);
 			DoResponsePhrase (we_are_vindicator0, InitialSyreen, shared_phrase_buf);
@@ -846,10 +868,10 @@ post_syreen_enc (void)
 	// nothing defined so far
 }
 
-LOCDATAPTR
+LOCDATA*
 init_syreen_comm (void)
 {
-	LOCDATAPTR retval;
+	LOCDATA *retval;
 
 	syreen_desc.init_encounter_func = Intro;
 	syreen_desc.post_encounter_func = post_syreen_enc;
diff -ruNp src.orig/sc2code/comm/talkpet/ifontres.h src/sc2code/comm/talkpet/ifontres.h
--- src.orig/sc2code/comm/talkpet/ifontres.h	2017-11-08 16:49:26 -0600
+++ src/sc2code/comm/talkpet/ifontres.h	2017-11-08 16:49:53 -0600
@@ -1,3 +1,5 @@
-#define TALKING_PET_FONT 0x00200003L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define TALKING_PET_FONT "comm.talkingpet.font"
diff -ruNp src.orig/sc2code/comm/talkpet/igfxres.h src/sc2code/comm/talkpet/igfxres.h
--- src.orig/sc2code/comm/talkpet/igfxres.h	2017-11-08 16:49:26 -0600
+++ src/sc2code/comm/talkpet/igfxres.h	2017-11-08 16:49:53 -0600
@@ -1,3 +1,5 @@
-#define TALKING_PET_PMAP_ANIM 0x00200002L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define TALKING_PET_PMAP_ANIM "comm.talkingpet.graphics"
diff -ruNp src.orig/sc2code/comm/talkpet/imusicre.h src/sc2code/comm/talkpet/imusicre.h
--- src.orig/sc2code/comm/talkpet/imusicre.h	2017-11-08 16:49:26 -0600
+++ src/sc2code/comm/talkpet/imusicre.h	2017-11-08 16:49:53 -0600
@@ -1,3 +1,5 @@
-#define TALKING_PET_MUSIC 0x00200006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define TALKING_PET_MUSIC "comm.talkingpet.music"
diff -ruNp src.orig/sc2code/comm/talkpet/istrtab.h src/sc2code/comm/talkpet/istrtab.h
--- src.orig/sc2code/comm/talkpet/istrtab.h	2017-11-08 16:49:26 -0600
+++ src/sc2code/comm/talkpet/istrtab.h	2017-11-08 16:49:53 -0600
@@ -1,4 +1,6 @@
-#define TALKING_PET_CONVERSATION_PHRASES 0x00200004L
-#define TALKING_PET_COLOR_MAP 0x00200104L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define TALKING_PET_COLOR_MAP "comm.talkingpet.colortable"
+#define TALKING_PET_CONVERSATION_PHRASES "comm.talkingpet.dialogue"
diff -ruNp src.orig/sc2code/comm/talkpet/talkpet.c src/sc2code/comm/talkpet/talkpet.c
--- src.orig/sc2code/comm/talkpet/talkpet.c	2017-11-08 16:49:26 -0600
+++ src/sc2code/comm/talkpet/talkpet.c	2017-11-08 16:49:53 -0600
@@ -24,20 +24,20 @@
 
 static LOCDATA talkpet_desc =
 {
-	NULL_PTR, /* init_encounter_func */
-	NULL_PTR, /* post_encounter_func */
-	NULL_PTR, /* uninit_encounter_func */
-	(FRAME)TALKING_PET_PMAP_ANIM, /* AlienFrame */
-	(FONT)TALKING_PET_FONT, /* AlienFont */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	TALKING_PET_PMAP_ANIM, /* AlienFrame */
+	TALKING_PET_FONT, /* AlienFont */
 	WHITE_COLOR, /* AlienTextFColor */
 	BLACK_COLOR, /* AlienTextBColor */
 	{0, 0}, /* AlienTextBaseline */
 	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
 	ALIGN_CENTER, /* AlienTextAlign */
 	VALIGN_TOP, /* AlienTextValign */
-	(COLORMAP)TALKING_PET_COLOR_MAP, /* AlienColorMap */
+	TALKING_PET_COLOR_MAP, /* AlienColorMap */
 	TALKING_PET_MUSIC, /* AlienSong */
-	0, /* AlienAltSong */
+	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	TALKING_PET_CONVERSATION_PHRASES, /* PlayerPhrases */
 	16, /* NumAnimations */
@@ -190,7 +190,11 @@ static LOCDATA talkpet_desc =
 		ONE_SECOND / 12, 0, /* RestartRate */
 		0, /* BlockMask */
 	},
-	NULL_PTR, /* AlienNumberSpeech - none */
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
 };
 
 #define STROBE_RATE   15
@@ -520,8 +524,7 @@ CompelPlayer (RESPONSE_REF R)
 				we_are_vindicator0,
 				GLOBAL_SIS (ShipName),
 				we_are_vindicator1,
-				NULL_PTR
-				);
+				(UNICODE*)NULL);
 		pStr[2] = we_are_vindicator0;
 	}
 	else
@@ -792,10 +795,10 @@ post_talkpet_enc (void)
 	// nothing defined so far
 }
 
-LOCDATAPTR
+LOCDATA*
 init_talkpet_comm (void)
 {
-	LOCDATAPTR retval;
+	LOCDATA *retval;
 
 	talkpet_desc.init_encounter_func = Intro;
 	talkpet_desc.post_encounter_func = post_talkpet_enc;
diff -ruNp src.orig/sc2code/comm/thradd/ifontres.h src/sc2code/comm/thradd/ifontres.h
--- src.orig/sc2code/comm/thradd/ifontres.h	2017-11-08 16:49:26 -0600
+++ src/sc2code/comm/thradd/ifontres.h	2017-11-08 16:49:53 -0600
@@ -1,3 +1,5 @@
-#define THRADD_FONT 0x00200003L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define THRADD_FONT "comm.thraddash.font"
diff -ruNp src.orig/sc2code/comm/thradd/igfxres.h src/sc2code/comm/thradd/igfxres.h
--- src.orig/sc2code/comm/thradd/igfxres.h	2017-11-08 16:49:26 -0600
+++ src/sc2code/comm/thradd/igfxres.h	2017-11-08 16:49:53 -0600
@@ -1,3 +1,5 @@
-#define THRADD_PMAP_ANIM 0x00200002L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define THRADD_PMAP_ANIM "comm.thraddash.graphics"
diff -ruNp src.orig/sc2code/comm/thradd/imusicre.h src/sc2code/comm/thradd/imusicre.h
--- src.orig/sc2code/comm/thradd/imusicre.h	2017-11-08 16:49:26 -0600
+++ src/sc2code/comm/thradd/imusicre.h	2017-11-08 16:49:53 -0600
@@ -1,3 +1,5 @@
-#define THRADD_MUSIC 0x00200006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define THRADD_MUSIC "comm.thraddash.music"
diff -ruNp src.orig/sc2code/comm/thradd/istrtab.h src/sc2code/comm/thradd/istrtab.h
--- src.orig/sc2code/comm/thradd/istrtab.h	2017-11-08 16:49:26 -0600
+++ src/sc2code/comm/thradd/istrtab.h	2017-11-08 16:49:53 -0600
@@ -1,3 +1,6 @@
-#define THRADD_CONVERSATION_PHRASES 0x00200004L
-#define THRADD_COLOR_MAP 0x00200104L
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define THRADD_COLOR_MAP "comm.thraddash.colortable"
+#define THRADD_CONVERSATION_PHRASES "comm.thraddash.dialogue"
diff -ruNp src.orig/sc2code/comm/thradd/thraddc.c src/sc2code/comm/thradd/thraddc.c
--- src.orig/sc2code/comm/thradd/thraddc.c	2017-11-08 16:49:26 -0600
+++ src/sc2code/comm/thradd/thraddc.c	2017-11-08 16:49:53 -0600
@@ -26,20 +26,20 @@
 
 static LOCDATA thradd_desc =
 {
-	NULL_PTR, /* init_encounter_func */
-	NULL_PTR, /* post_encounter_func */
-	NULL_PTR, /* uninit_encounter_func */
-	(FRAME)THRADD_PMAP_ANIM, /* AlienFrame */
-	(FONT)THRADD_FONT, /* AlienFont */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	THRADD_PMAP_ANIM, /* AlienFrame */
+	THRADD_FONT, /* AlienFont */
 	WHITE_COLOR, /* AlienTextFColor */
 	BLACK_COLOR, /* AlienTextBColor */
 	{0, 0}, /* AlienTextBaseline */
 	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
 	ALIGN_CENTER, /* AlienTextAlign */
 	VALIGN_TOP, /* AlienTextValign */
-	(COLORMAP)THRADD_COLOR_MAP, /* AlienColorMap */
+	THRADD_COLOR_MAP, /* AlienColorMap */
 	THRADD_MUSIC, /* AlienSong */
-	0, /* AlienAltSong */
+	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	THRADD_CONVERSATION_PHRASES, /* PlayerPhrases */
 	8, /* NumAnimations */
@@ -126,7 +126,11 @@ static LOCDATA thradd_desc =
 		ONE_SECOND / 12, 0, /* RestartRate */
 		0, /* BlockMask */
 	},
-	NULL_PTR, /* AlienNumberSpeech - none */
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
 };
 
 static int
@@ -485,7 +489,7 @@ ThraddCulture (RESPONSE_REF R)
 			the_slave_empire0,
 			GLOBAL_SIS (CommanderName),
 			the_slave_empire1,
-			NULL_PTR);
+			(UNICODE*)NULL);
 
 	Response (you_decide, ThraddDemeanor);
 	Response (fat, ThraddDemeanor);
@@ -499,7 +503,7 @@ ThraddWorship (RESPONSE_REF R)
 	SET_GAME_STATE (THRADD_VISITS, 0);
 	SET_GAME_STATE (THRADD_MANNER, 1);
 	SET_GAME_STATE (THRADD_STACK_1, 0);
-	ActivateStarShip (THRADDASH_SHIP, 0);
+	ActivateStarShip (THRADDASH_SHIP, SET_ALLIED);
 
 	Response (be_polite, ThraddCulture);
 	Response (speak_pig_latin, ThraddCulture);
@@ -920,10 +924,10 @@ post_thradd_enc (void)
 	// nothing defined so far
 }
 
-LOCDATAPTR
+LOCDATA*
 init_thradd_comm (void)
 {
-	LOCDATAPTR retval;
+	LOCDATA *retval;
 
 	thradd_desc.init_encounter_func = Intro;
 	thradd_desc.post_encounter_func = post_thradd_enc;
diff -ruNp src.orig/sc2code/comm/umgah/ifontres.h src/sc2code/comm/umgah/ifontres.h
--- src.orig/sc2code/comm/umgah/ifontres.h	2017-11-08 16:49:26 -0600
+++ src/sc2code/comm/umgah/ifontres.h	2017-11-08 16:49:53 -0600
@@ -1,3 +1,5 @@
-#define UMGAH_FONT 0x00200003L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define UMGAH_FONT "comm.umgah.font"
diff -ruNp src.orig/sc2code/comm/umgah/igfxres.h src/sc2code/comm/umgah/igfxres.h
--- src.orig/sc2code/comm/umgah/igfxres.h	2017-11-08 16:49:26 -0600
+++ src/sc2code/comm/umgah/igfxres.h	2017-11-08 16:49:54 -0600
@@ -1,3 +1,5 @@
-#define UMGAH_PMAP_ANIM 0x00200002L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define UMGAH_PMAP_ANIM "comm.umgah.graphics"
diff -ruNp src.orig/sc2code/comm/umgah/imusicre.h src/sc2code/comm/umgah/imusicre.h
--- src.orig/sc2code/comm/umgah/imusicre.h	2017-11-08 16:49:26 -0600
+++ src/sc2code/comm/umgah/imusicre.h	2017-11-08 16:49:54 -0600
@@ -1,3 +1,5 @@
-#define UMGAH_MUSIC 0x00200006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define UMGAH_MUSIC "comm.umgah.music"
diff -ruNp src.orig/sc2code/comm/umgah/istrtab.h src/sc2code/comm/umgah/istrtab.h
--- src.orig/sc2code/comm/umgah/istrtab.h	2017-11-08 16:49:26 -0600
+++ src/sc2code/comm/umgah/istrtab.h	2017-11-08 16:49:54 -0600
@@ -1,3 +1,6 @@
-#define UMGAH_CONVERSATION_PHRASES 0x00200004L
-#define UMGAH_COLOR_MAP 0x00200104L
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define UMGAH_COLOR_MAP "comm.umgah.colortable"
+#define UMGAH_CONVERSATION_PHRASES "comm.umgah.dialogue"
diff -ruNp src.orig/sc2code/comm/umgah/umgahc.c src/sc2code/comm/umgah/umgahc.c
--- src.orig/sc2code/comm/umgah/umgahc.c	2017-11-08 16:49:26 -0600
+++ src/sc2code/comm/umgah/umgahc.c	2017-11-08 16:49:54 -0600
@@ -25,20 +25,20 @@
 
 static LOCDATA umgah_desc =
 {
-	NULL_PTR, /* init_encounter_func */
-	NULL_PTR, /* post_encounter_func */
-	NULL_PTR, /* uninit_encounter_func */
-	(FRAME)UMGAH_PMAP_ANIM, /* AlienFrame */
-	(FONT)UMGAH_FONT, /* AlienFont */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	UMGAH_PMAP_ANIM, /* AlienFrame */
+	UMGAH_FONT, /* AlienFont */
 	WHITE_COLOR, /* AlienTextFColor */
 	BLACK_COLOR, /* AlienTextBColor */
 	{0, 0}, /* AlienTextBaseline */
 	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
 	ALIGN_CENTER, /* AlienTextAlign */
 	VALIGN_TOP, /* AlienTextValign */
-	(COLORMAP)UMGAH_COLOR_MAP, /* AlienColorMap */
+	UMGAH_COLOR_MAP, /* AlienColorMap */
 	UMGAH_MUSIC, /* AlienSong */
-	0, /* AlienAltSong */
+	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	UMGAH_CONVERSATION_PHRASES, /* PlayerPhrases */
 	16, /* NumAnimations */
@@ -188,7 +188,11 @@ static LOCDATA umgah_desc =
 		ONE_SECOND / 12, 0, /* RestartRate */
 		0, /* BlockMask */
 	},
-	NULL_PTR, /* AlienNumberSpeech - none */
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
 };
 
 static void
@@ -368,7 +372,7 @@ Zombies (RESPONSE_REF R)
 					we_vindicator1,
 					GLOBAL_SIS (ShipName),
 					we_vindicator2,
-					NULL_PTR);
+					(UNICODE*)NULL);
 			pStr[1] = we_vindicator0;
 		}
 		else if (PHRASE_ENABLED (come_in_peace))
@@ -697,10 +701,10 @@ post_umgah_enc (void)
 	}
 }
 
-LOCDATAPTR
+LOCDATA*
 init_umgah_comm (void)
 {
-	LOCDATAPTR retval;
+	LOCDATA *retval;
 
 	umgah_desc.init_encounter_func = Intro;
 	umgah_desc.post_encounter_func = post_umgah_enc;
diff -ruNp src.orig/sc2code/comm/urquan/icode.h src/sc2code/comm/urquan/icode.h
--- src.orig/sc2code/comm/urquan/icode.h	2017-11-08 16:49:26 -0600
+++ src/sc2code/comm/urquan/icode.h	1969-12-31 18:00:00 -0600
@@ -1,4 +0,0 @@
-#define URQUAN_CODE 0x00200006L
-
-typedef RESOURCE CODE_INSTANCE;
-
diff -ruNp src.orig/sc2code/comm/urquan/ifontres.h src/sc2code/comm/urquan/ifontres.h
--- src.orig/sc2code/comm/urquan/ifontres.h	2017-11-08 16:49:26 -0600
+++ src/sc2code/comm/urquan/ifontres.h	2017-11-08 16:49:54 -0600
@@ -1,3 +1,5 @@
-#define URQUAN_FONT 0x00200003L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define URQUAN_FONT "comm.urquan.font"
diff -ruNp src.orig/sc2code/comm/urquan/igfxres.h src/sc2code/comm/urquan/igfxres.h
--- src.orig/sc2code/comm/urquan/igfxres.h	2017-11-08 16:49:26 -0600
+++ src/sc2code/comm/urquan/igfxres.h	2017-11-08 16:49:54 -0600
@@ -1,3 +1,5 @@
-#define URQUAN_PMAP_ANIM 0x00200002L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define URQUAN_PMAP_ANIM "comm.urquan.graphics"
diff -ruNp src.orig/sc2code/comm/urquan/imusicre.h src/sc2code/comm/urquan/imusicre.h
--- src.orig/sc2code/comm/urquan/imusicre.h	2017-11-08 16:49:26 -0600
+++ src/sc2code/comm/urquan/imusicre.h	2017-11-08 16:49:54 -0600
@@ -1,3 +1,5 @@
-#define URQUAN_MUSIC 0x00200006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define URQUAN_MUSIC "comm.urquan.music"
diff -ruNp src.orig/sc2code/comm/urquan/istrtab.h src/sc2code/comm/urquan/istrtab.h
--- src.orig/sc2code/comm/urquan/istrtab.h	2017-11-08 16:49:26 -0600
+++ src/sc2code/comm/urquan/istrtab.h	2017-11-08 16:49:54 -0600
@@ -1,3 +1,6 @@
-#define URQUAN_CONVERSATION_PHRASES 0x00200004L
-#define URQUAN_COLOR_MAP 0x00200104L
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define URQUAN_COLOR_MAP "comm.urquan.colortable"
+#define URQUAN_CONVERSATION_PHRASES "comm.urquan.dialogue"
diff -ruNp src.orig/sc2code/comm/urquan/urquanc.c src/sc2code/comm/urquan/urquanc.c
--- src.orig/sc2code/comm/urquan/urquanc.c	2017-11-08 16:49:27 -0600
+++ src/sc2code/comm/urquan/urquanc.c	2017-11-08 16:49:54 -0600
@@ -22,20 +22,20 @@
 
 static LOCDATA urquan_desc =
 {
-	NULL_PTR, /* init_encounter_func */
-	NULL_PTR, /* post_encounter_func */
-	NULL_PTR, /* uninit_encounter_func */
-	(FRAME)URQUAN_PMAP_ANIM, /* AlienFrame */
-	(FONT)URQUAN_FONT, /* AlienFont */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	URQUAN_PMAP_ANIM, /* AlienFrame */
+	URQUAN_FONT, /* AlienFont */
 	WHITE_COLOR, /* AlienTextFColor */
 	BLACK_COLOR, /* AlienTextBColor */
 	{0, 0}, /* AlienTextBaseline */
 	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
 	ALIGN_CENTER, /* AlienTextAlign */
 	VALIGN_TOP, /* AlienTextValign */
-	(COLORMAP)URQUAN_COLOR_MAP, /* AlienColorMap */
+	URQUAN_COLOR_MAP, /* AlienColorMap */
 	URQUAN_MUSIC, /* AlienSong */
-	0, /* AlienAltSong */
+	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	URQUAN_CONVERSATION_PHRASES, /* PlayerPhrases */
 	7, /* NumAnimations */
@@ -113,7 +113,11 @@ static LOCDATA urquan_desc =
 		ONE_SECOND / 12, 0, /* RestartRate */
 		0, /* BlockMask */
 	},
-	NULL_PTR, /* AlienNumberSpeech - none */
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
 };
 
 static void
@@ -518,10 +522,10 @@ post_urquan_enc (void)
 	SET_GAME_STATE (PLAYER_HYPNOTIZED, 0);
 }
 
-LOCDATAPTR
+LOCDATA*
 init_urquan_comm (void)
 {
-	LOCDATAPTR retval;
+	LOCDATA *retval;
 
 	DWORD GrpOffs;
 
diff -ruNp src.orig/sc2code/comm/utwig/ifontres.h src/sc2code/comm/utwig/ifontres.h
--- src.orig/sc2code/comm/utwig/ifontres.h	2017-11-08 16:49:27 -0600
+++ src/sc2code/comm/utwig/ifontres.h	2017-11-08 16:49:54 -0600
@@ -1,3 +1,5 @@
-#define UTWIG_FONT 0x00200003L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define UTWIG_FONT "comm.utwig.font"
diff -ruNp src.orig/sc2code/comm/utwig/igfxres.h src/sc2code/comm/utwig/igfxres.h
--- src.orig/sc2code/comm/utwig/igfxres.h	2017-11-08 16:49:27 -0600
+++ src/sc2code/comm/utwig/igfxres.h	2017-11-08 16:49:54 -0600
@@ -1,3 +1,5 @@
-#define UTWIG_PMAP_ANIM 0x00200002L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define UTWIG_PMAP_ANIM "comm.utwig.graphics"
diff -ruNp src.orig/sc2code/comm/utwig/imusicre.h src/sc2code/comm/utwig/imusicre.h
--- src.orig/sc2code/comm/utwig/imusicre.h	2017-11-08 16:49:27 -0600
+++ src/sc2code/comm/utwig/imusicre.h	2017-11-08 16:49:54 -0600
@@ -1,5 +1,6 @@
-#define UTWIG_MUSIC 0x00200006L
-
-#define UTWIG_ULTRON_MUSIC 0x00400106L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define UTWIG_MUSIC "comm.utwig.music"
+#define UTWIG_ULTRON_MUSIC "comm.utwigult.music"
diff -ruNp src.orig/sc2code/comm/utwig/istrtab.h src/sc2code/comm/utwig/istrtab.h
--- src.orig/sc2code/comm/utwig/istrtab.h	2017-11-08 16:49:27 -0600
+++ src/sc2code/comm/utwig/istrtab.h	2017-11-08 16:49:54 -0600
@@ -1,3 +1,6 @@
-#define UTWIG_CONVERSATION_PHRASES 0x00200004L
-#define UTWIG_COLOR_MAP 0x00200104L
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define UTWIG_COLOR_MAP "comm.utwig.colortable"
+#define UTWIG_CONVERSATION_PHRASES "comm.utwig.dialogue"
diff -ruNp src.orig/sc2code/comm/utwig/utwigc.c src/sc2code/comm/utwig/utwigc.c
--- src.orig/sc2code/comm/utwig/utwigc.c	2017-11-08 16:49:27 -0600
+++ src/sc2code/comm/utwig/utwigc.c	2017-11-08 16:49:54 -0600
@@ -26,20 +26,20 @@
 
 static LOCDATA utwig_desc =
 {
-	NULL_PTR, /* init_encounter_func */
-	NULL_PTR, /* post_encounter_func */
-	NULL_PTR, /* uninit_encounter_func */
-	(FRAME)UTWIG_PMAP_ANIM, /* AlienFrame */
-	(FONT)UTWIG_FONT, /* AlienFont */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	UTWIG_PMAP_ANIM, /* AlienFrame */
+	UTWIG_FONT, /* AlienFont */
 	WHITE_COLOR, /* AlienTextFColor */
 	BLACK_COLOR, /* AlienTextBColor */
 	{0, 0}, /* AlienTextBaseline */
 	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
 	ALIGN_CENTER, /* AlienTextAlign */
 	VALIGN_MIDDLE, /* AlienTextValign */
-	(COLORMAP)UTWIG_COLOR_MAP, /* AlienColorMap */
+	UTWIG_COLOR_MAP, /* AlienColorMap */
 	UTWIG_MUSIC, /* AlienSong */
-	0, /* AlienAltSong */
+	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	UTWIG_CONVERSATION_PHRASES, /* PlayerPhrases */
 	16, /* NumAnimations */
@@ -190,7 +190,11 @@ static LOCDATA utwig_desc =
 		ONE_SECOND * 7 / 60, ONE_SECOND / 2, /* RestartRate */
 		0, /* BlockMask */
 	},
-	NULL_PTR, /* AlienNumberSpeech - none */
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
 };
 
 static void
@@ -284,8 +288,8 @@ ExitConversation (RESPONSE_REF R)
 				SET_GAME_STATE (SUPOX_HOSTILE, 0);
 				SET_GAME_STATE (UTWIG_HOSTILE, 0);
 
-				ActivateStarShip (UTWIG_SHIP, 0);
-				ActivateStarShip (SUPOX_SHIP, 0);
+				ActivateStarShip (UTWIG_SHIP, SET_ALLIED);
+				ActivateStarShip (SUPOX_SHIP, SET_ALLIED);
 			}
 		}
 	}
@@ -558,8 +562,7 @@ NeutralUtwig (RESPONSE_REF R)
 						we_are_vindicator1,
 						buf,
 						we_are_vindicator2,
-						NULL_PTR
-						);
+						(UNICODE*)NULL);
 			}
 			pStr[0] = we_are_vindicator0;
 			break;
@@ -955,10 +958,10 @@ post_utwig_enc (void)
 	// nothing defined so far
 }
 
-LOCDATAPTR
+LOCDATA*
 init_utwig_comm (void)
 {
-	LOCDATAPTR retval;
+	LOCDATA *retval;
 
 	utwig_desc.init_encounter_func = Intro;
 	utwig_desc.post_encounter_func = post_utwig_enc;
@@ -970,7 +973,7 @@ init_utwig_comm (void)
 
 	if (GET_GAME_STATE (UTWIG_HAVE_ULTRON))
 	{	// use alternate 'Happy Utwig!' track
-		utwig_desc.AlienAltSong = UTWIG_ULTRON_MUSIC;
+		utwig_desc.AlienAltSongRes = UTWIG_ULTRON_MUSIC;
 		utwig_desc.AlienSongFlags |= LDASF_USE_ALTERNATE;
 	}
 	else
diff -ruNp src.orig/sc2code/comm/vux/ifontres.h src/sc2code/comm/vux/ifontres.h
--- src.orig/sc2code/comm/vux/ifontres.h	2017-11-08 16:49:27 -0600
+++ src/sc2code/comm/vux/ifontres.h	2017-11-08 16:49:54 -0600
@@ -1,3 +1,5 @@
-#define VUX_FONT 0x00200003L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define VUX_FONT "comm.vux.font"
diff -ruNp src.orig/sc2code/comm/vux/igfxres.h src/sc2code/comm/vux/igfxres.h
--- src.orig/sc2code/comm/vux/igfxres.h	2017-11-08 16:49:27 -0600
+++ src/sc2code/comm/vux/igfxres.h	2017-11-08 16:49:54 -0600
@@ -1,3 +1,5 @@
-#define VUX_PMAP_ANIM 0x00200002L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define VUX_PMAP_ANIM "comm.vux.graphics"
diff -ruNp src.orig/sc2code/comm/vux/imusicre.h src/sc2code/comm/vux/imusicre.h
--- src.orig/sc2code/comm/vux/imusicre.h	2017-11-08 16:49:27 -0600
+++ src/sc2code/comm/vux/imusicre.h	2017-11-08 16:49:54 -0600
@@ -1,3 +1,5 @@
-#define VUX_MUSIC 0x00200006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define VUX_MUSIC "comm.vux.music"
diff -ruNp src.orig/sc2code/comm/vux/istrtab.h src/sc2code/comm/vux/istrtab.h
--- src.orig/sc2code/comm/vux/istrtab.h	2017-11-08 16:49:27 -0600
+++ src/sc2code/comm/vux/istrtab.h	2017-11-08 16:49:54 -0600
@@ -1,4 +1,6 @@
-#define VUX_CONVERSATION_PHRASES 0x00200004L
-#define VUX_COLOR_MAP 0x00200104L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define VUX_COLOR_MAP "comm.vux.colortable"
+#define VUX_CONVERSATION_PHRASES "comm.vux.dialogue"
diff -ruNp src.orig/sc2code/comm/vux/vuxc.c src/sc2code/comm/vux/vuxc.c
--- src.orig/sc2code/comm/vux/vuxc.c	2017-11-08 16:49:27 -0600
+++ src/sc2code/comm/vux/vuxc.c	2017-11-08 16:49:54 -0600
@@ -22,11 +22,11 @@
 
 static LOCDATA vux_desc =
 {
-	NULL_PTR, /* init_encounter_func */
-	NULL_PTR, /* post_encounter_func */
-	NULL_PTR, /* uninit_encounter_func */
-	(FRAME)VUX_PMAP_ANIM, /* AlienFrame */
-	(FONT)VUX_FONT, /* AlienFont */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	VUX_PMAP_ANIM, /* AlienFrame */
+	VUX_FONT, /* AlienFont */
 	WHITE_COLOR, /* AlienTextFColor */
 	BLACK_COLOR, /* AlienTextBColor */
 	{0, 0}, /* AlienTextBaseline */
@@ -35,7 +35,7 @@ static LOCDATA vux_desc =
 	VALIGN_TOP, /* AlienTextValign */
 	VUX_COLOR_MAP, /* AlienColorMap */
 	VUX_MUSIC, /* AlienSong */
-	0, /* AlienAltSong */
+	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	VUX_CONVERSATION_PHRASES, /* PlayerPhrases */
 	17, /* NumAnimations */
@@ -193,7 +193,11 @@ static LOCDATA vux_desc =
 		ONE_SECOND / 12, 0, /* RestartRate */
 		0, /* BlockMask */
 	},
-	NULL_PTR, /* AlienNumberSpeech - none */
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
 };
 
 static void
@@ -763,10 +767,10 @@ post_vux_enc (void)
 	// nothing defined so far
 }
 
-LOCDATAPTR
+LOCDATA*
 init_vux_comm (void)
 {
-	LOCDATAPTR retval;
+	LOCDATA *retval;
 
 	vux_desc.init_encounter_func = Intro;
 	vux_desc.post_encounter_func = post_vux_enc;
diff -ruNp src.orig/sc2code/comm/yehat/ifontres.h src/sc2code/comm/yehat/ifontres.h
--- src.orig/sc2code/comm/yehat/ifontres.h	2017-11-08 16:49:27 -0600
+++ src/sc2code/comm/yehat/ifontres.h	2017-11-08 16:49:54 -0600
@@ -1,3 +1,5 @@
-#define YEHAT_FONT 0x00200003L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define YEHAT_FONT "comm.yehat.font"
diff -ruNp src.orig/sc2code/comm/yehat/igfxres.h src/sc2code/comm/yehat/igfxres.h
--- src.orig/sc2code/comm/yehat/igfxres.h	2017-11-08 16:49:27 -0600
+++ src/sc2code/comm/yehat/igfxres.h	2017-11-08 16:49:54 -0600
@@ -1,3 +1,5 @@
-#define YEHAT_PMAP_ANIM 0x00200002L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define YEHAT_PMAP_ANIM "comm.yehat.graphics"
diff -ruNp src.orig/sc2code/comm/yehat/imusicre.h src/sc2code/comm/yehat/imusicre.h
--- src.orig/sc2code/comm/yehat/imusicre.h	2017-11-08 16:49:27 -0600
+++ src/sc2code/comm/yehat/imusicre.h	2017-11-08 16:49:54 -0600
@@ -1,5 +1,6 @@
-#define YEHAT_MUSIC 0x00200006L
-
-#define REBEL_MUSIC 0x00800106L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define REBEL_MUSIC "comm.yehat.rebel.music"
+#define YEHAT_MUSIC "comm.yehat.music"
diff -ruNp src.orig/sc2code/comm/yehat/istrtab.h src/sc2code/comm/yehat/istrtab.h
--- src.orig/sc2code/comm/yehat/istrtab.h	2017-11-08 16:49:27 -0600
+++ src/sc2code/comm/yehat/istrtab.h	2017-11-08 16:49:54 -0600
@@ -1,5 +1,7 @@
-#define YEHAT_CONVERSATION_PHRASES 0x00400004L
-#define REBEL_CONVERSATION_PHRASES 0x00600104L
-#define YEHAT_COLOR_MAP 0x00200204L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define REBEL_CONVERSATION_PHRASES "comm.yehat.rebel.dialogue"
+#define YEHAT_COLOR_MAP "comm.yehat.colortable"
+#define YEHAT_CONVERSATION_PHRASES "comm.yehat.dialogue"
diff -ruNp src.orig/sc2code/comm/yehat/yehatc.c src/sc2code/comm/yehat/yehatc.c
--- src.orig/sc2code/comm/yehat/yehatc.c	2017-11-08 16:49:27 -0600
+++ src/sc2code/comm/yehat/yehatc.c	2017-11-08 16:49:54 -0600
@@ -27,20 +27,20 @@
 
 static LOCDATA yehat_desc =
 {
-	NULL_PTR, /* init_encounter_func */
-	NULL_PTR, /* post_encounter_func */
-	NULL_PTR, /* uninit_encounter_func */
-	(FRAME)YEHAT_PMAP_ANIM, /* AlienFrame */
-	(FONT)YEHAT_FONT, /* AlienFont */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	YEHAT_PMAP_ANIM, /* AlienFrame */
+	YEHAT_FONT, /* AlienFont */
 	WHITE_COLOR, /* AlienTextFColor */
 	BLACK_COLOR, /* AlienTextBColor */
 	{0, 0}, /* AlienTextBaseline */
 	0, /* (SIS_TEXT_WIDTH - 16) * 2 / 3, */ /* AlienTextWidth */
 	ALIGN_CENTER, /* AlienTextAlign */
 	VALIGN_MIDDLE, /* AlienTextValign */
-	(COLORMAP)YEHAT_COLOR_MAP, /* AlienColorMap */
+	YEHAT_COLOR_MAP, /* AlienColorMap */
 	YEHAT_MUSIC, /* AlienSong */
-	0, /* AlienAltSong */
+	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	YEHAT_CONVERSATION_PHRASES, /* PlayerPhrases */
 	15, /* NumAnimations */
@@ -184,7 +184,11 @@ static LOCDATA yehat_desc =
 		ONE_SECOND / 12, 0, /* RestartRate */
 		0, /* BlockMask */
 	},
-	NULL_PTR, /* AlienNumberSpeech - none */
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
 };
 
 static void
@@ -381,8 +385,7 @@ YehatHome (RESPONSE_REF R)
 				i_demand_you_ally_homeworld2,
 				GLOBAL_SIS (ShipName),
 				i_demand_you_ally_homeworld3,
-				NULL_PTR
-				);
+				(UNICODE*)NULL);
 		DoResponsePhrase (i_demand_you_ally_homeworld0,
 				ExitConversation, shared_phrase_buf);
 	}
@@ -508,8 +511,7 @@ YehatSpace (RESPONSE_REF R)
 					i_demand_you_ally_space2,
 					buf,
 					i_demand_you_ally_space3,
-					NULL_PTR
-					);
+					(UNICODE*)NULL);
 			pStr[2] = i_demand_you_ally_space0;
 			break;
 		}
@@ -656,10 +658,10 @@ post_yehat_enc (void)
 	// nothing defined so far
 }
 
-LOCDATAPTR
+LOCDATA*
 init_yehat_comm (void)
 {
-	LOCDATAPTR retval;
+	LOCDATA *retval;
 
 	yehat_desc.init_encounter_func = Intro;
 	yehat_desc.post_encounter_func = post_yehat_enc;
diff -ruNp src.orig/sc2code/comm/zoqfot/ifontres.h src/sc2code/comm/zoqfot/ifontres.h
--- src.orig/sc2code/comm/zoqfot/ifontres.h	2017-11-08 16:49:27 -0600
+++ src/sc2code/comm/zoqfot/ifontres.h	2017-11-08 16:49:54 -0600
@@ -1,3 +1,5 @@
-#define ZOQFOTPIK_FONT 0x00200003L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ZOQFOTPIK_FONT "comm.zoqfotpik.font"
diff -ruNp src.orig/sc2code/comm/zoqfot/igfxres.h src/sc2code/comm/zoqfot/igfxres.h
--- src.orig/sc2code/comm/zoqfot/igfxres.h	2017-11-08 16:49:27 -0600
+++ src/sc2code/comm/zoqfot/igfxres.h	2017-11-08 16:49:54 -0600
@@ -1,3 +1,5 @@
-#define ZOQFOTPIK_PMAP_ANIM 0x00200002L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ZOQFOTPIK_PMAP_ANIM "comm.zoqfotpik.graphics"
diff -ruNp src.orig/sc2code/comm/zoqfot/imusicre.h src/sc2code/comm/zoqfot/imusicre.h
--- src.orig/sc2code/comm/zoqfot/imusicre.h	2017-11-08 16:49:27 -0600
+++ src/sc2code/comm/zoqfot/imusicre.h	2017-11-08 16:49:54 -0600
@@ -1,3 +1,5 @@
-#define ZOQFOTPIK_MUSIC 0x00200006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ZOQFOTPIK_MUSIC "comm.zoqfotpik.music"
diff -ruNp src.orig/sc2code/comm/zoqfot/istrtab.h src/sc2code/comm/zoqfot/istrtab.h
--- src.orig/sc2code/comm/zoqfot/istrtab.h	2017-11-08 16:49:27 -0600
+++ src/sc2code/comm/zoqfot/istrtab.h	2017-11-08 16:49:54 -0600
@@ -1,3 +1,6 @@
-#define ZOQFOTPIK_CONVERSATION_PHRASES 0x00200004L
-#define ZOQFOTPIK_COLOR_MAP 0x00200104L
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ZOQFOTPIK_COLOR_MAP "comm.zoqfotpik.colortable"
+#define ZOQFOTPIK_CONVERSATION_PHRASES "comm.zoqfotpik.dialogue"
diff -ruNp src.orig/sc2code/comm/zoqfot/zoqfotc.c src/sc2code/comm/zoqfot/zoqfotc.c
--- src.orig/sc2code/comm/zoqfot/zoqfotc.c	2017-11-08 16:49:27 -0600
+++ src/sc2code/comm/zoqfot/zoqfotc.c	2017-11-08 16:49:55 -0600
@@ -42,20 +42,20 @@
 
 static LOCDATA zoqfot_desc =
 {
-	NULL_PTR, /* init_encounter_func */
-	NULL_PTR, /* post_encounter_func */
-	NULL_PTR, /* uninit_encounter_func */
-	(FRAME)ZOQFOTPIK_PMAP_ANIM, /* AlienFrame */
-	(FONT)ZOQFOTPIK_FONT, /* AlienFont */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	ZOQFOTPIK_PMAP_ANIM, /* AlienFrame */
+	ZOQFOTPIK_FONT, /* AlienFont */
 	0, /* AlienTextFColor */
 	0, /* AlienTextBColor */
 	{0, 0}, /* AlienTextBaseline */
 	0, /* AlienTextWidth */
 	ALIGN_CENTER, /* AlienTextAlign */
 	VALIGN_MIDDLE, /* AlienTextValign */
-	(COLORMAP)ZOQFOTPIK_COLOR_MAP, /* AlienColorMap */
+	ZOQFOTPIK_COLOR_MAP, /* AlienColorMap */
 	ZOQFOTPIK_MUSIC, /* AlienSong */
-	0, /* AlienAltSong */
+	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	ZOQFOTPIK_CONVERSATION_PHRASES, /* PlayerPhrases */
 	3, /* NumAnimations */
@@ -102,7 +102,11 @@ static LOCDATA zoqfot_desc =
 		ONE_SECOND / 12, 0, /* RestartRate */
 		0, /* BlockMask */
 	},
-	NULL_PTR, /* AlienNumberSpeech - none */
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
 };
 
 enum
@@ -206,7 +210,7 @@ ExitConversation (RESPONSE_REF R)
 		NPCPhrase_cb (WE_ALLY4, &SelectAlienZOQ);
 		NPCPhrase_cb (WE_ALLY5, &SelectAlienPIK);
 		ZFPTalkSegue ((COUNT)~0);
-		ActivateStarShip (ZOQFOTPIK_SHIP, 0);
+		ActivateStarShip (ZOQFOTPIK_SHIP, SET_ALLIED);
 		AddEvent (RELATIVE_EVENT, 3, 0, 0, ZOQFOT_DISTRESS_EVENT);
 		SET_GAME_STATE (ZOQFOT_HOME_VISITS, 0);
 	}
@@ -413,8 +417,7 @@ AquaintZoqFot (RESPONSE_REF R)
 				we_are_vindicator1,
 				GLOBAL_SIS (ShipName),
 				we_are_vindicator2,
-				NULL_PTR
-				);
+				(UNICODE*)NULL);
 	}
 
 	if (PHRASE_ENABLED (which_fot))
@@ -718,7 +721,7 @@ ZoqFotHome (RESPONSE_REF R)
 		NPCPhrase_cb (GOOD9, &SelectAlienPIK);
 		ZFPTalkSegue ((COUNT)~0);
 
-		ActivateStarShip (ZOQFOTPIK_SHIP, 0);
+		ActivateStarShip (ZOQFOTPIK_SHIP, SET_ALLIED);
 		AddEvent (RELATIVE_EVENT, 3, 0, 0, ZOQFOT_DISTRESS_EVENT);
 	}
 	else if (PLAYER_SAID (R, enough_info))
@@ -932,10 +935,10 @@ post_zoqfot_enc (void)
 	// nothing defined so far
 }
 
-LOCDATAPTR
+LOCDATA*
 init_zoqfot_comm (void)
 {
-	LOCDATAPTR retval;
+	LOCDATA *retval;
 
 	zoqfot_desc.init_encounter_func = Intro;
 	zoqfot_desc.post_encounter_func = post_zoqfot_enc;
diff -ruNp src.orig/sc2code/comm.c src/sc2code/comm.c
--- src.orig/sc2code/comm.c	2017-11-08 16:49:27 -0600
+++ src/sc2code/comm.c	2017-11-08 16:49:55 -0600
@@ -59,7 +59,6 @@ typedef struct response_entry
 	TEXT response_text;
 	RESPONSE_FUNC response_func;
 } RESPONSE_ENTRY;
-typedef RESPONSE_ENTRY *PRESPONSE_ENTRY;
 
 typedef struct encounter_state
 {
@@ -75,9 +74,8 @@ typedef struct encounter_state
 	COUNT phrase_buf_index;
 	UNICODE phrase_buf[512];
 } ENCOUNTER_STATE;
-typedef ENCOUNTER_STATE *PENCOUNTER_STATE;
 
-static PENCOUNTER_STATE pCurInputState;
+static ENCOUNTER_STATE *pCurInputState;
 static SUBTITLE_STATE subtitle_state = DONE_SUBTITLE;
 static Mutex subtitle_mutex;
 
@@ -97,7 +95,7 @@ RECT CommWndRect = {
  * display given the line wrapping information
  */
 static int
-_count_lines (PTEXT pText)
+_count_lines (TEXT *pText)
 {
 	SIZE text_width;
 	const unsigned char *pStr;
@@ -124,11 +122,11 @@ _count_lines (PTEXT pText)
 // status == -4: use current context, and baseline from pTextIn
 // status ==  1:  draw alien speech; subtitle cache is used
 static COORD
-add_text (int status, PTEXT pTextIn)
+add_text (int status, TEXT *pTextIn)
 {
 	COUNT maxchars, numchars;
 	TEXT locText;
-	PTEXT pText;
+	TEXT *pText;
 	SIZE leading;
 	const unsigned char *pStr;
 	SIZE text_width;
@@ -252,30 +250,8 @@ add_text (int status, PTEXT pTextIn)
 		else
 		{
 			// Alien speech
-
-			// Draw the background by drawing the same text in the
-			// background color one pixel shifted to all 4 directions.
-			SetContextForeGroundColor (CommData.AlienTextBColor);
-
-			--pText->baseline.x;
-			font_DrawText (pText);
-
-			++pText->baseline.x;
-			--pText->baseline.y;
-			font_DrawText (pText);
-
-			++pText->baseline.x;
-			++pText->baseline.y;
-			font_DrawText (pText);
-
-			--pText->baseline.x;
-			++pText->baseline.y;
-			font_DrawText (pText);
-
-			SetContextForeGroundColor (CommData.AlienTextFColor);
-
-			--pText->baseline.y;
-			font_DrawText (pText);
+			font_DrawTracedText (pText,
+					CommData.AlienTextFColor, CommData.AlienTextBColor);
 		}
 	} while (!eol && maxchars);
 	pText->pStr = pStr;
@@ -357,7 +333,7 @@ getLineWithinWidth(TEXT *pText, const un
 
 		oldCount = pText->CharCount;
 		pText->CharCount = charCount;
-		TextRect (pText, &rect, NULL_PTR);
+		TextRect (pText, &rect, NULL);
 		
 		if (rect.extent.width >= maxWidth)
 		{
@@ -422,7 +398,7 @@ DrawSISComWindow (void)
 			OldStrings = SetRelStringTableIndex (OldStrings, 1);
 			font_DrawText (&t);
 			SetContextForeGroundColor (WHITE_COLOR);
-			t.pStr = (PBYTE)GetStringAddress (CreditStrings);
+			t.pStr = (BYTE*)GetStringAddress (CreditStrings);
 			t.CharCount = GetStringLength (CreditStrings);
 			CreditStrings = SetRelStringTableIndex (CreditStrings, 1);
 			font_DrawText (&t);
@@ -443,11 +419,11 @@ DrawSISComWindow (void)
 }
 
 void
-DrawAlienFrame (FRAME aframe, PSEQUENCE pSeq)
+DrawAlienFrame (FRAME aframe, SEQUENCE *pSeq)
 {
 	COUNT i;
 	STAMP s;
-	ANIMATION_DESCPTR ADPtr;
+	ANIMATION_DESC *ADPtr;
 
 	s.origin.x = -SAFE_X;
 	s.origin.y = 0;
@@ -504,7 +480,7 @@ volatile BOOLEAN ClearSummary;
 static volatile BOOLEAN ClearSubtitle;
 
 static void
-RefreshResponses (PENCOUNTER_STATE pES)
+RefreshResponses (ENCOUNTER_STATE *pES)
 {
 	COORD y;
 	BYTE response;
@@ -827,7 +803,7 @@ AlienTalkSegue (COUNT wait_track)
 	if (!pCurInputState->Initialized)
 	{
 		SetColorMap (GetColorMapAddress (CommData.AlienColorMap));
-		DrawAlienFrame (CommData.AlienFrame, NULL_PTR);
+		DrawAlienFrame (CommData.AlienFrame, NULL);
 		UpdateSpeechGraphics (TRUE);
 
 		if (LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE
@@ -869,7 +845,7 @@ AlienTalkSegue (COUNT wait_track)
 		}
 		pCurInputState->Initialized = TRUE;
 
-		PlayMusic ((MUSIC_REF)CommData.AlienSong, TRUE, 1);
+		PlayMusic (CommData.AlienSong, TRUE, 1);
 		SetMusicVolume (BACKGROUND_VOL);
 
 		{
@@ -920,10 +896,9 @@ typedef struct summary_state
 	const UNICODE *LeftOver;
 
 } SUMMARY_STATE;
-typedef SUMMARY_STATE *PSUMMARY_STATE;
 
 static BOOLEAN
-DoConvSummary (PSUMMARY_STATE pSS)
+DoConvSummary (SUMMARY_STATE *pSS)
 {
 #define DELTA_Y_SUMMARY 8
 #define MAX_SUMM_ROWS ((SIS_SCREEN_HEIGHT - SLIDER_Y - SLIDER_HEIGHT) \
@@ -1051,10 +1026,10 @@ DoConvSummary (PSUMMARY_STATE pSS)
 
 // Called when the player presses the select button on a response.
 static void
-SelectResponse (PENCOUNTER_STATE pES)
+SelectResponse (ENCOUNTER_STATE *pES)
 {
 	const unsigned char *end;
-	PTEXT response_text =
+	TEXT *response_text =
 			&pES->response_list[pES->cur_response].response_text;
 	end = skipUTF8Chars(response_text->pStr, response_text->CharCount);
 	pES->phrase_buf_index = end - response_text->pStr;
@@ -1077,7 +1052,7 @@ SelectResponse (PENCOUNTER_STATE pES)
 
 // Called when the player presses the cancel button in comm.
 static void
-SelectConversationSummary (PENCOUNTER_STATE pES)
+SelectConversationSummary (ENCOUNTER_STATE *pES)
 {
 	SUMMARY_STATE SummaryState;
 	
@@ -1099,7 +1074,7 @@ SelectConversationSummary (PENCOUNTER_ST
 }
 
 static void
-PlayerResponseInput (PENCOUNTER_STATE pES)
+PlayerResponseInput (ENCOUNTER_STATE *pES)
 {
 	BYTE response;
 
@@ -1181,7 +1156,7 @@ PlayerResponseInput (PENCOUNTER_STATE pE
 }
 
 static BOOLEAN
-DoCommunication (PENCOUNTER_STATE pES)
+DoCommunication (ENCOUNTER_STATE *pES)
 {
 	SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);
 
@@ -1241,7 +1216,7 @@ DoCommunication (PENCOUNTER_STATE pES)
 	CommData.AlienTransitionDesc.AnimFlags &= ~(TALK_INTRO | TALK_DONE);
 
 	SetContext (SpaceContext);
-	DestroyContext (ReleaseContext (TaskContext));
+	DestroyContext (TaskContext);
 	TaskContext = 0;
 
 	UnlockMutex (GraphicsLock);
@@ -1261,8 +1236,8 @@ void
 DoResponsePhrase (RESPONSE_REF R, RESPONSE_FUNC response_func,
 		UNICODE *ConstructStr)
 {
-	PENCOUNTER_STATE pES = pCurInputState;
-	PRESPONSE_ENTRY pEntry;
+	ENCOUNTER_STATE *pES = pCurInputState;
+	RESPONSE_ENTRY *pEntry;
 
 	if (GLOBAL (CurrentActivity) & CHECK_ABORT)
 		return;
@@ -1301,7 +1276,6 @@ DoResponsePhrase (RESPONSE_REF R, RESPON
 static void
 HailAlien (void)
 {
-	MEM_HANDLE hOldIndex;
 	ENCOUNTER_STATE ES;
 	FONT PlayerFont, OldFont;
 	MUSIC_REF SongRef = 0;
@@ -1311,32 +1285,29 @@ HailAlien (void)
 	memset (pCurInputState, 0, sizeof (*pCurInputState));
 
 	ES.InputFunc = DoCommunication;
-	hOldIndex = SetResourceIndex (hResIndex);
-	PlayerFont = CaptureFont ((FONT_REF)LoadFont (PLAYER_FONT));
-	SetResourceIndex (hOldIndex);
+	PlayerFont = LoadFont (PLAYER_FONT);
 
 	CommData.AlienFrame = CaptureDrawable (
-			LoadGraphic ((RESOURCE)CommData.AlienFrame));
-	CommData.AlienFont = CaptureFont ((FONT_REF)
-			LoadFont ((RESOURCE)CommData.AlienFont));
+			LoadGraphic (CommData.AlienFrameRes));
+	CommData.AlienFont = LoadFont (CommData.AlienFontRes);
 	CommData.AlienColorMap = CaptureColorMap (
-			LoadColorMap ((RESOURCE)CommData.AlienColorMap));
+			LoadColorMap (CommData.AlienColorMapRes));
 	if ((CommData.AlienSongFlags & LDASF_USE_ALTERNATE)
-			&& CommData.AlienAltSong)
-		SongRef = LoadMusic ((RESOURCE)CommData.AlienAltSong);
+			&& CommData.AlienAltSongRes)
+		SongRef = LoadMusic (CommData.AlienAltSongRes);
 	if (SongRef)
 		CommData.AlienSong = SongRef;
 	else
-		CommData.AlienSong = LoadMusic ((RESOURCE)CommData.AlienSong);
+		CommData.AlienSong = LoadMusic (CommData.AlienSongRes);
 
 	CommData.ConversationPhrases = CaptureStringTable (
-			LoadStringTable ((RESOURCE)CommData.ConversationPhrases));
+			LoadStringTable (CommData.ConversationPhrasesRes));
 
 	SubtitleText.baseline = CommData.AlienTextBaseline;
 	SubtitleText.align = CommData.AlienTextAlign;
 
 	// init subtitle cache context
-	TextCacheContext = CaptureContext (CreateContext ());
+	TextCacheContext = CreateContext ();
 	TextCacheFrame = CaptureDrawable (
 			CreateDrawable (WANT_PIXMAP, SIS_SCREEN_WIDTH,
 			SIS_SCREEN_HEIGHT - SLIDER_Y - SLIDER_HEIGHT + 2, 1));
@@ -1357,7 +1328,7 @@ HailAlien (void)
 	{
 		RECT r;
 
-		TaskContext = CaptureContext (CreateContext ());
+		TaskContext = CreateContext ();
 		SetContext (TaskContext);
 		SetContextFGFrame (Screen);
 		GetFrameRect (CommData.AlienFrame, &r);
@@ -1397,7 +1368,7 @@ HailAlien (void)
 				}
 				else
 				{
-					DrawSISMessage (NULL_PTR);
+					DrawSISMessage (NULL);
 					DrawSISTitle (GLOBAL_SIS (PlanetName));
 				}
 			}
@@ -1410,7 +1381,7 @@ HailAlien (void)
 
 	LastActivity |= CHECK_LOAD; /* prevent spurious input */
 	(*CommData.init_encounter_func) ();
-	DoInput ((PVOID)&ES, FALSE);
+	DoInput (&ES, FALSE);
 	if (!(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD)))
 		(*CommData.post_encounter_func) ();
 	(*CommData.uninit_encounter_func) ();
@@ -1418,28 +1389,27 @@ HailAlien (void)
 	LockMutex (GraphicsLock);
 
 	DestroyStringTable (ReleaseStringTable (CommData.ConversationPhrases));
-	DestroyMusic ((MUSIC_REF)CommData.AlienSong);
+	DestroyMusic (CommData.AlienSong);
 	DestroyColorMap (ReleaseColorMap (CommData.AlienColorMap));
-	DestroyFont (ReleaseFont (CommData.AlienFont));
+	DestroyFont (CommData.AlienFont);
 	DestroyDrawable (ReleaseDrawable (CommData.AlienFrame));
 
-	DestroyContext (ReleaseContext (TextCacheContext));
+	DestroyContext (TextCacheContext);
 	DestroyDrawable (ReleaseDrawable (TextCacheFrame));
 
 	SetContext (SpaceContext);
 	SetContextFont (OldFont);
-	DestroyFont (ReleaseFont (PlayerFont));
+	DestroyFont (PlayerFont);
 
 	CommData.ConversationPhrases = 0;
 	pCurInputState = 0;
 }
 
 COUNT
-InitCommunication (RESOURCE which_comm)
+InitCommunication (CONVERSATION which_comm)
 {
 	COUNT status;
-	MEM_HANDLE hOldIndex, hIndex;
-	LOCDATAPTR LocDataPtr;
+	LOCDATA *LocDataPtr;
 
 #ifdef DEBUG
 	if (disableInteractivity)
@@ -1464,7 +1434,7 @@ InitCommunication (RESOURCE which_comm)
 				ClearSISRect (DRAW_SIS_DISPLAY);
 				RepairSISBorder ();
 			}
-			DrawSISMessage (NULL_PTR);
+			DrawSISMessage (NULL);
 			if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
 				DrawHyperCoords (GLOBAL (ShipStamp.origin));
 			else if (HIWORD (GLOBAL (ShipStamp.frame)) == 0)
@@ -1474,22 +1444,24 @@ InitCommunication (RESOURCE which_comm)
 		}
 	}
 
-	if (which_comm == 0)
+	if (which_comm == URQUAN_PROBE_CONVERSATION)
 	{
 		status = URQUAN_PROBE_SHIP;
 		which_comm = URQUAN_CONVERSATION;
 	}
 	else
 	{
-		if (which_comm == (RESOURCE) YEHAT_REBEL_CONVERSATION)
+		if (which_comm == YEHAT_REBEL_CONVERSATION)
 		{
 			status = YEHAT_REBEL_SHIP;
 			which_comm = YEHAT_CONVERSATION;
 		}
 		else
 		{
-			status = GET_PACKAGE (which_comm)
-					- GET_PACKAGE (ARILOU_CONVERSATION) + ARILOU_SHIP;
+			COUNT commToShip[] = {
+				RACE_SHIP_FOR_COMM
+			};
+			status = commToShip[which_comm];
 			if (status >= YEHAT_REBEL_SHIP) {
 				/* conversation exception, set to self */
 				status = HUMAN_SHIP;
@@ -1507,23 +1479,11 @@ InitCommunication (RESOURCE which_comm)
 			BuildBattle (1);
 	}
 
-	hOldIndex = SetResourceIndex (hResIndex);
-	hIndex = OpenResourceIndexInstance (which_comm);
-	if (hIndex == 0)
-	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
-		LocDataPtr = 0;
-	}
-	else
-	{
-		SetResourceIndex (hIndex);
-
-		LocDataPtr = (LOCDATAPTR)init_race (
-				status != YEHAT_REBEL_SHIP ? which_comm :
-				(RESOURCE)YEHAT_REBEL_CONVERSATION);
-		if (LocDataPtr)
-			CommData = *LocDataPtr;
-	}
+	LocDataPtr = init_race (
+			status != YEHAT_REBEL_SHIP ? which_comm :
+			YEHAT_REBEL_CONVERSATION);
+	if (LocDataPtr)
+		CommData = *LocDataPtr;
 
 	UnlockMutex (GraphicsLock);
 
@@ -1560,9 +1520,6 @@ InitCommunication (RESOURCE which_comm)
 		(*CommData.uninit_encounter_func) (); // cleanup
 	}
 
-	SetResourceIndex (hOldIndex);
-	CloseResourceIndex (hIndex);
-
 	UnlockMutex (GraphicsLock);
 
 	status = 0;
@@ -1596,9 +1553,10 @@ void
 RaceCommunication (void)
 {
 	COUNT i, status;
-	HSTARSHIP hStarShip;
-	SHIP_FRAGMENTPTR FragPtr;
-	RESOURCE RaceComm[] =
+	HSHIPFRAG hStarShip;
+	SHIP_FRAGMENT *FragPtr;
+	HENCOUNTER hEncounter = 0;
+	CONVERSATION RaceComm[] =
 	{
 		RACE_COMMUNICATION
 	};
@@ -1653,9 +1611,9 @@ RaceCommunication (void)
 		}
 		else
 		{
+			/* Encounter with a black globe in HS, prepare enemy ship list */
 			COUNT NumShips;
-			HENCOUNTER hEncounter;
-			ENCOUNTERPTR EncounterPtr;
+			ENCOUNTER *EncounterPtr;
 
 			hEncounter = GetHeadEncounter ();
 			LockEncounter (hEncounter, &EncounterPtr);
@@ -1663,20 +1621,26 @@ RaceCommunication (void)
 			NumShips = LONIBBLE (EncounterPtr->SD.Index);
 			for (i = 0; i < NumShips; ++i)
 			{
+				// XXX: Bug 996 lives here: crew is set to default (0)
+				//   None of ship info is actually used!
 				CloneShipFragment (EncounterPtr->SD.Type,
-						&GLOBAL (npc_built_ship_q), 0);
+						&GLOBAL (npc_built_ship_q),
+						EncounterPtr->ShipList[i].crew_level);
 			}
 
-			CurStarDescPtr = (STAR_DESCPTR)&EncounterPtr->SD;
+			// XXX: Bug: CurStarDescPtr was abused to point within
+			//    an ENCOUNTER struct, which is immediately unlocked
+			//CurStarDescPtr = (STAR_DESC*)&EncounterPtr->SD;
 			UnlockEncounter (hEncounter);
 		}
 	}
 
+	// First ship in the npc queue defines which alien race
+	// the player will be talking to
 	hStarShip = GetHeadLink (&GLOBAL (npc_built_ship_q));
-	FragPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-			&GLOBAL (npc_built_ship_q), hStarShip);
-	i = GET_RACE_ID (FragPtr);
-	UnlockStarShip (&GLOBAL (npc_built_ship_q), hStarShip);
+	FragPtr = LockShipFrag (&GLOBAL (npc_built_ship_q), hStarShip);
+	i = FragPtr->race_id;
+	UnlockShipFrag (&GLOBAL (npc_built_ship_q), hStarShip);
 
 	status = InitCommunication (RaceComm[i]);
 
@@ -1692,38 +1656,39 @@ RaceCommunication (void)
 		if (i == SLYLANDRO_SHIP && status == 0)
 			ReinitQueue (&GLOBAL (npc_built_ship_q));
 	}
-	else
+	else if (hEncounter)
 	{
-		PEXTENDED_STAR_DESC pESD;
-
-		pESD = (PEXTENDED_STAR_DESC)CurStarDescPtr;
-		if (pESD)
-		{
-			BYTE i, NumShips;
-
-			NumShips = (BYTE)CountLinks (&GLOBAL (npc_built_ship_q));
-			pESD->Index = MAKE_BYTE (NumShips, HINIBBLE (pESD->Index));
-			pESD->Index |= ENCOUNTER_REFORMING;
-			if (status == 0)
-				pESD->Index |= ONE_SHOT_ENCOUNTER;
-
-			for (i = 0; i < NumShips; ++i)
-			{
-				HSTARSHIP hStarShip;
-				SHIP_FRAGMENTPTR TemplatePtr;
-
-				hStarShip = GetStarShipFromIndex (
-						&GLOBAL (npc_built_ship_q), i);
-				TemplatePtr = (SHIP_FRAGMENTPTR)LockStarShip (
-						&GLOBAL (npc_built_ship_q), hStarShip);
-				pESD->ShipList[i] = TemplatePtr->ShipInfo;
-				pESD->ShipList[i].var1 = GET_RACE_ID (TemplatePtr);
-				UnlockStarShip (&GLOBAL (npc_built_ship_q), hStarShip);
-			}
-
-			ReinitQueue (&GLOBAL (npc_built_ship_q));
-			CurStarDescPtr = 0;
+		/* Update HSpace encounter info, ships lefts, etc. */
+		BYTE i, NumShips;
+		ENCOUNTER *EncounterPtr;
+
+		LockEncounter (hEncounter, &EncounterPtr);
+
+		NumShips = (BYTE)CountLinks (&GLOBAL (npc_built_ship_q));
+		EncounterPtr->SD.Index = MAKE_BYTE (NumShips,
+				HINIBBLE (EncounterPtr->SD.Index));
+		EncounterPtr->SD.Index |= ENCOUNTER_REFORMING;
+		if (status == 0)
+			EncounterPtr->SD.Index |= ONE_SHOT_ENCOUNTER;
+
+		for (i = 0; i < NumShips; ++i)
+		{
+			HSHIPFRAG hStarShip;
+			SHIP_FRAGMENT *FragPtr;
+			BRIEF_SHIP_INFO *BSIPtr;
+
+			hStarShip = GetStarShipFromIndex (&GLOBAL (npc_built_ship_q), i);
+			FragPtr = LockShipFrag (&GLOBAL (npc_built_ship_q), hStarShip);
+			BSIPtr = &EncounterPtr->ShipList[i];
+			BSIPtr->race_id = FragPtr->race_id;
+			BSIPtr->crew_level = FragPtr->crew_level;
+			BSIPtr->max_crew = FragPtr->max_crew;
+			BSIPtr->max_energy = FragPtr->max_energy;
+			UnlockShipFrag (&GLOBAL (npc_built_ship_q), hStarShip);
 		}
+		
+		UnlockEncounter (hEncounter);
+		ReinitQueue (&GLOBAL (npc_built_ship_q));
 	}
 }
 
diff -ruNp src.orig/sc2code/comm.h src/sc2code/comm.h
--- src.orig/sc2code/comm.h	2017-11-08 16:49:27 -0600
+++ src/sc2code/comm.h	2017-11-08 16:49:55 -0600
@@ -38,7 +38,7 @@ typedef enum
 
 #include "commanim.h"
 
-void DrawAlienFrame (FRAME aframe, PSEQUENCE pSeq);
+void DrawAlienFrame (FRAME aframe, SEQUENCE *pSeq);
 BOOLEAN SetClearSubtitle (BOOLEAN flag, SUBTITLE_STATE *sub_state);
 
 extern LOCDATA CommData;
diff -ruNp src.orig/sc2code/commanim.c src/sc2code/commanim.c
--- src.orig/sc2code/commanim.c	2017-11-08 16:49:27 -0600
+++ src/sc2code/commanim.c	2017-11-08 16:49:55 -0600
@@ -46,10 +46,10 @@ volatile BOOLEAN PauseAnimTask = FALSE;
 
 
 static void
-SetUpSequence (PSEQUENCE pSeq)
+SetUpSequence (SEQUENCE *pSeq)
 {
 	COUNT i;
-	ANIMATION_DESCPTR ADPtr;
+	ANIMATION_DESC *ADPtr;
 
 	i = CommData.NumAnimations;
 	pSeq = &pSeq[i];
@@ -106,15 +106,17 @@ ambient_anim_task (void *data)
 	FRAME TalkFrame;
 	FRAME ResetTalkFrame = NULL;
 	FRAME TransitionFrame = NULL;
-	FRAME AnimFrame[MAX_ANIMATIONS + 1];
+	FRAME AnimFrame[MAX_ANIMATIONS];
 	COUNT i;
 	DWORD LastTime;
 	FRAME CommFrame;
 	SEQUENCE Sequencer[MAX_ANIMATIONS];
 	ANIMATION_DESC TalkBuffer = CommData.AlienTalkDesc;
-	PSEQUENCE pSeq;
-	ANIMATION_DESCPTR ADPtr;
+	SEQUENCE *pSeq;
+	ANIMATION_DESC *ADPtr;
 	DWORD ActiveMask;
+			// Bit mask of all animations that are currently active.
+			// Bit 'i' is set if the animation with index 'i' is active.
 	DWORD LastOscillTime;
 	Task task = (Task) data;
 	BOOLEAN TransitionDone = FALSE;
@@ -127,7 +129,7 @@ ambient_anim_task (void *data)
 		TaskSwitch ();
 
 	LockMutex (GraphicsLock);
-	memset ((PSTR)&DisplayArray[0], 0, sizeof (DisplayArray));
+	memset (&DisplayArray[0], 0, sizeof (DisplayArray));
 	SetUpSequence (Sequencer);
 	UnlockMutex (GraphicsLock);
 
@@ -138,14 +140,17 @@ ambient_anim_task (void *data)
 	LastOscillTime = LastTime;
 	memset (FrameChanged, 0, sizeof (FrameChanged));
 	memset (AnimFrame, 0, sizeof (AnimFrame));
-	for (i = 0; i <= CommData.NumAnimations; i++)
+	for (i = 0; i < CommData.NumAnimations; i++)
+	{
+		COUNT nextIndex;
+
 		if (CommData.AlienAmbientArray[i].AnimFlags & YOYO_ANIM)
-			AnimFrame[i] =  SetAbsFrameIndex (CommFrame,
-					CommData.AlienAmbientArray[i].StartIndex);
+			nextIndex = CommData.AlienAmbientArray[i].StartIndex;
 		else
-			AnimFrame[i] =  SetAbsFrameIndex (CommFrame,
-					(COUNT)(CommData.AlienAmbientArray[i].StartIndex
-					+ CommData.AlienAmbientArray[i].NumFrames - 1));
+			nextIndex = (CommData.AlienAmbientArray[i].StartIndex
+					+ CommData.AlienAmbientArray[i].NumFrames - 1);
+		AnimFrame[i] = SetAbsFrameIndex (CommFrame, nextIndex);
+	}
 
 	while (!Task_ReadState (task, TASK_EXIT))
 	{
@@ -182,7 +187,11 @@ ambient_anim_task (void *data)
 			{
 				if (!(ADPtr->AnimFlags
 						& CommData.AlienTalkDesc.AnimFlags & WAIT_TALKING))
+				{
+					// This animation does not conflict with the talking
+					// animation right now.
 					pSeq->Direction = UP_DIR;
+				}
 			}
 			else if ((DWORD)pSeq->Alarm > ElapsedTicks)
 				pSeq->Alarm -= (COUNT)ElapsedTicks;
@@ -281,6 +290,8 @@ ambient_anim_task (void *data)
 					& CommData.AlienTalkDesc.AnimFlags & WAIT_TALKING)
 					&& pSeq->Direction != NO_DIR)
 			{
+				// This is a picture animation which would conflict with
+				// the talking animation, and it is not stopped yet.
 				COUNT index;
 
 				CanTalk = FALSE;
diff -ruNp src.orig/sc2code/commanim.h src/sc2code/commanim.h
--- src.orig/sc2code/commanim.h	2017-11-08 16:49:27 -0600
+++ src/sc2code/commanim.h	2017-11-08 16:49:55 -0600
@@ -25,16 +25,21 @@
 typedef enum
 {
 	UP_DIR,
+			// Animation indices are increasing
 	DOWN_DIR,
+			// Animation indices are decreasing
 	NO_DIR
 } ANIM_DIR;
 
 typedef enum
 {
 	PICTURE_ANIM,
+			// Parts of a picture are replaced
 	COLOR_ANIM
+			// Colormap tricks on a picture
 } ANIM_TYPE;
 
+// Describes an active animation.
 struct SEQUENCE
 {
 	COUNT Alarm;
@@ -50,7 +55,6 @@ struct SEQUENCE
 #endif
 
 typedef struct SEQUENCE SEQUENCE;
-typedef SEQUENCE *PSEQUENCE;
 
 void UpdateSpeechGraphics (BOOLEAN Initialize);
 Task StartCommAnimTask(void);
diff -ruNp src.orig/sc2code/commglue.c src/sc2code/commglue.c
--- src.orig/sc2code/commglue.c	2017-11-08 16:49:27 -0600
+++ src/sc2code/commglue.c	2017-11-08 16:49:55 -0600
@@ -47,21 +47,17 @@ NPCPhrase_cb (int index,  TFB_TrackCB cb
 			pTimeStamp = 0;
 			break;
 		case GLOBAL_PLAYER_LOCATION:
+		/* This is currently only used by the Slylandro Probes.
+		 * It runs a callback to generate/speak the coordinates
+		 * of the probe relative to their point of origin.
+		 */
 		{
-			SIZE dx, dy;
-			COUNT adx, ady;
-
-			dx = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x)) - 333;
-			adx = dx >= 0 ? dx : -dx;
-			dy = 9812 - LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
-			ady = dy >= 0 ? dy : -dy;
-			sprintf (numbuf,
-					"%+04d.%01u,%+04d.%01u",
-					(SIZE)(dy / 10), (COUNT)(ady % 10),
-					(SIZE)(dx / 10), (COUNT)(adx % 10));
-			pStr = numbuf;
+			if (cb)
+				(*cb) ();
+			pStr = NULL;
 			pClip = 0;
 			pTimeStamp = 0;
+			cb = NULL;
 			break;
 		}
 		case 0:
@@ -129,6 +125,34 @@ NPCNumberPhrase (int number, UNICODE **p
 	if (!speech)
 		return 0;
 
+	/* if the function is fed a negative number, go directly
+	 * to that (inverse) offset and add the subtitle + speech to
+	 * the chain.  This allows the function to be able to handle
+	 * decimal points, cooridnate systems, etc.  albeit in a
+	 * "piecemeal" fashion
+	 */
+	if (number < 0)
+	{
+		number = (-number) - 1;
+
+		if (!ptrack)
+		{
+			toplevel = 1;
+			ptrack = TrackNames;
+			strncpy (numbuf, (UNICODE *)GetStringAddress (
+					SetAbsStringTableIndex (
+							CommData.ConversationPhrases, number)),
+					sizeof (numbuf) - 1);
+			numbuf[sizeof (numbuf) - 1] = (UNICODE)'\0';
+		}
+
+		*ptrack++ = GetStringSoundClip (SetAbsStringTableIndex (
+				CommData.ConversationPhrases, number));
+		queued++;
+	}
+	/* "normal" (i.e., positive integer) number handling proceeds here */
+	else
+	{
 	if (!ptrack)
 	{
 		toplevel = 1;
@@ -200,6 +224,7 @@ NPCNumberPhrase (int number, UNICODE **p
 
 		number %= dig->Divider;
 	}
+	}
 
 	if (toplevel)
 	{
@@ -207,9 +232,7 @@ NPCNumberPhrase (int number, UNICODE **p
 		{	// nothing queued, say "zero"
 			*ptrack++ = GetStringSoundClip (SetAbsStringTableIndex (
 					CommData.ConversationPhrases,
-					speech->Digits[speech->NumDigits - 1].StrDigits[0]
-					));
-			
+					speech->Digits[speech->NumDigits - 1].StrDigits[0] - 1));
 		}
 		*ptrack++ = NULL; // term
 		
@@ -292,68 +315,68 @@ construct_response (UNICODE *buf, int R
 	}
 }
 
-LOCDATAPTR
-init_race (RESOURCE comm_id)
+LOCDATA*
+init_race (CONVERSATION comm_id)
 {
 	switch (comm_id)
 	{
 		case ARILOU_CONVERSATION:
-			return ((LOCDATAPTR)init_arilou_comm ());
+			return init_arilou_comm ();
 		case BLACKURQ_CONVERSATION:
-			return ((LOCDATAPTR)init_blackurq_comm ());
+			return init_blackurq_comm ();
 		case CHMMR_CONVERSATION:
-			return ((LOCDATAPTR)init_chmmr_comm ());
+			return init_chmmr_comm ();
 		case COMMANDER_CONVERSATION:
 			if (!GET_GAME_STATE (STARBASE_AVAILABLE))
-				return ((LOCDATAPTR)init_commander_comm ());
+				return init_commander_comm ();
 			else
-				return ((LOCDATAPTR)init_starbase_comm ());
+				return init_starbase_comm ();
 		case DRUUGE_CONVERSATION:
-			return ((LOCDATAPTR)init_druuge_comm ());
+			return init_druuge_comm ();
 		case ILWRATH_CONVERSATION:
-			return ((LOCDATAPTR)init_ilwrath_comm ());
+			return init_ilwrath_comm ();
 		case MELNORME_CONVERSATION:
-			return ((LOCDATAPTR)init_melnorme_comm ());
+			return init_melnorme_comm ();
 		case MYCON_CONVERSATION:
-			return ((LOCDATAPTR)init_mycon_comm ());
+			return init_mycon_comm ();
 		case ORZ_CONVERSATION:
-			return ((LOCDATAPTR)init_orz_comm ());
+			return init_orz_comm ();
 		case PKUNK_CONVERSATION:
-			return ((LOCDATAPTR)init_pkunk_comm ());
+			return init_pkunk_comm ();
 		case SHOFIXTI_CONVERSATION:
-			return ((LOCDATAPTR)init_shofixti_comm ());
+			return init_shofixti_comm ();
 		case SLYLANDRO_CONVERSATION:
-			return ((LOCDATAPTR)init_slyland_comm ());
+			return init_slyland_comm ();
 		case SLYLANDRO_HOME_CONVERSATION:
-			return ((LOCDATAPTR)init_slylandro_comm ());
+			return init_slylandro_comm ();
 		case SPATHI_CONVERSATION:
 			if (!(GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 7)))
-				return ((LOCDATAPTR)init_spathi_comm ());
+				return init_spathi_comm ();
 			else
-				return ((LOCDATAPTR)init_spahome_comm ());
+				return init_spahome_comm ();
 		case SUPOX_CONVERSATION:
-			return ((LOCDATAPTR)init_supox_comm ());
+			return init_supox_comm ();
 		case SYREEN_CONVERSATION:
-			return ((LOCDATAPTR)init_syreen_comm ());
+			return init_syreen_comm ();
 		case TALKING_PET_CONVERSATION:
-			return ((LOCDATAPTR)init_talkpet_comm ());
+			return init_talkpet_comm ();
 		case THRADD_CONVERSATION:
-			return ((LOCDATAPTR)init_thradd_comm ());
+			return init_thradd_comm ();
 		case UMGAH_CONVERSATION:
-			return ((LOCDATAPTR)init_umgah_comm ());
+			return init_umgah_comm ();
 		case URQUAN_CONVERSATION:
-			return ((LOCDATAPTR)init_urquan_comm ());
+			return init_urquan_comm ();
 		case UTWIG_CONVERSATION:
-			return ((LOCDATAPTR)init_utwig_comm ());
+			return init_utwig_comm ();
 		case VUX_CONVERSATION:
-			return ((LOCDATAPTR)init_vux_comm ());
+			return init_vux_comm ();
 		case YEHAT_REBEL_CONVERSATION:
-			return ((LOCDATAPTR)init_rebel_yehat_comm ());
+			return init_rebel_yehat_comm ();
 		case YEHAT_CONVERSATION:
-			return ((LOCDATAPTR)init_yehat_comm ());
+			return init_yehat_comm ();
 		case ZOQFOTPIK_CONVERSATION:
-			return ((LOCDATAPTR)init_zoqfot_comm ());
+			return init_zoqfot_comm ();
 		default:
-			return ((LOCDATAPTR)init_chmmr_comm ());
+			return init_chmmr_comm ();
 	}
 }
diff -ruNp src.orig/sc2code/commglue.h src/sc2code/commglue.h
--- src.orig/sc2code/commglue.h	2017-11-08 16:49:27 -0600
+++ src/sc2code/commglue.h	2017-11-08 16:49:55 -0600
@@ -23,6 +23,35 @@
 #include "resinst.h"
 #include "libs/sound/trackplayer.h"
 
+typedef enum {
+	ARILOU_CONVERSATION,
+	CHMMR_CONVERSATION,
+	COMMANDER_CONVERSATION,
+	ORZ_CONVERSATION,
+	PKUNK_CONVERSATION,
+	SHOFIXTI_CONVERSATION,
+	SPATHI_CONVERSATION,
+	SUPOX_CONVERSATION,
+	THRADD_CONVERSATION,
+	UTWIG_CONVERSATION,
+	VUX_CONVERSATION,
+	YEHAT_CONVERSATION,
+	MELNORME_CONVERSATION,
+	DRUUGE_CONVERSATION,
+	ILWRATH_CONVERSATION,
+	MYCON_CONVERSATION,
+	SLYLANDRO_CONVERSATION,
+	UMGAH_CONVERSATION,
+	URQUAN_CONVERSATION,
+	ZOQFOTPIK_CONVERSATION,
+	SYREEN_CONVERSATION,
+	BLACKURQ_CONVERSATION,
+	TALKING_PET_CONVERSATION,
+	SLYLANDRO_HOME_CONVERSATION,
+	URQUAN_PROBE_CONVERSATION,
+	YEHAT_REBEL_CONVERSATION,
+	INVALID_CONVERSATION,
+} CONVERSATION;
 
 extern LOCDATA CommData;
 extern int cur_comm;
@@ -69,63 +98,63 @@ extern void GetAllianceName (UNICODE *bu
 extern void construct_response (UNICODE *buf, int R /* promoted from
 		RESPONSE_REF */, ...);
 
-extern LOCDATAPTR init_race (RESOURCE comm_id);
+extern LOCDATA* init_race (CONVERSATION comm_id);
 
-extern LOCDATAPTR init_arilou_comm (void);
+extern LOCDATA* init_arilou_comm (void);
 
-extern LOCDATAPTR init_blackurq_comm (void);
+extern LOCDATA* init_blackurq_comm (void);
 
-extern LOCDATAPTR init_chmmr_comm (void);
+extern LOCDATA* init_chmmr_comm (void);
 
-extern LOCDATAPTR init_commander_comm (void);
+extern LOCDATA* init_commander_comm (void);
 
-extern LOCDATAPTR init_druuge_comm (void);
+extern LOCDATA* init_druuge_comm (void);
 
-extern LOCDATAPTR init_ilwrath_comm (void);
+extern LOCDATA* init_ilwrath_comm (void);
 
-extern LOCDATAPTR init_melnorme_comm (void);
+extern LOCDATA* init_melnorme_comm (void);
 
-extern LOCDATAPTR init_mycon_comm (void);
+extern LOCDATA* init_mycon_comm (void);
 
-extern LOCDATAPTR init_orz_comm (void);
+extern LOCDATA* init_orz_comm (void);
 
-extern LOCDATAPTR init_pkunk_comm (void);
+extern LOCDATA* init_pkunk_comm (void);
 
-extern LOCDATAPTR init_rebel_yehat_comm (void);
+extern LOCDATA* init_rebel_yehat_comm (void);
 
-extern LOCDATAPTR init_shofixti_comm (void);
+extern LOCDATA* init_shofixti_comm (void);
 
-extern LOCDATAPTR init_slyland_comm (void);
+extern LOCDATA* init_slyland_comm (void);
 
-extern LOCDATAPTR init_slylandro_comm (void);
+extern LOCDATA* init_slylandro_comm (void);
 
-extern LOCDATAPTR init_spahome_comm (void);
+extern LOCDATA* init_spahome_comm (void);
 
-extern LOCDATAPTR init_spathi_comm (void);
+extern LOCDATA* init_spathi_comm (void);
 
-extern LOCDATAPTR init_starbase_comm (void);
+extern LOCDATA* init_starbase_comm (void);
 
-extern LOCDATAPTR init_supox_comm (void);
+extern LOCDATA* init_supox_comm (void);
 
-extern LOCDATAPTR init_syreen_comm (void);
+extern LOCDATA* init_syreen_comm (void);
 
-extern LOCDATAPTR init_talkpet_comm (void);
+extern LOCDATA* init_talkpet_comm (void);
 
-extern LOCDATAPTR init_thradd_comm (void);
+extern LOCDATA* init_thradd_comm (void);
 
-extern LOCDATAPTR init_umgah_comm (void);
+extern LOCDATA* init_umgah_comm (void);
 
-extern LOCDATAPTR init_urquan_comm (void);
+extern LOCDATA* init_urquan_comm (void);
 
-extern LOCDATAPTR init_utwig_comm (void);
+extern LOCDATA* init_utwig_comm (void);
 
-extern LOCDATAPTR init_vux_comm (void);
+extern LOCDATA* init_vux_comm (void);
 
-extern LOCDATAPTR init_yehat_comm (void);
+extern LOCDATA* init_yehat_comm (void);
 
-extern LOCDATAPTR init_zoqfot_comm (void);
+extern LOCDATA* init_zoqfot_comm (void);
 
-extern LOCDATAPTR init_umgah_comm (void);
+extern LOCDATA* init_umgah_comm (void);
 
 #endif /* _COMMGLUE_H */
 
diff -ruNp src.orig/sc2code/confirm.c src/sc2code/confirm.c
--- src.orig/sc2code/confirm.c	2017-11-08 16:49:27 -0600
+++ src/sc2code/confirm.c	2017-11-08 16:49:55 -0600
@@ -110,7 +110,7 @@ DoConfirmExit (void)
 		in_confirm = TRUE;
 		oldContext = SetContext (ScreenContext);
 		GetContextClipRect (&oldRect);
-		SetContextClipRect (NULL_PTR);
+		SetContextClipRect (NULL);
 
 		r.extent.width = CONFIRM_WIN_WIDTH + 4;
 		r.extent.height = CONFIRM_WIN_HEIGHT + 4;
@@ -245,7 +245,7 @@ DoPopupWindow(const char *msg)
 
 	oldContext = SetContext (ScreenContext);
 	GetContextClipRect (&oldRect);
-	SetContextClipRect (NULL_PTR);
+	SetContextClipRect (NULL);
 
 	/* TODO: Better measure of dimensions than this */
 	r.extent.width = SCREEN_WIDTH;
diff -ruNp src.orig/sc2code/cons_res.c src/sc2code/cons_res.c
--- src.orig/sc2code/cons_res.c	1969-12-31 18:00:00 -0600
+++ src/sc2code/cons_res.c	2017-11-08 16:49:55 -0600
@@ -0,0 +1,109 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <stdio.h>
+
+#include "cons_res.h"
+#include "element.h"
+#include "resinst.h"
+#include "nameref.h"
+#include "setup.h"
+
+static const char *planet_types[] = {
+	"oolite", "yttric", "quasidegenerate", "lanthanide", "treasure",
+	"urea", "metal", "radioactive", "opalescent", "cyanic",
+	"acid", "alkali", "halide", "green", "copper",
+	"carbide", "ultramarine", "noble", "azure", "chondrite",
+	"purple", "superdense", "pellucid", "dust", "crimson",
+	"cimmerian", "infrared", "selenic", "auric", "fluorescent",
+	"ultraviolet", "plutonic", "rainbow", "shattered", "sapphire",
+	"organic", "xenolithic", "redux", "primordial", "emerald",
+	"chlorine", "magnetic", "water", "telluric", "hydrocarbon",
+	"iodine", "vinylogous", "ruby", "magma", "maroon",
+	"bluegas", "cyangas", "greengas", "greygas", "orangegas",
+	"purplegas", "redgas", "violetgas", "yellowgas"
+};
+
+static const char *planet_sizes[] = {
+	"large", "medium", "small"
+}; 
+
+FRAME planet[NUM_VIEWS];
+static char buffer[80];
+
+void
+load_gravity_well (BYTE selector)
+{
+	COUNT i;
+
+	if (selector == NUMBER_OF_PLANET_TYPES)
+	{
+		planet[0] = CaptureDrawable (
+				LoadGraphic (SAMATRA_BIG_MASK_PMAP_ANIM)
+				);
+		planet[1] = planet[2] = 0;
+	}
+	else
+	{
+		const char *ptype;
+		if (selector & PLANET_SHIELDED)
+		{
+			ptype = "slaveshield";
+		}
+		else
+		{
+			ptype = planet_types[selector];
+		}
+
+		for (i = 0; i < NUM_VIEWS; ++i)
+		{
+			snprintf (buffer, 79, "planet.%s.%s", ptype, planet_sizes[i]);
+			buffer[79] = '\0';
+			planet[i] = CaptureDrawable (LoadGraphic (buffer));
+		}
+	}
+
+}
+
+void
+free_gravity_well (void)
+{
+	COUNT i;
+
+	for (i = 0; i < NUM_VIEWS; ++i)
+	{
+		DestroyDrawable (ReleaseDrawable (planet[i]));
+		planet[i] = 0;
+	}
+}
+
+FRAME
+load_life_form (BYTE selector)
+{
+	snprintf (buffer, 79, "graphics.life.%d", selector);
+	buffer[79] = '\0'; /* Shouldn't be necessary, but better safe than sorry */
+	return CaptureDrawable (LoadGraphic (buffer));
+}
+
+MUSIC_REF
+load_orbit_theme (BYTE selector)
+{
+	snprintf (buffer, 79, "music.orbit%d", selector + 1);
+	buffer[79] = '\0'; /* Shouldn't be necessary, but better safe than sorry */	
+	return LoadMusic (buffer);
+}
diff -ruNp src.orig/sc2code/cons_res.h src/sc2code/cons_res.h
--- src.orig/sc2code/cons_res.h	1969-12-31 18:00:00 -0600
+++ src/sc2code/cons_res.h	2017-11-08 16:49:55 -0600
@@ -0,0 +1,30 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef CONS_RES_H_
+#define CONS_RES_H_
+
+#include "gfxlib.h"
+#include "sndlib.h"
+
+void load_gravity_well (BYTE selector);
+void free_gravity_well (void);
+
+FRAME load_life_form (BYTE selector);
+
+MUSIC_REF load_orbit_theme (BYTE selector);
+
+#endif /* CONS_RES_H_ */
diff -ruNp src.orig/sc2code/controls.h src/sc2code/controls.h
--- src.orig/sc2code/controls.h	2017-11-08 16:49:27 -0600
+++ src/sc2code/controls.h	2017-11-08 16:49:55 -0600
@@ -19,9 +19,6 @@
 #ifndef _CONTROLS_H_
 #define _CONTROLS_H_
 
-#include "races.h"
-		// For STARSHIPPTR
-
 #include "libs/compiler.h"
 #include "libs/strlib.h"
 
@@ -42,6 +39,7 @@ enum {
 	KEY_EXIT,
 	KEY_ABORT,
 	KEY_DEBUG,
+	KEY_FULLSCREEN,
 	KEY_MENU_UP,
 	KEY_MENU_DOWN,
 	KEY_MENU_LEFT,
@@ -88,14 +86,13 @@ typedef UBYTE BATTLE_INPUT_STATE;
 #define BATTLE_ESCAPE     ((BATTLE_INPUT_STATE)(1 << 5))
 #define BATTLE_DOWN       ((BATTLE_INPUT_STATE)(1 << 6))
 
-typedef BATTLE_INPUT_STATE (*battle_summary_func) (COUNT player,
-		STARSHIPPTR StarShipPtr);
-extern battle_summary_func ComputerInput, HumanInput[], NetworkInput;
-extern battle_summary_func PlayerInput[];
+BATTLE_INPUT_STATE CurrentInputToBattleInput (COUNT player);
+BATTLE_INPUT_STATE PulsedInputToBattleInput (COUNT player);
 
-extern CONTROLLER_INPUT_STATE CurrentInputState, PulsedInputState;
+extern CONTROLLER_INPUT_STATE CurrentInputState;
+extern CONTROLLER_INPUT_STATE PulsedInputState;
 extern volatile CONTROLLER_INPUT_STATE ImmediateInputState;
-extern CONTROL_TEMPLATE PlayerOne, PlayerTwo;
+extern CONTROL_TEMPLATE PlayerControls[];
 
 void UpdateInputState (void);
 void FlushInputState (void);
@@ -110,12 +107,10 @@ BOOLEAN WaitAnyButtonOrQuit (BOOLEAN Che
 void WaitForNoInput (SIZE Duration);
 BOOLEAN ConfirmExit (void);
 void DoPopupWindow(const char *msg);
-void DoInput (PVOID pInputState, BOOLEAN resetInput);
-
-BATTLE_INPUT_STATE p1_combat_summary (COUNT player, STARSHIPPTR StarShipPtr);
-BATTLE_INPUT_STATE p2_combat_summary (COUNT player, STARSHIPPTR StarShipPtr);
+void DoInput (void *pInputState, BOOLEAN resetInput);
 
-extern volatile BOOLEAN GamePaused, ExitRequested;
+extern volatile BOOLEAN GamePaused;
+extern volatile BOOLEAN ExitRequested;
 
 typedef struct joy_char joy_char_t;
 
@@ -152,9 +147,8 @@ typedef struct textentry_state
 	void *CbParam;     // callback parameter, use as you like
 	
 } TEXTENTRY_STATE;
-typedef TEXTENTRY_STATE *PTEXTENTRY_STATE;
 
-BOOLEAN DoTextEntry (PTEXTENTRY_STATE pTES);
+BOOLEAN DoTextEntry (TEXTENTRY_STATE *pTES);
 
 #endif
 
diff -ruNp src.orig/sc2code/corecode.h src/sc2code/corecode.h
--- src.orig/sc2code/corecode.h	1969-12-31 18:00:00 -0600
+++ src/sc2code/corecode.h	2017-11-08 16:49:55 -0600
@@ -0,0 +1,49 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef CORECODE_H_
+#define CORECODE_H_
+
+#include "ships/androsyn/icode.h"
+#include "ships/arilou/icode.h"
+#include "ships/blackurq/icode.h"
+#include "ships/chenjesu/icode.h"
+#include "ships/chmmr/icode.h"
+#include "ships/druuge/icode.h"
+#include "ships/human/icode.h"
+#include "ships/ilwrath/icode.h"
+#include "ships/lastbat/icode.h"
+#include "ships/melnorme/icode.h"
+#include "ships/mmrnmhrm/icode.h"
+#include "ships/mycon/icode.h"
+#include "ships/orz/icode.h"
+#include "ships/pkunk/icode.h"
+#include "ships/probe/icode.h"
+#include "ships/shofixti/icode.h"
+#include "ships/sis_ship/icode.h"
+#include "ships/slylandr/icode.h"
+#include "ships/spathi/icode.h"
+#include "ships/supox/icode.h"
+#include "ships/syreen/icode.h"
+#include "ships/thradd/icode.h"
+#include "ships/umgah/icode.h"
+#include "ships/urquan/icode.h"
+#include "ships/utwig/icode.h"
+#include "ships/vux/icode.h"
+#include "ships/yehat/icode.h"
+#include "ships/zoqfot/icode.h"
+
+#endif /* CORECODE_H_ */
diff -ruNp src.orig/sc2code/credits.c src/sc2code/credits.c
--- src.orig/sc2code/credits.c	2017-11-08 16:49:28 -0600
+++ src/sc2code/credits.c	2017-11-08 16:49:55 -0600
@@ -23,6 +23,7 @@
 #include "options.h"
 #include "oscill.h"
 #include "comm.h"
+#include "commglue.h"
 #include "resinst.h"
 #include "nameref.h"
 #include "settings.h"
@@ -49,7 +50,7 @@ static FRAME CreditsBack;
 typedef struct
 {
 	int size;
-	DWORD res;
+	RESOURCE res;
 	FONT font;
 } FONT_SIZE_DEF;
 
@@ -214,7 +215,7 @@ Credits_RenderTextFrame (CONTEXT TempCon
 	SetContextFont (fdef->font);
 	GetContextFontLeading (&leading);
 	// get left/right margin
-	TextRect (&t, &r, NULL_PTR);
+	TextRect (&t, &r, NULL);
 
 	// parse text column alignment
 	for (i = 0, scol = strtok (salign, ",");
@@ -314,8 +315,8 @@ credit_roll_task (void *data)
 	TextBack = BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x00), 0x00);
 	TextFore = BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x1F), 0x0F);
 
-	LocalContext = CaptureContext (CreateContext ());
-	DrawContext = CaptureContext (CreateContext ());
+	LocalContext = CreateContext ();
+	DrawContext = CreateContext ();
 	
 	total_h = disp_h = SCREEN_HEIGHT;
 
@@ -530,8 +531,8 @@ credit_roll_task (void *data)
 		}
 	}
 
-	DestroyContext (ReleaseContext (DrawContext));
-	DestroyContext (ReleaseContext (LocalContext));
+	DestroyContext (DrawContext);
+	DestroyContext (LocalContext);
 
 	// free remaining frames
 	DestroyDrawable (ReleaseDrawable (Frame));
@@ -554,7 +555,7 @@ StartCredits (void)
 	CreditsBack = CaptureDrawable (LoadGraphic (CREDITS_BACK_ANIM));
 	// load fonts
 	for (fdef = CreditsFont; fdef->size; ++fdef)
-		fdef->font = CaptureFont (LoadFont (fdef->res));
+		fdef->font = LoadFont (fdef->res);
 
 	CreditsRate = CREDITS_BASE_RATE;
 	CreditsRunning = FALSE;
@@ -578,7 +579,7 @@ FreeCredits (void)
 	// free fonts
 	for (fdef = CreditsFont; fdef->size; ++fdef)
 	{
-		DestroyFont (ReleaseFont (fdef->font));
+		DestroyFont (fdef->font);
 		fdef->font = 0;
 	}
 }
@@ -587,7 +588,7 @@ static void
 OutTakes (void)
 {
 #define NUM_OUTTAKES 15
-	static long outtake_list[NUM_OUTTAKES] =
+	static CONVERSATION outtake_list[NUM_OUTTAKES] =
 	{
 		ZOQFOTPIK_CONVERSATION,
 		TALKING_PET_CONVERSATION,
@@ -627,7 +628,7 @@ OutTakes (void)
 typedef struct
 {
 	// standard state required by DoInput
-	BOOLEAN (*InputFunc) (PVOID pInputState);
+	BOOLEAN (*InputFunc) (void *pInputState);
 	COUNT MenuRepeatDelay;
 
 	BOOLEAN AllowCancel;
@@ -638,7 +639,7 @@ typedef struct
 } CREDITS_INPUT_STATE;
 
 static BOOLEAN
-DoCreditsInput (PVOID pIS)
+DoCreditsInput (void *pIS)
 {
 	CREDITS_INPUT_STATE *pCIS = (CREDITS_INPUT_STATE *) pIS;
 
@@ -716,7 +717,7 @@ Credits (BOOLEAN WithOuttakes)
 
 	LockMutex (GraphicsLock);
 	SetContext (ScreenContext);
-	SetContextClipRect (NULL_PTR);
+	SetContextClipRect (NULL);
 	SetContextBackGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x00), 0x00));
 	ClearDrawable ();
diff -ruNp src.orig/sc2code/cyborg.c src/sc2code/cyborg.c
--- src.orig/sc2code/cyborg.c	2017-11-08 16:49:28 -0600
+++ src/sc2code/cyborg.c	2017-11-08 16:49:55 -0600
@@ -31,8 +31,8 @@
 //#define DEBUG_CYBORG
 
 COUNT
-PlotIntercept (ELEMENTPTR ElementPtr0, ELEMENTPTR ElementPtr1, COUNT
-		max_turns, COUNT margin_of_error)
+PlotIntercept (ELEMENT *ElementPtr0, ELEMENT *ElementPtr1,
+		COUNT max_turns, COUNT margin_of_error)
 {
 	SIZE dy;
 	SIZE time_y_0, time_y_1;
@@ -289,10 +289,10 @@ PlotIntercept (ELEMENTPTR ElementPtr0, E
 	return (0);
 }
 
-STARSHIPPTR CyborgDescPtr;
+STARSHIP *CyborgDescPtr;
 
 static void
-InitCyborg (STARSHIPPTR StarShipPtr)
+InitCyborg (STARSHIP *StarShipPtr)
 {
 	COUNT Index, Divisor;
 
@@ -318,7 +318,7 @@ InitCyborg (STARSHIPPTR StarShipPtr)
 }
 
 static void
-ship_movement (ELEMENTPTR ShipPtr, EVALUATE_DESCPTR EvalDescPtr)
+ship_movement (ELEMENT *ShipPtr, EVALUATE_DESC *EvalDescPtr)
 {
 	if (EvalDescPtr->which_turn == 0)
 		EvalDescPtr->which_turn = 1;
@@ -342,14 +342,13 @@ ship_movement (ELEMENTPTR ShipPtr, EVALU
 }
 
 BOOLEAN
-ship_weapons (ELEMENTPTR ShipPtr, ELEMENTPTR OtherPtr, COUNT
-		margin_of_error)
+ship_weapons (ELEMENT *ShipPtr, ELEMENT *OtherPtr, COUNT margin_of_error)
 {
 	SIZE delta_x, delta_y;
 	COUNT n, num_weapons;
 	ELEMENT Ship;
 	HELEMENT Weapon[6];
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	if (OBJECT_CLOAKED (OtherPtr))
 		margin_of_error += DISPLAY_TO_WORLD (40);
@@ -370,8 +369,8 @@ ship_weapons (ELEMENTPTR ShipPtr, ELEMEN
 	if ((n = num_weapons))
 	{
 		HELEMENT *WeaponPtr, w;
-		//STARSHIPPTR StarShipPtr;
-		ELEMENTPTR EPtr;
+		//STARSHIP *StarShipPtr;
+		ELEMENT *EPtr;
 
 		WeaponPtr = &Weapon[0];
 		do
@@ -416,12 +415,12 @@ ship_weapons (ELEMENTPTR ShipPtr, ELEMEN
 }
 
 void
-ship_intelligence (ELEMENTPTR ShipPtr, EVALUATE_DESCPTR ObjectsOfConcern,
+ship_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
 		COUNT ConcernCounter)
 {
 	BOOLEAN ShipMoved, ShipFired;
 	COUNT margin_of_error;
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 
@@ -455,7 +454,7 @@ ship_intelligence (ELEMENTPTR ShipPtr, E
 			if (!ShipMoved
 					&& (ConcernCounter != ENEMY_WEAPON_INDEX
 					|| ObjectsOfConcern->MoveState == PURSUE
-|| (ObjectsOfConcern->ObjectPtr->state_flags & CREW_OBJECT)
+					|| (ObjectsOfConcern->ObjectPtr->state_flags & CREW_OBJECT)
 					|| MANEUVERABILITY (
 							&StarShipPtr->RaceDescPtr->cyborg_control
 							) >= MEDIUM_SHIP))
@@ -482,10 +481,10 @@ ship_intelligence (ELEMENTPTR ShipPtr, E
 }
 
 BOOLEAN
-TurnShip (ELEMENTPTR ShipPtr, COUNT angle)
+TurnShip (ELEMENT *ShipPtr, COUNT angle)
 {
 	COUNT f, ship_delta_facing;
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	f = StarShipPtr->ShipFacing;
@@ -531,10 +530,10 @@ TurnShip (ELEMENTPTR ShipPtr, COUNT angl
 }
 
 BOOLEAN
-ThrustShip (ELEMENTPTR ShipPtr, COUNT angle)
+ThrustShip (ELEMENT *ShipPtr, COUNT angle)
 {
 	BOOLEAN ShouldThrust;
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	if (StarShipPtr->ship_input_state & THRUST)
@@ -571,14 +570,14 @@ ThrustShip (ELEMENTPTR ShipPtr, COUNT an
 }
 
 void
-Pursue (ELEMENTPTR ShipPtr, EVALUATE_DESCPTR EvalDescPtr)
+Pursue (ELEMENT *ShipPtr, EVALUATE_DESC *EvalDescPtr)
 {
 	INPUT_STATE maneuver_state;
 	COUNT desired_thrust_angle, desired_turn_angle;
 	SIZE delta_x, delta_y;
 	SIZE ship_delta_x, ship_delta_y;
 	SIZE other_delta_x, other_delta_y;
-	ELEMENTPTR OtherObjPtr;
+	ELEMENT *OtherObjPtr;
 	VELOCITY_DESC ShipVelocity, OtherVelocity;
 
 	ShipVelocity = ShipPtr->velocity;
@@ -617,7 +616,8 @@ Pursue (ELEMENTPTR ShipPtr, EVALUATE_DES
 	if ((OtherObjPtr->state_flags & PLAYER_SHIP)
 			&& OtherObjPtr->mass_points <= MAX_SHIP_MASS)
 	{
-		STARSHIPPTR StarShipPtr, EnemyStarShipPtr;
+		STARSHIP *StarShipPtr;
+		STARSHIP *EnemyStarShipPtr;
 
 		GetElementStarShip (ShipPtr, &StarShipPtr);
 		GetElementStarShip (OtherObjPtr, &EnemyStarShipPtr);
@@ -701,7 +701,7 @@ Pursue (ELEMENTPTR ShipPtr, EVALUATE_DES
 }
 
 void
-Entice (ELEMENTPTR ShipPtr, EVALUATE_DESCPTR EvalDescPtr)
+Entice (ELEMENT *ShipPtr, EVALUATE_DESC *EvalDescPtr)
 {
 	INPUT_STATE maneuver_state;
 	COUNT desired_thrust_angle, desired_turn_angle;
@@ -709,10 +709,10 @@ Entice (ELEMENTPTR ShipPtr, EVALUATE_DES
 	SIZE delta_x, delta_y;
 	SIZE ship_delta_x, ship_delta_y;
 	SIZE other_delta_x, other_delta_y;
-	ELEMENTPTR OtherObjPtr;
+	ELEMENT *OtherObjPtr;
 	VELOCITY_DESC ShipVelocity, OtherVelocity;
-	STARSHIPPTR StarShipPtr;
-	RACE_DESCPTR RDPtr;
+	STARSHIP *StarShipPtr;
+	RACE_DESC *RDPtr;
 
 	ShipVelocity = ShipPtr->velocity;
 	GetNextVelocityComponents (&ShipVelocity,
@@ -722,7 +722,7 @@ Entice (ELEMENTPTR ShipPtr, EVALUATE_DES
 	ShipPtr->next.location.y =
 			ShipPtr->current.location.y + ship_delta_y;
 
-	OtherObjPtr = (ELEMENTPTR)EvalDescPtr->ObjectPtr;
+	OtherObjPtr = EvalDescPtr->ObjectPtr;
 	OtherVelocity = OtherObjPtr->velocity;
 	GetNextVelocityComponents (&OtherVelocity,
 			&other_delta_x, &other_delta_y, EvalDescPtr->which_turn);
@@ -840,7 +840,7 @@ Entice (ELEMENTPTR ShipPtr, EVALUATE_DES
 		{
 			UWORD fire_flags, ship_flags;
 			COUNT facing;
-			STARSHIPPTR EnemyStarShipPtr;
+			STARSHIP *EnemyStarShipPtr;
 
 			GetElementStarShip (OtherObjPtr, &EnemyStarShipPtr);
 			ship_flags = EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags;
@@ -1003,24 +1003,25 @@ DoManeuver:
 }
 
 void
-Avoid (ELEMENTPTR ShipPtr, EVALUATE_DESCPTR EvalDescPtr)
+Avoid (ELEMENT *ShipPtr, EVALUATE_DESC *EvalDescPtr)
 {
 	(void) ShipPtr;  /* Satisfying compiler (unused parameter) */
 	(void) EvalDescPtr;  /* Satisfying compiler (unused parameter) */
 }
 
 BATTLE_INPUT_STATE
-tactical_intelligence (COUNT player, STARSHIPPTR StarShipPtr)
+tactical_intelligence (ComputerInputContext *context, STARSHIP *StarShipPtr)
 {
-	ELEMENTPTR ShipPtr;
+	ELEMENT *ShipPtr;
 	ELEMENT Ship;
 	COUNT ShipFacing;
 	HELEMENT hElement, hNextElement;
 	COUNT ConcernCounter;
 	EVALUATE_DESC ObjectsOfConcern[10];
 	BOOLEAN ShipMoved, UltraManeuverable;
-	STARSHIPPTR EnemyStarShipPtr;
-	RACE_DESCPTR RDPtr, EnemyRDPtr;
+	STARSHIP *EnemyStarShipPtr;
+	RACE_DESC *RDPtr;
+	RACE_DESC *EnemyRDPtr;
 
 	RDPtr = StarShipPtr->RaceDescPtr;
 
@@ -1036,7 +1037,8 @@ tactical_intelligence (COUNT player, STA
 	}
 
 	ShipMoved = TRUE;
-	if (PlayerControl[player] & STANDARD_RATING)
+	/* Disable ship's special completely for the Standard AI */
+	if (PlayerControl[context->playerNr] & STANDARD_RATING)
 		++StarShipPtr->special_counter;
 
 #ifdef DEBUG_CYBORG
@@ -1144,9 +1146,9 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 					InitCyborg (EnemyStarShipPtr);
 
 				ed.which_turn = WORLD_TO_TURN (
-						square_root ((long)dx * dx + (long)dy * dy)
-						);
-				if (ed.which_turn > ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn)
+						square_root ((long)dx * dx + (long)dy * dy));
+				if (ed.which_turn >
+						ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn)
 				{
 					UnlockElement (hElement);
 					continue;
@@ -1259,7 +1261,7 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 							ed.which_turn = 0;
 					}
 				}
-				else if (!(PlayerControl[player] & AWESOME_RATING))
+				else if (!(PlayerControl[context->playerNr] & AWESOME_RATING))
 					ed.which_turn = 0;
 				else
 				{
@@ -1313,8 +1315,8 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 		UnlockElement (hElement);
 	}
 
-	(*RDPtr->cyborg_control.intelligence_func)
-			(&Ship, ObjectsOfConcern, ConcernCounter);
+	RDPtr->cyborg_control.intelligence_func (&Ship, ObjectsOfConcern,
+			ConcernCounter);
 #ifdef DEBUG_CYBORG
 StarShipPtr->ship_input_state &= ~SPECIAL;
 #endif /* DEBUG_CYBORG */
diff -ruNp src.orig/sc2code/demo.c src/sc2code/demo.c
--- src.orig/sc2code/demo.c	2017-11-08 16:49:28 -0600
+++ src/sc2code/demo.c	2017-11-08 16:49:55 -0600
@@ -39,7 +39,7 @@ INPUT_STATE
 demo_input (INPUT_REF InputRef, INPUT_STATE InputState)
 {
 	if (InputState || AnyButtonPress () || cread (
-			(PBYTE)&InputState, sizeof (InputState), 1, journal_fh
+			&InputState, sizeof (InputState), 1, journal_fh
 			) == 0)
 	{
 		cclose (journal_fh);
@@ -63,7 +63,7 @@ void
 JournalInput (INPUT_STATE InputState)
 {
 	if (ArrowInput != DemoInput && journal_fh)
-		cwrite ((PBYTE)&InputState, sizeof (InputState), 1, journal_fh);
+		cwrite (&InputState, sizeof (InputState), 1, journal_fh);
 }
 
 #endif /* CREATE_JOURNAL */
@@ -81,7 +81,7 @@ OpenJournal (void)
 		if (journal_fh = copen (journal_buf, MEMORY_STREAM, STREAM_WRITE))
 		{
 			start_seed = SeedRandomNumbers ();
-			cwrite ((PBYTE)&start_seed, sizeof (start_seed), 1, journal_fh);
+			cwrite (&start_seed, sizeof (start_seed), 1, journal_fh);
 		}
 	}
 	else
@@ -102,7 +102,7 @@ OpenJournal (void)
 
 				FlushInput ();
 
-				cread ((PBYTE)&start_seed, sizeof (start_seed), 1, journal_fh);
+				cread (&start_seed, sizeof (start_seed), 1, journal_fh);
 				TFB_SeedRandom (start_seed);
 			}
 		}
diff -ruNp src.orig/sc2code/displist.c src/sc2code/displist.c
--- src.orig/sc2code/displist.c	2017-11-08 16:49:28 -0600
+++ src/sc2code/displist.c	2017-11-08 16:49:55 -0600
@@ -19,6 +19,10 @@
 #include "displist.h"
 #include "libs/log.h"
 
+#ifdef QUEUE_TABLE
+#define NULL_HANDLE NULL
+#endif
+
 /*
  * This file contains code for generic doubly linked lists.
  * If QUEUE_TABLE is defined, each lists has its own preallocated
@@ -27,7 +31,7 @@
  */
 
 BOOLEAN
-InitQueue (PQUEUE pq, COUNT num_elements, OBJ_SIZE size)
+InitQueue (QUEUE *pq, COUNT num_elements, OBJ_SIZE size)
 {
 	SetHeadLink (pq, NULL_HANDLE);
 	SetTailLink (pq, NULL_HANDLE);
@@ -40,7 +44,7 @@ InitQueue (PQUEUE pq, COUNT num_elements
 	log_add (log_Debug, "InitQueue(): num_elements = %d (%d)",
 			num_elements, (BYTE)num_elements);
 #endif
-	if (AllocQueueTab (pq, num_elements) && LockQueueTab (pq))
+	if (AllocQueueTab (pq, num_elements) != NULL)
 	{
 		do
 			FreeLink (pq, GetLinkAddr (pq, num_elements));
@@ -54,13 +58,12 @@ InitQueue (PQUEUE pq, COUNT num_elements
 }
 
 BOOLEAN
-UninitQueue (PQUEUE pq)
+UninitQueue (QUEUE *pq)
 {
 #ifdef QUEUE_TABLE
 	SetHeadLink (pq, NULL_HANDLE);
 	SetTailLink (pq, NULL_HANDLE);
 	SetFreeList (pq, NULL_HANDLE);
-	UnlockQueueTab (pq);
 	FreeQueueTab (pq);
 
 	return (TRUE);
@@ -78,8 +81,9 @@ UninitQueue (PQUEUE pq)
 #endif /* QUEUE_TABLE */
 }
 
+// Empty the queue. The elements linked to in the queue are unchanged.
 void
-ReinitQueue (PQUEUE pq)
+ReinitQueue (QUEUE *pq)
 {
 	SetHeadLink (pq, NULL_HANDLE);
 	SetTailLink (pq, NULL_HANDLE);
@@ -102,14 +106,14 @@ ReinitQueue (PQUEUE pq)
 
 #ifdef QUEUE_TABLE
 HLINK
-AllocLink (PQUEUE pq)
+AllocLink (QUEUE *pq)
 {
 	HLINK hLink;
 
 	hLink = GetFreeList (pq);
 	if (hLink)
 	{
-		LINKPTR LinkPtr;
+		LINK *LinkPtr;
 
 		LinkPtr = LockLink (pq, hLink);
 		SetFreeList (pq, _GetSuccLink (LinkPtr));
@@ -122,9 +126,9 @@ AllocLink (PQUEUE pq)
 }
 
 void
-FreeLink (PQUEUE pq, HLINK hLink)
+FreeLink (QUEUE *pq, HLINK hLink)
 {
-	LINKPTR LinkPtr;
+	LINK *LinkPtr;
 
 	LinkPtr = LockLink (pq, hLink);
 	_SetSuccLink (LinkPtr, GetFreeList (pq));
@@ -135,16 +139,16 @@ FreeLink (PQUEUE pq, HLINK hLink)
 #endif /* QUEUE_TABLE */
 
 void
-PutQueue (PQUEUE pq, HLINK hLink)
+PutQueue (QUEUE *pq, HLINK hLink)
 {
-	LINKPTR LinkPtr;
+	LINK *LinkPtr;
 
 	if (GetHeadLink (pq) == 0)
 		SetHeadLink (pq, hLink);
 	else
 	{
 		HLINK hTail;
-		LINKPTR lpTail;
+		LINK *lpTail;
 
 		hTail = GetTailLink (pq);
 		lpTail = LockLink (pq, hTail);
@@ -161,13 +165,14 @@ PutQueue (PQUEUE pq, HLINK hLink)
 }
 
 void
-InsertQueue (PQUEUE pq, HLINK hLink, HLINK hRefLink)
+InsertQueue (QUEUE *pq, HLINK hLink, HLINK hRefLink)
 {
 	if (hRefLink == 0)
 		PutQueue (pq, hLink);
 	else
 	{
-		LINKPTR LinkPtr, RefLinkPtr;
+		LINK *LinkPtr;
+		LINK *RefLinkPtr;
 
 		LinkPtr = LockLink (pq, hLink);
 		RefLinkPtr = LockLink (pq, hRefLink);
@@ -180,7 +185,7 @@ InsertQueue (PQUEUE pq, HLINK hLink, HLI
 		else
 		{
 			HLINK hPredLink;
-			LINKPTR PredLinkPtr;
+			LINK *PredLinkPtr;
 
 			hPredLink = _GetPredLink (LinkPtr);
 			PredLinkPtr = LockLink (pq, hPredLink);
@@ -193,9 +198,9 @@ InsertQueue (PQUEUE pq, HLINK hLink, HLI
 }
 
 void
-RemoveQueue (PQUEUE pq, HLINK hLink)
+RemoveQueue (QUEUE *pq, HLINK hLink)
 {
-	LINKPTR LinkPtr;
+	LINK *LinkPtr;
 
 	LinkPtr = LockLink (pq, hLink);
 	if (GetHeadLink (pq) == hLink)
@@ -205,7 +210,7 @@ RemoveQueue (PQUEUE pq, HLINK hLink)
 	else
 	{
 		HLINK hPredLink;
-		LINKPTR PredLinkPtr;
+		LINK *PredLinkPtr;
 
 		hPredLink = _GetPredLink (LinkPtr);
 		PredLinkPtr = LockLink (pq, hPredLink);
@@ -219,7 +224,7 @@ RemoveQueue (PQUEUE pq, HLINK hLink)
 	else
 	{
 		HLINK hSuccLink, hPredLink;
-		LINKPTR SuccLinkPtr;
+		LINK *SuccLinkPtr;
 
 		hSuccLink = _GetSuccLink (LinkPtr);
 		SuccLinkPtr = LockLink (pq, hSuccLink);
@@ -231,7 +236,7 @@ RemoveQueue (PQUEUE pq, HLINK hLink)
 }
 
 COUNT
-CountLinks (PQUEUE pq)
+CountLinks (QUEUE *pq)
 {
 	COUNT LinkCount;
 	HLINK hLink, hNextLink;
@@ -239,7 +244,7 @@ CountLinks (PQUEUE pq)
 	LinkCount = 0;
 	for (hLink = GetHeadLink (pq); hLink; hLink = hNextLink)
 	{
-		LINKPTR LinkPtr;
+		LINK *LinkPtr;
 
 		++LinkCount;
 
@@ -252,13 +257,13 @@ CountLinks (PQUEUE pq)
 }
 
 void
-ForAllLinks (PQUEUE pq, void (*callback)(LINKPTR, void *), void *arg)
+ForAllLinks (QUEUE *pq, void (*callback)(LINK *, void *), void *arg)
 {
 	HLINK hLink, hNextLink;
 
 	for (hLink = GetHeadLink (pq); hLink; hLink = hNextLink)
 	{
-		LINKPTR LinkPtr;
+		LINK *LinkPtr;
 		LinkPtr = LockLink (pq, hLink);
 		hNextLink = _GetSuccLink (LinkPtr);
 		(*callback) (LinkPtr, arg);
diff -ruNp src.orig/sc2code/displist.h src/sc2code/displist.h
--- src.orig/sc2code/displist.h	2017-11-08 16:49:28 -0600
+++ src/sc2code/displist.h	2017-11-08 16:49:55 -0600
@@ -19,13 +19,23 @@
 #ifndef _DISPLIST_H
 #define _DISPLIST_H
 
-#include "memlib.h"
-
+#include <assert.h>
+#include "port.h"
+#include "compiler.h"
+#include "misc.h"
+
+// Note that we MUST use the QUEUE_TABLE variant at this time, because
+// certain gameplay elements depend on it. Namely, the maximum number
+// of HyperSpace encounter globes chasing the player is defined by the
+// allocated size of the encounter_q. If switched to non-table variant,
+// the max number of encounters will be virtually unlimited the way the
+// code works now.
 #define QUEUE_TABLE
 
 #ifdef QUEUE_TABLE
-typedef PVOID QUEUE_HANDLE;
+typedef void* QUEUE_HANDLE;
 #else /* !QUEUE_TABLE */
+#include "libs/memlib.h"
 typedef MEM_HANDLE QUEUE_HANDLE;
 #endif /* QUEUE_TABLE */
 
@@ -34,55 +44,64 @@ typedef QUEUE_HANDLE HLINK;
 
 typedef struct link
 {
+	// Every queue element of any queue must have these
+	// two as the first members
 	HLINK pred;
 	HLINK succ;
 } LINK;
-typedef LINK *PLINK;
-
-typedef PBYTE BYTEPTR;
-typedef PUWORD WORDPTR;
-typedef PVOID VOIDPTR;
-typedef PLINK LINKPTR;
 
-#ifdef QUEUE_TABLE
-#define LockLink(pq, h) (LINKPTR)(h)
-#define UnlockLink(pq, h)
-#define GetFreeList(pq) (pq)->free_list
-#define SetFreeList(pq, h) (pq)->free_list = (h)
-#define AllocQueueTab(pq,n) \
-		((pq)->hq_tab = mem_allocate ((MEM_SIZE)((COUNT)(pq)->object_size * \
-		(COUNT)((pq)->num_objects = (BYTE)(n))), \
-		MEM_PRIMARY, DEFAULT_MEM_PRIORITY, MEM_SIMPLE))
-#define LockQueueTab(pq) ((pq)->pq_tab = (BYTEPTR)mem_lock ((pq)->hq_tab))
-#define UnlockQueueTab(pq) mem_unlock ((pq)->hq_tab)
-#define FreeQueueTab(pq) mem_release ((pq)->hq_tab); (pq)->hq_tab = 0
-#define SizeQueueTab(pq) (COUNT)((pq)->num_objects)
-#define GetLinkAddr(pq,i) (HLINK)((pq)->pq_tab + ((pq)->object_size * ((i) - 1)))
-#else /* !QUEUE_TABLE */
-#define AllocLink(pq) (HLINK)mem_request ((pq)->object_size)
-#define LockLink(pq, h) (LINKPTR)mem_lock (h)
-#define UnlockLink(pq, h) mem_unlock (h)
-#define FreeLink(pq,h) mem_release (h)
-#endif /* QUEUE_TABLE */
-
-typedef struct queue
+typedef struct /* queue */
 {
 	HLINK head;
 	HLINK tail;
 #ifdef QUEUE_TABLE
-	BYTEPTR pq_tab;
+	BYTE  *pq_tab;
 	HLINK free_list;
-	MEM_HANDLE hq_tab;
 #endif
-//    BYTE object_size;
 	COUNT object_size;
 #ifdef QUEUE_TABLE
 	BYTE num_objects;
 #endif /* QUEUE_TABLE */
 } QUEUE;
-typedef QUEUE *PQUEUE;
 
-// #define SetLinkSize(pq,s) ((pq)->object_size = (BYTE)(s))
+#ifdef QUEUE_TABLE
+
+static inline LINK *
+LockLink (const QUEUE *pq, HLINK h)
+{
+	if (h) // Apparently, h==0 is OK
+	{	// Make sure the link is actually in our queue!
+		assert (pq->pq_tab && (BYTE*)h >= pq->pq_tab &&
+				(BYTE*)h < pq->pq_tab + pq->object_size * pq->num_objects);
+	}
+	return (LINK*)h;
+}
+
+static inline void
+UnlockLink (const QUEUE *pq, HLINK h)
+{
+	if (h) // Apparently, h==0 is OK
+	{	// Make sure the link is actually in our queue!
+		assert (pq->pq_tab && (BYTE*)h >= pq->pq_tab &&
+				(BYTE*)h < pq->pq_tab + pq->object_size * pq->num_objects);
+	}
+}
+
+#define GetFreeList(pq) (pq)->free_list
+#define SetFreeList(pq, h) (pq)->free_list = (h)
+#define AllocQueueTab(pq,n) \
+		((pq)->pq_tab = HMalloc (((COUNT)(pq)->object_size * \
+		(COUNT)((pq)->num_objects = (BYTE)(n)))))
+#define FreeQueueTab(pq) HFree ((pq)->pq_tab); (pq)->pq_tab = NULL
+#define SizeQueueTab(pq) (COUNT)((pq)->num_objects)
+#define GetLinkAddr(pq,i) (HLINK)((pq)->pq_tab + ((pq)->object_size * ((i) - 1)))
+#else /* !QUEUE_TABLE */
+#define AllocLink(pq) (HLINK)mem_allocate ((pq)->object_size, DEFAULT_MEM_FLAGS)
+#define LockLink(pq, h) (LINK*)mem_lock (h)
+#define UnlockLink(pq, h) mem_unlock (h)
+#define FreeLink(pq,h) mem_release (h)
+#endif /* QUEUE_TABLE */
+
 #define SetLinkSize(pq,s) ((pq)->object_size = (COUNT)(s))
 #define GetLinkSize(pq) (COUNT)((pq)->object_size)
 #define GetHeadLink(pq) ((pq)->head)
@@ -94,17 +113,17 @@ typedef QUEUE *PQUEUE;
 #define _GetSuccLink(lpE) ((lpE)->succ)
 #define _SetSuccLink(lpE,h) ((lpE)->succ = (h))
 
-extern BOOLEAN InitQueue (PQUEUE pq, COUNT num_elements, OBJ_SIZE size);
-extern BOOLEAN UninitQueue (PQUEUE pq);
-extern void ReinitQueue (PQUEUE pq);
-extern void PutQueue (PQUEUE pq, HLINK hLink);
-extern void InsertQueue (PQUEUE pq, HLINK hLink, HLINK hRefLink);
-extern void RemoveQueue (PQUEUE pq, HLINK hLink);
-extern COUNT CountLinks (PQUEUE pq);
-void ForAllLinks(PQUEUE pq, void (*callback)(LINKPTR, void *), void *arg);
+extern BOOLEAN InitQueue (QUEUE *pq, COUNT num_elements, OBJ_SIZE size);
+extern BOOLEAN UninitQueue (QUEUE *pq);
+extern void ReinitQueue (QUEUE *pq);
+extern void PutQueue (QUEUE *pq, HLINK hLink);
+extern void InsertQueue (QUEUE *pq, HLINK hLink, HLINK hRefLink);
+extern void RemoveQueue (QUEUE *pq, HLINK hLink);
+extern COUNT CountLinks (QUEUE *pq);
+void ForAllLinks(QUEUE *pq, void (*callback)(LINK *, void *), void *arg);
 #ifdef QUEUE_TABLE
-extern HLINK AllocLink (PQUEUE pq);
-extern void FreeLink (PQUEUE pq, HLINK hLink);
+extern HLINK AllocLink (QUEUE *pq);
+extern void FreeLink (QUEUE *pq, HLINK hLink);
 #endif /* QUEUE_TABLE */
 
 #endif /* _DISPLIST_H */
diff -ruNp src.orig/sc2code/dummy.c src/sc2code/dummy.c
--- src.orig/sc2code/dummy.c	2017-11-08 16:49:28 -0600
+++ src/sc2code/dummy.c	2017-11-08 16:49:55 -0600
@@ -28,24 +28,17 @@
 #include "libs/compiler.h"
 #include "libs/log.h"
 
+#include <stdlib.h>
 #include <ctype.h>
 
 
 typedef struct
 {
-	MEM_HANDLE handle _ALIGNED_ON(sizeof (MEM_HANDLE));
 	RACE_DESC data _ALIGNED_ANY;
 } CODERES_STRUCT;
 
-MEM_HANDLE
-LoadCodeResFile (PSTR pStr)
-{
-	(void) pStr;  /* Satisfying compiler (unused parameter) */
-	return (0);
-}
-
-static MEM_HANDLE
-GetCodeResData (uio_Stream *fp, DWORD length)
+static void
+GetCodeResData (const char *ship_id, RESOURCE_DATA *resdata)
 {
 enum
 {
@@ -81,62 +74,62 @@ enum
 };
 
 	BYTE which_res;
-	MEM_HANDLE hData;
+	void *hData;
 
-	which_res = GetResFileChar (fp);
-	hData = mem_request (sizeof (CODERES_STRUCT));
+	which_res = atoi (ship_id);
+	hData = HMalloc (sizeof (CODERES_STRUCT));
 	if (hData)
 	{
-		RACE_DESCPTR RDPtr;
+		RACE_DESC *RDPtr;
 
-		RDPtr = 0;
+		RDPtr = NULL;
 		switch (which_res)
 		{
 			case ANDROSYN_CODE_RES:
 			{
-				extern RACE_DESCPTR init_androsynth (void);
+				extern RACE_DESC* init_androsynth (void);
 
 				RDPtr = init_androsynth ();
 				break;
 			}
 			case ARILOU_CODE_RES:
 			{
-				extern RACE_DESCPTR init_arilou (void);
+				extern RACE_DESC* init_arilou (void);
 
 				RDPtr = init_arilou ();
 				break;
 			}
 			case BLACKURQ_CODE_RES:
 			{
-				extern RACE_DESCPTR init_black_urquan (void);
+				extern RACE_DESC* init_black_urquan (void);
 
 				RDPtr = init_black_urquan ();
 				break;
 			}
 			case CHENJESU_CODE_RES:
 			{
-				extern RACE_DESCPTR init_chenjesu (void);
+				extern RACE_DESC* init_chenjesu (void);
 
 				RDPtr = init_chenjesu ();
 				break;
 			}
 			case CHMMR_CODE_RES:
 			{
-				extern RACE_DESCPTR init_chmmr (void);
+				extern RACE_DESC* init_chmmr (void);
 
 				RDPtr = init_chmmr ();
 				break;
 			}
 			case DRUUGE_CODE_RES:
 			{
-				extern RACE_DESCPTR init_druuge (void);
+				extern RACE_DESC* init_druuge (void);
 
 				RDPtr = init_druuge ();
 				break;
 			}
 			case HUMAN_CODE_RES:
 			{
-				extern RACE_DESCPTR init_human (void);
+				extern RACE_DESC* init_human (void);
 
 				RDPtr = init_human ();
 				break;
@@ -144,49 +137,49 @@ enum
 			case ILWRATH_CODE_RES:
 			{
 				
-				extern RACE_DESCPTR init_ilwrath (void);
+				extern RACE_DESC* init_ilwrath (void);
 
 				RDPtr = init_ilwrath ();
 				break;
 			}
 			case MELNORME_CODE_RES:
 			{
-				extern RACE_DESCPTR init_melnorme (void);
+				extern RACE_DESC* init_melnorme (void);
 
 				RDPtr = init_melnorme ();
 				break;
 			}
 			case MMRNMHRM_CODE_RES:
 			{
-				extern RACE_DESCPTR init_mmrnmhrm (void);
+				extern RACE_DESC* init_mmrnmhrm (void);
 
 				RDPtr = init_mmrnmhrm ();
 				break;
 			}
 			case MYCON_CODE_RES:
 			{
-				extern RACE_DESCPTR init_mycon (void);
+				extern RACE_DESC* init_mycon (void);
 
 				RDPtr = init_mycon ();
 				break;
 			}
 			case ORZ_CODE_RES:
 			{
-				extern RACE_DESCPTR init_orz (void);
+				extern RACE_DESC* init_orz (void);
 
 				RDPtr = init_orz ();
 				break;
 			}
 			case PKUNK_CODE_RES:
 			{
-				extern RACE_DESCPTR init_pkunk (void);
+				extern RACE_DESC* init_pkunk (void);
 
 				RDPtr = init_pkunk ();
 				break;
 			}
 			case SHOFIXTI_CODE_RES:
 			{
-				extern RACE_DESCPTR init_shofixti (void);
+				extern RACE_DESC* init_shofixti (void);
 
 				RDPtr = init_shofixti ();
 				break;
@@ -194,56 +187,56 @@ enum
 			case SLYLANDR_CODE_RES:
 			{
 				
-				extern RACE_DESCPTR init_slylandro (void);
+				extern RACE_DESC* init_slylandro (void);
 
 				RDPtr = init_slylandro ();
 				break;
 			}
 			case SPATHI_CODE_RES:
 			{
-				extern RACE_DESCPTR init_spathi (void);
+				extern RACE_DESC* init_spathi (void);
 
 				RDPtr = init_spathi ();
 				break;
 			}
 			case SUPOX_CODE_RES:
 			{
-				extern RACE_DESCPTR init_supox (void);
+				extern RACE_DESC* init_supox (void);
 
 				RDPtr = init_supox ();
 				break;
 			}
 			case SYREEN_CODE_RES:
 			{
-				extern RACE_DESCPTR init_syreen (void);
+				extern RACE_DESC* init_syreen (void);
 
 				RDPtr = init_syreen ();
 				break;
 			}
 			case THRADD_CODE_RES:
 			{
-				extern RACE_DESCPTR init_thraddash (void);
+				extern RACE_DESC* init_thraddash (void);
 
 				RDPtr = init_thraddash ();
 				break;
 			}
 			case UMGAH_CODE_RES:
 			{
-				extern RACE_DESCPTR init_umgah (void);
+				extern RACE_DESC* init_umgah (void);
 
 				RDPtr = init_umgah ();
 				break;
 			}
 			case URQUAN_CODE_RES:
 			{
-				extern RACE_DESCPTR init_urquan (void);
+				extern RACE_DESC* init_urquan (void);
 
 				RDPtr = init_urquan ();
 				break;
 			}
 			case UTWIG_CODE_RES:
 			{
-				extern RACE_DESCPTR init_utwig (void);
+				extern RACE_DESC* init_utwig (void);
 
 				RDPtr = init_utwig ();
 				break;
@@ -251,80 +244,89 @@ enum
 			case VUX_CODE_RES:
 			{
 				
-				extern RACE_DESCPTR init_vux (void);
+				extern RACE_DESC* init_vux (void);
 
 				RDPtr = init_vux ();
 				break;
 			}
 			case YEHAT_CODE_RES:
 			{
-				extern RACE_DESCPTR init_yehat (void);
+				extern RACE_DESC* init_yehat (void);
 
 				RDPtr = init_yehat ();
 				break;
 			}
 			case ZOQFOT_CODE_RES:
 			{
-				extern RACE_DESCPTR init_zoqfotpik (void);
+				extern RACE_DESC* init_zoqfotpik (void);
 
 				RDPtr = init_zoqfotpik ();
 				break;
 			}
 			case SAMATRA_CODE_RES:
 			{
-				extern RACE_DESCPTR init_samatra (void);
+				extern RACE_DESC* init_samatra (void);
 
 				RDPtr = init_samatra ();
 				break;
 			}
 			case SIS_CODE_RES:
 			{
-				extern RACE_DESCPTR init_sis (void);
+				extern RACE_DESC* init_sis (void);
 
 				RDPtr = init_sis ();
 				break;
 			}
 			case PROBE_CODE_RES:
 			{
-				extern RACE_DESCPTR init_probe (void);
+				extern RACE_DESC* init_probe (void);
 
 				RDPtr = init_probe ();
 				break;
 			}
+			default:
+			{
+				log_add (log_Warning, "Unknown SHIP identifier '%d'", which_res);
+				RDPtr = NULL;
+				break;
+			}
 		}
 
 		if (RDPtr == 0)
 		{
-			mem_release (hData);
+			HFree (hData);
 			hData = 0;
 		}
 		else
 		{
 			CODERES_STRUCT *cs;
 
-			cs = (CODERES_STRUCT *) mem_lock (hData);
-			cs->data = *RDPtr;
-					// Structure assignment.
-			mem_unlock (hData);
+			cs = (CODERES_STRUCT *) hData;
+			cs->data = *RDPtr;  // Structure assignment.
 		}
 	}
-	(void) length;  /* Satisfying compiler (unused parameter) */
-	return (hData);
+	resdata->ptr = (hData);
 }
 
+BOOLEAN
+_ReleaseCodeResData (void *data)
+{
+	HFree (data);
+	return TRUE;
+}
 
 BOOLEAN
-InstallCodeResType (COUNT code_type)
+InstallCodeResType ()
 {
-	return (InstallResTypeVectors (code_type,
-			GetCodeResData, mem_release));
+	return (InstallResTypeVectors ("SHIP",
+			GetCodeResData, _ReleaseCodeResData));
 }
 
 
-MEM_HANDLE
-LoadCodeResInstance (DWORD res)
+void *
+LoadCodeResInstance (RESOURCE res)
 {
-	MEM_HANDLE hData;
+	void *hData;
 
 	hData = res_GetResource (res);
 	if (hData)
@@ -335,53 +337,35 @@ LoadCodeResInstance (DWORD res)
 
 
 BOOLEAN
-DestroyCodeRes (MEM_HANDLE hCode)
+DestroyCodeRes (void *hCode)
 {
-	return (mem_release (hCode));
+	HFree (hCode);
+	return (TRUE);
 }
 
 
-PVOID
-CaptureCodeRes (MEM_HANDLE hCode, PVOID pData, PVOID *ppLocData)
+void*
+CaptureCodeRes (void *hCode, void *pData, void **ppLocData)
 {
 	CODERES_STRUCT *cs;
 
-	if (hCode == 0)
+	if (hCode == NULL)
 	{
-		log_add (log_Fatal, "dummy.c::CaptureCodeRes() hCode==0! FATAL!");
-		return(0);
+		log_add (log_Fatal, "dummy.c::CaptureCodeRes() hCode==NULL! FATAL!");
+		return(NULL);
 	}
 
-	cs = (CODERES_STRUCT *) mem_lock (hCode);
-	cs->handle = hCode;
-	*ppLocData = (void *) &cs->data;
+	cs = (CODERES_STRUCT *) hCode;
+	*ppLocData = &cs->data;
 
 	(void) pData;  /* Satisfying compiler (unused parameter) */
-	return (void *) cs;
+	return cs;
 }
 
 
-MEM_HANDLE
-ReleaseCodeRes (PVOID CodeRef)
+void *
+ReleaseCodeRes (void *CodeRef)
 {
-	if (CodeRef)
-	{
-		MEM_HANDLE hCode;
-
-		mem_unlock (hCode = *(MEM_HANDLE *)CodeRef);
-		return (hCode);
-	}
-
-	return (0);
+	return CodeRef;
 }
 
-DRAWABLE
-CreatePixmapRegion (FRAME Frame, PPOINT lpOrg, SIZE width, SIZE height)
-{
-	(void) lpOrg;  /* Satisfying compiler (unused parameter) */
-	(void) width;  /* Satisfying compiler (unused parameter) */
-	(void) height;  /* Satisfying compiler (unused parameter) */
-	return (GetFrameHandle (Frame));
-}
-
-
diff -ruNp src.orig/sc2code/element.h src/sc2code/element.h
--- src.orig/sc2code/element.h	2017-11-08 16:49:28 -0600
+++ src/sc2code/element.h	2017-11-08 16:49:55 -0600
@@ -41,16 +41,20 @@
 
 #define NORMAL_LIFE 1
 
-typedef QUEUE_HANDLE HELEMENT;
+typedef HLINK HELEMENT;
 
 // Bits for ELEMENT_FLAGS:
 #define GOOD_GUY (1 << 0)
 #define BAD_GUY (1 << 1)
 #define PLAYER_SHIP (1 << 2)
+		// The ELEMENT is a player controlable ship, and not some bullet,
+		// crew, asteroid, fighter, etc. This does not mean that the ship
+		// is actually controlled by a human; it may be a computer.
 
 #define APPEARING (1 << 3)
 #define DISAPPEARING (1 << 4)
 #define CHANGING (1 << 5)
+		// The element's graphical representation has changed.
 
 #define NONSOLID (1 << 6)
 #define COLLISION (1 << 7)
@@ -60,11 +64,17 @@ typedef QUEUE_HANDLE HELEMENT;
 #define FINITE_LIFE (1 << 10)
 
 #define PRE_PROCESS (1 << 11)
+		// PreProcess() is to be called for the ELEMENT.
 #define POST_PROCESS (1 << 12)
 
 #define IGNORE_VELOCITY (1 << 13)
 #define CREW_OBJECT (1 << 14)
 #define BACKGROUND_OBJECT (1 << 15)
+		// The BACKGROUND_OBJECT flag existed originally but wasn't used.
+		// It can now be used for objects that never influence the state
+		// of other elements; elements that have this flag set are not
+		// included in the checksum used for netplay games.
+		// It can be used for graphical mods that don't impede netplay.
 
 
 #define HYPERJUMP_LIFE 15
@@ -90,39 +100,64 @@ typedef struct state
 	struct
 	{
 		FRAME frame;
-		PFRAME farray;
+		FRAME *farray;
 	} image;
 } STATE;
-typedef STATE *PSTATE;
+
+
+typedef struct element ELEMENT;
+
+typedef void (CollisionFunc) (ELEMENT *ElementPtr0, POINT *pPt0,
+			ELEMENT *ElementPtr1, POINT *pPt1);
 
 // Any physical object in the simulation.
-typedef struct element
+struct element
 {
+	// LINK elements; must be first
 	HELEMENT pred, succ;
 
 	void (*preprocess_func) (struct element *ElementPtr);
 	void (*postprocess_func) (struct element *ElementPtr);
-	void (*collision_func) (struct element *ElementPtr0, PPOINT
-			pPt0, struct element *ElementPtr1, PPOINT pPt1);
+	CollisionFunc *collision_func;
 	void (*death_func) (struct element *ElementPtr);
 
 	ELEMENT_FLAGS state_flags;
-	COUNT life_span;
-	COUNT crew_level;
-	BYTE mass_points;
-	BYTE turn_wait, thrust_wait;
+	union
+	{
+		COUNT life_span;
+		COUNT scan_node; /* Planetside: scan type and node id */
+	};
+	union
+	{
+		COUNT crew_level;
+		COUNT hit_points;
+		COUNT facing; /* Planetside: lava-spot direction of travel */
+		COUNT cycle;  /* Planetside: lightning cycle length */
+	};
+	union
+	{
+		BYTE mass_points;
+		BYTE sys_loc; /* IP: location in system */
+	};
+	BYTE turn_wait;
+	union
+	{
+		BYTE thrust_wait;
+		BYTE blast_offset;
+		BYTE next_turn; /* Battle: animation interframe for some elements */
+	};
+
 	VELOCITY_DESC velocity;
 	INTERSECT_CONTROL IntersectControl;
 	COUNT PrimIndex;
 	STATE current, next;
 
-	PVOID pParent;
+	void *pParent;
 			// The ship this element belongs to.
 	HELEMENT hTarget;
-} ELEMENT;
-typedef ELEMENT *PELEMENT;
+};
 
-#define MAX_DISPLAY_PRIMS 280
+#define MAX_DISPLAY_PRIMS 330
 extern COUNT DisplayFreeList;
 extern PRIMITIVE DisplayArray[MAX_DISPLAY_PRIMS];
 
@@ -131,22 +166,22 @@ extern PRIMITIVE DisplayArray[MAX_DISPLA
 #define FreeDisplayPrim(p) SetPrimLinks (&DisplayArray[p], END_OF_LIST, DisplayFreeList); \
 								DisplayFreeList = (p)
 
-#define STATEPTR PSTATE
-#define ELEMENTPTR PELEMENT
-
-#define GetElementStarShip(e,psd) *(psd) = (PVOID)(e)->pParent
-#define SetElementStarShip(e,psd) ((e)->pParent = (PVOID)(psd))
+#define GetElementStarShip(e,ppsd) do { *(ppsd) = (e)->pParent; } while (0)
+#define SetElementStarShip(e,psd)  do { (e)->pParent = psd; } while (0)
 
-#define blast_offset thrust_wait
-#define hit_points crew_level
-#define next_turn thrust_wait
 #define MAX_CREW_SIZE 42
 #define MAX_ENERGY_SIZE 42
 #define MAX_SHIP_MASS 10
 #define GRAVITY_MASS(m) ((m) > MAX_SHIP_MASS * 10)
 #define GRAVITY_THRESHOLD (COUNT)255
 
-#define WHICH_SIDE(f) (((f) & BAD_GUY) >> 1)
+static inline BYTE
+ElementFlagsSide (ELEMENT_FLAGS flags)
+{
+	return (BYTE) ((flags & BAD_GUY) >> 1);
+}
+#define WHICH_SIDE(flags) ElementFlagsSide (flags)
+
 #define OBJECT_CLOAKED(eptr) \
 		(GetPrimType (&GLOBAL (DisplayArray[(eptr)->PrimIndex])) >= NUM_PRIMS \
 		|| (GetPrimType (&GLOBAL (DisplayArray[(eptr)->PrimIndex])) == STAMPFILL_PRIM \
@@ -159,63 +194,70 @@ extern void FreeElement (HELEMENT hEleme
 #define InsertElement(h,i) InsertQueue (&disp_q, h, i)
 #define GetHeadElement() GetHeadLink (&disp_q)
 #define GetTailElement() GetTailLink (&disp_q)
-#define LockElement(h,eptr) *(eptr) = (ELEMENTPTR)LockLink (&disp_q, h)
+#define LockElement(h,ppe) (*(ppe) = (ELEMENT*)LockLink (&disp_q, h))
 #define UnlockElement(h) UnlockLink (&disp_q, h)
 #define GetPredElement(l) _GetPredLink (l)
 #define GetSuccElement(l) _GetSuccLink (l)
 extern void RemoveElement (HLINK hLink);
 
 extern void RedrawQueue (BOOLEAN clear);
-extern BOOLEAN DeltaEnergy (ELEMENTPTR ElementPtr, SIZE
-		energy_delta);
-extern BOOLEAN DeltaCrew (ELEMENTPTR ElementPtr, SIZE
-		crew_delta);
+extern BOOLEAN DeltaEnergy (ELEMENT *ElementPtr, SIZE energy_delta);
+extern BOOLEAN DeltaCrew (ELEMENT *ElementPtr, SIZE crew_delta);
 
-extern void PreProcessStatus (PELEMENT ShipPtr);
-extern void PostProcessStatus (PELEMENT ShipPtr);
+extern void PreProcessStatus (ELEMENT *ShipPtr);
+extern void PostProcessStatus (ELEMENT *ShipPtr);
 
-extern void load_gravity_well (BYTE selector);
-extern void free_gravity_well (void);
 extern void spawn_planet (void);
-extern void spawn_asteroid (PELEMENT ElementPtr);
-extern void animation_preprocess (PELEMENT ElementPtr);
-extern void do_damage (ELEMENTPTR ElementPtr, SIZE
-		damage);
-extern void collision (PELEMENT ElementPtr0, PPOINT pPt0,
-		PELEMENT ElementPtr1, PPOINT pPt1);
-extern void crew_preprocess (PELEMENT ElementPtr);
-extern void crew_collision (PELEMENT ElementPtr0, PPOINT
-		pPt0, PELEMENT ElementPtr1, PPOINT pPt1);
-extern void AbandonShip (ELEMENTPTR ShipPtr, ELEMENTPTR
-		TargetPtr, COUNT crew_loss);
-extern BOOLEAN TimeSpaceMatterConflict (ELEMENTPTR
-		ElementPtr);
-extern COUNT PlotIntercept (ELEMENTPTR ElementPtr0,
-		ELEMENTPTR ElementPtr1, COUNT max_turns, COUNT
-		margin_of_error);
+extern void spawn_asteroid (ELEMENT *ElementPtr);
+extern void animation_preprocess (ELEMENT *ElementPtr);
+extern void do_damage (ELEMENT *ElementPtr, SIZE damage);
+extern void collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1);
+extern void crew_preprocess (ELEMENT *ElementPtr);
+extern void crew_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1);
+extern void AbandonShip (ELEMENT *ShipPtr, ELEMENT *TargetPtr,
+		COUNT crew_loss);
+extern BOOLEAN TimeSpaceMatterConflict (ELEMENT *ElementPtr);
+extern COUNT PlotIntercept (ELEMENT *ElementPtr0,
+		ELEMENT *ElementPtr1, COUNT max_turns, COUNT margin_of_error);
 extern BOOLEAN LoadKernel (int argc, char *argv[]);
 extern void FreeKernel (void);
 
 extern void InitDisplayList (void);
 
 extern void InitGalaxy (void);
-extern void MoveGalaxy (VIEW_STATE view_state, 
-		SIZE dx, SIZE dy);
-extern void ship_preprocess (PELEMENT ElementPtr);
-extern void ship_postprocess (PELEMENT
-		ElementPtr);
-extern void ship_death (PELEMENT ShipPtr);
-extern BOOLEAN hyper_transition (PELEMENT ElementPtr);
-
-extern BOOLEAN CalculateGravity (PELEMENT ElementPtr);
-extern UWORD inertial_thrust (ELEMENTPTR ElementPtr);
-extern void SetUpElement (ELEMENTPTR
-		ElementPtr);
+extern void MoveGalaxy (VIEW_STATE view_state, SIZE dx, SIZE dy);
+extern void ship_preprocess (ELEMENT *ElementPtr);
+extern void ship_postprocess (ELEMENT *ElementPtr);
+extern void ship_death (ELEMENT *ShipPtr);
+extern BOOLEAN hyper_transition (ELEMENT *ElementPtr);
+
+extern BOOLEAN CalculateGravity (ELEMENT *ElementPtr);
+extern void SetUpElement (ELEMENT *ElementPtr);
 
 extern void BattleSong (BOOLEAN DoPlay);
 extern void FreeBattleSong (void);
 
 extern void InsertPrim (PRIM_LINKS *pLinks, COUNT primIndex, COUNT iPI);
 
+
+typedef UWORD STATUS_FLAGS;
+
+/* STATUS_FLAGS - heat of battle specific flags */
+#define LEFT                   (1 << 0)
+#define RIGHT                  (1 << 1)
+#define THRUST                 (1 << 2)
+#define WEAPON                 (1 << 3)
+#define SPECIAL                (1 << 4)
+#define LOW_ON_ENERGY          (1 << 5)
+#define SHIP_BEYOND_MAX_SPEED  (1 << 6)
+#define SHIP_AT_MAX_SPEED      (1 << 7)
+#define SHIP_IN_GRAVITY_WELL   (1 << 8)
+#define PLAY_VICTORY_DITTY     (1 << 9)
+
+extern STATUS_FLAGS inertial_thrust (ELEMENT *ElementPtr);
+
+
 #endif /* _ELEMENT_H */
 
diff -ruNp src.orig/sc2code/encount.c src/sc2code/encount.c
--- src.orig/sc2code/encount.c	2017-11-08 16:49:28 -0600
+++ src/sc2code/encount.c	2017-11-08 16:49:55 -0600
@@ -19,8 +19,10 @@
 #include "encount.h"
 
 #include "battle.h"
+#include "battlecontrols.h"
 #include "build.h"
 #include "colors.h"
+#include "cons_res.h"
 #include "controls.h"
 #include "gameopt.h"
 #include "gamestr.h"
@@ -38,11 +40,11 @@
 
 
 static void DrawFadeText (const UNICODE *str1, const UNICODE *str2,
-		BOOLEAN fade_in, PRECT pRect);
+		BOOLEAN fade_in, RECT *pRect);
 
 
 static BOOLEAN
-DoSelectAction (PMENU_STATE pMS)
+DoSelectAction (MENU_STATE *pMS)
 {
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
 	if (GLOBAL (CurrentActivity) & CHECK_ABORT)
@@ -82,13 +84,14 @@ DoSelectAction (PMENU_STATE pMS)
 	return (TRUE);
 }
 
+// Called by comm code to intialize battle fleets during encounter
 void
 BuildBattle (COUNT which_player)
 {
-	PQUEUE pQueue;
-	HSTARSHIP hStarShip, hNextShip;
+	QUEUE *pQueue;
+	HSHIPFRAG hStarShip, hNextShip;
 	HSTARSHIP hBuiltShip;
-	STARSHIPPTR BuiltShipPtr;
+	STARSHIP *BuiltShipPtr;
 
 	EncounterRace = -1;
 
@@ -123,44 +126,52 @@ BuildBattle (COUNT which_player)
 	for (hStarShip = GetHeadLink (pQueue);
 			hStarShip != 0; hStarShip = hNextShip)
 	{
-		SHIP_FRAGMENTPTR FragPtr;
+		SHIP_FRAGMENT *FragPtr;
 
-		FragPtr = (SHIP_FRAGMENTPTR)LockStarShip (pQueue, hStarShip);
+		FragPtr = LockShipFrag (pQueue, hStarShip);
 		hNextShip = _GetSuccLink (FragPtr);
 
 		hBuiltShip = Build (&race_q[which_player],
-				GET_RACE_ID (FragPtr) == SAMATRA_SHIP ?
-				SAMATRA_RES_INDEX : FragPtr->RaceResIndex,
-				1 << which_player, StarShipCaptain (FragPtr));
+				FragPtr->race_id == SAMATRA_SHIP ?
+					SA_MATRA_ID : FragPtr->SpeciesID);
 		if (hBuiltShip)
 		{
 			BuiltShipPtr = LockStarShip (&race_q[which_player], hBuiltShip);
-			BuiltShipPtr->captains_name_index =
-					StarShipCaptain (BuiltShipPtr);
-			BuiltShipPtr->cur_status_flags =
-					StarShipPlayer (BuiltShipPtr);
-			if (FragPtr->ShipInfo.crew_level != INFINITE_FLEET)
-				BuiltShipPtr->special_counter = FragPtr->ShipInfo.crew_level;
+			BuiltShipPtr->captains_name_index = FragPtr->captains_name_index;
+			BuiltShipPtr->which_side = 1 << which_player;
+			if (FragPtr->crew_level != INFINITE_FLEET)
+				BuiltShipPtr->crew_level = FragPtr->crew_level;
 			else /* if infinite ships */
-				BuiltShipPtr->special_counter = FragPtr->ShipInfo.max_crew;
-			BuiltShipPtr->RaceDescPtr = (RACE_DESCPTR)&FragPtr->ShipInfo;
+				BuiltShipPtr->crew_level = FragPtr->max_crew;
+			BuiltShipPtr->max_crew = FragPtr->max_crew;
+			BuiltShipPtr->race_strings = FragPtr->race_strings;
+			BuiltShipPtr->icons = FragPtr->icons;
+			BuiltShipPtr->index = FragPtr->index;
+			BuiltShipPtr->ship_cost = 0;
+			BuiltShipPtr->RaceDescPtr = 0;
 
 			UnlockStarShip (&race_q[which_player], hBuiltShip);
 		}
 
-		UnlockStarShip (pQueue, hStarShip);
+		UnlockShipFrag (pQueue, hStarShip);
 	}
 
 	if (which_player == 0
-			&& (hBuiltShip = Build (&race_q[0], SIS_RES_INDEX, GOOD_GUY, 0)))
+			&& (hBuiltShip = Build (&race_q[0], SIS_SHIP_ID)))
 	{
 		BuiltShipPtr = LockStarShip (&race_q[0], hBuiltShip);
-		BuiltShipPtr->captains_name_index = StarShipCaptain (BuiltShipPtr);
-		BuiltShipPtr->cur_status_flags = StarShipPlayer (BuiltShipPtr);
-		BuiltShipPtr->special_counter = 0;
+		BuiltShipPtr->captains_name_index = 0;
+		BuiltShipPtr->which_side = GOOD_GUY;
+		BuiltShipPtr->crew_level = 0;
+		BuiltShipPtr->max_crew = 0;
 				// Crew will be copied directly from
 				// GLOBAL_SIS (CrewEnlisted) later.
+		BuiltShipPtr->race_strings = 0;
+		BuiltShipPtr->icons = 0;
+		BuiltShipPtr->index = -1;
+		BuiltShipPtr->ship_cost = 0;
 		BuiltShipPtr->energy_counter = MAX_ENERGY_SIZE;
+		BuiltShipPtr->RaceDescPtr = 0;
 		UnlockStarShip (&race_q[0], hBuiltShip);
 	}
 }
@@ -175,7 +186,6 @@ COUNT
 InitEncounter (void)
 {
 	COUNT i;
-	MEM_HANDLE hOldIndex;
 	FRAME SegueFrame;
 	STAMP s;
 	TEXT t;
@@ -184,8 +194,6 @@ InitEncounter (void)
 
 	LockMutex (GraphicsLock);
 
-	hOldIndex = SetResourceIndex (hResIndex);
-
 	SetContext (SpaceContext);
 	SetContextFont (TinyFont);
 
@@ -219,10 +227,12 @@ InitEncounter (void)
 	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
 	{
 		t.pStr = GAME_STRING (ENCOUNTER_STRING_BASE + 0);
+				// "ENCOUNTER IN"
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
 		t.baseline.y += 12;
 		t.pStr = GAME_STRING (ENCOUNTER_STRING_BASE + 1);
+				// "DEEP SPACE"
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
 	}
@@ -231,6 +241,7 @@ InitEncounter (void)
 		UNICODE buf[256];
 
 		t.pStr = GAME_STRING (ENCOUNTER_STRING_BASE + 2);
+				// "ENCOUNTER AT"
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
 		t.baseline.y += 12;
@@ -252,7 +263,7 @@ InitEncounter (void)
 	if (LOBYTE (GLOBAL (CurrentActivity)) != IN_LAST_BATTLE)
 	{
 #define NUM_DISPLAY_PTS (sizeof (display_pt) / sizeof (display_pt[0]))
-		HSTARSHIP hStarShip, hNextShip;
+		HSHIPFRAG hStarShip, hNextShip;
 		POINT display_pt[] =
 		{
 			{ 10,  51},
@@ -267,16 +278,15 @@ InitEncounter (void)
 			{-44, -27},
 		};
 
-		for (hStarShip = GetHeadLink (&race_q[1]), i = 0;
+		for (hStarShip = GetHeadLink (&GLOBAL (npc_built_ship_q)), i = 0;
 				hStarShip && i < 60; hStarShip = hNextShip, ++i)
 		{
 			RECT r;
-			STARSHIPPTR StarShipPtr;
+			SHIP_FRAGMENT *FragPtr;
 
-			StarShipPtr = LockStarShip (&race_q[1], hStarShip);
-			if (StarShipPtr->RaceDescPtr->ship_info.crew_level !=
-					INFINITE_FLEET)
-				hNextShip = _GetSuccLink (StarShipPtr);
+			FragPtr = LockShipFrag (&GLOBAL (npc_built_ship_q), hStarShip);
+			if (FragPtr->crew_level != INFINITE_FLEET)
+				hNextShip = _GetSuccLink (FragPtr);
 			else /* if infinite ships */
 				hNextShip = hStarShip;
 
@@ -293,14 +303,13 @@ InitEncounter (void)
 				s.origin.x = COSINE (angle, radius);
 				s.origin.y = SINE (angle, radius);
 			}
-			s.frame = SetAbsFrameIndex (
-					StarShipPtr->RaceDescPtr->ship_info.icons, 0);
+			s.frame = SetAbsFrameIndex (FragPtr->icons, 0);
 			GetFrameRect (s.frame, &r);
 			s.origin.x += (SIS_SCREEN_WIDTH >> 1) - (r.extent.width >> 1);
 			s.origin.y += (SIS_SCREEN_HEIGHT >> 1) - (r.extent.height >> 1);
 			DrawStamp (&s);
 
-			UnlockStarShip (&race_q[1], hStarShip);
+			UnlockShipFrag (&GLOBAL (npc_built_ship_q), hStarShip);
 		}
 	}
 
@@ -308,8 +317,6 @@ InitEncounter (void)
 	DestroyDrawable (ReleaseDrawable (SegueFrame));
 	ScreenTransition (3, NULL);
 
-	SetResourceIndex (hOldIndex);
-
 	UnlockMutex (GraphicsLock);
 
 	{
@@ -323,10 +330,10 @@ InitEncounter (void)
 		SetFlashRect (SFR_MENU_3DO, (FRAME)0);
 		UnlockMutex (GraphicsLock);
 
-		DoInput ((PVOID)&MenuState, TRUE);
+		DoInput (&MenuState, TRUE);
 
 		LockMutex (GraphicsLock);
-		SetFlashRect (NULL_PTR, (FRAME)0);
+		SetFlashRect (NULL, (FRAME)0);
 		UnlockMutex (GraphicsLock);
 
 		return (MenuState.CurState);
@@ -335,7 +342,7 @@ InitEncounter (void)
 
 static void
 DrawFadeText (const UNICODE *str1, const UNICODE *str2, BOOLEAN fade_in,
-		PRECT pRect)
+		RECT *pRect)
 {
 	SIZE i;
 	DWORD TimeIn;
@@ -435,8 +442,8 @@ UninitEncounter (void)
 		const UNICODE *str1 = NULL;
 		const UNICODE *str2 = NULL;
 		UNICODE buf[80];
-		HSTARSHIP hStarShip;
-		SHIP_FRAGMENTPTR FragPtr;
+		HSHIPFRAG hStarShip;
+		SHIP_FRAGMENT *FragPtr;
 		static const COLOR fade_ship_cycle[] =
 		{
 			BUILD_COLOR (MAKE_RGB15 (0x07, 0x00, 0x00), 0x2F),
@@ -462,26 +469,26 @@ UninitEncounter (void)
 		SET_GAME_STATE (BOMB_CARRIER, 0);
 
 		VictoryState = (
-				HIBYTE (battle_counter) || !LOBYTE (battle_counter)
+				battle_counter[1] || !battle_counter[0]
 				|| GET_GAME_STATE (URQUAN_PROTECTING_SAMATRA)
 				) ? 0 : 1;
 
 		hStarShip = GetHeadLink (&GLOBAL (npc_built_ship_q));
-		FragPtr = (SHIP_FRAGMENTPTR)LockStarShip (&GLOBAL (npc_built_ship_q),
-				hStarShip);
-		EncounterRace = GET_RACE_ID (FragPtr);
+		FragPtr = LockShipFrag (&GLOBAL (npc_built_ship_q), hStarShip);
+		EncounterRace = FragPtr->race_id;
 		if (GetStarShipFromIndex (&GLOBAL (avail_race_q), EncounterRace) == 0)
 		{
+			/* Suppress the final tally and salvage info */
 			VictoryState = -1;
 			InitSISContexts ();
 		}
-		UnlockStarShip (&GLOBAL (npc_built_ship_q), hStarShip);
+		UnlockShipFrag (&GLOBAL (npc_built_ship_q), hStarShip);
 
 		Sleepy = TRUE;
 		for (i = 0; i < NUM_SIDES; ++i)
 		{
-			PQUEUE pQueue;
-			HSTARSHIP hNextShip;
+			QUEUE *pQueue;
+			HSHIPFRAG hNextShip;
 
 			if (i == 0)
 				pQueue = &GLOBAL (built_ship_q);
@@ -492,7 +499,7 @@ UninitEncounter (void)
 				else
 				{
 					DrawSISFrame ();
-					DrawSISMessage (NULL_PTR);
+					DrawSISMessage (NULL);
 					if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
 						DrawHyperCoords (GLOBAL (ShipStamp.origin));
 					else if (HIWORD (GLOBAL (ShipStamp.frame)) == 0)
@@ -512,10 +519,10 @@ UninitEncounter (void)
 			for (hStarShip = GetHeadLink (pQueue); hStarShip;
 					hStarShip = hNextShip)
 			{
-				FragPtr = (SHIP_FRAGMENTPTR)LockStarShip (pQueue, hStarShip);
+				FragPtr = LockShipFrag (pQueue, hStarShip);
 				hNextShip = _GetSuccLink (FragPtr);
 
-				if (FragPtr->ShipInfo.crew_level == 0
+				if (FragPtr->crew_level == 0
 						|| (VictoryState && i == NUM_SIDES - 1))
 				{
 					if (i == NUM_SIDES - 1)
@@ -534,15 +541,13 @@ UninitEncounter (void)
 								
 								ship_s.origin.x = scavenge_r.corner.x + 32;
 								ship_s.origin.y = scavenge_r.corner.y + 56;
-								ship_s.frame = IncFrameIndex (
-										FragPtr->ShipInfo.icons);
+								ship_s.frame = IncFrameIndex (FragPtr->icons);
 								DrawStamp (&ship_s);
 								SetContextForeGroundColor (
 										BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
 								SetContextFont (TinyFont);
 
-								GetStringContents (
-										FragPtr->ShipInfo.race_strings,
+								GetStringContents (FragPtr->race_strings,
 										(STRINGPTR)buf, FALSE);
 								// XXX: this will not work with UTF-8 strings
 								strupr (buf);
@@ -556,16 +561,19 @@ UninitEncounter (void)
 								t.baseline.y += 6;
 								t.pStr = GAME_STRING (
 										ENCOUNTER_STRING_BASE + 3);
+										// "BATTLE GROUP"
 								t.CharCount = (COUNT)~0;
 								font_DrawText (&t);
 
-								ship_s.frame = FragPtr->ShipInfo.icons;
+								ship_s.frame = FragPtr->icons;
 
 								SetContextFont (MicroFont);
 								str1 = GAME_STRING (
 										ENCOUNTER_STRING_BASE + 4);
+										// "Enemy Ships"
 								str2 = GAME_STRING (
 										ENCOUNTER_STRING_BASE + 5),
+										// "Destroyed"
 								DrawFadeText (str1, str2, TRUE, &scavenge_r);
 							}
 
@@ -630,14 +638,14 @@ UninitEncounter (void)
 						}
 					}
 
-					UnlockStarShip (pQueue, hStarShip);
+					UnlockShipFrag (pQueue, hStarShip);
 					RemoveQueue (pQueue, hStarShip);
-					FreeStarShip (pQueue, hStarShip);
+					FreeShipFrag (pQueue, hStarShip);
 
 					continue;
 				}
 
-				UnlockStarShip (pQueue, hStarShip);
+				UnlockShipFrag (pQueue, hStarShip);
 			}
 		}
 
@@ -653,10 +661,10 @@ UninitEncounter (void)
 			while (!(AnyButtonPress (TRUE)) && GetTimeCounter () < Time)
 				TaskSwitch ();
 			LockMutex (GraphicsLock);
-			if (!CurrentInputState.key[PlayerOne][KEY_ESCAPE])
+			if (!CurrentInputState.key[PlayerControls[0]][KEY_ESCAPE])
 			{
 				DrawFadeText (str1, str2, FALSE, &scavenge_r);
-				if (!CurrentInputState.key[PlayerOne][KEY_ESCAPE])
+				if (!CurrentInputState.key[PlayerControls[0]][KEY_ESCAPE])
 				{
 					SetContextForeGroundColor (BLACK_COLOR);
 					r.corner.x = scavenge_r.corner.x + 10;
@@ -674,7 +682,9 @@ UninitEncounter (void)
 					font_DrawText (&t);
 
 					str1 = GAME_STRING (ENCOUNTER_STRING_BASE + 6);
+							// "Debris"
 					str2 = GAME_STRING (ENCOUNTER_STRING_BASE + 7);
+							// "Scavenged"
 					DrawFadeText (str1, str2, TRUE, &scavenge_r);
 					Time = GetTimeCounter () + ONE_SECOND * 2;
 					UnlockMutex (GraphicsLock);
@@ -682,12 +692,12 @@ UninitEncounter (void)
 							&& GetTimeCounter () < Time)
 						TaskSwitch ();
 					LockMutex (GraphicsLock);
-					if (!CurrentInputState.key[PlayerOne][KEY_ESCAPE])
+					if (!CurrentInputState.key[PlayerControls[0]][KEY_ESCAPE])
 						DrawFadeText (str1, str2, FALSE, &scavenge_r);
 				}
 			}
 
-			DrawStatusMessage (NULL_PTR);
+			DrawStatusMessage (NULL);
 		}
 
 		if (ships_killed && EncounterRace == THRADDASH_SHIP
@@ -708,16 +718,14 @@ ExitUninitEncounter:
 void
 EncounterBattle (void)
 {
-	MEM_HANDLE hLastIndex;
 	ACTIVITY OldActivity;
 	extern UWORD nth_frame;
+	InputContext *savedPlayerInput;
 
 	LockMutex (GraphicsLock);
 
 	SET_GAME_STATE (BATTLE_SEGUE, 1);
 
-	hLastIndex = SetResourceIndex (hResIndex);
-
 	OldActivity = GLOBAL (CurrentActivity);
 	if (LOBYTE (OldActivity) == IN_LAST_BATTLE)
 		GLOBAL (CurrentActivity) = MAKE_WORD (IN_LAST_BATTLE, 0);
@@ -743,7 +751,9 @@ EncounterBattle (void)
 			cur_speed = (BYTE)~0; /* maximum speed - no rendering */
 		nth_frame = MAKE_WORD (1, cur_speed);
 		PlayerControl[0] = CYBORG_CONTROL | AWESOME_RATING;
-		PlayerInput[0] = ComputerInput;
+		savedPlayerInput = PlayerInput[0];
+		PlayerInput[0] = NULL;
+		SetPlayerInput (0);
 	}
 
 	GameSounds = CaptureSound (LoadSound (GAME_SOUNDS));
@@ -762,10 +772,10 @@ EncounterBattle (void)
 	{
 		nth_frame = MAKE_WORD (0, 0);
 		PlayerControl[0] = HUMAN_CONTROL | STANDARD_RATING;
-		PlayerInput[0] = HumanInput[0];
+		ClearPlayerInput (0);
+		PlayerInput[0] = savedPlayerInput;
 	}
 
-	SetResourceIndex (hResIndex);
 //    MicroFont = CaptureFont (
 // LoadFont (MICRO_FONT)
 // );
@@ -774,8 +784,6 @@ EncounterBattle (void)
 
 	GLOBAL (CurrentActivity) = OldActivity;
 
-	SetResourceIndex (hLastIndex);
-
 	UnlockMutex (GraphicsLock);
 }
 
diff -ruNp src.orig/sc2code/encount.h src/sc2code/encount.h
--- src.orig/sc2code/encount.h	2017-11-08 16:49:28 -0600
+++ src/sc2code/encount.h	2017-11-08 16:49:55 -0600
@@ -19,13 +19,14 @@
 #ifndef _ENCOUNT_H
 #define _ENCOUNT_H
 
+#include "commglue.h"
 #include "displist.h"
 #include "libs/gfxlib.h"
 #include "planets/planets.h"
 #include "races.h"
 
 
-typedef QUEUE_HANDLE HENCOUNTER;
+typedef HLINK HENCOUNTER;
 
 #define MAX_HYPER_SHIPS 7
 #define ONE_SHOT_ENCOUNTER (1 << 7)
@@ -33,14 +34,17 @@ typedef QUEUE_HANDLE HENCOUNTER;
 
 typedef struct
 {
-	POINT star_pt;
-	BYTE Type, Index;
-	SHIP_INFO ShipList[MAX_HYPER_SHIPS];
-} EXTENDED_STAR_DESC;
-typedef EXTENDED_STAR_DESC *PEXTENDED_STAR_DESC;
+	// The only field actually used right now is crew_level
+	BYTE race_id;
+	COUNT crew_level;
+	COUNT max_crew;
+	BYTE max_energy;
+
+} BRIEF_SHIP_INFO;
 
 typedef struct
 {
+	// LINK elements; must be first
 	HENCOUNTER pred, succ;
 
 	HELEMENT hElement;
@@ -49,26 +53,24 @@ typedef struct
 	POINT origin;
 	COUNT radius;
 
-	EXTENDED_STAR_DESC SD;
+	STAR_DESC SD;
+	BRIEF_SHIP_INFO ShipList[MAX_HYPER_SHIPS];
 
 	SDWORD log_x, log_y;
 } ENCOUNTER;
-typedef ENCOUNTER *PENCOUNTER;
 
 #define AllocEncounter() AllocLink (&GLOBAL (encounter_q))
 #define PutEncounter(h) PutQueue (&GLOBAL (encounter_q), h)
 #define InsertEncounter(h,i) InsertQueue (&GLOBAL (encounter_q), h, i)
 #define GetHeadEncounter() GetHeadLink (&GLOBAL (encounter_q))
 #define GetTailEncounter() GetTailLink (&GLOBAL (encounter_q))
-#define LockEncounter(h,eptr) *(eptr) = (ENCOUNTERPTR)LockLink (&GLOBAL (encounter_q), h)
+#define LockEncounter(h,ppe) (*(ppe) = (ENCOUNTER*)LockLink (&GLOBAL (encounter_q), h))
 #define UnlockEncounter(h) UnlockLink (&GLOBAL (encounter_q), h)
 #define RemoveEncounter(h) RemoveQueue (&GLOBAL (encounter_q), h)
 #define FreeEncounter(h) FreeLink (&GLOBAL (encounter_q), h)
 #define GetPredEncounter(l) _GetPredLink (l)
 #define GetSuccEncounter(l) _GetSuccLink (l)
 
-#define ENCOUNTERPTR PENCOUNTER
-
 enum
 {
 	SOL_DEFINED = 1,
@@ -117,7 +119,12 @@ enum
 	RAINBOW_DEFINED,
 	ILWRATH_DEFINED,
 	ANDROSYNTH_DEFINED,
-	MYCON_TRAP_DEFINED
+	MYCON_TRAP_DEFINED,
+	URQUAN_DEFINED,
+	KOHRAH_DEFINED,
+	NEGLECTED_STARBASE_DEFINED,
+	MOTHER_ARK_DEFINED,
+	ZOQ_COLONY_DEFINED
 };
 
 #define UMGAH_DEFINED TALKING_PET_DEFINED
@@ -126,15 +133,15 @@ enum
 #define TEXT_Y_OFFS 1
 #define SIS_TEXT_WIDTH (SIS_SCREEN_WIDTH - (TEXT_X_OFFS << 1))
 
-extern STAR_DESCPTR CurStarDescPtr;
-extern STAR_DESCPTR star_array;
+extern STAR_DESC *CurStarDescPtr;
+extern STAR_DESC *star_array;
 
 #define NUM_SOLAR_SYSTEMS 502
 
-extern STAR_DESCPTR FindStar (STAR_DESCPTR pLastStar, PPOINT puniverse,
+extern STAR_DESC* FindStar (STAR_DESC *pLastStar, POINT *puniverse,
 		SIZE xbounds, SIZE ybounds);
 
-extern void GetClusterName (STAR_DESCPTR pSD, UNICODE buf[]);
+extern void GetClusterName (const STAR_DESC *pSD, UNICODE buf[]);
 
 enum
 {
@@ -147,7 +154,7 @@ extern void EncounterBattle (void);
 extern void BuildBattle (COUNT which_player);
 extern COUNT InitEncounter (void);
 extern COUNT UninitEncounter (void);
-extern COUNT InitCommunication (RESOURCE which_comm);
+extern COUNT InitCommunication (CONVERSATION which_comm);
 extern void RaceCommunication (void);
 
 extern void GenerateSOL (BYTE control);
@@ -175,6 +182,11 @@ extern void GeneratePkunk (BYTE control)
 extern void GenerateSupox (BYTE control);
 extern void GenerateRainbow (BYTE control);
 extern void GenerateIlwrath (BYTE control);
+extern void GenerateNeglectedStarbase (BYTE control);
+extern void GenerateMotherArk (BYTE control);
+extern void GeneratePrecursorStarbase (BYTE control);
+extern void GenerateUrQuan (BYTE control);
+extern void GenerateKohrAh (BYTE control);
 
 extern SIZE EncounterRace;
 extern BYTE EncounterGroup;
diff -ruNp src.orig/sc2code/flash.c src/sc2code/flash.c
--- src.orig/sc2code/flash.c	1969-12-31 18:00:00 -0600
+++ src/sc2code/flash.c	2017-11-08 16:49:55 -0600
@@ -0,0 +1,722 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+// NOTE: A lot of this code is untested. Only highlite flash areas drawing
+//       directly to the screen, using a cache are currently in use.
+
+// TODO:
+// - Add Flash_setHighlight() to change the brightness as in
+//   Flash_createHighlight(), for an already created flash area.
+// - Add Flash_setOverlay() to change the overlay frame as in
+//   Flash_createOverlay(), for an already created flash area.
+
+
+#define FLASH_INTERNAL
+#include "flash.h"
+
+#include "setup.h"
+#include "libs/log.h"
+#include "libs/misc.h"
+#include "libs/threadlib.h"
+
+
+extern void arith_frame_blit (FRAME srcFrame, const RECT *rsrc,
+		FRAME dstFrame, const RECT *rdst, int num, int denom);
+
+static FlashContext *Flash_create (CONTEXT gfxContext, FRAME parent);
+static void Flash_fixState (FlashContext *context);
+static void Flash_nextState (FlashContext *context);
+static void Flash_clearCache (FlashContext *context);
+static void Flash_initCache (FlashContext *context);
+static void Flash_grabOriginal (FlashContext *context);
+static void Flash_blendFraction (FlashContext *context, int numer, int denom,
+		int *resNumer, int *resDenom);
+static void Flash_makeFrame (FlashContext *context,
+		FRAME dest, RECT *destRect, int numer, int denom);
+static inline void Flash_prepareCacheFrame (FlashContext *context,
+		COUNT index);
+static void Flash_drawFrame (FlashContext *context, FRAME frame);
+static void Flash_drawCacheFrame (FlashContext *context, COUNT index);
+static inline void Flash_drawUncachedFrame (FlashContext *context,
+		int numer, int denom);
+static inline void Flash_drawCachedFrame (FlashContext *context,
+		int numer, int denom);
+static void Flash_drawCurrentFrame (FlashContext *context);
+
+static FlashContext *
+Flash_create (CONTEXT gfxContext, FRAME parent)
+{
+	FlashContext *context = HMalloc (sizeof (FlashContext));
+
+	context->gfxContext     = gfxContext;
+	context->parent         = parent;
+
+	context->original       = 0;
+
+	context->fadeInTime     = Flash_DEFAULT_FADE_IN_TIME;
+	context->onTime         = Flash_DEFAULT_ON_TIME;
+	context->fadeOutTime    = Flash_DEFAULT_FADE_OUT_TIME;
+	context->offTime        = Flash_DEFAULT_OFF_TIME;
+
+	context->frameTime      = 0;
+
+	context->state          = FlashState_off;
+	context->lastStateTime  = 0;
+	context->lastFrameTime  = 0;
+	
+	context->started        = false;
+	context->paused         = false;
+
+	context->cache          = 0;
+	context->cacheSize      = Flash_DEFAULT_CACHE_SIZE;
+	
+	context->lastFrameIndex = (COUNT) -1;
+	
+	return context;
+}
+
+// 'startNumer / denom' is the brightness in the start state of the flash.
+// 'endNumer / denom' is the brightness in the end state of the flash.
+// These numbers are relative to the brighness of the original image.
+FlashContext *
+Flash_createHighlight (CONTEXT gfxContext, FRAME parent, const RECT *rect,
+		int startNumer, int endNumer, int denom)
+{
+	FlashContext *context = Flash_create (gfxContext, parent);
+
+	if (rect == NULL)
+	{
+		// No rectangle specified. Should be later with Flash_setRect()
+		// before calling Flash_start().
+		context->rect.corner.x = 0;
+		context->rect.corner.y = 0;
+		context->rect.extent.width = 0;
+		context->rect.extent.height = 0;
+	}
+	else
+		context->rect = *rect;
+	context->type = FlashType_highlight;
+
+	context->u.highlight.startNumer = startNumer;
+	context->u.highlight.endNumer = endNumer;
+	context->u.highlight.denom = denom;
+
+	return context;
+}
+
+FlashContext *
+Flash_createTransition (CONTEXT gfxContext, FRAME parent,
+		const POINT *origin, FRAME first, FRAME final)
+{
+	FlashContext *context = Flash_create (gfxContext, parent);
+	
+	context->type = FlashType_transition;
+
+	context->u.transition.first = first;
+	context->u.transition.final = final;
+	GetFrameRect (final, &context->rect);
+	context->rect.corner = *origin;
+	
+	return context;
+}
+
+FlashContext *
+Flash_createOverlay (CONTEXT gfxContext, FRAME parent,
+		const POINT *origin, FRAME overlay)
+{
+	FlashContext *context = Flash_create (gfxContext, parent);
+	
+	context->type = FlashType_overlay;
+
+	context->u.overlay.frame = overlay;
+	GetFrameRect (overlay, &context->rect);
+	context->rect.corner = *origin;
+	
+	return context;
+}
+
+void
+Flash_setState (FlashContext *context, FlashState state)
+{
+	TimeCount now;
+	
+	now = GetTimeCounter ();
+
+	context->state = state;
+	Flash_fixState (context);
+	Flash_drawCurrentFrame (context);
+	
+	context->lastStateTime = now;
+	context->lastFrameTime = now;
+}
+
+void
+Flash_start (FlashContext *context)
+{
+	if (context->started)
+	{
+		log_add (log_Warning, "Flash_start() called on already started "
+				"FlashContext.\n");
+		return;
+	}
+	
+	Flash_initCache (context);
+
+	context->started = true;
+	context->paused = false;
+
+	Flash_grabOriginal (context);
+	context->lastFrameIndex = 0;
+
+	Flash_fixState (context);
+	Flash_drawCurrentFrame (context);
+}
+
+void
+Flash_terminate (FlashContext *context)
+{
+	if (context->started)
+	{
+		// Restore the flash rectangle:
+		Flash_drawFrame (context, context->original);
+
+		Flash_clearCache (context);
+		DestroyDrawable (ReleaseDrawable (context->original));
+	}
+
+	HFree (context);
+}
+
+void
+Flash_pause (FlashContext *context)
+{
+	context->paused = true;
+}
+
+void
+Flash_continue (FlashContext *context)
+{
+	context->paused = false;
+}
+
+// Change the state to the next state as long as the current state has
+// a zero-time duration.
+static void
+Flash_fixState (FlashContext *context)
+{
+	TimeCount stateTime;
+	
+	for (;;) {
+		switch (context->state) {
+			case FlashState_fadeIn:
+				stateTime = context->fadeInTime;
+				break;
+			case FlashState_on:
+				stateTime = context->onTime;
+				break;
+			case FlashState_fadeOut:
+				stateTime = context->fadeOutTime;
+				break;
+			case FlashState_off:
+				stateTime = context->offTime;
+				break;
+		}
+		if (stateTime != 0)
+			break;
+		context->state = (context->state + 1) & 0x3;
+	}
+}
+
+static void
+Flash_nextState (FlashContext *context)
+{
+	context->state = (context->state + 1) & 0x3;
+	Flash_fixState (context);
+}
+
+void
+Flash_process (FlashContext *context)
+{
+	TimeCount now;
+
+	if (!context->started || context->paused)
+		return;
+	
+	now = GetTimeCounter ();
+
+	if (context->state == FlashState_fadeIn)
+	{
+		if (now >= context->lastStateTime + context->fadeInTime)
+		{
+			Flash_nextState (context);
+			context->lastStateTime = now;
+		}
+		context->lastFrameTime = now;
+	}
+	else if (context->state == FlashState_on)
+	{
+		if (now < context->lastStateTime + context->onTime)
+			return;
+		Flash_nextState (context);
+		context->lastStateTime = now;
+	}
+	else if (context->state == FlashState_fadeOut)
+	{
+		if (now >= context->lastStateTime + context->fadeOutTime)
+		{
+			Flash_nextState (context);
+			context->lastStateTime = now;
+		}
+		context->lastFrameTime = now;
+	}
+	else /* context->state == FlashState_off */
+	{
+		if (now < context->lastStateTime + context->offTime)
+			return;
+		Flash_nextState (context);
+		context->lastStateTime = now;
+	}
+
+	Flash_drawCurrentFrame (context);
+}
+
+void
+Flash_setSpeed (FlashContext *context, TimeCount fadeInTime,
+		TimeCount onTime, TimeCount fadeOutTime, TimeCount offTime)
+{
+	context->fadeInTime = fadeInTime;
+	context->onTime = onTime;
+	context->fadeOutTime = fadeOutTime;
+	context->offTime = offTime;
+}
+
+// Set the time between updates of the flash area.
+void
+Flash_setFrameTime (FlashContext *context, TimeCount frameTime) {
+	context->frameTime = frameTime;
+}
+
+// Returns the time when the flash area is to be updated.
+TimeCount
+Flash_nextTime (FlashContext *context)
+{
+	if (!context->started || context->paused)
+		return (TimeCount) -1;
+
+	if (context->state == FlashState_fadeIn ||
+			context->state == FlashState_fadeOut)
+	{
+		// When we're fading in or out, we need updates during
+		// the fade.
+		return context->lastFrameTime + context->frameTime;
+	}
+	else
+	{
+		// When the flash area is completely on or off, we don't
+		// need an update until we're ready to change state again.
+		if (context->state == FlashState_on)
+			return context->lastStateTime + context->onTime;
+		else /* context->state == FlashState_off */
+			return context->lastStateTime + context->offTime;
+	}
+}
+
+static void
+Flash_clearCache (FlashContext *context)
+{
+	COUNT i;
+
+	if (context->type == FlashType_transition ||
+			context->type == FlashType_overlay)
+	{
+		// First frame is not allocated by the flash code, so
+		// we shouldn't free it.
+		context->cache[0] = (FRAME) 0;
+	}
+	if (context->type == FlashType_transition)
+	{
+		// Final frame is not allocated by the flash code, so
+		// we shouldn't free it.
+		context->cache[context->cacheSize - 1] = (FRAME) 0;
+	}
+	
+	for (i = 0; i < context->cacheSize; i++)
+	{
+		if (context->cache[i] != (FRAME) 0)
+		{
+			DestroyDrawable (ReleaseDrawable (context->cache[i]));
+			context->cache[i] = (FRAME) 0;
+		}
+	}
+}
+
+void
+Flash_setRect (FlashContext *context, const RECT *rect)
+{
+	if (context->started)
+	{
+		Flash_drawFrame (context, context->original);
+		Flash_clearCache (context);
+	}
+
+	context->rect = *rect;
+	context->lastFrameIndex = (COUNT) -1;
+
+	if (context->started)
+	{
+		Flash_grabOriginal (context);
+		Flash_drawCurrentFrame (context);
+	}
+}
+
+void
+Flash_getRect (FlashContext *context, RECT *rect)
+{
+	assert (!context->type == FlashType_highlight);
+
+	*rect = context->rect;
+}
+
+// Call before you update the graphics in the currently flashing area.
+void
+Flash_preUpdate (FlashContext *context)
+{
+	Flash_drawFrame (context, context->original);
+	Flash_clearCache (context);
+}
+
+// Call after you update the graphics in the currently flashing area.
+void
+Flash_postUpdate (FlashContext *context)
+{
+	Flash_grabOriginal (context);
+	Flash_drawCurrentFrame (context);
+}
+
+// Pre: context->original has been initialised.
+static void
+Flash_initCache (FlashContext *context)
+{
+	COUNT i;
+
+	context->cache = HMalloc (context->cacheSize * sizeof (FRAME));
+	for (i = 0; i < context->cacheSize; i++)
+		context->cache[i] = (FRAME) 0;
+}
+
+void
+Flash_setCacheSize (FlashContext *context, COUNT size)
+{
+	assert (size == 0 || size >= 2);
+
+	if (context->cache != NULL)
+	{
+		Flash_clearCache (context);
+		HFree (context->cache);
+		context->cache = NULL;
+	}
+
+	context->cacheSize = size;
+
+	if (size != 0)
+		Flash_initCache (context);
+}
+
+COUNT
+Flash_getCacheSize (const FlashContext *context)
+{
+	return context->cacheSize;
+}
+
+static void
+Flash_grabOriginal (FlashContext *context)
+{
+	if (context->original != (FRAME) 0)
+		DestroyDrawable (ReleaseDrawable (context->original));
+
+	if (context->parent == 0)
+	{
+		// Grab from the entire screen
+		CONTEXT oldGfxContext;
+		LockMutex (GraphicsLock);
+		oldGfxContext = SetContext (context->gfxContext);
+		context->original = CaptureDrawable (LoadDisplayPixmap (
+				&context->rect, (FRAME) 0));
+		SetContext (oldGfxContext);
+		UnlockMutex (GraphicsLock);
+		FlushGraphics ();
+				// LoadDisplayPixmap only queues the command to read
+				// a rectangle from the screen; a FlushGraphics()
+				// is necessary to ensure that it can actually be used.
+	}
+	else
+	{
+		// Grab from a frame.
+		context->original = CaptureDrawable (CreateDrawable (WANT_PIXMAP,
+				context->rect.extent.width, context->rect.extent.height, 1));
+		arith_frame_blit (context->parent, &context->rect,
+				context->original, NULL, 1, 1);
+	}
+}
+
+static inline void
+Flash_blendFraction (FlashContext *context, int numer, int denom,
+		int *resNumer, int *resDenom)
+{
+	// This function merges two fractions (F0 and F1),
+	// based on another fraction (P) (yielding R).
+	// F0 = context->u.highlight.startNumer / context->u.highlight.denom
+	// F1 = context->u.highlight.endNumer / context->u.highlight.denom
+	// P = *numer / *denom
+	// R = P * F1 + (1 - P) * F0
+	//   = numer * context->u.highlight.endNumer /
+	//     (denom * context->u.highlight.denom) +
+	//     (denom - numer) * u.highlight.startNumer /
+	//     denom * context->u.highlight.denom
+	
+	assert (numer >= 0 && numer <= denom);
+
+	*resNumer = numer * context->u.highlight.endNumer +
+			(denom - numer) * context->u.highlight.startNumer;
+	*resDenom = denom * context->u.highlight.denom;
+}
+
+static void
+Flash_makeFrame (FlashContext *context, FRAME dest, RECT *destRect,
+		int numer, int denom)
+{
+	RECT orgRect;
+	orgRect.corner.x = 0;
+	orgRect.corner.y = 0;
+	orgRect.extent = context->rect.extent;
+
+	switch (context->type) {
+		case FlashType_highlight:
+		{
+			int blendedNumer;
+			int blendedDenom;
+
+			Flash_blendFraction (context, numer, denom, &blendedNumer,
+					&blendedDenom);
+			arith_frame_blit (context->original, &orgRect, dest, destRect,
+					blendedNumer, blendedDenom);
+			break;
+		}
+		case FlashType_transition:
+		{
+			FRAME first;
+			FRAME final;
+
+			first = context->u.transition.first;
+			if (first == (FRAME) 0)
+				first = context->original;
+			final = context->u.transition.final;
+			if (final == (FRAME) 0)
+				final = context->original;
+
+			arith_frame_blit (first, &orgRect, dest, destRect,
+					denom - numer, denom);
+			arith_frame_blit (final, &orgRect, dest, destRect,
+					numer, -denom);
+			break;
+		}
+		case FlashType_overlay:
+			arith_frame_blit (context->original, &orgRect, dest, destRect,
+					denom, denom);
+			arith_frame_blit (context->u.overlay.frame, &orgRect,
+					dest, destRect, numer, -denom);
+			break;
+	}
+}
+
+
+// Prepare an entry in the cache.
+static inline void
+Flash_prepareCacheFrame (FlashContext *context, COUNT index)
+{
+	if (context->cache[index] != (FRAME) 0)
+		return;
+
+	if (index == 0 && context->type == FlashType_overlay)
+		context->cache[index] = context->original;
+	else if (index == 0 && context->type == FlashType_transition)
+		context->cache[index] = context->u.transition.first != (FRAME) 0 ?
+				context->u.transition.first : context->original;
+	else if (index == context->cacheSize - 1 &&
+			context->type == FlashType_transition)
+		context->cache[index] = context->u.transition.final != (FRAME) 0 ?
+				context->u.transition.final : context->original;
+	else
+	{
+		context->cache[index] = CaptureDrawable (CreateDrawable (WANT_PIXMAP,
+				context->rect.extent.width, context->rect.extent.height, 1));
+		Flash_makeFrame (context, context->cache[index], NULL,
+				index, context->cacheSize - 1);
+	}
+}
+
+static void
+Flash_drawFrame (FlashContext *context, FRAME frame)
+{
+	CONTEXT oldGfxContext;
+	FRAME oldFGFrame = (FRAME) 0;
+	STAMP stamp;
+
+	LockMutex (GraphicsLock);
+	oldGfxContext = SetContext (context->gfxContext);
+	if (context->parent != NULL)
+		oldFGFrame = SetContextFGFrame (context->parent);
+
+	stamp.origin = context->rect.corner;
+	stamp.frame = frame;
+	DrawStamp(&stamp);
+
+	if (context->parent != NULL)
+		SetContextFGFrame (oldFGFrame);
+	SetContext (oldGfxContext);
+	UnlockMutex (GraphicsLock);
+}
+
+static void
+Flash_drawCacheFrame (FlashContext *context, COUNT index)
+{
+	FRAME frame;
+
+	if (context->lastFrameIndex == index)
+		return;
+
+	frame = context->cache[index];
+	Flash_drawFrame (context, frame);
+	context->lastFrameIndex = index;
+}
+
+static inline void
+Flash_drawUncachedFrame (FlashContext *context, int numer, int denom)
+{
+	// 'lastFrameIndex' is 0 for the first image, 1 for the final
+	// image, and 2 otherwise.
+
+	if (numer == 0 && context->type == FlashType_overlay)
+	{
+		if (context->lastFrameIndex != 0)
+			return;
+
+		Flash_drawFrame (context, context->original);
+		context->lastFrameIndex = 0;
+		return;
+	}
+	else if (numer == 0 && context->type == FlashType_transition)
+	{
+		if (context->lastFrameIndex == 0)
+			return;
+
+		Flash_drawFrame (context, context->u.transition.first);
+		context->lastFrameIndex = 0;
+		return;
+	}
+	else if (numer == denom && context->type == FlashType_transition)
+	{
+		if (context->lastFrameIndex == 1)
+			return;
+
+		Flash_drawFrame (context, context->u.transition.final);
+		context->lastFrameIndex = 1;
+		return;
+	}
+
+	context->lastFrameIndex = 2;
+
+	if (context->parent == NULL)
+	{
+		// Painting to the screen; we need a temporary frame to draw to.
+		FRAME work;
+
+		work = CaptureDrawable (CreateDrawable (WANT_PIXMAP,
+				context->rect.extent.width, context->rect.extent.height, 1));
+		Flash_makeFrame (context, work, NULL, numer, denom);
+		Flash_drawFrame (context, work);
+
+		DestroyDrawable (ReleaseDrawable (work));
+	}
+	else
+	{
+		// Painting to another frame; we can directly draw to it.
+		CONTEXT oldGfxContext;
+		FRAME oldFGFrame;
+
+		LockMutex (GraphicsLock);
+		oldGfxContext = SetContext (context->gfxContext);
+		oldFGFrame = SetContextFGFrame (context->parent);
+		Flash_makeFrame (context, context->parent, &context->rect,
+				numer, denom);
+		SetContextFGFrame (oldFGFrame);
+		SetContext (oldGfxContext);
+		UnlockMutex (GraphicsLock);
+	}
+}
+
+static inline void
+Flash_drawCachedFrame (FlashContext *context, int numer, int denom)
+{
+	COUNT cachePos;
+
+	cachePos = ((context->cacheSize - 1) * numer + (denom / 2)) / denom;
+	Flash_prepareCacheFrame (context, cachePos);
+	Flash_drawCacheFrame (context, cachePos);
+}
+
+static void
+Flash_drawCurrentFrame (FlashContext *context)
+{
+	int numer;
+	int denom;
+
+	if (context->state == FlashState_off)
+	{
+		numer = 0;
+		denom = 1;
+	}
+	else if (context->state == FlashState_on)
+	{
+		numer = 1;
+		denom = 1;
+	}
+	else
+	{
+		TimeCount now = GetTimeCounter ();
+
+		if (context->state == FlashState_fadeIn)
+			denom = (int) context->fadeInTime;
+		else
+			denom = (int) context->fadeOutTime;
+
+		numer = (int) (now - context->lastStateTime);
+
+		if (numer > denom)
+			numer = denom;
+
+		if (context->state == FlashState_fadeOut)
+			numer = (int) context->fadeOutTime - numer;
+	}
+
+	if (context->cacheSize == 0)
+		Flash_drawUncachedFrame (context, numer, denom);
+	else
+		Flash_drawCachedFrame (context, numer, denom);
+}
+
+
+
diff -ruNp src.orig/sc2code/flash.h src/sc2code/flash.h
--- src.orig/sc2code/flash.h	1969-12-31 18:00:00 -0600
+++ src/sc2code/flash.h	2017-11-08 16:49:55 -0600
@@ -0,0 +1,201 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _FLASH_H
+#define _FLASH_H
+
+/*
+ * This code can draw three kinds of flashing areas.
+ * - a rectangular highlight area. The brightness of the area oscilates.
+ * - an overlay; an image is overlayed over an area, with oscilating
+ *   brightness.
+ * - a transition/cross-fade between two images.
+ *
+ * NB. The graphics lock should not be held when any of the Flash functions
+ *     is called.
+ *
+ *
+ * Example:
+ *
+ * // We create the flash context; it is used to manipulate the flash
+ * // rectangle while it exists.
+ * FlashContext *fc = Flash_createHighlight (context, (FRAME) 0, rect,
+ *         2, 3, 2);
+ *
+ * // We change the flashing speed from the defaults.
+ * Flash_setSpeed (ONE_SECOND, ONE_SECOND, ONE_SECOND, ONE_SECOND);
+ * 
+ * // During cross-fades, update 8 times per second.
+ * Flash_setFrameTime (gmstate.player[playerI].flashContext,
+ *         ONE_SECOND / 8);
+ *
+ * // We start the flashing. The default is to start from the "off" state.
+ * Flash_start (fc);
+ *
+ * // Some other stuff happens
+ * ...
+ *
+ * // The user has activated the selection. We pause for instance while
+ * // a pop-up window is active.
+ * Flash_pause (fc);
+ *
+ * // We set the flashing rectangle full on, to indicate the current
+ * // selection while the popup is active.
+ * Flash_setState (FlashState_on);
+ * ...
+ * // Continue the flashing.
+ * Flash_continue (fc);
+ * ...
+ * // Modifying the graphics of the area that is flashing:
+ * void Flash_preUpdate (fc);
+ * ... // do Drawing
+ * void Flash_postUpdate (fc);
+ * ...
+ * // We're done. Terminating the flash restores the flash area to its
+ * // original state.
+ * Flash_terminate (fc);
+ *
+ *
+ * Periodically, Flash_process() should be called on the flash context,
+ * so that the flashing square is updated.
+ * You can use Flash_nextTime() to determine when the next update is needed,
+ * or just call Flash_process() to try (it does no updates if not needed).
+ *
+ */
+
+#include "libs/gfxlib.h"
+#include "libs/timelib.h"
+
+typedef enum {
+	FlashState_fadeIn = 0,
+			// Someway between on and off, going towards on.
+	FlashState_on = 1,
+			// The overlay image is visible at 100% opacity.
+	FlashState_fadeOut = 2,
+			// Someway between on and off, going towards off.
+	FlashState_off = 3,
+			// The overlay image is not visible.
+} FlashState;
+
+typedef struct FlashContext FlashContext;
+
+#ifdef FLASH_INTERNAL
+typedef enum {
+	FlashType_highlight,
+	FlashType_transition,
+	FlashType_overlay,
+} FlashType;
+
+struct FlashContext {
+	CONTEXT gfxContext;
+			// The graphics context used for drawing.
+	FRAME parent;
+			// The frame that contains the flash rectangle.
+
+	RECT rect;
+			// The rectangle to flash.
+			
+	FRAME original;
+			// The original contents of the flash area.
+
+	FlashType type;
+			// The type of flash animation.
+
+	union {
+		struct {
+			int startNumer;
+					// Numerator for the brightness for the on state.
+			int endNumer;
+					// Numerator for the brightness for the off state.
+			int denom;
+					// Denominator for the brightness.
+		} highlight;
+		struct {
+			FRAME first;
+					// The first image from the transition (cross-fade).
+					// (FRAME) 0 means that the original is to be used.
+			FRAME final;
+					// The last image from the transition.
+					// (FRAME) 0 means that the original is to be used.
+		} transition;
+		struct {
+			FRAME frame;
+		} overlay;
+	} u;
+
+	TimeCount fadeInTime;
+	TimeCount onTime;
+	TimeCount fadeOutTime;
+	TimeCount offTime;
+
+	TimeCount frameTime;
+
+	FlashState state;
+	TimeCount lastStateTime;
+			// Time of the last state change.
+	TimeCount lastFrameTime;
+			// Time of the last frame draw.
+
+	BOOLEAN started : 1;
+	BOOLEAN paused : 1;
+
+	FRAME *cache;
+	COUNT cacheSize;
+
+	COUNT lastFrameIndex;
+			// Last frame drawn; used to determine whether a frame needs to
+			// be redawn. If a cache is used, this is the index in the cache.
+			// If no cache is used, this is either 0, 1, or 2, for
+			// the respectively first, last, or other frame for the flash
+			// animation.
+};
+
+#	define Flash_DEFAULT_FADE_IN_TIME   0
+#	define Flash_DEFAULT_ON_TIME        (ONE_SECOND / 8)
+#	define Flash_DEFAULT_FADE_OUT_TIME  0
+#	define Flash_DEFAULT_OFF_TIME       (ONE_SECOND / 8)
+
+#	define Flash_DEFAULT_CACHE_SIZE 9
+#endif  /* FLASH_INTERNAL */
+
+
+FlashContext *Flash_createHighlight (CONTEXT gfxContext, FRAME parent,
+		const RECT *rect, int startNumer, int endNumer, int denom);
+FlashContext *Flash_createTransition (CONTEXT gfxContext, FRAME parent,
+		const POINT *origin, FRAME first, FRAME final);
+FlashContext *Flash_createOverlay (CONTEXT gfxContext, FRAME parent,
+		const POINT *origin, FRAME overlay);
+
+void Flash_setState (FlashContext *context, FlashState state);
+void Flash_start (FlashContext *context);
+void Flash_terminate (FlashContext *context);
+void Flash_pause (FlashContext *context);
+void Flash_continue (FlashContext *context);
+void Flash_process (FlashContext *context);
+void Flash_setSpeed (FlashContext *context, TimeCount fadeInTime,
+		TimeCount onTime, TimeCount fadeOutTime, TimeCount offTime);
+void Flash_setFrameTime (FlashContext *context, TimeCount frameTime);
+TimeCount Flash_nextTime (FlashContext *context);
+void Flash_setRect (FlashContext *context, const RECT *rect);
+void Flash_getRect (FlashContext *context, RECT *rect);
+void Flash_preUpdate (FlashContext *context);
+void Flash_postUpdate (FlashContext *context);
+void Flash_setCacheSize (FlashContext *context, COUNT size);
+COUNT Flash_getCacheSize (const FlashContext *context);
+
+
+#endif  /* _FLASH_H */
+
diff -ruNp src.orig/sc2code/fmv.c src/sc2code/fmv.c
--- src.orig/sc2code/fmv.c	2017-11-08 16:49:28 -0600
+++ src/sc2code/fmv.c	2017-11-08 16:49:55 -0600
@@ -30,28 +30,35 @@
 #include "libs/graphics/gfx_common.h"
 #include "libs/inplib.h"
 
-
 void
 DoShipSpin (COUNT index, MUSIC_REF hMusic)
 {
 #ifdef WANT_SHIP_SPINS
-	char buf[30];
+	char vnbuf[32];
 	BYTE clut_buf[1];
 	RECT old_r, r;
 
 	SetGraphicUseOtherExtra (1);
 	LoadIntoExtraScreen (0);
+#if 0
+	/* This is cut out right now but should be part of the 3DO side */
 	clut_buf[0] = FadeAllToBlack;
 	SleepThreadUntil (XFormColorMap ((COLORMAPPTR)clut_buf, ONE_SECOND / 4));
 	FlushColorXForms ();
+#endif
 	
 	if (hMusic)
 		StopMusic ();
 
 	FreeHyperData ();
-	
-	sprintf (buf, "ship%02d", index);
-	DoFMV (buf, "spin", FALSE);
+
+	// TODO: It would be nice to have better resource names for these.
+	sprintf (vnbuf, "slides.spins.%02u", (unsigned)index);
+	ShowPresentation (vnbuf);
+
+	clut_buf[0] = FadeAllToBlack;
+	SleepThreadUntil (XFormColorMap ((COLORMAPPTR)clut_buf, ONE_SECOND / 4));
+	FlushColorXForms ();
 
 	GetContextClipRect (&old_r);
 	r.corner.x = r.corner.y = 0;
@@ -123,10 +130,6 @@ SplashScreen (void (* DoProcessing)(DWOR
 	}
 	GLOBAL (CurrentActivity) &= ~CHECK_ABORT;
 
-	/* You can't try to quit during a fade to black, because if
-	 * you try, the confirmation window will fade to black too.
-	 * Fixing this will require a rewrite of our whole rendering
-	 * engine. -- Michael */
 	xform_buf[0] = FadeAllToBlack;
 	SleepThreadUntil (XFormColorMap ((COLORMAPPTR)xform_buf, ONE_SECOND / 2));
 }
@@ -136,12 +139,7 @@ Introduction (void)
 {
 	BYTE xform_buf[1];
 
-	/* by default we do 3DO cinematics; or PC slides when 3DO files are
-	 * not present */
-	if (optWhichIntro == OPT_PC ||
-			!DoFMV ("slides/intro/intro.duk", NULL, TRUE))
-		ShowPresentation ( CaptureStringTable (
-				LoadStringTable (INTROPRES_STRTAB)));
+	ShowPresentation (INTROPRES_STRTAB);
 
 	xform_buf[0] = FadeAllToBlack;
 	SleepThreadUntil (XFormColorMap ((COLORMAPPTR)xform_buf, ONE_SECOND / 2));
@@ -157,10 +155,7 @@ Victory (void)
 
 	/* by default we do 3DO cinematics; or PC slides when 3DO files are
 	 * not present */
-	if (optWhichIntro == OPT_PC ||
-			!DoFMV ("slides/ending/victory.duk", NULL, TRUE))
-		ShowPresentation ( CaptureStringTable (
-					LoadStringTable (FINALPRES_STRTAB)));
+	ShowPresentation (FINALPRES_STRTAB);
 		
 	xform_buf[0] = FadeAllToBlack;
 	XFormColorMap ((COLORMAPPTR)xform_buf, 0);
@@ -169,7 +164,7 @@ Victory (void)
 void
 Logo (void)
 {
-	DoFMV ("logo", NULL, FALSE);
+	ShowPresentation ("slides.logo");
 }
 
 
diff -ruNp src.orig/sc2code/fmv.h src/sc2code/fmv.h
--- src.orig/sc2code/fmv.h	2017-11-08 16:49:28 -0600
+++ src/sc2code/fmv.h	2017-11-08 16:49:55 -0600
@@ -18,21 +18,17 @@
 #define _FMV_H
 
 #include "libs/compiler.h"
-
+#include "libs/sndlib.h"
+#include "libs/gfxlib.h"
+#define WANT_SHIP_SPINS
 
 extern void Logo (void);
 extern void SplashScreen (void (* DoProcessing)(DWORD TimeOut));
 extern void Introduction (void);
 extern void Victory (void);
-
-#include "libs/sndlib.h"
 extern void DoShipSpin (COUNT index, MUSIC_REF hMusic);
 
-extern BOOLEAN DoFMV (const char *name, const char *loopname,
-		BOOLEAN uninit);
-extern BOOLEAN ShowPresentation (STRING PresStr);
-extern BOOLEAN ShowPresentationFile (const char *name);
-
+extern BOOLEAN ShowPresentation (RESOURCE presentation);
 
 #endif  /* _FMV_H */
 
diff -ruNp src.orig/sc2code/galaxy.c src/sc2code/galaxy.c
--- src.orig/sc2code/galaxy.c	2017-11-08 16:49:28 -0600
+++ src/sc2code/galaxy.c	2017-11-08 16:49:55 -0600
@@ -47,11 +47,12 @@ static POINT log_star_array[NUM_STARS];
 
 typedef struct
 {
-	COUNT min_star_index, num_stars;
-	PPOINT star_array;
-	PPOINT pmin_star, plast_star;
+	COUNT min_star_index;
+	COUNT num_stars;
+	POINT *star_array;
+	POINT *pmin_star;
+	POINT *plast_star;
 } STAR_BLOCK;
-typedef STAR_BLOCK *PSTAR_BLOCK;
 
 STAR_BLOCK StarBlock[NUM_STAR_PLANES] =
 {
@@ -73,7 +74,7 @@ STAR_BLOCK StarBlock[NUM_STAR_PLANES] =
 };
 
 static void
-SortStarBlock (PSTAR_BLOCK pStarBlock)
+SortStarBlock (STAR_BLOCK *pStarBlock)
 {
 	COUNT i;
 
@@ -104,10 +105,10 @@ static void
 WrapStarBlock (SIZE plane, SIZE dx, SIZE dy)
 {
 	COUNT i;
-	PPOINT ppt;
+	POINT *ppt;
 	SIZE offs_y;
 	COUNT num_stars;
-	PSTAR_BLOCK pStarBlock;
+	STAR_BLOCK *pStarBlock;
 
 	pStarBlock = &StarBlock[plane];
 
@@ -235,7 +236,7 @@ void
 InitGalaxy (void)
 {
 	COUNT i, factor;
-	PPOINT ppt;
+	POINT *ppt;
 	PRIM_LINKS Links;
 
 	log_add (log_Debug, "InitGalaxy(): transition_width = %d, "
@@ -286,7 +287,7 @@ InitGalaxy (void)
 }
 
 static BOOLEAN
-CmpMovePoints (const PPOINT pt1, const PPOINT pt2, SIZE dx, SIZE dy,
+CmpMovePoints (const POINT *pt1, const POINT *pt2, SIZE dx, SIZE dy,
 			   SIZE reduction)
 {
 	if (optMeleeScale == TFB_SCALE_STEP)
@@ -304,7 +305,7 @@ CmpMovePoints (const PPOINT pt1, const P
 void
 MoveGalaxy (VIEW_STATE view_state, SIZE dx, SIZE dy)
 {
-	PPRIMITIVE pprim;
+	PRIMITIVE *pprim;
 	static const COUNT star_counts[] =
 	{
 		BIG_STAR_COUNT,
@@ -318,7 +319,7 @@ MoveGalaxy (VIEW_STATE view_state, SIZE
 		COUNT reduction;
 		COUNT i;
 		COUNT iss;
-		PPOINT ppt;
+		POINT *ppt;
 		int wrap_around;
 
 		reduction = zoom_out;
diff -ruNp src.orig/sc2code/gameev.c src/sc2code/gameev.c
--- src.orig/sc2code/gameev.c	2017-11-08 16:49:28 -0600
+++ src/sc2code/gameev.c	2017-11-08 16:49:55 -0600
@@ -105,22 +105,21 @@ EventHandler (BYTE selector)
 				AddEvent (RELATIVE_EVENT, 0, 7, 0, ZOQFOT_DEATH_EVENT);
 			else if (GET_GAME_STATE (ZOQFOT_DISTRESS))
 			{
-				HSTARSHIP hZoqFot;
-				EXTENDED_SHIP_FRAGMENTPTR ZoqFotPtr;
+				HFLEETINFO hZoqFot;
+				FLEET_INFO *ZoqFotPtr;
 
 				hZoqFot = GetStarShipFromIndex (&GLOBAL (avail_race_q),
 						ZOQFOTPIK_SHIP);
-				ZoqFotPtr = (EXTENDED_SHIP_FRAGMENTPTR)LockStarShip (
-						&GLOBAL (avail_race_q), hZoqFot);
-				ZoqFotPtr->ShipInfo.actual_strength = 0;
-				ZoqFotPtr->ShipInfo.ship_flags &= ~(GOOD_GUY | BAD_GUY);
-				UnlockStarShip ( &GLOBAL (avail_race_q), hZoqFot);
+				ZoqFotPtr = LockFleetInfo (&GLOBAL (avail_race_q), hZoqFot);
+				ZoqFotPtr->actual_strength = 0;
+				ZoqFotPtr->ship_flags &= ~(GOOD_GUY | BAD_GUY);
+				UnlockFleetInfo (&GLOBAL (avail_race_q), hZoqFot);
 
 				SET_GAME_STATE (ZOQFOT_DISTRESS, 2);
 			}
 			break;
 		case SHOFIXTI_RETURN_EVENT:
-			ActivateStarShip (SHOFIXTI_SHIP, 0);
+			ActivateStarShip (SHOFIXTI_SHIP, SET_ALLIED);
 			GLOBAL (CrewCost) -= 2;
 					/* crew is not an issue anymore */
 			SET_GAME_STATE (CREW_PURCHASED0, 0);
@@ -136,22 +135,22 @@ EventHandler (BYTE selector)
 				AddEvent (RELATIVE_EVENT, 0, 7, 0, SPATHI_SHIELD_EVENT);
 			else
 			{
-				HSTARSHIP hSpathi;
-				EXTENDED_SHIP_FRAGMENTPTR SpathiPtr;
+				HFLEETINFO hSpathi;
+				FLEET_INFO *SpathiPtr;
 
-				hSpathi = GetStarShipFromIndex (
-						&GLOBAL (avail_race_q), SPATHI_SHIP);
-				SpathiPtr = (EXTENDED_SHIP_FRAGMENTPTR)LockStarShip (
-						&GLOBAL (avail_race_q), hSpathi);
+				hSpathi = GetStarShipFromIndex (&GLOBAL (avail_race_q),
+						SPATHI_SHIP);
+				SpathiPtr = LockFleetInfo (&GLOBAL (avail_race_q), hSpathi);
 
-				if (SpathiPtr->ShipInfo.actual_strength)
+				if (SpathiPtr->actual_strength)
 				{
-					ActivateStarShip (SPATHI_SHIP, -1);
+					ActivateStarShip (SPATHI_SHIP, SET_NOT_ALLIED);
+					ActivateStarShip (SPATHI_SHIP, REMOVE_BUILT);
 					SET_GAME_STATE (SPATHI_SHIELDED_SELVES, 1);
-					SpathiPtr->ShipInfo.actual_strength = 0;
+					SpathiPtr->actual_strength = 0;
 				}
 
-				UnlockStarShip (&GLOBAL (avail_race_q), hSpathi);
+				UnlockFleetInfo (&GLOBAL (avail_race_q), hSpathi);
 			}
 			break;
 		case ADVANCE_ILWRATH_MISSION:
@@ -165,24 +164,23 @@ EventHandler (BYTE selector)
 			break;
 		case YEHAT_REBEL_EVENT:
 		{
-			HSTARSHIP hRebel, hRoyalist;
-			EXTENDED_SHIP_FRAGMENTPTR RebelPtr, RoyalistPtr;
+			HFLEETINFO hRebel, hRoyalist;
+			FLEET_INFO *RebelPtr;
+			FLEET_INFO *RoyalistPtr;
 
 			hRebel = GetStarShipFromIndex (&GLOBAL (avail_race_q),
 					YEHAT_REBEL_SHIP);
-			RebelPtr = (EXTENDED_SHIP_FRAGMENTPTR)LockStarShip (
-					&GLOBAL (avail_race_q), hRebel);
+			RebelPtr = LockFleetInfo (&GLOBAL (avail_race_q), hRebel);
 			hRoyalist = GetStarShipFromIndex (&GLOBAL (avail_race_q),
 					YEHAT_SHIP);
-			RoyalistPtr = (EXTENDED_SHIP_FRAGMENTPTR)LockStarShip (
-					&GLOBAL (avail_race_q), hRoyalist);
-			RebelPtr->ShipInfo.actual_strength =
-					RoyalistPtr->ShipInfo.actual_strength =
-					RoyalistPtr->ShipInfo.actual_strength * 2 / 3;
-			RebelPtr->ShipInfo.loc.x = 5150;
-			RebelPtr->ShipInfo.loc.y = 0;
-			UnlockStarShip (&GLOBAL (avail_race_q), hRoyalist);
-			UnlockStarShip (&GLOBAL (avail_race_q), hRebel);
+			RoyalistPtr = LockFleetInfo (&GLOBAL (avail_race_q), hRoyalist);
+			RoyalistPtr->actual_strength = RoyalistPtr->actual_strength *
+					2 / 3;
+			RebelPtr->actual_strength = RoyalistPtr->actual_strength;
+			RebelPtr->loc.x = 5150;
+			RebelPtr->loc.y = 0;
+			UnlockFleetInfo (&GLOBAL (avail_race_q), hRoyalist);
+			UnlockFleetInfo (&GLOBAL (avail_race_q), hRebel);
 			ActivateStarShip (YEHAT_REBEL_SHIP, SPHERE_TRACKING);
 			break;
 		}
@@ -216,19 +214,18 @@ void
 SetRaceDest (BYTE which_race, COORD x, COORD y, BYTE days_left, BYTE
 		func_index)
 {
-	HSTARSHIP hStarShip;
-	EXTENDED_SHIP_FRAGMENTPTR TemplatePtr;
+	HFLEETINFO hFleet;
+	FLEET_INFO *FleetPtr;
 
-	hStarShip = GetStarShipFromIndex (&GLOBAL (avail_race_q), which_race);
-	TemplatePtr = (EXTENDED_SHIP_FRAGMENTPTR)LockStarShip (
-			&GLOBAL (avail_race_q), hStarShip);
-
-	TemplatePtr->ShipInfo.dest_loc.x = x;
-	TemplatePtr->ShipInfo.dest_loc.y = y;
-	TemplatePtr->ShipInfo.days_left = days_left;
-	TemplatePtr->ShipInfo.func_index = func_index;
+	hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q), which_race);
+	FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hFleet);
 
-	UnlockStarShip (&GLOBAL (avail_race_q), hStarShip);
+	FleetPtr->dest_loc.x = x;
+	FleetPtr->dest_loc.y = y;
+	FleetPtr->days_left = days_left;
+	FleetPtr->func_index = func_index;
+
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
 }
 
 
@@ -258,63 +255,55 @@ arilou_exit_event (void)
 static void
 check_race_growth (void)
 {
-	HSTARSHIP hStarShip, hNextShip;
+	HFLEETINFO hStarShip, hNextShip;
 
 	for (hStarShip = GetHeadLink (&GLOBAL (avail_race_q));
 			hStarShip; hStarShip = hNextShip)
 	{
-		EXTENDED_SHIP_FRAGMENTPTR TemplatePtr;
+		FLEET_INFO *FleetPtr;
 
-		TemplatePtr = (EXTENDED_SHIP_FRAGMENTPTR)LockStarShip (
-				&GLOBAL (avail_race_q), hStarShip);
-		hNextShip = _GetSuccLink (TemplatePtr);
+		FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
+		hNextShip = _GetSuccLink (FleetPtr);
 
-		if (TemplatePtr->ShipInfo.actual_strength
-				&& TemplatePtr->ShipInfo.actual_strength != (COUNT)~0)
+		if (FleetPtr->actual_strength
+				&& FleetPtr->actual_strength != INFINITE_RADIUS)
 		{
 			SIZE delta_strength;
 
-			delta_strength = (SBYTE)TemplatePtr->ShipInfo.energy_level;
-			if (TemplatePtr->ShipInfo.growth_err_term <=
-					TemplatePtr->ShipInfo.growth_fract)
+			delta_strength = (SBYTE)FleetPtr->growth;
+			if (FleetPtr->growth_err_term <= FleetPtr->growth_fract)
 			{
 				if (delta_strength <= 0)
 					--delta_strength;
 				else
 					++delta_strength;
 			}
-			TemplatePtr->ShipInfo.growth_err_term -=
-					TemplatePtr->ShipInfo.growth_fract;
+			FleetPtr->growth_err_term -= FleetPtr->growth_fract;
 
-			delta_strength += TemplatePtr->ShipInfo.actual_strength;
+			delta_strength += FleetPtr->actual_strength;
 			if (delta_strength <= 0)
 			{
 				delta_strength = 0;
-				TemplatePtr->ShipInfo.ship_flags &= ~(GOOD_GUY | BAD_GUY);
+				FleetPtr->ship_flags &= ~(GOOD_GUY | BAD_GUY);
 			}
 			else if (delta_strength > MAX_FLEET_STRENGTH)
 				delta_strength = MAX_FLEET_STRENGTH;
 				
-			TemplatePtr->ShipInfo.actual_strength = (COUNT)delta_strength;
-			if (TemplatePtr->ShipInfo.actual_strength &&
-					TemplatePtr->ShipInfo.days_left)
-			{
-				TemplatePtr->ShipInfo.loc.x +=
-						(TemplatePtr->ShipInfo.dest_loc.x
-						- TemplatePtr->ShipInfo.loc.x)
-						/ TemplatePtr->ShipInfo.days_left;
-				TemplatePtr->ShipInfo.loc.y +=
-						(TemplatePtr->ShipInfo.dest_loc.y
-						- TemplatePtr->ShipInfo.loc.y)
-						/ TemplatePtr->ShipInfo.days_left;
-
-				if (--TemplatePtr->ShipInfo.days_left == 0
-						&& TemplatePtr->ShipInfo.func_index != (BYTE) ~0)
-					EventHandler (TemplatePtr->ShipInfo.func_index);
+			FleetPtr->actual_strength = (COUNT)delta_strength;
+			if (FleetPtr->actual_strength && FleetPtr->days_left)
+			{
+				FleetPtr->loc.x += (FleetPtr->dest_loc.x - FleetPtr->loc.x)
+						/ FleetPtr->days_left;
+				FleetPtr->loc.y += (FleetPtr->dest_loc.y - FleetPtr->loc.y)
+						/ FleetPtr->days_left;
+
+				if (--FleetPtr->days_left == 0
+						&& FleetPtr->func_index != (BYTE) ~0)
+					EventHandler (FleetPtr->func_index);
 			}
 		}
 
-		UnlockStarShip (&GLOBAL (avail_race_q), hStarShip);
+		UnlockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
 	}
 }
 
@@ -324,42 +313,40 @@ black_urquan_genocide (void)
 	BYTE Index;
 	long best_dist;
 	SIZE best_dx, best_dy;
-	HSTARSHIP hStarShip, hNextShip;
-	HSTARSHIP hBlackUrquan;
-	EXTENDED_SHIP_FRAGMENTPTR BlackUrquanPtr;
-
-	hBlackUrquan = GetStarShipFromIndex (
-			&GLOBAL (avail_race_q), BLACK_URQUAN_SHIP);
-	BlackUrquanPtr = (EXTENDED_SHIP_FRAGMENTPTR)LockStarShip (
-			&GLOBAL (avail_race_q), hBlackUrquan);
+	HFLEETINFO hStarShip, hNextShip;
+	HFLEETINFO hBlackUrquan;
+	FLEET_INFO *BlackUrquanPtr;
+
+	hBlackUrquan = GetStarShipFromIndex (&GLOBAL (avail_race_q),
+			BLACK_URQUAN_SHIP);
+	BlackUrquanPtr = LockFleetInfo (&GLOBAL (avail_race_q), hBlackUrquan);
 
 	best_dist = -1;
-	best_dx = SOL_X - BlackUrquanPtr->ShipInfo.loc.x;
-	best_dy = SOL_Y - BlackUrquanPtr->ShipInfo.loc.y;
+	best_dx = SOL_X - BlackUrquanPtr->loc.x;
+	best_dy = SOL_Y - BlackUrquanPtr->loc.y;
 	for (Index = 0, hStarShip = GetHeadLink (&GLOBAL (avail_race_q));
 			hStarShip; ++Index, hStarShip = hNextShip)
 	{
-		EXTENDED_SHIP_FRAGMENTPTR TemplatePtr;
+		FLEET_INFO *FleetPtr;
 
-		TemplatePtr = (EXTENDED_SHIP_FRAGMENTPTR)LockStarShip (
-				&GLOBAL (avail_race_q), hStarShip);
-		hNextShip = _GetSuccLink (TemplatePtr);
+		FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
+		hNextShip = _GetSuccLink (FleetPtr);
 
 		if (Index != BLACK_URQUAN_SHIP
 				&& Index != URQUAN_SHIP
-				&& TemplatePtr->ShipInfo.actual_strength != (COUNT)~0)
+				&& FleetPtr->actual_strength != INFINITE_RADIUS)
 		{
 			SIZE dx, dy;
 
-			dx = TemplatePtr->ShipInfo.loc.x - BlackUrquanPtr->ShipInfo.loc.x;
-			dy = TemplatePtr->ShipInfo.loc.y - BlackUrquanPtr->ShipInfo.loc.y;
+			dx = FleetPtr->loc.x - BlackUrquanPtr->loc.x;
+			dy = FleetPtr->loc.y - BlackUrquanPtr->loc.y;
 			if (dx == 0 && dy == 0)
 			{
 				// Arrived at the victim's home world. Cleanse it.
-				TemplatePtr->ShipInfo.ship_flags &= ~(GOOD_GUY | BAD_GUY);
-				TemplatePtr->ShipInfo.actual_strength = 0;
+				FleetPtr->ship_flags &= ~(GOOD_GUY | BAD_GUY);
+				FleetPtr->actual_strength = 0;
 			}
-			else if (TemplatePtr->ShipInfo.actual_strength)
+			else if (FleetPtr->actual_strength)
 			{
 				long dist;
 
@@ -376,7 +363,7 @@ black_urquan_genocide (void)
 			}
 		}
 
-		UnlockStarShip (&GLOBAL (avail_race_q), hStarShip);
+		UnlockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
 	}
 
 	if (best_dist < 0 && best_dx == 0 && best_dy == 0)
@@ -408,51 +395,50 @@ black_urquan_genocide (void)
 		SET_GAME_STATE (KOHR_AH_INFO, 0);
 		SET_GAME_STATE (URQUAN_VISITS, 0);
 		SetRaceDest (BLACK_URQUAN_SHIP,
-				BlackUrquanPtr->ShipInfo.loc.x + best_dx,
-				BlackUrquanPtr->ShipInfo.loc.y + best_dy,
+				BlackUrquanPtr->loc.x + best_dx,
+				BlackUrquanPtr->loc.y + best_dy,
 				(BYTE)speed, KOHR_AH_GENOCIDE_EVENT);
 	}
 
-	UnlockStarShip (&GLOBAL (avail_race_q), hBlackUrquan);
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hBlackUrquan);
 }
 
 static void
 pkunk_mission (void)
 {
-	HSTARSHIP hPkunk;
-	EXTENDED_SHIP_FRAGMENTPTR PkunkPtr;
+	HFLEETINFO hPkunk;
+	FLEET_INFO *PkunkPtr;
 
 	hPkunk = GetStarShipFromIndex (&GLOBAL (avail_race_q), PKUNK_SHIP);
-	PkunkPtr = (EXTENDED_SHIP_FRAGMENTPTR)LockStarShip (
-			&GLOBAL (avail_race_q), hPkunk);
+	PkunkPtr = LockFleetInfo (&GLOBAL (avail_race_q), hPkunk);
 
-	if (PkunkPtr->ShipInfo.actual_strength)
+	if (PkunkPtr->actual_strength)
 	{
 		BYTE MissionState;
 
 		MissionState = GET_GAME_STATE (PKUNK_MISSION);
-		if (PkunkPtr->ShipInfo.days_left == 0 && MissionState)
+		if (PkunkPtr->days_left == 0 && MissionState)
 		{
 			if ((MissionState & 1)
 							/* made it to Yehat space */
-					|| (PkunkPtr->ShipInfo.loc.x == 4970
-					&& PkunkPtr->ShipInfo.loc.y == 400))
-				PkunkPtr->ShipInfo.actual_strength = 0;
-			else if (PkunkPtr->ShipInfo.loc.x == 502
-					&& PkunkPtr->ShipInfo.loc.y == 401
+					|| (PkunkPtr->loc.x == 4970
+					&& PkunkPtr->loc.y == 400))
+				PkunkPtr->actual_strength = 0;
+			else if (PkunkPtr->loc.x == 502
+					&& PkunkPtr->loc.y == 401
 					&& GET_GAME_STATE (PKUNK_ON_THE_MOVE))
 			{
 				SET_GAME_STATE (PKUNK_ON_THE_MOVE, 0);
 				AddEvent (RELATIVE_EVENT, 3, 0, 0, ADVANCE_PKUNK_MISSION);
-				UnlockStarShip (&GLOBAL (avail_race_q), hPkunk);
+				UnlockFleetInfo (&GLOBAL (avail_race_q), hPkunk);
 				return;
 			}
 		}
 
-		if (PkunkPtr->ShipInfo.actual_strength == 0)
+		if (PkunkPtr->actual_strength == 0)
 		{
 			SET_GAME_STATE (YEHAT_ABSORBED_PKUNK, 1);
-			PkunkPtr->ShipInfo.ship_flags &= ~(GOOD_GUY | BAD_GUY);
+			PkunkPtr->ship_flags &= ~(GOOD_GUY | BAD_GUY);
 			ActivateStarShip (YEHAT_SHIP, SPHERE_TRACKING);
 		}
 		else
@@ -472,28 +458,27 @@ pkunk_mission (void)
 			SET_GAME_STATE (PKUNK_ON_THE_MOVE, 1);
 			SET_GAME_STATE (PKUNK_SWITCH, 0);
 			SetRaceDest (PKUNK_SHIP, x, y,
-					(BYTE)((365 >> 1) - PkunkPtr->ShipInfo.days_left),
+					(BYTE)((365 >> 1) - PkunkPtr->days_left),
 					ADVANCE_PKUNK_MISSION);
 		}
 		SET_GAME_STATE (PKUNK_MISSION, MissionState + 1);
 	}
 
-	UnlockStarShip (&GLOBAL (avail_race_q), hPkunk);
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hPkunk);
 }
 
 static void
 thradd_mission (void)
 {
 	BYTE MissionState;
-	HSTARSHIP hThradd;
-	EXTENDED_SHIP_FRAGMENTPTR ThraddPtr;
+	HFLEETINFO hThradd;
+	FLEET_INFO *ThraddPtr;
 
 	hThradd = GetStarShipFromIndex (&GLOBAL (avail_race_q), THRADDASH_SHIP);
-	ThraddPtr = (EXTENDED_SHIP_FRAGMENTPTR)LockStarShip (
-			&GLOBAL (avail_race_q), hThradd);
+	ThraddPtr = LockFleetInfo (&GLOBAL (avail_race_q), hThradd);
 
 	MissionState = GET_GAME_STATE (THRADD_MISSION);
-	if (ThraddPtr->ShipInfo.actual_strength && MissionState < 3)
+	if (ThraddPtr->actual_strength && MissionState < 3)
 	{
 		COORD x, y;
 
@@ -512,19 +497,17 @@ thradd_mission (void)
 		{	/* arrived at Kohr-Ah, engaging */
 			SIZE strength_loss;
 
-			strength_loss = (SIZE)(ThraddPtr->ShipInfo.actual_strength >> 1);
-			ThraddPtr->ShipInfo.energy_level =
-					(BYTE)(-strength_loss / 14);
-			ThraddPtr->ShipInfo.growth_fract =
-					(BYTE)(((strength_loss % 14) << 8) / 14);
-			ThraddPtr->ShipInfo.growth_err_term = 255 >> 1;
+			strength_loss = (SIZE)(ThraddPtr->actual_strength >> 1);
+			ThraddPtr->growth = (BYTE)(-strength_loss / 14);
+			ThraddPtr->growth_fract = (BYTE)(((strength_loss % 14) << 8) / 14);
+			ThraddPtr->growth_err_term = 255 >> 1;
 		}
 		else
 		{
 			if (MissionState != 0)
 			{	/* stop losses */
-				ThraddPtr->ShipInfo.energy_level = 0;
-				ThraddPtr->ShipInfo.growth_fract = 0;
+				ThraddPtr->growth = 0;
+				ThraddPtr->growth_fract = 0;
 			}
 		}
 		SetRaceDest (THRADDASH_SHIP, x, y, 14, ADVANCE_THRADD_MISSION);
@@ -537,36 +520,35 @@ thradd_mission (void)
 		AddEvent (RELATIVE_EVENT, 0, 0, 0, ADVANCE_ILWRATH_MISSION);
 	}
 
-	UnlockStarShip (&GLOBAL (avail_race_q), hThradd);
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hThradd);
 }
 
 static void
 ilwrath_mission (void)
 {
 	BYTE ThraddState;
-	HSTARSHIP hIlwrath, hThradd;
-	EXTENDED_SHIP_FRAGMENTPTR IlwrathPtr, ThraddPtr;
+	HFLEETINFO hIlwrath, hThradd;
+	FLEET_INFO *IlwrathPtr;
+	FLEET_INFO *ThraddPtr;
 
 	hIlwrath = GetStarShipFromIndex (&GLOBAL (avail_race_q), ILWRATH_SHIP);
-	IlwrathPtr = (EXTENDED_SHIP_FRAGMENTPTR)LockStarShip (
-			&GLOBAL (avail_race_q), hIlwrath);
+	IlwrathPtr = LockFleetInfo (&GLOBAL (avail_race_q), hIlwrath);
 	hThradd = GetStarShipFromIndex (&GLOBAL (avail_race_q), THRADDASH_SHIP);
-	ThraddPtr = (EXTENDED_SHIP_FRAGMENTPTR)LockStarShip (
-			&GLOBAL (avail_race_q), hThradd);
+	ThraddPtr = LockFleetInfo (&GLOBAL (avail_race_q), hThradd);
 
-	if (IlwrathPtr->ShipInfo.loc.x == ((2500 + 2535) >> 1)
-			&& IlwrathPtr->ShipInfo.loc.y == ((8070 + 8358) >> 1))
+	if (IlwrathPtr->loc.x == ((2500 + 2535) >> 1)
+			&& IlwrathPtr->loc.y == ((8070 + 8358) >> 1))
 	{
-		IlwrathPtr->ShipInfo.actual_strength =
-				ThraddPtr->ShipInfo.actual_strength = 0;
-		IlwrathPtr->ShipInfo.ship_flags &= ~(GOOD_GUY | BAD_GUY);
-		ThraddPtr->ShipInfo.ship_flags &= ~(GOOD_GUY | BAD_GUY);
+		IlwrathPtr->actual_strength = 0;
+		ThraddPtr->actual_strength = 0;
+		IlwrathPtr->ship_flags &= ~(GOOD_GUY | BAD_GUY);
+		ThraddPtr->ship_flags &= ~(GOOD_GUY | BAD_GUY);
 	}
-	else if (IlwrathPtr->ShipInfo.actual_strength)
+	else if (IlwrathPtr->actual_strength)
 	{
 		if (!GET_GAME_STATE (ILWRATH_FIGHT_THRADDASH)
-				&& (IlwrathPtr->ShipInfo.dest_loc.x != 2500
-				|| IlwrathPtr->ShipInfo.dest_loc.y != 8070))
+				&& (IlwrathPtr->dest_loc.x != 2500
+				|| IlwrathPtr->dest_loc.y != 8070))
 		{
 			SetRaceDest (ILWRATH_SHIP, 2500, 8070, 90,
 					ADVANCE_ILWRATH_MISSION);
@@ -576,28 +558,26 @@ ilwrath_mission (void)
 #define MADD_LENGTH 128
 			SIZE strength_loss;
 
-			if (IlwrathPtr->ShipInfo.days_left == 0)
+			if (IlwrathPtr->days_left == 0)
 			{	/* arrived for battle */
 				SET_GAME_STATE (ILWRATH_FIGHT_THRADDASH, 1);
 				SET_GAME_STATE (HELIX_UNPROTECTED, 1);
-				strength_loss = (SIZE)IlwrathPtr->ShipInfo.actual_strength;
-				IlwrathPtr->ShipInfo.energy_level =
-						(BYTE)(-strength_loss / MADD_LENGTH);
-				IlwrathPtr->ShipInfo.growth_fract =
+				strength_loss = (SIZE)IlwrathPtr->actual_strength;
+				IlwrathPtr->growth = (BYTE)(-strength_loss / MADD_LENGTH);
+				IlwrathPtr->growth_fract =
 						(BYTE)(((strength_loss % MADD_LENGTH) << 8) / MADD_LENGTH);
 				SetRaceDest (ILWRATH_SHIP,
 						(2500 + 2535) >> 1, (8070 + 8358) >> 1,
 						MADD_LENGTH - 1, ADVANCE_ILWRATH_MISSION);
 
-				strength_loss = (SIZE)ThraddPtr->ShipInfo.actual_strength;
-				ThraddPtr->ShipInfo.energy_level =
-						(BYTE)(-strength_loss / MADD_LENGTH);
-				ThraddPtr->ShipInfo.growth_fract =
+				strength_loss = (SIZE)ThraddPtr->actual_strength;
+				ThraddPtr->growth = (BYTE)(-strength_loss / MADD_LENGTH);
+				ThraddPtr->growth_fract =
 						(BYTE)(((strength_loss % MADD_LENGTH) << 8) / MADD_LENGTH);
 
 				SET_GAME_STATE (THRADD_VISITS, 0);
-				if (ThraddPtr->ShipInfo.ship_flags & GOOD_GUY)
-					ActivateStarShip (THRADDASH_SHIP, -1);
+				if (ThraddPtr->ship_flags & GOOD_GUY)
+					ActivateStarShip (THRADDASH_SHIP, SET_NOT_ALLIED);
 			}
 
 			ThraddState = GET_GAME_STATE (THRADD_MISSION);
@@ -605,7 +585,7 @@ ilwrath_mission (void)
 			{	/* never went to Kohr-Ah or returned */
 				SetRaceDest (THRADDASH_SHIP,
 						(2500 + 2535) >> 1, (8070 + 8358) >> 1,
-						IlwrathPtr->ShipInfo.days_left + 1, (BYTE)~0);
+						IlwrathPtr->days_left + 1, (BYTE)~0);
 			}
 			else if (ThraddState < 3)
 			{	/* recall on the double */
@@ -616,26 +596,25 @@ ilwrath_mission (void)
 		}
 	}
 
-	UnlockStarShip (&GLOBAL (avail_race_q), hThradd);
-	UnlockStarShip (&GLOBAL (avail_race_q), hIlwrath);
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hThradd);
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hIlwrath);
 }
 
 static void
 utwig_supox_mission (void)
 {
 	BYTE MissionState;
-	HSTARSHIP hUtwig, hSupox;
-	EXTENDED_SHIP_FRAGMENTPTR UtwigPtr, SupoxPtr;
+	HFLEETINFO hUtwig, hSupox;
+	FLEET_INFO *UtwigPtr;
+	FLEET_INFO *SupoxPtr;
 
 	hUtwig = GetStarShipFromIndex (&GLOBAL (avail_race_q), UTWIG_SHIP);
-	UtwigPtr = (EXTENDED_SHIP_FRAGMENTPTR)LockStarShip (
-			&GLOBAL (avail_race_q), hUtwig);
+	UtwigPtr = LockFleetInfo (&GLOBAL (avail_race_q), hUtwig);
 	hSupox = GetStarShipFromIndex (&GLOBAL (avail_race_q), SUPOX_SHIP);
-	SupoxPtr = (EXTENDED_SHIP_FRAGMENTPTR)LockStarShip (
-			&GLOBAL (avail_race_q), hSupox);
+	SupoxPtr = LockFleetInfo (&GLOBAL (avail_race_q), hSupox);
 
 	MissionState = GET_GAME_STATE (UTWIG_SUPOX_MISSION);
-	if (UtwigPtr->ShipInfo.actual_strength && MissionState < 5)
+	if (UtwigPtr->actual_strength && MissionState < 5)
 	{
 		if (MissionState == 1)
 		{
@@ -644,21 +623,19 @@ utwig_supox_mission (void)
 			AddEvent (RELATIVE_EVENT, 0, (160 >> 1), 0,
 					ADVANCE_UTWIG_SUPOX_MISSION);
 
-			strength_loss = (SIZE)(UtwigPtr->ShipInfo.actual_strength >> 1);
-			UtwigPtr->ShipInfo.energy_level =
-					(BYTE)(-strength_loss / 160);
-			UtwigPtr->ShipInfo.growth_fract =
+			strength_loss = (SIZE)(UtwigPtr->actual_strength >> 1);
+			UtwigPtr->growth = (BYTE)(-strength_loss / 160);
+			UtwigPtr->growth_fract =
 					(BYTE)(((strength_loss % 160) << 8) / 160);
-			UtwigPtr->ShipInfo.growth_err_term = 255 >> 1;
+			UtwigPtr->growth_err_term = 255 >> 1;
 
-			strength_loss = (SIZE)(SupoxPtr->ShipInfo.actual_strength >> 1);
+			strength_loss = (SIZE)(SupoxPtr->actual_strength >> 1);
 			if (strength_loss)
 			{
-				SupoxPtr->ShipInfo.energy_level =
-						(BYTE)(-strength_loss / 160);
-				SupoxPtr->ShipInfo.growth_fract =
+				SupoxPtr->growth = (BYTE)(-strength_loss / 160);
+				SupoxPtr->growth_fract =
 						(BYTE)(((strength_loss % 160) << 8) / 160);
-				SupoxPtr->ShipInfo.growth_err_term = 255 >> 1;
+				SupoxPtr->growth_err_term = 255 >> 1;
 			}
 
 			SET_GAME_STATE (UTWIG_WAR_NEWS, 0);
@@ -690,10 +667,10 @@ utwig_supox_mission (void)
 				sx = 7468;
 				sy = 9246;
 
-				UtwigPtr->ShipInfo.energy_level = 0;
-				UtwigPtr->ShipInfo.growth_fract = 0;
-				SupoxPtr->ShipInfo.energy_level = 0;
-				SupoxPtr->ShipInfo.growth_fract = 0;
+				UtwigPtr->growth = 0;
+				UtwigPtr->growth_fract = 0;
+				SupoxPtr->growth = 0;
+				SupoxPtr->growth_fract = 0;
 
 				SET_GAME_STATE (UTWIG_WAR_NEWS, 0);
 				SET_GAME_STATE (SUPOX_WAR_NEWS, 0);
@@ -708,33 +685,32 @@ utwig_supox_mission (void)
 	}
 	SET_GAME_STATE (UTWIG_SUPOX_MISSION, MissionState + 1);
 
-	UnlockStarShip (&GLOBAL (avail_race_q), hSupox);
-	UnlockStarShip (&GLOBAL (avail_race_q), hUtwig);
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hSupox);
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hUtwig);
 }
 
 static void
 mycon_mission (void)
 {
-	HSTARSHIP hMycon;
-	EXTENDED_SHIP_FRAGMENTPTR MyconPtr;
+	HFLEETINFO hMycon;
+	FLEET_INFO *MyconPtr;
 
 	hMycon = GetStarShipFromIndex (&GLOBAL (avail_race_q), MYCON_SHIP);
-	MyconPtr = (EXTENDED_SHIP_FRAGMENTPTR)LockStarShip (
-			&GLOBAL (avail_race_q), hMycon);
+	MyconPtr = LockFleetInfo (&GLOBAL (avail_race_q), hMycon);
 
-	if (MyconPtr->ShipInfo.actual_strength)
+	if (MyconPtr->actual_strength)
 	{
-		if (MyconPtr->ShipInfo.energy_level)
+		if (MyconPtr->growth)
 		{
 			// Head back.
 			SET_GAME_STATE (MYCON_KNOW_AMBUSH, 1);
 			SetRaceDest (MYCON_SHIP, 6392, 2200, 30, (BYTE)~0);
+			SetRaceDest (SYREEN_SHIP, 4125, 3770, 15, (BYTE)~0);
 
-			MyconPtr->ShipInfo.energy_level = 0;
-			MyconPtr->ShipInfo.growth_fract = 0;
+			MyconPtr->growth = 0;
+			MyconPtr->growth_fract = 0;
 		}
-		else if (MyconPtr->ShipInfo.loc.x != 6858
-				|| MyconPtr->ShipInfo.loc.y != 577)
+		else if (MyconPtr->loc.x != 6858 || MyconPtr->loc.y != 577)
 			SetRaceDest (MYCON_SHIP, 6858, 577, 30, ADVANCE_MYCON_MISSION);
 					// To Organon.
 		else
@@ -743,15 +719,13 @@ mycon_mission (void)
 			SIZE strength_loss;
 
 			AddEvent (RELATIVE_EVENT, 0, 14, 0, ADVANCE_MYCON_MISSION);
-			strength_loss = (SIZE)(MyconPtr->ShipInfo.actual_strength >> 1);
-			MyconPtr->ShipInfo.energy_level =
-					(BYTE)(-strength_loss / 14);
-			MyconPtr->ShipInfo.growth_fract =
-					(BYTE)(((strength_loss % 14) << 8) / 14);
-			MyconPtr->ShipInfo.growth_err_term = 255 >> 1;
+			strength_loss = (SIZE)(MyconPtr->actual_strength >> 1);
+			MyconPtr->growth = (BYTE)(-strength_loss / 14);
+			MyconPtr->growth_fract = (BYTE)(((strength_loss % 14) << 8) / 14);
+			MyconPtr->growth_err_term = 255 >> 1;
 		}
 	}
 
-	UnlockStarShip (&GLOBAL (avail_race_q), hMycon);
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hMycon);
 }
 
diff -ruNp src.orig/sc2code/gameinp.c src/sc2code/gameinp.c
--- src.orig/sc2code/gameinp.c	2017-11-08 16:49:28 -0600
+++ src/sc2code/gameinp.c	2017-11-08 16:49:55 -0600
@@ -17,39 +17,42 @@
  */
 
 #include "controls.h"
+#include "battlecontrols.h"
 #include "init.h"
+#include "intel.h"
+		// For computer_intelligence
+#ifdef NETPLAY
+#	include "netplay/netmelee.h"
+#endif
 #include "planets/planets.h"
 #include "settings.h"
 #include "sounds.h"
+#include "tactrans.h"
 #include "libs/inplib.h"
 #include "libs/timelib.h"
 #include "libs/threadlib.h"
 
 
-battle_summary_func ComputerInput, HumanInput[NUM_PLAYERS], NetworkInput;
-battle_summary_func PlayerInput[NUM_PLAYERS];
-
 #define ACCELERATION_INCREMENT (ONE_SECOND / 12)
 #define MENU_REPEAT_DELAY (ONE_SECOND >> 1)
 
 
 typedef struct
 {
-	BOOLEAN (*InputFunc) (PVOID pInputState);
+	BOOLEAN (*InputFunc) (void *pInputState);
 	COUNT MenuRepeatDelay;
 } INPUT_STATE_DESC;
-typedef INPUT_STATE_DESC *PINPUT_STATE_DESC;
 
 /* These static variables are the values that are set by the controllers. */
 
-typedef struct 
+typedef struct
 {
 	DWORD key [NUM_TEMPLATES][NUM_KEYS];
 	DWORD menu [NUM_MENU_KEYS];
 } MENU_ANNOTATIONS;
 
 
-CONTROL_TEMPLATE PlayerOne, PlayerTwo;
+CONTROL_TEMPLATE PlayerControls[NUM_PLAYERS];
 CONTROLLER_INPUT_STATE CurrentInputState, PulsedInputState;
 static CONTROLLER_INPUT_STATE CachedInputState, OldInputState;
 static MENU_ANNOTATIONS RepeatDelays, Times;
@@ -106,14 +109,15 @@ ResetKeyRepeat (void)
 }
 
 static void
-_check_for_pulse (int *current, int *cached, int *old, DWORD *accel, DWORD *newtime, DWORD *oldtime)
+_check_for_pulse (int *current, int *cached, int *old, DWORD *accel,
+		DWORD *newtime, DWORD *oldtime)
 {
 	if (*cached && *old)
 	{
 		if (*newtime - *oldtime < *accel)
 		{
 			*current = 0;
-		} 
+		}
 		else
 		{
 			*current = *cached;
@@ -140,7 +144,7 @@ static void
 _check_gestalt (DWORD NewTime)
 {
 	BOOLEAN CurrentGestalt;
-	int i,j;
+	int i, j;
 	OldGestalt = CachedGestalt;
 
 	CachedGestalt = 0;
@@ -226,13 +230,12 @@ UpdateInputState (void)
 		PauseGame ();
 
 	if (ExitRequested)
-	{
 		ConfirmExit ();
-	}
 
 	CurrentInputState = ImmediateInputState;
 	OldInputState = CachedInputState;
 	CachedInputState = ImmediateInputState;
+	BeginInputFrame ();
 	NewTime = GetTimeCounter ();
 	if (_gestalt_keys)
 	{
@@ -294,17 +297,49 @@ FlushInputState (void)
 	_clear_menu_state ();
 }
 
+MENU_SOUND_FLAGS
+MenuKeysToSoundFlags (const CONTROLLER_INPUT_STATE *state)
+{
+	MENU_SOUND_FLAGS soundFlags;
+
+	soundFlags = MENU_SOUND_NONE;
+	if (state->menu[KEY_MENU_UP])
+		soundFlags |= MENU_SOUND_UP;
+	if (state->menu[KEY_MENU_DOWN])
+		soundFlags |= MENU_SOUND_DOWN;
+	if (state->menu[KEY_MENU_LEFT])
+		soundFlags |= MENU_SOUND_LEFT;
+	if (state->menu[KEY_MENU_RIGHT])
+		soundFlags |= MENU_SOUND_RIGHT;
+	if (state->menu[KEY_MENU_SELECT])
+		soundFlags |= MENU_SOUND_SELECT;
+	if (state->menu[KEY_MENU_CANCEL])
+		soundFlags |= MENU_SOUND_CANCEL;
+	if (state->menu[KEY_MENU_SPECIAL])
+		soundFlags |= MENU_SOUND_SPECIAL;
+	if (state->menu[KEY_MENU_PAGE_UP])
+		soundFlags |= MENU_SOUND_PAGEUP;
+	if (state->menu[KEY_MENU_PAGE_DOWN])
+		soundFlags |= MENU_SOUND_PAGEDOWN;
+	if (state->menu[KEY_MENU_DELETE])
+		soundFlags |= MENU_SOUND_DELETE;
+	if (state->menu[KEY_MENU_BACKSPACE])
+		soundFlags |= MENU_SOUND_DELETE;
+	
+	return soundFlags;
+}
+
 void
-DoInput (PVOID pInputState, BOOLEAN resetInput)
+DoInput (void *pInputState, BOOLEAN resetInput)
 {
-	SetMenuRepeatDelay (ACCELERATION_INCREMENT, MENU_REPEAT_DELAY, ACCELERATION_INCREMENT, FALSE);
+	SetMenuRepeatDelay (ACCELERATION_INCREMENT, MENU_REPEAT_DELAY,
+			ACCELERATION_INCREMENT, FALSE);
 	if (resetInput)
-	{
 		TFB_ResetControls ();
-	}
+
 	do
 	{
-		MENU_SOUND_FLAGS input;
+		MENU_SOUND_FLAGS soundFlags;
 		TaskSwitch ();
 
 		UpdateInputState ();
@@ -321,25 +356,14 @@ DoInput (PVOID pInputState, BOOLEAN rese
 		if (CurrentInputState.menu[KEY_EXIT])
 			ExitState = ConfirmExit ();
 
-		input = MENU_SOUND_NONE;
-		if (PulsedInputState.menu[KEY_MENU_UP]) input |= MENU_SOUND_UP;
-		if (PulsedInputState.menu[KEY_MENU_DOWN]) input |= MENU_SOUND_DOWN;
-		if (PulsedInputState.menu[KEY_MENU_LEFT]) input |= MENU_SOUND_LEFT;
-		if (PulsedInputState.menu[KEY_MENU_RIGHT]) input |= MENU_SOUND_RIGHT;
-		if (PulsedInputState.menu[KEY_MENU_SELECT]) input |= MENU_SOUND_SELECT;
-		if (PulsedInputState.menu[KEY_MENU_CANCEL]) input |= MENU_SOUND_CANCEL;
-		if (PulsedInputState.menu[KEY_MENU_SPECIAL]) input |= MENU_SOUND_SPECIAL;
-		if (PulsedInputState.menu[KEY_MENU_PAGE_UP]) input |= MENU_SOUND_PAGEUP;
-		if (PulsedInputState.menu[KEY_MENU_PAGE_DOWN]) input |= MENU_SOUND_PAGEDOWN;
-		if (PulsedInputState.menu[KEY_MENU_DELETE]) input |= MENU_SOUND_DELETE;
-		if (PulsedInputState.menu[KEY_MENU_BACKSPACE]) input |= MENU_SOUND_DELETE;
+		soundFlags = MenuKeysToSoundFlags (&PulsedInputState);
 			
 		if (MenuSounds
 				&& (pSolarSysState == 0
 						/* see if in menu */
 				|| pSolarSysState->MenuState.CurState
 				|| pSolarSysState->MenuState.Initialized > 2)
-		                && (input & (sound_0 | sound_1))
+		                && (soundFlags & (sound_0 | sound_1))
 #ifdef NEVER
 				&& !PLRPlaying ((MUSIC_REF)~0)
 #endif /* NEVER */
@@ -348,18 +372,15 @@ DoInput (PVOID pInputState, BOOLEAN rese
 			SOUND S;
 
 			S = MenuSounds;
-			if (input & sound_1)
+			if (soundFlags & sound_1)
 				S = SetAbsSoundIndex (S, MENU_SOUND_SUCCESS);
 
 			PlaySoundEffect (S, 0, NotPositional (), NULL, 0);
 		}
-	} while ((*((PINPUT_STATE_DESC)pInputState)->InputFunc)
-			(pInputState));
+	} while (((INPUT_STATE_DESC*)pInputState)->InputFunc (pInputState));
+
 	if (resetInput)
-	{
 		TFB_ResetControls ();
-	}
-
 }
 
 void
@@ -376,52 +397,41 @@ GetMenuSounds (MENU_SOUND_FLAGS *s0, MEN
 	*s1 = sound_1;
 }
 
-/* These can really be refactored */
-
-BATTLE_INPUT_STATE
-p1_combat_summary (COUNT player, STARSHIPPTR StarShipPtr)
+static BATTLE_INPUT_STATE
+ControlInputToBattleInput (const int *keyState)
 {
 	BATTLE_INPUT_STATE InputState = 0;
-	if (CurrentInputState.key[PlayerOne][KEY_UP])
+
+	if (keyState[KEY_UP])
 		InputState |= BATTLE_THRUST;
-	if (CurrentInputState.key[PlayerOne][KEY_LEFT])
+	if (keyState[KEY_LEFT])
 		InputState |= BATTLE_LEFT;
-	if (CurrentInputState.key[PlayerOne][KEY_RIGHT])
+	if (keyState[KEY_RIGHT])
 		InputState |= BATTLE_RIGHT;
-	if (CurrentInputState.key[PlayerOne][KEY_WEAPON])
+	if (keyState[KEY_WEAPON])
 		InputState |= BATTLE_WEAPON;
-	if (CurrentInputState.key[PlayerOne][KEY_SPECIAL])
+	if (keyState[KEY_SPECIAL])
 		InputState |= BATTLE_SPECIAL;
-	if (CurrentInputState.key[PlayerOne][KEY_ESCAPE])
+	if (keyState[KEY_ESCAPE])
 		InputState |= BATTLE_ESCAPE;
-	if (CurrentInputState.key[PlayerOne][KEY_DOWN])
+	if (keyState[KEY_DOWN])
 		InputState |= BATTLE_DOWN;
 
-	(void) player;
-	(void) StarShipPtr;
 	return InputState;
 }
 
 BATTLE_INPUT_STATE
-p2_combat_summary (COUNT player, STARSHIPPTR StarShipPtr)
+CurrentInputToBattleInput (COUNT player)
 {
-	BATTLE_INPUT_STATE InputState = 0;
-	if (CurrentInputState.key[PlayerTwo][KEY_UP])
-		InputState |= BATTLE_THRUST;
-	if (CurrentInputState.key[PlayerTwo][KEY_LEFT])
-		InputState |= BATTLE_LEFT;
-	if (CurrentInputState.key[PlayerTwo][KEY_RIGHT])
-		InputState |= BATTLE_RIGHT;
-	if (CurrentInputState.key[PlayerTwo][KEY_WEAPON])
-		InputState |= BATTLE_WEAPON;
-	if (CurrentInputState.key[PlayerTwo][KEY_SPECIAL])
-		InputState |= BATTLE_SPECIAL;
-	if (CurrentInputState.key[PlayerTwo][KEY_DOWN])
-		InputState |= BATTLE_DOWN;
+	return ControlInputToBattleInput(
+			CurrentInputState.key[PlayerControls[player]]);
+}
 
-	(void) player;
-	(void) StarShipPtr;
-	return InputState;
+BATTLE_INPUT_STATE
+PulsedInputToBattleInput (COUNT player)
+{
+	return ControlInputToBattleInput(
+			PulsedInputState.key[PlayerControls[player]]);
 }
 
 BOOLEAN
@@ -461,6 +471,8 @@ ConfirmExit (void)
 		
 	result = DoConfirmExit ();
 	
-	SetMenuRepeatDelay (old_min_accel, old_max_accel, old_step_accel, old_gestalt_keys);
+	SetMenuRepeatDelay (old_min_accel, old_max_accel, old_step_accel,
+			old_gestalt_keys);
 	return result;
 }
+
diff -ruNp src.orig/sc2code/gameopt.c src/sc2code/gameopt.c
--- src.orig/sc2code/gameopt.c	2017-11-08 16:49:28 -0600
+++ src/sc2code/gameopt.c	2017-11-08 16:49:55 -0600
@@ -45,10 +45,10 @@
 #define SUMMARY_SIDE_OFFS 7
 #define SAVES_PER_PAGE 5
 
-static BOOLEAN DoSettings (PMENU_STATE pMS);
-static BOOLEAN DoNaming (PMENU_STATE pMS);
+static BOOLEAN DoSettings (MENU_STATE *pMS);
+static BOOLEAN DoNaming (MENU_STATE *pMS);
 
-static PMENU_STATE pLocMenuState;
+static MENU_STATE *pLocMenuState;
 static BYTE prev_save; //keeps track of the last slot that was saved or loaded
 
 
@@ -75,7 +75,7 @@ ConfirmSaveLoad (STAMP *MsgStamp)
 		t.pStr = GAME_STRING (SAVEGAME_STRING_BASE + 0);
 	else
 		t.pStr = GAME_STRING (SAVEGAME_STRING_BASE + 1);
-	TextRect (&t, &r, NULL_PTR);
+	TextRect (&t, &r, NULL);
 	r.corner.x -= 4;
 	r.corner.y -= 4;
 	r.extent.width += 8;
@@ -106,7 +106,7 @@ enum
 	SETTINGS
 };
 
-static BOOLEAN DoGameOptions (PMENU_STATE pMS);
+static BOOLEAN DoGameOptions (MENU_STATE *pMS);
 
 enum
 {
@@ -215,7 +215,7 @@ FeedbackQuit (BYTE which_setting)
 #define DDSHS_BLOCKCUR 2
 
 static BOOLEAN
-DrawDescriptionString (PMENU_STATE pMS, COUNT which_string, COUNT state)
+DrawDescriptionString (MENU_STATE *pMS, COUNT which_string, COUNT state)
 {
 	COUNT rel_index;
 	RECT r;
@@ -297,7 +297,7 @@ DrawDescriptionString (PMENU_STATE pMS,
 		COUNT i;
 		RECT text_r;
 		BYTE char_deltas[MAX_DESC_CHARS];
-		PBYTE pchar_deltas;
+		BYTE *pchar_deltas;
 
 		TextRect (&lf, &text_r, char_deltas);
 		if ((text_r.extent.width + 2) >= r.extent.width)
@@ -353,9 +353,9 @@ DrawDescriptionString (PMENU_STATE pMS,
 }
 
 static BOOLEAN
-OnNameChange (PTEXTENTRY_STATE pTES)
+OnNameChange (TEXTENTRY_STATE *pTES)
 {
-	PMENU_STATE pMS = (PMENU_STATE) pTES->CbParam;
+	MENU_STATE *pMS = (MENU_STATE*) pTES->CbParam;
 	COUNT hl = DDSHS_EDIT;
 
 	pMS->first_item.x = pTES->CursorPos;
@@ -366,7 +366,7 @@ OnNameChange (PTEXTENTRY_STATE pTES)
 }
 
 static BOOLEAN
-DoNaming (PMENU_STATE pMS)
+DoNaming (MENU_STATE *pMS)
 {
 	GAME_DESC buf;
 	TEXTENTRY_STATE tes;
@@ -427,7 +427,7 @@ DoNaming (PMENU_STATE pMS)
 }
 
 static BOOLEAN
-DoSettings (PMENU_STATE pMS)
+DoSettings (MENU_STATE *pMS)
 {
 	BYTE cur_speed;
 
@@ -448,7 +448,7 @@ DoSettings (PMENU_STATE pMS)
 			&& pMS->CurState == EXIT_MENU_SETTING))
 	{
 		LockMutex (GraphicsLock);
-		DrawStatusMessage (NULL_PTR);
+		DrawStatusMessage (NULL);
 		UnlockMutex (GraphicsLock);
 
 		pMS->CurState = SETTINGS;
@@ -500,7 +500,7 @@ DoSettings (PMENU_STATE pMS)
 }
 
 static BOOLEAN
-DoQuitMenu (PMENU_STATE pMS)
+DoQuitMenu (MENU_STATE *pMS)
 {
 	if (GLOBAL (CurrentActivity) & CHECK_ABORT)
 		return (FALSE);
@@ -519,7 +519,7 @@ DoQuitMenu (PMENU_STATE pMS)
 			&& pMS->CurState == NO_QUIT_MENU))
 	{
 		LockMutex (GraphicsLock);
-		DrawStatusMessage (NULL_PTR);
+		DrawStatusMessage (NULL);
 		UnlockMutex (GraphicsLock);
 
 		pMS->CurState = QUIT_GAME;
@@ -845,11 +845,11 @@ ShowSummary (SUMMARY_DESC *pSD)
 			case IN_STARBASE:
 			{
 				BYTE QuasiState;
-				STAR_DESCPTR SDPtr;
+				STAR_DESC *SDPtr;
 				
 				QuasiState = GET_GAME_STATE (ARILOU_SPACE_SIDE);
 				SET_GAME_STATE (ARILOU_SPACE_SIDE, 0);
-				SDPtr = FindStar (NULL_PTR, &r.corner, 1, 1);
+				SDPtr = FindStar (NULL, &r.corner, 1, 1);
 				SET_GAME_STATE (ARILOU_SPACE_SIDE, QuasiState);
 				if (SDPtr)
 				{
@@ -910,7 +910,7 @@ LoadGameDescriptions (SUMMARY_DESC *pSD)
 }
 
 static BOOLEAN
-DoPickGame (PMENU_STATE pMS)
+DoPickGame (MENU_STATE *pMS)
 {
 	BYTE NewState;
 	SUMMARY_DESC *pSD;
@@ -992,7 +992,7 @@ Restart:
 				}
 				else
 				{
-					SetFlashRect (NULL_PTR, (FRAME)0);
+					SetFlashRect (NULL, (FRAME)0);
 					DrawStamp (&MsgStamp);
 					DestroyDrawable (ReleaseDrawable (MsgStamp.frame));
 					UnlockMutex (GraphicsLock);
@@ -1021,10 +1021,10 @@ Restart:
 			else
 			{
 				ConfirmSaveLoad (0);
-				if (LoadGame ((COUNT)pMS->CurState, NULL_PTR))
+				if (LoadGame ((COUNT)pMS->CurState, NULL))
 					GLOBAL (CurrentActivity) |= CHECK_LOAD;
 			}
-			SetFlashRect (NULL_PTR, (FRAME)0);
+			SetFlashRect (NULL, (FRAME)0);
 			UnlockMutex (GraphicsLock);
 
 			pMS->ModuleFrame = 0;
@@ -1182,7 +1182,7 @@ ChangeGameSelection:
 				}
 				UnbatchGraphics ();
 			}
-			SetFlashRect (NULL_PTR, (FRAME)0);
+			SetFlashRect (NULL, (FRAME)0);
 			UnlockMutex (GraphicsLock);
 		}
 	}
@@ -1191,7 +1191,7 @@ ChangeGameSelection:
 }
 
 static BOOLEAN
-PickGame (PMENU_STATE pMS)
+PickGame (MENU_STATE *pMS)
 {
 	BOOLEAN retval;
 	CONTEXT OldContext;
@@ -1286,7 +1286,7 @@ PickGame (PMENU_STATE pMS)
 }
 
 static BOOLEAN
-DoGameOptions (PMENU_STATE pMS)
+DoGameOptions (MENU_STATE *pMS)
 {
 	BOOLEAN force_select = FALSE;
 	if (GLOBAL (CurrentActivity) & CHECK_ABORT)
@@ -1353,7 +1353,7 @@ GameOptions (void)
 	MenuState.InputFunc = DoGameOptions;
 	MenuState.CurState = SAVE_GAME;
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
-	DoInput ((PVOID)&MenuState, TRUE);
+	DoInput (&MenuState, TRUE);
 
 	pLocMenuState = 0;
 
diff -ruNp src.orig/sc2code/gamestr.h src/sc2code/gamestr.h
--- src.orig/sc2code/gamestr.h	2017-11-08 16:49:28 -0600
+++ src/sc2code/gamestr.h	2017-11-08 16:49:55 -0600
@@ -46,7 +46,8 @@
 #define FLAGSHIP_STRING_COUNT    13
 #define ORBITSCAN_STRING_COUNT   19
 #define MAINMENU_STRING_COUNT    57
-#define NETMELEE_STRING_COUNT    18
+#define NETMELEE_STRING_COUNT    34
+#define BIOLOGICAL_STRING_COUNT  26
 
 enum {
 	STAR_STRING_BASE       = 0,
@@ -71,8 +72,9 @@ enum {
 	ORBITSCAN_STRING_BASE  = FLAGSHIP_STRING_BASE + FLAGSHIP_STRING_COUNT,
 	MAINMENU_STRING_BASE   = ORBITSCAN_STRING_BASE + ORBITSCAN_STRING_COUNT,
 	NETMELEE_STRING_BASE   = MAINMENU_STRING_BASE + MAINMENU_STRING_COUNT,
+	BIOLOGICAL_STRING_BASE = NETMELEE_STRING_BASE + NETMELEE_STRING_COUNT,
 
-	GAMESTR_COUNT          = NETMELEE_STRING_BASE + NETMELEE_STRING_COUNT
+	GAMESTR_COUNT          = BIOLOGICAL_STRING_BASE + BIOLOGICAL_STRING_COUNT
 };
 
 
diff -ruNp src.orig/sc2code/gendef.c src/sc2code/gendef.c
--- src.orig/sc2code/gendef.c	2017-11-08 16:49:28 -0600
+++ src/sc2code/gendef.c	2017-11-08 16:49:55 -0600
@@ -37,8 +37,10 @@ GenerateIP (BYTE Index)
 		case SPATHI_DEFINED:
 			GenFunc = GenerateSpathi;
 			break;
-		case MELNORME0_DEFINED:
 		case MELNORME1_DEFINED:
+			GenFunc = GeneratePrecursorStarbase;
+			break;
+		case MELNORME0_DEFINED:
 		case MELNORME2_DEFINED:
 		case MELNORME3_DEFINED:
 		case MELNORME4_DEFINED:
@@ -103,6 +105,7 @@ GenerateIP (BYTE Index)
 			break;
 		case ZOQFOT_DEFINED:
 		case ZOQ_SCOUT_DEFINED:
+		case ZOQ_COLONY_DEFINED:
 			GenFunc = GenerateZoqFotPik;
 			break;
 		case YEHAT_DEFINED:
@@ -120,6 +123,18 @@ GenerateIP (BYTE Index)
 		case ILWRATH_DEFINED:
 			GenFunc = GenerateIlwrath;
 			break;
+		case URQUAN_DEFINED:
+			GenFunc = GenerateUrQuan;
+			break;
+		case KOHRAH_DEFINED:
+			GenFunc = GenerateKohrAh;
+			break;
+		case NEGLECTED_STARBASE_DEFINED:
+			GenFunc = GenerateNeglectedStarbase;
+			break;
+		case MOTHER_ARK_DEFINED:
+			GenFunc = GenerateMotherArk;
+			break;
 		default:
 			GenFunc = GenerateRandomIP;
 			break;
diff -ruNp src.orig/sc2code/getchar.c src/sc2code/getchar.c
--- src.orig/sc2code/getchar.c	2017-11-08 16:49:28 -0600
+++ src/sc2code/getchar.c	2017-11-08 16:49:55 -0600
@@ -88,7 +88,7 @@ JoyCharFindIn (const joy_char_t *ch, con
 }
 
 static int
-JoyCharIsLower (const joy_char_t *ch, PTEXTENTRY_STATE pTES)
+JoyCharIsLower (const joy_char_t *ch, TEXTENTRY_STATE *pTES)
 {
 	return 0 <= JoyCharFindIn (ch, pTES->JoyLower, pTES->JoyRegLength);
 }
@@ -104,7 +104,7 @@ JoyCharSwitchReg (joy_char_t *ch, const
 
 static void
 JoyCharToUpper (joy_char_t *outch, const joy_char_t *ch,
-		PTEXTENTRY_STATE pTES)
+		TEXTENTRY_STATE *pTES)
 {
 	*outch = *ch;
 	JoyCharSwitchReg (outch, pTES->JoyLower, pTES->JoyUpper,
@@ -113,7 +113,7 @@ JoyCharToUpper (joy_char_t *outch, const
 
 static void
 JoyCharToLower (joy_char_t *outch, const joy_char_t *ch,
-		PTEXTENTRY_STATE pTES)
+		TEXTENTRY_STATE *pTES)
 {
 	*outch = *ch;
 	JoyCharSwitchReg (outch, pTES->JoyUpper, pTES->JoyLower,
@@ -121,7 +121,7 @@ JoyCharToLower (joy_char_t *outch, const
 }
 
 BOOLEAN
-DoTextEntry (PTEXTENTRY_STATE pTES)
+DoTextEntry (TEXTENTRY_STATE *pTES)
 {
 	wchar_t ch;
 	UNICODE *pStr;
diff -ruNp src.orig/sc2code/globdata.c src/sc2code/globdata.c
--- src.orig/sc2code/globdata.c	2017-11-08 16:49:28 -0600
+++ src/sc2code/globdata.c	2017-11-08 16:49:55 -0600
@@ -26,6 +26,7 @@
 #include "nameref.h"
 #include "build.h"
 #include "state.h"
+#include "grpinfo.h"
 #include "gamestr.h"
 
 #include <stdlib.h>
@@ -124,7 +125,7 @@ CreateRadar (void)
 		RECT r;
 		CONTEXT OldContext;
 
-		RadarContext = CaptureContext (CreateContext ());
+		RadarContext = CreateContext ();
 		OldContext = SetContext (RadarContext);
 		SetContextFGFrame (Screen);
 		r.corner.x = RADAR_X;
@@ -141,10 +142,6 @@ LoadSC2Data (void)
 {
 	if (FlagStatFrame == 0)
 	{
-		MEM_HANDLE hOldIndex;
-
-		hOldIndex = SetResourceIndex (hResIndex);
-
 		FlagStatFrame = CaptureDrawable (
 				LoadGraphic (FLAGSTAT_MASK_PMAP_ANIM));
 		if (FlagStatFrame == NULL)
@@ -157,8 +154,6 @@ LoadSC2Data (void)
 
 		FontGradFrame = CaptureDrawable (
 				LoadGraphic (FONTGRAD_PMAP_ANIM));
-
-		SetResourceIndex (hOldIndex);
 	}
 
 	CreateRadar ();
@@ -172,6 +167,22 @@ LoadSC2Data (void)
 	return TRUE;
 }
 
+static void
+copyFleetInfo (FLEET_INFO *dst, SHIP_INFO *src, FLEET_STUFF *fleet)
+{
+	// other leading fields are irrelevant
+	dst->crew_level = src->crew_level;
+	dst->max_crew = src->max_crew;
+	dst->max_energy = src->max_energy;
+
+	dst->race_strings = src->race_strings;
+	dst->icons = src->icons;
+	dst->melee_icon = src->melee_icon;
+
+	dst->actual_strength = fleet->strength;
+	dst->known_loc = fleet->known_loc;
+}
+
 BOOLEAN
 InitSIS (void)
 {
@@ -183,79 +194,71 @@ InitSIS (void)
 	
 	{
 		COUNT num_ships;
-		RES_TYPE rt;
-		RES_INSTANCE ri;
-		RES_PACKAGE rp;
-
-		rt = GET_TYPE (ARILOU_SHIP_INDEX);
-		ri = GET_INSTANCE (ARILOU_SHIP_INDEX);
-		rp = GET_PACKAGE (ARILOU_SHIP_INDEX);
+		SPECIES_ID s_id = ARILOU_ID;
 
-		num_ships = (GET_PACKAGE (BLACKURQ_SHIP_INDEX) - rp + 1)
+		num_ships = KOHR_AH_ID - s_id + 1
 				+ 2; /* Yehat Rebels and Ur-Quan probe */
 
-		InitQueue (&GLOBAL (avail_race_q),
-				num_ships, sizeof (EXTENDED_SHIP_FRAGMENT));
+		InitQueue (&GLOBAL (avail_race_q), num_ships, sizeof (FLEET_INFO));
 		for (i = 0; i < num_ships; ++i)
 		{
-			DWORD ship_ref;
-			HSTARSHIP hStarShip;
+			SPECIES_ID ship_ref;
+			HFLEETINFO hFleet;
+			FLEET_INFO *FleetPtr;
 
 			if (i < num_ships - 2)
-				ship_ref = MAKE_RESOURCE (rp++, rt, ri++);
+				ship_ref = s_id++;
 			else if (i == num_ships - 2)
-				ship_ref = YEHAT_SHIP_INDEX;
+				ship_ref = YEHAT_ID;
 			else  /* (i == num_ships - 1) */
-				ship_ref = PROBE_RES_INDEX;
-			hStarShip = Build (&GLOBAL (avail_race_q), ship_ref, 0, 0);
-			if (hStarShip)
-			{
-				SHIP_FRAGMENTPTR FragPtr;
-				EXTENDED_SHIP_FRAGMENTPTR ExtFragPtr;
+				ship_ref = UR_QUAN_PROBE_ID;
+			
+			hFleet = AllocLink (&GLOBAL (avail_race_q));
+			if (!hFleet)
+				continue;
+			FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+			FleetPtr->SpeciesID = ship_ref;
 
-				FragPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-						&GLOBAL (avail_race_q), hStarShip);
-				if (i < num_ships - 1)
-				{
-					HSTARSHIP hMasterShip;
-					STARSHIPPTR MasterShipPtr;
-					
-					hMasterShip = FindMasterShip (ship_ref);
-					MasterShipPtr = LockStarShip (&master_q, hMasterShip);
-					FragPtr->ShipInfo =
-							((SHIP_FRAGMENTPTR)MasterShipPtr)->ShipInfo;
-					UnlockStarShip (&master_q, hMasterShip);
-				}
-				else
-				{
-					// Ur-Quan probe.
-					load_ship ((STARSHIPPTR)FragPtr, FALSE);
-					FragPtr->ShipInfo = FragPtr->RaceDescPtr->ship_info;
-					FragPtr->RaceDescPtr->ship_info.melee_icon = 0;
-					FragPtr->RaceDescPtr->ship_info.icons = 0;
-					FragPtr->RaceDescPtr->ship_info.race_strings = 0;
-					free_ship ((STARSHIPPTR)FragPtr, FALSE);
+			if (i < num_ships - 1)
+			{
+				HMASTERSHIP hMasterShip;
+				MASTER_SHIP_INFO *MasterPtr;
+				
+				hMasterShip = FindMasterShip (ship_ref);
+				MasterPtr = LockMasterShip (&master_q, hMasterShip);
+				// Grab a copy of loaded icons and strings (not owned)
+				copyFleetInfo (FleetPtr, &MasterPtr->ShipInfo,
+						&MasterPtr->Fleet);
+				UnlockMasterShip (&master_q, hMasterShip);
+			}
+			else
+			{
+				// Ur-Quan probe.
+				RACE_DESC *RDPtr = load_ship (FleetPtr->SpeciesID,
+						FALSE);
+				if (RDPtr)
+				{	// Grab a copy of loaded icons and strings
+					copyFleetInfo (FleetPtr, &RDPtr->ship_info,
+							&RDPtr->fleet);
+					// avail_race_q owns these resources now
+					free_ship (RDPtr, FALSE, FALSE);
 				}
+			}
 
-				FragPtr->ShipInfo.ship_flags = BAD_GUY;
-				ExtFragPtr = (EXTENDED_SHIP_FRAGMENTPTR)FragPtr;
-				ExtFragPtr->ShipInfo.known_strength = 0;
-				ExtFragPtr->ShipInfo.known_loc = ExtFragPtr->ShipInfo.loc;
-				if (FragPtr->ShipInfo.var2 == (BYTE)~0)
-					ExtFragPtr->ShipInfo.actual_strength = (COUNT)~0;
-				else if (i == YEHAT_REBEL_SHIP)
-					ExtFragPtr->ShipInfo.actual_strength = 0;
-				else
-					ExtFragPtr->ShipInfo.actual_strength =
-							(COUNT)FragPtr->ShipInfo.var2 << 1;
-				ExtFragPtr->ShipInfo.growth_fract = 0;
-				ExtFragPtr->ShipInfo.growth_err_term = 255 >> 1;
-				ExtFragPtr->ShipInfo.energy_level = 0;
-				ExtFragPtr->ShipInfo.days_left = 0;
-				FragPtr->RaceDescPtr = (RACE_DESCPTR)&ExtFragPtr->ShipInfo;
+			FleetPtr->ship_flags = BAD_GUY;
+			FleetPtr->known_strength = 0;
+			FleetPtr->loc = FleetPtr->known_loc;
+			// XXX: Hack: Rebel special case 
+			if (i == YEHAT_REBEL_SHIP)
+				FleetPtr->actual_strength = 0;
+			FleetPtr->growth = 0;
+			FleetPtr->growth_fract = 0;
+			FleetPtr->growth_err_term = 255 >> 1;
+			FleetPtr->days_left = 0;
+			FleetPtr->func_index = ~0;
 
-				UnlockStarShip (&GLOBAL (avail_race_q), hStarShip);
-			}
+			UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+			PutQueue (&GLOBAL (avail_race_q), hFleet);
 		}
 	}
 
@@ -265,7 +268,7 @@ InitSIS (void)
 	InitPlanetInfo ();
 	InitGroupInfo (TRUE);
 
-	GLOBAL (glob_flags) = NUM_READ_SPEEDS >> 1;
+	GLOBAL (glob_flags) = 0;
 
 	GLOBAL (ElementWorth[COMMON]) = 1;
 	GLOBAL_SIS (ElementAmounts[COMMON]) = 0;
@@ -303,9 +306,11 @@ InitSIS (void)
 
 	InitQueue (&GLOBAL (built_ship_q),
 			MAX_BUILT_SHIPS, sizeof (SHIP_FRAGMENT));
-	InitQueue (&GLOBAL (npc_built_ship_q),
-			(MAX_BATTLE_GROUPS >> 1), sizeof (SHIP_FRAGMENT));
-	InitQueue (&GLOBAL (encounter_q), 16, sizeof (ENCOUNTER));
+	InitQueue (&GLOBAL (npc_built_ship_q), MAX_SHIPS_PER_SIDE,
+			sizeof (SHIP_FRAGMENT));
+	InitQueue (&GLOBAL (ip_group_q), MAX_BATTLE_GROUPS,
+			sizeof (IP_GROUP));
+	InitQueue (&GLOBAL (encounter_q), MAX_ENCOUNTERS, sizeof (ENCOUNTER));
 
 	GLOBAL (CurrentActivity) = IN_INTERPLANETARY | START_INTERPLANETARY;
 
@@ -329,13 +334,14 @@ InitSIS (void)
 			sizeof (GLOBAL_SIS (CommanderName)),
 			GAME_STRING (NAMING_STRING_BASE + 3));
 
-	ActivateStarShip (HUMAN_SHIP, 0);
+	ActivateStarShip (HUMAN_SHIP, SET_ALLIED);
 	CloneShipFragment (HUMAN_SHIP, &GLOBAL (built_ship_q), 0);
 
 	GLOBAL_SIS (log_x) = UNIVERSE_TO_LOGX (SOL_X);
 	GLOBAL_SIS (log_y) = UNIVERSE_TO_LOGY (SOL_Y);
 	CurStarDescPtr = 0;
-	GLOBAL (autopilot.x) = GLOBAL (autopilot.y) = ~0;
+	GLOBAL (autopilot.x) = ~0;
+	GLOBAL (autopilot.y) = ~0;
 
 	/* In case the program is exited before the full game is terminated,
 	 * make sure that the temporary files are deleted.
@@ -354,7 +360,7 @@ InitSIS (void)
 void
 FreeSC2Data (void)
 {
-	DestroyContext (ReleaseContext (RadarContext));
+	DestroyContext (RadarContext);
 	RadarContext = 0;
 	DestroyDrawable (ReleaseDrawable (FontGradFrame));
 	FontGradFrame = 0;
@@ -367,12 +373,13 @@ FreeSC2Data (void)
 void
 UninitSIS (void)
 {
-	HSTARSHIP hStarShip;
+	HFLEETINFO hStarShip;
 
 	if (!initedSIS)
 		return;
 
 	UninitQueue (&GLOBAL (encounter_q));
+	UninitQueue (&GLOBAL (ip_group_q));
 	UninitQueue (&GLOBAL (npc_built_ship_q));
 	UninitQueue (&GLOBAL (built_ship_q));
 	UninitGroupInfo ();
@@ -380,19 +387,18 @@ UninitSIS (void)
 
 //    FreeSC2Data ();
 
+	// The only resources avail_race_q owns are the Ur-Quan probe's
+	// so free them now
 	hStarShip = GetTailLink (&GLOBAL (avail_race_q));
 	if (hStarShip)
 	{
-		STARSHIPPTR StarShipPtr;
+		FLEET_INFO *FleetPtr;
 
-		StarShipPtr = LockStarShip (&GLOBAL (avail_race_q), hStarShip);
-		DestroyDrawable (ReleaseDrawable (
-				StarShipPtr->RaceDescPtr->ship_info.melee_icon));
-		DestroyDrawable (ReleaseDrawable (
-				StarShipPtr->RaceDescPtr->ship_info.icons));
-		DestroyStringTable (ReleaseStringTable (
-				StarShipPtr->RaceDescPtr->ship_info.race_strings));
-		UnlockStarShip (&GLOBAL (avail_race_q), hStarShip);
+		FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
+		DestroyDrawable (ReleaseDrawable (FleetPtr->melee_icon));
+		DestroyDrawable (ReleaseDrawable (FleetPtr->icons));
+		DestroyStringTable (ReleaseStringTable (FleetPtr->race_strings));
+		UnlockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
 	}
 
 	UninitQueue (&GLOBAL (avail_race_q));
@@ -408,7 +414,7 @@ InitGlobData (void)
 	COUNT i;
 
 	i = GLOBAL (glob_flags);
-	memset ((PBYTE)&GlobData, 0, sizeof (GlobData));
+	memset (&GlobData, 0, sizeof (GlobData));
 	GLOBAL (glob_flags) = (BYTE)i;
 
 	GLOBAL (DisplayArray) = DisplayArray;
diff -ruNp src.orig/sc2code/globdata.h src/sc2code/globdata.h
--- src.orig/sc2code/globdata.h	2017-11-08 16:49:28 -0600
+++ src/sc2code/globdata.h	2017-11-08 16:49:55 -0600
@@ -21,19 +21,28 @@
 
 #include "clock.h"
 #include "libs/gfxlib.h"
+#include "libs/reslib.h"
 #include "sis.h"
 #include "velocity.h"
 
 
+// XXX: the following should be moved to commanim.h
 // Animation types:
 #define RANDOM_ANIM (1 << 0)
-		// Next index is randomly chose
+		// The next index is randomly chosen.
 #define CIRCULAR_ANIM (1 << 1)
-		//
+		// After the last index has been reached, the animation starts over.
 #define YOYO_ANIM (1 << 2)
+		// After the last index has been reached, the order that the
+		// animation frames are used is reversed.
 #define ANIM_MASK (RANDOM_ANIM | CIRCULAR_ANIM | YOYO_ANIM)
+		// Mask of all animation types.
 
 #define WAIT_TALKING (1 << 3)
+		// This is set in AlienTalkDesc when the ambient animations should
+		// stop at the end of the current animation cycle.
+		// In AlienAmbientArray, this is set for those ambient animations
+		// which can not be active while the talking animation is active.
 #define PAUSE_TALKING (1 << 4)
 #define TALK_INTRO (1 << 5)
 #define TALK_DONE (1 << 6)
@@ -48,7 +57,7 @@ typedef struct
 			// Index of the first image (for image animation) or
 			// index of the first color map (for palette animation)
 	BYTE NumFrames;
-			// number of frames
+			// Number of frames in the animation.
 
 	BYTE AnimFlags;
 			// One of RANDOM_ANIM, CIRCULAR_ANIM, or YOYO_ANIM
@@ -59,9 +68,9 @@ typedef struct
 	COUNT RandomRestartRate;
 
 	DWORD BlockMask;
+			// Bit mask of the indices of all animations that can not
+			// be active at the same time as this animation.
 } ANIMATION_DESC;
-typedef ANIMATION_DESC *PANIMATION_DESC;
-#define ANIMATION_DESCPTR PANIMATION_DESC
 
 #define MAX_ANIMATIONS 20
 
@@ -119,8 +128,6 @@ typedef struct
 	// 0-9, 10-19, ..20-90, ..100-900, etc.
 	SPEECH_DIGIT Digits[MAX_SPEECH_DIGITS];
 } NUMBER_SPEECH_DESC;
-typedef NUMBER_SPEECH_DESC *PNUMBER_SPEECH_DESC;
-#define NUMBER_SPEECH_DESCPTR PNUMBER_SPEECH_DESC
 typedef NUMBER_SPEECH_DESC *NUMBER_SPEECH;
 
 typedef DWORD LDAS_FLAGS;
@@ -136,19 +143,19 @@ typedef struct
 	COUNT (*uninit_encounter_func) (void);
 			/* Called when encounter is done for cleanup */
 
-	FRAME AlienFrame;
-	FONT AlienFont;
+	RESOURCE AlienFrameRes;
+	RESOURCE AlienFontRes;
 	COLOR AlienTextFColor, AlienTextBColor;
 	POINT AlienTextBaseline;
 	COUNT AlienTextWidth;
 	TEXT_ALIGN AlienTextAlign;
 	TEXT_VALIGN AlienTextValign;
-	COLORMAP AlienColorMap;
-	DWORD AlienSong;
-	DWORD AlienAltSong;
+	RESOURCE AlienColorMapRes;
+	RESOURCE AlienSongRes;
+	RESOURCE AlienAltSongRes;
 	LDAS_FLAGS AlienSongFlags;
 
-	STRING ConversationPhrases;
+	RESOURCE ConversationPhrasesRes;
 
 	COUNT NumAnimations;
 	ANIMATION_DESC AlienAmbientArray[MAX_ANIMATIONS];
@@ -157,9 +164,14 @@ typedef struct
 	ANIMATION_DESC AlienTalkDesc;
 
 	NUMBER_SPEECH AlienNumberSpeech;
+
+	FRAME AlienFrame;
+	FONT AlienFont;
+	COLORMAP AlienColorMap;
+	MUSIC_REF AlienSong;
+	STRING ConversationPhrases;
+	
 } LOCDATA;
-typedef LOCDATA *PLOCDATA;
-#define LOCDATAPTR PLOCDATA
 
 enum
 {
@@ -541,6 +553,12 @@ START_GAME_STATE
 	ADD_GAME_STATE (CHMMR_EMERGING, 1)
 	ADD_GAME_STATE (CHMMR_UNLEASHED, 1)
 	ADD_GAME_STATE (CHMMR_BOMB_STATE, 2)
+			/* 0 - Nothing is known about the Precursor Bomb.
+			 * 1 - The captain knows from the Chmmr that some extremely
+			 *     powerful weapon is needed to destroy the Sa-Matra.
+			 * 2 - Installation of the precursor bomb has started.
+			 * 3 - Left the starbase after installation of the Precursor bomb.
+			 */
 
 	ADD_GAME_STATE (DRUUGE_DISCLAIMER, 1)
 
@@ -892,12 +910,10 @@ START_GAME_STATE
 	ADD_GAME_STATE (ORZ_STACK1, 1)
 END_GAME_STATE
 
-#define READ_SPEED_MASK ((1 << 3) - 1)
-#define NUM_READ_SPEEDS 5
+// Values for GAME_STATE.glob_flags:
 #define COMBAT_SPEED_SHIFT 6
 #define COMBAT_SPEED_MASK (((1 << 2) - 1) << COMBAT_SPEED_SHIFT)
 #define NUM_COMBAT_SPEEDS 4
-
 #define MUSIC_DISABLED (1 << 3)
 #define SOUND_DISABLED (1 << 4)
 #define CYBORG_ENABLED (1 << 5)
@@ -929,14 +945,14 @@ typedef UWORD ACTIVITY;
 
 typedef struct
 {
-	// XXX: cur_state is obsolete now and was replaced by process.c:zoom_out
-	BYTE cur_state, glob_flags;
+	BYTE glob_flags;
+			// See above for the meaning of the bits.
 
 	BYTE CrewCost, FuelCost;
 	BYTE ModuleCost[NUM_MODULES];
 	BYTE ElementWorth[NUM_ELEMENT_CATEGORIES];
 
-	PPRIMITIVE DisplayArray;
+	PRIMITIVE *DisplayArray;
 	ACTIVITY CurrentActivity;
 
 	CLOCK_STATE GameClock;
@@ -948,30 +964,37 @@ typedef struct
 
 	DWORD BattleGroupRef;
 	QUEUE avail_race_q;
+			/* List of all the races in the game with information
+			 * about their ships, and what player knows about their
+			 * fleet, center of SoI, status, etc.
+			 * queue element is FLEET_INFO */
 	QUEUE npc_built_ship_q;
-			// Non-player-character list of ships (during encounter)
-			//   or list of groups present in solarsys (during IP)
+			/* Non-player-character list of ships (during encounter)
+			 * queue element is SHIP_FRAGMENT */
+	QUEUE ip_group_q;
+			/* List of groups present in solarsys (during IP);
+			 * queue element is IP_GROUP */
 	QUEUE encounter_q;
+			/* List of HyperSpace encounters (black globes);
+			 * queue element is ENCOUNTER */
 	QUEUE built_ship_q;
-			/* Queue of SIS escort ships */
+			/* List of SIS escort ships;
+			 * queue element is SHIP_FRAGMENT */
 
 	BYTE GameState[(NUM_GAME_STATE_BITS + 7) >> 3];
 } GAME_STATE;
-typedef GAME_STATE *PGAME_STATE;
 
 typedef struct
 {
 	SIS_STATE SIS_state;
 	GAME_STATE Game_state;
 } GLOBDATA;
-typedef GLOBDATA *PGLOBDATA;
 
 extern GLOBDATA GlobData;
 #define GLOBAL(f) GlobData.Game_state.f
 #define GLOBAL_SIS(f) GlobData.SIS_state.f
 
-#define GLOBDATAPTR PGLOBDATA
-
+#define MAX_ENCOUNTERS  16
 
 //#define STATE_DEBUG
 	
@@ -1010,9 +1033,6 @@ extern void setGameState32 (int startBit
 	
 extern CONTEXT RadarContext;
 
-extern void DiscardStarMap (PVOID CodeRef);
-extern void RetrieveStarMap (void);
-
 extern void FreeSC2Data (void);
 extern BOOLEAN LoadSC2Data (void);
 
diff -ruNp src.orig/sc2code/gravity.c src/sc2code/gravity.c
--- src.orig/sc2code/gravity.c	2017-11-08 16:49:28 -0600
+++ src/sc2code/gravity.c	2017-11-08 16:49:55 -0600
@@ -24,7 +24,7 @@
 //#define DEBUG_GRAVITY
 
 BOOLEAN
-CalculateGravity (PELEMENT ElementPtr)
+CalculateGravity (ELEMENT *ElementPtr)
 {
 	BOOLEAN retval, HasGravity;
 	HELEMENT hTestElement, hSuccElement;
@@ -36,7 +36,7 @@ CalculateGravity (PELEMENT ElementPtr)
 			hTestElement != 0; hTestElement = hSuccElement)
 	{
 		BOOLEAN TestHasGravity;
-		ELEMENTPTR TestElementPtr;
+		ELEMENT *TestElementPtr;
 
 		LockElement (hTestElement, &TestElementPtr);
 		if (TestElementPtr != ElementPtr
@@ -130,7 +130,7 @@ CalculateGravity (PELEMENT ElementPtr)
 								SINE (angle, WORLD_TO_VELOCITY (1)));
 						if (TestElementPtr->state_flags & PLAYER_SHIP)
 						{
-							STARSHIPPTR StarShipPtr;
+							STARSHIP *StarShipPtr;
 
 							GetElementStarShip (TestElementPtr, &StarShipPtr);
 							StarShipPtr->cur_status_flags &= ~SHIP_AT_MAX_SPEED;
@@ -149,7 +149,7 @@ CalculateGravity (PELEMENT ElementPtr)
 }
 
 BOOLEAN
-TimeSpaceMatterConflict (ELEMENTPTR ElementPtr)
+TimeSpaceMatterConflict (ELEMENT *ElementPtr)
 {
 	HELEMENT hTestElement, hSuccElement;
 	INTERSECT_CONTROL ElementControl;
@@ -165,7 +165,7 @@ TimeSpaceMatterConflict (ELEMENTPTR Elem
 	for (hTestElement = GetHeadElement ();
 			hTestElement != 0; hTestElement = hSuccElement)
 	{
-		ELEMENTPTR TestElementPtr;
+		ELEMENT *TestElementPtr;
 
 		LockElement (hTestElement, &TestElementPtr);
 		hSuccElement = GetSuccElement (TestElementPtr);
diff -ruNp src.orig/sc2code/gravwell.c src/sc2code/gravwell.c
--- src.orig/sc2code/gravwell.c	2017-11-08 16:49:28 -0600
+++ src/sc2code/gravwell.c	1969-12-31 18:00:00 -0600
@@ -1,84 +0,0 @@
-//Copyright Paul Reiche, Fred Ford. 1992-2002
-
-/*
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include "element.h"
-#include "resinst.h"
-#include "nameref.h"
-#include "setup.h"
-
-
-FRAME planet[NUM_VIEWS];
-
-void
-load_gravity_well (BYTE selector)
-{
-	COUNT i;
-	RES_TYPE rt;
-	RES_INSTANCE ri;
-	RES_PACKAGE rp;
-	MEM_HANDLE hLastIndex;
-
-	hLastIndex = SetResourceIndex (hResIndex);
-
-	if (selector == NUMBER_OF_PLANET_TYPES)
-	{
-		planet[0] = CaptureDrawable (
-				LoadGraphic (SAMATRA_BIG_MASK_PMAP_ANIM)
-				);
-		planet[1] = planet[2] = 0;
-	}
-	else
-	{
-		if (selector & PLANET_SHIELDED)
-		{
-			rt = GET_TYPE (SHIELDED_BIG_MASK_PMAP_ANIM);
-			ri = GET_INSTANCE (SHIELDED_BIG_MASK_PMAP_ANIM);
-			rp = GET_PACKAGE (SHIELDED_BIG_MASK_PMAP_ANIM);
-		}
-		else
-		{
-			rt = GET_TYPE (PLANET00_BIG_MASK_PMAP_ANIM);
-			ri = GET_INSTANCE (PLANET00_BIG_MASK_PMAP_ANIM)
-					+ (selector * NUM_VIEWS);
-			rp = GET_PACKAGE (PLANET00_BIG_MASK_PMAP_ANIM)
-					+ selector;
-		}
-
-		for (i = 0; i < NUM_VIEWS; ++i, ++ri)
-		{
-			planet[i] = CaptureDrawable (
-					LoadGraphic (MAKE_RESOURCE (rp, rt, ri))
-					);
-		}
-	}
-
-	SetResourceIndex (hLastIndex);
-}
-
-void
-free_gravity_well (void)
-{
-	COUNT i;
-
-	for (i = 0; i < NUM_VIEWS; ++i)
-	{
-		DestroyDrawable (ReleaseDrawable (planet[i]));
-		planet[i] = 0;
-	}
-}
-
diff -ruNp src.orig/sc2code/grpinfo.c src/sc2code/grpinfo.c
--- src.orig/sc2code/grpinfo.c	2017-11-08 16:49:28 -0600
+++ src/sc2code/grpinfo.c	2017-11-08 16:49:55 -0600
@@ -23,6 +23,7 @@
 #include "intel.h"
 #include "sis.h"
 #include "state.h"
+#include "grpinfo.h"
 
 #include "libs/mathlib.h"
 #include "libs/log.h"
@@ -36,6 +37,13 @@ static BYTE LastEncGroup;
 
 //#define DEBUG_GROUPS
 
+// A group header describes battle groups present in a star system. There is
+//    at most 1 group header per system.
+// 'Random' group info file (RANDGRPINFO_FILE) always contains only one
+//    group header record, which describes the last-visited star system,
+//    (which may be the current system). Thus the randomly generated groups
+//    are valid for 7 days (set in PutGroupInfo) after the player leaves 
+//    the system, or until the player enters another star system.
 typedef struct
 {
 	BYTE NumGroups;
@@ -46,15 +54,16 @@ typedef struct
 			//   by going to HSpace and stay there till such time)
 			// star_index is the index of a star this group header
 			//   applies to; ~0 means uninited
-	DWORD GroupOffset[MAX_BATTLE_GROUPS + 1];
+	DWORD GroupOffset[NUM_SAVED_BATTLE_GROUPS + 1];
 			// Absolute offsets of group definitions in a state file
-			// Group 0 is actually a list of groups present in solarsys
+			// Group 0 is a list of groups present in solarsys
+			//    (RANDGRPINFO_FILE only)
 			// Groups 1..max are definitions of actual battle groups
-			//    containing ships composition and status
+			//    containing ship makeup and status
 
 	// Each group has the following format:
 	// 1 byte, RaceType (LastEncGroup in Group 0)
-	// 1 byte, NumShips
+	// 1 byte, NumShips (NumGroups in Group 0)
 	// Ships follow:
 	// 1 byte, RaceType
 	// 16 bytes, part of SHIP_FRAGMENT struct
@@ -62,7 +71,7 @@ typedef struct
 } GROUP_HEADER;
 
 static void
-ReadGroupHeader (PVOID fp, GROUP_HEADER* pGH)
+ReadGroupHeader (void *fp, GROUP_HEADER *pGH)
 {
 	sread_8   (fp, &pGH->NumGroups);
 	sread_8   (fp, &pGH->day_index);
@@ -70,11 +79,11 @@ ReadGroupHeader (PVOID fp, GROUP_HEADER*
 	sread_8   (fp, NULL); /* padding */
 	sread_16  (fp, &pGH->star_index);
 	sread_16  (fp, &pGH->year_index);
-	sread_a32 (fp, pGH->GroupOffset, MAX_BATTLE_GROUPS + 1);
+	sread_a32 (fp, pGH->GroupOffset, NUM_SAVED_BATTLE_GROUPS + 1);
 }
 
 static void
-WriteGroupHeader (PVOID fp, GROUP_HEADER* pGH)
+WriteGroupHeader (void *fp, const GROUP_HEADER *pGH)
 {
 	swrite_8   (fp, pGH->NumGroups);
 	swrite_8   (fp, pGH->day_index);
@@ -82,75 +91,117 @@ WriteGroupHeader (PVOID fp, GROUP_HEADER
 	swrite_8   (fp, 0); /* padding */
 	swrite_16  (fp, pGH->star_index);
 	swrite_16  (fp, pGH->year_index);
-	swrite_a32 (fp, pGH->GroupOffset, MAX_BATTLE_GROUPS + 1);
+	swrite_a32 (fp, pGH->GroupOffset, NUM_SAVED_BATTLE_GROUPS + 1);
 }
 
 static void
-ReadShipFragment (PVOID fp, SHIP_FRAGMENTPTR FragPtr)
+ReadShipFragment (void *fp, SHIP_FRAGMENT *FragPtr)
 {
 	BYTE tmpb;
 
-	// Read SHIP_FRAGMENT elements
-	sread_16 (fp, &FragPtr->s.Player);
-	sread_8  (fp, &FragPtr->s.Captain);
-	sread_8  (fp, NULL); /* padding */
-	// Read SHIP_INFO elements
-	sread_16 (fp, &FragPtr->ShipInfo.ship_flags);
-	sread_8  (fp, &FragPtr->ShipInfo.var1);
-	sread_8  (fp, &FragPtr->ShipInfo.var2);
+	sread_16 (fp, &FragPtr->which_side);
+	sread_8  (fp, &FragPtr->captains_name_index);
+	sread_8  (fp, NULL); /* padding; for savegame compat */
+	sread_16 (fp, NULL); /* unused: was ship_flags */
+	sread_8  (fp, &FragPtr->race_id);
+	sread_8  (fp, &FragPtr->index);
+	// XXX: reading crew as BYTE to maintain savegame compatibility
 	sread_8  (fp, &tmpb);
-	FragPtr->ShipInfo.crew_level = tmpb;
+	FragPtr->crew_level = tmpb;
 	sread_8  (fp, &tmpb);
-	FragPtr->ShipInfo.max_crew = tmpb;
-	sread_8  (fp, &FragPtr->ShipInfo.energy_level);
-	sread_8  (fp, &FragPtr->ShipInfo.max_energy);
-	sread_16 (fp, &FragPtr->ShipInfo.loc.x);
-	sread_16 (fp, &FragPtr->ShipInfo.loc.y);
+	FragPtr->max_crew = tmpb;
+	sread_8  (fp, &FragPtr->energy_level);
+	sread_8  (fp, &FragPtr->max_energy);
+	sread_16 (fp, NULL); /* unused; was loc.x */
+	sread_16 (fp, NULL); /* unused; was loc.y */
 }
 
 static void
-WriteShipFragment (PVOID fp, SHIP_FRAGMENTPTR FragPtr)
+WriteShipFragment (void *fp, const SHIP_FRAGMENT *FragPtr)
 {
-	// Write SHIP_FRAGMENT elements
-	swrite_16 (fp, FragPtr->s.Player);
-	swrite_8  (fp, FragPtr->s.Captain);
-	swrite_8  (fp, 0); /* padding */
-	// Write SHIP_INFO elements
-	swrite_16 (fp, FragPtr->ShipInfo.ship_flags);
-	swrite_8  (fp, FragPtr->ShipInfo.var1);
-	swrite_8  (fp, FragPtr->ShipInfo.var2);
-	swrite_8  (fp, FragPtr->ShipInfo.crew_level);
-	swrite_8  (fp, FragPtr->ShipInfo.max_crew);
-	swrite_8  (fp, FragPtr->ShipInfo.energy_level);
-	swrite_8  (fp, FragPtr->ShipInfo.max_energy);
-	swrite_16 (fp, FragPtr->ShipInfo.loc.x);
-	swrite_16 (fp, FragPtr->ShipInfo.loc.y);
+	swrite_16 (fp, FragPtr->which_side);
+	swrite_8  (fp, FragPtr->captains_name_index);
+	swrite_8  (fp, 0); /* padding; for savegame compat */
+	swrite_16 (fp, 0); /* unused: was ship_flags */
+	swrite_8  (fp, FragPtr->race_id);
+	swrite_8  (fp, FragPtr->index);
+	// XXX: writing crew as BYTE to maintain savegame compatibility
+	swrite_8  (fp, FragPtr->crew_level);
+	swrite_8  (fp, FragPtr->max_crew);
+	swrite_8  (fp, FragPtr->energy_level);
+	swrite_8  (fp, FragPtr->max_energy);
+	swrite_16 (fp, 0); /* unused; was loc.x */
+	swrite_16 (fp, 0); /* unused; was loc.y */
+}
+
+static void
+ReadIpGroup (void *fp, IP_GROUP *GroupPtr)
+{
+	BYTE tmpb;
+
+	sread_16 (fp, NULL); /* unused; was which_side */
+	sread_8  (fp, NULL); /* unused; was captains_name_index */
+	sread_8  (fp, NULL); /* padding; for savegame compat */
+	sread_16 (fp, &GroupPtr->group_counter);
+	sread_8  (fp, &GroupPtr->race_id);
+	sread_8  (fp, &tmpb); /* was var2 */
+	GroupPtr->sys_loc = LONIBBLE (tmpb);
+	GroupPtr->task = HINIBBLE (tmpb);
+	sread_8  (fp, &GroupPtr->in_system); /* was crew_level */
+	sread_8  (fp, NULL); /* unused; was max_crew */
+	sread_8  (fp, &tmpb); /* was energy_level */
+	GroupPtr->dest_loc = LONIBBLE (tmpb);
+	GroupPtr->orbit_pos = HINIBBLE (tmpb);
+	sread_8  (fp, &GroupPtr->group_id); /* was max_energy */
+	sread_16 (fp, &GroupPtr->loc.x);
+	sread_16 (fp, &GroupPtr->loc.y);
+}
+
+static void
+WriteIpGroup (void *fp, const IP_GROUP *GroupPtr)
+{
+	swrite_16 (fp, 0); /* unused; was which_side */
+	swrite_8  (fp, 0); /* unused; was captains_name_index */
+	swrite_8  (fp, 0); /* padding; for savegame compat */
+	swrite_16 (fp, GroupPtr->group_counter);
+	swrite_8  (fp, GroupPtr->race_id);
+	assert (GroupPtr->sys_loc < 0x10 && GroupPtr->task < 0x10);
+	swrite_8  (fp, MAKE_BYTE (GroupPtr->sys_loc, GroupPtr->task));
+			/* was var2 */
+	swrite_8  (fp, GroupPtr->in_system); /* was crew_level */
+	swrite_8  (fp, 0); /* unused; was max_crew */
+	assert (GroupPtr->dest_loc < 0x10 && GroupPtr->orbit_pos < 0x10);
+	swrite_8  (fp, MAKE_BYTE (GroupPtr->dest_loc, GroupPtr->orbit_pos));
+			/* was energy_level */
+	swrite_8  (fp, GroupPtr->group_id); /* was max_energy */
+	swrite_16 (fp, GroupPtr->loc.x);
+	swrite_16 (fp, GroupPtr->loc.y);
 }
 
 void
 InitGroupInfo (BOOLEAN FirstTime)
 {
-	PVOID fp;
+	void *fp;
+
+	assert (NUM_SAVED_BATTLE_GROUPS >= MAX_BATTLE_GROUPS);
 
 	fp = OpenStateFile (RANDGRPINFO_FILE, "wb");
 	if (fp)
 	{
 		GROUP_HEADER GH;
 
-		GH.NumGroups = 0;
+		memset (&GH, 0, sizeof (GH));
 		GH.star_index = (COUNT)~0;
-		GH.GroupOffset[0] = 0;
 		WriteGroupHeader (fp, &GH);
-
 		CloseStateFile (fp);
 	}
 
 	if (FirstTime && (fp = OpenStateFile (DEFGRPINFO_FILE, "wb")))
 	{
-		// Group headers cannot start with offset 0 in
-		// defined group info file, so bump it
+		// Group headers cannot start with offset 0 in 'defined' group
+		// info file, so bump it (because offset 0 is reserved to
+		// indicate the 'random' group info file).
 		swrite_8 (fp, 0);
-
 		CloseStateFile (fp);
 	}
 }
@@ -162,13 +213,43 @@ UninitGroupInfo (void)
 	DeleteStateFile (RANDGRPINFO_FILE);
 }
 
+HIPGROUP
+BuildGroup (QUEUE *pDstQueue, BYTE race_id)
+{
+	HFLEETINFO hFleet;
+	FLEET_INFO *TemplatePtr;
+	HLINK hGroup;
+	IP_GROUP *GroupPtr;
+
+	assert (GetLinkSize (pDstQueue) == sizeof (IP_GROUP));
+
+	hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q), race_id);
+	if (!hFleet)
+		return 0;
+
+	hGroup = AllocLink (pDstQueue);
+	if (!hGroup)
+		return 0;
+	
+	TemplatePtr = LockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+	GroupPtr = LockIpGroup (pDstQueue, hGroup);
+	memset (GroupPtr, 0, GetLinkSize (pDstQueue));
+	GroupPtr->race_id = race_id;
+	GroupPtr->melee_icon = TemplatePtr->melee_icon;
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+	UnlockIpGroup (pDstQueue, hGroup);
+	PutQueue (pDstQueue, hGroup);
+
+	return hGroup;
+}
+
 void
 BuildGroups (void)
 {
 	BYTE Index, BestIndex;
 	COUNT BestPercent;
 	POINT universe;
-	HSTARSHIP hTemplate, hNextShip;
+	HFLEETINFO hFleet, hNextFleet;
 	BYTE HomeWorld[] =
 	{
 		0,                /* ARILOU_SHIP */
@@ -202,23 +283,37 @@ BuildGroups (void)
 	};
 
 	EncounterPercent[SLYLANDRO_SHIP] *= GET_GAME_STATE (SLYLANDRO_MULTIPLIER);
+
+	/* make Ur-Quan encounters impossible at the ZFP homeworld,
+	 * like their dialog claims */
+	if (CurStarDescPtr->Index == ZOQFOT_DEFINED)
+		EncounterPercent[URQUAN_SHIP] = EncounterPercent[BLACK_URQUAN_SHIP] = 0;
+
 	Index = GET_GAME_STATE (UTWIG_SUPOX_MISSION);
 	if (Index > 1 && Index < 5)
-		HomeWorld[UTWIG_SHIP] = HomeWorld[SUPOX_SHIP] = 0;
+	{
+		// When the Utwig and Supox are on their mission, there won't be
+		// new battle groups generated for the system.
+		// Note that old groups may still exist (in which case this function
+		// would not even be called), but those expire after spending a week
+		// outside of the star system, or when a different star system is
+		// entered.
+		HomeWorld[UTWIG_SHIP] = 0;
+		HomeWorld[SUPOX_SHIP] = 0;
+	}
 
 	BestPercent = 0;
 	universe = CurStarDescPtr->star_pt;
-	for (hTemplate = GetHeadLink (&GLOBAL (avail_race_q)), Index = 0;
-			hTemplate; hTemplate = hNextShip, ++Index)
+	for (hFleet = GetHeadLink (&GLOBAL (avail_race_q)), Index = 0;
+			hFleet; hFleet = hNextFleet, ++Index)
 	{
 		COUNT i, encounter_radius;
-		EXTENDED_SHIP_FRAGMENTPTR TemplatePtr;
+		FLEET_INFO *FleetPtr;
 
-		TemplatePtr = (EXTENDED_SHIP_FRAGMENTPTR)LockStarShip (
-				&GLOBAL (avail_race_q), hTemplate);
-		hNextShip = _GetSuccLink (TemplatePtr);
+		FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+		hNextFleet = _GetSuccLink (FleetPtr);
 
-		if ((encounter_radius = TemplatePtr->ShipInfo.actual_strength)
+		if ((encounter_radius = FleetPtr->actual_strength)
 				&& (i = EncounterPercent[Index]))
 		{
 			SIZE dx, dy;
@@ -229,31 +324,26 @@ BuildGroups (void)
 			if (race_enc && CurStarDescPtr->Index == race_enc)
 			{	// In general, there are always ships at the Homeworld for
 				// the races specified in HomeWorld[] array.
-				// XXX: This code is somewhat broken and the intent is not
-				// 100% clear. Finding a Homeworld does not break you out
-				// of the loop, so another race could override with its
-				// ships when another race's SoI covers the Homeworld.
-				// However, only a race later in the order can do that, so
-				// for example, there will *always* be Yehat Rebel ships
-				// at the Rebel Homeworld, but the same is not true for the
-				// regular Yehat.
 				BestIndex = Index;
 				BestPercent = 70;
 				if (race_enc == SPATHI_DEFINED || race_enc == SUPOX_DEFINED)
 					BestPercent = 2;
-				hNextShip = 0;
+				// Terminate the loop!
+				hNextFleet = 0;
 
 				goto FoundHome;
 			}
 
-			if (encounter_radius == (COUNT)~0)
+			if (encounter_radius == INFINITE_RADIUS)
 				encounter_radius = (MAX_X_UNIVERSE + 1) << 1;
 			else
 				encounter_radius =
 						(encounter_radius * SPHERE_RADIUS_INCREMENT) >> 1;
-			if ((dx = universe.x - TemplatePtr->ShipInfo.loc.x) < 0)
+			dx = universe.x - FleetPtr->loc.x;
+			if (dx < 0)
 				dx = -dx;
-			if ((dy = universe.y - TemplatePtr->ShipInfo.loc.y) < 0)
+			dy = universe.y - FleetPtr->loc.y;
+			if (dy < 0)
 				dy = -dy;
 			if ((COUNT)dx < encounter_radius
 					&& (COUNT)dy < encounter_radius
@@ -265,7 +355,7 @@ BuildGroups (void)
 				// EncounterPercent is only used in practice for the Slylandro
 				// Probes, for the rest of races the chance of encounter is
 				// calced directly below from the distance to the Homeworld
-				if (TemplatePtr->ShipInfo.actual_strength != (COUNT)~0)
+				if (FleetPtr->actual_strength != INFINITE_RADIUS)
 				{
 					i = 70 - (COUNT)((DWORD)square_root (d_squared)
 							* 60L / encounter_radius);
@@ -276,7 +366,7 @@ BuildGroups (void)
 						&& (BestPercent == 0
 						|| (HIWORD (rand_val) % (i + BestPercent)) < i))
 				{
-					if (TemplatePtr->ShipInfo.actual_strength == (COUNT)~0)
+					if (FleetPtr->actual_strength == INFINITE_RADIUS)
 					{	// The prevailing encounter chance is hereby limitted
 						// to 4% for races with infinite SoI (currently, it
 						// is only the Slylandro Probes)
@@ -290,7 +380,7 @@ BuildGroups (void)
 		}
 
 FoundHome:
-		UnlockStarShip (&GLOBAL (avail_race_q), hTemplate);
+		UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
 	}
 
 	if (BestPercent)
@@ -303,8 +393,8 @@ FoundHome:
 
 		which_group = 0;
 		num_groups = ((COUNT)TFB_Random () % (BestPercent >> 1)) + 1;
-		if (num_groups > (MAX_BATTLE_GROUPS >> 1))
-			num_groups = (MAX_BATTLE_GROUPS >> 1);
+		if (num_groups > MAX_BATTLE_GROUPS)
+			num_groups = MAX_BATTLE_GROUPS;
 		else if (num_groups < 5
 				&& (Index = HomeWorld[BestIndex])
 				&& CurStarDescPtr->Index == Index)
@@ -329,429 +419,491 @@ FoundHome:
 }
 
 static void
-FlushGroupInfo (GROUP_HEADER *pGH, DWORD offset, BYTE which_group, PVOID fp)
+FlushGroupInfo (GROUP_HEADER* pGH, DWORD offset, BYTE which_group, void *fp)
 {
-	BYTE RaceType, NumShips;
-	HSTARSHIP hStarShip;
-	SHIP_FRAGMENTPTR FragPtr;
-
 	if (which_group == GROUP_LIST)
 	{
-		QUEUE temp_q;
-		HSTARSHIP hNextShip;
+		HIPGROUP hGroup, hNextGroup;
 
+		/* If the group list was never written before, add it */
 		if (pGH->GroupOffset[0] == 0)
 			pGH->GroupOffset[0] = LengthStateFile (fp);
 
-		temp_q = GLOBAL (npc_built_ship_q);
-		SetHeadLink (&GLOBAL (npc_built_ship_q), 0);
-		SetTailLink (&GLOBAL (npc_built_ship_q), 0);
-		for (hStarShip = GetHeadLink (&temp_q);
-				hStarShip; hStarShip = hNextShip)
+		// XXX: npc_built_ship_q must be empty because the wipe-out
+		//   procedure is actually the writing of the npc_built_ship_q
+		//   out as the group in question
+		assert (!GetHeadLink (&GLOBAL (npc_built_ship_q)));
+
+		/* Weed out the groups that left the system first */
+		for (hGroup = GetHeadLink (&GLOBAL (ip_group_q));
+				hGroup; hGroup = hNextGroup)
 		{
-			COUNT crew_level;
+			BYTE in_system;
+			BYTE group_id;
+			IP_GROUP *GroupPtr;
+
+			GroupPtr = LockIpGroup (&GLOBAL (ip_group_q), hGroup);
+			hNextGroup = _GetSuccLink (GroupPtr);
+			in_system = GroupPtr->in_system;
+			group_id = GroupPtr->group_id;
+			UnlockIpGroup (&GLOBAL (ip_group_q), hGroup);
 
-			FragPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-					&temp_q, hStarShip);
-			hNextShip = _GetSuccLink (FragPtr);
-			crew_level = FragPtr->ShipInfo.crew_level;
-			which_group = GET_GROUP_ID (FragPtr);
-			UnlockStarShip (&temp_q, hStarShip);
-
-			if (crew_level == 0)
+			if (!in_system)
 			{
+				// The following 'if' is needed because GROUP_LIST is only
+				// ever flushed to RANDGRPINFO_FILE, but the current group
+				// may need to be updated in the DEFGRPINFO_FILE as well.
+				// In that case, PutGroupInfo() will update the correct file.
 				if (GLOBAL (BattleGroupRef))
-					PutGroupInfo (GLOBAL (BattleGroupRef), which_group);
+					PutGroupInfo (GLOBAL (BattleGroupRef), group_id);
 				else
-					FlushGroupInfo (pGH, GROUPS_RANDOM, which_group, fp);
-				pGH->GroupOffset[which_group] = 0;
-				RemoveQueue (&temp_q, hStarShip);
-				FreeStarShip (&temp_q, hStarShip);
+					FlushGroupInfo (pGH, GROUPS_RANDOM, group_id, fp);
+				// This will also wipe the group out in the RANDGRPINFO_FILE
+				pGH->GroupOffset[group_id] = 0;
+				RemoveQueue (&GLOBAL (ip_group_q), hGroup);
+				FreeIpGroup (&GLOBAL (ip_group_q), hGroup);
 			}
 		}
-		GLOBAL (npc_built_ship_q) = temp_q;
-
-		which_group = GROUP_LIST;
 	}
 	else if (which_group > pGH->NumGroups)
-	{
+	{	/* Group not present yet -- add it */
 		pGH->NumGroups = which_group;
 		pGH->GroupOffset[which_group] = LengthStateFile (fp);
-
-		hStarShip = GetHeadLink (&GLOBAL (npc_built_ship_q));
-		FragPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-				&GLOBAL (npc_built_ship_q), hStarShip);
-		RaceType = GET_RACE_ID (FragPtr);
-		SeekStateFile (fp, pGH->GroupOffset[which_group], SEEK_SET);
-		swrite_8 (fp, RaceType);
-		UnlockStarShip (&GLOBAL (npc_built_ship_q), hStarShip);
 	}
+	
 	SeekStateFile (fp, offset, SEEK_SET);
 	WriteGroupHeader (fp, pGH);
+
 #ifdef DEBUG_GROUPS
 	log_add (log_Debug, "1)FlushGroupInfo(%lu): WG = %u(%lu), NG = %u, "
 			"SI = %u", offset, which_group, pGH->GroupOffset[which_group],
 			pGH->NumGroups, pGH->star_index);
 #endif /* DEBUG_GROUPS */
 
-	NumShips = (BYTE)CountLinks (&GLOBAL (npc_built_ship_q));
-
-	if (which_group != GROUP_LIST)
-	{	// skip RaceType
-		SeekStateFile (fp, pGH->GroupOffset[which_group] + 1, SEEK_SET);
-	}
-	else
+	if (which_group == GROUP_LIST)
 	{
+		/* Write out ip_group_q as group 0 */
+		HIPGROUP hGroup, hNextGroup;
+		BYTE NumGroups = CountLinks (&GLOBAL (ip_group_q));
+
 		SeekStateFile (fp, pGH->GroupOffset[0], SEEK_SET);
 		swrite_8 (fp, LastEncGroup);
-	}
-	swrite_8 (fp, NumShips);
+		swrite_8 (fp, NumGroups);
 
-	hStarShip = GetHeadLink (&GLOBAL (npc_built_ship_q));
-	while (NumShips--)
-	{
-		HSTARSHIP hNextShip;
-
-		FragPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-				&GLOBAL (npc_built_ship_q), hStarShip
-				);
-		hNextShip = _GetSuccLink (FragPtr);
+		hGroup = GetHeadLink (&GLOBAL (ip_group_q));
+		for ( ; NumGroups; --NumGroups, hGroup = hNextGroup)
+		{
+			IP_GROUP *GroupPtr;
+			
+			GroupPtr = LockIpGroup (&GLOBAL (ip_group_q), hGroup);
+			hNextGroup = _GetSuccLink (GroupPtr);
 
-		RaceType = GET_RACE_ID (FragPtr);
-		swrite_8 (fp, RaceType);
+			swrite_8 (fp, GroupPtr->race_id);
 
 #ifdef DEBUG_GROUPS
-		if (which_group == GROUP_LIST)
 			log_add (log_Debug, "F) type %u, loc %u<%d, %d>, task 0x%02x:%u",
-					RaceType,
-					GET_GROUP_LOC (FragPtr),
-					FragPtr->ShipInfo.loc.x,
-					FragPtr->ShipInfo.loc.y,
-					GET_GROUP_MISSION (FragPtr),
-					GET_GROUP_DEST (FragPtr));
+					GroupPtr->race_id,
+					GET_GROUP_LOC (GroupPtr),
+					GroupPtr->loc.x,
+					GroupPtr->loc.y,
+					GET_GROUP_MISSION (GroupPtr),
+					GET_GROUP_DEST (GroupPtr));
 #endif /* DEBUG_GROUPS */
-		WriteShipFragment (fp, FragPtr);
-		UnlockStarShip (&GLOBAL (npc_built_ship_q), hStarShip);
-		hStarShip = hNextShip;
+
+			WriteIpGroup (fp, GroupPtr);
+			
+			UnlockIpGroup (&GLOBAL (ip_group_q), hGroup);
+		}
+	}
+	else
+	{
+		/* Write out npc_built_ship_q as 'which_group' group */
+		HSHIPFRAG hStarShip, hNextShip;
+		BYTE NumShips = CountLinks (&GLOBAL (npc_built_ship_q));
+		BYTE RaceType = 0;
+
+		hStarShip = GetHeadLink (&GLOBAL (npc_built_ship_q));
+		if (NumShips > 0)
+		{
+			SHIP_FRAGMENT *FragPtr;
+
+			/* The first ship in a group defines the alien race */
+			FragPtr = LockShipFrag (&GLOBAL (npc_built_ship_q), hStarShip);
+			RaceType = FragPtr->race_id;
+			UnlockShipFrag (&GLOBAL (npc_built_ship_q), hStarShip);
+		}
+
+		SeekStateFile (fp, pGH->GroupOffset[which_group], SEEK_SET);
+		swrite_8 (fp, RaceType);
+		swrite_8 (fp, NumShips);
+
+		for ( ; NumShips; --NumShips, hStarShip = hNextShip)
+		{
+			SHIP_FRAGMENT *FragPtr;
+
+			FragPtr = LockShipFrag (&GLOBAL (npc_built_ship_q), hStarShip);
+			hNextShip = _GetSuccLink (FragPtr);
+
+			swrite_8 (fp, FragPtr->race_id);
+			WriteShipFragment (fp, FragPtr);
+
+			UnlockShipFrag (&GLOBAL (npc_built_ship_q), hStarShip);
+		}
 	}
 }
 
 BOOLEAN
 GetGroupInfo (DWORD offset, BYTE which_group)
 {
-	PVOID fp;
+	void *fp;
+	GROUP_HEADER GH;
 
 	if (offset != GROUPS_RANDOM && which_group != GROUP_LIST)
 		fp = OpenStateFile (DEFGRPINFO_FILE, "r+b");
 	else
 		fp = OpenStateFile (RANDGRPINFO_FILE, "r+b");
 
-	if (fp)
-	{
-		BYTE RaceType, NumShips;
-		GROUP_HEADER GH;
-		HSTARSHIP hStarShip;
-		SHIP_FRAGMENTPTR FragPtr;
+	if (!fp)
+		return FALSE;
 
-		SeekStateFile (fp, offset, SEEK_SET);
-		ReadGroupHeader (fp, &GH);
+	SeekStateFile (fp, offset, SEEK_SET);
+	ReadGroupHeader (fp, &GH);
 #ifdef DEBUG_GROUPS
-		log_add (log_Debug, "GetGroupInfo(%lu): %u(%lu) out of %u", offset,
-				which_group, GH.GroupOffset[which_group], GH.NumGroups);
+	log_add (log_Debug, "GetGroupInfo(%lu): %u(%lu) out of %u", offset,
+			which_group, GH.GroupOffset[which_group], GH.NumGroups);
 #endif /* DEBUG_GROUPS */
-		if (which_group == GROUP_INIT_IP)
-		{
-			COUNT month_index, day_index, year_index;
 
-			ReinitQueue (&GLOBAL (npc_built_ship_q));
+	if (which_group == GROUP_INIT_IP)
+	{
+		COUNT month_index, day_index, year_index;
+
+		ReinitQueue (&GLOBAL (ip_group_q));
 #ifdef DEBUG_GROUPS
-			log_add (log_Debug, "%u == %u", GH.star_index,
-					(COUNT)(CurStarDescPtr - star_array));
+		log_add (log_Debug, "%u == %u", GH.star_index,
+				(COUNT)(CurStarDescPtr - star_array));
 #endif /* DEBUG_GROUPS */
-			day_index = GH.day_index;
-			month_index = GH.month_index;
-			year_index = GH.year_index;
-			if (offset == GROUPS_RANDOM
-					&& (GH.star_index != (COUNT)(CurStarDescPtr - star_array)
-					|| !ValidateEvent (ABSOLUTE_EVENT,
-					&month_index, &day_index, &year_index)))
-			{
-				CloseStateFile (fp);
 
+		/* Check if the requested groups are valid for this star system
+		 * and if they are still current (not expired) */
+		day_index = GH.day_index;
+		month_index = GH.month_index;
+		year_index = GH.year_index;
+		if (offset == GROUPS_RANDOM
+				&& (GH.star_index != (COUNT)(CurStarDescPtr - star_array)
+				|| !ValidateEvent (ABSOLUTE_EVENT, &month_index, &day_index,
+					&year_index)))
+		{
 #ifdef DEBUG_GROUPS
-				if (GH.star_index == (COUNT)(CurStarDescPtr - star_array))
-					log_add (log_Debug, "GetGroupInfo: battle groups out of "
-							"date %u/%u/%u!", month_index, day_index,
-							year_index);
+			if (GH.star_index == CurStarDescPtr - star_array)
+				log_add (log_Debug, "GetGroupInfo: battle groups out of "
+						"date %u/%u/%u!", month_index, day_index,
+						year_index);
 #endif /* DEBUG_GROUPS */
-				// Erase random groups (out of date)
-				fp = OpenStateFile (RANDGRPINFO_FILE, "wb");
-				GH.NumGroups = 0;
-				GH.star_index = (COUNT)~0;
-				GH.GroupOffset[0] = 0;
-				WriteGroupHeader (fp, &GH);
-			}
+
+			CloseStateFile (fp);
+			/* Erase random groups (out of date) */
+			fp = OpenStateFile (RANDGRPINFO_FILE, "wb");
+			memset (&GH, 0, sizeof (GH));
+			GH.star_index = (COUNT)~0;
+			WriteGroupHeader (fp, &GH);
+			CloseStateFile (fp);
+			
+			return FALSE;
+		}
+
+		/* Read IP groups into ip_group_q and send them on their missions */
+		for (which_group = 1; which_group <= GH.NumGroups; ++which_group)
+		{
+			BYTE task, group_loc;
+			DWORD rand_val;
+			BYTE RaceType;
+			BYTE NumShips;
+			HIPGROUP hGroup;
+			IP_GROUP *GroupPtr;
+
+			if (GH.GroupOffset[which_group] == 0)
+				continue;
+
+			SeekStateFile (fp, GH.GroupOffset[which_group], SEEK_SET);
+			sread_8 (fp, &RaceType);
+			sread_8 (fp, &NumShips);
+			if (!NumShips)
+				continue; /* group is dead */
+
+			hGroup = BuildGroup (&GLOBAL (ip_group_q), RaceType);
+			GroupPtr = LockIpGroup (&GLOBAL (ip_group_q), hGroup);
+			// XXX: which_side is unused, other than this assign
+			//GroupPtr->which_side = BAD_GUY;
+			GroupPtr->group_id = which_group;
+			GroupPtr->in_system = 1;
+
+			rand_val = TFB_Random ();
+			task = (BYTE)(LOBYTE (LOWORD (rand_val)) % ON_STATION);
+			if (task == FLEE)
+				task = ON_STATION;
+			GroupPtr->orbit_pos = NORMALIZE_FACING (
+					LOBYTE (HIWORD (rand_val)));
+
+			group_loc = pSolarSysState->SunDesc[0].NumPlanets;
+			if (group_loc == 1 && task == EXPLORE)
+				task = IN_ORBIT;
 			else
+				group_loc = (BYTE)((HIBYTE (LOWORD (rand_val)) % group_loc) + 1);
+			GroupPtr->dest_loc = group_loc;
+			rand_val = TFB_Random ();
+			GroupPtr->loc.x = (LOWORD (rand_val) % 10000) - 5000;
+			GroupPtr->loc.y = (HIWORD (rand_val) % 10000) - 5000;
+			GroupPtr->group_counter = 0;
+			if (task == EXPLORE)
 			{
-				for (which_group = 1; which_group <= GH.NumGroups;
-						++which_group)
-				{
-					if (GH.GroupOffset[which_group] == 0)
-						continue;
+				GroupPtr->group_counter = ((COUNT)TFB_Random () %
+						MAX_REVOLUTIONS) << FACING_SHIFT;
+			}
+			else if (task == ON_STATION)
+			{
+				COUNT angle;
+				POINT org;
 
-					SeekStateFile (fp, GH.GroupOffset[which_group], SEEK_SET);
-					sread_8 (fp, &RaceType);
-					sread_8 (fp, &NumShips);
-
-					if (NumShips)
-					{
-						BYTE task, group_loc;
-						DWORD rand_val;
-
-						hStarShip = CloneShipFragment (RaceType,
-								&GLOBAL (npc_built_ship_q), 0);
-						FragPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-								&GLOBAL (npc_built_ship_q), hStarShip);
-						OwnStarShip (FragPtr, BAD_GUY, 0);
-						SET_GROUP_ID (FragPtr, which_group);
-
-						rand_val = TFB_Random ();
-						task = (BYTE)(LOBYTE (LOWORD (rand_val))
-								% ON_STATION);
-						if (task == FLEE)
-							task = ON_STATION;
-						SET_ORBIT_LOC (FragPtr, NORMALIZE_FACING (
-								LOBYTE (HIWORD (rand_val))));
-
-						group_loc = pSolarSysState->SunDesc[0].NumPlanets;
-						if (group_loc == 1 && task == EXPLORE)
-							task = IN_ORBIT;
-						else
-							group_loc = (BYTE)((
-									HIBYTE (LOWORD (rand_val)) % group_loc
-									) + 1);
-						SET_GROUP_DEST (FragPtr, group_loc);
-						rand_val = TFB_Random ();
-						FragPtr->ShipInfo.loc.x =
-								(LOWORD (rand_val) % 10000) - 5000;
-						FragPtr->ShipInfo.loc.y =
-								(HIWORD (rand_val) % 10000) - 5000;
-						if (task == EXPLORE)
-							FragPtr->ShipInfo.group_counter =
-									((COUNT)TFB_Random () % MAX_REVOLUTIONS)
-									<< FACING_SHIFT;
-						else
-						{
-							FragPtr->ShipInfo.group_counter = 0;
-							if (task == ON_STATION)
-							{
-								COUNT angle;
-								POINT org;
-
-								XFormIPLoc (&pSolarSysState->PlanetDesc[
-										group_loc - 1].image.origin, &org,
-										FALSE);
-								angle = FACING_TO_ANGLE (GET_ORBIT_LOC (
-										FragPtr) + 1);
-								FragPtr->ShipInfo.loc.x = org.x
-										+ COSINE (angle, STATION_RADIUS);
-								FragPtr->ShipInfo.loc.y = org.y
-										+ SINE (angle, STATION_RADIUS);
-								group_loc = 0;
-							}
-						}
+				XFormIPLoc (&pSolarSysState->PlanetDesc[group_loc - 1]
+						.image.origin, &org, FALSE);
+				angle = FACING_TO_ANGLE (GroupPtr->orbit_pos + 1);
+				GroupPtr->loc.x = org.x + COSINE (angle, STATION_RADIUS);
+				GroupPtr->loc.y = org.y + SINE (angle, STATION_RADIUS);
+				group_loc = 0;
+			}
 
-						SET_GROUP_MISSION (FragPtr, task);
-						SET_GROUP_LOC (FragPtr, group_loc);
+			GroupPtr->task = task;
+			GroupPtr->sys_loc = group_loc;
 
 #ifdef DEBUG_GROUPS
-						log_add (log_Debug, "battle group %u(0x%04x) strength "
-								"%u, type %u, loc %u<%d, %d>, task %u",
-								which_group,
-								hStarShip,
-								NumShips,
-								RaceType,
-								group_loc,
-								FragPtr->ShipInfo.loc.x,
-								FragPtr->ShipInfo.loc.y,
-								task);
+			log_add (log_Debug, "battle group %u(0x%04x) strength "
+					"%u, type %u, loc %u<%d, %d>, task %u",
+					which_group,
+					hGroup,
+					NumShips,
+					RaceType,
+					group_loc,
+					GroupPtr->loc.x,
+					GroupPtr->loc.y,
+					task);
 #endif /* DEBUG_GROUPS */
-						UnlockStarShip (&GLOBAL (npc_built_ship_q),
-								hStarShip);
-					}
-				}
 
-				if (offset != GROUPS_RANDOM)
-					InitGroupInfo (FALSE); 	/* Wipe out random battle groups */
-				else if (ValidateEvent (ABSOLUTE_EVENT, /* still fresh */
-						&month_index, &day_index, &year_index))
-				{
-					CloseStateFile (fp);
-					return (TRUE);
-				}
-			}
+			UnlockIpGroup (&GLOBAL (ip_group_q), hGroup);
 		}
-		else if (GH.GroupOffset[which_group])
+
+		if (offset != GROUPS_RANDOM)
+			InitGroupInfo (FALSE); 	/* Wipe out random battle groups */
+		else if (ValidateEvent (ABSOLUTE_EVENT, /* still fresh */
+					&month_index, &day_index, &year_index))
 		{
-			COUNT ShipsLeft;
+			CloseStateFile (fp);
+			return TRUE;
+		}
 
-			ShipsLeft = CountLinks (&GLOBAL (npc_built_ship_q));
-			if (which_group == GROUP_LIST)
-			{
-				SeekStateFile (fp, GH.GroupOffset[0], SEEK_SET);
-				sread_8 (fp, &LastEncGroup);
+		CloseStateFile (fp);
+		return (GetHeadLink (&GLOBAL (ip_group_q)) != 0);
+	}
+	
+	if (!GH.GroupOffset[which_group])
+	{
+		/* Group not present */
+		CloseStateFile (fp);
+		return FALSE;
+	}
 
-				if (LastEncGroup)
-				{
-					if (GLOBAL (BattleGroupRef))
-						PutGroupInfo (GLOBAL (BattleGroupRef), LastEncGroup);
-					else
-						FlushGroupInfo (&GH, offset, LastEncGroup, fp);
-				}
-			}
-			else
-			{
-				LastEncGroup = which_group;
-				if (offset != GROUPS_RANDOM)
-					PutGroupInfo (GROUPS_RANDOM, GROUP_LIST);
-				else
-					FlushGroupInfo (&GH, GROUPS_RANDOM, GROUP_LIST, fp);
-			}
-			ReinitQueue (&GLOBAL (npc_built_ship_q));
 
-			// skip RaceType
-			SeekStateFile (fp, GH.GroupOffset[which_group] + 1, SEEK_SET);
-			
-			sread_8 (fp, &NumShips);
-			while (NumShips--)
-			{
-				sread_8 (fp, &RaceType);
+	if (which_group == GROUP_LIST)
+	{
+		BYTE NumGroups;
+		COUNT ShipsLeftInLEG;
 
-				hStarShip = CloneShipFragment (RaceType,
-						&GLOBAL (npc_built_ship_q), 0);
+		// XXX: Hack: First, save the state of last encountered group, if any.
+		//   The assumption here is that we read the group list immediately
+		//   after an IP encounter, and npc_built_ship_q contains whatever
+		//   ships are left in the encountered group (can be none).
+		ShipsLeftInLEG = CountLinks (&GLOBAL (npc_built_ship_q));
+		
+		SeekStateFile (fp, GH.GroupOffset[0], SEEK_SET);
+		sread_8 (fp, &LastEncGroup);
 
-				FragPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-						&GLOBAL (npc_built_ship_q), hStarShip);
-				ReadShipFragment (fp, FragPtr);
+		if (LastEncGroup)
+		{
+			// The following 'if' is needed because GROUP_LIST is only
+			// ever read from RANDGRPINFO_FILE, but the LastEncGroup
+			// may need to be updated in the DEFGRPINFO_FILE as well.
+			// In that case, PutGroupInfo() will update the correct file.
+			if (GLOBAL (BattleGroupRef))
+				PutGroupInfo (GLOBAL (BattleGroupRef), LastEncGroup);
+			else
+				FlushGroupInfo (&GH, offset, LastEncGroup, fp);
+		}
+		ReinitQueue (&GLOBAL (npc_built_ship_q));
+
+		/* Read group 0 into ip_group_q */
+		ReinitQueue (&GLOBAL (ip_group_q));
+		/* Need a seek because Put/Flush has moved the file ptr */
+		SeekStateFile (fp, GH.GroupOffset[0] + 1, SEEK_SET);
+		sread_8 (fp, &NumGroups);
+
+		while (NumGroups--)
+		{
+			BYTE group_id;
+			BYTE RaceType;
+			HSHIPFRAG hGroup;
+			IP_GROUP *GroupPtr;
+
+			sread_8 (fp, &RaceType);
+
+			hGroup = BuildGroup (&GLOBAL (ip_group_q), RaceType);
+			GroupPtr = LockIpGroup (&GLOBAL (ip_group_q), hGroup);
+			ReadIpGroup (fp, GroupPtr);
+			group_id = GroupPtr->group_id;
 
 #ifdef DEBUG_GROUPS
-				if (which_group == GROUP_LIST)
-					log_add (log_Debug, "G) type %u, loc %u<%d, %d>, "
-							"task 0x%02x:%u",
-							RaceType,
-							GET_GROUP_LOC (FragPtr),
-							FragPtr->ShipInfo.loc.x,
-							FragPtr->ShipInfo.loc.y,
-							GET_GROUP_MISSION (FragPtr),
-							GET_GROUP_DEST (FragPtr));
-#endif /* DEBUG_GROUPS */
-				if (GET_GROUP_ID (FragPtr) != LastEncGroup
-						|| which_group != GROUP_LIST
-						|| ShipsLeft)
-				{
-#ifdef DEBUG_GROUPS
-					log_add (log_Debug, "\n");
+			log_add (log_Debug, "G) type %u, loc %u<%d, %d>, task 0x%02x:%u",
+					RaceType,
+					GroupPtr->sys_loc,
+					GroupPtr->loc.x,
+					GroupPtr->loc.y,
+					GroupPtr->task,
+					GroupPtr->dest_loc);
 #endif /* DEBUG_GROUPS */
-					if (RaceType == SHOFIXTI_SHIP
-							&& which_group != GROUP_LIST
-							&& !GET_GAME_STATE (SHOFIXTI_RECRUITED))
-					{
-						BYTE captains_name_index;
-
-						if (!GET_GAME_STATE (SHOFIXTI_KIA))
-							captains_name_index =
-									NAME_OFFSET + NUM_CAPTAINS_NAMES;
-						else
-							captains_name_index =
-									NAME_OFFSET + NUM_CAPTAINS_NAMES + 1;
-						OwnStarShip (FragPtr, BAD_GUY, captains_name_index);
-					}
-					UnlockStarShip (&GLOBAL (npc_built_ship_q), hStarShip);
-				}
-				else
-				{
+
+			UnlockIpGroup (&GLOBAL (ip_group_q), hGroup);
+
+			if (group_id == LastEncGroup && !ShipsLeftInLEG)
+			{
+				/* No ships left in the last encountered group, remove it */
 #ifdef DEBUG_GROUPS
-					log_add (log_Debug, " -- REMOVING");
+				log_add (log_Debug, " -- REMOVING");
 #endif /* DEBUG_GROUPS */
-					UnlockStarShip (&GLOBAL (npc_built_ship_q), hStarShip);
-					RemoveQueue (&GLOBAL (npc_built_ship_q), hStarShip);
-					FreeStarShip (&GLOBAL (npc_built_ship_q), hStarShip);
-				}
+				RemoveQueue (&GLOBAL (ip_group_q), hGroup);
+				FreeIpGroup (&GLOBAL (ip_group_q), hGroup);
 			}
 		}
 
 		CloseStateFile (fp);
+		return (GetHeadLink (&GLOBAL (ip_group_q)) != 0);
 	}
+	else
+	{
+		/* Read 'which_group' group into npc_built_ship_q */
+		BYTE NumShips;
+
+		// XXX: Hack: The assumption here is that we only read the makeup
+		//   of a particular group when initializing an encounter, which
+		//   makes this group 'last encountered'. Also the state of all
+		//   groups is saved here. This may make working with savegames
+		//   harder in the future, as special care will have to be taken
+		//   when loading a game into an encounter.
+		LastEncGroup = which_group;
+		// The following 'if' is needed because GROUP_LIST is only
+		// ever written to RANDGRPINFO_FILE, but the group we are reading
+		// may be in the DEFGRPINFO_FILE as well.
+		// In that case, PutGroupInfo() will update the correct file.
+		// Always calling PutGroupInfo() here would also be acceptable now.
+		if (offset != GROUPS_RANDOM)
+			PutGroupInfo (GROUPS_RANDOM, GROUP_LIST);
+		else
+			FlushGroupInfo (&GH, GROUPS_RANDOM, GROUP_LIST, fp);
+		ReinitQueue (&GLOBAL (ip_group_q));
+
+		ReinitQueue (&GLOBAL (npc_built_ship_q));
+		// skip RaceType
+		SeekStateFile (fp, GH.GroupOffset[which_group] + 1, SEEK_SET);
+		sread_8 (fp, &NumShips);
 
-	return (GetHeadLink (&GLOBAL (npc_built_ship_q)) != 0);
+		while (NumShips--)
+		{
+			BYTE RaceType;
+			HSHIPFRAG hStarShip;
+			SHIP_FRAGMENT *FragPtr;
+
+			sread_8 (fp, &RaceType);
+
+			hStarShip = CloneShipFragment (RaceType,
+					&GLOBAL (npc_built_ship_q), 0);
+
+			FragPtr = LockShipFrag (&GLOBAL (npc_built_ship_q), hStarShip);
+			ReadShipFragment (fp, FragPtr);
+			UnlockShipFrag (&GLOBAL (npc_built_ship_q), hStarShip);
+		}
+
+		CloseStateFile (fp);
+		return (GetHeadLink (&GLOBAL (npc_built_ship_q)) != 0);
+	}
 }
 
 DWORD
 PutGroupInfo (DWORD offset, BYTE which_group)
 {
-	PVOID fp;
+	void *fp;
+	GROUP_HEADER GH;
 
 	if (offset != GROUPS_RANDOM && which_group != GROUP_LIST)
 		fp = OpenStateFile (DEFGRPINFO_FILE, "r+b");
 	else
 		fp = OpenStateFile (RANDGRPINFO_FILE, "r+b");
 
-	if (fp)
-	{
-		GROUP_HEADER GH;
+	if (!fp)
+		return offset;
 
-		if (offset == GROUPS_ADD_NEW)
-		{
-			offset = LengthStateFile (fp);
-			SeekStateFile (fp, offset, SEEK_SET);
-			// XXX: All important fields are inited here, and the
-			//   rest are inited below
-			GH.NumGroups = 0;
-			GH.star_index = (COUNT)~0;
-			GH.GroupOffset[0] = 0;
-			WriteGroupHeader (fp, &GH);
-		}
+	if (offset == GROUPS_ADD_NEW)
+	{
+		offset = LengthStateFile (fp);
+		SeekStateFile (fp, offset, SEEK_SET);
+		memset (&GH, 0, sizeof (GH));
+		GH.star_index = (COUNT)~0;
+		WriteGroupHeader (fp, &GH);
+	}
 
-		if (which_group != GROUP_LIST)
+	// XXX: This is a bit dangerous. The assumption here is that we are
+	//   only called to write GROUP_LIST in the GROUPS_RANDOM context,
+	//   which is true right now and in which case we would seek to 0 anyway.
+	//   The latter also makes guarding the seek with
+	//   'if (which_group != GROUP_LIST)' moot.
+	if (which_group != GROUP_LIST)
+	{
+		SeekStateFile (fp, offset, SEEK_SET);
+		if (which_group == GROUP_SAVE_IP)
 		{
-			SeekStateFile (fp, offset, SEEK_SET);
-			if (which_group == GROUP_SAVE_IP)
-			{
-				LastEncGroup = 0;
-				which_group = GROUP_LIST;
-			}
+			LastEncGroup = 0;
+			which_group = GROUP_LIST;
 		}
-		ReadGroupHeader (fp, &GH);
+	}
+	ReadGroupHeader (fp, &GH);
 
 #ifdef NEVER
-		if (GetHeadLink (&GLOBAL (npc_built_ship_q))
-				|| GH.GroupOffset[0] == 0)
+	// XXX: this appears to be a remnant of a slightly different group info
+	//   expiration mechanism. Nowadays, the 'defined' groups never expire,
+	//   and the dead 'random' groups stay in the file with NumShips==0 until
+	//   the entire 'random' group header expires.
+	if (GetHeadLink (&GLOBAL (npc_built_ship_q)) || GH.GroupOffset[0] == 0)
 #endif /* NEVER */
-		{
-			COUNT month_index, day_index, year_index;
+	{
+		COUNT month_index, day_index, year_index;
+
+		/* The groups in this system are good for the next 7 days */
+		month_index = 0;
+		day_index = 7;
+		year_index = 0;
+		ValidateEvent (RELATIVE_EVENT, &month_index, &day_index, &year_index);
+		GH.day_index = (BYTE)day_index;
+		GH.month_index = (BYTE)month_index;
+		GH.year_index = year_index;
+	}
+	GH.star_index = CurStarDescPtr - star_array;
 
-			month_index = 0;
-			day_index = 7;
-			year_index = 0;
-			ValidateEvent (RELATIVE_EVENT, &month_index, &day_index,
-					&year_index);
-			GH.day_index = (BYTE)day_index;
-			GH.month_index = (BYTE)month_index;
-			GH.year_index = year_index;
-		}
-		GH.star_index = CurStarDescPtr - star_array;
 #ifdef DEBUG_GROUPS
-		log_add (log_Debug, "PutGroupInfo(%lu): %u out of %u -- %u/%u/%u",
-				offset, which_group, GH.NumGroups,
-				GH.month_index, GH.day_index, GH.year_index);
+	log_add (log_Debug, "PutGroupInfo(%lu): %u out of %u -- %u/%u/%u",
+			offset, which_group, GH.NumGroups,
+			GH.month_index, GH.day_index, GH.year_index);
 #endif /* DEBUG_GROUPS */
 
-		FlushGroupInfo (&GH, offset, which_group, fp);
+	FlushGroupInfo (&GH, offset, which_group, fp);
 
-		CloseStateFile (fp);
-	}
+	CloseStateFile (fp);
 
 	return (offset);
 }
 
-
diff -ruNp src.orig/sc2code/grpinfo.h src/sc2code/grpinfo.h
--- src.orig/sc2code/grpinfo.h	1969-12-31 18:00:00 -0600
+++ src/sc2code/grpinfo.h	2017-11-08 16:49:55 -0600
@@ -0,0 +1,84 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _GRPINFO_H
+#define _GRPINFO_H
+
+#include "port.h"
+#include "libs/compiler.h"
+#include "displist.h"
+#include "libs/gfxlib.h"
+		// for POINT
+#include <assert.h>
+
+typedef HLINK HIPGROUP;
+
+typedef struct
+{
+	// LINK elements; must be first
+	HIPGROUP pred;
+	HIPGROUP succ;
+
+	/* unused: COUNT which_side; */
+
+	UWORD group_counter;
+	BYTE race_id;
+	BYTE sys_loc;
+	BYTE task;  // AKA mission
+	BYTE in_system;
+			// a simple != 0 flag
+			// In older savegames this will be >1, because
+			//   CloneShipFragment was used to spawn groups,
+			//   and it set this to crew_level values
+	
+	BYTE dest_loc;
+	BYTE orbit_pos;
+			/* Also: saved prev dest_loc before intercept call,
+			 *   restored to dest_loc on all-clear */
+	BYTE group_id;
+	POINT loc;
+
+	FRAME melee_icon;
+} IP_GROUP;
+
+enum
+{
+	IN_ORBIT = 0,
+	EXPLORE,
+	FLEE,
+	ON_STATION,
+
+	IGNORE_FLAGSHIP = 1 << 2,
+	REFORM_GROUP = 1 << 3
+};
+#define MAX_REVOLUTIONS 5
+
+#define STATION_RADIUS 1600
+#define ORBIT_RADIUS 2400
+
+static inline IP_GROUP *
+LockIpGroup (const QUEUE *pq, HIPGROUP h)
+{
+	assert (GetLinkSize (pq) == sizeof (IP_GROUP));
+	return (IP_GROUP *) LockLink (pq, h);
+}
+
+#define UnlockIpGroup(pq, h)  UnlockLink (pq, h)
+#define FreeIpGroup(pq, h)    FreeLink (pq, h)
+
+extern HIPGROUP BuildGroup (QUEUE *pDstQueue, BYTE race_id);
+
+#endif /* _GRPINFO_H */
diff -ruNp src.orig/sc2code/hyper.c src/sc2code/hyper.c
--- src.orig/sc2code/hyper.c	2017-11-08 16:49:28 -0600
+++ src/sc2code/hyper.c	2017-11-08 16:49:55 -0600
@@ -30,10 +30,10 @@
 #include "setup.h"
 #include "sounds.h"
 #include "libs/graphics/gfx_common.h"
+#include "libs/graphics/drawable.h"
 #include "libs/mathlib.h"
 
 
-
 #define XOFFS ((RADAR_SCAN_WIDTH + (UNIT_SCREEN_WIDTH << 2)) >> 1)
 #define YOFFS ((RADAR_SCAN_HEIGHT + (UNIT_SCREEN_HEIGHT << 2)) >> 1)
 
@@ -42,8 +42,112 @@ static COLORMAP hypercmaps[2];
 static BYTE fuel_ticks;
 static COUNT hyper_dx, hyper_dy, hyper_extra;
 
+/*
+ * draws the melee icon for the battle group inside the black holes,
+ * so you can see who's chasing you.
+ */
+static void
+decorate_vortex (ELEMENT * ElementPtr)
+{
+	HENCOUNTER hEncounter, hNextEncounter;
+	FRAME f = NULL;
+	static FRAME vortex_ships[NUM_AVAILABLE_RACES];
+
+	// The element is still spawning, nothing to do yet
+	if (ElementPtr->death_func)
+		return;
+
+	// The element doesn't know what kind of ship it is, that
+	// info is stored in the encounter queue.  I'm guessing this
+	// needs refactoring
+	for (hEncounter = GetHeadEncounter ();
+			hEncounter != 0; hEncounter = hNextEncounter)
+	{
+		ENCOUNTER *EncounterPtr;
+
+		LockEncounter (hEncounter, &EncounterPtr);
+		hNextEncounter = GetSuccEncounter (EncounterPtr);
+		if (EncounterPtr->hElement)
+		{
+			ELEMENT *EncounterElementPtr;
+
+			LockElement (EncounterPtr->hElement, &EncounterElementPtr);
+			if (EncounterElementPtr == ElementPtr)
+			{
+				HFLEETINFO hFleet;
+				FLEET_INFO *FleetPtr;
+
+				if (vortex_ships[EncounterPtr->SD.Type])
+				{
+					if (ElementPtr->next.image.frame != vortex_ships[EncounterPtr->SD.Type])
+						ElementPtr->next.image.frame = vortex_ships[EncounterPtr->SD.Type];
+				}
+				else
+				{
+					hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q),
+							EncounterPtr->SD.Type);
+					if (hFleet)
+					{
+						FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q),
+								hFleet);
+						f = SetAbsFrameIndex (FleetPtr->melee_icon, 1);
+						UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+					}
+
+					// now make a frame, and use a context to scribble
+					// into it with DrawStamp().  uses a static array to
+					// reuse generated frames for the life of the game
+					// (or multiple games) as a dodge around figuring out
+					// a sensible memory management strategy  ;)
+					if (f)
+					{
+						CONTEXT tmp, old;
+						COLOR trans;
+						STAMP s;
+
+						vortex_ships[EncounterPtr->SD.Type] = CaptureDrawable (
+								CreateDrawable (WANT_PIXMAP | WANT_ALPHA,
+								GetFrameWidth (ElementPtr->next.image.frame),
+								GetFrameHeight (ElementPtr->next.image.frame), 1));
+						tmp = CreateContext ();
+						old = SetContext (tmp);
+						SetContextFGFrame (vortex_ships[EncounterPtr->SD.Type]);
+						trans = BUILD_COLOR (MAKE_RGB15 (0x10, 0x00, 0x10), 0x00);
+						SetContextBackGroundColor (trans);
+						ClearDrawable ();
+						SetFrameTransparentColor (vortex_ships[EncounterPtr->SD.Type], trans); 
+
+						// the original element
+						s.frame = ElementPtr->current.image.frame;
+						s.origin = GetFrameHot (s.frame);
+						DrawStamp (&s);
+
+						// the overlaid gfx
+						s.frame = f;
+						DrawStamp (&s);
+
+						// important to make sure the
+						// collision animation looks correct
+						SetFrameHot (vortex_ships[EncounterPtr->SD.Type],
+								s.origin);
+
+						// cleanup
+						SetContext (old);
+						DestroyContext (tmp);
+						vortex_ships[EncounterPtr->SD.Type]->parent = 
+								ElementPtr->current.image.frame->parent;
+						ElementPtr->next.image.frame = vortex_ships[EncounterPtr->SD.Type];
+					}
+				}
+			}
+			UnlockElement (EncounterPtr->hElement);
+		}
+		UnlockEncounter (hEncounter);
+	}
+}
+
 void
-MoveSIS (PSIZE pdx, PSIZE pdy)
+MoveSIS (SIZE *pdx, SIZE *pdy)
 {
 	SIZE new_dx, new_dy;
 
@@ -81,7 +185,7 @@ MoveSIS (PSIZE pdx, PSIZE pdy)
 		for (hElement = GetTailElement ();
 				hElement != 0; hElement = hNextElement)
 		{
-			ELEMENTPTR ElementPtr;
+			ELEMENT *ElementPtr;
 
 			LockElement (hElement, &ElementPtr);
 
@@ -143,7 +247,7 @@ check_hyperspace_encounter (void)
 {
 	BYTE Type;
 	POINT universe;
-	HSTARSHIP hStarShip, hNextShip;
+	HFLEETINFO hStarShip, hNextShip;
 	COUNT EncounterPercent[] =
 	{
 		RACE_HYPERSPACE_PERCENT
@@ -156,29 +260,29 @@ check_hyperspace_encounter (void)
 			hStarShip = hNextShip, ++Type)
 	{
 		COUNT encounter_radius;
-		EXTENDED_SHIP_FRAGMENTPTR TemplatePtr;
+		FLEET_INFO *FleetPtr;
 
-		TemplatePtr = (EXTENDED_SHIP_FRAGMENTPTR)LockStarShip (
-				&GLOBAL (avail_race_q),
-				hStarShip
-				);
-		hNextShip = _GetSuccLink (TemplatePtr);
+		FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
+		hNextShip = _GetSuccLink (FleetPtr);
 
-		encounter_radius = TemplatePtr->ShipInfo.actual_strength;
+		encounter_radius = FleetPtr->actual_strength;
 		if (encounter_radius)
 		{
 			BYTE encounter_flags;
 			SIZE dx, dy;
 			COUNT percent;
 			HENCOUNTER hEncounter;
-			ENCOUNTERPTR EncounterPtr;
+			ENCOUNTER *EncounterPtr;
 
 			encounter_flags = 0;
 			percent = EncounterPercent[Type];
-			if (encounter_radius != (COUNT)~0)
+			
+			if (encounter_radius != INFINITE_RADIUS)
+			{
 				encounter_radius =
 						(encounter_radius * SPHERE_RADIUS_INCREMENT) >> 1;
-			else
+			}
+			else /* encounter_radius == infinity */
 			{
 				HENCOUNTER hNextEncounter;
 
@@ -224,9 +328,11 @@ check_hyperspace_encounter (void)
 				}
 			}
 
-			if ((dx = universe.x - TemplatePtr->ShipInfo.loc.x) < 0)
+			dx = universe.x - FleetPtr->loc.x;
+			if (dx < 0)
 				dx = -dx;
-			if ((dy = universe.y - TemplatePtr->ShipInfo.loc.y) < 0)
+			dy = universe.y - FleetPtr->loc.y;
+			if (dy < 0)
 				dy = -dy;
 			if ((COUNT)dx < encounter_radius
 					&& (COUNT)dy < encounter_radius
@@ -240,7 +346,7 @@ check_hyperspace_encounter (void)
 				{
 					LockEncounter (hEncounter, &EncounterPtr);
 					memset (EncounterPtr, 0, sizeof (*EncounterPtr));
-					EncounterPtr->origin = TemplatePtr->ShipInfo.loc;
+					EncounterPtr->origin = FleetPtr->loc;
 					EncounterPtr->radius = encounter_radius;
 					EncounterPtr->SD.Index = encounter_flags;
 					EncounterPtr->SD.Type = Type;
@@ -251,7 +357,7 @@ check_hyperspace_encounter (void)
 			}
 		}
 
-		UnlockStarShip (&GLOBAL (avail_race_q), hStarShip);
+		UnlockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
 	}
 
 	SET_GAME_STATE (USED_BROADCASTER, 0);
@@ -322,7 +428,7 @@ LoadHyperspace (void)
 			RepairSISBorder ();
 		}
 	}
-	DrawSISMessage (NULL_PTR);
+	DrawSISMessage (NULL);
 
 	SetContext (RadarContext);
 	SetContextBackGroundColor (
@@ -370,7 +476,7 @@ FreeHyperspace (void)
 }
 
 static void
-ElementToUniverse (ELEMENTPTR ElementPtr, PPOINT pPt)
+ElementToUniverse (ELEMENT *ElementPtr, POINT *pPt)
 {
 	SDWORD log_x, log_y;
 
@@ -390,13 +496,13 @@ cleanup_hyperspace (void)
 	for (hEncounter = GetHeadEncounter ();
 			hEncounter != 0; hEncounter = hNextEncounter)
 	{
-		ENCOUNTERPTR EncounterPtr;
+		ENCOUNTER *EncounterPtr;
 
 		LockEncounter (hEncounter, &EncounterPtr);
 		hNextEncounter = GetSuccEncounter (EncounterPtr);
 		if (EncounterPtr->hElement)
 		{
-			ELEMENTPTR ElementPtr;
+			ELEMENT *ElementPtr;
 
 			LockElement (EncounterPtr->hElement, &ElementPtr);
 
@@ -421,7 +527,7 @@ typedef enum
 } TRANSITION_TYPE;
 
 static void
-unhyper_transition (PELEMENT ElementPtr)
+unhyper_transition (ELEMENT *ElementPtr)
 {
 	COUNT frame_index;
 
@@ -455,11 +561,11 @@ unhyper_transition (PELEMENT ElementPtr)
 				{
 					POINT pt;
 
-					GLOBAL (autopilot.x) =
-							GLOBAL (autopilot.y) = ~0;
+					GLOBAL (autopilot.x) = ~0;
+					GLOBAL (autopilot.y) = ~0;
 
 					ElementToUniverse (ElementPtr, &pt);
-					CurStarDescPtr = FindStar (NULL_PTR, &pt, 5, 5);
+					CurStarDescPtr = FindStar (NULL, &pt, 5, 5);
 					if (CurStarDescPtr->star_pt.x == ARILOU_HOME_X
 							&& CurStarDescPtr->star_pt.y == ARILOU_HOME_Y)
 					{
@@ -488,7 +594,7 @@ unhyper_transition (PELEMENT ElementPtr)
 						};
 
 						index = CurStarDescPtr
-								- ((STAR_DESCPTR)&star_array[NUM_SOLAR_SYSTEMS + 1]);
+								- &star_array[NUM_SOLAR_SYSTEMS + 1];
 						GLOBAL_SIS (log_x) =
 								UNIVERSE_TO_LOGX (portal_pt[index].x);
 						GLOBAL_SIS (log_y) =
@@ -505,15 +611,13 @@ unhyper_transition (PELEMENT ElementPtr)
 				 */
 				GLOBAL (ShipStamp.frame) = 0;
 				SET_GAME_STATE (USED_BROADCASTER, 0);
-				GLOBAL (autopilot.x) =
-						GLOBAL (autopilot.y) = ~0;
+				GLOBAL (autopilot.x) = ~0;
+				GLOBAL (autopilot.y) = ~0;
 				if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
 				{
 					// From HyperSpace to QuasiSpace.
-					GLOBAL_SIS (log_x) =
-							UNIVERSE_TO_LOGX (QUASI_SPACE_X);
-					GLOBAL_SIS (log_y) =
-							UNIVERSE_TO_LOGY (QUASI_SPACE_Y);
+					GLOBAL_SIS (log_x) = UNIVERSE_TO_LOGX (QUASI_SPACE_X);
+					GLOBAL_SIS (log_y) = UNIVERSE_TO_LOGY (QUASI_SPACE_Y);
 					if (GET_GAME_STATE (PORTAL_COUNTER) == 0)
 					{
 						// Periodically appearing portal.
@@ -530,10 +634,8 @@ unhyper_transition (PELEMENT ElementPtr)
 				{
 					// From QuasiSpace to HyperSpace through the
 					// periodically appearing portal.
-					GLOBAL_SIS (log_x) =
-							UNIVERSE_TO_LOGX (ARILOU_SPACE_X);
-					GLOBAL_SIS (log_y) =
-							UNIVERSE_TO_LOGY (ARILOU_SPACE_Y);
+					GLOBAL_SIS (log_x) = UNIVERSE_TO_LOGX (ARILOU_SPACE_X);
+					GLOBAL_SIS (log_y) = UNIVERSE_TO_LOGY (ARILOU_SPACE_Y);
 					SET_GAME_STATE (ARILOU_SPACE_SIDE, 0);
 				}
 				break;
@@ -548,11 +650,11 @@ unhyper_transition (PELEMENT ElementPtr)
 }
 
 static void
-init_transition (ELEMENTPTR ElementPtr0, ELEMENTPTR ElementPtr1,
+init_transition (ELEMENT *ElementPtr0, ELEMENT *ElementPtr1,
 		TRANSITION_TYPE which_transition)
 {
 	SIZE dx, dy, num_turns;
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	dx = WORLD_TO_VELOCITY (ElementPtr0->next.location.x
 			- ElementPtr1->next.location.x);
@@ -561,7 +663,7 @@ init_transition (ELEMENTPTR ElementPtr0,
 
 	ElementPtr1->state_flags |= NONSOLID;
 	ElementPtr1->preprocess_func = unhyper_transition;
-	ElementPtr1->postprocess_func = NULL_PTR;
+	ElementPtr1->postprocess_func = NULL;
 	ElementPtr1->turn_wait = (BYTE) which_transition;
 
 	GetElementStarShip (ElementPtr1, &StarShipPtr);
@@ -576,7 +678,7 @@ init_transition (ELEMENTPTR ElementPtr0,
 }
 
 BOOLEAN
-hyper_transition (PELEMENT ElementPtr)
+hyper_transition (ELEMENT *ElementPtr)
 {
 	if (ElementPtr->state_flags & APPEARING)
 	{
@@ -596,7 +698,7 @@ hyper_transition (PELEMENT ElementPtr)
 			ElementPtr->preprocess_func =
 						(void (*) (struct element
 								*ElementPtr))hyper_transition;
-			ElementPtr->postprocess_func = NULL_PTR;
+			ElementPtr->postprocess_func = NULL;
 			ElementPtr->state_flags |= NONSOLID;
 			ElementPtr->next.image.frame =
 					SetAbsFrameIndex (ElementPtr->current.image.frame,
@@ -610,7 +712,7 @@ hyper_transition (PELEMENT ElementPtr)
 		frame_index = GetFrameIndex (ElementPtr->current.image.frame);
 		if (frame_index-- <= ANGLE_TO_FACING (FULL_CIRCLE))
 		{
-			STARSHIPPTR StarShipPtr;
+			STARSHIP *StarShipPtr;
 
 			if (frame_index == ANGLE_TO_FACING (FULL_CIRCLE) - 1)
 				frame_index = 0;
@@ -618,7 +720,7 @@ hyper_transition (PELEMENT ElementPtr)
 				frame_index = NORMALIZE_FACING (frame_index);
 
 			GetElementStarShip (ElementPtr, &StarShipPtr);
-			if (frame_index == StarShipPtr->ShipFacing)
+			if (frame_index == NORMALIZE_FACING (StarShipPtr->ShipFacing))
 			{
 				ElementPtr->preprocess_func = ship_preprocess;
 				ElementPtr->postprocess_func = ship_postprocess;
@@ -644,20 +746,20 @@ hyper_transition (PELEMENT ElementPtr)
 }
 
 static void
-hyper_collision (PELEMENT ElementPtr0, PPOINT
-		pPt0, PELEMENT ElementPtr1, PPOINT pPt1)
+hyper_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
 	if ((ElementPtr1->state_flags & PLAYER_SHIP)
 			&& GET_GAME_STATE (PORTAL_COUNTER) == 0)
 	{
 		SIZE dx, dy;
 		POINT pt;
-		STAR_DESCPTR SDPtr;
-		STARSHIPPTR StarShipPtr;
+		STAR_DESC *SDPtr;
+		STARSHIP *StarShipPtr;
 
 		ElementToUniverse (ElementPtr0, &pt);
 
-		SDPtr = FindStar (NULL_PTR, &pt, 5, 5);
+		SDPtr = FindStar (NULL, &pt, 5, 5);
 
 		GetElementStarShip (ElementPtr1, &StarShipPtr);
 		GetCurrentVelocityComponents (&ElementPtr1->velocity, &dx, &dy);
@@ -687,7 +789,7 @@ hyper_collision (PELEMENT ElementPtr0, P
 }
 
 static void
-hyper_death (PELEMENT ElementPtr)
+hyper_death (ELEMENT *ElementPtr)
 {
 	if (!(ElementPtr->state_flags & DEFY_PHYSICS)
 			&& (GLOBAL (CurrentActivity) & IN_BATTLE))
@@ -695,7 +797,7 @@ hyper_death (PELEMENT ElementPtr)
 }
 
 static void
-arilou_space_death (PELEMENT ElementPtr)
+arilou_space_death (ELEMENT *ElementPtr)
 {
 	if (!(ElementPtr->state_flags & DEFY_PHYSICS)
 			|| GET_GAME_STATE (ARILOU_SPACE_COUNTER) == 0)
@@ -712,9 +814,8 @@ arilou_space_death (PELEMENT ElementPtr)
 }
 
 static void
-arilou_space_collision (PELEMENT ElementPtr0,
-		PPOINT pPt0, PELEMENT ElementPtr1, PPOINT
-		pPt1)
+arilou_space_collision (ELEMENT *ElementPtr0,
+		POINT *pPt0, ELEMENT *ElementPtr1, POINT *pPt1)
 {
 	COUNT which_side;
 
@@ -740,14 +841,14 @@ arilou_space_collision (PELEMENT Element
 }
 
 static HELEMENT
-AllocHyperElement (STAR_DESCPTR SDPtr)
+AllocHyperElement (STAR_DESC *SDPtr)
 {
 	HELEMENT hHyperSpaceElement;
 
 	hHyperSpaceElement = AllocElement ();
 	if (hHyperSpaceElement)
 	{
-		ELEMENTPTR HyperSpaceElementPtr;
+		ELEMENT *HyperSpaceElementPtr;
 
 		LockElement (hHyperSpaceElement, &HyperSpaceElementPtr);
 		HyperSpaceElementPtr->state_flags = CHANGING | FINITE_LIFE;
@@ -788,7 +889,7 @@ AddAmbientElement (void)
 	{
 		SIZE dx, dy;
 		DWORD rand_val;
-		ELEMENTPTR HyperSpaceElementPtr;
+		ELEMENT *HyperSpaceElementPtr;
 
 		LockElement (hHyperSpaceElement, &HyperSpaceElementPtr);
 		HyperSpaceElementPtr->state_flags =
@@ -828,7 +929,7 @@ AddAmbientElement (void)
 #define VORTEX_WAIT 1
 
 static void
-encounter_transition (PELEMENT ElementPtr)
+encounter_transition (ELEMENT *ElementPtr)
 {
 	ElementPtr->state_flags &= ~DISAPPEARING;
 	ElementPtr->life_span = 1;
@@ -851,7 +952,7 @@ encounter_transition (PELEMENT ElementPt
 			if (f != ElementPtr->current.image.farray[0])
 				ElementPtr->next.image.frame = f;
 			else
-				ElementPtr->death_func = NULL_PTR;
+				ElementPtr->death_func = NULL;
 		}
 
 		ElementPtr->turn_wait = VORTEX_WAIT;
@@ -859,8 +960,8 @@ encounter_transition (PELEMENT ElementPt
 }
 
 static void
-encounter_collision (PELEMENT ElementPtr0, PPOINT
-		pPt0, PELEMENT ElementPtr1, PPOINT pPt1)
+encounter_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
 
 	if ((ElementPtr1->state_flags & PLAYER_SHIP)
@@ -873,13 +974,13 @@ encounter_collision (PELEMENT ElementPtr
 		for (hEncounter = GetHeadEncounter ();
 				hEncounter != 0; hEncounter = hNextEncounter)
 		{
-			ENCOUNTERPTR EncounterPtr;
+			ENCOUNTER *EncounterPtr;
 
 			LockEncounter (hEncounter, &EncounterPtr);
 			hNextEncounter = GetSuccEncounter (EncounterPtr);
 			if (EncounterPtr->hElement)
 			{
-				ELEMENTPTR ElementPtr;
+				ELEMENT *ElementPtr;
 
 				LockElement (EncounterPtr->hElement, &ElementPtr);
 
@@ -898,8 +999,7 @@ encounter_collision (PELEMENT ElementPtr
 }
 
 static HELEMENT
-AddEncounterElement (ENCOUNTERPTR EncounterPtr,
-		PPOINT puniverse)
+AddEncounterElement (ENCOUNTER *EncounterPtr, POINT *puniverse)
 {
 	BOOLEAN NewEncounter;
 	HELEMENT hElement;
@@ -955,15 +1055,17 @@ AddEncounterElement (ENCOUNTERPTR Encoun
 				NumShips, HINIBBLE (EncounterPtr->SD.Index));
 		for (i = 0; i < NumShips; ++i)
 		{
-			HSTARSHIP hStarShip;
-			SHIP_FRAGMENTPTR TemplatePtr;
+			HFLEETINFO hStarShip;
+			FLEET_INFO *FleetPtr;
+			BRIEF_SHIP_INFO *BSIPtr = &EncounterPtr->ShipList[i];
 
 			hStarShip = GetStarShipFromIndex (&GLOBAL (avail_race_q), Type);
-			TemplatePtr = (SHIP_FRAGMENTPTR)LockStarShip (
-					&GLOBAL (avail_race_q), hStarShip);
-			EncounterPtr->SD.ShipList[i] = TemplatePtr->ShipInfo;
-			EncounterPtr->SD.ShipList[i].var1 = Type;
-			UnlockStarShip (&GLOBAL (avail_race_q), hStarShip);
+			FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
+			BSIPtr->race_id = Type;
+			BSIPtr->crew_level = FleetPtr->crew_level;
+			BSIPtr->max_crew = FleetPtr->max_crew;
+			BSIPtr->max_energy = FleetPtr->max_energy;
+			UnlockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
 		}
 
 
@@ -999,8 +1101,7 @@ AddEncounterElement (ENCOUNTERPTR Encoun
 	if (hElement)
 	{
 		SIZE i;
-		ELEMENTPTR ElementPtr;
-
+		ELEMENT *ElementPtr;
 
 		LockElement (hElement, &ElementPtr);
 		
@@ -1025,8 +1126,8 @@ AddEncounterElement (ENCOUNTERPTR Encoun
 		}
 
 		ElementPtr->turn_wait = VORTEX_WAIT;
-		ElementPtr->preprocess_func = NULL_PTR;
-		ElementPtr->postprocess_func = NULL_PTR;
+		ElementPtr->preprocess_func = NULL;
+		ElementPtr->postprocess_func = decorate_vortex;
 		ElementPtr->collision_func = encounter_collision;
 
 		SetUpElement (ElementPtr);
@@ -1098,8 +1199,7 @@ DrawHyperGrid (COORD ux, COORD uy, COORD
 
 
 static void
-ProcessEncounters (PPOINT puniverse, COORD ox,
-		COORD oy)
+ProcessEncounters (POINT *puniverse, COORD ox, COORD oy)
 {
 	STAMP s;
 	HENCOUNTER hEncounter, hNextEncounter;
@@ -1109,7 +1209,7 @@ ProcessEncounters (PPOINT puniverse, COO
 			hEncounter; hEncounter = hNextEncounter)
 	{
 		COORD ex, ey;
-		ENCOUNTERPTR EncounterPtr;
+		ENCOUNTER *EncounterPtr;
 
 		LockEncounter (hEncounter, &EncounterPtr);
 		hNextEncounter = GetSuccEncounter (EncounterPtr);
@@ -1126,7 +1226,7 @@ DeleteEncounter:
 		}
 
 		{
-			ELEMENTPTR ElementPtr;
+			ELEMENT *ElementPtr;
 
 			LockElement (EncounterPtr->hElement, &ElementPtr);
 
@@ -1142,7 +1242,7 @@ DeleteEncounter:
 					else if (EncounterPtr->transition_state ==
 							-NUM_VORTEX_TRANSITIONS)
 					{
-						ElementPtr->death_func = NULL_PTR;
+						ElementPtr->death_func = NULL;
 						UnlockElement (EncounterPtr->hElement);
 						goto DeleteEncounter;
 					}
@@ -1234,7 +1334,7 @@ DeleteEncounter:
 					}
 					else
 					{
-						ElementPtr->death_func = NULL_PTR;
+						ElementPtr->death_func = NULL;
 						UnlockElement (EncounterPtr->hElement);
 						goto DeleteEncounter;
 					}
@@ -1276,7 +1376,7 @@ DeleteEncounter:
 						|| ey - puniverse->y > YOFFS)
 				{
 					ElementPtr->life_span = 0;
-					ElementPtr->death_func = NULL_PTR;
+					ElementPtr->death_func = NULL;
 					UnlockElement (EncounterPtr->hElement);
 
 					goto DeleteEncounter;
@@ -1307,9 +1407,9 @@ SeedUniverse (void)
 	POINT universe;
 	FRAME blip_frame;
 	STAMP s;
-	STAR_DESCPTR SDPtr;
+	STAR_DESC *SDPtr;
 	HELEMENT hHyperSpaceElement;
-	ELEMENTPTR HyperSpaceElementPtr;
+	ELEMENT *HyperSpaceElementPtr;
 
 	ClockTick ();
 
@@ -1440,7 +1540,7 @@ SeedUniverse (void)
 				if (ex <= (XOFFS / NUM_RADAR_SCREENS)
 						&& ey <= (YOFFS / NUM_RADAR_SCREENS)
 						&& (hHyperSpaceElement =
-						AllocHyperElement ((STAR_DESCPTR)&SD[i])) != 0)
+						AllocHyperElement (&SD[i])) != 0)
 				{
 					LockElement (hHyperSpaceElement, &HyperSpaceElementPtr);
 					HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (
@@ -1448,7 +1548,7 @@ SeedUniverse (void)
 							SD[i].Index
 							);
 					HyperSpaceElementPtr->preprocess_func =
-							HyperSpaceElementPtr->postprocess_func = NULL_PTR;
+							HyperSpaceElementPtr->postprocess_func = NULL;
 					HyperSpaceElementPtr->collision_func = arilou_space_collision;
 
 					SetUpElement (HyperSpaceElementPtr);
@@ -1457,7 +1557,7 @@ SeedUniverse (void)
 						HyperSpaceElementPtr->death_func = arilou_space_death;
 					else
 					{
-						HyperSpaceElementPtr->death_func = NULL_PTR;
+						HyperSpaceElementPtr->death_func = NULL;
 						HyperSpaceElementPtr->IntersectControl.IntersectStamp.frame =
 								DecFrameIndex (stars_in_space);
 					}
@@ -1496,7 +1596,7 @@ SeedUniverse (void)
 						+ STAR_COLOR (star_type)
 						);
 				HyperSpaceElementPtr->preprocess_func =
-						HyperSpaceElementPtr->postprocess_func = NULL_PTR;
+						HyperSpaceElementPtr->postprocess_func = NULL;
 				HyperSpaceElementPtr->collision_func = hyper_collision;
 
 				SetUpElement (HyperSpaceElementPtr);
@@ -1506,7 +1606,7 @@ SeedUniverse (void)
 					HyperSpaceElementPtr->death_func = hyper_death;
 				else
 				{
-					HyperSpaceElementPtr->death_func = NULL_PTR;
+					HyperSpaceElementPtr->death_func = NULL;
 					HyperSpaceElementPtr->IntersectControl.IntersectStamp.frame =
 							DecFrameIndex (stars_in_space);
 				}
@@ -1589,7 +1689,7 @@ UnbatchGraphics ();
 	UnlockMutex (GraphicsLock);
 	SuspendGameClock ();
 
-	memset ((PMENU_STATE)&MenuState, 0, sizeof (MenuState));
+	memset (&MenuState, 0, sizeof (MenuState));
 	MenuState.InputFunc = DoFlagshipCommands;
 	MenuState.Initialized = 1;
 	MenuState.CurState = STARMAP + 1;
@@ -1600,10 +1700,10 @@ UnbatchGraphics ();
 	UnlockMutex (GraphicsLock);
 
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
-	DoInput ((PVOID)&MenuState, TRUE);
+	DoInput (&MenuState, TRUE);
 
 	LockMutex (GraphicsLock);
-	SetFlashRect (NULL_PTR, (FRAME)0);
+	SetFlashRect (NULL, (FRAME)0);
 
 	SetContext (SpaceContext);
 
diff -ruNp src.orig/sc2code/ifontres.h src/sc2code/ifontres.h
--- src.orig/sc2code/ifontres.h	2017-11-08 16:49:28 -0600
+++ src/sc2code/ifontres.h	2017-11-08 16:49:55 -0600
@@ -1,10 +1,12 @@
-#define STARCON_FONT 0x03800003L
-#define TINY_FONT 0x03800103L
-#define MICRO_FONT 0x03c00203L
-#define LANDER_FONT 0x11400303L
-#define PLAYER_FONT 0x17a00403L
-
-#define PT13AA_FONT 0x24000503L
-#define PT17AA_FONT 0x24000603L
-#define PT45AA_FONT 0x24000703L
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define LANDER_FONT "font.lander"
+#define MICRO_FONT "font.micro"
+#define PLAYER_FONT "font.player"
+#define PT13AA_FONT "credits.font.pt13"
+#define PT17AA_FONT "credits.font.pt17"
+#define PT45AA_FONT "credits.font.pt45"
+#define STARCON_FONT "font.starcon"
+#define TINY_FONT "font.tiny"
diff -ruNp src.orig/sc2code/igfxres.h src/sc2code/igfxres.h
--- src.orig/sc2code/igfxres.h	2017-11-08 16:49:28 -0600
+++ src/sc2code/igfxres.h	2017-11-08 16:49:55 -0600
@@ -1,272 +1,275 @@
-#define TITLE_ANIM 0x00400002L
-#define STATUS_MASK_PMAP_ANIM 0x03800102L
-#define ACTIVITY_ANIM 0x03800202L
-#define PLAYMENU_ANIM 0x03a00302L
-#define FLAGSTAT_MASK_PMAP_ANIM 0x03e00402L
-#define MISCDATA_MASK_PMAP_ANIM 0x03e00502L
-#define STAR_MASK_PMAP_ANIM 0x04400602L
-#define ASTEROID_BIG_MASK_PMAP_ANIM 0x04400702L
-#define ASTEROID_MED_MASK_PMAP_ANIM 0x04400802L
-#define ASTEROID_SML_MASK_PMAP_ANIM 0x04400902L
-#define BLAST_BIG_MASK_PMAP_ANIM 0x04400a02L
-#define BLAST_MED_MASK_PMAP_ANIM 0x04400b02L
-#define BLAST_SML_MASK_PMAP_ANIM 0x04400c02L
-#define BOOM_BIG_MASK_PMAP_ANIM 0x04400d02L
-#define BOOM_MED_MASK_PMAP_ANIM 0x04400e02L
-#define BOOM_SML_MASK_PMAP_ANIM 0x04400f02L
-#define AMBIENT_MASK_PMAP_ANIM 0x04601002L
-#define HYPERSTARS_MASK_PMAP_ANIM 0x04801102L
-#define ARISPACE_MASK_PMAP_ANIM 0x04a01202L
-#define IPBKGND_MASK_PMAP_ANIM 0x05001302L
-#define SISIP_MASK_PMAP_ANIM 0x05201402L
-#define ORBPLAN_MASK_PMAP_ANIM 0x05201502L
-#define SUN_MASK_PMAP_ANIM 0x05201602L
-#define LANDER_MASK_PMAP_ANIM 0x05401702L
-#define QUAKE_MASK_PMAP_ANIM 0x05401802L
-#define LIGHTNING_MASK_ANIM 0x05401902L
-#define LAVA_MASK_PMAP_ANIM 0x05401a02L
-#define LANDER_SHIELD_MASK_ANIM 0x05401b02L
-#define LANDER_LAUNCH_MASK_PMAP_ANIM 0x05401c02L
-#define LANDER_RETURN_MASK_PMAP_ANIM 0x05401d02L
-#define ORBIT_VIEW_ANIM 0x05601e02L
-#define EARTH_MASK_ANIM 0x05801f02L
-#define CANNISTER_MASK_PMAP_ANIM 0x05a02002L
-#define LIFE00_MASK_PMAP_ANIM 0x05c02102L
-#define LIFE01_MASK_PMAP_ANIM 0x05e02202L
-#define LIFE02_MASK_PMAP_ANIM 0x06002302L
-#define LIFE03_MASK_PMAP_ANIM 0x06202402L
-#define LIFE04_MASK_PMAP_ANIM 0x06402502L
-#define LIFE05_MASK_PMAP_ANIM 0x06602602L
-#define LIFE06_MASK_PMAP_ANIM 0x06802702L
-#define LIFE07_MASK_PMAP_ANIM 0x06a02802L
-#define LIFE08_MASK_PMAP_ANIM 0x06c02902L
-#define LIFE09_MASK_PMAP_ANIM 0x06e02a02L
-#define LIFE10_MASK_PMAP_ANIM 0x07002b02L
-#define LIFE11_MASK_PMAP_ANIM 0x07202c02L
-#define LIFE12_MASK_PMAP_ANIM 0x07402d02L
-#define LIFE13_MASK_PMAP_ANIM 0x07602e02L
-#define LIFE14_MASK_PMAP_ANIM 0x07802f02L
-#define LIFE15_MASK_PMAP_ANIM 0x07a03002L
-#define LIFE16_MASK_PMAP_ANIM 0x07c03102L
-#define LIFE17_MASK_PMAP_ANIM 0x07e03202L
-#define LIFE18_MASK_PMAP_ANIM 0x08003302L
-#define LIFE19_MASK_PMAP_ANIM 0x08203402L
-#define LIFE20_MASK_PMAP_ANIM 0x08403502L
-#define LIFE21_MASK_PMAP_ANIM 0x08603602L
-#define LIFE22_MASK_PMAP_ANIM 0x08803702L
-#define LIFE23_MASK_PMAP_ANIM 0x08a03802L
-#define LIFE24_MASK_PMAP_ANIM 0x08c03902L
-#define LIFE25_MASK_PMAP_ANIM 0x08e03a02L
-#define MOONBASE_MASK_PMAP_ANIM 0x11603b02L
-#define MAIDENS_MASK_PMAP_ANIM 0x11803c02L
-#define AQUA_MASK_PMAP_ANIM 0x11c03d02L
-#define BURV_BCS_MASK_PMAP_ANIM 0x11e03e02L
-#define TAALO_DEVICE_MASK_PMAP_ANIM 0x12003f02L
-#define SUN_DEVICE_MASK_PMAP_ANIM 0x12204002L
-#define VAULT_MASK_PMAP_ANIM 0x12404102L
-#define WRECK_MASK_PMAP_ANIM 0x12604202L
-#define BOMB_MASK_PMAP_ANIM 0x12804302L
-#define EGG_CASE_MASK_PMAP_ANIM 0x12c04402L
-#define SPAPLUTO_MASK_PMAP_ANIM 0x12e04502L
-#define RUINS_MASK_PMAP_ANIM 0x13804602L
-#define UMGAH_BCS_MASK_PMAP_ANIM 0x13c04702L
-#define MELEE_SCREEN_PMAP_ANIM 0x14204802L
-#define MELEE_PICK_MASK_PMAP_ANIM 0x14404902L
-#define SEGUE_PMAP_ANIM 0x14604a02L
-#define SC2_PICK_PMAP_ANIM 0x14804b02L
-#define RESTART_PMAP_ANIM 0x18204c02L
-#define MODULES_PMAP_ANIM 0x18404d02L
-#define SISMODS_MASK_PMAP_ANIM 0x18604e02L
-#define OUTFIT_PMAP_ANIM 0x18604f02L
-#define SISBLU_MASK_ANIM 0x18a05002L
-#define SHIPYARD_PMAP_ANIM 0x18a05102L
-#define STARBASE_ANIM 0x18e05202L
-#define SAMATRA_BIG_MASK_PMAP_ANIM 0x19005302L
-#define SHIELDED_BIG_MASK_PMAP_ANIM 0x19205402L
-#define SHIELDED_MED_MASK_PMAP_ANIM 0x19205502L
-#define SHIELDED_SML_MASK_PMAP_ANIM 0x19205602L
-#define PLANET00_BIG_MASK_PMAP_ANIM 0x19405702L
-#define PLANET00_MED_MASK_PMAP_ANIM 0x19405802L
-#define PLANET00_SML_MASK_PMAP_ANIM 0x19405902L
-#define PLANET01_BIG_MASK_PMAP_ANIM 0x19605a02L
-#define PLANET01_MED_MASK_PMAP_ANIM 0x19605b02L
-#define PLANET01_SML_MASK_PMAP_ANIM 0x19605c02L
-#define PLANET02_BIG_MASK_PMAP_ANIM 0x19805d02L
-#define PLANET02_MED_MASK_PMAP_ANIM 0x19805e02L
-#define PLANET02_SML_MASK_PMAP_ANIM 0x19805f02L
-#define PLANET03_BIG_MASK_PMAP_ANIM 0x19a06002L
-#define PLANET03_MED_MASK_PMAP_ANIM 0x19a06102L
-#define PLANET03_SML_MASK_PMAP_ANIM 0x19a06202L
-#define PLANET04_BIG_MASK_PMAP_ANIM 0x19c06302L
-#define PLANET04_MED_MASK_PMAP_ANIM 0x19c06402L
-#define PLANET04_SML_MASK_PMAP_ANIM 0x19c06502L
-#define PLANET05_BIG_MASK_PMAP_ANIM 0x19e06602L
-#define PLANET05_MED_MASK_PMAP_ANIM 0x19e06702L
-#define PLANET05_SML_MASK_PMAP_ANIM 0x19e06802L
-#define PLANET06_BIG_MASK_PMAP_ANIM 0x1a006902L
-#define PLANET06_MED_MASK_PMAP_ANIM 0x1a006a02L
-#define PLANET06_SML_MASK_PMAP_ANIM 0x1a006b02L
-#define PLANET07_BIG_MASK_PMAP_ANIM 0x1a206c02L
-#define PLANET07_MED_MASK_PMAP_ANIM 0x1a206d02L
-#define PLANET07_SML_MASK_PMAP_ANIM 0x1a206e02L
-#define PLANET08_BIG_MASK_PMAP_ANIM 0x1a406f02L
-#define PLANET08_MED_MASK_PMAP_ANIM 0x1a407002L
-#define PLANET08_SML_MASK_PMAP_ANIM 0x1a407102L
-#define PLANET09_BIG_MASK_PMAP_ANIM 0x1a607202L
-#define PLANET09_MED_MASK_PMAP_ANIM 0x1a607302L
-#define PLANET09_SML_MASK_PMAP_ANIM 0x1a607402L
-#define PLANET10_BIG_MASK_PMAP_ANIM 0x1a807502L
-#define PLANET10_MED_MASK_PMAP_ANIM 0x1a807602L
-#define PLANET10_SML_MASK_PMAP_ANIM 0x1a807702L
-#define PLANET11_BIG_MASK_PMAP_ANIM 0x1aa07802L
-#define PLANET11_MED_MASK_PMAP_ANIM 0x1aa07902L
-#define PLANET11_SML_MASK_PMAP_ANIM 0x1aa07a02L
-#define PLANET12_BIG_MASK_PMAP_ANIM 0x1ac07b02L
-#define PLANET12_MED_MASK_PMAP_ANIM 0x1ac07c02L
-#define PLANET12_SML_MASK_PMAP_ANIM 0x1ac07d02L
-#define PLANET13_BIG_MASK_PMAP_ANIM 0x1ae07e02L
-#define PLANET13_MED_MASK_PMAP_ANIM 0x1ae07f02L
-#define PLANET13_SML_MASK_PMAP_ANIM 0x1ae08002L
-#define PLANET14_BIG_MASK_PMAP_ANIM 0x1b008102L
-#define PLANET14_MED_MASK_PMAP_ANIM 0x1b008202L
-#define PLANET14_SML_MASK_PMAP_ANIM 0x1b008302L
-#define PLANET15_BIG_MASK_PMAP_ANIM 0x1b208402L
-#define PLANET15_MED_MASK_PMAP_ANIM 0x1b208502L
-#define PLANET15_SML_MASK_PMAP_ANIM 0x1b208602L
-#define PLANET16_BIG_MASK_PMAP_ANIM 0x1b408702L
-#define PLANET16_MED_MASK_PMAP_ANIM 0x1b408802L
-#define PLANET16_SML_MASK_PMAP_ANIM 0x1b408902L
-#define PLANET17_BIG_MASK_PMAP_ANIM 0x1b608a02L
-#define PLANET17_MED_MASK_PMAP_ANIM 0x1b608b02L
-#define PLANET17_SML_MASK_PMAP_ANIM 0x1b608c02L
-#define PLANET18_BIG_MASK_PMAP_ANIM 0x1b808d02L
-#define PLANET18_MED_MASK_PMAP_ANIM 0x1b808e02L
-#define PLANET18_SML_MASK_PMAP_ANIM 0x1b808f02L
-#define PLANET19_BIG_MASK_PMAP_ANIM 0x1ba09002L
-#define PLANET19_MED_MASK_PMAP_ANIM 0x1ba09102L
-#define PLANET19_SML_MASK_PMAP_ANIM 0x1ba09202L
-#define PLANET20_BIG_MASK_PMAP_ANIM 0x1bc09302L
-#define PLANET20_MED_MASK_PMAP_ANIM 0x1bc09402L
-#define PLANET20_SML_MASK_PMAP_ANIM 0x1bc09502L
-#define PLANET21_BIG_MASK_PMAP_ANIM 0x1be09602L
-#define PLANET21_MED_MASK_PMAP_ANIM 0x1be09702L
-#define PLANET21_SML_MASK_PMAP_ANIM 0x1be09802L
-#define PLANET22_BIG_MASK_PMAP_ANIM 0x1c009902L
-#define PLANET22_MED_MASK_PMAP_ANIM 0x1c009a02L
-#define PLANET22_SML_MASK_PMAP_ANIM 0x1c009b02L
-#define PLANET23_BIG_MASK_PMAP_ANIM 0x1c209c02L
-#define PLANET23_MED_MASK_PMAP_ANIM 0x1c209d02L
-#define PLANET23_SML_MASK_PMAP_ANIM 0x1c209e02L
-#define PLANET24_BIG_MASK_PMAP_ANIM 0x1c409f02L
-#define PLANET24_MED_MASK_PMAP_ANIM 0x1c40a002L
-#define PLANET24_SML_MASK_PMAP_ANIM 0x1c40a102L
-#define PLANET25_BIG_MASK_PMAP_ANIM 0x1c60a202L
-#define PLANET25_MED_MASK_PMAP_ANIM 0x1c60a302L
-#define PLANET25_SML_MASK_PMAP_ANIM 0x1c60a402L
-#define PLANET26_BIG_MASK_PMAP_ANIM 0x1c80a502L
-#define PLANET26_MED_MASK_PMAP_ANIM 0x1c80a602L
-#define PLANET26_SML_MASK_PMAP_ANIM 0x1c80a702L
-#define PLANET27_BIG_MASK_PMAP_ANIM 0x1ca0a802L
-#define PLANET27_MED_MASK_PMAP_ANIM 0x1ca0a902L
-#define PLANET27_SML_MASK_PMAP_ANIM 0x1ca0aa02L
-#define PLANET28_BIG_MASK_PMAP_ANIM 0x1cc0ab02L
-#define PLANET28_MED_MASK_PMAP_ANIM 0x1cc0ac02L
-#define PLANET28_SML_MASK_PMAP_ANIM 0x1cc0ad02L
-#define PLANET29_BIG_MASK_PMAP_ANIM 0x1ce0ae02L
-#define PLANET29_MED_MASK_PMAP_ANIM 0x1ce0af02L
-#define PLANET29_SML_MASK_PMAP_ANIM 0x1ce0b002L
-#define PLANET30_BIG_MASK_PMAP_ANIM 0x1d00b102L
-#define PLANET30_MED_MASK_PMAP_ANIM 0x1d00b202L
-#define PLANET30_SML_MASK_PMAP_ANIM 0x1d00b302L
-#define PLANET31_BIG_MASK_PMAP_ANIM 0x1d20b402L
-#define PLANET31_MED_MASK_PMAP_ANIM 0x1d20b502L
-#define PLANET31_SML_MASK_PMAP_ANIM 0x1d20b602L
-#define PLANET32_BIG_MASK_PMAP_ANIM 0x1d40b702L
-#define PLANET32_MED_MASK_PMAP_ANIM 0x1d40b802L
-#define PLANET32_SML_MASK_PMAP_ANIM 0x1d40b902L
-#define PLANET33_BIG_MASK_PMAP_ANIM 0x1d60ba02L
-#define PLANET33_MED_MASK_PMAP_ANIM 0x1d60bb02L
-#define PLANET33_SML_MASK_PMAP_ANIM 0x1d60bc02L
-#define PLANET34_BIG_MASK_PMAP_ANIM 0x1d80bd02L
-#define PLANET34_MED_MASK_PMAP_ANIM 0x1d80be02L
-#define PLANET34_SML_MASK_PMAP_ANIM 0x1d80bf02L
-#define PLANET35_BIG_MASK_PMAP_ANIM 0x1da0c002L
-#define PLANET35_MED_MASK_PMAP_ANIM 0x1da0c102L
-#define PLANET35_SML_MASK_PMAP_ANIM 0x1da0c202L
-#define PLANET36_BIG_MASK_PMAP_ANIM 0x1dc0c302L
-#define PLANET36_MED_MASK_PMAP_ANIM 0x1dc0c402L
-#define PLANET36_SML_MASK_PMAP_ANIM 0x1dc0c502L
-#define PLANET37_BIG_MASK_PMAP_ANIM 0x1de0c602L
-#define PLANET37_MED_MASK_PMAP_ANIM 0x1de0c702L
-#define PLANET37_SML_MASK_PMAP_ANIM 0x1de0c802L
-#define PLANET38_BIG_MASK_PMAP_ANIM 0x1e00c902L
-#define PLANET38_MED_MASK_PMAP_ANIM 0x1e00ca02L
-#define PLANET38_SML_MASK_PMAP_ANIM 0x1e00cb02L
-#define PLANET39_BIG_MASK_PMAP_ANIM 0x1e20cc02L
-#define PLANET39_MED_MASK_PMAP_ANIM 0x1e20cd02L
-#define PLANET39_SML_MASK_PMAP_ANIM 0x1e20ce02L
-#define PLANET40_BIG_MASK_PMAP_ANIM 0x1e40cf02L
-#define PLANET40_MED_MASK_PMAP_ANIM 0x1e40d002L
-#define PLANET40_SML_MASK_PMAP_ANIM 0x1e40d102L
-#define PLANET41_BIG_MASK_PMAP_ANIM 0x1e60d202L
-#define PLANET41_MED_MASK_PMAP_ANIM 0x1e60d302L
-#define PLANET41_SML_MASK_PMAP_ANIM 0x1e60d402L
-#define PLANET42_BIG_MASK_PMAP_ANIM 0x1e80d502L
-#define PLANET42_MED_MASK_PMAP_ANIM 0x1e80d602L
-#define PLANET42_SML_MASK_PMAP_ANIM 0x1e80d702L
-#define PLANET43_BIG_MASK_PMAP_ANIM 0x1ea0d802L
-#define PLANET43_MED_MASK_PMAP_ANIM 0x1ea0d902L
-#define PLANET43_SML_MASK_PMAP_ANIM 0x1ea0da02L
-#define PLANET44_BIG_MASK_PMAP_ANIM 0x1ec0db02L
-#define PLANET44_MED_MASK_PMAP_ANIM 0x1ec0dc02L
-#define PLANET44_SML_MASK_PMAP_ANIM 0x1ec0dd02L
-#define PLANET45_BIG_MASK_PMAP_ANIM 0x1ee0de02L
-#define PLANET45_MED_MASK_PMAP_ANIM 0x1ee0df02L
-#define PLANET45_SML_MASK_PMAP_ANIM 0x1ee0e002L
-#define PLANET46_BIG_MASK_PMAP_ANIM 0x1f00e102L
-#define PLANET46_MED_MASK_PMAP_ANIM 0x1f00e202L
-#define PLANET46_SML_MASK_PMAP_ANIM 0x1f00e302L
-#define PLANET47_BIG_MASK_PMAP_ANIM 0x1f20e402L
-#define PLANET47_MED_MASK_PMAP_ANIM 0x1f20e502L
-#define PLANET47_SML_MASK_PMAP_ANIM 0x1f20e602L
-#define PLANET48_BIG_MASK_PMAP_ANIM 0x1f40e702L
-#define PLANET48_MED_MASK_PMAP_ANIM 0x1f40e802L
-#define PLANET48_SML_MASK_PMAP_ANIM 0x1f40e902L
-#define PLANET49_BIG_MASK_PMAP_ANIM 0x1f60ea02L
-#define PLANET49_MED_MASK_PMAP_ANIM 0x1f60eb02L
-#define PLANET49_SML_MASK_PMAP_ANIM 0x1f60ec02L
-#define PLANET50_BIG_MASK_PMAP_ANIM 0x1f80ed02L
-#define PLANET50_MED_MASK_PMAP_ANIM 0x1f80ee02L
-#define PLANET50_SML_MASK_PMAP_ANIM 0x1f80ef02L
-#define PLANET51_BIG_MASK_PMAP_ANIM 0x1fa0f002L
-#define PLANET51_MED_MASK_PMAP_ANIM 0x1fa0f102L
-#define PLANET51_SML_MASK_PMAP_ANIM 0x1fa0f202L
-#define PLANET52_BIG_MASK_PMAP_ANIM 0x1fc0f302L
-#define PLANET52_MED_MASK_PMAP_ANIM 0x1fc0f402L
-#define PLANET52_SML_MASK_PMAP_ANIM 0x1fc0f502L
-#define PLANET53_BIG_MASK_PMAP_ANIM 0x1fe0f602L
-#define PLANET53_MED_MASK_PMAP_ANIM 0x1fe0f702L
-#define PLANET53_SML_MASK_PMAP_ANIM 0x1fe0f802L
-#define PLANET54_BIG_MASK_PMAP_ANIM 0x2000f902L
-#define PLANET54_MED_MASK_PMAP_ANIM 0x2000fa02L
-#define PLANET54_SML_MASK_PMAP_ANIM 0x2000fb02L
-#define PLANET55_BIG_MASK_PMAP_ANIM 0x2020fc02L
-#define PLANET55_MED_MASK_PMAP_ANIM 0x2020fd02L
-#define PLANET55_SML_MASK_PMAP_ANIM 0x2020fe02L
-#define PLANET56_BIG_MASK_PMAP_ANIM 0x2040ff02L
-#define PLANET56_MED_MASK_PMAP_ANIM 0x20410002L
-#define PLANET56_SML_MASK_PMAP_ANIM 0x20410102L
-#define PLANET57_BIG_MASK_PMAP_ANIM 0x20610202L
-#define PLANET57_MED_MASK_PMAP_ANIM 0x20610302L
-#define PLANET57_SML_MASK_PMAP_ANIM 0x20610402L
-#define PLANET58_BIG_MASK_PMAP_ANIM 0x20810502L
-#define PLANET58_MED_MASK_PMAP_ANIM 0x20810602L
-#define PLANET58_SML_MASK_PMAP_ANIM 0x20810702L
-#define CREDITS_BACK_ANIM 0x20c10802L
-
-#define SISSKEL_MASK_PMAP_ANIM 0x23611c02L
-#define ORBENTER_PMAP_ANIM 0x23811d02L
-#define MENUBKG_PMAP_ANIM 0x23a11e02L
-#define FONTGRAD_PMAP_ANIM 0x03e11f02L
-#define LANDER_FONTEFF_PMAP_ANIM 0x11412002L
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ACTIVITY_ANIM "graphics.activity"
+#define AMBIENT_MASK_PMAP_ANIM "graphics.ambanim"
+#define AQUA_MASK_PMAP_ANIM "graphics.aquhelix"
+#define ARISPACE_MASK_PMAP_ANIM "graphics.arispace"
+#define ASTEROID_BIG_MASK_PMAP_ANIM "graphics.astbig"
+#define ASTEROID_MED_MASK_PMAP_ANIM "graphics.astmed"
+#define ASTEROID_SML_MASK_PMAP_ANIM "graphics.astsml"
+#define BLAST_BIG_MASK_PMAP_ANIM "graphics.blabig"
+#define BLAST_MED_MASK_PMAP_ANIM "graphics.blamed"
+#define BLAST_SML_MASK_PMAP_ANIM "graphics.blasml"
+#define BOMB_MASK_PMAP_ANIM "graphics.utwbomb"
+#define BOOM_BIG_MASK_PMAP_ANIM "graphics.boobig"
+#define BOOM_MED_MASK_PMAP_ANIM "graphics.boomed"
+#define BOOM_SML_MASK_PMAP_ANIM "graphics.boosml"
+#define BURV_BCS_MASK_PMAP_ANIM "graphics.drutrans"
+#define CANNISTER_MASK_PMAP_ANIM "graphics.lifecan"
+#define CREDITS_BACK_ANIM "credits.background"
+#define EARTH_MASK_ANIM "graphics.eartmask"
+#define EGG_CASE_MASK_PMAP_ANIM "graphics.eggcase"
+#define FLAGSTAT_MASK_PMAP_ANIM "graphics.flagstat"
+#define FONTGRAD_PMAP_ANIM "graphics.fontgrad"
+#define HYPERSTARS_MASK_PMAP_ANIM "graphics.hyperstr"
+#define IPBKGND_MASK_PMAP_ANIM "graphics.obbkgnd"
+#define LANDER_FONTEFF_PMAP_ANIM "graphics.landfeff"
+#define LANDER_LAUNCH_MASK_PMAP_ANIM "graphics.launch"
+#define LANDER_MASK_PMAP_ANIM "graphics.lander"
+#define LANDER_RETURN_MASK_PMAP_ANIM "graphics.return"
+#define LANDER_SHIELD_MASK_ANIM "graphics.lndrshld"
+#define LAVA_MASK_PMAP_ANIM "graphics.lavaspot"
+#define LIFE00_MASK_PMAP_ANIM "graphics.life.0"
+#define LIFE01_MASK_PMAP_ANIM "graphics.life.1"
+#define LIFE02_MASK_PMAP_ANIM "graphics.life.2"
+#define LIFE03_MASK_PMAP_ANIM "graphics.life.3"
+#define LIFE04_MASK_PMAP_ANIM "graphics.life.4"
+#define LIFE05_MASK_PMAP_ANIM "graphics.life.5"
+#define LIFE06_MASK_PMAP_ANIM "graphics.life.6"
+#define LIFE07_MASK_PMAP_ANIM "graphics.life.7"
+#define LIFE08_MASK_PMAP_ANIM "graphics.life.8"
+#define LIFE09_MASK_PMAP_ANIM "graphics.life.9"
+#define LIFE10_MASK_PMAP_ANIM "graphics.life.10"
+#define LIFE11_MASK_PMAP_ANIM "graphics.life.11"
+#define LIFE12_MASK_PMAP_ANIM "graphics.life.12"
+#define LIFE13_MASK_PMAP_ANIM "graphics.life.13"
+#define LIFE14_MASK_PMAP_ANIM "graphics.life.14"
+#define LIFE15_MASK_PMAP_ANIM "graphics.life.15"
+#define LIFE16_MASK_PMAP_ANIM "graphics.life.16"
+#define LIFE17_MASK_PMAP_ANIM "graphics.life.17"
+#define LIFE18_MASK_PMAP_ANIM "graphics.life.18"
+#define LIFE19_MASK_PMAP_ANIM "graphics.life.19"
+#define LIFE20_MASK_PMAP_ANIM "graphics.life.20"
+#define LIFE21_MASK_PMAP_ANIM "graphics.life.21"
+#define LIFE22_MASK_PMAP_ANIM "graphics.life.22"
+#define LIFE23_MASK_PMAP_ANIM "graphics.life.23"
+#define LIFE24_MASK_PMAP_ANIM "graphics.life.24"
+#define LIFE25_MASK_PMAP_ANIM "graphics.life.25"
+#define LIGHTNING_MASK_ANIM "graphics.lightnin"
+#define MAIDENS_MASK_PMAP_ANIM "graphics.maidens"
+#define MELEE_PICK_MASK_PMAP_ANIM "graphics.melee"
+#define MELEE_SCREEN_PMAP_ANIM "graphics.melebkgd"
+#define MENUBKG_PMAP_ANIM "graphics.setupmenu"
+#define MISCDATA_MASK_PMAP_ANIM "graphics.miscdata"
+#define MODULES_PMAP_ANIM "graphics.modules"
+#define MOONBASE_MASK_PMAP_ANIM "graphics.moonbase"
+#define MOTHER_ARK_MASK_PMAP_ANIM "graphics.motherark"
+#define ORBENTER_PMAP_ANIM "graphics.orbenter"
+#define ORBIT_VIEW_ANIM "graphics.orbview"
+#define ORBPLAN_MASK_PMAP_ANIM "graphics.orbplan"
+#define OUTFIT_PMAP_ANIM "graphics.outfit"
+#define PLANET00_BIG_MASK_PMAP_ANIM "planet.oolite.large"
+#define PLANET00_MED_MASK_PMAP_ANIM "planet.oolite.medium"
+#define PLANET00_SML_MASK_PMAP_ANIM "planet.oolite.small"
+#define PLANET01_BIG_MASK_PMAP_ANIM "planet.yttric.large"
+#define PLANET01_MED_MASK_PMAP_ANIM "planet.yttric.medium"
+#define PLANET01_SML_MASK_PMAP_ANIM "planet.yttric.small"
+#define PLANET02_BIG_MASK_PMAP_ANIM "planet.quasidegenerate.large"
+#define PLANET02_MED_MASK_PMAP_ANIM "planet.quasidegenerate.medium"
+#define PLANET02_SML_MASK_PMAP_ANIM "planet.quasidegenerate.small"
+#define PLANET03_BIG_MASK_PMAP_ANIM "planet.lanthanide.large"
+#define PLANET03_MED_MASK_PMAP_ANIM "planet.lanthanide.medium"
+#define PLANET03_SML_MASK_PMAP_ANIM "planet.lanthanide.small"
+#define PLANET04_BIG_MASK_PMAP_ANIM "planet.treasure.large"
+#define PLANET04_MED_MASK_PMAP_ANIM "planet.treasure.medium"
+#define PLANET04_SML_MASK_PMAP_ANIM "planet.treasure.small"
+#define PLANET05_BIG_MASK_PMAP_ANIM "planet.urea.large"
+#define PLANET05_MED_MASK_PMAP_ANIM "planet.urea.medium"
+#define PLANET05_SML_MASK_PMAP_ANIM "planet.urea.small"
+#define PLANET06_BIG_MASK_PMAP_ANIM "planet.metal.large"
+#define PLANET06_MED_MASK_PMAP_ANIM "planet.metal.medium"
+#define PLANET06_SML_MASK_PMAP_ANIM "planet.metal.small"
+#define PLANET07_BIG_MASK_PMAP_ANIM "planet.radioactive.large"
+#define PLANET07_MED_MASK_PMAP_ANIM "planet.radioactive.medium"
+#define PLANET07_SML_MASK_PMAP_ANIM "planet.radioactive.small"
+#define PLANET08_BIG_MASK_PMAP_ANIM "planet.opalescent.large"
+#define PLANET08_MED_MASK_PMAP_ANIM "planet.opalescent.medium"
+#define PLANET08_SML_MASK_PMAP_ANIM "planet.opalescent.small"
+#define PLANET09_BIG_MASK_PMAP_ANIM "planet.cyanic.large"
+#define PLANET09_MED_MASK_PMAP_ANIM "planet.cyanic.medium"
+#define PLANET09_SML_MASK_PMAP_ANIM "planet.cyanic.small"
+#define PLANET10_BIG_MASK_PMAP_ANIM "planet.acid.large"
+#define PLANET10_MED_MASK_PMAP_ANIM "planet.acid.medium"
+#define PLANET10_SML_MASK_PMAP_ANIM "planet.acid.small"
+#define PLANET11_BIG_MASK_PMAP_ANIM "planet.alkali.large"
+#define PLANET11_MED_MASK_PMAP_ANIM "planet.alkali.medium"
+#define PLANET11_SML_MASK_PMAP_ANIM "planet.alkali.small"
+#define PLANET12_BIG_MASK_PMAP_ANIM "planet.halide.large"
+#define PLANET12_MED_MASK_PMAP_ANIM "planet.halide.medium"
+#define PLANET12_SML_MASK_PMAP_ANIM "planet.halide.small"
+#define PLANET13_BIG_MASK_PMAP_ANIM "planet.green.large"
+#define PLANET13_MED_MASK_PMAP_ANIM "planet.green.medium"
+#define PLANET13_SML_MASK_PMAP_ANIM "planet.green.small"
+#define PLANET14_BIG_MASK_PMAP_ANIM "planet.copper.large"
+#define PLANET14_MED_MASK_PMAP_ANIM "planet.copper.medium"
+#define PLANET14_SML_MASK_PMAP_ANIM "planet.copper.small"
+#define PLANET15_BIG_MASK_PMAP_ANIM "planet.carbide.large"
+#define PLANET15_MED_MASK_PMAP_ANIM "planet.carbide.medium"
+#define PLANET15_SML_MASK_PMAP_ANIM "planet.carbide.small"
+#define PLANET16_BIG_MASK_PMAP_ANIM "planet.ultramarine.large"
+#define PLANET16_MED_MASK_PMAP_ANIM "planet.ultramarine.medium"
+#define PLANET16_SML_MASK_PMAP_ANIM "planet.ultramarine.small"
+#define PLANET17_BIG_MASK_PMAP_ANIM "planet.noble.large"
+#define PLANET17_MED_MASK_PMAP_ANIM "planet.noble.medium"
+#define PLANET17_SML_MASK_PMAP_ANIM "planet.noble.small"
+#define PLANET18_BIG_MASK_PMAP_ANIM "planet.azure.large"
+#define PLANET18_MED_MASK_PMAP_ANIM "planet.azure.medium"
+#define PLANET18_SML_MASK_PMAP_ANIM "planet.azure.small"
+#define PLANET19_BIG_MASK_PMAP_ANIM "planet.chondrite.large"
+#define PLANET19_MED_MASK_PMAP_ANIM "planet.chondrite.medium"
+#define PLANET19_SML_MASK_PMAP_ANIM "planet.chondrite.small"
+#define PLANET20_BIG_MASK_PMAP_ANIM "planet.purple.large"
+#define PLANET20_MED_MASK_PMAP_ANIM "planet.purple.medium"
+#define PLANET20_SML_MASK_PMAP_ANIM "planet.purple.small"
+#define PLANET21_BIG_MASK_PMAP_ANIM "planet.superdense.large"
+#define PLANET21_MED_MASK_PMAP_ANIM "planet.superdense.medium"
+#define PLANET21_SML_MASK_PMAP_ANIM "planet.superdense.small"
+#define PLANET22_BIG_MASK_PMAP_ANIM "planet.pellucid.large"
+#define PLANET22_MED_MASK_PMAP_ANIM "planet.pellucid.medium"
+#define PLANET22_SML_MASK_PMAP_ANIM "planet.pellucid.small"
+#define PLANET23_BIG_MASK_PMAP_ANIM "planet.dust.large"
+#define PLANET23_MED_MASK_PMAP_ANIM "planet.dust.medium"
+#define PLANET23_SML_MASK_PMAP_ANIM "planet.dust.small"
+#define PLANET24_BIG_MASK_PMAP_ANIM "planet.crimson.large"
+#define PLANET24_MED_MASK_PMAP_ANIM "planet.crimson.medium"
+#define PLANET24_SML_MASK_PMAP_ANIM "planet.crimson.small"
+#define PLANET25_BIG_MASK_PMAP_ANIM "planet.cimmerian.large"
+#define PLANET25_MED_MASK_PMAP_ANIM "planet.cimmerian.medium"
+#define PLANET25_SML_MASK_PMAP_ANIM "planet.cimmerian.small"
+#define PLANET26_BIG_MASK_PMAP_ANIM "planet.infrared.large"
+#define PLANET26_MED_MASK_PMAP_ANIM "planet.infrared.medium"
+#define PLANET26_SML_MASK_PMAP_ANIM "planet.infrared.small"
+#define PLANET27_BIG_MASK_PMAP_ANIM "planet.selenic.large"
+#define PLANET27_MED_MASK_PMAP_ANIM "planet.selenic.medium"
+#define PLANET27_SML_MASK_PMAP_ANIM "planet.selenic.small"
+#define PLANET28_BIG_MASK_PMAP_ANIM "planet.auric.large"
+#define PLANET28_MED_MASK_PMAP_ANIM "planet.auric.medium"
+#define PLANET28_SML_MASK_PMAP_ANIM "planet.auric.small"
+#define PLANET29_BIG_MASK_PMAP_ANIM "planet.fluorescent.large"
+#define PLANET29_MED_MASK_PMAP_ANIM "planet.fluorescent.medium"
+#define PLANET29_SML_MASK_PMAP_ANIM "planet.fluorescent.small"
+#define PLANET30_BIG_MASK_PMAP_ANIM "planet.ultraviolet.large"
+#define PLANET30_MED_MASK_PMAP_ANIM "planet.ultraviolet.medium"
+#define PLANET30_SML_MASK_PMAP_ANIM "planet.ultraviolet.small"
+#define PLANET31_BIG_MASK_PMAP_ANIM "planet.plutonic.large"
+#define PLANET31_MED_MASK_PMAP_ANIM "planet.plutonic.medium"
+#define PLANET31_SML_MASK_PMAP_ANIM "planet.plutonic.small"
+#define PLANET32_BIG_MASK_PMAP_ANIM "planet.rainbow.large"
+#define PLANET32_MED_MASK_PMAP_ANIM "planet.rainbow.medium"
+#define PLANET32_SML_MASK_PMAP_ANIM "planet.rainbow.small"
+#define PLANET33_BIG_MASK_PMAP_ANIM "planet.shattered.large"
+#define PLANET33_MED_MASK_PMAP_ANIM "planet.shattered.medium"
+#define PLANET33_SML_MASK_PMAP_ANIM "planet.shattered.small"
+#define PLANET34_BIG_MASK_PMAP_ANIM "planet.sapphire.large"
+#define PLANET34_MED_MASK_PMAP_ANIM "planet.sapphire.medium"
+#define PLANET34_SML_MASK_PMAP_ANIM "planet.sapphire.small"
+#define PLANET35_BIG_MASK_PMAP_ANIM "planet.organic.large"
+#define PLANET35_MED_MASK_PMAP_ANIM "planet.organic.medium"
+#define PLANET35_SML_MASK_PMAP_ANIM "planet.organic.small"
+#define PLANET36_BIG_MASK_PMAP_ANIM "planet.xenolithic.large"
+#define PLANET36_MED_MASK_PMAP_ANIM "planet.xenolithic.medium"
+#define PLANET36_SML_MASK_PMAP_ANIM "planet.xenolithic.small"
+#define PLANET37_BIG_MASK_PMAP_ANIM "planet.redux.large"
+#define PLANET37_MED_MASK_PMAP_ANIM "planet.redux.medium"
+#define PLANET37_SML_MASK_PMAP_ANIM "planet.redux.small"
+#define PLANET38_BIG_MASK_PMAP_ANIM "planet.primordial.large"
+#define PLANET38_MED_MASK_PMAP_ANIM "planet.primordial.medium"
+#define PLANET38_SML_MASK_PMAP_ANIM "planet.primordial.small"
+#define PLANET39_BIG_MASK_PMAP_ANIM "planet.emerald.large"
+#define PLANET39_MED_MASK_PMAP_ANIM "planet.emerald.medium"
+#define PLANET39_SML_MASK_PMAP_ANIM "planet.emerald.small"
+#define PLANET40_BIG_MASK_PMAP_ANIM "planet.chlorine.large"
+#define PLANET40_MED_MASK_PMAP_ANIM "planet.chlorine.medium"
+#define PLANET40_SML_MASK_PMAP_ANIM "planet.chlorine.small"
+#define PLANET41_BIG_MASK_PMAP_ANIM "planet.magnetic.large"
+#define PLANET41_MED_MASK_PMAP_ANIM "planet.magnetic.medium"
+#define PLANET41_SML_MASK_PMAP_ANIM "planet.magnetic.small"
+#define PLANET42_BIG_MASK_PMAP_ANIM "planet.water.large"
+#define PLANET42_MED_MASK_PMAP_ANIM "planet.water.medium"
+#define PLANET42_SML_MASK_PMAP_ANIM "planet.water.small"
+#define PLANET43_BIG_MASK_PMAP_ANIM "planet.telluric.large"
+#define PLANET43_MED_MASK_PMAP_ANIM "planet.telluric.medium"
+#define PLANET43_SML_MASK_PMAP_ANIM "planet.telluric.small"
+#define PLANET44_BIG_MASK_PMAP_ANIM "planet.hydrocarbon.large"
+#define PLANET44_MED_MASK_PMAP_ANIM "planet.hydrocarbon.medium"
+#define PLANET44_SML_MASK_PMAP_ANIM "planet.hydrocarbon.small"
+#define PLANET45_BIG_MASK_PMAP_ANIM "planet.iodine.large"
+#define PLANET45_MED_MASK_PMAP_ANIM "planet.iodine.medium"
+#define PLANET45_SML_MASK_PMAP_ANIM "planet.iodine.small"
+#define PLANET46_BIG_MASK_PMAP_ANIM "planet.vinylogous.large"
+#define PLANET46_MED_MASK_PMAP_ANIM "planet.vinylogous.medium"
+#define PLANET46_SML_MASK_PMAP_ANIM "planet.vinylogous.small"
+#define PLANET47_BIG_MASK_PMAP_ANIM "planet.ruby.large"
+#define PLANET47_MED_MASK_PMAP_ANIM "planet.ruby.medium"
+#define PLANET47_SML_MASK_PMAP_ANIM "planet.ruby.small"
+#define PLANET48_BIG_MASK_PMAP_ANIM "planet.magma.large"
+#define PLANET48_MED_MASK_PMAP_ANIM "planet.magma.medium"
+#define PLANET48_SML_MASK_PMAP_ANIM "planet.magma.small"
+#define PLANET49_BIG_MASK_PMAP_ANIM "planet.maroon.large"
+#define PLANET49_MED_MASK_PMAP_ANIM "planet.maroon.medium"
+#define PLANET49_SML_MASK_PMAP_ANIM "planet.maroon.small"
+#define PLANET50_BIG_MASK_PMAP_ANIM "planet.bluegas.large"
+#define PLANET50_MED_MASK_PMAP_ANIM "planet.bluegas.medium"
+#define PLANET50_SML_MASK_PMAP_ANIM "planet.bluegas.small"
+#define PLANET51_BIG_MASK_PMAP_ANIM "planet.cyangas.large"
+#define PLANET51_MED_MASK_PMAP_ANIM "planet.cyangas.medium"
+#define PLANET51_SML_MASK_PMAP_ANIM "planet.cyangas.small"
+#define PLANET52_BIG_MASK_PMAP_ANIM "planet.greengas.large"
+#define PLANET52_MED_MASK_PMAP_ANIM "planet.greengas.medium"
+#define PLANET52_SML_MASK_PMAP_ANIM "planet.greengas.small"
+#define PLANET53_BIG_MASK_PMAP_ANIM "planet.greygas.large"
+#define PLANET53_MED_MASK_PMAP_ANIM "planet.greygas.medium"
+#define PLANET53_SML_MASK_PMAP_ANIM "planet.greygas.small"
+#define PLANET54_BIG_MASK_PMAP_ANIM "planet.orangegas.large"
+#define PLANET54_MED_MASK_PMAP_ANIM "planet.orangegas.medium"
+#define PLANET54_SML_MASK_PMAP_ANIM "planet.orangegas.small"
+#define PLANET55_BIG_MASK_PMAP_ANIM "planet.purplegas.large"
+#define PLANET55_MED_MASK_PMAP_ANIM "planet.purplegas.medium"
+#define PLANET55_SML_MASK_PMAP_ANIM "planet.purplegas.small"
+#define PLANET56_BIG_MASK_PMAP_ANIM "planet.redgas.large"
+#define PLANET56_MED_MASK_PMAP_ANIM "planet.redgas.medium"
+#define PLANET56_SML_MASK_PMAP_ANIM "planet.redgas.small"
+#define PLANET57_BIG_MASK_PMAP_ANIM "planet.violetgas.large"
+#define PLANET57_MED_MASK_PMAP_ANIM "planet.violetgas.medium"
+#define PLANET57_SML_MASK_PMAP_ANIM "planet.violetgas.small"
+#define PLANET58_BIG_MASK_PMAP_ANIM "planet.yellowgas.large"
+#define PLANET58_MED_MASK_PMAP_ANIM "planet.yellowgas.medium"
+#define PLANET58_SML_MASK_PMAP_ANIM "planet.yellowgas.small"
+#define PLAYMENU_ANIM "graphics.playmenu"
+#define QUAKE_MASK_PMAP_ANIM "graphics.quake"
+#define RESTART_PMAP_ANIM "graphics.newgame"
+#define RUINS_MASK_PMAP_ANIM "graphics.ruins"
+#define SAMATRA_BIG_MASK_PMAP_ANIM "planet.samatra.large"
+#define SC2_PICK_PMAP_ANIM "graphics.pickship"
+#define SEGUE_PMAP_ANIM "graphics.segue"
+#define SHIELDED_BIG_MASK_PMAP_ANIM "planet.slaveshield.large"
+#define SHIELDED_MED_MASK_PMAP_ANIM "planet.slaveshield.medium"
+#define SHIELDED_SML_MASK_PMAP_ANIM "planet.slaveshield.small"
+#define SHIPYARD_PMAP_ANIM "graphics.shipyard"
+#define SISBLU_MASK_ANIM "graphics.sisblu"
+#define SISIP_MASK_PMAP_ANIM "graphics.sis_ip"
+#define SISMODS_MASK_PMAP_ANIM "graphics.sismods"
+#define SISSKEL_MASK_PMAP_ANIM "graphics.sisskeleton"
+#define SPAPLUTO_MASK_PMAP_ANIM "graphics.spapluto"
+#define STARBASE_ANIM "graphics.starbase"
+#define STAR_MASK_PMAP_ANIM "graphics.stars"
+#define STATUS_MASK_PMAP_ANIM "graphics.status"
+#define SUN_DEVICE_MASK_PMAP_ANIM "graphics.sundevic"
+#define SUN_MASK_PMAP_ANIM "graphics.ip_sun"
+#define TAALO_DEVICE_MASK_PMAP_ANIM "graphics.taadevic"
+#define TITLE_ANIM "graphics.title"
+#define UMGAH_BCS_MASK_PMAP_ANIM "graphics.umgtrans"
+#define VAULT_MASK_PMAP_ANIM "graphics.syrvault"
+#define WRECK_MASK_PMAP_ANIM "graphics.urqwreck"
diff -ruNp src.orig/sc2code/ikey_con.h src/sc2code/ikey_con.h
--- src.orig/sc2code/ikey_con.h	2017-11-08 16:49:28 -0600
+++ src/sc2code/ikey_con.h	2017-11-08 16:49:55 -0600
@@ -1,3 +1,2 @@
-#define JOYSTICK_KEYS 0x00200001L
-
+// This is a dead resource file.
 
diff -ruNp src.orig/sc2code/imusicre.h src/sc2code/imusicre.h
--- src.orig/sc2code/imusicre.h	2017-11-08 16:49:28 -0600
+++ src/sc2code/imusicre.h	2017-11-08 16:49:55 -0600
@@ -1,19 +1,20 @@
-#define HYPERSPACE_MUSIC 0x04c00006L
-#define QUASISPACE_MUSIC 0x04e00106L
-#define IP_MUSIC 0x13e00206L
-#define ORBIT1_MUSIC 0x14000306L
-#define ORBIT2_MUSIC 0x14000406L
-#define ORBIT3_MUSIC 0x14000506L
-#define ORBIT4_MUSIC 0x14000606L
-#define ORBIT5_MUSIC 0x14000706L
-#define REDALERT_MUSIC 0x14600806L
-#define OUTFIT_MUSIC 0x18800906L
-#define SHIPYARD_MUSIC 0x18c00a06L
-#define STARBASE_MUSIC 0x18e00b06L
-#define BATTLE_MUSIC 0x20a00c06L
-#define CREDITS_MUSIC 0x23400d06L
-
-#define MELEE_MUSIC 0x14200e06L
-#define MAINMENU_MUSIC 0x18200f06L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define BATTLE_MUSIC "music.battle"
+#define CREDITS_MUSIC "music.credits"
+#define HYPERSPACE_MUSIC "music.hyper"
+#define IP_MUSIC "music.space"
+#define MAINMENU_MUSIC "music.mainmenu"
+#define MELEE_MUSIC "music.meleemenu"
+#define ORBIT1_MUSIC "music.orbit1"
+#define ORBIT2_MUSIC "music.orbit2"
+#define ORBIT3_MUSIC "music.orbit3"
+#define ORBIT4_MUSIC "music.orbit4"
+#define ORBIT5_MUSIC "music.orbit5"
+#define OUTFIT_MUSIC "music.outfit"
+#define QUASISPACE_MUSIC "music.arispace"
+#define REDALERT_MUSIC "music.redalert"
+#define SHIPYARD_MUSIC "music.shipyard"
+#define STARBASE_MUSIC "music.starbase"
diff -ruNp src.orig/sc2code/init.c src/sc2code/init.c
--- src.orig/sc2code/init.c	2017-11-08 16:49:28 -0600
+++ src/sc2code/init.c	2017-11-08 16:49:55 -0600
@@ -18,11 +18,13 @@
 
 #include "build.h"
 #include "colors.h"
+#include "cons_res.h"
 #include "element.h"
 #include "globdata.h"
 #include "init.h"
 #include "port.h"
 #include "resinst.h"
+#include "reslib.h"
 #include "nameref.h"
 #include "setup.h"
 #include "units.h"
@@ -35,40 +37,65 @@ FRAME explosion[NUM_VIEWS];
 
 
 BOOLEAN
-load_animation (PFRAME pixarray, DWORD big_res, DWORD med_res, DWORD
+load_animation (FRAME *pixarray, RESOURCE big_res, RESOURCE med_res, RESOURCE
 		sml_res)
 {
 	DRAWABLE d;
 
-	if ((d = LoadGraphic (big_res)) == (DRAWABLE)NULL_PTR)
-		return (FALSE);
+	d = LoadGraphic (big_res);
+	if (!d)
+		return FALSE;
 	pixarray[0] = CaptureDrawable (d);
 
-	if (med_res != 0L && (d = LoadGraphic (med_res)) == (DRAWABLE)NULL_PTR)
-		return (FALSE);
+	if (med_res != NULL_RESOURCE)
+	{
+		d = LoadGraphic (med_res);
+		if (!d)
+			return FALSE;
+	}
 	pixarray[1] = CaptureDrawable (d);
 
-	if (sml_res != 0L && (d = LoadGraphic (sml_res)) == (DRAWABLE)NULL_PTR)
-		return (FALSE);
+	if (sml_res != NULL_RESOURCE)
+	{
+		d = LoadGraphic (sml_res);
+		if (!d)
+			return FALSE;
+	}
 	pixarray[2] = CaptureDrawable (d);
 
-	return (TRUE);
+	return TRUE;
 }
 
+/* Warning: Some ships (such as the Umgah) will alias their pixarrays,
+   so we need to track to make sure that we do not double-free. */
 BOOLEAN
-free_image (PFRAME pixarray)
+free_image (FRAME *pixarray)
 {
 	BOOLEAN retval;
-	COUNT i;
+	COUNT i, j;
+	void *already_freed[NUM_VIEWS];
 
 	retval = TRUE;
 	for (i = 0; i < NUM_VIEWS; ++i)
 	{
-		if (pixarray[i] != (FRAME)NULL_PTR)
+		if (pixarray[i] != NULL)
 		{
-			if (!DestroyDrawable (ReleaseDrawable (pixarray[i])))
-				retval = FALSE;
-			pixarray[i] = (FRAME)NULL_PTR;
+			BOOLEAN ok = TRUE;
+			for (j = 0; j < i; j++)
+			{
+				if (already_freed[j] == pixarray[i])
+				{
+					ok = FALSE;
+					break;
+				}
+			}
+			if (ok)
+			{
+				if (!DestroyDrawable (ReleaseDrawable (pixarray[i])))
+					retval = FALSE;
+			}
+			already_freed[i] = pixarray[i];
+			pixarray[i] = NULL;
 		}
 	}
 
@@ -124,6 +151,23 @@ UninitSpace (void)
 	}
 }
 
+HSTARSHIP
+BuildSIS (void)
+{
+	HSTARSHIP hStarShip;
+	STARSHIP *StarShipPtr;
+
+	hStarShip = Build (&race_q[0], SIS_SHIP_ID);
+	if (!hStarShip)
+		return 0;
+	StarShipPtr = LockStarShip (&race_q[0], hStarShip);
+	StarShipPtr->which_side = GOOD_GUY;
+	StarShipPtr->captains_name_index = 0;
+	UnlockStarShip (&race_q[0], hStarShip);
+
+	return hStarShip;
+}
+
 SIZE
 InitShips (void)
 {
@@ -137,17 +181,15 @@ InitShips (void)
 	InitDisplayList ();
 	InitGalaxy ();
 
-	num_ships = NUM_SIDES;
 	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
 	{
 		ReinitQueue (&race_q[0]);
 		ReinitQueue (&race_q[1]);
 
-		Build (&race_q[0], SIS_RES_INDEX, GOOD_GUY, 0);
-
+		BuildSIS ();
 		LoadHyperspace ();
 
-		--num_ships;
+		num_ships = 1;
 	}
 	else
 	{
@@ -179,11 +221,13 @@ InitShips (void)
 		{
 #define NUM_ASTEROIDS 5
 			for (i = 0; i < NUM_ASTEROIDS; ++i)
-				spawn_asteroid (NULL_PTR);
+				spawn_asteroid (NULL);
 #define NUM_PLANETS 1
 			for (i = 0; i < NUM_PLANETS; ++i)
 				spawn_planet ();
 		}
+	
+		num_ships = NUM_SIDES;
 	}
 
 	// FlushInput ();
@@ -191,13 +235,37 @@ InitShips (void)
 	return (num_ships);
 }
 
+// Count the crew elements in the display list.
+static COUNT
+CountCrewElements (void)
+{
+	COUNT result;
+	HELEMENT hElement, hNextElement;
+
+	result = 0;
+	for (hElement = GetHeadElement ();
+			hElement != 0; hElement = hNextElement)
+	{
+		ELEMENT *ElementPtr;
+
+		LockElement (hElement, &ElementPtr);
+		hNextElement = GetSuccElement (ElementPtr);
+		if (ElementPtr->state_flags & CREW_OBJECT)
+			++result;
+
+		UnlockElement (hElement);
+	}
+
+	return result;
+}
+
 void
 UninitShips (void)
 {
-	BYTE crew_retrieved;
+	COUNT crew_retrieved;
 	SIZE i;
 	HELEMENT hElement, hNextElement;
-	STARSHIPPTR SPtr[NUM_PLAYERS];
+	STARSHIP *SPtr[NUM_PLAYERS];
 
 	StopSound ();
 
@@ -207,30 +275,20 @@ UninitShips (void)
 		SPtr[i] = 0;
 
 	// Count the crew floating in space.
-	crew_retrieved = 0;
-	for (hElement = GetHeadElement ();
-			hElement != 0; hElement = hNextElement)
-	{
-		ELEMENTPTR ElementPtr;
-		LockElement (hElement, &ElementPtr);
-		hNextElement = GetSuccElement (ElementPtr);
-		if (ElementPtr->state_flags & CREW_OBJECT)
-			++crew_retrieved;
-		UnlockElement (hElement);
-	}
+	crew_retrieved = CountCrewElements();
 
 	for (hElement = GetHeadElement ();
 			hElement != 0; hElement = hNextElement)
 	{
-		ELEMENTPTR ElementPtr;
-		extern void new_ship (PELEMENT ElementPtr);
+		ELEMENT *ElementPtr;
+		extern void new_ship (ELEMENT *ElementPtr);
 
 		LockElement (hElement, &ElementPtr);
 		hNextElement = GetSuccElement (ElementPtr);
 		if ((ElementPtr->state_flags & PLAYER_SHIP)
 				|| ElementPtr->death_func == new_ship)
 		{
-			STARSHIPPTR StarShipPtr;
+			STARSHIP *StarShipPtr;
 
 			GetElementStarShip (ElementPtr, &StarShipPtr);
 
@@ -251,12 +309,12 @@ UninitShips (void)
 			if (StarShipPtr->RaceDescPtr->uninit_func != NULL)
 				(*StarShipPtr->RaceDescPtr->uninit_func) (
 						StarShipPtr->RaceDescPtr);
-			StarShipPtr->ShipFacing =
-					StarShipPtr->RaceDescPtr->ship_info.var2;
-			StarShipPtr->special_counter =
+			/* Record crew left after battle */
+			StarShipPtr->crew_level =
 					StarShipPtr->RaceDescPtr->ship_info.crew_level;
 			SPtr[WHICH_SIDE (ElementPtr->state_flags)] = StarShipPtr;
-			free_ship (StarShipPtr, TRUE);
+			free_ship (StarShipPtr->RaceDescPtr, TRUE, TRUE);
+			StarShipPtr->RaceDescPtr = 0;
 		}
 		UnlockElement (hElement);
 	}
@@ -269,6 +327,10 @@ UninitShips (void)
 	else if (LOBYTE (GLOBAL (CurrentActivity)) <= IN_ENCOUNTER
 			&& !(GLOBAL (CurrentActivity) & CHECK_ABORT))
 	{
+		// XXX: This has no purpose for SuperMelee
+		//   In full-game, the sole purpose of this is to record the crew
+		//   left in the last ship standing. The crew left is first recorded
+		//   into STARSHIP.crew_level just a few lines above here.
 		for (i = NUM_PLAYERS - 1; i >= 0; --i)
 		{
 			if (SPtr[i])
@@ -278,8 +340,9 @@ UninitShips (void)
 
 	if (LOBYTE (GLOBAL (CurrentActivity)) != IN_ENCOUNTER)
 	{
-		ReinitQueue (&race_q[0]);
-		ReinitQueue (&race_q[1]);
+		// Remove any ships left from the race queue.
+		for (i = 0; i < NUM_PLAYERS; i++)
+			ReinitQueue (&race_q[i]);
 
 		if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
 			FreeHyperspace ();
diff -ruNp src.orig/sc2code/intel.c src/sc2code/intel.c
--- src.orig/sc2code/intel.c	2017-11-08 16:49:28 -0600
+++ src/sc2code/intel.c	2017-11-08 16:49:55 -0600
@@ -18,6 +18,7 @@
 
 #include "intel.h"
 
+#include "battlecontrols.h"
 #include "controls.h"
 #include "globdata.h"
 #include "setup.h"
@@ -29,7 +30,7 @@
 SIZE cur_player;
 
 BATTLE_INPUT_STATE
-computer_intelligence (COUNT player, STARSHIPPTR StarShipPtr)
+computer_intelligence (ComputerInputContext *context, STARSHIP *StarShipPtr)
 {
 	BATTLE_INPUT_STATE InputState;
 
@@ -38,19 +39,20 @@ computer_intelligence (COUNT player, STA
 
 	if (StarShipPtr)
 	{
-		if (PlayerControl[player] & CYBORG_CONTROL)
+		// Selecting the next action for in battle.
+		if (PlayerControl[context->playerNr] & CYBORG_CONTROL)
 		{
-			InputState = tactical_intelligence (player, StarShipPtr);
+			InputState = tactical_intelligence (context, StarShipPtr);
 
-			// allow a player to warp-escape in cyborg mode
-			if (player == 0)
-				InputState |= (*(HumanInput[player])) (player, StarShipPtr)
-						& BATTLE_ESCAPE;
+			// Allow a player to warp-escape in cyborg mode
+			if (context->playerNr == 0)
+				InputState |= CurrentInputToBattleInput (
+						context->playerNr) & BATTLE_ESCAPE;
 		}
 		else
-			InputState = (*(HumanInput[player])) (player, StarShipPtr);
+			InputState = CurrentInputToBattleInput (context->playerNr);
 	}
-	else if (!(PlayerControl[player] & PSYTRON_CONTROL))
+	else if (!(PlayerControl[context->playerNr] & PSYTRON_CONTROL))
 		InputState = 0;
 	else
 	{
diff -ruNp src.orig/sc2code/intel.h src/sc2code/intel.h
--- src.orig/sc2code/intel.h	2017-11-08 16:49:28 -0600
+++ src/sc2code/intel.h	2017-11-08 16:49:55 -0600
@@ -19,27 +19,11 @@
 #ifndef _INTEL_H
 #define _INTEL_H
 
+#include "battlecontrols.h"
 #include "controls.h"
 #include "element.h"
 #include "races.h"
 
-typedef enum
-{
-	PURSUE = 0,
-	AVOID,
-	ENTICE,
-	NO_MOVEMENT
-} MOVEMENT_STATE;
-
-typedef struct
-{
-	PELEMENT ObjectPtr;
-	COUNT facing, which_turn;
-	MOVEMENT_STATE MoveState;
-} EVALUATE_DESC;
-typedef EVALUATE_DESC *PEVALUATE_DESC;
-#define EVALUATE_DESCPTR PEVALUATE_DESC
-
 #define MANEUVERABILITY(pi) ((pi)->ManeuverabilityIndex)
 #define WEAPON_RANGE(pi) ((pi)->WeaponRange)
 
@@ -60,30 +44,33 @@ enum
 	FIRST_EMPTY_INDEX
 };
 
-extern STARSHIPPTR CyborgDescPtr;
+extern STARSHIP *CyborgDescPtr;
 extern SIZE cur_player;
 
-extern BATTLE_INPUT_STATE computer_intelligence (COUNT player,
-		STARSHIPPTR StarShipPtr);
-extern BATTLE_INPUT_STATE tactical_intelligence (COUNT player,
-		STARSHIPPTR StarShipPtr);
-extern void ship_intelligence (ELEMENTPTR ShipPtr, EVALUATE_DESCPTR
-		ObjectsOfConcern, COUNT ConcernCounter);
-extern BOOLEAN ship_weapons (ELEMENTPTR ShipPtr, ELEMENTPTR OtherPtr,
+extern BATTLE_INPUT_STATE computer_intelligence (
+		ComputerInputContext *context, STARSHIP *StarShipPtr);
+extern BATTLE_INPUT_STATE tactical_intelligence (
+		ComputerInputContext *context, STARSHIP *StarShipPtr);
+extern void ship_intelligence (ELEMENT *ShipPtr,
+		EVALUATE_DESC *ObjectsOfConcern, COUNT ConcernCounter);
+extern BOOLEAN ship_weapons (ELEMENT *ShipPtr, ELEMENT *OtherPtr,
 		COUNT margin_of_error);
 
-extern void Pursue (ELEMENTPTR ShipPtr, EVALUATE_DESCPTR EvalDescPtr);
-extern void Entice (ELEMENTPTR ShipPtr, EVALUATE_DESCPTR EvalDescPtr);
-extern void Avoid (ELEMENTPTR ShipPtr, EVALUATE_DESCPTR EvalDescPtr);
-extern BOOLEAN TurnShip (ELEMENTPTR ShipPtr, COUNT angle);
-extern BOOLEAN ThrustShip (ELEMENTPTR ShipPtr, COUNT angle);
+extern void Pursue (ELEMENT *ShipPtr, EVALUATE_DESC *EvalDescPtr);
+extern void Entice (ELEMENT *ShipPtr, EVALUATE_DESC *EvalDescPtr);
+extern void Avoid (ELEMENT *ShipPtr, EVALUATE_DESC *EvalDescPtr);
+extern BOOLEAN TurnShip (ELEMENT *ShipPtr, COUNT angle);
+extern BOOLEAN ThrustShip (ELEMENT *ShipPtr, COUNT angle);
 
 
 #define HUMAN_CONTROL (BYTE)(1 << 0)
 #define CYBORG_CONTROL (BYTE)(1 << 1)
+		// The computer fights the battles.
 #define PSYTRON_CONTROL (BYTE)(1 << 2)
+		// The computer selects the ships to fight with.
 #define NETWORK_CONTROL (BYTE)(1 << 3)
 #define COMPUTER_CONTROL (CYBORG_CONTROL | PSYTRON_CONTROL)
+#define CONTROL_MASK (HUMAN_CONTROL | COMPUTER_CONTROL | NETWORK_CONTROL)
 
 #define STANDARD_RATING (BYTE)(1 << 4)
 #define GOOD_RATING (BYTE)(1 << 5)
diff -ruNp src.orig/sc2code/intro.c src/sc2code/intro.c
--- src.orig/sc2code/intro.c	2017-11-08 16:49:28 -0600
+++ src/sc2code/intro.c	2017-11-08 16:49:55 -0600
@@ -27,17 +27,18 @@
 #include "libs/graphics/gfx_common.h"
 #include "libs/graphics/drawable.h"
 #include "libs/sound/sound.h"
-//#include "libs/vidlib.h"
+#include "libs/vidlib.h"
 #include "libs/inplib.h"
 #include "libs/log.h"
 
 #include <ctype.h>
 
+static BOOLEAN ShowSlidePresentation (STRING PresStr);
 
 typedef struct
 {
 	/* standard state required by DoInput */
-	BOOLEAN (*InputFunc) (PVOID pInputState);
+	BOOLEAN (*InputFunc) (void *pInputState);
 	COUNT MenuRepeatDelay;
 
 	/* Presentation state */
@@ -46,7 +47,8 @@ typedef struct
 	TimeCount TimeOut;
 	int TimeOutOnSkip;
 	STRING SlideShow;
-	FONT Font;
+#define MAX_FONTS 5
+	FONT Fonts[MAX_FONTS];
 	FRAME Frame;
 	MUSIC_REF MusicRef;
 	BOOLEAN Batched;
@@ -59,34 +61,31 @@ typedef struct
 	COLOR TextColor;
 	COLOR TextBackColor;
 	int TextVPos;
+	int TextEffect;
 	RECT clip_r;
 	RECT tfade_r;
 #define MAX_TEXT_LINES 15
 	TEXT TextLines[MAX_TEXT_LINES];
 	COUNT LinesCount;
 	char Buffer[512];
+	int MovieFrame;
+	int MovieEndFrame;
+	int InterframeDelay;
 
-} PRESENTATION_INPUT_STATE, *PPRESENTATION_INPUT_STATE;
+} PRESENTATION_INPUT_STATE;
 
+typedef struct {
+	/* standard state required by DoInput */
+	BOOLEAN (*InputFunc) (void *pInputState);
+	COUNT MenuRepeatDelay;
 
-static BOOLEAN DoPresentation (PVOID pIS);
-
+	/* Spinanim state */
+	STAMP anim;
+	TimeCount last_time;
+	int debounce;
+} SPINANIM_INPUT_STATE;
 
-BOOLEAN
-DoFMV (const char *name, const char *loopname, BOOLEAN uninit)
-{
-	VIDEO_REF VidRef;
-
-	VidRef = LoadVideoFile (name);
-	if (!VidRef)
-		return FALSE;
-	VidPlay (VidRef, loopname, uninit);
-	VidDoInput ();
-	VidStop ();
-	DestroyVideo (VidRef);
-	
-	return TRUE;
-}
+static BOOLEAN DoPresentation (void *pIS);
 
 static BOOLEAN
 ParseColorString (const char *Src, COLOR* pColor)
@@ -115,21 +114,17 @@ DoFadeScreen (PRESENTATION_INPUT_STATE*
 }
 
 static void
-DrawTracedText (TEXT *pText, COLOR Fore, COLOR Back)
+DrawTextEffect (TEXT *pText, COLOR Fore, COLOR Back, int Effect)
 {
-	SetContextForeGroundColor (Back);
-	pText->baseline.x--;
-	font_DrawText (pText);
-	pText->baseline.x += 2;
-	font_DrawText (pText);
-	pText->baseline.x--;
-	pText->baseline.y--;
-	font_DrawText (pText);
-	pText->baseline.y += 2;
-	font_DrawText (pText);
-	pText->baseline.y--;
-	SetContextForeGroundColor (Fore);
-	font_DrawText (pText);
+	if (Effect == 'T')
+	{
+		font_DrawTracedText (pText, Fore, Back);
+	}
+	else
+	{
+		SetContextForeGroundColor (Fore);
+		font_DrawText (pText);
+	}
 }
 
 static COUNT
@@ -204,7 +199,7 @@ Present_GenerateSIS (PRESENTATION_INPUT_
 			WANT_PIXMAP, r.extent.width, r.extent.height, 1
 			));
 	SetContextFGFrame (SisFrame);
-	SetContextClipRect (NULL_PTR);
+	SetContextClipRect (NULL);
 	SisBack = BUILD_COLOR (MAKE_RGB15 (0x01, 0x01, 0x01), 0x07);
 	SetContextBackGroundColor (SisBack);
 	ClearDrawable ();
@@ -266,15 +261,29 @@ Present_GenerateSIS (PRESENTATION_INPUT_
 	pPIS->SisFrame = SisFrame;
 }
 
+static void
+Present_DrawMovieFrame (PRESENTATION_INPUT_STATE* pPIS)
+{
+	STAMP s;
+
+	s.origin.x = 0;
+	s.origin.y = 0;
+	s.frame = SetAbsFrameIndex (pPIS->Frame, pPIS->MovieFrame);
+	LockMutex (GraphicsLock);
+	SetContextClipping (TRUE);
+	DrawStamp (&s);
+	UnlockMutex (GraphicsLock);
+}
+
 BOOLEAN
 ShowPresentationFile (const char *name)
 {
-	return ShowPresentation (CaptureStringTable (
+	return ShowSlidePresentation (CaptureStringTable (
 			LoadStringTableFile (contentDir, name)));
 }
 
 static BOOLEAN
-DoPresentation (PVOID pIS)
+DoPresentation (void *pIS)
 {
 	PRESENTATION_INPUT_STATE* pPIS = (PRESENTATION_INPUT_STATE*) pIS;
 
@@ -284,10 +293,23 @@ DoPresentation (PVOID pIS)
 
 	if (pPIS->TimeOut)
 	{
-		if (GetTimeCounter () > pPIS->TimeOut)
-		{	/* time elapsed - continue normal ops */
-			pPIS->TimeOut = 0;
-			return TRUE;
+		TimeCount Delay = ONE_SECOND / 84;
+
+		if (GetTimeCounter () >= pPIS->TimeOut)
+		{
+			if (pPIS->MovieFrame >= 0)
+			{	/* Movie mode */
+				Present_DrawMovieFrame (pPIS);
+				++pPIS->MovieFrame;
+				if (pPIS->MovieFrame > pPIS->MovieEndFrame)
+					pPIS->MovieFrame = -1; /* movie is done */
+				Delay = pPIS->InterframeDelay;
+			}
+			else
+			{	/* time elapsed - continue normal ops */
+				pPIS->TimeOut = 0;
+				return TRUE;
+			}
 		}
 		
 		if (pPIS->TimeOutOnSkip &&
@@ -296,10 +318,11 @@ DoPresentation (PVOID pIS)
 			|| PulsedInputState.menu[KEY_MENU_RIGHT]) )
 		{	/* skip requested - continue normal ops */
 			pPIS->TimeOut = 0;
+			pPIS->MovieFrame = -1; /* abort any movie in progress */
 			return TRUE;
 		}
 
-		SleepThread (ONE_SECOND / 84);
+		SleepThread (Delay);
 		return TRUE;
 	}
 
@@ -336,15 +359,31 @@ DoPresentation (PVOID pIS)
 			}
 		}
 		else if (strcmp (Opcode, "FONT") == 0)
-		{	/* set font */
-			utf8StringCopy (pPIS->Buffer, sizeof (pPIS->Buffer), pStr);
-			if (pPIS->Font)
-				DestroyFont (ReleaseFont (pPIS->Font));
-			pPIS->Font = CaptureFont ((FONT_REF) LoadFontFile (pPIS->Buffer));
+		{	/* set and/or load a font */
+			int index;
+			FONT *pFont;
+
+			assert (sizeof (pPIS->Buffer) >= 256);
+
+			pPIS->Buffer[0] = '\0';
+			if (1 > sscanf (pStr, "%d %255[^\n]", &index, pPIS->Buffer) ||
+					index < 0 || index >= MAX_FONTS)
+			{
+				log_add (log_Warning, "Bad FONT command '%s'", pStr);
+				continue;
+			}
+			pFont = &pPIS->Fonts[index];
+
+			if (pPIS->Buffer[0])
+			{	/* asked to load a font */
+				if (*pFont)
+					DestroyFont (*pFont);
+				*pFont = LoadFontFile (pPIS->Buffer);
+			}
 
 			if (!pPIS->Batched)
 				LockMutex (GraphicsLock);
-			SetContextFont (pPIS->Font);
+			SetContextFont (*pFont);
 			if (!pPIS->Batched)
 				UnlockMutex (GraphicsLock);
 		}
@@ -353,7 +392,7 @@ DoPresentation (PVOID pIS)
 			utf8StringCopy (pPIS->Buffer, sizeof (pPIS->Buffer), pStr);
 			if (pPIS->Frame)
 				DestroyDrawable (ReleaseDrawable (pPIS->Frame));
-			pPIS->Frame = CaptureDrawable (LoadCelFile (pPIS->Buffer));
+			pPIS->Frame = CaptureDrawable (LoadGraphicFile (pPIS->Buffer));
 		}
 		else if (strcmp (Opcode, "MUSIC") == 0)
 		{	/* set music */
@@ -423,48 +462,33 @@ DoPresentation (PVOID pIS)
 		{	/* text vertical align */
 			pPIS->TextVPos = toupper (*pStr);
 		}
+		else if (strcmp (Opcode, "TE") == 0)
+		{	/* text vertical align */
+			pPIS->TextEffect = toupper (*pStr);
+		}
 		else if (strcmp (Opcode, "TEXT") == 0)
 		{	/* simple text draw */
-			SIZE leading;
-			COUNT i;
-			COORD y;
-			
-			utf8StringCopy (pPIS->Buffer, sizeof (pPIS->Buffer), pStr);
-			pPIS->LinesCount = ParseTextLines (pPIS->TextLines,
-					MAX_TEXT_LINES, pPIS->Buffer);
-			
-			if (!pPIS->Batched)
-				LockMutex (GraphicsLock);
-			GetContextFontLeading (&leading);
-			if (!pPIS->Batched)
-				UnlockMutex (GraphicsLock);
-			switch (pPIS->TextVPos)
-			{
-			case 'T': /* top */
-				y = leading;
-				break;
-			case 'M': /* middle */
-				y = (pPIS->clip_r.extent.height
-						- pPIS->LinesCount * leading) / 2;
-				break;
-			default: /* bottom */
-				y = pPIS->clip_r.extent.height - pPIS->LinesCount * leading;
-			}
-			for (i = 0; i < pPIS->LinesCount; ++i, y += leading)
+			int x, y;
+
+			assert (sizeof (pPIS->Buffer) >= 256);
+
+			if (3 == sscanf (pStr, "%d %d %255[^\n]", &x, &y, pPIS->Buffer))
 			{
-				pPIS->TextLines[i].align = ALIGN_CENTER;
-				pPIS->TextLines[i].baseline.x = SCREEN_WIDTH / 2;
-				pPIS->TextLines[i].baseline.y = y;
-			}
+				TEXT t;
 
-			if (!pPIS->Batched)
-				LockMutex (GraphicsLock);
-			SetContextClipping (TRUE);
-			for (i = 0; i < pPIS->LinesCount; ++i)
-				DrawTracedText (pPIS->TextLines + i,
-						pPIS->TextColor, pPIS->TextBackColor);
-			if (!pPIS->Batched)
-				UnlockMutex (GraphicsLock);
+				t.align = ALIGN_CENTER;
+				t.pStr = pPIS->Buffer;
+				t.CharCount = (COUNT)~0;
+				t.baseline.x = x;
+				t.baseline.y = y;
+				if (!pPIS->Batched)
+					LockMutex (GraphicsLock);
+				SetContextClipping (TRUE);
+				DrawTextEffect (&t, pPIS->TextColor, pPIS->TextBackColor,
+						pPIS->TextEffect);
+				if (!pPIS->Batched)
+					UnlockMutex (GraphicsLock);
+			}
 		}
 		else if (strcmp (Opcode, "TFI") == 0)
 		{	/* text fade-in */
@@ -507,15 +531,15 @@ DoPresentation (PVOID pIS)
 			LockMutex (GraphicsLock);
 			SetContextClipping (TRUE);
 			for (i = 0; i < pPIS->LinesCount; ++i)
-				DrawTracedText (pPIS->TextLines + i,
-						pPIS->TextFadeColor, pPIS->TextFadeColor);
+				DrawTextEffect (pPIS->TextLines + i, pPIS->TextFadeColor,
+						pPIS->TextFadeColor, pPIS->TextEffect);
 
 			/* do transition */
 			SetTransitionSource (&pPIS->tfade_r);
 			BatchGraphics ();
 			for (i = 0; i < pPIS->LinesCount; ++i)
-				DrawTracedText (pPIS->TextLines + i,
-						pPIS->TextColor, pPIS->TextBackColor);
+				DrawTextEffect (pPIS->TextLines + i, pPIS->TextColor,
+						pPIS->TextBackColor, pPIS->TextEffect);
 			ScreenTransition (3, &pPIS->tfade_r);
 			UnbatchGraphics ();
 			
@@ -533,8 +557,8 @@ DoPresentation (PVOID pIS)
 			SetTransitionSource (&pPIS->tfade_r);
 			BatchGraphics ();
 			for (i = 0; i < pPIS->LinesCount; ++i)
-				DrawTracedText (pPIS->TextLines + i,
-						pPIS->TextFadeColor, pPIS->TextFadeColor);
+				DrawTextEffect (pPIS->TextLines + i, pPIS->TextFadeColor,
+						pPIS->TextFadeColor, pPIS->TextEffect);
 			ScreenTransition (3, &pPIS->tfade_r);
 			UnbatchGraphics ();
 			UnlockMutex (GraphicsLock);
@@ -556,20 +580,23 @@ DoPresentation (PVOID pIS)
 			int cargs;
 			int draw_what;
 			int index, x, y, scale, angle;
+			int scale_mode;
 			char ImgName[16];
-			int OldScale;
+			int old_scale, old_mode;
 			STAMP s;
 
 			if (1 == sscanf (pStr, "%15s", ImgName)
 					&& strcmp (strupr (ImgName), "SIS") == 0)
 			{
 				draw_what = PRES_DRAW_SIS;
+				scale_mode = TFB_SCALE_NEAREST;
 				cargs = sscanf (pStr, "%*s %d %d %d %d",
 							&x, &y, &scale, &angle) + 1;
 			}
 			else
 			{
 				draw_what = PRES_DRAW_INDEX;
+				scale_mode = TFB_SCALE_BILINEAR;
 				cargs = sscanf (pStr, "%d %d %d %d %d",
 							&index, &x, &y, &scale, &angle);
 			}
@@ -617,11 +644,12 @@ DoPresentation (PVOID pIS)
 			s.origin.y = y;
 			if (!pPIS->Batched)
 				LockMutex (GraphicsLock);
-			OldScale = GetGraphicScale ();
-			SetGraphicScale (scale);
+			old_mode = SetGraphicScaleMode (scale_mode);
+			old_scale = SetGraphicScale (scale);
 			SetContextClipping (TRUE);
 			DrawStamp (&s);
-			SetGraphicScale (OldScale);
+			SetGraphicScale (old_scale);
+			SetGraphicScaleMode (old_mode);
 			if (!pPIS->Batched)
 				UnlockMutex (GraphicsLock);
 		}
@@ -670,6 +698,52 @@ DoPresentation (PVOID pIS)
 			utf8StringCopy (pPIS->Buffer, sizeof (pPIS->Buffer), pStr);
 			ShowPresentationFile (pPIS->Buffer);
 		}
+		else if (strcmp (Opcode, "LINE") == 0)
+		{
+			int x1, x2, y1, y2;
+			if (4 == sscanf (pStr, "%d %d %d %d", &x1, &y1, &x2, &y2))
+			{
+				LINE l;
+
+				l.first.x = x1;
+				l.first.y = y1;
+				l.second.x = x2;
+				l.second.y = y2;
+				
+				if (!pPIS->Batched)
+					LockMutex (GraphicsLock);
+				SetContextForeGroundColor (pPIS->TextColor);
+				DrawLine (&l);
+				if (!pPIS->Batched)
+					UnlockMutex (GraphicsLock);
+			}
+			else
+			{
+				log_add (log_Warning, "Bad LINE command '%s'", pStr);
+			}
+		}
+		else if (strcmp (Opcode, "MOVIE") == 0)
+		{
+			int fps, from, to;
+		
+			if (3 == sscanf (pStr, "%d %d %d", &fps, &from, &to) &&
+					fps > 0 && from >= 0 && to >= 0 && to >= from)
+			{
+				Present_UnbatchGraphics (pPIS, TRUE);
+				
+				pPIS->MovieFrame = from;
+				pPIS->MovieEndFrame = to;
+				pPIS->InterframeDelay = ONE_SECOND / fps;
+
+				pPIS->TimeOut = GetTimeCounter ();
+				pPIS->TimeOutOnSkip = TRUE;
+				return TRUE;
+			}
+			else
+			{
+				log_add (log_Warning, "Bad MOVIE command '%s'", pStr);
+			}
+		}
 		else if (strcmp (Opcode, "NOOP") == 0)
 		{	/* no operation - must be a comment in script */
 			/* do nothing */
@@ -679,14 +753,16 @@ DoPresentation (PVOID pIS)
 	return FALSE;
 }
 
-BOOLEAN
-ShowPresentation (STRING PresStr)
+static BOOLEAN
+ShowSlidePresentation (STRING PresStr)
 {
 	CONTEXT OldContext;
 	FONT OldFont;
 	RECT OldRect;
 	PRESENTATION_INPUT_STATE pis;
+	int i;
 
+	memset (&pis, 0, sizeof(pis));
 	pis.SlideShow = PresStr;
 	if (!pis.SlideShow)
 		return FALSE;
@@ -697,27 +773,17 @@ ShowPresentation (STRING PresStr)
 	OldContext = SetContext (ScreenContext);
 	GetContextClipRect (&OldRect);
 	OldFont = SetContextFont (NULL);
-	/* paint black rect over screen	*/
-	SetContextBackGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x00), 0x00));
-	ClearDrawable ();
 	UnlockMutex (GraphicsLock);
 
 	FlushInput ();
 	SetMenuSounds (MENU_SOUND_NONE, MENU_SOUND_NONE);
 	pis.MenuRepeatDelay = 0;
 	pis.InputFunc = DoPresentation;
-	pis.Font = 0;
-	pis.Frame = 0;
-	pis.RotatedFrame = 0;
 	pis.LastDrawKind = -1;
-	pis.LastAngle = 0;
-	pis.MusicRef = 0;
-	pis.SisFrame = 0;
-	pis.Batched = FALSE;
 	pis.TextVPos = 'B';
-	pis.LastSyncTime = pis.StartTime = GetTimeCounter ();
-	pis.TimeOut = 0;
+	pis.MovieFrame = -1;
+	pis.StartTime = GetTimeCounter ();
+	pis.LastSyncTime = pis.StartTime;
 	DoInput (&pis, TRUE);
 
 	SleepThreadUntil (FadeMusic (0, ONE_SECOND));
@@ -727,7 +793,8 @@ ShowPresentation (STRING PresStr)
 	DestroyMusic (pis.MusicRef);
 	DestroyDrawable (ReleaseDrawable (pis.RotatedFrame));
 	DestroyDrawable (ReleaseDrawable (pis.Frame));
-	DestroyFont (ReleaseFont (pis.Font));
+	for (i = 0; i < MAX_FONTS; ++i)
+		DestroyFont (pis.Fonts[i]);
 	DestroyStringTable (ReleaseStringTable (pis.SlideShow));
 
 	LockMutex (GraphicsLock);
@@ -739,4 +806,27 @@ ShowPresentation (STRING PresStr)
 	return TRUE;
 }
 
-
+BOOLEAN
+ShowPresentation (RESOURCE res)
+{
+	const char *resType = res_GetResourceType (res);
+	if (!resType)
+	{
+		return FALSE;
+	}
+	if (!strcmp (resType, "STRTAB"))
+	{
+		return ShowSlidePresentation (CaptureStringTable (
+			LoadStringTable (res)));
+	}
+	else if (!strcmp (resType, "3DOVID"))
+	{
+		LEGACY_VIDEO vid = LoadLegacyVideoInstance (res);
+		BOOLEAN result = PlayLegacyVideo (vid);
+		DestroyLegacyVideo (vid);
+		return result;
+	}
+	
+	log_add (log_Warning, "Tried to present '%s', of non-presentable type '%s'", res, resType);
+	return FALSE;
+}
diff -ruNp src.orig/sc2code/ipdisp.c src/sc2code/ipdisp.c
--- src.orig/sc2code/ipdisp.c	2017-11-08 16:49:28 -0600
+++ src/sc2code/ipdisp.c	2017-11-08 16:49:55 -0600
@@ -20,6 +20,7 @@
 #include "globdata.h"
 #include "init.h"
 #include "races.h"
+#include "grpinfo.h"
 #include "encount.h"
 #include "libs/mathlib.h"
 
@@ -27,33 +28,37 @@
 void
 NotifyOthers (COUNT which_race, BYTE target_loc)
 {
-	HSTARSHIP hStarShip, hNextShip;
+	HSHIPFRAG hGroup, hNextGroup;
 
-	for (hStarShip = GetHeadLink (&GLOBAL (npc_built_ship_q));
-			hStarShip; hStarShip = hNextShip)
+	for (hGroup = GetHeadLink (&GLOBAL (ip_group_q));
+			hGroup; hGroup = hNextGroup)
 	{
-		SHIP_FRAGMENTPTR StarShipPtr;
+		IP_GROUP *GroupPtr;
 
-		StarShipPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-				&GLOBAL (npc_built_ship_q), hStarShip);
-		hNextShip = _GetSuccLink (StarShipPtr);
+		GroupPtr = LockIpGroup (&GLOBAL (ip_group_q), hGroup);
+		hNextGroup = _GetSuccLink (GroupPtr);
 
-		if (GET_RACE_ID (StarShipPtr) == which_race)
+		if (GroupPtr->race_id == which_race)
 		{
 			BYTE task;
 
-			task = GET_GROUP_MISSION (StarShipPtr) | IGNORE_FLAGSHIP;
+			task = GroupPtr->task | IGNORE_FLAGSHIP;
 
 			if (target_loc == 0)
 			{
 				task &= ~IGNORE_FLAGSHIP;
-				SET_ORBIT_LOC (StarShipPtr, GET_GROUP_DEST (StarShipPtr));
+				// XXX: orbit_pos is abused here to store the previous
+				//   group destination, before the intercept task.
+				//   Returned to dest_loc below.
+				GroupPtr->orbit_pos = GroupPtr->dest_loc;
 /* task = FLEE | IGNORE_FLAGSHIP; */
 			}
-			else if ((target_loc = GET_GROUP_DEST (StarShipPtr)) == 0)
+			else if ((target_loc = GroupPtr->dest_loc) == 0)
 			{
-				target_loc = GET_ORBIT_LOC (StarShipPtr);
-				SET_ORBIT_LOC (StarShipPtr, NORMALIZE_FACING (TFB_Random ()));
+				// XXX: orbit_pos is abused to store the previous
+				//   group destination, before the intercept task.
+				target_loc = GroupPtr->orbit_pos;
+				GroupPtr->orbit_pos = NORMALIZE_FACING (TFB_Random ());
 #ifdef OLD
 				target_loc = (BYTE)((
 						(COUNT)TFB_Random ()
@@ -62,24 +67,24 @@ NotifyOthers (COUNT which_race, BYTE tar
 				if (!(task & REFORM_GROUP))
 				{
 					if ((task & ~IGNORE_FLAGSHIP) != EXPLORE)
-						StarShipPtr->ShipInfo.group_counter = 0;
+						GroupPtr->group_counter = 0;
 					else
-						StarShipPtr->ShipInfo.group_counter =
+						GroupPtr->group_counter =
 								((COUNT) TFB_Random () % MAX_REVOLUTIONS)
 								<< FACING_SHIFT;
 				}
 			}
 
-			SET_GROUP_MISSION (StarShipPtr, task);
-			SET_GROUP_DEST (StarShipPtr, target_loc);
+			GroupPtr->task = task;
+			GroupPtr->dest_loc = target_loc;
 		}
 
-		UnlockStarShip (&GLOBAL (npc_built_ship_q), hStarShip);
+		UnlockIpGroup (&GLOBAL (ip_group_q), hGroup);
 	}
 }
 
 static void
-ip_group_preprocess (PELEMENT ElementPtr)
+ip_group_preprocess (ELEMENT *ElementPtr)
 {
 #define TRACK_WAIT 5
 	BYTE task;
@@ -87,19 +92,19 @@ ip_group_preprocess (PELEMENT ElementPtr
 	SIZE radius;
 	POINT dest_pt;
 	SIZE vdx, vdy;
-	ELEMENTPTR EPtr;
-	SHIP_FRAGMENTPTR StarShipPtr;
+	ELEMENT *EPtr;
+	IP_GROUP *GroupPtr;
 
-	EPtr = (ELEMENTPTR)ElementPtr;
+	EPtr = ElementPtr;
 	EPtr->state_flags &=
 			~(DISAPPEARING | NONSOLID); /* "I'm not quite dead." */
 	++EPtr->life_span; /* so that it will 'die'
 										 * again next time.
 										 */
-	GetElementStarShip (EPtr, &StarShipPtr);
-	group_loc = GET_GROUP_LOC (StarShipPtr);
+	GetElementStarShip (EPtr, &GroupPtr);
+	group_loc = GroupPtr->sys_loc;
 			/* save old location */
-	DisplayArray[EPtr->PrimIndex].Object.Point = StarShipPtr->ShipInfo.loc;
+	DisplayArray[EPtr->PrimIndex].Object.Point = GroupPtr->loc;
 
 	if (group_loc != 0)
 		radius = MAX_ZOOM_RADIUS;
@@ -107,10 +112,10 @@ ip_group_preprocess (PELEMENT ElementPtr
 		radius = pSolarSysState->SunDesc[0].radius;
 
 	dest_pt.x = (SIS_SCREEN_WIDTH >> 1)
-			+ (SIZE)((long)StarShipPtr->ShipInfo.loc.x
+			+ (SIZE)((long)GroupPtr->loc.x
 			* (DISPLAY_FACTOR >> 1) / radius);
 	dest_pt.y = (SIS_SCREEN_HEIGHT >> 1)
-			+ (SIZE)((long)StarShipPtr->ShipInfo.loc.y
+			+ (SIZE)((long)GroupPtr->loc.y
 			* (DISPLAY_FACTOR >> 1) / radius);
 	EPtr->current.location.x = DISPLAY_TO_WORLD (dest_pt.x)
 			+ (COORD)(LOG_SPACE_WIDTH >> 1)
@@ -127,22 +132,19 @@ ip_group_preprocess (PELEMENT ElementPtr
 		flagship_loc = (BYTE)(pSolarSysState->pBaseDesc->pPrevDesc
 				- pSolarSysState->PlanetDesc + 1);
 
-	task = GET_GROUP_MISSION (StarShipPtr);
+	task = GroupPtr->task;
 	if (pSolarSysState->MenuState.CurState)
 		goto ExitIPProcess;
 
-	if ((task & REFORM_GROUP)
-			&& --StarShipPtr->ShipInfo.group_counter == 0)
+	if ((task & REFORM_GROUP) && --GroupPtr->group_counter == 0)
 	{
 		task &= ~REFORM_GROUP;
-		SET_GROUP_MISSION (StarShipPtr, task);
+		GroupPtr->task = task;
 		if ((task & ~IGNORE_FLAGSHIP) != EXPLORE)
-			StarShipPtr->ShipInfo.group_counter = 0;
+			GroupPtr->group_counter = 0;
 		else
-			StarShipPtr->ShipInfo.group_counter =
-					((COUNT)TFB_Random ()
-					% MAX_REVOLUTIONS)
-					<< FACING_SHIFT;
+			GroupPtr->group_counter = ((COUNT)TFB_Random ()
+					% MAX_REVOLUTIONS) << FACING_SHIFT;
 	}
 
 	if (!(task & REFORM_GROUP))
@@ -161,7 +163,7 @@ ip_group_preprocess (PELEMENT ElementPtr
 		}
 	}
 
-	target_loc = GET_GROUP_DEST (StarShipPtr);
+	target_loc = GroupPtr->dest_loc;
 	if (!(task & (IGNORE_FLAGSHIP | REFORM_GROUP)))
 	{
 		if (target_loc == 0 && task != FLEE)
@@ -182,22 +184,20 @@ ip_group_preprocess (PELEMENT ElementPtr
 			if (group_loc != 0) /* if in planetary views */
 			{
 				detect_dist *= (MAX_ZOOM_RADIUS / MIN_ZOOM_RADIUS);
-				if (GET_RACE_ID (StarShipPtr) == URQUAN_PROBE_SHIP)
+				if (GroupPtr->race_id == URQUAN_PROBE_SHIP)
 					detect_dist <<= 1;
 			}
-			vdx = GLOBAL (ip_location.x)
-					- StarShipPtr->ShipInfo.loc.x;
-			vdy = GLOBAL (ip_location.y)
-					- StarShipPtr->ShipInfo.loc.y;
+			vdx = GLOBAL (ip_location.x) - GroupPtr->loc.x;
+			vdy = GLOBAL (ip_location.y) - GroupPtr->loc.y;
 			if ((long)vdx * vdx
 					+ (long)vdy * vdy < (long)detect_dist * detect_dist)
 			{
 				EPtr->thrust_wait = 0;
 				ZeroVelocityComponents (&EPtr->velocity);
 
-				NotifyOthers (GET_RACE_ID (StarShipPtr), 0);
-				task = GET_GROUP_MISSION (StarShipPtr);
-				if ((target_loc = GET_GROUP_DEST (StarShipPtr)) == 0)
+				NotifyOthers (GroupPtr->race_id, 0);
+				task = GroupPtr->task;
+				if ((target_loc = GroupPtr->dest_loc) == 0)
 					target_loc = flagship_loc;
 			}
 		}
@@ -209,7 +209,7 @@ ip_group_preprocess (PELEMENT ElementPtr
 	if (task <= ON_STATION)
 #ifdef NEVER
 	if (task <= FLEE || (task == ON_STATION
-			&& GET_GROUP_DEST (StarShipPtr) == 0))
+			&& GroupPtr->dest_loc == 0))
 #endif /* NEVER */
 	{
 		BOOLEAN Transition;
@@ -220,16 +220,15 @@ ip_group_preprocess (PELEMENT ElementPtr
 		Transition = FALSE;
 		if (task == FLEE)
 		{
-			dest_pt.x = StarShipPtr->ShipInfo.loc.x << 1;
-			dest_pt.y = StarShipPtr->ShipInfo.loc.y << 1;
+			dest_pt.x = GroupPtr->loc.x << 1;
+			dest_pt.y = GroupPtr->loc.y << 1;
 		}
-		else if (((task != ON_STATION || GET_GROUP_DEST (StarShipPtr) == 0)
+		else if (((task != ON_STATION || GroupPtr->dest_loc == 0)
 				&& group_loc == target_loc)
-				|| (task == ON_STATION
-				&& GET_GROUP_DEST (StarShipPtr)
+				|| (task == ON_STATION && GroupPtr->dest_loc
 				&& group_loc == 0))
 		{
-			if (GET_GROUP_DEST (StarShipPtr) == 0)
+			if (GroupPtr->dest_loc == 0)
 				dest_pt = GLOBAL (ip_location);
 			else
 			{
@@ -253,37 +252,38 @@ ip_group_preprocess (PELEMENT ElementPtr
 							);
 				}
 
-				angle = FACING_TO_ANGLE (GET_ORBIT_LOC (StarShipPtr) + 1);
+				angle = FACING_TO_ANGLE (GroupPtr->orbit_pos + 1);
 				dest_pt.x = org.x + COSINE (angle, orbit_dist);
 				dest_pt.y = org.y + SINE (angle, orbit_dist);
-				if (StarShipPtr->ShipInfo.loc.x == dest_pt.x
-						&& StarShipPtr->ShipInfo.loc.y == dest_pt.y)
+				if (GroupPtr->loc.x == dest_pt.x
+						&& GroupPtr->loc.y == dest_pt.y)
 				{
 					BYTE next_loc;
 
-					SET_ORBIT_LOC (StarShipPtr,
-							NORMALIZE_FACING (ANGLE_TO_FACING (angle)));
+					GroupPtr->orbit_pos = NORMALIZE_FACING (
+							ANGLE_TO_FACING (angle));
 					angle += FACING_TO_ANGLE (1);
 					dest_pt.x = org.x + COSINE (angle, orbit_dist);
 					dest_pt.y = org.y + SINE (angle, orbit_dist);
 
 					EPtr->thrust_wait = (BYTE)~0;
-					if (StarShipPtr->ShipInfo.group_counter)
-						--StarShipPtr->ShipInfo.group_counter;
+					if (GroupPtr->group_counter)
+						--GroupPtr->group_counter;
 					else if (task == EXPLORE
 							&& (next_loc = (BYTE)(((COUNT)TFB_Random ()
 							% pSolarSysState->SunDesc[0].NumPlanets)
 							+ 1)) != target_loc)
 					{
 						EPtr->thrust_wait = 0;
-						SET_GROUP_DEST (StarShipPtr, target_loc = next_loc);
+						target_loc = next_loc;
+						GroupPtr->dest_loc = next_loc;
 					}
 				}
 			}
 		}
 		else if (group_loc == 0)
 		{
-			if (GET_GROUP_DEST (StarShipPtr) == 0)
+			if (GroupPtr->dest_loc == 0)
 				dest_pt = pSolarSysState->SunDesc[0].location;
 			else
 				XFormIPLoc (&pSolarSysState->PlanetDesc[
@@ -294,12 +294,12 @@ ip_group_preprocess (PELEMENT ElementPtr
 			if (task == ON_STATION)
 				target_loc = 0;
 
-			dest_pt.x = StarShipPtr->ShipInfo.loc.x << 1;
-			dest_pt.y = StarShipPtr->ShipInfo.loc.y << 1;
+			dest_pt.x = GroupPtr->loc.x << 1;
+			dest_pt.y = GroupPtr->loc.y << 1;
 		}
 
-		delta_x = dest_pt.x - StarShipPtr->ShipInfo.loc.x;
-		delta_y = dest_pt.y - StarShipPtr->ShipInfo.loc.y;
+		delta_x = dest_pt.x - GroupPtr->loc.x;
+		delta_y = dest_pt.y - GroupPtr->loc.y;
 		angle = ARCTAN (delta_x, delta_y);
 
 		if (EPtr->thrust_wait && EPtr->thrust_wait != (BYTE)~0)
@@ -309,7 +309,7 @@ ip_group_preprocess (PELEMENT ElementPtr
 		{
 			SIZE speed;
 
-			if (EPtr->thrust_wait && GET_GROUP_DEST (StarShipPtr) != 0)
+			if (EPtr->thrust_wait && GroupPtr->dest_loc != 0)
 			{
 #define ORBIT_SPEED 60
 				speed = ORBIT_SPEED;
@@ -323,7 +323,7 @@ ip_group_preprocess (PELEMENT ElementPtr
 					RACE_IP_SPEED
 				};
 
-				speed = RaceIPSpeed[GET_RACE_ID (StarShipPtr)];
+				speed = RaceIPSpeed[GroupPtr->race_id];
 				EPtr->thrust_wait = TRACK_WAIT;
 			}
 
@@ -340,13 +340,13 @@ ip_group_preprocess (PELEMENT ElementPtr
 				if (task == FLEE)
 					goto CheckGetAway;
 			}
-			else if (target_loc == GET_GROUP_DEST (StarShipPtr))
+			else if (target_loc == GroupPtr->dest_loc)
 			{
 PartialRevolution:
 				if ((long)((COUNT)(dx * dx) + (COUNT)(dy * dy))
 						>= (long)delta_x * delta_x + (long)delta_y * delta_y)
 				{
-					StarShipPtr->ShipInfo.loc = dest_pt;
+					GroupPtr->loc = dest_pt;
 					vdx = vdy = 0;
 					ZeroVelocityComponents (&EPtr->velocity);
 				}
@@ -367,8 +367,7 @@ PartialRevolution:
 					}
 				}
 
-				if (task == ON_STATION
-						&& GET_GROUP_DEST (StarShipPtr))
+				if (task == ON_STATION && GroupPtr->dest_loc)
 					goto PartialRevolution;
 				else if ((long)((COUNT)(dx * dx) + (COUNT)(dy * dy))
 						>= (long)delta_x * delta_x + (long)delta_y * delta_y)
@@ -378,10 +377,10 @@ PartialRevolution:
 			{
 CheckGetAway:
 				dest_pt.x = (SIS_SCREEN_WIDTH >> 1)
-						+ (SIZE)((long)StarShipPtr->ShipInfo.loc.x
+						+ (SIZE)((long)GroupPtr->loc.x
 						* (DISPLAY_FACTOR >> 1) / MAX_ZOOM_RADIUS);
 				dest_pt.y = (SIS_SCREEN_HEIGHT >> 1)
-						+ (SIZE)((long)StarShipPtr->ShipInfo.loc.y
+						+ (SIZE)((long)GroupPtr->loc.y
 						* (DISPLAY_FACTOR >> 1) / MAX_ZOOM_RADIUS);
 				if (dest_pt.x < 0
 						|| dest_pt.x >= SIS_SCREEN_WIDTH
@@ -399,44 +398,42 @@ CheckGetAway:
 				ZeroVelocityComponents (&EPtr->velocity);
 				if (group_loc != 0)
 				{
-					PPLANET_DESC pCurDesc;
+					PLANET_DESC *pCurDesc;
 
 					pCurDesc = &pSolarSysState->PlanetDesc[group_loc - 1];
-					XFormIPLoc (
-							&pCurDesc->image.origin,
-							&StarShipPtr->ShipInfo.loc,
-							FALSE
-							);
-					SET_GROUP_LOC (StarShipPtr, group_loc = 0);
+					XFormIPLoc (&pCurDesc->image.origin, &GroupPtr->loc,
+							FALSE);
+					group_loc = 0;
+					GroupPtr->sys_loc = 0;
 				}
 				else if (target_loc == 0)
 				{
+					/* Group completely left the star system */
 					EPtr->life_span = 0;
 					EPtr->state_flags |= DISAPPEARING | NONSOLID;
-					StarShipPtr->ShipInfo.crew_level = 0;
+					GroupPtr->in_system = 0;
 					return;
 				}
 				else
 				{
-					if (target_loc == GET_GROUP_DEST (StarShipPtr))
+					if (target_loc == GroupPtr->dest_loc)
 					{
-						SET_ORBIT_LOC (StarShipPtr,
-								NORMALIZE_FACING (
-								ANGLE_TO_FACING (angle + HALF_CIRCLE)
-								));
-						StarShipPtr->ShipInfo.group_counter =
+						GroupPtr->orbit_pos = NORMALIZE_FACING (
+								ANGLE_TO_FACING (angle + HALF_CIRCLE));
+						GroupPtr->group_counter =
 								((COUNT)TFB_Random () % MAX_REVOLUTIONS)
 								<< FACING_SHIFT;
 					}
 
-					StarShipPtr->ShipInfo.loc.x = -(SIZE)((long)COSINE (
+					GroupPtr->loc.x = -(SIZE)((long)COSINE (
 							angle, SIS_SCREEN_WIDTH * 9 / 16
 							) * MAX_ZOOM_RADIUS / (DISPLAY_FACTOR >> 1));
-					StarShipPtr->ShipInfo.loc.y = -(SIZE)((long)SINE (
+					GroupPtr->loc.y = -(SIZE)((long)SINE (
 							angle, SIS_SCREEN_WIDTH * 9 / 16
 							) * MAX_ZOOM_RADIUS / (DISPLAY_FACTOR >> 1));
 
-					SET_GROUP_LOC (StarShipPtr, group_loc = target_loc);
+					group_loc = target_loc;
+					GroupPtr->sys_loc = target_loc;
 				}
 			}
 		}
@@ -458,14 +455,14 @@ CheckGetAway:
 			}
 		}
 	}
-	StarShipPtr->ShipInfo.loc.x += vdx;
-	StarShipPtr->ShipInfo.loc.y += vdy;
+	GroupPtr->loc.x += vdx;
+	GroupPtr->loc.y += vdy;
 
 	dest_pt.x = (SIS_SCREEN_WIDTH >> 1)
-			+ (SIZE)((long)StarShipPtr->ShipInfo.loc.x
+			+ (SIZE)((long)GroupPtr->loc.x
 			* (DISPLAY_FACTOR >> 1) / radius);
 	dest_pt.y = (SIS_SCREEN_HEIGHT >> 1)
-			+ (SIZE)((long)StarShipPtr->ShipInfo.loc.y
+			+ (SIZE)((long)GroupPtr->loc.y
 			* (DISPLAY_FACTOR >> 1) / radius);
 
 ExitIPProcess:
@@ -478,7 +475,7 @@ ExitIPProcess:
 
 	if (group_loc != flagship_loc
 			|| ((task & REFORM_GROUP)
-			&& (StarShipPtr->ShipInfo.group_counter & 1)))
+			&& (GroupPtr->group_counter & 1)))
 	{
 		SetPrimType (&DisplayArray[EPtr->PrimIndex], NO_PRIM);
 		EPtr->state_flags |= NONSOLID;
@@ -494,8 +491,8 @@ ExitIPProcess:
 }
 
 static void
-flag_ship_collision (PELEMENT ElementPtr0, PPOINT pPt0, PELEMENT
-		ElementPtr1, PPOINT pPt1)
+flag_ship_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
 	if ((GLOBAL (CurrentActivity) & START_ENCOUNTER)
 			|| pSolarSysState->MenuState.CurState
@@ -514,10 +511,10 @@ flag_ship_collision (PELEMENT ElementPtr
 }
 
 static void
-ip_group_collision (PELEMENT ElementPtr0, PPOINT pPt0, PELEMENT
-		ElementPtr1, PPOINT pPt1)
+ip_group_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
-	SHIP_FRAGMENTPTR StarShipPtr;
+	IP_GROUP *GroupPtr;
 
 	if ((GLOBAL (CurrentActivity) & START_ENCOUNTER)
 			|| pSolarSysState->MenuState.CurState
@@ -527,7 +524,7 @@ ip_group_collision (PELEMENT ElementPtr0
 		return;
 	}
 
-	GetElementStarShip (ElementPtr0, &StarShipPtr);
+	GetElementStarShip (ElementPtr0, &GroupPtr);
 	if (ElementPtr0->state_flags & ElementPtr1->state_flags & BAD_GUY)
 	{
 		if ((ElementPtr0->state_flags & COLLISION)
@@ -538,7 +535,7 @@ ip_group_collision (PELEMENT ElementPtr0
 		{
 			ElementPtr1->state_flags |= COLLISION;
 
-			StarShipPtr->ShipInfo.loc =
+			GroupPtr->loc =
 					DisplayArray[ElementPtr0->PrimIndex].Object.Point;
 			ElementPtr0->next.location = ElementPtr0->current.location;
 			InitIntersectEndPoint (ElementPtr0);
@@ -546,19 +543,18 @@ ip_group_collision (PELEMENT ElementPtr0
 	}
 	else
 	{
-		EncounterGroup = GET_GROUP_ID (StarShipPtr);
+		EncounterGroup = GroupPtr->group_id;
 
-		if (GET_RACE_ID (StarShipPtr) == URQUAN_PROBE_SHIP)
+		if (GroupPtr->race_id == URQUAN_PROBE_SHIP)
 		{
-			SET_GROUP_MISSION (StarShipPtr, FLEE | IGNORE_FLAGSHIP);
-			SET_GROUP_DEST (StarShipPtr, 0);
+			GroupPtr->task = FLEE | IGNORE_FLAGSHIP;
+			GroupPtr->dest_loc = 0;
 		}
 		else
 		{
-			SET_GROUP_MISSION (StarShipPtr,
-					GET_GROUP_MISSION (StarShipPtr) | REFORM_GROUP);
-			StarShipPtr->ShipInfo.group_counter = 100;
-			NotifyOthers (GET_RACE_ID (StarShipPtr), (BYTE)~0);
+			GroupPtr->task |= REFORM_GROUP;
+			GroupPtr->group_counter = 100;
+			NotifyOthers (GroupPtr->race_id, (BYTE)~0);
 		}
 
 		if (!(ElementPtr1->state_flags & COLLISION)) /* not processed yet */
@@ -574,7 +570,7 @@ ip_group_collision (PELEMENT ElementPtr0
 }
 
 static void
-spawn_ip_group (SHIP_FRAGMENTPTR StarShipPtr)
+spawn_ip_group (IP_GROUP *GroupPtr)
 {
 	HELEMENT hIPSHIPElement;
 
@@ -582,34 +578,36 @@ spawn_ip_group (SHIP_FRAGMENTPTR StarShi
 	if (hIPSHIPElement)
 	{
 		BYTE task;
-		ELEMENTPTR IPSHIPElementPtr;
+		ELEMENT *IPSHIPElementPtr;
 
 		LockElement (hIPSHIPElement, &IPSHIPElementPtr);
-		IPSHIPElementPtr->turn_wait = GET_GROUP_ID (StarShipPtr);
-		IPSHIPElementPtr->mass_points = 1;
+		// XXX: turn_wait hack is not actually used anywhere
+		//IPSHIPElementPtr->turn_wait = GroupPtr->group_id;
+		IPSHIPElementPtr->sys_loc = 1;
 		IPSHIPElementPtr->hit_points = 1;
 		IPSHIPElementPtr->state_flags =
 				CHANGING | FINITE_LIFE | IGNORE_VELOCITY;
 
-		task = GET_GROUP_MISSION (StarShipPtr);
+		task = GroupPtr->task;
 		if (!(task & IGNORE_FLAGSHIP))
 			IPSHIPElementPtr->state_flags |= BAD_GUY;
 		else
 		{
 			IPSHIPElementPtr->state_flags |= GOOD_GUY;
-			if (GET_RACE_ID (StarShipPtr) == YEHAT_SHIP
+			// XXX: Hack: Yehat revolution start, fleeing groups
+			if (GroupPtr->race_id == YEHAT_SHIP
 					&& GET_GAME_STATE (YEHAT_CIVIL_WAR))
 			{
-				SET_GROUP_MISSION (StarShipPtr, FLEE | (task & REFORM_GROUP));
-				SET_GROUP_DEST (StarShipPtr, 0);
+				GroupPtr->task = FLEE | (task & REFORM_GROUP);
+				GroupPtr->dest_loc = 0;
 			}
 		}
 
 		SetPrimType (&DisplayArray[IPSHIPElementPtr->PrimIndex], STAMP_PRIM);
-		IPSHIPElementPtr->current.image.farray =
-				&StarShipPtr->ShipInfo.melee_icon;
-		IPSHIPElementPtr->current.image.frame =
-				SetAbsFrameIndex (StarShipPtr->ShipInfo.melee_icon, 1);
+		// XXX: Hack: farray points to FRAME[3] and given FRAME
+		IPSHIPElementPtr->current.image.farray = &GroupPtr->melee_icon;
+		IPSHIPElementPtr->current.image.frame = SetAbsFrameIndex (
+					GroupPtr->melee_icon, 1);
 			/* preprocessing has a side effect
 			 * we wish to avoid.  So death_func
 			 * is used instead, but will achieve
@@ -623,16 +621,16 @@ spawn_ip_group (SHIP_FRAGMENTPTR StarShi
 			SIZE radius;
 			POINT pt;
 
-			if (GET_GROUP_LOC (StarShipPtr) != 0)
+			if (GroupPtr->sys_loc != 0)
 				radius = MAX_ZOOM_RADIUS;
 			else
 				radius = pSolarSysState->SunDesc[0].radius;
 
 			pt.x = (SIS_SCREEN_WIDTH >> 1)
-					+ (SIZE)((long)StarShipPtr->ShipInfo.loc.x
+					+ (SIZE)((long)GroupPtr->loc.x
 					* DISPLAY_FACTOR / radius);
 			pt.y = (SIS_SCREEN_HEIGHT >> 1)
-					+ (SIZE)((long)StarShipPtr->ShipInfo.loc.y
+					+ (SIZE)((long)GroupPtr->loc.y
 					* (DISPLAY_FACTOR >> 1) / radius);
 
 			IPSHIPElementPtr->current.location.x =
@@ -645,7 +643,7 @@ spawn_ip_group (SHIP_FRAGMENTPTR StarShi
 					- (LOG_SPACE_HEIGHT >> (MAX_REDUCTION + 1));
 		}
 
-		SetElementStarShip (IPSHIPElementPtr, StarShipPtr);
+		SetElementStarShip (IPSHIPElementPtr, GroupPtr);
 
 		SetUpElement (IPSHIPElementPtr);
 		IPSHIPElementPtr->IntersectControl.IntersectStamp.frame =
@@ -660,7 +658,7 @@ spawn_ip_group (SHIP_FRAGMENTPTR StarShi
 #define FLIP_WAIT 42
 
 static void
-flag_ship_preprocess (PELEMENT ElementPtr)
+flag_ship_preprocess (ELEMENT *ElementPtr)
 {
 	if (--ElementPtr->thrust_wait == 0)
 		/* juggle list after flagship */
@@ -671,7 +669,7 @@ flag_ship_preprocess (PELEMENT ElementPt
 				&& hSuccElement != GetTailElement ())
 		{
 			HELEMENT hPredElement;
-			ELEMENTPTR TailPtr;
+			ELEMENT *TailPtr;
 
 			LockElement (GetTailElement (), &TailPtr);
 			hPredElement = _GetPredLink (TailPtr);
@@ -747,7 +745,7 @@ flag_ship_preprocess (PELEMENT ElementPt
 		GLOBAL (ShipStamp.origin) = pt;
 		ElementPtr->next.image.frame = GLOBAL (ShipStamp.frame);
 
-		if (ElementPtr->mass_points == flagship_loc)
+		if (ElementPtr->sys_loc == flagship_loc)
 		{
 			if (ElementPtr->state_flags & NONSOLID)
 				ElementPtr->state_flags &= ~NONSOLID;
@@ -755,7 +753,7 @@ flag_ship_preprocess (PELEMENT ElementPt
 		else /* no collisions during transition */
 		{
 			ElementPtr->state_flags |= NONSOLID;
-			ElementPtr->mass_points = flagship_loc;
+			ElementPtr->sys_loc = flagship_loc;
 		}
 
 		if ((ec = GET_GAME_STATE (ESCAPE_COUNTER))
@@ -779,14 +777,14 @@ spawn_flag_ship (void)
 	hFlagShipElement = AllocElement ();
 	if (hFlagShipElement)
 	{
-		ELEMENTPTR FlagShipElementPtr;
+		ELEMENT *FlagShipElementPtr;
 
 		LockElement (hFlagShipElement, &FlagShipElementPtr);
 		FlagShipElementPtr->hit_points = 1;
 		if (pSolarSysState->pBaseDesc == pSolarSysState->PlanetDesc)
-			FlagShipElementPtr->mass_points = 1;
+			FlagShipElementPtr->sys_loc = 1;
 		else
-			FlagShipElementPtr->mass_points =
+			FlagShipElementPtr->sys_loc =
 					(BYTE)(pSolarSysState->pBaseDesc->pPrevDesc
 					- pSolarSysState->PlanetDesc + 2);
 		FlagShipElementPtr->state_flags =
@@ -821,7 +819,7 @@ spawn_flag_ship (void)
 void
 DoMissions (void)
 {
-	HSTARSHIP hStarShip, hNextShip;
+	HSHIPFRAG hGroup, hNextGroup;
 
 	spawn_flag_ship ();
 
@@ -831,19 +829,18 @@ DoMissions (void)
 		EncounterRace = -1;
 	}
 
-	for (hStarShip = GetHeadLink (&GLOBAL (npc_built_ship_q));
-			hStarShip; hStarShip = hNextShip)
+	for (hGroup = GetHeadLink (&GLOBAL (ip_group_q));
+			hGroup; hGroup = hNextGroup)
 	{
-		SHIP_FRAGMENTPTR StarShipPtr;
+		IP_GROUP *GroupPtr;
 
-		StarShipPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-				&GLOBAL (npc_built_ship_q), hStarShip);
-		hNextShip = _GetSuccLink (StarShipPtr);
+		GroupPtr = LockIpGroup (&GLOBAL (ip_group_q), hGroup);
+		hNextGroup = _GetSuccLink (GroupPtr);
 
-		if (StarShipPtr->ShipInfo.crew_level)
-			spawn_ip_group (StarShipPtr);
+		if (GroupPtr->in_system)
+			spawn_ip_group (GroupPtr);
 
-		UnlockStarShip (&GLOBAL (npc_built_ship_q), hStarShip);
+		UnlockIpGroup (&GLOBAL (ip_group_q), hGroup);
 	}
 }
 
diff -ruNp src.orig/sc2code/ires_ind.h src/sc2code/ires_ind.h
--- src.orig/sc2code/ires_ind.h	2017-11-08 16:49:28 -0600
+++ src/sc2code/ires_ind.h	1969-12-31 18:00:00 -0600
@@ -1,54 +0,0 @@
-#define ARILOU_SHIP_INDEX 0x00600007L
-#define CHMMR_SHIP_INDEX 0x00800107L
-#define EARTHLING_SHIP_INDEX 0x00a00207L
-#define ORZ_SHIP_INDEX 0x00c00307L
-#define PKUNK_SHIP_INDEX 0x00e00407L
-#define SHOFIXTI_SHIP_INDEX 0x01000507L
-#define SPATHI_SHIP_INDEX 0x01200607L
-#define SUPOX_SHIP_INDEX 0x01400707L
-#define THRADD_SHIP_INDEX 0x01600807L
-#define UTWIG_SHIP_INDEX 0x01800907L
-#define VUX_SHIP_INDEX 0x01a00a07L
-#define YEHAT_SHIP_INDEX 0x01c00b07L
-#define MELNORME_SHIP_INDEX 0x01e00c07L
-#define DRUUGE_SHIP_INDEX 0x02000d07L
-#define ILWRATH_SHIP_INDEX 0x02200e07L
-#define MYCON_SHIP_INDEX 0x02400f07L
-#define SLYLANDRO_SHIP_INDEX 0x02601007L
-#define UMGAH_SHIP_INDEX 0x02801107L
-#define URQUAN_SHIP_INDEX 0x02a01207L
-#define ZOQFOTPIK_SHIP_INDEX 0x02c01307L
-#define SYREEN_SHIP_INDEX 0x02e01407L
-#define BLACKURQ_SHIP_INDEX 0x03001507L
-#define ANDROSYN_SHIP_INDEX 0x03201607L
-#define CHENJESU_SHIP_INDEX 0x03401707L
-#define MMRNMHRM_SHIP_INDEX 0x03601807L
-#define ARILOU_CONVERSATION 0x14a01907L
-#define CHMMR_CONVERSATION 0x14c01a07L
-#define COMMANDER_CONVERSATION 0x14e01b07L
-#define ORZ_CONVERSATION 0x15001c07L
-#define PKUNK_CONVERSATION 0x15201d07L
-#define SHOFIXTI_CONVERSATION 0x15401e07L
-#define SPATHI_CONVERSATION 0x15601f07L
-#define SUPOX_CONVERSATION 0x15802007L
-#define THRADD_CONVERSATION 0x15a02107L
-#define UTWIG_CONVERSATION 0x15c02207L
-#define VUX_CONVERSATION 0x15e02307L
-#define YEHAT_CONVERSATION 0x16002407L
-#define MELNORME_CONVERSATION 0x16202507L
-#define DRUUGE_CONVERSATION 0x16402607L
-#define ILWRATH_CONVERSATION 0x16602707L
-#define MYCON_CONVERSATION 0x16802807L
-#define SLYLANDRO_CONVERSATION 0x16a02907L
-#define UMGAH_CONVERSATION 0x16c02a07L
-#define URQUAN_CONVERSATION 0x16e02b07L
-#define ZOQFOTPIK_CONVERSATION 0x17002c07L
-#define SYREEN_CONVERSATION 0x17202d07L
-#define BLACKURQ_CONVERSATION 0x17402e07L
-#define TALKING_PET_CONVERSATION 0x17602f07L
-#define SLYLANDRO_HOME_CONVERSATION 0x17803007L
-#define SIS_RES_INDEX 0x17c03107L
-#define SAMATRA_RES_INDEX 0x17e03207L
-#define PROBE_RES_INDEX 0x18003307L
-
-
diff -ruNp src.orig/sc2code/isndres.h src/sc2code/isndres.h
--- src.orig/sc2code/isndres.h	2017-11-08 16:49:28 -0600
+++ src/sc2code/isndres.h	2017-11-08 16:49:55 -0600
@@ -1,5 +1,7 @@
-#define MENU_SOUNDS 0x04000005L
-#define GAME_SOUNDS 0x04200105L
-#define LANDER_SOUNDS 0x05400205L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define GAME_SOUNDS "sounds.game"
+#define LANDER_SOUNDS "sounds.landsnds"
+#define MENU_SOUNDS "sounds.menu"
diff -ruNp src.orig/sc2code/istrtab.h src/sc2code/istrtab.h
--- src.orig/sc2code/istrtab.h	2017-11-08 16:49:28 -0600
+++ src/sc2code/istrtab.h	2017-11-08 16:49:55 -0600
@@ -1,104 +1,158 @@
-#define STARCON_COLOR_MAP 0x00200004L
-#define STARCON_GAME_STRINGS 0x03800104L
-#define HYPER_COLOR_TAB 0x04800204L
-#define ARISPACE_COLOR_TAB 0x04a00304L
-#define ORBPLAN_COLOR_MAP 0x05200404L
-#define OOLITE_COLOR_TAB 0x09000504L
-#define OOLITE_XLAT_TAB 0x09000604L
-#define YTTRIC_COLOR_TAB 0x09200704L
-#define YTTRIC_XLAT_TAB 0x09400804L
-#define QUASI_DEGENERATE_COLOR_TAB 0x09600904L
-#define QUASI_DEGENERATE_XLAT_TAB 0x09800a04L
-#define LANTHANIDE_COLOR_TAB 0x09a00b04L
-#define TREASURE_COLOR_TAB 0x09c00c04L
-#define UREA_COLOR_TAB 0x09e00d04L
-#define UREA_XLAT_TAB 0x0a000e04L
-#define METAL_COLOR_TAB 0x0a200f04L
-#define METAL_XLAT_TAB 0x0a201004L
-#define RADIOACTIVE_COLOR_TAB 0x0a401104L
-#define OPALESCENT_COLOR_TAB 0x0a601204L
-#define OPALESCENT_XLAT_TAB 0x0a801304L
-#define CYANIC_COLOR_TAB 0x0aa01404L
-#define ACID_COLOR_TAB 0x0ac01504L
-#define ALKALI_COLOR_TAB 0x0ae01604L
-#define HALIDE_COLOR_TAB 0x0b001704L
-#define GREEN_COLOR_TAB 0x0b201804L
-#define COPPER_COLOR_TAB 0x0b401904L
-#define CARBIDE_COLOR_TAB 0x0b601a04L
-#define ULTRAMARINE_COLOR_TAB 0x0b801b04L
-#define NOBLE_COLOR_TAB 0x0ba01c04L
-#define AZURE_COLOR_TAB 0x0bc01d04L
-#define CHONDRITE_COLOR_TAB 0x0be01e04L
-#define CHONDRITE_XLAT_TAB 0x0be01f04L
-#define PURPLE_COLOR_TAB 0x0c002004L
-#define SUPER_DENSE_COLOR_TAB 0x0c202104L
-#define PELLUCID_COLOR_TAB 0x0c402204L
-#define DUST_COLOR_TAB 0x0c602304L
-#define MAROON_COLOR_TAB 0x0c802404L
-#define CIMMERIAN_COLOR_TAB 0x0ca02504L
-#define INFRARED_COLOR_TAB 0x0cc02604L
-#define SELENIC_COLOR_TAB 0x0ce02704L
-#define AURIC_COLOR_TAB 0x0d002804L
-#define FLUORESCENT_COLOR_TAB 0x0d202904L
-#define ULTRAVIOLET_COLOR_TAB 0x0d402a04L
-#define PLUTONIC_COLOR_TAB 0x0d602b04L
-#define RAINBOW_COLOR_TAB 0x0d802c04L
-#define RAINBOW_XLAT_TAB 0x0d802d04L
-#define CRACKED_COLOR_TAB 0x0da02e04L
-#define CRACKED_XLAT_TAB 0x0da02f04L
-#define SAPPHIRE_COLOR_TAB 0x0dc03004L
-#define SAPPHIRE_XLAT_TAB 0x0de03104L
-#define ORGANIC_COLOR_TAB 0x0e003204L
-#define XENOLITHIC_COLOR_TAB 0x0e203304L
-#define REDUX_COLOR_TAB 0x0e403404L
-#define REDUX_XLAT_TAB 0x0e403504L
-#define PRIMORDIAL_COLOR_TAB 0x0e603604L
-#define EMERALD_COLOR_TAB 0x0e803704L
-#define CHLORINE_COLOR_TAB 0x0ea03804L
-#define CHLORINE_XLAT_TAB 0x0ec03904L
-#define MAGNETIC_COLOR_TAB 0x0ee03a04L
-#define WATER_COLOR_TAB 0x0f003b04L
-#define TELLURIC_COLOR_TAB 0x0f203c04L
-#define HYDROCARBON_COLOR_TAB 0x0f403d04L
-#define IODINE_COLOR_TAB 0x0f603e04L
-#define VINYLOGOUS_COLOR_TAB 0x0f803f04L
-#define RUBY_COLOR_TAB 0x0fa04004L
-#define MAGMA_COLOR_TAB 0x0fc04104L
-#define CRIMSON_COLOR_TAB 0x0fe04204L
-#define GAS_XLAT_TAB 0x10004304L
-#define BLU_GAS_COLOR_TAB 0x10204404L
-#define CYA_GAS_COLOR_TAB 0x10404504L
-#define GRN_GAS_COLOR_TAB 0x10604604L
-#define GRY_GAS_COLOR_TAB 0x10804704L
-#define ORA_GAS_COLOR_TAB 0x10a04804L
-#define PUR_GAS_COLOR_TAB 0x10c04904L
-#define RED_GAS_COLOR_TAB 0x10e04a04L
-#define VIO_GAS_COLOR_TAB 0x11004b04L
-#define YEL_GAS_COLOR_TAB 0x11204c04L
-#define MOONBASE_STRTAB 0x11604d04L
-#define MAIDENS_STRTAB 0x11804e04L
-#define CHMMR_BASE_STRTAB 0x11a04f04L
-#define AQUA_STRTAB 0x11c05004L
-#define BURV_BCS_STRTAB 0x11e05104L
-#define TAALO_DEVICE_STRTAB 0x12005204L
-#define SUN_DEVICE_STRTAB 0x12205304L
-#define VAULT_STRTAB 0x12405404L
-#define WRECK_STRTAB 0x12605504L
-#define BOMB_STRTAB 0x12805604L
-#define BEAST_STRTAB 0x12a05704L
-#define EGG_CASE_STRTAB 0x12c05804L
-#define SPAPLUTO_STRTAB 0x12e05904L
-#define BURV_RUINS_STRTAB 0x13005a04L
-#define ANDROSYNTH_RUINS_STRTAB 0x13205b04L
-#define DRUUGE_RUINS_STRTAB 0x13405c04L
-#define PKUNK_RUINS_STRTAB 0x13605d04L
-#define RUINS_STRTAB 0x13a05e04L
-#define UMGAH_BCS_STRTAB 0x13c05f04L
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
-#define IPSUN_COLOR_MAP 0x05206004L
-#define HANGAR_COLOR_TAB 0x18a06104L
-#define INTROPRES_STRTAB 0x23c06204L
-#define FINALPRES_STRTAB 0x23e06304L
-#define CREDITS_STRTAB 0x24206404L
-#define JOYSTICK_ALPHA_STRTAB 0x24406504L
-#define SETUP_MENU_STRTAB 0x23a11f04L
+#define ACID_COLOR_TAB "planet.acid.colortable"
+#define ACID_XLAT_TAB "planet.acid.translatetable"
+#define ALKALI_COLOR_TAB "planet.alkali.colortable"
+#define ALKALI_XLAT_TAB "planet.alkali.translatetable"
+#define ANDROSYNTH_RUINS_STRTAB "text.andruins"
+#define AQUA_STRTAB "text.aquhelix"
+#define ARISPACE_COLOR_TAB "colortable.arispace"
+#define AURIC_COLOR_TAB "planet.auric.colortable"
+#define AURIC_XLAT_TAB "planet.auric.translatetable"
+#define AZURE_COLOR_TAB "planet.azure.colortable"
+#define AZURE_XLAT_TAB "planet.azure.translatetable"
+#define BEAST_STRTAB "text.vuxbeast"
+#define BLU_GAS_COLOR_TAB "planet.bluegas.colortable"
+#define BLU_GAS_XLAT_TAB "planet.bluegas.translatetable"
+#define BOMB_STRTAB "text.utwbomb"
+#define BURV_BCS_STRTAB "text.drutrans"
+#define BURV_RUINS_STRTAB "text.burruins"
+#define CARBIDE_COLOR_TAB "planet.carbide.colortable"
+#define CARBIDE_XLAT_TAB "planet.carbide.translatetable"
+#define CHLORINE_COLOR_TAB "planet.chlorine.colortable"
+#define CHLORINE_XLAT_TAB "planet.chlorine.translatetable"
+#define CHMMR_BASE_STRTAB "text.chmmrbas"
+#define CHONDRITE_COLOR_TAB "planet.chondrite.colortable"
+#define CHONDRITE_XLAT_TAB "planet.chondrite.translatetable"
+#define CIMMERIAN_COLOR_TAB "planet.cimmerian.colortable"
+#define CIMMERIAN_XLAT_TAB "planet.cimmerian.translatetable"
+#define COPPER_COLOR_TAB "planet.copper.colortable"
+#define COPPER_XLAT_TAB "planet.copper.translatetable"
+#define CREDITS_STRTAB "credits.credits"
+#define CRIMSON_COLOR_TAB "planet.crimson.colortable"
+#define CRIMSON_XLAT_TAB "planet.crimson.translatetable"
+#define CYANIC_COLOR_TAB "planet.cyanic.colortable"
+#define CYANIC_XLAT_TAB "planet.cyanic.translatetable"
+#define CYA_GAS_COLOR_TAB "planet.cyangas.colortable"
+#define CYA_GAS_XLAT_TAB "planet.cyangas.translatetable"
+#define DRUUGE_RUINS_STRTAB "text.sphere"
+#define DUST_COLOR_TAB "planet.dust.colortable"
+#define DUST_XLAT_TAB "planet.dust.translatetable"
+#define EGG_CASE_STRTAB "text.eggcase"
+#define EMERALD_COLOR_TAB "planet.emerald.colortable"
+#define EMERALD_XLAT_TAB "planet.emerald.translatetable"
+#define FINALPRES_STRTAB "slides.ending"
+#define FLUORESCENT_COLOR_TAB "planet.fluorescent.colortable"
+#define FLUORESCENT_XLAT_TAB "planet.fluorescent.translatetable"
+#define GREEN_COLOR_TAB "planet.green.colortable"
+#define GREEN_XLAT_TAB "planet.green.translatetable"
+#define GRN_GAS_COLOR_TAB "planet.greengas.colortable"
+#define GRN_GAS_XLAT_TAB "planet.greengas.translatetable"
+#define GRY_GAS_COLOR_TAB "planet.greygas.colortable"
+#define GRY_GAS_XLAT_TAB "planet.greygas.translatetable"
+#define HALIDE_COLOR_TAB "planet.halide.colortable"
+#define HALIDE_XLAT_TAB "planet.halide.translatetable"
+#define HANGAR_COLOR_TAB "colortable.hangar"
+#define HYDROCARBON_COLOR_TAB "planet.hydrocarbon.colortable"
+#define HYDROCARBON_XLAT_TAB "planet.hydrocarbon.translatetable"
+#define HYPER_COLOR_TAB "colortable.hyperpal"
+#define INFRARED_COLOR_TAB "planet.infrared.colortable"
+#define INFRARED_XLAT_TAB "planet.infrared.translatetable"
+#define INTROPRES_STRTAB "slides.intro"
+#define IODINE_COLOR_TAB "planet.iodine.colortable"
+#define IODINE_XLAT_TAB "planet.iodine.translatetable"
+#define IPSUN_COLOR_MAP "colortable.ip_sun"
+#define JOYSTICK_ALPHA_STRTAB "text.joyalpha"
+#define LANTHANIDE_COLOR_TAB "planet.lanthanide.colortable"
+#define LANTHANIDE_XLAT_TAB "planet.lanthanide.translatetable"
+#define MAGMA_COLOR_TAB "planet.magma.colortable"
+#define MAGMA_XLAT_TAB "planet.magma.translatetable"
+#define MAGNETIC_COLOR_TAB "planet.magnetic.colortable"
+#define MAGNETIC_XLAT_TAB "planet.magnetic.translatetable"
+#define MAIDENS_STRTAB "text.maidens"
+#define MAROON_COLOR_TAB "planet.maroon.colortable"
+#define MAROON_XLAT_TAB "planet.maroon.translatetable"
+#define METAL_COLOR_TAB "planet.metal.colortable"
+#define METAL_XLAT_TAB "planet.metal.translatetable"
+#define MOONBASE_STRTAB "text.moonbase"
+#define MOTHER_ARK_STRTAB "text.motherark"
+#define NEGLECTED_BASE_STRTAB "text.neglectedbase"
+#define NOBLE_COLOR_TAB "planet.noble.colortable"
+#define NOBLE_XLAT_TAB "planet.noble.translatetable"
+#define OOLITE_COLOR_TAB "planet.oolite.colortable"
+#define OOLITE_XLAT_TAB "planet.oolite.translatetable"
+#define OPALESCENT_COLOR_TAB "planet.opalescent.colortable"
+#define OPALESCENT_XLAT_TAB "planet.opalescent.translatetable"
+#define ORA_GAS_COLOR_TAB "planet.orangegas.colortable"
+#define ORA_GAS_XLAT_TAB "planet.orangegas.translatetable"
+#define ORBPLAN_COLOR_MAP "colortable.orbplan"
+#define ORGANIC_COLOR_TAB "planet.organic.colortable"
+#define ORGANIC_XLAT_TAB "planet.organic.translatetable"
+#define PELLUCID_COLOR_TAB "planet.pellucid.colortable"
+#define PELLUCID_XLAT_TAB "planet.pellucid.translatetable"
+#define PKUNK_RUINS_STRTAB "text.spindle"
+#define PLUTONIC_COLOR_TAB "planet.plutonic.colortable"
+#define PLUTONIC_XLAT_TAB "planet.plutonic.translatetable"
+#define PRECURSOR_BASE_STRTAB "text.precursorbase"
+#define PRIMORDIAL_COLOR_TAB "planet.primordial.colortable"
+#define PRIMORDIAL_XLAT_TAB "planet.primordial.translatetable"
+#define PURPLE_COLOR_TAB "planet.purple.colortable"
+#define PURPLE_XLAT_TAB "planet.purple.translatetable"
+#define PUR_GAS_COLOR_TAB "planet.purplegas.colortable"
+#define PUR_GAS_XLAT_TAB "planet.purplegas.translatetable"
+#define QUASI_DEGENERATE_COLOR_TAB "planet.quasidegenerate.colortable"
+#define QUASI_DEGENERATE_XLAT_TAB "planet.quasidegenerate.translatetable"
+#define RADIOACTIVE_COLOR_TAB "planet.radioactive.colortable"
+#define RADIOACTIVE_XLAT_TAB "planet.radioactive.translatetable"
+#define RAINBOW_COLOR_TAB "planet.rainbow.colortable"
+#define RAINBOW_XLAT_TAB "planet.rainbow.translatetable"
+#define REDUX_COLOR_TAB "planet.redux.colortable"
+#define REDUX_XLAT_TAB "planet.redux.translatetable"
+#define RED_GAS_COLOR_TAB "planet.redgas.colortable"
+#define RED_GAS_XLAT_TAB "planet.redgas.translatetable"
+#define RUBY_COLOR_TAB "planet.ruby.colortable"
+#define RUBY_XLAT_TAB "planet.ruby.translatetable"
+#define RUINS_STRTAB "text.ruins"
+#define SAPPHIRE_COLOR_TAB "planet.sapphire.colortable"
+#define SAPPHIRE_XLAT_TAB "planet.sapphire.translatetable"
+#define SELENIC_COLOR_TAB "planet.selenic.colortable"
+#define SELENIC_XLAT_TAB "planet.selenic.translatetable"
+#define SETUP_MENU_STRTAB "text.setupmenu"
+#define SHATTERED_COLOR_TAB "planet.shattered.colortable"
+#define SHATTERED_XLAT_TAB "planet.shattered.translatetable"
+#define SPAPLUTO_STRTAB "text.spapluto"
+#define STARCON_COLOR_MAP "colortable.scclrtab"
+#define STARCON_GAME_STRINGS "text.starcon"
+#define SUN_DEVICE_STRTAB "text.sundevic"
+#define SUPER_DENSE_COLOR_TAB "planet.superdense.colortable"
+#define SUPER_DENSE_XLAT_TAB "planet.superdense.translatetable"
+#define TAALO_DEVICE_STRTAB "text.taadevic"
+#define TELLURIC_COLOR_TAB "planet.telluric.colortable"
+#define TELLURIC_XLAT_TAB "planet.telluric.translatetable"
+#define TREASURE_COLOR_TAB "planet.treasure.colortable"
+#define TREASURE_XLAT_TAB "planet.treasure.translatetable"
+#define ULTRAMARINE_COLOR_TAB "planet.ultramarine.colortable"
+#define ULTRAMARINE_XLAT_TAB "planet.ultramarine.translatetable"
+#define ULTRAVIOLET_COLOR_TAB "planet.ultraviolet.colortable"
+#define ULTRAVIOLET_XLAT_TAB "planet.ultraviolet.translatetable"
+#define UMGAH_BCS_STRTAB "text.umgtrans"
+#define UREA_COLOR_TAB "planet.urea.colortable"
+#define UREA_XLAT_TAB "planet.urea.translatetable"
+#define URQUAN_BASE_STRTAB "text.urquanbase"
+#define VAULT_STRTAB "text.syrvault"
+#define VINYLOGOUS_COLOR_TAB "planet.vinylogous.colortable"
+#define VINYLOGOUS_XLAT_TAB "planet.vinylogous.translatetable"
+#define VIO_GAS_COLOR_TAB "planet.violetgas.colortable"
+#define VIO_GAS_XLAT_TAB "planet.violetgas.translatetable"
+#define WATER_COLOR_TAB "planet.water.colortable"
+#define WATER_XLAT_TAB "planet.water.translatetable"
+#define WRECK_STRTAB "text.urqwreck"
+#define XENOLITHIC_COLOR_TAB "planet.xenolithic.colortable"
+#define XENOLITHIC_XLAT_TAB "planet.xenolithic.translatetable"
+#define YEL_GAS_COLOR_TAB "planet.yellowgas.colortable"
+#define YEL_GAS_XLAT_TAB "planet.yellowgas.translatetable"
+#define YTTRIC_COLOR_TAB "planet.yttric.colortable"
+#define YTTRIC_XLAT_TAB "planet.yttric.translatetable"
+#define ZFPRUINS_STRTAB "text.zfpcolony"
diff -ruNp src.orig/sc2code/libs/callback/alarm.h src/sc2code/libs/callback/alarm.h
--- src.orig/sc2code/libs/callback/alarm.h	2017-11-08 16:49:28 -0600
+++ src/sc2code/libs/callback/alarm.h	2017-11-08 16:49:55 -0600
@@ -31,7 +31,7 @@ alarmTimeToMsUint32(AlarmTime time) {
 
 typedef struct Alarm Alarm;
 typedef void *AlarmCallbackArg;
-typedef void (*AlarmCallback)(AlarmCallbackArg *arg);
+typedef void (*AlarmCallback)(AlarmCallbackArg arg);
 
 struct Alarm {
 	size_t index;
diff -ruNp src.orig/sc2code/libs/cdp/cdpapi.c src/sc2code/libs/cdp/cdpapi.c
--- src.orig/sc2code/libs/cdp/cdpapi.c	2017-11-08 16:49:28 -0600
+++ src/sc2code/libs/cdp/cdpapi.c	2017-11-08 16:49:56 -0600
@@ -225,7 +225,7 @@ cdp_UninitApi (void)
 		{
 			itf->used = false;
 			if (itf->name)
-				HFree ((void*) itf->name);
+				HFree (itf->name);
 			itf->name = NULL;
 			itf->itfvtbl = NULL;
 			itf->module = NULL;
@@ -277,7 +277,7 @@ cdp_GetInterfaceReg (const char* name, c
 	cdp_ItfReg* itf;
 
 	for (itf = cdp_itfs; itf->used &&
-			(!itf->name || stricmp(itf->name, name) != 0 ||
+			(!itf->name || strcasecmp(itf->name, name) != 0 ||
 			 api_ver < itf->ver_from || api_ver > itf->ver_to);
 			itf++)
 		;
@@ -390,7 +390,7 @@ cdp_Host_RegisterItf (const char* name,
 
 	// check if interface already registered
 	for (itfreg = cdp_itfs; itfreg->used &&
-			(!itfreg->name || stricmp(itfreg->name, id_name) != 0 ||
+			(!itfreg->name || strcasecmp(itfreg->name, id_name) != 0 ||
 			 ver_from < itfreg->ver_from || ver_to > itfreg->ver_to);
 			++itfreg)
 	{
@@ -449,7 +449,7 @@ cdp_Host_UnregisterItf (cdp_ItfReg* itfr
 
 	if (!itfreg->builtin)
 	{
-		HFree ((void*) itfreg->name);
+		HFree (itfreg->name);
 	}
 	itfreg->module = NULL;
 	itfreg->name = NULL;
@@ -502,7 +502,7 @@ cdp_GetEventReg (const char* name)
 	cdp_EventReg* evt;
 
 	for (evt = cdp_evts; evt->used &&
-			(!evt->name || stricmp(evt->name, name) != 0);
+			(!evt->name || strcasecmp(evt->name, name) != 0);
 			evt++)
 		;
 	if (!evt->name)
@@ -626,7 +626,7 @@ cdp_Host_RegisterEvent (const char* name
 
 	// check if event already registered
 	for (evtreg = cdp_evts; evtreg->used &&
-			(!evtreg->name || stricmp(evtreg->name, id_name) != 0);
+			(!evtreg->name || strcasecmp(evtreg->name, id_name) != 0);
 			++evtreg)
 	{
 		// and pick up an empty slot (where available)
@@ -682,7 +682,7 @@ cdp_Host_UnregisterEvent (cdp_EventReg*
 
 	if (!evtreg->builtin)
 	{
-		HFree ((void*) evtreg->name);
+		HFree (evtreg->name);
 	}
 	evtreg->module = NULL;
 	evtreg->name = NULL;
diff -ruNp src.orig/sc2code/libs/compiler.h src/sc2code/libs/compiler.h
--- src.orig/sc2code/libs/compiler.h	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/compiler.h	2017-11-08 16:49:56 -0600
@@ -22,40 +22,24 @@
 #include "types.h"
 
 typedef uint8             BYTE;
-typedef BYTE            *PBYTE;
 typedef uint8             UBYTE;
-typedef UBYTE           *PUBYTE;
 typedef sint8             SBYTE;
-typedef SBYTE           *PSBYTE;
 typedef uint16            UWORD;
-typedef UWORD           *PUWORD;
 typedef sint16            SWORD;
-typedef SWORD           *PSWORD;
 typedef uint32            DWORD;
-typedef DWORD           *PDWORD;
 typedef sint32           SDWORD;
-typedef SDWORD          *PSDWORD;
-
-typedef SBYTE           *PSTR;
-
-typedef void            *PVOID;
-typedef const void     *PCVOID;
 
 typedef UWORD             COUNT;
-typedef COUNT           *PCOUNT;
 typedef SWORD              SIZE;
-typedef SIZE             *PSIZE;
 
 typedef unsigned char   UNICODE;
 
-#define NULL_PTR 0L
 
 typedef enum
 {
 	FALSE = 0,
 	TRUE
 } BOOLEAN;
-typedef BOOLEAN *PBOOLEAN;
 
 typedef void     (*PVOIDFUNC) (void);
 typedef BOOLEAN  (*PBOOLFUNC) (void);
@@ -91,6 +75,14 @@ typedef DWORD    (*PDWORDFUNC) (void);
 			// Leaving it alone for now.
 #	define _PACKED
 #	define _ALIGNED_ON(bytes)
+#elif defined(__ARMCC__)
+#	define _PACKED __attribute__((packed))
+#	define _ALIGNED_ANY __attribute__((aligned))
+#	define _ALIGNED_ON(bytes) __attribute__((aligned(bytes)))
+#elif defined(__WINSCW__)
+#	define _PACKED
+#	define _ALIGNED_ANY
+#	define _ALIGNED_ON(bytes)
 #endif
 
 #endif /* _COMPILER_H */
diff -ruNp src.orig/sc2code/libs/declib.h src/sc2code/libs/declib.h
--- src.orig/sc2code/libs/declib.h	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/declib.h	2017-11-08 16:49:56 -0600
@@ -20,7 +20,7 @@
 #define _DECLIB_H
 
 #include "libs/compiler.h"
-#define DECODE_REF PVOID
+typedef struct _LZHCODE_DESC* DECODE_REF;
 
 enum
 {
@@ -36,19 +36,13 @@ enum
 };
 typedef BYTE STREAM_MODE;
 
-#endif /* _DECLIB_H */
-
-#ifndef _DEC_PROTOS
-#define _DEC_PROTOS
-
-extern DECODE_REF copen (PVOID InStream, STREAM_TYPE SType, STREAM_MODE
-		SMode);
+extern DECODE_REF copen (void *InStream, STREAM_TYPE SType,
+		STREAM_MODE SMode);
 extern DWORD cclose (DECODE_REF DecodeRef);
 extern void cfilelength (DECODE_REF DecodeRef, DWORD *pfilelen);
-extern COUNT cread (PVOID pStr, COUNT size, COUNT count, DECODE_REF
-		DecodeRef);
-extern COUNT cwrite (PVOID pStr, COUNT size, COUNT count, DECODE_REF
-		DecodeRef);
-
-#endif /* _DEC_PROTOS */
+extern COUNT cread (void *pStr, COUNT size, COUNT count,
+		DECODE_REF DecodeRef);
+extern COUNT cwrite (const void *pStr, COUNT size, COUNT count,
+		DECODE_REF DecodeRef);
 
+#endif /* _DECLIB_H */
diff -ruNp src.orig/sc2code/libs/decomp/lzdecode.c src/sc2code/libs/decomp/lzdecode.c
--- src.orig/sc2code/libs/decomp/lzdecode.c	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/decomp/lzdecode.c	2017-11-08 16:49:56 -0600
@@ -29,10 +29,11 @@
 #include <string.h>
 #include <ctype.h>
 #include "libs/decomp/lzh.h"
+#include "reslib.h"
 
 PLZHCODE_DESC _lpCurCodeDesc;
 STREAM_TYPE _StreamType;
-PBYTE _Stream;
+BYTE* _Stream;
 UWORD _workbuf;
 BYTE _workbuflen;
 
@@ -101,9 +102,8 @@ StartHuff (void)
 }
 
 DECODE_REF
-copen (PVOID InStream, STREAM_TYPE SType, STREAM_MODE SMode)
+copen (void *InStream, STREAM_TYPE SType, STREAM_MODE SMode)
 {
-	MEM_HANDLE h;
 	DWORD StreamLength;
 
 	_StreamType = SType;
@@ -132,23 +132,20 @@ copen (PVOID InStream, STREAM_TYPE SType
 		StreamLength = MAKE_DWORD (loword, hiword);
 	}
 
-	h = 0;
 	if (StreamLength == 0xFFFFFFFF
-			|| (h = AllocCodeDesc ()) == 0
-			|| (_lpCurCodeDesc = LockCodeDesc (h)) == 0)
+			|| (_lpCurCodeDesc = AllocCodeDesc ()) == NULL)
 	{
-		_lpCurCodeDesc = 0;
-		FreeCodeDesc (h);
+		FreeCodeDesc (_lpCurCodeDesc);
+		_lpCurCodeDesc = NULL;
 	}
 	else
 	{
-		_lpCurCodeDesc->fh = h;
 		_lpCurCodeDesc->Stream = _Stream;
 		_lpCurCodeDesc->StreamType = _StreamType;
 		_lpCurCodeDesc->StreamMode = SMode;
 		_lpCurCodeDesc->StreamLength = StreamLength;
 		_lpCurCodeDesc->buf_index = N - F;
-		memset ((PBYTE)&_lpCurCodeDesc->text_buf[0], ' ', N - F);
+		memset (&_lpCurCodeDesc->text_buf[0], ' ', N - F);
 
 		StartHuff ();
 	}
@@ -168,8 +165,8 @@ cclose (PLZHCODE_DESC lpCodeDesc)
 			(*_lpCurCodeDesc->CleanupFunc) ();
 
 		StreamIndex = lpCodeDesc->StreamIndex;
-		UnlockCodeDesc (lpCodeDesc->fh);
-		FreeCodeDesc (lpCodeDesc->fh);
+		FreeCodeDesc (lpCodeDesc);
+		_lpCurCodeDesc = NULL;
 
 		return (StreamIndex);
 	}
@@ -292,11 +289,10 @@ static const BYTE d_len[256] =
 }
 
 COUNT
-cread (PVOID buf, COUNT size, COUNT count, PLZHCODE_DESC
-		lpCodeDesc)
+cread (void *buf, COUNT size, COUNT count, PLZHCODE_DESC lpCodeDesc)
 {
 	COUNT r, j, i;
-	PBYTE lpStr;
+	BYTE *lpStr;
 
 	if ((_lpCurCodeDesc = lpCodeDesc) == 0)
 		return (0);
@@ -314,7 +310,7 @@ cread (PVOID buf, COUNT size, COUNT coun
 	if (size == 0)
 		return (0);
 
-	lpStr = (PBYTE)buf;
+	lpStr = (BYTE*)buf;
 	_StreamType = lpCodeDesc->StreamType;
 
 	_Stream = lpCodeDesc->Stream;
diff -ruNp src.orig/sc2code/libs/decomp/lzencode.c src/sc2code/libs/decomp/lzencode.c
--- src.orig/sc2code/libs/decomp/lzencode.c	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/decomp/lzencode.c	2017-11-08 16:49:56 -0600
@@ -26,37 +26,34 @@
 
 #include <stdio.h>
 #include "lzh.h"
+#include "reslib.h"
 
 static UWORD match_position, match_length;
-static PSWORD lson, rson, dad;
+static SWORD *lson;
+static SWORD *rson;
+static SWORD *dad;
+static SWORD *encode_arrays;
 
 #define AllocEncodeArrays() \
-		mem_allocate ( \
-		(MEM_SIZE)(((N + 1) + (N + 257) + (N + 1)) \
-		* sizeof (lson[0]) + sizeof (MEM_HANDLE)), \
-		MEM_ZEROINIT, DEFAULT_MEM_PRIORITY, MEM_SIMPLE \
-		)
-#define LockCodeArrays (PSWORD)mem_lock
-#define UnlockCodeArrays mem_unlock
-#define FreeCodeArrays mem_release
+		HCalloc ( \
+		(((N + 1) + (N + 257) + (N + 1)) \
+		* sizeof (lson[0])))
+#define FreeCodeArrays HFree
 
 static BOOLEAN
 InitTree (void)
 {
-	MEM_HANDLE h;
-
-	if ((h = AllocEncodeArrays ()) == 0
-			|| (lson = LockCodeArrays (h)) == 0)
+	if ((encode_arrays = AllocEncodeArrays ()) == NULL)
 	{
-		FreeCodeArrays (h);
+		FreeCodeArrays (encode_arrays);
+		encode_arrays = NULL;
 		return (FALSE);
 	}
 	else
 	{
 		SWORD i;
 
-		*(MEM_HANDLE *)lson = h;
-		lson = (PSWORD)((PBYTE)lson + sizeof (h));
+		lson = encode_arrays;
 		rson = lson + (N + 1);
 		dad = rson + (N + 257);
 
@@ -73,7 +70,7 @@ static void
 InsertNode (SWORD r)
 {
 	SWORD p, cmp;
-	PBYTE lpBuf;
+	BYTE *lpBuf;
 
 	cmp = 1;
 	lpBuf = _lpCurCodeDesc->text_buf;
@@ -276,18 +273,17 @@ EncodePosition (UWORD c)
 static void
 UninitTree (void)
 {
-	MEM_HANDLE h;
-
 	if (_workbuflen)
 	{
 		OutChar ((BYTE)(_workbuf >> 8));
 		++_lpCurCodeDesc->StreamIndex;
 	}
 
-	lson = (PSWORD)((PBYTE)lson - sizeof (h));
-	h = *(MEM_HANDLE *)lson;
-	UnlockCodeArrays (h);
-	FreeCodeArrays (h);
+	FreeCodeArrays (encode_arrays);
+	encode_arrays = NULL;
+	lson = NULL;
+	rson = NULL;
+	dad = NULL;
 }
 
 static void
@@ -334,8 +330,7 @@ _encode_cleanup (void)
 					SeekResFile ((uio_Stream *)_Stream,
 							-(int)_lpCurCodeDesc->StreamIndex, SEEK_CUR);
 				else /* _lpCurCodeDesc->StreamType == MEMORY_STREAM */
-					_Stream = (PBYTE)((BYTE *)_Stream
-							- _lpCurCodeDesc->StreamIndex);
+					_Stream = (BYTE*)_Stream - _lpCurCodeDesc->StreamIndex;
 
 				loword = LOWORD (_lpCurCodeDesc->StreamLength);
 				lobyte = LOBYTE (loword);
@@ -371,11 +366,11 @@ _encode_cleanup (void)
 }
 
 COUNT
-cwrite (PVOID buf, COUNT size, COUNT count, PLZHCODE_DESC
-		lpCodeDesc)
+cwrite (const void *buf, COUNT size, COUNT count, PLZHCODE_DESC lpCodeDesc)
 {
 	UWORD r, s, last_match_length;
-	PBYTE lpBuf, lpStr;
+	BYTE *lpBuf;
+	BYTE *lpStr;
 
 	if ((_lpCurCodeDesc = lpCodeDesc) == 0
 			|| (size *= count) == 0)
@@ -385,7 +380,7 @@ cwrite (PVOID buf, COUNT size, COUNT cou
 	_Stream = lpCodeDesc->Stream;
 	_workbuf = lpCodeDesc->workbuf;
 	_workbuflen = lpCodeDesc->workbuflen;
-	lpStr = (PBYTE)buf;
+	lpStr = (BYTE*)buf;
 	lpBuf = lpCodeDesc->text_buf;
 
 	r = lpCodeDesc->buf_index;
diff -ruNp src.orig/sc2code/libs/decomp/lzh.h src/sc2code/libs/decomp/lzh.h
--- src.orig/sc2code/libs/decomp/lzh.h	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/decomp/lzh.h	2017-11-08 16:49:56 -0600
@@ -19,9 +19,8 @@
 #ifndef _LZH_H
 #define _LZH_H
 
-#include "reslib.h"
-#define _DEC_PROTOS
 #include "declib.h"
+#include "misc.h"
 
 /* LZSS Parameters */
 
@@ -40,10 +39,8 @@
 #define MAX_FREQ 0x8000
 										/* update when cumulative frequency */
 
-typedef struct
+struct _LZHCODE_DESC
 {
-	MEM_HANDLE fh;
-
 	COUNT buf_index, restart_index, bytes_left;
 	BYTE text_buf[N + F - 1];
 		/* reconstruct freq tree */
@@ -60,12 +57,14 @@ typedef struct
 
 	STREAM_TYPE StreamType;
 
-	PVOID Stream;
+	void *Stream;
 	DWORD StreamIndex, StreamLength;
 
 	STREAM_MODE StreamMode;
 	PVOIDFUNC CleanupFunc;
-} LZHCODE_DESC;
+};
+
+typedef struct _LZHCODE_DESC LZHCODE_DESC;
 typedef LZHCODE_DESC *PLZHCODE_DESC;
 
 #define InChar() (_StreamType == FILE_STREAM ? \
@@ -76,24 +75,15 @@ typedef LZHCODE_DESC *PLZHCODE_DESC;
 								(*_Stream++ = (BYTE)(c)))
 
 
-#define AllocCodeDesc() \
-		mem_allocate ((MEM_SIZE)sizeof (LZHCODE_DESC), \
-		MEM_ZEROINIT, DEFAULT_MEM_PRIORITY, MEM_SIMPLE)
-#define LockCodeDesc (PLZHCODE_DESC)mem_lock
-#define UnlockCodeDesc mem_unlock
-#define FreeCodeDesc mem_release
+#define AllocCodeDesc() HCalloc (sizeof (LZHCODE_DESC))
+#define FreeCodeDesc HFree
 
 extern void _update (COUNT c);
 extern void StartHuff (void);
 
-#undef DECODE_REF
-#define DECODE_REF PLZHCODE_DESC
-#undef _DEC_PROTOS
-#include "declib.h"
-
 extern PLZHCODE_DESC  _lpCurCodeDesc;
 extern STREAM_TYPE    _StreamType;
-extern PBYTE          _Stream;
+extern BYTE*          _Stream;
 extern UWORD          _workbuf;
 extern BYTE           _workbuflen;
 
diff -ruNp src.orig/sc2code/libs/file/Makeinfo src/sc2code/libs/file/Makeinfo
--- src.orig/sc2code/libs/file/Makeinfo	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/file/Makeinfo	2017-11-08 16:49:56 -0600
@@ -1 +1 @@
-uqm_CFILES="dirs.c files.c temp.c"
+uqm_CFILES="dirs.c files.c"
diff -ruNp src.orig/sc2code/libs/file/dirs.c src/sc2code/libs/file/dirs.c
--- src.orig/sc2code/libs/file/dirs.c	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/file/dirs.c	2017-11-08 16:49:56 -0600
@@ -29,11 +29,16 @@
 #include "misc.h"
 #include "libs/log.h"
 
+#ifdef HAVE_DRIVE_LETTERS
+#	include <ctype.h>
+			// For tolower()
+#endif  /* HAVE_DRIVE_LETTERS */
 #ifdef WIN32
 #	include <direct.h>
-#	include <ctype.h>
+			// For _getdcwd()
 #else
 #	include <pwd.h>
+			// For getpwuid()
 #endif
 
 /* Try to find a suitable value for %APPDATA% if it isn't defined on
@@ -67,12 +72,12 @@ mkdirhier (const char *path)
 	struct stat statbuf;
 	
 	len = strlen (path);
-	buf = alloca (len + 2);  // one extra for possibly added '/'
+	buf = HMalloc (len + 2);  // one extra for possibly added '/'
 
 	ptr = buf;
 	pathstart = path;
 
-#ifdef WIN32
+#ifdef HAVE_DRIVE_LETTERS
 	if (isDriveLetter(pathstart[0]) && pathstart[1] == ':')
 	{
 		// Driveletter + semicolon on Windows.
@@ -85,10 +90,15 @@ mkdirhier (const char *path)
 		if (stat (buf, &statbuf) == -1)
 		{
 			log_add (log_Error, "Can't stat \"%s\": %s", buf, strerror (errno));
-			return -1;
+			goto err;
 		}
-	} else if (pathstart[0] == '\\' && pathstart[1] == '\\') {
-		// Windows UNC path. (\\server\share\...)
+	}
+	else
+#endif  /* HAVE_DRIVE_LETTERS */
+#ifdef HAVE_UNC_PATHS
+	if (pathstart[0] == '\\' && pathstart[1] == '\\')
+	{
+		// Universal Naming Convention path. (\\server\share\...)
 		// Copy the server part as is; don't try to create directories for
 		// it, or stat it. Don't create a dir for the share either.
 		*(ptr++) = *(pathstart++);
@@ -101,7 +111,7 @@ mkdirhier (const char *path)
 		if (*pathstart == '\0')
 		{
 			log_add (log_Error, "Incomplete UNC path \"%s\"", pathstart);
-			return -1;
+			goto err;
 		}
 
 		// Copy the path seperator.
@@ -116,10 +126,15 @@ mkdirhier (const char *path)
 		if (stat (buf, &statbuf) == -1)
 		{
 			log_add (log_Error, "Can't stat \"%s\": %s", buf, strerror (errno));
-			return -1;
+			goto err;
 		}
 	}
-#endif
+#else
+	{
+		// Making sure that there is an 'else' case if HAVE_DRIVE_LETTERS is
+		// defined.
+	}
+#endif  /* HAVE_UNC_PATHS */
 
 	if (*pathstart == '/')
 		*(ptr++) = *(pathstart++);
@@ -141,13 +156,23 @@ mkdirhier (const char *path)
 		
 		if (stat (buf, &statbuf) == -1)
 		{
-			if (errno != ENOENT)
+			if (errno == ENOENT)
+				break;
+#ifdef __SYMBIAN32__
+			// XXX: HACK: If we don't have access to a directory, we can
+			// still have access to the underlying entries. We don't
+			// actually know whether the entry is a directory, but I know of
+			// no way to find out. We just pretend that it is; if we were
+			// wrong, an error will occur when we try to do something with
+			// the directory. That /should/ not be a problem, as any such
+			// action should have its own error checking.
+			if (errno != EACCES)
+#endif			
 			{
 				log_add (log_Error, "Can't stat \"%s\": %s", buf,
 						strerror (errno));
-				return -1;
+				goto err;
 			}
-			break;
 		}
 		
 		if (*pathend == '\0')
@@ -171,7 +196,7 @@ mkdirhier (const char *path)
 		{
 			log_add (log_Error, "Error: Can't create %s: %s", buf,
 					strerror (errno));
-			return -1;
+			goto err;
 		}
 
 		if (*pathend == '\0')
@@ -196,6 +221,14 @@ mkdirhier (const char *path)
 		*ptr = '\0';
 	}
 	return 0;
+
+err:
+	{
+		int savedErrno = errno;
+		HFree (buf);
+		errno = savedErrno;
+	}
+	return -1;
 }
 
 // Get the user's home dir
@@ -243,14 +276,15 @@ int
 expandPath (char *dest, size_t len, const char *src, int what)
 {
 	char *destptr, *destend;
-	char *buf, *bufptr, *bufend;
+	char *buf = NULL;
+	char *bufptr, *bufend;
 	const char *srcend;
 
 #define CHECKLEN(bufname, n) \
 		if (bufname##ptr + (n) >= bufname##end) \
 		{ \
 			errno = ENAMETOOLONG; \
-			return -1; \
+			goto err; \
 		} \
 		else \
 			(void) 0
@@ -260,7 +294,7 @@ expandPath (char *dest, size_t len, cons
 
 	if (what & EP_ENVVARS)
 	{
-		buf = alloca (len);
+		buf = HMalloc (len);
 		bufptr = buf;
 		bufend = buf + len;
 		while (*src != '\0')
@@ -281,7 +315,7 @@ expandPath (char *dest, size_t len, cons
 					if (end == NULL)
 					{
 						errno = EINVAL;
-						return -1;
+						goto err;
 					}
 					
 					envNameLen = end - src;
@@ -366,7 +400,7 @@ expandPath (char *dest, size_t len, cons
 						if (end == NULL)
 						{
 							errno = EINVAL;
-							return -1;
+							goto err;
 						}
 						envNameLen = end - src;
 						end++;  // Skip the '}'
@@ -423,14 +457,14 @@ expandPath (char *dest, size_t len, cons
 			if (src[1] != '/')
 			{
 				errno = EINVAL;
-				return -1;
+				goto err;
 			}
 
 			home = getHomeDir ();
 			if (home == NULL)
 			{
 				errno = ENOENT;
-				return -1;
+				goto err;
 			}
 			homelen = strlen (home);
 		
@@ -441,7 +475,7 @@ expandPath (char *dest, size_t len, cons
 				if (destptr == NULL)
 				{
 					// errno is set
-					return -1;
+					goto err;
 				}
 				home += skip;
 				what &= ~EP_ABSOLUTE;
@@ -464,7 +498,7 @@ expandPath (char *dest, size_t len, cons
 		if (destptr == NULL)
 		{
 			// errno is set
-			return -1;
+			goto err;
 		}
 		src += skip;
 	}
@@ -478,9 +512,9 @@ expandPath (char *dest, size_t len, cons
 	{
 		/* Replacing backslashes in path by slashes. */
 		destptr = dest;
-#ifdef WIN32
+#ifdef HAVE_UNC_PATHS
 		{
-			// A Windows UNC path should always start with two backslashes
+			// A UNC path should always start with two backslashes
 			// and have a backslash in between the server and share part.
 			size_t skip = skipUNCServerShare (destptr);
 			if (skip != 0)
@@ -491,7 +525,7 @@ expandPath (char *dest, size_t len, cons
 				destptr += skip;
 			}
 		}
-#endif
+#endif  /* HAVE_UNC_PATHS */
 		while (*destptr != '\0')
 		{
 			if (*destptr == '\\')
@@ -512,17 +546,24 @@ expandPath (char *dest, size_t len, cons
 		char *endPart;
 
 		pathStart = dest;
-#ifdef WIN32
+#ifdef HAVE_DRIVE_LETTERS
 		if (isDriveLetter(pathStart[0]) && (pathStart[1] == ':'))
 		{
 			pathStart += 2;
 		}
 		else
+#endif  /* HAVE_DRIVE_LETTERS */
+#ifdef HAVE_UNC_PATHS
 		{
-			// Test for a UNC path.
+			// Test for a Universal Naming Convention path.
 			pathStart += skipUNCServerShare(pathStart);
 		}
-#endif
+#else
+		{
+			// Making sure that there is an 'else' case if HAVE_DRIVE_LETTERS is
+			// defined.
+		}
+#endif  /* HAVE_UNC_PATHS */
 		if (pathStart[0] == '/')
 			pathStart++;
 
@@ -551,7 +592,7 @@ expandPath (char *dest, size_t len, cons
 					{
 						// We ran out of path components to back out of.
 						errno = EINVAL;
-						return -1;
+						goto err;
 					}
 					destptr = pathStart;
 				}
@@ -600,9 +641,19 @@ expandPath (char *dest, size_t len, cons
 	}
 	
 	return 0;
+
+err:
+	if (buf != NULL) {
+		int savedErrno = errno;
+		HFree (buf);
+		errno = savedErrno;
+	}
+	return -1;
 }
 
-#ifdef WIN32
+#if defined(HAVE_DRIVE_LETTERS) && defined(HAVE_CWD_PER_DRIVE)
+		// This code is only needed if we have a current working directory
+		// per drive.
 // letter is 0 based: 0 = A, 1 = B, ...
 bool
 driveLetterExists(int letter)
@@ -613,7 +664,7 @@ driveLetterExists(int letter)
 
 	return ((drives >> letter) & 1) != 0;
 }
-#endif
+#endif  /* if defined(HAVE_DRIVE_LETTERS) && defined(HAVE_CWD_PER_DRIVE) */
 
 // helper for expandPath, expanding an absolute path
 // returns a pointer to the end of the filled in part of dest.
@@ -631,7 +682,7 @@ expandPathAbsolute (char *dest, size_t d
 	}
 
 	orgSrc = src;
-#ifdef WIN32
+#ifdef HAVE_DRIVE_LETTERS
 	if (isDriveLetter(src[0]) && (src[1] == ':'))
 	{
 		int letter;
@@ -646,6 +697,13 @@ expandPathAbsolute (char *dest, size_t d
 		// Path is of the form "d:path", without a (back)slash after the
 		// semicolon.
 
+#ifdef REJECT_DRIVE_PATH_WITHOUT_SLASH
+		// We reject paths of the form "d:foo/bar".
+		errno = EINVAL;
+		return NULL;
+#elif defined(HAVE_CWD_PER_DRIVE)
+		// Paths of the form "d:foo/bar" are treated as "foo/bar" relative
+		// to the working directory of d:.
 		letter = tolower(src[0]) - 'a';
 
 		// _getdcwd() should only be called on drives that exist.
@@ -667,9 +725,22 @@ expandPathAbsolute (char *dest, size_t d
 		}
 
 		src += 2;
+#else  /* if !defined(HAVE_CWD_PER_DRIVE) */
+		// We treat paths of the form "d:foo/bar" as "d:/foo/bar".
+		if (destLen < 3) {
+			errno = ERANGE;
+			return NULL;
+		}
+		dest[0] = src[0];
+		dest[1] = ':';
+		dest[2] = '/';
+		*skipSrc = 2;
+		dest += 3;
+		return dest;
+#endif  /* HAVE_CWD_PER_DRIVE */
 	}
 	else
-#endif
+#endif  /* HAVE_DRIVE_LETTERS */
 	{
 		// Relative dir
 		if (getcwd (dest, destLen) == NULL)
@@ -692,9 +763,9 @@ expandPathAbsolute (char *dest, size_t d
 		destLen -= tempLen;
 	}
 	if (dest[-1] != '/'
-#ifdef WIN32
+#ifdef BACKSLASH_IS_PATH_SEPARATOR
 			&& dest[-1] != '\\'
-#endif
+#endif  /* BACKSLASH_IS_PATH_SEPARATOR */
 			)
 	{
 		// Need to add a slash.
@@ -721,7 +792,7 @@ strrchr2(const char *start, int c, const
 	}
 }
 
-#ifdef WIN32
+#ifdef HAVE_UNC_PATHS
 // returns 0 if the path is not a valid UNC path.
 // Does not skip trailing slashes.
 size_t
@@ -749,6 +820,6 @@ skipUNCServerShare(const char *inPath) {
 	
 	return (size_t) (path - inPath);
 }
-#endif
+#endif  /* HAVE_UNC_PATHS */
 
 
diff -ruNp src.orig/sc2code/libs/file/temp.c src/sc2code/libs/file/temp.c
--- src.orig/sc2code/libs/file/temp.c	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/file/temp.c	2017-11-08 16:49:56 -0600
@@ -97,7 +97,10 @@ getTempDir (char *buf, size_t buflen) {
 	
 	if (tryTempDir (buf, buflen, getenv("TMP")) &&
 			tryTempDir (buf, buflen, getenv("TEMP")) &&
+#if !defined(WIN32) || defined (__CYGWIN__)
 			tryTempDir (buf, buflen, "/tmp/") &&
+			tryTempDir (buf, buflen, "/var/tmp/") &&
+#endif
 			tryTempDir (buf, buflen, getcwd (cwd, sizeof cwd)))
 	{
 		log_add (log_Fatal, "Fatal Error: Cannot find a suitable location "
diff -ruNp src.orig/sc2code/libs/file.h src/sc2code/libs/file.h
--- src.orig/sc2code/libs/file.h	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/file.h	2017-11-08 16:49:56 -0600
@@ -20,16 +20,18 @@
 #define _FILE_H
 
 #include "port.h"
+#include "libs/uio.h"
 
 // for bool
 #include "types.h"
 
+#if 0
 // from temp.h
-#include "libs/uio.h"
 void initTempDir (void);
 void unInitTempDir (void);
 char *tempFilePath (const char *filename);
 extern uio_DirHandle *tempDir;
+#endif
 
 
 // from dirs.h
@@ -70,16 +72,16 @@ int copyFile (uio_DirHandle *srcDir, con
 		uio_DirHandle *dstDir, const char *newName);
 bool fileExists (const char *name);
 bool fileExists2(uio_DirHandle *dir, const char *fileName);
-#ifdef WIN32
+#ifdef HAVE_UNC_PATHS
 size_t skipUNCServerShare(const char *inPath);
-#endif
+#endif  /* HAVE_UNC_PATHS */
 
-#ifdef WIN32
+#ifdef HAVE_DRIVE_LETTERS
 static inline int isDriveLetter(int c)
 {
 	return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');
 }
-#endif
+#endif  /* HAVE_DRIVE_LETTERS */
 
 #endif  /* _FILE_H */
 
diff -ruNp src.orig/sc2code/libs/gfxlib.h src/sc2code/libs/gfxlib.h
--- src.orig/sc2code/libs/gfxlib.h	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/gfxlib.h	2017-11-08 16:49:56 -0600
@@ -19,27 +19,26 @@
 #ifndef _GFXLIB_H
 #define _GFXLIB_H
 
-#include "memlib.h"
+#include "compiler.h"
+#include "reslib.h"
 
-#define CONTEXT PVOID
-#define FRAME PVOID
-#define FONT PVOID
-
-typedef CONTEXT *PCONTEXT;
-typedef FRAME *PFRAME;
-typedef FONT *PFONT;
+typedef struct context_desc CONTEXT_DESC;
+typedef struct frame_desc FRAME_DESC;
+typedef struct font_desc FONT_DESC;
+typedef struct drawable_desc DRAWABLE_DESC;
+
+typedef CONTEXT_DESC *CONTEXT;
+typedef FRAME_DESC *FRAME;
+typedef FONT_DESC *FONT;
+typedef DRAWABLE_DESC *DRAWABLE;
 
 typedef UWORD TIME_VALUE;
-typedef TIME_VALUE *PTIME_VALUE;
 
 #define TIME_SHIFT 8
 #define MAX_TIME_VALUE ((1 << TIME_SHIFT) + 1)
 
 typedef SWORD COORD;
-typedef COORD *PCOORD;
-
 typedef DWORD COLOR;
-typedef COLOR *PCOLOR;
 
 #define BUILD_COLOR(c32k,c256) \
 	(COLOR)(((DWORD)(c32k)<<8)|(BYTE)(c256))
@@ -70,33 +69,28 @@ typedef struct extent
 {
 	COORD width, height;
 } EXTENT;
-typedef EXTENT *PEXTENT;
 
 typedef struct point
 {
 	COORD x, y;
 } POINT;
-typedef POINT *PPOINT;
 
 typedef struct stamp
 {
 	POINT origin;
 	FRAME frame;
 } STAMP;
-typedef STAMP *PSTAMP;
 
 typedef struct rect
 {
 	POINT corner;
 	EXTENT extent;
 } RECT;
-typedef RECT *PRECT;
 
 typedef struct line
 {
 	POINT first, second;
 } LINE;
-typedef LINE *PLINE;
 
 typedef enum
 {
@@ -119,7 +113,6 @@ typedef struct text
 	TEXT_ALIGN align;
 	COUNT CharCount;
 } TEXT;
-typedef TEXT *PTEXT;
 
 #include "strlib.h"
 
@@ -140,18 +133,6 @@ typedef struct
 	POINT EndPoint;
 	STAMP IntersectStamp;
 } INTERSECT_CONTROL;
-typedef INTERSECT_CONTROL *PINTERSECT_CONTROL;
-
-typedef MEM_HANDLE CONTEXT_REF;
-typedef CONTEXT_REF *PCONTEXT_REF;
-
-typedef DWORD DRAWABLE;
-typedef DRAWABLE *PDRAWABLE;
-
-#define BUILD_DRAWABLE(h,i) ((DRAWABLE)MAKE_DWORD(h,i))
-
-typedef MEM_HANDLE FONT_REF;
-typedef FONT_REF *PFONT_REF;
 
 typedef BYTE INTERSECT_CODE;
 
@@ -169,9 +150,8 @@ typedef POINT HOT_SPOT;
 
 extern HOT_SPOT MAKE_HOT_SPOT (COORD, COORD);
 
-extern INTERSECT_CODE BoxIntersect (PRECT pr1, PRECT pr2, PRECT
-		printer);
-extern void BoxUnion (PRECT pr1, PRECT pr2, PRECT punion);
+extern INTERSECT_CODE BoxIntersect (RECT *pr1, RECT *pr2, RECT *printer);
+extern void BoxUnion (RECT *pr1, RECT *pr2, RECT *punion);
 
 enum
 {
@@ -183,65 +163,56 @@ enum
 	FadeSomeToColor
 };
 
-#endif /* _GFXLIB_H */
-
-
-#ifndef _GFX_PROTOS
-#define _GFX_PROTOS
-
 extern BOOLEAN InitGraphics (int argc, char *argv[], COUNT
 		KbytesRequired);
 extern void UninitGraphics (void);
 
 extern CONTEXT SetContext (CONTEXT Context);
-extern CONTEXT CaptureContext (CONTEXT_REF ContextRef);
-extern CONTEXT_REF ReleaseContext (CONTEXT Context);
 extern COLOR SetContextForeGroundColor (COLOR Color);
 extern COLOR SetContextBackGroundColor (COLOR Color);
 extern FRAME SetContextFGFrame (FRAME Frame);
 extern BOOLEAN SetContextClipping (BOOLEAN ClipStatus);
-extern BOOLEAN SetContextClipRect (PRECT pRect);
-extern BOOLEAN GetContextClipRect (PRECT pRect);
-extern TIME_VALUE DrawablesIntersect (PINTERSECT_CONTROL pControl0,
-		PINTERSECT_CONTROL pControl1, TIME_VALUE max_time_val);
-extern void DrawStamp (PSTAMP pStamp);
-extern void DrawFilledStamp (PSTAMP pStamp);
-extern void DrawPoint (PPOINT pPoint);
-extern void DrawRectangle (PRECT pRect);
-extern void DrawFilledRectangle (PRECT pRect);
-extern void DrawLine (PLINE pLine);
-extern void font_DrawText (PTEXT pText);
-extern void DrawBatch (PPRIMITIVE pBasePrim, PRIM_LINKS PrimLinks,
+extern BOOLEAN SetContextClipRect (RECT *pRect);
+extern BOOLEAN GetContextClipRect (RECT *pRect);
+extern TIME_VALUE DrawablesIntersect (INTERSECT_CONTROL *pControl0,
+		INTERSECT_CONTROL *pControl1, TIME_VALUE max_time_val);
+extern void DrawStamp (STAMP *pStamp);
+extern void DrawFilledStamp (STAMP *pStamp);
+extern void DrawPoint (POINT *pPoint);
+extern void DrawRectangle (RECT *pRect);
+extern void DrawFilledRectangle (RECT *pRect);
+extern void DrawLine (LINE *pLine);
+extern void font_DrawText (TEXT *pText);
+extern void font_DrawTracedText (TEXT *pText, COLOR text, COLOR trace);
+extern void DrawBatch (PRIMITIVE *pBasePrim, PRIM_LINKS PrimLinks,
 		BATCH_FLAGS BatchFlags);
 extern void BatchGraphics (void);
 extern void UnbatchGraphics (void);
 extern void FlushGraphics (void);
-extern void ClearBackGround (PRECT pClipRect);
+extern void ClearBackGround (RECT *pClipRect);
 extern void ClearDrawable (void);
-extern CONTEXT_REF CreateContext (void);
-extern BOOLEAN DestroyContext (CONTEXT_REF ContextRef);
-extern DRAWABLE CreateDisplay (CREATE_FLAGS CreateFlags, PSIZE pwidth,
-		PSIZE pheight);
+extern CONTEXT CreateContext (void);
+extern BOOLEAN DestroyContext (CONTEXT ContextRef);
+extern DRAWABLE CreateDisplay (CREATE_FLAGS CreateFlags, SIZE *pwidth,
+		SIZE *pheight);
 extern DRAWABLE CreateDrawable (CREATE_FLAGS CreateFlags, SIZE width,
 		SIZE height, COUNT num_frames);
 extern BOOLEAN DestroyDrawable (DRAWABLE Drawable);
-extern BOOLEAN GetFrameRect (FRAME Frame, PRECT pRect);
+extern BOOLEAN GetFrameRect (FRAME Frame, RECT *pRect);
 
 extern HOT_SPOT SetFrameHot (FRAME Frame, HOT_SPOT HotSpot);
 extern HOT_SPOT GetFrameHot (FRAME Frame);
-extern BOOLEAN InstallGraphicResTypes (COUNT cel_type, COUNT font_type);
-extern DWORD LoadCelFile (PVOID pStr);
-extern DWORD LoadFontFile (PVOID pStr);
-extern DWORD LoadGraphicInstance (DWORD res);
-extern DRAWABLE LoadDisplayPixmap (PRECT area, FRAME frame);
+extern BOOLEAN InstallGraphicResTypes (void);
+extern DRAWABLE LoadGraphicFile (const char *pStr);
+extern FONT LoadFontFile (const char *pStr);
+extern void *LoadGraphicInstance (RESOURCE res);
+extern DRAWABLE LoadDisplayPixmap (RECT *area, FRAME frame);
 extern FRAME SetContextFontEffect (FRAME EffectFrame);
 extern FONT SetContextFont (FONT Font);
-extern BOOLEAN DestroyFont (FONT_REF FontRef);
-extern FONT CaptureFont (FONT_REF FontRef);
-extern FONT_REF ReleaseFont (FONT Font);
-extern BOOLEAN TextRect (PTEXT pText, PRECT pRect, PBYTE pdelta);
-extern BOOLEAN GetContextFontLeading (PSIZE pheight);
-extern BOOLEAN GetContextFontLeadingWidth (PSIZE pwidth);
+extern BOOLEAN DestroyFont (FONT FontRef);
+extern BOOLEAN TextRect (TEXT *pText, RECT *pRect, BYTE *pdelta);
+extern BOOLEAN GetContextFontLeading (SIZE *pheight);
+extern BOOLEAN GetContextFontLeadingWidth (SIZE *pwidth);
 extern COUNT GetFrameCount (FRAME Frame);
 extern COUNT GetFrameIndex (FRAME Frame);
 extern FRAME SetAbsFrameIndex (FRAME Frame, COUNT FrameIndex);
@@ -255,7 +226,7 @@ extern void SetFrameTransparentColor (FR
 extern FRAME CaptureDrawable (DRAWABLE Drawable);
 extern DRAWABLE ReleaseDrawable (FRAME Frame);
 
-extern MEM_HANDLE GetFrameHandle (FRAME Frame);
+extern DRAWABLE GetFrameParentDrawable (FRAME Frame);
 
 extern BOOLEAN SetColorMap (COLORMAPPTR ColorMapPtr);
 extern DWORD XFormColorMap (COLORMAPPTR ColorMapPtr, SIZE TimeInterval);
@@ -275,8 +246,7 @@ extern void FlushColorXForms (void);
 #define GetColorMapAddress GetStringAddress
 #define GetColorMapContents GetStringContents
 
-void SetSystemRect (PRECT pRect);
+void SetSystemRect (RECT *pRect);
 void ClearSystemRect (void);
 
-#endif /* _GFX_PROTOS */
-
+#endif /* _GFXLIB_H */
diff -ruNp src.orig/sc2code/libs/graphics/boxint.c src/sc2code/libs/graphics/boxint.c
--- src.orig/sc2code/libs/graphics/boxint.c	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/graphics/boxint.c	2017-11-08 16:49:56 -0600
@@ -24,7 +24,7 @@
 #define MAX(a, b) (((a) >= (b)) ? (a) : (b))
 
 INTERSECT_CODE
-BoxIntersect (PRECT pr1, PRECT pr2, PRECT pinter)
+BoxIntersect (RECT *pr1, RECT *pr2, RECT *pinter)
 {
 	INTERSECT_CODE intersect_code;
 	COORD x1;
@@ -102,7 +102,7 @@ BoxIntersect (PRECT pr1, PRECT pr2, PREC
 }
 
 void
-BoxUnion (PRECT pr1, PRECT pr2, PRECT punion)
+BoxUnion (RECT *pr1, RECT *pr2, RECT *punion)
 {
 #if NEVER // Part of lower FIXME.
 	COORD x2, y2, w2, h2;
diff -ruNp src.orig/sc2code/libs/graphics/clipline.c src/sc2code/libs/graphics/clipline.c
--- src.orig/sc2code/libs/graphics/clipline.c	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/graphics/clipline.c	2017-11-08 16:49:56 -0600
@@ -19,7 +19,7 @@
 #include "gfxintrn.h"
 
 INTERSECT_CODE
-_clip_line (PRECT pClipRect, PBRESENHAM_LINE pLine)
+_clip_line (RECT *pClipRect, BRESENHAM_LINE *pLine)
 {
 	COORD p;
 	COORD x0, y0, xmin, ymin, xmax, ymax;
diff -ruNp src.orig/sc2code/libs/graphics/context.c src/sc2code/libs/graphics/context.c
--- src.orig/sc2code/libs/graphics/context.c	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/graphics/context.c	2017-11-08 16:49:56 -0600
@@ -20,18 +20,18 @@
 #include "gfxother.h"
 
 GRAPHICS_STATUS _GraphicsStatusFlags;
-CONTEXTPTR _pCurContext;
+CONTEXT _pCurContext;
 
 PRIMITIVE _locPrim;
 
-FONTPTR _CurFontPtr;
+FONT _CurFontPtr;
 
 CONTEXT
 SetContext (CONTEXT Context)
 {
 	CONTEXT LastContext;
 
-	LastContext = (CONTEXT)_pCurContext;
+	LastContext = _pCurContext;
 	if (Context != LastContext)
 	{
 		if (LastContext)
@@ -47,7 +47,7 @@ SetContext (CONTEXT Context)
 			DeactivateContext ();
 		}
 
-		_pCurContext = (CONTEXTPTR)Context;
+		_pCurContext = Context;
 		if (_pCurContext)
 		{
 			ActivateContext ();
@@ -57,78 +57,48 @@ SetContext (CONTEXT Context)
 
 			SetPrimColor (&_locPrim, _get_context_fg_color ());
 
-			_CurFramePtr = (FRAMEPTR)_get_context_fg_frame ();
-			_CurFontPtr = (FONTPTR)_get_context_font ();
+			_CurFramePtr = _get_context_fg_frame ();
+			_CurFontPtr = _get_context_font ();
 		}
 	}
 
 	return (LastContext);
 }
 
-CONTEXT_REF
+CONTEXT
 CreateContext (void)
 {
-	CONTEXT_REF ContextRef;
+	CONTEXT NewContext;
 
-	ContextRef = AllocContext ();
-	if (ContextRef)
+	NewContext = AllocContext ();
+	if (NewContext)
 	{
 		CONTEXT OldContext;
 
 				/* initialize context */
-		OldContext = SetContext (CaptureContext (ContextRef));
+		OldContext = SetContext (NewContext);
 		SetContextForeGroundColor (
 				BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x1F), 0x0F));
 		SetContextBackGroundColor (
 				BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x00), 0x00));
 		SetContextClipping (TRUE);
-		ReleaseContext (SetContext (OldContext));
+		SetContext (OldContext);
 	}
 
-	return (ContextRef);
+	return (NewContext);
 }
 
 BOOLEAN
-DestroyContext (CONTEXT_REF ContextRef)
+DestroyContext (CONTEXT ContextRef)
 {
 	if (ContextRef == 0)
 		return (FALSE);
 
-	if (_pCurContext && _pCurContext->ContextRef == ContextRef)
+	if (_pCurContext && _pCurContext == ContextRef)
 		SetContext ((CONTEXT)0);
 
-	return (FreeContext (ContextRef));
-}
-
-CONTEXT
-CaptureContext (CONTEXT_REF ContextRef)
-{
-	CONTEXTPTR ContextPtr;
-
-	ContextPtr = LockContext (ContextRef);
-	if (ContextPtr)
-		ContextPtr->ContextRef = ContextRef;
-
-	return ((CONTEXT)ContextPtr);
-}
-
-CONTEXT_REF
-ReleaseContext (CONTEXT Context)
-{
-	CONTEXTPTR ContextPtr;
-
-	ContextPtr = (CONTEXTPTR)Context;
-	if (ContextPtr)
-	{
-		CONTEXT_REF ContextRef;
-
-		ContextRef = ContextPtr->ContextRef;
-		UnlockContext (ContextRef);
-
-		return (ContextRef);
-	}
-
-	return (0);
+	FreeContext (ContextRef);
+	return TRUE;
 }
 
 COLOR
@@ -191,7 +161,7 @@ SetContextClipping (BOOLEAN ClipStatus)
 }
 
 BOOLEAN
-SetContextClipRect (PRECT lpRect)
+SetContextClipRect (RECT *lpRect)
 {
 	if (!ContextActive ())
 		return (FALSE);
@@ -205,7 +175,7 @@ SetContextClipRect (PRECT lpRect)
 }
 
 BOOLEAN
-GetContextClipRect (PRECT lpRect)
+GetContextClipRect (RECT *lpRect)
 {
 	if (!ContextActive ())
 		return (FALSE);
@@ -261,7 +231,7 @@ FixContextFontEffect (void)
 	img = TFB_DrawImage_CreateForScreen (w, h, TRUE);
 	if (_get_context_fbk_flags () & FBK_IMAGE)
 	{	// image pattern backing
-		FRAMEPTR EffectFrame = (FRAMEPTR)_get_context_fonteff ();
+		FRAME EffectFrame = _get_context_fonteff ();
 		
 		TFB_DrawImage_Image (EffectFrame->image,
 				-EffectFrame->HotSpot.x, -EffectFrame->HotSpot.y,
diff -ruNp src.orig/sc2code/libs/graphics/context.h src/sc2code/libs/graphics/context.h
--- src.orig/sc2code/libs/graphics/context.h	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/graphics/context.h	2017-11-08 16:49:56 -0600
@@ -25,9 +25,8 @@ typedef UWORD FBK_FLAGS;
 #define FBK_DIRTY (1 << 0)
 #define FBK_IMAGE (1 << 1)
 
-typedef struct
+struct context_desc
 {
-	CONTEXT_REF ContextRef;
 	UWORD Flags;
 
 	COLOR ForeGroundColor, BackGroundColor;
@@ -40,21 +39,12 @@ typedef struct
 	TFB_Image *FontBacking;
 	FBK_FLAGS BackingFlags;
 
-} CONTEXT_DESC;
-typedef CONTEXT_DESC *PCONTEXT_DESC;
+};
 
-#define CONTEXT_PRIORITY DEFAULT_MEM_PRIORITY
+#define AllocContext() HCalloc (sizeof (CONTEXT_DESC))
+#define FreeContext HFree
 
-#define CONTEXTPTR PCONTEXT_DESC
-
-#define AllocContext() \
-		(CONTEXT_REF)mem_allocate ((MEM_SIZE)sizeof (CONTEXT_DESC), \
-		MEM_ZEROINIT | MEM_PRIMARY, CONTEXT_PRIORITY, MEM_SIMPLE)
-#define LockContext (CONTEXTPTR)mem_lock
-#define UnlockContext mem_unlock
-#define FreeContext mem_release
-
-extern CONTEXTPTR _pCurContext;
+extern CONTEXT _pCurContext;
 extern PRIMITIVE _locPrim;
 
 #define _get_context_fg_color() (_pCurContext->ForeGroundColor)
diff -ruNp src.orig/sc2code/libs/graphics/display.h src/sc2code/libs/graphics/display.h
--- src.orig/sc2code/libs/graphics/display.h	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/graphics/display.h	2017-11-08 16:49:56 -0600
@@ -24,20 +24,19 @@ typedef struct
 	CREATE_FLAGS DisplayFlags;
 
 	BYTE DisplayDepth;
-	COUNT DisplayWidth, DisplayHeight;
+	COUNT DisplayWidth;
+	COUNT DisplayHeight;
 
 	DRAWABLE (*alloc_image) (COUNT NumFrames, DRAWABLE_TYPE DrawableType,
 			CREATE_FLAGS flags, SIZE width, SIZE height);
 
-	void (*read_display) (PRECT pRect, FRAMEPTR DstFramePtr);
+	void (*read_display) (RECT *pRect, FRAME DstFramePtr);
 
 } DISPLAY_INTERFACE;
-typedef DISPLAY_INTERFACE *PDISPLAY_INTERFACE;
 
-extern PDISPLAY_INTERFACE _pCurDisplay;
+extern DISPLAY_INTERFACE *_pCurDisplay;
 
-extern void (* mask_func_array[]) (PRECT pClipRect,
-		PRIMITIVEPTR PrimPtr);
+extern void (* mask_func_array[]) (RECT *pClipRect, PRIMITIVE *PrimPtr);
 
 #define AllocDrawableImage (*_pCurDisplay->alloc_image)
 #define ReadDisplay (*_pCurDisplay->read_display)
diff -ruNp src.orig/sc2code/libs/graphics/drawable.c src/sc2code/libs/graphics/drawable.c
--- src.orig/sc2code/libs/graphics/drawable.c	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/graphics/drawable.c	2017-11-08 16:49:56 -0600
@@ -23,7 +23,7 @@
 #include "libs/mathlib.h"
 #include "gfxother.h"
 
-FRAMEPTR _CurFramePtr;
+FRAME _CurFramePtr;
 
 FRAME
 SetContextFGFrame (FRAME Frame)
@@ -35,7 +35,7 @@ SetContextFGFrame (FRAME Frame)
 		if (LastFrame)
 			DeactivateDrawable ();
 
-		_CurFramePtr = (FRAMEPTR)Frame;
+		_CurFramePtr = Frame;
 		if (_CurFramePtr)
 			ActivateDrawable ();
 
@@ -49,7 +49,7 @@ SetContextFGFrame (FRAME Frame)
 }
 
 DRAWABLE
-CreateDisplay (CREATE_FLAGS CreateFlags, PSIZE pwidth, PSIZE pheight)
+CreateDisplay (CREATE_FLAGS CreateFlags, SIZE *pwidth, SIZE *pheight)
 {
 	DRAWABLE Drawable;
 
@@ -61,7 +61,7 @@ CreateDisplay (CREATE_FLAGS CreateFlags,
 			GetDisplayWidth (), GetDisplayHeight ());
 	if (Drawable)
 	{
-		FRAMEPTR F;
+		FRAME F;
 
 		if ((F = CaptureDrawable (Drawable)) == 0)
 			DestroyDrawable (Drawable);
@@ -80,32 +80,29 @@ CreateDisplay (CREATE_FLAGS CreateFlags,
 }
 
 DRAWABLE
-AllocDrawable (COUNT n) 
+AllocDrawable (COUNT n)
 {
 	DRAWABLE Drawable;
-	Drawable = (DRAWABLE)mem_allocate ((MEM_SIZE)(sizeof (DRAWABLE_DESC)), 
-			MEM_ZEROINIT | MEM_GRAPHICS,
-			DRAWABLE_PRIORITY, MEM_SIMPLE);
+	Drawable = (DRAWABLE) HCalloc(sizeof (DRAWABLE_DESC));
 	if (Drawable)
 	{
-		DRAWABLEPTR DrawablePtr;
 		int i;
-		DrawablePtr = LockDrawable (Drawable);
-		DrawablePtr->Frame = (FRAMEPTR)HMalloc ((MEM_SIZE)(sizeof (FRAME_DESC) * n));
+		Drawable->Frame = (FRAME)HMalloc (sizeof (FRAME_DESC) * n);
 
-		/* Zero out the newly allocated frames, since HMalloc doesn't have MEM_ZEROINIT. */
+		/* Zero out the newly allocated frames, since HMalloc doesn't have
+		 * MEM_ZEROINIT. */
 		for (i = 0; i < n; i++) {
-			FRAMEPTR F;
-			F = &DrawablePtr->Frame[i];
-			F->parent = DrawablePtr;
+			FRAME F;
+			F = &Drawable->Frame[i];
+			F->parent = Drawable;
 			F->Type = 0;
 			F->Index = 0;
 			F->image = 0;
-			F->Bounds.width = F->Bounds.height = 0;
-			F->HotSpot.x = F->HotSpot.y = 0;
+			F->Bounds.width = 0;
+			F->Bounds.height = 0;
+			F->HotSpot.x = 0;
+			F->HotSpot.y = 0;
 		}
-		
-		UnlockDrawable (Drawable);
 	}
 	return Drawable;
 }
@@ -125,7 +122,7 @@ CreateDrawable (CREATE_FLAGS CreateFlags
 			width, height);
 	if (Drawable)
 	{
-		FRAMEPTR F;
+		FRAME F;
 
 		F = CaptureDrawable (Drawable);
 		if (F)
@@ -142,15 +139,11 @@ CreateDrawable (CREATE_FLAGS CreateFlags
 BOOLEAN
 DestroyDrawable (DRAWABLE Drawable)
 {
-	DRAWABLEPTR DrawablePtr;
+	if (_CurFramePtr && (Drawable == _CurFramePtr->parent))
+		SetContextFGFrame ((FRAME)NULL);
 
-	if (LOWORD (Drawable) == GetFrameHandle (_CurFramePtr))
-		SetContextFGFrame ((FRAME)0);
-
-	DrawablePtr = LockDrawable (Drawable);
-	if (DrawablePtr)
+	if (Drawable)
 	{
-		UnlockDrawable (Drawable);
 		FreeDrawable (Drawable);
 
 		return (TRUE);
@@ -160,7 +153,7 @@ DestroyDrawable (DRAWABLE Drawable)
 }
 
 BOOLEAN
-GetFrameRect (FRAMEPTR FramePtr, PRECT pRect)
+GetFrameRect (FRAME FramePtr, RECT *pRect)
 {
 	if (FramePtr)
 	{
@@ -176,7 +169,7 @@ GetFrameRect (FRAMEPTR FramePtr, PRECT p
 }
 
 HOT_SPOT
-SetFrameHot (FRAMEPTR FramePtr, HOT_SPOT HotSpot)
+SetFrameHot (FRAME FramePtr, HOT_SPOT HotSpot)
 {
 	if (FramePtr)
 	{
@@ -192,7 +185,7 @@ SetFrameHot (FRAMEPTR FramePtr, HOT_SPOT
 }
 
 HOT_SPOT
-GetFrameHot (FRAMEPTR FramePtr)
+GetFrameHot (FRAME FramePtr)
 {
 	if (FramePtr)
 	{
@@ -203,10 +196,10 @@ GetFrameHot (FRAMEPTR FramePtr)
 }
 
 DRAWABLE
-RotateFrame (FRAMEPTR Frame, COUNT angle)
+RotateFrame (FRAME Frame, COUNT angle)
 {
 	DRAWABLE Drawable;
-	FRAMEPTR RotFramePtr;
+	FRAME RotFramePtr;
 	SIZE dx, dy;
 	SIZE d;
 	COUNT organg;
@@ -245,7 +238,7 @@ RotateFrame (FRAMEPTR Frame, COUNT angle
 }
 
 void
-SetFrameTransparentColor (FRAMEPTR Frame, COLOR c32k)
+SetFrameTransparentColor (FRAME Frame, COLOR c32k)
 {
 	TFB_Palette color;
 	
@@ -253,3 +246,4 @@ SetFrameTransparentColor (FRAMEPTR Frame
 	TFB_DrawCanvas_SetTransparentColor (Frame->image->NormalImg,
 			color.r, color.g, color.b, FALSE);
 }
+
diff -ruNp src.orig/sc2code/libs/graphics/drawable.h src/sc2code/libs/graphics/drawable.h
--- src.orig/sc2code/libs/graphics/drawable.h	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/graphics/drawable.h	2017-11-08 16:49:56 -0600
@@ -32,14 +32,13 @@ typedef struct bresenham_line
 	BOOLEAN end_points_exchanged;
 	INTERSECT_CODE intersect_code;
 } BRESENHAM_LINE;
-typedef BRESENHAM_LINE *PBRESENHAM_LINE;
 
 typedef UWORD DRAWABLE_TYPE;
 #define ROM_DRAWABLE 0
 #define RAM_DRAWABLE 1
 #define SCREEN_DRAWABLE 2
 
-typedef struct frame_desc
+struct frame_desc
 {
 	DRAWABLE_TYPE Type;
 	UWORD Index;
@@ -47,40 +46,25 @@ typedef struct frame_desc
 	EXTENT Bounds;
 	TFB_Image *image;
 	struct drawable_desc *parent;
-} FRAME_DESC;
-typedef FRAME_DESC *PFRAME_DESC;
+};
 
-typedef struct drawable_desc
+struct drawable_desc
 {
-	MEM_HANDLE hDrawable;
-
 	CREATE_FLAGS Flags;
 	UWORD MaxIndex;
 	FRAME_DESC *Frame;
-} DRAWABLE_DESC;
-typedef DRAWABLE_DESC *PDRAWABLE_DESC;
+};
 
-#define GetFrameWidth(f) (((PFRAME_DESC)(f))->Bounds.width)
-#define GetFrameHeight(f) (((PFRAME_DESC)(f))->Bounds.height)
+#define GetFrameWidth(f) ((f)->Bounds.width)
+#define GetFrameHeight(f) ((f)->Bounds.height)
 #define SetFrameBounds(f,w,h) \
-		(((PFRAME_DESC)(f))->Bounds.width=(w), \
-		((PFRAME_DESC)(f))->Bounds.height=(h))
+		((f)->Bounds.width=(w), \
+		((f))->Bounds.height=(h))
 
 #define DRAWABLE_PRIORITY DEFAULT_MEM_PRIORITY
 
-#define DRAWABLEPTR PDRAWABLE_DESC
-#define FRAMEPTR PFRAME_DESC
-#define COUNTPTR PCOUNT
-
 extern DRAWABLE AllocDrawable (COUNT num_frames);
-#define LockDrawable(D) ((DRAWABLEPTR)mem_lock (GetDrawableHandle (D)))
-#define UnlockDrawable(D) mem_unlock (GetDrawableHandle (D))
-#define FreeDrawable(D) _ReleaseCelData (GetDrawableHandle (D))
-#define GetDrawableHandle(D) ((MEM_HANDLE)LOWORD (D))
-#define GetDrawableIndex(D) ((COUNT)HIWORD (D))
-#define GetFrameParentDrawable(F) (F)->parent
-
-#define NULL_DRAWABLE (DRAWABLE)NULL_PTR
+#define FreeDrawable(D) _ReleaseCelData (D)
 
 #define TYPE_GET(f) ((f) & FTYPE_MASK)
 #define INDEX_GET(f) ((f) & FINDEX_MASK)
@@ -90,29 +74,21 @@ extern DRAWABLE AllocDrawable (COUNT num
 typedef struct
 {
 	RECT Box;
-	FRAMEPTR FramePtr;
+	FRAME FramePtr;
 } IMAGE_BOX;
-typedef IMAGE_BOX *PIMAGE_BOX;
 
 extern DRAWABLE _request_drawable (COUNT NumFrames, DRAWABLE_TYPE
 		DrawableType, CREATE_FLAGS flags, SIZE width, SIZE height);
-extern INTERSECT_CODE _clip_line (PRECT pClipRect, PBRESENHAM_LINE
-		pLine);
-
-extern MEM_HANDLE _GetCelData (uio_Stream *fp, DWORD length);
-extern BOOLEAN _ReleaseCelData (MEM_HANDLE handle);
+extern INTERSECT_CODE _clip_line (RECT *pClipRect, BRESENHAM_LINE *pLine);
 
-typedef PPRIMITIVE PRIMITIVEPTR;
-typedef PPOINT POINTPTR;
-typedef PRECT RECTPTR;
-typedef PSTAMP STAMPPTR;
-typedef PTEXT TEXTPTR;
+extern void *_GetCelData (uio_Stream *fp, DWORD length);
+extern BOOLEAN _ReleaseCelData (void *handle);
 
 extern STAMP _save_stamp;
-extern FRAMEPTR _CurFramePtr;
+extern FRAME _CurFramePtr;
 
-extern void _rect_blt (PRECT pClipRect, PRIMITIVEPTR PrimPtr);
-extern void _text_blt (PRECT pClipRect, PRIMITIVEPTR PrimPtr);
+extern void _rect_blt (RECT *pClipRect, PRIMITIVE *PrimPtr);
+extern void _text_blt (RECT *pClipRect, PRIMITIVE *PrimPtr);
 
 #endif /* _DRAWABLE_H */
 
diff -ruNp src.orig/sc2code/libs/graphics/drawcmd.h src/sc2code/libs/graphics/drawcmd.h
--- src.orig/sc2code/libs/graphics/drawcmd.h	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/graphics/drawcmd.h	2017-11-08 16:49:56 -0600
@@ -35,12 +35,12 @@ enum
 	TFB_DRAWCOMMANDTYPE_SCISSORENABLE,
 	TFB_DRAWCOMMANDTYPE_SCISSORDISABLE,
 
-	TFB_DRAWCOMMANDTYPE_SETPALETTE,
 	TFB_DRAWCOMMANDTYPE_SETMIPMAP,
 	TFB_DRAWCOMMANDTYPE_DELETEIMAGE,
 	TFB_DRAWCOMMANDTYPE_DELETEDATA,
 	TFB_DRAWCOMMANDTYPE_SENDSIGNAL,
 	TFB_DRAWCOMMANDTYPE_REINITVIDEO,
+	TFB_DRAWCOMMANDTYPE_CALLBACK,
 };
 
 typedef struct tfb_dc_line
@@ -110,7 +110,7 @@ typedef struct tfb_dc_setpal
 typedef struct tfb_dc_setmip
 {
 	TFB_Image *image;
-	TFB_Canvas mipmap;
+	TFB_Image *mipmap;
 	int hotx, hoty;
 } TFB_DrawCommand_SetMipmap;
 
@@ -135,6 +135,12 @@ typedef struct tfb_dc_reinit_video
 	int driver, flags, width, height;
 } TFB_DrawCommand_ReinitVideo;
 
+typedef struct tfb_dc_callback
+{
+	void (*callback)(void *arg);
+	void *arg;
+} TFB_DrawCommand_Callback;
+
 typedef struct tfb_drawcommand
 {
 	int Type;
@@ -153,6 +159,7 @@ typedef struct tfb_drawcommand
 		TFB_DrawCommand_DeleteData deletedata;
 		TFB_DrawCommand_SendSignal sendsignal;
 		TFB_DrawCommand_ReinitVideo reinitvideo;
+		TFB_DrawCommand_Callback callback;
 	} data;
 } TFB_DrawCommand;
 
diff -ruNp src.orig/sc2code/libs/graphics/filegfx.c src/sc2code/libs/graphics/filegfx.c
--- src.orig/sc2code/libs/graphics/filegfx.c	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/graphics/filegfx.c	2017-11-08 16:49:56 -0600
@@ -21,8 +21,8 @@
 #include "libs/reslib.h"
 
 
-DWORD
-LoadCelFile (PVOID pStr)
+DRAWABLE
+LoadGraphicFile (const char *pStr)
 {
 	uio_Stream *fp;
 
@@ -34,20 +34,20 @@ LoadCelFile (PVOID pStr)
 	fp = res_OpenResFile (contentDir, pStr, "rb");
 	if (fp != NULL)
 	{
-		MEM_HANDLE hData;
+		DRAWABLE hData;
 
 		_cur_resfile_name = pStr;
-		hData = _GetCelData (fp, LengthResFile (fp));
+		hData = (DRAWABLE)_GetCelData (fp, LengthResFile (fp));
 		_cur_resfile_name = 0;
 		res_CloseResFile (fp);
-		return ((DWORD)hData);
+		return hData;
 	}
 
-	return (0);
+	return (NULL);
 }
 
-DWORD
-LoadFontFile (PVOID pStr)
+FONT
+LoadFontFile (const char *pStr)
 {
 	uio_Stream *fp;
 
@@ -57,15 +57,15 @@ LoadFontFile (PVOID pStr)
 		return 0;
 
 	fp = res_OpenResFile (contentDir, pStr, "rb");
-	if (fp == (uio_Stream *) ~0)
+	if (fp != NULL)
 	{
-		MEM_HANDLE hData;
+		FONT hData;
 
 		_cur_resfile_name = pStr;
-		hData = _GetFontData (fp, LengthResFile (fp));
+		hData = (FONT)_GetFontData (fp, LengthResFile (fp));
 		_cur_resfile_name = 0;
 		res_CloseResFile (fp);
-		return ((DWORD)hData);
+		return hData;
 	}
 
 	return (0);
diff -ruNp src.orig/sc2code/libs/graphics/font.c src/sc2code/libs/graphics/font.c
--- src.orig/sc2code/libs/graphics/font.c	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/graphics/font.c	2017-11-08 16:49:56 -0600
@@ -33,8 +33,8 @@ SetContextFont (FONT Font)
 {
 	FONT LastFont;
 
-	LastFont = (FONT)_CurFontPtr;
-	_CurFontPtr = (FONTPTR)Font;
+	LastFont = _CurFontPtr;
+	_CurFontPtr = Font;
 	if (ContextActive ())
 		SwitchContextFont (Font);
 
@@ -42,50 +42,19 @@ SetContextFont (FONT Font)
 }
 
 BOOLEAN
-DestroyFont (FONT_REF FontRef)
+DestroyFont (FONT FontRef)
 {
-	if (FontRef == 0)
+	if (FontRef == NULL)
 		return (FALSE);
 
-	if (_CurFontPtr && _CurFontPtr->FontRef == FontRef)
-		SetContextFont ((FONT)0);
+	if (_CurFontPtr && _CurFontPtr == FontRef)
+		SetContextFont ((FONT)NULL);
 
 	return (FreeFont (FontRef));
 }
 
-FONT
-CaptureFont (FONT_REF FontRef)
-{
-	FONTPTR FontPtr;
-
-	FontPtr = LockFont (FontRef);
-	if (FontPtr)
-		FontPtr->FontRef = FontRef;
-
-	return ((FONT)FontPtr);
-}
-
-FONT_REF
-ReleaseFont (FONT Font)
-{
-	FONTPTR FontPtr;
-
-	FontPtr = (FONTPTR)Font;
-	if (FontPtr)
-	{
-		FONT_REF FontRef;
-
-		FontRef = FontPtr->FontRef;
-		UnlockFont (FontRef);
-
-		return (FontRef);
-	}
-
-	return (0);
-}
-
 void
-font_DrawText (PTEXT lpText)
+font_DrawText (TEXT *lpText)
 {
 	FixContextFontEffect ();
 	SetPrimType (&_locPrim, TEXT_PRIM);
@@ -93,8 +62,32 @@ font_DrawText (PTEXT lpText)
 	DrawBatch (&_locPrim, 0, BATCH_SINGLE);
 }
 
+ 
+/* Draw the stroke by drawing the same text in the
+ * background color one pixel shifted to all 4 directions.
+ */
+void
+font_DrawTracedText (TEXT *pText, COLOR text, COLOR trace)
+{
+	// Preserve current foreground color for full correctness
+	COLOR oldfg = SetContextForeGroundColor (trace);
+	pText->baseline.x--;
+	font_DrawText (pText);
+	pText->baseline.x += 2;
+	font_DrawText (pText);
+	pText->baseline.x--;
+	pText->baseline.y--;
+	font_DrawText (pText);
+	pText->baseline.y += 2;
+	font_DrawText (pText);
+	pText->baseline.y--;
+	SetContextForeGroundColor (text);
+	font_DrawText (pText);
+	SetContextForeGroundColor (oldfg);
+}
+
 BOOLEAN
-GetContextFontLeading (PSIZE pheight)
+GetContextFontLeading (SIZE *pheight)
 {
 	if (_CurFontPtr != 0)
 	{
@@ -107,7 +100,7 @@ GetContextFontLeading (PSIZE pheight)
 }
 
 BOOLEAN
-GetContextFontLeadingWidth (PSIZE pwidth)
+GetContextFontLeadingWidth (SIZE *pwidth)
 {
 	if (_CurFontPtr != 0)
 	{
@@ -120,9 +113,9 @@ GetContextFontLeadingWidth (PSIZE pwidth
 }
 
 BOOLEAN
-TextRect (PTEXT lpText, PRECT pRect, PBYTE pdelta)
+TextRect (TEXT *lpText, RECT *pRect, BYTE *pdelta)
 {
-	FONTPTR FontPtr;
+	FONT FontPtr;
 
 	FontPtr = _CurFontPtr;
 	if (FontPtr != 0 && lpText->CharCount != 0)
@@ -235,14 +228,14 @@ TextRect (PTEXT lpText, PRECT pRect, PBY
 }
 
 void
-_text_blt (PRECT pClipRect, PRIMITIVEPTR PrimPtr)
+_text_blt (RECT *pClipRect, PRIMITIVE *PrimPtr)
 {
-	FONTPTR FontPtr;
+	FONT FontPtr;
 
 	COUNT num_chars;
 	wchar_t next_ch;
 	const unsigned char *pStr;
-	TEXTPTR TextPtr;
+	TEXT *TextPtr;
 	POINT origin;
 	TFB_Palette color;
 	TFB_Image *backing;
@@ -333,7 +326,7 @@ getCharFrame (FONT_DESC *fontPtr, wchar_
 	}
 	else
 	{
-		log_add (log_Debug, "Character %u not present", (unsigned int) ch);
+		//log_add (log_Debug, "Character %u not present", (unsigned int) ch);
 		return NULL;
 	}
 }
diff -ruNp src.orig/sc2code/libs/graphics/font.h src/sc2code/libs/graphics/font.h
--- src.orig/sc2code/libs/graphics/font.h	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/graphics/font.h	2017-11-08 16:49:56 -0600
@@ -30,7 +30,6 @@ typedef struct FontPage
 	size_t numChars;
 	TFB_Char *charDesc;
 } FONT_PAGE;
-typedef FONT_PAGE *PFONT_PAGE;
 
 static inline FONT_PAGE *
 AllocFontPage (int numChars)
@@ -47,34 +46,24 @@ FreeFontPage (FONT_PAGE *page)
 	HFree (page);
 }
 
-typedef struct
+struct font_desc
 {
-	FONT_REF FontRef;
-
 	UWORD Leading;
 	UWORD LeadingWidth;
 	FONT_PAGE *fontPages;
-} FONT_DESC;
-typedef FONT_DESC *PFONT_DESC;
+};
 
-#define FONTPTR PFONT_DESC
 #define CHAR_DESCPTR PCHAR_DESC
 
 #define FONT_PRIORITY DEFAULT_MEM_PRIORITY
 
-#define AllocFont(size) \
-	(FONT_REF)mem_allocate ((MEM_SIZE)(sizeof (FONT_DESC) + (size)), \
-			MEM_ZEROINIT | MEM_GRAPHICS, FONT_PRIORITY, MEM_SIMPLE)
-#define LockFont(h) (FONTPTR)mem_lock (h)
-#define UnlockFont(h) mem_unlock (h)
+#define AllocFont(size) (FONT)HCalloc (sizeof (FONT_DESC) + (size))
 #define FreeFont _ReleaseFontData
 
-#define NULL_FONT (FONTPTR)NULL_PTR
-
-extern FONTPTR _CurFontPtr;
+extern FONT _CurFontPtr;
 
-extern MEM_HANDLE _GetFontData (uio_Stream *fp, DWORD length);
-extern BOOLEAN _ReleaseFontData (MEM_HANDLE handle);
+extern void *_GetFontData (uio_Stream *fp, DWORD length);
+extern BOOLEAN _ReleaseFontData (void *handle);
 
 #endif /* _FONT_H */
 
diff -ruNp src.orig/sc2code/libs/graphics/frame.c src/sc2code/libs/graphics/frame.c
--- src.orig/sc2code/libs/graphics/frame.c	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/graphics/frame.c	2017-11-08 16:49:56 -0600
@@ -32,6 +32,7 @@ MAKE_HOT_SPOT (COORD x, COORD y)
 	return hs;
 }
 
+// XXX: INTERNAL_PRIMITIVE and INTERNAL_PRIM_DESC are not used
 typedef union
 {
 	POINT Point;
@@ -40,9 +41,6 @@ typedef union
 	TEXT Text;
 	RECT Rect;
 } INTERNAL_PRIM_DESC;
-typedef INTERNAL_PRIM_DESC *PINTERNAL_PRIM_DESC;
-
-typedef PINTERNAL_PRIM_DESC INTERNAL_PRIM_DESCPTR;
 
 typedef struct
 {
@@ -51,12 +49,11 @@ typedef struct
 	COLOR Color;
 	INTERNAL_PRIM_DESC Object;
 } INTERNAL_PRIMITIVE;
-typedef INTERNAL_PRIMITIVE *PINTERNAL_PRIMITIVE;
 
 STAMP _save_stamp;
 
 static BOOLEAN
-GetFrameValidRect (PRECT pValidRect, HOT_SPOT *pOldHot)
+GetFrameValidRect (RECT *pValidRect, HOT_SPOT *pOldHot)
 {
 	COORD hx, hy;
 	HOT_SPOT OldHot;
@@ -86,7 +83,7 @@ GetFrameValidRect (PRECT pValidRect, HOT
 }
 
 void
-ClearBackGround (PRECT pClipRect)
+ClearBackGround (RECT *pClipRect)
 {
 	TFB_Palette color;
 
@@ -95,7 +92,7 @@ ClearBackGround (PRECT pClipRect)
 }
 
 void
-DrawBatch (PPRIMITIVE lpBasePrim, PRIM_LINKS PrimLinks, 
+DrawBatch (PRIMITIVE *lpBasePrim, PRIM_LINKS PrimLinks, 
 		BATCH_FLAGS BatchFlags)
 {
 	RECT ValidRect;
@@ -105,7 +102,7 @@ DrawBatch (PPRIMITIVE lpBasePrim, PRIM_L
 	{
 		COUNT CurIndex;
 		PRIM_LINKS OldLinks;
-		PPRIMITIVE lpPrim;
+		PRIMITIVE *lpPrim;
 
 		BatchFlags &= BATCH_SINGLE
 				| BATCH_BUILD_PAGE
@@ -138,7 +135,7 @@ DrawBatch (PPRIMITIVE lpBasePrim, PRIM_L
 		for (; CurIndex != END_OF_LIST; CurIndex = GetSuccLink (GetPrimLinks (lpPrim)))
 		{
 			GRAPHICS_PRIM PrimType;
-			PPRIMITIVE lpWorkPrim;
+			PRIMITIVE *lpWorkPrim;
 			RECT ClipRect;
 			TFB_Palette color;
 
@@ -168,7 +165,7 @@ DrawBatch (PPRIMITIVE lpBasePrim, PRIM_L
 					break;
 				case TEXT_PRIM:
 					if (!TextRect (&lpWorkPrim->Object.Text,
-							&ClipRect, NULL_PTR))
+							&ClipRect, NULL))
 						continue;
 
 					_save_stamp.origin = ClipRect.corner;
@@ -215,7 +212,7 @@ ClearDrawable (void)
 }
 
 void
-DrawPoint (PPOINT lpPoint)
+DrawPoint (POINT *lpPoint)
 {
 	RECT ValidRect;
 	HOT_SPOT OldHot;
@@ -231,7 +228,7 @@ DrawPoint (PPOINT lpPoint)
 }
 
 void
-DrawRectangle (PRECT lpRect)
+DrawRectangle (RECT *lpRect)
 {
 	RECT ValidRect;
 	HOT_SPOT OldHot;
@@ -247,7 +244,7 @@ DrawRectangle (PRECT lpRect)
 }
 
 void
-DrawFilledRectangle (PRECT lpRect)
+DrawFilledRectangle (RECT *lpRect)
 {
 	RECT ValidRect;
 	HOT_SPOT OldHot;
@@ -263,7 +260,7 @@ DrawFilledRectangle (PRECT lpRect)
 }
 
 void
-DrawLine (PLINE lpLine)
+DrawLine (LINE *lpLine)
 {
 	RECT ValidRect;
 	HOT_SPOT OldHot;
@@ -279,7 +276,7 @@ DrawLine (PLINE lpLine)
 }
 
 void
-DrawStamp (PSTAMP stmp)
+DrawStamp (STAMP *stmp)
 {
 	RECT ValidRect;
 	HOT_SPOT OldHot;
@@ -292,7 +289,7 @@ DrawStamp (PSTAMP stmp)
 }
 
 void
-DrawFilledStamp (PSTAMP stmp)
+DrawFilledStamp (STAMP *stmp)
 {
 	RECT ValidRect;
 	HOT_SPOT OldHot;
diff -ruNp src.orig/sc2code/libs/graphics/gfx_common.c src/sc2code/libs/graphics/gfx_common.c
--- src.orig/sc2code/libs/graphics/gfx_common.c	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/graphics/gfx_common.c	2017-11-08 16:49:56 -0600
@@ -21,10 +21,9 @@
 #include "libs/graphics/gfx_common.h"
 #include "libs/graphics/drawcmd.h"
 
-PDISPLAY_INTERFACE _pCurDisplay; //Not a function. Probably has to be initialized...
+DISPLAY_INTERFACE *_pCurDisplay; //Not a function. Probably has to be initialized...
 
-void (*mask_func_array[])
-		(PRECT pClipRect, PRIMITIVEPTR PrimPtr)
+void (*mask_func_array[]) (RECT *pClipRect, PRIMITIVE *PrimPtr)
 		= { 0 };
 
 int ScreenWidth;
@@ -35,6 +34,9 @@ int ScreenColorDepth;
 int GraphicsDriver;
 int TFB_DEBUG_HALT = 0;
 
+static int gscale = GSCALE_IDENTITY;
+static int gscale_mode = TFB_SCALE_NEAREST;
+
 // Status: Ignored (only used in fmv.c)
 void
 SetGraphicUseOtherExtra (int other) //Could this possibly be more cryptic?!? :)
@@ -52,14 +54,42 @@ SetGraphicGrabOther (int grab_other)
 }
 
 void
-DrawFromExtraScreen (PRECT r)
+DrawFromExtraScreen (RECT *r)
 {
 	TFB_DrawScreen_Copy(r, TFB_SCREEN_EXTRA, TFB_SCREEN_MAIN);
 }
 
 void
-LoadIntoExtraScreen (PRECT r)
+LoadIntoExtraScreen (RECT *r)
 {
 	TFB_DrawScreen_Copy(r, TFB_SCREEN_MAIN, TFB_SCREEN_EXTRA);
 }
 
+int
+SetGraphicScale (int scale)
+{
+	int old_scale = gscale;
+	gscale = (scale ? scale : GSCALE_IDENTITY);
+	return old_scale;
+}
+
+int
+GetGraphicScale (void)
+{
+	return gscale;
+}
+
+int
+SetGraphicScaleMode (int mode)
+{
+	int old_mode = gscale_mode;
+	assert (mode >= TFB_SCALE_NEAREST && mode <= TFB_SCALE_TRILINEAR);
+	gscale_mode = mode;
+	return old_mode;
+}
+
+int
+GetGraphicScaleMode (void)
+{
+	return gscale_mode;
+}
diff -ruNp src.orig/sc2code/libs/graphics/gfx_common.h src/sc2code/libs/graphics/gfx_common.h
--- src.orig/sc2code/libs/graphics/gfx_common.h	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/graphics/gfx_common.h	2017-11-08 16:49:56 -0600
@@ -23,7 +23,6 @@
 #include <stdlib.h>
 
 #include "libs/gfxlib.h"
-#include "libs/vidlib.h"
 #include "libs/misc.h"
 
 // driver for TFB_InitGraphics
@@ -33,6 +32,15 @@ enum
 	TFB_GFXDRIVER_SDL_PURE,
 };
 
+// forced redraw
+enum
+{
+	TFB_REDRAW_NO = 0,
+	TFB_REDRAW_FADING,
+	TFB_REDRAW_EXPOSE,
+	TFB_REDRAW_YES
+};
+
 // flags for TFB_InitGraphics
 #define TFB_GFXFLAGS_FULLSCREEN         (1<<0)
 #define TFB_GFXFLAGS_SHOWFPS            (1<<1)
@@ -59,18 +67,25 @@ int TFB_InitGraphics (int driver, int fl
 void TFB_UninitGraphics (void);
 void TFB_ProcessEvents (void);
 
-// 3DO Graphics Stuff
-
 #define GSCALE_IDENTITY 256
 
-void LoadIntoExtraScreen (PRECT r);
-void DrawFromExtraScreen (PRECT r);
+typedef enum {
+	TFB_SCALE_STEP, /* not really a scaler */
+	TFB_SCALE_NEAREST,
+	TFB_SCALE_BILINEAR,
+	TFB_SCALE_TRILINEAR
+} SCALE;
+
+void LoadIntoExtraScreen (RECT *r);
+void DrawFromExtraScreen (RECT *r);
 void SetGraphicGrabOther (int grab_other);
-void SetGraphicScale (int scale);
-int  GetGraphicScale (void);
+int SetGraphicScale (int scale);
+int GetGraphicScale (void);
+int SetGraphicScaleMode (int mode /* enum SCALE */);
+int GetGraphicScaleMode (void);
 void SetGraphicUseOtherExtra (int other);
-void SetTransitionSource (PRECT pRect);
-void ScreenTransition (int transition, PRECT pRect);
+void SetTransitionSource (RECT *pRect);
+void ScreenTransition (int transition, RECT *pRect);
 
 extern float FrameRate;
 extern int FrameRateTickBase;
diff -ruNp src.orig/sc2code/libs/graphics/gfxintrn.h src/sc2code/libs/graphics/gfxintrn.h
--- src.orig/sc2code/libs/graphics/gfxintrn.h	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/graphics/gfxintrn.h	2017-11-08 16:49:56 -0600
@@ -22,7 +22,6 @@
 #include <stdio.h>
 #include <string.h>
 
-#define _GFX_PROTOS
 #include "gfxlib.h"
 #include "reslib.h"
 #include "context.h"
@@ -30,14 +29,5 @@
 #include "font.h"
 #include "display.h"
 
-#undef CONTEXT
-#define CONTEXT CONTEXTPTR
-#undef FRAME
-#define FRAME FRAMEPTR
-#undef FONT
-#define FONT FONTPTR
-#undef _GFX_PROTOS
-#include "gfxlib.h"
-
 #endif /* _GFXINTRN_H */
 
diff -ruNp src.orig/sc2code/libs/graphics/intersec.c src/sc2code/libs/graphics/intersec.c
--- src.orig/sc2code/libs/graphics/intersec.c	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/graphics/intersec.c	2017-11-08 16:49:56 -0600
@@ -22,8 +22,8 @@
 //#define DEBUG_INTERSEC
 
 static TIME_VALUE
-frame_intersect (PINTERSECT_CONTROL pControl0, PRECT pr0,
-		PINTERSECT_CONTROL pControl1, PRECT pr1, TIME_VALUE t0,
+frame_intersect (INTERSECT_CONTROL *pControl0, RECT *pr0,
+		INTERSECT_CONTROL *pControl1, RECT *pr1, TIME_VALUE t0,
 		TIME_VALUE t1)
 {
 	SIZE time_error0, time_error1;
@@ -201,8 +201,8 @@ frame_intersect (PINTERSECT_CONTROL pCon
 						 * separated by a pixel, the shapes wouldn't be touching
 						 * each other.
 						 */
-			BOOLEAN _image_intersect (PIMAGE_BOX pImageBox0, PIMAGE_BOX
-					pImageBox1, PRECT pIRect);
+			extern BOOLEAN _image_intersect (IMAGE_BOX *pImageBox0,
+					IMAGE_BOX *pImageBox1, RECT *pIRect);
 
 CheckFirstIntersection:
 			if (BoxIntersect (&IB0.Box, &IB1.Box, &r_intersect)
@@ -228,14 +228,13 @@ CheckFirstIntersection:
 }
 
 TIME_VALUE
-DrawablesIntersect (PINTERSECT_CONTROL pControl0,
-		PINTERSECT_CONTROL pControl1, TIME_VALUE
-		max_time_val)
+DrawablesIntersect (INTERSECT_CONTROL *pControl0,
+		INTERSECT_CONTROL *pControl1, TIME_VALUE max_time_val)
 {
 	SIZE dy;
 	SIZE time_y_0, time_y_1;
 	RECT r0, r1;
-	FRAMEPTR FramePtr0, FramePtr1;
+	FRAME FramePtr0, FramePtr1;
 
 	if (!ContextActive () || max_time_val == 0)
 		return ((TIME_VALUE)0);
@@ -252,13 +251,13 @@ DrawablesIntersect (PINTERSECT_CONTROL p
 	r1.extent.width = pControl1->EndPoint.x - r1.corner.x;
 	r1.extent.height = pControl1->EndPoint.y - r1.corner.y;
 		
-	FramePtr0 = (FRAMEPTR)pControl0->IntersectStamp.frame;
+	FramePtr0 = pControl0->IntersectStamp.frame;
 	if (FramePtr0 == 0)
 		return(0);
 	r0.corner.x -= FramePtr0->HotSpot.x;
 	r0.corner.y -= FramePtr0->HotSpot.y;
 
-	FramePtr1 = (FRAMEPTR)pControl1->IntersectStamp.frame;
+	FramePtr1 = pControl1->IntersectStamp.frame;
 	if (FramePtr1 == 0)
 		return(0);
 	r1.corner.x -= FramePtr1->HotSpot.x;
@@ -393,10 +392,10 @@ DrawablesIntersect (PINTERSECT_CONTROL p
 					pControl0, &r0, pControl1, &r1,
 					(TIME_VALUE)time_y_0, (TIME_VALUE)time_y_1)))
 			{
-				FramePtr0 = (FRAMEPTR)pControl0->IntersectStamp.frame;
+				FramePtr0 = pControl0->IntersectStamp.frame;
 				pControl0->EndPoint.x = r0.corner.x + FramePtr0->HotSpot.x;
 				pControl0->EndPoint.y = r0.corner.y + FramePtr0->HotSpot.y;
-				FramePtr1 = (FRAMEPTR)pControl1->IntersectStamp.frame;
+				FramePtr1 = pControl1->IntersectStamp.frame;
 				pControl1->EndPoint.x = r1.corner.x + FramePtr1->HotSpot.x;
 				pControl1->EndPoint.y = r1.corner.y + FramePtr1->HotSpot.y;
 
diff -ruNp src.orig/sc2code/libs/graphics/loaddisp.c src/sc2code/libs/graphics/loaddisp.c
--- src.orig/sc2code/libs/graphics/loaddisp.c	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/graphics/loaddisp.c	2017-11-08 16:49:56 -0600
@@ -34,14 +34,11 @@
 
 
 DRAWABLE
-LoadDisplayPixmap (PRECT area, FRAME frame)
+LoadDisplayPixmap (RECT *area, FRAME frame)
 {
-	DRAWABLE buffer;
+	DRAWABLE buffer = GetFrameParentDrawable (frame);
+	COUNT index = GetFrameIndex (frame);
 
-	buffer = BUILD_DRAWABLE (
-			GetFrameHandle (frame),
-			GetFrameIndex (frame)
-			);
 	if (buffer || (buffer = CreateDrawable (
 			WANT_PIXMAP | MAPPED_TO_DISPLAY,
 			area->extent.width,
@@ -49,8 +46,8 @@ LoadDisplayPixmap (PRECT area, FRAME fra
 			1))
 		)
 	{
-		frame = CaptureDrawable (buffer);
-		ReadDisplay (area, (FRAMEPTR)frame);
+		frame = SetAbsFrameIndex (CaptureDrawable (buffer), index);
+		ReadDisplay (area, frame);
 		ReleaseDrawable (frame);
 	}
 
diff -ruNp src.orig/sc2code/libs/graphics/pixmap.c src/sc2code/libs/graphics/pixmap.c
--- src.orig/sc2code/libs/graphics/pixmap.c	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/graphics/pixmap.c	2017-11-08 16:49:56 -0600
@@ -17,58 +17,48 @@
  */
 
 #include "gfxintrn.h"
+#include "libs/log.h"
 
-FRAME
-CaptureDrawable (DRAWABLE Drawable)
+DRAWABLE
+GetFrameParentDrawable (FRAME f)
 {
-	DRAWABLEPTR DrawablePtr;
+	if (f != NULL)
+	{
+		return f->parent;
+	}
+	return NULL;
+}
 
-	DrawablePtr = LockDrawable (Drawable);
+FRAME
+CaptureDrawable (DRAWABLE DrawablePtr)
+{
 	if (DrawablePtr)
 	{
-		COUNT FrameIndex;
-
-		FrameIndex = GetDrawableIndex (Drawable);
-		return ((FRAME)&DrawablePtr->Frame[FrameIndex]);
+		return &DrawablePtr->Frame[0];
 	}
 
-	return (0);
+	return NULL;
 }
 
 DRAWABLE
-ReleaseDrawable (FRAMEPTR FramePtr)
+ReleaseDrawable (FRAME FramePtr)
 {
 	if (FramePtr != 0)
 	{
 		DRAWABLE Drawable;
-		DRAWABLEPTR DrawablePtr;
 
-		DrawablePtr = GetFrameParentDrawable (FramePtr);
-		Drawable = BUILD_DRAWABLE (DrawablePtr->hDrawable, FramePtr->Index);
-		UnlockDrawable (Drawable);
+		Drawable = GetFrameParentDrawable (FramePtr);
 
 		return (Drawable);
 	}
 
-	return (0);
-}
-
-MEM_HANDLE
-GetFrameHandle (FRAMEPTR FramePtr)
-{
-	DRAWABLEPTR DrawablePtr;
-
-	if (FramePtr == 0)
-		return (0);
-
-	DrawablePtr = GetFrameParentDrawable (FramePtr);
-	return (DrawablePtr->hDrawable);
+	return NULL;
 }
 
 COUNT
-GetFrameCount (FRAMEPTR FramePtr)
+GetFrameCount (FRAME FramePtr)
 {
-	DRAWABLEPTR DrawablePtr;
+	DRAWABLE_DESC *DrawablePtr;
 
 	if (FramePtr == 0)
 		return (0);
@@ -78,7 +68,7 @@ GetFrameCount (FRAMEPTR FramePtr)
 }
 
 COUNT
-GetFrameIndex (FRAMEPTR FramePtr)
+GetFrameIndex (FRAME FramePtr)
 {
 	if (FramePtr == 0)
 		return (0);
@@ -87,28 +77,28 @@ GetFrameIndex (FRAMEPTR FramePtr)
 }
 
 FRAME
-SetAbsFrameIndex (FRAMEPTR FramePtr, COUNT FrameIndex)
+SetAbsFrameIndex (FRAME FramePtr, COUNT FrameIndex)
 {
 	if (FramePtr != 0)
 	{
-		DRAWABLEPTR DrawablePtr;
+		DRAWABLE_DESC *DrawablePtr;
 
 		DrawablePtr = GetFrameParentDrawable (FramePtr);
 
 		FrameIndex = FrameIndex	% (DrawablePtr->MaxIndex + 1);
-		FramePtr = (FRAMEPTR)&DrawablePtr->Frame[FrameIndex];
+		FramePtr = &DrawablePtr->Frame[FrameIndex];
 	}
 
-	return ((FRAME)FramePtr);
+	return FramePtr;
 }
 
 FRAME
-SetRelFrameIndex (FRAMEPTR FramePtr, SIZE FrameOffs)
+SetRelFrameIndex (FRAME FramePtr, SIZE FrameOffs)
 {
 	if (FramePtr != 0)
 	{
 		COUNT num_frames;
-		DRAWABLEPTR DrawablePtr;
+		DRAWABLE_DESC *DrawablePtr;
 
 		DrawablePtr = GetFrameParentDrawable (FramePtr);
 		num_frames = DrawablePtr->MaxIndex + 1;
@@ -119,53 +109,62 @@ SetRelFrameIndex (FRAMEPTR FramePtr, SIZ
 		}
 
 		FrameOffs = ((SWORD)FramePtr->Index + FrameOffs) % num_frames;
-		FramePtr = (FRAMEPTR)&DrawablePtr->Frame[FrameOffs];
+		FramePtr = &DrawablePtr->Frame[FrameOffs];
 	}
 
-	return ((FRAME)FramePtr);
+	return FramePtr;
 }
 
 FRAME
-SetEquFrameIndex (FRAMEPTR DstFramePtr, FRAMEPTR SrcFramePtr)
+SetEquFrameIndex (FRAME DstFramePtr, FRAME SrcFramePtr)
 {
-	if (DstFramePtr && SrcFramePtr)
-		return ((FRAME)(
-				(PBYTE)((GetFrameParentDrawable (DstFramePtr))->Frame)
-				+ ((PBYTE)SrcFramePtr -
-				(PBYTE)((GetFrameParentDrawable (SrcFramePtr))->Frame))
-				));
+	COUNT Index;
+
+	if (!DstFramePtr || !SrcFramePtr)
+		return 0;
 
-	return (0);
+	Index = GetFrameIndex (SrcFramePtr);
+#ifdef DEBUG
+	{
+		DRAWABLE_DESC *DrawablePtr = GetFrameParentDrawable (DstFramePtr);
+		if (Index > DrawablePtr->MaxIndex)
+			log_add (log_Debug, "SetEquFrameIndex: source index (%d) beyond "
+					"destination range (%d)", (int)Index,
+					(int)DrawablePtr->MaxIndex);
+	}
+#endif
+	
+	return SetAbsFrameIndex (DstFramePtr, Index);
 }
 
 FRAME
-IncFrameIndex (FRAMEPTR FramePtr)
+IncFrameIndex (FRAME FramePtr)
 {
-	DRAWABLEPTR DrawablePtr;
+	DRAWABLE_DESC *DrawablePtr;
 
 	if (FramePtr == 0)
 		return (0);
 
 	DrawablePtr = GetFrameParentDrawable (FramePtr);
 	if (FramePtr->Index < DrawablePtr->MaxIndex)
-		return ((FRAME)++FramePtr);
+		return ++FramePtr;
 	else
-		return ((FRAME)DrawablePtr->Frame);
+		return DrawablePtr->Frame;
 }
 
 FRAME
-DecFrameIndex (FRAMEPTR FramePtr)
+DecFrameIndex (FRAME FramePtr)
 {
 	if (FramePtr == 0)
 		return (0);
 
 	if (FramePtr->Index > 0)
-		return ((FRAME)--FramePtr);
+		return --FramePtr;
 	else
 	{
-		DRAWABLEPTR DrawablePtr;
+		DRAWABLE_DESC *DrawablePtr;
 
 		DrawablePtr = GetFrameParentDrawable (FramePtr);
-		return ((FRAME)&DrawablePtr->Frame[DrawablePtr->MaxIndex]);
+		return &DrawablePtr->Frame[DrawablePtr->MaxIndex];
 	}
 }
diff -ruNp src.orig/sc2code/libs/graphics/prim.h src/sc2code/libs/graphics/prim.h
--- src.orig/sc2code/libs/graphics/prim.h	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/graphics/prim.h	2017-11-08 16:49:56 -0600
@@ -38,7 +38,6 @@ typedef union
    TEXT Text;
    RECT Rect;
 } PRIM_DESC;
-typedef PRIM_DESC *PPRIM_DESC;
 
 typedef DWORD PRIM_LINKS;
 
@@ -49,7 +48,6 @@ typedef struct
 	COLOR Color;
 	PRIM_DESC Object;
 } PRIMITIVE;
-typedef PRIMITIVE *PPRIMITIVE;
 
 #define END_OF_LIST ((COUNT)0xFFFF)
 
@@ -64,14 +62,14 @@ typedef PRIMITIVE *PPRIMITIVE;
 #define GetPrimColor(pPrim) ((pPrim)->Color)
 
 static inline void
-SetPrimNextLink (PPRIMITIVE pPrim, COUNT Link)
+SetPrimNextLink (PRIMITIVE *pPrim, COUNT Link)
 {
 	SetPrimLinks (pPrim, END_OF_LIST, Link);
 }
 
 
 static inline COUNT
-GetPrimNextLink (PPRIMITIVE pPrim)
+GetPrimNextLink (PRIMITIVE *pPrim)
 {
 	return GetSuccLink (GetPrimLinks (pPrim));
 }
diff -ruNp src.orig/sc2code/libs/graphics/resgfx.c src/sc2code/libs/graphics/resgfx.c
--- src.orig/sc2code/libs/graphics/resgfx.c	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/graphics/resgfx.c	2017-11-08 16:49:56 -0600
@@ -18,24 +18,37 @@
 
 #include "gfxintrn.h"
 
+static void
+GetCelFileData (const char *pathname, RESOURCE_DATA *resdata)
+{
+	resdata->ptr = LoadResourceFromPath (pathname, _GetCelData);
+}
+
+static void
+GetFontFileData (const char *pathname, RESOURCE_DATA *resdata)
+{
+	resdata->ptr = LoadResourceFromPath (pathname, _GetFontData);
+}
+
 
 BOOLEAN
-InstallGraphicResTypes (COUNT cel_type, COUNT font_type)
+InstallGraphicResTypes (void)
 {
-	InstallResTypeVectors (cel_type, _GetCelData, _ReleaseCelData);
-	InstallResTypeVectors (font_type, _GetFontData, _ReleaseFontData);
+	InstallResTypeVectors ("GFXRES", GetCelFileData, _ReleaseCelData);
+	InstallResTypeVectors ("FONTRES", GetFontFileData, _ReleaseFontData);
 	return (TRUE);
 }
 
-DWORD
-LoadGraphicInstance (DWORD res)
+/* Needs to be void * because it could be either a DRAWABLE or a FONT. */
+void *
+LoadGraphicInstance (RESOURCE res)
 {
-	MEM_HANDLE hData;
+	void *hData;
 
 	hData = res_GetResource (res);
 	if (hData)
 		res_DetachResource (res);
 
-	return ((DWORD)hData);
+	return (hData);
 }
 
diff -ruNp src.orig/sc2code/libs/graphics/sdl/3do_blt.c src/sc2code/libs/graphics/sdl/3do_blt.c
--- src.orig/sc2code/libs/graphics/sdl/3do_blt.c	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/graphics/sdl/3do_blt.c	2017-11-08 16:49:57 -0600
@@ -22,29 +22,16 @@
 #include "graphics/tfb_draw.h"
 #include "libs/log.h"
 
-static int gscale = GSCALE_IDENTITY;
-
-void
-SetGraphicScale (int scale)
-{
-	gscale = (scale ? scale : GSCALE_IDENTITY);
-}
-
-int
-GetGraphicScale ()
-{
-	return gscale;
-}
-
 static void
-read_screen (PRECT lpRect, FRAMEPTR DstFramePtr)
+read_screen (RECT *lpRect, FRAME DstFramePtr)
 {
 	if (_CurFramePtr->Type != SCREEN_DRAWABLE
 			|| DstFramePtr->Type == SCREEN_DRAWABLE
 			|| !(GetFrameParentDrawable (DstFramePtr)->Flags
 				& MAPPED_TO_DISPLAY))
 	{
-		log_add (log_Warning, "Unimplemented function activated: read_screen()");
+		log_add (log_Warning, "Unimplemented function activated: "
+				"read_screen()");
 	}
 	else
 	{
@@ -67,20 +54,21 @@ alloc_image (COUNT NumFrames, DRAWABLE_T
 
 static DISPLAY_INTERFACE DisplayInterface =
 {
-	WANT_MASK,
+	/* .DisplayFlags  = */ WANT_MASK,
 
-	16, // SCREEN_DEPTH,
-	320,
-	240,
+	/* .DisplayDepth  = */ 16,
+	/* .DisplayWidth  = */ 320,
+	/* .DisplayHeight = */ 240,
 
-	alloc_image,
-	read_screen,
+	/* .alloc_iamge   = */ alloc_image,
+	/* .read_display  = */ read_screen,
 };
 
 void
-LoadDisplay (PDISPLAY_INTERFACE *pDisplay)
+LoadDisplay (DISPLAY_INTERFACE **pDisplay)
 {
 	*pDisplay = &DisplayInterface;
 }
 
 #endif
+
diff -ruNp src.orig/sc2code/libs/graphics/sdl/3do_funcs.c src/sc2code/libs/graphics/sdl/3do_funcs.c
--- src.orig/sc2code/libs/graphics/sdl/3do_funcs.c	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/graphics/sdl/3do_funcs.c	2017-11-08 16:49:57 -0600
@@ -84,7 +84,7 @@ FlushGraphics ()
 }
 
 static void
-ExpandRect (PRECT rect, int expansion)
+ExpandRect (RECT *rect, int expansion)
 {
 	if (rect->corner.x - expansion >= 0)
 	{
@@ -120,7 +120,7 @@ ExpandRect (PRECT rect, int expansion)
 }
 
 void
-SetTransitionSource (PRECT pRect)
+SetTransitionSource (RECT *pRect)
 {
 	RECT ActualRect;
 
@@ -135,7 +135,7 @@ SetTransitionSource (PRECT pRect)
 
 // Status: Implemented
 void
-ScreenTransition (int TransType, PRECT pRect)
+ScreenTransition (int TransType, RECT *pRect)
 {
 	const float DURATION = (31.0f / 60.0f); // in seconds
 	Uint32 last_time = 0, current_time, delta_time, add_amount;
@@ -183,7 +183,7 @@ ScreenTransition (int TransType, PRECT p
 }
 
 BOOLEAN
-_image_intersect (PIMAGE_BOX box1, PIMAGE_BOX box2, PRECT rect)
+_image_intersect (IMAGE_BOX *box1, IMAGE_BOX *box2, RECT *rect)
 {
 	BOOLEAN ret;
 	SDL_Surface *img1, *img2;
diff -ruNp src.orig/sc2code/libs/graphics/sdl/3do_getbody.c src/sc2code/libs/graphics/sdl/3do_getbody.c
--- src.orig/sc2code/libs/graphics/sdl/3do_getbody.c	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/graphics/sdl/3do_getbody.c	2017-11-08 16:49:57 -0600
@@ -42,9 +42,11 @@ typedef struct anidata
 	int hotspot_y;
 } AniData;
 
+extern uio_Repository *repository;
+static uio_AutoMount *autoMount[] = { NULL };
 
 static void
-process_image (FRAMEPTR FramePtr, SDL_Surface *img[], AniData *ani, int cel_ct)
+process_image (FRAME FramePtr, SDL_Surface *img[], AniData *ani, int cel_ct)
 {
 	TFB_Image *tfbimg;
 	int hx, hy;
@@ -185,13 +187,12 @@ processFontChar (TFB_Char* CharPtr, SDL_
 // create a new frame of size neww x newh, and blit a scaled version FramePtr
 // into it.
 // destroy the old frame if 'destroy' is 1
-FRAMEPTR stretch_frame (FRAMEPTR FramePtr, int neww, int newh, int destroy)
+FRAME stretch_frame (FRAME FramePtr, int neww, int newh, int destroy)
 {
-	FRAMEPTR NewFrame;
+	FRAME NewFrame;
 	CREATE_FLAGS flags;
 	TFB_Image *tfbImg;
 	TFB_Canvas src, dst;
-	EXTENT ext;
 
 	flags = GetFrameParentDrawable (FramePtr)->Flags;
 	NewFrame = CaptureDrawable (
@@ -200,16 +201,14 @@ FRAMEPTR stretch_frame (FRAMEPTR FramePt
 	LockMutex (tfbImg->mutex);
 	src = tfbImg->NormalImg;
 	dst = NewFrame->image->NormalImg;
-	ext.width = neww;
-	ext.height = newh;
-	TFB_DrawCanvas_Rescale_Nearest (src, dst, ext);
+	TFB_DrawCanvas_Rescale_Nearest (src, dst, -1, NULL, NULL, NULL);
 	UnlockMutex (tfbImg->mutex);
 	if (destroy)
 		DestroyDrawable (ReleaseDrawable (FramePtr));
 	return (NewFrame);
 }
 
-void process_rgb_bmp (FRAMEPTR FramePtr, Uint32 *rgba, int maxx, int maxy)
+void process_rgb_bmp (FRAME FramePtr, Uint32 *rgba, int maxx, int maxy)
 {
 	int x, y;
 	TFB_Image *tfbImg;
@@ -230,7 +229,7 @@ void process_rgb_bmp (FRAMEPTR FramePtr,
 	UnlockMutex (tfbImg->mutex);
 }
 
-void fill_frame_rgb (FRAMEPTR FramePtr, Uint32 color, int x0, int y0,
+void fill_frame_rgb (FRAME FramePtr, Uint32 color, int x0, int y0,
 		int x, int y)
 {
 	SDL_Surface *img;
@@ -255,8 +254,8 @@ void fill_frame_rgb (FRAMEPTR FramePtr,
 	UnlockMutex (tfbImg->mutex);
 }
 
-void arith_frame_blit (FRAMEPTR srcFrame, RECT *rsrc, FRAMEPTR dstFrame,
-		RECT *rdst, int num, int denom)
+void arith_frame_blit (FRAME srcFrame, const RECT *rsrc, FRAME dstFrame,
+		const RECT *rdst, int num, int denom)
 {
 	TFB_Image *srcImg, *dstImg;
 	SDL_Surface *src, *dst;
@@ -296,7 +295,7 @@ void arith_frame_blit (FRAMEPTR srcFrame
 			dstRect.y = -srcFrame->HotSpot.y;
 			dstRect.w = GetFrameWidth (srcFrame);
 			dstRect.h = GetFrameHeight (srcFrame);
-			drp =&dstRect;
+			drp = &dstRect;
 		}
 
 	}
@@ -312,7 +311,7 @@ void arith_frame_blit (FRAMEPTR srcFrame
 //  bits 8-15  : blue
 //  bits 0-7   : alpha
 // The 8bpp pixel format is 1 index per pixel
-void getpixelarray (void *map, int Bpp, FRAMEPTR FramePtr,
+void getpixelarray (void *map, int Bpp, FRAME FramePtr,
 		int width, int height)
 {
 	Uint8 r,g,b,a;
@@ -367,50 +366,114 @@ void getpixelarray (void *map, int Bpp,
 
 // Generate a pixel (in the correct format to be applied to FramePtr) from the
 // r,g,b,a values supplied
-Uint32 frame_mapRGBA (FRAMEPTR FramePtr,Uint8 r, Uint8 g,  Uint8 b, Uint8 a)
+Uint32 frame_mapRGBA (FRAME FramePtr,Uint8 r, Uint8 g,  Uint8 b, Uint8 a)
 {
 	SDL_Surface *img= (SDL_Surface *)FramePtr->image->NormalImg;
 	return (SDL_MapRGBA (img->format, r, g, b, a));
 }
 
-MEM_HANDLE
+void *
 _GetCelData (uio_Stream *fp, DWORD length)
 {
-	int cel_ct, n;
+	int cel_total, cel_index, n;
 	DWORD opos;
-	char CurrentLine[1024], filename[1024];
-#define MAX_CELS 256
-	SDL_Surface *img[MAX_CELS];
-	AniData ani[MAX_CELS];
+	char CurrentLine[1024], filename[PATH_MAX];
+	SDL_Surface **img;
+	AniData *ani;
 	DRAWABLE Drawable;
+	uio_MountHandle *aniMount = 0;
+	uio_DirHandle *aniDir = 0;
+	uio_Stream *aniFile = 0;
 	
 	opos = uio_ftell (fp);
 
 	{
 		char *s1, *s2;
+		char aniDirName[PATH_MAX];			
+		const char *aniFileName;
+		uint8 buf[4] = { 0, 0, 0, 0 };
+		uint32 header;
 
 		if (_cur_resfile_name == 0
 				|| (((s2 = 0), (s1 = strrchr (_cur_resfile_name, '/')) == 0)
 						&& (s2 = strrchr (_cur_resfile_name, '\\')) == 0))
+		{
 			n = 0;
+		}
 		else
 		{
 			if (s2 > s1)
 				s1 = s2;
 			n = s1 - _cur_resfile_name + 1;
+		}
+
+		uio_fread(buf, 4, 1, fp);
+		header = buf[0] | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24);
+ 		if (_cur_resfile_name && header == 0x04034b50)
+		{
+			// zipped ani file
+			if (n)
+			{
+				strncpy (aniDirName, _cur_resfile_name, n - 1);
+				aniDirName[n - 1] = 0;
+				aniFileName = _cur_resfile_name + n;
+			}
+			else
+			{
+				strcpy(aniDirName, ".");
+				aniFileName = _cur_resfile_name;
+			}
+			aniDir = uio_openDir (repository, aniDirName, 0);
+			aniMount = uio_mountDir (repository, aniDirName, uio_FSTYPE_ZIP,
+							aniDir, aniFileName, "/", autoMount,
+							uio_MOUNT_RDONLY | uio_MOUNT_TOP,
+							NULL);
+			aniFile = uio_fopen (aniDir, aniFileName, "r");
+			opos = 0;
+			n = 0;
+		}
+		else
+		{
+			// unpacked ani file
 			strncpy (filename, _cur_resfile_name, n);
+			aniFile = fp;
+			aniDir = contentDir;
+		}
+	}
+
+	cel_total = 0;
+	uio_fseek (aniFile, opos, SEEK_SET);
+	while (uio_fgets (CurrentLine, sizeof (CurrentLine), aniFile))
+	{
+		++cel_total;
+	}
+
+	img = HMalloc (sizeof (SDL_Surface *) * cel_total);
+	ani = HMalloc (sizeof (AniData) * cel_total);
+	if (!img || !ani)
+	{
+		log_add (log_Warning, "Couldn't allocate space for '%s'", _cur_resfile_name);
+		if (aniMount)
+		{
+			uio_fclose(aniFile);
+			uio_closeDir(aniDir);
+			uio_unmountDir(aniMount);
 		}
+		HFree (img);
+		HFree (ani);
+		return NULL;
 	}
 
-	cel_ct = 0;
-	while (uio_fgets (CurrentLine, sizeof (CurrentLine), fp) && cel_ct < MAX_CELS)
+	cel_index = 0;
+	uio_fseek (aniFile, opos, SEEK_SET);
+	while (uio_fgets (CurrentLine, sizeof (CurrentLine), aniFile) && cel_index < cel_total)
 	{
 		sscanf (CurrentLine, "%s %d %d %d %d", &filename[n], 
-			&ani[cel_ct].transparent_color, &ani[cel_ct].colormap_index, 
-			&ani[cel_ct].hotspot_x, &ani[cel_ct].hotspot_y);
+			&ani[cel_index].transparent_color, &ani[cel_index].colormap_index, 
+			&ani[cel_index].hotspot_x, &ani[cel_index].hotspot_y);
 	
-		img[cel_ct] = sdluio_loadImage (contentDir, filename);
-		if (img[cel_ct] == NULL)
+		img[cel_index] = sdluio_loadImage (aniDir, filename);
+		if (img[cel_index] == NULL)
 		{
 			const char *err;
 
@@ -418,66 +481,71 @@ _GetCelData (uio_Stream *fp, DWORD lengt
 			log_add (log_Warning, "_GetCelData: Unable to load image!");
 			if (err != NULL)
 				log_add (log_Warning, "SDL reports: %s", err);
-			SDL_FreeSurface (img[cel_ct]);
+			SDL_FreeSurface (img[cel_index]);
 		}
-		else if (img[cel_ct]->w < 0 || img[cel_ct]->h < 0 ||
-				img[cel_ct]->format->BitsPerPixel < 8)
+		else if (img[cel_index]->w < 0 || img[cel_index]->h < 0 ||
+				img[cel_index]->format->BitsPerPixel < 8)
 		{
 			log_add (log_Warning, "_GetCelData: Bad file!");
-			SDL_FreeSurface (img[cel_ct]);
+			SDL_FreeSurface (img[cel_index]);
 		}
 		else
 		{
-			++cel_ct;
+			++cel_index;
 		}
 
-		if ((int)uio_ftell (fp) - (int)opos >= (int)length)
+		if ((int)uio_ftell (aniFile) - (int)opos >= (int)length)
 			break;
 	}
 
-	Drawable = 0;
-	if (cel_ct && (Drawable = AllocDrawable (cel_ct)))
+	Drawable = NULL;
+	if (cel_index && (Drawable = AllocDrawable (cel_index)))
 	{
-		DRAWABLEPTR DrawablePtr;
-
-		if ((DrawablePtr = LockDrawable (Drawable)) == 0)
+		if (!Drawable)
 		{
-			while (cel_ct--)
-				SDL_FreeSurface (img[cel_ct]);
+			while (cel_index--)
+				SDL_FreeSurface (img[cel_index]);
 
-			mem_release ((MEM_HANDLE)Drawable);
-			Drawable = 0;
+			HFree (Drawable);
+			Drawable = NULL;
 		}
 		else
 		{
-			FRAMEPTR FramePtr;
-
-			DrawablePtr->hDrawable = GetDrawableHandle (Drawable);
-			DrawablePtr->Flags = WANT_PIXMAP;
-			DrawablePtr->MaxIndex = cel_ct - 1;
+			FRAME FramePtr;
 
-			FramePtr = &DrawablePtr->Frame[cel_ct];
-			while (--FramePtr, cel_ct--)
-				process_image (FramePtr, img, ani, cel_ct);
+			Drawable->Flags = WANT_PIXMAP;
+			Drawable->MaxIndex = cel_index - 1;
 
-			UnlockDrawable (Drawable);
+			FramePtr = &Drawable->Frame[cel_index];
+			while (--FramePtr, cel_index--)
+				process_image (FramePtr, img, ani, cel_index);
 		}
 	}
 
-	if (Drawable == 0)
+	if (Drawable == NULL)
 		log_add (log_Warning, "Couldn't get cel data for '%s'",
 				_cur_resfile_name);
-	return (GetDrawableHandle (Drawable));
+
+	if (aniMount)
+	{
+		uio_fclose(aniFile);
+		uio_closeDir(aniDir);
+		uio_unmountDir(aniMount);
+	}
+
+	HFree (img);
+	HFree (ani);
+	return Drawable;
 }
 
 BOOLEAN
-_ReleaseCelData (MEM_HANDLE handle)
+_ReleaseCelData (void *handle)
 {
-	DRAWABLEPTR DrawablePtr;
+	DRAWABLE DrawablePtr;
 	int cel_ct;
-	FRAMEPTR FramePtr = NULL;
+	FRAME FramePtr = NULL;
 
-	if ((DrawablePtr = LockDrawable (handle)) == 0)
+	if ((DrawablePtr = handle) == 0)
 		return (FALSE);
 
 	cel_ct = DrawablePtr->MaxIndex + 1;
@@ -491,8 +559,8 @@ _ReleaseCelData (MEM_HANDLE handle)
 		}
 	}
 
-	UnlockDrawable (handle);
-	if (mem_release (handle) && FramePtr)
+	HFree (handle);
+	if (FramePtr)
 	{
 		int i;
 		for (i = 0; i < cel_ct; i++)
@@ -520,25 +588,59 @@ compareBCDIndex(const BuildCharDesc *bcd
 	return (int) bcd1->index - (int) bcd2->index;
 }
 
-MEM_HANDLE
+void *
 _GetFontData (uio_Stream *fp, DWORD length)
 {
 	COUNT numDirEntries;
-	FONT_REF fontRef = 0;
-	DIRENTRY fontDir = 0;
+	DIRENTRY fontDir = NULL;
 	BuildCharDesc *bcds = NULL;
 	size_t numBCDs = 0;
 	int dirEntryI;
 	uio_DirHandle *fontDirHandle = NULL;
-	FONTPTR fontPtr;
+	uio_MountHandle *fontMount = NULL;
+	FONT fontPtr = NULL;
 
 	if (_cur_resfile_name == 0)
 		goto err;
 
+	if (fp != (uio_Stream*)~0)
+	{
+		// font is zipped instead of being in a directory
+
+		char *s1, *s2;
+		int n;
+		const char *fontZipName;
+		char fontDirName[PATH_MAX];
+
+		if ((((s2 = 0), (s1 = strrchr (_cur_resfile_name, '/')) == 0)
+						&& (s2 = strrchr (_cur_resfile_name, '\\')) == 0))
+		{
+			strcpy(fontDirName, ".");
+			fontZipName = _cur_resfile_name;
+		}
+		else
+		{
+			if (s2 > s1)
+				s1 = s2;
+			n = s1 - _cur_resfile_name + 1;
+			strncpy (fontDirName, _cur_resfile_name, n - 1);
+			fontDirName[n - 1] = 0;
+			fontZipName = _cur_resfile_name + n;
+		}
+
+		fontDirHandle = uio_openDir (repository, fontDirName, 0);
+		fontMount = uio_mountDir (repository, _cur_resfile_name, uio_FSTYPE_ZIP,
+						fontDirHandle, fontZipName, "/", autoMount,
+						uio_MOUNT_RDONLY | uio_MOUNT_TOP,
+						NULL);
+		uio_closeDir (fontDirHandle);
+	}
+
 	fontDir = CaptureDirEntryTable (LoadDirEntryTable (contentDir,
-			_cur_resfile_name, ".", match_MATCH_SUBSTRING, &numDirEntries));
+			_cur_resfile_name, ".", match_MATCH_SUBSTRING));
 	if (fontDir == 0)
 		goto err;
+	numDirEntries = GetDirEntryTableCount (fontDir);
 
 	fontDirHandle = uio_openDirRelative (contentDir, _cur_resfile_name, 0);
 	if (fontDirHandle == NULL)
@@ -579,6 +681,8 @@ _GetFontData (uio_Stream *fp, DWORD leng
 	}
 	uio_closeDir (fontDirHandle);
 	DestroyDirEntryTable (ReleaseDirEntryTable (fontDir));
+	if (fontMount != 0)
+		uio_unmountDir(fontMount);
 
 #if 0
 	if (numBCDs == 0)
@@ -589,15 +693,10 @@ _GetFontData (uio_Stream *fp, DWORD leng
 	qsort (bcds, numBCDs, sizeof (BuildCharDesc),
 			(int (*)(const void *, const void *)) compareBCDIndex);
 
-	fontRef = AllocFont (0);
-	if (fontRef == 0)
-		goto err;
-
-	fontPtr = LockFont (fontRef);
+	fontPtr = AllocFont (0);
 	if (fontPtr == NULL)
 		goto err;
 	
-	fontPtr->FontRef = fontRef;
 	fontPtr->Leading = 0;
 	fontPtr->LeadingWidth = 0;
 
@@ -660,17 +759,16 @@ _GetFontData (uio_Stream *fp, DWORD leng
 	}
 
 	fontPtr->Leading++;
-	UnlockFont (fontRef);
 
 	HFree (bcds);
 
 	(void) fp;  /* Satisfying compiler (unused parameter) */
 	(void) length;  /* Satisfying compiler (unused parameter) */
-	return fontRef;
+	return fontPtr;
 
 err:
-	if (fontRef != 0)
-		mem_release (fontRef);
+	if (fontPtr != 0)
+		HFree (fontPtr);
 	
 	if (bcds != NULL)
 	{
@@ -685,13 +783,17 @@ err:
 	
 	if (fontDir != 0)
 		DestroyDirEntryTable (ReleaseDirEntryTable (fontDir));
+
+	if (fontMount != 0)
+		uio_unmountDir(fontMount);
+
 	return 0;
 }
 
 BOOLEAN
-_ReleaseFontData (MEM_HANDLE handle)
+_ReleaseFontData (void *handle)
 {
-	FONTPTR font = LockFont (handle);
+	FONT font = (FONT) handle;
 	if (font == NULL)
 		return FALSE;
 
@@ -719,8 +821,7 @@ _ReleaseFontData (MEM_HANDLE handle)
 		}
 	}
 
-	UnlockFont (handle);
-	mem_release (handle);
+	HFree (font);
 
 	return TRUE;
 }
@@ -738,43 +839,31 @@ _request_drawable (COUNT NumFrames, DRAW
 			);
 	if (Drawable)
 	{
-		DRAWABLEPTR DrawablePtr;
-
-		if ((DrawablePtr = LockDrawable (Drawable)) == 0)
-		{
-			FreeDrawable (Drawable);
-			Drawable = 0;
-		}
-		else
-		{
-			int imgw, imgh;
-			FRAMEPTR FramePtr;
+		int imgw, imgh;
+		FRAME FramePtr;
 
-			DrawablePtr->hDrawable = GetDrawableHandle (Drawable);
-			DrawablePtr->Flags = flags;
-			DrawablePtr->MaxIndex = NumFrames - 1;
+		Drawable->Flags = flags;
+		Drawable->MaxIndex = NumFrames - 1;
 
-			imgw = width;
-			imgh = height;
+		imgw = width;
+		imgh = height;
 			
-			FramePtr = &DrawablePtr->Frame[NumFrames - 1];
-			while (NumFrames--)
-			{
-				TFB_Image *Image;
-
-				if (DrawableType == RAM_DRAWABLE && imgw > 0 && imgh > 0
-						&& (Image = TFB_DrawImage_New (TFB_DrawCanvas_New_TrueColor (
-							imgw, imgh, (flags & WANT_ALPHA) ? TRUE : FALSE))))
-				{
-					FramePtr->image = Image;
-				}
+		FramePtr = &Drawable->Frame[NumFrames - 1];
+		while (NumFrames--)
+		{
+			TFB_Image *Image;
 
-				FramePtr->Type = DrawableType;
-				FramePtr->Index = NumFrames;
-				SetFrameBounds (FramePtr, width, height);
-				--FramePtr;
+			if (DrawableType == RAM_DRAWABLE && imgw > 0 && imgh > 0
+					&& (Image = TFB_DrawImage_New (TFB_DrawCanvas_New_TrueColor (
+						imgw, imgh, (flags & WANT_ALPHA) ? TRUE : FALSE))))
+			{
+				FramePtr->image = Image;
 			}
-			UnlockDrawable (Drawable);
+
+			FramePtr->Type = DrawableType;
+			FramePtr->Index = NumFrames;
+			SetFrameBounds (FramePtr, width, height);
+			--FramePtr;
 		}
 	}
 
diff -ruNp src.orig/sc2code/libs/graphics/sdl/bbox.c src/sc2code/libs/graphics/sdl/bbox.c
--- src.orig/sc2code/libs/graphics/sdl/bbox.c	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/graphics/sdl/bbox.c	2017-11-08 16:49:57 -0600
@@ -105,7 +105,7 @@ TFB_BBox_RegisterPoint (int x, int y)
 }
 
 void
-TFB_BBox_RegisterRect (PRECT r)
+TFB_BBox_RegisterRect (RECT *r)
 {
 	TFB_BBox_RegisterPoint (r->corner.x, r->corner.y);
 	TFB_BBox_RegisterPoint (r->corner.x + r->extent.width, r->corner.y + r->extent.height);
diff -ruNp src.orig/sc2code/libs/graphics/sdl/bbox.h src/sc2code/libs/graphics/sdl/bbox.h
--- src.orig/sc2code/libs/graphics/sdl/bbox.h	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/graphics/sdl/bbox.h	2017-11-08 16:49:57 -0600
@@ -37,7 +37,7 @@ typedef struct {
 extern TFB_BoundingBox TFB_BBox;
 
 void TFB_BBox_RegisterPoint (int x, int y);
-void TFB_BBox_RegisterRect (PRECT r);
+void TFB_BBox_RegisterRect (RECT *r);
 void TFB_BBox_RegisterCanvas (TFB_Canvas c, int x, int y);
 
 void TFB_BBox_Reset (void);
diff -ruNp src.orig/sc2code/libs/graphics/sdl/canvas.c src/sc2code/libs/graphics/sdl/canvas.c
--- src.orig/sc2code/libs/graphics/sdl/canvas.c	2017-11-08 16:49:29 -0600
+++ src/sc2code/libs/graphics/sdl/canvas.c	2017-11-08 16:49:57 -0600
@@ -55,7 +55,7 @@ TFB_DrawCanvas_Line (int x1, int y1, int
 }
 
 void
-TFB_DrawCanvas_Rect (PRECT rect, int r, int g, int b, TFB_Canvas target)
+TFB_DrawCanvas_Rect (RECT *rect, int r, int g, int b, TFB_Canvas target)
 {
 	SDL_Surface *dst = target;
 	SDL_PixelFormat *fmt = dst->format;
@@ -105,18 +105,18 @@ TFB_DrawCanvas_Image (TFB_Image *img, in
 
 	if (scale != 0 && scale != GSCALE_IDENTITY)
 	{
-		int type;
-		if (optMeleeScale == TFB_SCALE_TRILINEAR && img->MipmapImg)
+		int type = GetGraphicScaleMode ();
+
+		if (type == TFB_SCALE_TRILINEAR && img->MipmapImg)
 		{
-			type = TFB_SCALE_TRILINEAR;
 			// only set the new palette if it changed
 			if (((SDL_Surface *)img->MipmapImg)->format->palette
 					&& cmap && img->colormap_version != cmap->version)
 				SDL_SetColors (img->MipmapImg, (SDL_Color*)palette, 0, 256);
 		}
-		else
+		else if (type == TFB_SCALE_TRILINEAR && !img->MipmapImg)
 		{
-			type = TFB_SCALE_NEAREST;
+			type = TFB_SCALE_BILINEAR;
 		}
 
 		TFB_DrawImage_FixScaling (img, scale, type);
@@ -244,8 +244,7 @@ TFB_DrawCanvas_FilledImage (TFB_Image *i
 	SDL_Rect srcRect, targetRect, *pSrcRect;
 	SDL_Surface *surf;
 	int i;
-	SDL_Color pal[256];
-	EXTENT prevextent = img->extent;
+	bool force_fill = false;
 
 	if (img == 0)
 	{
@@ -257,7 +256,16 @@ TFB_DrawCanvas_FilledImage (TFB_Image *i
 
 	if (scale != 0 && scale != GSCALE_IDENTITY)
 	{
-		TFB_DrawImage_FixScaling (img, scale, TFB_SCALE_NEAREST);
+		int type = GetGraphicScaleMode ();
+
+		if (type == TFB_SCALE_TRILINEAR)
+			type = TFB_SCALE_BILINEAR;
+					// no point in trilinear for filled images
+
+		if (scale != img->last_scale || type != img->last_scale_type)
+			force_fill = true;
+
+		TFB_DrawImage_FixScaling (img, scale, type);
 		surf = img->ScaledImg;
 		srcRect.x = 0;
 		srcRect.y = 0;
@@ -270,6 +278,14 @@ TFB_DrawCanvas_FilledImage (TFB_Image *i
 	}
 	else
 	{
+		if (img->last_scale != 0)
+		{
+			// Make sure we remember that the last fill was from
+			// an unscaled image
+			force_fill = true;
+			img->last_scale = 0;
+		}
+
 		surf = img->NormalImg;
 		pSrcRect = NULL;
 		
@@ -279,6 +295,14 @@ TFB_DrawCanvas_FilledImage (TFB_Image *i
 
 	if (surf->format->palette)
 	{	// set palette for fill-stamp
+		// Calling SDL_SetColors() results in an expensive src -> dst
+		// color-mapping operation for an SDL blit, following the call.
+		// We want to avoid that as much as possible.
+		
+		// TODO: generate a 32bpp filled image?
+
+		SDL_Color pal[256];
+
 		for (i = 0; i < 256; i++)
 		{
 			pal[i].r = r;
@@ -291,42 +315,44 @@ TFB_DrawCanvas_FilledImage (TFB_Image *i
 	}
 	else
 	{	// fill the non-transparent parts of the image with fillcolor
-		SDL_Surface *src = img->NormalImg;
 		SDL_Surface *newfill = img->FilledImg;
-		BOOLEAN force = FALSE;
+
+		if (newfill && (newfill->w < surf->w || newfill->h < surf->h))
+		{
+			TFB_DrawCanvas_Delete (newfill);
+			newfill = NULL;
+		}
 
 		// prepare the filled image
 		if (!newfill)
 		{
 			newfill = SDL_CreateRGBSurface (SDL_SWSURFACE,
-						src->w, src->h,
+						surf->w, surf->h,
 						surf->format->BitsPerPixel,
 						surf->format->Rmask,
 						surf->format->Gmask,
 						surf->format->Bmask,
 						surf->format->Amask);
-			force = TRUE;
+			force_fill = true;
 		}
 
-		if (force ||
-				prevextent.height != img->extent.height ||
-				prevextent.width != img->extent.width ||
+		if (force_fill ||
 				img->last_fill.r != r ||
 				img->last_fill.g != g ||
 				img->last_fill.b != b)
 		{	// image or fillcolor changed - regenerate
-			TFB_DrawCanvas_Fill (surf, img->extent.width, img->extent.height,
+			TFB_DrawCanvas_Fill (surf, surf->w, surf->h,
 					SDL_MapRGBA (newfill->format, r, g, b, 0), newfill);
 					// important to keep alpha=0 in fillcolor
 					// -- we process alpha ourselves
+
+			// cache filled image if possible
+			img->last_fill.r = r;
+			img->last_fill.g = g;
+			img->last_fill.b = b;
 		}
 
-		// cache filled image if possible
-		img->last_fill.r = r;
-		img->last_fill.g = g;
-		img->last_fill.b = b;
 		img->FilledImg = newfill;
-
 		surf = newfill;
 	}
 
@@ -486,48 +512,41 @@ TFB_DrawCanvas_New_ScaleTarget (TFB_Canv
 {
 	SDL_Surface *src = (SDL_Surface *)canvas;
 	SDL_Surface *old = (SDL_Surface *)oldcanvas;
-	SDL_Surface *newsurf = old;
+	SDL_Surface *newsurf = NULL;
+
+	// For the purposes of this function, bilinear == trilinear
+	if (type == TFB_SCALE_TRILINEAR)
+		type = TFB_SCALE_BILINEAR;
+	if (last_type == TFB_SCALE_TRILINEAR)
+		last_type = TFB_SCALE_BILINEAR;
+
+	if (old && type != last_type)
+	{
+		TFB_DrawCanvas_Delete (old);
+		old = NULL;
+	}
+	if (old)
+		return old; /* can just reuse the old one */
 
 	if (type == TFB_SCALE_NEAREST)
 	{
-		if (old && type != last_type)
-		{
-			TFB_DrawCanvas_Delete (old);
-			old = NULL;
-		}
-		if (!old)
-		{
-			newsurf = SDL_CreateRGBSurface (SDL_SWSURFACE, src->w,
-						src->h,
-						src->format->BitsPerPixel,
-						src->format->Rmask,
-						src->format->Gmask,
-						src->format->Bmask,
-						src->format->Amask);
-			if (src->format->palette)
-				TFB_DrawCanvas_SetTransparentIndex (newsurf, TFB_DrawCanvas_GetTransparentIndex (src), FALSE);
-			else
-			{
-				int r, g, b;
-				if (TFB_DrawCanvas_GetTransparentColor (src, &r, &g, &b))
-					TFB_DrawCanvas_SetTransparentColor (newsurf, r, g, b, FALSE);
-			}
-		}
+		newsurf = SDL_CreateRGBSurface (SDL_SWSURFACE, src->w,
+					src->h,
+					src->format->BitsPerPixel,
+					src->format->Rmask,
+					src->format->Gmask,
+					src->format->Bmask,
+					src->format->Amask);
+		TFB_DrawCanvas_CopyTransparencyInfo (src, newsurf);
 	}
 	else
 	{
-		if (old && type != last_type)
-		{
-			TFB_DrawCanvas_Delete (old);
-			old = NULL;
-		}
-		if (!old)
-		{
-			if (SDL_Screen->format->BitsPerPixel == 32)
-				newsurf = TFB_DrawCanvas_New_ForScreen (src->w, src->h, TRUE);
-			else
-				newsurf = TFB_DrawCanvas_New_TrueColor (src->w, src->h, TRUE);
-		}
+		// The scaled image may in fact be larger by 1 pixel than the source
+		// because of hotspot alignment and fractional edge pixels
+		if (SDL_Screen->format->BitsPerPixel == 32)
+			newsurf = TFB_DrawCanvas_New_ForScreen (src->w + 1, src->h + 1, TRUE);
+		else
+			newsurf = TFB_DrawCanvas_New_TrueColor (src->w + 1, src->h + 1, TRUE);
 	}
 		
 	return newsurf;
@@ -556,14 +575,7 @@ TFB_DrawCanvas_New_RotationTarget (TFB_C
 				SDL_GetError());
 		exit (EXIT_FAILURE);
 	}
-	if (src->format->palette)
-		TFB_DrawCanvas_SetTransparentIndex (newsurf, TFB_DrawCanvas_GetTransparentIndex (src), FALSE);
-	else
-	{
-		int r, g, b;
-		if (TFB_DrawCanvas_GetTransparentColor (src, &r, &g, &b))
-			TFB_DrawCanvas_SetTransparentColor (newsurf, r, g, b, FALSE);
-	}
+	TFB_DrawCanvas_CopyTransparencyInfo (src, newsurf);
 	
 	return newsurf;
 }
@@ -672,6 +684,25 @@ TFB_DrawCanvas_SetTransparentIndex (TFB_
 	}		
 }
 
+void
+TFB_DrawCanvas_CopyTransparencyInfo (TFB_Canvas src_canvas, TFB_Canvas dst_canvas)
+{
+	SDL_Surface* src = (SDL_Surface*)src_canvas;
+
+	if (src->format->palette)
+	{
+		int index;
+		index = TFB_DrawCanvas_GetTransparentIndex (src_canvas);
+		TFB_DrawCanvas_SetTransparentIndex (dst_canvas, index, FALSE);
+	}
+	else
+	{
+		int r, g, b;
+		if (TFB_DrawCanvas_GetTransparentColor (src_canvas, &r, &g, &b))
+			TFB_DrawCanvas_SetTransparentColor (dst_canvas, r, g, b, FALSE);
+	}
+}
+
 BOOLEAN
 TFB_DrawCanvas_GetTransparentColor (TFB_Canvas canvas, int *r, int *g, int *b)
 {
@@ -707,39 +738,68 @@ TFB_DrawCanvas_SetTransparentColor (TFB_
 }
 
 void
-TFB_DrawCanvas_GetScaledExtent (TFB_Canvas src_canvas, HOT_SPOT src_hs,
-		TFB_Canvas src_mipmap, HOT_SPOT mm_hs,
-		int scale, PEXTENT size, HOT_SPOT *hs)
+TFB_DrawCanvas_GetScaledExtent (TFB_Canvas src_canvas, HOT_SPOT* src_hs,
+		TFB_Canvas src_mipmap, HOT_SPOT* mm_hs,
+		int scale, int type, EXTENT *size, HOT_SPOT *hs)
 {
 	SDL_Surface *src = (SDL_Surface *)src_canvas;
+	sint32 x, y, w, h;
+	int frac;
 	
 	if (!src_mipmap)
 	{
-		size->width  = src->w * scale / GSCALE_IDENTITY;
-		size->height = src->h * scale / GSCALE_IDENTITY;
-
-		hs->x = src_hs.x * scale / GSCALE_IDENTITY;
-		hs->y = src_hs.y * scale / GSCALE_IDENTITY;
+		w = src->w * scale;
+		h = src->h * scale;
+		x = src_hs->x * scale;
+		y = src_hs->y * scale;
 	}
 	else
 	{
 		// interpolates extents between src and mipmap to get smoother
 		// transition when surface changes
 		SDL_Surface *mipmap = (SDL_Surface *)src_mipmap;
+		int ratio = scale * 2 - GSCALE_IDENTITY;
 
-		float ratio = (scale / (float)GSCALE_IDENTITY) * 2.0f - 1.0f;
-		if (ratio < 0.0f)
-			ratio = 0.0f;
-		else if (ratio > 1.0f)
-			ratio = 1.0f;
+		assert (scale >= GSCALE_IDENTITY / 2);
 
-		size->width = (int)((src->w - mipmap->w) * ratio + mipmap->w + 0.5);
-		size->height = (int)((src->h - mipmap->h) * ratio + mipmap->h + 0.5);
+		w = mipmap->w * GSCALE_IDENTITY + (src->w - mipmap->w) * ratio;
+		h = mipmap->h * GSCALE_IDENTITY + (src->h - mipmap->h) * ratio;
 
-		hs->x = (int)((src_hs.x - mm_hs.x) * ratio + mm_hs.x + 0.5);
-		hs->y = (int)((src_hs.y - mm_hs.y) * ratio + mm_hs.y + 0.5);
+		// Seems it is better to use mipmap hotspot because some
+		// source and mipmap images have the same dimensions!
+		x = mm_hs->x * GSCALE_IDENTITY + (src_hs->x - mm_hs->x) * ratio;
+		y = mm_hs->y * GSCALE_IDENTITY + (src_hs->y - mm_hs->y) * ratio;
 	}
-		
+
+	if (type != TFB_SCALE_NEAREST)
+	{
+		// align hotspot on an whole pixel
+		if (x & (GSCALE_IDENTITY - 1))
+		{
+			frac = GSCALE_IDENTITY - (x & (GSCALE_IDENTITY - 1));
+			x += frac;
+			w += frac;
+		}
+		if (y & (GSCALE_IDENTITY - 1))
+		{
+			frac = GSCALE_IDENTITY - (y & (GSCALE_IDENTITY - 1));
+			y += frac;
+			h += frac;
+		}
+		// pad the extent to accomodate fractional edge pixels
+		w += (GSCALE_IDENTITY - 1);
+		h += (GSCALE_IDENTITY - 1);
+	}
+
+	size->width = w / GSCALE_IDENTITY;
+	size->height = h / GSCALE_IDENTITY;
+	hs->x = x / GSCALE_IDENTITY;
+	hs->y = y / GSCALE_IDENTITY;
+
+	// Scaled image can be larger than the source by 1 pixel
+	// because of hotspot alignment and fractional edge pixels
+	assert (size->width <= src->w + 1 && size->height <= src->h + 1);
+
 	if (!size->width && src->w)
 		size->width = 1;
 	if (!size->height && src->h)
@@ -747,7 +807,7 @@ TFB_DrawCanvas_GetScaledExtent (TFB_Canv
 }
 
 void
-TFB_DrawCanvas_GetExtent (TFB_Canvas canvas, PEXTENT size)
+TFB_DrawCanvas_GetExtent (TFB_Canvas canvas, EXTENT *size)
 {
 	SDL_Surface *src = (SDL_Surface *)canvas;
 
@@ -756,57 +816,48 @@ TFB_DrawCanvas_GetExtent (TFB_Canvas can
 }
 
 void
-TFB_DrawCanvas_Rescale_Nearest (TFB_Canvas src_canvas, TFB_Canvas dest_canvas, EXTENT size)
+TFB_DrawCanvas_Rescale_Nearest (TFB_Canvas src_canvas, TFB_Canvas dst_canvas,
+		int scale, HOT_SPOT* src_hs, EXTENT* size, HOT_SPOT* dst_hs)
 {
-#define NNS_MAX_DIMS 600	
 	SDL_Surface *src = (SDL_Surface *)src_canvas;
-	SDL_Surface *dst = (SDL_Surface *)dest_canvas;
-	int x, y, sx, sy, *csax, *csay, csx, csy;
-	int saspace[NNS_MAX_DIMS];
-	int *sax, *say;
+	SDL_Surface *dst = (SDL_Surface *)dst_canvas;
+	int x, y;
+	int fsx = 0, fsy = 0; // source fractional dx and dy increments
+	int ssx = 0, ssy = 0; // source fractional x and y starting points
+	int w, h;
 
-	if (size.width + size.height > NNS_MAX_DIMS)
+	if (scale > 0)
 	{
-		log_add (log_Warning, "TFB_DrawCanvas_Scale: Tried to zoom"
-				" an image to unreasonable size! Failing.");
-		return;
+		TFB_DrawCanvas_GetScaledExtent (src, src_hs, NULL, NULL, scale,
+				TFB_SCALE_NEAREST, size, dst_hs);
+
+		w = size->width;
+		h = size->height;
 	}
-	if (size.width > dst->w || size.height > dst->h) 
+	else
 	{
-		log_add (log_Warning, "TFB_DrawCanvas_Scale: Tried to scale"
+		// Just go with the dst surface dimensions
+		w = dst->w;
+		h = dst->h;
+	}
+
+	if (w > dst->w || h > dst->h) 
+	{
+		log_add (log_Warning, "TFB_DrawCanvas_Rescale_Nearest: Tried to scale"
 				" image to size %d %d when dest_canvas has only"
 				" dimensions of %d %d! Failing.",
-				size.width, size.height, dst->w, dst->h);
+				w, h, dst->w, dst->h);
 		return;
 	}
 
-	sx = sy = 0;
-	if (size.width  > 1)
-		sx = ((src->w - 1) << 16) / (size.width  - 1);
-	if (size.height > 1)
-		sy = ((src->h - 1) << 16) / (size.height - 1);
-
-	sax = saspace;
-	say = saspace + size.width;
-	/*
-	 * Precalculate row increments 
-	 * We start with a value in 0..0.5 range to shift the bigger
-	 * jumps towards the center of the image
-	 */
-	csax = sax;
-	for (x = 0, csx = 0x6000; x < size.width; x++) {
-		*csax = csx >> 16;
-		csax++;
-		csx &= 0xffff;
-		csx += sx;
-	}
-	csay = say;
-	for (y = 0, csy = 0x6000; y < size.height; y++) {
-		*csay = csy >> 16;
-		csay++;
-		csy &= 0xffff;
-		csy += sy;
-	}
+	if (w > 1)
+		fsx = ((src->w - 1) << 16) / (w - 1);
+	if (h > 1)
+		fsy = ((src->h - 1) << 16) / (h - 1);
+	// We start with a value in 0..0.5 range to shift the bigger
+	// jumps towards the center of the image
+	ssx = 0x6000;
+	ssy = 0x6000;
 
 	SDL_LockSurface (src);
 	SDL_LockSurface (dst);
@@ -814,29 +865,33 @@ TFB_DrawCanvas_Rescale_Nearest (TFB_Canv
 	if (src->format->BytesPerPixel == 1 && dst->format->BytesPerPixel == 1)
 	{
 		Uint8 *sp, *csp, *dp, *cdp;
+		int sx, sy; // source fractional x and y positions
 
 		sp = csp = (Uint8 *) src->pixels;
 		dp = cdp = (Uint8 *) dst->pixels;
 
-		csay = say;
-		for (y = 0; y < size.height; ++y) {
-			csp += (*csay) * src->pitch;
+		for (y = 0, sy = ssy; y < h; ++y)
+		{
+			csp += (sy >> 16) * src->pitch;
 			sp = csp;
 			dp = cdp;
-			csax = sax;
-			for (x = 0; x < size.width; ++x) {
-				sp += *csax;
+			for (x = 0, sx = ssx; x < w; ++x)
+			{
+				sp += (sx >> 16);
 				*dp = *sp;
-				++csax;
+				sx &= 0xffff;
+				sx += fsx;
 				++dp;
 			}
-			++csay;
+			sy &= 0xffff;
+			sy += fsy;
 			cdp += dst->pitch;
 		}
 	}	
 	else if (src->format->BytesPerPixel == 4 && dst->format->BytesPerPixel == 4)
 	{
 		Uint32 *sp, *csp, *dp, *cdp;
+		int sx, sy; // source fractional x and y positions
 		int sgap, dgap;
 
 		sgap = src->pitch >> 2;
@@ -845,19 +900,21 @@ TFB_DrawCanvas_Rescale_Nearest (TFB_Canv
 		sp = csp = (Uint32 *) src->pixels;
 		dp = cdp = (Uint32 *) dst->pixels;
 
-		csay = say;
-		for (y = 0; y < size.height; ++y) {
-			csp += (*csay) * sgap;
+		for (y = 0, sy = ssy; y < h; ++y)
+		{
+			csp += (sy >> 16) * sgap;
 			sp = csp;
 			dp = cdp;
-			csax = sax;
-			for (x = 0; x < size.width; ++x) {
-				sp += *csax;
+			for (x = 0, sx = ssx; x < w; ++x)
+			{
+				sp += (sx >> 16);
 				*dp = *sp;
-				++csax;
+				sx &= 0xffff;
+				sx += fsx;
 				++dp;
 			}
-			++csay;
+			sy &= 0xffff;
+			sy += fsy;
 			cdp += dgap;
 		}
 	}
@@ -913,7 +970,7 @@ blend_ratio_2 (Uint8 c1, Uint8 c2, int r
 }
 
 static inline Uint32
-tri_get_pixel (void* ppix, SDL_PixelFormat *fmt, SDL_Color *pal,
+scale_read_pixel (void* ppix, SDL_PixelFormat *fmt, SDL_Color *pal,
 				Uint32 mask, Uint32 key)
 {
 	pixel_t p;
@@ -956,29 +1013,40 @@ tri_get_pixel (void* ppix, SDL_PixelForm
 	return p.value;
 }
 
+static inline Uint32
+scale_get_pixel (SDL_Surface *src, Uint32 mask, Uint32 key, int x, int y)
+{
+	SDL_Color *pal = src->format->palette? src->format->palette->colors : 0;
+
+	if (x < 0 || x >= src->w || y < 0 || y >= src->h)
+		return 0;
+
+	return scale_read_pixel ((Uint8*)src->pixels + y * src->pitch +
+			x * src->format->BytesPerPixel, src->format, pal, mask, key);
+}
+
 void
-TFB_DrawCanvas_Rescale_Trilinear (TFB_Canvas src_canvas,
-		TFB_Canvas dest_canvas, TFB_Canvas src_mipmap, EXTENT size)
+TFB_DrawCanvas_Rescale_Trilinear (TFB_Canvas src_canvas, TFB_Canvas src_mipmap,
+		TFB_Canvas dst_canvas, int scale, HOT_SPOT* src_hs, HOT_SPOT* mm_hs,
+		EXTENT* size, HOT_SPOT* dst_hs)
 {
 	SDL_Surface *src = (SDL_Surface *)src_canvas;
-	SDL_Surface *dst = (SDL_Surface *)dest_canvas;
-	SDL_Surface *mipmap = (SDL_Surface *)src_mipmap;
+	SDL_Surface *dst = (SDL_Surface *)dst_canvas;
+	SDL_Surface *mm = (SDL_Surface *)src_mipmap;
 	SDL_PixelFormat *srcfmt = src->format;
-	SDL_PixelFormat *mmfmt = mipmap->format;
+	SDL_PixelFormat *mmfmt = mm->format;
 	SDL_PixelFormat *dstfmt = dst->format;
 	SDL_Color *srcpal = srcfmt->palette? srcfmt->palette->colors : 0;
-	SDL_Color *mmpal = mmfmt->palette ? mmfmt->palette->colors : 0;
 	const int sbpp = srcfmt->BytesPerPixel;
 	const int mmbpp = mmfmt->BytesPerPixel;
 	const int slen = src->pitch;
-	const int mmlen = mipmap->pitch;
+	const int mmlen = mm->pitch;
 	const int dst_has_alpha = (dstfmt->Amask != 0);
 	const int transparent = (dst->flags & SDL_SRCCOLORKEY) ?
 			dstfmt->colorkey : 0;
-	const int w = size.width, h = size.height;
 	const int alpha_threshold = dst_has_alpha ? 0 : 127;
 	// src v. mipmap importance factor
-	int ratio;
+	int ratio = scale * 2 - GSCALE_IDENTITY;
 	// source masks and keys
 	Uint32 mk0 = 0, ck0 = ~0, mk1 = 0, ck1 = ~0;
 	// source fractional x and y positions
@@ -987,36 +1055,74 @@ TFB_DrawCanvas_Rescale_Trilinear (TFB_Ca
 	int fsx0 = 0, fsy0 = 0, fsx1 = 0, fsy1 = 0;
 	// source fractional x and y starting points
 	int ssx0 = 0, ssy0 = 0, ssx1 = 0, ssy1 = 0;
-	int x, y;
+	int x, y, w, h;
 
-	fsx0 = (src->w << 16) / w;
-	fsy0 = (src->h << 16) / h;
+	if (mmfmt->palette && !srcpal) 
+	{
+		log_add (log_Warning, "TFB_DrawCanvas_Rescale_Trilinear: "
+				"Mipmap is paletted, but source is not! Failing.");
+		return;
+	}
 
-	if (w > 1)
-		fsx1 = ((mipmap->w - 1) << 16) / (w - 1);
-	if (h > 1)
-		fsy1 = ((mipmap->h - 1) << 16) / (h - 1);
+	if (scale > 0)
+	{
+		int fw, fh;
 
-	// give equal importance to both edges
-	ssx0 = (((src->w - 1) << 16) - fsx0 * (w - 1)) >> 1;
-	ssy0 = (((src->h - 1) << 16) - fsy0 * (h - 1)) >> 1;
+		// Use (scale / GSCALE_IDENTITY) sizing factor
+		TFB_DrawCanvas_GetScaledExtent (src, src_hs, mm, mm_hs, scale,
+				TFB_SCALE_TRILINEAR, size, dst_hs);
+
+		w = size->width;
+		h = size->height;
+
+		fw = mm->w * GSCALE_IDENTITY + (src->w - mm->w) * ratio;
+		fh = mm->h * GSCALE_IDENTITY + (src->h - mm->h) * ratio;
+
+		// This limits the effective source dimensions to 2048x2048,
+		// and we also lose 4 bits of precision out of 16 (no problem)
+		fsx0 = (src->w << 20) / fw;
+		fsx0 <<= 4;
+		fsy0 = (src->h << 20) / fh;
+		fsy0 <<= 4;
+
+		fsx1 = (mm->w << 20) / fw;
+		fsx1 <<= 4;
+		fsy1 = (mm->h << 20) / fh;
+		fsy1 <<= 4;
+
+		// position the hotspots directly over each other
+		ssx0 = (src_hs->x << 16) - fsx0 * dst_hs->x;
+		ssy0 = (src_hs->y << 16) - fsy0 * dst_hs->y;
 
-	ssx1 = (((mipmap->w - 1) << 16) - fsx1 * (w - 1)) >> 1;
-	ssy1 = (((mipmap->h - 1) << 16) - fsy1 * (h - 1)) >> 1;
+		ssx1 = (mm_hs->x << 16) - fsx1 * dst_hs->x;
+		ssy1 = (mm_hs->y << 16) - fsy1 * dst_hs->y;
+	}
+	else
+	{
+		// Just go with the dst surface dimensions
+		w = dst->w;
+		h = dst->h;
 
-	// src v. mipmap importance factor
-	ratio = (w << 9) / src->w - 256;
-	if (ratio < 0)
-		ratio = 0;
-	if (ratio > 256)
-		ratio = 256;
+		fsx0 = (src->w << 16) / w;
+		fsy0 = (src->h << 16) / h;
 
-	if (size.width > dst->w || size.height > dst->h) 
+		fsx1 = (mm->w << 16) / w;
+		fsy1 = (mm->h << 16) / h;
+
+		// give equal importance to both edges
+		ssx0 = (((src->w - 1) << 16) - fsx0 * (w - 1)) >> 1;
+		ssy0 = (((src->h - 1) << 16) - fsy0 * (h - 1)) >> 1;
+
+		ssx1 = (((mm->w - 1) << 16) - fsx1 * (w - 1)) >> 1;
+		ssy1 = (((mm->h - 1) << 16) - fsy1 * (h - 1)) >> 1;
+	}
+
+	if (w > dst->w || h > dst->h) 
 	{
 		log_add (log_Warning, "TFB_DrawCanvas_Rescale_Trilinear: "
 				"Tried to scale image to size %d %d when dest_canvas"
 				" has only dimensions of %d %d! Failing.",
-				size.width, size.height, dst->w, dst->h);
+				w, h, dst->w, dst->h);
 		return;
 	}
 
@@ -1048,7 +1154,7 @@ TFB_DrawCanvas_Rescale_Trilinear (TFB_Ca
 		mk1 = mmfmt->Amask;
 		ck1 = 0;
 	}
-	else if (mipmap->flags & SDL_SRCCOLORKEY)
+	else if (mm->flags & SDL_SRCCOLORKEY)
 	{	// colorkey transparency
 		mk1 = ~mmfmt->Amask;
 		ck1 = mmfmt->colorkey & mk1;
@@ -1056,15 +1162,17 @@ TFB_DrawCanvas_Rescale_Trilinear (TFB_Ca
 
 	SDL_LockSurface(src);
 	SDL_LockSurface(dst);
-	SDL_LockSurface(mipmap);
+	SDL_LockSurface(mm);
 	
 	for (y = 0, sy0 = ssy0, sy1 = ssy1;
 			y < h;
 			++y, sy0 += fsy0, sy1 += fsy1)
 	{
 		Uint32 *dst_p = (Uint32 *) ((Uint8*)dst->pixels + y * dst->pitch);
-		Uint8 *src_a0 = (Uint8*)src->pixels + (sy0 >> 16) * slen;
-		Uint8 *src_a1 = (Uint8*)mipmap->pixels + (sy1 >> 16) * mmlen;
+		const int py0 = (sy0 >> 16);
+		const int py1 = (sy1 >> 16);
+		Uint8 *src_a0 = (Uint8*)src->pixels + py0 * slen;
+		Uint8 *src_a1 = (Uint8*)mm->pixels + py1 * mmlen;
 		// retrieve the fractional portions of y
 		const Uint8 v0 = (sy0 >> 8) & 0xff;
 		const Uint8 v1 = (sy1 >> 8) & 0xff;
@@ -1074,8 +1182,8 @@ TFB_DrawCanvas_Rescale_Trilinear (TFB_Ca
 				x < w;
 				++x, ++dst_p, sx0 += fsx0, sx1 += fsx1)
 		{
-			Uint8 *src_p0 = src_a0 + (sx0 >> 16) * sbpp;
-			Uint8 *src_p1 = src_a1 + (sx1 >> 16) * mmbpp;
+			const int px0 = (sx0 >> 16);
+			const int px1 = (sx1 >> 16);
 			// retrieve the fractional portions of x
 			const Uint8 u0 = (sx0 >> 8) & 0xff;
 			const Uint8 u1 = (sx1 >> 8) & 0xff;
@@ -1092,81 +1200,58 @@ TFB_DrawCanvas_Rescale_Trilinear (TFB_Ca
 			w0[1] = btable[u0][255 - v0];
 			w0[2] = btable[255 - u0][v0];
 			w0[3] = btable[u0][v0];
+			
 			w1[0] = btable[255 - u1][255 - v1];
 			w1[1] = btable[u1][255 - v1];
 			w1[2] = btable[255 - u1][v1];
 			w1[3] = btable[u1][v1];
 
-			// collect interesting pixels from src image
-			p0[0].value = tri_get_pixel (src_p0, srcfmt, srcpal, mk0, ck0);
+			// Collect interesting pixels from src image
+			// Optimization: speed is criticial on larger images;
+			// most pixel reads fall completely inside the image
+			if (px0 >= 0 && px0 + 1 < src->w && py0 >= 0 && py0 + 1 < src->h)
+			{
+				Uint8 *src_p = src_a0 + px0 * sbpp;
 
-			if ((sx0 >> 16) <= src->w - 2)
-			{						
-				p0[1].value = tri_get_pixel (src_p0 + sbpp,
-						srcfmt, srcpal, mk0, ck0);
-				
-				if ((sy0 >> 16) <= src->h - 2)
-				{
-					p0[2].value = tri_get_pixel (src_p0 + slen,
-							srcfmt, srcpal, mk0, ck0);
-					p0[3].value = tri_get_pixel (src_p0 + slen + sbpp,
-							srcfmt, srcpal, mk0, ck0);
-				}
-				else
-				{
-					p0[2].value = p0[0].value;
-					p0[3].value = p0[1].value;
-				}
+				p0[0].value = scale_read_pixel (src_p, srcfmt,
+						srcpal, mk0, ck0);
+				p0[1].value = scale_read_pixel (src_p + sbpp, srcfmt,
+						srcpal, mk0, ck0);
+				p0[2].value = scale_read_pixel (src_p + slen, srcfmt,
+						srcpal, mk0, ck0);
+				p0[3].value = scale_read_pixel (src_p + sbpp + slen, srcfmt,
+						srcpal, mk0, ck0);
 			}
 			else
 			{
-				p0[1].value = p0[0].value;
-				if ((sy0 >> 16) <= src->h - 2)
-				{
-					p0[2].value = tri_get_pixel (src_p0 + slen,
-							srcfmt, srcpal, mk0, ck0);
-				}
-				else
-				{
-					p0[2].value = p0[0].value;
-				}
-				p0[3].value = p0[2].value;
+				p0[0].value = scale_get_pixel (src, mk0, ck0, px0, py0);
+				p0[1].value = scale_get_pixel (src, mk0, ck0, px0 + 1, py0);
+				p0[2].value = scale_get_pixel (src, mk0, ck0, px0, py0 + 1);
+				p0[3].value = scale_get_pixel (src, mk0, ck0,
+						px0 + 1, py0 + 1);
 			}
 
-			// collect interesting pixels from mipmap image
-			p1[0].value = tri_get_pixel (src_p1, mmfmt, mmpal, mk1, ck1);
-
-			if ((sx1 >> 16) <= mipmap->w - 2)
-			{						
-				p1[1].value = tri_get_pixel (src_p1 + mmbpp,
-						mmfmt, mmpal, mk1, ck1);
+			// Collect interesting pixels from mipmap image
+			if (px1 >= 0 && px1 + 1 < mm->w && py1 >= 0 && py1 + 1 < mm->h)
+			{
+				Uint8 *mm_p = src_a1 + px1 * mmbpp;
 
-				if ((sy1 >> 16) <= mipmap->h - 2)
-				{
-					p1[2].value = tri_get_pixel (src_p1 + mmlen,
-							mmfmt, mmpal, mk1, ck1);
-					p1[3].value = tri_get_pixel (src_p1 + mmlen + mmbpp,
-							mmfmt, mmpal, mk1, ck1);
-				}
-				else
-				{
-					p1[2].value = p1[0].value;
-					p1[3].value = p1[1].value;
-				}
+				p1[0].value = scale_read_pixel (mm_p, mmfmt,
+						srcpal, mk1, ck1);
+				p1[1].value = scale_read_pixel (mm_p + mmbpp, mmfmt,
+						srcpal, mk1, ck1);
+				p1[2].value = scale_read_pixel (mm_p + mmlen, mmfmt,
+						srcpal, mk1, ck1);
+				p1[3].value = scale_read_pixel (mm_p + mmbpp + mmlen, mmfmt,
+						srcpal, mk1, ck1);
 			}
 			else
 			{
-				p1[1].value = p1[0].value;
-				if ((sy1 >> 16) <= mipmap->h - 2)
-				{
-					p1[2].value = tri_get_pixel (src_p1 + mmlen,
-							mmfmt, mmpal, mk1, ck1);
-				}
-				else
-				{
-					p1[2].value = p1[0].value;
-				}
-				p1[3].value = p1[2].value;
+				p1[0].value = scale_get_pixel (mm, mk1, ck1, px1, py1);
+				p1[1].value = scale_get_pixel (mm, mk1, ck1, px1 + 1, py1);
+				p1[2].value = scale_get_pixel (mm, mk1, ck1, px1, py1 + 1);
+				p1[3].value = scale_get_pixel (mm, mk1, ck1,
+						px1 + 1, py1 + 1);
 			}
 
 			p0[4].c.a = dot_product_8_4 (p0, 3, w0);
@@ -1192,6 +1277,9 @@ TFB_DrawCanvas_Rescale_Trilinear (TFB_Ca
 				p0[4].c.g = blend_ratio_2 (p0[4].c.g, p1[4].c.g, ratio);
 				p0[4].c.b = blend_ratio_2 (p0[4].c.b, p1[4].c.b, ratio);
 
+				// TODO: we should handle alpha-blending here, but we do
+				//   not know the destination color for blending!
+
 				*dst_p =
 					(p0[4].c.r << dstfmt->Rshift) |
 					(p0[4].c.g << dstfmt->Gshift) |
@@ -1251,12 +1339,215 @@ TFB_DrawCanvas_Rescale_Trilinear (TFB_Ca
 		}
 	}
 
-	SDL_UnlockSurface(mipmap);
+	SDL_UnlockSurface(mm);
 	SDL_UnlockSurface(dst);
 	SDL_UnlockSurface(src);
 }
 
 void
+TFB_DrawCanvas_Rescale_Bilinear (TFB_Canvas src_canvas, TFB_Canvas dst_canvas,
+		int scale, HOT_SPOT* src_hs, EXTENT* size, HOT_SPOT* dst_hs)
+{
+	SDL_Surface *src = (SDL_Surface *)src_canvas;
+	SDL_Surface *dst = (SDL_Surface *)dst_canvas;
+	SDL_PixelFormat *srcfmt = src->format;
+	SDL_PixelFormat *dstfmt = dst->format;
+	SDL_Color *srcpal = srcfmt->palette? srcfmt->palette->colors : 0;
+	const int sbpp = srcfmt->BytesPerPixel;
+	const int slen = src->pitch;
+	const int dst_has_alpha = (dstfmt->Amask != 0);
+	const int transparent = (dst->flags & SDL_SRCCOLORKEY) ?
+			dstfmt->colorkey : 0;
+	const int alpha_threshold = dst_has_alpha ? 0 : 127;
+	// source masks and keys
+	Uint32 mk = 0, ck = ~0;
+	// source fractional x and y positions
+	int sx, sy;
+	// source fractional dx and dy increments
+	int fsx = 0, fsy = 0;
+	// source fractional x and y starting points
+	int ssx = 0, ssy = 0;
+	int x, y, w, h;
+
+	if (scale > 0)
+	{
+		// Use (scale / GSCALE_IDENTITY) sizing factor
+		TFB_DrawCanvas_GetScaledExtent (src, src_hs, NULL, NULL, scale,
+				TFB_SCALE_BILINEAR, size, dst_hs);
+
+		w = size->width;
+		h = size->height;
+		fsx = (GSCALE_IDENTITY << 16) / scale;
+		fsy = (GSCALE_IDENTITY << 16) / scale;
+
+		// position the hotspots directly over each other
+		ssx = (src_hs->x << 16) - fsx * dst_hs->x;
+		ssy = (src_hs->y << 16) - fsy * dst_hs->y;
+	}
+	else
+	{
+		// Just go with the dst surface dimensions
+		w = dst->w;
+		h = dst->h;
+		fsx = (src->w << 16) / w;
+		fsy = (src->h << 16) / h;
+
+		// give equal importance to both edges
+		ssx = (((src->w - 1) << 16) - fsx * (w - 1)) >> 1;
+		ssy = (((src->h - 1) << 16) - fsy * (h - 1)) >> 1;
+	}
+
+	if (w > dst->w || h > dst->h) 
+	{
+		log_add (log_Warning, "TFB_DrawCanvas_Rescale_Bilinear: "
+				"Tried to scale image to size %d %d when dest_canvas"
+				" has only dimensions of %d %d! Failing.",
+				w, h, dst->w, dst->h);
+		return;
+	}
+
+	if ((srcfmt->BytesPerPixel != 1 && srcfmt->BytesPerPixel != 4) ||
+		(dst->format->BytesPerPixel != 4))
+	{
+		log_add (log_Warning, "TFB_DrawCanvas_Rescale_Bilinear: "
+				"Tried to deal with unknown BPP: %d -> %d",
+				srcfmt->BitsPerPixel, dst->format->BitsPerPixel);
+		return;
+	}
+
+	// use colorkeys where appropriate
+	if (srcfmt->Amask)
+	{	// alpha transparency
+		mk = srcfmt->Amask;
+		ck = 0;
+	}
+	else if (src->flags & SDL_SRCCOLORKEY)
+	{	// colorkey transparency
+		mk = ~srcfmt->Amask;
+		ck = srcfmt->colorkey & mk;
+	}
+
+	SDL_LockSurface(src);
+	SDL_LockSurface(dst);
+	
+	for (y = 0, sy = ssy; y < h; ++y, sy += fsy)
+	{
+		Uint32 *dst_p = (Uint32 *) ((Uint8*)dst->pixels + y * dst->pitch);
+		const int py = (sy >> 16);
+		Uint8 *src_a = (Uint8*)src->pixels + py * slen;
+		// retrieve the fractional portions of y
+		const Uint8 v = (sy >> 8) & 0xff;
+		Uint8 weight[4]; // pixel weight vectors
+
+		for (x = 0, sx = ssx; x < w; ++x, ++dst_p, sx += fsx)
+		{
+			const int px = (sx >> 16);
+			// retrieve the fractional portions of x
+			const Uint8 u = (sx >> 8) & 0xff;
+			// pixels are examined and numbered in pattern
+			//  0  1
+			//  2  3
+			// the ideal pixel (4) is somewhere between these four
+			// and is calculated from these using weight vector (weight)
+			// with a dot product
+			pixel_t p[5];
+			
+			weight[0] = btable[255 - u][255 - v];
+			weight[1] = btable[u][255 - v];
+			weight[2] = btable[255 - u][v];
+			weight[3] = btable[u][v];
+
+			// Collect interesting pixels from src image
+			// Optimization: speed is criticial on larger images;
+			// most pixel reads fall completely inside the image
+			if (px >= 0 && px + 1 < src->w && py >= 0 && py + 1 < src->h)
+			{
+				Uint8 *src_p = src_a + px * sbpp;
+
+				p[0].value = scale_read_pixel (src_p, srcfmt, srcpal, mk, ck);
+				p[1].value = scale_read_pixel (src_p + sbpp, srcfmt,
+						srcpal, mk, ck);
+				p[2].value = scale_read_pixel (src_p + slen, srcfmt,
+						srcpal, mk, ck);
+				p[3].value = scale_read_pixel (src_p + sbpp + slen, srcfmt,
+						srcpal, mk, ck);
+			}
+			else
+			{
+				p[0].value = scale_get_pixel (src, mk, ck, px, py);
+				p[1].value = scale_get_pixel (src, mk, ck, px + 1, py);
+				p[2].value = scale_get_pixel (src, mk, ck, px, py + 1);
+				p[3].value = scale_get_pixel (src, mk, ck, px + 1, py + 1);
+			}
+
+			p[4].c.a = dot_product_8_4 (p, 3, weight);
+			
+			if (p[4].c.a <= alpha_threshold)
+			{
+				*dst_p = transparent;
+			}
+			else if (!dst_has_alpha)
+			{	// RGB surface handling
+				p[4].c.r = dot_product_8_4 (p, 0, weight);
+				p[4].c.g = dot_product_8_4 (p, 1, weight);
+				p[4].c.b = dot_product_8_4 (p, 2, weight);
+
+				// TODO: we should handle alpha-blending here, but we do
+				//   not know the destination color for blending!
+
+				*dst_p =
+					(p[4].c.r << dstfmt->Rshift) |
+					(p[4].c.g << dstfmt->Gshift) |
+					(p[4].c.b << dstfmt->Bshift);
+			}
+			else
+			{	// RGBA surface handling
+
+				// we do not want to blend with non-present pixels
+				// (pixels that have alpha == 0) as these will
+				// skew the result and make resulting alpha useless
+				int i;
+				for (i = 0; i < 4; ++i)
+					if (p[i].c.a == 0)
+						weight[i] = 0;
+
+				p[4].c.r = weight_product_8_4 (p, 0, weight);
+				p[4].c.g = weight_product_8_4 (p, 1, weight);
+				p[4].c.b = weight_product_8_4 (p, 2, weight);
+
+				// error-correct alpha to fully opaque to remove
+				// the often unwanted and unnecessary blending
+				if (p[4].c.a > 0xf8)
+					p[4].c.a = 0xff;
+
+				*dst_p =
+					(p[4].c.r << dstfmt->Rshift) |
+					(p[4].c.g << dstfmt->Gshift) |
+					(p[4].c.b << dstfmt->Bshift) |
+					(p[4].c.a << dstfmt->Ashift);
+			}
+		}
+	}
+
+	SDL_UnlockSurface(dst);
+	SDL_UnlockSurface(src);
+}
+
+void
+TFB_DrawCanvas_Lock (TFB_Canvas canvas)
+{
+	SDL_Surface *surf = (SDL_Surface *)canvas;
+	SDL_LockSurface (surf);
+}
+
+void
+TFB_DrawCanvas_Unlock (TFB_Canvas canvas)
+{
+	SDL_Surface *surf = (SDL_Surface *)canvas;
+	SDL_UnlockSurface (surf);
+}
+
+void
 TFB_DrawCanvas_GetScreenFormat (TFB_PixelFormat *fmt)
 {
 	SDL_PixelFormat *sdl = SDL_Screen->format;
@@ -1282,11 +1573,18 @@ TFB_DrawCanvas_GetScreenFormat (TFB_Pixe
 	}
 }
 
+int
+TFB_DrawCanvas_GetStride (TFB_Canvas canvas)
+{
+	SDL_Surface *surf = (SDL_Surface *)canvas;
+	return surf->pitch;
+}
+
 void*
 TFB_DrawCanvas_GetLine (TFB_Canvas canvas, int line)
 {
-	SDL_Surface* surf = (SDL_Surface *)canvas;
-	return (uint8*)surf->pixels + surf->pitch * line;
+	SDL_Surface *surf = (SDL_Surface *)canvas;
+	return (uint8 *)surf->pixels + surf->pitch * line;
 }
 
 void
@@ -1338,7 +1636,7 @@ TFB_DrawCanvas_Rotate (TFB_Canvas src_ca
 }
 
 void
-TFB_DrawCanvas_GetRotatedExtent (TFB_Canvas src_canvas, int angle, PEXTENT size)
+TFB_DrawCanvas_GetRotatedExtent (TFB_Canvas src_canvas, int angle, EXTENT *size)
 {
 	int dstw, dsth;
 	SDL_Surface *src = (SDL_Surface *)src_canvas;
@@ -1347,3 +1645,4 @@ TFB_DrawCanvas_GetRotatedExtent (TFB_Can
 	size->height = dsth;
 	size->width = dstw;
 }
+
diff -ruNp src.orig/sc2code/libs/graphics/sdl/opengl.c src/sc2code/libs/graphics/sdl/opengl.c
--- src.orig/sc2code/libs/graphics/sdl/opengl.c	2017-11-08 16:49:30 -0600
+++ src/sc2code/libs/graphics/sdl/opengl.c	2017-11-08 16:49:57 -0600
@@ -21,6 +21,7 @@
 #include "libs/graphics/sdl/opengl.h"
 #include "bbox.h"
 #include "scalers.h"
+#include "options.h"
 #include "libs/log.h"
 
 typedef struct _gl_screeninfo {
@@ -160,7 +161,7 @@ AttemptColorDepth (int flags, int width,
 }
 
 int
-TFB_GL_ConfigureVideo (int driver, int flags, int width, int height)
+TFB_GL_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen)
 {
 	int i, texture_width, texture_height;
 	GraphicsDriver = driver;
@@ -172,56 +173,62 @@ TFB_GL_ConfigureVideo (int driver, int f
 		log_add (log_Error, "Couldn't set any OpenGL %ix%i video mode!",
 			 width, height);
 		return -1;
-	}		
-
-	if (format_conv_surf)
-		SDL_FreeSurface (format_conv_surf);
-	format_conv_surf = SDL_CreateRGBSurface (SDL_SWSURFACE, 0, 0, 32,
-		R_MASK, G_MASK, B_MASK, A_MASK);
-	if (format_conv_surf == NULL)
-	{
-		log_add (log_Error, "Couldn't create format_conv_surf: %s",
-				SDL_GetError());
-		return -1;
 	}
 
-	for (i = 0; i < TFB_GFX_NUMSCREENS; i++)
+	if (!togglefullscreen)
 	{
-		if (0 != ReInit_Screen (&SDL_Screens[i], format_conv_surf,
-				ScreenWidth, ScreenHeight))
+		if (format_conv_surf)
+			SDL_FreeSurface (format_conv_surf);
+		format_conv_surf = SDL_CreateRGBSurface (SDL_SWSURFACE, 0, 0, 32,
+			R_MASK, G_MASK, B_MASK, A_MASK);
+		if (format_conv_surf == NULL)
+		{
+			log_add (log_Error, "Couldn't create format_conv_surf: %s",
+					SDL_GetError());
 			return -1;
-	}
-
-	SDL_Screen = SDL_Screens[0];
-	TransitionScreen = SDL_Screens[2];
+		}
 
-	if (first_init)
-	{
 		for (i = 0; i < TFB_GFX_NUMSCREENS; i++)
 		{
-			GL_Screens[i].scaled = NULL;
-			GL_Screens[i].dirty = TRUE;
-			GL_Screens[i].active = TRUE;
+			if (0 != ReInit_Screen (&SDL_Screens[i], format_conv_surf,
+					ScreenWidth, ScreenHeight))
+				return -1;
+		}
+
+		SDL_Screen = SDL_Screens[0];
+		TransitionScreen = SDL_Screens[2];
+
+		if (first_init)
+		{
+			for (i = 0; i < TFB_GFX_NUMSCREENS; i++)
+			{
+				GL_Screens[i].scaled = NULL;
+				GL_Screens[i].dirty = TRUE;
+				GL_Screens[i].active = TRUE;
+			}
+			GL_Screens[1].active = FALSE;
+			first_init = FALSE;
 		}
-		GL_Screens[1].active = FALSE;
-		first_init = FALSE;
 	}
 
 	if (GfxFlags & TFB_GFXFLAGS_SCALE_SOFT_ONLY)
 	{
-		for (i = 0; i < TFB_GFX_NUMSCREENS; i++)
+		if (!togglefullscreen)
 		{
-			if (!GL_Screens[i].active)
-				continue;
-			if (0 != ReInit_Screen (&GL_Screens[i].scaled, format_conv_surf,
-					ScreenWidth * 2, ScreenHeight * 2))
-			return -1;
+			for (i = 0; i < TFB_GFX_NUMSCREENS; i++)
+			{
+				if (!GL_Screens[i].active)
+					continue;
+				if (0 != ReInit_Screen (&GL_Screens[i].scaled, format_conv_surf,
+						ScreenWidth * 2, ScreenHeight * 2))
+				return -1;
+			}
+			scaler = Scale_PrepPlatform (flags, SDL_Screen->format);
 		}
 
 		texture_width = 1024;
 		texture_height = 512;
 
-		scaler = Scale_PrepPlatform (flags, SDL_Screen->format);
 		graphics_backend = &opengl_scaled_backend;
 	}
 	else
@@ -233,6 +240,7 @@ TFB_GL_ConfigureVideo (int driver, int f
 		graphics_backend = &opengl_unscaled_backend;
 	}
 
+
 	if (GfxFlags & TFB_GFXFLAGS_SCALE_ANY)
 		ScreenFilterMode = GL_LINEAR;
 	else
@@ -277,7 +285,7 @@ TFB_GL_InitGraphics (int driver, int fla
 	ScreenWidth = 320;
 	ScreenHeight = 240;
 
-	if (TFB_GL_ConfigureVideo (driver, flags, width, height))
+	if (TFB_GL_ConfigureVideo (driver, flags, width, height, 0))
 	{
 		log_add (log_Fatal, "Could not initialize video: "
 				"no fallback at start of program!");
@@ -330,28 +338,77 @@ TFB_GL_ScanLines (void)
 static void
 TFB_GL_DrawQuad (SDL_Rect *r)
 {
-	if (r != NULL)
+	BOOLEAN keep_aspect_ratio = optKeepAspectRatio;
+	int x1 = 0, y1 = 0, x2 = ScreenWidthActual, y2 = ScreenHeightActual;
+	int sx, sy, sw, sh;
+	float sx_multiplier, sy_multiplier;
+
+	if (keep_aspect_ratio)
 	{
-		float scale_x = (ScreenWidthActual / (float)ScreenWidth);
-		float scale_y = (ScreenHeightActual / (float)ScreenHeight);
+		float threshold = 0.75f;
+		float ratio = ScreenHeightActual / (float)ScreenWidthActual;
 
-		glScissor (
-			(GLint) (r->x * scale_x),
-			(GLint) ((ScreenHeight - (r->y + r->h)) * scale_y),
-			(GLsizei) (r->w * scale_x),
-			(GLsizei) (r->h * scale_y)
-		);		
+		if (ratio > threshold)
+		{
+			// screen is narrower than 4:3
+			int height = (int)(ScreenWidthActual * threshold);
+			y1 = (ScreenHeightActual - height) / 2;
+			y2 = ScreenHeightActual - y1;
+
+			if (r != NULL)
+			{
+				sx_multiplier = ScreenWidthActual / (float)ScreenWidth;
+				sy_multiplier = height / (float)ScreenHeight;
+				sx = (int)(r->x * sx_multiplier);
+				sy = (int)(((ScreenHeight - (r->y + r->h)) * sy_multiplier) + y1);
+			}
+		}
+		else if (ratio < threshold)
+		{
+			// screen is wider than 4:3
+			int width = (int)(ScreenHeightActual / threshold);
+			x1 = (ScreenWidthActual - width) / 2;
+			x2 = ScreenWidthActual - x1;
+
+			if (r != NULL)
+			{
+				sx_multiplier = width / (float)ScreenWidth;
+				sy_multiplier = ScreenHeightActual / (float)ScreenHeight;
+				sx = (int)((r->x * sx_multiplier) + x1);
+				sy = (int)((ScreenHeight - (r->y + r->h)) * sy_multiplier);
+			}
+		}
+		else
+		{
+			// screen is 4:3
+			keep_aspect_ratio = 0;
+		}
+	}
+
+	if (r != NULL)
+	{
+		if (!keep_aspect_ratio)
+		{
+			sx_multiplier = ScreenWidthActual / (float)ScreenWidth;
+			sy_multiplier = ScreenHeightActual / (float)ScreenHeight;
+			sx = (int)(r->x * sx_multiplier);
+			sy = (int)((ScreenHeight - (r->y + r->h)) * sy_multiplier);
+		}
+		sw = (int)(r->w * sx_multiplier);
+		sh = (int)(r->h * sy_multiplier);
+		glScissor (sx, sy, sw, sh);
 		glEnable (GL_SCISSOR_TEST);
 	}
+	
 	glBegin (GL_TRIANGLE_FAN);
 	glTexCoord2f (0, 0);
-	glVertex2i (0, 0);
+	glVertex2i (x1, y1);
 	glTexCoord2f (ScreenWidth / 512.0f, 0);
-	glVertex2i (ScreenWidthActual, 0);	
+	glVertex2i (x2, y1);	
 	glTexCoord2f (ScreenWidth / 512.0f, ScreenHeight / 256.0f);
-	glVertex2i (ScreenWidthActual, ScreenHeightActual);
+	glVertex2i (x2, y2);
 	glTexCoord2f (0, ScreenHeight / 256.0f);
-	glVertex2i (0, ScreenHeightActual);
+	glVertex2i (x1, y2);
 	glEnd ();
 	if (r != NULL)
 	{
@@ -367,10 +424,21 @@ TFB_GL_Preprocess (int force_full_redraw
 	glOrtho (0,ScreenWidthActual,ScreenHeightActual, 0, -1, 1);
 	glMatrixMode (GL_MODELVIEW);
 	glLoadIdentity ();
-	(void) force_full_redraw;
+	if (optKeepAspectRatio)
+		glClear (GL_COLOR_BUFFER_BIT);
+
 	(void) transition_amount;
 	(void) fade_amount;
-	if (TFB_BBox.valid)
+
+	if (force_full_redraw == TFB_REDRAW_YES)
+	{
+		GL_Screens[TFB_SCREEN_MAIN].updated.x = 0;
+		GL_Screens[TFB_SCREEN_MAIN].updated.y = 0;
+		GL_Screens[TFB_SCREEN_MAIN].updated.w = ScreenWidth;
+		GL_Screens[TFB_SCREEN_MAIN].updated.h = ScreenHeight;
+		GL_Screens[TFB_SCREEN_MAIN].dirty = TRUE;
+	}
+	else if (TFB_BBox.valid)
 	{
 		GL_Screens[TFB_SCREEN_MAIN].updated.x = TFB_BBox.region.corner.x;
 		GL_Screens[TFB_SCREEN_MAIN].updated.y = TFB_BBox.region.corner.y;
@@ -388,7 +456,8 @@ TFB_GL_Unscaled_ScreenLayer (SCREEN scre
 
 	if (GL_Screens[screen].dirty)
 	{
-		glPixelStorei (GL_UNPACK_ROW_LENGTH, ScreenWidth);
+		int PitchWords = SDL_Screens[screen]->pitch / 4;
+		glPixelStorei (GL_UNPACK_ROW_LENGTH, PitchWords);
 		/* Matrox OpenGL drivers do not handle GL_UNPACK_SKIP_*
 		   correctly */
 		glPixelStorei (GL_UNPACK_SKIP_ROWS, 0);
@@ -400,7 +469,7 @@ TFB_GL_Unscaled_ScreenLayer (SCREEN scre
 				GL_Screens[screen].updated.h,
 				GL_RGBA, GL_UNSIGNED_BYTE,
 				(Uint32 *)SDL_Screens[screen]->pixels +
-					(GL_Screens[screen].updated.y * ScreenWidth + 
+					(GL_Screens[screen].updated.y * PitchWords + 
 					GL_Screens[screen].updated.x));
 		SDL_UnlockSurface (SDL_Screens[screen]);
 		GL_Screens[screen].dirty = FALSE;
@@ -434,8 +503,9 @@ TFB_GL_Scaled_ScreenLayer (SCREEN screen
 
 	if (GL_Screens[screen].dirty)
 	{
+		int PitchWords = GL_Screens[screen].scaled->pitch / 4;
 		scaler (SDL_Screens[screen], GL_Screens[screen].scaled, &GL_Screens[screen].updated);
-		glPixelStorei (GL_UNPACK_ROW_LENGTH, ScreenWidth * 2);
+		glPixelStorei (GL_UNPACK_ROW_LENGTH, PitchWords);
 
 		 /* Matrox OpenGL drivers do not handle GL_UNPACK_SKIP_*
 		    correctly */
@@ -448,7 +518,7 @@ TFB_GL_Scaled_ScreenLayer (SCREEN screen
 				GL_Screens[screen].updated.h * 2,
 				GL_RGBA, GL_UNSIGNED_BYTE,
 				(Uint32 *)GL_Screens[screen].scaled->pixels +
-				(GL_Screens[screen].updated.y * 4 * ScreenWidth + 
+				(GL_Screens[screen].updated.y * 2 * PitchWords + 
 				GL_Screens[screen].updated.x * 2));
 		SDL_UnlockSurface (GL_Screens[screen].scaled);
 		GL_Screens[screen].dirty = FALSE;
diff -ruNp src.orig/sc2code/libs/graphics/sdl/opengl.h src/sc2code/libs/graphics/sdl/opengl.h
--- src.orig/sc2code/libs/graphics/sdl/opengl.h	2017-11-08 16:49:30 -0600
+++ src/sc2code/libs/graphics/sdl/opengl.h	2017-11-08 16:49:57 -0600
@@ -22,7 +22,7 @@
 #include "libs/graphics/sdl/sdl_common.h"
 
 int TFB_GL_InitGraphics (int driver, int flags, int width, int height);
-int TFB_GL_ConfigureVideo (int driver, int flags, int width, int height);
+int TFB_GL_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen);
 void TFB_GL_UploadTransitionScreen (void);
 
 #ifdef HAVE_OPENGL
diff -ruNp src.orig/sc2code/libs/graphics/sdl/pure.c src/sc2code/libs/graphics/sdl/pure.c
--- src.orig/sc2code/libs/graphics/sdl/pure.c	2017-11-08 16:49:30 -0600
+++ src/sc2code/libs/graphics/sdl/pure.c	2017-11-08 16:49:57 -0600
@@ -74,7 +74,7 @@ ReInit_Screen (SDL_Surface **screen, SDL
 }
 
 int
-TFB_Pure_ConfigureVideo (int driver, int flags, int width, int height)
+TFB_Pure_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen)
 {
 	int i, videomode_flags;
 	SDL_Surface *temp_surf;
@@ -124,6 +124,9 @@ TFB_Pure_ConfigureVideo (int driver, int
 			SDL_GetVideoSurface()->w, SDL_GetVideoSurface()->h,
 			SDL_GetVideoSurface()->format->BitsPerPixel);
 		ScreenColorDepth = SDL_GetVideoSurface()->format->BitsPerPixel;
+		
+		if (togglefullscreen)
+			return 0;
 	}
 
 	// Create a 32bpp surface in a compatible format which will supply
@@ -210,7 +213,7 @@ TFB_Pure_InitGraphics (int driver, int f
 	ScreenWidth = 320;
 	ScreenHeight = 240;
 
-	if (TFB_Pure_ConfigureVideo (driver, flags, width, height))
+	if (TFB_Pure_ConfigureVideo (driver, flags, width, height, 0))
 	{
 		log_add (log_Fatal, "Could not initialize video: "
 				"no fallback at start of program!");
@@ -255,7 +258,7 @@ static SDL_Rect updated;
 static void
 TFB_Pure_Scaled_Preprocess (int force_full_redraw, int transition_amount, int fade_amount)
 {
-	if (force_full_redraw)
+	if (force_full_redraw != TFB_REDRAW_NO)
 	{
 		updated.x = updated.y = 0;
 		updated.w = ScreenWidth;
@@ -286,7 +289,7 @@ TFB_Pure_Scaled_Preprocess (int force_fu
 static void
 TFB_Pure_Unscaled_Preprocess (int force_full_redraw, int transition_amount, int fade_amount)
 {
-	if (force_full_redraw)
+	if (force_full_redraw != TFB_REDRAW_NO)
 	{
 		updated.x = updated.y = 0;
 		updated.w = ScreenWidth;
diff -ruNp src.orig/sc2code/libs/graphics/sdl/pure.h src/sc2code/libs/graphics/sdl/pure.h
--- src.orig/sc2code/libs/graphics/sdl/pure.h	2017-11-08 16:49:30 -0600
+++ src/sc2code/libs/graphics/sdl/pure.h	2017-11-08 16:49:57 -0600
@@ -22,6 +22,6 @@
 #include "libs/graphics/sdl/sdl_common.h"
 
 int TFB_Pure_InitGraphics (int driver, int flags, int width, int height);
-int TFB_Pure_ConfigureVideo (int driver, int flags, int width, int height);
+int TFB_Pure_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen);
 
 #endif
diff -ruNp src.orig/sc2code/libs/graphics/sdl/rndzoom.c src/sc2code/libs/graphics/sdl/rndzoom.c
--- src.orig/sc2code/libs/graphics/sdl/rndzoom.c	2017-11-08 16:49:30 -0600
+++ src/sc2code/libs/graphics/sdl/rndzoom.c	2017-11-08 16:49:57 -0600
@@ -531,7 +531,7 @@ void random16xZoomSurfaceRGBA (SDL_Surfa
 	blurSurface32 (dst);
 }
 
-FRAMEPTR scale16xRandomizeFrame (FRAMEPTR NewFrame, FRAMEPTR FramePtr)
+FRAME scale16xRandomizeFrame (FRAME NewFrame, FRAME FramePtr)
 {
 	TFB_Image *origImg, *newImg;
 	CREATE_FLAGS flags;
diff -ruNp src.orig/sc2code/libs/graphics/sdl/rotozoom.c src/sc2code/libs/graphics/sdl/rotozoom.c
--- src.orig/sc2code/libs/graphics/sdl/rotozoom.c	2017-11-08 16:49:30 -0600
+++ src/sc2code/libs/graphics/sdl/rotozoom.c	2017-11-08 16:49:57 -0600
@@ -19,6 +19,8 @@
 
 #define MAX(a,b)    (((a) > (b)) ? (a) : (b))
 
+
+
 /* 
  
  32bit Zoomer with optional anti-aliasing by bilinear interpolation.
@@ -54,12 +56,22 @@ int zoomSurfaceRGBA(SDL_Surface * src, S
     /*
      * Allocate memory for row increments 
      */
-    if ((sax = (int *) alloca((dst->w + 1) * sizeof(Uint32))) == NULL) {
-	return (-1);
-    }
-    if ((say = (int *) alloca((dst->h + 1) * sizeof(Uint32))) == NULL) {
-	return (-1);
-    }
+
+#ifndef __SYMBIAN32__     
+    if ((sax = (int *) alloca((dst->w + 1) * sizeof(Uint32))) == NULL)
+		return (-1);
+    if ((say = (int *) alloca((dst->h + 1) * sizeof(Uint32))) == NULL)
+		return (-1);
+#else
+    if ((sax = (int *) HMalloc((dst->w + 1) * sizeof(Uint32))) == NULL)
+		return (-1);
+    if ((say = (int *) HMalloc((dst->h + 1) * sizeof(Uint32))) == NULL)
+    {
+    	HFree(sax);
+		return (-1);	
+	}
+#endif
+
 
     /*
      * Precalculate row increments 
@@ -196,6 +208,11 @@ int zoomSurfaceRGBA(SDL_Surface * src, S
 
     }
 
+#ifdef __SYMBIAN32__
+	HFree(sax);
+	HFree(say);	
+#endif
+
     return (0);
 }
 
@@ -223,12 +240,20 @@ int zoomSurfaceY(SDL_Surface * src, SDL_
     /*
      * Allocate memory for row increments 
      */
-    if ((sax = (Uint32 *) alloca(dst->w * sizeof(Uint32))) == NULL) {
-	return (-1);
-    }
-    if ((say = (Uint32 *) alloca(dst->h * sizeof(Uint32))) == NULL) {
-	return (-1);
-    }
+#ifndef __SYMBIAN32__     
+    if ((sax = (Uint32 *) alloca(dst->w * sizeof(Uint32))) == NULL)
+		return (-1);
+    if ((say = (Uint32 *) alloca(dst->h * sizeof(Uint32))) == NULL)
+		return (-1);
+#else
+    if ((sax = (Uint32 *) HMalloc(dst->w * sizeof(Uint32))) == NULL)
+		return (-1);
+    if ((say = (Uint32 *) HMalloc(dst->h * sizeof(Uint32))) == NULL)
+    {
+    	HFree(sax);
+		return (-1);
+	}
+#endif    
 
     /*
      * Precalculate row increments 
@@ -303,6 +328,11 @@ int zoomSurfaceY(SDL_Surface * src, SDL_
 	dp += dgap;
     }
 
+#ifdef __SYMBIAN32__
+	HFree(sax);
+	HFree(say);	
+#endif
+
     return (0);
 }
 
diff -ruNp src.orig/sc2code/libs/graphics/sdl/sdl_common.c src/sc2code/libs/graphics/sdl/sdl_common.c
--- src.orig/sc2code/libs/graphics/sdl/sdl_common.c	2017-11-08 16:49:30 -0600
+++ src/sc2code/libs/graphics/sdl/sdl_common.c	2017-11-08 16:49:57 -0600
@@ -32,6 +32,7 @@
 #include "libs/uio.h"
 #include "libs/log.h"
 #include "controls.h"
+#include "vidlib.h"
 		// XXX: Should not be included from here.
 #include "uqmdebug.h"
 #include SDL_INCLUDE(SDL_thread.h)
@@ -50,8 +51,6 @@ static volatile BOOLEAN abortFlag = FALS
 
 int GfxFlags = 0;
 
-static TFB_Palette palette[256];
-
 TFB_GRAPHICS_BACKEND *graphics_backend = NULL;
 
 #define FPS_PERIOD 100
@@ -71,9 +70,20 @@ TFB_PreInit (void)
 			"%d.%d.%d)", SDL_Linked_Version ()->major,
 			SDL_Linked_Version ()->minor, SDL_Linked_Version ()->patch,
 			SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL);
+#if 0
+	if (SDL_Linked_Version ()->major != SDL_MAJOR_VERSION ||
+			SDL_Linked_Version ()->minor != SDL_MINOR_VERSION ||
+			SDL_Linked_Version ()->patch != SDL_PATCHLEVEL) {
+		log_add (log_Warning, "The used SDL library is not the same version "
+				"as the one used to compile The Ur-Quan Masters with! "
+				"If you experience any crashes, this would be an excellent "
+				"suspect.");
+	}
+#endif
+
 	if ((SDL_Init (SDL_INIT_VIDEO | SDL_INIT_NOPARACHUTE) == -1))
 	{
-		log_add (log_Fatal, "Could not initialize SDL: %s.", SDL_GetError());
+		log_add (log_Fatal, "Could not initialize SDL: %s.", SDL_GetError ());
 		exit (EXIT_FAILURE);
 	}
 }
@@ -82,24 +92,35 @@ int
 TFB_ReInitGraphics (int driver, int flags, int width, int height)
 {
 	int result;
+	int togglefullscreen = 0;
 	char caption[200];
 
+	if (GfxFlags == (flags ^ TFB_GFXFLAGS_FULLSCREEN) &&
+			driver == GraphicsDriver &&
+			width == ScreenWidthActual && height == ScreenHeightActual)
+	{
+		togglefullscreen = 1;
+	}
+
 	GfxFlags = flags;
 
 	if (driver == TFB_GFXDRIVER_SDL_OPENGL)
 	{
 #ifdef HAVE_OPENGL
-		result = TFB_GL_ConfigureVideo (driver, flags, width, height);
+		result = TFB_GL_ConfigureVideo (driver, flags, width, height,
+				togglefullscreen);
 #else
 		driver = TFB_GFXDRIVER_SDL_PURE;
 		log_add (log_Warning, "OpenGL support not compiled in,"
 				" so using pure SDL driver");
-		result = TFB_Pure_ConfigureVideo (driver, flags, width, height);
+		result = TFB_Pure_ConfigureVideo (driver, flags, width, height,
+				togglefullscreen);
 #endif
 	}
 	else
 	{
-		result = TFB_Pure_ConfigureVideo (driver, flags, width, height);
+		result = TFB_Pure_ConfigureVideo (driver, flags, width, height,
+				togglefullscreen);
 	}
 
 	sprintf (caption, "The Ur-Quan Masters v%d.%d.%d%s",
@@ -183,7 +204,7 @@ TFB_ProcessEvents ()
 		ProcessInputEvent (&Event);
 		/* Handle Graphics events. */
 		switch (Event.type) {
-			case SDL_ACTIVEEVENT:    /* Loose/gain visibility */
+			case SDL_ACTIVEEVENT:    /* Lose/gain visibility */
 				// TODO
 				break;
 			case SDL_QUIT:
@@ -194,17 +215,28 @@ TFB_ProcessEvents ()
 				// TODO
 				break;
 			case SDL_VIDEOEXPOSE:    /* Screen needs to be redrawn */
-				TFB_SwapBuffers (1);
+				TFB_SwapBuffers (TFB_REDRAW_EXPOSE);
 				break;
 			default:
 				break;
 		}
 	}
+
 	if (ImmediateInputState.menu[KEY_ABORT] || abortFlag)
 	{
 		log_showBox (false, false);
 		exit (EXIT_SUCCESS);
 	}
+	
+	if (ImmediateInputState.menu[KEY_FULLSCREEN])
+	{
+		int flags = GfxFlags ^ TFB_GFXFLAGS_FULLSCREEN;
+		FlushInput ();
+		TFB_ReInitGraphics (GraphicsDriver, flags, ScreenWidthActual,
+				ScreenHeightActual);
+		TFB_SwapBuffers (TFB_REDRAW_YES);
+	}
+
 #if defined(DEBUG) || defined(USE_DEBUG_KEY)
 	if (ImmediateInputState.menu[KEY_DEBUG])
 	{
@@ -218,7 +250,7 @@ static BOOLEAN system_box_active = 0;
 static SDL_Rect system_box;
 
 void
-SetSystemRect (PRECT r)
+SetSystemRect (RECT *r)
 {
 	system_box_active = TRUE;
 	system_box.x = r->corner.x;
@@ -242,21 +274,21 @@ TFB_SwapBuffers (int force_full_redraw)
 	fade_amount = FadeAmount;
 	transition_amount = TransitionAmount;
 
-	if (!force_full_redraw && !TFB_BBox.valid &&
+	if (force_full_redraw == TFB_REDRAW_NO && !TFB_BBox.valid &&
 			fade_amount == 255 && transition_amount == 255 &&
 			last_fade_amount == 255 && last_transition_amount == 255)
 		return;
 
-	if (fade_amount != 255 || transition_amount != 255 ||
-			last_fade_amount != 255 || last_transition_amount != 255)
-	{
-		force_full_redraw = 1;
-	}
+	if (force_full_redraw == TFB_REDRAW_NO &&
+			(fade_amount != 255 || transition_amount != 255 ||
+			last_fade_amount != 255 || last_transition_amount != 255))
+		force_full_redraw = TFB_REDRAW_FADING;
 
 	last_fade_amount = fade_amount;
 	last_transition_amount = transition_amount;	
 
-	graphics_backend->preprocess (force_full_redraw, transition_amount, fade_amount);
+	graphics_backend->preprocess (force_full_redraw, transition_amount,
+			fade_amount);
 	graphics_backend->screen (TFB_SCREEN_MAIN, 255, NULL);
 
 	if (transition_amount != 255)
@@ -287,7 +319,7 @@ TFB_SwapBuffers (int force_full_redraw)
 }
 
 /* Probably ought to clean this away at some point. */
-SDL_Surface* 
+SDL_Surface *
 TFB_DisplayFormatAlpha (SDL_Surface *surface)
 {
 	SDL_Surface* newsurf;
@@ -300,7 +332,7 @@ TFB_DisplayFormatAlpha (SDL_Surface *sur
 	else
 		dstfmt = SDL_Screen->format;
 
-	if (srcfmt->BytesPerPixel == dstfmt->BytesPerPixel && 
+	if (srcfmt->BytesPerPixel == dstfmt->BytesPerPixel &&
 			srcfmt->Rmask == dstfmt->Rmask &&
 			srcfmt->Gmask == dstfmt->Gmask &&
 			srcfmt->Bmask == dstfmt->Bmask &&
@@ -318,6 +350,14 @@ TFB_DisplayFormatAlpha (SDL_Surface *sur
 	return newsurf;
 }
 
+// This function should only be called from the graphics thread,
+// like from a TFB_DrawCommand_Callback command.
+TFB_Canvas
+TFB_GetScreenCanvas (SCREEN screen)
+{
+	return (TFB_Canvas) SDL_Screens[screen];
+}
+
 void TFB_BlitSurface (SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst,
 					  SDL_Rect *dstrect, int blend_numer, int blend_denom)
 {
@@ -355,32 +395,32 @@ void TFB_BlitSurface (SDL_Surface *src,
 
 		srcx = srcrect->x;
 		w = srcrect->w;
-		if(srcx < 0) 
+		if (srcx < 0) 
 		{
 			w += srcx;
 			dstrect->x -= srcx;
 			srcx = 0;
 		}
 		maxw = src->w - srcx;
-		if(maxw < w)
+		if (maxw < w)
 			w = maxw;
 
 		srcy = srcrect->y;
 		h = srcrect->h;
-		if(srcy < 0) 
+		if (srcy < 0) 
 		{
 			h += srcy;
 			dstrect->y -= srcy;
 			srcy = 0;
 		}
 		maxh = src->h - srcy;
-		if(maxh < h)
+		if (maxh < h)
 			h = maxh;
-
-	} 
-	else 
+	}
+	else
 	{
-		srcx = srcy = 0;
+		srcx = 0;
+		srcy = 0;
 		w = src->w;
 		h = src->h;
 	}
@@ -391,25 +431,25 @@ void TFB_BlitSurface (SDL_Surface *src,
 		int dx, dy;
 
 		dx = clip->x - dstrect->x;
-		if(dx > 0) 
+		if (dx > 0)
 		{
 			w -= dx;
 			dstrect->x += dx;
 			srcx += dx;
 		}
 		dx = dstrect->x + w - clip->x - clip->w;
-		if(dx > 0)
+		if (dx > 0)
 			w -= dx;
 
 		dy = clip->y - dstrect->y;
-		if(dy > 0) 
+		if (dy > 0)
 		{
 			h -= dy;
 			dstrect->y += dy;
 			srcy += dy;
 		}
 		dy = dstrect->y + h - clip->y - clip->h;
-		if(dy > 0)
+		if (dy > 0)
 			h -= dy;
 	}
 
@@ -584,7 +624,7 @@ TFB_ComputeFPS (void)
 }
 
 void
-TFB_FlushGraphics () // Only call from main thread!!
+TFB_FlushGraphics (void) // Only call from main thread!!
 {
 	int commands_handled;
 	BOOLEAN livelock_deterrence;
@@ -605,7 +645,8 @@ TFB_FlushGraphics () // Only call from m
 			(current_fade == 255 && last_fade != 255) ||
 			(current_transition == 255 && last_transition != 255))
 		{
-			TFB_SwapBuffers (1); // if fading, redraw every frame
+			TFB_SwapBuffers (TFB_REDRAW_FADING);
+					// if fading, redraw every frame
 		}
 		else
 		{
@@ -661,28 +702,10 @@ TFB_FlushGraphics () // Only call from m
 
 		switch (DC.Type)
 		{
-		case TFB_DRAWCOMMANDTYPE_SETPALETTE:
-			{
-				int index = DC.data.setpalette.index;
-				if (index < 0 || index > 255)
-				{
-					log_add (log_Debug, "DCQ panic: Tried to set palette #%i",
-							index);
-				}
-				else
-				{
-					palette[index].r = DC.data.setpalette.r & 0xFF;
-					palette[index].g = DC.data.setpalette.g & 0xFF;
-					palette[index].b = DC.data.setpalette.b & 0xFF;
-				}
-				break;
-			}
 		case TFB_DRAWCOMMANDTYPE_SETMIPMAP:
-			LockMutex (DC.data.setmipmap.image->mutex);
-			DC.data.setmipmap.image->MipmapImg = DC.data.setmipmap.mipmap;
-			DC.data.setmipmap.image->MipmapHs.x = DC.data.setmipmap.hotx;
-			DC.data.setmipmap.image->MipmapHs.y = DC.data.setmipmap.hoty;
-			UnlockMutex (DC.data.setmipmap.image->mutex);
+			TFB_DrawImage_SetMipmap (DC.data.setmipmap.image,
+					DC.data.setmipmap.mipmap,
+					DC.data.setmipmap.hotx, DC.data.setmipmap.hoty);
 			break;
 		case TFB_DRAWCOMMANDTYPE_IMAGE:
 			{
@@ -794,11 +817,11 @@ TFB_FlushGraphics () // Only call from m
 				r.y = TFB_BBox.clip.corner.y = DC.data.scissor.y;
 				r.w = TFB_BBox.clip.extent.width = DC.data.scissor.w;
 				r.h = TFB_BBox.clip.extent.height = DC.data.scissor.h;
-				SDL_SetClipRect(SDL_Screens[0], &r);
+				SDL_SetClipRect (SDL_Screens[0], &r);
 				break;
 			}
 		case TFB_DRAWCOMMANDTYPE_SCISSORDISABLE:
-			SDL_SetClipRect(SDL_Screens[0], NULL);
+			SDL_SetClipRect (SDL_Screens[0], NULL);
 			TFB_BBox.clip.corner.x = 0;
 			TFB_BBox.clip.corner.y = 0;
 			TFB_BBox.clip.extent.width = ScreenWidth;
@@ -824,7 +847,7 @@ TFB_FlushGraphics () // Only call from m
 
 				dest.x = 0;
 				dest.y = 0;
-				SDL_BlitSurface(SDL_Screens[DC.data.copytoimage.srcBuffer],
+				SDL_BlitSurface (SDL_Screens[DC.data.copytoimage.srcBuffer],
 						&src, DC_image->NormalImg, &dest);
 				UnlockMutex (DC_image->mutex);
 				break;
@@ -843,14 +866,14 @@ TFB_FlushGraphics () // Only call from m
 					TFB_BBox_RegisterPoint (src.x + src.w, src.y + src.h);
 				}
 
-				SDL_BlitSurface(SDL_Screens[DC.data.copy.srcBuffer], &src,
+				SDL_BlitSurface (SDL_Screens[DC.data.copy.srcBuffer], &src,
 						SDL_Screens[DC.data.copy.destBuffer], &dest);
 				break;
 			}
 		case TFB_DRAWCOMMANDTYPE_DELETEIMAGE:
 			{
 				TFB_Image *DC_image = (TFB_Image *)DC.data.deleteimage.image;
-				TFB_DrawImage_Delete(DC_image);
+				TFB_DrawImage_Delete (DC_image);
 				break;
 			}
 		case TFB_DRAWCOMMANDTYPE_DELETEDATA:
@@ -865,30 +888,37 @@ TFB_FlushGraphics () // Only call from m
 		case TFB_DRAWCOMMANDTYPE_REINITVIDEO:
 			{
 				int oldDriver = GraphicsDriver;
-				if (TFB_ReInitGraphics (DC.data.reinitvideo.driver, DC.data.reinitvideo.flags, 
-							DC.data.reinitvideo.width, DC.data.reinitvideo.height))
+				if (TFB_ReInitGraphics (DC.data.reinitvideo.driver,
+						DC.data.reinitvideo.flags,
+						DC.data.reinitvideo.width, DC.data.reinitvideo.height))
 				{
 					log_add (log_Error, "Could not provide requested mode: "
 							"reverting to last known driver.");
-					if (TFB_ReInitGraphics (oldDriver, DC.data.reinitvideo.flags,
-								DC.data.reinitvideo.width, DC.data.reinitvideo.height))
+					if (TFB_ReInitGraphics (oldDriver,
+							DC.data.reinitvideo.flags,
+							DC.data.reinitvideo.width,
+							DC.data.reinitvideo.height))
 					{
-						log_add (log_Fatal, "Couldn't reinit at that point either."
-								" Your video has been somehow tied in knots.");
+						log_add (log_Fatal,
+								"Couldn't reinit at that point either. "
+								"Your video has been somehow tied in knots.");
 						exit (EXIT_FAILURE);
 					}
 				}
 				break;
 			}
+		case TFB_DRAWCOMMANDTYPE_CALLBACK:
+			{
+				DC.data.callback.callback (DC.data.callback.arg);
+				break;
+			}
 		}
 	}
 	
 	if (livelock_deterrence)
-	{
 		Unlock_DCQ ();
-	}
 
-	TFB_SwapBuffers (0);
+	TFB_SwapBuffers (TFB_REDRAW_NO);
 	RenderedFrames++;
 	BroadcastCondVar (RenderingCond);
 }
diff -ruNp src.orig/sc2code/libs/graphics/sdl/sdl_common.h src/sc2code/libs/graphics/sdl/sdl_common.h
--- src.orig/sc2code/libs/graphics/sdl/sdl_common.h	2017-11-08 16:49:30 -0600
+++ src/sc2code/libs/graphics/sdl/sdl_common.h	2017-11-08 16:49:57 -0600
@@ -55,7 +55,7 @@ extern volatile int TransitionAmount;
 extern SDL_Rect TransitionClipRect;
 
 void ScreenOrigin (FRAME Display, COORD sx, COORD sy);
-void LoadDisplay (PDISPLAY_INTERFACE *pDisplay);
+void LoadDisplay (DISPLAY_INTERFACE **pDisplay);
 
 void TFB_SwapBuffers (int force_full_redraw);
 SDL_Surface* TFB_DisplayFormatAlpha (SDL_Surface *surface);
diff -ruNp src.orig/sc2code/libs/graphics/sdl/sdluio.c src/sc2code/libs/graphics/sdl/sdluio.c
--- src.orig/sc2code/libs/graphics/sdl/sdluio.c	2017-11-08 16:49:30 -0600
+++ src/sc2code/libs/graphics/sdl/sdluio.c	2017-11-08 16:49:57 -0600
@@ -125,7 +125,7 @@ sdluio_makeRWops (uio_Stream *stream) {
 	result->read = sdluio_read;
 	result->write = sdluio_write;
 	result->close = sdluio_close;
-	result->hidden.unknown.data1 = (void *) stream;
+	result->hidden.unknown.data1 = stream;
 	return result;
 }
 
diff -ruNp src.orig/sc2code/libs/graphics/tfb_draw.c src/sc2code/libs/graphics/tfb_draw.c
--- src.orig/sc2code/libs/graphics/tfb_draw.c	2017-11-08 16:49:30 -0600
+++ src/sc2code/libs/graphics/tfb_draw.c	2017-11-08 16:49:57 -0600
@@ -42,7 +42,7 @@ TFB_DrawScreen_Line (int x1, int y1, int
 }
 
 void
-TFB_DrawScreen_Rect (PRECT rect, int r, int g, int b, SCREEN dest)
+TFB_DrawScreen_Rect (RECT *rect, int r, int g, int b, SCREEN dest)
 {
 	RECT locRect;
 	TFB_DrawCommand DC;
@@ -66,20 +66,6 @@ TFB_DrawScreen_Rect (PRECT rect, int r,
 }
 
 void
-TFB_DrawScreen_SetPalette (int paletteIndex, int r, int g, int b)
-{
-	TFB_DrawCommand DC;
-
-	DC.Type = TFB_DRAWCOMMANDTYPE_SETPALETTE;
-	DC.data.setpalette.r = r;
-	DC.data.setpalette.g = g;
-	DC.data.setpalette.b = b;
-	DC.data.setpalette.index = paletteIndex;
-
-	TFB_EnqueueDrawCommand (&DC);
-}
-
-void
 TFB_DrawScreen_Image (TFB_Image *img, int x, int y, int scale,
 		TFB_ColorMap *cmap, SCREEN dest)
 {
@@ -132,7 +118,7 @@ TFB_DrawScreen_FontChar (TFB_Char *fontC
 }
 
 void
-TFB_DrawScreen_CopyToImage (TFB_Image *img, PRECT lpRect, SCREEN src)
+TFB_DrawScreen_CopyToImage (TFB_Image *img, RECT *lpRect, SCREEN src)
 {
 	TFB_DrawCommand DC;
 
@@ -148,7 +134,7 @@ TFB_DrawScreen_CopyToImage (TFB_Image *i
 }
 
 void
-TFB_DrawScreen_Copy (PRECT r, SCREEN src, SCREEN dest)
+TFB_DrawScreen_Copy (RECT *r, SCREEN src, SCREEN dest)
 {
 	RECT locRect;
 	TFB_DrawCommand DC;
@@ -173,6 +159,20 @@ TFB_DrawScreen_Copy (PRECT r, SCREEN src
 }
 
 void
+TFB_DrawScreen_SetMipmap (TFB_Image *img, TFB_Image *mmimg, int hotx, int hoty)
+{
+	TFB_DrawCommand DC;
+
+	DC.Type = TFB_DRAWCOMMANDTYPE_SETMIPMAP;
+	DC.data.setmipmap.image = img;
+	DC.data.setmipmap.mipmap = mmimg;
+	DC.data.setmipmap.hotx = hotx;
+	DC.data.setmipmap.hoty = hoty;
+
+	TFB_EnqueueDrawCommand (&DC);
+}
+
+void
 TFB_DrawScreen_DeleteImage (TFB_Image *img)
 {
 	if (img)
@@ -211,7 +211,7 @@ TFB_DrawScreen_WaitForSignal (void)
 	DrawCommand.data.sendsignal.sem = s;
 	Lock_DCQ (1);
 	TFB_BatchReset ();
-	TFB_EnqueueDrawCommand(&DrawCommand);
+	TFB_EnqueueDrawCommand (&DrawCommand);
 	Unlock_DCQ();
 	SetSemaphore (s);	
 }
@@ -225,6 +225,16 @@ TFB_DrawScreen_ReinitVideo (int driver,
 	DrawCommand.data.reinitvideo.flags = flags;
 	DrawCommand.data.reinitvideo.width = width;
 	DrawCommand.data.reinitvideo.height = height;
+	TFB_EnqueueDrawCommand (&DrawCommand);
+}
+
+void
+TFB_DrawScreen_Callback (void (*callback) (void *arg), void *arg)
+{
+	TFB_DrawCommand DrawCommand;
+	DrawCommand.Type = TFB_DRAWCOMMANDTYPE_CALLBACK;
+	DrawCommand.data.callback.callback = callback;
+	DrawCommand.data.callback.arg = arg;
 	TFB_EnqueueDrawCommand(&DrawCommand);
 }
 
@@ -239,7 +249,7 @@ TFB_DrawImage_Line (int x1, int y1, int
 }
 
 void
-TFB_DrawImage_Rect (PRECT rect, int r, int g, int b, TFB_Image *image)
+TFB_DrawImage_Rect (RECT *rect, int r, int g, int b, TFB_Image *image)
 {
 	LockMutex (image->mutex);
 	TFB_DrawCanvas_Rect (rect, r, g, b, image->NormalImg);
@@ -292,6 +302,7 @@ TFB_DrawImage_New (TFB_Canvas canvas)
 	img->MipmapHs = NullHs;
 	img->last_scale_hs = NullHs;
 	img->last_scale_type = -1;
+	img->last_scale = 0;
 	TFB_DrawCanvas_GetExtent (canvas, &img->extent);
 
 	img->Palette = TFB_DrawCanvas_ExtractPalette (canvas);
@@ -322,6 +333,7 @@ TFB_DrawImage_CreateForScreen (int w, in
 	img->MipmapHs = NullHs;
 	img->last_scale_hs = NullHs;
 	img->last_scale_type = -1;
+	img->last_scale = 0;
 	img->Palette = NULL;
 	img->extent.width = w;
 	img->extent.height = h;
@@ -360,6 +372,40 @@ TFB_DrawImage_New_Rotated (TFB_Image *im
 	return newimg;
 }
 
+void
+TFB_DrawImage_SetMipmap (TFB_Image *img, TFB_Image *mmimg, int hotx, int hoty)
+{
+	bool imgpal;
+	bool mmpal;
+
+	if (!img || !mmimg)
+		return;
+
+	LockMutex (img->mutex);
+	LockMutex (mmimg->mutex);
+	
+	// Either both images must be using the same colormap, or mipmap image
+	// must not be paletted. This restriction is due to the current
+	// implementation of fill-stamp, which replaces the palette with
+	// fill color.
+	imgpal = TFB_DrawCanvas_IsPaletted (img->NormalImg);
+	mmpal = TFB_DrawCanvas_IsPaletted (mmimg->NormalImg);
+	if (!mmpal || (mmpal && imgpal &&
+			img->colormap_index == mmimg->colormap_index))
+	{
+		img->MipmapImg = mmimg->NormalImg;
+		img->MipmapHs.x = hotx;
+		img->MipmapHs.y = hoty;
+	}
+	else
+	{
+		img->MipmapImg = NULL;
+	}
+
+	UnlockMutex (mmimg->mutex);
+	UnlockMutex (img->mutex);
+}
+
 void 
 TFB_DrawImage_Delete (TFB_Image *image)
 {
@@ -389,28 +435,30 @@ TFB_DrawImage_Delete (TFB_Image *image)
 void
 TFB_DrawImage_FixScaling (TFB_Image *image, int target, int type)
 {
-	EXTENT old = image->extent;
-	HOT_SPOT oldhs = image->last_scale_hs;
-	TFB_DrawCanvas_GetScaledExtent (image->NormalImg, image->NormalHs,
-			image->MipmapImg, image->MipmapHs, target,
-			&image->extent, &image->last_scale_hs);
-
-	if ((old.width != image->extent.width) ||
-			(old.height != image->extent.height) || image->dirty ||
-			!image->ScaledImg || type != image->last_scale_type ||
-			(oldhs.x != image->last_scale_hs.x) ||
-			(oldhs.y != image->last_scale_hs.y))
+	if (image->dirty || !image->ScaledImg ||
+			target != image->last_scale ||
+			type != image->last_scale_type)
 	{
 		image->dirty = FALSE;
 		image->ScaledImg = TFB_DrawCanvas_New_ScaleTarget (image->NormalImg,
 			image->ScaledImg, type, image->last_scale_type);
-		image->last_scale_type = type;
 		
 		if (type == TFB_SCALE_NEAREST)
 			TFB_DrawCanvas_Rescale_Nearest (image->NormalImg,
-					image->ScaledImg, image->extent);
+					image->ScaledImg, target, &image->NormalHs,
+					&image->extent, &image->last_scale_hs);
+		else if (type == TFB_SCALE_BILINEAR)
+			TFB_DrawCanvas_Rescale_Bilinear (image->NormalImg,
+					image->ScaledImg, target, &image->NormalHs,
+					&image->extent, &image->last_scale_hs);
 		else
 			TFB_DrawCanvas_Rescale_Trilinear (image->NormalImg,
-					image->ScaledImg, image->MipmapImg, image->extent);
+					image->MipmapImg, image->ScaledImg, target,
+					&image->NormalHs, &image->MipmapHs,
+					&image->extent, &image->last_scale_hs);
+
+		image->last_scale_type = type;
+		image->last_scale = target;
 	}
 }
+
diff -ruNp src.orig/sc2code/libs/graphics/tfb_draw.h src/sc2code/libs/graphics/tfb_draw.h
--- src.orig/sc2code/libs/graphics/tfb_draw.h	2017-11-08 16:49:30 -0600
+++ src/sc2code/libs/graphics/tfb_draw.h	2017-11-08 16:49:57 -0600
@@ -32,12 +32,6 @@ typedef enum {
 	TFB_GFX_NUMSCREENS
 } SCREEN;
 
-typedef enum {
-	TFB_SCALE_STEP, /* not really a scaler */
-	TFB_SCALE_NEAREST,
-	TFB_SCALE_TRILINEAR
-} SCALE;
-
 typedef struct tfb_palette
 {
 	UBYTE r;
@@ -61,6 +55,7 @@ typedef struct tfb_image
 	HOT_SPOT NormalHs;
 	HOT_SPOT MipmapHs;
 	HOT_SPOT last_scale_hs;
+	int last_scale;
 	int last_scale_type;
 	TFB_Palette last_fill;
 	EXTENT extent;
@@ -93,27 +88,29 @@ typedef struct tfb_pixelformat
 // Drawing commands
 
 void TFB_DrawScreen_Line (int x1, int y1, int x2, int y2, int r, int g, int b, SCREEN dest);
-void TFB_DrawScreen_Rect (PRECT rect, int r, int g, int b, SCREEN dest);
+void TFB_DrawScreen_Rect (RECT *rect, int r, int g, int b, SCREEN dest);
 void TFB_DrawScreen_Image (TFB_Image *img, int x, int y, int scale, TFB_ColorMap *cmap, SCREEN dest);
-void TFB_DrawScreen_Copy (PRECT r, SCREEN src, SCREEN dest);
+void TFB_DrawScreen_Copy (RECT *r, SCREEN src, SCREEN dest);
 void TFB_DrawScreen_FilledImage (TFB_Image *img, int x, int y, int scale, int r, int g, int b, SCREEN dest);
 void TFB_DrawScreen_FontChar (TFB_Char *, TFB_Image *backing, int x, int y, SCREEN dest);
 
-void TFB_DrawScreen_CopyToImage (TFB_Image *img, PRECT lpRect, SCREEN src);
+void TFB_DrawScreen_CopyToImage (TFB_Image *img, RECT *lpRect, SCREEN src);
+void TFB_DrawScreen_SetMipmap (TFB_Image *img, TFB_Image *mmimg, int hotx, int hoty);
 void TFB_DrawScreen_DeleteImage (TFB_Image *img);
 void TFB_DrawScreen_DeleteData (void *);
 void TFB_DrawScreen_WaitForSignal (void);
 void TFB_DrawScreen_ReinitVideo (int driver, int flags, int width, int height);
-void TFB_DrawScreen_SetPalette (int paletteIndex, int r, int g, int b);
+void TFB_DrawScreen_Callback (void (*callback) (void *arg), void *arg);
 
 TFB_Image *TFB_DrawImage_New (TFB_Canvas canvas);
 TFB_Image *TFB_DrawImage_CreateForScreen (int w, int h, BOOLEAN withalpha);
 TFB_Image *TFB_DrawImage_New_Rotated (TFB_Image *img, int angle);
+void TFB_DrawImage_SetMipmap (TFB_Image *img, TFB_Image *mmimg, int hotx, int hoty);
 void TFB_DrawImage_Delete (TFB_Image *image);
 void TFB_DrawImage_FixScaling (TFB_Image *image, int target, int type);
 
 void TFB_DrawImage_Line (int x1, int y1, int x2, int y2, int r, int g, int b, TFB_Image *dest);
-void TFB_DrawImage_Rect (PRECT rect, int r, int g, int b, TFB_Image *image);
+void TFB_DrawImage_Rect (RECT *rect, int r, int g, int b, TFB_Image *image);
 void TFB_DrawImage_Image (TFB_Image *img, int x, int y, int scale, TFB_ColorMap *cmap, TFB_Image *target);
 void TFB_DrawImage_FilledImage (TFB_Image *img, int x, int y, int scale, int r, int g, int b, TFB_Image *target);
 void TFB_DrawImage_FontChar (TFB_Char *, TFB_Image *backing, int x, int y, TFB_Image *target);
@@ -125,19 +122,24 @@ TFB_Canvas TFB_DrawCanvas_New_ScaleTarge
 TFB_Canvas TFB_DrawCanvas_New_RotationTarget (TFB_Canvas src, int angle);
 TFB_Canvas TFB_DrawCanvas_ToScreenFormat (TFB_Canvas canvas);
 BOOLEAN TFB_DrawCanvas_IsPaletted (TFB_Canvas canvas);
-void TFB_DrawCanvas_Rescale_Nearest (TFB_Canvas src, TFB_Canvas dst, EXTENT size);
-void TFB_DrawCanvas_Rescale_Trilinear (TFB_Canvas src, TFB_Canvas dst, TFB_Canvas mipmap, EXTENT size);
-void TFB_DrawCanvas_GetScaledExtent (TFB_Canvas src_canvas, HOT_SPOT src_hs,
-		TFB_Canvas src_mipmap, HOT_SPOT mm_hs,
-		int scale, PEXTENT size, HOT_SPOT *hs);
+void TFB_DrawCanvas_Rescale_Nearest (TFB_Canvas src, TFB_Canvas dst,
+		int scale, HOT_SPOT* src_hs, EXTENT* size, HOT_SPOT* dst_hs);
+void TFB_DrawCanvas_Rescale_Bilinear (TFB_Canvas src, TFB_Canvas dst,
+		int scale, HOT_SPOT* src_hs, EXTENT* size, HOT_SPOT* dst_hs);
+void TFB_DrawCanvas_Rescale_Trilinear (TFB_Canvas src, TFB_Canvas mipmap,
+		TFB_Canvas dst, int scale, HOT_SPOT* src_hs, HOT_SPOT* mm_hs,
+		EXTENT* size, HOT_SPOT* dst_hs);
+void TFB_DrawCanvas_GetScaledExtent (TFB_Canvas src_canvas, HOT_SPOT* src_hs,
+		TFB_Canvas src_mipmap, HOT_SPOT* mm_hs,
+		int scale, int type, EXTENT *size, HOT_SPOT *hs);
 void TFB_DrawCanvas_Rotate (TFB_Canvas src, TFB_Canvas dst, int angle, EXTENT size);
-void TFB_DrawCanvas_GetRotatedExtent (TFB_Canvas src, int angle, PEXTENT size);
-void TFB_DrawCanvas_GetExtent (TFB_Canvas canvas, PEXTENT size);
+void TFB_DrawCanvas_GetRotatedExtent (TFB_Canvas src, int angle, EXTENT *size);
+void TFB_DrawCanvas_GetExtent (TFB_Canvas canvas, EXTENT *size);
 
 void TFB_DrawCanvas_Delete (TFB_Canvas canvas);
 
 void TFB_DrawCanvas_Line (int x1, int y1, int x2, int y2, int r, int g, int b, TFB_Canvas dest);
-void TFB_DrawCanvas_Rect (PRECT rect, int r, int g, int b, TFB_Canvas image);
+void TFB_DrawCanvas_Rect (RECT *rect, int r, int g, int b, TFB_Canvas image);
 void TFB_DrawCanvas_Image (TFB_Image *img, int x, int y, int scale, TFB_ColorMap *cmap, TFB_Canvas target);
 void TFB_DrawCanvas_FilledImage (TFB_Image *img, int x, int y, int scale, int r, int g, int b, TFB_Canvas target);
 void TFB_DrawCanvas_FontChar (TFB_Char *, TFB_Image *backing, int x, int y, TFB_Canvas target);
@@ -148,9 +150,15 @@ int TFB_DrawCanvas_GetTransparentIndex (
 void TFB_DrawCanvas_SetTransparentIndex (TFB_Canvas canvas, int i, BOOLEAN rleaccel);
 BOOLEAN TFB_DrawCanvas_GetTransparentColor (TFB_Canvas canvas, int *r, int *g, int *b);
 void TFB_DrawCanvas_SetTransparentColor (TFB_Canvas canvas, int r, int g, int b, BOOLEAN rleaccel);
+void TFB_DrawCanvas_CopyTransparencyInfo (TFB_Canvas src, TFB_Canvas dst);
 void TFB_DrawCanvas_Initialize (void);
+void TFB_DrawCanvas_Lock (TFB_Canvas canvas);
+void TFB_DrawCanvas_Unlock (TFB_Canvas canvas);
 void TFB_DrawCanvas_GetScreenFormat (TFB_PixelFormat *fmt);
-void* TFB_DrawCanvas_GetLine (TFB_Canvas canvas, int line);
+int TFB_DrawCanvas_GetStride (TFB_Canvas canvas);
+void *TFB_DrawCanvas_GetLine (TFB_Canvas canvas, int line);
 void TFB_DrawCanvas_GetPixel (TFB_Canvas canvas, int x, int y, int *r, int *g, int *b);
 
+TFB_Canvas TFB_GetScreenCanvas (SCREEN screen);
+
 #endif
diff -ruNp src.orig/sc2code/libs/graphics/tfb_prim.c src/sc2code/libs/graphics/tfb_prim.c
--- src.orig/sc2code/libs/graphics/tfb_prim.c	2017-11-08 16:49:30 -0600
+++ src/sc2code/libs/graphics/tfb_prim.c	2017-11-08 16:49:57 -0600
@@ -29,7 +29,7 @@
 #include "libs/log.h"
 
 void
-TFB_Prim_Point (PPOINT p, TFB_Palette *color)
+TFB_Prim_Point (POINT *p, TFB_Palette *color)
 {
 	RECT r;
 
@@ -44,7 +44,7 @@ TFB_Prim_Point (PPOINT p, TFB_Palette *c
 }
 
 void
-TFB_Prim_Rect (PRECT r, TFB_Palette *color)
+TFB_Prim_Rect (RECT *r, TFB_Palette *color)
 {
 	RECT arm;
 	int gscale;
@@ -69,7 +69,7 @@ TFB_Prim_Rect (PRECT r, TFB_Palette *col
 }
 
 void
-TFB_Prim_FillRect (PRECT r, TFB_Palette *color)
+TFB_Prim_FillRect (RECT *r, TFB_Palette *color)
 {
 	RECT rect;
 	int gscale;
@@ -99,7 +99,7 @@ TFB_Prim_FillRect (PRECT r, TFB_Palette
 }
 
 void
-TFB_Prim_Line (PLINE line, TFB_Palette *color)
+TFB_Prim_Line (LINE *line, TFB_Palette *color)
 {
 	int x1, y1, x2, y2;
 
@@ -115,15 +115,15 @@ TFB_Prim_Line (PLINE line, TFB_Palette *
 }
 
 void
-TFB_Prim_Stamp (PSTAMP stmp)
+TFB_Prim_Stamp (STAMP *stmp)
 {
 	int x, y;
-	PFRAME_DESC SrcFramePtr;
+	FRAME SrcFramePtr;
 	TFB_Image *img;
 	TFB_ColorMap *cmap = NULL;
 	int gscale;
 
-	SrcFramePtr = (PFRAME_DESC)stmp->frame;
+	SrcFramePtr = stmp->frame;
 	if (!SrcFramePtr)
 	{
 		log_add (log_Warning, "TFB_Prim_Stamp: Tried to draw a NULL frame"
@@ -164,15 +164,15 @@ TFB_Prim_Stamp (PSTAMP stmp)
 }
 
 void
-TFB_Prim_StampFill (PSTAMP stmp, TFB_Palette *color)
+TFB_Prim_StampFill (STAMP *stmp, TFB_Palette *color)
 {
 	int x, y;
-	PFRAME_DESC SrcFramePtr;
+	FRAME SrcFramePtr;
 	TFB_Image *img;
 	int r, g, b;
 	int gscale;
 
-	SrcFramePtr = (PFRAME_DESC)stmp->frame;
+	SrcFramePtr = stmp->frame;
 	if (!SrcFramePtr)
 	{
 		log_add (log_Warning, "TFB_Prim_StampFill: Tried to draw a NULL frame"
@@ -213,7 +213,7 @@ TFB_Prim_StampFill (PSTAMP stmp, TFB_Pal
 }
 
 void
-TFB_Prim_FontChar (PPOINT origin, TFB_Char *fontChar, TFB_Image *backing)
+TFB_Prim_FontChar (POINT *origin, TFB_Char *fontChar, TFB_Image *backing)
 {
 	int x, y;
 
diff -ruNp src.orig/sc2code/libs/graphics/tfb_prim.h src/sc2code/libs/graphics/tfb_prim.h
--- src.orig/sc2code/libs/graphics/tfb_prim.h	2017-11-08 16:49:30 -0600
+++ src/sc2code/libs/graphics/tfb_prim.h	2017-11-08 16:49:57 -0600
@@ -20,10 +20,10 @@
 #include "tfb_draw.h"
 
 
-void TFB_Prim_Line (PLINE line, TFB_Palette *color);
-void TFB_Prim_Point (PPOINT p, TFB_Palette *color);
-void TFB_Prim_Rect (PRECT r, TFB_Palette *color);
-void TFB_Prim_FillRect (PRECT r, TFB_Palette *color);
-void TFB_Prim_Stamp (PSTAMP stamp);
-void TFB_Prim_StampFill (PSTAMP stamp, TFB_Palette *color);
-void TFB_Prim_FontChar (PPOINT origin, TFB_Char *, TFB_Image *backing);
+void TFB_Prim_Line (LINE *line, TFB_Palette *color);
+void TFB_Prim_Point (POINT *p, TFB_Palette *color);
+void TFB_Prim_Rect (RECT *r, TFB_Palette *color);
+void TFB_Prim_FillRect (RECT *r, TFB_Palette *color);
+void TFB_Prim_Stamp (STAMP *stamp);
+void TFB_Prim_StampFill (STAMP *stamp, TFB_Palette *color);
+void TFB_Prim_FontChar (POINT *origin, TFB_Char *, TFB_Image *backing);
diff -ruNp src.orig/sc2code/libs/graphics/widgets.c src/sc2code/libs/graphics/widgets.c
--- src.orig/sc2code/libs/graphics/widgets.c	2017-11-08 16:49:30 -0600
+++ src/sc2code/libs/graphics/widgets.c	2017-11-08 16:49:57 -0600
@@ -38,7 +38,7 @@ WIDGET *widget_focus = NULL;
 		BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x00), 0x00)
 
 void
-DrawShadowedBox(PRECT r, COLOR bg, COLOR dark, COLOR medium)
+DrawShadowedBox (RECT *r, COLOR bg, COLOR dark, COLOR medium)
 {
 	RECT t;
 	COLOR oldcolor;
@@ -466,7 +466,7 @@ Widget_DrawTextEntry (WIDGET *_self, int
 		COUNT i;
 		RECT text_r;
 		BYTE char_deltas[WIDGET_TEXTENTRY_WIDTH];
-		PBYTE pchar_deltas;
+		BYTE *pchar_deltas;
 		RECT r;
 		SIZE leading;
 
diff -ruNp src.orig/sc2code/libs/graphics/widgets.h src/sc2code/libs/graphics/widgets.h
--- src.orig/sc2code/libs/graphics/widgets.h	2017-11-08 16:49:30 -0600
+++ src/sc2code/libs/graphics/widgets.h	2017-11-08 16:49:57 -0600
@@ -175,7 +175,7 @@ typedef struct _widget_controlentry {
 	char controlname[2][WIDGET_CONTROLENTRY_WIDTH];
 } WIDGET_CONTROLENTRY;
 
-void DrawShadowedBox (PRECT r, COLOR bg, COLOR dark, COLOR medium);
+void DrawShadowedBox (RECT *r, COLOR bg, COLOR dark, COLOR medium);
 void DrawLabelAsWindow(WIDGET_LABEL *label);
 
 int Widget_Event (int event);
diff -ruNp src.orig/sc2code/libs/inplib.h src/sc2code/libs/inplib.h
--- src.orig/sc2code/libs/inplib.h	2017-11-08 16:49:30 -0600
+++ src/sc2code/libs/inplib.h	2017-11-08 16:49:57 -0600
@@ -19,8 +19,8 @@
 #ifndef _INPLIB_H
 #define _INPLIB_H
 
-#include "memlib.h"
 #include <stddef.h>
+#include "compiler.h"
 #include "libs/uio.h"
 
 typedef DWORD INPUT_STATE;
@@ -35,7 +35,7 @@ extern void FlushInput (void);
  * Not used right now
 extern BOOLEAN FindMouse (void);
 extern void MoveMouse (SWORD x, SWORD y);
-extern BYTE LocateMouse (PSWORD px, PSWORD py);
+extern BYTE LocateMouse (SWORD *px, SWORD *py);
 */
 
 extern volatile int MouseButtonDown;
@@ -55,5 +55,9 @@ void RebindInputState (int template, int
 
 void SaveKeyConfiguration (uio_DirHandle *path, const char *fname);
 
+/* Separate inputs into frames for dealing with very fast inputs */
+
+void BeginInputFrame (void);
+
 #endif /* _INPLIB_H */
 
diff -ruNp src.orig/sc2code/libs/input/sdl/input.c src/sc2code/libs/input/sdl/input.c
--- src.orig/sc2code/libs/input/sdl/input.c	2017-11-08 16:49:30 -0600
+++ src/sc2code/libs/input/sdl/input.c	2017-11-08 16:49:57 -0600
@@ -44,150 +44,146 @@ static BOOLEAN InputInitialized = FALSE;
 
 static BOOLEAN _in_character_mode = FALSE;
 
-#define VCONTROL_VERSION 4
+static const char *menu_res_names[] = {
+	"pause",
+	"exit",
+	"abort",
+	"debug",
+	"fullscreen",
+	"up",
+	"down",
+	"left",
+	"right",
+	"select",
+	"cancel",
+	"special",
+	"pageup",
+	"pagedown",
+	"home",
+	"end",
+	"zoomin",
+	"zoomout",
+	"delete",
+	"backspace",
+	"editcancel",
+	"search",
+	"next",
+	NULL
+};
+
+static const char *flight_res_names[] = {
+	"up",
+	"down",
+	"left",
+	"right",
+	"weapon",
+	"special",
+	"escape",
+	NULL
+};
 
-static VControl_NameBinding control_names[] = {
-	{ "Menu-Up", (int *)&ImmediateInputState.menu[KEY_MENU_UP] },
-	{ "Menu-Down", (int *)&ImmediateInputState.menu[KEY_MENU_DOWN] },
-	{ "Menu-Left", (int *)&ImmediateInputState.menu[KEY_MENU_LEFT] },
-	{ "Menu-Right", (int *)&ImmediateInputState.menu[KEY_MENU_RIGHT] },
-	{ "Menu-Select", (int *)&ImmediateInputState.menu[KEY_MENU_SELECT] },
-	{ "Menu-Cancel", (int *)&ImmediateInputState.menu[KEY_MENU_CANCEL] },
-	{ "Menu-Special", (int *)&ImmediateInputState.menu[KEY_MENU_SPECIAL] },
-	{ "Menu-Page-Up", (int *)&ImmediateInputState.menu[KEY_MENU_PAGE_UP] },
-	{ "Menu-Page-Down", (int *)&ImmediateInputState.menu[KEY_MENU_PAGE_DOWN] },
-	{ "Menu-Home", (int *)&ImmediateInputState.menu[KEY_MENU_HOME] },
-	{ "Menu-End", (int *)&ImmediateInputState.menu[KEY_MENU_END] },
-	{ "Menu-Zoom-In", (int *)&ImmediateInputState.menu[KEY_MENU_ZOOM_IN] },
-	{ "Menu-Zoom-Out", (int *)&ImmediateInputState.menu[KEY_MENU_ZOOM_OUT] },
-	{ "Menu-Delete", (int *)&ImmediateInputState.menu[KEY_MENU_DELETE] },
-	{ "Menu-Backspace", (int *)&ImmediateInputState.menu[KEY_MENU_BACKSPACE] },
-	{ "Menu-Edit-Cancel", (int *)&ImmediateInputState.menu[KEY_MENU_EDIT_CANCEL] },
-	{ "Menu-Search", (int *)&ImmediateInputState.menu[KEY_MENU_SEARCH] },
-	{ "Menu-Next", (int *)&ImmediateInputState.menu[KEY_MENU_NEXT] },
-	{ "Template-1-Up", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_KB_1][KEY_UP] },
-	{ "Template-1-Down", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_KB_1][KEY_DOWN] },
-	{ "Template-1-Left", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_KB_1][KEY_LEFT] },
-	{ "Template-1-Right", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_KB_1][KEY_RIGHT] },
-	{ "Template-1-Weapon", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_KB_1][KEY_WEAPON] },
-	{ "Template-1-Special", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_KB_1][KEY_SPECIAL] },
-	{ "Template-1-Escape", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_KB_1][KEY_ESCAPE] },
-	{ "Template-2-Up", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_KB_2][KEY_UP] },
-	{ "Template-2-Down", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_KB_2][KEY_DOWN] },
-	{ "Template-2-Left", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_KB_2][KEY_LEFT] },
-	{ "Template-2-Right", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_KB_2][KEY_RIGHT] },
-	{ "Template-2-Weapon", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_KB_2][KEY_WEAPON] },
-	{ "Template-2-Special", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_KB_2][KEY_SPECIAL] },
-	{ "Template-2-Escape", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_KB_2][KEY_ESCAPE] },
-	{ "Template-3-Up", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_KB_3][KEY_UP] },
-	{ "Template-3-Down", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_KB_3][KEY_DOWN] },
-	{ "Template-3-Left", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_KB_3][KEY_LEFT] },
-	{ "Template-3-Right", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_KB_3][KEY_RIGHT] },
-	{ "Template-3-Weapon", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_KB_3][KEY_WEAPON] },
-	{ "Template-3-Special", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_KB_3][KEY_SPECIAL] },
-	{ "Template-3-Escape", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_KB_3][KEY_ESCAPE] },
-	{ "Template-4-Up", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_JOY_1][KEY_UP] },
-	{ "Template-4-Down", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_JOY_1][KEY_DOWN] },
-	{ "Template-4-Left", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_JOY_1][KEY_LEFT] },
-	{ "Template-4-Right", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_JOY_1][KEY_RIGHT] },
-	{ "Template-4-Weapon", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_JOY_1][KEY_WEAPON] },
-	{ "Template-4-Special", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_JOY_1][KEY_SPECIAL] },
-	{ "Template-4-Escape", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_JOY_1][KEY_ESCAPE] },
-	{ "Template-5-Up", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_JOY_2][KEY_UP] },
-	{ "Template-5-Down", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_JOY_2][KEY_DOWN] },
-	{ "Template-5-Left", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_JOY_2][KEY_LEFT] },
-	{ "Template-5-Right", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_JOY_2][KEY_RIGHT] },
-	{ "Template-5-Weapon", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_JOY_2][KEY_WEAPON] },
-	{ "Template-5-Special", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_JOY_2][KEY_SPECIAL] },
-	{ "Template-5-Escape", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_JOY_2][KEY_ESCAPE] },
-	{ "Template-6-Up", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_JOY_3][KEY_UP] },
-	{ "Template-6-Down", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_JOY_3][KEY_DOWN] },
-	{ "Template-6-Left", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_JOY_3][KEY_LEFT] },
-	{ "Template-6-Right", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_JOY_3][KEY_RIGHT] },
-	{ "Template-6-Weapon", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_JOY_3][KEY_WEAPON] },
-	{ "Template-6-Special", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_JOY_3][KEY_SPECIAL] },
-	{ "Template-6-Escape", (int *)&ImmediateInputState.key[CONTROL_TEMPLATE_JOY_3][KEY_ESCAPE] },
-	{ "Pause", (int *)&ImmediateInputState.menu[KEY_PAUSE] },
-	{ "Exit", (int *)&ImmediateInputState.menu[KEY_EXIT] },
-	{ "Abort", (int *)&ImmediateInputState.menu[KEY_ABORT] },
-	{ "Debug", (int *)&ImmediateInputState.menu[KEY_DEBUG] },
-	{ "Illegal", NULL}};
+static void
+register_menu_controls (int index)
+{
+	int i;
+	char buf[40];
+	buf[39] = '\0';
+	
+	i = 1;
+	while (TRUE)
+	{
+		VCONTROL_GESTURE g;
+		snprintf (buf, 39, "menu.%s.%d", menu_res_names[index], i);
+		if (!res_HasKey (buf))
+			break;
+		VControl_ParseGesture (&g, res_GetString (buf));
+		VControl_AddGestureBinding (&g, (int *)&ImmediateInputState.menu[index]);
+		i++;
+	}
+}
 
+static VCONTROL_GESTURE controls[NUM_TEMPLATES][NUM_KEYS][2];
 
 static void
-initKeyConfig (void)
+register_flight_controls (void)
 {
-	uio_Stream *fp;
-	int i, errors;
-	
-	for (i = 0; i < 2; ++i)
+	int i, j, k;
+	char buf[40];
+
+	buf[39] = '\0';
+
+	for (i = 0; i < NUM_TEMPLATES; i++)
 	{
-		if ((fp = res_OpenResFile (configDir, "keys.cfg", "rt")) == NULL)
+		/* Copy in name */
+		snprintf (buf, 39, "keys.%d.name", i+1);
+		if (res_HasKey (buf))
 		{
-			if (copyFile (contentDir, "starcon.key",
-				configDir, "keys.cfg") == -1)
-			{
-				log_add (log_Fatal, "Error: Could not copy default key config "
-					"to user config dir: %s.", strerror (errno));
-				exit (EXIT_FAILURE);
-			}
-			log_add (log_Info, "Copying default key config file to user "
-				"config dir.");
-			
-			if ((fp = res_OpenResFile (configDir, "keys.cfg", "rt")) == NULL)
-			{
-				log_add (log_Fatal, "Error: Could not open keys.cfg");
-				exit (EXIT_FAILURE);
-			}
+			strncpy (input_templates[i].name, res_GetString (buf), 29);
+			input_templates[i].name[29] = '\0';
 		}
-		
-		errors = VControl_ReadConfiguration (fp);
-		res_CloseResFile (fp);
-		
-		if (errors || (VControl_GetConfigFileVersion () != VCONTROL_VERSION))
+		else
 		{
-			bool do_rename = false;
-			if (errors)
-				log_add (log_Warning, "%d errors encountered in key configuration file.", errors);
-
-			if (VControl_GetValidCount () == 0)
-			{
-				log_add (log_Error, "\nI didn't understand a single line in your configuration file.");
-				log_add (log_Error, "This is likely because you're still using a 0.2 era or earlier keys.cfg.");
-				do_rename = true;
-			}
-			if (VControl_GetConfigFileVersion () != VCONTROL_VERSION)
-			{
-				log_add (log_Error, "\nThe control scheme for UQM has changed since you last updated keys.cfg.");
-				log_add (log_Error, "(I'm using control scheme version %d, while your config file appears to be\nfor version %d.)", VCONTROL_VERSION, VControl_GetConfigFileVersion ());
-				do_rename = true;
-			}
-
-			if (do_rename)
+			input_templates[i].name[0] = '\0';
+		}
+		for (j = 0; j < NUM_KEYS; j++)
+		{
+			for (k = 0; k < 2; k++)
 			{
-				log_add (log_Error, "\nRenaming keys.cfg to keys.old and retrying.");
-
-				if (fileExists2 (configDir, "keys.old"))
-					uio_unlink (configDir, "keys.old");
-				if ((uio_rename (configDir, "keys.cfg", configDir, "keys.old")) == -1)
+				VCONTROL_GESTURE *g = &controls[i][j][k];
+				snprintf (buf, 39, "keys.%d.%s.%d", i+1, flight_res_names[j], k+1);
+				if (!res_HasKey (buf))
 				{
-					log_add (log_Fatal, "Error: Renaming failed!");
-					log_add (log_Fatal, "You must delete keys.cfg manually before you can run the game.");
-					exit (EXIT_FAILURE);
+					g->type = VCONTROL_NONE;
+					continue;
 				}
-				continue;
+				VControl_ParseGesture (g, res_GetString (buf));
+				VControl_AddGestureBinding (g, (int *)&ImmediateInputState.key[i][j]);
 			}
-			
-			log_add (log_Fatal, "\nRepair your keys.cfg file to continue.");
+		}
+	}
+}
+
+static void
+initKeyConfig (void)
+{
+	uio_Stream *fp;
+	int i;
+
+	/* First, load in the menu keys */
+	res_LoadFilename (contentDir, "menu.key");
+	for (i = 0; i < NUM_MENU_KEYS; i++)
+	{
+		if (!menu_res_names[i])
+			break;
+		register_menu_controls (i);
+	}
+	
+	fp = res_OpenResFile (configDir, "flight.cfg", "rt");
+	if (!fp)
+	{
+		if (copyFile (contentDir, "uqm.key",
+			configDir, "flight.cfg") == -1)
+		{
+			log_add (log_Fatal, "Error: Could not copy default key config "
+				"to user config dir: %s.", strerror (errno));
 			exit (EXIT_FAILURE);
 		}
+		log_add (log_Info, "Copying default key config file to user "
+			"config dir.");
 		
-		return;
+		if ((fp = res_OpenResFile (configDir, "flight.cfg", "rt")) == NULL)
+		{
+			log_add (log_Fatal, "Error: Could not open flight.cfg");
+			exit (EXIT_FAILURE);
+		}
 	}
+	
+	res_LoadFile (fp);
+	res_CloseResFile (fp);
+
+	register_flight_controls ();
 
-	log_add (log_Fatal, "Error: Something went wrong and we were looping again and again so aborting.");
-	log_add (log_Fatal, "Possible cause is your content dir not being up-to-date.");
-	exit (EXIT_FAILURE);
+	return;
 }
 
 static void
@@ -239,7 +235,6 @@ TFB_InitInput (int driver, int flags)
 
 	/* Prepare the Virtual Controller system. */
 	VControl_Init ();
-	VControl_RegisterNameTable (control_names);
 
 	initKeyConfig ();
 	
@@ -387,82 +382,71 @@ FlushInput (void)
 void
 InterrogateInputState (int template, int control, int index, char *buffer, int maxlen)
 {
-	int i;
-	VCONTROL_GESTURE g;
+	VCONTROL_GESTURE *g = &controls[template][control][index];
 
-	VControl_StartIter (&ImmediateInputState.key[template][control]);
-	i = 0;
-	while (VControl_NextBinding (&g))
+	switch (g->type)
 	{
-		if (i++ < index)
-		{
-			continue;
-		}
-		switch (g.type)
-		{
-		case VCONTROL_KEY:
-			snprintf (buffer, maxlen, "%s", VControl_code2name (g.gesture.key));
-			buffer[maxlen-1] = 0;
-			break;
-		case VCONTROL_JOYBUTTON:
-			snprintf (buffer, maxlen, "[J%d B%d]", g.gesture.button.port, g.gesture.button.index + 1);
-			buffer[maxlen-1] = 0;
-			break;
-		case VCONTROL_JOYAXIS:
-			snprintf (buffer, maxlen, "[J%d A%d %c]", g.gesture.axis.port, g.gesture.axis.index, g.gesture.axis.polarity > 0 ? '+' : '-');
-			break;
-		case VCONTROL_JOYHAT:
-			snprintf (buffer, maxlen, "[J%d H%d %d]", g.gesture.hat.port, g.gesture.hat.index, g.gesture.hat.dir);
-			break;
-		default:
-			/* Something we don't handle yet */
-			buffer[0] = 0;
-			break;
-		}
-		return;
+	case VCONTROL_KEY:
+		snprintf (buffer, maxlen, "%s", VControl_code2name (g->gesture.key));
+		buffer[maxlen-1] = 0;
+		break;
+	case VCONTROL_JOYBUTTON:
+		snprintf (buffer, maxlen, "[J%d B%d]", g->gesture.button.port, g->gesture.button.index + 1);
+		buffer[maxlen-1] = 0;
+		break;
+	case VCONTROL_JOYAXIS:
+		snprintf (buffer, maxlen, "[J%d A%d %c]", g->gesture.axis.port, g->gesture.axis.index, g->gesture.axis.polarity > 0 ? '+' : '-');
+		break;
+	case VCONTROL_JOYHAT:
+		snprintf (buffer, maxlen, "[J%d H%d %d]", g->gesture.hat.port, g->gesture.hat.index, g->gesture.hat.dir);
+		break;
+	default:
+		/* Something we don't handle yet */
+		buffer[0] = 0;
+		break;
 	}
-	/* There aren't that many bindings, so return blank string */
-	buffer[0] = 0;
+	return;
 }
 
 void
 RemoveInputState (int template, int control, int index)
 {
-	int i;
-	VCONTROL_GESTURE g;
+	VCONTROL_GESTURE *g = &controls[template][control][index];
+	char keybuf[40];
+	keybuf[39] = '\0';
+
+	VControl_RemoveGestureBinding (g, (int *)&ImmediateInputState.key[template][control]);
+	g->type = VCONTROL_NONE;
+
+	snprintf (keybuf, 39, "keys.%d.%s.%d", template+1, flight_res_names[control], index+1);
+	res_Remove (keybuf);
 
-	VControl_StartIter (&ImmediateInputState.key[template][control]);
-	i = 0;
-	while (VControl_NextBinding (&g))
-	{
-		if (i++ < index)
-		{
-			continue;
-		}
-		VControl_RemoveGestureBinding (&g, &ImmediateInputState.key[template][control]);
-		return;
-	}
-	/* No such gesture! */
 	return;
 }
 
 void
 RebindInputState (int template, int control, int index)
 {
-	SDL_Event e;
+	VCONTROL_GESTURE g;
+	char keybuf[40], valbuf[40];
+	keybuf[39] = valbuf[39] = '\0';
 
 	/* Remove the old binding on this spot */
 	RemoveInputState (template, control, index);
 
 	/* Wait for the next interesting bit of user input */
-	VControl_ClearEvent ();
-	while (!VControl_GetLastEvent (&e))
+	VControl_ClearGesture ();
+	while (!VControl_GetLastGesture (&g))
 	{
 		TaskSwitch ();
 	}
 
 	/* And now, add the new binding. */
-	VControl_AddBinding (&e, &ImmediateInputState.key[template][control]);
+	VControl_AddGestureBinding (&g, (int *)&ImmediateInputState.key[template][control]);
+	controls[template][control][index] = g;
+	snprintf (keybuf, 39, "keys.%d.%s.%d", template+1, flight_res_names[control], index+1);
+	VControl_DumpGesture (valbuf, 39, &g);
+	res_PutString (keybuf, valbuf);
 }
 
 void
@@ -473,9 +457,15 @@ SaveKeyConfiguration (uio_DirHandle *pat
 	f = res_OpenResFile (path, fname, "wb");
 	if (f) 
 	{
-		VControl_Dump (f);
+		res_SaveFile (f, "keys.");
 		res_CloseResFile (f);
-	}
+	} 
+}
+
+void
+BeginInputFrame (void)
+{
+	VControl_BeginFrame ();
 }
 
 #endif
diff -ruNp src.orig/sc2code/libs/input/sdl/keynames.c src/sc2code/libs/input/sdl/keynames.c
--- src.orig/sc2code/libs/input/sdl/keynames.c	2017-11-08 16:49:30 -0600
+++ src/sc2code/libs/input/sdl/keynames.c	2017-11-08 16:49:57 -0600
@@ -170,7 +170,16 @@ static keyname keynames[] = {
 	{"Power", SDLK_POWER},
 	{"Euro", SDLK_EURO},
 	{"Undo", SDLK_UNDO},
-	{"Unknown", 0}};  
+#ifdef _WIN32_WCE
+	{"App1", SDLK_APP1},
+	{"App2", SDLK_APP2},
+	{"App3", SDLK_APP3},
+	{"App4", SDLK_APP4},
+	{"App5", SDLK_APP5},
+	{"App6", SDLK_APP6},
+#endif
+
+	{"Unknown", 0}};
 /* Last element must have code zero */
 
 char *
@@ -196,7 +205,7 @@ VControl_name2code (char *name)
 	{
 		char *test = keynames[i].name;
 		int code = keynames[i].code;
-		if (!stricmp(test, name) || !code)
+		if (!strcasecmp(test, name) || !code)
 		{
 			return code;
 		}
diff -ruNp src.orig/sc2code/libs/input/sdl/vcontrol.c src/sc2code/libs/input/sdl/vcontrol.c
--- src.orig/sc2code/libs/input/sdl/vcontrol.c	2017-11-08 16:49:30 -0600
+++ src/sc2code/libs/input/sdl/vcontrol.c	2017-11-08 16:49:57 -0600
@@ -20,7 +20,7 @@
 #include <string.h>
 #include <ctype.h>
 #include "vcontrol.h"
-#include "vcontrol_malloc.h"
+#include "misc.h"
 #include "keynames.h"
 #include "libs/log.h"
 #include "libs/reslib.h"
@@ -71,16 +71,6 @@ static int num_sdl_keys = 0;
 static keybinding **bindings = NULL;
 
 static keypool *pool;
-static VControl_NameBinding *nametable;
-
-/* Statistics variables - set by VControl_ReadConfiguration */
-
-static int version, errors, validlines;
-
-/* Iterator temp variables */
-
-static int *iter_target;
-static int iter_device, iter_index;
 
 /* Last interesting event */
 static int event_ready;
@@ -89,7 +79,7 @@ static SDL_Event last_interesting;
 static keypool *
 allocate_key_chunk (void)
 {
-	keypool *x = vctrl_malloc (sizeof (keypool));
+	keypool *x = HMalloc (sizeof (keypool));
 	if (x)
 	{
 		int i;
@@ -111,7 +101,7 @@ free_key_pool (keypool *x)
 	if (x)
 	{
 		free_key_pool (x->next);
-		vctrl_free (x);
+		HFree (x);
 	}
 }
 
@@ -145,9 +135,9 @@ create_joystick (int index)
 		x->numaxes = axes;
 		x->numbuttons = buttons;
 		x->numhats = hats;
-		x->axes = vctrl_malloc (sizeof (axis_type) * axes);
-		x->buttons = vctrl_malloc (sizeof (keybinding *) * buttons);
-		x->hats = vctrl_malloc (sizeof (hat_type) * hats);
+		x->axes = HMalloc (sizeof (axis_type) * axes);
+		x->buttons = HMalloc (sizeof (keybinding *) * buttons);
+		x->hats = HMalloc (sizeof (hat_type) * hats);
 		for (j = 0; j < axes; j++)
 		{
 			x->axes[j].neg = x->axes[j].pos = NULL;
@@ -178,9 +168,9 @@ destroy_joystick (int index)
 	{
 		SDL_JoystickClose (stick);
 		joysticks[index].stick = NULL;
-		vctrl_free (joysticks[index].axes);
-		vctrl_free (joysticks[index].buttons);
-		vctrl_free (joysticks[index].hats);
+		HFree (joysticks[index].axes);
+		HFree (joysticks[index].buttons);
+		HFree (joysticks[index].hats);
 		joysticks[index].numaxes = joysticks[index].numbuttons = 0;
 		joysticks[index].axes = NULL;
 		joysticks[index].buttons = NULL;
@@ -196,7 +186,7 @@ key_init (void)
 	int i;
 	pool = allocate_key_chunk ();
 	(void)SDL_GetKeyState (&num_sdl_keys);
-	bindings = (keybinding **) vctrl_malloc (sizeof (keybinding *) * num_sdl_keys);
+	bindings = (keybinding **) HMalloc (sizeof (keybinding *) * num_sdl_keys);
 	for (i = 0; i < num_sdl_keys; i++)
 		bindings[i] = NULL;
 
@@ -207,13 +197,14 @@ key_init (void)
 	joycount = SDL_NumJoysticks ();
 	if (joycount)
 	{
-		joysticks = vctrl_malloc (sizeof (joystick) * joycount);
+		joysticks = HMalloc (sizeof (joystick) * joycount);
 		for (i = 0; i < joycount; i++)
 		{
 			joysticks[i].stick = NULL;	
 			joysticks[i].numaxes = joysticks[i].numbuttons = 0;
 			joysticks[i].axes = NULL;
 			joysticks[i].buttons = NULL;
+			joysticks[i].threshold = 10000;
 		}
 	}
 	else
@@ -232,40 +223,27 @@ key_uninit (void)
 	free_key_pool (pool);
 	for (i = 0; i < num_sdl_keys; i++)
 		bindings[i] = NULL;
-	vctrl_free (bindings);
+	HFree (bindings);
+	bindings = NULL;
 	pool = NULL;
 
 #ifdef HAVE_JOYSTICK
 	for (i = 0; i < joycount; i++)
 		destroy_joystick (i);
-	vctrl_free (joysticks);
+	HFree (joysticks);
 #endif /* HAVE_JOYSTICK */
 }
 
-static void
-name_init (void)
-{
-	nametable = NULL;
-}
-
-static void
-name_uninit (void)
-{
-	nametable = NULL;
-}
-
 void
 VControl_Init (void)
 {
 	key_init ();
-	name_init ();
 }
 
 void
 VControl_Uninit (void)
 {
 	key_uninit ();
-	name_uninit ();
 }
 
 int
@@ -278,6 +256,9 @@ VControl_SetJoyThreshold (int port, int
 		return 0;
 	}
 	else
+#else
+	(void) port;
+	(void) threshold;
 #endif /* HAVE_JOYSTICK */
 	{
 		// log_add (log_Warning, "VControl_SetJoyThreshold passed illegal port %d", port);
@@ -384,7 +365,7 @@ activate (keybinding *i)
 {
 	while (i != NULL)
 	{
-		*(i->target) = *(i->target)+1;
+		*(i->target) = (*(i->target)+1) | VCONTROL_STARTBIT;
 		i = i->next;
 	}
 }
@@ -394,67 +375,44 @@ deactivate (keybinding *i)
 {
 	while (i != NULL)
 	{
-		if (*(i->target) > 0)
+		int v = *(i->target) & VCONTROL_MASK;
+		if (v > 0)
 		{
-			*(i->target) = *(i->target)-1;
+			*(i->target) = (v-1) | (*(i->target) & VCONTROL_STARTBIT);
 		}
 		i = i->next;
 	}
 }
 
-int
-VControl_AddBinding (SDL_Event *e, int *target)
-{
-	int result;
-	switch (e->type)
-	{
-	case SDL_KEYDOWN:
-		result = VControl_AddKeyBinding (e->key.keysym.sym, target);
-		break;
-
-#ifdef HAVE_JOYSTICK
-	case SDL_JOYAXISMOTION:
-		result = VControl_AddJoyAxisBinding (e->jaxis.which, e->jaxis.axis, (e->jaxis.value < 0) ? -1 : 1, target);
-		break;
-	case SDL_JOYHATMOTION:
-		result = VControl_AddJoyHatBinding (e->jhat.which, e->jhat.hat, e->jhat.value, target);
-		break;
-	case SDL_JOYBUTTONDOWN:
-		result = VControl_AddJoyButtonBinding (e->jbutton.which, e->jbutton.button, target);
-		break;
-#endif /* HAVE_JOYSTICK */
-
-	default:
-		log_add (log_Warning, "VControl_AddBinding didn't understand argument event");
-		result = -1;
-		break;
-	}
-	return result;
-}
-
-void
-VControl_RemoveBinding (SDL_Event *e, int *target)
+static void
+event2gesture (SDL_Event *e, VCONTROL_GESTURE *g)
 {
 	switch (e->type)
 	{
 	case SDL_KEYDOWN:
-		VControl_RemoveKeyBinding (e->key.keysym.sym, target);
+		g->type = VCONTROL_KEY;
+		g->gesture.key = e->key.keysym.sym;
 		break;
-
-#ifdef HAVE_JOYSTICK
 	case SDL_JOYAXISMOTION:
-		VControl_RemoveJoyAxisBinding (e->jaxis.which, e->jaxis.axis, (e->jaxis.value < 0) ? -1 : 1, target);
+		g->type = VCONTROL_JOYAXIS;
+		g->gesture.axis.port = e->jaxis.which;
+		g->gesture.axis.index = e->jaxis.axis;
+		g->gesture.axis.polarity = (e->jaxis.value < 0) ? -1 : 1;
 		break;
 	case SDL_JOYHATMOTION:
-		VControl_RemoveJoyHatBinding (e->jhat.which, e->jhat.hat, e->jhat.value, target);
+		g->type = VCONTROL_JOYHAT;
+		g->gesture.hat.port = e->jhat.which;
+		g->gesture.hat.index = e->jhat.hat;
+		g->gesture.hat.dir = e->jhat.value;
 		break;
 	case SDL_JOYBUTTONDOWN:
-		VControl_RemoveJoyButtonBinding (e->jbutton.which, e->jbutton.button, target);
+		g->type = VCONTROL_JOYBUTTON;
+		g->gesture.button.port = e->jbutton.which;
+		g->gesture.button.index = e->jbutton.button;
 		break;
-#endif /* HAVE_JOYSTICK */
 
 	default:
-		log_add (log_Warning, "VControl_RemoveBinding didn't understand argument event");
+		g->type = VCONTROL_NONE;
 		break;
 	}
 }
@@ -469,17 +427,24 @@ VControl_AddGestureBinding (VCONTROL_GES
 		result = VControl_AddKeyBinding (g->gesture.key, target);
 		break;
 
-#ifdef HAVE_JOYSTICK
 	case VCONTROL_JOYAXIS:
+#ifdef HAVE_JOYSTICK
 		result = VControl_AddJoyAxisBinding (g->gesture.axis.port, g->gesture.axis.index, (g->gesture.axis.polarity < 0) ? -1 : 1, target);
 		break;
+#endif
 	case VCONTROL_JOYHAT:
+#ifdef HAVE_JOYSTICK
 		result = VControl_AddJoyHatBinding (g->gesture.hat.port, g->gesture.hat.index, g->gesture.hat.dir, target);
 		break;
+#endif
 	case VCONTROL_JOYBUTTON:
+#ifdef HAVE_JOYSTICK
 		result = VControl_AddJoyButtonBinding (g->gesture.button.port, g->gesture.button.index, target);
 		break;
 #endif /* HAVE_JOYSTICK */
+	case VCONTROL_NONE:
+		/* Do nothing */
+		break;
 
 	default:
 		log_add (log_Warning, "VControl_AddGestureBinding didn't understand argument gesture");
@@ -498,25 +463,29 @@ VControl_RemoveGestureBinding (VCONTROL_
 		VControl_RemoveKeyBinding (g->gesture.key, target);
 		break;
 
-#ifdef HAVE_JOYSTICK
 	case VCONTROL_JOYAXIS:
+#ifdef HAVE_JOYSTICK
 		VControl_RemoveJoyAxisBinding (g->gesture.axis.port, g->gesture.axis.index, (g->gesture.axis.polarity < 0) ? -1 : 1, target);
 		break;
+#endif /* HAVE_JOYSTICK */
 	case VCONTROL_JOYHAT:
+#ifdef HAVE_JOYSTICK
 		VControl_RemoveJoyHatBinding (g->gesture.hat.port, g->gesture.hat.index, g->gesture.hat.dir, target);
 		break;
+#endif /* HAVE_JOYSTICK */
 	case VCONTROL_JOYBUTTON:
+#ifdef HAVE_JOYSTICK
 		VControl_RemoveJoyButtonBinding (g->gesture.button.port, g->gesture.button.index, target);
 		break;
 #endif /* HAVE_JOYSTICK */
-
+	case VCONTROL_NONE:
+		break;
 	default:
 		log_add (log_Warning, "VControl_RemoveGestureBinding didn't understand argument gesture");
 		break;
 	}
 }
 
-
 int
 VControl_AddKeyBinding (SDLKey symbol, int *target)
 {
@@ -570,6 +539,11 @@ VControl_AddJoyAxisBinding (int port, in
 		}
 	}
 	else
+#else
+	(void) port;
+	(void) axis;
+	(void) polarity;
+	(void) target;
 #endif /* HAVE_JOYSTICK */
 	{
 		// log_add (log_Debug, "VControl: Attempted to bind to illegal port %d", port);
@@ -608,6 +582,11 @@ VControl_RemoveJoyAxisBinding (int port,
 		}
 	}
 	else
+#else
+	(void) port;
+	(void) axis;
+	(void) polarity;
+	(void) target;
 #endif /* HAVE_JOYSTICK */
 	{
 		log_add (log_Debug, "VControl: Attempted to unbind from illegal port %d", port);
@@ -635,6 +614,10 @@ VControl_AddJoyButtonBinding (int port,
 		}
 	}
 	else
+#else
+	(void) port;
+	(void) button;
+	(void) target;
 #endif /* HAVE_JOYSTICK */
 	{
 		// log_add (log_Debug, "VControl: Attempted to bind to illegal port %d", port);
@@ -661,6 +644,10 @@ VControl_RemoveJoyButtonBinding (int por
 		}
 	}
 	else
+#else
+	(void) port;
+	(void) button;
+	(void) target;
 #endif /* HAVE_JOYSTICK */
 	{
 		log_add (log_Debug, "VControl: Attempted to unbind from illegal port %d", port);
@@ -708,6 +695,11 @@ VControl_AddJoyHatBinding (int port, int
 		}
 	}
 	else
+#else
+	(void) port;
+	(void) which;
+	(void) dir;
+	(void) target;
 #endif /* HAVE_JOYSTICK */
 	{
 		// log_add (log_Debug, "VControl: Attempted to bind to illegal port %d", port);
@@ -753,6 +745,11 @@ VControl_RemoveJoyHatBinding (int port,
 		}
 	}
 	else
+#else
+	(void) port;
+	(void) which;
+	(void) dir;
+	(void) target;
 #endif /* HAVE_JOYSTICK */
 	{
 		log_add (log_Debug, "VControl: Attempted to unbind from illegal port %d", port);
@@ -760,7 +757,7 @@ VControl_RemoveJoyHatBinding (int port,
 }
 
 void
-VControl_RemoveAllBindings ()
+VControl_RemoveAllBindings (void)
 {
 	key_uninit ();
 	key_init ();
@@ -793,6 +790,9 @@ VControl_ProcessJoyButtonDown (int port,
 	if (!joysticks[port].stick)
 		return;
 	activate (joysticks[port].buttons[button]);
+#else
+	(void) port;
+	(void) button;
 #endif /* HAVE_JOYSTICK */
 }
 
@@ -803,6 +803,9 @@ VControl_ProcessJoyButtonUp (int port, i
 	if (!joysticks[port].stick)
 		return;
 	deactivate (joysticks[port].buttons[button]);
+#else
+	(void) port;
+	(void) button;
 #endif /* HAVE_JOYSTICK */
 }
 
@@ -850,6 +853,10 @@ VControl_ProcessJoyAxis (int port, int a
 		}
 		joysticks[port].axes[axis].polarity = 0;
 	}
+#else
+	(void) port;
+	(void) axis;
+	(void) value;
 #endif /* HAVE_JOYSTICK */
 }
 
@@ -878,11 +885,15 @@ VControl_ProcessJoyHat (int port, int wh
 	if ((old & SDL_HAT_DOWN) && !(value & SDL_HAT_DOWN))
 		deactivate (joysticks[port].hats[which].down);
 	joysticks[port].hats[which].last = value;
+#else
+	(void) port;
+	(void) which;
+	(void) value;
 #endif /* HAVE_JOYSTICK */
 }
 
 void
-VControl_ResetInput ()
+VControl_ResetInput (void)
 {
 	/* Step through every valid entry in the binding pool and zero
 	 * them out.  This will probably zero entries multiple times;
@@ -904,6 +915,28 @@ VControl_ResetInput ()
 }
 
 void
+VControl_BeginFrame (void)
+{
+	/* Step through every valid entry in the binding pool and zero
+	 * out the frame-start bit.  This will probably zero entries
+	 * multiple times; oh well, no harm done. */
+
+	keypool *base = pool;
+	while (base != NULL)
+	{
+		int i;
+		for (i = 0; i < POOL_CHUNK_SIZE; i++)
+		{
+			if(base->pool[i].target)
+			{
+				*(base->pool[i].target) &= VCONTROL_MASK;
+			}
+		}
+		base = base->next;
+	}
+}
+
+void
 VControl_HandleEvent (const SDL_Event *e)
 {
 	switch (e->type)
@@ -946,313 +979,20 @@ VControl_HandleEvent (const SDL_Event *e
 	}
 }
 
-void
-VControl_RegisterNameTable (VControl_NameBinding *table)
-{
-	nametable = table;
-}
-
-static char *
-target2name (int *target)
-{
-	VControl_NameBinding *b = nametable;
-	while (b->target)
-	{
-		if (target == b->target)
-		{
-			return b->name;
-		}
-		++b;
-	}
-	return NULL;
-}
-
-static int *
-name2target (char *name)
-{
-	VControl_NameBinding *b = nametable;
-	while (b->target)
-	{
-		if (!stricmp (name, b->name))
-		{
-			return b->target;
-		}
-		++b;
-	}
-	return NULL;
-}
-
-static void
-dump_keybindings (uio_Stream *out, keybinding *kb, char *name)
-{
-	while (kb != NULL)
-	{
-		char *targetname = target2name (kb->target);
-		WriteResFile (targetname, 1, strlen (targetname), out);
-		PutResFileChar (':', out);
-		PutResFileChar (' ', out);
-		WriteResFile (name, 1, strlen (name), out);
-		PutResFileNewline (out);
-
-		kb = kb->next;
-	}
-}
-
-void
-VControl_Dump (uio_Stream *out)
-{
-	int i;
-	char namebuffer[64];
-
-	sprintf (namebuffer, "version %d", version);
-	WriteResFile (namebuffer, 1, strlen (namebuffer), out);
-	PutResFileNewline (out);
-
-	/* Print out keyboard bindings */
-	for (i = 0; i < num_sdl_keys; i++)
-	{
-		keybinding *kb = bindings[i];		
-		if (kb != NULL)
-		{
-			sprintf (namebuffer, "key %s", VControl_code2name (i));
-			dump_keybindings (out, kb, namebuffer);
-		}
-	}
-
-#ifdef HAVE_JOYSTICK
-	/* Print out joystick bindings */
-	for (i = 0; i < joycount; i++)
-	{
-		if (joysticks[i].stick)
-		{
-			int j;
-
-			sprintf (namebuffer, "joystick %d threshold %d", i, joysticks[i].threshold);
-			WriteResFile (namebuffer, 1, strlen (namebuffer), out);
-			PutResFileNewline (out);
-			
-			for (j = 0; j < joysticks[i].numaxes; j++)
-			{
-				sprintf (namebuffer, "joystick %d axis %d negative", i, j);
-				dump_keybindings (out, joysticks[i].axes[j].neg, namebuffer);
-				sprintf (namebuffer, "joystick %d axis %d positive", i, j);
-				dump_keybindings (out, joysticks[i].axes[j].pos, namebuffer);
-			}
-			for (j = 0; j < joysticks[i].numbuttons; j++)
-			{
-				keybinding *kb = joysticks[i].buttons[j];
-				if (kb != NULL)
-				{
-					sprintf (namebuffer, "joystick %d button %d", i, j);
-					dump_keybindings (out, kb, namebuffer);
-				}
-			}
-			for (j = 0; j < joysticks[i].numhats; j++)
-			{
-				sprintf (namebuffer, "joystick %d hat %d left", i, j);
-				dump_keybindings (out, joysticks[i].hats[j].left, namebuffer);
-				sprintf (namebuffer, "joystick %d hat %d right", i, j);
-				dump_keybindings (out, joysticks[i].hats[j].right, namebuffer);
-				sprintf (namebuffer, "joystick %d hat %d up", i, j);
-				dump_keybindings (out, joysticks[i].hats[j].up, namebuffer);
-				sprintf (namebuffer, "joystick %d hat %d down", i, j);
-				dump_keybindings (out, joysticks[i].hats[j].down, namebuffer);
-			}
-		}
-	}
-#endif /* HAVE_JOYSTICK */
-
-#ifdef VCONTROL_DEBUG
-	/* Print out allocation data */
-	{
-		keypool bp = pool;
-		i = 0;
-		while (bp != NULL)
-		{
-			fprintf (out, "# Internal Debug: Chunk #%i: %d slots remaining.\n", i, bp->remaining);
-			i++;
-			bp = bp->next;
-		}
-		fprintf (out, "# Internal Debug: %d chunks allocated.\n", i);
-	}
-#endif
-}
-
-/* Iterator routines.  iter_target holds the target keybinding.
-   iter_device is -1 for the keyboard, otherwise it is joystick
-   #(iter_device/3).  (iter_device%3) gives whether we're checking the
-   joystick's axes (0), buttons (1), or hats (2). */
-
-static int *iter_target;
-static int iter_device, iter_index;
-
-void
-VControl_StartIter (int *target)
-{
-	iter_target = target;
-	iter_device = -1;
-	iter_index = 0;
-}
-
-void
-VControl_StartIterByName (char *targetname)
-{
-	VControl_StartIter (name2target (targetname));
-}
-
-int
-VControl_NextBinding (VCONTROL_GESTURE *gesture)
-{
-	if ((gesture == NULL) || (iter_target == NULL)
-			|| iter_device >= (joycount * 3))
-		return 0;
-	while (iter_device < (joycount * 3))
-	{
-		if (iter_device == -1) /* keyboard */
-		{
-			keybinding *kb = bindings[iter_index];
-			int done = 0;
-			while (kb != NULL) 
-			{
-				if (kb->target == iter_target)
-				{
-					gesture->type = VCONTROL_KEY;
-					gesture->gesture.key = iter_index;
-					done = 1;
-				}
-				kb = kb->next;
-			}
-			if (++iter_index == num_sdl_keys)
-			{
-				iter_device = 0;
-				iter_index = 0;
-			}
-			if (done) return 1;
-		}
-#ifdef HAVE_JOYSTICK
-		else
-		{
-			int i = iter_device / 3;
-			int t = iter_device % 3;
-			if (!joysticks[i].stick)  /* Joystick wasn't opened; this binding is dead */
-			{
-				iter_device++;
-				iter_index = 0;
-			}
-			else
-			{
-				int done = 0;
-				switch (t)
-				{
-				case 0: { /* Axes */
-					int axis = iter_index / 2;
-					int dir = iter_index % 2;
-					if (axis >= joysticks[i].numaxes)
-					{
-						iter_device++;
-						iter_index = 0;
-					}
-					else
-					{
-						keybinding *kb = (dir) ? joysticks[i].axes[axis].pos : joysticks[i].axes[axis].neg;
-						while (kb != NULL) 
-						{
-							if (kb->target == iter_target)
-							{
-								done = 1;
-								gesture->type = VCONTROL_JOYAXIS;
-								gesture->gesture.axis.port = i;
-								gesture->gesture.axis.index = axis;
-								gesture->gesture.axis.polarity = (dir) ? 1 : -1;
-							}
-							kb = kb->next;
-						}
-						iter_index++;
-					}
-					break;
-				}
-				case 1: { /* Buttons */
-					keybinding *kb = joysticks[i].buttons[iter_index];
-					if (iter_index >= joysticks[i].numbuttons)
-					{
-						iter_device++;
-						iter_index = 0;
-					}
-					else
-					{
-						while (kb != NULL) 
-						{
-							if (kb->target == iter_target)
-							{
-								gesture->type = VCONTROL_JOYBUTTON;
-								gesture->gesture.button.port = i;
-								gesture->gesture.button.index = iter_index;
-								done = 1;
-							}
-							kb = kb->next;
-						}
-						iter_index++;
-					}
-					break;
-				}
-				case 2: { /* Hats */
-					int hat = iter_index / 4;
-					int hatd = iter_index % 4;
-					if (hat >= joysticks[i].numhats)
-					{
-						iter_device++;
-						iter_index = 0;
-					}
-					else
-					{
-						keybinding *kb;
-						Uint8 targetdir;
-						switch (hatd) 
-						{
-						case 0: kb = joysticks[i].hats[hat].left; targetdir = SDL_HAT_LEFT; break;
-						case 1: kb = joysticks[i].hats[hat].right; targetdir = SDL_HAT_RIGHT; break;
-						case 2: kb = joysticks[i].hats[hat].up; targetdir = SDL_HAT_UP; break;
-						default: kb = joysticks[i].hats[hat].down; targetdir = SDL_HAT_DOWN; break;
-						}
-						while (kb != NULL) 
-						{
-							if (kb->target == iter_target)
-							{
-								done = 1;
-								gesture->type = VCONTROL_JOYHAT;
-								gesture->gesture.hat.port = i;
-								gesture->gesture.hat.index = hat;
-								gesture->gesture.hat.dir = targetdir;
-							}
-							kb = kb->next;
-						}
-						iter_index++;
-					}
-					break;
-				}
-				}
-				if (done) return 1;
-			}
-		}
-#endif /* HAVE_JOYSTICK */
-	}
-	return 0;
-}
-
 /* Tracking the last interesting event */
 
 void
-VControl_ClearEvent (void)
+VControl_ClearGesture (void)
 {
 	event_ready = 0;
 }
 
 int
-VControl_GetLastEvent (SDL_Event *e)
+VControl_GetLastGesture (VCONTROL_GESTURE *g)
 {
-	if (event_ready && e != NULL)
+	if (event_ready && g != NULL)
 	{
-		*e = last_interesting;
+		event2gesture(&last_interesting, g);
 	}
 	return event_ready;
 }		
@@ -1336,43 +1076,6 @@ next_token (parse_state *state)
 }
 
 static void
-next_line (parse_state *state, uio_Stream *in)
-{
-	int i, ch = 0;
-	state->linenum++;
-	for (i = 0; i < LINE_SIZE-1; i++)
-	{
-		if (uio_feof (in))
-		{
-			break;
-		}
-		ch = uio_fgetc (in);
-		if (ch == '#' || ch == '\n' || ch == EOF)
-		{
-			/* If this line is blank or all commented, include some
-			 * whitespace.  This lets us detect EOF as a completely
-			 * blank line. */
-			if (i==0) 
-			{
-				state->line[i] = '\n';
-				i++;
-			} 
-			break;
-		}
-		state->line[i] = ch;
-	}
-	state->line[i] = '\0';
-	/* Skip to end of line */
-	while (ch != '\n' && !uio_feof (in))
-	{
-		ch = uio_fgetc (in);
-	}
-	state->token[0] = 0;
-	state->index = 0;
-	state->error = 0;
-}
-
-static void
 expected_error (parse_state *state, char *expected)
 {
 	log_add (log_Warning, "VControl: Expected '%s' on config file line %d",
@@ -1383,7 +1086,7 @@ expected_error (parse_state *state, char
 static void
 consume (parse_state *state, char *expected)
 {
-	if (stricmp (expected, state->token))
+	if (strcasecmp (expected, state->token))
 	{
 		expected_error (state, expected);
 	}
@@ -1404,45 +1107,6 @@ consume_keyname (parse_state *state)
 	return keysym;
 }
 
-static int *
-consume_idname (parse_state *state)
-{
-	int *result = NULL;
-	int index = 0;
-	while (state->token[index]) 
-	{
-		index++;
-	}
-
-	if (index == 0)
-	{
-		log_add (log_Debug, "VControl: Can't happen: blank token to consume_idname (line %d)",
-				state->linenum);
-		state->error = 1;
-		return NULL;
-	}
-
-	index--;
-	if (state->token[index] != ':')
-	{
-		expected_error (state, ":");
-		return NULL;
-	}
-
-	state->token[index] = 0;  /* remove trailing colon */
-
-	result = name2target (state->token);
-
-	if (!result)
-	{
-		log_add (log_Warning, "VControl: Illegal command type '%s' on config file line %d",
-				state->token, state->linenum);
-		state->error = 1;
-	}
-	next_token (state);
-	return result;
-}
-
 static int
 consume_num (parse_state *state)
 {
@@ -1462,11 +1126,11 @@ static int
 consume_polarity (parse_state *state)
 {
 	int result = 0;
-	if (!stricmp (state->token, "positive"))
+	if (!strcasecmp (state->token, "positive"))
 	{
 		result = 1;
 	}
-	else if (!stricmp (state->token, "negative"))
+	else if (!strcasecmp (state->token, "negative"))
 	{
 		result = -1;
 	}
@@ -1482,20 +1146,19 @@ static Uint8
 consume_dir (parse_state *state)
 {
 	Uint8 result = 0;
-#ifdef HAVE_JOYSTICK
-	if (!stricmp (state->token, "left"))
+	if (!strcasecmp (state->token, "left"))
 	{
 		result = SDL_HAT_LEFT;
 	}
-	else if (!stricmp (state->token, "right"))
+	else if (!strcasecmp (state->token, "right"))
 	{
 		result = SDL_HAT_RIGHT;
 	}
-	else if (!stricmp (state->token, "up"))
+	else if (!strcasecmp (state->token, "up"))
 	{
 		result = SDL_HAT_UP;
 	}
-	else if (!stricmp (state->token, "down"))
+	else if (!strcasecmp (state->token, "down"))
 	{
 		result = SDL_HAT_DOWN;
 	}
@@ -1503,20 +1166,19 @@ consume_dir (parse_state *state)
 	{
 		expected_error (state, "left', 'right', 'up' or 'down");
 	}
-#endif /* HAVE_JOYSTICK */
 	next_token (state);
 	return result;
 }
 
 static void
-parse_joybinding (parse_state *state, int *target)
+parse_joybinding (parse_state *state, VCONTROL_GESTURE *gesture)
 {
 	int sticknum;
 	consume (state, "joystick");
 	sticknum = consume_num (state);
 	if (!state->error)
 	{
-		if (!stricmp (state->token, "axis"))
+		if (!strcasecmp (state->token, "axis"))
 		{
 			int axisnum;
 			consume (state, "axis");
@@ -1526,29 +1188,26 @@ parse_joybinding (parse_state *state, in
 				int polarity = consume_polarity (state);
 				if (!state->error)
 				{
-					if (VControl_AddJoyAxisBinding (sticknum, axisnum, polarity, target))
-					{
-						// Don't count this as an error
-						// state->error = 1;
-					}
+					gesture->type = VCONTROL_JOYAXIS;
+					gesture->gesture.axis.port = sticknum;
+					gesture->gesture.axis.index = axisnum;
+					gesture->gesture.axis.polarity = polarity;
 				}
 			}
 		} 
-		else if (!stricmp (state->token, "button"))
+		else if (!strcasecmp (state->token, "button"))
 		{
 			int buttonnum;
 			consume (state, "button");
 			buttonnum = consume_num (state);
 			if (!state->error)
 			{
-				if (VControl_AddJoyButtonBinding (sticknum, buttonnum, target))
-				{
-					// Don't count this as an error
-					// state->error = 1;
-				}
+				gesture->type = VCONTROL_JOYBUTTON;
+				gesture->gesture.button.port = sticknum;
+				gesture->gesture.button.index = buttonnum;
 			}
 		}
-		else if (!stricmp (state->token, "hat"))
+		else if (!strcasecmp (state->token, "hat"))
 		{
 			int hatnum;
 			consume (state, "hat");
@@ -1558,11 +1217,10 @@ parse_joybinding (parse_state *state, in
 				Uint8 dir = consume_dir (state);
 				if (!state->error)
 				{
-					if (VControl_AddJoyHatBinding (sticknum, hatnum, dir, target))
-					{
-						// Don't count this as an error
-						// state->error = 1;
-					}
+					gesture->type = VCONTROL_JOYHAT;
+					gesture->gesture.hat.port = sticknum;
+					gesture->gesture.hat.index = hatnum;
+					gesture->gesture.hat.dir = dir;
 				}
 			}
 		}
@@ -1574,161 +1232,66 @@ parse_joybinding (parse_state *state, in
 }
 
 static void
-parse_binding (parse_state *state)
-{
-	int *target = consume_idname (state);
-	if (!state->error)
-	{
-		if (!stricmp (state->token, "key"))
-		{
-			/* Parse key binding */
-			int keysym;
-			consume (state, "key");
-			keysym = consume_keyname (state);
-			if (!state->error)
-			{
-				if (VControl_AddKeyBinding (keysym, target))
-				{
-					state->error = 1;
-				}
-			}
-		}
-		else if (!stricmp (state->token, "joystick"))
-		{
-			parse_joybinding (state, target);
-		}
-		else
-		{
-			expected_error (state, "key' or 'joystick");
-		}
-	}
-}
-
-static void
-parse_config_line (parse_state *state)
+parse_gesture (parse_state *state, VCONTROL_GESTURE *gesture)
 {
-	state->error = 0;
-	next_token (state);
-	if (!state->token[0])
-	{
-		/* Blank line, skip it */
-		return;
-	}
-	if (!stricmp (state->token, "joystick"))
+	gesture->type = VCONTROL_NONE; /* Default to error */
+	if (!strcasecmp (state->token, "key"))
 	{
-		int sticknum, threshold = 0;
-		consume (state, "joystick");
-		sticknum = consume_num (state);
-		if (!state->error) consume (state, "threshold");
-		if (!state->error) threshold = consume_num (state);
+		/* Parse key binding */
+		int keysym;
+		consume (state, "key");
+		keysym = consume_keyname (state);
 		if (!state->error)
 		{
-			if (VControl_SetJoyThreshold (sticknum, threshold))
-			{
-				// Don't count this as an error
-				// state->error = 1;
-			}
+			gesture->type = VCONTROL_KEY;
+			gesture->gesture.key = keysym;
 		}
-		if (!state->error)
-		{
-			validlines++;
-		}
-		return;
 	}
-	if (!stricmp (state->token, "version"))
+	else if (!strcasecmp (state->token, "joystick"))
 	{
-		consume (state, "version");
-		version = consume_num (state);
-		if (!state->error)
-		{
-			validlines++;
-		}
-		return;
+		parse_joybinding (state, gesture);
 	}
-	/* Otherwise, it must be a binding */
-	parse_binding (state);
-	if (!state->error)
+	else
 	{
-		validlines++;
+		expected_error (state, "key' or 'joystick");
 	}
 }
 
-int
-VControl_ReadConfiguration (uio_Stream *in)
+void
+VControl_ParseGesture (VCONTROL_GESTURE *g, const char *spec)
 {
 	parse_state ps;
-	if (!in)
-	{
-		log_add (log_Warning, "VControl: Invalid configuration file stream");
-		return 1;
-	}
-	ps.linenum = 0;
-	errors = version = validlines = 0;
-	while (1)
-	{
-		next_line (&ps, in);
-		if (!ps.line[0])
-			break;
-		parse_config_line (&ps);
-		if (ps.error)
-		{
-			errors++;
-		}
-	}
-	return errors;
-}
 
-int
-VControl_GetErrorCount (void)
-{
-	return errors;
-}
-
-int
-VControl_GetValidCount (void)
-{
-	return validlines;
+	strncpy (ps.line, spec, LINE_SIZE);
+	ps.line[LINE_SIZE] = '\0';
+	ps.index = ps.error = 0;
+	ps.linenum = -1;
+
+	next_token (&ps);
+	parse_gesture (&ps, g);
+	if (ps.error)
+		printf ("Error parsing %s\n", spec);
 }
 
 int
-VControl_GetConfigFileVersion (void)
-{
-	return version;
-}
-
-void
-VControl_SetConfigFileVersion (int v)
+VControl_DumpGesture (char *buf, int n, VCONTROL_GESTURE *g)
 {
-	version = v;
-}
-
-#if 0
-/* This was kinda handy for proving (lack of) buffer overrun
- * vulnerabilities, but there's no real need for it otherwise. */
-void
-VControl_TokenizeFile (FILE *in)
-{
-	parse_state ps;
-	if (!in)
+	switch (g->type) 
 	{
-		log_add (log_Warning, "VControl: Invalid configuration file stream");
-		return;
-	}
-	ps.linenum = 0;
-	while (1)
-	{
-		_next_line (&ps, in);
-		if (!ps.line[0])
-			break;
-		printf ("%3d:", ps.linenum);
-		while (1)
-		{
-			_next_token (&ps);
-			if (!ps.token[0])
-				break;
-			printf (" \"%s\"", ps.token);
-		}
-		printf ("\n");
+	case VCONTROL_KEY:
+		return snprintf (buf, n, "key %s", VControl_code2name (g->gesture.key));
+	case VCONTROL_JOYAXIS:
+		return snprintf (buf, n, "joystick %d axis %d %s", g->gesture.axis.port, g->gesture.axis.index, 
+				(g->gesture.axis.polarity > 0) ? "positive" : "negative");
+	case VCONTROL_JOYBUTTON:
+		return snprintf (buf, n, "joystick %d button %d", g->gesture.button.port, g->gesture.button.index);
+	case VCONTROL_JOYHAT:
+		return snprintf (buf, n, "joystick %d hat %d %s", g->gesture.hat.port, g->gesture.hat.index, 
+				(g->gesture.hat.dir == SDL_HAT_UP) ? "up" :
+				((g->gesture.hat.dir == SDL_HAT_DOWN) ? "down" : 
+				((g->gesture.hat.dir == SDL_HAT_LEFT) ? "left" : "right")));
+	default:
+		buf[0] = '\0';
+		return 0;
 	}
 }
-#endif
diff -ruNp src.orig/sc2code/libs/input/sdl/vcontrol.h src/sc2code/libs/input/sdl/vcontrol.h
--- src.orig/sc2code/libs/input/sdl/vcontrol.h	2017-11-08 16:49:30 -0600
+++ src/sc2code/libs/input/sdl/vcontrol.h	2017-11-08 16:49:57 -0600
@@ -18,7 +18,6 @@
 #define _VCONTROL_H_
 
 #include "port.h"
-#include "libs/uio.h"
 #include SDL_INCLUDE(SDL.h)
 
 /* Initialization routines */
@@ -29,6 +28,7 @@ void VControl_Uninit (void);
    iterators and used to construct bindings. */
 
 typedef enum {
+	VCONTROL_NONE,
 	VCONTROL_KEY,
 	VCONTROL_JOYAXIS,
 	VCONTROL_JOYBUTTON,
@@ -47,9 +47,6 @@ typedef struct {
 } VCONTROL_GESTURE;			
 
 /* Control of bindings */
-int  VControl_AddBinding (SDL_Event *e, int *target);
-void VControl_RemoveBinding (SDL_Event *e, int *target);
-
 int  VControl_AddGestureBinding (VCONTROL_GESTURE *g, int *target);
 void VControl_RemoveGestureBinding (VCONTROL_GESTURE *g, int *target);
 
@@ -65,6 +62,9 @@ void VControl_RemoveJoyHatBinding (int p
 
 void VControl_RemoveAllBindings (void);
 
+/* Signal to VControl that a frame is about to begin. */
+void VControl_BeginFrame (void);
+
 /* The listener.  Routines besides HandleEvent may be used to 'fake' inputs without 
  * fabricating an SDL_Event. 
  */
@@ -79,46 +79,24 @@ void VControl_ProcessJoyHat (int port, i
 /* Force the input into the blank state.  For preventing "sticky" keys. */
 void VControl_ResetInput (void);
 
-/* Name control.  To provide a table of names and bindings, declare
- * a persistent, unchanging array of VControl_NameBinding and end it
- * with a {0, 0} entry.  Pass this array to VControl_RegisterNameTable.
- * Only one name table may be registered at a time; subsequent calls
- * replace the previous values. */
-
-typedef struct vcontrol_namebinding {
-	char *name;
-	int *target;
-} VControl_NameBinding;
-
-void VControl_RegisterNameTable (VControl_NameBinding *table);
-
-/* Version number control */
-int VControl_GetConfigFileVersion (void);
-void VControl_SetConfigFileVersion (int v);
-
-/* Dump a configuration file corresponding to the current bindings and names. */
-void VControl_Dump (uio_Stream *out);
-void VControl_SaveFilename (uio_DirHandle *path, const char *fname);
+/* Translate between gestures and string representations thereof. */
+void VControl_ParseGesture (VCONTROL_GESTURE *g, const char *spec);
+int VControl_DumpGesture (char *buf, int n, VCONTROL_GESTURE *g);
 
+/* Tracking the "last interesting gesture."  Used to poll to find new
+   control keys. */
 
-/* Read a configuration file.  Returns number of errors encountered. */
-int VControl_ReadConfiguration (uio_Stream *in);
-int VControl_GetErrorCount (void);
-int VControl_GetValidCount (void);
-
-
-/* Iterator control.  Start an iteration with StartIter or
-   StartIterByName; then call NextBindingName until it returns 0.  
-   Produces gestures. */
-
-void VControl_StartIter (int *target);
-void VControl_StartIterByName (char *targetname);
-int  VControl_NextBinding (VCONTROL_GESTURE *gesture);
+void VControl_ClearGesture (void);
+int  VControl_GetLastGesture (VCONTROL_GESTURE *g);
 
-/* Tracking the "last interesting event."  Used to poll to find new
-   control keys. */
+/* Constants for handling the "Start bit."  If a gesture is made, and
+ * then ends, within a single frame, it will still, for one frame,
+ * have a nonzero value.  This is because Bit 16 will be on for the
+ * first frame a gesture is struck.  This bit is cleared when
+ * VControl_BeginFrame() is called.  These constants are used to mask
+ * out results if necessary. */
 
-void VControl_ClearEvent (void);
-int  VControl_GetLastEvent (SDL_Event *e);
+#define VCONTROL_STARTBIT 0x10000
+#define VCONTROL_MASK     0x0FFFF
 
 #endif
diff -ruNp src.orig/sc2code/libs/input/sdl/vcontrol_malloc.h src/sc2code/libs/input/sdl/vcontrol_malloc.h
--- src.orig/sc2code/libs/input/sdl/vcontrol_malloc.h	2017-11-08 16:49:30 -0600
+++ src/sc2code/libs/input/sdl/vcontrol_malloc.h	1969-12-31 18:00:00 -0600
@@ -1,21 +0,0 @@
-/*
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-/* re-#define these to use your own allocators. */
-#include "misc.h"
-
-#define vctrl_malloc    HMalloc
-#define vctrl_free      HFree
diff -ruNp src.orig/sc2code/libs/math/Makeinfo src/sc2code/libs/math/Makeinfo
--- src.orig/sc2code/libs/math/Makeinfo	2017-11-08 16:49:30 -0600
+++ src/sc2code/libs/math/Makeinfo	2017-11-08 16:49:58 -0600
@@ -1 +1 @@
-uqm_CFILES="random.c sqrt.c"
+uqm_CFILES="random.c random2.c sqrt.c"
diff -ruNp src.orig/sc2code/libs/math/random.c src/sc2code/libs/math/random.c
--- src.orig/sc2code/libs/math/random.c	2017-11-08 16:49:30 -0600
+++ src/sc2code/libs/math/random.c	2017-11-08 16:49:58 -0600
@@ -61,7 +61,8 @@ static DWORD seed = 12345L; /* random nu
 DWORD
 TFB_Random (void)
 {
-	if ((seed = A * (seed % Q) - R * (seed / Q)) > M)
+	seed = A * (seed % Q) - R * (seed / Q);
+	if (seed > M)
 		return (seed -= M);
 	else if (seed)
 		return (seed);
diff -ruNp src.orig/sc2code/libs/math/random.h src/sc2code/libs/math/random.h
--- src.orig/sc2code/libs/math/random.h	2017-11-08 16:49:30 -0600
+++ src/sc2code/libs/math/random.h	2017-11-08 16:49:58 -0600
@@ -26,6 +26,9 @@
 * Copyright (c) 1989, Robert Leyland and Scott Anderson
 ****************************************************************************/
 
+#ifndef _RANDOM_H
+#define _RANDOM_H
+
 /* ----------------------------DEFINES------------------------------------ */
 
 #define RAND(n) ( (int) ( (unsigned int)TFB_Random() % (n) ) )
@@ -38,3 +41,22 @@
 DWORD TFB_SeedRandom (DWORD seed);
 DWORD TFB_Random (void);
 
+
+typedef struct RandomContext RandomContext;
+
+#ifdef RANDOM2_INTERNAL
+struct RandomContext {
+	DWORD seed;
+};
+#endif
+
+RandomContext *RandomContext_New (void);
+void RandomContext_Delete (RandomContext *context);
+RandomContext *RandomContext_Copy (const RandomContext *source);
+DWORD RandomContext_Random (RandomContext *context);
+DWORD RandomContext_SeedRandom (RandomContext *context, DWORD new_seed);
+
+
+#endif  /* _RANDOM_H */
+
+
diff -ruNp src.orig/sc2code/libs/math/random2.c src/sc2code/libs/math/random2.c
--- src.orig/sc2code/libs/math/random2.c	1969-12-31 18:00:00 -0600
+++ src/sc2code/libs/math/random2.c	2017-11-08 16:49:58 -0600
@@ -0,0 +1,85 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+// This file contains variants of the random functions in random.c
+// that store the state of the RNG in a context, allowing for multiple
+// independant RNGs to be used simultaneously.
+// The RNG behavior itself is the same.
+
+#include "libs/compiler.h"
+
+#define RANDOM2_INTERNAL
+#include "random.h"
+
+#include "libs/misc.h"
+
+
+#define A 16807 /* a relatively prime number -- also M div Q */
+#define M 2147483647 /* 0xFFFFFFFF / 2 */
+#define Q 127773 /* M div A */
+#define R 2836 /* M mod A */
+
+RandomContext *
+RandomContext_New (void)
+{
+	RandomContext *result = (RandomContext *) HMalloc (sizeof (RandomContext));
+	result->seed = 12345;
+	return result;
+}
+
+void
+RandomContext_Delete (RandomContext *context)
+{
+	HFree ((void *) context);
+}
+
+RandomContext *
+RandomContext_Copy (const RandomContext *source)
+{
+	RandomContext *result = (RandomContext *) HMalloc (sizeof (RandomContext));
+	*result = *source;
+	return result;
+}
+
+DWORD
+RandomContext_Random (RandomContext *context)
+{
+	context->seed = A * (context->seed % Q) - R * (context->seed / Q);
+	if (context->seed > M) {
+		context->seed -= M;
+	} else if (context->seed == 0)
+		context->seed = 1;
+
+	return context->seed;
+}
+
+DWORD
+RandomContext_SeedRandom (RandomContext *context, DWORD new_seed)
+{
+	DWORD old_seed;
+
+	/* coerce the seed to be in the range 1..M */
+	if (new_seed == 0) /* 0 becomes 1 */
+		new_seed = 1;
+	else if (new_seed > M) /* and less than M */
+		new_seed -= M;
+
+	old_seed = context->seed;
+	context->seed = new_seed;
+	return old_seed;
+}
+
+
diff -ruNp src.orig/sc2code/libs/md5/Makeinfo src/sc2code/libs/md5/Makeinfo
--- src.orig/sc2code/libs/md5/Makeinfo	1969-12-31 18:00:00 -0600
+++ src/sc2code/libs/md5/Makeinfo	2017-11-08 16:49:58 -0600
@@ -0,0 +1,2 @@
+uqm_CFILES="md5.c"
+
diff -ruNp src.orig/sc2code/libs/md5/README src/sc2code/libs/md5/README
--- src.orig/sc2code/libs/md5/README	1969-12-31 18:00:00 -0600
+++ src/sc2code/libs/md5/README	2017-11-08 16:49:58 -0600
@@ -0,0 +1,6 @@
+The files md5.c and md5.h from this directory come from the GNU TLS
+library (http://www.gnutls.org/), version 1.6.1.
+
+These files are unchanged, except for the is the replacement of the LGPL
+notices by GPL notices.
+
diff -ruNp src.orig/sc2code/libs/md5/md5.c src/sc2code/libs/md5/md5.c
--- src.orig/sc2code/libs/md5/md5.c	1969-12-31 18:00:00 -0600
+++ src/sc2code/libs/md5/md5.c	2017-11-08 16:49:58 -0600
@@ -0,0 +1,452 @@
+/* Functions to compute MD5 message digest of files or memory blocks.
+   according to the definition of MD5 in RFC 1321 from April 1992.
+   Copyright (C) 1995,1996,1997,1999,2000,2001,2005,2006
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+  */
+
+/* Written by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.  */
+
+#include <config.h>
+
+#include "md5.h"
+
+#include <stddef.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+
+#if USE_UNLOCKED_IO
+# include "unlocked-io.h"
+#endif
+
+#ifdef _LIBC
+# include <endian.h>
+# if __BYTE_ORDER == __BIG_ENDIAN
+#  define WORDS_BIGENDIAN 1
+# endif
+/* We need to keep the namespace clean so define the MD5 function
+   protected using leading __ .  */
+# define md5_init_ctx __md5_init_ctx
+# define md5_process_block __md5_process_block
+# define md5_process_bytes __md5_process_bytes
+# define md5_finish_ctx __md5_finish_ctx
+# define md5_read_ctx __md5_read_ctx
+# define md5_stream __md5_stream
+# define md5_buffer __md5_buffer
+#endif
+
+#ifdef WORDS_BIGENDIAN
+# define SWAP(n)							\
+    (((n) << 24) | (((n) & 0xff00) << 8) | (((n) >> 8) & 0xff00) | ((n) >> 24))
+#else
+# define SWAP(n) (n)
+#endif
+
+#define BLOCKSIZE 4096
+#if BLOCKSIZE % 64 != 0
+# error "invalid BLOCKSIZE"
+#endif
+
+/* This array contains the bytes used to pad the buffer to the next
+   64-byte boundary.  (RFC 1321, 3.1: Step 1)  */
+static const unsigned char fillbuf[64] = { 0x80, 0 /* , 0, 0, ...  */ };
+
+
+/* Initialize structure containing state of computation.
+   (RFC 1321, 3.3: Step 3)  */
+void
+md5_init_ctx (struct md5_ctx *ctx)
+{
+  ctx->A = 0x67452301;
+  ctx->B = 0xefcdab89;
+  ctx->C = 0x98badcfe;
+  ctx->D = 0x10325476;
+
+  ctx->total[0] = ctx->total[1] = 0;
+  ctx->buflen = 0;
+}
+
+/* Put result from CTX in first 16 bytes following RESBUF.  The result
+   must be in little endian byte order.
+
+   IMPORTANT: On some systems it is required that RESBUF is correctly
+   aligned for a 32-bit value.  */
+void *
+md5_read_ctx (const struct md5_ctx *ctx, void *resbuf)
+{
+  ((uint32_t *) resbuf)[0] = SWAP (ctx->A);
+  ((uint32_t *) resbuf)[1] = SWAP (ctx->B);
+  ((uint32_t *) resbuf)[2] = SWAP (ctx->C);
+  ((uint32_t *) resbuf)[3] = SWAP (ctx->D);
+
+  return resbuf;
+}
+
+/* Process the remaining bytes in the internal buffer and the usual
+   prolog according to the standard and write the result to RESBUF.
+
+   IMPORTANT: On some systems it is required that RESBUF is correctly
+   aligned for a 32-bit value.  */
+void *
+md5_finish_ctx (struct md5_ctx *ctx, void *resbuf)
+{
+  /* Take yet unprocessed bytes into account.  */
+  uint32_t bytes = ctx->buflen;
+  size_t size = (bytes < 56) ? 64 / 4 : 64 * 2 / 4;
+
+  /* Now count remaining bytes.  */
+  ctx->total[0] += bytes;
+  if (ctx->total[0] < bytes)
+    ++ctx->total[1];
+
+  /* Put the 64-bit file length in *bits* at the end of the buffer.  */
+  ctx->buffer[size - 2] = SWAP (ctx->total[0] << 3);
+  ctx->buffer[size - 1] = SWAP ((ctx->total[1] << 3) | (ctx->total[0] >> 29));
+
+  memcpy (&((char *) ctx->buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);
+
+  /* Process last bytes.  */
+  md5_process_block (ctx->buffer, size * 4, ctx);
+
+  return md5_read_ctx (ctx, resbuf);
+}
+
+/* Compute MD5 message digest for bytes read from STREAM.  The
+   resulting message digest number will be written into the 16 bytes
+   beginning at RESBLOCK.  */
+int
+md5_stream (FILE *stream, void *resblock)
+{
+  struct md5_ctx ctx;
+  char buffer[BLOCKSIZE + 72];
+  size_t sum;
+
+  /* Initialize the computation context.  */
+  md5_init_ctx (&ctx);
+
+  /* Iterate over full file contents.  */
+  while (1)
+    {
+      /* We read the file in blocks of BLOCKSIZE bytes.  One call of the
+         computation function processes the whole buffer so that with the
+         next round of the loop another block can be read.  */
+      size_t n;
+      sum = 0;
+
+      /* Read block.  Take care for partial reads.  */
+      while (1)
+	{
+	  n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);
+
+	  sum += n;
+
+	  if (sum == BLOCKSIZE)
+	    break;
+
+	  if (n == 0)
+	    {
+	      /* Check for the error flag IFF N == 0, so that we don't
+	         exit the loop after a partial read due to e.g., EAGAIN
+	         or EWOULDBLOCK.  */
+	      if (ferror (stream))
+		return 1;
+	      goto process_partial_block;
+	    }
+
+	  /* We've read at least one byte, so ignore errors.  But always
+	     check for EOF, since feof may be true even though N > 0.
+	     Otherwise, we could end up calling fread after EOF.  */
+	  if (feof (stream))
+	    goto process_partial_block;
+	}
+
+      /* Process buffer with BLOCKSIZE bytes.  Note that
+         BLOCKSIZE % 64 == 0
+       */
+      md5_process_block (buffer, BLOCKSIZE, &ctx);
+    }
+
+process_partial_block:
+
+  /* Process any remaining bytes.  */
+  if (sum > 0)
+    md5_process_bytes (buffer, sum, &ctx);
+
+  /* Construct result in desired memory.  */
+  md5_finish_ctx (&ctx, resblock);
+  return 0;
+}
+
+/* Compute MD5 message digest for LEN bytes beginning at BUFFER.  The
+   result is always in little endian byte order, so that a byte-wise
+   output yields to the wanted ASCII representation of the message
+   digest.  */
+void *
+md5_buffer (const char *buffer, size_t len, void *resblock)
+{
+  struct md5_ctx ctx;
+
+  /* Initialize the computation context.  */
+  md5_init_ctx (&ctx);
+
+  /* Process whole buffer but last len % 64 bytes.  */
+  md5_process_bytes (buffer, len, &ctx);
+
+  /* Put result in desired memory area.  */
+  return md5_finish_ctx (&ctx, resblock);
+}
+
+
+void
+md5_process_bytes (const void *buffer, size_t len, struct md5_ctx *ctx)
+{
+  /* When we already have some bits in our internal buffer concatenate
+     both inputs first.  */
+  if (ctx->buflen != 0)
+    {
+      size_t left_over = ctx->buflen;
+      size_t add = 128 - left_over > len ? len : 128 - left_over;
+
+      memcpy (&((char *) ctx->buffer)[left_over], buffer, add);
+      ctx->buflen += add;
+
+      if (ctx->buflen > 64)
+	{
+	  md5_process_block (ctx->buffer, ctx->buflen & ~63, ctx);
+
+	  ctx->buflen &= 63;
+	  /* The regions in the following copy operation cannot overlap.  */
+	  memcpy (ctx->buffer,
+		  &((char *) ctx->buffer)[(left_over + add) & ~63],
+		  ctx->buflen);
+	}
+
+      buffer = (const char *) buffer + add;
+      len -= add;
+    }
+
+  /* Process available complete blocks.  */
+  if (len >= 64)
+    {
+#if !_STRING_ARCH_unaligned
+# define alignof(type) offsetof (struct { char c; type x; }, x)
+# define UNALIGNED_P(p) (((size_t) p) % alignof (uint32_t) != 0)
+      if (UNALIGNED_P (buffer))
+	while (len > 64)
+	  {
+	    md5_process_block (memcpy (ctx->buffer, buffer, 64), 64, ctx);
+	    buffer = (const char *) buffer + 64;
+	    len -= 64;
+	  }
+      else
+#endif
+	{
+	  md5_process_block (buffer, len & ~63, ctx);
+	  buffer = (const char *) buffer + (len & ~63);
+	  len &= 63;
+	}
+    }
+
+  /* Move remaining bytes in internal buffer.  */
+  if (len > 0)
+    {
+      size_t left_over = ctx->buflen;
+
+      memcpy (&((char *) ctx->buffer)[left_over], buffer, len);
+      left_over += len;
+      if (left_over >= 64)
+	{
+	  md5_process_block (ctx->buffer, 64, ctx);
+	  left_over -= 64;
+	  memcpy (ctx->buffer, &ctx->buffer[16], left_over);
+	}
+      ctx->buflen = left_over;
+    }
+}
+
+
+/* These are the four functions used in the four steps of the MD5 algorithm
+   and defined in the RFC 1321.  The first function is a little bit optimized
+   (as found in Colin Plumbs public domain implementation).  */
+/* #define FF(b, c, d) ((b & c) | (~b & d)) */
+#define FF(b, c, d) (d ^ (b & (c ^ d)))
+#define FG(b, c, d) FF (d, b, c)
+#define FH(b, c, d) (b ^ c ^ d)
+#define FI(b, c, d) (c ^ (b | ~d))
+
+/* Process LEN bytes of BUFFER, accumulating context into CTX.
+   It is assumed that LEN % 64 == 0.  */
+
+void
+md5_process_block (const void *buffer, size_t len, struct md5_ctx *ctx)
+{
+  uint32_t correct_words[16];
+  const uint32_t *words = buffer;
+  size_t nwords = len / sizeof (uint32_t);
+  const uint32_t *endp = words + nwords;
+  uint32_t A = ctx->A;
+  uint32_t B = ctx->B;
+  uint32_t C = ctx->C;
+  uint32_t D = ctx->D;
+
+  /* First increment the byte count.  RFC 1321 specifies the possible
+     length of the file up to 2^64 bits.  Here we only compute the
+     number of bytes.  Do a double word increment.  */
+  ctx->total[0] += len;
+  if (ctx->total[0] < len)
+    ++ctx->total[1];
+
+  /* Process all bytes in the buffer with 64 bytes in each round of
+     the loop.  */
+  while (words < endp)
+    {
+      uint32_t *cwp = correct_words;
+      uint32_t A_save = A;
+      uint32_t B_save = B;
+      uint32_t C_save = C;
+      uint32_t D_save = D;
+
+      /* First round: using the given function, the context and a constant
+         the next context is computed.  Because the algorithms processing
+         unit is a 32-bit word and it is determined to work on words in
+         little endian byte order we perhaps have to change the byte order
+         before the computation.  To reduce the work for the next steps
+         we store the swapped words in the array CORRECT_WORDS.  */
+
+#define OP(a, b, c, d, s, T)						\
+      do								\
+        {								\
+	  a += FF (b, c, d) + (*cwp++ = SWAP (*words)) + T;		\
+	  ++words;							\
+	  CYCLIC (a, s);						\
+	  a += b;							\
+        }								\
+      while (0)
+
+      /* It is unfortunate that C does not provide an operator for
+         cyclic rotation.  Hope the C compiler is smart enough.  */
+#define CYCLIC(w, s) (w = (w << s) | (w >> (32 - s)))
+
+      /* Before we start, one word to the strange constants.
+         They are defined in RFC 1321 as
+
+         T[i] = (int) (4294967296.0 * fabs (sin (i))), i=1..64
+
+         Here is an equivalent invocation using Perl:
+
+         perl -e 'foreach(1..64){printf "0x%08x\n", int (4294967296 * abs (sin $_))}'
+       */
+
+      /* Round 1.  */
+      OP (A, B, C, D, 7, 0xd76aa478);
+      OP (D, A, B, C, 12, 0xe8c7b756);
+      OP (C, D, A, B, 17, 0x242070db);
+      OP (B, C, D, A, 22, 0xc1bdceee);
+      OP (A, B, C, D, 7, 0xf57c0faf);
+      OP (D, A, B, C, 12, 0x4787c62a);
+      OP (C, D, A, B, 17, 0xa8304613);
+      OP (B, C, D, A, 22, 0xfd469501);
+      OP (A, B, C, D, 7, 0x698098d8);
+      OP (D, A, B, C, 12, 0x8b44f7af);
+      OP (C, D, A, B, 17, 0xffff5bb1);
+      OP (B, C, D, A, 22, 0x895cd7be);
+      OP (A, B, C, D, 7, 0x6b901122);
+      OP (D, A, B, C, 12, 0xfd987193);
+      OP (C, D, A, B, 17, 0xa679438e);
+      OP (B, C, D, A, 22, 0x49b40821);
+
+      /* For the second to fourth round we have the possibly swapped words
+         in CORRECT_WORDS.  Redefine the macro to take an additional first
+         argument specifying the function to use.  */
+#undef OP
+#define OP(f, a, b, c, d, k, s, T)					\
+      do								\
+	{								\
+	  a += f (b, c, d) + correct_words[k] + T;			\
+	  CYCLIC (a, s);						\
+	  a += b;							\
+	}								\
+      while (0)
+
+      /* Round 2.  */
+      OP (FG, A, B, C, D, 1, 5, 0xf61e2562);
+      OP (FG, D, A, B, C, 6, 9, 0xc040b340);
+      OP (FG, C, D, A, B, 11, 14, 0x265e5a51);
+      OP (FG, B, C, D, A, 0, 20, 0xe9b6c7aa);
+      OP (FG, A, B, C, D, 5, 5, 0xd62f105d);
+      OP (FG, D, A, B, C, 10, 9, 0x02441453);
+      OP (FG, C, D, A, B, 15, 14, 0xd8a1e681);
+      OP (FG, B, C, D, A, 4, 20, 0xe7d3fbc8);
+      OP (FG, A, B, C, D, 9, 5, 0x21e1cde6);
+      OP (FG, D, A, B, C, 14, 9, 0xc33707d6);
+      OP (FG, C, D, A, B, 3, 14, 0xf4d50d87);
+      OP (FG, B, C, D, A, 8, 20, 0x455a14ed);
+      OP (FG, A, B, C, D, 13, 5, 0xa9e3e905);
+      OP (FG, D, A, B, C, 2, 9, 0xfcefa3f8);
+      OP (FG, C, D, A, B, 7, 14, 0x676f02d9);
+      OP (FG, B, C, D, A, 12, 20, 0x8d2a4c8a);
+
+      /* Round 3.  */
+      OP (FH, A, B, C, D, 5, 4, 0xfffa3942);
+      OP (FH, D, A, B, C, 8, 11, 0x8771f681);
+      OP (FH, C, D, A, B, 11, 16, 0x6d9d6122);
+      OP (FH, B, C, D, A, 14, 23, 0xfde5380c);
+      OP (FH, A, B, C, D, 1, 4, 0xa4beea44);
+      OP (FH, D, A, B, C, 4, 11, 0x4bdecfa9);
+      OP (FH, C, D, A, B, 7, 16, 0xf6bb4b60);
+      OP (FH, B, C, D, A, 10, 23, 0xbebfbc70);
+      OP (FH, A, B, C, D, 13, 4, 0x289b7ec6);
+      OP (FH, D, A, B, C, 0, 11, 0xeaa127fa);
+      OP (FH, C, D, A, B, 3, 16, 0xd4ef3085);
+      OP (FH, B, C, D, A, 6, 23, 0x04881d05);
+      OP (FH, A, B, C, D, 9, 4, 0xd9d4d039);
+      OP (FH, D, A, B, C, 12, 11, 0xe6db99e5);
+      OP (FH, C, D, A, B, 15, 16, 0x1fa27cf8);
+      OP (FH, B, C, D, A, 2, 23, 0xc4ac5665);
+
+      /* Round 4.  */
+      OP (FI, A, B, C, D, 0, 6, 0xf4292244);
+      OP (FI, D, A, B, C, 7, 10, 0x432aff97);
+      OP (FI, C, D, A, B, 14, 15, 0xab9423a7);
+      OP (FI, B, C, D, A, 5, 21, 0xfc93a039);
+      OP (FI, A, B, C, D, 12, 6, 0x655b59c3);
+      OP (FI, D, A, B, C, 3, 10, 0x8f0ccc92);
+      OP (FI, C, D, A, B, 10, 15, 0xffeff47d);
+      OP (FI, B, C, D, A, 1, 21, 0x85845dd1);
+      OP (FI, A, B, C, D, 8, 6, 0x6fa87e4f);
+      OP (FI, D, A, B, C, 15, 10, 0xfe2ce6e0);
+      OP (FI, C, D, A, B, 6, 15, 0xa3014314);
+      OP (FI, B, C, D, A, 13, 21, 0x4e0811a1);
+      OP (FI, A, B, C, D, 4, 6, 0xf7537e82);
+      OP (FI, D, A, B, C, 11, 10, 0xbd3af235);
+      OP (FI, C, D, A, B, 2, 15, 0x2ad7d2bb);
+      OP (FI, B, C, D, A, 9, 21, 0xeb86d391);
+
+      /* Add the starting values of the context.  */
+      A += A_save;
+      B += B_save;
+      C += C_save;
+      D += D_save;
+    }
+
+  /* Put checksum in context given as argument.  */
+  ctx->A = A;
+  ctx->B = B;
+  ctx->C = C;
+  ctx->D = D;
+}
diff -ruNp src.orig/sc2code/libs/md5/md5.h src/sc2code/libs/md5/md5.h
--- src.orig/sc2code/libs/md5/md5.h	1969-12-31 18:00:00 -0600
+++ src/sc2code/libs/md5/md5.h	2017-11-08 16:49:58 -0600
@@ -0,0 +1,130 @@
+/* Declaration of functions and data types used for MD5 sum computing
+   library functions.
+   Copyright (C) 1995-1997,1999,2000,2001,2004,2005,2006
+      Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+  */
+
+#ifndef _MD5_H
+#define _MD5_H 1
+
+#include <stdio.h>
+
+#ifdef _MSC_VER
+typedef unsigned int uint32_t;
+#else
+#include <stdint.h>
+#endif
+
+#define MD5_DIGEST_SIZE 16
+#define MD5_BLOCK_SIZE 64
+
+#ifndef __GNUC_PREREQ
+# if defined __GNUC__ && defined __GNUC_MINOR__
+#  define __GNUC_PREREQ(maj, min)					\
+  ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))
+# else
+#  define __GNUC_PREREQ(maj, min) 0
+# endif
+#endif
+
+#ifndef __THROW
+# if defined __cplusplus && __GNUC_PREREQ (2,8)
+#  define __THROW	throw ()
+# else
+#  define __THROW
+# endif
+#endif
+
+#ifndef _LIBC
+# define __md5_buffer md5_buffer
+# define __md5_finish_ctx md5_finish_ctx
+# define __md5_init_ctx md5_init_ctx
+# define __md5_process_block md5_process_block
+# define __md5_process_bytes md5_process_bytes
+# define __md5_read_ctx md5_read_ctx
+# define __md5_stream md5_stream
+#endif
+
+/* Structure to save state of computation between the single steps.  */
+struct md5_ctx
+{
+  uint32_t A;
+  uint32_t B;
+  uint32_t C;
+  uint32_t D;
+
+  uint32_t total[2];
+  uint32_t buflen;
+  uint32_t buffer[32];
+};
+
+/*
+ * The following three functions are build up the low level used in
+ * the functions `md5_stream' and `md5_buffer'.
+ */
+
+/* Initialize structure containing state of computation.
+   (RFC 1321, 3.3: Step 3)  */
+extern void __md5_init_ctx (struct md5_ctx *ctx) __THROW;
+
+/* Starting with the result of former calls of this function (or the
+   initialization function update the context for the next LEN bytes
+   starting at BUFFER.
+   It is necessary that LEN is a multiple of 64!!! */
+extern void __md5_process_block (const void *buffer, size_t len,
+				 struct md5_ctx *ctx) __THROW;
+
+/* Starting with the result of former calls of this function (or the
+   initialization function update the context for the next LEN bytes
+   starting at BUFFER.
+   It is NOT required that LEN is a multiple of 64.  */
+extern void __md5_process_bytes (const void *buffer, size_t len,
+				 struct md5_ctx *ctx) __THROW;
+
+/* Process the remaining bytes in the buffer and put result from CTX
+   in first 16 bytes following RESBUF.  The result is always in little
+   endian byte order, so that a byte-wise output yields to the wanted
+   ASCII representation of the message digest.
+
+   IMPORTANT: On some systems, RESBUF must be aligned to a 32-bit
+   boundary. */
+extern void *__md5_finish_ctx (struct md5_ctx *ctx, void *resbuf) __THROW;
+
+
+/* Put result from CTX in first 16 bytes following RESBUF.  The result is
+   always in little endian byte order, so that a byte-wise output yields
+   to the wanted ASCII representation of the message digest.
+
+   IMPORTANT: On some systems, RESBUF must be aligned to a 32-bit
+   boundary. */
+extern void *__md5_read_ctx (const struct md5_ctx *ctx, void *resbuf) __THROW;
+
+
+/* Compute MD5 message digest for bytes read from STREAM.  The
+   resulting message digest number will be written into the 16 bytes
+   beginning at RESBLOCK.  */
+extern int __md5_stream (FILE *stream, void *resblock) __THROW;
+
+/* Compute MD5 message digest for LEN bytes beginning at BUFFER.  The
+   result is always in little endian byte order, so that a byte-wise
+   output yields to the wanted ASCII representation of the message
+   digest.  */
+extern void *__md5_buffer (const char *buffer, size_t len,
+			   void *resblock) __THROW;
+
+#endif /* md5.h */
diff -ruNp src.orig/sc2code/libs/md5.h src/sc2code/libs/md5.h
--- src.orig/sc2code/libs/md5.h	1969-12-31 18:00:00 -0600
+++ src/sc2code/libs/md5.h	2017-11-08 16:49:58 -0600
@@ -0,0 +1,25 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ * Nota bene: later versions of the GNU General Public License do not apply
+ * to this program.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef _LIB_MD5_H
+#define _LIB_MD5_H
+
+#include "md5/md5.h"
+
+#endif  /* _LIB_MD5_H */
+
diff -ruNp src.orig/sc2code/libs/memlib.h src/sc2code/libs/memlib.h
--- src.orig/sc2code/libs/memlib.h	2017-11-08 16:49:30 -0600
+++ src/sc2code/libs/memlib.h	2017-11-08 16:49:58 -0600
@@ -21,133 +21,43 @@
 
 #include "compiler.h"
 
-#define MEM_NULL 0L
-#define NULL_HANDLE (MEM_HANDLE)MEM_NULL
+extern BOOLEAN mem_init (void);
+extern BOOLEAN mem_uninit (void);
 
-typedef signed long MEM_SIZE;
-typedef MEM_SIZE *PMEM_SIZE;
-typedef long MEM_OFFS;
+#ifdef LEGACY_HANDLE_ALLOCATOR
 
-typedef SWORD MEM_HANDLE;
-typedef MEM_HANDLE *PMEM_HANDLE;
+#define NULL_HANDLE (MEM_HANDLE)(0L)
 
-typedef BOOLEAN MEM_BOOL;
-#define MEM_FAILURE FALSE
-#define MEM_SUCCESS TRUE
-
-enum
-{
-	SAME_MEM_USAGE = 0,
-	MEM_SIMPLE,
-	MEM_COMPLEX
-};
-typedef BYTE MEM_USAGE;
-
-#define NO_MEM_USAGE (MEM_USAGE)SAME_MEM_USAGE
-#define DEFAULT_MEM_USAGE (MEM_USAGE)MEM_SIMPLE
-
-enum
-{
-	MEM_NO_ACCESS = 0,
-	MEM_READ_ONLY,
-	MEM_WRITE_ONLY,
-	MEM_READ_WRITE
-};
-typedef BYTE MEM_ACCESS_MODE;
-
-enum
-{
-	MEM_SEEK_REL,
-	MEM_SEEK_ABS
-};
-typedef BYTE MEM_SEEK_MODE;
-
-enum
-{
-	MEM_FORWARD,
-	MEM_BACKWARD
-};
-typedef BYTE MEM_DIRECTION;
-
-typedef struct mem_size_request
-{
-	MEM_SIZE min_size, size, max_size;
-	MEM_DIRECTION direction;
-} MEM_SIZE_REQUEST;
+typedef signed long MEM_SIZE;
 
-typedef MEM_SIZE_REQUEST *PMEM_SIZE_REQUEST;
-typedef SBYTE MEM_PRIORITY;
+typedef SWORD MEM_HANDLE;
 typedef UWORD MEM_FLAGS;
 
 #define DEFAULT_MEM_FLAGS (MEM_FLAGS)0
-#define SAME_MEM_FLAGS (MEM_FLAGS)0
-#define MEM_CONSTRAINED (MEM_FLAGS)(1 << 2)
-#define MEM_DISCARDABLE (MEM_FLAGS)(1 << 3)
-#define MEM_NODISCARD (MEM_FLAGS)(1 << 4)
-#define MEM_DISCARDED (MEM_FLAGS)(1 << 5)
-#define MEM_ACCESSED (MEM_FLAGS)(1 << 6)
-#define MEM_STATIC (MEM_FLAGS)(1 << 7)
 #define MEM_PRIMARY (MEM_FLAGS)(1 << 8)
 #define MEM_ZEROINIT (MEM_FLAGS)(1 << 9)
 #define MEM_GRAPHICS (MEM_FLAGS)(1 << 10)
 #define MEM_SOUND (MEM_FLAGS)(1 << 11)
 
-#define DEFAULT_MEM_PRIORITY (MEM_PRIORITY)0
-#define SAME_MEM_PRIORITY (MEM_PRIORITY)0
-#define HIGHEST_MEM_PRIORITY (MEM_PRIORITY)1
-#define LOWEST_MEM_PRIORITY (MEM_PRIORITY)100
-
 typedef struct mem_header {
 	MEM_HANDLE handle;
 } _ALIGNED_ANY MEM_HEADER;
+// _ALIGNED_ANY adds padding to the end of MEM_HEADER, so that the following
+// address is aligned for any object (if the address of the MEM_HEADER
+// itself is aligned for any object).
 
 #define GET_MEM_HEADER(addr) ((MEM_HEADER *) \
 		(((char *) addr) - sizeof (MEM_HEADER)))
 
-//Newer verion from w_memlib.c to follow...
-/*
-extern MEM_BOOL mem_init (MEM_SIZE core_size, PMEM_SIZE pmin_addressable,
-		PSTR disk_name);*/
-
-extern MEM_BOOL mem_init (void);
-
-extern MEM_BOOL mem_uninit (void);
-
-extern MEM_HANDLE mem_allocate (MEM_SIZE size, MEM_FLAGS flags,
-		MEM_PRIORITY priority, MEM_USAGE usage);
-#define mem_request(size) \
-		mem_allocate((MEM_SIZE)(size), DEFAULT_MEM_FLAGS, DEFAULT_MEM_PRIORITY, DEFAULT_MEM_USAGE)
-extern MEM_BOOL mem_release (MEM_HANDLE handle);
-extern MEM_HANDLE mem_reallocate (MEM_HANDLE handle, MEM_SIZE size,
-		MEM_FLAGS flags, MEM_PRIORITY priority, MEM_USAGE usage);
-#define mem_resize(h, size) \
-		mem_reallocate(h, (MEM_SIZE)size, SAME_MEM_FLAGS, SAME_MEM_PRIORITY, SAME_MEM_USAGE)
-extern MEM_HANDLE mem_static (PVOID pVoid, MEM_SIZE size, MEM_USAGE
-		usage);
-extern MEM_HANDLE mem_dup (MEM_HANDLE handle, MEM_USAGE usage);
-
-extern PVOID mem_simple_access (MEM_HANDLE handle);
-extern MEM_BOOL mem_simple_unaccess (MEM_HANDLE handle);
-
-#define mem_lock mem_simple_access
-#define mem_unlock mem_simple_unaccess
-
-extern PVOID mem_complex_access (MEM_HANDLE handle, MEM_SIZE pos,
-		PMEM_SIZE_REQUEST pSizeRequest, MEM_ACCESS_MODE access_mode);
-extern MEM_BOOL mem_complex_unaccess (MEM_HANDLE handle);
-extern PVOID mem_complex_seek (MEM_HANDLE handle, MEM_OFFS offset,
-		PMEM_SIZE_REQUEST pSizeRequest, MEM_SEEK_MODE seek_mode);
+extern MEM_HANDLE mem_allocate (MEM_SIZE size, MEM_FLAGS flags);
+extern BOOLEAN mem_release (MEM_HANDLE handle);
 
-extern MEM_SIZE mem_get_memavailable (MEM_SIZE size, MEM_PRIORITY
-		priority);
+extern void* mem_lock (MEM_HANDLE handle);
+extern BOOLEAN mem_unlock (MEM_HANDLE handle);
 
 extern MEM_SIZE mem_get_size (MEM_HANDLE handle);
-extern MEM_USAGE mem_get_usage (MEM_HANDLE handle);
-extern MEM_BOOL mem_set_flags (MEM_HANDLE handle, MEM_FLAGS mem_flags);
-extern MEM_FLAGS mem_get_flags (MEM_HANDLE handle);
-extern MEM_BOOL mem_set_priority (MEM_HANDLE handle, MEM_PRIORITY
-		mem_priority);
-extern MEM_PRIORITY mem_get_priority (MEM_HANDLE handle);
+
+#endif /* LEGACY_HANDLE_ALLOCATOR */
 
 #endif /* _MEMLIB_H */
 
diff -ruNp src.orig/sc2code/libs/memory/w_memlib.c src/sc2code/libs/memory/w_memlib.c
--- src.orig/sc2code/libs/memory/w_memlib.c	2017-11-08 16:49:30 -0600
+++ src/sc2code/libs/memory/w_memlib.c	2017-11-08 16:49:58 -0600
@@ -25,11 +25,15 @@
 //#include "utils.h"
 //#include "pcwin.h"
 #include "compiler.h"
+#ifdef LEGACY_HANDLE_ALLOCATOR
 #include "libs/threadlib.h"
+#endif
 #include "libs/memlib.h"
 #include "libs/log.h"
 #include "libs/misc.h"
 
+#ifdef LEGACY_HANDLE_ALLOCATOR
+
 #define GetToolFrame() 1
 
 //#define MEM_DEBUG
@@ -66,74 +70,6 @@ typedef struct _szMemoryNode {
 static szMemoryNode extents[MAX_EXTENTS];
 static szMemoryNode *freeListHead = NULL;
 
-
-#if 0
-/*****************************************************************************/
-/*FUNCTION
-**
-** SYNOPSIS
-**      ok = MessageWithRetry(format, parms)
-**
-** DESCRIPTION
-** Presents a windows message box to the user and echoes the
-** message with printf(). The users gets to choose OK or CANCEL.
-** Returns TRUE if the user says OK.
-**
-** INPUT
-** As for printf().
-**
-** OUTPUT
-** int ok = TRUE for OK, FALSE for CANCEL.
-**
-** HISTORY
-**      6-Nov-96:AKL Creation.
-**
-** ASSUMPTIONS
-**END*/
-
-static int MessageWithRetry(char *fmt, ...)
-{
-		va_list ap;
-		char buffer[256];
-#if 0
-		int ret;
-#endif
-
-
-		va_start(ap, fmt);
-		vsprintf(buffer, fmt, ap);
-		va_end(ap);
-
-		log_add (log_User, "%s", buffer);
-		// fflush(stderr);
-
-#if 0
-	if (GetToolFrame ())
-	{
-		ShowWindow(GetToolFrame (),SW_HIDE);
-	}
-		ret = MessageBox(NULL, buffer, "Message From Programmer Dude",
-												MB_OKCANCEL);
-
-		/* Return value:
-						0 => not enough memory for message. Abort game.
-						IDCANCEL => user selected CANCEL.
-						IDOK => user selected OK.
-		*/
-
-	if (GetToolFrame ())
-	{
-		ShowWindow(GetToolFrame (),SW_NORMAL);
-	}
-
-		if ( ret == IDOK )
-				return TRUE;
-		else
-#endif
-				return FALSE;
-}
-#endif
-
 /*****************************************************************************/
 /*FUNCTION
 **
@@ -160,17 +96,16 @@ static int MessageWithRetry(char *fmt, .
 
 void CheckMemory(void)
 {
+	// Send all reports to STDOUT
+	_CrtSetReportMode( _CRT_WARN, _CRTDBG_MODE_FILE );
+	_CrtSetReportFile( _CRT_WARN, _CRTDBG_FILE_STDOUT );
+	_CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_FILE );
+	_CrtSetReportFile( _CRT_ERROR, _CRTDBG_FILE_STDOUT );
+	_CrtSetReportMode( _CRT_ASSERT, _CRTDBG_MODE_FILE );
+	_CrtSetReportFile( _CRT_ASSERT, _CRTDBG_FILE_STDOUT );
 
-   // Send all reports to STDOUT
-   _CrtSetReportMode( _CRT_WARN, _CRTDBG_MODE_FILE );
-   _CrtSetReportFile( _CRT_WARN, _CRTDBG_FILE_STDOUT );
-   _CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_FILE );
-   _CrtSetReportFile( _CRT_ERROR, _CRTDBG_FILE_STDOUT );
-   _CrtSetReportMode( _CRT_ASSERT, _CRTDBG_MODE_FILE );
-   _CrtSetReportFile( _CRT_ASSERT, _CRTDBG_FILE_STDOUT );
-
-		_CrtCheckMemory();
-		fflush(stdout);
+	_CrtCheckMemory();
+	fflush(stdout);
 }
 #endif
 
@@ -178,61 +113,44 @@ void CheckMemory(void)
 /*FUNCTION
 **
 ** SYNOPSIS
-** mem = MallocWithRetry(coreSize, diagnostic)
+** mem = SafeMalloc (coreSize, diagnostic)
 **
 ** DESCRIPTION
-** Mallocs the required memory. If the malloc fails, the user is prompted
-** to shutdown other applications and retry, or kill the game.
-** If the game is killed, the diagnostic string is printed.
+** Mallocs the required memory. If the malloc fails, the game
+** is killed with a diagnostic string.
 **
 ** INPUT
 ** int coreSize = How much memory to malloc (in bytes).
 ** char *diagnostic = String identifying the caller.
 **
 ** OUTPUT
-** void *mem = Ptr to memory, or NULL if user wants to kill us.
+** void *mem = Ptr to memory.  Never returns NULL.
 **
 ** HISTORY
+**      14-Jan-08:Cleanups and conversion from MallocWithRetry.
 **      06-Nov-96:AKL Creation.
 **
 ** ASSUMPTIONS
 **
 **END*/
 
-void *
-MallocWithRetry(int bytes, char *diagStr)
+static void *
+SafeMalloc (int bytes, char *diagStr)
 {
-	while (1)
+	void *ptr;
+	
+	ptr = malloc (bytes);
+	if (!ptr)
 	{
-		void *ptr;
-		
-		ptr = malloc (bytes);
-		if (ptr)
-			return (ptr);
-
 		log_add (log_Fatal, "Malloc failed for %s. #Bytes %d.", diagStr, bytes);
 		fflush (stderr);
-        explode ();
-#if 0
-		/* The user gets a chance to close other applications and try again. */
-		if (!MessageWithRetry ("I'm out of memory!  "
-				"Please close other applications and click OK to try again"))
-		{
-			if (MessageWithRetry ("Really OK to stop tfbtool?"))
-			{
-				/* User says "die". */
-				log_add (log_Error, "Killed by the user (%s).", diagStr);
-				log_showBox (false, false);
-				exit (EXIT_SUCCESS);
-			}
-		}
-#endif
+		explode ();
 	}
+	return ptr;
 }
 
 MEM_HANDLE
-mem_allocate (MEM_SIZE coreSize, MEM_FLAGS flags, MEM_PRIORITY priority,
-		MEM_USAGE usage)
+mem_allocate (MEM_SIZE coreSize, MEM_FLAGS flags)
 {
 	szMemoryNode *node;
 
@@ -277,8 +195,6 @@ mem_allocate (MEM_SIZE coreSize, MEM_FLA
 	}
 
 	UnlockMutex (_MemoryLock);
-	(void) priority;  /* Satisfying compiler (unused parameter) */
-	(void) usage;  /* Satisfying compiler (unused parameter) */
 	return (0);
 }
 
@@ -342,7 +258,7 @@ mem_get_size (MEM_HANDLE h)
 **
 **END*/
 
-MEM_BOOL
+BOOLEAN
 mem_init (void)
 {
 	int i;
@@ -385,7 +301,7 @@ mem_init (void)
 **
 **END*/
 
-MEM_BOOL
+BOOLEAN
 mem_uninit(void)
 {
 	int i;
@@ -442,7 +358,7 @@ mem_uninit(void)
 **
 **END*/
 
-MEM_BOOL
+BOOLEAN
 mem_release(MEM_HANDLE h)
 {
 	if (h == 0)
@@ -487,11 +403,10 @@ mem_release(MEM_HANDLE h)
 /*FUNCTION
 **
 ** SYNOPSIS
-** memp = mem_simple_access(h)
+** memp = mem_lock (h)
 **
 ** DESCRIPTION
-**      Obtains access to the given memory allocation. For now, we simply
-** return the handle itself, because it is the actual address!
+**      Converts a MEM_HANDLE into its equivalent pointer.
 **
 ** INPUT
 ** int h = Handle to memory to be accessed.
@@ -507,7 +422,7 @@ mem_release(MEM_HANDLE h)
 **END*/
 
 void *
-mem_simple_access(MEM_HANDLE h)
+mem_lock (MEM_HANDLE h)
 {
 	LockMutex (_MemoryLock);
 
@@ -529,8 +444,7 @@ mem_simple_access(MEM_HANDLE h)
 ** done = mem_simple_unaccess(h)
 **
 ** DESCRIPTION
-**      Release access to the given memory allocation. For now, we simply
-** do nothing!
+**      Drops the refcount on a piece of memory.
 **
 ** INPUT
 ** int h = Handle to memory to be unaccessed.
@@ -545,8 +459,8 @@ mem_simple_access(MEM_HANDLE h)
 **
 **END*/
 
-MEM_BOOL
-mem_simple_unaccess(MEM_HANDLE h)
+BOOLEAN
+mem_unlock (MEM_HANDLE h)
 {
 	LockMutex (_MemoryLock);
 	if (h > 0 && h <= MAX_EXTENTS && extents[h - 1].handle == h)
@@ -567,8 +481,8 @@ _alloc_mem (int size)
 	void *p;
 	int h;
 
-	h = mem_allocate (sizeof (MEM_HEADER) + size, 0, 0, 0);
-	p = (void *)mem_simple_access (h);
+	h = mem_allocate (sizeof (MEM_HEADER) + size, DEFAULT_MEM_FLAGS);
+	p = (void *)mem_lock (h);
 	if (p)
 	{
 		((MEM_HEADER *) p)->handle = h;
@@ -603,7 +517,7 @@ HFree (void *p)
 
 		hdr = GET_MEM_HEADER(p);
 		h = hdr->handle;
-		mem_simple_unaccess (h);
+		mem_unlock (h);
 		mem_release (h);
 	}
 }
@@ -620,9 +534,6 @@ HCalloc (int size)
 	return (p);
 }
 
-// BUG: HRealloc() is does not behave like realloc():
-// From the C standard: "If memory for the new object cannot be allocated,
-// the old object is not deallocated and its value is unchanged."
 void *
 HRealloc (void *p, int size)
 {
@@ -646,3 +557,67 @@ HRealloc (void *p, int size)
 	return (np);
 }
 
+#else /* !LEGACY_HANDLE_ALLOCATOR */
+
+BOOLEAN
+mem_init (void)
+{
+	return TRUE;
+}
+
+BOOLEAN
+mem_uninit(void)
+{
+	return (TRUE);
+}
+
+void *
+HMalloc (int size)
+{
+	void *p;
+
+	if (size == 0) return NULL;
+
+	if (size < 0) 
+	{
+		log_add (log_Fatal, "Fatal Error: Request for negative amount of memory %d!", size);
+		fflush (stderr);
+		explode ();
+	}
+
+	if ((p = malloc (size)) == NULL) 
+	{
+		log_add (log_Fatal, "Fatal Error: HMalloc(): out of memory.");
+		fflush (stderr);
+		explode ();
+	}
+	return (p);
+}
+
+void
+HFree (void *p)
+{
+	if (p)
+	{
+		free (p);
+	}
+}
+
+void *
+HCalloc (int size)
+{
+	void *p;
+
+	p = HMalloc (size);
+	memset (p, 0, size);
+
+	return (p);
+}
+
+void *
+HRealloc (void *p, int size)
+{
+	return realloc (p, size);
+}
+
+#endif /* LEGACY_HANDLE_ALLOCATOR */
diff -ruNp src.orig/sc2code/libs/network/connect/connect.c src/sc2code/libs/network/connect/connect.c
--- src.orig/sc2code/libs/network/connect/connect.c	2017-11-08 16:49:31 -0600
+++ src/sc2code/libs/network/connect/connect.c	2017-11-08 16:49:58 -0600
@@ -78,7 +78,7 @@ ConnectState_incRef(ConnectState *connec
 	assert(connectState->refCount < REFCOUNT_MAX);
 	connectState->refCount++;
 #ifdef DEBUG_CONNECT_REF
-	log_add(log_Debug, "ConnectState %08" PRIxPTR ": ref++ (%d)\n",
+	log_add(log_Debug, "ConnectState %08" PRIxPTR ": ref++ (%d)",
 			(uintptr_t) connectState, connectState->refCount);
 #endif
 }
@@ -88,7 +88,7 @@ ConnectState_decRef(ConnectState *connec
 	assert(connectState->refCount > 0);
 	connectState->refCount--;
 #ifdef DEBUG_CONNECT_REF
-	log_add(log_Debug, "ConnectState %08" PRIxPTR ": ref-- (%d)\n",
+	log_add(log_Debug, "ConnectState %08" PRIxPTR ": ref-- (%d)",
 			(uintptr_t) connectState, connectState->refCount);
 #endif
 	if (connectState->refCount == 0) {
@@ -147,20 +147,20 @@ connectCallback(NetDescriptor *nd) {
 	if (connectState->state == Connect_closed) {
 		// The connection attempt has been aborted.
 #ifdef DEBUG
-		log_add(log_Debug, "Connection attempt was aborted.\n");
+		log_add(log_Debug, "Connection attempt was aborted.");
 #endif
 		ConnectState_decRef(connectState);
 		return;
 	}
 
 	if (Socket_getError(NetDescriptor_getSocket(nd), &err) == -1) {
-		log_add(log_Fatal, "Socket_getError() failed: %s.\n",
+		log_add(log_Fatal, "Socket_getError() failed: %s.",
 				strerror(errno));
 		explode();
 	}
 	if (err != 0) {
 #ifdef DEBUG
-		log_add(log_Debug, "connect() failed: %s.\n", strerror(err));
+		log_add(log_Debug, "connect() failed: %s.", strerror(err));
 #endif
 		NetDescriptor_close(nd);
 		connectState->nd = NULL;
@@ -169,6 +169,10 @@ connectCallback(NetDescriptor *nd) {
 		return;
 	}
 
+#ifdef DEBUG
+	log_add(log_Debug, "Connection established.");
+#endif
+
 	// Notify the higher layer.
 	connectState->nd = NULL;
 			// The callback function takes over ownership of the
@@ -224,14 +228,14 @@ tryConnectHostNext(ConnectState *connect
 			info->ai_protocol);
 	if (sock == Socket_noSocket) {
 		int savedErrno = errno;
-		log_add(log_Error, "socket() failed: %s.\n", strerror(errno));
+		log_add(log_Error, "socket() failed: %s.", strerror(errno));
 		errno = savedErrno;
 		return Socket_noSocket;
 	}
 	
 	if (Socket_setNonBlocking(sock) == -1) {
 		int savedErrno = errno;
-		log_add(log_Error, "Could not make socket non-blocking: %s.\n",
+		log_add(log_Error, "Could not make socket non-blocking: %s.",
 				strerror(errno));
 		errno = savedErrno;
 		return Socket_noSocket;
@@ -268,7 +272,7 @@ tryConnectHostNext(ConnectState *connect
 		Socket_close(sock);
 #ifdef DEBUG
 		log_add(log_Debug, "connect() immediately failed for one address: "
-				"%s.\n", strerror(errno));
+				"%s.", strerror(errno));
 				// TODO: add the address in the status message.
 #endif
 		errno = savedErrno;
@@ -327,7 +331,7 @@ connectHostNext(ConnectState *connectSta
 				ConnectError error;
 				int savedErrno = errno;
 
-				log_add(log_Error, "NetDescriptor_new() failed: %s.\n",
+				log_add(log_Error, "NetDescriptor_new() failed: %s.",
 						strerror(errno));
 				Socket_close(sock);
 				freeaddrinfo(connectState->info);
@@ -438,7 +442,7 @@ connectHostByName(const char *host, cons
 	connectState = ConnectState_alloc();
 	connectState->refCount = 1;
 #ifdef DEBUG_CONNECT_REF
-	log_add(log_Debug, "ConnectState %08" PRIxPTR ": ref=1 (%d)\n",
+	log_add(log_Debug, "ConnectState %08" PRIxPTR ": ref=1 (%d)",
 			(uintptr_t) connectState, connectState->refCount);
 #endif
 	connectState->state = Connect_resolving;
diff -ruNp src.orig/sc2code/libs/network/connect/listen.c src/sc2code/libs/network/connect/listen.c
--- src.orig/sc2code/libs/network/connect/listen.c	2017-11-08 16:49:31 -0600
+++ src/sc2code/libs/network/connect/listen.c	2017-11-08 16:49:58 -0600
@@ -74,7 +74,7 @@ ListenState_incRef(ListenState *listenSt
 	assert(listenState->refCount < REFCOUNT_MAX);
 	listenState->refCount++;
 #ifdef DEBUG_LISTEN_REF
-	log_add(log_Debug, "ListenState %08" PRIxPTR ": ref++ (%d)\n",
+	log_add(log_Debug, "ListenState %08" PRIxPTR ": ref++ (%d)",
 			(uintptr_t) listenState, listenState->refCount);
 #endif
 }
@@ -84,7 +84,7 @@ ListenState_decRef(ListenState *listenSt
 	assert(listenState->refCount > 0);
 	listenState->refCount--;
 #ifdef DEBUG_LISTEN_REF
-	log_add(log_Debug, "ListenState %08" PRIxPTR ": ref-- (%d)\n",
+	log_add(log_Debug, "ListenState %08" PRIxPTR ": ref-- (%d)",
 			(uintptr_t) listenState, listenState->refCount);
 #endif
 	if (listenState->refCount == 0) {
@@ -134,7 +134,7 @@ listenPortSingle(struct ListenState *lis
 			info->ai_protocol);
 	if (sock == Socket_noSocket) {
 		int savedErrno = errno;
-		log_add(log_Error, "socket() failed: %s.\n", strerror(errno));
+		log_add(log_Error, "socket() failed: %s.", strerror(errno));
 		errno = savedErrno;
 		return NULL;
 	}
@@ -154,10 +154,10 @@ listenPortSingle(struct ListenState *lis
 		int savedErrno = errno;
 		if (errno == EADDRINUSE) {
 #ifdef DEBUG
-			log_add(log_Warning, "bind() failed: %s.\n", strerror(errno));
+			log_add(log_Warning, "bind() failed: %s.", strerror(errno));
 #endif
 		} else
-			log_add(log_Error, "bind() failed: %s.\n", strerror(errno));
+			log_add(log_Error, "bind() failed: %s.", strerror(errno));
 		Socket_close(sock);
 		errno = savedErrno;
 		return NULL;
@@ -166,7 +166,7 @@ listenPortSingle(struct ListenState *lis
 	listenResult = Socket_listen(sock, listenState->flags.backlog);
 	if (listenResult == -1) {
 		int savedErrno = errno;
-		log_add(log_Error, "listen() failed: %s.\n", strerror(errno));
+		log_add(log_Error, "listen() failed: %s.", strerror(errno));
 		Socket_close(sock);
 		errno = savedErrno;
 		return NULL;
@@ -175,7 +175,7 @@ listenPortSingle(struct ListenState *lis
 	nd = NetDescriptor_new(sock, (void *) listenState);
 	if (nd == NULL) {
 		int savedErrno = errno;
-		log_add(log_Error, "NetDescriptor_new() failed: %s.\n",
+		log_add(log_Error, "NetDescriptor_new() failed: %s.",
 				strerror(errno));
 		Socket_close(sock);
 		errno = savedErrno;
@@ -226,7 +226,7 @@ listenPortMulti(struct ListenState *list
 			// it's a real possibility.
 			if (errno == EADDRINUSE && addrOkCount == 0) {
 				log_add(log_Error, "Error while preparing a network socket "
-						"for incoming connections: %s\n", strerror(errno));
+						"for incoming connections: %s", strerror(errno));
 			}
 			continue;
 		}
@@ -312,7 +312,7 @@ listenPort(const char *service, Protocol
 	listenState = ListenState_alloc();
 	listenState->refCount = 1;
 #ifdef DEBUG_LISTEN_REF
-	log_add(log_Debug, "ListenState %08" PRIxPTR ": ref=1 (%d)\n",
+	log_add(log_Debug, "ListenState %08" PRIxPTR ": ref=1 (%d)",
 			(uintptr_t) listenState, listenState->refCount);
 #endif
 	listenState->state = Listen_resolving;
@@ -382,13 +382,13 @@ acceptSingleConnection(ListenState *list
 #endif
 				// Serious problems, but future connections may still
 				// be possible.
-				log_add(log_Warning, "accept() reported '%s'\n",
+				log_add(log_Warning, "accept() reported '%s'",
 						strerror(errno));
 				return;
 			default:
 				// Should not happen.
 				log_add(log_Fatal, "Internal error: accept() reported "
-						"'%s'\n", strerror(errno));
+						"'%s'", strerror(errno));
 				explode();
 		}
 	}
@@ -397,7 +397,7 @@ acceptSingleConnection(ListenState *list
 			// Ignore errors; it's not a big deal.
 	if (Socket_setNonBlocking(acceptResult) == -1) {
 		int savedErrno = errno;
-		log_add(log_Error, "Could not make socket non-blocking: %s.\n",
+		log_add(log_Error, "Could not make socket non-blocking: %s.",
 				strerror(errno));
 		Socket_close(acceptResult);
 		errno = savedErrno;
@@ -418,11 +418,11 @@ acceptSingleConnection(ListenState *list
 				hostname, sizeof hostname, NULL, 0, 0);
 		if (gniRes != 0) {
 			log_add(log_Error, "Error while performing hostname "
-					"lookup for incoming connection: %s\n",
+					"lookup for incoming connection: %s",
 					(gniRes == EAI_SYSTEM) ? strerror(errno) :
 					gai_strerror(gniRes));
 		} else {
-			log_add(log_Debug, "Accepted incoming connection from '%s'.\n",
+			log_add(log_Debug, "Accepted incoming connection from '%s'.",
 					hostname);
 		}
 	}
@@ -431,7 +431,7 @@ acceptSingleConnection(ListenState *list
 	newNd = NetDescriptor_new(acceptResult, NULL);
 	if (newNd == NULL) {
 		int savedErrno = errno;
-		log_add(log_Error, "NetDescriptor_new() failed: %s.\n",
+		log_add(log_Error, "NetDescriptor_new() failed: %s.",
 				strerror(errno));
 		Socket_close(acceptResult);
 		errno = savedErrno;
diff -ruNp src.orig/sc2code/libs/network/connect/resolve.c src/sc2code/libs/network/connect/resolve.c
--- src.orig/sc2code/libs/network/connect/resolve.c	2017-11-08 16:49:31 -0600
+++ src/sc2code/libs/network/connect/resolve.c	2017-11-08 16:49:58 -0600
@@ -51,7 +51,7 @@ ResolveState_incRef(ResolveState *resolv
 	assert(resolveState->refCount < REFCOUNT_MAX);
 	resolveState->refCount++;
 #ifdef DEBUG_RESOLVE_REF
-	log_add(log_Debug, "ResolveState %08" PRIxPTR ": ref++ (%d)\n",
+	log_add(log_Debug, "ResolveState %08" PRIxPTR ": ref++ (%d)",
 			(uintptr_t) resolveState, resolveState->refCount);
 #endif
 }
@@ -61,7 +61,7 @@ ResolveState_decRef(ResolveState *resolv
 	assert(resolveState->refCount > 0);
 	resolveState->refCount--;
 #ifdef DEBUG_RESOLVE_REF
-	log_add(log_Debug, "ResolveState %08" PRIxPTR ": ref-- (%d)\n",
+	log_add(log_Debug, "ResolveState %08" PRIxPTR ": ref-- (%d)",
 			(uintptr_t) resolveState, resolveState->refCount);
 #endif
 	if (resolveState->refCount == 0) {
@@ -129,7 +129,7 @@ getaddrinfoAsync(const char *node, const
 	resolveState = ResolveState_new();
 	resolveState->refCount = 1;
 #ifdef DEBUG_RESOLVE_REF
-	log_add(log_Debug, "ResolveState %08" PRIxPTR ": ref=1 (%d)\n",
+	log_add(log_Debug, "ResolveState %08" PRIxPTR ": ref=1 (%d)",
 			(uintptr_t) resolveState, resolveState->refCount);
 #endif
 	resolveState->state = Resolve_resolving;
diff -ruNp src.orig/sc2code/libs/network/netmanager/ndesc.c src/sc2code/libs/network/netmanager/ndesc.c
--- src.orig/sc2code/libs/network/netmanager/ndesc.c	2017-11-08 16:49:31 -0600
+++ src/sc2code/libs/network/netmanager/ndesc.c	2017-11-08 16:49:58 -0600
@@ -51,7 +51,7 @@ NetDescriptor_new(Socket *socket, void *
 	nd = NetDescriptor_alloc();
 	nd->refCount = 1;
 #ifdef DEBUG_NETDESCRIPTOR_REF
-	log_add(log_Debug, "NetDescriptor %08" PRIxPTR ": ref=1 (%d)\n",
+	log_add(log_Debug, "NetDescriptor %08" PRIxPTR ": ref=1 (%d)",
 			(uintptr_t) nd, nd->refCount);
 #endif
 
@@ -117,7 +117,7 @@ NetDescriptor_incRef(NetDescriptor *nd)
 	assert(nd->refCount < REFCOUNT_MAX);
 	nd->refCount++;
 #ifdef DEBUG_NETDESCRIPTOR_REF
-	log_add(log_Debug, "NetDescriptor %08" PRIxPTR ": ref++ (%d)\n",
+	log_add(log_Debug, "NetDescriptor %08" PRIxPTR ": ref++ (%d)",
 			(uintptr_t) nd, nd->refCount);
 #endif
 }
@@ -128,7 +128,7 @@ NetDescriptor_decRef(NetDescriptor *nd)
 	assert(nd->refCount > 0);
 	nd->refCount--;
 #ifdef DEBUG_NETDESCRIPTOR_REF
-	log_add(log_Debug, "NetDescriptor %08" PRIxPTR ": ref-- (%d)\n",
+	log_add(log_Debug, "NetDescriptor %08" PRIxPTR ": ref-- (%d)",
 			(uintptr_t) nd, nd->refCount);
 #endif
 	if (nd->refCount == 0) {
diff -ruNp src.orig/sc2code/libs/network/netmanager/netmanager_bsd.c src/sc2code/libs/network/netmanager/netmanager_bsd.c
--- src.orig/sc2code/libs/network/netmanager/netmanager_bsd.c	2017-11-08 16:49:31 -0600
+++ src/sc2code/libs/network/netmanager/netmanager_bsd.c	2017-11-08 16:49:58 -0600
@@ -154,7 +154,7 @@ NetManager_process(uint32 *timeoutMs) {
 	} while (selectResult == -1 && errno == EINTR);
 	if (selectResult == -1) {
 		int savedErrno = errno;
-		log_add(log_Error, "select() failed: %s.\n", strerror(errno));
+		log_add(log_Error, "select() failed: %s.", strerror(errno));
 		errno = savedErrno;
 		*timeoutMs = (timeout.tv_sec * 1000) + (timeout.tv_usec / 1000);
 				// XXX: rounding microseconds down. Is that the correct
diff -ruNp src.orig/sc2code/libs/network/netmanager/netmanager_win.c src/sc2code/libs/network/netmanager/netmanager_win.c
--- src.orig/sc2code/libs/network/netmanager/netmanager_win.c	2017-11-08 16:49:31 -0600
+++ src/sc2code/libs/network/netmanager/netmanager_win.c	2017-11-08 16:49:59 -0600
@@ -89,7 +89,7 @@ closeWSAEvent(WSAEVENT event) {
 		error = WSAGetLastError();
 		if (error != WSAEINPROGRESS) {
 			log_add(log_Error,
-					"WSACloseEvent() failed with error code %d.\n", error);
+					"WSACloseEvent() failed with error code %d.", error);
 			errno = winsockErrorToErrno(error);
 			return -1;
 		}
@@ -137,7 +137,7 @@ NetManager_addDesc(NetDescriptor *nd) {
 			int savedErrno = getWinsockErrno();
 			int closeStatus = closeWSAEvent(event);
 			if (closeStatus == -1) {
-				log_add(log_Fatal, "closeWSAEvent() failed: %s.\n",
+				log_add(log_Fatal, "closeWSAEvent() failed: %s.",
 						strerror(errno));
 				explode();
 			}
@@ -224,7 +224,7 @@ NetManager_updateEvent(NetDescriptor *nd
 		int savedErrno = getWinsockErrno();
 		int closeStatus = closeWSAEvent(events[nd->smd->index]);
 		if (closeStatus == -1) {
-			log_add(log_Fatal, "closeWSAEvent() failed: %s.\n",
+			log_add(log_Fatal, "closeWSAEvent() failed: %s.",
 					strerror(errno));
 			explode();
 		}
@@ -265,7 +265,7 @@ activateSomeCallback(NetDescriptor *nd,
 	{
 		int status = NetManager_updateEvent(nd);
 		if (status == -1) {
-			log_add(log_Fatal, "NetManager_updateEvent() failed: %s.\n",
+			log_add(log_Fatal, "NetManager_updateEvent() failed: %s.",
 					strerror(errno));
 			explode();
 			// TODO: better error handling.
@@ -279,7 +279,7 @@ deactivateSomeCallback(NetDescriptor *nd
 	{
 		int status = NetManager_updateEvent(nd);
 		if (status == -1) {
-			log_add(log_Fatal, "NetManager_updateEvent() failed: %s.\n",
+			log_add(log_Fatal, "NetManager_updateEvent() failed: %s.",
 					strerror(errno));
 			explode();
 			// TODO: better error handling
diff -ruNp src.orig/sc2code/libs/network/network_win.c src/sc2code/libs/network/network_win.c
--- src.orig/sc2code/libs/network/network_win.c	2017-11-08 16:49:31 -0600
+++ src/sc2code/libs/network/network_win.c	2017-11-08 16:49:59 -0600
@@ -35,23 +35,23 @@ Network_init(void) {
 	startupResult = WSAStartup(requestVersion, &data);
 	if (startupResult != 0) {
 		int savedErrno = winsockErrorToErrno(startupResult);
-		log_add(log_Fatal, "WSAStartup failed.\n");
+		log_add(log_Fatal, "WSAStartup failed.");
 		errno = savedErrno;
 		explode();
 	}
 
 #ifdef DEBUG
-	log_add(log_Debug, "Winsock version %d.%d found: \"%s\".\n",
+	log_add(log_Debug, "Winsock version %d.%d found: \"%s\".",
 			LOBYTE(data.wHighVersion), HIBYTE(data.wHighVersion),
 			data.szDescription);
 	log_add(log_Debug, "Requesting to use Winsock version %d.%d, got "
-			"version %d.%d.\n",
+			"version %d.%d.",
 			LOBYTE(requestVersion), HIBYTE(requestVersion),
 			LOBYTE(data.wVersion), HIBYTE(data.wVersion));
 #endif
 	if (data.wVersion != requestVersion) {
 		log_add(log_Fatal, "Winsock version %d.%d presented, requested "
-				"%d.%d.\n", LOBYTE(data.wVersion), HIBYTE(data.wVersion),
+				"%d.%d.", LOBYTE(data.wVersion), HIBYTE(data.wVersion),
 				LOBYTE(requestVersion), HIBYTE(requestVersion));
 		(void) WSACleanup();
 				// Ignoring errors; we're going to abort anyhow.
@@ -66,7 +66,7 @@ Network_uninit(void) {
 	cleanupResult = WSACleanup();
 	if (cleanupResult == SOCKET_ERROR) {
 		int savedErrno = getWinsockErrno();
-		log_add(log_Fatal, "WSACleanup failed.\n");
+		log_add(log_Fatal, "WSACleanup failed.");
 		errno = savedErrno;
 		explode();
 	}
diff -ruNp src.orig/sc2code/libs/network/socket/socket_bsd.c src/sc2code/libs/network/socket/socket_bsd.c
--- src.orig/sc2code/libs/network/socket/socket_bsd.c	2017-11-08 16:49:31 -0600
+++ src/sc2code/libs/network/socket/socket_bsd.c	2017-11-08 16:49:59 -0600
@@ -30,7 +30,7 @@
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <netdb.h>
-#if defined(__FreeBSD__) || defined(__OpenBSD__)
+#if defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__)
 #	include <netinet/in_systm.h>
 #	include <netinet/in.h>
 #endif
@@ -142,7 +142,7 @@ Socket_setNonBlocking(Socket *sock) {
 	if (flags == -1) {
 		int savedErrno = errno;
 		log_add(log_Error, "Getting file descriptor flags of socket failed: "
-				"%s.\n", strerror(errno));
+				"%s.", strerror(errno));
 		errno = savedErrno;
 		return -1;
 	}
@@ -150,7 +150,7 @@ Socket_setNonBlocking(Socket *sock) {
 	if (fcntl(sock->fd, F_SETFL, flags | O_NONBLOCK) == -1) {
 		int savedErrno = errno;
 		log_add(log_Error, "Setting non-blocking mode on socket failed: "
-				"%s.\n", strerror(errno));
+				"%s.", strerror(errno));
 		errno = savedErrno;
 		return -1;
 	}
@@ -165,7 +165,7 @@ Socket_setReuseAddr(Socket *sock) {
 	if (setsockopt(sock->fd, SOL_SOCKET, SO_REUSEADDR, &flag, sizeof flag)
 			== -1) {
 		int savedErrno = errno;
-		log_add(log_Error, "Setting socket reuse failed: %s.\n",
+		log_add(log_Error, "Setting socket reuse failed: %s.",
 				strerror(errno));
 		errno = savedErrno;
 		return -1;
@@ -183,7 +183,7 @@ Socket_setNodelay(Socket *sock) {
 			== -1) {
 #ifdef DEBUG
 		int savedErrno = errno;
-		log_add(log_Warning, "Disabling Nagle algorithm failed: %s.\n",
+		log_add(log_Warning, "Disabling Nagle algorithm failed: %s.",
 				strerror(errno));
 		errno = savedErrno;
 #endif
@@ -199,7 +199,7 @@ Socket_setTOS(Socket *sock, int tos) {
 	if (setsockopt(sock->fd, IPPROTO_IP, IP_TOS, &tos, sizeof tos) == -1) {
 #ifdef DEBUG
 		int savedErrno = errno;
-		log_add(log_Warning, "Setting socket type-of-service failed: %s.\n",
+		log_add(log_Warning, "Setting socket type-of-service failed: %s.",
 				strerror(errno));
 		errno = savedErrno;
 #endif
@@ -231,7 +231,7 @@ Socket_setInlineOOB(Socket *sock) {
 	if (setsockopt(sock->fd, SOL_SOCKET, SO_OOBINLINE, &flag, sizeof flag)
 			== -1) {
 		int savedErrno = errno;
-		log_add(log_Error, "Setting inline OOB on socket failed: %s\n",
+		log_add(log_Error, "Setting inline OOB on socket failed: %s",
 				strerror(errno));
 		errno = savedErrno;
 		return -1;
@@ -246,7 +246,7 @@ Socket_setKeepAlive(Socket *sock) {
 	if (setsockopt(sock->fd, IPPROTO_TCP, SO_KEEPALIVE, &flag, sizeof flag)
 			== -1) {
 		int savedErrno = errno;
-		log_add(log_Error, "Setting keep-alive on socket failed: %s\n",
+		log_add(log_Error, "Setting keep-alive on socket failed: %s",
 				strerror(errno));
 		errno = savedErrno;
 		return -1;
diff -ruNp src.orig/sc2code/libs/network/socket/socket_win.c src/sc2code/libs/network/socket/socket_win.c
--- src.orig/sc2code/libs/network/socket/socket_win.c	2017-11-08 16:49:31 -0600
+++ src/sc2code/libs/network/socket/socket_win.c	2017-11-08 16:49:59 -0600
@@ -178,7 +178,7 @@ Socket_setNonBlocking(Socket *sock) {
 
 	if (ioctlsocket(sock->sock, FIONBIO, &flag) == SOCKET_ERROR) {
 		int savedErrno = getWinsockErrno();
-		log_add(log_Error, "Setting non-block mode on socket failed: %s.\n",
+		log_add(log_Error, "Setting non-block mode on socket failed: %s.",
 				strerror(errno));
 		errno = savedErrno;
 		return -1;
@@ -193,7 +193,7 @@ Socket_setReuseAddr(Socket *sock) {
 	if (setsockopt(sock->sock, SOL_SOCKET, SO_REUSEADDR,
 				(const char *) &flag, sizeof flag) == SOCKET_ERROR) {
 		int savedErrno = getWinsockErrno();
-		log_add(log_Error, "Setting socket reuse failed: %s.\n",
+		log_add(log_Error, "Setting socket reuse failed: %s.",
 				strerror(errno));
 		errno = savedErrno;
 		return -1;
@@ -211,7 +211,7 @@ Socket_setNodelay(Socket *sock) {
 				(const char *) &flag, sizeof flag) == SOCKET_ERROR) {
 #ifdef DEBUG
 		int savedErrno = getWinsockErrno();
-		log_add(log_Warning, "Disabling Nagle algorithm failed: %s.\n",
+		log_add(log_Warning, "Disabling Nagle algorithm failed: %s.",
 				strerror(errno));
 		errno = savedErrno;
 #endif
@@ -245,7 +245,7 @@ Socket_setInlineOOB(Socket *sock) {
 	if (setsockopt(sock->sock, SOL_SOCKET, SO_OOBINLINE, (const char *) &flag,
 			sizeof flag) == SOCKET_ERROR) {
 		int savedErrno = getWinsockErrno();
-		log_add(log_Error, "Setting inline OOB on socket failed: %s\n",
+		log_add(log_Error, "Setting inline OOB on socket failed: %s",
 				strerror(errno));
 		errno = savedErrno;
 		return -1;
@@ -260,7 +260,7 @@ Socket_setKeepAlive(Socket *sock) {
 	if (setsockopt(sock->sock, IPPROTO_TCP, SO_KEEPALIVE,
 			(const char *) &flag, sizeof flag) == SOCKET_ERROR) {
 		int savedErrno = getWinsockErrno();
-		log_add(log_Error, "Setting keep-alive on socket failed: %s\n",
+		log_add(log_Error, "Setting keep-alive on socket failed: %s",
 				strerror(errno));
 		errno = savedErrno;
 		return -1;
diff -ruNp src.orig/sc2code/libs/reslib.h src/sc2code/libs/reslib.h
--- src.orig/sc2code/libs/reslib.h	2017-11-08 16:49:31 -0600
+++ src/sc2code/libs/reslib.h	2017-11-08 16:49:59 -0600
@@ -20,83 +20,61 @@
 #define _RESLIB_H
 
 //#include <stdio.h>
+#include "compiler.h"
 #include "port.h"
-#include "memlib.h"
-#include  "libs/uio.h"
+#include "misc.h"
+#include "libs/uio.h"
 
+typedef struct resource_index_desc RESOURCE_INDEX_DESC;
+typedef RESOURCE_INDEX_DESC *RESOURCE_INDEX;
 
-typedef DWORD RESOURCE;
+typedef const char *RESOURCE;
 
-typedef BYTE RES_TYPE;
-typedef COUNT RES_INSTANCE;
-typedef COUNT RES_PACKAGE;
-
-#define TYPE_BITS 8
-#define INSTANCE_BITS 13
-#define PACKAGE_BITS 11
-
-#define GET_TYPE(res) \
-		((RES_TYPE)(res) & (RES_TYPE)((1 << TYPE_BITS) - 1))
-#define GET_INSTANCE(res) \
-		((RES_INSTANCE)((res) >> TYPE_BITS) & ((1 << INSTANCE_BITS) - 1))
-#define GET_PACKAGE(res) \
-		((RES_PACKAGE)((res) >> (TYPE_BITS + INSTANCE_BITS)) & \
-		((1 << PACKAGE_BITS) - 1))
-#define MAKE_RESOURCE(p,t,i) \
-		(((RESOURCE)(p) << (TYPE_BITS + INSTANCE_BITS)) | \
-		((RESOURCE)(i) << TYPE_BITS) | \
-		((RESOURCE)(t)))
+typedef union {
+	DWORD num;
+	void *ptr;
+} RESOURCE_DATA;
 
+#define NULL_RESOURCE NULL
 
 extern const char *_cur_resfile_name;
 
-typedef MEM_HANDLE (ResourceLoadFun) (uio_Stream *fp, DWORD len);
-typedef BOOLEAN (ResourceFreeFun) (MEM_HANDLE handle);
+typedef void (ResourceLoadFun) (const char *pathname, RESOURCE_DATA *resdata);
+typedef BOOLEAN (ResourceFreeFun) (void *handle);
+				  
+typedef void *(ResourceLoadFileFun) (uio_Stream *fp, DWORD len);
+
+void *LoadResourceFromPath(const char *pathname, ResourceLoadFileFun fn);
+
+uio_Stream *res_OpenResFile (uio_DirHandle *dir, const char *filename, const char *mode);
+int ReadResFile (void *lpBuf, COUNT size, COUNT count, uio_Stream *fp);
+int WriteResFile (const void *lpBuf, COUNT size, COUNT count, uio_Stream *fp);
+int GetResFileChar (uio_Stream *fp);
+int PutResFileChar (char ch, uio_Stream *fp);
+int PutResFileNewline (uio_Stream *fp);
+long SeekResFile (uio_Stream *fp, long offset, int whence);
+long TellResFile (uio_Stream *fp);
+long LengthResFile (uio_Stream *fp);
+BOOLEAN res_CloseResFile (uio_Stream *fp);
+BOOLEAN DeleteResFile (uio_DirHandle *dir, const char *filename);
+
+RESOURCE_INDEX InitResourceSystem ();
+void UninitResourceSystem (void);
+BOOLEAN InstallResTypeVectors (const char *res_type, ResourceLoadFun *loadFun, ResourceFreeFun *freeFun);
+void *res_GetResource (RESOURCE res);
+void *res_DetachResource (RESOURCE res);
+BOOLEAN FreeResource (RESOURCE res);
+COUNT CountResourceTypes (void);
+DWORD res_GetIntResource (RESOURCE res);
+BOOLEAN res_GetBooleanResource (RESOURCE res);
+const char *res_GetResourceType (RESOURCE res);
 
-extern uio_Stream *res_OpenResFile (uio_DirHandle *dir, const char *filename,
-		const char *mode);
-extern int ReadResFile (PVOID lpBuf, COUNT size, COUNT count, uio_Stream *fp);
-extern int WriteResFile (PCVOID lpBuf, COUNT size, COUNT count,
-		uio_Stream *fp);
-extern int GetResFileChar (uio_Stream *fp);
-extern int PutResFileChar (char ch, uio_Stream *fp);
-extern int PutResFileNewline (uio_Stream *fp);
-extern long SeekResFile (uio_Stream *fp, long offset, int whence);
-extern long TellResFile (uio_Stream *fp);
-extern long LengthResFile (uio_Stream *fp);
-extern BOOLEAN res_CloseResFile (uio_Stream *fp);
-extern BOOLEAN DeleteResFile (uio_DirHandle *dir, const char *filename);
-
-extern MEM_HANDLE InitResourceSystem (const char *resfile, RES_TYPE resType,
-		BOOLEAN (*FileErrorFun) (const char *filename));
-extern void UninitResourceSystem (void);
-extern BOOLEAN InstallResTypeVectors (RES_TYPE res_type,
-		ResourceLoadFun *loadFun, ResourceFreeFun *freeFun);
-extern MEM_HANDLE res_GetResource (RESOURCE res);
-extern MEM_HANDLE res_DetachResource (RESOURCE res);
-extern BOOLEAN FreeResource (RESOURCE res);
-extern COUNT CountResourceTypes (void);
-
-extern MEM_HANDLE OpenResourceIndexFile (const char *resfile);
-extern MEM_HANDLE OpenResourceIndexInstance (RESOURCE res);
-extern MEM_HANDLE SetResourceIndex (MEM_HANDLE newIndexHandle);
-extern BOOLEAN CloseResourceIndex (MEM_HANDLE newIndexHandle);
-
-extern MEM_HANDLE GetResourceData (uio_Stream *fp, DWORD length,
-		MEM_FLAGS mem_flags);
-
-#define RESOURCE_PRIORITY DEFAULT_MEM_PRIORITY
-#define RESOURCE_DATAPTR PBYTE
-
-#define AllocResourceData(s,mf) \
-	mem_allocate ((MEM_SIZE)(s), (mf), RESOURCE_PRIORITY, MEM_SIMPLE)
-#define LockResourceData(h,lp) \
-do \
-{ \
-	*(lp) = mem_lock ((MEM_HANDLE)(h)); \
-} while (0)
-#define UnlockResourceData mem_unlock
-#define FreeResourceData mem_release
+void LoadResourceIndex (uio_DirHandle *dir, const char *filename);
+
+void *GetResourceData (uio_Stream *fp, DWORD length);
+
+#define AllocResourceData HMalloc
+BOOLEAN FreeResourceData (void *);
 
 #include "strlib.h"
 
@@ -104,10 +82,8 @@ typedef STRING_TABLE DIRENTRY_REF;
 typedef STRING DIRENTRY;
 typedef STRINGPTR DIRENTRYPTR;
 
-
 extern DIRENTRY_REF LoadDirEntryTable (uio_DirHandle *dirHandle,
-		const char *path, const char *pattern, match_MatchType matchType,
-		PCOUNT pnum_entries);
+		const char *path, const char *pattern, match_MatchType matchType);
 #define CaptureDirEntryTable CaptureStringTable
 #define ReleaseDirEntryTable ReleaseStringTable
 #define DestroyDirEntryTable DestroyStringTable
@@ -142,5 +118,6 @@ BOOLEAN res_IsBoolean (const char *key);
 BOOLEAN res_GetBoolean (const char *key);
 void res_PutBoolean (const char *key, BOOLEAN value);
 
-#endif /* _RESLIB_H */
+BOOLEAN res_Remove (const char *key);
 
+#endif /* _RESLIB_H */
diff -ruNp src.orig/sc2code/libs/resource/Makeinfo src/sc2code/libs/resource/Makeinfo
--- src.orig/sc2code/libs/resource/Makeinfo	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/resource/Makeinfo	2017-11-08 16:49:59 -0600
@@ -1,2 +1,2 @@
-uqm_CFILES="alist.c direct.c filecntl.c getres.c loadres.c mapres.c
-		resdata.c resinit.c stringbank.c"
+uqm_CFILES="direct.c filecntl.c getres.c loadres.c mapres.c
+		propfile.c resdata.c resinit.c stringbank.c"
diff -ruNp src.orig/sc2code/libs/resource/alist.c src/sc2code/libs/resource/alist.c
--- src.orig/sc2code/libs/resource/alist.c	2017-11-08 16:49:31 -0600
+++ src/sc2code/libs/resource/alist.c	1969-12-31 18:00:00 -0600
@@ -1,230 +0,0 @@
-/*  alist.c, Copyright (c) 2005 Michael C. Martin */
-
-/*
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope thta it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  Se the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include <stdlib.h>
-#include <string.h>
-#include <ctype.h>
-#include "libs/reslib.h"
-#include "libs/log.h"
-#include "alist.h"
-
-alist_entry *
-AlistEntry_New (alist *m, const char *key, const char *value)
-{
-	alist_entry *e;
-	e = malloc (sizeof(alist_entry));
-	e->key = StringBank_AddOrFindString(m->bank, key);
-	e->value = StringBank_AddOrFindString(m->bank, value);
-	e->next = NULL;
-	return e;
-}
-
-void
-AlistEntry_Free (alist_entry *e)
-{
-	if (e == NULL)
-		return;
-	AlistEntry_Free (e->next);
-	free (e);
-}
-
-alist *
-Alist_New (void)
-{
-	alist *result = malloc (sizeof(alist));
-	result->first = NULL;
-	result->bank = StringBank_Create ();
-	return result;
-}
-
-void
-Alist_Free (alist *m) {
-	if (m == NULL) return;
-	AlistEntry_Free (m->first);
-	StringBank_Free (m->bank);
-	free (m);
-}
-
-alist_entry *
-Alist_GetEntry (alist *m, const char *key)
-{
-	alist_entry *x = m->first;
-	while (x != NULL) {
-		if (!strcmp (x->key, key))
-			return x;
-		x = x->next;
-	}
-	return NULL;
-}
-
-const char *
-Alist_GetString (alist *m, const char *key)
-{
-	alist_entry *x = Alist_GetEntry (m, key);
-	return x ? x->value : NULL;
-}
-
-void
-Alist_PutString (alist *m, const char *key, const char *value)
-{
-	alist_entry *e = Alist_GetEntry (m, key);
-	if (e == NULL) {
-		e = AlistEntry_New(m, key, value);
-		e->next = m->first;
-		m->first = e;
-	} else {
-		e->value = StringBank_AddOrFindString(m->bank, value);
-	}
-}
-
-void
-Alist_PutAll (alist *dst, alist *src)
-{
-	alist_entry *e = src->first;
-	while (e) {
-		Alist_PutString (dst,
-				StringBank_AddOrFindString(dst->bank, e->key),
-				StringBank_AddOrFindString(dst->bank, e->value));
-		e = e->next;
-	}
-}
-
-alist *
-Alist_New_FromFile (uio_Stream *f)
-{
-	long flen;
-	alist *m;
-	char *data;
-
-	flen = LengthResFile (f);
-
-	data = malloc (flen + 1);
-	if (!data) {
-		return NULL;
-	}
-
-	flen = ReadResFile (data, 1, flen, f);
-	data[flen] = '\0';
-
-	m = Alist_New_FromString (data);
-	free (data);
-	return m;
-}
-
-alist *
-Alist_New_FromFilename (uio_DirHandle *path, const char *fname)
-{
-	alist *result;
-	uio_Stream *f = res_OpenResFile (path, fname, "rt");
-	if (!f) {
-		return NULL;
-	}
-	result = Alist_New_FromFile (f);
-	res_CloseResFile(f);
-	return result;
-}
-
-alist *
-Alist_New_FromString (char *d)
-{
-	alist *m = Alist_New ();
-	int len, i;
-	if (!m) return NULL;
-
-	len = strlen(d);
-	i = 0;
-	while (i < len) {
-		int key_start, key_end, value_start, value_end;
-		/* Starting a line: search for non-whitespace */
-		while ((i < len) && isspace (d[i])) i++;
-		if (i >= len) break;  /* Done parsing! */
-		/* If it was a comment, skip to end of comment/file */
-		if (d[i] == '#') {
-			while ((i < len) && (d[i] != '\n')) i++;
-			if (i >= len) break;
-			continue; /* Back to keyword search */
-		}
-		key_start = i;
-		/* Find the = on this line */
-		while ((i < len) && (d[i] != '=') &&
-		       (d[i] != '\n') && (d[i] != '#')) i++;
-		if (i >= len) {  /* Bare key at EOF */
-			log_add (log_Warning, "Warning: Bare keyword at EOF");
-			break;
-		}
-		/* Comments here mean incomplete line too */
-		if (d[i] != '=') {
-			log_add (log_Warning, "Warning: Key without value");
-			while ((i < len) && (d[i] != '\n')) i++;
-			if (i >= len) break;
-			continue; /* Back to keyword search */
-		}
-		/* Key ends at first whitespace before = , or at key_start*/
-		key_end = i;
-		while ((key_end > key_start) && isspace (d[key_end-1]))
-			key_end--;
-		
-		/* Consume the = */
-		i++;
-		/* Value starts at first non-whitespace after = on line... */
-		while ((i < len) && (d[i] != '#') && (d[i] != '\n') &&
-		       isspace (d[i]))
-			i++;
-		value_start = i;
-		/* Until first non-whitespace before terminator */
-		while ((i < len) && (d[i] != '#') && (d[i] != '\n'))
-			i++;
-		value_end = i;
-		while ((value_end > value_start) && isspace (d[value_end-1]))
-			value_end--;
-		/* Skip past EOL or EOF */
-		while ((i < len) && (d[i] != '\n'))
-			i++;
-		i++;
-
-		/* We now have start and end values for key and value.
-		   We terminate the strings for both by writing \0s, then
-		   make a new map entry. */
-		d[key_end] = '\0';
-		d[value_end] = '\0';
-		Alist_PutString (m, StringBank_AddOrFindString(m->bank, d+key_start), 
-				  StringBank_AddOrFindString(m->bank, d+value_start));
-	}
-	return m;
-}
-
-void
-Alist_Dump (alist *m, uio_Stream *s, const char *prefix)
-{
-	alist_entry *e = m->first;
-	int prefix_len = 0;
-	if (prefix)
-		prefix_len = strlen (prefix);
-	while (e) {
-		if (!prefix || !strncmp (prefix, e->key, prefix_len)) {
-			WriteResFile (e->key, 1, strlen (e->key), s);
-			PutResFileChar(' ', s);
-			PutResFileChar('=', s);
-			PutResFileChar(' ', s);
-			WriteResFile (e->value, 1, strlen (e->value), s);
-			PutResFileNewline(s);
-		}
-		e = e->next;
-	}
-	return;
-}
diff -ruNp src.orig/sc2code/libs/resource/alist.h src/sc2code/libs/resource/alist.h
--- src.orig/sc2code/libs/resource/alist.h	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/resource/alist.h	1969-12-31 18:00:00 -0600
@@ -1,67 +0,0 @@
-/*  alist.h, Copyright (c) 2005 Michael C. Martin */
-
-/*
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope thta it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  Se the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _ALIST_H_
-#define _ALIST_H_
-
-#include "libs/uio.h"
-#include "stringbank.h"
-
-/* Associative List types. */
-
-typedef struct _alist_entry {
-	const char *key, *value;
-	struct _alist_entry *next;
-} alist_entry;
-
-typedef struct _alist_map {
-	alist_entry *first;
-	stringbank *bank;
-} alist;
-
-/* ***** alist_entry operations ***** */
-
-/* Constructor and destructor */
-alist_entry *AlistEntry_New (alist *m, const char *key, const char *value);
-void AlistEntry_Free (alist_entry *e);
-
-/* ***** alist operations ***** */
-
-/* Standard constructor and destructor */
-alist *Alist_New (void);
-void Alist_Free (alist *m);
-
-/* Specialized constructors: Parse an alist out of a stream, file, or
-   string.  It expects a bunch of key=value statements, one per
-   line. */
-alist *Alist_New_FromFile (uio_Stream *f);
-alist *Alist_New_FromFilename (uio_DirHandle *path, const char *fname);
-alist *Alist_New_FromString (char *d);
-
-/* Getting and Setting operations */
-alist_entry *Alist_GetEntry (alist *m, const char *key);
-const char *Alist_GetString (alist *m, const char *key);
-void Alist_PutString (alist *m, const char *key, const char *value);
-void Alist_PutAll (alist *dest, alist *src);
-
-/* Dump the alist to the specified stream in a form that could be
-   read later by the Alist_New_From* routines.  Dump only keys
-   that begin with the prefix; NULL means all keys. */
-void Alist_Dump (alist *m, uio_Stream *s, const char *prefix);
-
-#endif   /* _ALIST_H_ */
diff -ruNp src.orig/sc2code/libs/resource/direct.c src/sc2code/libs/resource/direct.c
--- src.orig/sc2code/libs/resource/direct.c	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/resource/direct.c	2017-11-08 16:49:59 -0600
@@ -17,30 +17,28 @@
  */
 
 #include "libs/strings/strintrn.h"
+#include "misc.h"
 #include "port.h"
 #include "libs/uio.h"
 #include <sys/stat.h>
 
 DIRENTRY_REF
 LoadDirEntryTable (uio_DirHandle *dirHandle, const char *path,
-		const char *pattern, match_MatchType matchType, PCOUNT pnum_entries)
+		const char *pattern, match_MatchType matchType)
 {
 	uio_DirList *dirList;
-	COUNT num_entries, length;
+	COUNT num_entries;
 	COUNT i;
-	COUNT slen;
 	uio_DirHandle *dir;
 	STRING_TABLE StringTable;
-	STRING_TABLEPTR lpST;
-	PSTR lpStr;
-	PDWORD lpLastOffs;
+	STRING_TABLE_DESC *lpST;
+	STRING lpLastString;
 
 	dir = uio_openDirRelative (dirHandle, path, 0);
 	assert(dir != NULL);
 	dirList = uio_getDirList (dir, "", pattern, matchType);
 	assert(dirList != NULL);
 	num_entries = 0;
-	length = 0;
 
 	// First, count the amount of space needed
 	for (i = 0; i < dirList->numNames; i++)
@@ -62,49 +60,42 @@ LoadDirEntryTable (uio_DirHandle *dirHan
 			dirList->names[i] = NULL;
 			continue;
 		}
-		length += strlen (dirList->names[i]) + 1;
 		num_entries++;
 	}
 	uio_closeDir (dir);
 
 	if (num_entries == 0) {
 		uio_DirList_free(dirList);
-		*pnum_entries = 0;
 		return ((DIRENTRY_REF) 0);
 	}
 
-	slen = sizeof (STRING_TABLE_DESC)
-			+ (num_entries * sizeof (DWORD));
-	StringTable = AllocResourceData (slen + length, 0);
-	LockStringTable (StringTable, &lpST);
+	StringTable = AllocStringTable (num_entries, 0);
+	lpST = StringTable;
 	if (lpST == 0)
 	{
 		FreeStringTable (StringTable);
 		uio_DirList_free(dirList);
-		*pnum_entries = 0;
 		return ((DIRENTRY_REF) 0);
 	}
-	lpST->StringCount = num_entries;
-	lpLastOffs = &lpST->StringOffsets[0];
-	*lpLastOffs = slen;
-	lpStr = (PSTR)lpST + slen;
+	lpST->size = num_entries;
+	lpLastString = lpST->strings;
 
 	for (i = 0; i < dirList->numNames; i++)
 	{
 		int size;
+		STRINGPTR target;
 		if (dirList->names[i] == NULL)
 			continue;
 		size = strlen (dirList->names[i]) + 1;
-		memcpy (lpStr, dirList->names[i], size);
-		lpLastOffs[1] = lpLastOffs[0] + size;
-		lpLastOffs++;
-		lpStr += size;
+		target = HMalloc (size);
+		memcpy (target, dirList->names[i], size);
+		lpLastString->data = target;
+		lpLastString->length = size;
+		lpLastString++;
 	}
 	
 	uio_DirList_free(dirList);
-	*pnum_entries = num_entries;
-	UnlockStringTable (StringTable);
-	return ((DIRENTRY_REF) StringTable);
+	return StringTable;
 }	
 
 
diff -ruNp src.orig/sc2code/libs/resource/filecntl.c src/sc2code/libs/resource/filecntl.c
--- src.orig/sc2code/libs/resource/filecntl.c	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/resource/filecntl.c	2017-11-08 16:49:59 -0600
@@ -61,7 +61,7 @@ DeleteResFile (uio_DirHandle *dir, const
 }
 
 int
-ReadResFile (PVOID lpBuf, COUNT size, COUNT count, uio_Stream *fp)
+ReadResFile (void *lpBuf, COUNT size, COUNT count, uio_Stream *fp)
 {
 	int retval;
 
@@ -71,7 +71,7 @@ ReadResFile (PVOID lpBuf, COUNT size, CO
 }
 
 int
-WriteResFile (PCVOID lpBuf, COUNT size, COUNT count, uio_Stream *fp)
+WriteResFile (const void *lpBuf, COUNT size, COUNT count, uio_Stream *fp)
 {
 	int retval;
 
diff -ruNp src.orig/sc2code/libs/resource/getres.c src/sc2code/libs/resource/getres.c
--- src.orig/sc2code/libs/resource/getres.c	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/resource/getres.c	2017-11-08 16:49:59 -0600
@@ -21,83 +21,35 @@
 #include "resintrn.h"
 #include "libs/misc.h"
 #include "libs/log.h"
-
+#include "libs/uio/charhashtable.h"
 
 const char *_cur_resfile_name;
 // When a file is being loaded, _cur_resfile_name is set to its name.
 // At other times, it is NULL.
 
-static ResourceDesc *
-lookupResourceDesc (ResourceIndex *idx, RESOURCE res) {
-	// Binary search through the resources.
-	COUNT l, h;
-
-	if (idx->numRes == 0)
-		return NULL;
-	
-	l = 0;
-	h = idx->numRes;
-
-	while (l + 1 != h)
-	{
-		COUNT m = (l + h) / 2;
-		if (idx->res[m]->res <= res)
-			l = m;
-		else
-			h = m;
-	}
-
-	if (idx->res[l]->res == res)
-		return idx->res[l];
-	return NULL;
+ResourceDesc *
+lookupResourceDesc (RESOURCE_INDEX idx, RESOURCE res) {
+	return (ResourceDesc *) CharHashTable_find (idx->map, res);
 }
 
-// Load every resource in a package.
-static void
-loadPackage (ResourceIndex *idx, RES_PACKAGE pkg) {
-	COUNT i;
-
-	for (i = 0; i < idx->numRes; i++) {
-		if (GET_PACKAGE (idx->res[i]->res) != pkg)
-			continue;
-	
-		if (idx->res[i]->handle != NULL_HANDLE)
-			continue;  // Already loaded
-
-		loadResourceDesc (idx, idx->res[i]);
-	}
-}
-
-MEM_HANDLE
-loadResourceDesc (ResourceIndex *idx, ResourceDesc *desc)
+void
+loadResourceDesc (ResourceDesc *desc)
 {
-	RES_TYPE resType = GET_TYPE (desc->res);
-	
-	if (resType >= idx->typeInfo.numTypes ||
-			idx->typeInfo.handlers[resType].loadFun == NULL)
-	{
-		log_add (log_Warning, "Warning: Unable to load '%s'; no handler "
-				"for type %d defined.", desc->path, resType);
-		return NULL_HANDLE;
-	}
-
-	desc->handle = loadResource (desc->path,
-			idx->typeInfo.handlers[resType].loadFun);
-	return desc->handle;
+	desc->vtable->loadFun (desc->fname, &desc->resdata);
 }
 
-MEM_HANDLE
-loadResource(const char *path, ResourceLoadFun *loadFun)
+void *
+LoadResourceFromPath (const char *path, ResourceLoadFileFun *loadFun)
 {
 	uio_Stream *stream;
 	long dataLen;
-	MEM_HANDLE handle;
+	void *resdata;
 
 	stream = res_OpenResFile (contentDir, path, "rb");
 	if (stream == NULL)
 	{
 		log_add (log_Warning, "Warning: Can't open '%s'", path);
-		return NULL_HANDLE;
+		return NULL;
 	}
 
 	dataLen = LengthResFile (stream);
@@ -110,47 +62,103 @@ loadResource(const char *path, ResourceL
 	}
 
 	_cur_resfile_name = path;
-	handle = (*loadFun) (stream, dataLen);
+	resdata = (*loadFun) (stream, dataLen);
 	_cur_resfile_name = NULL;
 	res_CloseResFile (stream);
 
-	return handle;
+	return resdata;
 
 err:
 	res_CloseResFile (stream);
-	return NULL_HANDLE;
+	return NULL;
+}
+
+const char *
+res_GetResourceType (RESOURCE res)
+{
+	RESOURCE_INDEX resourceIndex;
+	ResourceDesc *desc;
+	
+	if (res == NULL_RESOURCE)
+	{
+		log_add (log_Warning, "Trying to get type of null resource");
+		return NULL;
+	}
+	
+	resourceIndex = _get_current_index_header ();
+	desc = lookupResourceDesc (resourceIndex, res);
+	if (desc == NULL)
+	{
+		log_add (log_Warning, "Trying to get type of undefined resource '%s'",
+				res);
+		return NULL;
+	}
+	
+	return desc->vtable->resType;
 }
+	
 
 // Get a resource by its resource ID.
-// For historical reasons, if the resource is not already loaded,
-// the *entire* package will be (pre-)loaded.
-// NB. It may be better to add an extra flag to res_GetResource() to
-// indicate whether you really want this, or add a separate function
-// for preloading the entire package.
-MEM_HANDLE
+void *
 res_GetResource (RESOURCE res)
 {
-	ResourceIndex *resourceIndex;
+	RESOURCE_INDEX resourceIndex;
 	ResourceDesc *desc;
 	
+	if (res == NULL_RESOURCE)
+	{
+		log_add (log_Warning, "Trying to get null resource");
+		return NULL;
+	}
+	
 	resourceIndex = _get_current_index_header ();
 
 	desc = lookupResourceDesc (resourceIndex, res);
 	if (desc == NULL)
 	{
-		log_add (log_Warning, "Trying to get undefined resource %08x",
-				(DWORD) res);
-		return NULL_HANDLE;
+		log_add (log_Warning, "Trying to get undefined resource '%s'",
+				 res);
+		return NULL;
 	}
 
-	if (desc->handle != NULL_HANDLE)
-		return desc->handle;
+	if (desc->resdata.ptr != NULL)
+		return desc->resdata.ptr;
 
-	// Load the entire package, for historical reasons.
-	loadPackage (resourceIndex, GET_PACKAGE (res));
+	loadResourceDesc (desc);
 
-	return desc->handle;
-			// May still be NULL_HANDLE, if the load failed.
+	return desc->resdata.ptr;
+			// May still be NULL, if the load failed.
+}
+
+DWORD
+res_GetIntResource (RESOURCE res)
+{
+	RESOURCE_INDEX resourceIndex;
+	ResourceDesc *desc;
+	
+	if (res == NULL_RESOURCE)
+	{
+		log_add (log_Warning, "Trying to get null resource");
+		return 0;
+	}
+	
+	resourceIndex = _get_current_index_header ();
+
+	desc = lookupResourceDesc (resourceIndex, res);
+	if (desc == NULL)
+	{
+		log_add (log_Warning, "Trying to get undefined resource '%s'",
+				 res);
+		return 0;
+	}
+
+	return desc->resdata.num;
+}
+
+BOOLEAN
+res_GetBooleanResource (RESOURCE res)
+{
+	return (res_GetIntResource (res) != 0);
 }
 
 // NB: this function appears to be never called!
@@ -159,7 +167,6 @@ res_FreeResource (RESOURCE res)
 {
 	ResourceDesc *desc;
 	ResourceFreeFun *freeFun;
-	ResourceIndex *idx;
 
 	desc = lookupResourceDesc (_get_current_index_header(), res);
 	if (desc == NULL)
@@ -168,49 +175,66 @@ res_FreeResource (RESOURCE res)
 				"resource.");
 		return;
 	}
+
+	freeFun = desc->vtable->freeFun;
+	if (freeFun == NULL)
+	{
+		log_add (log_Debug, "Warning: trying to free a non-heap resource.");
+		return;
+	}
 	
-	if (desc->handle == NULL_HANDLE)
+	if (desc->resdata.ptr == NULL)
 	{
 		log_add (log_Debug, "Warning: trying to free not loaded "
 				"resource.");
 		return;
 	}
 
-	idx = _get_current_index_header ();
-	freeFun = idx->typeInfo.handlers[GET_TYPE (res)].freeFun;
-	(*freeFun) (desc->handle);
-	desc->handle = NULL_HANDLE;
+	(*freeFun) (desc->resdata.ptr);
+	desc->resdata.ptr = NULL;
 }
 
 // By calling this function the caller will be responsible of unloading
 // the resource. If res_GetResource() get called again for this
 // resource, a NEW copy will be loaded, regardless of whether a detached
 // copy still exists.
-MEM_HANDLE
+void *
 res_DetachResource (RESOURCE res)
 {
 	ResourceDesc *desc;
-	MEM_HANDLE result;
+	ResourceFreeFun *freeFun;
+	void *result;
 
 	desc = lookupResourceDesc (_get_current_index_header(), res);
 	if (desc == NULL)
 	{
 		log_add (log_Debug, "Warning: trying to detach from an unrecognised "
 				"resource.");
-		return NULL_HANDLE;
+		return NULL;
 	}
 	
-	if (desc->handle == NULL_HANDLE)
+	freeFun = desc->vtable->freeFun;
+	if (freeFun == NULL)
+	{
+		log_add (log_Debug, "Warning: trying to detatch from a non-heap resource.");
+		return NULL;
+	}
+	
+	if (desc->resdata.ptr == NULL)
 	{
 		log_add (log_Debug, "Warning: trying to detach from a not loaded "
 				"resource.");
-		return NULL_HANDLE;
+		return NULL;
 	}
 
-	result = desc->handle;
-	desc->handle = NULL_HANDLE;
+	result = desc->resdata.ptr;
+	desc->resdata.ptr = NULL;
 
 	return result;
 }
 
-
+BOOLEAN
+FreeResourceData (void *data) {
+	HFree (data);
+	return TRUE;
+}
\ No newline at end of file
diff -ruNp src.orig/sc2code/libs/resource/index.h src/sc2code/libs/resource/index.h
--- src.orig/sc2code/libs/resource/index.h	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/resource/index.h	2017-11-08 16:49:59 -0600
@@ -20,54 +20,29 @@
 #define _INDEX_H
 
 #include <stdio.h>
+#include "reslib.h"
+#include "libs/uio/charhashtable.h"
 
-typedef struct
-{
-	RESOURCE res;
-	char *path;
-	MEM_HANDLE handle;
-	//COUNT ref;
-} ResourceDesc;
-
-typedef struct
+typedef struct resource_handlers
 {
+	const char *resType;
 	ResourceLoadFun *loadFun;
 	ResourceFreeFun *freeFun;
 } ResourceHandlers;
 
-typedef struct
+typedef struct resource_desc
 {
-	RES_TYPE numTypes;
-			/* Number of types in the handlers array (whether NULL or not).
-			 * == the highest stored handler number + 1.
-			 */
-	ResourceHandlers *handlers;
-} ResourceTypeInfo;
+	RESOURCE res_id;
+	char *fname;
+	ResourceHandlers *vtable;
+	RESOURCE_DATA resdata;
+} ResourceDesc;
 
-typedef struct
+struct resource_index_desc
 {
-	ResourceDesc **res;
-	ResourceTypeInfo typeInfo;
+	CharHashTable_HashTable *map;
 	size_t numRes;
-} ResourceIndex;
-
-
-void
-forAllResourceIndices(
-		void (*callback) (ResourceIndex *idx, void *extra), void *extra);
-
-
-#define INDEX_HEADER_PRIORITY DEFAULT_MEM_PRIORITY
-
-static inline ResourceIndex *
-lockResourceIndex (MEM_HANDLE h) {
-	return (ResourceIndex *) mem_lock (h);
-}
-static inline void
-unlockResourceIndex (MEM_HANDLE h) {
-	mem_unlock (h);
-}
-
+};
 
 #endif /* _INDEX_H */
 
diff -ruNp src.orig/sc2code/libs/resource/loadres.c src/sc2code/libs/resource/loadres.c
--- src.orig/sc2code/libs/resource/loadres.c	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/resource/loadres.c	2017-11-08 16:49:59 -0600
@@ -19,64 +19,52 @@
 #include "resintrn.h"
 #include "declib.h"
 
-MEM_HANDLE
-GetResourceData (uio_Stream *fp, DWORD length, MEM_FLAGS mem_flags)
+void *
+GetResourceData (uio_Stream *fp, DWORD length)
 {
-	MEM_HANDLE RData;
-	DECODE_REF fh;
+	BYTE *RDPtr;
+	void *result;
+	DECODE_REF fh = 0;
 
 	if (length == ~(DWORD)0)
-		length = LengthResFile (fp), fh = 0;
+		length = LengthResFile (fp);
 	else if ((fh = copen (fp, FILE_STREAM, STREAM_READ)))
 		cfilelength (fh, &length);
 	else
 		length -= sizeof (DWORD);
 
-	RData = AllocResourceData (length, mem_flags);
-	if (RData)
+	result = AllocResourceData (length);
+	RDPtr = result;
+	if (RDPtr)
 	{
-		RESOURCE_DATAPTR RDPtr;
+		COUNT num_read;
 
-		LockResourceData (RData, &RDPtr);
-		if (RDPtr == NULL_PTR)
+		do
 		{
-			FreeResourceData (RData);
-			RData = 0;
-		}
-		else
-		{
-			COUNT num_read;
-
-			do
-			{
 #define READ_LENGTH 0x00007FFFL
-				num_read = length >= READ_LENGTH ?
-						(COUNT)READ_LENGTH : (COUNT)length;
-				if (fh)
-				{
-					if (cread (RDPtr, 1, num_read, fh) != num_read)
-						break;
-				}
-				else
-				{
-					if ((int)(ReadResFile (RDPtr, 1, num_read, fp)) != (int)num_read)
-						break;
-				}
-				RDPtr = (RESOURCE_DATAPTR) ((BYTE *) RDPtr + num_read);
-			} while (length -= num_read);
-
-			UnlockResourceData (RData);
-			if (length > 0)
+			num_read = length >= READ_LENGTH ?
+					(COUNT)READ_LENGTH : (COUNT)length;
+			if (fh)
 			{
-				FreeResourceData (RData);
-				RData = 0;
+				if (cread (RDPtr, 1, num_read, fh) != num_read)
+					break;
 			}
+			else
+			{
+				if ((int)(ReadResFile (RDPtr, 1, num_read, fp)) != (int)num_read)
+					break;
+			}
+			RDPtr += num_read;
+		} while (length -= num_read);
+
+		if (length > 0)
+		{
+			FreeResourceData (result);
+			result = NULL;
 		}
 	}
 
 	cclose (fh);
 
-	return (RData);
+	return result;
 }
-
-
diff -ruNp src.orig/sc2code/libs/resource/mapres.c src/sc2code/libs/resource/mapres.c
--- src.orig/sc2code/libs/resource/mapres.c	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/resource/mapres.c	2017-11-08 16:49:59 -0600
@@ -1,4 +1,4 @@
-/*  mapres.h, Copyright (c) 2005 Michael C. Martin */
+/*  mapres.c, Copyright (c) 2005 Michael C. Martin */
 
 /*
  *  This program is free software; you can redistribute it and/or modify
@@ -20,16 +20,25 @@
 #include <string.h>
 #include <ctype.h>
 #include "libs/reslib.h"
-#include "alist.h"
+#include "libs/log.h"
+#include "libs/uio/charhashtable.h"
+#include "propfile.h"
 #include "stringbank.h"
 
-static alist *map = NULL;
+/* The CharHashTable owns its keys, but not its values. We will keep the 
+   values in a StringBank. */
+
+static CharHashTable_HashTable *map = NULL;
+static stringbank *bank = NULL;
 
 static void
 check_map_init (void)
 {
 	if (map == NULL) {
-		map = Alist_New ();
+		map = CharHashTable_newHashTable (NULL, NULL, NULL, NULL, 0, 0.85, 0.9);
+	}
+	if (bank == NULL) {
+		bank = StringBank_Create ();
 	}
 }
 
@@ -37,9 +46,19 @@ void
 res_ClearTables (void)
 {
 	if (map != NULL) {
-		Alist_Free (map);
+		CharHashTable_deleteHashTable (map);
 		map = NULL;
 	}
+	if (bank != NULL) {
+		StringBank_Free (bank);
+		bank = NULL;
+	}
+}
+
+BOOLEAN
+res_Remove (const char *key)
+{
+	return CharHashTable_remove (map, key);
 }
 
 /* Type conversion routines. */
@@ -53,7 +72,7 @@ static const char *
 int2str (int i) {
 	char buf[20];
 	sprintf (buf, "%d", i);
-	return StringBank_AddOrFindString (map->bank, buf);
+	return StringBank_AddOrFindString (bank, buf);
 }
 
 static int
@@ -63,59 +82,13 @@ str2int (const char *s) {
 
 static BOOLEAN
 str2bool (const char *s) {
-	if (!stricmp (s, "yes") ||
-	    !stricmp (s, "true") ||
-	    !stricmp (s, "1") )
+	if (!strcasecmp (s, "yes") ||
+	    !strcasecmp (s, "true") ||
+	    !strcasecmp (s, "1") )
 		return TRUE;
 	return FALSE;
 }
 
-void
-res_LoadFile (uio_Stream *s)
-{
-	alist *d;
-	check_map_init ();
-	
-	d = Alist_New_FromFile (s);
-	if (d) {
-		Alist_PutAll (map, d);
-		Alist_Free (d);
-	}
-}
-
-void
-res_LoadFilename (uio_DirHandle *path, const char *fname)
-{
-	alist *d;
-	check_map_init ();
-	
-	d = Alist_New_FromFilename (path, fname);
-	if (d) {
-		Alist_PutAll (map, d);
-		Alist_Free (d);
-	}
-}
-
-void
-res_SaveFile (uio_Stream *f, const char *root)
-{
-	check_map_init ();
-	Alist_Dump (map, f, root);
-}
-
-void
-res_SaveFilename (uio_DirHandle *path, const char *fname, const char *root)
-{
-	uio_Stream *f;
-	
-	check_map_init ();
-	f = res_OpenResFile (path, fname, "wb");
-	if (f) {
-		res_SaveFile (f, root);
-		res_CloseResFile (f);
-	}
-}
-
 BOOLEAN
 res_IsBoolean (const char *key)
 {
@@ -125,13 +98,13 @@ res_IsBoolean (const char *key)
 	d = res_GetString (key);
 	if (!d) return 0;
 		
-	return !stricmp (d, "yes") ||
-	       !stricmp (d, "no") ||
-	       !stricmp (d, "true") ||
-	       !stricmp (d, "false") ||
-	       !stricmp (d, "0") ||
-	       !stricmp (d, "1") ||
-	       !stricmp (d, "");
+	return !strcasecmp (d, "yes") ||
+	       !strcasecmp (d, "no") ||
+	       !strcasecmp (d, "true") ||
+	       !strcasecmp (d, "false") ||
+	       !strcasecmp (d, "0") ||
+	       !strcasecmp (d, "1") ||
+	       !strcasecmp (d, "");
 }
 
 BOOLEAN
@@ -153,14 +126,20 @@ const char *
 res_GetString (const char *key)
 {
 	check_map_init ();
-	return Alist_GetString (map, key);
+	return CharHashTable_find (map, key);
 }
 
 void
 res_PutString (const char *key, const char *value)
 {
 	check_map_init ();
-	Alist_PutString (map, key, value);
+	
+	value = StringBank_AddOrFindString (bank, value);
+	if (!CharHashTable_add (map, key, (void *)value))
+	{
+		CharHashTable_remove (map, key);
+		CharHashTable_add (map, key, (void *)value);
+	}
 }
 
 int
@@ -197,3 +176,71 @@ res_HasKey (const char *key)
 	check_map_init ();
 	return (res_GetString (key) != NULL);
 }
+
+void
+res_LoadFile (uio_Stream *s)
+{
+	check_map_init ();
+	
+	if (!map)
+	{
+		return;
+	}
+	
+	PropFile_from_file (s, res_PutString);
+}
+
+void
+res_LoadFilename (uio_DirHandle *path, const char *fname)
+{
+	check_map_init ();
+	
+	if (!map)
+	{
+		return;
+	}
+	
+	PropFile_from_filename (path, fname, res_PutString);
+}
+
+void
+res_SaveFile (uio_Stream *f, const char *prefix)
+{
+	CharHashTable_Iterator *i;
+	int prefix_len = 0;
+	
+	if (prefix)
+		prefix_len = strlen (prefix);
+	
+	check_map_init ();
+
+	i = CharHashTable_getIterator (map);
+	while (!CharHashTable_iteratorDone (i))
+	{
+		const char *key = CharHashTable_iteratorKey (i);
+		const char *value = (const char *)CharHashTable_iteratorValue (i);
+		if (!prefix || !strncmp (prefix, key, prefix_len)) {
+			WriteResFile (key, 1, strlen (key), f);
+			PutResFileChar(' ', f);
+			PutResFileChar('=', f);
+			PutResFileChar(' ', f);
+			WriteResFile (value, 1, strlen (value), f);
+			PutResFileNewline(f);
+		}
+		i = CharHashTable_iteratorNext (i);
+	}
+	CharHashTable_freeIterator (i);
+}
+
+void
+res_SaveFilename (uio_DirHandle *path, const char *fname, const char *prefix)
+{
+	uio_Stream *f;
+	
+	check_map_init ();
+	f = res_OpenResFile (path, fname, "wb");
+	if (f) {
+		res_SaveFile (f, prefix);
+		res_CloseResFile (f);
+	}
+}
diff -ruNp src.orig/sc2code/libs/resource/propfile.c src/sc2code/libs/resource/propfile.c
--- src.orig/sc2code/libs/resource/propfile.c	1969-12-31 18:00:00 -0600
+++ src/sc2code/libs/resource/propfile.c	2017-11-08 16:49:59 -0600
@@ -0,0 +1,120 @@
+/*  propfile.c, Copyright (c) 2008 Michael C. Martin */
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope thta it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  Se the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include "libs/log.h"
+#include "propfile.h"
+#include "reslib.h"
+
+void
+PropFile_from_string (char *d, PROPERTY_HANDLER handler)
+{
+	int len, i;
+
+	len = strlen(d);
+	i = 0;
+	while (i < len) {
+		int key_start, key_end, value_start, value_end;
+		/* Starting a line: search for non-whitespace */
+		while ((i < len) && isspace (d[i])) i++;
+		if (i >= len) break;  /* Done parsing! */
+		/* If it was a comment, skip to end of comment/file */
+		if (d[i] == '#') {
+			while ((i < len) && (d[i] != '\n')) i++;
+			if (i >= len) break;
+			continue; /* Back to keyword search */
+		}
+		key_start = i;
+		/* Find the = on this line */
+		while ((i < len) && (d[i] != '=') &&
+		       (d[i] != '\n') && (d[i] != '#')) i++;
+		if (i >= len) {  /* Bare key at EOF */
+			log_add (log_Warning, "Warning: Bare keyword at EOF");
+			break;
+		}
+		/* Comments here mean incomplete line too */
+		if (d[i] != '=') {
+			log_add (log_Warning, "Warning: Key without value");
+			while ((i < len) && (d[i] != '\n')) i++;
+			if (i >= len) break;
+			continue; /* Back to keyword search */
+		}
+		/* Key ends at first whitespace before = , or at key_start*/
+		key_end = i;
+		while ((key_end > key_start) && isspace (d[key_end-1]))
+			key_end--;
+		
+		/* Consume the = */
+		i++;
+		/* Value starts at first non-whitespace after = on line... */
+		while ((i < len) && (d[i] != '#') && (d[i] != '\n') &&
+		       isspace (d[i]))
+			i++;
+		value_start = i;
+		/* Until first non-whitespace before terminator */
+		while ((i < len) && (d[i] != '#') && (d[i] != '\n'))
+			i++;
+		value_end = i;
+		while ((value_end > value_start) && isspace (d[value_end-1]))
+			value_end--;
+		/* Skip past EOL or EOF */
+		while ((i < len) && (d[i] != '\n'))
+			i++;
+		i++;
+
+		/* We now have start and end values for key and value.
+		   We terminate the strings for both by writing \0s, then
+		   make a new map entry. */
+		d[key_end] = '\0';
+		d[value_end] = '\0';
+		handler (d+key_start, d+value_start);
+	}
+}
+
+void
+PropFile_from_file (uio_Stream *f, PROPERTY_HANDLER handler)
+{
+	long flen;
+	char *data;
+
+	flen = LengthResFile (f);
+
+	data = malloc (flen + 1);
+	if (!data) {
+		return;
+	}
+
+	flen = ReadResFile (data, 1, flen, f);
+	data[flen] = '\0';
+
+	PropFile_from_string (data, handler);
+	free (data);
+}
+
+void
+PropFile_from_filename (uio_DirHandle *path, const char *fname, PROPERTY_HANDLER handler)
+{
+	uio_Stream *f = res_OpenResFile (path, fname, "rt");
+	if (!f) {
+		return;
+	}
+	PropFile_from_file (f, handler);
+	res_CloseResFile(f);
+}
diff -ruNp src.orig/sc2code/libs/resource/propfile.h src/sc2code/libs/resource/propfile.h
--- src.orig/sc2code/libs/resource/propfile.h	1969-12-31 18:00:00 -0600
+++ src/sc2code/libs/resource/propfile.h	2017-11-08 16:49:59 -0600
@@ -0,0 +1,30 @@
+/*  propfile.h, Copyright (c) 2008 Michael C. Martin */
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope thta it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  Se the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef PROPFILE_H_
+#define PROPFILE_H_
+
+#include "uio.h"
+
+typedef void (*PROPERTY_HANDLER) (const char *, const char *);
+
+void PropFile_from_string (char *d, PROPERTY_HANDLER handler);
+void PropFile_from_file (uio_Stream *f, PROPERTY_HANDLER handler);
+void PropFile_from_filename (uio_DirHandle *path, const char *fname, PROPERTY_HANDLER handler);
+
+#endif
diff -ruNp src.orig/sc2code/libs/resource/resdata.c src/sc2code/libs/resource/resdata.c
--- src.orig/sc2code/libs/resource/resdata.c	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/resource/resdata.c	2017-11-08 16:49:59 -0600
@@ -18,15 +18,15 @@
 
 #include "resintrn.h"
 
-static ResourceIndex *curResourceIndex;
+static RESOURCE_INDEX curResourceIndex;
 
 void
-_set_current_index_header (ResourceIndex *newResourceIndex)
+_set_current_index_header (RESOURCE_INDEX newResourceIndex)
 {
 	curResourceIndex = newResourceIndex;
 }
 
-ResourceIndex *
+RESOURCE_INDEX
 _get_current_index_header (void)
 {
 	return curResourceIndex;
diff -ruNp src.orig/sc2code/libs/resource/resinit.c src/sc2code/libs/resource/resinit.c
--- src.orig/sc2code/libs/resource/resinit.c	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/resource/resinit.c	2017-11-08 16:49:59 -0600
@@ -19,461 +19,222 @@
 #include "resintrn.h"
 #include "misc.h"
 #include "options.h"
+#include "nameref.h"
 #include "types.h"
-#include "libs/list.h"
 #include "libs/log.h"
+#include "libs/gfxlib.h"
+#include "libs/sndlib.h"
+#include "libs/vidlib.h"
+#include "coderes.h"
+#include "propfile.h"
 #include <ctype.h>
 #include <stdlib.h>
 
-
-static bool copyResTypeHandlers (ResourceIndex *dest,
-		const ResourceIndex *src);
-static bool setResTypeHandlers (ResourceIndex *idx, RES_TYPE resType,
-		const ResourceHandlers *handlers);
-static MEM_HANDLE allocResourceIndex(void);
-static void freeResourceIndex (MEM_HANDLE h);
-
-
-static List_List *indexList;
-
-
-static void
-initIndexList (void)
-{
-	indexList = List_newList ();
+static RESOURCE_INDEX
+allocResourceIndex (void) {
+	RESOURCE_INDEX ndx = HMalloc (sizeof (RESOURCE_INDEX_DESC));
+	ndx->map = CharHashTable_newHashTable (NULL, NULL, NULL, NULL, 0, 0.85, 0.9);
+	return ndx;
 }
 
 static void
-uninitIndexList (void)
-{
-	List_deleteList (indexList);
-	indexList = NULL;
-}
-
-void
-forAllResourceIndices(
-		void (*callback) (ResourceIndex *idx, void *extra),
-		void *extra) {
-	List_Link *link;
-
-	for (link = indexList->first; link != NULL; link = link->next)
+freeResourceIndex (RESOURCE_INDEX h) {
+	if (h != NULL)
 	{
-		ResourceIndex *idx = (ResourceIndex *) link->entry;
-		(*callback) (idx, extra);
+		/* TODO: This leaks the contents of h->map */
+		CharHashTable_deleteHashTable (h->map);
+		HFree (h);
 	}
 }
 
+#define TYPESIZ 32
 
-#if 0
 static ResourceDesc *
-lookupResourceIndex (const char *path)
+newResourceDesc (const char *res_id, const char *resval)
 {
-	List_Link *link;
+	const char *path;
+	int pathlen;
+	ResourceHandlers *vtable;
+	ResourceDesc *result, *handlerdesc;
+	RESOURCE_INDEX idx = _get_current_index_header ();
+	char typestr[TYPESIZ];
 
-	for (link = indexList->first; link != NULL; link = link->next)
+	path = strchr (resval, ':');
+	if (path == NULL)
 	{
-		ResourceDesc *desc = (ResourceDesc *) link->entry;
-		
-		if (strcmp (desc->path, path) == 0)
-			return link->entry;
+		log_add (log_Warning, "Could not find type information for resource '%s'", res_id);
+		strncpy(typestr, "sys.UNKNOWNRES", TYPESIZ);
+		path = resval;
 	}
+	else
+	{
+		int n = path - resval;
 
-	return NULL;
-}
-#endif
+		if (n >= TYPESIZ - 4)
+		{
+			n = TYPESIZ - 5;
+		}
+		strncpy (typestr, "sys.", TYPESIZ);
+		strncat (typestr+1, resval, n);
+		typestr[n+4] = '\0';
+		path++;
+	}
+	pathlen = strlen (path);
 
-static ResourceDesc *
-newResourceDesc (RESOURCE res, char *path)
-{
-	ResourceDesc *result;
+	handlerdesc = lookupResourceDesc(idx, typestr);
+	if (handlerdesc == NULL) {
+		path = resval;
+		log_add (log_Warning, "Illegal type '%s' for resource '%s'; treating as UNKNOWNRES", typestr, res_id);
+		handlerdesc = lookupResourceDesc(idx, "sys.UNKNOWNRES");
+	}
+
+	vtable = (ResourceHandlers *)handlerdesc->resdata.ptr;
+
+	if (vtable->loadFun == NULL)
+	{
+		log_add (log_Warning, "Warning: Unable to load '%s'; no handler "
+				"for type %s defined.", res_id, typestr);
+		return NULL;
+	}
 
 	result = HMalloc (sizeof (ResourceDesc));
 	if (result == NULL)
 		return NULL;
 
-	result->res = res;
-	result->path = path;
-	result->handle = NULL_HANDLE;
-	//result->ref = 0;
+	result->fname = HMalloc (pathlen + 1);
+	strncpy (result->fname, path, pathlen);
+	result->fname[pathlen] = '\0';
+	result->vtable = vtable;
+	
+	if (vtable->freeFun == NULL)
+	{
+		/* Non-heap resources are raw values. Work those out at load time. */
+		vtable->loadFun (result->fname, &result->resdata);
+	}
+	else
+	{
+		result->resdata.ptr = NULL;
+	}
 	return result;
 }
 
-static MEM_HANDLE
-loadResourceIndex (uio_Stream *stream, const char *fileName) {
-	size_t lineNum;
-	ResourceDesc **descs = NULL;
-	COUNT numRes;
-	int numDescsAlloced = 0;
-	MEM_HANDLE indexHandle = NULL_HANDLE;
-	ResourceIndex *ndx = NULL;
-#ifdef DEBUG
-	RESOURCE lastResource = 0x00000000;
-#endif
-	
-	// This loop parses lines of the format "<resnum> <path>".
-	// Resnum is in hex. '#' can be used to add comments.
-	lineNum = 0;
-	numRes = 0;
-	for (;;)
+static void
+process_resource_desc (const char *key, const char *value)
+{
+	CharHashTable_HashTable *map = _get_current_index_header ()->map;
+	ResourceDesc *newDesc = newResourceDesc (key, value);
+	if (newDesc != NULL)
 	{
-		char lineBuf[PATH_MAX + 80];
-		char *ptr;
-		char *endPtr;
-		char *path;
-		char *newPath;
-		RESOURCE res;
-		ResourceDesc *desc;
-		
-		if (uio_fgets (lineBuf, sizeof lineBuf, stream) == NULL)
+		if (!CharHashTable_add (map, key, newDesc))
 		{
-			if (uio_ferror (stream))
-				goto err;
-			else
-				break;  // EOF
-		}
-
-		lineNum++;
-
-		// Skip comments.
-		ptr = strchr (lineBuf, '#');
-		if (ptr != NULL)
-			*ptr = '\0';
-
-		// Omit leading whitespace.
-		ptr = lineBuf;
-		while (isspace (*ptr))
-			ptr++;
-		
-		// Omit trailing whitespace.
-		endPtr = ptr + strlen(ptr);
-		while (endPtr != ptr && isspace (endPtr[-1]))
-		{
-			endPtr--;
-			*endPtr = '\0';
-		}
-
-		// If the line is empty (apart from comments and whitespace)
-		// go to the next one.
-		if (*ptr == 0)
-			continue;
-
-		{
-			unsigned int resPackage;
-			unsigned int resInstance;
-			unsigned int resType;
-			unsigned int numParsed;
-
-			if (sscanf (ptr, "%i %i %i %n",
-					&resPackage, &resInstance, &resType, &numParsed) != 3)
+			ResourceDesc *oldDesc = (ResourceDesc *)CharHashTable_find (map, key);
+			if (oldDesc != NULL)
 			{
-				log_add (log_Warning, "Resource index '%s': Invalid line %d.",
-						fileName, lineNum);
-				continue;
+				if (newDesc->resdata.ptr != NULL)
+				{
+					/* XXX: It might be nice to actually clean it up properly */
+					log_add (log_Warning, "LEAK WARNING: Replaced '%s' while it was live", key);
+				}
+				HFree (oldDesc->fname);
+				HFree (oldDesc);
 			}
-			path = ptr + numParsed;
-		
-			res = MAKE_RESOURCE (resPackage, resType, resInstance);
+			CharHashTable_remove (map, key);
+			CharHashTable_add (map, key, newDesc);
 		}
-
-		while (isspace (*path))
-			path++;
-		if (*path == '\0')
-		{
-			// No path supplied.
-			log_add (log_Warning, "Resource index '%s': Invalid line %d.",
-					fileName, lineNum);
-			continue;
-		}
-
-#ifdef DEBUG
-		// We need the list to be sorted, as we binary search through it.
-		if (res <= lastResource)
-		{
-			log_add (log_Fatal, "Fatal: resource index '%s' is not sorted "
-					"on the resource number, or contains a double entry. "
-					"Problem encountered on line %d.", fileName, lineNum);
-			explode ();
-		}
-		lastResource = res;
-#endif
-
-#define DESC_NUM_INCREMENT 80
-		if (numDescsAlloced <= numRes)
-		{
-			// Need to enlarge the array of resource descs.
-			ResourceDesc **newDescs = HRealloc (descs,
-					sizeof (ResourceDesc *) *
-					(numDescsAlloced + DESC_NUM_INCREMENT));
-			if (newDescs == NULL)
-				goto err;  // Original descs is untouched.
-			descs = newDescs;
-			numDescsAlloced += DESC_NUM_INCREMENT;
-		}
-
-		// Can't use strdup; it doesn't use HMalloc.
-		newPath = HMalloc (endPtr - path + 1);
-		if (newPath == NULL)
-			goto err;
-		strcpy (newPath, path);
-
-		desc = newResourceDesc (res, newPath);
-		if (desc == NULL)
-			goto err;
-
-		descs[numRes] = desc;	
-		numRes++;
 	}
-
-	{
-		ResourceDesc **newDescs = HRealloc (descs,
-				sizeof (ResourceDesc *) * numRes);
-		if (newDescs == NULL && numRes != 0)
-			goto err;  // Original descs is untouched.
-		descs = newDescs;
-	}
-
-	if (numRes == 0)
-		log_add (log_Debug, "Warning: Resource index '%s' contains no valid "
-				"entries.", fileName);
-
-	indexHandle = allocResourceIndex ();
-	if (indexHandle == NULL_HANDLE)
-		goto err;
-	
-	ndx = lockResourceIndex (indexHandle);
-	ndx->res = descs;
-	ndx->numRes = numRes;
-	ndx->typeInfo.numTypes = 0;
-	ndx->typeInfo.handlers = NULL;
-	List_add (indexList, (void *) ndx);
-	unlockResourceIndex (indexHandle);
-
-	return indexHandle;
-
-err:
-	if (indexHandle != NULL_HANDLE)
-		freeResourceIndex (indexHandle);
-	HFree (descs);
-	return NULL_HANDLE;
-}
-
-// Get the data associated with a resource of type RES_INDEX
-// (In other words, a ResourceIndex)
-MEM_HANDLE
-_GetResFileData (uio_Stream *res_fp, DWORD fileLength)
-{
-	MEM_HANDLE handle;
-	ResourceIndex *ndx;
-	ResourceIndex *parentNdx;
-
-#if 0
-	ResourceDesc *desc;
-
-	desc = lookupResourceIndex (_cur_resfile_name);
-	assert(desc != NULL);
-
-	if (desc->handle != NULL_HANDLE)
-		return desc->handle;
-#endif
-
-	handle = loadResourceIndex (res_fp, _cur_resfile_name);
-	if (handle == NULL_HANDLE)
-		return NULL_HANDLE;
-
-	ndx = lockResourceIndex (handle);
-	parentNdx = _get_current_index_header ();
-	if (parentNdx != NULL)
-		copyResTypeHandlers (ndx, parentNdx);
-	
-	unlockResourceIndex (handle);
-
-	(void) fileLength;
-	return handle;
 }
 
-BOOLEAN
-_ReleaseResFileData (MEM_HANDLE handle)
+void
+UseDescriptorAsRes (const char *descriptor, RESOURCE_DATA *resdata)
 {
-	ResourceIndex *ndx;
-
-	ndx = lockResourceIndex (handle);
-	if (ndx->typeInfo.handlers != NULL)
-		HFree (ndx->typeInfo.handlers);
-	unlockResourceIndex (handle);
-	mem_release (handle);
-	return TRUE;
+	resdata->ptr = (void *)descriptor;
 }
 
-MEM_HANDLE
-InitResourceSystem (const char *resfile, RES_TYPE resType, BOOLEAN
-		(*FileErrorFun) (const char *filename))
+void
+DescriptorToInt (const char *descriptor, RESOURCE_DATA *resdata)
 {
-	MEM_HANDLE handle;
-	ResourceIndex *ndx;
-	ResourceHandlers handlers;
-
-	initIndexList ();
-	
-	handlers.loadFun = _GetResFileData;
-	handlers.freeFun = _ReleaseResFileData;
-
-	SetResourceIndex (NULL_HANDLE);
-	handle = loadResource (resfile, handlers.loadFun);
-	if (handle == NULL_HANDLE)
-		return NULL_HANDLE;
-
-	ndx = lockResourceIndex (handle);
-	setResTypeHandlers (ndx, resType, &handlers);
-	unlockResourceIndex (handle);
-
-	SetResourceIndex (handle);
-
-	(void) FileErrorFun;
-	return handle;
+	resdata->num = atoi (descriptor);
 }
 
 void
-UninitResourceSystem (void)
+DescriptorToBoolean (const char *descriptor, RESOURCE_DATA *resdata)
 {
-#if 0
-	List_Link *link;
-
-	for (link = indexList->first; link != NULL; link = link->next)
+	if (!strcasecmp (descriptor, "true"))
 	{
-		ResourceIndex *ndx = (ResourceIndex *) link->entry;
-		
+		resdata->num = TRUE;
+	}
+	else
+	{
+		resdata->num = FALSE;
 	}
-#endif
-	uninitIndexList ();
-	
-	SetResourceIndex (NULL_HANDLE);
 }
 
-MEM_HANDLE
-OpenResourceIndexInstance (RESOURCE res)
+RESOURCE_INDEX
+InitResourceSystem (void)
 {
-	MEM_HANDLE hRH;
+	RESOURCE_INDEX ndx = allocResourceIndex ();
+	
+	_set_current_index_header (ndx);
 
-	hRH = res_GetResource (res);
-	if (hRH)
-		res_DetachResource (res);
+	InstallResTypeVectors ("UNKNOWNRES", UseDescriptorAsRes, NULL);
+	InstallResTypeVectors ("STRING", UseDescriptorAsRes, NULL);
+	InstallResTypeVectors ("INT32", DescriptorToInt, NULL);
+	InstallResTypeVectors ("BOOLEAN", DescriptorToBoolean, NULL);
+	InstallGraphicResTypes ();
+	InstallStringTableResType ();
+	InstallAudioResTypes ();
+	InstallVideoResType ();
+	InstallCodeResType ();
 
-	return (hRH);
+	return ndx;
 }
 
-// Sets the current global resource index.
-// This is the index res_GetResource() calls will use.
-MEM_HANDLE
-SetResourceIndex (MEM_HANDLE newIndexHandle)
+void
+LoadResourceIndex (uio_DirHandle *dir, const char *rmpfile)
 {
-	static MEM_HANDLE currentIndexHandle;
-			// NB: currentIndexHandle is locked.
-	MEM_HANDLE oldIndexHandle;
-	
-	if (currentIndexHandle != NULL_HANDLE)
-		unlockResourceIndex (currentIndexHandle);
-
-	oldIndexHandle = currentIndexHandle;
-	currentIndexHandle = newIndexHandle;
-
-	if (currentIndexHandle != NULL_HANDLE) {
-		ResourceIndex *ndx;
-
-		ndx = lockResourceIndex (currentIndexHandle);
-		_set_current_index_header (ndx);
-	} else
-		_set_current_index_header (NULL);
-	
-	return oldIndexHandle;
+	PropFile_from_filename (dir, rmpfile, process_resource_desc);
 }
 
-BOOLEAN
-CloseResourceIndex (MEM_HANDLE handle)
+void
+UninitResourceSystem (void)
 {
-	ResourceIndex *ndx;
-	
-	unlockResourceIndex (handle);
-
-	ndx = lockResourceIndex (handle);
-	if (ndx == _get_current_index_header ())
-		SetResourceIndex (NULL_HANDLE);
-
-	List_remove ((void *) indexList, ndx);
-	
-	unlockResourceIndex (handle);
-
-	_ReleaseResFileData (handle);
-
-	return TRUE;
+	freeResourceIndex (_get_current_index_header ());
+	_set_current_index_header (NULL);
 }
 
 BOOLEAN
-InstallResTypeVectors (RES_TYPE resType, ResourceLoadFun *loadFun,
+InstallResTypeVectors (const char *resType, ResourceLoadFun *loadFun,
 		ResourceFreeFun *freeFun)
 {
-	ResourceHandlers handlers;
-	handlers.loadFun = loadFun;
-	handlers.freeFun = freeFun;
-
-	setResTypeHandlers(_get_current_index_header (), resType, &handlers);
-	return TRUE;
-}
-
-static bool
-setResTypeHandlers (ResourceIndex *idx, RES_TYPE resType,
-		const ResourceHandlers *handlers)
-{
-	if (resType >= idx->typeInfo.numTypes) {
-		// Have to enlarge the handler array.
-		ResourceHandlers *newHandlers = HRealloc (idx->typeInfo.handlers,
-				(resType + 1) * sizeof (ResourceHandlers));
-		if (newHandlers == NULL)
-			return false;  // idx->typeInfo.handlers is untouched
-
-		// Clear the space for new entries. No need to init the last one;
-		// it's going to be used immediately.
-		memset (&newHandlers[idx->typeInfo.numTypes], 0,
-				(resType - idx->typeInfo.numTypes /* + 1 - 1 */)
-				* sizeof (ResourceHandlers));
-
-		idx->typeInfo.handlers = newHandlers;
-		idx->typeInfo.numTypes = resType + 1;
-	}
-
-	idx->typeInfo.handlers[resType] = *handlers;
-	return true;
-}
-
-static bool
-copyResTypeHandlers (ResourceIndex *dest, const ResourceIndex *src)
-{
-	assert (src != dest);
-
-	if (dest->typeInfo.handlers != NULL)
-		HFree (dest->typeInfo.handlers);
-
-	dest->typeInfo.handlers = HMalloc (src->typeInfo.numTypes *
-			sizeof (ResourceHandlers));
-	if (dest->typeInfo.handlers == NULL)
-		return false;
+	ResourceHandlers *handlers;
+	ResourceDesc *result;
+	char key[TYPESIZ];
+	int typelen;
+	CharHashTable_HashTable *map;
+	
+	snprintf(key, TYPESIZ, "sys.%s", resType);
+	key[TYPESIZ-1] = '\0';
+	typelen = strlen(resType);
 	
-	memcpy (dest->typeInfo.handlers, src->typeInfo.handlers,
-			src->typeInfo.numTypes * sizeof (ResourceHandlers));
-	dest->typeInfo.numTypes = src->typeInfo.numTypes;
+	handlers = HMalloc (sizeof (ResourceHandlers));
+	if (handlers == NULL)
+	{
+		return FALSE;
+	}
+	handlers->loadFun = loadFun;
+	handlers->freeFun = freeFun;
+	handlers->resType = resType;
 	
-	return true;
-}
-
+	result = HMalloc (sizeof (ResourceDesc));
+	if (result == NULL)
+		return FALSE;
 
-static MEM_HANDLE
-allocResourceIndex (void) {
-	return mem_allocate (sizeof (ResourceIndex), MEM_PRIMARY,
-			INDEX_HEADER_PRIORITY, MEM_SIMPLE);
-}
+	result->fname = HMalloc (strlen(resType) + 1);
+	strncpy (result->fname, resType, typelen);
+	result->fname[typelen] = '\0';
+	result->vtable = NULL;
+	result->resdata.ptr = handlers;
 
-static void
-freeResourceIndex (MEM_HANDLE h) {
-	mem_release (h);
+	map = _get_current_index_header ()->map;
+	return CharHashTable_add (map, key, result) != 0;
 }
-
-
diff -ruNp src.orig/sc2code/libs/resource/resintrn.h src/sc2code/libs/resource/resintrn.h
--- src.orig/sc2code/libs/resource/resintrn.h	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/resource/resintrn.h	2017-11-08 16:49:59 -0600
@@ -20,14 +20,14 @@
 #define _RESINTRN_H
 
 #include <string.h>
-#include "libs/reslib.h"
+#include "reslib.h"
 #include "index.h"
 
-MEM_HANDLE loadResourceDesc (ResourceIndex *idx, ResourceDesc *desc);
-MEM_HANDLE loadResource(const char *path, ResourceLoadFun *loadFun);
+ResourceDesc *lookupResourceDesc (RESOURCE_INDEX idx, RESOURCE res);
+void loadResourceDesc (ResourceDesc *desc);
 
-void _set_current_index_header (ResourceIndex *newResourceIndex);
-ResourceIndex *_get_current_index_header (void);
+void _set_current_index_header (RESOURCE_INDEX newResourceIndex);
+RESOURCE_INDEX _get_current_index_header (void);
 
 
 #endif /* _RESINTRN_H */
diff -ruNp src.orig/sc2code/libs/resource/stringbank.c src/sc2code/libs/resource/stringbank.c
--- src.orig/sc2code/libs/resource/stringbank.c	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/resource/stringbank.c	2017-11-08 16:49:59 -0600
@@ -75,7 +75,7 @@ StringBank_AddString (stringbank *bank,
 	/* No room in any currently existing chunk */
 	x = add_chunk (bank);
 	strcpy (x->data, str);
-	x->len += len + 1;
+	x->len += len;
 	return x->data;
 }
 
diff -ruNp src.orig/sc2code/libs/sndlib.h src/sc2code/libs/sndlib.h
--- src.orig/sc2code/libs/sndlib.h	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/sndlib.h	2017-11-08 16:49:59 -0600
@@ -20,7 +20,6 @@
 #define _SNDLIB_H
 
 #include "strlib.h"
-#include "memlib.h"
 
 typedef STRING_TABLE SOUND_REF;
 typedef STRING SOUND;
@@ -43,16 +42,16 @@ typedef struct soundposition
 #define GetSoundAddress GetStringAddress
 #define GetSoundContents GetStringContents
 
-typedef MEM_HANDLE MUSIC_REF;
+typedef struct tfb_soundsample TFB_SoundSample;
+typedef TFB_SoundSample **MUSIC_REF;
 
 extern BOOLEAN InitSound (int argc, char *argv[]);
 extern void UninitSound (void);
-extern SOUND_REF LoadSoundFile (PVOID pStr);
-extern MUSIC_REF LoadMusicFile (PVOID pStr);
-extern BOOLEAN InstallAudioResTypes (COUNT sound_type, COUNT
-		music_type);
-extern SOUND_REF LoadSoundInstance (DWORD res);
-extern MUSIC_REF LoadMusicInstance (DWORD res);
+extern SOUND_REF LoadSoundFile (const char *pStr);
+extern MUSIC_REF LoadMusicFile (const char *pStr);
+extern BOOLEAN InstallAudioResTypes (void);
+extern SOUND_REF LoadSoundInstance (RESOURCE res);
+extern MUSIC_REF LoadMusicInstance (RESOURCE res);
 extern BOOLEAN DestroySound (SOUND_REF SoundRef);
 extern BOOLEAN DestroyMusic (MUSIC_REF MusicRef);
 
@@ -72,7 +71,9 @@ extern void PLRStop (MUSIC_REF MusicRef)
 extern BOOLEAN PLRPlaying (MUSIC_REF MusicRef);
 extern void PLRPause (MUSIC_REF MusicRef);
 extern void PLRResume (MUSIC_REF MusicRef);
-extern void PlayChannel (COUNT channel, PVOID sample, SoundPosition pos,
+extern void snd_PlaySpeech (MUSIC_REF SpeechRef);
+extern void snd_StopSpeech (void);
+extern void PlayChannel (COUNT channel, void *sample, SoundPosition pos,
 		void *positional_object, unsigned char priority);
 extern BOOLEAN ChannelPlaying (COUNT Channel);
 extern void * GetPositionalObject (COUNT channel);
@@ -90,13 +91,13 @@ extern BOOLEAN SoundPlaying (void);
 extern void WaitForSoundEnd (COUNT Channel);
 #define TFBSOUND_WAIT_ALL ((COUNT)~0)
 
-extern BOOLEAN AllocHardwareSample (PBYTE lpSnd, DWORD SampleRate, COUNT
+extern BOOLEAN AllocHardwareSample (BYTE *lpSnd, DWORD SampleRate, COUNT
 		SampleLength, COUNT LoopBegin, COUNT LoopLen);
-extern BOOLEAN FreeHardwareSample (PBYTE lpSnd, COUNT SampleLength);
+extern BOOLEAN FreeHardwareSample (BYTE *lpSnd, COUNT SampleLength);
 
 extern COUNT GetSampleRate (SOUND Sound);
 extern COUNT GetSampleLength (SOUND Sound);
-extern PBYTE GetSampleAddress (SOUND Sound);
+extern BYTE* GetSampleAddress (SOUND Sound);
 extern DWORD FadeMusic (BYTE end_vol, SIZE TimeInterval);
 
 #endif /* _SNDLIB_H */
diff -ruNp src.orig/sc2code/libs/sound/decoders/Makeinfo src/sc2code/libs/sound/decoders/Makeinfo
--- src.orig/sc2code/libs/sound/decoders/Makeinfo	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/sound/decoders/Makeinfo	2017-11-08 16:49:59 -0600
@@ -1 +1,6 @@
-uqm_CFILES="decoder.c wav.c dukaud.c modaud.c oggaud.c"
+uqm_CFILES="decoder.c aiffaud.c wav.c dukaud.c modaud.c"
+
+if [ "$uqm_OGGVORBIS" '!=' "none" ]; then
+	uqm_CFILES="$uqm_CFILES oggaud.c"
+fi
+
diff -ruNp src.orig/sc2code/libs/sound/decoders/aiffaud.c src/sc2code/libs/sound/decoders/aiffaud.c
--- src.orig/sc2code/libs/sound/decoders/aiffaud.c	1969-12-31 18:00:00 -0600
+++ src/sc2code/libs/sound/decoders/aiffaud.c	2017-11-08 16:49:59 -0600
@@ -0,0 +1,649 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/* Portions (C) Serge van den Boom (svdb at stack.nl) */
+/* Portions (C) Alex Volkov (codepro at usa.net) */
+
+/* AIFF decoder (.aif)
+ *
+ * Doesn't work on *all* aiff files in general, only 8/16 PCM and
+ * 16-bit AIFF-C SDX2-compressed.
+ */
+
+#include <stdio.h>
+#include <errno.h>
+#ifndef _WIN32_WCE
+#	include <memory.h>
+#endif
+#include <string.h>
+#include "port.h"
+#include "types.h"
+#include "uio.h"
+#include "endian_uqm.h"
+#include "libs/misc.h"
+#include "libs/log.h"
+#include "aiffaud.h"
+
+typedef uint32 aiff_ID;
+
+#define aiff_MAKE_ID(x1, x2, x3, x4) \
+		(((x1) << 24) | ((x2) << 16) | ((x3) << 8) | (x4))
+
+#define aiff_FormID         aiff_MAKE_ID('F', 'O', 'R', 'M')
+#define aiff_FormVersionID  aiff_MAKE_ID('F', 'V', 'E', 'R')
+#define aiff_CommonID       aiff_MAKE_ID('C', 'O', 'M', 'M')
+#define aiff_SoundDataID    aiff_MAKE_ID('S', 'S', 'N', 'D')
+
+#define aiff_FormTypeAIFF   aiff_MAKE_ID('A', 'I', 'F', 'F')
+#define aiff_FormTypeAIFC   aiff_MAKE_ID('A', 'I', 'F', 'C')
+
+#define aiff_CompressionTypeSDX2  aiff_MAKE_ID('S', 'D', 'X', '2')
+
+
+typedef struct
+{
+	aiff_ID id;
+	uint32 size;
+} aiff_ChunkHeader;
+
+#define AIFF_CHUNK_HDR_SIZE (4+4)
+
+typedef struct
+{
+	aiff_ChunkHeader chunk;
+	aiff_ID type;
+} aiff_FileHeader;
+
+typedef struct
+{
+	uint32 version;  /* format version, in Mac format */
+} aiff_FormatVersionChunk;
+
+typedef struct
+{
+	uint16 channels;       /* number of channels */
+	uint32 sampleFrames;   /* number of sample frames */
+	uint16 sampleSize;     /* number of bits per sample */
+	uint32 sampleRate;     /* number of frames per second */
+			/* this is actually stored as IEEE-754 80bit in files */
+} aiff_CommonChunk;
+
+#define AIFF_COMM_SIZE (2+4+2+10)
+
+typedef struct
+{
+	uint16 channels;      /* number of channels */
+	uint32 sampleFrames;  /* number of sample frames */
+	uint16 sampleSize;    /* number of bits per sample */
+	uint32 sampleRate;    /* number of frames per second */
+	aiff_ID extTypeID;    /* compression type ID */
+	char extName[32];     /* compression type name */
+} aiff_ExtCommonChunk;
+
+#define AIFF_EXT_COMM_SIZE (AIFF_COMM_SIZE+4)
+
+typedef struct
+{
+	uint32 offset;     /* offset to sound data */
+	uint32 blockSize;  /* size of alignment blocks */
+} aiff_SoundDataChunk;
+
+#define AIFF_SSND_SIZE (4+4)
+ 
+ 
+#define THIS_PTR TFB_SoundDecoder* This
+
+static const char* aifa_GetName (void);
+static bool aifa_InitModule (int flags, const TFB_DecoderFormats*);
+static void aifa_TermModule (void);
+static uint32 aifa_GetStructSize (void);
+static int aifa_GetError (THIS_PTR);
+static bool aifa_Init (THIS_PTR);
+static void aifa_Term (THIS_PTR);
+static bool aifa_Open (THIS_PTR, uio_DirHandle *dir, const char *filename);
+static void aifa_Close (THIS_PTR);
+static int aifa_Decode (THIS_PTR, void* buf, sint32 bufsize);
+static uint32 aifa_Seek (THIS_PTR, uint32 pcm_pos);
+static uint32 aifa_GetFrame (THIS_PTR);
+
+TFB_SoundDecoderFuncs aifa_DecoderVtbl = 
+{
+	aifa_GetName,
+	aifa_InitModule,
+	aifa_TermModule,
+	aifa_GetStructSize,
+	aifa_GetError,
+	aifa_Init,
+	aifa_Term,
+	aifa_Open,
+	aifa_Close,
+	aifa_Decode,
+	aifa_Seek,
+	aifa_GetFrame,
+};
+
+
+typedef enum
+{
+	aifc_None,
+	aifc_Sdx2,
+} aiff_CompressionType;
+
+#define MAX_CHANNELS 4
+
+typedef struct tfb_wavesounddecoder
+{
+	// always the first member
+	TFB_SoundDecoder decoder;
+
+	// private
+	sint32 last_error;
+	uio_Stream *fp;
+	aiff_ExtCommonChunk fmtHdr;
+	aiff_CompressionType comp_type;
+	unsigned bits_per_sample;
+	unsigned block_align;
+	unsigned file_block;
+	uint32 data_ofs;
+	uint32 data_size;
+	uint32 max_pcm;
+	uint32 cur_pcm;
+	sint32 prev_val[MAX_CHANNELS];
+
+} TFB_AiffSoundDecoder;
+
+static const TFB_DecoderFormats* aifa_formats = NULL;
+
+static int aifa_DecodePCM (TFB_AiffSoundDecoder*, void* buf, sint32 bufsize);
+static int aifa_DecodeSDX2 (TFB_AiffSoundDecoder*, void* buf, sint32 bufsize);
+
+
+static const char*
+aifa_GetName (void)
+{
+	return "AIFF";
+}
+
+static bool
+aifa_InitModule (int flags, const TFB_DecoderFormats* fmts)
+{
+	aifa_formats = fmts;
+	return true;
+	
+	(void)flags;	// laugh at compiler warning
+}
+
+static void
+aifa_TermModule (void)
+{
+	// no specific module term
+}
+
+static uint32
+aifa_GetStructSize (void)
+{
+	return sizeof (TFB_AiffSoundDecoder);
+}
+
+static int
+aifa_GetError (THIS_PTR)
+{
+	TFB_AiffSoundDecoder* aifa = (TFB_AiffSoundDecoder*) This;
+	int ret = aifa->last_error;
+	aifa->last_error = 0;
+	return ret;
+}
+
+static bool
+aifa_Init (THIS_PTR)
+{
+	//TFB_AiffSoundDecoder* aifa = (TFB_AiffSoundDecoder*) This;
+	This->need_swap = !aifa_formats->want_big_endian;
+	return true;
+}
+
+static void
+aifa_Term (THIS_PTR)
+{
+	//TFB_AiffSoundDecoder* aifa = (TFB_AiffSoundDecoder*) This;
+	aifa_Close (This); // ensure cleanup
+}
+
+static bool
+read_be_16 (uio_Stream *fp, uint16 *v)
+{
+	if (!uio_fread (v, sizeof(*v), 1, fp))
+		return false;
+	*v = UQM_SwapBE16 (*v);
+	return true;
+}
+
+static bool
+read_be_32 (uio_Stream *fp, uint32 *v)
+{
+	if (!uio_fread (v, sizeof(*v), 1, fp))
+		return false;
+	*v = UQM_SwapBE32 (*v);
+	return true;
+}
+
+// Read 80-bit IEEE 754 floating point number.
+// We are only interested in values that we can work with,
+//   so using an sint32 here is fine.
+static bool
+read_be_f80 (uio_Stream *fp, sint32 *v)
+{
+	int sign, exp;
+	int shift;
+	uint16 se;
+	uint32 mant, mant_low;
+	if (!read_be_16 (fp, &se) ||
+		!read_be_32 (fp, &mant) || !read_be_32 (fp, &mant_low))
+		return false;
+
+	sign = (se >> 15) & 1;        // sign is the highest bit
+	exp = (se & ((1 << 15) - 1)); // exponent is next highest 15 bits
+#if 0 // XXX: 80bit IEEE 754 used in AIFF uses explicit mantissa MS bit
+	// mantissa has an implied leading bit which is typically 1
+	mant >>= 1;
+	if (exp != 0)
+		mant |= 0x80000000;
+#endif
+	mant >>= 1;            // we also need space for sign
+	exp -= (1 << 14) - 1;  // exponent is biased by (2^(e-1) - 1)
+	shift = exp - 31 + 1;  // mantissa is already 31 bits before decimal pt.
+	if (shift > 0)
+		mant = 0x7fffffff; // already too big
+	else if (shift < 0)
+		mant >>= -shift;
+
+	*v = sign ? -(sint32)mant : (sint32)mant;
+
+	return true;
+}
+
+static bool
+aifa_readFileHeader (TFB_AiffSoundDecoder* aifa, aiff_FileHeader* hdr)
+{
+	if (!read_be_32 (aifa->fp, &hdr->chunk.id) ||
+			!read_be_32 (aifa->fp, &hdr->chunk.size) ||
+			!read_be_32 (aifa->fp, &hdr->type))
+	{
+		aifa->last_error = errno;
+		return false;
+	}
+	return true;
+}
+
+static bool
+aifa_readChunkHeader (TFB_AiffSoundDecoder* aifa, aiff_ChunkHeader* hdr)
+{
+	if (!read_be_32 (aifa->fp, &hdr->id) ||
+			!read_be_32 (aifa->fp, &hdr->size))
+	{
+		aifa->last_error = errno;
+		return false;
+	}
+	return true;
+}
+
+static int
+aifa_readCommonChunk (TFB_AiffSoundDecoder* aifa, uint32 size,
+		aiff_ExtCommonChunk* fmt)
+{
+	int bytes;
+
+	memset(fmt, sizeof(*fmt), 0);
+	if (size < AIFF_COMM_SIZE)
+	{
+		aifa->last_error = aifae_BadFile;
+		return 0;
+	}
+
+	if (!read_be_16 (aifa->fp, &fmt->channels) ||
+			!read_be_32 (aifa->fp, &fmt->sampleFrames) ||
+			!read_be_16 (aifa->fp, &fmt->sampleSize) ||
+			!read_be_f80 (aifa->fp, &fmt->sampleRate))
+	{
+		aifa->last_error = errno;
+		return 0;
+	}
+	bytes = AIFF_COMM_SIZE;
+
+	if (size >= AIFF_EXT_COMM_SIZE)
+	{
+		if (!read_be_32 (aifa->fp, &fmt->extTypeID))
+		{
+			aifa->last_error = errno;
+			return 0;
+		}
+		bytes += sizeof(fmt->extTypeID);
+	}
+	
+	return bytes;
+}
+
+static bool
+aifa_readSoundDataChunk (TFB_AiffSoundDecoder* aifa,
+		aiff_SoundDataChunk* data)
+{
+	if (!read_be_32 (aifa->fp, &data->offset) ||
+			!read_be_32 (aifa->fp, &data->blockSize))
+	{
+		aifa->last_error = errno;
+		return false;
+	}
+	return true;
+}
+
+static bool
+aifa_Open (THIS_PTR, uio_DirHandle *dir, const char *filename)
+{
+	TFB_AiffSoundDecoder* aifa = (TFB_AiffSoundDecoder*) This;
+	aiff_FileHeader fileHdr;
+	aiff_ChunkHeader chunkHdr;
+	sint32 remSize;
+
+	aifa->fp = uio_fopen (dir, filename, "rb");
+	if (!aifa->fp)
+	{
+		aifa->last_error = errno;
+		return false;
+	}
+
+	aifa->data_size = 0;
+	aifa->max_pcm = 0;
+	aifa->data_ofs = 0;
+	memset(&aifa->fmtHdr, 0, sizeof(aifa->fmtHdr));
+	memset(aifa->prev_val, sizeof(aifa->prev_val), 0);
+
+	// read wave header
+	if (!aifa_readFileHeader (aifa, &fileHdr))
+	{
+		aifa->last_error = errno;
+		aifa_Close (This);
+		return false;
+	}
+	if (fileHdr.chunk.id != aiff_FormID)
+	{
+		log_add (log_Warning, "aifa_Open(): not an aiff file, ID 0x%08x",
+				fileHdr.chunk.id);
+		aifa_Close (This);
+		return false;
+	}
+	if (fileHdr.type != aiff_FormTypeAIFF && fileHdr.type != aiff_FormTypeAIFC)
+	{
+		log_add (log_Warning, "aifa_Open(): unsupported aiff file"
+				", Type 0x%08x", fileHdr.type);
+		aifa_Close (This);
+		return false;
+	}
+
+	for (remSize = fileHdr.chunk.size - sizeof(aiff_ID); remSize > 0;
+			remSize -= ((chunkHdr.size + 1) & ~1) + AIFF_CHUNK_HDR_SIZE)
+	{
+		if (!aifa_readChunkHeader (aifa, &chunkHdr))
+		{
+			aifa_Close (This);
+			return false;
+		}
+
+		if (chunkHdr.id == aiff_CommonID)
+		{
+			int read = aifa_readCommonChunk (aifa, chunkHdr.size, &aifa->fmtHdr);
+			if (!read)
+			{
+				aifa_Close (This);
+				return false;
+			}
+			uio_fseek (aifa->fp, chunkHdr.size - read, SEEK_CUR);
+		}
+		else if (chunkHdr.id == aiff_SoundDataID)
+		{
+			aiff_SoundDataChunk data;
+			if (!aifa_readSoundDataChunk (aifa, &data))
+			{
+				aifa_Close (This);
+				return false;
+			}
+			aifa->data_ofs = uio_ftell (aifa->fp) + data.offset;
+			uio_fseek (aifa->fp, chunkHdr.size - AIFF_SSND_SIZE, SEEK_CUR);
+		}
+		else
+		{	// skip uninteresting chunk
+			uio_fseek (aifa->fp, chunkHdr.size, SEEK_CUR);
+		}
+
+		// 2-align the file ptr
+		uio_fseek (aifa->fp, chunkHdr.size & 1, SEEK_CUR);
+	}
+
+	if (aifa->fmtHdr.sampleFrames == 0)
+	{
+		log_add (log_Warning, "aifa_Open(): aiff file has no sound data");
+		aifa_Close (This);
+		return false;
+	}
+	
+	// make bits-per-sample a multiple of 8
+	aifa->bits_per_sample = (aifa->fmtHdr.sampleSize + 7) & ~7;
+	if (aifa->bits_per_sample == 0 || aifa->bits_per_sample > 16)
+	{	// XXX: for now we do not support 24 and 32 bps
+		log_add (log_Warning, "aifa_Open(): unsupported sample size %u",
+				aifa->bits_per_sample);
+		aifa_Close (This);
+		return false;
+	}
+	if (aifa->fmtHdr.channels != 1 && aifa->fmtHdr.channels != 2)
+	{
+		log_add (log_Warning, "aifa_Open(): unsupported number of channels %u",
+				(unsigned)aifa->fmtHdr.channels);
+		aifa_Close (This);
+		return false;
+	}
+	if (aifa->fmtHdr.sampleRate < 300 || aifa->fmtHdr.sampleRate > 128000)
+	{
+		log_add (log_Warning, "aifa_Open(): unsupported sampling rate %ld",
+				(long)aifa->fmtHdr.sampleRate);
+		aifa_Close (This);
+		return false;
+	}
+
+	aifa->block_align = aifa->bits_per_sample / 8 * aifa->fmtHdr.channels;
+	aifa->file_block = aifa->block_align;
+	if (!aifa->data_ofs)
+	{
+		log_add (log_Warning, "aifa_Open(): bad aiff file,"
+				" no SSND chunk found");
+		aifa_Close (This);
+		return false;
+	}
+
+	if (fileHdr.type == aiff_FormTypeAIFF)
+	{
+		if (aifa->fmtHdr.extTypeID != 0)
+		{
+			log_add (log_Warning, "aifa_Open(): unsupported extension 0x%08x",
+					aifa->fmtHdr.extTypeID);
+			aifa_Close (This);
+			return false;
+		}
+		aifa->comp_type = aifc_None;
+	}
+	else if (fileHdr.type == aiff_FormTypeAIFC)
+	{
+		if (aifa->fmtHdr.extTypeID != aiff_CompressionTypeSDX2)
+		{
+			log_add (log_Warning, "aifa_Open(): unsupported compression 0x%08x",
+					aifa->fmtHdr.extTypeID);
+			aifa_Close (This);
+			return false;
+		}
+		aifa->comp_type = aifc_Sdx2;
+		aifa->file_block /= 2;
+		assert(aifa->fmtHdr.channels <= MAX_CHANNELS);
+		// after decompression, we will get samples in machine byte order
+		This->need_swap = (aifa_formats->big_endian
+				!= aifa_formats->want_big_endian);
+	}
+
+	aifa->data_size = aifa->fmtHdr.sampleFrames * aifa->file_block;
+
+	if (aifa->comp_type == aifc_Sdx2 && aifa->bits_per_sample != 16)
+	{
+		log_add (log_Warning, "aifa_Open(): unsupported sample size %u for SDX2",
+				(unsigned)aifa->fmtHdr.sampleSize);
+		aifa_Close (This);
+		return false;
+	}
+
+	This->format = (aifa->fmtHdr.channels == 1 ?
+			(aifa->bits_per_sample == 8 ?
+				aifa_formats->mono8 : aifa_formats->mono16)
+			:
+			(aifa->bits_per_sample == 8 ?
+				aifa_formats->stereo8 : aifa_formats->stereo16)
+			);
+	This->frequency = aifa->fmtHdr.sampleRate;
+
+	uio_fseek (aifa->fp, aifa->data_ofs, SEEK_SET);
+	aifa->max_pcm = aifa->fmtHdr.sampleFrames;
+	aifa->cur_pcm = 0;
+	This->length = (float) aifa->max_pcm / aifa->fmtHdr.sampleRate;
+	aifa->last_error = 0;
+
+	return true;
+}
+
+static void
+aifa_Close (THIS_PTR)
+{
+	TFB_AiffSoundDecoder* aifa = (TFB_AiffSoundDecoder*) This;
+
+	if (aifa->fp)
+	{
+		uio_fclose (aifa->fp);
+		aifa->fp = NULL;
+	}
+}
+
+static int
+aifa_Decode (THIS_PTR, void* buf, sint32 bufsize)
+{
+	TFB_AiffSoundDecoder* aifa = (TFB_AiffSoundDecoder*) This;
+	switch (aifa->comp_type)
+	{
+	case aifc_None:
+		return aifa_DecodePCM (aifa, buf, bufsize);
+	case aifc_Sdx2:
+		return aifa_DecodeSDX2 (aifa, buf, bufsize);
+	default:
+		assert(false && "Unknown comp_type");
+		return 0;
+	}
+}
+
+static int
+aifa_DecodePCM (TFB_AiffSoundDecoder* aifa, void* buf, sint32 bufsize)
+{
+	uint32 dec_pcm;
+	uint32 size;
+
+	dec_pcm = bufsize / aifa->block_align;
+	if (dec_pcm > aifa->max_pcm - aifa->cur_pcm)
+		dec_pcm = aifa->max_pcm - aifa->cur_pcm;
+
+	dec_pcm = uio_fread (buf, aifa->file_block, dec_pcm, aifa->fp);
+	aifa->cur_pcm += dec_pcm;
+	size = dec_pcm * aifa->block_align;
+
+	if (aifa->bits_per_sample == 8)
+	{	// AIFF files store 8-bit data as signed
+		// and we need it unsigned
+		uint8* ptr = (uint8*)buf;
+		uint32 left;
+		for (left = size; left > 0; --left, ++ptr)
+			*ptr += 128;
+	}
+	
+	return size;
+}
+
+static int
+aifa_DecodeSDX2 (TFB_AiffSoundDecoder* aifa, void* buf, sint32 bufsize)
+{
+	uint32 dec_pcm;
+	sint8 *src;
+	sint16 *dst = buf;
+	uint32 left;
+
+	dec_pcm = bufsize / aifa->block_align;
+	if (dec_pcm > aifa->max_pcm - aifa->cur_pcm)
+		dec_pcm = aifa->max_pcm - aifa->cur_pcm;
+
+	src = (uint8*)buf + bufsize - (dec_pcm * aifa->file_block);
+	dec_pcm = uio_fread (src, aifa->file_block, dec_pcm, aifa->fp);
+	aifa->cur_pcm += dec_pcm;
+
+	for (left = dec_pcm; left > 0; --left)
+	{
+		int i;
+		sint32 *prev = aifa->prev_val;
+		for (i = aifa->fmtHdr.channels; i > 0; --i, ++prev, ++src, ++dst)
+		{
+			sint32 v = (*src * abs(*src)) << 1;
+			if (*src & 1)
+				v += *prev;
+			// saturate the value
+			if (v > 32767)
+				v = 32767;
+			else if (v < -32768)
+				v = -32768;
+			*prev = v;
+			*dst = v;
+		}
+	}
+
+	return dec_pcm * aifa->block_align;
+}
+
+static uint32
+aifa_Seek (THIS_PTR, uint32 pcm_pos)
+{
+	TFB_AiffSoundDecoder* aifa = (TFB_AiffSoundDecoder*) This;
+
+	if (pcm_pos > aifa->max_pcm)
+		pcm_pos = aifa->max_pcm;
+	aifa->cur_pcm = pcm_pos;
+	uio_fseek (aifa->fp,
+			aifa->data_ofs + pcm_pos * aifa->file_block,
+			SEEK_SET);
+
+	// reset previous values for SDX2 on seek ops
+	// the delta will recover faster with reset
+	memset(aifa->prev_val, sizeof(aifa->prev_val), 0);
+
+	return pcm_pos;
+}
+
+static uint32
+aifa_GetFrame (THIS_PTR)
+{
+	//TFB_AiffSoundDecoder* aifa = (TFB_AiffSoundDecoder*) This;
+	return 0; // only 1 frame for now
+
+	(void)This;	// laugh at compiler warning
+}
diff -ruNp src.orig/sc2code/libs/sound/decoders/aiffaud.h src/sc2code/libs/sound/decoders/aiffaud.h
--- src.orig/sc2code/libs/sound/decoders/aiffaud.h	1969-12-31 18:00:00 -0600
+++ src/sc2code/libs/sound/decoders/aiffaud.h	2017-11-08 16:49:59 -0600
@@ -0,0 +1,36 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/* AIFF decoder */
+
+#ifndef AIFFAUD_H
+#define AIFFAUD_H
+
+#include "decoder.h"
+
+extern TFB_SoundDecoderFuncs aifa_DecoderVtbl;
+
+typedef enum
+{
+	// positive values are the same as in errno
+	aifae_None = 0,
+	aifae_Unknown = -1,
+	aifae_BadFile = -2,
+	aifae_BadArg = -3,
+	aifae_Other = -1000,
+} aifa_Error;
+
+#endif /* AIFFAUD_H */
diff -ruNp src.orig/sc2code/libs/sound/decoders/decoder.c src/sc2code/libs/sound/decoders/decoder.c
--- src.orig/sc2code/libs/sound/decoders/decoder.c	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/sound/decoders/decoder.c	2017-11-08 16:49:59 -0600
@@ -28,7 +28,10 @@
 #include "wav.h"
 #include "dukaud.h"
 #include "modaud.h"
-#include "oggaud.h"
+#ifndef OVCODEC_NONE
+#	include "oggaud.h"
+#endif  /* OVCODEC_NONE */
+#include "aiffaud.h"
 
 
 #define MAX_REG_DECODERS 31
@@ -131,8 +134,11 @@ static TFB_RegSoundDecoder sd_decoders[M
 {
 	{true,  true,  "wav", &wava_DecoderVtbl},
 	{true,  true,  "mod", &moda_DecoderVtbl},
+#ifndef OVCODEC_NONE
 	{true,  true,  "ogg", &ova_DecoderVtbl},
+#endif  /* OVCODEC_NONE */
 	{true,  true,  "duk", &duka_DecoderVtbl},
+	{true,  true,  "aif", &aifa_DecoderVtbl},
 	{false, false,  NULL, NULL}, // null term
 };
 
@@ -338,10 +344,23 @@ SoundDecoder_Load (uio_DirHandle *dir, c
 	if (!info->ext)
 	{
 		log_add (log_Warning, "SoundDecoder_Load(): Unsupported file type (%s)",
-				filename);
-		return NULL;
+			filename);			
+
+		if (runTime)
+		{
+			runTime = abs (runTime);
+			startTime = 0;
+			funcs = &nula_DecoderVtbl;
+		}
+		else
+		{		
+			return NULL;
+		}
+	}
+	else
+	{
+		funcs = info->funcs;
 	}
-	funcs = info->funcs;
 
 	if (!fileExists2 (dir, filename))
 	{
@@ -359,7 +378,7 @@ SoundDecoder_Load (uio_DirHandle *dir, c
 		}
 	}
 
-	struct_size = info->funcs->GetStructSize ();
+	struct_size = funcs->GetStructSize ();
 	if (struct_size < SD_MIN_SIZE)
 		struct_size = SD_MIN_SIZE;
 
@@ -401,7 +420,7 @@ SoundDecoder_Load (uio_DirHandle *dir, c
 	if (runTime > 0 && runTime / 1000.0 < decoder->length)
 		decoder->length = (float)(runTime / 1000.0);
 
-	decoder->start_sample = decoder->frequency * startTime / 1000;
+	decoder->start_sample = (uint32)(startTime / 1000.0f * decoder->frequency);
 	decoder->end_sample = decoder->start_sample + 
 			(unsigned long)(decoder->length * decoder->frequency);
 	if (decoder->start_sample != 0)
@@ -535,10 +554,6 @@ SoundDecoder_DecodeAll (TFB_SoundDecoder
 	if (reqbufsize < 4096)
 		reqbufsize = 4096;
 
-	if (reqbufsize < 16384)
-		log_add (log_Debug, "SoundDecoder_DecodeAll(): WARNING, "
-				"called with a small buffer (%u)", reqbufsize);
-
 	for (decoded_bytes = 0, rc = 1; rc > 0; )
 	{	
 		if (decoded_bytes >= decoder->buffer_size)
@@ -608,7 +623,7 @@ SoundDecoder_Seek (TFB_SoundDecoder *dec
 		return;
 	}
 
-	pcm_pos = seekTime * decoder->frequency / 1000;
+	pcm_pos = (uint32) (seekTime / 1000.0f * decoder->frequency);
 	pcm_pos = decoder->funcs->Seek (decoder,
 			decoder->start_sample + pcm_pos);
 	decoder->pos = pcm_pos * decoder->bytes_per_samp;
diff -ruNp src.orig/sc2code/libs/sound/decoders/decoder.h src/sc2code/libs/sound/decoders/decoder.h
--- src.orig/sc2code/libs/sound/decoders/decoder.h	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/sound/decoders/decoder.h	2017-11-08 16:49:59 -0600
@@ -25,9 +25,11 @@
 #include "types.h"
 #include "uio.h"
 
-#ifdef _MSC_VER
-#	pragma comment (lib, "vorbisfile.lib")
-#endif
+#ifndef OVCODEC_NONE
+#	ifdef _MSC_VER
+#		pragma comment (lib, "vorbisfile.lib")
+#	endif  /* _MSC_VER */
+#endif  /* OVCODEC_NONE */
 
 typedef struct tfb_decoderformats
 {
diff -ruNp src.orig/sc2code/libs/sound/decoders/dukaud.c src/sc2code/libs/sound/decoders/dukaud.c
--- src.orig/sc2code/libs/sound/decoders/dukaud.c	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/sound/decoders/dukaud.c	2017-11-08 16:49:59 -0600
@@ -501,7 +501,7 @@ duka_Decode (THIS_PTR, void* buf, sint32
 	do
 	{
 		stuffed = duka_stuffBuffer (duka, buf, bufsize);
-		buf = (void *) ((uint8 *) buf + stuffed);
+		buf = (uint8*)buf + stuffed;
 		bufsize -= stuffed;
 		total += stuffed;
 	
diff -ruNp src.orig/sc2code/libs/sound/decoders/modaud.c src/sc2code/libs/sound/decoders/modaud.c
--- src.orig/sc2code/libs/sound/decoders/modaud.c	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/sound/decoders/modaud.c	2017-11-08 16:49:59 -0600
@@ -260,7 +260,11 @@ moda_InitModule (int flags, const TFB_De
 	else if (flags & audio_QUALITY_LOW)
 	{
 		md_mode = DMODE_SOFT_MUSIC|DMODE_STEREO|DMODE_16BITS;
+#ifdef __SYMBIAN32__
+		md_mixfreq = 11025;
+#else
 		md_mixfreq = 22050;
+#endif		
 		md_reverb = 0;
 	}
 	else
diff -ruNp src.orig/sc2code/libs/sound/decoders/wav.c src/sc2code/libs/sound/decoders/wav.c
--- src.orig/sc2code/libs/sound/decoders/wav.c	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/sound/decoders/wav.c	2017-11-08 16:49:59 -0600
@@ -28,33 +28,36 @@
 #include "libs/log.h"
 #include "wav.h"
 
-#define RIFF 0x46464952 /* "RIFF" */
-#define WAVE 0x45564157 /* "WAVE" */
-#define FMT  0x20746D66 /* "fmt " */
-#define DATA 0x61746164 /* "data" */
+#define wave_MAKE_ID(x1, x2, x3, x4) \
+		(((x4) << 24) | ((x3) << 16) | ((x2) << 8) | (x1))
+
+#define wave_RiffID   wave_MAKE_ID('R', 'I', 'F', 'F')
+#define wave_WaveID   wave_MAKE_ID('W', 'A', 'V', 'E')
+#define wave_FmtID    wave_MAKE_ID('f', 'm', 't', ' ')
+#define wave_DataID   wave_MAKE_ID('d', 'a', 't', 'a')
 
 typedef struct
 {
-	uint32 Id;
-	sint32 Size;
-	uint32 Type;
-} WAVFileHdr_Struct;
+	uint32 id;
+	sint32 size;
+	uint32 type;
+} wave_FileHeader;
 
 typedef struct
 {
-	uint16 Format;
-	uint16 Channels;
-	uint32 SamplesPerSec;
-	uint32 BytesPerSec;
-	uint16 BlockAlign;
-	uint16 BitsPerSample;
-} WAVFmtHdr_Struct;
+	uint16 format;
+	uint16 channels;
+	uint32 samplesPerSec;
+	uint32 bytesPerSec;
+	uint16 blockAlign;
+	uint16 bitsPerSample;
+} wave_FormatHeader;
 
 typedef struct
 {
-	uint32 Id;
-	uint32 Size;
-} WAVChunkHdr_Struct;
+	uint32 id;
+	uint32 size;
+} wave_ChunkHeader;
 
 
 #define THIS_PTR TFB_SoundDecoder* This
@@ -96,7 +99,7 @@ typedef struct tfb_wavesounddecoder
 	// private
 	sint32 last_error;
 	uio_Stream *fp;
-	WAVFmtHdr_Struct FmtHdr;
+	wave_FormatHeader fmtHdr;
 	uint32 data_ofs;
 	uint32 data_size;
 	uint32 max_pcm;
@@ -159,53 +162,61 @@ wava_Term (THIS_PTR)
 }
 
 static bool
-wava_readFileHeader (TFB_WaveSoundDecoder* wava, WAVFileHdr_Struct* hdr)
+read_le_16 (uio_Stream *fp, uint16 *v)
+{
+	if (!uio_fread (v, sizeof(*v), 1, fp))
+		return false;
+	*v = UQM_SwapLE16 (*v);
+	return true;
+}
+
+static bool
+read_le_32 (uio_Stream *fp, uint32 *v)
+{
+	if (!uio_fread (v, sizeof(*v), 1, fp))
+		return false;
+	*v = UQM_SwapLE32 (*v);
+	return true;
+}
+
+static bool
+wava_readFileHeader (TFB_WaveSoundDecoder* wava, wave_FileHeader* hdr)
 {
-	if (!uio_fread (&hdr->Id, 4, 1, wava->fp) ||
-			!uio_fread (&hdr->Size, 4, 1, wava->fp) ||
-			!uio_fread (&hdr->Type, 4, 1, wava->fp))
+	if (!read_le_32 (wava->fp, &hdr->id) ||
+			!read_le_32 (wava->fp, &hdr->size) ||
+			!read_le_32 (wava->fp, &hdr->type))
 	{
 		wava->last_error = errno;
 		return false;
 	}
-	hdr->Id   = UQM_SwapLE32 (hdr->Id);
-	hdr->Size = UQM_SwapLE32 (hdr->Size);
-	hdr->Type = UQM_SwapLE32 (hdr->Type);
-
 	return true;
 }
 
 static bool
-wava_readChunkHeader (TFB_WaveSoundDecoder* wava, WAVChunkHdr_Struct* chunk)
+wava_readChunkHeader (TFB_WaveSoundDecoder* wava, wave_ChunkHeader* chunk)
 {
-	if (!uio_fread (&chunk->Id, 4, 1, wava->fp) ||
-			!uio_fread (&chunk->Size, 4, 1, wava->fp))
+	if (!read_le_32 (wava->fp, &chunk->id) ||
+			!read_le_32 (wava->fp, &chunk->size))
+	{
+		wava->last_error = errno;
 		return false;
-
-	chunk->Id   = UQM_SwapLE32 (chunk->Id);
-	chunk->Size = UQM_SwapLE32 (chunk->Size);
-
+	}
 	return true;
 }
 
 static bool
-wava_readFormatHeader (TFB_WaveSoundDecoder* wava, WAVFmtHdr_Struct* fmt)
+wava_readFormatHeader (TFB_WaveSoundDecoder* wava, wave_FormatHeader* fmt)
 {
-	if (!uio_fread (&fmt->Format, 2, 1, wava->fp) ||
-			!uio_fread (&fmt->Channels, 2, 1, wava->fp) ||
-			!uio_fread (&fmt->SamplesPerSec, 4, 1, wava->fp) ||
-			!uio_fread (&fmt->BytesPerSec, 4, 1, wava->fp) ||
-			!uio_fread (&fmt->BlockAlign, 2, 1, wava->fp) ||
-			!uio_fread (&fmt->BitsPerSample, 2, 1, wava->fp))
-		return false;
-
-	fmt->Format        = UQM_SwapLE16 (fmt->Format);
-	fmt->Channels      = UQM_SwapLE16 (fmt->Channels);
-	fmt->SamplesPerSec = UQM_SwapLE32 (fmt->SamplesPerSec);
-	fmt->BytesPerSec   = UQM_SwapLE32 (fmt->BytesPerSec);
-	fmt->BlockAlign    = UQM_SwapLE16 (fmt->BlockAlign);
-	fmt->BitsPerSample = UQM_SwapLE16 (fmt->BitsPerSample);
-
+	if (!read_le_16 (wava->fp, &fmt->format) ||
+			!read_le_16 (wava->fp, &fmt->channels) ||
+			!read_le_32 (wava->fp, &fmt->samplesPerSec) ||
+			!read_le_32 (wava->fp, &fmt->bytesPerSec) ||
+			!read_le_16 (wava->fp, &fmt->blockAlign) ||
+			!read_le_16 (wava->fp, &fmt->bitsPerSample))
+	{
+		wava->last_error = errno;
+		return false;
+	}
 	return true;
 }
 
@@ -213,8 +224,8 @@ static bool
 wava_Open (THIS_PTR, uio_DirHandle *dir, const char *filename)
 {
 	TFB_WaveSoundDecoder* wava = (TFB_WaveSoundDecoder*) This;
-	WAVFileHdr_Struct FileHdr;
-	WAVChunkHdr_Struct ChunkHdr;
+	wave_FileHeader fileHdr;
+	wave_ChunkHeader chunkHdr;
 
 	wava->fp = uio_fopen (dir, filename, "rb");
 	if (!wava->fp)
@@ -227,52 +238,53 @@ wava_Open (THIS_PTR, uio_DirHandle *dir,
 	wava->data_ofs = 0;
 
 	// read wave header
-	if (!wava_readFileHeader (wava, &FileHdr))
+	if (!wava_readFileHeader (wava, &fileHdr))
 	{
 		wava->last_error = errno;
 		wava_Close (This);
 		return false;
 	}
-	if (FileHdr.Id != RIFF || FileHdr.Type != WAVE)
+	if (fileHdr.id != wave_RiffID || fileHdr.type != wave_WaveID)
 	{
 		log_add (log_Warning, "wava_Open(): "
 				"not a wave file, ID 0x%08x, Type 0x%08x",
-				FileHdr.Id, FileHdr.Type);
+				fileHdr.id, fileHdr.type);
 		wava_Close (This);
 		return false;
 	}
 
-	for (FileHdr.Size = ((FileHdr.Size + 1) & ~1) - 4; FileHdr.Size != 0;
-			FileHdr.Size -= (((ChunkHdr.Size + 1) & ~1) + 8))
+	for (fileHdr.size = ((fileHdr.size + 1) & ~1) - 4; fileHdr.size != 0;
+			fileHdr.size -= (((chunkHdr.size + 1) & ~1) + 8))
 	{
-		if (!wava_readChunkHeader (wava, &ChunkHdr))
+		if (!wava_readChunkHeader (wava, &chunkHdr))
 		{
-			wava->last_error = errno;
 			wava_Close (This);
 			return false;
 		}
 
-		if (ChunkHdr.Id == FMT)
+		if (chunkHdr.id == wave_FmtID)
 		{
-			if (!wava_readFormatHeader (wava, &wava->FmtHdr))
+			if (!wava_readFormatHeader (wava, &wava->fmtHdr))
 			{
-				wava->last_error = errno;
 				wava_Close (This);
 				return false;
 			}
-			uio_fseek (wava->fp, ChunkHdr.Size - 16, SEEK_CUR);
+			uio_fseek (wava->fp, chunkHdr.size - 16, SEEK_CUR);
 		}
 		else
 		{
-			if (ChunkHdr.Id == DATA)
+			if (chunkHdr.id == wave_DataID)
 			{
-				wava->data_size = ChunkHdr.Size;
+				wava->data_size = chunkHdr.size;
 				wava->data_ofs = uio_ftell (wava->fp);
 			}
-			uio_fseek (wava->fp, ChunkHdr.Size, SEEK_CUR);
+			uio_fseek (wava->fp, chunkHdr.size, SEEK_CUR);
 		}
 
-		uio_fseek (wava->fp, ChunkHdr.Size & 1, SEEK_CUR);
+		// 2-align the file ptr
+		// XXX: I do not think this is necessary in WAVE files;
+		//   possibly a remnant of ported AIFF reader
+		uio_fseek (wava->fp, chunkHdr.size & 1, SEEK_CUR);
 	}
 
 	if (!wava->data_size || !wava->data_ofs)
@@ -283,29 +295,34 @@ wava_Open (THIS_PTR, uio_DirHandle *dir,
 		return false;
 	}
 
-	if (wava->FmtHdr.Format == 0x0001)
-	{
-		This->format = (wava->FmtHdr.Channels == 1 ?
-				(wava->FmtHdr.BitsPerSample == 8 ?
-					wava_formats->mono8 : wava_formats->mono16)
-				:
-				(wava->FmtHdr.BitsPerSample == 8 ?
-					wava_formats->stereo8 : wava_formats->stereo16)
-				);
-		This->frequency = wava->FmtHdr.SamplesPerSec;
-	} 
-	else
-	{
+	if (wava->fmtHdr.format != 0x0001)
+	{	// not a PCM format
 		log_add (log_Warning, "wava_Open(): unsupported format %x",
-				wava->FmtHdr.Format);
+				wava->fmtHdr.format);
 		wava_Close (This);
 		return false;
 	}
+	if (wava->fmtHdr.channels != 1 && wava->fmtHdr.channels != 2)
+	{
+		log_add (log_Warning, "wava_Open(): unsupported number of channels %u",
+				(unsigned)wava->fmtHdr.channels);
+		wava_Close (This);
+		return false;
+	}
+
+	This->format = (wava->fmtHdr.channels == 1 ?
+			(wava->fmtHdr.bitsPerSample == 8 ?
+				wava_formats->mono8 : wava_formats->mono16)
+			:
+			(wava->fmtHdr.bitsPerSample == 8 ?
+				wava_formats->stereo8 : wava_formats->stereo16)
+			);
+	This->frequency = wava->fmtHdr.samplesPerSec;
 
 	uio_fseek (wava->fp, wava->data_ofs, SEEK_SET);
-	wava->max_pcm = wava->data_size / wava->FmtHdr.BlockAlign;
+	wava->max_pcm = wava->data_size / wava->fmtHdr.blockAlign;
 	wava->cur_pcm = 0;
-	This->length = (float) wava->max_pcm / wava->FmtHdr.SamplesPerSec;
+	This->length = (float) wava->max_pcm / wava->fmtHdr.samplesPerSec;
 	wava->last_error = 0;
 
 	return true;
@@ -329,14 +346,14 @@ wava_Decode (THIS_PTR, void* buf, sint32
 	TFB_WaveSoundDecoder* wava = (TFB_WaveSoundDecoder*) This;
 	uint32 dec_pcm;
 
-	dec_pcm = bufsize / wava->FmtHdr.BlockAlign;
+	dec_pcm = bufsize / wava->fmtHdr.blockAlign;
 	if (dec_pcm > wava->max_pcm - wava->cur_pcm)
 		dec_pcm = wava->max_pcm - wava->cur_pcm;
 
-	dec_pcm = uio_fread (buf, wava->FmtHdr.BlockAlign, dec_pcm, wava->fp);
+	dec_pcm = uio_fread (buf, wava->fmtHdr.blockAlign, dec_pcm, wava->fp);
 	wava->cur_pcm += dec_pcm;
 	
-	return dec_pcm * wava->FmtHdr.BlockAlign;
+	return dec_pcm * wava->fmtHdr.blockAlign;
 }
 
 static uint32
@@ -348,7 +365,7 @@ wava_Seek (THIS_PTR, uint32 pcm_pos)
 		pcm_pos = wava->max_pcm;
 	wava->cur_pcm = pcm_pos;
 	uio_fseek (wava->fp,
-			wava->data_ofs + pcm_pos * wava->FmtHdr.BlockAlign,
+			wava->data_ofs + pcm_pos * wava->fmtHdr.blockAlign,
 			SEEK_SET);
 
 	return pcm_pos;
diff -ruNp src.orig/sc2code/libs/sound/fileinst.c src/sc2code/libs/sound/fileinst.c
--- src.orig/sc2code/libs/sound/fileinst.c	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/sound/fileinst.c	2017-11-08 16:49:59 -0600
@@ -23,7 +23,7 @@
 
 
 SOUND_REF
-LoadSoundFile (PVOID pStr)
+LoadSoundFile (const char *pStr)
 {
 	uio_Stream *fp;
 
@@ -35,22 +35,22 @@ LoadSoundFile (PVOID pStr)
 	fp = res_OpenResFile (contentDir, pStr, "rb");
 	if (fp)
 	{
-		MEM_HANDLE hData;
+		SOUND_REF hData;
 
 		_cur_resfile_name = pStr;
-		hData = _GetSoundBankData (fp, LengthResFile (fp));
+		hData = (SOUND_REF)_GetSoundBankData (fp, LengthResFile (fp));
 		_cur_resfile_name = 0;
 
 		res_CloseResFile (fp);
 
-		return ((SOUND_REF)hData);
+		return hData;
 	}
 
-	return (0);
+	return NULL;
 }
 
 MUSIC_REF
-LoadMusicFile (PVOID pStr)
+LoadMusicFile (const char *pStr)
 {
 	uio_Stream *fp;
 	char filename[256];
@@ -70,15 +70,15 @@ LoadMusicFile (PVOID pStr)
 	fp = res_OpenResFile (contentDir, filename, "rb");
 	if (fp)
 	{
-		MEM_HANDLE hData;
+		MUSIC_REF hData;
 
 		_cur_resfile_name = filename;
-		hData = _GetMusicData (fp, LengthResFile (fp));
+		hData = (MUSIC_REF)_GetMusicData (fp, LengthResFile (fp));
 		_cur_resfile_name = 0;
 
 		res_CloseResFile (fp);
 
-		return ((MUSIC_REF)hData);
+		return hData;
 	}
 
 	return (0);
diff -ruNp src.orig/sc2code/libs/sound/mixer/sdl/audiodrv_sdl.c src/sc2code/libs/sound/mixer/sdl/audiodrv_sdl.c
--- src.orig/sc2code/libs/sound/mixer/sdl/audiodrv_sdl.c	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/sound/mixer/sdl/audiodrv_sdl.c	2017-11-08 16:49:59 -0600
@@ -119,7 +119,7 @@ mixSDL_Init (audio_Driver *driver, sint3
 		return -1;
 	}
 	log_add (log_Info, "SDL audio subsystem initialized.");
-	
+		
 	if (flags & audio_QUALITY_HIGH)
 	{
 		quality = MIX_QUALITY_HIGH;
@@ -129,8 +129,13 @@ mixSDL_Init (audio_Driver *driver, sint3
 	else if (flags & audio_QUALITY_LOW)
 	{
 		quality = MIX_QUALITY_LOW;
+#ifdef __SYMBIAN32__
+		desired.freq = 11025;
+		desired.samples = 4096;
+#else
 		desired.freq = 22050;
 		desired.samples = 2048;
+#endif		
 	}
 	else
 	{
@@ -208,12 +213,12 @@ mixSDL_Init (audio_Driver *driver, sint3
 	SetSFXVolume (sfxVolumeScale);
 	SetSpeechVolume (speechVolumeScale);
 	SetMusicVolume ((COUNT)musicVolume);
-		
+				
 	StreamDecoderTask = AssignTask (StreamDecoderTaskFunc, 1024, 
 		"audio stream decoder");
 
 	SDL_PauseAudio (0);
-	
+		
 	return 0;
 }
 
diff -ruNp src.orig/sc2code/libs/sound/music.c src/sc2code/libs/sound/music.c
--- src.orig/sc2code/libs/sound/music.c	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/sound/music.c	2017-11-08 16:49:59 -0600
@@ -14,6 +14,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+#include <string.h>
 #include "file.h"
 #include "options.h"
 #include "sound.h"
@@ -22,13 +23,13 @@
 
 
 static MUSIC_REF curMusicRef;
+static MUSIC_REF curSpeechRef;
 
 void
 PLRPlaySong (MUSIC_REF MusicRef, BOOLEAN Continuous, BYTE Priority)
 {
-	TFB_SoundSample **pmus;
+	TFB_SoundSample **pmus = MusicRef;
 
-	LockMusicData (MusicRef, &pmus);
 	if (pmus)
 	{
 		LockMutex (soundSource[MUSIC_SOURCE].stream_mutex);
@@ -50,7 +51,6 @@ PLRStop (MUSIC_REF MusicRef)
 		LockMutex (soundSource[MUSIC_SOURCE].stream_mutex);
 		StopStream (MUSIC_SOURCE);
 		UnlockMutex (soundSource[MUSIC_SOURCE].stream_mutex);
-		UnlockMusicData (curMusicRef);
 
 		curMusicRef = 0;
 	}
@@ -95,10 +95,39 @@ PLRResume (MUSIC_REF MusicRef)
 	}
 }
 
+void
+snd_PlaySpeech (MUSIC_REF SpeechRef)
+{
+	TFB_SoundSample **pmus = SpeechRef;
+
+	if (pmus)
+	{
+		LockMutex (soundSource[SPEECH_SOURCE].stream_mutex);
+		PlayStream (*pmus, SPEECH_SOURCE, false, false, true);
+		UnlockMutex (soundSource[SPEECH_SOURCE].stream_mutex);
+		
+		curSpeechRef = SpeechRef;
+	}
+}
+
+void
+snd_StopSpeech (void)
+{
+	if (!curSpeechRef)
+		return;
+	
+	LockMutex (soundSource[SPEECH_SOURCE].stream_mutex);
+	StopStream (SPEECH_SOURCE);
+	UnlockMutex (soundSource[SPEECH_SOURCE].stream_mutex);
+
+	curSpeechRef = 0;
+}
+
 BOOLEAN
 DestroyMusic (MUSIC_REF MusicRef)
 {
-	return (FreeMusicData (MusicRef));
+	FreeMusicData (MusicRef);
+	return (TRUE);
 }
 
 void
@@ -112,56 +141,23 @@ SetMusicVolume (COUNT Volume)
 char*
 CheckMusicResName (char* fileName)
 {
-	char otherName[256];
-	const char* otherExt;
-	char* curExt;
-
-	if (strlen (fileName) < 4)
-		return fileName;
-
-	strncpy (otherName, fileName, sizeof (otherName) - 1);
-	otherName[sizeof (otherName) - 1] = '\0';
-	
-	switch (optWhichMusic)
-	{
-		default:
-		case OPT_3DO:
-			otherExt = "ogg";
-			break;
-		case OPT_PC:
-			otherExt = "mod";
-			break;
-	}
-
-	curExt = otherName + strlen (otherName) - strlen (otherExt);
-	if (strcmp(curExt, otherExt) != 0)
-	{
-		strcpy (curExt, otherExt);
-		if (fileExists2 (contentDir, otherName))
-			strcpy (fileName, otherName);
-		else
-			log_add (log_Warning, "Requested track '%s' not found.", otherName);
-	}
-
+	if (!fileExists2 (contentDir, fileName))
+		log_add (log_Warning, "Requested track '%s' not found.", fileName);
 	return fileName;
 }
 
-MEM_HANDLE
+void *
 _GetMusicData (uio_Stream *fp, DWORD length)
 {
-	MEM_HANDLE h;
+	MUSIC_REF h;
 
-	h = 0;
 	if (_cur_resfile_name && (h = AllocMusicData (sizeof (void *))))
 	{
-		TFB_SoundSample **pmus;
+		TFB_SoundSample **pmus = h;
 
-		LockMusicData (h, &pmus);
 		if (!pmus)
 		{
-			UnlockMusicData (h);
-			mem_release (h);
-			h = 0;
+			return NULL;
 		}		
 		else
 		{
@@ -178,9 +174,8 @@ _GetMusicData (uio_Stream *fp, DWORD len
 			{
 				log_add (log_Warning, "_GetMusicData(): couldn't load %s", filename);
 
-				UnlockMusicData (h);
-				mem_release (h);
-				h = 0;
+				HFree (h);
+				return NULL;
 			}
 			else
 			{
@@ -193,8 +188,6 @@ _GetMusicData (uio_Stream *fp, DWORD len
 				audio_GenBuffers ((*pmus)->num_buffers, (*pmus)->buffer);
 			}
 		}
-
-		UnlockMusicData (h);
 	}
 
 	(void) fp;  /* satisfy compiler (unused parameter) */
@@ -203,12 +196,11 @@ _GetMusicData (uio_Stream *fp, DWORD len
 }
 
 BOOLEAN
-_ReleaseMusicData (MEM_HANDLE handle)
+_ReleaseMusicData (void *data)
 {
-	TFB_SoundSample **pmus;
+	TFB_SoundSample **pmus = data;
 
-	LockMusicData (handle, &pmus);
-	if (pmus == 0)
+	if (pmus == NULL)
 		return (FALSE);
 
 	if ((*pmus)->decoder)
@@ -229,9 +221,7 @@ _ReleaseMusicData (MEM_HANDLE handle)
 			HFree ((*pmus)->buffer_tag);
 	}
 	HFree (*pmus);
-
-	UnlockMusicData (handle);
-	mem_release (handle);
+	HFree (pmus);
 
 	return (TRUE);
 }
diff -ruNp src.orig/sc2code/libs/sound/openal/audiodrv_openal.c src/sc2code/libs/sound/openal/audiodrv_openal.c
--- src.orig/sc2code/libs/sound/openal/audiodrv_openal.c	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/sound/openal/audiodrv_openal.c	2017-11-08 16:49:59 -0600
@@ -145,9 +145,9 @@ openAL_Init (audio_Driver *driver, sint3
 	alcMakeContextCurrent (alcContext);
 
 	log_add (log_Info, "OpenAL initialized.\n"
-			"    version:     %s\n",
-			"    vendor:      %s\n",
-			"    renderer:    %s\n",
+			"    version:     %s\n"
+			"    vendor:      %s\n"
+			"    renderer:    %s\n"
 			"    device:      %s",
 			alGetString (AL_VERSION), alGetString (AL_VENDOR),
 			alGetString (AL_RENDERER),
diff -ruNp src.orig/sc2code/libs/sound/resinst.c src/sc2code/libs/sound/resinst.c
--- src.orig/sc2code/libs/sound/resinst.c	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/sound/resinst.c	2017-11-08 16:50:00 -0600
@@ -18,18 +18,30 @@
 
 #include "sndintrn.h"
 
+static void
+GetSoundBankFileData (const char *pathname, RESOURCE_DATA *resdata)
+{
+	resdata->ptr = LoadResourceFromPath (pathname, _GetSoundBankData);
+}
+
+static void
+GetMusicFileData (const char *pathname, RESOURCE_DATA *resdata)
+{
+	resdata->ptr = LoadResourceFromPath (pathname, _GetMusicData);
+}
+
 BOOLEAN
-InstallAudioResTypes (COUNT sound_type, COUNT music_type)
+InstallAudioResTypes (void)
 {
-	InstallResTypeVectors (sound_type, _GetSoundBankData, _ReleaseSoundBankData);
-	InstallResTypeVectors (music_type, _GetMusicData, _ReleaseMusicData);
+	InstallResTypeVectors ("SNDRES", GetSoundBankFileData, _ReleaseSoundBankData);
+	InstallResTypeVectors ("MUSICRES", GetMusicFileData, _ReleaseMusicData);
 	return (TRUE);
 }
 
 SOUND_REF
-LoadSoundInstance (DWORD res)
+LoadSoundInstance (RESOURCE res)
 {
-	MEM_HANDLE hData;
+	void *hData;
 
 	hData = res_GetResource (res);
 	if (hData)
@@ -39,9 +51,9 @@ LoadSoundInstance (DWORD res)
 }
 
 MUSIC_REF
-LoadMusicInstance (DWORD res)
+LoadMusicInstance (RESOURCE res)
 {
-	MEM_HANDLE hData;
+	void *hData;
 
 	hData = res_GetResource (res);
 	if (hData)
diff -ruNp src.orig/sc2code/libs/sound/sfx.c src/sc2code/libs/sound/sfx.c
--- src.orig/sc2code/libs/sound/sfx.c	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/sound/sfx.c	2017-11-08 16:50:00 -0600
@@ -18,6 +18,7 @@
 #include "sound.h"
 #include "libs/reslib.h"
 #include "libs/log.h"
+#include "libs/strings/strintrn.h"
 #include <math.h>
 
 
@@ -25,7 +26,7 @@ static void CheckFinishedChannels (void)
 
 
 void
-PlayChannel (COUNT channel, PVOID sample, SoundPosition pos,
+PlayChannel (COUNT channel, void *sample, SoundPosition pos,
 		void *positional_object, unsigned char priority)
 {
 	TFB_SoundSample *tfb_sample = *(TFB_SoundSample**) sample;
@@ -144,11 +145,11 @@ SetChannelVolume (COUNT channel, COUNT v
 }
 
 // Status: Ignored
-PBYTE
+BYTE*
 GetSampleAddress (SOUND sound)
 		// I might be prototyping this wrong, type-wise.
 {
-	return ((PBYTE)GetSoundAddress (sound));
+	return ((BYTE*)GetSoundAddress (sound));
 }
 
 // Status: Ignored
@@ -176,7 +177,7 @@ GetSampleRate (SOUND sound)
 	return 0;
 }
 
-MEM_HANDLE
+void *
 _GetSoundBankData (uio_Stream *fp, DWORD length)
 {
 	int snd_ct, n;
@@ -253,16 +254,11 @@ _GetSoundBankData (uio_Stream *fp, DWORD
 			break;*/
 	}
 
-	Snd = 0;
-	if (snd_ct && (Snd = AllocStringTable (
-		sizeof (STRING_TABLE_DESC)
-		+ (sizeof (DWORD) * snd_ct)
-		+ (sizeof (sndfx[0]) * snd_ct)
-		)))
+	Snd = NULL;
+	if (snd_ct && (Snd = AllocStringTable (snd_ct, 0)))
 	{
-		STRING_TABLEPTR fxTab;
+		STRING_TABLE fxTab = Snd;
 
-		LockStringTable (Snd, &fxTab);
 		if (fxTab == 0)
 		{
 			while (snd_ct--)
@@ -277,42 +273,42 @@ _GetSoundBankData (uio_Stream *fp, DWORD
 		}
 		else
 		{
-			DWORD *offs, StringOffs;
+			STRING str;
+			int i;
 
-			fxTab->StringCount = snd_ct;
-			fxTab->flags = 0;
-			offs = fxTab->StringOffsets;
-			StringOffs = sizeof (STRING_TABLE_DESC) + (sizeof (DWORD) * snd_ct);
-			memcpy ((BYTE *)fxTab + StringOffs, sndfx, sizeof (sndfx[0]) * snd_ct);
-			do
+			str = fxTab->strings;
+			for (i = 0; i < snd_ct; i++)
 			{
-				*offs++ = StringOffs;
-				StringOffs += sizeof (sndfx[0]);
-			} while (snd_ct--);
-			UnlockStringTable (Snd);
+				TFB_SoundSample **target = HMalloc (sizeof (sndfx[0]));
+				*target = sndfx[i];
+				str->data = (STRINGPTR)target;
+				str->length = sizeof (sndfx[0]);
+				str++;
+			}
 		}
 	}
 
-	return ((MEM_HANDLE)Snd);
+	return Snd;
 }
 
 BOOLEAN
-_ReleaseSoundBankData (MEM_HANDLE Snd)
+_ReleaseSoundBankData (void *Snd)
 {
-	STRING_TABLEPTR fxTab;
+	STRING_TABLE fxTab = Snd;
 
-	LockStringTable (Snd, &fxTab);
 	if (fxTab)
 	{
-		int snd_ct;
+		int snd_ct, index;
 		TFB_SoundSample **sptr;
 
-		snd_ct = fxTab->StringCount;
-		sptr = (TFB_SoundSample **)((BYTE *)fxTab + fxTab->StringOffsets[0]);
+		snd_ct = fxTab->size;
+		index = 0;
 		while (snd_ct--)
 		{
 			int i;
 			
+			sptr = (TFB_SoundSample **)(fxTab->strings[index].data);
+
 			for (i = 0; i < NUM_SOUNDSOURCES; ++i)
 			{
 				if (soundSource[i].sample == (*sptr))
@@ -329,9 +325,9 @@ _ReleaseSoundBankData (MEM_HANDLE Snd)
 			if ((*sptr)->buffer_tag)
 				HFree ((*sptr)->buffer_tag);
 			HFree (*sptr);
-			*sptr++ = 0;
+			*sptr = 0;
+			index++;
 		}
-		UnlockStringTable (Snd);
 		FreeStringTable (Snd);
 
 		return (TRUE);
@@ -343,5 +339,5 @@ _ReleaseSoundBankData (MEM_HANDLE Snd)
 BOOLEAN
 DestroySound(SOUND_REF target)
 {
-	return _ReleaseSoundBankData ((MEM_HANDLE) target);
+	return _ReleaseSoundBankData (target);
 }
diff -ruNp src.orig/sc2code/libs/sound/sndintrn.h src/sc2code/libs/sound/sndintrn.h
--- src.orig/sc2code/libs/sound/sndintrn.h	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/sound/sndintrn.h	2017-11-08 16:50:00 -0600
@@ -23,16 +23,14 @@
 #include "sndlib.h"
 #include "reslib.h"
 
-extern MEM_HANDLE _GetMusicData (uio_Stream *fp, DWORD length);
-extern BOOLEAN _ReleaseMusicData (MEM_HANDLE handle);
+extern void *_GetMusicData (uio_Stream *fp, DWORD length);
+extern BOOLEAN _ReleaseMusicData (void *handle);
 
-extern MEM_HANDLE _GetSoundBankData (uio_Stream *fp, DWORD length);
-extern BOOLEAN _ReleaseSoundBankData (MEM_HANDLE handle);
+extern void *_GetSoundBankData (uio_Stream *fp, DWORD length);
+extern BOOLEAN _ReleaseSoundBankData (void *handle);
 
-#define AllocMusicData(s) AllocResourceData((s),MEM_ZEROINIT)
-#define LockMusicData LockResourceData
-#define UnlockMusicData UnlockResourceData
-#define FreeMusicData _ReleaseMusicData
+#define AllocMusicData HMalloc
+#define FreeMusicData  _ReleaseMusicData
 
 extern char* CheckMusicResName (char* filename);
 
diff -ruNp src.orig/sc2code/libs/sound/sound.h src/sc2code/libs/sound/sound.h
--- src.orig/sc2code/libs/sound/sound.h	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/sound/sound.h	2017-11-08 16:50:00 -0600
@@ -18,7 +18,6 @@
 #define _UQM_SOUND_H
 
 #include "misc.h"
-#include "libs/strings/strintrn.h"
 #include "sndintrn.h"
 #include "audiocore.h"
 #include "decoders/decoder.h"
@@ -39,9 +38,6 @@ typedef struct
 	void *data; // user-defined data
 } TFB_SoundTag;
 
-// forward-declare
-typedef struct tfb_soundsample TFB_SoundSample;
-
 typedef struct tfb_soundcallbacks
 {
 	// return TRUE to continue, FALSE to abort
diff -ruNp src.orig/sc2code/libs/sound/stream.c src/sc2code/libs/sound/stream.c
--- src.orig/sc2code/libs/sound/stream.c	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/sound/stream.c	2017-11-08 16:50:00 -0600
@@ -15,6 +15,7 @@
  */
 
 #include <assert.h>
+#include <string.h>
 #include "sound.h"
 #include "libs/tasklib.h"
 #include "libs/log.h"
diff -ruNp src.orig/sc2code/libs/sound/trackplayer.c src/sc2code/libs/sound/trackplayer.c
--- src.orig/sc2code/libs/sound/trackplayer.c	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/sound/trackplayer.c	2017-11-08 16:50:00 -0600
@@ -646,7 +646,7 @@ SpliceTrack (UNICODE *TrackName, UNICODE
 						last_chain->track_num = tct - 1;
 						if (page_counter < num_pages)
 						{
-							last_chain->text = (void *)split_text[page_counter];
+							last_chain->text = split_text[page_counter];
 							last_ts_chain = last_chain;
 						}
 						last_chain->callback = cb;
@@ -825,6 +825,7 @@ FastForward_Page ()
 int
 GetSoundData (void *data) 
 {
+	// XXX: These two variants are begging to be merged
 	if (speechVolumeScale != 0.0f)
 	{
 		// speech is enabled
@@ -840,12 +841,18 @@ GetSoundData (void *data)
 				sample->decoder->frequency * 2.0f);
 			unsigned long pos;
 			int i;
+			int step;
 			UBYTE *scopedata = (UBYTE *) data;
 			UBYTE *sbuffer = soundSource[SPEECH_SOURCE].sbuffer;
 
-			assert (soundSource[SPEECH_SOURCE].sample->decoder->frequency == 11025);
+			assert (soundSource[SPEECH_SOURCE].sample->decoder->frequency >= 11025);
 			assert (soundSource[SPEECH_SOURCE].sample->decoder->format == audio_FORMAT_MONO16);
 
+			// Using step of 1 sample at 11025Hz, because the human speech
+			// is mostly in the low frequencies
+			step = soundSource[SPEECH_SOURCE].sample->decoder->frequency * 2 / 11025;
+			step = (step + 1) & ~1;
+
 			if (delta < 0)
 			{
 				log_add (log_Debug, "GetSoundData(): something's messed"
@@ -892,7 +899,7 @@ GetSoundData (void *data)
 					s = RADAR_HEIGHT - 2;
 				scopedata[i] = (UBYTE) s;
 
-				pos += 2;
+				pos += step;
 			}
 
 			UnlockMutex (soundSource[SPEECH_SOURCE].stream_mutex);
@@ -921,6 +928,7 @@ GetSoundData (void *data)
 			assert (soundSource[MUSIC_SOURCE].sample->decoder->frequency >= 11025);
 			assert (soundSource[MUSIC_SOURCE].sample->decoder->format == audio_FORMAT_STEREO16);
 
+			// Using step of 4 samples at 11025Hz for the music
 			step = soundSource[MUSIC_SOURCE].sample->decoder->frequency / 11025 * 16;
 			if (step % 2 == 1)
 				step++;
diff -ruNp src.orig/sc2code/libs/strings/getstr.c src/sc2code/libs/strings/getstr.c
--- src.orig/sc2code/libs/strings/getstr.c	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/strings/getstr.c	2017-11-08 16:50:00 -0600
@@ -22,11 +22,13 @@
 #include "libs/reslib.h"
 #include "libs/log.h"
 
+#define MAX_STRINGS 2048
+#define POOL_SIZE 4096
 
 static void
-dword_convert (PDWORD dword_array, COUNT num_dwords)
+dword_convert (DWORD *dword_array, COUNT num_dwords)
 {
-	PBYTE p = (PBYTE)dword_array;
+	BYTE *p = (BYTE*)dword_array;
 
 	do
 	{
@@ -38,303 +40,441 @@ dword_convert (PDWORD dword_array, COUNT
 	} while (--num_dwords);
 }
 
-MEM_HANDLE
-_GetStringData (uio_Stream *fp, DWORD length)
+static void
+set_strtab_entry (STRING_TABLE_DESC *strtab, int index, const char *value, int len)
 {
-	MEM_HANDLE hData;
+	STRING str = &strtab->strings[index];
+
+	if (str->data)
+	{
+		HFree (str->data);
+		str->data = NULL;
+		str->length = 0;
+	}
+	if (len)
+	{
+		str->data = HMalloc (len);
+		str->length = len;
+		memcpy (str->data, value, len);
+	}
+}
 
+void
+_GetConversationData (const char *path, RESOURCE_DATA *resdata)
+{
+	uio_Stream *fp;
+	long dataLen;
+	void *result;
+	int n, path_len, num_data_sets;
+	DWORD opos,
+		slen[MAX_STRINGS], StringOffs, tot_string_size,
+		clen[MAX_STRINGS], ClipOffs, tot_clip_size,
+		tslen[MAX_STRINGS], TSOffs, tot_ts_size;
+	char CurrentLine[1024], paths[1024], *clip_path, *ts_path,
+		*strdata, *clipdata, *ts_data;
+	uio_Stream *timestamp_fp = NULL;
+
+	/* Parse out the conversation components. */
+	strncpy (paths, path, 1023);
+	paths[1023] = '\0';
+	clip_path = strchr (paths, ':');
+	if (clip_path == NULL)
 	{
-		char *s;
+		ts_path = NULL;
+	}
+	else
+	{
+		*clip_path = '\0';
+		clip_path++;
 
-		if (_cur_resfile_name && (s = strrchr (_cur_resfile_name, '.')) &&
-				stricmp (s, ".txt") == 0)
+		ts_path = strchr (clip_path, ':');
+		if (ts_path != NULL)
 		{
-#define MAX_STRINGS 2048
-#define POOL_SIZE 4096
-			int n, path_len, num_data_sets;
-			DWORD opos,
-			      slen[MAX_STRINGS], StringOffs, tot_string_size,
-			      clen[MAX_STRINGS], ClipOffs, tot_clip_size,
-			      tslen[MAX_STRINGS], TSOffs, tot_ts_size;
-			char CurrentLine[1024], clip_path[1024], *strdata, *clipdata,
-			     *ts_data;
-			uio_Stream *timestamp_fp = NULL;
+			*ts_path = '\0';
+			ts_path++;
+		}
+	}
 
-			if ((strdata = HMalloc (tot_string_size = POOL_SIZE)) == 0)
-				return (0);
+	fp = res_OpenResFile (contentDir, paths, "rb");
+	if (fp == NULL)
+	{
+		log_add (log_Warning, "Warning: Can't open '%s'", paths);
+		resdata->ptr = NULL;
+		return;
+	}
 
-			if ((clipdata = HMalloc (tot_clip_size = POOL_SIZE)) == 0)
-			{
-				HFree (strdata);
-				return (0);
-			}
-			ts_data = NULL;
+	dataLen = LengthResFile (fp);
+	log_add (log_Info, "\t'%s' -- conversation phrases -- %lu bytes", paths, dataLen);
+	if (clip_path)
+		log_add (log_Info, "\t'%s' -- voice clip directory", clip_path);
+	else
+		log_add (log_Info, "\tNo associated voice clips");
+	if (ts_path)
+		log_add (log_Info, "\t'%s' -- timestamps", ts_path);
+	else
+		log_add (log_Info, "\tNo associated timestamp file");
 
-			{
-				char *s1, *s2;
+	
+	if (dataLen == 0)
+	{
+		log_add (log_Warning, "Warning: Trying to load empty file '%s'.", path);
+		goto err;
+	}
+	
+	if ((strdata = HMalloc (tot_string_size = POOL_SIZE)) == 0)
+		goto err;
+	
+	if ((clipdata = HMalloc (tot_clip_size = POOL_SIZE)) == 0)
+	{
+		HFree (strdata);
+		goto err;
+	}
+	ts_data = NULL;
+	
+	path_len = clip_path ? strlen (clip_path) : 0;
 
-				if (((s2 = 0), (s1 = strrchr (_cur_resfile_name, '/')) == 0)
-						&& (s2 = strrchr (_cur_resfile_name, '\\')) == 0)
-					n = 0;
-				else
-				{
-					if (s2 > s1)
-						s1 = s2;
-					n = s1 - _cur_resfile_name + 1;
-					strncpy (clip_path, _cur_resfile_name, n);
-				}
-				clip_path[n] = '\0';
-				path_len = strlen (clip_path);
-			}
+	if (ts_path && (timestamp_fp = uio_fopen (contentDir, ts_path,
+			"rb")))
+	{
+		if ((ts_data = HMalloc (tot_ts_size = POOL_SIZE)) == 0)
+			goto err;
+	}
+	
+	opos = uio_ftell (fp);
+	n = -1;
+	StringOffs = ClipOffs = TSOffs = 0;
+	while (uio_fgets (CurrentLine, sizeof (CurrentLine), fp) && n < MAX_STRINGS - 1)
+	{
+		int l;
+
+		if (CurrentLine[0] == '#')
+		{
+			char CopyLine[1024];
+			char *s;
 
+			strcpy (CopyLine, CurrentLine);
+			s = strtok (&CopyLine[1], "()");
+			if (s)
 			{
-				// try to open the timestamp file
-				char ts_file_name[1024];
-				strcpy (ts_file_name, _cur_resfile_name);
-				s = strrchr (ts_file_name, '.');
-				s += 2;
-				*s++ = 's';
-				*s = '\0';
-				if ((timestamp_fp = uio_fopen (contentDir, ts_file_name,
-						"rb")))
+				if (n >= 0)
 				{
-					log_add (log_Info, "Found timestamp file: %s", ts_file_name);
-					if ((ts_data = HMalloc (tot_ts_size = POOL_SIZE)) == 0)
-						return (0);
+					while (slen[n] > 1 && 
+							(strdata[StringOffs - 2] == '\n' ||
+							strdata[StringOffs - 2] == '\r'))
+					{
+						--slen[n];
+						--StringOffs;
+						strdata[StringOffs - 1] = '\0';
+					}
 				}
-			}
 
-			opos = uio_ftell (fp);
-			n = -1;
-			StringOffs = ClipOffs = TSOffs = 0;
-			while (uio_fgets (CurrentLine, sizeof (CurrentLine), fp) && n < MAX_STRINGS - 1)
-			{
-				int l;
-
-				if (CurrentLine[0] == '#')
+				slen[++n] = 0;
+				// now lets check for timestamp data
+				if (timestamp_fp)
 				{
-					char CopyLine[1024];
-
-					strcpy (CopyLine, CurrentLine);
-					s = strtok (&CopyLine[1], "()");
-					if (s)
+					char TimeStampLine[1024], *tsptr;
+					BOOLEAN ts_ok = FALSE;
+					uio_fgets (TimeStampLine, sizeof (TimeStampLine), timestamp_fp);
+					if (TimeStampLine[0] == '#')
 					{
-						if (n >= 0)
+						tslen[n] = 0;
+						if ((tsptr = strstr (TimeStampLine,s)) 
+								&& (tsptr += strlen(s))
+								&& (++tsptr))
 						{
-							while (slen[n] > 1 && 
-									(strdata[StringOffs - 2] == '\n' ||
-									strdata[StringOffs - 2] == '\r'))
+							ts_ok = TRUE;
+							while (! strcspn(tsptr," \t\r\n") && *tsptr)
+								tsptr++;
+							if (*tsptr)
 							{
-								--slen[n];
-								--StringOffs;
-								strdata[StringOffs - 1] = '\0';
-							}
-						}
-
-						slen[++n] = 0;
-						// now lets check for timestamp data
-						if (timestamp_fp)
-						{
-							char TimeStampLine[1024], *tsptr;
-							BOOLEAN ts_ok = FALSE;
-							uio_fgets (TimeStampLine, sizeof (TimeStampLine), timestamp_fp);
-							if (TimeStampLine[0] == '#')
-							{
-								tslen[n] = 0;
-								if ((tsptr = strstr (TimeStampLine,s)) 
-										&& (tsptr += strlen(s))
-										&& (++tsptr))
+								l = strlen (tsptr)  + 1;
+								if (TSOffs + l > tot_ts_size
+									&& (ts_data = HRealloc (ts_data,
+										tot_ts_size += POOL_SIZE)) == 0)
 								{
-									ts_ok = TRUE;
-									while (! strcspn(tsptr," \t\r\n") && *tsptr)
-										tsptr++;
-									if (*tsptr)
-									{
-										l = strlen (tsptr)  + 1;
-										if (TSOffs + l > tot_ts_size
-											&& (ts_data = HRealloc (ts_data,
-												tot_ts_size += POOL_SIZE)) == 0)
-										{
-											HFree (strdata);
-											return (0);
-										}
-										strcpy (&ts_data[TSOffs], tsptr);
-										TSOffs += l;
-										tslen[n] = l;
-									}
+									HFree (strdata);
+									goto err;
 								}
+								strcpy (&ts_data[TSOffs], tsptr);
+								TSOffs += l;
+								tslen[n] = l;
 							}
-							if (!ts_ok)
-							{
-								// timestamp data is invalid, remove all of it
-								log_add (log_Warning, "Invalid timestamp data "
-										"for '%s'.  Disabling timestamps", s);
-								HFree (ts_data);
-								ts_data = NULL;
-								uio_fclose (timestamp_fp);
-								timestamp_fp = NULL;
-								TSOffs = 0;
-							}
-						}
-						clen[n] = 0;
-						s = strtok (NULL, " \t\r\n)");
-						if (s)
-						{
-							l = path_len + strlen (s) + 1;
-							if (ClipOffs + l > tot_clip_size
-									&& (clipdata = HRealloc (clipdata,
-									tot_clip_size += POOL_SIZE)) == 0)
-							{
-								HFree (strdata);
-								return (0);
-							}
-
-							strcpy (&clipdata[ClipOffs], clip_path);
-							strcpy (&clipdata[ClipOffs + path_len], s);
-							ClipOffs += l;
-							clen[n] = l;
 						}
 					}
-				}
-				else if (n >= 0)
-				{
-					l = strlen (CurrentLine) + 1;
-					if (StringOffs + l > tot_string_size
-							&& (strdata = HRealloc (strdata,
-							tot_string_size += POOL_SIZE)) == 0)
+					if (!ts_ok)
 					{
-						HFree (clipdata);
-						return (0);
+						// timestamp data is invalid, remove all of it
+						log_add (log_Warning, "Invalid timestamp data "
+								"for '%s'.  Disabling timestamps", s);
+						HFree (ts_data);
+						ts_data = NULL;
+						uio_fclose (timestamp_fp);
+						timestamp_fp = NULL;
+						TSOffs = 0;
 					}
-
-					if (slen[n])
+				}
+				clen[n] = 0;
+				s = strtok (NULL, " \t\r\n)");
+				if (s)
+				{
+					l = path_len + strlen (s) + 1;
+					if (ClipOffs + l > tot_clip_size
+							&& (clipdata = HRealloc (clipdata,
+							tot_clip_size += POOL_SIZE)) == 0)
 					{
-						--slen[n];
-						--StringOffs;
+						HFree (strdata);
+						goto err;
 					}
-					s = &strdata[StringOffs];
-					slen[n] += l;
-					StringOffs += l;
 
-					strcpy (s, CurrentLine);
+					if (clip_path)
+						strcpy (&clipdata[ClipOffs], clip_path);
+					strcpy (&clipdata[ClipOffs + path_len], s);
+					ClipOffs += l;
+					clen[n] = l;
 				}
+			}
+		}
+		else if (n >= 0)
+		{
+			char *s;
+			l = strlen (CurrentLine) + 1;
+			if (StringOffs + l > tot_string_size
+					&& (strdata = HRealloc (strdata,
+					tot_string_size += POOL_SIZE)) == 0)
+			{
+				HFree (clipdata);
+				goto err;
+			}
 
-				if ((int)uio_ftell (fp) - (int)opos >= (int)length)
-					break;
+			if (slen[n])
+			{
+				--slen[n];
+				--StringOffs;
 			}
-			if (n >= 0)
+			s = &strdata[StringOffs];
+			slen[n] += l;
+			StringOffs += l;
+
+			strcpy (s, CurrentLine);
+		}
+
+		if ((int)uio_ftell (fp) - (int)opos >= (int)dataLen)
+			break;
+	}
+	if (n >= 0)
+	{
+		while (slen[n] > 1 && (strdata[StringOffs - 2] == '\n'
+				|| strdata[StringOffs - 2] == '\r'))
+		{
+			--slen[n];
+			--StringOffs;
+			strdata[StringOffs - 1] = '\0';
+		}
+	}
+
+	if (timestamp_fp)
+		uio_fclose (timestamp_fp);
+
+	result = NULL;
+	num_data_sets = (ClipOffs ? 1 : 0) + (TSOffs ? 1 : 0) + 1;
+	if (++n)
+	{
+		int flags = 0;
+		if (ClipOffs)
+			flags |= HAS_SOUND_CLIPS;
+		if (TSOffs)
+			flags |= HAS_TIMESTAMP;
+		result = AllocStringTable (n, flags);
+		if (result)
+		{
+			int StringIndex, ClipIndex, TSIndex;
+			STRING_TABLE_DESC *lpST;
+
+			lpST = (STRING_TABLE) result;
+
+			StringIndex = 0;
+			ClipIndex = n;
+			TSIndex = n * ((flags & HAS_SOUND_CLIPS) ? 2 : 1);
+
+			StringOffs = ClipOffs = TSOffs = 0;
+
+			for (n = 0; n < (int)lpST->size;
+					++n, ++StringIndex, ++ClipIndex, ++TSIndex)
 			{
-				while (slen[n] > 1 && (strdata[StringOffs - 2] == '\n'
-						|| strdata[StringOffs - 2] == '\r'))
+				set_strtab_entry(lpST, StringIndex, strdata + StringOffs, slen[n]);
+				StringOffs += slen[n];
+				if (lpST->flags & HAS_SOUND_CLIPS)
+				{
+					set_strtab_entry(lpST, ClipIndex, clipdata + ClipOffs, clen[n]);
+					ClipOffs += clen[n];
+				}
+				if (lpST->flags & HAS_TIMESTAMP)
 				{
-					--slen[n];
-					--StringOffs;
-					strdata[StringOffs - 1] = '\0';
+					set_strtab_entry(lpST, TSIndex, ts_data + TSOffs, tslen[n]);
+					TSOffs += tslen[n];
 				}
 			}
+		}
+	}
+	HFree (strdata);
+	HFree (clipdata);
+	if (ts_data)
+		HFree (ts_data);
+
+	resdata->ptr = result;
+	return;
+
+err:
+	res_CloseResFile (fp);
+	resdata->ptr = NULL;
 
-			if (timestamp_fp)
-				uio_fclose (timestamp_fp);
+}
 
-			hData = 0;
-			num_data_sets = (ClipOffs ? 1 : 0) + (TSOffs ? 1 : 0) + 1;
-			if (++n && (hData = AllocStringTable (
-					(sizeof (STRING_TABLE_DESC) - sizeof (DWORD))
-					+ (sizeof (DWORD) * ((n + 1) * num_data_sets))
-					+ StringOffs + ClipOffs + TSOffs)))
-			{
-				PDWORD lpStringOffs, lpClipOffs, lpTSOffs;
-				STRING_TABLEPTR lpST;
+void *
+_GetStringData (uio_Stream *fp, DWORD length)
+{
+	void *result;
+
+	int n;
+	DWORD opos, slen[MAX_STRINGS], StringOffs, tot_string_size;
+	char CurrentLine[1024], *strdata;
+
+	if ((strdata = HMalloc (tot_string_size = POOL_SIZE)) == 0)
+		return (0);
+
+	opos = uio_ftell (fp);
+	n = -1;
+	StringOffs = 0;
+	while (uio_fgets (CurrentLine, sizeof (CurrentLine), fp) && n < MAX_STRINGS - 1)
+	{
+		int l;
 
-				LockStringTable (hData, &lpST);
-				lpST->StringCount = n;
-				lpST->flags = 0;
-				if (ClipOffs)
-					lpST->flags |= HAS_SOUND_CLIPS;
-				if (TSOffs)
-					lpST->flags |= HAS_TIMESTAMP;
-
-				memcpy (&lpST->StringOffsets[(n + 1) * num_data_sets],
-						strdata, StringOffs);
-				memcpy ((BYTE *)&lpST->StringOffsets[(n + 1) * num_data_sets]
-						+ StringOffs, clipdata, ClipOffs);
-				if (TSOffs)
-					memcpy ((BYTE *)&lpST->StringOffsets[
-							(n + 1) * num_data_sets] + StringOffs + ClipOffs,
-							ts_data, TSOffs);
-				TSOffs = ((BYTE *)&lpST->StringOffsets[(n + 1) * num_data_sets]
-						- (BYTE *)lpST) + StringOffs + ClipOffs;
-				ClipOffs = TSOffs - ClipOffs;
-				StringOffs = ClipOffs - StringOffs;
-
-				lpStringOffs = lpST->StringOffsets;
-				lpClipOffs = &lpST->StringOffsets[lpST->StringCount + 1];
-				lpTSOffs = &lpST->StringOffsets[(lpST->StringCount + 1)
-						<< ((lpST->flags & HAS_SOUND_CLIPS) ? 1 : 0)];
-				for (n = 0; n < (int)lpST->StringCount;
-						++n, ++lpStringOffs, ++lpClipOffs, ++lpTSOffs)
+		if (CurrentLine[0] == '#')
+		{
+			char CopyLine[1024];
+			char *s;
+
+			strcpy (CopyLine, CurrentLine);
+			s = strtok (&CopyLine[1], "()");
+			if (s)
+			{
+				if (n >= 0)
 				{
-					*lpStringOffs = StringOffs;
-					StringOffs += slen[n];
-					if (lpST->flags & HAS_SOUND_CLIPS)
-					{
-						*lpClipOffs = ClipOffs;
-						ClipOffs += clen[n];
-					}
-					if (lpST->flags & HAS_TIMESTAMP)
+					while (slen[n] > 1 && 
+							(strdata[StringOffs - 2] == '\n' ||
+							strdata[StringOffs - 2] == '\r'))
 					{
-						*lpTSOffs = TSOffs;
-						TSOffs += tslen[n];
+						--slen[n];
+						--StringOffs;
+						strdata[StringOffs - 1] = '\0';
 					}
-
 				}
-				*lpStringOffs = StringOffs;
-				if (lpST->flags & HAS_SOUND_CLIPS)
-					*lpClipOffs = ClipOffs;
-				if (lpST->flags & HAS_TIMESTAMP)
-					*lpTSOffs = TSOffs;
 
-				UnlockStringTable (hData);
+				slen[++n] = 0;
+			}
+		}
+		else if (n >= 0)
+		{
+			char *s;
+			l = strlen (CurrentLine) + 1;
+			if (StringOffs + l > tot_string_size
+					&& (strdata = HRealloc (strdata,
+					tot_string_size += POOL_SIZE)) == 0)
+			{
+				return (0);
+			}
+
+			if (slen[n])
+			{
+				--slen[n];
+				--StringOffs;
 			}
+			s = &strdata[StringOffs];
+			slen[n] += l;
+			StringOffs += l;
 
-			HFree (strdata);
-			HFree (clipdata);
-			if (ts_data)
-				HFree (ts_data);
+			strcpy (s, CurrentLine);
+		}
 
-			return (hData);
+		if ((int)uio_ftell (fp) - (int)opos >= (int)length)
+			break;
+	}
+	if (n >= 0)
+	{
+		while (slen[n] > 1 && (strdata[StringOffs - 2] == '\n'
+				|| strdata[StringOffs - 2] == '\r'))
+		{
+			--slen[n];
+			--StringOffs;
+			strdata[StringOffs - 1] = '\0';
 		}
 	}
 
-	hData = GetResourceData (fp, length, MEM_SOUND);
-	if (hData)
+	result = NULL;
+	if (++n)
 	{
-		COUNT StringCount;
-		DWORD StringOffs;
-		PDWORD lpStringOffs;
-		STRING_TABLEPTR lpST;
-
-		LockStringTable (hData, &lpST);
-length = *(DWORD *)&lpST->StringCount;
-dword_convert (&length, 1);
-lpST->StringCount = (unsigned short)length;
-		StringCount = lpST->StringCount;
-		lpST->flags = 0;
-
-		lpStringOffs = lpST->StringOffsets;
-dword_convert (lpStringOffs, StringCount + 1);
-		StringOffs = sizeof (STRING_TABLE_DESC)
-				+ (sizeof (DWORD) * StringCount);
-		do
+		int flags = 0;
+		result = AllocStringTable (n, flags);
+		if (result)
 		{
-			StringOffs += *lpStringOffs;
-			*lpStringOffs++ = StringOffs;
-		} while (StringCount--);
+			int StringIndex;
+			STRING_TABLE_DESC *lpST;
+
+			lpST = (STRING_TABLE) result;
 
-		UnlockStringTable (hData);
+			StringIndex = 0;
+
+			StringOffs = 0;
+
+			for (n = 0; n < (int)lpST->size;
+					++n, ++StringIndex)
+			{
+				set_strtab_entry(lpST, StringIndex, strdata + StringOffs, slen[n]);
+				StringOffs += slen[n];
+			}
+		}
 	}
+	HFree (strdata);
 
-	return (hData);
+	return (result);
 }
 
 
+void *
+_GetBinaryTableData (uio_Stream *fp, DWORD length)
+{
+	void *result;
+	result = GetResourceData (fp, length);
+
+	if (result)
+	{
+		DWORD *fileData;
+		STRING_TABLE lpST;
+
+		fileData = (DWORD *)result;
+
+		dword_convert (fileData, 1); /* Length */
+
+		lpST = AllocStringTable (fileData[0], 0);
+		if (lpST)
+		{
+			int i, size;
+			BYTE *stringptr;
+
+			size = lpST->size;
+
+			dword_convert (fileData+1, size + 1);
+			stringptr = (BYTE *)(fileData + 2 + size + fileData[1]);
+			for (i = 0; i < size; i++)
+			{
+				set_strtab_entry (lpST, i, stringptr, fileData[2+i]);
+				stringptr += fileData[2+i];
+			}
+		}
+		HFree (result);
+		result = lpST;
+	}
+
+	return (result);
+}
+
diff -ruNp src.orig/sc2code/libs/strings/sfileins.c src/sc2code/libs/strings/sfileins.c
--- src.orig/sc2code/libs/strings/sfileins.c	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/strings/sfileins.c	2017-11-08 16:50:00 -0600
@@ -35,14 +35,14 @@ LoadStringTableFile (uio_DirHandle *dir,
 	fp = res_OpenResFile (dir, fileName, "rb");
 	if (fp)
 	{
-		MEM_HANDLE hData;
+		STRING_TABLE data;
 
 		_cur_resfile_name = fileName;
-		hData = _GetStringData (fp, LengthResFile (fp));
+		data = (STRING_TABLE) _GetStringData (fp, LengthResFile (fp));
 		_cur_resfile_name = 0;
 		res_CloseResFile (fp);
 
-		return (BUILD_STRING_TABLE (hData));
+		return data;
 	}
 
 	return (0);
diff -ruNp src.orig/sc2code/libs/strings/sresins.c src/sc2code/libs/strings/sresins.c
--- src.orig/sc2code/libs/strings/sresins.c	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/strings/sresins.c	2017-11-08 16:50:00 -0600
@@ -18,24 +18,38 @@
 
 #include "strintrn.h"
 
+static void
+GetStringTableFileData (const char *pathname, RESOURCE_DATA *resdata)
+{
+	resdata->ptr = LoadResourceFromPath (pathname, _GetStringData);
+}
+
+static void
+GetBinaryTableFileData (const char *pathname, RESOURCE_DATA *resdata)
+{
+	resdata->ptr = LoadResourceFromPath (pathname, _GetBinaryTableData);
+}
+
 BOOLEAN
-InstallStringTableResType (COUNT string_type)
+InstallStringTableResType (void)
 {
-	return (InstallResTypeVectors (string_type,
-			_GetStringData, FreeResourceData));
+	InstallResTypeVectors ("STRTAB", GetStringTableFileData, FreeResourceData);
+	InstallResTypeVectors ("BINTAB", GetBinaryTableFileData, FreeResourceData);
+	InstallResTypeVectors ("CONVERSATION", _GetConversationData, FreeResourceData);
+	return TRUE;
 }
 
 STRING_TABLE
-LoadStringTableInstance (DWORD res)
+LoadStringTableInstance (RESOURCE res)
 {
-	MEM_HANDLE hData;
+	void *data;
 
-	hData = res_GetResource (res);
-	if (hData)
+	data = res_GetResource (res);
+	if (data)
 	{
 		res_DetachResource (res);
 	}
 
-	return (BUILD_STRING_TABLE (hData));
+	return (STRING_TABLE)data;
 }
 
diff -ruNp src.orig/sc2code/libs/strings/strings.c src/sc2code/libs/strings/strings.c
--- src.orig/sc2code/libs/strings/strings.c	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/strings/strings.c	2017-11-08 16:50:00 -0600
@@ -17,27 +17,83 @@
  */
 
 #include "strintrn.h"
+#include "misc.h"
+
+STRING_TABLE
+AllocStringTable (int num_entries, int flags)
+{
+	STRING_TABLE strtab = HMalloc (sizeof (STRING_TABLE_DESC));
+	int i, multiplier = 1;
+
+	if (flags & HAS_SOUND_CLIPS)
+	{
+		multiplier++;
+	}
+	if (flags & HAS_TIMESTAMP)
+	{
+		multiplier++;
+	}
+	strtab->flags = flags;
+	strtab->size = num_entries;
+	num_entries *= multiplier;
+	strtab->strings = HMalloc (sizeof (STRING_TABLE_ENTRY_DESC) * num_entries);
+	for (i = 0; i < num_entries; i++)
+	{
+		strtab->strings[i].data = NULL;
+		strtab->strings[i].length = 0;
+		strtab->strings[i].parent = strtab;
+		strtab->strings[i].index = i;
+	}
+	return strtab;
+}
+
+void
+FreeStringTable (STRING_TABLE strtab)
+{
+	int i, multiplier = 1;
+
+	if (strtab == NULL)
+	{
+		return;
+	}
+
+	if (strtab->flags & HAS_SOUND_CLIPS)
+	{
+		multiplier++;
+	}
+	if (strtab->flags & HAS_TIMESTAMP)
+	{
+		multiplier++;
+	}
+
+	for (i = 0; i < strtab->size * multiplier; i++)
+	{
+		if (strtab->strings[i].data != NULL)
+		{
+			HFree (strtab->strings[i].data);
+		}
+	}
+
+	HFree (strtab->strings);
+	HFree (strtab);
+}
 
 BOOLEAN
 DestroyStringTable (STRING_TABLE StringTable)
 {
-	return (FreeStringTable (StringTable));
+	FreeStringTable (StringTable);
+	return TRUE;
 }
 
 STRING
 CaptureStringTable (STRING_TABLE StringTable)
 {
-	if (StringTable != 0)
+	if ((StringTable != 0) && (StringTable->size > 0))
 	{
-		COUNT StringTableIndex;
-		STRING_TABLEPTR StringTablePtr;
-
-		LockStringTable (StringTable, &StringTablePtr);
-		StringTableIndex = GetStringTableIndex (StringTable);
-		return (BUILD_STRING (StringTable, StringTableIndex));
+		return StringTable->strings;
 	}
 
-	return ((STRING)NULL_PTR);
+	return NULL;
 }
 
 STRING_TABLE
@@ -46,8 +102,6 @@ ReleaseStringTable (STRING String)
 	STRING_TABLE StringTable;
 
 	StringTable = GetStringTable (String);
-	if (StringTable != 0)
-		UnlockStringTable (StringTable);
 
 	return (StringTable);
 }
@@ -55,53 +109,51 @@ ReleaseStringTable (STRING String)
 STRING_TABLE
 GetStringTable (STRING String)
 {
-	return ((STRING_TABLE)LOWORD (String));
+	if (String && String->parent)
+	{
+		return String->parent;
+	}
+	return NULL;
 }
 
 COUNT
 GetStringTableCount (STRING String)
 {
-	COUNT StringCount;
-	STRING_TABLE StringTable;
-
-	StringTable = GetStringTable (String);
-	if (StringTable == 0)
-		StringCount = 0;
-	else
+	if (String && String->parent)
 	{
-		STRING_TABLEPTR StringTablePtr;
-
-		LockStringTable (StringTable, &StringTablePtr);
-		StringCount = StringTablePtr->StringCount;
-		UnlockStringTable (StringTable);
+		return String->parent->size;
 	}
-
-	return (StringCount);
+	return 0;
 }
 
 COUNT
 GetStringTableIndex (STRING String)
 {
-	return (STRING_INDEX (String));
+	if (String)
+	{
+		return String->index;
+	}
+	return 0;
 }
 
 STRING
 SetAbsStringTableIndex (STRING String, COUNT StringTableIndex)
 {
-	STRING_TABLE StringTable;
+	STRING_TABLE StringTablePtr;
 
-	StringTable = GetStringTable (String);
-	if (StringTable == 0)
-		String = 0;
+	if (!String)
+		return NULL;
+	
+	StringTablePtr = String->parent;
+	
+	if (StringTablePtr == NULL)
+	{
+		String = NULL;
+	}
 	else
 	{
-		STRING_TABLEPTR StringTablePtr;
-
-		LockStringTable (StringTable, &StringTablePtr);
-		StringTableIndex = StringTableIndex % StringTablePtr->StringCount;
-		UnlockStringTable (StringTable);
-
-		String = BUILD_STRING (StringTable, StringTableIndex);
+		StringTableIndex = StringTableIndex % StringTablePtr->size;
+		String = &StringTablePtr->strings[StringTableIndex];
 	}
 
 	return (String);
@@ -110,24 +162,27 @@ SetAbsStringTableIndex (STRING String, C
 STRING
 SetRelStringTableIndex (STRING String, SIZE StringTableOffs)
 {
-	STRING_TABLE StringTable;
+	STRING_TABLE StringTablePtr;
 
-	StringTable = GetStringTable (String);
-	if (StringTable == 0)
-		String = 0;
+	if (!String)
+		return NULL;
+	
+	StringTablePtr = String->parent;
+	
+	if (StringTablePtr == NULL)
+	{
+		String = NULL;
+	}
 	else
 	{
-		STRING_TABLEPTR StringTablePtr;
 		COUNT StringTableIndex;
 
-		LockStringTable (StringTable, &StringTablePtr);
 		while (StringTableOffs < 0)
-			StringTableOffs += StringTablePtr->StringCount;
-		StringTableIndex = (STRING_INDEX (String) + StringTableOffs)
-				% StringTablePtr->StringCount;
-		UnlockStringTable (StringTable);
+			StringTableOffs += StringTablePtr->size;
+		StringTableIndex = (String->index + StringTableOffs)
+				% StringTablePtr->size;
 
-		String = BUILD_STRING (StringTable, StringTableIndex);
+		String = &StringTablePtr->strings[StringTableIndex];
 	}
 
 	return (String);
@@ -136,156 +191,99 @@ SetRelStringTableIndex (STRING String, S
 COUNT
 GetStringLength (STRING String)
 {
-	COUNT StringLength;
-	STRING_TABLE StringTable;
-
-	StringTable = GetStringTable (String);
-	if (StringTable == 0)
-		StringLength = 0;
-	else
+	if (String == NULL)
 	{
-		COUNT StringIndex;
-		STRING_TABLEPTR StringTablePtr;
-
-		StringIndex = STRING_INDEX (String);
-		LockStringTable (StringTable, &StringTablePtr);
-
-		{
-			STRINGPTR start;
-			STRINGPTR end;
-
-			start = (STRINGPTR) ((BYTE *) StringTablePtr +
-					StringTablePtr->StringOffsets[StringIndex]);
-			end = (STRINGPTR) ((BYTE *) StringTablePtr +
-					StringTablePtr->StringOffsets[StringIndex + 1]);
-			StringLength = utf8StringCountN(start, end);
-		}
-
-#if 0
-		StringLength = (COUNT)(
-				StringTablePtr->StringOffsets[StringIndex + 1]
-				- StringTablePtr->StringOffsets[StringIndex]);
-#endif
-		UnlockStringTable (StringTable);
+		return 0;
 	}
-
-	return (StringLength);
+	return utf8StringCountN(String->data, String->data + String->length);
 }
 
 COUNT
 GetStringLengthBin (STRING String)
 {
-	COUNT StringLength;
-	STRING_TABLE StringTable;
-
-	StringTable = GetStringTable (String);
-	if (StringTable == 0)
-		StringLength = 0;
-	else
+	if (String == NULL)
 	{
-		COUNT StringIndex;
-		STRING_TABLEPTR StringTablePtr;
-
-		StringIndex = STRING_INDEX (String);
-		LockStringTable (StringTable, &StringTablePtr);
-
-		StringLength = (COUNT)(
-				StringTablePtr->StringOffsets[StringIndex + 1]
-				- StringTablePtr->StringOffsets[StringIndex]);
-		UnlockStringTable (StringTable);
+		return 0;
 	}
-
-	return (StringLength);
+	return String->length;
 }
 
 STRINGPTR
 GetStringSoundClip (STRING String)
 {
-	STRINGPTR StringAddr;
-	STRING_TABLE StringTable;
+	STRING_TABLE StringTablePtr;
+	COUNT StringIndex;
 
-	StringTable = GetStringTable (String);
-	if (StringTable == 0)
-		StringAddr = 0;
-	else
+	if (String == NULL)
 	{
-		COUNT StringIndex;
-		STRING_TABLEPTR StringTablePtr;
+		return NULL;
+	}
 
-		StringIndex = STRING_INDEX (String);
-		LockStringTable (StringTable, &StringTablePtr);
-		if (!(StringTablePtr->flags & HAS_SOUND_CLIPS)
-				|| ((StringIndex += StringTablePtr->StringCount + 1),
-						StringTablePtr->StringOffsets[StringIndex + 1]
-								== StringTablePtr->StringOffsets[StringIndex]))
-			StringAddr = 0;
-		else
-		{
-			StringAddr = (STRINGPTR) ((BYTE *) StringTablePtr +
-					StringTablePtr->StringOffsets[StringIndex]);
-		}
-		UnlockStringTable (StringTable);
+	StringTablePtr = String->parent;
+	if (StringTablePtr == NULL)
+	{
+		return NULL;
+	}
+
+	StringIndex = String->index;
+	if (!(StringTablePtr->flags & HAS_SOUND_CLIPS))
+	{
+		return NULL;
 	}
 
-	return (StringAddr);
+	StringIndex += StringTablePtr->size;
+	String = &StringTablePtr->strings[StringIndex];
+	if (String->length == 0)
+	{
+		return NULL;
+	}
+
+	return String->data;
 }
 
 STRINGPTR
 GetStringTimeStamp (STRING String)
 {
-	STRINGPTR StringAddr;
-	STRING_TABLE StringTable;
+	STRING_TABLE StringTablePtr;
+	COUNT StringIndex;
+	int offset;
 
-	StringTable = GetStringTable (String);
-	if (StringTable == 0)
-		StringAddr = 0;
-	else
+	if (String == NULL)
 	{
-		COUNT StringIndex;
-		STRING_TABLEPTR StringTablePtr;
-		int offset;
-
-		StringIndex = STRING_INDEX (String);
-		LockStringTable (StringTable, &StringTablePtr);
-		offset = (StringTablePtr->flags & HAS_SOUND_CLIPS) ? 1 : 0;
-		if (!(StringTablePtr->flags & HAS_TIMESTAMP)
-				|| ((StringIndex += (StringTablePtr->StringCount + 1) << offset),
-						StringTablePtr->StringOffsets[StringIndex + 1]
-								== StringTablePtr->StringOffsets[StringIndex]))
-			StringAddr = 0;
-		else
-		{
-			StringAddr = (STRINGPTR) ((BYTE *) StringTablePtr +
-					StringTablePtr->StringOffsets[StringIndex]);
-		}
-		UnlockStringTable (StringTable);
+		return NULL;
+	}
+
+	StringTablePtr = String->parent;
+	if (StringTablePtr == NULL)
+	{
+		return NULL;
+	}
+
+	StringIndex = String->index;
+	if (!(StringTablePtr->flags & HAS_TIMESTAMP))
+	{
+		return NULL;
 	}
 
-	return (StringAddr);
+	offset = (StringTablePtr->flags & HAS_SOUND_CLIPS) ? 1 : 0;
+	StringIndex += StringTablePtr->size << offset;
+	String = &StringTablePtr->strings[StringIndex];
+	if (String->length == 0)
+	{
+		return NULL;
+	}
+
+	return String->data;
 }
 
 STRINGPTR
 GetStringAddress (STRING String)
 {
-	STRINGPTR StringAddr;
-	STRING_TABLE StringTable;
-
-	StringTable = GetStringTable (String);
-	if (StringTable == 0)
-		StringAddr = 0;
-	else
+	if (String == NULL)
 	{
-		COUNT StringIndex;
-		STRING_TABLEPTR StringTablePtr;
-
-		StringIndex = STRING_INDEX (String);
-		LockStringTable (StringTable, &StringTablePtr);
-		StringAddr = (STRINGPTR) ((BYTE *) StringTablePtr +
-				StringTablePtr->StringOffsets[StringIndex]);
-		UnlockStringTable (StringTable);
+		return NULL;
 	}
-
-	return (StringAddr);
+	return String->data;
 }
 
 BOOLEAN
@@ -309,4 +307,3 @@ GetStringContents (STRING String, STRING
 	*StringBuf = '\0';
 	return (FALSE);
 }
-
diff -ruNp src.orig/sc2code/libs/strings/strintrn.h src/sc2code/libs/strings/strintrn.h
--- src.orig/sc2code/libs/strings/strintrn.h	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/strings/strintrn.h	2017-11-08 16:50:00 -0600
@@ -22,31 +22,32 @@
 #include <stdio.h>
 #include <string.h>
 #include "strlib.h"
-#include "memlib.h"
 #include "reslib.h"
 
-typedef struct string_table
+struct string_table_entry
+{
+	STRINGPTR data;
+	int length;  /* Internal NULs are allowed */
+	int index;
+	struct string_table *parent;
+};
+
+struct string_table
 {
-	unsigned short StringCount;
 	unsigned short flags;
-	DWORD StringOffsets[1];
-} STRING_TABLE_DESC;
-typedef STRING_TABLE_DESC *PSTRING_TABLE_DESC;
+	int size;
+	STRING_TABLE_ENTRY_DESC *strings;
+};
 
 #define HAS_SOUND_CLIPS (1 << 0)
 #define HAS_TIMESTAMP (1 << 1)
-#define STRING_TABLEPTR PSTRING_TABLE_DESC
 
-#define AllocStringTable(s) AllocResourceData((s),MEM_SOUND)
-#define LockStringTable(h,ps) LockResourceData((MEM_HANDLE)LOWORD(h),ps)
-#define UnlockStringTable(h) UnlockResourceData ((MEM_HANDLE)LOWORD(h))
-#define FreeStringTable(h) FreeResourceData ((MEM_HANDLE)LOWORD(h))
-
-#define STRING_INDEX(S) ((COUNT)HIWORD (S))
-#define BUILD_STRING(h,i) ((STRING_TABLE)MAKE_DWORD(h,i))
-#define BUILD_STRING_TABLE(h) (STRING_TABLE)(h)
+STRING_TABLE AllocStringTable (int num_entries, int flags);
+void FreeStringTable (STRING_TABLE strtab);
 
-extern MEM_HANDLE _GetStringData (uio_Stream *fp, DWORD length);
+void *_GetStringData (uio_Stream *fp, DWORD length);
+void *_GetBinaryTableData (uio_Stream *fp, DWORD length);
+void _GetConversationData (const char *path, RESOURCE_DATA *resdata);
 
 #endif /* _STRINTRN_H */
 
diff -ruNp src.orig/sc2code/libs/strings/unicode.c src/sc2code/libs/strings/unicode.c
--- src.orig/sc2code/libs/strings/unicode.c	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/strings/unicode.c	2017-11-08 16:50:00 -0600
@@ -28,7 +28,7 @@
 static inline void
 resyncUTF8(const unsigned char **ptr) {
 	while ((**ptr & 0xc0) == 0x80)
-		*ptr++;
+		(*ptr)++;
 }
 
 // Get one character from a UTF-8 encoded string.
diff -ruNp src.orig/sc2code/libs/strlib.h src/sc2code/libs/strlib.h
--- src.orig/sc2code/libs/strlib.h	2017-11-08 16:49:32 -0600
+++ src/sc2code/libs/strlib.h	2017-11-08 16:50:00 -0600
@@ -25,12 +25,18 @@
 
 #include <stddef.h>
 
-typedef DWORD STRING_TABLE;
-typedef DWORD STRING;
-typedef PBYTE STRINGPTR;
+typedef struct string_table_entry STRING_TABLE_ENTRY_DESC;
+typedef struct string_table STRING_TABLE_DESC;
 
-extern BOOLEAN InstallStringTableResType (COUNT string_type);
-extern STRING_TABLE LoadStringTableInstance (DWORD res);
+typedef STRING_TABLE_DESC *STRING_TABLE;
+typedef STRING_TABLE_ENTRY_DESC *STRING;
+typedef BYTE *STRINGPTR;
+
+/* This has to go here because reslib requires the above typedefs. */
+#include "reslib.h"
+
+extern BOOLEAN InstallStringTableResType (void);
+extern STRING_TABLE LoadStringTableInstance (RESOURCE res);
 extern STRING_TABLE LoadStringTableFile (uio_DirHandle *dir,
 		const char *fileName);
 extern BOOLEAN DestroyStringTable (STRING_TABLE StringTable);
diff -ruNp src.orig/sc2code/libs/threadlib.h src/sc2code/libs/threadlib.h
--- src.orig/sc2code/libs/threadlib.h	2017-11-08 16:49:33 -0600
+++ src/sc2code/libs/threadlib.h	2017-11-08 16:50:00 -0600
@@ -20,8 +20,6 @@
 #ifndef _THREADLIB_H
 #define _THREADLIB_H
 
-#define THREADLIB SDL
-
 #define NAMED_SYNCHRO           /* Should synchronizable objects have names? */
 #define TRACK_CONTENTION       /* Should we report when a thread sleeps on synchronize? */
 
diff -ruNp src.orig/sc2code/libs/threads/Makeinfo src/sc2code/libs/threads/Makeinfo
--- src.orig/sc2code/libs/threads/Makeinfo	2017-11-08 16:49:33 -0600
+++ src/sc2code/libs/threads/Makeinfo	2017-11-08 16:50:00 -0600
@@ -1,2 +1,9 @@
-uqm_SUBDIRS="sdl"
+case "$uqm_THREADLIB" in
+	SDL)
+		uqm_SUBDIRS="sdl"
+		;;
+	PTHREAD)
+		uqm_SUBDIRS="pthread"
+		;;
+esac
 uqm_CFILES="thrcommon.c"
diff -ruNp src.orig/sc2code/libs/threads/pthread/Makeinfo src/sc2code/libs/threads/pthread/Makeinfo
--- src.orig/sc2code/libs/threads/pthread/Makeinfo	1969-12-31 18:00:00 -0600
+++ src/sc2code/libs/threads/pthread/Makeinfo	2017-11-08 16:50:00 -0600
@@ -0,0 +1 @@
+uqm_CFILES="posixthreads.c"
diff -ruNp src.orig/sc2code/libs/threads/pthread/posixthreads.c src/sc2code/libs/threads/pthread/posixthreads.c
--- src.orig/sc2code/libs/threads/pthread/posixthreads.c	1969-12-31 18:00:00 -0600
+++ src/sc2code/libs/threads/pthread/posixthreads.c	2017-11-08 16:50:00 -0600
@@ -0,0 +1,671 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <stdlib.h>
+#include "misc.h"
+#include "posixthreads.h"
+#include <pthread.h>
+#include <unistd.h>
+
+#include <semaphore.h>
+
+#include "libs/log/uqmlog.h"
+
+typedef struct _thread {
+	pthread_t native;
+#ifdef NAMED_SYNCHRO
+	const char *name;
+#endif
+	ThreadLocal *localData;
+	struct _thread *next;
+} *TrueThread;
+
+static volatile TrueThread threadQueue = NULL;
+static pthread_mutex_t threadQueueMutex;
+
+struct ThreadStartInfo
+{
+	ThreadFunction func;
+	void *data;
+	sem_t sem;
+	TrueThread thread;
+};
+
+void
+InitThreadSystem_PT (void)
+{
+	pthread_mutex_init (&threadQueueMutex, NULL);
+}
+
+void
+UnInitThreadSystem_PT (void)
+{
+	pthread_mutex_destroy (&threadQueueMutex);
+}
+
+static void
+QueueThread (TrueThread thread)
+{
+	pthread_mutex_lock (&threadQueueMutex);
+	thread->next = threadQueue;
+	threadQueue = thread;
+	pthread_mutex_unlock (&threadQueueMutex);
+}
+
+static void
+UnQueueThread (TrueThread thread)
+{
+	volatile TrueThread *ptr;
+
+	pthread_mutex_lock (&threadQueueMutex);
+	ptr = &threadQueue;
+	while (*ptr != thread)
+	{
+#ifdef DEBUG_THREADS
+		if (*ptr == NULL)
+		{
+			// Should not happen.
+			log_add (log_Debug, "Error: Trying to remove non-present thread "
+					"from thread queue.");
+			fflush (stderr);
+			explode ();
+		}
+#endif  /* DEBUG_THREADS */
+		ptr = &(*ptr)->next;
+	}
+	*ptr = (*ptr)->next;
+	pthread_mutex_unlock (&threadQueueMutex);
+}
+
+static TrueThread
+FindThreadInfo (pthread_t threadID)
+{
+	TrueThread ptr;
+
+	pthread_mutex_lock (&threadQueueMutex);
+	ptr = threadQueue;
+	while (ptr)
+	{
+		if (ptr->native == threadID)
+		{
+			pthread_mutex_unlock (&threadQueueMutex);
+			return ptr;
+		}
+		ptr = ptr->next;
+	}
+	pthread_mutex_unlock (&threadQueueMutex);
+	return NULL;
+}
+
+#ifdef NAMED_SYNCHRO
+static const char *
+MyThreadName (void)
+{
+	TrueThread t = FindThreadInfo (pthread_self());
+	return t ? t->name : "Unknown (probably renderer)";
+}
+#endif
+
+static void *
+ThreadHelper (void *startInfo) {
+	ThreadFunction func;
+	void *data;
+	sem_t *sem;
+	TrueThread thread;
+	int result;
+	
+	//log_add (log_Debug, "ThreadHelper()");
+	
+	func = ((struct ThreadStartInfo *) startInfo)->func;
+	data = ((struct ThreadStartInfo *) startInfo)->data;
+	sem  = &((struct ThreadStartInfo *) startInfo)->sem;
+
+	// Wait until the Thread structure is available.
+	if (sem_wait (sem))
+	{
+		log_add(log_Fatal, "ThreadHelper sem_wait fail");
+		exit(EXIT_FAILURE);
+	}
+	if (sem_destroy (sem))
+	{
+		log_add(log_Fatal, "ThreadHelper sem_destroy fail");
+		exit(EXIT_FAILURE);
+	}
+	
+	thread = ((struct ThreadStartInfo *) startInfo)->thread;
+	HFree (startInfo);
+
+	result = (*func) (data);
+
+#ifdef DEBUG_THREADS
+	log_add (log_Debug, "Thread '%s' done (returned %d).",
+			thread->name, result);
+	fflush (stderr);
+#endif
+
+	UnQueueThread (thread);
+	DestroyThreadLocal (thread->localData);
+	FinishThread (thread);
+	/* Destroying the thread is the responsibility of ProcessThreadLifecycles() */
+	return (void*)result;
+}
+
+void
+DestroyThread_PT (Thread t)
+{
+	HFree (t);
+}	
+
+Thread
+CreateThread_PT (ThreadFunction func, void *data, SDWORD stackSize
+#ifdef NAMED_SYNCHRO
+		  , const char *name
+#endif
+	)
+{
+	TrueThread thread;
+	struct ThreadStartInfo *startInfo;
+	pthread_attr_t attr;
+
+	
+	//log_add (log_Debug, "CreateThread_PT '%s'", name);
+	
+	thread = (struct _thread *) HMalloc (sizeof *thread);
+#ifdef NAMED_SYNCHRO
+	thread->name = name;
+#endif
+
+	thread->localData = CreateThreadLocal ();
+
+	startInfo = (struct ThreadStartInfo *) HMalloc (sizeof (*startInfo));
+	startInfo->func = func;
+	startInfo->data = data;
+	if (sem_init(&startInfo->sem, 0, 0) < 0)
+	{
+		log_add (log_Fatal, "createthread seminit fail");
+		exit(EXIT_FAILURE);
+	}
+	startInfo->thread = thread;
+		
+	pthread_attr_init(&attr);
+ 	if (pthread_attr_setstacksize(&attr, 75000))
+ 	{
+ 		log_add (log_Debug, "pthread stacksize fail");
+ 	}
+	if (pthread_create(&thread->native, &attr, ThreadHelper, (void *)startInfo))
+	{
+		log_add (log_Debug, "pthread create fail");
+		DestroyThreadLocal (thread->localData);
+		HFree (startInfo);
+		HFree (thread);
+		return NULL;
+	}
+	// The responsibility to free 'startInfo' and 'thread' is now by the new
+	// thread.
+	
+	QueueThread (thread);
+
+#ifdef DEBUG_THREADS
+//#if 0	
+	log_add (log_Debug, "Thread '%s' created.", thread->name);
+	fflush (stderr);
+//#endif
+#endif
+
+	// Signal to the new thread that the thread structure is ready
+	// and it can begin to use it.
+	if (sem_post (&startInfo->sem))
+	{
+		log_add(log_Fatal, "CreateThread sem_post fail");
+		exit(EXIT_FAILURE);
+	}
+
+	(void) stackSize;  /* Satisfying compiler (unused parameter) */
+	return thread;
+}
+
+void
+SleepThread_PT (TimeCount sleepTime)
+{
+	usleep (sleepTime * 1000000 / ONE_SECOND);
+}
+
+void
+SleepThreadUntil_PT (TimeCount wakeTime) {
+	TimeCount now;
+
+	now = GetTimeCounter ();
+	if (wakeTime <= now)
+		TaskSwitch_PT ();
+	else
+		usleep ((wakeTime - now) * 1000000 / ONE_SECOND);
+}
+
+void
+TaskSwitch_PT (void) {
+	usleep (1000);
+}
+
+void
+WaitThread_PT (Thread thread, int *status) {
+	//log_add(log_Debug, "WaitThread_PT '%s', status %x", ((TrueThread)thread)->name, status);
+	//pthread_join(((TrueThread)thread)->native, status);
+	pthread_join(((TrueThread)thread)->native, NULL);
+	//log_add(log_Debug, "WaitThread_PT '%s' complete", ((TrueThread)thread)->name);
+}
+
+ThreadLocal *
+GetMyThreadLocal_PT (void)
+{
+	TrueThread t = FindThreadInfo (pthread_self());
+	return t ? t->localData : NULL;
+}
+
+/* These are the pthread implementations of the UQM synchronization objects. */
+
+/* Mutexes. */
+/* TODO.  The w_memlib uses Mutexes right now, so we can't use HMalloc
+ * or HFree. Once that goes, this needs to change. */
+
+typedef struct _mutex {
+	pthread_mutex_t mutex;
+#ifdef TRACK_CONTENTION
+	pthread_t owner;
+#endif
+#ifdef NAMED_SYNCHRO
+	const char *name;
+	DWORD syncClass;
+#endif
+} Mut;
+	
+
+Mutex
+#ifdef NAMED_SYNCHRO
+CreateMutex_PT (const char *name, DWORD syncClass)
+#else
+CreateMutex_PT (void)
+#endif
+{
+	Mut *mutex = malloc (sizeof (Mut));
+	
+	if (mutex != NULL)
+	{
+		pthread_mutexattr_t attr;
+		pthread_mutexattr_init(&attr);
+		pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
+		if (pthread_mutex_init(&mutex->mutex, &attr))
+		{
+#ifdef NAMED_SYNCHRO
+			/* logging depends on Mutexes, so we have to use the
+			 * non-threaded version instead */
+			log_add_nothread (log_Fatal, "Could not initialize mutex '%s':"
+				"aborting.", name);
+#else
+			log_add_nothread (log_Fatal, "Could not initialize mutex:"
+					"aborting.");
+#endif
+			exit (EXIT_FAILURE);			
+		}
+		pthread_mutexattr_destroy(&attr);
+		 
+#ifdef TRACK_CONTENTION
+		mutex->owner = 0;
+#endif
+#ifdef NAMED_SYNCHRO
+		mutex->name = name;
+		mutex->syncClass = syncClass;
+#endif
+	}
+
+	return mutex;
+}
+
+void
+DestroyMutex_PT (Mutex m)
+{
+	Mut *mutex = (Mut *)m;
+	//log_add_nothread(log_Debug, "Destroying mutex '%s'", mutex->name);
+	pthread_mutex_destroy (&mutex->mutex);
+	free (mutex);
+}
+
+void
+LockMutex_PT (Mutex m)
+{
+	Mut *mutex = (Mut *)m;
+#ifdef TRACK_CONTENTION
+	/* This code isn't really quite right; race conditions between
+	 * check and lock remain and can produce reports of contention
+	 * where the thread never sleeps, or fail to report in
+	 * situations where it does.  If tracking with perfect
+	 * accuracy becomes important, the TRACK_CONTENTION mutex will
+	 * need to handle its own wake/sleep cycles with condition
+	 * variables (check the history of this file for the
+	 * CrossThreadMutex code).  This almost-measure is being added
+	 * because for the most part it should suffice. */
+	if (mutex->owner && (mutex->syncClass & TRACK_CONTENTION_CLASSES))
+	{	/* logging depends on Mutexes, so we have to use the
+		 * non-threaded version instead */
+		log_add_nothread (log_Debug, "Thread '%s' blocking on mutex '%s'",
+				MyThreadName (), mutex->name);
+	}
+#endif
+
+	while (pthread_mutex_lock (&mutex->mutex) != 0)
+	{		
+		//log_add_nothread (log_Debug, "Attempt to acquire mutex '%s' failretry", mutex->name);
+		TaskSwitch_PT ();
+	}
+#ifdef TRACK_CONTENTION
+	mutex->owner = pthread_self();
+#endif
+}
+
+void
+UnlockMutex_PT (Mutex m)
+{
+	Mut *mutex = (Mut *)m;
+#ifdef TRACK_CONTENTION
+	mutex->owner = 0;
+#endif
+	while (pthread_mutex_unlock (&mutex->mutex) != 0)
+	{
+		TaskSwitch_PT ();
+	}
+}
+
+/* Semaphores. */
+
+typedef struct _sem {
+	sem_t sem;
+#ifdef NAMED_SYNCHRO
+	const char *name;
+	DWORD syncClass;
+#endif
+} Sem;
+
+Semaphore
+CreateSemaphore_PT (DWORD initial
+#ifdef NAMED_SYNCHRO
+		  , const char *name, DWORD syncClass
+#endif
+	)
+{
+	Sem *sem = (Sem *) HMalloc (sizeof (struct _sem));
+#ifdef NAMED_SYNCHRO
+	sem->name = name;
+	sem->syncClass = syncClass;
+#endif
+	
+	//log_add (log_Debug, "Creating semaphore '%s'", sem->name);
+	
+	if (sem_init(&sem->sem, 0, initial) < 0)
+	{
+#ifdef NAMED_SYNCHRO
+		log_add (log_Fatal, "Could not initialize semaphore '%s':"
+				" aborting.", name);
+#else
+		log_add (log_Fatal, "Could not initialize semaphore:"
+				" aborting.");
+#endif
+		exit (EXIT_FAILURE);
+	}
+	//log_add (log_Debug, "Creating semaphore '%s' success", sem->name);
+	return sem;
+}
+
+void
+DestroySemaphore_PT (Semaphore s)
+{
+	Sem *sem = (Sem *)s;
+	//log_add (log_Debug, "Destroying semaphore '%s'", sem->name);
+	if (sem_destroy (&sem->sem))
+	{
+		log_add (log_Debug, "Destroying semaphore '%s' failed", sem->name);
+	}
+	HFree (sem);
+}
+
+void
+SetSemaphore_PT (Semaphore s)
+{
+	Sem *sem = (Sem *)s;
+#ifdef TRACK_CONTENTION
+	int contention = 0;
+	sem_getvalue(&sem->sem, &contention);
+	contention = !contention;
+	if (contention && (sem->syncClass & TRACK_CONTENTION_CLASSES))
+	{
+		log_add (log_Debug, "Thread '%s' blocking on semaphore '%s'",
+				MyThreadName (), sem->name);
+	}
+#endif
+	//log_add (log_Debug, "Attempt to set semaphore '%s'", sem->name);
+	while (sem_wait (&sem->sem) == -1)
+	{
+		//log_add (log_Debug, "Attempt to set semaphore '%s' failretry", sem->name);
+		TaskSwitch_PT ();
+	}
+	//log_add (log_Debug, "Attempt to set semaphore '%s' success", sem->name);
+#ifdef TRACK_CONTENTION
+	if (contention && (sem->syncClass & TRACK_CONTENTION_CLASSES))
+	{
+		log_add (log_Debug, "Thread '%s' awakens,"
+				" released from semaphore '%s'", MyThreadName (), sem->name);
+	}
+#endif
+}
+
+void
+ClearSemaphore_PT (Semaphore s)
+{
+	Sem *sem = (Sem *)s;
+	//log_add (log_Debug, "Attempt to clear semaphore '%s' %x", sem->name, sem);
+	while (sem_post (&sem->sem) == -1)
+	{
+		//log_add (log_Debug, "Attempt to clear semaphore %x failretry", sem);
+		TaskSwitch_PT ();
+	}
+	//log_add (log_Debug, "Attempt to clear semaphore %x success", sem);
+}
+
+/* Recursive mutexes. Adapted from mixSDL code, which was adapted from
+   the original DCQ code. */
+
+typedef struct _recm {
+	pthread_mutex_t mutex;
+	pthread_t thread_id;
+	unsigned int locks;
+#ifdef NAMED_SYNCHRO
+	const char *name;
+	DWORD syncClass;
+#endif
+} RecM;
+
+RecursiveMutex
+#ifdef NAMED_SYNCHRO
+CreateRecursiveMutex_PT (const char *name, DWORD syncClass)
+#else
+CreateRecursiveMutex_PT (void)
+#endif
+{
+	RecM *mtx = (RecM *) HMalloc (sizeof (struct _recm));
+
+	mtx->thread_id = 0;
+	if (pthread_mutex_init(&mtx->mutex, NULL))
+	{
+#ifdef NAMED_SYNCHRO
+		log_add (log_Fatal, "Could not initialize recursive "
+				"mutex '%s': aborting.", name);
+#else
+		log_add (log_Fatal, "Could not initialize recursive "
+				"mutex: aborting.");
+#endif
+		exit (EXIT_FAILURE);
+	}
+#ifdef NAMED_SYNCHRO
+	mtx->name = name;
+	mtx->syncClass = syncClass;
+#endif
+	mtx->locks = 0;
+	return (RecursiveMutex) mtx;
+}
+
+void
+DestroyRecursiveMutex_PT (RecursiveMutex val)
+{
+	RecM *mtx = (RecM *)val;
+	pthread_mutex_destroy(&mtx->mutex);
+	HFree (mtx);
+}
+
+void
+LockRecursiveMutex_PT (RecursiveMutex val)
+{
+	RecM *mtx = (RecM *)val;
+	pthread_t thread_id = pthread_self();
+	if (!mtx->locks || mtx->thread_id != thread_id)
+	{
+#ifdef TRACK_CONTENTION
+		if (mtx->thread_id && (mtx->syncClass & TRACK_CONTENTION_CLASSES))
+		{
+			log_add (log_Debug, "Thread '%s' blocking on '%s'",
+					MyThreadName (), mtx->name);
+		}
+#endif
+		while (pthread_mutex_lock (&mtx->mutex))
+			TaskSwitch_PT ();
+		mtx->thread_id = thread_id;
+	}
+	mtx->locks++;
+}
+
+void
+UnlockRecursiveMutex_PT (RecursiveMutex val)
+{
+	RecM *mtx = (RecM *)val;
+	pthread_t thread_id = pthread_self();
+	if (!mtx->locks || mtx->thread_id != thread_id)
+	{
+#ifdef NAMED_SYNCHRO
+		log_add (log_Debug, "'%s' attempted to unlock %s when it "
+				"didn't hold it", MyThreadName (), mtx->name);
+#endif
+	}
+	else
+	{
+		mtx->locks--;
+		if (!mtx->locks)
+		{
+			mtx->thread_id = 0;
+			pthread_mutex_unlock (&mtx->mutex);
+		}
+	}
+}
+
+int
+GetRecursiveMutexDepth_PT (RecursiveMutex val)
+{
+	RecM *mtx = (RecM *)val;
+	return mtx->locks;
+}
+
+typedef struct _cond {
+	pthread_cond_t cond;
+	pthread_mutex_t mutex;
+#ifdef NAMED_SYNCHRO
+	const char *name;
+	DWORD syncClass;
+#endif
+} cvar;
+
+CondVar
+#ifdef NAMED_SYNCHRO
+CreateCondVar_PT (const char *name, DWORD syncClass)
+#else
+CreateCondVar_PT (void)
+#endif
+{
+	int err1, err2;
+	cvar *cv = (cvar *) HMalloc (sizeof (cvar));
+	err1 = pthread_cond_init(&cv->cond, NULL);
+	err2 = pthread_mutex_init(&cv->mutex, NULL);
+	if (err1 || err2)
+	{
+#ifdef NAMED_SYNCHRO
+		log_add (log_Fatal, "Could not initialize condition variable '%s':"
+				" aborting.", name);
+#else
+		log_add (log_Fatal, "Could not initialize condition variable:"
+				" aborting.");
+#endif
+		exit (EXIT_FAILURE);
+	}
+#ifdef NAMED_SYNCHRO
+	cv->name = name;
+	cv->syncClass = syncClass;
+#endif
+	return cv;
+}
+
+void
+DestroyCondVar_PT (CondVar c)
+{
+	cvar *cv = (cvar *) c;
+	pthread_cond_destroy(&cv->cond);
+	pthread_mutex_destroy(&cv->mutex);
+	HFree (cv);
+}
+
+void
+WaitCondVar_PT (CondVar c)
+{
+	cvar *cv = (cvar *) c;
+	pthread_mutex_lock (&cv->mutex);
+#ifdef TRACK_CONTENTION
+	if (cv->syncClass & TRACK_CONTENTION_CLASSES)
+	{
+		log_add (log_Debug, "Thread '%s' waiting for signal from '%s'",
+				MyThreadName (), cv->name);
+	}
+#endif
+	while (pthread_cond_wait (&cv->cond, &cv->mutex) != 0)
+	{
+		TaskSwitch_PT ();
+	}
+#ifdef TRACK_CONTENTION
+	if (cv->syncClass & TRACK_CONTENTION_CLASSES)
+	{
+		log_add (log_Debug, "Thread '%s' received signal from '%s',"
+				" awakening.", MyThreadName (), cv->name);
+	}
+#endif
+	pthread_mutex_unlock (&cv->mutex);
+}
+
+void
+SignalCondVar_PT (CondVar c)
+{
+	cvar *cv = (cvar *) c;
+	pthread_cond_signal(&cv->cond);
+}
+
+void
+BroadcastCondVar_PT (CondVar c)
+{
+	cvar *cv = (cvar *) c;
+	pthread_cond_broadcast(&cv->cond);
+}
diff -ruNp src.orig/sc2code/libs/threads/pthread/posixthreads.h src/sc2code/libs/threads/pthread/posixthreads.h
--- src.orig/sc2code/libs/threads/pthread/posixthreads.h	1969-12-31 18:00:00 -0600
+++ src/sc2code/libs/threads/pthread/posixthreads.h	2017-11-08 16:50:00 -0600
@@ -0,0 +1,103 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _UQMPTHREADS_H
+#define _UQMPTHREADS_H
+
+#include "port.h"
+#include "libs/threadlib.h"
+
+void InitThreadSystem_PT (void);
+void UnInitThreadSystem_PT (void);
+
+#ifdef NAMED_SYNCHRO
+/* Prototypes with the "name" field */
+Thread CreateThread_PT (ThreadFunction func, void *data, SDWORD stackSize, const char *name);
+Mutex CreateMutex_PT (const char *name, DWORD syncClass);
+Semaphore CreateSemaphore_PT (DWORD initial, const char *name, DWORD syncClass);
+RecursiveMutex CreateRecursiveMutex_PT (const char *name, DWORD syncClass);
+CondVar CreateCondVar_PT (const char *name, DWORD syncClass);
+#else
+/* Prototypes without the "name" field. */
+Thread CreateThread_PT (ThreadFunction func, void *data, SDWORD stackSize);
+Mutex CreateMutex_PT (void);
+Semaphore CreateSemaphore_PT (DWORD initial);
+RecursiveMutex CreateRecursiveMutex_PT (void);
+CondVar CreateCondVar_PT (void);
+#endif
+
+ThreadLocal *GetMyThreadLocal_PT (void);
+
+void SleepThread_PT (TimeCount sleepTime);
+void SleepThreadUntil_PT (TimeCount wakeTime);
+void TaskSwitch_PT (void);
+void WaitThread_PT (Thread thread, int *status);
+void DestroyThread_PT (Thread thread);
+
+void DestroyMutex_PT (Mutex m);
+void LockMutex_PT (Mutex m);
+void UnlockMutex_PT (Mutex m);
+
+void DestroySemaphore_PT (Semaphore sem);
+void SetSemaphore_PT (Semaphore sem);
+void ClearSemaphore_PT (Semaphore sem);
+
+void DestroyCondVar_PT (CondVar c);
+void WaitCondVar_PT (CondVar c);
+void SignalCondVar_PT (CondVar c);
+void BroadcastCondVar_PT (CondVar c);
+
+void DestroyRecursiveMutex_PT (RecursiveMutex m);
+void LockRecursiveMutex_PT (RecursiveMutex m);
+void UnlockRecursiveMutex_PT (RecursiveMutex m);
+int  GetRecursiveMutexDepth_PT (RecursiveMutex m);
+
+#define NativeInitThreadSystem InitThreadSystem_PT
+#define NativeUnInitThreadSystem UnInitThreadSystem_PT
+
+#define NativeGetMyThreadLocal GetMyThreadLocal_PT
+
+#define NativeCreateThread CreateThread_PT
+#define NativeSleepThread SleepThread_PT
+#define NativeSleepThreadUntil SleepThreadUntil_PT
+#define NativeTaskSwitch TaskSwitch_PT
+#define NativeWaitThread WaitThread_PT
+#define NativeDestroyThread DestroyThread_PT
+
+#define NativeCreateMutex CreateMutex_PT
+#define NativeDestroyMutex DestroyMutex_PT
+#define NativeLockMutex LockMutex_PT
+#define NativeUnlockMutex UnlockMutex_PT
+
+#define NativeCreateSemaphore CreateSemaphore_PT
+#define NativeDestroySemaphore DestroySemaphore_PT
+#define NativeSetSemaphore SetSemaphore_PT
+#define NativeClearSemaphore ClearSemaphore_PT
+
+#define NativeCreateCondVar CreateCondVar_PT
+#define NativeDestroyCondVar DestroyCondVar_PT
+#define NativeWaitCondVar WaitCondVar_PT
+#define NativeSignalCondVar SignalCondVar_PT
+#define NativeBroadcastCondVar BroadcastCondVar_PT
+
+#define NativeCreateRecursiveMutex CreateRecursiveMutex_PT
+#define NativeDestroyRecursiveMutex DestroyRecursiveMutex_PT
+#define NativeLockRecursiveMutex LockRecursiveMutex_PT
+#define NativeUnlockRecursiveMutex UnlockRecursiveMutex_PT
+#define NativeGetRecursiveMutexDepth GetRecursiveMutexDepth_PT
+
+#endif  /* _PTTHREAD_H */
+
diff -ruNp src.orig/sc2code/libs/threads/sdl/sdlthreads.c src/sc2code/libs/threads/sdl/sdlthreads.c
--- src.orig/sc2code/libs/threads/sdl/sdlthreads.c	2017-11-08 16:49:33 -0600
+++ src/sc2code/libs/threads/sdl/sdlthreads.c	2017-11-08 16:50:00 -0600
@@ -14,9 +14,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* By Serge van den Boom
- */
-
 #include <stdlib.h>
 #include "misc.h"
 #include "sdlthreads.h"
@@ -144,8 +141,8 @@ UnQueueThread (TrueThread thread)
 {
 	volatile TrueThread *ptr;
 
-	ptr = &threadQueue;
 	SDL_mutexP (threadQueueMutex);
+	ptr = &threadQueue;
 	while (*ptr != thread)
 	{
 #ifdef DEBUG_THREADS
@@ -169,8 +166,8 @@ FindThreadInfo (Uint32 threadID)
 {
 	TrueThread ptr;
 
-	ptr = threadQueue;
 	SDL_mutexP (threadQueueMutex);
+	ptr = threadQueue;
 	while (ptr)
 	{
 		if (SDL_GetThreadID (ptr->native) == threadID)
diff -ruNp src.orig/sc2code/libs/threads/sdl/sdlthreads.h src/sc2code/libs/threads/sdl/sdlthreads.h
--- src.orig/sc2code/libs/threads/sdl/sdlthreads.h	2017-11-08 16:49:33 -0600
+++ src/sc2code/libs/threads/sdl/sdlthreads.h	2017-11-08 16:50:00 -0600
@@ -14,9 +14,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* By Serge van den Boom, 2002-09-12
- */
-
 #ifndef _SDLTHREAD_H
 #define _SDLTHREAD_H
 
diff -ruNp src.orig/sc2code/libs/threads/thrcommon.c src/sc2code/libs/threads/thrcommon.c
--- src.orig/sc2code/libs/threads/thrcommon.c	2017-11-08 16:49:33 -0600
+++ src/sc2code/libs/threads/thrcommon.c	2017-11-08 16:50:00 -0600
@@ -14,9 +14,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* By Serge van den Boom, 2002-09-12
- */
-
 #include <stdio.h>
 #include <stdlib.h>
 #include "libs/threadlib.h"
diff -ruNp src.orig/sc2code/libs/threads/thrcommon.h src/sc2code/libs/threads/thrcommon.h
--- src.orig/sc2code/libs/threads/thrcommon.h	2017-11-08 16:49:33 -0600
+++ src/sc2code/libs/threads/thrcommon.h	2017-11-08 16:50:00 -0600
@@ -14,16 +14,15 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* By Serge van den Boom, 2002-09-12
- */
-
 #ifndef _THRCOMMON_H
 #define _THRCOMMON_H
 
 
-#if THREADLIB == SDL
-#include "sdl/sdlthreads.h"
-#endif  /* THREADLIB == SDL */
+#if defined(THREADLIB_SDL)
+#	include "sdl/sdlthreads.h"
+#elif defined(THREADLIB_PTHREAD)
+#	include "pthread/posixthreads.h"
+#endif  /* defined(THREADLIB_PTHREAD) */
 
 
 #endif  /* _THR_COMMON_H */
diff -ruNp src.orig/sc2code/libs/uio/debug.c src/sc2code/libs/uio/debug.c
--- src.orig/sc2code/libs/uio/debug.c	2017-11-08 16:49:33 -0600
+++ src/sc2code/libs/uio/debug.c	2017-11-08 16:50:00 -0600
@@ -25,7 +25,7 @@
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <time.h>
-#ifdef __unix__
+#if defined(__unix__) && !defined(_WIN32_WCE)
 #	include <sys/wait.h>
 #endif
 
@@ -496,7 +496,7 @@ debugCmdExec(DebugContext *debugContext,
 		fprintf(debugContext->err, " %s", newArgs[i]);
 	fprintf(debugContext->err, "\n");
 
-#ifdef __unix__
+#if defined(__unix__) && !defined(_WIN32_WCE)
 	{
 		pid_t pid;
 		
@@ -667,6 +667,7 @@ listOneDir(DebugContext *debugContext, c
 	int i;
 	const char *pattern;
 	const char *cpath;
+	char *buf = NULL;
 
 	if (arg[0] == '\0') {
 		cpath = arg;
@@ -674,21 +675,21 @@ listOneDir(DebugContext *debugContext, c
 	} else {
 		pattern = strrchr(arg, '/');
 		if (pattern == NULL) {
+			// No directory component in 'arg'.
 			cpath = "";
 			pattern = arg;
 		} else if (pattern[1] == '\0') {
-			// argument ends on /
+			// 'arg' ends on /
 			cpath = arg;
 			pattern = "*";
 		} else {
 			if (pattern == arg) {
 				cpath = "/";
 			} else {
-				char *path;
-				path = uio_alloca(pattern - arg + 1);
-				memcpy(path, arg, pattern - arg);
-				path[pattern - arg] = '\0';
-				cpath = path;
+				buf = uio_malloc(pattern - arg + 1);
+				memcpy(buf, arg, pattern - arg);
+				buf[pattern - arg] = '\0';
+				cpath = buf;
 			}
 			pattern++;
 		}
@@ -708,11 +709,15 @@ listOneDir(DebugContext *debugContext, c
 	if (dirList == NULL) {
 		fprintf(debugContext->out, "Error in uio_getDirList(): %s.\n",
 				strerror(errno));
+		if (buf != NULL)
+			uio_free(buf);
 		return 1;
 	}
 	for (i = 0; i < dirList->numNames; i++)
 		fprintf(debugContext->out, "%s\n", dirList->names[i]);
 	uio_DirList_free(dirList);
+	if (buf != NULL)
+		uio_free(buf);
 	return 0;
 }
 
diff -ruNp src.orig/sc2code/libs/uio/doc/todo src/sc2code/libs/uio/doc/todo
--- src.orig/sc2code/libs/uio/doc/todo	2017-11-08 16:49:33 -0600
+++ src/sc2code/libs/uio/doc/todo	2017-11-08 16:50:00 -0600
@@ -4,6 +4,7 @@ Needed for use in UQM:
 - when doing uio_getStdioPhysical(), if write access is required, but
   not available on the original location, also copy the file to the
   temporary dir.
+- Call fsync() at appropriate times.
 
 Documentation:
 - use doxygen
@@ -31,6 +32,9 @@ Documentation:
   in the directory. "/a/../b" will always be functionally equivalent to
   "/b", even when "/a" is a symlink.
 
+Testing:
+- Test mounting an UNC directory
+
 Bugs:
 - 'openDir(repository, "dir/")' will have the trailing '/'
   in the dirHandle, which will cause problems.
@@ -79,6 +83,8 @@ Extra features (not necessary for UQM):
   (the system rename() doesn't work cross-fs either, so keeping uio_rename()
   as it is makes sense, as I'm trying to stay close to the system functions,
   even though hiding file systems from the user would be nicer)
+- Add a readdir_r(). Right now, for Symbian readdir_r() is defined in
+  uioport.h, but the actual implementation is out of the uio tree.
 
 Optimisations (not necessary for UQM):
 - use mmap for fileBlocks
@@ -127,6 +133,9 @@ Cleanups (not necessary for UQM):
   uio_PRoot_unref etc
 - Add uio_fatal(), uio_error(), uio_warning()
 - Clean up the include structure
+- use stdint.h and stdbool.h types directly, instead of using uio_int16 etc.
+  Remove types.h, and instead, if these types are missing on some platforms,
+  put the fixes in port.h.
 
 
 
diff -ruNp src.orig/sc2code/libs/uio/fileblock.c src/sc2code/libs/uio/fileblock.c
--- src.orig/sc2code/libs/uio/fileblock.c	2017-11-08 16:49:33 -0600
+++ src/sc2code/libs/uio/fileblock.c	2017-11-08 16:50:00 -0600
@@ -18,6 +18,8 @@
  *
  */
 
+#define uio_INTERNAL_FILEBLOCK
+
 #include "iointrn.h"
 #include "fileblock.h"
 #include "uioport.h"
@@ -25,10 +27,41 @@
 #include <errno.h>
 
 static uio_FileBlock *uio_FileBlock_new(uio_Handle *handle, int flags,
-		off_t offset, size_t blockSize, char *buffer, size_t bufSize);
+		off_t offset, size_t blockSize, char *buffer, size_t bufSize,
+		off_t bufOffset, size_t bufFill, size_t readAheadBufSize);
 static inline uio_FileBlock *uio_FileBlock_alloc(void);
 static void uio_FileBlock_free(uio_FileBlock *block);
 
+// caller should uio_Handle_ref(handle) (unless it doesn't need it's own
+// reference anymore).
+static uio_FileBlock *
+uio_FileBlock_new(uio_Handle *handle, int flags, off_t offset,
+		size_t blockSize, char *buffer, size_t bufSize, off_t bufOffset,
+		size_t bufFill, size_t readAheadBufSize) {
+	uio_FileBlock *result;
+	
+	result = uio_FileBlock_alloc();
+	result->handle = handle;
+	result->flags = flags;
+	result->offset = offset;
+	result->blockSize = blockSize;
+	result->buffer = buffer;
+	result->bufSize = bufSize;
+	result->bufOffset = bufOffset;
+	result->bufFill = bufFill;
+	result->readAheadBufSize = readAheadBufSize;
+	return result;
+}
+
+static inline uio_FileBlock *
+uio_FileBlock_alloc(void) {
+	return uio_malloc(sizeof (uio_FileBlock));
+}
+
+static inline void
+uio_FileBlock_free(uio_FileBlock *block) {
+	uio_free(block);
+}
 
 uio_FileBlock *
 uio_openFileBlock(uio_Handle *handle) {
@@ -44,7 +77,7 @@ uio_openFileBlock(uio_Handle *handle) {
 		return NULL;
 	}
 	uio_Handle_ref(handle);
-	return uio_FileBlock_new(handle, 0, 0, statBuf.st_size, NULL, 0);
+	return uio_FileBlock_new(handle, 0, 0, statBuf.st_size, NULL, 0, 0, 0, 0);
 }
 
 uio_FileBlock *
@@ -58,52 +91,151 @@ uio_openFileBlock2(uio_Handle *handle, o
 		// errno is set
 		return NULL;
 	}
-	if (statBuf.st_size > 
+	if (statBuf.st_size > offset || (statBuf.st_size - offset > size)) {
+		// NOT: 'if (statBuf.st_size > offset + size)', to protect
+		// against overflow.
+
+	}
 #endif
 	uio_Handle_ref(handle);
-	return uio_FileBlock_new(handle, 0, offset, size, NULL, 0);
+	return uio_FileBlock_new(handle, 0, offset, size, NULL, 0, 0, 0, 0);
+}
+
+static inline ssize_t
+uio_accessFileBlockMmap(uio_FileBlock *block, off_t offset, size_t length,
+		char **buffer) {
+	// TODO
+	errno = ENOSYS;
+	(void) block;
+	(void) offset;
+	(void) length;
+	(void) buffer;
+	return -1;
+}
+
+static inline ssize_t
+uio_accessFileBlockNoMmap(uio_FileBlock *block, off_t offset, size_t length,
+		char **buffer) {
+	ssize_t numRead;
+	off_t start;
+	off_t end;
+	size_t bufSize;
+	char *oldBuffer;
+	//size_t oldBufSize;
+
+	// Don't go beyond the end of the block.
+	if (offset > (off_t) block->blockSize) {
+		*buffer = block->buffer;
+		return 0;
+	}
+	if (length > block->blockSize - offset)
+		length = block->blockSize - offset;
+
+	if (block->buffer != NULL) {
+		// Check whether the requested data is already in the buffer.
+		if (offset >= block->bufOffset &&
+				(offset - block->bufOffset) + length < block->bufFill) {
+			*buffer = block->buffer + (offset - block->bufOffset);
+			return length;
+		}
+	}
+
+	if (length < block->readAheadBufSize &&
+			(block->flags & uio_FB_USAGE_MASK) != 0) {
+		// We can buffer more data.
+		switch (block->flags & uio_FB_USAGE_MASK) {
+			case uio_FB_USAGE_FORWARD:
+				// Read extra data after the requested data.
+				start = offset;
+				end = (block->readAheadBufSize > block->blockSize - offset) ?
+						block->blockSize : offset + block->readAheadBufSize;
+				break;
+			case uio_FB_USAGE_BACKWARD:
+				// Read extra data before the requested data.
+				end = offset + length;
+				start = (end <= (off_t) block->blockSize) ?
+						0 : end - block->bufSize;
+				break;
+			case uio_FB_USAGE_FORWARD | uio_FB_USAGE_BACKWARD: {
+				// Read extra data both before and after the requested data.
+				off_t extraBefore = (block->readAheadBufSize - length) / 2;
+				start = (offset < extraBefore) ? 0 : offset - extraBefore;
+
+				end = (block->readAheadBufSize > block->blockSize - start) ?
+						block->blockSize : start + block->readAheadBufSize;
+				break;
+			}
+		}
+	} else {
+		start = offset;
+		end = offset + length;
+	}
+	bufSize = (length > block->readAheadBufSize) ?
+			length : block->readAheadBufSize;
+
+	// Start contains the start index in the block of the data we're going
+	// to read.
+	// End contains the end index.
+	// bufSize contains the size of the buffer. bufSize >= end - start.
+
+	oldBuffer = block->buffer;
+	//oldBufSize = block->bufSize;
+	if (block->buffer != NULL || block->bufSize != bufSize) {
+		// We don't have a buffer, or we have one, but of the wrong size.
+		block->buffer = uio_malloc(bufSize);
+		block->bufSize = bufSize;
+	}
+
+	if (oldBuffer != NULL) {
+		// TODO: If we have part of the data still in the old buffer, we
+		// can keep that.
+		// memmove(...)
+
+		if (oldBuffer != block->buffer)
+			uio_free(oldBuffer);
+	}
+	block->bufFill = 0;
+	block->bufOffset = start;
+
+	// TODO: lock handle
+	if (uio_lseek(block->handle, block->offset + start, SEEK_SET) ==
+			(off_t) -1) {
+		// errno is set
+		return -1;
+	}
+	
+	numRead = uio_read(block->handle, block->buffer, end - start);
+	if (numRead == -1) {
+		// errno is set
+		// TODO: unlock handle
+		return -1;
+	}
+	// TODO: unlock handle
+
+	block->bufFill = numRead;
+	*buffer = block->buffer + (offset - block->bufOffset);
+	if (numRead <= (offset - block->bufOffset))
+		return 0;
+	if ((size_t) numRead >= length)
+		return length;
+	return numRead - offset;
 }
 
 // block remains usable until the next call to uio_accessFileBlock
 // with the same block as argument, or until uio_closeFileBlock with
 // that block as argument.
+// The 'offset' parameter is wrt. the start of the block.
+// Requesting access to data beyond the file block is not an error. The
+// FileBlock is meant to be used as a replacement of seek() and read(), and
+// as with those functions, trying to go beyond the end of a file just
+// goes to the end. The return value is the number of bytes in the buffer.
 ssize_t
 uio_accessFileBlock(uio_FileBlock *block, off_t offset, size_t length,
 		char **buffer) {
 	if (block->flags & uio_FB_USE_MMAP) {
-		// TODO
-		errno = ENOSYS;
-		return -1;
+		return uio_accessFileBlockMmap(block, offset, length, buffer);
 	} else {
-		// TODO: add read-ahead buffering
-		ssize_t numRead;
-	
-		if (length > block->blockSize - offset)
-			length = block->blockSize - offset;
-
-		if (block->buffer != NULL && length != block->bufSize) {
-			uio_free(block->buffer);
-			block->buffer = NULL;
-		}
-		if (block->buffer == NULL)
-			block->buffer = uio_malloc(length);
-
-		// TODO: lock handle
-		if (uio_lseek(block->handle, block->offset + offset, SEEK_SET) ==
-				(off_t) -1) {
-			// errno is set
-			return -1;
-		}
-		
-		numRead = uio_read(block->handle, block->buffer, length);
-		if (numRead == -1) {
-			// errno is set
-			// TODO: unlock handle
-			return -1;
-		}
-		// TODO: unlock handle
-		*buffer = block->buffer;
-		return numRead;
+		return uio_accessFileBlockNoMmap(block, offset, length, buffer);
 	}
 }
 
@@ -115,10 +247,31 @@ uio_copyFileBlock(uio_FileBlock *block,
 		errno = ENOSYS;
 		return -1;
 	} else {
-		ssize_t numRead;
+		ssize_t numCopied = 0;
+		ssize_t readResult;
 
+		// Don't go beyond the end of the block.
+		if (offset > (off_t) block->blockSize)
+			return 0;
 		if (length > block->blockSize - offset)
 			length = block->blockSize - offset;
+		
+		// Check whether (part of) the requested data is already in our
+		// own buffer.
+		if (block->buffer != NULL && offset >= block->bufOffset
+				&& offset < block->bufOffset + (off_t) block->bufFill) {
+			size_t toCopy = block->bufFill - offset;
+			if (toCopy > length)
+				toCopy = length;
+			memcpy(buffer, block->buffer + (offset - block->bufOffset),
+					toCopy);
+			numCopied += toCopy;
+			length -= toCopy;
+			if (length == 0)
+				return numCopied;
+			buffer += toCopy;
+			offset += toCopy;
+		}
 
 		// TODO: lock handle
 		if (uio_lseek(block->handle, block->offset + offset, SEEK_SET) ==
@@ -127,14 +280,15 @@ uio_copyFileBlock(uio_FileBlock *block,
 			return -1;
 		}
 		
-		numRead = uio_read(block->handle, buffer, length);
-		if (numRead == -1) {
+		readResult = uio_read(block->handle, buffer, length);
+		// TODO: unlock handle
+		if (readResult == -1) {
 			// errno is set
-			// TODO: unlock handle
 			return -1;
 		}
-		// TODO: unlock handle
-		return numRead;
+		numCopied += readResult;
+
+		return numCopied;
 	}
 }
 
@@ -154,31 +308,25 @@ uio_closeFileBlock(uio_FileBlock *block)
 	return 0;
 }
 
-// caller should uio_Handle_ref(handle) (unless it doesn't need it's own
-// reference anymore).
-static uio_FileBlock *
-uio_FileBlock_new(uio_Handle *handle, int flags, off_t offset,
-		size_t blockSize, char *buffer, size_t bufSize) {
-	uio_FileBlock *result;
-	
-	result = uio_FileBlock_alloc();
-	result->handle = handle;
-	result->flags = flags;
-	result->offset = offset;
-	result->blockSize = blockSize;
-	result->buffer = buffer;
-	result->bufSize = bufSize;
-	return result;
-}
-
-static inline uio_FileBlock *
-uio_FileBlock_alloc(void) {
-	return uio_malloc(sizeof (uio_FileBlock));
+// Usage is the or'ed value of zero or more of uio_FB_USAGE_FORWARD,
+// and uio_FB_USAGE_BACKWARD.
+void
+uio_setFileBlockUsageHint(uio_FileBlock *block, int usage,
+		size_t readAheadBufSize) {
+	block->flags = (block->flags & ~uio_FB_USAGE_MASK) |
+			(usage & uio_FB_USAGE_MASK);
+	block->readAheadBufSize = readAheadBufSize;
 }
 
-static void
-uio_FileBlock_free(uio_FileBlock *block) {
-	uio_free(block);
+// Call if you want the memory used by the fileblock to be released, but
+// still want to use the fileblock later. If you don't need the fileblock,
+// call uio_closeFileBlock() instead.
+void
+uio_clearFileBlockBuffers(uio_FileBlock *block) {
+	if (block->buffer != NULL) {
+		uio_free(block->buffer);
+		block->buffer = NULL;
+	}
 }
 
 
diff -ruNp src.orig/sc2code/libs/uio/fileblock.h src/sc2code/libs/uio/fileblock.h
--- src.orig/sc2code/libs/uio/fileblock.h	2017-11-08 16:49:33 -0600
+++ src/sc2code/libs/uio/fileblock.h	2017-11-08 16:50:00 -0600
@@ -21,22 +21,54 @@
 #ifndef _FILEBLOCK_H
 #define _FILEBLOCK_H
 
+typedef struct uio_FileBlock uio_FileBlock;
+
 #include "io.h"
 #include "uioport.h"
 
 #include <sys/types.h>
 
-typedef struct uio_FileBlock {
+#define uio_FB_USAGE_FORWARD  1
+#define uio_FB_USAGE_BACKWARD 2
+#define uio_FB_USAGE_MASK  (uio_FB_USAGE_FORWARD | uio_FB_USAGE_BACKWARD)
+
+#ifdef uio_INTERNAL_FILEBLOCK
+
+// A fileblock represents a contiguous block of data from a file.
+// It's purpose is to avoid needless copying of data, while enabling
+// buffering.
+
+struct uio_FileBlock {
 	uio_Handle *handle;
 	int flags;
-#define uio_FB_USE_MMAP 1
+			// See above for uio_FB_USAGE_FORWARD, uio_FB_USAGE_BACKWARD.
+#define uio_FB_USE_MMAP       4
 	off_t offset;
 			// Offset to the start of the block in the file.
 	size_t blockSize;
+			// Size of the block of data represented by this FileBlock.
 	char *buffer;
 			// either allocated buffer, or buffer to mmap'ed area.
 	size_t bufSize;
-} uio_FileBlock;
+			// Size of the buffer.
+	off_t bufOffset;
+			// Offset of the start of the buffer into the block.
+	size_t bufFill;
+			// Part of 'buffer' which is in use.
+	size_t readAheadBufSize;
+			// Try to read up to this many bytes at a time, even when less
+			// is immediately needed.
+};
+// INV: The FileBlock represents 'fileData[offset..(offset + blockSize - 1)]'
+// where 'fileData' is the contents of the file.
+// INV: If buf != NULL then:
+//     bufFill <= bufSize
+//     bufFill <= blockSize
+//     buffer[0..bufFill - 1] == fileData[
+//             (offset + bufOffset)..(offset + bufOffset + bufFill - 1)]
+
+
+#endif  /* uio_INTERNAL_FILEBLOCK */
 
 uio_FileBlock *uio_openFileBlock(uio_Handle *handle);
 uio_FileBlock *uio_openFileBlock2(uio_Handle *handle, off_t offset,
@@ -46,6 +78,10 @@ ssize_t uio_accessFileBlock(uio_FileBloc
 int uio_copyFileBlock(uio_FileBlock *block, off_t offset, char *buffer,
 		size_t length);
 int uio_closeFileBlock(uio_FileBlock *block);
+#define uio_FB_READAHEAD_BUFSIZE_MAX ((size_t) -1)
+void uio_setFileBlockUsageHint(uio_FileBlock *block, int usage,
+		size_t readAheadBufSize);
+void uio_clearFileBlockBuffers(uio_FileBlock *block);
 
 #endif  /* _FILEBLOCK_H */
 
diff -ruNp src.orig/sc2code/libs/uio/getint.h src/sc2code/libs/uio/getint.h
--- src.orig/sc2code/libs/uio/getint.h	1969-12-31 18:00:00 -0600
+++ src/sc2code/libs/uio/getint.h	2017-11-08 16:50:00 -0600
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2007  Serge van den Boom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ * Nota bene: later versions of the GNU General Public License do not apply
+ * to this program.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef _GETINT_H
+#define _GETINT_H
+
+/* All these functions return true on success, or false on failure */
+
+#include "types.h"
+#include "uioport.h"
+
+static inline uio_bool
+uio_getU8(uio_Stream *stream, uio_uint8 *result) {
+	int val = uio_getc(stream);
+	if (val == EOF)
+		return false;
+
+	*result = (uio_uint8) val;
+	return true;
+}
+
+static inline uio_bool
+uio_getS8(uio_Stream *stream, uio_sint8 *result) {
+	int val = uio_getc(stream);
+	if (val == EOF)
+		return false;
+
+	*result = (uio_sint8) val;
+	return true;
+}
+
+static inline uio_bool
+uio_getU16LE(uio_Stream *stream, uio_uint16 *result) {
+	uio_uint8 buf[2];
+
+	if (uio_fread(buf, sizeof buf, 1, stream) != 1)
+		return false;
+
+	*result = (buf[1] << 8) | buf[0];
+	return true;
+}
+
+static inline uio_bool
+uio_getU16BE(uio_Stream *stream, uio_uint16 *result) {
+	uio_uint8 buf[2];
+
+	if (uio_fread(buf, sizeof buf, 1, stream) != 1)
+		return false;
+
+	*result = (buf[0] << 8) | buf[1];
+	return true;
+}
+
+static inline uio_bool
+uio_getS16LE(uio_Stream *stream, uio_sint16 *result) {
+	uio_uint8 buf[2];
+
+	if (uio_fread(buf, sizeof buf, 1, stream) != 1)
+		return false;
+
+	*result = (uio_sint16) ((buf[1] << 8) | buf[0]);
+	return true;
+}
+
+static inline uio_bool
+uio_getS16BE(uio_Stream *stream, uio_sint16 *result) {
+	uio_uint8 buf[2];
+
+	if (uio_fread(buf, sizeof buf, 1, stream) != 1)
+		return false;
+
+	*result = (uio_sint16) ((buf[0] << 8) | buf[1]);
+	return true;
+}
+
+static inline uio_bool
+uio_getU32LE(uio_Stream *stream, uio_uint32 *result) {
+	uio_uint8 buf[4];
+
+	if (uio_fread(buf, sizeof buf, 1, stream) != 1)
+		return false;
+
+	*result = (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0];
+	return true;
+}
+
+static inline uio_bool
+uio_getU32BE(uio_Stream *stream, uio_uint32 *result) {
+	uio_uint8 buf[4];
+
+	if (uio_fread(buf, sizeof buf, 1, stream) != 1)
+		return false;
+
+	*result = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
+	return true;
+}
+
+static inline uio_bool
+uio_getS32LE(uio_Stream *stream, uio_sint32 *result) {
+	uio_uint8 buf[4];
+
+	if (uio_fread(buf, sizeof buf, 1, stream) != 1)
+		return false;
+
+	*result = (uio_sint32) ((buf[3] << 24) | (buf[2] << 16) |
+				(buf[1] << 8) | buf[0]);
+	return true;
+}
+
+static inline uio_bool
+uio_getS32BE(uio_Stream *stream, uio_sint32 *result) {
+	uio_uint8 buf[4];
+
+	if (uio_fread(buf, sizeof buf, 1, stream) != 1)
+		return false;
+
+	*result = (uio_sint32) ((buf[0] << 24) | (buf[1] << 16) |
+				(buf[2] << 8) | buf[3]);
+	return true;
+}
+
+
+#endif  /* _GETINT_H */
+
diff -ruNp src.orig/sc2code/libs/uio/gphys.c src/sc2code/libs/uio/gphys.c
--- src.orig/sc2code/libs/uio/gphys.c	2017-11-08 16:49:33 -0600
+++ src/sc2code/libs/uio/gphys.c	2017-11-08 16:50:01 -0600
@@ -205,7 +205,7 @@ uio_GPDir_getPDirEntryHandle(const uio_P
  * where you ended up, and 'pathRest' will point into the original path. to
  * the beginning of the part that was not matched.
  * It is allowed to have endGPDir point to gPDir and/or restPath
- * point to path when calling this function.i
+ * point to path when calling this function.
  * returns: 0 if the complete path was matched
  *          ENOENT if some component (the next one) didn't exists
  *          ENODIR if a component (the next one) exists but isn't a dir
@@ -223,7 +223,8 @@ uio_walkGPPath(uio_GPDir *startGPDir, co
 	int retVal;
 
 	gPDir = startGPDir;
-	tempBuf = uio_alloca(strlen(path) + 1);
+	tempBuf = uio_malloc(strlen(path) + 1);
+			// XXX: Use a dynamically allocated array when moving to C99.
 	pathEnd = path + pathLen;
 	getFirstPathComponent(path, pathEnd, &partStart, &partEnd);
 	while (1) {
@@ -247,6 +248,7 @@ uio_walkGPPath(uio_GPDir *startGPDir, co
 		getNextPathComponent(pathEnd, &partStart, &partEnd);
 	}
 
+	uio_free(tempBuf);
 	*pathRest = partStart;
 	*endGPDir = gPDir;
 	return retVal;
diff -ruNp src.orig/sc2code/libs/uio/io.c src/sc2code/libs/uio/io.c
--- src.orig/sc2code/libs/uio/io.c	2017-11-08 16:49:33 -0600
+++ src/sc2code/libs/uio/io.c	2017-11-08 16:50:01 -0600
@@ -238,12 +238,12 @@ uio_mountDir(uio_Repository *destRep, co
 		uio_MountInfo *mountInfo;
 		uio_MountTree *mountTree;
 		uio_PDirHandle *pRootHandle;
-#ifdef WIN32
+#ifdef BACKSLASH_IS_PATH_SEPARATOR
 		char *unixPath;
 		
 		unixPath = dosToUnixPath(inPath);
 		inPath = unixPath;
-#endif
+#endif  /* BACKSLASH_IS_PATH_SEPARATOR */
 
 		if (inPath[0] == '/')
 			inPath++;
@@ -252,13 +252,11 @@ uio_mountDir(uio_Repository *destRep, co
 				&endDirHandle, &endInPath);
 		if (*endInPath != '\0') {
 			// Path inside the filesystem to mount does not exist.
-#ifdef WIN32
+#ifdef BACKSLASH_IS_PATH_SEPARATOR
 			uio_free(unixPath);
-#endif
+#endif  /* BACKSLASH_IS_PATH_SEPARATOR */
 			uio_PDirHandle_unref(endDirHandle);
 			uio_PRoot_unrefMount(pRoot);
-			if (handle)
-				uio_close(handle);
 			errno = ENOENT;
 			return NULL;
 		}
@@ -266,10 +264,10 @@ uio_mountDir(uio_Repository *destRep, co
 		dirName = uio_malloc(endInPath - inPath + 1);
 		memcpy(dirName, inPath, endInPath - inPath);
 		dirName[endInPath - inPath] = '\0';
-#ifdef WIN32
+#ifdef BACKSLASH_IS_PATH_SEPARATOR
 		// InPath is a copy with the paths fixed.
 		uio_free(unixPath);
-#endif
+#endif  /* BACKSLASH_IS_PATH_SEPARATOR */
 		mountInfo = uio_MountInfo_new(fsType, NULL, endDirHandle, dirName,
 				autoMount, NULL, flags);
 		uio_repositoryAddMount(destRep, mountInfo,
diff -ruNp src.orig/sc2code/libs/uio/io.h src/sc2code/libs/uio/io.h
--- src.orig/sc2code/libs/uio/io.h	2017-11-08 16:49:33 -0600
+++ src/sc2code/libs/uio/io.h	2017-11-08 16:50:01 -0600
@@ -41,6 +41,7 @@ typedef enum {
 #include "mount.h"
 #include "mounttree.h"
 #include "uiostream.h"
+#include "getint.h"
 #include "debug.h"
 
 struct uio_AutoMount {
diff -ruNp src.orig/sc2code/libs/uio/ioaux.c src/sc2code/libs/uio/ioaux.c
--- src.orig/sc2code/libs/uio/ioaux.c	2017-11-08 16:49:33 -0600
+++ src/sc2code/libs/uio/ioaux.c	2017-11-08 16:50:01 -0600
@@ -71,7 +71,8 @@ uio_walkPhysicalPath(uio_PDirHandle *sta
 
 	uio_PDirHandle_ref(startPDirHandle);
 	pDirHandle = startPDirHandle;
-	tempBuf = uio_alloca(strlen(path) + 1);
+	tempBuf = uio_malloc(strlen(path) + 1);
+			// XXX: Use a dynamically allocated array when moving to C99.
 	pathEnd = path + pathLen;
 	getFirstPathComponent(path, pathEnd, &partStart, &partEnd);
 	for (;;) {
@@ -97,6 +98,7 @@ uio_walkPhysicalPath(uio_PDirHandle *sta
 		getNextPathComponent(pathEnd, &partStart, &partEnd);
 	}
 
+	uio_free(tempBuf);
 	*pathRest = partStart;
 	*endPDirHandle = pDirHandle;
 	return retVal;
@@ -132,8 +134,9 @@ uio_makePath(uio_PDirHandle *pDirHandle,
 
 	pathEnd = path + pathLen;
 	
-	buf = uio_alloca(pathLen + 1);
+	buf = uio_malloc(pathLen + 1);
 			// worst case length
+			// XXX: Use a dynamically allocated array when moving to C99.
 
 	uio_walkPhysicalPath(pDirHandle, path, pathLen, &pDirHandle, &rest);
 			// The reference to the original pDirHandle is still kept
@@ -152,12 +155,14 @@ uio_makePath(uio_PDirHandle *pDirHandle,
 			int savedErrno = errno;
 			uio_PDirHandle_unref(pDirHandle);
 			errno = savedErrno;
+			uio_free(buf);
 			return NULL;
 		}
 		uio_PDirHandle_unref(pDirHandle);
 		pDirHandle = newPDirHandle;
 		getNextPathComponent(pathEnd, &start, &end);
 	}
+	uio_free(buf);
 	return pDirHandle;
 }
 
diff -ruNp src.orig/sc2code/libs/uio/match.c src/sc2code/libs/uio/match.c
--- src.orig/sc2code/libs/uio/match.c	2017-11-08 16:49:33 -0600
+++ src/sc2code/libs/uio/match.c	2017-11-08 16:50:01 -0600
@@ -65,6 +65,16 @@ static inline void match_freeRegexContex
 
 // *** General part ***
 
+static inline match_MatchContext *
+match_allocMatchContext(void) {
+	return uio_malloc(sizeof (match_MatchContext));
+}
+
+static inline void
+match_freeMatchContext(match_MatchContext *context) {
+	uio_free(context);
+}
+
 // NB: Even if this function fails, *contextPtr contains a context
 //     which needs to be freed.
 match_Result
@@ -133,6 +143,7 @@ match_matchPattern(match_MatchContext *c
 	}
 }
 
+// context may be NULL
 const char *
 match_errorString(match_MatchContext *context, match_Result result) {
 	switch (result) {
@@ -145,11 +156,15 @@ match_errorString(match_MatchContext *co
 		case match_ENOTINIT:
 			return "Uninitialised use";
 		case match_ECUSTOM:
-			// Depends on match type.
+			// Depends on match type. Printed below.
 			break;
 		default:
 			return "Unknown error";
 	}
+			
+	if (context == NULL)
+		return "Unknown match-type specific error.";
+				// We can't be any more specific if no 'context' is supplied.
 
 	switch (context->type) {
 #if 0
@@ -206,14 +221,21 @@ match_freeContext(match_MatchContext *co
 	match_freeMatchContext(context);
 }
 
-static inline match_MatchContext *
-match_allocMatchContext(void) {
-	return uio_malloc(sizeof (match_MatchContext));
-}
+match_Result
+match_matchPatternOnce(const char *pattern, match_MatchType type,
+		const char *string) {
+	match_MatchContext *context;
+	match_Result result;
 
-static inline void
-match_freeMatchContext(match_MatchContext *context) {
-	uio_free(context);
+	result = match_prepareContext(pattern, &context, type);
+	if (result != match_OK)
+		goto out;
+
+	result = match_matchPattern(context, string);
+
+out:
+	match_freeContext(context);
+	return result;
 }
 
 
diff -ruNp src.orig/sc2code/libs/uio/match.h src/sc2code/libs/uio/match.h
--- src.orig/sc2code/libs/uio/match.h	2017-11-08 16:49:33 -0600
+++ src/sc2code/libs/uio/match.h	2017-11-08 16:50:01 -0600
@@ -70,6 +70,8 @@ match_Result match_matchPattern(match_Ma
 const char *match_errorString(match_MatchContext *context,
 		match_Result result);
 void match_freeContext(match_MatchContext *context);
+match_Result match_matchPatternOnce(const char *pattern, match_MatchType type,
+		const char *string);
 
 
 /* *** Internal definitions follow *** */
diff -ruNp src.orig/sc2code/libs/uio/mem.h src/sc2code/libs/uio/mem.h
--- src.orig/sc2code/libs/uio/mem.h	2017-11-08 16:49:33 -0600
+++ src/sc2code/libs/uio/mem.h	2017-11-08 16:50:01 -0600
@@ -29,7 +29,6 @@
 #define uio_realloc realloc
 #define uio_free free
 #define uio_calloc calloc
-#define uio_alloca alloca
 
 #ifdef uio_MEM_DEBUG
 // When uio_strdup is defined to the libc strdup, there's no opportunity
diff -ruNp src.orig/sc2code/libs/uio/mounttree.h src/sc2code/libs/uio/mounttree.h
--- src.orig/sc2code/libs/uio/mounttree.h	2017-11-08 16:49:33 -0600
+++ src/sc2code/libs/uio/mounttree.h	2017-11-08 16:50:01 -0600
@@ -102,7 +102,7 @@ struct uio_MountInfo {
 	char *dirName;
 			/* The path inside the mounted fs leading to pDirHandle */
 	uio_PDirHandle *pDirHandle;
-			/* The pDirHandle belonging to this mount type */
+			/* The pDirHandle belonging to this mount */
 	uio_MountTree *mountTree;
 			/* The MountTree node for the mountpoint */
 	uio_AutoMount **autoMount;
diff -ruNp src.orig/sc2code/libs/uio/paths.c src/sc2code/libs/uio/paths.c
--- src.orig/sc2code/libs/uio/paths.c	2017-11-08 16:49:33 -0600
+++ src/sc2code/libs/uio/paths.c	2017-11-08 16:50:01 -0600
@@ -367,9 +367,9 @@ decomposePath(const char *path, uio_Path
 	uio_PathComp **endResult = &result;
 	uio_bool absolute = false;
 	char *name;
-#ifdef WIN32
+#ifdef HAVE_UNC_PATHS
 	size_t nameLen;
-#endif
+#endif  /* HAVE_UNC_PATHS */
 
 	if (path[0] == '\0') {
 		errno = ENOENT;
@@ -377,7 +377,7 @@ decomposePath(const char *path, uio_Path
 	}
 
 	last = NULL;
-#ifdef WIN32
+#ifdef HAVE_UNC_PATHS
 	path += uio_getUNCServerShare(path, &name, &nameLen);
 	if (name != NULL) {
 		// UNC path
@@ -386,7 +386,10 @@ decomposePath(const char *path, uio_Path
 		endResult = &last->next;
 
 		absolute = true;
-	} else if (isDriveLetter(path[0]) && path[1] == ':') {
+	} else
+#endif  /* HAVE_UNC_PATHS */
+#ifdef HAVE_DRIVE_LETTERS
+	if (isDriveLetter(path[0]) && path[1] == ':') {
 		// DOS/Windows drive letter.
 		if (path[2] != '\0' && !isPathDelimiter(path[2])) {
 			errno = ENOENT;
@@ -398,7 +401,7 @@ decomposePath(const char *path, uio_Path
 		endResult = &last->next;
 		absolute = true;
 	} else
-#endif
+#endif  /* HAVE_DRIVE_LETTERS */
 	{
 		if (isPathDelimiter(*path)) {
 			absolute = true;
@@ -457,17 +460,20 @@ composePath(const uio_PathComp *pathComp
 	pathPtr = result;
 	ptr = pathComp;
 	if (absolute) {
-#ifdef WIN32
+#ifdef HAVE_UNC_PATHS
 		if (ptr->name[0] == '\\') {
 			// UNC path
 			assert(ptr->name[1] == '\\');
 			// Nothing to do.
-		} else if (ptr->nameLen == 2 && ptr->name[1] == ':'
+		} else
+#endif  /* HAVE_UNC_PATHS */
+#ifdef HAVE_DRIVE_LETTERS
+		if (ptr->nameLen == 2 && ptr->name[1] == ':'
 				&& isDriveLetter(ptr->name[0])) {
 			// Nothing to do.
 		}
 		else
-#endif
+#endif  /* HAVE_DRIVE_LETTERS */
 		{
 			*(pathPtr++) = '/';
 		}
diff -ruNp src.orig/sc2code/libs/uio/paths.h src/sc2code/libs/uio/paths.h
--- src.orig/sc2code/libs/uio/paths.h	2017-11-08 16:49:33 -0600
+++ src/sc2code/libs/uio/paths.h	2017-11-08 16:50:01 -0600
@@ -61,22 +61,22 @@ size_t uio_skipUNCServerShare(const char
 size_t uio_getUNCServerShare(const char *inPath, char **outPath,
 		size_t *outLen);
 
-#ifdef WIN32
+#ifdef HAVE_DRIVE_LETTERS
 static inline int
 isDriveLetter(int c)
 {
 	return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');
 }
-#endif
+#endif  /* HAVE_DRIVE_LETTERS */
 
 static inline int
 isPathDelimiter(int c)
 {
-#ifdef WIN32
+#ifdef BACKSLASH_IS_PATH_SEPARATOR
 	return c == '/' || c == '\\';
 #else
 	return c == '/';
-#endif
+#endif  /* BACKSLASH_IS_PATH_SEPARATOR */
 }
 
 int decomposePath(const char *path, uio_PathComp **pathComp,
diff -ruNp src.orig/sc2code/libs/uio/stdio/stdio.c src/sc2code/libs/uio/stdio/stdio.c
--- src.orig/sc2code/libs/uio/stdio/stdio.c	2017-11-08 16:49:34 -0600
+++ src/sc2code/libs/uio/stdio/stdio.c	2017-11-08 16:50:01 -0600
@@ -32,8 +32,6 @@
 #else
 #	include <sys/stat.h>
 #	include <unistd.h>
-#	define _POSIX_THREAD_SAFEFUNCTIONS
-		// for readdir_r
 #	include <dirent.h>
 #endif
 #include <stdio.h>
@@ -342,20 +340,24 @@ stdio_getPDirEntryHandle(const uio_PDirH
 	const char *pathUpTo;
 	char *path;
 	struct stat statBuf;
-#ifdef WIN32
+#ifdef HAVE_DRIVE_LETTERS
 	char driveName[3];
-#endif
+#endif  /* HAVE_DRIVE_LETTERS */
 
-#ifdef WIN32
+#if defined(HAVE_DRIVE_LETTERS) || defined(HAVE_UNC_PATHS)
 	if (pDirHandle->extra->extra->upDir == NULL) {
 		// Top dir. Contains only drive letters and UNC \\server\share
 		// parts.
+#ifdef HAVE_DRIVE_LETTERS
 		if (isDriveLetter(name[0]) && name[1] == ':' && name[2] == '\0') {
 			driveName[0] = tolower(name[0]);
 			driveName[1] = ':';
 			driveName[2] = '\0';
 			name = driveName;
-		} else {
+		} else
+#endif  /* HAVE_DRIVE_LETTERS */
+#ifdef HAVE_UNC_PATHS
+		{
 			size_t uncLen;
 
 			uncLen = uio_skipUNCServerShare(name);
@@ -365,14 +367,20 @@ stdio_getPDirEntryHandle(const uio_PDirH
 				return NULL;
 			}
 		}
+#else /* !defined(HAVE_UNC_PATHS) */
+		{
+			// Make sure that there is an 'else' case if HAVE_DRIVE_LETTERS
+			// is defined.
+		}
+#endif  /* HAVE_UNC_PATHS */
 	}
-#endif
+#endif  /* defined(HAVE_DRIVE_LETTERS) || defined(HAVE_UNC_PATHS) */
 	
 	result = uio_GPDir_getPDirEntryHandle(pDirHandle, name);
 	if (result != NULL)
 		return result;
 
-#ifdef WIN32
+#if defined(HAVE_DRIVE_LETTERS) || defined(HAVE_UNC_PATHS)
 	if (pDirHandle->extra->extra->upDir == NULL) {
 		// Need to create a 'directory' for the drive letter or UNC
 		// "\\server\share" part.
@@ -385,7 +393,7 @@ stdio_getPDirEntryHandle(const uio_PDirH
 		return (uio_PDirEntryHandle *) uio_PDirHandle_new(
 				pDirHandle->pRoot, gPDir);
 	}
-#endif
+#endif  /* defined(HAVE_DRIVE_LETTERS) || defined(HAVE_UNC_PATHS) */
 	
 	pathUpTo = stdio_getPath(pDirHandle->extra);
 	if (pathUpTo == NULL) {
@@ -399,8 +407,25 @@ stdio_getPDirEntryHandle(const uio_PDirH
 	}
 
 	if (stat(path, &statBuf) == -1) {
-		uio_free(path);
-		return NULL;
+#ifdef __SYMBIAN32__
+		// XXX: HACK: If we don't have access to a directory, we can still
+		// have access to the underlying entries. We don't actually know
+		// whether the entry is a directory, but I know of no way to find
+		// out. We just pretend that it is; worst case, a file which we can't
+		// access shows up as a directory which we can't access.
+		if (errno == EACCES) {
+			statBuf.st_mode = S_IFDIR;
+					// Fake a directory; the other fields of the stat
+					// structure are unused.
+		} else
+#endif
+		{
+			// errno is set.
+			int savedErrno = errno;
+			uio_free(path);
+			errno = savedErrno;
+			return NULL;
+		}
 	}
 	uio_free(path);
 
@@ -436,12 +461,12 @@ stdio_mount(uio_Handle *handle, int flag
 	assert (handle == NULL);
 	extra = stdio_GPDirData_new(
 			uio_strdup("") /* name */,
-#ifdef WIN32
-			// In MS Windows, full paths start with a drive letter.
+#if defined(HAVE_DRIVE_LETTERS) || defined(HAVE_UNC_PATHS)
+			// Full paths start with a drive letter or \\server\share
 			uio_strdup("") /* cached path */,
 #else
 			uio_strdup("/") /* cached path */,
-#endif
+#endif  /* HAVE_DRIVE_LETTERS */
 			NULL /* parent dir */);
 
 	result = uio_GPRoot_makePRoot(
@@ -713,15 +738,15 @@ stdio_getPath(uio_GPDir *gPDir) {
 		size_t upPathLen, nameLen;
 	
 		if (gPDir->extra->upDir == NULL) {
-#ifdef WIN32
-			// Drive letter still needs to follow.
+#if defined(HAVE_DRIVE_LETTERS) || defined(HAVE_UNC_PATHS)
+			// Drive letter or UNC \\server\share still needs to follow.
 			gPDir->extra->cachedPath = uio_malloc(1);
 			gPDir->extra->cachedPath[0] = '\0';
 #else
 			gPDir->extra->cachedPath = uio_malloc(2);
 			gPDir->extra->cachedPath[0] = '/';
 			gPDir->extra->cachedPath[1] = '\0';
-#endif
+#endif  /* defined(HAVE_DRIVE_LETTERS) || defined(HAVE_UNC_PATHS) */
 			return gPDir->extra->cachedPath;
 		}
 		
@@ -731,21 +756,22 @@ stdio_getPath(uio_GPDir *gPDir) {
 			return NULL;
 		}
 			
-#ifdef WIN32
+#if defined(HAVE_DRIVE_LETTERS) || defined(HAVE_UNC_PATHS)
 		if (upPath[0] == '\0') {
 			// The up dir is the root dir. Directly below the root dir are
-			// only dirs for drive letters. No '/' needs to be attached.
+			// only dirs for drive letters and UNC \\share\server parts.
+			// No '/' needs to be attached.
 			gPDir->extra->cachedPath = uio_strdup(gPDir->extra->name);
 			return gPDir->extra->cachedPath;
 		}
-#endif
+#endif  /* defined(HAVE_DRIVE_LETTERS) || defined(HAVE_UNC_PATHS) */
 		upPathLen = strlen(upPath);
-#ifndef WIN32
+#if !defined(HAVE_DRIVE_LETTERS) && !defined(HAVE_UNC_PATHS)
 		if (upPath[upPathLen - 1] == '/') {
 			// should only happen for "/"
 			upPathLen--;
 		}
-#endif
+#endif  /* !defined(HAVE_DRIVE_LETTERS) && !defined(HAVE_UNC_PATHS) */
 		nameLen = strlen(gPDir->extra->name);
 		if (upPathLen + nameLen + 1 >= PATH_MAX) {
 			errno = ENAMETOOLONG;
diff -ruNp src.orig/sc2code/libs/uio/types.h src/sc2code/libs/uio/types.h
--- src.orig/sc2code/libs/uio/types.h	2017-11-08 16:49:34 -0600
+++ src/sc2code/libs/uio/types.h	2017-11-08 16:50:01 -0600
@@ -21,11 +21,33 @@
 #ifndef _uio_TYPES_H
 #define _uio_TYPES_H
 
-typedef enum
-{
-	false = 0,
-	true
-} uio_bool;
+#include "config.h"
+
+// ISO C99 compatible boolean types. The ISO C99 standard defines:
+// - An object declared as type _Bool, large enough to store the values 0
+//   and 1, the rank of which is less than the rank of all other standard
+//   integer types.
+// - A macro "bool", which expands to "_Bool".
+// - A macro "true", which expands to the integer constant 1, suitable for
+//   use in #if preprocessing directives.
+// - A macro "false", which expands to the integer constant 0, suitable for
+//   use in #if preprocessing directives.
+// - A macro "__bool_true_false_are_defined", which expands to the integer
+//   constant 1, suitable for use in #if preprocessing directives.
+#ifndef __bool_true_false_are_defined
+#undef bool
+#undef false
+#undef true
+#ifndef HAVE__BOOL
+typedef unsigned char _Bool;
+#endif  /* HAVE_BOOL */
+#define bool _Bool
+#define true 1
+#define false 0
+#define __bool_true_false_are_defined
+#endif  /* __bool_true_false_are_defined */
+
+typedef bool uio_bool;
 
 typedef unsigned char  uio_uint8;
 typedef   signed char  uio_sint8;
diff -ruNp src.orig/sc2code/libs/uio/uioport.h src/sc2code/libs/uio/uioport.h
--- src.orig/sc2code/libs/uio/uioport.h	2017-11-08 16:49:34 -0600
+++ src/sc2code/libs/uio/uioport.h	2017-11-08 16:50:01 -0600
@@ -45,6 +45,8 @@
 		// _MAX_DIR and FILENAME_MAX could also be candidates.
 		// If anyone can tell me which one matches NAME_MAX, please
 		// let me know.
+#elif defined(_WIN32_WCE)
+#	include <sys/syslimits.h>
 #else
 #	include <limits.h>
 		/* PATH_MAX is per POSIX defined in <limits.h>, but:
@@ -63,6 +65,23 @@
 #	endif
 #endif
 
+// Variations in path handling
+#if defined(WIN32) || defined(__SYMBIAN32__)
+	// HAVE_DRIVE_LETTERS is defined to signify that DOS/Windows style drive
+	// letters are to be recognised on this platform.
+#	define HAVE_DRIVE_LETTERS
+	// BACKSLASH_IS_PATH_SEPARATOR is defined to signify that the backslash
+	// character is to be recognised as a path separator on this platform.
+	// This does not affect the acceptance of forward slashes as path
+	// separators.
+#	define BACKSLASH_IS_PATH_SEPARATOR
+#endif
+#if defined(WIN32)
+	// HAVE_UNC_PATHS is defined to signify that Universal Naming Convention
+	// style paths are to be recognised on this platform.
+#	define HAVE_UNC_PATHS
+#endif
+
 // User ids
 #ifdef WIN32
 typedef short uid_t;
@@ -142,18 +161,21 @@ typedef unsigned short mode_t;
 #	define S_IFCHR _S_IFCHR
 #	define S_IFDIR _S_IFDIR
 #endif
+#ifdef __SYMBIAN32__
+	// TODO: Symbian doesn't have readdir_r(). If uio is to be usable
+	// outside of uqm (which defines its own backup readdir_r()), an
+	// implementation of that function needs to be added to uio.
+#	include <dirent.h>
+	int readdir_r (DIR *dirp, struct dirent *entry, struct dirent **result);
+#endif
 
-// Memory related:
-#ifdef WIN32
-#	ifdef __MINGW32__
-#		include <malloc.h>
-#	elif defined (_MSC_VER)
-#		define alloca _alloca
-#	endif
-#elif defined(__linux__) || defined(__svr4__)
-#	include <alloca.h>
+// String formatting
+#ifdef _MSC_VER
+#define snprintf _snprintf
+#define vsnprintf _vsnprintf
 #endif
 
+
 #endif  /* _UIOPORT_H */
 
 
diff -ruNp src.orig/sc2code/libs/uio/uiostream.c src/sc2code/libs/uio/uiostream.c
--- src.orig/sc2code/libs/uio/uiostream.c	2017-11-08 16:49:34 -0600
+++ src/sc2code/libs/uio/uiostream.c	2017-11-08 16:50:01 -0600
@@ -24,8 +24,10 @@
 
 #include <errno.h>
 #include <stdio.h>
+#include <stdarg.h>
 
 #include "uioutils.h"
+#include "utils.h"
 #ifdef uio_MEM_DEBUG
 #	include "memdebug.h"
 #endif
@@ -267,6 +269,46 @@ uio_ungetc(int c, uio_Stream *stream) {
 //	return c;
 }
 
+// NB. POSIX allows errno to be set for vsprintf(), but does not require it:
+// "The value of errno may be set to nonzero by a library function call
+// whether or not there is an error, provided the use of errno is not
+// documented in the description of the function in this International
+// Standard." The latter is the case for vsprintf().
+int
+uio_vfprintf(uio_Stream *stream, const char *format, va_list args) {
+	// This could be done faster, but going through snprintf() is easiest,
+	// and is fast enough for now.
+	char *buf;
+	int putResult;
+	int savedErrno;
+
+	buf = uio_vasprintf(format, args);
+	if (buf == NULL) {
+		// errno may or may not be set
+		return -1;
+	}
+
+	putResult = uio_fputs(buf, stream);
+	savedErrno = errno;
+
+	uio_free(buf);
+
+	errno = savedErrno;
+	return putResult;
+}
+
+int
+uio_fprintf(uio_Stream *stream, const char *format, ...) {
+	va_list args;
+	int result;
+
+	va_start(args, format);
+	result = uio_vfprintf(stream, format, args);
+	va_end(args);
+
+	return result;
+}
+
 int
 uio_fputc(int c, uio_Stream *stream) {
 	assert((stream->openFlags & O_ACCMODE) != O_RDONLY);
diff -ruNp src.orig/sc2code/libs/uio/uiostream.h src/sc2code/libs/uio/uiostream.h
--- src.orig/sc2code/libs/uio/uiostream.h	2017-11-08 16:49:34 -0600
+++ src/sc2code/libs/uio/uiostream.h	2017-11-08 16:50:01 -0600
@@ -26,6 +26,8 @@ typedef struct uio_Stream uio_Stream;
 
 #include "io.h"
 
+#include <stdarg.h>
+
 
 uio_Stream *uio_fopen(uio_DirHandle *dir, const char *path, const char *mode);
 int uio_fclose(uio_Stream *stream);
@@ -34,6 +36,8 @@ char *uio_fgets(char *buf, int size, uio
 int uio_fgetc(uio_Stream *stream);
 #define uio_getc uio_fgetc
 int uio_ungetc(int c, uio_Stream *stream);
+int uio_vfprintf(uio_Stream *stream, const char *format, va_list args);
+int uio_fprintf(uio_Stream *stream, const char *format, ...);
 int uio_fputc(int c, uio_Stream *stream);
 #define uio_putc uio_fputc
 int uio_fputs(const char *s, uio_Stream *stream);
diff -ruNp src.orig/sc2code/libs/uio/utils.c src/sc2code/libs/uio/utils.c
--- src.orig/sc2code/libs/uio/utils.c	2017-11-08 16:49:34 -0600
+++ src/sc2code/libs/uio/utils.c	2017-11-08 16:50:01 -0600
@@ -364,3 +364,98 @@ uio_StdioAccessHandle_free(uio_StdioAcce
 	uio_free(handle);
 }
 
+// The result should be freed using uio_free().
+// NB. POSIX allows errno to be set for vsprintf(), but does not require it:
+// "The value of errno may be set to nonzero by a library function call
+// whether or not there is an error, provided the use of errno is not
+// documented in the description of the function in this International
+// Standard." The latter is the case for vsprintf().
+char *
+uio_vasprintf(const char *format, va_list args) {
+	// TODO: If there is a system vasprintf, use that.
+	// XXX:  That would mean that the allocation would always go through
+	//       malloc() or so, instead of uio_malloc(),  which may not be
+	//       desirable.
+
+	char *buf;
+	size_t bufSize = 128;
+			// Start with enough for one screen line, and a power of 2,
+			// which might give faster result with allocations.
+
+	buf = uio_malloc(bufSize);
+	if (buf == NULL) {
+		// errno is set.
+		return NULL;
+	}
+
+	for (;;) {
+		int printResult = vsnprintf(buf, bufSize, format, args);
+		if (printResult < 0) {
+			// This means the buffer was not small enough, but vsnprintf()
+			// does not give us any clue on how large it should be.
+			// Note that this does not happen with a C'99 compliant
+			// vsnprintf(), but it will happen on MS Windows, and on
+			// glibc before version 2.1.
+			bufSize *= 2;
+		} else if ((unsigned int) printResult >= bufSize) {
+			// The buffer was too small, but printResult contains the size
+			// that the buffer needs to be (excluding the '\0' character).
+			bufSize = printResult + 1;
+		} else {
+			// Success.
+			if ((unsigned int) printResult + 1 != bufSize) {
+				// Shorten the resulting buffer to the size that was
+				// actually needed.
+				char *newBuf = uio_realloc(buf, printResult + 1);
+				if (newBuf == NULL) {
+					// We could have returned the (overly large) original
+					// buffer, but the unused memory might not be
+					// acceptable, and the program would be likely to run
+					// into problems sooner or later anyhow.
+					int savedErrno = errno;
+					uio_free(buf);
+					errno = savedErrno;
+					return NULL;
+				}
+				return newBuf;
+			}
+
+			return buf;
+		}
+
+		{
+			char *newBuf = uio_realloc(buf, bufSize);
+			if (newBuf == NULL)
+			{
+				int savedErrno = errno;
+				uio_free(buf);
+				errno = savedErrno;
+				return NULL;
+			}
+			buf = newBuf;
+		}
+	}
+}
+
+// As uio_vasprintf(), but with an argument list.
+char *
+uio_asprintf(const char *format, ...) {
+	// TODO: If there is a system asprintf, use that.
+	// XXX:  That would mean that the allocation would always go through
+	//       malloc() or so, instead of uio_malloc(),  which may not be
+	//       desirable.
+
+	va_list args;
+	char *result;
+	int savedErrno;
+
+	va_start(args, format);
+	result = uio_vasprintf(format, args);
+	savedErrno = errno;
+	va_end(args);
+
+	errno = savedErrno;
+	return result;
+}
+
+
diff -ruNp src.orig/sc2code/libs/uio/utils.h src/sc2code/libs/uio/utils.h
--- src.orig/sc2code/libs/uio/utils.h	2017-11-08 16:49:34 -0600
+++ src/sc2code/libs/uio/utils.h	2017-11-08 16:50:01 -0600
@@ -21,6 +21,8 @@
 #ifndef _UTILS_H
 #define _UTILS_H
 
+#include <stdarg.h>
+
 #ifdef uio_INTERNAL
 typedef struct uio_StdioAccessHandle uio_StdioAccessHandle;
 #else
@@ -34,6 +36,8 @@ uio_StdioAccessHandle *uio_getStdioAcces
 const char *uio_StdioAccessHandle_getPath(uio_StdioAccessHandle *handle);
 void uio_releaseStdioAccess(uio_StdioAccessHandle *handle);
 
+char *uio_vasprintf(const char *format, va_list args);
+char *uio_asprintf(const char *format, ...);
 
 #endif  /* _UTILS_H */
 
diff -ruNp src.orig/sc2code/libs/uio/zip/zip.c src/sc2code/libs/uio/zip/zip.c
--- src.orig/sc2code/libs/uio/zip/zip.c	2017-11-08 16:49:34 -0600
+++ src/sc2code/libs/uio/zip/zip.c	2017-11-08 16:50:01 -0600
@@ -43,6 +43,8 @@
 #endif
 
 
+#define DIR_STRUCTURE_READ_BUFSIZE 0x10000
+
 static int zip_badFile(zip_GPFileData *gPFileData, char *fileName);
 static int zip_fillDirStructure(uio_GPDir *top, uio_Handle *handle);
 #if zip_USE_HEADERS == zip_USE_LOCAL_HEADERS
@@ -583,7 +585,7 @@ zip_mount(uio_Handle *handle, int flags)
 		int savedErrno = errno;
 #ifdef DEBUG
 		fprintf(stderr, "Error: failed to read the zip directory "
-				"structure - %d.\n", errno);
+				"structure - %s.\n", strerror(errno));
 #endif
 		uio_GPRoot_umount(result);
 		errno = savedErrno;
@@ -647,7 +649,11 @@ zip_fillDirStructureCentral(uio_GPDir *t
 	}
 
 	startCentralDir = makeUInt32(buf[16], buf[17], buf[18], buf[19]);
-	
+
+	// Enable read-ahead buffering, for speed.
+	uio_setFileBlockUsageHint(fileBlock, uio_FB_USAGE_FORWARD,
+			DIR_STRUCTURE_READ_BUFSIZE);
+
 	pos = startCentralDir;
 	while (numEntries--) {
 		if (zip_fillDirStructureCentralProcessEntry(top, fileBlock, &pos)
@@ -1308,6 +1314,32 @@ zip_fillDirStructureProcessExtraFields(u
 				gPFileData->gid = (uid_t) makeUInt16(buf[12], buf[13]);
 				break;
 			}
+			case 0x7875: { // 'Unix3 any-size'
+				// The purpose of the first byte of this field is not
+				// documented, but is typically "1".  Skip it.
+				int pos = 1;
+				if (central)
+					break;
+
+#define SET_FILEDATA_ATTR(x) do { \
+				if (2 == buf[pos]) \
+					gPFileData->x = (uid_t) makeUInt16(buf[pos+1], \
+							buf[pos+2]); \
+				else if (4 == buf[pos]) \
+					gPFileData->x = (uid_t) makeUInt32(buf[pos+1], \
+							buf[pos+2], buf[pos+3], buf[pos+4]); \
+				else \
+					fprintf(stderr, "Warning: invalid " #x \
+							" length(%d) for file " \
+							"'%s' - ignored\n", buf[pos], fileName); \
+} while (0);
+
+				SET_FILEDATA_ATTR(uid);
+				pos += 1 + buf[pos];
+				SET_FILEDATA_ATTR(gid);
+
+				break;
+			}
 			default:
 #ifdef DEBUG
 				fprintf(stderr, "Debug: Extra field 0x%04x unsupported, "
diff -ruNp src.orig/sc2code/libs/video/Makeinfo src/sc2code/libs/video/Makeinfo
--- src.orig/sc2code/libs/video/Makeinfo	2017-11-08 16:49:34 -0600
+++ src/sc2code/libs/video/Makeinfo	2017-11-08 16:50:01 -0600
@@ -1 +1,2 @@
-uqm_CFILES="vfileins.c video.c videodec.c vidplayer.c dukvid.c"
+uqm_CFILES="vfileins.c vresins.c video.c videodec.c vidplayer.c dukvid.c \
+            legacyplayer.c"
diff -ruNp src.orig/sc2code/libs/video/dukvid.c src/sc2code/libs/video/dukvid.c
--- src.orig/sc2code/libs/video/dukvid.c	2017-11-08 16:49:34 -0600
+++ src/sc2code/libs/video/dukvid.c	2017-11-08 16:50:01 -0600
@@ -22,6 +22,7 @@
 #include "video.h"
 #include "dukvid.h"
 #include <stdio.h>
+#include <string.h>
 #include "libs/uio.h"
 #include "endian_uqm.h"
 
@@ -529,7 +530,6 @@ dukv_RenderFrame (THIS_PTR)
 	default:
 		;
 	}
-
 }
 
 static const char*
@@ -700,7 +700,12 @@ dukv_DecodeNext (THIS_PTR)
 
 	dukv->iframe++;
 
+	This->callbacks.BeginFrame (This);
 	dukv_RenderFrame (This);
+	This->callbacks.EndFrame (This);
+
+	if (!This->audio_synced)
+	   This->callbacks.SetTimer (This, (uint32) (1000.0f / DUCK_GENERAL_FPS));
 
 	return 1;
 }
diff -ruNp src.orig/sc2code/libs/video/legacyplayer.c src/sc2code/libs/video/legacyplayer.c
--- src.orig/sc2code/libs/video/legacyplayer.c	1969-12-31 18:00:00 -0600
+++ src/sc2code/libs/video/legacyplayer.c	2017-11-08 16:50:01 -0600
@@ -0,0 +1,39 @@
+#include "vidintrn.h"
+
+BOOLEAN
+PlayLegacyVideo (LEGACY_VIDEO vid)
+{
+	const char *name, *audname, *speechname;
+	DWORD loopframe;
+	VIDEO_REF VidRef;
+	MUSIC_REF AudRef = 0;
+	MUSIC_REF SpeechRef = 0;
+
+	if (!vid)
+		return FALSE;
+	name = vid->video;
+	audname = vid->audio;
+	speechname = vid->speech;
+	loopframe = vid->loop;
+
+	VidRef = LoadVideoFile (name);
+	if (!VidRef)
+		return FALSE;
+	if (audname)
+		AudRef = LoadMusicFile (audname);
+	if (speechname)
+		SpeechRef = LoadMusicFile (speechname);
+
+	VidPlayEx (VidRef, AudRef, SpeechRef, loopframe);
+	VidDoInput ();
+	VidStop ();
+	
+	DestroyVideo (VidRef);
+	if (SpeechRef)
+		DestroyMusic (SpeechRef);
+	if (AudRef)
+		DestroyMusic (AudRef);
+
+	return TRUE;
+}
+
diff -ruNp src.orig/sc2code/libs/video/video.c src/sc2code/libs/video/video.c
--- src.orig/sc2code/libs/video/video.c	2017-11-08 16:49:34 -0600
+++ src/sc2code/libs/video/video.c	2017-11-08 16:50:01 -0600
@@ -23,9 +23,10 @@
 
 #define NULL_VIDEO_REF	(0)
 static VIDEO_REF _cur_video = NULL_VIDEO_REF;
+static MUSIC_REF _cur_speech = 0;
 
 BOOLEAN
-InitVideo (BOOLEAN useCDROM)
+InitVideoPlayer (BOOLEAN useCDROM)
 		//useCDROM doesn't really apply to us
 {
 	TFB_PixelFormat fmt;
@@ -41,7 +42,7 @@ InitVideo (BOOLEAN useCDROM)
 }
 
 void
-UninitVideo ()
+UninitVideoPlayer (void)
 {
 	TFB_UninitVideoPlayer ();
 	VideoDecoder_Uninit ();
@@ -50,12 +51,14 @@ UninitVideo ()
 void
 VidStop ()
 {
+	if (_cur_speech)
+		snd_StopSpeech ();
 	if (_cur_video)
 	{
 		TFB_StopVideo (_cur_video);
 		TFB_FadeClearScreen ();
 	}
-
+	_cur_speech = 0;
 	_cur_video = NULL_VIDEO_REF;
 }
 
@@ -73,18 +76,30 @@ VidPlaying ()
 }
 
 VIDEO_TYPE
-VidPlay (VIDEO_REF VidRef, const char *loopname, BOOLEAN uninit)
-		// uninit was used to uninit the game kernel
-		// before spawning duck exe
+VidPlayEx (VIDEO_REF vid, MUSIC_REF AudRef, MUSIC_REF SpeechRef,
+		DWORD LoopFrame)
 {
 	VIDEO_TYPE ret;
-	TFB_VideoClip* vid = (TFB_VideoClip*) VidRef;
 
 	if (!vid)
 		return NO_FMV;
 
+	if (AudRef)
+	{
+		if (vid->hAudio)
+			DestroyMusic (vid->hAudio);
+		vid->hAudio = AudRef;
+		vid->decoder->audio_synced = FALSE;
+	}
+
+	vid->loop_frame = LoopFrame;
+	vid->loop_to = 0;
+
+	if (_cur_speech)
+		snd_StopSpeech ();
 	if (_cur_video)
 		TFB_StopVideo (_cur_video);
+	_cur_speech = 0;
 	_cur_video = NULL_VIDEO_REF;
 
 	TFB_FadeClearScreen ();
@@ -92,11 +107,16 @@ VidPlay (VIDEO_REF VidRef, const char *l
 	LockMutex (GraphicsLock);
 	SetContext (ScreenContext);
 	// play video in the center of the screen
-	if (TFB_PlayVideo (VidRef, (SCREEN_WIDTH - vid->w) / 2,
+	if (TFB_PlayVideo (vid, (SCREEN_WIDTH - vid->w) / 2,
 			(SCREEN_HEIGHT - vid->h) / 2))
 	{
-		_cur_video = VidRef;
+		_cur_video = vid;
 		ret = SOFTWARE_FMV;
+		if (SpeechRef)
+		{
+			snd_PlaySpeech (SpeechRef);
+			_cur_speech = SpeechRef;
+		}
 	}
 	else
 	{
@@ -104,13 +124,15 @@ VidPlay (VIDEO_REF VidRef, const char *l
 	}
 	UnlockMutex (GraphicsLock);
 
-	/* dodge compiler warnings */
-	(void) loopname;
-	(void) uninit;
-
 	return ret;
 }
 
+VIDEO_TYPE
+VidPlay (VIDEO_REF VidRef)
+{
+	return VidPlayEx (VidRef, 0, 0, VID_NO_LOOP);
+}
+
 void
 VidDoInput (void)
 {
@@ -119,7 +141,7 @@ VidDoInput (void)
 }
 
 VIDEO_REF
-_init_video_file(const char *pStr)
+_init_video_file (const char *pStr)
 {
 	TFB_VideoClip* vid;
 	TFB_VideoDecoder* dec;
@@ -139,10 +161,8 @@ _init_video_file(const char *pStr)
 }
 
 BOOLEAN
-DestroyVideo (VIDEO_REF VideoRef)
+DestroyVideo (VIDEO_REF vid)
 {
-	TFB_VideoClip* vid = (TFB_VideoClip*) VideoRef;
-
 	if (!vid)
 		return FALSE;
 
diff -ruNp src.orig/sc2code/libs/video/video.h src/sc2code/libs/video/video.h
--- src.orig/sc2code/libs/video/video.h	2017-11-08 16:49:34 -0600
+++ src/sc2code/libs/video/video.h	2017-11-08 16:50:01 -0600
@@ -43,6 +43,9 @@ typedef struct tfb_videoclip
 	uint32 cur_frame;  // index of frame currently displayed
 	uint32 max_frame_wait;
 	bool playing;
+	bool own_audio;
+	uint32 loop_frame; // frame index to loop from
+	uint32 loop_to;    // frame index to loop to
 
 	Mutex guard;
 	uint32 want_frame; // audio-signaled desired frame index
diff -ruNp src.orig/sc2code/libs/video/videodec.c src/sc2code/libs/video/videodec.c
--- src.orig/sc2code/libs/video/videodec.c	2017-11-08 16:49:34 -0600
+++ src/sc2code/libs/video/videodec.c	2017-11-08 16:50:01 -0600
@@ -14,6 +14,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+#include <string.h>
 #include "video.h"
 #include "videodec.h"
 #include "dukvid.h"
diff -ruNp src.orig/sc2code/libs/video/videodec.h src/sc2code/libs/video/videodec.h
--- src.orig/sc2code/libs/video/videodec.h	2017-11-08 16:49:34 -0600
+++ src/sc2code/libs/video/videodec.h	2017-11-08 16:50:01 -0600
@@ -49,7 +49,9 @@ typedef struct tfb_videodecoderfunc
 // from the player
 typedef struct tfb_videocallbacks
 {
-	// any decoder calls this
+	// any decoder calls these
+	void (* BeginFrame) (THIS_PTR);
+	void (* EndFrame) (THIS_PTR);
 	void* (* GetCanvasLine) (THIS_PTR, uint32 line);
 	// non-audio-driven decoders call this to figure out
 	// when the next frame should be drawn
diff -ruNp src.orig/sc2code/libs/video/vidintrn.h src/sc2code/libs/video/vidintrn.h
--- src.orig/sc2code/libs/video/vidintrn.h	1969-12-31 18:00:00 -0600
+++ src/sc2code/libs/video/vidintrn.h	2017-11-08 16:50:01 -0600
@@ -0,0 +1,29 @@
+// Copyright 2008 Michael Martin
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef VIDINTERN_H_
+#define VIDINTERN_H_
+
+#include "libs/vidlib.h"
+
+typedef struct legacy_video_desc {
+	char *video, *audio, *speech;
+	DWORD loop;
+} LEGACY_VIDEO_DESC;
+
+#endif
diff -ruNp src.orig/sc2code/libs/video/vidplayer.c src/sc2code/libs/video/vidplayer.c
--- src.orig/sc2code/libs/video/vidplayer.c	2017-11-08 16:49:34 -0600
+++ src/sc2code/libs/video/vidplayer.c	2017-11-08 16:50:01 -0600
@@ -25,12 +25,17 @@
 #include "libs/log.h"
 
 // video callbacks
+static void vp_BeginFrame (TFB_VideoDecoder*);
+static void vp_EndFrame (TFB_VideoDecoder*);
 static void* vp_GetCanvasLine (TFB_VideoDecoder*, uint32 line);
 static uint32 vp_GetTicks (TFB_VideoDecoder*);
 static bool vp_SetTimer (TFB_VideoDecoder*, uint32 msecs);
 
+
 TFB_VideoCallbacks vp_DecoderCBs =
 {
+	vp_BeginFrame,
+	vp_EndFrame,
 	vp_GetCanvasLine,
 	vp_GetTicks,
 	vp_SetTimer
@@ -58,7 +63,7 @@ static void* vp_interthread_clip = NULL;
 typedef struct
 {
 	// standard state required by DoInput
-	BOOLEAN (*InputFunc) (PVOID pInputState);
+	BOOLEAN (*InputFunc) (void *pInputState);
 	COUNT MenuRepeatDelay;
 
 	VIDEO_REF CurVideo;
@@ -123,7 +128,8 @@ as_video_play_task (void *data)
 
 	LockMutex (vid->guard);
 	want_frame = vid->want_frame;
-	PlayMusic (vid->hAudio, FALSE, 1);
+	if (vid->hAudio)
+		PlayMusic (vid->hAudio, FALSE, 1);
 	UnlockMutex (vid->guard);
 
 	clagged = 0;
@@ -205,10 +211,11 @@ as_video_play_task (void *data)
 		// increase timeout with lag-count to allow audio to catch up
 		TimeOut = GetTimeCounter () + vid->decoder->max_frame_wait *
 				ONE_SECOND / 1000 + clagged * ONE_SECOND / 100;
-		
+
 		ret = VideoDecoder_Decode (vid->decoder);
 	}
-	StopMusic ();
+	if (vid->hAudio)
+		StopMusic ();
 	vid->playing = false;
 
 	FinishTask (task);
@@ -232,7 +239,8 @@ video_play_task (void *data)
 
 	LockMutex (vid->guard);
 	if (vid->hAudio)
-		PlayMusic (vid->hAudio, FALSE, 1);
+		PlayMusic (vid->hAudio, (vid->loop_frame != VID_NO_LOOP), 1);
+
 	UnlockMutex (vid->guard);
 
 	// this works like so:
@@ -260,6 +268,9 @@ video_play_task (void *data)
 		UnlockMutex (GraphicsLock);
 		FlushGraphics (); // needed to prevent half-frame updates
 
+		if (vid->cur_frame == vid->loop_frame)
+			VideoDecoder_SeekFrame (vid->decoder, vid->loop_to);
+
 		ret = VideoDecoder_Decode (vid->decoder);
 	}
 	vid->playing = false;
@@ -272,9 +283,8 @@ video_play_task (void *data)
 }
 
 bool
-TFB_PlayVideo (VIDEO_REF VidRef, uint32 x, uint32 y)
+TFB_PlayVideo (VIDEO_REF vid, uint32 x, uint32 y)
 {
-	TFB_VideoClip* vid = (TFB_VideoClip*) VidRef;
 	RECT scrn_r;
 	RECT clip_r = {{0, 0}, {vid->w, vid->h}};
 	RECT vid_r = {{0, 0}, {SCREEN_WIDTH, SCREEN_HEIGHT}};
@@ -315,7 +325,12 @@ TFB_PlayVideo (VIDEO_REF VidRef, uint32
 	vid->cur_frame = -1;
 	vid->want_frame = -1;
 
-	vid->hAudio = LoadMusicFile (vid->decoder->filename);
+	if (!vid->hAudio)
+	{
+		vid->hAudio = LoadMusicFile (vid->decoder->filename);
+		vid->own_audio = true;
+	}
+
 	StopMusic ();
 
 	if (vid->decoder->audio_synced)
@@ -330,12 +345,11 @@ TFB_PlayVideo (VIDEO_REF VidRef, uint32
 		}
 
 		// nasty hack for now
-		LockMusicData (vid->hAudio, &pmus);
+		pmus = vid->hAudio;
 		(*pmus)->buffer_tag = HCalloc (
 				sizeof (TFB_SoundTag) * (*pmus)->num_buffers);
 		(*pmus)->callbacks = vp_AudioCBs;
 		(*pmus)->data = vid;	// hijack data ;)
-		UnlockMusicData (vid->hAudio);
 	}
 
 	SetSemaphore (vp_interthread_lock);
@@ -353,7 +367,7 @@ TFB_PlayVideo (VIDEO_REF VidRef, uint32
 	{
 		vid->playing = false;
 		ClearSemaphore (vp_interthread_lock);
-		TFB_StopVideo (VidRef);
+		TFB_StopVideo (vid);
 
 		return false;
 	}
@@ -362,10 +376,8 @@ TFB_PlayVideo (VIDEO_REF VidRef, uint32
 }
 
 void
-TFB_StopVideo (VIDEO_REF VidRef)
+TFB_StopVideo (VIDEO_REF vid)
 {
-	TFB_VideoClip* vid = (TFB_VideoClip*) VidRef;
-
 	if (!vid)
 		return;
 
@@ -376,8 +388,12 @@ TFB_StopVideo (VIDEO_REF VidRef)
 	if (vid->hAudio)
 	{
 		StopMusic ();
-		DestroyMusic (vid->hAudio);
-		vid->hAudio = 0;
+		if (vid->own_audio)
+		{
+			DestroyMusic (vid->hAudio);
+			vid->hAudio = 0;
+			vid->own_audio = false;
+		}
 	}
 	if (vid->frame) 
 	{
@@ -387,10 +403,8 @@ TFB_StopVideo (VIDEO_REF VidRef)
 }
 
 bool
-TFB_VideoPlaying (VIDEO_REF VidRef)
+TFB_VideoPlaying (VIDEO_REF vid)
 {
-	TFB_VideoClip* vid = (TFB_VideoClip*) VidRef;
-
 	if (!vid)
 		return false;
 
@@ -398,10 +412,10 @@ TFB_VideoPlaying (VIDEO_REF VidRef)
 }
 
 static BOOLEAN
-TFB_DoVideoInput (PVOID pIS)
+TFB_DoVideoInput (void *pIS)
 {
 	VIDEO_INPUT_STATE* pVIS = (VIDEO_INPUT_STATE*) pIS;
-	TFB_VideoClip* vid = (TFB_VideoClip*) pVIS->CurVideo;
+	TFB_VideoClip* vid = pVIS->CurVideo;
 
 	if (!pVIS->CurVideo || !TFB_VideoPlaying (pVIS->CurVideo))
 		return FALSE;
@@ -456,10 +470,28 @@ TFB_VideoInput (VIDEO_REF VidRef)
 	DoInput (&vis, TRUE);
 }
 
+static void
+vp_BeginFrame (TFB_VideoDecoder* decoder)
+{
+	TFB_VideoClip* vid = decoder->data;
+
+	if (vid)
+		TFB_DrawCanvas_Lock (vid->frame->NormalImg);
+}
+
+static void
+vp_EndFrame (TFB_VideoDecoder* decoder)
+{
+	TFB_VideoClip* vid = decoder->data;
+
+	if (vid)
+		TFB_DrawCanvas_Unlock (vid->frame->NormalImg);
+}
+
 static void*
 vp_GetCanvasLine (TFB_VideoDecoder* decoder, uint32 line)
 {
-	TFB_VideoClip* vid = (TFB_VideoClip*) decoder->data;
+	TFB_VideoClip* vid = decoder->data;
 
 	if (!vid)
 		return NULL;
@@ -479,7 +511,7 @@ vp_GetTicks (TFB_VideoDecoder* decoder)
 static bool
 vp_SetTimer (TFB_VideoDecoder* decoder, uint32 msecs)
 {
-	TFB_VideoClip* vid = (TFB_VideoClip*) decoder->data;
+	TFB_VideoClip* vid = decoder->data;
 
 	if (!vid)
 		return false;
diff -ruNp src.orig/sc2code/libs/video/vresins.c src/sc2code/libs/video/vresins.c
--- src.orig/sc2code/libs/video/vresins.c	1969-12-31 18:00:00 -0600
+++ src/sc2code/libs/video/vresins.c	2017-11-08 16:50:01 -0600
@@ -0,0 +1,184 @@
+// Copyright 2008 Michael Martin
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include "vidintrn.h"
+#include "libs/log.h"
+
+static BOOLEAN
+FreeLegacyVideoData (void *data)
+{
+	LEGACY_VIDEO pLV;
+	if (!data)
+		return FALSE;
+		
+	pLV = (LEGACY_VIDEO) data;
+	if (pLV->video)
+		HFree (pLV->video);
+	if (pLV->audio)
+		HFree (pLV->audio);
+	if (pLV->speech)
+		HFree (pLV->speech);
+	HFree (pLV);
+	
+	return TRUE;
+}
+
+static void
+GetLegacyVideoData (const char *path, RESOURCE_DATA *resdata)
+{
+	void *result = NULL;
+	char paths[1024], *audio_path, *speech_path, *loop_str;
+	DWORD LoopFrame = VID_NO_LOOP;
+
+	/* Parse out the video components. */
+	strncpy (paths, path, 1023);
+	paths[1023] = '\0';
+	audio_path = strchr (paths, ':');
+	if (audio_path == NULL)
+	{
+		speech_path = NULL;
+		loop_str = NULL;
+	}
+	else
+	{
+		*audio_path = '\0';
+		audio_path++;
+
+		speech_path = strchr (audio_path, ':');
+		if (speech_path == NULL)
+		{
+			loop_str = NULL;
+		}
+		else
+		{
+			*speech_path = '\0';
+			speech_path++;
+			
+			loop_str = strchr (speech_path, ':');
+			if (loop_str != NULL) {
+				*loop_str = '\0';
+				loop_str++;
+			}
+		}
+	}
+
+	log_add (log_Info, "\t'%s' -- video", paths);
+	if (audio_path)
+		log_add (log_Info, "\t'%s' -- audio", audio_path);
+	else
+		log_add (log_Info, "\tNo associated audio");
+	if (speech_path)
+		log_add (log_Info, "\t'%s' -- speech path", speech_path);
+	else
+		log_add (log_Info, "\tNo associated speech");
+	if (loop_str)
+	{
+		char *end;
+		LoopFrame = (DWORD) strtol (loop_str, &end, 10);
+		// We allow whitespace at the end, but nothing printable.
+		if (*end > 32) {
+			log_add (log_Warning, "Warning: Unparsable loop frame '%s'. Disabling loop.", loop_str);
+			LoopFrame = VID_NO_LOOP;
+		}
+		log_add (log_Info, "\tLoop frame is %d", LoopFrame);
+	} 
+	else
+		log_add (log_Info, "\tNo specified loop frame");
+		
+	result = HMalloc (sizeof (LEGACY_VIDEO_DESC));
+	if (result)
+	{
+		LEGACY_VIDEO pLV = (LEGACY_VIDEO) result;
+		int len;
+		pLV->video = NULL;
+		pLV->audio = NULL;
+		pLV->speech = NULL;
+		pLV->loop = LoopFrame;
+		
+		len = strlen(paths)+1;
+		pLV->video = (char *)HMalloc (len);
+		if (!pLV->video)
+		{
+			log_add (log_Warning, "Warning: Couldn't allocate space for '%s'", paths);
+			goto err;
+		}
+		strncpy(pLV->video, paths, len);
+
+		if (audio_path)
+		{
+			len = strlen(audio_path)+1;
+			pLV->audio = (char *)HMalloc (len);
+			if (!pLV->audio)
+			{
+				log_add (log_Warning, "Warning: Couldn't allocate space for '%s'", audio_path);
+				goto err;
+			}
+			strncpy(pLV->audio, audio_path, len);
+		}
+		
+		if (speech_path)
+		{
+			len = strlen(speech_path)+1;
+			pLV->speech = (char *)HMalloc (len);
+			if (!pLV->speech)
+			{
+				log_add (log_Warning, "Warning: Couldn't allocate space for '%s'", speech_path);
+				goto err;
+			}
+			strncpy(pLV->speech, speech_path, len);
+		}
+		
+		resdata->ptr = result;
+	}
+	return;
+err:
+	if (result)
+		FreeLegacyVideoData ((LEGACY_VIDEO)result);
+
+	resdata->ptr = NULL;
+	return;
+}
+
+BOOLEAN
+InstallVideoResType (void)
+{
+	InstallResTypeVectors ("3DOVID", GetLegacyVideoData, FreeLegacyVideoData);
+	return TRUE;
+}
+
+LEGACY_VIDEO
+LoadLegacyVideoInstance (RESOURCE res)
+{
+	void *data;
+	
+	data = res_GetResource (res);
+	if (data)
+	{
+		res_DetachResource (res);
+	}
+	
+	return (LEGACY_VIDEO)data;
+}
+
+BOOLEAN
+DestroyLegacyVideo (LEGACY_VIDEO vid)
+{
+	return FreeLegacyVideoData (vid);
+}
diff -ruNp src.orig/sc2code/libs/vidlib.h src/sc2code/libs/vidlib.h
--- src.orig/sc2code/libs/vidlib.h	2017-11-08 16:49:34 -0600
+++ src/sc2code/libs/vidlib.h	2017-11-08 16:50:01 -0600
@@ -19,7 +19,9 @@
 #ifndef _VIDLIB_H
 #define _VIDLIB_H
 
-#include "compiler.h"
+#include "libs/compiler.h"
+#include "libs/sndlib.h"
+#include "libs/reslib.h"
 
 typedef enum
 {
@@ -28,22 +30,26 @@ typedef enum
 	SOFTWARE_FMV
 } VIDEO_TYPE;
 
-#define MODES_UNDEFINED ((BYTE)~0)
+typedef struct tfb_videoclip *VIDEO_REF;
+typedef struct legacy_video_desc *LEGACY_VIDEO;
 
-typedef DWORD VIDEO_REF;
+extern BOOLEAN InstallVideoResType (void);
 
-extern BOOLEAN InitVideo (BOOLEAN UseCDROM);
-extern void UninitVideo (void);
-
-extern BYTE SetVideoMode (BYTE new_mode);
-extern BYTE GetVideoMode (void);
+extern BOOLEAN InitVideoPlayer (BOOLEAN UseCDROM);
+extern void UninitVideoPlayer (void);
 
 extern VIDEO_REF LoadVideoFile (const char *pStr);
 extern BOOLEAN DestroyVideo (VIDEO_REF VideoRef);
-extern VIDEO_TYPE VidPlay (VIDEO_REF VidRef, const char *loopname,
-		BOOLEAN uninit);
+extern VIDEO_TYPE VidPlay (VIDEO_REF VidRef);
+extern VIDEO_TYPE VidPlayEx (VIDEO_REF VidRef, MUSIC_REF AudRef,
+		MUSIC_REF SpeechRef, DWORD LoopFrame);
+#define VID_NO_LOOP (0U-1)
 extern void VidStop (void);
 extern VIDEO_REF VidPlaying (void);
 extern void VidDoInput (void);
 
+LEGACY_VIDEO LoadLegacyVideoInstance (RESOURCE res);
+BOOLEAN PlayLegacyVideo (LEGACY_VIDEO vid);
+BOOLEAN DestroyLegacyVideo (LEGACY_VIDEO vid);
+
 #endif /* _VIDLIB_H */
diff -ruNp src.orig/sc2code/load.c src/sc2code/load.c
--- src.orig/sc2code/load.c	2017-11-08 16:49:34 -0600
+++ src/sc2code/load.c	2017-11-08 16:50:01 -0600
@@ -29,9 +29,11 @@
 #include "options.h"
 #include "setup.h"
 #include "state.h"
+#include "grpinfo.h"
 
 #include "libs/tasklib.h"
 #include "libs/log.h"
+#include "libs/misc.h"
 
 //#define DEBUG_LOAD
 
@@ -39,7 +41,7 @@ ACTIVITY NextActivity;
 
 // XXX: these should handle endian conversions later
 static inline COUNT
-cread_8 (DECODE_REF fh, PBYTE v)
+cread_8 (DECODE_REF fh, BYTE *v)
 {
 	BYTE t;
 	if (!v) /* read value ignored */
@@ -48,7 +50,7 @@ cread_8 (DECODE_REF fh, PBYTE v)
 }
 
 static inline COUNT
-cread_16 (DECODE_REF fh, PUWORD v)
+cread_16 (DECODE_REF fh, UWORD *v)
 {
 	UWORD t;
 	if (!v) /* read value ignored */
@@ -57,7 +59,7 @@ cread_16 (DECODE_REF fh, PUWORD v)
 }
 
 static inline COUNT
-cread_32 (DECODE_REF fh, PDWORD v)
+cread_32 (DECODE_REF fh, DWORD *v)
 {
 	DWORD t;
 	if (!v) /* read value ignored */
@@ -73,14 +75,14 @@ cread_ptr (DECODE_REF fh)
 }
 
 static inline COUNT
-cread_a8 (DECODE_REF fh, PBYTE ar, COUNT count)
+cread_a8 (DECODE_REF fh, BYTE *ar, COUNT count)
 {
 	assert (ar != NULL);
 	return cread (ar, 1, count, fh) == count;
 }
 
 static inline COUNT
-read_8 (PVOID fp, PBYTE v)
+read_8 (void *fp, BYTE *v)
 {
 	BYTE t;
 	if (!v) /* read value ignored */
@@ -89,7 +91,7 @@ read_8 (PVOID fp, PBYTE v)
 }
 
 static inline COUNT
-read_16 (PVOID fp, PUWORD v)
+read_16 (void *fp, UWORD *v)
 {
 	UWORD t;
 	if (!v) /* read value ignored */
@@ -98,7 +100,7 @@ read_16 (PVOID fp, PUWORD v)
 }
 
 static inline COUNT
-read_32 (PVOID fp, PDWORD v)
+read_32 (void *fp, DWORD *v)
 {
 	DWORD t;
 	if (!v) /* read value ignored */
@@ -107,21 +109,21 @@ read_32 (PVOID fp, PDWORD v)
 }
 
 static inline COUNT
-read_ptr (PVOID fp)
+read_ptr (void *fp)
 {
 	DWORD t;
 	return read_32 (fp, &t); /* ptrs are useless in saves */
 }
 
 static inline COUNT
-read_a8 (PVOID fp, PBYTE ar, COUNT count)
+read_a8 (void *fp, BYTE *ar, COUNT count)
 {
 	assert (ar != NULL);
 	return ReadResFile (ar, 1, count, fp) == count;
 }
 
 static inline COUNT
-read_a16 (PVOID fp, PUWORD ar, COUNT count)
+read_a16 (void *fp, UWORD *ar, COUNT count)
 {
 	assert (ar != NULL);
 
@@ -134,74 +136,147 @@ read_a16 (PVOID fp, PUWORD ar, COUNT cou
 }
 
 static void
-LoadShipQueue (DECODE_REF fh, PQUEUE pQueue, BOOLEAN MakeQ)
+LoadEmptyQueue (DECODE_REF fh)
+{
+	COUNT num_links;
+
+	cread_16 (fh, &num_links);
+	if (num_links)
+	{
+		log_add (log_Error, "LoadEmptyQueue(): BUG: the queue is not empty!");
+#ifdef DEBUG
+		explode ();
+#endif
+	}
+}
+
+static void
+LoadShipQueue (DECODE_REF fh, QUEUE *pQueue)
 {
 	COUNT num_links;
 
 	cread_16 (fh, &num_links);
-	if (num_links && MakeQ)
-		InitQueue (pQueue, num_links, sizeof (SHIP_FRAGMENT));
 
 	while (num_links--)
 	{
-		HSTARSHIP hStarShip;
-		SHIP_FRAGMENTPTR FragPtr;
+		HSHIPFRAG hStarShip;
+		SHIP_FRAGMENT *FragPtr;
 		COUNT Index;
 		BYTE tmpb;
 
 		cread_16 (fh, &Index);
 
-		if (pQueue == &GLOBAL (avail_race_q))
-			hStarShip = GetStarShipFromIndex (pQueue, Index);
-		else
-			hStarShip = CloneShipFragment (Index, pQueue, 0);
+		hStarShip = CloneShipFragment (Index, pQueue, 0);
+		FragPtr = LockShipFrag (pQueue, hStarShip);
 
-		FragPtr = (SHIP_FRAGMENTPTR)LockStarShip (pQueue, hStarShip);
+		// Read SHIP_FRAGMENT elements
+		cread_16 (fh, &FragPtr->which_side);
+		cread_8  (fh, &FragPtr->captains_name_index);
+		cread_8  (fh, NULL); /* padding */
+		cread_16 (fh, NULL); /* unused: was ship_flags */
+		cread_8  (fh, &FragPtr->race_id);
+		cread_8  (fh, &FragPtr->index);
+		// XXX: reading crew as BYTE to maintain savegame compatibility
+		cread_8  (fh, &tmpb);
+		FragPtr->crew_level = tmpb;
+		cread_8  (fh, &tmpb);
+		FragPtr->max_crew = tmpb;
+		cread_8  (fh, &FragPtr->energy_level);
+		cread_8  (fh, &FragPtr->max_energy);
+		cread_16 (fh, NULL); /* unused; was loc.x */
+		cread_16 (fh, NULL); /* unused; was loc.y */
 
-		if (pQueue != &GLOBAL (avail_race_q))
-		{	// queues other than avail_race_q save SHIP_FRAGMENT elements
-			// Read SHIP_FRAGMENT elements
-			cread_16 (fh, &FragPtr->s.Player);
-			cread_8  (fh, &FragPtr->s.Captain);
-			cread_8  (fh, NULL); /* padding */
-		}
-		// Read SHIP_INFO elements
-		cread_16 (fh, &FragPtr->ShipInfo.ship_flags);
-		cread_8  (fh, &FragPtr->ShipInfo.var1);
-		cread_8  (fh, &FragPtr->ShipInfo.var2);
+		UnlockShipFrag (pQueue, hStarShip);
+	}
+}
+
+static void
+LoadRaceQueue (DECODE_REF fh, QUEUE *pQueue)
+{
+	COUNT num_links;
+
+	cread_16 (fh, &num_links);
+
+	while (num_links--)
+	{
+		HFLEETINFO hStarShip;
+		FLEET_INFO *FleetPtr;
+		COUNT Index;
+		BYTE tmpb;
+
+		cread_16 (fh, &Index);
+
+		hStarShip = GetStarShipFromIndex (pQueue, Index);
+		FleetPtr = LockFleetInfo (pQueue, hStarShip);
+
+		// Read FLEET_INFO elements
+		cread_16 (fh, &FleetPtr->ship_flags);
+		cread_8  (fh, &FleetPtr->days_left);
+		cread_8  (fh, &FleetPtr->growth_fract);
 		cread_8  (fh, &tmpb);
-		FragPtr->ShipInfo.crew_level = tmpb;
+		FleetPtr->crew_level = tmpb;
 		cread_8  (fh, &tmpb);
-		FragPtr->ShipInfo.max_crew = tmpb;
-		cread_8  (fh, &FragPtr->ShipInfo.energy_level);
-		cread_8  (fh, &FragPtr->ShipInfo.max_energy);
-		cread_16 (fh, &FragPtr->ShipInfo.loc.x);
-		cread_16 (fh, &FragPtr->ShipInfo.loc.y);
+		FleetPtr->max_crew = tmpb;
+		cread_8  (fh, &FleetPtr->growth);
+		cread_8  (fh, &FleetPtr->max_energy);
+		cread_16 (fh, &FleetPtr->loc.x);
+		cread_16 (fh, &FleetPtr->loc.y);
+
+		cread_16 (fh, &FleetPtr->actual_strength);
+		cread_16 (fh, &FleetPtr->known_strength);
+		cread_16 (fh, &FleetPtr->known_loc.x);
+		cread_16 (fh, &FleetPtr->known_loc.y);
+		cread_8  (fh, &FleetPtr->growth_err_term);
+		cread_8  (fh, &FleetPtr->func_index);
+		cread_16 (fh, &FleetPtr->dest_loc.x);
+		cread_16 (fh, &FleetPtr->dest_loc.y);
+		cread_16 (fh, NULL); /* alignment padding */
 
-		if (pQueue == &GLOBAL (avail_race_q))
-		{
-			// avail_race_q contains information not about specific ships,
-			// but about a race.
-			EXTENDED_SHIP_FRAGMENTPTR ExtFragPtr =
-					(EXTENDED_SHIP_FRAGMENTPTR) FragPtr;
-
-			cread_16 (fh, &ExtFragPtr->ShipInfo.actual_strength);
-			cread_16 (fh, &ExtFragPtr->ShipInfo.known_strength);
-			cread_16 (fh, &ExtFragPtr->ShipInfo.known_loc.x);
-			cread_16 (fh, &ExtFragPtr->ShipInfo.known_loc.y);
-			cread_8  (fh, &ExtFragPtr->ShipInfo.growth_err_term);
-			cread_8  (fh, &ExtFragPtr->ShipInfo.func_index);
-			cread_16 (fh, &ExtFragPtr->ShipInfo.dest_loc.x);
-			cread_16 (fh, &ExtFragPtr->ShipInfo.dest_loc.y);
-			cread_16 (fh, NULL); /* alignment padding */
-		}
+		UnlockFleetInfo (pQueue, hStarShip);
+	}
+}
+
+static void
+LoadGroupQueue (DECODE_REF fh, QUEUE *pQueue)
+{
+	COUNT num_links;
 
-		UnlockStarShip (pQueue, hStarShip);
+	cread_16 (fh, &num_links);
+
+	while (num_links--)
+	{
+		HIPGROUP hGroup;
+		IP_GROUP *GroupPtr;
+		BYTE tmpb;
+
+		cread_16 (fh, NULL); /* unused; was race_id */
+
+		hGroup = BuildGroup (pQueue, 0);
+		GroupPtr = LockIpGroup (pQueue, hGroup);
+
+		cread_16 (fh, NULL); /* unused; was which_side */
+		cread_8  (fh, NULL); /* unused; was captains_name_index */
+		cread_8  (fh, NULL); /* padding; for savegame compat */
+		cread_16 (fh, &GroupPtr->group_counter);
+		cread_8  (fh, &GroupPtr->race_id);
+		cread_8  (fh, &tmpb); /* was var2 */
+		GroupPtr->sys_loc = LONIBBLE (tmpb);
+		GroupPtr->task = HINIBBLE (tmpb);
+		cread_8  (fh, &GroupPtr->in_system); /* was crew_level */
+		cread_8  (fh, NULL); /* unused; was max_crew */
+		cread_8  (fh, &tmpb); /* was energy_level */
+		GroupPtr->dest_loc = LONIBBLE (tmpb);
+		GroupPtr->orbit_pos = HINIBBLE (tmpb);
+		cread_8  (fh, &GroupPtr->group_id); /* was max_energy */
+		cread_16 (fh, &GroupPtr->loc.x);
+		cread_16 (fh, &GroupPtr->loc.y);
+
+		UnlockIpGroup (pQueue, hGroup);
 	}
 }
 
 static void
-LoadEncounter (ENCOUNTERPTR EncounterPtr, DECODE_REF fh)
+LoadEncounter (ENCOUNTER *EncounterPtr, DECODE_REF fh)
 {
 	COUNT i;
 
@@ -215,45 +290,43 @@ LoadEncounter (ENCOUNTERPTR EncounterPtr
 	cread_16  (fh, &EncounterPtr->origin.x);
 	cread_16  (fh, &EncounterPtr->origin.y);
 	cread_16  (fh, &EncounterPtr->radius);
-	// EXTENDED_STAR_DESC fields
+	// STAR_DESC fields
 	cread_16  (fh, &EncounterPtr->SD.star_pt.x);
 	cread_16  (fh, &EncounterPtr->SD.star_pt.y);
 	cread_8   (fh, &EncounterPtr->SD.Type);
 	cread_8   (fh, &EncounterPtr->SD.Index);
 	cread_16  (fh, NULL); /* alignment padding */
 
-	// Load each entry in the SHIP_INFO array:
+	// Load each entry in the BRIEF_SHIP_INFO array
 	for (i = 0; i < MAX_HYPER_SHIPS; i++)
 	{
-		SHIP_INFOPTR ShipInfo = &EncounterPtr->SD.ShipList[i];
+		BRIEF_SHIP_INFO *ShipInfo = &EncounterPtr->ShipList[i];
 		BYTE tmpb;
 
-		cread_16  (fh, &ShipInfo->ship_flags);
-		cread_8   (fh, &ShipInfo->var1);
-		cread_8   (fh, &ShipInfo->var2);
+		cread_16  (fh, NULL); /* useless; was SHIP_INFO.ship_flags */
+		cread_8   (fh, &ShipInfo->race_id);
+		cread_8   (fh, NULL); /* useless; was SHIP_INFO.var2 */
+		// XXX: reading crew as BYTE to maintain savegame compatibility
 		cread_8   (fh, &tmpb);
 		ShipInfo->crew_level = tmpb;
 		cread_8   (fh, &tmpb);
 		ShipInfo->max_crew = tmpb;
-		cread_8   (fh, &ShipInfo->energy_level);
+		cread_8   (fh, NULL); /* useless; was SHIP_INFO.energy_level */
 		cread_8   (fh, &ShipInfo->max_energy);
-		cread_16  (fh, &ShipInfo->loc.x);
-		cread_16  (fh, &ShipInfo->loc.y);
+		cread_16  (fh, NULL); /* useless; was SHIP_INFO.loc.x */
+		cread_16  (fh, NULL); /* useless; was SHIP_INFO.loc.y */
 		cread_32  (fh, NULL); /* useless val; STRING race_strings */
-		ShipInfo->race_strings = 0;
 		cread_ptr (fh); /* useless ptr; FRAME icons */
-		ShipInfo->icons = 0;
 		cread_ptr (fh); /* useless ptr; FRAME melee_icon */
-		ShipInfo->melee_icon = 0;
 	}
 	
-	// Load the stuff after the SHIP_INFO array:
+	// Load the stuff after the BRIEF_SHIP_INFO array
 	cread_32  (fh, &EncounterPtr->log_x);
 	cread_32  (fh, &EncounterPtr->log_y);
 }
 
 static void
-LoadEvent (EVENTPTR EventPtr, DECODE_REF fh)
+LoadEvent (EVENT *EventPtr, DECODE_REF fh)
 {
 	cread_ptr (fh); /* useless ptr; HEVENT pred */
 	EventPtr->pred = 0;
@@ -268,7 +341,7 @@ LoadEvent (EVENTPTR EventPtr, DECODE_REF
 }
 
 static void
-DummyLoadQueue (PQUEUE QueuePtr, DECODE_REF fh)
+DummyLoadQueue (QUEUE *QueuePtr, DECODE_REF fh)
 {
 	/* QUEUE should never actually be loaded since it contains
 	 * purely internal representation and the lists
@@ -278,7 +351,7 @@ DummyLoadQueue (PQUEUE QueuePtr, DECODE_
 	/* QUEUE format with QUEUE_TABLE defined -- UQM default */
 	cread_ptr (fh); /* HLINK head */
 	cread_ptr (fh); /* HLINK tail */
-	cread_ptr (fh); /* PBYTE pq_tab */
+	cread_ptr (fh); /* BYTE* pq_tab */
 	cread_ptr (fh); /* HLINK free_list */
 	cread_16  (fh, NULL); /* MEM_HANDLE hq_tab */
 	cread_16  (fh, NULL); /* COUNT object_size */
@@ -289,7 +362,7 @@ DummyLoadQueue (PQUEUE QueuePtr, DECODE_
 }
 
 static void
-LoadClockState (PCLOCK_STATE ClockPtr, DECODE_REF fh)
+LoadClockState (CLOCK_STATE *ClockPtr, DECODE_REF fh)
 {
 	cread_8   (fh, &ClockPtr->day_index);
 	cread_8   (fh, &ClockPtr->month_index);
@@ -304,17 +377,18 @@ LoadClockState (PCLOCK_STATE ClockPtr, D
 }
 
 static void
-LoadGameState (PGAME_STATE GSPtr, DECODE_REF fh)
+LoadGameState (GAME_STATE *GSPtr, DECODE_REF fh)
 {
+	BYTE dummy8;
 	DWORD tmpd;
 
-	cread_8   (fh, &GSPtr->cur_state); /* obsolete */
+	cread_8   (fh, &dummy8); /* obsolete */
 	cread_8   (fh, &GSPtr->glob_flags);
 	cread_8   (fh, &GSPtr->CrewCost);
 	cread_8   (fh, &GSPtr->FuelCost);
 	cread_a8  (fh, GSPtr->ModuleCost, NUM_MODULES);
 	cread_a8  (fh, GSPtr->ElementWorth, NUM_ELEMENT_CATEGORIES);
-	cread_ptr (fh); /* not loading ptr; PPRIMITIVE DisplayArray */
+	cread_ptr (fh); /* not loading ptr; PRIMITIVE *DisplayArray */
 	cread_16  (fh, &GSPtr->CurrentActivity);
 	
 	cread_16  (fh, NULL); /* CLOCK_STATE alignment padding */
@@ -346,6 +420,7 @@ LoadGameState (PGAME_STATE GSPtr, DECODE
 	
 	DummyLoadQueue (&GSPtr->avail_race_q, fh);
 	DummyLoadQueue (&GSPtr->npc_built_ship_q, fh);
+	// Not loading ip_group_q, was not there originally
 	DummyLoadQueue (&GSPtr->encounter_q, fh);
 	DummyLoadQueue (&GSPtr->built_ship_q, fh);
 
@@ -356,7 +431,7 @@ LoadGameState (PGAME_STATE GSPtr, DECODE
 }
 
 static BOOLEAN
-LoadSisState (PSIS_STATE SSPtr, PVOID fp)
+LoadSisState (SIS_STATE *SSPtr, void *fp)
 {
 	if (
 			read_32  (fp, &SSPtr->log_x) != 1 ||
@@ -384,7 +459,7 @@ LoadSisState (PSIS_STATE SSPtr, PVOID fp
 }
 
 static BOOLEAN
-LoadSummary (SUMMARY_DESC *SummPtr, PVOID fp)
+LoadSummary (SUMMARY_DESC *SummPtr, void *fp)
 {
 	if (!LoadSisState (&SummPtr->SS, fp))
 		return FALSE;
@@ -410,7 +485,7 @@ LoadSummary (SUMMARY_DESC *SummPtr, PVOI
 }
 
 static void
-LoadStarDesc (STAR_DESCPTR SDPtr, DECODE_REF fh)
+LoadStarDesc (STAR_DESC *SDPtr, DECODE_REF fh)
 {
 	cread_16 (fh, &SDPtr->star_pt.x);
 	cread_16 (fh, &SDPtr->star_pt.y);
@@ -481,6 +556,7 @@ LoadGame (COUNT which_game, SUMMARY_DESC
 
 	ReinitQueue (&GLOBAL (GameClock.event_q));
 	ReinitQueue (&GLOBAL (encounter_q));
+	ReinitQueue (&GLOBAL (ip_group_q));
 	ReinitQueue (&GLOBAL (npc_built_ship_q));
 	ReinitQueue (&GLOBAL (built_ship_q));
 
@@ -498,10 +574,26 @@ LoadGame (COUNT which_game, SUMMARY_DESC
 				"save, Savegame may be corrupt!\n");
 	GLOBAL (GameClock.TimeCounter) = 0;
 
-	LoadShipQueue (fh, &GLOBAL (avail_race_q), FALSE);
+	LoadRaceQueue (fh, &GLOBAL (avail_race_q));
+	// START_INTERPLANETARY is only set when saving from Homeworld
+	//   encounter screen. When the game is loaded, GENERATE_ORBITAL will
+	//   create the encounter anew and populate the npc queue.
 	if (!(NextActivity & START_INTERPLANETARY))
-		LoadShipQueue (fh, &GLOBAL (npc_built_ship_q), FALSE);
-	LoadShipQueue (fh, &GLOBAL (built_ship_q), FALSE);
+	{
+		if (NextActivity & START_ENCOUNTER)
+			LoadShipQueue (fh, &GLOBAL (npc_built_ship_q));
+		else if (LOBYTE (NextActivity) == IN_INTERPLANETARY)
+			// XXX: Technically, this queue does not need to be
+			//   saved/loaded at all. IP groups will be reloaded
+			//   from group state files. But the original code did,
+			//   and so will we until we can prove we do not need to.
+			LoadGroupQueue (fh, &GLOBAL (ip_group_q));
+		else
+			// XXX: The empty queue read is only needed to maintain
+			//   the savegame compatibility
+			LoadEmptyQueue (fh);
+	}
+	LoadShipQueue (fh, &GLOBAL (built_ship_q));
 
 	// Load the game events (compressed)
 	cread_16 (fh, &num_links);
@@ -512,7 +604,7 @@ LoadGame (COUNT which_game, SUMMARY_DESC
 		while (num_links--)
 		{
 			HEVENT hEvent;
-			EVENTPTR EventPtr;
+			EVENT *EventPtr;
 
 			hEvent = AllocEvent ();
 			LockEvent (hEvent, &EventPtr);
@@ -536,35 +628,14 @@ LoadGame (COUNT which_game, SUMMARY_DESC
 	{
 		while (num_links--)
 		{
-			BYTE i, NumShips;
 			HENCOUNTER hEncounter;
-			ENCOUNTERPTR EncounterPtr;
+			ENCOUNTER *EncounterPtr;
 
 			hEncounter = AllocEncounter ();
 			LockEncounter (hEncounter, &EncounterPtr);
 
 			LoadEncounter (EncounterPtr, fh);
 
-			NumShips = LONIBBLE (EncounterPtr->SD.Index);
-			for (i = 0; i < NumShips; ++i)
-			{
-				HSTARSHIP hStarShip;
-				SHIP_FRAGMENTPTR TemplatePtr;
-
-				hStarShip = GetStarShipFromIndex (
-						&GLOBAL (avail_race_q),
-						EncounterPtr->SD.ShipList[i].var1);
-				TemplatePtr = (SHIP_FRAGMENTPTR)LockStarShip (
-						&GLOBAL (avail_race_q), hStarShip);
-				EncounterPtr->SD.ShipList[i].race_strings =
-						TemplatePtr->ShipInfo.race_strings;
-				EncounterPtr->SD.ShipList[i].icons =
-						TemplatePtr->ShipInfo.icons;
-				EncounterPtr->SD.ShipList[i].melee_icon =
-						TemplatePtr->ShipInfo.melee_icon;
-				UnlockStarShip (&GLOBAL (avail_race_q), hStarShip);
-			}
-
 			UnlockEncounter (hEncounter);
 			PutEncounter (hEncounter);
 		}
diff -ruNp src.orig/sc2code/loadmele.c src/sc2code/loadmele.c
--- src.orig/sc2code/loadmele.c	1969-12-31 18:00:00 -0600
+++ src/sc2code/loadmele.c	2017-11-08 16:50:01 -0600
@@ -0,0 +1,834 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+// This file handles loading of teams, but the UI and the actual loading.
+
+#include "melee.h"
+
+#include "controls.h"
+#include "gameopt.h"
+#include "gamestr.h"
+#include "globdata.h"
+#include "master.h"
+#include "save.h"
+#include "setup.h"
+#include "sounds.h"
+#include "options.h"
+#include "libs/log.h"
+#include "libs/misc.h"
+
+
+#define LOAD_TEAM_NAME_TEXT_COLOR \
+		BUILD_COLOR (MAKE_RGB15 (0x0F, 0x10, 0x1B), 0x00)
+#define LOAD_TEAM_NAME_TEXT_COLOR_HILITE \
+		BUILD_COLOR (MAKE_RGB15 (0x17, 0x18, 0x1D), 0x00)
+
+
+#define LOAD_MELEE_BOX_WIDTH 34
+#define LOAD_MELEE_BOX_HEIGHT 34
+#define LOAD_MELEE_BOX_SPACE 1
+
+
+static void DrawFileStrings (MELEE_STATE *pMS);
+static bool FillFileView (MELEE_STATE *pMS);
+
+
+bool
+ReadTeamImage (TEAM_IMAGE *pTI, uio_Stream *load_fp)
+{
+	int status;
+	FleetShipIndex i;
+	
+	status = ReadResFile (pTI, sizeof (*pTI), 1, load_fp);
+	if (status != 1)
+		return false;
+
+	// Sanity check on the entries.
+	for (i = 0; i < MELEE_FLEET_SIZE; i++)
+	{
+		BYTE StarShip = pTI->ShipList[i];
+
+		if (StarShip == MELEE_NONE)
+			continue;
+
+		if (StarShip >= NUM_MELEE_SHIPS)
+		{
+			log_add (log_Warning, "Invalid ship type in loaded team (index "
+					"%d, ship type is %d, max valid is %d).",
+					i, StarShip, NUM_MELEE_SHIPS - 1);
+			pTI->ShipList[i] = MELEE_NONE;
+		}
+	}
+
+	return true;
+}
+
+static bool
+LoadTeamImage (DIRENTRY DirEntry, TEAM_IMAGE *pTI)
+{
+	const BYTE *fileName;
+	uio_Stream *load_fp;
+	bool status;
+
+	fileName = GetDirEntryAddress (DirEntry);
+	load_fp = res_OpenResFile (meleeDir, (const char *) fileName, "rb");
+	if (load_fp == 0)
+		return false;
+
+	if (LengthResFile (load_fp) != sizeof (*pTI))
+		status = false;
+	else
+		status = ReadTeamImage (pTI, load_fp);
+	res_CloseResFile (load_fp);
+
+	return status;
+}
+
+#if 0  /* Not used */
+static void
+UnindexFleet (MELEE_STATE *pMS, COUNT index)
+{
+	assert (index < pMS->load.numIndices);
+	pMS->load.numIndices--;
+	memmove (&pMS->load.entryIndices[index],
+			&pMS->load.entryIndices[index + 1],
+			(pMS->load.numIndices - index) * sizeof pMS->load.entryIndices[0]);
+}
+#endif
+
+static void
+UnindexFleets (MELEE_STATE *pMS, COUNT index, COUNT count)
+{
+	assert (index + count <= pMS->load.numIndices);
+
+	pMS->load.numIndices -= count;
+	memmove (&pMS->load.entryIndices[index],
+			&pMS->load.entryIndices[index + count],
+			(pMS->load.numIndices - index) * sizeof pMS->load.entryIndices[0]);
+}
+
+static bool
+GetFleetByIndex (MELEE_STATE *pMS, COUNT index, TEAM_IMAGE *result)
+{
+	COUNT firstIndex;
+
+	if (index < pMS->load.preBuiltCount)
+	{
+		*result = pMS->load.preBuiltList[index];
+		return true;
+	}
+
+	index -= pMS->load.preBuiltCount;
+	firstIndex = index;
+
+	for ( ; index < pMS->load.numIndices; index++)
+	{
+		DIRENTRY entry = SetAbsDirEntryTableIndex (pMS->load.dirEntries,
+				pMS->load.entryIndices[index]);
+		if (LoadTeamImage (entry, result))
+			break;  // Success
+
+		{
+			const BYTE *fileName;
+			fileName = GetDirEntryAddress (entry);
+			log_add (log_Warning, "Warning: File '%s' is not a valid "
+					"SuperMelee team.", fileName);
+		}
+	}
+
+	if (index != firstIndex)
+		UnindexFleets (pMS, firstIndex, index - firstIndex);
+
+	return index < pMS->load.numIndices;
+}
+
+// returns (COUNT) -1 if not found
+static COUNT
+GetFleetIndexByFileName (MELEE_STATE *pMS, const char *fileName)
+{
+	COUNT index;
+	
+	for (index = 0; index < pMS->load.numIndices; index++)
+	{
+		DIRENTRY entry = SetAbsDirEntryTableIndex (pMS->load.dirEntries,
+				pMS->load.entryIndices[index]);
+		const BYTE *entryName = GetDirEntryAddress (entry);
+
+		if (strcasecmp ((const char *) entryName, fileName) == 0)
+			return pMS->load.preBuiltCount + index;
+	}
+
+	return (COUNT) -1;
+}
+
+// Auxiliary function for DrawFileStrings
+// If drawShips is set the ships themselves are drawn, in addition to the
+// fleet name and value; if not, only the fleet name and value are drawn.
+// If highlite is set the text is drawn in the color used for highlighting.
+static void
+DrawFileString (TEAM_IMAGE *pTI, POINT *origin, BOOLEAN drawShips,
+		BOOLEAN highlite)
+{
+	SetContextForeGroundColor (highlite ?
+			LOAD_TEAM_NAME_TEXT_COLOR_HILITE : LOAD_TEAM_NAME_TEXT_COLOR);
+
+	// Print the name of the fleet
+	{
+		TEXT Text;
+
+		Text.baseline = *origin;
+		Text.align = ALIGN_LEFT;
+		Text.pStr = pTI->TeamName;
+		Text.CharCount = (COUNT)~0;
+		font_DrawText (&Text);
+	}
+
+	// Print the value of the fleet
+	{
+		TEXT Text;
+		UNICODE buf[60];
+
+		sprintf (buf, "%u", GetTeamValue (pTI));
+		Text.baseline = *origin;
+		Text.baseline.x += NUM_MELEE_COLUMNS *
+				(LOAD_MELEE_BOX_WIDTH + LOAD_MELEE_BOX_SPACE) - 1;
+		Text.align = ALIGN_RIGHT;
+		Text.pStr = buf;
+		Text.CharCount = (COUNT)~0;
+		font_DrawText (&Text);
+	}
+
+	// Draw the ships for the fleet
+	if (drawShips)
+	{
+		STAMP s;
+		FleetShipIndex index;
+
+		s.origin.x = origin->x + 1;
+		s.origin.y = origin->y + 4;
+		for (index = 0; index < MELEE_FLEET_SIZE; index++)
+		{
+			BYTE StarShip;
+				
+			StarShip = pTI->ShipList[index];
+			if (StarShip != MELEE_NONE)
+			{
+				s.frame = GetShipIconsFromIndex (StarShip);
+				DrawStamp (&s);
+				s.origin.x += 17;
+			}
+		}
+	}
+}
+
+// returns true if there are any entries in the view, in which case
+// pMS->load.bot gets set to the index of the bottom entry in the view.
+// returns false if not, in which case, the entire view remains unchanged.
+static bool
+FillFileView (MELEE_STATE *pMS)
+{
+	COUNT viewI;
+
+	for (viewI = 0; viewI < LOAD_TEAM_VIEW_SIZE; viewI++)
+	{
+		bool success = GetFleetByIndex (pMS, pMS->load.top + viewI,
+				&pMS->load.view[viewI]);
+		if (!success)
+			break;
+	}
+
+	if (viewI == 0)
+		return false;
+
+	pMS->load.bot = pMS->load.top + viewI;
+	return true;
+}
+
+#define FILE_STRING_ORIGIN_X  5
+#define FILE_STRING_ORIGIN_Y  34
+#define ENTRY_HEIGHT 32
+
+void
+SelectFileString (MELEE_STATE *pMS, bool hilite)
+{
+	CONTEXT OldContext;
+	POINT origin;
+	COUNT viewI;
+
+	viewI = pMS->load.cur - pMS->load.top;
+
+	OldContext = SetContext (SpaceContext);
+	SetContextFont (MicroFont);
+	BatchGraphics ();
+
+	origin.x = FILE_STRING_ORIGIN_X;
+	origin.y = FILE_STRING_ORIGIN_Y + viewI * ENTRY_HEIGHT;
+	DrawFileString (&pMS->load.view[viewI], &origin, FALSE, hilite);
+
+	UnbatchGraphics ();
+	SetContext (OldContext);
+}
+
+static void
+DrawFileStrings (MELEE_STATE *pMS)
+{
+	POINT origin;
+	CONTEXT OldContext;
+
+	origin.x = FILE_STRING_ORIGIN_X;
+	origin.y = FILE_STRING_ORIGIN_Y;
+		
+	OldContext = SetContext (SpaceContext);
+	SetContextFont (MicroFont);
+	BatchGraphics ();
+
+	DrawMeleeIcon (28);  /* The load team frame */
+
+	if (FillFileView (pMS))
+	{
+		COUNT i;
+		for (i = pMS->load.top; i < pMS->load.bot; i++) {
+			DrawFileString (&pMS->load.view[i - pMS->load.top], &origin,
+					TRUE, FALSE);
+			origin.y += ENTRY_HEIGHT;
+		}
+	}
+
+	UnbatchGraphics ();
+	SetContext (OldContext);
+}
+
+static void
+RefocusView (MELEE_STATE *pMS, COUNT index)
+{
+	assert (index < pMS->load.preBuiltCount + pMS->load.numIndices);
+		
+	pMS->load.cur = index;
+	if (index <= LOAD_TEAM_VIEW_SIZE / 2)
+		pMS->load.top = 0;
+	else
+		pMS->load.top = index - LOAD_TEAM_VIEW_SIZE / 2;
+}
+
+BOOLEAN
+DoLoadTeam (MELEE_STATE *pMS)
+{
+	if (GLOBAL (CurrentActivity) & CHECK_ABORT)
+		return FALSE;
+
+	SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN | MENU_SOUND_PAGEUP |
+			MENU_SOUND_PAGEDOWN, MENU_SOUND_SELECT);
+
+	if (!pMS->Initialized)
+	{
+		LockMutex (GraphicsLock);
+		DrawFileStrings (pMS);
+		SelectFileString (pMS, true);
+		pMS->Initialized = TRUE;
+		pMS->InputFunc = DoLoadTeam;
+		UnlockMutex (GraphicsLock);
+		return TRUE;
+	}
+
+	if (PulsedInputState.menu[KEY_MENU_SELECT] ||
+			PulsedInputState.menu[KEY_MENU_CANCEL])
+	{
+		if (PulsedInputState.menu[KEY_MENU_SELECT])
+		{
+			// Copy the selected fleet to the player.
+			pMS->SideState[pMS->side].TeamImage =
+					pMS->load.view[pMS->load.cur - pMS->load.top];
+			pMS->SideState[pMS->side].star_bucks =
+					GetTeamValue (&pMS->SideState[pMS->side].TeamImage);
+			entireFleetChanged (pMS, pMS->side);
+			teamStringChanged (pMS, pMS->side);
+		}
+
+		pMS->InputFunc = DoMelee;
+		{
+			RECT r;
+			
+			GetFrameRect (SetAbsFrameIndex (MeleeFrame, 28), &r);
+			LockMutex (GraphicsLock);
+			RepairMeleeFrame (&r);
+			UnlockMutex (GraphicsLock);
+		}
+		return TRUE;
+	}
+	
+	{
+		COUNT newTop = pMS->load.top;
+		COUNT newIndex = pMS->load.cur;
+
+		if (PulsedInputState.menu[KEY_MENU_UP])
+		{
+			if (newIndex > 0)
+			{
+				newIndex--;
+				if (newIndex < newTop)
+					newTop = (newTop < LOAD_TEAM_VIEW_SIZE) ?
+							0 : newTop - LOAD_TEAM_VIEW_SIZE;
+			}
+		}
+		else if (PulsedInputState.menu[KEY_MENU_DOWN])
+		{
+			COUNT numEntries = pMS->load.numIndices + pMS->load.preBuiltCount;
+			if (newIndex + 1 < numEntries)
+			{
+				newIndex++;
+				if (newIndex >= pMS->load.bot)
+					newTop = pMS->load.bot;
+			}
+		}
+		else if (PulsedInputState.menu[KEY_MENU_PAGE_UP])
+		{
+			newIndex = (newIndex < LOAD_TEAM_VIEW_SIZE) ?
+					0 : newIndex - LOAD_TEAM_VIEW_SIZE;
+			newTop = (newTop < LOAD_TEAM_VIEW_SIZE) ?
+					0 : newTop - LOAD_TEAM_VIEW_SIZE;
+		}
+		else if (PulsedInputState.menu[KEY_MENU_PAGE_DOWN])
+		{
+			COUNT numEntries = pMS->load.numIndices + pMS->load.preBuiltCount;
+			if (newIndex + LOAD_TEAM_VIEW_SIZE < numEntries)
+			{
+				newIndex += LOAD_TEAM_VIEW_SIZE;
+				newTop += LOAD_TEAM_VIEW_SIZE;
+			}
+			else
+			{
+				newIndex = numEntries - 1;
+				if (newTop + LOAD_TEAM_VIEW_SIZE < numEntries &&
+						numEntries > LOAD_TEAM_VIEW_SIZE)
+					newTop = numEntries - LOAD_TEAM_VIEW_SIZE;
+			}
+		}
+
+		if (newIndex != pMS->load.cur)
+		{
+			LockMutex (GraphicsLock);
+			if (newTop == pMS->load.top)
+				SelectFileString (pMS, false);
+			else
+			{
+				pMS->load.top = newTop;
+				DrawFileStrings (pMS);
+			}
+			pMS->load.cur = newIndex;
+			UnlockMutex (GraphicsLock);
+		}
+	}
+
+	return TRUE;
+}
+
+int
+WriteTeamImage (TEAM_IMAGE *pTI, uio_Stream *save_fp)
+{
+	return WriteResFile (pTI, sizeof (*pTI), 1, save_fp);
+}
+
+void
+SelectTeamByFileName (MELEE_STATE *pMS, const char *fileName)
+{
+	COUNT index = GetFleetIndexByFileName (pMS, fileName);
+	if (index == (COUNT) -1)
+		return;
+
+	RefocusView (pMS, index);
+}
+
+void
+LoadTeamList (MELEE_STATE *pMS)
+{
+	COUNT i;
+
+	DestroyDirEntryTable (ReleaseDirEntryTable (pMS->load.dirEntries));
+	pMS->load.dirEntries = CaptureDirEntryTable (
+			LoadDirEntryTable (meleeDir, "", ".mle", match_MATCH_SUFFIX));
+	
+	if (pMS->load.entryIndices != NULL)
+		HFree (pMS->load.entryIndices);
+	pMS->load.numIndices = GetDirEntryTableCount (pMS->load.dirEntries);
+	pMS->load.entryIndices = HMalloc (pMS->load.numIndices *
+			sizeof pMS->load.entryIndices[0]);
+	for (i = 0; i < pMS->load.numIndices; i++)
+		pMS->load.entryIndices[i] = i;
+}
+
+BOOLEAN
+DoSaveTeam (MELEE_STATE *pMS)
+{
+	STAMP MsgStamp;
+	char file[NAME_MAX];
+	uio_Stream *save_fp;
+	CONTEXT OldContext;
+
+	sprintf (file, "%s.mle", pMS->SideState[pMS->side].TeamImage.TeamName);
+
+	LockMutex (GraphicsLock);
+	OldContext = SetContext (ScreenContext);
+	ConfirmSaveLoad (&MsgStamp);
+	save_fp = res_OpenResFile (meleeDir, file, "wb");
+	if (save_fp)
+	{
+		BOOLEAN err;
+
+		err = (BOOLEAN)(WriteTeamImage (
+				&pMS->SideState[pMS->side].TeamImage, save_fp) == 0);
+		if (res_CloseResFile (save_fp) == 0)
+			err = TRUE;
+		if (err)
+			save_fp = 0;
+	}
+
+	pMS->load.top = 0;
+	pMS->load.cur = 0;
+
+	if (save_fp == 0)
+	{
+		DrawStamp (&MsgStamp);
+		DestroyDrawable (ReleaseDrawable (MsgStamp.frame));
+		SetContext (OldContext);
+		UnlockMutex (GraphicsLock);
+
+		DeleteResFile (meleeDir, file);
+		SaveProblem ();
+	}
+
+	LoadTeamList (pMS);
+	SelectTeamByFileName (pMS, file);
+
+	if (save_fp != 0)
+	{
+		DrawStamp (&MsgStamp);
+		DestroyDrawable (ReleaseDrawable (MsgStamp.frame));
+		SetContext (OldContext);
+		UnlockMutex (GraphicsLock);
+	}
+	
+	return (save_fp != 0);
+}
+
+static void
+InitPreBuilt (MELEE_STATE *pMS)
+{
+	TEAM_IMAGE *list;
+
+#define PREBUILT_COUNT 15
+	pMS->load.preBuiltList =
+			HMalloc (PREBUILT_COUNT * sizeof pMS->load.preBuiltList[0]);
+	pMS->load.preBuiltCount = PREBUILT_COUNT;
+#undef PREBUILT_COUNT
+
+	{
+		FleetShipIndex shipI = 0;
+		int fleetI;
+
+		for (fleetI = 0; fleetI < pMS->load.preBuiltCount; fleetI++)
+			for (shipI = 0; shipI < MELEE_FLEET_SIZE; shipI++)
+				pMS->load.preBuiltList[fleetI].ShipList[shipI] = MELEE_NONE;
+	}
+
+	list = pMS->load.preBuiltList;
+
+	{
+		/* "Balanced Team 1" */
+		FleetShipIndex i = 0;
+		utf8StringCopy (list->TeamName, sizeof (list->TeamName),
+				GAME_STRING (MELEE_STRING_BASE + 4));
+		list->ShipList[i++] = MELEE_ANDROSYNTH;
+		list->ShipList[i++] = MELEE_CHMMR;
+		list->ShipList[i++] = MELEE_DRUUGE;
+		list->ShipList[i++] = MELEE_URQUAN;
+		list->ShipList[i++] = MELEE_MELNORME;
+		list->ShipList[i++] = MELEE_ORZ;
+		list->ShipList[i++] = MELEE_SPATHI;
+		list->ShipList[i++] = MELEE_SYREEN;
+		list->ShipList[i++] = MELEE_UTWIG;
+		list++;
+	}
+
+	{
+		/* "Balanced Team 2" */
+		FleetShipIndex i = 0;
+		utf8StringCopy (list->TeamName, sizeof (list->TeamName),
+				GAME_STRING (MELEE_STRING_BASE + 5));
+		list->ShipList[i++] = MELEE_ARILOU;
+		list->ShipList[i++] = MELEE_CHENJESU;
+		list->ShipList[i++] = MELEE_EARTHLING;
+		list->ShipList[i++] = MELEE_KOHR_AH;
+		list->ShipList[i++] = MELEE_MYCON;
+		list->ShipList[i++] = MELEE_YEHAT;
+		list->ShipList[i++] = MELEE_PKUNK;
+		list->ShipList[i++] = MELEE_SUPOX;
+		list->ShipList[i++] = MELEE_THRADDASH;
+		list->ShipList[i++] = MELEE_ZOQFOTPIK;
+		list->ShipList[i++] = MELEE_SHOFIXTI;
+		list++;
+	}
+
+	{
+		/* "200 points" */
+		FleetShipIndex i = 0;
+		utf8StringCopy (list->TeamName, sizeof (list->TeamName),
+				GAME_STRING (MELEE_STRING_BASE + 6));
+		list->ShipList[i++] = MELEE_ANDROSYNTH;
+		list->ShipList[i++] = MELEE_CHMMR;
+		list->ShipList[i++] = MELEE_DRUUGE;
+		list->ShipList[i++] = MELEE_MELNORME;
+		list->ShipList[i++] = MELEE_EARTHLING;
+		list->ShipList[i++] = MELEE_KOHR_AH;
+		list->ShipList[i++] = MELEE_SUPOX;
+		list->ShipList[i++] = MELEE_ORZ;
+		list->ShipList[i++] = MELEE_SPATHI;
+		list->ShipList[i++] = MELEE_ILWRATH;
+		list->ShipList[i++] = MELEE_VUX;
+		list++;
+	}
+
+	{
+		/* "Behemoth Zenith" */
+		FleetShipIndex i = 0;
+		utf8StringCopy (list->TeamName, sizeof (list->TeamName),
+				GAME_STRING (MELEE_STRING_BASE + 7));
+		list->ShipList[i++] = MELEE_CHENJESU;
+		list->ShipList[i++] = MELEE_CHENJESU;
+		list->ShipList[i++] = MELEE_CHMMR;
+		list->ShipList[i++] = MELEE_CHMMR;
+		list->ShipList[i++] = MELEE_KOHR_AH;
+		list->ShipList[i++] = MELEE_KOHR_AH;
+		list->ShipList[i++] = MELEE_URQUAN;
+		list->ShipList[i++] = MELEE_URQUAN;
+		list->ShipList[i++] = MELEE_UTWIG;
+		list->ShipList[i++] = MELEE_UTWIG;
+		list++;
+	}
+
+	{
+		/* "The Peeled Eyes" */
+		FleetShipIndex i = 0;
+		utf8StringCopy (list->TeamName, sizeof (list->TeamName),
+				GAME_STRING (MELEE_STRING_BASE + 8));
+		list->ShipList[i++] = MELEE_URQUAN;
+		list->ShipList[i++] = MELEE_CHENJESU;
+		list->ShipList[i++] = MELEE_MYCON;
+		list->ShipList[i++] = MELEE_SYREEN;
+		list->ShipList[i++] = MELEE_ZOQFOTPIK;
+		list->ShipList[i++] = MELEE_SHOFIXTI;
+		list->ShipList[i++] = MELEE_EARTHLING;
+		list->ShipList[i++] = MELEE_KOHR_AH;
+		list->ShipList[i++] = MELEE_MELNORME;
+		list->ShipList[i++] = MELEE_DRUUGE;
+		list->ShipList[i++] = MELEE_PKUNK;
+		list->ShipList[i++] = MELEE_ORZ;
+		list++;
+	}
+
+	{
+		FleetShipIndex i = 0;
+		utf8StringCopy (list->TeamName, sizeof (list->TeamName),
+				"Ford's Fighters");
+		list->ShipList[i++] = MELEE_CHMMR;
+		list->ShipList[i++] = MELEE_ZOQFOTPIK;
+		list->ShipList[i++] = MELEE_MELNORME;
+		list->ShipList[i++] = MELEE_SUPOX;
+		list->ShipList[i++] = MELEE_UTWIG;
+		list->ShipList[i++] = MELEE_UMGAH;
+		list++;
+	}
+
+	{
+		FleetShipIndex i = 0;
+		utf8StringCopy (list->TeamName, sizeof (list->TeamName),
+				"Leyland's Lashers");
+		list->ShipList[i++] = MELEE_ANDROSYNTH;
+		list->ShipList[i++] = MELEE_EARTHLING;
+		list->ShipList[i++] = MELEE_MYCON;
+		list->ShipList[i++] = MELEE_ORZ;
+		list->ShipList[i++] = MELEE_URQUAN;
+		list++;
+	}
+
+	{
+		FleetShipIndex i = 0;
+		utf8StringCopy (list->TeamName, sizeof (list->TeamName),
+				"The Gregorizers 200");
+		list->ShipList[i++] = MELEE_ANDROSYNTH;
+		list->ShipList[i++] = MELEE_CHMMR;
+		list->ShipList[i++] = MELEE_DRUUGE;
+		list->ShipList[i++] = MELEE_MELNORME;
+		list->ShipList[i++] = MELEE_EARTHLING;
+		list->ShipList[i++] = MELEE_KOHR_AH;
+		list->ShipList[i++] = MELEE_SUPOX;
+		list->ShipList[i++] = MELEE_ORZ;
+		list->ShipList[i++] = MELEE_PKUNK;
+		list->ShipList[i++] = MELEE_SPATHI;
+		list++;
+	}
+
+	{
+		FleetShipIndex i = 0;
+		utf8StringCopy (list->TeamName, sizeof (list->TeamName),
+				"300 point Armada!");
+		list->ShipList[i++] = MELEE_ANDROSYNTH;
+		list->ShipList[i++] = MELEE_CHMMR;
+		list->ShipList[i++] = MELEE_CHENJESU;
+		list->ShipList[i++] = MELEE_DRUUGE;
+		list->ShipList[i++] = MELEE_EARTHLING;
+		list->ShipList[i++] = MELEE_KOHR_AH;
+		list->ShipList[i++] = MELEE_MELNORME;
+		list->ShipList[i++] = MELEE_MYCON;
+		list->ShipList[i++] = MELEE_ORZ;
+		list->ShipList[i++] = MELEE_PKUNK;
+		list->ShipList[i++] = MELEE_SPATHI;
+		list->ShipList[i++] = MELEE_SUPOX;
+		list->ShipList[i++] = MELEE_URQUAN;
+		list->ShipList[i++] = MELEE_YEHAT;
+		list++;
+	}
+
+	{
+		FleetShipIndex i = 0;
+		utf8StringCopy (list->TeamName, sizeof (list->TeamName),
+				"Little Dudes with Attitudes");
+		list->ShipList[i++] = MELEE_UMGAH;
+		list->ShipList[i++] = MELEE_THRADDASH;
+		list->ShipList[i++] = MELEE_SHOFIXTI;
+		list->ShipList[i++] = MELEE_EARTHLING;
+		list->ShipList[i++] = MELEE_VUX;
+		list->ShipList[i++] = MELEE_ZOQFOTPIK;
+		list++;
+	}
+
+	{
+		FleetShipIndex i = 0;
+		utf8StringCopy (list->TeamName, sizeof (list->TeamName),
+				"New Alliance Ships");
+		list->ShipList[i++] = MELEE_ARILOU;
+		list->ShipList[i++] = MELEE_CHMMR;
+		list->ShipList[i++] = MELEE_EARTHLING;
+		list->ShipList[i++] = MELEE_ORZ;
+		list->ShipList[i++] = MELEE_PKUNK;
+		list->ShipList[i++] = MELEE_SHOFIXTI;
+		list->ShipList[i++] = MELEE_SUPOX;
+		list->ShipList[i++] = MELEE_SYREEN;
+		list->ShipList[i++] = MELEE_UTWIG;
+		list->ShipList[i++] = MELEE_ZOQFOTPIK;
+		list->ShipList[i++] = MELEE_YEHAT;
+		list->ShipList[i++] = MELEE_DRUUGE;
+		list->ShipList[i++] = MELEE_THRADDASH;
+		list->ShipList[i++] = MELEE_SPATHI;
+		list++;
+	}
+
+	{
+		FleetShipIndex i = 0;
+		utf8StringCopy (list->TeamName, sizeof (list->TeamName),
+				"Old Alliance Ships");
+		list->ShipList[i++] = MELEE_ARILOU;
+		list->ShipList[i++] = MELEE_CHENJESU;
+		list->ShipList[i++] = MELEE_EARTHLING;
+		list->ShipList[i++] = MELEE_MMRNMHRM;
+		list->ShipList[i++] = MELEE_SHOFIXTI;
+		list->ShipList[i++] = MELEE_SYREEN;
+		list->ShipList[i++] = MELEE_YEHAT;
+		list++;
+	}
+
+	{
+		FleetShipIndex i = 0;
+		utf8StringCopy (list->TeamName, sizeof (list->TeamName),
+				"Old Hierarchy Ships");
+		list->ShipList[i++] = MELEE_ANDROSYNTH;
+		list->ShipList[i++] = MELEE_ILWRATH;
+		list->ShipList[i++] = MELEE_MYCON;
+		list->ShipList[i++] = MELEE_SPATHI;
+		list->ShipList[i++] = MELEE_UMGAH;
+		list->ShipList[i++] = MELEE_URQUAN;
+		list->ShipList[i++] = MELEE_VUX;
+		list++;
+	}
+
+	{
+		FleetShipIndex i = 0;
+		utf8StringCopy (list->TeamName, sizeof (list->TeamName),
+				"Star Control 1");
+		list->ShipList[i++] = MELEE_ANDROSYNTH;
+		list->ShipList[i++] = MELEE_ARILOU;
+		list->ShipList[i++] = MELEE_CHENJESU;
+		list->ShipList[i++] = MELEE_EARTHLING;
+		list->ShipList[i++] = MELEE_ILWRATH;
+		list->ShipList[i++] = MELEE_MMRNMHRM;
+		list->ShipList[i++] = MELEE_MYCON;
+		list->ShipList[i++] = MELEE_SHOFIXTI;
+		list->ShipList[i++] = MELEE_SPATHI;
+		list->ShipList[i++] = MELEE_SYREEN;
+		list->ShipList[i++] = MELEE_UMGAH;
+		list->ShipList[i++] = MELEE_URQUAN;
+		list->ShipList[i++] = MELEE_VUX;
+		list->ShipList[i++] = MELEE_YEHAT;
+		list++;
+	}
+
+	{
+		FleetShipIndex i = 0;
+		utf8StringCopy (list->TeamName, sizeof (list->TeamName),
+				"Star Control 2");
+		list->ShipList[i++] = MELEE_CHMMR;
+		list->ShipList[i++] = MELEE_DRUUGE;
+		list->ShipList[i++] = MELEE_KOHR_AH;
+		list->ShipList[i++] = MELEE_MELNORME;
+		list->ShipList[i++] = MELEE_ORZ;
+		list->ShipList[i++] = MELEE_PKUNK;
+		list->ShipList[i++] = MELEE_SLYLANDRO;
+		list->ShipList[i++] = MELEE_SUPOX;
+		list->ShipList[i++] = MELEE_THRADDASH;
+		list->ShipList[i++] = MELEE_UTWIG;
+		list->ShipList[i++] = MELEE_ZOQFOTPIK;
+		list->ShipList[i++] = MELEE_ZOQFOTPIK;
+		list->ShipList[i++] = MELEE_ZOQFOTPIK;
+		list->ShipList[i++] = MELEE_ZOQFOTPIK;
+		list++;
+	}
+
+	assert (list == pMS->load.preBuiltList + pMS->load.preBuiltCount);
+}
+
+static void
+UninitPreBuilt (MELEE_STATE *pMS) {
+	HFree (pMS->load.preBuiltList);
+	pMS->load.preBuiltCount = 0;
+}
+
+void
+InitMeleeLoadState (MELEE_STATE *pMS)
+{
+	pMS->load.entryIndices = NULL;
+	InitPreBuilt (pMS);
+}
+
+void
+UninitMeleeLoadState (MELEE_STATE *pMS)
+{
+	UninitPreBuilt (pMS);
+	if (pMS->load.entryIndices != NULL)
+		HFree (pMS->load.entryIndices);
+}
+
+
diff -ruNp src.orig/sc2code/loadmele.h src/sc2code/loadmele.h
--- src.orig/sc2code/loadmele.h	1969-12-31 18:00:00 -0600
+++ src/sc2code/loadmele.h	2017-11-08 16:50:01 -0600
@@ -0,0 +1,61 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _LOADMELE_H
+#define _LOADMELE_H
+
+#define LOAD_TEAM_VIEW_SIZE 5
+
+struct melee_load_state;
+
+#include "melee.h"
+
+struct melee_load_state
+{
+	TEAM_IMAGE *preBuiltList;
+	COUNT preBuiltCount;
+	
+	DIRENTRY dirEntries;
+	COUNT *entryIndices;
+	COUNT numIndices;
+
+	TEAM_IMAGE view[LOAD_TEAM_VIEW_SIZE];
+	COUNT top;
+			// Index of the first entry for the view.
+	COUNT bot;
+			// Index of the first entry past the end of the view.
+
+	COUNT cur;
+			// Index of the current position in the view.
+	COUNT viewSize;
+			// Number of entries in the view.
+};
+
+void InitMeleeLoadState (MELEE_STATE *pMS);
+void UninitMeleeLoadState (MELEE_STATE *pMS);
+
+BOOLEAN DoLoadTeam (MELEE_STATE *pMS);
+BOOLEAN DoSaveTeam (MELEE_STATE *pMS);
+bool ReadTeamImage (TEAM_IMAGE *pTI, uio_Stream *load_fp);
+int WriteTeamImage (TEAM_IMAGE *pTI, uio_Stream *save_fp);
+void SelectFileString (MELEE_STATE *pMS, bool hilite);
+void LoadTeamList (MELEE_STATE *pMS);
+
+#endif /* _LOADMELE_H */
+
+
diff -ruNp src.orig/sc2code/loadship.c src/sc2code/loadship.c
--- src.orig/sc2code/loadship.c	2017-11-08 16:49:34 -0600
+++ src/sc2code/loadship.c	2017-11-08 16:50:01 -0600
@@ -18,139 +18,148 @@
 
 #include "build.h"
 #include "coderes.h"
+#include "corecode.h"
 #include "globdata.h"
 #include "nameref.h"
 #include "races.h"
 
+static RESOURCE code_resources[] = {
+		NULL_RESOURCE,
+		ARILOU_CODE,
+		CHMMR_CODE,
+		HUMAN_CODE,
+		ORZ_CODE,
+		PKUNK_CODE,
+		SHOFIXTI_CODE,
+		SPATHI_CODE,
+		SUPOX_CODE,
+		THRADDASH_CODE,
+		UTWIG_CODE,
+		VUX_CODE,
+		YEHAT_CODE,
+		MELNORME_CODE,
+		DRUUGE_CODE,
+		ILWRATH_CODE,
+		MYCON_CODE,
+		SLYLANDRO_CODE,
+		UMGAH_CODE,
+		URQUAN_CODE,
+		ZOQFOTPIK_CODE,
+		SYREEN_CODE,
+		KOHR_AH_CODE,
+		ANDROSYNTH_CODE,
+		CHENJESU_CODE,
+		MMRNMHRM_CODE,
+		SIS_CODE,
+		SAMATRA_CODE,
+		PROBE_CODE };
 
-MEM_HANDLE
-load_ship (STARSHIPPTR StarShipPtr, BOOLEAN LoadBattleData)
+RACE_DESC *
+load_ship (SPECIES_ID SpeciesID, BOOLEAN LoadBattleData)
 {
-	BOOLEAN retval;
-	MEM_HANDLE h;
+	RACE_DESC *RDPtr = 0;
+	void *CodeRef;
+	
+	if (SpeciesID >= NUM_SPECIES_ID)
+		return NULL;
 
-	h = OpenResourceIndexInstance (StarShipPtr->RaceResIndex);
+	CodeRef = CaptureCodeRes (LoadCodeRes (code_resources[SpeciesID]),
+			&GlobData, (void **)(&RDPtr));
+			
+	if (!CodeRef)
+		goto BadLoad;
+	RDPtr->CodeRef = CodeRef;
+
+	RDPtr->ship_info.icons = CaptureDrawable (LoadGraphic (
+			RDPtr->ship_info.icons_rsc));
+	if (!RDPtr->ship_info.icons)
+	{
+		/* goto BadLoad */
+	}
+		
+	RDPtr->ship_info.melee_icon = CaptureDrawable (LoadGraphic (
+			RDPtr->ship_info.melee_icon_rsc));
+	if (!RDPtr->ship_info.melee_icon)
+	{
+		/* goto BadLoad */
+	}
+
+	RDPtr->ship_info.race_strings =	CaptureStringTable (LoadStringTable (
+			RDPtr->ship_info.race_strings_rsc));
+	if (!RDPtr->ship_info.race_strings)
+	{
+		/* goto BadLoad */
+	}
 
-	retval = FALSE;
-	if (h)
+	if (LoadBattleData)
 	{
-#define INITIAL_CODE_RES MAKE_RESOURCE (1, CODE, 0)
-		BYTE captains_name_index;
-		PVOID CodeRef;
-		MEM_HANDLE hOldIndex;
-		COUNT which_player;
-
-		captains_name_index = StarShipCaptain (StarShipPtr);
-		which_player = StarShipPlayer (StarShipPtr);
-		hOldIndex = SetResourceIndex (h);
-
-		CodeRef = CaptureCodeRes (LoadCodeRes (INITIAL_CODE_RES),
-				(PVOID)&GlobData, (PVOID)&StarShipPtr->RaceDescPtr);
-		if (CodeRef == 0)
+		DATA_STUFF *RawPtr = &RDPtr->ship_data;
+		if (!load_animation (RawPtr->ship,
+				RawPtr->ship_rsc[0],
+				RawPtr->ship_rsc[1],
+				RawPtr->ship_rsc[2]))
 			goto BadLoad;
-		StarShipPtr->RaceDescPtr->CodeRef = CodeRef;
 
-		StarShipPtr->RaceDescPtr->ship_info.icons =
-				CaptureDrawable (LoadGraphic (
-				(RESOURCE)StarShipPtr->RaceDescPtr->ship_info.icons));
-		if (StarShipPtr->RaceDescPtr->ship_info.icons == 0)
+		if (RawPtr->weapon_rsc[0] != NULL_RESOURCE)
 		{
-			/* goto BadLoad */
+			if (!load_animation (RawPtr->weapon,
+					RawPtr->weapon_rsc[0],
+					RawPtr->weapon_rsc[1],
+					RawPtr->weapon_rsc[2]))
+				goto BadLoad;
 		}
-			
-		StarShipPtr->RaceDescPtr->ship_info.melee_icon =
-				CaptureDrawable (LoadGraphic (
-				(RESOURCE)StarShipPtr->RaceDescPtr->ship_info.melee_icon));
-		if (StarShipPtr->RaceDescPtr->ship_info.melee_icon == 0)
+
+		if (RawPtr->special_rsc[0] != NULL_RESOURCE)
 		{
-			/* goto BadLoad */
+			if (!load_animation (RawPtr->special,
+					RawPtr->special_rsc[0],
+					RawPtr->special_rsc[1],
+					RawPtr->special_rsc[2]))
+				goto BadLoad;
 		}
 
-		StarShipPtr->RaceDescPtr->ship_info.race_strings =
-				CaptureStringTable (LoadStringTable (
-				(RESOURCE)StarShipPtr->RaceDescPtr->ship_info.race_strings));
-		if (StarShipPtr->RaceDescPtr->ship_info.race_strings == 0)
+		if (RawPtr->captain_control.captain_rsc != NULL_RESOURCE)
 		{
-			/* goto BadLoad */
+			RawPtr->captain_control.background = CaptureDrawable (LoadGraphic (
+					RawPtr->captain_control.captain_rsc));
+			if (!RawPtr->captain_control.background)
+				goto BadLoad;
 		}
 
-		if (LoadBattleData)
+		if (RawPtr->victory_ditty_rsc != NULL_RESOURCE)
 		{
-			DATA_STUFFPTR RawPtr;
-
-			StarShipPtr->captains_name_index = captains_name_index;
-			StarShipPtr->RaceDescPtr->ship_info.ship_flags |= which_player;
-
-			RawPtr = &StarShipPtr->RaceDescPtr->ship_data;
-			if (!load_animation (RawPtr->ship,
-					(RESOURCE)RawPtr->ship[0],
-					(RESOURCE)RawPtr->ship[1],
-					(RESOURCE)RawPtr->ship[2]))
+			RawPtr->victory_ditty =
+					LoadMusic (RawPtr->victory_ditty_rsc);
+			if (!RawPtr->victory_ditty)
 				goto BadLoad;
+		}
 
-			if (RawPtr->weapon[0] != 0)
-			{
-				if (!load_animation (RawPtr->weapon,
-						(RESOURCE)RawPtr->weapon[0],
-						(RESOURCE)RawPtr->weapon[1],
-						(RESOURCE)RawPtr->weapon[2]))
-					goto BadLoad;
-			}
-
-			if (RawPtr->special[0] != 0)
-			{
-				if (!load_animation (RawPtr->special,
-						(RESOURCE)RawPtr->special[0],
-						(RESOURCE)RawPtr->special[1],
-						(RESOURCE)RawPtr->special[2]))
-					goto BadLoad;
-			}
-
-			if (RawPtr->captain_control.background != 0)
-			{
-				RawPtr->captain_control.background =
-						CaptureDrawable (LoadGraphic (
-						(RESOURCE)RawPtr->captain_control.background));
-				if (RawPtr->captain_control.background == 0)
-					goto BadLoad;
-			}
-
-			if (RawPtr->victory_ditty != 0)
-			{
-				RawPtr->victory_ditty =
-						LoadMusic ((RESOURCE)RawPtr->victory_ditty);
-				if (RawPtr->victory_ditty == 0)
-					goto BadLoad;
-			}
-
-			if (RawPtr->ship_sounds != 0)
-			{
-				RawPtr->ship_sounds = CaptureSound (
-						LoadSound ((RESOURCE)RawPtr->ship_sounds));
-				if (RawPtr->ship_sounds == 0)
-					goto BadLoad;
-			}
-
-			if (StarShipPtr->RaceDescPtr->ship_info.icons)
-				StarShipPtr->silhouette = IncFrameIndex (
-						StarShipPtr->RaceDescPtr->ship_info.icons);
+		if (RawPtr->ship_sounds_rsc != NULL_RESOURCE)
+		{
+			RawPtr->ship_sounds = CaptureSound (
+					LoadSound (RawPtr->ship_sounds_rsc));
+			if (!RawPtr->ship_sounds)
+				goto BadLoad;
 		}
+	}
 
-		retval = TRUE;
+ExitFunc:
+	return RDPtr;
+
+	// TODO: We should really free the resources that did load here
 BadLoad:
-		SetResourceIndex (hOldIndex);
-		CloseResourceIndex (h);
-	}
+	if (CodeRef)
+		DestroyCodeRes (ReleaseCodeRes (CodeRef));
+
+	RDPtr = 0; /* failed */
 
-	return (retval);
+	goto ExitFunc;
 }
 
 void
-free_ship (STARSHIPPTR StarShipPtr, BOOLEAN FreeBattleData)
+free_ship (RACE_DESC *raceDescPtr, BOOLEAN FreeIconData,
+		BOOLEAN FreeBattleData)
 {
-	RACE_DESCPTR raceDescPtr = StarShipPtr->RaceDescPtr;
-	SHIP_INFO *shipInfo = &raceDescPtr->ship_info;
-
 	if (FreeBattleData)
 	{
 		DATA_STUFF *shipData = &raceDescPtr->ship_data;
@@ -161,17 +170,18 @@ free_ship (STARSHIPPTR StarShipPtr, BOOL
 
 		DestroyDrawable (
 				ReleaseDrawable (shipData->captain_control.background));
-		DestroyMusic ((MUSIC_REF)shipData->victory_ditty);
+		DestroyMusic (shipData->victory_ditty);
 		DestroySound (ReleaseSound (shipData->ship_sounds));
 	}
 
-	DestroyDrawable (ReleaseDrawable (shipInfo->melee_icon));
-	DestroyDrawable (ReleaseDrawable (shipInfo->icons));
-	DestroyStringTable (ReleaseStringTable (shipInfo->race_strings));
+	if (FreeIconData)
+	{
+		SHIP_INFO *shipInfo = &raceDescPtr->ship_info;
 
-	DestroyCodeRes (ReleaseCodeRes (raceDescPtr->CodeRef));
+		DestroyDrawable (ReleaseDrawable (shipInfo->melee_icon));
+		DestroyDrawable (ReleaseDrawable (shipInfo->icons));
+		DestroyStringTable (ReleaseStringTable (shipInfo->race_strings));
+	}
 
-	StarShipPtr->RaceDescPtr = 0;
+	DestroyCodeRes (ReleaseCodeRes (raceDescPtr->CodeRef));
 }
-
-
diff -ruNp src.orig/sc2code/master.c src/sc2code/master.c
--- src.orig/sc2code/master.c	2017-11-08 16:49:34 -0600
+++ src/sc2code/master.c	2017-11-08 16:50:01 -0600
@@ -27,123 +27,193 @@
 QUEUE master_q;
 
 void
-LoadMasterShipList (void)
+LoadMasterShipList (void (* YieldProcessing)(void))
 {
 	COUNT num_entries;
-	RES_TYPE rt;
-	RES_INSTANCE ri;
-	RES_PACKAGE rp;
-
-	rt = GET_TYPE (ARILOU_SHIP_INDEX);
-	ri = GET_INSTANCE (ARILOU_SHIP_INDEX);
-	rp = GET_PACKAGE (ARILOU_SHIP_INDEX);
-	InitQueue (&master_q, num_entries = NUM_MELEE_SHIPS, sizeof (SHIP_FRAGMENT));
+	SPECIES_ID s_id = ARILOU_ID;
+	num_entries = LAST_MELEE_ID - ARILOU_ID + 1;
+	InitQueue (&master_q, num_entries, sizeof (MASTER_SHIP_INFO));
 	while (num_entries--)
 	{
-		HSTARSHIP hBuiltShip;
+		HMASTERSHIP hBuiltShip;
+		char built_buf[30];
+		HMASTERSHIP hStarShip, hNextShip;
+		MASTER_SHIP_INFO *BuiltPtr;
+		RACE_DESC *RDPtr;
+
+		hBuiltShip = AllocLink (&master_q);
+		if (!hBuiltShip)
+			continue;
+
+		// Allow other things to run
+		//  supposedly, loading ship packages and data takes some time
+		if (YieldProcessing)
+			YieldProcessing ();
+
+		BuiltPtr = LockMasterShip (&master_q, hBuiltShip);
+		BuiltPtr->SpeciesID = s_id++;
+		RDPtr = load_ship (BuiltPtr->SpeciesID, FALSE);
+		if (!RDPtr)
+		{
+			UnlockMasterShip (&master_q, hBuiltShip);
+			continue;
+		}
 
-		hBuiltShip = Build (&master_q, MAKE_RESOURCE (rp++, rt, ri++), 0, 0);
-		if (hBuiltShip)
+		// Grab a copy of loaded icons, strings and info
+		// XXX: SHIP_INFO implicitly referenced here
+		BuiltPtr->ShipInfo = RDPtr->ship_info;
+		BuiltPtr->Fleet = RDPtr->fleet;
+		free_ship (RDPtr, FALSE, FALSE);
+
+		GetStringContents (SetAbsStringTableIndex (
+				BuiltPtr->ShipInfo.race_strings, 2
+				), (STRINGPTR)built_buf, FALSE);
+		UnlockMasterShip (&master_q, hBuiltShip);
+
+		// Insert the ship in the master queue in the right location
+		// to keep the list sorted on the name of the race.
+		for (hStarShip = GetHeadLink (&master_q);
+				hStarShip; hStarShip = hNextShip)
 		{
-			char built_buf[30];
-			HSTARSHIP hStarShip, hNextShip;
-			STARSHIPPTR BuiltShipPtr;
-			SHIP_INFOPTR ShipInfoPtr;
-
-			TaskSwitch ();
-					// XXX: what is this doing here?
-
-			BuiltShipPtr = LockStarShip (&master_q, hBuiltShip);
-			load_ship (BuiltShipPtr, FALSE);
-			ShipInfoPtr = &((SHIP_FRAGMENTPTR)BuiltShipPtr)->ShipInfo;
-			*ShipInfoPtr = BuiltShipPtr->RaceDescPtr->ship_info;
-			BuiltShipPtr->RaceDescPtr->ship_info.melee_icon = 0;
-			BuiltShipPtr->RaceDescPtr->ship_info.icons = 0;
-			BuiltShipPtr->RaceDescPtr->ship_info.race_strings = 0;
-			free_ship (BuiltShipPtr, FALSE);
-			BuiltShipPtr->RaceDescPtr = (RACE_DESCPTR)ShipInfoPtr;
+			char ship_buf[30];
+			MASTER_SHIP_INFO *MasterPtr;
 
+			MasterPtr = LockMasterShip (&master_q, hStarShip);
+			hNextShip = _GetSuccLink (MasterPtr);
 			GetStringContents (SetAbsStringTableIndex (
-					BuiltShipPtr->RaceDescPtr->ship_info.race_strings, 2
-					), (STRINGPTR)built_buf, FALSE);
-			UnlockStarShip (&master_q, hBuiltShip);
-
-			RemoveQueue (&master_q, hBuiltShip);
-
-			// Insert the ship in the master queue in the right location
-			// to keep the list sorted on the name of the race.
-			for (hStarShip = GetHeadLink (&master_q);
-					hStarShip; hStarShip = hNextShip)
-			{
-				char ship_buf[30];
-				STARSHIPPTR StarShipPtr;
-
-				StarShipPtr = LockStarShip (&master_q, hStarShip);
-				hNextShip = _GetSuccLink (StarShipPtr);
-				GetStringContents (SetAbsStringTableIndex (
-						StarShipPtr->RaceDescPtr->ship_info.race_strings, 2
-						), (STRINGPTR)ship_buf, FALSE);
-				UnlockStarShip (&master_q, hStarShip);
-
-				if (strcmp (built_buf, ship_buf) < 0)
-					break;
-			}
-			InsertQueue (&master_q, hBuiltShip, hStarShip);
+					MasterPtr->ShipInfo.race_strings, 2
+					), (STRINGPTR)ship_buf, FALSE);
+			UnlockMasterShip (&master_q, hStarShip);
+
+			if (strcmp (built_buf, ship_buf) < 0)
+				break;
 		}
+		InsertQueue (&master_q, hBuiltShip, hStarShip);
 	}
 }
 
 void
 FreeMasterShipList (void)
 {
-	HSTARSHIP hStarShip, hNextShip;
+	HMASTERSHIP hStarShip, hNextShip;
 
 	for (hStarShip = GetHeadLink (&master_q);
 			hStarShip != 0; hStarShip = hNextShip)
 	{
-		STARSHIPPTR StarShipPtr;
+		MASTER_SHIP_INFO *MasterPtr;
 
-		StarShipPtr = LockStarShip (&master_q, hStarShip);
-		hNextShip = _GetSuccLink (StarShipPtr);
+		MasterPtr = LockMasterShip (&master_q, hStarShip);
+		hNextShip = _GetSuccLink (MasterPtr);
 
-		DestroyDrawable (ReleaseDrawable (
-				StarShipPtr->RaceDescPtr->ship_info.melee_icon));
-		DestroyDrawable (ReleaseDrawable (
-				StarShipPtr->RaceDescPtr->ship_info.icons));
+		DestroyDrawable (ReleaseDrawable (MasterPtr->ShipInfo.melee_icon));
+		DestroyDrawable (ReleaseDrawable (MasterPtr->ShipInfo.icons));
 		DestroyStringTable (ReleaseStringTable (
-				StarShipPtr->RaceDescPtr->ship_info.race_strings));
+				MasterPtr->ShipInfo.race_strings));
 
-		UnlockStarShip (&master_q, hStarShip);
+		UnlockMasterShip (&master_q, hStarShip);
 	}
 
 	UninitQueue (&master_q);
 }
 
-HSTARSHIP
-FindMasterShip (DWORD ship_ref)
+HMASTERSHIP
+FindMasterShip (SPECIES_ID ship_ref)
 {
-	HSTARSHIP hStarShip;
+	HMASTERSHIP hStarShip, hNextShip;
 	
-	hStarShip = GetHeadLink (&master_q);
-	if (hStarShip)
+	for (hStarShip = GetHeadLink (&master_q); hStarShip; hStarShip = hNextShip)
 	{
-		do
-		{
-			DWORD ref;
-			HSTARSHIP hNextShip;
-			STARSHIPPTR StarShipPtr;
-
-			StarShipPtr = LockStarShip (&master_q, hStarShip);
-			hNextShip = _GetSuccLink (StarShipPtr);
-			ref = StarShipPtr->RaceResIndex;
-			UnlockStarShip (&master_q, hStarShip);
+		SPECIES_ID ref;
+		MASTER_SHIP_INFO *MasterPtr;
 
-			if (ref == ship_ref)
-				break;
+		MasterPtr = LockMasterShip (&master_q, hStarShip);
+		hNextShip = _GetSuccLink (MasterPtr);
+		ref = MasterPtr->SpeciesID;
+		UnlockMasterShip (&master_q, hStarShip);
 
-			hStarShip = hNextShip;
-		} while (hStarShip);
+		if (ref == ship_ref)
+			break;
 	}
 
 	return (hStarShip);
 }
+
+int
+FindMasterShipIndex (SPECIES_ID ship_ref)
+{
+	HMASTERSHIP hStarShip, hNextShip;
+	int index;
+	
+	for (index = 0, hStarShip = GetHeadLink (&master_q); hStarShip;
+			++index, hStarShip = hNextShip)
+	{
+		SPECIES_ID ref;
+		MASTER_SHIP_INFO *MasterPtr;
+
+		MasterPtr = LockMasterShip (&master_q, hStarShip);
+		hNextShip = _GetSuccLink (MasterPtr);
+		ref = MasterPtr->SpeciesID;
+		UnlockMasterShip (&master_q, hStarShip);
+
+		if (ref == ship_ref)
+			break;
+	}
+
+	return hStarShip ? index : -1;
+}
+
+COUNT
+GetShipCostFromIndex (unsigned Index)
+{
+	HMASTERSHIP hMasterShip;
+	MASTER_SHIP_INFO *MasterPtr;
+	COUNT val;
+
+	hMasterShip = GetStarShipFromIndex (&master_q, Index);
+	if (!hMasterShip)
+		return 0;
+
+	MasterPtr = LockMasterShip (&master_q, hMasterShip);
+	val = MasterPtr->ShipInfo.ship_cost;
+	UnlockMasterShip (&master_q, hMasterShip);
+
+	return val;
+}
+
+FRAME
+GetShipIconsFromIndex (unsigned Index)
+{
+	HMASTERSHIP hMasterShip;
+	MASTER_SHIP_INFO *MasterPtr;
+	FRAME val;
+
+	hMasterShip = GetStarShipFromIndex (&master_q, Index);
+	if (!hMasterShip)
+		return 0;
+
+	MasterPtr = LockMasterShip (&master_q, hMasterShip);
+	val = MasterPtr->ShipInfo.icons;
+	UnlockMasterShip (&master_q, hMasterShip);
+
+	return val;
+}
+
+FRAME
+GetShipMeleeIconsFromIndex (unsigned Index)
+{
+	HMASTERSHIP hMasterShip;
+	MASTER_SHIP_INFO *MasterPtr;
+	FRAME val;
+
+	hMasterShip = GetStarShipFromIndex (&master_q, Index);
+	if (!hMasterShip)
+		return 0;
+
+	MasterPtr = LockMasterShip (&master_q, hMasterShip);
+	val = MasterPtr->ShipInfo.melee_icon;
+	UnlockMasterShip (&master_q, hMasterShip);
+
+	return val;
+}
+
+
diff -ruNp src.orig/sc2code/master.h src/sc2code/master.h
--- src.orig/sc2code/master.h	2017-11-08 16:49:34 -0600
+++ src/sc2code/master.h	2017-11-08 16:50:01 -0600
@@ -20,10 +20,43 @@
 #include "races.h"
 #include "libs/compiler.h"
 
+typedef HLINK HMASTERSHIP;
 
-extern void LoadMasterShipList (void);
+typedef struct
+{
+	// LINK elements; must be first
+	HMASTERSHIP pred;
+	HMASTERSHIP succ;
+
+	SPECIES_ID SpeciesID;
+
+	SHIP_INFO ShipInfo;
+	FLEET_STUFF Fleet;
+			// FLEET_STUFF is only necessary here because avail_race_q
+			// is initialized in part from master_q (kinda hacky)
+} MASTER_SHIP_INFO;
+
+extern QUEUE master_q;
+		/* List of ships available in SuperMelee;
+		 * queue element is MASTER_SHIP_INFO */
+
+static inline MASTER_SHIP_INFO *
+LockMasterShip (const QUEUE *pq, HMASTERSHIP h)
+{
+	assert (GetLinkSize (pq) == sizeof (MASTER_SHIP_INFO));
+	return (MASTER_SHIP_INFO *) LockLink (pq, h);
+}
+
+#define UnlockMasterShip(pq, h) UnlockLink (pq, h)
+#define FreeMasterShip(pq, h) FreeLink (pq, h)
+
+extern void LoadMasterShipList (void (* YieldProcessing)(void));
 extern void FreeMasterShipList (void);
-extern HSTARSHIP FindMasterShip (DWORD ship_ref);
+extern HMASTERSHIP FindMasterShip (SPECIES_ID ship_ref);
+extern int FindMasterShipIndex (SPECIES_ID ship_ref);
+COUNT GetShipCostFromIndex (unsigned Index);
+FRAME GetShipIconsFromIndex (unsigned Index);
+FRAME GetShipMeleeIconsFromIndex (unsigned Index);
 
 #endif  /* _MASTER_H */
 
diff -ruNp src.orig/sc2code/melee.c src/sc2code/melee.c
--- src.orig/sc2code/melee.c	2017-11-08 16:49:34 -0600
+++ src/sc2code/melee.c	2017-11-08 16:50:01 -0600
@@ -22,12 +22,14 @@
 #include "colors.h"
 #include "comm.h"
 		// for getLineWithinWidth
+#include "cons_res.h"
 #include "controls.h"
 #include "file.h"
 #include "fmv.h"
 #include "gamestr.h"
 #include "globdata.h"
 #include "intel.h"
+#include "master.h"
 #include "nameref.h"
 #ifdef NETPLAY
 #	include "netplay/netconnection.h"
@@ -39,9 +41,7 @@
 #include "options.h"
 #include "races.h"
 #include "resinst.h"
-#include "save.h"
 #include "settings.h"
-#include "gameopt.h"
 #include "setup.h"
 #include "sounds.h"
 #include "util.h"
@@ -58,8 +58,8 @@
 #include <errno.h>
 
 
-static void DrawMeleeShipStrings (PMELEE_STATE pMS, BYTE NewStarShip);
-static void StartMelee (PMELEE_STATE pMS);
+static void DrawMeleeShipStrings (MELEE_STATE *pMS, BYTE NewStarShip);
+static void StartMelee (MELEE_STATE *pMS);
 static ssize_t numPlayersReady (void);
 
 static int flash_selection_func (void *data);
@@ -184,16 +184,17 @@ enum
 
 
 FRAME PickMeleeFrame;
-static FRAME MeleeFrame;
+FRAME MeleeFrame;
+		// Loaded from melee/melebkgd.ani
 static FRAME BuildPickFrame;
-extern QUEUE master_q;
+		// Constructed.
 DWORD InTime;
-PMELEE_STATE volatile pMeleeState;
+MELEE_STATE *pMeleeState;
 
-static BOOLEAN DoMelee (PMELEE_STATE pMS);
-static BOOLEAN DoEdit (PMELEE_STATE pMS);
-static BOOLEAN DoPickShip (PMELEE_STATE pMS);
-static BOOLEAN DoConfirmSettings (PMELEE_STATE pMS);
+BOOLEAN DoMelee (MELEE_STATE *pMS);
+static BOOLEAN DoEdit (MELEE_STATE *pMS);
+static BOOLEAN DoPickShip (MELEE_STATE *pMS);
+static BOOLEAN DoConfirmSettings (MELEE_STATE *pMS);
 
 #define DTSHS_NORMAL   0
 #define DTSHS_EDIT     1
@@ -201,25 +202,24 @@ static BOOLEAN DoConfirmSettings (PMELEE
 #define DTSHS_REPAIR   4
 #define DTSHS_BLOCKCUR 8
 
-static BOOLEAN DrawTeamString (PMELEE_STATE pMS, COUNT side,
+static BOOLEAN DrawTeamString (MELEE_STATE *pMS, COUNT side,
 		COUNT HiLiteState);
 
-static BOOLEAN DoLoadTeam (PMELEE_STATE pMS);
-static void DrawFileStrings (PMELEE_STATE pMS, int HiLiteState);
 
-
-static void
+// These icons come from melee/melebkgd.ani
+void
 DrawMeleeIcon (COUNT which_icon)
 {
 	STAMP s;
 			
-	s.origin.x = s.origin.y = 0;
+	s.origin.x = 0;
+	s.origin.y = 0;
 	s.frame = SetAbsFrameIndex (MeleeFrame, which_icon);
 	DrawStamp (&s);
 }
 
 static void
-GetShipBox (PRECT pRect, COUNT side, COUNT row, COUNT col)
+GetShipBox (RECT *pRect, COUNT side, COUNT row, COUNT col)
 {
 	pRect->corner.x = MELEE_X_OFFS
 			+ (col * (MELEE_BOX_WIDTH + MELEE_BOX_SPACE));
@@ -273,26 +273,20 @@ DrawShipBox (COUNT side, COUNT row, COUN
 	if (ship != MELEE_NONE)
 	{
 		STAMP s;
-		HSTARSHIP hStarShip;
-		STARSHIPPTR StarShipPtr;
-
-		hStarShip = GetStarShipFromIndex (&master_q, ship);
-		StarShipPtr = LockStarShip (&master_q, hStarShip);
 		s.origin.x = r.corner.x + (r.extent.width >> 1);
 		s.origin.y = r.corner.y + (r.extent.height >> 1);
-		s.frame = StarShipPtr->RaceDescPtr->ship_info.melee_icon;
+		s.frame = GetShipMeleeIconsFromIndex (ship);
 
 		DrawStamp (&s);
-		UnlockStarShip (&master_q, hStarShip);
 	}
 	UnbatchGraphics ();
 }
 
 static void
-DrawShipBoxCurrent (PMELEE_STATE pMS, BOOLEAN HiLite)
+DrawShipBoxCurrent (MELEE_STATE *pMS, BOOLEAN HiLite)
 {
 	FleetShipIndex index = GetShipIndex (pMS->row, pMS->col);
-	BYTE ship = pMS->TeamImage[pMS->side].ShipList[index];
+	BYTE ship = pMS->SideState[pMS->side].TeamImage.ShipList[index];
 	DrawShipBox (pMS->side, pMS->row, pMS->col, ship, HiLite);
 }
 
@@ -305,6 +299,7 @@ DrawControls (COUNT which_side, BOOLEAN
 	if (PlayerControl[which_side] & NETWORK_CONTROL)
 	{
 		DrawMeleeIcon (31 + (HiLite ? 1 : 0) + 2 * (1 - which_side));
+				/* "Network Control" */
 		return;
 	}
 	
@@ -335,7 +330,7 @@ DrawControls (COUNT which_side, BOOLEAN
 }
 
 static void
-DrawPickFrame (PMELEE_STATE pMS)
+DrawPickFrame (MELEE_STATE *pMS)
 {
 	RECT r, r0, r1, ship_r;
 	STAMP s;
@@ -363,8 +358,8 @@ DrawPickFrame (PMELEE_STATE pMS)
 	LockMutex (GraphicsLock);
 }
 
-static void
-RepairMeleeFrame (PRECT pRect)
+void
+RepairMeleeFrame (RECT *pRect)
 {
 	RECT r;
 	CONTEXT OldContext;
@@ -388,8 +383,8 @@ RepairMeleeFrame (PRECT pRect)
 
 	DrawMeleeIcon (0);   /* Entire melee screen */
 #ifdef NETPLAY
-	DrawMeleeIcon (35);
-	DrawMeleeIcon (37);
+	DrawMeleeIcon (35);  /* "Net..." (top, not highlighted) */
+	DrawMeleeIcon (37);  /* "Net..." (bottom, not highlighted) */
 #endif
 	DrawMeleeIcon (26);  /* "Battle!" (highlighted) */
 	{
@@ -405,7 +400,8 @@ RepairMeleeFrame (PRECT pRect)
 				for (col = 0; col < NUM_MELEE_COLUMNS; col++)
 				{
 					FleetShipIndex index = GetShipIndex (row, col);
-					BYTE ship = pMeleeState->TeamImage[side].ShipList[index];
+					BYTE ship = pMeleeState->SideState[side].TeamImage.
+							ShipList[index];
 					DrawShipBox (side, row, col, ship, FALSE);
 				}
 			}
@@ -428,7 +424,8 @@ RedrawMeleeFrame (void)
 {
 	RECT r;
 
-	r.corner.x = r.corner.y = 0;
+	r.corner.x = 0;
+	r.corner.y = 0;
 	r.extent.width = SCREEN_WIDTH;
 	r.extent.height = SCREEN_HEIGHT;
 
@@ -436,7 +433,7 @@ RedrawMeleeFrame (void)
 }
 
 static BOOLEAN
-DrawTeamString (PMELEE_STATE pMS, COUNT side, COUNT HiLiteState)
+DrawTeamString (MELEE_STATE *pMS, COUNT side, COUNT HiLiteState)
 {
 	RECT r;
 	TEXT lfText;
@@ -454,7 +451,7 @@ DrawTeamString (PMELEE_STATE pMS, COUNT
 		
 	SetContextFont (MicroFont);
 
-	lfText.pStr = pMS->TeamImage[side].TeamName;
+	lfText.pStr = pMS->SideState[side].TeamImage.TeamName;
 	lfText.baseline.y = r.corner.y + r.extent.height - 3;
 
 	lfText.baseline.x = r.corner.x + 1;
@@ -467,7 +464,7 @@ DrawTeamString (PMELEE_STATE pMS, COUNT
 		TEXT rtText;
 		UNICODE buf[30];
 
-		sprintf (buf, "%d", pMS->star_bucks[side]);
+		sprintf (buf, "%u", pMS->SideState[side].star_bucks);
 		rtText.pStr = buf;
 		rtText.align = ALIGN_RIGHT;
 		rtText.CharCount = (COUNT)~0;
@@ -484,7 +481,7 @@ DrawTeamString (PMELEE_STATE pMS, COUNT
 		COUNT i;
 		RECT text_r;
 		BYTE char_deltas[MAX_TEAM_CHARS];
-		PBYTE pchar_deltas;
+		BYTE *pchar_deltas;
 
 		// not drawing team bucks
 		r.extent.width -= 29;
@@ -547,17 +544,13 @@ static void
 DrawPickIcon (COUNT iship, BYTE DrawErase)
 {
 	STAMP s;
-	HSTARSHIP hStarShip;
-	STARSHIPPTR StarShipPtr;
 	RECT r;
 
 	GetFrameRect (BuildPickFrame, &r);
 
-	hStarShip = GetStarShipFromIndex (&master_q, iship);
-	StarShipPtr = LockStarShip (&master_q, hStarShip);
 	s.origin.x = r.corner.x + 20 + (iship % NUM_PICK_COLS) * 18;
 	s.origin.y = r.corner.y +  5 + (iship / NUM_PICK_COLS) * 18;
-	s.frame = StarShipPtr->RaceDescPtr->ship_info.icons;
+	s.frame = GetShipIconsFromIndex (iship);
 	if (DrawErase)
 	{	// draw icon
 		DrawStamp (&s);
@@ -570,14 +563,13 @@ DrawPickIcon (COUNT iship, BYTE DrawEras
 		DrawFilledStamp (&s);
 		SetContextForeGroundColor (OldColor);
 	}
-	UnlockStarShip (&master_q, hStarShip);
 }
 
 #ifdef NETPLAY
 // This function is generic. It should probably be moved to elsewhere.
 // The caller should hold the GraphicsLock.
 static void
-multiLineDrawText(TEXT *textIn, RECT *clipRect) {
+multiLineDrawText (TEXT *textIn, RECT *clipRect) {
 	RECT oldRect;
 
 	SIZE leading;
@@ -603,7 +595,7 @@ multiLineDrawText(TEXT *textIn, RECT *cl
 
 		text.baseline.y += leading;
 		text.CharCount = (COUNT) ~0;
-		getLineWithinWidth(&text, &nextLine, lineWidth, text.CharCount);
+		getLineWithinWidth (&text, &nextLine, lineWidth, text.CharCount);
 				// This will also fill in text->CharCount.
 			
 		font_DrawText (&text);
@@ -678,7 +670,7 @@ UpdateMeleeStatusMessage (ssize_t player
 					// "Unconnected. Press LEFT to connect."
 			break;
 		case NetState_connecting:
-			if (NetConnection_getPeerOptions(conn)->isServer)
+			if (NetConnection_getPeerOptions (conn)->isServer)
 				DrawMeleeStatusMessage (
 						GAME_STRING (NETMELEE_STRING_BASE + 1));
 						// "Awaiting incoming connection...\n"
@@ -715,25 +707,27 @@ Deselect (BYTE opt)
 		case LOAD_BOT:
 			if (pMeleeState->InputFunc != DoLoadTeam)
 				DrawMeleeIcon (opt == LOAD_TOP ? 17 : 22);
+						/* 17: "Load" (top, not highlighted) */
+						/* 22: "Load" (bottom, not highlighted) */
 			else
-				DrawFileStrings (pMeleeState, 0);
+				SelectFileString (pMeleeState, false);
 			break;
 		case SAVE_TOP:
-			DrawMeleeIcon (18);  /* "Save" (top; not highlighted) */
+			DrawMeleeIcon (18);  /* "Save" (top, not highlighted) */
 			break;
 		case SAVE_BOT:
-			DrawMeleeIcon (21);  /* "Save" (bottom; not highlighted) */
+			DrawMeleeIcon (21);  /* "Save" (bottom, not highlighted) */
 			break;
 #ifdef NETPLAY
 		case NET_TOP:
-			DrawMeleeIcon (35);
+			DrawMeleeIcon (35);  /* "Net..." (top, not highlighted) */
 			break;
 		case NET_BOT:
-			DrawMeleeIcon (37);
+			DrawMeleeIcon (37);  /* "Net..." (bottom, not highlighted) */
 			break;
 #endif
 		case QUIT_BOT:
-			DrawMeleeIcon (29);
+			DrawMeleeIcon (29);  /* "Quit" (not highlighted) */
 			break;
 		case CONTROLS_TOP:
 		case CONTROLS_BOT:
@@ -775,8 +769,10 @@ Select (BYTE opt)
 		case LOAD_BOT:
 			if (pMeleeState->InputFunc != DoLoadTeam)
 				DrawMeleeIcon (opt == LOAD_TOP ? 19 : 24);
+						/* 19: "Load" (top, highlighted) */
+						/* 24: "Load" (bottom, highlighted) */
 			else
-				DrawFileStrings (pMeleeState, 1);
+				SelectFileString (pMeleeState, true);
 			break;
 		case SAVE_TOP:
 			DrawMeleeIcon (20);  /* "Save" (top; highlighted) */
@@ -786,14 +782,14 @@ Select (BYTE opt)
 			break;
 #ifdef NETPLAY
 		case NET_TOP:
-			DrawMeleeIcon (36);  /* "Save" (top; highlighted) */
+			DrawMeleeIcon (36);  /* "Net..." (top; highlighted) */
 			break;
 		case NET_BOT:
-			DrawMeleeIcon (38);  /* "Save" (bottom; highlighted) */
+			DrawMeleeIcon (38);  /* "Net..." (bottom; highlighted) */
 			break;
 #endif
 		case QUIT_BOT:
-			DrawMeleeIcon (30);
+			DrawMeleeIcon (30);  /* "Quit" (highlighted) */
 			break;
 		case CONTROLS_TOP:
 		case CONTROLS_BOT:
@@ -814,9 +810,7 @@ Select (BYTE opt)
 							DTSHS_SELECTED);
 			}
 			else if (pMeleeState->InputFunc == DoPickShip)
-			{
 				DrawPickIcon (pMeleeState->CurIndex, 0);
-			}
 			break;
 	}
 }
@@ -826,6 +820,7 @@ flash_selection_func (void *data)
 {
 	DWORD TimeIn;
 	Task task = (Task) data;
+	volatile MELEE_STATE *pMS = pMeleeState;
 	
 	TimeIn = GetTimeCounter ();
 	while (!Task_ReadState (task, TASK_EXIT))
@@ -835,7 +830,7 @@ flash_selection_func (void *data)
 
 		LockMutex (GraphicsLock);
 		OldContext = SetContext (SpaceContext);
-		Deselect (pMeleeState->MeleeOption);
+		Deselect (pMS->MeleeOption);
 		SetContext (OldContext);
 		UnlockMutex (GraphicsLock);
 		SleepThreadUntil (TimeIn + FLASH_RATE);
@@ -843,7 +838,7 @@ flash_selection_func (void *data)
 
 		LockMutex (GraphicsLock);
 		OldContext = SetContext (SpaceContext);
-		Select (pMeleeState->MeleeOption);
+		Select (pMS->MeleeOption);
 		SetContext (OldContext);
 		UnlockMutex (GraphicsLock);
 		SleepThreadUntil (TimeIn + FLASH_RATE);
@@ -856,13 +851,13 @@ flash_selection_func (void *data)
 }
 
 static void
-InitMelee (PMELEE_STATE pMS)
+InitMelee (MELEE_STATE *pMS)
 {
 	RECT r;
 
 	SetContext (SpaceContext);
 	SetContextFGFrame (Screen);
-	SetContextClipRect (NULL_PTR);
+	SetContextClipRect (NULL);
 	SetContextBackGroundColor (BLACK_COLOR);
 	ClearDrawable ();
 	r.corner.x = SAFE_X;
@@ -879,11 +874,9 @@ InitMelee (PMELEE_STATE pMS)
 }
 
 static void
-DrawMeleeShipStrings (PMELEE_STATE pMS, BYTE NewStarShip)
+DrawMeleeShipStrings (MELEE_STATE *pMS, BYTE NewStarShip)
 {
 	RECT r, OldRect;
-	HSTARSHIP hStarShip;
-	STARSHIPPTR StarShipPtr;
 	CONTEXT OldContext;
 
 	LockMutex (GraphicsLock);
@@ -933,12 +926,15 @@ DrawMeleeShipStrings (PMELEE_STATE pMS,
 	}
 	else
 	{
-		hStarShip = GetStarShipFromIndex (&master_q, NewStarShip);
-		StarShipPtr = LockStarShip (&master_q, hStarShip);
+		HMASTERSHIP hMasterShip;
+		MASTER_SHIP_INFO *MasterPtr;
 
-		InitShipStatus (StarShipPtr, NULL_PTR);
+		hMasterShip = GetStarShipFromIndex (&master_q, NewStarShip);
+		MasterPtr = LockMasterShip (&master_q, hMasterShip);
 
-		UnlockStarShip (&master_q, hStarShip);
+		InitShipStatus (&MasterPtr->ShipInfo, ~0, NULL);
+
+		UnlockMasterShip (&master_q, hMasterShip);
 	}
 
 	UnbatchGraphics ();
@@ -949,13 +945,14 @@ DrawMeleeShipStrings (PMELEE_STATE pMS,
 }
 
 static void
-UpdateCurrentShip (PMELEE_STATE pMS)
+UpdateCurrentShip (MELEE_STATE *pMS)
 {
 	FleetShipIndex fleetShipIndex = GetShipIndex (pMS->row, pMS->col);
 	if (pMS->row == NUM_MELEE_ROWS)
 		pMS->CurIndex = MELEE_NONE;
 	else
-		pMS->CurIndex = pMS->TeamImage[pMS->side].ShipList[fleetShipIndex];
+		pMS->CurIndex =
+				pMS->SideState[pMS->side].TeamImage.ShipList[fleetShipIndex];
 	DrawMeleeShipStrings (pMS, (BYTE)(pMS->CurIndex));
 }
 
@@ -963,27 +960,19 @@ UpdateCurrentShip (PMELEE_STATE pMS)
 static COUNT
 GetShipValue (BYTE StarShip)
 {
-	HSTARSHIP hStarShip;
+	COUNT val;
 
 	if (StarShip == MELEE_NONE)
 		return 0;
 
-	hStarShip = GetStarShipFromIndex (&master_q, StarShip);
-	if (hStarShip == 0)
-		return (COUNT)~0;
+	val = GetShipCostFromIndex (StarShip);
+	if (val == 0)
+		val = (COUNT)~0;
 
-	{
-		STARSHIPPTR StarShipPtr;
-		COUNT val;
-
-		StarShipPtr = LockStarShip (&master_q, hStarShip);
-		val = StarShipPtr->RaceDescPtr->ship_info.ship_cost;
-		UnlockStarShip (&master_q, hStarShip);
-		return val;
-	}
+	return val;
 }
 
-static COUNT
+COUNT
 GetTeamValue (TEAM_IMAGE *pTI)
 {
 	FleetShipIndex index;
@@ -1002,460 +991,28 @@ GetTeamValue (TEAM_IMAGE *pTI)
 	return val;
 }
 
-static int
-ReadTeamImage (TEAM_IMAGE *pTI, uio_Stream *load_fp)
-{
-	int status;
-	FleetShipIndex i;
-	
-	status = ReadResFile (pTI, sizeof (*pTI), 1, load_fp);
-	if (status != 1)
-		return -1;
-
-	// Sanity check on the entries.
-	for (i = 0; i < MELEE_FLEET_SIZE; i++)
-	{
-		BYTE StarShip = pTI->ShipList[i];
-
-		if (StarShip == MELEE_NONE)
-			continue;
-
-		if (StarShip >= NUM_MELEE_SHIPS)
-		{
-			log_add(log_Warning, "Invalid ship type in loaded team (index "
-					"%d, ship type is %d, max valid is %d).",
-					i, StarShip, NUM_MELEE_SHIPS - 1);
-			pTI->ShipList[i] = MELEE_NONE;
-		}
-	}
-
-	return 0;
-}
-
-static int
-LoadTeamImage (DIRENTRY DirEntry, TEAM_IMAGE* pTI,
-		UNICODE* pFilePath)
-{
-	UNICODE file[NAME_MAX];	// local buf if needed
-	UNICODE *pfile;
-	uio_Stream *load_fp;
-	int status;
-
-	pfile = pFilePath != NULL_PTR ? pFilePath : file;
-
-	GetDirEntryContents (DirEntry, (STRINGPTR)pfile, FALSE);
-	load_fp = res_OpenResFile (meleeDir, pfile, "rb");
-	if (load_fp == 0)
-		status = -1;
-	else
-	{
-		if (LengthResFile (load_fp) != sizeof (*pTI))
-			status = -1;
-		else
-			status = ReadTeamImage (pTI, load_fp);
-		res_CloseResFile (load_fp);
-	}
-
-	return status;
-}
-
 static void
-DrawFileStrings (PMELEE_STATE pMS, int HiLiteState)
-{
-#define ENTRY_HEIGHT 32
-	COORD y;
-	COUNT top, bot;
-	TEXT Text, rtText;
-	CONTEXT OldContext;
-	UNICODE buf[60];
-
-	Text.baseline.x = 5;
-	y = 34;
-	Text.align = ALIGN_LEFT;
-
-	rtText.pStr = buf;
-	rtText.align = ALIGN_RIGHT;
-	rtText.baseline.x = Text.baseline.x + NUM_MELEE_COLUMNS
-			* (MELEE_BOX_WIDTH + MELEE_BOX_SPACE) - 1;
-				
-	top = pMS->TopTeamIndex;
-
-	if (HiLiteState == 1)
-	{
-		COUNT new_;
-
-		new_ = pMS->CurIndex;
-		bot = pMS->BotTeamIndex;
-
-		if (new_ < top || new_ > bot)
-		{
-			if (new_ < top)
-				top = new_;
-			else
-				top += new_ - bot;
-			pMS->TopTeamIndex = top;
-
-			HiLiteState = -1;
-		}
-	}
-
-	OldContext = SetContext (SpaceContext);
-	SetContextFont (MicroFont);
-	BatchGraphics ();
-	if (HiLiteState != -1)
-	{
-		bot = pMS->CurIndex - top;
-		Text.baseline.y = y + bot * ENTRY_HEIGHT;
-		Text.pStr = pMS->FileList[bot].TeamName;
-		Text.CharCount = (COUNT)~0;
-		SetContextForeGroundColor (HiLiteState == 0 ?
-				BUILD_COLOR (MAKE_RGB15 (15, 16, 27), 0x00)
-				: BUILD_COLOR (MAKE_RGB15 (23, 24, 29), 0x00));
-		font_DrawText (&Text);
-
-		rtText.baseline.y = Text.baseline.y;
-		sprintf (buf, "%d", GetTeamValue (&pMS->FileList[bot]));
-		rtText.CharCount = (COUNT)~0;
-		font_DrawText (&rtText);
-	}
-	else
-	{
-		COUNT teams_left;
-
-		DrawMeleeIcon (28);  /* Load team frame */
-
-		Text.baseline.y = y;
-		teams_left = (COUNT)(
-				GetDirEntryTableCount (pMS->TeamDE) + NUM_PREBUILT - top);
-		if (teams_left)
-		{
-			bot = top - 1;
-			do
-			{
-				FleetShipIndex index;
-				STAMP s;
-
-				if (++bot < NUM_PREBUILT)
-					pMS->FileList[bot - top] = pMS->PreBuiltList[bot];
-				else
-				{
-					pMS->TeamDE = SetAbsDirEntryTableIndex (
-							pMS->TeamDE, bot - NUM_PREBUILT);
-					if (-1 == LoadTeamImage (pMS->TeamDE,
-							&pMS->FileList[bot - top], NULL_PTR))
-					{
-						pMS->FileList[bot - top] = pMS->PreBuiltList[0];
-					}
-				}
-
-				{
-					Text.pStr = pMS->FileList[bot - top].TeamName;
-					Text.CharCount = (COUNT)~0;
-					SetContextForeGroundColor (
-							BUILD_COLOR (MAKE_RGB15 (15, 16, 27), 0x00));
-					font_DrawText (&Text);
-
-					rtText.baseline.y = Text.baseline.y;
-					sprintf (buf, "%d",
-							GetTeamValue (&pMS->FileList[bot - top]));
-					rtText.CharCount = (COUNT)~0;
-					font_DrawText (&rtText);
-				}
-
-				s.origin.x = Text.baseline.x + 1;
-				s.origin.y = Text.baseline.y + 4;
-				for (index = 0; index < MELEE_FLEET_SIZE; index++)
-				{
-					BYTE StarShip;
-						
-					StarShip = pMS->FileList[bot - top].ShipList[index];
-					if (StarShip != MELEE_NONE)
-					{
-						HSTARSHIP hStarShip;
-						STARSHIPPTR StarShipPtr;
-
-						hStarShip = GetStarShipFromIndex (&master_q, StarShip);
-						StarShipPtr = LockStarShip (&master_q, hStarShip);
-						s.frame = StarShipPtr->RaceDescPtr->ship_info.icons;
-						DrawStamp (&s);
-						s.origin.x += 17;
-						UnlockStarShip (&master_q, hStarShip);
-					}
-				}
-
-				Text.baseline.y += ENTRY_HEIGHT;
-			} while (--teams_left && bot - top < MAX_VIS_TEAMS - 1);
-			pMS->BotTeamIndex = bot;
-		}
-	}
-	UnbatchGraphics ();
-	SetContext (OldContext);
-}
-
-static BOOLEAN
-DoLoadTeam (PMELEE_STATE pMS)
-{
-	SIZE index;
-
-	if (GLOBAL (CurrentActivity) & CHECK_ABORT)
-		return (FALSE);
-
-	SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN | MENU_SOUND_PAGEUP |
-			MENU_SOUND_PAGEDOWN, MENU_SOUND_SELECT);
-
-	if (!pMS->Initialized)
-	{
-		LockMutex (GraphicsLock);
-		Select (pMS->MeleeOption);
-		pMS->TopTeamIndex = pMS->CurIndex;
-		if (pMS->TopTeamIndex == (COUNT)~0)
-		{
-			pMS->TopTeamIndex = 0;
-			pMS->CurIndex = 0;
-		}
-		else if (pMS->TopTeamIndex <= MAX_VIS_TEAMS / 2)
-			pMS->TopTeamIndex = 0;
-		else
-			pMS->TopTeamIndex -= MAX_VIS_TEAMS / 2;
-
-		DrawFileStrings (pMS, -1);
-		pMS->Initialized = TRUE;
-		pMS->InputFunc = DoLoadTeam;
-		UnlockMutex (GraphicsLock);
-	}
-	else if (PulsedInputState.menu[KEY_MENU_SELECT] |
-			PulsedInputState.menu[KEY_MENU_CANCEL])
-	{
-		if (!PulsedInputState.menu[KEY_MENU_CANCEL])
-		{
-			pMS->TeamImage[pMS->side] =
-					pMS->FileList[pMS->CurIndex - pMS->TopTeamIndex];
-			pMS->star_bucks[pMS->side] =
-					GetTeamValue (&pMS->TeamImage[pMS->side]);
-			entireFleetChanged (pMS, pMS->side);
-			teamStringChanged (pMS, pMS->side);
-		}
-
-		pMS->InputFunc = DoMelee;
-		{
-			RECT r;
-			
-			GetFrameRect (SetAbsFrameIndex (MeleeFrame, 28), &r);
-			LockMutex (GraphicsLock);
-			RepairMeleeFrame (&r);
-			UnlockMutex (GraphicsLock);
-		}
-		InTime = GetTimeCounter ();
-	}
-	else
-	{
-		SIZE old_index, NewTop;
-
-		NewTop = pMS->TopTeamIndex;
-		index = old_index = pMS->CurIndex;
-		if (PulsedInputState.menu[KEY_MENU_UP])
-		{
-			if (index-- == 0)
-				index = 0;
-
-			if (index < NewTop && (NewTop -= MAX_VIS_TEAMS) < 0)
-				NewTop = 0;
-		}
-		else if (PulsedInputState.menu[KEY_MENU_DOWN])
-		{
-			if ((int)index < (int)GetDirEntryTableCount (pMS->TeamDE) +
-					NUM_PREBUILT - 1)
-				++index;
-
-			if ((int)index > (int)pMS->BotTeamIndex)
-				NewTop = index;
-		}
-		else if (PulsedInputState.menu[KEY_MENU_PAGE_UP])
-		{
-			index -= MAX_VIS_TEAMS;
-			if (index < 0)
-			{
-				index = 0;
-				NewTop = 0;
-			}
-			else
-			{
-				NewTop -= MAX_VIS_TEAMS;
-				if (NewTop < 0)
-					NewTop = 0;
-			}
-		}
-		else if (PulsedInputState.menu[KEY_MENU_PAGE_DOWN])
-		{
-			index += MAX_VIS_TEAMS;
-			if ((int) index <
-					(int)(GetDirEntryTableCount (pMS->TeamDE) + NUM_PREBUILT))
-				NewTop += MAX_VIS_TEAMS;
-			else
-			{
-				index = GetDirEntryTableCount (pMS->TeamDE) + NUM_PREBUILT - 1;
-				if (index - (MAX_VIS_TEAMS - 1) > NewTop)
-				{
-					NewTop = index - (MAX_VIS_TEAMS - 1);
-					if (NewTop < 0)
-						NewTop = 0;
-				}
-			}
-		}
-
-		if (index != old_index)
-		{
-			LockMutex (GraphicsLock);
-			if ((int)NewTop == (int)pMS->TopTeamIndex)
-				Deselect (pMS->MeleeOption);
-			else
-			{
-				pMS->TopTeamIndex = NewTop;
-				DrawFileStrings (pMS, -1);
-			}
-			pMS->CurIndex = index;
-			UnlockMutex (GraphicsLock);
-		}
-	}
-
-	return (TRUE);
-}
-
-static int
-WriteTeamImage (TEAM_IMAGE *pTI, uio_Stream *save_fp)
-{
-	return (WriteResFile (pTI, sizeof (*pTI), 1, save_fp));
-}
-
-static void
-LoadTeamList (PMELEE_STATE pMS, UNICODE *pbuf)
-{
-	COUNT num_entries;
-	char file[NAME_MAX];
-
-GetNewList:
-	DestroyDirEntryTable (ReleaseDirEntryTable (pMS->TeamDE));
-	pMS->TeamDE = CaptureDirEntryTable (
-			LoadDirEntryTable (meleeDir, "", ".mle", match_MATCH_SUFFIX,
-			&num_entries));
-
-	pMS->CurIndex = 0;
-	while (num_entries--)
-	{
-		int status;
-		TEAM_IMAGE TI;
-
-		status = LoadTeamImage (pMS->TeamDE, &TI, file);
-
-		if (status == -1)
-		{
-			BOOLEAN deleteStatus;
-
-			log_add (log_Error, "Could not load '%s', deleting", file);
-
-			deleteStatus = DeleteResFile (meleeDir, file);
-			if (deleteStatus == FALSE)
-			{
-				// XXX: see bug #823
-				log_add (log_Fatal, "FATAL: Could not delete '%s'", file);
-				exit (EXIT_FAILURE);
-			}
-			goto GetNewList;
-		}
-
-		if (pbuf && stricmp (file, pbuf) == 0)
-		{
-			pMS->CurIndex = GetDirEntryTableIndex (pMS->TeamDE) + NUM_PREBUILT;
-			pbuf = 0;
-		}
-		pMS->TeamDE = SetRelDirEntryTableIndex (pMS->TeamDE, 1);
-	}
-	pMS->TeamDE = SetAbsDirEntryTableIndex (pMS->TeamDE, 0);
-}
-
-static BOOLEAN
-DoSaveTeam (PMELEE_STATE pMS)
-{
-	STAMP MsgStamp;
-	char file[NAME_MAX];
-	uio_Stream *save_fp;
-	CONTEXT OldContext;
-
-	sprintf (file, "%s.mle", pMS->TeamImage[pMS->side].TeamName);
-
-	LockMutex (GraphicsLock);
-	OldContext = SetContext (ScreenContext);
-	ConfirmSaveLoad (&MsgStamp);
-	save_fp = res_OpenResFile (meleeDir, file, "wb");
-	if (save_fp)
-	{
-		BOOLEAN err;
-
-		err = (BOOLEAN)(WriteTeamImage (
-				&pMS->TeamImage[pMS->side], save_fp) == 0);
-		if (res_CloseResFile (save_fp) == 0)
-			err = TRUE;
-		if (err)
-			save_fp = 0;
-	}
-
-	pMS->CurIndex = 0;
-	if (save_fp == 0)
-	{
-		DrawStamp (&MsgStamp);
-		DestroyDrawable (ReleaseDrawable (MsgStamp.frame));
-		SetContext (OldContext);
-		UnlockMutex (GraphicsLock);
-
-		DeleteResFile (meleeDir, file);
-		SaveProblem ();
-	}
-
-	LoadTeamList (pMS, file);
-
-	if (save_fp)
-	{
-		DrawStamp (&MsgStamp);
-		DestroyDrawable (ReleaseDrawable (MsgStamp.frame));
-		SetContext (OldContext);
-		UnlockMutex (GraphicsLock);
-	}
-	
-	return (save_fp != 0);
-}
-
-static void
-DeleteCurrentShip (PMELEE_STATE pMS)
+DeleteCurrentShip (MELEE_STATE *pMS)
 {
 	RECT r;
-	HSTARSHIP hStarShip;
-	STARSHIPPTR StarShipPtr;
 	FleetShipIndex fleetShipIndex;
 	int CurIndex;
 
 	fleetShipIndex = GetShipIndex (pMS->row, pMS->col);
-	CurIndex = pMS->TeamImage[pMS->side].ShipList[fleetShipIndex];
-	hStarShip = GetStarShipFromIndex (&master_q, CurIndex);
-	StarShipPtr = LockStarShip (&master_q, hStarShip);
-	if (StarShipPtr)
-	{
-		pMS->star_bucks[pMS->side] -=
-			StarShipPtr->RaceDescPtr->ship_info.ship_cost;
-		UnlockStarShip (&master_q, hStarShip);
-	
-		pMS->TeamImage[pMS->side].ShipList[fleetShipIndex] = MELEE_NONE;
-	}
+	CurIndex = pMS->SideState[pMS->side].TeamImage.ShipList[fleetShipIndex];
+	pMS->SideState[pMS->side].star_bucks -= GetShipCostFromIndex (CurIndex);
+	pMS->SideState[pMS->side].TeamImage.ShipList[fleetShipIndex] = MELEE_NONE;
+
 	LockMutex (GraphicsLock);
 	GetShipBox (&r, pMS->side, pMS->row, pMS->col);
 	RepairMeleeFrame (&r);
 
 	DrawTeamString (pMS, pMS->side, DTSHS_REPAIR);
 	UnlockMutex (GraphicsLock);
-
 }
 
 static void
-AdvanceCursor (PMELEE_STATE pMS)
+AdvanceCursor (MELEE_STATE *pMS)
 {
 	if (++pMS->col == NUM_MELEE_COLUMNS)
 	{
@@ -1470,9 +1027,9 @@ AdvanceCursor (PMELEE_STATE pMS)
 }
 
 static BOOLEAN
-OnTeamNameChange (PTEXTENTRY_STATE pTES)
+OnTeamNameChange (TEXTENTRY_STATE *pTES)
 {
-	PMELEE_STATE pMS = (PMELEE_STATE) pTES->CbParam;
+	MELEE_STATE *pMS = (MELEE_STATE*) pTES->CbParam;
 	BOOLEAN ret;
 	COUNT hl = DTSHS_EDIT;
 
@@ -1488,7 +1045,7 @@ OnTeamNameChange (PTEXTENTRY_STATE pTES)
 }
 
 static BOOLEAN
-DoEdit (PMELEE_STATE pMS)
+DoEdit (MELEE_STATE *pMS)
 {
 	if (GLOBAL (CurrentActivity) & CHECK_ABORT)
 		return (FALSE);
@@ -1496,7 +1053,8 @@ DoEdit (PMELEE_STATE pMS)
 	if (!pMS->Initialized)
 	{
 		FleetShipIndex fleetShipIndex = GetShipIndex (pMS->row, pMS->col);
-		pMS->CurIndex = pMS->TeamImage[pMS->side].ShipList[fleetShipIndex];
+		pMS->CurIndex =
+				pMS->SideState[pMS->side].TeamImage.ShipList[fleetShipIndex];
 		DrawMeleeShipStrings (pMS, (BYTE)pMS->CurIndex);
 
 		pMS->Initialized = TRUE;
@@ -1543,7 +1101,7 @@ DoEdit (PMELEE_STATE pMS)
 		fleetShipIndex = GetShipIndex (pMS->row, pMS->col);
 		fleetShipChanged (pMS, pMS->side, fleetShipIndex);
 		AdvanceCursor (pMS);
-		UpdateCurrentShip(pMS);
+		UpdateCurrentShip (pMS);
 	}
 	else
 	{
@@ -1570,7 +1128,7 @@ DoEdit (PMELEE_STATE pMS)
 
 				tes.Initialized = FALSE;
 				tes.MenuRepeatDelay = 0;
-				tes.BaseStr = pMS->TeamImage[pMS->side].TeamName;
+				tes.BaseStr = pMS->SideState[pMS->side].TeamImage.TeamName;
 				tes.CursorPos = 0;
 				tes.MaxSize = MAX_TEAM_CHARS + 1;
 				tes.CbParam = pMS;
@@ -1639,7 +1197,7 @@ DoEdit (PMELEE_STATE pMS)
 			pMS->col = col;
 			UnlockMutex (GraphicsLock);
 
-			UpdateCurrentShip(pMS);
+			UpdateCurrentShip (pMS);
 		}
 	}
 
@@ -1652,10 +1210,8 @@ DoEdit (PMELEE_STATE pMS)
 
 // Handle the popup from which a ship to add to the fleet can be chosen.
 static BOOLEAN
-DoPickShip (PMELEE_STATE pMS)
+DoPickShip (MELEE_STATE *pMS)
 {
-	STARSHIPPTR StarShipPtr;
-
 	if (GLOBAL (CurrentActivity) & CHECK_ABORT)
 		return (FALSE);
 
@@ -1666,9 +1222,7 @@ DoPickShip (PMELEE_STATE pMS)
 		if (pMS->CurIndex == (BYTE)~0 && pMS->Initialized == 0)
 			pMS->CurIndex = 0;
 		else if (pMS->CurIndex != (BYTE)~0)
-		{
 			DeleteCurrentShip (pMS);
-		}
 
 		if (pMS->Initialized == 0)
 		{
@@ -1686,7 +1240,8 @@ DoPickShip (PMELEE_STATE pMS)
 			Deselect (EDIT_MELEE);
 			pMS->Initialized = TRUE;
 			AdvanceCursor (pMS);
-			pMS->CurIndex = pMS->TeamImage[pMS->side].ShipList[fleetShipIndex];
+			pMS->CurIndex = pMS->SideState[pMS->side].TeamImage.ShipList[
+					fleetShipIndex];
 			UnlockMutex (GraphicsLock);
 
 			DrawMeleeShipStrings (pMS, (BYTE)(pMS->CurIndex));
@@ -1701,15 +1256,10 @@ DoPickShip (PMELEE_STATE pMS)
 		if (!PulsedInputState.menu[KEY_MENU_CANCEL])
 		{
 			// Add the currently selected ship to the fleet.
-			HSTARSHIP hStarShip;
-			
-			hStarShip = GetStarShipFromIndex (&master_q, pMS->CurIndex);
-			StarShipPtr = LockStarShip (&master_q, hStarShip);
-			pMS->star_bucks[pMS->side] +=
-					StarShipPtr->RaceDescPtr->ship_info.ship_cost;
-			UnlockStarShip (&master_q, hStarShip);
-
-			pMS->TeamImage[pMS->side].ShipList[index] = pMS->CurIndex;
+			pMS->SideState[pMS->side].star_bucks +=
+					GetShipCostFromIndex (pMS->CurIndex);
+			pMS->SideState[pMS->side].TeamImage.ShipList[index] =
+					pMS->CurIndex;
 			LockMutex (GraphicsLock);
 			DrawTeamString (pMS, pMS->side, DTSHS_REPAIR);
 			DrawShipBoxCurrent (pMS, FALSE);
@@ -1727,15 +1277,20 @@ DoPickShip (PMELEE_STATE pMS)
 		}
 
 		fleetShipChanged (pMS, pMS->side, index);
-		UpdateCurrentShip(pMS);
+		UpdateCurrentShip (pMS);
 
 		pMS->InputFunc = DoEdit;
 
 		return (TRUE);
 	}
-	else if (PulsedInputState.menu[KEY_MENU_SPECIAL])
+	else if (PulsedInputState.menu[KEY_MENU_SPECIAL]
+			&& (pMeleeState->CurIndex != (BYTE)~0))
 	{
+		BOOLEAN (*InputFunc) (struct melee_state *pInputState);
+		InputFunc = pMS->InputFunc;
+		pMS->InputFunc = 0; /* disable ship flashing */
 		DoShipSpin (pMS->CurIndex, (MUSIC_REF)0);
+		pMS->InputFunc = InputFunc;
 	
 		return (TRUE);
 	}
@@ -1809,7 +1364,7 @@ numPlayersReady (void)
 			if (conn == NULL || !NetConnection_isConnected (conn))
 				return -1;
 
-			if (NetConnection_getState(conn) > NetState_inSetup)
+			if (NetConnection_getState (conn) > NetState_inSetup)
 				numDone++;
 		}
 #endif
@@ -1824,7 +1379,7 @@ numPlayersReady (void)
 // When the other party changes something in the settings, the confirmation
 // is cancelled.
 static BOOLEAN
-DoConfirmSettings (PMELEE_STATE pMS)
+DoConfirmSettings (MELEE_STATE *pMS)
 {
 #ifdef NETPLAY
 	ssize_t numDone;
@@ -1903,7 +1458,7 @@ DoConfirmSettings (PMELEE_STATE pMS)
 			if (!NetConnection_isConnected (conn))
 				continue;
 
-			if (NetConnection_getDiscriminant(conn))
+			if (NetConnection_getDiscriminant (conn))
 				Netplay_seedRandom (conn, SeedRandomNumbers ());
 		}
 		flushPacketQueues ();
@@ -1922,7 +1477,7 @@ DoConfirmSettings (PMELEE_STATE pMS)
 
 	// The maximum value for all connections is used.
 	{
-		bool ok = setupInputDelay(netplayOptions.inputDelay);
+		bool ok = setupInputDelay (netplayOptions.inputDelay);
 		if (!ok)
 			return FALSE;
 	}
@@ -1938,7 +1493,7 @@ DoConfirmSettings (PMELEE_STATE pMS)
 }
 
 static void
-LoadMeleeInfo (PMELEE_STATE pMS)
+LoadMeleeInfo (MELEE_STATE *pMS)
 {
 	STAMP	s;
 	CONTEXT	OldContext;
@@ -1967,12 +1522,14 @@ LoadMeleeInfo (PMELEE_STATE pMS)
 
 	// create team building ship selection box
 	s.frame = SetAbsFrameIndex (MeleeFrame, 27);
+			// 5x5 grid of ships to pick from
 	GetFrameRect (s.frame, &r);
 	BuildPickFrame = CaptureDrawable (CreateDrawable (
 			WANT_PIXMAP, r.extent.width, r.extent.height, 1));
 	SetContextFGFrame (BuildPickFrame);
 	SetFrameHot (s.frame, MAKE_HOT_SPOT (0, 0));
 	DrawStamp (&s);
+
 	for (i = 0; i < NUM_PICK_COLS * NUM_PICK_ROWS; ++i)
 		DrawPickIcon (i, 1);
 
@@ -1980,19 +1537,19 @@ LoadMeleeInfo (PMELEE_STATE pMS)
 
 	InitSpace ();
 
-	LoadTeamList (pMS, 0);
+	LoadTeamList (pMS);
 }
 
 static void
-FreeMeleeInfo (PMELEE_STATE pMS)
+FreeMeleeInfo (MELEE_STATE *pMS)
 {
 	if (pMS->flash_task)
 	{
 		ConcludeTask (pMS->flash_task);
 		pMS->flash_task = 0;
 	}
-	DestroyDirEntryTable (ReleaseDirEntryTable (pMS->TeamDE));
-	pMS->TeamDE = 0;
+	DestroyDirEntryTable (ReleaseDirEntryTable (pMS->load.dirEntries));
+	pMS->load.dirEntries = 0;
 
 	if (pMS->hMusic)
 	{
@@ -2013,7 +1570,7 @@ FreeMeleeInfo (PMELEE_STATE pMS)
 }
 
 static void
-BuildAndDrawShipList (PMELEE_STATE pMS)
+BuildAndDrawShipList (MELEE_STATE *pMS)
 {
 	COUNT i;
 	CONTEXT OldContext;
@@ -2037,12 +1594,14 @@ BuildAndDrawShipList (PMELEE_STATE pMS)
 		GetFrameRect (s.frame, &r);
 		t.baseline.x = r.extent.width >> 1;
 		t.baseline.y = r.extent.height - NAME_AREA_HEIGHT + 4;
+
 		r.corner.x += 2;
 		r.corner.y += 2;
 		r.extent.width -= (2 * 2) + (ICON_WIDTH + 2) + 1;
 		r.extent.height -= (2 * 2) + NAME_AREA_HEIGHT;
 		SetContextForeGroundColor (PICK_BG_COLOR);
 		DrawFilledRectangle (&r);
+
 		r.corner.x += 2;
 		r.extent.width += (ICON_WIDTH + 2) - (2 * 2);
 		r.corner.y += r.extent.height;
@@ -2051,14 +1610,14 @@ BuildAndDrawShipList (PMELEE_STATE pMS)
 
 		// Team name at the bottom of the frame:
 		t.align = ALIGN_CENTER;
-		t.pStr = pMS->TeamImage[i].TeamName;
+		t.pStr = pMS->SideState[i].TeamImage.TeamName;
 		t.CharCount = (COUNT)~0;
 		SetContextFont (TinyFont);
 		SetContextForeGroundColor (PICKSHIP_TEAM_NAME_TEXT_COLOR);
 		font_DrawText (&t);
 
 		// Total team value of the starting team:
-		sprintf (buf, "%d", pMS->star_bucks[i]);
+		sprintf (buf, "%u", pMS->SideState[i].star_bucks);
 		t.baseline.x = 4;
 		t.baseline.y = 7;
 		t.align = ALIGN_LEFT;
@@ -2067,41 +1626,54 @@ BuildAndDrawShipList (PMELEE_STATE pMS)
 		SetContextForeGroundColor (PICKSHIP_TEAM_START_VALUE_COLOR);
 		font_DrawText (&t);
 
+		assert (CountLinks (&race_q[side]) == 0);
+
 		for (index = 0; index < MELEE_FLEET_SIZE; index++)
 		{
 			BYTE StarShip;
 
-			StarShip = pMS->TeamImage[i].ShipList[index];
+			StarShip = pMS->SideState[i].TeamImage.ShipList[index];
 			if (StarShip == MELEE_NONE)
 				continue;
 
 			{
 				BYTE row, col;
 				BYTE ship_cost;
-				HSTARSHIP hStarShip, hBuiltShip;
-				STARSHIPPTR StarShipPtr, BuiltShipPtr;
-
-				hStarShip = GetStarShipFromIndex (&master_q, StarShip);
-				StarShipPtr = LockStarShip (&master_q, hStarShip);
-				hBuiltShip = Build (&race_q[side], StarShipPtr->RaceResIndex,
-						1 << side, NameCaptain (&race_q[side], StarShipPtr));
+				HMASTERSHIP hMasterShip;
+				HSTARSHIP hBuiltShip;
+				MASTER_SHIP_INFO *MasterPtr;
+				STARSHIP *BuiltShipPtr;
+				BYTE captains_name_index;
+
+				hMasterShip = GetStarShipFromIndex (&master_q, StarShip);
+				MasterPtr = LockMasterShip (&master_q, hMasterShip);
+
+				captains_name_index = NameCaptain (&race_q[side],
+						MasterPtr->SpeciesID);
+				hBuiltShip = Build (&race_q[side], MasterPtr->SpeciesID);
 
+				// Draw the icon.
 				row = GetShipRow (index);
 				col = GetShipColumn (index);
 				s.origin.x = 4 + ((ICON_WIDTH + 2) * col);
 				s.origin.y = 10 + ((ICON_HEIGHT + 2) * row);
-				s.frame = StarShipPtr->RaceDescPtr->ship_info.icons;
+				s.frame = MasterPtr->ShipInfo.icons;
 				DrawStamp (&s);
 
-				ship_cost = StarShipPtr->RaceDescPtr->ship_info.ship_cost;
-				UnlockStarShip (&master_q, hStarShip);
+				ship_cost = MasterPtr->ShipInfo.ship_cost;
+				UnlockMasterShip (&master_q, hMasterShip);
 
 				BuiltShipPtr = LockStarShip (&race_q[side], hBuiltShip);
-				BuiltShipPtr->ShipFacing = index;
-				BuiltShipPtr->special_counter = ship_cost;
-				BuiltShipPtr->captains_name_index =
-						StarShipCaptain (BuiltShipPtr);
-				BuiltShipPtr->RaceDescPtr = StarShipPtr->RaceDescPtr;
+				BuiltShipPtr->index = index;
+				BuiltShipPtr->ship_cost = ship_cost;
+				BuiltShipPtr->which_side = 1 << side;
+				BuiltShipPtr->captains_name_index = captains_name_index;
+				// The next ones are not used in Melee
+				BuiltShipPtr->crew_level = 0;
+				BuiltShipPtr->max_crew = 0;
+				BuiltShipPtr->race_strings = 0;
+				BuiltShipPtr->icons = 0;
+				BuiltShipPtr->RaceDescPtr = 0;
 				UnlockStarShip (&race_q[side], hBuiltShip);
 			}
 		}
@@ -2111,7 +1683,7 @@ BuildAndDrawShipList (PMELEE_STATE pMS)
 }
 
 static void
-StartMelee (PMELEE_STATE pMS)
+StartMelee (MELEE_STATE *pMS)
 {
 	if (pMS->flash_task)
 	{
@@ -2143,10 +1715,12 @@ StartMelee (PMELEE_STATE pMS)
 
 		WaitForSoundEnd (TFBSOUND_WAIT_ALL);
 
+		SetPlayerInputAll ();
 		load_gravity_well ((BYTE)((COUNT)TFB_Random () %
 					NUMBER_OF_PLANET_TYPES));
 		Battle ();
 		free_gravity_well ();
+		ClearPlayerInputAll ();
 
 		if (GLOBAL (CurrentActivity) & CHECK_ABORT)
 			return;
@@ -2166,18 +1740,20 @@ StartMelee (PMELEE_STATE pMS)
 }
 
 static void
-StartMeleeButtonPressed (PMELEE_STATE pMS)
+StartMeleeButtonPressed (MELEE_STATE *pMS)
 {
-	if (pMS->star_bucks[0] == 0 || pMS->star_bucks[1] == 0)
+	if (pMS->SideState[0].star_bucks == 0 ||
+			pMS->SideState[1].star_bucks == 0)
 	{
 		PlayMenuSound (MENU_SOUND_FAILURE);
 		return;
 	}
 	
+#ifdef NETPLAY
 	if ((PlayerControl[0] & NETWORK_CONTROL) &&
 			(PlayerControl[1] & NETWORK_CONTROL))
 	{
-		DrawMeleeStatusMessage (GAME_STRING (NETMELEE_STRING_BASE + 31));
+		DrawMeleeStatusMessage (GAME_STRING (NETMELEE_STRING_BASE + 32));
 				// "Only one side at a time can be network controlled."
 		return;
 	}
@@ -2187,13 +1763,12 @@ StartMeleeButtonPressed (PMELEE_STATE pM
 			((PlayerControl[0] & COMPUTER_CONTROL) &&
 			(PlayerControl[1] & NETWORK_CONTROL)))
 	{
-		DrawMeleeStatusMessage (GAME_STRING (NETMELEE_STRING_BASE + 32));
+		DrawMeleeStatusMessage (GAME_STRING (NETMELEE_STRING_BASE + 33));
 				// "Netplay with a computer-controlled side is currently
 				// not possible."
 		return;
 	}
 
-#ifdef NETPLAY
 	// Check whether all network parties are ready;
 	{
 		COUNT player;
@@ -2224,7 +1799,7 @@ StartMeleeButtonPressed (PMELEE_STATE pM
 							// "Connection for top player not "
 							// "established."
 			}
-			else if (NetConnection_getState(conn) != NetState_inSetup)
+			else if (NetConnection_getState (conn) != NetState_inSetup)
 			{
 				// This side may be in the setup, but the network connection
 				// is not in a state that setup information can be sent.
@@ -2259,7 +1834,7 @@ StartMeleeButtonPressed (PMELEE_STATE pM
 #ifdef NETPLAY
 
 static BOOLEAN
-DoConnectingDialog (PMELEE_STATE pMS)
+DoConnectingDialog (MELEE_STATE *pMS)
 {
 	COUNT which_side = (pMS->MeleeOption == NET_TOP) ? 1 : 0;
 	NetConnection *conn;
@@ -2271,16 +1846,16 @@ DoConnectingDialog (PMELEE_STATE pMS)
 	if (!pMS->Initialized)
 	{
 		RECT r;
-		FONT oldfont; 
+		FONT oldfont;
 		COLOR oldcolor;
 		TEXT t;
 
 		// Build a network connection.
 		if (netConnections[which_side] != NULL)
-			closePlayerNetworkConnection(which_side);
+			closePlayerNetworkConnection (which_side);
 
 		pMS->Initialized = TRUE;
-		conn = openPlayerNetworkConnection (which_side, (void *) pMS);
+		conn = openPlayerNetworkConnection (which_side, pMS);
 		pMS->InputFunc = DoConnectingDialog;
 
 		/* Draw the dialog box here */
@@ -2298,10 +1873,12 @@ DoConnectingDialog (PMELEE_STATE pMS)
 		if (NetConnection_getPeerOptions (conn)->isServer)
 		{
 			t.pStr = GAME_STRING (NETMELEE_STRING_BASE + 1);
+					/* "Awaiting incoming connection */
 		}
 		else
 		{
 			t.pStr = GAME_STRING (NETMELEE_STRING_BASE + 2);
+					/* "Awaiting outgoing connection */
 		}
 		t.baseline.y = r.corner.y + 10;
 		t.baseline.x = SCREEN_WIDTH >> 1;
@@ -2310,7 +1887,7 @@ DoConnectingDialog (PMELEE_STATE pMS)
 		font_DrawText (&t);
 
 		t.pStr = GAME_STRING (NETMELEE_STRING_BASE + 18);
-			/* "Press SPACE to cancel" */
+				/* "Press SPACE to cancel" */
 		t.baseline.y += 16;
 		font_DrawText (&t);
 
@@ -2352,7 +1929,6 @@ DoConnectingDialog (PMELEE_STATE pMS)
 		{
 			/* Connection complete! */
 			PlayerControl[which_side] = NETWORK_CONTROL | STANDARD_RATING;
-			SetPlayerInput ();
 			DrawControls (which_side, TRUE);
 
 			RedrawMeleeFrame ();
@@ -2378,7 +1954,7 @@ DoConnectingDialog (PMELEE_STATE pMS)
 
 /* Check for disconnections, and revert to human control if so */
 static void
-check_for_disconnections (PMELEE_STATE pMS)
+check_for_disconnections (MELEE_STATE *pMS)
 {
 	COUNT player;
 	bool changed = FALSE;
@@ -2401,19 +1977,49 @@ check_for_disconnections (PMELEE_STATE p
 		}
 	}
 
-	if (changed)
-	{
-		SetPlayerInput ();
-	}
-
 	(void) pMS;
 }
 
 #endif
 
+static void
+nextControlType (COUNT which_side)
+{
+	switch (PlayerControl[which_side])
+	{
+		case HUMAN_CONTROL | STANDARD_RATING:
+			PlayerControl[which_side] =  COMPUTER_CONTROL | STANDARD_RATING;
+			break;
+		case COMPUTER_CONTROL | STANDARD_RATING:
+			PlayerControl[which_side] =  COMPUTER_CONTROL | GOOD_RATING;
+			break;
+		case COMPUTER_CONTROL | GOOD_RATING:
+			PlayerControl[which_side] =  COMPUTER_CONTROL | AWESOME_RATING;
+			break;
+		case COMPUTER_CONTROL | AWESOME_RATING:
+			PlayerControl[which_side] =  HUMAN_CONTROL | STANDARD_RATING;
+			break;
 
-static BOOLEAN
-DoMelee (PMELEE_STATE pMS)
+#ifdef NETPLAY
+		case NETWORK_CONTROL | STANDARD_RATING:
+			if (netConnections[which_side] != NULL)
+				closePlayerNetworkConnection (which_side);
+			UpdateMeleeStatusMessage (-1);
+			PlayerControl[which_side] =  HUMAN_CONTROL | STANDARD_RATING;
+			break;
+#endif  /* NETPLAY */
+		default:
+			log_add (log_Error, "Error: Bad control type (%d) in "
+					"nextControlType().\n", PlayerControl[which_side]);
+			PlayerControl[which_side] =  HUMAN_CONTROL | STANDARD_RATING;
+			break;
+	}
+
+	DrawControls (which_side, TRUE);
+}
+
+BOOLEAN
+DoMelee (MELEE_STATE *pMS)
 {
 	BOOLEAN force_select = FALSE;
 	if (GLOBAL (CurrentActivity) & CHECK_ABORT)
@@ -2537,11 +2143,12 @@ DoMelee (PMELEE_STATE pMS)
 					pMS->Initialized = FALSE;
 					pMS->side = pMS->MeleeOption == LOAD_TOP ? 0 : 1;
 					DoLoadTeam (pMS);
+					InTime = GetTimeCounter ();
 					break;
 				case SAVE_TOP:
 				case SAVE_BOT:
 					pMS->side = pMS->MeleeOption == SAVE_TOP ? 0 : 1;
-					if (pMS->star_bucks[pMS->side])
+					if (pMS->SideState[pMS->side].star_bucks)
 						DoSaveTeam (pMS);
 					else
 						PlayMenuSound (MENU_SOUND_FAILURE);
@@ -2574,8 +2181,9 @@ DoMelee (PMELEE_STATE pMS)
 					{
 						if (!pMS->flash_task)
 						{
-							pMS->flash_task = AssignTask (flash_selection_func, 2048,
-										      "flash melee selection");
+							pMS->flash_task = AssignTask (
+									flash_selection_func, 2048,
+									"flash melee selection");
 						}
 					}
 
@@ -2585,34 +2193,9 @@ DoMelee (PMELEE_STATE pMS)
 				case CONTROLS_TOP:
 				case CONTROLS_BOT:
 				{
-					COUNT which_side;
-
-					which_side = pMS->MeleeOption == CONTROLS_TOP ? 1 : 0;
-					if (PlayerControl[which_side] & HUMAN_CONTROL)
-						PlayerControl[which_side] =
-								COMPUTER_CONTROL | STANDARD_RATING;
-					else if (PlayerControl[which_side] & AWESOME_RATING)
-					{
-						PlayerControl[which_side] =
-								HUMAN_CONTROL | STANDARD_RATING;
-					}
-#ifdef NETPLAY
-					else if (PlayerControl[which_side] & NETWORK_CONTROL)
-					{
-						if (netConnections[which_side] != NULL)
-							closePlayerNetworkConnection (which_side);
-						UpdateMeleeStatusMessage (-1);
-						PlayerControl[which_side] =
-								HUMAN_CONTROL | STANDARD_RATING;
-					}
-#endif  /* NETPLAY */
-					else
-						PlayerControl[which_side] = ((
-								PlayerControl[which_side]
-								& (STANDARD_RATING | GOOD_RATING |
-								AWESOME_RATING)) << 1) | COMPUTER_CONTROL;
-					SetPlayerInput ();
-					DrawControls (which_side, TRUE);
+					COUNT which_side =
+							(pMS->MeleeOption == CONTROLS_TOP) ? 1 : 0;
+					nextControlType (which_side);
 					break;
 				}
 			}
@@ -2628,318 +2211,36 @@ DoMelee (PMELEE_STATE pMS)
 	return (TRUE);
 }
 
-static void
-InitPreBuilt (PMELEE_STATE pMS)
-{
-	{
-		FleetShipIndex shipI = 0;
-		int fleetI;
-
-		for (fleetI = 0; fleetI < NUM_PREBUILT; fleetI++)
-			for (shipI = 0; shipI < MELEE_FLEET_SIZE; shipI++)
-				pMS->PreBuiltList[fleetI].ShipList[shipI] = MELEE_NONE;
-	}
-
-	{
-		/* "Balanced Team 1" */
-		FleetShipIndex i = 0;
-		utf8StringCopy (pMS->PreBuiltList[0].TeamName,
-				sizeof (pMS->PreBuiltList[0].TeamName),
-				GAME_STRING (MELEE_STRING_BASE + 4));
-		pMS->PreBuiltList[0].ShipList[i++] = MELEE_ANDROSYNTH;
-		pMS->PreBuiltList[0].ShipList[i++] = MELEE_CHMMR;
-		pMS->PreBuiltList[0].ShipList[i++] = MELEE_DRUUGE;
-		pMS->PreBuiltList[0].ShipList[i++] = MELEE_URQUAN;
-		pMS->PreBuiltList[0].ShipList[i++] = MELEE_MELNORME;
-		pMS->PreBuiltList[0].ShipList[i++] = MELEE_ORZ;
-		pMS->PreBuiltList[0].ShipList[i++] = MELEE_SPATHI;
-		pMS->PreBuiltList[0].ShipList[i++] = MELEE_SYREEN;
-		pMS->PreBuiltList[0].ShipList[i++] = MELEE_UTWIG;
-	}
-
-	{
-		/* "Balanced Team 2" */
-		FleetShipIndex i = 0;
-		utf8StringCopy (pMS->PreBuiltList[1].TeamName,
-				sizeof (pMS->PreBuiltList[1].TeamName),
-				GAME_STRING (MELEE_STRING_BASE + 5));
-		pMS->PreBuiltList[1].ShipList[i++] = MELEE_ARILOU;
-		pMS->PreBuiltList[1].ShipList[i++] = MELEE_CHENJESU;
-		pMS->PreBuiltList[1].ShipList[i++] = MELEE_EARTHLING;
-		pMS->PreBuiltList[1].ShipList[i++] = MELEE_KOHR_AH;
-		pMS->PreBuiltList[1].ShipList[i++] = MELEE_MYCON;
-		pMS->PreBuiltList[1].ShipList[i++] = MELEE_YEHAT;
-		pMS->PreBuiltList[1].ShipList[i++] = MELEE_PKUNK;
-		pMS->PreBuiltList[1].ShipList[i++] = MELEE_SUPOX;
-		pMS->PreBuiltList[1].ShipList[i++] = MELEE_THRADDASH;
-		pMS->PreBuiltList[1].ShipList[i++] = MELEE_ZOQFOTPIK;
-		pMS->PreBuiltList[1].ShipList[i++] = MELEE_SHOFIXTI;
-	}
-
-	{
-		/* "200 points" */
-		FleetShipIndex i = 0;
-		utf8StringCopy (pMS->PreBuiltList[2].TeamName,
-				sizeof (pMS->PreBuiltList[2].TeamName),
-				GAME_STRING (MELEE_STRING_BASE + 6));
-		pMS->PreBuiltList[2].ShipList[i++] = MELEE_ANDROSYNTH;
-		pMS->PreBuiltList[2].ShipList[i++] = MELEE_CHMMR;
-		pMS->PreBuiltList[2].ShipList[i++] = MELEE_DRUUGE;
-		pMS->PreBuiltList[2].ShipList[i++] = MELEE_MELNORME;
-		pMS->PreBuiltList[2].ShipList[i++] = MELEE_EARTHLING;
-		pMS->PreBuiltList[2].ShipList[i++] = MELEE_KOHR_AH;
-		pMS->PreBuiltList[2].ShipList[i++] = MELEE_SUPOX;
-		pMS->PreBuiltList[2].ShipList[i++] = MELEE_ORZ;
-		pMS->PreBuiltList[2].ShipList[i++] = MELEE_SPATHI;
-		pMS->PreBuiltList[2].ShipList[i++] = MELEE_ILWRATH;
-		pMS->PreBuiltList[2].ShipList[i++] = MELEE_VUX;
-	}
-
-	{
-		/* "Behemoth Zenith" */
-		FleetShipIndex i = 0;
-		utf8StringCopy (pMS->PreBuiltList[3].TeamName,
-				sizeof (pMS->PreBuiltList[3].TeamName),
-				GAME_STRING (MELEE_STRING_BASE + 7));
-		pMS->PreBuiltList[3].ShipList[i++] = MELEE_CHENJESU;
-		pMS->PreBuiltList[3].ShipList[i++] = MELEE_CHENJESU;
-		pMS->PreBuiltList[3].ShipList[i++] = MELEE_CHMMR;
-		pMS->PreBuiltList[3].ShipList[i++] = MELEE_CHMMR;
-		pMS->PreBuiltList[3].ShipList[i++] = MELEE_KOHR_AH;
-		pMS->PreBuiltList[3].ShipList[i++] = MELEE_KOHR_AH;
-		pMS->PreBuiltList[3].ShipList[i++] = MELEE_URQUAN;
-		pMS->PreBuiltList[3].ShipList[i++] = MELEE_URQUAN;
-		pMS->PreBuiltList[3].ShipList[i++] = MELEE_UTWIG;
-		pMS->PreBuiltList[3].ShipList[i++] = MELEE_UTWIG;
-	}
-
-	{
-		/* "The Peeled Eyes" */
-		FleetShipIndex i = 0;
-		utf8StringCopy (pMS->PreBuiltList[4].TeamName,
-				sizeof (pMS->PreBuiltList[4].TeamName),
-				GAME_STRING (MELEE_STRING_BASE + 8));
-		pMS->PreBuiltList[4].ShipList[i++] = MELEE_URQUAN;
-		pMS->PreBuiltList[4].ShipList[i++] = MELEE_CHENJESU;
-		pMS->PreBuiltList[4].ShipList[i++] = MELEE_MYCON;
-		pMS->PreBuiltList[4].ShipList[i++] = MELEE_SYREEN;
-		pMS->PreBuiltList[4].ShipList[i++] = MELEE_ZOQFOTPIK;
-		pMS->PreBuiltList[4].ShipList[i++] = MELEE_SHOFIXTI;
-		pMS->PreBuiltList[4].ShipList[i++] = MELEE_EARTHLING;
-		pMS->PreBuiltList[4].ShipList[i++] = MELEE_KOHR_AH;
-		pMS->PreBuiltList[4].ShipList[i++] = MELEE_MELNORME;
-		pMS->PreBuiltList[4].ShipList[i++] = MELEE_DRUUGE;
-		pMS->PreBuiltList[4].ShipList[i++] = MELEE_PKUNK;
-		pMS->PreBuiltList[4].ShipList[i++] = MELEE_ORZ;
-	}
-
-	{
-		FleetShipIndex i = 0;
-		utf8StringCopy (pMS->PreBuiltList[5].TeamName,
-				sizeof (pMS->PreBuiltList[5].TeamName),
-				"Ford's Fighters");
-		pMS->PreBuiltList[5].ShipList[i++] = MELEE_CHMMR;
-		pMS->PreBuiltList[5].ShipList[i++] = MELEE_ZOQFOTPIK;
-		pMS->PreBuiltList[5].ShipList[i++] = MELEE_MELNORME;
-		pMS->PreBuiltList[5].ShipList[i++] = MELEE_SUPOX;
-		pMS->PreBuiltList[5].ShipList[i++] = MELEE_UTWIG;
-		pMS->PreBuiltList[5].ShipList[i++] = MELEE_UMGAH;
-	}
-
-	{
-		FleetShipIndex i = 0;
-		utf8StringCopy (pMS->PreBuiltList[6].TeamName,
-				sizeof (pMS->PreBuiltList[6].TeamName),
-				"Leyland's Lashers");
-		pMS->PreBuiltList[6].ShipList[i++] = MELEE_ANDROSYNTH;
-		pMS->PreBuiltList[6].ShipList[i++] = MELEE_EARTHLING;
-		pMS->PreBuiltList[6].ShipList[i++] = MELEE_MYCON;
-		pMS->PreBuiltList[6].ShipList[i++] = MELEE_ORZ;
-		pMS->PreBuiltList[6].ShipList[i++] = MELEE_URQUAN;
-	}
-
-	{
-		FleetShipIndex i = 0;
-		utf8StringCopy (pMS->PreBuiltList[7].TeamName,
-				sizeof (pMS->PreBuiltList[7].TeamName),
-				"The Gregorizers 200");
-		pMS->PreBuiltList[7].ShipList[i++] = MELEE_ANDROSYNTH;
-		pMS->PreBuiltList[7].ShipList[i++] = MELEE_CHMMR;
-		pMS->PreBuiltList[7].ShipList[i++] = MELEE_DRUUGE;
-		pMS->PreBuiltList[7].ShipList[i++] = MELEE_MELNORME;
-		pMS->PreBuiltList[7].ShipList[i++] = MELEE_EARTHLING;
-		pMS->PreBuiltList[7].ShipList[i++] = MELEE_KOHR_AH;
-		pMS->PreBuiltList[7].ShipList[i++] = MELEE_SUPOX;
-		pMS->PreBuiltList[7].ShipList[i++] = MELEE_ORZ;
-		pMS->PreBuiltList[7].ShipList[i++] = MELEE_PKUNK;
-		pMS->PreBuiltList[7].ShipList[i++] = MELEE_SPATHI;
-	}
-
-	{
-		FleetShipIndex i = 0;
-		utf8StringCopy (pMS->PreBuiltList[8].TeamName,
-				sizeof (pMS->PreBuiltList[8].TeamName),
-				"300 point Armada!");
-		pMS->PreBuiltList[8].ShipList[i++] = MELEE_ANDROSYNTH;
-		pMS->PreBuiltList[8].ShipList[i++] = MELEE_CHMMR;
-		pMS->PreBuiltList[8].ShipList[i++] = MELEE_CHENJESU;
-		pMS->PreBuiltList[8].ShipList[i++] = MELEE_DRUUGE;
-		pMS->PreBuiltList[8].ShipList[i++] = MELEE_EARTHLING;
-		pMS->PreBuiltList[8].ShipList[i++] = MELEE_KOHR_AH;
-		pMS->PreBuiltList[8].ShipList[i++] = MELEE_MELNORME;
-		pMS->PreBuiltList[8].ShipList[i++] = MELEE_MYCON;
-		pMS->PreBuiltList[8].ShipList[i++] = MELEE_ORZ;
-		pMS->PreBuiltList[8].ShipList[i++] = MELEE_PKUNK;
-		pMS->PreBuiltList[8].ShipList[i++] = MELEE_SPATHI;
-		pMS->PreBuiltList[8].ShipList[i++] = MELEE_SUPOX;
-		pMS->PreBuiltList[8].ShipList[i++] = MELEE_URQUAN;
-		pMS->PreBuiltList[8].ShipList[i++] = MELEE_YEHAT;
-	}
-
-	{
-		FleetShipIndex i = 0;
-		utf8StringCopy (pMS->PreBuiltList[9].TeamName,
-				sizeof (pMS->PreBuiltList[9].TeamName),
-				"Little Dudes with Attitudes");
-		pMS->PreBuiltList[9].ShipList[i++] = MELEE_UMGAH;
-		pMS->PreBuiltList[9].ShipList[i++] = MELEE_THRADDASH;
-		pMS->PreBuiltList[9].ShipList[i++] = MELEE_SHOFIXTI;
-		pMS->PreBuiltList[9].ShipList[i++] = MELEE_EARTHLING;
-		pMS->PreBuiltList[9].ShipList[i++] = MELEE_VUX;
-		pMS->PreBuiltList[9].ShipList[i++] = MELEE_ZOQFOTPIK;
-	}
-
-	{
-		FleetShipIndex i = 0;
-		utf8StringCopy (pMS->PreBuiltList[10].TeamName,
-				sizeof (pMS->PreBuiltList[10].TeamName),
-				"New Alliance Ships");
-		pMS->PreBuiltList[10].ShipList[i++] = MELEE_ARILOU;
-		pMS->PreBuiltList[10].ShipList[i++] = MELEE_CHMMR;
-		pMS->PreBuiltList[10].ShipList[i++] = MELEE_EARTHLING;
-		pMS->PreBuiltList[10].ShipList[i++] = MELEE_ORZ;
-		pMS->PreBuiltList[10].ShipList[i++] = MELEE_PKUNK;
-		pMS->PreBuiltList[10].ShipList[i++] = MELEE_SHOFIXTI;
-		pMS->PreBuiltList[10].ShipList[i++] = MELEE_SUPOX;
-		pMS->PreBuiltList[10].ShipList[i++] = MELEE_SYREEN;
-		pMS->PreBuiltList[10].ShipList[i++] = MELEE_UTWIG;
-		pMS->PreBuiltList[10].ShipList[i++] = MELEE_ZOQFOTPIK;
-		pMS->PreBuiltList[10].ShipList[i++] = MELEE_YEHAT;
-		pMS->PreBuiltList[10].ShipList[i++] = MELEE_DRUUGE;
-		pMS->PreBuiltList[10].ShipList[i++] = MELEE_THRADDASH;
-		pMS->PreBuiltList[10].ShipList[i++] = MELEE_SPATHI;
-	}
-
-	{
-		FleetShipIndex i = 0;
-		utf8StringCopy (pMS->PreBuiltList[11].TeamName,
-				sizeof (pMS->PreBuiltList[11].TeamName),
-				"Old Alliance Ships");
-		pMS->PreBuiltList[11].ShipList[i++] = MELEE_ARILOU;
-		pMS->PreBuiltList[11].ShipList[i++] = MELEE_CHENJESU;
-		pMS->PreBuiltList[11].ShipList[i++] = MELEE_EARTHLING;
-		pMS->PreBuiltList[11].ShipList[i++] = MELEE_MMRNMHRM;
-		pMS->PreBuiltList[11].ShipList[i++] = MELEE_SHOFIXTI;
-		pMS->PreBuiltList[11].ShipList[i++] = MELEE_SYREEN;
-		pMS->PreBuiltList[11].ShipList[i++] = MELEE_YEHAT;
-	}
-
-	{
-		FleetShipIndex i = 0;
-		utf8StringCopy (pMS->PreBuiltList[12].TeamName,
-				sizeof (pMS->PreBuiltList[12].TeamName),
-				"Old Hierarchy Ships");
-		pMS->PreBuiltList[12].ShipList[i++] = MELEE_ANDROSYNTH;
-		pMS->PreBuiltList[12].ShipList[i++] = MELEE_ILWRATH;
-		pMS->PreBuiltList[12].ShipList[i++] = MELEE_MYCON;
-		pMS->PreBuiltList[12].ShipList[i++] = MELEE_SPATHI;
-		pMS->PreBuiltList[12].ShipList[i++] = MELEE_UMGAH;
-		pMS->PreBuiltList[12].ShipList[i++] = MELEE_URQUAN;
-		pMS->PreBuiltList[12].ShipList[i++] = MELEE_VUX;
-	}
-
-	{
-		FleetShipIndex i = 0;
-		utf8StringCopy (pMS->PreBuiltList[13].TeamName,
-				sizeof (pMS->PreBuiltList[13].TeamName),
-				"Star Control 1");
-		pMS->PreBuiltList[13].ShipList[i++] = MELEE_ANDROSYNTH;
-		pMS->PreBuiltList[13].ShipList[i++] = MELEE_ARILOU;
-		pMS->PreBuiltList[13].ShipList[i++] = MELEE_CHENJESU;
-		pMS->PreBuiltList[13].ShipList[i++] = MELEE_EARTHLING;
-		pMS->PreBuiltList[13].ShipList[i++] = MELEE_ILWRATH;
-		pMS->PreBuiltList[13].ShipList[i++] = MELEE_MMRNMHRM;
-		pMS->PreBuiltList[13].ShipList[i++] = MELEE_MYCON;
-		pMS->PreBuiltList[13].ShipList[i++] = MELEE_SHOFIXTI;
-		pMS->PreBuiltList[13].ShipList[i++] = MELEE_SPATHI;
-		pMS->PreBuiltList[13].ShipList[i++] = MELEE_SYREEN;
-		pMS->PreBuiltList[13].ShipList[i++] = MELEE_UMGAH;
-		pMS->PreBuiltList[13].ShipList[i++] = MELEE_URQUAN;
-		pMS->PreBuiltList[13].ShipList[i++] = MELEE_VUX;
-		pMS->PreBuiltList[13].ShipList[i++] = MELEE_YEHAT;
-	}
-
-	{
-		FleetShipIndex i = 0;
-		utf8StringCopy (pMS->PreBuiltList[14].TeamName,
-				sizeof (pMS->PreBuiltList[14].TeamName),
-				"Star Control 2");
-		pMS->PreBuiltList[14].ShipList[i++] = MELEE_CHMMR;
-		pMS->PreBuiltList[14].ShipList[i++] = MELEE_DRUUGE;
-		pMS->PreBuiltList[14].ShipList[i++] = MELEE_KOHR_AH;
-		pMS->PreBuiltList[14].ShipList[i++] = MELEE_MELNORME;
-		pMS->PreBuiltList[14].ShipList[i++] = MELEE_ORZ;
-		pMS->PreBuiltList[14].ShipList[i++] = MELEE_PKUNK;
-		pMS->PreBuiltList[14].ShipList[i++] = MELEE_SLYLANDRO;
-		pMS->PreBuiltList[14].ShipList[i++] = MELEE_SUPOX;
-		pMS->PreBuiltList[14].ShipList[i++] = MELEE_THRADDASH;
-		pMS->PreBuiltList[14].ShipList[i++] = MELEE_UTWIG;
-		pMS->PreBuiltList[14].ShipList[i++] = MELEE_ZOQFOTPIK;
-		pMS->PreBuiltList[14].ShipList[i++] = MELEE_ZOQFOTPIK;
-		pMS->PreBuiltList[14].ShipList[i++] = MELEE_ZOQFOTPIK;
-		pMS->PreBuiltList[14].ShipList[i++] = MELEE_ZOQFOTPIK;
-	}
-}
-
 int
-LoadMeleeConfig (PMELEE_STATE pMS)
+LoadMeleeConfig (MELEE_STATE *pMS)
 {
 	uio_Stream *load_fp;
 	int status;
+	COUNT side;
 
 	load_fp = res_OpenResFile (configDir, "melee.cfg", "rb");
 	if (!load_fp)
 		goto err;
 
-	if (LengthResFile (load_fp) != (1 + sizeof (TEAM_IMAGE)) * 2)
+	if (LengthResFile (load_fp) != (1 + sizeof (TEAM_IMAGE)) * NUM_SIDES)
 		goto err;
 
-	status = GetResFileChar (load_fp);
-	if (status == -1)
-		goto err;
-	PlayerControl[0] = (BYTE)status;
-
-	status = ReadTeamImage (&pMS->TeamImage[0], load_fp);
-	if (status == -1)
-		goto err;
-
-	status = GetResFileChar (load_fp);
-	if (status == -1)
-		goto err;
-	PlayerControl[1] = (BYTE)status;
+	for (side = 0; side < NUM_SIDES; side++)
+	{
+		status = GetResFileChar (load_fp);
+		if (status == -1)
+			goto err;
+		PlayerControl[side] = (BYTE)status;
 
-	status = ReadTeamImage (&pMS->TeamImage[1], load_fp);
-	if (status == -1)
-		goto err;
+		if (!ReadTeamImage (&pMS->SideState[side].TeamImage, load_fp))
+			goto err;
 	
-	res_CloseResFile (load_fp);
-
-	/* Do not allow netplay mode at the start. */
-	if (PlayerControl[0] & NETWORK_CONTROL)
-		PlayerControl[0] = HUMAN_CONTROL | STANDARD_RATING;
-	if (PlayerControl[1] & NETWORK_CONTROL)
-		PlayerControl[1] = HUMAN_CONTROL | STANDARD_RATING;
+		/* Do not allow netplay mode at the start. */
+		if (PlayerControl[side] & NETWORK_CONTROL)
+			PlayerControl[side] = HUMAN_CONTROL | STANDARD_RATING;
+	}
 
+	res_CloseResFile (load_fp);
 	return 0;
 
 err:
@@ -2949,25 +2250,23 @@ err:
 }
 
 int
-WriteMeleeConfig (PMELEE_STATE pMS)
+WriteMeleeConfig (MELEE_STATE *pMS)
 {
 	uio_Stream *save_fp;
+	COUNT side;
 
 	save_fp = res_OpenResFile (configDir, "melee.cfg", "wb");
 	if (!save_fp)
 		goto err;
 
-	if (PutResFileChar (PlayerControl[0], save_fp) == -1)
-		goto err;
-
-	if (WriteTeamImage (&pMS->TeamImage[0], save_fp) == 0)
-		goto err;
-
-	if (PutResFileChar (PlayerControl[1], save_fp) == -1)
-		goto err;
+	for (side = 0; side < NUM_SIDES; side++)
+	{
+		if (PutResFileChar (PlayerControl[side], save_fp) == -1)
+			goto err;
 
-	if (WriteTeamImage (&pMS->TeamImage[1], save_fp) == 0)
-		goto err;
+		if (WriteTeamImage (&pMS->SideState[side].TeamImage, save_fp) == 0)
+			goto err;
+	}
 
 	if (!res_CloseResFile (save_fp))
 		goto err;
@@ -2996,6 +2295,12 @@ Melee (void)
 		MenuState.InputFunc = DoMelee;
 		MenuState.Initialized = FALSE;
 
+		MenuState.randomContext = RandomContext_New ();
+		RandomContext_SeedRandom (MenuState.randomContext,
+				GetTimeCounter ());
+				// Using the current time still leave the random state a bit
+				// predictable, but it is good enough.
+
 #ifdef NETPLAY
 		{
 			COUNT player;
@@ -3005,7 +2310,7 @@ Melee (void)
 #endif
 		
 		MenuState.CurIndex = (COUNT)~0;
-		InitPreBuilt (&MenuState);
+		InitMeleeLoadState (&MenuState);
 
 		GLOBAL (CurrentActivity) = SUPER_MELEE;
 
@@ -3014,21 +2319,22 @@ Melee (void)
 		if (LoadMeleeConfig (&MenuState) == -1)
 		{
 			PlayerControl[0] = HUMAN_CONTROL | STANDARD_RATING;
-			MenuState.TeamImage[0] = MenuState.PreBuiltList[0];
+			MenuState.SideState[0].TeamImage = MenuState.load.preBuiltList[0];
 			PlayerControl[1] = COMPUTER_CONTROL | STANDARD_RATING;
-			MenuState.TeamImage[1] = MenuState.PreBuiltList[1];
+			MenuState.SideState[1].TeamImage = MenuState.load.preBuiltList[1];
 		}
-		SetPlayerInput ();
 		teamStringChanged (&MenuState, 0);
 		teamStringChanged (&MenuState, 1);
 		entireFleetChanged (&MenuState, 0);
 		entireFleetChanged (&MenuState, 1);
 
 		MenuState.side = 0;
-		MenuState.star_bucks[0] = GetTeamValue (&MenuState.TeamImage[0]);
-		MenuState.star_bucks[1] = GetTeamValue (&MenuState.TeamImage[1]);
+		MenuState.SideState[0].star_bucks =
+				GetTeamValue (&MenuState.SideState[0].TeamImage);
+		MenuState.SideState[1].star_bucks =
+				GetTeamValue (&MenuState.SideState[1].TeamImage);
 		SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
-		DoInput ((PVOID)&MenuState, TRUE);
+		DoInput (&MenuState, TRUE);
 
 		StopMusic ();
 		WaitForSoundEnd (TFBSOUND_WAIT_ALL);
@@ -3041,20 +2347,24 @@ Melee (void)
 		DestroyDrawable (ReleaseDrawable (PickMeleeFrame));
 		PickMeleeFrame = 0;
 
+		UninitMeleeLoadState (&MenuState);
+
+		RandomContext_Delete (MenuState.randomContext);
+
 		FlushInput ();
 	}
 }
 
 // Notify the network connections of a team name change.
 void
-teamStringChanged (PMELEE_STATE pMS, int player)
+teamStringChanged (MELEE_STATE *pMS, int player)
 {
 #ifdef NETPLAY
 	const char *name;
 	size_t len;
 	size_t playerI;
 
-	name = pMS->TeamImage[player].TeamName;
+	name = pMS->SideState[player].TeamImage.TeamName;
 	len = strlen (name);
 	for (playerI = 0; playerI < NUM_PLAYERS; playerI++)
 	{
@@ -3079,7 +2389,7 @@ teamStringChanged (PMELEE_STATE pMS, int
 
 // Notify the network connections of the configuration of a fleet.
 void
-entireFleetChanged (PMELEE_STATE pMS, int player)
+entireFleetChanged (MELEE_STATE *pMS, int player)
 {
 #ifdef NETPLAY
 	size_t playerI;
@@ -3096,7 +2406,7 @@ entireFleetChanged (PMELEE_STATE pMS, in
 			continue;
 
 		Netplay_entireFleetChanged (conn, player,
-				pMS->TeamImage[player].ShipList, MELEE_FLEET_SIZE);
+				pMS->SideState[player].TeamImage.ShipList, MELEE_FLEET_SIZE);
 	}
 #else
 	(void) player;
@@ -3106,7 +2416,7 @@ entireFleetChanged (PMELEE_STATE pMS, in
 
 // Notify the network of a change in the configuration of a fleet.
 void
-fleetShipChanged (PMELEE_STATE pMS, int player, size_t index)
+fleetShipChanged (MELEE_STATE *pMS, int player, size_t index)
 {
 #ifdef NETPLAY
 	size_t playerI;
@@ -3124,7 +2434,7 @@ fleetShipChanged (PMELEE_STATE pMS, int
 			continue;
 
 		Netplay_fleetShipChanged (conn, player, index,
-				pMS->TeamImage[player].ShipList[index]);
+				pMS->SideState[player].TeamImage.ShipList[index]);
 	}
 #else
 	(void) player;
@@ -3137,7 +2447,7 @@ fleetShipChanged (PMELEE_STATE pMS, int
 // NB: 'len' does not include the terminating 0.
 //     'len' counts in bytes, not in characters.
 void
-updateTeamName (PMELEE_STATE pMS, COUNT side, const char *name,
+updateTeamName (MELEE_STATE *pMS, COUNT side, const char *name,
 		size_t len)
 {
 	// NB: MAX_TEAM_CHARS is the maximum number of characters,
@@ -3146,8 +2456,8 @@ updateTeamName (PMELEE_STATE pMS, COUNT
 		len = MAX_TEAM_CHARS;
 
 	// TeamName has space for at least MAX_TEAM_CHARS + 1 bytes.
-	strncpy (pMS->TeamImage[side].TeamName, name, len);
-	pMS->TeamImage[side].TeamName[len] = '\0';
+	strncpy (pMS->SideState[side].TeamImage.TeamName, name, len);
+	pMS->SideState[side].TeamImage.TeamName[len] = '\0';
 	
 	LockMutex (GraphicsLock);
 #if 0  /* DTSHS_REPAIR does not combine with other options */
@@ -3162,7 +2472,7 @@ updateTeamName (PMELEE_STATE pMS, COUNT
 
 // Update a ship in a fleet as specified by a remote party.
 bool
-updateFleetShip (PMELEE_STATE pMS, COUNT side, COUNT index, BYTE ship)
+updateFleetShip (MELEE_STATE *pMS, COUNT side, COUNT index, BYTE ship)
 {
 	BYTE row = GetShipRow (index);
 	BYTE col = GetShipColumn (index);
@@ -3172,14 +2482,14 @@ updateFleetShip (PMELEE_STATE pMS, COUNT
 	BOOLEAN isSelected;
 
 	if (ship >= NUM_MELEE_SHIPS && ship != MELEE_NONE) {
-		fprintf (stderr, "Invalid ship type number %d (max = %d).\n",
+		log_add (log_Warning, "Invalid ship type number %d (max = %d).\n",
 				ship, NUM_MELEE_SHIPS - 1);
 		return false;
 	}
 	
 	if (index >= MELEE_FLEET_SIZE)
 	{
-		fprintf (stderr, "Invalid ship position number %d (max = %d).\n",
+		log_add (log_Warning, "Invalid ship position number %d (max = %d).\n",
 				index, MELEE_FLEET_SIZE - 1);
 		return false;
 	}
@@ -3188,11 +2498,11 @@ updateFleetShip (PMELEE_STATE pMS, COUNT
 	if (val == (COUNT) ~0)
 		return false;
 
-	pMS->star_bucks[side] -=
-			GetShipValue (pMS->TeamImage[side].ShipList[index]);
-	pMS->star_bucks[side] += val;
+	pMS->SideState[side].star_bucks -=
+			GetShipValue (pMS->SideState[side].TeamImage.ShipList[index]);
+	pMS->SideState[side].star_bucks += val;
 
-	pMS->TeamImage[side].ShipList[index] = ship;
+	pMS->SideState[side].TeamImage.ShipList[index] = ship;
 
 	selectedShipIndex = GetShipIndex (pMS->row, pMS->col);
 	isSelected = (pMS->MeleeOption == EDIT_MELEE) &&
@@ -3223,7 +2533,7 @@ updateFleetShip (PMELEE_STATE pMS, COUNT
 }
 
 void
-updateRandomSeed (PMELEE_STATE pMS, COUNT side, DWORD seed)
+updateRandomSeed (MELEE_STATE *pMS, COUNT side, DWORD seed)
 {
 	TFB_SeedRandom (seed);
 	(void) pMS;
@@ -3232,7 +2542,7 @@ updateRandomSeed (PMELEE_STATE pMS, COUN
 
 // The remote player has done something which invalidates our confirmation.
 void
-confirmationCancelled(PMELEE_STATE pMS, COUNT side)
+confirmationCancelled (MELEE_STATE *pMS, COUNT side)
 {
 	LockMutex (GraphicsLock);
 	if (side == 0)
@@ -3266,7 +2576,7 @@ connectionFeedback (NetConnection *conn,
 
 void
 connectedFeedback (NetConnection *conn) {
-	if (NetConnection_getPlayerNr(conn) == 0)
+	if (NetConnection_getPlayerNr (conn) == 0)
 		connectionFeedback (conn, GAME_STRING (NETMELEE_STRING_BASE + 8),
 				false);
 				// "Bottom player is connected."
@@ -3279,7 +2589,7 @@ connectedFeedback (NetConnection *conn)
 }
 
 const char *
-abortReasonString (NetplayResetReason reason)
+abortReasonString (NetplayAbortReason reason)
 {
 	switch (reason)
 	{
@@ -3289,8 +2599,12 @@ abortReasonString (NetplayResetReason re
 		case AbortReason_versionMismatch:
 			return GAME_STRING (NETMELEE_STRING_BASE + 26);
 					// "Connection aborted due to version mismatch."
-		case AbortReason_protocolError:
+		case AbortReason_invalidHash:
 			return GAME_STRING (NETMELEE_STRING_BASE + 27);
+					// "Connection aborted because the remote side sent a "
+					// "fake signature."
+		case AbortReason_protocolError:
+			return GAME_STRING (NETMELEE_STRING_BASE + 28);
 					// "Connection aborted due to an internal protocol "
 					// "error."
 	}
@@ -3315,13 +2629,13 @@ resetReasonString (NetplayResetReason re
 	switch (reason)
 	{
 		case ResetReason_unspecified:
-			return GAME_STRING (NETMELEE_STRING_BASE + 28);
+			return GAME_STRING (NETMELEE_STRING_BASE + 29);
 					// "Game aborted for an unspecified reason."
 		case ResetReason_syncLoss:
-			return GAME_STRING (NETMELEE_STRING_BASE + 29);
+			return GAME_STRING (NETMELEE_STRING_BASE + 30);
 					// "Game aborted due to loss of synchronisation."
 		case ResetReason_manualReset:
-			return GAME_STRING (NETMELEE_STRING_BASE + 30);
+			return GAME_STRING (NETMELEE_STRING_BASE + 31);
 					// "Game aborted by the remote player."
 	}
 
@@ -3356,7 +2670,7 @@ resetFeedback (NetConnection *conn, Netp
 void
 errorFeedback (NetConnection *conn)
 {
-	if (NetConnection_getPlayerNr(conn) == 0)
+	if (NetConnection_getPlayerNr (conn) == 0)
 		connectionFeedback (conn, GAME_STRING (NETMELEE_STRING_BASE + 10),
 				false);
 				// "Bottom player: connection failed."
@@ -3369,7 +2683,7 @@ errorFeedback (NetConnection *conn)
 void
 closeFeedback (NetConnection *conn)
 {
-	if (NetConnection_getPlayerNr(conn) == 0)
+	if (NetConnection_getPlayerNr (conn) == 0)
 		connectionFeedback (conn, GAME_STRING (NETMELEE_STRING_BASE + 12),
 				false);
 				// "Bottom player: connection closed."
diff -ruNp src.orig/sc2code/melee.h src/sc2code/melee.h
--- src.orig/sc2code/melee.h	2017-11-08 16:49:34 -0600
+++ src/sc2code/melee.h	2017-11-08 16:50:01 -0600
@@ -22,10 +22,11 @@
 #include "init.h"
 #include "libs/tasklib.h"
 #include "libs/gfxlib.h"
+#include "libs/mathlib.h"
 #include "libs/sndlib.h"
 #include "libs/reslib.h"
 #include "netplay/packet.h"
-		// for NetplayAbortREason and NetplayResetReason.
+		// for NetplayAbortReason and NetplayResetReason.
 
 typedef struct melee_state MELEE_STATE;
 
@@ -71,11 +72,12 @@ enum
 
 extern FRAME PickMeleeFrame;
 
-#define PICK_BG_COLOR BUILD_COLOR (MAKE_RGB15 (0x00, 0x01, 0x0F), 0x01)
+#define PICK_BG_COLOR    BUILD_COLOR (MAKE_RGB15 (0x00, 0x01, 0x0F), 0x01)
+#define PICK_VALUE_COLOR BUILD_COLOR (MAKE_RGB15 (0x13, 0x00, 0x00), 0x2C)
+		// Used for the current fleet value in the next ship selection
+		// in SuperMelee.
 
 #define MAX_TEAM_CHARS 30
-#define MAX_VIS_TEAMS 5
-#define NUM_PREBUILT 15
 #define NUM_PICK_COLS 5
 #define NUM_PICK_ROWS 5
 
@@ -90,6 +92,14 @@ typedef struct
 			 * default name in starcon.txt is unknowingly mangled. */
 } TEAM_IMAGE;
 
+#include "loadmele.h"
+
+struct melee_side_state
+{
+	TEAM_IMAGE TeamImage;
+	COUNT star_bucks;
+};
+
 struct melee_state
 {
 	BOOLEAN (*InputFunc) (struct melee_state *pInputState);
@@ -97,33 +107,36 @@ struct melee_state
 
 	BOOLEAN Initialized;
 	MELEE_OPTIONS MeleeOption;
-	DIRENTRY TeamDE;
-	COUNT TopTeamIndex, BotTeamIndex;
 	COUNT side, row, col;
-	TEAM_IMAGE TeamImage[NUM_SIDES];
-	COUNT star_bucks[NUM_SIDES];
+	struct melee_side_state SideState[NUM_SIDES];
+	struct melee_load_state load;
 	COUNT CurIndex;
 	Task flash_task;
-	TEAM_IMAGE FileList[MAX_VIS_TEAMS];
-	TEAM_IMAGE PreBuiltList[NUM_PREBUILT];
+	RandomContext *randomContext;
+			/* RNG state for all local random decisions, i.e. those
+			 * decisions that are not shared among network parties. */
 
 	MUSIC_REF hMusic;
 };
-typedef MELEE_STATE *PMELEE_STATE;
-
-extern PMELEE_STATE volatile pMeleeState;
 
 extern void Melee (void);
 
-void teamStringChanged (PMELEE_STATE pMS, int player);
-void entireFleetChanged (PMELEE_STATE pMS, int player);
-void fleetShipChanged (PMELEE_STATE pMS, int player, size_t index);
+// Some prototypes for use by loadmele.c:
+BOOLEAN DoMelee (MELEE_STATE *pMS);
+void DrawMeleeIcon (COUNT which_icon);
+COUNT GetTeamValue (TEAM_IMAGE *pTI);
+void RepairMeleeFrame (RECT *pRect);
+extern FRAME MeleeFrame;
+
+void teamStringChanged (MELEE_STATE *pMS, int player);
+void entireFleetChanged (MELEE_STATE *pMS, int player);
+void fleetShipChanged (MELEE_STATE *pMS, int player, size_t index);
 
-void updateTeamName (PMELEE_STATE pMS, COUNT side, const char *name,
+void updateTeamName (MELEE_STATE *pMS, COUNT side, const char *name,
 		size_t len);
-bool updateFleetShip (PMELEE_STATE pMS, COUNT side, COUNT index, BYTE ship);
-void updateRandomSeed (PMELEE_STATE pMS, COUNT side, DWORD seed);
-void confirmationCancelled(PMELEE_STATE pMS, COUNT side);
+bool updateFleetShip (MELEE_STATE *pMS, COUNT side, COUNT index, BYTE ship);
+void updateRandomSeed (MELEE_STATE *pMS, COUNT side, DWORD seed);
+void confirmationCancelled(MELEE_STATE *pMS, COUNT side);
 void connectedFeedback (NetConnection *conn);
 void abortFeedback (NetConnection *conn, NetplayAbortReason reason);
 void resetFeedback (NetConnection *conn, NetplayResetReason reason,
diff -ruNp src.orig/sc2code/menu.c src/sc2code/menu.c
--- src.orig/sc2code/menu.c	2017-11-08 16:49:34 -0600
+++ src/sc2code/menu.c	2017-11-08 16:50:01 -0600
@@ -397,7 +397,7 @@ ConvertAlternateMenu (BYTE BaseState, BY
 }
 
 BOOLEAN
-DoMenuChooser (PMENU_STATE pMS, BYTE BaseState)
+DoMenuChooser (MENU_STATE *pMS, BYTE BaseState)
 {
 	{
 
@@ -430,6 +430,16 @@ DoMenuChooser (PMENU_STATE pMS, BYTE Bas
 			}
 			return (FALSE);
 		}
+		else if ((optWhichMenu == OPT_PC) && PulsedInputState.menu[KEY_MENU_CANCEL] && 
+				(BaseState == PM_ALT_CARGO))
+		{
+			if (OrigBase == PM_SCAN)
+				DrawMenuStateStrings (PM_ALT_SCAN, PM_ALT_MANIFEST - PM_ALT_SCAN);
+			else
+				DrawMenuStateStrings (PM_ALT_STARMAP, PM_ALT_MANIFEST - PM_ALT_STARMAP);
+			pMS->CurState = ALT_MANIFEST;
+			return (TRUE);
+		}
 		else
 			return (FALSE);
 		DrawMenuStateStrings (BaseState, NewState);
diff -ruNp src.orig/sc2code/menustat.h src/sc2code/menustat.h
--- src.orig/sc2code/menustat.h	2017-11-08 16:49:34 -0600
+++ src/sc2code/menustat.h	2017-11-08 16:50:02 -0600
@@ -47,9 +47,7 @@ typedef struct menu_state
 	void *Extra;
 } MENU_STATE;
 
-typedef MENU_STATE *PMENU_STATE;
-
-extern PMENU_STATE pMenuState;
+extern MENU_STATE *pMenuState;
 
 #endif /* _MENUSTAT_H */
 
diff -ruNp src.orig/sc2code/misc.c src/sc2code/misc.c
--- src.orig/sc2code/misc.c	2017-11-08 16:49:34 -0600
+++ src/sc2code/misc.c	2017-11-08 16:50:02 -0600
@@ -33,7 +33,7 @@ spawn_planet (void)
 	hPlanetElement = AllocElement ();
 	if (hPlanetElement)
 	{
-		ELEMENTPTR PlanetElementPtr;
+		ELEMENT *PlanetElementPtr;
 		extern FRAME planet[];
 
 		LockElement (hPlanetElement, &PlanetElementPtr);
@@ -66,14 +66,14 @@ spawn_planet (void)
 extern FRAME asteroid[];
 
 static void
-spawn_rubble (PELEMENT AsteroidElementPtr)
+spawn_rubble (ELEMENT *AsteroidElementPtr)
 {
 	HELEMENT hRubbleElement;
 	
 	hRubbleElement = AllocElement ();
 	if (hRubbleElement)
 	{
-		ELEMENTPTR RubbleElementPtr;
+		ELEMENT *RubbleElementPtr;
 
 		PutElement (hRubbleElement);
 		LockElement (hRubbleElement, &RubbleElementPtr);
@@ -92,7 +92,7 @@ spawn_rubble (PELEMENT AsteroidElementPt
 }
 
 static void
-asteroid_preprocess (PELEMENT ElementPtr)
+asteroid_preprocess (ELEMENT *ElementPtr)
 {
 	if (ElementPtr->turn_wait > 0)
 		--ElementPtr->turn_wait;
@@ -115,7 +115,7 @@ asteroid_preprocess (PELEMENT ElementPtr
 }
 
 void
-spawn_asteroid (PELEMENT ElementPtr)
+spawn_asteroid (ELEMENT *ElementPtr)
 {
 	HELEMENT hAsteroidElement;
 
@@ -130,7 +130,7 @@ spawn_asteroid (PELEMENT ElementPtr)
 	}
 	else
 	{
-		ELEMENTPTR AsteroidElementPtr;
+		ELEMENT *AsteroidElementPtr;
 		COUNT val;
 
 		LockElement (hAsteroidElement, &AsteroidElementPtr);
@@ -187,7 +187,7 @@ spawn_asteroid (PELEMENT ElementPtr)
 }
 
 void
-do_damage (ELEMENTPTR ElementPtr, SIZE damage)
+do_damage (ELEMENT *ElementPtr, SIZE damage)
 {
 	if (ElementPtr->state_flags & PLAYER_SHIP)
 	{
@@ -211,7 +211,7 @@ do_damage (ELEMENTPTR ElementPtr, SIZE d
 }
 
 void
-crew_preprocess (PELEMENT ElementPtr)
+crew_preprocess (ELEMENT *ElementPtr)
 {
 	HELEMENT hTarget;
 
@@ -222,7 +222,7 @@ crew_preprocess (PELEMENT ElementPtr)
 
 	if ((hTarget = ElementPtr->hTarget) == 0)
 	{
-		STARSHIPPTR StarShipPtr;
+		STARSHIP *StarShipPtr;
 
 		GetElementStarShip (ElementPtr, &StarShipPtr);
 		if (StarShipPtr && StarShipPtr->RaceDescPtr->ship_info.crew_level)
@@ -232,7 +232,7 @@ crew_preprocess (PELEMENT ElementPtr)
 			COUNT facing;
 
 			facing = 0;
-			TrackShip ((ELEMENTPTR)ElementPtr, &facing);
+			TrackShip (ElementPtr, &facing);
 		}
 	}
 
@@ -240,7 +240,7 @@ crew_preprocess (PELEMENT ElementPtr)
 	{
 #define CREW_DELTA SCALED_ONE
 		SIZE delta;
-		ELEMENTPTR ShipPtr;
+		ELEMENT *ShipPtr;
 
 		LockElement (hTarget, &ShipPtr);
 		delta = ShipPtr->current.location.x
@@ -263,20 +263,20 @@ crew_preprocess (PELEMENT ElementPtr)
 }
 
 void
-crew_collision (PELEMENT ElementPtr0, PPOINT pPt0,
-		PELEMENT ElementPtr1, PPOINT pPt1)
+crew_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
 	if ((ElementPtr1->state_flags & PLAYER_SHIP)
 			&& ElementPtr1->life_span >= NORMAL_LIFE
 			&& ElementPtr0->hit_points > 0)
 	{
-		STARSHIPPTR StarShipPtr;
+		STARSHIP *StarShipPtr;
 
 		GetElementStarShip (ElementPtr1, &StarShipPtr);
 		if (!(StarShipPtr->RaceDescPtr->ship_info.ship_flags & CREW_IMMUNE))
 		{
 			ProcessSound (SetAbsSoundIndex (GameSounds, GRAB_CREW), ElementPtr1);
-			DeltaCrew ((ELEMENTPTR)ElementPtr1, 1);
+			DeltaCrew (ElementPtr1, 1);
 		}
 	}
 
@@ -288,13 +288,13 @@ crew_collision (PELEMENT ElementPtr0, PP
 }
 
 void
-AbandonShip (ELEMENTPTR ShipPtr, ELEMENTPTR TargetPtr,
+AbandonShip (ELEMENT *ShipPtr, ELEMENT *TargetPtr,
 		COUNT crew_loss)
 {
 	SIZE dx, dy;
 	COUNT direction;
 	RECT r;
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	HELEMENT hCrew;
 	INTERSECT_CONTROL ShipIntersect;
 
@@ -319,7 +319,7 @@ AbandonShip (ELEMENTPTR ShipPtr, ELEMENT
 	while (crew_loss-- && (hCrew = AllocElement ()))
 	{
 #define CREW_LIFE 300
-		ELEMENTPTR CrewPtr;
+		ELEMENT *CrewPtr;
 
 		DeltaCrew (ShipPtr, -1);
 
diff -ruNp src.orig/sc2code/nameref.h src/sc2code/nameref.h
--- src.orig/sc2code/nameref.h	2017-11-08 16:49:34 -0600
+++ src/sc2code/nameref.h	2017-11-08 16:50:02 -0600
@@ -19,24 +19,15 @@
 #ifndef _NAMEREF_H
 #define _NAMEREF_H
 
-#include "restypes.h"
+#include "reslib.h"
 
 #define LoadCodeRes     LoadCodeResInstance
-#define LoadGraphic     LoadGraphicInstance
-#define LoadFont        LoadGraphicInstance
+#define LoadGraphic     (DRAWABLE)LoadGraphicInstance
+#define LoadFont        (FONT)LoadGraphicInstance
 #define LoadColorMap    LoadColorMapInstance
 #define LoadStringTable LoadStringTableInstance
 #define LoadSound       LoadSoundInstance
 #define LoadMusic       LoadMusicInstance
 
-#define INIT_INSTANCES() do \
-		{ \
-			InstallGraphicResTypes (GFXRES, FONTRES); \
-			InstallStringTableResType (STRTAB); \
-			InstallAudioResTypes (SNDRES, MUSICRES); \
-			InstallCodeResType (CODE); \
-		} while (0)
-#define UNINIT_INSTANCES()
-
 #endif /* _NAMEREF_H */
 
diff -ruNp src.orig/sc2code/netplay/checksum.c src/sc2code/netplay/checksum.c
--- src.orig/sc2code/netplay/checksum.c	2017-11-08 16:49:34 -0600
+++ src/sc2code/netplay/checksum.c	2017-11-08 16:50:02 -0600
@@ -32,25 +32,24 @@
 #include "libs/mathlib.h"
 #include "libs/misc.h"
 
-
 ChecksumBuffer localChecksumBuffer;
 
 void
 crc_processEXTENT(crc_State *state, const EXTENT *val) {
 #ifdef DUMP_CRC_OPS
-	log_add(log_Debug, "START crc_processEXTENT().");
+	crc_log("START crc_processEXTENT().");
 #endif
 	crc_processCOORD(state, val->width);
 	crc_processCOORD(state, val->height);
 #ifdef DUMP_CRC_OPS
-	log_add(log_Debug, "END   crc_processEXTENT().");
+	crc_log("END   crc_processEXTENT().");
 #endif
 }
 
 void
 crc_processVELOCITY_DESC(crc_State *state, const VELOCITY_DESC *val) {
 #ifdef DUMP_CRC_OPS
-	log_add(log_Debug, "START crc_processVELOCITY_DESC().");
+	crc_log("START crc_processVELOCITY_DESC().");
 #endif
 	crc_processCOUNT(state, val->TravelAngle);
 	crc_processEXTENT(state, &val->vector);
@@ -58,19 +57,19 @@ crc_processVELOCITY_DESC(crc_State *stat
 	crc_processEXTENT(state, &val->error);
 	crc_processEXTENT(state, &val->incr);
 #ifdef DUMP_CRC_OPS
-	log_add(log_Debug, "END   crc_processVELOCITY_DESC().");
+	crc_log("END   crc_processVELOCITY_DESC().");
 #endif
 }
 
 void
 crc_processPOINT(crc_State *state, const POINT *val) {
 #ifdef DUMP_CRC_OPS
-	log_add(log_Debug, "START crc_processPOINT().");
+	crc_log("START crc_processPOINT().");
 #endif
 	crc_processCOORD(state, val->x);
 	crc_processCOORD(state, val->y);
 #ifdef DUMP_CRC_OPS
-	log_add(log_Debug, "END   crc_processPOINT().");
+	crc_log("END   crc_processPOINT().");
 #endif
 }
 
@@ -78,24 +77,24 @@ crc_processPOINT(crc_State *state, const
 void
 crc_processSTAMP(crc_State *state, const STAMP *val) {
 #ifdef DUMP_CRC_OPS
-	log_add(log_Debug, "START crc_processSTAMP().");
+	crc_log("START crc_processSTAMP().");
 #endif
 	crc_processPOINT(state, val->origin);
 	crc_processFRAME(state, val->frame);
 #ifdef DUMP_CRC_OPS
-	log_add(log_Debug, "END   crc_processSTAMP().");
+	crc_log("END   crc_processSTAMP().");
 #endif
 }
 
 void
 crc_processINTERSECT_CONTROL(crc_State *state, const INTERSECT_CONTROL *val) {
 #ifdef DUMP_CRC_OPS
-	log_add(log_Debug, "START crc_processINTERSECT_CONTROL().");
+	crc_log("START crc_processINTERSECT_CONTROL().");
 #endif
 	crc_processTIME_VALUE(state, val->last_time_val);
 	crc_processPOINT(state, &val->EndPoint);
 #ifdef DUMP_CRC_OPS
-	log_add(log_Debug, "END   crc_processINTERSECT_CONTROL().");
+	crc_log("END   crc_processINTERSECT_CONTROL().");
 #endif
 }
 #endif
@@ -108,32 +107,40 @@ crc_processSTATE(crc_State *state, const
 void
 crc_processELEMENT(crc_State *state, const ELEMENT *val) {
 #ifdef DUMP_CRC_OPS
-	log_add(log_Debug, "START crc_processELEMENT().");
+	crc_log("START crc_processELEMENT().");
 #endif
-	crc_processELEMENT_FLAGS(state, val->state_flags);
-	crc_processCOUNT(state, val->life_span);
-	crc_processCOUNT(state, val->crew_level);
-	crc_processBYTE(state, val->mass_points);
-
-	// HACK: when a ship is being destroyed, turn_wait is abused to store
-	// the side this ship is on. This must be excluded from the checksum
-	// as this does not have to be the same for both sides.
-	{
-		extern void new_ship(PELEMENT ElementPtr);
-		BYTE turn_wait = val->turn_wait;
-		
-		if (val->preprocess_func == new_ship)
-			turn_wait = 0;
-
-		crc_processBYTE(state, turn_wait);
+	if (val->state_flags & BACKGROUND_OBJECT) {
+		// The element never influences the state of other elements,
+		// and is to be excluded from checksums.
+#ifdef DUMP_CRC_OPS
+		crc_log("      BACKGROUND_OBJECT element omited");
+#endif
+	} else {
+		crc_processELEMENT_FLAGS(state, val->state_flags);
+		crc_processCOUNT(state, val->life_span);
+		crc_processCOUNT(state, val->crew_level);
+		crc_processBYTE(state, val->mass_points);
+
+		// HACK: when a ship is being destroyed, turn_wait is abused to store
+		// the side this ship is on. This must be excluded from the checksum
+		// as this does not have to be the same for both sides.
+		{
+			extern void new_ship(ELEMENT *ElementPtr);
+			BYTE turn_wait = val->turn_wait;
+			
+			if (val->preprocess_func == new_ship)
+				turn_wait = 0;
+
+			crc_processBYTE(state, turn_wait);
+		}
+
+		crc_processBYTE(state, val->thrust_wait);
+		crc_processVELOCITY_DESC(state, &val->velocity);
+		crc_processSTATE(state, &val->current);
+		crc_processSTATE(state, &val->next);
 	}
-
-	crc_processBYTE(state, val->thrust_wait);
-	crc_processVELOCITY_DESC(state, &val->velocity);
-	crc_processSTATE(state, &val->current);
-	crc_processSTATE(state, &val->next);
 #ifdef DUMP_CRC_OPS
-	log_add(log_Debug, "END   crc_processELEMENT().");
+	crc_log("END   crc_processELEMENT().");
 #endif
 }
 
@@ -144,17 +151,17 @@ crc_processDispQueue(crc_State *state) {
 
 #ifdef DUMP_CRC_OPS
 	size_t i = 0;
-	log_add(log_Debug, "START crc_processDispQueue().");
+	crc_log("START crc_processDispQueue().");
 #endif
 	for (element = GetHeadElement(); element != 0; element = nextElement) {
-		ELEMENTPTR elementPtr;
+		ELEMENT *elementPtr;
 
 #ifdef DUMP_CRC_OPS
-		log_add(log_Debug, "===== disp_q[%d]:", i);
+		crc_log("===== disp_q[%d]:", i);
 #endif
 		LockElement(element, &elementPtr);
 
-		crc_processELEMENT(state, element);
+		crc_processELEMENT(state, elementPtr);
 
 		nextElement = GetSuccElement(elementPtr);
 		UnlockElement(element);
@@ -163,7 +170,7 @@ crc_processDispQueue(crc_State *state) {
 #endif
 	}
 #ifdef DUMP_CRC_OPS
-	log_add(log_Debug, "END   crc_processDispQueue().");
+	crc_log("END   crc_processDispQueue().");
 #endif
 }
 
@@ -172,7 +179,7 @@ crc_processRNG(crc_State *state) {
 	DWORD seed;
 
 #ifdef DUMP_CRC_OPS
-	log_add(log_Debug, "START crc_processRNG().");
+	crc_log("START crc_processRNG().");
 #endif
 
 	seed = TFB_SeedRandom(0);
@@ -182,14 +189,14 @@ crc_processRNG(crc_State *state) {
 			// Restore the old seed.
 
 #ifdef DUMP_CRC_OPS
-	log_add(log_Debug, "END   crc_processRNG().");
+	crc_log("END   crc_processRNG().");
 #endif
 }
 
 void
 crc_processState(crc_State *state) {
 #ifdef DUMP_CRC_OPS
-	log_add(log_Debug, "--------------------\n"
+	crc_log("--------------------\n"
 			"START crc_processState() (frame %u).", battleFrameCount);
 #endif
 
@@ -197,7 +204,7 @@ crc_processState(crc_State *state) {
 	crc_processDispQueue(state);
 
 #ifdef DUMP_CRC_OPS
-	log_add(log_Debug, "END   crc_processState() (frame %u).",
+	crc_log("END   crc_processState() (frame %u).",
 			battleFrameCount);
 #endif
 }
diff -ruNp src.orig/sc2code/netplay/checksum.h src/sc2code/netplay/checksum.h
--- src.orig/sc2code/netplay/checksum.h	2017-11-08 16:49:34 -0600
+++ src/sc2code/netplay/checksum.h	2017-11-08 16:50:02 -0600
@@ -25,6 +25,7 @@
 typedef uint32 Checksum;
 
 
+#include "netplay.h"
 #include "crc.h"
 
 #include "element.h"
diff -ruNp src.orig/sc2code/netplay/crc.c src/sc2code/netplay/crc.c
--- src.orig/sc2code/netplay/crc.c	2017-11-08 16:49:34 -0600
+++ src/sc2code/netplay/crc.c	2017-11-08 16:50:02 -0600
@@ -16,6 +16,9 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+#include "netplay.h"
+		// For DUMP_CRC_OPS
+
 #include "crc.h"
 
 #ifdef DUMP_CRC_OPS
@@ -84,7 +87,7 @@ crc_processBytes(crc_State *state, uint8
 		newCrc = (newCrc >> 8) ^ crcTable[(newCrc ^ *buf) & 0xff];
 
 #ifdef DUMP_CRC_OPS
-	log_add(log_Debug, "crc_processBytes(%08x, [%zu bytes]) --> %08x.",
+	crc_log("crc_processBytes(%08x, [%zu bytes]) --> %08x.",
 			state->crc, bufLen, newCrc);
 #endif
 	state->crc = newCrc;
@@ -96,7 +99,7 @@ crc_processUint8(crc_State *state, uint8
 
 	newCrc = (newCrc >> 8) ^ crcTable[(newCrc ^ val) & 0xff];
 #ifdef DUMP_CRC_OPS
-	log_add(log_Debug, "crc_processUint8(%08x, %02x) --> %08x.",
+	crc_log("crc_processUint8(%08x, %02x) --> %08x.",
 			state->crc, (int) val, newCrc);
 #endif
 	state->crc = newCrc;
@@ -109,7 +112,7 @@ crc_processUint16(crc_State *state, uint
 	newCrc = (newCrc >> 8) ^ crcTable[(newCrc ^ (val & 0xff)) & 0xff];
 	newCrc = (newCrc >> 8) ^ crcTable[(newCrc ^ (val >> 8)  ) & 0xff];
 #ifdef DUMP_CRC_OPS
-	log_add(log_Debug, "crc_processUint16(%08x, %04x) --> %08x.",
+	crc_log("crc_processUint16(%08x, %04x) --> %08x.",
 			state->crc, (int) val, newCrc);
 #endif
 	state->crc = newCrc;
@@ -125,7 +128,7 @@ crc_processUint32(crc_State *state, uint
 	newCrc = (newCrc >> 8) ^ crcTable[(newCrc ^ ((val >> 24)       )) & 0xff];
 
 #ifdef DUMP_CRC_OPS
-	log_add(log_Debug, "crc_processUint32(%08x, %08x) --> %08x.",
+	crc_log("crc_processUint32(%08x, %08x) --> %08x.",
 			state->crc, (int) val, newCrc);
 #endif
 	state->crc = newCrc;
diff -ruNp src.orig/sc2code/netplay/crc.h src/sc2code/netplay/crc.h
--- src.orig/sc2code/netplay/crc.h	2017-11-08 16:49:34 -0600
+++ src/sc2code/netplay/crc.h	2017-11-08 16:50:02 -0600
@@ -19,15 +19,12 @@
 #ifndef _CRC_H
 #define _CRC_H
 
+typedef struct crc_State crc_State;
+
 #include "types.h"
 
 #include <stddef.h>
 
-// If set, every CRC operation is logged. Very spammy.
-#undef DUMP_CRC_OPS
-
-
-typedef struct crc_State crc_State;
 struct crc_State {
 	uint32 crc;
 };
@@ -40,5 +37,17 @@ void crc_processUint32(crc_State *state,
 uint32 crc_finish(const crc_State *state);
 
 
+#ifdef DUMP_CRC_OPS
+#include "netconnection.h"
+		// for netplayDebugFile
+//#define crc_log(...)  log_add (logDebug, __VA_ARGS__)
+#define crc_log(...)  if (netplayDebugFile != NULL) \
+		{ \
+			uio_fprintf (netplayDebugFile, __VA_ARGS__); \
+			uio_putc ('\n', netplayDebugFile); \
+		} else \
+			(void) 0
+#endif
+
 #endif  /* _CRC_H */
 
diff -ruNp src.orig/sc2code/netplay/netconnection.c src/sc2code/netplay/netconnection.c
--- src.orig/sc2code/netplay/netconnection.c	2017-11-08 16:49:34 -0600
+++ src/sc2code/netplay/netconnection.c	2017-11-08 16:50:02 -0600
@@ -25,9 +25,17 @@
 #if defined(DEBUG) || defined(NETPLAY_DEBUG)
 #	include "libs/log.h"
 #endif
+#if defined(NETPLAY_DEBUG) && defined(NETPLAY_DEBUG_FILE)
+#	include "options.h"
+			// for configDir
+#endif
 
 #include <assert.h>
 #include <stdlib.h>
+#if defined(NETPLAY_DEBUG) && defined(NETPLAY_DEBUG_FILE)
+#	include <errno.h>
+#	include <time.h>
+#endif
 
 
 static void closeCallback(NetDescriptor *nd);
@@ -36,6 +44,9 @@ static void NetConnection_doClose(NetCon
 
 #include "nc_connect.ci"
 
+#if defined(NETPLAY_DEBUG) && defined(NETPLAY_DEBUG_FILE)
+uio_Stream *netplayDebugFile;
+#endif
 
 // Used as initial value for Agreement structures, by structure assignment.
 const Agreement Agreement_nothingAgreed;
@@ -53,6 +64,49 @@ NetConnection_open(int player, const Net
 
 	conn = malloc(sizeof (NetConnection));
 
+#if defined(NETPLAY_DEBUG) && defined(NETPLAY_DEBUG_FILE)
+	{
+		char dumpFileName[PATH_MAX];
+		time_t now;
+		struct tm *nowTm;
+		size_t strftimeResult;
+
+		now = time (NULL);
+		if (now == (time_t) -1) {
+			log_add (log_Fatal, "time() failed: %s.", strerror (errno));
+			abort ();
+		}
+
+		nowTm = localtime(&now);
+		// XXX: I would like to use localtime_r(), but it isn't very
+		// portable (yet), and adding a check for it to the build.sh script
+		// is not worth the effort for a debugging function right now.
+
+		strftimeResult = strftime (dumpFileName, sizeof dumpFileName,
+				"debug/netlog-%Y%m%d%H%M%S", nowTm);
+		if (strftimeResult == 0) {
+			log_add (log_Fatal, "strftime() failed: %s.", strerror (errno));
+			abort ();
+		}
+				
+		// The user needs to create the debug/ dir manually. If there
+		// is no debug/ dir, no log will be created.
+		conn->debugFile = uio_fopen (configDir, dumpFileName, "wt");
+		if (conn->debugFile == NULL) {
+			log_add (log_Debug, "Not creating a netplay debug log for "
+					"player %d.", player);
+		} else {
+			log_add (log_Debug, "Creating netplay debug log '%s' for "
+					"player %d.", dumpFileName, player);
+			if (netplayDebugFile == NULL) {
+				// Debug info relating to no specific network connection
+				// is sent to the first opened one.
+				netplayDebugFile = conn->debugFile;
+			}
+		}
+	}
+#endif
+
 	conn->nd = NULL;
 	conn->player = player;
 	conn->state = NetState_unconnected;
@@ -129,6 +183,19 @@ NetConnection_delete(NetConnection *conn
 	}
 	free(conn->readBuf);
 	PacketQueue_uninit(&conn->queue);
+
+#ifdef NETPLAY_DEBUG_FILE
+	if (conn->debugFile != NULL) {
+		if (netplayDebugFile == conn->debugFile) {
+			// There may be other network connections, with an open
+			// debug file, but we don't know about that.
+			// The debugging person just has to work around that.
+			netplayDebugFile = NULL;
+		}
+		uio_fclose(conn->debugFile);
+	}
+#endif
+
 	free(conn);
 }
 
@@ -317,4 +384,3 @@ NetConnection_getStatistics(NetConnectio
 }
 #endif
 
-
diff -ruNp src.orig/sc2code/netplay/netconnection.h src/sc2code/netplay/netconnection.h
--- src.orig/sc2code/netplay/netconnection.h	2017-11-08 16:49:34 -0600
+++ src/sc2code/netplay/netconnection.h	2017-11-08 16:50:02 -0600
@@ -43,6 +43,12 @@ typedef void (*NetConnection_ResetCallba
 #ifdef NETPLAY_CHECKSUM
 #	include "checkbuf.h"
 #endif
+#if defined(NETPLAY_STATISTICS) || defined(NETCONNECTION_INTERNAL)
+#	include "packet.h"
+#endif
+#if defined(NETPLAY_DEBUG) && defined(NETPLAY_DEBUG_FILE)
+#	include "libs/uio.h"
+#endif
 
 struct NetConnectionError {
 	NetState state;
@@ -54,8 +60,6 @@ struct NetConnectionError {
 };
 
 #ifdef NETPLAY_STATISTICS
-#include "packet.h"
-
 struct NetStatistics {
 	size_t packetsReceived;
 	size_t packetTypeReceived[PACKET_NUM];
@@ -64,6 +68,7 @@ struct NetStatistics {
 };
 #endif
 
+
 #ifdef NETCONNECTION_INTERNAL
 #include "libs/net.h"
 #include "packetq.h"
@@ -158,6 +163,10 @@ struct NetConnection {
 #ifdef NETPLAY_CHECKSUM
 	ChecksumBuffer checksumBuffer;
 #endif
+#if defined(NETPLAY_DEBUG) && defined(NETPLAY_DEBUG_FILE)
+	uio_Stream *debugFile;
+#endif
+
 	NetConnection_ConnectCallback connectCallback;
 	NetConnection_CloseCallback closeCallback;
 			// Called when the NetConnection becomes disconnected.
@@ -229,6 +238,11 @@ NetConnection_ResetCallback NetConnectio
 void *NetConnection_getResetCallbackArg(const NetConnection *conn);
 
 
+#if defined(NETPLAY_DEBUG) && defined(NETPLAY_DEBUG_FILE)
+extern uio_Stream *netplayDebugFile;
+#endif
+
+
 #endif  /* _NETCONNECTION_H */
 
 
diff -ruNp src.orig/sc2code/netplay/netmelee.c src/sc2code/netplay/netmelee.c
--- src.orig/sc2code/netplay/netmelee.c	2017-11-08 16:49:34 -0600
+++ src/sc2code/netplay/netmelee.c	2017-11-08 16:50:02 -0600
@@ -30,8 +30,8 @@
 #include "netplay/proto/ready.h"
 #include "netplay/proto/reset.h"
 
-#include "build.h"
-		// for StarShipPlayer()
+#include "battlecontrols.h"
+		// for NetworkInputContext
 #include "controls.h"
 		// for BATTLE_INPUT_STATE
 #include "init.h"
@@ -320,8 +320,8 @@ setBattleStateConnections(struct battles
 }
 
 BATTLE_INPUT_STATE
-networkBattleInput(COUNT player, STARSHIPPTR StarShipPtr) {
-	BattleInputBuffer *bib = getBattleInputBuffer(player);
+networkBattleInput(NetworkInputContext *context, STARSHIP *StarShipPtr) {
+	BattleInputBuffer *bib = getBattleInputBuffer(context->playerNr);
 	BATTLE_INPUT_STATE result;
 	
 	for (;;) {
@@ -347,7 +347,7 @@ networkBattleInput(COUNT player, STARSHI
 			break;
 			
 		{
-			NetConnection *conn = netConnections[player];
+			NetConnection *conn = netConnections[context->playerNr];
 
 			// First try whether there is incoming data, without blocking.
 			// If there isn't any, only then give a warning, and then
@@ -366,7 +366,7 @@ networkBattleInput(COUNT player, STARSHI
 #if 0
 			log_add(log_Warning, "NETPLAY: [%d] stalling for "
 					"network input. Increase the input delay if this "
-					"happens a lot.\n", player);
+					"happens a lot.\n", context->playerNr);
 #endif
 #define MAX_BLOCK_TIME 500
 			netInputBlocking(MAX_BLOCK_TIME);
@@ -549,7 +549,7 @@ typedef struct NegotiateReadyState Negot
 struct NegotiateReadyState {
 	// Common fields of INPUT_STATE_DESC, from which this structure
 	// "inherits".
-	BOOLEAN(*InputFunc)(PVOID pInputState);
+	BOOLEAN(*InputFunc)(void *pInputState);
 	COUNT MenuRepeatDelay;
 
 	NetConnection *conn;
@@ -638,7 +638,7 @@ typedef struct WaitReadyState WaitReadyS
 struct WaitReadyState {
 	// Common fields of INPUT_STATE_DESC, from which this structure
 	// "inherits".
-	BOOLEAN(*InputFunc)(PVOID pInputState);
+	BOOLEAN(*InputFunc)(void *pInputState);
 	COUNT MenuRepeatDelay;
 
 	NetConnection *conn;
@@ -697,7 +697,7 @@ typedef struct WaitResetState WaitResetS
 struct WaitResetState {
 	// Common fields of INPUT_STATE_DESC, from which this structure
 	// "inherits".
-	BOOLEAN(*InputFunc)(PVOID pInputState);
+	BOOLEAN(*InputFunc)(void *pInputState);
 	COUNT MenuRepeatDelay;
 
 	NetConnection *conn;
diff -ruNp src.orig/sc2code/netplay/netmelee.h src/sc2code/netplay/netmelee.h
--- src.orig/sc2code/netplay/netmelee.h	2017-11-08 16:49:34 -0600
+++ src/sc2code/netplay/netmelee.h	2017-11-08 16:50:02 -0600
@@ -24,8 +24,12 @@
 #include "netconnection.h"
 #include "packetsenders.h"
 
+#include "../battlecontrols.h"
+		// for NetworkInputContext
 #include "../controls.h"
 		// for BATTLE_INPUT_STATE
+#include "../races.h"
+		// for STARSHIP
 
 
 extern struct NetConnection *netConnections[];
@@ -55,7 +59,8 @@ void sendChecksumConnections(uint32 fram
 void initBattleStateDataConnections(void);
 void setBattleStateConnections(struct battlestate_struct *bs);
 
-BATTLE_INPUT_STATE networkBattleInput(COUNT player, STARSHIPPTR StarShipPtr);
+BATTLE_INPUT_STATE networkBattleInput(NetworkInputContext *context,
+		STARSHIP *StarShipPtr);
 
 NetConnection *openPlayerNetworkConnection(COUNT player, void *extra);
 void closePlayerNetworkConnection(COUNT player);
diff -ruNp src.orig/sc2code/netplay/netmisc.h src/sc2code/netplay/netmisc.h
--- src.orig/sc2code/netplay/netmisc.h	2017-11-08 16:49:34 -0600
+++ src/sc2code/netplay/netmisc.h	2017-11-08 16:50:02 -0600
@@ -58,6 +58,7 @@ static inline bool
 readyFlagsMeaningful(NetState state) {
 	return state == NetState_init ||
 			state == NetState_preBattle ||
+			state == NetState_selectShip ||
 			state == NetState_interBattle ||
 			state == NetState_inBattle ||
 			state == NetState_endingBattle ||
diff -ruNp src.orig/sc2code/netplay/netplay.h src/sc2code/netplay/netplay.h
--- src.orig/sc2code/netplay/netplay.h	2017-11-08 16:49:34 -0600
+++ src/sc2code/netplay/netplay.h	2017-11-08 16:50:02 -0600
@@ -33,6 +33,9 @@
 
 #define NETPLAY_DEBUG
 		/* Extra debugging for netplay */
+#define NETPLAY_DEBUG_FILE
+		/* Dump extra debugging information to file.
+		 * Implies NETPLAY_DEBUG.*/
 #define NETPLAY_STATISTICS
 		/* Keep some statistics */
 #define NETPLAY_CHECKSUM
@@ -56,5 +59,19 @@
 		/* Second argument to listen(). */
 
 
+#ifdef _MSC_VER
+#	if _MSC_VER < 1300
+		/* NETPLAY_DEBUG_FILE requires the __VA_ARGS__ macro, which is
+		 * not available on MSVC 6.0. */
+#		undef NETPLAY_DEBUG_FILE
+#	endif
+#endif
+
+#ifdef NETPLAY_DEBUG_FILE
+#	define NETPLAY_DEBUG
+#	define DUMP_CRC_OPS
+#endif
+
+
 #endif  /* _NETPLAY_H */
 
diff -ruNp src.orig/sc2code/netplay/netrcv.c src/sc2code/netplay/netrcv.c
--- src.orig/sc2code/netplay/netrcv.c	2017-11-08 16:49:34 -0600
+++ src/sc2code/netplay/netrcv.c	2017-11-08 16:50:02 -0600
@@ -82,7 +82,14 @@ dataReceivedSingle(NetConnection *conn,
 		log_add(log_Debug, "NETPLAY: [%d] <== Received packet of type %s.\n",
 				NetConnection_getPlayerNr(conn), packetTypeData[type].name);
 	}
-#endif
+#ifdef NETPLAY_DEBUG_FILE
+	if (conn->debugFile != NULL) {
+		uio_fprintf(conn->debugFile,
+				"NETPLAY: [%d] <== Received packet of type %s.\n",
+				NetConnection_getPlayerNr(conn), packetTypeData[type].name);
+	}
+#endif  /* NETPLAY_DEBUG_FILE */
+#endif  /* NETPLAY_DEBUG */
 	
 	result = packetTypeData[type].handler(conn, data);
 	if (result == -1) {
diff -ruNp src.orig/sc2code/netplay/netsend.c src/sc2code/netplay/netsend.c
--- src.orig/sc2code/netplay/netsend.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/netplay/netsend.c	2017-11-08 16:50:02 -0600
@@ -47,7 +47,14 @@ sendPacket(NetConnection *conn, Packet *
 	//	log_add(log_Debug, "NETPLAY: [%d] ==> Sending packet of type %s.\n",
 	//			conn->player, packetTypeData[packetType(packet)].name);
 	//}
-#endif
+#ifdef NETPLAY_DEBUG_FILE
+	if (conn->debugFile != NULL) {
+		uio_fprintf(conn->debugFile,
+				"NETPLAY: [%d] ==> Sending packet of type %s.\n",
+				conn->player, packetTypeData[packetType(packet)].name);
+	}
+#endif  /* NETPLAY_DEBUG_FILE */
+#endif  /* NETPLAY_DEBUG */
 
 	socket = NetDescriptor_getSocket(conn->nd);
 
diff -ruNp src.orig/sc2code/netplay/packet.h src/sc2code/netplay/packet.h
--- src.orig/sc2code/netplay/packet.h	2017-11-08 16:49:35 -0600
+++ src/sc2code/netplay/packet.h	2017-11-08 16:50:02 -0600
@@ -49,6 +49,7 @@ typedef enum PacketType {
 typedef enum NetplayAbortReason {
 	AbortReason_unspecified,
 	AbortReason_versionMismatch,
+	AbortReason_invalidHash,
 	AbortReason_protocolError,
 			// Network is in an inconsistent state.
 } NetplayAbortReason;
diff -ruNp src.orig/sc2code/netplay/packetq.c src/sc2code/netplay/packetq.c
--- src.orig/sc2code/netplay/packetq.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/netplay/packetq.c	2017-11-08 16:50:02 -0600
@@ -102,7 +102,15 @@ queuePacket(NetConnection *conn, Packet
 				NetConnection_getPlayerNr(conn),
 				packetTypeData[packetType(packet)].name);
 	}
-#endif
+#ifdef NETPLAY_DEBUG_FILE
+	if (conn->debugFile != NULL) {
+		uio_fprintf(conn->debugFile,
+				"NETPLAY: [%d] ==> Queueing packet of type %s.\n",
+				NetConnection_getPlayerNr(conn),
+				packetTypeData[packetType(packet)].name);
+	}
+#endif  /* NETPLAY_DEBUG_FILE */
+#endif  /* NETPLAY_DEBUG */
 }
 
 // If an error occurs during sending, we leave the unsent packets in
diff -ruNp src.orig/sc2code/oscill.c src/sc2code/oscill.c
--- src.orig/sc2code/oscill.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/oscill.c	2017-11-08 16:50:02 -0600
@@ -24,7 +24,7 @@
 #include "libs/sound/trackplayer.h"
 
 
-static FRAMEPTR scope_frame;
+static FRAME scope_frame;
 static int scope_init = 0;
 static TFB_Image *scope_bg = NULL;
 static TFB_Image *scope_surf = NULL;
diff -ruNp src.orig/sc2code/outfit.c src/sc2code/outfit.c
--- src.orig/sc2code/outfit.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/outfit.c	2017-11-08 16:50:02 -0600
@@ -42,7 +42,7 @@ enum
 
 
 static void
-DrawModuleStrings (PMENU_STATE pMS, BYTE NewModule)
+DrawModuleStrings (MENU_STATE *pMS, BYTE NewModule)
 {
 	RECT r;
 	STAMP s;
@@ -139,7 +139,7 @@ RedistributeFuel (void)
 #define LANDER_WIDTH 15
 
 static void
-DisplayLanders (PMENU_STATE pMS)
+DisplayLanders (MENU_STATE *pMS)
 {
 	STAMP s;
 
@@ -172,7 +172,7 @@ DisplayLanders (PMENU_STATE pMS)
 }
 
 static BOOLEAN
-DoInstallModule (PMENU_STATE pMS)
+DoInstallModule (MENU_STATE *pMS)
 {
 	BYTE NewState, new_slot_piece, old_slot_piece;
 	SIZE FirstItem, LastItem;
@@ -237,7 +237,7 @@ DoInstallModule (PMENU_STATE pMS)
 
 		SetContext (SpaceContext);
 		ClearSISRect (CLEAR_SIS_RADAR);
-		SetFlashRect (NULL_PTR, (FRAME)0);
+		SetFlashRect (NULL, (FRAME)0);
 		goto InitFlash;
 	}
 	else if (select || cancel)
@@ -298,7 +298,7 @@ DoInstallModule (PMENU_STATE pMS)
 		LockMutex (GraphicsLock);
 		SetContext (SpaceContext);
 
-		SetFlashRect (NULL_PTR, (FRAME)0);
+		SetFlashRect (NULL, (FRAME)0);
 
 		if (select)
 		{
@@ -545,11 +545,21 @@ InitFlash:
 static void
 ChangeFuelQuantity (void)
 {
+	int loop;
+	int incr = 0;
+
+	if (PulsedInputState.menu[KEY_MENU_UP]) incr = 1;
+	if (PulsedInputState.menu[KEY_MENU_DOWN]) incr = -1;
+	if (PulsedInputState.menu[KEY_MENU_PAGE_DOWN]) incr = -10;
+	if (PulsedInputState.menu[KEY_MENU_PAGE_UP]) incr = 10;
+
+	for (loop = 0; loop < abs(incr); loop++)
+	{
 	RECT r;
 	
 	r.extent.height = 1;
 	
-	if (PulsedInputState.menu[KEY_MENU_UP])
+	if (incr > 0)
 	{
 		LockMutex (GraphicsLock);
 		SetContext (SpaceContext);
@@ -575,11 +585,16 @@ ChangeFuelQuantity (void)
 		}
 		else
 		{	// no more room for fuel or not enough RUs
+			if (loop)
+			{
+				UnlockMutex (GraphicsLock);
+				break;
+			}
 			PlayMenuSound (MENU_SOUND_FAILURE);
 		}
 		UnlockMutex (GraphicsLock);
 	}
-	else if (PulsedInputState.menu[KEY_MENU_DOWN])
+	else if (incr < 0)
 	{
 		LockMutex (GraphicsLock);
 		SetContext (SpaceContext);
@@ -599,6 +614,14 @@ ChangeFuelQuantity (void)
 		}
 		else
 		{	// no fuel left to drain
+			if (loop)
+			{
+				SetContext (StatusContext);
+				GetGaugeRect (&r, FALSE);
+				SetFlashRect (&r, (FRAME)0);
+				UnlockMutex (GraphicsLock);
+				break;
+			}
 			PlayMenuSound (MENU_SOUND_FAILURE);
 		}
 		SetContext (StatusContext);
@@ -606,10 +629,11 @@ ChangeFuelQuantity (void)
 		SetFlashRect (&r, (FRAME)0);
 		UnlockMutex (GraphicsLock);
 	}
+	}
 }
 
 BOOLEAN
-DoOutfit (PMENU_STATE pMS)
+DoOutfit (MENU_STATE *pMS)
 {
 	if (GLOBAL (CurrentActivity) & CHECK_ABORT)
 		goto ExitOutfit;
@@ -680,16 +704,16 @@ DoOutfit (PMENU_STATE pMS)
 				s.frame = SetAbsFrameIndex (pMS->ModuleFrame,
 						GetFrameCount (pMS->ModuleFrame) - 5);
 				if (ShieldFlags & (1 << EARTHQUAKE_DISASTER))
-					DrawStamp ((PSTAMP)&s);
+					DrawStamp (&s);
 				s.frame = IncFrameIndex (s.frame);
 				if (ShieldFlags & (1 << BIOLOGICAL_DISASTER))
-					DrawStamp ((PSTAMP)&s);
+					DrawStamp (&s);
 				s.frame = IncFrameIndex (s.frame);
 				if (ShieldFlags & (1 << LIGHTNING_DISASTER))
-					DrawStamp ((PSTAMP)&s);
+					DrawStamp (&s);
 				s.frame = IncFrameIndex (s.frame);
 				if (ShieldFlags & (1 << LAVASPOT_DISASTER))
-					DrawStamp ((PSTAMP)&s);
+					DrawStamp (&s);
 			}
 
 			UnlockMutex (GraphicsLock);
@@ -793,7 +817,7 @@ ExitOutfit:
 		switch (pMS->CurState)
 		{
 			case OUTFIT_DOFUEL:
-				SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
+				SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN | MENU_SOUND_PAGEUP | MENU_SOUND_PAGEDOWN, MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
 				break;
 			default:
 				SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
diff -ruNp src.orig/sc2code/pickmele.c src/sc2code/pickmele.c
--- src.orig/sc2code/pickmele.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/pickmele.c	2017-11-08 16:50:02 -0600
@@ -16,10 +16,12 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+#define PICKMELE_INTERNAL
 #include "pickmele.h"
 
-#include "build.h"
+#include "battlecontrols.h"
 #include "controls.h"
+#include "flash.h"
 #include "intel.h"
 #include "melee.h"
 #ifdef NETPLAY
@@ -28,10 +30,9 @@
 #	include "netplay/notify.h"
 #endif
 #include "races.h"
-#include "settings.h"
 #include "setup.h"
 #include "sounds.h"
-#include "libs/inplib.h"
+#include "libs/log.h"
 #include "libs/mathlib.h"
 
 
@@ -40,19 +41,6 @@
 #define PICK_Y_OFFS 24
 #define PICK_SIDE_OFFS 100
 
-struct getmelee_struct {
-	BOOLEAN (*InputFunc) (struct getmelee_struct *pInputState);
-	COUNT MenuRepeatDelay;
-	BOOLEAN Initialized;
-	HSTARSHIP hBattleShip;
-	COUNT row, col, ships_left, which_player;
-	COUNT randomIndex;
-#ifdef NETPLAY
-	BOOLEAN remoteSelected;
-#endif
-	RECT flash_rect;
-};
-
 #ifdef NETPLAY
 static void reportShipSelected (GETMELEE_STATE *gms, COUNT index);
 #endif
@@ -68,17 +56,17 @@ MeleeShipByQueueIndex (const QUEUE *queu
 	
 	for (hShip = GetHeadLink (queue); hShip != 0; hShip = hNextShip)
 	{
-		STARSHIPPTR StarShipPtr = LockStarShip (queue, hShip);
-		if (StarShipPtr->ShipFacing == index)
+		STARSHIP *StarShipPtr = LockStarShip (queue, hShip);
+		if (StarShipPtr->index == index)
 		{
 			hNextShip = hShip;
-			if (StarShipPtr->RaceResIndex == 0)
+			if (StarShipPtr->SpeciesID == NO_ID)
 				hShip = 0;
 			UnlockStarShip (queue, hNextShip);
 			break;
 		}
 		hNextShip = _GetSuccLink (StarShipPtr);
-		UnlockStarShip (queue, ship);
+		UnlockStarShip (queue, hShip);
 	}
 
 	return hShip;
@@ -93,8 +81,8 @@ MeleeShipByUsedIndex (const QUEUE *queue
 	
 	for (hShip = GetHeadLink (queue); hShip != 0; hShip = hNextShip)
 	{
-		STARSHIPPTR StarShipPtr = LockStarShip (queue, hShip);
-		if (StarShipPtr->RaceResIndex && index-- == 0)
+		STARSHIP *StarShipPtr = LockStarShip (queue, hShip);
+		if ((StarShipPtr->SpeciesID != NO_ID) && index-- == 0)
 		{
 			UnlockStarShip (queue, hShip);
 			break;
@@ -111,137 +99,91 @@ static COUNT
 queueIndexFromShip (HSTARSHIP hShip)
 {
 	COUNT result;
-	STARSHIPPTR StarShipPtr = LockStarShip (queue, hShip);
-	result = StarShipPtr->ShipFacing;
+	STARSHIP *StarShipPtr = LockStarShip (queue, hShip);
+	result = StarShipPtr->index;
 	UnlockStarShip (queue, hShip);
 }
 #endif
 
+// Pre: called does not hold the graphics lock
 static void
-PickMelee_ChangedSelection (GETMELEE_STATE *gms)
+PickMelee_ChangedSelection (GETMELEE_STATE *gms, COUNT playerI)
 {
-	LockMutex (GraphicsLock);
-	gms->flash_rect.corner.x = PICK_X_OFFS + ((ICON_WIDTH + 2) * gms->col);
-	gms->flash_rect.corner.y = PICK_Y_OFFS + ((ICON_HEIGHT + 2) * gms->row)
-			+ ((1 - gms->which_player) * PICK_SIDE_OFFS);
-	SetFlashRect (&gms->flash_rect, (FRAME)0);
-	UnlockMutex (GraphicsLock);
+	RECT r;
+	r.corner.x = PICK_X_OFFS + ((ICON_WIDTH + 2) * gms->player[playerI].col);
+	r.corner.y = PICK_Y_OFFS + ((ICON_HEIGHT + 2) * gms->player[playerI].row)
+			+ ((1 - playerI) * PICK_SIDE_OFFS);
+	r.extent.width = (ICON_WIDTH + 2);
+	r.extent.height = (ICON_HEIGHT + 2);
+	Flash_setRect (gms->player[playerI].flashContext, &r);
 }
 
-// Select a new ship from the fleet for battle.
-// Returns 'TRUE' if no choice has been made yet; this function is to be
-// called again later.
-// Returns 'FALSE' if a choice has been made. gms->hStarShip is set
-// to the chosen (or randomly selected) ship, or to 0 if 'exit' has
-// been chosen.
-/* TODO: Include player timeouts */
-static BOOLEAN
-DoGetMelee (GETMELEE_STATE *gms)
+// Only returns false when there is no ship for the choice.
+bool
+setShipSelected(GETMELEE_STATE *gms, COUNT playerI, COUNT choice,
+		bool reportNetwork)
 {
-	BOOLEAN left, right, up, down, select;
-	COUNT which_player = gms->which_player;
-	BOOLEAN done = FALSE;
+	HSTARSHIP ship;
 
-	SetMenuSounds (MENU_SOUND_NONE, MENU_SOUND_NONE);
+	assert (!gms->player[playerI].done);
 
-	if (!gms->Initialized)
+	if (choice == (COUNT) ~0)
 	{
-		gms->Initialized = TRUE;
-		gms->row = 0;
-		gms->col = NUM_MELEE_COLS_ORIG;
-#ifdef NETPLAY
-		gms->remoteSelected = FALSE;
-#endif
-
-		// We determine in advance which ship would be chosen if the player
-		// wants a random ship, to keep it simple to keep network parties
-		// synchronised.
-		gms->randomIndex = (COUNT)TFB_Random () % gms->ships_left;
-
-		PickMelee_ChangedSelection (gms);
-		return TRUE;
+		// Random ship selection.
+		ship = MeleeShipByUsedIndex (&race_q[playerI],
+				gms->player[playerI].randomIndex);
 	}
-
-	SleepThread (ONE_SECOND / 120);
-#ifdef NETPLAY
-	netInput ();
-
-	if (!allConnected())
-		goto aborted;
-#endif
-	
-	if (GLOBAL (CurrentActivity) & CHECK_ABORT)
-		goto aborted;
-
-	if (PlayerInput[which_player] == ComputerInput)
-	{
-		/* TODO: Make this a frame-by-frame thing.  This code is currently
-		 *       copied from intel.c's computer_intelligence */
-		SleepThread (ONE_SECOND >> 1);
-		left = right = up = down = FALSE;
-		select = TRUE;		
-	}
-#ifdef NETPLAY
-	else if (PlayerInput[which_player] == NetworkInput)
-	{
-		flushPacketQueues ();
-		if (gms->remoteSelected)
-			return FALSE;
-		return TRUE;
-	}
-#endif
 	else
 	{
-		CONTROL_TEMPLATE template;
+		// Explicit ship selection.
+		ship = MeleeShipByQueueIndex (&race_q[playerI], choice);
+	}
 
-		if (which_player == 0)
-			template = PlayerOne;
-		else
-			template = PlayerTwo;
+	if (ship == 0)
+		return false;
 
-		left = PulsedInputState.key[template][KEY_LEFT];
-		right = PulsedInputState.key[template][KEY_RIGHT];
-		up = PulsedInputState.key[template][KEY_UP];
-		down = PulsedInputState.key[template][KEY_DOWN];
-		select = PulsedInputState.key[template][KEY_WEAPON];
-	}
+	gms->player[playerI].choice = choice;
+	gms->player[playerI].hBattleShip = ship;
+	PlayMenuSound (MENU_SOUND_SUCCESS);
+#ifdef NETPLAY
+	if (reportNetwork)
+		reportShipSelected (gms, choice);
+#else
+	(void) reportNetwork;
+#endif
+	gms->player[playerI].done = true;
+	return true;
+}
 
-	if (select)
+// Returns FALSE if aborted.
+static BOOLEAN
+SelectShip_processInput (GETMELEE_STATE *gms, COUNT playerI,
+		BATTLE_INPUT_STATE inputState)
+{
+	if (inputState & BATTLE_WEAPON)
 	{
-		if (gms->col == NUM_MELEE_COLS_ORIG)
+		if (gms->player[playerI].col == NUM_MELEE_COLS_ORIG &&
+				gms->player[playerI].row == 0)
 		{
-			if (gms->row == 0)
-			{
-				// Random ship
-				gms->hBattleShip = MeleeShipByUsedIndex (
-						&race_q[which_player], gms->randomIndex);
-#ifdef NETPLAY
-				reportShipSelected (gms, (COUNT)~0);
-#endif
-				done = TRUE;
-			}
-			else
-			{
-				// Selected exit
-				if (ConfirmExit ())
-					goto aborted;
-			}
+			// Random ship
+			(void) setShipSelected (gms, playerI, (COUNT) ~0, TRUE);
+		}
+		else if (gms->player[playerI].col == NUM_MELEE_COLS_ORIG &&
+				gms->player[playerI].row == 1)
+		{
+			// Selected exit
+			if (ConfirmExit ())
+				return FALSE;
 		}
 		else
 		{
-			COUNT ship_index;
-			
-			ship_index = (gms->row * NUM_MELEE_COLS_ORIG) + gms->col;
-			gms->hBattleShip = MeleeShipByQueueIndex (
-					&race_q[which_player], ship_index);
-			if (gms->hBattleShip != 0)
-			{
-				// Selection contains a ship.
-#ifdef NETPLAY
-				reportShipSelected (gms, ship_index);
-#endif
-				done = TRUE;
-			}
+			// Selection is on a ship slot.
+			COUNT shipI =
+					(gms->player[playerI].row * NUM_MELEE_COLS_ORIG)
+					+ gms->player[playerI].col;
+			(void) setShipSelected (gms, playerI, shipI, TRUE);
+					// If the choice is not valid, setShipSelected()
+					// will not set .done.
 		}
 	}
 	else
@@ -249,50 +191,159 @@ DoGetMelee (GETMELEE_STATE *gms)
 		// Process motion commands.
 		COUNT new_row, new_col;
 		
-		new_row = gms->row;
-		new_col = gms->col;
-		if (left)
+		new_row = gms->player[playerI].row;
+		new_col = gms->player[playerI].col;
+		if (inputState & BATTLE_LEFT)
 		{
 			if (new_col-- == 0)
 				new_col = NUM_MELEE_COLS_ORIG;
 		}
-		else if (right)
+		else if (inputState & BATTLE_RIGHT)
 		{
 			if (new_col++ == NUM_MELEE_COLS_ORIG)
 				new_col = 0;
 		}
-		if (up)
+		if (inputState & BATTLE_THRUST)
 		{
 			if (new_row-- == 0)
 				new_row = NUM_MELEE_ROWS - 1;
 		}
-		else if (down)
+		else if (inputState & BATTLE_DOWN)
 		{
 			if (++new_row == NUM_MELEE_ROWS)
 				new_row = 0;
 		}
 		
-		if (new_row != gms->row || new_col != gms->col)
+		if (new_row != gms->player[playerI].row ||
+				new_col != gms->player[playerI].col)
 		{
-			gms->row = new_row;
-			gms->col = new_col;
+			gms->player[playerI].row = new_row;
+			gms->player[playerI].col = new_col;
 			
 			PlayMenuSound (MENU_SOUND_MOVE);
-			PickMelee_ChangedSelection (gms);
+			PickMelee_ChangedSelection (gms, playerI);
 		}
 	}
 
+	return TRUE;
+}
+
+BOOLEAN
+selectShipHuman (HumanInputContext *context, GETMELEE_STATE *gms)
+{
+	BATTLE_INPUT_STATE inputState =
+			PulsedInputToBattleInput (context->playerNr);
+
+	return SelectShip_processInput (gms, context->playerNr, inputState);
+}
+
+BOOLEAN
+selectShipComputer (ComputerInputContext *context, GETMELEE_STATE *gms)
+{
+#define COMPUTER_SELECTION_DELAY (ONE_SECOND >> 1)
+	TimeCount now = GetTimeCounter ();
+	if (now < gms->player[context->playerNr].timeIn +
+			COMPUTER_SELECTION_DELAY)
+		return TRUE;
+
+	return SelectShip_processInput (gms, context->playerNr, BATTLE_WEAPON);
+			// Simulate selection of the random choice button.
+}
+
 #ifdef NETPLAY
+BOOLEAN
+selectShipNetwork (NetworkInputContext *context, GETMELEE_STATE *gms)
+{
 	flushPacketQueues ();
+			// Sets gms->player[context->playerNr].remoteSelected if input
+			// is received.
+	if (gms->player[context->playerNr].remoteSelected)
+		gms->player[context->playerNr].done = TRUE;
+
+	return TRUE;
+}
+#endif
+
+// Select a new ship from the fleet for battle.
+// Returns 'TRUE' if no choice has been made yet; this function is to be
+// called again later.
+// Returns 'FALSE' if a choice has been made. gms->hStarShip is set
+// to the chosen (or randomly selected) ship, or to 0 if 'exit' has
+// been chosen.
+/* TODO: Include player timeouts */
+static BOOLEAN
+DoGetMelee (GETMELEE_STATE *gms)
+{
+	BOOLEAN done;
+	COUNT playerI;
+
+	SetMenuSounds (MENU_SOUND_NONE, MENU_SOUND_NONE);
+
+	if (!gms->Initialized)
+	{
+		gms->Initialized = TRUE;
+		return TRUE;
+	}
+
+	for (playerI = 0; playerI < NUM_PLAYERS; playerI++)
+	{
+		if (!gms->player[playerI].selecting)
+			continue;
+
+		if (!gms->player[playerI].done)
+			Flash_process (gms->player[playerI].flashContext);
+	}
+
+	SleepThread (ONE_SECOND / 120);
+
+#ifdef NETPLAY
+	netInput ();
+
+	if (!allConnected ())
+		goto aborted;
 #endif
+	
+	if (GLOBAL (CurrentActivity) & CHECK_ABORT)
+		goto aborted;
+
+	done = TRUE;
+	for (playerI = 0; playerI < NUM_PLAYERS; playerI++)
+	{
+		if (!gms->player[playerI].selecting)
+			continue;
+
+		if (!gms->player[playerI].done) {
+			if (!PlayerInput[playerI]->handlers->selectShip (
+					PlayerInput[playerI], gms))
+				goto aborted;
 
+			if (gms->player[playerI].done)
+			{
+				Flash_terminate (gms->player[playerI].flashContext);
+				gms->player[playerI].flashContext = NULL;
+			}
+			else
+				done = FALSE;
+		}
+	}
+
+#ifdef NETPLAY
+	flushPacketQueues ();
+#endif
 	return !done;
 
 aborted:
 #ifdef NETPLAY
 	flushPacketQueues ();
 #endif
-	gms->hBattleShip = 0;
+	for (playerI = 0; playerI < NUM_PLAYERS; playerI++)
+	{
+		if (!gms->player[playerI].selecting)
+			continue;
+
+		gms->player[playerI].choice = 0;
+		gms->player[playerI].hBattleShip = 0;
+	}
 	GLOBAL (CurrentActivity) &= ~CHECK_ABORT;
 	return FALSE;
 }
@@ -306,263 +357,396 @@ endMeleeCallback (NetConnection *conn, v
 }
 #endif
 
-HSTARSHIP
-GetMeleeStarShip (STARSHIPPTR LastStarShipPtr, COUNT which_player)
-{
-	COUNT ships_left;
-	TEXT t;
-	UNICODE buf[40];
-	STAMP s;
-	CONTEXT OldContext;
-	GETMELEE_STATE gmstate;
-	STARSHIPPTR StarShipPtr;
-	BOOLEAN firstTime;
-
-	if (!(GLOBAL (CurrentActivity) & IN_BATTLE))
-		return (0);
+static COUNT
+GetRaceQueueValue (const QUEUE *queue) {
+	COUNT result;
+	HSTARSHIP hBattleShip, hNextShip;
 
-#ifdef NETPLAY
+	result = 0;
+	for (hBattleShip = GetHeadLink (queue);
+			hBattleShip != 0; hBattleShip = hNextShip)
 	{
-		NetConnection *conn = netConnections[which_player];
-		if (conn != NULL) {
-			BattleStateData *battleStateData;
-			battleStateData =
-					(BattleStateData *) NetConnection_getStateData(conn);
-			battleStateData->getMeleeState = &gmstate;
-		}
+		STARSHIP *StarShipPtr = LockStarShip (queue, hBattleShip);
+		hNextShip = _GetSuccLink (StarShipPtr);
+		
+		if (StarShipPtr->SpeciesID == NO_ID)
+			continue;  // Not active any more.
+
+		result += StarShipPtr->ship_cost;
+
+		UnlockStarShip (queue, hBattleShip);
 	}
-#endif
-	
-	s.frame = SetAbsFrameIndex (PickMeleeFrame, which_player);
+
+	return result;
+}
+
+// Cross out the icon for the dead ship.
+// 'frame' is the PickMeleeFrame for the player.
+// 'shipI' is the index in the ship list.
+// Pre: caller holds the graphics lock.
+static void
+CrossOutShip (FRAME frame, COUNT shipI)
+{
+	CONTEXT OldContext;
+	STAMP s;
 
 	OldContext = SetContext (OffScreenContext);
-	SetContextFGFrame (s.frame);
-	if (LastStarShipPtr == 0 || LastStarShipPtr->special_counter == 0)
-	{
-		COUNT cur_bucks;
-		HSTARSHIP hBattleShip, hNextShip;
+	
+	SetContextFGFrame (frame);
 
-		cur_bucks = 0;
-		for (hBattleShip = GetHeadLink (&race_q[which_player]);
-				hBattleShip != 0; hBattleShip = hNextShip)
-		{
-			StarShipPtr = LockStarShip (&race_q[which_player], hBattleShip);
-			if (StarShipPtr == LastStarShipPtr)
-			{
-				LastStarShipPtr->RaceResIndex = 0;
+	s.origin.x = 3 + ((ICON_WIDTH + 2) * (shipI % NUM_MELEE_COLS_ORIG));
+	s.origin.y = 9 + ((ICON_HEIGHT + 2) * (shipI / NUM_MELEE_COLS_ORIG));
+	s.frame = SetAbsFrameIndex (StatusFrame, 3);
+			// Cross for through the ship image.
+	DrawStamp (&s);
 
-				gmstate.col = LastStarShipPtr->ShipFacing;
-				s.origin.x = 3
-					+ ((ICON_WIDTH + 2) * (gmstate.col % NUM_MELEE_COLS_ORIG));
-				s.origin.y = 9
-					+ ((ICON_HEIGHT + 2) * (gmstate.col / NUM_MELEE_COLS_ORIG));
-				s.frame = SetAbsFrameIndex (StatusFrame, 3);
-				DrawStamp (&s);
-				s.frame = SetAbsFrameIndex (PickMeleeFrame, which_player);
-			}
-			else if (StarShipPtr->RaceResIndex)
-			{
-				cur_bucks += StarShipPtr->special_counter;
-			}
-			hNextShip = _GetSuccLink (StarShipPtr);
-			UnlockStarShip (&race_q[which_player], hBattleShip);
-		}
+	SetContext (OldContext);
+}
 
-		GetFrameRect (s.frame, &gmstate.flash_rect);
-		gmstate.flash_rect.extent.width -= 4;
-		t.baseline.x = gmstate.flash_rect.extent.width;
-		gmstate.flash_rect.corner.x =
-				gmstate.flash_rect.extent.width - (6 * 3);
-		gmstate.flash_rect.corner.y = 2;
-		gmstate.flash_rect.extent.width = (6 * 3);
-		gmstate.flash_rect.extent.height = 7 - 2;
-		SetContextForeGroundColor (PICK_BG_COLOR);
-		DrawFilledRectangle (&gmstate.flash_rect);
-
-		sprintf (buf, "%d", cur_bucks);
-		t.baseline.y = 7;
-		t.align = ALIGN_RIGHT;
-		t.pStr = buf;
-		t.CharCount = (COUNT)~0;
-		SetContextFont (TinyFont);
-		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x13, 0x00, 0x00), 0x2C));
-		font_DrawText (&t);
-	}
+// Draw the value of the fleet in the top right of the PickMeleeFrame.
+// Pre: caller holds the graphics lock.
+static void
+UpdatePickMeleeFleetValue (FRAME frame, COUNT which_player)
+{
+	CONTEXT OldContext;
+	COUNT value;
+	RECT r;
+	TEXT t;
+	UNICODE buf[40];
+	
+	value = GetRaceQueueValue (&race_q[which_player]);
 
-	SetContext (SpaceContext);
+	OldContext = SetContext (OffScreenContext);
+	SetContextFGFrame (frame);
+
+	// Erase the old value text.
+	GetFrameRect (frame, &r);
+	r.extent.width -= 4;
+	t.baseline.x = r.extent.width;
+	r.corner.x = r.extent.width - (6 * 3);
+	r.corner.y = 2;
+	r.extent.width = (6 * 3);
+	r.extent.height = 7 - 2;
+	SetContextForeGroundColor (PICK_BG_COLOR);
+	DrawFilledRectangle (&r);
+
+	// Draw the new value text.
+	sprintf (buf, "%d", value);
+	t.baseline.y = 7;
+	t.align = ALIGN_RIGHT;
+	t.pStr = buf;
+	t.CharCount = (COUNT)~0;
+	SetContextFont (TinyFont);
+	SetContextForeGroundColor (PICK_VALUE_COLOR);
+	font_DrawText (&t);
 	
+	SetContext (OldContext);
+}
+
+// Pre: caller holds the graphics lock.
+static void
+DrawPickMeleeFrame (COUNT which_player)
+{
+	CONTEXT oldContext;
+	STAMP s;
+
+	oldContext = SetContext (SpaceContext);
+	s.frame = SetAbsFrameIndex (PickMeleeFrame, which_player);
 	s.origin.x = PICK_X_OFFS - 3;
 	s.origin.y = PICK_Y_OFFS - 9 + ((1 - which_player) * PICK_SIDE_OFFS);
-
 	DrawStamp (&s);
+			// Draw the selection box to screen.
+	
+	SetContext (oldContext);
+}
 
-	if (LOBYTE (battle_counter) == 0 || HIBYTE (battle_counter) == 0)
-	{
-		// One side is out of ships. Game over.
-		DWORD TimeOut;
-		BOOLEAN PressState, ButtonState;
+// Pre: caller holds the graphics lock.
+void
+MeleeGameOver (void)
+{
+	COUNT playerI;
+	DWORD TimeOut;
+	BOOLEAN PressState, ButtonState;
 
-		s.origin.y = PICK_Y_OFFS - 9 + (which_player * PICK_SIDE_OFFS);
-		s.frame = SetAbsFrameIndex (PickMeleeFrame,
-				(COUNT) (1 - which_player));
-		DrawStamp (&s);
-
-		TimeOut = GetTimeCounter () + (ONE_SECOND * 4);
-		SetContext (OldContext);
-		UnlockMutex (GraphicsLock);
+	// Show the battle result.
+	for (playerI = 0; playerI < NUM_PLAYERS; playerI++)
+		DrawPickMeleeFrame (playerI);
 
-		PressState = PulsedInputState.menu[KEY_MENU_SELECT] ||
+	TimeOut = GetTimeCounter () + (ONE_SECOND * 4);
+	UnlockMutex (GraphicsLock);
+
+	PressState = PulsedInputState.menu[KEY_MENU_SELECT] ||
+			PulsedInputState.menu[KEY_MENU_CANCEL];
+	do
+	{
+		UpdateInputState ();
+		ButtonState = PulsedInputState.menu[KEY_MENU_SELECT] ||
 				PulsedInputState.menu[KEY_MENU_CANCEL];
-		do
+		if (PressState)
 		{
-			UpdateInputState ();
-			ButtonState = PulsedInputState.menu[KEY_MENU_SELECT] ||
-					PulsedInputState.menu[KEY_MENU_CANCEL];
-			if (PressState)
-			{
-				PressState = ButtonState;
-				ButtonState = FALSE;
-			}
+			PressState = ButtonState;
+			ButtonState = FALSE;
+		}
 
-			TaskSwitch ();
-		} while (!(GLOBAL (CurrentActivity) & CHECK_ABORT) && (!ButtonState
-				&& (!(PlayerControl[0] & PlayerControl[1] & PSYTRON_CONTROL)
-				|| GetTimeCounter () < TimeOut)));
+		TaskSwitch ();
+	} while (!(GLOBAL (CurrentActivity) & CHECK_ABORT) && (!ButtonState
+			&& (!(PlayerControl[0] & PlayerControl[1] & PSYTRON_CONTROL)
+			|| GetTimeCounter () < TimeOut)));
 
 #ifdef NETPLAY
-		setStateConnections (NetState_endMelee);
-		localReadyConnections (endMeleeCallback, NULL, true);
+	setStateConnections (NetState_endMelee);
+	localReadyConnections (endMeleeCallback, NULL, true);
 #endif
 
-		LockMutex (GraphicsLock);
+	LockMutex (GraphicsLock);
+}
 
-		return (0);
+BOOLEAN
+MeleeShipDeath (STARSHIP *ship, COUNT which_player) {
+	FRAME frame;
+
+	// Deactivate fleet position.
+	ship->SpeciesID = NO_ID;
+
+	frame = SetAbsFrameIndex (PickMeleeFrame, which_player);
+	CrossOutShip (frame, ship->index);
+	UpdatePickMeleeFleetValue (frame, which_player);
+	
+	if (battle_counter[0] == 0 || battle_counter[1] == 0)
+	{
+		// One side is out of ships. Game over.
+		return FALSE;
 	}
 
-	// Fade in if we're not already faded in.
+	return TRUE;
+}
+
+// Post: the NetState for all players is NetState_interBattle
+static BOOLEAN
+GetMeleeStarShips (COUNT playerMask, HSTARSHIP *ships)
+{
+	COUNT playerI;
+	BOOLEAN ok;
+	GETMELEE_STATE gmstate;
+	TimeCount now;
+
 #ifdef NETPLAY
-	// Hack. If one side is network controlled, the top player does not have
-	// to be the first player to get a chance to select his ship,
-	// As what is top locally doesn't have to be the same as what it is
-	// remotely.
-	// This check is not so nice as it replicates the code used to decide
-	// which party is first in selectAllShips.
-	firstTime = (LastStarShipPtr == 0) && ((which_player == 0) ==
-			(((PlayerControl[0] & NETWORK_CONTROL) &&
-			!NetConnection_getDiscriminant(netConnections[0])) ||
-			((PlayerControl[1] & NETWORK_CONTROL) &&
-			NetConnection_getDiscriminant(netConnections[1]))));
-#else
-	firstTime = LastStarShipPtr == 0 && which_player == 1;
-#endif
-	if (firstTime)
+	for (playerI = 0; playerI < NUM_PLAYERS; playerI++)
 	{
-		BYTE fade_buf[] = {FadeAllToColor};
-						
-		SleepThreadUntil (XFormColorMap
-				((COLORMAPPTR) fade_buf, ONE_SECOND / 2) + ONE_SECOND / 60);
-		FlushColorXForms ();
+		NetConnection *conn;
+
+		if ((playerMask & (1 << playerI)) == 0)
+			continue;
+
+		// XXX: This does not have to be done per connection.
+		conn = netConnections[playerI];
+		if (conn != NULL) {
+			BattleStateData *battleStateData;
+			battleStateData =
+					(BattleStateData *) NetConnection_getStateData (conn);
+			battleStateData->getMeleeState = &gmstate;
+		}
 	}
+#endif
+	
+	ok = true;
 
-	if (which_player == 0)
-		ships_left = LOBYTE (battle_counter);
-	else
-		ships_left = HIBYTE (battle_counter);
+	now = GetTimeCounter ();
+	gmstate.InputFunc = DoGetMelee;
+	gmstate.Initialized = FALSE;
+	for (playerI = 0; playerI < NUM_PLAYERS; playerI++)
+	{
+		gmstate.player[playerI].selecting =
+				(playerMask & (1 << playerI)) != 0;
+		gmstate.player[playerI].ships_left = battle_counter[playerI];
+
+		// We determine in advance which ship would be chosen if the player
+		// wants a random ship, to keep it simple to keep network parties
+		// synchronised.
+		gmstate.player[playerI].randomIndex =
+				(COUNT)TFB_Random () % gmstate.player[playerI].ships_left;
+		gmstate.player[playerI].done = FALSE;
+
+		if (!gmstate.player[playerI].selecting)
+			continue;
+
+		gmstate.player[playerI].timeIn = now;
+		gmstate.player[playerI].row = 0;
+		gmstate.player[playerI].col = NUM_MELEE_COLS_ORIG;
+#ifdef NETPLAY
+		gmstate.player[playerI].remoteSelected = FALSE;
+#endif
+
+		gmstate.player[playerI].flashContext =
+				Flash_createHighlight (ScreenContext, (FRAME) 0, NULL,
+				2, 3, 2);
+		Flash_setFrameTime (gmstate.player[playerI].flashContext,
+				ONE_SECOND / 16);
+#ifdef NETPLAY
+		if (PlayerControl[playerI] & NETWORK_CONTROL)
+			Flash_setSpeed (gmstate.player[playerI].flashContext,
+					ONE_SECOND / 2, 0, ONE_SECOND / 2, 0);
+		else
+#endif
+		{
+			Flash_setSpeed (gmstate.player[playerI].flashContext,
+					0, ONE_SECOND / 16, 0, ONE_SECOND / 16);
+		}
+		PickMelee_ChangedSelection (&gmstate, playerI);
+		Flash_start (gmstate.player[playerI].flashContext);
+	}
 
-	gmstate.flash_rect.extent.width = (ICON_WIDTH + 2);
-	gmstate.flash_rect.extent.height = (ICON_HEIGHT + 2);
 #ifdef NETPLAY
 	{
+		// NB. gmstate.player[].randomIndex and gmstate.player[].done must
+		// be initialised before negotiateReadyConnections is completed, to
+		// ensure that they are initialised when the SelectShip packet
+		// arrives.
 		bool allOk = negotiateReadyConnections (true, NetState_selectShip);
 		if (!allOk)
 		{
 			// Some network connection has been reset.
-			gmstate.hBattleShip = 0;
+			ok = false;
 		}
 	}
 #endif
-	gmstate.InputFunc = DoGetMelee;
 	SetDefaultMenuRepeatDelay ();
-	gmstate.Initialized = FALSE;
-	gmstate.ships_left = ships_left;
-	gmstate.which_player = which_player;
+	
+	SetContext (OffScreenContext);
 
 	UnlockMutex (GraphicsLock);
 	ResetKeyRepeat ();
-	DoInput ((PVOID)&gmstate, FALSE);
+	DoInput (&gmstate, FALSE);
+	WaitForSoundEnd (0);
 
 	LockMutex (GraphicsLock);
-	SetFlashRect (NULL_PTR, (FRAME)0);
-	
-	if (gmstate.hBattleShip == 0)
+
+	for (playerI = 0; playerI < NUM_PLAYERS; playerI++)
 	{
-		// Aborting.
-		GLOBAL (CurrentActivity) &= ~IN_BATTLE;
+		if (!gmstate.player[playerI].selecting)
+			continue;
+		
+		if (gmstate.player[playerI].done)
+		{
+			// Flash rectangle is already terminated.
+			ships[playerI] = gmstate.player[playerI].hBattleShip;
+		}
+		else
+		{
+			Flash_terminate (gmstate.player[playerI].flashContext);
+			gmstate.player[playerI].flashContext = NULL;
+			ok = false;
+		}
 	}
-	else
-	{
-		StarShipPtr =
-				LockStarShip (&race_q[which_player], gmstate.hBattleShip);
-		OwnStarShip (StarShipPtr,
-				1 << which_player, StarShipPtr->captains_name_index);
-		StarShipPtr->captains_name_index = 0;
-		UnlockStarShip (&race_q[which_player], gmstate.hBattleShip);
 
-		PlayMenuSound (MENU_SOUND_SUCCESS);
+#ifdef NETPLAY
+	if (ok)
+	{
+		if (!negotiateReadyConnections (true, NetState_interBattle))
+			ok = false;
+	}
+	else
+		setStateConnections (NetState_interBattle);
+#endif
 
-		WaitForSoundEnd (0);
+	if (!ok)
+	{
+		// Aborting.
+		GLOBAL (CurrentActivity) &= ~IN_BATTLE;
 	}
 
 #ifdef NETPLAY
+	for (playerI = 0; playerI < NUM_PLAYERS; playerI++)
 	{
-		NetConnection *conn = netConnections[which_player];
-		if (conn != NULL && NetConnection_isConnected(conn))
+		NetConnection *conn;
+
+		if ((playerMask & (1 << playerI)) == 0)
+			continue;
+
+		// XXX: This does not have to be done per connection.
+		conn = netConnections[playerI];
+		if (conn != NULL && NetConnection_isConnected (conn))
 		{
 			BattleStateData *battleStateData;
-			battleStateData = (BattleStateData *)
-					NetConnection_getStateData(conn);
+			battleStateData =
+					(BattleStateData *) NetConnection_getStateData (conn);
 			battleStateData->getMeleeState = NULL;
 		}
 	}
 #endif
 
-	return (gmstate.hBattleShip);
+	return ok;
+}
+
+BOOLEAN
+GetInitialMeleeStarShips (HSTARSHIP *result)
+{
+	COUNT playerI;
+	COUNT playerMask;
+
+	for (playerI = 0; playerI < NUM_PLAYERS; playerI++)
+	{
+		FRAME frame;
+		frame = SetAbsFrameIndex (PickMeleeFrame, playerI);
+		UpdatePickMeleeFleetValue (frame, playerI);
+		DrawPickMeleeFrame (playerI);
+	}
+
+	// Fade in
+	{
+		BYTE fade_buf[] = {FadeAllToColor};
+		SleepThreadUntil (XFormColorMap
+				((COLORMAPPTR) fade_buf, ONE_SECOND / 2) + ONE_SECOND / 60);
+		FlushColorXForms ();
+	}
+
+	playerMask = 0;
+	for (playerI = 0; playerI < NUM_PLAYERS; playerI++)
+		playerMask |= (1 << playerI);
+
+	return GetMeleeStarShips (playerMask, result);
+}
+
+BOOLEAN
+GetNextMeleeStarShip (COUNT which_player, HSTARSHIP *result)
+{
+	COUNT playerMask;
+	HSTARSHIP ships[NUM_PLAYERS];
+	BOOLEAN ok;
+
+	DrawPickMeleeFrame (which_player);
+
+	playerMask = 1 << which_player;
+	ok = GetMeleeStarShips (playerMask, ships);
+	if (ok)
+		*result = ships[which_player];
+
+	return ok;
 }
 
 #ifdef NETPLAY
 // Called when a ship selection has arrived from a remote player.
 bool
-updateMeleeSelection (GETMELEE_STATE *gms, COUNT player, COUNT ship)
+updateMeleeSelection (GETMELEE_STATE *gms, COUNT playerI, COUNT ship)
 {
-	if (gms == NULL)
+	if (gms == NULL || !gms->player[playerI].selecting ||
+			gms->player[playerI].done)
 	{
 		// This happens when we get an update message from a connection
-		// for who we are not selecting a ship (yet?).
-		fprintf (stderr, "Unexpected ship selection packet received.\n");
+		// for who we are not selecting a ship.
+		log_add (log_Warning, "Unexpected ship selection packet "
+				"received.\n");
 		return false;
 	}
 
-	if (ship == (COUNT) ~0)
-	{
-		// Random selection.
-		gms->hBattleShip =
-				MeleeShipByUsedIndex (&race_q[player], gms->randomIndex);
-		gms->remoteSelected = TRUE;
-		NetConnection_setState (netConnections[player], NetState_interBattle);
-		return true;
-	}
-	
-	gms->hBattleShip = MeleeShipByQueueIndex (&race_q[player], ship);
-	if (gms->hBattleShip == 0)
+	if (!setShipSelected (gms, playerI, ship, false))
 	{
-		fprintf (stderr, "Invalid ship selection received from remote "
+		log_add (log_Warning, "Invalid ship selection received from remote "
 				"party.\n");
 		return false;
 	}
 
-	gms->remoteSelected = TRUE;
-	NetConnection_setState (netConnections[player], NetState_interBattle);
+	gms->player[playerI].remoteSelected = TRUE;
 	return true;
 }
 
@@ -581,7 +765,6 @@ reportShipSelected (GETMELEE_STATE *gms,
 			continue;
 
 		Netplay_selectShip (conn, index);
-		NetConnection_setState (conn, NetState_interBattle);
 	}
 	(void) gms;
 }
diff -ruNp src.orig/sc2code/pickmele.h src/sc2code/pickmele.h
--- src.orig/sc2code/pickmele.h	2017-11-08 16:49:35 -0600
+++ src/sc2code/pickmele.h	2017-11-08 16:50:02 -0600
@@ -17,15 +17,65 @@
 #ifndef _PICKMELE_H
 #define _PICKMELE_H
 
+typedef struct getmelee_struct GETMELEE_STATE;
+
 #include "races.h"
+#include "battlecontrols.h"
 #include "libs/compiler.h"
 
-HSTARSHIP GetMeleeStarShip (STARSHIPPTR LastStarShipPtr,
-		COUNT which_player);
-
-typedef struct getmelee_struct GETMELEE_STATE;
+BOOLEAN MeleeShipDeath (STARSHIP *ship, COUNT which_player);
+void MeleeGameOver (void);
+BOOLEAN GetInitialMeleeStarShips (HSTARSHIP *result);
+BOOLEAN GetNextMeleeStarShip (COUNT which_player, HSTARSHIP *result);
 
 bool updateMeleeSelection (GETMELEE_STATE *gms, COUNT player, COUNT ship);
 
+BOOLEAN selectShipHuman (HumanInputContext *context, GETMELEE_STATE *gms);
+BOOLEAN selectShipComputer (ComputerInputContext *context,
+		GETMELEE_STATE *gms);
+#ifdef NETPLAY
+BOOLEAN selectShipNetwork (NetworkInputContext *context, GETMELEE_STATE *gms);
+#endif  /* NETPLAY */
+
+#ifdef PICKMELE_INTERNAL
+
+#include "flash.h"
+#include "libs/timelib.h"
+
+struct getmelee_struct {
+	BOOLEAN (*InputFunc) (struct getmelee_struct *pInputState);
+	COUNT MenuRepeatDelay;
+	BOOLEAN Initialized;
+	
+	struct {
+		TimeCount timeIn;
+		HSTARSHIP hBattleShip;
+				// Chosen ship.
+		COUNT choice;
+				// Index of chosen ship, or (COUNT) ~0 for random choice.
+
+		COUNT row;
+		COUNT col;
+		COUNT ships_left;
+				// Number of ships still available.
+		COUNT randomIndex;
+				// Pre-generated random number.
+		BOOLEAN selecting;
+				// Is this player selecting a ship?
+		BOOLEAN done;
+				// Has a selection been made for this player?
+		FlashContext *flashContext;
+				// Context for controlling the flash rectangle.
+#ifdef NETPLAY
+		BOOLEAN remoteSelected;
+#endif
+	} player[NUM_PLAYERS];
+};
+
+bool setShipSelected(GETMELEE_STATE *gms, COUNT playerI, COUNT choice,
+		bool reportNetwork);
+
+#endif  /* PICKMELE_INTERNAL */
+
 #endif  /* _PICKMELE_H */
 
diff -ruNp src.orig/sc2code/pickship.c src/sc2code/pickship.c
--- src.orig/sc2code/pickship.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/pickship.c	2017-11-08 16:50:02 -0600
@@ -41,7 +41,7 @@
 #define FLAGSHIP_HEIGHT 48
 
 static BOOLEAN
-DoPickBattleShip (PMENU_STATE pMS)
+DoPickBattleShip (MENU_STATE *pMS)
 {
 	if (GLOBAL (CurrentActivity) & CHECK_ABORT)
 	{
@@ -87,7 +87,7 @@ DoPickBattleShip (PMENU_STATE pMS)
 			COUNT crew_level, max_crew;
 			COUNT ship_index;
 			HSTARSHIP hBattleShip, hNextShip;
-			STARSHIPPTR StarShipPtr;
+			STARSHIP *StarShipPtr;
 
 			if (new_col < 0)
 				new_col = NUM_PICK_SHIP_COLUMNS;
@@ -114,8 +114,10 @@ DoPickBattleShip (PMENU_STATE pMS)
 ChangeSelection:
 			if (pMS->first_item.x == (NUM_PICK_SHIP_COLUMNS >> 1))
 			{
-				pMS->flash_rect0.corner.x = pMS->flash_rect1.corner.x - 2 + FLAGSHIP_X_OFFS;
-				pMS->flash_rect0.corner.y = pMS->flash_rect1.corner.y - 2 + FLAGSHIP_Y_OFFS;
+				pMS->flash_rect0.corner.x =
+						pMS->flash_rect1.corner.x - 2 + FLAGSHIP_X_OFFS;
+				pMS->flash_rect0.corner.y =
+						pMS->flash_rect1.corner.y - 2 + FLAGSHIP_Y_OFFS;
 				pMS->flash_rect0.extent.width = FLAGSHIP_WIDTH + 4;
 				pMS->flash_rect0.extent.height = FLAGSHIP_HEIGHT + 4;
 
@@ -144,9 +146,8 @@ ChangeSelection:
 						hBattleShip = hNextShip)
 				{
 					StarShipPtr = LockStarShip (&race_q[0], hBattleShip);
-					if ((COUNT)LONIBBLE (
-							StarShipPtr->RaceDescPtr->ship_info.var2
-							) == ship_index && StarShipPtr->RaceResIndex)
+					if (StarShipPtr->index == ship_index
+							&& (StarShipPtr->SpeciesID != NO_ID))
 					{
 						UnlockStarShip (&race_q[0], hBattleShip);
 						break;
@@ -189,19 +190,19 @@ ChangeSelection:
 					t.pStr = GLOBAL_SIS (CommanderName);
 					t.CharCount = (COUNT)~0;
 					crew_level = GLOBAL_SIS (CrewEnlisted);
-					max_crew = GetCPodCapacity (NULL_PTR);
+					max_crew = GetCPodCapacity (NULL);
 				}
 				else
 				{
 					STRING locString;
 
 					locString = SetAbsStringTableIndex (
-							StarShipPtr->RaceDescPtr->ship_info.race_strings,
+							StarShipPtr->race_strings,
 							StarShipPtr->captains_name_index);
 					t.pStr = (UNICODE *)GetStringAddress (locString);
 					t.CharCount = GetStringLength (locString);
-					crew_level = StarShipPtr->RaceDescPtr->ship_info.crew_level;
-					max_crew = StarShipPtr->RaceDescPtr->ship_info.max_crew;
+					crew_level = StarShipPtr->crew_level;
+					max_crew = StarShipPtr->max_crew;
 				}
 				UnlockStarShip (&race_q[0], hBattleShip);
 
@@ -232,7 +233,7 @@ ChangeSelection:
 				font_DrawText (&t);
 			}
 
-			SetFlashRect (NULL_PTR, (FRAME)0);
+			SetFlashRect (NULL, (FRAME)0);
 			SetFlashRect (&pMS->flash_rect0, (FRAME)0);
 			UnlockMutex (GraphicsLock);
 		}
@@ -248,9 +249,10 @@ GetArmadaStarShip (void)
 	CONTEXT OldContext;
 	HSTARSHIP hBattleShip;
 	
-	if (HIBYTE (battle_counter) == 0)
+	if (battle_counter[1] == 0)
 	{
-		return (0);
+		// No opponents left.
+		return 0;
 	}
 	
 //    MenuSounds = CaptureSound (LoadSound (MENU_SOUNDS));
@@ -273,11 +275,11 @@ OldContext = SetContext (SpaceContext);
 		UnlockMutex (GraphicsLock);
 		pMenuState = &MenuState;
 		SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
-		DoInput ((PVOID)&MenuState, FALSE);
+		DoInput (&MenuState, FALSE);
 		pMenuState = 0;
 		LockMutex (GraphicsLock);
 
-		SetFlashRect (NULL_PTR, (FRAME)0);
+		SetFlashRect (NULL, (FRAME)0);
 
 		hBattleShip = (HSTARSHIP)MenuState.CurFrame;
 	}
@@ -285,7 +287,7 @@ OldContext = SetContext (SpaceContext);
 	if (hBattleShip)
 	{
 		if (hBattleShip == GetTailLink (&race_q[0]))
-			battle_counter = MAKE_WORD (1, HIBYTE (battle_counter));
+			battle_counter[0] = 1;
 
 		WaitForSoundEnd (0);
 	}
@@ -298,7 +300,7 @@ SetContext (OldContext);
 }
 
 HSTARSHIP
-GetEncounterStarShip (STARSHIPPTR LastStarShipPtr, COUNT which_player)
+GetEncounterStarShip (STARSHIP *LastStarShipPtr, COUNT which_player)
 {
 	HSTARSHIP hBattleShip;
 
@@ -308,39 +310,59 @@ GetEncounterStarShip (STARSHIPPTR LastSt
 	else if (LOBYTE (GLOBAL (CurrentActivity)) == SUPER_MELEE)
 	{
 		// Let the player chose his own ship. (May be a computer player).
-		hBattleShip = GetMeleeStarShip (LastStarShipPtr, which_player);
+
+		if (!(GLOBAL (CurrentActivity) & IN_BATTLE))
+		{
+			// XXX: This check is needed, because UninitShips() calls
+			//      this function after the battle is over to record
+			//      the crew left in the last ship standing.
+			hBattleShip = 0;
+		}
+		else if (!MeleeShipDeath (LastStarShipPtr, which_player))
+			hBattleShip = 0;
+					// Game over.
+		else
+		{
+			if (!GetNextMeleeStarShip (which_player, &hBattleShip))
+				hBattleShip = 0;
+		}
 	}
 	else
 	{
-		HSTARSHIP hStarShip;
-		STARSHIPPTR SPtr;
-		SHIP_FRAGMENTPTR FragPtr;
+		// Full game.
+		HSHIPFRAG hStarShip;
+		SHIP_FRAGMENT *FragPtr;
 
 		if (LastStarShipPtr == 0)
 		{
-			if (which_player == 0 && LOBYTE (battle_counter) > 1)
+			// First time picking a ship.
+			if (which_player == 0 && battle_counter[0] > 1)
+			{
+				// The player in a full game, still having a ship left.
 				hBattleShip = GetArmadaStarShip ();
+			}
 			else
 			{
 				hBattleShip = GetHeadLink (&race_q[which_player]);
 				if (which_player == 1)
 				{
+					// Select the next ship for the computer.
 					hStarShip = GetHeadLink (&GLOBAL (npc_built_ship_q));
-					FragPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-							&GLOBAL (npc_built_ship_q), hStarShip);
-					if (FragPtr->ShipInfo.crew_level == INFINITE_FLEET)
+					FragPtr = LockShipFrag (&GLOBAL (npc_built_ship_q),
+							hStarShip);
+					if (FragPtr->crew_level == INFINITE_FLEET)
 					{
 						// Infinite number of ships.
-						battle_counter += MAKE_WORD (0, 1);
+						battle_counter[1]++;
 					}
-					UnlockStarShip (&GLOBAL (npc_built_ship_q), hStarShip);
+					UnlockShipFrag (&GLOBAL (npc_built_ship_q), hStarShip);
 				}
 			}
 		}
 		else
 		{
-			PQUEUE pQueue;
-			HSTARSHIP hNextShip;
+			QUEUE *pQueue;
+			HSHIPFRAG hNextShip;
 
 			if (which_player == 0)
 				pQueue = &GLOBAL (built_ship_q);
@@ -351,83 +373,86 @@ GetEncounterStarShip (STARSHIPPTR LastSt
 			for (hStarShip = GetHeadLink (pQueue);
 					hStarShip != 0; hStarShip = hNextShip)
 			{
+				STARSHIP *SPtr;
+
 				SPtr = LockStarShip (&race_q[which_player], hBattleShip);
 				hNextShip = _GetSuccLink (SPtr);
 				UnlockStarShip (&race_q[which_player], hBattleShip);
 				hBattleShip = hNextShip;
 
-				FragPtr = (SHIP_FRAGMENTPTR)LockStarShip (pQueue, hStarShip);
+				FragPtr = LockShipFrag (pQueue, hStarShip);
 				if (SPtr == LastStarShipPtr)
 				{
-					if (FragPtr->ShipInfo.crew_level != INFINITE_FLEET)
+					if (FragPtr->crew_level != INFINITE_FLEET)
 					{
-						FragPtr->ShipInfo.crew_level = SPtr->special_counter;
-						SPtr->RaceDescPtr = (RACE_DESCPTR)&FragPtr->ShipInfo;
+						/* Record crew left after the battle */
+						FragPtr->crew_level = SPtr->crew_level;
 						if (GLOBAL (CurrentActivity) & IN_BATTLE)
-							SPtr->RaceResIndex = 0;
+							SPtr->SpeciesID = NO_ID;
+									// deactivates the ship
 					}
 					else /* if infinite ships */
 					{
 						hBattleShip = GetTailLink (&race_q[which_player]);
-						SPtr->special_counter = FragPtr->ShipInfo.max_crew;
-						SPtr->cur_status_flags = 1 << which_player;
+						/* XXX: Note that if Syreen had a homeworld you could
+						 * fight, all Syreen ships there would be crewed to
+						 * the maximum, instead of the normal level */
+						SPtr->crew_level = FragPtr->max_crew;
+						SPtr->which_side = 1 << which_player;
 						SPtr->captains_name_index = PickCaptainName ();
 
-						battle_counter += MAKE_WORD (0, 1);
+						battle_counter[1]++;
 					}
-					UnlockStarShip (pQueue, hStarShip);
+					UnlockShipFrag (pQueue, hStarShip);
 					break;
 				}
 				hNextShip = _GetSuccLink (FragPtr);
-				UnlockStarShip (pQueue, hStarShip);
+				UnlockShipFrag (pQueue, hStarShip);
 			}
 
 			if (which_player == 0)
 			{
-				if (LOBYTE (battle_counter))
+				// Player in a full game.
+				if (battle_counter[0])
 					hBattleShip = GetArmadaStarShip ();
 				else /* last ship was flagship */
 				{
 #define RUN_AWAY_FUEL_COST (5 * FUEL_TANK_SCALE)
 					hBattleShip = 0;
-					if (LastStarShipPtr->special_counter == 0)
-								/* died in the line of duty */
+					if (LastStarShipPtr->crew_level == 0)
+					{
+						/* Died in the line of duty */
 						GLOBAL_SIS (CrewEnlisted) = (COUNT)~0;
-					else if (GLOBAL_SIS (FuelOnBoard) > RUN_AWAY_FUEL_COST)
-						GLOBAL_SIS (FuelOnBoard) -= RUN_AWAY_FUEL_COST;
+					}
 					else
-						GLOBAL_SIS (FuelOnBoard) = 0;
+					{
+						// Player ran away.
+						if (GLOBAL_SIS (FuelOnBoard) > RUN_AWAY_FUEL_COST)
+							GLOBAL_SIS (FuelOnBoard) -= RUN_AWAY_FUEL_COST;
+						else
+							GLOBAL_SIS (FuelOnBoard) = 0;
+					}
 				}
 			}
 		}
-
-		if (hBattleShip)
-		{
-			SPtr = LockStarShip (&race_q[which_player], hBattleShip);
-			OwnStarShip (SPtr, SPtr->cur_status_flags,
-					SPtr->captains_name_index);
-			UnlockStarShip (&race_q[which_player], hBattleShip);
-		}
 	}
 
 	return (hBattleShip);
 }
 
 void
-DrawArmadaPickShip (BOOLEAN draw_salvage_frame, PRECT pPickRect)
+DrawArmadaPickShip (BOOLEAN draw_salvage_frame, RECT *pPickRect)
 {
 #define PICK_NAME_HEIGHT 6
 	//COUNT i;
 	HSTARSHIP hBattleShip, hNextShip;
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	RECT r, pick_r;
 	STAMP s;
 	TEXT t;
 	CONTEXT OldContext;
-	MEM_HANDLE hLastIndex;
 	FRAME PickFrame;
 
-	hLastIndex = SetResourceIndex (hResIndex);
 	OldContext = SetContext (SpaceContext);
 
 	PickFrame = CaptureDrawable (LoadGraphic (SC2_PICK_PMAP_ANIM));
@@ -480,11 +505,10 @@ DrawArmadaPickShip (BOOLEAN draw_salvage
 		StarShipPtr = LockStarShip (&race_q[0], hBattleShip);
 
 		if (StarShipPtr->captains_name_index)
-		{
+		{	// Escort ship, not SIS
 			COUNT ship_index;
 
-			ship_index = (COUNT)LONIBBLE (
-					StarShipPtr->RaceDescPtr->ship_info.var2);
+			ship_index = StarShipPtr->index;
 
 			s.origin.x = pick_r.corner.x
 					+ (5 + ((ICON_WIDTH + 4)
@@ -495,15 +519,14 @@ DrawArmadaPickShip (BOOLEAN draw_salvage
 			s.origin.y = pick_r.corner.y
 					+ (16 + ((ICON_HEIGHT + 4)
 					* (ship_index / NUM_PICK_SHIP_COLUMNS)));
-			s.frame = StarShipPtr->RaceDescPtr->ship_info.icons;
+			s.frame = StarShipPtr->icons;
 			r.corner = s.origin;
 			SetContextForeGroundColor (BLACK_COLOR);
 			DrawFilledRectangle (&r);
-			if (StarShipPtr->RaceResIndex
-					|| StarShipPtr->RaceDescPtr->ship_info.crew_level == 0)
+			if ((StarShipPtr->SpeciesID != NO_ID) || (StarShipPtr->crew_level == 0))
 			{
 				DrawStamp (&s);
-				if (StarShipPtr->RaceResIndex == 0)
+				if (StarShipPtr->SpeciesID == NO_ID)
 				{
 					/* Dead ship - mark with an X. */
 					s.origin.x -= 1;
@@ -529,6 +552,5 @@ DrawArmadaPickShip (BOOLEAN draw_salvage
 	DestroyDrawable (ReleaseDrawable (PickFrame));
 
 	SetContext (OldContext);
-	SetResourceIndex (hLastIndex);
 }
 
diff -ruNp src.orig/sc2code/plandata.c src/sc2code/plandata.c
--- src.orig/sc2code/plandata.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/plandata.c	2017-11-08 16:50:02 -0600
@@ -206,7 +206,7 @@ STAR_DESC starmap_array[] =
 	{{3619, 2830}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 87},
 	{{2208, 2854}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 7, 106},
 	{{9250, 2854}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 4, 61},
-	{{ 672, 2863}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 7, 78},
+	{{ 672, 2863}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), MOTHER_ARK_DEFINED, 7, 78},
 	{{ 167, 2875}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 6, 78},
 	{{4030, 2887}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 105},
 	{{ 384, 2900}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 78},
@@ -289,7 +289,7 @@ STAR_DESC starmap_array[] =
 	{{ 250, 4583}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 5, 26},
 	{{7250, 4583}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 4, 68},
 	{{ 479, 4583}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 26},
-	{{5708, 4604}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 0, 104},
+	{{5708, 4604}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), URQUAN_DEFINED, 0, 104},
 	{{ 479, 4645}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 26},
 	{{2895, 4687}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 6, 20},
 	{{2708, 4708}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 5, 20},
@@ -298,13 +298,13 @@ STAR_DESC starmap_array[] =
 	{{5094, 4931}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 4, 11},
 	{{9000, 5000}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 67},
 	{{8958, 5000}, MAKE_STAR (GIANT_STAR, BLUE_BODY, -1), 0, 1, 67},
-	{{5006, 5011}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 11},
+	{{5006, 5011}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), URQUAN_DEFINED, 3, 11},
 	{{7312, 5062}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 1, 68},
 	{{3679, 5068}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 3, 17},
 	{{9062, 5083}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 67},
 	{{7416, 5083}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), RAINBOW_DEFINED, 3, 68},
 	{{5155, 5122}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 11},
-	{{3875, 5145}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 4, 17},
+	{{3875, 5145}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), ZOQ_COLONY_DEFINED, 4, 17},
 	{{4937, 5145}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 11},
 	{{2979, 5166}, MAKE_STAR (GIANT_STAR, ORANGE_BODY, -1), 0, 1, 15},
 	{{3035, 5178}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 15},
@@ -314,7 +314,7 @@ STAR_DESC starmap_array[] =
 	{{3770, 5250}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 17},
 	{{1520, 5261}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 55},
 	{{1613, 5279}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 4, 55},
-	{{7020, 5291}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 68},
+	{{7020, 5291}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), KOHRAH_DEFINED, 2, 68},
 	{{1416, 5315}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 2, 55},
 	{{2993, 5318}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 15},
 	{{1425, 5404}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 55},
@@ -323,7 +323,7 @@ STAR_DESC starmap_array[] =
 	{{3416, 5437}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 16},
 	{{4000, 5437}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), ZOQFOT_DEFINED, 1, 18},
 	{{6270, 5479}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 102},
-	{{3583, 5479}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 16},
+	{{3583, 5479}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), ZOQ_COLONY_DEFINED, 3, 16},
 	{{4083, 5513}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 18},
 	{{2159, 5614}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 6, 55},
 	{{3937, 5625}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 18},
@@ -348,7 +348,7 @@ STAR_DESC starmap_array[] =
 	{{ 395, 5979}, MAKE_STAR (GIANT_STAR, GREEN_BODY, -1), 0, 1, 22},
 	{{ 563, 5980}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 5, 22},
 	{{ 456, 5989}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 6, 22},
-	{{4625, 6000}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 131},
+	{{4625, 6000}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), URQUAN_DEFINED, 1, 131},
 	{{6166, 6000}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 3, 21},
 	{{6496, 6032}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 6, 21},
 	{{2228, 6038}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 12, 54},
@@ -390,7 +390,7 @@ STAR_DESC starmap_array[] =
 	{{4208, 6854}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 1, 31},
 	{{5145, 6875}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 9, 28},
 	{{4291, 6937}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 31},
-	{{5145, 6958}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 8, 28},
+	{{5145, 6958}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), KOHRAH_DEFINED, 8, 28},
 	{{7208, 7000}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 39},
 	{{8625, 7000}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), RAINBOW_DEFINED, 1, 41},
 	{{4955, 7034}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 28},
@@ -414,7 +414,7 @@ STAR_DESC starmap_array[] =
 	{{4645, 7479}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 4, 36},
 	{{6940, 7514}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 11, 39},
 	{{7443, 7538}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 6, 39},
-	{{6479, 7541}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 0, 38},
+	{{6479, 7541}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), KOHRAH_DEFINED, 0, 38},
 	{{7208, 7541}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 1, 39},
 	{{5791, 7583}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 3, 34},
 	{{ 333, 7625}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 60},
@@ -480,7 +480,7 @@ STAR_DESC starmap_array[] =
 	{{3050, 8833}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 4, 1},
 	{{2831, 8854}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 1},
 	{{2300, 8861}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 13, 53},
-	{{ 479, 8875}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 57},
+	{{ 479, 8875}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), NEGLECTED_STARBASE_DEFINED, 2, 57},
 	{{2706, 8910}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 2, 1},
 	{{ 333, 8916}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 57},
 	{{2535, 8917}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 5, 1},
@@ -794,7 +794,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{TERBIUM, MEDIUM_USEFUL},
 		},
 		LANTHANIDE_COLOR_TAB,
-		YTTRIC_XLAT_TAB,
+		LANTHANIDE_XLAT_TAB,
 		250, 2, 80, 200,
 	},
 	{ /* TREASURE_WORLD */
@@ -813,7 +813,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		TREASURE_COLOR_TAB,
-		QUASI_DEGENERATE_XLAT_TAB,
+		TREASURE_XLAT_TAB,
 		500, 1, 0, 160,
 	},
 	{ /* UREA_WORLD */
@@ -870,7 +870,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		RADIOACTIVE_COLOR_TAB,
-		YTTRIC_XLAT_TAB,
+		RADIOACTIVE_XLAT_TAB,
 		250, 2, 80, 200,
 	},
 	{ /* OPALESCENT_WORLD */
@@ -908,7 +908,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		CYANIC_COLOR_TAB,
-		QUASI_DEGENERATE_XLAT_TAB,
+		CYANIC_XLAT_TAB,
 		500, 1, 0, 160,
 	},
 	{ /* ACID_WORLD */
@@ -927,7 +927,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		ACID_COLOR_TAB,
-		YTTRIC_XLAT_TAB,
+		ACID_XLAT_TAB,
 		250, 2, 80, 200,
 	},
 	{ /* ALKALI_WORLD */
@@ -946,7 +946,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		ALKALI_COLOR_TAB,
-		YTTRIC_XLAT_TAB,
+		ALKALI_XLAT_TAB,
 		250, 2, 80, 200,
 	},
 	{ /* HALIDE_WORLD */
@@ -965,7 +965,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		HALIDE_COLOR_TAB,
-		YTTRIC_XLAT_TAB,
+		HALIDE_XLAT_TAB,
 		250, 2, 80, 200,
 	},
 	{ /* GREEN_WORLD */
@@ -984,7 +984,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		GREEN_COLOR_TAB,
-		UREA_XLAT_TAB,
+		GREEN_XLAT_TAB,
 		230, 2, 200, 150,
 	},
 	{ /* COPPER_WORLD */
@@ -1003,7 +1003,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		COPPER_COLOR_TAB,
-		QUASI_DEGENERATE_XLAT_TAB,
+		COPPER_XLAT_TAB,
 		500, 1, 0, 160,
 	},
 	{ /* CARBIDE_WORLD */
@@ -1022,7 +1022,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		CARBIDE_COLOR_TAB,
-		OPALESCENT_XLAT_TAB,
+		CARBIDE_XLAT_TAB,
 		400, 1, 100, 190,
 	},
 	{ /* ULTRAMARINE_WORLD */
@@ -1041,7 +1041,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		ULTRAMARINE_COLOR_TAB,
-		UREA_XLAT_TAB,
+		ULTRAMARINE_XLAT_TAB,
 		200, 2, 100, 100,
 	},
 	{ /* NOBLE_WORLD */
@@ -1060,7 +1060,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		NOBLE_COLOR_TAB,
-		YTTRIC_XLAT_TAB,
+		NOBLE_XLAT_TAB,
 		250, 2, 80, 200,
 	},
 	{ /* AZURE_WORLD */
@@ -1079,7 +1079,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		AZURE_COLOR_TAB,
-		UREA_XLAT_TAB,
+		AZURE_XLAT_TAB,
 		230, 2, 200, 150,
 	},
 	{ /* CHONDRITE_WORLD */
@@ -1117,7 +1117,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		PURPLE_COLOR_TAB,
-		UREA_XLAT_TAB,
+		PURPLE_XLAT_TAB,
 		230, 2, 200, 150,
 	},
 	{ /* SUPER_DENSE_WORLD */
@@ -1136,7 +1136,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		SUPER_DENSE_COLOR_TAB,
-		QUASI_DEGENERATE_XLAT_TAB,
+		SUPER_DENSE_XLAT_TAB,
 		500, 1, 0, 160,
 	},
 	{ /* PELLUCID_WORLD */
@@ -1155,7 +1155,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		PELLUCID_COLOR_TAB,
-		OPALESCENT_XLAT_TAB,
+		PELLUCID_XLAT_TAB,
 		400, 1, 100, 190,
 	},
 	{ /* DUST_WORLD */
@@ -1174,7 +1174,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		DUST_COLOR_TAB,
-		YTTRIC_XLAT_TAB,
+		DUST_XLAT_TAB,
 		250, 2, 80, 200,
 	},
 	{ /* CRIMSON_WORLD */
@@ -1192,8 +1192,8 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 			{NOTHING, NO_DEPOSIT},
 		},
-		MAROON_COLOR_TAB,
-		UREA_XLAT_TAB,
+		CRIMSON_COLOR_TAB,
+		CRIMSON_XLAT_TAB,
 		230, 2, 200, 150,
 	},
 	{ /* CIMMERIAN_WORLD */
@@ -1212,7 +1212,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		CIMMERIAN_COLOR_TAB,
-		QUASI_DEGENERATE_XLAT_TAB,
+		CIMMERIAN_XLAT_TAB,
 		500, 1, 0, 160,
 	},
 	{ /* INFRARED_WORLD */
@@ -1231,7 +1231,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		INFRARED_COLOR_TAB,
-		OPALESCENT_XLAT_TAB,
+		INFRARED_XLAT_TAB,
 		400, 1, 100, 190,
 	},
 	{ /* SELENIC_WORLD */
@@ -1250,7 +1250,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		SELENIC_COLOR_TAB,
-		UREA_XLAT_TAB,
+		SELENIC_XLAT_TAB,
 		230, 2, 200, 150,
 	},
 	{ /* AURIC_WORLD */
@@ -1269,7 +1269,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		AURIC_COLOR_TAB,
-		QUASI_DEGENERATE_XLAT_TAB,
+		AURIC_XLAT_TAB,
 		500, 1, 0, 160,
 	},
 
@@ -1290,7 +1290,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		FLUORESCENT_COLOR_TAB,
-		OPALESCENT_XLAT_TAB,
+		FLUORESCENT_XLAT_TAB,
 		400, 1, 100, 190,
 	},
 	{ /* ULTRAVIOLET_WORLD */
@@ -1309,7 +1309,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		ULTRAVIOLET_COLOR_TAB,
-		YTTRIC_XLAT_TAB,
+		ULTRAVIOLET_XLAT_TAB,
 		250, 2, 80, 200,
 	},
 	{ /* PLUTONIC_WORLD */
@@ -1328,7 +1328,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		PLUTONIC_COLOR_TAB,
-		YTTRIC_XLAT_TAB,
+		PLUTONIC_XLAT_TAB,
 		250, 2, 80, 200,
 	},
 	{ /* RAINBOW_WORLD */
@@ -1350,7 +1350,7 @@ const PlanetFrame planet_array[NUMBER_OF
 		RAINBOW_XLAT_TAB,
 		500, 1, 20, 100,
 	},
-	{ /* CRACKED_WORLD */
+	{ /* SHATTERED_WORLD */
 		MAKE_BYTE (LARGE_ROCKY_WORLD + CRATERED_ALGO,
 				ORANGE_BODY), /* Color and type/size of planet */
 		SUPER_TECTONICS, /* Tectonics - Scaled with Earth at 82    */
@@ -1365,8 +1365,8 @@ const PlanetFrame planet_array[NUMBER_OF
 			{CHROMIUM, HUGE_USEFUL},
 			{NOTHING, NO_DEPOSIT},
 		},
-		CRACKED_COLOR_TAB,
-		CRACKED_XLAT_TAB,
+		SHATTERED_COLOR_TAB,
+		SHATTERED_XLAT_TAB,
 		500, 1, 0, 185,
 	},
 	{ /* SAPPHIRE_WORLD */
@@ -1404,7 +1404,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		ORGANIC_COLOR_TAB,
-		QUASI_DEGENERATE_XLAT_TAB,
+		ORGANIC_XLAT_TAB,
 		500, 1, 0, 160,
 	},
 	{ /* XENOLITHIC_WORLD */
@@ -1423,7 +1423,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		XENOLITHIC_COLOR_TAB,
-		OPALESCENT_XLAT_TAB,
+		XENOLITHIC_XLAT_TAB,
 		400, 1, 100, 190,
 	},
 	{ /* REDUX_WORLD */
@@ -1461,7 +1461,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		PRIMORDIAL_COLOR_TAB,
-		YTTRIC_XLAT_TAB,
+		PRIMORDIAL_XLAT_TAB,
 		250, 2, 10, 200,
 	},
 	{ /* EMERALD_WORLD */
@@ -1480,7 +1480,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		EMERALD_COLOR_TAB,
-		SAPPHIRE_XLAT_TAB,
+		EMERALD_XLAT_TAB,
 		80, 1, 0, 128,
 	},
 	{ /* CHLORINE_WORLD */
@@ -1518,7 +1518,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		MAGNETIC_COLOR_TAB,
-		OPALESCENT_XLAT_TAB,
+		MAGNETIC_XLAT_TAB,
 		400, 1, 100, 190,
 	},
 	{ /* WATER_WORLD */
@@ -1537,7 +1537,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		WATER_COLOR_TAB,
-		CHLORINE_XLAT_TAB,
+		WATER_XLAT_TAB,
 		500, 1, 0, 190,
 	},
 	{ /* TELLURIC_WORLD */
@@ -1556,7 +1556,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		TELLURIC_COLOR_TAB,
-		YTTRIC_XLAT_TAB,
+		TELLURIC_XLAT_TAB,
 		250, 2, 80, 200,
 	},
 	{ /* HYDROCARBON_WORLD */
@@ -1575,7 +1575,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		HYDROCARBON_COLOR_TAB,
-		QUASI_DEGENERATE_XLAT_TAB,
+		HYDROCARBON_XLAT_TAB,
 		500, 1, 0, 160,
 	},
 	{ /* IODINE_WORLD */
@@ -1594,7 +1594,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		IODINE_COLOR_TAB,
-		UREA_XLAT_TAB,
+		IODINE_XLAT_TAB,
 		230, 2, 200, 150,
 	},
 	{ /* VINYLOGOUS_WORLD */
@@ -1613,7 +1613,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		VINYLOGOUS_COLOR_TAB,
-		OPALESCENT_XLAT_TAB,
+		VINYLOGOUS_XLAT_TAB,
 		400, 1, 100, 190,
 	},
 	{ /* RUBY_WORLD */
@@ -1632,7 +1632,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		RUBY_COLOR_TAB,
-		SAPPHIRE_XLAT_TAB,
+		RUBY_XLAT_TAB,
 		80, 1, 0, 128,
 	},
 	{ /* MAGMA_WORLD */
@@ -1651,7 +1651,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		MAGMA_COLOR_TAB,
-		QUASI_DEGENERATE_XLAT_TAB,
+		MAGMA_XLAT_TAB,
 		500, 1, 0, 160,
 	},
 	{ /* MAROON_WORLD */
@@ -1669,8 +1669,8 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 			{NOTHING, NO_DEPOSIT},
 		},
-		CRIMSON_COLOR_TAB,
-		UREA_XLAT_TAB,
+		MAROON_COLOR_TAB,
+		MAROON_XLAT_TAB,
 		230, 2, 200, 150,
 	},
 
@@ -1690,7 +1690,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		BLU_GAS_COLOR_TAB,
-		GAS_XLAT_TAB,
+		BLU_GAS_XLAT_TAB,
 		10, 2, 8, 29,
 	},
 	{
@@ -1709,7 +1709,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		CYA_GAS_COLOR_TAB,
-		GAS_XLAT_TAB,
+		CYA_GAS_XLAT_TAB,
 		10, 2, 8, 29,
 	},
 	{
@@ -1728,7 +1728,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		GRN_GAS_COLOR_TAB,
-		GAS_XLAT_TAB,
+		GRN_GAS_XLAT_TAB,
 		10, 2, 8, 29,
 	},
 	{
@@ -1747,7 +1747,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		GRY_GAS_COLOR_TAB,
-		GAS_XLAT_TAB,
+		GRY_GAS_XLAT_TAB,
 		10, 2, 8, 29,
 	},
 	{
@@ -1766,7 +1766,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		ORA_GAS_COLOR_TAB,
-		GAS_XLAT_TAB,
+		ORA_GAS_XLAT_TAB,
 		10, 2, 8, 29,
 	},
 	{
@@ -1785,7 +1785,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		PUR_GAS_COLOR_TAB,
-		GAS_XLAT_TAB,
+		PUR_GAS_XLAT_TAB,
 		10, 2, 8, 29,
 	},
 	{
@@ -1804,7 +1804,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		RED_GAS_COLOR_TAB,
-		GAS_XLAT_TAB,
+		RED_GAS_XLAT_TAB,
 		10, 2, 8, 29,
 	},
 	{
@@ -1823,7 +1823,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		VIO_GAS_COLOR_TAB,
-		GAS_XLAT_TAB,
+		VIO_GAS_XLAT_TAB,
 		10, 2, 8, 29,
 	},
 	{ /* A Jupiter-like World */
@@ -1842,7 +1842,7 @@ const PlanetFrame planet_array[NUMBER_OF
 			{NOTHING, NO_DEPOSIT},
 		},
 		YEL_GAS_COLOR_TAB,
-		GAS_XLAT_TAB,
+		YEL_GAS_XLAT_TAB,
 		10, 2, 8, 29,
 	},
 };
diff -ruNp src.orig/sc2code/planets/Makeinfo src/sc2code/planets/Makeinfo
--- src.orig/sc2code/planets/Makeinfo	2017-11-08 16:49:36 -0600
+++ src/sc2code/planets/Makeinfo	2017-11-08 16:50:03 -0600
@@ -1,7 +1,8 @@
 uqm_CFILES="calc.c cargo.c devices.c genburv.c genchmmr.c gencol.c
-		gendru.c genilw.c genmel.c genmyc.c genorz.c genpet.c genpku.c
-		genrain.c gensam.c genshof.c gensly.c gensol.c genspa.c gensup.c
-		gensyr.c genthrad.c gentopo.c genutw.c genvault.c genvux.c
-		genwreck.c genyeh.c genzoq.c lander.c orbits.c oval.c pl_stuff.c
-		planets.c plangen.c pstarmap.c report.c
-		roster.c scan.c solarsys.c surface.c"
+		gendru.c genilw.c genmel.c genmothark.c genmyc.c
+		gennegl.c genorz.c genpet.c genpku.c genprecrsr.c
+		genrain.c gensam.c genshof.c gensly.c gensol.c genspa.c
+		gensup.c gensyr.c genthrad.c gentopo.c genurq.c genutw.c
+		genvault.c genvux.c genwreck.c genyeh.c genzoq.c lander.c
+		orbits.c oval.c pl_stuff.c planets.c plangen.c pstarmap.c
+		report.c roster.c scan.c solarsys.c surface.c"
diff -ruNp src.orig/sc2code/planets/calc.c src/sc2code/planets/calc.c
--- src.orig/sc2code/planets/calc.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/planets/calc.c	2017-11-08 16:50:02 -0600
@@ -57,7 +57,7 @@ enum
 };
 
 static void
-CalcSysInfo (SYSTEM_INFOPTR SysInfoPtr)
+CalcSysInfo (SYSTEM_INFO *SysInfoPtr)
 {
 	SysInfoPtr->StarSize = pSolarSysState->SunDesc[0].data_index;
 	switch (STAR_COLOR (CurStarDescPtr->Type))
@@ -100,8 +100,8 @@ CalcSysInfo (SYSTEM_INFOPTR SysInfoPtr)
 }
 
 static UWORD
-GeneratePlanetComposition (PLANET_INFOPTR PlanetInfoPtr, SIZE
-		SurfaceTemp, SIZE radius)
+GeneratePlanetComposition (PLANET_INFO *PlanetInfoPtr, SIZE SurfaceTemp,
+		SIZE radius)
 {
 	if (PLANSIZE (PlanetInfoPtr->PlanDataPtr->Type) == GAS_GIANT)
 	{
@@ -166,7 +166,7 @@ GeneratePlanetComposition (PLANET_INFOPT
 // (eg. Beta Corvi I). I don't know what the idea behind this is,
 // but the if statement must be there for a reason. -- SvdB
 static SIZE
-CalcTemp (SYSTEM_INFOPTR SysInfoPtr, SIZE radius)
+CalcTemp (SYSTEM_INFO *SysInfoPtr, SIZE radius)
 {
 #define GENERIC_ALBEDO 33 /* In %, 0=black, 100 is reflective */
 #define ADJUST_FOR_KELVIN 273
@@ -201,7 +201,7 @@ CalcTemp (SYSTEM_INFOPTR SysInfoPtr, SIZ
 }
 
 static COUNT
-CalcRotation (PLANET_INFOPTR PlanetInfoPtr)
+CalcRotation (PLANET_INFO *PlanetInfoPtr)
 {
 	if (PLANSIZE (PlanetInfoPtr->PlanDataPtr->Type) == GAS_GIANT)
 		return ((COUNT)CalcFromBase (80, 80));
@@ -231,13 +231,12 @@ CalcTilt (void)
 
 // NB. Returns the RNG to the state it found it in.
 DWORD
-DoPlanetaryAnalysis (SYSTEM_INFOPTR SysInfoPtr, PPLANET_DESC
-		pPlanetDesc)
+DoPlanetaryAnalysis (SYSTEM_INFO *SysInfoPtr, PLANET_DESC *pPlanetDesc)
 {
 	DWORD old_seed;
 
 					/* Earth Starbase */
-	if (pPlanetDesc->data_index == (BYTE)~0)
+	if (pPlanetDesc->data_index == HIERARCHY_STARBASE)
 		return (0);
 
 	old_seed = TFB_SeedRandom (pPlanetDesc->rand_seed);
diff -ruNp src.orig/sc2code/planets/cargo.c src/sc2code/planets/cargo.c
--- src.orig/sc2code/planets/cargo.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/planets/cargo.c	2017-11-08 16:50:02 -0600
@@ -37,7 +37,7 @@ ShowRemainingCapacity (void)
 	SetContextFont (TinyFont);
 
 	sprintf (rt_amount_buf, "%u",
-			GetSBayCapacity (NULL_PTR)
+			GetSBayCapacity (NULL)
 			- GLOBAL_SIS (TotalElementMass));
 	rt.baseline.x = 59;
 	rt.baseline.y = 113;
@@ -289,7 +289,7 @@ DrawCargoStrings (BYTE OldElement, BYTE
 }
 
 static BOOLEAN
-DoDiscardCargo (PMENU_STATE pMS)
+DoDiscardCargo (MENU_STATE *pMS)
 {
 	BYTE NewState;
 	BOOLEAN select, cancel, back, forward;
@@ -365,7 +365,7 @@ SelectCargo:
 }
 
 void
-Cargo (PMENU_STATE pMS)
+Cargo (MENU_STATE *pMS)
 {
 	pMS->InputFunc = DoDiscardCargo;
 	--pMS->Initialized;
@@ -376,7 +376,7 @@ Cargo (PMENU_STATE pMS)
 	UnlockMutex (GraphicsLock);
 
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
-	DoInput ((PVOID)pMS, TRUE);
+	DoInput (pMS, TRUE);
 
 	pMS->InputFunc = DoFlagshipCommands;
 	pMS->CurState = CARGO + 1;
diff -ruNp src.orig/sc2code/planets/devices.c src/sc2code/planets/devices.c
--- src.orig/sc2code/planets/devices.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/planets/devices.c	2017-11-08 16:50:02 -0600
@@ -25,6 +25,7 @@
 #include "load.h"
 #include "setup.h"
 #include "state.h"
+#include "grpinfo.h"
 #include "sounds.h"
 #include "util.h"
 #include "strlib.h"
@@ -36,13 +37,13 @@
 //#define DEBUG_DEVICES
 
 static void
-DrawDevices (PMENU_STATE pMS, BYTE OldDevice, BYTE NewDevice)
+DrawDevices (MENU_STATE *pMS, BYTE OldDevice, BYTE NewDevice)
 {
 #define MAX_VIS_DEVICES 5
 	COORD y, cy;
 	TEXT t;
 	RECT r;
-	PBYTE pDeviceMap;
+	BYTE *pDeviceMap;
 
 	LockMutex (GraphicsLock);
 
@@ -54,7 +55,7 @@ DrawDevices (PMENU_STATE pMS, BYTE OldDe
 	t.align = ALIGN_CENTER;
 	t.CharCount = 3;
 
-	pDeviceMap = (PBYTE)pMS->CurFrame;
+	pDeviceMap = (BYTE*)pMS->CurFrame;
 	if (OldDevice > NUM_DEVICES
 			|| (NewDevice < NUM_DEVICES
 			&& (NewDevice < (BYTE)pMS->first_item.y
@@ -217,7 +218,8 @@ UseCaster (void)
 
 		EncounterGroup = 0;
 		PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
-		ReinitQueue (&GLOBAL (npc_built_ship_q));
+		ReinitQueue (&GLOBAL (ip_group_q));
+		assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
 
 		SET_GAME_STATE (GLOBAL_FLAGS_AND_DATA, 1 << 7);
 		SaveFlagshipState ();
@@ -226,22 +228,20 @@ UseCaster (void)
 
 	{
 		BOOLEAN FoundIlwrath;
-		HSTARSHIP hStarShip;
+		HIPGROUP hGroup;
 
 		FoundIlwrath = (BOOLEAN)(CurStarDescPtr->Index == ILWRATH_DEFINED);
 				// In the Ilwrath home system?
 
 		if (!FoundIlwrath &&
-				(hStarShip = GetHeadLink (&GLOBAL (npc_built_ship_q))))
+				(hGroup = GetHeadLink (&GLOBAL (ip_group_q))))
 		{
-			// Ilwrath ship is in the system.
-			SHIP_FRAGMENTPTR FragPtr;
+			// Is an Ilwrath ship in the system?
+			IP_GROUP *GroupPtr;
 
-			FragPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-					&GLOBAL (npc_built_ship_q), hStarShip);
-			FoundIlwrath = (BOOLEAN)(
-					GET_RACE_ID (FragPtr) == ILWRATH_SHIP);
-			UnlockStarShip (&GLOBAL (npc_built_ship_q), hStarShip);
+			GroupPtr = LockIpGroup (&GLOBAL (ip_group_q), hGroup);
+			FoundIlwrath = (GroupPtr->race_id == ILWRATH_SHIP);
+			UnlockIpGroup (&GLOBAL (ip_group_q), hGroup);
 		}
 
 		if (FoundIlwrath)
@@ -251,7 +251,8 @@ UseCaster (void)
 
 			EncounterGroup = 0;
 			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
-			ReinitQueue (&GLOBAL (npc_built_ship_q));
+			ReinitQueue (&GLOBAL (ip_group_q));
+			assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
 
 			if (CurStarDescPtr->Index == ILWRATH_DEFINED)
 			{
@@ -323,7 +324,8 @@ DeviceFailed (BYTE which_device)
 					GLOBAL (CurrentActivity) |= START_ENCOUNTER;
 
 					PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
-					ReinitQueue (&GLOBAL (npc_built_ship_q));
+					ReinitQueue (&GLOBAL (ip_group_q));
+					assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
 
 					CloneShipFragment (CHMMR_SHIP,
 							&GLOBAL (npc_built_ship_q), 0);
@@ -361,12 +363,13 @@ DeviceFailed (BYTE which_device)
 			else
 			{
 				EncounterGroup = 0;
-				if (GetHeadLink (&GLOBAL (npc_built_ship_q)))
+				if (GetHeadLink (&GLOBAL (ip_group_q)))
 				{
 					SET_GAME_STATE (SHIP_TO_COMPEL, 1);
 
 					PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
-					ReinitQueue (&GLOBAL (npc_built_ship_q));
+					ReinitQueue (&GLOBAL (ip_group_q));
+					assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
 				}
 
 				if (CurStarDescPtr->Index == SAMATRA_DEFINED)
@@ -441,7 +444,7 @@ DeviceFailed (BYTE which_device)
 }
 
 static BOOLEAN
-DoManipulateDevices (PMENU_STATE pMS)
+DoManipulateDevices (MENU_STATE *pMS)
 {
 	BYTE NewState;
 	BOOLEAN select, cancel, back, forward;
@@ -474,7 +477,7 @@ DoManipulateDevices (PMENU_STATE pMS)
 
 		LockMutex (GraphicsLock);
 		status = DeviceFailed (
-				((PBYTE)pMS->CurFrame)[pMS->CurState - 1]
+				((BYTE*)pMS->CurFrame)[pMS->CurState - 1]
 				);
 		NewState = LOBYTE (status);
 		if (NewState)
@@ -630,7 +633,7 @@ InventoryDevices (BYTE *pDeviceMap)
 }
 
 BOOLEAN
-Devices (PMENU_STATE pMS)
+Devices (MENU_STATE *pMS)
 {
 	BYTE DeviceMap[NUM_DEVICES];
 
@@ -646,7 +649,7 @@ Devices (PMENU_STATE pMS)
 		TFB_ResetControls ();
 		DoManipulateDevices (pMS); /* to make sure it's initialized */
 		SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
-		DoInput ((PVOID)pMS, TRUE);
+		DoInput (pMS, TRUE);
 		pMS->CurFrame = 0;
 
 		pMS->InputFunc = DoFlagshipCommands;
diff -ruNp src.orig/sc2code/planets/genchmmr.c src/sc2code/planets/genchmmr.c
--- src.orig/sc2code/planets/genchmmr.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/planets/genchmmr.c	2017-11-08 16:50:02 -0600
@@ -41,7 +41,7 @@ GenerateChmmr (BYTE control)
 				COUNT angle;
 				DWORD rand_val;
 
-				pSolarSysState->MoonDesc[0].data_index = (BYTE)~0;
+				pSolarSysState->MoonDesc[0].data_index = HIERARCHY_STARBASE;
 				pSolarSysState->MoonDesc[0].radius = MIN_MOON_RADIUS;
 				rand_val = TFB_Random ();
 				angle = NORMALIZE_ANGLE (LOWORD (rand_val));
@@ -79,7 +79,8 @@ GenerateChmmr (BYTE control)
 						&& ActivateStarShip (ILWRATH_SHIP, SPHERE_TRACKING))
 				{
 					PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
-					ReinitQueue (&GLOBAL (npc_built_ship_q));
+					ReinitQueue (&GLOBAL (ip_group_q));
+					assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
 
 					CloneShipFragment (ILWRATH_SHIP,
 							&GLOBAL (npc_built_ship_q), INFINITE_FLEET);
@@ -112,7 +113,7 @@ GenerateChmmr (BYTE control)
 						CaptureStringTable (
 								LoadStringTable (CHMMR_BASE_STRTAB));
 
-				ScanContext = CaptureContext (CreateContext ());
+				ScanContext = CreateContext ();
 				SetContext (ScanContext);
 				SetContextFGFrame (Screen);
 				r.corner.x = (SIS_ORG_X + SIS_SCREEN_WIDTH) - MAP_WIDTH;
@@ -124,7 +125,7 @@ GenerateChmmr (BYTE control)
 				DoDiscoveryReport (MenuSounds);
 
 				SetContext (SpaceContext);
-				DestroyContext (ReleaseContext (ScanContext));
+				DestroyContext (ScanContext);
 				ScanContext = 0;
 
 				DestroyStringTable (ReleaseStringTable (
diff -ruNp src.orig/sc2code/planets/gencol.c src/sc2code/planets/gencol.c
--- src.orig/sc2code/planets/gencol.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/planets/gencol.c	2017-11-08 16:50:02 -0600
@@ -19,6 +19,7 @@
 #include "build.h"
 #include "globdata.h"
 #include "state.h"
+#include "grpinfo.h"
 #include "planets/genall.h"
 
 
@@ -29,43 +30,40 @@ GenerateColony (BYTE control)
 	{
 		case INIT_NPCS:
 		{
-			HSTARSHIP hStarShip;
+			HIPGROUP hGroup;
 
 			GLOBAL (BattleGroupRef) = GET_GAME_STATE_32 (COLONY_GRPOFFS0);
 			if (GLOBAL (BattleGroupRef) == 0)
 			{
 				CloneShipFragment (URQUAN_SHIP,
 						&GLOBAL (npc_built_ship_q), 0);
-
 				GLOBAL (BattleGroupRef) = PutGroupInfo (GROUPS_ADD_NEW, 1);
+				ReinitQueue (&GLOBAL (npc_built_ship_q));
 				SET_GAME_STATE_32 (COLONY_GRPOFFS0, GLOBAL (BattleGroupRef));
 			}
 
 			GenerateRandomIP (INIT_NPCS);
 
 			if (GLOBAL (BattleGroupRef)
-					&& (hStarShip = GetHeadLink (&GLOBAL (npc_built_ship_q))))
+					&& (hGroup = GetHeadLink (&GLOBAL (ip_group_q))))
 			{
-				SHIP_FRAGMENTPTR FragPtr;
+				IP_GROUP *GroupPtr;
 
-				FragPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-						&GLOBAL (npc_built_ship_q), hStarShip
-						);
-				SET_GROUP_MISSION (FragPtr, IN_ORBIT);
-				SET_GROUP_LOC (FragPtr, 0 + 1); /* orbitting colony */
-				SET_GROUP_DEST (FragPtr, 0 + 1); /* orbitting colony */
-				FragPtr->ShipInfo.loc.x = FragPtr->ShipInfo.loc.y = 0;
-				FragPtr->ShipInfo.group_counter = 0;
-				UnlockStarShip (
-						&GLOBAL (npc_built_ship_q), hStarShip
-						);
+				GroupPtr = LockIpGroup (&GLOBAL (ip_group_q), hGroup);
+				GroupPtr->task = IN_ORBIT;
+				GroupPtr->sys_loc = 0 + 1; /* orbitting colony */
+				GroupPtr->dest_loc = 0 + 1; /* orbitting colony */
+				GroupPtr->loc.x = 0;
+				GroupPtr->loc.y = 0;
+				GroupPtr->group_counter = 0;
+				UnlockIpGroup (&GLOBAL (ip_group_q), hGroup);
 			}
 			break;
 		}
 		case GENERATE_PLANETS:
 		{
 			COUNT angle;
-			PPLANET_DESC pMinPlanet;
+			PLANET_DESC *pMinPlanet;
 
 			pMinPlanet = &pSolarSysState->PlanetDesc[0];
 			FillOrbits (pSolarSysState, (BYTE)~0, pMinPlanet, FALSE);
diff -ruNp src.orig/sc2code/planets/gendru.c src/sc2code/planets/gendru.c
--- src.orig/sc2code/planets/gendru.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/planets/gendru.c	2017-11-08 16:50:02 -0600
@@ -22,6 +22,8 @@
 #include "lander.h"
 #include "nameref.h"
 #include "resinst.h"
+#include "setup.h"
+#include "sounds.h"
 #include "state.h"
 #include "planets/genall.h"
 #include "libs/mathlib.h"
@@ -63,7 +65,7 @@ GenerateDruuge (BYTE control)
 
 						if (!GET_GAME_STATE (ROSY_SPHERE))
 						{
-							((PPLANETSIDE_DESC)pMenuState->ModuleFrame)->InTransit = TRUE;
+							((PLANETSIDE_DESC*)pMenuState->ModuleFrame)->InTransit = TRUE;
 
 							SET_GAME_STATE (ROSY_SPHERE, 1);
 							SET_GAME_STATE (ROSY_SPHERE_ON_SHIP, 1);
@@ -82,6 +84,22 @@ GenerateDruuge (BYTE control)
 			}
 			pSolarSysState->CurNode = 0;
 			break;
+		case GENERATE_MOONS:
+			GenerateRandomIP (GENERATE_MOONS);
+			if (CurStarDescPtr->Index == DRUUGE_DEFINED &&
+					pSolarSysState->pBaseDesc == &pSolarSysState->PlanetDesc[0])
+			{
+				GenerateRandomIP (GENERATE_MOONS);
+				pSolarSysState->MoonDesc[0].data_index =
+						(ActivateStarShip (DRUUGE_SHIP, SPHERE_TRACKING)) ?
+						DRUUGE_STARBASE : DESTROYED_STARBASE;
+				pSolarSysState->MoonDesc[0].radius = MIN_MOON_RADIUS;
+				pSolarSysState->MoonDesc[0].location.x =
+						COSINE (HALF_CIRCLE, pSolarSysState->MoonDesc[0].radius);
+				pSolarSysState->MoonDesc[0].location.y =
+						SINE (HALF_CIRCLE, pSolarSysState->MoonDesc[0].radius);
+			}
+			break;
 		case GENERATE_PLANETS:
 		{
 			COUNT angle;
@@ -96,7 +114,7 @@ GenerateDruuge (BYTE control)
 
 			pSolarSysState->PlanetDesc[0].data_index = DUST_WORLD;
 			pSolarSysState->PlanetDesc[0].radius = EARTH_RADIUS * 50L / 100;
-			pSolarSysState->PlanetDesc[0].NumPlanets = 0;
+			pSolarSysState->PlanetDesc[0].NumPlanets = 1;
 			angle = HALF_CIRCLE - OCTANT;
 			pSolarSysState->PlanetDesc[0].location.x =
 					COSINE (angle, pSolarSysState->PlanetDesc[0].radius);
@@ -109,13 +127,64 @@ GenerateDruuge (BYTE control)
 			break;
 		}
 		case GENERATE_ORBITAL:
+			if ((pSolarSysState->pOrbitalDesc == &pSolarSysState->MoonDesc[0]) &&
+					(pSolarSysState->pOrbitalDesc->pPrevDesc == &pSolarSysState->PlanetDesc[0]))
+			{
+				// If you go to the starbase, move the ship to
+				// the planet instead
+				if (ActivateStarShip (DRUUGE_SHIP, SPHERE_TRACKING))
+				{
+					pSolarSysState->pOrbitalDesc =
+							&pSolarSysState->PlanetDesc[0];
+					GLOBAL (ShipStamp.origin.x) = SIS_SCREEN_WIDTH >> 1;
+					GLOBAL (ShipStamp.origin.y) = SIS_SCREEN_HEIGHT >> 1;
+				}
+				// ...unless the Kohr-Ah have been through here
+				else
+				{
+					RECT r;
+					LockMutex (GraphicsLock);
+					
+					LoadStdLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+					pSolarSysState->SysInfo.PlanetInfo.DiscoveryString =
+							SetRelStringTableIndex (
+									CaptureStringTable (
+											LoadStringTable (RUINS_STRTAB)), 1);
+
+					ScanContext = CreateContext ();
+					SetContext (ScanContext);
+					SetContextFGFrame (Screen);
+					r.corner.x = (SIS_ORG_X + SIS_SCREEN_WIDTH) - MAP_WIDTH;
+					r.corner.y = (SIS_ORG_Y + SIS_SCREEN_HEIGHT) - MAP_HEIGHT;
+					r.extent.width = MAP_WIDTH;
+					r.extent.height = MAP_HEIGHT;
+					SetContextClipRect (&r);
+
+					DoDiscoveryReport (MenuSounds);
+
+					SetContext (SpaceContext);
+					DestroyContext (ScanContext);
+					ScanContext = 0;
+
+					DestroyStringTable (ReleaseStringTable (
+							pSolarSysState->SysInfo.PlanetInfo.DiscoveryString
+							));
+					pSolarSysState->SysInfo.PlanetInfo.DiscoveryString = 0;
+					FreeLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+
+					UnlockMutex (GraphicsLock);
+					break; 
+				}
+			}
+
 			if (pSolarSysState->pOrbitalDesc == &pSolarSysState->PlanetDesc[0])
 			{
 				if (ActivateStarShip (DRUUGE_SHIP, SPHERE_TRACKING))
 				{
 					NotifyOthers (DRUUGE_SHIP, (BYTE)~0);
 					PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
-					ReinitQueue (&GLOBAL (npc_built_ship_q));
+					ReinitQueue (&GLOBAL (ip_group_q));
+					assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
 
 					CloneShipFragment (DRUUGE_SHIP,
 							&GLOBAL (npc_built_ship_q), INFINITE_FLEET);
diff -ruNp src.orig/sc2code/planets/genilw.c src/sc2code/planets/genilw.c
--- src.orig/sc2code/planets/genilw.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/planets/genilw.c	2017-11-08 16:50:02 -0600
@@ -19,8 +19,11 @@
 #include "build.h"
 #include "encount.h"
 #include "globdata.h"
+#include "lander.h"
 #include "nameref.h"
 #include "resinst.h"
+#include "setup.h"
+#include "sounds.h"
 #include "state.h"
 #include "planets/genall.h"
 #include "libs/mathlib.h"
@@ -64,6 +67,21 @@ GenerateIlwrath (BYTE control)
 			}
 			pSolarSysState->CurNode = 0;
 			break;
+		case GENERATE_MOONS:
+			GenerateRandomIP (GENERATE_MOONS);
+			if (CurStarDescPtr->Index == ILWRATH_DEFINED &&
+					pSolarSysState->pBaseDesc == &pSolarSysState->PlanetDesc[0])
+			{
+				pSolarSysState->MoonDesc[0].data_index =
+						(ActivateStarShip (ILWRATH_SHIP, SPHERE_TRACKING)) ?
+						HIERARCHY_STARBASE : DESTROYED_STARBASE;
+				pSolarSysState->MoonDesc[0].radius = MIN_MOON_RADIUS;
+				pSolarSysState->MoonDesc[0].location.x =
+						COSINE (OCTANT, pSolarSysState->MoonDesc[0].radius);
+				pSolarSysState->MoonDesc[0].location.y =
+						SINE (OCTANT, pSolarSysState->MoonDesc[0].radius);
+			}
+			break;
 		case GENERATE_PLANETS:
 		{
 			COUNT angle;
@@ -79,16 +97,69 @@ GenerateIlwrath (BYTE control)
 					COSINE (angle, pSolarSysState->PlanetDesc[0].radius);
 			pSolarSysState->PlanetDesc[0].location.y =
 					SINE (angle, pSolarSysState->PlanetDesc[0].radius);
+			pSolarSysState->PlanetDesc[0].NumPlanets = 1;
 			break;
 		}
 		case GENERATE_ORBITAL:
+			if ((CurStarDescPtr->Index == ILWRATH_DEFINED) &&
+					(pSolarSysState->pOrbitalDesc == &pSolarSysState->MoonDesc[0]) &&
+					(pSolarSysState->pOrbitalDesc->pPrevDesc == &pSolarSysState->PlanetDesc[0]))
+			{
+				// If you go to the starbase, move the ship to
+				// the planet instead
+				if (ActivateStarShip (ILWRATH_SHIP, SPHERE_TRACKING))
+				{
+					pSolarSysState->pOrbitalDesc =
+							&pSolarSysState->PlanetDesc[0];
+					GLOBAL (ShipStamp.origin.x) = SIS_SCREEN_WIDTH >> 1;
+					GLOBAL (ShipStamp.origin.y) = SIS_SCREEN_HEIGHT >> 1;
+				}
+				// ...unless they're all dead
+				else
+				{
+					RECT r;
+					LockMutex (GraphicsLock);
+					
+					LoadStdLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+					pSolarSysState->SysInfo.PlanetInfo.DiscoveryString =
+							SetRelStringTableIndex (
+									CaptureStringTable (
+											LoadStringTable (RUINS_STRTAB)), 1);
+
+					ScanContext = CreateContext ();
+					SetContext (ScanContext);
+					SetContextFGFrame (Screen);
+					r.corner.x = (SIS_ORG_X + SIS_SCREEN_WIDTH) - MAP_WIDTH;
+					r.corner.y = (SIS_ORG_Y + SIS_SCREEN_HEIGHT) - MAP_HEIGHT;
+					r.extent.width = MAP_WIDTH;
+					r.extent.height = MAP_HEIGHT;
+					SetContextClipRect (&r);
+
+					DoDiscoveryReport (MenuSounds);
+
+					SetContext (SpaceContext);
+					DestroyContext (ScanContext);
+					ScanContext = 0;
+
+					DestroyStringTable (ReleaseStringTable (
+							pSolarSysState->SysInfo.PlanetInfo.DiscoveryString
+							));
+					pSolarSysState->SysInfo.PlanetInfo.DiscoveryString = 0;
+					FreeLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+
+					UnlockMutex (GraphicsLock);
+					break; 
+				}
+			}
+
 			if (pSolarSysState->pOrbitalDesc == &pSolarSysState->PlanetDesc[0])
 			{
 				if (ActivateStarShip (ILWRATH_SHIP, SPHERE_TRACKING))
 				{
 					NotifyOthers (ILWRATH_SHIP, (BYTE)~0);
 					PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
-					ReinitQueue (&GLOBAL (npc_built_ship_q));
+					ReinitQueue (&GLOBAL (ip_group_q));
+					assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
 
 					CloneShipFragment (ILWRATH_SHIP,
 							&GLOBAL (npc_built_ship_q), INFINITE_FLEET);
diff -ruNp src.orig/sc2code/planets/genmel.c src/sc2code/planets/genmel.c
--- src.orig/sc2code/planets/genmel.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/planets/genmel.c	2017-11-08 16:50:03 -0600
@@ -102,6 +102,7 @@ GenerateMelnorme (BYTE control)
 				CloneShipFragment (MELNORME_SHIP,
 						&GLOBAL (npc_built_ship_q), 0);
 				GLOBAL (BattleGroupRef) = PutGroupInfo (GROUPS_ADD_NEW, 1);
+				ReinitQueue (&GLOBAL (npc_built_ship_q));
 				SetMelnormeRef (GLOBAL (BattleGroupRef));
 			}
 			GenerateRandomIP (INIT_NPCS);
diff -ruNp src.orig/sc2code/planets/genmothark.c src/sc2code/planets/genmothark.c
--- src.orig/sc2code/planets/genmothark.c	1969-12-31 18:00:00 -0600
+++ src/sc2code/planets/genmothark.c	2017-11-08 16:50:03 -0600
@@ -0,0 +1,74 @@
+/*
+ *  Copyright (C) 2008  Nicolas Simonds <uqm@submedia.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "globdata.h"
+#include "lander.h"
+#include "nameref.h"
+#include "resinst.h"
+#include "planets/genall.h"
+#include "libs/mathlib.h"
+
+
+void
+GenerateMotherArk (BYTE control)
+{
+	switch (control)
+	{
+		case GENERATE_ENERGY:
+			if (pSolarSysState->pOrbitalDesc->pPrevDesc == &pSolarSysState->PlanetDesc[2]
+					&& pSolarSysState->pOrbitalDesc == &pSolarSysState->MoonDesc[0])
+			{
+				DWORD rand_val, old_rand;
+
+				old_rand = TFB_SeedRandom (
+						pSolarSysState->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN]);
+
+				rand_val = TFB_Random ();
+				pSolarSysState->SysInfo.PlanetInfo.CurPt.x =
+						(LOBYTE (LOWORD (rand_val)) % (MAP_WIDTH - (8 << 1))) + 8;
+				pSolarSysState->SysInfo.PlanetInfo.CurPt.y =
+						(HIBYTE (LOWORD (rand_val)) % (MAP_HEIGHT - (8 << 1))) + 8;
+				pSolarSysState->SysInfo.PlanetInfo.CurType = 1;
+				pSolarSysState->SysInfo.PlanetInfo.CurDensity = 0;
+				if (!(pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN] & (1L << 0)))
+					pSolarSysState->CurNode = 1;
+
+				TFB_SeedRandom (old_rand);
+				break;
+			}
+			pSolarSysState->CurNode = 0;
+			break;
+		case GENERATE_ORBITAL:
+			if (pSolarSysState->pOrbitalDesc->pPrevDesc == &pSolarSysState->PlanetDesc[2]
+                    && pSolarSysState->pOrbitalDesc == &pSolarSysState->MoonDesc[0])
+			{
+				LoadStdLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+				pSolarSysState->PlanetSideFrame[1] =
+						CaptureDrawable (
+								LoadGraphic (MOTHER_ARK_MASK_PMAP_ANIM)
+								);
+				pSolarSysState->SysInfo.PlanetInfo.DiscoveryString =
+						CaptureStringTable (
+								LoadStringTable (MOTHER_ARK_STRTAB)
+								);
+			}
+		default:
+			GenerateRandomIP (control);
+			break;
+	}
+}
diff -ruNp src.orig/sc2code/planets/genmyc.c src/sc2code/planets/genmyc.c
--- src.orig/sc2code/planets/genmyc.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/planets/genmyc.c	2017-11-08 16:50:03 -0600
@@ -19,9 +19,11 @@
 #include "build.h"
 #include "encount.h"
 #include "globdata.h"
+#include "lander.h"
 #include "nameref.h"
 #include "resinst.h"
 #include "setup.h"
+#include "sounds.h"
 #include "state.h"
 #include "planets/genall.h"
 #include "libs/mathlib.h"
@@ -103,13 +105,53 @@ GenerateMycon (BYTE control)
 				break;
 			}
 			pSolarSysState->CurNode = 0;
+			break; 
+		case GENERATE_MOONS:
+			if (CurStarDescPtr->Index == MYCON_DEFINED &&
+					pSolarSysState->pBaseDesc == &pSolarSysState->PlanetDesc[0])
+			{
+				COUNT angle;
+
+				// Setup moons, then add a starbase as the last moon
+				pSolarSysState->PlanetDesc[0].NumPlanets = 2;
+				GenerateRandomIP (GENERATE_MOONS);
+				pSolarSysState->PlanetDesc[0].NumPlanets = 3;
+
+				pSolarSysState->MoonDesc[2].data_index =
+						(ActivateStarShip (MYCON_SHIP, SPHERE_TRACKING)) ?
+						HIERARCHY_STARBASE : DESTROYED_STARBASE;
+				angle = FULL_CIRCLE - OCTANT;
+				pSolarSysState->MoonDesc[2].radius = MIN_MOON_RADIUS;
+				pSolarSysState->MoonDesc[2].location.x =
+						COSINE (angle, pSolarSysState->MoonDesc[0].radius);
+				pSolarSysState->MoonDesc[2].location.y =
+						SINE (angle, pSolarSysState->MoonDesc[0].radius);
+
+				// adjust the positions of the other moons outward
+				pSolarSysState->MoonDesc[0].radius += MOON_DELTA;
+				angle = ARCTAN (pSolarSysState->MoonDesc[0].location.x,
+						pSolarSysState->MoonDesc[0].location.y);
+				pSolarSysState->MoonDesc[0].location.x =
+						COSINE (angle, pSolarSysState->MoonDesc[0].radius);
+				pSolarSysState->MoonDesc[0].location.y =
+						SINE (angle, pSolarSysState->MoonDesc[0].radius);
+				pSolarSysState->MoonDesc[1].radius += MOON_DELTA;
+				angle = ARCTAN (pSolarSysState->MoonDesc[1].location.x,
+						pSolarSysState->MoonDesc[1].location.y);
+				pSolarSysState->MoonDesc[1].location.x =
+						COSINE (angle, pSolarSysState->MoonDesc[1].radius);
+				pSolarSysState->MoonDesc[1].location.y =
+						SINE (angle, pSolarSysState->MoonDesc[1].radius);
+				break;
+			}
+			GenerateRandomIP (GENERATE_MOONS);
 			break;
 		case GENERATE_PLANETS:
 		{
 			COUNT angle;
 
 			GenerateRandomIP (GENERATE_PLANETS);
-			pSolarSysState->PlanetDesc[0].data_index = CRACKED_WORLD;
+			pSolarSysState->PlanetDesc[0].data_index = SHATTERED_WORLD;
 			pSolarSysState->PlanetDesc[0].radius = EARTH_RADIUS * 80L / 100;
 			if (pSolarSysState->PlanetDesc[0].NumPlanets > 2)
 				pSolarSysState->PlanetDesc[0].NumPlanets = 2;
@@ -124,6 +166,57 @@ GenerateMycon (BYTE control)
 			break;
 		}
 		case GENERATE_ORBITAL:
+			if ((CurStarDescPtr->Index == MYCON_DEFINED) &&
+					(pSolarSysState->pOrbitalDesc == &pSolarSysState->MoonDesc[2]) &&
+					(pSolarSysState->pOrbitalDesc->pPrevDesc == &pSolarSysState->PlanetDesc[0]))
+			{
+				// If you go to the starbase, move the ship to
+				// the planet instead
+				if (ActivateStarShip (MYCON_SHIP, SPHERE_TRACKING))
+				{
+					pSolarSysState->pOrbitalDesc =
+							&pSolarSysState->PlanetDesc[0];
+					GLOBAL (ShipStamp.origin.x) = SIS_SCREEN_WIDTH >> 1;
+					GLOBAL (ShipStamp.origin.y) = SIS_SCREEN_HEIGHT >> 1;
+				}
+				// ...unless they're all dead
+				else
+				{
+					RECT r;
+					LockMutex (GraphicsLock);
+					
+					LoadStdLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+					pSolarSysState->SysInfo.PlanetInfo.DiscoveryString =
+							SetRelStringTableIndex (
+									CaptureStringTable (
+											LoadStringTable (RUINS_STRTAB)), 1);
+
+					ScanContext = CreateContext ();
+					SetContext (ScanContext);
+					SetContextFGFrame (Screen);
+					r.corner.x = (SIS_ORG_X + SIS_SCREEN_WIDTH) - MAP_WIDTH;
+					r.corner.y = (SIS_ORG_Y + SIS_SCREEN_HEIGHT) - MAP_HEIGHT;
+					r.extent.width = MAP_WIDTH;
+					r.extent.height = MAP_HEIGHT;
+					SetContextClipRect (&r);
+
+					DoDiscoveryReport (MenuSounds);
+
+					SetContext (SpaceContext);
+					DestroyContext (ScanContext);
+					ScanContext = 0;
+
+					DestroyStringTable (ReleaseStringTable (
+							pSolarSysState->SysInfo.PlanetInfo.DiscoveryString
+							));
+					pSolarSysState->SysInfo.PlanetInfo.DiscoveryString = 0;
+					FreeLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+
+					UnlockMutex (GraphicsLock);
+					break; 
+				}
+			}
+
 			if (pSolarSysState->pOrbitalDesc == &pSolarSysState->PlanetDesc[0])
 			{
 				if ((CurStarDescPtr->Index == MYCON_DEFINED
@@ -135,7 +228,8 @@ GenerateMycon (BYTE control)
 					{
 						NotifyOthers (MYCON_SHIP, (BYTE)~0);
 						PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
-						ReinitQueue (&GLOBAL (npc_built_ship_q));
+						ReinitQueue (&GLOBAL (ip_group_q));
+						assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
 
 						if (CurStarDescPtr->Index == MYCON_DEFINED
 								|| !GET_GAME_STATE (MYCON_FELL_FOR_AMBUSH))
diff -ruNp src.orig/sc2code/planets/gennegl.c src/sc2code/planets/gennegl.c
--- src.orig/sc2code/planets/gennegl.c	1969-12-31 18:00:00 -0600
+++ src/sc2code/planets/gennegl.c	2017-11-08 16:50:03 -0600
@@ -0,0 +1,124 @@
+/*
+ *  Copyright (C) 2008  Nicolas Simonds <uqm@submedia.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "build.h"
+#include "encount.h"
+#include "globdata.h"
+#include "lander.h"
+#include "nameref.h"
+#include "resinst.h"
+#include "setup.h"
+#include "state.h"
+#include "sounds.h"
+#include "planets/genall.h"
+#include "libs/mathlib.h"
+
+
+void
+GenerateNeglectedStarbase (BYTE control)
+{
+	COUNT angle;
+
+	switch (control)
+	{
+		case GENERATE_MOONS:
+			GenerateRandomIP (GENERATE_MOONS);
+			if (pSolarSysState->pBaseDesc == &pSolarSysState->PlanetDesc[0])
+			{
+				pSolarSysState->MoonDesc[0].data_index = DESTROYED_STARBASE;
+				pSolarSysState->MoonDesc[0].radius = MIN_MOON_RADIUS;
+				angle = ARCTAN (pSolarSysState->MoonDesc[0].location.x,
+						pSolarSysState->MoonDesc[0].location.y);
+				pSolarSysState->MoonDesc[0].location.x =
+						COSINE (angle, pSolarSysState->MoonDesc[0].radius);
+				pSolarSysState->MoonDesc[0].location.y =
+						SINE (angle, pSolarSysState->MoonDesc[0].radius);
+			}
+			break;
+		case GENERATE_PLANETS:
+			GenerateRandomIP (GENERATE_PLANETS);
+			pSolarSysState->PlanetDesc[0].data_index |= PLANET_SHIELDED;
+			pSolarSysState->PlanetDesc[0].radius = EARTH_RADIUS * 2L;
+			angle = ARCTAN (pSolarSysState->PlanetDesc[0].location.x,
+					pSolarSysState->PlanetDesc[0].location.y);
+			pSolarSysState->PlanetDesc[0].location.x =
+					COSINE (angle, pSolarSysState->PlanetDesc[0].radius);
+			pSolarSysState->PlanetDesc[0].location.y =
+					SINE (angle, pSolarSysState->PlanetDesc[0].radius);
+			pSolarSysState->PlanetDesc[0].NumPlanets = 1;
+			break;
+		case GENERATE_ORBITAL:
+			if (pSolarSysState->pOrbitalDesc == &pSolarSysState->PlanetDesc[0])
+			{
+				DoPlanetaryAnalysis (
+						&pSolarSysState->SysInfo, pSolarSysState->pOrbitalDesc
+						);
+
+				LoadPlanet (NULL);
+				break;
+			}
+				/* Starbase */
+			if (pSolarSysState->pOrbitalDesc->pPrevDesc == &pSolarSysState->PlanetDesc[0]
+					&& pSolarSysState->pOrbitalDesc == &pSolarSysState->MoonDesc[0])
+			{
+				RECT r;
+
+				LockMutex (GraphicsLock);
+
+				LoadStdLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+				pSolarSysState->SysInfo.PlanetInfo.DiscoveryString =
+						CaptureStringTable (
+								LoadStringTable (NEGLECTED_BASE_STRTAB));
+
+				// use alternate text if the player
+				// hasn't freed the Earth starbase yet
+				if (! GET_GAME_STATE (STARBASE_AVAILABLE))
+					pSolarSysState->SysInfo.PlanetInfo.DiscoveryString =
+							SetRelStringTableIndex (
+									pSolarSysState->SysInfo.PlanetInfo.DiscoveryString,
+									1);
+
+				ScanContext = CreateContext ();
+				SetContext (ScanContext);
+				SetContextFGFrame (Screen);
+				r.corner.x = (SIS_ORG_X + SIS_SCREEN_WIDTH) - MAP_WIDTH;
+				r.corner.y = (SIS_ORG_Y + SIS_SCREEN_HEIGHT) - MAP_HEIGHT;
+				r.extent.width = MAP_WIDTH;
+				r.extent.height = MAP_HEIGHT;
+				SetContextClipRect (&r);
+
+				DoDiscoveryReport (MenuSounds);
+
+				SetContext (SpaceContext);
+				DestroyContext (ScanContext);
+				ScanContext = 0;
+
+				DestroyStringTable (ReleaseStringTable (
+						pSolarSysState->SysInfo.PlanetInfo.DiscoveryString
+						));
+				pSolarSysState->SysInfo.PlanetInfo.DiscoveryString = 0;
+				FreeLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+
+				UnlockMutex (GraphicsLock);
+				break;
+			}
+		default:
+			GenerateRandomIP (control);
+			break;
+	}
+}
diff -ruNp src.orig/sc2code/planets/genorz.c src/sc2code/planets/genorz.c
--- src.orig/sc2code/planets/genorz.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/planets/genorz.c	2017-11-08 16:50:03 -0600
@@ -62,10 +62,6 @@ GenerateAndrosynth (BYTE control)
 					{
 						pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
 								&= ~(1L << i);
-							/* so won't get freed in lander.c */
-						CaptureStringTable (GetStringTable (
-								pSolarSysState->SysInfo.PlanetInfo.DiscoveryString
-								));
 						if (!(pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
 								& (1L << (i + 16))))
 						{
@@ -75,9 +71,9 @@ GenerateAndrosynth (BYTE control)
 									|= (1L << (i + 16));
 							if (pSolarSysState->SysInfo.PlanetInfo.DiscoveryString)
 							{
-								PPLANETSIDE_DESC pPSD;
+								PLANETSIDE_DESC *pPSD;
 
-								pPSD = (PPLANETSIDE_DESC)pMenuState->ModuleFrame;
+								pPSD = (PLANETSIDE_DESC*)pMenuState->ModuleFrame;
 								UnbatchGraphics ();
 								DoDiscoveryReport (MenuSounds);
 								BatchGraphics ();
@@ -86,13 +82,6 @@ GenerateAndrosynth (BYTE control)
 										pSolarSysState->SysInfo.PlanetInfo.DiscoveryString,
 										1
 										);
-								if (GetStringTableIndex (
-										pSolarSysState->SysInfo.PlanetInfo.DiscoveryString
-										) == 0)
-										/* so will get freed in lander.c */
-									ReleaseStringTable (
-											pSolarSysState->SysInfo.PlanetInfo.DiscoveryString
-											);
 							}
 						}
 					}
@@ -266,6 +255,21 @@ GenerateOrz (BYTE control)
 			pSolarSysState->CurNode = 0;
 			break;
 		}
+		case GENERATE_MOONS:
+			GenerateRandomIP (GENERATE_MOONS);
+			if (CurStarDescPtr->Index == ORZ_DEFINED &&
+					pSolarSysState->pBaseDesc == &pSolarSysState->PlanetDesc[0])
+			{
+				pSolarSysState->MoonDesc[0].data_index =
+						(ActivateStarShip (ORZ_SHIP, SPHERE_TRACKING)) ?
+						ORZ_STARBASE : DESTROYED_STARBASE;
+				pSolarSysState->MoonDesc[0].radius = MIN_MOON_RADIUS;
+				pSolarSysState->MoonDesc[0].location.x =
+						COSINE (FULL_CIRCLE, pSolarSysState->MoonDesc[0].radius);
+				pSolarSysState->MoonDesc[0].location.y =
+						SINE (FULL_CIRCLE, pSolarSysState->MoonDesc[0].radius);
+			}
+			break;
 		case GENERATE_PLANETS:
 		{
 			COUNT angle;
@@ -275,7 +279,7 @@ GenerateOrz (BYTE control)
 			{
 				pSolarSysState->PlanetDesc[0].data_index = WATER_WORLD;
 				pSolarSysState->PlanetDesc[0].radius = EARTH_RADIUS * 156L / 100;
-				pSolarSysState->PlanetDesc[0].NumPlanets = 0;
+				pSolarSysState->PlanetDesc[0].NumPlanets = 1;
 				angle = ARCTAN (
 						pSolarSysState->PlanetDesc[0].location.x,
 						pSolarSysState->PlanetDesc[0].location.y
@@ -288,6 +292,57 @@ GenerateOrz (BYTE control)
 			break;
 		}
 		case GENERATE_ORBITAL:
+			if ((CurStarDescPtr->Index == ORZ_DEFINED) &&
+					(pSolarSysState->pOrbitalDesc == &pSolarSysState->MoonDesc[0]) &&
+					(pSolarSysState->pOrbitalDesc->pPrevDesc == &pSolarSysState->PlanetDesc[0]))
+			{
+				// If you go to the starbase, move the ship to
+				// the planet instead
+				if (ActivateStarShip (ORZ_SHIP, SPHERE_TRACKING))
+				{
+					pSolarSysState->pOrbitalDesc =
+							&pSolarSysState->PlanetDesc[0];
+					GLOBAL (ShipStamp.origin.x) = SIS_SCREEN_WIDTH >> 1;
+					GLOBAL (ShipStamp.origin.y) = SIS_SCREEN_HEIGHT >> 1;
+				}
+				// ...unless the Kohr-Ah have been through here
+				else
+				{
+					RECT r;
+					LockMutex (GraphicsLock);
+					
+					LoadStdLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+					pSolarSysState->SysInfo.PlanetInfo.DiscoveryString =
+							SetRelStringTableIndex (
+									CaptureStringTable (
+											LoadStringTable (RUINS_STRTAB)), 1);
+
+					ScanContext = CreateContext ();
+					SetContext (ScanContext);
+					SetContextFGFrame (Screen);
+					r.corner.x = (SIS_ORG_X + SIS_SCREEN_WIDTH) - MAP_WIDTH;
+					r.corner.y = (SIS_ORG_Y + SIS_SCREEN_HEIGHT) - MAP_HEIGHT;
+					r.extent.width = MAP_WIDTH;
+					r.extent.height = MAP_HEIGHT;
+					SetContextClipRect (&r);
+
+					DoDiscoveryReport (MenuSounds);
+
+					SetContext (SpaceContext);
+					DestroyContext (ScanContext);
+					ScanContext = 0;
+
+					DestroyStringTable (ReleaseStringTable (
+							pSolarSysState->SysInfo.PlanetInfo.DiscoveryString
+							));
+					pSolarSysState->SysInfo.PlanetInfo.DiscoveryString = 0;
+					FreeLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+
+					UnlockMutex (GraphicsLock);
+					break; 
+				}
+			}
+
 			if ((CurStarDescPtr->Index == ORZ_DEFINED
 					&& pSolarSysState->pOrbitalDesc == &pSolarSysState->PlanetDesc[0])
 					|| (CurStarDescPtr->Index == TAALO_PROTECTOR_DEFINED
@@ -303,7 +358,8 @@ GenerateOrz (BYTE control)
 				{
 					NotifyOthers (ORZ_SHIP, (BYTE)~0);
 					PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
-					ReinitQueue (&GLOBAL (npc_built_ship_q));
+					ReinitQueue (&GLOBAL (ip_group_q));
+					assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
 
 					if (CurStarDescPtr->Index == ORZ_DEFINED)
 					{
diff -ruNp src.orig/sc2code/planets/genpet.c src/sc2code/planets/genpet.c
--- src.orig/sc2code/planets/genpet.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/planets/genpet.c	2017-11-08 16:50:03 -0600
@@ -19,9 +19,11 @@
 #include "build.h"
 #include "encount.h"
 #include "globdata.h"
+#include "lander.h"
 #include "nameref.h"
 #include "resinst.h"
 #include "setup.h"
+#include "sounds.h"
 #include "state.h"
 #include "planets/genall.h"
 #include "libs/mathlib.h"
@@ -35,9 +37,10 @@ ZapToUrquanEncounter (void)
 	if ((hEncounter = AllocEncounter ()) || (hEncounter = GetHeadEncounter ()))
 	{
 		SIZE dx, dy;
-		ENCOUNTERPTR EncounterPtr;
-		HSTARSHIP hStarShip;
-		EXTENDED_SHIP_FRAGMENTPTR TemplatePtr;
+		ENCOUNTER *EncounterPtr;
+		HFLEETINFO hStarShip;
+		FLEET_INFO *TemplatePtr;
+		BRIEF_SHIP_INFO *BSIPtr;
 
 		LockEncounter (hEncounter, &EncounterPtr);
 
@@ -48,27 +51,23 @@ ZapToUrquanEncounter (void)
 		InsertEncounter (hEncounter, GetHeadEncounter ());
 
 		hStarShip = GetStarShipFromIndex (&GLOBAL (avail_race_q), URQUAN_SHIP);
-		TemplatePtr = (EXTENDED_SHIP_FRAGMENTPTR)LockStarShip (
-				&GLOBAL (avail_race_q),
-				hStarShip
-				);
-		EncounterPtr->origin = TemplatePtr->ShipInfo.loc;
-		EncounterPtr->radius = TemplatePtr->ShipInfo.actual_strength;
+		TemplatePtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
+		EncounterPtr->origin = TemplatePtr->loc;
+		EncounterPtr->radius = TemplatePtr->actual_strength;
 		EncounterPtr->SD.Type = URQUAN_SHIP;
 		EncounterPtr->SD.Index = MAKE_BYTE (1, 0) | ONE_SHOT_ENCOUNTER;
-		EncounterPtr->SD.ShipList[0] =
-				((SHIP_FRAGMENTPTR)TemplatePtr)->ShipInfo;
-		EncounterPtr->SD.ShipList[0].var1 = URQUAN_SHIP;
+		BSIPtr = &EncounterPtr->ShipList[0];
+		BSIPtr->race_id = URQUAN_SHIP;
+		BSIPtr->crew_level = TemplatePtr->crew_level;
+		BSIPtr->max_crew = TemplatePtr->max_crew;
+		BSIPtr->max_energy = TemplatePtr->max_energy;
 		EncounterPtr->SD.star_pt.x = 5288;
 		EncounterPtr->SD.star_pt.y = 4892;
 		EncounterPtr->log_x = UNIVERSE_TO_LOGX (EncounterPtr->SD.star_pt.x);
 		EncounterPtr->log_y = UNIVERSE_TO_LOGY (EncounterPtr->SD.star_pt.y);
 		GLOBAL_SIS (log_x) = EncounterPtr->log_x;
 		GLOBAL_SIS (log_y) = EncounterPtr->log_y;
-		UnlockStarShip (
-				&GLOBAL (avail_race_q),
-				hStarShip
-				);
+		UnlockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
 
 		{
 #define LOST_DAYS 15
@@ -102,7 +101,7 @@ ZapToUrquanEncounter (void)
 					- (SIZE)GLOBAL_SIS (FuelOnBoard);
 			DeltaSISGauges (0, dx, 0);
 		}
-		DrawSISMessage (NULL_PTR);
+		DrawSISMessage (NULL);
 		DrawHyperCoords (EncounterPtr->SD.star_pt);
 		UnlockMutex (GraphicsLock);
 
@@ -148,6 +147,21 @@ GenerateTalkingPet (BYTE control)
 			}
 			pSolarSysState->CurNode = 0;
 			break;
+		case GENERATE_MOONS:
+			GenerateRandomIP (GENERATE_MOONS); 
+			if (CurStarDescPtr->Index == UMGAH_DEFINED &&
+					pSolarSysState->pBaseDesc == &pSolarSysState->PlanetDesc[0])
+			{
+				pSolarSysState->MoonDesc[0].data_index =
+						(ActivateStarShip (UMGAH_SHIP, SPHERE_TRACKING)) ?
+						HIERARCHY_STARBASE : DESTROYED_STARBASE;
+				pSolarSysState->MoonDesc[0].radius = MIN_MOON_RADIUS;
+				pSolarSysState->MoonDesc[0].location.x =
+						COSINE (OCTANT >> 1, pSolarSysState->MoonDesc[0].radius);
+				pSolarSysState->MoonDesc[0].location.y =
+						SINE (OCTANT >> 1, pSolarSysState->MoonDesc[0].radius);
+			}
+			break;
 		case GENERATE_PLANETS:
 		{
 			COUNT angle;
@@ -155,6 +169,7 @@ GenerateTalkingPet (BYTE control)
 			GenerateRandomIP (GENERATE_PLANETS);
 			pSolarSysState->PlanetDesc[0].data_index = TELLURIC_WORLD;
 			pSolarSysState->PlanetDesc[0].radius = EARTH_RADIUS * 204L / 100;
+			pSolarSysState->PlanetDesc[0].NumPlanets = 1;
 			angle = ARCTAN (
 					pSolarSysState->PlanetDesc[0].location.x,
 					pSolarSysState->PlanetDesc[0].location.y
@@ -166,6 +181,57 @@ GenerateTalkingPet (BYTE control)
 			break;
 		}
 		case GENERATE_ORBITAL:
+			if ((CurStarDescPtr->Index == UMGAH_DEFINED) &&
+					(pSolarSysState->pOrbitalDesc == &pSolarSysState->MoonDesc[0]) &&
+					(pSolarSysState->pOrbitalDesc->pPrevDesc == &pSolarSysState->PlanetDesc[0]))
+			{
+				// If you go to the starbase, move the ship to
+				// the planet instead
+				if (ActivateStarShip (UMGAH_SHIP, SPHERE_TRACKING))
+				{
+					pSolarSysState->pOrbitalDesc =
+							&pSolarSysState->PlanetDesc[0];
+					GLOBAL (ShipStamp.origin.x) = SIS_SCREEN_WIDTH >> 1;
+					GLOBAL (ShipStamp.origin.y) = SIS_SCREEN_HEIGHT >> 1;
+				}
+				// ...unless they're all dead
+				else
+				{
+					RECT r;
+					LockMutex (GraphicsLock);
+					
+					LoadStdLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+					pSolarSysState->SysInfo.PlanetInfo.DiscoveryString =
+							SetRelStringTableIndex (
+									CaptureStringTable (
+											LoadStringTable (RUINS_STRTAB)), 1);
+
+					ScanContext = CreateContext ();
+					SetContext (ScanContext);
+					SetContextFGFrame (Screen);
+					r.corner.x = (SIS_ORG_X + SIS_SCREEN_WIDTH) - MAP_WIDTH;
+					r.corner.y = (SIS_ORG_Y + SIS_SCREEN_HEIGHT) - MAP_HEIGHT;
+					r.extent.width = MAP_WIDTH;
+					r.extent.height = MAP_HEIGHT;
+					SetContextClipRect (&r);
+
+					DoDiscoveryReport (MenuSounds);
+
+					SetContext (SpaceContext);
+					DestroyContext (ScanContext);
+					ScanContext = 0;
+
+					DestroyStringTable (ReleaseStringTable (
+							pSolarSysState->SysInfo.PlanetInfo.DiscoveryString
+							));
+					pSolarSysState->SysInfo.PlanetInfo.DiscoveryString = 0;
+					FreeLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+
+					UnlockMutex (GraphicsLock);
+					break; 
+				}
+			}
+
 			if (pSolarSysState->pOrbitalDesc == &pSolarSysState->PlanetDesc[0]
 					&& (GET_GAME_STATE (UMGAH_ZOMBIE_BLOBBIES)
 					|| !GET_GAME_STATE (TALKING_PET)
@@ -173,7 +239,8 @@ GenerateTalkingPet (BYTE control)
 			{
 				NotifyOthers (UMGAH_SHIP, (BYTE)~0);
 				PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
-				ReinitQueue (&GLOBAL (npc_built_ship_q));
+				ReinitQueue (&GLOBAL (ip_group_q));
+				assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
 
 				if (ActivateStarShip (UMGAH_SHIP, SPHERE_TRACKING))
 				{
diff -ruNp src.orig/sc2code/planets/genpku.c src/sc2code/planets/genpku.c
--- src.orig/sc2code/planets/genpku.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/planets/genpku.c	2017-11-08 16:50:03 -0600
@@ -22,6 +22,8 @@
 #include "lander.h"
 #include "nameref.h"
 #include "resinst.h"
+#include "setup.h"
+#include "sounds.h"
 #include "state.h"
 #include "planets/genall.h"
 #include "libs/mathlib.h"
@@ -63,7 +65,7 @@ GeneratePkunk (BYTE control)
 
 						if (!GET_GAME_STATE (CLEAR_SPINDLE))
 						{
-							((PPLANETSIDE_DESC)pMenuState->ModuleFrame)->InTransit = TRUE;
+							((PLANETSIDE_DESC*)pMenuState->ModuleFrame)->InTransit = TRUE;
 
 							SET_GAME_STATE (CLEAR_SPINDLE, 1);
 							SET_GAME_STATE (CLEAR_SPINDLE_ON_SHIP, 1);
@@ -82,6 +84,27 @@ GeneratePkunk (BYTE control)
 			}
 			pSolarSysState->CurNode = 0;
 			break;
+		case GENERATE_MOONS:
+			if (CurStarDescPtr->Index == PKUNK_DEFINED &&
+					pSolarSysState->pBaseDesc == &pSolarSysState->PlanetDesc[0])
+			{
+				// Setup moons, then add a starbase as the last moon
+				pSolarSysState->PlanetDesc[0].NumPlanets = 1;
+				GenerateRandomIP (GENERATE_MOONS);
+				pSolarSysState->PlanetDesc[0].NumPlanets = 2;
+
+				pSolarSysState->MoonDesc[1].data_index =
+						(ActivateStarShip (PKUNK_SHIP, SPHERE_TRACKING)) ?
+						PKUNK_STARBASE : DESTROYED_STARBASE;
+				pSolarSysState->MoonDesc[1].radius = MIN_MOON_RADIUS;
+				pSolarSysState->MoonDesc[1].location.x =
+						COSINE (QUADRANT, pSolarSysState->MoonDesc[1].radius);
+				pSolarSysState->MoonDesc[1].location.y =
+						SINE (QUADRANT, pSolarSysState->MoonDesc[1].radius);
+				break;
+			}
+			GenerateRandomIP (GENERATE_MOONS);
+			break;
 		case GENERATE_PLANETS:
 		{
 			COUNT angle;
@@ -101,13 +124,64 @@ GeneratePkunk (BYTE control)
 			break;
 		}
 		case GENERATE_ORBITAL:
+			if ((pSolarSysState->pOrbitalDesc == &pSolarSysState->MoonDesc[1]) &&
+					(pSolarSysState->pOrbitalDesc->pPrevDesc == &pSolarSysState->PlanetDesc[0]))
+			{
+				// If you go to the starbase, move the ship to
+				// the planet instead
+				if (ActivateStarShip (PKUNK_SHIP, SPHERE_TRACKING))
+				{
+					pSolarSysState->pOrbitalDesc =
+							&pSolarSysState->PlanetDesc[0];
+					GLOBAL (ShipStamp.origin.x) = SIS_SCREEN_WIDTH >> 1;
+					GLOBAL (ShipStamp.origin.y) = SIS_SCREEN_HEIGHT >> 1;
+				}
+				// ...unless they're all dead
+				else
+				{
+					RECT r;
+					LockMutex (GraphicsLock);
+					
+					LoadStdLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+					pSolarSysState->SysInfo.PlanetInfo.DiscoveryString =
+							SetRelStringTableIndex (
+									CaptureStringTable (
+											LoadStringTable (RUINS_STRTAB)), 1);
+
+					ScanContext = CreateContext ();
+					SetContext (ScanContext);
+					SetContextFGFrame (Screen);
+					r.corner.x = (SIS_ORG_X + SIS_SCREEN_WIDTH) - MAP_WIDTH;
+					r.corner.y = (SIS_ORG_Y + SIS_SCREEN_HEIGHT) - MAP_HEIGHT;
+					r.extent.width = MAP_WIDTH;
+					r.extent.height = MAP_HEIGHT;
+					SetContextClipRect (&r);
+
+					DoDiscoveryReport (MenuSounds);
+
+					SetContext (SpaceContext);
+					DestroyContext (ScanContext);
+					ScanContext = 0;
+
+					DestroyStringTable (ReleaseStringTable (
+							pSolarSysState->SysInfo.PlanetInfo.DiscoveryString
+							));
+					pSolarSysState->SysInfo.PlanetInfo.DiscoveryString = 0;
+					FreeLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+
+					UnlockMutex (GraphicsLock);
+					break; 
+				}
+			}
+
 			if (pSolarSysState->pOrbitalDesc == &pSolarSysState->PlanetDesc[0])
 			{
 				if (ActivateStarShip (PKUNK_SHIP, SPHERE_TRACKING))
 				{
 					NotifyOthers (PKUNK_SHIP, (BYTE)~0);
 					PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
-					ReinitQueue (&GLOBAL (npc_built_ship_q));
+					ReinitQueue (&GLOBAL (ip_group_q));
+					assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
 
 					CloneShipFragment (PKUNK_SHIP,
 							&GLOBAL (npc_built_ship_q), INFINITE_FLEET);
diff -ruNp src.orig/sc2code/planets/genprecrsr.c src/sc2code/planets/genprecrsr.c
--- src.orig/sc2code/planets/genprecrsr.c	1969-12-31 18:00:00 -0600
+++ src/sc2code/planets/genprecrsr.c	2017-11-08 16:50:03 -0600
@@ -0,0 +1,116 @@
+/*
+ *  Copyright (C) 2008  Nicolas Simonds <uqm@submedia.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "build.h"
+#include "encount.h"
+#include "globdata.h"
+#include "lander.h"
+#include "nameref.h"
+#include "resinst.h"
+#include "setup.h"
+#include "state.h"
+#include "sounds.h"
+#include "planets/genall.h"
+#include "libs/mathlib.h"
+
+/*
+ * Co-opted the definition of Alpha Centauri to draw a Precursor
+ * starbase around the first planet.  So when this GenFunc is called
+ * with INIT_NPCS, it just calls GenerateMelnorme ()
+ */
+
+void
+GeneratePrecursorStarbase (BYTE control)
+{
+	COUNT angle;
+
+	switch (control)
+	{
+		case GENERATE_MOONS:
+			GenerateRandomIP (GENERATE_MOONS);
+			if (pSolarSysState->pBaseDesc == &pSolarSysState->PlanetDesc[0])
+			{
+				pSolarSysState->MoonDesc[0].data_index = PRECURSOR_STARBASE;
+				pSolarSysState->MoonDesc[0].radius = MIN_MOON_RADIUS;
+				angle = ARCTAN (pSolarSysState->MoonDesc[0].location.x,
+						pSolarSysState->MoonDesc[0].location.y);
+				pSolarSysState->MoonDesc[0].location.x =
+						COSINE (angle, pSolarSysState->MoonDesc[0].radius);
+				pSolarSysState->MoonDesc[0].location.y =
+						SINE (angle, pSolarSysState->MoonDesc[0].radius);
+			}
+			break;
+		case GENERATE_PLANETS:
+			GenerateRandomIP (GENERATE_PLANETS);
+			pSolarSysState->PlanetDesc[0].NumPlanets = 1;
+			break;
+		case GENERATE_ORBITAL:
+			if (pSolarSysState->pOrbitalDesc == &pSolarSysState->PlanetDesc[0])
+			{
+				DoPlanetaryAnalysis (
+						&pSolarSysState->SysInfo, pSolarSysState->pOrbitalDesc
+						);
+
+				LoadPlanet (NULL);
+				break;
+			}
+				/* Starbase */
+			if (pSolarSysState->pOrbitalDesc->pPrevDesc == &pSolarSysState->PlanetDesc[0]
+					&& pSolarSysState->pOrbitalDesc == &pSolarSysState->MoonDesc[0])
+			{
+				RECT r;
+
+				LockMutex (GraphicsLock);
+
+				LoadStdLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+				pSolarSysState->SysInfo.PlanetInfo.DiscoveryString =
+						CaptureStringTable (
+								LoadStringTable (PRECURSOR_BASE_STRTAB));
+
+				ScanContext = CreateContext ();
+				SetContext (ScanContext);
+				SetContextFGFrame (Screen);
+				r.corner.x = (SIS_ORG_X + SIS_SCREEN_WIDTH) - MAP_WIDTH;
+				r.corner.y = (SIS_ORG_Y + SIS_SCREEN_HEIGHT) - MAP_HEIGHT;
+				r.extent.width = MAP_WIDTH;
+				r.extent.height = MAP_HEIGHT;
+				SetContextClipRect (&r);
+
+				DoDiscoveryReport (MenuSounds);
+
+				SetContext (SpaceContext);
+				DestroyContext (ScanContext);
+				ScanContext = 0;
+
+				DestroyStringTable (ReleaseStringTable (
+						pSolarSysState->SysInfo.PlanetInfo.DiscoveryString
+						));
+				pSolarSysState->SysInfo.PlanetInfo.DiscoveryString = 0;
+				FreeLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+
+				UnlockMutex (GraphicsLock);
+				break;
+			}
+		case INIT_NPCS:
+			GenerateMelnorme (control);
+			break;
+		default:
+			GenerateRandomIP (control);
+			break;
+	}
+}
diff -ruNp src.orig/sc2code/planets/genrain.c src/sc2code/planets/genrain.c
--- src.orig/sc2code/planets/genrain.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/planets/genrain.c	2017-11-08 16:50:03 -0600
@@ -53,7 +53,7 @@ GenerateRainbow (BYTE control)
 			{
 				BYTE which_rainbow;
 				UWORD rainbow_mask;
-				STAR_DESCPTR SDPtr;
+				STAR_DESC *SDPtr;
 
 				rainbow_mask = MAKE_WORD (
 						GET_GAME_STATE (RAINBOW_WORLD0),
diff -ruNp src.orig/sc2code/planets/gensam.c src/sc2code/planets/gensam.c
--- src.orig/sc2code/planets/gensam.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/planets/gensam.c	2017-11-08 16:50:03 -0600
@@ -22,6 +22,7 @@
 #include "resinst.h"
 #include "races.h"
 #include "state.h"
+#include "grpinfo.h"
 #include "planets/genall.h"
 #include "libs/mathlib.h"
 
@@ -32,7 +33,7 @@ BuildUrquanGuard (void)
 	BYTE ship1, ship2;
 	BYTE b0, b1;
 	POINT org;
-	HSTARSHIP hStarShip, hNextShip;
+	HIPGROUP hGroup, hNextGroup;
 
 	GLOBAL (BattleGroupRef) = GET_GAME_STATE_32 (SAMATRA_GRPOFFS0);
 
@@ -41,6 +42,8 @@ BuildUrquanGuard (void)
 	else
 		ship1 = BLACK_URQUAN_SHIP, ship2 = URQUAN_SHIP;
 
+	assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
+
 	for (b0 = 0; b0 < MAX_SHIPS_PER_SIDE; ++b0)
 		CloneShipFragment (ship1,
 					&GLOBAL (npc_built_ship_q), 0);
@@ -63,67 +66,52 @@ BuildUrquanGuard (void)
 	for (b0 = 1; b0 <= NUM_URQUAN_GUARDS1; ++b0)
 		PutGroupInfo (GLOBAL (BattleGroupRef), (BYTE)(NUM_URQUAN_GUARDS0 + b0));
 
+	ReinitQueue (&GLOBAL (npc_built_ship_q));
+
 	GetGroupInfo (GLOBAL (BattleGroupRef), GROUP_INIT_IP);
 
-	XFormIPLoc (
-			&pSolarSysState->PlanetDesc[4].image.origin,
-			&org,
-			FALSE
-			);
-	hStarShip = GetHeadLink (&GLOBAL (npc_built_ship_q));
+	XFormIPLoc (&pSolarSysState->PlanetDesc[4].image.origin,
+			&org, FALSE);
+	hGroup = GetHeadLink (&GLOBAL (ip_group_q));
 	for (b0 = 0, b1 = 0;
 			b0 < NUM_URQUAN_GUARDS0;
 			++b0, b1 += FULL_CIRCLE / (NUM_URQUAN_GUARDS0 + NUM_URQUAN_GUARDS1))
 	{
-		SHIP_FRAGMENTPTR FragPtr;
+		IP_GROUP *GroupPtr;
 
 		if (b1 % (FULL_CIRCLE / NUM_URQUAN_GUARDS1) == 0)
 			b1 += FULL_CIRCLE / (NUM_URQUAN_GUARDS0 + NUM_URQUAN_GUARDS1);
 
-		FragPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-				&GLOBAL (npc_built_ship_q), hStarShip
-				);
-		hNextShip = _GetSuccLink (FragPtr);
-		SET_GROUP_MISSION (FragPtr, ON_STATION | IGNORE_FLAGSHIP);
-		SET_GROUP_LOC (FragPtr, 0);
-		SET_GROUP_DEST (FragPtr, 4 + 1);
-		SET_ORBIT_LOC (FragPtr,
-				NORMALIZE_FACING (ANGLE_TO_FACING (b1)));
-		FragPtr->ShipInfo.group_counter = 0;
-		FragPtr->ShipInfo.loc.x = org.x
-				+ COSINE (b1, STATION_RADIUS);
-		FragPtr->ShipInfo.loc.y = org.y
-				+ SINE (b1, STATION_RADIUS);
-		UnlockStarShip (
-				&GLOBAL (npc_built_ship_q), hStarShip
-				);
-		hStarShip = hNextShip;
+		GroupPtr = LockIpGroup (&GLOBAL (ip_group_q), hGroup);
+		hNextGroup = _GetSuccLink (GroupPtr);
+		GroupPtr->task = ON_STATION | IGNORE_FLAGSHIP;
+		GroupPtr->sys_loc = 0;
+		GroupPtr->dest_loc = 4 + 1;
+		GroupPtr->orbit_pos = NORMALIZE_FACING (ANGLE_TO_FACING (b1));
+		GroupPtr->group_counter = 0;
+		GroupPtr->loc.x = org.x + COSINE (b1, STATION_RADIUS);
+		GroupPtr->loc.y = org.y + SINE (b1, STATION_RADIUS);
+		UnlockIpGroup (&GLOBAL (ip_group_q), hGroup);
+		hGroup = hNextGroup;
 	}
 
 	for (b0 = 0, b1 = 0;
 			b0 < NUM_URQUAN_GUARDS1;
 			++b0, b1 += FULL_CIRCLE / NUM_URQUAN_GUARDS1)
 	{
-		SHIP_FRAGMENTPTR FragPtr;
+		IP_GROUP *GroupPtr;
 
-		FragPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-				&GLOBAL (npc_built_ship_q), hStarShip
-				);
-		hNextShip = _GetSuccLink (FragPtr);
-		SET_GROUP_MISSION (FragPtr, ON_STATION | IGNORE_FLAGSHIP);
-		SET_GROUP_LOC (FragPtr, 0);
-		SET_GROUP_DEST (FragPtr, 4 + 1);
-		SET_ORBIT_LOC (FragPtr,
-				NORMALIZE_FACING (ANGLE_TO_FACING (b1)));
-		FragPtr->ShipInfo.group_counter = 0;
-		FragPtr->ShipInfo.loc.x = org.x
-				+ COSINE (b1, STATION_RADIUS);
-		FragPtr->ShipInfo.loc.y = org.y
-				+ SINE (b1, STATION_RADIUS);
-		UnlockStarShip (
-				&GLOBAL (npc_built_ship_q), hStarShip
-				);
-		hStarShip = hNextShip;
+		GroupPtr = LockIpGroup (&GLOBAL (ip_group_q), hGroup);
+		hNextGroup = _GetSuccLink (GroupPtr);
+		GroupPtr->task = ON_STATION | IGNORE_FLAGSHIP;
+		GroupPtr->sys_loc = 0;
+		GroupPtr->dest_loc = 4 + 1;
+		GroupPtr->orbit_pos = NORMALIZE_FACING (ANGLE_TO_FACING (b1));
+		GroupPtr->group_counter = 0;
+		GroupPtr->loc.x = org.x + COSINE (b1, STATION_RADIUS);
+		GroupPtr->loc.y = org.y + SINE (b1, STATION_RADIUS);
+		UnlockIpGroup (&GLOBAL (ip_group_q), hGroup);
+		hGroup = hNextGroup;
 	}
 }
 
@@ -146,39 +134,32 @@ GenerateSamatra (BYTE control)
 			EncounterRace = -1; // Do not want guards to chase the player
 			{
 				BOOLEAN GuardEngaged;
-				HSTARSHIP hStarShip, hNextShip;
+				HIPGROUP hGroup, hNextGroup;
 
 				GuardEngaged = FALSE;
-				for (hStarShip = GetHeadLink (&GLOBAL (npc_built_ship_q));
-						hStarShip; hStarShip = hNextShip)
+				for (hGroup = GetHeadLink (&GLOBAL (ip_group_q));
+						hGroup; hGroup = hNextGroup)
 				{
-					BYTE task;
-					SHIP_FRAGMENTPTR FragPtr;
+					IP_GROUP *GroupPtr;
 
-					FragPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-							&GLOBAL (npc_built_ship_q), hStarShip
-							);
-					hNextShip = _GetSuccLink (FragPtr);
+					GroupPtr = LockIpGroup (&GLOBAL (ip_group_q), hGroup);
+					hNextGroup = _GetSuccLink (GroupPtr);
 
-					task = GET_GROUP_MISSION (FragPtr);
 					if (GET_GAME_STATE (URQUAN_MESSED_UP))
 					{
-						SET_GROUP_MISSION (FragPtr,
-								FLEE | IGNORE_FLAGSHIP | (task & REFORM_GROUP));
-						SET_GROUP_DEST (FragPtr, 0);
+						GroupPtr->task &= REFORM_GROUP;
+						GroupPtr->task |= FLEE | IGNORE_FLAGSHIP;
+						GroupPtr->dest_loc = 0;
 					}
-					else if (task & REFORM_GROUP)
+					else if (GroupPtr->task & REFORM_GROUP)
 					{
-						task &= ~REFORM_GROUP;
-						FragPtr->ShipInfo.group_counter = 0;
-						SET_GROUP_MISSION (FragPtr, task);
+						GroupPtr->task &= ~REFORM_GROUP;
+						GroupPtr->group_counter = 0;
 
 						GuardEngaged = TRUE;
 					}
 
-					UnlockStarShip (
-							&GLOBAL (npc_built_ship_q), hStarShip
-							);
+					UnlockIpGroup (&GLOBAL (ip_group_q), hGroup);
 				}
 
 				if (GuardEngaged)
@@ -188,22 +169,13 @@ GenerateSamatra (BYTE control)
 
 					XFormIPLoc (
 							&pSolarSysState->PlanetDesc[4].image.origin,
-							&org,
-							FALSE
-							);
-					angle = ARCTAN (
-							GLOBAL (ip_location.x) - org.x,
-							GLOBAL (ip_location.y) - org.y
-							);
-					GLOBAL (ip_location.x) = org.x
-							+ COSINE (angle, 3000);
-					GLOBAL (ip_location.y) = org.y
-							+ SINE (angle, 3000);
-					XFormIPLoc (
-							&GLOBAL (ip_location),
-							&GLOBAL (ShipStamp.origin),
-							TRUE
-							);
+							&org, FALSE);
+					angle = ARCTAN (GLOBAL (ip_location.x) - org.x,
+							GLOBAL (ip_location.y) - org.y);
+					GLOBAL (ip_location.x) = org.x + COSINE (angle, 3000);
+					GLOBAL (ip_location.y) = org.y + SINE (angle, 3000);
+					XFormIPLoc (&GLOBAL (ip_location),
+							&GLOBAL (ShipStamp.origin), TRUE);
 				}
 			}
 			break;
@@ -214,7 +186,7 @@ GenerateSamatra (BYTE control)
 				COUNT angle;
 				DWORD rand_val;
 
-				pSolarSysState->MoonDesc[0].data_index = (BYTE)(~0 - 1);
+				pSolarSysState->MoonDesc[0].data_index = SA_MATRA;
 				pSolarSysState->MoonDesc[0].radius = MIN_MOON_RADIUS
 						+ (2 * MOON_DELTA);
 				rand_val = TFB_Random ();
@@ -235,7 +207,8 @@ GenerateSamatra (BYTE control)
 					&& pSolarSysState->pOrbitalDesc == &pSolarSysState->MoonDesc[0])
 			{
 				PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
-				ReinitQueue (&GLOBAL (npc_built_ship_q));
+				ReinitQueue (&GLOBAL (ip_group_q));
+				assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
 
 				if (!GET_GAME_STATE (URQUAN_MESSED_UP))
 					CloneShipFragment (!GET_GAME_STATE (KOHR_AH_FRENZY) ?
diff -ruNp src.orig/sc2code/planets/genshof.c src/sc2code/planets/genshof.c
--- src.orig/sc2code/planets/genshof.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/planets/genshof.c	2017-11-08 16:50:03 -0600
@@ -19,30 +19,28 @@
 #include "build.h"
 #include "globdata.h"
 #include "state.h"
+#include "grpinfo.h"
 #include "planets/genall.h"
 
 
 static void
 check_old_shofixti (void)
 {
-	HSTARSHIP hStarShip;
+	HIPGROUP hGroup;
 
 	if (GLOBAL (BattleGroupRef)
-			&& (hStarShip = GetHeadLink (&GLOBAL (npc_built_ship_q)))
+			&& (hGroup = GetHeadLink (&GLOBAL (ip_group_q)))
 			&& GET_GAME_STATE (SHOFIXTI_RECRUITED))
 	{
-		BYTE task;
-		SHIP_FRAGMENTPTR FragPtr;
+		IP_GROUP *GroupPtr;
 
-		FragPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-				&GLOBAL (npc_built_ship_q), hStarShip);
-		task = GET_GROUP_MISSION (FragPtr);
-
-		SET_GROUP_MISSION (FragPtr,
-				FLEE | IGNORE_FLAGSHIP | (task & REFORM_GROUP));
-		SET_GROUP_DEST (FragPtr, 0);
+		GroupPtr = LockIpGroup (&GLOBAL (ip_group_q), hGroup);
 
-		UnlockStarShip (&GLOBAL (npc_built_ship_q), hStarShip);
+		GroupPtr->task &= REFORM_GROUP;
+		GroupPtr->task |= FLEE | IGNORE_FLAGSHIP;
+		GroupPtr->dest_loc = 0;
+
+		UnlockIpGroup (&GLOBAL (ip_group_q), hGroup);
 	}
 }
 
@@ -61,14 +59,27 @@ GenerateShofixti (BYTE control)
 			if (GLOBAL (BattleGroupRef) == 0
 					|| !GetGroupInfo (GLOBAL (BattleGroupRef), GROUP_INIT_IP))
 			{
+				HSHIPFRAG hStarShip;
+
 				if (GLOBAL (BattleGroupRef) == 0)
 					GLOBAL (BattleGroupRef) = ~0L;
 
-				CloneShipFragment (SHOFIXTI_SHIP,
+				hStarShip = CloneShipFragment (SHOFIXTI_SHIP,
 						&GLOBAL (npc_built_ship_q), 1);
+				if (hStarShip)
+				{	/* Set old Shofixti name; his brother if Tanaka died */
+					SHIP_FRAGMENT *FragPtr = LockShipFrag (
+							&GLOBAL (npc_built_ship_q), hStarShip);
+					/* Name Tanaka or Katana (+1) */
+					FragPtr->captains_name_index = NAME_OFFSET +
+							NUM_CAPTAINS_NAMES +
+							(GET_GAME_STATE (SHOFIXTI_KIA) & 1);
+					UnlockShipFrag (&GLOBAL (npc_built_ship_q), hStarShip);
+				}
 
 				GLOBAL (BattleGroupRef) = PutGroupInfo (
 						GLOBAL (BattleGroupRef), 1);
+				ReinitQueue (&GLOBAL (npc_built_ship_q));
 				SET_GAME_STATE_32 (SHOFIXTI_GRPOFFS0,
 						GLOBAL (BattleGroupRef));
 			}
@@ -80,7 +91,7 @@ GenerateShofixti (BYTE control)
 		case UNINIT_NPCS:
 			if (GLOBAL (BattleGroupRef)
 					&& !GET_GAME_STATE (SHOFIXTI_RECRUITED)
-					&& GetHeadLink (&GLOBAL (npc_built_ship_q)) == 0)
+					&& GetHeadLink (&GLOBAL (ip_group_q)) == 0)
 			{
 				if (!GET_GAME_STATE (SHOFIXTI_KIA))
 				{
@@ -97,7 +108,7 @@ GenerateShofixti (BYTE control)
 		case GENERATE_PLANETS:
 		{
 			COUNT i;
-			PPLANET_DESC pCurDesc;
+			PLANET_DESC *pCurDesc;
 
 #define NUM_PLANETS 6
 			pSolarSysState->SunDesc[0].NumPlanets = NUM_PLANETS;
diff -ruNp src.orig/sc2code/planets/gensol.c src/sc2code/planets/gensol.c
--- src.orig/sc2code/planets/gensol.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/planets/gensol.c	2017-11-08 16:50:03 -0600
@@ -25,6 +25,7 @@
 #include "races.h"
 #include "resinst.h"
 #include "state.h"
+#include "grpinfo.h"
 #include "encount.h"
 #include "planets/genall.h"
 #include "libs/mathlib.h"
@@ -33,22 +34,22 @@
 static int
 init_probe (void)
 {
-	HSTARSHIP hStarShip;
+	HIPGROUP hGroup;
 
 	if (!GET_GAME_STATE (PROBE_MESSAGE_DELIVERED)
 			&& GetGroupInfo (GLOBAL (BattleGroupRef), GROUP_INIT_IP)
-			&& (hStarShip = GetHeadLink (&GLOBAL (npc_built_ship_q))))
+			&& (hGroup = GetHeadLink (&GLOBAL (ip_group_q))))
 	{
-		SHIP_FRAGMENTPTR FragPtr;
+		IP_GROUP *GroupPtr;
 
-		FragPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-				&GLOBAL (npc_built_ship_q), hStarShip);
-		SET_GROUP_MISSION (FragPtr, IN_ORBIT);
-		SET_GROUP_LOC (FragPtr, 2 + 1); /* orbitting earth */
-		SET_GROUP_DEST (FragPtr, 2 + 1); /* orbitting earth */
-		FragPtr->ShipInfo.loc.x = FragPtr->ShipInfo.loc.y = 0;
-		FragPtr->ShipInfo.group_counter = 0;
-		UnlockStarShip (&GLOBAL (npc_built_ship_q), hStarShip);
+		GroupPtr = LockIpGroup (&GLOBAL (ip_group_q), hGroup);
+		GroupPtr->task = IN_ORBIT;
+		GroupPtr->sys_loc = 2 + 1; /* orbitting earth */
+		GroupPtr->dest_loc = 2 + 1; /* orbitting earth */
+		GroupPtr->loc.x = 0;
+		GroupPtr->loc.y = 0;
+		GroupPtr->group_counter = 0;
+		UnlockIpGroup (&GLOBAL (ip_group_q), hGroup);
 
 		return 1;
 	}
@@ -74,7 +75,7 @@ generate_energy_nodes (void)
 				SET_GAME_STATE (FOUND_PLUTO_SPATHI, 1);
 				pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
 						&= ~(1L << 0);
-				((PPLANETSIDE_DESC)pMenuState->ModuleFrame)->InTransit = TRUE;
+				((PLANETSIDE_DESC*)pMenuState->ModuleFrame)->InTransit = TRUE;
 			}
 			else if (pSolarSysState->CurNode == (COUNT)~0)
 				pSolarSysState->CurNode = 1;
@@ -154,7 +155,8 @@ generate_orbital (void)
 			&& pSolarSysState->pOrbitalDesc == &pSolarSysState->MoonDesc[0])
 	{
 		PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
-		ReinitQueue (&GLOBAL (npc_built_ship_q));
+		ReinitQueue (&GLOBAL (ip_group_q));
+		assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
 
 		EncounterGroup = 0;
 		GLOBAL (CurrentActivity) |= START_ENCOUNTER;
@@ -402,7 +404,7 @@ GenerateSOL (BYTE control)
 {
 	COUNT i;
 	DWORD rand_val;
-	PPLANET_DESC pCurDesc;
+	PLANET_DESC *pCurDesc;
 
 	switch (control)
 	{
@@ -413,8 +415,8 @@ GenerateSOL (BYTE control)
 			{
 				CloneShipFragment (URQUAN_PROBE_SHIP,
 						&GLOBAL (npc_built_ship_q), 0);
-
 				GLOBAL (BattleGroupRef) = PutGroupInfo (GROUPS_ADD_NEW, 1);
+				ReinitQueue (&GLOBAL (npc_built_ship_q));
 				SET_GAME_STATE_32 (URQUAN_PROBE_GRPOFFS0,
 						GLOBAL (BattleGroupRef));
 			}
@@ -427,7 +429,8 @@ GenerateSOL (BYTE control)
 			else
 			{
 				GLOBAL (BattleGroupRef) = 0;
-				ReinitQueue (&GLOBAL (npc_built_ship_q));
+				ReinitQueue (&GLOBAL (ip_group_q));
+				assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
 			}
 			break;
 		case GENERATE_ENERGY:
@@ -459,7 +462,7 @@ GenerateSOL (BYTE control)
 					COUNT angle;
 
 					/* Starbase: */
-					pSolarSysState->MoonDesc[0].data_index = (BYTE)~0;
+					pSolarSysState->MoonDesc[0].data_index = HIERARCHY_STARBASE;
 					pSolarSysState->MoonDesc[0].radius = MIN_MOON_RADIUS;
 					angle = HALF_CIRCLE + QUADRANT;
 					pSolarSysState->MoonDesc[0].location.x =
diff -ruNp src.orig/sc2code/planets/genspa.c src/sc2code/planets/genspa.c
--- src.orig/sc2code/planets/genspa.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/planets/genspa.c	2017-11-08 16:50:03 -0600
@@ -22,6 +22,7 @@
 #include "lifeform.h"
 #include "nameref.h"
 #include "resinst.h"
+#include "setup.h"
 #include "state.h"
 #include "planets/genall.h"
 #include "libs/mathlib.h"
@@ -73,6 +74,7 @@ GenerateSpathi (BYTE control)
 			pSolarSysState->CurNode = 0;
 			break;
 		case GENERATE_MOONS:
+			pSolarSysState->PlanetDesc[0].NumPlanets = 1;
 			GenerateRandomIP (GENERATE_MOONS);
 			if (pSolarSysState->pBaseDesc == &pSolarSysState->PlanetDesc[0])
 			{
@@ -90,10 +92,27 @@ GenerateSpathi (BYTE control)
 				pSolarSysState->MoonDesc[0].location.y =
 						SINE (angle, pSolarSysState->MoonDesc[0].radius);
 			}
+			/* "Ur-Quan slave law requires that we maintain an orbital
+			 *  space platform to assist Hierarchy vessels which are in
+			 *  need of repairs or fuel"
+			 */
+			if (!GET_GAME_STATE (SPATHI_SHIELDED_SELVES))
+			{
+				pSolarSysState->PlanetDesc[0].NumPlanets = 2;
+				pSolarSysState->MoonDesc[1].data_index = HIERARCHY_STARBASE;
+				pSolarSysState->MoonDesc[1].radius =
+						pSolarSysState->MoonDesc[0].radius;
+				pSolarSysState->MoonDesc[1].location.x =
+						COSINE (angle - (OCTANT >> 1),
+						pSolarSysState->MoonDesc[1].radius);
+				pSolarSysState->MoonDesc[1].location.y =
+						SINE (angle - (OCTANT >> 1),
+						pSolarSysState->MoonDesc[1].radius);
+			}
 			break;
 		case GENERATE_PLANETS:
 		{
-			PPLANET_DESC pMinPlanet;
+			PLANET_DESC *pMinPlanet;
 
 			pMinPlanet = &pSolarSysState->PlanetDesc[0];
 			FillOrbits (pSolarSysState,
@@ -153,6 +172,17 @@ GenerateSpathi (BYTE control)
 			break;
 		case GENERATE_ORBITAL:
 			if (pSolarSysState->pOrbitalDesc->pPrevDesc == &pSolarSysState->PlanetDesc[0]
+					&& pSolarSysState->pOrbitalDesc == &pSolarSysState->MoonDesc[1])
+			{
+				// If you go to the starbase, move the ship to
+				// the moon instead
+				pSolarSysState->pOrbitalDesc = &pSolarSysState->MoonDesc[0];
+				GLOBAL (ShipStamp.origin.x) = (SIS_SCREEN_WIDTH >> 1) +
+						pSolarSysState->MoonDesc[0].location.x;
+				GLOBAL (ShipStamp.origin.y) = (SIS_SCREEN_HEIGHT >> 1) +
+						(pSolarSysState->MoonDesc[0].location.y >> 1);
+			}
+			if (pSolarSysState->pOrbitalDesc->pPrevDesc == &pSolarSysState->PlanetDesc[0]
 					&& pSolarSysState->pOrbitalDesc == &pSolarSysState->MoonDesc[0])
 			{
 				if (!GET_GAME_STATE (SPATHI_SHIELDED_SELVES)
@@ -160,7 +190,8 @@ GenerateSpathi (BYTE control)
 				{
 					NotifyOthers (SPATHI_SHIP, (BYTE)~0);
 					PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
-					ReinitQueue (&GLOBAL (npc_built_ship_q));
+					ReinitQueue (&GLOBAL (ip_group_q));
+					assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
 
 					CloneShipFragment (SPATHI_SHIP,
 							&GLOBAL (npc_built_ship_q), INFINITE_FLEET);
diff -ruNp src.orig/sc2code/planets/gensup.c src/sc2code/planets/gensup.c
--- src.orig/sc2code/planets/gensup.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/planets/gensup.c	2017-11-08 16:50:03 -0600
@@ -22,6 +22,8 @@
 #include "lander.h"
 #include "nameref.h"
 #include "resinst.h"
+#include "setup.h"
+#include "sounds.h"
 #include "state.h"
 #include "planets/genall.h"
 #include "libs/mathlib.h"
@@ -62,7 +64,7 @@ GenerateSupox (BYTE control)
 
 						if (!GET_GAME_STATE (ULTRON_CONDITION))
 						{
-							((PPLANETSIDE_DESC)pMenuState->ModuleFrame)->InTransit = TRUE;
+							((PLANETSIDE_DESC*)pMenuState->ModuleFrame)->InTransit = TRUE;
 
 							SET_GAME_STATE (ULTRON_CONDITION, 1);
 						}
@@ -80,6 +82,45 @@ GenerateSupox (BYTE control)
 			}
 			pSolarSysState->CurNode = 0;
 			break;
+		case GENERATE_MOONS:
+			if (CurStarDescPtr->Index == SUPOX_DEFINED &&
+					pSolarSysState->pBaseDesc == &pSolarSysState->PlanetDesc[0])            {
+				COUNT angle;
+
+				// Setup moons, then add a starbase as the last moon
+				pSolarSysState->PlanetDesc[0].NumPlanets = 2;
+				GenerateRandomIP (GENERATE_MOONS);
+				pSolarSysState->PlanetDesc[0].NumPlanets = 3;
+
+				pSolarSysState->MoonDesc[2].data_index =
+						(ActivateStarShip (SUPOX_SHIP, SPHERE_TRACKING)) ?
+						SUPOX_STARBASE : DESTROYED_STARBASE;
+				angle = HALF_CIRCLE + OCTANT;
+				pSolarSysState->MoonDesc[2].radius = MIN_MOON_RADIUS;
+				pSolarSysState->MoonDesc[2].location.x =
+						COSINE (angle, pSolarSysState->MoonDesc[2].radius);
+				pSolarSysState->MoonDesc[2].location.y =
+						SINE (angle, pSolarSysState->MoonDesc[2].radius);
+
+				// adjust the positions of the other moons outward
+				pSolarSysState->MoonDesc[0].radius += MOON_DELTA;
+				angle = ARCTAN (pSolarSysState->MoonDesc[0].location.x,
+						pSolarSysState->MoonDesc[0].location.y);
+				pSolarSysState->MoonDesc[0].location.x =
+						COSINE (angle, pSolarSysState->MoonDesc[0].radius);
+				pSolarSysState->MoonDesc[0].location.y =
+						SINE (angle, pSolarSysState->MoonDesc[0].radius);
+				pSolarSysState->MoonDesc[1].radius += MOON_DELTA;
+				angle = ARCTAN (pSolarSysState->MoonDesc[1].location.x,
+						pSolarSysState->MoonDesc[1].location.y);
+				pSolarSysState->MoonDesc[1].location.x =
+						COSINE (angle, pSolarSysState->MoonDesc[1].radius);
+				pSolarSysState->MoonDesc[1].location.y =
+						SINE (angle, pSolarSysState->MoonDesc[1].radius);
+				break;
+			}
+			GenerateRandomIP (GENERATE_MOONS);
+			break;
 		case GENERATE_PLANETS:
 		{
 			COUNT angle;
@@ -99,13 +140,64 @@ GenerateSupox (BYTE control)
 			break;
 		}
 		case GENERATE_ORBITAL:
+			if ((CurStarDescPtr->Index == SUPOX_DEFINED) &&
+					(pSolarSysState->pOrbitalDesc == &pSolarSysState->MoonDesc[2]) &&
+					(pSolarSysState->pOrbitalDesc->pPrevDesc == &pSolarSysState->PlanetDesc[0]))
+			{
+				// If you go to the starbase, move the ship to
+				// the planet instead
+				if (ActivateStarShip (SUPOX_SHIP, SPHERE_TRACKING))
+				{
+					pSolarSysState->pOrbitalDesc =
+							&pSolarSysState->PlanetDesc[0];
+					GLOBAL (ShipStamp.origin.x) = SIS_SCREEN_WIDTH >> 1;
+					GLOBAL (ShipStamp.origin.y) = SIS_SCREEN_HEIGHT >> 1;
+				}
+				// ...unless they're all dead
+				else
+				{
+					RECT r;
+					LockMutex (GraphicsLock);
+					
+					LoadStdLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+					pSolarSysState->SysInfo.PlanetInfo.DiscoveryString =
+							SetRelStringTableIndex (
+									CaptureStringTable (
+											LoadStringTable (RUINS_STRTAB)), 1);
+					ScanContext = CreateContext ();
+					SetContext (ScanContext);
+					SetContextFGFrame (Screen);
+					r.corner.x = (SIS_ORG_X + SIS_SCREEN_WIDTH) - MAP_WIDTH;
+					r.corner.y = (SIS_ORG_Y + SIS_SCREEN_HEIGHT) - MAP_HEIGHT;
+					r.extent.width = MAP_WIDTH;
+					r.extent.height = MAP_HEIGHT;
+					SetContextClipRect (&r);
+
+					DoDiscoveryReport (MenuSounds);
+
+					SetContext (SpaceContext);
+					DestroyContext (ScanContext);
+					ScanContext = 0;
+
+					DestroyStringTable (ReleaseStringTable (
+							pSolarSysState->SysInfo.PlanetInfo.DiscoveryString
+							));
+					pSolarSysState->SysInfo.PlanetInfo.DiscoveryString = 0;
+					FreeLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+
+					UnlockMutex (GraphicsLock);
+					break; 
+				}
+			}
+
 			if (pSolarSysState->pOrbitalDesc == &pSolarSysState->PlanetDesc[0])
 			{
 				if (ActivateStarShip (SUPOX_SHIP, SPHERE_TRACKING))
 				{
 					NotifyOthers (SUPOX_SHIP, (BYTE)~0);
 					PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
-					ReinitQueue (&GLOBAL (npc_built_ship_q));
+					ReinitQueue (&GLOBAL (ip_group_q));
+					assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
 
 					CloneShipFragment (SUPOX_SHIP,
 							&GLOBAL (npc_built_ship_q), INFINITE_FLEET);
diff -ruNp src.orig/sc2code/planets/gensyr.c src/sc2code/planets/gensyr.c
--- src.orig/sc2code/planets/gensyr.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/planets/gensyr.c	2017-11-08 16:50:03 -0600
@@ -75,7 +75,7 @@ GenerateSyreen (BYTE control)
 			GenerateRandomIP (GENERATE_MOONS);
 			if (pSolarSysState->pBaseDesc == &pSolarSysState->PlanetDesc[0])
 			{
-				pSolarSysState->MoonDesc[0].data_index = (BYTE)~0;
+				pSolarSysState->MoonDesc[0].data_index = HIERARCHY_STARBASE;
 				pSolarSysState->MoonDesc[0].radius = MIN_MOON_RADIUS;
 				pSolarSysState->MoonDesc[0].location.x =
 						COSINE (QUADRANT, pSolarSysState->MoonDesc[0].radius);
diff -ruNp src.orig/sc2code/planets/genthrad.c src/sc2code/planets/genthrad.c
--- src.orig/sc2code/planets/genthrad.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/planets/genthrad.c	2017-11-08 16:50:03 -0600
@@ -19,10 +19,12 @@
 #include "build.h"
 #include "encount.h"
 #include "globdata.h"
+#include "lander.h"
 #include "nameref.h"
 #include "resinst.h"
 #include "setup.h"
 #include "state.h"
+#include "sounds.h"
 #include "planets/genall.h"
 #include "libs/mathlib.h"
 
@@ -102,6 +104,23 @@ GenerateThradd (BYTE control)
 			}
 			pSolarSysState->CurNode = 0;
 			break;
+		case GENERATE_MOONS:
+			GenerateRandomIP (GENERATE_MOONS);
+			if (CurStarDescPtr->Index == THRADD_DEFINED &&
+					pSolarSysState->pBaseDesc == &pSolarSysState->PlanetDesc[0])
+			{
+				pSolarSysState->MoonDesc[0].data_index =
+						(ActivateStarShip (THRADDASH_SHIP, SPHERE_TRACKING)) ?
+						HIERARCHY_STARBASE : DESTROYED_STARBASE;
+				pSolarSysState->MoonDesc[0].radius = MIN_MOON_RADIUS;
+				pSolarSysState->MoonDesc[0].location.x =
+						COSINE (HALF_CIRCLE + OCTANT,
+						pSolarSysState->MoonDesc[0].radius);
+				pSolarSysState->MoonDesc[0].location.y =
+						SINE (HALF_CIRCLE + OCTANT,
+						pSolarSysState->MoonDesc[0].radius);
+			}
+			break;
 		case GENERATE_PLANETS:
 		{
 			COUNT angle;
@@ -123,7 +142,7 @@ GenerateThradd (BYTE control)
 			else
 			{
 				pSolarSysState->PlanetDesc[0].data_index = WATER_WORLD;
-				pSolarSysState->PlanetDesc[0].NumPlanets = 0;
+				pSolarSysState->PlanetDesc[0].NumPlanets = 1;
 				pSolarSysState->PlanetDesc[0].radius = EARTH_RADIUS * 98L / 100;
 				angle = ARCTAN (
 						pSolarSysState->PlanetDesc[0].location.x,
@@ -137,6 +156,57 @@ GenerateThradd (BYTE control)
 			break;
 		}
 		case GENERATE_ORBITAL:
+			if ((CurStarDescPtr->Index == THRADD_DEFINED) &&
+					(pSolarSysState->pOrbitalDesc == &pSolarSysState->MoonDesc[0]) &&
+					(pSolarSysState->pOrbitalDesc->pPrevDesc == &pSolarSysState->PlanetDesc[0]))
+			{
+				// If you go to the starbase, move the ship to
+				// the planet instead
+				if (ActivateStarShip (THRADDASH_SHIP, SPHERE_TRACKING))
+				{
+					pSolarSysState->pOrbitalDesc =
+							&pSolarSysState->PlanetDesc[0];
+					GLOBAL (ShipStamp.origin.x) = SIS_SCREEN_WIDTH >> 1;
+					GLOBAL (ShipStamp.origin.y) = SIS_SCREEN_HEIGHT >> 1;
+				}
+				// ...unless the Ilwrath or Kohr-Ah have been through here
+				else
+				{
+					RECT r;
+					LockMutex (GraphicsLock);
+					
+					LoadStdLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+					pSolarSysState->SysInfo.PlanetInfo.DiscoveryString =
+							SetRelStringTableIndex (
+									CaptureStringTable (
+											LoadStringTable (RUINS_STRTAB)), 1);
+
+					ScanContext = CreateContext ();
+					SetContext (ScanContext);
+					SetContextFGFrame (Screen);
+					r.corner.x = (SIS_ORG_X + SIS_SCREEN_WIDTH) - MAP_WIDTH;
+					r.corner.y = (SIS_ORG_Y + SIS_SCREEN_HEIGHT) - MAP_HEIGHT;
+					r.extent.width = MAP_WIDTH;
+					r.extent.height = MAP_HEIGHT;
+					SetContextClipRect (&r);
+
+					DoDiscoveryReport (MenuSounds);
+
+					SetContext (SpaceContext);
+					DestroyContext (ScanContext);
+					ScanContext = 0;
+
+					DestroyStringTable (ReleaseStringTable (
+							pSolarSysState->SysInfo.PlanetInfo.DiscoveryString
+							));
+					pSolarSysState->SysInfo.PlanetInfo.DiscoveryString = 0;
+					FreeLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+
+					UnlockMutex (GraphicsLock);
+					break; 
+				}
+			}
+
 			if (pSolarSysState->pOrbitalDesc == &pSolarSysState->PlanetDesc[0])
 			{
 				if (ActivateStarShip (THRADDASH_SHIP, SPHERE_TRACKING)
@@ -146,7 +216,8 @@ GenerateThradd (BYTE control)
 				{
 					NotifyOthers (THRADDASH_SHIP, (BYTE)~0);
 					PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
-					ReinitQueue (&GLOBAL (npc_built_ship_q));
+					ReinitQueue (&GLOBAL (ip_group_q));
+					assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
 
 					CloneShipFragment (THRADDASH_SHIP,
 							&GLOBAL (npc_built_ship_q), INFINITE_FLEET);
diff -ruNp src.orig/sc2code/planets/gentopo.c src/sc2code/planets/gentopo.c
--- src.orig/sc2code/planets/gentopo.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/planets/gentopo.c	2017-11-08 16:50:03 -0600
@@ -23,7 +23,7 @@
 #include "planets.h"
 
 void
-DeltaTopography (COUNT num_iterations, PSBYTE DepthArray, PRECT pRect,
+DeltaTopography (COUNT num_iterations, SBYTE *DepthArray, RECT *pRect,
 		SIZE depth_delta)
 {
 	SIZE width, height, delta_y;
@@ -41,7 +41,7 @@ DeltaTopography (COUNT num_iterations, P
 		SIZE d;
 		COUNT h, w1, w2;
 		DWORD rand_val;
-		PSBYTE lpDst;
+		SBYTE *lpDst;
 
 		depth_delta = ((((SIZE)TFB_Random () & 1) << 1) - 1) * depth_delta;
 
diff -ruNp src.orig/sc2code/planets/genurq.c src/sc2code/planets/genurq.c
--- src.orig/sc2code/planets/genurq.c	1969-12-31 18:00:00 -0600
+++ src/sc2code/planets/genurq.c	2017-11-08 16:50:03 -0600
@@ -0,0 +1,128 @@
+/*
+ *  Copyright (C) 2008  Nicolas Simonds <uqm@submedia.net>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "build.h"
+#include "encount.h"
+#include "globdata.h"
+#include "lander.h"
+#include "nameref.h"
+#include "resinst.h"
+#include "setup.h"
+#include "state.h"
+#include "sounds.h"
+#include "planets/genall.h"
+#include "libs/mathlib.h"
+
+static void
+generate_doctrinal_space_junk (BYTE control, int index)
+{
+	COUNT angle, p;
+
+	if (control != GENERATE_ORBITAL)
+		GenerateRandomIP (control);
+
+	// Look for a planet with no moons, to put a destroyed starbase there
+	for (p = 0; p < pSolarSysState->SunDesc[0].NumPlanets; p++)
+	{
+		if (pSolarSysState->PlanetDesc[p].NumPlanets <= 1)
+			break;
+	}
+
+	switch (control)
+	{
+		case GENERATE_MOONS:
+			if (pSolarSysState->pBaseDesc == &pSolarSysState->PlanetDesc[p])
+			{
+				pSolarSysState->MoonDesc[0].data_index = DESTROYED_STARBASE;
+				pSolarSysState->MoonDesc[0].radius = MIN_MOON_RADIUS;
+				angle = ARCTAN (pSolarSysState->MoonDesc[0].location.x,
+						pSolarSysState->MoonDesc[0].location.y);
+				pSolarSysState->MoonDesc[0].location.x =
+						COSINE (angle, pSolarSysState->MoonDesc[0].radius);
+				pSolarSysState->MoonDesc[0].location.y =
+						SINE (angle, pSolarSysState->MoonDesc[0].radius);
+			}
+			break;
+		case GENERATE_PLANETS:
+			pSolarSysState->PlanetDesc[p].NumPlanets = 1;
+			break;
+		case GENERATE_ORBITAL:
+			if (pSolarSysState->pOrbitalDesc == &pSolarSysState->PlanetDesc[p])
+			{
+				DoPlanetaryAnalysis (
+						&pSolarSysState->SysInfo, pSolarSysState->pOrbitalDesc
+						);
+
+				LoadPlanet (NULL);
+				break;
+			}
+			/* Starbase */
+			if (pSolarSysState->pOrbitalDesc->pPrevDesc == &pSolarSysState->PlanetDesc[p]
+					&& pSolarSysState->pOrbitalDesc == &pSolarSysState->MoonDesc[0])
+			{
+				RECT r;
+
+				LockMutex (GraphicsLock);
+
+				LoadStdLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+				pSolarSysState->SysInfo.PlanetInfo.DiscoveryString =
+						SetRelStringTableIndex (
+								CaptureStringTable (
+										LoadStringTable (URQUAN_BASE_STRTAB)),
+										index);
+
+				ScanContext = CreateContext ();
+				SetContext (ScanContext);
+				SetContextFGFrame (Screen);
+				r.corner.x = (SIS_ORG_X + SIS_SCREEN_WIDTH) - MAP_WIDTH;
+				r.corner.y = (SIS_ORG_Y + SIS_SCREEN_HEIGHT) - MAP_HEIGHT;
+				r.extent.width = MAP_WIDTH;
+				r.extent.height = MAP_HEIGHT;
+				SetContextClipRect (&r);
+
+				DoDiscoveryReport (MenuSounds);
+
+				SetContext (SpaceContext);
+				DestroyContext (ScanContext);
+				ScanContext = 0;
+
+				DestroyStringTable (ReleaseStringTable (
+						pSolarSysState->SysInfo.PlanetInfo.DiscoveryString
+						));
+				pSolarSysState->SysInfo.PlanetInfo.DiscoveryString = 0;
+				FreeLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+
+				UnlockMutex (GraphicsLock);
+				break;
+			}
+		default:
+			break;
+	}
+}
+
+void
+GenerateUrQuan (BYTE control)
+{
+	generate_doctrinal_space_junk (control, 0);
+}
+
+void
+GenerateKohrAh (BYTE control)
+{
+	generate_doctrinal_space_junk (control, 1);
+}
diff -ruNp src.orig/sc2code/planets/genutw.c src/sc2code/planets/genutw.c
--- src.orig/sc2code/planets/genutw.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/planets/genutw.c	2017-11-08 16:50:03 -0600
@@ -19,9 +19,11 @@
 #include "build.h"
 #include "encount.h"
 #include "globdata.h"
+#include "lander.h"
 #include "nameref.h"
 #include "resinst.h"
 #include "setup.h"
+#include "sounds.h"
 #include "state.h"
 #include "planets/genall.h"
 #include "libs/mathlib.h"
@@ -34,10 +36,46 @@ GenerateUtwig (BYTE control)
 		case INIT_NPCS:
 			if (CurStarDescPtr->Index == BOMB_DEFINED
 					&& !GET_GAME_STATE (UTWIG_BOMB))
-				ReinitQueue (&GLOBAL (npc_built_ship_q));
+			{
+				ReinitQueue (&GLOBAL (ip_group_q));
+				assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
+			}
 			else
 				GenerateRandomIP (INIT_NPCS);
 			break;
+		case GENERATE_MOONS:
+			if (CurStarDescPtr->Index == UTWIG_DEFINED &&
+					pSolarSysState->pBaseDesc == &pSolarSysState->PlanetDesc[0])
+			{
+				COUNT angle;
+
+				// Setup moons, then add a starbase as the last moon
+				pSolarSysState->PlanetDesc[0].NumPlanets = 1;
+				GenerateRandomIP (GENERATE_MOONS);
+				pSolarSysState->PlanetDesc[0].NumPlanets = 2;
+
+				pSolarSysState->MoonDesc[1].data_index =
+						(ActivateStarShip (UTWIG_SHIP, SPHERE_TRACKING)) ?
+						UTWIG_STARBASE : DESTROYED_STARBASE;
+				angle = HALF_CIRCLE - OCTANT;
+				pSolarSysState->MoonDesc[1].radius = MIN_MOON_RADIUS;
+				pSolarSysState->MoonDesc[1].location.x =
+						COSINE (angle, pSolarSysState->MoonDesc[1].radius);
+				pSolarSysState->MoonDesc[1].location.y =
+						SINE (angle, pSolarSysState->MoonDesc[1].radius);
+
+				// adjust the position of the other moons outward
+				pSolarSysState->MoonDesc[0].radius += MOON_DELTA;
+				angle = ARCTAN (pSolarSysState->MoonDesc[0].location.x,
+						pSolarSysState->MoonDesc[0].location.y);
+				pSolarSysState->MoonDesc[0].location.x =
+						COSINE (angle, pSolarSysState->MoonDesc[0].radius);
+				pSolarSysState->MoonDesc[0].location.y =
+						SINE (angle, pSolarSysState->MoonDesc[0].radius);
+				break;
+			}
+			GenerateRandomIP (GENERATE_MOONS);
+			break;
 		case GENERATE_PLANETS:
 		{
 			COUNT angle;
@@ -134,6 +172,56 @@ GenerateUtwig (BYTE control)
 			break;
 		}
 		case GENERATE_ORBITAL:
+			if ((CurStarDescPtr->Index == UTWIG_DEFINED) && 
+					(pSolarSysState->pOrbitalDesc == &pSolarSysState->MoonDesc[1]) &&
+					(pSolarSysState->pOrbitalDesc->pPrevDesc == &pSolarSysState->PlanetDesc[0]))
+			{
+				// If you go to the starbase, move the ship to
+				// the planet instead
+				if (ActivateStarShip (UTWIG_SHIP, SPHERE_TRACKING))
+				{
+					pSolarSysState->pOrbitalDesc =
+							&pSolarSysState->PlanetDesc[0];
+					GLOBAL (ShipStamp.origin.x) = SIS_SCREEN_WIDTH >> 1;
+					GLOBAL (ShipStamp.origin.y) = SIS_SCREEN_HEIGHT >> 1;
+				}
+				// ...unless the Kohr-Ah have been through here
+				else
+				{
+					RECT r;
+					LockMutex (GraphicsLock);
+					
+					LoadStdLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+					pSolarSysState->SysInfo.PlanetInfo.DiscoveryString =
+							SetRelStringTableIndex (
+									CaptureStringTable (
+											LoadStringTable (RUINS_STRTAB)), 1);
+					ScanContext = CreateContext ();
+					SetContext (ScanContext);
+					SetContextFGFrame (Screen);
+					r.corner.x = (SIS_ORG_X + SIS_SCREEN_WIDTH) - MAP_WIDTH;
+					r.corner.y = (SIS_ORG_Y + SIS_SCREEN_HEIGHT) - MAP_HEIGHT;
+					r.extent.width = MAP_WIDTH;
+					r.extent.height = MAP_HEIGHT;
+					SetContextClipRect (&r);
+
+					DoDiscoveryReport (MenuSounds);
+
+					SetContext (SpaceContext);
+					DestroyContext (ScanContext);
+					ScanContext = 0;
+
+					DestroyStringTable (ReleaseStringTable (
+							pSolarSysState->SysInfo.PlanetInfo.DiscoveryString
+							));
+					pSolarSysState->SysInfo.PlanetInfo.DiscoveryString = 0;
+					FreeLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+
+					UnlockMutex (GraphicsLock);
+					break; 
+				}
+			}
+
 			if ((CurStarDescPtr->Index == UTWIG_DEFINED
 					&& pSolarSysState->pOrbitalDesc == &pSolarSysState->PlanetDesc[0])
 					|| (CurStarDescPtr->Index == BOMB_DEFINED
@@ -147,7 +235,8 @@ GenerateUtwig (BYTE control)
 				{
 					NotifyOthers (UTWIG_SHIP, (BYTE)~0);
 					PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
-					ReinitQueue (&GLOBAL (npc_built_ship_q));
+					ReinitQueue (&GLOBAL (ip_group_q));
+					assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
 
 					CloneShipFragment (UTWIG_SHIP,
 							&GLOBAL (npc_built_ship_q), INFINITE_FLEET);
@@ -180,7 +269,8 @@ GenerateUtwig (BYTE control)
 					COUNT i;
 
 					PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
-					ReinitQueue (&GLOBAL (npc_built_ship_q));
+					ReinitQueue (&GLOBAL (ip_group_q));
+					assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
 
 					for (i = 0; i < 5; ++i)
 						CloneShipFragment (DRUUGE_SHIP,
diff -ruNp src.orig/sc2code/planets/genvault.c src/sc2code/planets/genvault.c
--- src.orig/sc2code/planets/genvault.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/planets/genvault.c	2017-11-08 16:50:03 -0600
@@ -59,7 +59,7 @@ GenerateShipVault (BYTE control)
 							&= ~(1L << 0);
 					if (GET_GAME_STATE (SYREEN_SHUTTLE_ON_SHIP))
 					{
-						((PPLANETSIDE_DESC)pMenuState->ModuleFrame)->InTransit = TRUE;
+						((PLANETSIDE_DESC*)pMenuState->ModuleFrame)->InTransit = TRUE;
 
 						SET_GAME_STATE (SHIP_VAULT_UNLOCKED, 1);
 						SET_GAME_STATE (SYREEN_SHUTTLE_ON_SHIP, 0);
diff -ruNp src.orig/sc2code/planets/genvux.c src/sc2code/planets/genvux.c
--- src.orig/sc2code/planets/genvux.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/planets/genvux.c	2017-11-08 16:50:03 -0600
@@ -97,6 +97,29 @@ GenerateVUX (BYTE control)
 			}
 			pSolarSysState->CurNode = 0;
 			break;
+		case GENERATE_MOONS:
+			if (CurStarDescPtr->Index == VUX_DEFINED &&
+					pSolarSysState->pBaseDesc == &pSolarSysState->PlanetDesc[0])
+			{
+				// Setup moons, then add a starbase as the last moon
+				pSolarSysState->PlanetDesc[0].NumPlanets = 1;
+				GenerateRandomIP (GENERATE_MOONS);
+				pSolarSysState->PlanetDesc[0].NumPlanets = 2;
+
+				pSolarSysState->MoonDesc[1].data_index =
+						(ActivateStarShip (VUX_SHIP, SPHERE_TRACKING)) ?
+						HIERARCHY_STARBASE : DESTROYED_STARBASE;
+				pSolarSysState->MoonDesc[1].radius = MIN_MOON_RADIUS;
+				pSolarSysState->MoonDesc[1].location.x =
+						COSINE (HALF_CIRCLE - OCTANT,
+						pSolarSysState->MoonDesc[1].radius);
+				pSolarSysState->MoonDesc[1].location.y =
+						SINE (HALF_CIRCLE - OCTANT,
+						pSolarSysState->MoonDesc[1].radius);
+				break;
+			}
+			GenerateRandomIP (GENERATE_MOONS);
+			break;
 		case GENERATE_PLANETS:
 		{
 			COUNT angle;
@@ -152,6 +175,57 @@ GenerateVUX (BYTE control)
 		}
 		case GENERATE_ORBITAL:
 		{
+			if ((CurStarDescPtr->Index == VUX_DEFINED) && 
+					(pSolarSysState->pOrbitalDesc == &pSolarSysState->MoonDesc[1]) &&
+					(pSolarSysState->pOrbitalDesc->pPrevDesc == &pSolarSysState->PlanetDesc[0]))
+			{
+				// If you go to the starbase, move the ship to
+				// the planet instead
+				if (ActivateStarShip (VUX_SHIP, SPHERE_TRACKING))
+				{
+					pSolarSysState->pOrbitalDesc =
+							&pSolarSysState->PlanetDesc[0];
+					GLOBAL (ShipStamp.origin.x) = SIS_SCREEN_WIDTH >> 1;
+					GLOBAL (ShipStamp.origin.y) = SIS_SCREEN_HEIGHT >> 1;
+				}
+				// ...unless the Kohr-Ah have been through here
+				else
+				{
+					RECT r;
+					LockMutex (GraphicsLock);
+					
+					LoadStdLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+					pSolarSysState->SysInfo.PlanetInfo.DiscoveryString =
+							SetRelStringTableIndex (
+									CaptureStringTable (
+											LoadStringTable (RUINS_STRTAB)), 1);
+
+					ScanContext = CreateContext ();
+					SetContext (ScanContext);
+					SetContextFGFrame (Screen);
+					r.corner.x = (SIS_ORG_X + SIS_SCREEN_WIDTH) - MAP_WIDTH;
+					r.corner.y = (SIS_ORG_Y + SIS_SCREEN_HEIGHT) - MAP_HEIGHT;
+					r.extent.width = MAP_WIDTH;
+					r.extent.height = MAP_HEIGHT;
+					SetContextClipRect (&r);
+
+					DoDiscoveryReport (MenuSounds);
+
+					SetContext (SpaceContext);
+					DestroyContext (ScanContext);
+					ScanContext = 0;
+
+					DestroyStringTable (ReleaseStringTable (
+							pSolarSysState->SysInfo.PlanetInfo.DiscoveryString
+							));
+					pSolarSysState->SysInfo.PlanetInfo.DiscoveryString = 0;
+					FreeLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+
+					UnlockMutex (GraphicsLock);
+					break; 
+				}
+			}
+
 			if ((pSolarSysState->pOrbitalDesc == &pSolarSysState->PlanetDesc[0]
 					&& (CurStarDescPtr->Index == VUX_DEFINED
 					|| (CurStarDescPtr->Index == MAIDENS_DEFINED
@@ -160,7 +234,8 @@ GenerateVUX (BYTE control)
 			{
 				NotifyOthers (VUX_SHIP, (BYTE)~0);
 				PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
-				ReinitQueue (&GLOBAL (npc_built_ship_q));
+				ReinitQueue (&GLOBAL (ip_group_q));
+				assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
 
 				CloneShipFragment (VUX_SHIP,
 						&GLOBAL (npc_built_ship_q), INFINITE_FLEET);
@@ -312,9 +387,9 @@ GenerateVUX (BYTE control)
 							& (1L << i))
 							&& !GET_GAME_STATE (VUX_BEAST))
 					{
-						PPLANETSIDE_DESC pPSD;
+						PLANETSIDE_DESC *pPSD;
 
-						pPSD = (PPLANETSIDE_DESC)pMenuState->ModuleFrame;
+						pPSD = (PLANETSIDE_DESC*)pMenuState->ModuleFrame;
 						UnbatchGraphics ();
 						DoDiscoveryReport (MenuSounds);
 						BatchGraphics ();
diff -ruNp src.orig/sc2code/planets/genwreck.c src/sc2code/planets/genwreck.c
--- src.orig/sc2code/planets/genwreck.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/planets/genwreck.c	2017-11-08 16:50:03 -0600
@@ -57,7 +57,7 @@ GenerateUrquanWreck (BYTE control)
 
 					if (!GET_GAME_STATE (PORTAL_KEY))
 					{
-						((PPLANETSIDE_DESC)pMenuState->ModuleFrame)->InTransit = TRUE;
+						((PLANETSIDE_DESC*)pMenuState->ModuleFrame)->InTransit = TRUE;
 
 						SET_GAME_STATE (PORTAL_KEY, 1);
 						SET_GAME_STATE (PORTAL_KEY_ON_SHIP, 1);
diff -ruNp src.orig/sc2code/planets/genyeh.c src/sc2code/planets/genyeh.c
--- src.orig/sc2code/planets/genyeh.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/planets/genyeh.c	2017-11-08 16:50:03 -0600
@@ -19,8 +19,11 @@
 #include "build.h"
 #include "encount.h"
 #include "globdata.h"
+#include "lander.h"
 #include "nameref.h"
 #include "resinst.h"
+#include "setup.h"
+#include "sounds.h"
 #include "state.h"
 #include "planets/genall.h"
 #include "libs/mathlib.h"
@@ -64,6 +67,23 @@ GenerateYehat (BYTE control)
 			}
 			pSolarSysState->CurNode = 0;
 			break;
+		case GENERATE_MOONS:
+			GenerateRandomIP (GENERATE_MOONS);
+			if (CurStarDescPtr->Index == YEHAT_DEFINED &&
+					pSolarSysState->pBaseDesc == &pSolarSysState->PlanetDesc[0])
+			{
+				pSolarSysState->MoonDesc[0].data_index =
+						(ActivateStarShip (YEHAT_SHIP, SPHERE_TRACKING)) ?
+						HIERARCHY_STARBASE : DESTROYED_STARBASE;
+				pSolarSysState->MoonDesc[0].radius = MIN_MOON_RADIUS;
+				pSolarSysState->MoonDesc[0].location.x =
+						COSINE (FULL_CIRCLE - (OCTANT >> 1),
+						pSolarSysState->MoonDesc[0].radius);
+				pSolarSysState->MoonDesc[0].location.y =
+						SINE (FULL_CIRCLE - (OCTANT >> 1),
+						pSolarSysState->MoonDesc[0].radius);
+			}
+			break;
 		case GENERATE_PLANETS:
 		{
 			COUNT angle;
@@ -83,13 +103,64 @@ GenerateYehat (BYTE control)
 			break;
 		}
 		case GENERATE_ORBITAL:
+			if ((CurStarDescPtr->Index == YEHAT_DEFINED) &&
+					(pSolarSysState->pOrbitalDesc == &pSolarSysState->MoonDesc[0]) &&
+					(pSolarSysState->pOrbitalDesc->pPrevDesc == &pSolarSysState->PlanetDesc[0]))
+			{
+				// If you go to the starbase, move the ship to
+				// the planet instead
+				if (ActivateStarShip (YEHAT_SHIP, SPHERE_TRACKING))
+				{
+					pSolarSysState->pOrbitalDesc =
+							&pSolarSysState->PlanetDesc[0];
+					GLOBAL (ShipStamp.origin.x) = SIS_SCREEN_WIDTH >> 1;
+					GLOBAL (ShipStamp.origin.y) = SIS_SCREEN_HEIGHT >> 1;
+				}
+				// ...unless they're all dead
+				else
+				{
+					RECT r;
+					LockMutex (GraphicsLock);
+					
+					LoadStdLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+					pSolarSysState->SysInfo.PlanetInfo.DiscoveryString =
+							SetRelStringTableIndex (
+									CaptureStringTable (
+											LoadStringTable (RUINS_STRTAB)), 1);
+					ScanContext = CreateContext ();
+					SetContext (ScanContext);
+					SetContextFGFrame (Screen);
+					r.corner.x = (SIS_ORG_X + SIS_SCREEN_WIDTH) - MAP_WIDTH;
+					r.corner.y = (SIS_ORG_Y + SIS_SCREEN_HEIGHT) - MAP_HEIGHT;
+					r.extent.width = MAP_WIDTH;
+					r.extent.height = MAP_HEIGHT;
+					SetContextClipRect (&r);
+
+					DoDiscoveryReport (MenuSounds);
+
+					SetContext (SpaceContext);
+					DestroyContext (ScanContext);
+					ScanContext = 0;
+
+					DestroyStringTable (ReleaseStringTable (
+							pSolarSysState->SysInfo.PlanetInfo.DiscoveryString
+							));
+					pSolarSysState->SysInfo.PlanetInfo.DiscoveryString = 0;
+					FreeLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+
+					UnlockMutex (GraphicsLock);
+					break; 
+				}
+			}
+
 			if (pSolarSysState->pOrbitalDesc == &pSolarSysState->PlanetDesc[0])
 			{
 				if (ActivateStarShip (YEHAT_SHIP, SPHERE_TRACKING))
 				{
 					NotifyOthers (YEHAT_SHIP, (BYTE)~0);
 					PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
-					ReinitQueue (&GLOBAL (npc_built_ship_q));
+					ReinitQueue (&GLOBAL (ip_group_q));
+					assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
 
 					CloneShipFragment (YEHAT_SHIP,
 							&GLOBAL (npc_built_ship_q), INFINITE_FLEET);
diff -ruNp src.orig/sc2code/planets/genzoq.c src/sc2code/planets/genzoq.c
--- src.orig/sc2code/planets/genzoq.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/planets/genzoq.c	2017-11-08 16:50:03 -0600
@@ -19,9 +19,13 @@
 #include "build.h"
 #include "encount.h"
 #include "globdata.h"
+#include "lander.h"
 #include "nameref.h"
 #include "resinst.h"
+#include "setup.h"
+#include "sounds.h"
 #include "state.h"
+#include "grpinfo.h"
 #include "planets/genall.h"
 #include "libs/mathlib.h"
 
@@ -29,29 +33,22 @@
 static void
 check_scout (void)
 {
-	HSTARSHIP hStarShip;
+	HIPGROUP hGroup;
 
 	if (GLOBAL (BattleGroupRef)
-			&& (hStarShip = GetHeadLink (
-					&GLOBAL (npc_built_ship_q)
-					)))
-	{
-		BYTE task;
-		SHIP_FRAGMENTPTR FragPtr;
-
-		FragPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-				&GLOBAL (npc_built_ship_q), hStarShip
-				);
-		task = GET_GROUP_MISSION (FragPtr);
+			&& (hGroup = GetHeadLink (&GLOBAL (ip_group_q))))
+	{
+		IP_GROUP *GroupPtr;
+
+		GroupPtr = LockIpGroup (&GLOBAL (ip_group_q), hGroup);
 
-		if (task & REFORM_GROUP)
+		if (GroupPtr->task & REFORM_GROUP)
 		{
-			SET_GROUP_MISSION (FragPtr,
-					FLEE | IGNORE_FLAGSHIP | REFORM_GROUP);
-			SET_GROUP_DEST (FragPtr, 0);
+			GroupPtr->task = FLEE | IGNORE_FLAGSHIP | REFORM_GROUP;
+			GroupPtr->dest_loc = 0;
 		}
 
-		UnlockStarShip (&GLOBAL (npc_built_ship_q), hStarShip);
+		UnlockIpGroup (&GLOBAL (ip_group_q), hGroup);
 	}
 }
 
@@ -68,8 +65,8 @@ GenerateScout (BYTE control)
 				{
 					CloneShipFragment (ZOQFOTPIK_SHIP,
 							&GLOBAL (npc_built_ship_q), 0);
-
 					GLOBAL (BattleGroupRef) = PutGroupInfo (GROUPS_ADD_NEW, 1);
+					ReinitQueue (&GLOBAL (npc_built_ship_q));
 					SET_GAME_STATE_32 (ZOQFOT_GRPOFFS0,
 							GLOBAL (BattleGroupRef));
 				}
@@ -86,6 +83,69 @@ GenerateScout (BYTE control)
 	}
 }
 
+static void
+generate_energy_signatures (int num)
+{
+	COUNT i, which_node;
+	DWORD rand_val, old_rand;
+
+	old_rand = TFB_SeedRandom (
+			pSolarSysState->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN]);
+
+	which_node = i = 0;
+	do
+	{
+		rand_val = TFB_Random ();
+		pSolarSysState->SysInfo.PlanetInfo.CurPt.x =
+				(LOBYTE (LOWORD (rand_val)) % (MAP_WIDTH - (8 << 1))) + 8;
+		pSolarSysState->SysInfo.PlanetInfo.CurPt.y =
+				(HIBYTE (LOWORD (rand_val)) % (MAP_HEIGHT - (8 << 1))) + 8;
+		pSolarSysState->SysInfo.PlanetInfo.CurType = 1;
+		pSolarSysState->SysInfo.PlanetInfo.CurDensity = 0;
+		if (which_node >= pSolarSysState->CurNode
+				&& !(pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+				& (1L << i)))
+			break;
+		++which_node;
+	} while (++i < num);
+	pSolarSysState->CurNode = which_node;
+
+	TFB_SeedRandom (old_rand);
+}
+
+static void
+GenerateZoqFotPikColonies (BYTE control)
+{
+	switch (control)
+	{
+		case GENERATE_ENERGY:
+			if ((pSolarSysState->pOrbitalDesc == &pSolarSysState->PlanetDesc[0]
+					&& pSolarSysState->pOrbitalDesc->NumPlanets == 0)
+					|| (pSolarSysState->pOrbitalDesc->pPrevDesc == &pSolarSysState->PlanetDesc[0]
+					&& pSolarSysState->pOrbitalDesc == &pSolarSysState->MoonDesc[1])) 
+			{
+				generate_energy_signatures (4);
+				break;
+			}
+		case GENERATE_ORBITAL:
+			if ((pSolarSysState->pOrbitalDesc == &pSolarSysState->PlanetDesc[0]
+					&& pSolarSysState->pOrbitalDesc->NumPlanets == 0)
+					|| (pSolarSysState->pOrbitalDesc->pPrevDesc == &pSolarSysState->PlanetDesc[0]
+					&& pSolarSysState->pOrbitalDesc == &pSolarSysState->MoonDesc[1])) 
+			{
+				LoadStdLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+				pSolarSysState->PlanetSideFrame[1] =
+						CaptureDrawable (LoadGraphic (RUINS_MASK_PMAP_ANIM));
+				pSolarSysState->SysInfo.PlanetInfo.DiscoveryString =
+						CaptureStringTable (LoadStringTable (ZFPRUINS_STRTAB));
+			}
+			// note the lack of a break statement here
+		default:
+			GenerateRandomIP (control);
+			break;
+	}
+}
+
 void
 GenerateZoqFotPik (BYTE control)
 {
@@ -94,6 +154,11 @@ GenerateZoqFotPik (BYTE control)
 		GenerateScout (control);
 		return;
 	}
+	else if (CurStarDescPtr->Index == ZOQ_COLONY_DEFINED)
+	{
+		GenerateZoqFotPikColonies (control);
+		return;
+	}
 
 	switch (control)
 	{
@@ -104,36 +169,34 @@ GenerateZoqFotPik (BYTE control)
 		case GENERATE_ENERGY:
 			if (pSolarSysState->pOrbitalDesc == &pSolarSysState->PlanetDesc[0])
 			{
-				COUNT i, which_node;
-				DWORD rand_val, old_rand;
-
-				old_rand = TFB_SeedRandom (
-						pSolarSysState->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN]
-						);
-
-				which_node = i = 0;
-				do
-				{
-					rand_val = TFB_Random ();
-					pSolarSysState->SysInfo.PlanetInfo.CurPt.x =
-							(LOBYTE (LOWORD (rand_val)) % (MAP_WIDTH - (8 << 1))) + 8;
-					pSolarSysState->SysInfo.PlanetInfo.CurPt.y =
-							(HIBYTE (LOWORD (rand_val)) % (MAP_HEIGHT - (8 << 1))) + 8;
-					pSolarSysState->SysInfo.PlanetInfo.CurType = 1;
-					pSolarSysState->SysInfo.PlanetInfo.CurDensity = 0;
-					if (which_node >= pSolarSysState->CurNode
-							&& !(pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
-							& (1L << i)))
-						break;
-					++which_node;
-				} while (++i < 16);
-				pSolarSysState->CurNode = which_node;
-
-				TFB_SeedRandom (old_rand);
+				generate_energy_signatures (16);
 				break;
 			}
 			pSolarSysState->CurNode = 0;
 			break;
+		case GENERATE_MOONS:
+			if (CurStarDescPtr->Index == ZOQFOT_DEFINED &&
+					pSolarSysState->pBaseDesc == &pSolarSysState->PlanetDesc[0])
+			{
+				// Setup moons, then add a starbase as the last moon
+				pSolarSysState->PlanetDesc[0].NumPlanets = 1;
+				GenerateRandomIP (GENERATE_MOONS);
+				pSolarSysState->PlanetDesc[0].NumPlanets = 2;
+
+				pSolarSysState->MoonDesc[1].data_index =
+						(ActivateStarShip (ZOQFOTPIK_SHIP, SPHERE_TRACKING)) ?
+						ZOQFOTPIK_STARBASE : DESTROYED_STARBASE;
+				pSolarSysState->MoonDesc[1].radius = MIN_MOON_RADIUS;
+				pSolarSysState->MoonDesc[1].location.x =
+						COSINE (HALF_CIRCLE + QUADRANT,
+								pSolarSysState->MoonDesc[1].radius);
+				pSolarSysState->MoonDesc[1].location.y =
+						SINE (HALF_CIRCLE + QUADRANT,
+								pSolarSysState->MoonDesc[1].radius);
+				break;
+			}
+			GenerateRandomIP (GENERATE_MOONS);
+			break;
 		case GENERATE_PLANETS:
 		{
 			COUNT angle;
@@ -153,12 +216,62 @@ GenerateZoqFotPik (BYTE control)
 			break;
 		}
 		case GENERATE_ORBITAL:
+			if ((pSolarSysState->pOrbitalDesc == &pSolarSysState->MoonDesc[1]) &&
+					(pSolarSysState->pOrbitalDesc->pPrevDesc == &pSolarSysState->PlanetDesc[0]))
+			{
+				// If you go to the starbase, move the ship to
+				// the planet instead
+				if (ActivateStarShip (ZOQFOTPIK_SHIP, SPHERE_TRACKING))
+				{
+					pSolarSysState->pOrbitalDesc =
+							&pSolarSysState->PlanetDesc[0];
+					GLOBAL (ShipStamp.origin.x) = SIS_SCREEN_WIDTH >> 1;
+					GLOBAL (ShipStamp.origin.y) = SIS_SCREEN_HEIGHT >> 1;
+				}
+				// ...unless they're all dead
+				else
+				{
+					RECT r;
+					LockMutex (GraphicsLock);
+
+					LoadStdLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+					pSolarSysState->SysInfo.PlanetInfo.DiscoveryString =
+							SetRelStringTableIndex (
+									CaptureStringTable (
+											LoadStringTable (RUINS_STRTAB)), 1);
+					ScanContext = CreateContext ();
+					SetContext (ScanContext);
+					SetContextFGFrame (Screen);
+					r.corner.x = (SIS_ORG_X + SIS_SCREEN_WIDTH) - MAP_WIDTH;
+					r.corner.y = (SIS_ORG_Y + SIS_SCREEN_HEIGHT) - MAP_HEIGHT;
+					r.extent.width = MAP_WIDTH;
+					r.extent.height = MAP_HEIGHT;
+					SetContextClipRect (&r);
+
+					DoDiscoveryReport (MenuSounds);
+
+					SetContext (SpaceContext);
+					DestroyContext (ScanContext);
+					ScanContext = 0;
+
+					DestroyStringTable (ReleaseStringTable (
+							pSolarSysState->SysInfo.PlanetInfo.DiscoveryString
+							));
+					pSolarSysState->SysInfo.PlanetInfo.DiscoveryString = 0;
+					FreeLanderFont (&pSolarSysState->SysInfo.PlanetInfo);
+
+					UnlockMutex (GraphicsLock);
+					break;
+				}
+			}
+
 			if (pSolarSysState->pOrbitalDesc == &pSolarSysState->PlanetDesc[0])
 			{
 				if (ActivateStarShip (ZOQFOTPIK_SHIP, SPHERE_TRACKING))
 				{
 					PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
-					ReinitQueue (&GLOBAL (npc_built_ship_q));
+					ReinitQueue (&GLOBAL (ip_group_q));
+					assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
 
 					if (GET_GAME_STATE (ZOQFOT_DISTRESS))
 					{
diff -ruNp src.orig/sc2code/planets/lander.c src/sc2code/planets/lander.c
--- src.orig/sc2code/planets/lander.c	2017-11-08 16:49:35 -0600
+++ src/sc2code/planets/lander.c	2017-11-08 16:50:03 -0600
@@ -16,6 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+#include "cons_res.h"
 #include "controls.h"
 #include "colors.h"
 #include "encount.h"
@@ -171,7 +172,7 @@ DamageColorCycle (COLOR c, COUNT i)
 #define MAGNIFICATION (1 << MAG_SHIFT)
 
 static BOOLEAN
-RepairTopography (ELEMENTPTR ElementPtr)
+RepairTopography (ELEMENT *ElementPtr)
 {
 	//BOOLEAN CursorIntersect;
 	SIZE delta;
@@ -213,10 +214,10 @@ RepairTopography (ELEMENTPTR ElementPtr)
 static HELEMENT AddGroundDisaster (COUNT which_disaster);
 
 void
-object_animation (PELEMENT ElementPtr)
+object_animation (ELEMENT *ElementPtr)
 {
 	COUNT frame_index, angle;
-	PPRIMITIVE pPrim;
+	PRIMITIVE *pPrim;
 
 	pPrim = &DisplayArray[ElementPtr->PrimIndex];
 	if (GetPrimType (pPrim) == STAMPFILL_PRIM
@@ -254,6 +255,7 @@ object_animation (PELEMENT ElementPtr)
 				IncFrameIndex (pPrim->Object.Stamp.frame);
 		if (ElementPtr->state_flags & FINITE_LIFE)
 		{
+			/* A natural disaster */
 			if (ElementPtr->mass_points == DEATH_EXPLOSION)
 			{
 				if (++pMenuState->CurState >= EXPLOSION_LIFE)
@@ -268,6 +270,7 @@ object_animation (PELEMENT ElementPtr)
 					s = 0;
 				else
 					s = (14 - frame_index) >> 1;
+				// XXX: Was 0x8000 the background flag on 3DO?
 				SetPrimColor (pPrim, BUILD_COLOR (0x8000 | MAKE_RGB15 (0x1F, 0x1F, 0x1F), s));
 				if (frame_index == 13)
 					PlaySound (SetAbsSoundIndex (LanderSounds, EARTHQUAKE_DISASTER),
@@ -280,12 +283,13 @@ object_animation (PELEMENT ElementPtr)
 			{
 				HELEMENT hLavaElement;
 
+				/* Change lava-spot direction of travel */
 				hLavaElement = AddGroundDisaster (LAVASPOT_DISASTER);
 				if (hLavaElement)
 				{
-					ELEMENTPTR LavaElementPtr;
+					ELEMENT *LavaElementPtr;
 
-					angle = FACING_TO_ANGLE (ElementPtr->hit_points);
+					angle = FACING_TO_ANGLE (ElementPtr->facing);
 					LockElement (hLavaElement, &LavaElementPtr);
 					LavaElementPtr->next.location = ElementPtr->next.location;
 					LavaElementPtr->next.location.x += COSINE (angle, 4);
@@ -298,9 +302,8 @@ object_animation (PELEMENT ElementPtr)
 						LavaElementPtr->next.location.x += MAP_WIDTH << MAG_SHIFT;
 					else
 						LavaElementPtr->next.location.x %= MAP_WIDTH << MAG_SHIFT;
-					LavaElementPtr->hit_points = NORMALIZE_FACING (
-							ElementPtr->hit_points + ((COUNT)TFB_Random () % 3) - 1
-							);
+					LavaElementPtr->facing = NORMALIZE_FACING (
+							ElementPtr->facing + ((COUNT)TFB_Random () % 3) - 1);
 					UnlockElement (hLavaElement);
 				}
 			}
@@ -479,13 +482,13 @@ DeltaLanderCrew (SIZE crew_delta, COUNT
 }
 
 static void
-FillLanderHold (PPLANETSIDE_DESC pPSD, COUNT scan, COUNT NumRetrieved)
+FillLanderHold (PLANETSIDE_DESC *pPSD, COUNT scan, COUNT NumRetrieved, COUNT sound_index)
 {
 	COUNT start_count;
 	STAMP s;
 	CONTEXT OldContext;
 
-	PlaySound (SetAbsSoundIndex (LanderSounds, LANDER_PICKUP),
+	PlaySound (SetAbsSoundIndex (LanderSounds, sound_index),
 			NotPositional (), NULL, GAME_SOUND_PRIORITY);
 
 	if (scan == BIOLOGICAL_SCAN)
@@ -531,9 +534,10 @@ static void
 CheckObjectCollision (COUNT index)
 {
 	INTERSECT_CONTROL LanderControl;
-	MEM_HANDLE LanderHandle;
-	PPRIMITIVE pPrim, pLanderPrim;
-	PPLANETSIDE_DESC pPSD;
+	DRAWABLE LanderHandle;
+	PRIMITIVE *pPrim;
+	PRIMITIVE *pLanderPrim;
+	PLANETSIDE_DESC *pPSD;
 
 	if (index != END_OF_LIST)
 	{
@@ -550,9 +554,9 @@ CheckObjectCollision (COUNT index)
 		index = GetSuccLink (DisplayLinks);
 	}
 
-	pPSD = (PPLANETSIDE_DESC)pMenuState->ModuleFrame;
+	pPSD = (PLANETSIDE_DESC*)pMenuState->ModuleFrame;
 	LanderControl.EndPoint = LanderControl.IntersectStamp.origin;
-	LanderHandle = GetFrameHandle (LanderControl.IntersectStamp.frame);
+	LanderHandle = GetFrameParentDrawable (LanderControl.IntersectStamp.frame);
 
 	for (; index != END_OF_LIST; index = GetPredLink (GetPrimLinks (pPrim)))
 	{
@@ -563,7 +567,7 @@ CheckObjectCollision (COUNT index)
 		ElementControl.IntersectStamp = pPrim->Object.Stamp;
 		ElementControl.EndPoint = ElementControl.IntersectStamp.origin;
 
-		if (GetFrameHandle (ElementControl.IntersectStamp.frame)
+		if (GetFrameParentDrawable (ElementControl.IntersectStamp.frame)
 				== LanderHandle)
 		{
 			CheckObjectCollision (index);
@@ -576,7 +580,7 @@ CheckObjectCollision (COUNT index)
 
 		for (hElement = GetHeadElement (); hElement; hElement = hNextElement)
 		{
-			ELEMENTPTR ElementPtr;
+			ELEMENT *ElementPtr;
 
 			LockElement (hElement, &ElementPtr);
 			hNextElement = GetSuccElement (ElementPtr);
@@ -599,9 +603,10 @@ CheckObjectCollision (COUNT index)
 				COUNT scan, NumRetrieved;
 				SIZE which_node;
 
-				scan = LOBYTE (ElementPtr->life_span);
+				scan = LOBYTE (ElementPtr->scan_node);
 				if (pLanderPrim == 0)
 				{
+					/* Collision of lander with another object */
 					if (HIBYTE (pMenuState->delta_item) == 0
 							|| pPSD->InTransit)
 						break;
@@ -684,9 +689,9 @@ CheckObjectCollision (COUNT index)
 
 					NumRetrieved = ElementPtr->mass_points;
 				}
-					/* if a natural disaster */
 				else if (ElementPtr->state_flags & FINITE_LIFE)
 				{
+					/* Collision of a stun bolt with a natural disaster */
 					UnlockElement (hElement);
 					continue;
 				}
@@ -696,6 +701,7 @@ CheckObjectCollision (COUNT index)
 
 					if (scan == ENERGY_SCAN)
 					{
+						/* Collision of a stun bolt with an energy node */
 						UnlockElement (hElement);
 						break;
 					}
@@ -705,10 +711,17 @@ CheckObjectCollision (COUNT index)
 							& ~CREATURE_AWARE
 							].ValueAndHitPoints)))
 					{
+						/* Collision of a stun bolt with a viable creature */
 						if (ElementPtr->hit_points)
 						{
 							if (--ElementPtr->hit_points == 0)
 							{
+								// stash the type of creature in the
+								// thrust_wait field.  It seems to be unused
+								// by the game for anything at this point
+								ElementPtr->thrust_wait =
+										ElementPtr->mass_points &
+										~CREATURE_AWARE;
 								ElementPtr->mass_points = value;
 								DisplayArray[
 										ElementPtr->PrimIndex
@@ -745,69 +758,110 @@ CheckObjectCollision (COUNT index)
 						UnlockElement (hElement);
 						break;
 					}
+					else if (scan == BIOLOGICAL_SCAN)
+					{
+						/* Corner case: collision of a stun bolt with a moon
+						 * bulldozer.  Blow 'em up!  Uses the same frames as
+						 * the lander explosion */
+
+						ElementPtr->state_flags |= FINITE_LIFE;
+						ElementPtr->turn_wait = MAKE_BYTE (2, 2);
+						ElementPtr->life_span = EXPLOSION_LIFE *
+								(LONIBBLE (ElementPtr->turn_wait));
+						ZeroVelocityComponents (&ElementPtr->velocity);
+
+						DisplayArray[ElementPtr->PrimIndex].Object.Stamp.frame =
+								 SetAbsFrameIndex (LanderFrame[0], 46);
+
+						PlaySound (SetAbsSoundIndex (
+								LanderSounds, LANDER_HITS), NotPositional (),
+								NULL, GAME_SOUND_PRIORITY + 1); 
+
+						UnlockElement (hElement);
+						break;
+					}
 
 					NumRetrieved = 0;
 				}
 
 				if (NumRetrieved)
 				{
+					BYTE EType;
+					COUNT *amount, max, offset;
+					UNICODE ch, *pStr;
+
 					switch (scan)
 					{
 						case ENERGY_SCAN:
 							break;
 						case MINERAL_SCAN:
-							if (pPSD->ElementLevel < pPSD->MaxElementLevel)
+						case BIOLOGICAL_SCAN:
+							/* code path here is mostly the same, but there
+							 * are a few differences.
+							 */
+							if (scan == MINERAL_SCAN)
 							{
-								if (pPSD->ElementLevel
-										+ NumRetrieved > pPSD->MaxElementLevel)
-									NumRetrieved = (COUNT)(pPSD->MaxElementLevel
-											- pPSD->ElementLevel);
-								FillLanderHold (pPSD, scan, NumRetrieved);
-								if (scan == MINERAL_SCAN)
+								amount = &pPSD->ElementLevel;
+								max = pPSD->MaxElementLevel;
+								EType = ElementPtr->turn_wait;
+								offset = ELEMENTS_STRING_BASE;
+							}
+							else if (scan == BIOLOGICAL_SCAN)
+							{
+								amount = &pPSD->BiologicalLevel;
+								max = MAX_SCROUNGED;
+								EType = ElementPtr->thrust_wait;
+								offset = BIOLOGICAL_STRING_BASE;
+							}
+							if (*amount < max)
+							{
+								COUNT sound_index = LANDER_PICKUP;
+								if (*amount + NumRetrieved > max)
 								{
-									BYTE EType;
-									UNICODE ch, *pStr;
+									NumRetrieved = (COUNT)(max - *amount);
+									sound_index = LANDER_FULL;
+								}
+								FillLanderHold (pPSD, scan, NumRetrieved, sound_index);
 
-									EType = ElementPtr->turn_wait;
+								if (scan == MINERAL_SCAN)
 									pPSD->ElementAmounts[
 											ElementCategory (EType)
 											] += NumRetrieved;
 
-									pPSD->NumFrames = NUM_TEXT_FRAMES;
-									sprintf (pPSD->AmountBuf, "%u", NumRetrieved);
-									pStr = GAME_STRING (EType + ELEMENTS_STRING_BASE);
-
-									pPSD->MineralText[0].baseline.x =
-											(SURFACE_WIDTH >> 1)
-											+ (ElementControl.EndPoint.x
-											- LanderControl.EndPoint.x);
-									pPSD->MineralText[0].baseline.y =
-											(SURFACE_HEIGHT >> 1)
-											+ (ElementControl.EndPoint.y
-											- LanderControl.EndPoint.y);
-									pPSD->MineralText[0].CharCount =
+								pPSD->NumFrames = NUM_TEXT_FRAMES;
+								sprintf (pPSD->AmountBuf, "%u", NumRetrieved);
+								pStr = GAME_STRING (EType + offset);
+
+								pPSD->ElementText[0].baseline.x =
+										(SURFACE_WIDTH >> 1)
+										+ (ElementControl.EndPoint.x
+										- LanderControl.EndPoint.x);
+								pPSD->ElementText[0].baseline.y =
+										(SURFACE_HEIGHT >> 1)
+										+ (ElementControl.EndPoint.y
+										- LanderControl.EndPoint.y);
+								pPSD->ElementText[0].CharCount =
+										(COUNT)~0;
+								pPSD->ElementText[1].pStr = pStr;
+								while ((ch = *pStr++) && ch != ' ')
+									;
+								if (ch == '\0')
+								{
+									pPSD->ElementText[1].CharCount =
+											(COUNT)~0;
+									pPSD->ElementText[2].CharCount = 0;
+								}
+								else  /* ch == ' ' */
+								{
+									// Name contains a space. Print over
+									// two lines.
+									pPSD->ElementText[1].CharCount =
+											utf8StringCountN(
+											pPSD->ElementText[1].pStr,
+											pStr - 1);
+									pPSD->ElementText[2].pStr = pStr;
+									pPSD->ElementText[2].CharCount =
 											(COUNT)~0;
-									pPSD->MineralText[1].pStr = pStr;
-									while ((ch = *pStr++) && ch != ' ')
-										;
-									if (ch == '\0')
-									{
-										pPSD->MineralText[1].CharCount =
-												(COUNT)~0;
-										pPSD->MineralText[2].CharCount = 0;
-									}
-									else  /* ch == ' ' */
-									{
-										// Name contains a space. Print over
-										// two lines.
-										pPSD->MineralText[1].CharCount =
-												utf8StringCountN(
-												pPSD->MineralText[1].pStr,
-												pStr - 1);
-										pPSD->MineralText[2].pStr = pStr;
-										pPSD->MineralText[2].CharCount =
-												(COUNT)~0;
-									}
 								}
 								break;
 							}
@@ -816,26 +870,10 @@ CheckObjectCollision (COUNT index)
 									NotPositional (), NULL,
 									GAME_SOUND_PRIORITY);
 							continue;
-						case BIOLOGICAL_SCAN:
-							if (pPSD->BiologicalLevel < MAX_SCROUNGED)
-							{
-								if (pPSD->BiologicalLevel
-										+ NumRetrieved > MAX_SCROUNGED)
-									NumRetrieved = (COUNT)(
-											MAX_SCROUNGED
-											- pPSD->BiologicalLevel
-											);
-								FillLanderHold (pPSD, scan, NumRetrieved);
-								break;
-							}
-							PlaySound (SetAbsSoundIndex (
-									LanderSounds, LANDER_FULL
-									), NotPositional (), NULL, GAME_SOUND_PRIORITY);
-							continue;
 					}
 				}
 
-				which_node = HIBYTE (ElementPtr->life_span) - 1;
+				which_node = HIBYTE (ElementPtr->scan_node) - 1;
 				pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[scan] |=
 						(1L << which_node);
 				pSolarSysState->CurNode = (COUNT)~0;
@@ -844,10 +882,15 @@ CheckObjectCollision (COUNT index)
 				if (!(pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[scan] &
 						(1L << which_node)))
 				{
-					if (DestroyStringTable (ReleaseStringTable (
-							pSolarSysState->SysInfo.PlanetInfo.DiscoveryString
-							)))
-						pSolarSysState->SysInfo.PlanetInfo.DiscoveryString = 0;
+					/* If our discovery strings have cycled, we're done */
+					if (GetStringTableIndex (
+							pSolarSysState->SysInfo.PlanetInfo.DiscoveryString) == 0)
+					{
+						if (DestroyStringTable (ReleaseStringTable (
+								pSolarSysState->SysInfo.PlanetInfo.DiscoveryString
+								)))
+							pSolarSysState->SysInfo.PlanetInfo.DiscoveryString = 0;
+					}
 				}
 				else
 				{
@@ -864,9 +907,9 @@ CheckObjectCollision (COUNT index)
 }
 
 static void
-lightning_process (PELEMENT ElementPtr)
+lightning_process (ELEMENT *ElementPtr)
 {
-	PPRIMITIVE pPrim;
+	PRIMITIVE *pPrim;
 
 	pPrim = &DisplayArray[ElementPtr->PrimIndex];
 	if (LONIBBLE (ElementPtr->turn_wait))
@@ -877,23 +920,40 @@ lightning_process (PELEMENT ElementPtr)
 
 		num_frames = GetFrameCount (pPrim->Object.Stamp.frame) - 7;
 		if (GetFrameIndex (pPrim->Object.Stamp.frame) >= num_frames)
+		{
+			/* Advance to the next surface strike effect frame */
+			// XXX: This is unused, we never get here
 			pPrim->Object.Stamp.frame =
 					IncFrameIndex (pPrim->Object.Stamp.frame);
+		}
 		else
 		{
 			SIZE s;
+#define NUM_CYCLES 8
+			static const COLOR color_tab[] =
+			{
+				BUILD_COLOR (MAKE_RGB15 (0x11, 0x11, 0x11), 0x18),
+				BUILD_COLOR (MAKE_RGB15 (0x13, 0x13, 0x13), 0x17),
+				BUILD_COLOR (MAKE_RGB15 (0x15, 0x15, 0x15), 0x15),
+				BUILD_COLOR (MAKE_RGB15 (0x17, 0x17, 0x17), 0x14),
+				BUILD_COLOR (MAKE_RGB15 (0x19, 0x19, 0x19), 0x13),
+				BUILD_COLOR (MAKE_RGB15 (0x1B, 0x1B, 0x1B), 0x12),
+				BUILD_COLOR (MAKE_RGB15 (0x1D, 0x1D, 0x1D), 0x10),
+				BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x1F), 0x0f),
+			};
 			
-			s = 7 - ((SIZE)ElementPtr->crew_level - (SIZE)ElementPtr->life_span);
-			if (s < 0)
-				s = 0;
-			SetPrimColor (pPrim, BUILD_COLOR (0x8000 | MAKE_RGB15 (0x1F, 0x1F, 0x1F), s));
+			s = ElementPtr->life_span;
+			if (s > NUM_CYCLES - 1)
+				s = NUM_CYCLES - 1;
+			SetPrimColor (pPrim, color_tab[s]);
 
 			if (ElementPtr->mass_points == LIGHTNING_DISASTER)
 			{
+				/* This one always strikes the lander and can hurt */
 				if (HIBYTE (pMenuState->delta_item)
 						&& (BYTE)TFB_Random () < (256 / 10)
 						&& !(
-						(PPLANETSIDE_DESC)pMenuState->ModuleFrame
+						(PLANETSIDE_DESC*)pMenuState->ModuleFrame
 						)->InTransit)
 					lander_flags |= KILL_CREW;
 
@@ -922,14 +982,14 @@ AddLightning (void)
 	if (hLightningElement)
 	{
 		DWORD rand_val;
-		ELEMENTPTR LightningElementPtr;
+		ELEMENT *LightningElementPtr;
 
 		LockElement (hLightningElement, &LightningElementPtr);
 
 		LightningElementPtr->state_flags = FINITE_LIFE | BAD_GUY;
 		LightningElementPtr->preprocess_func = lightning_process;
 		if ((BYTE)TFB_Random () >= (256 >> 2))
-			LightningElementPtr->mass_points = 0;
+			LightningElementPtr->mass_points = 0; /* harmless */
 		else
 			LightningElementPtr->mass_points = LIGHTNING_DISASTER;
 
@@ -946,7 +1006,7 @@ AddLightning (void)
 				+ (HIBYTE (rand_val) % (SURFACE_HEIGHT - 12))
 				) % (MAP_HEIGHT << MAG_SHIFT);
 
-		LightningElementPtr->crew_level = LightningElementPtr->life_span;
+		LightningElementPtr->cycle = LightningElementPtr->life_span;
 		
 		SetPrimType (&DisplayArray[LightningElementPtr->PrimIndex], STAMPFILL_PRIM);
 		SetPrimColor (&DisplayArray[LightningElementPtr->PrimIndex], WHITE_COLOR);
@@ -971,8 +1031,8 @@ AddGroundDisaster (COUNT which_disaster)
 	if (hGroundDisasterElement)
 	{
 		DWORD rand_val;
-		ELEMENTPTR GroundDisasterElementPtr;
-		PPRIMITIVE pPrim;
+		ELEMENT *GroundDisasterElementPtr;
+		PRIMITIVE *pPrim;
 
 		LockElement (hGroundDisasterElement, &GroundDisasterElementPtr);
 
@@ -1000,10 +1060,10 @@ AddGroundDisaster (COUNT which_disaster)
 			pPrim->Object.Stamp.frame = LanderFrame[1];
 			GroundDisasterElementPtr->turn_wait = MAKE_BYTE (2, 2);
 		}
-		else
+		else /* if (which_disaster == LAVASPOT_DISASTER) */
 		{
 			SetPrimType (pPrim, STAMP_PRIM);
-			GroundDisasterElementPtr->hit_points =
+			GroundDisasterElementPtr->facing =
 					NORMALIZE_FACING (TFB_Random ());
 			pPrim->Object.Stamp.frame = LanderFrame[3];
 			GroundDisasterElementPtr->turn_wait = MAKE_BYTE (0, 0);
@@ -1026,13 +1086,13 @@ BuildObjectList (void)
 	DWORD rand_val;
 	POINT org;
 	HELEMENT hElement, hNextElement;
-	PPLANETSIDE_DESC pPSD;
+	PLANETSIDE_DESC *pPSD;
 
 	DisplayLinks = MakeLinks (END_OF_LIST, END_OF_LIST);
 	
 	lander_flags &= ~KILL_CREW;
 
-	pPSD = (PPLANETSIDE_DESC)pMenuState->ModuleFrame;
+	pPSD = (PLANETSIDE_DESC*)pMenuState->ModuleFrame;
 	rand_val = TFB_Random ();
 	if (LOBYTE (HIWORD (rand_val)) < pPSD->FireChance)
 	{
@@ -1052,7 +1112,7 @@ BuildObjectList (void)
 			hElement; hElement = hNextElement)
 	{
 		SIZE dx, dy;
-		ELEMENTPTR ElementPtr;
+		ELEMENT *ElementPtr;
 
 		LockElement (hElement, &ElementPtr);
 
@@ -1107,7 +1167,7 @@ BuildObjectList (void)
 		}
 
 		{
-			PPRIMITIVE pPrim;
+			PRIMITIVE *pPrim;
 
 			pPrim = &DisplayArray[ElementPtr->PrimIndex];
 			pPrim->Object.Stamp.origin.x =
@@ -1146,7 +1206,7 @@ RepairScan (void)
 	for (hElement = GetHeadElement ();
 			hElement; hElement = hNextElement)
 	{
-		ELEMENTPTR ElementPtr;
+		ELEMENT *ElementPtr;
 
 		LockElement (hElement, &ElementPtr);
 		hNextElement = GetSuccElement (ElementPtr);
@@ -1332,23 +1392,23 @@ ScrollPlanetSide (SIZE dx, SIZE dy, SIZE
 		CheckObjectCollision (END_OF_LIST);
 
 	{
-		PPLANETSIDE_DESC pPSD;
+		PLANETSIDE_DESC *pPSD;
 
-		pPSD = (PPLANETSIDE_DESC)pMenuState->ModuleFrame;
+		pPSD = (PLANETSIDE_DESC*)pMenuState->ModuleFrame;
 		if (pPSD->NumFrames)
 		{
 			--pPSD->NumFrames;
 			SetContextForeGroundColor (pPSD->ColorCycle[pPSD->NumFrames >> 1]);
 
-			pPSD->MineralText[0].baseline.x -= dx;
-			pPSD->MineralText[0].baseline.y -= dy;
-			font_DrawText (&pPSD->MineralText[0]);
-			pPSD->MineralText[1].baseline.x = pPSD->MineralText[0].baseline.x;
-			pPSD->MineralText[1].baseline.y = pPSD->MineralText[0].baseline.y + 7;
-			font_DrawText (&pPSD->MineralText[1]);
-			pPSD->MineralText[2].baseline.x = pPSD->MineralText[1].baseline.x;
-			pPSD->MineralText[2].baseline.y = pPSD->MineralText[1].baseline.y + 7;
-			font_DrawText (&pPSD->MineralText[2]);
+			pPSD->ElementText[0].baseline.x -= dx;
+			pPSD->ElementText[0].baseline.y -= dy;
+			font_DrawText (&pPSD->ElementText[0]);
+			pPSD->ElementText[1].baseline.x = pPSD->ElementText[0].baseline.x;
+			pPSD->ElementText[1].baseline.y = pPSD->ElementText[0].baseline.y + 7;
+			font_DrawText (&pPSD->ElementText[1]);
+			pPSD->ElementText[2].baseline.x = pPSD->ElementText[1].baseline.x;
+			pPSD->ElementText[2].baseline.y = pPSD->ElementText[1].baseline.y + 7;
+			font_DrawText (&pPSD->ElementText[2]);
 		}
 	}
 
@@ -1586,7 +1646,7 @@ InitPlanetSide (void)
 }
 
 static BOOLEAN
-DoPlanetSide (PMENU_STATE pMS)
+DoPlanetSide (MENU_STATE *pMS)
 {
 #define NUM_LANDING_DELTAS 10
 #define SHUTTLE_TURN_WAIT 2
@@ -1624,10 +1684,10 @@ SetVelocityComponents (
 #endif
 	}
 	else if (pMS->delta_item == 0
-			|| (HIBYTE (pMS->delta_item) 
-			&& ((CurrentInputState.key[PlayerOne][KEY_ESCAPE] ||
-			     CurrentInputState.key[PlayerOne][KEY_SPECIAL])
-			|| ((PPLANETSIDE_DESC)pMenuState->ModuleFrame)->InTransit)))
+			|| (HIBYTE (pMS->delta_item)
+			&& ((CurrentInputState.key[PlayerControls[0]][KEY_ESCAPE] ||
+			     CurrentInputState.key[PlayerControls[0]][KEY_SPECIAL])
+			|| ((PLANETSIDE_DESC*)pMenuState->ModuleFrame)->InTransit)))
 	{
 		if (pMS->delta_item || pMS->CurState > EXPLOSION_LIFE + 60)
 			return (FALSE);
@@ -1643,7 +1703,7 @@ SetVelocityComponents (
 				hExplosionElement = AllocElement ();
 				if (hExplosionElement)
 				{
-					ELEMENTPTR ExplosionElementPtr;
+					ELEMENT *ExplosionElementPtr;
 
 					LockElement (hExplosionElement, &ExplosionElementPtr);
 
@@ -1687,9 +1747,10 @@ SetVelocityComponents (
 			index = GetFrameIndex (LanderFrame[0]);
 			if (LONIBBLE (pMS->CurState))
 				pMS->CurState -= MAKE_BYTE (1, 0);
-			else if (CurrentInputState.key[PlayerOne][KEY_LEFT] || CurrentInputState.key[PlayerOne][KEY_RIGHT])
+			else if (CurrentInputState.key[PlayerControls[0]][KEY_LEFT] ||
+					CurrentInputState.key[PlayerControls[0]][KEY_RIGHT])
 			{
-				if (CurrentInputState.key[PlayerOne][KEY_LEFT])
+				if (CurrentInputState.key[PlayerControls[0]][KEY_LEFT])
 				{
 					dx = -1;
 					--index;
@@ -1729,7 +1790,7 @@ SetVelocityComponents (
 						);
 			}
 
-			if (!CurrentInputState.key[PlayerOne][KEY_UP])
+			if (!CurrentInputState.key[PlayerControls[0]][KEY_UP])
 				dx = dy = 0;
 			else
 				GetNextVelocityComponents (
@@ -1738,7 +1799,7 @@ SetVelocityComponents (
 
 			if (HINIBBLE (pMS->CurState))
 				pMS->CurState -= MAKE_BYTE (0, 1);
-			else if (CurrentInputState.key[PlayerOne][KEY_WEAPON])
+			else if (CurrentInputState.key[PlayerControls[0]][KEY_WEAPON])
 			{
 				HELEMENT hWeaponElement;
 
@@ -1746,7 +1807,7 @@ SetVelocityComponents (
 				if (hWeaponElement)
 				{
 					SIZE wdx, wdy;
-					ELEMENTPTR WeaponElementPtr;
+					ELEMENT *WeaponElementPtr;
 
 					LockElement (hWeaponElement, &WeaponElementPtr);
 
@@ -1767,7 +1828,7 @@ SetVelocityComponents (
 							index + ANGLE_TO_FACING (FULL_CIRCLE)
 							);
 
-					if (!CurrentInputState.key[PlayerOne][KEY_UP])
+					if (!CurrentInputState.key[PlayerControls[0]][KEY_UP])
 						wdx = wdy = 0;
 					else
 						GetCurrentVelocityComponents (
@@ -1851,15 +1912,9 @@ LoadLanderData (void)
 
 		{
 			COUNT i;
-			RES_TYPE rt;
-			RES_INSTANCE ri;
-			RES_PACKAGE rp;
-
-			rt = GET_TYPE (ORBIT1_MUSIC);
-			ri = GET_INSTANCE (ORBIT1_MUSIC);
-			rp = GET_PACKAGE (ORBIT1_MUSIC);
-			for (i = 0; i < NUM_ORBIT_THEMES; ++i, ++ri)
-				OrbitMusic[i] = LoadMusic (MAKE_RESOURCE (rp, rt, ri));
+
+			for (i = 0; i < NUM_ORBIT_THEMES; ++i)
+				OrbitMusic[i] = load_orbit_theme (i);
 		}
 	}
 }
@@ -1871,7 +1926,7 @@ SetPlanetMusic (BYTE planet_type)
 }
 
 static void
-ReturnToOrbit (PRECT pRect)
+ReturnToOrbit (RECT *pRect)
 {
 	CONTEXT OldContext;
 	
@@ -1896,7 +1951,7 @@ ReturnToOrbit (PRECT pRect)
 }
 
 void
-PlanetSide (PMENU_STATE pMS)
+PlanetSide (MENU_STATE *pMS)
 {
 	SIZE index;
 	DWORD TimeIn;
@@ -1905,7 +1960,7 @@ PlanetSide (PMENU_STATE pMS)
 	BYTE WeatherChanceTab[] = {0*3, 0*3, 1*3, 2*3, 3*3, 6*3, 12*3, 24*3};
 	BYTE FireChanceTab[] = {0*3, 0*3, 1*3, 2*3, 4*3, 12*3, 24*3, 48*3};
 
-	memset ((PPLANETSIDE_DESC)&PSD, 0, sizeof (PSD));
+	memset (&PSD, 0, sizeof (PSD));
 	PSD.InTransit = TRUE;
 
 	PSD.TectonicsChance =
@@ -1930,7 +1985,7 @@ PlanetSide (PMENU_STATE pMS)
 	else
 		PSD.FireChance = FireChanceTab[7];
 
-	PSD.ElementLevel = GetSBayCapacity (NULL_PTR)
+	PSD.ElementLevel = GetSBayCapacity (NULL)
 			- GLOBAL_SIS (TotalElementMass);
 	PSD.MaxElementLevel = MAX_SCROUNGED;
 	if (GET_GAME_STATE (IMPROVED_LANDER_CARGO))
@@ -1939,10 +1994,10 @@ PlanetSide (PMENU_STATE pMS)
 		PSD.MaxElementLevel = PSD.ElementLevel;
 	PSD.ElementLevel = 0;
 
-	PSD.MineralText[0].align = ALIGN_CENTER;
-	PSD.MineralText[0].pStr = PSD.AmountBuf;
-	PSD.MineralText[1] = PSD.MineralText[0];
-	PSD.MineralText[2] = PSD.MineralText[1];
+	PSD.ElementText[0].align = ALIGN_CENTER;
+	PSD.ElementText[0].pStr = PSD.AmountBuf;
+	PSD.ElementText[1] = PSD.ElementText[0];
+	PSD.ElementText[2] = PSD.ElementText[1];
 
 	PSD.ColorCycle[0] = BUILD_COLOR (MAKE_RGB15 (0x1F, 0x03, 0x00), 0x7F);
 	PSD.ColorCycle[1] = BUILD_COLOR (MAKE_RGB15 (0x1F, 0x0A, 0x00), 0x7D);
@@ -1993,7 +2048,7 @@ PlanetSide (PMENU_STATE pMS)
 	pMS->Initialized = FALSE;
 	pMS->InputFunc = DoPlanetSide;
 	SetMenuSounds (MENU_SOUND_NONE, MENU_SOUND_NONE);
-	DoInput ((PVOID)pMS, FALSE);
+	DoInput (pMS, FALSE);
 
 	if (!(GLOBAL (CurrentActivity) & CHECK_ABORT))
 	{
@@ -2081,7 +2136,7 @@ PlanetSide (PMENU_STATE pMS)
 		for (hElement = GetHeadElement ();
 				hElement; hElement = hNextElement)
 		{
-			ELEMENTPTR ElementPtr;
+			ELEMENT *ElementPtr;
 
 			LockElement (hElement, &ElementPtr);
 			hNextElement = _GetSuccLink (ElementPtr);
@@ -2174,9 +2229,8 @@ InitLander (BYTE LanderFlags)
 			DrawStamp (&s);
 		}
 
-		if ((int)(free_space = GetSBayCapacity (NULL_PTR)
-				- GLOBAL_SIS (TotalElementMass)) <
-				(int)(MAX_SCROUNGED << capacity_shift))
+		free_space = GetSBayCapacity (NULL) - GLOBAL_SIS (TotalElementMass);
+		if ((int)free_space < (int)(MAX_SCROUNGED << capacity_shift))
 		{
 			r.corner.x = 1;
 			r.extent.width = 4;
diff -ruNp src.orig/sc2code/planets/lander.h src/sc2code/planets/lander.h
--- src.orig/sc2code/planets/lander.h	2017-11-08 16:49:35 -0600
+++ src/sc2code/planets/lander.h	2017-11-08 16:50:03 -0600
@@ -42,18 +42,17 @@ typedef struct
 
 	COUNT NumFrames;
 	UNICODE AmountBuf[40];
-	TEXT MineralText[3];
+	TEXT ElementText[3];
 
 	COLOR ColorCycle[NUM_TEXT_FRAMES >> 1];
 
 	BYTE TectonicsChance, WeatherChance, FireChance;
 } PLANETSIDE_DESC;
-typedef PLANETSIDE_DESC *PPLANETSIDE_DESC;
 
 extern CONTEXT ScanContext;
 extern MUSIC_REF LanderMusic;
 
-extern void PlanetSide (PMENU_STATE pMS);
+extern void PlanetSide (MENU_STATE *pMS);
 extern void DoDiscoveryReport (SOUND ReadOutSounds);
 extern void SetPlanetMusic (BYTE planet_type);
 extern void LoadLanderData (void);
diff -ruNp src.orig/sc2code/planets/orbits.c src/sc2code/planets/orbits.c
--- src.orig/sc2code/planets/orbits.c	2017-11-08 16:49:36 -0600
+++ src/sc2code/planets/orbits.c	2017-11-08 16:50:03 -0600
@@ -73,7 +73,7 @@ BlueDistribution (BYTE which_world)
 		PLANET_ALWAYS, /* ULTRAVIOLET_WORLD */
 		PLANET_ALWAYS, /* PLUTONIC_WORLD */
 		PLANET_NEVER,  /* RAINBOW_WORLD */
-		PLANET_NEVER,  /* CRACKED_WORLD */
+		PLANET_NEVER,  /* SHATTERED_WORLD */
 		PLANET_ALWAYS, /* SAPPHIRE_WORLD */
 		PLANET_ALWAYS, /* ORGANIC_WORLD */
 		PLANET_ALWAYS, /* XENOLITHIC_WORLD */
@@ -144,7 +144,7 @@ GreenDistribution (BYTE which_world)
 		PLANET_ALWAYS, /* ULTRAVIOLET_WORLD */
 		PLANET_ALWAYS, /* PLUTONIC_WORLD */
 		PLANET_NEVER,  /* RAINBOW_WORLD */
-		PLANET_NEVER,  /* CRACKED_WORLD */
+		PLANET_NEVER,  /* SHATTERED_WORLD */
 		PLANET_NEVER,  /* SAPPHIRE_WORLD */
 		PLANET_ALWAYS, /* ORGANIC_WORLD */
 		PLANET_ALWAYS, /* XENOLITHIC_WORLD */
@@ -215,7 +215,7 @@ OrangeDistribution (BYTE which_world)
 		PLANET_NEVER,  /* ULTRAVIOLET_WORLD */
 		PLANET_NEVER,  /* PLUTONIC_WORLD */
 		PLANET_NEVER,  /* RAINBOW_WORLD */
-		PLANET_NEVER,  /* CRACKED_WORLD */
+		PLANET_NEVER,  /* SHATTERED_WORLD */
 		PLANET_NEVER,  /* SAPPHIRE_WORLD */
 		PLANET_NEVER,  /* ORGANIC_WORLD */
 		PLANET_NEVER,  /* XENOLITHIC_WORLD */
@@ -286,7 +286,7 @@ RedDistribution (BYTE which_world)
 		PLANET_NEVER,  /* ULTRAVIOLET_WORLD */
 		PLANET_NEVER,  /* PLUTONIC_WORLD */
 		PLANET_NEVER,  /* RAINBOW_WORLD */
-		PLANET_NEVER,  /* CRACKED_WORLD */
+		PLANET_NEVER,  /* SHATTERED_WORLD */
 		PLANET_NEVER,  /* SAPPHIRE_WORLD */
 		PLANET_NEVER,  /* ORGANIC_WORLD */
 		PLANET_NEVER,  /* XENOLITHIC_WORLD */
@@ -357,7 +357,7 @@ WhiteDistribution (BYTE which_world)
 		PLANET_ALWAYS, /* ULTRAVIOLET_WORLD */
 		PLANET_ALWAYS, /* PLUTONIC_WORLD */
 		PLANET_NEVER,  /* RAINBOW_WORLD */
-		PLANET_NEVER,  /* CRACKED_WORLD */
+		PLANET_NEVER,  /* SHATTERED_WORLD */
 		PLANET_ALWAYS, /* SAPPHIRE_WORLD */
 		PLANET_ALWAYS, /* ORGANIC_WORLD */
 		PLANET_ALWAYS, /* XENOLITHIC_WORLD */
@@ -428,7 +428,7 @@ YellowDistribution (BYTE which_world)
 		PLANET_NEVER,  /* ULTRAVIOLET_WORLD */
 		PLANET_NEVER,  /* PLUTONIC_WORLD */
 		PLANET_NEVER,  /* RAINBOW_WORLD */
-		PLANET_NEVER,  /* CRACKED_WORLD */
+		PLANET_NEVER,  /* SHATTERED_WORLD */
 		PLANET_NEVER,  /* SAPPHIRE_WORLD */
 		PLANET_ALWAYS, /* ORGANIC_WORLD */
 		PLANET_ALWAYS, /* XENOLITHIC_WORLD */
@@ -470,13 +470,13 @@ YellowDistribution (BYTE which_world)
 #define SUPERGIANT_GASG_DIST SCALE_RADIUS (33)
 
 void
-FillOrbits (PSOLARSYS_STATE system,
-		BYTE NumPlanets, PPLANET_DESC pBaseDesc, BOOLEAN TypesDefined)
+FillOrbits (SOLARSYS_STATE *system, BYTE NumPlanets,
+		PLANET_DESC *pBaseDesc, BOOLEAN TypesDefined)
 { /* Generate Planets in orbit around star */
 	BYTE StarColor, PlanetCount, MaxPlanet;
 	BOOLEAN GeneratingMoons;
 	COUNT StarSize;
-	PPLANET_DESC pPD;
+	PLANET_DESC *pPD;
 	struct
 	{
 		COUNT MinRockyDist, MinGasGDist;
@@ -523,7 +523,7 @@ char scolor[] = {'B', 'G', 'O', 'R', 'W'
 		DWORD rand_val;
 		COUNT min_radius, angle;
 		SIZE delta_r;
-		PPLANET_DESC pLocPD;
+		PLANET_DESC *pLocPD;
 
 		do
 		{
diff -ruNp src.orig/sc2code/planets/oval.c src/sc2code/planets/oval.c
--- src.orig/sc2code/planets/oval.c	2017-11-08 16:49:36 -0600
+++ src/sc2code/planets/oval.c	2017-11-08 16:50:03 -0600
@@ -25,7 +25,7 @@
 #define NUM_QUADS 4
 
 void
-DrawOval (PRECT pRect, BYTE num_off_pixels)
+DrawOval (RECT *pRect, BYTE num_off_pixels)
 {
 #define FIRST_QUAD (1 << 0)
 #define SECOND_QUAD (1 << 1)
@@ -216,7 +216,7 @@ DrawOval (PRECT pRect, BYTE num_off_pixe
 }
 
 void
-DrawFilledOval (PRECT pRect)
+DrawFilledOval (RECT *pRect)
 {
 	COORD x, y;
 	SIZE A, B;
diff -ruNp src.orig/sc2code/planets/pl_stuff.c src/sc2code/planets/pl_stuff.c
--- src.orig/sc2code/planets/pl_stuff.c	2017-11-08 16:49:36 -0600
+++ src/sc2code/planets/pl_stuff.c	2017-11-08 16:50:03 -0600
@@ -37,8 +37,8 @@ extern DWORD frame_mapRGBA (FRAME FrameP
 		UBYTE b, UBYTE a);
 extern void fill_frame_rgb (FRAME FramePtr, DWORD color, int x0, int y0,
 		int x, int y);
-extern void arith_frame_blit (FRAME srcFrame, RECT *rsrc, FRAME dstFrame,
-		RECT *rdst, int num, int denom);
+extern void arith_frame_blit (FRAME srcFrame, const RECT *rsrc,
+		FRAME dstFrame, const RECT *rdst, int num, int denom);
 
 
 // RotatePlanet
@@ -48,16 +48,19 @@ extern void arith_frame_blit (FRAME srcF
 // The speed to zoom in.
 #define PLANET_ZOOM_SPEED 2
 
-PRECT
-RotatePlanet (int x, int dx, int dy, COUNT scale_amt, UBYTE zoom_from, PRECT zoomr)
+RECT*
+RotatePlanet (int x, int dx, int dy, COUNT scale_amt, UBYTE zoom_from,
+		RECT *zoomr)
 {
 	STAMP s;
 	FRAME pFrame[2];
-	COUNT i, num_frames, old_scale;
+	COUNT i, num_frames;
+	int old_scale, old_mode;
 	RECT *rp = NULL;
 	CONTEXT OldContext;
 	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
 	int base = GSCALE_IDENTITY;
+	extern FRAME coarse_scan;
 
 	num_frames = 1;
 	pFrame[0] = Orbit->PlanetFrameArray;
@@ -88,7 +91,7 @@ RotatePlanet (int x, int dx, int dy, COU
 	// operation is moved before the RenderLevelMasks call, one of
 	// the two PauseRotate checks can be removed.
 
-	//if (((PSOLARSYS_STATE volatile)pSolarSysState)->PauseRotate !=1)
+	//if (((SOLARSYS_STATE *volatile)pSolarSysState)->PauseRotate !=1)
 	{
 		OldContext = SetContext (SpaceContext);
 		BatchGraphics ();
@@ -96,14 +99,22 @@ RotatePlanet (int x, int dx, int dy, COU
 			RepairBackRect (rp);
 		s.origin.x = dx;
 		s.origin.y = dy;
-		old_scale = GetGraphicScale ();
-		SetGraphicScale (scale_amt);
+		old_mode = SetGraphicScaleMode (TFB_SCALE_BILINEAR);
+		old_scale = SetGraphicScale (scale_amt);
 		for (i = 0; i < num_frames; i++)
 		{
 			s.frame = pFrame[i];
 			DrawStamp (&s);
 		}
 		SetGraphicScale (old_scale);
+		SetGraphicScaleMode (old_mode);
+		// If the player is scanning the planet, print the coarse scan.
+		if (pMenuState && pMenuState->InputFunc == DoScan)
+		{
+			s.origin.x = s.origin.y = 0;
+			s.frame = coarse_scan;
+			DrawStamp (&s);
+		}
 		UnbatchGraphics ();
 		SetContext (OldContext);
 	}
diff -ruNp src.orig/sc2code/planets/plandata.h src/sc2code/planets/plandata.h
--- src.orig/sc2code/planets/plandata.h	2017-11-08 16:49:36 -0600
+++ src/sc2code/planets/plandata.h	2017-11-08 16:50:03 -0600
@@ -149,7 +149,7 @@ enum
 	ULTRAVIOLET_WORLD,
 	PLUTONIC_WORLD,
 	RAINBOW_WORLD,
-	CRACKED_WORLD,
+	SHATTERED_WORLD,
 	SAPPHIRE_WORLD,
 	ORGANIC_WORLD,
 	XENOLITHIC_WORLD,
@@ -180,7 +180,21 @@ enum
 	YEL_GAS_GIANT,
 	LAST_GAS_GIANT = YEL_GAS_GIANT,
 
-	NUMBER_OF_PLANET_TYPES
+	NUMBER_OF_PLANET_TYPES,
+
+	WORLD_TYPE_SPECIAL = 0x80,
+	PLANET_SHIELDED    = WORLD_TYPE_SPECIAL,
+
+	HIERARCHY_STARBASE = 127 | WORLD_TYPE_SPECIAL,
+	SA_MATRA           = 126 | WORLD_TYPE_SPECIAL,
+	DESTROYED_STARBASE = 125 | WORLD_TYPE_SPECIAL,
+	PRECURSOR_STARBASE = 124 | WORLD_TYPE_SPECIAL,
+	ZOQFOTPIK_STARBASE = 123 | WORLD_TYPE_SPECIAL,
+	PKUNK_STARBASE     = 122 | WORLD_TYPE_SPECIAL,
+	DRUUGE_STARBASE    = 121 | WORLD_TYPE_SPECIAL,
+	UTWIG_STARBASE     = 120 | WORLD_TYPE_SPECIAL,
+	SUPOX_STARBASE     = UTWIG_STARBASE,
+	ORZ_STARBASE       = 119 | WORLD_TYPE_SPECIAL,
 };
 
 #define NUMBER_OF_SMALL_ROCKY_WORLDS (LAST_SMALL_ROCKY_WORLD - FIRST_SMALL_ROCKY_WORLD + 1)
@@ -193,7 +207,6 @@ typedef struct
 	const SIZE level_tab[3];
 	const BYTE xlat_tab[256];
 } XLAT_DESC;
-typedef const XLAT_DESC *PXLAT_DESC;
 
 typedef struct
 {
@@ -204,7 +217,7 @@ typedef struct
 			 *           deposits), one of FEW, MODERATE, or NUMEROUS
 			 * bits 4-7: quality of the deposit, one of LOW, MEDIUM, or HEAVY
 			 */
-} ElementEntry;
+} ELEMENT_ENTRY;
 
 // PlanetFrame describes a type of planet. It is not used to describe
 // individual planets.
@@ -234,7 +247,7 @@ typedef struct
 			 *           (no define for this) super thick.
 			 */
 #define NUM_USEFUL_ELEMENTS 8
-	ElementEntry UsefulElements[NUM_USEFUL_ELEMENTS];
+	ELEMENT_ENTRY UsefulElements[NUM_USEFUL_ELEMENTS];
 			/* Minerals on the planet */
 
 	RESOURCE CMapInstance;
@@ -248,13 +261,6 @@ typedef struct
 	COUNT num_blemishes;
 	SIZE base_elevation;
 } PlanetFrame;
-typedef const PlanetFrame *PPLANDATA;
-
-typedef const ElementEntry *PELEMENT_ENTRY;
-
-#define XLAT_DESCPTR PXLAT_DESC
-#define PLANDATAPTR PPLANDATA
-#define ELEMENT_ENTRYPTR PELEMENT_ENTRY
 
 typedef struct
 {
@@ -270,7 +276,7 @@ typedef struct
 	SIZE LifeChance;
 	UWORD PlanetToSunDist;
 
-	PLANDATAPTR PlanDataPtr;
+	const PlanetFrame *PlanDataPtr;
 
 	DWORD ScanSeed[NUM_SCAN_TYPES];
 	DWORD ScanRetrieveMask[NUM_SCAN_TYPES];
@@ -300,7 +306,6 @@ typedef struct
 	FONT LanderFont;
 	FRAME LanderFontEff;
 } PLANET_INFO;
-typedef PLANET_INFO *PPLANET_INFO;
 
 enum
 {
@@ -315,8 +320,6 @@ enum
 #define CalcGravity(d,r) (UWORD)((DWORD)(d) * (r) / 100)
 #define CalcFromBase(b,v) ((UWORD)(b) + ((UWORD)TFB_Random () % (v)))
 
-#define PLANET_INFOPTR PPLANET_INFO
-
 #define EARTH_ATMOSPHERE 50
 
 #define COLD_THRESHOLD -40
diff -ruNp src.orig/sc2code/planets/planets.c src/sc2code/planets/planets.c
--- src.orig/sc2code/planets/planets.c	2017-11-08 16:49:36 -0600
+++ src/sc2code/planets/planets.c	2017-11-08 16:50:03 -0600
@@ -26,9 +26,10 @@
 #include "resinst.h"
 #include "nameref.h"
 
+void uninit_coarse_scan (void);
+extern FRAME coarse_scan;
 
-extern int rotate_planet_task (PVOID data);
-
+extern int rotate_planet_task (void *data);
 
 void
 DrawScannedObjects (BOOLEAN Reversed)
@@ -38,7 +39,7 @@ DrawScannedObjects (BOOLEAN Reversed)
 	for (hElement = Reversed ? GetTailElement () : GetHeadElement ();
 			hElement; hElement = hNextElement)
 	{
-		ELEMENTPTR ElementPtr;
+		ELEMENT *ElementPtr;
 
 		LockElement (hElement, &ElementPtr);
 		hNextElement = Reversed ?
@@ -79,7 +80,7 @@ DrawOrbitalDisplay (DRAW_ORBITAL_MODE Mo
 		SetTransitionSource (NULL);
 
 		DrawSISFrame ();
-		DrawSISMessage (NULL_PTR);
+		DrawSISMessage (NULL);
 		DrawSISTitle (GLOBAL_SIS (PlanetName));
 		DrawStarBackGround (TRUE);
 	}
@@ -148,11 +149,11 @@ LoadPlanet (FRAME SurfDefFrame)
 		// The "rotate planets" task is not initialised yet.
 		// This means the call to LoadPlanet is made from a
 		// GENERATE_ORBITAL case of an IP generation function.
-		PPLANET_DESC pPlanetDesc;
+		PLANET_DESC *pPlanetDesc;
 
 		StopMusic ();
 
-		TaskContext = CaptureContext (CreateContext ());
+		TaskContext = CreateContext ();
 
 		pPlanetDesc = pSolarSysState->pOrbitalDesc;
 
@@ -229,6 +230,7 @@ FreePlanet (void)
 
 //    FreeLanderData ();
 
+	uninit_coarse_scan ();
 	DestroyStringTable (ReleaseStringTable (pSolarSysState->XlatRef));
 	pSolarSysState->XlatRef = 0;
 	DestroyDrawable (ReleaseDrawable (pSolarSysState->TopoFrame));
@@ -263,7 +265,7 @@ FreePlanet (void)
 		Orbit->ScratchArray = 0;
 	}
 
-	DestroyContext (ReleaseContext (TaskContext));
+	DestroyContext (TaskContext);
 	TaskContext = 0;
 	
 	DestroyStringTable (ReleaseStringTable (
@@ -279,7 +281,7 @@ FreePlanet (void)
 void
 LoadStdLanderFont (PLANET_INFO *info)
 {
-	info->LanderFont = CaptureFont (LoadFont (LANDER_FONT));
+	info->LanderFont = LoadFont (LANDER_FONT);
 	info->LanderFontEff = CaptureDrawable (
 			LoadGraphic (LANDER_FONTEFF_PMAP_ANIM));
 }
@@ -287,8 +289,8 @@ LoadStdLanderFont (PLANET_INFO *info)
 void
 FreeLanderFont (PLANET_INFO *info)
 {
-	DestroyFont (ReleaseFont (info->LanderFont));
-	info->LanderFont = 0;
+	DestroyFont (info->LanderFont);
+	info->LanderFont = NULL;
 	DestroyDrawable (ReleaseDrawable (info->LanderFontEff));
-	info->LanderFontEff = 0;
+	info->LanderFontEff = NULL;
 }
diff -ruNp src.orig/sc2code/planets/planets.h src/sc2code/planets/planets.h
--- src.orig/sc2code/planets/planets.h	2017-11-08 16:49:36 -0600
+++ src/sc2code/planets/planets.h	2017-11-08 16:50:03 -0600
@@ -53,18 +53,28 @@ enum
 enum
 {
 	GENERATE_PLANETS = 0,
+			// Layout of planets within a solar system.
 	GENERATE_MOONS,
+			// Layout of moons around a planet.
 	GENERATE_ORBITAL,
+			// Characteristics of words (planets and moons).
 
 	INIT_NPCS,
+			// Ships in the solar system, the first time it is accessed.
 	REINIT_NPCS,
+			// Ships in the solar system, every next time it is accessed.
 	UNINIT_NPCS,
+			// When leaving the solar system.
 
 	GENERATE_MINERAL,
+			// Minerals on the planet surface.
 	GENERATE_ENERGY,
+			// Energy sources on the planet surface.
 	GENERATE_LIFE,
+			// Bio on the planet surface.
 
 	GENERATE_NAME
+			// Name of a planet.
 };
 
 enum
@@ -74,7 +84,7 @@ enum
 	LIGHTNING_DISASTER,
 	LAVASPOT_DISASTER,
 
-		/* additional lander sounds */
+	/* additional lander sounds */
 	LANDER_INJURED,
 	LANDER_SHOOTS,
 	LANDER_HITS,
@@ -103,8 +113,6 @@ enum
 #define MIN_MOON_RADIUS 35
 #define MOON_DELTA 20
 
-#define PLANET_SHIELDED (1 << 7)
-
 typedef struct planet_desc
 {
 	DWORD rand_seed;
@@ -120,7 +128,6 @@ typedef struct planet_desc
 
 	struct planet_desc *pPrevDesc;
 } PLANET_DESC;
-typedef PLANET_DESC *PPLANET_DESC;
 
 typedef struct
 {
@@ -128,8 +135,6 @@ typedef struct
 	BYTE Type, Index;
 	BYTE Prefix, Postfix;
 } STAR_DESC;
-typedef STAR_DESC *PSTAR_DESC;
-#define STAR_DESCPTR PSTAR_DESC
 
 #define MAX_SUNS 1
 #define MAX_PLANETS 16
@@ -145,7 +150,7 @@ typedef struct planet_orbit
 {
 	FRAME TopoZoomFrame;
 			// 4x scaled topo image for planet-side
-	PBYTE lpTopoData;
+	BYTE  *lpTopoData;
 			// normal topo data; expressed in elevation levels
 			// data is signed for planets other than gas giants
 			// transformed to light variance map for 3d planet
@@ -181,8 +186,8 @@ typedef struct solarsys_state
 			// by pBaseDesc.
 			// Only defined after a call to GenFunc with GENERATE_MOONS
 			// as its argument, and overwritten by subsequent calls.
-	PPLANET_DESC pBaseDesc;
-	PPLANET_DESC pOrbitalDesc;
+	PLANET_DESC *pBaseDesc;
+	PLANET_DESC *pOrbitalDesc;
 	SIZE FirstPlanetIndex, LastPlanetIndex;
 			// The planets get sorted on their image.origin.y value.
 			// PlanetDesc[FirstPlanetIndex] is the planet with the lowest
@@ -211,9 +216,8 @@ typedef struct solarsys_state
 	FRAME TopoFrame;
 	PLANET_ORBIT Orbit;
 } SOLARSYS_STATE;
-typedef SOLARSYS_STATE *PSOLARSYS_STATE;
 
-extern PSOLARSYS_STATE pSolarSysState;
+extern SOLARSYS_STATE *pSolarSysState;
 extern MUSIC_REF SpaceMusic;
 
 extern void LoadPlanet (FRAME SurfDefFrame);
@@ -224,18 +228,18 @@ extern void FreeLanderFont (PLANET_INFO
 
 extern void ExploreSolarSys (void);
 extern void DrawStarBackGround (BOOLEAN ForPlanet);
-extern void XFormIPLoc (PPOINT pIn, PPOINT pOut, BOOLEAN ToDisplay);
+extern void XFormIPLoc (POINT *pIn, POINT *pOut, BOOLEAN ToDisplay);
 extern void GenerateRandomIP (BYTE control);
 extern PLAN_GEN_FUNC GenerateIP (BYTE Index);
 extern void DrawSystem (SIZE radius, BOOLEAN IsInnerSystem);
-extern void DrawOval (PRECT pRect, BYTE num_off_pixels);
-extern void DrawFilledOval (PRECT pRect);
+extern void DrawOval (RECT *pRect, BYTE num_off_pixels);
+extern void DrawFilledOval (RECT *pRect);
 extern void DoMissions (void);
-extern void FillOrbits (PSOLARSYS_STATE system,
-		BYTE NumPlanets, PPLANET_DESC pBaseDesc, BOOLEAN TypesDefined);
+extern void FillOrbits (SOLARSYS_STATE *system, BYTE NumPlanets,
+		PLANET_DESC *pBaseDesc, BOOLEAN TypesDefined);
 extern void ScanSystem (void);
 extern void ChangeSolarSys (void);
-extern BOOLEAN DoFlagshipCommands (PMENU_STATE pMS);
+extern BOOLEAN DoFlagshipCommands (MENU_STATE *pMS);
 extern void ZoomSystem (void);
 extern void LoadSolarSys (void);
 extern void InitLander (BYTE LanderFlags);
@@ -243,13 +247,13 @@ extern BOOLEAN ValidateOrbits (void);
 extern void IP_reset (void);
 extern void IP_frame (void);
 
-extern PRECT RotatePlanet (int x, int dx, int dy, COUNT scale_amt,
-		UBYTE zoom_from, PRECT r);
+extern RECT* RotatePlanet (int x, int dx, int dy, COUNT scale_amt,
+		UBYTE zoom_from, RECT *r);
 extern void SetPlanetTilt (int da);
 extern void DrawScannedObjects (BOOLEAN Reversed);
-extern void GeneratePlanetMask (PPLANET_DESC pPlanetDesc, FRAME SurfDefFrame);
-extern void DeltaTopography (COUNT num_iterations, PSBYTE DepthArray,
-		PRECT pRect, SIZE depth_delta);
+extern void GeneratePlanetMask (PLANET_DESC *pPlanetDesc, FRAME SurfDefFrame);
+extern void DeltaTopography (COUNT num_iterations, SBYTE *DepthArray,
+		RECT *pRect, SIZE depth_delta);
 
 #endif /* _PLANETS_H */
 
diff -ruNp src.orig/sc2code/planets/plangen.c src/sc2code/planets/plangen.c
--- src.orig/sc2code/planets/plangen.c	2017-11-08 16:49:36 -0600
+++ src/sc2code/planets/plangen.c	2017-11-08 16:50:03 -0600
@@ -30,7 +30,7 @@
 #include <time.h>
 
 
-#define PROFILE_ROTATION  1
+#undef PROFILE_ROTATION
 #define ROTATION_TIME 12
 
 // The initial size of the planet when zooming.  MUST BE ODD
@@ -48,9 +48,9 @@ extern void process_rgb_bmp (FRAME Frame
 extern FRAME stretch_frame (FRAME FramePtr, int neww, int newh, int destroy);
 extern void fill_frame_rgb (FRAME FramePtr, DWORD color, int x0, int y0,
 		int x, int y);
-extern void arith_frame_blit (FRAME srcFrame, RECT *rsrc, FRAME dstFrame,
-		RECT *rdst, int num, int denom);
-extern void getpixelarray (void *map, int Bpp, FRAMEPTR FramePtr,
+extern void arith_frame_blit (FRAME srcFrame, const RECT *rsrc,
+		FRAME dstFrame, const RECT *rdst, int num, int denom);
+extern void getpixelarray (void *map, int Bpp, FRAME FramePtr,
 		int width, int height);
 
 
@@ -106,7 +106,7 @@ typedef struct
 } POINT3;
 
 static void
-TransformTopography (FRAME DstFrame, PBYTE pTopoData, int w, int h)
+TransformTopography (FRAME DstFrame, BYTE *pTopoData, int w, int h)
 {
 	CONTEXT OldContext;
 	FRAME OldFrame;
@@ -132,16 +132,18 @@ TransformTopography (FRAME DstFrame, PBY
 		BYTE AlgoType;
 		SIZE base, d;
 		POINT pt;
-		PLANDATAPTR PlanDataPtr;
+		const PlanetFrame *PlanDataPtr;
 		PRIMITIVE BatchArray[NUM_BATCH_POINTS];
-		PPRIMITIVE pBatch;
-		PBYTE pSrc, xlat_tab, cbase;
+		PRIMITIVE *pBatch;
+		BYTE *pSrc;
+		BYTE *xlat_tab;
+		BYTE *cbase;
 		HOT_SPOT OldHot;
 		RECT ClipRect;
 
 		OldHot = SetFrameHot (DstFrame, MAKE_HOT_SPOT (0, 0));
 		GetContextClipRect (&ClipRect);
-		SetContextClipRect (NULL_PTR);
+		SetContextClipRect (NULL);
 		SetContextClipping (FALSE);
 
 		pBatch = &BatchArray[0];
@@ -157,7 +159,7 @@ TransformTopography (FRAME DstFrame, PBY
 				];
 		AlgoType = PLANALGO (PlanDataPtr->Type);
 		base = PlanDataPtr->base_elevation;
-		xlat_tab = (PBYTE)((XLAT_DESCPTR)pSolarSysState->XlatPtr)->xlat_tab;
+		xlat_tab = (BYTE*)((XLAT_DESC*)pSolarSysState->XlatPtr)->xlat_tab;
 		cbase = GetColorMapAddress (pSolarSysState->OrbitalCMap);
 
 		i = NUM_BATCH_POINTS;
@@ -167,7 +169,7 @@ TransformTopography (FRAME DstFrame, PBY
 		{
 			for (pt.x = 0; pt.x < w; ++pt.x, ++pSrc)
 			{
-				PBYTE ctab;
+				BYTE *ctab;
 
 				d = (SBYTE)*pSrc;
 				if (AlgoType == GAS_GIANT_ALGO)
@@ -881,10 +883,10 @@ RenderLevelMasks (FRAME MaskFrame, int o
 #define RANGE_SHIFT 6
 
 static void
-DitherMap (PSBYTE DepthArray)
+DitherMap (SBYTE *DepthArray)
 {
 	COUNT i;
-	PSBYTE lpDst;
+	SBYTE *lpDst;
 
 	i = (MAP_WIDTH * MAP_HEIGHT) >> 2;
 	lpDst = DepthArray;
@@ -909,7 +911,7 @@ DitherMap (PSBYTE DepthArray)
 }
 
 static void
-MakeCrater (PRECT pRect, PSBYTE DepthArray, SIZE rim_delta, SIZE
+MakeCrater (RECT *pRect, SBYTE *DepthArray, SIZE rim_delta, SIZE
 		crater_delta, BOOLEAN SetDepth)
 {
 	COORD x, y, lf_x, rt_x;
@@ -947,10 +949,8 @@ MakeCrater (PRECT pRect, PSBYTE DepthArr
 			rt_x = A + x;
 			if (SetDepth)
 			{
-				memset ((PSBYTE)&DepthArray[TopIndex + lf_x], 0,
-						rt_x - lf_x + 1);
-				memset ((PSBYTE)&DepthArray[BotIndex + lf_x], 0,
-						rt_x - lf_x + 1);
+				memset (&DepthArray[TopIndex + lf_x], 0, rt_x - lf_x + 1);
+				memset (&DepthArray[BotIndex + lf_x], 0, rt_x - lf_x + 1);
 			}
 			if (lf_x == rt_x)
 			{
@@ -1011,8 +1011,8 @@ MakeCrater (PRECT pRect, PSBYTE DepthArr
 		rt_x = A + x;
 		if (SetDepth)
 		{
-			memset ((PSBYTE)&DepthArray[TopIndex + lf_x], 0, rt_x - lf_x + 1);
-			memset ((PSBYTE)&DepthArray[BotIndex + lf_x], 0, rt_x - lf_x + 1);
+			memset (&DepthArray[TopIndex + lf_x], 0, rt_x - lf_x + 1);
+			memset (&DepthArray[BotIndex + lf_x], 0, rt_x - lf_x + 1);
 		}
 		if (lf_x == rt_x)
 		{
@@ -1069,7 +1069,7 @@ MakeCrater (PRECT pRect, PSBYTE DepthArr
 	lf_x = A - x;
 	rt_x = A + x;
 	if (SetDepth)
-		memset ((PSBYTE)&DepthArray[TopIndex + lf_x], 0, rt_x - lf_x + 1);
+		memset (&DepthArray[TopIndex + lf_x], 0, rt_x - lf_x + 1);
 	if (lf_x == rt_x)
 	{
 		DepthArray[TopIndex + lf_x] += rim_delta;
@@ -1103,12 +1103,12 @@ MakeCrater (PRECT pRect, PSBYTE DepthArr
 #define NUM_BAND_COLORS 4
 
 static void
-MakeStorms (COUNT storm_count, PSBYTE DepthArray)
+MakeStorms (COUNT storm_count, SBYTE *DepthArray)
 {
 #define MAX_STORMS 8
 	COUNT i;
 	RECT storm_r[MAX_STORMS];
-	PRECT pstorm_r;
+	RECT *pstorm_r;
 
 	pstorm_r = &storm_r[i = storm_count];
 	while (i--)
@@ -1227,13 +1227,13 @@ MakeStorms (COUNT storm_count, PSBYTE De
 }
 
 static void
-MakeGasGiant (COUNT num_bands, PSBYTE DepthArray, PRECT pRect, SIZE
+MakeGasGiant (COUNT num_bands, SBYTE *DepthArray, RECT *pRect, SIZE
 		depth_delta)
 {
 	COORD last_y, next_y;
 	SIZE band_error, band_bump, band_delta;
 	COUNT i, j, band_height;
-	PSBYTE lpDst;
+	SBYTE *lpDst;
 	UWORD loword, hiword;
 	DWORD rand_val;
 
@@ -1296,14 +1296,217 @@ MakeGasGiant (COUNT num_bands, PSBYTE De
 	DitherMap (DepthArray);
 }
 
+/* CreateRingMask
+ * This creates the rings around gas giants.
+ *
+ * How it works:
+ * -------------
+ * Two ellipses are drawn, an "inner" ellipse, which is transparent, and
+ * an "outer" ellipse, which is opaque.  The "back" of the outer
+ * ellipse is also made transparent to simulate the planet obscuring
+ * its view. (i.e., if it's where the planet should be, and it's in
+ * the "upper" half of the ring, set to invisible) The ellipses are
+ * rotated according to the AxialTilt parameter for the planet,
+ * and the ring colours are variations on a base colour pulled from
+ * the planet's colourmap.
+ *
+ * Geometry For Dummies:
+ * ---------------------
+ * the equation for an ellipse is:
+ *
+ *    x^2   y^2
+ *    --- + --- = 1
+ *    a^2   b^2
+ *
+ * the equation for the rotation of a point (x,y) is:
+ *
+ *    x' = x*cos(theta) - y*sin(theta)
+ *    y' = x*sin(theta) + y*cos(theta)
+ *
+ * combining these gives the equation for a rotated ellipse:
+ *
+ *    (x*cos(theta) - y*sin(theta))^2   (x*sin(theta) + y*cos(theta))^2
+ *    ------------------------------- + ------------------------------- = 1
+ *                 a^2                               b^2
+ *
+ */
+#define RING_OUTER_SEMIMAJOR 64
+#define RING_OUTER_MAJOR ((RING_OUTER_SEMIMAJOR << 1) + 1)
+#define RING_OUTER_SEMIMINOR 10
+#define RING_OUTER_SEMIMAJOR_2 (RING_OUTER_SEMIMAJOR * RING_OUTER_SEMIMAJOR)
+#define RING_OUTER_SEMIMINOR_2 (RING_OUTER_SEMIMINOR * RING_OUTER_SEMIMINOR)
+
+#define RING_INNER_SEMIMAJOR (RADIUS + 6)
+#define RING_INNER_SEMIMINOR (RING_OUTER_SEMIMINOR - 2)
+#define RING_INNER_SEMIMAJOR_2 (RING_INNER_SEMIMAJOR * RING_INNER_SEMIMAJOR)
+#define RING_INNER_SEMIMINOR_2 (RING_INNER_SEMIMINOR * RING_INNER_SEMIMINOR)
+#define RING_INNER_OFF_X 0
+#define RING_INNER_OFF_Y -2
+
+static FRAME
+CreateRingMask (void)
+{
+	DWORD rad2, clear, *rgba, *p_rgba, p;
+	float is_outer, is_inner, theta, ctheta, stheta;
+	float o_semimajor;
+	UBYTE max, r, g, b;
+	int x, y, origin_y;
+	FRAME RingFrame;
+	BYTE *cbase;
+
+	/* Use the first colour in planet's colourmp as the "base
+	 * colour" for the rings (yes, the rings are monochromatic).
+	 * According to strtab.txt, The RGB values in the colourmap
+	 * are 6 bits wide; padding them to 8 bits makes them look
+	 * too "bright", so they're only padded to 7 bits wide here.
+	 */
+	cbase = GetColorMapAddress (pSolarSysState->OrbitalCMap) + 2;
+	r = cbase[0] << 1;
+	g = cbase[1] << 1;
+	b = cbase[2] << 1;
+
+	/* at a 45-degree angle, the ellipse can be ~30% larger and
+	 * still fit inside the bounding box.  let's take advantge
+	 * of that, and set the width of the ellipse to the distance
+	 * between the two edges of the bounding box at that angle
+	 */
+	if ((pSolarSysState->SysInfo.PlanetInfo.AxialTilt % 90) > 45)
+		o_semimajor = RING_OUTER_SEMIMAJOR /
+				sin((pSolarSysState->SysInfo.PlanetInfo.AxialTilt % 90) *
+				M_DEG2RAD);
+	else
+		o_semimajor = RING_OUTER_SEMIMAJOR /
+				cos((pSolarSysState->SysInfo.PlanetInfo.AxialTilt % 90) *
+				M_DEG2RAD);
+
+	theta = pSolarSysState->SysInfo.PlanetInfo.AxialTilt * M_DEG2RAD;
+	ctheta = cos(theta);
+	stheta = sin(theta);
+	RingFrame = CaptureDrawable (
+            CreateDrawable (WANT_PIXMAP | WANT_ALPHA,
+                RING_OUTER_MAJOR, RING_OUTER_MAJOR, 1));
+	rgba = pSolarSysState->Orbit.ScratchArray;
+	p_rgba = rgba;
+	
+	max = 0xFF;
+	clear = frame_mapRGBA (RingFrame, 0, 0, 0, 0);
+
+	for (y = -RING_OUTER_SEMIMAJOR; y <= RING_OUTER_SEMIMAJOR; y++)
+	{
+		float o_yctheta, o_ystheta, i_yctheta, i_ystheta;
+		o_yctheta = y * ctheta;
+		o_ystheta = y * stheta;
+		i_yctheta = (y - RING_INNER_OFF_Y) * ctheta;
+		i_ystheta = (y - RING_INNER_OFF_Y) * stheta;
+
+		for (x = -RING_OUTER_SEMIMAJOR; x <= RING_OUTER_SEMIMAJOR; x++)
+		{
+			float o_xctheta, o_xstheta, i_xctheta, i_xstheta;
+			o_xctheta = x * ctheta;
+			o_xstheta = x * stheta;
+			i_xctheta = (x - RING_INNER_OFF_X) * ctheta;
+			i_xstheta = (x - RING_INNER_OFF_X) * stheta;
+
+			is_outer = (((o_xctheta - o_ystheta) * (o_xctheta - o_ystheta)) /
+					// RING_OUTER_SEMIMAJOR_2) +
+					(o_semimajor * o_semimajor)) +
+					(((o_xstheta + o_yctheta) * (o_xstheta + o_yctheta)) /
+					RING_OUTER_SEMIMINOR_2);
+			is_inner = (((i_xctheta - i_ystheta) * (i_xctheta - i_ystheta)) /
+					RING_INNER_SEMIMAJOR_2) +
+					(((i_xstheta + i_yctheta) * (i_xstheta + i_yctheta)) /
+					RING_INNER_SEMIMINOR_2);
+
+			origin_y = (int)(o_xstheta + o_yctheta);
+			rad2 = (x * x) + (y * y);
+
+			if (is_inner < 1.0)
+			{
+				if ((origin_y < 0) && (rad2 <= RADIUS_2))
+					p = clear;
+				else
+				{
+					if (is_inner < 0.9)
+						p = clear;
+					else
+					{
+						UBYTE r2, g2, b2, value;
+						float level;
+						level = (is_inner - 0.9) * 10;
+						r2 = (UBYTE) (r * level);
+						g2 = (UBYTE) (g * level);
+						b2 = (UBYTE) (b * level);
+						value = (UBYTE) (max * level);
+						/* alpha-channel blending only seems to work over the
+						 * actual planet surface, any pixel drawn over the
+						 * clipping frame gets "promoted" to full
+						 * opacity.  Whether bug or feature, for now it needs
+						 * working around.
+						 */
+						if (rad2 > RADIUS_2)
+							p = frame_mapRGBA (RingFrame, r2, g2, b2, max);
+						else
+							p = frame_mapRGBA (RingFrame, r, g, b, value);
+					}
+				}
+			}
+			else if (is_outer < 1.0)
+			{
+				if ((origin_y < 0) && (rad2 <= RADIUS_2))
+					p = clear;
+				else
+				{
+					UBYTE r2, g2, b2, value;
+
+					if (is_outer < 0.9)
+					{
+						if ((int)(is_outer * 10) % 2) {
+							r2 = r * (1 - is_outer);
+							g2 = g * (1 - is_outer);
+							b2 = b * (1 - is_outer);
+						}
+						else {
+							r2 = r * is_outer;
+							g2 = g * is_outer;
+							b2 = b * is_outer;
+						}
+						p = frame_mapRGBA (RingFrame, r2, g2, b2, max);
+					}
+					else
+					{
+						float level;
+						level = (1 - ((is_outer - 0.9) * 10));
+						r2 = (UBYTE) (r * level);
+						g2 = (UBYTE) (g * level);
+						b2 = (UBYTE) (b * level);
+						value = (UBYTE) (max * level);
+						if (rad2 > RADIUS_2)
+							p = frame_mapRGBA (RingFrame, r2, g2, b2, max);
+						else
+							p = frame_mapRGBA (RingFrame, r, g, b, value);
+					}
+				}
+			}
+			else
+				p = clear;
+
+			*p_rgba++ = p;
+		}
+	}
+	process_rgb_bmp (RingFrame, rgba, RING_OUTER_MAJOR, RING_OUTER_MAJOR);
+	SetFrameHot (RingFrame, MAKE_HOT_SPOT (RING_OUTER_SEMIMAJOR + 1, RING_OUTER_SEMIMAJOR + 1));
+
+	return RingFrame;
+}
+
 static void
-ValidateMap (PSBYTE DepthArray)
+ValidateMap (SBYTE *DepthArray)
 {
 	BYTE state;
 	BYTE pixel_count[2], lb[2];
 	SBYTE last_byte;
 	COUNT i;
-	PSBYTE lpDst;
+	SBYTE *lpDst;
 
 	i = MAP_WIDTH - 1;
 	lpDst = DepthArray;
@@ -1370,7 +1573,7 @@ planet_orbit_init ()
 			* (MAP_HEIGHT * (MAP_WIDTH + SPHERE_SPAN_X)));
 	// always allocate the scratch array to largest needed size
 	Orbit->ScratchArray = HMalloc (sizeof (DWORD)
-			* (SHIELD_DIAM) * (SHIELD_DIAM));
+			* (RING_OUTER_MAJOR) * (RING_OUTER_MAJOR));
 }
 
 static unsigned
@@ -1402,7 +1605,7 @@ TopoVarianceCalc (int factor)
 }
 
 static void
-TopoScale4x (PBYTE pDstTopo, PBYTE pSrcTopo, int num_faults, int fault_var)
+TopoScale4x (BYTE *pDstTopo, BYTE *pSrcTopo, int num_faults, int fault_var)
 {
 		// Interpolate the topographical data by connecting the elevations
 		// to their nearest neighboors using straight lines (in random
@@ -1412,7 +1615,8 @@ TopoScale4x (PBYTE pDstTopo, PBYTE pSrcT
 	int x, y;
 	const int w = MAP_WIDTH, h = MAP_HEIGHT;
 	const int spitch = MAP_WIDTH, dpitch = MAP_WIDTH * 4;
-	PSBYTE pSrc, pDst;
+	SBYTE *pSrc;
+	SBYTE *pDst;
 	int* prevrow;
 	int* prow;
 	int elev[5][5];
@@ -1454,7 +1658,7 @@ TopoScale4x (PBYTE pDstTopo, PBYTE pSrcT
 		},
 	};
 	
-	prevrow = (int *) alloca ((MAP_WIDTH * 4 + 1) * sizeof(prevrow[0]));
+	prevrow = (int *) HMalloc ((MAP_WIDTH * 4 + 1) * sizeof(prevrow[0]));
 
 	var_allow = (num_faults << SCALE_SHIFT) / AVG_VARIANCE;
 	var_min = fault_var << SCALE_SHIFT;
@@ -1492,7 +1696,7 @@ TopoScale4x (PBYTE pDstTopo, PBYTE pSrcT
 	for (y = 0; y < h; ++y, pDst += dpitch * 3)
 	{
 		int x2, y2;
-		PSBYTE p;
+		SBYTE *p;
 		int val, step, rndfact;
 		const struct line_def_t* pld;
 
@@ -1591,6 +1795,8 @@ TopoScale4x (PBYTE pDstTopo, PBYTE pSrcT
 		// save last row point
 		prow[0] = elev[4][4];
 	}
+	
+	HFree (prevrow);
 }
 
 
@@ -1614,7 +1820,7 @@ typedef struct
 } elev_block_t;
 
 static inline void
-get_vblock_avg (elev_block_t *pblk, PSBYTE pTopo, int x, int y)
+get_vblock_avg (elev_block_t *pblk, SBYTE *pTopo, int x, int y)
 {
 	SBYTE *elev = pTopo;
 	int y0, y1, i;
@@ -1660,7 +1866,7 @@ get_vblock_avg (elev_block_t *pblk, PSBY
 
 // See description above
 static void
-GenerateLightMap (PSBYTE pTopo, int w, int h)
+GenerateLightMap (SBYTE *pTopo, int w, int h)
 {
 #define LMAP_BLOCKS       (2 * LMAP_MAX_DIST + 1)
 	int x, y;
@@ -1778,16 +1984,16 @@ GenerateLightMap (PSBYTE pTopo, int w, i
 }
 
 void
-GeneratePlanetMask (PPLANET_DESC pPlanetDesc, FRAME SurfDefFrame)
+GeneratePlanetMask (PLANET_DESC *pPlanetDesc, FRAME SurfDefFrame)
 {
 	RECT r;
 	DWORD old_seed;
-	PLANDATAPTR PlanDataPtr;
+	const PlanetFrame *PlanDataPtr;
 	COUNT i, y;
 	POINT loc;
 	CONTEXT OldContext;
 	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
-	PBYTE pScaledTopo = 0;
+	BYTE *pScaledTopo = 0;
 
 	old_seed = TFB_SeedRandom (pPlanetDesc->rand_seed);
 
@@ -1939,6 +2145,29 @@ GeneratePlanetMask (PPLANET_DESC pPlanet
 					pSolarSysState->XlatRef, 1);
 		}
 		pSolarSysState->XlatPtr = GetStringAddress (pSolarSysState->XlatRef);
+
+		if (pSolarSysState->SysInfo.PlanetInfo.AtmoDensity ==
+				GAS_GIANT_ATMOSPHERE)
+		{
+			/* Skip ringmask if the axial tilt is too small --
+			 * the idea is that you would be viewing the rings
+			 * "end-on" and wouldn't see them
+			 */
+			if (abs (pSolarSysState->SysInfo.PlanetInfo.AxialTilt) > 5)
+				switch (pSolarSysState->pOrbitalDesc->data_index)
+				{
+					/* Also skip rings if the planet is a certain
+					 * colour.  These were arbitrarily chosen.
+					 */
+					case GRY_GAS_GIANT:
+					case CYA_GAS_GIANT:
+					case YEL_GAS_GIANT:
+						break;
+					default:
+						Orbit->ObjectFrame = CreateRingMask ();
+				}
+		}
+
 		RenderTopography (FALSE);
 	}
 
@@ -2013,7 +2242,7 @@ rotate_planet_task (void *data)
 	SIZE spin_dir;
 	COORD init_x;
 	DWORD TimeIn;
-	PSOLARSYS_STATE pSS;
+	SOLARSYS_STATE *pSS;
 	BOOLEAN zooming;
 	RECT r, *repair = &r;
 	UBYTE zoom_from;
@@ -2084,7 +2313,7 @@ rotate_planet_task (void *data)
 			// to acquire the graphics lock
 			LockMutex (GraphicsLock);
 			if (*(volatile UBYTE *)&pSS->PauseRotate != 1
-//			if (((PSOLARSYS_STATE volatile)pSS)->MenuState.Initialized <= 3
+//			if (((SOLARSYS_STATE *volatile)pSS)->MenuState.Initialized <= 3
 					&& !(GLOBAL (CurrentActivity) & CHECK_ABORT))
 			{
 				//PauseRotate == 2 is a single-step
diff -ruNp src.orig/sc2code/planets/pstarmap.c src/sc2code/planets/pstarmap.c
--- src.orig/sc2code/planets/pstarmap.c	2017-11-08 16:49:36 -0600
+++ src/sc2code/planets/pstarmap.c	2017-11-08 16:50:03 -0600
@@ -115,7 +115,7 @@ DrawCursor (COORD curs_x, COORD curs_y)
 }
 
 static void
-DrawAutoPilot (PPOINT pDstPt)
+DrawAutoPilot (POINT *pDstPt)
 {
 	SIZE dx, dy,
 				xincr, yincr,
@@ -181,15 +181,11 @@ DrawAutoPilot (PPOINT pDstPt)
 }
 
 static void
-GetSphereRect (EXTENDED_SHIP_FRAGMENTPTR StarShipPtr, PRECT pRect, PRECT
-		pRepairRect)
+GetSphereRect (FLEET_INFO *FleetPtr, RECT *pRect, RECT *pRepairRect)
 {
 	long diameter;
 
-	diameter = (long)(
-			StarShipPtr->ShipInfo.known_strength
-			* SPHERE_RADIUS_INCREMENT
-			);
+	diameter = (long)(FleetPtr->known_strength * SPHERE_RADIUS_INCREMENT);
 	pRect->extent.width = UNIVERSE_TO_DISPX (diameter)
 			- UNIVERSE_TO_DISPX (0);
 	if (pRect->extent.width < 0)
@@ -203,12 +199,8 @@ GetSphereRect (EXTENDED_SHIP_FRAGMENTPTR
 	else if (pRect->extent.height == 0)
 		pRect->extent.height = 1;
 
-	pRect->corner.x = UNIVERSE_TO_DISPX (
-			StarShipPtr->ShipInfo.known_loc.x
-			);
-	pRect->corner.y = UNIVERSE_TO_DISPY (
-			StarShipPtr->ShipInfo.known_loc.y
-			);
+	pRect->corner.x = UNIVERSE_TO_DISPX (FleetPtr->known_loc.x);
+	pRect->corner.y = UNIVERSE_TO_DISPY (FleetPtr->known_loc.y);
 	pRect->corner.x -= pRect->extent.width >> 1;
 	pRect->corner.y -= pRect->extent.height >> 1;
 
@@ -221,12 +213,10 @@ GetSphereRect (EXTENDED_SHIP_FRAGMENTPTR
 		t.baseline.x = pRect->corner.x + (pRect->extent.width >> 1);
 		t.baseline.y = pRect->corner.y + (pRect->extent.height >> 1) - 1;
 		t.align = ALIGN_CENTER;
-		locString = SetAbsStringTableIndex (
-				StarShipPtr->ShipInfo.race_strings, 1
-				);
+		locString = SetAbsStringTableIndex (FleetPtr->race_strings, 1);
 		t.CharCount = GetStringLength (locString);
 		t.pStr = (UNICODE *)GetStringAddress (locString);
-		TextRect (&t, pRepairRect, NULL_PTR);
+		TextRect (&t, pRepairRect, NULL);
 		
 		if (pRepairRect->corner.x <= 0)
 			pRepairRect->corner.x = 1;
@@ -244,7 +234,7 @@ GetSphereRect (EXTENDED_SHIP_FRAGMENTPTR
 }
 
 static void
-DrawStarMap (COUNT race_update, PRECT pClipRect)
+DrawStarMap (COUNT race_update, RECT *pClipRect)
 {
 #define GRID_DELTA 500
 	SIZE i;
@@ -253,10 +243,10 @@ DrawStarMap (COUNT race_update, PRECT pC
 	RECT r, old_r;
 	STAMP s;
 	FRAME star_frame;
-	STAR_DESCPTR SDPtr;
+	STAR_DESC *SDPtr;
 	BOOLEAN draw_cursor;
 
-	if (pClipRect == (PRECT)-1)
+	if (pClipRect == (RECT*)-1)
 	{
 		pClipRect = 0;
 		draw_cursor = FALSE;
@@ -363,7 +353,7 @@ DrawStarMap (COUNT race_update, PRECT pC
 	if (which_space <= 1)
 	{
 		COUNT index;
-		HSTARSHIP hStarShip, hNextShip;
+		HFLEETINFO hStarShip, hNextShip;
 		static const COLOR race_colors[] =
 		{
 			RACE_COLORS
@@ -373,19 +363,16 @@ DrawStarMap (COUNT race_update, PRECT pC
 				hStarShip = GetHeadLink (&GLOBAL (avail_race_q));
 				hStarShip != 0; ++index, hStarShip = hNextShip)
 		{
-			EXTENDED_SHIP_FRAGMENTPTR StarShipPtr;
+			FLEET_INFO *FleetPtr;
 
-			StarShipPtr = (EXTENDED_SHIP_FRAGMENTPTR)LockStarShip (
-					&GLOBAL (avail_race_q),
-					hStarShip
-					);
-			hNextShip = _GetSuccLink (StarShipPtr);
+			FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
+			hNextShip = _GetSuccLink (FleetPtr);
 
-			if (StarShipPtr->ShipInfo.known_strength)
+			if (FleetPtr->known_strength)
 			{
 				RECT repair_r;
 
-				GetSphereRect (StarShipPtr, &r, &repair_r);
+				GetSphereRect (FleetPtr, &r, &repair_r);
 				if (r.corner.x < SIS_SCREEN_WIDTH
 						&& r.corner.y < SIS_SCREEN_HEIGHT
 						&& r.corner.x + r.extent.width > 0
@@ -413,11 +400,10 @@ DrawStarMap (COUNT race_update, PRECT pC
 					t.baseline.y = r.corner.y + (r.extent.height >> 1) - 1;
 					t.align = ALIGN_CENTER;
 					locString = SetAbsStringTableIndex (
-							StarShipPtr->ShipInfo.race_strings, 1
-							);
+							FleetPtr->race_strings, 1);
 					t.CharCount = GetStringLength (locString);
 					t.pStr = (UNICODE *)GetStringAddress (locString);
-					TextRect (&t, &r, NULL_PTR);
+					TextRect (&t, &r, NULL);
 
 					if (r.corner.x <= 0)
 						t.baseline.x -= r.corner.x - 1;
@@ -450,9 +436,7 @@ DrawStarMap (COUNT race_update, PRECT pC
 				}
 			}
 
-			UnlockStarShip (
-					&GLOBAL (avail_race_q), hStarShip
-					);
+			UnlockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
 		}
 	}
 
@@ -588,7 +572,7 @@ ZoomStarMap (SIZE dir)
 			++pMenuState->delta_item;
 			pMenuState->flash_rect1.corner = pMenuState->first_item;
 
-			DrawStarMap (0, NULL_PTR);
+			DrawStarMap (0, NULL);
 			SleepThread (ONE_SECOND >> 3);
 		}
 	}
@@ -605,14 +589,14 @@ ZoomStarMap (SIZE dir)
 			}
 			--pMenuState->delta_item;
 
-			DrawStarMap (0, NULL_PTR);
+			DrawStarMap (0, NULL);
 			SleepThread (ONE_SECOND >> 3);
 		}
 	}
 }
 
 static void
-UpdateCursorLocation (PMENU_STATE pMS, int sx, int sy, const POINT *newpt)
+UpdateCursorLocation (MENU_STATE *pMS, int sx, int sy, const POINT *newpt)
 {
 	STAMP s;
 	POINT pt;
@@ -680,7 +664,7 @@ UpdateCursorLocation (PMENU_STATE pMS, i
 			|| s.origin.y >= SIS_SCREEN_HEIGHT)
 	{
 		pMS->flash_rect1.corner = pMS->first_item;
-		DrawStarMap (0, NULL_PTR);
+		DrawStarMap (0, NULL);
 
 		s.origin.x = UNIVERSE_TO_DISPX (pMS->first_item.x);
 		s.origin.y = UNIVERSE_TO_DISPY (pMS->first_item.y);
@@ -698,11 +682,12 @@ UpdateCursorLocation (PMENU_STATE pMS, i
 #define CURSOR_INFO_BUFSIZE 256
 
 static void
-UpdateCursorInfo (PMENU_STATE pMS, UNICODE *prevbuf)
+UpdateCursorInfo (MENU_STATE *pMS, UNICODE *prevbuf)
 {
 	UNICODE buf[CURSOR_INFO_BUFSIZE] = "";
 	POINT pt;
-	STAR_DESCPTR SDPtr, BestSDPtr;
+	STAR_DESC *SDPtr;
+	STAR_DESC *BestSDPtr;
 
 	pt.x = UNIVERSE_TO_DISPX (pMS->first_item.x);
 	pt.y = UNIVERSE_TO_DISPY (pMS->first_item.y);
@@ -758,7 +743,7 @@ UpdateCursorInfo (PMENU_STATE pMS, UNICO
 }
 
 static void
-UpdateFuelRequirement (PMENU_STATE pMS)
+UpdateFuelRequirement (MENU_STATE *pMS)
 {
 	UNICODE buf[80];
 	COUNT fuel_required;
@@ -795,7 +780,7 @@ UpdateFuelRequirement (PMENU_STATE pMS)
 
 typedef struct starsearch_state
 {
-	PMENU_STATE pMS;
+	MENU_STATE *pMS;
 	UNICODE Text[STAR_SEARCH_BUFSIZE];
 	UNICODE LastText[STAR_SEARCH_BUFSIZE];
 	DWORD LastChangeTime;
@@ -927,7 +912,7 @@ FindNextStarIndex (STAR_SEARCH_STATE *pS
 
 	for (i = from; i < NUM_SOLAR_SYSTEMS; ++i)
 	{
-		STAR_DESCPTR SDPtr = &star_array[pSS->SortedStars[i]];
+		STAR_DESC *SDPtr = &star_array[pSS->SortedStars[i]];
 		UNICODE FullName[STAR_SEARCH_BUFSIZE];
 		UNICODE *ClusterName = GAME_STRING (SDPtr->Postfix);
 		const UNICODE *sptr;
@@ -1002,14 +987,14 @@ FindNextStarIndex (STAR_SEARCH_STATE *pS
 }
 
 static void
-DrawMatchedStarName (PTEXTENTRY_STATE pTES)
+DrawMatchedStarName (TEXTENTRY_STATE *pTES)
 {
 	STAR_SEARCH_STATE *pSS = (STAR_SEARCH_STATE *) pTES->CbParam;
-	PMENU_STATE pMS = pSS->pMS;
+	MENU_STATE *pMS = pSS->pMS;
 	UNICODE buf[STAR_SEARCH_BUFSIZE] = "";
 	SIZE ExPos = 0;
 	SIZE CurPos = -1;
-	STAR_DESCPTR SDPtr = &star_array[pSS->SortedStars[pSS->CurIndex]];
+	STAR_DESC *SDPtr = &star_array[pSS->SortedStars[pSS->CurIndex]];
 	COUNT flags;
 
 	if (pSS->SingleClust || pSS->SingleMatch)
@@ -1085,10 +1070,10 @@ MatchNextStar (STAR_SEARCH_STATE *pSS, B
 }
 
 static BOOLEAN
-OnStarNameChange (PTEXTENTRY_STATE pTES)
+OnStarNameChange (TEXTENTRY_STATE *pTES)
 {
 	STAR_SEARCH_STATE *pSS = (STAR_SEARCH_STATE *) pTES->CbParam;
-	PMENU_STATE pMS = pSS->pMS;
+	MENU_STATE *pMS = pSS->pMS;
 	COUNT flags;
 	BOOLEAN ret = TRUE;
 
@@ -1116,7 +1101,7 @@ OnStarNameChange (PTEXTENTRY_STATE pTES)
 	}
 	else
 	{
-		STAR_DESCPTR SDPtr;
+		STAR_DESC *SDPtr;
 
 		// move the cursor to the found star
 		SDPtr = &star_array[pSS->SortedStars[pSS->CurIndex]];
@@ -1130,14 +1115,14 @@ OnStarNameChange (PTEXTENTRY_STATE pTES)
 }
 
 static BOOLEAN
-OnStarNameFrame (PTEXTENTRY_STATE pTES)
+OnStarNameFrame (TEXTENTRY_STATE *pTES)
 {
 	STAR_SEARCH_STATE *pSS = (STAR_SEARCH_STATE *) pTES->CbParam;
-	PMENU_STATE pMS = pSS->pMS;
+	MENU_STATE *pMS = pSS->pMS;
 
 	if (PulsedInputState.menu[KEY_MENU_NEXT])
 	{	// search for next match
-		STAR_DESCPTR SDPtr;
+		STAR_DESC *SDPtr;
 
 		MatchNextStar (pSS, FALSE);
 
@@ -1160,7 +1145,7 @@ OnStarNameFrame (PTEXTENTRY_STATE pTES)
 }
 
 static BOOLEAN
-DoStarSearch (PMENU_STATE pMS)
+DoStarSearch (MENU_STATE *pMS)
 {
 	TEXTENTRY_STATE tes;
 	STAR_SEARCH_STATE *pss;
@@ -1204,7 +1189,7 @@ DoStarSearch (PMENU_STATE pMS)
 } 
 
 static BOOLEAN
-DoMoveCursor (PMENU_STATE pMS)
+DoMoveCursor (MENU_STATE *pMS)
 {
 #define MIN_ACCEL_DELAY (ONE_SECOND / 60)
 #define MAX_ACCEL_DELAY (ONE_SECOND / 8)
@@ -1269,7 +1254,7 @@ DoMoveCursor (PMENU_STATE pMS)
 			return (FALSE);
 		}
 #endif
-		DrawStarMap (0, NULL_PTR);
+		DrawStarMap (0, NULL);
 	}
 	else if (PulsedInputState.menu[KEY_MENU_SEARCH])
 	{
@@ -1316,7 +1301,7 @@ DoMoveCursor (PMENU_STATE pMS)
 
 		if (sx != 0 || sy != 0)
 		{
-			UpdateCursorLocation (pMS, sx, sy, NULL_PTR);
+			UpdateCursorLocation (pMS, sx, sy, NULL);
 			UpdateCursorInfo (pMS, last_buf);
 			UpdateFuelRequirement (pMS);
 		}
@@ -1337,7 +1322,7 @@ DoMoveCursor (PMENU_STATE pMS)
 }
 
 static void
-RepairMap (COUNT update_race, PRECT pLastRect, PRECT pNextRect)
+RepairMap (COUNT update_race, RECT *pLastRect, RECT *pNextRect)
 {
 	RECT r;
 
@@ -1387,7 +1372,7 @@ UpdateMap (void)
 	BYTE ButtonState, VisibleChange;
 	BOOLEAN MapDrawn, Interrupted;
 	COUNT index;
-	HSTARSHIP hStarShip, hNextShip;
+	HFLEETINFO hStarShip, hNextShip;
 
 	FlushInput ();
 	ButtonState = 1; /* assume a button down */
@@ -1397,13 +1382,10 @@ UpdateMap (void)
 			hStarShip = GetHeadLink (&GLOBAL (avail_race_q));
 			hStarShip; ++index, hStarShip = hNextShip)
 	{
-		EXTENDED_SHIP_FRAGMENTPTR StarShipPtr;
+		FLEET_INFO *FleetPtr;
 
-		StarShipPtr = (EXTENDED_SHIP_FRAGMENTPTR)LockStarShip (
-				&GLOBAL (avail_race_q),
-				hStarShip
-				);
-		hNextShip = _GetSuccLink (StarShipPtr);
+		FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
+		hNextShip = _GetSuccLink (FleetPtr);
 
 		if (ButtonState)
 		{
@@ -1415,15 +1397,13 @@ UpdateMap (void)
 				)))
 			MapDrawn = TRUE;
 
-		if (StarShipPtr->ShipInfo.known_strength)
+		if (FleetPtr->known_strength)
 		{
 			SIZE dx, dy, delta;
 			RECT r, last_r, temp_r0, temp_r1;
 
-			dx = StarShipPtr->ShipInfo.loc.x
-					- StarShipPtr->ShipInfo.known_loc.x;
-			dy = StarShipPtr->ShipInfo.loc.y
-					- StarShipPtr->ShipInfo.known_loc.y;
+			dx = FleetPtr->loc.x - FleetPtr->known_loc.x;
+			dy = FleetPtr->loc.y - FleetPtr->known_loc.y;
 			if (dx || dy)
 			{
 				SIZE xincr, yincr,
@@ -1456,11 +1436,11 @@ UpdateMap (void)
 
 				if (!MapDrawn)
 				{
-					DrawStarMap ((COUNT)~0, NULL_PTR);
+					DrawStarMap ((COUNT)~0, NULL);
 					MapDrawn = TRUE;
 				}
 
-				GetSphereRect (StarShipPtr, &temp_r0, &last_r);
+				GetSphereRect (FleetPtr, &temp_r0, &last_r);
 				++last_r.extent.width;
 				++last_r.extent.height;
 				VisibleChange = FALSE;
@@ -1470,15 +1450,15 @@ UpdateMap (void)
 					{
 						if ((xerror -= dx) <= 0)
 						{
-							StarShipPtr->ShipInfo.known_loc.x += xincr;
+							FleetPtr->known_loc.x += xincr;
 							xerror += cycle;
 						}
 						if ((yerror -= dy) <= 0)
 						{
-							StarShipPtr->ShipInfo.known_loc.y += yincr;
+							FleetPtr->known_loc.y += yincr;
 							yerror += cycle;
 						}
-						GetSphereRect (StarShipPtr, &temp_r1, &r);
+						GetSphereRect (FleetPtr, &temp_r1, &r);
 					} while (delta--
 							&& ((delta & 0x1F)
 							|| (temp_r0.corner.x == temp_r1.corner.x
@@ -1510,16 +1490,15 @@ UpdateMap (void)
 					RepairMap ((COUNT)~0, &last_r, &r);
 
 DoneSphereMove:
-				StarShipPtr->ShipInfo.known_loc = StarShipPtr->ShipInfo.loc;
+				FleetPtr->known_loc = FleetPtr->loc;
 			}
 
-			delta = StarShipPtr->ShipInfo.actual_strength
-					- StarShipPtr->ShipInfo.known_strength;
+			delta = FleetPtr->actual_strength - FleetPtr->known_strength;
 			if (delta)
 			{
 				if (!MapDrawn)
 				{
-					DrawStarMap ((COUNT)~0, NULL_PTR);
+					DrawStarMap ((COUNT)~0, NULL);
 					MapDrawn = TRUE;
 				}
 
@@ -1532,7 +1511,7 @@ DoneSphereMove:
 				}
 				--delta;
 
-				GetSphereRect (StarShipPtr, &temp_r0, &last_r);
+				GetSphereRect (FleetPtr, &temp_r0, &last_r);
 				++last_r.extent.width;
 				++last_r.extent.height;
 				VisibleChange = FALSE;
@@ -1540,8 +1519,8 @@ DoneSphereMove:
 				{
 					do
 					{
-						StarShipPtr->ShipInfo.known_strength += dx;
-						GetSphereRect (StarShipPtr, &temp_r1, &r);
+						FleetPtr->known_strength += dx;
+						GetSphereRect (FleetPtr, &temp_r1, &r);
 					} while (delta--
 							&& ((delta & 0xF)
 							|| temp_r0.extent.height == temp_r1.extent.height));
@@ -1570,14 +1549,11 @@ DoneSphereMove:
 					RepairMap ((COUNT)~0, &last_r, &r);
 
 DoneSphereGrowth:
-				StarShipPtr->ShipInfo.known_strength =
-						StarShipPtr->ShipInfo.actual_strength;
+				FleetPtr->known_strength = FleetPtr->actual_strength;
 			}
 		}
 
-		UnlockStarShip (
-				&GLOBAL (avail_race_q), hStarShip
-				);
+		UnlockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
 	}
 }
 
@@ -1619,10 +1595,16 @@ DoStarMap (void)
 	transition_pending = TRUE;
 	if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
 		UpdateMap ();
+	else
+	{
+		if (GLOBAL_SIS (log_x) == UNIVERSE_TO_LOGX (QUASI_SPACE_X) &&
+				GLOBAL_SIS (log_y) == UNIVERSE_TO_LOGY (QUASI_SPACE_Y))
+			MenuState.delta_item = 2;
+	}
 
 	LockMutex (GraphicsLock);
 	
-	DrawStarMap (0, (PRECT)-1);
+	DrawStarMap (0, (RECT*)-1);
 	transition_pending = FALSE;
 	
 	BatchGraphics ();
@@ -1637,7 +1619,7 @@ DoStarMap (void)
 	UnbatchGraphics ();
 	UnlockMutex (GraphicsLock);
 
-	DoInput ((PVOID)&MenuState, FALSE);
+	DoInput (&MenuState, FALSE);
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
 
 	pMenuState = 0;
@@ -1645,8 +1627,8 @@ DoStarMap (void)
 	LockMutex (GraphicsLock);
 
 	DrawHyperCoords (universe);
-	DrawSISMessage (NULL_PTR);
-	DrawStatusMessage (NULL_PTR);
+	DrawSISMessage (NULL);
+	DrawStatusMessage (NULL);
 
 	if (GLOBAL (autopilot.x) == universe.x
 			&& GLOBAL (autopilot.y) == universe.y)
@@ -1657,7 +1639,7 @@ DoStarMap (void)
 }
 
 BOOLEAN
-DoFlagshipCommands (PMENU_STATE pMS)
+DoFlagshipCommands (MENU_STATE *pMS)
 {
 	/* TODO: Make this carried cleanly by MENU_STATE structure */
 	// static DWORD NextTime;
@@ -1708,7 +1690,7 @@ DoFlagshipCommands (PMENU_STATE pMS)
 					if (NewState != SCAN + 1 && NewState != (GAME_MENU) + 1)
 					{
 						LockMutex (GraphicsLock);
-						SetFlashRect (NULL_PTR, (FRAME)0);
+						SetFlashRect (NULL, (FRAME)0);
 						UnlockMutex (GraphicsLock);
 					}
 
@@ -1826,7 +1808,7 @@ DoFlagshipCommands (PMENU_STATE pMS)
 					else
 					{
 						LockMutex (GraphicsLock);
-						SetFlashRect (NULL_PTR, (FRAME)0);
+						SetFlashRect (NULL, (FRAME)0);
 						UnlockMutex (GraphicsLock);
 						DrawMenuStateStrings (PM_STARMAP, -NAVIGATION);
 					}
diff -ruNp src.orig/sc2code/planets/report.c src/sc2code/planets/report.c
--- src.orig/sc2code/planets/report.c	2017-11-08 16:49:36 -0600
+++ src/sc2code/planets/report.c	2017-11-08 16:50:03 -0600
@@ -87,7 +87,7 @@ MakeReport (SOUND ReadOutSounds, UNICODE
 	BYTE ButtonState;
 	int end_page_len;
 	UNICODE end_page_buf[200];
-	wchar_t last_c;
+	wchar_t last_c = 0;
 	COUNT row_cells;
 	BOOLEAN Sleepy;
 	RECT r;
@@ -171,12 +171,20 @@ MakeReport (SOUND ReadOutSounds, UNICODE
 						PlaySound (ReadOutSounds, NotPositional (), NULL,
 								GAME_SOUND_PRIORITY);
 
-						if (c == ',')
-							TimeOut += ONE_SECOND / 4;
-						if (c == '.' || c == '!' || c == '?')
-							TimeOut += ONE_SECOND / 2;
+						if (last_c && last_c != ' ' && last_c != ',' &&
+								last_c != '.' && last_c != '!' && last_c != '?')
+						{
+							if (c == ',')
+								TimeOut += ONE_SECOND / 4;
+							if (c == '.' || c == '!' || c == '?')
+								TimeOut += ONE_SECOND / 2;
+							else
+								TimeOut += ONE_SECOND / 20;
+						}
 						else
 							TimeOut += ONE_SECOND / 20;
+						last_c = c;
+
 						if (word_chars == 0)
 							TimeOut += ONE_SECOND / 20;
 
diff -ruNp src.orig/sc2code/planets/roster.c src/sc2code/planets/roster.c
--- src.orig/sc2code/planets/roster.c	2017-11-08 16:49:36 -0600
+++ src/sc2code/planets/roster.c	2017-11-08 16:50:03 -0600
@@ -39,17 +39,17 @@ flash_ship_task (void *data)
 	while (!Task_ReadState (task, TASK_EXIT))
 	{
 		STAMP s;
-		SHIP_FRAGMENTPTR StarShipPtr;
+		SHIP_FRAGMENT *StarShipPtr;
 		COLOR OldColor;
 		CONTEXT OldContext;
 
 		LockMutex (GraphicsLock);
 		s.origin = pMenuState->first_item;
-		StarShipPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-				&GLOBAL (built_ship_q), (HSTARSHIP)pMenuState->CurFrame);
-		s.frame = StarShipPtr->ShipInfo.icons;
-		UnlockStarShip (&GLOBAL (built_ship_q),
-				(HSTARSHIP)pMenuState->CurFrame);
+		StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q),
+				(HSHIPFRAG)pMenuState->CurFrame);
+		s.frame = StarShipPtr->icons;
+		UnlockShipFrag (&GLOBAL (built_ship_q),
+				(HSHIPFRAG)pMenuState->CurFrame);
 		OldContext = SetContext (StatusContext);
 		if (c >= BUILD_COLOR (MAKE_RGB15 (0x1F, 0x19, 0x19), 0x24))
 			c = BUILD_COLOR (MAKE_RGB15 (0x1F, 0x00, 0x00), 0x24);
@@ -67,30 +67,29 @@ flash_ship_task (void *data)
 	return 0;
 }
 
-static HSTARSHIP
-MatchSupportShip (PMENU_STATE pMS)
+static HSHIPFRAG
+MatchSupportShip (MENU_STATE *pMS)
 {
-	PPOINT pship_pos;
-	HSTARSHIP hStarShip, hNextShip;
+	POINT *pship_pos;
+	HSHIPFRAG hStarShip, hNextShip;
 
 	for (hStarShip = GetHeadLink (&GLOBAL (built_ship_q)),
-			pship_pos = (PPOINT)pMS->flash_frame0;
+			pship_pos = (POINT*)pMS->flash_frame0;
 			hStarShip; hStarShip = hNextShip, ++pship_pos)
 	{
-		SHIP_FRAGMENTPTR StarShipPtr;
+		SHIP_FRAGMENT *StarShipPtr;
 
-		StarShipPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-				&GLOBAL (built_ship_q), hStarShip);
+		StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 
 		if (pship_pos->x == pMS->first_item.x
 				&& pship_pos->y == pMS->first_item.y)
 		{
-			UnlockStarShip (&GLOBAL (built_ship_q), hStarShip);
+			UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 			return hStarShip;
 		}
 
 		hNextShip = _GetSuccLink (StarShipPtr);
-		UnlockStarShip (&GLOBAL (built_ship_q), hStarShip);
+		UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 	}
 
 	return 0;
@@ -101,33 +100,42 @@ DeltaSupportCrew (SIZE crew_delta)
 {
 	BOOLEAN ret = FALSE;
 	UNICODE buf[40];
-	HSTARSHIP hTemplate;
-	SHIP_FRAGMENTPTR StarShipPtr, TemplatePtr;
+	HFLEETINFO hTemplate;
+	SHIP_FRAGMENT *StarShipPtr;
+	FLEET_INFO *TemplatePtr;
 
-	StarShipPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-			&GLOBAL (built_ship_q), (HSTARSHIP)pMenuState->CurFrame);
+	StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q),
+			(HSHIPFRAG)pMenuState->CurFrame);
 	hTemplate = GetStarShipFromIndex (&GLOBAL (avail_race_q),
-			GET_RACE_ID (StarShipPtr));
-	TemplatePtr = (SHIP_FRAGMENTPTR)LockStarShip (
-			&GLOBAL (avail_race_q), hTemplate);
-
-	StarShipPtr->ShipInfo.crew_level += crew_delta;
-
-	if (StarShipPtr->ShipInfo.crew_level == 0)
-		StarShipPtr->ShipInfo.crew_level = 1;
-	else if (StarShipPtr->ShipInfo.crew_level >
-			TemplatePtr->RaceDescPtr->ship_info.crew_level &&
+			StarShipPtr->race_id);
+	TemplatePtr = LockFleetInfo (&GLOBAL (avail_race_q), hTemplate);
+
+	if (crew_delta > 0)
+	{
+		while (crew_delta && (StarShipPtr->crew_level + crew_delta) >
+				StarShipPtr->max_crew)
+			crew_delta--;
+	}
+	else if (crew_delta < 0)
+	{
+		while (crew_delta && (StarShipPtr->crew_level + crew_delta) < 1)
+			crew_delta++;
+	}
+	StarShipPtr->crew_level += crew_delta;
+
+	if (StarShipPtr->crew_level == 0)
+		StarShipPtr->crew_level = 1;
+	else if (StarShipPtr->crew_level > TemplatePtr->crew_level &&
 			crew_delta > 0)
-		StarShipPtr->ShipInfo.crew_level -= crew_delta;
+		StarShipPtr->crew_level -= crew_delta;
 	else
 	{
-		if (StarShipPtr->ShipInfo.crew_level >=
-				TemplatePtr->RaceDescPtr->ship_info.crew_level)
-			sprintf (buf, "%u", StarShipPtr->ShipInfo.crew_level);
+		if (StarShipPtr->crew_level >= TemplatePtr->crew_level)
+			sprintf (buf, "%u", StarShipPtr->crew_level);
 		else
 			sprintf (buf, "%u/%u",
-					StarShipPtr->ShipInfo.crew_level,
-					TemplatePtr->RaceDescPtr->ship_info.crew_level);
+					StarShipPtr->crew_level,
+					TemplatePtr->crew_level);
 
 		DrawStatusMessage (buf);
 		DeltaSISGauges (-crew_delta, 0, 0);
@@ -145,8 +153,8 @@ DeltaSupportCrew (SIZE crew_delta)
 		ret = TRUE;
 	}
 
-	UnlockStarShip (&GLOBAL (avail_race_q), hTemplate);
-	UnlockStarShip (&GLOBAL (built_ship_q), (HSTARSHIP)pMenuState->CurFrame);
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hTemplate);
+	UnlockShipFrag (&GLOBAL (built_ship_q), (HSHIPFRAG)pMenuState->CurFrame);
 
 	return ret;
 }
@@ -154,7 +162,7 @@ DeltaSupportCrew (SIZE crew_delta)
 #define SHIP_TOGGLE ((BYTE)(1 << 7))
 
 static void
-RosterCleanup (PMENU_STATE pMS)
+RosterCleanup (MENU_STATE *pMS)
 {
 	if (pMS->flash_task)
 	{
@@ -167,14 +175,14 @@ RosterCleanup (PMENU_STATE pMS)
 	if (pMS->CurFrame)
 	{
 		STAMP s;
-		SHIP_FRAGMENTPTR StarShipPtr;
+		SHIP_FRAGMENT *StarShipPtr;
 
 		SetContext (StatusContext);
 		s.origin = pMS->first_item;
-		StarShipPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-				&GLOBAL (built_ship_q), (HSTARSHIP)pMS->CurFrame);
-		s.frame = StarShipPtr->ShipInfo.icons;
-		UnlockStarShip (&GLOBAL (built_ship_q), (HSTARSHIP)pMS->CurFrame);
+		StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q),
+				(HSHIPFRAG)pMS->CurFrame);
+		s.frame = StarShipPtr->icons;
+		UnlockShipFrag (&GLOBAL (built_ship_q), (HSHIPFRAG)pMS->CurFrame);
 		if (!(pMS->CurState & SHIP_TOGGLE))
 			DrawStamp (&s);
 		else
@@ -186,14 +194,14 @@ RosterCleanup (PMENU_STATE pMS)
 }
 
 static BOOLEAN
-DoModifyRoster (PMENU_STATE pMS)
+DoModifyRoster (MENU_STATE *pMS)
 {
 	BYTE NewState;
 	SBYTE sx, sy;
 	RECT r;
 	STAMP s;
-	SHIP_FRAGMENTPTR StarShipPtr;
-	BOOLEAN select, cancel, up, down, horiz;
+	SHIP_FRAGMENT *StarShipPtr;
+	BOOLEAN select, cancel, up, down, pgup, pgdn, horiz;
 
 	if (GLOBAL (CurrentActivity) & CHECK_ABORT)
 	{
@@ -211,15 +219,18 @@ DoModifyRoster (PMENU_STATE pMS)
 	down = PulsedInputState.menu[KEY_MENU_DOWN];
 	horiz = PulsedInputState.menu[KEY_MENU_LEFT] ||
 			PulsedInputState.menu[KEY_MENU_RIGHT];
+	pgup = PulsedInputState.menu[KEY_MENU_PAGE_UP];
+	pgdn = PulsedInputState.menu[KEY_MENU_PAGE_DOWN];
 
 	if (pMS->Initialized && (pMS->CurState & SHIP_TOGGLE))
 	{
-		SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN,
-				MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
+		SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN | MENU_SOUND_PAGEUP |
+				MENU_SOUND_PAGEDOWN, MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
 	}
 	else
 	{
-		SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
+		SetMenuSounds (MENU_SOUND_ARROWS | MENU_SOUND_PAGEUP |
+				MENU_SOUND_PAGEDOWN, MENU_SOUND_SELECT);
 	}
 
 	if (!pMS->Initialized)
@@ -235,10 +246,10 @@ DoModifyRoster (PMENU_STATE pMS)
 	else if (cancel && !(pMS->CurState & SHIP_TOGGLE))
 	{
 		LockMutex (GraphicsLock);
-		SetFlashRect (NULL_PTR, (FRAME)0);
+		SetFlashRect (NULL, (FRAME)0);
 		RosterCleanup (pMS);
 		pMS->CurFrame = 0;
-		DrawStatusMessage (NULL_PTR);
+		DrawStatusMessage (NULL);
 		UnlockMutex (GraphicsLock);
 
 		return FALSE;
@@ -248,7 +259,7 @@ DoModifyRoster (PMENU_STATE pMS)
 		LockMutex (GraphicsLock);
 		pMS->CurState ^= SHIP_TOGGLE;
 		if (!(pMS->CurState & SHIP_TOGGLE))
-			SetFlashRect (NULL_PTR, (FRAME)0);
+			SetFlashRect (NULL, (FRAME)0);
 		else
 		{
 			RosterCleanup (pMS);
@@ -266,20 +277,17 @@ DoModifyRoster (PMENU_STATE pMS)
 	{
 		SIZE delta = 0;
 		BOOLEAN failed = FALSE;
-
-		if (up)
+		if (up || pgup)
 		{
-			sy = -1;
 			if (GLOBAL_SIS (CrewEnlisted))
-				delta = 1;
+				delta = pgup ? 10 : 1;
 			else
 				failed = TRUE;
 		}
-		else if (down)
+		else if (down || pgdn)
 		{
-			sy = 1;
-			if (GLOBAL_SIS (CrewEnlisted) < GetCPodCapacity (NULL_PTR))
-				delta = -1;
+			if (GLOBAL_SIS (CrewEnlisted) < GetCPodCapacity (NULL))
+				delta = pgdn ? -10 : -1;
 			else
 				failed = TRUE;
 		}
@@ -297,13 +305,13 @@ DoModifyRoster (PMENU_STATE pMS)
 	}
 	else
 	{
-		PPOINT pship_pos;
+		POINT *pship_pos;
 
 		NewState = pMS->CurState;
 		sx = (SBYTE)((pMS->delta_item + 1) >> 1);
 		if (horiz)
 		{
-			pship_pos = (PPOINT)pMS->flash_frame1;
+			pship_pos = (POINT*)pMS->flash_frame1;
 			if (NewState == (BYTE)(sx - 1))
 				NewState = (BYTE)(pMS->delta_item - 1);
 			else if (NewState >= (BYTE)sx)
@@ -344,18 +352,13 @@ DoModifyRoster (PMENU_STATE pMS)
 			LockMutex (GraphicsLock);
 			SetContext (StatusContext);
 			s.origin = pMS->first_item;
-			StarShipPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-					&GLOBAL (built_ship_q),
-					(HSTARSHIP)pMS->CurFrame
-					);
-			s.frame = StarShipPtr->ShipInfo.icons;
-			UnlockStarShip (
-					&GLOBAL (built_ship_q),
-					(HSTARSHIP)pMS->CurFrame
-					);
+			StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q),
+					(HSHIPFRAG)pMS->CurFrame);
+			s.frame = StarShipPtr->icons;
+			UnlockShipFrag (&GLOBAL (built_ship_q), (HSHIPFRAG)pMS->CurFrame);
 			DrawStamp (&s);
 SelectSupport:
-			pship_pos = (PPOINT)pMS->flash_frame1;
+			pship_pos = (POINT*)pMS->flash_frame1;
 			pMS->first_item = pship_pos[NewState];
 			pMS->CurFrame = (FRAME)MatchSupportShip (pMS);
 
@@ -388,7 +391,7 @@ Roster (void)
 			SUPPORT_SHIP_PTS
 		};
 		MENU_STATE MenuState;
-		PMENU_STATE pOldMenuState;
+		MENU_STATE *pOldMenuState;
 
 		pOldMenuState = pMenuState;
 		pMenuState = &MenuState;
@@ -443,7 +446,7 @@ Roster (void)
 		MenuState.flash_frame0 = (FRAME)ship_pos;
 		MenuState.flash_frame1 = (FRAME)modified_ship_pos;
 		SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
-		DoInput ((PVOID)&MenuState, TRUE);
+		DoInput (&MenuState, TRUE);
 
 		pMenuState = pOldMenuState;
 		
diff -ruNp src.orig/sc2code/planets/scan.c src/sc2code/planets/scan.c
--- src.orig/sc2code/planets/scan.c	2017-11-08 16:49:36 -0600
+++ src/sc2code/planets/scan.c	2017-11-08 16:50:03 -0600
@@ -17,6 +17,8 @@
  */
 
 #include "build.h"
+#include "colors.h"
+#include "cons_res.h"
 #include "controls.h"
 #include "encount.h"
 #include "gamestr.h"
@@ -35,7 +37,8 @@
 #include "libs/inplib.h"
 #include "libs/mathlib.h"
 
-
+CONTEXT coarse_scan_context;
+FRAME coarse_scan;
 extern FRAME SpaceJunkFrame;
 
 // define SPIN_ON_SCAN to allow the planet to spin 
@@ -49,7 +52,7 @@ extern FRAME SpaceJunkFrame;
 CONTEXT ScanContext;
 
 void
-RepairBackRect (PRECT pRect)
+RepairBackRect (RECT *pRect)
 {
 	RECT new_r, old_r;
 
@@ -100,15 +103,12 @@ static void
 PrintScanTitlePC (TEXT *t, RECT *r, const char *txt, int xpos)
 {
 	t->baseline.x = xpos;
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x15), 0x3B));
 	t->pStr = txt;
 	t->CharCount = (COUNT)~0;
-	font_DrawText (t);
-	TextRect (t, r, NULL_PTR);
+	font_DrawTracedText (t,
+			BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x15), 0x3B), BLACK_COLOR);
+	TextRect (t, r, NULL);
 	t->baseline.x += r->extent.width;
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x0F, 0x00, 0x19), 0x3B));
 }
 
 static void
@@ -134,7 +134,6 @@ PrintCoarseScanPC (void)
 	UNICODE buf[200];
 
 	LockMutex (GraphicsLock);
-	SetContext (SpaceContext);
 
 	if (CurStarDescPtr->Index == SOL_DEFINED)
 	{
@@ -200,11 +199,9 @@ PrintCoarseScanPC (void)
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x15), 0x3B));
 	SetContextFont (MicroFont);
-	font_DrawText (&t);
-
+	font_DrawTracedText (&t,
+			BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x15), 0x3B), BLACK_COLOR);
 	SetContextFont (TinyFont);
 	UnlockMutex (GraphicsLock);
 
@@ -224,7 +221,8 @@ PrintCoarseScanPC (void)
 			GAME_STRING (ORBITSCAN_STRING_BASE + 1)); // " a.u."
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	font_DrawTracedText (&t,
+			BUILD_COLOR (MAKE_RGB15 (0xF, 0x00, 0x19), 0x3B), BLACK_COLOR);
 	t.baseline.y += SCAN_LEADING_PC;
 	UnlockMutex (GraphicsLock);
 
@@ -246,7 +244,8 @@ PrintCoarseScanPC (void)
 	}
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	font_DrawTracedText (&t,
+			BUILD_COLOR (MAKE_RGB15 (0xF, 0x00, 0x19), 0x3B), BLACK_COLOR);
 	t.baseline.y += SCAN_LEADING_PC;
 	UnlockMutex (GraphicsLock);
 
@@ -257,7 +256,8 @@ PrintCoarseScanPC (void)
 			pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature);
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	font_DrawTracedText (&t,
+			BUILD_COLOR (MAKE_RGB15 (0xF, 0x00, 0x19), 0x3B), BLACK_COLOR);
 	t.baseline.y += SCAN_LEADING_PC;
 	UnlockMutex (GraphicsLock);
 
@@ -274,7 +274,8 @@ PrintCoarseScanPC (void)
 		t.pStr = buf;
 	}
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	font_DrawTracedText (&t,
+			BUILD_COLOR (MAKE_RGB15 (0xF, 0x00, 0x19), 0x3B), BLACK_COLOR);
 	t.baseline.y += SCAN_LEADING_PC;
 	UnlockMutex (GraphicsLock);
 
@@ -292,7 +293,8 @@ PrintCoarseScanPC (void)
 		t.pStr = buf;
 	}
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	font_DrawTracedText (&t,
+			BUILD_COLOR (MAKE_RGB15 (0xF, 0x00, 0x19), 0x3B), BLACK_COLOR);
 	UnlockMutex (GraphicsLock);
 
 	t.baseline.y = SCAN_BASELINE_Y_PC;
@@ -301,7 +303,7 @@ PrintCoarseScanPC (void)
 	PrintScanTitlePC (&t, &r, GAME_STRING (ORBITSCAN_STRING_BASE + 11),
 			RIGHT_SIDE_BASELINE_X_PC); // "Mass: "
 	val = pSolarSysState->SysInfo.PlanetInfo.PlanetRadius;
-	val = (val * val * val / 100L
+	val = ((DWORD) val * (DWORD) val * (DWORD) val / 100L
 			* pSolarSysState->SysInfo.PlanetInfo.PlanetDensity
 			+ ((100L * 100L) >> 1)) / (100L * 100L);
 	if (val == 0)
@@ -310,7 +312,8 @@ PrintCoarseScanPC (void)
 			GAME_STRING (ORBITSCAN_STRING_BASE + 12)); // " e.s."
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	font_DrawTracedText (&t,
+			BUILD_COLOR (MAKE_RGB15 (0xF, 0x00, 0x19), 0x3B), BLACK_COLOR);
 	t.baseline.y += SCAN_LEADING_PC;
 	UnlockMutex (GraphicsLock);
 
@@ -322,7 +325,8 @@ PrintCoarseScanPC (void)
 			GAME_STRING (ORBITSCAN_STRING_BASE + 12)); // " e.s."
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	font_DrawTracedText (&t,
+			BUILD_COLOR (MAKE_RGB15 (0xF, 0x00, 0x19), 0x3B), BLACK_COLOR);
 	t.baseline.y += SCAN_LEADING_PC;
 	UnlockMutex (GraphicsLock);
 
@@ -336,7 +340,8 @@ PrintCoarseScanPC (void)
 			GAME_STRING (ORBITSCAN_STRING_BASE + 15)); // " g."
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	font_DrawTracedText (&t,
+			BUILD_COLOR (MAKE_RGB15 (0xF, 0x00, 0x19), 0x3B), BLACK_COLOR);
 	t.baseline.y += SCAN_LEADING_PC;
 	UnlockMutex (GraphicsLock);
 
@@ -349,7 +354,8 @@ PrintCoarseScanPC (void)
 			GAME_STRING (ORBITSCAN_STRING_BASE + 17)); // " days"
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	font_DrawTracedText (&t,
+			BUILD_COLOR (MAKE_RGB15 (0xF, 0x00, 0x19), 0x3B), BLACK_COLOR);
 	t.baseline.y += SCAN_LEADING_PC;
 	UnlockMutex (GraphicsLock);
 
@@ -362,7 +368,8 @@ PrintCoarseScanPC (void)
 	t.pStr = buf;
 	sprintf (buf, "%d" STR_DEGREE_SIGN, val);
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	font_DrawTracedText (&t,
+			BUILD_COLOR (MAKE_RGB15 (0xF, 0x00, 0x19), 0x3B), BLACK_COLOR);
 	UnlockMutex (GraphicsLock);
 }
 
@@ -376,7 +383,6 @@ PrintCoarseScan3DO (void)
 	UNICODE buf[200];
 
 	LockMutex (GraphicsLock);
-	SetContext (SpaceContext);
 
 	if (CurStarDescPtr->Index == SOL_DEFINED)
 	{
@@ -441,10 +447,9 @@ PrintCoarseScan3DO (void)
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x0F, 0x00, 0x19), 0x3B));
 	SetContextFont (MicroFont);
-	font_DrawText (&t);
+	font_DrawTracedText (&t,
+			BUILD_COLOR (MAKE_RGB15 (0xF, 0x00, 0x19), 0x3B), BLACK_COLOR);
 
 	s.origin.x = s.origin.y = 0;
 	s.origin.x = 16 - SAFE_X;
@@ -467,7 +472,8 @@ PrintCoarseScan3DO (void)
 			+ (EARTH_RADIUS >> 1)) / EARTH_RADIUS);
 	MakeScanValue (buf, val, STR_EARTH_SIGN);
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	font_DrawTracedText (&t,
+			BUILD_COLOR (MAKE_RGB15 (0xF, 0x00, 0x19), 0x3B), BLACK_COLOR);
 	t.baseline.y += SCAN_LEADING;
 	UnlockMutex (GraphicsLock);
 
@@ -482,7 +488,8 @@ PrintCoarseScan3DO (void)
 		MakeScanValue (buf, val, STR_EARTH_SIGN);
 	}
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	font_DrawTracedText (&t,
+			BUILD_COLOR (MAKE_RGB15 (0xF, 0x00, 0x19), 0x3B), BLACK_COLOR);
 	t.baseline.y += SCAN_LEADING;
 	UnlockMutex (GraphicsLock);
 
@@ -491,7 +498,8 @@ PrintCoarseScan3DO (void)
 	sprintf (buf, "%d" STR_DEGREE_SIGN,
 			pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature);
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	font_DrawTracedText (&t,
+			BUILD_COLOR (MAKE_RGB15 (0xF, 0x00, 0x19), 0x3B), BLACK_COLOR);
 	t.baseline.y += SCAN_LEADING;
 	UnlockMutex (GraphicsLock);
 
@@ -500,7 +508,8 @@ PrintCoarseScan3DO (void)
 	sprintf (buf, "<%u>", pSolarSysState->SysInfo.PlanetInfo.AtmoDensity == 0
 			? 0 : (pSolarSysState->SysInfo.PlanetInfo.Weather + 1));
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	font_DrawTracedText (&t,
+			BUILD_COLOR (MAKE_RGB15 (0xF, 0x00, 0x19), 0x3B), BLACK_COLOR);
 	t.baseline.y += SCAN_LEADING;
 	UnlockMutex (GraphicsLock);
 
@@ -512,7 +521,8 @@ PrintCoarseScan3DO (void)
 			) == GAS_GIANT
 			? 0 : (pSolarSysState->SysInfo.PlanetInfo.Tectonics + 1));
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	font_DrawTracedText (&t,
+			BUILD_COLOR (MAKE_RGB15 (0xF, 0x00, 0x19), 0x3B), BLACK_COLOR);
 	UnlockMutex (GraphicsLock);
 
 	t.baseline.x = RIGHT_SIDE_BASELINE_X;
@@ -522,14 +532,15 @@ PrintCoarseScan3DO (void)
 	LockMutex (GraphicsLock);
 	t.pStr = buf;
 	val = pSolarSysState->SysInfo.PlanetInfo.PlanetRadius;
-	val = (val * val * val / 100L
+	val = ((DWORD) val * (DWORD) val * (DWORD) val / 100L
 			* pSolarSysState->SysInfo.PlanetInfo.PlanetDensity
 			+ ((100L * 100L) >> 1)) / (100L * 100L);
 	if (val == 0)
 		val = 1;
 	MakeScanValue (buf, val, STR_EARTH_SIGN);
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	font_DrawTracedText (&t,
+			BUILD_COLOR (MAKE_RGB15 (0xF, 0x00, 0x19), 0x3B), BLACK_COLOR);
 	t.baseline.y += SCAN_LEADING;
 	UnlockMutex (GraphicsLock);
 
@@ -539,7 +550,8 @@ PrintCoarseScan3DO (void)
 	MakeScanValue (buf, val, STR_EARTH_SIGN);
 
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	font_DrawTracedText (&t,
+			BUILD_COLOR (MAKE_RGB15 (0xF, 0x00, 0x19), 0x3B), BLACK_COLOR);
 	t.baseline.y += SCAN_LEADING;
 	UnlockMutex (GraphicsLock);
 
@@ -550,7 +562,8 @@ PrintCoarseScan3DO (void)
 		val = 1;
 	MakeScanValue (buf, val, STR_EARTH_SIGN);
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	font_DrawTracedText (&t,
+			BUILD_COLOR (MAKE_RGB15 (0xF, 0x00, 0x19), 0x3B), BLACK_COLOR);
 	t.baseline.y += SCAN_LEADING;
 	UnlockMutex (GraphicsLock);
 
@@ -561,7 +574,8 @@ PrintCoarseScan3DO (void)
 		val = -val;
 	sprintf (buf, "%d" STR_DEGREE_SIGN, val);
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	font_DrawTracedText (&t,
+			BUILD_COLOR (MAKE_RGB15 (0xF, 0x00, 0x19), 0x3B), BLACK_COLOR);
 	t.baseline.y += SCAN_LEADING;
 	UnlockMutex (GraphicsLock);
 
@@ -571,7 +585,8 @@ PrintCoarseScan3DO (void)
 			* 10 / 24;
 	MakeScanValue (buf, val, STR_EARTH_SIGN);
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	font_DrawTracedText (&t,
+			BUILD_COLOR (MAKE_RGB15 (0xF, 0x00, 0x19), 0x3B), BLACK_COLOR);
 	UnlockMutex (GraphicsLock);
 }
 
@@ -663,10 +678,10 @@ flash_planet_loc_func(void *data)
 	return(0);
 }
 
-static BOOLEAN DoScan (PMENU_STATE pMS);
+BOOLEAN DoScan (MENU_STATE *pMS);
 
 static BOOLEAN
-PickPlanetSide (PMENU_STATE pMS)
+PickPlanetSide (MENU_STATE *pMS)
 {
 	BOOLEAN select, cancel;
 	select = PulsedInputState.menu[KEY_MENU_SELECT];
@@ -705,7 +720,7 @@ PickPlanetSide (PMENU_STATE pMS)
 			r.extent.height = FLASH_HEIGHT;
 			LoadDisplayPixmap (&r, pMenuState->flash_frame0);
 
-			SetFlashRect (NULL_PTR, (FRAME)0);
+			SetFlashRect (NULL, (FRAME)0);
 			UnlockMutex (GraphicsLock);
 
 			InitLander (0);
@@ -721,7 +736,7 @@ PickPlanetSide (PMENU_STATE pMS)
 		SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
 
 		LockMutex (GraphicsLock);
-		DrawStatusMessage (NULL_PTR);
+		DrawStatusMessage (NULL);
 		UnlockMutex (GraphicsLock);
 
 		FlushInput ();
@@ -759,7 +774,8 @@ PickPlanetSide (PMENU_STATE pMS)
 
 			if (GET_GAME_STATE (FOUND_PLUTO_SPATHI) == 1)
 			{
-				HSTARSHIP hStarShip;
+				/* Create Fwiffo group and go into comm with it */
+				HSHIPFRAG hStarShip;
 
 				if (pMenuState->flash_task)
 				{
@@ -772,35 +788,26 @@ PickPlanetSide (PMENU_STATE pMS)
 
 				EncounterGroup = 0;
 				PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
-				ReinitQueue (&GLOBAL (npc_built_ship_q));
+				ReinitQueue (&GLOBAL (ip_group_q));
+				assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
 
 				hStarShip = CloneShipFragment (SPATHI_SHIP,
 						&GLOBAL (npc_built_ship_q), 1);
 				if (hStarShip)
 				{
-					BYTE captains_name_index;
-					COUNT which_player;
-					STARSHIPPTR StarShipPtr;
-
-					StarShipPtr = LockStarShip (
-							&GLOBAL (npc_built_ship_q), hStarShip
-							);
-					which_player = StarShipPlayer (StarShipPtr);
-					captains_name_index = NAME_OFFSET + NUM_CAPTAINS_NAMES;
-					OwnStarShip (StarShipPtr, which_player, captains_name_index);
-					UnlockStarShip (
-							&GLOBAL (npc_built_ship_q), hStarShip
-							);
+					SHIP_FRAGMENT *StarShipPtr;
+
+					StarShipPtr = LockShipFrag (&GLOBAL (npc_built_ship_q),
+							hStarShip);
+					// Name Fwiffo
+					StarShipPtr->captains_name_index = NAME_OFFSET +
+							NUM_CAPTAINS_NAMES;
+					UnlockShipFrag (&GLOBAL (npc_built_ship_q), hStarShip);
 				}
 
 				SaveFlagshipState ();
 				return (FALSE);
 			}
-
-			if (optWhichCoarseScan == OPT_PC)
-				PrintCoarseScanPC ();
-			else
-				PrintCoarseScan3DO ();
 		}
 
 		DrawMenuStateStrings (PM_MIN_SCAN, DISPATCH_SHUTTLE);
@@ -870,7 +877,7 @@ DrawScannedStuff (COUNT y, BYTE CurState
 
 	for (hElement = GetHeadElement (); hElement; hElement = hNextElement)
 	{
-		ELEMENTPTR ElementPtr;
+		ELEMENT *ElementPtr;
 		//COLOR OldColor;
 		SIZE dy;
 		
@@ -878,7 +885,7 @@ DrawScannedStuff (COUNT y, BYTE CurState
 		hNextElement = GetSuccElement (ElementPtr);
 
 		dy = y - ElementPtr->current.location.y;
-		if (LOBYTE (ElementPtr->life_span) == CurState
+		if (LOBYTE (ElementPtr->scan_node) == CurState
 				&& dy >= 0)// && dy <= 3)
 		{
 			COUNT i;
@@ -948,8 +955,8 @@ DrawScannedStuff (COUNT y, BYTE CurState
 	SetContextForeGroundColor (OldColor);
 }
 
-static BOOLEAN
-DoScan (PMENU_STATE pMS)
+BOOLEAN
+DoScan (MENU_STATE *pMS)
 {
 	DWORD TimeIn, WaitTime;
 	BOOLEAN select, cancel;
@@ -1232,7 +1239,7 @@ ScanSystem (void)
 				(MAP_HEIGHT >> 1) << MAG_SHIFT;
 
 		LockMutex (GraphicsLock);
-		ScanContext = CaptureContext (CreateContext ());
+		ScanContext = CreateContext ();
 		SetContext (ScanContext);
 		MenuState.flash_rect0.extent.width = FLASH_WIDTH;
 		MenuState.flash_rect0.extent.height = FLASH_HEIGHT;
@@ -1251,14 +1258,9 @@ ScanSystem (void)
 
 	DrawMenuStateStrings (PM_MIN_SCAN, MenuState.CurState);
 
-	if (optWhichCoarseScan == OPT_PC)
-		PrintCoarseScanPC ();
-	else
-		PrintCoarseScan3DO ();
-
 	pMenuState = &MenuState;
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
-	DoInput ((PVOID)&MenuState, FALSE);
+	DoInput (&MenuState, FALSE);
 	pMenuState = 0;
 
 	if (ScanContext)
@@ -1266,7 +1268,7 @@ ScanSystem (void)
 		LockMutex (GraphicsLock);
 		SetContext (SpaceContext);
 		DestroyDrawable (ReleaseDrawable (MenuState.flash_frame0));
-		DestroyContext (ReleaseContext (ScanContext));
+		DestroyContext (ScanContext);
 		ScanContext = 0;
 		UnlockMutex (GraphicsLock);
 	}
@@ -1298,7 +1300,7 @@ GeneratePlanetSide (void)
 		while (num_nodes--)
 		{
 			HELEMENT hNodeElement;
-			ELEMENTPTR NodeElementPtr;
+			ELEMENT *NodeElementPtr;
 
 			if (pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[scan]
 					& (1L << num_nodes))
@@ -1313,7 +1315,7 @@ GeneratePlanetSide (void)
 			pSolarSysState->CurNode = num_nodes;
 			(*pSolarSysState->GenFunc) ((BYTE)(scan + GENERATE_MINERAL));
 
-			NodeElementPtr->life_span = MAKE_WORD (scan, num_nodes + 1);
+			NodeElementPtr->scan_node = MAKE_WORD (scan, num_nodes + 1);
 			NodeElementPtr->state_flags = BAD_GUY;
 			NodeElementPtr->current.location.x =
 					pSolarSysState->SysInfo.PlanetInfo.CurPt.x;
@@ -1340,7 +1342,7 @@ GeneratePlanetSide (void)
 			}
 			else
 			{
-				extern void object_animation (PELEMENT ElementPtr);
+				extern void object_animation (ELEMENT *ElementPtr);
 
 				NodeElementPtr->current.image.frame = f;
 				NodeElementPtr->next.image.frame = SetRelFrameIndex (
@@ -1387,13 +1389,7 @@ GeneratePlanetSide (void)
 						life_init_tab[i] = (BYTE)which_node + 1;
 
 						pSolarSysState->PlanetSideFrame[i + 3] =
-								CaptureDrawable (LoadGraphic (
-								MAKE_RESOURCE (
-								GET_PACKAGE (LIFE00_MASK_PMAP_ANIM)
-								+ which_node, GFXRES,
-								GET_INSTANCE (LIFE00_MASK_PMAP_ANIM)
-								+ which_node)));
-
+								load_life_form (which_node);
 						break;
 					}
 
@@ -1418,4 +1414,35 @@ GeneratePlanetSide (void)
 	}
 }
 
+void
+init_coarse_scan (void)
+{
+	COLOR bg;
+	CONTEXT old_context;
+
+	coarse_scan_context = CreateContext ();
+	coarse_scan = CaptureDrawable (
+			CreateDrawable (WANT_PIXMAP, SIS_SCREEN_WIDTH,
+			SIS_SCREEN_HEIGHT, 1));
+	old_context = SetContext (coarse_scan_context);
+	SetContextFGFrame (coarse_scan);
+	bg = BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x10), 0x00);
+	// Color key for the background.
+	SetContextBackGroundColor (bg);
+	ClearDrawable ();
+	SetFrameTransparentColor (coarse_scan, bg);
+
+	if (optWhichCoarseScan == OPT_PC)
+		PrintCoarseScanPC ();
+	else
+		PrintCoarseScan3DO ();
+
+	SetContext (old_context);
+}
 
+void
+uninit_coarse_scan (void)
+{
+	DestroyContext (coarse_scan_context);
+	DestroyDrawable (ReleaseDrawable (coarse_scan));
+}
diff -ruNp src.orig/sc2code/planets/scan.h src/sc2code/planets/scan.h
--- src.orig/sc2code/planets/scan.h	2017-11-08 16:49:36 -0600
+++ src/sc2code/planets/scan.h	2017-11-08 16:50:03 -0600
@@ -20,31 +20,31 @@
 #define _SCAN_H
 
 #include "libs/gfxlib.h"
-
+#include "menustat.h"
 
 typedef struct
 {
 	POINT start;
-	COUNT start_dot,
-				num_dots,
-				dots_per_semi;
+	COUNT start_dot;
+	COUNT num_dots;
+	COUNT dots_per_semi;
 } SCAN_DESC;
-typedef SCAN_DESC *PSCAN_DESC;
 
 typedef struct
 {
-	PPOINT line_base;
-	COUNT num_scans, num_same_scans;
-	PSCAN_DESC scan_base;
+	POINT *line_base;
+	COUNT num_scans;
+	COUNT num_same_scans;
+	SCAN_DESC *scan_base;
 } SCAN_BLOCK;
-typedef SCAN_BLOCK *PSCAN_BLOCK;
 
 #define SAME_SCAN (1 << 16)
 #define SCALED_ROOT_TWO 92682L /* root 2 * (1 << 16) */
 #define SCALE_FACTOR 16
 
-extern void RepairBackRect (PRECT pRect);
+extern void RepairBackRect (RECT *pRect);
 extern void GeneratePlanetSide (void);
+extern BOOLEAN DoScan (MENU_STATE *pMS);
 
 #endif /* _SCAN_H */
 
diff -ruNp src.orig/sc2code/planets/solarsys.c src/sc2code/planets/solarsys.c
--- src.orig/sc2code/planets/solarsys.c	2017-11-08 16:49:36 -0600
+++ src/sc2code/planets/solarsys.c	2017-11-08 16:50:03 -0600
@@ -36,11 +36,11 @@
 #include "libs/inplib.h"
 #include "libs/log.h"
 
-
 //#define DEBUG_SOLARSYS
 
-
-PSOLARSYS_STATE pSolarSysState;
+void init_coarse_scan (void);
+extern FRAME coarse_scan;
+SOLARSYS_STATE *pSolarSysState;
 FRAME SISIPFrame, SunFrame, OrbitalFrame, SpaceJunkFrame;
 COLORMAP OrbitalCMap;
 COLORMAP SunCMap;
@@ -65,10 +65,10 @@ BYTE draw_sys_flags = DRAW_STARS | DRAW_
 
 // NB. This function modifies the RNG state.
 static void
-GeneratePlanets (PSOLARSYS_STATE system)
+GeneratePlanets (SOLARSYS_STATE *system)
 {
 	COUNT i;
-	PPLANET_DESC planet;
+	PLANET_DESC *planet;
 
 	for (i = system->SunDesc[0].NumPlanets,
 			planet = &system->PlanetDesc[0]; i; --i, ++planet)
@@ -118,8 +118,8 @@ static void
 GenerateMoons (void)
 {
 	COUNT i, facing;
-	PPLANET_DESC pMoonDesc;
-	PPLANET_DESC pCurDesc;
+	PLANET_DESC *pMoonDesc;
+	PLANET_DESC *pCurDesc;
 	DWORD old_seed;
 
 	GLOBAL (ip_location.x) =
@@ -147,22 +147,46 @@ GenerateMoons (void)
 			;
 		else
 		{
-			BYTE data_index;
-
 			pMoonDesc->temp_color = pCurDesc->temp_color;
 
-			data_index = pMoonDesc->data_index;
-			if (data_index == (BYTE)~0)
-			{
-				/* Starbase */
-				pMoonDesc->image.frame =
-						SetAbsFrameIndex (SpaceJunkFrame, 16);
-			}
-			else if (data_index == (BYTE)(~0 - 1))
+			switch (pMoonDesc->data_index)
 			{
-				/* Sa-Matra */
-				pMoonDesc->image.frame =
-						SetAbsFrameIndex (SpaceJunkFrame, 19);
+				case HIERARCHY_STARBASE:
+					pMoonDesc->image.frame =
+							SetAbsFrameIndex (SpaceJunkFrame, 16);
+					break;
+				case SA_MATRA:
+					pMoonDesc->image.frame =
+							SetAbsFrameIndex (SpaceJunkFrame, 19);
+					break;
+				case DESTROYED_STARBASE:
+					pMoonDesc->image.frame =
+							SetAbsFrameIndex (SpaceJunkFrame, 22);
+					break;
+				case PRECURSOR_STARBASE:
+					pMoonDesc->image.frame =
+							SetAbsFrameIndex (SpaceJunkFrame, 23);
+					break;
+				case ZOQFOTPIK_STARBASE:
+					pMoonDesc->image.frame =
+							SetAbsFrameIndex (SpaceJunkFrame, 24);
+					break;
+				case PKUNK_STARBASE:
+					pMoonDesc->image.frame =
+							SetAbsFrameIndex (SpaceJunkFrame, 25);
+					break;
+				case DRUUGE_STARBASE:
+					pMoonDesc->image.frame =
+							SetAbsFrameIndex (SpaceJunkFrame, 26);
+					break;
+				case UTWIG_STARBASE:
+					pMoonDesc->image.frame =
+							SetAbsFrameIndex (SpaceJunkFrame, 27);
+					break;
+				case ORZ_STARBASE:
+					pMoonDesc->image.frame =
+							SetAbsFrameIndex (SpaceJunkFrame, 28);
+					break;
 			}
 		}
 	}
@@ -213,7 +237,7 @@ void
 LoadSolarSys (void)
 {
 	COUNT i;
-	PPLANET_DESC pCurDesc;
+	PLANET_DESC *pCurDesc;
 	DWORD old_seed;
 #define NUM_TEMP_RANGES 5
 	static const COLOR temp_color_array[NUM_TEMP_RANGES] =
@@ -422,7 +446,7 @@ static void
 CheckIntersect (BOOLEAN just_checking)
 {
 	COUNT i;
-	PPLANET_DESC pCurDesc;
+	PLANET_DESC *pCurDesc;
 	INTERSECT_CONTROL ShipIntersect, PlanetIntersect;
 	COUNT NewWaitPlanet;
 	BYTE PlanetOffset, MoonOffset;
@@ -574,7 +598,7 @@ ShowPlanet:
 }
 
 static void
-GetOrbitRect (PRECT pRect, COORD cx, COORD cy, SIZE
+GetOrbitRect (RECT *pRect, COORD cx, COORD cy, SIZE
 		radius, COUNT xnumer, COUNT ynumer, COUNT denom)
 {
 #ifdef BVT_NOT
@@ -594,7 +618,7 @@ GetOrbitRect (PRECT pRect, COORD cx, COO
 }
 
 static void
-DrawOrbit (PPLANET_DESC pPlanetDesc, COUNT xnumer, COUNT ynumer0,
+DrawOrbit (PLANET_DESC *pPlanetDesc, COUNT xnumer, COUNT ynumer0,
 		COUNT ynumer1, COUNT denom)
 {
 	COUNT index;
@@ -754,7 +778,7 @@ flagship_inertial_thrust (COUNT CurrentA
 	BYTE max_speed;
 	SIZE cur_delta_x, cur_delta_y;
 	COUNT TravelAngle;
-	VELOCITYPTR VelocityPtr;
+	VELOCITY_DESC *VelocityPtr;
 
 	max_speed = pSolarSysState->max_ship_speed;
 	VelocityPtr = &GLOBAL (velocity);
@@ -822,15 +846,15 @@ ProcessShipControls (void)
 
 	ClockTick ();
 
-	if (CurrentInputState.key[PlayerOne][KEY_UP])
+	if (CurrentInputState.key[PlayerControls[0]][KEY_UP])
 		delta_y = -1;
 	else
 		delta_y = 0;
 
 	delta_x = 0;
-	if (CurrentInputState.key[PlayerOne][KEY_LEFT])
+	if (CurrentInputState.key[PlayerControls[0]][KEY_LEFT])
 		delta_x -= 1;
-	if (CurrentInputState.key[PlayerOne][KEY_RIGHT])
+	if (CurrentInputState.key[PlayerControls[0]][KEY_RIGHT])
 		delta_x += 1;
 		
 	if (delta_x || delta_y < 0)
@@ -897,7 +921,7 @@ UndrawShip (void)
 		}
 		else
 		{
-			PPLANET_DESC pPlanetDesc;
+			PLANET_DESC *pPlanetDesc;
 
 			LeavingInnerSystem = TRUE;
 			pPlanetDesc = pSolarSysState->pBaseDesc->pPrevDesc;
@@ -1238,7 +1262,7 @@ IP_frame (void)
 		SuspendGameClock ();
 		
 		LockMutex (GraphicsLock);
-		DrawStatusMessage (NULL_PTR);
+		DrawStatusMessage (NULL);
 		if (LastActivity == CHECK_LOAD)
 			pSolarSysState->MenuState.CurState = (ROSTER + 1) + 1;
 		else
@@ -1269,8 +1293,8 @@ ValidateOrbits (void)
 {
 	BYTE i;
 	BOOLEAN InnerSystem;
-	POINT old_pts[2];
-	PPLANET_DESC pCurDesc;
+	POINT old_pts[2] = { { 0, 0 }, { 0, 0 } };
+	PLANET_DESC *pCurDesc;
 
 	InnerSystem = (BOOLEAN)(
 			pSolarSysState->pBaseDesc == pSolarSysState->MoonDesc);
@@ -1353,8 +1377,9 @@ StartGroups:
 						UnbatchGraphics ();
 					}
 					LockMutex (GraphicsLock);
-					while (pSolarSysState->SunDesc[0].radius ==
-							(MAX_ZOOM_RADIUS << 1))
+					while ((pSolarSysState->SunDesc[0].radius ==
+							(MAX_ZOOM_RADIUS << 1)) &&
+							!(GLOBAL(CurrentActivity) & CHECK_ABORT))
 					{
 						UnlockMutex (GraphicsLock);
 						IP_frame ();
@@ -1390,6 +1415,10 @@ StartGroups:
 
 		GetPlanetInfo ();
 		(*pSolarSysState->GenFunc) (GENERATE_ORBITAL);
+		// if the GenFunc left us with usable planet data,
+		// initialize the coarse scan frame
+		if (pSolarSysState->SysInfo.PlanetInfo.PlanDataPtr)
+			init_coarse_scan ();
 		LastActivity &= ~(CHECK_LOAD | CHECK_RESTART);
 		if ((GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD |
 				START_ENCOUNTER)) || GLOBAL_SIS (CrewEnlisted) == (COUNT)~0
@@ -1460,6 +1489,7 @@ InitSolarSys (void)
 		EncounterRace = -1;
 		EncounterGroup = 0;
 		GLOBAL (BattleGroupRef) = 0;
+		ReinitQueue (&GLOBAL (ip_group_q));
 		ReinitQueue (&GLOBAL (npc_built_ship_q));
 		(*pSolarSysState->GenFunc) (INIT_NPCS);
 	}
@@ -1491,7 +1521,7 @@ InitSolarSys (void)
 
 		// Enabled graphics synchronization again, as in 3DO code originally.
 		// This should fix the 'entering star' lockup/messed graphics problems.
-		DrawSISMessage (NULL_PTR);
+		DrawSISMessage (NULL);
 		SetContext (SpaceContext);
 		SetContextFGFrame (Screen);
 		SetContextBackGroundColor (BLACK_COLOR);
@@ -1544,7 +1574,7 @@ UninitSolarSys (void)
 		{
 			BYTE i;
 			DWORD best_dist;
-			PPLANET_DESC pCurDesc;
+			PLANET_DESC *pCurDesc;
 
 			best_dist = ~0L;
 			for (i = 0, pCurDesc = pSolarSysState->PlanetDesc;
@@ -1590,6 +1620,7 @@ GenerateRandomIP (BYTE control)
 		case UNINIT_NPCS:
 			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
 			ReinitQueue (&GLOBAL (npc_built_ship_q));
+			ReinitQueue (&GLOBAL (ip_group_q));
 			break;
 		case GENERATE_MINERAL:
 			GenerateMineralDeposits (&pSolarSysState->SysInfo,
@@ -1664,7 +1695,8 @@ void
 DrawSystem (SIZE radius, BOOLEAN IsInnerSystem)
 {
 	BYTE i;
-	PPLANET_DESC pCurDesc, pBaseDesc;
+	PLANET_DESC *pCurDesc;
+	PLANET_DESC *pBaseDesc;
 
 	BatchGraphics ();
 	if (draw_sys_flags & DRAW_STARS)
@@ -1696,7 +1728,37 @@ DrawSystem (SIZE radius, BOOLEAN IsInner
 	}
 
 	if (IsInnerSystem)
+	{
 		DrawSISTitle (GLOBAL_SIS (PlanetName));
+
+		/* UGLY HACK: scribble the orbital for the Spathi
+		 * starbase on the screen.  Can't do this in
+		 * GenerateSpathi() because it fires before the 
+		 * ExtraScreen has been setup.  Yuck.
+		 *
+		 * This is not my best work ever.  Apologies.  A
+		 * proper fix appears to involve more heavy lifting
+		 * than I'm amenable to right now...
+		 */
+		if (pSolarSysState->GenFunc == GenerateSpathi &&
+				!GET_GAME_STATE (SPATHI_SHIELDED_SELVES))
+		{
+			RECT r;
+			int i;
+
+			r.extent.width = 45;
+			r.extent.height = r.extent.width >> 1;
+			r.corner.x = (SIS_SCREEN_WIDTH >> 1) - (r.extent.width >> 1) +
+					pSolarSysState->MoonDesc[0].location.x;
+			r.corner.y = (SIS_SCREEN_HEIGHT >> 1) - (r.extent.height >> 1) +
+					(pSolarSysState->MoonDesc[0].location.y >> 1);
+			DrawOval (&r, 1);
+			for (i = 0; i < pSolarSysState->PlanetDesc[0].NumPlanets; i++)
+				DrawStamp (&pSolarSysState->MoonDesc[i].image);
+		}
+		/* END SHAMEFUL HACKERY */
+
+	}
 	else
 	{
 		SIZE index;
@@ -1873,7 +1935,7 @@ DrawStarBackGround (BOOLEAN ForPlanet)
 }
 
 void
-XFormIPLoc (PPOINT pIn, PPOINT pOut, BOOLEAN ToDisplay)
+XFormIPLoc (POINT *pIn, POINT *pOut, BOOLEAN ToDisplay)
 {
 	if (ToDisplay)
 	{
@@ -1927,7 +1989,7 @@ ExploreSolarSys (void)
 
 	InitSolarSys ();
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
-	DoInput ((PVOID)&SolarSysState.MenuState, FALSE);
+	DoInput (&SolarSysState.MenuState, FALSE);
 	UninitSolarSys ();
 	pSolarSysState = 0;
 }
diff -ruNp src.orig/sc2code/planets/sundata.h src/sc2code/planets/sundata.h
--- src.orig/sc2code/planets/sundata.h	2017-11-08 16:49:36 -0600
+++ src/sc2code/planets/sundata.h	2017-11-08 16:50:03 -0600
@@ -39,14 +39,10 @@ typedef struct
 
 	PLANET_INFO PlanetInfo;
 } SYSTEM_INFO;
-typedef SYSTEM_INFO *PSYSTEM_INFO;
-
-#define SYSTEM_INFOPTR PSYSTEM_INFO
 		
-extern DWORD GenerateMineralDeposits (SYSTEM_INFOPTR SysInfoPtr, PCOUNT
-		pwhich_deposit);
-extern DWORD GenerateLifeForms (SYSTEM_INFOPTR SysInfoPtr, PCOUNT
-		pwhich_life);
+extern DWORD GenerateMineralDeposits (SYSTEM_INFO *SysInfoPtr,
+		COUNT *pwhich_deposit);
+extern DWORD GenerateLifeForms (SYSTEM_INFO *SysInfoPtr, COUNT *pwhich_life);
 
 #define DWARF_ELEMENT_DENSITY  1
 #define GIANT_ELEMENT_DENSITY 3
@@ -54,8 +50,8 @@ extern DWORD GenerateLifeForms (SYSTEM_I
 
 #define MAX_ELEMENT_DENSITY ((MAX_ELEMENT_UNITS * SUPERGIANT_ELEMENT_DENSITY) << 1)
 
-extern DWORD DoPlanetaryAnalysis (SYSTEM_INFOPTR SysInfoPtr, PPLANET_DESC
-		pPlanetDesc);
+extern DWORD DoPlanetaryAnalysis (SYSTEM_INFO *SysInfoPtr,
+		PLANET_DESC *pPlanetDesc);
 
 extern SYSTEM_INFO CurSysInfo;
 
diff -ruNp src.orig/sc2code/planets/surface.c src/sc2code/planets/surface.c
--- src.orig/sc2code/planets/surface.c	2017-11-08 16:49:36 -0600
+++ src/sc2code/planets/surface.c	2017-11-08 16:50:03 -0600
@@ -28,11 +28,11 @@ const BYTE *Elements;
 const PlanetFrame *PlanData;
 
 static COUNT
-CalcMineralDeposits (SYSTEM_INFOPTR SysInfoPtr, COUNT which_deposit)
+CalcMineralDeposits (SYSTEM_INFO *SysInfoPtr, COUNT which_deposit)
 {
 	BYTE j;
 	COUNT num_deposits;
-	ELEMENT_ENTRYPTR eptr;
+	const ELEMENT_ENTRY *eptr;
 
 	eptr = &SysInfoPtr->PlanetInfo.PlanDataPtr->UsefulElements[0];
 	num_deposits = 0;
@@ -96,8 +96,7 @@ ExitCalcMinerals:
 }
 
 DWORD
-GenerateMineralDeposits (SYSTEM_INFOPTR SysInfoPtr, PCOUNT
-		pwhich_deposit)
+GenerateMineralDeposits (SYSTEM_INFO *SysInfoPtr, COUNT *pwhich_deposit)
 {
 	DWORD old_rand;
 
@@ -107,7 +106,7 @@ GenerateMineralDeposits (SYSTEM_INFOPTR
 }
 
 static COUNT
-CalcLifeForms (SYSTEM_INFOPTR SysInfoPtr, COUNT which_life)
+CalcLifeForms (SYSTEM_INFO *SysInfoPtr, COUNT which_life)
 {
 	COUNT num_life_forms;
 
@@ -251,7 +250,7 @@ CalcLifeForms (SYSTEM_INFOPTR SysInfoPtr
 }
 
 DWORD
-GenerateLifeForms (SYSTEM_INFOPTR SysInfoPtr, PCOUNT pwhich_life)
+GenerateLifeForms (SYSTEM_INFO *SysInfoPtr, COUNT *pwhich_life)
 {
 	DWORD old_rand;
 
diff -ruNp src.orig/sc2code/process.c src/sc2code/process.c
--- src.orig/sc2code/process.c	2017-11-08 16:49:36 -0600
+++ src/sc2code/process.c	2017-11-08 16:50:03 -0600
@@ -75,11 +75,16 @@ AllocElement (void)
 	hElement = AllocLink (&disp_q);
 	if (hElement)
 	{
-		ELEMENTPTR ElementPtr;
+		ELEMENT *ElementPtr;
 
 		LockElement (hElement, &ElementPtr);
 		memset (ElementPtr, 0, sizeof (*ElementPtr));
 		ElementPtr->PrimIndex = AllocDisplayPrim ();
+		if (ElementPtr->PrimIndex == END_OF_LIST)
+		{
+			log_add (log_Error, "AllocElement: Out of display prims!");
+			explode ();
+		}
 		SetPrimType (&DisplayArray[ElementPtr->PrimIndex], NO_PRIM);
 		UnlockElement (hElement);
 	}
@@ -92,7 +97,7 @@ FreeElement (HELEMENT hElement)
 {
 	if (hElement)
 	{
-		ELEMENTPTR ElementPtr;
+		ELEMENT *ElementPtr;
 
 		LockElement (hElement, &ElementPtr);
 		FreeDisplayPrim (ElementPtr->PrimIndex);
@@ -103,7 +108,7 @@ FreeElement (HELEMENT hElement)
 }
 
 void
-SetUpElement (ELEMENTPTR ElementPtr)
+SetUpElement (ELEMENT *ElementPtr)
 {
 	ElementPtr->next = ElementPtr->current;
 	if (CollidingElement (ElementPtr))
@@ -115,7 +120,7 @@ SetUpElement (ELEMENTPTR ElementPtr)
 }
 
 static void
-PreProcess (ELEMENTPTR ElementPtr)
+PreProcess (ELEMENT *ElementPtr)
 {
 	ELEMENT_FLAGS state_flags;
 
@@ -175,7 +180,7 @@ PreProcess (ELEMENTPTR ElementPtr)
 }
 
 static void
-PostProcess (ELEMENTPTR ElementPtr)
+PostProcess (ELEMENT *ElementPtr)
 {
 	if (ElementPtr->postprocess_func)
 		(*ElementPtr->postprocess_func) (ElementPtr);
@@ -270,8 +275,8 @@ CalcReduction (SIZE dx, SIZE dy)
 }
 
 static VIEW_STATE
-CalcView (PPOINT pNewScrollPt, SIZE next_reduction,
-		PSIZE pdx, PSIZE pdy, COUNT ships_alive)
+CalcView (POINT *pNewScrollPt, SIZE next_reduction,
+		SIZE *pdx, SIZE *pdy, COUNT ships_alive)
 {
 	SIZE dx, dy;
 	VIEW_STATE view_state;
@@ -324,10 +329,12 @@ CalcView (PPOINT pNewScrollPt, SIZE next
 					&& zoom_out - next_reduction > ZOOM_JUMP)
 				next_reduction = zoom_out - ZOOM_JUMP;
 				
-			SpaceOrg.x = (int)(LOG_SPACE_WIDTH >> 1)
-					- (LOG_SPACE_WIDTH * next_reduction / (MAX_ZOOM_OUT << 2));
-			SpaceOrg.y = (int)(LOG_SPACE_HEIGHT >> 1)
-					- (LOG_SPACE_HEIGHT * next_reduction / (MAX_ZOOM_OUT << 2));
+			// Always align the origin on a whole pixel to reduce the
+			// amount of object positioning jitter
+			SpaceOrg.x = DISPLAY_ALIGN((int)(LOG_SPACE_WIDTH >> 1) -
+					(LOG_SPACE_WIDTH * next_reduction / (MAX_ZOOM_OUT << 2)));
+			SpaceOrg.y = DISPLAY_ALIGN((int)(LOG_SPACE_HEIGHT >> 1) -
+					(LOG_SPACE_HEIGHT * next_reduction / (MAX_ZOOM_OUT << 2)));
 		}
 		zoom_out = next_reduction;
 		view_state = VIEW_CHANGE;
@@ -347,14 +354,14 @@ CalcView (PPOINT pNewScrollPt, SIZE next
 
 
 static ELEMENT_FLAGS
-ProcessCollisions (HELEMENT hSuccElement, ELEMENTPTR ElementPtr,
+ProcessCollisions (HELEMENT hSuccElement, ELEMENT *ElementPtr,
 		TIME_VALUE min_time, ELEMENT_FLAGS process_flags)
 {
 	HELEMENT hTestElement;
 
 	while ((hTestElement = hSuccElement) != 0)
 	{
-		ELEMENTPTR TestElementPtr;
+		ELEMENT *TestElementPtr;
 
 		LockElement (hTestElement, &TestElementPtr);
 		if (!(TestElementPtr->state_flags & process_flags))
@@ -364,7 +371,6 @@ ProcessCollisions (HELEMENT hSuccElement
 		if (TestElementPtr == ElementPtr)
 		{
 			UnlockElement (hTestElement);
-
 			continue;
 		}
 
@@ -472,7 +478,7 @@ ProcessCollisions (HELEMENT hSuccElement
 							InitIntersectFrame (ElementPtr);
 							if (state_flags & PLAYER_SHIP)
 							{
-								STARSHIPPTR StarShipPtr;
+								STARSHIP *StarShipPtr;
 
 								GetElementStarShip (ElementPtr, &StarShipPtr);
 								StarShipPtr->ShipFacing =
@@ -485,7 +491,7 @@ ProcessCollisions (HELEMENT hSuccElement
 							InitIntersectFrame (TestElementPtr);
 							if (test_state_flags & PLAYER_SHIP)
 							{
-								STARSHIPPTR StarShipPtr;
+								STARSHIP *StarShipPtr;
 
 								GetElementStarShip (TestElementPtr, &StarShipPtr);
 								StarShipPtr->ShipFacing =
@@ -616,10 +622,10 @@ ProcessCollisions (HELEMENT hSuccElement
 }
 
 static VIEW_STATE
-PreProcessQueue (PSIZE pscroll_x, PSIZE pscroll_y)
+PreProcessQueue (SIZE *pscroll_x, SIZE *pscroll_y)
 {
 	SIZE min_reduction, max_reduction;
-	COUNT num_ships;
+	COUNT sides_active;
 	POINT Origin;
 	HELEMENT hElement;
 	COUNT ships_alive;
@@ -627,8 +633,8 @@ PreProcessQueue (PSIZE pscroll_x, PSIZE
 #ifdef KDEBUG
 	log_add (log_Debug, "PreProcess:");
 #endif
-	num_ships = (LOBYTE (battle_counter) ? 1 : 0)
-			+ (HIBYTE (battle_counter) ? 1 : 0);
+	sides_active = (battle_counter[0] ? 1 : 0)
+			+ (battle_counter[1] ? 1 : 0);
 
 	if (optMeleeScale == TFB_SCALE_STEP)
 		min_reduction = max_reduction = MAX_VIS_REDUCTION + 1;
@@ -642,7 +648,7 @@ PreProcessQueue (PSIZE pscroll_x, PSIZE
 	ships_alive = 0;
 	while (hElement != 0)
 	{
-		ELEMENTPTR ElementPtr;
+		ELEMENT *ElementPtr;
 		HELEMENT hNextElement;
 
 		LockElement (hElement, &ElementPtr);
@@ -673,7 +679,7 @@ PreProcessQueue (PSIZE pscroll_x, PSIZE
 			dy = DISPLAY_ALIGN (ElementPtr->next.location.y) - Origin.y;
 			dy = WRAP_DELTA_Y (dy);
 
-			if (num_ships <= 2 || !(ElementPtr->state_flags & BAD_GUY))
+			if (sides_active <= 2 || !(ElementPtr->state_flags & BAD_GUY))
 			{
 				Origin.x = DISPLAY_ALIGN (Origin.x + (dx >> 1));
 				Origin.y = DISPLAY_ALIGN (Origin.y + (dy >> 1));
@@ -804,7 +810,7 @@ PostProcessQueue (VIEW_STATE view_state,
 	while (hElement != 0)
 	{
 		ELEMENT_FLAGS state_flags;
-		ELEMENTPTR ElementPtr;
+		ELEMENT *ElementPtr;
 		HELEMENT hNextElement;
 
 		LockElement (hElement, &ElementPtr);
@@ -835,7 +841,7 @@ PostProcessQueue (VIEW_STATE view_state,
 			hPostElement = hElement;
 			do
 			{
-				ELEMENTPTR PostElementPtr;
+				ELEMENT *PostElementPtr;
 
 				LockElement (hPostElement, &PostElementPtr);
 				if (!(PostElementPtr->state_flags & PRE_PROCESS))
@@ -920,16 +926,9 @@ PostProcessQueue (VIEW_STATE view_state,
 							else
 								CALC_ZOOM_STUFF (&index, &scale);
 
-							ElementPtr->next.image.frame =
-#ifdef SAFE
-									SetAbsFrameIndex (
-									ElementPtr->next.image.farray[index],
-									GetFrameIndex (ElementPtr->next.image.frame));
-#else /* SAFE */
-									SetEquFrameIndex (
+							ElementPtr->next.image.frame = SetEquFrameIndex (
 									ElementPtr->next.image.farray[index],
 									ElementPtr->next.image.frame);
-#endif /* SAFE */
 
 							if (optMeleeScale == TFB_SCALE_TRILINEAR &&
 									index < 2 && scale != 256)
@@ -938,24 +937,19 @@ PostProcessQueue (VIEW_STATE view_state,
 								// (smaller) zoom level image as mipmap,
 								// needed for trilinear scaling
 
-								PFRAME_DESC frame = 
-									SetAbsFrameIndex (
-									ElementPtr->next.image.farray
-									[index + 1],
-									GetFrameIndex (ElementPtr->next.image.frame));
-
-								if (frame && frame->image)
+								FRAME frame = ElementPtr->next.image.frame;
+								FRAME mmframe = SetEquFrameIndex (
+										ElementPtr->next.image.farray[
+										index + 1], frame);
+
+								// TODO: This is currently hacky, this code
+								//   really should not dereference FRAME.
+								//   Perhaps make mipmap part of STAMP prim?
+								if (frame && mmframe)
 								{
-									TFB_DrawCommand DC;
-									TFB_Image *mmimg = frame->image;
-									DC.Type = TFB_DRAWCOMMANDTYPE_SETMIPMAP;
-									DC.data.setmipmap.image = ((PFRAME_DESC)ElementPtr->next.image.frame)->image;
-									DC.data.setmipmap.hotx = frame->HotSpot.x;
-									DC.data.setmipmap.hoty = frame->HotSpot.y;
-									LockMutex (mmimg->mutex);
-									DC.data.setmipmap.mipmap = mmimg->NormalImg;
-									UnlockMutex (mmimg->mutex);
-									TFB_EnqueueDrawCommand (&DC);
+									HOT_SPOT mmhs = GetFrameHot (mmframe);
+									TFB_DrawScreen_SetMipmap (frame->image,
+											mmframe->image, mmhs.x, mmhs.y);
 								}
 							}
 						}
@@ -1061,15 +1055,17 @@ RedrawQueue (BOOLEAN clear)
 	DisplayLinks = MakeLinks (END_OF_LIST, END_OF_LIST);
 }
 
+// Set the hTarget field to 0 for all elements in the display list that
+// have hTarget set to ElementPtr.
 void
-Untarget (ELEMENTPTR ElementPtr)
+Untarget (ELEMENT *ElementPtr)
 {
 	HELEMENT hElement, hNextElement;
 
 	for (hElement = GetHeadElement (); hElement; hElement = hNextElement)
 	{
 		HELEMENT hTarget;
-		ELEMENTPTR ListPtr;
+		ELEMENT *ListPtr;
 
 		LockElement (hElement, &ListPtr);
 		hNextElement = GetSuccElement (ListPtr);
@@ -1077,7 +1073,7 @@ Untarget (ELEMENTPTR ElementPtr)
 		hTarget = ListPtr->hTarget;
 		if (hTarget)
 		{
-			ELEMENTPTR TargetElementPtr;
+			ELEMENT *TargetElementPtr;
 
 			LockElement (hTarget, &TargetElementPtr);
 			if (TargetElementPtr == ElementPtr)
@@ -1094,7 +1090,7 @@ RemoveElement (HLINK hLink)
 {
 	if (optStereoSFX)
 	{
-		ELEMENTPTR ElementPtr;
+		ELEMENT *ElementPtr;
 
 		LockElement (hLink, &ElementPtr);
 		if (ElementPtr != NULL)
diff -ruNp src.orig/sc2code/races.h src/sc2code/races.h
--- src.orig/sc2code/races.h	2017-11-08 16:49:36 -0600
+++ src/sc2code/races.h	2017-11-08 16:50:03 -0600
@@ -19,28 +19,23 @@
 #ifndef _RACES_H
 #define _RACES_H
 
+#include "libs/compiler.h"
 #include "units.h"
+#include "displist.h"
+
+typedef struct STARSHIP STARSHIP;
+typedef HLINK HSTARSHIP;
+
 #include "element.h"
-#include "libs/compiler.h"
 #include "libs/sndlib.h"
+#include "libs/reslib.h"
 
 
+// TODO: remove RACES_PER_PLAYER remnant of SC1
 #define RACES_PER_PLAYER 7
 #define MAX_SHIPS_PER_SIDE 14
 
-/* heat of battle specific flags */
-#define LEFT                   (1 << 0)
-#define RIGHT                  (1 << 1)
-#define THRUST                 (1 << 2)
-#define WEAPON                 (1 << 3)
-#define SPECIAL                (1 << 4)
-#define LOW_ON_ENERGY          (1 << 5)
-#define SHIP_BEYOND_MAX_SPEED  (1 << 6)
-#define SHIP_AT_MAX_SPEED      (1 << 7)
-#define SHIP_IN_GRAVITY_WELL   (1 << 8)
-#define PLAY_VICTORY_DITTY     (1 << 9)
-
-/* ship specific flags */
+/* SHIP_INFO.ship_flags - ship specific flags */
 /*
 #define GOOD_GUY  (1 << 0)
 #define BAD_GUY   (1 << 1)
@@ -60,20 +55,70 @@
 #define PLAYER_CAPTAIN    (1 << 13)
 		/* The protagonist himself is on board. He gets a different color. */
 
+/* These track the old resource package orderings for the ship resource indices */
+typedef enum
+{
+	NO_ID,
+	ARILOU_ID,
+	CHMMR_ID,
+	EARTHLING_ID,
+	ORZ_ID,
+	PKUNK_ID,
+	SHOFIXTI_ID,
+	SPATHI_ID,
+	SUPOX_ID,
+	THRADDASH_ID,
+	UTWIG_ID,
+	VUX_ID,
+	YEHAT_ID,
+	MELNORME_ID,
+	DRUUGE_ID,
+	ILWRATH_ID,
+	MYCON_ID,
+	SLYLANDRO_ID,
+	UMGAH_ID,
+	UR_QUAN_ID,
+	ZOQFOTPIK_ID,
+	SYREEN_ID,
+	KOHR_AH_ID,
+	ANDROSYNTH_ID,
+	CHENJESU_ID,
+	MMRNMHRM_ID,
+	LAST_MELEE_ID = MMRNMHRM_ID,
+	SIS_SHIP_ID,
+	SA_MATRA_ID,
+	UR_QUAN_PROBE_ID,
+	NUM_SPECIES_ID
+} SPECIES_ID;
 
 typedef struct captain_stuff
 {
+	RESOURCE captain_rsc;
 	FRAME background;
 	FRAME turn;
 	FRAME thrust;
 	FRAME weapon;
 	FRAME special;
 } CAPTAIN_STUFF;
-typedef CAPTAIN_STUFF *PCAPTAIN_STUFF;
-#define CAPTAIN_STUFFPTR PCAPTAIN_STUFF
 
-typedef void (IntelligenceFunc) (PVOID ShipPtr, PVOID ObjectsOfConcern,
-		COUNT ConcernCounter);
+typedef enum
+{
+	PURSUE = 0,
+	AVOID,
+	ENTICE,
+	NO_MOVEMENT
+} MOVEMENT_STATE;
+
+typedef struct
+{
+	ELEMENT *ObjectPtr;
+	COUNT facing;
+	COUNT which_turn;
+	MOVEMENT_STATE MoveState;
+} EVALUATE_DESC;
+
+typedef void (IntelligenceFunc) (ELEMENT *ShipPtr,
+		EVALUATE_DESC *ObjectsOfConcern, COUNT ConcernCounter);
 typedef struct
 {
 	COUNT ManeuverabilityIndex;
@@ -83,243 +128,243 @@ typedef struct
 
 typedef struct
 {
-	COUNT max_thrust,
-	      thrust_increment;
-	BYTE energy_regeneration,
-	     weapon_energy_cost,
-	     special_energy_cost,
-	     energy_wait,
-	     turn_wait,
-	     thrust_wait,
-	     weapon_wait,
-	     special_wait,
-	     ship_mass;
+	COUNT max_thrust;
+	COUNT thrust_increment;
+	BYTE energy_regeneration;
+	BYTE weapon_energy_cost;
+	BYTE special_energy_cost;
+	BYTE energy_wait;
+	BYTE turn_wait;
+	BYTE thrust_wait;
+	BYTE weapon_wait;
+	BYTE special_wait;
+	BYTE ship_mass;
 } CHARACTERISTIC_STUFF;
-typedef CHARACTERISTIC_STUFF *PCHARACTERISTIC_STUFF;
 
 typedef struct
 {
 	UWORD ship_flags;
-	BYTE var1, var2;
-	COUNT crew_level, max_crew;
-			/* For ships in npc_built_ship_q, the value INFINITE_FLEET for
-			 * crew_level indicates an infinite number of ships. */
-	BYTE energy_level, max_energy;
-	POINT loc;
-
-	/* The fields above this line are included in queues in savegames,
-	 * All fields, including those below, are saved in ENCOUNTER structures
-	 * in savegames. The latter was probably not supposed to happen.
-	 */
+	BYTE ship_cost;
+	
+	COUNT crew_level;
+	COUNT max_crew;
+	BYTE energy_level;
+	BYTE max_energy;
+
+	RESOURCE race_strings_rsc;
+	RESOURCE icons_rsc;
+	RESOURCE melee_icon_rsc;
 
 	STRING race_strings;
-	FRAME icons, melee_icon;
-#define INFINITE_FLEET ((COUNT) ~0)
+	FRAME icons;
+	FRAME melee_icon;
 } SHIP_INFO;
-typedef SHIP_INFO *PSHIP_INFO;
-#define SHIP_INFOPTR PSHIP_INFO
-
-#define ship_cost var1
-#define group_counter ship_flags
-
-enum
-{
-	IN_ORBIT = 0,
-	EXPLORE,
-	FLEE,
-	ON_STATION,
-
-	IGNORE_FLAGSHIP = 1 << 2,
-	REFORM_GROUP = 1 << 3
-};
-#define MAX_REVOLUTIONS 5
-
-#define GET_RACE_ID(s)          ((s)->ShipInfo.var1)
-#define SET_RACE_ID(s,v)        ((s)->ShipInfo.var1 = (v))
-#define GET_GROUP_LOC(s)        LONIBBLE ((s)->ShipInfo.var2)
-#define SET_GROUP_LOC(s,v)      ((s)->ShipInfo.var2 = \
-		MAKE_BYTE ((v), HINIBBLE ((s)->ShipInfo.var2)))
-#define GET_GROUP_MISSION(s)    HINIBBLE ((s)->ShipInfo.var2)
-#define SET_GROUP_MISSION(s,v)  ((s)->ShipInfo.var2 = \
-		MAKE_BYTE (LONIBBLE ((s)->ShipInfo.var2), (v)))
-#define GET_GROUP_DEST(s)       LONIBBLE ((s)->ShipInfo.energy_level)
-#define SET_GROUP_DEST(s,v)     ((s)->ShipInfo.energy_level = \
-		MAKE_BYTE ((v), HINIBBLE ((s)->ShipInfo.energy_level)))
-#define GET_ORBIT_LOC(s)        HINIBBLE ((s)->ShipInfo.energy_level)
-#define SET_ORBIT_LOC(s,v)      ((s)->ShipInfo.energy_level = \
-		MAKE_BYTE (LONIBBLE ((s)->ShipInfo.energy_level), (v)))
-#define GET_GROUP_ID(s)         ((s)->ShipInfo.max_energy)
-#define SET_GROUP_ID(s,v)       ((s)->ShipInfo.max_energy = (v))
-
-#define STATION_RADIUS 1600
-#define ORBIT_RADIUS 2400
 
 typedef struct
 {
-	UWORD ship_flags;
-	BYTE days_left;
-			/* Days left before the fleet reachers 'dest_loc'. */
-	BYTE growth_fract;
-	COUNT crew_level, max_crew;
-			/* For ships in npc_built_ship_q, the value INFINITE_FLEET for
-			 * crew_level indicates an infinite number of ships. */
-	BYTE energy_level, max_energy;
-	POINT loc;
-			/* Location of the fleet (center) */
-
-	STRING race_strings;
-			/* Race specific strings, see doc/devel/racestrings. */
-	FRAME icons, melee_icon;
-
-	/*   -== The fields below this line are included in savegames. ==-   */
-
-	COUNT actual_strength;
-			/* Measure for the size of the sphere of influence.
-			 * 0 if there is none and no ships will be generated.
-	         * '(COUNT) ~0' if there is none, and the ship generation
-			 * is handled separately. */
-	COUNT known_strength;
-			/* Measure for the size of the sphere of influence when last
-			 * checked the starmap.
-			 * 0 if the race's SoI is not known. */
+	COUNT strength;
 	POINT known_loc;
-			/* Location of the SoI (center) when last checked
-			 * the starmap. */
 
-	BYTE growth_err_term;
-	BYTE func_index;
-			/* Function index defined in clock.h (the same as in SetEvent())
-			 * for the function to call when the fleet reaches 'dest_loc'.
-			 * '(BYTE) ~0' means no function to call. */
-	POINT dest_loc;
-			/* Location to which the fleet (center) is moving. */
-} EXTENDED_SHIP_INFO;
-typedef EXTENDED_SHIP_INFO *PEXTENDED_SHIP_INFO;
+#define INFINITE_RADIUS ((COUNT) ~0)
+} FLEET_STUFF;
 
 typedef struct
 {
+	RESOURCE ship_rsc[NUM_VIEWS];
+	RESOURCE weapon_rsc[NUM_VIEWS];
+	RESOURCE special_rsc[NUM_VIEWS];
+	CAPTAIN_STUFF captain_control;
+	RESOURCE victory_ditty_rsc;
+	RESOURCE ship_sounds_rsc;
+
 	FRAME ship[NUM_VIEWS];
 	FRAME weapon[NUM_VIEWS];
 	FRAME special[NUM_VIEWS];
-	CAPTAIN_STUFF captain_control;
-	DWORD victory_ditty;
+	MUSIC_REF victory_ditty;
 	SOUND ship_sounds;
 } DATA_STUFF;
-typedef DATA_STUFF *PDATA_STUFF;
-#define DATA_STUFFPTR PDATA_STUFF
 
 
 typedef struct race_desc RACE_DESC;
-typedef RACE_DESC *PRACE_DESC;
-#define RACE_DESCPTR PRACE_DESC
 
-typedef void (PREPROCESS_FUNC) (PELEMENT ElementPtr);
-typedef void (POSTPROCESS_FUNC) (PELEMENT ElementPtr);
-typedef COUNT (INIT_WEAPON_FUNC) (PELEMENT ElementPtr, HELEMENT Weapon[]);
-typedef void (UNINIT_FUNC) (RACE_DESCPTR pRaceDesc);
+typedef void (PREPROCESS_FUNC) (ELEMENT *ElementPtr);
+typedef void (POSTPROCESS_FUNC) (ELEMENT *ElementPtr);
+typedef COUNT (INIT_WEAPON_FUNC) (ELEMENT *ElementPtr, HELEMENT Weapon[]);
+typedef void (UNINIT_FUNC) (RACE_DESC *pRaceDesc);
 
 struct race_desc
 {
 	SHIP_INFO ship_info _ALIGNED_ANY;
+	FLEET_STUFF fleet _ALIGNED_ANY;
 	CHARACTERISTIC_STUFF characteristics _ALIGNED_ANY;
 	DATA_STUFF ship_data _ALIGNED_ANY;
 	INTEL_STUFF cyborg_control _ALIGNED_ANY;
 
-	UNINIT_FUNC *uninit_func
-			_ALIGNED_ON(sizeof (UNINIT_FUNC *));
-	PREPROCESS_FUNC *preprocess_func
-			_ALIGNED_ON(sizeof (PREPROCESS_FUNC *));
-	POSTPROCESS_FUNC *postprocess_func 
-			_ALIGNED_ON(sizeof (POSTPROCESS_FUNC *));
-	INIT_WEAPON_FUNC *init_weapon_func
-			_ALIGNED_ON(sizeof (INIT_WEAPON_FUNC *));
+	UNINIT_FUNC *uninit_func;
+	PREPROCESS_FUNC *preprocess_func;
+	POSTPROCESS_FUNC *postprocess_func;
+	INIT_WEAPON_FUNC *init_weapon_func;
 
-	PVOID CodeRef _ALIGNED_ON(sizeof (PVOID));
+	void *CodeRef;
 };
 
-
-typedef QUEUE_HANDLE HSTARSHIP;
+#define SHIP_BASE_COMMON \
+	/* LINK elements; must be first */ \
+	HLINK pred; \
+	HLINK succ; \
+	\
+	SPECIES_ID SpeciesID; \
+	BYTE captains_name_index \
+			/* Also used in full-game to detect if a STARSHIP is an escort
+			 * or the flagship (captains_name_index == 0) */
 
 typedef struct
 {
-	HSTARSHIP pred;
-	HSTARSHIP succ;
+	SHIP_BASE_COMMON;
+} SHIP_BASE;
 
-	DWORD RaceResIndex;
+
+struct STARSHIP
+{
+	SHIP_BASE_COMMON;
 	
-	/* This field is abused to store other data when the ship
-	 * is in GLOBAL(built_ship_q), GLOBDATA(npc_built_ship_q),
-	 * or race_q[], namely the side this ship is on (accessed
-	 * through StarShipPlayer()), and the captains name for
-	 * the ship (accessed through StarShipCaptain()).
-	 * These values are set using OwnStarShip(). */
-	union {
-		RACE_DESCPTR RaceDescPtr;
-		struct {
-			COUNT Player;
-			BYTE Captain;
-		} s;
-	};
+	RACE_DESC *RaceDescPtr;
 
-	BYTE captains_name_index;
+	// Ship information
+	UWORD which_side;
+			// In race_q: side the ship is on
+	COUNT crew_level;
+			// In full-game battles: crew left
+			// In SuperMelee: irrelevant
+	COUNT max_crew;
+	BYTE ship_cost;
+			// In Super Melee ship queue: ship cost
+			// In full-game: irrelevant
+	COUNT index;
+			// original queue index
+	STRING race_strings;
+	FRAME icons;
 
+	// Battle states
 	BYTE weapon_counter;
+			// In battle: frames left before primary weapon can be used
 	BYTE special_counter;
+			// In battle: frames left before special can be used
 	BYTE energy_counter;
+			// In battle: frames left before energy regeneration
 
 	BYTE ship_input_state;
-	UWORD cur_status_flags _ALIGNED_ON(sizeof (UWORD));
-	UWORD old_status_flags _ALIGNED_ON(sizeof (UWORD));
+	STATUS_FLAGS cur_status_flags;
+	STATUS_FLAGS old_status_flags;
+
+	HELEMENT hShip;
+	COUNT ShipFacing;
+};
 
-	FRAME silhouette _ALIGNED_ON(sizeof (FRAME));
-	HELEMENT hShip _ALIGNED_ON(sizeof (HELEMENT));
-	COUNT ShipFacing _ALIGNED_ON(sizeof (COUNT));
-} STARSHIP;
-typedef STARSHIP *PSTARSHIP;
-#define STARSHIPPTR PSTARSHIP
+static inline STARSHIP *
+LockStarShip (const QUEUE *pq, HSTARSHIP h)
+{
+	assert (GetLinkSize (pq) == sizeof (STARSHIP));
+	return (STARSHIP *) LockLink (pq, h);
+}
+
+#define UnlockStarShip(pq, h)  UnlockLink (pq, h)
+#define FreeStarShip(pq, h)    FreeLink (pq, h)
+
+
+typedef HLINK HSHIPFRAG;
 
 typedef struct
 {
-	HSTARSHIP pred;
-	HSTARSHIP succ;
+	SHIP_BASE_COMMON;
 
-	DWORD RaceResIndex;
+	COUNT which_side;
 
-	/* This field is abused to store other data when the ship
-	 * is in GLOBAL(built_ship_q), GLOBDATA(npc_built_ship_q),
-	 * or race_q[], namely the side this ship is on (accessed
-	 * through StarShipPlayer()), and the captains name for
-	 * the ship (accessed through StarShipCaptain()).
-	 * These values are set using OwnStarShip(). */
-	union {
-		RACE_DESCPTR RaceDescPtr;
-		struct {
-			COUNT Player;
-			BYTE Captain;
-		} s;
-	};
+	BYTE race_id;
+	BYTE index;
+	COUNT crew_level;
+			/* For ships in npc_built_ship_q, the value INFINITE_FLEET for
+			 * crew_level indicates an infinite number of ships. */
+	COUNT max_crew;
+	
+	BYTE energy_level;
+	BYTE max_energy;
+			// XXX: energy_level and max_energy are unused. We save and load
+			//   them, but otherwise nothing needs them atm.
 
-	SHIP_INFO ShipInfo;
+	STRING race_strings;
+	FRAME icons;
+	FRAME melee_icon;  /* Only used by Shipyard */
+
+#define INFINITE_FLEET ((COUNT) ~0)
 } SHIP_FRAGMENT;
-typedef SHIP_FRAGMENT *PSHIP_FRAGMENT;
-#define SHIP_FRAGMENTPTR PSHIP_FRAGMENT
+
+static inline SHIP_FRAGMENT *
+LockShipFrag (const QUEUE *pq, HSHIPFRAG h)
+{
+	assert (GetLinkSize (pq) == sizeof (SHIP_FRAGMENT));
+	return (SHIP_FRAGMENT *) LockLink (pq, h);
+}
+
+#define UnlockShipFrag(pq, h)  UnlockLink (pq, h)
+#define FreeShipFrag(pq, h)    FreeLink (pq, h)
+
+
+typedef HLINK HFLEETINFO;
 
 typedef struct
 {
-	HSTARSHIP pred;
-	HSTARSHIP succ;
+	// LINK elements; must be first
+	HFLEETINFO pred;
+	HFLEETINFO succ;
+
+	SPECIES_ID SpeciesID;
+
+	UWORD ship_flags; /* 0, GOOD_GUY, or BAD_GUY */
+	BYTE days_left;   /* Days left before the fleet reachers 'dest_loc'. */
+	BYTE growth_fract;
+	COUNT crew_level;
+	COUNT max_crew;
+	BYTE growth;
+	BYTE max_energy;
+	POINT loc;        /* Location of the fleet (center) */
 
-	DWORD RaceResIndex;
-	RACE_DESCPTR RaceDescPtr;
-	EXTENDED_SHIP_INFO ShipInfo;
-} EXTENDED_SHIP_FRAGMENT;
-typedef EXTENDED_SHIP_FRAGMENT *PEXTENDED_SHIP_FRAGMENT;
-#define EXTENDED_SHIP_FRAGMENTPTR PEXTENDED_SHIP_FRAGMENT
-
-#define AllocStarShip(pq) AllocLink (pq)
-#define LockStarShip(pq,h) (STARSHIPPTR)LockLink (pq, h)
-#define UnlockStarShip(pq,h) UnlockLink (pq, h)
-#define FreeStarShip(pq,h) FreeLink (pq, h)
+	STRING race_strings;
+			/* Race specific strings, see doc/devel/racestrings. */
+	FRAME icons;
+	FRAME melee_icon;
+
+	COUNT actual_strength;
+			/* Measure for the size of the sphere of influence.
+			 * 0 if there is none and no ships will be generated.
+	         * '(COUNT) ~0' if there is none, and the ship generation
+			 * is handled separately. */
+	COUNT known_strength;
+			/* Measure for the size of the sphere of influence when last
+			 * checked the starmap.
+			 * 0 if the race's SoI is not known. */
+	POINT known_loc;
+			/* Location of the SoI (center) when last checked
+			 * the starmap. */
+
+	BYTE growth_err_term;
+	BYTE func_index;
+			/* Function index defined in clock.h (the same as in SetEvent())
+			 * for the function to call when the fleet reaches 'dest_loc'.
+			 * '(BYTE) ~0' means no function to call. */
+	POINT dest_loc;
+			/* Location to which the fleet (center) is moving. */
+
+} FLEET_INFO;
+
+static inline FLEET_INFO *
+LockFleetInfo (const QUEUE *pq, HFLEETINFO h)
+{
+	assert (GetLinkSize (pq) == sizeof (FLEET_INFO));
+	return (FLEET_INFO *) LockLink (pq, h);
+}
+
+#define UnlockFleetInfo(pq, h) UnlockLink (pq, h)
 
 enum
 {
@@ -353,12 +398,10 @@ enum
 	NUM_AVAILABLE_RACES
 };
 
-#define YEHAT_REBEL_CONVERSATION (~0L)
-
 #define RACE_COMMUNICATION \
 		ARILOU_CONVERSATION,       /* ARILOU_SHIP */ \
 		CHMMR_CONVERSATION,        /* CHMMR_SHIP */ \
-		0L,                        /* HUMAN_SHIP */ \
+		INVALID_CONVERSATION,      /* HUMAN_SHIP */ \
 		ORZ_CONVERSATION,          /* ORZ_SHIP */ \
 		PKUNK_CONVERSATION,        /* PKUNK_SHIP */ \
 		SHOFIXTI_CONVERSATION,     /* SHOFIXTI_SHIP */ \
@@ -376,11 +419,40 @@ enum
 		UMGAH_CONVERSATION,        /* UMGAH_SHIP */ \
 		URQUAN_CONVERSATION,       /* URQUAN_SHIP */ \
 		ZOQFOTPIK_CONVERSATION,    /* ZOQFOTPIK_SHIP */ \
-		0L,                        /* SYREEN_SHIP */ \
+		INVALID_CONVERSATION,      /* SYREEN_SHIP */ \
 		BLACKURQ_CONVERSATION,     /* BLACK_URQUAN_SHIP */ \
 		YEHAT_REBEL_CONVERSATION,  /* YEHAT_REBEL_SHIP */ \
-		0L,                        /* URQUAN_PROBE_SHIP */
+		URQUAN_PROBE_CONVERSATION, /* URQUAN_PROBE_SHIP */
 
+#define RACE_SHIP_FOR_COMM \
+	ARILOU_SHIP,       /* ARILOU_CONVERSATION */ \
+	CHMMR_SHIP,        /* CHMMR_CONVERSATION */ \
+	HUMAN_SHIP,        /* COMMANDER_CONVERSATION */ \
+	ORZ_SHIP,          /* ORZ_CONVERSATION */ \
+	PKUNK_SHIP,        /* PKUNK_CONVERSATION */ \
+	SHOFIXTI_SHIP,     /* SHOFIXTI_CONVERSATION */ \
+	SPATHI_SHIP,       /* SPATHI_CONVERSATION */ \
+	SUPOX_SHIP,        /* SUPOX_CONVERSATION */ \
+	THRADDASH_SHIP,    /* THRADD_CONVERSATION */ \
+	UTWIG_SHIP,        /* UTWIG_CONVERSATION */ \
+	VUX_SHIP,          /* VUX_CONVERSATION */ \
+	YEHAT_SHIP,        /* YEHAT_CONVERSATION */ \
+	MELNORME_SHIP,     /* MELNORME_CONVERSATION */ \
+	DRUUGE_SHIP,       /* DRUUGE_CONVERSATION */ \
+	ILWRATH_SHIP,      /* ILWRATH_CONVERSATION */ \
+	MYCON_SHIP,        /* MYCON_CONVERSATION */ \
+	SLYLANDRO_SHIP,    /* SLYLANDRO_CONVERSATION */ \
+	UMGAH_SHIP,        /* UMGAH_CONVERSATION */ \
+	URQUAN_SHIP,       /* URQUAN_CONVERSATION */ \
+	ZOQFOTPIK_SHIP,    /* ZOQFOTPIK_CONVERSATION */ \
+	SYREEN_SHIP,       /* SYREEN_CONVERSATION */ \
+	BLACK_URQUAN_SHIP, /* BLACKURQ_CONVERSATION */ \
+	UMGAH_SHIP,        /* TALKING_PET_CONVERSATION */ \
+	SLYLANDRO_SHIP,    /* SLYLANDRO_HOME_CONVERSATION */ \
+	URQUAN_PROBE_SHIP, /* URQUAN_PROBE_CONVERSATION */ \
+	YEHAT_SHIP,        /* YEHAT_REBEL_CONVERSATION */ \
+	HUMAN_SHIP         /* INVALID_CONVERSATION */
+ 
 #define RACE_SHIP_COST \
 		1600,  /* ARILOU_SHIP */ \
 		3000,  /* CHMMR_SHIP */ \
@@ -541,7 +613,7 @@ enum
 
 #define RACE_COLORS \
 		BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x10), 0x53),  /* ARILOU_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x00), 0x00),  /* CHMMR_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15 (0x02, 0x05, 0x0C), 0x00),  /* CHMMR_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15 (0x00, 0x01, 0x1f), 0x4D),  /* HUMAN_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15 (0x0E, 0x00, 0x0E), 0x36),  /* ORZ_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15 (0x00, 0x06, 0x08), 0x62),  /* PKUNK_SHIP */ \
@@ -560,7 +632,7 @@ enum
 		BUILD_COLOR (MAKE_RGB15 (0x0A, 0x00, 0x11), 0x3D),  /* UMGAH_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15 (0x00, 0x08, 0x00), 0x6E),  /* URQUAN_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15 (0x0F, 0x00, 0x00), 0x2D),  /* ZOQFOTPIK_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x00), 0x00),  /* SYREEN_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15 (0x0C, 0x05, 0x02), 0x00),  /* SYREEN_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15 (0x06, 0x06, 0x06), 0x20),  /* BLACK_URQUAN_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15 (0x14, 0x07, 0x1F), 0x39),  /* YEHAT_REBEL_SHIP */
 
@@ -586,20 +658,18 @@ enum
 
 extern BOOLEAN InitKernel (void);
 
-extern void DrawCaptainsWindow (STARSHIPPTR
-		StarShipPtr);
-extern BOOLEAN GetNextStarShip (STARSHIPPTR
-		LastStarShipPtr, COUNT which_side);
-extern HSTARSHIP GetEncounterStarShip (STARSHIPPTR
-		LastStarShipPtr, COUNT which_player);
-extern void DrawArmadaPickShip (BOOLEAN
-		draw_salvage_frame, PRECT pPickRect);
-
-extern BOOLEAN load_animation (PFRAME pixarray, DWORD
-		big_res, DWORD med_res, DWORD sml_res);
-extern BOOLEAN free_image (PFRAME pixarray);
-extern void NotifyOthers (COUNT which_race, BYTE
-		target_loc);
+extern void DrawCaptainsWindow (STARSHIP *StarShipPtr);
+extern BOOLEAN GetNextStarShip (STARSHIP *LastStarShipPtr,
+		COUNT which_side);
+extern BOOLEAN GetInitialStarShips (void);
+extern HSTARSHIP GetEncounterStarShip (STARSHIP *LastStarShipPtr,
+		COUNT which_player);
+extern void DrawArmadaPickShip (BOOLEAN draw_salvage_frame, RECT *pPickRect);
+
+extern BOOLEAN load_animation (FRAME *pixarray, RESOURCE big_res,
+		RESOURCE med_res, RESOURCE sml_res);
+extern BOOLEAN free_image (FRAME *pixarray);
+extern void NotifyOthers (COUNT which_race, BYTE target_loc);
 
 #endif /* _RACES_H */
 
diff -ruNp src.orig/sc2code/resinst.h src/sc2code/resinst.h
--- src.orig/sc2code/resinst.h	2017-11-08 16:49:36 -0600
+++ src/sc2code/resinst.h	2017-11-08 16:50:03 -0600
@@ -22,4 +22,3 @@
 #include "istrtab.h"
 #include "isndres.h"
 #include "imusicre.h"
-#include "ires_ind.h"
diff -ruNp src.orig/sc2code/respkg.h src/sc2code/respkg.h
--- src.orig/sc2code/respkg.h	2017-11-08 16:49:36 -0600
+++ src/sc2code/respkg.h	2017-11-08 16:50:03 -0600
@@ -126,7 +126,7 @@ enum
 	ULTRAVIOLET_COLOR_PACKAGE,
 	PLUTONIC_COLOR_PACKAGE,
 	RAINBOW_COLOR_PACKAGE,
-	CRACKED_PACKAGE,
+	SHATTERED_PACKAGE,
 	SAPPHIRE_COLOR_PACKAGE,
 	SAPPHIRE_XLAT_PACKAGE,
 	ORGANIC_COLOR_PACKAGE,
diff -ruNp src.orig/sc2code/restart.c src/sc2code/restart.c
--- src.orig/sc2code/restart.c	2017-11-08 16:49:36 -0600
+++ src/sc2code/restart.c	2017-11-08 16:50:03 -0600
@@ -23,6 +23,7 @@
 #include "credits.h"
 #include "encount.h"
 #include "fmv.h"
+#include "gamestr.h"
 #include "globdata.h"
 #include "intel.h"
 #include "melee.h"
@@ -50,14 +51,12 @@ enum
 };
 
 static void
-DrawRestartMenuGraphic (PMENU_STATE pMS)
+DrawRestartMenuGraphic (MENU_STATE *pMS)
 {
 	RECT r;
 	STAMP s;
 
-	s.frame = CaptureDrawable (
-		LoadGraphic (RESTART_PMAP_ANIM)
-		);
+	s.frame = CaptureDrawable (LoadGraphic (RESTART_PMAP_ANIM));
 	pMS->CurFrame = s.frame;
 	GetFrameRect (s.frame, &r);
 	s.origin.x = (SCREEN_WIDTH - r.extent.width) >> 1;
@@ -82,8 +81,13 @@ DrawRestartMenu (BYTE OldState, BYTE New
 
 	LockMutex (GraphicsLock);
 	SetContext (ScreenContext);
-	r.corner.x = r.corner.y = r.extent.width = r.extent.height = 0;
+
+	r.corner.x = 0;
+	r.corner.y = 0;
+	r.extent.width = 0;
+	r.extent.height = 0;
 	SetContextClipRect (&r);
+
 	r.corner.x = 0;
 	r.corner.y = 0;
 	r.extent.width = SCREEN_WIDTH;
@@ -108,7 +112,7 @@ DrawRestartMenu (BYTE OldState, BYTE New
 
 
 static BOOLEAN
-DoRestart (PMENU_STATE pMS)
+DoRestart (MENU_STATE *pMS)
 {
 	static DWORD InTime;
 	static DWORD InactTimeOut;
@@ -133,7 +137,8 @@ DoRestart (PMENU_STATE pMS)
 
 		{
 			BYTE clut_buf[] = {FadeAllToColor};
-			DWORD TimeOut = XFormColorMap ((COLORMAPPTR)clut_buf, ONE_SECOND / 2);
+			DWORD TimeOut = XFormColorMap (
+					(COLORMAPPTR)clut_buf, ONE_SECOND / 2);
 			while ((GetTimeCounter () <= TimeOut) &&
 			       !(GLOBAL (CurrentActivity) & CHECK_ABORT))
 			{
@@ -142,15 +147,14 @@ DoRestart (PMENU_STATE pMS)
 			}
 		}
 	}
-#ifdef TESTING
-else if (InputState & DEVICE_EXIT) return (FALSE);
-#endif /* TESTING */
 	else if (GLOBAL (CurrentActivity) & CHECK_ABORT)
 	{
 		return (FALSE);
 	}
-	else if (!(PulsedInputState.menu[KEY_MENU_UP] || PulsedInputState.menu[KEY_MENU_DOWN] ||
-			PulsedInputState.menu[KEY_MENU_LEFT] || PulsedInputState.menu[KEY_MENU_RIGHT] ||
+	else if (!(PulsedInputState.menu[KEY_MENU_UP] ||
+			PulsedInputState.menu[KEY_MENU_DOWN] ||
+			PulsedInputState.menu[KEY_MENU_LEFT] ||
+			PulsedInputState.menu[KEY_MENU_RIGHT] ||
 			PulsedInputState.menu[KEY_MENU_SELECT] || MouseButtonDown))
 
 	{
@@ -183,10 +187,11 @@ else if (InputState & DEVICE_EXIT) retur
 				break;
 			case SETUP_GAME:
 				LockMutex (GraphicsLock);
-				SetFlashRect (NULL_PTR, (FRAME)0);
+				SetFlashRect (NULL, (FRAME)0);
 				UnlockMutex (GraphicsLock);
 				SetupMenu ();
-				SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);
+				SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN,
+						MENU_SOUND_SELECT);
 				InTime = GetTimeCounter ();
 				SetTransitionSource (NULL);
 				BatchGraphics ();
@@ -197,14 +202,15 @@ else if (InputState & DEVICE_EXIT) retur
 				return TRUE;
 			case QUIT_GAME:
 				fade_buf[0] = FadeAllToBlack;
-				SleepThreadUntil (XFormColorMap ((COLORMAPPTR)fade_buf, ONE_SECOND / 2));
+				SleepThreadUntil (XFormColorMap (
+						(COLORMAPPTR)fade_buf, ONE_SECOND / 2));
 
 				GLOBAL (CurrentActivity) = CHECK_ABORT;
 				break;
 		}
 
 		LockMutex (GraphicsLock);
-		SetFlashRect (NULL_PTR, (FRAME)0);
+		SetFlashRect (NULL, (FRAME)0);
 		UnlockMutex (GraphicsLock);
 
 		return (FALSE);
@@ -236,9 +242,10 @@ else if (InputState & DEVICE_EXIT) retur
 	if (MouseButtonDown)
 	{
 		LockMutex (GraphicsLock);
-		SetFlashRect (NULL_PTR, (FRAME)0);
+		SetFlashRect (NULL, (FRAME)0);
 		UnlockMutex (GraphicsLock);
-		MouseError ();
+		DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 56));
+				// Mouse not supported message
 		SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
 		SetTransitionSource (NULL);
 		BatchGraphics ();
@@ -253,7 +260,7 @@ else if (InputState & DEVICE_EXIT) retur
 }
 
 static BOOLEAN
-RestartMenu (PMENU_STATE pMS)
+RestartMenu (MENU_STATE *pMS)
 {
 	DWORD TimeOut;
 	BYTE black_buf[1];
@@ -276,7 +283,8 @@ RestartMenu (PMENU_STATE pMS)
 
 		SleepThreadUntil (XFormColorMap ((COLORMAPPTR)white_buf,
 				ONE_SECOND / 8) + ONE_SECOND / 60);
-		SetContextBackGroundColor (BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x1F), 0x0F));
+		SetContextBackGroundColor (
+				BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x1F), 0x0F));
 		ClearDrawable ();
 		FlushColorXForms ();
 
@@ -299,7 +307,8 @@ RestartMenu (PMENU_STATE pMS)
 		}
 	}
 
-	LastActivity = NextActivity = 0;
+	LastActivity = 0;
+	NextActivity = 0;
 
 	SleepThreadUntil (XFormColorMap ((COLORMAPPTR)black_buf, TimeOut));
 	if (TimeOut == ONE_SECOND / 8)
@@ -318,7 +327,7 @@ RestartMenu (PMENU_STATE pMS)
 	}
 
 	LockMutex (GraphicsLock);
-	SetFlashRect (NULL_PTR, (FRAME)0);
+	SetFlashRect (NULL, (FRAME)0);
 	UnlockMutex (GraphicsLock);
 	DestroyDrawable (ReleaseDrawable (pMS->CurFrame));
 
@@ -410,8 +419,8 @@ StartGame (void)
 	}
 
 	PlayerControl[0] = HUMAN_CONTROL | STANDARD_RATING;
-	PlayerControl[1] =  COMPUTER_CONTROL | AWESOME_RATING;
-	SetPlayerInput ();
+	PlayerControl[1] = COMPUTER_CONTROL | AWESOME_RATING;
 
 	return (TRUE);
 }
+
diff -ruNp src.orig/sc2code/restypes.h src/sc2code/restypes.h
--- src.orig/sc2code/restypes.h	2017-11-08 16:49:36 -0600
+++ src/sc2code/restypes.h	1969-12-31 18:00:00 -0600
@@ -1,35 +0,0 @@
-//Copyright Paul Reiche, Fred Ford. 1992-2002
-
-/*
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef _RESTYPES_H
-#define _RESTYPES_H
-
-enum
-{
-	KEY_CONFIG = 1,
-	GFXRES,
-	FONTRES,
-	STRTAB,
-	SNDRES,
-	MUSICRES,
-	RES_INDEX,
-	CODE
-};
-
-#endif /* _RESTYPES_H */
-
diff -ruNp src.orig/sc2code/save.c src/sc2code/save.c
--- src.orig/sc2code/save.c	2017-11-08 16:49:36 -0600
+++ src/sc2code/save.c	2017-11-08 16:50:03 -0600
@@ -32,6 +32,7 @@
 #include "shipcont.h"
 #include "setup.h"
 #include "state.h"
+#include "grpinfo.h"
 #include "util.h"
 #include "libs/inplib.h"
 #include "libs/log.h"
@@ -63,43 +64,43 @@ cwrite_ptr (DECODE_REF fh)
 }
 
 static inline COUNT
-cwrite_a8 (DECODE_REF fh, PBYTE ar, COUNT count)
+cwrite_a8 (DECODE_REF fh, const BYTE *ar, COUNT count)
 {
 	return cwrite (ar, 1, count, fh) == count;
 }
 
 static inline COUNT
-write_8 (PVOID fp, BYTE v)
+write_8 (void *fp, BYTE v)
 {
 	return WriteResFile (&v, 1, 1, fp);
 }
 
 static inline COUNT
-write_16 (PVOID fp, UWORD v)
+write_16 (void *fp, UWORD v)
 {
 	return WriteResFile (&v, 2, 1, fp);
 }
 
 static inline COUNT
-write_32 (PVOID fp, DWORD v)
+write_32 (void *fp, DWORD v)
 {
 	return WriteResFile (&v, 4, 1, fp);
 }
 
 static inline COUNT
-write_ptr (PVOID fp)
+write_ptr (void *fp)
 {
 	return write_32 (fp, 0); /* ptrs are useless in saves */
 }
 
 static inline COUNT
-write_a8 (PVOID fp, PBYTE ar, COUNT count)
+write_a8 (void *fp, const BYTE *ar, COUNT count)
 {
 	return WriteResFile (ar, 1, count, fp) == count;
 }
 
 static inline COUNT
-write_a16 (PVOID fp, PUWORD ar, COUNT count)
+write_a16 (void *fp, const UWORD *ar, COUNT count)
 {
 	for ( ; count > 0; --count, ++ar)
 	{
@@ -110,10 +111,19 @@ write_a16 (PVOID fp, PUWORD ar, COUNT co
 }
 
 static void
-SaveShipQueue (DECODE_REF fh, PQUEUE pQueue)
+SaveEmptyQueue (DECODE_REF fh)
+{
+	COUNT num_links = 0;
+
+	// Write the number of entries in the queue.
+	cwrite_16 (fh, num_links);
+}
+
+static void
+SaveShipQueue (DECODE_REF fh, QUEUE *pQueue)
 {
 	COUNT num_links;
-	HSTARSHIP hStarShip;
+	HSHIPFRAG hStarShip;
 
 	// Write the number of entries in the queue.
 	num_links = CountLinks (pQueue);
@@ -122,66 +132,128 @@ SaveShipQueue (DECODE_REF fh, PQUEUE pQu
 	hStarShip = GetHeadLink (pQueue);
 	while (num_links--)
 	{
-		HSTARSHIP hNextShip;
-		SHIP_FRAGMENTPTR FragPtr;
+		HSHIPFRAG hNextShip;
+		SHIP_FRAGMENT *FragPtr;
 		COUNT Index;
 
-		FragPtr = (SHIP_FRAGMENTPTR)LockStarShip (pQueue, hStarShip);
+		FragPtr = LockShipFrag (pQueue, hStarShip);
 		hNextShip = _GetSuccLink (FragPtr);
 
-		if (pQueue == &GLOBAL (avail_race_q))
-			Index = GetIndexFromStarShip (pQueue, hStarShip);
-					// The index is the position in the queue.
-		else
-			Index = GET_RACE_ID (FragPtr);
-
+		Index = FragPtr->race_id;
 		// Write the number identifying this ship type.
 		// See races.h; look for the enum containing NUM_AVAILABLE_RACES.
 		cwrite_16 (fh, Index);
 
-		if (pQueue != &GLOBAL (avail_race_q))
-		{	// queues other than avail_race_q save SHIP_FRAGMENT elements
-			// Write SHIP_FRAGMENT elements
-			cwrite_16 (fh, FragPtr->s.Player);
-			cwrite_8  (fh, FragPtr->s.Captain);
-			cwrite_8  (fh, 0); /* padding */
-		}
-		// Write SHIP_INFO elements
-		cwrite_16 (fh, FragPtr->ShipInfo.ship_flags);
-		cwrite_8  (fh, FragPtr->ShipInfo.var1);
-		cwrite_8  (fh, FragPtr->ShipInfo.var2);
-		cwrite_8  (fh, FragPtr->ShipInfo.crew_level);
-		cwrite_8  (fh, FragPtr->ShipInfo.max_crew);
-		cwrite_8  (fh, FragPtr->ShipInfo.energy_level);
-		cwrite_8  (fh, FragPtr->ShipInfo.max_energy);
-		cwrite_16 (fh, FragPtr->ShipInfo.loc.x);
-		cwrite_16 (fh, FragPtr->ShipInfo.loc.y);
+		// Write SHIP_FRAGMENT elements
+		cwrite_16 (fh, FragPtr->which_side);
+		cwrite_8  (fh, FragPtr->captains_name_index);
+		cwrite_8  (fh, 0); /* padding */
+		cwrite_16 (fh, 0); /* unused: was ship_flags */
+		cwrite_8  (fh, FragPtr->race_id);
+		cwrite_8  (fh, FragPtr->index);
+		// XXX: writing crew as BYTE to maintain savegame compatibility
+		cwrite_8  (fh, FragPtr->crew_level);
+		cwrite_8  (fh, FragPtr->max_crew);
+		cwrite_8  (fh, FragPtr->energy_level);
+		cwrite_8  (fh, FragPtr->max_energy);
+		cwrite_16 (fh, 0); /* unused; was loc.x */
+		cwrite_16 (fh, 0); /* unused; was loc.y */
 
-		if (pQueue == &GLOBAL (avail_race_q))
-		{
-			// avail_race_q contains information not about specific ships,
-			// but about a race.
-			EXTENDED_SHIP_FRAGMENTPTR ExtFragPtr =
-					(EXTENDED_SHIP_FRAGMENTPTR) FragPtr;
-
-			cwrite_16 (fh, ExtFragPtr->ShipInfo.actual_strength);
-			cwrite_16 (fh, ExtFragPtr->ShipInfo.known_strength);
-			cwrite_16 (fh, ExtFragPtr->ShipInfo.known_loc.x);
-			cwrite_16 (fh, ExtFragPtr->ShipInfo.known_loc.y);
-			cwrite_8  (fh, ExtFragPtr->ShipInfo.growth_err_term);
-			cwrite_8  (fh, ExtFragPtr->ShipInfo.func_index);
-			cwrite_16 (fh, ExtFragPtr->ShipInfo.dest_loc.x);
-			cwrite_16 (fh, ExtFragPtr->ShipInfo.dest_loc.y);
-			cwrite_16 (fh, 0); /* alignment padding */
-		}
-
-		UnlockStarShip (pQueue, hStarShip);
+		UnlockShipFrag (pQueue, hStarShip);
 		hStarShip = hNextShip;
 	}
 }
 
 static void
-SaveEncounter (ENCOUNTERPTR EncounterPtr, DECODE_REF fh)
+SaveRaceQueue (DECODE_REF fh, QUEUE *pQueue)
+{
+	COUNT num_links;
+	HFLEETINFO hFleet;
+
+	// Write the number of entries in the queue.
+	num_links = CountLinks (pQueue);
+	cwrite_16 (fh, num_links);
+
+	hFleet = GetHeadLink (pQueue);
+	while (num_links--)
+	{
+		HFLEETINFO hNextFleet;
+		FLEET_INFO *FleetPtr;
+		COUNT Index;
+
+		FleetPtr = LockFleetInfo (pQueue, hFleet);
+		hNextFleet = _GetSuccLink (FleetPtr);
+
+		Index = GetIndexFromStarShip (pQueue, hFleet);
+		// The index is the position in the queue.
+		cwrite_16 (fh, Index);
+
+		// Write FLEET_INFO elements
+		cwrite_16 (fh, FleetPtr->ship_flags);
+		cwrite_8  (fh, FleetPtr->days_left);
+		cwrite_8  (fh, FleetPtr->growth_fract);
+		cwrite_8  (fh, FleetPtr->crew_level);
+		cwrite_8  (fh, FleetPtr->max_crew);
+		cwrite_8  (fh, FleetPtr->growth);
+		cwrite_8  (fh, FleetPtr->max_energy);
+		cwrite_16 (fh, FleetPtr->loc.x);
+		cwrite_16 (fh, FleetPtr->loc.y);
+
+		cwrite_16 (fh, FleetPtr->actual_strength);
+		cwrite_16 (fh, FleetPtr->known_strength);
+		cwrite_16 (fh, FleetPtr->known_loc.x);
+		cwrite_16 (fh, FleetPtr->known_loc.y);
+		cwrite_8  (fh, FleetPtr->growth_err_term);
+		cwrite_8  (fh, FleetPtr->func_index);
+		cwrite_16 (fh, FleetPtr->dest_loc.x);
+		cwrite_16 (fh, FleetPtr->dest_loc.y);
+		cwrite_16 (fh, 0); /* alignment padding */
+
+		UnlockFleetInfo (pQueue, hFleet);
+		hFleet = hNextFleet;
+	}
+}
+
+static void
+SaveGroupQueue (DECODE_REF fh, QUEUE *pQueue)
+{
+	HIPGROUP hGroup, hNextGroup;
+
+	// Write the number of entries in the queue.
+	cwrite_16 (fh, CountLinks (pQueue));
+
+	for (hGroup = GetHeadLink (pQueue); hGroup; hGroup = hNextGroup)
+	{
+		IP_GROUP *GroupPtr;
+
+		GroupPtr = LockIpGroup (pQueue, hGroup);
+		hNextGroup = _GetSuccLink (GroupPtr);
+
+		cwrite_16 (fh, GroupPtr->race_id); /* unused; for old versions */
+
+		cwrite_16 (fh, 0); /* unused; was which_side */
+		cwrite_8  (fh, 0); /* unused; was captains_name_index */
+		cwrite_8  (fh, 0); /* padding; for savegame compat */
+		cwrite_16 (fh, GroupPtr->group_counter);
+		cwrite_8  (fh, GroupPtr->race_id);
+		assert (GroupPtr->sys_loc < 0x10 && GroupPtr->task < 0x10);
+		cwrite_8  (fh, MAKE_BYTE (GroupPtr->sys_loc, GroupPtr->task));
+				/* was var2 */
+		cwrite_8  (fh, GroupPtr->in_system); /* was crew_level */
+		cwrite_8  (fh, 0); /* unused; was max_crew */
+		assert (GroupPtr->dest_loc < 0x10 && GroupPtr->orbit_pos < 0x10);
+		cwrite_8  (fh, MAKE_BYTE (GroupPtr->dest_loc, GroupPtr->orbit_pos));
+				/* was energy_level */
+		cwrite_8  (fh, GroupPtr->group_id); /* was max_energy */
+		cwrite_16 (fh, GroupPtr->loc.x);
+		cwrite_16 (fh, GroupPtr->loc.y);
+
+		UnlockIpGroup (pQueue, hGroup);
+	}
+}
+
+static void
+SaveEncounter (const ENCOUNTER *EncounterPtr, DECODE_REF fh)
 {
 	COUNT i;
 
@@ -192,39 +264,40 @@ SaveEncounter (ENCOUNTERPTR EncounterPtr
 	cwrite_16  (fh, EncounterPtr->origin.x);
 	cwrite_16  (fh, EncounterPtr->origin.y);
 	cwrite_16  (fh, EncounterPtr->radius);
-	// EXTENDED_STAR_DESC fields
+	// STAR_DESC fields
 	cwrite_16  (fh, EncounterPtr->SD.star_pt.x);
 	cwrite_16  (fh, EncounterPtr->SD.star_pt.y);
 	cwrite_8   (fh, EncounterPtr->SD.Type);
 	cwrite_8   (fh, EncounterPtr->SD.Index);
 	cwrite_16  (fh, 0); /* alignment padding */
 
-	// Save each entry in the SHIP_INFO array:
+	// Save each entry in the BRIEF_SHIP_INFO array
 	for (i = 0; i < MAX_HYPER_SHIPS; i++)
 	{
-		SHIP_INFOPTR ShipInfo = &EncounterPtr->SD.ShipList[i];
+		const BRIEF_SHIP_INFO *ShipInfo = &EncounterPtr->ShipList[i];
 
-		cwrite_16  (fh, ShipInfo->ship_flags);
-		cwrite_8   (fh, ShipInfo->var1);
-		cwrite_8   (fh, ShipInfo->var2);
+		cwrite_16  (fh, 0); /* useless; was SHIP_INFO.ship_flags */
+		cwrite_8   (fh, ShipInfo->race_id);
+		cwrite_8   (fh, 0); /* useless; was SHIP_INFO.var2 */
+		// XXX: writing crew as BYTE to maintain savegame compatibility
 		cwrite_8   (fh, ShipInfo->crew_level);
 		cwrite_8   (fh, ShipInfo->max_crew);
-		cwrite_8   (fh, ShipInfo->energy_level);
+		cwrite_8   (fh, 0); /* useless; was SHIP_INFO.energy_level */
 		cwrite_8   (fh, ShipInfo->max_energy);
-		cwrite_16  (fh, ShipInfo->loc.x);
-		cwrite_16  (fh, ShipInfo->loc.y);
+		cwrite_16  (fh, 0); /* useless; was SHIP_INFO.loc.x */
+		cwrite_16  (fh, 0); /* useless; was SHIP_INFO.loc.y */
 		cwrite_32  (fh, 0); /* useless val; STRING race_strings */
 		cwrite_ptr (fh); /* useless ptr; FRAME icons */
 		cwrite_ptr (fh); /* useless ptr; FRAME melee_icon */
 	}
 	
-	// Save the stuff after the SHIP_INFO array:
+	// Save the stuff after the BRIEF_SHIP_INFO array
 	cwrite_32  (fh, EncounterPtr->log_x);
 	cwrite_32  (fh, EncounterPtr->log_y);
 }
 
 static void
-SaveEvent (EVENTPTR EventPtr, DECODE_REF fh)
+SaveEvent (const EVENT *EventPtr, DECODE_REF fh)
 {
 	cwrite_ptr (fh); /* useless ptr; HEVENT pred */
 	cwrite_ptr (fh); /* useless ptr; HEVENT succ */
@@ -237,7 +310,7 @@ SaveEvent (EVENTPTR EventPtr, DECODE_REF
 }
 
 static void
-DummySaveQueue (PQUEUE QueuePtr, DECODE_REF fh)
+DummySaveQueue (const QUEUE *QueuePtr, DECODE_REF fh)
 {
 	/* QUEUE should never actually be saved since it contains
 	 * purely internal representation and the lists
@@ -247,7 +320,7 @@ DummySaveQueue (PQUEUE QueuePtr, DECODE_
 	/* QUEUE format with QUEUE_TABLE defined -- UQM default */
 	cwrite_ptr (fh); /* HLINK head */
 	cwrite_ptr (fh); /* HLINK tail */
-	cwrite_ptr (fh); /* PBYTE pq_tab */
+	cwrite_ptr (fh); /* BYTE* pq_tab */
 	cwrite_ptr (fh); /* HLINK free_list */
 	cwrite_16  (fh, 0); /* MEM_HANDLE hq_tab */
 	cwrite_16  (fh, 0); /* COUNT object_size */
@@ -258,7 +331,7 @@ DummySaveQueue (PQUEUE QueuePtr, DECODE_
 }
 
 static void
-SaveClockState (PCLOCK_STATE ClockPtr, DECODE_REF fh)
+SaveClockState (const CLOCK_STATE *ClockPtr, DECODE_REF fh)
 {
 	cwrite_8   (fh, ClockPtr->day_index);
 	cwrite_8   (fh, ClockPtr->month_index);
@@ -273,7 +346,7 @@ SaveClockState (PCLOCK_STATE ClockPtr, D
 }
 
 static void
-SaveGameState (PGAME_STATE GSPtr, DECODE_REF fh)
+SaveGameState (const GAME_STATE *GSPtr, DECODE_REF fh)
 {
 	cwrite_8   (fh, 0); /* obsolete; BYTE cur_state */
 	cwrite_8   (fh, GSPtr->glob_flags);
@@ -281,7 +354,7 @@ SaveGameState (PGAME_STATE GSPtr, DECODE
 	cwrite_8   (fh, GSPtr->FuelCost);
 	cwrite_a8  (fh, GSPtr->ModuleCost, NUM_MODULES);
 	cwrite_a8  (fh, GSPtr->ElementWorth, NUM_ELEMENT_CATEGORIES);
-	cwrite_ptr (fh); /* useless ptr; PPRIMITIVE DisplayArray */
+	cwrite_ptr (fh); /* useless ptr; PRIMITIVE *DisplayArray */
 	cwrite_16  (fh, GSPtr->CurrentActivity);
 	
 	cwrite_16  (fh, 0); /* CLOCK_STATE alignment padding */
@@ -311,6 +384,7 @@ SaveGameState (PGAME_STATE GSPtr, DECODE
 	
 	DummySaveQueue (&GSPtr->avail_race_q, fh);
 	DummySaveQueue (&GSPtr->npc_built_ship_q, fh);
+	// Not saving ip_group_q, was not there originally
 	DummySaveQueue (&GSPtr->encounter_q, fh);
 	DummySaveQueue (&GSPtr->built_ship_q, fh);
 
@@ -321,7 +395,7 @@ SaveGameState (PGAME_STATE GSPtr, DECODE
 }
 
 static BOOLEAN
-SaveSisState (PSIS_STATE SSPtr, PVOID fp)
+SaveSisState (const SIS_STATE *SSPtr, void *fp)
 {
 	if (
 			write_32  (fp, SSPtr->log_x) != 1 ||
@@ -349,7 +423,7 @@ SaveSisState (PSIS_STATE SSPtr, PVOID fp
 }
 
 static BOOLEAN
-SaveSummary (SUMMARY_DESC *SummPtr, PVOID fp)
+SaveSummary (const SUMMARY_DESC *SummPtr, void *fp)
 {
 	if (!SaveSisState (&SummPtr->SS, fp))
 		return FALSE;
@@ -375,7 +449,7 @@ SaveSummary (SUMMARY_DESC *SummPtr, PVOI
 }
 
 static void
-SaveStarDesc (STAR_DESCPTR SDPtr, DECODE_REF fh)
+SaveStarDesc (const STAR_DESC *SDPtr, DECODE_REF fh)
 {
 	cwrite_16 (fh, SDPtr->star_pt.x);
 	cwrite_16 (fh, SDPtr->star_pt.y);
@@ -408,19 +482,17 @@ PrepareSummary (SUMMARY_DESC *SummPtr)
 	SummPtr->MCreditHi = GET_GAME_STATE (MELNORME_CREDIT1);
 
 	{
-		HSTARSHIP hStarShip, hNextShip;
+		HSHIPFRAG hStarShip, hNextShip;
 
 		for (hStarShip = GetHeadLink (&GLOBAL (built_ship_q)), SummPtr->NumShips = 0;
 				hStarShip; hStarShip = hNextShip, ++SummPtr->NumShips)
 		{
-			SHIP_FRAGMENTPTR StarShipPtr;
+			SHIP_FRAGMENT *StarShipPtr;
 
-			StarShipPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-					&GLOBAL (built_ship_q), hStarShip
-					);
+			StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 			hNextShip = _GetSuccLink (StarShipPtr);
-			SummPtr->ShipList[SummPtr->NumShips] = GET_RACE_ID (StarShipPtr);
-			UnlockStarShip (&GLOBAL (built_ship_q), hStarShip);
+			SummPtr->ShipList[SummPtr->NumShips] = StarShipPtr->race_id;
+			UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 		}
 	}
 
@@ -438,7 +510,7 @@ PrepareSummary (SUMMARY_DESC *SummPtr)
 }
 
 static void
-SaveProblemMessage (PSTAMP MsgStamp)
+SaveProblemMessage (STAMP *MsgStamp)
 {
 #define MAX_MSG_LINES 1
 	RECT r;
@@ -460,7 +532,7 @@ SaveProblemMessage (PSTAMP MsgStamp)
 		if (*t.pStr == '\0')
 			break;
 		t.CharCount = (COUNT)~0;
-		TextRect (&t, &tr, NULL_PTR);
+		TextRect (&t, &tr, NULL);
 		if (i == 0)
 			r = tr;
 		else
@@ -546,24 +618,21 @@ BOOLEAN
 SaveGame (COUNT which_game, SUMMARY_DESC *SummPtr)
 {
 	BOOLEAN success, made_room;
-	PVOID out_fp;
-	MEM_HANDLE h;
+	void *out_fp, *h;
 	DECODE_REF fh;
 
 	success = TRUE;
 	made_room = FALSE;
 RetrySave:
-	h = mem_request (10 * 1024);
-	out_fp = mem_lock (h);
-	if (out_fp == 0
-			|| (fh = copen (out_fp, MEMORY_STREAM, STREAM_WRITE)) == 0)
+	h = HMalloc (10 * 1024);
+	if (h == 0
+			|| (fh = copen (h, MEMORY_STREAM, STREAM_WRITE)) == 0)
 	{
 		if (success)
 		{
 			success = FALSE;
 			made_room = TRUE;
-			mem_unlock (h);
-			mem_release (h);
+			HFree (h);
 
 			FreeSC2Data ();
 			log_add (log_Debug, "Insufficient room for save buffers"
@@ -606,9 +675,26 @@ RetrySave:
 		// XXX: Restore: ShipStamp.frame is abused to store DWORD info
 		GLOBAL (ShipStamp.frame) = frame;
 
-		SaveShipQueue (fh, &GLOBAL (avail_race_q));
+		SaveRaceQueue (fh, &GLOBAL (avail_race_q));
+		// START_INTERPLANETARY is only set when saving from Homeworld
+		//   encounter screen. When the game is loaded, GENERATE_ORBITAL will
+		//   create the encounter anew and populate the npc queue.
 		if (!(GLOBAL (CurrentActivity) & START_INTERPLANETARY))
-			SaveShipQueue (fh, &GLOBAL (npc_built_ship_q));
+		{
+			if (GLOBAL (CurrentActivity) & START_ENCOUNTER)
+				SaveShipQueue (fh, &GLOBAL (npc_built_ship_q));
+			else if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY)
+				// XXX: Technically, this queue does not need to be
+				//   saved/loaded at all. IP groups will be reloaded
+				//   from group state files. But the original code did,
+				//   and so will we until we can prove we do not need to.
+				SaveGroupQueue (fh, &GLOBAL (ip_group_q));
+				//SaveEmptyQueue (fh);
+			else
+				// XXX: empty queue write-out is only needed to maintain
+				//   the savegame compatibility
+				SaveEmptyQueue (fh);
+		}
 		SaveShipQueue (fh, &GLOBAL (built_ship_q));
 
 		// Save the number of game events (compressed).
@@ -622,7 +708,7 @@ RetrySave:
 			while (num_links--)
 			{
 				HEVENT hNextEvent;
-				EVENTPTR EventPtr;
+				EVENT *EventPtr;
 
 				LockEvent (hEvent, &EventPtr);
 				hNextEvent = GetSuccEvent (EventPtr);
@@ -645,7 +731,7 @@ RetrySave:
 			while (num_links--)
 			{
 				HENCOUNTER hNextEncounter;
-				ENCOUNTERPTR EncounterPtr;
+				ENCOUNTER *EncounterPtr;
 
 				LockEncounter (hEncounter, &EncounterPtr);
 				hNextEncounter = GetSuccEncounter (EncounterPtr);
@@ -732,11 +818,10 @@ RetrySave:
 
 			success = SaveSummary (SummPtr, out_fp);
 			// Then write the rest of the data.
-			if (success && WriteResFile (mem_lock (h), (COUNT)flen, 1,
+			if (success && WriteResFile (h, (COUNT)flen, 1,
 						out_fp) == 0)
 				success = FALSE;
 
-			mem_unlock (h);
 			if (res_CloseResFile ((uio_Stream *)out_fp) == 0)
 				success = FALSE;
 
@@ -748,8 +833,7 @@ RetrySave:
 			DeleteResFile (saveDir, file);
 	}
 
-	mem_unlock (h);
-	mem_release (h);
+	HFree (h);
 
 	if (made_room)
 		LoadSC2Data ();
diff -ruNp src.orig/sc2code/settings.h src/sc2code/settings.h
--- src.orig/sc2code/settings.h	2017-11-08 16:49:36 -0600
+++ src/sc2code/settings.h	2017-11-08 16:50:03 -0600
@@ -25,8 +25,7 @@ extern void ResumeMusic (void);
 extern void PauseMusic (void);
 extern void ToggleSoundEffect (void);
 
-extern void PlayMusic (MUSIC_REF MusicRef, BOOLEAN Continuous, BYTE
-		Priority);
+extern void PlayMusic (MUSIC_REF MusicRef, BOOLEAN Continuous, BYTE Priority);
 extern void PlaySoundEffect (SOUND S, COUNT Channel, SoundPosition Pos,
 		void *PositionalObject, BYTE Priority);
 
diff -ruNp src.orig/sc2code/setup.c src/sc2code/setup.c
--- src.orig/sc2code/setup.c	2017-11-08 16:49:36 -0600
+++ src/sc2code/setup.c	2017-11-08 16:50:03 -0600
@@ -46,7 +46,7 @@ ACTIVITY LastActivity;
 BYTE PlayerControl[NUM_PLAYERS];
 
 // XXX: These declarations should really go to the file they belong to.
-MEM_HANDLE hResIndex;
+RESOURCE_INDEX hResIndex;
 CONTEXT ScreenContext;
 CONTEXT SpaceContext;
 CONTEXT StatusContext;
@@ -73,12 +73,6 @@ uio_DirHandle *rootDir;
 static void
 InitPlayerInput (void)
 {
-	HumanInput[0] = p1_combat_summary;
-	HumanInput[1] = p2_combat_summary;
-	ComputerInput = computer_intelligence;
-#ifdef NETPLAY
-	NetworkInput = networkBattleInput;
-#endif
 }
 
 void
@@ -96,9 +90,9 @@ LoadKernel (int argc, char *argv[])
 	if (!InitGraphics (argc, argv, MIN_K_REQUIRED))
 		return FALSE;
 	InitSound (argc, argv);
-	InitVideo (TRUE);
+	InitVideoPlayer (TRUE);
 
-	ScreenContext = CaptureContext (CreateContext ());
+	ScreenContext = CreateContext ();
 	if (ScreenContext == NULL)
 		return FALSE;
 
@@ -111,10 +105,33 @@ LoadKernel (int argc, char *argv[])
 	SetContextFGFrame (Screen);
 	SetFrameHot (Screen, MAKE_HOT_SPOT (0, 0));
 
-	hResIndex = InitResourceSystem ("starcon.lst", RES_INDEX, NULL);
+	hResIndex = InitResourceSystem ();
 	if (hResIndex == 0)
 		return FALSE;
-	INIT_INSTANCES ();
+	
+	/* Load base content. */
+	loadIndices (contentDir);
+
+	/* Load addons demanded by the current configuration. */
+	if (opt3doMusic)
+	{
+		loadAddon ("3domusic");
+	}
+
+	loadAddon ("3dovoice"); /* Always try to use voice data */
+
+	if (optPrecursorsMusic)
+	{
+		loadAddon ("remix");
+	}
+
+	if (optWhichIntro == OPT_3DO)
+	{
+		loadAddon ("3dovideo");
+	}
+
+	/* Now load the rest of the addons, in order. */
+	prepareAddons (optAddons);
 
 	{
 		COLORMAP ColorMapTab;
@@ -135,7 +152,7 @@ InitContexts (void)
 {
 	RECT r;
 	
-	StatusContext = CaptureContext (CreateContext ());
+	StatusContext = CreateContext ();
 	if (StatusContext == NULL)
 		return FALSE;
 
@@ -147,15 +164,15 @@ InitContexts (void)
 	r.extent.height = STATUS_HEIGHT;
 	SetContextClipRect (&r);
 	
-	SpaceContext = CaptureContext (CreateContext ());
+	SpaceContext = CreateContext ();
 	if (SpaceContext == NULL)
 		return FALSE;
 		
-	OffScreenContext = CaptureContext (CreateContext ());
+	OffScreenContext = CreateContext ();
 	if (OffScreenContext == NULL)
 		return FALSE;
 
-	if (!InitQueue (&disp_q, 100, sizeof (ELEMENT)))
+	if (!InitQueue (&disp_q, MAX_DISPLAY_ELEMENTS, sizeof (ELEMENT)))
 		return FALSE;
 
 	return TRUE;
@@ -169,11 +186,11 @@ InitKernel (void)
 	for (counter = 0; counter < NUM_PLAYERS; ++counter)
 		InitQueue (&race_q[counter], MAX_SHIPS_PER_SIDE, sizeof (STARSHIP));
 
-	StarConFont = CaptureFont (LoadFont (STARCON_FONT));
+	StarConFont = LoadFont (STARCON_FONT);
 	if (StarConFont == NULL)
 		return FALSE;
 
-	TinyFont = CaptureFont (LoadFont (TINY_FONT));
+	TinyFont = LoadFont (TINY_FONT);
 	if (TinyFont == NULL)
 		return FALSE;
 
@@ -189,7 +206,7 @@ InitKernel (void)
 	if (GameStrings == 0)
 		return FALSE;
 
-	MicroFont = CaptureFont (LoadFont (MICRO_FONT));
+	MicroFont = LoadFont (MICRO_FONT);
 	if (MicroFont == NULL)
 		return FALSE;
 
@@ -214,34 +231,64 @@ InitGameKernel (void)
 }
 
 void
-SetPlayerInput (void)
+SetPlayerInput (COUNT playerI)
 {
-	COUNT which_player;
+	assert (PlayerInput[playerI] == NULL);
 
-	for (which_player = 0; which_player < NUM_PLAYERS; ++which_player)
-	{
-		if (PlayerControl[which_player] & COMPUTER_CONTROL)
-			PlayerInput[which_player] = ComputerInput;
-		else if (LOBYTE (GLOBAL (CurrentActivity)) != SUPER_MELEE)
-		{
-			// Full game.
-			if (which_player == 0)
-				PlayerInput[which_player] = HumanInput[0];
-			else
-			{
-				PlayerInput[which_player] = ComputerInput;
-				PlayerControl[which_player] = COMPUTER_CONTROL | AWESOME_RATING;
-			}
-		}
+	switch (PlayerControl[playerI] & CONTROL_MASK) {
+		case HUMAN_CONTROL:
+			PlayerInput[playerI] =
+					(InputContext *) HumanInputContext_new (playerI);
+			break;
+		case COMPUTER_CONTROL:
+		case CYBORG_CONTROL:
+			// COMPUTER_CONTROL is used in SuperMelee; the computer choses
+			// the ships and fights the battles.
+			// CYBORG_CONTROL is used in the full game; the computer only
+			// fights the battles. XXX: This will need to be handled
+			// separately in the future if we want to remove the special
+			// cases for ship selection with CYBORG_CONTROL from the
+			// computer handlers.
+			PlayerInput[playerI] =
+					(InputContext *) ComputerInputContext_new (playerI);
+			break;
 #ifdef NETPLAY
-		else if (PlayerControl[which_player] & NETWORK_CONTROL)
-			PlayerInput[which_player] = NetworkInput;
+		case NETWORK_CONTROL:
+			PlayerInput[playerI] =
+					(InputContext *) NetworkInputContext_new (playerI);
+			break;
 #endif
-		else
-			PlayerInput[which_player] = HumanInput[which_player];
+		default:
+			fprintf (stderr, "Invalid control method in SetPlayerInput().\n");
+			explode ();  /* Does not return */
 	}
 }
 
+void
+SetPlayerInputAll (void)
+{
+	COUNT playerI;
+	for (playerI = 0; playerI < NUM_PLAYERS; playerI++)
+		SetPlayerInput (playerI);
+}
+
+void
+ClearPlayerInput (COUNT playerI)
+{
+	assert (PlayerInput[playerI] != NULL);
+
+	PlayerInput[playerI]->handlers->deleteContext (PlayerInput[playerI]);
+	PlayerInput[playerI] = NULL;
+}
+
+void
+ClearPlayerInputAll (void)
+{
+	COUNT playerI;
+	for (playerI = 0; playerI < NUM_PLAYERS; playerI++)
+		ClearPlayerInput (playerI);
+}
+
 int
 initIO (void)
 {
diff -ruNp src.orig/sc2code/setup.h src/sc2code/setup.h
--- src.orig/sc2code/setup.h	2017-11-08 16:49:36 -0600
+++ src/sc2code/setup.h	2017-11-08 16:50:03 -0600
@@ -19,12 +19,12 @@
 
 #include "displist.h"
 #include "globdata.h"
+#include "libs/reslib.h"
 #include "libs/sndlib.h"
 #include "libs/gfxlib.h"
 #include "libs/threadlib.h"
 
-
-extern MEM_HANDLE hResIndex;
+extern RESOURCE_INDEX hResIndex;
 
 extern FRAME Screen;
 extern FRAME ActivityFrame;
@@ -49,20 +49,25 @@ extern Mutex GraphicsLock;
 extern CondVar RenderingCond;
 
 extern QUEUE race_q[];
+		/* Array of lists of ships involved in a battle, one queue per side;
+		 * queue element is STARSHIP */
 
 extern ACTIVITY LastActivity;
 
 extern BYTE PlayerControl[];
 extern SIZE cur_player;
 
-extern BOOLEAN InitContexts (void);
-extern void UninitPlayerInput (void);
-extern BOOLEAN InitGameKernel (void);
-
-extern int initIO (void);
-extern void uninitIO (void);
-
-extern void SetPlayerInput (void);
+BOOLEAN InitContexts (void);
+void UninitPlayerInput (void);
+BOOLEAN InitGameKernel (void);
+
+int initIO (void);
+void uninitIO (void);
+
+void SetPlayerInput (COUNT playerI);
+void SetPlayerInputAll (void);
+void ClearPlayerInput (COUNT playerI);
+void ClearPlayerInputAll (void);
 
 
 #endif  /* _SETUP_H */
diff -ruNp src.orig/sc2code/setupmenu.c src/sc2code/setupmenu.c
--- src.orig/sc2code/setupmenu.c	2017-11-08 16:49:36 -0600
+++ src/sc2code/setupmenu.c	2017-11-08 16:50:03 -0600
@@ -29,6 +29,7 @@
 #include "libs/strlib.h"
 #include "libs/reslib.h"
 #include "libs/inplib.h"
+#include "libs/vidlib.h"
 #include "libs/sound/sound.h"
 #include "libs/resource/stringbank.h"
 #include "libs/log.h"
@@ -45,9 +46,7 @@ typedef struct setup_menu_state {
 	DWORD NextTime;
 } SETUP_MENU_STATE;
 
-typedef SETUP_MENU_STATE *PSETUP_MENU_STATE;
-
-static BOOLEAN DoSetupMenu (PSETUP_MENU_STATE pInputState);
+static BOOLEAN DoSetupMenu (SETUP_MENU_STATE *pInputState);
 static BOOLEAN done;
 static WIDGET *current, *next;
 
@@ -72,8 +71,8 @@ static void clear_control (WIDGET_CONTRO
 #endif
 
 #define MENU_COUNT          8
-#define CHOICE_COUNT       21
-#define SLIDER_COUNT        3
+#define CHOICE_COUNT       22
+#define SLIDER_COUNT        4
 #define BUTTON_COUNT       10
 #define LABEL_COUNT         4
 #define TEXTENTRY_COUNT     1
@@ -95,7 +94,7 @@ typedef int (*HANDLER)(WIDGET *, int);
 static int choice_widths[CHOICE_COUNT] = {
 	3, 2, 3, 3, 2, 2, 2, 2, 2, 2, 
 	2, 2, 3, 2, 2, 3, 3, 2,	3, 3, 
-	3 };
+	3, 2 };
 
 static HANDLER button_handlers[BUTTON_COUNT] = {
 	quit_main_menu, quit_sub_menu, do_graphics, do_engine,
@@ -103,7 +102,7 @@ static HANDLER button_handlers[BUTTON_CO
 	do_keyconfig };
 
 static int menu_sizes[MENU_COUNT] = {
-	7, 5, 6, 9, 2, 5,
+	7, 6, 7, 9, 2, 5,
 #ifdef HAVE_OPENGL
 	5,
 #else
@@ -128,6 +127,7 @@ static WIDGET *main_widgets[] = {
 static WIDGET *graphics_widgets[] = {
 	(WIDGET *)(&choices[0]),
 	(WIDGET *)(&choices[10]),
+	(WIDGET *)(&sliders[3]),
 	(WIDGET *)(&choices[2]),
 	(WIDGET *)(&choices[3]),
 	(WIDGET *)(&buttons[1]) };
@@ -138,6 +138,7 @@ static WIDGET *audio_widgets[] = {
 	(WIDGET *)(&sliders[2]),
 	(WIDGET *)(&choices[14]),
 	(WIDGET *)(&choices[9]),
+	(WIDGET *)(&choices[21]),
 	(WIDGET *)(&buttons[1]) };
 
 static WIDGET *engine_widgets[] = {
@@ -371,7 +372,7 @@ SetDefaults (void)
 	choices[6].selected = opts.cscan;
 	choices[7].selected = opts.scroll;
 	choices[8].selected = opts.subtitles;
-	choices[9].selected = opts.music;
+	choices[9].selected = opts.music3do;
 	choices[10].selected = opts.fullscreen;
 	choices[11].selected = opts.intro;
 	choices[12].selected = opts.fps;
@@ -383,10 +384,12 @@ SetDefaults (void)
 	choices[18].selected = opts.player1;
 	choices[19].selected = opts.player2;
 	choices[20].selected = 0;
+	choices[21].selected = opts.musicremix;
 
 	sliders[0].value = opts.musicvol;
 	sliders[1].value = opts.sfxvol;
 	sliders[2].value = opts.speechvol;
+	sliders[3].value = opts.gamma;
 }
 
 static void
@@ -402,7 +405,7 @@ PropagateResults (void)
 	opts.cscan = choices[6].selected;
 	opts.scroll = choices[7].selected;
 	opts.subtitles = choices[8].selected;
-	opts.music = choices[9].selected;
+	opts.music3do = choices[9].selected;
 	opts.fullscreen = choices[10].selected;
 	opts.intro = choices[11].selected;
 	opts.fps = choices[12].selected;
@@ -413,15 +416,17 @@ PropagateResults (void)
 	opts.shield = choices[17].selected;
 	opts.player1 = choices[18].selected;
 	opts.player2 = choices[19].selected;
+	opts.musicremix = choices[21].selected;
 
 	opts.musicvol = sliders[0].value;
 	opts.sfxvol = sliders[1].value;
 	opts.speechvol = sliders[2].value;
+	opts.gamma = sliders[3].value;
 	SetGlobalOptions (&opts);
 }
 
 static BOOLEAN
-DoSetupMenu (PSETUP_MENU_STATE pInputState)
+DoSetupMenu (SETUP_MENU_STATE *pInputState)
 {
 	if (!pInputState->initialized) 
 	{
@@ -495,7 +500,7 @@ redraw_menu (void)
 }
 
 static BOOLEAN
-OnTextEntryChange (PTEXTENTRY_STATE pTES)
+OnTextEntryChange (TEXTENTRY_STATE *pTES)
 {
 	WIDGET_TEXTENTRY *widget = (WIDGET_TEXTENTRY *) pTES->CbParam;
 
@@ -513,7 +518,7 @@ OnTextEntryChange (PTEXTENTRY_STATE pTES
 }
 
 static BOOLEAN
-OnTextEntryFrame (PTEXTENTRY_STATE pTES)
+OnTextEntryFrame (TEXTENTRY_STATE *pTES)
 {
 	WIDGET_TEXTENTRY *widget = (WIDGET_TEXTENTRY *) pTES->CbParam;
 
@@ -986,7 +991,7 @@ clean_up_widgets (void)
 	{
 		if (labels[i].lines)
 		{
-			HFree (labels[i].lines);
+			HFree ((void *)labels[i].lines);
 		}
 	}
 
@@ -1029,7 +1034,7 @@ SetupMenu (void)
 	}
 	done = FALSE;
 
-	DoInput ((PVOID)&s, TRUE);
+	DoInput (&s, TRUE);
 	GLOBAL (CurrentActivity) &= ~CHECK_ABORT;
 	PropagateResults ();
 	if (SetupTab)
@@ -1078,11 +1083,12 @@ GetGlobalOptions (GLOBALOPTS *opts)
 	opts->shield = (optWhichShield == OPT_3DO) ? OPTVAL_3DO : OPTVAL_PC;
 	opts->fps = (GfxFlags & TFB_GFXFLAGS_SHOWFPS) ? 
 			OPTVAL_ENABLED : OPTVAL_DISABLED;
-	opts->meleezoom = (optMeleeScale == TFB_SCALE_TRILINEAR) ? 
-			OPTVAL_3DO : OPTVAL_PC;
+	opts->meleezoom = (optMeleeScale == TFB_SCALE_STEP) ? 
+			OPTVAL_PC : OPTVAL_3DO;
 	opts->stereo = optStereoSFX ? OPTVAL_ENABLED : OPTVAL_DISABLED;
 	/* These values are read in, but won't change during a run. */
-	opts->music = (optWhichMusic == OPT_3DO) ? OPTVAL_3DO : OPTVAL_PC;
+	opts->music3do = opt3doMusic ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->musicremix = optPrecursorsMusic ? OPTVAL_ENABLED : OPTVAL_DISABLED;
 	switch (snddriver) {
 	case audio_DRIVER_OPENAL:
 		opts->adriver = OPTVAL_OPENAL;
@@ -1185,12 +1191,13 @@ GetGlobalOptions (GLOBALOPTS *opts)
 		}
 	}
 
-	opts->player1 = PlayerOne;
-	opts->player2 = PlayerTwo;
+	opts->player1 = PlayerControls[0];
+	opts->player2 = PlayerControls[1];
 
 	opts->musicvol = (((int)(musicVolumeScale * 100.0f) + 2) / 5) * 5;
 	opts->sfxvol = (((int)(sfxVolumeScale * 100.0f) + 2) / 5) * 5;
 	opts->speechvol = (((int)(speechVolumeScale * 100.0f) + 2) / 5) * 5;
+	opts->gamma = (((int)(gammaCorrection * 50.0f) + 2) / 5) * 5;
 	
 }
 
@@ -1289,8 +1296,10 @@ SetGlobalOptions (GLOBALOPTS *opts)
 	    (NewGfxFlags != GfxFlags)) 
 	{
 		FlushGraphics ();
+		UninitVideoPlayer ();
 		TFB_DrawScreen_ReinitVideo (NewDriver, NewGfxFlags, NewWidth, NewHeight);
 		FlushGraphics ();
+		InitVideoPlayer (TRUE);
 	}
 	optSubtitles = (opts->subtitles == OPTVAL_ENABLED) ? TRUE : FALSE;
 	// optWhichMusic = (opts->music == OPTVAL_3DO) ? OPT_3DO : OPT_PC;
@@ -1301,8 +1310,8 @@ SetGlobalOptions (GLOBALOPTS *opts)
 	optWhichShield = (opts->shield == OPTVAL_3DO) ? OPT_3DO : OPT_PC;
 	optMeleeScale = (opts->meleezoom == OPTVAL_3DO) ? TFB_SCALE_TRILINEAR : TFB_SCALE_STEP;
 	optWhichIntro = (opts->intro == OPTVAL_3DO) ? OPT_3DO : OPT_PC;
-	PlayerOne = opts->player1;
-	PlayerTwo = opts->player2;
+	PlayerControls[0] = opts->player1;
+	PlayerControls[1] = opts->player2;
 
 	res_PutBoolean ("config.subtitles", opts->subtitles == OPTVAL_ENABLED);
 	res_PutBoolean ("config.textmenu", opts->menu == OPTVAL_PC);
@@ -1310,7 +1319,8 @@ SetGlobalOptions (GLOBALOPTS *opts)
 	res_PutBoolean ("config.iconicscan", opts->cscan == OPTVAL_3DO);
 	res_PutBoolean ("config.smoothscroll", opts->scroll == OPTVAL_3DO);
 
-	res_PutBoolean ("config.3domusic", opts->music == OPTVAL_3DO);
+	res_PutBoolean ("config.3domusic", opts->music3do == OPTVAL_ENABLED);
+	res_PutBoolean ("config.remixmusic", opts->musicremix == OPTVAL_ENABLED);
 	res_PutBoolean ("config.3domovies", opts->intro == OPTVAL_3DO);
 	res_PutBoolean ("config.showfps", opts->fps == OPTVAL_ENABLED);
 	res_PutBoolean ("config.smoothmelee", opts->meleezoom == OPTVAL_3DO);
@@ -1351,20 +1361,29 @@ SetGlobalOptions (GLOBALOPTS *opts)
 	res_PutInteger ("config.musicvol", opts->musicvol);
 	res_PutInteger ("config.sfxvol", opts->sfxvol);
 	res_PutInteger ("config.speechvol", opts->speechvol);
+	res_PutInteger ("config.gamma", opts->gamma);
 	musicVolumeScale = opts->musicvol / 100.0f;
 	sfxVolumeScale = opts->sfxvol / 100.0f;
 	speechVolumeScale = opts->speechvol / 100.0f;
+	gammaCorrection = opts->gamma / 50.0f;
 	// update actual volumes
 	SetMusicVolume (musicVolume);
 	SetSpeechVolume (speechVolumeScale);
 
-	res_PutString ("config.keys.1.name", input_templates[0].name);
-	res_PutString ("config.keys.2.name", input_templates[1].name);
-	res_PutString ("config.keys.3.name", input_templates[2].name);
-	res_PutString ("config.keys.4.name", input_templates[3].name);
-	res_PutString ("config.keys.5.name", input_templates[4].name);
-	res_PutString ("config.keys.6.name", input_templates[5].name);
+	// A gamma of 0.0 turns the screen completely black (on my
+	// hardware, at least) which is unfortunate.  Place a lower
+	// limit on the value that is barely bright enough to see
+	// anything
+	log_add (log_Debug, "DEBUG: setting gamma to %1.4f", gammaCorrection);
+	TFB_SetGamma (gammaCorrection ? gammaCorrection : 0.05f);
+
+	res_PutString ("keys.1.name", input_templates[0].name);
+	res_PutString ("keys.2.name", input_templates[1].name);
+	res_PutString ("keys.3.name", input_templates[2].name);
+	res_PutString ("keys.4.name", input_templates[3].name);
+	res_PutString ("keys.5.name", input_templates[4].name);
+	res_PutString ("keys.6.name", input_templates[5].name);
 
 	res_SaveFilename (configDir, "uqm.cfg", "config.");
-	SaveKeyConfiguration (configDir, "keys.cfg");
+	SaveKeyConfiguration (configDir, "flight.cfg");
 }
diff -ruNp src.orig/sc2code/setupmenu.h src/sc2code/setupmenu.h
--- src.orig/sc2code/setupmenu.h	2017-11-08 16:49:36 -0600
+++ src/sc2code/setupmenu.h	2017-11-08 16:50:03 -0600
@@ -74,10 +74,10 @@ typedef struct globalopts_struct {
 	OPT_DRIVERTYPE driver;
 	OPT_ADRIVERTYPE adriver;
 	OPT_AQUALITYTYPE aquality;
-	OPT_ENABLABLE fullscreen, subtitles, scanlines, fps, stereo;
-	OPT_CONSOLETYPE music, menu, text, cscan, scroll, intro, meleezoom, shield;
+	OPT_ENABLABLE fullscreen, subtitles, scanlines, fps, stereo, music3do, musicremix;
+	OPT_CONSOLETYPE menu, text, cscan, scroll, intro, meleezoom, shield;
 	CONTROL_TEMPLATE player1, player2;
-	int speechvol, musicvol, sfxvol;
+	int speechvol, musicvol, sfxvol, gamma;
 } GLOBALOPTS;
 
 void SetupMenu (void);
diff -ruNp src.orig/sc2code/ship.c src/sc2code/ship.c
--- src.orig/sc2code/ship.c	2017-11-08 16:49:36 -0600
+++ src/sc2code/ship.c	2017-11-08 16:50:03 -0600
@@ -21,6 +21,7 @@
 #include "colors.h"
 #include "globdata.h"
 #include "intel.h"
+#include "pickmele.h"
 #include "races.h"
 #include "setup.h"
 #include "sounds.h"
@@ -28,7 +29,7 @@
 
 
 void
-animation_preprocess (PELEMENT ElementPtr)
+animation_preprocess (ELEMENT *ElementPtr)
 {
 	if (ElementPtr->turn_wait > 0)
 		--ElementPtr->turn_wait;
@@ -43,16 +44,16 @@ animation_preprocess (PELEMENT ElementPt
 }
 
 
-UWORD
-inertial_thrust (ELEMENTPTR ElementPtr)
+STATUS_FLAGS
+inertial_thrust (ELEMENT *ElementPtr)
 {
 #define MAX_ALLOWED_SPEED     WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (18))
 #define MAX_ALLOWED_SPEED_SQR ((DWORD)MAX_ALLOWED_SPEED * MAX_ALLOWED_SPEED)
 
 	COUNT CurrentAngle, TravelAngle;
 	COUNT max_thrust, thrust_increment;
-	VELOCITYPTR VelocityPtr;
-	STARSHIPPTR StarShipPtr;
+	VELOCITY_DESC *VelocityPtr;
+	STARSHIP *StarShipPtr;
 
 	VelocityPtr = &ElementPtr->velocity;
 
@@ -138,11 +139,11 @@ inertial_thrust (ELEMENTPTR ElementPtr)
 }
 
 void
-ship_preprocess (PELEMENT ElementPtr)
+ship_preprocess (ELEMENT *ElementPtr)
 {
-	ELEMENT_FLAGS cur_status_flags;
-	STARSHIPPTR StarShipPtr;
-	RACE_DESCPTR RDPtr;
+	STATUS_FLAGS cur_status_flags;
+	STARSHIP *StarShipPtr;
+	RACE_DESC *RDPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	RDPtr = StarShipPtr->RaceDescPtr;
@@ -175,7 +176,8 @@ ship_preprocess (PELEMENT ElementPtr)
 		{
 			CONTEXT OldContext;
 
-			InitShipStatus (StarShipPtr, NULL_PTR);
+			InitShipStatus (&RDPtr->ship_info,
+					StarShipPtr->captains_name_index, NULL);
 			OldContext = SetContext (StatusContext);
 			DrawCaptainsWindow (StarShipPtr);
 			SetContext (OldContext);
@@ -184,14 +186,13 @@ ship_preprocess (PELEMENT ElementPtr)
 
 			if (ElementPtr->hTarget == 0)
 			{
-				extern void ship_transition (PELEMENT ElementPtr);
+				extern void ship_transition (ELEMENT *ElementPtr);
 
 				ship_transition (ElementPtr);
 			}
 			else
 			{
-				extern BOOLEAN OpponentAlive (STARSHIPPTR
-						TestStarShipPtr);
+				extern BOOLEAN OpponentAlive (STARSHIP *TestStarShipPtr);
 
 				ElementPtr->hTarget = 0;
 				if (!PLRPlaying ((MUSIC_REF)~0) && OpponentAlive (StarShipPtr))
@@ -222,7 +223,7 @@ ship_preprocess (PELEMENT ElementPtr)
 		--StarShipPtr->energy_counter;
 	else if (RDPtr->ship_info.energy_level < (BYTE)RDPtr->ship_info.max_energy
 			|| (SBYTE)RDPtr->characteristics.energy_regeneration < 0)
-		DeltaEnergy ((ELEMENTPTR)ElementPtr,
+		DeltaEnergy (ElementPtr,
 				(SBYTE)RDPtr->characteristics.energy_regeneration);
 
 	if (RDPtr->preprocess_func)
@@ -253,9 +254,9 @@ ship_preprocess (PELEMENT ElementPtr)
 		--ElementPtr->thrust_wait;
 	else if (cur_status_flags & THRUST)
 	{
-		UWORD thrust_status;
+		STATUS_FLAGS thrust_status;
 
-		thrust_status = inertial_thrust ((ELEMENTPTR)ElementPtr);
+		thrust_status = inertial_thrust (ElementPtr);
 		StarShipPtr->cur_status_flags &=
 				~(SHIP_AT_MAX_SPEED
 				| SHIP_BEYOND_MAX_SPEED
@@ -267,7 +268,7 @@ ship_preprocess (PELEMENT ElementPtr)
 		if (!OBJECT_CLOAKED (ElementPtr)
 				&& LOBYTE (GLOBAL (CurrentActivity)) <= IN_ENCOUNTER)
 		{
-			extern void spawn_ion_trail (PELEMENT ElementPtr);
+			extern void spawn_ion_trail (ELEMENT *ElementPtr);
 
 			spawn_ion_trail (ElementPtr);
 		}
@@ -278,10 +279,10 @@ ship_preprocess (PELEMENT ElementPtr)
 }
 
 void
-ship_postprocess (PELEMENT ElementPtr)
+ship_postprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
-	RACE_DESCPTR RDPtr;
+	STARSHIP *StarShipPtr;
+	RACE_DESC *RDPtr;
 
 	if (ElementPtr->crew_level == 0)
 		return;
@@ -292,7 +293,7 @@ ship_postprocess (PELEMENT ElementPtr)
 	if (StarShipPtr->weapon_counter)
 		--StarShipPtr->weapon_counter;
 	else if ((StarShipPtr->cur_status_flags
-			& WEAPON) && DeltaEnergy ((ELEMENTPTR)ElementPtr,
+			& WEAPON) && DeltaEnergy (ElementPtr,
 			-RDPtr->characteristics.weapon_energy_cost))
 	{
 		COUNT num_weapons;
@@ -303,7 +304,7 @@ ship_postprocess (PELEMENT ElementPtr)
 		if (num_weapons)
 		{
 			HELEMENT *WeaponPtr;
-			STARSHIPPTR StarShipPtr;
+			STARSHIP *StarShipPtr;
 			BOOLEAN played_sfx = FALSE;
 
 			GetElementStarShip (ElementPtr, &StarShipPtr);
@@ -314,7 +315,7 @@ ship_postprocess (PELEMENT ElementPtr)
 				w = *WeaponPtr++;
 				if (w)
 				{
-					ELEMENTPTR EPtr;
+					ELEMENT *EPtr;
 
 					LockElement (w, &EPtr);
 					SetElementStarShip (EPtr, StarShipPtr);
@@ -348,8 +349,8 @@ ship_postprocess (PELEMENT ElementPtr)
 }
 
 void
-collision (PELEMENT ElementPtr0, PPOINT pPt0,
-		PELEMENT ElementPtr1, PPOINT pPt1)
+collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
 	if (!(ElementPtr1->state_flags & FINITE_LIFE))
 	{
@@ -362,7 +363,7 @@ collision (PELEMENT ElementPtr0, PPOINT
 			damage = ElementPtr0->hit_points >> 2;
 			if (damage == 0)
 				damage = 1;
-			do_damage ((ELEMENTPTR)ElementPtr0, damage);
+			do_damage (ElementPtr0, damage);
 
 			damage = TARGET_DAMAGED_FOR_1_PT + (damage >> 1);
 			if (damage > TARGET_DAMAGED_FOR_6_PLUS_PT)
@@ -375,16 +376,17 @@ collision (PELEMENT ElementPtr0, PPOINT
 }
 
 static BOOLEAN
-spawn_ship (STARSHIPPTR StarShipPtr)
+spawn_ship (STARSHIP *StarShipPtr)
 {
 	HELEMENT hShip;
-	RACE_DESCPTR RDPtr;
+	RACE_DESC *RDPtr;
 
-	if (!load_ship (StarShipPtr, TRUE))
-		return (FALSE);
+	RDPtr = load_ship (StarShipPtr->SpeciesID, TRUE);
+	if (!RDPtr)
+		return FALSE;
 
-	RDPtr = StarShipPtr->RaceDescPtr;
-	RDPtr->ship_info.var2 = (BYTE)StarShipPtr->ShipFacing;
+	RDPtr->ship_info.ship_flags |= StarShipPtr->which_side;
+	StarShipPtr->RaceDescPtr = RDPtr;
 
 	StarShipPtr->ship_input_state = 0;
 	StarShipPtr->cur_status_flags = 0;
@@ -393,13 +395,13 @@ spawn_ship (STARSHIPPTR StarShipPtr)
 	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_ENCOUNTER
 			|| LOBYTE (GLOBAL (CurrentActivity)) == IN_LAST_BATTLE)
 	{
-		if (StarShipPtr->special_counter == 0)
+		if (StarShipPtr->crew_level == 0)
 		{
 			// SIS, already handled from sis_ship.c.
 			// RDPtr->ship_info.crew_level = GLOBAL_SIS (CrewEnlisted);
 		}
 		else
-			RDPtr->ship_info.crew_level = StarShipPtr->special_counter;
+			RDPtr->ship_info.crew_level = StarShipPtr->crew_level;
 
 		if (RDPtr->ship_info.crew_level > RDPtr->ship_info.max_crew)
 			RDPtr->ship_info.crew_level = RDPtr->ship_info.max_crew;
@@ -421,7 +423,7 @@ spawn_ship (STARSHIPPTR StarShipPtr)
 	if (StarShipPtr->hShip != 0)
 	{
 		// Construct an ELEMENT for the STARSHIP
-		ELEMENTPTR ShipElementPtr;
+		ELEMENT *ShipElementPtr;
 
 		LockElement (hShip, &ShipElementPtr);
 
@@ -429,7 +431,8 @@ spawn_ship (STARSHIPPTR StarShipPtr)
 		ShipElementPtr->mass_points = RDPtr->characteristics.ship_mass;
 		ShipElementPtr->state_flags = APPEARING | PLAYER_SHIP | IGNORE_SIMILAR
 				| (RDPtr->ship_info.ship_flags & (GOOD_GUY | BAD_GUY));
-		ShipElementPtr->turn_wait = ShipElementPtr->thrust_wait = 0;
+		ShipElementPtr->turn_wait = 0;
+		ShipElementPtr->thrust_wait = 0;
 		ShipElementPtr->life_span = NORMAL_LIFE;
 
 		SetPrimType (&DisplayArray[ShipElementPtr->PrimIndex], STAMP_PRIM);
@@ -491,7 +494,7 @@ spawn_ship (STARSHIPPTR StarShipPtr)
 }
 
 BOOLEAN
-GetNextStarShip (STARSHIPPTR LastStarShipPtr, COUNT which_side)
+GetNextStarShip (STARSHIP *LastStarShipPtr, COUNT which_side)
 {
 	HSTARSHIP hBattleShip;
 
@@ -502,13 +505,16 @@ GetNextStarShip (STARSHIPPTR LastStarShi
 	hBattleShip = GetEncounterStarShip (LastStarShipPtr, which_side);
 	if (hBattleShip)
 	{
-		STARSHIPPTR StarShipPtr;
+		STARSHIP *StarShipPtr;
 
 		StarShipPtr = LockStarShip (&race_q[which_side], hBattleShip);
 		if (LastStarShipPtr)
 		{
 			if (StarShipPtr == LastStarShipPtr)
+			{
+				// Ship has been recycled (on infinite ship worlds).
 				LastStarShipPtr = 0;
+			}
 			else
 				StarShipPtr->hShip = LastStarShipPtr->hShip;
 		}
@@ -527,3 +533,41 @@ GetNextStarShip (STARSHIPPTR LastStarShi
 	return (hBattleShip != 0);
 }
 
+BOOLEAN
+GetInitialStarShips (void)
+{
+	if (LOBYTE (GLOBAL (CurrentActivity)) == SUPER_MELEE)
+	{
+		HSTARSHIP ships[NUM_PLAYERS];
+		COUNT i;
+		
+		if (!GetInitialMeleeStarShips (ships))
+			return FALSE;
+
+		for (i = 0; i < NUM_PLAYERS; i++)
+		{
+			STARSHIP *StarShipPtr;
+			COUNT playerI = GetPlayerOrder (i);
+
+			StarShipPtr = LockStarShip (&race_q[playerI], ships[playerI]);
+			if (!spawn_ship (StarShipPtr))
+			{
+				UnlockStarShip (&race_q[playerI], ships[playerI]);
+				return FALSE;
+			}
+			UnlockStarShip (&race_q[playerI], ships[playerI]);
+		}
+		return TRUE;
+	}
+	else
+	{
+		COUNT num_ships = NUM_PLAYERS;
+		while (num_ships--)
+		{
+			if (!GetNextStarShip (NULL, num_ships == 1))
+				return FALSE;
+		}
+		return TRUE;
+	}
+}
+
diff -ruNp src.orig/sc2code/shipcont.h src/sc2code/shipcont.h
--- src.orig/sc2code/shipcont.h	2017-11-08 16:49:36 -0600
+++ src/sc2code/shipcont.h	2017-11-08 16:50:03 -0600
@@ -23,9 +23,9 @@
 
 #define FIELD_WIDTH (STATUS_WIDTH - 5)
 
-extern void Cargo (PMENU_STATE pMS);
+extern void Cargo (MENU_STATE *pMS);
 extern BOOLEAN Roster (void);
-extern BOOLEAN Devices (PMENU_STATE pMS);
+extern BOOLEAN Devices (MENU_STATE *pMS);
 
 extern void DrawCargoStrings (BYTE OldElement, BYTE NewElement);
 extern void ShowRemainingCapacity (void);
diff -ruNp src.orig/sc2code/ships/androsyn/androsyn.c src/sc2code/ships/androsyn/androsyn.c
--- src.orig/sc2code/ships/androsyn/androsyn.c	2017-11-08 16:49:36 -0600
+++ src/sc2code/ships/androsyn/androsyn.c	2017-11-08 16:50:03 -0600
@@ -39,18 +39,22 @@
 
 static RACE_DESC androsynth_desc =
 {
-	{
+	{ /* SHIP_INFO */
 		FIRES_FORE | SEEKING_WEAPON,
 		15, /* Super Melee cost */
-		~0, /* Initial sphere of influence radius */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY, MAX_ENERGY,
-		{
+		ANDROSYNTH_RACE_STRINGS,
+		ANDROSYNTH_ICON_MASK_PMAP_ANIM,
+		ANDROSYNTH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		INFINITE_RADIUS, /* Initial sphere of influence radius */
+				// XXX: Why infinite radius? Bug?
+		{ /* Known location (center of SoI) */
 			MAX_X_UNIVERSE >> 1, MAX_Y_UNIVERSE >> 1,
 		},
-		(STRING)ANDROSYNTH_RACE_STRINGS,
-		(FRAME)ANDROSYNTH_ICON_MASK_PMAP_ANIM,
-		(FRAME)ANDROSYNTH_MICON_MASK_PMAP_ANIM,
 	},
 	{
 		MAX_THRUST,
@@ -67,34 +71,35 @@ static RACE_DESC androsynth_desc =
 	},
 	{
 		{
-			(FRAME)ANDROSYNTH_BIG_MASK_PMAP_ANIM,
-			(FRAME)ANDROSYNTH_MED_MASK_PMAP_ANIM,
-			(FRAME)ANDROSYNTH_SML_MASK_PMAP_ANIM,
+			ANDROSYNTH_BIG_MASK_PMAP_ANIM,
+			ANDROSYNTH_MED_MASK_PMAP_ANIM,
+			ANDROSYNTH_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)BUBBLE_BIG_MASK_PMAP_ANIM,
-			(FRAME)BUBBLE_MED_MASK_PMAP_ANIM,
-			(FRAME)BUBBLE_SML_MASK_PMAP_ANIM,
+			BUBBLE_BIG_MASK_PMAP_ANIM,
+			BUBBLE_MED_MASK_PMAP_ANIM,
+			BUBBLE_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)BLAZER_BIG_MASK_PMAP_ANIM,
-			(FRAME)BLAZER_MED_MASK_PMAP_ANIM,
-			(FRAME)BLAZER_SML_MASK_PMAP_ANIM,
+			BLAZER_BIG_MASK_PMAP_ANIM,
+			BLAZER_MED_MASK_PMAP_ANIM,
+			BLAZER_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)ANDROSYNTH_CAPT_MASK_PMAP_ANIM,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			ANDROSYNTH_CAPT_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
 		},
-		(SOUND)ANDROSYNTH_VICTORY_SONG,
-		(SOUND)ANDROSYNTH_SHIP_SOUNDS,
+		ANDROSYNTH_VICTORY_SONG,
+		ANDROSYNTH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
 	},
 	{
 		0,
 		LONG_RANGE_WEAPON >> 2,
-		NULL_PTR,
+		NULL,
 	},
 	(UNINIT_FUNC *) NULL,
 	(PREPROCESS_FUNC *) NULL,
@@ -107,7 +112,8 @@ static RACE_DESC androsynth_desc =
 #define BLAZER_MASS 1
 
 static void
-blazer_collision (PELEMENT ElementPtr0, PPOINT pPt0, PELEMENT ElementPtr1, PPOINT pPt1)
+blazer_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
 #define BLAZER_OFFSET 10
 	BYTE old_offs;
@@ -132,7 +138,7 @@ blazer_collision (PELEMENT ElementPtr0,
 #define MISSILE_SPEED DISPLAY_TO_WORLD (8)
 
 static void
-bubble_preprocess (PELEMENT ElementPtr)
+bubble_preprocess (ELEMENT *ElementPtr)
 {
 	BYTE thrust_wait, turn_wait;
 
@@ -157,8 +163,7 @@ bubble_preprocess (PELEMENT ElementPtr)
 		SIZE delta_facing;
 
 		facing = NORMALIZE_FACING (ANGLE_TO_FACING (
-				GetVelocityTravelAngle (&ElementPtr->velocity)
-				));
+				GetVelocityTravelAngle (&ElementPtr->velocity)));
 		if ((delta_facing = TrackShip (ElementPtr, &facing)) == -1)
 			facing = (COUNT)TFB_Random ();
 		else if (delta_facing <= ANGLE_TO_FACING (HALF_CIRCLE))
@@ -179,12 +184,12 @@ bubble_preprocess (PELEMENT ElementPtr)
 #define MISSILE_LIFE 200
 
 static COUNT
-initialize_bubble (PELEMENT ShipPtr, HELEMENT BubbleArray[])
+initialize_bubble (ELEMENT *ShipPtr, HELEMENT BubbleArray[])
 {
 #define ANDROSYNTH_OFFSET 14
 #define MISSILE_OFFSET 3
 #define MISSILE_HITS 3
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
@@ -206,7 +211,7 @@ initialize_bubble (PELEMENT ShipPtr, HEL
 
 	if (BubbleArray[0])
 	{
-		ELEMENTPTR BubblePtr;
+		ELEMENT *BubblePtr;
 
 		LockElement (BubbleArray[0], &BubblePtr);
 		BubblePtr->turn_wait = 0;
@@ -217,10 +222,11 @@ initialize_bubble (PELEMENT ShipPtr, HEL
 }
 
 static void
-androsynth_intelligence (PELEMENT ShipPtr, PEVALUATE_DESC ObjectsOfConcern, COUNT ConcernCounter)
+androsynth_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+		COUNT ConcernCounter)
 {
-	PEVALUATE_DESC lpEvalDesc;
-	STARSHIPPTR StarShipPtr;
+	EVALUATE_DESC *lpEvalDesc;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 
@@ -242,7 +248,7 @@ androsynth_intelligence (PELEMENT ShipPt
 	}
 	else
 	{
-		STARSHIPPTR pEnemyStarShip;
+		STARSHIP *pEnemyStarShip;
 
 		lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
 		if (lpEvalDesc->ObjectPtr)
@@ -316,15 +322,14 @@ androsynth_intelligence (PELEMENT ShipPt
 	}
 }
 
-static void (*ship_collision_func[2]) (PELEMENT ElementPtr0, PPOINT pPt0,
-		PELEMENT ElementPtr1, PPOINT pPt1);
+static CollisionFunc *ship_collision_func[2];
 
 #define BLAZER_TURN_WAIT 1
 
 static void
-androsynth_postprocess (PELEMENT ElementPtr)
+androsynth_postprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 			/* take care of blazer effect */
@@ -369,10 +374,10 @@ androsynth_postprocess (PELEMENT Element
 }
 
 static void
-androsynth_preprocess (PELEMENT ElementPtr)
+androsynth_preprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
-	ELEMENT_FLAGS cur_status_flags;
+	STARSHIP *StarShipPtr;
+	STATUS_FLAGS cur_status_flags;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 
@@ -399,6 +404,9 @@ androsynth_preprocess (PELEMENT ElementP
 	else
 	{
 		cur_status_flags &= ~(THRUST | WEAPON | SPECIAL);
+		/* keep the special "on" for the duration of blazer mode, a la SC1 */
+		StarShipPtr->RaceDescPtr->ship_data.captain_control.special =
+				SetRelFrameIndex (StarShipPtr->RaceDescPtr->ship_data.captain_control.special, 2);
 
 					/* protection against vux */
 		if (StarShipPtr->RaceDescPtr->characteristics.turn_wait > BLAZER_TURN_WAIT)
@@ -411,9 +419,13 @@ androsynth_preprocess (PELEMENT ElementP
 
 		if (StarShipPtr->RaceDescPtr->ship_info.energy_level == 0)
 		{
+			/* turn special off */
+			StarShipPtr->RaceDescPtr->ship_data.captain_control.special =
+					SetRelFrameIndex (StarShipPtr->RaceDescPtr->ship_data.captain_control.special, -2);
 			ZeroVelocityComponents (&ElementPtr->velocity);
 			cur_status_flags &= ~(LEFT | RIGHT
 					| SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED);
+			DrawCaptainsWindow(StarShipPtr);
 
 			StarShipPtr->RaceDescPtr->characteristics.turn_wait =
 					StarShipPtr->RaceDescPtr->characteristics.special_wait;
@@ -455,17 +467,15 @@ androsynth_preprocess (PELEMENT ElementP
 	StarShipPtr->cur_status_flags = cur_status_flags;
 }
 
-RACE_DESCPTR
+RACE_DESC*
 init_androsynth (void)
 {
-	RACE_DESCPTR RaceDescPtr;
+	RACE_DESC *RaceDescPtr;
 
 	androsynth_desc.preprocess_func = androsynth_preprocess;
 	androsynth_desc.postprocess_func = androsynth_postprocess;
 	androsynth_desc.init_weapon_func = initialize_bubble;
-	androsynth_desc.cyborg_control.intelligence_func =
-			(void (*) (PVOID ShipPtr, PVOID ObjectsOfConcern, COUNT
-					ConcernCounter)) androsynth_intelligence;
+	androsynth_desc.cyborg_control.intelligence_func = androsynth_intelligence;
 
 	RaceDescPtr = &androsynth_desc;
 
diff -ruNp src.orig/sc2code/ships/androsyn/icode.h src/sc2code/ships/androsyn/icode.h
--- src.orig/sc2code/ships/androsyn/icode.h	2017-11-08 16:49:36 -0600
+++ src/sc2code/ships/androsyn/icode.h	2017-11-08 16:50:04 -0600
@@ -1,3 +1,5 @@
-#define ANDROSYNTH_CODE 0x00200008L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ANDROSYNTH_CODE "ship.androsynth.code"
diff -ruNp src.orig/sc2code/ships/androsyn/igfxres.h src/sc2code/ships/androsyn/igfxres.h
--- src.orig/sc2code/ships/androsyn/igfxres.h	2017-11-08 16:49:36 -0600
+++ src/sc2code/ships/androsyn/igfxres.h	2017-11-08 16:50:04 -0600
@@ -1,14 +1,16 @@
-#define ANDROSYNTH_ICON_MASK_PMAP_ANIM 0x00200002L
-#define ANDROSYNTH_MICON_MASK_PMAP_ANIM 0x00200102L
-#define ANDROSYNTH_BIG_MASK_PMAP_ANIM 0x00400202L
-#define ANDROSYNTH_MED_MASK_PMAP_ANIM 0x00400302L
-#define ANDROSYNTH_SML_MASK_PMAP_ANIM 0x00400402L
-#define BUBBLE_BIG_MASK_PMAP_ANIM 0x00400502L
-#define BUBBLE_MED_MASK_PMAP_ANIM 0x00400602L
-#define BUBBLE_SML_MASK_PMAP_ANIM 0x00400702L
-#define BLAZER_BIG_MASK_PMAP_ANIM 0x00400802L
-#define BLAZER_MED_MASK_PMAP_ANIM 0x00400902L
-#define BLAZER_SML_MASK_PMAP_ANIM 0x00400a02L
-#define ANDROSYNTH_CAPT_MASK_PMAP_ANIM 0x00400b02L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ANDROSYNTH_BIG_MASK_PMAP_ANIM "ship.androsynth.graphics.androsyn.large"
+#define ANDROSYNTH_CAPT_MASK_PMAP_ANIM "ship.androsynth.graphics.captain"
+#define ANDROSYNTH_ICON_MASK_PMAP_ANIM "ship.androsynth.icons"
+#define ANDROSYNTH_MED_MASK_PMAP_ANIM "ship.androsynth.graphics.androsyn.medium"
+#define ANDROSYNTH_MICON_MASK_PMAP_ANIM "ship.androsynth.meleeicons"
+#define ANDROSYNTH_SML_MASK_PMAP_ANIM "ship.androsynth.graphics.androsyn.small"
+#define BLAZER_BIG_MASK_PMAP_ANIM "ship.androsynth.graphics.blazer.large"
+#define BLAZER_MED_MASK_PMAP_ANIM "ship.androsynth.graphics.blazer.medium"
+#define BLAZER_SML_MASK_PMAP_ANIM "ship.androsynth.graphics.blazer.small"
+#define BUBBLE_BIG_MASK_PMAP_ANIM "ship.androsynth.graphics.bubble.large"
+#define BUBBLE_MED_MASK_PMAP_ANIM "ship.androsynth.graphics.bubble.medium"
+#define BUBBLE_SML_MASK_PMAP_ANIM "ship.androsynth.graphics.bubble.small"
diff -ruNp src.orig/sc2code/ships/androsyn/imusicre.h src/sc2code/ships/androsyn/imusicre.h
--- src.orig/sc2code/ships/androsyn/imusicre.h	2017-11-08 16:49:36 -0600
+++ src/sc2code/ships/androsyn/imusicre.h	2017-11-08 16:50:04 -0600
@@ -1,3 +1,5 @@
-#define ANDROSYNTH_VICTORY_SONG 0x00400006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ANDROSYNTH_VICTORY_SONG "ship.androsynth.ditty"
diff -ruNp src.orig/sc2code/ships/androsyn/isndres.h src/sc2code/ships/androsyn/isndres.h
--- src.orig/sc2code/ships/androsyn/isndres.h	2017-11-08 16:49:36 -0600
+++ src/sc2code/ships/androsyn/isndres.h	2017-11-08 16:50:04 -0600
@@ -1,3 +1,5 @@
-#define ANDROSYNTH_SHIP_SOUNDS 0x00400005L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ANDROSYNTH_SHIP_SOUNDS "ship.androsynth.sounds"
diff -ruNp src.orig/sc2code/ships/androsyn/istrtab.h src/sc2code/ships/androsyn/istrtab.h
--- src.orig/sc2code/ships/androsyn/istrtab.h	2017-11-08 16:49:36 -0600
+++ src/sc2code/ships/androsyn/istrtab.h	2017-11-08 16:50:04 -0600
@@ -1,3 +1,5 @@
-#define ANDROSYNTH_RACE_STRINGS 0x00200004L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ANDROSYNTH_RACE_STRINGS "ship.androsynth.text"
diff -ruNp src.orig/sc2code/ships/arilou/arilou.c src/sc2code/ships/arilou/arilou.c
--- src.orig/sc2code/ships/arilou/arilou.c	2017-11-08 16:49:36 -0600
+++ src/sc2code/ships/arilou/arilou.c	2017-11-08 16:50:04 -0600
@@ -41,18 +41,21 @@
 
 static RACE_DESC arilou_desc =
 {
-	{
+	{ /* SHIP_INFO */
 		/* FIRES_FORE | */ IMMEDIATE_WEAPON,
 		16, /* Super Melee cost */
-		250 / SPHERE_RADIUS_INCREMENT, /* Initial sphere of influence radius */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY, MAX_ENERGY,
-		{
+		ARILOU_RACE_STRINGS,
+		ARILOU_ICON_MASK_PMAP_ANIM,
+		ARILOU_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		250 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
 			438, 6372,
 		},
-		(STRING)ARILOU_RACE_STRINGS,
-		(FRAME)ARILOU_ICON_MASK_PMAP_ANIM,
-		(FRAME)ARILOU_MICON_MASK_PMAP_ANIM,
 	},
 	{
 		MAX_THRUST,
@@ -69,34 +72,35 @@ static RACE_DESC arilou_desc =
 	},
 	{
 		{
-			(FRAME)ARILOU_BIG_MASK_PMAP_ANIM,
-			(FRAME)ARILOU_MED_MASK_PMAP_ANIM,
-			(FRAME)ARILOU_SML_MASK_PMAP_ANIM,
+			ARILOU_BIG_MASK_PMAP_ANIM,
+			ARILOU_MED_MASK_PMAP_ANIM,
+			ARILOU_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
 		},
 		{
-			(FRAME)WARP_BIG_MASK_PMAP_ANIM,
-			(FRAME)WARP_MED_MASK_PMAP_ANIM,
-			(FRAME)WARP_SML_MASK_PMAP_ANIM,
+			WARP_BIG_MASK_PMAP_ANIM,
+			WARP_MED_MASK_PMAP_ANIM,
+			WARP_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)ARILOU_CAPTAIN_MASK_PMAP_ANIM,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			ARILOU_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
 		},
-		(SOUND)ARILOU_VICTORY_SONG,
-		(SOUND)ARILOU_SHIP_SOUNDS,
+		ARILOU_VICTORY_SONG,
+		ARILOU_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
 	},
 	{
 		0,
 		LASER_RANGE >> 1,
-		NULL_PTR,
+		NULL,
 	},
 	(UNINIT_FUNC *) NULL,
 	(PREPROCESS_FUNC *) NULL,
@@ -106,11 +110,11 @@ static RACE_DESC arilou_desc =
 };
 
 static COUNT
-initialize_autoaim_laser (PELEMENT ShipPtr, HELEMENT LaserArray[])
+initialize_autoaim_laser (ELEMENT *ShipPtr, HELEMENT LaserArray[])
 {
 	COUNT orig_facing;
 	SIZE delta_facing;
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	LASER_BLOCK LaserBlock;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
@@ -133,10 +137,10 @@ initialize_autoaim_laser (PELEMENT ShipP
 }
 
 static void
-arilou_intelligence (PELEMENT ShipPtr, PEVALUATE_DESC ObjectsOfConcern,
+arilou_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
 		COUNT ConcernCounter)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	StarShipPtr->ship_input_state |= THRUST;
@@ -146,7 +150,7 @@ arilou_intelligence (PELEMENT ShipPtr, P
 
 	if (StarShipPtr->special_counter == 0)
 	{
-		PEVALUATE_DESC lpEvalDesc;
+		EVALUATE_DESC *lpEvalDesc;
 
 		StarShipPtr->ship_input_state &= ~SPECIAL;
 
@@ -154,7 +158,7 @@ arilou_intelligence (PELEMENT ShipPtr, P
 		if (lpEvalDesc->ObjectPtr && lpEvalDesc->which_turn <= 6)
 		{
 			BOOLEAN IsTrackingWeapon;
-			STARSHIPPTR EnemyStarShipPtr;
+			STARSHIP *EnemyStarShipPtr;
 
 			GetElementStarShip (lpEvalDesc->ObjectPtr, &EnemyStarShipPtr);
 			if (((EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags
@@ -185,9 +189,9 @@ arilou_intelligence (PELEMENT ShipPtr, P
 }
 
 static void
-arilou_preprocess (PELEMENT ElementPtr)
+arilou_preprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (!(ElementPtr->state_flags & NONSOLID))
@@ -202,6 +206,7 @@ arilou_preprocess (PELEMENT ElementPtr)
 				&& StarShipPtr->special_counter == 0
 				&& DeltaEnergy (ElementPtr, -SPECIAL_ENERGY_COST))
 		{
+			/* Special key is pressed; start teleport */
 #define HYPER_LIFE 5
 			ZeroVelocityComponents (&ElementPtr->velocity);
 			StarShipPtr->cur_status_flags &=
@@ -239,6 +244,7 @@ arilou_preprocess (PELEMENT ElementPtr)
 
 		if ((life_span = ElementPtr->life_span) == NORMAL_LIFE)
 		{
+			/* Ending teleport */
 			ElementPtr->state_flags &= ~(NONSOLID | FINITE_LIFE);
 			ElementPtr->state_flags |= APPEARING;
 			ElementPtr->current.image.farray =
@@ -252,6 +258,7 @@ arilou_preprocess (PELEMENT ElementPtr)
 		}
 		else
 		{
+			/* Teleporting in progress */
 			--life_span;
 			if (life_span != 2)
 			{
@@ -275,16 +282,14 @@ arilou_preprocess (PELEMENT ElementPtr)
 	}
 }
 
-RACE_DESCPTR
+RACE_DESC*
 init_arilou (void)
 {
-	RACE_DESCPTR RaceDescPtr;
+	RACE_DESC *RaceDescPtr;
 
 	arilou_desc.preprocess_func = arilou_preprocess;
 	arilou_desc.init_weapon_func = initialize_autoaim_laser;
-	arilou_desc.cyborg_control.intelligence_func =
-			(void (*) (PVOID ShipPtr, PVOID ObjectsOfConcern, COUNT
-					ConcernCounter)) arilou_intelligence;
+	arilou_desc.cyborg_control.intelligence_func = arilou_intelligence;
 
 	RaceDescPtr = &arilou_desc;
 
diff -ruNp src.orig/sc2code/ships/arilou/icode.h src/sc2code/ships/arilou/icode.h
--- src.orig/sc2code/ships/arilou/icode.h	2017-11-08 16:49:36 -0600
+++ src/sc2code/ships/arilou/icode.h	2017-11-08 16:50:04 -0600
@@ -1,3 +1,5 @@
-#define ARILOU_CODE 0x00200008L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ARILOU_CODE "ship.arilou.code"
diff -ruNp src.orig/sc2code/ships/arilou/igfxres.h src/sc2code/ships/arilou/igfxres.h
--- src.orig/sc2code/ships/arilou/igfxres.h	2017-11-08 16:49:36 -0600
+++ src/sc2code/ships/arilou/igfxres.h	2017-11-08 16:50:04 -0600
@@ -1,11 +1,13 @@
-#define ARILOU_ICON_MASK_PMAP_ANIM 0x00200002L
-#define ARILOU_MICON_MASK_PMAP_ANIM 0x00200102L
-#define ARILOU_BIG_MASK_PMAP_ANIM 0x00400202L
-#define ARILOU_MED_MASK_PMAP_ANIM 0x00400302L
-#define ARILOU_SML_MASK_PMAP_ANIM 0x00400402L
-#define WARP_BIG_MASK_PMAP_ANIM 0x00400502L
-#define WARP_MED_MASK_PMAP_ANIM 0x00400602L
-#define WARP_SML_MASK_PMAP_ANIM 0x00400702L
-#define ARILOU_CAPTAIN_MASK_PMAP_ANIM 0x00400802L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ARILOU_BIG_MASK_PMAP_ANIM "ship.arilou.graphics.arilou.large"
+#define ARILOU_CAPTAIN_MASK_PMAP_ANIM "ship.arilou.graphics.captain"
+#define ARILOU_ICON_MASK_PMAP_ANIM "ship.arilou.icons"
+#define ARILOU_MED_MASK_PMAP_ANIM "ship.arilou.graphics.arilou.medium"
+#define ARILOU_MICON_MASK_PMAP_ANIM "ship.arilou.meleeicons"
+#define ARILOU_SML_MASK_PMAP_ANIM "ship.arilou.graphics.arilou.small"
+#define WARP_BIG_MASK_PMAP_ANIM "ship.arilou.graphics.warp.large"
+#define WARP_MED_MASK_PMAP_ANIM "ship.arilou.graphics.warp.medium"
+#define WARP_SML_MASK_PMAP_ANIM "ship.arilou.graphics.warp.small"
diff -ruNp src.orig/sc2code/ships/arilou/imusicre.h src/sc2code/ships/arilou/imusicre.h
--- src.orig/sc2code/ships/arilou/imusicre.h	2017-11-08 16:49:36 -0600
+++ src/sc2code/ships/arilou/imusicre.h	2017-11-08 16:50:04 -0600
@@ -1,3 +1,5 @@
-#define ARILOU_VICTORY_SONG 0x00400006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ARILOU_VICTORY_SONG "ship.arilou.ditty"
diff -ruNp src.orig/sc2code/ships/arilou/isndres.h src/sc2code/ships/arilou/isndres.h
--- src.orig/sc2code/ships/arilou/isndres.h	2017-11-08 16:49:36 -0600
+++ src/sc2code/ships/arilou/isndres.h	2017-11-08 16:50:04 -0600
@@ -1,3 +1,5 @@
-#define ARILOU_SHIP_SOUNDS 0x00400005L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ARILOU_SHIP_SOUNDS "ship.arilou.sounds"
diff -ruNp src.orig/sc2code/ships/arilou/istrtab.h src/sc2code/ships/arilou/istrtab.h
--- src.orig/sc2code/ships/arilou/istrtab.h	2017-11-08 16:49:36 -0600
+++ src/sc2code/ships/arilou/istrtab.h	2017-11-08 16:50:04 -0600
@@ -1,3 +1,5 @@
-#define ARILOU_RACE_STRINGS 0x00200004L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ARILOU_RACE_STRINGS "ship.arilou.text"
diff -ruNp src.orig/sc2code/ships/blackurq/blackurq.c src/sc2code/ships/blackurq/blackurq.c
--- src.orig/sc2code/ships/blackurq/blackurq.c	2017-11-08 16:49:36 -0600
+++ src/sc2code/ships/blackurq/blackurq.c	2017-11-08 16:50:04 -0600
@@ -43,18 +43,21 @@
 
 static RACE_DESC black_urquan_desc =
 {
-	{
+	{ /* SHIP_INFO */
 		FIRES_FORE,
 		30, /* Super Melee cost */
-		2666 / SPHERE_RADIUS_INCREMENT, /* Initial sphere of influence radius */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY, MAX_ENERGY,
-		{
+		KOHR_AH_RACE_STRINGS,
+		KOHR_AH_ICON_MASK_PMAP_ANIM,
+		KOHR_AH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		2666 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
 			6000, 6250,
 		},
-		(STRING)KOHR_AH_RACE_STRINGS,
-		(FRAME)KOHR_AH_ICON_MASK_PMAP_ANIM,
-		(FRAME)KOHR_AH_MICON_MASK_PMAP_ANIM,
 	},
 	{
 		MAX_THRUST,
@@ -71,34 +74,35 @@ static RACE_DESC black_urquan_desc =
 	},
 	{
 		{
-			(FRAME)KOHR_AH_BIG_MASK_PMAP_ANIM,
-			(FRAME)KOHR_AH_MED_MASK_PMAP_ANIM,
-			(FRAME)KOHR_AH_SML_MASK_PMAP_ANIM,
+			KOHR_AH_BIG_MASK_PMAP_ANIM,
+			KOHR_AH_MED_MASK_PMAP_ANIM,
+			KOHR_AH_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)BUZZSAW_BIG_MASK_PMAP_ANIM,
-			(FRAME)BUZZSAW_MED_MASK_PMAP_ANIM,
-			(FRAME)BUZZSAW_SML_MASK_PMAP_ANIM,
+			BUZZSAW_BIG_MASK_PMAP_ANIM,
+			BUZZSAW_MED_MASK_PMAP_ANIM,
+			BUZZSAW_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)GAS_BIG_MASK_PMAP_ANIM,
-			(FRAME)GAS_MED_MASK_PMAP_ANIM,
-			(FRAME)GAS_SML_MASK_PMAP_ANIM,
+			GAS_BIG_MASK_PMAP_ANIM,
+			GAS_MED_MASK_PMAP_ANIM,
+			GAS_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)KOHR_AH_CAPTAIN_MASK_PMAP_ANIM,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			KOHR_AH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
 		},
-		(SOUND)KOHR_AH_VICTORY_SONG,
-		(SOUND)KOHR_AH_SHIP_SOUNDS,
+		KOHR_AH_VICTORY_SONG,
+		KOHR_AH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
 	},
 	{
 		0,
 		CLOSE_RANGE_WEAPON,
-		NULL_PTR,
+		NULL,
 	},
 	(UNINIT_FUNC *) NULL,
 	(PREPROCESS_FUNC *) NULL,
@@ -111,10 +115,10 @@ static RACE_DESC black_urquan_desc =
 #define MAX_SAWS 8
 
 static void
-spin_preprocess (PELEMENT ElementPtr)
+spin_preprocess (ELEMENT *ElementPtr)
 {
-	ELEMENTPTR ShipPtr;
-	STARSHIPPTR StarShipPtr;
+	ELEMENT *ShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	LockElement (StarShipPtr->hShip, &ShipPtr);
@@ -151,7 +155,7 @@ spin_preprocess (PELEMENT ElementPtr)
 #define TRACK_WAIT 4
 
 static void
-buzztrack_preprocess (PELEMENT ElementPtr)
+buzztrack_preprocess (ELEMENT *ElementPtr)
 {
 	if (ElementPtr->thrust_wait)
 		--ElementPtr->thrust_wait;
@@ -168,7 +172,7 @@ buzztrack_preprocess (PELEMENT ElementPt
 		{
 #define ACTIVATE_RANGE 224 /* Originally SPACE_WIDTH */
 			SIZE delta_x, delta_y;
-			ELEMENTPTR eptr;
+			ELEMENT *eptr;
 
 			LockElement (ElementPtr->hTarget, &eptr);
 			delta_x = eptr->current.location.x
@@ -209,7 +213,7 @@ buzztrack_preprocess (PELEMENT ElementPt
 }
 
 static void
-decelerate_preprocess (PELEMENT ElementPtr)
+decelerate_preprocess (ELEMENT *ElementPtr)
 {
 	SIZE dx, dy;
 
@@ -226,7 +230,7 @@ decelerate_preprocess (PELEMENT ElementP
 }
 
 static void
-splinter_preprocess (PELEMENT ElementPtr)
+splinter_preprocess (ELEMENT *ElementPtr)
 {
 	ElementPtr->next.image.frame =
 			IncFrameIndex (ElementPtr->current.image.frame);
@@ -234,7 +238,8 @@ splinter_preprocess (PELEMENT ElementPtr
 }
 
 static void
-buzzsaw_collision (PELEMENT ElementPtr0, PPOINT pPt0, PELEMENT ElementPtr1, PPOINT pPt1)
+buzzsaw_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
 	weapon_collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
 
@@ -251,9 +256,9 @@ buzzsaw_collision (PELEMENT ElementPtr0,
 }
 
 static void
-buzzsaw_preprocess (PELEMENT ElementPtr)
+buzzsaw_preprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (!(StarShipPtr->cur_status_flags & WEAPON))
@@ -266,7 +271,7 @@ buzzsaw_preprocess (PELEMENT ElementPtr)
 }
 
 static void
-buzzsaw_postprocess (PELEMENT ElementPtr)
+buzzsaw_postprocess (ELEMENT *ElementPtr)
 {
 	HELEMENT hElement;
 
@@ -275,8 +280,8 @@ buzzsaw_postprocess (PELEMENT ElementPtr
 	if (hElement)
 	{
 		COUNT primIndex;
-		ELEMENTPTR ListElementPtr;
-		STARSHIPPTR StarShipPtr;
+		ELEMENT *ListElementPtr;
+		STARSHIP *StarShipPtr;
 
 		LockElement (hElement, &ListElementPtr);
 		primIndex = ListElementPtr->PrimIndex;
@@ -302,13 +307,13 @@ buzzsaw_postprocess (PELEMENT ElementPtr
 }
 
 static COUNT
-initialize_buzzsaw (PELEMENT ShipPtr, HELEMENT SawArray[])
+initialize_buzzsaw (ELEMENT *ShipPtr, HELEMENT SawArray[])
 {
 #define MISSILE_HITS 10
 #define MISSILE_DAMAGE 4
 #define MISSILE_OFFSET 9
 #define KOHR_AH_OFFSET 28
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
@@ -330,7 +335,7 @@ initialize_buzzsaw (PELEMENT ShipPtr, HE
 
 	if (SawArray[0])
 	{
-		ELEMENTPTR SawPtr;
+		ELEMENT *SawPtr;
 
 		LockElement (SawArray[0], &SawPtr);
 		SawPtr->turn_wait = SAW_RATE;
@@ -344,10 +349,11 @@ initialize_buzzsaw (PELEMENT ShipPtr, HE
 }
 
 static void
-black_urquan_intelligence (PELEMENT ShipPtr, PEVALUATE_DESC ObjectsOfConcern, COUNT ConcernCounter)
+black_urquan_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+		COUNT ConcernCounter)
 {
-	PEVALUATE_DESC lpEvalDesc;
-	STARSHIPPTR StarShipPtr;
+	EVALUATE_DESC *lpEvalDesc;
+	STARSHIP *StarShipPtr;
 
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_WEAPON_INDEX];
 	if (lpEvalDesc->ObjectPtr
@@ -375,7 +381,7 @@ black_urquan_intelligence (PELEMENT Ship
 #define FRAGMENT_SPEED MISSILE_SPEED
 #define FRAGMENT_RANGE (FRAGMENT_LIFE * FRAGMENT_SPEED)
 		HELEMENT h, hNext;
-		ELEMENTPTR BuzzSawPtr;
+		ELEMENT *BuzzSawPtr;
 
 		h = (StarShipPtr->old_status_flags & WEAPON) ?
 				GetSuccElement (ShipPtr) : (HELEMENT)0;
@@ -429,7 +435,7 @@ black_urquan_intelligence (PELEMENT Ship
 #define GAS_RATE 2
 
 static void
-gas_cloud_preprocess (PELEMENT ElementPtr)
+gas_cloud_preprocess (ELEMENT *ElementPtr)
 {
 	if (ElementPtr->turn_wait)
 		--ElementPtr->turn_wait;
@@ -446,7 +452,8 @@ gas_cloud_preprocess (PELEMENT ElementPt
 #define GAS_DAMAGE 3
 
 static void
-gas_cloud_collision (PELEMENT ElementPtr0, PPOINT pPt0, PELEMENT ElementPtr1, PPOINT pPt1)
+gas_cloud_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
 	if (ElementPtr1->state_flags & PLAYER_SHIP)
 		ElementPtr0->mass_points = GAS_DAMAGE;
@@ -457,14 +464,14 @@ gas_cloud_collision (PELEMENT ElementPtr
 }
 
 static void
-spawn_gas_cloud (PELEMENT ElementPtr)
+spawn_gas_cloud (ELEMENT *ElementPtr)
 {
 #define GAS_SPEED 16
 #define GAS_HITS 100
 #define GAS_OFFSET 2
 #define NUM_GAS_CLOUDS 16
 	SIZE dx, dy;
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
@@ -495,7 +502,7 @@ spawn_gas_cloud (PELEMENT ElementPtr)
 		hGasCloud = initialize_missile (&MissileBlock);
 		if (hGasCloud)
 		{
-			ELEMENTPTR GasCloudPtr;
+			ELEMENT *GasCloudPtr;
 
 			LockElement (hGasCloud, &GasCloudPtr);
 			SetElementStarShip (GasCloudPtr, StarShipPtr);
@@ -510,9 +517,9 @@ spawn_gas_cloud (PELEMENT ElementPtr)
 }
 
 static void
-black_urquan_postprocess (PELEMENT ElementPtr)
+black_urquan_postprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if ((StarShipPtr->cur_status_flags & SPECIAL)
@@ -529,9 +536,9 @@ black_urquan_postprocess (PELEMENT Eleme
 }
 
 static void
-black_urquan_preprocess (PELEMENT ElementPtr)
+black_urquan_preprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 			/* no spinning disks */
@@ -542,17 +549,15 @@ black_urquan_preprocess (PELEMENT Elemen
 		++StarShipPtr->weapon_counter;
 }
 
-RACE_DESCPTR
+RACE_DESC*
 init_black_urquan (void)
 {
-	RACE_DESCPTR RaceDescPtr;
+	RACE_DESC *RaceDescPtr;
 
 	black_urquan_desc.preprocess_func = black_urquan_preprocess;
 	black_urquan_desc.postprocess_func = black_urquan_postprocess;
 	black_urquan_desc.init_weapon_func = initialize_buzzsaw;
-	black_urquan_desc.cyborg_control.intelligence_func =
-			(void (*) (PVOID ShipPtr, PVOID ObjectsOfConcern, COUNT
-					ConcernCounter)) black_urquan_intelligence;
+	black_urquan_desc.cyborg_control.intelligence_func = black_urquan_intelligence;
 
 	RaceDescPtr = &black_urquan_desc;
 
diff -ruNp src.orig/sc2code/ships/blackurq/icode.h src/sc2code/ships/blackurq/icode.h
--- src.orig/sc2code/ships/blackurq/icode.h	2017-11-08 16:49:36 -0600
+++ src/sc2code/ships/blackurq/icode.h	2017-11-08 16:50:04 -0600
@@ -1,3 +1,5 @@
-#define KOHR_AH_CODE 0x00200008L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define KOHR_AH_CODE "ship.kohrah.code"
diff -ruNp src.orig/sc2code/ships/blackurq/igfxres.h src/sc2code/ships/blackurq/igfxres.h
--- src.orig/sc2code/ships/blackurq/igfxres.h	2017-11-08 16:49:36 -0600
+++ src/sc2code/ships/blackurq/igfxres.h	2017-11-08 16:50:04 -0600
@@ -1,14 +1,16 @@
-#define KOHR_AH_ICON_MASK_PMAP_ANIM 0x00200002L
-#define KOHR_AH_MICON_MASK_PMAP_ANIM 0x00200102L
-#define KOHR_AH_BIG_MASK_PMAP_ANIM 0x00400202L
-#define KOHR_AH_MED_MASK_PMAP_ANIM 0x00400302L
-#define KOHR_AH_SML_MASK_PMAP_ANIM 0x00400402L
-#define BUZZSAW_BIG_MASK_PMAP_ANIM 0x00400502L
-#define BUZZSAW_MED_MASK_PMAP_ANIM 0x00400602L
-#define BUZZSAW_SML_MASK_PMAP_ANIM 0x00400702L
-#define GAS_BIG_MASK_PMAP_ANIM 0x00400802L
-#define GAS_MED_MASK_PMAP_ANIM 0x00400902L
-#define GAS_SML_MASK_PMAP_ANIM 0x00400a02L
-#define KOHR_AH_CAPTAIN_MASK_PMAP_ANIM 0x00400b02L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define BUZZSAW_BIG_MASK_PMAP_ANIM "ship.kohrah.graphics.buz.large"
+#define BUZZSAW_MED_MASK_PMAP_ANIM "ship.kohrah.graphics.buz.medium"
+#define BUZZSAW_SML_MASK_PMAP_ANIM "ship.kohrah.graphics.buz.small"
+#define GAS_BIG_MASK_PMAP_ANIM "ship.kohrah.graphics.gas.large"
+#define GAS_MED_MASK_PMAP_ANIM "ship.kohrah.graphics.gas.medium"
+#define GAS_SML_MASK_PMAP_ANIM "ship.kohrah.graphics.gas.small"
+#define KOHR_AH_BIG_MASK_PMAP_ANIM "ship.kohrah.graphics.blackurq.large"
+#define KOHR_AH_CAPTAIN_MASK_PMAP_ANIM "ship.kohrah.graphics.captain"
+#define KOHR_AH_ICON_MASK_PMAP_ANIM "ship.kohrah.icons"
+#define KOHR_AH_MED_MASK_PMAP_ANIM "ship.kohrah.graphics.blackurq.medium"
+#define KOHR_AH_MICON_MASK_PMAP_ANIM "ship.kohrah.meleeicons"
+#define KOHR_AH_SML_MASK_PMAP_ANIM "ship.kohrah.graphics.blackurq.small"
diff -ruNp src.orig/sc2code/ships/blackurq/imusicre.h src/sc2code/ships/blackurq/imusicre.h
--- src.orig/sc2code/ships/blackurq/imusicre.h	2017-11-08 16:49:36 -0600
+++ src/sc2code/ships/blackurq/imusicre.h	2017-11-08 16:50:04 -0600
@@ -1,3 +1,5 @@
-#define KOHR_AH_VICTORY_SONG 0x00400006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define KOHR_AH_VICTORY_SONG "ship.kohrah.ditty"
diff -ruNp src.orig/sc2code/ships/blackurq/isndres.h src/sc2code/ships/blackurq/isndres.h
--- src.orig/sc2code/ships/blackurq/isndres.h	2017-11-08 16:49:36 -0600
+++ src/sc2code/ships/blackurq/isndres.h	2017-11-08 16:50:04 -0600
@@ -1,3 +1,5 @@
-#define KOHR_AH_SHIP_SOUNDS 0x00400005L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define KOHR_AH_SHIP_SOUNDS "ship.kohrah.sounds"
diff -ruNp src.orig/sc2code/ships/blackurq/istrtab.h src/sc2code/ships/blackurq/istrtab.h
--- src.orig/sc2code/ships/blackurq/istrtab.h	2017-11-08 16:49:36 -0600
+++ src/sc2code/ships/blackurq/istrtab.h	2017-11-08 16:50:04 -0600
@@ -1,3 +1,5 @@
-#define KOHR_AH_RACE_STRINGS 0x00200004L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define KOHR_AH_RACE_STRINGS "ship.kohrah.text"
diff -ruNp src.orig/sc2code/ships/chenjesu/chenjesu.c src/sc2code/ships/chenjesu/chenjesu.c
--- src.orig/sc2code/ships/chenjesu/chenjesu.c	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/chenjesu/chenjesu.c	2017-11-08 16:50:04 -0600
@@ -46,18 +46,21 @@
 
 static RACE_DESC chenjesu_desc =
 {
-	{
+	{ /* SHIP_INFO */
 		FIRES_FORE | SEEKING_SPECIAL | SEEKING_WEAPON,
 		28, /* Super Melee cost */
-		0 / SPHERE_RADIUS_INCREMENT, /* Initial sphere of influence radius */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY, MAX_ENERGY,
-		{
+		CHENJESU_RACE_STRINGS,
+		CHENJESU_ICON_MASK_PMAP_ANIM,
+		CHENJESU_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
 			0, 0,
 		},
-		(STRING)CHENJESU_RACE_STRINGS,
-		(FRAME)CHENJESU_ICON_MASK_PMAP_ANIM,
-		(FRAME)CHENJESU_MICON_MASK_PMAP_ANIM,
 	},
 	{
 		MAX_THRUST,
@@ -74,34 +77,35 @@ static RACE_DESC chenjesu_desc =
 	},
 	{
 		{
-			(FRAME)CHENJESU_BIG_MASK_PMAP_ANIM,
-			(FRAME)CHENJESU_MED_MASK_PMAP_ANIM,
-			(FRAME)CHENJESU_SML_MASK_PMAP_ANIM,
+			CHENJESU_BIG_MASK_PMAP_ANIM,
+			CHENJESU_MED_MASK_PMAP_ANIM,
+			CHENJESU_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)SPARK_BIG_MASK_PMAP_ANIM,
-			(FRAME)SPARK_MED_MASK_PMAP_ANIM,
-			(FRAME)SPARK_SML_MASK_PMAP_ANIM,
+			SPARK_BIG_MASK_PMAP_ANIM,
+			SPARK_MED_MASK_PMAP_ANIM,
+			SPARK_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)DOGGY_BIG_MASK_PMAP_ANIM,
-			(FRAME)DOGGY_MED_MASK_PMAP_ANIM,
-			(FRAME)DOGGY_SML_MASK_PMAP_ANIM,
+			DOGGY_BIG_MASK_PMAP_ANIM,
+			DOGGY_MED_MASK_PMAP_ANIM,
+			DOGGY_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)CHENJESU_CAPTAIN_MASK_PMAP_ANIM,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			CHENJESU_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
 		},
-		(SOUND)CHENJESU_VICTORY_SONG,
-		(SOUND)CHENJESU_SHIP_SOUNDS,
+		CHENJESU_VICTORY_SONG,
+		CHENJESU_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
 	},
 	{
 		0,
 		LONG_RANGE_WEAPON,
-		NULL_PTR,
+		NULL,
 	},
 	(UNINIT_FUNC *) NULL,
 	(PREPROCESS_FUNC *) NULL,
@@ -115,13 +119,13 @@ static RACE_DESC chenjesu_desc =
 #define FRAGMENT_RANGE (FRAGMENT_LIFE * FRAGMENT_SPEED)
 
 static void
-crystal_postprocess (PELEMENT ElementPtr)
+crystal_postprocess (ELEMENT *ElementPtr)
 {
 #define FRAGMENT_HITS 1
 #define FRAGMENT_DAMAGE 2
 #define FRAGMENT_OFFSET 2
 #define NUM_FRAGMENTS 8
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
@@ -137,7 +141,7 @@ crystal_postprocess (PELEMENT ElementPtr
 	MissileBlock.hit_points = FRAGMENT_HITS;
 	MissileBlock.damage = FRAGMENT_DAMAGE;
 	MissileBlock.life = FRAGMENT_LIFE;
-	MissileBlock.preprocess_func = NULL_PTR;
+	MissileBlock.preprocess_func = NULL;
 	MissileBlock.blast_offs = FRAGMENT_OFFSET;
 
 	for (MissileBlock.face = 0;
@@ -150,7 +154,7 @@ crystal_postprocess (PELEMENT ElementPtr
 		hFragment = initialize_missile (&MissileBlock);
 		if (hFragment)
 		{
-			ELEMENTPTR FragPtr;
+			ELEMENT *FragPtr;
 
 			LockElement (hFragment, &FragPtr);
 			SetElementStarShip (FragPtr, StarShipPtr);
@@ -165,9 +169,9 @@ crystal_postprocess (PELEMENT ElementPtr
 }
 
 static void
-crystal_preprocess (PELEMENT ElementPtr)
+crystal_preprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (StarShipPtr->cur_status_flags & WEAPON)
@@ -181,7 +185,7 @@ crystal_preprocess (PELEMENT ElementPtr)
 }
 
 static void
-animate (PELEMENT ElementPtr)
+animate (ELEMENT *ElementPtr)
 {
 	if (ElementPtr->turn_wait > 0)
 		--ElementPtr->turn_wait;
@@ -196,7 +200,8 @@ animate (PELEMENT ElementPtr)
 }
 
 static void
-crystal_collision (PELEMENT ElementPtr0, PPOINT pPt0, PELEMENT ElementPtr1, PPOINT pPt1)
+crystal_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
 	HELEMENT hBlastElement;
 
@@ -204,7 +209,7 @@ crystal_collision (PELEMENT ElementPtr0,
 			weapon_collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
 	if (hBlastElement)
 	{
-		ELEMENTPTR BlastElementPtr;
+		ELEMENT *BlastElementPtr;
 
 #define NUM_SPARKLES 8
 		LockElement (hBlastElement, &BlastElementPtr);
@@ -229,9 +234,9 @@ crystal_collision (PELEMENT ElementPtr0,
 #define DOGGY_SPEED DISPLAY_TO_WORLD (8)
 
 static void
-doggy_preprocess (PELEMENT ElementPtr)
+doggy_preprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	++StarShipPtr->special_counter;
@@ -250,7 +255,7 @@ doggy_preprocess (PELEMENT ElementPtr)
 			facing = NORMALIZE_FACING (TFB_Random ());
 		else
 		{
-			ELEMENTPTR ShipPtr;
+			ELEMENT *ShipPtr;
 
 			LockElement (ElementPtr->hTarget, &ShipPtr);
 			facing = NORMALIZE_FACING (ANGLE_TO_FACING (
@@ -282,9 +287,9 @@ doggy_preprocess (PELEMENT ElementPtr)
 }
 
 static void
-doggy_death (PELEMENT ElementPtr)
+doggy_death (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	ProcessSound (SetAbsSoundIndex (
@@ -297,15 +302,16 @@ doggy_death (PELEMENT ElementPtr)
 	{
 		ElementPtr->preprocess_func = animate;
 	}
-	ElementPtr->death_func = NULL_PTR;
-	ElementPtr->collision_func = NULL_PTR;
+	ElementPtr->death_func = NULL;
+	ElementPtr->collision_func = NULL;
 	ZeroVelocityComponents (&ElementPtr->velocity);
 
 	ElementPtr->turn_wait = ElementPtr->next_turn = 0;
 }
 
 static void
-doggy_collision (PELEMENT ElementPtr0, PPOINT pPt0, PELEMENT ElementPtr1, PPOINT pPt1)
+doggy_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
 #define ENERGY_DRAIN 10
 	collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
@@ -315,7 +321,7 @@ doggy_collision (PELEMENT ElementPtr0, P
 			(ElementPtr1->state_flags
 			& (GOOD_GUY | BAD_GUY)))
 	{
-		STARSHIPPTR StarShipPtr;
+		STARSHIP *StarShipPtr;
 
 		GetElementStarShip (ElementPtr0, &StarShipPtr);
 		ProcessSound (SetAbsSoundIndex (
@@ -334,15 +340,15 @@ doggy_collision (PELEMENT ElementPtr0, P
 #define CHENJESU_OFFSET 16
 
 static void
-spawn_doggy (PELEMENT ElementPtr)
+spawn_doggy (ELEMENT *ElementPtr)
 {
 	HELEMENT hDoggyElement;
 
 	if ((hDoggyElement = AllocElement ()) != 0)
 	{
 		COUNT angle;
-		ELEMENTPTR DoggyElementPtr;
-		STARSHIPPTR StarShipPtr;
+		ELEMENT *DoggyElementPtr;
+		STARSHIP *StarShipPtr;
 
 		ElementPtr->state_flags |= DEFY_PHYSICS;
 
@@ -358,7 +364,7 @@ spawn_doggy (PELEMENT ElementPtr)
 				STAMP_PRIM);
 		{
 			DoggyElementPtr->preprocess_func = doggy_preprocess;
-			DoggyElementPtr->postprocess_func = NULL_PTR;
+			DoggyElementPtr->postprocess_func = NULL;
 			DoggyElementPtr->collision_func = doggy_collision;
 			DoggyElementPtr->death_func = doggy_death;
 		}
@@ -386,10 +392,11 @@ spawn_doggy (PELEMENT ElementPtr)
 }
 
 static void
-chenjesu_intelligence (PELEMENT ShipPtr, PEVALUATE_DESC ObjectsOfConcern, COUNT ConcernCounter)
+chenjesu_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+		COUNT ConcernCounter)
 {
-	PEVALUATE_DESC lpEvalDesc;
-	STARSHIPPTR StarShipPtr;
+	EVALUATE_DESC *lpEvalDesc;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	StarShipPtr->ship_input_state &= ~SPECIAL;
@@ -397,7 +404,7 @@ chenjesu_intelligence (PELEMENT ShipPtr,
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
 	if (lpEvalDesc->ObjectPtr)
 	{
-		STARSHIPPTR EnemyStarShipPtr;
+		STARSHIP *EnemyStarShipPtr;
 
 		GetElementStarShip (lpEvalDesc->ObjectPtr, &EnemyStarShipPtr);
 		if ((lpEvalDesc->which_turn <= 16
@@ -427,7 +434,7 @@ chenjesu_intelligence (PELEMENT ShipPtr,
 	if (lpEvalDesc->ObjectPtr)
 	{
 		HELEMENT h, hNext;
-		ELEMENTPTR CrystalPtr;
+		ELEMENT *CrystalPtr;
 
 		h = (StarShipPtr->old_status_flags & WEAPON) ?
 				GetTailElement () : (HELEMENT)0;
@@ -493,12 +500,12 @@ chenjesu_intelligence (PELEMENT ShipPtr,
 }
 
 static COUNT
-initialize_crystal (PELEMENT ShipPtr, HELEMENT CrystalArray[])
+initialize_crystal (ELEMENT *ShipPtr, HELEMENT CrystalArray[])
 {
 #define MISSILE_HITS 10
 #define MISSILE_DAMAGE 6
 #define MISSILE_OFFSET 0
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
@@ -520,7 +527,7 @@ initialize_crystal (PELEMENT ShipPtr, HE
 
 	if (CrystalArray[0])
 	{
-		ELEMENTPTR CrystalPtr;
+		ELEMENT *CrystalPtr;
 
 		LockElement (CrystalArray[0], &CrystalPtr);
 		CrystalPtr->collision_func = crystal_collision;
@@ -531,9 +538,9 @@ initialize_crystal (PELEMENT ShipPtr, HE
 }
 
 static void
-chenjesu_postprocess (PELEMENT ElementPtr)
+chenjesu_postprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if ((StarShipPtr->cur_status_flags & SPECIAL)
@@ -549,9 +556,9 @@ chenjesu_postprocess (PELEMENT ElementPt
 }
 
 static void
-chenjesu_preprocess (PELEMENT ElementPtr)
+chenjesu_preprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (StarShipPtr->special_counter > 1) /* only when STANDARD
@@ -564,17 +571,15 @@ chenjesu_preprocess (PELEMENT ElementPtr
 		++StarShipPtr->weapon_counter;
 }
 
-RACE_DESCPTR
+RACE_DESC*
 init_chenjesu (void)
 {
-	RACE_DESCPTR RaceDescPtr;
+	RACE_DESC *RaceDescPtr;
 
 	chenjesu_desc.preprocess_func = chenjesu_preprocess;
 	chenjesu_desc.postprocess_func = chenjesu_postprocess;
 	chenjesu_desc.init_weapon_func = initialize_crystal;
-	chenjesu_desc.cyborg_control.intelligence_func =
-			(void (*) (PVOID ShipPtr, PVOID ObjectsOfConcern, COUNT
-					ConcernCounter)) chenjesu_intelligence;
+	chenjesu_desc.cyborg_control.intelligence_func = chenjesu_intelligence;
 
 	RaceDescPtr = &chenjesu_desc;
 
diff -ruNp src.orig/sc2code/ships/chenjesu/icode.h src/sc2code/ships/chenjesu/icode.h
--- src.orig/sc2code/ships/chenjesu/icode.h	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/chenjesu/icode.h	2017-11-08 16:50:04 -0600
@@ -1,3 +1,5 @@
-#define CHENJESU_CODE 0x00200008L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define CHENJESU_CODE "ship.chenjesu.code"
diff -ruNp src.orig/sc2code/ships/chenjesu/igfxres.h src/sc2code/ships/chenjesu/igfxres.h
--- src.orig/sc2code/ships/chenjesu/igfxres.h	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/chenjesu/igfxres.h	2017-11-08 16:50:04 -0600
@@ -1,14 +1,16 @@
-#define CHENJESU_ICON_MASK_PMAP_ANIM 0x00200002L
-#define CHENJESU_MICON_MASK_PMAP_ANIM 0x00200102L
-#define CHENJESU_BIG_MASK_PMAP_ANIM 0x00400202L
-#define CHENJESU_MED_MASK_PMAP_ANIM 0x00400302L
-#define CHENJESU_SML_MASK_PMAP_ANIM 0x00400402L
-#define SPARK_BIG_MASK_PMAP_ANIM 0x00400502L
-#define SPARK_MED_MASK_PMAP_ANIM 0x00400602L
-#define SPARK_SML_MASK_PMAP_ANIM 0x00400702L
-#define DOGGY_BIG_MASK_PMAP_ANIM 0x00400802L
-#define DOGGY_MED_MASK_PMAP_ANIM 0x00400902L
-#define DOGGY_SML_MASK_PMAP_ANIM 0x00400a02L
-#define CHENJESU_CAPTAIN_MASK_PMAP_ANIM 0x00400b02L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define CHENJESU_BIG_MASK_PMAP_ANIM "ship.chenjesu.graphics.chenjesu.large"
+#define CHENJESU_CAPTAIN_MASK_PMAP_ANIM "ship.chenjesu.graphics.captain"
+#define CHENJESU_ICON_MASK_PMAP_ANIM "ship.chenjesu.icons"
+#define CHENJESU_MED_MASK_PMAP_ANIM "ship.chenjesu.graphics.chenjesu.medium"
+#define CHENJESU_MICON_MASK_PMAP_ANIM "ship.chenjesu.meleeicons"
+#define CHENJESU_SML_MASK_PMAP_ANIM "ship.chenjesu.graphics.chenjesu.small"
+#define DOGGY_BIG_MASK_PMAP_ANIM "ship.chenjesu.graphics.doggy.large"
+#define DOGGY_MED_MASK_PMAP_ANIM "ship.chenjesu.graphics.doggy.medium"
+#define DOGGY_SML_MASK_PMAP_ANIM "ship.chenjesu.graphics.doggy.small"
+#define SPARK_BIG_MASK_PMAP_ANIM "ship.chenjesu.graphics.spark.large"
+#define SPARK_MED_MASK_PMAP_ANIM "ship.chenjesu.graphics.spark.medium"
+#define SPARK_SML_MASK_PMAP_ANIM "ship.chenjesu.graphics.spark.small"
diff -ruNp src.orig/sc2code/ships/chenjesu/imusicre.h src/sc2code/ships/chenjesu/imusicre.h
--- src.orig/sc2code/ships/chenjesu/imusicre.h	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/chenjesu/imusicre.h	2017-11-08 16:50:04 -0600
@@ -1,3 +1,5 @@
-#define CHENJESU_VICTORY_SONG 0x00400006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define CHENJESU_VICTORY_SONG "ship.chenjesu.ditty"
diff -ruNp src.orig/sc2code/ships/chenjesu/isndres.h src/sc2code/ships/chenjesu/isndres.h
--- src.orig/sc2code/ships/chenjesu/isndres.h	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/chenjesu/isndres.h	2017-11-08 16:50:04 -0600
@@ -1,3 +1,5 @@
-#define CHENJESU_SHIP_SOUNDS 0x00400005L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define CHENJESU_SHIP_SOUNDS "ship.chenjesu.sounds"
diff -ruNp src.orig/sc2code/ships/chenjesu/istrtab.h src/sc2code/ships/chenjesu/istrtab.h
--- src.orig/sc2code/ships/chenjesu/istrtab.h	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/chenjesu/istrtab.h	2017-11-08 16:50:04 -0600
@@ -1,3 +1,5 @@
-#define CHENJESU_RACE_STRINGS 0x00200004L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define CHENJESU_RACE_STRINGS "ship.chenjesu.text"
diff -ruNp src.orig/sc2code/ships/chmmr/chmmr.c src/sc2code/ships/chmmr/chmmr.c
--- src.orig/sc2code/ships/chmmr/chmmr.c	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/chmmr/chmmr.c	2017-11-08 16:50:04 -0600
@@ -43,18 +43,21 @@
 
 static RACE_DESC chmmr_desc =
 {
-	{
+	{ /* SHIP_INFO */
 		FIRES_FORE | IMMEDIATE_WEAPON | SEEKING_SPECIAL | POINT_DEFENSE,
 		30, /* Super Melee cost */
-		0, /* Initial sphere of influence radius */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY, MAX_ENERGY,
-		{
+		CHMMR_RACE_STRINGS,
+		CHMMR_ICON_MASK_PMAP_ANIM,
+		CHMMR_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
 			0, 0,
 		},
-		(STRING)CHMMR_RACE_STRINGS,
-		(FRAME)CHMMR_ICON_MASK_PMAP_ANIM,
-		(FRAME)CHMMR_MICON_MASK_PMAP_ANIM,
 	},
 	{
 		MAX_THRUST,
@@ -71,34 +74,35 @@ static RACE_DESC chmmr_desc =
 	},
 	{
 		{
-			(FRAME)CHMMR_BIG_MASK_PMAP_ANIM,
-			(FRAME)CHMMR_MED_MASK_PMAP_ANIM,
-			(FRAME)CHMMR_SML_MASK_PMAP_ANIM,
+			CHMMR_BIG_MASK_PMAP_ANIM,
+			CHMMR_MED_MASK_PMAP_ANIM,
+			CHMMR_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)MUZZLE_BIG_MASK_PMAP_ANIM,
-			(FRAME)MUZZLE_MED_MASK_PMAP_ANIM,
-			(FRAME)MUZZLE_SML_MASK_PMAP_ANIM,
+			MUZZLE_BIG_MASK_PMAP_ANIM,
+			MUZZLE_MED_MASK_PMAP_ANIM,
+			MUZZLE_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)SATELLITE_BIG_MASK_PMAP_ANIM,
-			(FRAME)SATELLITE_MED_MASK_PMAP_ANIM,
-			(FRAME)SATELLITE_SML_MASK_PMAP_ANIM,
+			SATELLITE_BIG_MASK_PMAP_ANIM,
+			SATELLITE_MED_MASK_PMAP_ANIM,
+			SATELLITE_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)CHMMR_CAPTAIN_MASK_PMAP_ANIM,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			CHMMR_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
 		},
-		(SOUND)CHMMR_VICTORY_SONG,
-		(SOUND)CHMMR_SHIP_SOUNDS,
+		CHMMR_VICTORY_SONG,
+		CHMMR_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
 	},
 	{
 		0,
 		CLOSE_RANGE_WEAPON,
-		NULL_PTR,
+		NULL,
 	},
 	(UNINIT_FUNC *) NULL,
 	(PREPROCESS_FUNC *) NULL,
@@ -108,7 +112,7 @@ static RACE_DESC chmmr_desc =
 };
 
 static void
-animate (PELEMENT ElementPtr)
+animate (ELEMENT *ElementPtr)
 {
 	if (ElementPtr->turn_wait > 0)
 		--ElementPtr->turn_wait;
@@ -123,9 +127,9 @@ animate (PELEMENT ElementPtr)
 }
 
 static void
-laser_death (ELEMENTPTR ElementPtr)
+laser_death (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	StarShipPtr->special_counter = ElementPtr->turn_wait;
@@ -135,7 +139,7 @@ laser_death (ELEMENTPTR ElementPtr)
 		SIZE dx, dy;
 		long dist;
 		HELEMENT hIonSpots;
-		ELEMENTPTR ShipPtr;
+		ELEMENT *ShipPtr;
 
 		LockElement (StarShipPtr->hShip, &ShipPtr);
 
@@ -150,7 +154,7 @@ laser_death (ELEMENTPTR ElementPtr)
 				&& (hIonSpots = AllocElement ()))
 		{
 			COUNT angle, magnitude;
-			ELEMENTPTR IonSpotsPtr;
+			ELEMENT *IonSpotsPtr;
 
 			LockElement (hIonSpots, &IonSpotsPtr);
 			IonSpotsPtr->state_flags =
@@ -194,11 +198,11 @@ laser_death (ELEMENTPTR ElementPtr)
 }
 
 static COUNT
-initialize_megawatt_laser (PELEMENT ShipPtr, HELEMENT LaserArray[])
+initialize_megawatt_laser (ELEMENT *ShipPtr, HELEMENT LaserArray[])
 {
 #define NUM_CYCLES 4
 	RECT r;
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	LASER_BLOCK LaserBlock;
 	static const COLOR cycle_array[] =
 	{
@@ -227,7 +231,7 @@ initialize_megawatt_laser (PELEMENT Ship
 
 	if (LaserArray[0])
 	{
-		ELEMENTPTR LaserPtr;
+		ELEMENT *LaserPtr;
 
 		LockElement (LaserArray[0], &LaserPtr);
 
@@ -243,10 +247,11 @@ initialize_megawatt_laser (PELEMENT Ship
 }
 
 static void
-chmmr_intelligence (PELEMENT ShipPtr, PEVALUATE_DESC ObjectsOfConcern, COUNT ConcernCounter)
+chmmr_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+		COUNT ConcernCounter)
 {
-	STARSHIPPTR StarShipPtr;
-	PEVALUATE_DESC lpEvalDesc;
+	STARSHIP *StarShipPtr;
+	EVALUATE_DESC *lpEvalDesc;
 
 	ship_intelligence (ShipPtr, ObjectsOfConcern, ConcernCounter);
 
@@ -266,19 +271,19 @@ chmmr_intelligence (PELEMENT ShipPtr, PE
 }
 
 static void
-chmmr_postprocess (PELEMENT ElementPtr)
+chmmr_postprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 
 	if (StarShipPtr->cur_status_flags & WEAPON)
 	{
 		HELEMENT hMuzzleFlash;
-		ELEMENTPTR MuzzleFlashPtr;
+		ELEMENT *MuzzleFlashPtr;
 
 		LockElement (GetTailElement (), &MuzzleFlashPtr);
-		if ((PELEMENT)MuzzleFlashPtr != ElementPtr
+		if (MuzzleFlashPtr != ElementPtr
 				&& (MuzzleFlashPtr->state_flags & (GOOD_GUY | BAD_GUY)) ==
 				(ElementPtr->state_flags & (GOOD_GUY | BAD_GUY))
 				&& (MuzzleFlashPtr->state_flags & APPEARING)
@@ -318,7 +323,7 @@ chmmr_postprocess (PELEMENT ElementPtr)
 			&& DeltaEnergy (ElementPtr, -SPECIAL_ENERGY_COST))
 	{
 		COUNT facing;
-		ELEMENTPTR ShipElementPtr;
+		ELEMENT *ShipElementPtr;
 
 		LockElement (ElementPtr->hTarget, &ShipElementPtr);
 		
@@ -333,14 +338,14 @@ chmmr_postprocess (PELEMENT ElementPtr)
 		{
 #define NUM_SHADOWS 5
 					
-			ELEMENTPTR ShipElementPtr;
+			ELEMENT *ShipElementPtr;
 
 			LockElement (ElementPtr->hTarget, &ShipElementPtr);
 			if (!GRAVITY_MASS (ShipElementPtr->mass_points + 1))
 			{
 				SIZE i, dx, dy;
 				COUNT angle, magnitude;
-				STARSHIPPTR EnemyStarShipPtr;
+				STARSHIP *EnemyStarShipPtr;
 				static const SIZE shadow_offs[] =
 				{
 					DISPLAY_TO_WORLD (8),
@@ -399,7 +404,7 @@ chmmr_postprocess (PELEMENT ElementPtr)
 					hShadow = AllocElement ();
 					if (hShadow)
 					{
-						ELEMENTPTR ShadowElementPtr;
+						ELEMENT *ShadowElementPtr;
 
 						LockElement (hShadow, &ShadowElementPtr);
 
@@ -441,9 +446,9 @@ chmmr_postprocess (PELEMENT ElementPtr)
 #define SATELLITE_OFFSET DISPLAY_TO_WORLD (64)
 
 static void
-satellite_preprocess (PELEMENT ElementPtr)
+satellite_preprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	++ElementPtr->life_span;
 
@@ -460,7 +465,7 @@ satellite_preprocess (PELEMENT ElementPt
 	if (StarShipPtr->hShip)
 	{
 		SIZE dx, dy;
-		ELEMENTPTR ShipPtr;
+		ELEMENT *ShipPtr;
 
 		StarShipPtr->RaceDescPtr->ship_info.ship_flags |= POINT_DEFENSE;
 
@@ -494,15 +499,17 @@ satellite_preprocess (PELEMENT ElementPt
 }
 
 static void
-spawn_point_defense (PELEMENT ElementPtr)
+spawn_point_defense (ELEMENT *ElementPtr)
 {
 #define DEFENSE_RANGE (UWORD)64
 #define DEFENSE_WAIT 2
 	BYTE weakest;
 	UWORD best_dist;
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	HELEMENT hObject, hNextObject, hBestObject;
-	ELEMENTPTR ShipPtr, SattPtr, ObjectPtr;
+	ELEMENT *ShipPtr;
+	ELEMENT *SattPtr;
+	ELEMENT *ObjectPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	hBestObject = 0;
@@ -573,7 +580,7 @@ spawn_point_defense (PELEMENT ElementPtr
 		hPointDefense = initialize_laser (&LaserBlock);
 		if (hPointDefense)
 		{
-			ELEMENTPTR PDPtr;
+			ELEMENT *PDPtr;
 
 			LockElement (hPointDefense, &PDPtr);
 			SetElementStarShip (PDPtr, StarShipPtr);
@@ -593,9 +600,9 @@ spawn_point_defense (PELEMENT ElementPtr
 }
 
 static void
-satellite_postprocess (PELEMENT ElementPtr)
+satellite_postprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	if (ElementPtr->thrust_wait || ElementPtr->life_span == 0)
 		--ElementPtr->thrust_wait;
@@ -606,7 +613,7 @@ satellite_postprocess (PELEMENT ElementP
 		hDefense = AllocElement ();
 		if (hDefense)
 		{
-			ELEMENTPTR DefensePtr;
+			ELEMENT *DefensePtr;
 			
 			PutElement (hDefense);
 
@@ -615,7 +622,7 @@ satellite_postprocess (PELEMENT ElementP
 					| (ElementPtr->state_flags & (GOOD_GUY | BAD_GUY));
 
 			{
-				ELEMENTPTR SuccPtr;
+				ELEMENT *SuccPtr;
 
 				LockElement (GetSuccElement (ElementPtr), &SuccPtr);
 				DefensePtr->hTarget = GetPredElement (SuccPtr);
@@ -633,8 +640,8 @@ satellite_postprocess (PELEMENT ElementP
 }
 
 static void
-satellite_collision (PELEMENT ElementPtr0, PPOINT pPt0,
-		PELEMENT ElementPtr1, PPOINT pPt1)
+satellite_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
 	(void) ElementPtr0;  /* Satisfying compiler (unused parameter) */
 	(void) pPt0;  /* Satisfying compiler (unused parameter) */
@@ -643,9 +650,9 @@ satellite_collision (PELEMENT ElementPtr
 }
 
 static void
-satellite_death (PELEMENT ElementPtr)
+satellite_death (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	StarShipPtr->RaceDescPtr->ship_info.ship_flags &= ~POINT_DEFENSE;
@@ -659,17 +666,17 @@ satellite_death (PELEMENT ElementPtr)
 			SetAbsFrameIndex (ElementPtr->current.image.frame, 8);
 
 	ElementPtr->preprocess_func = animate;
-	ElementPtr->death_func = NULL_PTR;
-	ElementPtr->postprocess_func = NULL_PTR;
-	ElementPtr->collision_func = NULL_PTR;
+	ElementPtr->death_func = NULL;
+	ElementPtr->postprocess_func = NULL;
+	ElementPtr->collision_func = NULL;
 }
 
 static void
-spawn_satellites (PELEMENT ElementPtr)
+spawn_satellites (ELEMENT *ElementPtr)
 {
 #define NUM_SATELLITES 3
 	COUNT i;
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (StarShipPtr->hShip)
@@ -683,7 +690,7 @@ spawn_satellites (PELEMENT ElementPtr)
 			if (hSatellite)
 			{
 				COUNT angle;
-				ELEMENTPTR SattPtr;
+				ELEMENT *SattPtr;
 
 				LockElement (hSatellite, &SattPtr);
 				SattPtr->state_flags =
@@ -727,17 +734,17 @@ spawn_satellites (PELEMENT ElementPtr)
 }
 
 static void
-chmmr_preprocess (PELEMENT ElementPtr)
+chmmr_preprocess (ELEMENT *ElementPtr)
 {
 	HELEMENT hSatellite;
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	hSatellite = AllocElement ();
 	if (hSatellite)
 	{
-		ELEMENTPTR SattPtr;
-		STARSHIPPTR StarShipPtr;
+		ELEMENT *SattPtr;
+		STARSHIP *StarShipPtr;
 
 		LockElement (hSatellite, &SattPtr);
 		SattPtr->state_flags =
@@ -761,17 +768,15 @@ chmmr_preprocess (PELEMENT ElementPtr)
 	StarShipPtr->RaceDescPtr->preprocess_func = 0;
 }
 
-RACE_DESCPTR
+RACE_DESC*
 init_chmmr (void)
 {
-	RACE_DESCPTR RaceDescPtr;
+	RACE_DESC *RaceDescPtr;
 
 	chmmr_desc.preprocess_func = chmmr_preprocess;
 	chmmr_desc.postprocess_func = chmmr_postprocess;
 	chmmr_desc.init_weapon_func = initialize_megawatt_laser;
-	chmmr_desc.cyborg_control.intelligence_func =
-			(void (*) (PVOID ShipPtr, PVOID ObjectsOfConcern, COUNT
-					ConcernCounter)) chmmr_intelligence;
+	chmmr_desc.cyborg_control.intelligence_func = chmmr_intelligence;
 
 	RaceDescPtr = &chmmr_desc;
 
diff -ruNp src.orig/sc2code/ships/chmmr/icode.h src/sc2code/ships/chmmr/icode.h
--- src.orig/sc2code/ships/chmmr/icode.h	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/chmmr/icode.h	2017-11-08 16:50:04 -0600
@@ -1,3 +1,5 @@
-#define CHMMR_CODE 0x00200008L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define CHMMR_CODE "ship.chmmr.code"
diff -ruNp src.orig/sc2code/ships/chmmr/igfxres.h src/sc2code/ships/chmmr/igfxres.h
--- src.orig/sc2code/ships/chmmr/igfxres.h	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/chmmr/igfxres.h	2017-11-08 16:50:04 -0600
@@ -1,14 +1,16 @@
-#define CHMMR_ICON_MASK_PMAP_ANIM 0x00200002L
-#define CHMMR_MICON_MASK_PMAP_ANIM 0x00200102L
-#define CHMMR_BIG_MASK_PMAP_ANIM 0x00400202L
-#define CHMMR_MED_MASK_PMAP_ANIM 0x00400302L
-#define CHMMR_SML_MASK_PMAP_ANIM 0x00400402L
-#define MUZZLE_BIG_MASK_PMAP_ANIM 0x00400502L
-#define MUZZLE_MED_MASK_PMAP_ANIM 0x00400602L
-#define MUZZLE_SML_MASK_PMAP_ANIM 0x00400702L
-#define SATELLITE_BIG_MASK_PMAP_ANIM 0x00400802L
-#define SATELLITE_MED_MASK_PMAP_ANIM 0x00400902L
-#define SATELLITE_SML_MASK_PMAP_ANIM 0x00400a02L
-#define CHMMR_CAPTAIN_MASK_PMAP_ANIM 0x00400b02L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define CHMMR_BIG_MASK_PMAP_ANIM "ship.chmmr.graphics.chmmr.large"
+#define CHMMR_CAPTAIN_MASK_PMAP_ANIM "ship.chmmr.graphics.captain"
+#define CHMMR_ICON_MASK_PMAP_ANIM "ship.chmmr.icons"
+#define CHMMR_MED_MASK_PMAP_ANIM "ship.chmmr.graphics.chmmr.medium"
+#define CHMMR_MICON_MASK_PMAP_ANIM "ship.chmmr.meleeicons"
+#define CHMMR_SML_MASK_PMAP_ANIM "ship.chmmr.graphics.chmmr.small"
+#define MUZZLE_BIG_MASK_PMAP_ANIM "ship.chmmr.graphics.muz.large"
+#define MUZZLE_MED_MASK_PMAP_ANIM "ship.chmmr.graphics.muz.medium"
+#define MUZZLE_SML_MASK_PMAP_ANIM "ship.chmmr.graphics.muz.small"
+#define SATELLITE_BIG_MASK_PMAP_ANIM "ship.chmmr.graphics.sat.large"
+#define SATELLITE_MED_MASK_PMAP_ANIM "ship.chmmr.graphics.sat.medium"
+#define SATELLITE_SML_MASK_PMAP_ANIM "ship.chmmr.graphics.sat.small"
diff -ruNp src.orig/sc2code/ships/chmmr/imusicre.h src/sc2code/ships/chmmr/imusicre.h
--- src.orig/sc2code/ships/chmmr/imusicre.h	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/chmmr/imusicre.h	2017-11-08 16:50:04 -0600
@@ -1,3 +1,5 @@
-#define CHMMR_VICTORY_SONG 0x00400006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define CHMMR_VICTORY_SONG "ship.chmmr.ditty"
diff -ruNp src.orig/sc2code/ships/chmmr/isndres.h src/sc2code/ships/chmmr/isndres.h
--- src.orig/sc2code/ships/chmmr/isndres.h	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/chmmr/isndres.h	2017-11-08 16:50:04 -0600
@@ -1,3 +1,5 @@
-#define CHMMR_SHIP_SOUNDS 0x00400005L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define CHMMR_SHIP_SOUNDS "ship.chmmr.sounds"
diff -ruNp src.orig/sc2code/ships/chmmr/istrtab.h src/sc2code/ships/chmmr/istrtab.h
--- src.orig/sc2code/ships/chmmr/istrtab.h	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/chmmr/istrtab.h	2017-11-08 16:50:04 -0600
@@ -1,3 +1,5 @@
-#define CHMMR_RACE_STRINGS 0x00200004L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define CHMMR_RACE_STRINGS "ship.chmmr.text"
diff -ruNp src.orig/sc2code/ships/druuge/druuge.c src/sc2code/ships/druuge/druuge.c
--- src.orig/sc2code/ships/druuge/druuge.c	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/druuge/druuge.c	2017-11-08 16:50:04 -0600
@@ -39,18 +39,21 @@
 
 static RACE_DESC druuge_desc =
 {
-	{
+	{ /* SHIP_INFO */
 		FIRES_FORE,
 		17, /* Super Melee cost */
-		1400 / SPHERE_RADIUS_INCREMENT, /* Initial sphere of influence radius */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY, MAX_ENERGY,
-		{
+		DRUUGE_RACE_STRINGS,
+		DRUUGE_ICON_MASK_PMAP_ANIM,
+		DRUUGE_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		1400 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
 			9500, 2792,
 		},
-		(STRING)DRUUGE_RACE_STRINGS,
-		(FRAME)DRUUGE_ICON_MASK_PMAP_ANIM,
-		(FRAME)DRUUGE_MICON_MASK_PMAP_ANIM,
 	},
 	{
 		MAX_THRUST,
@@ -67,34 +70,35 @@ static RACE_DESC druuge_desc =
 	},
 	{
 		{
-			(FRAME)DRUUGE_BIG_MASK_PMAP_ANIM,
-			(FRAME)DRUUGE_MED_MASK_PMAP_ANIM,
-			(FRAME)DRUUGE_SML_MASK_PMAP_ANIM,
+			DRUUGE_BIG_MASK_PMAP_ANIM,
+			DRUUGE_MED_MASK_PMAP_ANIM,
+			DRUUGE_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)DRUUGE_CANNON_BIG_MASK_PMAP_ANIM,
-			(FRAME)DRUUGE_CANNON_MED_MASK_PMAP_ANIM,
-			(FRAME)DRUUGE_CANNON_SML_MASK_PMAP_ANIM,
+			DRUUGE_CANNON_BIG_MASK_PMAP_ANIM,
+			DRUUGE_CANNON_MED_MASK_PMAP_ANIM,
+			DRUUGE_CANNON_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
 		},
 		{
-			(FRAME)DRUUGE_CAPT_MASK_PMAP_ANIM,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			DRUUGE_CAPT_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
 		},
-		(SOUND)DRUUGE_VICTORY_SONG,
-		(SOUND)DRUUGE_SHIP_SOUNDS,
+		DRUUGE_VICTORY_SONG,
+		DRUUGE_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
 	},
 	{
 		0,
 		MISSILE_RANGE,
-		NULL_PTR,
+		NULL,
 	},
 	(UNINIT_FUNC *) NULL,
 	(PREPROCESS_FUNC *) NULL,
@@ -107,7 +111,8 @@ static RACE_DESC druuge_desc =
 #define MAX_RECOIL_VELOCITY (RECOIL_VELOCITY * 4)
 
 static void
-cannon_collision (PELEMENT ElementPtr0, PPOINT pPt0, PELEMENT ElementPtr1, PPOINT pPt1)
+cannon_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
 	weapon_collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
 
@@ -117,7 +122,7 @@ cannon_collision (PELEMENT ElementPtr0,
 	{
 		COUNT angle;
 		SIZE cur_delta_x, cur_delta_y;
-		STARSHIPPTR StarShipPtr;
+		STARSHIP *StarShipPtr;
 
 		GetElementStarShip (ElementPtr1, &StarShipPtr);
 		StarShipPtr->cur_status_flags &=
@@ -144,13 +149,13 @@ cannon_collision (PELEMENT ElementPtr0,
 }
 
 static COUNT
-initialize_cannon (PELEMENT ShipPtr, HELEMENT CannonArray[])
+initialize_cannon (ELEMENT *ShipPtr, HELEMENT CannonArray[])
 {
 #define DRUUGE_OFFSET 24
 #define MISSILE_OFFSET 6
 #define MISSILE_HITS 4
 #define MISSILE_DAMAGE 6
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
@@ -166,13 +171,13 @@ initialize_cannon (PELEMENT ShipPtr, HEL
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
-	MissileBlock.preprocess_func = NULL_PTR;
+	MissileBlock.preprocess_func = NULL;
 	MissileBlock.blast_offs = MISSILE_OFFSET;
 	CannonArray[0] = initialize_missile (&MissileBlock);
 
 	if (CannonArray[0])
 	{
-		ELEMENTPTR CannonPtr;
+		ELEMENT *CannonPtr;
 
 		LockElement (CannonArray[0], &CannonPtr);
 		CannonPtr->collision_func = cannon_collision;
@@ -183,11 +188,13 @@ initialize_cannon (PELEMENT ShipPtr, HEL
 }
 
 static void
-druuge_intelligence (PELEMENT ShipPtr, PEVALUATE_DESC ObjectsOfConcern, COUNT ConcernCounter)
+druuge_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+		COUNT ConcernCounter)
 {
 	UWORD ship_flags;
-	STARSHIPPTR StarShipPtr, EnemyStarShipPtr;
-	PEVALUATE_DESC lpEvalDesc;
+	STARSHIP *StarShipPtr;
+	STARSHIP *EnemyStarShipPtr;
+	EVALUATE_DESC *lpEvalDesc;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 
@@ -235,9 +242,9 @@ druuge_intelligence (PELEMENT ShipPtr, P
 }
 
 static void
-druuge_postprocess (PELEMENT ElementPtr)
+druuge_postprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 			/* if just fired cannon */
@@ -269,9 +276,9 @@ druuge_postprocess (PELEMENT ElementPtr)
 }
 
 static void
-druuge_preprocess (PELEMENT ElementPtr)
+druuge_preprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (StarShipPtr->cur_status_flags & SPECIAL)
@@ -296,17 +303,15 @@ druuge_preprocess (PELEMENT ElementPtr)
 	}
 }
 
-RACE_DESCPTR
+RACE_DESC*
 init_druuge (void)
 {
-	RACE_DESCPTR RaceDescPtr;
+	RACE_DESC *RaceDescPtr;
 
 	druuge_desc.preprocess_func = druuge_preprocess;
 	druuge_desc.postprocess_func = druuge_postprocess;
 	druuge_desc.init_weapon_func = initialize_cannon;
-	druuge_desc.cyborg_control.intelligence_func =
-			(void (*) (PVOID ShipPtr, PVOID ObjectsOfConcern, COUNT
-					ConcernCounter)) druuge_intelligence;
+	druuge_desc.cyborg_control.intelligence_func = druuge_intelligence;
 
 	RaceDescPtr = &druuge_desc;
 
diff -ruNp src.orig/sc2code/ships/druuge/icode.h src/sc2code/ships/druuge/icode.h
--- src.orig/sc2code/ships/druuge/icode.h	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/druuge/icode.h	2017-11-08 16:50:04 -0600
@@ -1,3 +1,5 @@
-#define DRUUGE_CODE 0x00200008L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define DRUUGE_CODE "ship.druuge.code"
diff -ruNp src.orig/sc2code/ships/druuge/igfxres.h src/sc2code/ships/druuge/igfxres.h
--- src.orig/sc2code/ships/druuge/igfxres.h	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/druuge/igfxres.h	2017-11-08 16:50:04 -0600
@@ -1,11 +1,13 @@
-#define DRUUGE_ICON_MASK_PMAP_ANIM 0x00200002L
-#define DRUUGE_MICON_MASK_PMAP_ANIM 0x00200102L
-#define DRUUGE_BIG_MASK_PMAP_ANIM 0x00400202L
-#define DRUUGE_MED_MASK_PMAP_ANIM 0x00400302L
-#define DRUUGE_SML_MASK_PMAP_ANIM 0x00400402L
-#define DRUUGE_CANNON_BIG_MASK_PMAP_ANIM 0x00400502L
-#define DRUUGE_CANNON_MED_MASK_PMAP_ANIM 0x00400602L
-#define DRUUGE_CANNON_SML_MASK_PMAP_ANIM 0x00400702L
-#define DRUUGE_CAPT_MASK_PMAP_ANIM 0x00400802L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define DRUUGE_BIG_MASK_PMAP_ANIM "ship.druuge.graphics.druuge.large"
+#define DRUUGE_CANNON_BIG_MASK_PMAP_ANIM "ship.druuge.graphics.can.large"
+#define DRUUGE_CANNON_MED_MASK_PMAP_ANIM "ship.druuge.graphics.can.medium"
+#define DRUUGE_CANNON_SML_MASK_PMAP_ANIM "ship.druuge.graphics.can.small"
+#define DRUUGE_CAPT_MASK_PMAP_ANIM "ship.druuge.graphics.captain"
+#define DRUUGE_ICON_MASK_PMAP_ANIM "ship.druuge.icons"
+#define DRUUGE_MED_MASK_PMAP_ANIM "ship.druuge.graphics.druuge.medium"
+#define DRUUGE_MICON_MASK_PMAP_ANIM "ship.druuge.meleeicons"
+#define DRUUGE_SML_MASK_PMAP_ANIM "ship.druuge.graphics.druuge.small"
diff -ruNp src.orig/sc2code/ships/druuge/imusicre.h src/sc2code/ships/druuge/imusicre.h
--- src.orig/sc2code/ships/druuge/imusicre.h	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/druuge/imusicre.h	2017-11-08 16:50:04 -0600
@@ -1,3 +1,5 @@
-#define DRUUGE_VICTORY_SONG 0x00400006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define DRUUGE_VICTORY_SONG "ship.druuge.ditty"
diff -ruNp src.orig/sc2code/ships/druuge/isndres.h src/sc2code/ships/druuge/isndres.h
--- src.orig/sc2code/ships/druuge/isndres.h	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/druuge/isndres.h	2017-11-08 16:50:04 -0600
@@ -1,3 +1,5 @@
-#define DRUUGE_SHIP_SOUNDS 0x00400005L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define DRUUGE_SHIP_SOUNDS "ship.druuge.sounds"
diff -ruNp src.orig/sc2code/ships/druuge/istrtab.h src/sc2code/ships/druuge/istrtab.h
--- src.orig/sc2code/ships/druuge/istrtab.h	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/druuge/istrtab.h	2017-11-08 16:50:04 -0600
@@ -1,3 +1,5 @@
-#define DRUUGE_RACE_STRINGS 0x00200004L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define DRUUGE_RACE_STRINGS "ship.druuge.text"
diff -ruNp src.orig/sc2code/ships/human/human.c src/sc2code/ships/human/human.c
--- src.orig/sc2code/ships/human/human.c	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/human/human.c	2017-11-08 16:50:05 -0600
@@ -43,18 +43,21 @@
 
 static RACE_DESC human_desc =
 {
-	{
+	{ /* SHIP_INFO */
 		FIRES_FORE | SEEKING_WEAPON | POINT_DEFENSE,
 		11, /* Super Melee cost */
-		0 / SPHERE_RADIUS_INCREMENT, /* Initial sphere of influence radius */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY, MAX_ENERGY,
-		{
+		HUMAN_RACE_STRINGS,
+		HUMAN_ICON_MASK_PMAP_ANIM,
+		HUMAN_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
 			1752, 1450,
 		},
-		(STRING)HUMAN_RACE_STRINGS,
-		(FRAME)HUMAN_ICON_MASK_PMAP_ANIM,
-		(FRAME)HUMAN_MICON_MASK_PMAP_ANIM,
 	},
 	{
 		MAX_THRUST,
@@ -71,34 +74,35 @@ static RACE_DESC human_desc =
 	},
 	{
 		{
-			(FRAME)HUMAN_BIG_MASK_PMAP_ANIM,
-			(FRAME)HUMAN_MED_MASK_PMAP_ANIM,
-			(FRAME)HUMAN_SML_MASK_PMAP_ANIM,
+			HUMAN_BIG_MASK_PMAP_ANIM,
+			HUMAN_MED_MASK_PMAP_ANIM,
+			HUMAN_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)SATURN_BIG_MASK_PMAP_ANIM,
-			(FRAME)SATURN_MED_MASK_PMAP_ANIM,
-			(FRAME)SATURN_SML_MASK_PMAP_ANIM,
+			SATURN_BIG_MASK_PMAP_ANIM,
+			SATURN_MED_MASK_PMAP_ANIM,
+			SATURN_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
 		},
 		{
-			(FRAME)HUMAN_CAPTAIN_MASK_PMAP_ANIM,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			HUMAN_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
 		},
-		(SOUND)HUMAN_VICTORY_SONG,
-		(SOUND)HUMAN_SHIP_SOUNDS,
+		HUMAN_VICTORY_SONG,
+		HUMAN_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
 	},
 	{
 		0,
 		LONG_RANGE_WEAPON,
-		NULL_PTR,
+		NULL,
 	},
 	(UNINIT_FUNC *) NULL,
 	(PREPROCESS_FUNC *) NULL,
@@ -112,7 +116,7 @@ static RACE_DESC human_desc =
 #define TRACK_WAIT 3
 
 static void
-nuke_preprocess (PELEMENT ElementPtr)
+nuke_preprocess (ELEMENT *ElementPtr)
 {
 	COUNT facing;
 
@@ -146,9 +150,9 @@ nuke_preprocess (PELEMENT ElementPtr)
 }
 
 static void
-spawn_point_defense (PELEMENT ElementPtr)
+spawn_point_defense (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (ElementPtr->state_flags & PLAYER_SHIP)
@@ -158,7 +162,7 @@ spawn_point_defense (PELEMENT ElementPtr
 		hDefense = AllocElement ();
 		if (hDefense)
 		{
-			ELEMENTPTR DefensePtr;
+			ELEMENT *DefensePtr;
 
 			LockElement (hDefense, &DefensePtr);
 			DefensePtr->state_flags = APPEARING | NONSOLID | FINITE_LIFE |
@@ -177,14 +181,14 @@ spawn_point_defense (PELEMENT ElementPtr
 	{
 		BOOLEAN PaidFor;
 		HELEMENT hObject, hNextObject;
-		ELEMENTPTR ShipPtr;
+		ELEMENT *ShipPtr;
 
 		PaidFor = FALSE;
 
 		LockElement (StarShipPtr->hShip, &ShipPtr);
 		for (hObject = GetTailElement (); hObject; hObject = hNextObject)
 		{
-			ELEMENTPTR ObjectPtr;
+			ELEMENT *ObjectPtr;
 
 			LockElement (hObject, &ObjectPtr);
 			hNextObject = GetPredElement (ObjectPtr);
@@ -240,7 +244,7 @@ spawn_point_defense (PELEMENT ElementPtr
 					hPointDefense = initialize_laser (&LaserBlock);
 					if (hPointDefense)
 					{
-						ELEMENTPTR PDPtr;
+						ELEMENT *PDPtr;
 
 						LockElement (hPointDefense, &PDPtr);
 						SetElementStarShip (PDPtr, StarShipPtr);
@@ -258,13 +262,13 @@ spawn_point_defense (PELEMENT ElementPtr
 }
 
 static COUNT
-initialize_nuke (PELEMENT ShipPtr, HELEMENT NukeArray[])
+initialize_nuke (ELEMENT *ShipPtr, HELEMENT NukeArray[])
 {
 #define HUMAN_OFFSET 42
 #define MISSILE_DAMAGE 4
 #define MISSILE_HITS 1
 #define NUKE_OFFSET 8
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
@@ -284,7 +288,7 @@ initialize_nuke (PELEMENT ShipPtr, HELEM
 
 	if (NukeArray[0])
 	{
-		ELEMENTPTR NukePtr;
+		ELEMENT *NukePtr;
 
 		LockElement (NukeArray[0], &NukePtr);
 		NukePtr->turn_wait = TRACK_WAIT;
@@ -295,20 +299,21 @@ initialize_nuke (PELEMENT ShipPtr, HELEM
 }
 
 static void
-human_intelligence (PELEMENT ShipPtr, PEVALUATE_DESC ObjectsOfConcern, COUNT ConcernCounter)
+human_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+		COUNT ConcernCounter)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	if (StarShipPtr->special_counter == 0
-			&& ((ObjectsOfConcern[ENEMY_WEAPON_INDEX].ObjectPtr != NULL_PTR
+			&& ((ObjectsOfConcern[ENEMY_WEAPON_INDEX].ObjectPtr != NULL
 			&& ObjectsOfConcern[ENEMY_WEAPON_INDEX].which_turn <= 2)
-			|| (ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr != NULL_PTR
+			|| (ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr != NULL
 			&& ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn <= 4)))
 		StarShipPtr->ship_input_state |= SPECIAL;
 	else
 		StarShipPtr->ship_input_state &= ~SPECIAL;
-	ObjectsOfConcern[ENEMY_WEAPON_INDEX].ObjectPtr = NULL_PTR;
+	ObjectsOfConcern[ENEMY_WEAPON_INDEX].ObjectPtr = NULL;
 
 	ship_intelligence (ShipPtr,
 			ObjectsOfConcern, ConcernCounter);
@@ -323,9 +328,9 @@ human_intelligence (PELEMENT ShipPtr, PE
 }
 
 static void
-human_postprocess (PELEMENT ElementPtr)
+human_postprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if ((StarShipPtr->cur_status_flags & SPECIAL)
@@ -335,16 +340,14 @@ human_postprocess (PELEMENT ElementPtr)
 	}
 }
 
-RACE_DESCPTR
+RACE_DESC*
 init_human (void)
 {
-	RACE_DESCPTR RaceDescPtr;
+	RACE_DESC *RaceDescPtr;
 
 	human_desc.postprocess_func = human_postprocess;
 	human_desc.init_weapon_func = initialize_nuke;
-	human_desc.cyborg_control.intelligence_func =
-			(void (*) (PVOID ShipPtr, PVOID ObjectsOfConcern, COUNT
-					ConcernCounter)) human_intelligence;
+	human_desc.cyborg_control.intelligence_func = human_intelligence;
 
 	RaceDescPtr = &human_desc;
 
diff -ruNp src.orig/sc2code/ships/human/icode.h src/sc2code/ships/human/icode.h
--- src.orig/sc2code/ships/human/icode.h	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/human/icode.h	2017-11-08 16:50:05 -0600
@@ -1,3 +1,5 @@
-#define HUMAN_CODE 0x00200008L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define HUMAN_CODE "ship.earthling.code"
diff -ruNp src.orig/sc2code/ships/human/igfxres.h src/sc2code/ships/human/igfxres.h
--- src.orig/sc2code/ships/human/igfxres.h	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/human/igfxres.h	2017-11-08 16:50:05 -0600
@@ -1,11 +1,13 @@
-#define HUMAN_ICON_MASK_PMAP_ANIM 0x00200002L
-#define HUMAN_MICON_MASK_PMAP_ANIM 0x00200102L
-#define HUMAN_BIG_MASK_PMAP_ANIM 0x00400202L
-#define HUMAN_MED_MASK_PMAP_ANIM 0x00400302L
-#define HUMAN_SML_MASK_PMAP_ANIM 0x00400402L
-#define SATURN_BIG_MASK_PMAP_ANIM 0x00400502L
-#define SATURN_MED_MASK_PMAP_ANIM 0x00400602L
-#define SATURN_SML_MASK_PMAP_ANIM 0x00400702L
-#define HUMAN_CAPTAIN_MASK_PMAP_ANIM 0x00400802L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define HUMAN_BIG_MASK_PMAP_ANIM "ship.earthling.graphics.human.large"
+#define HUMAN_CAPTAIN_MASK_PMAP_ANIM "ship.earthling.graphics.captain"
+#define HUMAN_ICON_MASK_PMAP_ANIM "ship.earthling.icons"
+#define HUMAN_MED_MASK_PMAP_ANIM "ship.earthling.graphics.human.medium"
+#define HUMAN_MICON_MASK_PMAP_ANIM "ship.earthling.meleeicons"
+#define HUMAN_SML_MASK_PMAP_ANIM "ship.earthling.graphics.human.small"
+#define SATURN_BIG_MASK_PMAP_ANIM "ship.earthling.graphics.saturn.large"
+#define SATURN_MED_MASK_PMAP_ANIM "ship.earthling.graphics.saturn.medium"
+#define SATURN_SML_MASK_PMAP_ANIM "ship.earthling.graphics.saturn.small"
diff -ruNp src.orig/sc2code/ships/human/imusicre.h src/sc2code/ships/human/imusicre.h
--- src.orig/sc2code/ships/human/imusicre.h	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/human/imusicre.h	2017-11-08 16:50:05 -0600
@@ -1,3 +1,5 @@
-#define HUMAN_VICTORY_SONG 0x00400006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define HUMAN_VICTORY_SONG "ship.earthling.ditty"
diff -ruNp src.orig/sc2code/ships/human/isndres.h src/sc2code/ships/human/isndres.h
--- src.orig/sc2code/ships/human/isndres.h	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/human/isndres.h	2017-11-08 16:50:05 -0600
@@ -1,3 +1,5 @@
-#define HUMAN_SHIP_SOUNDS 0x00400005L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define HUMAN_SHIP_SOUNDS "ship.earthling.sounds"
diff -ruNp src.orig/sc2code/ships/human/istrtab.h src/sc2code/ships/human/istrtab.h
--- src.orig/sc2code/ships/human/istrtab.h	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/human/istrtab.h	2017-11-08 16:50:05 -0600
@@ -1,3 +1,5 @@
-#define HUMAN_RACE_STRINGS 0x00200004L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define HUMAN_RACE_STRINGS "ship.earthling.text"
diff -ruNp src.orig/sc2code/ships/ilwrath/icode.h src/sc2code/ships/ilwrath/icode.h
--- src.orig/sc2code/ships/ilwrath/icode.h	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/ilwrath/icode.h	2017-11-08 16:50:05 -0600
@@ -1,3 +1,5 @@
-#define ILWRATH_CODE 0x00200008L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ILWRATH_CODE "ship.ilwrath.code"
diff -ruNp src.orig/sc2code/ships/ilwrath/igfxres.h src/sc2code/ships/ilwrath/igfxres.h
--- src.orig/sc2code/ships/ilwrath/igfxres.h	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/ilwrath/igfxres.h	2017-11-08 16:50:05 -0600
@@ -1,11 +1,13 @@
-#define ILWRATH_ICON_MASK_PMAP_ANIM 0x00200002L
-#define ILWRATH_MICON_MASK_PMAP_ANIM 0x00200102L
-#define ILWRATH_BIG_MASK_PMAP_ANIM 0x00400202L
-#define ILWRATH_MED_MASK_PMAP_ANIM 0x00400302L
-#define ILWRATH_SML_MASK_PMAP_ANIM 0x00400402L
-#define FIRE_BIG_MASK_PMAP_ANIM 0x00400502L
-#define FIRE_MED_MASK_PMAP_ANIM 0x00400602L
-#define FIRE_SML_MASK_PMAP_ANIM 0x00400702L
-#define ILWRATH_CAPTAIN_MASK_PMAP_ANIM 0x00400802L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define FIRE_BIG_MASK_PMAP_ANIM "ship.ilwrath.graphics.fire.large"
+#define FIRE_MED_MASK_PMAP_ANIM "ship.ilwrath.graphics.fire.medium"
+#define FIRE_SML_MASK_PMAP_ANIM "ship.ilwrath.graphics.fire.small"
+#define ILWRATH_BIG_MASK_PMAP_ANIM "ship.ilwrath.graphics.ilwrath.large"
+#define ILWRATH_CAPTAIN_MASK_PMAP_ANIM "ship.ilwrath.graphics.captain"
+#define ILWRATH_ICON_MASK_PMAP_ANIM "ship.ilwrath.icons"
+#define ILWRATH_MED_MASK_PMAP_ANIM "ship.ilwrath.graphics.ilwrath.medium"
+#define ILWRATH_MICON_MASK_PMAP_ANIM "ship.ilwrath.meleeicons"
+#define ILWRATH_SML_MASK_PMAP_ANIM "ship.ilwrath.graphics.ilwrath.small"
diff -ruNp src.orig/sc2code/ships/ilwrath/ilwrath.c src/sc2code/ships/ilwrath/ilwrath.c
--- src.orig/sc2code/ships/ilwrath/ilwrath.c	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/ilwrath/ilwrath.c	2017-11-08 16:50:05 -0600
@@ -41,18 +41,21 @@
 
 static RACE_DESC ilwrath_desc =
 {
-	{
+	{ /* SHIP_INFO */
 		FIRES_FORE,
 		10, /* Super Melee cost */
-		1410 / SPHERE_RADIUS_INCREMENT, /* Initial sphere of influence radius */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY, MAX_ENERGY,
-		{
+		ILWRATH_RACE_STRINGS,
+		ILWRATH_ICON_MASK_PMAP_ANIM,
+		ILWRATH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		1410 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
 			48, 1700,
 		},
-		(STRING)ILWRATH_RACE_STRINGS,
-		(FRAME)ILWRATH_ICON_MASK_PMAP_ANIM,
-		(FRAME)ILWRATH_MICON_MASK_PMAP_ANIM,
 	},
 	{
 		MAX_THRUST,
@@ -69,34 +72,35 @@ static RACE_DESC ilwrath_desc =
 	},
 	{
 		{
-			(FRAME)ILWRATH_BIG_MASK_PMAP_ANIM,
-			(FRAME)ILWRATH_MED_MASK_PMAP_ANIM,
-			(FRAME)ILWRATH_SML_MASK_PMAP_ANIM,
+			ILWRATH_BIG_MASK_PMAP_ANIM,
+			ILWRATH_MED_MASK_PMAP_ANIM,
+			ILWRATH_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)FIRE_BIG_MASK_PMAP_ANIM,
-			(FRAME)FIRE_MED_MASK_PMAP_ANIM,
-			(FRAME)FIRE_SML_MASK_PMAP_ANIM,
+			FIRE_BIG_MASK_PMAP_ANIM,
+			FIRE_MED_MASK_PMAP_ANIM,
+			FIRE_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
 		},
 		{
-			(FRAME)ILWRATH_CAPTAIN_MASK_PMAP_ANIM,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			ILWRATH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
 		},
-		(SOUND)ILWRATH_VICTORY_SONG,
-		(SOUND)ILWRATH_SHIP_SOUNDS,
+		ILWRATH_VICTORY_SONG,
+		ILWRATH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
 	},
 	{
 		0,
 		CLOSE_RANGE_WEAPON,
-		NULL_PTR,
+		NULL,
 	},
 	(UNINIT_FUNC *) NULL,
 	(PREPROCESS_FUNC *) NULL,
@@ -106,7 +110,7 @@ static RACE_DESC ilwrath_desc =
 };
 
 static void
-flame_preprocess (PELEMENT ElementPtr)
+flame_preprocess (ELEMENT *ElementPtr)
 {
 	if (ElementPtr->turn_wait > 0)
 		--ElementPtr->turn_wait;
@@ -121,7 +125,8 @@ flame_preprocess (PELEMENT ElementPtr)
 }
 
 static void
-flame_collision (PELEMENT ElementPtr0, PPOINT pPt0, PELEMENT ElementPtr1, PPOINT pPt1)
+flame_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
 	weapon_collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
 	ElementPtr0->state_flags &= ~DISAPPEARING;
@@ -129,10 +134,11 @@ flame_collision (PELEMENT ElementPtr0, P
 }
 
 static void
-ilwrath_intelligence (PELEMENT ShipPtr, PEVALUATE_DESC ObjectsOfConcern, COUNT ConcernCounter)
+ilwrath_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+		COUNT ConcernCounter)
 {
-	PEVALUATE_DESC lpEvalDesc;
-	STARSHIPPTR StarShipPtr;
+	EVALUATE_DESC *lpEvalDesc;
+	STARSHIP *StarShipPtr;
 
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
 	 lpEvalDesc->MoveState = PURSUE;
@@ -168,14 +174,14 @@ ilwrath_intelligence (PELEMENT ShipPtr,
 }
 
 static COUNT
-initialize_flame (PELEMENT ShipPtr, HELEMENT FlameArray[])
+initialize_flame (ELEMENT *ShipPtr, HELEMENT FlameArray[])
 {
 #define ILWRATH_OFFSET 29
 #define MISSILE_SPEED MAX_THRUST
 #define MISSILE_HITS 1
 #define MISSILE_DAMAGE 1
 #define MISSILE_OFFSET 0
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
@@ -198,7 +204,7 @@ initialize_flame (PELEMENT ShipPtr, HELE
 	if (FlameArray[0])
 	{
 		SIZE dx, dy;
-		ELEMENTPTR FlamePtr;
+		ELEMENT *FlamePtr;
 
 		LockElement (FlameArray[0], &FlamePtr);
 		GetCurrentVelocityComponents (&ShipPtr->velocity, &dx, &dy);
@@ -215,11 +221,11 @@ initialize_flame (PELEMENT ShipPtr, HELE
 }
 
 static void
-ilwrath_preprocess (PELEMENT ElementPtr)
+ilwrath_preprocess (ELEMENT *ElementPtr)
 {
-	ELEMENT_FLAGS status_flags;
-	STARSHIPPTR StarShipPtr;
-	PPRIMITIVE lpPrim;
+	STATUS_FLAGS status_flags;
+	STARSHIP *StarShipPtr;
+	PRIMITIVE *lpPrim;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	status_flags = StarShipPtr->cur_status_flags;
@@ -261,7 +267,7 @@ ilwrath_preprocess (PELEMENT ElementPtr)
 					if (TrackShip (ElementPtr, &facing) >= 0)
 					{
 #define LOOK_AHEAD 4
-						ELEMENTPTR eptr;
+						ELEMENT *eptr;
 						SIZE dx0, dy0, dx1, dy1;
 						VELOCITY_DESC v;
 
@@ -359,16 +365,14 @@ ilwrath_preprocess (PELEMENT ElementPtr)
 	}
 }
 
-RACE_DESCPTR
+RACE_DESC*
 init_ilwrath (void)
 {
-	RACE_DESCPTR RaceDescPtr;
+	RACE_DESC *RaceDescPtr;
 
 	ilwrath_desc.preprocess_func = ilwrath_preprocess;
 	ilwrath_desc.init_weapon_func = initialize_flame;
-	ilwrath_desc.cyborg_control.intelligence_func =
-			(void (*) (PVOID ShipPtr, PVOID ObjectsOfConcern, COUNT
-					ConcernCounter)) ilwrath_intelligence;
+	ilwrath_desc.cyborg_control.intelligence_func = ilwrath_intelligence;
 
 	RaceDescPtr = &ilwrath_desc;
 
diff -ruNp src.orig/sc2code/ships/ilwrath/imusicre.h src/sc2code/ships/ilwrath/imusicre.h
--- src.orig/sc2code/ships/ilwrath/imusicre.h	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/ilwrath/imusicre.h	2017-11-08 16:50:05 -0600
@@ -1,3 +1,5 @@
-#define ILWRATH_VICTORY_SONG 0x00400006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ILWRATH_VICTORY_SONG "ship.ilwrath.ditty"
diff -ruNp src.orig/sc2code/ships/ilwrath/isndres.h src/sc2code/ships/ilwrath/isndres.h
--- src.orig/sc2code/ships/ilwrath/isndres.h	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/ilwrath/isndres.h	2017-11-08 16:50:05 -0600
@@ -1,3 +1,5 @@
-#define ILWRATH_SHIP_SOUNDS 0x00400005L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ILWRATH_SHIP_SOUNDS "ship.ilwrath.sounds"
diff -ruNp src.orig/sc2code/ships/ilwrath/istrtab.h src/sc2code/ships/ilwrath/istrtab.h
--- src.orig/sc2code/ships/ilwrath/istrtab.h	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/ilwrath/istrtab.h	2017-11-08 16:50:05 -0600
@@ -1,3 +1,5 @@
-#define ILWRATH_RACE_STRINGS 0x00200004L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ILWRATH_RACE_STRINGS "ship.ilwrath.text"
diff -ruNp src.orig/sc2code/ships/lastbat/icode.h src/sc2code/ships/lastbat/icode.h
--- src.orig/sc2code/ships/lastbat/icode.h	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/lastbat/icode.h	2017-11-08 16:50:05 -0600
@@ -1,3 +1,5 @@
-#define SAMATRA_CODE 0x00200008L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SAMATRA_CODE "ship.lastbat.code"
diff -ruNp src.orig/sc2code/ships/lastbat/igfxres.h src/sc2code/ships/lastbat/igfxres.h
--- src.orig/sc2code/ships/lastbat/igfxres.h	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/lastbat/igfxres.h	2017-11-08 16:50:05 -0600
@@ -1,12 +1,14 @@
-#define SAMATRA_BIG_MASK_ANIM 0x00400002L
-#define SAMATRA_MED_MASK_PMAP_ANIM 0x00400102L
-#define SAMATRA_SML_MASK_PMAP_ANIM 0x00400202L
-#define SENTINEL_BIG_MASK_ANIM 0x00400302L
-#define SENTINEL_MED_MASK_PMAP_ANIM 0x00400402L
-#define SENTINEL_SML_MASK_PMAP_ANIM 0x00400502L
-#define GENERATOR_BIG_MASK_ANIM 0x00400602L
-#define GENERATOR_MED_MASK_PMAP_ANIM 0x00400702L
-#define GENERATOR_SML_MASK_PMAP_ANIM 0x00400802L
-#define SAMATRA_CAPTAIN_MASK_PMAP_ANIM 0x00600902L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define GENERATOR_BIG_MASK_ANIM "ship.lastbat.graphics.gen.large"
+#define GENERATOR_MED_MASK_PMAP_ANIM "ship.lastbat.graphics.gen.medium"
+#define GENERATOR_SML_MASK_PMAP_ANIM "ship.lastbat.graphics.gen.small"
+#define SAMATRA_BIG_MASK_ANIM "ship.lastbat.graphics.lastbat.large"
+#define SAMATRA_CAPTAIN_MASK_PMAP_ANIM "ship.lastbat.graphics.captain"
+#define SAMATRA_MED_MASK_PMAP_ANIM "ship.lastbat.graphics.lastbat.medium"
+#define SAMATRA_SML_MASK_PMAP_ANIM "ship.lastbat.graphics.lastbat.small"
+#define SENTINEL_BIG_MASK_ANIM "ship.lastbat.graphics.sen.large"
+#define SENTINEL_MED_MASK_PMAP_ANIM "ship.lastbat.graphics.sen.medium"
+#define SENTINEL_SML_MASK_PMAP_ANIM "ship.lastbat.graphics.sen.small"
diff -ruNp src.orig/sc2code/ships/lastbat/imusicre.h src/sc2code/ships/lastbat/imusicre.h
--- src.orig/sc2code/ships/lastbat/imusicre.h	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/lastbat/imusicre.h	2017-11-08 16:50:05 -0600
@@ -1,3 +1,5 @@
-#define SAMATRA_VICTORY_SONG 0x00400005L
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
-typedef RESOURCE MUSICRES_INSTANCE;
+#define SAMATRA_VICTORY_SONG "ship.lastbat.ditty"
diff -ruNp src.orig/sc2code/ships/lastbat/isndres.h src/sc2code/ships/lastbat/isndres.h
--- src.orig/sc2code/ships/lastbat/isndres.h	2017-11-08 16:49:37 -0600
+++ src/sc2code/ships/lastbat/isndres.h	2017-11-08 16:50:05 -0600
@@ -1,3 +1,5 @@
-#define SAMATRA_SHIP_SOUNDS 0x00400005L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SAMATRA_SHIP_SOUNDS "ship.lastbat.sounds"
diff -ruNp src.orig/sc2code/ships/lastbat/istrtab.h src/sc2code/ships/lastbat/istrtab.h
--- src.orig/sc2code/ships/lastbat/istrtab.h	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/lastbat/istrtab.h	2017-11-08 16:50:05 -0600
@@ -1,3 +1,3 @@
-#define SAMATRA_SHIP_SOUNDS 0x00400004L
+// Dead file
 
 
diff -ruNp src.orig/sc2code/ships/lastbat/lastbat.c src/sc2code/ships/lastbat/lastbat.c
--- src.orig/sc2code/ships/lastbat/lastbat.c	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/lastbat/lastbat.c	2017-11-08 16:50:05 -0600
@@ -46,18 +46,21 @@
 
 static RACE_DESC samatra_desc =
 {
-	{
+	{ /* SHIP_INFO */
 		/* FIRES_FORE | */ IMMEDIATE_WEAPON | CREW_IMMUNE,
 		16, /* Super Melee cost */
-		0, /* Initial sphere of influence radius */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY, MAX_ENERGY,
-		{
+		NULL_RESOURCE,
+		NULL_RESOURCE,
+		NULL_RESOURCE,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
 			0, 0,
 		},
-		(STRING)0,
-		(FRAME)0,
-		(FRAME)0,
 	},
 	{
 		MAX_THRUST,
@@ -74,34 +77,35 @@ static RACE_DESC samatra_desc =
 	},
 	{
 		{
-			(FRAME)SAMATRA_BIG_MASK_ANIM,
-			(FRAME)SAMATRA_MED_MASK_PMAP_ANIM,
-			(FRAME)SAMATRA_SML_MASK_PMAP_ANIM,
+			SAMATRA_BIG_MASK_ANIM,
+			SAMATRA_MED_MASK_PMAP_ANIM,
+			SAMATRA_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)SENTINEL_BIG_MASK_ANIM,
-			(FRAME)SENTINEL_MED_MASK_PMAP_ANIM,
-			(FRAME)SENTINEL_SML_MASK_PMAP_ANIM,
+			SENTINEL_BIG_MASK_ANIM,
+			SENTINEL_MED_MASK_PMAP_ANIM,
+			SENTINEL_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)GENERATOR_BIG_MASK_ANIM,
-			(FRAME)GENERATOR_MED_MASK_PMAP_ANIM,
-			(FRAME)GENERATOR_SML_MASK_PMAP_ANIM,
+			GENERATOR_BIG_MASK_ANIM,
+			GENERATOR_MED_MASK_PMAP_ANIM,
+			GENERATOR_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)SAMATRA_CAPTAIN_MASK_PMAP_ANIM,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			SAMATRA_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
 		},
-		0,
-		(SOUND)SAMATRA_SHIP_SOUNDS,
+		NULL_RESOURCE,
+		SAMATRA_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
 	},
 	{
 		0,
 		0,
-		NULL_PTR,
+		NULL,
 	},
 	(UNINIT_FUNC *) NULL,
 	(PREPROCESS_FUNC *) NULL,
@@ -110,10 +114,10 @@ static RACE_DESC samatra_desc =
 	0,
 };
 
-static HELEMENT spawn_comet (PELEMENT ElementPtr);
+static HELEMENT spawn_comet (ELEMENT *ElementPtr);
 
 static void
-comet_preprocess (PELEMENT ElementPtr)
+comet_preprocess (ELEMENT *ElementPtr)
 {
 	COUNT frame_index;
 
@@ -123,7 +127,7 @@ comet_preprocess (PELEMENT ElementPtr)
 		if (frame_index == 25)
 		{
 			SIZE cur_delta_x, cur_delta_y;
-			STARSHIPPTR StarShipPtr;
+			STARSHIP *StarShipPtr;
 
 			GetElementStarShip (ElementPtr, &StarShipPtr);
 			++StarShipPtr->RaceDescPtr->characteristics.weapon_wait;
@@ -148,7 +152,8 @@ comet_preprocess (PELEMENT ElementPtr)
 #define COMET_DAMAGE 2
 
 static void
-comet_collision (PELEMENT ElementPtr0, PPOINT pPt0, PELEMENT ElementPtr1, PPOINT pPt1)
+comet_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
 	if (ElementPtr1->state_flags & GOOD_GUY)
 	{
@@ -179,7 +184,7 @@ comet_collision (PELEMENT ElementPtr0, P
 
 		if (ElementPtr0->state_flags & DISAPPEARING)
 		{
-			STARSHIPPTR StarShipPtr;
+			STARSHIP *StarShipPtr;
 
 			GetElementStarShip (ElementPtr0, &StarShipPtr);
 			--StarShipPtr->RaceDescPtr->characteristics.weapon_wait;
@@ -188,7 +193,7 @@ comet_collision (PELEMENT ElementPtr0, P
 }
 
 static HELEMENT
-spawn_comet (PELEMENT ElementPtr)
+spawn_comet (ELEMENT *ElementPtr)
 {
 #define COMET_OFFSET 0
 #define COMET_HITS 12
@@ -196,7 +201,7 @@ spawn_comet (PELEMENT ElementPtr)
 #define COMET_LIFE 2
 	MISSILE_BLOCK MissileBlock;
 	HELEMENT hComet;
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	MissileBlock.cx = ElementPtr->next.location.x;
@@ -216,7 +221,7 @@ spawn_comet (PELEMENT ElementPtr)
 
 	if (hComet)
 	{
-		ELEMENTPTR CometPtr;
+		ELEMENT *CometPtr;
 
 		PutElement (hComet);
 
@@ -263,7 +268,7 @@ spawn_comet (PELEMENT ElementPtr)
 }
 
 static void
-turret_preprocess (PELEMENT ElementPtr)
+turret_preprocess (ELEMENT *ElementPtr)
 {
 	if (ElementPtr->turn_wait > 0)
 		--ElementPtr->turn_wait;
@@ -283,11 +288,12 @@ turret_preprocess (PELEMENT ElementPtr)
 #define GATE_HITS 100
 
 static void
-gate_collision (PELEMENT ElementPtr0, PPOINT pPt0, PELEMENT ElementPtr1, PPOINT pPt1)
+gate_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
 	if (ElementPtr1->state_flags & GOOD_GUY)
 	{
-		STARSHIPPTR StarShipPtr;
+		STARSHIP *StarShipPtr;
 
 		GetElementStarShip (ElementPtr0, &StarShipPtr);
 		if (StarShipPtr->RaceDescPtr->num_generators == 0)
@@ -328,9 +334,9 @@ gate_collision (PELEMENT ElementPtr0, PP
 }
 
 static void
-gate_preprocess (PELEMENT ElementPtr)
+gate_preprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (StarShipPtr->RaceDescPtr->num_generators == 0)
@@ -364,11 +370,11 @@ gate_preprocess (PELEMENT ElementPtr)
 }
 
 static void
-generator_death (PELEMENT ElementPtr)
+generator_death (ELEMENT *ElementPtr)
 {
 	if (!(ElementPtr->state_flags & FINITE_LIFE))
 	{
-		STARSHIPPTR StarShipPtr;
+		STARSHIP *StarShipPtr;
 
 		GetElementStarShip (ElementPtr, &StarShipPtr);
 		--StarShipPtr->RaceDescPtr->num_generators;
@@ -405,7 +411,7 @@ generator_death (PELEMENT ElementPtr)
 #define GENERATOR_HITS 15
 
 static void
-generator_preprocess (PELEMENT ElementPtr)
+generator_preprocess (ELEMENT *ElementPtr)
 {
 	if (ElementPtr->turn_wait > 0)
 		--ElementPtr->turn_wait;
@@ -421,8 +427,8 @@ generator_preprocess (PELEMENT ElementPt
 }
 
 static void
-generator_collision (PELEMENT ElementPtr0, PPOINT pPt0,
-		PELEMENT ElementPtr1, PPOINT pPt1)
+generator_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
 	if (!(ElementPtr1->state_flags & FINITE_LIFE))
 	{
@@ -435,9 +441,9 @@ generator_collision (PELEMENT ElementPtr
 #define TRACK_WAIT 1
 
 static void
-sentinel_preprocess (PELEMENT ElementPtr)
+sentinel_preprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	++StarShipPtr->RaceDescPtr->characteristics.special_wait;
@@ -490,7 +496,8 @@ sentinel_preprocess (PELEMENT ElementPtr
 		else
 		{
 			SIZE delta_x0, delta_y0, delta_x1, delta_y1;
-			ELEMENTPTR ShipPtr, EnemyShipPtr;
+			ELEMENT *ShipPtr;
+			ELEMENT *EnemyShipPtr;
 
 			LockElement (ElementPtr->hTarget, &EnemyShipPtr);
 
@@ -521,7 +528,7 @@ sentinel_preprocess (PELEMENT ElementPtr
 		{
 			COUNT num_frames;
 			SIZE delta_x, delta_y;
-			ELEMENTPTR TargetPtr;
+			ELEMENT *TargetPtr;
 			VELOCITY_DESC TargetVelocity;
 
 			LockElement (hTarget, &TargetPtr);
@@ -576,10 +583,11 @@ sentinel_preprocess (PELEMENT ElementPtr
 #define MAX_RECOIL_VELOCITY (RECOIL_VELOCITY * 4)
 
 static void
-sentinel_collision (PELEMENT ElementPtr0, PPOINT pPt0, PELEMENT ElementPtr1, PPOINT pPt1)
+sentinel_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
 	COUNT angle;
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	if (ElementPtr1->state_flags & BAD_GUY)
 	{
@@ -654,7 +662,7 @@ sentinel_collision (PELEMENT ElementPtr0
 			--StarShipPtr->RaceDescPtr->characteristics.special_wait;
 			if (hBlastElement)
 			{
-				ELEMENTPTR BlastElementPtr;
+				ELEMENT *BlastElementPtr;
 
 				LockElement (hBlastElement, &BlastElementPtr);
 				BlastElementPtr->life_span = 6;
@@ -669,7 +677,8 @@ sentinel_collision (PELEMENT ElementPtr0
 }
 
 static void
-samatra_intelligence (PELEMENT ShipPtr, PEVALUATE_DESC ObjectsOfConcern, COUNT ConcernCounter)
+samatra_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+		COUNT ConcernCounter)
 {
 	ship_intelligence (ShipPtr, ObjectsOfConcern, ConcernCounter);
 }
@@ -678,9 +687,9 @@ samatra_intelligence (PELEMENT ShipPtr,
 #define MAX_SENTINELS 4
 
 static void
-samatra_postprocess (PELEMENT ElementPtr)
+samatra_postprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (StarShipPtr->RaceDescPtr->num_generators)
@@ -719,7 +728,7 @@ samatra_postprocess (PELEMENT ElementPtr
 
 			if (hSentinel)
 			{
-				ELEMENTPTR SentinelPtr;
+				ELEMENT *SentinelPtr;
 
 				LockElement (hSentinel, &SentinelPtr);
 				SentinelPtr->collision_func = sentinel_collision;
@@ -736,9 +745,9 @@ samatra_postprocess (PELEMENT ElementPtr
 }
 
 static void
-samatra_preprocess (PELEMENT ElementPtr)
+samatra_preprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	StarShipPtr->RaceDescPtr->characteristics.weapon_wait = 0;
@@ -772,7 +781,7 @@ samatra_preprocess (PELEMENT ElementPtr)
 			hGenerator = AllocElement ();
 			if (hGenerator)
 			{
-				ELEMENTPTR GeneratorPtr;
+				ELEMENT *GeneratorPtr;
 
 				LockElement (hGenerator, &GeneratorPtr);
 				GeneratorPtr->hit_points = GENERATOR_HITS;
@@ -817,7 +826,7 @@ samatra_preprocess (PELEMENT ElementPtr)
 			hTurret = AllocElement ();
 			if (hTurret)
 			{
-				ELEMENTPTR TurretPtr;
+				ELEMENT *TurretPtr;
 
 				LockElement (hTurret, &TurretPtr);
 				TurretPtr->hit_points = 1;
@@ -852,7 +861,7 @@ samatra_preprocess (PELEMENT ElementPtr)
 			hGate = AllocElement ();
 			if (hGate)
 			{
-				ELEMENTPTR GatePtr;
+				ELEMENT *GatePtr;
 
 				LockElement (hGate, &GatePtr);
 				GatePtr->hit_points = GATE_HITS;
@@ -888,16 +897,14 @@ samatra_preprocess (PELEMENT ElementPtr)
 	}
 }
 
-RACE_DESCPTR
+RACE_DESC*
 init_samatra (void)
 {
-	RACE_DESCPTR RaceDescPtr;
+	RACE_DESC *RaceDescPtr;
 
 	samatra_desc.preprocess_func = samatra_preprocess;
 	samatra_desc.postprocess_func = samatra_postprocess;
-	samatra_desc.cyborg_control.intelligence_func =
-			(void (*) (PVOID ShipPtr, PVOID ObjectsOfConcern, COUNT
-					ConcernCounter)) samatra_intelligence;
+	samatra_desc.cyborg_control.intelligence_func = samatra_intelligence;
 
 	RaceDescPtr = &samatra_desc;
 
diff -ruNp src.orig/sc2code/ships/melnorme/icode.h src/sc2code/ships/melnorme/icode.h
--- src.orig/sc2code/ships/melnorme/icode.h	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/melnorme/icode.h	2017-11-08 16:50:05 -0600
@@ -1,3 +1,5 @@
-#define MELNORME_CODE 0x00200008L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define MELNORME_CODE "ship.melnorme.code"
diff -ruNp src.orig/sc2code/ships/melnorme/igfxres.h src/sc2code/ships/melnorme/igfxres.h
--- src.orig/sc2code/ships/melnorme/igfxres.h	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/melnorme/igfxres.h	2017-11-08 16:50:05 -0600
@@ -1,14 +1,16 @@
-#define MELNORME_ICON_MASK_PMAP_ANIM 0x00200002L
-#define MELNORME_MICON_MASK_PMAP_ANIM 0x00200102L
-#define MELNORME_BIG_MASK_PMAP_ANIM 0x00400202L
-#define MELNORME_MED_MASK_PMAP_ANIM 0x00400302L
-#define MELNORME_SML_MASK_PMAP_ANIM 0x00400402L
-#define PUMPUP_BIG_MASK_PMAP_ANIM 0x00400502L
-#define PUMPUP_MED_MASK_PMAP_ANIM 0x00400602L
-#define PUMPUP_SML_MASK_PMAP_ANIM 0x00400702L
-#define CONFUSE_BIG_MASK_PMAP_ANIM 0x00400802L
-#define CONFUSE_MED_MASK_PMAP_ANIM 0x00400902L
-#define CONFUSE_SML_MASK_PMAP_ANIM 0x00400a02L
-#define MELNORME_CAPTAIN_MASK_PMAP_ANIM 0x00400b02L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define CONFUSE_BIG_MASK_PMAP_ANIM "ship.melnorme.graphics.confu.large"
+#define CONFUSE_MED_MASK_PMAP_ANIM "ship.melnorme.graphics.confu.medium"
+#define CONFUSE_SML_MASK_PMAP_ANIM "ship.melnorme.graphics.confu.small"
+#define MELNORME_BIG_MASK_PMAP_ANIM "ship.melnorme.graphics.melnorme.large"
+#define MELNORME_CAPTAIN_MASK_PMAP_ANIM "ship.melnorme.graphics.captain"
+#define MELNORME_ICON_MASK_PMAP_ANIM "ship.melnorme.icons"
+#define MELNORME_MED_MASK_PMAP_ANIM "ship.melnorme.graphics.melnorme.medium"
+#define MELNORME_MICON_MASK_PMAP_ANIM "ship.melnorme.meleeicons"
+#define MELNORME_SML_MASK_PMAP_ANIM "ship.melnorme.graphics.melnorme.small"
+#define PUMPUP_BIG_MASK_PMAP_ANIM "ship.melnorme.graphics.pump.large"
+#define PUMPUP_MED_MASK_PMAP_ANIM "ship.melnorme.graphics.pump.medium"
+#define PUMPUP_SML_MASK_PMAP_ANIM "ship.melnorme.graphics.pump.small"
diff -ruNp src.orig/sc2code/ships/melnorme/imusicre.h src/sc2code/ships/melnorme/imusicre.h
--- src.orig/sc2code/ships/melnorme/imusicre.h	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/melnorme/imusicre.h	2017-11-08 16:50:05 -0600
@@ -1,3 +1,5 @@
-#define MELNORME_VICTORY_SONG 0x00400006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define MELNORME_VICTORY_SONG "ship.melnorme.ditty"
diff -ruNp src.orig/sc2code/ships/melnorme/isndres.h src/sc2code/ships/melnorme/isndres.h
--- src.orig/sc2code/ships/melnorme/isndres.h	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/melnorme/isndres.h	2017-11-08 16:50:05 -0600
@@ -1,3 +1,5 @@
-#define MELNORME_SHIP_SOUNDS 0x00400005L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define MELNORME_SHIP_SOUNDS "ship.melnorme.sounds"
diff -ruNp src.orig/sc2code/ships/melnorme/istrtab.h src/sc2code/ships/melnorme/istrtab.h
--- src.orig/sc2code/ships/melnorme/istrtab.h	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/melnorme/istrtab.h	2017-11-08 16:50:05 -0600
@@ -1,3 +1,5 @@
-#define MELNORME_RACE_STRINGS 0x00200004L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define MELNORME_RACE_STRINGS "ship.melnorme.text"
diff -ruNp src.orig/sc2code/ships/melnorme/melnorme.c src/sc2code/ships/melnorme/melnorme.c
--- src.orig/sc2code/ships/melnorme/melnorme.c	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/melnorme/melnorme.c	2017-11-08 16:50:05 -0600
@@ -42,18 +42,21 @@
 
 static RACE_DESC melnorme_desc =
 {
-	{
+	{ /* SHIP_INFO */
 		FIRES_FORE,
 		18, /* Super Melee cost */
-		~0, /* Initial sphere of influence radius */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY, MAX_ENERGY,
-		{
+		MELNORME_RACE_STRINGS,
+		MELNORME_ICON_MASK_PMAP_ANIM,
+		MELNORME_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		INFINITE_RADIUS, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
 			MAX_X_UNIVERSE >> 1, MAX_Y_UNIVERSE >> 1,
 		},
-		(STRING)MELNORME_RACE_STRINGS,
-		(FRAME)MELNORME_ICON_MASK_PMAP_ANIM,
-		(FRAME)MELNORME_MICON_MASK_PMAP_ANIM,
 	},
 	{
 		MAX_THRUST,
@@ -70,34 +73,35 @@ static RACE_DESC melnorme_desc =
 	},
 	{
 		{
-			(FRAME)MELNORME_BIG_MASK_PMAP_ANIM,
-			(FRAME)MELNORME_MED_MASK_PMAP_ANIM,
-			(FRAME)MELNORME_SML_MASK_PMAP_ANIM,
+			MELNORME_BIG_MASK_PMAP_ANIM,
+			MELNORME_MED_MASK_PMAP_ANIM,
+			MELNORME_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)PUMPUP_BIG_MASK_PMAP_ANIM,
-			(FRAME)PUMPUP_MED_MASK_PMAP_ANIM,
-			(FRAME)PUMPUP_SML_MASK_PMAP_ANIM,
+			PUMPUP_BIG_MASK_PMAP_ANIM,
+			PUMPUP_MED_MASK_PMAP_ANIM,
+			PUMPUP_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)CONFUSE_BIG_MASK_PMAP_ANIM,
-			(FRAME)CONFUSE_MED_MASK_PMAP_ANIM,
-			(FRAME)CONFUSE_SML_MASK_PMAP_ANIM,
+			CONFUSE_BIG_MASK_PMAP_ANIM,
+			CONFUSE_MED_MASK_PMAP_ANIM,
+			CONFUSE_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)MELNORME_CAPTAIN_MASK_PMAP_ANIM,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			MELNORME_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
 		},
-		(SOUND)MELNORME_VICTORY_SONG,
-		(SOUND)MELNORME_SHIP_SOUNDS,
+		MELNORME_VICTORY_SONG,
+		MELNORME_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
 	},
 	{
 		0,
 		PUMPUP_SPEED * PUMPUP_LIFE,
-		NULL_PTR,
+		NULL,
 	},
 	(UNINIT_FUNC *) NULL,
 	(PREPROCESS_FUNC *) NULL,
@@ -110,7 +114,7 @@ static RACE_DESC melnorme_desc =
 #define REVERSE_DIR (BYTE)(1 << 7)
 
 static void
-pump_up_preprocess (PELEMENT ElementPtr)
+pump_up_preprocess (ELEMENT *ElementPtr)
 {
 	if (--ElementPtr->thrust_wait & 1)
 	{
@@ -138,8 +142,7 @@ pump_up_preprocess (PELEMENT ElementPtr)
 	}
 }
 
-static COUNT initialize_pump_up (PELEMENT ShipPtr, HELEMENT
-		PumpUpArray[]);
+static COUNT initialize_pump_up (ELEMENT *ShipPtr, HELEMENT PumpUpArray[]);
 
 #define MELNORME_OFFSET 24
 #define LEVEL_COUNTER 72
@@ -147,7 +150,7 @@ static COUNT initialize_pump_up (PELEMEN
 #define PUMPUP_DAMAGE 2
 
 static void
-pump_up_postprocess (PELEMENT ElementPtr)
+pump_up_postprocess (ELEMENT *ElementPtr)
 {
 	if (ElementPtr->state_flags & APPEARING)
 	{
@@ -156,8 +159,9 @@ pump_up_postprocess (PELEMENT ElementPtr
 	else
 	{
 		HELEMENT hPumpUp;
-		ELEMENTPTR EPtr, ShipPtr;
-		STARSHIPPTR StarShipPtr;
+		ELEMENT *EPtr;
+		ELEMENT *ShipPtr;
+		STARSHIP *StarShipPtr;
 
 		GetElementStarShip (ElementPtr, &StarShipPtr);
 		LockElement (StarShipPtr->hShip, &ShipPtr);
@@ -243,7 +247,7 @@ pump_up_postprocess (PELEMENT ElementPtr
 }
 
 static void
-animate (PELEMENT ElementPtr)
+animate (ELEMENT *ElementPtr)
 {
 	if (ElementPtr->turn_wait > 0)
 		--ElementPtr->turn_wait;
@@ -258,7 +262,8 @@ animate (PELEMENT ElementPtr)
 }
 
 static void
-pump_up_collision (PELEMENT ElementPtr0, PPOINT pPt0, PELEMENT ElementPtr1, PPOINT pPt1)
+pump_up_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
 	RECT r;
 	BYTE old_thrust_wait;
@@ -273,7 +278,7 @@ pump_up_collision (PELEMENT ElementPtr0,
 
 	if (hBlastElement)
 	{
-		ELEMENTPTR BlastElementPtr;
+		ELEMENT *BlastElementPtr;
 
 #define MIN_PUMPITUDE_ANIMS 3
 		LockElement (hBlastElement, &BlastElementPtr);
@@ -296,9 +301,9 @@ pump_up_collision (PELEMENT ElementPtr0,
 }
 
 static COUNT
-initialize_pump_up (PELEMENT ShipPtr, HELEMENT PumpUpArray[])
+initialize_pump_up (ELEMENT *ShipPtr, HELEMENT PumpUpArray[])
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
@@ -320,7 +325,7 @@ initialize_pump_up (PELEMENT ShipPtr, HE
 
 	if (PumpUpArray[0])
 	{
-		ELEMENTPTR PumpUpPtr;
+		ELEMENT *PumpUpPtr;
 
 		LockElement (PumpUpArray[0], &PumpUpPtr);
 		PumpUpPtr->postprocess_func = pump_up_postprocess;
@@ -333,7 +338,7 @@ initialize_pump_up (PELEMENT ShipPtr, HE
 }
 
 static void
-confuse_preprocess (PELEMENT ElementPtr)
+confuse_preprocess (ELEMENT *ElementPtr)
 {
 	if (!(ElementPtr->state_flags & NONSOLID))
 	{
@@ -349,7 +354,7 @@ confuse_preprocess (PELEMENT ElementPtr)
 	}
 	else
 	{
-		ELEMENTPTR eptr;
+		ELEMENT *eptr;
 
 		LockElement (ElementPtr->hTarget, &eptr);
 
@@ -358,7 +363,7 @@ confuse_preprocess (PELEMENT ElementPtr)
 		if (ElementPtr->turn_wait)
 		{
 			HELEMENT hEffect;
-			STARSHIPPTR StarShipPtr;
+			STARSHIP *StarShipPtr;
 
 			if (GetFrameIndex (ElementPtr->next.image.frame =
 					IncFrameIndex (ElementPtr->current.image.frame)) == 0)
@@ -398,13 +403,14 @@ confuse_preprocess (PELEMENT ElementPtr)
 }
 
 static void
-confusion_collision (PELEMENT ElementPtr0, PPOINT pPt0, PELEMENT ElementPtr1, PPOINT pPt1)
+confusion_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
 	if (ElementPtr1->state_flags & PLAYER_SHIP)
 	{
 		HELEMENT hConfusionElement, hNextElement;
-		ELEMENTPTR ConfusionPtr;
-		STARSHIPPTR StarShipPtr;
+		ELEMENT *ConfusionPtr;
+		STARSHIP *StarShipPtr;
 
 		GetElementStarShip (ElementPtr0, &StarShipPtr);
 		for (hConfusionElement = GetHeadElement ();
@@ -466,14 +472,14 @@ confusion_collision (PELEMENT ElementPtr
 }
 
 static COUNT
-initialize_confusion (PELEMENT ShipPtr, HELEMENT ConfusionArray[])
+initialize_confusion (ELEMENT *ShipPtr, HELEMENT ConfusionArray[])
 {
 #define CMISSILE_SPEED DISPLAY_TO_WORLD (30)
 #define CMISSILE_HITS 200
 #define CMISSILE_DAMAGE 0
 #define CMISSILE_LIFE 20
 #define CMISSILE_OFFSET 4
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK ConfusionBlock;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
@@ -495,7 +501,7 @@ initialize_confusion (PELEMENT ShipPtr,
 
 	if (ConfusionArray[0])
 	{
-		ELEMENTPTR CMissilePtr;
+		ELEMENT *CMissilePtr;
 
 		LockElement (ConfusionArray[0], &CMissilePtr);
 		CMissilePtr->collision_func = confusion_collision;
@@ -506,11 +512,11 @@ initialize_confusion (PELEMENT ShipPtr,
 }
 
 static COUNT
-initialize_test_pump_up (PELEMENT ShipPtr, HELEMENT PumpUpArray[])
+initialize_test_pump_up (ELEMENT *ShipPtr, HELEMENT PumpUpArray[])
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
-	//ELEMENTPTR PumpUpPtr;
+	//ELEMENT *PumpUpPtr;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	MissileBlock.cx = ShipPtr->next.location.x;
@@ -533,11 +539,12 @@ initialize_test_pump_up (PELEMENT ShipPt
 }
 
 static void
-melnorme_intelligence (PELEMENT ShipPtr, PEVALUATE_DESC ObjectsOfConcern, COUNT ConcernCounter)
+melnorme_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+		COUNT ConcernCounter)
 {
 	BYTE old_count;
-	STARSHIPPTR StarShipPtr;
-	PEVALUATE_DESC lpEvalDesc;
+	STARSHIP *StarShipPtr;
+	EVALUATE_DESC *lpEvalDesc;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 
@@ -556,7 +563,7 @@ melnorme_intelligence (PELEMENT ShipPtr,
 			lpEvalDesc->MoveState = ENTICE;
 		else
 		{
-			STARSHIPPTR EnemyStarShipPtr;
+			STARSHIP *EnemyStarShipPtr;
 
 			GetElementStarShip (lpEvalDesc->ObjectPtr, &EnemyStarShipPtr);
 			if (!(EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags
@@ -606,9 +613,9 @@ melnorme_intelligence (PELEMENT ShipPtr,
 }
 
 static void
-melnorme_postprocess (PELEMENT ElementPtr)
+melnorme_postprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if ((StarShipPtr->cur_status_flags & SPECIAL)
@@ -620,7 +627,7 @@ melnorme_postprocess (PELEMENT ElementPt
 		initialize_confusion (ElementPtr, &Confusion);
 		if (Confusion)
 		{
-			ELEMENTPTR CMissilePtr;
+			ELEMENT *CMissilePtr;
 			LockElement (Confusion, &CMissilePtr);
 			
 			ProcessSound (SetAbsSoundIndex (
@@ -634,16 +641,14 @@ melnorme_postprocess (PELEMENT ElementPt
 	}
 }
 
-RACE_DESCPTR
+RACE_DESC*
 init_melnorme (void)
 {
-	RACE_DESCPTR RaceDescPtr;
+	RACE_DESC *RaceDescPtr;
 
 	melnorme_desc.postprocess_func = melnorme_postprocess;
 	melnorme_desc.init_weapon_func = initialize_pump_up;
-	melnorme_desc.cyborg_control.intelligence_func =
-			(void (*) (PVOID ShipPtr, PVOID ObjectsOfConcern, COUNT
-					ConcernCounter)) melnorme_intelligence;
+	melnorme_desc.cyborg_control.intelligence_func = melnorme_intelligence;
 
 	RaceDescPtr = &melnorme_desc;
 
diff -ruNp src.orig/sc2code/ships/mmrnmhrm/icode.h src/sc2code/ships/mmrnmhrm/icode.h
--- src.orig/sc2code/ships/mmrnmhrm/icode.h	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/mmrnmhrm/icode.h	2017-11-08 16:50:05 -0600
@@ -1,3 +1,5 @@
-#define MMRNMHRM_CODE 0x00200008L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define MMRNMHRM_CODE "ship.mmrnmhrm.code"
diff -ruNp src.orig/sc2code/ships/mmrnmhrm/igfxres.h src/sc2code/ships/mmrnmhrm/igfxres.h
--- src.orig/sc2code/ships/mmrnmhrm/igfxres.h	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/mmrnmhrm/igfxres.h	2017-11-08 16:50:05 -0600
@@ -1,14 +1,16 @@
-#define MMRNMHRM_ICON_MASK_PMAP_ANIM 0x00200002L
-#define MMRNMHRM_MICON_MASK_PMAP_ANIM 0x00200102L
-#define MMRNMHRM_BIG_MASK_PMAP_ANIM 0x00400202L
-#define MMRNMHRM_MED_MASK_PMAP_ANIM 0x00400302L
-#define MMRNMHRM_SML_MASK_PMAP_ANIM 0x00400402L
-#define TORP_BIG_MASK_PMAP_ANIM 0x00400502L
-#define TORP_MED_MASK_PMAP_ANIM 0x00400602L
-#define TORP_SML_MASK_PMAP_ANIM 0x00400702L
-#define YWING_BIG_MASK_PMAP_ANIM 0x00400802L
-#define YWING_MED_MASK_PMAP_ANIM 0x00400902L
-#define YWING_SML_MASK_PMAP_ANIM 0x00400a02L
-#define MMRNMHRM_CAPTAIN_MASK_PMAP_ANIM 0x00400b02L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define MMRNMHRM_BIG_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.mmrnmhrm.large"
+#define MMRNMHRM_CAPTAIN_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.captain"
+#define MMRNMHRM_ICON_MASK_PMAP_ANIM "ship.mmrnmhrm.icons"
+#define MMRNMHRM_MED_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.mmrnmhrm.medium"
+#define MMRNMHRM_MICON_MASK_PMAP_ANIM "ship.mmrnmhrm.meleeicons"
+#define MMRNMHRM_SML_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.mmrnmhrm.small"
+#define TORP_BIG_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.torp.large"
+#define TORP_MED_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.torp.medium"
+#define TORP_SML_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.torp.small"
+#define YWING_BIG_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.ywing.large"
+#define YWING_MED_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.ywing.medium"
+#define YWING_SML_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.ywing.small"
diff -ruNp src.orig/sc2code/ships/mmrnmhrm/imusicre.h src/sc2code/ships/mmrnmhrm/imusicre.h
--- src.orig/sc2code/ships/mmrnmhrm/imusicre.h	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/mmrnmhrm/imusicre.h	2017-11-08 16:50:05 -0600
@@ -1,3 +1,5 @@
-#define MMRNMHRM_VICTORY_SONG 0x00400006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define MMRNMHRM_VICTORY_SONG "ship.mmrnmhrm.ditty"
diff -ruNp src.orig/sc2code/ships/mmrnmhrm/isndres.h src/sc2code/ships/mmrnmhrm/isndres.h
--- src.orig/sc2code/ships/mmrnmhrm/isndres.h	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/mmrnmhrm/isndres.h	2017-11-08 16:50:05 -0600
@@ -1,3 +1,5 @@
-#define MMRNMHRM_SHIP_SOUNDS 0x00400005L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define MMRNMHRM_SHIP_SOUNDS "ship.mmrnmhrm.sounds"
diff -ruNp src.orig/sc2code/ships/mmrnmhrm/istrtab.h src/sc2code/ships/mmrnmhrm/istrtab.h
--- src.orig/sc2code/ships/mmrnmhrm/istrtab.h	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/mmrnmhrm/istrtab.h	2017-11-08 16:50:05 -0600
@@ -1,3 +1,5 @@
-#define MMRNMHRM_RACE_STRINGS 0x00200004L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define MMRNMHRM_RACE_STRINGS "ship.mmrnmhrm.text"
diff -ruNp src.orig/sc2code/ships/mmrnmhrm/mmrnmhrm.c src/sc2code/ships/mmrnmhrm/mmrnmhrm.c
--- src.orig/sc2code/ships/mmrnmhrm/mmrnmhrm.c	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/mmrnmhrm/mmrnmhrm.c	2017-11-08 16:50:05 -0600
@@ -54,18 +54,21 @@ static CHARACTERISTIC_STUFF otherwing_de
 
 static RACE_DESC mmrnmhrm_desc =
 {
-	{
+	{ /* SHIP_INFO */
 		FIRES_FORE | IMMEDIATE_WEAPON,
 		19, /* Super Melee cost */
-		0 / SPHERE_RADIUS_INCREMENT, /* Initial sphere of influence radius */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY, MAX_ENERGY,
-		{
+		MMRNMHRM_RACE_STRINGS,
+		MMRNMHRM_ICON_MASK_PMAP_ANIM,
+		MMRNMHRM_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
 			0, 0,
 		},
-		(STRING)MMRNMHRM_RACE_STRINGS,
-		(FRAME)MMRNMHRM_ICON_MASK_PMAP_ANIM,
-		(FRAME)MMRNMHRM_MICON_MASK_PMAP_ANIM,
 	},
 	{
 		MAX_THRUST,
@@ -82,34 +85,35 @@ static RACE_DESC mmrnmhrm_desc =
 	},
 	{
 		{
-			(FRAME)MMRNMHRM_BIG_MASK_PMAP_ANIM,
-			(FRAME)MMRNMHRM_MED_MASK_PMAP_ANIM,
-			(FRAME)MMRNMHRM_SML_MASK_PMAP_ANIM,
+			MMRNMHRM_BIG_MASK_PMAP_ANIM,
+			MMRNMHRM_MED_MASK_PMAP_ANIM,
+			MMRNMHRM_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)TORP_BIG_MASK_PMAP_ANIM,
-			(FRAME)TORP_MED_MASK_PMAP_ANIM,
-			(FRAME)TORP_SML_MASK_PMAP_ANIM,
+			TORP_BIG_MASK_PMAP_ANIM,
+			TORP_MED_MASK_PMAP_ANIM,
+			TORP_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)YWING_BIG_MASK_PMAP_ANIM,
-			(FRAME)YWING_MED_MASK_PMAP_ANIM,
-			(FRAME)YWING_SML_MASK_PMAP_ANIM,
+			YWING_BIG_MASK_PMAP_ANIM,
+			YWING_MED_MASK_PMAP_ANIM,
+			YWING_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)MMRNMHRM_CAPTAIN_MASK_PMAP_ANIM,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			MMRNMHRM_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
 		},
-		(SOUND)MMRNMHRM_VICTORY_SONG,
-		(SOUND)MMRNMHRM_SHIP_SOUNDS,
+		MMRNMHRM_VICTORY_SONG,
+		MMRNMHRM_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
 	},
 	{
 		0,
 		CLOSE_RANGE_WEAPON,
-		NULL_PTR,
+		NULL,
 	},
 	(UNINIT_FUNC *) NULL,
 	(PREPROCESS_FUNC *) NULL,
@@ -122,7 +126,7 @@ static RACE_DESC mmrnmhrm_desc =
 #define TRACK_WAIT 5
 
 static void
-missile_preprocess (PELEMENT ElementPtr)
+missile_preprocess (ELEMENT *ElementPtr)
 {
 	if (ElementPtr->turn_wait > 0)
 		--ElementPtr->turn_wait;
@@ -147,11 +151,13 @@ missile_preprocess (PELEMENT ElementPtr)
 }
 
 static void
-mmrnmhrm_intelligence (PELEMENT ShipPtr, PEVALUATE_DESC ObjectsOfConcern, COUNT ConcernCounter)
+mmrnmhrm_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+		COUNT ConcernCounter)
 {
 	BOOLEAN CanTransform;
-	PEVALUATE_DESC lpEvalDesc;
-	STARSHIPPTR StarShipPtr, EnemyStarShipPtr;
+	EVALUATE_DESC *lpEvalDesc;
+	STARSHIP *StarShipPtr;
+	STARSHIP *EnemyStarShipPtr;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	CanTransform = (BOOLEAN)(StarShipPtr->special_counter == 0
@@ -237,7 +243,8 @@ mmrnmhrm_intelligence (PELEMENT ShipPtr,
 }
 
 static void
-twin_laser_collision (PELEMENT ElementPtr0, PPOINT pPt0, PELEMENT ElementPtr1, PPOINT pPt1)
+twin_laser_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
 	if (!(ElementPtr1->state_flags & PLAYER_SHIP)
 			|| !(ElementPtr0->state_flags & ElementPtr1->state_flags
@@ -246,13 +253,13 @@ twin_laser_collision (PELEMENT ElementPt
 }
 
 static COUNT
-initialize_dual_weapons (PELEMENT ShipPtr, HELEMENT WeaponArray[])
+initialize_dual_weapons (ELEMENT *ShipPtr, HELEMENT WeaponArray[])
 {
 #define CENTER_OFFS DISPLAY_TO_WORLD (4)
 	COORD cx, cy;
 	COUNT facing, angle;
 	SIZE offs_x, offs_y;
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	facing = StarShipPtr->ShipFacing;
@@ -265,7 +272,7 @@ initialize_dual_weapons (PELEMENT ShipPt
 #define WING_OFFS DISPLAY_TO_WORLD (10)
 		COORD ex, ey;
 		LASER_BLOCK LaserBlock;
-		ELEMENTPTR LaserPtr;
+		ELEMENT *LaserPtr;
 
 		LaserBlock.sender = ShipPtr->state_flags & (GOOD_GUY | BAD_GUY);
 		LaserBlock.pixoffs = 0;
@@ -307,7 +314,7 @@ initialize_dual_weapons (PELEMENT ShipPt
 #define MISSILE_LIFE 40
 #define LAUNCH_OFFS DISPLAY_TO_WORLD (4)
 		MISSILE_BLOCK TorpBlock;
-		ELEMENTPTR TorpPtr;
+		ELEMENT *TorpPtr;
 
 		TorpBlock.farray = StarShipPtr->RaceDescPtr->ship_data.weapon;
 		TorpBlock.sender = (ShipPtr->state_flags & (GOOD_GUY | BAD_GUY))
@@ -349,9 +356,9 @@ initialize_dual_weapons (PELEMENT ShipPt
 }
 
 static void
-mmrnmhrm_postprocess (PELEMENT ElementPtr)
+mmrnmhrm_postprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 			/* take care of transform effect */
@@ -400,7 +407,7 @@ mmrnmhrm_postprocess (PELEMENT ElementPt
 }
 
 static void
-mmrnmhrm_preprocess (PELEMENT ElementPtr)
+mmrnmhrm_preprocess (ELEMENT *ElementPtr)
 {
 	if (ElementPtr->state_flags & APPEARING)
 	{
@@ -421,7 +428,7 @@ mmrnmhrm_preprocess (PELEMENT ElementPtr
 	}
 	else
 	{
-		STARSHIPPTR StarShipPtr;
+		STARSHIP *StarShipPtr;
 
 		GetElementStarShip (ElementPtr, &StarShipPtr);
 		if ((StarShipPtr->cur_status_flags & SPECIAL)
@@ -451,17 +458,15 @@ mmrnmhrm_preprocess (PELEMENT ElementPtr
 	}
 }
 
-RACE_DESCPTR
+RACE_DESC*
 init_mmrnmhrm (void)
 {
-	RACE_DESCPTR RaceDescPtr;
+	RACE_DESC *RaceDescPtr;
 
 	mmrnmhrm_desc.preprocess_func = mmrnmhrm_preprocess;
 	mmrnmhrm_desc.postprocess_func = mmrnmhrm_postprocess;
 	mmrnmhrm_desc.init_weapon_func = initialize_dual_weapons;
-	mmrnmhrm_desc.cyborg_control.intelligence_func =
-			(void (*) (PVOID ShipPtr, PVOID ObjectsOfConcern, COUNT
-					ConcernCounter)) mmrnmhrm_intelligence;
+	mmrnmhrm_desc.cyborg_control.intelligence_func = mmrnmhrm_intelligence;
 
 	RaceDescPtr = &mmrnmhrm_desc;
 
diff -ruNp src.orig/sc2code/ships/mycon/icode.h src/sc2code/ships/mycon/icode.h
--- src.orig/sc2code/ships/mycon/icode.h	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/mycon/icode.h	2017-11-08 16:50:05 -0600
@@ -1,3 +1,5 @@
-#define MYCON_CODE 0x00200008L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define MYCON_CODE "ship.mycon.code"
diff -ruNp src.orig/sc2code/ships/mycon/igfxres.h src/sc2code/ships/mycon/igfxres.h
--- src.orig/sc2code/ships/mycon/igfxres.h	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/mycon/igfxres.h	2017-11-08 16:50:05 -0600
@@ -1,11 +1,13 @@
-#define MYCON_ICON_MASK_PMAP_ANIM 0x00200002L
-#define MYCON_MICON_MASK_PMAP_ANIM 0x00200102L
-#define MYCON_BIG_MASK_PMAP_ANIM 0x00400202L
-#define MYCON_MED_MASK_PMAP_ANIM 0x00400302L
-#define MYCON_SML_MASK_PMAP_ANIM 0x00400402L
-#define PLASMA_BIG_MASK_PMAP_ANIM 0x00400502L
-#define PLASMA_MED_MASK_PMAP_ANIM 0x00400602L
-#define PLASMA_SML_MASK_PMAP_ANIM 0x00400702L
-#define MYCON_CAPTAIN_MASK_PMAP_ANIM 0x00400802L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define MYCON_BIG_MASK_PMAP_ANIM "ship.mycon.graphics.mycon.large"
+#define MYCON_CAPTAIN_MASK_PMAP_ANIM "ship.mycon.graphics.captain"
+#define MYCON_ICON_MASK_PMAP_ANIM "ship.mycon.icons"
+#define MYCON_MED_MASK_PMAP_ANIM "ship.mycon.graphics.mycon.medium"
+#define MYCON_MICON_MASK_PMAP_ANIM "ship.mycon.meleeicons"
+#define MYCON_SML_MASK_PMAP_ANIM "ship.mycon.graphics.mycon.small"
+#define PLASMA_BIG_MASK_PMAP_ANIM "ship.mycon.graphics.plasma.large"
+#define PLASMA_MED_MASK_PMAP_ANIM "ship.mycon.graphics.plasma.medium"
+#define PLASMA_SML_MASK_PMAP_ANIM "ship.mycon.graphics.plasma.small"
diff -ruNp src.orig/sc2code/ships/mycon/imusicre.h src/sc2code/ships/mycon/imusicre.h
--- src.orig/sc2code/ships/mycon/imusicre.h	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/mycon/imusicre.h	2017-11-08 16:50:05 -0600
@@ -1,3 +1,5 @@
-#define MYCON_VICTORY_SONG 0x00400006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define MYCON_VICTORY_SONG "ship.mycon.ditty"
diff -ruNp src.orig/sc2code/ships/mycon/isndres.h src/sc2code/ships/mycon/isndres.h
--- src.orig/sc2code/ships/mycon/isndres.h	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/mycon/isndres.h	2017-11-08 16:50:05 -0600
@@ -1,3 +1,5 @@
-#define MYCON_SHIP_SOUNDS 0x00400005L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define MYCON_SHIP_SOUNDS "ship.mycon.sounds"
diff -ruNp src.orig/sc2code/ships/mycon/istrtab.h src/sc2code/ships/mycon/istrtab.h
--- src.orig/sc2code/ships/mycon/istrtab.h	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/mycon/istrtab.h	2017-11-08 16:50:05 -0600
@@ -1,3 +1,5 @@
-#define MYCON_RACE_STRINGS 0x00200004L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define MYCON_RACE_STRINGS "ship.mycon.text"
diff -ruNp src.orig/sc2code/ships/mycon/mycon.c src/sc2code/ships/mycon/mycon.c
--- src.orig/sc2code/ships/mycon/mycon.c	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/mycon/mycon.c	2017-11-08 16:50:05 -0600
@@ -42,18 +42,21 @@
 
 static RACE_DESC mycon_desc =
 {
-	{
+	{ /* SHIP_INFO */
 		FIRES_FORE | SEEKING_WEAPON,
 		21, /* Super Melee cost */
-		1070 / SPHERE_RADIUS_INCREMENT, /* Initial sphere of influence radius */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY, MAX_ENERGY,
-		{
+		MYCON_RACE_STRINGS,
+		MYCON_ICON_MASK_PMAP_ANIM,
+		MYCON_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		1070 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
 			6392, 2200,
 		},
-		(STRING)MYCON_RACE_STRINGS,
-		(FRAME)MYCON_ICON_MASK_PMAP_ANIM,
-		(FRAME)MYCON_MICON_MASK_PMAP_ANIM,
 	},
 	{
 		MAX_THRUST,
@@ -70,34 +73,35 @@ static RACE_DESC mycon_desc =
 	},
 	{
 		{
-			(FRAME)MYCON_BIG_MASK_PMAP_ANIM,
-			(FRAME)MYCON_MED_MASK_PMAP_ANIM,
-			(FRAME)MYCON_SML_MASK_PMAP_ANIM,
+			MYCON_BIG_MASK_PMAP_ANIM,
+			MYCON_MED_MASK_PMAP_ANIM,
+			MYCON_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)PLASMA_BIG_MASK_PMAP_ANIM,
-			(FRAME)PLASMA_MED_MASK_PMAP_ANIM,
-			(FRAME)PLASMA_SML_MASK_PMAP_ANIM,
+			PLASMA_BIG_MASK_PMAP_ANIM,
+			PLASMA_MED_MASK_PMAP_ANIM,
+			PLASMA_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
 		},
 		{
-			(FRAME)MYCON_CAPTAIN_MASK_PMAP_ANIM,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			MYCON_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
 		},
-		(SOUND)MYCON_VICTORY_SONG,
-		(SOUND)MYCON_SHIP_SOUNDS,
+		MYCON_VICTORY_SONG,
+		MYCON_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
 	},
 	{
 		0,
 		DISPLAY_TO_WORLD (800),
-		NULL_PTR,
+		NULL,
 	},
 	(UNINIT_FUNC *) NULL,
 	(PREPROCESS_FUNC *) NULL,
@@ -111,7 +115,7 @@ static RACE_DESC mycon_desc =
 #define TRACK_WAIT 1
 
 static void
-plasma_preprocess (PELEMENT ElementPtr)
+plasma_preprocess (ELEMENT *ElementPtr)
 {
 	COUNT plasma_index;
 
@@ -149,7 +153,7 @@ plasma_preprocess (PELEMENT ElementPtr)
 }
 
 static void
-plasma_blast_preprocess (PELEMENT ElementPtr)
+plasma_blast_preprocess (ELEMENT *ElementPtr)
 {
 	if (ElementPtr->life_span >= ElementPtr->thrust_wait)
 		ElementPtr->next.image.frame =
@@ -159,7 +163,7 @@ plasma_blast_preprocess (PELEMENT Elemen
 				DecFrameIndex (ElementPtr->next.image.frame);
 	if (ElementPtr->hTarget)
 	{
-		ELEMENTPTR ShipPtr;
+		ELEMENT *ShipPtr;
 
 		LockElement (ElementPtr->hTarget, &ShipPtr);
 		ElementPtr->next.location = ShipPtr->next.location;
@@ -170,7 +174,8 @@ plasma_blast_preprocess (PELEMENT Elemen
 }
 
 static void
-plasma_collision (PELEMENT ElementPtr0, PPOINT pPt0, PELEMENT ElementPtr1, PPOINT pPt1)
+plasma_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
 	SIZE old_mass;
 	HELEMENT hBlastElement;
@@ -182,7 +187,7 @@ plasma_collision (PELEMENT ElementPtr0,
 			weapon_collision (ElementPtr0, pPt0, ElementPtr1, pPt1)))
 	{
 		SIZE num_animations;
-		ELEMENTPTR BlastElementPtr;
+		ELEMENT *BlastElementPtr;
 
 		LockElement (hBlastElement, &BlastElementPtr);
 		BlastElementPtr->pParent = ElementPtr0->pParent;
@@ -190,7 +195,7 @@ plasma_collision (PELEMENT ElementPtr0,
 			BlastElementPtr->hTarget = 0;
 		else
 		{
-			STARSHIPPTR StarShipPtr;
+			STARSHIP *StarShipPtr;
 
 			GetElementStarShip (ElementPtr1, &StarShipPtr);
 			BlastElementPtr->hTarget = StarShipPtr->hShip;
@@ -218,10 +223,11 @@ plasma_collision (PELEMENT ElementPtr0,
 }
 
 static void
-mycon_intelligence (PELEMENT ShipPtr, PEVALUATE_DESC ObjectsOfConcern, COUNT ConcernCounter)
+mycon_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+		COUNT ConcernCounter)
 {
-	STARSHIPPTR StarShipPtr;
-	PEVALUATE_DESC lpEvalDesc;
+	STARSHIP *StarShipPtr;
+	EVALUATE_DESC *lpEvalDesc;
 
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_WEAPON_INDEX];
 	if (lpEvalDesc->ObjectPtr && lpEvalDesc->MoveState == ENTICE)
@@ -287,11 +293,11 @@ mycon_intelligence (PELEMENT ShipPtr, PE
 }
 
 static COUNT
-initialize_plasma (PELEMENT ShipPtr, HELEMENT PlasmaArray[])
+initialize_plasma (ELEMENT *ShipPtr, HELEMENT PlasmaArray[])
 {
 #define MYCON_OFFSET 24
 #define MISSILE_OFFSET 0
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
@@ -312,7 +318,7 @@ initialize_plasma (PELEMENT ShipPtr, HEL
 
 	if (PlasmaArray[0])
 	{
-		ELEMENTPTR PlasmaPtr;
+		ELEMENT *PlasmaPtr;
 
 		LockElement (PlasmaArray[0], &PlasmaPtr);
 		PlasmaPtr->collision_func = plasma_collision;
@@ -324,9 +330,9 @@ initialize_plasma (PELEMENT ShipPtr, HEL
 }
 
 static void
-mycon_postprocess (PELEMENT ElementPtr)
+mycon_postprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if ((StarShipPtr->cur_status_flags & SPECIAL)
@@ -350,16 +356,14 @@ mycon_postprocess (PELEMENT ElementPtr)
 	}
 }
 
-RACE_DESCPTR
+RACE_DESC*
 init_mycon (void)
 {
-	RACE_DESCPTR RaceDescPtr;
+	RACE_DESC *RaceDescPtr;
 
 	mycon_desc.postprocess_func = mycon_postprocess;
 	mycon_desc.init_weapon_func = initialize_plasma;
-	mycon_desc.cyborg_control.intelligence_func =
-			(void (*) (PVOID ShipPtr, PVOID ObjectsOfConcern, COUNT
-					ConcernCounter)) mycon_intelligence;
+	mycon_desc.cyborg_control.intelligence_func = mycon_intelligence;
 
 	RaceDescPtr = &mycon_desc;
 
diff -ruNp src.orig/sc2code/ships/orz/icode.h src/sc2code/ships/orz/icode.h
--- src.orig/sc2code/ships/orz/icode.h	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/orz/icode.h	2017-11-08 16:50:06 -0600
@@ -1,3 +1,5 @@
-#define ORZ_CODE 0x00200008L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ORZ_CODE "ship.orz.code"
diff -ruNp src.orig/sc2code/ships/orz/igfxres.h src/sc2code/ships/orz/igfxres.h
--- src.orig/sc2code/ships/orz/igfxres.h	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/orz/igfxres.h	2017-11-08 16:50:06 -0600
@@ -1,14 +1,16 @@
-#define ORZ_ICON_MASK_PMAP_ANIM 0x00200002L
-#define ORZ_MICON_MASK_PMAP_ANIM 0x00200102L
-#define ORZ_BIG_MASK_PMAP_ANIM 0x00400202L
-#define ORZ_MED_MASK_PMAP_ANIM 0x00400302L
-#define ORZ_SML_MASK_PMAP_ANIM 0x00400402L
-#define HOWITZER_BIG_MASK_PMAP_ANIM 0x00400502L
-#define HOWITZER_MED_MASK_PMAP_ANIM 0x00400602L
-#define HOWITZER_SML_MASK_PMAP_ANIM 0x00400702L
-#define TURRET_BIG_MASK_PMAP_ANIM 0x00400802L
-#define TURRET_MED_MASK_PMAP_ANIM 0x00400902L
-#define TURRET_SML_MASK_PMAP_ANIM 0x00400a02L
-#define ORZ_CAPTAIN_MASK_PMAP_ANIM 0x00400b02L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define HOWITZER_BIG_MASK_PMAP_ANIM "ship.orz.graphics.how.large"
+#define HOWITZER_MED_MASK_PMAP_ANIM "ship.orz.graphics.how.medium"
+#define HOWITZER_SML_MASK_PMAP_ANIM "ship.orz.graphics.how.small"
+#define ORZ_BIG_MASK_PMAP_ANIM "ship.orz.graphics.orz.large"
+#define ORZ_CAPTAIN_MASK_PMAP_ANIM "ship.orz.graphics.captain"
+#define ORZ_ICON_MASK_PMAP_ANIM "ship.orz.icons"
+#define ORZ_MED_MASK_PMAP_ANIM "ship.orz.graphics.orz.medium"
+#define ORZ_MICON_MASK_PMAP_ANIM "ship.orz.meleeicons"
+#define ORZ_SML_MASK_PMAP_ANIM "ship.orz.graphics.orz.small"
+#define TURRET_BIG_MASK_PMAP_ANIM "ship.orz.graphics.tur.large"
+#define TURRET_MED_MASK_PMAP_ANIM "ship.orz.graphics.tur.medium"
+#define TURRET_SML_MASK_PMAP_ANIM "ship.orz.graphics.tur.small"
diff -ruNp src.orig/sc2code/ships/orz/imusicre.h src/sc2code/ships/orz/imusicre.h
--- src.orig/sc2code/ships/orz/imusicre.h	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/orz/imusicre.h	2017-11-08 16:50:06 -0600
@@ -1,3 +1,5 @@
-#define ORZ_VICTORY_SONG 0x00400006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ORZ_VICTORY_SONG "ship.orz.ditty"
diff -ruNp src.orig/sc2code/ships/orz/isndres.h src/sc2code/ships/orz/isndres.h
--- src.orig/sc2code/ships/orz/isndres.h	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/orz/isndres.h	2017-11-08 16:50:06 -0600
@@ -1,3 +1,5 @@
-#define ORZ_SHIP_SOUNDS 0x00400005L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ORZ_SHIP_SOUNDS "ship.orz.sounds"
diff -ruNp src.orig/sc2code/ships/orz/istrtab.h src/sc2code/ships/orz/istrtab.h
--- src.orig/sc2code/ships/orz/istrtab.h	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/orz/istrtab.h	2017-11-08 16:50:06 -0600
@@ -1,3 +1,5 @@
-#define ORZ_RACE_STRINGS 0x00200004L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ORZ_RACE_STRINGS "ship.orz.text"
diff -ruNp src.orig/sc2code/ships/orz/orz.c src/sc2code/ships/orz/orz.c
--- src.orig/sc2code/ships/orz/orz.c	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/orz/orz.c	2017-11-08 16:50:06 -0600
@@ -44,18 +44,21 @@
 
 static RACE_DESC orz_desc =
 {
-	{
+	{ /* SHIP_INFO */
 		FIRES_FORE | SEEKING_SPECIAL,
 		23, /* Super Melee cost */
-		333 / SPHERE_RADIUS_INCREMENT, /* Initial sphere of influence radius */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY, MAX_ENERGY,
-		{
+		ORZ_RACE_STRINGS,
+		ORZ_ICON_MASK_PMAP_ANIM,
+		ORZ_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		333 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
 			3608, 2637,
 		},
-		(STRING)ORZ_RACE_STRINGS,
-		(FRAME)ORZ_ICON_MASK_PMAP_ANIM,
-		(FRAME)ORZ_MICON_MASK_PMAP_ANIM,
 	},
 	{
 		MAX_THRUST,
@@ -72,34 +75,35 @@ static RACE_DESC orz_desc =
 	},
 	{
 		{
-			(FRAME)ORZ_BIG_MASK_PMAP_ANIM,
-			(FRAME)ORZ_MED_MASK_PMAP_ANIM,
-			(FRAME)ORZ_SML_MASK_PMAP_ANIM,
+			ORZ_BIG_MASK_PMAP_ANIM,
+			ORZ_MED_MASK_PMAP_ANIM,
+			ORZ_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)HOWITZER_BIG_MASK_PMAP_ANIM,
-			(FRAME)HOWITZER_MED_MASK_PMAP_ANIM,
-			(FRAME)HOWITZER_SML_MASK_PMAP_ANIM,
+			HOWITZER_BIG_MASK_PMAP_ANIM,
+			HOWITZER_MED_MASK_PMAP_ANIM,
+			HOWITZER_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)TURRET_BIG_MASK_PMAP_ANIM,
-			(FRAME)TURRET_MED_MASK_PMAP_ANIM,
-			(FRAME)TURRET_SML_MASK_PMAP_ANIM,
+			TURRET_BIG_MASK_PMAP_ANIM,
+			TURRET_MED_MASK_PMAP_ANIM,
+			TURRET_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)ORZ_CAPTAIN_MASK_PMAP_ANIM,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			ORZ_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
 		},
-		(SOUND)ORZ_VICTORY_SONG,
-		(SOUND)ORZ_SHIP_SOUNDS,
+		ORZ_VICTORY_SONG,
+		ORZ_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
 	},
 	{
 		0,
 		MISSILE_SPEED * MISSILE_LIFE,
-		NULL_PTR,
+		NULL,
 	},
 	(UNINIT_FUNC *) NULL,
 	(PREPROCESS_FUNC *) NULL,
@@ -109,7 +113,8 @@ static RACE_DESC orz_desc =
 };
 
 static void
-howitzer_collision (PELEMENT ElementPtr0, PPOINT pPt0, PELEMENT ElementPtr1, PPOINT pPt1)
+howitzer_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
 	if ((ElementPtr0->state_flags & (GOOD_GUY | BAD_GUY))
 			!= (ElementPtr1->state_flags & (GOOD_GUY | BAD_GUY)))
@@ -120,13 +125,13 @@ howitzer_collision (PELEMENT ElementPtr0
 #define TURRET_WAIT 3
 
 static COUNT
-initialize_turret_missile (PELEMENT ShipPtr, HELEMENT MissileArray[])
+initialize_turret_missile (ELEMENT *ShipPtr, HELEMENT MissileArray[])
 {
 #define MISSILE_HITS 2
 #define MISSILE_DAMAGE 3
 #define MISSILE_OFFSET 1
-	ELEMENTPTR TurretPtr;
-	STARSHIPPTR StarShipPtr;
+	ELEMENT *TurretPtr;
+	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
@@ -158,13 +163,13 @@ initialize_turret_missile (PELEMENT Ship
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
-	MissileBlock.preprocess_func = NULL_PTR;
+	MissileBlock.preprocess_func = NULL;
 	MissileBlock.blast_offs = MISSILE_OFFSET;
 	MissileArray[0] = initialize_missile (&MissileBlock);
 
 	if (MissileArray[0])
 	{
-		ELEMENTPTR HowitzerPtr;
+		ELEMENT *HowitzerPtr;
 
 		LockElement (MissileArray[0], &HowitzerPtr);
 		HowitzerPtr->collision_func = howitzer_collision;
@@ -177,7 +182,7 @@ initialize_turret_missile (PELEMENT Ship
 #define MAX_MARINES 8
 
 static BYTE
-count_marines (STARSHIPPTR StarShipPtr, BOOLEAN FindSpot)
+count_marines (STARSHIP *StarShipPtr, BOOLEAN FindSpot)
 {
 	BYTE num_marines, id_use[MAX_MARINES];
 	HELEMENT hElement, hNextElement;
@@ -189,7 +194,7 @@ count_marines (STARSHIPPTR StarShipPtr,
 	num_marines = 0;
 	for (hElement = GetTailElement (); hElement; hElement = hNextElement)
 	{
-		ELEMENTPTR ElementPtr;
+		ELEMENT *ElementPtr;
 
 		LockElement (hElement, &ElementPtr);
 		hNextElement = GetPredElement (ElementPtr);
@@ -223,12 +228,12 @@ count_marines (STARSHIPPTR StarShipPtr,
 }
 
 static void
-orz_intelligence (PELEMENT ShipPtr, PEVALUATE_DESC ObjectsOfConcern,
+orz_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
 		COUNT ConcernCounter)
 {
-	ELEMENTPTR TurretPtr;
-	STARSHIPPTR StarShipPtr;
-	PEVALUATE_DESC lpEvalDesc;
+	ELEMENT *TurretPtr;
+	STARSHIP *StarShipPtr;
+	EVALUATE_DESC *lpEvalDesc;
 
 	LockElement (GetSuccElement (ShipPtr), &TurretPtr);
 
@@ -242,7 +247,7 @@ orz_intelligence (PELEMENT ShipPtr, PEVA
 		StarShipPtr->ship_input_state &= ~SPECIAL;
 	else if (StarShipPtr->special_counter != 1)
 	{
-		STARSHIPPTR EnemyStarShipPtr;
+		STARSHIP *EnemyStarShipPtr;
 
 		if (ShipPtr->turn_wait == 0
 				&& lpEvalDesc->MoveState == ENTICE
@@ -307,7 +312,7 @@ orz_intelligence (PELEMENT ShipPtr, PEVA
 #define START_ION_COLOR BUILD_COLOR (MAKE_RGB15 (0x1F, 0x15, 0x00), 0x7A)
 
 void
-ion_preprocess (PELEMENT ElementPtr)
+ion_preprocess (ELEMENT *ElementPtr)
 {
 	static const COLOR color_tab[] =
 	{
@@ -352,16 +357,16 @@ ion_preprocess (PELEMENT ElementPtr)
 	}
 }
 
-static void marine_preprocess (PELEMENT ElementPtr);
+static void marine_preprocess (ELEMENT *ElementPtr);
 
 #define MARINE_WAIT 12
 
 void
-intruder_preprocess (PELEMENT ElementPtr)
+intruder_preprocess (ELEMENT *ElementPtr)
 {
 	HELEMENT hElement, hNextElement;
-	ELEMENTPTR ShipPtr;
-	STARSHIPPTR StarShipPtr;
+	ELEMENT *ShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	LockElement (StarShipPtr->hShip, &ShipPtr);
@@ -469,11 +474,10 @@ LeftShip:
 }
 
 static void
-marine_preprocess (ElementPtr)
-PELEMENT ElementPtr;
+marine_preprocess (ELEMENT *ElementPtr)
 {
-	ELEMENTPTR ShipPtr;
-	STARSHIPPTR StarShipPtr;
+	ELEMENT *ShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	LockElement (StarShipPtr->hShip, &ShipPtr);
@@ -495,8 +499,10 @@ PELEMENT ElementPtr;
 		COUNT facing, pfacing;
 		SIZE delta_x, delta_y, delta_facing;
 		HELEMENT hObject, hNextObject, hTarget;
-		ELEMENTPTR ObjectPtr;
+		ELEMENT *ObjectPtr;
 
+		// XXX: thrust_wait is abused to store marine speed and
+		//   gravity well flags
 		ElementPtr->thrust_wait &= ~(SHIP_IN_GRAVITY_WELL >> 6);
 
 		hTarget = 0;
@@ -629,14 +635,16 @@ PELEMENT ElementPtr;
 				 || ((ElementPtr->thrust_wait & (SHIP_BEYOND_MAX_SPEED >> 6))
 				 && !(ElementPtr->thrust_wait & (SHIP_IN_GRAVITY_WELL >> 6))))
 		{
-			UWORD thrust_status;
+			STATUS_FLAGS thrust_status;
 			COUNT OldFacing;
-			UWORD OldStatus;
+			STATUS_FLAGS OldStatus;
 			COUNT OldIncrement, OldThrust;
-			STARSHIPPTR StarShipPtr;
+			STARSHIP *StarShipPtr;
 
 			GetElementStarShip (ElementPtr, &StarShipPtr);
 
+			// XXX: Hack: abusing the primary STARSHIP struct in order
+			//   to call inertial_thrust() for a marine
 			OldFacing = StarShipPtr->ShipFacing;
 			OldStatus = StarShipPtr->cur_status_flags;
 			OldIncrement = StarShipPtr->RaceDescPtr->characteristics.
@@ -644,6 +652,8 @@ PELEMENT ElementPtr;
 			OldThrust = StarShipPtr->RaceDescPtr->characteristics.max_thrust;
 
 			StarShipPtr->ShipFacing = facing;
+			// XXX: thrust_wait is abused to store marine speed and
+			//   gravity well flags
 			StarShipPtr->cur_status_flags = ElementPtr->thrust_wait << 6;
 			StarShipPtr->RaceDescPtr->characteristics.thrust_increment = 8;
 			StarShipPtr->RaceDescPtr->characteristics.max_thrust = 32;
@@ -668,7 +678,7 @@ PELEMENT ElementPtr;
 				{
 #define ION_LIFE 1
 					COUNT angle;
-					ELEMENTPTR IonElementPtr;
+					ELEMENT *IonElementPtr;
 
 					angle = FACING_TO_ANGLE (facing) + HALF_CIRCLE;
 
@@ -706,13 +716,16 @@ PELEMENT ElementPtr;
 				}
 			}
 
+			// XXX: thrust_wait is abused to store marine speed and
+			//   gravity well flags
 			ElementPtr->thrust_wait = (BYTE)(thrust_status >> 6);
 		}
 	}
 }
 
 void
-marine_collision (PELEMENT ElementPtr0, PPOINT pPt0, PELEMENT ElementPtr1, PPOINT pPt1)
+marine_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
 	if (ElementPtr0->life_span
 			&& !(ElementPtr0->state_flags & (NONSOLID | COLLISION))
@@ -757,7 +770,7 @@ marine_collision (PELEMENT ElementPtr0,
 					)
 			{
 				STAMP s;
-				STARSHIPPTR StarShipPtr;
+				STARSHIP *StarShipPtr;
 
 				GetElementStarShip (ElementPtr0, &StarShipPtr);
 				if (!DeltaCrew (ElementPtr1, -1))
@@ -796,7 +809,7 @@ marine_collision (PELEMENT ElementPtr0,
 }
 
 static void
-animate (PELEMENT ElementPtr)
+animate (ELEMENT *ElementPtr)
 {
 	if (ElementPtr->turn_wait > 0)
 		--ElementPtr->turn_wait;
@@ -811,11 +824,11 @@ animate (PELEMENT ElementPtr)
 }
 
 static void
-turret_postprocess (PELEMENT ElementPtr)
+turret_postprocess (ELEMENT *ElementPtr)
 {
 	if (ElementPtr->life_span == 0)
 	{
-		STARSHIPPTR StarShipPtr;
+		STARSHIP *StarShipPtr;
 
 		SetPrimType (&(GLOBAL (DisplayArray))[
 				ElementPtr->PrimIndex], NO_PRIM);
@@ -825,13 +838,13 @@ turret_postprocess (PELEMENT ElementPtr)
 		{
 			COUNT facing;
 			HELEMENT hTurret, hSpaceMarine;
-			ELEMENTPTR ShipPtr;
+			ELEMENT *ShipPtr;
 
 			LockElement (StarShipPtr->hShip, &ShipPtr);
 			hTurret = AllocElement ();
 			if (hTurret)
 			{
-				ELEMENTPTR TurretPtr;
+				ELEMENT *TurretPtr;
 
 				LockElement (hTurret, &TurretPtr);
 				TurretPtr->state_flags =
@@ -869,10 +882,10 @@ turret_postprocess (PELEMENT ElementPtr)
 				if (StarShipPtr->cur_status_flags & WEAPON)
 				{
 					HELEMENT hTurretEffect;
-					ELEMENTPTR TurretEffectPtr;
+					ELEMENT *TurretEffectPtr;
 
 					LockElement (GetTailElement (), &TurretEffectPtr);
-					if ((PELEMENT)TurretEffectPtr != ElementPtr
+					if (TurretEffectPtr != ElementPtr
 							&& (TurretEffectPtr->state_flags &
 							(GOOD_GUY | BAD_GUY)) ==
 							(ElementPtr->state_flags & (GOOD_GUY | BAD_GUY))
@@ -948,7 +961,7 @@ turret_postprocess (PELEMENT ElementPtr)
 					&& TrackShip (ShipPtr, &facing) >= 0
 					&& (hSpaceMarine = AllocElement ()))
 			{
-				ELEMENTPTR SpaceMarinePtr;
+				ELEMENT *SpaceMarinePtr;
 
 				LockElement (hSpaceMarine, &SpaceMarinePtr);
 				SpaceMarinePtr->state_flags =
@@ -999,9 +1012,9 @@ turret_postprocess (PELEMENT ElementPtr)
 }
 
 static void
-orz_preprocess (PELEMENT ElementPtr)
+orz_preprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (!(ElementPtr->state_flags & APPEARING))
@@ -1028,7 +1041,7 @@ orz_preprocess (PELEMENT ElementPtr)
 		hTurret = AllocElement ();
 		if (hTurret)
 		{
-			ELEMENTPTR TurretPtr;
+			ELEMENT *TurretPtr;
 
 			LockElement (hTurret, &TurretPtr);
 			TurretPtr->state_flags =
@@ -1050,16 +1063,14 @@ orz_preprocess (PELEMENT ElementPtr)
 	}
 }
 
-RACE_DESCPTR
+RACE_DESC*
 init_orz (void)
 {
-	RACE_DESCPTR RaceDescPtr;
+	RACE_DESC *RaceDescPtr;
 
 	orz_desc.preprocess_func = orz_preprocess;
 	orz_desc.init_weapon_func = initialize_turret_missile;
-	orz_desc.cyborg_control.intelligence_func =
-			(void (*) (PVOID ShipPtr, PVOID ObjectsOfConcern, COUNT
-					ConcernCounter)) orz_intelligence;
+	orz_desc.cyborg_control.intelligence_func = orz_intelligence;
 
 	RaceDescPtr = &orz_desc;
 
diff -ruNp src.orig/sc2code/ships/pkunk/icode.h src/sc2code/ships/pkunk/icode.h
--- src.orig/sc2code/ships/pkunk/icode.h	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/pkunk/icode.h	2017-11-08 16:50:06 -0600
@@ -1,3 +1,5 @@
-#define PKUNK_CODE 0x00200008L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define PKUNK_CODE "ship.pkunk.code"
diff -ruNp src.orig/sc2code/ships/pkunk/igfxres.h src/sc2code/ships/pkunk/igfxres.h
--- src.orig/sc2code/ships/pkunk/igfxres.h	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/pkunk/igfxres.h	2017-11-08 16:50:06 -0600
@@ -1,11 +1,13 @@
-#define PKUNK_ICON_MASK_PMAP_ANIM 0x00200002L
-#define PKUNK_MICON_MASK_PMAP_ANIM 0x00200102L
-#define PKUNK_BIG_MASK_PMAP_ANIM 0x00400202L
-#define PKUNK_MED_MASK_PMAP_ANIM 0x00400302L
-#define PKUNK_SML_MASK_PMAP_ANIM 0x00400402L
-#define BUG_BIG_MASK_PMAP_ANIM 0x00400502L
-#define BUG_MED_MASK_PMAP_ANIM 0x00400602L
-#define BUG_SML_MASK_PMAP_ANIM 0x00400702L
-#define PKUNK_CAPTAIN_MASK_PMAP_ANIM 0x00400802L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define BUG_BIG_MASK_PMAP_ANIM "ship.pkunk.graphics.bug.large"
+#define BUG_MED_MASK_PMAP_ANIM "ship.pkunk.graphics.bug.medium"
+#define BUG_SML_MASK_PMAP_ANIM "ship.pkunk.graphics.bug.small"
+#define PKUNK_BIG_MASK_PMAP_ANIM "ship.pkunk.graphics.pkunk.large"
+#define PKUNK_CAPTAIN_MASK_PMAP_ANIM "ship.pkunk.graphics.captain"
+#define PKUNK_ICON_MASK_PMAP_ANIM "ship.pkunk.icons"
+#define PKUNK_MED_MASK_PMAP_ANIM "ship.pkunk.graphics.pkunk.medium"
+#define PKUNK_MICON_MASK_PMAP_ANIM "ship.pkunk.meleeicons"
+#define PKUNK_SML_MASK_PMAP_ANIM "ship.pkunk.graphics.pkunk.small"
diff -ruNp src.orig/sc2code/ships/pkunk/imusicre.h src/sc2code/ships/pkunk/imusicre.h
--- src.orig/sc2code/ships/pkunk/imusicre.h	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/pkunk/imusicre.h	2017-11-08 16:50:06 -0600
@@ -1,3 +1,5 @@
-#define PKUNK_VICTORY_SONG 0x00400006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define PKUNK_VICTORY_SONG "ship.pkunk.ditty"
diff -ruNp src.orig/sc2code/ships/pkunk/isndres.h src/sc2code/ships/pkunk/isndres.h
--- src.orig/sc2code/ships/pkunk/isndres.h	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/pkunk/isndres.h	2017-11-08 16:50:06 -0600
@@ -1,3 +1,5 @@
-#define PKUNK_SHIP_SOUNDS 0x00400005L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define PKUNK_SHIP_SOUNDS "ship.pkunk.sounds"
diff -ruNp src.orig/sc2code/ships/pkunk/istrtab.h src/sc2code/ships/pkunk/istrtab.h
--- src.orig/sc2code/ships/pkunk/istrtab.h	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/pkunk/istrtab.h	2017-11-08 16:50:06 -0600
@@ -1,3 +1,5 @@
-#define PKUNK_RACE_STRINGS 0x00200004L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define PKUNK_RACE_STRINGS "ship.pkunk.text"
diff -ruNp src.orig/sc2code/ships/pkunk/pkunk.c src/sc2code/ships/pkunk/pkunk.c
--- src.orig/sc2code/ships/pkunk/pkunk.c	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/pkunk/pkunk.c	2017-11-08 16:50:06 -0600
@@ -19,6 +19,7 @@
 #include "ships/ship.h"
 #include "ships/pkunk/resinst.h"
 
+#include "settings.h"
 #include "globdata.h"
 #include "libs/mathlib.h"
 
@@ -42,18 +43,21 @@
 
 static RACE_DESC pkunk_desc =
 {
-	{
+	{ /* SHIP_INFO */
 		FIRES_FORE | FIRES_LEFT | FIRES_RIGHT,
 		20, /* Super Melee cost */
-		666 / SPHERE_RADIUS_INCREMENT, /* Initial sphere of influence radius */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY, MAX_ENERGY,
-		{
+		PKUNK_RACE_STRINGS,
+		PKUNK_ICON_MASK_PMAP_ANIM,
+		PKUNK_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		666 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
 			502, 401,
 		},
-		(STRING)PKUNK_RACE_STRINGS,
-		(FRAME)PKUNK_ICON_MASK_PMAP_ANIM,
-		(FRAME)PKUNK_MICON_MASK_PMAP_ANIM,
 	},
 	{
 		MAX_THRUST,
@@ -70,34 +74,35 @@ static RACE_DESC pkunk_desc =
 	},
 	{
 		{
-			(FRAME)PKUNK_BIG_MASK_PMAP_ANIM,
-			(FRAME)PKUNK_MED_MASK_PMAP_ANIM,
-			(FRAME)PKUNK_SML_MASK_PMAP_ANIM,
+			PKUNK_BIG_MASK_PMAP_ANIM,
+			PKUNK_MED_MASK_PMAP_ANIM,
+			PKUNK_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)BUG_BIG_MASK_PMAP_ANIM,
-			(FRAME)BUG_MED_MASK_PMAP_ANIM,
-			(FRAME)BUG_SML_MASK_PMAP_ANIM,
+			BUG_BIG_MASK_PMAP_ANIM,
+			BUG_MED_MASK_PMAP_ANIM,
+			BUG_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
 		},
 		{
-			(FRAME)PKUNK_CAPTAIN_MASK_PMAP_ANIM,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			PKUNK_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
 		},
-		(SOUND)PKUNK_VICTORY_SONG,
-		(SOUND)PKUNK_SHIP_SOUNDS,
+		PKUNK_VICTORY_SONG,
+		PKUNK_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
 	},
 	{
 		0,
 		CLOSE_RANGE_WEAPON + 1,
-		NULL_PTR,
+		NULL,
 	},
 	(UNINIT_FUNC *) NULL,
 	(PREPROCESS_FUNC *) NULL,
@@ -107,7 +112,7 @@ static RACE_DESC pkunk_desc =
 };
 
 static void
-animate (PELEMENT ElementPtr)
+animate (ELEMENT *ElementPtr)
 {
 	if (ElementPtr->turn_wait > 0)
 		--ElementPtr->turn_wait;
@@ -122,14 +127,14 @@ animate (PELEMENT ElementPtr)
 }
 
 static COUNT
-initialize_bug_missile (PELEMENT ShipPtr, HELEMENT MissileArray[])
+initialize_bug_missile (ELEMENT *ShipPtr, HELEMENT MissileArray[])
 {
 #define PKUNK_OFFSET 15
 #define MISSILE_HITS 1
 #define MISSILE_DAMAGE 1
 #define MISSILE_OFFSET 1
 	COUNT i;
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
@@ -144,7 +149,7 @@ initialize_bug_missile (PELEMENT ShipPtr
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
-	MissileBlock.preprocess_func = NULL_PTR;
+	MissileBlock.preprocess_func = NULL;
 	MissileBlock.blast_offs = MISSILE_OFFSET;
 
 	for (i = 0; i < 3; ++i)
@@ -159,7 +164,7 @@ initialize_bug_missile (PELEMENT ShipPtr
 		if ((MissileArray[i] = initialize_missile (&MissileBlock)))
 		{
 			SIZE dx, dy;
-			ELEMENTPTR MissilePtr;
+			ELEMENT *MissilePtr;
 
 			LockElement (MissileArray[i], &MissilePtr);
 			GetCurrentVelocityComponents (&ShipPtr->velocity, &dx, &dy);
@@ -178,9 +183,10 @@ initialize_bug_missile (PELEMENT ShipPtr
 static HELEMENT hPhoenix = 0;
 
 static void
-pkunk_intelligence (PELEMENT ShipPtr, PEVALUATE_DESC ObjectsOfConcern, COUNT ConcernCounter)
+pkunk_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+		COUNT ConcernCounter)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	if (hPhoenix && StarShipPtr->special_counter)
@@ -200,18 +206,18 @@ pkunk_intelligence (PELEMENT ShipPtr, PE
 	ship_intelligence (ShipPtr, ObjectsOfConcern, ConcernCounter);
 }
 
-static void pkunk_preprocess (PELEMENT ElementPtr);
-static void pkunk_postprocess (PELEMENT ElementPtr);
+static void pkunk_preprocess (ELEMENT *ElementPtr);
+static void pkunk_postprocess (ELEMENT *ElementPtr);
 
 static void
-new_pkunk (PELEMENT ElementPtr)
+new_pkunk (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (!(ElementPtr->state_flags & PLAYER_SHIP))
 	{
-		ELEMENTPTR ShipPtr;
+		ELEMENT *ShipPtr;
 
 		LockElement (StarShipPtr->hShip, &ShipPtr);
 		ShipPtr->death_func = new_pkunk;
@@ -226,7 +232,7 @@ new_pkunk (PELEMENT ElementPtr)
 		ElementPtr->preprocess_func = StarShipPtr->RaceDescPtr->preprocess_func;
 		ElementPtr->postprocess_func = StarShipPtr->RaceDescPtr->postprocess_func;
 		ElementPtr->death_func =
-				(void (*) (PELEMENT ElementPtr))
+				(void (*) (ELEMENT *ElementPtr))
 						StarShipPtr->RaceDescPtr->init_weapon_func;
 		StarShipPtr->RaceDescPtr->preprocess_func = pkunk_preprocess;
 		StarShipPtr->RaceDescPtr->postprocess_func = pkunk_postprocess;
@@ -241,13 +247,14 @@ new_pkunk (PELEMENT ElementPtr)
 		StarShipPtr->RaceDescPtr->characteristics.special_wait = 0;
 
 		StarShipPtr->ship_input_state = 0;
-		StarShipPtr->cur_status_flags =
-				StarShipPtr->old_status_flags = 0;
-		StarShipPtr->energy_counter =
-				StarShipPtr->weapon_counter =
-				StarShipPtr->special_counter = 0;
-		ElementPtr->crew_level =
-				ElementPtr->turn_wait = ElementPtr->thrust_wait = 0;
+		StarShipPtr->cur_status_flags = 0;
+		StarShipPtr->old_status_flags = 0;
+		StarShipPtr->energy_counter = 0;
+		StarShipPtr->weapon_counter = 0;
+		StarShipPtr->special_counter = 0;
+		ElementPtr->crew_level = 0;
+		ElementPtr->turn_wait = 0;
+		ElementPtr->thrust_wait = 0;
 		ElementPtr->life_span = NORMAL_LIFE;
 
 		StarShipPtr->ShipFacing = NORMALIZE_FACING (TFB_Random ());
@@ -273,9 +280,9 @@ new_pkunk (PELEMENT ElementPtr)
 }
 
 static void
-intercept_pkunk_death (PELEMENT ElementPtr)
+intercept_pkunk_death (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	ElementPtr->state_flags &= ~DISAPPEARING;
 	ElementPtr->life_span = 1;
@@ -283,7 +290,7 @@ intercept_pkunk_death (PELEMENT ElementP
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (StarShipPtr->RaceDescPtr->ship_info.crew_level == 0)
 	{
-		ELEMENTPTR ShipPtr;
+		ELEMENT *ShipPtr;
 
 		LockElement (StarShipPtr->hShip, &ShipPtr);
 		if (GRAVITY_MASS (ShipPtr->mass_points + 1))
@@ -297,8 +304,7 @@ intercept_pkunk_death (PELEMENT ElementP
 			StarShipPtr->RaceDescPtr->preprocess_func = ShipPtr->preprocess_func;
 			StarShipPtr->RaceDescPtr->postprocess_func = ShipPtr->postprocess_func;
 			StarShipPtr->RaceDescPtr->init_weapon_func =
-					(COUNT (*) (PELEMENT ElementPtr,
-							HELEMENT Weapon[]))
+					(COUNT (*) (ELEMENT *ElementPtr, HELEMENT Weapon[]))
 							ShipPtr->death_func;
 
 			ElementPtr->death_func = new_pkunk;
@@ -311,8 +317,7 @@ intercept_pkunk_death (PELEMENT ElementP
 #define TRANSITION_LIFE 1
 
 void
-spawn_phoenix_trail (PELEMENT
-		ElementPtr)
+spawn_phoenix_trail (ELEMENT *ElementPtr)
 {
 	static const COLOR color_tab[] =
 	{
@@ -362,19 +367,18 @@ spawn_phoenix_trail (PELEMENT
 #define PHOENIX_LIFE 12
 
 void
-phoenix_transition (PELEMENT
-		ElementPtr)
+phoenix_transition (ELEMENT *ElementPtr)
 {
 	HELEMENT hShipImage;
-	ELEMENTPTR ShipImagePtr;
-	STARSHIPPTR StarShipPtr;
+	ELEMENT *ShipImagePtr;
+	STARSHIP *StarShipPtr;
 	
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	LockElement (StarShipPtr->hShip, &ShipImagePtr);
 
 	if (!(ShipImagePtr->state_flags & NONSOLID))
 	{
-		ElementPtr->preprocess_func = NULL_PTR;
+		ElementPtr->preprocess_func = NULL;
 	}
 	else if ((hShipImage = AllocElement ()))
 	{
@@ -402,7 +406,7 @@ phoenix_transition (PELEMENT
 					COSINE (angle, TRANSITION_SPEED);
 			ShipImagePtr->current.location.y +=
 					SINE (angle, TRANSITION_SPEED);
-			ElementPtr->preprocess_func = NULL_PTR;
+			ElementPtr->preprocess_func = NULL;
 		}
 		else
 		{
@@ -433,15 +437,14 @@ phoenix_transition (PELEMENT
 }
 
 static void
-pkunk_preprocess (ElementPtr)
-PELEMENT ElementPtr;
+pkunk_preprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (ElementPtr->state_flags & APPEARING)
 	{
-		ELEMENTPTR PhoenixPtr;
+		ELEMENT *PhoenixPtr;
 
 		if (((BYTE)TFB_Random () & 1)
 				&& (hPhoenix = AllocElement ()))
@@ -467,9 +470,14 @@ PELEMENT ElementPtr;
 		{
 			COUNT angle, facing;
 
-			ProcessSound (SetAbsSoundIndex (
+			// kill any music that might be playing.
+			// The only possible candidate for this is
+			// the shofixti victory ditty -- if you are
+			// here, then the scout didn't really win
+			StopMusic ();
+			PlaySound (SetAbsSoundIndex (
 					StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 1
-					), ElementPtr);
+					), NotPositional (), NULL, GAME_SOUND_PRIORITY);
 
 			ElementPtr->life_span = PHOENIX_LIFE;
 			SetPrimType (&(GLOBAL (DisplayArray))[ElementPtr->PrimIndex],
@@ -505,7 +513,7 @@ PELEMENT ElementPtr;
 			InitIntersectStartPoint (ElementPtr);
 			InitIntersectEndPoint (ElementPtr);
 			InitIntersectFrame (ElementPtr);
-			ZeroVelocityComponents (&((ELEMENTPTR)ElementPtr)->velocity);
+			ZeroVelocityComponents (&ElementPtr->velocity);
 			ElementPtr->state_flags &= ~(NONSOLID | FINITE_LIFE);
 			ElementPtr->state_flags |= CHANGING;
 
@@ -515,10 +523,9 @@ PELEMENT ElementPtr;
 }
 
 static void
-pkunk_postprocess (ElementPtr)
-PELEMENT ElementPtr;
+pkunk_postprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (StarShipPtr->RaceDescPtr->characteristics.special_wait)
@@ -547,21 +554,15 @@ PELEMENT ElementPtr;
 	}
 }
 
-RACE_DESCPTR
+RACE_DESC*
 init_pkunk (void)
 {
-	RACE_DESCPTR RaceDescPtr;
+	RACE_DESC *RaceDescPtr;
 
 	pkunk_desc.preprocess_func = pkunk_preprocess;
 	pkunk_desc.postprocess_func = pkunk_postprocess;
 	pkunk_desc.init_weapon_func = initialize_bug_missile;
-	pkunk_desc.cyborg_control.intelligence_func =
-			(void (*) (PVOID ShipPtr,
-					PVOID
-					ObjectsOfConcern,
-					COUNT
-					ConcernCounter))
-					pkunk_intelligence;
+	pkunk_desc.cyborg_control.intelligence_func = pkunk_intelligence;
 
 	RaceDescPtr = &pkunk_desc;
 
diff -ruNp src.orig/sc2code/ships/probe/icode.h src/sc2code/ships/probe/icode.h
--- src.orig/sc2code/ships/probe/icode.h	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/probe/icode.h	2017-11-08 16:50:06 -0600
@@ -1,3 +1,5 @@
-#define PROBE_CODE 0x00200008L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define PROBE_CODE "ship.probe.code"
diff -ruNp src.orig/sc2code/ships/probe/igfxres.h src/sc2code/ships/probe/igfxres.h
--- src.orig/sc2code/ships/probe/igfxres.h	2017-11-08 16:49:38 -0600
+++ src/sc2code/ships/probe/igfxres.h	2017-11-08 16:50:06 -0600
@@ -1,3 +1,5 @@
-#define PROBE_MICON_MASK_PMAP_ANIM 0x00200002L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define PROBE_MICON_MASK_PMAP_ANIM "ship.probe.meleeicons"
diff -ruNp src.orig/sc2code/ships/probe/istrtab.h src/sc2code/ships/probe/istrtab.h
--- src.orig/sc2code/ships/probe/istrtab.h	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/probe/istrtab.h	2017-11-08 16:50:06 -0600
@@ -1,10 +1,6 @@
 #ifndef _ISTRTAB_H
 #define _ISTRTAB_H
 
-#define ARILOU_RACE_STRINGS 0x00200004L
-#define ARILOU_SHIP_SOUNDS 0x00400104L
-#define ARILOU_VICTORY_SONG 0x00600204L
-
 typedef RESOURCE STRTAB_INSTANCE;
 
 #endif /* _ISTRTAB_H */
diff -ruNp src.orig/sc2code/ships/probe/probe.c src/sc2code/ships/probe/probe.c
--- src.orig/sc2code/ships/probe/probe.c	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/probe/probe.c	2017-11-08 16:50:06 -0600
@@ -36,18 +36,21 @@
 
 static RACE_DESC probe_desc =
 {
-	{
+	{ /* SHIP_INFO */
 		0,
 		0, /* Super Melee cost */
-		0, /* Initial sphere of influence radius */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY, MAX_ENERGY,
-		{
-			0, 0,
-		},
 		0,
 		0,
-		(FRAME)PROBE_MICON_MASK_PMAP_ANIM,
+		PROBE_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
 	},
 	{
 		MAX_THRUST,
@@ -64,34 +67,35 @@ static RACE_DESC probe_desc =
 	},
 	{
 		{
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
 		},
 		{
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
 		},
 		{
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
 		},
 		{
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			NULL_RESOURCE,
+			NULL, NULL, NULL, NULL, NULL
 		},
-		(SOUND)0,
-		(SOUND)0,
+		NULL_RESOURCE,
+		NULL_RESOURCE,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
 	},
 	{
 		0,
 		0,
-		NULL_PTR,
+		NULL,
 	},
 	(UNINIT_FUNC *) NULL,
 	(PREPROCESS_FUNC *) NULL,
@@ -100,10 +104,10 @@ static RACE_DESC probe_desc =
 	0,
 };
 
-RACE_DESCPTR
+RACE_DESC*
 init_probe (void)
 {
-	RACE_DESCPTR RaceDescPtr;
+	RACE_DESC *RaceDescPtr;
 
 	RaceDescPtr = &probe_desc;
 
diff -ruNp src.orig/sc2code/ships/shofixti/icode.h src/sc2code/ships/shofixti/icode.h
--- src.orig/sc2code/ships/shofixti/icode.h	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/shofixti/icode.h	2017-11-08 16:50:06 -0600
@@ -1,3 +1,5 @@
-#define SHOFIXTI_CODE 0x00200008L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SHOFIXTI_CODE "ship.shofixti.code"
diff -ruNp src.orig/sc2code/ships/shofixti/igfxres.h src/sc2code/ships/shofixti/igfxres.h
--- src.orig/sc2code/ships/shofixti/igfxres.h	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/shofixti/igfxres.h	2017-11-08 16:50:06 -0600
@@ -1,18 +1,20 @@
-#define SHOFIXTI_ICON_MASK_PMAP_ANIM 0x00200002L
-#define SHOFIXTI_MICON_MASK_PMAP_ANIM 0x00200102L
-#define SHOFIXTI_BIG_MASK_PMAP_ANIM 0x00400202L
-#define SHOFIXTI_MED_MASK_PMAP_ANIM 0x00400302L
-#define SHOFIXTI_SML_MASK_PMAP_ANIM 0x00400402L
-#define DESTRUCT_BIG_MASK_ANIM 0x00400502L
-#define DESTRUCT_MED_MASK_ANIM 0x00400602L
-#define DESTRUCT_SML_MASK_ANIM 0x00400702L
-#define SHOFIXTI_CAPTAIN_MASK_PMAP_ANIM 0x00400802L
-#define OLDSHOF_BIG_MASK_PMAP_ANIM 0x00600902L
-#define OLDSHOF_MED_MASK_PMAP_ANIM 0x00600a02L
-#define OLDSHOF_SML_MASK_PMAP_ANIM 0x00600b02L
-#define OLDSHOF_CAPTAIN_MASK_PMAP_ANIM 0x00600c02L
-#define DART_BIG_MASK_PMAP_ANIM 0x00800d02L
-#define DART_MED_MASK_PMAP_ANIM 0x00800e02L
-#define DART_SML_MASK_PMAP_ANIM 0x00800f02L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define DART_BIG_MASK_PMAP_ANIM "ship.shofixti.graphics.missile.large"
+#define DART_MED_MASK_PMAP_ANIM "ship.shofixti.graphics.missile.medium"
+#define DART_SML_MASK_PMAP_ANIM "ship.shofixti.graphics.missile.small"
+#define DESTRUCT_BIG_MASK_ANIM "ship.shofixti.graphics.destruct.large"
+#define DESTRUCT_MED_MASK_ANIM "ship.shofixti.graphics.destruct.medium"
+#define DESTRUCT_SML_MASK_ANIM "ship.shofixti.graphics.destruct.small"
+#define OLDSHOF_BIG_MASK_PMAP_ANIM "ship.shofixti.graphics.oldshof.large"
+#define OLDSHOF_CAPTAIN_MASK_PMAP_ANIM "ship.shofixti.graphics.oldcaptain"
+#define OLDSHOF_MED_MASK_PMAP_ANIM "ship.shofixti.graphics.oldshof.medium"
+#define OLDSHOF_SML_MASK_PMAP_ANIM "ship.shofixti.graphics.oldshof.small"
+#define SHOFIXTI_BIG_MASK_PMAP_ANIM "ship.shofixti.graphics.shofixti.large"
+#define SHOFIXTI_CAPTAIN_MASK_PMAP_ANIM "ship.shofixti.graphics.captain"
+#define SHOFIXTI_ICON_MASK_PMAP_ANIM "ship.shofixti.icons"
+#define SHOFIXTI_MED_MASK_PMAP_ANIM "ship.shofixti.graphics.shofixti.medium"
+#define SHOFIXTI_MICON_MASK_PMAP_ANIM "ship.shofixti.meleeicons"
+#define SHOFIXTI_SML_MASK_PMAP_ANIM "ship.shofixti.graphics.shofixti.small"
diff -ruNp src.orig/sc2code/ships/shofixti/imusicre.h src/sc2code/ships/shofixti/imusicre.h
--- src.orig/sc2code/ships/shofixti/imusicre.h	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/shofixti/imusicre.h	2017-11-08 16:50:06 -0600
@@ -1,3 +1,5 @@
-#define SHOFIXTI_VICTORY_SONG 0x00800006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SHOFIXTI_VICTORY_SONG "ship.shofixti.ditty"
diff -ruNp src.orig/sc2code/ships/shofixti/isndres.h src/sc2code/ships/shofixti/isndres.h
--- src.orig/sc2code/ships/shofixti/isndres.h	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/shofixti/isndres.h	2017-11-08 16:50:06 -0600
@@ -1,3 +1,5 @@
-#define SHOFIXTI_SHIP_SOUNDS 0x00800005L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SHOFIXTI_SHIP_SOUNDS "ship.shofixti.sounds"
diff -ruNp src.orig/sc2code/ships/shofixti/istrtab.h src/sc2code/ships/shofixti/istrtab.h
--- src.orig/sc2code/ships/shofixti/istrtab.h	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/shofixti/istrtab.h	2017-11-08 16:50:06 -0600
@@ -1,3 +1,5 @@
-#define SHOFIXTI_RACE_STRINGS 0x00200004L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SHOFIXTI_RACE_STRINGS "ship.shofixti.text"
diff -ruNp src.orig/sc2code/ships/shofixti/shofixti.c src/sc2code/ships/shofixti/shofixti.c
--- src.orig/sc2code/ships/shofixti/shofixti.c	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/shofixti/shofixti.c	2017-11-08 16:50:06 -0600
@@ -42,18 +42,21 @@
 
 static RACE_DESC shofixti_desc =
 {
-	{
+	{ /* SHIP_INFO */
 		FIRES_FORE,
 		5, /* Super Melee cost */
-		0 / SPHERE_RADIUS_INCREMENT, /* Initial sphere of influence radius */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY, MAX_ENERGY,
-		{
+		SHOFIXTI_RACE_STRINGS,
+		SHOFIXTI_ICON_MASK_PMAP_ANIM,
+		SHOFIXTI_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
 			0, 0,
 		},
-		(STRING)SHOFIXTI_RACE_STRINGS,
-		(FRAME)SHOFIXTI_ICON_MASK_PMAP_ANIM,
-		(FRAME)SHOFIXTI_MICON_MASK_PMAP_ANIM,
 	},
 	{
 		MAX_THRUST,
@@ -70,34 +73,35 @@ static RACE_DESC shofixti_desc =
 	},
 	{
 		{
-			(FRAME)SHOFIXTI_BIG_MASK_PMAP_ANIM,
-			(FRAME)SHOFIXTI_MED_MASK_PMAP_ANIM,
-			(FRAME)SHOFIXTI_SML_MASK_PMAP_ANIM,
+			SHOFIXTI_BIG_MASK_PMAP_ANIM,
+			SHOFIXTI_MED_MASK_PMAP_ANIM,
+			SHOFIXTI_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)DART_BIG_MASK_PMAP_ANIM,
-			(FRAME)DART_MED_MASK_PMAP_ANIM,
-			(FRAME)DART_SML_MASK_PMAP_ANIM,
+			DART_BIG_MASK_PMAP_ANIM,
+			DART_MED_MASK_PMAP_ANIM,
+			DART_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)DESTRUCT_BIG_MASK_ANIM,
-			(FRAME)DESTRUCT_MED_MASK_ANIM,
-			(FRAME)DESTRUCT_SML_MASK_ANIM,
+			DESTRUCT_BIG_MASK_ANIM,
+			DESTRUCT_MED_MASK_ANIM,
+			DESTRUCT_SML_MASK_ANIM,
 		},
 		{
-			(FRAME)SHOFIXTI_CAPTAIN_MASK_PMAP_ANIM,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			SHOFIXTI_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
 		},
-		(SOUND)SHOFIXTI_VICTORY_SONG,
-		(SOUND)SHOFIXTI_SHIP_SOUNDS,
+	        SHOFIXTI_VICTORY_SONG,
+		SHOFIXTI_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
 	},
 	{
 		0,
 		MISSILE_SPEED * MISSILE_LIFE,
-		NULL_PTR,
+		NULL,
 	},
 	(UNINIT_FUNC *) NULL,
 	(PREPROCESS_FUNC *) NULL,
@@ -107,13 +111,13 @@ static RACE_DESC shofixti_desc =
 };
 
 static COUNT
-initialize_standard_missile (PELEMENT ShipPtr, HELEMENT MissileArray[])
+initialize_standard_missile (ELEMENT *ShipPtr, HELEMENT MissileArray[])
 {
 #define SHOFIXTI_OFFSET 15
 #define MISSILE_HITS 1
 #define MISSILE_DAMAGE 1
 #define MISSILE_OFFSET 1
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
@@ -128,7 +132,7 @@ initialize_standard_missile (PELEMENT Sh
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
-	MissileBlock.preprocess_func = NULL_PTR;
+	MissileBlock.preprocess_func = NULL;
 	MissileBlock.blast_offs = MISSILE_OFFSET;
 	MissileArray[0] = initialize_missile (&MissileBlock);
 
@@ -136,10 +140,10 @@ initialize_standard_missile (PELEMENT Sh
 }
 
 static void
-destruct_preprocess (PELEMENT ElementPtr)
+destruct_preprocess (ELEMENT *ElementPtr)
 {
 #define DESTRUCT_SWITCH ((NUM_EXPLOSION_FRAMES * 3) - 3)
-	PPRIMITIVE lpPrim;
+	PRIMITIVE *lpPrim;
 
 	lpPrim = &(GLOBAL (DisplayArray))[ElementPtr->PrimIndex];
 	ElementPtr->state_flags |= CHANGING;
@@ -169,13 +173,13 @@ destruct_preprocess (PELEMENT ElementPtr
 		HELEMENT hDestruct;
 
 		SetPrimType (lpPrim, NO_PRIM);
-		ElementPtr->preprocess_func = NULL_PTR;
+		ElementPtr->preprocess_func = NULL;
 
 		hDestruct = AllocElement ();
 		if (hDestruct)
 		{
-			ELEMENTPTR DestructPtr;
-			STARSHIPPTR StarShipPtr;
+			ELEMENT *DestructPtr;
+			STARSHIP *StarShipPtr;
 
 			GetElementStarShip (ElementPtr, &StarShipPtr);
 
@@ -200,7 +204,7 @@ destruct_preprocess (PELEMENT ElementPtr
 				DestructPtr->preprocess_func = destruct_preprocess;
 			}
 			DestructPtr->postprocess_func =
-					DestructPtr->death_func = NULL_PTR;
+					DestructPtr->death_func = NULL;
 			ZeroVelocityComponents (&DestructPtr->velocity);
 			UnlockElement (hDestruct);
 		}
@@ -209,15 +213,15 @@ destruct_preprocess (PELEMENT ElementPtr
 
 /* In order to detect any Orz Marines that have boarded the ship
    when it self-destructs, we'll need to see these Orz functions */
-void intruder_preprocess (PELEMENT);
-void marine_collision (PELEMENT, PPOINT, PELEMENT, PPOINT);
+extern void intruder_preprocess (ELEMENT*);
+extern void marine_collision (ELEMENT*, POINT*, ELEMENT*, POINT*);
 #define ORZ_MARINE(ptr) (ptr->preprocess_func == intruder_preprocess && \
 		ptr->collision_func == marine_collision)
 
 static void
-self_destruct (PELEMENT ElementPtr)
+self_destruct (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (ElementPtr->state_flags & PLAYER_SHIP)
@@ -227,7 +231,7 @@ self_destruct (PELEMENT ElementPtr)
 		hDestruct = AllocElement ();
 		if (hDestruct)
 		{
-			ELEMENTPTR DestructPtr;
+			ELEMENT *DestructPtr;
 
 			LockElement (hDestruct, &DestructPtr);
 			DestructPtr->state_flags = APPEARING | NONSOLID | FINITE_LIFE |
@@ -256,7 +260,7 @@ self_destruct (PELEMENT ElementPtr)
 		for (hElement = GetHeadElement ();
 				hElement != 0; hElement = hNextElement)
 		{
-			ELEMENTPTR ObjPtr;
+			ELEMENT *ObjPtr;
 
 			LockElement (hElement, &ObjPtr);
 			hNextElement = GetSuccElement (ObjPtr);
@@ -311,90 +315,97 @@ self_destruct (PELEMENT ElementPtr)
 }
 
 static void
-shofixti_intelligence (PELEMENT ShipPtr, PEVALUATE_DESC ObjectsOfConcern, COUNT ConcernCounter)
+shofixti_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+		COUNT ConcernCounter)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
-	ship_intelligence (ShipPtr,
-			ObjectsOfConcern, ConcernCounter);
+	ship_intelligence (ShipPtr, ObjectsOfConcern, ConcernCounter);
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
-	if (StarShipPtr->special_counter == 0)
+	if (StarShipPtr->special_counter != 0)
+		return;
+
+	if (StarShipPtr->ship_input_state & SPECIAL)
+		StarShipPtr->ship_input_state &= ~SPECIAL;
+	else
 	{
-		if (StarShipPtr->ship_input_state & SPECIAL)
-			StarShipPtr->ship_input_state &= ~SPECIAL;
-		else
-		{
-			PEVALUATE_DESC lpWeaponEvalDesc, lpShipEvalDesc;
+		EVALUATE_DESC *lpWeaponEvalDesc;
+		EVALUATE_DESC *lpShipEvalDesc;
 
-			lpWeaponEvalDesc = &ObjectsOfConcern[ENEMY_WEAPON_INDEX];
-			lpShipEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
-			if (StarShipPtr->RaceDescPtr->ship_data.special[0]
-					&& (GetFrameCount (StarShipPtr->RaceDescPtr->ship_data.captain_control.special)
-					- GetFrameIndex (StarShipPtr->RaceDescPtr->ship_data.captain_control.special) > 5
-					|| (lpShipEvalDesc->ObjectPtr != NULL_PTR
-					&& lpShipEvalDesc->which_turn <= 4)
-					|| (lpWeaponEvalDesc->ObjectPtr != NULL_PTR
-								/* means IMMEDIATE WEAPON */
-					&& (((lpWeaponEvalDesc->ObjectPtr->state_flags & PLAYER_SHIP)
-					&& ShipPtr->crew_level == 1)
-					|| (PlotIntercept (lpWeaponEvalDesc->ObjectPtr, ShipPtr, 2, 0)
-					&& lpWeaponEvalDesc->ObjectPtr->mass_points >= ShipPtr->crew_level
-					&& (TFB_Random () & 1))))))
-				StarShipPtr->ship_input_state |= SPECIAL;
-		}
+		lpWeaponEvalDesc = &ObjectsOfConcern[ENEMY_WEAPON_INDEX];
+		lpShipEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
+		if (StarShipPtr->RaceDescPtr->ship_data.special[0]
+				&& (GetFrameCount (StarShipPtr->RaceDescPtr->ship_data.
+				captain_control.special)
+				- GetFrameIndex (StarShipPtr->RaceDescPtr->ship_data.
+				captain_control.special) > 5
+				|| (lpShipEvalDesc->ObjectPtr != NULL
+				&& lpShipEvalDesc->which_turn <= 4)
+				|| (lpWeaponEvalDesc->ObjectPtr != NULL
+							/* means IMMEDIATE WEAPON */
+				&& (((lpWeaponEvalDesc->ObjectPtr->state_flags & PLAYER_SHIP)
+				&& ShipPtr->crew_level == 1)
+				|| (PlotIntercept (lpWeaponEvalDesc->ObjectPtr, ShipPtr, 2, 0)
+				&& lpWeaponEvalDesc->ObjectPtr->mass_points >=
+				ShipPtr->crew_level
+				&& (TFB_Random () & 1))))))
+			StarShipPtr->ship_input_state |= SPECIAL;
 	}
 }
 
 static void
-shofixti_postprocess (PELEMENT ElementPtr)
+shofixti_postprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if ((StarShipPtr->cur_status_flags
 			^ StarShipPtr->old_status_flags) & SPECIAL)
 	{
 		StarShipPtr->RaceDescPtr->ship_data.captain_control.special =
-				IncFrameIndex (StarShipPtr->RaceDescPtr->ship_data.captain_control.special);
-		if (GetFrameCount (StarShipPtr->RaceDescPtr->ship_data.captain_control.special)
-				- GetFrameIndex (StarShipPtr->RaceDescPtr->ship_data.captain_control.special) == 3)
+				IncFrameIndex (StarShipPtr->RaceDescPtr->ship_data.
+				captain_control.special);
+		if (GetFrameCount (StarShipPtr->RaceDescPtr->ship_data.
+				captain_control.special)
+				- GetFrameIndex (StarShipPtr->RaceDescPtr->ship_data.
+				captain_control.special) == 3)
 			self_destruct (ElementPtr);
 	}
 }
 
-RACE_DESCPTR
+RACE_DESC*
 init_shofixti (void)
 {
-	RACE_DESCPTR RaceDescPtr;
+	RACE_DESC *RaceDescPtr;
 
 	static RACE_DESC new_shofixti_desc;
 
 	shofixti_desc.postprocess_func = shofixti_postprocess;
 	shofixti_desc.init_weapon_func = initialize_standard_missile;
-	shofixti_desc.cyborg_control.intelligence_func =
-			(void (*) (PVOID ShipPtr, PVOID ObjectsOfConcern, COUNT
-					ConcernCounter)) shofixti_intelligence;
+	shofixti_desc.cyborg_control.intelligence_func = shofixti_intelligence;
 
 	new_shofixti_desc = shofixti_desc;
 	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_ENCOUNTER
 			&& !GET_GAME_STATE (SHOFIXTI_RECRUITED))
 	{
+		// Tanaka/Katana flies in a damaged ship.
 #define NUM_LIMPETS 3
 		COUNT i;
 
-		new_shofixti_desc.ship_data.ship[0] = (FRAME)OLDSHOF_BIG_MASK_PMAP_ANIM;
-		new_shofixti_desc.ship_data.ship[1] = (FRAME)OLDSHOF_MED_MASK_PMAP_ANIM;
-		new_shofixti_desc.ship_data.ship[2] = (FRAME)OLDSHOF_SML_MASK_PMAP_ANIM;
-		new_shofixti_desc.ship_data.special[0] =
-				new_shofixti_desc.ship_data.special[1] =
-				new_shofixti_desc.ship_data.special[2] = (FRAME)0;
-		new_shofixti_desc.ship_data.captain_control.background =
-				(FRAME)OLDSHOF_CAPTAIN_MASK_PMAP_ANIM;
+		new_shofixti_desc.ship_data.ship_rsc[0] = OLDSHOF_BIG_MASK_PMAP_ANIM;
+		new_shofixti_desc.ship_data.ship_rsc[1] = OLDSHOF_MED_MASK_PMAP_ANIM;
+		new_shofixti_desc.ship_data.ship_rsc[2] = OLDSHOF_SML_MASK_PMAP_ANIM;
+		new_shofixti_desc.ship_data.special_rsc[0] = NULL_RESOURCE;
+		new_shofixti_desc.ship_data.special_rsc[1] = NULL_RESOURCE;
+		new_shofixti_desc.ship_data.special_rsc[2] = NULL_RESOURCE;
+		new_shofixti_desc.ship_data.captain_control.captain_rsc =
+				OLDSHOF_CAPTAIN_MASK_PMAP_ANIM;
 
-				/* weapon doesn't work as well */
+		/* Weapon doesn't work as well */
 		new_shofixti_desc.characteristics.weapon_wait = 10;
-				/* simulate VUX limpets */
+		
+		/* Simulate VUX limpets */
 		for (i = 0; i < NUM_LIMPETS; ++i)
 		{
 			if (++new_shofixti_desc.characteristics.turn_wait == 0)
@@ -402,7 +413,8 @@ init_shofixti (void)
 			if (++new_shofixti_desc.characteristics.thrust_wait == 0)
 				--new_shofixti_desc.characteristics.thrust_wait;
 #define MIN_THRUST_INCREMENT DISPLAY_TO_WORLD (1)
-			if (new_shofixti_desc.characteristics.thrust_increment <= MIN_THRUST_INCREMENT)
+			if (new_shofixti_desc.characteristics.thrust_increment <=
+					MIN_THRUST_INCREMENT)
 			{
 				new_shofixti_desc.characteristics.max_thrust =
 						new_shofixti_desc.characteristics.thrust_increment << 1;
@@ -415,7 +427,8 @@ init_shofixti (void)
 						new_shofixti_desc.characteristics.thrust_increment;
 				--new_shofixti_desc.characteristics.thrust_increment;
 				new_shofixti_desc.characteristics.max_thrust =
-						new_shofixti_desc.characteristics.thrust_increment * num_thrusts;
+						new_shofixti_desc.characteristics.thrust_increment *
+						num_thrusts;
 			}
 		}
 	}
diff -ruNp src.orig/sc2code/ships/sis_ship/icode.h src/sc2code/ships/sis_ship/icode.h
--- src.orig/sc2code/ships/sis_ship/icode.h	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/sis_ship/icode.h	2017-11-08 16:50:06 -0600
@@ -1,3 +1,5 @@
-#define SIS_CODE 0x00200008L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SIS_CODE "ship.sis_ship.code"
diff -ruNp src.orig/sc2code/ships/sis_ship/igfxres.h src/sc2code/ships/sis_ship/igfxres.h
--- src.orig/sc2code/ships/sis_ship/igfxres.h	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/sis_ship/igfxres.h	2017-11-08 16:50:06 -0600
@@ -1,11 +1,13 @@
-#define SIS_ICON_MASK_PMAP_ANIM 0x00400002L
-#define SIS_BIG_MASK_PMAP_ANIM 0x00400102L
-#define SIS_MED_MASK_PMAP_ANIM 0x00400202L
-#define SIS_SML_MASK_PMAP_ANIM 0x00400302L
-#define BLASTER_BIG_MASK_PMAP_ANIM 0x00400402L
-#define BLASTER_MED_MASK_PMAP_ANIM 0x00400502L
-#define BLASTER_SML_MASK_PMAP_ANIM 0x00400602L
-#define SIS_CAPTAIN_MASK_PMAP_ANIM 0x00400702L
-#define SIS_HYPER_MASK_PMAP_ANIM 0x00600802L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define BLASTER_BIG_MASK_PMAP_ANIM "ship.sis_ship.graphics.blas.large"
+#define BLASTER_MED_MASK_PMAP_ANIM "ship.sis_ship.graphics.blas.medium"
+#define BLASTER_SML_MASK_PMAP_ANIM "ship.sis_ship.graphics.blas.small"
+#define SIS_BIG_MASK_PMAP_ANIM "ship.sis_ship.graphics.sis.large"
+#define SIS_CAPTAIN_MASK_PMAP_ANIM "ship.sis_ship.graphics.captain"
+#define SIS_HYPER_MASK_PMAP_ANIM "ship.sis_ship.graphics.sishyper"
+#define SIS_ICON_MASK_PMAP_ANIM "ship.sis_ship.icons"
+#define SIS_MED_MASK_PMAP_ANIM "ship.sis_ship.graphics.sis.medium"
+#define SIS_SML_MASK_PMAP_ANIM "ship.sis_ship.graphics.sis.small"
diff -ruNp src.orig/sc2code/ships/sis_ship/imusicre.h src/sc2code/ships/sis_ship/imusicre.h
--- src.orig/sc2code/ships/sis_ship/imusicre.h	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/sis_ship/imusicre.h	2017-11-08 16:50:06 -0600
@@ -1,3 +1,5 @@
-#define SIS_VICTORY_SONG 0x00400006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SIS_VICTORY_SONG "ship.sis_ship.ditty"
diff -ruNp src.orig/sc2code/ships/sis_ship/isndres.h src/sc2code/ships/sis_ship/isndres.h
--- src.orig/sc2code/ships/sis_ship/isndres.h	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/sis_ship/isndres.h	2017-11-08 16:50:06 -0600
@@ -1,3 +1,5 @@
-#define SIS_SHIP_SOUNDS 0x00400005L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SIS_SHIP_SOUNDS "ship.sis_ship.sounds"
diff -ruNp src.orig/sc2code/ships/sis_ship/sis_ship.c src/sc2code/ships/sis_ship/sis_ship.c
--- src.orig/sc2code/ships/sis_ship/sis_ship.c	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/sis_ship/sis_ship.c	2017-11-08 16:50:06 -0600
@@ -48,18 +48,21 @@
 
 static RACE_DESC sis_desc =
 {
-	{
+	{ /* SHIP_INFO */
 		0,
 		16, /* Super Melee cost */
-		0 / SPHERE_RADIUS_INCREMENT, /* Initial sphere of influence radius */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY, MAX_ENERGY,
-		{
+		NULL_RESOURCE,
+		SIS_ICON_MASK_PMAP_ANIM,
+		NULL_RESOURCE,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
 			0, 0,
 		},
-		0,
-		(FRAME)SIS_ICON_MASK_PMAP_ANIM,
-		0,
 	},
 	{
 		MAX_THRUST,
@@ -76,34 +79,35 @@ static RACE_DESC sis_desc =
 	},
 	{
 		{
-			(FRAME)SIS_BIG_MASK_PMAP_ANIM,
-			(FRAME)SIS_MED_MASK_PMAP_ANIM,
-			(FRAME)SIS_SML_MASK_PMAP_ANIM,
+			SIS_BIG_MASK_PMAP_ANIM,
+			SIS_MED_MASK_PMAP_ANIM,
+			SIS_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)BLASTER_BIG_MASK_PMAP_ANIM,
-			(FRAME)BLASTER_MED_MASK_PMAP_ANIM,
-			(FRAME)BLASTER_SML_MASK_PMAP_ANIM,
+			BLASTER_BIG_MASK_PMAP_ANIM,
+			BLASTER_MED_MASK_PMAP_ANIM,
+			BLASTER_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
 		},
 		{
-			(FRAME)SIS_CAPTAIN_MASK_PMAP_ANIM,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			SIS_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
 		},
-		(SOUND)SIS_VICTORY_SONG,
-		(SOUND)SIS_SHIP_SOUNDS,
+		SIS_VICTORY_SONG,
+		SIS_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
 	},
 	{
 		0,
 		BLASTER_SPEED * BLASTER_LIFE,
-		NULL_PTR,
+		NULL,
 	},
 	(UNINIT_FUNC *) NULL,
 	(PREPROCESS_FUNC *) NULL,
@@ -112,22 +116,22 @@ static RACE_DESC sis_desc =
 	0,
 };
 
-static void InitModuleSlots (RACE_DESCPTR RaceDescPtr,
+static void InitModuleSlots (RACE_DESC *RaceDescPtr,
 		const BYTE *ModuleSlots);
-static void InitDriveSlots (RACE_DESCPTR RaceDescPtr,
+static void InitDriveSlots (RACE_DESC *RaceDescPtr,
 		const BYTE *DriveSlots);
-static void InitJetSlots (RACE_DESCPTR RaceDescPtr,
+static void InitJetSlots (RACE_DESC *RaceDescPtr,
 		const BYTE *JetSlots);
-void uninit_sis (RACE_DESCPTR pRaceDesc);
+void uninit_sis (RACE_DESC *pRaceDesc);
 
 static BYTE num_trackers = 0;
 
 static void
-sis_hyper_preprocess (PELEMENT ElementPtr)
+sis_hyper_preprocess (ELEMENT *ElementPtr)
 {
 	SIZE udx, udy, dx, dy;
 	SIZE AccelerateDirection;
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	if (ElementPtr->state_flags & APPEARING)
 		ElementPtr->velocity = GLOBAL (velocity);
@@ -276,9 +280,9 @@ LeaveAutoPilot:
 }
 
 static void
-sis_hyper_postprocess (PELEMENT ElementPtr)
+sis_hyper_postprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GLOBAL (velocity) = ElementPtr->velocity;
 
@@ -295,9 +299,9 @@ sis_hyper_postprocess (PELEMENT ElementP
 }
 
 static void
-spawn_point_defense (PELEMENT ElementPtr)
+spawn_point_defense (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (ElementPtr->state_flags & PLAYER_SHIP)
@@ -307,7 +311,7 @@ spawn_point_defense (PELEMENT ElementPtr
 		hDefense = AllocElement ();
 		if (hDefense)
 		{
-			ELEMENTPTR DefensePtr;
+			ELEMENT *DefensePtr;
 
 			LockElement (hDefense, &DefensePtr);
 			DefensePtr->state_flags = APPEARING | NONSOLID | FINITE_LIFE |
@@ -326,7 +330,7 @@ spawn_point_defense (PELEMENT ElementPtr
 	{
 		BOOLEAN PaidFor;
 		HELEMENT hObject, hNextObject;
-		ELEMENTPTR ShipPtr;
+		ELEMENT *ShipPtr;
 		COLOR LaserColor;
 		static const COLOR ColorRange[] =
 		{
@@ -348,7 +352,7 @@ spawn_point_defense (PELEMENT ElementPtr
 		LockElement (StarShipPtr->hShip, &ShipPtr);
 		for (hObject = GetTailElement (); hObject; hObject = hNextObject)
 		{
-			ELEMENTPTR ObjectPtr;
+			ELEMENT *ObjectPtr;
 
 			LockElement (hObject, &ObjectPtr);
 			hNextObject = GetPredElement (ObjectPtr);
@@ -406,7 +410,7 @@ spawn_point_defense (PELEMENT ElementPtr
 					hPointDefense = initialize_laser (&LaserBlock);
 					if (hPointDefense)
 					{
-						ELEMENTPTR PDPtr;
+						ELEMENT *PDPtr;
 
 						LockElement (hPointDefense, &PDPtr);
 						PDPtr->mass_points =
@@ -426,9 +430,9 @@ spawn_point_defense (PELEMENT ElementPtr
 }
 
 static void
-sis_battle_preprocess (PELEMENT ElementPtr)
+sis_battle_preprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (StarShipPtr->RaceDescPtr->characteristics.special_energy_cost == 0)
@@ -445,9 +449,9 @@ sis_battle_preprocess (PELEMENT ElementP
 }
 
 static void
-sis_battle_postprocess (PELEMENT ElementPtr)
+sis_battle_postprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if ((StarShipPtr->cur_status_flags & SPECIAL)
@@ -461,14 +465,15 @@ sis_battle_postprocess (PELEMENT Element
 #define BLASTER_DAMAGE 2
 
 static void
-blaster_collision (PELEMENT ElementPtr0, PPOINT pPt0, PELEMENT ElementPtr1, PPOINT pPt1)
+blaster_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
 	HELEMENT hBlastElement;
 
 	hBlastElement = weapon_collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
 	if (hBlastElement)
 	{
-		ELEMENTPTR BlastElementPtr;
+		ELEMENT *BlastElementPtr;
 
 		LockElement (hBlastElement, &BlastElementPtr);
 		switch (ElementPtr0->mass_points)
@@ -477,7 +482,7 @@ blaster_collision (PELEMENT ElementPtr0,
 				BlastElementPtr->life_span = 2;
 				BlastElementPtr->current.image.frame =
 						SetAbsFrameIndex (ElementPtr0->current.image.frame, 0);
-				BlastElementPtr->preprocess_func = NULL_PTR;
+				BlastElementPtr->preprocess_func = NULL;
 				break;
 			case BLASTER_DAMAGE * 2:
 				BlastElementPtr->life_span = 6;
@@ -495,7 +500,7 @@ blaster_collision (PELEMENT ElementPtr0,
 }
 
 static void
-blaster_preprocess (PELEMENT ElementPtr)
+blaster_preprocess (ELEMENT *ElementPtr)
 {
 	BYTE wait;
 
@@ -536,7 +541,7 @@ blaster_preprocess (PELEMENT ElementPtr)
 }
 
 static COUNT
-initialize_blasters (PELEMENT ShipPtr, HELEMENT BlasterArray[])
+initialize_blasters (ELEMENT *ShipPtr, HELEMENT BlasterArray[])
 {
 #define SIS_VERT_OFFSET 28
 #define SIS_HORZ_OFFSET 20
@@ -546,9 +551,9 @@ initialize_blasters (PELEMENT ShipPtr, H
 
 	BYTE nt;
 	COUNT i;
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock[6];
-	PMISSILE_BLOCK lpMB;
+	MISSILE_BLOCK *lpMB;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 
@@ -628,7 +633,7 @@ initialize_blasters (PELEMENT ShipPtr, H
 	{
 		if ((BlasterArray[i] = initialize_missile (lpMB)))
 		{
-			ELEMENTPTR BlasterPtr;
+			ELEMENT *BlasterPtr;
 
 			LockElement (BlasterArray[i], &BlasterPtr);
 			BlasterPtr->collision_func = blaster_collision;
@@ -641,11 +646,11 @@ initialize_blasters (PELEMENT ShipPtr, H
 }
 
 static void
-sis_intelligence (PELEMENT ShipPtr, PEVALUATE_DESC ObjectsOfConcern,
+sis_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
 		COUNT ConcernCounter)
 {
-	PEVALUATE_DESC lpEvalDesc;
-	STARSHIPPTR StarShipPtr;
+	EVALUATE_DESC *lpEvalDesc;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 
@@ -657,12 +662,12 @@ sis_intelligence (PELEMENT ShipPtr, PEVA
 			if (StarShipPtr->special_counter == 0
 					&& ((lpEvalDesc->ObjectPtr
 					&& lpEvalDesc->which_turn <= 2)
-					|| (ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr != NULL_PTR
+					|| (ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr != NULL
 					&& ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn <= 4)))
 				StarShipPtr->ship_input_state |= SPECIAL;
 			else
 				StarShipPtr->ship_input_state &= ~SPECIAL;
-			lpEvalDesc->ObjectPtr = NULL_PTR;
+			lpEvalDesc->ObjectPtr = NULL;
 		}
 		else if (MANEUVERABILITY (&StarShipPtr->RaceDescPtr->cyborg_control)
 				< MEDIUM_SHIP
@@ -714,7 +719,8 @@ sis_intelligence (PELEMENT ShipPtr, PEVA
 }
 
 static void
-InitModuleSlots (RACE_DESCPTR RaceDescPtr, const BYTE *ModuleSlots) {
+InitModuleSlots (RACE_DESC *RaceDescPtr, const BYTE *ModuleSlots)
+{
 	COUNT i;
 
 	RaceDescPtr->ship_info.max_crew = 0;
@@ -771,7 +777,8 @@ InitModuleSlots (RACE_DESCPTR RaceDescPt
 }
 
 static void
-InitDriveSlots (RACE_DESCPTR RaceDescPtr, const BYTE *DriveSlots) {
+InitDriveSlots (RACE_DESC *RaceDescPtr, const BYTE *DriveSlots)
+{
 	COUNT i;
 
 	// NB. RaceDescPtr->characteristics.max_thrust is already initialised.
@@ -795,7 +802,8 @@ InitDriveSlots (RACE_DESCPTR RaceDescPtr
 }
 
 static void
-InitJetSlots (RACE_DESCPTR RaceDescPtr, const BYTE *JetSlots) {
+InitJetSlots (RACE_DESC *RaceDescPtr, const BYTE *JetSlots)
+{
 	COUNT i;
 
 	for (i = 0; i < NUM_JET_SLOTS; ++i)
@@ -809,10 +817,10 @@ InitJetSlots (RACE_DESCPTR RaceDescPtr,
 	}
 }
 
-RACE_DESCPTR
+RACE_DESC*
 init_sis (void)
 {
-	RACE_DESCPTR RaceDescPtr;
+	RACE_DESC *RaceDescPtr;
 
 	COUNT i;
 	static RACE_DESC new_sis_desc;
@@ -826,16 +834,16 @@ init_sis (void)
 	{
 		for (i = 0; i < NUM_VIEWS; ++i)
 		{
-			new_sis_desc.ship_data.ship[i] = 0;
-			new_sis_desc.ship_data.weapon[i] = 0;
-			new_sis_desc.ship_data.special[i] = 0;
-		}
-		new_sis_desc.ship_info.icons = 0;
-		new_sis_desc.ship_data.captain_control.background = 0;
-		new_sis_desc.ship_data.victory_ditty = 0;
-		new_sis_desc.ship_data.ship_sounds = 0;
+			new_sis_desc.ship_data.ship_rsc[i] = NULL_RESOURCE;
+			new_sis_desc.ship_data.weapon_rsc[i] = NULL_RESOURCE;
+			new_sis_desc.ship_data.special_rsc[i] = NULL_RESOURCE;
+		}
+		new_sis_desc.ship_info.icons_rsc = NULL_RESOURCE;
+		new_sis_desc.ship_data.captain_control.captain_rsc = NULL_RESOURCE;
+		new_sis_desc.ship_data.victory_ditty_rsc = NULL_RESOURCE;
+		new_sis_desc.ship_data.ship_sounds_rsc = NULL_RESOURCE;
 
-		new_sis_desc.ship_data.ship[0] = (FRAME)SIS_HYPER_MASK_PMAP_ANIM;
+		new_sis_desc.ship_data.ship_rsc[0] = SIS_HYPER_MASK_PMAP_ANIM;
 
 		new_sis_desc.preprocess_func = sis_hyper_preprocess;
 		new_sis_desc.postprocess_func = sis_hyper_postprocess;
@@ -847,9 +855,7 @@ init_sis (void)
 		new_sis_desc.preprocess_func = sis_battle_preprocess;
 		new_sis_desc.postprocess_func = sis_battle_postprocess;
 		new_sis_desc.init_weapon_func = initialize_blasters;
-		new_sis_desc.cyborg_control.intelligence_func =
-				(void (*) (PVOID ShipPtr, PVOID ObjectsOfConcern,
-				COUNT ConcernCounter)) sis_intelligence;
+		new_sis_desc.cyborg_control.intelligence_func = sis_intelligence;
 
 		if (GET_GAME_STATE (CHMMR_BOMB_STATE) == 3)
 			SET_GAME_STATE (BOMB_CARRIER, 1);
@@ -879,7 +885,7 @@ init_sis (void)
 }
 
 void
-uninit_sis (RACE_DESCPTR pRaceDesc)
+uninit_sis (RACE_DESC *pRaceDesc)
 {
 	if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
 	{
diff -ruNp src.orig/sc2code/ships/slylandr/icode.h src/sc2code/ships/slylandr/icode.h
--- src.orig/sc2code/ships/slylandr/icode.h	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/slylandr/icode.h	2017-11-08 16:50:06 -0600
@@ -1,3 +1,5 @@
-#define SLYLANDRO_CODE 0x00200008L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SLYLANDRO_CODE "ship.slylandro.code"
diff -ruNp src.orig/sc2code/ships/slylandr/igfxres.h src/sc2code/ships/slylandr/igfxres.h
--- src.orig/sc2code/ships/slylandr/igfxres.h	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/slylandr/igfxres.h	2017-11-08 16:50:06 -0600
@@ -1,8 +1,10 @@
-#define SLYLANDRO_ICON_MASK_PMAP_ANIM 0x00200002L
-#define SLYLANDRO_MICON_MASK_PMAP_ANIM 0x00200102L
-#define SLYLANDRO_BIG_MASK_PMAP_ANIM 0x00400202L
-#define SLYLANDRO_MED_MASK_PMAP_ANIM 0x00400302L
-#define SLYLANDRO_SML_MASK_PMAP_ANIM 0x00400402L
-#define SLYLANDRO_CAPTAIN_MASK_PMAP_ANIM 0x00400502L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SLYLANDRO_BIG_MASK_PMAP_ANIM "ship.slylandro.graphics.slylandr.large"
+#define SLYLANDRO_CAPTAIN_MASK_PMAP_ANIM "ship.slylandro.graphics.captain"
+#define SLYLANDRO_ICON_MASK_PMAP_ANIM "ship.slylandro.icons"
+#define SLYLANDRO_MED_MASK_PMAP_ANIM "ship.slylandro.graphics.slylandr.medium"
+#define SLYLANDRO_MICON_MASK_PMAP_ANIM "ship.slylandro.meleeicons"
+#define SLYLANDRO_SML_MASK_PMAP_ANIM "ship.slylandro.graphics.slylandr.small"
diff -ruNp src.orig/sc2code/ships/slylandr/imusicre.h src/sc2code/ships/slylandr/imusicre.h
--- src.orig/sc2code/ships/slylandr/imusicre.h	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/slylandr/imusicre.h	2017-11-08 16:50:06 -0600
@@ -1,3 +1,5 @@
-#define SLYLANDRO_VICTORY_SONG 0x00400006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SLYLANDRO_VICTORY_SONG "ship.slylandro.ditty"
diff -ruNp src.orig/sc2code/ships/slylandr/isndres.h src/sc2code/ships/slylandr/isndres.h
--- src.orig/sc2code/ships/slylandr/isndres.h	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/slylandr/isndres.h	2017-11-08 16:50:06 -0600
@@ -1,3 +1,5 @@
-#define SLYLANDRO_SHIP_SOUNDS 0x00400005L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SLYLANDRO_SHIP_SOUNDS "ship.slylandro.sounds"
diff -ruNp src.orig/sc2code/ships/slylandr/istrtab.h src/sc2code/ships/slylandr/istrtab.h
--- src.orig/sc2code/ships/slylandr/istrtab.h	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/slylandr/istrtab.h	2017-11-08 16:50:06 -0600
@@ -1,3 +1,5 @@
-#define SLYLANDRO_RACE_STRINGS 0x00200004L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SLYLANDRO_RACE_STRINGS "ship.slylandro.text"
diff -ruNp src.orig/sc2code/ships/slylandr/slylandr.c src/sc2code/ships/slylandr/slylandr.c
--- src.orig/sc2code/ships/slylandr/slylandr.c	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/slylandr/slylandr.c	2017-11-08 16:50:07 -0600
@@ -41,18 +41,21 @@
 
 static RACE_DESC slylandro_desc =
 {
-	{
+	{ /* SHIP_INFO */
 		SEEKING_WEAPON | CREW_IMMUNE,
 		17, /* Super Melee cost */
-		~0, /* Initial sphere of influence radius */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY, MAX_ENERGY,
-		{
+		SLYLANDRO_RACE_STRINGS,
+		SLYLANDRO_ICON_MASK_PMAP_ANIM,
+		SLYLANDRO_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		INFINITE_RADIUS, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
 			333, 9812,
 		},
-		(STRING)SLYLANDRO_RACE_STRINGS,
-		(FRAME)SLYLANDRO_ICON_MASK_PMAP_ANIM,
-		(FRAME)SLYLANDRO_MICON_MASK_PMAP_ANIM,
 	},
 	{
 		MAX_THRUST,
@@ -69,34 +72,35 @@ static RACE_DESC slylandro_desc =
 	},
 	{
 		{
-			(FRAME)SLYLANDRO_BIG_MASK_PMAP_ANIM,
-			(FRAME)SLYLANDRO_MED_MASK_PMAP_ANIM,
-			(FRAME)SLYLANDRO_SML_MASK_PMAP_ANIM,
+			SLYLANDRO_BIG_MASK_PMAP_ANIM,
+			SLYLANDRO_MED_MASK_PMAP_ANIM,
+			SLYLANDRO_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
 		},
 		{
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
 		},
 		{
-			(FRAME)SLYLANDRO_CAPTAIN_MASK_PMAP_ANIM,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			SLYLANDRO_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
 		},
-		(SOUND)SLYLANDRO_VICTORY_SONG,
-		(SOUND)SLYLANDRO_SHIP_SOUNDS,
+		SLYLANDRO_VICTORY_SONG,
+		SLYLANDRO_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
 	},
 	{
 		0,
 		CLOSE_RANGE_WEAPON << 1,
-		NULL_PTR,
+		NULL,
 	},
 	(UNINIT_FUNC *) NULL,
 	(PREPROCESS_FUNC *) NULL,
@@ -105,11 +109,11 @@ static RACE_DESC slylandro_desc =
 	0,
 };
 
-static COUNT initialize_lightning (PELEMENT ElementPtr, HELEMENT
-		LaserArray[]);
+static COUNT initialize_lightning (ELEMENT *ElementPtr,
+		HELEMENT LaserArray[]);
 
 static void
-lightning_postprocess (PELEMENT ElementPtr)
+lightning_postprocess (ELEMENT *ElementPtr)
 {
 	if (ElementPtr->turn_wait
 			&& !(ElementPtr->state_flags & COLLISION))
@@ -123,9 +127,10 @@ lightning_postprocess (PELEMENT ElementP
 }
 
 static void
-lightning_collision (PELEMENT ElementPtr0, PPOINT pPt0, PELEMENT ElementPtr1, PPOINT pPt1)
+lightning_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr0, &StarShipPtr);
 	if (StarShipPtr->weapon_counter > WEAPON_WAIT >> 1)
@@ -138,7 +143,7 @@ lightning_collision (PELEMENT ElementPtr
 }
 
 static COUNT
-initialize_lightning (PELEMENT ElementPtr, HELEMENT LaserArray[])
+initialize_lightning (ELEMENT *ElementPtr, HELEMENT LaserArray[])
 {
 	LASER_BLOCK LaserBlock;
 
@@ -158,8 +163,8 @@ initialize_lightning (PELEMENT ElementPt
 		SIZE delta;
 		COUNT angle, facing;
 		DWORD rand_val;
-		ELEMENTPTR LaserPtr;
-		STARSHIPPTR StarShipPtr;
+		ELEMENT *LaserPtr;
+		STARSHIP *StarShipPtr;
 
 		GetElementStarShip (ElementPtr, &StarShipPtr);
 
@@ -246,13 +251,16 @@ initialize_lightning (PELEMENT ElementPt
 }
 
 static void
-slylandro_intelligence (PELEMENT ShipPtr, PEVALUATE_DESC ObjectsOfConcern, COUNT ConcernCounter)
+slylandro_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+		COUNT ConcernCounter)
 {
-	PEVALUATE_DESC lpEvalDesc;
-	STARSHIPPTR StarShipPtr;
+	EVALUATE_DESC *lpEvalDesc;
+	STARSHIP *StarShipPtr;
 
-	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_ENCOUNTER)
-			/* no dodging in role playing game */
+	// no dodging in role playing game, unless you haven't
+	// visited the starbase yet
+	if ((LOBYTE (GLOBAL (CurrentActivity)) == IN_ENCOUNTER) &&
+			GET_GAME_STATE (STARBASE_AVAILABLE))
 		ObjectsOfConcern[ENEMY_WEAPON_INDEX].ObjectPtr = 0;
 
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
@@ -286,7 +294,7 @@ slylandro_intelligence (PELEMENT ShipPtr
 }
 
 static BOOLEAN
-harvest_space_junk (PELEMENT ElementPtr)
+harvest_space_junk (ELEMENT *ElementPtr)
 {
 	BOOLEAN retval;
 	HELEMENT hElement, hNextElement;
@@ -295,7 +303,7 @@ harvest_space_junk (PELEMENT ElementPtr)
 	for (hElement = GetHeadElement ();
 			hElement; hElement = hNextElement)
 	{
-		ELEMENTPTR ObjPtr;
+		ELEMENT *ObjPtr;
 
 		LockElement (hElement, &ObjPtr);
 		hNextElement = GetSuccElement (ObjPtr);
@@ -326,7 +334,7 @@ harvest_space_junk (PELEMENT ElementPtr)
 
 				if (!retval)
 				{
-					STARSHIPPTR StarShipPtr;
+					STARSHIP *StarShipPtr;
 
 					retval = TRUE;
 
@@ -345,9 +353,9 @@ harvest_space_junk (PELEMENT ElementPtr)
 }
 
 static void
-slylandro_postprocess (PELEMENT ElementPtr)
+slylandro_postprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (StarShipPtr->weapon_counter
@@ -370,11 +378,11 @@ slylandro_postprocess (PELEMENT ElementP
 }
 
 static void
-slylandro_preprocess (PELEMENT ElementPtr)
+slylandro_preprocess (ELEMENT *ElementPtr)
 {
 	if (!(ElementPtr->state_flags & (APPEARING | NONSOLID)))
 	{
-		STARSHIPPTR StarShipPtr;
+		STARSHIP *StarShipPtr;
 
 		GetElementStarShip (ElementPtr, &StarShipPtr);
 		if ((StarShipPtr->cur_status_flags & THRUST)
@@ -410,17 +418,15 @@ slylandro_preprocess (PELEMENT ElementPt
 	}
 }
 
-RACE_DESCPTR
+RACE_DESC*
 init_slylandro (void)
 {
-	RACE_DESCPTR RaceDescPtr;
+	RACE_DESC *RaceDescPtr;
 
 	slylandro_desc.preprocess_func = slylandro_preprocess;
 	slylandro_desc.postprocess_func = slylandro_postprocess;
 	slylandro_desc.init_weapon_func = initialize_lightning;
-	slylandro_desc.cyborg_control.intelligence_func =
-			(void (*) (PVOID ShipPtr, PVOID ObjectsOfConcern, COUNT
-					ConcernCounter)) slylandro_intelligence;
+	slylandro_desc.cyborg_control.intelligence_func = slylandro_intelligence;
 
 	RaceDescPtr = &slylandro_desc;
 
diff -ruNp src.orig/sc2code/ships/spathi/icode.h src/sc2code/ships/spathi/icode.h
--- src.orig/sc2code/ships/spathi/icode.h	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/spathi/icode.h	2017-11-08 16:50:07 -0600
@@ -1,3 +1,5 @@
-#define SPATHI_CODE 0x00200008L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SPATHI_CODE "ship.spathi.code"
diff -ruNp src.orig/sc2code/ships/spathi/igfxres.h src/sc2code/ships/spathi/igfxres.h
--- src.orig/sc2code/ships/spathi/igfxres.h	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/spathi/igfxres.h	2017-11-08 16:50:07 -0600
@@ -1,14 +1,16 @@
-#define SPATHI_ICON_MASK_PMAP_ANIM 0x00200002L
-#define SPATHI_MICON_MASK_PMAP_ANIM 0x00200102L
-#define SPATHI_BIG_MASK_PMAP_ANIM 0x00400202L
-#define SPATHI_MED_MASK_PMAP_ANIM 0x00400302L
-#define SPATHI_SML_MASK_PMAP_ANIM 0x00400402L
-#define MISSILE_BIG_MASK_PMAP_ANIM 0x00400502L
-#define MISSILE_MED_MASK_PMAP_ANIM 0x00400602L
-#define MISSILE_SML_MASK_PMAP_ANIM 0x00400702L
-#define DISCRIM_BIG_MASK_PMAP_ANIM 0x00400802L
-#define DISCRIM_MED_MASK_PMAP_ANIM 0x00400902L
-#define DISCRIM_SML_MASK_PMAP_ANIM 0x00400a02L
-#define SPATHI_CAPTAIN_MASK_PMAP_ANIM 0x00400b02L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define DISCRIM_BIG_MASK_PMAP_ANIM "ship.spathi.graphics.discrim.large"
+#define DISCRIM_MED_MASK_PMAP_ANIM "ship.spathi.graphics.discrim.medium"
+#define DISCRIM_SML_MASK_PMAP_ANIM "ship.spathi.graphics.discrim.small"
+#define MISSILE_BIG_MASK_PMAP_ANIM "ship.spathi.graphics.missile.large"
+#define MISSILE_MED_MASK_PMAP_ANIM "ship.spathi.graphics.missile.medium"
+#define MISSILE_SML_MASK_PMAP_ANIM "ship.spathi.graphics.missile.small"
+#define SPATHI_BIG_MASK_PMAP_ANIM "ship.spathi.graphics.spathi.large"
+#define SPATHI_CAPTAIN_MASK_PMAP_ANIM "ship.spathi.graphics.captain"
+#define SPATHI_ICON_MASK_PMAP_ANIM "ship.spathi.icons"
+#define SPATHI_MED_MASK_PMAP_ANIM "ship.spathi.graphics.spathi.medium"
+#define SPATHI_MICON_MASK_PMAP_ANIM "ship.spathi.meleeicons"
+#define SPATHI_SML_MASK_PMAP_ANIM "ship.spathi.graphics.spathi.small"
diff -ruNp src.orig/sc2code/ships/spathi/imusicre.h src/sc2code/ships/spathi/imusicre.h
--- src.orig/sc2code/ships/spathi/imusicre.h	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/spathi/imusicre.h	2017-11-08 16:50:07 -0600
@@ -1,3 +1,5 @@
-#define SPATHI_VICTORY_SONG 0x00400006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SPATHI_VICTORY_SONG "ship.spathi.ditty"
diff -ruNp src.orig/sc2code/ships/spathi/isndres.h src/sc2code/ships/spathi/isndres.h
--- src.orig/sc2code/ships/spathi/isndres.h	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/spathi/isndres.h	2017-11-08 16:50:07 -0600
@@ -1,3 +1,5 @@
-#define SPATHI_SHIP_SOUNDS 0x00400005L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SPATHI_SHIP_SOUNDS "ship.spathi.sounds"
diff -ruNp src.orig/sc2code/ships/spathi/istrtab.h src/sc2code/ships/spathi/istrtab.h
--- src.orig/sc2code/ships/spathi/istrtab.h	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/spathi/istrtab.h	2017-11-08 16:50:07 -0600
@@ -1,3 +1,5 @@
-#define SPATHI_RACE_STRINGS 0x00200004L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SPATHI_RACE_STRINGS "ship.spathi.text"
diff -ruNp src.orig/sc2code/ships/spathi/spathi.c src/sc2code/ships/spathi/spathi.c
--- src.orig/sc2code/ships/spathi/spathi.c	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/spathi/spathi.c	2017-11-08 16:50:07 -0600
@@ -39,18 +39,21 @@
 
 static RACE_DESC spathi_desc =
 {
-	{
+	{ /* SHIP_INFO */
 		FIRES_FORE | FIRES_AFT | SEEKING_SPECIAL | DONT_CHASE,
 		18, /* Super Melee cost */
-		1000 / SPHERE_RADIUS_INCREMENT, /* Initial sphere of influence radius */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY, MAX_ENERGY,
-		{
+		SPATHI_RACE_STRINGS,
+		SPATHI_ICON_MASK_PMAP_ANIM,
+		SPATHI_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		1000 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
 			2549, 3600,
 		},
-		(STRING)SPATHI_RACE_STRINGS,
-		(FRAME)SPATHI_ICON_MASK_PMAP_ANIM,
-		(FRAME)SPATHI_MICON_MASK_PMAP_ANIM,
 	},
 	{
 		MAX_THRUST,
@@ -67,34 +70,35 @@ static RACE_DESC spathi_desc =
 	},
 	{
 		{
-			(FRAME)SPATHI_BIG_MASK_PMAP_ANIM,
-			(FRAME)SPATHI_MED_MASK_PMAP_ANIM,
-			(FRAME)SPATHI_SML_MASK_PMAP_ANIM,
+			SPATHI_BIG_MASK_PMAP_ANIM,
+			SPATHI_MED_MASK_PMAP_ANIM,
+			SPATHI_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)MISSILE_BIG_MASK_PMAP_ANIM,
-			(FRAME)MISSILE_MED_MASK_PMAP_ANIM,
-			(FRAME)MISSILE_SML_MASK_PMAP_ANIM,
+			MISSILE_BIG_MASK_PMAP_ANIM,
+			MISSILE_MED_MASK_PMAP_ANIM,
+			MISSILE_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)DISCRIM_BIG_MASK_PMAP_ANIM,
-			(FRAME)DISCRIM_MED_MASK_PMAP_ANIM,
-			(FRAME)DISCRIM_SML_MASK_PMAP_ANIM,
+			DISCRIM_BIG_MASK_PMAP_ANIM,
+			DISCRIM_MED_MASK_PMAP_ANIM,
+			DISCRIM_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)SPATHI_CAPTAIN_MASK_PMAP_ANIM,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			SPATHI_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
 		},
-		(SOUND)SPATHI_VICTORY_SONG,
-		(SOUND)SPATHI_SHIP_SOUNDS,
+		SPATHI_VICTORY_SONG,
+		SPATHI_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
 	},
 	{
 		0,
 		MISSILE_RANGE,
-		NULL_PTR,
+		NULL,
 	},
 	(UNINIT_FUNC *) NULL,
 	(PREPROCESS_FUNC *) NULL,
@@ -107,7 +111,7 @@ static RACE_DESC spathi_desc =
 #define TRACK_WAIT 1
 
 static void
-butt_missile_preprocess (PELEMENT ElementPtr)
+butt_missile_preprocess (ELEMENT *ElementPtr)
 {
 	if (ElementPtr->turn_wait > 0)
 		--ElementPtr->turn_wait;
@@ -132,7 +136,7 @@ butt_missile_preprocess (PELEMENT Elemen
 }
 
 static void
-spawn_butt_missile (PELEMENT ShipPtr)
+spawn_butt_missile (ELEMENT *ShipPtr)
 {
 #define SPATHI_REAR_OFFSET 20
 #define DISCRIMINATOR_LIFE 30
@@ -140,7 +144,7 @@ spawn_butt_missile (PELEMENT ShipPtr)
 #define DISCRIMINATOR_DAMAGE 2
 #define DISCRIMINATOR_OFFSET 4
 	HELEMENT ButtMissile;
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK ButtMissileBlock;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
@@ -161,7 +165,7 @@ spawn_butt_missile (PELEMENT ShipPtr)
 	ButtMissile = initialize_missile (&ButtMissileBlock);
 	if (ButtMissile)
 	{
-		ELEMENTPTR ButtPtr;
+		ELEMENT *ButtPtr;
 
 		LockElement (ButtMissile, &ButtPtr);
 		ButtPtr->turn_wait = TRACK_WAIT;
@@ -177,10 +181,11 @@ spawn_butt_missile (PELEMENT ShipPtr)
 }
 
 static void
-spathi_intelligence (PELEMENT ShipPtr, PEVALUATE_DESC ObjectsOfConcern, COUNT ConcernCounter)
+spathi_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+		COUNT ConcernCounter)
 {
-	STARSHIPPTR StarShipPtr;
-	PEVALUATE_DESC lpEvalDesc;
+	STARSHIP *StarShipPtr;
+	EVALUATE_DESC *lpEvalDesc;
 
 	ship_intelligence (ShipPtr, ObjectsOfConcern, ConcernCounter);
 
@@ -229,13 +234,13 @@ spathi_intelligence (PELEMENT ShipPtr, P
 }
 
 static COUNT
-initialize_standard_missile (PELEMENT ShipPtr, HELEMENT MissileArray[])
+initialize_standard_missile (ELEMENT *ShipPtr, HELEMENT MissileArray[])
 {
 #define SPATHI_FORWARD_OFFSET 16
 #define MISSILE_HITS 1
 #define MISSILE_DAMAGE 1
 #define MISSILE_OFFSET 1
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
@@ -250,7 +255,7 @@ initialize_standard_missile (PELEMENT Sh
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
-	MissileBlock.preprocess_func = NULL_PTR;
+	MissileBlock.preprocess_func = NULL;
 	MissileBlock.blast_offs = MISSILE_OFFSET;
 	MissileArray[0] = initialize_missile (&MissileBlock);
 
@@ -258,9 +263,9 @@ initialize_standard_missile (PELEMENT Sh
 }
 
 static void
-spathi_postprocess (PELEMENT ElementPtr)
+spathi_postprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if ((StarShipPtr->cur_status_flags & SPECIAL)
@@ -274,16 +279,14 @@ spathi_postprocess (PELEMENT ElementPtr)
 	}
 }
 
-RACE_DESCPTR
+RACE_DESC*
 init_spathi (void)
 {
-	RACE_DESCPTR RaceDescPtr;
+	RACE_DESC *RaceDescPtr;
 
 	spathi_desc.postprocess_func = spathi_postprocess;
 	spathi_desc.init_weapon_func = initialize_standard_missile;
-	spathi_desc.cyborg_control.intelligence_func =
-			(void (*) (PVOID ShipPtr, PVOID ObjectsOfConcern, COUNT
-					ConcernCounter)) spathi_intelligence;
+	spathi_desc.cyborg_control.intelligence_func = spathi_intelligence;
 
 	RaceDescPtr = &spathi_desc;
 
diff -ruNp src.orig/sc2code/ships/supox/icode.h src/sc2code/ships/supox/icode.h
--- src.orig/sc2code/ships/supox/icode.h	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/supox/icode.h	2017-11-08 16:50:07 -0600
@@ -1,3 +1,5 @@
-#define SUPOX_CODE 0x00200008L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SUPOX_CODE "ship.supox.code"
diff -ruNp src.orig/sc2code/ships/supox/igfxres.h src/sc2code/ships/supox/igfxres.h
--- src.orig/sc2code/ships/supox/igfxres.h	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/supox/igfxres.h	2017-11-08 16:50:07 -0600
@@ -1,11 +1,13 @@
-#define SUPOX_ICON_MASK_PMAP_ANIM 0x00200002L
-#define SUPOX_MICON_MASK_PMAP_ANIM 0x00200102L
-#define SUPOX_BIG_MASK_PMAP_ANIM 0x00400202L
-#define SUPOX_MED_MASK_PMAP_ANIM 0x00400302L
-#define SUPOX_SML_MASK_PMAP_ANIM 0x00400402L
-#define GOB_BIG_MASK_PMAP_ANIM 0x00400502L
-#define GOB_MED_MASK_PMAP_ANIM 0x00400602L
-#define GOB_SML_MASK_PMAP_ANIM 0x00400702L
-#define SUPOX_CAPTAIN_MASK_PMAP_ANIM 0x00400802L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define GOB_BIG_MASK_PMAP_ANIM "ship.supox.graphics.gob.large"
+#define GOB_MED_MASK_PMAP_ANIM "ship.supox.graphics.gob.medium"
+#define GOB_SML_MASK_PMAP_ANIM "ship.supox.graphics.gob.small"
+#define SUPOX_BIG_MASK_PMAP_ANIM "ship.supox.graphics.supox.large"
+#define SUPOX_CAPTAIN_MASK_PMAP_ANIM "ship.supox.graphics.captain"
+#define SUPOX_ICON_MASK_PMAP_ANIM "ship.supox.icons"
+#define SUPOX_MED_MASK_PMAP_ANIM "ship.supox.graphics.supox.medium"
+#define SUPOX_MICON_MASK_PMAP_ANIM "ship.supox.meleeicons"
+#define SUPOX_SML_MASK_PMAP_ANIM "ship.supox.graphics.supox.small"
diff -ruNp src.orig/sc2code/ships/supox/imusicre.h src/sc2code/ships/supox/imusicre.h
--- src.orig/sc2code/ships/supox/imusicre.h	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/supox/imusicre.h	2017-11-08 16:50:07 -0600
@@ -1,3 +1,5 @@
-#define SUPOX_VICTORY_SONG 0x00400006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SUPOX_VICTORY_SONG "ship.supox.ditty"
diff -ruNp src.orig/sc2code/ships/supox/isndres.h src/sc2code/ships/supox/isndres.h
--- src.orig/sc2code/ships/supox/isndres.h	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/supox/isndres.h	2017-11-08 16:50:07 -0600
@@ -1,3 +1,5 @@
-#define SUPOX_SHIP_SOUNDS 0x00400005L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SUPOX_SHIP_SOUNDS "ship.supox.sounds"
diff -ruNp src.orig/sc2code/ships/supox/istrtab.h src/sc2code/ships/supox/istrtab.h
--- src.orig/sc2code/ships/supox/istrtab.h	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/supox/istrtab.h	2017-11-08 16:50:07 -0600
@@ -1,3 +1,5 @@
-#define SUPOX_RACE_STRINGS 0x00200004L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SUPOX_RACE_STRINGS "ship.supox.text"
diff -ruNp src.orig/sc2code/ships/supox/supox.c src/sc2code/ships/supox/supox.c
--- src.orig/sc2code/ships/supox/supox.c	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/supox/supox.c	2017-11-08 16:50:07 -0600
@@ -41,18 +41,21 @@
 
 static RACE_DESC supox_desc =
 {
-	{
+	{ /* SHIP_INFO */
 		FIRES_FORE,
 		16, /* Super Melee cost */
-		333 / SPHERE_RADIUS_INCREMENT, /* Initial sphere of influence radius */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY, MAX_ENERGY,
-		{
+		SUPOX_RACE_STRINGS,
+		SUPOX_ICON_MASK_PMAP_ANIM,
+		SUPOX_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		333 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
 			7468, 9246,
 		},
-		(STRING)SUPOX_RACE_STRINGS,
-		(FRAME)SUPOX_ICON_MASK_PMAP_ANIM,
-		(FRAME)SUPOX_MICON_MASK_PMAP_ANIM,
 	},
 	{
 		MAX_THRUST,
@@ -69,34 +72,35 @@ static RACE_DESC supox_desc =
 	},
 	{
 		{
-			(FRAME)SUPOX_BIG_MASK_PMAP_ANIM,
-			(FRAME)SUPOX_MED_MASK_PMAP_ANIM,
-			(FRAME)SUPOX_SML_MASK_PMAP_ANIM,
+			SUPOX_BIG_MASK_PMAP_ANIM,
+			SUPOX_MED_MASK_PMAP_ANIM,
+			SUPOX_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)GOB_BIG_MASK_PMAP_ANIM,
-			(FRAME)GOB_MED_MASK_PMAP_ANIM,
-			(FRAME)GOB_SML_MASK_PMAP_ANIM,
+			GOB_BIG_MASK_PMAP_ANIM,
+			GOB_MED_MASK_PMAP_ANIM,
+			GOB_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
 		},
 		{
-			(FRAME)SUPOX_CAPTAIN_MASK_PMAP_ANIM,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			SUPOX_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
 		},
-		(SOUND)SUPOX_VICTORY_SONG,
-		(SOUND)SUPOX_SHIP_SOUNDS,
+		SUPOX_VICTORY_SONG,
+		SUPOX_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
 	},
 	{
 		0,
 		(MISSILE_SPEED * MISSILE_LIFE) >> 1,
-		NULL_PTR,
+		NULL,
 	},
 	(UNINIT_FUNC *) NULL,
 	(PREPROCESS_FUNC *) NULL,
@@ -106,10 +110,11 @@ static RACE_DESC supox_desc =
 };
 
 static void
-supox_intelligence (PELEMENT ShipPtr, PEVALUATE_DESC ObjectsOfConcern, COUNT ConcernCounter)
+supox_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+		COUNT ConcernCounter)
 {
-	STARSHIPPTR StarShipPtr;
-	PEVALUATE_DESC lpEvalDesc;
+	STARSHIP *StarShipPtr;
+	EVALUATE_DESC *lpEvalDesc;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 
@@ -170,13 +175,13 @@ supox_intelligence (PELEMENT ShipPtr, PE
 }
 
 static COUNT
-initialize_horn (PELEMENT ShipPtr, HELEMENT HornArray[])
+initialize_horn (ELEMENT *ShipPtr, HELEMENT HornArray[])
 {
 #define MISSILE_HITS 1
 #define MISSILE_DAMAGE 1
 #define MISSILE_OFFSET 2
 #define SUPOX_OFFSET 23
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
@@ -191,16 +196,16 @@ initialize_horn (PELEMENT ShipPtr, HELEM
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
-	MissileBlock.preprocess_func = NULL_PTR;
+	MissileBlock.preprocess_func = NULL;
 	MissileBlock.blast_offs = MISSILE_OFFSET;
 	HornArray[0] = initialize_missile (&MissileBlock);
 	return (1);
 }
 
 static void
-supox_preprocess (PELEMENT ElementPtr)
+supox_preprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if ((StarShipPtr->cur_status_flags & SPECIAL)
@@ -243,7 +248,7 @@ supox_preprocess (PELEMENT ElementPtr)
 		if (add_facing)
 		{
 			COUNT facing;
-			UWORD thrust_status;
+			STATUS_FLAGS thrust_status;
 
 			facing = StarShipPtr->ShipFacing;
 			StarShipPtr->ShipFacing = NORMALIZE_FACING (
@@ -260,16 +265,14 @@ supox_preprocess (PELEMENT ElementPtr)
 	}
 }
 
-RACE_DESCPTR
+RACE_DESC*
 init_supox (void)
 {
-	RACE_DESCPTR RaceDescPtr;
+	RACE_DESC *RaceDescPtr;
 
 	supox_desc.preprocess_func = supox_preprocess;
 	supox_desc.init_weapon_func = initialize_horn;
-	supox_desc.cyborg_control.intelligence_func =
-			(void (*) (PVOID ShipPtr, PVOID ObjectsOfConcern, COUNT
-					ConcernCounter)) supox_intelligence;
+	supox_desc.cyborg_control.intelligence_func = supox_intelligence;
 
 	RaceDescPtr = &supox_desc;
 
diff -ruNp src.orig/sc2code/ships/syreen/icode.h src/sc2code/ships/syreen/icode.h
--- src.orig/sc2code/ships/syreen/icode.h	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/syreen/icode.h	2017-11-08 16:50:07 -0600
@@ -1,3 +1,5 @@
-#define SYREEN_CODE 0x00200008L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SYREEN_CODE "ship.syreen.code"
diff -ruNp src.orig/sc2code/ships/syreen/igfxres.h src/sc2code/ships/syreen/igfxres.h
--- src.orig/sc2code/ships/syreen/igfxres.h	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/syreen/igfxres.h	2017-11-08 16:50:07 -0600
@@ -1,11 +1,13 @@
-#define SYREEN_ICON_MASK_PMAP_ANIM 0x00200002L
-#define SYREEN_MICON_MASK_PMAP_ANIM 0x00200102L
-#define SYREEN_BIG_MASK_PMAP_ANIM 0x00400202L
-#define SYREEN_MED_MASK_PMAP_ANIM 0x00400302L
-#define SYREEN_SML_MASK_PMAP_ANIM 0x00400402L
-#define DAGGER_BIG_MASK_PMAP_ANIM 0x00400502L
-#define DAGGER_MED_MASK_PMAP_ANIM 0x00400602L
-#define DAGGER_SML_MASK_PMAP_ANIM 0x00400702L
-#define SYREEN_CAPTAIN_MASK_PMAP_ANIM 0x00400802L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define DAGGER_BIG_MASK_PMAP_ANIM "ship.syreen.graphics.dagger.large"
+#define DAGGER_MED_MASK_PMAP_ANIM "ship.syreen.graphics.dagger.medium"
+#define DAGGER_SML_MASK_PMAP_ANIM "ship.syreen.graphics.dagger.small"
+#define SYREEN_BIG_MASK_PMAP_ANIM "ship.syreen.graphics.syreen.large"
+#define SYREEN_CAPTAIN_MASK_PMAP_ANIM "ship.syreen.graphics.captain"
+#define SYREEN_ICON_MASK_PMAP_ANIM "ship.syreen.icons"
+#define SYREEN_MED_MASK_PMAP_ANIM "ship.syreen.graphics.syreen.medium"
+#define SYREEN_MICON_MASK_PMAP_ANIM "ship.syreen.meleeicons"
+#define SYREEN_SML_MASK_PMAP_ANIM "ship.syreen.graphics.syreen.small"
diff -ruNp src.orig/sc2code/ships/syreen/imusicre.h src/sc2code/ships/syreen/imusicre.h
--- src.orig/sc2code/ships/syreen/imusicre.h	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/syreen/imusicre.h	2017-11-08 16:50:07 -0600
@@ -1,3 +1,5 @@
-#define SYREEN_VICTORY_SONG 0x00400006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SYREEN_VICTORY_SONG "ship.syreen.ditty"
diff -ruNp src.orig/sc2code/ships/syreen/isndres.h src/sc2code/ships/syreen/isndres.h
--- src.orig/sc2code/ships/syreen/isndres.h	2017-11-08 16:49:39 -0600
+++ src/sc2code/ships/syreen/isndres.h	2017-11-08 16:50:07 -0600
@@ -1,3 +1,5 @@
-#define SYREEN_SHIP_SOUNDS 0x00400005L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SYREEN_SHIP_SOUNDS "ship.syreen.sounds"
diff -ruNp src.orig/sc2code/ships/syreen/istrtab.h src/sc2code/ships/syreen/istrtab.h
--- src.orig/sc2code/ships/syreen/istrtab.h	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/syreen/istrtab.h	2017-11-08 16:50:07 -0600
@@ -1,3 +1,5 @@
-#define SYREEN_RACE_STRINGS 0x00200004L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SYREEN_RACE_STRINGS "ship.syreen.text"
diff -ruNp src.orig/sc2code/ships/syreen/syreen.c src/sc2code/ships/syreen/syreen.c
--- src.orig/sc2code/ships/syreen/syreen.c	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/syreen/syreen.c	2017-11-08 16:50:07 -0600
@@ -42,18 +42,21 @@
 
 static RACE_DESC syreen_desc =
 {
-	{
+	{ /* SHIP_INFO */
 		FIRES_FORE,
 		13, /* Super Melee cost */
-		0 / SPHERE_RADIUS_INCREMENT, /* Initial sphere of influence radius */
 		MAX_CREW, SYREEN_MAX_CREW_SIZE,
 		MAX_ENERGY, MAX_ENERGY,
-		{
+		SYREEN_RACE_STRINGS,
+		SYREEN_ICON_MASK_PMAP_ANIM,
+		SYREEN_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
 			0, 0,
 		},
-		(STRING)SYREEN_RACE_STRINGS,
-		(FRAME)SYREEN_ICON_MASK_PMAP_ANIM,
-		(FRAME)SYREEN_MICON_MASK_PMAP_ANIM,
 	},
 	{
 		MAX_THRUST,
@@ -70,34 +73,35 @@ static RACE_DESC syreen_desc =
 	},
 	{
 		{
-			(FRAME)SYREEN_BIG_MASK_PMAP_ANIM,
-			(FRAME)SYREEN_MED_MASK_PMAP_ANIM,
-			(FRAME)SYREEN_SML_MASK_PMAP_ANIM,
+			SYREEN_BIG_MASK_PMAP_ANIM,
+			SYREEN_MED_MASK_PMAP_ANIM,
+			SYREEN_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)DAGGER_BIG_MASK_PMAP_ANIM,
-			(FRAME)DAGGER_MED_MASK_PMAP_ANIM,
-			(FRAME)DAGGER_SML_MASK_PMAP_ANIM,
+			DAGGER_BIG_MASK_PMAP_ANIM,
+			DAGGER_MED_MASK_PMAP_ANIM,
+			DAGGER_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
 		},
 		{
-			(FRAME)SYREEN_CAPTAIN_MASK_PMAP_ANIM,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			SYREEN_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
 		},
-		(SOUND)SYREEN_VICTORY_SONG,
-		(SOUND)SYREEN_SHIP_SOUNDS,
+		SYREEN_VICTORY_SONG,
+		SYREEN_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
 	},
 	{
 		0,
 		(MISSILE_SPEED * MISSILE_LIFE * 2 / 3),
-		NULL_PTR,
+		NULL,
 	},
 	(UNINIT_FUNC *) NULL,
 	(PREPROCESS_FUNC *) NULL,
@@ -107,13 +111,13 @@ static RACE_DESC syreen_desc =
 };
 
 static COUNT
-initialize_dagger (PELEMENT ShipPtr, HELEMENT DaggerArray[])
+initialize_dagger (ELEMENT *ShipPtr, HELEMENT DaggerArray[])
 {
 #define SYREEN_OFFSET 30
 #define MISSILE_HITS 1
 #define MISSILE_DAMAGE 2
 #define MISSILE_OFFSET 3
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
@@ -128,7 +132,7 @@ initialize_dagger (PELEMENT ShipPtr, HEL
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
-	MissileBlock.preprocess_func = NULL_PTR;
+	MissileBlock.preprocess_func = NULL;
 	MissileBlock.blast_offs = MISSILE_OFFSET;
 	DaggerArray[0] = initialize_missile (&MissileBlock);
 
@@ -136,7 +140,7 @@ initialize_dagger (PELEMENT ShipPtr, HEL
 }
 
 static void
-spawn_crew (PELEMENT ElementPtr)
+spawn_crew (ELEMENT *ElementPtr)
 {
 	if (ElementPtr->state_flags & PLAYER_SHIP)
 	{
@@ -145,7 +149,7 @@ spawn_crew (PELEMENT ElementPtr)
 		hCrew = AllocElement ();
 		if (hCrew != 0)
 		{
-			ELEMENTPTR CrewPtr;
+			ELEMENT *CrewPtr;
 
 			LockElement (hCrew, &CrewPtr);
 			CrewPtr->next.location = ElementPtr->next.location;
@@ -167,7 +171,7 @@ spawn_crew (PELEMENT ElementPtr)
 		for (hElement = GetHeadElement ();
 				hElement != 0; hElement = hNextElement)
 		{
-			ELEMENTPTR ObjPtr;
+			ELEMENT *ObjPtr;
 
 			LockElement (hElement, &ObjPtr);
 			hNextElement = GetSuccElement (ObjPtr);
@@ -214,17 +218,19 @@ spawn_crew (PELEMENT ElementPtr)
 }
 
 static void
-syreen_intelligence (PELEMENT ShipPtr, PEVALUATE_DESC ObjectsOfConcern, COUNT ConcernCounter)
+syreen_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+		COUNT ConcernCounter)
 {
-	PEVALUATE_DESC lpEvalDesc;
+	EVALUATE_DESC *lpEvalDesc;
 
 	ship_intelligence (ShipPtr,
 			ObjectsOfConcern, ConcernCounter);
 
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
-	if (lpEvalDesc->ObjectPtr != NULL_PTR)
+	if (lpEvalDesc->ObjectPtr != NULL)
 	{
-		STARSHIPPTR StarShipPtr, EnemyStarShipPtr;
+		STARSHIP *StarShipPtr;
+		STARSHIP *EnemyStarShipPtr;
 
 		GetElementStarShip (ShipPtr, &StarShipPtr);
 		GetElementStarShip (lpEvalDesc->ObjectPtr, &EnemyStarShipPtr);
@@ -239,9 +245,9 @@ syreen_intelligence (PELEMENT ShipPtr, P
 }
 
 static void
-syreen_postprocess (PELEMENT ElementPtr)
+syreen_postprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if ((StarShipPtr->cur_status_flags & SPECIAL)
@@ -258,16 +264,14 @@ syreen_postprocess (PELEMENT ElementPtr)
 	}
 }
 
-RACE_DESCPTR
+RACE_DESC*
 init_syreen (void)
 {
-	RACE_DESCPTR RaceDescPtr;
+	RACE_DESC *RaceDescPtr;
 
 	syreen_desc.postprocess_func = syreen_postprocess;
 	syreen_desc.init_weapon_func = initialize_dagger;
-	syreen_desc.cyborg_control.intelligence_func =
-			(void (*) (PVOID ShipPtr, PVOID ObjectsOfConcern, COUNT
-					ConcernCounter)) syreen_intelligence;
+	syreen_desc.cyborg_control.intelligence_func = syreen_intelligence;
 
 	RaceDescPtr = &syreen_desc;
 
diff -ruNp src.orig/sc2code/ships/thradd/icode.h src/sc2code/ships/thradd/icode.h
--- src.orig/sc2code/ships/thradd/icode.h	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/thradd/icode.h	2017-11-08 16:50:07 -0600
@@ -1,3 +1,5 @@
-#define THRADDASH_CODE 0x00200008L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define THRADDASH_CODE "ship.thraddash.code"
diff -ruNp src.orig/sc2code/ships/thradd/igfxres.h src/sc2code/ships/thradd/igfxres.h
--- src.orig/sc2code/ships/thradd/igfxres.h	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/thradd/igfxres.h	2017-11-08 16:50:07 -0600
@@ -1,14 +1,16 @@
-#define THRADDASH_ICON_MASK_PMAP_ANIM 0x00200002L
-#define THRADDASH_MICON_MASK_PMAP_ANIM 0x00200102L
-#define THRADDASH_BIG_MASK_PMAP_ANIM 0x00400202L
-#define THRADDASH_MED_MASK_PMAP_ANIM 0x00400302L
-#define THRADDASH_SML_MASK_PMAP_ANIM 0x00400402L
-#define HORN_BIG_MASK_PMAP_ANIM 0x00400502L
-#define HORN_MED_MASK_PMAP_ANIM 0x00400602L
-#define HORN_SML_MASK_PMAP_ANIM 0x00400702L
-#define NAPALM_BIG_MASK_PMAP_ANIM 0x00400802L
-#define NAPALM_MED_MASK_PMAP_ANIM 0x00400902L
-#define NAPALM_SML_MASK_PMAP_ANIM 0x00400a02L
-#define THRADDASH_CAPTAIN_MASK_PMAP_ANIM 0x00400b02L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define HORN_BIG_MASK_PMAP_ANIM "ship.thraddash.graphics.hor.large"
+#define HORN_MED_MASK_PMAP_ANIM "ship.thraddash.graphics.hor.medium"
+#define HORN_SML_MASK_PMAP_ANIM "ship.thraddash.graphics.hor.small"
+#define NAPALM_BIG_MASK_PMAP_ANIM "ship.thraddash.graphics.nap.large"
+#define NAPALM_MED_MASK_PMAP_ANIM "ship.thraddash.graphics.nap.medium"
+#define NAPALM_SML_MASK_PMAP_ANIM "ship.thraddash.graphics.nap.small"
+#define THRADDASH_BIG_MASK_PMAP_ANIM "ship.thraddash.graphics.thradd.large"
+#define THRADDASH_CAPTAIN_MASK_PMAP_ANIM "ship.thraddash.graphics.captain"
+#define THRADDASH_ICON_MASK_PMAP_ANIM "ship.thraddash.icons"
+#define THRADDASH_MED_MASK_PMAP_ANIM "ship.thraddash.graphics.thradd.medium"
+#define THRADDASH_MICON_MASK_PMAP_ANIM "ship.thraddash.meleeicons"
+#define THRADDASH_SML_MASK_PMAP_ANIM "ship.thraddash.graphics.thradd.small"
diff -ruNp src.orig/sc2code/ships/thradd/imusicre.h src/sc2code/ships/thradd/imusicre.h
--- src.orig/sc2code/ships/thradd/imusicre.h	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/thradd/imusicre.h	2017-11-08 16:50:07 -0600
@@ -1,3 +1,5 @@
-#define THRADDASH_VICTORY_SONG 0x00400006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define THRADDASH_VICTORY_SONG "ship.thraddash.ditty"
diff -ruNp src.orig/sc2code/ships/thradd/isndres.h src/sc2code/ships/thradd/isndres.h
--- src.orig/sc2code/ships/thradd/isndres.h	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/thradd/isndres.h	2017-11-08 16:50:07 -0600
@@ -1,3 +1,5 @@
-#define THRADDASH_SHIP_SOUNDS 0x00400005L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define THRADDASH_SHIP_SOUNDS "ship.thraddash.sounds"
diff -ruNp src.orig/sc2code/ships/thradd/istrtab.h src/sc2code/ships/thradd/istrtab.h
--- src.orig/sc2code/ships/thradd/istrtab.h	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/thradd/istrtab.h	2017-11-08 16:50:07 -0600
@@ -1,3 +1,5 @@
-#define THRADDASH_RACE_STRINGS 0x00200004L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define THRADDASH_RACE_STRINGS "ship.thraddash.text"
diff -ruNp src.orig/sc2code/ships/thradd/thradd.c src/sc2code/ships/thradd/thradd.c
--- src.orig/sc2code/ships/thradd/thradd.c	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/thradd/thradd.c	2017-11-08 16:50:07 -0600
@@ -42,18 +42,21 @@
 
 static RACE_DESC thraddash_desc =
 {
-	{
+	{ /* SHIP_INFO */
 		FIRES_FORE,
 		10, /* Super Melee cost */
-		833 / SPHERE_RADIUS_INCREMENT, /* Initial sphere of influence radius */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY, MAX_ENERGY,
-		{
+		THRADDASH_RACE_STRINGS,
+		THRADDASH_ICON_MASK_PMAP_ANIM,
+		THRADDASH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		833 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
 			2535, 8358,
 		},
-		(STRING)THRADDASH_RACE_STRINGS,
-		(FRAME)THRADDASH_ICON_MASK_PMAP_ANIM,
-		(FRAME)THRADDASH_MICON_MASK_PMAP_ANIM,
 	},
 	{
 		MAX_THRUST,
@@ -70,34 +73,35 @@ static RACE_DESC thraddash_desc =
 	},
 	{
 		{
-			(FRAME)THRADDASH_BIG_MASK_PMAP_ANIM,
-			(FRAME)THRADDASH_MED_MASK_PMAP_ANIM,
-			(FRAME)THRADDASH_SML_MASK_PMAP_ANIM,
+			THRADDASH_BIG_MASK_PMAP_ANIM,
+			THRADDASH_MED_MASK_PMAP_ANIM,
+			THRADDASH_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)HORN_BIG_MASK_PMAP_ANIM,
-			(FRAME)HORN_MED_MASK_PMAP_ANIM,
-			(FRAME)HORN_SML_MASK_PMAP_ANIM,
+			HORN_BIG_MASK_PMAP_ANIM,
+			HORN_MED_MASK_PMAP_ANIM,
+			HORN_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)NAPALM_BIG_MASK_PMAP_ANIM,
-			(FRAME)NAPALM_MED_MASK_PMAP_ANIM,
-			(FRAME)NAPALM_SML_MASK_PMAP_ANIM,
+			NAPALM_BIG_MASK_PMAP_ANIM,
+			NAPALM_MED_MASK_PMAP_ANIM,
+			NAPALM_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)THRADDASH_CAPTAIN_MASK_PMAP_ANIM,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			THRADDASH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
 		},
-		(SOUND)THRADDASH_VICTORY_SONG,
-		(SOUND)THRADDASH_SHIP_SOUNDS,
+		THRADDASH_VICTORY_SONG,
+		THRADDASH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
 	},
 	{
 		0,
 		(MISSILE_SPEED * MISSILE_LIFE) >> 1,
-		NULL_PTR,
+		NULL,
 	},
 	(UNINIT_FUNC *) NULL,
 	(PREPROCESS_FUNC *) NULL,
@@ -107,11 +111,12 @@ static RACE_DESC thraddash_desc =
 };
 
 static void
-thraddash_intelligence (PELEMENT ShipPtr, PEVALUATE_DESC ObjectsOfConcern, COUNT ConcernCounter)
+thraddash_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+		COUNT ConcernCounter)
 {
 
-	STARSHIPPTR StarShipPtr;
-	PEVALUATE_DESC lpEvalDesc;
+	STARSHIP *StarShipPtr;
+	EVALUATE_DESC *lpEvalDesc;
 	
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
 	if (lpEvalDesc->ObjectPtr)
@@ -198,7 +203,7 @@ thraddash_intelligence (PELEMENT ShipPtr
 #define NAPALM_WAIT 1
 
 static void
-flame_napalm_preprocess (PELEMENT ElementPtr)
+flame_napalm_preprocess (ELEMENT *ElementPtr)
 {
 	ZeroVelocityComponents (&ElementPtr->velocity);
 
@@ -236,12 +241,12 @@ flame_napalm_preprocess (PELEMENT Elemen
 }
 
 static COUNT
-initialize_horn (PELEMENT ShipPtr, HELEMENT HornArray[])
+initialize_horn (ELEMENT *ShipPtr, HELEMENT HornArray[])
 {
 #define MISSILE_HITS 2
 #define MISSILE_DAMAGE 1
 #define MISSILE_OFFSET 3
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
@@ -256,7 +261,7 @@ initialize_horn (PELEMENT ShipPtr, HELEM
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
-	MissileBlock.preprocess_func = NULL_PTR;
+	MissileBlock.preprocess_func = NULL;
 	MissileBlock.blast_offs = MISSILE_OFFSET;
 	HornArray[0] = initialize_missile (&MissileBlock);
 
@@ -264,9 +269,9 @@ initialize_horn (PELEMENT ShipPtr, HELEM
 }
 
 static void
-thraddash_preprocess (PELEMENT ElementPtr)
+thraddash_preprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (!(StarShipPtr->cur_status_flags & SPECIAL))
@@ -280,7 +285,7 @@ thraddash_preprocess (PELEMENT ElementPt
 #define SPECIAL_THRUST_INCREMENT 12
 #define SPECIAL_MAX_THRUST 72
 		COUNT max_thrust, thrust_increment;
-		UWORD thrust_status;
+		STATUS_FLAGS thrust_status;
 		HELEMENT hTrailElement;
 
 		if (!(StarShipPtr->old_status_flags & SPECIAL))
@@ -336,7 +341,7 @@ thraddash_preprocess (PELEMENT ElementPt
 			hTrailElement = initialize_missile (&MissileBlock);
 			if (hTrailElement)
 			{
-				ELEMENTPTR TrailElementPtr;
+				ELEMENT *TrailElementPtr;
 
 				LockElement (hTrailElement, &TrailElementPtr);
 				SetElementStarShip (TrailElementPtr, StarShipPtr);
@@ -366,16 +371,14 @@ thraddash_preprocess (PELEMENT ElementPt
 	}
 }
 
-RACE_DESCPTR
+RACE_DESC*
 init_thraddash (void)
 {
-	RACE_DESCPTR RaceDescPtr;
+	RACE_DESC *RaceDescPtr;
 
 	thraddash_desc.preprocess_func = thraddash_preprocess;
 	thraddash_desc.init_weapon_func = initialize_horn;
-	thraddash_desc.cyborg_control.intelligence_func =
-			(void (*) (PVOID ShipPtr, PVOID ObjectsOfConcern, COUNT
-					ConcernCounter)) thraddash_intelligence;
+	thraddash_desc.cyborg_control.intelligence_func = thraddash_intelligence;
 
 	RaceDescPtr = &thraddash_desc;
 
diff -ruNp src.orig/sc2code/ships/umgah/icode.h src/sc2code/ships/umgah/icode.h
--- src.orig/sc2code/ships/umgah/icode.h	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/umgah/icode.h	2017-11-08 16:50:07 -0600
@@ -1,3 +1,5 @@
-#define UMGAH_CODE 0x00200008L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define UMGAH_CODE "ship.umgah.code"
diff -ruNp src.orig/sc2code/ships/umgah/igfxres.h src/sc2code/ships/umgah/igfxres.h
--- src.orig/sc2code/ships/umgah/igfxres.h	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/umgah/igfxres.h	2017-11-08 16:50:07 -0600
@@ -1,12 +1,14 @@
-#define UMGAH_ICON_MASK_PMAP_ANIM 0x00200002L
-#define UMGAH_MICON_MASK_PMAP_ANIM 0x00200102L
-#define UMGAH_BIG_MASK_PMAP_ANIM 0x00400202L
-#define UMGAH_MED_MASK_PMAP_ANIM 0x00400302L
-#define UMGAH_SML_MASK_PMAP_ANIM 0x00400402L
-#define SPRITZ_MASK_PMAP_ANIM 0x00400502L
-#define CONE_BIG_MASK_ANIM 0x00400602L
-#define CONE_MED_MASK_ANIM 0x00400702L
-#define CONE_SML_MASK_ANIM 0x00400802L
-#define UMGAH_CAPTAIN_MASK_PMAP_ANIM 0x00400902L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define CONE_BIG_MASK_ANIM "ship.umgah.graphics.cone.large"
+#define CONE_MED_MASK_ANIM "ship.umgah.graphics.cone.medium"
+#define CONE_SML_MASK_ANIM "ship.umgah.graphics.cone.small"
+#define SPRITZ_MASK_PMAP_ANIM "ship.umgah.graphics.spritz"
+#define UMGAH_BIG_MASK_PMAP_ANIM "ship.umgah.graphics.umgah.large"
+#define UMGAH_CAPTAIN_MASK_PMAP_ANIM "ship.umgah.graphics.captain"
+#define UMGAH_ICON_MASK_PMAP_ANIM "ship.umgah.icons"
+#define UMGAH_MED_MASK_PMAP_ANIM "ship.umgah.graphics.umgah.medium"
+#define UMGAH_MICON_MASK_PMAP_ANIM "ship.umgah.meleeicons"
+#define UMGAH_SML_MASK_PMAP_ANIM "ship.umgah.graphics.umgah.small"
diff -ruNp src.orig/sc2code/ships/umgah/imusicre.h src/sc2code/ships/umgah/imusicre.h
--- src.orig/sc2code/ships/umgah/imusicre.h	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/umgah/imusicre.h	2017-11-08 16:50:07 -0600
@@ -1,3 +1,5 @@
-#define UMGAH_VICTORY_SONG 0x00400006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define UMGAH_VICTORY_SONG "ship.umgah.ditty"
diff -ruNp src.orig/sc2code/ships/umgah/isndres.h src/sc2code/ships/umgah/isndres.h
--- src.orig/sc2code/ships/umgah/isndres.h	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/umgah/isndres.h	2017-11-08 16:50:07 -0600
@@ -1,3 +1,5 @@
-#define UMGAH_SHIP_SOUNDS 0x00400005L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define UMGAH_SHIP_SOUNDS "ship.umgah.sounds"
diff -ruNp src.orig/sc2code/ships/umgah/istrtab.h src/sc2code/ships/umgah/istrtab.h
--- src.orig/sc2code/ships/umgah/istrtab.h	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/umgah/istrtab.h	2017-11-08 16:50:07 -0600
@@ -1,3 +1,5 @@
-#define UMGAH_RACE_STRINGS 0x00200004L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define UMGAH_RACE_STRINGS "ship.umgah.text"
diff -ruNp src.orig/sc2code/ships/umgah/umgah.c src/sc2code/ships/umgah/umgah.c
--- src.orig/sc2code/ships/umgah/umgah.c	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/umgah/umgah.c	2017-11-08 16:50:07 -0600
@@ -41,18 +41,21 @@ static FRAME LastShipFrame[2];
 
 static RACE_DESC umgah_desc =
 {
-	{
+	{ /* SHIP_INFO */
 		FIRES_FORE | IMMEDIATE_WEAPON,
 		7, /* Super Melee cost */
-		833 / SPHERE_RADIUS_INCREMENT, /* Initial sphere of influence radius */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY, MAX_ENERGY,
-		{
+		UMGAH_RACE_STRINGS,
+		UMGAH_ICON_MASK_PMAP_ANIM,
+		UMGAH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		833 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
 			1798, 6000,
 		},
-		(STRING)UMGAH_RACE_STRINGS,
-		(FRAME)UMGAH_ICON_MASK_PMAP_ANIM,
-		(FRAME)UMGAH_MICON_MASK_PMAP_ANIM,
 	},
 	{
 		MAX_THRUST,
@@ -69,34 +72,35 @@ static RACE_DESC umgah_desc =
 	},
 	{
 		{
-			(FRAME)UMGAH_BIG_MASK_PMAP_ANIM,
-			(FRAME)UMGAH_MED_MASK_PMAP_ANIM,
-			(FRAME)UMGAH_SML_MASK_PMAP_ANIM,
+			UMGAH_BIG_MASK_PMAP_ANIM,
+			UMGAH_MED_MASK_PMAP_ANIM,
+			UMGAH_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)SPRITZ_MASK_PMAP_ANIM,
-			(FRAME)0,
-			(FRAME)0,
+			SPRITZ_MASK_PMAP_ANIM,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
 		},
 		{
-			(FRAME)CONE_BIG_MASK_ANIM,
-			(FRAME)CONE_MED_MASK_ANIM,
-			(FRAME)CONE_SML_MASK_ANIM,
+			CONE_BIG_MASK_ANIM,
+			CONE_MED_MASK_ANIM,
+			CONE_SML_MASK_ANIM,
 		},
 		{
-			(FRAME)UMGAH_CAPTAIN_MASK_PMAP_ANIM,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			UMGAH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
 		},
-		(SOUND)UMGAH_VICTORY_SONG,
-		(SOUND)UMGAH_SHIP_SOUNDS,
+		UMGAH_VICTORY_SONG,
+		UMGAH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
 	},
 	{
 		0,
 		(LONG_RANGE_WEAPON << 2),
-		NULL_PTR,
+		NULL,
 	},
 	(UNINIT_FUNC *) NULL,
 	(PREPROCESS_FUNC *) NULL,
@@ -106,9 +110,9 @@ static RACE_DESC umgah_desc =
 };
 
 static void
-cone_preprocess (PELEMENT ElementPtr)
+cone_preprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	StarShipPtr->RaceDescPtr->ship_data.special[0] =
@@ -119,7 +123,8 @@ cone_preprocess (PELEMENT ElementPtr)
 }
 
 static void
-cone_collision (PELEMENT ElementPtr0, PPOINT pPt0, PELEMENT ElementPtr1, PPOINT pPt1)
+cone_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
 	HELEMENT hBlastElement;
 
@@ -136,10 +141,12 @@ cone_collision (PELEMENT ElementPtr0, PP
 #define JUMP_DIST DISPLAY_TO_WORLD (40)
 
 static void
-umgah_intelligence (PELEMENT ShipPtr, PEVALUATE_DESC ObjectsOfConcern, COUNT ConcernCounter)
+umgah_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+		COUNT ConcernCounter)
 {
-	PEVALUATE_DESC lpEvalDesc;
-	STARSHIPPTR StarShipPtr, EnemyStarShipPtr;
+	EVALUATE_DESC *lpEvalDesc;
+	STARSHIP *StarShipPtr;
+	STARSHIP *EnemyStarShipPtr;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_WEAPON_INDEX];
@@ -248,7 +255,7 @@ umgah_intelligence (PELEMENT ShipPtr, PE
 		StarShipPtr->RaceDescPtr->characteristics.special_wait = 0xFF;
 }
 static COUNT
-initialize_cone (PELEMENT ShipPtr, HELEMENT ConeArray[])
+initialize_cone (ELEMENT *ShipPtr, HELEMENT ConeArray[])
 {
 #define UMGAH_OFFSET 0
 #define MISSILE_SPEED 0
@@ -256,7 +263,7 @@ initialize_cone (PELEMENT ShipPtr, HELEM
 #define MISSILE_DAMAGE 1
 #define MISSILE_LIFE 1
 #define MISSILE_OFFSET 0
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
@@ -290,7 +297,7 @@ initialize_cone (PELEMENT ShipPtr, HELEM
 
 	if (ConeArray[0])
 	{
-		ELEMENTPTR ConePtr;
+		ELEMENT *ConePtr;
 
 		LockElement (ConeArray[0], &ConePtr);
 		ConePtr->collision_func = cone_collision;
@@ -307,9 +314,9 @@ initialize_cone (PELEMENT ShipPtr, HELEM
 }
 
 static void
-umgah_postprocess (PELEMENT ElementPtr)
+umgah_postprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (StarShipPtr->special_counter > 0)
@@ -321,13 +328,13 @@ umgah_postprocess (PELEMENT ElementPtr)
 }
 
 static void
-umgah_preprocess (PELEMENT ElementPtr)
+umgah_preprocess (ELEMENT *ElementPtr)
 {
 	if (ElementPtr->state_flags & APPEARING)
 		LastShipFrame[WHICH_SIDE(ElementPtr->state_flags)] = 0;
 	else
 	{
-		STARSHIPPTR StarShipPtr;
+		STARSHIP *StarShipPtr;
 
 		GetElementStarShip (ElementPtr, &StarShipPtr);
 		if (ElementPtr->thrust_wait == 0
@@ -351,17 +358,15 @@ umgah_preprocess (PELEMENT ElementPtr)
 	}
 }
 
-RACE_DESCPTR
+RACE_DESC*
 init_umgah (void)
 {
-	RACE_DESCPTR RaceDescPtr;
+	RACE_DESC *RaceDescPtr;
 
 	umgah_desc.preprocess_func = umgah_preprocess;
 	umgah_desc.postprocess_func = umgah_postprocess;
 	umgah_desc.init_weapon_func = initialize_cone;
-	umgah_desc.cyborg_control.intelligence_func =
-			(void (*) (PVOID ShipPtr, PVOID ObjectsOfConcern, COUNT
-					ConcernCounter)) umgah_intelligence;
+	umgah_desc.cyborg_control.intelligence_func = umgah_intelligence;
 
 	RaceDescPtr = &umgah_desc;
 
diff -ruNp src.orig/sc2code/ships/urquan/icode.h src/sc2code/ships/urquan/icode.h
--- src.orig/sc2code/ships/urquan/icode.h	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/urquan/icode.h	2017-11-08 16:50:07 -0600
@@ -1,3 +1,5 @@
-#define URQUAN_CODE 0x00200008L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define URQUAN_CODE "ship.urquan.code"
diff -ruNp src.orig/sc2code/ships/urquan/igfxres.h src/sc2code/ships/urquan/igfxres.h
--- src.orig/sc2code/ships/urquan/igfxres.h	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/urquan/igfxres.h	2017-11-08 16:50:07 -0600
@@ -1,14 +1,16 @@
-#define URQUAN_ICON_MASK_PMAP_ANIM 0x00200002L
-#define URQUAN_MICON_MASK_PMAP_ANIM 0x00200102L
-#define URQUAN_BIG_MASK_PMAP_ANIM 0x00400202L
-#define URQUAN_MED_MASK_PMAP_ANIM 0x00400302L
-#define URQUAN_SML_MASK_PMAP_ANIM 0x00400402L
-#define FUSION_BIG_MASK_PMAP_ANIM 0x00400502L
-#define FUSION_MED_MASK_PMAP_ANIM 0x00400602L
-#define FUSION_SML_MASK_PMAP_ANIM 0x00400702L
-#define FIGHTER_BIG_MASK_PMAP_ANIM 0x00400802L
-#define FIGHTER_MED_MASK_PMAP_ANIM 0x00400902L
-#define FIGHTER_SML_MASK_PMAP_ANIM 0x00400a02L
-#define URQUAN_CAPTAIN_MASK_PMAP_ANIM 0x00400b02L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define FIGHTER_BIG_MASK_PMAP_ANIM "ship.urquan.graphics.fight.large"
+#define FIGHTER_MED_MASK_PMAP_ANIM "ship.urquan.graphics.fight.medium"
+#define FIGHTER_SML_MASK_PMAP_ANIM "ship.urquan.graphics.fight.small"
+#define FUSION_BIG_MASK_PMAP_ANIM "ship.urquan.graphics.fusion.large"
+#define FUSION_MED_MASK_PMAP_ANIM "ship.urquan.graphics.fusion.medium"
+#define FUSION_SML_MASK_PMAP_ANIM "ship.urquan.graphics.fusion.small"
+#define URQUAN_BIG_MASK_PMAP_ANIM "ship.urquan.graphics.urquan.large"
+#define URQUAN_CAPTAIN_MASK_PMAP_ANIM "ship.urquan.graphics.captain"
+#define URQUAN_ICON_MASK_PMAP_ANIM "ship.urquan.icons"
+#define URQUAN_MED_MASK_PMAP_ANIM "ship.urquan.graphics.urquan.medium"
+#define URQUAN_MICON_MASK_PMAP_ANIM "ship.urquan.meleeicons"
+#define URQUAN_SML_MASK_PMAP_ANIM "ship.urquan.graphics.urquan.small"
diff -ruNp src.orig/sc2code/ships/urquan/imusicre.h src/sc2code/ships/urquan/imusicre.h
--- src.orig/sc2code/ships/urquan/imusicre.h	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/urquan/imusicre.h	2017-11-08 16:50:07 -0600
@@ -1,3 +1,5 @@
-#define URQUAN_VICTORY_SONG 0x00400006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define URQUAN_VICTORY_SONG "ship.urquan.ditty"
diff -ruNp src.orig/sc2code/ships/urquan/isndres.h src/sc2code/ships/urquan/isndres.h
--- src.orig/sc2code/ships/urquan/isndres.h	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/urquan/isndres.h	2017-11-08 16:50:07 -0600
@@ -1,3 +1,5 @@
-#define URQUAN_SHIP_SOUNDS 0x00400005L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define URQUAN_SHIP_SOUNDS "ship.urquan.sounds"
diff -ruNp src.orig/sc2code/ships/urquan/istrtab.h src/sc2code/ships/urquan/istrtab.h
--- src.orig/sc2code/ships/urquan/istrtab.h	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/urquan/istrtab.h	2017-11-08 16:50:07 -0600
@@ -1,3 +1,5 @@
-#define URQUAN_RACE_STRINGS 0x00200004L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define URQUAN_RACE_STRINGS "ship.urquan.text"
diff -ruNp src.orig/sc2code/ships/urquan/urquan.c src/sc2code/ships/urquan/urquan.c
--- src.orig/sc2code/ships/urquan/urquan.c	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/urquan/urquan.c	2017-11-08 16:50:08 -0600
@@ -19,6 +19,9 @@
 #include "ships/ship.h"
 #include "ships/urquan/resinst.h"
 
+// to satisfy OBJECT_CLOAKED ()
+#include "colors.h"
+
 #include "globdata.h"
 
 #include <stdlib.h>
@@ -43,18 +46,21 @@
 
 static RACE_DESC urquan_desc =
 {
-	{
+	{ /* SHIP_INFO */
 		FIRES_FORE | SEEKING_SPECIAL,
 		30, /* Super Melee cost */
-		2666 / SPHERE_RADIUS_INCREMENT, /* Initial sphere of influence radius */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY, MAX_ENERGY,
-		{
+		URQUAN_RACE_STRINGS,
+		URQUAN_ICON_MASK_PMAP_ANIM,
+		URQUAN_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		2666 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
 			5750, 6000,
 		},
-		(STRING)URQUAN_RACE_STRINGS,
-		(FRAME)URQUAN_ICON_MASK_PMAP_ANIM,
-		(FRAME)URQUAN_MICON_MASK_PMAP_ANIM,
 	},
 	{
 		MAX_THRUST,
@@ -71,34 +77,35 @@ static RACE_DESC urquan_desc =
 	},
 	{
 		{
-			(FRAME)URQUAN_BIG_MASK_PMAP_ANIM,
-			(FRAME)URQUAN_MED_MASK_PMAP_ANIM,
-			(FRAME)URQUAN_SML_MASK_PMAP_ANIM,
+			URQUAN_BIG_MASK_PMAP_ANIM,
+			URQUAN_MED_MASK_PMAP_ANIM,
+			URQUAN_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)FUSION_BIG_MASK_PMAP_ANIM,
-			(FRAME)FUSION_MED_MASK_PMAP_ANIM,
-			(FRAME)FUSION_SML_MASK_PMAP_ANIM,
+			FUSION_BIG_MASK_PMAP_ANIM,
+			FUSION_MED_MASK_PMAP_ANIM,
+			FUSION_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)FIGHTER_BIG_MASK_PMAP_ANIM,
-			(FRAME)FIGHTER_MED_MASK_PMAP_ANIM,
-			(FRAME)FIGHTER_SML_MASK_PMAP_ANIM,
+			FIGHTER_BIG_MASK_PMAP_ANIM,
+			FIGHTER_MED_MASK_PMAP_ANIM,
+			FIGHTER_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)URQUAN_CAPTAIN_MASK_PMAP_ANIM,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			URQUAN_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
 		},
-		(SOUND)URQUAN_VICTORY_SONG,
-		(SOUND)URQUAN_SHIP_SOUNDS,
+		URQUAN_VICTORY_SONG,
+		URQUAN_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
 	},
 	{
 		0,
 		MISSILE_SPEED * MISSILE_LIFE,
-		NULL_PTR,
+		NULL,
 	},
 	(UNINIT_FUNC *) NULL,
 	(PREPROCESS_FUNC *) NULL,
@@ -108,13 +115,13 @@ static RACE_DESC urquan_desc =
 };
 
 static COUNT
-initialize_fusion (PELEMENT ShipPtr, HELEMENT FusionArray[])
+initialize_fusion (ELEMENT *ShipPtr, HELEMENT FusionArray[])
 {
 #define MISSILE_HITS 10
 #define MISSILE_DAMAGE 6
 #define MISSILE_OFFSET 8
 #define URQUAN_OFFSET 32
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
@@ -129,7 +136,7 @@ initialize_fusion (PELEMENT ShipPtr, HEL
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
-	MissileBlock.preprocess_func = NULL_PTR;
+	MissileBlock.preprocess_func = NULL;
 	MissileBlock.blast_offs = MISSILE_OFFSET;
 	FusionArray[0] = initialize_missile (&MissileBlock);
 
@@ -146,10 +153,10 @@ initialize_fusion (PELEMENT ShipPtr, HEL
 #define LASER_RANGE DISPLAY_TO_WORLD (40 + FIGHTER_OFFSET)
 
 static void
-fighter_postprocess (PELEMENT ElementPtr)
+fighter_postprocess (ELEMENT *ElementPtr)
 {
 	HELEMENT Laser;
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	LASER_BLOCK LaserBlock;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
@@ -165,7 +172,7 @@ fighter_postprocess (PELEMENT ElementPtr
 	Laser = initialize_laser (&LaserBlock);
 	if (Laser)
 	{
-		ELEMENTPTR LaserPtr;
+		ELEMENT *LaserPtr;
 
 		LockElement (Laser, &LaserPtr);
 		SetElementStarShip (LaserPtr, StarShipPtr);
@@ -183,9 +190,9 @@ fighter_postprocess (PELEMENT ElementPtr
 }
 
 static void
-fighter_preprocess (PELEMENT ElementPtr)
+fighter_preprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 
@@ -196,7 +203,8 @@ fighter_preprocess (PELEMENT ElementPtr)
 		BOOLEAN Enroute;
 		COUNT orig_facing, facing;
 		SIZE delta_x, delta_y;
-		ELEMENTPTR eptr;
+		ELEMENT *eptr;
+		HELEMENT hObject, hNextObject;
 
 		Enroute = TRUE;
 
@@ -238,14 +246,27 @@ fighter_preprocess (PELEMENT ElementPtr)
 		if (ElementPtr->thrust_wait > 0)
 			--ElementPtr->thrust_wait;
 
-		if (ElementPtr->hTarget)
+		// just for fun: instead of only shooting at the
+		// enemy ship, shoot at anything within range
+		for (hObject = GetTailElement (); hObject; hObject = hNextObject)
 		{
-			LockElement (ElementPtr->hTarget, &eptr);
+			LockElement (hObject, &eptr);
+			hNextObject = GetPredElement (eptr);
 			delta_x = eptr->current.location.x
 					- ElementPtr->current.location.x;
 			delta_y = eptr->current.location.y
 					- ElementPtr->current.location.y;
-			UnlockElement (ElementPtr->hTarget);
+			UnlockElement (hObject);
+
+			// the list of things not to shoot at
+			// includes: yourself, the mothership, other
+			// fighters, non-collidable objects and
+			// cloaked ships
+			if (eptr == ElementPtr || eptr == ElementPtr->pParent ||
+					ElementPtr->pParent == eptr->pParent ||
+					! CollidingElement (eptr) || OBJECT_CLOAKED (eptr))
+				continue;
+
 			delta_x = WRAP_DELTA_X (delta_x);
 			delta_y = WRAP_DELTA_Y (delta_y);
 
@@ -260,29 +281,39 @@ fighter_preprocess (PELEMENT ElementPtr)
 						ANGLE_TO_FACING (ARCTAN (delta_x, delta_y))
 						);
 				ElementPtr->postprocess_func = fighter_postprocess;
+				break;
 			}
+		}
+
+		if (ElementPtr->hTarget && Enroute)
+		{
+			LockElement (ElementPtr->hTarget, &eptr);
+			delta_x = eptr->current.location.x
+					- ElementPtr->current.location.x;
+			delta_y = eptr->current.location.y
+					- ElementPtr->current.location.y;
+			UnlockElement (ElementPtr->hTarget);
+			delta_x = WRAP_DELTA_X (delta_x);
+			delta_y = WRAP_DELTA_Y (delta_y);
 
-			if (Enroute)
+			facing = GetFrameIndex (eptr->current.image.frame);
+			if (ElementPtr->turn_wait & LEFT)
 			{
-				facing = GetFrameIndex (eptr->current.image.frame);
-				if (ElementPtr->turn_wait & LEFT)
-				{
-					delta_x += COSINE (FACING_TO_ANGLE (facing - 4),
-							DISPLAY_TO_WORLD (30));
-					delta_y += SINE (FACING_TO_ANGLE (facing - 4),
-							DISPLAY_TO_WORLD (30));
-				}
-				else
-				{
-					delta_x += COSINE (FACING_TO_ANGLE (facing + 4),
-							DISPLAY_TO_WORLD (30));
-					delta_y += SINE (FACING_TO_ANGLE (facing + 4),
-							DISPLAY_TO_WORLD (30));
-				}
-				facing = NORMALIZE_FACING (
-						ANGLE_TO_FACING (ARCTAN (delta_x, delta_y))
-						);
+				delta_x += COSINE (FACING_TO_ANGLE (facing - 4),
+						DISPLAY_TO_WORLD (30));
+				delta_y += SINE (FACING_TO_ANGLE (facing - 4),
+						DISPLAY_TO_WORLD (30));
+			}
+			else
+			{
+				delta_x += COSINE (FACING_TO_ANGLE (facing + 4),
+						DISPLAY_TO_WORLD (30));
+				delta_y += SINE (FACING_TO_ANGLE (facing + 4),
+						DISPLAY_TO_WORLD (30));
 			}
+			facing = NORMALIZE_FACING (
+					ANGLE_TO_FACING (ARCTAN (delta_x, delta_y))
+					);
 		}
 		ElementPtr->state_flags |= CHANGING;
 
@@ -297,9 +328,10 @@ fighter_preprocess (PELEMENT ElementPtr)
 }
 
 static void
-fighter_collision (PELEMENT ElementPtr0, PPOINT pPt0, PELEMENT ElementPtr1, PPOINT pPt1)
+fighter_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr0, &StarShipPtr);
 	if (GRAVITY_MASS (ElementPtr1->mass_points))
@@ -311,7 +343,7 @@ fighter_collision (PELEMENT ElementPtr0,
 		{
 			COUNT primIndex, travel_facing;
 			SIZE delta_facing;
-			ELEMENTPTR FighterElementPtr;
+			ELEMENT *FighterElementPtr;
 
 			LockElement (hFighterElement, &FighterElementPtr);
 			primIndex = FighterElementPtr->PrimIndex;
@@ -383,13 +415,13 @@ fighter_collision (PELEMENT ElementPtr0,
 }
 
 static void
-spawn_fighters (PELEMENT ElementPtr)
+spawn_fighters (ELEMENT *ElementPtr)
 {
 	SIZE i;
 	COUNT facing;
 	SIZE delta_x, delta_y;
 	HELEMENT hFighterElement;
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	facing = StarShipPtr->ShipFacing + ANGLE_TO_FACING (HALF_CIRCLE);
@@ -401,7 +433,7 @@ spawn_fighters (PELEMENT ElementPtr)
 	{
 		SIZE sx, sy;
 		COUNT fighter_facing;
-		ELEMENTPTR FighterElementPtr;
+		ELEMENT *FighterElementPtr;
 
 		DeltaCrew (ElementPtr, -1);
 
@@ -420,7 +452,7 @@ spawn_fighters (PELEMENT ElementPtr)
 			FighterElementPtr->preprocess_func = fighter_preprocess;
 			FighterElementPtr->postprocess_func = 0;
 			FighterElementPtr->collision_func = fighter_collision;
-			FighterElementPtr->death_func = NULL_PTR;
+			FighterElementPtr->death_func = NULL;
 		}
 
 		FighterElementPtr->current.location = ElementPtr->next.location;
@@ -456,10 +488,11 @@ spawn_fighters (PELEMENT ElementPtr)
 }
 
 static void
-urquan_intelligence (PELEMENT ShipPtr, PEVALUATE_DESC ObjectsOfConcern, COUNT ConcernCounter)
+urquan_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+		COUNT ConcernCounter)
 {
-	PEVALUATE_DESC lpEvalDesc;
-	STARSHIPPTR StarShipPtr;
+	EVALUATE_DESC *lpEvalDesc;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 
@@ -480,7 +513,7 @@ urquan_intelligence (PELEMENT ShipPtr, P
 
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
 	{
-		STARSHIPPTR EnemyStarShipPtr;
+		STARSHIP *EnemyStarShipPtr;
 
 		if (lpEvalDesc->ObjectPtr)
 			GetElementStarShip (lpEvalDesc->ObjectPtr, &EnemyStarShipPtr);
@@ -508,9 +541,9 @@ urquan_intelligence (PELEMENT ShipPtr, P
 }
 
 static void
-urquan_postprocess (PELEMENT ElementPtr)
+urquan_postprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if ((StarShipPtr->cur_status_flags & SPECIAL)
@@ -527,16 +560,14 @@ urquan_postprocess (PELEMENT ElementPtr)
 	}
 }
 
-RACE_DESCPTR
+RACE_DESC*
 init_urquan (void)
 {
-	RACE_DESCPTR RaceDescPtr;
+	RACE_DESC *RaceDescPtr;
 
 	urquan_desc.postprocess_func = urquan_postprocess;
 	urquan_desc.init_weapon_func = initialize_fusion;
-	urquan_desc.cyborg_control.intelligence_func =
-			(void (*) (PVOID ShipPtr, PVOID ObjectsOfConcern, COUNT
-					ConcernCounter)) urquan_intelligence;
+	urquan_desc.cyborg_control.intelligence_func = urquan_intelligence;
 
 	RaceDescPtr = &urquan_desc;
 
diff -ruNp src.orig/sc2code/ships/utwig/icode.h src/sc2code/ships/utwig/icode.h
--- src.orig/sc2code/ships/utwig/icode.h	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/utwig/icode.h	2017-11-08 16:50:08 -0600
@@ -1,3 +1,5 @@
-#define UTWIG_CODE 0x00200008L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define UTWIG_CODE "ship.utwig.code"
diff -ruNp src.orig/sc2code/ships/utwig/igfxres.h src/sc2code/ships/utwig/igfxres.h
--- src.orig/sc2code/ships/utwig/igfxres.h	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/utwig/igfxres.h	2017-11-08 16:50:08 -0600
@@ -1,11 +1,13 @@
-#define UTWIG_ICON_MASK_PMAP_ANIM 0x00200002L
-#define UTWIG_MICON_MASK_PMAP_ANIM 0x00200102L
-#define UTWIG_BIG_MASK_PMAP_ANIM 0x00400202L
-#define UTWIG_MED_MASK_PMAP_ANIM 0x00400302L
-#define UTWIG_SML_MASK_PMAP_ANIM 0x00400402L
-#define LANCE_BIG_MASK_PMAP_ANIM 0x00400502L
-#define LANCE_MED_MASK_PMAP_ANIM 0x00400602L
-#define LANCE_SML_MASK_PMAP_ANIM 0x00400702L
-#define UTWIG_CAPTAIN_MASK_PMAP_ANIM 0x00400802L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define LANCE_BIG_MASK_PMAP_ANIM "ship.utwig.graphics.lan.large"
+#define LANCE_MED_MASK_PMAP_ANIM "ship.utwig.graphics.lan.medium"
+#define LANCE_SML_MASK_PMAP_ANIM "ship.utwig.graphics.lan.small"
+#define UTWIG_BIG_MASK_PMAP_ANIM "ship.utwig.graphics.utwig.large"
+#define UTWIG_CAPTAIN_MASK_PMAP_ANIM "ship.utwig.graphics.captain"
+#define UTWIG_ICON_MASK_PMAP_ANIM "ship.utwig.icons"
+#define UTWIG_MED_MASK_PMAP_ANIM "ship.utwig.graphics.utwig.medium"
+#define UTWIG_MICON_MASK_PMAP_ANIM "ship.utwig.meleeicons"
+#define UTWIG_SML_MASK_PMAP_ANIM "ship.utwig.graphics.utwig.small"
diff -ruNp src.orig/sc2code/ships/utwig/imusicre.h src/sc2code/ships/utwig/imusicre.h
--- src.orig/sc2code/ships/utwig/imusicre.h	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/utwig/imusicre.h	2017-11-08 16:50:08 -0600
@@ -1,3 +1,5 @@
-#define UTWIG_VICTORY_SONG 0x00400006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define UTWIG_VICTORY_SONG "ship.utwig.ditty"
diff -ruNp src.orig/sc2code/ships/utwig/isndres.h src/sc2code/ships/utwig/isndres.h
--- src.orig/sc2code/ships/utwig/isndres.h	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/utwig/isndres.h	2017-11-08 16:50:08 -0600
@@ -1,3 +1,5 @@
-#define UTWIG_SHIP_SOUNDS 0x00400005L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define UTWIG_SHIP_SOUNDS "ship.utwig.sounds"
diff -ruNp src.orig/sc2code/ships/utwig/istrtab.h src/sc2code/ships/utwig/istrtab.h
--- src.orig/sc2code/ships/utwig/istrtab.h	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/utwig/istrtab.h	2017-11-08 16:50:08 -0600
@@ -1,3 +1,5 @@
-#define UTWIG_RACE_STRINGS 0x00200004L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define UTWIG_RACE_STRINGS "ship.utwig.text"
diff -ruNp src.orig/sc2code/ships/utwig/utwig.c src/sc2code/ships/utwig/utwig.c
--- src.orig/sc2code/ships/utwig/utwig.c	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/utwig/utwig.c	2017-11-08 16:50:08 -0600
@@ -43,18 +43,21 @@
 
 static RACE_DESC utwig_desc =
 {
-	{
+	{ /* SHIP_INFO */
 		FIRES_FORE | POINT_DEFENSE | SHIELD_DEFENSE,
 		22, /* Super Melee cost */
-		666 / SPHERE_RADIUS_INCREMENT, /* Initial sphere of influence radius */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY >> 1, MAX_ENERGY,
-		{
+		UTWIG_RACE_STRINGS,
+		UTWIG_ICON_MASK_PMAP_ANIM,
+		UTWIG_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		666 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
 			8534, 8797,
 		},
-		(STRING)UTWIG_RACE_STRINGS,
-		(FRAME)UTWIG_ICON_MASK_PMAP_ANIM,
-		(FRAME)UTWIG_MICON_MASK_PMAP_ANIM,
 	},
 	{
 		MAX_THRUST,
@@ -71,34 +74,35 @@ static RACE_DESC utwig_desc =
 	},
 	{
 		{
-			(FRAME)UTWIG_BIG_MASK_PMAP_ANIM,
-			(FRAME)UTWIG_MED_MASK_PMAP_ANIM,
-			(FRAME)UTWIG_SML_MASK_PMAP_ANIM,
+			UTWIG_BIG_MASK_PMAP_ANIM,
+			UTWIG_MED_MASK_PMAP_ANIM,
+			UTWIG_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)LANCE_BIG_MASK_PMAP_ANIM,
-			(FRAME)LANCE_MED_MASK_PMAP_ANIM,
-			(FRAME)LANCE_SML_MASK_PMAP_ANIM,
+			LANCE_BIG_MASK_PMAP_ANIM,
+			LANCE_MED_MASK_PMAP_ANIM,
+			LANCE_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
 		},
 		{
-			(FRAME)UTWIG_CAPTAIN_MASK_PMAP_ANIM,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			UTWIG_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
 		},
-		(SOUND)UTWIG_VICTORY_SONG,
-		(SOUND)UTWIG_SHIP_SOUNDS,
+		UTWIG_VICTORY_SONG,
+		UTWIG_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
 	},
 	{
 		0,
 		CLOSE_RANGE_WEAPON,
-		NULL_PTR,
+		NULL,
 	},
 	(UNINIT_FUNC *) NULL,
 	(PREPROCESS_FUNC *) NULL,
@@ -108,7 +112,7 @@ static RACE_DESC utwig_desc =
 };
 
 static COUNT
-initialize_lance (PELEMENT ShipPtr, HELEMENT WeaponArray[])
+initialize_lance (ELEMENT *ShipPtr, HELEMENT WeaponArray[])
 {
 #define LAUNCH_XOFFS0 DISPLAY_TO_WORLD (5)
 #define LAUNCH_YOFFS0 -DISPLAY_TO_WORLD (18)
@@ -120,7 +124,7 @@ initialize_lance (PELEMENT ShipPtr, HELE
 #define MISSILE_DAMAGE 1
 #define MISSILE_OFFSET 1
 	COUNT i;
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
@@ -132,7 +136,7 @@ initialize_lance (PELEMENT ShipPtr, HELE
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
-	MissileBlock.preprocess_func = NULL_PTR;
+	MissileBlock.preprocess_func = NULL;
 	MissileBlock.blast_offs = MISSILE_OFFSET;
 	MissileBlock.pixoffs = 0;
 
@@ -180,11 +184,12 @@ initialize_lance (PELEMENT ShipPtr, HELE
 }
 
 static void
-utwig_intelligence (PELEMENT ShipPtr, PEVALUATE_DESC ObjectsOfConcern, COUNT ConcernCounter)
+utwig_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+		COUNT ConcernCounter)
 {
 	SIZE ShieldStatus;
-	STARSHIPPTR StarShipPtr;
-	PEVALUATE_DESC lpEvalDesc;
+	STARSHIP *StarShipPtr;
+	EVALUATE_DESC *lpEvalDesc;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 
@@ -239,7 +244,7 @@ utwig_intelligence (PELEMENT ShipPtr, PE
 	if (StarShipPtr->RaceDescPtr->ship_info.energy_level
 			&& (lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX])->ObjectPtr)
 	{
-		STARSHIPPTR EnemyStarShipPtr;
+		STARSHIP *EnemyStarShipPtr;
 
 		GetElementStarShip (lpEvalDesc->ObjectPtr, &EnemyStarShipPtr);
 		if (!(EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags
@@ -250,7 +255,8 @@ utwig_intelligence (PELEMENT ShipPtr, PE
 }
 
 static void
-utwig_collision (PELEMENT ElementPtr0, PPOINT pPt0, PELEMENT ElementPtr1, PPOINT pPt1)
+utwig_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
 	if (ElementPtr0->life_span > NORMAL_LIFE
 			&& (ElementPtr1->state_flags & FINITE_LIFE)
@@ -261,10 +267,10 @@ utwig_collision (PELEMENT ElementPtr0, P
 }
 
 static void
-utwig_preprocess (PELEMENT ElementPtr)
+utwig_preprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
-	PPRIMITIVE lpPrim;
+	STARSHIP *StarShipPtr;
+	PRIMITIVE *lpPrim;
 
 	if (ElementPtr->state_flags & APPEARING)
 	{
@@ -354,16 +360,14 @@ utwig_preprocess (PELEMENT ElementPtr)
 	}
 }
 
-RACE_DESCPTR
+RACE_DESC*
 init_utwig (void)
 {
-	RACE_DESCPTR RaceDescPtr;
+	RACE_DESC *RaceDescPtr;
 
 	utwig_desc.preprocess_func = utwig_preprocess;
 	utwig_desc.init_weapon_func = initialize_lance;
-	utwig_desc.cyborg_control.intelligence_func =
-			(void (*) (PVOID ShipPtr, PVOID ObjectsOfConcern, COUNT
-					ConcernCounter)) utwig_intelligence;
+	utwig_desc.cyborg_control.intelligence_func = utwig_intelligence;
 
 	RaceDescPtr = &utwig_desc;
 
diff -ruNp src.orig/sc2code/ships/vux/icode.h src/sc2code/ships/vux/icode.h
--- src.orig/sc2code/ships/vux/icode.h	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/vux/icode.h	2017-11-08 16:50:08 -0600
@@ -1,3 +1,5 @@
-#define VUX_CODE 0x00200008L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define VUX_CODE "ship.vux.code"
diff -ruNp src.orig/sc2code/ships/vux/igfxres.h src/sc2code/ships/vux/igfxres.h
--- src.orig/sc2code/ships/vux/igfxres.h	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/vux/igfxres.h	2017-11-08 16:50:08 -0600
@@ -1,12 +1,14 @@
-#define VUX_ICON_MASK_PMAP_ANIM 0x00200002L
-#define VUX_MICON_MASK_PMAP_ANIM 0x00200102L
-#define VUX_BIG_MASK_PMAP_ANIM 0x00400202L
-#define VUX_MED_MASK_PMAP_ANIM 0x00400302L
-#define VUX_SML_MASK_PMAP_ANIM 0x00400402L
-#define LIMPETS_BIG_MASK_PMAP_ANIM 0x00400502L
-#define LIMPETS_MED_MASK_PMAP_ANIM 0x00400602L
-#define LIMPETS_SML_MASK_PMAP_ANIM 0x00400702L
-#define SLIME_MASK_PMAP_ANIM 0x00400802L
-#define VUX_CAPTAIN_MASK_PMAP_ANIM 0x00400902L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define LIMPETS_BIG_MASK_PMAP_ANIM "ship.vux.graphics.limpets.large"
+#define LIMPETS_MED_MASK_PMAP_ANIM "ship.vux.graphics.limpets.medium"
+#define LIMPETS_SML_MASK_PMAP_ANIM "ship.vux.graphics.limpets.small"
+#define SLIME_MASK_PMAP_ANIM "ship.vux.graphics.slime"
+#define VUX_BIG_MASK_PMAP_ANIM "ship.vux.graphics.vux.large"
+#define VUX_CAPTAIN_MASK_PMAP_ANIM "ship.vux.graphics.captain"
+#define VUX_ICON_MASK_PMAP_ANIM "ship.vux.icons"
+#define VUX_MED_MASK_PMAP_ANIM "ship.vux.graphics.vux.medium"
+#define VUX_MICON_MASK_PMAP_ANIM "ship.vux.meleeicons"
+#define VUX_SML_MASK_PMAP_ANIM "ship.vux.graphics.vux.small"
diff -ruNp src.orig/sc2code/ships/vux/imusicre.h src/sc2code/ships/vux/imusicre.h
--- src.orig/sc2code/ships/vux/imusicre.h	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/vux/imusicre.h	2017-11-08 16:50:08 -0600
@@ -1,3 +1,5 @@
-#define VUX_VICTORY_SONG 0x00400006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define VUX_VICTORY_SONG "ship.vux.ditty"
diff -ruNp src.orig/sc2code/ships/vux/isndres.h src/sc2code/ships/vux/isndres.h
--- src.orig/sc2code/ships/vux/isndres.h	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/vux/isndres.h	2017-11-08 16:50:08 -0600
@@ -1,3 +1,5 @@
-#define VUX_SHIP_SOUNDS 0x00400005L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define VUX_SHIP_SOUNDS "ship.vux.sounds"
diff -ruNp src.orig/sc2code/ships/vux/istrtab.h src/sc2code/ships/vux/istrtab.h
--- src.orig/sc2code/ships/vux/istrtab.h	2017-11-08 16:49:40 -0600
+++ src/sc2code/ships/vux/istrtab.h	2017-11-08 16:50:08 -0600
@@ -1,3 +1,5 @@
-#define VUX_RACE_STRINGS 0x00200004L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define VUX_RACE_STRINGS "ship.vux.text"
diff -ruNp src.orig/sc2code/ships/vux/vux.c src/sc2code/ships/vux/vux.c
--- src.orig/sc2code/ships/vux/vux.c	2017-11-08 16:49:41 -0600
+++ src/sc2code/ships/vux/vux.c	2017-11-08 16:50:08 -0600
@@ -44,18 +44,21 @@
 
 static RACE_DESC vux_desc =
 {
-	{
+	{ /* SHIP_INFO */
 		FIRES_FORE | SEEKING_SPECIAL | IMMEDIATE_WEAPON,
 		12, /* Super Melee cost */
-		900 / SPHERE_RADIUS_INCREMENT, /* Initial sphere of influence radius */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY, MAX_ENERGY,
-		{
+		VUX_RACE_STRINGS,
+		VUX_ICON_MASK_PMAP_ANIM,
+		VUX_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		900 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
 			4412, 1558,
 		},
-		(STRING)VUX_RACE_STRINGS,
-		(FRAME)VUX_ICON_MASK_PMAP_ANIM,
-		(FRAME)VUX_MICON_MASK_PMAP_ANIM,
 	},
 	{
 		MAX_THRUST,
@@ -72,34 +75,35 @@ static RACE_DESC vux_desc =
 	},
 	{
 		{
-			(FRAME)VUX_BIG_MASK_PMAP_ANIM,
-			(FRAME)VUX_MED_MASK_PMAP_ANIM,
-			(FRAME)VUX_SML_MASK_PMAP_ANIM,
+			VUX_BIG_MASK_PMAP_ANIM,
+			VUX_MED_MASK_PMAP_ANIM,
+			VUX_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)SLIME_MASK_PMAP_ANIM,
-			(FRAME)0,
-			(FRAME)0,
+			SLIME_MASK_PMAP_ANIM,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
 		},
 		{
-			(FRAME)LIMPETS_BIG_MASK_PMAP_ANIM,
-			(FRAME)LIMPETS_MED_MASK_PMAP_ANIM,
-			(FRAME)LIMPETS_SML_MASK_PMAP_ANIM,
+			LIMPETS_BIG_MASK_PMAP_ANIM,
+			LIMPETS_MED_MASK_PMAP_ANIM,
+			LIMPETS_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)VUX_CAPTAIN_MASK_PMAP_ANIM,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			VUX_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
 		},
-		(SOUND)VUX_VICTORY_SONG,
-		(SOUND)VUX_SHIP_SOUNDS,
+		VUX_VICTORY_SONG,
+		VUX_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
 	},
 	{
 		0,
 		CLOSE_RANGE_WEAPON,
-		NULL_PTR,
+		NULL,
 	},
 	(UNINIT_FUNC *) NULL,
 	(PREPROCESS_FUNC *) NULL,
@@ -111,7 +115,7 @@ static RACE_DESC vux_desc =
 #define LIMPET_SPEED 25
 
 static void
-limpet_preprocess (PELEMENT ElementPtr)
+limpet_preprocess (ELEMENT *ElementPtr)
 {
 	COUNT facing, orig_facing;
 	SIZE delta_facing;
@@ -132,14 +136,14 @@ limpet_preprocess (PELEMENT ElementPtr)
 }
 
 static void
-limpet_collision (PELEMENT ElementPtr0, PPOINT pPt0, PELEMENT
-		ElementPtr1, PPOINT pPt1)
+limpet_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
 	if (ElementPtr1->state_flags & PLAYER_SHIP)
 	{
 		STAMP s;
-		STARSHIPPTR StarShipPtr;
-		RACE_DESCPTR RDPtr;
+		STARSHIP *StarShipPtr;
+		RACE_DESC *RDPtr;
 
 		GetElementStarShip (ElementPtr1, &StarShipPtr);
 		RDPtr = StarShipPtr->RaceDescPtr;
@@ -185,14 +189,14 @@ limpet_collision (PELEMENT ElementPtr0,
 }
 
 static void
-spawn_limpets (PELEMENT ElementPtr)
+spawn_limpets (ELEMENT *ElementPtr)
 {
 #define LIMPET_OFFSET 8
 #define LIMPET_LIFE 80
 #define LIMPET_HITS 1
 #define LIMPET_DAMAGE 0
 	HELEMENT Limpet;
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
@@ -214,7 +218,7 @@ spawn_limpets (PELEMENT ElementPtr)
 	Limpet = initialize_missile (&MissileBlock);
 	if (Limpet)
 	{
-		ELEMENTPTR LimpetPtr;
+		ELEMENT *LimpetPtr;
 
 		LockElement (Limpet, &LimpetPtr);
 		LimpetPtr->collision_func = limpet_collision;
@@ -226,9 +230,9 @@ spawn_limpets (PELEMENT ElementPtr)
 }
 
 static COUNT
-initialize_horrific_laser (PELEMENT ShipPtr, HELEMENT LaserArray[])
+initialize_horrific_laser (ELEMENT *ShipPtr, HELEMENT LaserArray[])
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	LASER_BLOCK LaserBlock;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
@@ -247,11 +251,11 @@ initialize_horrific_laser (PELEMENT Ship
 }
 
 static void
-vux_intelligence (PELEMENT ShipPtr, PEVALUATE_DESC ObjectsOfConcern,
+vux_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
 		COUNT ConcernCounter)
 {
-	PEVALUATE_DESC lpEvalDesc;
-	STARSHIPPTR StarShipPtr;
+	EVALUATE_DESC *lpEvalDesc;
+	STARSHIP *StarShipPtr;
 
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
 	 lpEvalDesc->MoveState = PURSUE;
@@ -283,9 +287,9 @@ vux_intelligence (PELEMENT ShipPtr, PEVA
 }
 
 static void
-vux_postprocess (PELEMENT ElementPtr)
+vux_postprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if ((StarShipPtr->cur_status_flags & SPECIAL)
@@ -303,19 +307,19 @@ vux_postprocess (PELEMENT ElementPtr)
 }
 
 static void
-vux_preprocess (PELEMENT ElementPtr)
+vux_preprocess (ELEMENT *ElementPtr)
 {
 	if (ElementPtr->state_flags & APPEARING)
 	{
 		COUNT facing;
-		STARSHIPPTR StarShipPtr;
+		STARSHIP *StarShipPtr;
 
 		GetElementStarShip (ElementPtr, &StarShipPtr);
 		facing = StarShipPtr->ShipFacing;
 		if (LOBYTE (GLOBAL (CurrentActivity)) != IN_ENCOUNTER
 				&& TrackShip (ElementPtr, &facing) >= 0)
 		{
-			ELEMENTPTR OtherShipPtr;
+			ELEMENT *OtherShipPtr;
 
 			LockElement (ElementPtr->hTarget, &OtherShipPtr);
 
@@ -370,17 +374,15 @@ vux_preprocess (PELEMENT ElementPtr)
 	}
 }
 
-RACE_DESCPTR
+RACE_DESC*
 init_vux (void)
 {
-	RACE_DESCPTR RaceDescPtr;
+	RACE_DESC *RaceDescPtr;
 
 	vux_desc.preprocess_func = vux_preprocess;
 	vux_desc.postprocess_func = vux_postprocess;
 	vux_desc.init_weapon_func = initialize_horrific_laser;
-	vux_desc.cyborg_control.intelligence_func =
-			(void (*) (PVOID ShipPtr, PVOID ObjectsOfConcern, COUNT
-					ConcernCounter)) vux_intelligence;
+	vux_desc.cyborg_control.intelligence_func = vux_intelligence;
 
 	RaceDescPtr = &vux_desc;
 
diff -ruNp src.orig/sc2code/ships/yehat/icode.h src/sc2code/ships/yehat/icode.h
--- src.orig/sc2code/ships/yehat/icode.h	2017-11-08 16:49:41 -0600
+++ src/sc2code/ships/yehat/icode.h	2017-11-08 16:50:08 -0600
@@ -1,3 +1,5 @@
-#define YEHAT_CODE 0x00200008L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define YEHAT_CODE "ship.yehat.code"
diff -ruNp src.orig/sc2code/ships/yehat/igfxres.h src/sc2code/ships/yehat/igfxres.h
--- src.orig/sc2code/ships/yehat/igfxres.h	2017-11-08 16:49:41 -0600
+++ src/sc2code/ships/yehat/igfxres.h	2017-11-08 16:50:08 -0600
@@ -1,14 +1,16 @@
-#define YEHAT_ICON_MASK_PMAP_ANIM 0x00200002L
-#define YEHAT_MICON_MASK_PMAP_ANIM 0x00200102L
-#define YEHAT_BIG_MASK_PMAP_ANIM 0x00400202L
-#define YEHAT_MED_MASK_PMAP_ANIM 0x00400302L
-#define YEHAT_SML_MASK_PMAP_ANIM 0x00400402L
-#define YEHAT_CANNON_BIG_MASK_PMAP_ANIM 0x00400502L
-#define YEHAT_CANNON_MED_MASK_PMAP_ANIM 0x00400602L
-#define YEHAT_CANNON_SML_MASK_PMAP_ANIM 0x00400702L
-#define SHIELD_BIG_MASK_ANIM 0x00400802L
-#define SHIELD_MED_MASK_ANIM 0x00400902L
-#define SHIELD_SML_MASK_ANIM 0x00400a02L
-#define YEHAT_CAPTAIN_MASK_PMAP_ANIM 0x00400b02L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SHIELD_BIG_MASK_ANIM "ship.yehat.graphics.shield.large"
+#define SHIELD_MED_MASK_ANIM "ship.yehat.graphics.shield.medium"
+#define SHIELD_SML_MASK_ANIM "ship.yehat.graphics.shield.small"
+#define YEHAT_BIG_MASK_PMAP_ANIM "ship.yehat.graphics.yehat.large"
+#define YEHAT_CANNON_BIG_MASK_PMAP_ANIM "ship.yehat.graphics.missile.large"
+#define YEHAT_CANNON_MED_MASK_PMAP_ANIM "ship.yehat.graphics.missile.medium"
+#define YEHAT_CANNON_SML_MASK_PMAP_ANIM "ship.yehat.graphics.missile.small"
+#define YEHAT_CAPTAIN_MASK_PMAP_ANIM "ship.yehat.graphics.captain"
+#define YEHAT_ICON_MASK_PMAP_ANIM "ship.yehat.icons"
+#define YEHAT_MED_MASK_PMAP_ANIM "ship.yehat.graphics.yehat.medium"
+#define YEHAT_MICON_MASK_PMAP_ANIM "ship.yehat.meleeicons"
+#define YEHAT_SML_MASK_PMAP_ANIM "ship.yehat.graphics.yehat.small"
diff -ruNp src.orig/sc2code/ships/yehat/imusicre.h src/sc2code/ships/yehat/imusicre.h
--- src.orig/sc2code/ships/yehat/imusicre.h	2017-11-08 16:49:41 -0600
+++ src/sc2code/ships/yehat/imusicre.h	2017-11-08 16:50:08 -0600
@@ -1,3 +1,5 @@
-#define YEHAT_VICTORY_SONG 0x00400006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define YEHAT_VICTORY_SONG "ship.yehat.ditty"
diff -ruNp src.orig/sc2code/ships/yehat/isndres.h src/sc2code/ships/yehat/isndres.h
--- src.orig/sc2code/ships/yehat/isndres.h	2017-11-08 16:49:41 -0600
+++ src/sc2code/ships/yehat/isndres.h	2017-11-08 16:50:08 -0600
@@ -1,3 +1,5 @@
-#define YEHAT_SHIP_SOUNDS 0x00400005L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define YEHAT_SHIP_SOUNDS "ship.yehat.sounds"
diff -ruNp src.orig/sc2code/ships/yehat/istrtab.h src/sc2code/ships/yehat/istrtab.h
--- src.orig/sc2code/ships/yehat/istrtab.h	2017-11-08 16:49:41 -0600
+++ src/sc2code/ships/yehat/istrtab.h	2017-11-08 16:50:08 -0600
@@ -1,3 +1,5 @@
-#define YEHAT_RACE_STRINGS 0x00200004L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define YEHAT_RACE_STRINGS "ship.yehat.text"
diff -ruNp src.orig/sc2code/ships/yehat/yehat.c src/sc2code/ships/yehat/yehat.c
--- src.orig/sc2code/ships/yehat/yehat.c	2017-11-08 16:49:41 -0600
+++ src/sc2code/ships/yehat/yehat.c	2017-11-08 16:50:08 -0600
@@ -41,18 +41,21 @@
 
 static RACE_DESC yehat_desc =
 {
-	{
+	{ /* SHIP_INFO */
 		FIRES_FORE | SHIELD_DEFENSE,
 		23, /* Super Melee cost */
-		750 / SPHERE_RADIUS_INCREMENT, /* Initial sphere of influence radius */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY, MAX_ENERGY,
-		{
+		YEHAT_RACE_STRINGS,
+		YEHAT_ICON_MASK_PMAP_ANIM,
+		YEHAT_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		750 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
 			4970, 40,
 		},
-		(STRING)YEHAT_RACE_STRINGS,
-		(FRAME)YEHAT_ICON_MASK_PMAP_ANIM,
-		(FRAME)YEHAT_MICON_MASK_PMAP_ANIM,
 	},
 	{
 		MAX_THRUST,
@@ -69,34 +72,35 @@ static RACE_DESC yehat_desc =
 	},
 	{
 		{
-			(FRAME)YEHAT_BIG_MASK_PMAP_ANIM,
-			(FRAME)YEHAT_MED_MASK_PMAP_ANIM,
-			(FRAME)YEHAT_SML_MASK_PMAP_ANIM,
+			YEHAT_BIG_MASK_PMAP_ANIM,
+			YEHAT_MED_MASK_PMAP_ANIM,
+			YEHAT_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)YEHAT_CANNON_BIG_MASK_PMAP_ANIM,
-			(FRAME)YEHAT_CANNON_MED_MASK_PMAP_ANIM,
-			(FRAME)YEHAT_CANNON_SML_MASK_PMAP_ANIM,
+			YEHAT_CANNON_BIG_MASK_PMAP_ANIM,
+			YEHAT_CANNON_MED_MASK_PMAP_ANIM,
+			YEHAT_CANNON_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)SHIELD_BIG_MASK_ANIM,
-			(FRAME)SHIELD_MED_MASK_ANIM,
-			(FRAME)SHIELD_SML_MASK_ANIM,
+			SHIELD_BIG_MASK_ANIM,
+			SHIELD_MED_MASK_ANIM,
+			SHIELD_SML_MASK_ANIM,
 		},
 		{
-			(FRAME)YEHAT_CAPTAIN_MASK_PMAP_ANIM,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			YEHAT_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
 		},
-		(SOUND)YEHAT_VICTORY_SONG,
-		(SOUND)YEHAT_SHIP_SOUNDS,
+		YEHAT_VICTORY_SONG,
+		YEHAT_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
 	},
 	{
 		0,
 		MISSILE_SPEED * MISSILE_LIFE / 3,
-		NULL_PTR,
+		NULL,
 	},
 	(UNINIT_FUNC *) NULL,
 	(PREPROCESS_FUNC *) NULL,
@@ -106,7 +110,7 @@ static RACE_DESC yehat_desc =
 };
 
 static COUNT
-initialize_standard_missiles (PELEMENT ShipPtr, HELEMENT MissileArray[])
+initialize_standard_missiles (ELEMENT *ShipPtr, HELEMENT MissileArray[])
 {
 #define YEHAT_OFFSET 16
 #define LAUNCH_OFFS DISPLAY_TO_WORLD (8)
@@ -114,7 +118,7 @@ initialize_standard_missiles (PELEMENT S
 #define MISSILE_DAMAGE 1
 #define MISSILE_OFFSET 1
 	SIZE offs_x, offs_y;
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
@@ -127,7 +131,7 @@ initialize_standard_missiles (PELEMENT S
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
-	MissileBlock.preprocess_func = NULL_PTR;
+	MissileBlock.preprocess_func = NULL;
 	MissileBlock.blast_offs = MISSILE_OFFSET;
 
 	offs_x = -SINE (FACING_TO_ANGLE (MissileBlock.face), LAUNCH_OFFS);
@@ -145,11 +149,12 @@ initialize_standard_missiles (PELEMENT S
 }
 
 static void
-yehat_intelligence (PELEMENT ShipPtr, PEVALUATE_DESC ObjectsOfConcern, COUNT ConcernCounter)
+yehat_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+		COUNT ConcernCounter)
 {
 	SIZE ShieldStatus;
-	STARSHIPPTR StarShipPtr;
-	PEVALUATE_DESC lpEvalDesc;
+	STARSHIP *StarShipPtr;
+	EVALUATE_DESC *lpEvalDesc;
 
 	ShieldStatus = -1;
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_WEAPON_INDEX];
@@ -202,7 +207,7 @@ yehat_intelligence (PELEMENT ShipPtr, PE
 
 	if ((lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX])->ObjectPtr)
 	{
-		STARSHIPPTR EnemyStarShipPtr;
+		STARSHIP *EnemyStarShipPtr;
 
 		GetElementStarShip (lpEvalDesc->ObjectPtr, &EnemyStarShipPtr);
 		if (!(EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags
@@ -217,11 +222,11 @@ yehat_intelligence (PELEMENT ShipPtr, PE
 }
 
 static void
-yehat_postprocess (PELEMENT ElementPtr)
+yehat_postprocess (ELEMENT *ElementPtr)
 {
 	if (!(ElementPtr->state_flags & NONSOLID))
 	{
-		STARSHIPPTR StarShipPtr;
+		STARSHIP *StarShipPtr;
 
 		GetElementStarShip (ElementPtr, &StarShipPtr);
 				/* take care of shield effect */
@@ -256,7 +261,7 @@ yehat_postprocess (PELEMENT ElementPtr)
 
 			if (hShipElement = AllocElement ())
 			{
-				ELEMENTPTR ShipElementPtr;
+				ELEMENT *ShipElementPtr;
 
 				InsertElement (hShipElement, GetSuccElement (ElementPtr));
 				LockElement (hShipElement, &ShipElementPtr);
@@ -282,7 +287,7 @@ yehat_postprocess (PELEMENT ElementPtr)
 				ShipElementPtr->next = ShipElementPtr->current;
 				ShipElementPtr->preprocess_func =
 						ShipElementPtr->postprocess_func =
-						ShipElementPtr->death_func = NULL_PTR;
+						ShipElementPtr->death_func = NULL;
 				ZeroVelocityComponents (&ShipElementPtr->velocity);
 
 				UnlockElement (hShipElement);
@@ -293,11 +298,11 @@ yehat_postprocess (PELEMENT ElementPtr)
 }
 
 static void
-yehat_preprocess (PELEMENT ElementPtr)
+yehat_preprocess (ELEMENT *ElementPtr)
 {
 	if (!(ElementPtr->state_flags & APPEARING))
 	{
-		STARSHIPPTR StarShipPtr;
+		STARSHIP *StarShipPtr;
 
 		GetElementStarShip (ElementPtr, &StarShipPtr);
 		if ((ElementPtr->life_span > NORMAL_LIFE
@@ -344,17 +349,15 @@ yehat_preprocess (PELEMENT ElementPtr)
 	}
 }
 
-RACE_DESCPTR
+RACE_DESC*
 init_yehat (void)
 {
-	RACE_DESCPTR RaceDescPtr;
+	RACE_DESC *RaceDescPtr;
 
 	yehat_desc.preprocess_func = yehat_preprocess;
 	yehat_desc.postprocess_func = yehat_postprocess;
 	yehat_desc.init_weapon_func = initialize_standard_missiles;
-	yehat_desc.cyborg_control.intelligence_func =
-			(void (*) (PVOID ShipPtr, PVOID ObjectsOfConcern, COUNT
-					ConcernCounter)) yehat_intelligence;
+	yehat_desc.cyborg_control.intelligence_func = yehat_intelligence;
 
 	RaceDescPtr = &yehat_desc;
 
diff -ruNp src.orig/sc2code/ships/zoqfot/icode.h src/sc2code/ships/zoqfot/icode.h
--- src.orig/sc2code/ships/zoqfot/icode.h	2017-11-08 16:49:41 -0600
+++ src/sc2code/ships/zoqfot/icode.h	2017-11-08 16:50:08 -0600
@@ -1,3 +1,5 @@
-#define ZOQFOTPIK_CODE 0x00200008L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ZOQFOTPIK_CODE "ship.zoqfotpik.code"
diff -ruNp src.orig/sc2code/ships/zoqfot/igfxres.h src/sc2code/ships/zoqfot/igfxres.h
--- src.orig/sc2code/ships/zoqfot/igfxres.h	2017-11-08 16:49:41 -0600
+++ src/sc2code/ships/zoqfot/igfxres.h	2017-11-08 16:50:08 -0600
@@ -1,14 +1,16 @@
-#define ZOQFOTPIK_ICON_MASK_PMAP_ANIM 0x00200002L
-#define ZOQFOTPIK_MICON_MASK_PMAP_ANIM 0x00200102L
-#define ZOQFOTPIK_BIG_MASK_PMAP_ANIM 0x00400202L
-#define ZOQFOTPIK_MED_MASK_PMAP_ANIM 0x00400302L
-#define ZOQFOTPIK_SML_MASK_PMAP_ANIM 0x00400402L
-#define SPIT_BIG_MASK_PMAP_ANIM 0x00400502L
-#define SPIT_MED_MASK_PMAP_ANIM 0x00400602L
-#define SPIT_SML_MASK_PMAP_ANIM 0x00400702L
-#define STINGER_BIG_MASK_PMAP_ANIM 0x00400802L
-#define STINGER_MED_MASK_PMAP_ANIM 0x00400902L
-#define STINGER_SML_MASK_PMAP_ANIM 0x00400a02L
-#define ZOQFOTPIK_CAPTAIN_MASK_PMAP_ANIM 0x00400b02L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define SPIT_BIG_MASK_PMAP_ANIM "ship.zoqfotpik.graphics.spit.large"
+#define SPIT_MED_MASK_PMAP_ANIM "ship.zoqfotpik.graphics.spit.medium"
+#define SPIT_SML_MASK_PMAP_ANIM "ship.zoqfotpik.graphics.spit.small"
+#define STINGER_BIG_MASK_PMAP_ANIM "ship.zoqfotpik.graphics.sti.large"
+#define STINGER_MED_MASK_PMAP_ANIM "ship.zoqfotpik.graphics.sti.medium"
+#define STINGER_SML_MASK_PMAP_ANIM "ship.zoqfotpik.graphics.sti.small"
+#define ZOQFOTPIK_BIG_MASK_PMAP_ANIM "ship.zoqfotpik.graphics.zoqfot.large"
+#define ZOQFOTPIK_CAPTAIN_MASK_PMAP_ANIM "ship.zoqfotpik.graphics.captain"
+#define ZOQFOTPIK_ICON_MASK_PMAP_ANIM "ship.zoqfotpik.icons"
+#define ZOQFOTPIK_MED_MASK_PMAP_ANIM "ship.zoqfotpik.graphics.zoqfot.medium"
+#define ZOQFOTPIK_MICON_MASK_PMAP_ANIM "ship.zoqfotpik.meleeicons"
+#define ZOQFOTPIK_SML_MASK_PMAP_ANIM "ship.zoqfotpik.graphics.zoqfot.small"
diff -ruNp src.orig/sc2code/ships/zoqfot/imusicre.h src/sc2code/ships/zoqfot/imusicre.h
--- src.orig/sc2code/ships/zoqfot/imusicre.h	2017-11-08 16:49:41 -0600
+++ src/sc2code/ships/zoqfot/imusicre.h	2017-11-08 16:50:08 -0600
@@ -1,3 +1,5 @@
-#define ZOQFOTPIK_VICTORY_SONG 0x00400006L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ZOQFOTPIK_VICTORY_SONG "ship.zoqfotpik.ditty"
diff -ruNp src.orig/sc2code/ships/zoqfot/isndres.h src/sc2code/ships/zoqfot/isndres.h
--- src.orig/sc2code/ships/zoqfot/isndres.h	2017-11-08 16:49:41 -0600
+++ src/sc2code/ships/zoqfot/isndres.h	2017-11-08 16:50:08 -0600
@@ -1,3 +1,5 @@
-#define ZOQFOTPIK_SHIP_SOUNDS 0x00400005L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ZOQFOTPIK_SHIP_SOUNDS "ship.zoqfotpik.sounds"
diff -ruNp src.orig/sc2code/ships/zoqfot/istrtab.h src/sc2code/ships/zoqfot/istrtab.h
--- src.orig/sc2code/ships/zoqfot/istrtab.h	2017-11-08 16:49:41 -0600
+++ src/sc2code/ships/zoqfot/istrtab.h	2017-11-08 16:50:08 -0600
@@ -1,3 +1,5 @@
-#define ZOQFOTPIK_RACE_STRINGS 0x00200004L
-
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
+#define ZOQFOTPIK_RACE_STRINGS "ship.zoqfotpik.text"
diff -ruNp src.orig/sc2code/ships/zoqfot/zoqfot.c src/sc2code/ships/zoqfot/zoqfot.c
--- src.orig/sc2code/ships/zoqfot/zoqfot.c	2017-11-08 16:49:41 -0600
+++ src/sc2code/ships/zoqfot/zoqfot.c	2017-11-08 16:50:08 -0600
@@ -42,18 +42,21 @@
 
 static RACE_DESC zoqfotpik_desc =
 {
-	{
+	{ /* SHIP_INFO */
 		FIRES_FORE,
 		6, /* Super Melee cost */
-		320 / SPHERE_RADIUS_INCREMENT, /* Initial sphere of influence radius */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY, MAX_ENERGY,
-		{
+		ZOQFOTPIK_RACE_STRINGS,
+		ZOQFOTPIK_ICON_MASK_PMAP_ANIM,
+		ZOQFOTPIK_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		320 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
 			3761, 5333,
 		},
-		(STRING)ZOQFOTPIK_RACE_STRINGS,
-		(FRAME)ZOQFOTPIK_ICON_MASK_PMAP_ANIM,
-		(FRAME)ZOQFOTPIK_MICON_MASK_PMAP_ANIM,
 	},
 	{
 		MAX_THRUST,
@@ -70,34 +73,35 @@ static RACE_DESC zoqfotpik_desc =
 	},
 	{
 		{
-			(FRAME)ZOQFOTPIK_BIG_MASK_PMAP_ANIM,
-			(FRAME)ZOQFOTPIK_MED_MASK_PMAP_ANIM,
-			(FRAME)ZOQFOTPIK_SML_MASK_PMAP_ANIM,
+			ZOQFOTPIK_BIG_MASK_PMAP_ANIM,
+			ZOQFOTPIK_MED_MASK_PMAP_ANIM,
+			ZOQFOTPIK_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)SPIT_BIG_MASK_PMAP_ANIM,
-			(FRAME)SPIT_MED_MASK_PMAP_ANIM,
-			(FRAME)SPIT_SML_MASK_PMAP_ANIM,
+			SPIT_BIG_MASK_PMAP_ANIM,
+			SPIT_MED_MASK_PMAP_ANIM,
+			SPIT_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)STINGER_BIG_MASK_PMAP_ANIM,
-			(FRAME)STINGER_MED_MASK_PMAP_ANIM,
-			(FRAME)STINGER_SML_MASK_PMAP_ANIM,
+			STINGER_BIG_MASK_PMAP_ANIM,
+			STINGER_MED_MASK_PMAP_ANIM,
+			STINGER_SML_MASK_PMAP_ANIM,
 		},
 		{
-			(FRAME)ZOQFOTPIK_CAPTAIN_MASK_PMAP_ANIM,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
-			(FRAME)0,
+			ZOQFOTPIK_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
 		},
-		(SOUND)ZOQFOTPIK_VICTORY_SONG,
-		(SOUND)ZOQFOTPIK_SHIP_SOUNDS,
+		ZOQFOTPIK_VICTORY_SONG,
+		ZOQFOTPIK_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
 	},
 	{
 		0,
 		MISSILE_RANGE,
-		NULL_PTR,
+		NULL,
 	},
 	(UNINIT_FUNC *) NULL,
 	(PREPROCESS_FUNC *) NULL,
@@ -110,7 +114,7 @@ static RACE_DESC zoqfotpik_desc =
 #define SPIT_WAIT 2
 
 static void
-spit_preprocess (PELEMENT ElementPtr)
+spit_preprocess (ELEMENT *ElementPtr)
 {
 	if (ElementPtr->turn_wait > 0)
 		--ElementPtr->turn_wait;
@@ -136,12 +140,12 @@ spit_preprocess (PELEMENT ElementPtr)
 }
 
 static COUNT
-initialize_spit (PELEMENT ShipPtr, HELEMENT SpitArray[])
+initialize_spit (ELEMENT *ShipPtr, HELEMENT SpitArray[])
 {
 #define MISSILE_DAMAGE 1
 #define MISSILE_HITS 1
 #define MISSILE_OFFSET 0
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
@@ -165,19 +169,20 @@ initialize_spit (PELEMENT ShipPtr, HELEM
 	return (1);
 }
 
-static void spawn_tongue (PELEMENT ElementPtr);
+static void spawn_tongue (ELEMENT *ElementPtr);
 
 static void
-tongue_postprocess (PELEMENT ElementPtr)
+tongue_postprocess (ELEMENT *ElementPtr)
 {
 	if (ElementPtr->turn_wait)
 		spawn_tongue (ElementPtr);
 }
 
 static void
-tongue_collision (PELEMENT ElementPtr0, PPOINT pPt0, PELEMENT ElementPtr1, PPOINT pPt1)
+tongue_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr0, &StarShipPtr);
 	if (StarShipPtr->special_counter ==
@@ -190,14 +195,13 @@ tongue_collision (PELEMENT ElementPtr0,
 }
 
 static void
-spawn_tongue (ElementPtr)
-PELEMENT ElementPtr;
+spawn_tongue (ELEMENT *ElementPtr)
 {
 #define TONGUE_SPEED 0
 #define TONGUE_HITS 1
 #define TONGUE_DAMAGE 12
 #define TONGUE_OFFSET 4
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK TongueBlock;
 	HELEMENT Tongue;
 
@@ -218,7 +222,7 @@ PELEMENT ElementPtr;
 	Tongue = initialize_missile (&TongueBlock);
 	if (Tongue)
 	{
-		ELEMENTPTR TonguePtr;
+		ELEMENT *TonguePtr;
 
 		LockElement (Tongue, &TonguePtr);
 		TonguePtr->postprocess_func = tongue_postprocess;
@@ -255,17 +259,18 @@ PELEMENT ElementPtr;
 }
 
 static void
-zoqfotpik_intelligence (PELEMENT ShipPtr, PEVALUATE_DESC ObjectsOfConcern, COUNT ConcernCounter)
+zoqfotpik_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+		COUNT ConcernCounter)
 {
 	BOOLEAN GiveTongueJob;
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 
 	GiveTongueJob = FALSE;
 	if (StarShipPtr->special_counter == 0)
 	{
-			PEVALUATE_DESC lpEnemyEvalDesc;
+		EVALUATE_DESC *lpEnemyEvalDesc;
 
 		StarShipPtr->ship_input_state &= ~SPECIAL;
 
@@ -326,9 +331,9 @@ zoqfotpik_intelligence (PELEMENT ShipPtr
 }
 
 static void
-zoqfotpik_postprocess (PELEMENT ElementPtr)
+zoqfotpik_postprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if ((StarShipPtr->cur_status_flags & SPECIAL)
@@ -347,16 +352,14 @@ zoqfotpik_postprocess (PELEMENT ElementP
 		spawn_tongue (ElementPtr);
 }
 
-RACE_DESCPTR
+RACE_DESC*
 init_zoqfotpik (void)
 {
-	RACE_DESCPTR RaceDescPtr;
+	RACE_DESC *RaceDescPtr;
 
 	zoqfotpik_desc.postprocess_func = zoqfotpik_postprocess;
 	zoqfotpik_desc.init_weapon_func = initialize_spit;
-	zoqfotpik_desc.cyborg_control.intelligence_func =
-			(void (*) (PVOID ShipPtr, PVOID ObjectsOfConcern, COUNT
-					ConcernCounter)) zoqfotpik_intelligence;
+	zoqfotpik_desc.cyborg_control.intelligence_func = zoqfotpik_intelligence;
 
 	RaceDescPtr = &zoqfotpik_desc;
 
diff -ruNp src.orig/sc2code/shipstat.c src/sc2code/shipstat.c
--- src.orig/sc2code/shipstat.c	2017-11-08 16:49:41 -0600
+++ src/sc2code/shipstat.c	2017-11-08 16:50:08 -0600
@@ -133,15 +133,13 @@ OutlineShipStatus (COORD y)
 }
 
 void
-InitShipStatus (STARSHIPPTR StarShipPtr, PRECT pClipRect)
+InitShipStatus (SHIP_INFO *SIPtr, BYTE captains_name_index, RECT *pClipRect)
 {
 	RECT r;
 	COORD y, y_stat;
 	STAMP Stamp;
 	CONTEXT OldContext;
-	SHIP_INFOPTR SIPtr;
 
-	SIPtr = &StarShipPtr->RaceDescPtr->ship_info;
 	y_stat = (SIPtr->ship_flags & GOOD_GUY) ?
 			GOOD_GUY_YOFFS : BAD_GUY_YOFFS;
 
@@ -227,8 +225,7 @@ InitShipStatus (STARSHIPPTR StarShipPtr,
 		DrawFilledRectangle (&r);
 	}
 
-	if (StarShipPtr->captains_name_index
-			|| LOBYTE (GLOBAL (CurrentActivity)) == SUPER_MELEE)
+	if (captains_name_index)
 	{
 		STRING locString;
 
@@ -255,7 +252,7 @@ InitShipStatus (STARSHIPPTR StarShipPtr,
 			else
 			{
 				locString = SetAbsStringTableIndex (SIPtr->race_strings,
-						StarShipPtr->captains_name_index);
+						captains_name_index);
 				Text.pStr = (UNICODE *)GetStringAddress (locString);
 				Text.CharCount = GetStringLength (locString);
 			}
@@ -270,8 +267,8 @@ InitShipStatus (STARSHIPPTR StarShipPtr,
 			SetContextFont (OldFont);
 		}
 	}
-	else if (StarShipPtr->captains_name_index == 0)
-	{
+	else /* if (captains_name_index == 0) */
+	{	/* Only SIS or Sa-Matra */
 		if (SIPtr->ship_flags & GOOD_GUY)
 		{
 			DrawCrewFuelString (y, 0);
@@ -285,7 +282,7 @@ InitShipStatus (STARSHIPPTR StarShipPtr,
 		crew_delta = SIPtr->crew_level;
 		energy_delta = SIPtr->energy_level;
 		SIPtr->crew_level = SIPtr->energy_level = 0;
-		DeltaStatistics (StarShipPtr, crew_delta, energy_delta);
+		DeltaStatistics (SIPtr, crew_delta, energy_delta);
 	}
 
 	UnbatchGraphics ();
@@ -303,21 +300,17 @@ InitShipStatus (STARSHIPPTR StarShipPtr,
 	SetContext (OldContext);
 }
 
-// Pre: -crew_delta <= StarShipPtr->crew_level
-//      crew_delta <= StarShipPtr->max_crew - StarShipPtr->crew_level
+// Pre: -crew_delta <= ShipInfoPtr->crew_level
+//      crew_delta <= ShipInfoPtr->max_crew - ShipInfoPtr->crew_level
 void
-DeltaStatistics (STARSHIPPTR StarShipPtr, SIZE crew_delta, SIZE
-		energy_delta)
+DeltaStatistics (SHIP_INFO *ShipInfoPtr, SIZE crew_delta, SIZE energy_delta)
 {
 	COORD x, y;
 	RECT r;
-	SHIP_INFOPTR ShipInfoPtr;
 
 	if (crew_delta == 0 && energy_delta == 0)
 		return;
 
-	ShipInfoPtr = &StarShipPtr->RaceDescPtr->ship_info;
-
 	x = 0;
 	y = GAUGE_YOFFS + ((ShipInfoPtr->ship_flags & GOOD_GUY) ?
 			GOOD_GUY_YOFFS : BAD_GUY_YOFFS);
@@ -395,7 +388,7 @@ DeltaStatistics (STARSHIPPTR StarShipPtr
 		{
 			// All crew doesn't fit in the graphics; print a number.
 			// Always print a number for the SIS in the full game.
-			DrawBattleCrewAmount (StarShipPtr);
+			DrawBattleCrewAmount (ShipInfoPtr);
 		}
 	}
 
diff -ruNp src.orig/sc2code/shipyard.c src/sc2code/shipyard.c
--- src.orig/sc2code/shipyard.c	2017-11-08 16:49:41 -0600
+++ src/sc2code/shipyard.c	2017-11-08 16:50:08 -0600
@@ -23,6 +23,7 @@
 #include "gameopt.h"
 #include "gamestr.h"
 #include "melee.h"
+#include "master.h"
 #include "options.h"
 #include "races.h"
 #include "nameref.h"
@@ -36,6 +37,8 @@
 #include "libs/graphics/gfx_common.h"
 #include "libs/inplib.h"
 
+static void BeginHangarAnim (MENU_STATE *pMS);
+static void EndHangarAnim (MENU_STATE *pMS);
 
 #ifdef USE_3DO_HANGAR
 // 3DO 4x3 hangar layout
@@ -121,31 +124,21 @@ hangar_anim_func (void *data)
 
 #ifdef WANT_SHIP_SPINS
 static void
-SpinStarShip (HSTARSHIP hStarShip)
+SpinStarShip (HFLEETINFO hStarShip)
 {
-	COUNT Index;
-	HSTARSHIP hNextShip, hShip;
-	STARSHIPPTR StarShipPtr;
-	extern QUEUE master_q;
-
-	StarShipPtr = LockStarShip (&GLOBAL (built_ship_q), hStarShip);
-
-	for (Index = 0, hShip = GetHeadLink (&master_q);
-			hShip; hShip = hNextShip, ++Index)
-	{
-		STARSHIPPTR SSPtr;
+	int Index;
+	FLEET_INFO *FleetPtr;
 
-		SSPtr = LockStarShip (&master_q, hShip);
-		if (StarShipPtr->RaceResIndex == SSPtr->RaceResIndex)
-			break;
-		hNextShip = _GetSuccLink (SSPtr);
-		UnlockStarShip (&master_q, hShip);
-	}
-
-	UnlockStarShip (&master_q, hStarShip);
+	FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
+	Index = FindMasterShipIndex (FleetPtr->SpeciesID);
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
 				
-	if (Index < NUM_MELEE_SHIPS)
+	if (Index >= 0 && Index < NUM_MELEE_SHIPS)
+	{
+		UnlockMutex (GraphicsLock);
 		DoShipSpin (Index, pMenuState->hMusic);
+		LockMutex (GraphicsLock);
+	}
 }
 #endif
 
@@ -154,46 +147,44 @@ static COUNT
 GetAvailableRaceCount (void)
 {
 	COUNT Index;
-	HSTARSHIP hStarShip, hNextShip;
+	HFLEETINFO hStarShip, hNextShip;
 
 	Index = 0;
 	for (hStarShip = GetHeadLink (&GLOBAL (avail_race_q));
 			hStarShip; hStarShip = hNextShip)
 	{
-		SHIP_FRAGMENTPTR StarShipPtr;
+		FLEET_INFO *FleetPtr;
 
-		StarShipPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-				&GLOBAL (avail_race_q), hStarShip);
-		if (StarShipPtr->ShipInfo.ship_flags & GOOD_GUY)
+		FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
+		if (FleetPtr->ship_flags & GOOD_GUY)
 			++Index;
 
-		hNextShip = _GetSuccLink (StarShipPtr);
-		UnlockStarShip (&GLOBAL (avail_race_q), hStarShip);
+		hNextShip = _GetSuccLink (FleetPtr);
+		UnlockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
 	}
 
 	return Index;
 }
 
-static HSTARSHIP
+static HFLEETINFO
 GetAvailableRaceFromIndex (BYTE Index)
 {
-	HSTARSHIP hStarShip, hNextShip;
+	HFLEETINFO hStarShip, hNextShip;
 
 	for (hStarShip = GetHeadLink (&GLOBAL (avail_race_q));
 			hStarShip; hStarShip = hNextShip)
 	{
-		SHIP_FRAGMENTPTR StarShipPtr;
+		FLEET_INFO *FleetPtr;
 
-		StarShipPtr = (SHIP_FRAGMENTPTR)LockStarShip (&GLOBAL (avail_race_q),
-				hStarShip);
-		if ((StarShipPtr->ShipInfo.ship_flags & GOOD_GUY) && Index-- == 0)
+		FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
+		if ((FleetPtr->ship_flags & GOOD_GUY) && Index-- == 0)
 		{
-			UnlockStarShip (&GLOBAL (avail_race_q), hStarShip);
+			UnlockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
 			return hStarShip;
 		}
 
-		hNextShip = _GetSuccLink (StarShipPtr);
-		UnlockStarShip (&GLOBAL (avail_race_q), hStarShip);
+		hNextShip = _GetSuccLink (FleetPtr);
+		UnlockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
 	}
 
 	return 0;
@@ -230,8 +221,8 @@ DrawRaceStrings (BYTE NewRaceItem)
 	if (NewRaceItem != (BYTE)~0)
 	{
 		TEXT t;
-		HSTARSHIP hStarShip;
-		STARSHIPPTR StarShipPtr;
+		HFLEETINFO hStarShip;
+		FLEET_INFO *FleetPtr;
 		UNICODE buf[30];
 		COUNT ShipCost[] =
 		{
@@ -244,9 +235,9 @@ DrawRaceStrings (BYTE NewRaceItem)
 		s.frame = SetAbsFrameIndex (pMenuState->ModuleFrame,
 				3 + NewRaceItem);
 		DrawStamp (&s);
-		StarShipPtr = LockStarShip (&GLOBAL (avail_race_q), hStarShip);
-		s.frame = StarShipPtr->RaceDescPtr->ship_info.melee_icon;
-		UnlockStarShip (&GLOBAL (avail_race_q), hStarShip);
+		FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
+		s.frame = FleetPtr->melee_icon;
+		UnlockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
 
 		t.baseline.x = s.origin.x + RADAR_WIDTH - 2;
 		t.baseline.y = s.origin.y + RADAR_HEIGHT - 2;
@@ -275,28 +266,27 @@ DrawRaceStrings (BYTE NewRaceItem)
 #define SHIP_WIN_FRAMES ((SHIP_WIN_WIDTH >> 1) + 1)
 
 static void
-ShowShipCrew (SHIP_FRAGMENTPTR StarShipPtr, PRECT pRect)
+ShowShipCrew (SHIP_FRAGMENT *StarShipPtr, RECT *pRect)
 {
 	RECT r;
 	TEXT t;
 	UNICODE buf[80];
-	HSTARSHIP hTemplate;
-	SHIP_FRAGMENTPTR TemplatePtr;
+	HFLEETINFO hTemplate;
+	FLEET_INFO *TemplatePtr;
 
 	hTemplate = GetStarShipFromIndex (&GLOBAL (avail_race_q),
-			GET_RACE_ID (StarShipPtr));
-	TemplatePtr = (SHIP_FRAGMENTPTR)LockStarShip (
-			&GLOBAL (avail_race_q), hTemplate);
-	if (StarShipPtr->ShipInfo.crew_level >=
-			TemplatePtr->RaceDescPtr->ship_info.crew_level)
-		sprintf (buf, "%u", StarShipPtr->ShipInfo.crew_level);
-	else if (StarShipPtr->ShipInfo.crew_level == 0)
+			StarShipPtr->race_id);
+	TemplatePtr = LockFleetInfo (&GLOBAL (avail_race_q), hTemplate);
+	if (StarShipPtr->crew_level >= TemplatePtr->crew_level)
+		sprintf (buf, "%u", StarShipPtr->crew_level);
+	else if (StarShipPtr->crew_level == 0)
+		// XXX: "SCRAP" needs to be moved to starcon.txt
 		utf8StringCopy (buf, sizeof (buf), "SCRAP");
 	else
 		sprintf (buf, "%u/%u",
-				StarShipPtr->ShipInfo.crew_level,
-				TemplatePtr->RaceDescPtr->ship_info.crew_level);
-	UnlockStarShip (&GLOBAL (avail_race_q), hTemplate);
+				StarShipPtr->crew_level,
+				TemplatePtr->crew_level);
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hTemplate);
 
 	r = *pRect;
 	t.baseline.x = r.corner.x + (r.extent.width >> 1);
@@ -312,21 +302,21 @@ ShowShipCrew (SHIP_FRAGMENTPTR StarShipP
 		SetContextForeGroundColor (BLACK_COLOR);
 		DrawFilledRectangle (&r);
 	}
-	SetContextForeGroundColor ((StarShipPtr->ShipInfo.crew_level != 0) ?
+	SetContextForeGroundColor ((StarShipPtr->crew_level != 0) ?
 			(BUILD_COLOR (MAKE_RGB15 (0x00, 0x14, 0x00), 0x02)):
 			(BUILD_COLOR (MAKE_RGB15 (0x12, 0x00, 0x00), 0x2B)));
 	font_DrawText (&t);
 }
 
 static void
-ShowCombatShip (COUNT which_window, SHIP_FRAGMENTPTR YankedStarShipPtr)
+ShowCombatShip (COUNT which_window, SHIP_FRAGMENT *YankedStarShipPtr)
 {
 	COUNT i, num_ships;
-	HSTARSHIP hStarShip, hNextShip;
-	SHIP_FRAGMENTPTR StarShipPtr;
+	HSHIPFRAG hStarShip, hNextShip;
+	SHIP_FRAGMENT *StarShipPtr;
 	struct
 	{
-		SHIP_FRAGMENTPTR StarShipPtr;
+		SHIP_FRAGMENT *StarShipPtr;
 		POINT finished_s;
 		STAMP ship_s, lfdoor_s, rtdoor_s;
 	} ship_win_info[MAX_COMBAT_SHIPS], *pship_win_info;
@@ -348,8 +338,7 @@ ShowCombatShip (COUNT which_window, SHIP
 
 		pship_win_info->ship_s.origin.x = (SHIP_WIN_WIDTH >> 1) + 1;
 		pship_win_info->ship_s.origin.y = (SHIP_WIN_WIDTH >> 1);
-		pship_win_info->ship_s.frame =
-				YankedStarShipPtr->ShipInfo.melee_icon;
+		pship_win_info->ship_s.frame = YankedStarShipPtr->melee_icon;
 
 		pship_win_info->finished_s.x = hangar_x_coords[
 				which_window % HANGAR_SHIPS_ROW];
@@ -365,7 +354,7 @@ ShowCombatShip (COUNT which_window, SHIP
 		}
 		else
 		{
-			HSTARSHIP hTailShip;
+			HSHIPFRAG hTailShip;
 
 			hTailShip = GetTailLink (&GLOBAL (built_ship_q));
 			RemoveQueue (&GLOBAL (built_ship_q), hTailShip);
@@ -373,31 +362,28 @@ ShowCombatShip (COUNT which_window, SHIP
 			hStarShip = GetHeadLink (&GLOBAL (built_ship_q));
 			while (hStarShip)
 			{
-				StarShipPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-						&GLOBAL (built_ship_q), hStarShip);
-				if (GET_GROUP_LOC (StarShipPtr) > which_window)
+				StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+				if (StarShipPtr->index > which_window)
 				{
-					UnlockStarShip (&GLOBAL (built_ship_q), hStarShip);
+					UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 					break;
 				}
 				hNextShip = _GetSuccLink (StarShipPtr);
-				UnlockStarShip (&GLOBAL (built_ship_q), hStarShip);
+				UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 
 				hStarShip = hNextShip;
 			}
 			InsertQueue (&GLOBAL (built_ship_q), hTailShip, hStarShip);
 
 			hStarShip = hTailShip;
-			StarShipPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-					&GLOBAL (built_ship_q), hStarShip);
-			SET_GROUP_LOC (StarShipPtr, which_window);
-			UnlockStarShip (&GLOBAL (built_ship_q), hStarShip);
+			StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+			StarShipPtr->index = which_window;
+			UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 		}
 
 		for (i = 0; i < num_ships; ++i)
 		{
-			StarShipPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-					&GLOBAL (built_ship_q), hStarShip);
+			StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 			hNextShip = _GetSuccLink (StarShipPtr);
 
 			pship_win_info->StarShipPtr = StarShipPtr;
@@ -413,17 +399,16 @@ ShowCombatShip (COUNT which_window, SHIP
 
 			pship_win_info->ship_s.origin.x = (SHIP_WIN_WIDTH >> 1) + 1;
 			pship_win_info->ship_s.origin.y = (SHIP_WIN_WIDTH >> 1);
-			pship_win_info->ship_s.frame =
-					StarShipPtr->ShipInfo.melee_icon;
+			pship_win_info->ship_s.frame = StarShipPtr->melee_icon;
 
-			which_window = GET_GROUP_LOC (StarShipPtr);
+			which_window = StarShipPtr->index;
 			pship_win_info->finished_s.x = hangar_x_coords[
 					which_window % HANGAR_SHIPS_ROW];
 			pship_win_info->finished_s.y = HANGAR_Y + (HANGAR_DY *
 					(which_window / HANGAR_SHIPS_ROW));
 			++pship_win_info;
 
-			UnlockStarShip (&GLOBAL (built_ship_q), hStarShip);
+			UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 			hStarShip = hNextShip;
 		}
 	}
@@ -501,7 +486,7 @@ ShowCombatShip (COUNT which_window, SHIP
 			}
 
 			UnbatchGraphics ();
-			SetContextClipRect (NULL_PTR);
+			SetContextClipRect (NULL);
 			SetContext (OldContext);
 			UnlockMutex (GraphicsLock);
 		}
@@ -565,12 +550,12 @@ CrewTransaction (SIZE crew_delta)
  * ships per row number must divide 0xf0 without remainder
  */
 static BOOLEAN
-DoModifyShips (PMENU_STATE pMS)
+DoModifyShips (MENU_STATE *pMS)
 {
 #define MODIFY_CREW_FLAG (1 << 8)
 	RECT r;
-	HSTARSHIP hStarShip, hNextShip;
-	SHIP_FRAGMENTPTR StarShipPtr;
+	HSHIPFRAG hStarShip, hNextShip;
+	SHIP_FRAGMENT *StarShipPtr;
 	BOOLEAN select, cancel;
 #ifdef WANT_SHIP_SPINS
 	BOOLEAN special;
@@ -601,6 +586,7 @@ DoModifyShips (PMENU_STATE pMS)
 	{
 		SBYTE dx = 0;
 		SBYTE dy = 0;
+		SBYTE do_loop = 0;
 		BYTE NewState;
 
 		if (!(pMS->delta_item & MODIFY_CREW_FLAG))
@@ -612,6 +598,8 @@ DoModifyShips (PMENU_STATE pMS)
 		if (PulsedInputState.menu[KEY_MENU_LEFT]) dx = -1;
 		if (PulsedInputState.menu[KEY_MENU_UP]) dy = -1;
 		if (PulsedInputState.menu[KEY_MENU_DOWN]) dy = 1;
+		if (PulsedInputState.menu[KEY_MENU_PAGE_UP]) do_loop = dx = 1;
+		if (PulsedInputState.menu[KEY_MENU_PAGE_DOWN]) do_loop = dx = -1;
 		NewState = pMS->CurState;
 		if (pMS->delta_item & MODIFY_CREW_FLAG)
 		{
@@ -656,17 +644,16 @@ DoModifyShips (PMENU_STATE pMS)
 			for (hStarShip = GetHeadLink (&GLOBAL (built_ship_q));
 					hStarShip; hStarShip = hNextShip)
 			{
-				StarShipPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-						&GLOBAL (built_ship_q), hStarShip);
+				StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 
-				if (GET_GROUP_LOC (StarShipPtr) == pMS->CurState)
+				if (StarShipPtr->index == pMS->CurState)
 				{
-					UnlockStarShip (&GLOBAL (built_ship_q), hStarShip);
+					UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 					break;
 				}
 
 				hNextShip = _GetSuccLink (StarShipPtr);
-				UnlockStarShip (&GLOBAL (built_ship_q), hStarShip);
+				UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 			}
 			if ((pMS->delta_item & MODIFY_CREW_FLAG) && (hStarShip))
 			{
@@ -683,18 +670,59 @@ DoModifyShips (PMENU_STATE pMS)
 #ifdef WANT_SHIP_SPINS
 			if (special)
 			{
-				HSTARSHIP hSpinShip;
+				HFLEETINFO hSpinShip = 0;
 				
-				if ((hSpinShip = hStarShip)
-						|| (HINIBBLE (pMS->CurState) == 0
-						&& (hSpinShip = GetAvailableRaceFromIndex (
-								LOBYTE (pMS->delta_item)))))
+				if ((special && (((hStarShip == 0
+						   && HINIBBLE (pMS->CurState) == 0)
+						  && (pMS->delta_item & MODIFY_CREW_FLAG))
+						 || ((hStarShip != 0 &&
+						      HINIBBLE (pMS->CurState) == 0)
+						     && !(pMS->delta_item & MODIFY_CREW_FLAG))))
+				    && (hStarShip
+					|| (HINIBBLE (pMS->CurState) == 0
+					    && (hSpinShip = GetAvailableRaceFromIndex (
+							LOBYTE (pMS->delta_item))))))
 				{
-					SetFlashRect (NULL_PTR, (FRAME)0);
+					CONTEXT OldContext;
+					RECT OldClipRect;
+					RECT flash_r;
+
+					if (!hSpinShip)
+					{	/* Get fleet info from selected escort */
+						SHIP_FRAGMENT *FragPtr = LockShipFrag (
+								&GLOBAL (built_ship_q), hStarShip);
+						hSpinShip = GetStarShipFromIndex (
+								&GLOBAL (avail_race_q), FragPtr->race_id);
+						UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+					}
+					
+					SetFlashRect (NULL, (FRAME)0);
+					// Do not call EndHangarAnim() with GraphicsLock held!
+					UnlockMutex (GraphicsLock);
+					EndHangarAnim (pMS);
+					LockMutex (GraphicsLock);
+
+					OldContext = SetContext (ScreenContext);
+					GetContextClipRect (&OldClipRect);
+
 					SpinStarShip (hSpinShip);
+
+					SetContextClipRect (&OldClipRect);
+					SetContext (OldContext);
+
+					BeginHangarAnim (pMS);
+					SetContext (SpaceContext);
+
 					if (hStarShip)
 						goto ChangeFlashRect;
-					SetFlashRect (SFR_MENU_3DO, (FRAME)0);
+
+					GetContextClipRect (&flash_r);
+					GetContextClipRect (&flash_r);
+					flash_r.corner.x = RADAR_X - flash_r.corner.x;
+					flash_r.corner.y = RADAR_Y - flash_r.corner.y;
+					flash_r.extent.width = RADAR_WIDTH;
+					flash_r.extent.height = RADAR_HEIGHT;
+					SetFlashRect (&flash_r, (FRAME)0);
 				}
 			}
 			else
@@ -711,7 +739,7 @@ DoModifyShips (PMENU_STATE pMS)
 				{
 					COUNT Index;
 
-// SetFlashRect (NULL_PTR, (FRAME)0);
+// SetFlashRect (NULL, (FRAME)0);
 					UnlockMutex (GraphicsLock);
 					if (!(pMS->delta_item & MODIFY_CREW_FLAG))
 					{
@@ -739,7 +767,7 @@ DoModifyShips (PMENU_STATE pMS)
 								&GLOBAL (built_ship_q), 1))
 						{
 							ShowCombatShip ((COUNT)pMS->CurState,
-									(SHIP_FRAGMENTPTR) 0);
+									(SHIP_FRAGMENT*)0);
 							//Reset flash rectangle
 							LockMutex (GraphicsLock);
 							SetFlashRect (SFR_MENU_3DO, (FRAME)0);
@@ -798,19 +826,19 @@ DoModifyShips (PMENU_STATE pMS)
 					if ((pMS->delta_item & MODIFY_CREW_FLAG)
 							&& hStarShip != 0)
 					{
-						StarShipPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-								&GLOBAL (built_ship_q), hStarShip);
-						if (StarShipPtr->ShipInfo.crew_level == 0)
+						StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q),
+								hStarShip);
+						if (StarShipPtr->crew_level == 0)
 						{
-							SetFlashRect (NULL_PTR, (FRAME)0);
+							SetFlashRect (NULL, (FRAME)0);
 							UnlockMutex (GraphicsLock);
 							ShowCombatShip ((COUNT)pMS->CurState,
 									StarShipPtr);
 							LockMutex (GraphicsLock);
-							UnlockStarShip (&GLOBAL (built_ship_q),
+							UnlockShipFrag (&GLOBAL (built_ship_q),
 									hStarShip);
 							RemoveQueue (&GLOBAL (built_ship_q), hStarShip);
-							FreeStarShip (&GLOBAL (built_ship_q), hStarShip);
+							FreeShipFrag (&GLOBAL (built_ship_q), hStarShip);
 							// refresh SIS display
 							DeltaSISGauges (UNDEFINED_DELTA, UNDEFINED_DELTA,
 									UNDEFINED_DELTA);
@@ -824,7 +852,7 @@ DoModifyShips (PMENU_STATE pMS)
 						}
 						else
 						{
-							UnlockStarShip (&GLOBAL (built_ship_q),
+							UnlockShipFrag (&GLOBAL (built_ship_q),
 									hStarShip);
 						}
 					}
@@ -858,17 +886,21 @@ DoModifyShips (PMENU_STATE pMS)
 				else if (pMS->delta_item & MODIFY_CREW_FLAG)
 				{
 					SIZE crew_delta, crew_bought;
+					int loop;
 
 					if (hStarShip)
-						StarShipPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-								&GLOBAL (built_ship_q), hStarShip);
+						StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q),
+								hStarShip);
 					else
 						StarShipPtr = NULL;  // Keeping compiler quiet.
 
-					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN,
+					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN | MENU_SOUND_PAGEUP | MENU_SOUND_PAGEDOWN,
 							MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
 					crew_delta = 0;
-					if (dy < 0)
+
+					for (loop = 0; loop < (do_loop ? 10 : 1); loop++)
+					{
+					if (dy < 0 || dx > 0)
 					{
 						if (hStarShip == 0)
 						{
@@ -878,7 +910,7 @@ DoModifyShips (PMENU_STATE pMS)
 							{
 								DrawPoint (&r.corner);
 								DeltaSISGauges (1, 0, -GLOBAL (CrewCost));
-								crew_delta = 1;
+								crew_delta += 1;
 
 								SetContext (StatusContext);
 								GetGaugeRect (&r, TRUE);
@@ -887,34 +919,34 @@ DoModifyShips (PMENU_STATE pMS)
 							}
 							else
 							{	// at capacity or not enough RUs
+								if (loop) break;
 								PlayMenuSound (MENU_SOUND_FAILURE);
 							}
 						}
 						else
 						{
-							HSTARSHIP hTemplate;
-							SHIP_FRAGMENTPTR TemplatePtr;
+							HFLEETINFO hTemplate;
+							FLEET_INFO *TemplatePtr;
 
 							hTemplate = GetStarShipFromIndex (
 									&GLOBAL (avail_race_q),
-									GET_RACE_ID (StarShipPtr));
-							TemplatePtr = (SHIP_FRAGMENTPTR)LockStarShip (
+									StarShipPtr->race_id);
+							TemplatePtr = LockFleetInfo (
 									&GLOBAL (avail_race_q), hTemplate);
 							if (GLOBAL_SIS (ResUnits) >=
 									(DWORD)GLOBAL (CrewCost)
-									&& StarShipPtr->ShipInfo.crew_level <
-									StarShipPtr->ShipInfo.max_crew &&
-									StarShipPtr->ShipInfo.crew_level <
-									TemplatePtr->RaceDescPtr->ship_info.
-									crew_level)
+									&& StarShipPtr->crew_level <
+									StarShipPtr->max_crew &&
+									StarShipPtr->crew_level <
+									TemplatePtr->crew_level)
 							{
-								if (StarShipPtr->ShipInfo.crew_level > 0)
+								if (StarShipPtr->crew_level > 0)
 									DeltaSISGauges (0, 0, -GLOBAL (CrewCost));
 								else
 									DeltaSISGauges (0, 0, -(COUNT)ShipCost[
-											GET_RACE_ID (StarShipPtr) ]);
-								++StarShipPtr->ShipInfo.crew_level;
-								crew_delta = 1;
+											StarShipPtr->race_id]);
+								++StarShipPtr->crew_level;
+								crew_delta += 1;
 								ShowShipCrew (StarShipPtr, &pMS->flash_rect0);
 								r.corner.x = pMS->flash_rect0.corner.x;
 								r.corner.y = pMS->flash_rect0.corner.y
@@ -926,13 +958,19 @@ DoModifyShips (PMENU_STATE pMS)
 							}
 							else
 							{	// at capacity or not enough RUs
+								if (loop)
+								{
+									UnlockFleetInfo (&GLOBAL (avail_race_q),
+											hTemplate);
+									break;
+								}
 								PlayMenuSound (MENU_SOUND_FAILURE);
 							}
-							UnlockStarShip (&GLOBAL (avail_race_q),
+							UnlockFleetInfo (&GLOBAL (avail_race_q),
 									hTemplate);
 						}
 					}
-					else if (dy > 0)
+					else if (dy > 0 || dx < 0)
 					{
 						crew_bought = (SIZE)MAKE_WORD (
 								GET_GAME_STATE (CREW_PURCHASED0),
@@ -944,7 +982,7 @@ DoModifyShips (PMENU_STATE pMS)
 								DeltaSISGauges (-1, 0, GLOBAL (CrewCost)
 										- (crew_bought ==
 										CREW_EXPENSE_THRESHOLD ? 2 : 0));
-								crew_delta = -1;
+								crew_delta -= 1;
 
 								GetCPodCapacity (&r.corner);
 								SetContextForeGroundColor (BLACK_COLOR);
@@ -957,25 +995,39 @@ DoModifyShips (PMENU_STATE pMS)
 							}
 							else
 							{	// no crew to dismiss
+								if (loop) break;
 								PlayMenuSound (MENU_SOUND_FAILURE);
 							}
 						}
 						else
 						{
-							if (StarShipPtr->ShipInfo.crew_level > 0)
+							if (StarShipPtr->crew_level > 0)
 							{
-								if (StarShipPtr->ShipInfo.crew_level > 1)
+								if (StarShipPtr->crew_level > 1)
 									DeltaSISGauges (0, 0, GLOBAL (CrewCost)
 											- (crew_bought ==
 											CREW_EXPENSE_THRESHOLD ? 2 : 0));
 								else
 									DeltaSISGauges (0, 0, (COUNT)ShipCost[
-											GET_RACE_ID (StarShipPtr)]);
-								crew_delta = -1;
-								--StarShipPtr->ShipInfo.crew_level;
+											StarShipPtr->race_id]);
+								crew_delta -= 1;
+								--StarShipPtr->crew_level;
 							}
 							else
 							{	// no crew to dismiss
+								if (loop)
+								{
+									ShowShipCrew (StarShipPtr,
+										&pMS->flash_rect0);
+									r.corner.x = pMS->flash_rect0.corner.x;
+									r.corner.y = pMS->flash_rect0.corner.y
+										+ pMS->flash_rect0.extent.height - 6;
+									r.extent.width = SHIP_WIN_WIDTH;
+									r.extent.height = 5;
+									SetContext (SpaceContext);
+									SetFlashRect (&r, (FRAME)0);
+									break;
+								}
 								PlayMenuSound (MENU_SOUND_FAILURE);
 							}
 							ShowShipCrew (StarShipPtr, &pMS->flash_rect0);
@@ -988,10 +1040,11 @@ DoModifyShips (PMENU_STATE pMS)
 							SetFlashRect (&r, (FRAME)0);
 						}
 					}
+					}
 
 					if (hStarShip)
 					{
-						UnlockStarShip (&GLOBAL (built_ship_q), hStarShip);
+						UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 						
 						// clear out the bought ship index
 						// so that flash rects work correctly
@@ -1044,7 +1097,7 @@ ChangeFlashRect:
 }
 
 static void
-DrawBluePrint (PMENU_STATE pMS)
+DrawBluePrint (MENU_STATE *pMS)
 {
 	COUNT num_frames;
 	STAMP s;
@@ -1167,7 +1220,7 @@ DrawBluePrint (PMENU_STATE pMS)
 }
 
 static void
-BeginHangarAnim (PMENU_STATE pMS)
+BeginHangarAnim (MENU_STATE *pMS)
 {
 #ifdef WANT_HANGAR_ANIMATION
 	CONTEXT OldContext;
@@ -1187,8 +1240,9 @@ BeginHangarAnim (PMENU_STATE pMS)
 #endif
 }
 
+// Pre: GraphicsLock is NOT held (or risk a deadlock)
 static void
-EndHangarAnim (PMENU_STATE pMS)
+EndHangarAnim (MENU_STATE *pMS)
 {
 	if (pMS->flash_task)
 	{
@@ -1198,7 +1252,7 @@ EndHangarAnim (PMENU_STATE pMS)
 }
 
 BOOLEAN
-DoShipyard (PMENU_STATE pMS)
+DoShipyard (MENU_STATE *pMS)
 {
 	BOOLEAN select, cancel;
 	if (GLOBAL (CurrentActivity) & CHECK_ABORT)
@@ -1269,7 +1323,7 @@ DoShipyard (PMENU_STATE pMS)
 			BeginHangarAnim (pMS);
 			UnlockMutex (GraphicsLock);
 
-			ShowCombatShip ((COUNT)~0, (SHIP_FRAGMENTPTR)0);
+			ShowCombatShip ((COUNT)~0, (SHIP_FRAGMENT*)0);
 			LockMutex (GraphicsLock);
 			SetFlashRect (SFR_MENU_3DO, (FRAME)0);
 			UnlockMutex (GraphicsLock);
diff -ruNp src.orig/sc2code/sis.c src/sc2code/sis.c
--- src.orig/sc2code/sis.c	2017-11-08 16:49:41 -0600
+++ src/sc2code/sis.c	2017-11-08 16:50:08 -0600
@@ -141,7 +141,7 @@ SetContextClipRect (&r);
 	font_DrawText (&t);
 	UnbatchGraphics ();
 
-	SetContextClipRect (NULL_PTR);
+	SetContextClipRect (NULL);
 
 	SetContext (OldContext);
 }
@@ -228,7 +228,7 @@ DrawSISMessageEx (const UNICODE *pStr, S
 
 	if (flags & DSME_CLEARFR)
 	{
-		SetFlashRect (NULL_PTR, (FRAME)0);
+		SetFlashRect (NULL, (FRAME)0);
 	}
 
 	if (CurPos < 0 && ExPos < 0)
@@ -243,7 +243,7 @@ DrawSISMessageEx (const UNICODE *pStr, S
 		int i;
 		RECT text_r;
 		BYTE char_deltas[MAX_DESC_CHARS];
-		PBYTE pchar_deltas;
+		BYTE *pchar_deltas;
 
 		t.baseline.x = 3;
 		t.align = ALIGN_LEFT;
@@ -254,7 +254,7 @@ DrawSISMessageEx (const UNICODE *pStr, S
 			// will not fit when displayed later
 			// disallow the change
 			UnbatchGraphics ();
-			SetContextClipRect (NULL_PTR);
+			SetContextClipRect (NULL);
 			SetContext (OldContext);
 			return (FALSE);
 		}
@@ -327,7 +327,7 @@ DrawSISMessageEx (const UNICODE *pStr, S
 
 	UnbatchGraphics ();
 
-	SetContextClipRect (NULL_PTR);
+	SetContextClipRect (NULL);
 	SetContext (OldContext);
 
 	return (TRUE);
@@ -406,7 +406,7 @@ DrawStatusMessage (const UNICODE *pStr)
 	font_DrawText (&t);
 	UnbatchGraphics ();
 
-	SetContextClipRect (NULL_PTR);
+	SetContextClipRect (NULL);
 
 	SetContext (OldContext);
 }
@@ -797,7 +797,7 @@ DrawStorageBays (BOOLEAN Refresh)
 }
 
 void
-GetGaugeRect (PRECT pRect, BOOLEAN IsCrewRect)
+GetGaugeRect (RECT *pRect, BOOLEAN IsCrewRect)
 {
 	pRect->extent.width = 24;
 	pRect->corner.x = (STATUS_WIDTH >> 1) - (pRect->extent.width >> 1);
@@ -932,8 +932,8 @@ DeltaSISGauges (SIZE crew_delta, SIZE fu
 		}
 
 		{
-			HSTARSHIP hStarShip, hNextShip;
-			PPOINT pship_pos;
+			HSHIPFRAG hStarShip, hNextShip;
+			POINT *pship_pos;
 			POINT ship_pos[MAX_COMBAT_SHIPS] =
 			{
 				SUPPORT_SHIP_PTS
@@ -944,25 +944,19 @@ DeltaSISGauges (SIZE crew_delta, SIZE fu
 					pship_pos = ship_pos;
 					hStarShip; hStarShip = hNextShip, ++pship_pos)
 			{
-				SHIP_FRAGMENTPTR StarShipPtr;
+				SHIP_FRAGMENT *StarShipPtr;
 
-				StarShipPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-						&GLOBAL (built_ship_q),
-						hStarShip
-						);
+				StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 				hNextShip = _GetSuccLink (StarShipPtr);
 
 				s.origin.x = pship_pos->x;
 				s.origin.y = pship_pos->y;
-				s.frame = StarShipPtr->ShipInfo.icons;
+				s.frame = StarShipPtr->icons;
 				LockMutex (GraphicsLock);
 				DrawStamp (&s);
 				UnlockMutex (GraphicsLock);
 
-				UnlockStarShip (
-						&GLOBAL (built_ship_q),
-						hStarShip
-						);
+				UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 			}
 			LockMutex (GraphicsLock);
 		}
@@ -983,7 +977,7 @@ DeltaSISGauges (SIZE crew_delta, SIZE fu
 					&& GLOBAL_SIS (CrewEnlisted) <= (COUNT)-crew_delta)
 				GLOBAL_SIS (CrewEnlisted) = 0;
 			else if ((GLOBAL_SIS (CrewEnlisted) += crew_delta) >
-					(CrewCapacity = GetCPodCapacity (NULL_PTR)))
+					(CrewCapacity = GetCPodCapacity (NULL)))
 				GLOBAL_SIS (CrewEnlisted) = CrewCapacity;
 		}
 
@@ -1015,7 +1009,7 @@ DeltaSISGauges (SIZE crew_delta, SIZE fu
 					&& GLOBAL_SIS (FuelOnBoard) <= (DWORD)-fuel_delta)
 				GLOBAL_SIS (FuelOnBoard) = 0;
 			else if ((GLOBAL_SIS (FuelOnBoard) += fuel_delta) >
-					(FuelCapacity = GetFTankCapacity (NULL_PTR)))
+					(FuelCapacity = GetFTankCapacity (NULL)))
 				GLOBAL_SIS (FuelOnBoard) = FuelCapacity;
 		}
 
@@ -1075,7 +1069,7 @@ DeltaSISGauges (SIZE crew_delta, SIZE fu
 					|| pMenuState->InputFunc == DoShipyard)))
 				DrawStatusMessage ((UNICODE *)~0);
 			else
-				DrawStatusMessage (NULL_PTR);
+				DrawStatusMessage (NULL);
 		}
 	}
 	UnbatchGraphics ();
@@ -1090,7 +1084,7 @@ GetCrewCount (void)
 }
 
 COUNT
-GetCPodCapacity (PPOINT ppt)
+GetCPodCapacity (POINT *ppt)
 {
 	COORD x;
 	COUNT slot, capacity;
@@ -1146,7 +1140,7 @@ GetCPodCapacity (PPOINT ppt)
 }
 
 COUNT
-GetSBayCapacity (PPOINT ppt)
+GetSBayCapacity (POINT *ppt)
 {
 	COORD x;
 	COUNT slot, capacity;
@@ -1198,7 +1192,7 @@ GetSBayCapacity (PPOINT ppt)
 }
 
 DWORD
-GetFTankCapacity (PPOINT ppt)
+GetFTankCapacity (POINT *ppt)
 {
 	COORD x;
 	COUNT slot;
@@ -1302,8 +1296,8 @@ static int flash_changed;
 Mutex flash_mutex = 0;
 // XXX: these are currently defined in libs/graphics/sdl/3do_getbody.c
 //  they should be sorted out and cleaned up at some point
-extern void arith_frame_blit (FRAME srcFrame, RECT *rsrc, FRAME dstFrame,
-		RECT *rdst, int num, int denom);
+extern void arith_frame_blit (FRAME srcFrame, const RECT *rsrc,
+		FRAME dstFrame, const RECT *rdst, int num, int denom);
 
 static int
 flash_rect_func (void *data)
@@ -1349,7 +1343,8 @@ flash_rect_func (void *data)
 			GetFrameRect (flash_screen_frame, &screen_rect);
 			cached_screen_frame = CaptureDrawable (CreateDrawable (WANT_PIXMAP, 
 					screen_rect.extent.width, screen_rect.extent.height, 1));
-			screen_rect.corner.x = screen_rect.corner.y = 0;
+			screen_rect.corner.x = 0;
+			screen_rect.corner.y = 0;
 			arith_frame_blit (flash_screen_frame, &screen_rect, 
 					cached_screen_frame, NULL, 0, 0);
 			UnlockMutex (flash_mutex);
@@ -1406,11 +1401,13 @@ flash_rect_func (void *data)
 
 						if (fstrength < 0)
 						{
+							// Subtractive blit.
 							num = -8;
 							denom = 8;
 						}
 						else
 						{
+							// Additive blit.
 							num = 8;
 							denom = -8;
 						}
@@ -1453,7 +1450,7 @@ flash_rect_func (void *data)
 			// flash changed_can't be modified while GraphicSem is held
 			if (! flash_changed)
 				DrawStamp (pStamp);
-			SetContextClipRect (NULL_PTR); // this will flush whatever
+			SetContextClipRect (NULL); // this will flush whatever
 			SetContext (OldContext);
 			UnlockMutex (GraphicsLock);
 		}
@@ -1480,7 +1477,7 @@ flash_rect_func (void *data)
 }
 
 void
-SetFlashRect (PRECT pRect, FRAME f)
+SetFlashRect (RECT *pRect, FRAME f)
 {
 	RECT clip_r, temp_r, flash_rect1, old_r;
 	CONTEXT OldContext;
@@ -1565,9 +1562,11 @@ SetFlashRect (PRECT pRect, FRAME f)
 	
 	if (flash_rect.extent.width)
 	{
+		// Copy the original contents of the rectangle from the screen.
 		if (flash_screen_frame)
 			DestroyDrawable (ReleaseDrawable (flash_screen_frame));
-		flash_screen_frame = CaptureDrawable (LoadDisplayPixmap (&flash_rect, (FRAME)0));
+		flash_screen_frame =
+				CaptureDrawable (LoadDisplayPixmap (&flash_rect, (FRAME)0));
 	}
 	flash_changed = 1;
 	UnlockMutex (flash_mutex);
@@ -1598,13 +1597,13 @@ SaveFlagshipState (void)
 		for (hElement = GetHeadElement ();
 				hElement != 0; hElement = hNextElement)
 		{
-			ELEMENTPTR ElementPtr;
+			ELEMENT *ElementPtr;
 
 			LockElement (hElement, &ElementPtr);
 			hNextElement = GetSuccElement (ElementPtr);
 			if (ElementPtr->state_flags & PLAYER_SHIP)
 			{
-				STARSHIPPTR StarShipPtr;
+				STARSHIP *StarShipPtr;
 
 				GetElementStarShip (ElementPtr, &StarShipPtr);
 				GLOBAL (ShipStamp.frame) = (FRAME)MAKE_DWORD (
diff -ruNp src.orig/sc2code/sis.h src/sc2code/sis.h
--- src.orig/sc2code/sis.h	2017-11-08 16:49:41 -0600
+++ src/sc2code/sis.h	2017-11-08 16:50:08 -0600
@@ -109,7 +109,10 @@ enum
 #define FUEL_RESERVE FUEL_VOLUME_PER_ROW
 
 #define MAX_COMBAT_SHIPS 12
-#define MAX_BATTLE_GROUPS 64
+#define MAX_BATTLE_GROUPS 32
+
+// XXX: Needed to maintain savegame compatibility
+#define NUM_SAVED_BATTLE_GROUPS 64
 
 #define IP_SHIP_THRUST_INCREMENT 8
 #define IP_SHIP_TURN_WAIT 17
@@ -148,7 +151,7 @@ enum
 	BOMB_MODULE_4,
 	BOMB_MODULE_5,
 
-	NUM_MODULES = 20 /* must be last entry */
+	NUM_MODULES /* must be last entry */
 };
 
 #define EMPTY_SLOT NUM_MODULES
@@ -222,7 +225,6 @@ typedef struct
 	UNICODE CommanderName[SIS_NAME_SIZE];
 	UNICODE PlanetName[SIS_NAME_SIZE];
 } SIS_STATE;
-typedef SIS_STATE *PSIS_STATE;
 
 #define MAX_EXCLUSIVE_DEVICES 16
 
@@ -248,14 +250,14 @@ extern void UninitSIS (void);
 extern void SeedUniverse (void);
 extern BOOLEAN LoadHyperspace (void);
 extern BOOLEAN FreeHyperspace (void);
-extern void MoveSIS (PSIZE pdx, PSIZE pdy);
+extern void MoveSIS (SIZE *pdx, SIZE *pdy);
 extern void RepairSISBorder (void);
 extern void InitSISContexts (void);
 extern void DrawSISFrame (void);
 extern void ClearSISRect (BYTE ClearFlags);
-extern void SetFlashRect (PRECT pRect, FRAME f);
-#define SFR_MENU_3DO ((PRECT)~0L)
-#define SFR_MENU_ANY ((PRECT)~1L)
+extern void SetFlashRect (RECT *pRect, FRAME f);
+#define SFR_MENU_3DO ((RECT*)~0L)
+#define SFR_MENU_ANY ((RECT*)~1L)
 extern void DrawHyperCoords (POINT puniverse);
 extern void DrawSISTitle (UNICODE *pStr);
 extern BOOLEAN DrawSISMessageEx (const UNICODE *pStr, SIZE CurPos,
@@ -271,20 +273,20 @@ extern void DateToString (unsigned char
 extern void DrawStatusMessage (const UNICODE *pStr);
 extern void DrawLanders (void);
 extern void DrawStorageBays (BOOLEAN Refresh);
-extern void GetGaugeRect (PRECT pRect, BOOLEAN IsCrewRect);
+extern void GetGaugeRect (RECT *pRect, BOOLEAN IsCrewRect);
 extern void DrawFlagshipStats (void);
 extern void SaveFlagshipState (void);
 
 extern void DeltaSISGauges (SIZE crew_delta, SIZE fuel_delta, int
 		resunit_delta);
 extern COUNT GetCrewCount (void);
-extern COUNT GetCPodCapacity (PPOINT ppt);
-extern COUNT GetLBayCapacity (PPOINT ppt);
-extern COUNT GetSBayCapacity (PPOINT ppt);
-extern DWORD GetFTankCapacity (PPOINT ppt);
+extern COUNT GetCPodCapacity (POINT *ppt);
+extern COUNT GetLBayCapacity (POINT *ppt);
+extern COUNT GetSBayCapacity (POINT *ppt);
+extern DWORD GetFTankCapacity (POINT *ppt);
 extern COUNT CountSISPieces (BYTE piece_type);
 
-extern BOOLEAN DoMenuChooser (PMENU_STATE pMS, BYTE BaseState);
+extern BOOLEAN DoMenuChooser (MENU_STATE *pMS, BYTE BaseState);
 extern void DrawMenuStateStrings (BYTE beg_index, SWORD NewState);
 extern void DoMenuOptions (void);
 extern void DrawFlagshipName (BOOLEAN InStatusArea);
diff -ruNp src.orig/sc2code/sounds.c src/sc2code/sounds.c
--- src.orig/sc2code/sounds.c	2017-11-08 16:49:41 -0600
+++ src/sc2code/sounds.c	2017-11-08 16:50:08 -0600
@@ -25,10 +25,10 @@ SOUND GameSounds;
 #define MAX_SOUNDS 8
 static BYTE num_sounds = 0;
 static SOUND sound_buf[MAX_SOUNDS];
-static ELEMENTPTR sound_posobj[MAX_SOUNDS];
+static ELEMENT *sound_posobj[MAX_SOUNDS];
 
 void
-PlaySound (SOUND S, SoundPosition Pos, ELEMENTPTR PositionalObject,
+PlaySound (SOUND S, SoundPosition Pos, ELEMENT *PositionalObject,
 		BYTE Priority)
 {
 	BYTE chan, c;
@@ -62,7 +62,7 @@ PlaySound (SOUND S, SoundPosition Pos, E
 	{
 		if (lru_channel[c] == chan)
 		{
-			memmove ((PBYTE)&lru_channel[c], (PBYTE)&lru_channel[c + 1],
+			memmove (&lru_channel[c], &lru_channel[c + 1],
 					(NUM_FX_CHANNELS - 1) - c);
 			break;
 		}
@@ -81,7 +81,7 @@ PlayMenuSound (MENU_SOUND_EFFECT S)
 }
 
 void
-ProcessSound (SOUND Sound, ELEMENTPTR PositionalObject)
+ProcessSound (SOUND Sound, ELEMENT *PositionalObject)
 {
 	if (Sound == (SOUND)~0)
 	{
@@ -97,7 +97,7 @@ ProcessSound (SOUND Sound, ELEMENTPTR Po
 }
 
 SoundPosition
-CalcSoundPosition (ELEMENTPTR ElementPtr)
+CalcSoundPosition (ELEMENT *ElementPtr)
 {
 	SoundPosition pos;
 
@@ -144,7 +144,7 @@ UpdateSoundPositions (void)
 
 	for (i = FIRST_SFX_CHANNEL; i <= LAST_SFX_CHANNEL; ++i)
 	{
-		ELEMENTPTR posobj;
+		ELEMENT *posobj;
 		if (!ChannelPlaying(i))
 			continue;
 
@@ -165,7 +165,7 @@ FlushSounds (void)
 	if (num_sounds > 0)
 	{
 		SOUND *pSound;
-		ELEMENTPTR *pSoundPosObj;
+		ELEMENT **pSoundPosObj;
 
 		pSound = sound_buf;
 		pSoundPosObj = sound_posobj;
@@ -179,7 +179,7 @@ FlushSounds (void)
 }
 
 void
-RemoveSoundsForObject (ELEMENTPTR PosObj)
+RemoveSoundsForObject (ELEMENT *PosObj)
 {
 	int i;
 
diff -ruNp src.orig/sc2code/sounds.h src/sc2code/sounds.h
--- src.orig/sc2code/sounds.h	2017-11-08 16:49:41 -0600
+++ src/sc2code/sounds.h	2017-11-08 16:50:08 -0600
@@ -65,14 +65,14 @@ extern void GetMenuSounds (MENU_SOUND_FL
 		MENU_SOUND_FLAGS *sound_1);
 
 extern void PlaySound (SOUND S, SoundPosition Pos,
-		ELEMENTPTR PositionalObject, BYTE Priority);
+		ELEMENT *PositionalObject, BYTE Priority);
 extern void PlayMenuSound (MENU_SOUND_EFFECT S);
-extern void ProcessSound (SOUND Sound, ELEMENTPTR PositionalObject);
-extern SoundPosition CalcSoundPosition (ELEMENTPTR ElementPtr);
+extern void ProcessSound (SOUND Sound, ELEMENT *PositionalObject);
+extern SoundPosition CalcSoundPosition (ELEMENT *ElementPtr);
 extern SoundPosition NotPositional (void);
 extern void UpdateSoundPositions (void);
 extern void FlushSounds (void);
-extern void RemoveSoundsForObject (ELEMENTPTR PosObj);
+extern void RemoveSoundsForObject (ELEMENT *PosObj);
 
 #endif /* _SOUNDS_H */
 
diff -ruNp src.orig/sc2code/starbase.c src/sc2code/starbase.c
--- src.orig/sc2code/starbase.c	2017-11-08 16:49:41 -0600
+++ src/sc2code/starbase.c	2017-11-08 16:50:08 -0600
@@ -33,7 +33,7 @@
 #include "libs/inplib.h"
 
 
-PMENU_STATE pMenuState;
+MENU_STATE *pMenuState;
 
 static void
 DrawBaseStateStrings (STARBASE_STATE OldState, STARBASE_STATE NewState)
@@ -77,7 +77,7 @@ DrawBaseStateStrings (STARBASE_STATE Old
 }
 
 void
-DrawShipPiece (PMENU_STATE pMS, COUNT which_piece, COUNT which_slot,
+DrawShipPiece (MENU_STATE *pMS, COUNT which_piece, COUNT which_slot,
 		BOOLEAN DrawBluePrint)
 {
 	COLOR OldColor = 0;  // Initialisation is to keep the compiler silent.
@@ -287,7 +287,7 @@ rotate_starbase(void *data)
 }
 
 BOOLEAN
-DoStarBase (PMENU_STATE pMS)
+DoStarBase (MENU_STATE *pMS)
 {
 	if (GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD))
 	{
@@ -304,7 +304,7 @@ DoStarBase (PMENU_STATE pMS)
 		pMS->InputFunc = DoStarBase;
 
 		LockMutex (GraphicsLock);
-		SetFlashRect (NULL_PTR, (FRAME)0);
+		SetFlashRect (NULL, (FRAME)0);
 
 		if (pMS->hMusic)
 		{
@@ -403,7 +403,7 @@ ExitStarBase:
 			}
 
 			SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
-			DoInput ((PVOID)pMS, TRUE);
+			DoInput (pMS, TRUE);
 
 			pMS->Initialized = FALSE;
 			pMS->CurState = OldState;
@@ -471,8 +471,8 @@ VisitStarBase (void)
 	}
 	else if (!GET_GAME_STATE (STARBASE_AVAILABLE))
 	{
-		HSTARSHIP hStarShip;
-		SHIP_FRAGMENTPTR FragPtr;
+		HSHIPFRAG hStarShip;
+		SHIP_FRAGMENT *FragPtr;
 
 		pMenuState = 0;
 
@@ -481,17 +481,15 @@ VisitStarBase (void)
 				|| (GLOBAL (CurrentActivity) & CHECK_ABORT))
 			goto ExitStarBase;
 
-		hStarShip = CloneShipFragment (
-				ILWRATH_SHIP,
-				&GLOBAL (npc_built_ship_q), 7
-				);
-		FragPtr = (SHIP_FRAGMENTPTR)LockStarShip (
-				&GLOBAL (npc_built_ship_q), hStarShip
-				);
-		SET_RACE_ID (FragPtr, (BYTE)~0);
-		UnlockStarShip (
-				&GLOBAL (npc_built_ship_q), hStarShip
-				);
+		/* Create an Ilwrath ship responding to the Ur-Quan
+		 * probe's broadcast */
+		hStarShip = CloneShipFragment (ILWRATH_SHIP,
+				&GLOBAL (npc_built_ship_q), 7);
+		FragPtr = LockShipFrag (&GLOBAL (npc_built_ship_q), hStarShip);
+		/* Hack (sort of): Suppress the tally and salvage info
+		 * after the battle */
+		FragPtr->race_id = (BYTE)~0;
+		UnlockShipFrag (&GLOBAL (npc_built_ship_q), hStarShip);
 
 		InitCommunication (ILWRATH_CONVERSATION);
 		if (GLOBAL_SIS (CrewEnlisted) == (COUNT)~0
@@ -513,7 +511,7 @@ TimePassage:
 
 	pMenuState = &MenuState;
 
-	memset ((PMENU_STATE)&MenuState, 0, sizeof (MenuState));
+	memset (&MenuState, 0, sizeof (MenuState));
 
 	MenuState.InputFunc = DoStarBase;
 	if (GET_GAME_STATE (MOONBASE_ON_SHIP)
@@ -524,7 +522,7 @@ TimePassage:
 	}
 
 	OldContext = SetContext (ScreenContext);
-	DoInput ((PVOID)pMenuState, TRUE);
+	DoInput (pMenuState, TRUE);
 	SetContext (OldContext);
 
 	pMenuState = 0;
@@ -585,7 +583,7 @@ WrapText (const UNICODE *pStr, COUNT len
 			while (*++pStr != ' ' && (COUNT)(pStr - tarray->pStr) < len)
 				;
 			tarray->CharCount = pStr - tarray->pStr;
-			TextRect (tarray, &r, NULL_PTR);
+			TextRect (tarray, &r, NULL);
 		} while (tarray->CharCount < len && r.extent.width < field_width);
 	
 		if (r.extent.width >= field_width)
@@ -595,7 +593,7 @@ WrapText (const UNICODE *pStr, COUNT len
 				do
 				{
 					++tarray->CharCount;
-					TextRect (tarray, &r, NULL_PTR);
+					TextRect (tarray, &r, NULL);
 				} while (r.extent.width < field_width);
 				--tarray->CharCount;
 			}
diff -ruNp src.orig/sc2code/starbase.h src/sc2code/starbase.h
--- src.orig/sc2code/starbase.h	2017-11-08 16:49:41 -0600
+++ src/sc2code/starbase.h	2017-11-08 16:50:08 -0600
@@ -33,10 +33,10 @@ typedef BYTE STARBASE_STATE;
 
 extern void InstallBombAtEarth (void);
 extern void VisitStarBase (void);
-extern BOOLEAN DoStarBase (PMENU_STATE pMS);
-extern BOOLEAN DoOutfit (PMENU_STATE pMS);
-extern BOOLEAN DoShipyard (PMENU_STATE pMS);
-extern void DrawShipPiece (PMENU_STATE pMS, COUNT which_piece, COUNT
+extern BOOLEAN DoStarBase (MENU_STATE *pMS);
+extern BOOLEAN DoOutfit (MENU_STATE *pMS);
+extern BOOLEAN DoShipyard (MENU_STATE *pMS);
+extern void DrawShipPiece (MENU_STATE *pMS, COUNT which_piece, COUNT
 		which_slot, BOOLEAN DrawBluePrint);
 
 extern COUNT WrapText (const UNICODE *pStr, COUNT len, TEXT *tarray, SIZE
diff -ruNp src.orig/sc2code/starcon.c src/sc2code/starcon.c
--- src.orig/sc2code/starcon.c	2017-11-08 16:49:41 -0600
+++ src/sc2code/starcon.c	2017-11-08 16:50:08 -0600
@@ -78,13 +78,13 @@ arilou_gate_task(void *data)
 	}
 	FinishTask (task);
 
-	return(0);
+	return 0;
 }
 
 static void
 BackgroundInitKernel (DWORD TimeOut)
 {
-	LoadMasterShipList ();
+	LoadMasterShipList (TaskSwitch);
 	TaskSwitch ();
 	InitGameKernel ();
 
@@ -96,15 +96,13 @@ BackgroundInitKernel (DWORD TimeOut)
 	}
 }
 
-#define DEBUG_PSYTRON 0
-
 /* TODO: Remove these declarations once threading is gone. */
 extern int snddriver, soundflags;
 
 int
 Starcon2Main (void *threadArg)
 {
-#if DEBUG_PSYTRON || CREATE_JOURNAL
+#if CREATE_JOURNAL
 {
 int ac = argc;
 char **av = argv;
@@ -116,15 +114,6 @@ while (--ac > 0)
 	{
 		switch ((*av)[1])
 		{
-#ifdef DEBUG_PSYTRON
-			case 'd':
-			{
-				extern BYTE debug_psytron;
-
-				debug_psytron = atoi (&(*av)[2]);
-				break;
-			}
-#endif //DEBUG_PSYTRON
 #if CREATE_JOURNAL
 			case 'j':
 				++create_journal;
@@ -134,7 +123,7 @@ while (--ac > 0)
 	}
 }
 }
-#endif //DEBUG_PSYTRON || CREATE_JOURNAL
+#endif // CREATE_JOURNAL
 
 	/* TODO: Put initAudio back in main where it belongs once threading
 	 *       is gone.
@@ -142,148 +131,131 @@ while (--ac > 0)
 	extern sint32 initAudio (sint32 driver, sint32 flags);
 	initAudio (snddriver, soundflags);
 
-	if (LoadKernel (0,0))
+	if (!LoadKernel (0,0))
 	{
-		log_add (log_Info, "We've loaded the Kernel");
+		log_add (log_Fatal, "\n  *** FATAL ERROR: Could not load basic content ***\n\nUQM requires at least the base content pack to run properly.");
+		log_add (log_Fatal, "This file is typically called uqm-%d.%d.0.uqm.  UQM was expecting it", UQM_MAJOR_VERSION, UQM_MINOR_VERSION);
+		log_add (log_Fatal, "in the %s/packages directory.", baseContentPath);
+		log_add (log_Fatal, "Either your installation did not install the content pack at all, or it\ninstalled it in a different directory.\n\nFix your installation and rerun UQM.\n\n  *******************\n");
+		exit (EXIT_FAILURE);
+	}
+	log_add (log_Info, "We've loaded the Kernel");
+
+	Logo ();
 	
-		Logo ();
-		
-		GLOBAL (CurrentActivity) = 0;
-		// show splash and init the kernel in the meantime
-		SplashScreen (BackgroundInitKernel);
+	GLOBAL (CurrentActivity) = 0;
+	// show splash and init the kernel in the meantime
+	SplashScreen (BackgroundInitKernel);
 
-// OpenJournal ();
-		while (StartGame ())
-		{
-			InitSIS ();
-			InitGameClock ();
+//	OpenJournal ();
+	while (StartGame ())
+	{
+		// Initialise a new game
+		SetPlayerInputAll ();
+		InitSIS ();
+		InitGameClock ();
+		AddInitialGameEvents();
 
-			AddInitialGameEvents();
-			do
-			{
-				SuspendGameClock ();
+		do
+		{
+			SuspendGameClock ();
 
 #ifdef DEBUG
-				if (debugHook != NULL)
-				{
-					void (*saveDebugHook) (void);
-					saveDebugHook = debugHook;
-					debugHook = NULL;
-							// No further debugHook calls unless the called
-							// function resets debugHook.
-					(*saveDebugHook) ();
-					continue;
-				}
+			if (debugHook != NULL)
+			{
+				void (*saveDebugHook) (void);
+				saveDebugHook = debugHook;
+				debugHook = NULL;
+						// No further debugHook calls unless the called
+						// function resets debugHook.
+				(*saveDebugHook) ();
+				continue;
+			}
 #endif
-				
-				if (!((GLOBAL (CurrentActivity) | NextActivity) & CHECK_LOAD))
-					ZeroVelocityComponents (
-							&GLOBAL (velocity)
-							);
-						//not going into talking pet conversation
-				else if (GLOBAL (CurrentActivity) & CHECK_LOAD)
-					GLOBAL (CurrentActivity) = NextActivity;
+			
+			if (!((GLOBAL (CurrentActivity) | NextActivity) & CHECK_LOAD))
+				ZeroVelocityComponents (&GLOBAL (velocity));
+					// not going into talking pet conversation
+			else if (GLOBAL (CurrentActivity) & CHECK_LOAD)
+				GLOBAL (CurrentActivity) = NextActivity;
 
-				if ((GLOBAL (CurrentActivity) & START_ENCOUNTER)
-						|| GET_GAME_STATE (CHMMR_BOMB_STATE) == 2)
-				{
-					if (GET_GAME_STATE (CHMMR_BOMB_STATE) == 2
-							&& !GET_GAME_STATE (STARBASE_AVAILABLE))
-					{	/* BGD mode */
-						InstallBombAtEarth ();
-					}
-					else if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) == (BYTE)~0
-							|| GET_GAME_STATE (CHMMR_BOMB_STATE) == 2)
-					{
-						GLOBAL (CurrentActivity) |= START_ENCOUNTER;
-						VisitStarBase ();
-					}
-					else
-					{
-						GLOBAL (CurrentActivity) |= START_ENCOUNTER;
-						RaceCommunication ();
-					}
-
-					if (!(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD)))
-					{
-						GLOBAL (CurrentActivity) &= ~START_ENCOUNTER;
-						if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY)
-							GLOBAL (CurrentActivity) |= START_INTERPLANETARY;
-					}
+			if ((GLOBAL (CurrentActivity) & START_ENCOUNTER)
+					|| GET_GAME_STATE (CHMMR_BOMB_STATE) == 2)
+			{
+				if (GET_GAME_STATE (CHMMR_BOMB_STATE) == 2
+						&& !GET_GAME_STATE (STARBASE_AVAILABLE))
+				{	/* BGD mode */
+					InstallBombAtEarth ();
 				}
-				else if (GLOBAL (CurrentActivity) & START_INTERPLANETARY)
+				else if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) == (BYTE)~0
+						|| GET_GAME_STATE (CHMMR_BOMB_STATE) == 2)
 				{
-					GLOBAL (CurrentActivity) = MAKE_WORD (IN_INTERPLANETARY, 0);
-
-					ExploreSolarSys ();
-#ifdef TESTING
-					if (!(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD))
-							&& GLOBAL_SIS (CrewEnlisted) != (COUNT)~0)
-					{
-						if (!(GLOBAL (CurrentActivity) & START_ENCOUNTER)
-								&& (CurStarDescPtr = FindStar (NULL_PTR,
-								&GLOBAL (autopilot), 0, 0)))
-						{
-							GLOBAL (autopilot.x) = ~0;
-							GLOBAL (autopilot.y) = ~0;
-							GLOBAL (ShipStamp.frame) = 0;
-							GLOBAL (CurrentActivity) |= START_INTERPLANETARY;
-						}
-					}
-#endif //TESTING
+					GLOBAL (CurrentActivity) |= START_ENCOUNTER;
+					VisitStarBase ();
 				}
 				else
 				{
-					Task ArilouTask;
-					
-					GLOBAL (CurrentActivity) = MAKE_WORD (IN_HYPERSPACE, 0);
-
-					ArilouTask = AssignTask (arilou_gate_task, 128,
-							"quasispace portal manager");
-
-					TaskSwitch ();
-
-					Battle ();
-					if (ArilouTask)
-						Task_SetState (ArilouTask, TASK_EXIT);
+					GLOBAL (CurrentActivity) |= START_ENCOUNTER;
+					RaceCommunication ();
 				}
 
-				LockMutex (GraphicsLock);
-				SetFlashRect (NULL_PTR, (FRAME)0);
-				UnlockMutex (GraphicsLock);
-
-				LastActivity = GLOBAL (CurrentActivity);
-
-				if (!(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD))
-						&& (LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE
-								//if died for some reason
-						|| GLOBAL_SIS (CrewEnlisted) == (COUNT)~0))
+				if (!(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD)))
 				{
-					if (GET_GAME_STATE (KOHR_AH_KILLED_ALL))
-						InitCommunication (BLACKURQ_CONVERSATION);
-							//surrendered to Ur-Quan
-					else if (GLOBAL (CurrentActivity) & CHECK_RESTART)
-						GLOBAL (CurrentActivity) &= ~CHECK_RESTART;
-					break;
+					GLOBAL (CurrentActivity) &= ~START_ENCOUNTER;
+					if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY)
+						GLOBAL (CurrentActivity) |= START_INTERPLANETARY;
 				}
-			} while (!(GLOBAL (CurrentActivity) & CHECK_ABORT));
+			}
+			else if (GLOBAL (CurrentActivity) & START_INTERPLANETARY)
+			{
+				GLOBAL (CurrentActivity) = MAKE_WORD (IN_INTERPLANETARY, 0);
+				ExploreSolarSys ();
+			}
+			else
+			{
+				// Entering HyperSpace or QuasiSpace.
+				Task ArilouTask;
+				
+				GLOBAL (CurrentActivity) = MAKE_WORD (IN_HYPERSPACE, 0);
 
-			StopSound ();
-			UninitGameClock ();
-			UninitSIS ();
-		}
-//		CloseJournal ();
+				ArilouTask = AssignTask (arilou_gate_task, 128,
+						"quasispace portal manager");
 
-		FreeGameData ();
-	}
-	else
-	{
-		log_add (log_Fatal, "\n  *** FATAL ERROR: Could not load basic content ***\n\nUQM requires at least the base content pack to run properly.");
-		log_add (log_Fatal, "This file is typically called uqm-%d.%d.0.uqm.  UQM was expecting it", UQM_MAJOR_VERSION, UQM_MINOR_VERSION);
-		log_add (log_Fatal, "in the %s/packages directory.", baseContentPath);
-		log_add (log_Fatal, "Either your installation did not install the content pack at all, or it\ninstalled it in a different directory.\n\nFix your installation and rerun UQM.\n\n  *******************\n");
-		exit (EXIT_FAILURE);
+				TaskSwitch ();
+
+				Battle ();
+				if (ArilouTask)
+					Task_SetState (ArilouTask, TASK_EXIT);
+			}
+
+			LockMutex (GraphicsLock);
+			SetFlashRect (NULL, (FRAME)0);
+			UnlockMutex (GraphicsLock);
+
+			LastActivity = GLOBAL (CurrentActivity);
+
+			if (!(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD))
+					&& (LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE
+							// if died for some reason
+					|| GLOBAL_SIS (CrewEnlisted) == (COUNT)~0))
+			{
+				if (GET_GAME_STATE (KOHR_AH_KILLED_ALL))
+					InitCommunication (BLACKURQ_CONVERSATION);
+						// surrendered to Ur-Quan
+				else if (GLOBAL (CurrentActivity) & CHECK_RESTART)
+					GLOBAL (CurrentActivity) &= ~CHECK_RESTART;
+				break;
+			}
+		} while (!(GLOBAL (CurrentActivity) & CHECK_ABORT));
+
+		StopSound ();
+		UninitGameClock ();
+		UninitSIS ();
+		ClearPlayerInputAll ();
 	}
+//	CloseJournal ();
+
+	FreeGameData ();
 	FreeKernel ();
 
 	// XXX: the abort can now be changed to something cleaner;
@@ -293,3 +265,4 @@ while (--ac > 0)
 	(void) threadArg;  /* Satisfying compiler (unused parameter) */
 	return 0;
 }
+
diff -ruNp src.orig/sc2code/starmap.c src/sc2code/starmap.c
--- src.orig/sc2code/starmap.c	2017-11-08 16:49:41 -0600
+++ src/sc2code/starmap.c	2017-11-08 16:50:08 -0600
@@ -23,16 +23,16 @@
 #include "libs/gfxlib.h"
 
 
-STAR_DESCPTR star_array;
-STAR_DESCPTR CurStarDescPtr = 0;
+STAR_DESC *star_array;
+STAR_DESC *CurStarDescPtr = 0;
 
-STAR_DESCPTR
-FindStar (STAR_DESCPTR LastSDPtr, PPOINT puniverse, SIZE xbounds, SIZE
-		ybounds)
+STAR_DESC*
+FindStar (STAR_DESC *LastSDPtr, POINT *puniverse, SIZE xbounds,
+		SIZE ybounds)
 {
 	COORD min_y, max_y;
 	SIZE lo, hi;
-	STAR_DESCPTR BaseSDPtr;
+	STAR_DESC *BaseSDPtr;
 
 	if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
 	{
@@ -46,12 +46,12 @@ FindStar (STAR_DESCPTR LastSDPtr, PPOINT
 		hi = (NUM_HYPER_VORTICES + 1) - 1;
 	}
 
-	if (LastSDPtr == NULL_PTR)
+	if (LastSDPtr == NULL)
 		lo = 0;
 	else if ((lo = LastSDPtr - BaseSDPtr + 1) > hi)
 		return (0);
 	else
-			hi = lo;
+		hi = lo;
 
 	if (ybounds <= 0)
 		min_y = max_y = puniverse->y;
@@ -100,7 +100,7 @@ FindStar (STAR_DESCPTR LastSDPtr, PPOINT
 }
 
 void
-GetClusterName (STAR_DESCPTR pSD, UNICODE buf[])
+GetClusterName (const STAR_DESC *pSD, UNICODE buf[])
 {
 	UNICODE *pBuf, *pStr;
 
diff -ruNp src.orig/sc2code/state.c src/sc2code/state.c
--- src.orig/sc2code/state.c	2017-11-08 16:49:41 -0600
+++ src/sc2code/state.c	2017-11-08 16:50:08 -0600
@@ -132,7 +132,7 @@ LengthStateFile (GAME_STATE_FILE *fp)
 }
 
 int
-ReadStateFile (PVOID lpBuf, COUNT size, COUNT count, GAME_STATE_FILE *fp)
+ReadStateFile (void *lpBuf, COUNT size, COUNT count, GAME_STATE_FILE *fp)
 {
 	DWORD bytes = size * count;
 
@@ -155,7 +155,7 @@ ReadStateFile (PVOID lpBuf, COUNT size,
 }
 
 int
-WriteStateFile (PVOID lpBuf, COUNT size, COUNT count, GAME_STATE_FILE *fp)
+WriteStateFile (const void *lpBuf, COUNT size, COUNT count, GAME_STATE_FILE *fp)
 {
 	DWORD bytes = size * count;
 	
@@ -211,7 +211,7 @@ InitPlanetInfo (void)
 	fp = OpenStateFile (STARINFO_FILE, "wb");
 	if (fp)
 	{
-		STAR_DESCPTR pSD;
+		STAR_DESC *pSD;
 
 		// Set record offsets for all stars to 0 (not present)
 		pSD = &star_array[0];
@@ -238,7 +238,7 @@ UninitPlanetInfo (void)
 void
 GetPlanetInfo (void)
 {
-	PVOID fp;
+	void *fp;
 
 	pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[BIOLOGICAL_SCAN] = 0;
 	pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[MINERAL_SCAN] = 0;
@@ -286,7 +286,7 @@ GetPlanetInfo (void)
 void
 PutPlanetInfo (void)
 {
-	PVOID fp;
+	void *fp;
 
 	fp = OpenStateFile (STARINFO_FILE, "r+b");
 	if (fp)
diff -ruNp src.orig/sc2code/state.h src/sc2code/state.h
--- src.orig/sc2code/state.h	2017-11-08 16:49:41 -0600
+++ src/sc2code/state.h	2017-11-08 16:50:08 -0600
@@ -36,8 +36,14 @@ extern DWORD PutGroupInfo (DWORD offset,
 #define GROUPS_ADD_NEW ((DWORD)(~0L))
 #define GROUP_LIST     ((BYTE)0)
 #define GROUP_INIT_IP  ((BYTE)~0)
+		// Initialize IP group list (ip_group_q) from the actual groups
+		// (not GROUP_LIST) in one of the state files
 #define GROUP_LOAD_IP  GROUP_LIST
+		// Read IP group list into ip_group_q from the list entry
+		// (GROUP_LIST) in one of the state files
 #define GROUP_SAVE_IP  ((BYTE)~0)
+		// Write IP group list from ip_group_q to the list entry
+		// (GROUP_LIST) in one of the state files
 extern void BuildGroups (void);
 
 #define MAX_DESC_CHARS 60
@@ -67,12 +73,12 @@ GAME_STATE_FILE* OpenStateFile (int stat
 void CloseStateFile (GAME_STATE_FILE *fp);
 void DeleteStateFile (int stateFile);
 DWORD LengthStateFile (GAME_STATE_FILE *fp);
-int ReadStateFile (PVOID lpBuf, COUNT size, COUNT count, GAME_STATE_FILE *fp);
-int WriteStateFile (PVOID lpBuf, COUNT size, COUNT count, GAME_STATE_FILE *fp);
+int ReadStateFile (void *lpBuf, COUNT size, COUNT count, GAME_STATE_FILE *fp);
+int WriteStateFile (const void *lpBuf, COUNT size, COUNT count, GAME_STATE_FILE *fp);
 int SeekStateFile (GAME_STATE_FILE *fp, long offset, int whence);
 
 static inline COUNT
-sread_8 (PVOID fp, PBYTE v)
+sread_8 (void *fp, BYTE *v)
 {
 	BYTE t;
 	if (!v) /* read value ignored */
@@ -81,7 +87,7 @@ sread_8 (PVOID fp, PBYTE v)
 }
 
 static inline COUNT
-sread_16 (PVOID fp, PUWORD v)
+sread_16 (void *fp, UWORD *v)
 {
 	UWORD t;
 	if (!v) /* read value ignored */
@@ -90,7 +96,7 @@ sread_16 (PVOID fp, PUWORD v)
 }
 
 static inline COUNT
-sread_32 (PVOID fp, PDWORD v)
+sread_32 (void *fp, DWORD *v)
 {
 	DWORD t;
 	if (!v) /* read value ignored */
@@ -99,7 +105,7 @@ sread_32 (PVOID fp, PDWORD v)
 }
 
 static inline COUNT
-sread_a32 (PVOID fp, PDWORD ar, COUNT count)
+sread_a32 (void *fp, DWORD *ar, COUNT count)
 {
 	assert (ar != NULL);
 
@@ -112,25 +118,25 @@ sread_a32 (PVOID fp, PDWORD ar, COUNT co
 }
 
 static inline COUNT
-swrite_8 (PVOID fp, BYTE v)
+swrite_8 (void *fp, BYTE v)
 {
 	return WriteStateFile (&v, 1, 1, fp);
 }
 
 static inline COUNT
-swrite_16 (PVOID fp, UWORD v)
+swrite_16 (void *fp, UWORD v)
 {
 	return WriteStateFile (&v, 2, 1, fp);
 }
 
 static inline COUNT
-swrite_32 (PVOID fp, DWORD v)
+swrite_32 (void *fp, DWORD v)
 {
 	return WriteStateFile (&v, 4, 1, fp);
 }
 
 static inline COUNT
-swrite_a32 (PVOID fp, PDWORD ar, COUNT count)
+swrite_a32 (void *fp, const DWORD *ar, COUNT count)
 {
 	for ( ; count > 0; --count, ++ar)
 	{
diff -ruNp src.orig/sc2code/status.c src/sc2code/status.c
--- src.orig/sc2code/status.c	2017-11-08 16:49:41 -0600
+++ src/sc2code/status.c	2017-11-08 16:50:09 -0600
@@ -27,8 +27,8 @@
 #include <string.h>
 
 static void
-CaptainsWindow (CAPTAIN_STUFFPTR CSPtr, COORD y, ELEMENT_FLAGS
-		delta_status_flags, ELEMENT_FLAGS cur_status_flags,
+CaptainsWindow (CAPTAIN_STUFF *CSPtr, COORD y,
+		STATUS_FLAGS delta_status_flags, STATUS_FLAGS cur_status_flags,
 		COUNT Pass)
 {
 	STAMP Stamp;
@@ -114,7 +114,7 @@ CaptainsWindow (CAPTAIN_STUFFPTR CSPtr,
 }
 
 void
-DrawBattleCrewAmount (STARSHIPPTR StarShipPtr)
+DrawBattleCrewAmount (SHIP_INFO *ShipInfoPtr)
 {
 #define MAX_CREW_DIGITS 3
 	RECT r;
@@ -125,7 +125,7 @@ DrawBattleCrewAmount (STARSHIPPTR StarSh
 	if (optWhichMenu == OPT_PC)
 			t.baseline.x -= 8;
 	t.baseline.y = BATTLE_CREW_Y +
-			((StarShipPtr->RaceDescPtr->ship_info.ship_flags & GOOD_GUY) ?
+			((ShipInfoPtr->ship_flags & GOOD_GUY) ?
 			GOOD_GUY_YOFFS : BAD_GUY_YOFFS);
 	t.align = ALIGN_LEFT;
 	t.pStr = buf;
@@ -136,7 +136,7 @@ DrawBattleCrewAmount (STARSHIPPTR StarSh
 	r.extent.width = 6 * MAX_CREW_DIGITS + 6;
 	r.extent.height = 5;
 
-	sprintf (buf, "%u", StarShipPtr->RaceDescPtr->ship_info.crew_level);
+	sprintf (buf, "%u", ShipInfoPtr->crew_level);
 	SetContextFont (StarConFont);
 
 	SetContextForeGroundColor (
@@ -147,13 +147,13 @@ DrawBattleCrewAmount (STARSHIPPTR StarSh
 }
 
 void
-DrawCaptainsWindow (STARSHIPPTR StarShipPtr)
+DrawCaptainsWindow (STARSHIP *StarShipPtr)
 {
 	COORD y, y_offs;
 	RECT r;
 	STAMP s;
 	FRAME Frame;
-	RACE_DESCPTR RDPtr;
+	RACE_DESC *RDPtr;
 
 	RDPtr = StarShipPtr->RaceDescPtr;
 	Frame = RDPtr->ship_data.captain_control.background;
@@ -272,18 +272,18 @@ DrawCaptainsWindow (STARSHIPPTR StarShip
 	{
 		// All crew doesn't fit in the graphics; print a number.
 		// Always print a number for the SIS in the full game.
-		DrawBattleCrewAmount (StarShipPtr);
+		DrawBattleCrewAmount (&RDPtr->ship_info);
 	}
 
 	UnbatchGraphics ();
 }
 
 BOOLEAN
-DeltaEnergy (ELEMENTPTR ElementPtr, SIZE energy_delta)
+DeltaEnergy (ELEMENT *ElementPtr, SIZE energy_delta)
 {
 	BOOLEAN retval;
-	STARSHIPPTR StarShipPtr;
-	SHIP_INFOPTR ShipInfoPtr;
+	STARSHIP *StarShipPtr;
+	SHIP_INFO *ShipInfoPtr;
 
 	retval = TRUE;
 
@@ -312,17 +312,18 @@ DeltaEnergy (ELEMENTPTR ElementPtr, SIZE
 		StarShipPtr->energy_counter =
 				StarShipPtr->RaceDescPtr->characteristics.energy_wait;
 
-		DeltaStatistics (StarShipPtr, 0, energy_delta);
+		DeltaStatistics (ShipInfoPtr, 0, energy_delta);
 	}
 
 	return (retval);
 }
 
 BOOLEAN
-DeltaCrew (ELEMENTPTR ElementPtr, SIZE crew_delta)
+DeltaCrew (ELEMENT *ElementPtr, SIZE crew_delta)
 {
 	BOOLEAN retval;
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
+	SHIP_INFO *ShipInfoPtr;
 
 	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_LAST_BATTLE
 			&& (ElementPtr->state_flags & BAD_GUY))
@@ -330,12 +331,9 @@ DeltaCrew (ELEMENTPTR ElementPtr, SIZE c
 
 	retval = TRUE;
 	GetElementStarShip (ElementPtr, &StarShipPtr);
+	ShipInfoPtr = &StarShipPtr->RaceDescPtr->ship_info;
 	if (crew_delta > 0)
 	{
-		SHIP_INFOPTR ShipInfoPtr;
-
-		ShipInfoPtr = &StarShipPtr->RaceDescPtr->ship_info;
-
 		ElementPtr->crew_level += crew_delta;
 		if (ElementPtr->crew_level > ShipInfoPtr->max_crew)
 		{
@@ -355,22 +353,22 @@ DeltaCrew (ELEMENTPTR ElementPtr, SIZE c
 		}
 	}
 
-	DeltaStatistics (StarShipPtr, crew_delta, 0);
+	DeltaStatistics (ShipInfoPtr, crew_delta, 0);
 
 	return (retval);
 }
 
 void
-PreProcessStatus (PELEMENT ShipPtr)
+PreProcessStatus (ELEMENT *ShipPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	if (StarShipPtr->captains_name_index
 			|| (StarShipPtr->RaceDescPtr->ship_info.ship_flags & GOOD_GUY))
 	{
-		ELEMENT_FLAGS old_status_flags, cur_status_flags;
-		CAPTAIN_STUFFPTR CSPtr;
+		STATUS_FLAGS old_status_flags, cur_status_flags;
+		CAPTAIN_STUFF *CSPtr;
 
 		cur_status_flags = StarShipPtr->cur_status_flags;
 		old_status_flags = StarShipPtr->old_status_flags;
@@ -389,17 +387,16 @@ PreProcessStatus (PELEMENT ShipPtr)
 }
 
 void
-PostProcessStatus (PELEMENT ShipPtr)
+PostProcessStatus (ELEMENT *ShipPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	if (StarShipPtr->captains_name_index
 			|| (StarShipPtr->RaceDescPtr->ship_info.ship_flags & GOOD_GUY))
 	{
 		COORD y;
-		ELEMENT_FLAGS cur_status_flags, old_status_flags;
-
+		STATUS_FLAGS cur_status_flags, old_status_flags;
 
 		cur_status_flags = StarShipPtr->cur_status_flags;
 
diff -ruNp src.orig/sc2code/tactrans.c src/sc2code/tactrans.c
--- src.orig/sc2code/tactrans.c	2017-11-08 16:49:41 -0600
+++ src/sc2code/tactrans.c	2017-11-08 16:50:09 -0600
@@ -16,6 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+#include "battlecontrols.h"
 #include "build.h"
 #include "collide.h"
 #include "globdata.h"
@@ -35,14 +36,14 @@
 
 
 BOOLEAN
-OpponentAlive (STARSHIPPTR TestStarShipPtr)
+OpponentAlive (STARSHIP *TestStarShipPtr)
 {
 	HELEMENT hElement, hSuccElement;
 
 	for (hElement = GetHeadElement (); hElement; hElement = hSuccElement)
 	{
-		ELEMENTPTR ElementPtr;
-		STARSHIPPTR StarShipPtr;
+		ELEMENT *ElementPtr;
+		STARSHIP *StarShipPtr;
 
 		LockElement (hElement, &ElementPtr);
 		hSuccElement = GetSuccElement (ElementPtr);
@@ -119,7 +120,7 @@ readyToEndCallback (NetConnection *conn,
  * 5. The battle ends.
  */
 static bool
-readyForBattleEndPlayer (NetConnection *conn, void *arg)
+readyForBattleEndPlayer (NetConnection *conn)
 {
 	BattleStateData *battleStateData;
 	battleStateData = (BattleStateData *) NetConnection_getStateData(conn);
@@ -176,11 +177,32 @@ readyForBattleEndPlayer (NetConnection *
 	// We are ready and wait for the other party to become ready too.
 	negotiateReady (conn, true, NetState_interBattle);
 
-	(void) arg;
 	return true;	
 }
 #endif
 
+bool
+battleEndReadyHuman (HumanInputContext *context)
+{
+	(void) context;
+	return true;
+}
+
+bool
+battleEndReadyComputer (ComputerInputContext *context)
+{
+	(void) context;
+	return true;
+}
+
+#ifdef NETPLAY
+bool
+battleEndReadyNetwork (NetworkInputContext *context)
+{
+	return readyForBattleEndPlayer (netConnections[context->playerNr]);
+}
+#endif
+
 // Returns true iff this side is ready to end the battle.
 static inline bool
 readyForBattleEnd (COUNT side)
@@ -189,11 +211,15 @@ readyForBattleEnd (COUNT side)
 #if DEMO_MODE
 	// In Demo mode, the saved journal should be replayed with frame
 	// accuracy. PLRPlaying () isn't consistent enough.
+	(void) side;
 	return true;
 #else  /* !DEMO_MODE */
+	(void) side;
 	return !PLRPlaying ((MUSIC_REF)~0);
 #endif  /* !DEMO_MODE */
 #else  /* defined (NETPLAY) */
+	int playerI;
+
 	if (PLRPlaying ((MUSIC_REF)~0))
 		return false;
 
@@ -211,8 +237,10 @@ readyForBattleEnd (COUNT side)
 		return false;
 	}
 
-	if (!forAllConnectedPlayers (readyForBattleEndPlayer, NULL))
-		return false;
+	for (playerI = 0; playerI < NUM_PLAYERS; playerI++)
+		if (!PlayerInput[playerI]->handlers->battleEndReady (
+				PlayerInput[playerI]))
+			return false;
 
 	currentDeadSide = (COUNT)~0;
 			// Another side may be handled.
@@ -222,9 +250,9 @@ readyForBattleEnd (COUNT side)
 }
 
 void
-new_ship (PELEMENT DeadShipPtr)
+new_ship (ELEMENT *DeadShipPtr)
 {
-	STARSHIPPTR DeadStarShipPtr;
+	STARSHIP *DeadStarShipPtr;
 
 	ProcessSound ((SOUND)~0, NULL);
 
@@ -239,11 +267,10 @@ new_ship (PELEMENT DeadShipPtr)
 		BOOLEAN MusicStarted;
 		HELEMENT hElement, hSuccElement;
 
-		DeadStarShipPtr->ShipFacing =
-				DeadStarShipPtr->RaceDescPtr->ship_info.var2;
-		DeadStarShipPtr->special_counter =
+		/* Record crew left after the battle */
+		DeadStarShipPtr->crew_level =
 				DeadStarShipPtr->RaceDescPtr->ship_info.crew_level;
-		if (DeadStarShipPtr->special_counter)
+		if (DeadStarShipPtr->crew_level)
 		{
 			// We've just warped out. new_ship() will still be called
 			// a few times, to process the trace left behind (I assume).
@@ -264,8 +291,8 @@ new_ship (PELEMENT DeadShipPtr)
 				// set up for deletion below.
 		for (hElement = GetHeadElement (); hElement; hElement = hSuccElement)
 		{
-			ELEMENTPTR ElementPtr;
-			STARSHIPPTR StarShipPtr;
+			ELEMENT *ElementPtr;
+			STARSHIP *StarShipPtr;
 
 			LockElement (hElement, &ElementPtr);
 			hSuccElement = GetSuccElement (ElementPtr);
@@ -297,9 +324,9 @@ new_ship (PELEMENT DeadShipPtr)
 			if (StarShipPtr
 					&& (StarShipPtr->cur_status_flags & PLAY_VICTORY_DITTY))
 			{
-				// StarShipPtr points to the surviving ship.
+				// StarShipPtr points to the remaining ship.
 				MusicStarted = TRUE;
-				PlayMusic ((MUSIC_REF)StarShipPtr->RaceDescPtr->
+				PlayMusic (StarShipPtr->RaceDescPtr->
 						ship_data.victory_ditty, FALSE, 3);
 				StarShipPtr->cur_status_flags &= ~PLAY_VICTORY_DITTY;
 			}
@@ -334,7 +361,8 @@ new_ship (PELEMENT DeadShipPtr)
 		if (DeadStarShipPtr->RaceDescPtr->uninit_func != NULL)
 			(*DeadStarShipPtr->RaceDescPtr->uninit_func) (
 					DeadStarShipPtr->RaceDescPtr);
-		free_ship (DeadStarShipPtr, TRUE);
+		free_ship (DeadStarShipPtr->RaceDescPtr, TRUE, TRUE);
+		DeadStarShipPtr->RaceDescPtr = 0;
 UnbatchGraphics ();
 
 #ifdef NETPLAY
@@ -374,8 +402,7 @@ UnbatchGraphics ();
 			if (RestartMusic)
 				BattleSong (TRUE);
 		}
-		else if (LOBYTE (battle_counter) == 0
-				|| HIBYTE (battle_counter) == 0)
+		else if (battle_counter[0] == 0 || battle_counter[1] == 0)
 		{
 			// One player is out of ships. The battle is over.
 			GLOBAL (CurrentActivity) &= ~IN_BATTLE;
@@ -403,7 +430,7 @@ BatchGraphics ();
 }
 
 void
-explosion_preprocess (PELEMENT ShipPtr)
+explosion_preprocess (ELEMENT *ShipPtr)
 {
 	BYTE i;
 
@@ -411,7 +438,7 @@ explosion_preprocess (PELEMENT ShipPtr)
 	switch (i)
 	{
 		case 25:
-			ShipPtr->preprocess_func = NULL_PTR;
+			ShipPtr->preprocess_func = NULL;
 		case 0:
 		case 1:
 		case 2:
@@ -446,7 +473,7 @@ explosion_preprocess (PELEMENT ShipPtr)
 		{
 			COUNT angle, dist;
 			DWORD rand_val;
-			ELEMENTPTR ElementPtr;
+			ELEMENT *ElementPtr;
 			extern FRAME explosion[];
 
 			PutElement (hElement);
@@ -478,20 +505,19 @@ explosion_preprocess (PELEMENT ShipPtr)
 }
 
 void
-ship_death (PELEMENT ShipPtr)
+ship_death (ELEMENT *ShipPtr)
 {
-	STARSHIPPTR StarShipPtr, VictoriousStarShipPtr;
+	STARSHIP *StarShipPtr;
+	STARSHIP *VictoriousStarShipPtr;
 	HELEMENT hElement, hNextElement;
-	ELEMENTPTR ElementPtr;
+	ELEMENT *ElementPtr;
 
 	StopMusic ();
 
 	if (ShipPtr->mass_points <= MAX_SHIP_MASS)
 	{
-		if (WHICH_SIDE (ShipPtr->state_flags))
-			battle_counter -= MAKE_WORD (0, 1);
-		else
-			battle_counter -= MAKE_WORD (1, 0);
+		COUNT side = ElementFlagsSide (ShipPtr->state_flags);
+		battle_counter[side]--;
 	}
 
 	VictoriousStarShipPtr = 0;
@@ -499,7 +525,7 @@ ship_death (PELEMENT ShipPtr)
 	{
 		LockElement (hElement, &ElementPtr);
 		if ((ElementPtr->state_flags & PLAYER_SHIP)
-				&& ElementPtr != (ELEMENTPTR)ShipPtr
+				&& ElementPtr != ShipPtr
 						/* and not running away */
 				&& ElementPtr->mass_points <= MAX_SHIP_MASS)
 		{
@@ -519,7 +545,7 @@ ship_death (PELEMENT ShipPtr)
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	StarShipPtr->cur_status_flags &= ~PLAY_VICTORY_DITTY;
 
-	DeltaEnergy ((ELEMENTPTR)ShipPtr,
+	DeltaEnergy (ShipPtr,
 			-(SIZE)StarShipPtr->RaceDescPtr->ship_info.energy_level);
 
 	ShipPtr->life_span = NUM_EXPLOSION_FRAMES * 3;
@@ -528,7 +554,7 @@ ship_death (PELEMENT ShipPtr)
 	ShipPtr->postprocess_func = PostProcessStatus;
 	ShipPtr->death_func = new_ship;
 	ShipPtr->hTarget = 0;
-	ZeroVelocityComponents (&((ELEMENTPTR)ShipPtr)->velocity);
+	ZeroVelocityComponents (&ShipPtr->velocity);
 	if (ShipPtr->crew_level) /* only happens for shofixti self-destruct */
 	{
 
@@ -537,7 +563,7 @@ ship_death (PELEMENT ShipPtr)
 				CalcSoundPosition (ShipPtr), ShipPtr,
 				GAME_SOUND_PRIORITY + 1);
 
-		DeltaCrew ((ELEMENTPTR)ShipPtr, -(SIZE)ShipPtr->crew_level);
+		DeltaCrew (ShipPtr, -(SIZE)ShipPtr->crew_level);
 		if (VictoriousStarShipPtr == 0)
 			StarShipPtr->cur_status_flags |= PLAY_VICTORY_DITTY;
 	}
@@ -553,7 +579,7 @@ ship_death (PELEMENT ShipPtr)
 #define START_ION_COLOR BUILD_COLOR (MAKE_RGB15 (0x1F, 0x15, 0x00), 0x7A)
 
 void
-spawn_ion_trail (PELEMENT ElementPtr)
+spawn_ion_trail (ELEMENT *ElementPtr)
 {
 		  
 	if (ElementPtr->state_flags & PLAYER_SHIP)
@@ -566,8 +592,8 @@ spawn_ion_trail (PELEMENT ElementPtr)
 #define ION_LIFE 1
 			COUNT angle;
 			RECT r;
-			ELEMENTPTR IonElementPtr;
-			STARSHIPPTR StarShipPtr;
+			ELEMENT *IonElementPtr;
+			STARSHIP *StarShipPtr;
 
 			GetElementStarShip (ElementPtr, &StarShipPtr);
 			angle = FACING_TO_ANGLE (StarShipPtr->ShipFacing) + HALF_CIRCLE;
@@ -653,7 +679,7 @@ spawn_ion_trail (PELEMENT ElementPtr)
 // Used when a new ship warps in, or a ship escapes by warping out, but not
 // when a Pkunk ship is reborn.
 void
-ship_transition (PELEMENT ElementPtr)
+ship_transition (ELEMENT *ElementPtr)
 {
 	if (ElementPtr->state_flags & PLAYER_SHIP)
 	{
@@ -661,7 +687,7 @@ ship_transition (PELEMENT ElementPtr)
 		{
 			ElementPtr->life_span = HYPERJUMP_LIFE;
 			ElementPtr->preprocess_func = ship_transition;
-			ElementPtr->postprocess_func = NULL_PTR;
+			ElementPtr->postprocess_func = NULL;
 			SetPrimType (&DisplayArray[ElementPtr->PrimIndex], NO_PRIM);
 			ElementPtr->state_flags |= NONSOLID | FINITE_LIFE | CHANGING;
 		}
@@ -679,7 +705,7 @@ ship_transition (PELEMENT ElementPtr)
 				InitIntersectStartPoint (ElementPtr);
 				InitIntersectEndPoint (ElementPtr);
 				InitIntersectFrame (ElementPtr);
-				ZeroVelocityComponents (&((ELEMENTPTR)ElementPtr)->velocity);
+				ZeroVelocityComponents (&ElementPtr->velocity);
 				ElementPtr->state_flags &= ~(NONSOLID | FINITE_LIFE);
 				ElementPtr->state_flags |= CHANGING;
 
@@ -693,15 +719,15 @@ ship_transition (PELEMENT ElementPtr)
 
 	{
 		HELEMENT hShipImage;
-		ELEMENTPTR ShipImagePtr;
-		STARSHIPPTR StarShipPtr;
+		ELEMENT *ShipImagePtr;
+		STARSHIP *StarShipPtr;
 		
 		GetElementStarShip (ElementPtr, &StarShipPtr);
 		LockElement (StarShipPtr->hShip, &ShipImagePtr);
 
 		if (!(ShipImagePtr->state_flags & NONSOLID))
 		{
-			ElementPtr->preprocess_func = NULL_PTR;
+			ElementPtr->preprocess_func = NULL;
 		}
 		else if ((hShipImage = AllocElement ()))
 		{
@@ -729,7 +755,7 @@ ship_transition (PELEMENT ElementPtr)
 						COSINE (angle, TRANSITION_SPEED);
 				ShipImagePtr->current.location.y +=
 						SINE (angle, TRANSITION_SPEED);
-				ElementPtr->preprocess_func = NULL_PTR;
+				ElementPtr->preprocess_func = NULL;
 			}
 			else if (ElementPtr->crew_level)
 			{
@@ -757,9 +783,9 @@ ship_transition (PELEMENT ElementPtr)
 }
 
 void
-flee_preprocess (PELEMENT ElementPtr)
+flee_preprocess (ELEMENT *ElementPtr)
 {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 
 	if (--ElementPtr->turn_wait == 0)
 	{
@@ -814,7 +840,7 @@ flee_preprocess (PELEMENT ElementPtr)
 
 			ElementPtr->life_span = HYPERJUMP_LIFE + 1;
 			ElementPtr->preprocess_func = ship_transition;
-			ElementPtr->postprocess_func = NULL_PTR;
+			ElementPtr->postprocess_func = NULL;
 			SetPrimType (&DisplayArray[ElementPtr->PrimIndex], NO_PRIM);
 			ElementPtr->state_flags |= NONSOLID | FINITE_LIFE | CHANGING;
 		}
diff -ruNp src.orig/sc2code/tactrans.h src/sc2code/tactrans.h
--- src.orig/sc2code/tactrans.h	1969-12-31 18:00:00 -0600
+++ src/sc2code/tactrans.h	2017-11-08 16:50:09 -0600
@@ -0,0 +1,30 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _TACTRANS_H
+#define _TACTRANS_H
+
+bool battleEndReadyHuman (HumanInputContext *context);
+bool battleEndReadyComputer (ComputerInputContext *context);
+#ifdef NETPLAY
+bool battleEndReadyNetwork (NetworkInputContext *context);
+#endif
+
+#endif  /* _TACTRANS_H */
+
+
diff -ruNp src.orig/sc2code/units.h src/sc2code/units.h
--- src.orig/sc2code/units.h	2017-11-08 16:49:41 -0600
+++ src/sc2code/units.h	2017-11-08 16:50:09 -0600
@@ -76,11 +76,11 @@ extern int ScreenHeight;
 #define MAX_Y_UNIVERSE 9999
 #define MAX_X_LOGICAL \
 		((UNIVERSE_TO_LOGX (MAX_X_UNIVERSE + 1) > UNIVERSE_TO_LOGX (-1) ? \
-				UNIVERSE_TO_LOGX (MAX_X_UNIVERSE) : UNIVERSE_TO_LOGX (-1)) \
+				UNIVERSE_TO_LOGX (MAX_X_UNIVERSE + 1) : UNIVERSE_TO_LOGX (-1)) \
 				- 1L)
 #define MAX_Y_LOGICAL \
 		((UNIVERSE_TO_LOGY (MAX_Y_UNIVERSE + 1) > UNIVERSE_TO_LOGY (-1) ? \
-				UNIVERSE_TO_LOGY (MAX_Y_UNIVERSE) : UNIVERSE_TO_LOGY (-1)) \
+				UNIVERSE_TO_LOGY (MAX_Y_UNIVERSE + 1) : UNIVERSE_TO_LOGY (-1)) \
 				- 1L)
 #define SECTOR_WIDTH 195
 #define SECTOR_HEIGHT 25
@@ -95,7 +95,8 @@ extern int ScreenHeight;
 static inline COORD
 logxToUniverse (SDWORD lx)
 {
-	return (COORD) ((lx * ((MAX_X_UNIVERSE + 1) >> 4)) * 10
+	return (COORD) ((((lx * ((MAX_X_UNIVERSE + 1) >> 4)) * 10)
+			+ ((((MAX_X_UNIVERSE + 1) >> 4) * 10) >> 1))
 			/ ((SDWORD) ((LOG_SPACE_WIDTH) >> 4) * SECTOR_WIDTH));
 }
 #define LOGX_TO_UNIVERSE(lx) \
@@ -104,7 +105,8 @@ static inline COORD
 logyToUniverse (SDWORD ly)
 {
 	return (COORD) (MAX_Y_UNIVERSE -
-			(COORD)(((SDWORD) (ly) * ((MAX_Y_UNIVERSE + 1) >> 4))
+			(COORD) ((((SDWORD) (ly) * ((MAX_Y_UNIVERSE + 1) >> 4))
+			+ (((MAX_Y_UNIVERSE + 1) >> 4) >> 1))
 			/ ((SDWORD) ((LOG_SPACE_HEIGHT) >> 4) * SECTOR_HEIGHT)));
 }
 #define LOGY_TO_UNIVERSE(ly) \
diff -ruNp src.orig/sc2code/uqmdebug.c src/sc2code/uqmdebug.c
--- src.orig/sc2code/uqmdebug.c	2017-11-08 16:49:41 -0600
+++ src/sc2code/uqmdebug.c	2017-11-08 16:50:09 -0600
@@ -18,6 +18,7 @@
 
 #include "uqmdebug.h"
 
+#include "build.h"
 #include "colors.h"
 #include "clock.h"
 #include "encount.h"
@@ -35,7 +36,7 @@
 #include <errno.h>
 
 
-static void dumpEventCallback (const EVENTPTR eventPtr, void *arg);
+static void dumpEventCallback (const EVENT *eventPtr, void *arg);
 
 static void starRecurse (STAR_DESC *star, void *arg);
 static void planetRecurse (STAR_DESC *star, SOLARSYS_STATE *system,
@@ -49,6 +50,16 @@ static void dumpPlanetCallback (const PL
 static void dumpMoonCallback (const PLANET_DESC *moon, void *arg);
 static void dumpWorld (FILE *out, const PLANET_DESC *world);
 
+typedef struct TallyResourcesArg TallyResourcesArg;
+static void tallySystemPreCallback (const STAR_DESC *star, const
+		SOLARSYS_STATE *system, void *arg);
+static void tallySystemPostCallback (const STAR_DESC *star, const
+		SOLARSYS_STATE *system, void *arg);
+static void tallyPlanetCallback (const PLANET_DESC *planet, void *arg);
+static void tallyMoonCallback (const PLANET_DESC *moon, void *arg);
+static void tallyResourcesWorld (TallyResourcesArg *arg,
+		const PLANET_DESC *world);
+
 static void dumpPlanetTypeCallback (int index, const PlanetFrame *planet,
 		void *arg);
 
@@ -63,23 +74,48 @@ debugKeyPressed (void)
 {
 	// State modifying:
 	equipShip ();
+	giveDevices ();
+
+	// Give the player the ships you can't ally with under normal
+	// conditions.
+	clearEscorts ();
+	ActivateStarShip (ARILOU_SHIP, 1);
+	ActivateStarShip (PKUNK_SHIP, 1);
+	ActivateStarShip (VUX_SHIP, 1);
+	ActivateStarShip (YEHAT_SHIP, 1);
+	ActivateStarShip (MELNORME_SHIP, 1);
+	ActivateStarShip (DRUUGE_SHIP, 1);
+	ActivateStarShip (ILWRATH_SHIP, 1);
+	ActivateStarShip (MYCON_SHIP, 1);
+	ActivateStarShip (SLYLANDRO_SHIP, 1);
+	ActivateStarShip (UMGAH_SHIP, 1);
+	ActivateStarShip (URQUAN_SHIP, 1);
+	ActivateStarShip (BLACK_URQUAN_SHIP, 1);
+
 	resetCrewBattle ();
 	resetEnergyBattle ();
 	instantMove = !instantMove;
 	showSpheres ();
 	activateAllShips ();
-//	forwardToNextEvent (TRUE);		
+//	forwardToNextEvent (TRUE);
+//	SET_GAME_STATE (MELNORME_CREDIT1, 100);
+//	GLOBAL_SIS (ResUnits) = 100000;
 
 	// Tests
 //	Scale_PerfTest ();
 
 	// Informational:
+//	dumpStrings (stdout);
 //	dumpEvents (stderr);
 //	dumpPlanetTypes(stderr);
 //	debugHook = dumpUniverseToFile;
 			// This will cause dumpUniverseToFile to be called from the
 			// main loop. Calling it from here would give threading
 			// problems.
+//	debugHook = tallyResourcesToFile;
+			// This will cause tallyResourcesToFile to be called from the
+			// main loop. Calling it from here would give threading
+			// problems.
 
 	// Interactive:
 //	uio_debugInteractive(stdin, stdout, stderr);
@@ -93,7 +129,7 @@ void
 forwardToNextEvent (BOOLEAN skipHEE)
 {
 	HEVENT hEvent;
-	EVENTPTR EventPtr;
+	EVENT *EventPtr;
 	COUNT year, month, day;
 			// time of next event
 	BOOLEAN done;
@@ -183,14 +219,14 @@ eventName (BYTE func_index)
 }
 
 static void
-dumpEventCallback (const EVENTPTR eventPtr, void *arg)
+dumpEventCallback (const EVENT *eventPtr, void *arg)
 {
 	FILE *out = (FILE *) arg;
 	dumpEvent (out, eventPtr);
 }
 
 void
-dumpEvent (FILE *out, EVENTPTR eventPtr)
+dumpEvent (FILE *out, const EVENT *eventPtr)
 {
 	fprintf (out, "%4u/%02u/%02u: %s\n",
 			eventPtr->year_index,
@@ -327,6 +363,64 @@ equipShip (void)
 
 ////////////////////////////////////////////////////////////////////////////
 
+void
+giveDevices (void) {
+	SET_GAME_STATE (ROSY_SPHERE_ON_SHIP, 1);
+	SET_GAME_STATE (ARTIFACT_2_ON_SHIP, 1);
+	SET_GAME_STATE (ARTIFACT_3_ON_SHIP, 1);
+	SET_GAME_STATE (SUN_DEVICE_ON_SHIP, 1);
+	SET_GAME_STATE (UTWIG_BOMB_ON_SHIP, 1);
+	SET_GAME_STATE (ULTRON_CONDITION, 1);
+	//SET_GAME_STATE (ULTRON_CONDITION, 2);
+	//SET_GAME_STATE (ULTRON_CONDITION, 3);
+	//SET_GAME_STATE (ULTRON_CONDITION, 4);
+	SET_GAME_STATE (MAIDENS_ON_SHIP, 1);
+	SET_GAME_STATE (TALKING_PET_ON_SHIP, 1);
+	SET_GAME_STATE (AQUA_HELIX_ON_SHIP, 1);
+	SET_GAME_STATE (CLEAR_SPINDLE_ON_SHIP, 1);
+	SET_GAME_STATE (UMGAH_BROADCASTERS_ON_SHIP, 1);
+	SET_GAME_STATE (TAALO_PROTECTOR_ON_SHIP, 1);
+	SET_GAME_STATE (EGG_CASE0_ON_SHIP, 1);
+	SET_GAME_STATE (EGG_CASE1_ON_SHIP, 1);
+	SET_GAME_STATE (EGG_CASE2_ON_SHIP, 1);
+	SET_GAME_STATE (SYREEN_SHUTTLE_ON_SHIP, 1);
+	SET_GAME_STATE (VUX_BEAST_ON_SHIP, 1);
+	SET_GAME_STATE (PORTAL_SPAWNER_ON_SHIP, 1);
+	SET_GAME_STATE (PORTAL_KEY_ON_SHIP, 1);
+	SET_GAME_STATE (BURV_BROADCASTERS_ON_SHIP, 1);
+	SET_GAME_STATE (MOONBASE_ON_SHIP, 1);
+	
+	// Not strictly a device (although it originally was one).
+	SET_GAME_STATE (DESTRUCT_CODE_ON_SHIP, 1);
+}
+
+////////////////////////////////////////////////////////////////////////////
+
+void
+clearEscorts (void)
+{
+	HSHIPFRAG hStarShip, hNextShip;
+
+	for (hStarShip = GetHeadLink (&GLOBAL (built_ship_q));
+			hStarShip; hStarShip = hNextShip)
+	{
+		SHIP_FRAGMENT *StarShipPtr;
+
+		StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+		hNextShip = _GetSuccLink (StarShipPtr);
+		UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+
+		RemoveQueue (&GLOBAL (built_ship_q), hStarShip);
+		FreeShipFrag (&GLOBAL (built_ship_q), hStarShip);
+	}
+
+	LockMutex (GraphicsLock);
+	DeltaSISGauges (UNDEFINED_DELTA, UNDEFINED_DELTA, UNDEFINED_DELTA);
+	UnlockMutex (GraphicsLock);
+}
+
+////////////////////////////////////////////////////////////////////////////
+
 #if 0
 // Not needed anymore, but could be useful in the future.
 
@@ -335,7 +429,7 @@ static HELEMENT
 findFlagshipElement (void)
 {
 	HELEMENT hElement, hNextElement;
-	ELEMENTPTR ElementPtr;
+	ELEMENT *ElementPtr;
 
 	// Find the ship element.
 	for (hElement = GetTailElement (); hElement != 0;
@@ -363,8 +457,19 @@ void
 doInstantMove (void)
 {
 	// Move to the new location:
-	GLOBAL_SIS (log_x) = UNIVERSE_TO_LOGX((GLOBAL (autopilot)).x);
-	GLOBAL_SIS (log_y) = UNIVERSE_TO_LOGY((GLOBAL (autopilot)).y);
+	if ((GLOBAL (autopilot)).x == ~0 || (GLOBAL (autopilot)).y == ~0)
+	{
+		// If no destination has been selected, use the current location
+		// as the destination.
+		(GLOBAL (autopilot)).x = LOGX_TO_UNIVERSE(GLOBAL_SIS (log_x));
+		(GLOBAL (autopilot)).y = LOGY_TO_UNIVERSE(GLOBAL_SIS (log_y));
+	}
+	else
+	{
+		// A new destination has been selected.
+		GLOBAL_SIS (log_x) = UNIVERSE_TO_LOGX((GLOBAL (autopilot)).x);
+		GLOBAL_SIS (log_y) = UNIVERSE_TO_LOGY((GLOBAL (autopilot)).y);
+	}
 
 	// Check for a solar systems at the destination.
 	if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
@@ -384,6 +489,18 @@ doInstantMove (void)
 		}
 	}
 
+	// If entering HyperSpace directly from an orbital view,
+	// GLOBAL (ShipStamp.frame) will contain actual frame data,
+	// and not a DWORD indicating ship position.  Shocking.  Reset it
+	// if it's obviously out-of-bounds, and normalize it just-in-case.
+	// If this is not done, the ship will spin endlessly upon entry
+	// into HyperSpace from a coarse scan
+	if (LOWORD (GLOBAL (ShipStamp.frame)) > FULL_CIRCLE)
+		GLOBAL (ShipStamp.frame) = 0;
+	else
+		GLOBAL (ShipStamp.frame) = NORMALIZE_FACING (
+				GLOBAL (ShipStamp.frame));
+
 	// Turn off the autopilot:
 	(GLOBAL (autopilot)).x = ~0;
 	(GLOBAL (autopilot)).y = ~0;
@@ -394,27 +511,24 @@ doInstantMove (void)
 void
 showSpheres (void)
 {
-	HSTARSHIP hStarShip, hNextShip;
+	HFLEETINFO hStarShip, hNextShip;
 	
 	for (hStarShip = GetHeadLink (&GLOBAL (avail_race_q));
 			hStarShip != NULL; hStarShip = hNextShip)
 	{
-		EXTENDED_SHIP_FRAGMENTPTR StarShipPtr;
+		FLEET_INFO *FleetPtr;
 
-		StarShipPtr = (EXTENDED_SHIP_FRAGMENTPTR) LockStarShip (
-				&GLOBAL (avail_race_q), hStarShip);
-		hNextShip = _GetSuccLink (StarShipPtr);
+		FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
+		hNextShip = _GetSuccLink (FleetPtr);
 
-		if ((StarShipPtr->ShipInfo.actual_strength != (COUNT) ~0) &&
-				(StarShipPtr->ShipInfo.known_strength !=
-				StarShipPtr->ShipInfo.actual_strength))
+		if ((FleetPtr->actual_strength != INFINITE_RADIUS) &&
+				(FleetPtr->known_strength != FleetPtr->actual_strength))
 		{
-			StarShipPtr->ShipInfo.known_strength =
-					StarShipPtr->ShipInfo.actual_strength;
-			StarShipPtr->ShipInfo.known_loc = StarShipPtr->ShipInfo.loc;
+			FleetPtr->known_strength = FleetPtr->actual_strength;
+			FleetPtr->known_loc = FleetPtr->loc;
 		}
 
-		UnlockStarShip (&GLOBAL (avail_race_q), hStarShip);
+		UnlockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
 	}
 }
 
@@ -423,25 +537,24 @@ showSpheres (void)
 void
 activateAllShips (void)
 {
-	HSTARSHIP hStarShip, hNextShip;
+	HFLEETINFO hStarShip, hNextShip;
 	
 	for (hStarShip = GetHeadLink (&GLOBAL (avail_race_q));
 			hStarShip != NULL; hStarShip = hNextShip)
 	{
-		EXTENDED_SHIP_FRAGMENTPTR StarShipPtr;
+		FLEET_INFO *FleetPtr;
 
-		StarShipPtr = (EXTENDED_SHIP_FRAGMENTPTR) LockStarShip (
-				&GLOBAL (avail_race_q), hStarShip);
-		hNextShip = _GetSuccLink (StarShipPtr);
+		FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
+		hNextShip = _GetSuccLink (FleetPtr);
 
-		if (StarShipPtr->ShipInfo.icons != NULL)
+		if (FleetPtr->icons != NULL)
 				// Skip the Ur-Quan probe.
 		{
-			StarShipPtr->ShipInfo.ship_flags &= ~(GOOD_GUY | BAD_GUY);
-			StarShipPtr->ShipInfo.ship_flags |= GOOD_GUY;
+			FleetPtr->ship_flags &= ~(GOOD_GUY | BAD_GUY);
+			FleetPtr->ship_flags |= GOOD_GUY;
 		}
 
-		UnlockStarShip (&GLOBAL (avail_race_q), hStarShip);
+		UnlockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
 	}
 }
 
@@ -463,7 +576,7 @@ forAllPlanets (STAR_DESC *star, SOLARSYS
 {
 	COUNT i;
 
-	assert(CurStarDescPtr = star);
+	assert(CurStarDescPtr == star);
 	assert(pSolarSysState == system);
 
 	for (i = 0; i < system->SunDesc[0].NumPlanets; i++)
@@ -492,8 +605,10 @@ UniverseRecurse (UniverseRecurseArg *uni
 	BOOLEAN clockRunning;
 	ACTIVITY savedActivity;
 	
-	if (universeRecurseArg->systemFunc == NULL
-			&& universeRecurseArg->planetFunc == NULL
+	if (universeRecurseArg->systemFuncPre == NULL
+			&& universeRecurseArg->systemFuncPost == NULL
+			&& universeRecurseArg->planetFuncPre == NULL
+			&& universeRecurseArg->planetFuncPost == NULL
 			&& universeRecurseArg->moonFunc == NULL)
 		return;
 	
@@ -518,11 +633,11 @@ starRecurse (STAR_DESC *star, void *arg)
 	UniverseRecurseArg *universeRecurseArg = (UniverseRecurseArg *) arg;
 
 	SOLARSYS_STATE SolarSysState;
-	PSOLARSYS_STATE oldPSolarSysState = pSolarSysState;
+	SOLARSYS_STATE *oldPSolarSysState = pSolarSysState;
 	DWORD oldSeed =
 			TFB_SeedRandom (MAKE_DWORD (star->star_pt.x, star->star_pt.y));
 
-	STAR_DESCPTR oldStarDescPtr = CurStarDescPtr;
+	STAR_DESC *oldStarDescPtr = CurStarDescPtr;
 	CurStarDescPtr = star;
 
 	memset (&SolarSysState, 0, sizeof (SolarSysState));
@@ -537,19 +652,26 @@ starRecurse (STAR_DESC *star, void *arg)
 	pSolarSysState = &SolarSysState;
 	(*pSolarSysState->GenFunc) (GENERATE_PLANETS);
 
-	if (universeRecurseArg->systemFunc != NULL)
+	if (universeRecurseArg->systemFuncPre != NULL)
 	{
-		(*universeRecurseArg->systemFunc) (
+		(*universeRecurseArg->systemFuncPre) (
 				star, &SolarSysState, universeRecurseArg->arg);
 	}
 	
-	if (universeRecurseArg->planetFunc != NULL
+	if (universeRecurseArg->planetFuncPre != NULL
+			|| universeRecurseArg->planetFuncPost != NULL
 			|| universeRecurseArg->moonFunc != NULL)
 	{
 		forAllPlanets (star, &SolarSysState, planetRecurse,
 				(void *) universeRecurseArg);
 	}
 
+	if (universeRecurseArg->systemFuncPost != NULL)
+	{
+		(*universeRecurseArg->systemFuncPost) (
+				star, &SolarSysState, universeRecurseArg->arg);
+	}
+	
 	pSolarSysState = oldPSolarSysState;
 	CurStarDescPtr = oldStarDescPtr;
 	TFB_SeedRandom (oldSeed);
@@ -561,13 +683,13 @@ planetRecurse (STAR_DESC *star, SOLARSYS
 {
 	UniverseRecurseArg *universeRecurseArg = (UniverseRecurseArg *) arg;
 	
-	assert(CurStarDescPtr = star);
+	assert(CurStarDescPtr == star);
 	assert(pSolarSysState == system);
 
 	system->pBaseDesc = planet;
 	planet->pPrevDesc = &system->SunDesc[0];
 
-	if (universeRecurseArg->planetFunc != NULL)
+	if (universeRecurseArg->planetFuncPre != NULL)
 	{
 		system->pOrbitalDesc = planet;
 		DoPlanetaryAnalysis (&system->SysInfo, planet);
@@ -575,7 +697,7 @@ planetRecurse (STAR_DESC *star, SOLARSYS
 				// GENERATE_ORBITAL will also call DoPlanetaryAnalysis,
 				// but with other GenFuncs this is not guaranteed.
 		(*system->GenFunc) (GENERATE_ORBITAL);
-		(*universeRecurseArg->planetFunc) (
+		(*universeRecurseArg->planetFuncPre) (
 				planet, universeRecurseArg->arg);
 	}
 
@@ -590,6 +712,18 @@ planetRecurse (STAR_DESC *star, SOLARSYS
 
 		TFB_SeedRandom (oldSeed);
 	}
+	
+	if (universeRecurseArg->planetFuncPost != NULL)
+	{
+		system->pOrbitalDesc = planet;
+		DoPlanetaryAnalysis (&system->SysInfo, planet);
+				// When GenerateRandomIP is used as GenFunc,
+				// GENERATE_ORBITAL will also call DoPlanetaryAnalysis,
+				// but with other GenFuncs this is not guaranteed.
+		(*system->GenFunc) (GENERATE_ORBITAL);
+		(*universeRecurseArg->planetFuncPost) (
+				planet, universeRecurseArg->arg);
+	}
 }
 
 static void
@@ -598,7 +732,7 @@ moonRecurse (STAR_DESC *star, SOLARSYS_S
 {
 	UniverseRecurseArg *universeRecurseArg = (UniverseRecurseArg *) arg;
 	
-	assert(CurStarDescPtr = star);
+	assert(CurStarDescPtr == star);
 	assert(pSolarSysState == system);
 	assert(system->pBaseDesc == planet);
 	
@@ -632,8 +766,10 @@ dumpUniverse (FILE *out)
 	
 	dumpUniverseArg.out = out;
 
-	universeRecurseArg.systemFunc = dumpSystemCallback;
-	universeRecurseArg.planetFunc = dumpPlanetCallback;
+	universeRecurseArg.systemFuncPre = dumpSystemCallback;
+	universeRecurseArg.systemFuncPost = NULL;
+	universeRecurseArg.planetFuncPre = dumpPlanetCallback;
+	universeRecurseArg.planetFuncPost = NULL;
 	universeRecurseArg.moonFunc = dumpMoonCallback;
 	universeRecurseArg.arg = (void *) &dumpUniverseArg;
 
@@ -678,7 +814,7 @@ dumpSystem (FILE *out, const STAR_DESC *
 	UNICODE name[256];
 	UNICODE buf[40];
 
-	GetClusterName ((STAR_DESCPTR) star, name);
+	GetClusterName (star, name);
 	snprintf (buf, sizeof buf, "%s %s",
 			bodyColorString (STAR_COLOR(star->Type)),
 			starTypeString (STAR_TYPE(star->Type)));
@@ -867,11 +1003,11 @@ dumpMoon (FILE *out, const PLANET_DESC *
 {
 	const char *typeStr;
 	
-	if (moon->data_index == (BYTE) ~0)
+	if (moon->data_index == HIERARCHY_STARBASE)
 	{
 		typeStr = "StarBase";
 	}
-	else if (moon->data_index == (BYTE) (~0 - 1))
+	else if (moon->data_index == SA_MATRA)
 	{
 		typeStr = "Sa-Matra";
 	}
@@ -890,12 +1026,12 @@ dumpWorld (FILE *out, const PLANET_DESC
 {
 	PLANET_INFO *info;
 	
-	if (world->data_index == (BYTE) ~0) {
+	if (world->data_index == HIERARCHY_STARBASE) {
 		// StarBase
 		return;
 	}
 	
-	if (world->data_index == (BYTE)(~0 - 1)) {
+	if (world->data_index == SA_MATRA) {
 		// Sa-Matra
 		return;
 	}
@@ -1024,6 +1160,114 @@ generateMineralIndex(const SOLARSYS_STAT
 
 ////////////////////////////////////////////////////////////////////////////
 
+struct TallyResourcesArg
+{
+	FILE *out;
+	COUNT mineralCount;
+	COUNT bioCount;
+};
+
+void
+tallyResources (FILE *out)
+{
+	TallyResourcesArg tallyResourcesArg;
+	UniverseRecurseArg universeRecurseArg;
+	
+	tallyResourcesArg.out = out;
+
+	universeRecurseArg.systemFuncPre = tallySystemPreCallback;
+	universeRecurseArg.systemFuncPost = tallySystemPostCallback;
+	universeRecurseArg.planetFuncPre = tallyPlanetCallback;
+	universeRecurseArg.planetFuncPost = NULL;
+	universeRecurseArg.moonFunc = tallyMoonCallback;
+	universeRecurseArg.arg = (void *) &tallyResourcesArg;
+
+	UniverseRecurse (&universeRecurseArg);
+}
+
+void
+tallyResourcesToFile (void)
+{
+	FILE *out;
+
+#	define RESOURCE_TALLY_FILE "ResourceTally"
+	out = fopen(RESOURCE_TALLY_FILE, "w");
+	if (out == NULL)
+	{
+		fprintf(stderr, "Error: Could not open file '%s' for "
+				"writing: %s\n", RESOURCE_TALLY_FILE, strerror(errno));
+		return;
+	}
+
+	tallyResources (out);
+	
+	fclose(out);
+
+	fprintf(stdout, "*** Resource tally complete. The game may be in an "
+			"undefined state.\n");
+			// Data generation may have changed the game state,
+			// in particular for special planet generation.
+}
+
+static void
+tallySystemPreCallback (const STAR_DESC *star, const SOLARSYS_STATE *system,
+		void *arg)
+{
+	TallyResourcesArg *tallyResourcesArg = (TallyResourcesArg *) arg;
+	tallyResourcesArg->mineralCount = 0;
+	tallyResourcesArg->bioCount = 0;
+	
+	(void) star;  /* satisfy compiler */
+	(void) system;  /* satisfy compiler */
+}
+
+static void
+tallySystemPostCallback (const STAR_DESC *star, const SOLARSYS_STATE *system,
+		void *arg)
+{
+	UNICODE name[256];
+	TallyResourcesArg *tallyResourcesArg = (TallyResourcesArg *) arg;
+	FILE *out = tallyResourcesArg->out;
+
+	GetClusterName (star, name);
+	fprintf (out, "%s\t%d\t%d\n", name, tallyResourcesArg->mineralCount,
+			tallyResourcesArg->bioCount);
+
+	(void) star;  /* satisfy compiler */
+	(void) system;  /* satisfy compiler */
+}
+
+static void
+tallyPlanetCallback (const PLANET_DESC *planet, void *arg)
+{
+	tallyResourcesWorld ((TallyResourcesArg *) arg, planet);
+}
+
+static void
+tallyMoonCallback (const PLANET_DESC *moon, void *arg)
+{
+	tallyResourcesWorld ((TallyResourcesArg *) arg, moon);
+}
+
+static void
+tallyResourcesWorld (TallyResourcesArg *arg, const PLANET_DESC *world)
+{
+	if (world->data_index == HIERARCHY_STARBASE) {
+		// StarBase
+		return;
+	}
+	
+	if (world->data_index == SA_MATRA) {
+		// Sa-Matra
+		return;
+	}
+
+	arg->bioCount += calculateBioValue (pSolarSysState, world),
+	arg->mineralCount += calculateMineralValue (pSolarSysState, world);
+}
+
+////////////////////////////////////////////////////////////////////////////
+
 void
 forAllPlanetTypes (void (*callback) (int, const PlanetFrame *, void *),
 		void *arg)
@@ -1080,7 +1324,7 @@ dumpPlanetType (FILE *out, int index, co
 			);
 	for (i = 0; i < NUM_USEFUL_ELEMENTS; i++)
 	{
-		const ElementEntry *entry;
+		const ELEMENT_ENTRY *entry;
 		entry = &planetType->UsefulElements[i];
 		if (entry->Density == 0)
 			continue;
@@ -1239,13 +1483,13 @@ depositQualityString (BYTE quality)
 ////////////////////////////////////////////////////////////////////////////
 
 // Which should be GOOD_GUY or BAD_GUY
-STARSHIPPTR
+STARSHIP*
 findPlayerShip(ELEMENT_FLAGS which) {
 	HELEMENT hElement, hNextElement;
 
 	for (hElement = GetHeadElement (); hElement; hElement = hNextElement)
 	{
-		ELEMENTPTR ElementPtr;
+		ELEMENT *ElementPtr;
 
 		LockElement (hElement, &ElementPtr);
 		hNextElement = GetSuccElement (ElementPtr);
@@ -1253,7 +1497,7 @@ findPlayerShip(ELEMENT_FLAGS which) {
 		if ((ElementPtr->state_flags & PLAYER_SHIP)	&&
 				(ElementPtr->state_flags & (GOOD_GUY | BAD_GUY)) == which)
 		{
-			STARSHIPPTR StarShipPtr;
+			STARSHIP *StarShipPtr;
 			GetElementStarShip (ElementPtr, &StarShipPtr);
 			UnlockElement (hElement);
 			return StarShipPtr;
@@ -1268,7 +1512,7 @@ findPlayerShip(ELEMENT_FLAGS which) {
 
 void
 resetCrewBattle(void) {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	COUNT delta;
 	CONTEXT OldContext;
 	
@@ -1290,7 +1534,7 @@ resetCrewBattle(void) {
 
 void
 resetEnergyBattle(void) {
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	COUNT delta;
 	CONTEXT OldContext;
 	
@@ -1310,6 +1554,79 @@ resetEnergyBattle(void) {
 	SetContext (OldContext);
 }
 
+////////////////////////////////////////////////////////////////////////////
+
+// This function should help in making sure that gamestr.h matches
+// gamestrings.txt.
+void
+dumpStrings(FILE *out) {
+#define STRINGIZE(a) #a
+#define MAKE_STRING_CATEGORY(prefix) \
+		{ \
+			/* .name  = */ STRINGIZE(prefix ## _BASE), \
+			/* .base  = */ prefix ## _BASE, \
+			/* .count = */ prefix ## _COUNT \
+		}
+	struct {
+		const char *name;
+		size_t base;
+		size_t count;
+	} categories[] = {
+		{ "0", 0, 0 },
+		MAKE_STRING_CATEGORY(STAR_STRING),
+		MAKE_STRING_CATEGORY(DEVICE_STRING),
+		MAKE_STRING_CATEGORY(CARGO_STRING),
+		MAKE_STRING_CATEGORY(ELEMENTS_STRING),
+		MAKE_STRING_CATEGORY(SCAN_STRING),
+		MAKE_STRING_CATEGORY(STAR_NUMBER),
+		MAKE_STRING_CATEGORY(PLANET_NUMBER),
+		MAKE_STRING_CATEGORY(MONTHS_STRING),
+		MAKE_STRING_CATEGORY(FEEDBACK_STRING),
+		MAKE_STRING_CATEGORY(STARBASE_STRING),
+		MAKE_STRING_CATEGORY(ENCOUNTER_STRING),
+		MAKE_STRING_CATEGORY(NAVIGATION_STRING),
+		MAKE_STRING_CATEGORY(NAMING_STRING),
+		MAKE_STRING_CATEGORY(MELEE_STRING),
+		MAKE_STRING_CATEGORY(SAVEGAME_STRING),
+		MAKE_STRING_CATEGORY(OPTION_STRING),
+		MAKE_STRING_CATEGORY(QUITMENU_STRING),
+		MAKE_STRING_CATEGORY(STATUS_STRING),
+		MAKE_STRING_CATEGORY(FLAGSHIP_STRING),
+		MAKE_STRING_CATEGORY(ORBITSCAN_STRING),
+		MAKE_STRING_CATEGORY(MAINMENU_STRING),
+		MAKE_STRING_CATEGORY(NETMELEE_STRING),
+		{ "GAMESTR_COUNT", GAMESTR_COUNT, (size_t) -1 }
+	};
+	size_t numCategories = sizeof categories / sizeof categories[0];
+	size_t numStrings = GetStringTableCount (GameStrings);
+	size_t stringI;
+	size_t categoryI = 0;
+
+	// Start with a sanity check to see if gamestr.h has been changed but
+	// not this file.
+	for (categoryI = 0; categoryI < numCategories - 1; categoryI++) {
+		if (categories[categoryI].base + categories[categoryI].count !=
+				categories[categoryI + 1].base) {
+			fprintf(stderr, "Error: String category list in dumpStrings() is "
+					"not up to date.\n");
+			return;
+		}
+	}
+	
+	if (GAMESTR_COUNT != numStrings) {
+		fprintf(stderr, "Warning: GAMESTR_COUNT is %d, but GameStrings "
+				"contains %d strings.\n", GAMESTR_COUNT, numStrings);
+	}
+
+	categoryI = 0;
+	for (stringI = 0; stringI < numStrings; stringI++) {
+		while (categoryI < numCategories &&
+				stringI >= categories[categoryI + 1].base)
+			categoryI++;
+		fprintf(out, "[ %s + %d ]  %s\n", categories[categoryI].name,
+				stringI - categories[categoryI].base, GAME_STRING(stringI));
+	}
+}
 
 #endif  /* DEBUG */
 
diff -ruNp src.orig/sc2code/uqmdebug.h src/sc2code/uqmdebug.h
--- src.orig/sc2code/uqmdebug.h	2017-11-08 16:49:41 -0600
+++ src/sc2code/uqmdebug.h	2017-11-08 16:50:09 -0600
@@ -43,12 +43,17 @@ void forwardToNextEvent (BOOLEAN skipHEE
 // Generate a list of all events in the event queue.
 void dumpEvents (FILE *out);
 // Describe one event.
-void dumpEvent (FILE *out, EVENTPTR eventPtr);
+void dumpEvent (FILE *out, const EVENT *eventPtr);
 // Get the name of one event.
 const char *eventName (BYTE func_index);
 
 // Give the flagship a decent equipment for debugging.
 void equipShip (void);
+// Give the player all devices.
+void giveDevices (void);
+
+// Remove all escort ships.
+void clearEscorts (void);
 
 // Show all active spheres of influence.
 void showSpheres (void);
@@ -76,11 +81,20 @@ void forAllMoons (STAR_DESC *star, SOLAR
 // Argument to UniverseRecurse()
 typedef struct
 {
-	void (*systemFunc) (const STAR_DESC *star, const SOLARSYS_STATE *system,
-			void *arg);
-	void (*planetFunc) (const PLANET_DESC *planet, void *arg);
+	void (*systemFuncPre) (const STAR_DESC *star,
+			const SOLARSYS_STATE *system, void *arg);
+			// Called for each system prior to recursing to its planets.
+	void (*systemFuncPost) (const STAR_DESC *star,
+			const SOLARSYS_STATE *system, void *arg);
+			// Called for each system after recursing to its planets.
+	void (*planetFuncPre) (const PLANET_DESC *planet, void *arg);
+			// Called for each planet prior to recursing to its moons.
+	void (*planetFuncPost) (const PLANET_DESC *planet, void *arg);
+			// Called for each planet after recursing to its moons.
 	void (*moonFunc) (const PLANET_DESC *moon, void *arg);
+			// Called for each moon.
 	void *arg;
+			// User data.
 } UniverseRecurseArg;
 // Recurse through all systems, planets, and moons in the universe.
 void UniverseRecurse (UniverseRecurseArg *universeRecurseArg);
@@ -117,6 +131,12 @@ COUNT calculateBioValue (const SOLARSYS_
 void generateBioIndex(const SOLARSYS_STATE *system,
 		const PLANET_DESC *world, COUNT bio[]);
 
+// Tally the resources for each star system.
+void tallyResources (FILE *out);
+// Tally the resources for each star system, output to a file
+// "./ResourceTally".
+void tallyResourcesToFile (void);
+
 
 // Call a function for all planet types.
 void forAllPlanetTypes (void (*callBack) (int, const PlanetFrame *,
@@ -143,7 +163,7 @@ const char *depositQualityString (BYTE q
 
 
 // Find a player ship. Setting which to BAD_GUY is only meaningful in battle.
-STARSHIPPTR findPlayerShip(ELEMENT_FLAGS which);
+STARSHIP* findPlayerShip(ELEMENT_FLAGS which);
 
 // Resets the crew of the first player (the bottom one) to its maximum.
 void resetCrewBattle(void);
@@ -155,6 +175,11 @@ void resetEnergyBattle(void);
 // Move instantly across hyperspace/quasispace.
 extern BOOLEAN instantMove;
 
+
+// Dump all game strings.
+void dumpStrings(FILE *out);
+
+
 // To add some day:
 // - a function to fast forward the game clock to a specifiable time.
 
diff -ruNp src.orig/sc2code/util.c src/sc2code/util.c
--- src.orig/sc2code/util.c	2017-11-08 16:49:41 -0600
+++ src/sc2code/util.c	2017-11-08 16:50:09 -0600
@@ -27,7 +27,7 @@
 
 
 void
-DrawStarConBox (PRECT pRect, SIZE BorderWidth, COLOR TopLeftColor, COLOR
+DrawStarConBox (RECT *pRect, SIZE BorderWidth, COLOR TopLeftColor, COLOR
 		BottomRightColor, BOOLEAN FillInterior, COLOR InteriorColor)
 {
 	RECT locRect;
@@ -170,7 +170,7 @@ PauseGame (void)
 	OldContext = SetContext (ScreenContext);
 	OldHot = SetFrameHot (Screen, MAKE_HOT_SPOT (0, 0));
 	GetContextClipRect (&OldRect);
-	SetContextClipRect (NULL_PTR);
+	SetContextClipRect (NULL);
 
 	GetFrameRect (ActivityFrame, &r);
 	r.corner.x = (SCREEN_WIDTH - r.extent.width) >> 1;
@@ -189,13 +189,22 @@ PauseGame (void)
 	//LockMutex (GraphicsLock);
 
 	while (ImmediateInputState.menu[KEY_PAUSE])
+	{
+		BeginInputFrame ();
 		TaskSwitch ();
+	}
 
 	while (!ImmediateInputState.menu[KEY_PAUSE])
+	{
+		BeginInputFrame ();
 		TaskSwitch ();
+	}
 
 	while (ImmediateInputState.menu[KEY_PAUSE])
+	{
+		BeginInputFrame ();
 		TaskSwitch ();
+	}
 
 	GamePaused = FALSE;
 
diff -ruNp src.orig/sc2code/util.h src/sc2code/util.h
--- src.orig/sc2code/util.h	2017-11-08 16:49:41 -0600
+++ src/sc2code/util.h	2017-11-08 16:50:09 -0600
@@ -20,12 +20,10 @@
 #include "libs/compiler.h"
 #include "libs/gfxlib.h"
 
-extern void DrawStarConBox (PRECT pRect, SIZE BorderWidth,
+extern void DrawStarConBox (RECT *pRect, SIZE BorderWidth,
 		COLOR TopLeftColor, COLOR BottomRightColor, BOOLEAN FillInterior,
 		COLOR InteriorColor);
 extern DWORD SeedRandomNumbers (void);
 
-extern void MouseError (void);
-
 #endif  /* _UTIL_H */
 
diff -ruNp src.orig/sc2code/velocity.c src/sc2code/velocity.c
--- src.orig/sc2code/velocity.c	2017-11-08 16:49:41 -0600
+++ src/sc2code/velocity.c	2017-11-08 16:50:09 -0600
@@ -25,8 +25,7 @@
 #define VELOCITY_REMAINDER(v) ((v) & (VELOCITY_SCALE - 1))
 
 void
-GetCurrentVelocityComponents (VELOCITYPTR velocityptr, PSIZE pdx, PSIZE
-		pdy)
+GetCurrentVelocityComponents (VELOCITY_DESC *velocityptr, SIZE *pdx, SIZE *pdy)
 {
 	*pdx = WORLD_TO_VELOCITY (velocityptr->vector.width)
 			+ (velocityptr->fract.width - (SIZE)HIBYTE (velocityptr->incr.width));
@@ -35,7 +34,7 @@ GetCurrentVelocityComponents (VELOCITYPT
 }
 
 void
-GetNextVelocityComponents (VELOCITYPTR velocityptr, PSIZE pdx, PSIZE pdy,
+GetNextVelocityComponents (VELOCITY_DESC *velocityptr, SIZE *pdx, SIZE *pdy,
 		COUNT num_frames)
 {
 	COUNT e;
@@ -56,8 +55,7 @@ GetNextVelocityComponents (VELOCITYPTR v
 }
 
 void
-SetVelocityVector (VELOCITYPTR velocityptr, SIZE
-		magnitude, COUNT facing)
+SetVelocityVector (VELOCITY_DESC *velocityptr, SIZE magnitude, COUNT facing)
 {
 	COUNT angle;
 	SIZE dx, dy;
@@ -98,7 +96,7 @@ SetVelocityVector (VELOCITYPTR velocityp
 }
 
 void
-SetVelocityComponents (VELOCITYPTR velocityptr, SIZE dx, SIZE dy)
+SetVelocityComponents (VELOCITY_DESC *velocityptr, SIZE dx, SIZE dy)
 {
 	COUNT angle;
 
@@ -142,7 +140,7 @@ SetVelocityComponents (VELOCITYPTR veloc
 }
 
 void
-DeltaVelocityComponents (VELOCITYPTR velocityptr, SIZE dx, SIZE dy)
+DeltaVelocityComponents (VELOCITY_DESC *velocityptr, SIZE dx, SIZE dy)
 {
 
 	dx += WORLD_TO_VELOCITY (velocityptr->vector.width)
diff -ruNp src.orig/sc2code/velocity.h src/sc2code/velocity.h
--- src.orig/sc2code/velocity.h	2017-11-08 16:49:41 -0600
+++ src/sc2code/velocity.h	2017-11-08 16:50:09 -0600
@@ -30,21 +30,19 @@ typedef struct velocity_desc
 	EXTENT error;
 	EXTENT incr;
 } VELOCITY_DESC;
-typedef VELOCITY_DESC *PVELOCITY;
-typedef PVELOCITY VELOCITYPTR;
 
 #define ZeroVelocityComponents(pv) memset(pv,0,sizeof (*(pv)))
 #define GetVelocityTravelAngle(pv) (pv)->TravelAngle
 
-extern void GetCurrentVelocityComponents (VELOCITYPTR velocityptr, PSIZE
-		pdx, PSIZE pdy);
-extern void GetNextVelocityComponents (VELOCITYPTR velocityptr, PSIZE
-		pdx, PSIZE pdy, COUNT num_frames);
-extern void SetVelocityVector (VELOCITYPTR velocityptr, SIZE magnitude,
+extern void GetCurrentVelocityComponents (VELOCITY_DESC *velocityptr,
+		SIZE *pdx, SIZE *pdy);
+extern void GetNextVelocityComponents (VELOCITY_DESC *velocityptr,
+		SIZE *pdx, SIZE *pdy, COUNT num_frames);
+extern void SetVelocityVector (VELOCITY_DESC *velocityptr, SIZE magnitude,
 		COUNT facing);
-extern void SetVelocityComponents (VELOCITYPTR velocityptr, SIZE dx, SIZE
-		dy);
-extern void DeltaVelocityComponents (VELOCITYPTR velocityptr, SIZE dx,
+extern void SetVelocityComponents (VELOCITY_DESC *velocityptr, SIZE dx,
+		SIZE dy);
+extern void DeltaVelocityComponents (VELOCITY_DESC *velocityptr, SIZE dx,
 		SIZE dy);
 
 static inline DWORD
diff -ruNp src.orig/sc2code/weapon.c src/sc2code/weapon.c
--- src.orig/sc2code/weapon.c	2017-11-08 16:49:41 -0600
+++ src/sc2code/weapon.c	2017-11-08 16:50:09 -0600
@@ -32,7 +32,7 @@
 
 
 HELEMENT
-initialize_laser (PLASER_BLOCK pLaserBlock)
+initialize_laser (LASER_BLOCK *pLaserBlock)
 {
 	HELEMENT hLaserElement;
 
@@ -40,7 +40,7 @@ initialize_laser (PLASER_BLOCK pLaserBlo
 	if (hLaserElement)
 	{
 #define LASER_LIFE 1
-		ELEMENTPTR LaserElementPtr;
+		ELEMENT *LaserElementPtr;
 
 		LockElement (hLaserElement, &LaserElementPtr);
 		LaserElementPtr->hit_points = 1;
@@ -48,9 +48,7 @@ initialize_laser (PLASER_BLOCK pLaserBlo
 		LaserElementPtr->state_flags =
 				APPEARING | FINITE_LIFE | pLaserBlock->sender;
 		LaserElementPtr->life_span = LASER_LIFE;
-		LaserElementPtr->collision_func =
-				(void (*) (struct element *ElementPtr0, PPOINT pPt0,
-				struct element *ElementPtr1, PPOINT pPt1)) weapon_collision;
+		LaserElementPtr->collision_func = (CollisionFunc*)weapon_collision;
 		LaserElementPtr->blast_offset = 1;
 
 		LaserElementPtr->current.location.x = pLaserBlock->cx
@@ -76,7 +74,7 @@ initialize_laser (PLASER_BLOCK pLaserBlo
 }
 
 HELEMENT
-initialize_missile (PMISSILE_BLOCK pMissileBlock)
+initialize_missile (MISSILE_BLOCK *pMissileBlock)
 {
 	HELEMENT hMissileElement;
 
@@ -85,7 +83,7 @@ initialize_missile (PMISSILE_BLOCK pMiss
 	{
 		SIZE delta_x, delta_y;
 		COUNT angle;
-		ELEMENTPTR MissileElementPtr;
+		ELEMENT *MissileElementPtr;
 
 		LockElement (hMissileElement, &MissileElementPtr);
 		MissileElementPtr->hit_points = (BYTE)pMissileBlock->hit_points;
@@ -99,9 +97,7 @@ initialize_missile (PMISSILE_BLOCK pMiss
 				SetAbsFrameIndex (pMissileBlock->farray[0],
 				pMissileBlock->index);
 		MissileElementPtr->preprocess_func = pMissileBlock->preprocess_func;
-		MissileElementPtr->collision_func =
-				(void (*) (struct element *ElementPtr0, PPOINT pPt0,
-				struct element *ElementPtr1, PPOINT pPt1)) weapon_collision;
+		MissileElementPtr->collision_func = (CollisionFunc*)weapon_collision;
 		MissileElementPtr->blast_offset = (BYTE)pMissileBlock->blast_offs;
 
 		angle = FACING_TO_ANGLE (pMissileBlock->face);
@@ -124,8 +120,8 @@ initialize_missile (PMISSILE_BLOCK pMiss
 }
 
 HELEMENT
-weapon_collision (PELEMENT WeaponElementPtr, PPOINT pWPt,
-		PELEMENT HitElementPtr, PPOINT pHPt)
+weapon_collision (ELEMENT *WeaponElementPtr, POINT *pWPt,
+		ELEMENT *HitElementPtr, POINT *pHPt)
 {
 	SIZE damage;
 	HELEMENT hBlastElement;
@@ -146,7 +142,7 @@ weapon_collision (PELEMENT WeaponElement
 			(WeaponElementPtr->state_flags & (GOOD_GUY | BAD_GUY))))
 #endif /* NEVER */
 	{
-		do_damage ((ELEMENTPTR)HitElementPtr, damage);
+		do_damage (HitElementPtr, damage);
 		if (HitElementPtr->hit_points)
 			WeaponElementPtr->state_flags |= COLLISION;
 	}
@@ -179,7 +175,7 @@ weapon_collision (PELEMENT WeaponElement
 			COUNT blast_index;
 			SIZE blast_offs;
 			COUNT angle, num_blast_frames;
-			ELEMENTPTR BlastElementPtr;
+			ELEMENT *BlastElementPtr;
 			extern FRAME blast[];
 
 			PutElement (hBlastElement);
@@ -239,13 +235,13 @@ weapon_collision (PELEMENT WeaponElement
 }
 
 FRAME
-ModifySilhouette (ELEMENTPTR ElementPtr, PSTAMP modify_stamp,
+ModifySilhouette (ELEMENT *ElementPtr, STAMP *modify_stamp,
 		BYTE modify_flags)
 {
 	FRAME f;
 	RECT r, or;
 	INTERSECT_CONTROL ShipIntersect, ObjectIntersect;
-	STARSHIPPTR StarShipPtr;
+	STARSHIP *StarShipPtr;
 	CONTEXT OldContext;
 
 	f = 0;
@@ -255,7 +251,8 @@ ModifySilhouette (ELEMENTPTR ElementPtr,
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (modify_flags & MODIFY_IMAGE)
 	{
-		ShipIntersect.IntersectStamp.frame = StarShipPtr->silhouette;
+		ShipIntersect.IntersectStamp.frame = SetAbsFrameIndex (
+				StarShipPtr->RaceDescPtr->ship_info.icons, 1);
 		if (ShipIntersect.IntersectStamp.frame == 0)
 			return (0);
 
@@ -288,7 +285,8 @@ ModifySilhouette (ELEMENTPTR ElementPtr,
 	{
 		or.corner.x += ObjectIntersect.IntersectStamp.origin.x;
 		or.corner.y += ObjectIntersect.IntersectStamp.origin.y;
-		InitShipStatus (StarShipPtr, &or);
+		InitShipStatus (&StarShipPtr->RaceDescPtr->ship_info,
+				StarShipPtr->captains_name_index, &or);
 	}
 	else
 	{
@@ -308,11 +306,11 @@ ModifySilhouette (ELEMENTPTR ElementPtr,
 // Cloaked ships won't be detected, except when the APPEARING flag is
 // set for the Tracker.
 SIZE
-TrackShip (ELEMENTPTR Tracker, PCOUNT pfacing)
+TrackShip (ELEMENT *Tracker, COUNT *pfacing)
 {
 	SIZE best_delta_facing, best_delta;
 	HELEMENT hShip, hNextShip;
-	ELEMENTPTR Trackee;
+	ELEMENT *Trackee;
 
 	best_delta = 0;
 	best_delta_facing = -1;
@@ -338,7 +336,7 @@ TrackShip (ELEMENTPTR Tracker, PCOUNT pf
 				&& (Tracker->state_flags & APPEARING))
 				))
 		{
-			STARSHIPPTR StarShipPtr;
+			STARSHIP *StarShipPtr;
 
 CheckTracking:
 			GetElementStarShip (Trackee, &StarShipPtr);
diff -ruNp src.orig/sc2code/weapon.h src/sc2code/weapon.h
--- src.orig/sc2code/weapon.h	2017-11-08 16:49:41 -0600
+++ src/sc2code/weapon.h	2017-11-08 16:50:09 -0600
@@ -30,7 +30,6 @@ typedef struct
 	COUNT face;
 	COLOR color;
 } LASER_BLOCK;
-typedef LASER_BLOCK *PLASER_BLOCK;
 
 typedef struct
 {
@@ -38,24 +37,23 @@ typedef struct
 	ELEMENT_FLAGS sender;
 	SIZE pixoffs, speed, hit_points, damage;
 	COUNT face, index, life;
-	PFRAME farray;
-	void (*preprocess_func) (PELEMENT ElementPtr);
+	FRAME *farray;
+	void (*preprocess_func) (ELEMENT *ElementPtr);
 	SIZE blast_offs;
 } MISSILE_BLOCK;
-typedef MISSILE_BLOCK *PMISSILE_BLOCK;
 
-extern HELEMENT initialize_laser (PLASER_BLOCK pLaserBlock);
-extern HELEMENT initialize_missile (PMISSILE_BLOCK pMissileBlock);
-extern HELEMENT weapon_collision (PELEMENT ElementPtr0, PPOINT pPt0,
-		PELEMENT ElementPtr1, PPOINT pPt1);
-extern SIZE TrackShip (ELEMENTPTR Tracker, PCOUNT pfacing);
-extern void Untarget (ELEMENTPTR ElementPtr);
+extern HELEMENT initialize_laser (LASER_BLOCK *pLaserBlock);
+extern HELEMENT initialize_missile (MISSILE_BLOCK *pMissileBlock);
+extern HELEMENT weapon_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1);
+extern SIZE TrackShip (ELEMENT *Tracker, COUNT *pfacing);
+extern void Untarget (ELEMENT *ElementPtr);
 
 #define MODIFY_IMAGE (1 << 0)
 #define MODIFY_SWAP (1 << 1)
 
-extern FRAME ModifySilhouette (ELEMENTPTR ElementPtr, PSTAMP
-		modify_stamp, BYTE modify_flags);
+extern FRAME ModifySilhouette (ELEMENT *ElementPtr, STAMP *modify_stamp,
+		BYTE modify_flags);
 
 #endif /* _WEAPON_H */
 
diff -ruNp src.orig/starcon2.c src/starcon2.c
--- src.orig/starcon2.c	2017-11-08 16:49:41 -0600
+++ src/starcon2.c	2017-11-08 16:50:09 -0600
@@ -31,8 +31,11 @@
 #include "libs/input/input_common.h"
 #include "libs/tasklib.h"
 #include "controls.h"
+#include "element.h"
+		// For BATTLE_FRAME_RATE
 #include "file.h"
 #include "port.h"
+#include "libs/memlib.h"
 #include "libs/platform.h"
 #include "libs/log.h"
 #include "options.h"
@@ -67,13 +70,16 @@ struct options_struct {
 	int soundFlags;
 	int width;
 	int height;
+	BOOLEAN keepAspectRatio;
 	const char *configDir;
 	const char *contentDir;
 	const char **addons;
+	const char *addonDir;
 	int numAddons;
 	int gammaSet;
 	float gamma;
-	int whichMusic;
+	BOOLEAN use3doMusic;
+	BOOLEAN usePrecursorsMusic;
 	int whichCoarseScan;
 	int whichMenu;
 	int whichFonts;
@@ -98,6 +104,7 @@ static int parseIntOption (const char *s
 static int parseFloatOption (const char *str, float *f,
 		const char *optName);
 static int parseVolume (const char *str, float *vol, const char *optName);
+static int parseGamma (const char *str, float *gamma, const char *optName);
 static int InvalidArgument (const char *supplied, const char *opt_name);
 static int Check_PC_3DO_opt (const char *value, DWORD mask, const char *opt,
 		int *result);
@@ -115,17 +122,20 @@ main (int argc, char *argv[])
 		/* .soundFlags = */         audio_QUALITY_MEDIUM,
 		/* .width = */              640,
 		/* .height = */             480,
+		/* .keepAspectRatio = */    FALSE,
 		/* .configDir = */          NULL,
 		/* .contentDir = */         NULL,
 		/* .addons = */             NULL,
+		/* .addonDir = */           NULL,
 		/* .numAddons = */          0,
 		/* .gammaSet = */           0,
 		/* .gamma = */              0.0f,
-		/* .whichMusic = */         OPT_3DO,
+		/* .use3doMusic = */        TRUE,
+		/* .usePrecursorsMusic = */ FALSE,
 		/* .whichCoarseScan = */    OPT_PC,
 		/* .whichMenu = */          OPT_PC,
 		/* .whichFont = */          OPT_PC,
-		/* .whichIntro = */         OPT_3DO,
+		/* .whichIntro = */         OPT_PC,
 		/* .whichShield	= */        OPT_PC,
 		/* .smoothScroll = */       OPT_PC,
 		/* .meleeScale = */         TFB_SCALE_TRILINEAR,
@@ -150,6 +160,9 @@ main (int argc, char *argv[])
 	{
 		int i;
 		freopen (options.logFile, "w", stderr);
+#ifdef UNBUFFERED_LOGFILE
+		setbuf (stderr, NULL);
+#endif
 		for (i = 0; i < argc; ++i)
 			log_add (log_User, "argv[%d] = [%s]", i, argv[i]);
 	}
@@ -169,8 +182,8 @@ main (int argc, char *argv[])
 			UQM_PATCH_VERSION, UQM_EXTRA_VERSION,
 			__DATE__, __TIME__);
 #ifdef NETPLAY
-	log_add (log_User, "Netplay protocol version %d.%d. Requiring remote "
-			"UQM version %d.%d.%d.",
+	log_add (log_User, "Netplay protocol version %d.%d. Minimum required "
+			"remote UQM version is %d.%d.%d.",
 			NETPLAY_PROTOCOL_VERSION_MAJOR, NETPLAY_PROTOCOL_VERSION_MINOR,
 			NETPLAY_MIN_UQM_VERSION_MAJOR, NETPLAY_MIN_UQM_VERSION_MINOR,
 			NETPLAY_MIN_UQM_VERSION_PATCH);
@@ -194,8 +207,8 @@ main (int argc, char *argv[])
 	initIO ();
 	prepareConfigDir (options.configDir);
 
-	PlayerOne = CONTROL_TEMPLATE_KB_1;
-	PlayerTwo = CONTROL_TEMPLATE_JOY_1;
+	PlayerControls[0] = CONTROL_TEMPLATE_KB_1;
+	PlayerControls[1] = CONTROL_TEMPLATE_JOY_1;
 
 	// Fill in the options struct based on uqm.cfg
 	res_LoadFilename (configDir, "uqm.cfg");
@@ -207,6 +220,10 @@ main (int argc, char *argv[])
 	{
 		options.height = res_GetInteger ("config.resheight");
 	}
+	if (res_HasKey("config.keepaspectratio"))
+	{
+		options.keepAspectRatio = res_GetBoolean ("config.keepaspectratio");
+	}
 	if (res_HasKey ("config.alwaysgl"))
 	{
 		if (res_GetBoolean ("config.alwaysgl"))
@@ -221,17 +238,17 @@ main (int argc, char *argv[])
 	}
 	if (res_HasKey ("config.scaler"))
 	{
-		const char *optarg = res_GetString ("config.scaler");
+		const char *arg = res_GetString ("config.scaler");
 
-		if (!strcmp (optarg, "bilinear"))
+		if (!strcmp (arg, "bilinear"))
 			options.gfxFlags |= TFB_GFXFLAGS_SCALE_BILINEAR;
-		else if (!strcmp (optarg, "biadapt"))
+		else if (!strcmp (arg, "biadapt"))
 			options.gfxFlags |= TFB_GFXFLAGS_SCALE_BIADAPT;
-		else if (!strcmp (optarg, "biadv"))
+		else if (!strcmp (arg, "biadv"))
 			options.gfxFlags |= TFB_GFXFLAGS_SCALE_BIADAPTADV;
-		else if (!strcmp (optarg, "triscan"))
+		else if (!strcmp (arg, "triscan"))
 			options.gfxFlags |= TFB_GFXFLAGS_SCALE_TRISCAN;
-		else if (!strcmp (optarg, "hq"))
+		else if (!strcmp (arg, "hq"))
 			options.gfxFlags |= TFB_GFXFLAGS_SCALE_HQXX;	
 	}
 	if (res_HasKey ("config.scanlines") && res_GetBoolean ("config.scanlines"))
@@ -264,7 +281,11 @@ main (int argc, char *argv[])
 	}
 	if (res_HasKey ("config.3domusic"))
 	{
-		options.whichMusic = res_GetBoolean ("config.3domusic") ? OPT_3DO : OPT_PC;
+		options.use3doMusic = res_GetBoolean ("config.3domusic");
+	}
+	if (res_HasKey ("config.remixmusic"))
+	{
+		options.usePrecursorsMusic = res_GetBoolean ("config.remixmusic");
 	}
 	if (res_HasKey ("config.3domovies"))
 	{
@@ -331,26 +352,29 @@ main (int argc, char *argv[])
 	}
 	if (res_HasKey ("config.pulseshield"))
 	{
-		options.whichShield = res_GetBoolean ("config.pulseshield") ? OPT_3DO : OPT_PC;
+		options.whichShield =
+				res_GetBoolean ("config.pulseshield") ? OPT_3DO : OPT_PC;
 	}
 	if (res_HasKey ("config.player1control"))
 	{
-		PlayerOne = res_GetInteger ("config.player1control");
+		PlayerControls[0] = res_GetInteger ("config.player1control");
 		/* This is an unsigned, so no < 0 check is necessary */
-		if (PlayerOne >= NUM_TEMPLATES)
+		if (PlayerControls[0] >= NUM_TEMPLATES)
 		{
-			log_add (log_Error, "Illegal control template '%d' for Player One.", PlayerOne);
-			PlayerOne = CONTROL_TEMPLATE_KB_1;
+			log_add (log_Error, "Illegal control template '%d' for Player "
+					"One.", PlayerControls[0]);
+			PlayerControls[0] = CONTROL_TEMPLATE_KB_1;
 		}
 	}
 	if (res_HasKey ("config.player2control"))
 	{
 		/* This is an unsigned, so no < 0 check is necessary */
-		PlayerTwo = res_GetInteger ("config.player2control");
-		if (PlayerTwo >= NUM_TEMPLATES)
+		PlayerControls[1] = res_GetInteger ("config.player2control");
+		if (PlayerControls[1] >= NUM_TEMPLATES)
 		{
-			log_add (log_Error, "Illegal control template '%d' for Player Two.", PlayerTwo);
-			PlayerTwo = CONTROL_TEMPLATE_JOY_1;
+			log_add (log_Error, "Illegal control template '%d' for Player "
+					"Two.", PlayerControls[1]);
+			PlayerControls[1] = CONTROL_TEMPLATE_JOY_1;
 		}
 	}
 	if (res_HasKey ("config.musicvol"))
@@ -368,13 +392,13 @@ main (int argc, char *argv[])
 		parseVolume (res_GetString ("config.speechvol"), 
 				&options.speechVolumeScale, "speech volume");
 	}		
+	if (res_HasKey ("config.gamma"))
+	{
+		parseGamma (res_GetString ("config.gamma"), 
+				&options.gamma, "gamma correction");
+	}		
 
-	{	/* init control template names */
-		static const char* defaultNames[] =
-		{
-			"Arrows", "WASD", "Arrows (2)",
-			"ESDF", "Joystick 1", "Joystick 2"
-		};
+	{	/* remove old control template names */
 		int i;
 
 		for (i = 0; i < 6; ++i)
@@ -384,16 +408,7 @@ main (int argc, char *argv[])
 			snprintf(cfgkey, sizeof(cfgkey), "config.keys.%d.name", i + 1);
 			cfgkey[sizeof(cfgkey) - 1] = '\0';
 
-			if (res_HasKey (cfgkey))
-			{
-				strncpy (input_templates[i].name, res_GetString (cfgkey), 30);
-				input_templates[i].name[29] = 0;
-			}
-			else
-			{
-				strcpy (input_templates[i].name, defaultNames[i]);
-				res_PutString (cfgkey, input_templates[i].name);
-			}
+			res_Remove (cfgkey);
 		}
 	}
 
@@ -404,7 +419,6 @@ main (int argc, char *argv[])
 		return optionsResult;
 	}
 
-
 	/* TODO: Once threading is gone, these become local variables
 	   again.  In the meantime, they must be global so that
 	   initAudio (in StarCon2Main) can see them.  initAudio needed
@@ -414,7 +428,8 @@ main (int argc, char *argv[])
 	soundflags = options.soundFlags;
 
 	// Fill in global variables:
-	optWhichMusic = options.whichMusic;
+	opt3doMusic = options.use3doMusic;
+	optPrecursorsMusic = options.usePrecursorsMusic;
 	optWhichCoarseScan = options.whichCoarseScan;
 	optWhichMenu = options.whichMenu;
 	optWhichFonts = options.whichFonts;
@@ -422,17 +437,21 @@ main (int argc, char *argv[])
 	optWhichShield = options.whichShield;
 	optSmoothScroll = options.smoothScroll;
 	optMeleeScale = options.meleeScale;
+	optKeepAspectRatio = options.keepAspectRatio;
 	optSubtitles = options.subTitles;
 	optStereoSFX = options.stereoSFX;
 	musicVolumeScale = options.musicVolumeScale;
 	sfxVolumeScale = options.sfxVolumeScale;
 	speechVolumeScale = options.speechVolumeScale;
+	gammaCorrection = (options.gammaSet) ? options.gamma : 1.0f;
+	optAddons = options.addons;
 
-	prepareContentDir (options.contentDir, options.addons);
-	HFree ((void *) options.addons);
+	prepareContentDir (options.contentDir, options.addonDir, argv[0]);
 	prepareMeleeDir ();
 	prepareSaveDir ();
+#if 0
 	initTempDir ();
+#endif
 
 	InitTimeSystem ();
 	InitTaskSystem ();
@@ -468,7 +487,9 @@ main (int argc, char *argv[])
 		TFB_FlushGraphics ();
 	}
 
+#if 0
 	unInitTempDir ();
+#endif
 	uninitIO ();
 
 #ifdef NETPLAY
@@ -488,6 +509,7 @@ enum
 	SOUND_OPT,
 	STEREOSFX_OPT,
 	ADDON_OPT,
+	ADDONDIR_OPT,
 	ACCEL_OPT,
 #ifdef NETPLAY
 	NETHOST1_OPT,
@@ -498,7 +520,7 @@ enum
 #endif
 };
 
-static const char *optString = "+r:d:foc:b:spC:n:?hM:S:T:m:q:ug:l:i:v";
+static const char *optString = "+r:d:foc:b:spC:n:?hM:S:T:m:q:ug:l:i:vwxk";
 static struct option longOptions[] = 
 {
 	{"res", 1, NULL, 'r'},
@@ -516,11 +538,13 @@ static struct option longOptions[] =
 	{"speechvol", 1, NULL, 'T'},
 	{"audioquality", 1, NULL, 'q'},
 	{"nosubtitles", 0, NULL, 'u'},
-	{"music", 1, NULL, 'm'},
 	{"gamma", 1, NULL, 'g'},
 	{"logfile", 1, NULL, 'l'},
 	{"intro", 1, NULL, 'i'},
 	{"version", 0, NULL, 'v'},
+	{"windowed", 0, NULL, 'w'},
+	{"nogl", 0, NULL, 'x'},
+	{"keepaspectratio", 0, NULL, 'k'},
 
 	//  options with no short equivalent:
 	{"cscan", 1, NULL, CSCAN_OPT},
@@ -531,6 +555,7 @@ static struct option longOptions[] =
 	{"sound", 1, NULL, SOUND_OPT},
 	{"stereosfx", 0, NULL, STEREOSFX_OPT},
 	{"addon", 1, NULL, ADDON_OPT},
+	{"addondir", 1, NULL, ADDONDIR_OPT},
 	{"accel", 1, NULL, ACCEL_OPT},
 #ifdef NETPLAY
 	{"nethost1", 1, NULL, NETHOST1_OPT},
@@ -624,9 +649,18 @@ parseOptions (int argc, char *argv[], st
 			case 'f':
 				options->gfxFlags |= TFB_GFXFLAGS_FULLSCREEN;
 				break;
+			case 'w':
+				options->gfxFlags &= ~TFB_GFXFLAGS_FULLSCREEN;
+				break;
 			case 'o':
 				options->gfxDriver = TFB_GFXDRIVER_SDL_OPENGL;
 				break;
+			case 'x':
+				options->gfxDriver = TFB_GFXDRIVER_SDL_PURE;
+				break;
+			case 'k':
+				options->keepAspectRatio = TRUE;
+				break;
 			case 'c':
 				// make sure whatever was set by saved config is cleared
 				options->gfxFlags &= ~TFB_GFXFLAGS_SCALE_ANY;
@@ -651,6 +685,8 @@ parseOptions (int argc, char *argv[], st
 					options->meleeScale = TFB_SCALE_TRILINEAR;
 				else if (!strcmp (optarg, "step") || !strcmp (optarg, "pc"))
 					options->meleeScale = TFB_SCALE_STEP;
+				else if (!strcmp (optarg, "bilinear"))
+					options->meleeScale = TFB_SCALE_BILINEAR;
 				else
 				{
 					InvalidArgument (optarg, "--meleezoom or -b");
@@ -718,14 +754,6 @@ parseOptions (int argc, char *argv[], st
 			case 'u':
 				options->subTitles = FALSE;
 				break;
-			case 'm':
-			{
-				if (Check_PC_3DO_opt (optarg, OPT_PC | OPT_3DO,
-						optionIndex >= 0 ? longOptions[optionIndex].name : "m",
-						&options->whichMusic) == -1)
-					badArg = TRUE;
-				break;
-			}
 			case 'g':
 			{
 				int result = parseFloatOption (optarg, &options->gamma,
@@ -805,6 +833,9 @@ parseOptions (int argc, char *argv[], st
 				options->addons[options->numAddons - 1] = optarg;
 				options->addons[options->numAddons] = NULL;
 				break;
+			case ADDONDIR_OPT:
+				options->addonDir = optarg;
+				break;
 			case ACCEL_OPT:
 				force_platform = PLATFORM_NULL;
 				if (!strcmp (optarg, "mmx"))
@@ -838,12 +869,14 @@ parseOptions (int argc, char *argv[], st
 				break;
 			case NETDELAY_OPT:
 			{
-				if (parseIntOption (optarg, &netplayOptions.inputDelay,
-						"network input delay") == -1)
+				int temp;
+				if (parseIntOption (optarg, &temp, "network input delay")
+						== -1)
 				{
 					badArg = TRUE;
 					break;
 				}
+				netplayOptions.inputDelay = temp;
 
 				if (netplayOptions.inputDelay > 60 * BATTLE_FRAME_RATE)
 				{
@@ -914,6 +947,41 @@ parseVolume (const char *str, float *vol
 }
 
 static int
+parseGamma (const char *str, float *gamma, const char *optName)
+{
+	char *endPtr;
+	int intGamma;
+
+	if (str[0] == '\0')
+	{
+		log_add (log_Error, "Error: Invalid value for '%s'.", optName);
+		return -1;
+	}
+	intGamma = (int) strtol (str, &endPtr, 10);
+	if (*endPtr != '\0')
+	{
+		log_add (log_Error, "Error: Junk characters in gamma specified "
+				"for '%s'.", optName);
+		return -1;
+	}
+
+	if (intGamma <= 0)
+	{
+		*gamma = 0.05f;
+		return 0;
+	}
+
+	if (intGamma > 100)
+	{
+		*gamma = 2.0f;
+		return 0;
+	}
+
+	*gamma = intGamma / 50.0f;
+	return 0;
+}
+
+static int
 parseIntOption (const char *str, int *result, const char *optName)
 {
 	char *endPtr;
@@ -969,7 +1037,10 @@ usage (FILE *out, const struct options_s
 	log_add (log_User, "  -r, --res=WIDTHxHEIGHT (default 640x480, bigger "
 			"works only with --opengl)");
 	log_add (log_User, "  -f, --fullscreen (default off)");
+	log_add (log_User, "  -w, --windowed (default on)");
 	log_add (log_User, "  -o, --opengl (default off)");
+	log_add (log_User, "  -x, --nogl (default on)");
+	log_add (log_User, "  -k, --keepaspectratio (default off)");
 	log_add (log_User, "  -c, --scale=MODE (bilinear, biadapt, biadv, triscan, "
 			"hq or none (default) )");
 	log_add (log_User, "  -b, --meleezoom=MODE (step, aka pc, or smooth, aka 3do; "
@@ -990,6 +1061,7 @@ usage (FILE *out, const struct options_s
 			"FILE)");
 	log_add (log_User, "  --addon ADDON (using a specific addon; "
 			"may be specified multiple times)");
+	log_add (log_User, "  --addondir=ADDONDIR (directory where addons reside)");
 	log_add (log_User, "  --sound=DRIVER (openal, mixsdl, none; default "
 			"mixsdl)");
 	log_add (log_User, "  --stereosfx (enables positional sound effects, "
@@ -1004,8 +1076,6 @@ usage (FILE *out, const struct options_s
 #endif
 	log_add (log_User, "The following options can take either '3do' or 'pc' "
 			"as an option:");
-	log_add (log_User, "  -m, --music : Music version (default %s)",
-			PC_3DO_optString (defaultOptions->whichMusic));
 	log_add (log_User, "  -i, --intro : Intro/ending version (default %s)",
 			PC_3DO_optString (defaultOptions->whichIntro));
 	log_add (log_User, "  --cscan     : coarse-scan display, pc=text, "
diff -ruNp src.orig/symbian/bld.inf src/symbian/bld.inf
--- src.orig/symbian/bld.inf	1969-12-31 18:00:00 -0600
+++ src/symbian/bld.inf	2017-11-08 16:50:09 -0600
@@ -0,0 +1,9 @@
+PRJ_PLATFORMS
+
+
+PRJ_EXPORTS
+
+
+PRJ_MMPFILES
+gnumakefile icons_scalable_dc.mk
+uqm.mmp
diff -ruNp src.orig/symbian/config.h src/symbian/config.h
--- src.orig/symbian/config.h	1969-12-31 18:00:00 -0600
+++ src/symbian/config.h	2017-11-08 16:50:09 -0600
@@ -0,0 +1,57 @@
+/* This file contains some compile-time configuration options for Symbian
+ */
+
+#ifndef _CONFIG_H
+#define _CONFIG_H
+
+/* Directory where the UQM game data is located */
+#define CONTENTDIR "content"
+
+/* Directory where game data will be stored */
+#define USERDIR "userdata"
+
+/* Directory where config files will be stored */
+#define CONFIGDIR USERDIR
+
+/* Directory where supermelee teams will be stored */
+#define MELEEDIR "userdata\\teams\\"
+
+/* Directory where save games will be stored */
+#define SAVEDIR "userdata\\save\\"
+
+/* Define if words are stored with the most significant byte first */
+#undef WORDS_BIGENDIAN
+
+/* Defined if your system has readdir_r of its own */
+#undef HAVE_READDIR_R
+
+/* Defined if your system has setenv of its own */
+#define HAVE_SETENV
+
+/* Defined if your system has strupr of its own */
+#undef HAVE_STRUPR
+
+/* Defined if your system has strcasecmp of its own */
+#define HAVE_STRCASECMP_UQM
+		// Not using "HAVE_STRCASECMP" as that conflicts with SDL.
+
+/* Defined if your system has stricmp of its own */
+#undef HAVE_STRICMP
+
+/* Defined if your system has getopt_long */
+#undef HAVE_GETOPT_LONG
+
+/* Defined if your system has iswgraph of its own*/
+#define HAVE_ISWGRAPH
+
+/* Defined if your system has wchar_t of its own */
+#define HAVE_WCHAR_T
+
+/* Defined if your system has wint_t of its own */
+#define HAVE_WINT_T
+
+#define HAVE__BOOL
+
+#define PATH_MAX _POSIX_PATH_MAX
+
+#endif /* _CONFIG_H */
diff -ruNp src.orig/symbian/icons_scalable_dc.mk src/symbian/icons_scalable_dc.mk
--- src.orig/symbian/icons_scalable_dc.mk	1969-12-31 18:00:00 -0600
+++ src/symbian/icons_scalable_dc.mk	2017-11-08 16:50:09 -0600
@@ -0,0 +1,37 @@
+ifeq (WINS,$(findstring WINS, $(PLATFORM)))
+ZDIR=$(EPOCROOT)epoc32\release\$(PLATFORM)\$(CFG)\Z
+else
+ZDIR=$(EPOCROOT)epoc32\data\z
+endif
+
+TARGETDIR=$(ZDIR)\resource\apps
+ICONTARGETFILENAME=$(TARGETDIR)\uqm_icon.mif
+
+ICONDIR=
+
+do_nothing :
+	@rem do_nothing
+
+MAKMAKE : do_nothing
+
+BLD : do_nothing
+
+CLEAN : do_nothing
+
+LIB : do_nothing
+
+CLEANLIB : do_nothing
+
+RESOURCE :	
+	mifconv $(ICONTARGETFILENAME) \
+		/c32 uqm.svg
+		
+FREEZE : do_nothing
+
+SAVESPACE : do_nothing
+
+RELEASABLES :
+	@echo $(ICONTARGETFILENAME)
+
+FINAL : do_nothing
+
diff -ruNp src.orig/symbian/uqm-armv5.pkg src/symbian/uqm-armv5.pkg
--- src.orig/symbian/uqm-armv5.pkg	1969-12-31 18:00:00 -0600
+++ src/symbian/uqm-armv5.pkg	2017-11-08 16:50:09 -0600
@@ -0,0 +1,26 @@
+;Language - standard language definitions
+&EN
+
+; standard SIS file header
+#{"Ur-Quan Masters"},(0xA000A0C3),1,0,0
+
+;Localised Vendor name
+%{"Interstellar Frungy League"}
+
+;Unique Vendor name
+:"Interstellar Frungy League"
+
+;Supports Series 60 v 3.0
+[0x101F7961], 0, 0, 0, {"Series60ProductID"}
+
+*"uqm.key", "uqm.cer"
+
+;Files to install
+;<source> <destination>
+"\Epoc32\release\Armv5\urel\uqm.exe" - "!:\sys\bin\uqm.exe"
+"\Epoc32\data\z\resource\apps\uqm.rsc" - "!:\resource\apps\uqm.rsc"
+"\Epoc32\data\z\resource\apps\uqm_icon.mif" - "!:\resource\apps\uqm_icon.mif"
+"\Epoc32\data\z\private\10003a3f\import\apps\uqm_reg.rsc" - "!:\private\10003a3f\import\apps\uqm_reg.rsc"
+"uqm.cfg" - "!:\private\A000A0C3\userdata\uqm.cfg"
+"..\..\content\version" - "!:\private\A000A0C3\content\version"
+"..\..\content.uqm" - "!:\private\A000A0C3\content\packages\content.uqm"
diff -ruNp src.orig/symbian/uqm-gcce.pkg src/symbian/uqm-gcce.pkg
--- src.orig/symbian/uqm-gcce.pkg	1969-12-31 18:00:00 -0600
+++ src/symbian/uqm-gcce.pkg	2017-11-08 16:50:09 -0600
@@ -0,0 +1,26 @@
+;Language - standard language definitions
+&EN
+
+; standard SIS file header
+#{"Ur-Quan Masters"},(0xA000A0C3),1,0,0
+
+;Localised Vendor name
+%{"Interstellar Frungy League"}
+
+;Unique Vendor name
+:"Interstellar Frungy League"
+
+;Supports Series 60 v 3.0
+[0x101F7961], 0, 0, 0, {"Series60ProductID"}
+
+*"uqm.key", "uqm.cer"
+
+;Files to install
+;<source> <destination>
+"\Epoc32\release\gcce\urel\uqm.exe" - "!:\sys\bin\uqm.exe"
+"\Epoc32\data\z\resource\apps\uqm.rsc" - "!:\resource\apps\uqm.rsc"
+"\Epoc32\data\z\resource\apps\uqm_icon.mif" - "!:\resource\apps\uqm_icon.mif"
+"\Epoc32\data\z\private\10003a3f\import\apps\uqm_reg.rsc" - "!:\private\10003a3f\import\apps\uqm_reg.rsc"
+"uqm.cfg" - "!:\private\A000A0C3\userdata\uqm.cfg"
+"..\..\content\version" - "!:\private\A000A0C3\content\version"
+"..\..\content.uqm" - "!:\private\A000A0C3\content\packages\content.uqm"
diff -ruNp src.orig/symbian/uqm.cfg src/symbian/uqm.cfg
--- src.orig/symbian/uqm.cfg	1969-12-31 18:00:00 -0600
+++ src/symbian/uqm.cfg	2017-11-08 16:50:09 -0600
@@ -0,0 +1,26 @@
+config.textmenu = yes
+config.alwaysgl = no
+config.sfxvol = 20
+config.iconicscan = no
+config.pulseshield = no
+config.3domusic = yes
+config.smoothmelee = no
+config.positionalsfx = no
+config.resheight = 240
+config.musicvol = 20
+config.textgradients = yes
+config.reswidth = 320
+config.scaler = no
+config.audiodriver = mixsdl
+config.fullscreen = no
+config.usegl = no
+config.player2control = 3
+config.player1control = 0
+config.subtitles = yes
+config.3domovies = yes
+config.scanlines = no
+config.showfps = no
+config.speechvol = 20
+config.remixmusic = no
+config.smoothscroll = no
+config.audioquality = low
diff -ruNp src.orig/symbian/uqm.mmp src/symbian/uqm.mmp
--- src.orig/symbian/uqm.mmp	1969-12-31 18:00:00 -0600
+++ src/symbian/uqm.mmp	2017-11-08 16:50:09 -0600
@@ -0,0 +1,45 @@
+TARGET uqm.exe
+TARGETTYPE exe
+UID 0 0xA000A0C3
+EPOCHEAPSIZE 1000000 50000000
+EPOCSTACKSIZE 81920
+
+SYSTEMINCLUDE \epoc32\include \epoc32\include\stdapis
+
+SOURCEPATH .
+SOURCE uqmapp.cpp
+
+START RESOURCE uqm.rss
+HEADER
+TARGETPATH resource\apps
+LANG SC
+END  // RESOURCE
+
+START RESOURCE uqm_reg.rss
+#ifdef WINSCW
+TARGETPATH \private\10003a3f\apps
+#else
+TARGETPATH \private\10003a3f\import\apps
+#endif
+END 
+
+OPTION_REPLACE ARMCC --cpu ARM926EJ-S -O3 -Otime
+ALWAYS_BUILD_AS_ARM
+
+LIBRARY avkon.lib
+LIBRARY apparc.lib
+LIBRARY cone.lib
+LIBRARY eikcore.lib
+LIBRARY ws32.lib
+LIBRARY bafl.lib
+LIBRARY euser.lib
+LIBRARY efsrv.lib
+LIBRARY sdl.lib
+LIBRARY libc.lib
+LIBRARY libm.lib
+LIBRARY libz.lib
+LIBRARY libpthread.lib
+
+STATICLIBRARY uqm.lib
+STATICLIBRARY SDL_image.lib
+STATICLIBRARY tremor.lib
diff -ruNp src.orig/symbian/uqm.rss src/symbian/uqm.rss
--- src.orig/symbian/uqm.rss	1969-12-31 18:00:00 -0600
+++ src/symbian/uqm.rss	2017-11-08 16:50:09 -0600
@@ -0,0 +1,26 @@
+NAME UQM
+
+#include <eikon.rh>
+#include <avkon.rh>
+#include <avkon.rsg>
+#include <avkon.hrh>
+#include <appinfo.rh>
+
+RESOURCE RSS_SIGNATURE { }
+
+RESOURCE TBUF { buf="UQM"; }
+
+RESOURCE EIK_APP_INFO
+    {
+    }
+
+RESOURCE LOCALISABLE_APP_INFO r_uqm_localisable_app_info
+    {
+    short_caption = "UQM";
+    caption_and_icon = CAPTION_AND_ICON_INFO
+        {
+        caption = "UrQuanMasters";
+        number_of_icons = 1;
+        icon_file = "\\resource\\apps\\uqm_icon.mif";
+        };
+    }
diff -ruNp src.orig/symbian/uqm.svg src/symbian/uqm.svg
--- src.orig/symbian/uqm.svg	1969-12-31 18:00:00 -0600
+++ src/symbian/uqm.svg	2017-11-08 16:50:09 -0600
@@ -0,0 +1,70 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
+<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
+	 width="48px" height="48px" viewBox="0 0 48 48" enable-background="new 0 0 48 48" xml:space="preserve">
+<g>
+	<g>
+		<path fill="#5B5F54" d="M15,5c1.44,0.56,2.44,1.56,3,3c-0.81,0.19-0.997,1.003-2,1c-0.333,0-0.667,0-1,0
+			c0.184-0.851-0.39-0.943-1-1C13.718,6.385,14.945,6.278,15,5z"/>
+		<path fill="#5B5F54" d="M13,15c-0.586,3.511,4.727,3.289,2,6c-2.323,2.416-2.677-1.562-5-2c0-0.667,0-1.333,0-2
+			C10.437,15.77,11.28,14.946,13,15z"/>
+		<path fill="#B43905" d="M5,29c0.333,0,0.667,0,1,0c0.19,0.811,1.003,0.997,1,2c1.563,3.771,4.23,6.438,8,8
+			c0.89,0.443,1.789,0.878,2,2c-4.236,0.236-5.083-2.917-8-4c0.184-0.852-0.39-0.943-1-1C7.549,33.118,4.461,32.872,5,29z"/>
+		<path fill="#03D002" d="M9,31c5.35-2.9,9.348,4.807,9,8c-4.555-0.779-5.266-5.4-9-7C9,31.667,9,31.333,9,31z"/>
+		<path fill="#5B5F54" d="M27,30c0.902,1.764,2.236,3.098,4,4c-0.238,1.428-1.646,1.688-2,3c-0.333,0-0.667,0-1,0
+			c-0.902-1.764-2.236-3.098-4-4c0.239-1.428,1.646-1.688,2-3C26.333,30,26.667,30,27,30z"/>
+		<path opacity="0" fill="#EAECE6" d="M4,14c3.582-4.418,7.582-8.418,12-12C12.418,6.418,8.418,10.418,4,14z"/>
+		<path opacity="0" fill="#FFFFFF" d="M48,0c0,16,0,32,0,48c-16,0-32,0-48,0C0,32,0,16,0,0C16,0,32,0,48,0z M4,14
+			c-0.634,3.699-2.713,5.953-2,11c4.654,0.943,6.093-6.516,10-3c-1.412,2.588-3.231,4.77-8,4c-0.664,5.33,0.582,8.751,4,10
+			c0.61,0.057,1.184,0.148,1,1c0,0.333,0,0.667,0,1c2.853,1.813,4.086,5.247,10,4c0.792-3.339,2.546-9.477,7-6
+			c-0.854,3.275-7.298,4.725-5,8c13.313,1.313,15.825-8.175,23-13c0.253-3.586-3.003-3.664-3-7C52.211,11.655,34.152-2.889,21,6
+			c-1.286-1.714-2.068-3.932-5-4C11.582,5.582,7.582,9.582,4,14z"/>
+		<path fill="#21351B" d="M4,14c4.418-3.582,8.418-7.582,12-12c2.932,0.068,3.714,2.286,5,4c13.152-8.889,31.211,5.655,20,18
+			c-0.003,3.336,3.253,3.414,3,7c-7.175,4.825-9.688,14.313-23,13c-2.298-3.275,4.146-4.725,5-8c-4.454-3.477-6.208,2.661-7,6
+			c-5.914,1.247-7.147-2.188-10-4c0-0.333,0-0.667,0-1c2.917,1.083,3.764,4.236,8,4c0.333,0,0.667,0,1,0
+			c2.208-0.125,0.425-4.242,1-6c0.89,0.615,1.789,1.208,2,0c1.313-0.354,1.573-1.762,3-2c1.764,0.902,3.098,2.236,4,4
+			c-0.797,1.072-7.094,4.348-2,5c6.992-0.341,10.803-3.863,13-9c-0.354-1.313-1.762-1.572-2-3c-3.512-0.178-3.289,3.378-6,4
+			c-1.764-0.902-3.098-2.236-4-4c1.241-2.092,2.908-3.759,5-5c-1.436,2.951-5.811,4.049-2,7c2.748-1.131,12.85-8.146,3-7
+			c1.807-3.096,3.063-0.534,7-1c3.793-2.643,2.902-15.629-2-16c-0.529-0.804-1.043-1.624-1-3c-4.564,0.435-11.012-1.011-14,1
+			c3.873,11.531-9.844,12.351-12,21c-2,0-4,0-6,0c0,0.667,0,1.333,0,2c-0.539,3.872,2.549,4.118,3,7c-3.418-1.249-4.664-4.67-4-10
+			c4.769,0.77,6.588-1.412,8-4c-3.907-3.516-5.346,3.943-10,3C1.287,19.953,3.366,17.699,4,14z M18,8c1.278,0.055,1.385,1.282,3,1
+			c1.074-3.808-3.845-6.732-6-4c-0.055,1.278-1.282,1.385-1,3C8.369,11.035,3.757,15.09,3,23c2.951,2.451,4.049-3.356,7-4
+			c2.323,0.438,2.677,4.416,5,2c2.727-2.711-2.586-2.489-2-6c2.039-0.294,1.961-2.706,4-3c0.043-1.376-0.471-2.196-1-3
+			C17.003,9.003,17.19,8.19,18,8z M21,9c-1.546,2.867-8.463,4.297-5,9C19.536,17.498,24.081,12.798,21,9z M37,28
+			c3.384-0.384,1.572,4.428,6,3C42.991,27.918,38.283,23.799,37,28z"/>
+		<path fill="#65C11B" d="M34,6c1.725,3.276,5.275,4.724,7,8c-2.754-1.913-5.088-4.246-7-7c-1.758,0.575-5.875-1.208-6,1
+			C22.684,5.654,30.9,5.834,34,6z"/>
+		<path fill="#65C11B" d="M31,8c4.893,2.441,6.87,7.797,10,12c-4.051,1.688-3.527-9.783-9-10C31.811,9.19,30.997,9.003,31,8z"/>
+		<path fill="#03D002" d="M16,9c0.529,0.804,1.043,1.624,1,3c-2.039,0.294-1.961,2.706-4,3c-1.72-0.054-2.563,0.77-3,2
+			c-2.168,1.499-2.329,5.004-6,5c1.383-6.617,7.15-8.85,11-13C15.333,9,15.667,9,16,9z"/>
+		<path fill="#038C01" d="M15,9c-3.85,4.15-9.617,6.383-11,13c3.671,0.004,3.832-3.501,6-5c0,0.667,0,1.333,0,2
+			c-2.951,0.644-4.049,6.451-7,4c0.757-7.91,5.369-11.965,11-15C14.61,8.057,15.184,8.149,15,9z"/>
+		<path opacity="0" fill="#FFFFFF" d="M16,18c-3.463-4.703,3.454-6.133,5-9C24.081,12.798,19.536,17.498,16,18z"/>
+		<path fill="#03D002" d="M38,8c4.902,0.371,5.793,13.357,2,16c-3.938,0.466-5.193-2.096-7,1c-0.333,0-0.667,0-1,0
+			c-2.092,1.241-3.759,2.908-5,5c-0.333,0-0.667,0-1,0c-0.354,1.313-1.761,1.572-2,3c-1.427,0.238-1.687,1.646-3,2
+			c-0.333,0-0.667,0-1,0c-2.573-1.762-4.318-4.35-7-6c1.167-1.834,2.614-3.387,4-5c3.401,1.891-1.712,3.506-1,6
+			c3.094-1.236,5.508-3.184,8,0c-1.317-2.684,0.114-8.114-5-7c2.849-4.484,8.209-6.458,9-13c1.333,0,2.667,0,4,0
+			c5.473,0.217,4.949,11.688,9,10c0-2,0-4,0-6c-1.725-3.276-5.275-4.724-7-8C35.764,5.714,37.098,10.709,38,8z"/>
+		<path fill="#038C01" d="M17,24c-1.386,1.613-2.833,3.166-4,5c2.682,1.65,4.427,4.238,7,6c0.333,0,0.667,0,1,0
+			c-0.211,1.208-1.11,0.615-2,0c-0.575,1.758,1.208,5.875-1,6c0-0.667,0-1.333,0-2c0.348-3.193-3.65-10.9-9-8
+			c-1.313-0.354-1.573-1.762-3-2c-0.333,0-0.667,0-1,0c0-0.667,0-1.333,0-2c2,0,4,0,6,0c2.156-8.649,15.873-9.469,12-21
+			c2.988-2.011,9.436-0.565,14-1c-0.043,1.376,0.471,2.196,1,3c-0.902,2.709-2.236-2.286-4-2c-3.1-0.166-11.316-0.346-6,2
+			c1,0,2,0,3,0c-0.003,1.003,0.811,1.19,1,2c-1.333,0-2.667,0-4,0c-0.791,6.542-6.151,8.516-9,13c-1.313-0.354-1.573-1.761-3-2
+			C15.718,22.615,16.945,22.722,17,24z"/>
+		<path fill="#E6C626" d="M19,23c5.114-1.114,3.683,4.316,5,7c-2.492-3.184-4.906-1.236-8,0c-0.712-2.494,4.401-4.109,1-6
+			c-0.055-1.278-1.282-1.385-1-3C17.427,21.239,17.687,22.646,19,23z"/>
+		<path opacity="0" fill="#FFFFFF" d="M33,25c9.85-1.146-0.252,5.869-3,7c-3.811-2.951,0.564-4.049,2-7C32.333,25,32.667,25,33,25z"
+			/>
+		<path fill="#B43905" d="M43,31c-4.428,1.428-2.616-3.384-6-3C38.283,23.799,42.991,27.918,43,31z"/>
+		<path fill="#E6C626" d="M7,31c3.086,2.247,5.753,4.913,8,8C11.23,37.438,8.563,34.771,7,31z"/>
+		<path fill="#65C11B" d="M15,39c-2.247-3.087-4.914-5.753-8-8c0.003-1.003-0.81-1.189-1-2c1.427,0.238,1.687,1.646,3,2
+			c0,0.333,0,0.667,0,1c3.734,1.6,4.445,6.221,9,7c0,0.667,0,1.333,0,2c-0.333,0-0.667,0-1,0C16.789,39.878,15.89,39.443,15,39z"/>
+		<path fill="#038C01" d="M31,34c2.711-0.622,2.488-4.178,6-4c0.238,1.428,1.646,1.688,2,3c-4.995-1.393-9.604,5.531-13,9
+			c-5.094-0.652,1.203-3.928,2-5c0.333,0,0.667,0,1,0C29.354,35.688,30.762,35.428,31,34z"/>
+		<path fill="#03D002" d="M39,33c-2.197,5.137-6.008,8.659-13,9C29.396,38.531,34.005,31.607,39,33z"/>
+		<path fill="#B43905" d="M15,5c2.155-2.732,7.074,0.192,6,4c-1.615,0.282-1.722-0.945-3-1C17.44,6.56,16.44,5.56,15,5z"/>
+		<path fill="#E6C626" d="M41,14c0,2,0,4,0,6c-3.13-4.203-5.107-9.559-10-12c-1,0-2,0-3,0c0.125-2.208,4.242-0.425,6-1
+			C35.912,9.754,38.246,12.087,41,14z"/>
+	</g>
+</g>
+</svg>
diff -ruNp src.orig/symbian/uqm_reg.rss src/symbian/uqm_reg.rss
--- src.orig/symbian/uqm_reg.rss	1969-12-31 18:00:00 -0600
+++ src/symbian/uqm_reg.rss	2017-11-08 16:50:09 -0600
@@ -0,0 +1,12 @@
+#include <appinfo.rh>
+#include <uqm.rsg>
+
+UID2 KUidAppRegistrationResourceFile
+UID3 0xA000A0C3
+
+RESOURCE APP_REGISTRATION_INFO
+    {
+    app_file = "uqm";
+    localisable_resource_file = "\\resource\\apps\\uqm";
+    localisable_resource_id   = R_UQM_LOCALISABLE_APP_INFO; 
+    }
diff -ruNp src.orig/symbian/uqmapp.cpp src/symbian/uqmapp.cpp
--- src.orig/symbian/uqmapp.cpp	1969-12-31 18:00:00 -0600
+++ src/symbian/uqmapp.cpp	2017-11-08 16:50:09 -0600
@@ -0,0 +1,302 @@
+#include <coecntrl.h>
+#include <aknappui.h>
+#include <aknapp.h>
+#include <akndoc.h>
+#include <sdlepocapi.h>
+#include <aknnotewrappers.h>
+#include <eikstart.h>
+#include <badesca.h>
+#include <bautils.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <SDL/SDL_keysym.h>
+
+const TUid KUidSdlApp={ 0xA000A0C3 };
+
+class CSDL;
+
+class CSDLObserver : public CBase, public MSDLObserver
+{
+public:
+    CSDLObserver(CSDL* aSdl);
+
+    TInt SdlEvent(TInt aEvent, TInt aParam);
+    TInt SdlThreadEvent(TInt aEvent, TInt aParam);
+
+private:
+    CSDL* iSdl;    
+};
+
+class MExitWait
+    {
+    public:
+        virtual void DoExit(TInt aErr) = 0;
+    };   
+
+class CExitWait : public CActive
+    {
+    public:
+        CExitWait(MExitWait& aWait);
+        void Start();
+        ~CExitWait();
+    private:
+        void RunL();
+        void DoCancel();
+    private:
+        MExitWait& iWait;
+        TRequestStatus* iStatusPtr;
+    };
+
+class CSDLWin : public CCoeControl
+    {
+    public:
+        void ConstructL(const TRect& aRect);
+        RWindow& GetWindow() const;
+        void SetNoDraw();
+    private:
+        void Draw(const TRect& aRect) const;
+    };  
+    
+class CSdlApplication : public CAknApplication
+    {
+private:
+    // from CApaApplication
+    CApaDocument* CreateDocumentL();
+    TUid AppDllUid() const;
+    };
+    
+    
+class CSdlAppDocument : public CAknDocument
+    {
+public:
+    CSdlAppDocument(CEikApplication& aApp): CAknDocument(aApp) { }
+private:
+    CEikAppUi* CreateAppUiL();
+    };
+    
+            
+class CSdlAppUi : public CAknAppUi, public MExitWait
+    {
+public:
+    void ConstructL();
+    ~CSdlAppUi();
+private:
+    void HandleCommandL(TInt aCommand);
+    void DoExit(TInt aErr);
+    void HandleWsEventL(const TWsEvent& aEvent, CCoeControl* aDestination);
+    void HandleResourceChangeL(TInt aType);
+    void AddCmdLineParamsL(CDesC8Array& aArgs);
+private:
+    CExitWait* iWait;
+    CSDLWin* iSDLWin;
+    CSDL* iSdl;
+    CSDLObserver* iSdlObserver;
+    TBool iExit;
+    };  
+
+
+CExitWait::CExitWait(MExitWait& aWait) : CActive(CActive::EPriorityStandard), iWait(aWait)
+    {
+    CActiveScheduler::Add(this);
+    }
+    
+CExitWait::~CExitWait()
+    {
+    Cancel();
+    }
+ 
+void CExitWait::RunL()
+    {
+    if(iStatusPtr != NULL )
+        iWait.DoExit(iStatus.Int());
+    }
+    
+void CExitWait::DoCancel()
+    {
+    if(iStatusPtr != NULL )
+        User::RequestComplete(iStatusPtr , KErrCancel);
+    }
+    
+void CExitWait::Start()
+    {
+    SetActive();
+    iStatusPtr = &iStatus;
+    }
+
+void CSDLWin:: ConstructL(const TRect& aRect)   
+    {
+    CreateWindowL();
+    SetRect(aRect);
+    ActivateL();
+    }
+
+    
+RWindow& CSDLWin::GetWindow() const
+    {
+    return Window();
+    }
+    
+
+void CSDLWin::Draw(const TRect& /*aRect*/) const
+    {
+    CWindowGc& gc = SystemGc();
+    gc.SetPenStyle(CGraphicsContext::ESolidPen);
+    gc.SetPenColor(KRgbBlack);
+    gc.SetBrushStyle(CGraphicsContext::ESolidBrush);
+    gc.SetBrushColor(0x000000);
+    gc.DrawRect(Rect());
+    }   
+    
+void CSdlAppUi::ConstructL()    
+    {
+    BaseConstructL(ENoScreenFurniture | EAppOrientationLandscape);
+        
+    iSDLWin = new (ELeave) CSDLWin;
+    iSDLWin->ConstructL(ApplicationRect());
+                
+    iSdl = CSDL::NewL(CSDL::EEnableFocusStop);
+    iSdlObserver = new (ELeave) CSDLObserver(iSdl);
+    
+    iSdl->SetContainerWindowL(
+                    iSDLWin->GetWindow(), 
+                    iEikonEnv->WsSession(),
+                    *iEikonEnv->ScreenDevice());    
+    iSdl->SetObserver(iSdlObserver);
+    iSdl->DisableKeyBlocking(*this);    
+    
+    iWait = new (ELeave) CExitWait(*this);    
+    CDesC8ArrayFlat* args = new (ELeave)CDesC8ArrayFlat(10);
+    AddCmdLineParamsL(*args);
+    
+    iSdl->CallMainL(iWait->iStatus, *args, CSDL::ENoFlags, 81920);
+    delete args;
+    
+    iWait->Start();     
+    }
+
+void CSdlAppUi::HandleCommandL(TInt aCommand)
+    {
+    switch(aCommand)
+        {
+        case EAknCmdExit:
+        case EAknSoftkeyExit:
+        case EEikCmdExit:
+            exit(0);
+            break;
+            
+        default:
+            break;
+        }
+    }
+    
+void CSdlAppUi::DoExit(TInt aErr)
+    {       
+    delete iSdl;
+    iSdl = NULL;
+    
+    if(iExit)
+        Exit();
+    }
+    
+void CSdlAppUi::HandleWsEventL(const TWsEvent& aEvent, CCoeControl* aDestination)
+    {
+    if(iSdl != NULL)
+        iSdl->AppendWsEvent(aEvent);
+    CAknAppUi::HandleWsEventL(aEvent, aDestination);
+    }
+    
+void CSdlAppUi::HandleResourceChangeL(TInt aType)
+    {
+    CAknAppUi::HandleResourceChangeL(aType);
+    
+    if(aType == KEikDynamicLayoutVariantSwitch)
+        {
+        iSDLWin->SetRect(ApplicationRect());
+        if (iSdl)
+            {
+            iSdl->SetContainerWindowL(
+                        iSDLWin->GetWindow(),
+                        iEikonEnv->WsSession(),
+                        *iEikonEnv->ScreenDevice());
+            }                       
+        }
+    }
+
+void CSdlAppUi::AddCmdLineParamsL(CDesC8Array& aArgs)
+    {       
+    _LIT8(KAddonParam, "--addondir=?:\\uqm-addons");
+    _LIT16(KTestFolder, "?:\\uqm-addons");
+    RFs fs;
+    
+    fs.Connect();   
+    for (TInt8 c = 'e'; c < 'z'; ++c)
+        {
+        TBuf16<32> buf(KTestFolder);
+        buf[0] = c;
+        if (BaflUtils::FolderExists(fs, buf))
+            {
+            TBuf8<32> arg(KAddonParam);
+            arg[11] = c;
+            aArgs.AppendL(arg);
+            break;
+            }
+        }
+    fs.Close();
+    }
+
+CSdlAppUi::~CSdlAppUi()
+    {
+    if(iWait != NULL)
+        iWait->Cancel();
+    delete iSdl;
+    delete iWait;
+    delete iSDLWin;
+    delete iSdlObserver;
+    }
+
+CEikAppUi* CSdlAppDocument::CreateAppUiL()
+    {
+    return new(ELeave) CSdlAppUi();
+    }   
+    
+TUid CSdlApplication::AppDllUid() const
+    {
+    return KUidSdlApp;
+    }   
+    
+
+CApaDocument* CSdlApplication::CreateDocumentL()
+    {
+    CSdlAppDocument* document = new (ELeave) CSdlAppDocument(*this);
+    return document;
+    }
+  
+LOCAL_C CApaApplication* NewApplication()
+    {
+    return new CSdlApplication;
+    }
+
+GLDEF_C TInt E32Main()
+    {
+    return EikStart::RunApplication(NewApplication);
+    }
+
+CSDLObserver::CSDLObserver(CSDL* aSdl) : iSdl(aSdl)
+{
+}
+
+TInt CSDLObserver::SdlEvent(TInt aEvent, TInt aParam)
+{
+    if (aEvent == EEventKeyMapInit)
+    {
+        // starmap zoom
+        iSdl->SetSDLCode('3', SDLK_KP_PLUS);
+        iSdl->SetSDLCode('2', SDLK_KP_MINUS);
+    }
+    return 0;
+}
+
+TInt CSDLObserver::SdlThreadEvent(TInt aEvent, TInt aParam)
+{
+    return 0;
+}
diff -ruNp src.orig/types.h src/types.h
--- src.orig/types.h	2017-11-08 16:49:41 -0600
+++ src/types.h	2017-11-08 16:50:09 -0600
@@ -22,6 +22,8 @@
 #ifndef _TYPES_H
 #define _TYPES_H
 
+#include "config.h"
+
 #ifdef _MSC_VER
 #	if (_MSC_VER >= 1300)
 #		include <stddef.h>
@@ -36,11 +38,21 @@
 #	endif
 #else
 #	include <inttypes.h>
+#	ifndef PRIxPTR
+		/* SunOS (at least version 5.9) does not have PRIxPTR in inttypes.h */
+#		if defined(__arch64__) || defined(__alpha) || defined(__x86_64) \
+				|| defined(_M_IA64) || defined(_M_AMD64)
+			/* 64-bit platforms */
+#			define PRIxPTR "lx"
+#		else
+#			define PRIxPTR "x"
+#		endif
+#	endif  /* defined(PRIxPTR) */
 #endif
 
 #if defined(__arch64__) || defined(__alpha) || defined(__x86_64) \
-	|| defined(_M_IA64) || defined(_M_AMD64)
-/* 64-bit platforms */
+		|| defined(_M_IA64) || defined(_M_AMD64)
+	/* 64-bit platforms */
 #	define UQM_INT16   short
 #	define UQM_INT32   int
 #	define UQM_INT64   long
@@ -62,23 +74,36 @@
 
 /* Figure out how to support 64-bit datatypes */
 #if !defined(UQM_INT64) && !defined(__STRICT_ANSI__)
-#	if defined(__GNUC__) || defined(__MWERKS__) || defined(__SUNPRO_C)
+#	if defined(__GNUC__) || defined(__MWERKS__) || defined(__SUNPRO_C) || defined(__ARMCC__)
 #		define UQM_INT64    long long
 #	elif defined(_MSC_VER) || defined(__BORLANDC__)
 #		define UQM_INT64    __int64
 #	endif
 #endif /* !__STRICT_ANSI__ */
 
-/* The 64-bit type isn't available on EPOC/Symbian OS */
-#ifdef __SYMBIAN32__
-#	undef UQM_INT64
-#endif
-
-typedef enum
-{
-	false = 0,
-	true
-} bool;
+// ISO C99 compatible boolean types. The ISO C99 standard defines:
+// - An object declared as type _Bool, large enough to store the values 0
+//   and 1, the rank of which is less than the rank of all other standard
+//   integer types.
+// - A macro "bool", which expands to "_Bool".
+// - A macro "true", which expands to the integer constant 1, suitable for
+//   use in #if preprocessing directives.
+// - A macro "false", which expands to the integer constant 0, suitable for
+//   use in #if preprocessing directives.
+// - A macro "__bool_true_false_are_defined", which expands to the integer
+//   constant 1, suitable for use in #if preprocessing directives.
+#ifndef __bool_true_false_are_defined
+#undef bool
+#undef false
+#undef true
+#ifndef HAVE__BOOL
+typedef unsigned char _Bool;
+#endif  /* HAVE_BOOL */
+#define bool _Bool
+#define true 1
+#define false 0
+#define __bool_true_false_are_defined
+#endif  /* __bool_true_false_are_defined */
 
 /* If it isn't char, what is it ?!*/
 typedef unsigned char      uint8;
diff -ruNp src.orig/uqmversion.h src/uqmversion.h
--- src.orig/uqmversion.h	2017-11-08 16:49:41 -0600
+++ src/uqmversion.h	2017-11-08 16:50:09 -0600
@@ -21,9 +21,9 @@
 #define UQM_MAJOR_VERSION_S  "0"
 #define UQM_MINOR_VERSION     6
 #define UQM_MINOR_VERSION_S  "6"
-#define UQM_PATCH_VERSION     2
-#define UQM_PATCH_VERSION_S  "2"
-#define UQM_EXTRA_VERSION    ""
+#define UQM_PATCH_VERSION     4
+#define UQM_PATCH_VERSION_S  "4"
+#define UQM_EXTRA_VERSION    " - Extended Edition"
 /* The final version is interpreted as:
  * printf ("%d.%d.%d%s", UQM_MAJOR_VERSION, UQM_MINOR_VERSION,
  * 		UQM_PATCH_VERSION, UQM_EXTRA_VERSION);
@@ -33,6 +33,6 @@
 		UQM_MAJOR_VERSION_S "." UQM_MINOR_VERSION_S "." UQM_PATCH_VERSION_S \
 		UQM_EXTRA_VERSION
 
-#define UQM_CVS_DATE "$Date: 2007-01-15 00:04:49 +0100 (Mon, 15 Jan 2007) $"
+#define UQM_SVN_REVISION "$Revision: 2869 $"
 
 #endif
