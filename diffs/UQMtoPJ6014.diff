diff -ruNp src.orig/Makeinfo src/Makeinfo
--- src.orig/Makeinfo	2017-11-01 15:30:22 -0700
+++ src/Makeinfo	2017-11-01 15:30:59 -0700
@@ -16,3 +16,5 @@ fi
 
 uqm_CFILES="options.c port.c uqm.c"
 
+test_CFILES=test.c
+
diff -ruNp src.orig/config_unix.h.in src/config_unix.h.in
--- src.orig/config_unix.h.in	2017-11-01 15:30:19 -0700
+++ src/config_unix.h.in	2017-11-01 15:30:56 -0700
@@ -3,7 +3,7 @@
  * config_unix.h is generated from config_unix.h.in by build.sh
  * When building on MS Windows using build.sh (MinGW, Cygwin),
  * config_win.h is generated from src/config_win.h.in.
- * When using MSVC on MS Windows, you'll have to edit src/config_vc6.h
+ * When using MSVC on MS Windows, you'll have to edit src/msvc++/config.h
  * manually if you want anything else than the defaults.
  */
 
@@ -14,7 +14,7 @@
 #define CONTENTDIR "@CONTENTDIR@"
 
 /* Directory where game data will be stored */
-#define USERDIR "~/.uqm/"
+#define USERDIR "~/.uqmmod/"
 
 /* Directory where config files will be stored */
 #define CONFIGDIR USERDIR
@@ -44,6 +44,9 @@
 /* Defined if your system has stricmp of its own */
 @HAVE_STRICMP@
 
+/* Defined if your system has vsprintf of its own */
+@HAVE_VSNPRINTF@
+
 /* Defined if your system has getopt_long */
 @HAVE_GETOPT_LONG@
 
diff -ruNp src.orig/config_vc6.h src/config_vc6.h
--- src.orig/config_vc6.h	2017-11-01 15:30:19 -0700
+++ src/config_vc6.h	2017-11-01 15:30:56 -0700
@@ -7,15 +7,15 @@
  * config_win.h is generated from src/config_win.h.in.
  */
 
-#ifndef _CONFIG_VC6_H
-#define _CONFIG_VC6_H
+#ifndef _CONFIG_H
+#define _CONFIG_H
 
 /* Directory where the UQM game data is located */
 #define CONTENTDIR "../content/"
 
 /* Directory where game data will be stored */
 //#define USERDIR "../userdata/"
-#define USERDIR "%APPDATA%/uqm/"
+#define USERDIR "%APPDATA%/uqmmod/"
 
 /* Directory where config files will be stored */
 #define CONFIGDIR USERDIR
@@ -45,6 +45,11 @@
 /* Defined if your system has stricmp of its own */
 #define HAVE_STRICMP
 
+/* Defined if your system has vsprintf of its own */
+#if (_MSC_VER >= 1400)
+#define HAVE_VSNPRINTF
+#endif
+
 /* Defined if your system has getopt_long */
 #undef HAVE_GETOPT_LONG
 
@@ -57,5 +62,5 @@
 /* Defined if your system has wint_t of its own */
 #define HAVE_WINT_T
 
-#endif /* _CONFIG_VC6_H */
+#endif /* _CONFIG_H */
 
diff -ruNp src.orig/config_win.h.in src/config_win.h.in
--- src.orig/config_win.h.in	2017-11-01 15:30:19 -0700
+++ src/config_win.h.in	2017-11-01 15:30:56 -0700
@@ -1,7 +1,7 @@
 /* This file contains some compile-time configuration options for MS Windows
  * systems when building using build.sh (MinGW, Cygwin).
  * config_win.h is generated from src/config_win.h.in by build.sh
- * For building using MSVC, you'll have to edit src/config_vc6.h manually
+ * For building using MSVC, you'll have to edit src/msvc++/config.h manually
  * if you want anything else than the defaults.
  * For *nix systems, config_unix.h is used, which is generated by build.sh
  * from src/config_unix.h.in.
@@ -15,7 +15,7 @@
 
 /* Directory where game data will be stored */
 //#define USERDIR "../userdata/"
-#define USERDIR "%APPDATA%/uqm/"
+#define USERDIR "%APPDATA%/uqmmod/"
 
 /* Directory where config files will be stored */
 #define CONFIGDIR USERDIR
@@ -45,6 +45,9 @@
 /* Defined if your system has stricmp of its own */
 @HAVE_STRICMP@
 
+/* Defined if your system has vsprintf of its own */
+@HAVE_VSNPRINTF@
+
 /* Defined if your system has getopt_long */
 @HAVE_GETOPT_LONG@
 
diff -ruNp src.orig/libs/cdp/cdp.c src/libs/cdp/cdp.c
--- src.orig/libs/cdp/cdp.c	2017-11-01 15:30:19 -0700
+++ src/libs/cdp/cdp.c	2017-11-01 15:30:56 -0700
@@ -25,7 +25,7 @@
 #include "port.h"
 #include "cdpint.h"
 #include "cdpmod.h"
-#include "uio.h"
+#include "../uio.h"
 #include "uqmversion.h"
 #ifdef WIN32
 #	include "windl.h"
@@ -54,14 +54,14 @@ cdp_ModuleInfo cdp_kernel_info =
 {
 	sizeof (cdp_ModuleInfo),
 	CDPAPI_VERSION,              // API version we are using
-	UQM_MAJOR_VERSION, UQM_MINOR_VERSION, UQM_PATCH_VERSION,
-	UQM_MAJOR_VERSION, UQM_MINOR_VERSION, UQM_PATCH_VERSION,
+	P6014_MAJOR_VERSION, P6014_MINOR_VERSION, P6014_PATCH_VERSION,
+	P6014_MAJOR_VERSION, P6014_MINOR_VERSION, P6014_PATCH_VERSION,
 	CDP_MODINFO_RESERVED1,
 	"UQM",                       // CDP context cannonical name
 	"UQM Kernel",                // CDP mod name
 #	define S(i) #i
 	// CDP mod version
-	S(UQM_MAJOR_VERSION) "." S(UQM_MINOR_VERSION) UQM_EXTRA_VERSION,
+	S(P6014_MAJOR_VERSION) "." S(P6014_MINOR_VERSION) P6014_EXTRA_VERSION,
 #	undef S
 	"UQM Team",                  // CDP mod author
 	"http://sc2.sf.net",         // CDP mod URL
diff -ruNp src.orig/libs/cdp/cdpapi.c src/libs/cdp/cdpapi.c
--- src.orig/libs/cdp/cdpapi.c	2017-11-01 15:30:19 -0700
+++ src/libs/cdp/cdpapi.c	2017-11-01 15:30:56 -0700
@@ -242,8 +242,8 @@ cdp_Host_GetApiVersion (void)
 static uint32
 cdp_Host_GetVersion (void)
 {
-	return (UQM_MAJOR_VERSION << 20) | (UQM_MINOR_VERSION << 15) |
-			UQM_PATCH_VERSION;
+	return (P6014_MAJOR_VERSION << 20) | (P6014_MINOR_VERSION << 15) |
+			P6014_PATCH_VERSION;
 }
 
 static cdp_Error
diff -ruNp src.orig/libs/gfxlib.h src/libs/gfxlib.h
--- src.orig/libs/gfxlib.h	2017-11-01 15:30:19 -0700
+++ src/libs/gfxlib.h	2017-11-01 15:30:56 -0700
@@ -13,9 +13,11 @@
  *
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *  Foundation, Inc., 59 Temple Place - SuiCreateDisplayte 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2011: Added DPOINT type - a coordinate point with larger values to avoid overflows in hires modes.
+
 #ifndef _GFXLIB_H
 #define _GFXLIB_H
 
@@ -149,11 +151,23 @@ typedef struct extent
 	COORD width, height;
 } EXTENT;
 
+// JMS: Extent with larger values to avoid overflows in hires modes.
+typedef struct dextent
+{
+	SDWORD width, height;
+} DEXTENT;
+
 typedef struct point
 {
 	COORD x, y;
 } POINT;
 
+// JMS: coordinate point with larger values to avoid overflows in hires modes.
+typedef struct dpoint
+{
+	SDWORD x, y;
+} DPOINT;
+
 typedef struct stamp
 {
 	POINT origin;
diff -ruNp src.orig/libs/graphics/cmap.c src/libs/graphics/cmap.c
--- src.orig/libs/graphics/cmap.c	2017-11-01 15:30:19 -0700
+++ src/libs/graphics/cmap.c	2017-11-01 15:30:56 -0700
@@ -50,7 +50,6 @@ static int fadeAmount = FADE_NORMAL_INTE
 static int fadeDelta;
 static TimeCount fadeStartTime;
 static sint32 fadeInterval;
-static Mutex fadeLock;
 
 #define SPARE_COLORMAPS  20
 
@@ -61,7 +60,7 @@ static int poolcount;
 
 static TFB_ColorMap * colormaps[MAX_COLORMAPS];
 static int mapcount;
-static Mutex maplock;
+Mutex maplock;
 
 
 void
@@ -77,8 +76,6 @@ InitColorMaps (void)
 	XFormControl.Lock = CreateMutex ("Transform Lock", SYNC_CLASS_TOPLEVEL | SYNC_CLASS_VIDEO);
 	for (i = 0; i < MAX_XFORMS; ++i)
 		XFormControl.TaskControl[i].CMapIndex = -1;
-
-	fadeLock = CreateMutex ("Fade Lock", SYNC_CLASS_TOPLEVEL | SYNC_CLASS_VIDEO);
 }
 
 void
@@ -93,7 +90,6 @@ UninitColorMaps (void)
 		HFree (poolhead);
 	}
 
-	DestroyMutex (fadeLock);
 	// uninit xform control
 	DestroyMutex (XFormControl.Lock);
 	
@@ -321,7 +317,7 @@ GetFadeAmount (void)
 {
 	int newAmount;
 
-	LockMutex (fadeLock);
+	LockMutex (XFormControl.Lock);
 
 	if (fadeInterval)
 	{	// have a pending fade
@@ -345,7 +341,7 @@ GetFadeAmount (void)
 		newAmount = fadeAmount;
 	}
 
-	UnlockMutex (fadeLock);
+	UnlockMutex (XFormControl.Lock);
 
 	return newAmount;
 }
@@ -363,9 +359,9 @@ finishPendingFade (void)
 static void
 FlushFadeXForms (void)
 {
-	LockMutex (fadeLock);
+	LockMutex (XFormControl.Lock);
 	finishPendingFade ();
-	UnlockMutex (fadeLock);
+	UnlockMutex (XFormControl.Lock);
 }
 
 DWORD
@@ -396,7 +392,7 @@ FadeScreen (ScreenFadeType fadeType, SIZ
 	if (QuitPosted)
 		TimeInterval = 0;
 
-	LockMutex (fadeLock);
+	LockMutex (XFormControl.Lock);
 
 	finishPendingFade ();
 
@@ -415,7 +411,7 @@ FadeScreen (ScreenFadeType fadeType, SIZ
 		TimeOut = fadeStartTime + TimeInterval + 1;
 	}
 
-	UnlockMutex (fadeLock);
+	UnlockMutex (XFormControl.Lock);
 
 	return TimeOut;
 }
diff -ruNp src.orig/libs/graphics/dcqueue.c src/libs/graphics/dcqueue.c
--- src.orig/libs/graphics/dcqueue.c	2017-11-01 15:30:19 -0700
+++ src/libs/graphics/dcqueue.c	2017-11-01 15:30:56 -0700
@@ -553,14 +553,15 @@ TFB_FlushGraphics (void)
 				int oldFlags = GfxFlags;
 				int oldWidth = ScreenWidthActual;
 				int oldHeight = ScreenHeightActual;
+				// JMS_GFX: Added resolutionFactor
 				if (TFB_ReInitGraphics (cmd->driver, cmd->flags,
-						cmd->width, cmd->height))
+						cmd->width, cmd->height, resolutionFactor))
 				{
 					log_add (log_Error, "Could not provide requested mode: "
 							"reverting to last known driver.");
 					// We don't know what exactly failed, so roll it all back
 					if (TFB_ReInitGraphics (oldDriver, oldFlags,
-							oldWidth, oldHeight))
+							oldWidth, oldHeight, resolutionFactor))
 					{
 						log_add (log_Fatal,
 								"Couldn't reinit at that point either. "
diff -ruNp src.orig/libs/graphics/font.c src/libs/graphics/font.c
--- src.orig/libs/graphics/font.c	2017-11-01 15:30:19 -0700
+++ src/libs/graphics/font.c	2017-11-01 15:30:56 -0700
@@ -20,6 +20,8 @@
 #include "tfb_prim.h"
 #include "libs/log.h"
 
+#include "libs/graphics/gfx_common.h" // JMS: For resolutionFactor
+
 static inline TFB_Char *getCharFrame (FONT_DESC *fontPtr, UniChar ch);
 
 
@@ -74,18 +76,20 @@ font_DrawText (TEXT *lpText)
 void
 font_DrawTracedText (TEXT *pText, Color text, Color trace)
 {
+	BYTE res_scale = resolutionFactor > 0 ? 1 : 0;
+	
 	// Preserve current foreground color for full correctness
 	Color oldfg = SetContextForeGroundColor (trace);
-	pText->baseline.x--;
+	pText->baseline.x -= 1 << res_scale;
 	font_DrawText (pText);
-	pText->baseline.x += 2;
+	pText->baseline.x += 2 << res_scale;
 	font_DrawText (pText);
-	pText->baseline.x--;
-	pText->baseline.y--;
+	pText->baseline.x -= 1 << res_scale;
+	pText->baseline.y -= 1 << res_scale;
 	font_DrawText (pText);
-	pText->baseline.y += 2;
+	pText->baseline.y += 2 << res_scale;
 	font_DrawText (pText);
-	pText->baseline.y--;
+	pText->baseline.y -= 1 << res_scale;
 	SetContextForeGroundColor (text);
 	font_DrawText (pText);
 	SetContextForeGroundColor (oldfg);
@@ -327,7 +331,7 @@ getCharFrame (FONT_DESC *fontPtr, UniCha
 	}
 	else
 	{
-		//log_add (log_Debug, "Character %u not present", (unsigned int) ch);
+		log_add (log_Debug, "Character %u not present", (unsigned int) ch);
 		return NULL;
 	}
 }
diff -ruNp src.orig/libs/graphics/frame.c src/libs/graphics/frame.c
--- src.orig/libs/graphics/frame.c	2017-11-01 15:30:19 -0700
+++ src/libs/graphics/frame.c	2017-11-01 15:30:56 -0700
@@ -21,6 +21,9 @@
 #include "tfb_draw.h"
 #include "tfb_prim.h"
 
+//#include "../log.h"
+//#include "../../units.h"
+
 HOT_SPOT
 MAKE_HOT_SPOT (COORD x, COORD y)
 {
@@ -55,7 +58,6 @@ GetContextValidRect (RECT *pValidRect, P
 {
 	RECT tempRect;
 	POINT tempPt;
-
 	if (!pValidRect)
 		pValidRect = &tempRect;
 	if (!origin)
@@ -67,6 +69,7 @@ GetContextValidRect (RECT *pValidRect, P
 	pValidRect->extent = GetFrameBounds (_CurFramePtr);
 	*origin = _CurFramePtr->HotSpot;
 
+	
 	if (_pCurContext->ClipRect.extent.width)
 	{
 		// If the cliprect is completely outside of the valid frame
diff -ruNp src.orig/libs/graphics/gfx_common.c src/libs/graphics/gfx_common.c
--- src.orig/libs/graphics/gfx_common.c	2017-11-01 15:30:19 -0700
+++ src/libs/graphics/gfx_common.c	2017-11-01 15:30:56 -0700
@@ -1,4 +1,4 @@
-//Copyright Paul Reiche, Fred Ford. 1992-2002
+ //Copyright Paul Reiche, Fred Ford. 1992-2002
 
 /*
  *  This program is free software; you can redistribute it and/or modify
@@ -16,6 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2011: Merged resolution Factor stuff from UQM-HD.
 #include "gfxintrn.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/graphics/drawcmd.h"
@@ -24,6 +25,9 @@
 		// for TFB_DEBUG_HALT
 
 
+// JMS_GFX
+unsigned int resolutionFactor;
+
 int ScreenWidth;
 int ScreenHeight;
 int ScreenWidthActual;
@@ -44,12 +48,26 @@ DrawFromExtraScreen (RECT *r)
 	TFB_DrawScreen_Copy(r, TFB_SCREEN_EXTRA, TFB_SCREEN_MAIN);
 }
 
+// JMS_GFX
+void
+DrawFromExtraScreen_Fs (RECT *r)
+{
+	TFB_DrawScreen_Copy_Fs(r, TFB_SCREEN_EXTRA, TFB_SCREEN_MAIN);
+}
+
 void
 LoadIntoExtraScreen (RECT *r)
 {
 	TFB_DrawScreen_Copy(r, TFB_SCREEN_MAIN, TFB_SCREEN_EXTRA);
 }
 
+// JMS_GFX
+void
+LoadIntoExtraScreen_Fs (RECT *r)
+{
+	TFB_DrawScreen_Copy_Fs(r, TFB_SCREEN_MAIN, TFB_SCREEN_EXTRA);
+}
+
 int
 SetGraphicScale (int scale)
 {
@@ -146,11 +164,12 @@ SetTransitionSource (const RECT *pRect)
 	RECT ActualRect;
 
 	if (pRect)
-	{	/* expand the rect to accomodate scalers in OpenGL mode */
+	{	// expand the rect to accomodate scalers in OpenGL mode
 		ActualRect = *pRect;
 		pRect = &ActualRect;
 		ExpandRect (&ActualRect, 2);
 	}
+	
 	TFB_DrawScreen_Copy (pRect, TFB_SCREEN_MAIN, TFB_SCREEN_TRANSITION);
 }
 
diff -ruNp src.orig/libs/graphics/gfx_common.h src/libs/graphics/gfx_common.h
--- src.orig/libs/graphics/gfx_common.h	2017-11-01 15:30:19 -0700
+++ src/libs/graphics/gfx_common.h	2017-11-01 15:30:56 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2011: Merged resolution Factor stuff from UQM-HD.
+
 #ifndef GFX_COMMON_H
 #define GFX_COMMON_H
 
@@ -63,8 +65,8 @@ extern int GfxFlags;
 
 // The following functions are driver-defined
 void TFB_PreInit (void);
-int TFB_InitGraphics (int driver, int flags, int width, int height);
-int TFB_ReInitGraphics (int driver, int flags, int width, int height);
+int TFB_InitGraphics (int driver, int flags, int width, int height, unsigned int resolutionFactor); // JMS_GFX: Added resolutionFactor
+int TFB_ReInitGraphics (int driver, int flags, int width, int height, unsigned int resolutionFactor);
 void TFB_UninitGraphics (void);
 void TFB_ProcessEvents (void);
 void TFB_SetGamma (float gamma);
@@ -82,7 +84,9 @@ typedef enum {
 } SCALE;
 
 void LoadIntoExtraScreen (RECT *r);
+void LoadIntoExtraScreen_Fs (RECT *r); // JMS_GFX
 void DrawFromExtraScreen (RECT *r);
+void DrawFromExtraScreen_Fs (RECT *r); // JMS_GFX
 int SetGraphicScale (int scale);
 int GetGraphicScale (void);
 int SetGraphicScaleMode (int mode /* enum SCALE */);
@@ -99,6 +103,9 @@ extern int FrameRateTickBase;
 
 void TFB_FlushGraphics (void); // Only call from main thread!!
 
+// JMS_GFX
+extern unsigned int resolutionFactor;
+
 extern int ScreenWidth;
 extern int ScreenHeight;
 extern int ScreenWidthActual;
diff -ruNp src.orig/libs/graphics/intersec.c src/libs/graphics/intersec.c
--- src.orig/libs/graphics/intersec.c	2017-11-01 15:30:19 -0700
+++ src/libs/graphics/intersec.c	2017-11-01 15:30:56 -0700
@@ -21,8 +21,8 @@
 #include "libs/graphics/tfb_draw.h"
 #include "libs/log.h"
 
-//#define DEBUG_INTERSEC
-
+// #define DEBUG_INTERSEC
+ 
 static inline BOOLEAN
 images_intersect (IMAGE_BOX *box1, IMAGE_BOX *box2, const RECT *rect)
 {
@@ -30,16 +30,17 @@ images_intersect (IMAGE_BOX *box1, IMAGE
 			box2->FramePtr->image, box2->Box.corner, rect);
 }
 
+// JMS: Changed SIZEs to SDWORDs to prevent overflows. Ditto for COUNTs -> to DWORDs.
 static TIME_VALUE
 frame_intersect (INTERSECT_CONTROL *pControl0, RECT *pr0,
 		INTERSECT_CONTROL *pControl1, RECT *pr1, TIME_VALUE t0,
 		TIME_VALUE t1)
 {
-	SIZE time_error0, time_error1;
-	SIZE cycle0, cycle1;
-	SIZE dx_0, dy_0, dx_1, dy_1;
-	SIZE xincr0, yincr0, xincr1, yincr1;
-	SIZE xerror0, xerror1, yerror0, yerror1;
+	SDWORD time_error0, time_error1;
+	SDWORD cycle0, cycle1;
+	SDWORD dx_0, dy_0, dx_1, dy_1;
+	SDWORD xincr0, yincr0, xincr1, yincr1;
+	SDWORD xerror0, xerror1, yerror0, yerror1;
 	RECT r_intersect;
 	IMAGE_BOX IB0, IB1;
 	BOOLEAN check0, check1;
@@ -109,56 +110,56 @@ frame_intersect (INTERSECT_CONTROL *pCon
 	}
 	else
 	{
-		SIZE delta;
-		COUNT start;
+		SDWORD delta;
+		DWORD start;
 		long error;
 
-		start = (COUNT)cycle0 * (COUNT)(t0 - 1);
+		start = (DWORD)cycle0 * (DWORD)(t0 - 1);
 		time_error0 = start & ((1 << TIME_SHIFT) - 1);
-		if ((start >>= (COUNT)TIME_SHIFT) > 0)
+		if ((start >>= (DWORD)TIME_SHIFT) > 0)
 		{
 			if ((error = (long)xerror0
 					- (long)dx_0 * (long)start) > 0)
-				xerror0 = (SIZE)error;
+				xerror0 = (SDWORD)error;
 			else
 			{
-				delta = -(SIZE)(error / (long)cycle0) + 1;
+				delta = -(SDWORD)(error / (long)cycle0) + 1;
 				IB0.Box.corner.x += xincr0 * delta;
-				xerror0 = (SIZE)(error + (long)cycle0 * (long)delta);
+				xerror0 = (SDWORD)(error + (long)cycle0 * (long)delta);
 			}
 			if ((error = (long)yerror0
 					- (long)dy_0 * (long)start) > 0)
-				yerror0 = (SIZE)error;
+				yerror0 = (SDWORD)error;
 			else
 			{
-				delta = -(SIZE)(error / (long)cycle0) + 1;
+				delta = -(SDWORD)(error / (long)cycle0) + 1;
 				IB0.Box.corner.y += yincr0 * delta;
-				yerror0 = (SIZE)(error + (long)cycle0 * (long)delta);
+				yerror0 = (SDWORD)(error + (long)cycle0 * (long)delta);
 			}
 			pr0->corner = IB0.Box.corner;
 		}
 	
-		start = (COUNT)cycle1 * (COUNT)(t0 - 1);
+		start = (DWORD)cycle1 * (DWORD)(t0 - 1);
 		time_error1 = start & ((1 << TIME_SHIFT) - 1);
-		if ((start >>= (COUNT)TIME_SHIFT) > 0)
+		if ((start >>= (DWORD)TIME_SHIFT) > 0)
 		{
 			if ((error = (long)xerror1
 					- (long)dx_1 * (long)start) > 0)
-				xerror1 = (SIZE)error;
+				xerror1 = (SDWORD)error;
 			else
 			{
-				delta = -(SIZE)(error / (long)cycle1) + 1;
+				delta = -(SDWORD)(error / (long)cycle1) + 1;
 				IB1.Box.corner.x += xincr1 * delta;
-				xerror1 = (SIZE)(error + (long)cycle1 * (long)delta);
+				xerror1 = (SDWORD)(error + (long)cycle1 * (long)delta);
 			}
 			if ((error = (long)yerror1
 					- (long)dy_1 * (long)start) > 0)
-				yerror1 = (SIZE)error;
+				yerror1 = (SDWORD)error;
 			else
 			{
-				delta = -(SIZE)(error / (long)cycle1) + 1;
+				delta = -(SDWORD)(error / (long)cycle1) + 1;
 				IB1.Box.corner.y += yincr1 * delta;
-				yerror1 = (SIZE)(error + (long)cycle1 * (long)delta);
+				yerror1 = (SDWORD)(error + (long)cycle1 * (long)delta);
 			}
 			pr1->corner = IB1.Box.corner;
 		}
@@ -233,12 +234,12 @@ CheckFirstIntersection:
 	return ((TIME_VALUE)0);
 }
 
+// JMS: Changed SIZEs to SDWORDs to preven overflows.
 TIME_VALUE
-DrawablesIntersect (INTERSECT_CONTROL *pControl0,
-		INTERSECT_CONTROL *pControl1, TIME_VALUE max_time_val)
+DrawablesIntersect (INTERSECT_CONTROL *pControl0, INTERSECT_CONTROL *pControl1, TIME_VALUE max_time_val)
 {
-	SIZE dy;
-	SIZE time_y_0, time_y_1;
+	SDWORD dy;
+	SDWORD time_y_0, time_y_1;
 	RECT r0, r1;
 	FRAME FramePtr0, FramePtr1;
 
@@ -278,8 +279,8 @@ DrawablesIntersect (INTERSECT_CONTROL *p
 			|| (time_y_0 > 0 && dy >= time_y_0)
 			|| (time_y_1 < 0 && dy <= time_y_1))
 	{
-		SIZE dx;
-		SIZE time_x_0, time_x_1;
+		SDWORD dx;
+		SDWORD time_x_0, time_x_1;
 
 		dx = r1.corner.x - r0.corner.x;
 		time_x_0 = dx - GetFrameWidth (FramePtr0) + 1;
@@ -296,7 +297,7 @@ DrawablesIntersect (INTERSECT_CONTROL *p
 				time_y_0 = time_y_1 = 0;
 			else
 			{
-				SIZE t;
+				SDWORD t;
 				long time_beg, time_end, fract;
 
 				if (time_y_1 < 0)
@@ -379,14 +380,14 @@ DrawablesIntersect (INTERSECT_CONTROL *p
 				if ((time_beg <<= TIME_SHIFT) < fract)
 					time_y_0 = 0;
 				else
-					time_y_0 = (SIZE)(time_beg / fract);
+					time_y_0 = (SDWORD)(time_beg / fract);
 
 				if (time_end >= fract /* just in case of overflow */
 						|| (time_end <<= TIME_SHIFT) >=
 						fract * (long)max_time_val)
 					time_y_1 = max_time_val - 1;
 				else
-					time_y_1 = (SIZE)((time_end + fract - 1) / fract) - 1;
+					time_y_1 = (SDWORD)((time_end + fract - 1) / fract) - 1;
 			}
 
 #ifdef DEBUG_INTERSEC
@@ -405,11 +406,15 @@ DrawablesIntersect (INTERSECT_CONTROL *p
 				pControl1->EndPoint.x = r1.corner.x + FramePtr1->HotSpot.x;
 				pControl1->EndPoint.y = r1.corner.y + FramePtr1->HotSpot.y;
 
+#ifdef DEBUG_INTERSEC
+				log_add (log_Debug, "intersecttime = %d",
+						 intersect_time);
+#endif /* DEBUG_INTERSEC */
+				
 				return (intersect_time);
 			}
 		}
 	}
-
 	return ((TIME_VALUE)0);
 }
 
diff -ruNp src.orig/libs/graphics/sdl/opengl.c src/libs/graphics/sdl/opengl.c
--- src.orig/libs/graphics/sdl/opengl.c	2017-11-01 15:30:19 -0700
+++ src/libs/graphics/sdl/opengl.c	2017-11-01 15:30:56 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2011: Merged resolution Factor stuff from UQM-HD.
+
 #ifdef HAVE_OPENGL
 
 #include "libs/graphics/sdl/opengl.h"
@@ -161,17 +163,22 @@ AttemptColorDepth (int flags, int width,
 }
 
 int
-TFB_GL_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen)
+TFB_GL_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen, unsigned int resolutionFactor)  // JMS_GFX: Added resolutionFactor
 {
 	int i, texture_width, texture_height;
+  unsigned int temp;
 	GraphicsDriver = driver;
+	
+	// JMS_GFX: A temporary hack just to shut up the compiler. We might use resolutionFactor in openGL
+	// someday so keeping the passed variable in the function variables for now.
+	temp = resolutionFactor;
 
 	if (AttemptColorDepth (flags, width, height, 32) &&
 			AttemptColorDepth (flags, width, height, 24) &&
 			AttemptColorDepth (flags, width, height, 16))
 	{
-		log_add (log_Error, "Couldn't set any OpenGL %ix%i video mode!",
-			 width, height);
+		log_add (log_Error, "Couldn't set any OpenGL %ix%i video mode!, resFactor %d",
+			 width, height, temp);
 		return -1;
 	}
 
@@ -271,7 +278,7 @@ TFB_GL_ConfigureVideo (int driver, int f
 }
 
 int
-TFB_GL_InitGraphics (int driver, int flags, int width, int height)
+TFB_GL_InitGraphics (int driver, int flags, int width, int height, unsigned int resolutionFactor)  // JMS_GFX: Added resolutionFactor
 {
 	char VideoName[256];
 
@@ -282,10 +289,10 @@ TFB_GL_InitGraphics (int driver, int fla
 	log_add (log_Info, "SDL initialized.");
 	log_add (log_Info, "Initializing Screen.");
 
-	ScreenWidth = 320;
-	ScreenHeight = 240;
+	ScreenWidth =  (320 << resolutionFactor); // JMS_GFX
+	ScreenHeight = (240 << resolutionFactor); // JMS_GFX
 
-	if (TFB_GL_ConfigureVideo (driver, flags, width, height, 0))
+	if (TFB_GL_ConfigureVideo (driver, flags, width, height, 0, resolutionFactor))  // JMS_GFX: Added resolutionFactor
 	{
 		log_add (log_Fatal, "Could not initialize video: "
 				"no fallback at start of program!");
diff -ruNp src.orig/libs/graphics/sdl/opengl.h src/libs/graphics/sdl/opengl.h
--- src.orig/libs/graphics/sdl/opengl.h	2017-11-01 15:30:19 -0700
+++ src/libs/graphics/sdl/opengl.h	2017-11-01 15:30:56 -0700
@@ -16,13 +16,15 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2011: Merged resolution Factor stuff from UQM-HD.
+
 #ifndef OPENGL_H
 #define OPENGL_H
 
 #include "libs/graphics/sdl/sdl_common.h"
 
-int TFB_GL_InitGraphics (int driver, int flags, int width, int height);
-int TFB_GL_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen);
+int TFB_GL_InitGraphics (int driver, int flags, int width, int height, unsigned int resolutionFactor);  // JMS_GFX: Added resolutionFactor
+int TFB_GL_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen, unsigned int resolutionFactor);  // JMS_GFX: Added resolutionFactor
 void TFB_GL_UploadTransitionScreen (void);
 
 #ifdef HAVE_OPENGL
diff -ruNp src.orig/libs/graphics/sdl/pure.c src/libs/graphics/sdl/pure.c
--- src.orig/libs/graphics/sdl/pure.c	2017-11-01 15:30:19 -0700
+++ src/libs/graphics/sdl/pure.c	2017-11-01 15:30:56 -0700
@@ -15,6 +15,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2011: Merged resolution Factor stuff from UQM-HD.
+
 #include "pure.h"
 #include "libs/graphics/bbox.h"
 #include "scalers.h"
@@ -124,49 +126,76 @@ CalcAlphaFormat (const SDL_PixelFormat*
 }
 
 int
-TFB_Pure_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen)
+TFB_Pure_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen, unsigned int resolutionFactor)  // JMS_GFX: Added resolutionFactor
 {
-	int i, videomode_flags;
+	int i, videomode_flags, videomode_flags_windowed;
+	int forced_windowed_mode = 0;
 	SDL_PixelFormat conv_fmt;
 	
 	GraphicsDriver = driver;
 
-	// must use SDL_SWSURFACE, HWSURFACE doesn't work properly
-	// with fades/scaling
+	// JMS_GFX: Normal 320x240 mode.
 	if (width == 320 && height == 240)
 	{
-		videomode_flags = SDL_SWSURFACE;
 		ScreenWidthActual = 320;
 		ScreenHeightActual = 240;
 		graphics_backend = &pure_unscaled_backend;
 	}
 	else
-	{
-		videomode_flags = SDL_SWSURFACE;
-		ScreenWidthActual = 640;
-		ScreenHeightActual = 480;
-		graphics_backend = &pure_scaled_backend;
-
-		if (width != 640 || height != 480)
-			log_add (log_Error, "Screen resolution of %dx%d not supported "
-					"under pure SDL, using 640x480", width, height);
+	{		
+		// JMS_GFX: Normal 640x480 mode.
+		if (resolutionFactor == 0)
+		{
+			ScreenWidthActual = 640;
+			ScreenHeightActual = 480;
+			graphics_backend = &pure_scaled_backend;
+		}
+		else
+		{
+			// JMS_GFX: Hi-res modes.
+			ScreenWidthActual  = (320 << resolutionFactor);
+			ScreenHeightActual = (240 << resolutionFactor);
+			
+			graphics_backend = &pure_unscaled_backend;
+		}
 	}
-
+	
+	// must use SDL_SWSURFACE, HWSURFACE doesn't work properly with fades/scaling
+	videomode_flags = SDL_SWSURFACE;
 	videomode_flags |= SDL_ANYFORMAT;
+	videomode_flags_windowed = videomode_flags; // JMS_GFX: Video mode flags without fullscreen flag.
+	
 	if (flags & TFB_GFXFLAGS_FULLSCREEN)
 		videomode_flags |= SDL_FULLSCREEN;
 
 	/* We'll ask for a 32bpp frame, but it doesn't really matter, because we've set
 	   SDL_ANYFORMAT */
-	SDL_Video = SDL_SetVideoMode (ScreenWidthActual, ScreenHeightActual, 
-		32, videomode_flags);
+	SDL_Video = SDL_SetVideoMode (ScreenWidthActual, ScreenHeightActual, 32, videomode_flags);
 
 	if (SDL_Video == NULL)
 	{
-		log_add (log_Error, "Couldn't set %ix%i video mode: %s",
-			ScreenWidthActual, ScreenHeightActual,
-			SDL_GetError ());
-		return -1;
+		log_add (log_Error, "Couldn't set %ix%i video mode: %s", ScreenWidthActual, ScreenHeightActual, SDL_GetError ());
+		
+		// JMS_GFX: If video mode cannot be set in fullscreen, try to set it in windowed mode.
+		// This is useful when playing e.g. on laptop with an external monitor connected. The fullscreen
+		// video mode setup only takes into account the smaller laptop monitor and if it's too small
+		// for e.g. 1280x960, you would normally be thrown back to Desktop.
+		// Now, windowed mode is invoked instead of terminating, and you can drag this window to the 
+		// larger screen.
+		log_add (log_Error, "Trying the same resolution now in windowed mode.");
+		SDL_Video = SDL_SetVideoMode (ScreenWidthActual, ScreenHeightActual, 32, videomode_flags_windowed);
+		forced_windowed_mode = 1;
+		togglefullscreen = 0;
+		
+		// JMS_GFX If even the windowed mode doesn't work, then screw it all. Return.
+		if (SDL_Video == NULL)
+		{
+			log_add (log_Error, "Couldn't set %ix%i mode in windowed mode either: %s",
+					 ScreenWidthActual, ScreenHeightActual,
+					 SDL_GetError ());
+		
+			return -1;
+		}
 	}
 	else
 	{
@@ -207,8 +236,7 @@ TFB_Pure_ConfigureVideo (int driver, int
 			conv_fmt.Bmask, conv_fmt.Amask);
 	if (!format_conv_surf)
 	{
-		log_add (log_Error, "Couldn't create format_conv_surf: %s",
-				SDL_GetError());
+		log_add (log_Error, "Couldn't create format_conv_surf: %s", SDL_GetError());
 		return -1;
 	}
 	else
@@ -220,44 +248,44 @@ TFB_Pure_ConfigureVideo (int driver, int
 	
 	for (i = 0; i < TFB_GFX_NUMSCREENS; i++)
 	{
-		if (0 != ReInit_Screen (&SDL_Screens[i], format_conv_surf,
-				ScreenWidth, ScreenHeight))
+		if (0 != ReInit_Screen (&SDL_Screens[i], format_conv_surf, ScreenWidth, ScreenHeight))
 			return -1;
 	}
 
+
 	SDL_Screen = SDL_Screens[0];
 	TransitionScreen = SDL_Screens[2];
 
-	if (0 != ReInit_Screen (&fade_color_surface, format_conv_surf,
-			ScreenWidth, ScreenHeight))
+	if (0 != ReInit_Screen (&fade_color_surface, format_conv_surf, ScreenWidth, ScreenHeight))
 		return -1;
+
 	fade_color = SDL_MapRGB (fade_color_surface->format, 0, 0, 0);
 	SDL_FillRect (fade_color_surface, NULL, fade_color);
 	
-	if (0 != ReInit_Screen (&fade_temp, format_conv_surf,
-			ScreenWidth, ScreenHeight))
+	if (0 != ReInit_Screen (&fade_temp, format_conv_surf, ScreenWidth, ScreenHeight))
 		return -1;
 
-	if (ScreenWidthActual > ScreenWidth || ScreenHeightActual > ScreenHeight)
+	if ((ScreenWidthActual > ScreenWidth || ScreenHeightActual > ScreenHeight) || 
+		(ScreenWidthActual== 640 && ScreenHeightActual == 480 && resolutionFactor == 0)) // JMS_GFX
 	{
-		if (0 != ReInit_Screen (&scaled_display, format_conv_surf,
-				ScreenWidthActual, ScreenHeightActual))
+		if (0 != ReInit_Screen (&scaled_display, format_conv_surf, ScreenWidthActual, ScreenHeightActual))
 			return -1;
 
 		scaler = Scale_PrepPlatform (flags, SDL_Screen->format);
 	}
 	else
 	{	// no need to scale
+
 		scaler = NULL;
 	}
-
-	return 0;
+	return forced_windowed_mode;
 }
 
 int
-TFB_Pure_InitGraphics (int driver, int flags, int width, int height)
+TFB_Pure_InitGraphics (int driver, int flags, int width, int height, unsigned int resolutionFactor)  // JMS_GFX: Added resolutionFactor
 {
-	char VideoName[256];
+	char	VideoName[256];
+	int		config_video_result = 0;
 
 	log_add (log_Info, "Initializing Pure-SDL graphics.");
 
@@ -270,21 +298,20 @@ TFB_Pure_InitGraphics (int driver, int f
 
 	log_add (log_Info, "SDL initialized.");
 	log_add (log_Info, "Initializing Screen.");
-
-	ScreenWidth = 320;
-	ScreenHeight = 240;
-
-	if (TFB_Pure_ConfigureVideo (driver, flags, width, height, 0))
-	{
-		log_add (log_Fatal, "Could not initialize video: "
-				"no fallback at start of program!");
-		exit (EXIT_FAILURE);
-	}
+	
+	// JMS_GFX: Resolution is calculated with the help of a Resolution factor.
+	ScreenWidth  = (320 << resolutionFactor); // 320
+	ScreenHeight = (240 << resolutionFactor); // 240
+	
+	config_video_result = TFB_Pure_ConfigureVideo (driver, flags, width, height, 0, resolutionFactor);
+	
+	if (config_video_result < 0) // JMS_GFX: Added resolutionFactor. Added check '< 0' since now '1' may be returned and it's not an error.
+		log_add (log_Fatal, "Could not initialize video: " "no fallback at start of program!");
 
 	// Initialize scalers (let them precompute whatever)
 	Scale_Init ();
 
-	return 0;
+	return config_video_result;
 }
 
 static void
@@ -384,7 +411,7 @@ TFB_Pure_Scaled_Postprocess (void)
 		
 	SDL_UnlockSurface (backbuffer);
 	SDL_UnlockSurface (scalebuffer);
-
+	
 	updated.x *= 2;
 	updated.y *= 2;
 	updated.w *= 2;
@@ -397,7 +424,7 @@ TFB_Pure_Scaled_Postprocess (void)
 
 static void
 TFB_Pure_Unscaled_Postprocess (void)
-{
+{	
 	SDL_UpdateRect (SDL_Video, updated.x, updated.y,
 			updated.w, updated.h);
 }
diff -ruNp src.orig/libs/graphics/sdl/pure.h src/libs/graphics/sdl/pure.h
--- src.orig/libs/graphics/sdl/pure.h	2017-11-01 15:30:19 -0700
+++ src/libs/graphics/sdl/pure.h	2017-11-01 15:30:56 -0700
@@ -16,13 +16,15 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2011: Merged resolution Factor stuff from UQM-HD.
+
 #ifndef PURE_H
 #define PURE_H
 
 #include "libs/graphics/sdl/sdl_common.h"
 
-int TFB_Pure_InitGraphics (int driver, int flags, int width, int height);
-int TFB_Pure_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen);
+int TFB_Pure_InitGraphics (int driver, int flags, int width, int height, unsigned int resolutionFactor);  // JMS_GFX: Added resolutionFactor
+int TFB_Pure_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen, unsigned int resolutionFactor);  // JMS_GFX: Added resolutionFactor
 void Scale_PerfTest (void);
 
 #endif
diff -ruNp src.orig/libs/graphics/sdl/sdl_common.c src/libs/graphics/sdl/sdl_common.c
--- src.orig/libs/graphics/sdl/sdl_common.c	2017-11-01 15:30:19 -0700
+++ src/libs/graphics/sdl/sdl_common.c	2017-11-01 15:30:56 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2011: Added resolutionfactor to TFB_reInitGraphics and TFB_InitGraphics definitions and calls.
+
 #include "sdl_common.h"
 #include "opengl.h"
 #include "pure.h"
@@ -79,7 +81,7 @@ TFB_PreInit (void)
 }
 
 int
-TFB_ReInitGraphics (int driver, int flags, int width, int height)
+TFB_ReInitGraphics (int driver, int flags, int width, int height, unsigned int resolutionFactor) // JMS_GFX: Added resolutionFactor
 {
 	int result;
 	int togglefullscreen = 0;
@@ -97,25 +99,29 @@ TFB_ReInitGraphics (int driver, int flag
 	if (driver == TFB_GFXDRIVER_SDL_OPENGL)
 	{
 #ifdef HAVE_OPENGL
-		result = TFB_GL_ConfigureVideo (driver, flags, width, height,
-				togglefullscreen);
+		result = TFB_GL_ConfigureVideo (driver, flags, width, height, togglefullscreen, resolutionFactor); // JMS_GFX: Added resolutionFactor
 #else
 		driver = TFB_GFXDRIVER_SDL_PURE;
 		log_add (log_Warning, "OpenGL support not compiled in,"
 				" so using pure SDL driver");
-		result = TFB_Pure_ConfigureVideo (driver, flags, width, height,
-				togglefullscreen);
+		result = TFB_Pure_ConfigureVideo (driver, flags, width, height, togglefullscreen, resolutionFactor); // JMS_GFX: Added resolutionFactor
 #endif
 	}
 	else
 	{
-		result = TFB_Pure_ConfigureVideo (driver, flags, width, height,
-				togglefullscreen);
+		result = TFB_Pure_ConfigureVideo (driver, flags, width, height, togglefullscreen, resolutionFactor); // JMS_GFX: Added resolutionFactor
+	}
+	
+	// JMS_GFX: If we forced windowed mode when switching resolution, remove fullscreen from flags.
+	if (result == 1)
+	{
+		flags &= ~TFB_GFXFLAGS_FULLSCREEN;
+		GfxFlags = flags;
 	}
 
-	sprintf (caption, "The Ur-Quan Masters v%d.%d.%d%s",
-			UQM_MAJOR_VERSION, UQM_MINOR_VERSION,
-			UQM_PATCH_VERSION, UQM_EXTRA_VERSION);
+	sprintf (caption, "The Ur-Quan Masters project6014 v%d.%d.%d%s",
+			P6014_MAJOR_VERSION, P6014_MINOR_VERSION,
+			P6014_PATCH_VERSION, P6014_EXTRA_VERSION);
 	SDL_WM_SetCaption (caption, NULL);
 
 	if (flags & TFB_GFXFLAGS_FULLSCREEN)
@@ -127,11 +133,11 @@ TFB_ReInitGraphics (int driver, int flag
 }
 
 int
-TFB_InitGraphics (int driver, int flags, int width, int height)
+TFB_InitGraphics (int driver, int flags, int width, int height, unsigned int resolutionFactor) // JMS_GFX: added resolutionFactor
 {
 	int result, i;
 	char caption[200];
-
+	
 	/* Null out screen pointers the first time */
 	for (i = 0; i < TFB_GFX_NUMSCREENS; i++)
 	{
@@ -143,23 +149,30 @@ TFB_InitGraphics (int driver, int flags,
 	if (driver == TFB_GFXDRIVER_SDL_OPENGL)
 	{
 #ifdef HAVE_OPENGL
-		result = TFB_GL_InitGraphics (driver, flags, width, height);
+		result = TFB_GL_InitGraphics (driver, flags, width, height, resolutionFactor); // JMS_GFX: added resolutionFactor
 #else
 		driver = TFB_GFXDRIVER_SDL_PURE;
 		log_add (log_Warning, "OpenGL support not compiled in,"
 				" so using pure SDL driver");
-		result = TFB_Pure_InitGraphics (driver, flags, width, height);
+		result = TFB_Pure_InitGraphics (driver, flags, width, height, resolutionFactor); // JMS_GFX: added resolutionFactor
 #endif
 	}
 	else
 	{
-		result = TFB_Pure_InitGraphics (driver, flags, width, height);
+		result = TFB_Pure_InitGraphics (driver, flags, width, height, resolutionFactor); // JMS_GFX: added resolutionFactor
 	}
 
-	sprintf (caption, "The Ur-Quan Masters v%d.%d.%d%s", 
-			UQM_MAJOR_VERSION, UQM_MINOR_VERSION, 
-			UQM_PATCH_VERSION, UQM_EXTRA_VERSION);
+	sprintf (caption, "The Ur-Quan Masters project6014 v%d.%d.%d%s", 
+			P6014_MAJOR_VERSION, P6014_MINOR_VERSION, 
+			P6014_PATCH_VERSION, P6014_EXTRA_VERSION);
 	SDL_WM_SetCaption (caption, NULL);
+	
+	// JMS_GFX: If we forced windowed mode when switching resolution, remove fullscreen from flags.
+	if (result == 1)
+	{
+		flags &= ~TFB_GFXFLAGS_FULLSCREEN;
+		GfxFlags = flags;
+	}
 
 	if (flags & TFB_GFXFLAGS_FULLSCREEN)
 		SDL_ShowCursor (SDL_DISABLE);
diff -ruNp src.orig/libs/graphics/tfb_draw.c src/libs/graphics/tfb_draw.c
--- src.orig/libs/graphics/tfb_draw.c	2017-11-01 15:30:19 -0700
+++ src/libs/graphics/tfb_draw.c	2017-11-01 15:30:56 -0700
@@ -154,6 +154,28 @@ TFB_DrawScreen_Copy (const RECT *r, SCRE
 	TFB_EnqueueDrawCommand (&DC);
 }
 
+// JMS_GFX: This ensures the whole screen area is updated in screen transition.
+// Useful at least in hires when landing at planet and transitioning to planetside view.
+// (The planet is cut uglily in about half when using normal TFB_DrawScreen_Copy).
+void
+TFB_DrawScreen_Copy_Fs (RECT *r, SCREEN src, SCREEN dest)
+{
+	RECT locRect;
+	TFB_DrawCommand DC;
+	
+	locRect.corner.x = locRect.corner.y = 0;
+	locRect.extent.width = ScreenWidth;
+	locRect.extent.height = ScreenHeight;
+	r = &locRect;
+
+	DC.Type = TFB_DRAWCOMMANDTYPE_COPY;
+	DC.data.copy.rect = locRect;
+	DC.data.copy.srcBuffer = src;
+	DC.data.copy.destBuffer = dest;
+	
+	TFB_EnqueueDrawCommand (&DC);
+}
+
 void
 TFB_DrawScreen_SetMipmap (TFB_Image *img, TFB_Image *mmimg, int hotx, int hoty)
 {
diff -ruNp src.orig/libs/graphics/tfb_draw.h src/libs/graphics/tfb_draw.h
--- src.orig/libs/graphics/tfb_draw.h	2017-11-01 15:30:19 -0700
+++ src/libs/graphics/tfb_draw.h	2017-11-01 15:30:56 -0700
@@ -84,6 +84,7 @@ void TFB_DrawScreen_Rect (RECT *rect, Co
 void TFB_DrawScreen_Image (TFB_Image *img, int x, int y, int scale,
 		int scaleMode, TFB_ColorMap *, DrawMode, SCREEN dest);
 void TFB_DrawScreen_Copy (const RECT *r, SCREEN src, SCREEN dest);
+void TFB_DrawScreen_Copy_Fs (RECT *r, SCREEN src, SCREEN dest); // JMS_GFX
 void TFB_DrawScreen_FilledImage (TFB_Image *img, int x, int y, int scale,
 		int scaleMode, Color, DrawMode, SCREEN dest);
 void TFB_DrawScreen_FontChar (TFB_Char *, TFB_Image *backing, int x, int y,
diff -ruNp src.orig/libs/graphics/tfb_prim.c src/libs/graphics/tfb_prim.c
--- src.orig/libs/graphics/tfb_prim.c	2017-11-01 15:30:19 -0700
+++ src/libs/graphics/tfb_prim.c	2017-11-01 15:30:56 -0700
@@ -135,7 +135,7 @@ TFB_Prim_Stamp (STAMP *stmp, DrawMode mo
 		return;
 	}
 	img = SrcFramePtr->image;
-	
+
 	if (!img)
 	{
 		log_add (log_Warning, "Non-existent image to TFB_Prim_Stamp()");
diff -ruNp src.orig/libs/graphics/widgets.c src/libs/graphics/widgets.c
--- src.orig/libs/graphics/widgets.c	2017-11-01 15:30:19 -0700
+++ src/libs/graphics/widgets.c	2017-11-01 15:30:56 -0700
@@ -14,6 +14,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
 #include "gfx_common.h"
 #include "widgets.h"
 #include "libs/strlib.h"
@@ -98,7 +100,7 @@ DrawLabelAsWindow (WIDGET_LABEL *label,
 		oldfont = SetContextFont (cur_font);
 
 	/* Compute the dimensions of the label */
-	win_h = label->height ((WIDGET *)label) + 16;
+	win_h = label->height ((WIDGET *)label) + (16 << resolutionFactor); // JMS_GFX
 	win_w = 0;
 	for (i = 0; i < label->line_count; i++)
 	{
@@ -108,7 +110,7 @@ DrawLabelAsWindow (WIDGET_LABEL *label,
 			win_w = len;
 		}
 	}
-	win_w = (win_w * 6) + 16;
+	win_w = (win_w * (6 << resolutionFactor)) + (16 << resolutionFactor); // JMS_GFX
 
 	BatchGraphics ();
 	r.corner.x = (ScreenWidth - win_w) >> 1;
@@ -118,14 +120,14 @@ DrawLabelAsWindow (WIDGET_LABEL *label,
 	DrawShadowedBox (&r, win_bg_clr, win_dark_clr, win_medium_clr);
 
 	t.baseline.x = r.corner.x + (r.extent.width >> 1);
-	t.baseline.y = r.corner.y + 16;
+	t.baseline.y = r.corner.y + (16 << resolutionFactor); // JMS_GFX
 	for (i = 0; i < label->line_count; i++)
 	{
 		t.pStr = label->lines[i];
 		t.align = ALIGN_CENTER;
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
-		t.baseline.y += 8;
+		t.baseline.y += (8 << resolutionFactor); // JMS_GFX
 	}
 
 	UnbatchGraphics ();
@@ -139,10 +141,10 @@ DrawLabelAsWindow (WIDGET_LABEL *label,
 		// Add the outer border added by DrawShadowedBox.
 		// XXX: It may be nicer to add a border size parameter to
 		// DrawShadowedBox, instead of assuming 2 here.
-		windowRect->corner.x = r.corner.x - 2;
-		windowRect->corner.y = r.corner.y - 2;
-		windowRect->extent.width = r.extent.width + 4;
-		windowRect->extent.height = r.extent.height + 4;
+		windowRect->corner.x = r.corner.x - 2 * (1 + resolutionFactor);
+		windowRect->corner.y = r.corner.y - 2 * (1 + resolutionFactor);
+		windowRect->extent.width = r.extent.width + 4 * (1 + resolutionFactor);
+		windowRect->extent.height = r.extent.height + 4 * (1 + resolutionFactor);
 	}
 }
 
@@ -165,6 +167,9 @@ Widget_SetFont (FONT newFont)
 static void
 Widget_DrawToolTips (int numlines, const char **tips)
 {
+	// This functions draws the text at the bottom of the screen
+	// which explains what the current option does.
+	
 	RECT r;
 	FONT  oldfont = 0;
 	FRAME oldFontEffect = SetContextFontEffect (NULL);
@@ -175,21 +180,21 @@ Widget_DrawToolTips (int numlines, const
 	if (cur_font)
 		oldfont = SetContextFont (cur_font);
 
-	r.corner.x = 2;
-	r.corner.y = 2;
-	r.extent.width = ScreenWidth - 4;
-	r.extent.height = ScreenHeight - 4;
+	r.corner.x = 2 << resolutionFactor; // JMS_GFX
+	r.corner.y = 2 << resolutionFactor; // JMS_GFX
+	r.extent.width = ScreenWidth - (4 << resolutionFactor); // JMS_GFX
+	r.extent.height = ScreenHeight - (4 << resolutionFactor); // JMS_GFX
 
 	t.align = ALIGN_CENTER;
 	t.CharCount = ~0;
 	t.baseline.x = r.corner.x + (r.extent.width >> 1);
-	t.baseline.y = r.corner.y + (r.extent.height - 8 - 8 * numlines);
+	t.baseline.y = r.corner.y + (r.extent.height - (8 << resolutionFactor) - (8 << resolutionFactor) * numlines); // JMS_GFX
 
 	for (i = 0; i < numlines; i++)
 	{
 		t.pStr = tips[i];
 		font_DrawText(&t);
-		t.baseline.y += 8;
+		t.baseline.y += (8 << resolutionFactor); // JMS_GFX
 	}
 
 	SetContextFontEffect (oldFontEffect);
@@ -214,10 +219,10 @@ Widget_DrawMenuScreen (WIDGET *_self, in
 	if (cur_font)
 		oldfont = SetContextFont (cur_font);
 	
-	r.corner.x = 2;
-	r.corner.y = 2;
-	r.extent.width = ScreenWidth - 4;
-	r.extent.height = ScreenHeight - 4;
+	r.corner.x = (2 << resolutionFactor) + 2 * resolutionFactor; // JMS_GFX
+	r.corner.y = (2 << resolutionFactor); // JMS_GFX
+	r.extent.width = ScreenWidth - (4 << resolutionFactor); // JMS_GFX
+	r.extent.height = ScreenHeight - (4 << resolutionFactor); // JMS_GFX
 	
 	title = WIDGET_INACTIVE_SELECTED_COLOR;
 	selected = WIDGET_ACTIVE_COLOR;
@@ -228,12 +233,12 @@ Widget_DrawMenuScreen (WIDGET *_self, in
 	
 	oldtext = SetContextForeGroundColor (title);
 	t.baseline.x = r.corner.x + (r.extent.width >> 1);
-	t.baseline.y = r.corner.y + 8;
+	t.baseline.y = r.corner.y + (8 << resolutionFactor); // JMS_GFX
 	t.pStr = self->title;
 	t.align = ALIGN_CENTER;
 	t.CharCount = ~0;
 	font_DrawText (&t);
-	t.baseline.y += 8;
+	t.baseline.y += 8 << resolutionFactor; // JMS_GFX
 	t.pStr = self->subtitle;
 	font_DrawText (&t);
 
@@ -242,17 +247,17 @@ Widget_DrawMenuScreen (WIDGET *_self, in
 	{
 		WIDGET *child = self->child[widget_index];
 		height += (*child->height)(child);
-		height += 8;  /* spacing */
+		height += 8 << resolutionFactor; // JMS_GFX  /* spacing */
 	}
 
-	height -= 8;
+	height -= 8 << resolutionFactor; // JMS_GFX
 
 	widget_y = (ScreenHeight - height) >> 1;
 	for (widget_index = 0; widget_index < self->num_children; widget_index++)
 	{
 		WIDGET *c = self->child[widget_index];
 		(*c->draw)(c, 0, widget_y);
-		widget_y += (*c->height)(c) + 8;
+		widget_y += (*c->height)(c) + (8 << resolutionFactor); // JMS_GFX
 	}
 	
 	SetContextFontEffect (oldFontEffect);
@@ -282,7 +287,7 @@ Widget_DrawChoice (WIDGET *_self, int x,
 	selected = WIDGET_ACTIVE_COLOR;
 	inactive = WIDGET_INACTIVE_COLOR;
 
-	t.baseline.x = x;
+	t.baseline.x = x + 64 * resolutionFactor; // JMS_GFX
 	t.baseline.y = y;
 	t.align = ALIGN_LEFT;
 	t.CharCount = ~0;
@@ -296,15 +301,18 @@ Widget_DrawChoice (WIDGET *_self, int x,
 		oldtext = SetContextForeGroundColor (default_color);
 	}
 	font_DrawText (&t);
+	
+	t.baseline.x -= 64 * resolutionFactor; // JMS_GFX
 
 	home_x = t.baseline.x + 3 * (ScreenWidth / ((self->maxcolumns + 1) * 2));
 	home_y = t.baseline.y;
 	t.align = ALIGN_CENTER;
+	
 	for (i = 0; i < self->numopts; i++)
 	{
 		t.baseline.x = home_x + ((i % 3) *
 				(ScreenWidth / (self->maxcolumns + 1)));
-		t.baseline.y = home_y + (8 * (i / 3));
+		t.baseline.y = home_y + ((8 * (i / 3)) << resolutionFactor); // JMS_GFX
 		t.pStr = self->options[i].optname;
 		if ((widget_focus == _self) &&
 		    (self->highlighted == i))
@@ -322,6 +330,7 @@ Widget_DrawChoice (WIDGET *_self, int x,
 		}
 		font_DrawText (&t);
 	}
+	
 	SetContextFontEffect (oldFontEffect);
 	if (oldfont)
 		SetContextFont (oldfont);
@@ -344,7 +353,7 @@ Widget_DrawButton (WIDGET *_self, int x,
 	selected = WIDGET_ACTIVE_COLOR;
 	inactive = WIDGET_INACTIVE_COLOR;
 
-	t.baseline.x = 160;
+	t.baseline.x = 160 << resolutionFactor; // JMS_GFX
 	t.baseline.y = y;
 	t.align = ALIGN_CENTER;
 	t.CharCount = ~0;
@@ -379,7 +388,7 @@ Widget_DrawLabel (WIDGET *_self, int x,
 	if (cur_font)
 		oldfont = SetContextFont (cur_font);
 	
-	t.baseline.x = 160;
+	t.baseline.x = 160 << resolutionFactor; // JMS_GFX
 	t.baseline.y = y;
 	t.align = ALIGN_CENTER;
 	t.CharCount = ~0;
@@ -388,7 +397,7 @@ Widget_DrawLabel (WIDGET *_self, int x,
 	{
 		t.pStr = self->lines[i];
 		font_DrawText (&t);
-		t.baseline.y += 8;
+		t.baseline.y += (8 << resolutionFactor); // JMS_GFX
 	}
 	SetContextFontEffect (oldFontEffect);
 	if (oldfont)
@@ -416,7 +425,7 @@ Widget_DrawSlider(WIDGET *_self, int x,
 	selected = WIDGET_ACTIVE_COLOR;
 	inactive = WIDGET_INACTIVE_COLOR;
 
-	t.baseline.x = x;
+	t.baseline.x = x + 64 * resolutionFactor; // JMS_GFX;
 	t.baseline.y = y;
 	t.align = ALIGN_LEFT;
 	t.CharCount = ~0;
@@ -431,6 +440,8 @@ Widget_DrawSlider(WIDGET *_self, int x,
 		oldtext = SetContextForeGroundColor (default_color);
 	}
 	font_DrawText (&t);
+	
+	t.baseline.x -= 64 * resolutionFactor; // JMS_GFX;
 
 	r.corner.x = t.baseline.x + 3 * tick;
 	r.corner.y = t.baseline.y - 4;
@@ -489,7 +500,7 @@ Widget_DrawTextEntry (WIDGET *_self, int
 
 	BatchGraphics ();
 
-	t.baseline.x = x;
+	t.baseline.x = x + 64 * resolutionFactor; // JMS_GFX
 	t.baseline.y = y;
 	t.align = ALIGN_LEFT;
 	t.CharCount = ~0;
@@ -503,6 +514,8 @@ Widget_DrawTextEntry (WIDGET *_self, int
 		oldtext = SetContextForeGroundColor (default_color);
 	}
 	font_DrawText (&t);
+	
+	t.baseline.x -= 64 * resolutionFactor; // JMS_GFX
 
 	/* Force string termination */
 	self->value[WIDGET_TEXTENTRY_WIDTH-1] = 0;
@@ -513,7 +526,7 @@ Widget_DrawTextEntry (WIDGET *_self, int
 
 	if (!(self->state & WTE_EDITING))
 	{	// normal or selected state
-		t.baseline.x = 160;
+		t.baseline.x = 160 << resolutionFactor; // JMS_GFX
 		t.align = ALIGN_CENTER;
 
 		if (widget_focus == _self)
@@ -535,7 +548,7 @@ Widget_DrawTextEntry (WIDGET *_self, int
 		RECT r;
 		SIZE leading;
 
-		t.baseline.x = 90;
+		t.baseline.x = 90 << resolutionFactor; // JMS_GFX
 		t.align = ALIGN_LEFT;
 
 		// calc background box dimensions
@@ -625,7 +638,7 @@ Widget_DrawControlEntry (WIDGET *_self,
 	selected = WIDGET_ACTIVE_COLOR;
 	inactive = WIDGET_INACTIVE_COLOR;
 
-	t.baseline.x = x;
+	t.baseline.x = x + 64 * resolutionFactor; // JMS_GFX
 	t.baseline.y = y;
 	t.align = ALIGN_LEFT;
 	t.CharCount = ~0;
@@ -639,6 +652,8 @@ Widget_DrawControlEntry (WIDGET *_self,
 		oldtext = SetContextForeGroundColor (default_color);
 	}
 	font_DrawText (&t);
+	
+	t.baseline.x -= 64 * resolutionFactor; // JMS_GFX
 
         // 3 * ScreenWidth / ((self->maxcolumns + 1) * 2)) as per CHOICE, but only two options.
 	home_x = t.baseline.x + (ScreenWidth / 2); 
@@ -647,7 +662,7 @@ Widget_DrawControlEntry (WIDGET *_self,
 	for (i = 0; i < 2; i++)
 	{
 		t.baseline.x = home_x + ((i % 3) * (ScreenWidth / 3));  // self->maxcolumns + 1 as per CHOICE.
-		t.baseline.y = home_y + (8 * (i / 3));
+		t.baseline.y = home_y + ((8 * (i / 3)) << resolutionFactor); // JMS_GFX;
 		t.pStr = self->controlname[i];
 		if (!t.pStr[0])
 		{
@@ -673,7 +688,7 @@ Widget_DrawControlEntry (WIDGET *_self,
 int
 Widget_HeightChoice (WIDGET *_self)
 {
-	return ((((WIDGET_CHOICE *)_self)->numopts + 2) / 3) * 8;
+	return ((((WIDGET_CHOICE *)_self)->numopts + 2) / 3) * (8 << resolutionFactor); // JMS_GFX;
 }
 
 int
@@ -687,14 +702,14 @@ int
 Widget_HeightOneLine (WIDGET *_self)
 {
 	(void)_self;
-	return 8;
+	return (8 << resolutionFactor); // JMS_GFX
 }
 
 int
 Widget_HeightLabel (WIDGET *_self)
 {
 	WIDGET_LABEL *self = (WIDGET_LABEL *)_self;
-	return self->line_count * 8;
+	return self->line_count * (8 << resolutionFactor); // JMS_GFX
 }
 
 int
diff -ruNp src.orig/libs/heap/heap.c src/libs/heap/heap.c
--- src.orig/libs/heap/heap.c	2017-11-01 15:30:19 -0700
+++ src/libs/heap/heap.c	2017-11-01 15:30:56 -0700
@@ -103,8 +103,6 @@ Heap_removeByIndex(Heap *heap, size_t i)
 		// Restore the heap invariant. We're shifting entries into the
 		// gap that was created until we find the place where we can
 		// insert the last entry.
-		HeapValue *lastEntry = heap->entries[heap->numEntries];
-
 		for (;;) {
 			size_t childI = i * 2 + 1;
 			// The two children are childI and 'childI + 1'.
@@ -116,7 +114,7 @@ Heap_removeByIndex(Heap *heap, size_t i)
 					// There is no left child either.
 					break;
 				}
-			} else {
+
 				if (heap->comparator(heap->entries[childI + 1],
 						heap->entries[childI]) < 0) {
 					// The right child is the child with the lowest value.
@@ -125,7 +123,8 @@ Heap_removeByIndex(Heap *heap, size_t i)
 			}
 			// childI is now the child with the lowest value.
 
-			if (heap->comparator(lastEntry, heap->entries[childI]) <= 0) {
+			if (heap->comparator(heap->entries[heap->numEntries],
+					heap->entries[childI]) <= 0) {
 				// The last entry goes here.
 				break;
 			}
@@ -139,7 +138,7 @@ Heap_removeByIndex(Heap *heap, size_t i)
 		}
 
 		// Fill the gap with the last entry.
-		heap->entries[i] = lastEntry;
+		heap->entries[i] = heap->entries[heap->numEntries];
 		heap->entries[i]->index = i;
 	}
 
diff -ruNp src.orig/libs/input/sdl/vcontrol.c src/libs/input/sdl/vcontrol.c
--- src.orig/libs/input/sdl/vcontrol.c	2017-11-01 15:30:19 -0700
+++ src/libs/input/sdl/vcontrol.c	2017-11-01 15:30:57 -0700
@@ -448,7 +448,6 @@ VControl_AddGestureBinding (VCONTROL_GES
 
 	default:
 		log_add (log_Warning, "VControl_AddGestureBinding didn't understand argument gesture");
-		result = -1;
 		break;
 	}
 	return result;
diff -ruNp src.orig/libs/list/list.h src/libs/list/list.h
--- src.orig/libs/list/list.h	2017-11-01 15:30:19 -0700
+++ src/libs/list/list.h	2017-11-01 15:30:57 -0700
@@ -17,7 +17,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
  */
-
+  
 // The 'already included' check must be done slightly more complicated
 // than usually. This file may be included directly only once,
 // but it may be included my derivative List definitions that use
diff -ruNp src.orig/libs/log/uqmlog.c src/libs/log/uqmlog.c
--- src.orig/libs/log/uqmlog.c	2017-11-01 15:30:19 -0700
+++ src/libs/log/uqmlog.c	2017-11-01 15:30:57 -0700
@@ -288,7 +288,7 @@ displayLog (bool isError)
 
 	if (isError)
 	{
-		strcpy (p, "The Ur-Quan Masters encountered a fatal error.\n"
+		strcpy (p, "The Ur-Quan Masters project6014 encountered a fatal error.\n"
 				"Part of the log follows:\n\n");
 		len = strlen (p);
 		p += len;
@@ -325,6 +325,6 @@ displayLog (bool isError)
 	
 	*p = '\0';
 
-	log_displayBox ("The Ur-Quan Masters", isError, msgBuf);
+	log_displayBox ("The Ur-Quan Masters project6014", isError, msgBuf);
 }
 
diff -ruNp src.orig/libs/mikmod/drv_nos.c src/libs/mikmod/drv_nos.c
--- src.orig/libs/mikmod/drv_nos.c	2017-11-01 15:30:19 -0700
+++ src/libs/mikmod/drv_nos.c	2017-11-01 15:30:57 -0700
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: drv_nos.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   Driver for no output
 
diff -ruNp src.orig/libs/mikmod/load_it.c src/libs/mikmod/load_it.c
--- src.orig/libs/mikmod/load_it.c	2017-11-01 15:30:19 -0700
+++ src/libs/mikmod/load_it.c	2017-11-01 15:30:57 -0700
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_it.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   Impulse tracker (IT) module loader
 
diff -ruNp src.orig/libs/mikmod/load_mod.c src/libs/mikmod/load_mod.c
--- src.orig/libs/mikmod/load_mod.c	2017-11-01 15:30:19 -0700
+++ src/libs/mikmod/load_mod.c	2017-11-01 15:30:57 -0700
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_mod.c 2421 2006-08-19 00:36:21Z avolkov $
+  $Id$
 
   Generic MOD loader (Protracker, StarTracker, FastTracker, etc)
 
diff -ruNp src.orig/libs/mikmod/load_s3m.c src/libs/mikmod/load_s3m.c
--- src.orig/libs/mikmod/load_s3m.c	2017-11-01 15:30:19 -0700
+++ src/libs/mikmod/load_s3m.c	2017-11-01 15:30:57 -0700
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_s3m.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   Screamtracker (S3M) module loader
 
diff -ruNp src.orig/libs/mikmod/load_stm.c src/libs/mikmod/load_stm.c
--- src.orig/libs/mikmod/load_stm.c	2017-11-01 15:30:19 -0700
+++ src/libs/mikmod/load_stm.c	2017-11-01 15:30:57 -0700
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_stm.c 2421 2006-08-19 00:36:21Z avolkov $
+  $Id$
 
   Screamtracker 2 (STM) module loader
 
diff -ruNp src.orig/libs/mikmod/load_xm.c src/libs/mikmod/load_xm.c
--- src.orig/libs/mikmod/load_xm.c	2017-11-01 15:30:19 -0700
+++ src/libs/mikmod/load_xm.c	2017-11-01 15:30:57 -0700
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_xm.c 2421 2006-08-19 00:36:21Z avolkov $
+  $Id$
 
   Fasttracker (XM) module loader
 
diff -ruNp src.orig/libs/mikmod/mdreg.c src/libs/mikmod/mdreg.c
--- src.orig/libs/mikmod/mdreg.c	2017-11-01 15:30:19 -0700
+++ src/libs/mikmod/mdreg.c	2017-11-01 15:30:57 -0700
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mdreg.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   Routine for registering all drivers in libmikmod for the current platform.
 
diff -ruNp src.orig/libs/mikmod/mdriver.c src/libs/mikmod/mdriver.c
--- src.orig/libs/mikmod/mdriver.c	2017-11-01 15:30:19 -0700
+++ src/libs/mikmod/mdriver.c	2017-11-01 15:30:57 -0700
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mdriver.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   These routines are used to access the available soundcard drivers.
 
diff -ruNp src.orig/libs/mikmod/mikmod.h src/libs/mikmod/mikmod.h
--- src.orig/libs/mikmod/mikmod.h	2017-11-01 15:30:19 -0700
+++ src/libs/mikmod/mikmod.h	2017-11-01 15:30:57 -0700
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mikmod.h 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   MikMod sound library include file
 
diff -ruNp src.orig/libs/mikmod/mikmod_internals.h src/libs/mikmod/mikmod_internals.h
--- src.orig/libs/mikmod/mikmod_internals.h	2017-11-01 15:30:19 -0700
+++ src/libs/mikmod/mikmod_internals.h	2017-11-01 15:30:57 -0700
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mikmod_internals.h 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   MikMod sound library internal definitions
 
diff -ruNp src.orig/libs/mikmod/mloader.c src/libs/mikmod/mloader.c
--- src.orig/libs/mikmod/mloader.c	2017-11-01 15:30:19 -0700
+++ src/libs/mikmod/mloader.c	2017-11-01 15:30:57 -0700
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mloader.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   These routines are used to access the available module loaders
 
diff -ruNp src.orig/libs/mikmod/mlreg.c src/libs/mikmod/mlreg.c
--- src.orig/libs/mikmod/mlreg.c	2017-11-01 15:30:19 -0700
+++ src/libs/mikmod/mlreg.c	2017-11-01 15:30:57 -0700
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mlreg.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   Routine for registering all loaders in libmikmod for the current platform.
 
diff -ruNp src.orig/libs/mikmod/mlutil.c src/libs/mikmod/mlutil.c
--- src.orig/libs/mikmod/mlutil.c	2017-11-01 15:30:19 -0700
+++ src/libs/mikmod/mlutil.c	2017-11-01 15:30:57 -0700
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mlutil.c 2421 2006-08-19 00:36:21Z avolkov $
+  $Id$
 
   Utility functions for the module loader
 
diff -ruNp src.orig/libs/mikmod/mmalloc.c src/libs/mikmod/mmalloc.c
--- src.orig/libs/mikmod/mmalloc.c	2017-11-01 15:30:19 -0700
+++ src/libs/mikmod/mmalloc.c	2017-11-01 15:30:57 -0700
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mmalloc.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   Dynamic memory routines
 
diff -ruNp src.orig/libs/mikmod/mmerror.c src/libs/mikmod/mmerror.c
--- src.orig/libs/mikmod/mmerror.c	2017-11-01 15:30:19 -0700
+++ src/libs/mikmod/mmerror.c	2017-11-01 15:30:57 -0700
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mmerror.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   Error handling functions.
   Register an error handler with _mm_RegisterErrorHandler() and you're all set.
diff -ruNp src.orig/libs/mikmod/mmio.c src/libs/mikmod/mmio.c
--- src.orig/libs/mikmod/mmio.c	2017-11-01 15:30:19 -0700
+++ src/libs/mikmod/mmio.c	2017-11-01 15:30:57 -0700
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mmio.c 2421 2006-08-19 00:36:21Z avolkov $
+  $Id$
 
   Portable file I/O routines
 
diff -ruNp src.orig/libs/mikmod/mplayer.c src/libs/mikmod/mplayer.c
--- src.orig/libs/mikmod/mplayer.c	2017-11-01 15:30:19 -0700
+++ src/libs/mikmod/mplayer.c	2017-11-01 15:30:57 -0700
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mplayer.c 2421 2006-08-19 00:36:21Z avolkov $
+  $Id$
 
   The Protracker Player Driver
 
diff -ruNp src.orig/libs/mikmod/munitrk.c src/libs/mikmod/munitrk.c
--- src.orig/libs/mikmod/munitrk.c	2017-11-01 15:30:19 -0700
+++ src/libs/mikmod/munitrk.c	2017-11-01 15:30:57 -0700
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: munitrk.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   All routines dealing with the manipulation of UNITRK streams
 
diff -ruNp src.orig/libs/mikmod/mwav.c src/libs/mikmod/mwav.c
--- src.orig/libs/mikmod/mwav.c	2017-11-01 15:30:19 -0700
+++ src/libs/mikmod/mwav.c	2017-11-01 15:30:57 -0700
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mwav.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   WAV sample loader
 
diff -ruNp src.orig/libs/mikmod/npertab.c src/libs/mikmod/npertab.c
--- src.orig/libs/mikmod/npertab.c	2017-11-01 15:30:19 -0700
+++ src/libs/mikmod/npertab.c	2017-11-01 15:30:57 -0700
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: npertab.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   MOD format period table.  Used by both the MOD and M15 (15-inst mod) Loaders.
 
diff -ruNp src.orig/libs/mikmod/sloader.c src/libs/mikmod/sloader.c
--- src.orig/libs/mikmod/sloader.c	2017-11-01 15:30:20 -0700
+++ src/libs/mikmod/sloader.c	2017-11-01 15:30:57 -0700
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: sloader.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   Routines for loading samples. The sample loader utilizes the routines
   provided by the "registered" sample loader.
diff -ruNp src.orig/libs/mikmod/virtch.c src/libs/mikmod/virtch.c
--- src.orig/libs/mikmod/virtch.c	2017-11-01 15:30:20 -0700
+++ src/libs/mikmod/virtch.c	2017-11-01 15:30:57 -0700
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: virtch.c 2421 2006-08-19 00:36:21Z avolkov $
+  $Id$
 
   Sample mixing routines, using a 32 bits mixing buffer.
 
diff -ruNp src.orig/libs/mikmod/virtch2.c src/libs/mikmod/virtch2.c
--- src.orig/libs/mikmod/virtch2.c	2017-11-01 15:30:20 -0700
+++ src/libs/mikmod/virtch2.c	2017-11-01 15:30:57 -0700
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: virtch2.c 2421 2006-08-19 00:36:21Z avolkov $
+  $Id$
 
   High-quality sample mixing routines, using a 32 bits mixing buffer,
   interpolation, and sample smoothing to improve sound quality and remove
diff -ruNp src.orig/libs/mikmod/virtch_common.c src/libs/mikmod/virtch_common.c
--- src.orig/libs/mikmod/virtch_common.c	2017-11-01 15:30:20 -0700
+++ src/libs/mikmod/virtch_common.c	2017-11-01 15:30:57 -0700
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: virtch_common.c 2421 2006-08-19 00:36:21Z avolkov $
+  $Id$
 
   Common source parts between the two software mixers.
   This file is probably the ugliest part of libmikmod...
diff -ruNp src.orig/libs/network/wspiapiwrap.h src/libs/network/wspiapiwrap.h
--- src.orig/libs/network/wspiapiwrap.h	2017-11-01 15:30:20 -0700
+++ src/libs/network/wspiapiwrap.h	2017-11-01 15:30:57 -0700
@@ -16,6 +16,11 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+// Shiver: Added this part to help MSVC compile.
+#ifdef _MSC_VER
+#include <wspiapi.h>
+#endif
+
 #ifndef _WSPIAPIWRAP_H
 #define _WSPIAPIWRAP_H
 
diff -ruNp src.orig/libs/reslib.h src/libs/reslib.h
--- src.orig/libs/reslib.h	2017-11-01 15:30:20 -0700
+++ src/libs/reslib.h	2017-11-01 15:30:57 -0700
@@ -48,14 +48,14 @@ typedef void *(ResourceLoadFileFun) (uio
 void *LoadResourceFromPath(const char *pathname, ResourceLoadFileFun fn);
 
 uio_Stream *res_OpenResFile (uio_DirHandle *dir, const char *filename, const char *mode);
-size_t ReadResFile (void *lpBuf, size_t size, size_t count, uio_Stream *fp);
-size_t WriteResFile (const void *lpBuf, size_t size, size_t count, uio_Stream *fp);
+int ReadResFile (void *lpBuf, COUNT size, DWORD count, uio_Stream *fp);
+int WriteResFile (const void *lpBuf, COUNT size, DWORD count, uio_Stream *fp);
 int GetResFileChar (uio_Stream *fp);
 int PutResFileChar (char ch, uio_Stream *fp);
 int PutResFileNewline (uio_Stream *fp);
 long SeekResFile (uio_Stream *fp, long offset, int whence);
 long TellResFile (uio_Stream *fp);
-size_t LengthResFile (uio_Stream *fp);
+long LengthResFile (uio_Stream *fp);
 BOOLEAN res_CloseResFile (uio_Stream *fp);
 BOOLEAN DeleteResFile (uio_DirHandle *dir, const char *filename);
 
diff -ruNp src.orig/libs/resource/Makeinfo src/libs/resource/Makeinfo
--- src.orig/libs/resource/Makeinfo	2017-11-01 15:30:20 -0700
+++ src/libs/resource/Makeinfo	2017-11-01 15:30:57 -0700
@@ -1,2 +1 @@
-uqm_CFILES="direct.c filecntl.c getres.c loadres.c stringbank.c
-		propfile.c resinit.c"
+uqm_CFILES="direct.c filecntl.c getres.c loadres.c stringbank.c propfile.c resinit.c"
diff -ruNp src.orig/libs/resource/filecntl.c src/libs/resource/filecntl.c
--- src.orig/libs/resource/filecntl.c	2017-11-01 15:30:20 -0700
+++ src/libs/resource/filecntl.c	2017-11-01 15:30:57 -0700
@@ -60,8 +60,8 @@ DeleteResFile (uio_DirHandle *dir, const
 	return (uio_unlink (dir, filename) == 0);
 }
 
-size_t
-ReadResFile (void *lpBuf, size_t size, size_t count, uio_Stream *fp)
+int
+ReadResFile (void *lpBuf, COUNT size, DWORD count, uio_Stream *fp)
 {
 	int retval;
 
@@ -70,8 +70,8 @@ ReadResFile (void *lpBuf, size_t size, s
 	return (retval);
 }
 
-size_t
-WriteResFile (const void *lpBuf, size_t size, size_t count, uio_Stream *fp)
+int
+WriteResFile (const void *lpBuf, COUNT size, DWORD count, uio_Stream *fp)
 {
 	int retval;
 
@@ -131,7 +131,7 @@ TellResFile (uio_Stream *fp)
 	return (retval);
 }
 
-size_t
+long
 LengthResFile (uio_Stream *fp)
 {
 	struct stat sb;
diff -ruNp src.orig/libs/resource/getres.c src/libs/resource/getres.c
--- src.orig/libs/resource/getres.c	2017-11-01 15:30:20 -0700
+++ src/libs/resource/getres.c	2017-11-01 15:30:57 -0700
@@ -43,7 +43,7 @@ void *
 LoadResourceFromPath (const char *path, ResourceLoadFileFun *loadFun)
 {
 	uio_Stream *stream;
-	unsigned long dataLen;
+	long dataLen;
 	void *resdata;
 
 	stream = res_OpenResFile (contentDir, path, "rb");
diff -ruNp src.orig/libs/resource/loadres.c src/libs/resource/loadres.c
--- src.orig/libs/resource/loadres.c	2017-11-01 15:30:20 -0700
+++ src/libs/resource/loadres.c	2017-11-01 15:30:57 -0700
@@ -17,38 +17,56 @@
  */
 
 #include "resintrn.h"
+#include "libs/declib.h"
 #include "libs/memlib.h"
-#include "libs/log.h"
 
 
 void *
 GetResourceData (uio_Stream *fp, DWORD length)
 {
+	BYTE *RDPtr;
 	void *result;
-	DWORD compLen;
+	DECODE_REF fh = 0;
 
-	// Resource data used to be prefixed by its length in package files.
-	// A valid length prefix indicated compressed data, and
-	// a length prefix ~0 meant uncompressed.
-	// Currently, .ct and .xlt files still carry a ~0 length prefix.
-	if (ReadResFile (&compLen, sizeof (compLen), 1, fp) != 1)
-		return NULL;
-	if (compLen != ~(DWORD)0)
-	{
-		log_add (log_Warning, "LZ-compressed binary data not supported");
-		return NULL;
-	}
-	length -= sizeof (DWORD);
+	if (length == ~(DWORD)0)
+		length = LengthResFile (fp);
+	else if ((fh = copen (fp, FILE_STREAM, STREAM_READ)))
+		cfilelength (fh, &length);
+	else
+		length -= sizeof (DWORD);
 
 	result = AllocResourceData (length);
-	if (!result)
-		return NULL;
-
-	if (ReadResFile (result, 1, length, fp) != length)
+	RDPtr = result;
+	if (RDPtr)
 	{
-		FreeResourceData (result);
-		result = NULL;
+		COUNT num_read;
+
+		do
+		{
+#define READ_LENGTH 0x00007FFFL
+			num_read = length >= READ_LENGTH ?
+					(COUNT)READ_LENGTH : (COUNT)length;
+			if (fh)
+			{
+				if (cread (RDPtr, 1, num_read, fh) != num_read)
+					break;
+			}
+			else
+			{
+				if ((int)(ReadResFile (RDPtr, 1, num_read, fp)) != (int)num_read)
+					break;
+			}
+			RDPtr += num_read;
+		} while (length -= num_read);
+
+		if (length > 0)
+		{
+			FreeResourceData (result);
+			result = NULL;
+		}
 	}
 
+	cclose (fh);
+
 	return result;
 }
diff -ruNp src.orig/libs/resource/propfile.c src/libs/resource/propfile.c
--- src.orig/libs/resource/propfile.c	2017-11-01 15:30:20 -0700
+++ src/libs/resource/propfile.c	2017-11-01 15:30:58 -0700
@@ -98,7 +98,7 @@ PropFile_from_string (char *d, PROPERTY_
 void
 PropFile_from_file (uio_Stream *f, PROPERTY_HANDLER handler, const char *prefix)
 {
-	size_t flen;
+	long flen;
 	char *data;
 
 	flen = LengthResFile (f);
@@ -108,8 +108,6 @@ PropFile_from_file (uio_Stream *f, PROPE
 		return;
 	}
 
-	// We may end up with less bytes than we asked for due to the
-	// DOS->Unix newline conversion
 	flen = ReadResFile (data, 1, flen, f);
 	data[flen] = '\0';
 
diff -ruNp src.orig/libs/resource/resinit.c src/libs/resource/resinit.c
--- src.orig/libs/resource/resinit.c	2017-11-01 15:30:20 -0700
+++ src/libs/resource/resinit.c	2017-11-01 15:30:58 -0700
@@ -18,6 +18,7 @@
 
 #include "resintrn.h"
 #include "libs/memlib.h"
+#include "libs/memlib.h"
 #include "options.h"
 #include "types.h"
 #include "libs/log.h"
diff -ruNp src.orig/libs/sound/trackplayer.c src/libs/sound/trackplayer.c
--- src.orig/libs/sound/trackplayer.c	2017-11-01 15:30:20 -0700
+++ src/libs/sound/trackplayer.c	2017-11-01 15:30:58 -0700
@@ -393,7 +393,6 @@ SpliceMultiTrack (UNICODE *TrackNames[],
 
 			chunks_tail->next = create_SoundChunk (track_decs[tracks], sound_sample->length);
 			chunks_tail = chunks_tail->next;
-			chunks_tail->track_num = track_count - 1;
 			sound_sample->length += track_decs[tracks]->length;
 		}
 		else
@@ -581,10 +580,10 @@ SpliceTrack (UNICODE *TrackName, UNICODE
 					dec_offset, time_stamps[page]);
 #endif
 			sound_sample->length += decoder->length;
-			chunks_tail->track_num = track_count - 1;
 			if (!no_page_break)
 			{
 				chunks_tail->tag_me = 1;
+				chunks_tail->track_num = track_count - 1;
 				if (page < num_pages)
 				{
 					chunks_tail->text = pages[page];
@@ -774,9 +773,12 @@ TFB_SoundChunk *
 create_SoundChunk (TFB_SoundDecoder *decoder, float start_time)
 {
 	TFB_SoundChunk *chunk;
-	chunk = HCalloc (sizeof (*chunk));
+	chunk = HMalloc (sizeof (TFB_SoundChunk));
 	chunk->decoder = decoder;
+	chunk->next = NULL;
 	chunk->start_time = start_time;
+	chunk->tag_me = 0;
+	chunk->text = 0;
 	return chunk;
 }
 
diff -ruNp src.orig/libs/strings/getstr.c src/libs/strings/getstr.c
--- src.orig/libs/strings/getstr.c	2017-11-01 15:30:20 -0700
+++ src/libs/strings/getstr.c	2017-11-01 15:30:58 -0700
@@ -65,7 +65,7 @@ void
 _GetConversationData (const char *path, RESOURCE_DATA *resdata)
 {
 	uio_Stream *fp;
-	unsigned long dataLen;
+	long dataLen;
 	void *result;
 	int n, path_len, num_data_sets;
 	DWORD opos,
diff -ruNp src.orig/options.c src/options.c
--- src.orig/options.c	2017-11-01 15:30:22 -0700
+++ src/options.c	2017-11-01 15:30:59 -0700
@@ -14,6 +14,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2011: Merged resolution Factor stuff from UQM-HD.
+
 /*
  * Eventually this should include all configuration stuff, 
  * for now there's few options which indicate 3do/pc flavors.
@@ -52,6 +54,11 @@ int optSmoothScroll;
 int optMeleeScale;
 const char **optAddons;
 
+// JMS_GFX
+unsigned int loresBlowupScale;
+unsigned int resolutionFactor;
+BOOLEAN resFactorWasChanged;
+
 BOOLEAN opt3doMusic;
 BOOLEAN optRemixMusic;
 BOOLEAN optSubtitles;
@@ -129,7 +136,7 @@ findFileInDirs (const char *locs[], int
 // execFile is the path to the uqm executable, as acquired through
 // main()'s argv[0].
 void
-prepareContentDir (const char *contentDirName, const char* addonDirName, const char *execFile)
+prepareContentDir (const char *contentDirName, const char* addonDirName, char *execFile)
 {
 	const char *testFile = "version";
 	const char *loc;
@@ -152,8 +159,7 @@ prepareContentDir (const char *contentDi
 		if (loc == NULL)
 		{
 			char *tempDir = (char *) HMalloc (PATH_MAX);
-			snprintf (tempDir, PATH_MAX, "%s/../Resources/content",
-					dirname (execFile));
+			snprintf (tempDir, PATH_MAX, "%s/../Resources/content", dirname (execFile));
 			loc = findFileInDirs ((const char **) &tempDir, 1, testFile);
 			HFree (tempDir);
 		}
diff -ruNp src.orig/options.h src/options.h
--- src.orig/options.h	2017-11-01 15:30:22 -0700
+++ src/options.h	2017-11-01 15:30:59 -0700
@@ -14,6 +14,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2011: Merged resolution Factor stuff from UQM-HD.
+
 /*
  * Eventually this should include all configuration stuff, 
  * for now there's few options which indicate 3do/pc flavors.
@@ -38,6 +40,11 @@ extern int optWhichShield;
 extern int optSmoothScroll;
 extern int optMeleeScale;
 
+// JMS_GFX
+extern unsigned int loresBlowupScale;
+extern unsigned int resolutionFactor;
+extern BOOLEAN resFactorWasChanged;
+
 extern BOOLEAN opt3doMusic;
 extern BOOLEAN optRemixMusic;
 extern BOOLEAN optSubtitles;
@@ -65,7 +72,7 @@ typedef struct _input_template {
 
 extern INPUT_TEMPLATE input_templates[6];
 
-void prepareContentDir (const char *contentDirName, const char *addonDirName, const char *execFile);
+void prepareContentDir (const char *contentDirName, const char *addonDirName, char *execFile);
 void prepareConfigDir (const char *configDirName);
 void prepareMeleeDir (void);
 void prepareSaveDir (void);
diff -ruNp src.orig/port.c src/port.c
--- src.orig/port.c	2017-11-01 15:30:22 -0700
+++ src/port.c	2017-11-01 15:30:59 -0700
@@ -133,6 +133,7 @@ snprintf(char *str, size_t size, const c
 	return result;
 }
 
+#ifndef HAVE_VSNPRINTF
 int
 vsnprintf(char *str, size_t size, const char *format, va_list args)
 {
@@ -141,5 +142,6 @@ vsnprintf(char *str, size_t size, const
 		str[size - 1] = '\0';
 	return result;
 }
+#endif
 #endif  /* _MSC_VER */
 
diff -ruNp src.orig/port.h src/port.h
--- src.orig/port.h	2017-11-01 15:30:22 -0700
+++ src/port.h	2017-11-01 15:30:59 -0700
@@ -162,7 +162,9 @@ typedef unsigned short mode_t;
 #	include <stdarg.h>
 // Defined in port.c
 int snprintf(char *str, size_t size, const char *format, ...);
+#ifndef HAVE_VSNPRINTF
 int vsnprintf(char *str, size_t size, const char *format, va_list args);
+#endif
 #endif  /* _MSC_VER */
 
 // setenv()
diff -ruNp src.orig/res/UrQuanMasters.rc src/res/UrQuanMasters.rc
--- src.orig/res/UrQuanMasters.rc	2017-11-01 15:30:22 -0700
+++ src/res/UrQuanMasters.rc	2017-11-01 15:30:59 -0700
@@ -21,8 +21,8 @@ LANGUAGE 0x09, 0x01	// LANG_ENGLISH, SUB
 //
 
 1   VERSIONINFO
- FILEVERSION UQM_MAJOR_VERSION,UQM_MINOR_VERSION,UQM_PATCH_VERSION,0
- PRODUCTVERSION UQM_MAJOR_VERSION,UQM_MINOR_VERSION,UQM_PATCH_VERSION,0
+ FILEVERSION P6014_MAJOR_VERSION,P6014_MINOR_VERSION,P6014_PATCH_VERSION,0
+ PRODUCTVERSION P6014_MAJOR_VERSION,P6014_MINOR_VERSION,P6014_PATCH_VERSION,0
  FILEFLAGSMASK 0x3fL
 #ifdef _DEBUG
  FILEFLAGS 0x1L
@@ -40,16 +40,16 @@ BEGIN
             VALUE "Comments", "See http://sc2.sourceforge.net\0"
             VALUE "CompanyName", "sc2.sourceforge.net\0"
             VALUE "FileDescription", "The Ur-Quan Masters main executable\0"
-            VALUE "FileVersion", UQM_STRING_VERSION "\0"
+            VALUE "FileVersion", P6014_STRING_VERSION "\0"
             VALUE "InternalName", "uqm\0"
-            VALUE "LegalCopyright", "(C) 1992-1993, 2002-2011 by respective authors\0"
+            VALUE "LegalCopyright", "(C) 1992-1993, 2002-2007 by respective authors\0"
 #ifdef _DEBUG
             VALUE "OriginalFilename", "uqmdebug.exe\0"
 #else
             VALUE "OriginalFilename", "uqm.exe\0"
 #endif
             VALUE "ProductName", "The Ur-Quan Masters\0"
-            VALUE "ProductVersion", UQM_STRING_VERSION "\0"
+            VALUE "ProductVersion", P6014_STRING_VERSION "\0"
             VALUE "SpecialBuild", "Alpha\0"
         END
     END
diff -ruNp src.orig/res/darwin/Info.plist src/res/darwin/Info.plist
--- src.orig/res/darwin/Info.plist	2017-11-01 15:30:22 -0700
+++ src/res/darwin/Info.plist	2017-11-01 15:30:59 -0700
@@ -1,13 +1,13 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
 <plist version="1.0">
 <dict>
 	<key>CFBundleDevelopmentRegion</key>
 	<string>English</string>
 	<key>CFBundleExecutable</key>
-	<string>The Ur-Quan Masters</string>
+	<string>P6014</string>
 	<key>CFBundleIconFile</key>
-	<string>The Ur-Quan Masters.icns</string>
+	<string>P6014.icns</string>
 	<key>CFBundleInfoDictionaryVersion</key>
 	<string>6.0</string>
 	<key>CFBundlePackageType</key>
Files src.orig/res/darwin/P6014.icns and src/res/darwin/P6014.icns differ
Files src.orig/res/darwin/The Ur-Quan Masters.icns and src/res/darwin/The Ur-Quan Masters.icns differ
diff -ruNp src.orig/symbian/uqm.cfg src/symbian/uqm.cfg
--- src.orig/symbian/uqm.cfg	2017-11-01 15:30:22 -0700
+++ src/symbian/uqm.cfg	2017-11-01 15:31:00 -0700
@@ -1,26 +1,27 @@
-alwaysgl = BOOLEAN:false
-sfxvol = INT32:20
-reswidth = INT32:320
-usegl = BOOLEAN:false
-3domusic = BOOLEAN:true
-textmenu = BOOLEAN:true
-musicvol = INT32:20
-textgradients = BOOLEAN:true
-subtitles = BOOLEAN:true
-iconicscan = BOOLEAN:false
-resheight = INT32:240
-scaler = STRING:no
-3domovies = BOOLEAN:false
-speechvol = INT32:20
-audioquality = STRING:low
-positionalsfx = BOOLEAN:false
-player1control = INT32:0
-showfps = BOOLEAN:false
-pulseshield = BOOLEAN:false
-smoothmelee = BOOLEAN:false
-fullscreen = BOOLEAN:false
-smoothscroll = BOOLEAN:false
-audiodriver = STRING:mixsdl
-player2control = INT32:3
-scanlines = BOOLEAN:false
-remixmusic = BOOLEAN:false
+config.textmenu = yes
+config.alwaysgl = no
+config.sfxvol = 20
+config.iconicscan = no
+config.pulseshield = no
+config.3domusic = yes
+config.smoothmelee = no
+config.positionalsfx = no
+config.resheight = 480
+config.musicvol = 20
+config.textgradients = yes
+config.reswidth = 640
+config.scaler = no
+config.audiodriver = mixsdl
+config.fullscreen = no
+config.usegl = no
+config.player2control = 3
+config.player1control = 0
+config.subtitles = yes
+config.3domovies = yes
+config.scanlines = no
+config.showfps = no
+config.speechvol = 20
+config.remixmusic = no
+config.smoothscroll = no
+config.audioquality = low
+config.resolutionfactor = 1
diff -ruNp src.orig/uqm/Makeinfo src/uqm/Makeinfo
--- src.orig/uqm/Makeinfo	2017-11-01 15:30:25 -0700
+++ src/uqm/Makeinfo	2017-11-01 15:31:03 -0700
@@ -1,6 +1,7 @@
 uqm_SUBDIRS="comm planets ships supermelee"
 uqm_CFILES="battle.c battlecontrols.c border.c build.c cleanup.c clock.c
-		cnctdlg.c collide.c comm.c commanim.c commglue.c confirm.c credits.c
+		cnctdlg.c collide.c comm.c commanim.c commglue.c confirm.c
+                conversation.c credits.c
 		cyborg.c demo.c displist.c dummy.c encount.c flash.c fmv.c galaxy.c
 		gameev.c gameinp.c gameopt.c gendef.c getchar.c globdata.c gravity.c
 		cons_res.c grpinfo.c hyper.c init.c intel.c intro.c ipdisp.c load.c
diff -ruNp src.orig/uqm/battle.c src/uqm/battle.c
--- src.orig/uqm/battle.c	2017-11-01 15:30:22 -0700
+++ src/uqm/battle.c	2017-11-01 15:31:00 -0700
@@ -16,6 +16,9 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2009 - Play Orz space music in Orz space
+// JMS 2010 - Enable Down key in melee (comment tag JMS_KEYS)
+
 #include "battle.h"
 
 #include "battlecontrols.h"
@@ -205,6 +208,8 @@ ProcessInput (void)
 						StarShipPtr->ship_input_state |= WEAPON;
 					if (InputState & BATTLE_SPECIAL)
 						StarShipPtr->ship_input_state |= SPECIAL;
+					if (InputState & BATTLE_DOWN)
+						StarShipPtr->ship_input_state |= DOWN; // JMS_KEYS: Down key is now in use!
 
 					if (CanRunAway && cur_player == 0 &&
 							(InputState & BATTLE_ESCAPE))
@@ -237,6 +242,8 @@ BattleSong (BOOLEAN DoPlay)
 	{
 		if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
 			BattleRef = LoadMusic (BATTLE_MUSIC);
+		else if (GET_GAME_STATE (ORZ_SPACE_SIDE) > 1)		// BY JMS - this condition activates Orz space music
+			BattleRef = LoadMusic (ORZSPACE_MUSIC);
 		else if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
 			BattleRef = LoadMusic (HYPERSPACE_MUSIC);
 		else
@@ -375,6 +382,7 @@ static BOOLEAN
 selectAllShips (SIZE num_ships)
 {
 	if (num_ships == 1) {
+
 		// HyperSpace in full game.
 		return GetNextStarShip (NULL, 0);
 	}
@@ -388,7 +396,7 @@ selectAllShips (SIZE num_ships)
 		return FALSE;
 	}
 #endif
-
+	log_add (log_Debug, "to GetInitialStarShips, numShips = %d", num_ships);
 	return GetInitialStarShips ();
 }
 
@@ -430,7 +438,7 @@ Battle (BattleFrameCallback *callback)
 		GLOBAL (CurrentActivity) |= IN_BATTLE;
 		battle_counter[0] = CountLinks (&race_q[0]);
 		battle_counter[1] = CountLinks (&race_q[1]);
-
+		
 		if (optMeleeScale != TFB_SCALE_STEP)
 			SetGraphicScaleMode (optMeleeScale);
 
@@ -447,6 +455,7 @@ Battle (BattleFrameCallback *callback)
 
 		if (!selectAllShips (num_ships)) {
 			GLOBAL (CurrentActivity) |= CHECK_ABORT;
+
 			goto AbortBattle;
 		}
 
diff -ruNp src.orig/uqm/border.c src/uqm/border.c
--- src.orig/uqm/border.c	2017-11-01 15:30:22 -0700
+++ src/uqm/border.c	2017-11-01 15:31:00 -0700
@@ -16,6 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
 
 #include "libs/gfxlib.h"
 #include "libs/threadlib.h"
@@ -25,6 +26,7 @@
 #include "units.h"
 #include "util.h"
 
+#include "libs/log.h"
 
 void
 InitSISContexts (void)
@@ -49,144 +51,172 @@ DrawSISFrame (void)
 	RECT r;
 
 	SetContext (ScreenContext);
-
+	
 	BatchGraphics ();
-	{
-		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
+	{	// Middle grey rectangles around space window.
+		SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
+			//
 		r.corner.x = 0;
 		r.corner.y = 0;
 		r.extent.width = SIS_ORG_X + SIS_SCREEN_WIDTH + 1;
 		r.extent.height = SIS_ORG_Y - 1;
 		DrawFilledRectangle (&r);
+			//
 		r.corner.x = 0;
 		r.corner.y = 0;
 		r.extent.width = SIS_ORG_X - 1;
 		r.extent.height = SIS_ORG_Y + SIS_SCREEN_HEIGHT + 1;
 		DrawFilledRectangle (&r);
+			//
 		r.corner.x = 0;
 		r.corner.y = r.extent.height;
 		r.extent.width = SIS_ORG_X + SIS_SCREEN_WIDTH + 1;
 		r.extent.height = SCREEN_HEIGHT - SIS_ORG_Y + SIS_SCREEN_HEIGHT;
 		DrawFilledRectangle (&r);
+			//
 		r.corner.x = SIS_ORG_X + SIS_SCREEN_WIDTH + 1;
 		r.corner.y = 0;
 		r.extent.width = SCREEN_WIDTH - r.corner.x;
 		r.extent.height = SCREEN_HEIGHT;
 		DrawFilledRectangle (&r);
-
+		
+		// Light and dark grey edges of the space window.
 		r.corner.x = SIS_ORG_X - 1;
 		r.corner.y = SIS_ORG_Y - 1;
 		r.extent.width = SIS_SCREEN_WIDTH + 2;
 		r.extent.height = SIS_SCREEN_HEIGHT + 2;
-		DrawStarConBox (&r, 1,
+		DrawStarConBox (&r, 1, // JMS_GFX: Border width.
 				BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19),
 				BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F),
 				TRUE, BLACK_COLOR);
-
+		
+		// The big Blue box in the upper edge of screen containing the star system name.
 		r.corner.y = 0;
 		r.extent.height = SIS_ORG_Y;
-
 		r.corner.x = SIS_ORG_X;
-		r.extent.width = SIS_MESSAGE_BOX_WIDTH;
+		r.extent.width = SIS_MESSAGE_BOX_WIDTH; // JMS_GFX
 		DrawStarConBox (&r, 1,
 				BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x0E), 0x54),
 				BUILD_COLOR (MAKE_RGB15 (0x00, 0x01, 0x1C), 0x4E),
 				TRUE, BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01));
-
-		r.extent.width = SIS_TITLE_BOX_WIDTH;
-		r.corner.x = SIS_ORG_X + SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH;
+		
+		// The smaller blue box.
+		r.extent.width = SIS_TITLE_BOX_WIDTH; // JMS_GFX;
+		r.corner.x = SIS_ORG_X + SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH; // JMS_GFX;
 		DrawStarConBox (&r, 1,
 				BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x0E), 0x54),
 				BUILD_COLOR (MAKE_RGB15 (0x00, 0x01, 0x1C), 0x4E),
 				TRUE, BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01));
 
+		// Black border between menu area and space window area
 		SetContextForeGroundColor (BLACK_COLOR);
 		r.corner.x = SAFE_X + SPACE_WIDTH - 1;
 		r.corner.y = 0;
-		r.extent.width = 1;
+		r.extent.width = 1; // JMS_GFX;
 		r.extent.height = SCREEN_HEIGHT;
 		DrawFilledRectangle (&r);
+		
 		r.corner.x = SAFE_X + SPACE_WIDTH;
-		r.corner.y = SAFE_Y + 139;
+		r.corner.y = SAFE_Y + RES_STAT_SCALE(139); // JMS_GFX;
 		DrawPoint (&r.corner);
-		r.corner.x = SCREEN_WIDTH - 1;
+		
+		r.corner.x = SCREEN_WIDTH - 1; // JMS_GFX;
 		DrawPoint (&r.corner);
 
+		// Light grey border on the left side of big blue box.
 		SetContextForeGroundColor (
 				BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
 		r.corner.y = 1;
 		r.extent.width = 1;
-		r.extent.height = SAFE_Y + SIS_TITLE_HEIGHT;
-		r.corner.x = SIS_ORG_X - 1;
+		r.extent.height = SAFE_Y + SIS_TITLE_HEIGHT + (3 * RESOLUTION_FACTOR); // JMS_GFX
+		r.corner.x = SIS_ORG_X - 1; // JMS_GFX;
 		DrawFilledRectangle (&r);
+		
+		// The same for small blue box
 		r.corner.x = SIS_ORG_X + SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH - 1;
 		DrawFilledRectangle (&r);
-
+		
+		// Light grey horizontal line at the bottom of the screen, space window side
 		r.corner.x = 0;
 		r.corner.y = SCREEN_HEIGHT - 1;
 		r.extent.width = SAFE_X + SPACE_WIDTH - 1;
 		r.extent.height = 1;
 		DrawFilledRectangle (&r);
+		
+		// Light grey vertical line at the right side of space window
 		r.corner.x = SAFE_X + SPACE_WIDTH - 2;
 		r.corner.y = 0;
 		r.extent.width = 1;
 		r.extent.height = SCREEN_HEIGHT - 1;
 		DrawFilledRectangle (&r);
+		
+		//??
 		r.corner.x = SCREEN_WIDTH - 1;
 		r.corner.y = 0;
 		r.extent.width = 1;
-		r.extent.height = SAFE_Y + 139;
+		r.extent.height = SAFE_Y + RES_STAT_SCALE(139); // JMS_GFX
 		DrawFilledRectangle (&r);
+		
+		// Horizontal line at the bottom of the screen, menu window side
 		r.corner.x = SAFE_X + SPACE_WIDTH;
 		r.corner.y = SCREEN_HEIGHT - 1;
 		r.extent.width = SCREEN_WIDTH - r.corner.x;
 		r.extent.height = 1;
 		DrawFilledRectangle (&r);
+		
+		// Vertical line at the right side of the menu window
 		r.corner.x = SCREEN_WIDTH - 1;
-		r.corner.y = SAFE_Y + 140;
+		r.corner.y = SAFE_Y + RES_STAT_SCALE(140);
 		r.extent.width = 1;
 		r.extent.height = (SCREEN_HEIGHT - 1) - r.corner.y;
 		DrawFilledRectangle (&r);
 
-		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
-		r.corner.y = 1;
+		// Dark grey border around blue boxes.
+		SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
+		// Vertical line on the right side of the big blue box
+		r.corner.y = 0;
 		r.extent.width = 1;
 		r.extent.height = SAFE_Y + SIS_MESSAGE_HEIGHT;
 		r.corner.x = SIS_ORG_X + SIS_MESSAGE_BOX_WIDTH;
 		DrawFilledRectangle (&r);
+		// Vertical line on the right side of the small blue box
 		r.corner.x = SIS_ORG_X + SIS_SCREEN_WIDTH;
 		++r.extent.height;
 		DrawFilledRectangle (&r);
+		//
 		r.corner.y = 0;
 		r.extent.width = (SAFE_X + SPACE_WIDTH - 2) - r.corner.x;
 		r.extent.height = 1;
 		DrawFilledRectangle (&r);
+		//
 		r.corner.x = 0;
 		r.extent.width = SIS_ORG_X - r.corner.x;
 		DrawFilledRectangle (&r);
-		r.corner.x = SIS_ORG_X + SIS_MESSAGE_BOX_WIDTH;
-		r.extent.width = SIS_SPACER_BOX_WIDTH;
+		// Horizontal line between boxes
+		r.corner.x = SIS_ORG_X + SIS_MESSAGE_BOX_WIDTH; // JMS_GFX
+		r.extent.width = SIS_SPACER_BOX_WIDTH; // JMS_GFX
 		DrawFilledRectangle (&r);
-
+		//
 		r.corner.x = 0;
 		r.corner.y = 1;
 		r.extent.width = 1;
 		r.extent.height = (SCREEN_HEIGHT - 1) - r.corner.y;
 		DrawFilledRectangle (&r);
+		//
 		r.corner.x = SAFE_X + SPACE_WIDTH;
 		r.corner.y = 0;
 		r.extent.width = 1;
-		r.extent.height = SAFE_Y + 139;
+		r.extent.height = SAFE_Y + RES_STAT_SCALE(139); // JMS_GFX 
 		DrawFilledRectangle (&r);
+		//
 		r.corner.x = SAFE_X + SPACE_WIDTH + 1;
-		r.corner.y = SAFE_Y + 139;
+		r.corner.y = SAFE_Y + RES_STAT_SCALE(139); // JMS_GFX 
 		r.extent.width = STATUS_WIDTH - 2;
 		r.extent.height = 1;
 		DrawFilledRectangle (&r);
+		//
 		r.corner.x = SAFE_X + SPACE_WIDTH;
-		r.corner.y = SAFE_Y + 140;
+		r.corner.y = SAFE_Y + RES_STAT_SCALE(140); // JMS_GFX
 		r.extent.width = 1;
 		r.extent.height = SCREEN_HEIGHT - r.corner.y;
 		DrawFilledRectangle (&r);
@@ -197,4 +227,3 @@ DrawSISFrame (void)
 
 	UnbatchGraphics ();
 }
-
diff -ruNp src.orig/uqm/build.c src/uqm/build.c
--- src.orig/uqm/build.c	2017-11-01 15:30:23 -0700
+++ src/uqm/build.c	2017-11-01 15:31:00 -0700
@@ -25,6 +25,8 @@
 #include "libs/compiler.h"
 #include "libs/mathlib.h"
 
+#include "libs/log.h"
+
 
 // Allocate a new STARSHIP or SHIP_FRAGMENT and put it in the queue
 HLINK
@@ -116,18 +118,24 @@ ActivateStarShip (COUNT which_ship, SIZE
 	{
 		case SPHERE_TRACKING:
 		case SPHERE_KNOWN:
+		case SPHERE_INITIAL: // JMS
 		{
 			FLEET_INFO *FleetPtr;
 
 			FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hFleet);
 			if (state == SPHERE_KNOWN)
 				which_ship = FleetPtr->known_strength;
+			else if (state == SPHERE_INITIAL)
+			{	// JMS: This shows small spheres for the races in the beginning of the game.
+				FleetPtr->known_strength = -10;
+				FleetPtr->known_loc = FleetPtr->loc;
+			}
 			else if (FleetPtr->actual_strength == 0)
 			{
 				if (FleetPtr->allied_state == DEAD_GUY)
 					which_ship = 0;
 			}
-			else if (FleetPtr->known_strength == 0
+			else if (FleetPtr->known_strength <= 0 // JMS:was == 0
 					&& FleetPtr->actual_strength != INFINITE_RADIUS)
 			{
 				FleetPtr->known_strength = 1;
diff -ruNp src.orig/uqm/build.h src/uqm/build.h
--- src.orig/uqm/build.h	2017-11-01 15:30:23 -0700
+++ src/uqm/build.h	2017-11-01 15:31:00 -0700
@@ -16,6 +16,10 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2011: In the beginning of the game, show small spheres for the races.
+
+// JMS_GFX 2011: Merged resolution Factor stuff from UQM-HD.
+
 #ifndef _BUILD_H
 #define _BUILD_H
 
@@ -48,8 +52,8 @@ extern BYTE NameCaptain (QUEUE *pQueue,
 #define SPHERE_KNOWN       -5
 #define SPHERE_TRACKING    -6
 #define ESCORTING_FLAGSHIP -7
-#define FEASIBILITY_STUDY  -8
-		/* Check for how many escort ships there's still space */
+#define FEASIBILITY_STUDY  -8 /* Check for how many escort ships there's still space */
+#define SPHERE_INITIAL	   -9 // JMS: In the beginning of the game, this shows small spheres for the races.
 
 extern COUNT ActivateStarShip (COUNT which_ship, SIZE state);
 extern COUNT GetIndexFromStarShip (QUEUE *pShipQ, HLINK hStarShip);
diff -ruNp src.orig/uqm/cleanup.c src/uqm/cleanup.c
--- src.orig/uqm/cleanup.c	2017-11-01 15:30:23 -0700
+++ src/uqm/cleanup.c	2017-11-01 15:31:00 -0700
@@ -33,7 +33,6 @@
 //  should be something like solarsys.h
 extern void FreeIPData (void);
 
-
 void
 FreeKernel (void)
 {
@@ -67,6 +66,8 @@ UninitKernel (void)
 	DestroyFont (MicroFont);
 	DestroyStringTable (ReleaseStringTable (GameStrings));
 	DestroyDrawable (ReleaseDrawable (StatusFrame));
+	DestroyDrawable (ReleaseDrawable (nebulaeFrame));	// JMS
+	DestroyDrawable (ReleaseDrawable (hyperspacesuns));	// JMS
 	DestroyDrawable (ReleaseDrawable (ActivityFrame));
 	DestroyFont (TinyFont);
 	DestroyFont (StarConFont);
@@ -97,4 +98,3 @@ UninitGameKernel (void)
 		UninitContexts ();
 	}
 }
-
diff -ruNp src.orig/uqm/clock.c src/uqm/clock.c
--- src.orig/uqm/clock.c	2017-11-01 15:30:23 -0700
+++ src/uqm/clock.c	2017-11-01 15:31:00 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: Changed the start date from Feb 17 to Mar 26
+
 #include <stdlib.h>
 #include "gameev.h"
 #include "globdata.h"
@@ -84,6 +86,51 @@ nextClockDay (void)
 	DrawStatusMessage (NULL);
 }
 
+// Computes how many days have passed since the game has begun
+float
+daysElapsed (void)
+{
+	float days = 0;
+	COUNT index;
+	
+	// Years
+	for (index = START_YEAR ; index < GLOBAL (GameClock.year_index) ; index++ )
+		{
+			days += 365;
+			if(IsLeapYear(index))
+				days++;
+		}
+	switch (GLOBAL (GameClock.month_index))
+		{
+		case 1:
+		{
+			days = days - 31 - 28;
+			break;
+		}
+		case 2:
+		{
+			days = days - 28;
+			break;
+		}
+		default:
+			break;
+		}
+	
+	// Months
+	for (index = 3 ; index < GLOBAL (GameClock.month_index) ; index++ )
+		{
+			days += DaysInMonth (index, GLOBAL (GameClock.year_index));
+		}
+	
+	// Days
+	days = days + GLOBAL (GameClock.day_index) - 26;
+
+	// Part of a day
+	days = days + (GLOBAL (GameClock.day_in_ticks) - GLOBAL (GameClock.tick_count)) / (float)GLOBAL (GameClock.day_in_ticks);
+
+	return days;
+}
+
 static void
 processClockDayEvents (void)
 {
@@ -116,9 +163,11 @@ InitGameClock (void)
 	if (!InitQueue (&GLOBAL (GameClock.event_q), NUM_EVENTS, sizeof (EVENT)))
 		return (FALSE);
 	clock_mutex = CreateMutex ("Clock Mutex", SYNC_CLASS_TOPLEVEL);
-	GLOBAL (GameClock.month_index) = 2;
-	GLOBAL (GameClock.day_index) = 17;
-	GLOBAL (GameClock.year_index) = START_YEAR; /* Feb 17, START_YEAR */
+	
+	// JMS: Changed the start date
+	GLOBAL (GameClock.month_index) = 3;
+	GLOBAL (GameClock.day_index) = 26;
+	GLOBAL (GameClock.year_index) = START_YEAR; /* Mar 26, START_YEAR */
 	GLOBAL (GameClock.tick_count) = 0;
 	GLOBAL (GameClock.day_in_ticks) = 0;
 
diff -ruNp src.orig/uqm/clock.h src/uqm/clock.h
--- src.orig/uqm/clock.h	2017-11-01 15:30:23 -0700
+++ src/uqm/clock.h	2017-11-01 15:31:00 -0700
@@ -16,14 +16,16 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: -Changed START_YEAR from 2155 to 2165
+
 #ifndef _CLOCK_H
 #define _CLOCK_H
 
 #include "libs/tasklib.h"
 #include "displist.h"
 
-
-#define START_YEAR 2155
+// JMS: Changed the starting year.
+#define START_YEAR 2165
 
 #define UPDATE_DAY (1 << 0)
 #define UPDATE_MONTH (1 << 1)
@@ -82,6 +84,8 @@ typedef enum
 extern BOOLEAN InitGameClock (void);
 extern BOOLEAN UninitGameClock (void);
 
+extern float daysElapsed (void);
+
 extern void SetGameClockRate (COUNT seconds_per_day);
 extern BOOLEAN ValidateEvent (EVENT_TYPE type, COUNT *pmonth_index,
 		COUNT *pday_index, COUNT *pyear_index);
diff -ruNp src.orig/uqm/cnctdlg.c src/uqm/cnctdlg.c
--- src.orig/uqm/cnctdlg.c	2017-11-01 15:30:23 -0700
+++ src/uqm/cnctdlg.c	2017-11-01 15:31:00 -0700
@@ -29,8 +29,8 @@
 #include "libs/graphics/widgets.h"
 #include "supermelee/netplay/netoptions.h"
 
-#define MCD_WIDTH 260
-#define MCD_HEIGHT 110
+#define MCD_WIDTH (260 << RESOLUTION_FACTOR)
+#define MCD_HEIGHT (110 << RESOLUTION_FACTOR)
 
 #define MENU_FRAME_RATE (ONE_SECOND / 20)
 
@@ -80,12 +80,12 @@ MCD_DrawMenuScreen (WIDGET *_self, int x
 
 	WIDGET_MENU_SCREEN *self = (WIDGET_MENU_SCREEN *)_self;
 	
-	widget_y = y + 8;
+	widget_y = y + (8 << RESOLUTION_FACTOR);
 	for (widget_index = 0; widget_index < self->num_children; widget_index++)
 	{
 		WIDGET *c = self->child[widget_index];
 		(*c->draw)(c, x, widget_y);
-		widget_y += (*c->height)(c) + 8;
+		widget_y += (*c->height)(c) + (8 << RESOLUTION_FACTOR);
 	}
 }
 
@@ -102,7 +102,7 @@ MCD_DrawButton (WIDGET *_self, int x, in
 	selected = MENU_HIGHLIGHT_COLOR;
 	inactive = MENU_TEXT_COLOR;
 
-	t.baseline.x = 160;
+	t.baseline.x = 160 << RESOLUTION_FACTOR;
 	t.baseline.y = y;
 	t.align = ALIGN_CENTER;
 	t.CharCount = ~0;
@@ -153,14 +153,14 @@ MCD_DrawSlider (WIDGET *_self, int x, in
 	font_DrawText (&t);
 
 	r.corner.x = t.baseline.x + 3 * tick;
-	r.corner.y = t.baseline.y - 4;
-	r.extent.height = 2;
+	r.corner.y = t.baseline.y - (4 << RESOLUTION_FACTOR);
+	r.extent.height = 2 << RESOLUTION_FACTOR;
 	r.extent.width = 3 * tick;
 	DrawFilledRectangle (&r);
 
-	r.extent.width = 3;
-	r.extent.height = 8;
-	r.corner.y = t.baseline.y - 7;
+	r.extent.width = 3 << RESOLUTION_FACTOR;
+	r.extent.height = 8 << RESOLUTION_FACTOR;
+	r.corner.y = t.baseline.y - (7 << RESOLUTION_FACTOR);
 	r.corner.x = t.baseline.x + 3 * tick + (3 * tick *
 			(self->value - self->min) / (self->max - self->min)) - 1;
 	DrawFilledRectangle (&r);
@@ -212,7 +212,7 @@ MCD_DrawTextEntry (WIDGET *_self, int x,
 
 	if (!(self->state & WTE_EDITING))
 	{	// normal or selected state
-		t.baseline.x = 160;
+		t.baseline.x = 160 << RESOLUTION_FACTOR;
 		t.align = ALIGN_CENTER;
 
 		if (widget_focus == _self)
@@ -234,7 +234,7 @@ MCD_DrawTextEntry (WIDGET *_self, int x,
 		RECT r;
 		SIZE leading;
 
-		t.baseline.x = x + 90;
+		t.baseline.x = x + (90 << RESOLUTION_FACTOR);
 		t.align = ALIGN_LEFT;
 
 		// calc background box dimensions
@@ -245,7 +245,7 @@ MCD_DrawTextEntry (WIDGET *_self, int x,
 		GetContextFontLeading (&leading);
 		r.corner.x = t.baseline.x - 1;
 		r.corner.y = t.baseline.y - leading + BOX_VERT_OFFSET;
-		r.extent.width = MCD_WIDTH - r.corner.x - 10;
+		r.extent.width = MCD_WIDTH - r.corner.x - (10 << RESOLUTION_FACTOR);
 		r.extent.height = leading + 2;
 
 		TextRect (&t, &text_r, char_deltas);
@@ -536,7 +536,7 @@ DrawConnectDialog (void)
 	DrawShadowedBox (&r, SHADOWBOX_BACKGROUND_COLOR,
 			SHADOWBOX_DARK_COLOR, SHADOWBOX_MEDIUM_COLOR);
 
-	menu.draw ((WIDGET *)&menu, r.corner.x + 10, r.corner.y + 10);
+	menu.draw ((WIDGET *)&menu, r.corner.x + (10 << RESOLUTION_FACTOR), r.corner.y + (10 << RESOLUTION_FACTOR));
 
 	UnlockMutex (GraphicsLock);
 }
diff -ruNp src.orig/uqm/collide.h src/uqm/collide.h
--- src.orig/uqm/collide.h	2017-11-01 15:30:23 -0700
+++ src/uqm/collide.h	2017-11-01 15:31:00 -0700
@@ -27,12 +27,20 @@
 #define SKIP_COLLISION (NONSOLID | DISAPPEARING)
 #define CollidingElement(e) \
 		(!((e)->state_flags & SKIP_COLLISION))
+
+// JMS: Added the clauses with GASSY_SUBSTANCE. Mostly used with Baul Punisher.
+// XXX Ugly hack: the lines with "mass_points == 10" makes Chmmr's zapsats again hittable by all weapons (also other than baul gas.)
 #define CollisionPossible(e0,e1) \
 		(CollidingElement (e0) \
 		&& (!(((e1)->state_flags & (e0)->state_flags) & COLLISION) \
 		&& ((!(((e1)->state_flags & (e0)->state_flags) & IGNORE_SIMILAR) \
 		|| (e1)->pParent != (e0)->pParent)) \
-		&& ((e1)->mass_points || (e0)->mass_points)))
+		&& ((e1)->mass_points || (e0)->mass_points) \
+		&& ((((e1)->state_flags & GASSY_SUBSTANCE) == ((e0)->state_flags & GASSY_SUBSTANCE)) \
+			||(!((e1)->state_flags & GASSY_SUBSTANCE) && ((e0)->state_flags & GASSY_SUBSTANCE) && ((e0)->mass_points == 10)) \
+			||(!((e0)->state_flags & GASSY_SUBSTANCE) && ((e1)->state_flags & GASSY_SUBSTANCE) && ((e1)->mass_points == 10)) \
+			||(((e1)->state_flags & (GASSY_SUBSTANCE | IGNORE_VELOCITY)) && ((e0)->state_flags & PLAYER_SHIP)) \
+			||(((e0)->state_flags & (GASSY_SUBSTANCE | IGNORE_VELOCITY)) && ((e1)->state_flags & PLAYER_SHIP))) ))
 
 #define InitIntersectStartPoint(eptr) \
 { \
diff -ruNp src.orig/uqm/colors.h src/uqm/colors.h
--- src.orig/uqm/colors.h	2017-11-01 15:30:23 -0700
+++ src/uqm/colors.h	2017-11-01 15:31:00 -0700
@@ -284,6 +284,14 @@
 			 BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x07, 0x00), 0x65), \
 		}
 
+#define PC_EXPLORER_CREW_COLOR_TABLE					\
+	{								\
+	BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x07, 0x00), 0x65),		\
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x10, 0x00), 0x65),	\
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x18, 0x00), 0x65),	\
+		BUILD_COLOR (MAKE_RGB15_INIT (0x0A, 0x1E, 0x09), 0x65),	\
+		}
+
 // Colors for the crew in the crew pods as they are filled up,
 // when viewed from the shipyard, when using 3DO fonts.
 #define THREEDO_CREW_COLOR \
@@ -397,7 +405,7 @@
 // === Scan menu and general ===
 
 #define SCAN_PC_TITLE_COLOR \
-		BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x15), 0x3B)
+		BUILD_COLOR (MAKE_RGB15 (0x00, 0x14, 0x14), 0x03)
 
 #define SCAN_INFO_COLOR \
 		BUILD_COLOR (MAKE_RGB15 (0x0F, 0x00, 0x19), 0x3B)
diff -ruNp src.orig/uqm/comm/Makeinfo src/uqm/comm/Makeinfo
--- src.orig/uqm/comm/Makeinfo	2017-11-01 15:30:23 -0700
+++ src/uqm/comm/Makeinfo	2017-11-01 15:31:01 -0700
@@ -1,3 +1,3 @@
-uqm_SUBDIRS="arilou blackur chmmr comandr druuge ilwrath melnorm mycon
-		orz pkunk rebel shofixt slyhome slyland spahome spathi starbas supox
-		syreen talkpet thradd umgah urquan utwig vux yehat zoqfot"
+uqm_SUBDIRS="androsynth arilou blackur chmmr comandr druuge human ilwrath lurg melnorm mycon
+		orz pkunk rebel shofixt shofixticolony slaverace slyhome slyland spahome spathi starbas supox
+		syreen syreenbase syreenhome thradd transport umgah urquan utwig vux yehat yehatpkunk zoqfot"
diff -ruNp src.orig/uqm/comm/androsynth/Makeinfo src/uqm/comm/androsynth/Makeinfo
--- src.orig/uqm/comm/androsynth/Makeinfo	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/androsynth/Makeinfo	2017-11-01 15:31:00 -0700
@@ -0,0 +1 @@
+uqm_CFILES="androsynthc.c"
diff -ruNp src.orig/uqm/comm/androsynth/androsynthc.c src/uqm/comm/androsynth/androsynthc.c
--- src.orig/uqm/comm/androsynth/androsynthc.c	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/androsynth/androsynthc.c	2017-11-01 15:31:00 -0700
@@ -0,0 +1,274 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+// JMS 2010: Completely new file for androsynth communications
+
+#include "../commall.h"
+#include "resinst.h"
+#include "strings.h"
+
+#include "uqm/build.h"
+
+
+static LOCDATA androsynth_desc =
+{
+	ANDROSYNTH_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	ANDROSYNTH_PMAP_ANIM, /* AlienFrame */
+	ANDROSYNTH_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_TOP, /* AlienTextValign */
+	ANDROSYNTH_COLOR_MAP, /* AlienColorMap */
+	ANDROSYNTH_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	ANDROSYNTH_CONVERSATION_PHRASES, /* PlayerPhrases */
+	2, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{ /* Blink */
+			1, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, 0, /* FrameRate */
+			0, ONE_SECOND * 8, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Running light */
+			10, /* StartIndex */
+			30, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 40, 0, /* FrameRate */
+			ONE_SECOND * 2, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+	},
+	{ /* AlienTransitionDesc */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		4, /* StartIndex */
+		6, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 10, ONE_SECOND / 15, /* FrameRate */
+		ONE_SECOND * 7 / 60, ONE_SECOND / 12, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
+};
+
+static void
+ExitConversation (RESPONSE_REF R)
+{
+	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	SET_GAME_STATE (ANDROSYNTH_HOSTILE, 0);
+
+	if (PLAYER_SAID (R, goodbye_at_hello))
+	{
+		NPCPhrase (HELLO_GOODBYE);
+	}
+	
+	if (PLAYER_SAID (R, i_wish_goodbye))
+	{
+		NPCPhrase (GIVE_BLAZER);
+	}
+	
+	if (PLAYER_SAID (R, will_attack))
+	{
+		NPCPhrase (WILL_COME_TO_YOU);
+	}
+}
+
+static void
+FriendlySpaceAndrosynth (RESPONSE_REF R)
+{
+	//	BYTE NumVisits;
+	
+	if (PLAYER_SAID (R, huh_at_hello))
+	{
+		NPCPhrase (HUH_RESPONSE);
+		Response (interested_at_hello, FriendlySpaceAndrosynth);
+		Response (angry_at_hello, FriendlySpaceAndrosynth);
+	}
+
+	if (PLAYER_SAID (R, angry_at_hello))
+	{
+		NPCPhrase (ANGRY_RESPONSE);
+		DISABLE_PHRASE(goodbye_at_hello);
+		Response (calming_down, FriendlySpaceAndrosynth);
+		Response (nice_try, FriendlySpaceAndrosynth);
+		
+	}
+	
+	if (PLAYER_SAID (R, nice_try))
+	{
+		NPCPhrase (WARNING);
+		DISABLE_PHRASE(goodbye_at_hello);
+		Response (will_attack, ExitConversation);
+		Response (not_attack, FriendlySpaceAndrosynth);
+	}
+	
+	if (PLAYER_SAID (R, interested_at_hello) || PLAYER_SAID (R, calming_down) || PLAYER_SAID (R, not_attack))
+	{
+		NPCPhrase (IN_ORZ);
+		SET_GAME_STATE (KNOW_ANDROSYNTH_STATE, 1);
+		Response (what_about_orz_ships, FriendlySpaceAndrosynth);
+		Response (not_trapped, FriendlySpaceAndrosynth);
+	}
+	
+	if (PLAYER_SAID (R, what_about_orz_ships))
+	{
+		NPCPhrase (RECYCLED);
+		SET_GAME_STATE (ANDROSYNTH_STACK_1, 1);
+	}
+	
+	if (PLAYER_SAID (R, thats_horrible))
+	{
+		NPCPhrase (EXISTING_STRUCTURES);
+		SET_GAME_STATE (ANDROSYNTH_STACK_1, 2);
+		Response (not_trapped, FriendlySpaceAndrosynth);
+	}
+	
+	if (PLAYER_SAID (R, not_trapped))
+	{
+		NPCPhrase (INDEPENDENT);
+		SET_GAME_STATE (ANDROSYNTH_STACK_2, 1);
+		Response (kick_ass, FriendlySpaceAndrosynth);
+		Response (rather_not_tell, FriendlySpaceAndrosynth);
+		Response (protective_device, FriendlySpaceAndrosynth);
+	}
+	
+	if (PLAYER_SAID (R, kick_ass) || PLAYER_SAID (R, rather_not_tell) || PLAYER_SAID (R, protective_device))
+	{
+		if (PLAYER_SAID (R, kick_ass))
+			NPCPhrase (KICKASS_RESPONSE);
+		else if (PLAYER_SAID (R, rather_not_tell))
+			NPCPhrase (RATHER_NOT_TELL_RESPONSE);
+		else if (PLAYER_SAID (R, protective_device))
+			NPCPhrase (PROTECTIVE_RESPONSE);
+		
+		SET_GAME_STATE (ANDROSYNTH_STACK_2, 0);		
+		NPCPhrase (JOINT_RESPONSE);
+	}
+	
+	switch (GET_GAME_STATE (ANDROSYNTH_STACK_1))
+	{
+		case 1:
+			Response (thats_horrible, FriendlySpaceAndrosynth);
+			Response (not_trapped, FriendlySpaceAndrosynth);
+			break;
+	}
+	
+	if (GET_GAME_STATE (KNOW_ANDROSYNTH_STATE))
+	{
+		if(PHRASE_ENABLED(i_wish_goodbye) && !GET_GAME_STATE (ANDROSYNTH_STACK_2))
+			Response (i_wish_goodbye, ExitConversation);
+	}
+	else 
+	{
+		if(PHRASE_ENABLED(goodbye_at_hello))
+			Response (goodbye_at_hello, ExitConversation);
+	}
+}
+	
+static void
+Intro (void)
+{
+	//	BYTE NumVisits;
+	
+	RESPONSE_FUNC  RespFunc;
+	if (GET_GAME_STATE(ORZ_SPACE_SIDE) <= 1) {
+		NPCPhrase (NOT_DONE_YET);
+	}
+	
+	else if (!GET_GAME_STATE(ANDROSYNTH_MET))
+	{
+		NPCPhrase (INIT_SPACE_HELLO);
+		RespFunc = (RESPONSE_FUNC)FriendlySpaceAndrosynth;
+		
+		Response (huh_at_hello, RespFunc);
+		Response (interested_at_hello, RespFunc);
+		Response (angry_at_hello, RespFunc);
+		Response (goodbye_at_hello, ExitConversation);
+		
+		SET_GAME_STATE(ANDROSYNTH_MET,1);
+	}
+	else
+	{
+		NPCPhrase (AGAIN_HELLO);
+		RespFunc = (RESPONSE_FUNC)FriendlySpaceAndrosynth;
+		
+		Response (interested_at_hello, RespFunc);
+		Response (angry_at_hello, RespFunc);
+		Response (goodbye_at_hello, ExitConversation);
+	}
+}
+
+static COUNT
+uninit_androsynth (void)
+{
+	return (0);
+}
+
+static void
+post_androsynth_enc (void)
+{
+	// nothing defined so far
+}
+
+LOCDATA*
+init_androsynth_comm (void)
+{
+	LOCDATA *retval;
+
+	androsynth_desc.init_encounter_func = Intro;
+	androsynth_desc.post_encounter_func = post_androsynth_enc;
+	androsynth_desc.uninit_encounter_func = uninit_androsynth;
+
+	androsynth_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
+	androsynth_desc.AlienTextBaseline.y = 0;
+	androsynth_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
+	
+	SET_GAME_STATE (BATTLE_SEGUE, 1);
+	
+	if (GET_GAME_STATE(ORZ_SPACE_SIDE) > 1)
+		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		
+	retval = &androsynth_desc;
+
+	return (retval);
+}
diff -ruNp src.orig/uqm/comm/androsynth/resinst.h src/uqm/comm/androsynth/resinst.h
--- src.orig/uqm/comm/androsynth/resinst.h	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/androsynth/resinst.h	2017-11-01 15:31:00 -0700
@@ -0,0 +1,5 @@
+#define ANDROSYNTH_COLOR_MAP "comm.androsyn.colortable"
+#define ANDROSYNTH_PMAP_ANIM "comm.androsyn.graphics"
+#define ANDROSYNTH_FONT "comm.androsyn.font"
+#define ANDROSYNTH_CONVERSATION_PHRASES "comm.androsyn.dialogue"
+#define ANDROSYNTH_MUSIC "comm.androsyn.music"
diff -ruNp src.orig/uqm/comm/androsynth/strings.h src/uqm/comm/androsynth/strings.h
--- src.orig/uqm/comm/androsynth/strings.h	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/androsynth/strings.h	2017-11-01 15:31:00 -0700
@@ -0,0 +1,59 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _STRINGS_H
+#define _STRINGS_H
+
+enum
+{
+	NULL_PHRASE,
+	NOT_DONE_YET,
+	INIT_SPACE_HELLO,
+	goodbye_at_hello,
+	AGAIN_HELLO,
+	HELLO_GOODBYE,
+	huh_at_hello,
+	HUH_RESPONSE,
+	angry_at_hello,
+	interested_at_hello,
+	ANGRY_RESPONSE,
+	calming_down,
+	nice_try,
+	WARNING,
+	will_attack,
+	not_attack,
+	WILL_COME_TO_YOU,
+	IN_ORZ,
+	what_about_orz_ships,
+	RECYCLED,
+	thats_horrible,
+	EXISTING_STRUCTURES,
+	not_trapped,
+	INDEPENDENT,
+	kick_ass,
+	rather_not_tell,
+	protective_device,
+	KICKASS_RESPONSE,
+	RATHER_NOT_TELL_RESPONSE,
+	PROTECTIVE_RESPONSE,
+	JOINT_RESPONSE,
+	i_wish_goodbye,
+	GIVE_BLAZER,
+};
+
+#endif /* _STRINGS_H */
diff -ruNp src.orig/uqm/comm/arilou/arilouc.c src/uqm/comm/arilou/arilouc.c
--- src.orig/uqm/comm/arilou/arilouc.c	2017-11-01 15:30:23 -0700
+++ src/uqm/comm/arilou/arilouc.c	2017-11-01 15:31:00 -0700
@@ -16,15 +16,25 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: -Arilou guard the Orz space portal and won't let the player through
+//			  if he doesn't have the Temporal Wrapper device.
+//			 -Mycon music for orzspaceportal guards just to mess with fans!
+
 #include "../commall.h"
 #include "resinst.h"
 #include "strings.h"
 
 #include "uqm/gameev.h"
+#include "uqm/encount.h"
+// BW: for ORZ_SPACE_PORTAL_DEFINED, no longer included in commall.h
+
+#include "../mycon/resinst.h" // JMS
+// "../mycon/imusicre.h" // BW: i*.h files have been reformed
 
 
 static LOCDATA arilou_desc =
 {
+	ARILOU_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -36,8 +46,8 @@ static LOCDATA arilou_desc =
 	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
 	ALIGN_CENTER, /* AlienTextAlign */
 	VALIGN_TOP, /* AlienTextValign */
-	ARILOU_COLOR_MAP, /* AlienColorMap */
-	ARILOU_MUSIC, /* AlienSong */
+	ARILOU_ALT_COLOR_MAP, /* AlienColorMap */
+	MYCON_MUSIC, /* AlienSong */
 	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	ARILOU_CONVERSATION_PHRASES, /* PlayerPhrases */
@@ -179,29 +189,29 @@ static LOCDATA arilou_desc =
 			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
 			(1 << 0) | (1 << 1) | (1 << 2)
 		},
-		{	/* Hands moving (right up) */
+		{
 			155, /* StartIndex */
 			2, /* NumFrames */
-			CIRCULAR_ANIM | WAIT_TALKING, /* AnimFlags */
+			CIRCULAR_ANIM, /* AnimFlags */
 			ONE_SECOND / 15, 0, /* FrameRate */
 			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
-			(1 << 19), /* BlockMask */
+			0, /* BlockMask */
 		},
-		{	/* Hands moving (left up) */
+		{
 			157, /* StartIndex */
 			2, /* NumFrames */
-			CIRCULAR_ANIM | WAIT_TALKING, /* AnimFlags */
+			CIRCULAR_ANIM, /* AnimFlags */
 			ONE_SECOND / 15, 0, /* FrameRate */
 			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
-			(1 << 19), /* BlockMask */
+			0, /* BlockMask */
 		},
-		{	/* Stars flashing next to the head */
+		{
 			159, /* StartIndex */
 			4, /* NumFrames */
-			CIRCULAR_ANIM, /* AnimFlags */
+			CIRCULAR_ANIM | WAIT_TALKING,/* AnimFlags */
 			ONE_SECOND / 12, 0, /* FrameRate */
 			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
-			(1 << 17) | (1 << 18), /* BlockMask */
+			0, /* BlockMask */
 		},
 	},
 	{ /* AlienTransitionDesc */
@@ -225,6 +235,11 @@ static LOCDATA arilou_desc =
 	NULL, NULL, NULL,
 	NULL,
 	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
 };
 
 static void
@@ -252,6 +267,18 @@ ExitConversation (RESPONSE_REF R)
 
 		SET_GAME_STATE (ARILOU_MANNER, 2);
 	}
+	// JMS: New conversation options for Arilou at Orz space portal
+	else if (PLAYER_SAID (R, palefaced_babysitters))
+	{
+		NPCPhrase (PREVENT_ACTIONS);
+		Response (i_understand_goodbye, ExitConversation);
+	}
+	else if (PLAYER_SAID (R, i_understand_goodbye))
+	{
+		NPCPhrase (SEE_YOU_IN_FULL_GAME);
+	}
+		
+	
 }
 
 static void
@@ -638,7 +665,7 @@ FriendlySpaceArilou (RESPONSE_REF R)
 static void
 Intro (void)
 {
-	BYTE NumVisits, Manner;
+	//	BYTE NumVisits, Manner;
 
 	if (LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 	{
@@ -647,6 +674,27 @@ Intro (void)
 		SET_GAME_STATE (BATTLE_SEGUE, 0);
 		return;
 	}
+	// JMS: Arilou act as guardians at Orz space portal
+	else if(LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
+	{
+		if(CurStarDescPtr->Index == ORZ_SPACE_PORTAL_DEFINED)
+		{
+			RESPONSE_FUNC  RespFunc;
+			NPCPhrase (BEWARE_MY_CHILD_HELLO);
+			RespFunc = (ExitConversation);
+			Response (palefaced_babysitters, RespFunc);
+			Response (i_understand_goodbye, RespFunc);
+			return;
+		}
+	}
+	
+	else
+	{
+		//		RESPONSE_FUNC  RespFunc;
+		NPCPhrase (TOO_EARLY);
+		return;
+	}
+	/*
 	else if (!GET_GAME_STATE (MET_ARILOU))
 	{
 		RESPONSE_FUNC  RespFunc;
@@ -655,6 +703,7 @@ Intro (void)
 		{
 			NPCPhrase (INIT_HELLO);
 			RespFunc = (RESPONSE_FUNC)FriendlySpaceArilou;
+			
 		}
 		else
 		{
@@ -662,10 +711,12 @@ Intro (void)
 			RespFunc = (RESPONSE_FUNC)ArilouHome;
 			SET_GAME_STATE (ARILOU_HOME_VISITS, 1);
 		}
+		
 		Response (confused_by_hello, RespFunc);
 		Response (happy_by_hello, RespFunc);
 		Response (miffed_by_hello, RespFunc);
 		SET_GAME_STATE (MET_ARILOU, 1);
+		
 		return;
 	}
 
@@ -787,7 +838,7 @@ Intro (void)
 
 			ArilouHome ((RESPONSE_REF)0);
 		}
-	}
+	}*/
 }
 
 static COUNT
@@ -840,15 +891,25 @@ init_arilou_comm (void)
 	arilou_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
 
 	if (GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1
-			|| GET_GAME_STATE (ARILOU_MANNER) == 3
-			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
+		|| GET_GAME_STATE (ARILOU_MANNER) == 3
+		|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 	{
 		SET_GAME_STATE (BATTLE_SEGUE, 0);
 	}
+	// JMS: No fighting with Orz space portal guard arilous.
+	//
+	// Star Description pointer will only be checked if we're not in Hyperspace
+	// ... If we're in hyperspace the pointer doesn't exist and all hell breaks loose!
+	else if(LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
+	{
+		if (CurStarDescPtr->Index == ORZ_SPACE_PORTAL_DEFINED)
+			SET_GAME_STATE (BATTLE_SEGUE, 0);
+	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		SET_GAME_STATE (BATTLE_SEGUE, 0);
 	}
+	
 	retval = &arilou_desc;
 
 	return (retval);
diff -ruNp src.orig/uqm/comm/arilou/resinst.h src/uqm/comm/arilou/resinst.h
--- src.orig/uqm/comm/arilou/resinst.h	2017-11-01 15:30:23 -0700
+++ src/uqm/comm/arilou/resinst.h	2017-11-01 15:31:00 -0700
@@ -1,3 +1,4 @@
+#define ARILOU_ALT_COLOR_MAP "comm.arilou_alt.colortable"
 #define ARILOU_COLOR_MAP "comm.arilou.colortable"
 #define ARILOU_PMAP_ANIM "comm.arilou.graphics"
 #define ARILOU_FONT "comm.arilou.font"
diff -ruNp src.orig/uqm/comm/arilou/strings.h src/uqm/comm/arilou/strings.h
--- src.orig/uqm/comm/arilou/strings.h	2017-11-01 15:30:23 -0700
+++ src/uqm/comm/arilou/strings.h	2017-11-01 15:31:00 -0700
@@ -118,6 +118,12 @@ enum
 	APOLOGIZE_AT_HOMEWORLD,
 	bye_angry_space,
 	GOODBYE_ANGRY_SPACE,
+	BEWARE_MY_CHILD_HELLO,
+	palefaced_babysitters,
+	PREVENT_ACTIONS,
+	i_understand_goodbye,
+	SEE_YOU_IN_FULL_GAME,
+	TOO_EARLY,
 	OUT_TAKES,
 };
 
diff -ruNp src.orig/uqm/comm/blackur/blackurc.c src/uqm/comm/blackur/blackurc.c
--- src.orig/uqm/comm/blackur/blackurc.c	2017-11-01 15:30:23 -0700
+++ src/uqm/comm/blackur/blackurc.c	2017-11-01 15:31:00 -0700
@@ -16,12 +16,15 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: New dialogue for the new, vile, disgusting and enhanced Kohr-Ah-Rath!
+
 #include "../commall.h"
 #include "resinst.h"
 #include "strings.h"
 
 static LOCDATA blackurq_desc =
 {
+	BLACKURQ_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -38,7 +41,7 @@ static LOCDATA blackurq_desc =
 	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	BLACKURQ_CONVERSATION_PHRASES, /* PlayerPhrases */
-	8, /* NumAnimations */
+	7, /* NumAnimations */
 	{ /* AlienAmbientArray (ambient animations) */
 		{
 			7, /* StartIndex */
@@ -81,14 +84,6 @@ static LOCDATA blackurq_desc =
 			0, /* BlockMask */
 		},
 		{
-			29, /* StartIndex */
-			4, /* NumFrames */
-			RANDOM_ANIM, /* AnimFlags */
-			ONE_SECOND / 10, 0, /* FrameRate */
-			ONE_SECOND / 10, 0, /* RestartRate */
-			0, /* BlockMask */
-		},
-		{
 			33, /* StartIndex */
 			5, /* NumFrames */
 			CIRCULAR_ANIM
@@ -107,7 +102,7 @@ static LOCDATA blackurq_desc =
 		},
 	},
 	{ /* AlienTransitionDesc */
-		1, /* StartIndex */
+		29, /* StartIndex */
 		2, /* NumFrames */
 		0, /* AnimFlags */
 		ONE_SECOND / 6, 0, /* FrameRate */
@@ -115,11 +110,11 @@ static LOCDATA blackurq_desc =
 		0, /* BlockMask */
 	},
 	{ /* AlienTalkDesc */
-		2, /* StartIndex */
-		5, /* NumFrames */
-		0, /* AnimFlags */
-		ONE_SECOND / 15, 0, /* FrameRate */
-		ONE_SECOND / 12, 0, /* RestartRate */
+		29, /* StartIndex */
+		4, /* NumFrames */
+		RANDOM_ANIM, /* AnimFlags */
+		ONE_SECOND / 10, 0, /* FrameRate */
+		ONE_SECOND / 10, 0, /* RestartRate */
 		0, /* BlockMask */
 	},
 	NULL, /* AlienNumberSpeech - none */
@@ -127,6 +122,11 @@ static LOCDATA blackurq_desc =
 	NULL, NULL, NULL,
 	NULL,
 	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
 };
 
 static void
@@ -134,6 +134,8 @@ CombatIsInevitable (RESPONSE_REF R)
 {
 	BYTE NumVisits;
 
+	int temp_info;
+	
 	SET_GAME_STATE (BATTLE_SEGUE, 1);
 
 	if (PLAYER_SAID (R, bye))
@@ -141,390 +143,136 @@ CombatIsInevitable (RESPONSE_REF R)
 		if (GET_GAME_STATE (KOHR_AH_BYES) == 0)
 			NPCPhrase (GOODBYE_AND_DIE);
 		else
-			NPCPhrase (DIE_HUMAN /* GOODBYE_AND_DIE_2 */);
+			NPCPhrase (DIE_HUMAN);
 
 		SET_GAME_STATE (KOHR_AH_BYES, 1);
 	}
-	else if (PLAYER_SAID (R, guess_thats_all))
-		NPCPhrase (THEN_DIE);
-	else if (PLAYER_SAID (R, what_are_you_hovering_over))
+	
+	if (PLAYER_SAID (R, we_attack))
 	{
-		NPCPhrase (BONE_PILE);
-
-		SET_GAME_STATE (KOHR_AH_INFO, 1);
+		NPCPhrase (NO_WE_ATTACK);
 	}
-	else if (PLAYER_SAID (R, you_sure_are_creepy))
+		
+	if (PLAYER_SAID (R, murderous_bastards))
 	{
-		NPCPhrase (YES_CREEPY);
-
-		SET_GAME_STATE (KOHR_AH_INFO, 2);
-	}
-	else if (PLAYER_SAID (R, stop_that_gross_blinking))
-	{
-		NPCPhrase (DIE_HUMAN);
-
-		SET_GAME_STATE (KOHR_AH_INFO, 3);
-	}
-	else if (PLAYER_SAID (R, threat_1)
-			|| PLAYER_SAID (R, threat_2)
-			|| PLAYER_SAID (R, threat_3)
-			|| PLAYER_SAID (R, threat_4))
+		NPCPhrase (BRING_IT_ON);
+		temp_info=GET_GAME_STATE (KOHR_AH_PLEAD);
+		SET_GAME_STATE(KOHR_AH_PLEAD, (temp_info+1));
+	}
+	
+	else if (PLAYER_SAID (R, give_up_1)
+			|| PLAYER_SAID (R, give_up_extra_2)
+			|| PLAYER_SAID (R, give_up_3))
 	{
 		NumVisits = GET_GAME_STATE (KOHR_AH_REASONS);
 		switch (NumVisits++)
 		{
 			case 0:
-				NPCPhrase (RESISTANCE_IS_USELESS_1);
+				NPCPhrase (NO_GIVE_UP_1);
 				break;
 			case 1:
-				NPCPhrase (RESISTANCE_IS_USELESS_2);
+				NPCPhrase (NO_GIVE_UP_EXTRA_2);
 				break;
 			case 2:
-				NPCPhrase (RESISTANCE_IS_USELESS_3);
-				break;
-			case 3:
-				NPCPhrase (RESISTANCE_IS_USELESS_4);
+				NPCPhrase (NO_GIVE_UP_3);
 				--NumVisits;
 				break;
 		}
 		SET_GAME_STATE (KOHR_AH_REASONS, NumVisits);
 	}
-	else if (PLAYER_SAID (R, plead_1)
-			|| PLAYER_SAID (R, plead_2)
-			|| PLAYER_SAID (R, plead_3)
-			|| PLAYER_SAID (R, plead_4))
-	{
-		NumVisits = GET_GAME_STATE (KOHR_AH_PLEAD);
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (PLEADING_IS_USELESS_1);
-				break;
-			case 1:
-				NPCPhrase (PLEADING_IS_USELESS_2);
-				break;
-			case 2:
-				// This response disabled due to lack of a speech file.
-				// NPCPhrase (PLEADING_IS_USELESS_3);
-				// break;
-			case 3:
-				NPCPhrase (PLEADING_IS_USELESS_4);
-				--NumVisits;
-				break;
-		}
-		SET_GAME_STATE (KOHR_AH_PLEAD, NumVisits);
-	}
-	else if (PLAYER_SAID (R, why_kill_all_1)
-			|| PLAYER_SAID (R, why_kill_all_2)
-			|| PLAYER_SAID (R, why_kill_all_3)
-			|| PLAYER_SAID (R, why_kill_all_4))
-	{
-		NumVisits = GET_GAME_STATE (KOHR_AH_REASONS);
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (KILL_BECAUSE_1);
-				break;
-			case 1:
-				NPCPhrase (KILL_BECAUSE_2);
-				break;
-			case 2:
-				NPCPhrase (KILL_BECAUSE_3);
-				break;
-			case 3:
-				NPCPhrase (KILL_BECAUSE_4);
-				--NumVisits;
-				break;
-		}
-		SET_GAME_STATE (KOHR_AH_REASONS, NumVisits);
-	}
-	else if (PLAYER_SAID (R, please_dont_kill_1)
-			|| PLAYER_SAID (R, please_dont_kill_2)
-			|| PLAYER_SAID (R, please_dont_kill_3)
-			|| PLAYER_SAID (R, please_dont_kill_4))
-	{
-		NumVisits = GET_GAME_STATE (KOHR_AH_PLEAD);
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (WILL_KILL_1);
-				break;
-			case 1:
-				NPCPhrase (WILL_KILL_2);
-				break;
-			case 2:
-				NPCPhrase (WILL_KILL_3);
-				break;
-			case 3:
-				NPCPhrase (WILL_KILL_4);
-				--NumVisits;
-				break;
-		}
-		SET_GAME_STATE (KOHR_AH_PLEAD, NumVisits);
-	}
-	else if (PLAYER_SAID (R, bye_frenzy_1)
-			|| PLAYER_SAID (R, bye_frenzy_2)
-			|| PLAYER_SAID (R, bye_frenzy_3)
-			|| PLAYER_SAID (R, bye_frenzy_4))
-	{
-		NumVisits = GET_GAME_STATE (KOHR_AH_INFO);
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (GOODBYE_AND_DIE_FRENZY_1);
-				break;
-			case 1:
-				NPCPhrase (GOODBYE_AND_DIE_FRENZY_2);
-				break;
-			case 2:
-				NPCPhrase (GOODBYE_AND_DIE_FRENZY_3);
-				break;
-			case 3:
-				NPCPhrase (GOODBYE_AND_DIE_FRENZY_4);
-				--NumVisits;
-				break;
-		}
-		SET_GAME_STATE (KOHR_AH_INFO, NumVisits);
-	}
 }
 
 static void
-Frenzy (RESPONSE_REF R)
-{
-	(void) R;  // ignored
-	switch (GET_GAME_STATE (KOHR_AH_REASONS))
-	{
-		case 0:
-			Response (why_kill_all_1, CombatIsInevitable);
-			break;
-		case 1:
-			Response (why_kill_all_2, CombatIsInevitable);
-			break;
-		case 2:
-			Response (why_kill_all_3, CombatIsInevitable);
-			break;
-		case 3:
-			Response (why_kill_all_4, CombatIsInevitable);
-			break;
-	}
-	switch (GET_GAME_STATE (KOHR_AH_PLEAD))
-	{
-		case 0:
-			Response (please_dont_kill_1, CombatIsInevitable);
-			break;
-		case 1:
-			Response (please_dont_kill_2, CombatIsInevitable);
-			break;
-		case 2:
-			Response (please_dont_kill_3, CombatIsInevitable);
-			break;
-		case 3:
-			Response (please_dont_kill_4, CombatIsInevitable);
-			break;
-	}
-	switch (GET_GAME_STATE (KOHR_AH_INFO))
-	{
-		case 0:
-			Response (bye_frenzy_1, CombatIsInevitable);
-			break;
-		case 1:
-			Response (bye_frenzy_2, CombatIsInevitable);
-			break;
-		case 2:
-			Response (bye_frenzy_3, CombatIsInevitable);
-			break;
-		case 3:
-			Response (bye_frenzy_4, CombatIsInevitable);
-			break;
-	}
-}
-
-static void
-KohrAhStory (RESPONSE_REF R)
+DieHuman (RESPONSE_REF R)
 {
-	if (PLAYER_SAID (R, key_phrase))
-	{
-		NPCPhrase (RESPONSE_TO_KEY_PHRASE);
-
-		SET_GAME_STATE (KNOW_KOHR_AH_STORY, 2);
-	}
-	else if (PLAYER_SAID (R, why_do_you_destroy))
+	//(void) R;  // ignored
+	int temp_info;
+	
+	if (PLAYER_SAID (R, who_is_rath))
 	{
-		NPCPhrase (WE_WERE_SLAVES);
-
-		DISABLE_PHRASE (why_do_you_destroy);
+		NPCPhrase (RATH_IS_GREAT);
+		temp_info=GET_GAME_STATE (KOHR_AH_INFO);
+		SET_GAME_STATE(KOHR_AH_INFO, (temp_info+1));
 	}
-	else if (PLAYER_SAID (R, relationship_with_urquan))
+	if (PLAYER_SAID (R, hmm_new_doctrine))
 	{
-		NPCPhrase (WE_ARE_URQUAN_TOO);
-
-		DISABLE_PHRASE (relationship_with_urquan);
+		NPCPhrase (THIS_IS_NEW_DOCTRINE);
+		temp_info=GET_GAME_STATE (KOHR_AH_INFO);
+		SET_GAME_STATE(KOHR_AH_INFO, (temp_info+1));
 	}
-	else if (PLAYER_SAID (R, what_about_culture))
+	if (PLAYER_SAID (R, wheres_talking_pet))
 	{
-		NPCPhrase (BONE_GARDENS);
-
-		DISABLE_PHRASE (what_about_culture);
+		NPCPhrase (TALKING_PET_DEAD);
+		temp_info=GET_GAME_STATE (KOHR_AH_PLEAD);
+		SET_GAME_STATE(KOHR_AH_PLEAD, (temp_info+1));
 	}
-	else if (PLAYER_SAID (R, how_leave_me_alone))
+	if (PLAYER_SAID (R, give_up_2))
 	{
-		NPCPhrase (YOU_DIE);
-
-		DISABLE_PHRASE (how_leave_me_alone);
+		NPCPhrase (NO_GIVE_UP_2);
+		DISABLE_PHRASE (give_up_2);
 	}
-
-	if (PHRASE_ENABLED (why_do_you_destroy))
-		Response (why_do_you_destroy, KohrAhStory);
-	if (PHRASE_ENABLED (relationship_with_urquan))
-		Response (relationship_with_urquan, KohrAhStory);
-	if (PHRASE_ENABLED (what_about_culture))
-		Response (what_about_culture, KohrAhStory);
-	if (PHRASE_ENABLED (how_leave_me_alone))
-		Response (how_leave_me_alone, KohrAhStory);
-	Response (guess_thats_all, CombatIsInevitable);
-}
-
-static void
-DieHuman (RESPONSE_REF R)
-{
-	(void) R;  // ignored
+		
 	switch (GET_GAME_STATE (KOHR_AH_REASONS))
 	{
 		case 0:
-			Response (threat_1, CombatIsInevitable);
+			Response (give_up_1, CombatIsInevitable);
 			break;
 		case 1:
-			Response (threat_2, CombatIsInevitable);
+			if(PHRASE_ENABLED(give_up_2))
+				Response (give_up_2, DieHuman);
+			else
+				Response (give_up_extra_2, CombatIsInevitable);
 			break;
 		case 2:
-			Response (threat_3, CombatIsInevitable);
-			break;
-		case 3:
-			Response (threat_4, CombatIsInevitable);
+			Response (give_up_3, CombatIsInevitable);
 			break;
 	}
-	if (GET_GAME_STATE (KNOW_KOHR_AH_STORY) == 1)
-	{
-		Response (key_phrase, KohrAhStory);
-	}
 	switch (GET_GAME_STATE (KOHR_AH_INFO))
 	{
 		case 0:
-			Response (what_are_you_hovering_over, CombatIsInevitable);
+			Response (who_is_rath, DieHuman);
 			break;
 		case 1:
-			Response (you_sure_are_creepy, CombatIsInevitable);
-			break;
-		case 2:
-			Response (stop_that_gross_blinking, CombatIsInevitable);
+			Response (hmm_new_doctrine, DieHuman);
 			break;
 	}
 	switch (GET_GAME_STATE (KOHR_AH_PLEAD))
 	{
 		case 0:
-			Response (plead_1, CombatIsInevitable);
+			Response (wheres_talking_pet, DieHuman);
 			break;
 		case 1:
-			Response (plead_2, CombatIsInevitable);
-			break;
-		case 2:
-			// This response disabled due to lack of a speech file.
-			// Response (plead_3, CombatIsInevitable);
-			// break;
-		case 3:
-			Response (plead_4, CombatIsInevitable);
+			Response (murderous_bastards, CombatIsInevitable);
 			break;
 	}
+	Response (we_attack, CombatIsInevitable);
 	Response (bye, CombatIsInevitable);
 }
 
 static void
 Intro (void)
 {
-	DWORD GrpOffs;
-
-	if (LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
-	{
-		NPCPhrase (OUT_TAKES);
-
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
-		return;
-	}
-
-	if (GET_GAME_STATE (KOHR_AH_KILLED_ALL))
-	{
-		NPCPhrase (GAME_OVER_DUDE);
-
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
-		return;
-	}
-
-	if (!GET_GAME_STATE (KOHR_AH_SENSES_EVIL)
-			&& GET_GAME_STATE (TALKING_PET_ON_SHIP))
-	{
-		NPCPhrase (SENSE_EVIL);
-		SET_GAME_STATE (KOHR_AH_SENSES_EVIL, 1);
-	}
+	BYTE NumVisits;
 
-	GrpOffs = GET_GAME_STATE_32 (SAMATRA_GRPOFFS0);
-	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
-			&& GLOBAL (BattleGroupRef)
-			&& GLOBAL (BattleGroupRef) == GrpOffs)
+	NumVisits = GET_GAME_STATE (KOHR_AH_VISITS);
+	switch (NumVisits++)
 	{
-		NPCPhrase (HELLO_SAMATRA);
-
-		SET_GAME_STATE (AWARE_OF_SAMATRA, 1);
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
-	}
-	else
-	{
-		BYTE NumVisits;
-
-		NumVisits = GET_GAME_STATE (KOHR_AH_VISITS);
-		if (GET_GAME_STATE (KOHR_AH_FRENZY))
-		{
-			switch (NumVisits++)
-			{
-				case 0:
-					NPCPhrase (WE_KILL_ALL_1);
-					break;
-				case 1:
-					NPCPhrase (WE_KILL_ALL_2);
-					break;
-				case 2:
-					NPCPhrase (WE_KILL_ALL_3);
-					break;
-				case 3:
-					NPCPhrase (WE_KILL_ALL_4);
-					--NumVisits;
-					break;
-			}
-
-			Frenzy ((RESPONSE_REF)0);
-		}
-		else
-		{
-			switch (NumVisits++)
-			{
-				case 0:
-					NPCPhrase (HELLO_AND_DIE_1);
-					break;
-				case 1:
-					NPCPhrase (HELLO_AND_DIE_2);
-					break;
-				case 2:
-					NPCPhrase (HELLO_AND_DIE_3);
-					break;
-				case 3:
-					NPCPhrase (HELLO_AND_DIE_4);
-					--NumVisits;
-					break;
-			}
-
-			DieHuman ((RESPONSE_REF)0);
-		}
-		SET_GAME_STATE (KOHR_AH_VISITS, NumVisits);
+		case 0:
+			NPCPhrase (HELLO_AND_DIE_1);
+			break;
+		case 1:
+			NPCPhrase (HELLO_AND_DIE_2);
+			break;
+		case 2:
+			NPCPhrase (HELLO_AND_DIE_3);
+			break;
+		case 3:
+			NPCPhrase (HELLO_AND_DIE_4);
+			--NumVisits;
+			break;
 	}
+	DieHuman ((RESPONSE_REF)0);
+	SET_GAME_STATE (KOHR_AH_VISITS, NumVisits);
 }
 
 static COUNT
@@ -552,15 +300,8 @@ init_blackurq_comm (void)
 	blackurq_desc.AlienTextBaseline.y = 0;
 	blackurq_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
 
-	if (!GET_GAME_STATE (KOHR_AH_KILLED_ALL)
-			&& LOBYTE (GLOBAL (CurrentActivity)) != WON_LAST_BATTLE)
-	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
-	}
-	else
-	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
-	}
+	SET_GAME_STATE (BATTLE_SEGUE, 1);
+	
 	retval = &blackurq_desc;
 
 	return (retval);
diff -ruNp src.orig/uqm/comm/blackur/strings.h src/uqm/comm/blackur/strings.h
--- src.orig/uqm/comm/blackur/strings.h	2017-11-01 15:30:23 -0700
+++ src/uqm/comm/blackur/strings.h	2017-11-01 15:31:00 -0700
@@ -22,7 +22,6 @@
 enum
 {
 	NULL_PHRASE,
-	SENSE_EVIL,
 	HELLO_AND_DIE_1,
 	HELLO_AND_DIE_2,
 	HELLO_AND_DIE_3,
@@ -31,73 +30,27 @@ enum
 	HELLO_AND_DIE_6,
 	HELLO_AND_DIE_7,
 	HELLO_AND_DIE_8,
-	HELLO_SAMATRA,
-	WE_KILL_ALL_1,
-	WE_KILL_ALL_2,
-	WE_KILL_ALL_3,
-	WE_KILL_ALL_4,
-	why_kill_all_1,
-	why_kill_all_2,
-	why_kill_all_3,
-	why_kill_all_4,
-	KILL_BECAUSE_1,
-	KILL_BECAUSE_2,
-	KILL_BECAUSE_3,
-	KILL_BECAUSE_4,
-	please_dont_kill_1,
-	WILL_KILL_1,
-	please_dont_kill_2,
-	WILL_KILL_2,
-	please_dont_kill_3,
-	WILL_KILL_3,
-	please_dont_kill_4,
-	WILL_KILL_4,
-	bye_frenzy_1,
-	bye_frenzy_2,
-	bye_frenzy_3,
-	bye_frenzy_4,
-	GOODBYE_AND_DIE_FRENZY_1,
-	GOODBYE_AND_DIE_FRENZY_2,
-	GOODBYE_AND_DIE_FRENZY_3,
-	GOODBYE_AND_DIE_FRENZY_4,
-	threat_1,
-	RESISTANCE_IS_USELESS_1,
-	threat_2,
-	RESISTANCE_IS_USELESS_2,
-	threat_3,
-	RESISTANCE_IS_USELESS_3,
-	threat_4,
-	RESISTANCE_IS_USELESS_4,
-	key_phrase,
-	RESPONSE_TO_KEY_PHRASE,
-	why_do_you_destroy,
-	WE_WERE_SLAVES,
-	relationship_with_urquan,
-	WE_ARE_URQUAN_TOO,
-	what_about_culture,
-	BONE_GARDENS,
-	how_leave_me_alone,
-	YOU_DIE,
-	guess_thats_all,
-	THEN_DIE,
-	what_are_you_hovering_over,
-	BONE_PILE,
-	you_sure_are_creepy,
-	YES_CREEPY,
-	stop_that_gross_blinking,
-	DIE_HUMAN,
-	plead_1,
-	PLEADING_IS_USELESS_1,
-	plead_2,
-	PLEADING_IS_USELESS_2,
-	plead_3,
-	PLEADING_IS_USELESS_3,
-	plead_4,
-	PLEADING_IS_USELESS_4,
+	give_up_1,
+	NO_GIVE_UP_1,
+	give_up_2,
+	NO_GIVE_UP_2,
+	give_up_extra_2,
+	NO_GIVE_UP_EXTRA_2,
+	give_up_3,
+	NO_GIVE_UP_3,
+	who_is_rath,
+	RATH_IS_GREAT,
+	hmm_new_doctrine,
+	THIS_IS_NEW_DOCTRINE,
+	wheres_talking_pet,
+	TALKING_PET_DEAD,
+	murderous_bastards,
+	BRING_IT_ON,
+	we_attack,
+	NO_WE_ATTACK,
 	bye,
 	GOODBYE_AND_DIE,
-	GAME_OVER_DUDE,
-	OUT_TAKES,
+	DIE_HUMAN,
 };
 
 #endif /* _STRINGS_H */
diff -ruNp src.orig/uqm/comm/chmmr/chmmrc.c src/uqm/comm/chmmr/chmmrc.c
--- src.orig/uqm/comm/chmmr/chmmrc.c	2017-11-01 15:30:23 -0700
+++ src/uqm/comm/chmmr/chmmrc.c	2017-11-01 15:31:00 -0700
@@ -27,6 +27,7 @@
 
 static LOCDATA chmmr_desc =
 {
+	CHMMR_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -115,498 +116,240 @@ static LOCDATA chmmr_desc =
 	NULL, NULL, NULL,
 	NULL,
 	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
 };
 
 static void
 ExitConversation (RESPONSE_REF R)
-{
+{	
+	(void) R; // satisfy compiler
 	SET_GAME_STATE (BATTLE_SEGUE, 0);
-
-	if (PLAYER_SAID (R, bye))
-		NPCPhrase (GOODBYE);
-	else if (PLAYER_SAID (R, bye_shielded))
-		NPCPhrase (GOODBYE_SHIELDED);
-	else if (PLAYER_SAID (R, bye_after_bomb))
-		NPCPhrase (GOODBYE_AFTER_BOMB);
-	else if (PLAYER_SAID (R, proceed))
-	{
-		int i;
-
-		NPCPhrase (TAKE_2_WEEKS);
-
-		ActivateStarShip (CHMMR_SHIP, SET_ALLIED);
-
-		SET_GAME_STATE (CHMMR_HOME_VISITS, 0);
-		SET_GAME_STATE (CHMMR_STACK, 0);
-		SET_GAME_STATE (CHMMR_BOMB_STATE, 2);
-		SET_GAME_STATE (UTWIG_BOMB_ON_SHIP, 0);
-		GLOBAL_SIS (ResUnits) = 1000000L;
-		GLOBAL_SIS (NumLanders) = 0;
-		GLOBAL (ModuleCost[PLANET_LANDER]) = 0;
-
-#define EARTH_INDEX 2 /* earth is 3rd planet --> 3 - 1 = 2 */
-/* Magic numbers for Earth */
-#define EARTH_OUTER_X (-725)
-#define EARTH_OUTER_Y (597)
-#define EARTH_INNER_X (121)
-#define EARTH_INNER_Y (113)
-/* Magic numbers for Earth Starbase */
-#define STARBASE_INNER_X (86)
-#define STARBASE_INNER_Y (113)
-
-		/* transport player to Earth */
-		GLOBAL_SIS (log_x) = UNIVERSE_TO_LOGX (SOL_X);
-		GLOBAL_SIS (log_y) = UNIVERSE_TO_LOGY (SOL_Y);
-		GLOBAL (ShipFacing) = 1;
-		/* At Earth or at Starbase */
-		GLOBAL (ip_planet) = EARTH_INDEX + 1;
-		GLOBAL (in_orbit) = 0;
-		/* XXX : this should be unhardcoded eventually */
-		GLOBAL (ip_location.x) = EARTH_OUTER_X;
-		GLOBAL (ip_location.y) = EARTH_OUTER_Y;
-
-		if (GET_GAME_STATE (STARBASE_AVAILABLE))
-		{	/* Normal game mode - you are transported to Starbase */
-			GLOBAL_SIS (FuelOnBoard) = FUEL_RESERVE;
-			GLOBAL_SIS (CrewEnlisted) = 0;
-			GLOBAL_SIS (TotalElementMass) = 0;
-			GLOBAL (ModuleCost[STORAGE_BAY]) = 0; /* disable Storage Bay */
-			for (i = 0; i < NUM_ELEMENT_CATEGORIES; ++i)
-				GLOBAL_SIS (ElementAmounts[i]) = 0;
-			for (i = NUM_BOMB_MODULES; i < NUM_MODULE_SLOTS; ++i)
-				GLOBAL_SIS (ModuleSlots[i]) = EMPTY_SLOT + 2;
-
-			/* XXX : this should be unhardcoded eventually */
-			/* transport to Starbase */
-			GLOBAL (ShipStamp.origin.x) = STARBASE_INNER_X - SAFE_X;
-			GLOBAL (ShipStamp.origin.y) = STARBASE_INNER_Y - SAFE_Y;
-		}
-		else
-		{	/* 'Beating Game Differently' mode - never visited Starbase,
-			 * so you are transported to Earth */
-			/* compress the layout -- move all to front */
-			for (i = NUM_MODULE_SLOTS - 1; i > 0; --i)
-			{
-				int m;
-
-				/* find next unused slot */
-				for (; i > 0
-						&& GLOBAL_SIS (ModuleSlots[i]) != EMPTY_SLOT + 2;
-						--i)
-					;
-				if (i == 0)
-					break;
-				/* find next module to move */
-				for (m = i - 1; m >= 0
-						&& GLOBAL_SIS (ModuleSlots[m]) == EMPTY_SLOT + 2;
-						--m)
-					;
-				if (m < 0)
-					break;
-								
-				/* move the module */
-				GLOBAL_SIS (ModuleSlots[i]) = GLOBAL_SIS (ModuleSlots[m]);
-				GLOBAL_SIS (ModuleSlots[m]) = EMPTY_SLOT + 2;
-			}
-
-			/* XXX : this should be unhardcoded eventually */
-			/* transport to Earth itself */
-			GLOBAL (ShipStamp.origin.x) = EARTH_INNER_X - SAFE_X;
-			GLOBAL (ShipStamp.origin.y) = EARTH_INNER_Y - SAFE_Y;
-		}
-
-		/* install Chmmr-supplied modules */
-		for (i = 0; i < NUM_DRIVE_SLOTS; ++i)
-			GLOBAL_SIS (DriveSlots[i]) = FUSION_THRUSTER;
-		for (i = 0; i < NUM_JET_SLOTS; ++i)
-			GLOBAL_SIS (JetSlots[i]) = TURNING_JETS;
-		GLOBAL_SIS (ModuleSlots[0]) = BOMB_MODULE_4;
-		GLOBAL_SIS (ModuleSlots[1]) = BOMB_MODULE_5;
-		GLOBAL_SIS (ModuleSlots[2]) = BOMB_MODULE_3;
-		GLOBAL_SIS (ModuleSlots[3]) = BOMB_MODULE_1;
-		GLOBAL_SIS (ModuleSlots[4]) = BOMB_MODULE_0;
-		GLOBAL_SIS (ModuleSlots[5]) = BOMB_MODULE_1;
-		GLOBAL_SIS (ModuleSlots[6]) = BOMB_MODULE_3;
-		GLOBAL_SIS (ModuleSlots[7]) = BOMB_MODULE_4;
-		GLOBAL_SIS (ModuleSlots[8]) = BOMB_MODULE_5;
-		GLOBAL_SIS (ModuleSlots[9]) = BOMB_MODULE_2;
-	}
+	NPCPhrase (GOODBYE_HUMAN1);
 }
 
 static void
-NotReady (RESPONSE_REF R)
-{
-	if (R == 0)
-		NPCPhrase (RETURN_WHEN_READY);
-	else if (PLAYER_SAID (R, further_assistance))
-	{
-		NPCPhrase (NO_FURTHER_ASSISTANCE);
-
-		DISABLE_PHRASE (further_assistance);
-	}
-	else if (PLAYER_SAID (R, tech_help))
-	{
-		NPCPhrase (USE_OUR_SHIPS_BEFORE);
-
-		ActivateStarShip (CHMMR_SHIP, SET_ALLIED);
-	}
-	else if (PLAYER_SAID (R, where_weapon))
-	{
-		NPCPhrase (PRECURSOR_WEAPON);
-
-		DISABLE_PHRASE (where_weapon);
-	}
-	else if (PLAYER_SAID (R, where_distraction))
-	{
-		NPCPhrase (PSYCHIC_WEAPONRY);
-
-		DISABLE_PHRASE (where_distraction);
-	}
-
-	if (ActivateStarShip (CHMMR_SHIP, CHECK_ALLIANCE) != GOOD_GUY)
-		Response (tech_help, NotReady);
-	else if (PHRASE_ENABLED (further_assistance))
-		Response (further_assistance, NotReady);
-	if (PHRASE_ENABLED (where_weapon) && !GET_GAME_STATE (UTWIG_BOMB_ON_SHIP))
-		Response (where_weapon, NotReady);
-	if (PHRASE_ENABLED (where_distraction) && !GET_GAME_STATE (TALKING_PET_ON_SHIP))
-		Response (where_distraction, NotReady);
-	Response (bye, ExitConversation);
-}
+AskMenu (RESPONSE_REF R);
 
 static void
-ImproveBomb (RESPONSE_REF R)
-{
-	if (R == 0)
-		NPCPhrase (WE_WILL_IMPROVE_BOMB);
-	else if (PLAYER_SAID (R, what_now))
-	{
-		NPCPhrase (MODIFY_VESSEL);
-
-		DISABLE_PHRASE (what_now);
-	}
-	else if (PLAYER_SAID (R, wont_hurt_my_ship))
-	{
-		NPCPhrase (WILL_DESTROY_IT);
+WhereKohrah (RESPONSE_REF R)
+{	
+	(void) R; // satisfy compiler
+	NPCPhrase (KOHRAH_ARE);
+	DISABLE_PHRASE (where_kohrah);	
 
-		DISABLE_PHRASE (wont_hurt_my_ship);
-	}
-	else if (PLAYER_SAID (R, bummer_about_my_ship))
-	{
-		NPCPhrase (DEAD_SILENCE);
+	Response (why_kohrah_still_here, AskMenu);
+}
 
-		DISABLE_PHRASE (bummer_about_my_ship);
-	}
-	else if (PLAYER_SAID (R, other_assistance))
-	{
-		NPCPhrase (USE_OUR_SHIPS_AFTER);
 
-		ActivateStarShip (CHMMR_SHIP, SET_ALLIED);
-	}
+static void
+ProvokeAboutYehat (RESPONSE_REF R)
+{	
+	(void) R; // satisfy compiler
+	NPCPhrase (CHMMR_ARE_AWESOME);
+	DISABLE_PHRASE (yehat_not_impressed);	
 
-	if (PHRASE_ENABLED (what_now))
-		Response (what_now, ImproveBomb);
-	else if (PHRASE_ENABLED (wont_hurt_my_ship))
-		Response (wont_hurt_my_ship, ImproveBomb);
-	else if (PHRASE_ENABLED (bummer_about_my_ship))
-		Response (bummer_about_my_ship, ImproveBomb);
-	if (ActivateStarShip (CHMMR_SHIP, CHECK_ALLIANCE) != GOOD_GUY)
-		Response (other_assistance, ImproveBomb);
-	Response (proceed, ExitConversation);
+	Response (chenjesu_guiding_light, AskMenu);
+	Response (pterodactyls_know_nothing, AskMenu);
 }
 
 static void
-ChmmrFree (RESPONSE_REF R)
-{
-	if (R == 0
-			|| PLAYER_SAID (R, i_am_captain0)
-			|| PLAYER_SAID (R, i_am_savior)
-			|| PLAYER_SAID (R, i_am_silly))
-	{
-		NPCPhrase (WHY_HAVE_YOU_FREED_US);
-		AlienTalkSegue ((COUNT)~0);
-		SET_GAME_STATE (CHMMR_EMERGING, 0);
-
-		Response (serious_1, ChmmrFree);
-		Response (serious_2, ChmmrFree);
-		Response (silly, ChmmrFree);
-	}
-	else
-	{
-		NPCPhrase (WILL_HELP_ANALYZE_LOGS);
-
-		if (GET_GAME_STATE (AWARE_OF_SAMATRA))
-			NPCPhrase (YOU_KNOW_SAMATRA);
+AskMenu (RESPONSE_REF R)
+{	
+	static BYTE distressInfoState	= 0;
+	static BYTE chmmrLandInfoState	= 0;
+	
+	/* Alien speech */
+	if (PLAYER_SAID (R, better_starship))
+	{
+		NPCPhrase (NO_BETTER_STARSHIP);
+		DISABLE_PHRASE (better_starship);
+	}
+	
+	else if (PLAYER_SAID (R, how_you_heard_call))
+	{
+		NPCPhrase (HEARD_CALL_SO);
+		DISABLE_PHRASE (how_you_heard_call);
+		distressInfoState++;
+	}
+	
+	else if (PLAYER_SAID (R, where_distress_site))
+	{
+		// Can give location at procyon
+		if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) == (BYTE)~0)
+		{
+			NPCPhrase (GIVE_DISTRESS_LOCATION);
+			DISABLE_PHRASE (where_distress_site);
+			SET_GAME_STATE(TRIANGULATION_SPHERES_CHMMR, 1);
+			distressInfoState++;
+		}
+		// Ship groups don't know the location
 		else
 		{
-			NPCPhrase (DONT_KNOW_ABOUT_SAMATRA);
-
-			SET_GAME_STATE (AWARE_OF_SAMATRA, 1);
+			NPCPhrase (DONT_KNOW_LOCATION);
+			DISABLE_PHRASE (where_distress_site);
 		}
-
-		if (GET_GAME_STATE (TALKING_PET_ON_SHIP))
-			NPCPhrase (HAVE_TALKING_PET);
-		else
-			NPCPhrase (NEED_DISTRACTION);
-
-		if (GET_GAME_STATE (UTWIG_BOMB_ON_SHIP))
-			NPCPhrase (HAVE_BOMB);
-		else
-			NPCPhrase (NEED_WEAPON);
-
-		if (!GET_GAME_STATE (TALKING_PET_ON_SHIP)
-				|| !GET_GAME_STATE (UTWIG_BOMB_ON_SHIP))
-			NotReady ((RESPONSE_REF)0);
-		else
-			ImproveBomb ((RESPONSE_REF)0);
 	}
-}
-
-static void ChmmrShielded (RESPONSE_REF R);
-
-static void
-ChmmrAdvice (RESPONSE_REF R)
-{
-	BYTE AdviceLeft;
-
-	if (PLAYER_SAID (R, need_advice))
-		NPCPhrase (WHAT_ADVICE);
-	else if (PLAYER_SAID (R, how_defeat_urquan))
+	
+	// Answer about landing on alliance home planets.
+	else if (PLAYER_SAID (R, lame_landing_question_1))
 	{
-		NPCPhrase (DEFEAT_LIKE_SO);
-
-		SET_GAME_STATE (CHMMR_BOMB_STATE, 1);
-		DISABLE_PHRASE (how_defeat_urquan);
+		NPCPhrase (LAME_LANDING_ANSWER_1);
+		++chmmrLandInfoState;
 	}
-	else if (PLAYER_SAID (R, what_about_tpet))
+	else if (PLAYER_SAID (R, lame_landing_question_2))
 	{
-		NPCPhrase (SCARY_BUT_USEFUL);
-
-		DISABLE_PHRASE (what_about_tpet);
+		NPCPhrase (LAME_LANDING_ANSWER_2);
+		++chmmrLandInfoState;
 	}
-	else if (PLAYER_SAID (R, what_about_bomb))
+	else if (PLAYER_SAID (R, lame_landing_question_3))
 	{
-		NPCPhrase (ABOUT_BOMB);
-
-		DISABLE_PHRASE (what_about_bomb);
+		NPCPhrase (LAME_LANDING_ANSWER_3);
+		DISABLE_PHRASE(lame_landing_question_1);
+                SetGameStateByName("TZZRAK_TZON_PICS", 1);
+		chmmrLandInfoState = 0;
 	}
-	else if (PLAYER_SAID (R, what_about_sun_device))
+	
+	else if (PLAYER_SAID (R, where_urquan))
 	{
-		NPCPhrase (ABOUT_SUN_DEVICE);
-
-		DISABLE_PHRASE (what_about_sun_device);
+		NPCPhrase (URQUAN_ARE);
+		DISABLE_PHRASE (where_urquan);
 	}
-	else if (PLAYER_SAID (R, what_about_samatra))
-	{
-		NPCPhrase (ABOUT_SAMATRA);
-
-		DISABLE_PHRASE (what_about_samatra);
-	}
-
-	AdviceLeft = 0;
-	if (PHRASE_ENABLED (how_defeat_urquan))
+	else if (PLAYER_SAID (R, why_kohrah_still_here))
 	{
-		Response (how_defeat_urquan, ChmmrAdvice);
-		AdviceLeft = TRUE;
+		NPCPhrase (KOHRAH_HERE_BECAUSE);
 	}
-	if (PHRASE_ENABLED (what_about_tpet) && GET_GAME_STATE (TALKING_PET_ON_SHIP))
+	else if (PLAYER_SAID (R, chenjesu_guiding_light))
 	{
-		Response (what_about_tpet, ChmmrAdvice);
-		AdviceLeft = TRUE;
+		NPCPhrase (CHMMR_PROTECT);
 	}
-	if (PHRASE_ENABLED (what_about_bomb) && GET_GAME_STATE (UTWIG_BOMB_ON_SHIP))
+	else if (PLAYER_SAID (R, pterodactyls_know_nothing))
 	{
-		Response (what_about_bomb, ChmmrAdvice);
-		AdviceLeft = TRUE;
+		NPCPhrase (SPEAK_TO_YEHAT);
 	}
-	if (PHRASE_ENABLED (what_about_sun_device) && GET_GAME_STATE (SUN_DEVICE_ON_SHIP))
+	else if (PLAYER_SAID (R, can_we_ask))
 	{
-		Response (what_about_sun_device, ChmmrAdvice);
-		AdviceLeft = TRUE;
+		NPCPhrase (YOU_CAN_ASK);
 	}
-	if (PHRASE_ENABLED (what_about_samatra) && GET_GAME_STATE (AWARE_OF_SAMATRA))
+
+	/* Human speech options */
+	
+	// Ask about getting a new ship only at the starbase
+	if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) == (BYTE)~0 && PHRASE_ENABLED (better_starship))
 	{
-		Response (what_about_samatra, ChmmrAdvice);
-		AdviceLeft = TRUE;
+		Response (better_starship, AskMenu);
 	}
-	Response (enough_advice, ChmmrShielded);
-
-	if (!AdviceLeft)
-		DISABLE_PHRASE (need_advice);
-}
 
-static void
-ChmmrShielded (RESPONSE_REF R)
-{
-	if (PLAYER_SAID (R, find_out_whats_up))
+	if (distressInfoState == 0 && PHRASE_ENABLED (how_you_heard_call))
 	{
-		NPCPhrase (HYBRID_PROCESS);
-
-		DISABLE_PHRASE (find_out_whats_up);
+		Response (how_you_heard_call, AskMenu);
 	}
-	else if (PLAYER_SAID (R, need_help))
+	
+	if (distressInfoState == 1 && PHRASE_ENABLED (where_distress_site))
 	{
-		NPCPhrase (CANT_HELP);
-
-		SET_GAME_STATE (CHMMR_STACK, 1);
+		Response (where_distress_site, AskMenu);
 	}
-	else if (PLAYER_SAID (R, why_no_help))
+	
+    if (PHRASE_ENABLED (where_urquan))
 	{
-		NPCPhrase (LONG_TIME);
-
-		SET_GAME_STATE (CHMMR_STACK, 2);
+		Response (where_urquan, AskMenu);
 	}
-	else if (PLAYER_SAID (R, what_if_more_energy))
+	
+    if (PHRASE_ENABLED (where_kohrah))
 	{
-		NPCPhrase (DANGER_TO_US);
-
-		SET_GAME_STATE (CHMMR_STACK, 3);
+		Response (where_kohrah, WhereKohrah);
 	}
-	else if (PLAYER_SAID (R, enough_advice))
-		NPCPhrase (OK_ENOUGH_ADVICE);
 
-	switch (GET_GAME_STATE (CHMMR_STACK))
-	{
-		case 0:
-			Response (need_help, ChmmrShielded);
-			break;
-		case 1:
-			Response (why_no_help, ChmmrShielded);
-			break;
-		case 2:
-			Response (what_if_more_energy, ChmmrShielded);
-			break;
-	}
-	if (PHRASE_ENABLED (find_out_whats_up))
-		Response (find_out_whats_up, ChmmrShielded);
-	if (PHRASE_ENABLED (need_advice))
+	if (GET_GAME_STATE (YEHAT_MET) == 1
+		&& PHRASE_ENABLED (yehat_not_impressed))
 	{
-		Response (need_advice, ChmmrAdvice);
+		Response (yehat_not_impressed, ProvokeAboutYehat);
 	}
-	Response (bye_shielded, ExitConversation);
+	
+	// Ask about landing on alliance home planets only at the starbase
+	if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) == (BYTE)~0 && chmmrLandInfoState == 0 && PHRASE_ENABLED (lame_landing_question_1))
+		Response (lame_landing_question_1, AskMenu);
+	else if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) == (BYTE)~0 && chmmrLandInfoState == 1)
+		Response (lame_landing_question_2, AskMenu);
+	else if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) == (BYTE)~0 && chmmrLandInfoState == 2)
+		Response (lame_landing_question_3, AskMenu);
+
+	Response (on_our_way, ExitConversation);
 }
 
 static void
-AfterBomb (RESPONSE_REF R)
-{
-	if (PLAYER_SAID (R, whats_up_after_bomb))
+HaveYouFoundArtefact (RESPONSE_REF R)
+{	
+	if (PLAYER_SAID (R, yes_but_dont_have))
 	{
-		if (GET_GAME_STATE (CHMMR_STACK))
-			NPCPhrase (GENERAL_INFO_AFTER_BOMB_2);
-		else
-		{
-			NPCPhrase (GENERAL_INFO_AFTER_BOMB_1);
-
-			SET_GAME_STATE (CHMMR_STACK, 1);
-		}
-
-		DISABLE_PHRASE (whats_up_after_bomb);
+		NPCPhrase (BRING_HERE);
 	}
-	else if (PLAYER_SAID (R, what_do_after_bomb))
+	else if (PLAYER_SAID (R, not_yet) && GET_GAME_STATE(TRIANGULATION_SPHERES_CHMMR))
 	{
-		NPCPhrase (DO_AFTER_BOMB);
-
-		DISABLE_PHRASE (what_do_after_bomb);
+		NPCPhrase (SEARCH_FOR_IT);
+	}
+	else
+	{
+		SET_GAME_STATE(TRIANGULATION_SPHERES_CHMMR, 1);
+		NPCPhrase (GIVE_DISTRESS_LOCATION);
 	}
 
-	if (PHRASE_ENABLED (whats_up_after_bomb))
-		Response (whats_up_after_bomb, AfterBomb);
-	if (PHRASE_ENABLED (what_do_after_bomb))
-		Response (what_do_after_bomb, AfterBomb);
-	Response (bye_after_bomb, ExitConversation);
+	Response (can_we_ask, AskMenu);
+	Response (on_our_way, ExitConversation);
 }
 
 static void
 Intro (void)
 {
 	BYTE NumVisits;
-
-	if (GET_GAME_STATE (CHMMR_BOMB_STATE) >= 2)
-	{
-		NumVisits = GET_GAME_STATE (CHMMR_HOME_VISITS);
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (HELLO_AFTER_BOMB_1);
-				break;
-			case 1:
-				NPCPhrase (HELLO_AFTER_BOMB_2);
-				--NumVisits;
-				break;
+	
+	// If on home planet
+	if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) == (BYTE)~0)
+	{
+		if (GET_GAME_STATE (CHMMR_MET) == 0)
+		{
+			SET_GAME_STATE (CHMMR_MET, 1);
+			NPCPhrase (CHMMR_GREETING_HOME_1);
+	
+			AskMenu ((RESPONSE_REF)0);
 		}
-		SET_GAME_STATE (CHMMR_HOME_VISITS, NumVisits);
-
-		AfterBomb ((RESPONSE_REF)0);
-	}
-	else if (GET_GAME_STATE (CHMMR_UNLEASHED))
-	{
-		if (!GET_GAME_STATE (TALKING_PET_ON_SHIP)
-				|| !GET_GAME_STATE (UTWIG_BOMB_ON_SHIP))
-			NotReady ((RESPONSE_REF)0);
-		else
+		else 
 		{
-			NPCPhrase (YOU_ARE_READY);
-
-			ImproveBomb ((RESPONSE_REF)0);
+			NPCPhrase (CHMMR_GREETING_HOME_2);
+		
+			Response (yes_but_dont_have, HaveYouFoundArtefact);
+			Response (not_yet, HaveYouFoundArtefact);
+			Response (on_our_way, ExitConversation);
 		}
 	}
+	// Meet a ship group
 	else
 	{
-		NumVisits = GET_GAME_STATE (CHMMR_HOME_VISITS);
-		if (!GET_GAME_STATE (CHMMR_EMERGING))
-		{
-			CommData.AlienColorMap = SetAbsColorMapIndex (
-					CommData.AlienColorMap, 1
-					);
-			switch (NumVisits++)
-			{
-				case 0:
-					NPCPhrase (WHY_YOU_HERE_1);
-					break;
-				case 1:
-					NPCPhrase (WHY_YOU_HERE_2);
-					break;
-				case 2:
-					NPCPhrase (WHY_YOU_HERE_3);
-					break;
-				case 3:
-					NPCPhrase (WHY_YOU_HERE_4);
-					--NumVisits;
-					break;
-			}
-
-			ChmmrShielded ((RESPONSE_REF)0);
-		}
-		else
+		NumVisits = GET_GAME_STATE (CHMMR_SPACE_VISITS);
+		switch (NumVisits++)
 		{
-			SetCommIntroMode (CIM_FADE_IN_SCREEN, ONE_SECOND * 2);
-			NPCPhrase (WE_ARE_FREE);
-
-			if (NumVisits)
-			{
-				ChmmrFree ((RESPONSE_REF)0);
+			case 0:
+				NPCPhrase (CHMMR_GREETING_SPACE_1);
+				break;
+			case 1:
+				NPCPhrase (CHMMR_GREETING_SPACE_2);
+				break;
+			case 2:
+				NPCPhrase (CHMMR_GREETING_SPACE_3);
+				break;
+			case 3:
+				NPCPhrase (CHMMR_GREETING_SPACE_4);
 				NumVisits = 0;
-			}
-			else
-			{
-				NPCPhrase (WHO_ARE_YOU);
-
-				construct_response (shared_phrase_buf,
-						i_am_captain0,
-						GLOBAL_SIS (CommanderName),
-						i_am_captain1,
-						GLOBAL_SIS (ShipName),
-						i_am_captain2,
-						(UNICODE*)NULL);
-				DoResponsePhrase (i_am_captain0, ChmmrFree, shared_phrase_buf);
-				Response (i_am_savior, ChmmrFree);
-				Response (i_am_silly, ChmmrFree);
-			}
-
-			SET_GAME_STATE (CHMMR_UNLEASHED, 1);
+				break;
 		}
-		SET_GAME_STATE (CHMMR_HOME_VISITS, NumVisits);
+		SET_GAME_STATE (CHMMR_SPACE_VISITS, NumVisits);
+		
+		AskMenu ((RESPONSE_REF)0);
 	}
+	
 }
 
 static COUNT
diff -ruNp src.orig/uqm/comm/chmmr/strings.h src/uqm/comm/chmmr/strings.h
--- src.orig/uqm/comm/chmmr/strings.h	2017-11-01 15:30:23 -0700
+++ src/uqm/comm/chmmr/strings.h	2017-11-01 15:31:00 -0700
@@ -22,84 +22,54 @@
 enum
 {
 	NULL_PHRASE,
-	WHY_YOU_HERE_1,
-	WHY_YOU_HERE_2,
-	WHY_YOU_HERE_3,
-	WHY_YOU_HERE_4,
-	find_out_whats_up,
-	HYBRID_PROCESS,
-	need_help,
-	CANT_HELP,
-	why_no_help,
-	LONG_TIME,
-	what_if_more_energy,
-	DANGER_TO_US,
-	need_advice,
-	WHAT_ADVICE,
-	how_defeat_urquan,
-	DEFEAT_LIKE_SO,
-	what_about_tpet,
-	SCARY_BUT_USEFUL,
-	what_about_bomb,
-	ABOUT_BOMB,
-	what_about_sun_device,
-	ABOUT_SUN_DEVICE,
-	what_about_samatra,
-	ABOUT_SAMATRA,
-	enough_advice,
-	OK_ENOUGH_ADVICE,
-	bye_shielded,
-	GOODBYE_SHIELDED,
-	WE_ARE_FREE,
-	WHO_ARE_YOU,
-	i_am_captain0,
-	i_am_captain1,
-	i_am_captain2,
-	i_am_savior,
-	i_am_silly,
-	WHY_HAVE_YOU_FREED_US,
-	serious_1,
-	serious_2,
-	silly,
-	WILL_HELP_ANALYZE_LOGS,
-	YOU_KNOW_SAMATRA,
-	DONT_KNOW_ABOUT_SAMATRA,
-	NEED_DISTRACTION,
-	HAVE_TALKING_PET,
-	NEED_WEAPON,
-	HAVE_BOMB,
-	RETURN_WHEN_READY,
-	YOU_ARE_READY,
-	further_assistance,
-	NO_FURTHER_ASSISTANCE,
-	tech_help,
-	USE_OUR_SHIPS_BEFORE,
-	where_weapon,
-	PRECURSOR_WEAPON,
-	where_distraction,
-	PSYCHIC_WEAPONRY,
-	what_now,
-	WE_WILL_IMPROVE_BOMB,
-	MODIFY_VESSEL,
-	wont_hurt_my_ship,
-	WILL_DESTROY_IT,
-	bummer_about_my_ship,
-	DEAD_SILENCE,
-	other_assistance,
-	USE_OUR_SHIPS_AFTER,
-	proceed,
-	TAKE_2_WEEKS,
-	HELLO_AFTER_BOMB_1,
-	HELLO_AFTER_BOMB_2,
-	whats_up_after_bomb,
-	GENERAL_INFO_AFTER_BOMB_1,
-	GENERAL_INFO_AFTER_BOMB_2,
-	what_do_after_bomb,
-	DO_AFTER_BOMB,
-	bye_after_bomb,
-	GOODBYE_AFTER_BOMB,
-	bye,
-	GOODBYE,
+	CHMMR_GREETING_HOME_1,
+	CHMMR_GREETING_HOME_2,
+	CHMMR_GREETING_SPACE_1,
+	CHMMR_GREETING_SPACE_2,
+	CHMMR_GREETING_SPACE_3,
+	CHMMR_GREETING_SPACE_4,
+	yes_but_dont_have,
+	BRING_HERE,
+	not_yet,
+	SEARCH_FOR_IT,
+	can_we_ask,
+	YOU_CAN_ASK,
+	how_you_heard_call,
+	HEARD_CALL_SO,
+	where_distress_site,
+	DONT_KNOW_LOCATION,
+	GIVE_DISTRESS_LOCATION,
+	better_starship,
+	NO_BETTER_STARSHIP,
+	lame_landing_question_1,
+	LAME_LANDING_ANSWER_1,
+	lame_landing_question_2,
+	LAME_LANDING_ANSWER_2,
+	lame_landing_question_3,
+	LAME_LANDING_ANSWER_3,
+	where_urquan,
+	URQUAN_ARE,
+	where_kohrah,
+	KOHRAH_ARE,
+	why_kohrah_still_here,
+	KOHRAH_HERE_BECAUSE,
+	yehat_not_impressed,
+	CHMMR_ARE_AWESOME,
+	pterodactyls_know_nothing,
+	SPEAK_TO_YEHAT,
+	chenjesu_guiding_light,
+	CHMMR_PROTECT,
+	on_our_way,
+	GOODBYE_HUMAN1,
+	im_not_comfortable,
+	CHMMR_LECTURE,
+	you_know_best,
+	no_race_evil,
+	CONSEQUENCE,
+	FURTHER_QUESTIONS,
+	no_more_questions,
+
+	
 };
 
 #endif /* _STRINGS_H */
diff -ruNp src.orig/uqm/comm/comandr/comandr.c src/uqm/comm/comandr/comandr.c
--- src.orig/uqm/comm/comandr/comandr.c	2017-11-01 15:30:23 -0700
+++ src/uqm/comm/comandr/comandr.c	2017-11-01 15:31:00 -0700
@@ -16,10 +16,12 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: Removed the references to ANIM_DISABLED from here since that define is removed...
+//			 ... We're not using this file anyway, but keeping it just to be sure.
+
 #include "../commall.h"
 #include "resinst.h"
 #include "strings.h"
-
 #include "uqm/setup.h"
 #include "uqm/sis.h"
 		// for DeltaSISGauges(), DrawLanders()
@@ -27,6 +29,7 @@
 
 static LOCDATA commander_desc =
 {
+	COMMANDER_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -43,7 +46,7 @@ static LOCDATA commander_desc =
 	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	COMMANDER_CONVERSATION_PHRASES, /* PlayerPhrases */
-	3, /* NumAnimations */
+	2, /* NumAnimations */
 	{ /* AlienAmbientArray (ambient animations) */
 		{ /* Blink */
 			1, /* StartIndex */
@@ -61,14 +64,6 @@ static LOCDATA commander_desc =
 			ONE_SECOND * 2, 0, /* RestartRate */
 			0, /* BlockMask */
 		},
-		{
-			1, /* StartIndex */
-			3, /* NumFrames */
-			RANDOM_ANIM | COLORXFORM_ANIM,/* AnimFlags */
-			0, ONE_SECOND / 30, /* FrameRate */
-			0, ONE_SECOND / 15, /* RestartRate */
-			0, /* BlockMask */
-		},
 	},
 	{ /* AlienTransitionDesc */
 		0, /* StartIndex */
@@ -91,6 +86,11 @@ static LOCDATA commander_desc =
 	NULL, NULL, NULL,
 	NULL,
 	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
 };
 
 static void
@@ -594,7 +594,7 @@ GiveRadios (RESPONSE_REF R)
 		AlienTalkSegue (1);
 
 		LockMutex (GraphicsLock);
-		CommData.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
+		//CommData.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED; // JMS
 		UnlockMutex (GraphicsLock);
 
 		XFormColorMap (GetColorMapAddress (
@@ -621,6 +621,10 @@ GiveRadios (RESPONSE_REF R)
 static void
 Intro (void)
 {
+	SET_GAME_STATE (STARBASE_AVAILABLE, 1);
+	NPCPhrase (STARBASE_WILL_BE_READY);
+	return;
+
 	if (GET_GAME_STATE (PROBE_ILWRATH_ENCOUNTER))
 	{
 		NPCPhrase (VERY_IMPRESSIVE);
@@ -697,21 +701,21 @@ init_commander_comm ()
 
 	if (GET_GAME_STATE (RADIOACTIVES_PROVIDED))
 	{
-		commander_desc.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
+		//commander_desc.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED; // JMS
 		// regular track -- let's make sure
 		commander_desc.AlienSongFlags &= ~LDASF_USE_ALTERNATE;
 	}
 	else
 	{	
-		commander_desc.AlienAmbientArray[2].AnimFlags &= ~ANIM_DISABLED;
+		//commander_desc.AlienAmbientArray[2].AnimFlags &= ~ANIM_DISABLED; // JMS
 		// use alternate 'low-power' track if available
 		commander_desc.AlienAltSongRes = COMMANDER_LOWPOW_MUSIC;
 		commander_desc.AlienSongFlags |= LDASF_USE_ALTERNATE;
 	}
 
-	commander_desc.AlienTextWidth = 143;
-	commander_desc.AlienTextBaseline.x = 164;
-	commander_desc.AlienTextBaseline.y = 20;
+	commander_desc.AlienTextWidth = RES_SIS_SCALE(143); // JMS_GFX
+	commander_desc.AlienTextBaseline.x = RES_SIS_SCALE(164); // JMS_GFX
+	commander_desc.AlienTextBaseline.y = RES_SIS_SCALE(20); // JMS_GFX
 
 	SET_GAME_STATE (BATTLE_SEGUE, 0);
 	retval = &commander_desc;
diff -ruNp src.orig/uqm/comm/druuge/druugec.c src/uqm/comm/druuge/druugec.c
--- src.orig/uqm/comm/druuge/druugec.c	2017-11-01 15:30:23 -0700
+++ src/uqm/comm/druuge/druugec.c	2017-11-01 15:31:00 -0700
@@ -28,6 +28,7 @@
 
 static LOCDATA druuge_desc =
 {
+	DRUUGE_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -156,6 +157,11 @@ static LOCDATA druuge_desc =
 	NULL, NULL, NULL,
 	NULL,
 	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
 };
 
 static COUNT SlaveryCount = 0;
@@ -476,7 +482,7 @@ DoTransaction (RESPONSE_REF R)
 			UnlockMutex (GraphicsLock);
 
 			NPCPhrase (FUEL0);
-			NPCNumber (f, NULL);
+			NPCPhrase (-(int)f);
 			NPCPhrase (FUEL1);
 
 			if (f >= 250)
@@ -919,7 +925,7 @@ init_druuge_comm (void)
 	druuge_desc.uninit_encounter_func = uninit_druuge;
 
 	druuge_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
-	druuge_desc.AlienTextBaseline.y = 70;
+	druuge_desc.AlienTextBaseline.y = RES_SIS_SCALE(70);
 	druuge_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
 
 	if ((GET_GAME_STATE (DRUUGE_MANNER) == 0
diff -ruNp src.orig/uqm/comm/human/Makeinfo src/uqm/comm/human/Makeinfo
--- src.orig/uqm/comm/human/Makeinfo	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/human/Makeinfo	2017-11-01 15:31:00 -0700
@@ -0,0 +1 @@
+uqm_CFILES="humanc.c"
diff -ruNp src.orig/uqm/comm/human/human.res src/uqm/comm/human/human.res
--- src.orig/uqm/comm/human/human.res	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/human/human.res	2017-11-01 15:31:00 -0700
@@ -0,0 +1,10 @@
+INCLUDE	../../star3do.typ
+
+PATH	comm/human
+
+PACKAGE	HUMAN_PACKAGE		supox.con
+	GFXRES			HUMAN_PMAP_ANIM			supox.ani
+	FONTRES			HUMAN_FONT			supox.fon
+	MUSICRES		HUMAN_MUSIC			supox.mod
+	STRTAB			HUMAN_CONVERSATION_PHRASES	supox.txt
+
diff -ruNp src.orig/uqm/comm/human/humanc.c src/uqm/comm/human/humanc.c
--- src.orig/uqm/comm/human/humanc.c	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/human/humanc.c	2017-11-01 15:31:00 -0700
@@ -0,0 +1,610 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+// JMS 2010:	-New dialogue
+//				-Mechanism that allows for male/female captains in comm screens (CURRENTLY DISABLED, ALWAYS MALE)
+
+#include "../commall.h"
+#include "resinst.h"
+#include "strings.h"
+#include "libs/mathlib.h"
+
+#include "uqm/build.h"
+#include "uqm/encount.h"
+// BW: for EncounterGroup, no longer included in commall.h
+
+#include "libs/log.h"
+
+
+static LOCDATA human_desc_1x =
+{
+	HUMAN_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	HUMAN_PMAP_ANIM, /* AlienFrame */
+	HUMAN_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_TOP, /* AlienTextValign */
+	HUMAN_COLOR_MAP, /* AlienColorMap */
+	HUMAN_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	HUMAN_CONVERSATION_PHRASES, /* PlayerPhrases */
+	10, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{ /* Blink */
+			1, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			ONE_SECOND, (ONE_SECOND / 10) * 22, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Captain's "Picard Tug" */
+			11, /* StartIndex */
+			2, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 6, 0, /* FrameRate */
+			ONE_SECOND * 4, ONE_SECOND * 5, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Big Ceiling Monitor */
+			13, /* StartIndex */
+			125, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			ONE_SECOND * 1, ONE_SECOND * 4, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Small Monitor - left */
+			138, /* StartIndex */
+			94, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			ONE_SECOND * 1, ONE_SECOND * 2, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Small Monitor - Right */
+			232, /* StartIndex */
+			26, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			ONE_SECOND * 1, ONE_SECOND * 1, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Green Pulsing Stuff */
+			258, /* StartIndex */
+			18, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			0, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Back Wall Computer */
+			276, /* StartIndex */
+			12, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			0, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Guy in the Back */
+			288, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			(ONE_SECOND / 10) * 2, (ONE_SECOND / 10) * 13, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Woman's Left Arm */
+			291, /* StartIndex */
+			3, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			ONE_SECOND / 12, (ONE_SECOND / 12) * 15, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Woman's Right Arm */
+			294, /* StartIndex */
+			3, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			ONE_SECOND / 12, (ONE_SECOND / 12) * 15, /* RestartRate */
+			0, /* BlockMask */
+		},
+	},
+	{ /* AlienTransitionDesc */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		4, /* StartIndex */
+		7, /* NumFrames */
+		RANDOM_ANIM, /* AnimFlags */
+		ONE_SECOND / 12, ONE_SECOND / 15, /* FrameRate */
+		ONE_SECOND * 7 / 60, ONE_SECOND / 12, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+	0, /* NumFeatures */
+	{ /* AlienFeaturesArray (alternative features) */
+	  { /* Hair colour */
+	    0, /* StartIndex */
+	    0, /* NumFrames */
+	    {0 /* BlockMaskArray */
+	    },
+	  },
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
+};
+
+static LOCDATA human_desc_4x =
+{
+	HUMAN_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	DECKER_PMAP_ANIM, /* AlienFrame */
+	HUMAN_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_TOP, /* AlienTextValign */
+	HUMAN_COLOR_MAP, /* AlienColorMap */
+	HUMAN_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	HUMAN_CONVERSATION_PHRASES, /* PlayerPhrases */
+	8, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{ /* Blink */
+			1, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			ONE_SECOND, (ONE_SECOND / 10) * 22, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Captain's "Picard Tug" */
+			11, /* StartIndex */
+			4, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 6, 0, /* FrameRate */
+			ONE_SECOND * 4, ONE_SECOND * 5, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Big Ceiling Monitor */
+			15, /* StartIndex */
+			108, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			ONE_SECOND * 1, ONE_SECOND * 4, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Small Monitor - left */
+			123, /* StartIndex */
+			93, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			ONE_SECOND * 1, ONE_SECOND * 2, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Small Monitor - Right */
+			216, /* StartIndex */
+			26, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			ONE_SECOND * 1, ONE_SECOND * 1, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Green Pulsing Stuff and girl */
+			242, /* StartIndex */
+			27, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			ONE_SECOND / 12, (ONE_SECOND / 12) * 15, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Back Wall Computer */
+			269, /* StartIndex */
+			11, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			0, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Guy in the Back */
+			280, /* StartIndex */
+			5, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			(ONE_SECOND / 10) * 2, (ONE_SECOND / 10) * 13, /* RestartRate */
+			0, /* BlockMask */
+		},
+	},
+	{ /* AlienTransitionDesc */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		4, /* StartIndex */
+		7, /* NumFrames */
+		RANDOM_ANIM, /* AnimFlags */
+		ONE_SECOND / 12, ONE_SECOND / 15, /* FrameRate */
+		ONE_SECOND * 7 / 60, ONE_SECOND / 12, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+	0, /* NumFeatures */
+	{ /* AlienFeaturesArray (alternative features) */
+	  { /* Hair colour */
+	    0, /* StartIndex */
+	    0, /* NumFrames */
+	    {0 /* BlockMaskArray */
+	    },
+	  },
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
+};
+
+static LOCDATA human_desc2 =
+{
+	HUMAN_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	HUMAN_PMAP_ANIM2, /* AlienFrame */
+	HUMAN_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_TOP, /* AlienTextValign */
+	HUMAN_COLOR_MAP2, /* AlienColorMap */
+	HUMAN_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	HUMAN_CONVERSATION_PHRASES, /* PlayerPhrases */
+	2, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{ /* Blink */
+			1, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, 0, /* FrameRate */
+			0, ONE_SECOND * 8, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Running light */
+			10, /* StartIndex */
+			30, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 40, 0, /* FrameRate */
+			ONE_SECOND * 2, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+	},
+	{ /* AlienTransitionDesc */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		4, /* StartIndex */
+		6, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 10, ONE_SECOND / 15, /* FrameRate */
+		ONE_SECOND * 7 / 60, ONE_SECOND / 12, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
+};
+
+static void
+NukesConversation (RESPONSE_REF R);
+
+static void
+ExitConversation (RESPONSE_REF R)
+{
+	BYTE NumVisits;
+	(void) R; // satisfy compiler
+	
+	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	
+	NumVisits= GET_GAME_STATE (HUMAN_VISITS);
+	
+	switch (NumVisits++)
+	{
+		case 0:
+			NPCPhrase (GOODBYE_CAPTAIN_1);
+			break;
+		case 1:
+			NPCPhrase (GOODBYE_CAPTAIN_2);
+			break;
+		case 2:
+			NPCPhrase (GOODBYE_CAPTAIN_3);
+			--NumVisits;
+			--NumVisits;
+			break;
+	}
+	
+	SET_GAME_STATE (HUMAN_VISITS, NumVisits);
+}
+
+static void
+HumanConversationMain (RESPONSE_REF R)
+{
+	BYTE NumVisits;
+	
+	if (PLAYER_SAID (R, ask_news))
+	{
+		NumVisits = GET_GAME_STATE (HUMAN_NEWS);
+		switch (NumVisits++)
+		{
+			case 0:
+				NPCPhrase (NEWS_1);
+				break;
+			case 1:
+				NPCPhrase (NEWS_2);
+				break;
+			case 2:
+				NPCPhrase (NEWS_3);
+				break;
+			case 3:
+				NPCPhrase (NEWS_4);
+				break;
+			case 4:
+				NPCPhrase (NEWS_5);
+				NumVisits--;
+				break;
+		}
+		
+		SET_GAME_STATE (HUMAN_NEWS, NumVisits);
+		DISABLE_PHRASE (ask_news);
+	}
+	
+	if (PLAYER_SAID (R, short_on_fuel))
+	{
+		NumVisits = GET_GAME_STATE (HUMAN_FUEL_INFO);
+		switch (NumVisits++)
+		{
+			case 0:
+				NPCPhrase (FUEL_1);
+				break;
+			case 1:
+				NPCPhrase (FUEL_2);
+				break;
+			case 2:
+				NPCPhrase (FUEL_3);
+				NumVisits=0;
+				break;
+		}
+		
+		SET_GAME_STATE (HUMAN_FUEL_INFO, NumVisits);
+		DISABLE_PHRASE (short_on_fuel);
+	}
+	
+	if (PLAYER_SAID (R, serious) || PLAYER_SAID (R, joking))
+	{
+		if (PLAYER_SAID (R, serious))
+			NPCPhrase (NUKES_SERIOUS);
+		if (PLAYER_SAID (R, joking))
+			NPCPhrase (NUKES_JOKING);
+		
+		SET_GAME_STATE (HUMAN_NUKES_DONE, 1);
+	}
+	
+	if (PHRASE_ENABLED (ask_news))
+	{
+		Response (ask_news, HumanConversationMain);
+	}
+	
+	if (PHRASE_ENABLED (short_on_fuel))
+	{
+		Response (short_on_fuel, HumanConversationMain);
+	}
+	
+	if (PHRASE_ENABLED (spare_nukes) && !GET_GAME_STATE (HUMAN_NUKES_DONE))
+	{
+		Response (spare_nukes, NukesConversation);
+	}
+	
+	Response (keep_up_goodbye, ExitConversation);
+}
+
+static void
+NukesConversation (RESPONSE_REF R)
+{
+	if (PLAYER_SAID (R, spare_nukes))
+	{
+		NPCPhrase (NUKES_QUESTION);
+		Response (serious, HumanConversationMain);
+		Response (joking, HumanConversationMain);
+		
+		DISABLE_PHRASE (spare_nukes);
+	}
+}
+
+static void
+Intro (void)
+{
+	BYTE NumVisits;
+	UNICODE *pStr, numbuf[400];
+	STRING S;
+	
+	HSHIPFRAG hStarShip;
+	void *pClip;
+	
+	NumVisits = GET_GAME_STATE (HUMAN_VISITS);
+	switch (NumVisits)
+	{
+		case 0:
+			// JMS: This tomfoolery extracts the name of the earthling ship captain from the melee ship info 
+			// and appends it to the greeting the earthling says to player. 
+			// All this shit should be put to comm.c or commglue.c some day so other races could use it as well!
+			hStarShip = GetHeadLink (&GLOBAL (npc_built_ship_q));
+			if (hStarShip)
+			{
+				SHIP_FRAGMENT *StarShipPtr;
+				STRING earthling_captains_name;
+				
+				StarShipPtr = LockShipFrag (&GLOBAL (npc_built_ship_q), hStarShip);
+				earthling_captains_name = SetAbsStringTableIndex (StarShipPtr->race_strings, StarShipPtr->captains_name_index);
+				UnlockShipFrag (&GLOBAL (npc_built_ship_q), hStarShip);
+				S = SetAbsStringTableIndex (CommData.ConversationPhrases, (SPACE_HELLO_1a - 1));
+				strcpy (numbuf, (UNICODE *)GetStringAddress (S));
+				strcat (numbuf, (UNICODE *)GetStringAddress (earthling_captains_name));
+				S = SetAbsStringTableIndex (CommData.ConversationPhrases, (SPACE_HELLO_1b - 1));
+				strcat (numbuf, (UNICODE *)GetStringAddress (S));
+				pStr = numbuf;
+			}
+			// JMS: This is a failsafe: If the enemy ship group doesn't have ships for some reason (should not happen) 
+			// Then an alternate greeting string with built-in captain's name is used.
+			else
+			{
+				S = SetAbsStringTableIndex (CommData.ConversationPhrases, (SPACE_HELLO_1c-1));
+				strcpy (numbuf, (UNICODE *)GetStringAddress (S));
+				pStr = numbuf;
+				pStr = 0;
+			}
+			pClip = "noname.ogg";
+			SpliceTrack (pClip, pStr, 0, NULL);
+			break;
+		case 1:
+			NPCPhrase (SPACE_HELLO_2);
+			break;
+		case 2:
+			NPCPhrase (SPACE_HELLO_3);
+			break;
+	}
+	
+	HumanConversationMain ((RESPONSE_REF)0);
+
+}
+
+static COUNT
+uninit_human (void)
+{
+	return (0);
+}
+
+static void
+post_human_enc (void)
+{
+	// nothing defined so far
+}
+
+LOCDATA*
+init_human_comm (void)
+{
+	LOCDATA *retval;
+	COUNT captain; // BW: Choose captain
+	static LOCDATA human_desc;
+
+	switch (RESOLUTION_FACTOR)
+	{
+	case 2:
+		human_desc = human_desc_4x;
+		break;
+	case 1:
+		human_desc = human_desc_4x;
+		break;
+	case 0:
+	default:
+		human_desc = human_desc_1x;
+		break;
+	}
+	
+	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	
+	// JMS: In hyperspace just pick random captain graphics
+	// This does pose a problem if the hyperspace blip is fought, escaped from and encountered again:
+	// It might then get different random number and have captain of different gender...
+	if(LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+		captain = (TFB_Random() % 3);
+	// JMS: In Interplanetary pick graphics based on battle group index number.
+	// This way the same ship has always the same captain as long as it exists.
+	else
+		captain = (EncounterGroup % 3);
+
+	human_desc.init_encounter_func = Intro;
+	human_desc.post_encounter_func = post_human_enc;
+	human_desc.uninit_encounter_func = uninit_human;
+
+	human_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
+	human_desc.AlienTextBaseline.y = 0;
+	human_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
+
+	switch (captain)
+	{
+	case 0:
+		human_desc.AlienFrameRes = DECKER_PMAP_ANIM;
+		break;
+	case 1:
+		human_desc.AlienFrameRes = ENDER_PMAP_ANIM;
+		break;
+	case 2:
+		human_desc.AlienFrameRes = HALLECK_PMAP_ANIM;
+		break;
+	default:
+		human_desc.AlienFrameRes = HUMAN_PMAP_ANIM;
+		break;
+	}
+	
+	retval = &human_desc;
+
+	return (retval);
+}
diff -ruNp src.orig/uqm/comm/human/resinst.h src/uqm/comm/human/resinst.h
--- src.orig/uqm/comm/human/resinst.h	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/human/resinst.h	2017-11-01 15:31:00 -0700
@@ -0,0 +1,10 @@
+#define HUMAN_COLOR_MAP "comm.human.colortable"
+#define HUMAN_COLOR_MAP2 "comm.human.colortable2"
+#define HUMAN_PMAP_ANIM "comm.human.graphics"
+#define DECKER_PMAP_ANIM "comm.human.decker.graphics"
+#define ENDER_PMAP_ANIM "comm.human.ender.graphics"
+#define HALLECK_PMAP_ANIM "comm.human.halleck.graphics"
+#define HUMAN_PMAP_ANIM2 "comm.human.graphics2"
+#define HUMAN_FONT "comm.human.font"
+#define HUMAN_CONVERSATION_PHRASES "comm.human.dialogue"
+#define HUMAN_MUSIC "comm.human.music"
diff -ruNp src.orig/uqm/comm/human/strings.h src/uqm/comm/human/strings.h
--- src.orig/uqm/comm/human/strings.h	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/human/strings.h	2017-11-01 15:31:00 -0700
@@ -0,0 +1,60 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _STRINGS_H
+#define _STRINGS_H
+
+enum
+{
+	NULL_PHRASE,
+	SPACE_HELLO_1a,
+	SPACE_HELLO_1b,
+	SPACE_HELLO_1c,
+	SPACE_HELLO_2,
+	SPACE_HELLO_3,
+	ask_news,
+	keep_up_goodbye,
+	short_on_fuel,
+	spare_nukes,
+	NEWS_1,
+	NEWS_2,
+	NEWS_3,
+	NEWS_4,
+	NEWS_5,
+	FUEL_1,
+	FUEL_2,
+	FUEL_3,
+	NUKES_QUESTION,
+	serious,
+	joking,
+	NUKES_SERIOUS,
+	NUKES_JOKING,
+	GOODBYE_CAPTAIN_1,
+	GOODBYE_CAPTAIN_2,
+	GOODBYE_CAPTAIN_3,
+	NEUTRAL_SPACE_HELLO_1,
+	NEUTRAL_SPACE_HELLO_2,
+	HOSTILE_SPACE_HELLO_1,
+	HOSTILE_SPACE_HELLO_2,
+	yessiree,
+	nonono,
+	MADE_MY_DAY,
+	MADE_WOOD,
+};
+
+#endif /* _STRINGS_H */
diff -ruNp src.orig/uqm/comm/ilwrath/ilwrathc.c src/uqm/comm/ilwrath/ilwrathc.c
--- src.orig/uqm/comm/ilwrath/ilwrathc.c	2017-11-01 15:30:23 -0700
+++ src/uqm/comm/ilwrath/ilwrathc.c	2017-11-01 15:31:00 -0700
@@ -25,6 +25,7 @@
 
 static LOCDATA ilwrath_desc =
 {
+	ILWRATH_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -97,6 +98,11 @@ static LOCDATA ilwrath_desc =
 	NULL, NULL, NULL,
 	NULL,
 	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
 };
 
 static void
@@ -629,7 +635,7 @@ init_ilwrath_comm (void)
 	ilwrath_desc.uninit_encounter_func = uninit_ilwrath;
 
 	ilwrath_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
-	ilwrath_desc.AlienTextBaseline.y = 70;
+	ilwrath_desc.AlienTextBaseline.y = RES_SIS_SCALE(70);
 	ilwrath_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
 
 	if (GET_GAME_STATE (PROBE_ILWRATH_ENCOUNTER)
diff -ruNp src.orig/uqm/comm/lurg/Makeinfo src/uqm/comm/lurg/Makeinfo
--- src.orig/uqm/comm/lurg/Makeinfo	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/lurg/Makeinfo	2017-11-01 15:31:00 -0700
@@ -0,0 +1 @@
+uqm_CFILES="lurgc.c"
diff -ruNp src.orig/uqm/comm/lurg/lurgc.c src/uqm/comm/lurg/lurgc.c
--- src.orig/uqm/comm/lurg/lurgc.c	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/lurg/lurgc.c	2017-11-01 15:31:00 -0700
@@ -0,0 +1,608 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+// JMS 2010: Totally new file: Lurg communications
+
+#include "../commall.h"
+#include "resinst.h"
+#include "strings.h"
+
+#include "uqm/build.h"
+
+
+static LOCDATA lurg_desc_1x =
+{
+	LURG_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	LURG_PMAP_ANIM, /* AlienFrame */
+	LURG_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_BOTTOM, /* AlienTextValign */
+	LURG_COLOR_MAP, /* AlienColorMap */
+	LURG_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	LURG_CONVERSATION_PHRASES, /* PlayerPhrases */
+	21, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{	// 0 - Background throb animation
+			5, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM | WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 10, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1L << 8) | (1L << 9) | (1L << 10) | (1L << 13) | (1L << 14) | (1L << 17) | (1L << 18), /* BlockMask */
+		},
+		{	// 1 - Eye blink
+			8, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			ONE_SECOND * 2, ONE_SECOND, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{	// 2 - Spinchter A - Leftmost
+			11, /* StartIndex */
+			2, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{	// 3 - Spinchter B - Second left
+			13, /* StartIndex */
+			2, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1L << 17), /* BlockMask */
+		},
+		{	// 4 - Spinchter C - Middle left
+			15, /* StartIndex */
+			2, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1L << 19), /* BlockMask */
+		},
+		{	// 5 - Spinchter D - Middle right
+			17, /* StartIndex */
+			2, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1L << 13), /* BlockMask */
+		},
+		{	// 6 - Spinchter E - Second right
+			19, /* StartIndex */
+			2, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1L << 13), /* BlockMask */
+		},
+		{	// 7 - Spinchter F - Rightmost
+			21, /* StartIndex */
+			2, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{	// 8 - Intestine Left
+			23, /* StartIndex */
+			3, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, 0, /* FrameRate */
+			ONE_SECOND * 2, ONE_SECOND * 3, /* RestartRate */
+			(1L << 0) | (1L << 12) | (1L << 17), /* BlockMask */
+		},
+		{	// 9 - Intestine Middle
+			26, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			ONE_SECOND * 2, ONE_SECOND * 5, /* RestartRate */
+			(1L << 0), /* BlockMask */
+		},
+		{	// 10 - Intestine Right
+			29, /* StartIndex */
+			5, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, 0, /* FrameRate */
+			ONE_SECOND * 3, ONE_SECOND * 3, /* RestartRate */
+			(1L << 0) | (1L << 13), /* BlockMask */
+		},
+		{	// 11 - Lavalamp anim Right
+			34, /* StartIndex */
+			19, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 18, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND / 2, /* RestartRate */
+			(1L << 13), /* BlockMask */
+		},
+		{	// 12 - Lavalamp anim Left
+			53, /* StartIndex */
+			19, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 19, 0, /* FrameRate */
+			3 * ONE_SECOND / 2, ONE_SECOND / 2, /* RestartRate */
+			(1L << 17) | (1L << 8), /* BlockMask */
+		},
+		{	// 13 - Move lavalamp Right
+			72, /* StartIndex */
+			25, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			ONE_SECOND * 2, ONE_SECOND * 5, /* RestartRate */
+			(1L << 0) | (1L << 5) | (1L << 6) | (1L << 10) | (1L << 11) | (1L << 15), /* BlockMask */
+		},
+		{	// 14 - Tentacle R2
+			97, /* StartIndex */
+			6, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			3 * ONE_SECOND / 4, ONE_SECOND, /* RestartRate */
+			(1L << 0) | (1L << 15) | (1L << 16), /* BlockMask */
+		},
+		{	// 15 - Tentacle R3
+			103, /* StartIndex */
+			5, /* NumFrames */
+			YOYO_ANIM | WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 15, 0, /* FrameRate */
+			ONE_SECOND / 2, 3 * ONE_SECOND / 2, /* RestartRate */
+			(1L << 13) | (1L << 14) | (1L << 16), /* BlockMask */
+		},
+		{	// 16 - Tentacle R4
+			108, /* StartIndex */
+			4, /* NumFrames */
+			YOYO_ANIM | WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			ONE_SECOND / 2, 3 * ONE_SECOND / 2, /* RestartRate */
+			(1L << 14) | (1L << 15), /* BlockMask */
+		},
+		{	// 17 - Move lavalamp Left
+			112, /* StartIndex */
+			30, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			ONE_SECOND * 2, ONE_SECOND * 3, /* RestartRate */
+			(1L << 0) | (1L << 3) | (1L << 8) | (1L << 12) | (1L << 18) | (1L << 19), /* BlockMask */
+		},
+		{	// 18 - Tentacle L2
+			142, /* StartIndex */
+			5, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			ONE_SECOND / 2, ONE_SECOND * 2, /* RestartRate */
+			(1L << 0)  | (1L << 17) | (1L << 19) | (1L << 20), /* BlockMask */
+		},
+		{	// 19 - Tentacle L3
+			147, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM | WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			3 * ONE_SECOND / 2, ONE_SECOND, /* RestartRate */
+			(1L << 4) | (1L << 17) | (1L << 18) | (1L << 20), /* BlockMask */
+		},
+		{	// 20 - Tentacle L4
+			150, /* StartIndex */
+			4, /* NumFrames */
+			YOYO_ANIM | WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 15, 0, /* FrameRate */
+			ONE_SECOND / 2, 3 * ONE_SECOND / 2, /* RestartRate */
+			(1L << 18) | (1L << 19), /* BlockMask */
+		},
+	},
+	{ /* AlienTransitionDesc */
+		1, /* StartIndex */
+		2, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 15, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		1, /* StartIndex */
+		4, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 15, 0, /* FrameRate */
+		ONE_SECOND / 12, 0, /* RestartRate */	
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
+};
+
+
+static LOCDATA lurg_desc_4x =
+{
+	LURG_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	LURG_PMAP_ANIM, /* AlienFrame */
+	LURG_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_BOTTOM, /* AlienTextValign */
+	LURG_COLOR_MAP, /* AlienColorMap */
+	LURG_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	LURG_CONVERSATION_PHRASES, /* PlayerPhrases */
+	14, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{	// 0 - Background throb animation
+			5, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM | WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 10, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1L << 8) | (1L << 9) | (1L << 10) | (1L << 13), /* BlockMask */
+		},
+		{	// 1 - Eye blink
+			8, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			ONE_SECOND * 2, ONE_SECOND, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{	// 2 - Spinchter A - Leftmost
+			11, /* StartIndex */
+			2, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{	// 3 - Spinchter B - Second left
+			13, /* StartIndex */
+			2, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{	// 4 - Spinchter C - Middle left
+			15, /* StartIndex */
+			2, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{	// 5 - Spinchter D - Middle right
+			17, /* StartIndex */
+			2, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1L << 13), /* BlockMask */
+		},
+		{	// 6 - Spinchter E - Second right
+			19, /* StartIndex */
+			2, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1L << 13), /* BlockMask */
+		},
+		{	// 7 - Spinchter F - Rightmost
+			21, /* StartIndex */
+			2, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{	// 8 - Intestine Left
+			23, /* StartIndex */
+			3, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, 0, /* FrameRate */
+			ONE_SECOND * 2, ONE_SECOND * 3, /* RestartRate */
+			(1L << 0) | (1L << 12), /* BlockMask */
+		},
+		{	// 9 - Intestine Middle
+			26, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			ONE_SECOND * 2, ONE_SECOND * 5, /* RestartRate */
+			(1L << 0), /* BlockMask */
+		},
+		{	// 10 - Intestine Right
+			29, /* StartIndex */
+			5, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, 0, /* FrameRate */
+			ONE_SECOND * 3, ONE_SECOND * 3, /* RestartRate */
+			(1L << 0) | (1L << 13), /* BlockMask */
+		},
+		{	// 11 - Lavalamp anim Right
+			34, /* StartIndex */
+			19, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 18, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND / 2, /* RestartRate */
+			(1L << 13), /* BlockMask */
+		},
+		{	// 12 - Lavalamp anim Left
+			53, /* StartIndex */
+			19, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 19, 0, /* FrameRate */
+			3 * ONE_SECOND / 2, ONE_SECOND / 2, /* RestartRate */
+			(1L << 8), /* BlockMask */
+		},
+		{	// 13 - Move lavalamp Right
+			72, /* StartIndex */
+			25, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			ONE_SECOND * 2, ONE_SECOND * 5, /* RestartRate */
+			(1L << 0) | (1L << 5) | (1L << 6) | (1L << 10) | (1L << 11), /* BlockMask */
+		},
+	},
+	{ /* AlienTransitionDesc */
+		1, /* StartIndex */
+		2, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 15, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		1, /* StartIndex */
+		4, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 15, 0, /* FrameRate */
+		ONE_SECOND / 12, 0, /* RestartRate */	
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
+};
+
+static void
+ExitConversation (RESPONSE_REF R)
+{
+	//	BYTE NumVisits;
+    int at_home = GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 7);
+    
+    if (at_home && PLAYER_SAID (R, we_mean_no_harm))
+	{
+        // Lurg says nothing, player leaves peacefully.
+		SET_GAME_STATE (BATTLE_SEGUE, 0);
+        return;
+	}
+    
+    NPCPhrase (GOODBYE);
+	
+	SET_GAME_STATE (BATTLE_SEGUE, 1);
+}
+
+static void YouCantPass (RESPONSE_REF R)
+{
+    (void) R; // satisfy compiler
+    NPCPhrase (CANT_PASS);
+	
+    Response (last_chance, ExitConversation);
+    Response (lets_fight, ExitConversation);
+}
+
+static void
+AskQuestions (RESPONSE_REF R);
+
+static void
+WeKnowAll (RESPONSE_REF R)
+{
+    (void) R; // satisfy compiler
+    NPCPhrase (WE_KNOW_ALL);
+    
+    Response (we_kick_ass, AskQuestions);
+    Response (we_are_powerful, AskQuestions);
+}
+
+static void
+YouFeelUs (RESPONSE_REF R)
+{
+    (void) R; // satisfy compiler
+    DISABLE_PHRASE (you_look_familiar);
+    
+    NPCPhrase (YOU_FEEL_US);
+    
+    Response (alien_stalkers, WeKnowAll);
+    Response (creepy, WeKnowAll);
+    Response (big_imagination, WeKnowAll);
+}
+
+void
+AskQuestions (RESPONSE_REF R)
+{
+    int num_left = 0;
+    
+    if (PLAYER_SAID (R, we_kick_ass) || PLAYER_SAID (R, we_are_powerful))
+    {
+        NPCPhrase (EASILY_DESTROYED);
+    }
+    else if (PLAYER_SAID (R, tellus_species))
+    {
+        DISABLE_PHRASE (tellus_species);
+        NPCPhrase (OUR_SPECIES);
+    }
+	else if (PLAYER_SAID (R, tellus_ship))
+    {
+        DISABLE_PHRASE (tellus_ship);
+        NPCPhrase (OUR_SHIP);
+    }
+	else if (PLAYER_SAID (R, tellus_shielded))
+    {
+        DISABLE_PHRASE (tellus_shielded);
+        NPCPhrase (URQUAN_ALLIANCE);
+    }
+	else if (PLAYER_SAID (R, we_are_peaceful))
+    {
+        DISABLE_PHRASE (we_are_peaceful);
+        NPCPhrase (NOT_PEACEFUL);
+    }
+    else
+        NPCPhrase (ASK_YOUR_QUESTIONS);
+    
+    if (PHRASE_ENABLED (tellus_species))
+    {
+        Response (tellus_species, AskQuestions);
+        num_left++;
+    }
+    if (PHRASE_ENABLED (tellus_ship))
+    {
+        Response (tellus_ship, AskQuestions);
+        num_left++;
+    }
+    if (PHRASE_ENABLED (tellus_shielded))
+    {
+        Response (tellus_shielded, AskQuestions);
+        num_left++;
+    }
+    if (PHRASE_ENABLED (we_are_peaceful))
+    {
+        Response (we_are_peaceful, AskQuestions);
+        num_left++;
+    }
+    if (PHRASE_ENABLED (you_look_familiar))
+    {
+        Response (you_look_familiar, YouFeelUs);
+        num_left++;
+    }
+    
+    if (num_left > 0)
+        Response (dont_tellus, YouCantPass);
+    else
+        YouCantPass(R);
+}
+
+static void
+YouCantLeave (RESPONSE_REF R)
+{
+	if (PLAYER_SAID (R, we_mean_no_harm))
+        NPCPhrase (CANT_LEAVE);
+    else
+        NPCPhrase (DONT_INSULT_US);
+    
+	Response (can_we_pass, YouCantPass);
+	Response (let_us_pass, YouCantPass);
+	Response (tell_us_stuff, AskQuestions);
+}
+
+static void
+Intro (void)
+{
+	//	BYTE NumVisits;
+    int at_home = GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 7);
+
+	if (at_home)
+	{
+		NPCPhrase (LURG_HOME_HELLO_1);
+	}
+	else
+	{
+		NPCPhrase (LURG_SPACE_HELLO_1);
+	}
+	
+    if (at_home)
+    {
+    	Response (we_mean_no_harm, ExitConversation);
+        Response (lets_fight, ExitConversation);
+    }
+    else
+    {
+    	Response (we_mean_no_harm, YouCantLeave);
+        Response (distress_call, YouCantLeave);
+        Response (suck_vacuum, ExitConversation);
+    }
+}
+
+static COUNT
+uninit_lurg (void)
+{
+	return (0);
+}
+
+static void
+post_lurg_enc (void)
+{
+	// nothing defined so far
+}
+
+LOCDATA*
+init_lurg_comm (void)
+{
+	LOCDATA *retval;
+	static LOCDATA lurg_desc;
+
+	switch (RESOLUTION_FACTOR)
+	{
+	case 2:
+		lurg_desc = lurg_desc_4x;
+		break;
+	case 0:
+	default:
+		lurg_desc = lurg_desc_1x;
+		break;
+	}
+
+	lurg_desc.init_encounter_func = Intro;
+	lurg_desc.post_encounter_func = post_lurg_enc;
+	lurg_desc.uninit_encounter_func = uninit_lurg;
+
+	lurg_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
+	lurg_desc.AlienTextBaseline.y = RES_SIS_SCALE(100);
+	lurg_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
+
+	SET_GAME_STATE (BATTLE_SEGUE, 1);
+	retval = &lurg_desc;
+
+	return (retval);
+}
diff -ruNp src.orig/uqm/comm/lurg/resinst.h src/uqm/comm/lurg/resinst.h
--- src.orig/uqm/comm/lurg/resinst.h	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/lurg/resinst.h	2017-11-01 15:31:00 -0700
@@ -0,0 +1,5 @@
+#define LURG_COLOR_MAP "comm.lurg.colortable"
+#define LURG_PMAP_ANIM "comm.lurg.graphics"
+#define LURG_FONT "comm.lurg.font"
+#define LURG_CONVERSATION_PHRASES "comm.lurg.dialogue"
+#define LURG_MUSIC "comm.lurg.music"
diff -ruNp src.orig/uqm/comm/lurg/strings.h src/uqm/comm/lurg/strings.h
--- src.orig/uqm/comm/lurg/strings.h	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/lurg/strings.h	2017-11-01 15:31:01 -0700
@@ -0,0 +1,60 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _STRINGS_H
+#define _STRINGS_H
+
+enum
+{
+	NULL_PHRASE,
+    LURG_HOME_HELLO_1,
+    LURG_SPACE_HELLO_1,
+    we_mean_no_harm,
+    distress_call,
+    suck_vacuum,
+    CANT_LEAVE,
+    DONT_INSULT_US,
+    let_us_pass,
+    can_we_pass,
+    tell_us_stuff,
+    CANT_PASS,
+    ASK_YOUR_QUESTIONS,
+    tellus_species,
+    tellus_ship,
+    tellus_shielded,
+    we_are_peaceful,
+    dont_tellus,
+    URQUAN_ALLIANCE,
+    NOT_PEACEFUL,
+    OUR_SPECIES,
+    OUR_SHIP,
+    you_look_familiar, 
+    YOU_FEEL_US,
+    alien_stalkers,
+    creepy,
+    big_imagination,
+    WE_KNOW_ALL,
+    we_kick_ass,
+    we_are_powerful,
+    EASILY_DESTROYED,
+    last_chance,
+    lets_fight,
+    GOODBYE
+};
+
+#endif /* _STRINGS_H */
diff -ruNp src.orig/uqm/comm/melnorm/melnorm.c src/uqm/comm/melnorm/melnorm.c
--- src.orig/uqm/comm/melnorm/melnorm.c	2017-11-01 15:30:23 -0700
+++ src/uqm/comm/melnorm/melnorm.c	2017-11-01 15:31:01 -0700
@@ -16,6 +16,11 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+ 
+ // 	-DN DEC10		- added update_biounit_flags(void) that is activated when the 
+ //						player sells bio-data to enable the easter egg when the player
+ //						finds and sells data on all 25 new lifeform types
+ 
 #include "../commall.h"
 #include "resinst.h"
 #include "strings.h"
@@ -26,6 +31,7 @@
 #include "uqm/shipcont.h"
 #include "libs/inplib.h"
 #include "libs/mathlib.h"
+#include "assert.h"
 
 #include "uqm/hyper.h"
 			// for SOL_X/SOL_Y
@@ -33,16 +39,16 @@
 		// for xxx_DISASTER
 #include "uqm/sis.h"
 
+#define NUM_HISTORY_ITEMS 0
+#define NUM_EVENT_ITEMS 1
+#define NUM_ALIEN_RACE_ITEMS 0
+#define NUM_TECH_ITEMS 0
 
-#define NUM_HISTORY_ITEMS 9
-#define NUM_EVENT_ITEMS 8
-#define NUM_ALIEN_RACE_ITEMS 16
-#define NUM_TECH_ITEMS 13
-
-static const NUMBER_SPEECH_DESC melnorme_numbers_english;
+static NUMBER_SPEECH_DESC melnorme_numbers_english;
 
 static LOCDATA melnorme_desc =
 {
+	MELNORME_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -115,6 +121,11 @@ static LOCDATA melnorme_desc =
 	NULL, NULL, NULL,
 	NULL,
 	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
 };
 
 static COUNT melnorme_digit_names[] =
@@ -159,7 +170,7 @@ static COUNT melnorme_tens_names[] =
 	ENUMERATE_NINETY
 };
 
-static const NUMBER_SPEECH_DESC melnorme_numbers_english =
+static NUMBER_SPEECH_DESC melnorme_numbers_english =
 {
 	5, /* NumDigits */
 	{
@@ -202,328 +213,106 @@ static const NUMBER_SPEECH_DESC melnorme
 };
 
 static StatMsgMode prevMsgMode;
-
-static void DoFirstMeeting (RESPONSE_REF R);
-
-static COUNT
-ShipWorth (void)
-{
-	BYTE i;
-	SBYTE crew_pods;
-	COUNT worth;
-
-	worth = GLOBAL_SIS (NumLanders)
-			* GLOBAL (ModuleCost[PLANET_LANDER]);
-	for (i = 0; i < NUM_DRIVE_SLOTS; ++i)
-	{
-		if (GLOBAL_SIS (DriveSlots[i]) < EMPTY_SLOT)
-			worth += GLOBAL (ModuleCost[FUSION_THRUSTER]);
-	}
-	for (i = 0; i < NUM_JET_SLOTS; ++i)
-	{
-		if (GLOBAL_SIS (JetSlots[i]) < EMPTY_SLOT)
-			worth += GLOBAL (ModuleCost[TURNING_JETS]);
-	}
-
-	crew_pods = -(SBYTE)(
-			(GLOBAL_SIS (CrewEnlisted) + CREW_POD_CAPACITY - 1)
-			/ CREW_POD_CAPACITY
-			);
-	for (i = 0; i < NUM_MODULE_SLOTS; ++i)
-	{
-		BYTE which_module;
-
-		which_module = GLOBAL_SIS (ModuleSlots[i]);
-		if (which_module < BOMB_MODULE_0
-				&& (which_module != CREW_POD || ++crew_pods > 0))
-		{
-			worth += GLOBAL (ModuleCost[which_module]);
-		}
+void 
+update_biounit_flags(void) {
+	
+	/*
+	 * stuff for the Melnorme bio-data easter egg
+	 * this sets a flag indicating what types of creature
+	 * have been sold to the Melnorme. Once all types 
+	 * have been found, activate the easter egg! 
+	 * 
+	 * DN 04JAN11
+	 */
+	int all_found_flag = 0;
+
+	//probably should be done with a for loop and an array...  DN18JAN11
+	all_found_flag = all_found_flag + GET_GAME_STATE(MELNORME_ECHINOSOL_TYPE_FOUND);
+	all_found_flag = all_found_flag + GET_GAME_STATE(MELNORME_FLORA_FLATULENSIS_TYPE_FOUND);
+	all_found_flag = all_found_flag + GET_GAME_STATE(MELNORME_HOPPING_HATCHLING_TYPE_FOUND);
+	all_found_flag = all_found_flag + GET_GAME_STATE(MELNORME_DIZZY_FNARBLE_TYPE_FOUND);
+	all_found_flag = all_found_flag + GET_GAME_STATE(MELNORME_FLAGELLUM_PEST_TYPE_FOUND);
+	all_found_flag = all_found_flag + GET_GAME_STATE(MELNORME_FLYING_OHAIRY_TYPE_FOUND);
+	all_found_flag = all_found_flag + GET_GAME_STATE(MELNORME_BOBBING_WHIBBIT_TYPE_FOUND);
+	all_found_flag = all_found_flag + GET_GAME_STATE(MELNORME_MUDDY_MORPHLEGM_TYPE_FOUND);
+	all_found_flag = all_found_flag + GET_GAME_STATE(MELNORME_ULTRAMOEBA_TYPE_FOUND);
+	all_found_flag = all_found_flag + GET_GAME_STATE(MELNORME_ELECTROPTERA_TYPE_FOUND);
+	all_found_flag = all_found_flag + GET_GAME_STATE(MELNORME_QUARTZERBACK_TYPE_FOUND);
+	all_found_flag = all_found_flag + GET_GAME_STATE(MELNORME_TUBERUS_HUMUNGUS_TYPE_FOUND);
+	all_found_flag = all_found_flag + GET_GAME_STATE(MELNORME_VENUS_FRYTRAP_TYPE_FOUND);
+	all_found_flag = all_found_flag + GET_GAME_STATE(MELNORME_WATCHFUL_WILLOW_TYPE_FOUND);
+	all_found_flag = all_found_flag + GET_GAME_STATE(MELNORME_XEROPHYTIC_AUTOVORE_TYPE_FOUND);
+	all_found_flag = all_found_flag + GET_GAME_STATE(MELNORME_MIGRATOR_BLIMP_TYPE_FOUND);
+	all_found_flag = all_found_flag + GET_GAME_STATE(MELNORME_TENTACLE_DUJOUR_TYPE_FOUND);
+	all_found_flag = all_found_flag + GET_GAME_STATE(MELNORME_VANISHING_VERMIN_TYPE_FOUND);
+	all_found_flag = all_found_flag + GET_GAME_STATE(MELNORME_TRIPAZOID_TUMBLER_TYPE_FOUND);
+	all_found_flag = all_found_flag + GET_GAME_STATE(MELNORME_DUMPY_DWEEJUS_TYPE_FOUND);
+	all_found_flag = all_found_flag + GET_GAME_STATE(MELNORME_RADIAL_ARACHNID_TYPE_FOUND);
+	all_found_flag = all_found_flag + GET_GAME_STATE(MELNORME_WACKODEMON_TYPE_FOUND);
+	all_found_flag = all_found_flag + GET_GAME_STATE(MELNORME_CRABBY_OCTOPUS_TYPE_FOUND);	
+	all_found_flag = all_found_flag + GET_GAME_STATE(MELNORME_BLINKING_BEHOLDER_TYPE_FOUND);
+	all_found_flag = all_found_flag + GET_GAME_STATE(MELNORME_CREEPING_HEAD_TYPE_FOUND);
+		
+	/*check to see if all bio_unit types have been found*/
+	if (all_found_flag == 25 && GET_GAME_STATE(MELNORME_ALL_LIFE_TYPE_FOUND) != 2) {
+		SET_GAME_STATE(MELNORME_ALL_LIFE_TYPE_FOUND, 1);
 	}
-
-	return (worth);
+	
 }
 
-static COUNT rescue_fuel;
-static SIS_STATE SIS_copy;
-
-static BOOLEAN
-StripShip (COUNT fuel_required)
+static COUNT
+DeltaCredit (SIZE delta_credit)
 {
-	BYTE i, which_module;
-	SBYTE crew_pods;
-
-	SET_GAME_STATE (MELNORME_RESCUE_REFUSED, 0);
-
-	crew_pods = -(SBYTE)(
-			(GLOBAL_SIS (CrewEnlisted) + CREW_POD_CAPACITY - 1)
-			/ CREW_POD_CAPACITY
-			);
-	if (fuel_required == 0)
-	{
-		GlobData.SIS_state = SIS_copy;
-		LockMutex (GraphicsLock);
-		DeltaSISGauges (UNDEFINED_DELTA, rescue_fuel, UNDEFINED_DELTA);
-		UnlockMutex (GraphicsLock);
-	}
-	else if (fuel_required == (COUNT)~0)
+	COUNT Credit;
+	
+	Credit = MAKE_WORD (
+						GET_GAME_STATE (MELNORME_CREDIT0),
+						GET_GAME_STATE (MELNORME_CREDIT1)
+						);
+	if ((int)delta_credit >= 0 || ((int)(-delta_credit) <= (int)(Credit)))
 	{
-		GLOBAL_SIS (NumLanders) = 0;
-		for (i = 0; i < NUM_DRIVE_SLOTS; ++i)
-			GLOBAL_SIS (DriveSlots[i]) = EMPTY_SLOT + 0;
-		for (i = 0; i < NUM_JET_SLOTS; ++i)
-			GLOBAL_SIS (JetSlots[i]) = EMPTY_SLOT + 1;
-		if (GLOBAL_SIS (FuelOnBoard) > FUEL_RESERVE)
-			GLOBAL_SIS (FuelOnBoard) = FUEL_RESERVE;
-		GLOBAL_SIS (TotalBioMass) = 0;
-		GLOBAL_SIS (TotalElementMass) = 0;
-		for (i = 0; i < NUM_ELEMENT_CATEGORIES; ++i)
-			GLOBAL_SIS (ElementAmounts[i]) = 0;
-		for (i = 0; i < NUM_MODULE_SLOTS; ++i)
-		{
-			which_module = GLOBAL_SIS (ModuleSlots[i]);
-			if (which_module < BOMB_MODULE_0
-					&& (which_module != CREW_POD
-					|| ++crew_pods > 0))
-				GLOBAL_SIS (ModuleSlots[i]) = EMPTY_SLOT + 2;
-		}
-
+		Credit += delta_credit;
+		SET_GAME_STATE (MELNORME_CREDIT0, LOBYTE (Credit));
+		SET_GAME_STATE (MELNORME_CREDIT1, HIBYTE (Credit));
 		LockMutex (GraphicsLock);
-		DeltaSISGauges (UNDEFINED_DELTA, UNDEFINED_DELTA, UNDEFINED_DELTA);
+		DrawStatusMessage (NULL);
 		UnlockMutex (GraphicsLock);
 	}
-	else if (fuel_required)
+	else
 	{
-		SBYTE bays;
-		BYTE num_searches, beg_mod, end_mod;
-		COUNT worth, total;
-		BYTE module_count[BOMB_MODULE_0];
-		BYTE slot;
-		DWORD capacity;
-
-		SIS_copy = GlobData.SIS_state;
-		for (i = PLANET_LANDER; i < BOMB_MODULE_0; ++i)
-			module_count[i] = 0;
-
-		capacity = FUEL_RESERVE;
-		slot = NUM_MODULE_SLOTS - 1;
-		do
-		{
-			if (SIS_copy.ModuleSlots[slot] == FUEL_TANK
-					|| SIS_copy.ModuleSlots[slot] == HIGHEFF_FUELSYS)
-			{
-				COUNT volume;
-
-				volume = SIS_copy.ModuleSlots[slot] == FUEL_TANK
-						? FUEL_TANK_CAPACITY : HEFUEL_TANK_CAPACITY;
-				capacity += volume;
-			}
-		} while (slot--);
-		if (fuel_required > capacity)
-			fuel_required = capacity;
-
-		bays = -(SBYTE)(
-				(SIS_copy.TotalElementMass + STORAGE_BAY_CAPACITY - 1)
-				/ STORAGE_BAY_CAPACITY
-				);
-		for (i = 0; i < NUM_MODULE_SLOTS; ++i)
-		{
-			which_module = SIS_copy.ModuleSlots[i];
-			if (which_module == CREW_POD)
-				++crew_pods;
-			else if (which_module == STORAGE_BAY)
-				++bays;
-		}
-
-		worth = fuel_required / FUEL_TANK_SCALE;
-		total = 0;
-		num_searches = 0;
-		beg_mod = end_mod = (BYTE)~0;
-		while (total < worth && ShipWorth () && ++num_searches)
-		{
-			DWORD rand_val;
-
-			rand_val = TFB_Random ();
-			switch (which_module = LOBYTE (LOWORD (rand_val)) % (CREW_POD + 1))
-			{
-				case PLANET_LANDER:
-					if (SIS_copy.NumLanders == 0)
-						continue;
-					--SIS_copy.NumLanders;
-					break;
-				case FUSION_THRUSTER:
-					for (i = 0; i < NUM_DRIVE_SLOTS; ++i)
-					{
-						if (SIS_copy.DriveSlots[i] < EMPTY_SLOT)
-							break;
-					}
-					if (i == NUM_DRIVE_SLOTS)
-						continue;
-					SIS_copy.DriveSlots[i] = EMPTY_SLOT + 0;
-					break;
-				case TURNING_JETS:
-					for (i = 0; i < NUM_JET_SLOTS; ++i)
-					{
-						if (SIS_copy.JetSlots[i] < EMPTY_SLOT)
-							break;
-					}
-					if (i == NUM_JET_SLOTS)
-						continue;
-					SIS_copy.JetSlots[i] = EMPTY_SLOT + 1;
-					break;
-				case CREW_POD:
-					i = HIBYTE (LOWORD (rand_val)) % NUM_MODULE_SLOTS;
-					which_module = SIS_copy.ModuleSlots[i];
-					if (which_module >= BOMB_MODULE_0
-							|| which_module == FUEL_TANK
-							|| which_module == HIGHEFF_FUELSYS
-							|| (which_module == STORAGE_BAY
-							&& module_count[STORAGE_BAY] >= bays)
-							|| (which_module == CREW_POD
-							&& module_count[CREW_POD] >= crew_pods))
-						continue;
-					SIS_copy.ModuleSlots[i] = EMPTY_SLOT + 2;
-					break;
-			}
-
-			if (beg_mod == (BYTE)~0)
-				beg_mod = end_mod = which_module;
-			else if (which_module > end_mod)
-				end_mod = which_module;
-			++module_count[which_module];
-			total += GLOBAL (ModuleCost[which_module]);
-		}
-
-		if (total == 0)
-		{
-			NPCPhrase (CHARITY);
-			LockMutex (GraphicsLock);
-			DeltaSISGauges (0, fuel_required, 0);
-			UnlockMutex (GraphicsLock);
-			return (FALSE);
-		}
-		else
-		{
-			NPCPhrase (RESCUE_OFFER);
-			rescue_fuel = fuel_required;
-			if (rescue_fuel == capacity)
-				NPCPhrase (RESCUE_TANKS);
-			else
-				NPCPhrase (RESCUE_HOME);
-			for (i = PLANET_LANDER; i < BOMB_MODULE_0; ++i)
-			{
-				if (module_count[i])
-				{
-					RESPONSE_REF pStr = 0;
-
-					switch (i)
-					{
-						case PLANET_LANDER:
-							pStr = LANDERS;
-							break;
-						case FUSION_THRUSTER:
-							pStr = THRUSTERS;
-							break;
-						case TURNING_JETS:
-							pStr = JETS;
-							break;
-						case CREW_POD:
-							pStr = PODS;
-							break;
-						case STORAGE_BAY:
-							pStr = BAYS;
-							break;
-						case DYNAMO_UNIT:
-							pStr = DYNAMOS;
-							break;
-						case SHIVA_FURNACE:
-							pStr = FURNACES;
-							break;
-						case GUN_WEAPON:
-							pStr = GUNS;
-							break;
-						case BLASTER_WEAPON:
-							pStr = BLASTERS;
-							break;
-						case CANNON_WEAPON:
-							pStr = CANNONS;
-							break;
-						case TRACKING_SYSTEM:
-							pStr = TRACKERS;
-							break;
-						case ANTIMISSILE_DEFENSE:
-							pStr = DEFENSES;
-							break;
-						default:
-							assert (0 && "Unknown module");
-					}
-
-					if (i == end_mod && i != beg_mod)
-						NPCPhrase (END_LIST_WITH_AND);
-					NPCPhrase (ENUMERATE_ONE + (module_count[i] - 1));
-					NPCPhrase (pStr);
-				}
-			}
-		}
+		NPCPhrase (NEED_MORE_CREDIT0);
+		NPCPhrase (delta_credit + (int)Credit);
+		NPCPhrase (NEED_MORE_CREDIT1);
 	}
-
-	return (TRUE);
+	
+	return (Credit);
 }
 
+BOOLEAN StripExplorer (COUNT fuel_required);
+
 static void
 ExitConversation (RESPONSE_REF R)
 {
 	if (PLAYER_SAID (R, no_trade_now))
-		NPCPhrase (OK_NO_TRADE_NOW_BYE);
-	else if (PLAYER_SAID (R, youre_on))
-	{
-		NPCPhrase (YOU_GIVE_US_NO_CHOICE);
-
-		SET_GAME_STATE (MELNORME_ANGER, 1);
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
-	}
-	else if (PLAYER_SAID (R, so_we_can_attack))
-	{
-		NPCPhrase (DECEITFUL_HUMAN);
-
-		SET_GAME_STATE (MELNORME_ANGER, 2);
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
-	}
-	else if (PLAYER_SAID (R, bye_melnorme_slightly_angry))
-		NPCPhrase (MELNORME_SLIGHTLY_ANGRY_GOODBYE);
-	else if (PLAYER_SAID (R, ok_strip_me))
-	{
-		if (ShipWorth () < 4000 / MODULE_COST_SCALE)
-				/* is ship worth stripping */
-			NPCPhrase (NOT_WORTH_STRIPPING);
-		else
-		{
-			SET_GAME_STATE (MELNORME_ANGER, 0);
-
-			StripShip ((COUNT)~0);
-			NPCPhrase (FAIR_JUSTICE);
-		}
-	}
-	else if (PLAYER_SAID (R, fight_some_more))
 	{
-		NPCPhrase (OK_FIGHT_SOME_MORE);
-
-		SET_GAME_STATE (MELNORME_ANGER, 3);
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		NPCPhrase (OK_NO_TRADE_NOW_BYE);
+		SET_GAME_STATE (BATTLE_SEGUE, 0);
 	}
-	else if (PLAYER_SAID (R, bye_melnorme_pissed_off))
-		NPCPhrase (MELNORME_PISSED_OFF_GOODBYE);
-	else if (PLAYER_SAID (R, well_if_thats_the_way_you_feel))
+	else if (PLAYER_SAID (R, spank_ass2))
 	{
-		NPCPhrase (WE_FIGHT_AGAIN);
-
+		NPCPhrase (BATTLE_MELNORME);
 		SET_GAME_STATE (BATTLE_SEGUE, 1);
 	}
-	else if (PLAYER_SAID (R, you_hate_us_so_we_go_away))
-		NPCPhrase (HATE_YOU_GOODBYE);
 	else if (PLAYER_SAID (R, take_it))
 	{
-		StripShip (0);
+		switch (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS)) {
+			case CHMMR_EXPLORER_SHIP:
+				StripExplorer(0);
+				break;
+			case PRECURSOR_BATTLESHIP:
+				/* TODO: implement... */
+				break;
+		}
 		NPCPhrase (HAPPY_TO_HAVE_RESCUED);
 	}
 	else if (PLAYER_SAID (R, leave_it))
@@ -540,253 +329,143 @@ ExitConversation (RESPONSE_REF R)
 	{
 		NPCPhrase (GOODBYE_AND_GOODLUCK_AGAIN);
 	}
-	else if (PLAYER_SAID (R, be_leaving_now)
-			|| PLAYER_SAID (R, goodbye))
-	{
-		NPCPhrase (FRIENDLY_GOODBYE);
-	}
+
 }
 
+
 static void
-DoRescue (RESPONSE_REF R)
-{
-	SIZE dx, dy;
-	COUNT fuel_required;
+PurchaseMenu (RESPONSE_REF R);
 
-	(void) R;  // ignored
-	dx = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x))
-			- SOL_X;
-	dy = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y))
-			- SOL_Y;
-	fuel_required = square_root (
-			(DWORD)((long)dx * dx + (long)dy * dy)
-			) + (2 * FUEL_TANK_SCALE);
+static void
+SellMenu (RESPONSE_REF R);
 
-	if (StripShip (fuel_required))
-	{
-		Response (take_it, ExitConversation);
-		Response (leave_it, ExitConversation);
-	}
-}
+static void
+TradeMenu (RESPONSE_REF R);
 
-static COUNT
-DeltaCredit (SIZE delta_credit)
+static void
+ShipMarkSightingsMenu (RESPONSE_REF R)
 {
-	COUNT Credit;
-
-	Credit = MAKE_WORD (
-			GET_GAME_STATE (MELNORME_CREDIT0),
-			GET_GAME_STATE (MELNORME_CREDIT1)
-			);
-	if ((int)delta_credit >= 0 || ((int)(-delta_credit) <= (int)(Credit)))
+	if (PLAYER_SAID (R, sell_ship_mark_sightings))
 	{
-		Credit += delta_credit;
-		SET_GAME_STATE (MELNORME_CREDIT0, LOBYTE (Credit));
-		SET_GAME_STATE (MELNORME_CREDIT1, HIBYTE (Credit));
-		LockMutex (GraphicsLock);
-		DrawStatusMessage (NULL);
-		UnlockMutex (GraphicsLock);
+		NPCPhrase (OFFER_CREDITS_FOR_SHIPMARK_INFO);
+		Response (deal_shipmarks, ShipMarkSightingsMenu);
+		Response (no_deal_shipmarks, SellMenu);
 	}
-	else
+	else if (PLAYER_SAID (R, deal_shipmarks))
 	{
-		NPCPhrase (NEED_MORE_CREDIT0);
-		NPCNumber (-delta_credit - Credit, NULL);
-		NPCPhrase (NEED_MORE_CREDIT1);
-	}
-	
-	return (Credit);
+		NPCPhrase (ALTERNATIVE_REWARD_FOR_SHIPMARK_INFO);
+		Response (credits_for_ship_mark_sightings, SellMenu);
+		Response (info_for_ship_mark_sightings, SellMenu);
+	}	
 }
 
 static void
-CurrentEvents (void)
+BuyInfoMenu (RESPONSE_REF R)
 {
-	BYTE stack;
-
-	stack = GET_GAME_STATE (MELNORME_EVENTS_INFO_STACK);
-	switch (stack++)
+	COUNT credit;
+	SIZE needed_credit;
+	
+	credit = MAKE_WORD (GET_GAME_STATE (MELNORME_CREDIT0), GET_GAME_STATE (MELNORME_CREDIT1));
+	
+#define INFO_COST 75
+	needed_credit = INFO_COST;
+	
+	if (PLAYER_SAID (R, buy_current_events))
 	{
-		case 0:
+		BYTE stack = GET_GAME_STATE (MELNORME_EVENTS_INFO_STACK);
+		assert (stack < NUM_EVENT_ITEMS);
+		if ((int)credit >= (int)needed_credit)
+		{
+			/* TODO: If/when we add more current event info for sale, factor out
+			 * a switch on stack here. */
 			NPCPhrase (OK_BUY_EVENT_1);
-			break;
-		case 1:
-			NPCPhrase (OK_BUY_EVENT_2);
-			break;
-		case 2:
-			NPCPhrase (OK_BUY_EVENT_3);
-			break;
-		case 3:
-			NPCPhrase (OK_BUY_EVENT_4);
-			break;
-		case 4:
-			NPCPhrase (OK_BUY_EVENT_5);
-			break;
-		case 5:
-			NPCPhrase (OK_BUY_EVENT_6);
-			break;
-		case 6:
-			NPCPhrase (OK_BUY_EVENT_7);
-			break;
-		case 7:
-			NPCPhrase (OK_BUY_EVENT_8);
-			break;
+			SET_GAME_STATE (MELNORME_EVENTS_INFO_STACK, stack+1);
+		}
+		DeltaCredit (-needed_credit);
 	}
-	SET_GAME_STATE (MELNORME_EVENTS_INFO_STACK, stack);
-}
-
-static void
-AlienRaces (void)
-{
-	BYTE stack;
-
-	stack = GET_GAME_STATE (MELNORME_ALIEN_INFO_STACK);
-	switch (stack++)
+	else if (PLAYER_SAID (R, buy_alien_races))
 	{
-		case 0:
+		BYTE stack = GET_GAME_STATE (MELNORME_ALIEN_INFO_STACK);
+		assert(stack < NUM_ALIEN_RACE_ITEMS);
+		if ((int)credit >= (int)needed_credit)
+		{
 			NPCPhrase (OK_BUY_ALIEN_RACE_1);
-			break;
-		case 1:
-			NPCPhrase (OK_BUY_ALIEN_RACE_2);
-			break;
-		case 2:
-			NPCPhrase (OK_BUY_ALIEN_RACE_3);
-			break;
-		case 3:
-			NPCPhrase (OK_BUY_ALIEN_RACE_4);
-			break;
-		case 4:
-			NPCPhrase (OK_BUY_ALIEN_RACE_5);
-			break;
-		case 5:
-			NPCPhrase (OK_BUY_ALIEN_RACE_6);
-			break;
-		case 6:
-			NPCPhrase (OK_BUY_ALIEN_RACE_7);
-			break;
-		case 7:
-			NPCPhrase (OK_BUY_ALIEN_RACE_8);
-			break;
-		case 8:
-			NPCPhrase (OK_BUY_ALIEN_RACE_9);
-			break;
-		case 9:
-			NPCPhrase (OK_BUY_ALIEN_RACE_10);
-			break;
-		case 10:
-			NPCPhrase (OK_BUY_ALIEN_RACE_11);
-			break;
-		case 11:
-			NPCPhrase (OK_BUY_ALIEN_RACE_12);
-			break;
-		case 12:
-			NPCPhrase (OK_BUY_ALIEN_RACE_13);
-			break;
-		case 13:
-			NPCPhrase (OK_BUY_ALIEN_RACE_14);
-			if (!GET_GAME_STATE (FOUND_PLUTO_SPATHI))
-			{
-				SET_GAME_STATE (KNOW_SPATHI_PASSWORD, 1);
-				SET_GAME_STATE (SPATHI_HOME_VISITS, 7);
-			}
-			break;
-		case 14:
-			NPCPhrase (OK_BUY_ALIEN_RACE_15);
-			if (GET_GAME_STATE (KNOW_ABOUT_SHATTERED) < 2)
-			{
-				SET_GAME_STATE (KNOW_ABOUT_SHATTERED, 2);
-			}
-			SET_GAME_STATE (KNOW_SYREEN_WORLD_SHATTERED, 1);
-			break;
-		case 15:
-			NPCPhrase (OK_BUY_ALIEN_RACE_16);
-			break;
+			SET_GAME_STATE (MELNORME_ALIEN_INFO_STACK, stack+1);
+		}
+		DeltaCredit (-needed_credit);
 	}
-	SET_GAME_STATE (MELNORME_ALIEN_INFO_STACK, stack);
-}
-
-static void
-History (void)
-{
-	BYTE stack;
-
-	stack = GET_GAME_STATE (MELNORME_HISTORY_INFO_STACK);
-	switch (stack++)
+	else if (PLAYER_SAID (R, buy_history))
 	{
-		case 0:
+		BYTE stack = GET_GAME_STATE (MELNORME_HISTORY_INFO_STACK);
+		assert(stack < NUM_HISTORY_ITEMS);
+		if ((int)credit >= (int)needed_credit)
+		{
 			NPCPhrase (OK_BUY_HISTORY_1);
-			break;
-		case 1:
-			NPCPhrase (OK_BUY_HISTORY_2);
-			break;
-		case 2:
-			NPCPhrase (OK_BUY_HISTORY_3);
-			break;
-		case 3:
-			NPCPhrase (OK_BUY_HISTORY_4);
-			break;
-		case 4:
-			NPCPhrase (OK_BUY_HISTORY_5);
-			break;
-		case 5:
-			NPCPhrase (OK_BUY_HISTORY_6);
-			break;
-		case 6:
-			NPCPhrase (OK_BUY_HISTORY_7);
-			break;
-		case 7:
-			NPCPhrase (OK_BUY_HISTORY_8);
-			break;
-		case 8:
-			NPCPhrase (OK_BUY_HISTORY_9);
-			break;
+			SET_GAME_STATE (MELNORME_HISTORY_INFO_STACK, stack+1);
+		}
+		DeltaCredit (-needed_credit);
+	}
+	else if (PLAYER_SAID (R, buy_info))
+	{
+		if (GET_GAME_STATE (MELNORME_INFO_PROCEDURE))
+			NPCPhrase (OK_BUY_INFO);
+		else
+		{
+			NPCPhrase (BUY_INFO_INTRO);
+			SET_GAME_STATE (MELNORME_INFO_PROCEDURE, 1);
+		}
 	}
-	SET_GAME_STATE (MELNORME_HISTORY_INFO_STACK, stack);
-}
 
-static void NatureOfConversation (RESPONSE_REF R);
+	if (GET_GAME_STATE (MELNORME_EVENTS_INFO_STACK) < NUM_EVENT_ITEMS)
+		Response (buy_current_events, BuyInfoMenu);
+	if (GET_GAME_STATE (MELNORME_ALIEN_INFO_STACK) < NUM_ALIEN_RACE_ITEMS)
+		Response (buy_alien_races, BuyInfoMenu);
+	if (GET_GAME_STATE (MELNORME_HISTORY_INFO_STACK) < NUM_HISTORY_ITEMS)
+		Response (buy_history, BuyInfoMenu);
+
+	Response (done_buying_info, PurchaseMenu);
+}
 
-static BYTE AskedToBuy;
 
 static void
-DoBuy (RESPONSE_REF R)
+BuyFuelMenu (RESPONSE_REF R)
 {
 	COUNT credit;
 	SIZE needed_credit;
 	BYTE slot;
 	DWORD capacity;
-
-	credit = MAKE_WORD (
-			GET_GAME_STATE (MELNORME_CREDIT0),
-			GET_GAME_STATE (MELNORME_CREDIT1)
-			);
-
+	BOOLEAN doNotOfferFuel;
+	
+	credit = MAKE_WORD (GET_GAME_STATE (MELNORME_CREDIT0),GET_GAME_STATE (MELNORME_CREDIT1));
 	capacity = FUEL_RESERVE;
-	slot = NUM_MODULE_SLOTS - 1;
-	do
+	doNotOfferFuel = FALSE;
+	
+	if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == CHMMR_EXPLORER_SHIP)
 	{
-		if (GLOBAL_SIS (ModuleSlots[slot]) == FUEL_TANK
-				|| GLOBAL_SIS (ModuleSlots[slot]) == HIGHEFF_FUELSYS)
-		{
-			COUNT volume;
-
-			volume = GLOBAL_SIS (ModuleSlots[slot]) == FUEL_TANK
-					? FUEL_TANK_CAPACITY : HEFUEL_TANK_CAPACITY;
-			capacity += volume;
-		}
-	} while (slot--);
-
-	if (credit == 0)
+		capacity = EXPLORER_FUEL_CAPACITY;
+	}	
+	else
 	{
-		AskedToBuy = TRUE;
-		NPCPhrase (NEED_CREDIT);
-
-		NatureOfConversation (R);
+		slot = NUM_MODULE_SLOTS - 1;
+		
+		do
+		{
+			if (GLOBAL_SIS (ModuleSlots[slot]) == FUEL_TANK || GLOBAL_SIS (ModuleSlots[slot]) == HIGHEFF_FUELSYS)
+			{
+				COUNT volume;
+			
+				volume = GLOBAL_SIS (ModuleSlots[slot]) == FUEL_TANK ? FUEL_TANK_CAPACITY : HEFUEL_TANK_CAPACITY;
+				capacity += volume;
+			}
+		} while (slot--);
 	}
-	else if (PLAYER_SAID (R, buy_fuel)
-			|| PLAYER_SAID (R, buy_1_fuel)
-			|| PLAYER_SAID (R, buy_5_fuel)
-			|| PLAYER_SAID (R, buy_10_fuel)
-			|| PLAYER_SAID (R, buy_25_fuel)
-			|| PLAYER_SAID (R, fill_me_up))
+	
+	if (PLAYER_SAID (R, buy_fuel)
+		|| PLAYER_SAID (R, buy_1_fuel)
+		|| PLAYER_SAID (R, buy_5_fuel)
+		|| PLAYER_SAID (R, buy_10_fuel)
+		|| PLAYER_SAID (R, buy_25_fuel)
+		|| PLAYER_SAID (R, fill_me_up))
 	{
 		needed_credit = 0;
 		if (PLAYER_SAID (R, buy_1_fuel))
@@ -798,10 +477,8 @@ DoBuy (RESPONSE_REF R)
 		else if (PLAYER_SAID (R, buy_25_fuel))
 			needed_credit = 25;
 		else if (PLAYER_SAID (R, fill_me_up))
-			needed_credit = (capacity - GLOBAL_SIS (FuelOnBoard)
-					+ FUEL_TANK_SCALE - 1)
-				/ FUEL_TANK_SCALE;
-
+			needed_credit = (capacity - GLOBAL_SIS (FuelOnBoard) + FUEL_TANK_SCALE - 1) / FUEL_TANK_SCALE;
+		
 		if (needed_credit == 0)
 		{
 			if (!GET_GAME_STATE (MELNORME_FUEL_PROCEDURE))
@@ -812,19 +489,18 @@ DoBuy (RESPONSE_REF R)
 		}
 		else
 		{
-			if (GLOBAL_SIS (FuelOnBoard) / FUEL_TANK_SCALE
-					+ needed_credit > capacity / FUEL_TANK_SCALE)
+			if (GLOBAL_SIS (FuelOnBoard) / FUEL_TANK_SCALE + needed_credit > capacity / FUEL_TANK_SCALE)
 			{
 				NPCPhrase (NO_ROOM_FOR_FUEL);
 				goto TryFuelAgain;
 			}
-
+			
 			if ((int)(needed_credit * (BIO_CREDIT_VALUE / 2)) <= (int)credit)
 			{
 				DWORD f;
-
+				
 				NPCPhrase (GOT_FUEL);
-
+				
 				f = (DWORD)needed_credit * FUEL_TANK_SCALE;
 				LockMutex (GraphicsLock);
 				while (f > 0x3FFFL)
@@ -841,352 +517,177 @@ DoBuy (RESPONSE_REF R)
 		{
 			DeltaCredit (-needed_credit);
 			if (GLOBAL_SIS (FuelOnBoard) >= capacity)
-				goto BuyBuyBuy;
-		}
-TryFuelAgain:
-		NPCPhrase (HOW_MUCH_FUEL);
-
-		Response (buy_1_fuel, DoBuy);
-		Response (buy_5_fuel, DoBuy);
-		Response (buy_10_fuel, DoBuy);
-		Response (buy_25_fuel, DoBuy);
-		Response (fill_me_up, DoBuy);
-		Response (done_buying_fuel, DoBuy);
-	}
-	else if (PLAYER_SAID (R, buy_technology)
-			|| PLAYER_SAID (R, buy_new_tech))
-	{
-		BYTE stack;
-
-		needed_credit = 0;
-		if (PLAYER_SAID (R, buy_technology))
-		{
-			if (!GET_GAME_STATE (MELNORME_TECH_PROCEDURE))
 			{
-				NPCPhrase (BUY_NEW_TECH_INTRO);
-				SET_GAME_STATE (MELNORME_TECH_PROCEDURE, 1);
+				PurchaseMenu(0);
+				doNotOfferFuel = TRUE;
 			}
-			stack = 0;
 		}
-		else
+	TryFuelAgain:
+		if (!doNotOfferFuel)
 		{
-			RESPONSE_REF pStr = 0;
-
-			stack = GET_GAME_STATE (MELNORME_TECH_STACK);
-			switch (stack)
-			{
-				case 0:
-					pStr = OK_BUY_NEW_TECH_1;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 1:
-					pStr = OK_BUY_NEW_TECH_2;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 2:
-					pStr = OK_BUY_NEW_TECH_3;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 3:
-					pStr = OK_BUY_NEW_TECH_4;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 4:
-					pStr = OK_BUY_NEW_TECH_5;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 5:
-					pStr = OK_BUY_NEW_TECH_6;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 6:
-					pStr = OK_BUY_NEW_TECH_7;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 7:
-					pStr = OK_BUY_NEW_TECH_8;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 8:
-					pStr = OK_BUY_NEW_TECH_9;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 9:
-					pStr = OK_BUY_NEW_TECH_10;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 10:
-					pStr = OK_BUY_NEW_TECH_11;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 11:
-					pStr = OK_BUY_NEW_TECH_12;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 12:
-					pStr = OK_BUY_NEW_TECH_13;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				default:
-					assert (0 && "Unknown tech");
-			}
-			if ((int)needed_credit > (int)credit)
-			{
-				DeltaCredit (-needed_credit);
-				goto BuyBuyBuy;
-			}
-			else
-			{
-				++stack;
-				NPCPhrase (pStr);
-				DeltaCredit (-needed_credit);
-			}
+			NPCPhrase (HOW_MUCH_FUEL);
+		
+			Response (buy_1_fuel, BuyFuelMenu);
+			Response (buy_5_fuel, BuyFuelMenu);
+			Response (buy_10_fuel, BuyFuelMenu);
+			Response (buy_25_fuel, BuyFuelMenu);
+			Response (fill_me_up, BuyFuelMenu);
+			Response (done_buying_fuel, PurchaseMenu);
 		}
+	}
+		
+}
 
-		switch (stack)
-		{
-			case 0:
-				if (GLOBAL (ModuleCost[BLASTER_WEAPON]) == 0)
-				{
-					NPCPhrase (NEW_TECH_1);
-					break;
-				}
-				++stack;
-			case 1:
-				GLOBAL (ModuleCost[BLASTER_WEAPON]) =
-						4000 / MODULE_COST_SCALE;
-				if (!GET_GAME_STATE (IMPROVED_LANDER_SPEED))
-				{
-					NPCPhrase (NEW_TECH_2);
-					break;
-				}
-				++stack;
-			case 2:
-				SET_GAME_STATE (IMPROVED_LANDER_SPEED, 1);
-				if (GLOBAL (ModuleCost[ANTIMISSILE_DEFENSE]) == 0)
-				{
-					NPCPhrase (NEW_TECH_3);
-					break;
-				}
-				++stack;
-			case 3:
-				GLOBAL (ModuleCost[ANTIMISSILE_DEFENSE]) =
-						4000 / MODULE_COST_SCALE;
-				if (!(GET_GAME_STATE (LANDER_SHIELDS)
-						& (1 << BIOLOGICAL_DISASTER)))
-				{
-					NPCPhrase (NEW_TECH_4);
-					break;
-				}
-				++stack;
-			case 4:
-				credit = GET_GAME_STATE (LANDER_SHIELDS)
-						| (1 << BIOLOGICAL_DISASTER);
-				SET_GAME_STATE (LANDER_SHIELDS, credit);
-				if (!GET_GAME_STATE (IMPROVED_LANDER_CARGO))
-				{
-					NPCPhrase (NEW_TECH_5);
-					break;
-				}
-				++stack;
-			case 5:
-				SET_GAME_STATE (IMPROVED_LANDER_CARGO, 1);
-				if (GLOBAL (ModuleCost[HIGHEFF_FUELSYS]) == 0)
-				{
-					NPCPhrase (NEW_TECH_6);
-					break;
-				}
-				++stack;
-			case 6:
-				GLOBAL (ModuleCost[HIGHEFF_FUELSYS]) =
-						1000 / MODULE_COST_SCALE;
-				if (!GET_GAME_STATE (IMPROVED_LANDER_SHOT))
-				{
-					NPCPhrase (NEW_TECH_7);
-					break;
-				}
-				++stack;
-			case 7:
-				SET_GAME_STATE (IMPROVED_LANDER_SHOT, 1);
-				if (!(GET_GAME_STATE (LANDER_SHIELDS)
-						& (1 << EARTHQUAKE_DISASTER)))
-				{
-					NPCPhrase (NEW_TECH_8);
-					break;
-				}
-				++stack;
-			case 8:
-				credit = GET_GAME_STATE (LANDER_SHIELDS)
-						| (1 << EARTHQUAKE_DISASTER);
-				SET_GAME_STATE (LANDER_SHIELDS, credit);
-				if (GLOBAL (ModuleCost[TRACKING_SYSTEM]) == 0)
-				{
-					NPCPhrase (NEW_TECH_9);
-					break;
-				}
-				++stack;
-			case 9:
-				GLOBAL (ModuleCost[TRACKING_SYSTEM]) =
-						5000 / MODULE_COST_SCALE;
-				if (!(GET_GAME_STATE (LANDER_SHIELDS)
-						& (1 << LIGHTNING_DISASTER)))
-				{
-					NPCPhrase (NEW_TECH_10);
-					break;
-				}
-				++stack;
-			case 10:
-				credit = GET_GAME_STATE (LANDER_SHIELDS)
-						| (1 << LIGHTNING_DISASTER);
-				SET_GAME_STATE (LANDER_SHIELDS, credit);
-				if (!(GET_GAME_STATE (LANDER_SHIELDS)
-						& (1 << LAVASPOT_DISASTER)))
-				{
-					NPCPhrase (NEW_TECH_11);
-					break;
-				}
-				++stack;
-			case 11:
-				credit = GET_GAME_STATE (LANDER_SHIELDS)
-						| (1 << LAVASPOT_DISASTER);
-				SET_GAME_STATE (LANDER_SHIELDS, credit);
-				if (GLOBAL (ModuleCost[CANNON_WEAPON]) == 0)
-				{
-					NPCPhrase (NEW_TECH_12);
-					break;
-				}
-				++stack;
-			case 12:
-				GLOBAL (ModuleCost[CANNON_WEAPON]) =
-						6000 / MODULE_COST_SCALE;
-				if (GLOBAL (ModuleCost[SHIVA_FURNACE]) == 0)
-				{
-					NPCPhrase (NEW_TECH_13);
-					break;
-				}
-				++stack;
-			case 13:
-				GLOBAL (ModuleCost[SHIVA_FURNACE]) =
-						4000 / MODULE_COST_SCALE;
-				NPCPhrase (NEW_TECH_ALL_GONE);
-				SET_GAME_STATE (MELNORME_TECH_STACK, stack);
-				goto BuyBuyBuy;
-		}
-		SET_GAME_STATE (MELNORME_TECH_STACK, stack);
 
-		Response (buy_new_tech, DoBuy);
-		Response (no_buy_new_tech, DoBuy);
-	}
-	else if (PLAYER_SAID (R, buy_info)
-			|| PLAYER_SAID (R, buy_current_events)
-			|| PLAYER_SAID (R, buy_alien_races)
-			|| PLAYER_SAID (R, buy_history))
+static void
+PurchaseMenu (RESPONSE_REF R)
+{
+	BYTE slot;
+	DWORD capacity;
+	
+	(void) R; // satisfy compiler
+	capacity = FUEL_RESERVE;
+	
+	if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == CHMMR_EXPLORER_SHIP)
+		capacity = EXPLORER_FUEL_CAPACITY;
+	else
 	{
-		needed_credit = 0;
-		if (PLAYER_SAID (R, buy_info))
-		{
-			if (GET_GAME_STATE (MELNORME_INFO_PROCEDURE))
-				NPCPhrase (OK_BUY_INFO);
-			else
-			{
-				NPCPhrase (BUY_INFO_INTRO);
-				SET_GAME_STATE (MELNORME_INFO_PROCEDURE, 1);
-			}
-		}
-		else
+		slot = NUM_MODULE_SLOTS - 1;
+		
+		do
 		{
-#define INFO_COST 75
-			needed_credit = INFO_COST;
-			if ((int)credit >= (int)needed_credit)
-			{
-				if (PLAYER_SAID (R, buy_current_events))
-					CurrentEvents ();
-				else if (PLAYER_SAID (R, buy_alien_races))
-					AlienRaces ();
-				else /* if (R == buy_history) */
-					History ();
-			}
-
-			DeltaCredit (-needed_credit);
-			if (GET_GAME_STATE (MELNORME_EVENTS_INFO_STACK) < NUM_EVENT_ITEMS
-					 || GET_GAME_STATE (MELNORME_ALIEN_INFO_STACK) < NUM_ALIEN_RACE_ITEMS
-					 || GET_GAME_STATE (MELNORME_HISTORY_INFO_STACK) < NUM_HISTORY_ITEMS)
-			{
-			}
-			else
+			if (GLOBAL_SIS (ModuleSlots[slot]) == FUEL_TANK 
+				|| GLOBAL_SIS (ModuleSlots[slot]) == HIGHEFF_FUELSYS)
 			{
-				NPCPhrase (INFO_ALL_GONE);
-				goto BuyBuyBuy;
+				COUNT volume;
+				volume = GLOBAL_SIS (ModuleSlots[slot]) == FUEL_TANK
+				? FUEL_TANK_CAPACITY : HEFUEL_TANK_CAPACITY;
+				capacity += volume;
 			}
-		}
-
-		if (GET_GAME_STATE (MELNORME_EVENTS_INFO_STACK) < NUM_EVENT_ITEMS)
-			Response (buy_current_events, DoBuy);
-		if (GET_GAME_STATE (MELNORME_ALIEN_INFO_STACK) < NUM_ALIEN_RACE_ITEMS)
-			Response (buy_alien_races, DoBuy);
-		if (GET_GAME_STATE (MELNORME_HISTORY_INFO_STACK) < NUM_HISTORY_ITEMS)
-			Response (buy_history, DoBuy);
-		Response (done_buying_info, DoBuy);
+		} while (slot--);
 	}
-	else
+	if (PLAYER_SAID (R, make_purchases)
+			|| PLAYER_SAID (R, done_buying_info)
+			|| PLAYER_SAID (R, done_buying_fuel))
 	{
-		if (PLAYER_SAID (R, done_buying_fuel))
-			NPCPhrase (OK_DONE_BUYING_FUEL);
-		else if (PLAYER_SAID (R, no_buy_new_tech))
-			NPCPhrase (OK_NO_BUY_NEW_TECH);
-		else if (PLAYER_SAID (R, done_buying_info))
-			NPCPhrase (OK_DONE_BUYING_INFO);
-		else
-			NPCPhrase (WHAT_TO_BUY);
+		NPCPhrase (WHAT_TO_BUY);
+	}
+	
+	if (GET_GAME_STATE (MELNORME_EVENTS_INFO_STACK) < NUM_EVENT_ITEMS ||
+			GET_GAME_STATE (MELNORME_ALIEN_INFO_STACK) < NUM_ALIEN_RACE_ITEMS ||
+			GET_GAME_STATE (MELNORME_HISTORY_INFO_STACK) < NUM_HISTORY_ITEMS)
+	{
+		Response (buy_info, BuyInfoMenu);
+	}
+
+	if (GLOBAL_SIS (FuelOnBoard) < capacity)
+		Response (buy_fuel, BuyFuelMenu);
+	Response (done_buying, TradeMenu);
+}
+
+static void
+SayHelloAndDownToBusiness ()
+{
+	BYTE stack;
 
-BuyBuyBuy:
-		if (GLOBAL_SIS (FuelOnBoard) < capacity)
-			Response (buy_fuel, DoBuy);
-		if (GET_GAME_STATE (MELNORME_TECH_STACK) < NUM_TECH_ITEMS)
-			Response (buy_technology, DoBuy);
-		if (GET_GAME_STATE (MELNORME_ALIEN_INFO_STACK) < NUM_ALIEN_RACE_ITEMS
-				|| GET_GAME_STATE (MELNORME_HISTORY_INFO_STACK) < NUM_HISTORY_ITEMS
-				|| GET_GAME_STATE (MELNORME_EVENTS_INFO_STACK) < NUM_EVENT_ITEMS)
-			Response (buy_info, DoBuy);
-		Response (done_buying, NatureOfConversation);
-		Response (be_leaving_now, ExitConversation);
+	stack = (BYTE)(GET_GAME_STATE (MELNORME_YACK_STACK2));
+	switch (stack++)
+	{
+		case 0:
+			NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS1);
+			break;
+		case 1:
+			NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS2);
+			break;
+		case 2:
+			NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS3);
+			break;
+		case 3:
+			NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS4);
+			break;
+		case 4:
+			NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS5);
+			break;
+		case 5:
+			NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS6);
+			break;
+		case 6:
+			NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS7);
+			break;
+		case 7:
+			NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS8);
+			break;
+		case 8:
+			NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS9);
+			break;
+    case 9:
+			NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS10);
+			break;
 	}
+	stack = stack % 10; // Stack must be range [0,9].
+	SET_GAME_STATE (MELNORME_YACK_STACK2, stack);
+
 }
 
 static void
-DoSell (RESPONSE_REF R)
+SellMenu (RESPONSE_REF R)
 {
 	BYTE num_new_rainbows;
 	UWORD rainbow_mask;
 	SIZE added_credit;
 	int what_to_sell_queued = 0;
-
-	rainbow_mask = MAKE_WORD (
-			GET_GAME_STATE (RAINBOW_WORLD0),
-			GET_GAME_STATE (RAINBOW_WORLD1)
-			);
+	
+	rainbow_mask = MAKE_WORD (GET_GAME_STATE (RAINBOW_WORLD0),GET_GAME_STATE (RAINBOW_WORLD1));
 	num_new_rainbows = (BYTE)(-GET_GAME_STATE (MELNORME_RAINBOW_COUNT));
+	
 	while (rainbow_mask)
 	{
 		if (rainbow_mask & 1)
 			++num_new_rainbows;
-
+		
 		rainbow_mask >>= 1;
 	}
-
-	if (!PLAYER_SAID (R, sell))
+	
+	if (PLAYER_SAID (R, no_deal_shipmarks))
+	{
+		NPCPhrase (OK_NO_DEAL_SHIPMARKS);
+	}
+	else if (!PLAYER_SAID (R, items_to_sell))
 	{
 		if (PLAYER_SAID (R, sell_life_data))
 		{
 			DWORD TimeIn;
-
+			
 			added_credit = GLOBAL_SIS (TotalBioMass) * BIO_CREDIT_VALUE;
-
+			
 			NPCPhrase (SOLD_LIFE_DATA1);
-			NPCNumber (GLOBAL_SIS (TotalBioMass), NULL);
+			NPCPhrase (-(int)GLOBAL_SIS (TotalBioMass));
 			NPCPhrase (SOLD_LIFE_DATA2);
-			NPCNumber (added_credit, NULL);
+			NPCPhrase (-(int)added_credit);
 			NPCPhrase (SOLD_LIFE_DATA3);
+			
+			/*
+			 * if the bio-data easter egg hasn't been activated, 
+			 * check the biounit flags
+			 * -DN 18JAN11
+			 */
+			if (GET_GAME_STATE(MELNORME_ALL_LIFE_TYPE_FOUND) == 0) {
+				update_biounit_flags(); 
+			}
+			
+			/*
+			 * a check for the MELNORME_ALL_LIFE_TYPE_FOUND
+			 * flag after player sells bio-whatnot to the Melnorme. 
+			 *
+			 * DN 27DEC10
+			 *
+			 */
+			if (GET_GAME_STATE(MELNORME_ALL_LIFE_TYPE_FOUND) == 1)
+			{
+				NPCPhrase (ALL_BIO_TYPES_FOUND);
+				SET_GAME_STATE(MELNORME_ALL_LIFE_TYPE_FOUND, 2);
+			}
+			
 			// queue WHAT_TO_SELL before talk-segue
 			if (num_new_rainbows)
 			{
@@ -1194,14 +695,11 @@ DoSell (RESPONSE_REF R)
 				what_to_sell_queued = 1;
 			}
 			AlienTalkSegue (1);
-
+			
 			DrawCargoStrings ((BYTE)~0, (BYTE)~0);
 			SleepThread (ONE_SECOND / 2);
 			TimeIn = GetTimeCounter ();
-			DrawCargoStrings (
-					(BYTE)NUM_ELEMENT_CATEGORIES,
-					(BYTE)NUM_ELEMENT_CATEGORIES
-					);
+			DrawCargoStrings ((BYTE)NUM_ELEMENT_CATEGORIES, (BYTE)NUM_ELEMENT_CATEGORIES);
 			do
 			{
 				TimeIn = GetTimeCounter ();
@@ -1215,613 +713,395 @@ DoSell (RESPONSE_REF R)
 					--GLOBAL_SIS (TotalBioMass);
 					DeltaCredit (BIO_CREDIT_VALUE);
 				}
-				DrawCargoStrings (
-						(BYTE)NUM_ELEMENT_CATEGORIES,
-						(BYTE)NUM_ELEMENT_CATEGORIES
-						);
+				DrawCargoStrings ((BYTE)NUM_ELEMENT_CATEGORIES,(BYTE)NUM_ELEMENT_CATEGORIES);
 			} while (GLOBAL_SIS (TotalBioMass));
 			SleepThread (ONE_SECOND / 2);
-
+			
 			LockMutex (GraphicsLock);
 			ClearSISRect (DRAW_SIS_DISPLAY);
 			UnlockMutex (GraphicsLock);
 		}
+		else if (PLAYER_SAID (R, credits_for_ship_mark_sightings))
+		{
+			added_credit = (50 * BIO_CREDIT_VALUE);
+			NPCPhrase (SHIP_MARK_DEAL);
+			DeltaCredit (added_credit);
+			SET_GAME_STATE(YEHAT_PRECURSOR_ARTIFACT, 3);
+		}
+		else if (PLAYER_SAID (R, info_for_ship_mark_sightings))
+		{
+			NPCPhrase (SHIP_MARK_INFORMATION);
+			switch (GET_GAME_STATE(HINT_WORLD_LOCATION)) {
+				case 0:
+					NPCPhrase (HINT_PLANET_0);
+					break;
+				case 1:
+					NPCPhrase (HINT_PLANET_1);
+					break;
+				case 2:
+					NPCPhrase (HINT_PLANET_2);
+					break;
+				default:
+					break;
+			}
+			NPCPhrase (SHIP_MARK_INFORMATION_2);
+			SET_GAME_STATE(YEHAT_PRECURSOR_ARTIFACT, 3);
+		}
+		else if (PLAYER_SAID (R, sell_tzzrak_tzon_pics))
+		{
+			NPCPhrase (NO_WAY);
+                        SetGameStateByName("TZZRAK_TZON_PICS", 0);
+		}
 		else /* if (R == sell_rainbow_locations) */
 		{
 			added_credit = num_new_rainbows * (250 * BIO_CREDIT_VALUE);
-
+			
 			NPCPhrase (SOLD_RAINBOW_LOCATIONS1);
-			NPCNumber (num_new_rainbows, NULL);
+			NPCPhrase (-(int)num_new_rainbows);
 			NPCPhrase (SOLD_RAINBOW_LOCATIONS2);
-			NPCNumber (added_credit, NULL);
+			NPCPhrase (-(int)added_credit);
 			NPCPhrase (SOLD_RAINBOW_LOCATIONS3);
-
+			
+			// JMS: Player tries to sell the Zeta Sextantis rainbow world location.
+			if ((GET_GAME_STATE (FOUND_KNOWN_RAINBOW_WORLD)) == 1)
+			{
+				NPCPhrase (SOLD_RAINBOW_LOCATIONS_FAIL);
+				added_credit -= 250 * BIO_CREDIT_VALUE;
+				SET_GAME_STATE (FOUND_KNOWN_RAINBOW_WORLD, 2);
+			}
+			
 			num_new_rainbows += GET_GAME_STATE (MELNORME_RAINBOW_COUNT);
 			SET_GAME_STATE (MELNORME_RAINBOW_COUNT, num_new_rainbows);
 			num_new_rainbows = 0;
-
+			
 			DeltaCredit (added_credit);
 		}
-		
-		AskedToBuy = FALSE;
 	}
-
-	if (GLOBAL_SIS (TotalBioMass) || num_new_rainbows)
+	
+	if (GLOBAL_SIS (TotalBioMass) 
+		|| num_new_rainbows
+		|| GET_GAME_STATE(YEHAT_PRECURSOR_ARTIFACT) == 2
+		|| GetGameStateByName("TZZRAK_TZON_PICS") == 1)
 	{
 		if (!what_to_sell_queued)
 			NPCPhrase (WHAT_TO_SELL);
-
+		
 		if (GLOBAL_SIS (TotalBioMass))
-			Response (sell_life_data, DoSell);
+			Response (sell_life_data, SellMenu);
 		if (num_new_rainbows)
-			Response (sell_rainbow_locations, DoSell);
-		Response (done_selling, NatureOfConversation);
+			Response (sell_rainbow_locations, SellMenu);
+		if (GET_GAME_STATE(YEHAT_PRECURSOR_ARTIFACT) == 2)
+			Response (sell_ship_mark_sightings, ShipMarkSightingsMenu);
+		if (GetGameStateByName("TZZRAK_TZON_PICS") == 1)
+			Response (sell_tzzrak_tzon_pics, SellMenu);
+		
+		Response (done_selling, TradeMenu);
+		Response (no_trade_now, ExitConversation);
 	}
 	else
 	{
-		if (PLAYER_SAID (R, sell))
-			NPCPhrase (NOTHING_TO_SELL);
-		DISABLE_PHRASE (sell);
-
-		NatureOfConversation (R);
-	}
-}
-
-static void
-NatureOfConversation (RESPONSE_REF R)
-{
-	BYTE num_new_rainbows;
-	UWORD rainbow_mask;
-	COUNT Credit;
-
-	if (PLAYER_SAID (R, get_on_with_business))
-	{
-		SET_GAME_STATE (MELNORME_YACK_STACK2, 5);
-		R = 0;
-	}
-
-	Credit = DeltaCredit (0);
-	if (R == 0)
-	{
-		BYTE stack;
-
-		stack = (BYTE)(GET_GAME_STATE (MELNORME_YACK_STACK2) - 5);
-		switch (stack++)
-		{
-			case 0:
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_1);
-				break;
-			case 1:
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_2);
-				break;
-			case 2:
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_3);
-				break;
-			case 3:
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_4);
-				break;
-			case 4:
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_5);
-				break;
-			case 5:
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_6);
-				break;
-			case 6:
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_7);
-				break;
-			case 7:
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_8);
-				break;
-			case 8:
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_9);
-				break;
-			default:
-				--stack;
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_10);
-				break;
-		}
-		SET_GAME_STATE (MELNORME_YACK_STACK2, stack + 5);
-	}
-
-	rainbow_mask = MAKE_WORD (
-			GET_GAME_STATE (RAINBOW_WORLD0),
-			GET_GAME_STATE (RAINBOW_WORLD1)
-			);
-	num_new_rainbows = (BYTE)(-GET_GAME_STATE (MELNORME_RAINBOW_COUNT));
-	while (rainbow_mask)
-	{
-		if (rainbow_mask & 1)
-			++num_new_rainbows;
-
-		rainbow_mask >>= 1;
-	}
-
-	if (GLOBAL_SIS (FuelOnBoard) > 0
-			|| GLOBAL_SIS (TotalBioMass)
-			|| Credit
-			|| num_new_rainbows)
-	{
-		if (!GET_GAME_STATE (TRADED_WITH_MELNORME))
-		{
-			SET_GAME_STATE (TRADED_WITH_MELNORME, 1);
-
-			NPCPhrase (TRADING_INFO);
-		}
-
-		if (R == 0)
-		{
-				/* Melnorme reports any news and turns purple */
-			NPCPhrase (BUY_OR_SELL);
-			AlienTalkSegue(1);
-			XFormColorMap (GetColorMapAddress (
-					SetAbsColorMapIndex (CommData.AlienColorMap, 1)
-					), ONE_SECOND / 2);
-			AlienTalkSegue((COUNT)~0);
-		}
-		else if (PLAYER_SAID (R, why_turned_purple))
-		{
-			SET_GAME_STATE (WHY_MELNORME_PURPLE, 1);
-
-			NPCPhrase (TURNED_PURPLE_BECAUSE);
-		}
-		else if (PLAYER_SAID (R, done_selling))
-		{
-			NPCPhrase (OK_DONE_SELLING);
-		}
-		else if (PLAYER_SAID (R, done_buying))
-		{
-			NPCPhrase (OK_DONE_BUYING);
-		}
-
-		if (!GET_GAME_STATE (WHY_MELNORME_PURPLE))
-		{
-			Response (why_turned_purple, NatureOfConversation);
-		}
-		if (!AskedToBuy)
-			Response (buy, DoBuy);
-		if (PHRASE_ENABLED (sell))
-			Response (sell, DoSell);
-		Response (goodbye, ExitConversation);
-	}
-	else /* needs to be rescued */
-	{
-		if (GET_GAME_STATE (MELNORME_RESCUE_REFUSED))
+		if (PLAYER_SAID (R, items_to_sell))
 		{
-			NPCPhrase (CHANGED_MIND);
-
-			Response (yes_changed_mind, DoRescue);
-			Response (no_changed_mind, ExitConversation);
+			NPCPhrase (NOTHING_TO_SELL);
+			DISABLE_PHRASE (items_to_sell);
+			TradeMenu (dummy);
 		}
 		else
 		{
-			BYTE num_rescues;
-
-			num_rescues = GET_GAME_STATE (MELNORME_RESCUE_COUNT);
-			switch (num_rescues)
-			{
-				case 0:
-					NPCPhrase (RESCUE_EXPLANATION);
-					break;
-				case 1:
-					NPCPhrase (RESCUE_AGAIN_1);
-					break;
-				case 2:
-					NPCPhrase (RESCUE_AGAIN_2);
-					break;
-				case 3:
-					NPCPhrase (RESCUE_AGAIN_3);
-					break;
-				case 4:
-					NPCPhrase (RESCUE_AGAIN_4);
-					break;
-				case 5:
-					NPCPhrase (RESCUE_AGAIN_5);
-					break;
-			 }
-
-			if (num_rescues < 5)
-			{
-				++num_rescues;
-				SET_GAME_STATE (MELNORME_RESCUE_COUNT, num_rescues);
-			}
-
-			NPCPhrase (SHOULD_WE_HELP_YOU);
-
-			Response (yes_help, DoRescue);
-			Response (no_help, ExitConversation);
+			Response (done_selling, TradeMenu);
+			Response (no_trade_now, ExitConversation);
 		}
 	}
 }
 
-static BYTE local_stack0, local_stack1;
+static COUNT rescue_fuel;
+static SIS_STATE SIS_copy;
 
-static void
-DoBluster (RESPONSE_REF R)
+BOOLEAN
+StripExplorer (COUNT fuel_required)
 {
-	if (PLAYER_SAID (R, trade_is_for_the_weak))
-	{
-		XFormColorMap (GetColorMapAddress (
-				SetAbsColorMapIndex (CommData.AlienColorMap, 2)
-				), ONE_SECOND / 2);
-
-		SET_GAME_STATE (MELNORME_YACK_STACK2, 4);
-		NPCPhrase (WERE_NOT_AFRAID);
-	}
-	else if (PLAYER_SAID (R, why_blue_light))
-	{
-		SET_GAME_STATE (WHY_MELNORME_BLUE, 1);
+	COUNT worth, total, num_landers_sold;
+	BYTE i, which_module;
+	DWORD capacity;
 
-		NPCPhrase (BLUE_IS_MAD);
-	}
-	else if (PLAYER_SAID (R, we_strong_1))
-	{
-		local_stack0 = 1;
-		NPCPhrase (YOU_NOT_STRONG_1);
-	}
-	else if (PLAYER_SAID (R, we_strong_2))
-	{
-		local_stack0 = 2;
-		NPCPhrase (YOU_NOT_STRONG_2);
-	}
-	else if (PLAYER_SAID (R, we_strong_3))
+	if (fuel_required == 0)
 	{
-		local_stack0 = 3;
-		NPCPhrase (YOU_NOT_STRONG_3);
+		/* Player has agreed to rescue offer. */
+		GlobData.SIS_state = SIS_copy;
+		LockMutex (GraphicsLock);
+		DeltaSISGauges (UNDEFINED_DELTA, rescue_fuel, UNDEFINED_DELTA);
+		UnlockMutex (GraphicsLock);
+		return TRUE;
 	}
-	else if (PLAYER_SAID (R, just_testing))
-	{
-		local_stack1 = 1;
-		NPCPhrase (REALLY_TESTING);
+
+	assert (fuel_required > 0);
+	
+	/* Offer to trade planet landers for fuel. */
+	SIS_copy = GlobData.SIS_state;
+
+	/* The only thing of value which we can strip from the Explorer is
+	the landers (or perhaps escorts). */
+	capacity = EXPLORER_FUEL_CAPACITY;
+	worth = fuel_required / FUEL_TANK_SCALE;
+	total = 0;
+	num_landers_sold = 0;
+
+	for (i = 0; i < NUM_MODULE_SLOTS && SIS_copy.NumLanders > 0 && total < worth; ++i)
+	{
+		which_module = SIS_copy.ModuleSlots[i];
+		if (which_module != PLANET_LANDER)
+			continue;
+		total += GLOBAL (ModuleCost[which_module]);
+		SIS_copy.NumLanders--;
+		++num_landers_sold;
 	}
 
-	if (!GET_GAME_STATE (WHY_MELNORME_BLUE))
-		Response (why_blue_light, DoBluster);
-	switch (local_stack0)
+	if (total == 0)
 	{
-		case 0:
-			Response (we_strong_1, DoBluster);
-			break;
-		case 1:
-			Response (we_strong_2, DoBluster);
-			break;
-		case 2:
-			Response (we_strong_3, DoBluster);
-			break;
+		/* Player has nothing of value, just give them fuel. */
+		NPCPhrase (CHARITY);
+		LockMutex (GraphicsLock);
+		DeltaSISGauges (0, fuel_required, 0);
+		UnlockMutex (GraphicsLock);
+		return (FALSE);
 	}
-	switch (local_stack1)
+	else
 	{
-		case 0:
-			Response (just_testing, DoBluster);
-			break;
-		case 1:
-		{
-			Response (yes_really_testing, DoFirstMeeting);
-			break;
-		}
+		/* Offer to sell them fuel for landers. */
+		NPCPhrase (RESCUE_OFFER);
+		rescue_fuel = fuel_required;
+		if (rescue_fuel == capacity)
+			NPCPhrase (RESCUE_TANKS);
+		else
+			NPCPhrase (RESCUE_HOME);
+
+		NPCPhrase (ENUMERATE_ONE + num_landers_sold - 1);
+		NPCPhrase (LANDERS);
 	}
-	Response (youre_on, ExitConversation);
+
+	return (TRUE);
 }
 
 static void
-yack0_respond (void)
+DoRescue ()
 {
+	SIZE dx, dy;
+	COUNT fuel_required;
+	BOOLEAN s = FALSE;
 
-	switch (GET_GAME_STATE (MELNORME_YACK_STACK0))
-	{
-		case 0:
-		{
-			UNICODE buf[ALLIANCE_NAME_BUFSIZE];
+	dx = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x))
+			- SOL_X;
+	dy = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y))
+			- SOL_Y;
+	fuel_required = square_root (
+			(DWORD)((long)dx * dx + (long)dy * dy)
+			) + (2 * FUEL_TANK_SCALE);
 
-			GetAllianceName (buf, name_1);
-			construct_response (
-					shared_phrase_buf,
-					we_are_from_alliance0,
-					buf,
-					(RESPONSE_REF)-1);
-			DoResponsePhrase (we_are_from_alliance0, DoFirstMeeting, shared_phrase_buf);
+	switch (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS)) {
+		case CHMMR_EXPLORER_SHIP:
+			s = StripExplorer(fuel_required);
 			break;
-		}
-		case 1:
-			Response (how_know, DoFirstMeeting);
+		case PRECURSOR_BATTLESHIP:
+			/* TODO: implement... */
 			break;
 	}
-}
 
-static void
-yack1_respond (void)
-{
-	switch (GET_GAME_STATE (MELNORME_YACK_STACK1))
+	if (s)
 	{
-		case 0:
-			Response (what_about_yourselves, DoFirstMeeting);
-			break;
-		case 1:
-			Response (what_factors, DoFirstMeeting);
-		case 2:
-			Response (get_on_with_business, NatureOfConversation);
-			break;
+		Response (take_it, ExitConversation);
+		Response (leave_it, ExitConversation);
 	}
+
 }
 
 static void
-yack2_respond (void)
+TurnBridgePurple ()
 {
-	switch (GET_GAME_STATE (MELNORME_YACK_STACK2))
-	{
-		case 0:
-			Response (what_about_universe, DoFirstMeeting);
-			break;
-		case 1:
-			Response (giving_is_good_1, DoFirstMeeting);
-			break;
-		case 2:
-			Response (giving_is_good_2, DoFirstMeeting);
-			break;
-		case 3:
-			Response (trade_is_for_the_weak, DoBluster);
-			break;
-	}
+	AlienTalkSegue((COUNT)~0);
+	XFormColorMap (GetColorMapAddress (SetAbsColorMapIndex (CommData.AlienColorMap, 1)), ONE_SECOND / 2);
+	AlienTalkSegue((COUNT)~0);
 }
 
 static void
-DoFirstMeeting (RESPONSE_REF R)
+DiscussRescue ()
 {
-	BYTE last_stack = 0;
-	PVOIDFUNC temp_func, stack_func[] =
+	if (GET_GAME_STATE (MELNORME_RESCUE_REFUSED))
 	{
-		yack0_respond,
-		yack1_respond,
-		yack2_respond,
-	};
+		NPCPhrase (CHANGED_MIND);
 
-	if (R == 0)
+		Response (yes_changed_mind, DoRescue);
+		Response (no_changed_mind, ExitConversation);
+	}
+	else
 	{
-		BYTE business_count;
+		BYTE num_rescues;
 
-		business_count = GET_GAME_STATE (MELNORME_BUSINESS_COUNT);
-		switch (business_count++)
+		num_rescues = GET_GAME_STATE (MELNORME_RESCUE_COUNT);
+		switch (num_rescues)
 		{
 			case 0:
-				NPCPhrase (HELLO_NOW_DOWN_TO_BUSINESS_1);
+				NPCPhrase (RESCUE_EXPLANATION);
 				break;
 			case 1:
-				NPCPhrase (HELLO_NOW_DOWN_TO_BUSINESS_2);
+				NPCPhrase (RESCUE_AGAIN_1);
 				break;
 			case 2:
-				NPCPhrase (HELLO_NOW_DOWN_TO_BUSINESS_3);
-				--business_count;
+				NPCPhrase (RESCUE_AGAIN_2);
+				break;
+			case 3:
+				NPCPhrase (RESCUE_AGAIN_3);
+				break;
+			case 4:
+				NPCPhrase (RESCUE_AGAIN_4);
+				break;
+			case 5:
+				NPCPhrase (RESCUE_AGAIN_5);
 				break;
+			}
+
+		if (num_rescues < 5)
+		{
+			++num_rescues;
+			SET_GAME_STATE (MELNORME_RESCUE_COUNT, num_rescues);
 		}
-		SET_GAME_STATE (MELNORME_BUSINESS_COUNT, business_count);
-	}
-	else if (PLAYER_SAID (R, we_are_from_alliance0))
-	{
-		SET_GAME_STATE (MELNORME_YACK_STACK0, 1);
-		NPCPhrase (KNOW_OF_YOU);
-	}
-	else if (PLAYER_SAID (R, how_know))
-	{
-		SET_GAME_STATE (MELNORME_YACK_STACK0, 2);
-		NPCPhrase (KNOW_BECAUSE);
-	}
-	else if (PLAYER_SAID (R, what_about_yourselves))
-	{
-		last_stack = 1;
-		SET_GAME_STATE (MELNORME_YACK_STACK1, 1);
-		NPCPhrase (NO_TALK_ABOUT_OURSELVES);
-	}
-	else if (PLAYER_SAID (R, what_factors))
-	{
-		last_stack = 1;
-		SET_GAME_STATE (MELNORME_YACK_STACK1, 2);
-		NPCPhrase (FACTORS_ARE);
-	}
-	else if (PLAYER_SAID (R, what_about_universe))
-	{
-		last_stack = 2;
-		SET_GAME_STATE (MELNORME_YACK_STACK2, 1);
-		NPCPhrase (NO_FREE_LUNCH);
-	}
-	else if (PLAYER_SAID (R, giving_is_good_1))
-	{
-		last_stack = 2;
-		SET_GAME_STATE (MELNORME_YACK_STACK2, 2);
-		NPCPhrase (GIVING_IS_BAD_1);
-	}
-	else if (PLAYER_SAID (R, giving_is_good_2))
-	{
-		last_stack = 2;
-		SET_GAME_STATE (MELNORME_YACK_STACK2, 3);
-		NPCPhrase (GIVING_IS_BAD_2);
-	}
-	else if (PLAYER_SAID (R, yes_really_testing))
-	{
-		XFormColorMap (GetColorMapAddress (
-				SetAbsColorMapIndex (CommData.AlienColorMap, 0)
-				), ONE_SECOND / 2);
 
-		NPCPhrase (TEST_RESULTS);
+		NPCPhrase (SHOULD_WE_HELP_YOU);
+
+		TurnBridgePurple ();
+
+		Response (yes_help, DoRescue);
+		Response (no_help, ExitConversation);
 	}
-	else if (PLAYER_SAID (R, we_apologize))
+
+}
+
+static BOOLEAN
+PlayerNeedsRescue ()
+{
+	BYTE num_new_rainbows;
+	UWORD rainbow_mask;
+	COUNT Credit = DeltaCredit (0);
+
+	rainbow_mask = MAKE_WORD (
+			GET_GAME_STATE (RAINBOW_WORLD0),
+			GET_GAME_STATE (RAINBOW_WORLD1)
+			);
+	num_new_rainbows = (BYTE)(-GET_GAME_STATE (MELNORME_RAINBOW_COUNT));
+
+	while (rainbow_mask)
 	{
-		SET_GAME_STATE (MELNORME_ANGER, 0);
-		XFormColorMap (GetColorMapAddress (
-				SetAbsColorMapIndex (CommData.AlienColorMap, 0)
-				), ONE_SECOND / 2);
+		if (rainbow_mask & 1)
+			++num_new_rainbows;
 
-		NPCPhrase (APOLOGY_ACCEPTED);
+		rainbow_mask >>= 1;
 	}
 
-	temp_func = stack_func[0];
-	stack_func[0] = stack_func[last_stack];
-	stack_func[last_stack] = temp_func;
-	(*stack_func[0]) ();
-	(*stack_func[1]) ();
-	(*stack_func[2]) ();
-	Response (no_trade_now, ExitConversation);
+	return GLOBAL_SIS (FuelOnBoard) == 0
+		  && GLOBAL_SIS (TotalBioMass) == 0
+			&& Credit == 0
+			&& num_new_rainbows == 0;
 }
 
 static void
-DoMelnormeMiffed (RESPONSE_REF R)
+TradeMenu (RESPONSE_REF R)
 {
-	if (R == 0)
+	if (PlayerNeedsRescue())
 	{
-		BYTE miffed_count;
-
-		miffed_count = GET_GAME_STATE (MELNORME_MIFFED_COUNT);
-		switch (miffed_count++)
-		{
-			case 0:
-				NPCPhrase (HELLO_SLIGHTLY_ANGRY_1);
-				break;
-			case 1:
-				NPCPhrase (HELLO_SLIGHTLY_ANGRY_2);
-				break;
-			default:
-				--miffed_count;
-				NPCPhrase (HELLO_SLIGHTLY_ANGRY_3);
-				break;
-		}
-		SET_GAME_STATE (MELNORME_MIFFED_COUNT, miffed_count);
+		/* Player needs to be rescued... */
+		DiscussRescue();
+		return;
+	}
 
-		XFormColorMap (GetColorMapAddress (
-				SetAbsColorMapIndex (CommData.AlienColorMap, 2)
-				), ONE_SECOND / 2);
+	if (PLAYER_SAID (R, done_selling))
+	{
+		NPCPhrase (OK_DONE_SELLING);
 	}
-	else if (PLAYER_SAID (R, explore_relationship))
+	else if (PLAYER_SAID (R, done_buying))
 	{
-		SET_GAME_STATE (MELNORME_YACK_STACK3, 1);
-
-		NPCPhrase (EXAMPLE_OF_RELATIONSHIP);
+		NPCPhrase (OK_DONE_BUYING);
 	}
-	else if (PLAYER_SAID (R, excuse_1))
+	else if (PLAYER_SAID (R, only_joke))
 	{
-		SET_GAME_STATE (MELNORME_YACK_STACK3, 2);
-
-		NPCPhrase (NO_EXCUSE_1);
+		NPCPhrase (TRADING_INFO2);
+		NPCPhrase (MORE_TRADING_INFO);
+		NPCPhrase (BUY_OR_SELL);
+		TurnBridgePurple ();
 	}
-	else if (PLAYER_SAID (R, excuse_2))
+	else if (PLAYER_SAID (R, i_remember))
 	{
-		SET_GAME_STATE (MELNORME_YACK_STACK3, 3);
-
-		NPCPhrase (NO_EXCUSE_2);
+		NPCPhrase (RIGHT_YOU_ARE);
+		NPCPhrase (BUY_OR_SELL);
+		TurnBridgePurple ();
 	}
-	else if (PLAYER_SAID (R, excuse_3))
+	else if (PLAYER_SAID (R, how_to_trade))
 	{
-		SET_GAME_STATE (MELNORME_YACK_STACK3, 4);
-
-		NPCPhrase (NO_EXCUSE_3);
+		NPCPhrase (TRADING_INFO1);
+		NPCPhrase (MORE_TRADING_INFO);
+		NPCPhrase (BUY_OR_SELL);
+		TurnBridgePurple ();
 	}
-
-	switch (GET_GAME_STATE (MELNORME_YACK_STACK3))
+	else if (GET_GAME_STATE (MET_MELNORME) == 1 && !(PLAYER_SAID (R, dummy)))
 	{
-		case 0:
-			Response (explore_relationship, DoMelnormeMiffed);
-			break;
-		case 1:
-			Response (excuse_1, DoMelnormeMiffed);
-			break;
-		case 2:
-			Response (excuse_2, DoMelnormeMiffed);
-			break;
-		case 3:
-			Response (excuse_3, DoMelnormeMiffed);
-			break;
+		SayHelloAndDownToBusiness();
+		NPCPhrase (BUY_OR_SELL);
+		TurnBridgePurple ();
 	}
-	Response (we_apologize, DoFirstMeeting);
-	Response (so_we_can_attack, ExitConversation);
-	Response (bye_melnorme_slightly_angry, ExitConversation);
+	Response (make_purchases, PurchaseMenu);
+	if (PHRASE_ENABLED(items_to_sell))
+		Response (items_to_sell, SellMenu);
+	Response (no_trade_now, ExitConversation);
 }
 
 static void
-DoMelnormePissed (RESPONSE_REF R)
+Threaten (RESPONSE_REF R)
 {
-	if (R == 0)
+	if (PLAYER_SAID (R, spank_ass1))
 	{
-		BYTE pissed_count;
-
-		pissed_count = GET_GAME_STATE (MELNORME_PISSED_COUNT);
-		switch (pissed_count++)
-		{
-			case 0:
-				NPCPhrase (HELLO_PISSED_OFF_1);
-				break;
-			case 1:
-				NPCPhrase (HELLO_PISSED_OFF_2);
-				break;
-			default:
-				--pissed_count;
-				NPCPhrase (HELLO_PISSED_OFF_3);
-				break;
-		}
-		SET_GAME_STATE (MELNORME_PISSED_COUNT, pissed_count);
-
-		XFormColorMap (GetColorMapAddress (
-				SetAbsColorMapIndex (CommData.AlienColorMap, 2)
-				), ONE_SECOND / 2);
+		NPCPhrase (UNWISE_CAPTAIN);
 	}
-	else if (PLAYER_SAID (R, beg_forgiveness))
-	{
-		SET_GAME_STATE (MELNORME_YACK_STACK4, 1);
+		
+	Response (spank_ass2, ExitConversation);
+	Response (only_joke, TradeMenu);
+	
+}
 
-		NPCPhrase (LOTS_TO_MAKE_UP_FOR);
+static void
+HowAreYou (RESPONSE_REF R)
+{
+	if (PLAYER_SAID (R, hi_doing_great))
+	{
+		NPCPhrase (DOING_GOOD_RESPONSE);
+		NPCPhrase (WANT_TO_TRADE);
 	}
-	else if (PLAYER_SAID (R, you_are_so_right))
+	else if (PLAYER_SAID (R, doing_average))
 	{
-		SET_GAME_STATE (MELNORME_YACK_STACK4, 2);
-
-		NPCPhrase (ONE_LAST_CHANCE);
+		NPCPhrase (DOING_AVERAGE_RESPONSE);
+		NPCPhrase (WANT_TO_TRADE);
 	}
-
-	switch (GET_GAME_STATE (MELNORME_YACK_STACK4))
+	else if (PLAYER_SAID (R, not_good))
 	{
-		case 0:
-			Response (beg_forgiveness, DoMelnormePissed);
-			break;
-		case 1:
-			Response (you_are_so_right, DoMelnormePissed);
-			break;
-		case 2:
-			Response (ok_strip_me, ExitConversation);
-			break;
+		NPCPhrase (NOT_GOOD_RESPONSE);
+		NPCPhrase (WANT_TO_TRADE);
 	}
-	Response (fight_some_more, ExitConversation);
-	Response (bye_melnorme_pissed_off, ExitConversation);
+
+	Response (how_to_trade, TradeMenu);
+	Response (i_remember, TradeMenu);
+	Response (spank_ass1, Threaten);
 }
 
 static void
-DoMelnormeHate (RESPONSE_REF R)
+DoFirstMeeting (RESPONSE_REF R)
 {
-	BYTE hate_count;
+	(void) R; // satisfy compiler
+	NPCPhrase (HELLO_NOW_DOWN_TO_BUSINESS1);
 
-	(void) R;  // ignored
-	hate_count = GET_GAME_STATE (MELNORME_HATE_COUNT);
-	switch (hate_count++)
-	{
-		case 0:
-			NPCPhrase (HELLO_HATE_YOU_1);
-			break;
-		case 1:
-			NPCPhrase (HELLO_HATE_YOU_2);
-			break;
-		default:
-			--hate_count;
-			NPCPhrase (HELLO_HATE_YOU_3);
-			break;
-	}
-	SET_GAME_STATE (MELNORME_HATE_COUNT, hate_count);
-
-	XFormColorMap (GetColorMapAddress (
-			SetAbsColorMapIndex (CommData.AlienColorMap, 2)
-			), ONE_SECOND / 2);
-
-	Response (well_if_thats_the_way_you_feel, ExitConversation);
-	Response (you_hate_us_so_we_go_away, ExitConversation);
+	Response (hi_doing_great, HowAreYou);
+	Response (doing_average, HowAreYou);
+	Response (not_good, HowAreYou);
 }
 
 static void
-Intro (void)
-{
+Intro (void) {
 	prevMsgMode = SetStatusMessageMode (SMM_CREDITS);
 
 	if (GET_GAME_STATE (MET_MELNORME) == 0)
@@ -1831,24 +1111,7 @@ Intro (void)
 	}
 	else
 	{
-		switch (GET_GAME_STATE (MELNORME_ANGER))
-		{
-			case 0:
-				if (GET_GAME_STATE (MELNORME_YACK_STACK2) <= 5)
-					DoFirstMeeting (0);
-				else
-					NatureOfConversation (0);
-				break;
-			case 1:
-				DoMelnormeMiffed (0);
-				break;
-			case 2:
-				DoMelnormePissed (0);
-				break;
-			default:
-				DoMelnormeHate (0);
-				break;
-		}
+		TradeMenu(0);
 	}
 }
 
@@ -1881,13 +1144,11 @@ init_melnorme_comm (void)
 	melnorme_desc.AlienTextBaseline.y = 0;
 	melnorme_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
 
-	local_stack0 = 0;
-	local_stack1 = 0;
-
 	prevMsgMode = SMM_UNDEFINED;
 
 	SET_GAME_STATE (BATTLE_SEGUE, 0);
-	AskedToBuy = FALSE;
+	//TODO ressurect?
+	//AskedToBuy = FALSE;
 	retval = &melnorme_desc;
 
 	return (retval);
diff -ruNp src.orig/uqm/comm/melnorm/strings.h src/uqm/comm/melnorm/strings.h
--- src.orig/uqm/comm/melnorm/strings.h	2017-11-01 15:30:23 -0700
+++ src/uqm/comm/melnorm/strings.h	2017-11-01 15:31:01 -0700
@@ -22,62 +22,91 @@
 enum
 {
 	NULL_PHRASE,
-	HELLO_NOW_DOWN_TO_BUSINESS_1,
-	HELLO_NOW_DOWN_TO_BUSINESS_2,
-	HELLO_NOW_DOWN_TO_BUSINESS_3,
-	KNOW_OF_YOU,
-	how_know,
-	KNOW_BECAUSE,
-	what_about_yourselves,
-	NO_TALK_ABOUT_OURSELVES,
-	what_factors,
-	FACTORS_ARE,
-	what_about_universe,
-	NO_FREE_LUNCH,
-	giving_is_good_1,
-	GIVING_IS_BAD_1,
-	giving_is_good_2,
-	GIVING_IS_BAD_2,
+	dummy,
+	ENUMERATE_ONE,
+	ENUMERATE_TWO,
+	ENUMERATE_THREE,
+	ENUMERATE_FOUR,
+	ENUMERATE_FIVE,
+	ENUMERATE_SIX,
+	ENUMERATE_SEVEN,
+	ENUMERATE_EIGHT,
+	ENUMERATE_NINE,
+	ENUMERATE_TEN,
+	ENUMERATE_ELEVEN,
+	ENUMERATE_TWELVE,
+	ENUMERATE_THIRTEEN,
+	ENUMERATE_FOURTEEN,
+	ENUMERATE_FIFTEEN,
+	ENUMERATE_SIXTEEN,
+	END_LIST_WITH_AND,
+	ENUMERATE_ZERO,
+	ENUMERATE_SEVENTEEN,
+	ENUMERATE_EIGHTEEN,
+	ENUMERATE_NINETEEN,
+	ENUMERATE_TWENTY,
+	ENUMERATE_THIRTY,
+	ENUMERATE_FOURTY,
+	ENUMERATE_FIFTY,
+	ENUMERATE_SIXTY,
+	ENUMERATE_SEVENTY,
+	ENUMERATE_EIGHTY,
+	ENUMERATE_NINETY,
+	ENUMERATE_HUNDRED,
+	ENUMERATE_THOUSAND,
+	HELLO_NOW_DOWN_TO_BUSINESS1,
+	hi_doing_great,
+	DOING_GOOD_RESPONSE,
+	doing_average,
+	DOING_AVERAGE_RESPONSE,
+	not_good,
+	NOT_GOOD_RESPONSE,
+	WANT_TO_TRADE,
+	how_to_trade,
+	TRADING_INFO1,
+	MORE_TRADING_INFO,
+	i_remember,
+	RIGHT_YOU_ARE,
+	make_purchases,
+	items_to_sell,
+	spank_ass1,
+	spank_ass2,
+	UNWISE_CAPTAIN,
+	only_joke,
+	TRADING_INFO2,
+	BATTLE_MELNORME,
+	HELLO_NOW_DOWN_TO_BUSINESS2,
+	HELLO_NOW_DOWN_TO_BUSINESS3,
 	get_on_with_business,
-	trade_is_for_the_weak,
-	WERE_NOT_AFRAID,
 	no_trade_now,
 	OK_NO_TRADE_NOW_BYE,
-	HELLO_AND_DOWN_TO_BUSINESS_1,
-	HELLO_AND_DOWN_TO_BUSINESS_2,
-	HELLO_AND_DOWN_TO_BUSINESS_3,
-	HELLO_AND_DOWN_TO_BUSINESS_4,
-	HELLO_AND_DOWN_TO_BUSINESS_5,
-	HELLO_AND_DOWN_TO_BUSINESS_6,
-	HELLO_AND_DOWN_TO_BUSINESS_7,
-	HELLO_AND_DOWN_TO_BUSINESS_8,
-	HELLO_AND_DOWN_TO_BUSINESS_9,
-	HELLO_AND_DOWN_TO_BUSINESS_10,
+	sell_ship_mark_sightings,
+	OFFER_CREDITS_FOR_SHIPMARK_INFO,
+	deal_shipmarks,
+	no_deal_shipmarks,
+	OK_NO_DEAL_SHIPMARKS,
+	ALTERNATIVE_REWARD_FOR_SHIPMARK_INFO,
+	credits_for_ship_mark_sightings,
+	info_for_ship_mark_sightings,
+	SHIP_MARK_DEAL,
+	SHIP_MARK_INFORMATION,
+	HINT_PLANET_0,
+	HINT_PLANET_1,
+	HINT_PLANET_2,
+	SHIP_MARK_INFORMATION_2,
+	sell_tzzrak_tzon_pics,
+	NO_WAY,
+	HELLO_AND_DOWN_TO_BUSINESS1,
+	HELLO_AND_DOWN_TO_BUSINESS2,
+	HELLO_AND_DOWN_TO_BUSINESS3,
+	HELLO_AND_DOWN_TO_BUSINESS4,
+	HELLO_AND_DOWN_TO_BUSINESS5,
+	HELLO_AND_DOWN_TO_BUSINESS6,
+	HELLO_AND_DOWN_TO_BUSINESS7,
+	HELLO_AND_DOWN_TO_BUSINESS8,
+	HELLO_AND_DOWN_TO_BUSINESS9,
+	HELLO_AND_DOWN_TO_BUSINESS10,
 	whats_my_credit,
-	HELLO_SLIGHTLY_ANGRY_1,
-	HELLO_SLIGHTLY_ANGRY_2,
-	HELLO_SLIGHTLY_ANGRY_3,
-	explore_relationship,
-	EXAMPLE_OF_RELATIONSHIP,
-	excuse_1,
-	NO_EXCUSE_1,
-	excuse_2,
-	NO_EXCUSE_2,
-	excuse_3,
-	NO_EXCUSE_3,
-	we_apologize,
-	APOLOGY_ACCEPTED,
-	so_we_can_attack,
-	DECEITFUL_HUMAN,
-	bye_melnorme_slightly_angry,
-	MELNORME_SLIGHTLY_ANGRY_GOODBYE,
-	HELLO_HATE_YOU_1,
-	HELLO_HATE_YOU_2,
-	HELLO_HATE_YOU_3,
-	well_if_thats_the_way_you_feel,
-	you_hate_us_so_we_go_away,
-	HATE_YOU_GOODBYE,
-	WE_FIGHT_AGAIN,
 	RESCUE_EXPLANATION,
 	RESCUE_AGAIN_1,
 	RESCUE_AGAIN_2,
@@ -99,41 +128,9 @@ enum
 	MAYBE_SEE_YOU_LATER,
 	GOODBYE_AND_GOODLUCK,
 	GOODBYE_AND_GOODLUCK_AGAIN,
-	HELLO_PISSED_OFF_1,
-	HELLO_PISSED_OFF_2,
-	HELLO_PISSED_OFF_3,
-	beg_forgiveness,
-	LOTS_TO_MAKE_UP_FOR,
-	you_are_so_right,
-	ONE_LAST_CHANCE,
-	ok_strip_me,
-	no_strip_now,
-	NOT_WORTH_STRIPPING,
-	FAIR_JUSTICE,
-	bye_melnorme_pissed_off,
-	MELNORME_PISSED_OFF_GOODBYE,
-	fight_some_more,
-	OK_FIGHT_SOME_MORE,
-	why_blue_light,
-	BLUE_IS_MAD,
-	we_strong_1,
-	YOU_NOT_STRONG_1,
-	we_strong_2,
-	YOU_NOT_STRONG_2,
-	we_strong_3,
-	YOU_NOT_STRONG_3,
-	just_testing,
-	REALLY_TESTING,
-	yes_really_testing,
-	TEST_RESULTS,
-	youre_on,
-	YOU_GIVE_US_NO_CHOICE,
-	TRADING_INFO,
 	BUY_OR_SELL,
 	goodbye,
 	why_turned_purple,
-	buy,
-	sell,
 	TURNED_PURPLE_BECAUSE,
 	NOTHING_TO_SELL,
 	WHAT_TO_SELL,
@@ -146,6 +143,7 @@ enum
 	SOLD_RAINBOW_LOCATIONS1,
 	SOLD_RAINBOW_LOCATIONS2,
 	SOLD_RAINBOW_LOCATIONS3,
+	SOLD_RAINBOW_LOCATIONS_FAIL,
 	sell_precursor_find,
 	SOLD_PRECURSOR_FIND,
 	changed_mind_no_sell,
@@ -220,41 +218,10 @@ enum
 	no_buy_new_tech,
 	done_buying_new_tech,
 	fill_me_up,
-	OK_FILL_YOU_UP,
-	BUY_NEW_TECH_INTRO,
-	OK_BUY_NEW_TECH,
-	OK_NO_BUY_NEW_TECH,
-	OK_DONE_BUYING_NEW_TECH,
+	AT_MAXIMUM_CAPACITY,
 	OK_DONE_BUYING_FUEL,
-	NEW_TECH_1,
-	NEW_TECH_2,
-	NEW_TECH_3,
-	NEW_TECH_4,
-	NEW_TECH_5,
-	NEW_TECH_6,
-	NEW_TECH_7,
-	NEW_TECH_8,
-	NEW_TECH_9,
-	NEW_TECH_10,
-	NEW_TECH_11,
-	NEW_TECH_12,
-	NEW_TECH_13,
-	OK_BUY_NEW_TECH_1,
-	OK_BUY_NEW_TECH_2,
-	OK_BUY_NEW_TECH_3,
-	OK_BUY_NEW_TECH_4,
-	OK_BUY_NEW_TECH_5,
-	OK_BUY_NEW_TECH_6,
-	OK_BUY_NEW_TECH_7,
-	OK_BUY_NEW_TECH_8,
-	OK_BUY_NEW_TECH_9,
-	OK_BUY_NEW_TECH_10,
-	OK_BUY_NEW_TECH_11,
-	OK_BUY_NEW_TECH_12,
-	OK_BUY_NEW_TECH_13,
 	CHARITY,
-	NEW_TECH_ALL_GONE,
-	we_are_from_alliance0,
+	ALL_BIO_TYPES_FOUND,
 	STRIP_HEAD,
 	LANDERS,
 	THRUSTERS,
@@ -268,42 +235,6 @@ enum
 	CANNONS,
 	TRACKERS,
 	DEFENSES,
-	name_1,
-	name_2,
-	name_3,
-	name_40,
-	name_41,
-	ENUMERATE_ONE,
-	ENUMERATE_TWO,
-	ENUMERATE_THREE,
-	ENUMERATE_FOUR,
-	ENUMERATE_FIVE,
-	ENUMERATE_SIX,
-	ENUMERATE_SEVEN,
-	ENUMERATE_EIGHT,
-	ENUMERATE_NINE,
-	ENUMERATE_TEN,
-	ENUMERATE_ELEVEN,
-	ENUMERATE_TWELVE,
-	ENUMERATE_THIRTEEN,
-	ENUMERATE_FOURTEEN,
-	ENUMERATE_FIFTEEN,
-	ENUMERATE_SIXTEEN,
-	END_LIST_WITH_AND,
-	ENUMERATE_ZERO,
-	ENUMERATE_SEVENTEEN,
-	ENUMERATE_EIGHTEEN,
-	ENUMERATE_NINETEEN,
-	ENUMERATE_TWENTY,
-	ENUMERATE_THIRTY,
-	ENUMERATE_FOURTY,
-	ENUMERATE_FIFTY,
-	ENUMERATE_SIXTY,
-	ENUMERATE_SEVENTY,
-	ENUMERATE_EIGHTY,
-	ENUMERATE_NINETY,
-	ENUMERATE_HUNDRED,
-	ENUMERATE_THOUSAND
 };
 
 #endif /* _STRINGS_H */
diff -ruNp src.orig/uqm/comm/mycon/myconc.c src/uqm/comm/mycon/myconc.c
--- src.orig/uqm/comm/mycon/myconc.c	2017-11-01 15:30:23 -0700
+++ src/uqm/comm/mycon/myconc.c	2017-11-01 15:31:01 -0700
@@ -26,6 +26,7 @@
 
 static LOCDATA mycon_desc =
 {
+	MYCON_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -106,6 +107,11 @@ static LOCDATA mycon_desc =
 	NULL, NULL, NULL,
 	NULL,
 	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
 };
 
 static BYTE MadeChoice;
diff -ruNp src.orig/uqm/comm/orz/orzc.c src/uqm/comm/orz/orzc.c
--- src.orig/uqm/comm/orz/orzc.c	2017-11-01 15:30:23 -0700
+++ src/uqm/comm/orz/orzc.c	2017-11-01 15:31:01 -0700
@@ -16,15 +16,17 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: Cleaned up the comm logic
+
 #include "../commall.h"
 #include "resinst.h"
 #include "strings.h"
-
 #include "uqm/build.h"
 
 
 static LOCDATA orz_desc =
 {
+	ORZ_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -169,683 +171,165 @@ static LOCDATA orz_desc =
 	NULL, NULL, NULL,
 	NULL,
 	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
 };
 
 static void
 ExitConversation (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
-
-	if (PLAYER_SAID (R, bye_ally))
-		NPCPhrase (GOODBYE_ALLY);
-	else if (PLAYER_SAID (R, bye_neutral))
-		NPCPhrase (GOODBYE_NEUTRAL);
-	else if (PLAYER_SAID (R, bye_angry))
-		NPCPhrase (GOODBYE_ANGRY);
-	else if (PLAYER_SAID (R, bye_taalo))
-	{
-		if (GET_GAME_STATE (ORZ_MANNER) == 1)
-			NPCPhrase (ANGRY_TAALO_GOODBYE);
-		else
-			NPCPhrase (FRIENDLY_TAALO_GOODBYE);
-	}
-	else if (PLAYER_SAID (R, hostile_2))
-	{
-		NPCPhrase (HOSTILITY_IS_BAD_2);
-		
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
-	}
-	else if (PLAYER_SAID (R, may_we_land))
-	{
-		NPCPhrase (SURE_LAND);
-
-		SET_GAME_STATE (TAALO_UNPROTECTED, 1);
-	}
-	else if (PLAYER_SAID (R, yes_alliance)
-			|| PLAYER_SAID (R, were_sorry))
-	{
-		if (PLAYER_SAID (R, yes_alliance))
-			NPCPhrase (GREAT);
-		else
-			NPCPhrase (APOLOGY_ACCEPTED);
-
-		SET_GAME_STATE (ORZ_ANDRO_STATE, 0);
-		SET_GAME_STATE (ORZ_GENERAL_INFO, 0);
-		SET_GAME_STATE (ORZ_PERSONAL_INFO, 0);
-		SET_GAME_STATE (ORZ_MANNER, 3);
-		ActivateStarShip (ORZ_SHIP, SET_ALLIED);
-	}
-	else if (PLAYER_SAID (R, demand_to_land))
-	{
-		NPCPhrase (NO_DEMAND);
-
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
-	}
-	else if (PLAYER_SAID (R, about_andro_3)
-			|| PLAYER_SAID (R, must_know_about_androsyn))
-	{
-		if (PLAYER_SAID (R, about_andro_3))
-			NPCPhrase (BLEW_IT);
-		else
-			NPCPhrase (KNOW_TOO_MUCH);
-
-		SET_GAME_STATE (ORZ_VISITS, 0);
-		SET_GAME_STATE (ORZ_MANNER, 2);
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
-		if (PLAYER_SAID (R, about_andro_3))
-		{
-			ActivateStarShip (ORZ_SHIP, SET_NOT_ALLIED);
-			ActivateStarShip (ORZ_SHIP, REMOVE_BUILT);
-		}
-
-		XFormColorMap (GetColorMapAddress (
-				SetAbsColorMapIndex (CommData.AlienColorMap, 1)
-				), ONE_SECOND / 2);
-	}
-	else /* insults */
-	{
-		BYTE NumVisits;
-
-		NumVisits = GET_GAME_STATE (ORZ_PERSONAL_INFO);
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (INSULTED_1);
-				break;
-			case 1:
-				NPCPhrase (INSULTED_2);
-				break;
-			case 2:
-				NPCPhrase (INSULTED_3);
-				SET_GAME_STATE (BATTLE_SEGUE, 1);
-				break;
-			case 7:
-				--NumVisits;
-			default:
-				NPCPhrase (INSULTED_4);
-				SET_GAME_STATE (BATTLE_SEGUE, 1);
-				break;
-		}
-		SET_GAME_STATE (ORZ_PERSONAL_INFO, NumVisits);
-	}
-}
-
-static void
-TaaloWorld (RESPONSE_REF R)
-{
-	// We can only get here when ORZ_MANNER != HOSTILE (2)
-	BYTE Manner;
-
-	Manner = GET_GAME_STATE (ORZ_MANNER);
-	if (PLAYER_SAID (R, demand_to_land))
-	{
-		NPCPhrase (ASK_NICELY);
-
-		DISABLE_PHRASE (demand_to_land);
-	}
-	else if (PLAYER_SAID (R, why_you_here))
-	{
-		if (Manner != 1)
-			NPCPhrase (FRIENDLY_EXPLANATION);
-		else
-			NPCPhrase (ANGRY_EXPLANATION);
-
-		DISABLE_PHRASE (why_you_here);
-	}
-	else if (PLAYER_SAID (R, what_is_this_place))
-	{
-		if (Manner != 1)
-			NPCPhrase (FRIENDLY_PLACE);
-		else
-			NPCPhrase (ANGRY_PLACE);
-
-		DISABLE_PHRASE (what_is_this_place);
-	}
-	else if (PLAYER_SAID (R, may_we_land))
-	{
-		NPCPhrase (ALLIES_CAN_VISIT);
-
-		DISABLE_PHRASE (may_we_land);
-	}
-	else if (PLAYER_SAID (R, make_alliance))
+	if (PLAYER_SAID (R, goodbye_orz))
 	{
-		NPCPhrase (CANT_ALLY_HERE);
-
-		DISABLE_PHRASE (make_alliance);
-	}
-	else if (PLAYER_SAID (R, why_busy))
-	{
-		NPCPhrase (BUSY_BECAUSE);
-
-		DISABLE_PHRASE (why_busy);
-	}
+		NPCPhrase (GOODBYE_EARTHLING);
+		SET_GAME_STATE (BATTLE_SEGUE, 0);
+	}	
 
-	if (PHRASE_ENABLED (may_we_land))
-	{
-		if (Manner == 3 &&
-				ActivateStarShip (ORZ_SHIP, CHECK_ALLIANCE) == GOOD_GUY)
-			Response (may_we_land, ExitConversation);
-		else
-			Response (may_we_land, TaaloWorld);
-	}
-	else if (PHRASE_ENABLED (make_alliance))
-		Response (make_alliance, TaaloWorld);
-	else if (PHRASE_ENABLED (why_busy))
-		Response (why_busy, TaaloWorld);
-	if (PHRASE_ENABLED (demand_to_land))
-	{
-		if (Manner == 1)
-			Response (demand_to_land, ExitConversation);
-		else
-			Response (demand_to_land, TaaloWorld);
-	}
-	if (PHRASE_ENABLED (why_you_here))
-		Response (why_you_here, TaaloWorld);
-	if (PHRASE_ENABLED (what_is_this_place))
-		Response (what_is_this_place, TaaloWorld);
-	Response (bye_taalo, ExitConversation);
 }
 
-static void
-OrzAllied (RESPONSE_REF R)
-{
-	BYTE NumVisits;
-
-	if (PLAYER_SAID (R, whats_up_ally))
-	{
-		NumVisits = GET_GAME_STATE (ORZ_GENERAL_INFO);
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (GENERAL_INFO_ALLY_1);
-				break;
-			case 1:
-				NPCPhrase (GENERAL_INFO_ALLY_2);
-				break;
-			case 2:
-				NPCPhrase (GENERAL_INFO_ALLY_3);
-				break;
-			case 3:
-				NPCPhrase (GENERAL_INFO_ALLY_4);
-				--NumVisits;
-				break;
-		}
-		SET_GAME_STATE (ORZ_GENERAL_INFO, NumVisits);
-
-		DISABLE_PHRASE (whats_up_ally);
-	}
-	else if (PLAYER_SAID (R, more_about_you))
-	{
-		NumVisits = GET_GAME_STATE (ORZ_PERSONAL_INFO);
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (ABOUT_US_1);
-				break;
-			case 1:
-				NPCPhrase (ABOUT_US_2);
-				break;
-			case 2:
-				NPCPhrase (ABOUT_US_3);
-				break;
-			case 3:
-				NPCPhrase (ABOUT_US_4);
-				--NumVisits;
-				break;
-		}
-		SET_GAME_STATE (ORZ_PERSONAL_INFO, NumVisits);
-
-		DISABLE_PHRASE (more_about_you);
-	}
-	else if (PLAYER_SAID (R, about_andro_1))
-	{
-		NPCPhrase (FORGET_ANDRO_1);
-
-		SET_GAME_STATE (ORZ_ANDRO_STATE, 1);
-	}
-	else if (PLAYER_SAID (R, about_andro_2))
-	{
-		NPCPhrase (FORGET_ANDRO_2);
-
-		SET_GAME_STATE (ORZ_ANDRO_STATE, 2);
-	}
-
-	if (GET_GAME_STATE (ORZ_ANDRO_STATE) == 0)
-		Response (about_andro_1, OrzAllied);
-	else if (GET_GAME_STATE (ORZ_ANDRO_STATE) == 1)
-		Response (about_andro_2, OrzAllied);
-	else
-	{
-		Response (about_andro_3, ExitConversation);
-	}
-	if (PHRASE_ENABLED (whats_up_ally))
-		Response (whats_up_ally, OrzAllied);
-	if (PHRASE_ENABLED (more_about_you))
-		Response (more_about_you, OrzAllied);
-	Response (bye_ally, ExitConversation);
-}
+// JMS: Commented out for demo
+/*static void
+OhFjorn (RESPONSE_REF R)
+{	
+	if (PLAYER_SAID (R, you_have_met_fjorn))
+	{
+		NPCPhrase (TALK_ABOUT_FJORN);
+	}
+	
+		Response (goodbye_orz, ExitConversation);
+}*/
+
+// JMS: Commented out for demo
+/* static void
+AllianceMatters2 (RESPONSE_REF R)
+{	
+	
+	else if (PLAYER_SAID (R, ask_know_fjorn))
+	{
+		NPCPhrase (ORZ_DENY_FJORN);
+		DISABLE_PHRASE (ask_know_fjorn);
+	}
+
+	Response (you_have_met_fjorn, OhFjorn);
+	Response (goodbye_orz, ExitConversation);
+}*/
 
-static void OrzNeutral (RESPONSE_REF R);
+static void SmallTalk1 (RESPONSE_REF R);
 
 static void
-WhereAndrosyn (RESPONSE_REF R)
-{
-	(void) R;  // ignored
-	NPCPhrase (DISEMBLE_ABOUT_ANDROSYN);
-	DISABLE_PHRASE (where_androsyn);
-
-	Response (must_know_about_androsyn, ExitConversation);
-	Response (dont_really_care, OrzNeutral);
+AllianceMatters (RESPONSE_REF R)
+{	
+	if (PLAYER_SAID (R, discuss_alliance_matters))
+		NPCPhrase (HAPPY_TO_DISCUSS);
+	
+	if (PLAYER_SAID (R, alliance_question_1))
+	{
+		NPCPhrase (ALLIANCE_ANSWER_1);
+		DISABLE_PHRASE (alliance_question_1);
+	}
+	else if (PLAYER_SAID (R, alliance_question_2))
+	{
+		NPCPhrase (ALLIANCE_ANSWER_2);  //TODO 2
+		DISABLE_PHRASE (alliance_question_2);
+	}
+	
+	if (PHRASE_ENABLED (alliance_question_1))
+		Response (alliance_question_1, AllianceMatters);
+	if (PHRASE_ENABLED (alliance_question_2))
+		Response (alliance_question_2, AllianceMatters);
+	//if (PHRASE_ENABLED (ask_know_fjorn))
+	//	Response (ask_know_fjorn, AllianceMatters2); // JMS: Commented out for demo
+	
+	Response (enough_alliance, SmallTalk1); // JMS
+	
+	Response (goodbye_orz, ExitConversation);
 }
 
 static void
-OfferAlliance (RESPONSE_REF R)
-{
-	if (PLAYER_SAID (R, seem_like_nice_guys))
-		NPCPhrase (ARE_NICE_WANT_ALLY);
-	else if (PLAYER_SAID (R, talk_about_alliance))
-		NPCPhrase (OK_TALK_ALLIANCE);
-	else if (PLAYER_SAID (R, why_so_trusting))
-	{
-		NPCPhrase (TRUSTING_BECAUSE);
-
-		SET_GAME_STATE (ORZ_STACK1, 1);
+AnnoyOrz (RESPONSE_REF R)
+{	
+	if (PLAYER_SAID (R, tell_buddies))
+	{
+		NPCPhrase (ORZ_TELL_2);
+		DISABLE_PHRASE (tell_buddies);
+		SET_GAME_STATE(ORZ_STACK0, 1);
 	}
-
-	Response (no_alliance, OrzNeutral);
-	Response (decide_later, OrzNeutral);
-	if (GET_GAME_STATE (ORZ_STACK1) == 0)
-	{
-		Response (why_so_trusting, OfferAlliance);
-	}
-	Response (yes_alliance, ExitConversation);
+	
+	SmallTalk1 ((RESPONSE_REF)0);
 }
 
-static void
-OrzNeutral (RESPONSE_REF R)
-{
-	BYTE i, LastStack;
-	RESPONSE_REF pStr[3];
-
-	LastStack = 0;
-	pStr[0] = pStr[1] = pStr[2] = 0;
-	if (PLAYER_SAID (R, hostile_1))
+void
+SmallTalk1 (RESPONSE_REF R)
+{	
+	if (PLAYER_SAID (R, enough_alliance))
 	{
-		NPCPhrase (HOSTILITY_IS_BAD_1);
-
-		DISABLE_PHRASE (hostile_1);
-		LastStack = 2;
+		NPCPhrase (ENOUGH_ALLIANCE_OK);
 	}
-	else if (PLAYER_SAID (R, we_are_vindicator0))
+	if (PLAYER_SAID (R, how_are_things))
 	{
-		NPCPhrase (NICE_TO_MEET_YOU);
-
-		SET_GAME_STATE (ORZ_STACK0, 1);
-		LastStack = 1;
+		NPCPhrase (HAPPY_ORZ);
+		DISABLE_PHRASE (how_are_things);
 	}
-	else if (PLAYER_SAID (R, who_you))
+	else if (PLAYER_SAID (R, any_news))
 	{
-		NPCPhrase (WE_ARE_ORZ);
-
-		SET_GAME_STATE (ORZ_ANDRO_STATE, 1);
+		NPCPhrase (ORZ_NEWS);
+		DISABLE_PHRASE (any_news);
 	}
-	else if (PLAYER_SAID (R, why_here))
+	else if (PLAYER_SAID (R, discuss_alliance_matters))
 	{
-		NPCPhrase (HERE_BECAUSE);
-
-		SET_GAME_STATE (ORZ_ANDRO_STATE, 2);
+		NPCPhrase (HAPPY_TO_DISCUSS);
+		DISABLE_PHRASE (discuss_alliance_matters);
 	}
-	else if (PLAYER_SAID (R, no_alliance))
+	else if (PLAYER_SAID (R, tell_of_nature))
 	{
-		NPCPhrase (MAYBE_LATER);
-
-		DISABLE_PHRASE (talk_about_alliance);
-		SET_GAME_STATE (REFUSED_ORZ_ALLIANCE, 1);
+		NPCPhrase (ORZ_TELL_1);
+		DISABLE_PHRASE (tell_of_nature);
+		SET_GAME_STATE(ORZ_STACK0, 1);
 	}
-	else if (PLAYER_SAID (R, decide_later))
-	{
-		NPCPhrase (OK_LATER);
 
-		DISABLE_PHRASE (talk_about_alliance);
-		SET_GAME_STATE (REFUSED_ORZ_ALLIANCE, 1);
-	}
-	else if (PLAYER_SAID (R, dont_really_care))
-		NPCPhrase (YOU_ARE_OUR_FRIENDS);
-	else if (PLAYER_SAID (R, where_androsyn))
-	{
-		WhereAndrosyn (R);
-		return;
-	}
-	else if (PLAYER_SAID (R, talk_about_alliance)
-			|| PLAYER_SAID (R, seem_like_nice_guys))
-	{
-		OfferAlliance (R);
-		return;
-	}
-	else if (PLAYER_SAID (R, hostile_2))
-	{
-		ExitConversation (R);
-		return;
-	}
-
-	if (GET_GAME_STATE (ORZ_ANDRO_STATE) == 0)
-		pStr[0] = who_you;
-	else if (GET_GAME_STATE (ORZ_ANDRO_STATE) == 1)
-		pStr[0] = why_here;
-	else if (PHRASE_ENABLED (where_androsyn) && GET_GAME_STATE (ORZ_ANDRO_STATE) == 2)
-		pStr[0] = where_androsyn;
-	if (GET_GAME_STATE (REFUSED_ORZ_ALLIANCE))
-	{
-		if (PHRASE_ENABLED (talk_about_alliance))
-			pStr[1] = talk_about_alliance;
-	}
-	else if (GET_GAME_STATE (ORZ_STACK0) == 0)
-	{
-		construct_response (shared_phrase_buf,
-				we_are_vindicator0,
-				GLOBAL_SIS (CommanderName),
-				we_are_vindicator1,
-				GLOBAL_SIS (ShipName),
-				we_are_vindicator2,
-				(UNICODE*)NULL);
-		pStr[1] = we_are_vindicator0;
-	}
-	else
-		pStr[1] = seem_like_nice_guys;
-	if (PHRASE_ENABLED (hostile_1))
-		pStr[2] = hostile_1;
-	else
-		pStr[2] = hostile_2;
-
-	if (pStr[LastStack])
-	{
-		if (pStr[LastStack] != we_are_vindicator0)
-			Response (pStr[LastStack], OrzNeutral);
-		else
-			DoResponsePhrase (pStr[LastStack], OrzNeutral, shared_phrase_buf);
-	}
-	for (i = 0; i < 3; ++i)
-	{
-		if (i != LastStack && pStr[i])
-		{
-			if (pStr[i] != we_are_vindicator0)
-				Response (pStr[i], OrzNeutral);
-			else
-				DoResponsePhrase (pStr[i], OrzNeutral, shared_phrase_buf);
-		}
-	}
-	Response (bye_neutral, ExitConversation);
-}
-
-static void
-OrzAngry (RESPONSE_REF R)
-{
-	if (PLAYER_SAID (R, whats_up_angry))
-	{
-		BYTE NumVisits;
-
-		NumVisits = GET_GAME_STATE (ORZ_GENERAL_INFO);
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (GENERAL_INFO_ANGRY_1);
-				break;
-			case 1:
-				NPCPhrase (GENERAL_INFO_ANGRY_2);
-				--NumVisits;
-				break;
-		}
-		SET_GAME_STATE (ORZ_GENERAL_INFO, NumVisits);
-
-		DISABLE_PHRASE (whats_up_angry);
-	}
-
-	if (PHRASE_ENABLED (whats_up_angry))
-	{
-		Response (whats_up_angry, OrzAngry);
-	}
-	Response (were_sorry, ExitConversation);
-	switch (GET_GAME_STATE (ORZ_PERSONAL_INFO))
+	if (PHRASE_ENABLED (how_are_things))
+		Response (how_are_things, SmallTalk1);
+	if (PHRASE_ENABLED (any_news))
+		Response (any_news, SmallTalk1);
+	if (PHRASE_ENABLED (discuss_alliance_matters))
+		Response (discuss_alliance_matters, AllianceMatters);
+	
+	switch (GET_GAME_STATE(ORZ_STACK0))
 	{
 		case 0:
-			Response (insult_1, ExitConversation);
+			if (PHRASE_ENABLED (tell_of_nature))
+				Response (tell_of_nature, SmallTalk1);
 			break;
 		case 1:
-			Response (insult_2, ExitConversation);
-			break;
-		case 2:
-			Response (insult_3, ExitConversation);
-			break;
-		case 3:
-			Response (insult_4, ExitConversation);
-			break;
-		case 4:
-			Response (insult_5, ExitConversation);
-			break;
-		case 5:
-			Response (insult_6, ExitConversation);
+			if (PHRASE_ENABLED (tell_buddies))
+				Response (tell_buddies, AnnoyOrz);
 			break;
-		case 6:
-			Response (insult_7, ExitConversation);
-			break;
-		case 7:
-			Response (insult_8, ExitConversation);
+		default:
 			break;
 	}
-	Response (bye_angry, ExitConversation);
+	
+	Response (goodbye_orz, ExitConversation);
 }
 
 static void
 Intro (void)
 {
-	BYTE NumVisits, Manner;
-
-	if (LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
+	if (GET_GAME_STATE (ORZ_MET) == 0)
 	{
-		NPCPhrase (OUT_TAKES);
-
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
-		return;
+		NPCPhrase (ORZ_GREETING);
+		SET_GAME_STATE (ORZ_MET, 1);
 	}
+	else
+		NPCPhrase (ORZ_GREETING_2);
 
-	if (!GET_GAME_STATE (MET_ORZ_BEFORE))
-		NPCPhrase (INIT_HELLO);
-
-	Manner = GET_GAME_STATE (ORZ_MANNER);
-	if (Manner == 2)
-	{
-		CommData.AlienColorMap =
-				SetAbsColorMapIndex (CommData.AlienColorMap, 1);
-
-		NumVisits = GET_GAME_STATE (ORZ_VISITS);
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (HOSTILE_HELLO_1);
-				break;
-			case 1:
-				NPCPhrase (HOSTILE_HELLO_2);
-				--NumVisits;
-				break;
-		}
-		SET_GAME_STATE (ORZ_VISITS, NumVisits);
-
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
-	}
-	else if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 6))
-	{
-		NumVisits = GET_GAME_STATE (TAALO_VISITS);
-		if (Manner != 1)
-		{
-			switch (NumVisits++)
-			{
-				case 0:
-					NPCPhrase (FRIENDLY_ALLIED_TAALO_HELLO_1);
-					break;
-				case 1:
-					NPCPhrase (FRIENDLY_ALLIED_TAALO_HELLO_2);
-					--NumVisits;
-					break;
-			}
-		}
-		else
-		{
-			switch (NumVisits++)
-			{
-				case 0:
-					NPCPhrase (ANGRY_TAALO_HELLO_1);
-					break;
-				case 1:
-					NPCPhrase (ANGRY_TAALO_HELLO_2);
-					--NumVisits;
-					break;
-			}
-		}
-		SET_GAME_STATE (TAALO_VISITS, NumVisits);
-
-		TaaloWorld ((RESPONSE_REF)0);
-	}
-	else if (Manner == 3 &&
-			ActivateStarShip (ORZ_SHIP, CHECK_ALLIANCE) == GOOD_GUY)
-	{
-		if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 7))
-		{
-			NumVisits = GET_GAME_STATE (ORZ_HOME_VISITS);
-			switch (NumVisits++)
-			{
-				case 0:
-					NPCPhrase (ALLIED_HOMEWORLD_HELLO_1);
-					break;
-				case 1:
-					NPCPhrase (ALLIED_HOMEWORLD_HELLO_2);
-					break;
-				case 2:
-					NPCPhrase (ALLIED_HOMEWORLD_HELLO_3);
-					break;
-				case 3:
-					NPCPhrase (ALLIED_HOMEWORLD_HELLO_4);
-					--NumVisits;
-					break;
-			}
-			SET_GAME_STATE (ORZ_HOME_VISITS, NumVisits);
-		}
-		else
-		{
-			NumVisits = GET_GAME_STATE (ORZ_VISITS);
-			switch (NumVisits++)
-			{
-				case 0:
-					NPCPhrase (ALLIED_SPACE_HELLO_1);
-					break;
-				case 1:
-					NPCPhrase (ALLIED_SPACE_HELLO_2);
-					break;
-				case 2:
-					NPCPhrase (ALLIED_SPACE_HELLO_3);
-					break;
-				case 3:
-					NPCPhrase (ALLIED_SPACE_HELLO_4);
-					--NumVisits;
-					break;
-			}
-			SET_GAME_STATE (ORZ_VISITS, NumVisits);
-		}
-
-		OrzAllied ((RESPONSE_REF)0);
-	}
-	else if (Manner != 1)
-	{
-		if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 7))
-		{
-			NumVisits = GET_GAME_STATE (ORZ_HOME_VISITS);
-			switch (NumVisits++)
-			{
-				case 0:
-					NPCPhrase (NEUTRAL_HOMEWORLD_HELLO_1);
-					break;
-				case 1:
-					NPCPhrase (NEUTRAL_HOMEWORLD_HELLO_2);
-					break;
-				case 2:
-					NPCPhrase (NEUTRAL_HOMEWORLD_HELLO_3);
-					break;
-				case 3:
-					NPCPhrase (NEUTRAL_HOMEWORLD_HELLO_4);
-					--NumVisits;
-					break;
-			}
-			SET_GAME_STATE (ORZ_HOME_VISITS, NumVisits);
-		}
-		else
-		{
-			NumVisits = GET_GAME_STATE (ORZ_VISITS);
-			switch (NumVisits++)
-			{
-				case 0:
-					NPCPhrase (NEUTRAL_SPACE_HELLO_1);
-					break;
-				case 1:
-					NPCPhrase (NEUTRAL_SPACE_HELLO_2);
-					break;
-				case 2:
-					NPCPhrase (NEUTRAL_SPACE_HELLO_3);
-					break;
-				case 3:
-					NPCPhrase (NEUTRAL_SPACE_HELLO_4);
-					--NumVisits;
-					break;
-			}
-			SET_GAME_STATE (ORZ_VISITS, NumVisits);
-		}
+	SmallTalk1 ((RESPONSE_REF)0);
+}
 
-		OrzNeutral ((RESPONSE_REF)0);
-	}
-	else
-	{
-		if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 7))
-		{
-			NumVisits = GET_GAME_STATE (ORZ_HOME_VISITS);
-			switch (NumVisits++)
-			{
-				case 0:
-					NPCPhrase (ANGRY_HOMEWORLD_HELLO_1);
-					break;
-				case 1:
-					NPCPhrase (ANGRY_HOMEWORLD_HELLO_2);
-					--NumVisits;
-					break;
-			}
-			SET_GAME_STATE (ORZ_HOME_VISITS, NumVisits);
-		}
-		else
-		{
-			NumVisits = GET_GAME_STATE (ORZ_VISITS);
-			switch (NumVisits++)
-			{
-				case 0:
-					NPCPhrase (ANGRY_SPACE_HELLO_1);
-					break;
-				case 1:
-					NPCPhrase (ANGRY_SPACE_HELLO_2);
-					--NumVisits;
-					break;
-			}
-			SET_GAME_STATE (ORZ_VISITS, NumVisits);
-		}
-
-		OrzAngry ((RESPONSE_REF)0);
-	}
-
-	if (!GET_GAME_STATE (MET_ORZ_BEFORE))
-	{
-		SET_GAME_STATE (MET_ORZ_BEFORE, 1);
-
-		// Disable talking anim and run the computer report
-		EnableTalkingAnim (FALSE);
-		AlienTalkSegue (1);
-		// Run whatever is left with talking anim
-		EnableTalkingAnim (TRUE);
-	}
+static void
+post_orz_enc (void)
+{
 }
 
 static COUNT
@@ -854,23 +338,6 @@ uninit_orz (void)
 	return (0);
 }
 
-static void
-post_orz_enc (void)
-{
-	BYTE Manner;
-
-	if (GET_GAME_STATE (BATTLE_SEGUE) == 1
-			&& (Manner = GET_GAME_STATE (ORZ_MANNER)) != 2)
-	{
-		SET_GAME_STATE (ORZ_MANNER, 1);
-		if (Manner != 1)
-		{
-			SET_GAME_STATE (ORZ_VISITS, 0);
-			SET_GAME_STATE (ORZ_HOME_VISITS, 0);
-			SET_GAME_STATE (TAALO_VISITS, 0);
-		}
-	}
-}
 
 LOCDATA*
 init_orz_comm (void)
@@ -885,15 +352,8 @@ init_orz_comm (void)
 	orz_desc.AlienTextBaseline.y = 0;
 	orz_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
 
-	if (GET_GAME_STATE (ORZ_MANNER) == 3
-			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
-	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
-	}
-	else
-	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
-	}
+	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	
 	retval = &orz_desc;
 
 	return (retval);
diff -ruNp src.orig/uqm/comm/orz/strings.h src/uqm/comm/orz/strings.h
--- src.orig/uqm/comm/orz/strings.h	2017-11-01 15:30:23 -0700
+++ src/uqm/comm/orz/strings.h	2017-11-01 15:31:01 -0700
@@ -22,122 +22,32 @@
 enum
 {
 	NULL_PHRASE,
-	INIT_HELLO,
-	who_you,
-	WE_ARE_ORZ,
-	why_here,
-	HERE_BECAUSE,
-	ALLIED_HOMEWORLD_HELLO_1,
-	ALLIED_HOMEWORLD_HELLO_2,
-	ALLIED_HOMEWORLD_HELLO_3,
-	ALLIED_HOMEWORLD_HELLO_4,
-	ALLIED_SPACE_HELLO_1,
-	ALLIED_SPACE_HELLO_2,
-	ALLIED_SPACE_HELLO_3,
-	ALLIED_SPACE_HELLO_4,
-	whats_up_ally,
-	GENERAL_INFO_ALLY_1,
-	GENERAL_INFO_ALLY_2,
-	GENERAL_INFO_ALLY_3,
-	GENERAL_INFO_ALLY_4,
-	more_about_you,
-	ABOUT_US_1,
-	ABOUT_US_2,
-	ABOUT_US_3,
-	ABOUT_US_4,
-	where_androsyn,
-	DISEMBLE_ABOUT_ANDROSYN,
-	must_know_about_androsyn,
-	KNOW_TOO_MUCH,
-	dont_really_care,
-	YOU_ARE_OUR_FRIENDS,
-	about_andro_1,
-	FORGET_ANDRO_1,
-	about_andro_2,
-	FORGET_ANDRO_2,
-	about_andro_3,
-	BLEW_IT,
-	NEUTRAL_HOMEWORLD_HELLO_1,
-	NEUTRAL_HOMEWORLD_HELLO_2,
-	NEUTRAL_HOMEWORLD_HELLO_3,
-	NEUTRAL_HOMEWORLD_HELLO_4,
-	NEUTRAL_SPACE_HELLO_1,
-	NEUTRAL_SPACE_HELLO_2,
-	NEUTRAL_SPACE_HELLO_3,
-	NEUTRAL_SPACE_HELLO_4,
-	hostile_1,
-	HOSTILITY_IS_BAD_1,
-	hostile_2,
-	HOSTILITY_IS_BAD_2,
-	we_are_vindicator0,
-	we_are_vindicator1,
-	we_are_vindicator2,
-	NICE_TO_MEET_YOU,
-	seem_like_nice_guys,
-	ARE_NICE_WANT_ALLY,
-	talk_about_alliance,
-	OK_TALK_ALLIANCE,
-	yes_alliance,
-	GREAT,
-	no_alliance,
-	MAYBE_LATER,
-	decide_later,
-	OK_LATER,
-	why_so_trusting,
-	TRUSTING_BECAUSE,
-	bye_neutral,
-	GOODBYE_NEUTRAL,
-	ANGRY_SPACE_HELLO_1,
-	ANGRY_SPACE_HELLO_2,
-	ANGRY_HOMEWORLD_HELLO_1,
-	ANGRY_HOMEWORLD_HELLO_2,
-	whats_up_angry,
-	GENERAL_INFO_ANGRY_1,
-	GENERAL_INFO_ANGRY_2,
-	were_sorry,
-	APOLOGY_ACCEPTED,
-	insult_1,
-	insult_2,
-	insult_3,
-	insult_4,
-	insult_5,
-	insult_6,
-	insult_7,
-	insult_8,
-	INSULTED_1,
-	INSULTED_2,
-	INSULTED_3,
-	INSULTED_4,
-	bye_angry,
-	GOODBYE_ANGRY,
-	ANGRY_TAALO_HELLO_1,
-	ANGRY_TAALO_HELLO_2,
-	FRIENDLY_ALLIED_TAALO_HELLO_1,
-	FRIENDLY_ALLIED_TAALO_HELLO_2,
-	demand_to_land,
-	NO_DEMAND,
-	ASK_NICELY,
-	why_you_here,
-	ANGRY_EXPLANATION,
-	FRIENDLY_EXPLANATION,
-	what_is_this_place,
-	FRIENDLY_PLACE,
-	ANGRY_PLACE,
-	may_we_land,
-	SURE_LAND,
-	ALLIES_CAN_VISIT,
-	make_alliance,
-	CANT_ALLY_HERE,
-	why_busy,
-	BUSY_BECAUSE,
-	bye_taalo,
-	bye_ally,
-	GOODBYE_ALLY,
-	FRIENDLY_TAALO_GOODBYE,
-	ANGRY_TAALO_GOODBYE,
-	HOSTILE_HELLO_1,
-	HOSTILE_HELLO_2,
-	OUT_TAKES,
+	ORZ_GREETING,
+	ORZ_GREETING_2,
+	how_are_things,
+	HAPPY_ORZ,
+	any_news,
+	ORZ_NEWS,
+	tell_of_nature,
+	ORZ_TELL_1,
+	tell_buddies,
+	ORZ_TELL_2,
+	discuss_alliance_matters,
+	HAPPY_TO_DISCUSS,
+	alliance_question_1,
+	alliance_question_2,
+	ALLIANCE_ANSWER_1,
+	ALLIANCE_ANSWER_2,
+	enough_alliance,
+	ENOUGH_ALLIANCE_OK,
+	ask_know_fjorn,
+	ORZ_DENY_FJORN,
+	you_have_met_fjorn,
+	TALK_ABOUT_FJORN,
+	any_more_news,
+	ORZ_GARBAGE,
+	goodbye_orz,
+	GOODBYE_EARTHLING,
 };
 
 #endif /* _STRINGS_H */
diff -ruNp src.orig/uqm/comm/pkunk/pkunkc.c src/uqm/comm/pkunk/pkunkc.c
--- src.orig/uqm/comm/pkunk/pkunkc.c	2017-11-01 15:30:23 -0700
+++ src/uqm/comm/pkunk/pkunkc.c	2017-11-01 15:31:01 -0700
@@ -19,13 +19,18 @@
 #include "../commall.h"
 #include "resinst.h"
 #include "strings.h"
+#include "libs/mathlib.h"
 
 #include "uqm/build.h"
 #include "uqm/gameev.h"
 
+#include "uqm/conversation.h"
+
+
 
 static LOCDATA pkunk_desc =
 {
+	PKUNK_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -67,7 +72,7 @@ static LOCDATA pkunk_desc =
 			3, /* NumFrames */
 			YOYO_ANIM
 					| WAIT_TALKING, /* AnimFlags */
-			ONE_SECOND / 30, 0, /* FrameRate */
+			ONE_SECOND / 10, 0, /* FrameRate */
 			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
 			(1 << 1), /* BlockMask */
 		},
@@ -93,1002 +98,299 @@ static LOCDATA pkunk_desc =
 	NULL, NULL, NULL,
 	NULL,
 	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
 };
 
-static BOOLEAN
-ShipsReady (void)
-{
-	SIZE i;
 
-	return (GET_GAME_STATE (PKUNK_MANNER) == 3
-		&& !((i = (GLOBAL (GameClock.year_index) - START_YEAR) - GET_GAME_STATE (PKUNK_SHIP_YEAR)) < 0
-		     || ((i == 0 && (i = GLOBAL (GameClock.month_index) - GET_GAME_STATE (PKUNK_SHIP_MONTH)) < 0)
-			 || (i == 0 && GLOBAL (GameClock.day_index) < GET_GAME_STATE (PKUNK_SHIP_DAY)))));
-}
-
-static void
-PrepareShip (void)
-{
-#define MAX_PKUNK_SHIPS 4
-	if (ActivateStarShip (PKUNK_SHIP, MAX_PKUNK_SHIPS))
-	{
-		BYTE mi, di, yi;
-
-		mi = GLOBAL (GameClock.month_index);
-		SET_GAME_STATE (PKUNK_SHIP_MONTH, mi);
-		if ((di = GLOBAL (GameClock.day_index)) > 28)
-			di = 28;
-		SET_GAME_STATE (PKUNK_SHIP_DAY, di);
-		yi = (BYTE)(GLOBAL (GameClock.year_index) - START_YEAR) + 1;
-		SET_GAME_STATE (PKUNK_SHIP_YEAR, yi);
-	}
-}
+BOOLEAN heardAdapt = FALSE;
 
-#define GOOD_REASON_1 (1 << 0)
-#define GOOD_REASON_2 (1 << 1)
-#define BAD_REASON_1 (1 << 2)
-#define BAD_REASON_2 (1 << 3)
+static void Court (RESPONSE_REF R);
+static void PkunkMain (RESPONSE_REF R);
 
 static void
 ExitConversation (RESPONSE_REF R)
 {
+	static BOOLEAN firstSpanish = TRUE;
+		
 	SET_GAME_STATE (BATTLE_SEGUE, 0);
-
-	if (PLAYER_SAID (R, friendly_bye_space))
-		NPCPhrase (FRIENDLY_GOODBYE_SPACE);
-	else if (PLAYER_SAID (R, neutral_bye_space))
-		NPCPhrase (NEUTRAL_GOODBYE_SPACE);
-	else if (PLAYER_SAID (R, bye_angry))
-		NPCPhrase (GOODBYE_ANGRY);
-	else if (PLAYER_SAID (R, bye_friendly))
-		NPCPhrase (GOODBYE_FRIENDLY);
-	else if (PLAYER_SAID (R, we_here_to_help)
-			|| PLAYER_SAID (R, we_need_help))
+	if (PLAYER_SAID (R, spanish))
 	{
-		if (PLAYER_SAID (R, we_here_to_help))
-			NPCPhrase (NEED_HELP);
-		else
-			NPCPhrase (GIVE_HELP);
-		NPCPhrase (ALMOST_ALLIANCE);
-
-		SET_GAME_STATE (PKUNK_MANNER, 3);
-		SET_GAME_STATE (PKUNK_VISITS, 0);
-		SET_GAME_STATE (PKUNK_HOME_VISITS, 0);
-		SET_GAME_STATE (PKUNK_INFO, 0);
-
-		AddEvent (RELATIVE_EVENT, 6, 0, 0, ADVANCE_PKUNK_MISSION);
-		if (ActivateStarShip (PKUNK_SHIP, FEASIBILITY_STUDY) == 0)
-			NPCPhrase (INIT_NO_ROOM);
-		else
+		if (firstSpanish)
 		{
-			NPCPhrase (INIT_SHIP_GIFT);
-			AlienTalkSegue ((COUNT)~0);
-			PrepareShip ();
+			firstSpanish = FALSE;
+			NPCPhrase(ADIOS1);
 		}
-	}
-	else if (PLAYER_SAID (R, try_to_be_nicer))
-	{
-		NPCPhrase (CANT_ASK_FOR_MORE);
-		NPCPhrase (VISIT_OUR_HOMEWORLD);
-
-		SET_GAME_STATE (PKUNK_MANNER, 3);
-		SET_GAME_STATE (PKUNK_VISITS, 0);
-		SET_GAME_STATE (PKUNK_HOME_VISITS, 0);
-		SET_GAME_STATE (PKUNK_INFO, 0);
-	}
-	else if (PLAYER_SAID (R, must_conquer)
-			|| PLAYER_SAID (R, obey))
-	{
-		if (PLAYER_SAID (R, obey))
-			NPCPhrase (NO_OBEY);
 		else
-		{
-			NPCPhrase (BAD_IDEA);
-
-			SET_GAME_STATE (PKUNK_MANNER, 2);
-		}
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
-	}
-	else if (PLAYER_SAID (R, die_idiot_fools))
-	{
-		NPCPhrase (VERY_WELL);
-
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
-	}
-	else if (PLAYER_SAID (R, suit_yourself))
-		NPCPhrase (GOODBYE_MIGRATION);
-	else
-	{
-		BYTE ReasonMask;
-
-		ReasonMask = GET_GAME_STATE (PKUNK_REASONS);
-		if (PLAYER_SAID (R, good_reason_1))
-		{
-			NPCPhrase (WE_GO_HOME_1);
-			ReasonMask |= GOOD_REASON_1;
-			AddEvent (RELATIVE_EVENT, 0, 0, 0, ADVANCE_PKUNK_MISSION);
-		}
-		else if (PLAYER_SAID (R, good_reason_2))
-		{
-			NPCPhrase (WE_GO_HOME_2);
-			ReasonMask |= GOOD_REASON_2;
-			AddEvent (RELATIVE_EVENT, 0, 0, 0, ADVANCE_PKUNK_MISSION);
-		}
-		else if (PLAYER_SAID (R, bad_reason_1))
-		{
-			NPCPhrase (NO_GO_HOME_1);
-			ReasonMask |= BAD_REASON_1;
-		}
-		else if (PLAYER_SAID (R, bad_reason_2))
-		{
-			NPCPhrase (NO_GO_HOME_2);
-			ReasonMask |= BAD_REASON_2;
-		}
-		SET_GAME_STATE (PKUNK_REASONS, ReasonMask);
+			NPCPhrase(ADIOS2);
 	}
+	else if (PLAYER_SAID (R, later))
+		NPCPhrase (MMM_EXIT);
 }
 
-static void PkunkHome (RESPONSE_REF R);
-
-static void
-PkunkAngry (RESPONSE_REF R)
+static void Guidance (RESPONSE_REF R)
 {
-	if (PLAYER_SAID (R, why_insults))
-	{
-		NPCPhrase (RELEASE_TENSION);
-
-		DISABLE_PHRASE (why_insults);
-	}
-	else if (PLAYER_SAID (R, what_about_you))
-	{
-		NPCPhrase (ABOUT_US);
-
-		DISABLE_PHRASE (what_about_you);
-	}
-	else if (PLAYER_SAID (R, should_be_friends))
-	{
-		NPCPhrase (YES_FRIENDS);
-
-		DISABLE_PHRASE (should_be_friends);
-	}
-
-	if (PHRASE_ENABLED (should_be_friends))
-	{
-		Response (should_be_friends, PkunkAngry);
-	}
-	else
+	if (PLAYER_SAID (R, thanks))
 	{
-		if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 7))
-			Response (try_to_be_nicer, PkunkHome);
-		else
-			Response (try_to_be_nicer, ExitConversation);
+		DISABLE_PHRASE (thanks);
+		NPCPhrase(GUIDANCE);
 	}
-	Response (die_idiot_fools, ExitConversation);
-	if (PHRASE_ENABLED (why_insults))
-		Response (why_insults, PkunkAngry);
-	if (PHRASE_ENABLED (what_about_you))
-		Response (what_about_you, PkunkAngry);
-	Response (bye_angry, ExitConversation);
+	
+	if (PHRASE_ENABLED(coming_out))
+		Response(coming_out, PkunkMain);
+	if (PHRASE_ENABLED(ouija))
+		Response(ouija, PkunkMain);
+	if (PHRASE_ENABLED(glad))
+		Response(glad, PkunkMain);
 }
 
-static void
-DiscussConquer (RESPONSE_REF R)
+static void Humor (RESPONSE_REF R)
 {
-	if (PLAYER_SAID (R, we_conquer))
-	{
-		NPCPhrase (WHY_CONQUER);
-
-		DISABLE_PHRASE (we_conquer);
-	}
-	else if (PLAYER_SAID (R, conquer_because_1))
-	{
-#if 0
-		NPCPhrase (NOT_CONQUER_10);
-		NPCPhrase (GLOBAL_ALLIANCE_NAME + name_1);
-		NPCPhrase (NOT_CONQUER_11);
-		NPCPhrase (GLOBAL_ALLIANCE_NAME + name_1);
-		NPCPhrase (NOT_CONQUER_12);
-#endif
-		NPCPhrase (NOT_CONQUER_1);
-
-		DISABLE_PHRASE (conquer_because_1);
-	}
-	else if (PLAYER_SAID (R, conquer_because_2))
-	{
-		NPCPhrase (NOT_CONQUER_2);
-
-		DISABLE_PHRASE (conquer_because_2);
-	}
-
-	if (PHRASE_ENABLED (conquer_because_1))
-	{
-#if 0
-		UNICODE buf[ALLIANCE_NAME_BUFSIZE];
-
-		GetAllianceName (buf, name_1);
-		construct_response (
-				shared_phrase_buf,
-				conquer_because_1,
-				buf,
-				(RESPONSE_REF)-1);
-		DoResponsePhrase (conquer_because_1, DiscussConquer, shared_phrase_buf);
-#endif
-		Response(conquer_because_1, DiscussConquer);
-	}
-	if (PHRASE_ENABLED (conquer_because_2))
-		Response (conquer_because_2, DiscussConquer);
-	Response (must_conquer, ExitConversation);
-	Response (no_conquest, PkunkHome);
+	(void) R;
+	if (PHRASE_ENABLED(wtf_joke))
+		Response (wtf_joke, PkunkMain);
+	if (PHRASE_ENABLED(brick))
+		Response (brick, PkunkMain);
+	if (PHRASE_ENABLED(delivery))
+		Response (delivery, Court);
+	if (PHRASE_ENABLED(important))
+		Response (important, PkunkMain);
 }
 
-static void
-OfferAlliance (RESPONSE_REF R)
+static void Joke (RESPONSE_REF R)
 {
-	if (PLAYER_SAID (R, we_are_vindicator0))
-		NPCPhrase (WHY_YOU_HERE);
-	else if (PLAYER_SAID (R, exploring_universe))
+	if (PLAYER_SAID (R, astral))
 	{
-		NPCPhrase (SENSE_DEEPER_CONFLICT);
-
-		DISABLE_PHRASE (exploring_universe);
+		DISABLE_PHRASE (astral);
+		heardAdapt = TRUE;
+		NPCPhrase(PHOTOGRAPHS);
 	}
-	else if (PLAYER_SAID (R, fun_cruise))
-	{
-		NPCPhrase (REPRESS);
 
-		DISABLE_PHRASE (fun_cruise);
-	}
-
-	Response (we_here_to_help, ExitConversation);
-	Response (we_need_help, ExitConversation);
-	if (PHRASE_ENABLED (exploring_universe))
-		Response (exploring_universe, OfferAlliance);
-	if (PHRASE_ENABLED (fun_cruise))
-		Response (fun_cruise, OfferAlliance);
+	NPCPhrase(JOKE);
+	SET_GAME_STATE (PKUNK_JOKE, 1);
+	Humor (R);
 }
 
-static void
-AboutPkunk (RESPONSE_REF R)
+static void PkunkMain (RESPONSE_REF R)
 {
-	BYTE InfoLeft;
-
-	InfoLeft = FALSE;
-	if (PLAYER_SAID (R, what_about_you))
-		NPCPhrase (ABOUT_US);
-	else if (PLAYER_SAID (R, what_about_history))
+	if (PLAYER_SAID (R, did_we_speak))
 	{
-		NPCPhrase (ABOUT_HISTORY);
-
-		DISABLE_PHRASE (what_about_history);
+		DISABLE_PHRASE (did_we_speak);
+		NPCPhrase (ONE_AS_ALL);
 	}
-	else if (PLAYER_SAID (R, what_about_yehat))
+	else if (PLAYER_SAID (R, how_queen))
 	{
-		NPCPhrase (ABOUT_YEHAT);
-
-		DISABLE_PHRASE (what_about_yehat);
+		DISABLE_PHRASE (how_queen);
+		NPCPhrase (REBEL_RANT);
 	}
-	else if (PLAYER_SAID (R, what_about_culture))
+	else if (PLAYER_SAID (R, nafs))
 	{
-		NPCPhrase (ABOUT_CULTURE);
-
-		DISABLE_PHRASE (what_about_culture);
+		DISABLE_PHRASE (nafs);
+		NPCPhrase (WAY_BETTER);
 	}
-	else if (PLAYER_SAID (R, elaborate_culture))
+	else if (PLAYER_SAID (R, need_help))
 	{
-		NPCPhrase (OK_ELABORATE_CULTURE);
-
-		DISABLE_PHRASE (elaborate_culture);
+		DISABLE_PHRASE (need_help);
+		NPCPhrase (COSMOLOGY);
 	}
-	else if (PLAYER_SAID (R, what_about_future))
+	else if (PLAYER_SAID (R, interesting))
 	{
-		NPCPhrase (ABOUT_FUTURE);
-
-		DISABLE_PHRASE (what_about_future);
+		DISABLE_PHRASE (interesting);
+		NPCPhrase (MELTINGPOT);
 	}
-
-	if (PHRASE_ENABLED (what_about_history))
+	else if (PLAYER_SAID (R, sorry))
 	{
-		Response (what_about_history, AboutPkunk);
-		InfoLeft = TRUE;
+		NPCPhrase (WORDS);
 	}
-	else if (PHRASE_ENABLED (what_about_yehat))
+	else if (PLAYER_SAID (R, wtf_joke))
 	{
-		Response (what_about_yehat, AboutPkunk);
-		InfoLeft = TRUE;
+		DISABLE_PHRASE (wtf_joke);
+		NPCPhrase (PHILO_JOKE);
 	}
-	if (PHRASE_ENABLED (what_about_culture))
+	else if (PLAYER_SAID (R, brick))
 	{
-		Response (what_about_culture, AboutPkunk);
-		InfoLeft = TRUE;
+		DISABLE_PHRASE (brick);
+		NPCPhrase (YOU_KNOW_ALL);
 	}
-	else if (PHRASE_ENABLED (elaborate_culture))
+	else if (PLAYER_SAID (R, important))
 	{
-		Response (elaborate_culture, AboutPkunk);
-		InfoLeft = TRUE;
+		DISABLE_PHRASE (important);
+		NPCPhrase (BUSINESS);
 	}
-	if (PHRASE_ENABLED (what_about_future))
+	else if (PLAYER_SAID (R, coming_out))
 	{
-		Response (what_about_future, AboutPkunk);
-		InfoLeft = TRUE;
+		DISABLE_PHRASE (coming_out);
+		NPCPhrase (YOU_WERE_RIGHT);
 	}
-	Response (enough_about_you, PkunkHome);
-
-	if (!InfoLeft)
+	else if (PLAYER_SAID (R, ouija))
 	{
-		DISABLE_PHRASE (what_about_you);
+		DISABLE_PHRASE (ouija);
+		NPCPhrase (EXCUSE);
+		if (GET_GAME_STATE(PKUNK_JOKE) == 0)
+			Joke (R);
 	}
-}
-
-static void
-AboutIlwrath (RESPONSE_REF R)
-{
-	BYTE InfoLeft;
-
-	InfoLeft = FALSE;
-	if (PLAYER_SAID (R, what_about_ilwrath))
-		NPCPhrase (ABOUT_ILWRATH);
-	else if (PLAYER_SAID (R, why_ilwrath_fight))
-	{
-		NPCPhrase (ILWRATH_FIGHT_BECAUSE);
-
-		DISABLE_PHRASE (why_ilwrath_fight);
-	}
-	else if (PLAYER_SAID (R, when_fight_start))
-	{
-		NPCPhrase (FIGHT_START_WHEN);
-
-		DISABLE_PHRASE (when_fight_start);
-	}
-	else if (PLAYER_SAID (R, how_goes_fight))
-	{
-		NPCPhrase (FIGHT_GOES);
-
-		DISABLE_PHRASE (how_goes_fight);
-	}
-	else if (PLAYER_SAID (R, how_stop_fight))
+	else if (PLAYER_SAID (R, glad))
 	{
-		NPCPhrase (STOP_FIGHT_LIKE_SO);
-
-		DISABLE_PHRASE (how_stop_fight);
-	}
-
-	if (PHRASE_ENABLED (why_ilwrath_fight))
-	{
-		Response (why_ilwrath_fight, AboutIlwrath);
-		InfoLeft = TRUE;
-	}
-	if (PHRASE_ENABLED (when_fight_start))
-	{
-		Response (when_fight_start, AboutIlwrath);
-		InfoLeft = TRUE;
-	}
-	if (PHRASE_ENABLED (how_goes_fight))
-	{
-		Response (how_goes_fight, AboutIlwrath);
-		InfoLeft = TRUE;
-	}
-	if (PHRASE_ENABLED (how_stop_fight))
-	{
-		Response (how_stop_fight, AboutIlwrath);
-		InfoLeft = TRUE;
+		DISABLE_PHRASE (glad);
+		NPCPhrase (WELL_MEANT);
 	}
-	Response (enough_ilwrath, PkunkHome);
 
-	if (!InfoLeft)
-	{
-		DISABLE_PHRASE (what_about_ilwrath);
-	}
+	if (PHRASE_ENABLED (thanks))
+		Response (thanks, Guidance);
+	if (PHRASE_ENABLED (how_queen))
+		Response (how_queen, PkunkMain);
+	if (PHRASE_ENABLED (how_is_it))
+	    Response (how_is_it, Court);
+	else if (PHRASE_ENABLED (court))
+		Response (court, Court);
+	if (PHRASE_ENABLED (nafs))
+		Response (nafs, PkunkMain);
+	if (PHRASE_ENABLED (need_help))
+		Response (need_help, PkunkMain);
+	if (PHRASE_ENABLED (spanish))
+		Response (spanish, ExitConversation);
 }
 
-static void
-PkunkHome (RESPONSE_REF R)
+static void Court (RESPONSE_REF R)
 {
-	BYTE NumVisits;
-
-	if (PLAYER_SAID (R, no_conquest))
-		NPCPhrase (GOOD_IDEA);
-	else if (PLAYER_SAID (R, enough_ilwrath))
-		NPCPhrase (OK_ENOUGH_ILWRATH);
-	else if (PLAYER_SAID (R, enough_about_you))
-		NPCPhrase (OK_ENOUGH_ABOUT_US);
-	else if (PLAYER_SAID (R, where_fleet_1)
-			|| PLAYER_SAID (R, where_fleet_2)
-			|| PLAYER_SAID (R, where_fleet_3))
+	static BOOLEAN busy = FALSE;
+	if (PLAYER_SAID (R, how_is_it))
 	{
-		SET_GAME_STATE (PKUNK_SWITCH, 1);
-		if (!(GET_GAME_STATE (PKUNK_MISSION) & 1))
-		{
-			NumVisits = GET_GAME_STATE (PKUNK_RETURN);
-			switch (NumVisits++)
-			{
-				case 0:
-					NPCPhrase (RETURNING_FROM_YEHAT_1);
-					break;
-				case 1:
-					NPCPhrase (RETURNING_FROM_YEHAT_2);
-					--NumVisits;
-					break;
-			}
-			SET_GAME_STATE (PKUNK_RETURN, NumVisits);
-		}
-		else
-		{
-			NumVisits = GET_GAME_STATE (PKUNK_MIGRATE);
-			switch (NumVisits++)
-			{
-				case 0:
-					NPCPhrase (MIGRATING_HOMEWORLD_1);
-					break;
-				case 1:
-					NPCPhrase (MIGRATING_HOMEWORLD_2);
-					break;
-				case 2:
-					NPCPhrase (MIGRATING_HOMEWORLD_3);
-					--NumVisits;
-					break;
-			}
-			SET_GAME_STATE (PKUNK_MIGRATE, NumVisits);
-		}
-
-		NumVisits = GET_GAME_STATE (PKUNK_FLEET) + 1;
-		SET_GAME_STATE (PKUNK_FLEET, NumVisits);
-
-		DISABLE_PHRASE (where_fleet_1);
+		NPCPhrase (SYMBOL);
+		DISABLE_PHRASE(how_is_it);
 	}
-	else if (PLAYER_SAID (R, am_worried_1)
-			|| PLAYER_SAID (R, am_worried_2)
-			|| PLAYER_SAID (R, am_worried_3))
+	else if (PLAYER_SAID (R, court))
 	{
-		NumVisits = GET_GAME_STATE (PKUNK_WORRY);
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (DONT_WORRY_1);
-				break;
-			case 1:
-				NPCPhrase (DONT_WORRY_2);
-				break;
-			case 2:
-				NPCPhrase (DONT_WORRY_3);
-				--NumVisits;
-				break;
-		}
-		SET_GAME_STATE (PKUNK_WORRY, NumVisits);
-
-		DISABLE_PHRASE (am_worried_1);
+		NPCPhrase (CANT);
+		DISABLE_PHRASE(court);
 	}
-	else if (PLAYER_SAID (R, try_to_be_nicer))
+	else if (PLAYER_SAID (R, nicee))
 	{
-		NPCPhrase (CANT_ASK_FOR_MORE);
-		if (!GET_GAME_STATE (CLEAR_SPINDLE))
-		{
-			NPCPhrase (GIVE_SPINDLE);
-
-			SET_GAME_STATE (CLEAR_SPINDLE, 1);
-			SET_GAME_STATE (CLEAR_SPINDLE_ON_SHIP, 1);
-		}
-		NPCPhrase (CAN_BE_FRIENDS);
-
-		SET_GAME_STATE (PKUNK_MANNER, 3);
-		SET_GAME_STATE (PKUNK_VISITS, 0);
-		SET_GAME_STATE (PKUNK_HOME_VISITS, 0);
+		DISABLE_PHRASE (nicee);
+		NPCPhrase (ADAPT);
 	}
-	else if (PLAYER_SAID (R, what_about_ilwrath))
+	else if (PLAYER_SAID (R, queen_different))
 	{
-		NPCPhrase (ABOUT_ILWRATH /* ILWRATH_GONE */);
-
-		DISABLE_PHRASE (what_about_ilwrath);
+		DISABLE_PHRASE (queen_different);
+		heardAdapt = TRUE;
+		busy = TRUE;
+		NPCPhrase (ADAPT2);
 	}
-
-	if (PHRASE_ENABLED (we_conquer) && GET_GAME_STATE (PKUNK_MANNER) == 0)
-	{
-		Response (we_conquer, DiscussConquer);
-	}
-	if (GET_GAME_STATE (PKUNK_ON_THE_MOVE))
+	else if (PLAYER_SAID (R, court_troubles))
 	{
-		if (PHRASE_ENABLED (where_fleet_1) && !GET_GAME_STATE (PKUNK_SWITCH))
-		{
-			switch (GET_GAME_STATE (PKUNK_FLEET))
-			{
-				case 0:
-					Response (where_fleet_1, PkunkHome);
-					break;
-				case 1:
-					Response (where_fleet_2, PkunkHome);
-					break;
-				case 2:
-					Response (where_fleet_3, PkunkHome);
-					break;
-			}
-		}
-		else if (!PHRASE_ENABLED (where_fleet_1)
-				&& PHRASE_ENABLED (am_worried_1)
-				&& (GET_GAME_STATE (PKUNK_MISSION) & 1))
-		{
-			switch (GET_GAME_STATE (PKUNK_WORRY))
-			{
-				case 0:
-					Response (am_worried_1, PkunkHome);
-					break;
-				case 1:
-					Response (am_worried_2, PkunkHome);
-					break;
-				case 2:
-					Response (am_worried_3, PkunkHome);
-					break;
-			}
-		}
+		DISABLE_PHRASE (court_troubles);
+		busy = TRUE;
+		NPCPhrase (COURT_SHIT);
 	}
-	if (!GET_GAME_STATE (PKUNK_SHIP_MONTH))
+	else if (PLAYER_SAID (R, me_help))
 	{
-		construct_response (shared_phrase_buf,
-				we_are_vindicator0,
-				GLOBAL_SIS (CommanderName),
-				we_are_vindicator1,
-				GLOBAL_SIS (ShipName),
-				we_are_vindicator2,
-				(UNICODE*)NULL);
-		DoResponsePhrase (we_are_vindicator0, OfferAlliance, shared_phrase_buf);
+		DISABLE_PHRASE (me_help);
+		NPCPhrase (SAVE_WORLD);
 	}
-	if (PHRASE_ENABLED (what_about_you))
+	else if (PLAYER_SAID (R, you_busy))
 	{
-		Response (what_about_you, AboutPkunk);
+		DISABLE_PHRASE (you_busy);
+		NPCPhrase (ME_BUSY);
 	}
-	if (PHRASE_ENABLED (what_about_ilwrath))
+	else if (PLAYER_SAID (R, delivery))
 	{
-		if (!GET_GAME_STATE (ILWRATH_DECEIVED))
-		{
-			Response (what_about_ilwrath, AboutIlwrath);
-		}
-		else
-		{
-			Response (what_about_ilwrath, PkunkHome);
-		}
+		DISABLE_PHRASE (delivery);
+		NPCPhrase (THINGS_NOT_RIGHT);
 	}
-	Response (bye_friendly, ExitConversation);
-}
-
-static void
-PkunkFriendlySpace (RESPONSE_REF R)
-{
-	BYTE NumVisits;
-
-	if (PLAYER_SAID (R, whats_up_space))
-	{
-		if (ShipsReady ())
-			NPCPhrase (SHIPS_AT_HOME);
-		else
-		{
-			NumVisits = GET_GAME_STATE (PKUNK_INFO);
-			switch (NumVisits++)
-			{
-				case 0:
-					NPCPhrase (GENERAL_INFO_SPACE_1);
-					break;
-				case 1:
-					NPCPhrase (GENERAL_INFO_SPACE_2);
-					break;
-				case 2:
-					NPCPhrase (GENERAL_INFO_SPACE_3);
-					break;
-				case 3:
-					NPCPhrase (GENERAL_INFO_SPACE_4);
-					break;
-				case 4:
-					NPCPhrase (GENERAL_INFO_SPACE_5);
-					break;
-				case 5:
-					NPCPhrase (GENERAL_INFO_SPACE_6);
-					break;
-				case 6:
-					NPCPhrase (GENERAL_INFO_SPACE_7);
-					break;
-				case 7:
-					NPCPhrase (GENERAL_INFO_SPACE_8);
-					--NumVisits;
-					break;
-			}
-			SET_GAME_STATE (PKUNK_INFO, NumVisits);
-		}
-
-		DISABLE_PHRASE (whats_up_space);
-	}
-	else if (PLAYER_SAID (R, how_goes_war))
-	{
-		NumVisits = GET_GAME_STATE (PKUNK_WAR);
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (WAR_GOES_1);
-				SET_GAME_STATE (KNOW_URQUAN_STORY, 1);
-				SET_GAME_STATE (KNOW_KOHR_AH_STORY, 1);
-				break;
-			case 1:
-				NPCPhrase (WAR_GOES_2);
-				break;
-			case 2:
-				NPCPhrase (WAR_GOES_3);
-				break;
-			case 3:
-				NPCPhrase (WAR_GOES_4);
-				SET_GAME_STATE (PKUNK_DONE_WAR, 1);
-				--NumVisits;
-				break;
-		}
-		SET_GAME_STATE (PKUNK_WAR, NumVisits);
-
-		DISABLE_PHRASE (how_goes_war);
-	}
-	else if (PLAYER_SAID (R, tell_my_fortune))
-	{
-		NumVisits = GET_GAME_STATE (PKUNK_FORTUNE);
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (FORTUNE_IS_1);
-				break;
-			case 1:
-				NPCPhrase (FORTUNE_IS_2);
-				break;
-			case 2:
-				NPCPhrase (FORTUNE_IS_3);
-				break;
-			case 3:
-				NPCPhrase (FORTUNE_IS_4);
-				break;
-			case 4:
-				NPCPhrase (FORTUNE_IS_5);
-				break;
-			case 5:
-				NPCPhrase (FORTUNE_IS_6);
-				break;
-			case 6:
-				NPCPhrase (FORTUNE_IS_7);
-				break;
-			case 7:
-				NPCPhrase (FORTUNE_IS_8);
-				--NumVisits;
-				break;
-		}
-		SET_GAME_STATE (PKUNK_FORTUNE, NumVisits);
-
-		DISABLE_PHRASE (tell_my_fortune);
-	}
-
-	if (PHRASE_ENABLED (whats_up_space))
-		Response (whats_up_space, PkunkFriendlySpace);
-	if (!GET_GAME_STATE (PKUNK_DONE_WAR) && PHRASE_ENABLED (how_goes_war))
-		Response (how_goes_war, PkunkFriendlySpace);
-	if (PHRASE_ENABLED (tell_my_fortune))
-		Response (tell_my_fortune, PkunkFriendlySpace);
-	Response (friendly_bye_space, ExitConversation);
+	
+	if (!heardAdapt)
+		Response(queen_different, Court);
+	if (PHRASE_ENABLED (court_troubles))
+		Response (court_troubles, Court);
+	if (PHRASE_ENABLED (me_help))
+		Response (me_help, Court);
+	if ((busy) && (PHRASE_ENABLED (you_busy)))
+		Response (you_busy, Court);
+	if (PHRASE_ENABLED (interesting))
+		Response (interesting, PkunkMain);
+	else
+		Response (sorry, PkunkMain);
 }
 
-static void
-PkunkNeutralSpace (RESPONSE_REF R)
+static void Mmmm (RESPONSE_REF R)
 {
-	BYTE NumVisits;
+	static BOOLEAN asked = FALSE;
 
-	if (PLAYER_SAID (R, form_alliance))
+	if (PLAYER_SAID (R, uh_hi))
 	{
-		NPCPhrase (GO_TO_HOMEWORLD);
-
-		DISABLE_PHRASE (form_alliance);
+		DISABLE_PHRASE (uh_hi);
+		asked = TRUE;
+		NPCPhrase (MMM);
 	}
-	else if (PLAYER_SAID (R, can_you_help))
+	else if (PLAYER_SAID (R, yes_mmm))
 	{
-		NPCPhrase (GO_TO_HOMEWORLD_AGAIN);
-
-		DISABLE_PHRASE (can_you_help);
+		DISABLE_PHRASE (yes_mmm);
+		NPCPhrase (MMMUUU);
 	}
-	else if (PLAYER_SAID (R, hostile_greeting))
+	else if (PLAYER_SAID (R, see_me))
 	{
-		NPCPhrase (DONT_BE_HOSTILE);
-
-		DISABLE_PHRASE (hostile_greeting);
-	}
-	else if (PLAYER_SAID (R, whats_up_neutral))
-	{
-		NumVisits = GET_GAME_STATE (PKUNK_INFO);
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (GENERAL_INFO_SPACE_1);
-				break;
-			case 1:
-				NPCPhrase (GENERAL_INFO_SPACE_2);
-				break;
-			case 2:
-				NPCPhrase (GENERAL_INFO_SPACE_6 /* was 3 */);
-				break;
-			case 3:
-				NPCPhrase (GENERAL_INFO_SPACE_7 /* was 4 */);
-				--NumVisits;
-				break;
-		}
-		SET_GAME_STATE (PKUNK_INFO, NumVisits);
-
-		DISABLE_PHRASE (whats_up_neutral);
+		DISABLE_PHRASE (see_me);
+		NPCPhrase (MMMMMM);
 	}
-
-	if (PHRASE_ENABLED (form_alliance))
-		Response (form_alliance, PkunkNeutralSpace);
-	else if (PHRASE_ENABLED (can_you_help))
-		Response (can_you_help, PkunkNeutralSpace);
-	if (PHRASE_ENABLED (hostile_greeting))
-		Response (hostile_greeting, PkunkNeutralSpace);
-	else
+	else if (PLAYER_SAID (R, mm))
 	{
-		Response (obey, ExitConversation);
+		DISABLE_PHRASE (mm);
+		NPCPhrase (MREORM);
 	}
-	if (PHRASE_ENABLED (whats_up_neutral))
-		Response (whats_up_neutral, PkunkNeutralSpace);
-	Response (neutral_bye_space, ExitConversation);
+	
+	
+	if (PHRASE_ENABLED (uh_hi))
+		Response (uh_hi, Mmmm);
+	if ((asked) && (PHRASE_ENABLED (yes_mmm)))
+		Response (yes_mmm, Mmmm);
+	if (PHRASE_ENABLED (see_me))
+		Response (see_me, Mmmm);
+	if (PHRASE_ENABLED (mm))
+		Response (mm, Mmmm);
+	Response (later, ExitConversation);
 }
 
-static void
-PkunkMigrate (RESPONSE_REF R)
+static void Orly (RESPONSE_REF R)
 {
-	BYTE ReasonMask;
-	(void) R;  // ignored
-
-	ReasonMask = GET_GAME_STATE (PKUNK_REASONS);
-	if (!(ReasonMask & GOOD_REASON_1))
-		Response (good_reason_1, ExitConversation);
-	if (!(ReasonMask & BAD_REASON_1))
-		Response (bad_reason_1, ExitConversation);
-	if (!(ReasonMask & GOOD_REASON_2))
-		Response (good_reason_2, ExitConversation);
-	if (!(ReasonMask & BAD_REASON_2))
-		Response (bad_reason_2, ExitConversation);
-	Response (suit_yourself, ExitConversation);
+	(void) R;
+	if (PHRASE_ENABLED (did_we_speak))
+		Response (did_we_speak, PkunkMain);
+	if (PHRASE_ENABLED (astral))
+		Response (astral, Joke);
+	if (PHRASE_ENABLED (nicee))
+		Response (nicee, Court);
 }
 
+
 static void
 Intro (void)
 {
-	BYTE NumVisits, Manner;
-
-	if (LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
+	if (GET_GAME_STATE (PKUNK_MANNER) == 0)
 	{
-		NPCPhrase (OUT_TAKES);
-
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
-		return;
-	}
-
-	Manner = GET_GAME_STATE (PKUNK_MANNER);
-	if (Manner == 2)
-	{
-		// Irreparably Pissed off the Pkunk.
-		NumVisits = GET_GAME_STATE (PKUNK_VISITS);
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (HATE_YOU_FOREVER_1);
-				break;
-			case 1:
-				NPCPhrase (HATE_YOU_FOREVER_2);
-				break;
-			case 2:
-				NPCPhrase (HATE_YOU_FOREVER_3);
-				break;
-			case 3:
-				NPCPhrase (HATE_YOU_FOREVER_4);
-				--NumVisits;
-				break;
-		}
-		SET_GAME_STATE (PKUNK_VISITS, NumVisits);
-
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
-	}
-	else if (Manner == 1)
-	{
-		// Bad relations with the Pkunk, but not irreparably.
-		NumVisits = GET_GAME_STATE (PKUNK_VISITS);
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (SPIRITUAL_PROBLEMS_1);
-				break;
-			case 1:
-				NPCPhrase (SPIRITUAL_PROBLEMS_2);
-				break;
-			case 2:
-				NPCPhrase (SPIRITUAL_PROBLEMS_3);
-				break;
-			case 3:
-				NPCPhrase (SPIRITUAL_PROBLEMS_4);
-				--NumVisits;
-				break;
-		}
-		SET_GAME_STATE (PKUNK_VISITS, NumVisits);
-
-		PkunkAngry ((RESPONSE_REF)0);
-	}
-	else if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 7))
-	{
-		// Encountering the Pkunk at their home world.
-		if (!GET_GAME_STATE (CLEAR_SPINDLE))
-		{
-			NPCPhrase (GIVE_SPINDLE);
-
-			SET_GAME_STATE (CLEAR_SPINDLE, 1);
-			SET_GAME_STATE (CLEAR_SPINDLE_ON_SHIP, 1);
-		}
-		else if (!GET_GAME_STATE (PKUNK_SENSE_VICTOR)
-				&& GLOBAL (GameClock.year_index) > START_YEAR
-				&& !GET_GAME_STATE (KOHR_AH_FRENZY))
-		{
-			NPCPhrase (SENSE_KOHRAH_VICTORY);
-
-			SET_GAME_STATE (PKUNK_SENSE_VICTOR, 1);
-		}
-
-		NumVisits = GET_GAME_STATE (PKUNK_HOME_VISITS);
-		if (Manner == 0)
-		{
-			switch (NumVisits++)
-			{
-				case 0:
-					NPCPhrase (NEUTRAL_HOMEWORLD_HELLO_1);
-					break;
-				case 1:
-					NPCPhrase (NEUTRAL_HOMEWORLD_HELLO_2);
-					break;
-				case 2:
-					NPCPhrase (NEUTRAL_HOMEWORLD_HELLO_3);
-					break;
-				case 3:
-					NPCPhrase (NEUTRAL_HOMEWORLD_HELLO_4);
-					--NumVisits;
-					break;
-			}
-		}
-		else
-		{
-			if (NumVisits && ShipsReady ())
-			{
-				if (ActivateStarShip (PKUNK_SHIP, FEASIBILITY_STUDY) == 0)
-					NPCPhrase (NO_ROOM);
-				else
-				{
-					NPCPhrase (SHIP_GIFT);
-					PrepareShip ();
-				}
-			}
-			else switch (NumVisits++)
-			{
-				case 0:
-					NPCPhrase (FRIENDLY_HOMEWORLD_HELLO_1);
-					break;
-				case 1:
-					NPCPhrase (FRIENDLY_HOMEWORLD_HELLO_2);
-					break;
-				case 2:
-					NPCPhrase (FRIENDLY_HOMEWORLD_HELLO_3);
-					break;
-				case 3:
-					NPCPhrase (FRIENDLY_HOMEWORLD_HELLO_4);
-					break;
-				case 4:
-					NPCPhrase (FRIENDLY_HOMEWORLD_HELLO_5);
-					break;
-				case 5:
-					NPCPhrase (FRIENDLY_HOMEWORLD_HELLO_6);
-					break;
-				case 6:
-					NPCPhrase (FRIENDLY_HOMEWORLD_HELLO_7);
-					break;
-				case 7:
-					NPCPhrase (FRIENDLY_HOMEWORLD_HELLO_8);
-					--NumVisits;
-					break;
-			}
-		}
-		SET_GAME_STATE (PKUNK_HOME_VISITS, NumVisits);
-
-		PkunkHome ((RESPONSE_REF)0);
-	}
-	else if ((NumVisits = GET_GAME_STATE (PKUNK_MISSION)) == 0
-			|| !(NumVisits & 1))
-	{
-		// Encountering a Pkunk ship in space, while they are not
-		// migrating.
-		NumVisits = GET_GAME_STATE (PKUNK_VISITS);
-		if (Manner == 3)
-		{
-			switch (NumVisits++)
-			{
-				case 0:
-					NPCPhrase (FRIENDLY_SPACE_HELLO_1);
-					break;
-				case 1:
-					NPCPhrase (FRIENDLY_SPACE_HELLO_2);
-					break;
-				case 2:
-					NPCPhrase (FRIENDLY_SPACE_HELLO_3);
-					break;
-				case 3:
-					NPCPhrase (FRIENDLY_SPACE_HELLO_4);
-					break;
-				case 4:
-					NPCPhrase (FRIENDLY_SPACE_HELLO_5);
-					break;
-				case 5:
-					NPCPhrase (FRIENDLY_SPACE_HELLO_6);
-					break;
-				case 6:
-					NPCPhrase (FRIENDLY_SPACE_HELLO_7);
-					break;
-				case 7:
-					NPCPhrase (FRIENDLY_SPACE_HELLO_8);
-					--NumVisits;
-					break;
-			}
-
-			PkunkFriendlySpace ((RESPONSE_REF)0);
-		}
-		else
-		{
-			switch (NumVisits++)
-			{
-				case 0:
-					NPCPhrase (NEUTRAL_SPACE_HELLO_1);
-					break;
-				case 1:
-					NPCPhrase (NEUTRAL_SPACE_HELLO_2);
-					break;
-				case 2:
-					NPCPhrase (NEUTRAL_SPACE_HELLO_3);
-					break;
-				case 3:
-					NPCPhrase (NEUTRAL_SPACE_HELLO_4);
-					--NumVisits;
-					break;
-			}
-
-			PkunkNeutralSpace ((RESPONSE_REF)0);
-		}
-		SET_GAME_STATE (PKUNK_VISITS, NumVisits);
-
+		NPCPhrase (WONDERFUL);
+		Orly ((RESPONSE_REF)0);
 	}
 	else
 	{
-		// Encountering a Pkunk ship in space, while they are
-		// migrating.
-		NumVisits = GET_GAME_STATE (PKUNK_MIGRATE_VISITS);
-		switch (NumVisits++)
+		switch (TFB_Random() % 3)
 		{
-			case 0:
-				NPCPhrase (MIGRATING_SPACE_1);
-				break;
-			case 1:
-				NPCPhrase (MIGRATING_SPACE_2);
-				break;
-			case 2:
-				NPCPhrase (MIGRATING_SPACE_3);
-				break;
-			case 3:
-				NPCPhrase (MIGRATING_SPACE_4);
-				break;
-			case 4:
-				NPCPhrase (MIGRATING_SPACE_5);
-				break;
-			case 5:
-				NPCPhrase (MIGRATING_SPACE_6);
-				break;
-			case 6:
-				NPCPhrase (MIGRATING_SPACE_7);
-				break;
-			case 7:
-				NPCPhrase (MIGRATING_SPACE_8);
-				--NumVisits;
-				break;
+		case 0:
+			NPCPhrase(MMMM);
+			Mmmm ((RESPONSE_REF)0);
+			break;
+		case 1:
+			NPCPhrase(WELCOME_BACK);
+			Court ((RESPONSE_REF)0);
+			break;
+		case 2:
+		default:
+			NPCPhrase(HOWDY);
+			PkunkMain ((RESPONSE_REF)0);
+			break;
 		}
-		SET_GAME_STATE (PKUNK_MIGRATE_VISITS, NumVisits);
-
-		PkunkMigrate ((RESPONSE_REF)0);
 	}
 }
 
@@ -1102,18 +404,7 @@ uninit_pkunk (void)
 static void
 post_pkunk_enc (void)
 {
-	BYTE Manner;
 
-	if (GET_GAME_STATE (BATTLE_SEGUE) == 1
-			&& (Manner = GET_GAME_STATE (PKUNK_MANNER)) != 2)
-	{
-		SET_GAME_STATE (PKUNK_MANNER, 1);
-		if (Manner != 1)
-		{
-			SET_GAME_STATE (PKUNK_VISITS, 0);
-			SET_GAME_STATE (PKUNK_HOME_VISITS, 0);
-		}
-	}
 }
 
 LOCDATA*
@@ -1121,7 +412,7 @@ init_pkunk_comm (void)
 {
 	LOCDATA *retval;
 
-	pkunk_desc.init_encounter_func = Intro;
+	pkunk_desc.init_encounter_func = cm_intro; // entry point for conversation manager
 	pkunk_desc.post_encounter_func = post_pkunk_enc;
 	pkunk_desc.uninit_encounter_func = uninit_pkunk;
 
@@ -1129,18 +420,10 @@ init_pkunk_comm (void)
 	pkunk_desc.AlienTextBaseline.y = 0;
 	pkunk_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
 
-	if (GET_GAME_STATE (PKUNK_MANNER) == 3
-			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
-	{
-		// Enter communications immediately.
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
-	}
-	else
-	{
-		// Ask the player whether to attack or talk.
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
-	}
+	SET_GAME_STATE (BATTLE_SEGUE, 0);
+
 	retval = &pkunk_desc;
+  prep_conversation_module("pkunk", retval); // set up conversation manager
 
 	return (retval);
 }
diff -ruNp src.orig/uqm/comm/pkunk/strings.h src/uqm/comm/pkunk/strings.h
--- src.orig/uqm/comm/pkunk/strings.h	2017-11-01 15:30:23 -0700
+++ src/uqm/comm/pkunk/strings.h	2017-11-01 15:31:01 -0700
@@ -22,193 +22,68 @@
 enum
 {
 	NULL_PHRASE,
-	GIVE_SPINDLE,
-	name_1,
-	name_2,
-	name_3,
-	name_40,
-	name_41,
-	NEUTRAL_SPACE_HELLO_1,
-	NEUTRAL_SPACE_HELLO_3,
-	NEUTRAL_SPACE_HELLO_2,
-	NEUTRAL_SPACE_HELLO_4,
-	FRIENDLY_SPACE_HELLO_1,
-	FRIENDLY_SPACE_HELLO_2,
-	FRIENDLY_SPACE_HELLO_3,
-	FRIENDLY_SPACE_HELLO_4,
-	FRIENDLY_SPACE_HELLO_5,
-	FRIENDLY_SPACE_HELLO_6,
-	FRIENDLY_SPACE_HELLO_7,
-	FRIENDLY_SPACE_HELLO_8,
-	NEUTRAL_HOMEWORLD_HELLO_1,
-	NEUTRAL_HOMEWORLD_HELLO_2,
-	NEUTRAL_HOMEWORLD_HELLO_3,
-	NEUTRAL_HOMEWORLD_HELLO_4,
-	FRIENDLY_HOMEWORLD_HELLO_1,
-	FRIENDLY_HOMEWORLD_HELLO_2,
-	FRIENDLY_HOMEWORLD_HELLO_3,
-	FRIENDLY_HOMEWORLD_HELLO_4,
-	FRIENDLY_HOMEWORLD_HELLO_5,
-	FRIENDLY_HOMEWORLD_HELLO_6,
-	FRIENDLY_HOMEWORLD_HELLO_7,
-	FRIENDLY_HOMEWORLD_HELLO_8,
-	whats_up_neutral,
-	GENERAL_INFO_NEUTRAL_1,
-	GENERAL_INFO_NEUTRAL_2,
-	GENERAL_INFO_NEUTRAL_3,
-	GENERAL_INFO_NEUTRAL_4,
-	good_reason_1,
-	WE_GO_HOME_1,
-	good_reason_2,
-	WE_GO_HOME_2,
-	bad_reason_1,
-	NO_GO_HOME_1,
-	bad_reason_2,
-	NO_GO_HOME_2,
-	SENSE_KOHRAH_VICTORY,
-	SPIRITUAL_PROBLEMS_1,
-	SPIRITUAL_PROBLEMS_2,
-	SPIRITUAL_PROBLEMS_3,
-	SPIRITUAL_PROBLEMS_4,
-	HATE_YOU_FOREVER_1,
-	HATE_YOU_FOREVER_2,
-	HATE_YOU_FOREVER_3,
-	HATE_YOU_FOREVER_4,
-	MIGRATING_SPACE_1,
-	MIGRATING_SPACE_2,
-	MIGRATING_SPACE_3,
-	MIGRATING_SPACE_4,
-	MIGRATING_SPACE_5,
-	MIGRATING_SPACE_6,
-	MIGRATING_SPACE_7,
-	MIGRATING_SPACE_8,
-	die_idiot_fools,
-	VERY_WELL,
-	why_insults,
-	RELEASE_TENSION,
-	what_about_you_angry,
-	ABOUT_US_ANGRY,
-	what_about_you,
-	should_be_friends,
-	YES_FRIENDS,
-	try_to_be_nicer,
-	CANT_ASK_FOR_MORE,
-	VISIT_OUR_HOMEWORLD,
-	CAN_BE_FRIENDS,
-	bye_angry,
-	GOODBYE_ANGRY,
-	we_conquer,
-	WHY_CONQUER,
-	conquer_because_1,
-#if 0
-	NOT_CONQUER_10,
-	NOT_CONQUER_11,
-	NOT_CONQUER_12,
-#endif
-	NOT_CONQUER_1,
-	conquer_because_2,
-	NOT_CONQUER_2,
-	must_conquer,
-	BAD_IDEA,
-	no_conquest,
-	GOOD_IDEA,
-	we_are_vindicator0,
-	we_are_vindicator1,
-	we_are_vindicator2,
-	WHY_YOU_HERE,
-	we_here_to_help,
-	NEED_HELP,
-	we_need_help,
-	GIVE_HELP,
-	exploring_universe,
-	SENSE_DEEPER_CONFLICT,
-	fun_cruise,
-	REPRESS,
-	why_ilwrath_fight,
-	ILWRATH_FIGHT_BECAUSE,
-	when_fight_start,
-	FIGHT_START_WHEN,
-	how_goes_fight,
-	FIGHT_GOES,
-	how_goes_war,
-	WAR_GOES_1,
-	WAR_GOES_2,
-	WAR_GOES_3,
-	WAR_GOES_4,
-	how_stop_fight,
-	STOP_FIGHT_LIKE_SO,
-	enough_ilwrath,
-	OK_ENOUGH_ILWRATH,
-	what_about_history,
-	ABOUT_HISTORY,
-	what_about_yehat,
-	ABOUT_YEHAT,
-	what_about_culture,
-	ABOUT_CULTURE,
-	elaborate_culture,
-	OK_ELABORATE_CULTURE,
-	what_about_future,
-	ABOUT_FUTURE,
-	enough_about_you,
-	OK_ENOUGH_ABOUT_US,
-	ABOUT_US,
-	where_fleet_1,
-	where_fleet_2,
-	where_fleet_3,
-	MIGRATING_HOMEWORLD_1,
-	MIGRATING_HOMEWORLD_2,
-	MIGRATING_HOMEWORLD_3,
-	RETURNING_FROM_YEHAT_1,
-	RETURNING_FROM_YEHAT_2,
-	am_worried_1,
-	am_worried_2,
-	am_worried_3,
-	DONT_WORRY_1,
-	DONT_WORRY_2,
-	DONT_WORRY_3,
-	form_alliance,
-	GO_TO_HOMEWORLD,
-	can_you_help,
-	GO_TO_HOMEWORLD_AGAIN,
-	hostile_greeting,
-	DONT_BE_HOSTILE,
-	obey,
-	NO_OBEY,
-	neutral_bye_space,
-	NEUTRAL_GOODBYE_SPACE,
-	SHIP_GIFT,
-	NO_ROOM,
-	friendly_bye_space,
-	FRIENDLY_GOODBYE_SPACE,
-	bye_friendly,
-	GOODBYE_FRIENDLY,
-	ALMOST_ALLIANCE,
-	INIT_NO_ROOM,
-	INIT_SHIP_GIFT,
-	suit_yourself,
-	GOODBYE_MIGRATION,
-	what_about_ilwrath,
-	ABOUT_ILWRATH,
-	whats_up_space,
-	SHIPS_AT_HOME,
-	GENERAL_INFO_SPACE_1,
-	GENERAL_INFO_SPACE_2,
-	GENERAL_INFO_SPACE_3,
-	GENERAL_INFO_SPACE_4,
-	GENERAL_INFO_SPACE_5,
-	GENERAL_INFO_SPACE_6,
-	GENERAL_INFO_SPACE_7,
-	GENERAL_INFO_SPACE_8,
-	tell_my_fortune,
-	FORTUNE_IS_1,
-	FORTUNE_IS_2,
-	FORTUNE_IS_3,
-	FORTUNE_IS_4,
-	FORTUNE_IS_5,
-	FORTUNE_IS_6,
-	FORTUNE_IS_7,
-	FORTUNE_IS_8,
-	OUT_TAKES,
+	WONDERFUL,
+	MMMM,
+	WELCOME_BACK,
+	HOWDY,
+	did_we_speak,
+	ONE_AS_ALL,
+	astral,
+	PHOTOGRAPHS,
+	nicee,
+	ADAPT,
+	thanks,
+	GUIDANCE,
+	how_queen,
+	REBEL_RANT,
+	how_is_it,
+	SYMBOL,
+	court,
+	CANT,
+	nafs,
+	WAY_BETTER,
+	need_help,
+	COSMOLOGY,
+	spanish,
+	ADIOS1,
+	ADIOS2,
+	queen_different,
+	ADAPT2,
+	court_troubles,
+	COURT_SHIT,
+	me_help,
+	SAVE_WORLD,
+	you_busy,
+	ME_BUSY,
+	interesting,
+	MELTINGPOT,
+	sorry,
+	WORDS,
+	JOKE,
+	wtf_joke,
+	PHILO_JOKE,
+	brick,
+	YOU_KNOW_ALL,
+	delivery,
+	THINGS_NOT_RIGHT,
+	important,
+	BUSINESS,
+	coming_out,
+	YOU_WERE_RIGHT,
+	ouija,
+	EXCUSE,
+	glad,
+	WELL_MEANT,
+	uh_hi,
+	MMM,
+	yes_mmm,
+	MMMUUU,
+	see_me,
+	MMMMMM,
+	mm,
+	MREORM,
+	later,
+	MMM_EXIT
 };
 
 #endif /* _STRINGS_H */
diff -ruNp src.orig/uqm/comm/rebel/rebel.c src/uqm/comm/rebel/rebel.c
--- src.orig/uqm/comm/rebel/rebel.c	2017-11-01 15:30:23 -0700
+++ src/uqm/comm/rebel/rebel.c	2017-11-01 15:31:01 -0700
@@ -25,6 +25,7 @@
 
 static LOCDATA yehat_desc =
 {
+	YEHAT_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -190,6 +191,11 @@ static LOCDATA yehat_desc =
 	NULL, NULL, NULL,
 	NULL,
 	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
 };
 
 static void
@@ -436,7 +442,7 @@ init_rebel_yehat_comm (void)
 	yehat_desc.uninit_encounter_func = uninit_yehat;
 
 	yehat_desc.AlienTextBaseline.x = SIS_SCREEN_WIDTH * 2 / 3;
-	yehat_desc.AlienTextBaseline.y = 60;
+	yehat_desc.AlienTextBaseline.y = RES_SIS_SCALE(60);
 	yehat_desc.AlienTextWidth = (SIS_TEXT_WIDTH - 16) * 2 / 3;
 
 	// use alternate "Rebels" track if available
diff -ruNp src.orig/uqm/comm/shofixt/shofixt.c src/uqm/comm/shofixt/shofixt.c
--- src.orig/uqm/comm/shofixt/shofixt.c	2017-11-01 15:30:23 -0700
+++ src/uqm/comm/shofixt/shofixt.c	2017-11-01 15:31:01 -0700
@@ -16,15 +16,27 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: -Added viewscreen animu
+//			 -Added some dialogue options
+//			 -Lost shofixti patrols sidequest, one of 3 patrols returns home after 2 months
+
 #include "../commall.h"
 #include "resinst.h"
 #include "strings.h"
 
+#include "uqm/races.h"
+#include "uqm/grpinfo.h"
 #include "uqm/gameev.h"
+#include "uqm/encount.h"
+// BW: for EncounterGroup, no longer included in commall.h
+
+#include "libs/mathlib.h" // for TFB_Random
+#include "libs/log.h"
 
 
 static LOCDATA shofixti_desc =
 {
+	SHOFIXTI_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -41,92 +53,99 @@ static LOCDATA shofixti_desc =
 	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	SHOFIXTI_CONVERSATION_PHRASES, /* PlayerPhrases */
-	11, /* NumAnimations */
+	12, /* NumAnimations */
 	{ /* AlienAmbientArray (ambient animations) */
-		{
-			5, /* StartIndex */
-			15, /* NumFrames */
+		{ /* 0 bottom left star */
+			1, /* StartIndex */
+			6, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* RestartRate */
+			(1 << 2), /* BlockMask */
+		},
+		{ /* 1 bottom right star */
+			7, /* StartIndex */
+			6, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* RestartRate */
+			(1 << 3), /* BlockMask */
+		},
+		{ /* 2 top left star */
+			13, /* StartIndex */
+			5, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* RestartRate */
+			(1 << 0), /* BlockMask */
+		},
+		{ /* 3 top right star */
+			18, /* StartIndex */
+			5, /* NumFrames */
 			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* RestartRate */
+			(1 << 1), /* BlockMask */
+		},
+		{ /* 4 eye blink */
+			23, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
 			ONE_SECOND / 30, 0, /* FrameRate */
-			ONE_SECOND / 30, 0, /* RestartRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
 			0, /* BlockMask */
 		},
-		{
-			20, /* StartIndex */
+		{ /* 5 right hand */
+			26, /* StartIndex */
 			3, /* NumFrames */
 			RANDOM_ANIM, /* AnimFlags */
 			ONE_SECOND / 10, 0, /* FrameRate */
 			(ONE_SECOND >> 1), (ONE_SECOND >> 1) * 3, /* RestartRate */
 			0, /* BlockMask */
 		},
-		{
-			23, /* StartIndex */
-			3, /* NumFrames */
-			RANDOM_ANIM, /* AnimFlags */
+		{ /* 6 radar */
+			34, /* StartIndex */
+			8, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
 			ONE_SECOND / 10, 0, /* FrameRate */
-			(ONE_SECOND >> 1), (ONE_SECOND >> 1) * 3, /* RestartRate */
+			ONE_SECOND / 10, 0, /* RestartRate */
 			0, /* BlockMask */
 		},
-		{
-			26, /* StartIndex */
+		{ /* 7 left hand */
+			42, /* StartIndex */
 			3, /* NumFrames */
-			YOYO_ANIM, /* AnimFlags */
-			ONE_SECOND / 30, 0, /* FrameRate */
-			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
-			0, /* BlockMask */
-		},
-		{
-			29, /* StartIndex */
-			4, /* NumFrames */
-			YOYO_ANIM, /* AnimFlags */
-			ONE_SECOND / 15, 0, /* FrameRate */
-			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, 0, /* FrameRate */
+			(ONE_SECOND >> 1), (ONE_SECOND >> 1) * 3, /* RestartRate */
 			0, /* BlockMask */
 		},
-
-		{
-			33, /* StartIndex */
+		{ /* 8 upper-middle left star */
+			45, /* StartIndex */
 			6, /* NumFrames */
 			CIRCULAR_ANIM, /* AnimFlags */
 			ONE_SECOND / 20, ONE_SECOND / 30, /* FrameRate */
 			ONE_SECOND / 20, ONE_SECOND / 30, /* RestartRate */
-			0, /* BlockMask */
-		},
-		{
-			39, /* StartIndex */
-			7, /* NumFrames */
-			CIRCULAR_ANIM, /* AnimFlags */
-			ONE_SECOND / 20, ONE_SECOND / 30, /* FrameRate */
-			ONE_SECOND / 20, ONE_SECOND / 30, /* RestartRate */
-			(1 << 7), /* BlockMask */
+			(1 << 10), /* BlockMask */
 		},
-		{
-			46, /* StartIndex */
+		{ /* 9 upper-middle right star */
+			51, /* StartIndex */
 			6, /* NumFrames */
 			CIRCULAR_ANIM, /* AnimFlags */
 			ONE_SECOND / 20, ONE_SECOND / 30, /* FrameRate */
 			ONE_SECOND / 20, ONE_SECOND / 30, /* RestartRate */
-			(1 << 6), /* BlockMask */
-		},
-		{
-			52, /* StartIndex */
-			4, /* NumFrames */
-			CIRCULAR_ANIM, /* AnimFlags */
-			ONE_SECOND / 20, ONE_SECOND / 30, /* FrameRate */
-			ONE_SECOND / 20, ONE_SECOND / 30, /* RestartRate */
-			0, /* BlockMask */
+			(1 << 11), /* BlockMask */
 		},
-		{
-			56, /* StartIndex */
-			7, /* NumFrames */
+		{ /* 10 lower-middle left star */
+			57, /* StartIndex */
+			5, /* NumFrames */
 			CIRCULAR_ANIM, /* AnimFlags */
 			ONE_SECOND / 20, ONE_SECOND / 30, /* FrameRate */
 			ONE_SECOND / 20, ONE_SECOND / 30, /* RestartRate */
-			(1 << 10), /* BlockMask */
+			(1 << 8), /* BlockMask */
 		},
-		{
-			63, /* StartIndex */
-			6, /* NumFrames */
+		{  /* 11 lower-middle right star */
+			62, /* StartIndex */
+			5, /* NumFrames */
 			CIRCULAR_ANIM, /* AnimFlags */
 			ONE_SECOND / 20, ONE_SECOND / 30, /* FrameRate */
 			ONE_SECOND / 20, ONE_SECOND / 30, /* RestartRate */
@@ -142,8 +161,8 @@ static LOCDATA shofixti_desc =
 		0, /* BlockMask */
 	},
 	{ /* AlienTalkDesc */
-		1, /* StartIndex */
-		4, /* NumFrames */
+		29, /* StartIndex */
+		5, /* NumFrames */
 		0, /* AnimFlags */
 		ONE_SECOND / 20, 0, /* FrameRate */
 		ONE_SECOND / 15, 0, /* RestartRate */
@@ -154,430 +173,373 @@ static LOCDATA shofixti_desc =
 	NULL, NULL, NULL,
 	NULL,
 	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
 };
 
-static RESPONSE_REF shofixti_name;
-
 static void
-GetShofixtiName (void)
-{
-	if (GET_GAME_STATE (SHOFIXTI_KIA))
-		shofixti_name = katana;
-	else
-		shofixti_name = tanaka;
-}
+SmallTalk2 (RESPONSE_REF R);
 
+// Religious Shofixti groups have different goodbyes than tech-oriented groups.
 static void
 ExitConversation (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 1);
-
-	if (PLAYER_SAID (R, bye0))
+	BYTE ThisGroupIsReligious = GET_GAME_STATE (SHOFIXTI_RELIGIOUS_GROUP); // Set already in Intro
+	
+	if (PLAYER_SAID (R, no_joke_attack))
 	{
-		NPCPhrase (GOODBYE);
-
+		NPCPhrase (KYAIEE);
+		SET_GAME_STATE (SHOFIXTI_ANGRY, 2);
+		SET_GAME_STATE (BATTLE_SEGUE, 1);
+	}	
+	else if (PLAYER_SAID (R, farewell_shofixti))
+	{
+		BYTE RandomGoodbye = 1 + (TFB_Random () % 4);
+		
+		if (GET_GAME_STATE(SHOFIXTI_ANGRY) > 0)
+		{
+			NPCPhrase (MIFFED_GOODBYE_EARTHLING);
+		}
+		else if (ThisGroupIsReligious)
+		{
+			switch (RandomGoodbye)
+			{
+				case 1:
+					NPCPhrase (GOODBYE_RELIGIOUS_EARTHLING_1);
+					break;
+				case 2:
+					NPCPhrase (GOODBYE_RELIGIOUS_EARTHLING_2);
+					break;
+				case 3:
+					NPCPhrase (GOODBYE_RELIGIOUS_EARTHLING_3);
+					break;
+				case 4:
+					NPCPhrase (GOODBYE_RELIGIOUS_EARTHLING_4);
+					break;
+			}
+		}
+		else
+		{
+			switch (RandomGoodbye)
+			{
+				case 1:
+					NPCPhrase (GOODBYE_TECH_EARTHLING_1);
+					break;
+				case 2:
+					NPCPhrase (GOODBYE_TECH_EARTHLING_2);
+					break;
+				case 3:
+					NPCPhrase (GOODBYE_TECH_EARTHLING_3);
+					break;
+				case 4:
+					NPCPhrase (GOODBYE_TECH_EARTHLING_4);
+					break;	
+			}
+		}
 		SET_GAME_STATE (BATTLE_SEGUE, 0);
 	}
-	else if (PLAYER_SAID (R, go_ahead))
+	else if (PLAYER_SAID (R, will_attack))
 	{
-		NPCPhrase (ON_SECOND_THOUGHT);
-
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
-	}
-	else if (PLAYER_SAID (R, need_you_for_duty))
+		NPCPhrase (WILL_ATTACK_TOO);
+		SET_GAME_STATE (SHOFIXTI_ANGRY, 3);
+		SET_GAME_STATE (BATTLE_SEGUE, 1);
+	}	
+	else if (PLAYER_SAID (R, sorry))
 	{
-		NPCPhrase (OK_WILL_BE_SENTRY);
-
+		NPCPhrase (SORRY_ACCEPTED);
+		SET_GAME_STATE (SHOFIXTI_ANGRY, 1);
 		SET_GAME_STATE (BATTLE_SEGUE, 0);
 	}
-	else if (PLAYER_SAID (R, females)
-			|| PLAYER_SAID (R, nubiles)
-			|| PLAYER_SAID (R, rat_babes))
-	{
-		NPCPhrase (LEAPING_HAPPINESS);
 
-		SET_GAME_STATE (SHOFIXTI_RECRUITED, 1);
-		SET_GAME_STATE (MAIDENS_ON_SHIP, 0);
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+}
 
-		AddEvent (RELATIVE_EVENT, 2, 0, 0, SHOFIXTI_RETURN_EVENT);
-	}
-	else if (PLAYER_SAID (R, dont_attack))
+static void
+HowReconstruction (RESPONSE_REF R)
+{	
+	BYTE ThisGroupIsReligious;
+	
+	(void) R; // satisfy compiler
+	ThisGroupIsReligious = GET_GAME_STATE (SHOFIXTI_RELIGIOUS_GROUP); // Set already in Intro
+	
+	/* Shofixti answers */
+	
+	if (GET_GAME_STATE(SHOFIXTI_ANGRY) > 0)
+		NPCPhrase (NOT_GOOD_RECONSTRUCTION_PRE_MIFFED);
+	else
+		NPCPhrase (NOT_GOOD_RECONSTRUCTION_PRE);
+	
+	if (ThisGroupIsReligious)
 	{
-		NPCPhrase (TYPICAL_PLOY);
-
-		SET_GAME_STATE (SHOFIXTI_STACK1, 1);
+		NPCPhrase (RECONSTRUCTION_KISHIBOJIN); // Religious faction
+		SET_GAME_STATE(SHOFIXTI_RELIGIOUS_MET, 1);
 	}
-	else if (PLAYER_SAID (R, hey_stop))
+	else
 	{
-		NPCPhrase (ONLY_STOP);
-
-		SET_GAME_STATE (SHOFIXTI_STACK1, 2);
+		NPCPhrase (RECONSTRUCTION_TECHNOLOGY); // Tech faction
+		SET_GAME_STATE(SHOFIXTI_TECH_MET, 1);
 	}
-	else if (PLAYER_SAID (R, look_you_are))
-	{
-		NPCPhrase (TOO_BAD);
 
-		SET_GAME_STATE (SHOFIXTI_STACK1, 3);
-	}
-	else if (PLAYER_SAID (R, no_one_insults))
-	{
-		NPCPhrase (YOU_LIMP);
+	DISABLE_PHRASE (how_goes_reconstruction);	
 
-		SET_GAME_STATE (SHOFIXTI_STACK2, 1);
-	}
-	else if (PLAYER_SAID (R, mighty_words))
-	{
-		NPCPhrase (HANG_YOUR);
+	
+	/* Player's answers */
+	
+	if (ThisGroupIsReligious)
+		Response (who_is_kishibojin, SmallTalk2);
+	else
+		Response (sorry_to_hear, SmallTalk2);
+	
+	if (PHRASE_ENABLED (ask_scar))
+		Response (ask_scar, SmallTalk2);
+	
+	Response (farewell_shofixti, ExitConversation);
+}
 
-		SET_GAME_STATE (SHOFIXTI_STACK2, 2);
-	}
-	else if (PLAYER_SAID (R, dont_know))
+static void
+SmallTalk2 (RESPONSE_REF R)
+{	
+	/* Shofixti answers */
+	
+	if (PLAYER_SAID (R, sorry_to_hear))
 	{
-		NPCPhrase (NEVER);
+		if (GET_GAME_STATE(SHOFIXTI_ANGRY) > 0)
+			NPCPhrase (THANK_YOU_MIFFED);
+		else
+			NPCPhrase (THANK_YOU);
+		
+		DISABLE_PHRASE (sorry_to_hear);
+	}	
+	else if (PLAYER_SAID (R, who_is_kishibojin))
+	{
+		NPCPhrase (SHE_IS_KISHIBOJIN);
 
-		SET_GAME_STATE (SHOFIXTI_STACK3, 1);
+		DISABLE_PHRASE (who_is_kishibojin);
 	}
-	else if (PLAYER_SAID (R, look0))
+	else if (PLAYER_SAID (R, you_talk_differently_tech))
 	{
-		NPCPhrase (FOR_YOU);
+		NPCPhrase (YOU_MET_RELIGIOUS);
 
-		SET_GAME_STATE (SHOFIXTI_STACK3, 2);
+		DISABLE_PHRASE (you_talk_differently_tech);
 	}
-	else if (PLAYER_SAID (R, no_bloodshed))
+	else if (PLAYER_SAID (R, you_talk_differently_religious))
 	{
-		NPCPhrase (YES_BLOODSHED);
-
-		SET_GAME_STATE (SHOFIXTI_STACK3, 3);
+		NPCPhrase (YOU_MET_NONBELIEVERS);
+		
+		DISABLE_PHRASE (you_talk_differently_religious);
 	}
-	else if (PLAYER_SAID (R, dont_want_to_fight))
+	
+	else if (PLAYER_SAID (R, where_patrol)
+		|| PLAYER_SAID (R, where_patrol_2))
 	{
-		BYTE NumVisits;
-
-		NumVisits = GET_GAME_STATE (SHOFIXTI_STACK4);
-		switch (NumVisits++)
+		if (PLAYER_SAID (R, where_patrol_2))
+			NPCPhrase (HERE_GOES);
+			
+		NPCPhrase (LOST_PATROLS);
+		
+		if (GET_GAME_STATE(SHOFIXTI_PATROL_RETURNED))
+			NPCPhrase (TWO_PATROLS_MISSING);
+		else
+			NPCPhrase (THREE_PATROLS_MISSING);
+		
+		if (PLAYER_SAID (R, where_patrol))
 		{
-			case 0:
-				NPCPhrase (MUST_FIGHT_YOU_URQUAN_1);
-				break;
-			case 1:
-				NPCPhrase (MUST_FIGHT_YOU_URQUAN_2);
-				break;
-			case 2:
-				NPCPhrase (MUST_FIGHT_YOU_URQUAN_3);
-				break;
-			case 3:
-				NPCPhrase (MUST_FIGHT_YOU_URQUAN_4);
-				--NumVisits;
-				break;
+			DISABLE_PHRASE (where_patrol);
+			DISABLE_PHRASE (where_patrol_2);
 		}
-		SET_GAME_STATE (SHOFIXTI_STACK4, NumVisits);
+		else if (PLAYER_SAID (R, where_patrol_2))
+			DISABLE_PHRASE (where_patrol_2);
 	}
-}
-
-static void
-GiveMaidens (RESPONSE_REF R)
-{
-	if (PLAYER_SAID (R, important_duty))
-	{
-		NPCPhrase (WHAT_DUTY);
-
-		Response (procreating_wildly, GiveMaidens);
-		Response (replenishing_your_species, GiveMaidens);
-		Response (hope_you_have, GiveMaidens);
-	}
-	else
+	
+	else if (PLAYER_SAID (R, why_not_call))
 	{
-		NPCPhrase (SOUNDS_GREAT_BUT_HOW);
-
-		Response (females, ExitConversation);
-		Response (nubiles, ExitConversation);
-		Response (rat_babes, ExitConversation);
+		NPCPhrase (NO_RESOURCES_TO_CALL);
+		
+		if (GET_GAME_STATE(TRIANGULATION_SPHERES_SHOFIXTI))
+			NPCPhrase (YOU_HAVE_COORDINATES);
+		else
+			NPCPhrase (TRANSFER_COORDINATES);
+	
+		if(!(GET_GAME_STATE(TRIANGULATION_SPHERES_SHOFIXTI)))
+		{
+			// JMS: Trigger one of the lost patrols to come home after 2 months
+			AddEvent (RELATIVE_EVENT, 2, 0, 0, SHOFIXTI_PATROL_RETURNS_HOME_EVENT);
+			SET_GAME_STATE (TRIANGULATION_SPHERES_SHOFIXTI, 1);
+		}
+		
+		if (GET_GAME_STATE(SHOFIXTI_PATROL_RETURNED))
+			NPCPhrase (ONLY_TWO_PATROLS);
+		
+		DISABLE_PHRASE (why_not_call);
 	}
-}
-
-static void
-ConsoleShofixti (RESPONSE_REF R)
-{
-	if (PLAYER_SAID (R, dont_do_it))
+	else if (PLAYER_SAID (R, ask_scar))
 	{
-		NPCPhrase (YES_I_DO_IT);
-		DISABLE_PHRASE (dont_do_it);
+		NPCPhrase (ANSWER_SCAR);
+		DISABLE_PHRASE (ask_scar);
 	}
-	else
-		NPCPhrase (VERY_SAD_KILL_SELF);
+	
+	/* Player's answers */
+	
+	if (PHRASE_ENABLED (where_patrol) && !(GET_GAME_STATE(TRIANGULATION_SPHERES_SHOFIXTI)))
+		Response (where_patrol, SmallTalk2);
+				 
+	if (PHRASE_ENABLED (where_patrol_2) && GET_GAME_STATE(TRIANGULATION_SPHERES_SHOFIXTI))
+		Response (where_patrol_2, SmallTalk2);
+	
+	if ((PLAYER_SAID (R, where_patrol) || PLAYER_SAID (R, where_patrol_2)) && PHRASE_ENABLED (why_not_call))
+		Response (why_not_call, SmallTalk2);
 
-	if (GET_GAME_STATE (MAIDENS_ON_SHIP))
-	{
-		Response (important_duty, GiveMaidens);
-	}
-	if (PHRASE_ENABLED (dont_do_it))
-	{
-		Response (dont_do_it, ConsoleShofixti);
-	}
-	Response (need_you_for_duty, ExitConversation);
-	Response (go_ahead, ExitConversation);
-}
+	if (PHRASE_ENABLED (how_goes_reconstruction))
+		Response (how_goes_reconstruction, HowReconstruction);
+	
+	if (PLAYER_SAID (R, who_is_kishibojin) && PHRASE_ENABLED (you_talk_differently_tech) && GET_GAME_STATE(SHOFIXTI_TECH_MET))
+		Response (you_talk_differently_religious, SmallTalk2);
+	else if (PLAYER_SAID (R, sorry_to_hear) && PHRASE_ENABLED (you_talk_differently_religious) && GET_GAME_STATE(SHOFIXTI_RELIGIOUS_MET))
+		Response (you_talk_differently_tech, SmallTalk2);
 
-static void
-ExplainDefeat (RESPONSE_REF R)
-{
-	if (PLAYER_SAID (R, i_am_nice))
-		NPCPhrase (MUST_UNDERSTAND);
-	else if (PLAYER_SAID (R, i_am_guy))
-		NPCPhrase (NICE_BUT_WHAT_IS_DONKEY);
-	else /* if (PLAYER_SAID (R, i_am_captain0)) */
-		NPCPhrase (SO_SORRY);
-	NPCPhrase (IS_DEFEAT_TRUE);
-
-	Response (yes_and_no, ConsoleShofixti);
-	Response (clobbered, ConsoleShofixti);
-	Response (butt_blasted, ConsoleShofixti);
+	if (PHRASE_ENABLED (ask_scar))
+		Response (ask_scar, SmallTalk2);
+	
+	Response (farewell_shofixti, ExitConversation);
 }
 
-static void
-RealizeMistake (RESPONSE_REF R)
-{
-	(void) R;  // ignored
-	NPCPhrase (DGRUNTI);
-	SET_GAME_STATE (SHOFIXTI_STACK1, 0);
-	SET_GAME_STATE (SHOFIXTI_STACK3, 0);
-	SET_GAME_STATE (SHOFIXTI_STACK2, 3);
-
-	{
-		UNICODE buf[ALLIANCE_NAME_BUFSIZE];
-
-		GetAllianceName (buf, name_1);
-		construct_response (
-				shared_phrase_buf,
-				i_am_captain0,
-				GLOBAL_SIS (CommanderName),
-				i_am_captain1,
-				buf,
-				i_am_captain2,
-				GLOBAL_SIS (ShipName),
-				i_am_captain3,
-				(UNICODE*)NULL);
-	}
-	DoResponsePhrase (i_am_captain0, ExplainDefeat, shared_phrase_buf);
-	Response (i_am_nice, ExplainDefeat);
-	Response (i_am_guy, ExplainDefeat);
-}
 
-static void
-Hostile (RESPONSE_REF R)
-{
-	(void) R;  // ignored
-	switch (GET_GAME_STATE (SHOFIXTI_STACK1))
-	{
-		case 0:
-			Response (dont_attack, ExitConversation);
-			break;
-		case 1:
-			Response (hey_stop, ExitConversation);
-			break;
-		case 2:
-			Response (look_you_are, ExitConversation);
-			break;
-	}
-	switch (GET_GAME_STATE (SHOFIXTI_STACK2))
-	{
-		case 0:
-			Response (no_one_insults, ExitConversation);
-			break;
-		case 1:
-			Response (mighty_words, ExitConversation);
-			break;
-		case 2:
-			Response (donkey_breath, RealizeMistake);
-			break;
-	}
-	switch (GET_GAME_STATE (SHOFIXTI_STACK3))
-	{
-		case 0:
-			Response (dont_know, ExitConversation);
-			break;
-		case 1:
-		{
-			construct_response (
-					shared_phrase_buf,
-					look0,
-					"",
-					shofixti_name,
-					"",
-					look1,
-					(UNICODE*)NULL);
-			DoResponsePhrase (look0, ExitConversation, shared_phrase_buf);
-			break;
-		}
-		case 2:
-			Response (look_you_are, ExitConversation);
-			break;
-	}
-	Response (dont_want_to_fight, ExitConversation);
-}
 
 static void
-Friendly (RESPONSE_REF R)
-{
-	BYTE i, LastStack;
-	struct
-	{
-		RESPONSE_REF pStr;
-		UNICODE *c_buf;
-	} Resp[3];
-	static UNICODE buf0[80], buf1[80];
+SmallTalk1 (RESPONSE_REF R)
+{	
+	/* Shofixti answers */
 	
-	LastStack = 0;
-	memset (Resp, 0, sizeof (Resp));
-	if (PLAYER_SAID (R, report0))
+	if (PLAYER_SAID (R, chmmr_hunt_kohrah))
 	{
-		NPCPhrase (NOTHING_NEW);
-
-		DISABLE_PHRASE (report0);
-	}
-	else if (PLAYER_SAID (R, why_here0))
-	{
-		NPCPhrase (I_GUARD);
-
-		LastStack = 1;
-		SET_GAME_STATE (SHOFIXTI_STACK1, 1);
+		NPCPhrase (SLAVE_SHIELD_BEST_PLACE);
 	}
-	else if (PLAYER_SAID (R, what_happened))
+	else if (PLAYER_SAID (R, no_idea))
 	{
-		NPCPhrase (MET_VUX);
-
-		LastStack = 1;
-		SET_GAME_STATE (SHOFIXTI_STACK1, 2);
+		NPCPhrase (SHARE_NEWS);
 	}
-	else if (PLAYER_SAID (R, glory_device))
+	else if (PLAYER_SAID (R, take_a_joke))
 	{
-		NPCPhrase (SWITCH_BROKE);
-
-		SET_GAME_STATE (SHOFIXTI_STACK1, 3);
+		NPCPhrase (DONT_JOKE);
 	}
-	else if (PLAYER_SAID (R, where_world))
-	{
-		NPCPhrase (BLEW_IT_UP);
-
-		LastStack = 2;
-		SET_GAME_STATE (SHOFIXTI_STACK3, 1);
-	}
-	else if (PLAYER_SAID (R, how_survive))
-	{
-		NPCPhrase (NOT_HERE);
+	
 
-		SET_GAME_STATE (SHOFIXTI_STACK3, 2);
-	}
+	/* Player's answers */
+	
+	if (!(GET_GAME_STATE(TRIANGULATION_SPHERES_SHOFIXTI)))
+		Response (where_patrol, SmallTalk2);
+	else
+		Response (where_patrol_2, SmallTalk2);
+	Response (how_goes_reconstruction, HowReconstruction);
+	Response (ask_scar, SmallTalk2);
+	Response (farewell_shofixti, ExitConversation);
+}
 
-	if (PHRASE_ENABLED (report0))
-	{
-		construct_response (
-				buf0,
-				report0,
-				"",
-				shofixti_name,
-				"",
-				report1,
-				(UNICODE*)NULL);
-		Resp[0].pStr = report0;
-		Resp[0].c_buf = buf0;
-	}
 
-	switch (GET_GAME_STATE (SHOFIXTI_STACK1))
-	{
-		case 0:
-			construct_response (
-					buf1,
-					why_here0,
-					"",
-					shofixti_name,
-					"",
-					why_here1,
-					(UNICODE*)NULL);
-			Resp[1].pStr = why_here0;
-			Resp[1].c_buf = buf1;
-			break;
-		case 1:
-			Resp[1].pStr = what_happened;
-			break;
-		case 2:
-			Resp[1].pStr = glory_device;
-			break;
-	}
 
-	switch (GET_GAME_STATE (SHOFIXTI_STACK3))
-	{
-		case 0:
-				Resp[2].pStr = where_world;
-			break;
-		case 1:
-				Resp[2].pStr = how_survive;
-			break;
-	}
+static void
+DoShofixtiAngry (RESPONSE_REF R)
+{
+	(void) R; // satisfy compiler
+	NPCPhrase (ANGRY_SHOFIXTI_GREETING_1);
 
-	if (Resp[LastStack].pStr)
-		DoResponsePhrase (Resp[LastStack].pStr, Friendly, Resp[LastStack].c_buf);
-	for (i = 0; i < 3; ++i)
-	{
-		if (i != LastStack && Resp[i].pStr)
-			DoResponsePhrase (Resp[i].pStr, Friendly, Resp[i].c_buf);
-	}
-	if (GET_GAME_STATE (MAIDENS_ON_SHIP))
-	{
-		Response (important_duty, GiveMaidens);
-	}
+	Response (sorry, ExitConversation);
+	Response (will_attack, ExitConversation);
+}
 
-	construct_response (
-			shared_phrase_buf,
-			bye0,
-			"",
-			shofixti_name,
-			"",
-			bye1,
-			(UNICODE*)NULL);
-	DoResponsePhrase (bye0, ExitConversation, shared_phrase_buf);
+static void
+LastChanceToBackUp (RESPONSE_REF R)
+{
+	(void) R; // satisfy compiler
+	NPCPhrase (WHAT);
+	
+	Response (take_a_joke, SmallTalk1);
+	Response (no_joke_attack, ExitConversation);
 }
 
+// Religious Shofixti groups have different hellos than tech-oriented groups.
 static void
 Intro (void)
 {
-	if (LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
+	BYTE NumVisits;
+	BYTE ThisGroupIsReligious;
+	
+		/* Decide whether this is a religious battlegroup or not. */
+	
+	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY)
+		ThisGroupIsReligious = EncounterGroup % 2;
+	else
+		ThisGroupIsReligious = TFB_Random () % 2;
+	
+	if (ThisGroupIsReligious)
+		SET_GAME_STATE (SHOFIXTI_RELIGIOUS_GROUP, 1);
+	else
+		SET_GAME_STATE (SHOFIXTI_RELIGIOUS_GROUP, 0);
+	
+	
+		/* Shofixti answers */
+	
+	if (GET_GAME_STATE (SHOFIXTI_ANGRY) == 1)
 	{
-		NPCPhrase (OUT_TAKES);
-
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
-		return;
+		NumVisits = GET_GAME_STATE (SHOFIXTI_VISITS);
+		switch (NumVisits++)
+		{
+			case 1:
+				NPCPhrase (MIFFED_SHOFIXTI_GREETING_1);
+				break;
+			case 2:
+				NPCPhrase (MIFFED_SHOFIXTI_GREETING_2);
+				break;
+			case 3:
+				NPCPhrase (MIFFED_SHOFIXTI_GREETING_3);
+				break;
+			case 4:
+				NPCPhrase (MIFFED_SHOFIXTI_GREETING_4);
+				--NumVisits;
+				break;
+		}
+		
+		SmallTalk1 (0);
+		SET_GAME_STATE (SHOFIXTI_VISITS, NumVisits);
 	}
-
-	GetShofixtiName ();
-
-	if (GET_GAME_STATE (SHOFIXTI_STACK2) > 2)
+	
+	else if (GET_GAME_STATE (SHOFIXTI_ANGRY) == 2)
+		DoShofixtiAngry (0);
+	
+	else if (GET_GAME_STATE (SHOFIXTI_ANGRY) == 3)
 	{
-		NPCPhrase (FRIENDLY_HELLO);
-
-		Friendly ((RESPONSE_REF)0);
+		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		NPCPhrase (ANGRY_SHOFIXTI_GREETING_2);
 	}
+	
 	else
 	{
-		BYTE NumVisits;
-
 		NumVisits = GET_GAME_STATE (SHOFIXTI_VISITS);
-		if (GET_GAME_STATE (SHOFIXTI_KIA))
+		if (GET_GAME_STATE(SHOFIXTI_PATROL_RETURNED) && !(GET_GAME_STATE(SHOFIXTI_GREAT_NEWS_HEARD)))
+		{
+			NPCPhrase (GREAT_NEWS);
+			SET_GAME_STATE(SHOFIXTI_GREAT_NEWS_HEARD, 1);
+		}
+		else if (ThisGroupIsReligious)
 		{
 			switch (NumVisits++)
 			{
 				case 0:
-					NPCPhrase (HOSTILE_KATANA_1);
+					NPCPhrase (SHOFIXTI_GREETING_1);
 					break;
 				case 1:
-					NPCPhrase (HOSTILE_KATANA_2);
+					NPCPhrase (RELIGIOUS_SHOFIXTI_GREETING_2);
 					break;
 				case 2:
-					NPCPhrase (HOSTILE_KATANA_3);
+					NPCPhrase (RELIGIOUS_SHOFIXTI_GREETING_3);
 					break;
 				case 3:
-					NPCPhrase (HOSTILE_KATANA_4);
+					NPCPhrase (RELIGIOUS_SHOFIXTI_GREETING_4);
+					break;
+				case 4:
+					NPCPhrase (RELIGIOUS_SHOFIXTI_GREETING_4);
 					--NumVisits;
 					break;
 			}
@@ -587,35 +549,39 @@ Intro (void)
 			switch (NumVisits++)
 			{
 				case 0:
-					NPCPhrase (HOSTILE_TANAKA_1);
+					NPCPhrase (SHOFIXTI_GREETING_1);
 					break;
 				case 1:
-					NPCPhrase (HOSTILE_TANAKA_2);
+					NPCPhrase (TECH_SHOFIXTI_GREETING_2);
 					break;
 				case 2:
-					NPCPhrase (HOSTILE_TANAKA_3);
+					NPCPhrase (TECH_SHOFIXTI_GREETING_3);
 					break;
 				case 3:
-					NPCPhrase (HOSTILE_TANAKA_4);
+					NPCPhrase (TECH_SHOFIXTI_GREETING_4);
 					break;
 				case 4:
-					NPCPhrase (HOSTILE_TANAKA_5);
-					break;
-				case 5:
-					NPCPhrase (HOSTILE_TANAKA_6);
-					break;
-				case 6:
-					NPCPhrase (HOSTILE_TANAKA_7);
-					break;
-				case 7:
-					NPCPhrase (HOSTILE_TANAKA_8);
+					NPCPhrase (TECH_SHOFIXTI_GREETING_4);
 					--NumVisits;
 					break;
 			}
 		}
+		
 		SET_GAME_STATE (SHOFIXTI_VISITS, NumVisits);
-
-		Hostile ((RESPONSE_REF)0);
+		
+		
+		/* Player's answers */
+		
+		if (GET_GAME_STATE(SHOFIXTI_MET) == 0)
+		{
+			SET_GAME_STATE(SHOFIXTI_MET, 1);
+			Response (chmmr_hunt_kohrah, SmallTalk1);
+			Response (no_idea, SmallTalk1);
+			Response (pearshaped, LastChanceToBackUp);
+			Response (farewell_shofixti, ExitConversation);
+		}
+		else
+			SmallTalk1 (0);
 	}
 }
 
@@ -642,9 +608,14 @@ init_shofixti_comm (void)
 
 	shofixti_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
 	shofixti_desc.AlienTextBaseline.y = 0;
-	shofixti_desc.AlienTextWidth = SIS_TEXT_WIDTH;
+	shofixti_desc.AlienTextWidth = SIS_TEXT_WIDTH - 4;
 
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	// The Shofixti are ready to attack if pissed off badly enough.
+	// At 2 player may still soothe them, but at 3 all is lost.
+	if (GET_GAME_STATE (SHOFIXTI_ANGRY) > 1)
+		SET_GAME_STATE (BATTLE_SEGUE, 1);
+	else
+		SET_GAME_STATE (BATTLE_SEGUE, 0);
 
 	retval = &shofixti_desc;
 
diff -ruNp src.orig/uqm/comm/shofixt/strings.h src/uqm/comm/shofixt/strings.h
--- src.orig/uqm/comm/shofixt/strings.h	2017-11-01 15:30:23 -0700
+++ src/uqm/comm/shofixt/strings.h	2017-11-01 15:31:01 -0700
@@ -22,101 +22,71 @@
 enum
 {
 	NULL_PHRASE,
-	name_1,
-	name_2,
-	name_3,
-	name_40,
-	name_41,
-	tanaka,
-	katana,
-	HOSTILE_KATANA_1,
-	HOSTILE_KATANA_2,
-	HOSTILE_KATANA_3,
-	HOSTILE_KATANA_4,
-	HOSTILE_TANAKA_1,
-	HOSTILE_TANAKA_2,
-	HOSTILE_TANAKA_3,
-	HOSTILE_TANAKA_4,
-	HOSTILE_TANAKA_5,
-	HOSTILE_TANAKA_6,
-	HOSTILE_TANAKA_7,
-	HOSTILE_TANAKA_8,
-	dont_attack,
-	TYPICAL_PLOY,
-	hey_stop,
-	ONLY_STOP,
-	look_you_are,
-	TOO_BAD,
-	dont_know,
-	NEVER,
-	look0,
-	look1,
-	FOR_YOU,
-	no_bloodshed,
-	YES_BLOODSHED,
-	dont_want_to_fight,
-	MUST_FIGHT_YOU_URQUAN_1,
-	MUST_FIGHT_YOU_URQUAN_2,
-	MUST_FIGHT_YOU_URQUAN_3,
-	MUST_FIGHT_YOU_URQUAN_4,
-	no_one_insults,
-	YOU_LIMP,
-	mighty_words,
-	HANG_YOUR,
-	donkey_breath,
-	DGRUNTI,
-	i_am_captain0,
-	i_am_captain1,
-	i_am_captain2,
-	i_am_captain3,
-	i_am_nice,
-	i_am_guy,
-	SO_SORRY,
-	MUST_UNDERSTAND,
-	NICE_BUT_WHAT_IS_DONKEY,
-	IS_DEFEAT_TRUE,
-	yes_and_no,
-	butt_blasted,
-	clobbered,
-	VERY_SAD_KILL_SELF,
-	important_duty,
-	WHAT_DUTY,
-	need_you_for_duty,
-	OK_WILL_BE_SENTRY,
-	dont_do_it,
-	YES_I_DO_IT,
-	go_ahead,
-	ON_SECOND_THOUGHT,
-	procreating_wildly,
-	replenishing_your_species,
-	hope_you_have,
-	SOUNDS_GREAT_BUT_HOW,
-	females,
-	nubiles,
-	rat_babes,
-	LEAPING_HAPPINESS,
-	bye0,
-	bye1,
-	GOODBYE0,
-	GOODBYE1,
-	why_here0,
-	why_here1,
-	I_GUARD,
-	where_world,
-	BLEW_IT_UP,
-	how_survive,
-	NOT_HERE,
-	what_happened,
-	MET_VUX,
-	glory_device,
-	SWITCH_BROKE,
-	bye,
-	GOODBYE,
-	FRIENDLY_HELLO,
-	report0,
-	report1,
-	NOTHING_NEW,
-	OUT_TAKES,
+	SHOFIXTI_GREETING_1,
+	TECH_SHOFIXTI_GREETING_2,
+	TECH_SHOFIXTI_GREETING_3,
+	TECH_SHOFIXTI_GREETING_4,
+	RELIGIOUS_SHOFIXTI_GREETING_2,
+	RELIGIOUS_SHOFIXTI_GREETING_3,
+	RELIGIOUS_SHOFIXTI_GREETING_4,
+	MIFFED_SHOFIXTI_GREETING_1,
+	MIFFED_SHOFIXTI_GREETING_2,
+	MIFFED_SHOFIXTI_GREETING_3,
+	MIFFED_SHOFIXTI_GREETING_4,
+	ANGRY_SHOFIXTI_GREETING_1,
+	ANGRY_SHOFIXTI_GREETING_2,
+	sorry,
+	SORRY_ACCEPTED,
+	will_attack,
+	WILL_ATTACK_TOO,
+	chmmr_hunt_kohrah,
+	SLAVE_SHIELD_BEST_PLACE,
+	no_idea,
+	SHARE_NEWS,
+	pearshaped,
+	WHAT,
+	take_a_joke,
+	DONT_JOKE,
+	no_joke_attack,
+	KYAIEE,
+	how_goes_reconstruction,
+	NOT_GOOD_RECONSTRUCTION_PRE,
+	NOT_GOOD_RECONSTRUCTION_PRE_MIFFED,	
+	RECONSTRUCTION_TECHNOLOGY,
+	sorry_to_hear,
+	THANK_YOU,
+	THANK_YOU_MIFFED,
+	you_talk_differently_tech,
+	YOU_MET_RELIGIOUS,
+	RECONSTRUCTION_KISHIBOJIN,
+	who_is_kishibojin,
+	SHE_IS_KISHIBOJIN,
+	you_talk_differently_religious,
+	YOU_MET_NONBELIEVERS,
+	ask_scar,
+	ANSWER_SCAR,
+	where_patrol,
+	where_patrol_2,
+	HERE_GOES,
+	LOST_PATROLS,
+	THREE_PATROLS_MISSING,
+	TWO_PATROLS_MISSING,
+	why_not_call,
+	NO_RESOURCES_TO_CALL,
+	TRANSFER_COORDINATES,
+	YOU_HAVE_COORDINATES,
+	ONLY_TWO_PATROLS,
+	GREAT_NEWS,
+	farewell_shofixti,
+	GOODBYE_TECH_EARTHLING_1,
+	GOODBYE_TECH_EARTHLING_2,
+	GOODBYE_TECH_EARTHLING_3,
+	GOODBYE_TECH_EARTHLING_4,
+	GOODBYE_RELIGIOUS_EARTHLING_1,
+	GOODBYE_RELIGIOUS_EARTHLING_2,
+	GOODBYE_RELIGIOUS_EARTHLING_3,
+	GOODBYE_RELIGIOUS_EARTHLING_4,
+	MIFFED_GOODBYE_EARTHLING
 };
 
 #endif /* _STRINGS_H */
diff -ruNp src.orig/uqm/comm/shofixticolony/Makeinfo src/uqm/comm/shofixticolony/Makeinfo
--- src.orig/uqm/comm/shofixticolony/Makeinfo	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/shofixticolony/Makeinfo	2017-11-01 15:31:01 -0700
@@ -0,0 +1 @@
+uqm_CFILES="shofixticolonyc.c"
diff -ruNp src.orig/uqm/comm/shofixticolony/ifontres.h src/uqm/comm/shofixticolony/ifontres.h
--- src.orig/uqm/comm/shofixticolony/ifontres.h	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/shofixticolony/ifontres.h	2017-11-01 15:31:01 -0700
@@ -0,0 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
+#define SHOFIXTI_COLONY_FONT "comm.shofixticolony.font"
diff -ruNp src.orig/uqm/comm/shofixticolony/igfxres.h src/uqm/comm/shofixticolony/igfxres.h
--- src.orig/uqm/comm/shofixticolony/igfxres.h	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/shofixticolony/igfxres.h	2017-11-01 15:31:01 -0700
@@ -0,0 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
+#define SHOFIXTI_COLONY_PMAP_ANIM "comm.shofixticolony.graphics"
diff -ruNp src.orig/uqm/comm/shofixticolony/imusicre.h src/uqm/comm/shofixticolony/imusicre.h
--- src.orig/uqm/comm/shofixticolony/imusicre.h	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/shofixticolony/imusicre.h	2017-11-01 15:31:01 -0700
@@ -0,0 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
+#define SHOFIXTI_COLONY_MUSIC "comm.shofixticolony.music"
diff -ruNp src.orig/uqm/comm/shofixticolony/istrtab.h src/uqm/comm/shofixticolony/istrtab.h
--- src.orig/uqm/comm/shofixticolony/istrtab.h	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/shofixticolony/istrtab.h	2017-11-01 15:31:01 -0700
@@ -0,0 +1,6 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
+#define SHOFIXTI_COLONY_COLOR_MAP "comm.shofixticolony.colortable"
+#define SHOFIXTI_COLONY_CONVERSATION_PHRASES "comm.shofixticolony.dialogue"
diff -ruNp src.orig/uqm/comm/shofixticolony/resinst.h src/uqm/comm/shofixticolony/resinst.h
--- src.orig/uqm/comm/shofixticolony/resinst.h	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/shofixticolony/resinst.h	2017-11-01 15:31:01 -0700
@@ -0,0 +1,5 @@
+#define SHOFIXTI_COLONY_COLOR_MAP "comm.shofixticolony.colortable"
+#define SHOFIXTI_COLONY_CONVERSATION_PHRASES "comm.shofixticolony.dialogue"
+#define SHOFIXTI_COLONY_MUSIC "comm.shofixticolony.music"
+#define SHOFIXTI_COLONY_PMAP_ANIM "comm.shofixticolony.graphics"
+#define SHOFIXTI_COLONY_FONT "comm.shofixticolony.font"
\ No newline at end of file
diff -ruNp src.orig/uqm/comm/shofixticolony/shofixticolonyc.c src/uqm/comm/shofixticolony/shofixticolonyc.c
--- src.orig/uqm/comm/shofixticolony/shofixticolonyc.c	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/shofixticolony/shofixticolonyc.c	2017-11-01 15:31:01 -0700
@@ -0,0 +1,488 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+// JMS 2011: Totally new file for shofixti colony comm.
+
+#include "../commall.h"
+#include "resinst.h"
+#include "strings.h"
+#include "libs/sound/sound.h"
+
+#include "uqm/build.h"
+
+
+static LOCDATA shofixticolony_desc =
+{
+	SHOFIXTICOLONY_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	SHOFIXTI_COLONY_PMAP_ANIM, /* AlienFrame */
+	SHOFIXTI_COLONY_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_BOTTOM, /* AlienTextValign */
+	SHOFIXTI_COLONY_COLOR_MAP, /* AlienColorMap */
+	SHOFIXTI_COLONY_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	SHOFIXTI_COLONY_CONVERSATION_PHRASES, /* PlayerPhrases */
+	14, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{ /* 0 moving sleeves, basic version */
+			1, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND * 2, ONE_SECOND * 3, /* RestartRate */
+			(1 << 1), /* BlockMask */
+		},
+		{ /* 1 moving sleeves, alternative version */
+			4, /* StartIndex */
+			2, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND * 2, ONE_SECOND * 3, /* RestartRate */
+			(1 << 0), /* BlockMask */
+		},
+		{ /* 2 ear wiggle */
+			6, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND * 3, ONE_SECOND * 2, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* 3 eye blink */
+			9, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND, (ONE_SECOND / 10) * 22, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* 4 yellow light row */
+			12, /* StartIndex */
+			6, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, 0, /* FrameRate */
+			ONE_SECOND * 2, ONE_SECOND / 15, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* 5 top left ship flying */
+			23, /* StartIndex */
+			8, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND * 4, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* 6 ship flying */
+			31, /* StartIndex */
+			8, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND * 6, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* 7 ship flying */
+			39, /* StartIndex */
+			7, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND * 7, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* 8 green and red lights in the mast of the tower */
+			46, /* StartIndex */
+			2, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND * 2, 0, /* FrameRate */
+			ONE_SECOND * 2, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* 9 welding #1 */
+			48, /* StartIndex */
+			6, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			ONE_SECOND * 4, ONE_SECOND * 4, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* 10 welding #2 */
+			54, /* StartIndex */
+			6, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			ONE_SECOND * 4, ONE_SECOND * 4, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* 11 welding #3 */
+			60, /* StartIndex */
+			6, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			ONE_SECOND * 4, ONE_SECOND * 4, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* 12 welding #4 */
+			66, /* StartIndex */
+			6, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			ONE_SECOND * 4, ONE_SECOND * 4, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* 13 Black screen */
+			72, /* StartIndex */
+			1, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND, 0, /* FrameRate */
+			ONE_SECOND * 10, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+	},
+	{ /* AlienTransitionDesc */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		18, /* StartIndex */
+		5, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 15, 0, /* FrameRate */
+		ONE_SECOND / 12, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
+};
+
+static void
+MainLoop (RESPONSE_REF R);
+
+static void
+ExitConversation (RESPONSE_REF R)
+{
+	(void) R; // satisfy compiler. Fucking compiler.
+	
+	if (GET_GAME_STATE (SHOFIXTI_COLONY_MET) > 1)
+		NPCPhrase (GOODBYE_CAPTAIN);
+	else
+		NPCPhrase (BLACKSCREEN_GOODBYE);
+	
+	SET_GAME_STATE (BATTLE_SEGUE, 0);
+}
+
+static void
+CultureLoop (RESPONSE_REF R)
+{	
+	static BYTE historystack = 1;
+	
+	if (PLAYER_SAID (R, tell_me_about_culture))
+	{
+		NPCPhrase (GO_TO_CULTURE);
+		historystack = 1;
+	}
+	
+	else if (PLAYER_SAID (R, how_it_works_out))
+	{
+		NPCPhrase (SINCE_YOU_MENTIONED_IT);
+		DISABLE_PHRASE (how_it_works_out);
+		
+		Response (thats_sad, CultureLoop);
+		Response (humans_are_different, CultureLoop);
+	}
+	
+	else if (PLAYER_SAID (R, thats_sad) || PLAYER_SAID (R, humans_are_different))
+	{
+		if (PLAYER_SAID (R, thats_sad))
+			NPCPhrase (YOU_UNDERSTAND);
+		else if (PLAYER_SAID (R, humans_are_different))
+			NPCPhrase (SO_DIFFERENT);
+		
+		Response (gf_at_home, CultureLoop);
+	}
+	
+	else if (PLAYER_SAID (R, gf_at_home))
+	{
+		NPCPhrase (YOURE_JUST_AS_BAD);
+	}
+	
+	else if (PLAYER_SAID (R, surprised_seeing_female))
+	{
+		NPCPhrase (SURPRISED_ANSWER);
+		DISABLE_PHRASE (surprised_seeing_female);
+	}
+	
+	else if (PLAYER_SAID (R, history_question_1))
+	{
+		NPCPhrase (HISTORY_ANSWER_1);
+		DISABLE_PHRASE (history_question_1);
+		historystack++;
+	}
+	else if (PLAYER_SAID (R, history_question_2_admire) || PLAYER_SAID (R, history_question_2_sarcasm))
+	{
+		NPCPhrase (HISTORY_ANSWER_2);
+		DISABLE_PHRASE (history_question_2_admire);
+		DISABLE_PHRASE (history_question_2_sarcasm);
+		historystack++;
+	}
+	else if (PLAYER_SAID (R, history_question_3))
+	{
+		NPCPhrase (HISTORY_ANSWER_3);
+		DISABLE_PHRASE (history_question_3);
+		historystack++;
+	}
+	else if (PLAYER_SAID (R, history_question_4))
+	{
+		NPCPhrase (HISTORY_ANSWER_4);
+		DISABLE_PHRASE (history_question_4);
+		historystack++;
+	}
+
+	
+	if (PHRASE_ENABLED(surprised_seeing_female))
+		Response (surprised_seeing_female, CultureLoop);
+	
+	if (PHRASE_ENABLED(how_it_works_out))
+		Response (how_it_works_out, CultureLoop);
+	
+	if (PHRASE_ENABLED(history_question_1) && historystack == 1)
+		Response (history_question_1, CultureLoop);
+	
+	else if (historystack == 2)
+	{
+		if (PHRASE_ENABLED(history_question_2_admire))
+			Response (history_question_2_admire, CultureLoop);
+		if (PHRASE_ENABLED(history_question_2_sarcasm))
+			Response (history_question_2_sarcasm, CultureLoop);
+	}
+	
+	else if (PHRASE_ENABLED(history_question_3) && historystack == 3)
+		Response (history_question_3, CultureLoop);
+	
+	else if (PHRASE_ENABLED(history_question_4) && historystack == 4)
+		Response (history_question_4, CultureLoop);
+	
+	Response (enough_culture, MainLoop);
+	Response (goodbye, ExitConversation);
+}
+
+static void
+MainLoop (RESPONSE_REF R)
+{	
+	if (GET_GAME_STATE (SHOFIXTI_COLONY_INTRODUCED) == 0)
+		SET_GAME_STATE (SHOFIXTI_COLONY_INTRODUCED, 1);
+	
+	if (PLAYER_SAID (R, courteous_hello) || PLAYER_SAID (R, condescending))
+	{
+		NPCPhrase (INTRODUCING_HIROKU);
+	}
+	else if (PLAYER_SAID (R, just_joking))
+	{
+		NPCPhrase (JUST_JOKING_REPLY);
+	}
+	else if (PLAYER_SAID (R, sorry_disrespectful))
+	{
+		NPCPhrase (DISRESPECTFUL_REPLY);
+		NPCPhrase (INTRODUCING_HIROKU);
+	}
+	else if (PLAYER_SAID (R, enough_culture))
+	{
+		NPCPhrase (LEAVE_CULTURE);
+		DISABLE_PHRASE (tell_me_about_culture);
+	}
+	else if (PLAYER_SAID (R, what_is_going_on))
+	{
+		if (GET_GAME_STATE (SHOFIXTICOL_CURRENT_NEWS_STACK) == 0)
+		{
+			NPCPhrase (THIS_IS_GOING_ON);
+			SET_GAME_STATE (SHOFIXTICOL_CURRENT_NEWS_STACK, 1);
+		}
+		else
+			NPCPhrase (THIS_IS_GOING_ON2);
+		DISABLE_PHRASE (what_is_going_on);
+	}
+	else if (PLAYER_SAID (R, tell_me_about_distress_call))
+	{
+		NPCPhrase (DISTRESS_CALL);
+		DISABLE_PHRASE (tell_me_about_distress_call);
+	}
+	
+	if (PHRASE_ENABLED(what_is_going_on))
+		Response (what_is_going_on, MainLoop);
+
+	if (PHRASE_ENABLED(tell_me_about_culture))
+		Response (tell_me_about_culture, CultureLoop);
+	
+	if (PHRASE_ENABLED(tell_me_about_distress_call))
+		Response (tell_me_about_distress_call, MainLoop);
+	
+	Response (goodbye, ExitConversation);
+}
+
+static void
+ProperIntroduction (RESPONSE_REF R)
+{	
+	if (PLAYER_SAID (R, a_woman) || PLAYER_SAID (R, i_luv_furries))
+	{
+		if (PLAYER_SAID (R, a_woman))
+			NPCPhrase (YES_WOMAN);
+		else if (PLAYER_SAID (R, i_luv_furries))
+			NPCPhrase (BACK_OFF_CREEP);
+		
+		Response (condescending, MainLoop);
+		Response (just_joking, MainLoop);
+		Response (sorry_disrespectful, MainLoop);
+	}
+	
+	else if (PLAYER_SAID (R, just_joking))
+		NPCPhrase (JUST_JOKING_REPLY);
+	
+	else if (PLAYER_SAID (R, sorry_disrespectful))
+		NPCPhrase (DISRESPECTFUL_REPLY);
+	
+	else if (GET_GAME_STATE (SHOFIXTI_COLONY_INTRODUCED) == 0)
+	{
+		if (GET_GAME_STATE (SHOFIXTI_COLONY_MET) == 0)
+		{
+			SET_GAME_STATE (SHOFIXTI_COLONY_MET, 1);
+			NPCPhrase (SHO_GREETING1);
+		}
+		
+		Response (a_woman, ProperIntroduction);
+		Response (i_luv_furries, ProperIntroduction);
+		Response (courteous_hello, MainLoop);
+	}
+
+	Response (goodbye, ExitConversation);
+}
+
+static void
+BlackScreen3 (RESPONSE_REF R)
+{
+	(void) R; // satisfy compiler.
+	
+	NPCPhrase (BLACKSCREEN_LAST);
+	
+	ProperIntroduction ((RESPONSE_REF)0);
+}
+
+static void
+BlackScreen2 (RESPONSE_REF R)
+{
+	(void) R; // satisfy compiler.
+	
+	NPCPhrase (AIRLOCK_CASUALTIES);
+	
+	Response (sounds_nasty,BlackScreen3);
+	Response (whats_up_doc, BlackScreen3);
+	Response (goodbye, ExitConversation);
+}
+
+static void
+BlackScreen1 (RESPONSE_REF R)
+{
+	if (PLAYER_SAID (R, hello_blackscreen))
+		NPCPhrase (BLACKSCREEN_SIGNAL_DEGRADED);
+	
+	if (PLAYER_SAID (R, why_degraded))
+	{
+		NPCPhrase (REASON_DEGRADED);
+		DISABLE_PHRASE (why_degraded);
+		DISABLE_PHRASE (go_ahead);
+	}
+	
+	if (PHRASE_ENABLED(go_ahead))
+		Response (go_ahead, BlackScreen2);
+
+	if (PHRASE_ENABLED(why_degraded))	
+		Response (why_degraded, BlackScreen1);
+		
+	if (PLAYER_SAID (R, why_degraded))
+		Response (yes_proceed, BlackScreen2);
+		
+	Response (goodbye, ExitConversation);
+}
+
+static void
+Intro (void)
+{	
+	if (GET_GAME_STATE (SHOFIXTI_COLONY_MET) == 0)
+	{
+		NPCPhrase (BLACKSCREEN);
+		Response (hello_blackscreen, BlackScreen1);
+		Response (goodbye, ExitConversation);
+	}
+	else
+	{
+		NPCPhrase (SHO_GREETING2);
+		if (GET_GAME_STATE (SHOFIXTI_COLONY_INTRODUCED) == 0)
+			ProperIntroduction ((RESPONSE_REF)0);
+		else
+			MainLoop ((RESPONSE_REF)0);
+	}
+}
+
+
+static COUNT
+uninit_shofixticolony (void)
+{
+	return (0);
+}
+
+static void
+post_shofixticolony_enc (void)
+{
+	// nothing defined so far
+}
+
+LOCDATA*
+init_shofixticolony_comm (void)
+{
+	LOCDATA *retval;
+
+	shofixticolony_desc.init_encounter_func = Intro;
+	shofixticolony_desc.post_encounter_func = post_shofixticolony_enc;
+	shofixticolony_desc.uninit_encounter_func = uninit_shofixticolony;
+
+	shofixticolony_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
+	shofixticolony_desc.AlienTextBaseline.y = RES_SIS_SCALE(100);
+	shofixticolony_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
+
+	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	retval = &shofixticolony_desc;
+
+	return (retval);
+}
diff -ruNp src.orig/uqm/comm/shofixticolony/strings.h src/uqm/comm/shofixticolony/strings.h
--- src.orig/uqm/comm/shofixticolony/strings.h	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/shofixticolony/strings.h	2017-11-01 15:31:01 -0700
@@ -0,0 +1,83 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _STRINGS_H
+#define _STRINGS_H
+
+enum
+{
+	NULL_PHRASE,
+	BLACKSCREEN,
+	hello_blackscreen,
+	BLACKSCREEN_GOODBYE,
+	BLACKSCREEN_SIGNAL_DEGRADED,
+	go_ahead,
+	why_degraded,
+	REASON_DEGRADED,
+	yes_proceed,
+	AIRLOCK_CASUALTIES,
+	sounds_nasty,
+	whats_up_doc,
+	BLACKSCREEN_LAST,
+	SHO_GREETING1,
+	SHO_GREETING2,
+	a_woman,
+	YES_WOMAN,
+	condescending,
+	i_luv_furries,
+	BACK_OFF_CREEP,
+	just_joking,
+	sorry_disrespectful,
+	JUST_JOKING_REPLY,
+	DISRESPECTFUL_REPLY,
+	courteous_hello,
+	INTRODUCING_HIROKU,
+	tell_me_about_culture,
+	GO_TO_CULTURE,
+	how_it_works_out,
+	SINCE_YOU_MENTIONED_IT,
+	thats_sad,
+	humans_are_different,
+	SO_DIFFERENT,
+	YOU_UNDERSTAND,
+	gf_at_home,
+	YOURE_JUST_AS_BAD,
+	DIFFERENT_INDEED,
+	surprised_seeing_female,
+	SURPRISED_ANSWER,
+	history_question_1,
+	HISTORY_ANSWER_1,
+	history_question_2_admire,
+	history_question_2_sarcasm,
+	HISTORY_ANSWER_2,
+	history_question_3,
+	HISTORY_ANSWER_3,
+	history_question_4,
+	HISTORY_ANSWER_4,
+	enough_culture,
+	LEAVE_CULTURE,
+	what_is_going_on,
+	THIS_IS_GOING_ON,
+	THIS_IS_GOING_ON2,
+	tell_me_about_distress_call,
+	DISTRESS_CALL,
+	goodbye,
+	GOODBYE_CAPTAIN
+};
+
+#endif /* _STRINGS_H */
diff -ruNp src.orig/uqm/comm/slaverace/Makeinfo src/uqm/comm/slaverace/Makeinfo
--- src.orig/uqm/comm/slaverace/Makeinfo	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/slaverace/Makeinfo	2017-11-01 15:31:01 -0700
@@ -0,0 +1 @@
+uqm_CFILES="slaveracec.c"
diff -ruNp src.orig/uqm/comm/slaverace/resinst.h src/uqm/comm/slaverace/resinst.h
--- src.orig/uqm/comm/slaverace/resinst.h	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/slaverace/resinst.h	2017-11-01 15:31:01 -0700
@@ -0,0 +1,5 @@
+#define SLAVERACE_PMAP_ANIM "comm.slaverace.graphics"
+#define SLAVERACE_COLOR_MAP "comm.slaverace.colortable"
+#define SLAVERACE_FONT "comm.slaverace.font"
+#define SLAVERACE_CONVERSATION_PHRASES "comm.slaverace.dialogue"
+#define SLAVERACE_MUSIC "comm.slaverace.music"
diff -ruNp src.orig/uqm/comm/slaverace/slaveracec.c src/uqm/comm/slaverace/slaveracec.c
--- src.orig/uqm/comm/slaverace/slaveracec.c	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/slaverace/slaveracec.c	2017-11-01 15:31:01 -0700
@@ -0,0 +1,223 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "../commall.h"
+#include "resinst.h"
+#include "strings.h"
+#include "uqm/build.h"
+
+
+static LOCDATA slaverace_desc =
+{
+	FOONFOON_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	SLAVERACE_PMAP_ANIM, /* AlienFrame */
+	SLAVERACE_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_TOP, /* AlienTextValign */
+	SLAVERACE_COLOR_MAP, /* AlienColorMap */
+	SLAVERACE_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	SLAVERACE_CONVERSATION_PHRASES, /* PlayerPhrases */
+	12 /* 13 */, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{
+			4, /* StartIndex */
+			6, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			10, /* StartIndex */
+			5, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			15, /* StartIndex */
+			2, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 10, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			17, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 10, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			20, /* StartIndex */
+			2, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, 0, /* FrameRate */
+			ONE_SECOND / 10, ONE_SECOND * 3, /* RestartRate */
+			(1 << 7), /* BlockMask */
+		},
+		{
+			22, /* StartIndex */
+			8, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, 0, /* FrameRate */
+			ONE_SECOND / 10, ONE_SECOND * 3, /* RestartRate */
+			(1 << 6), /* BlockMask */
+		},
+		{
+			30, /* StartIndex */
+			3, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, 0, /* FrameRate */
+			ONE_SECOND / 10, ONE_SECOND * 3, /* RestartRate */
+			(1 << 5), /* BlockMask */
+		},
+		{
+			33, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, 0, /* FrameRate */
+			ONE_SECOND / 10, ONE_SECOND * 3, /* RestartRate */
+			(1 << 4), /* BlockMask */
+		},
+		{
+			36, /* StartIndex */
+			25, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 60, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			61, /* StartIndex */
+			15, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 60, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			76, /* StartIndex */
+			17, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 60, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 12), /* BlockMask */
+		},
+		{
+			93, /* StartIndex */
+			25, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 60, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			118, /* StartIndex */
+			11, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 60, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 10), /* BlockMask */
+		},
+	},
+	{ /* AlienTransitionDesc */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		1, /* StartIndex */
+		3, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+		ONE_SECOND / 12, ONE_SECOND * 3 / 8, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
+};
+
+static void
+ExitConversation (RESPONSE_REF R)
+{
+	(void) R; // satisfy compiler
+	SET_GAME_STATE (BATTLE_SEGUE, 0);
+
+	NPCPhrase (GOODBYE_EARTHLING);
+}
+
+static void
+Intro (void)
+{
+	ExitConversation(0);
+}
+
+static COUNT
+uninit_slaverace (void)
+{
+	return (0);
+}
+
+static void
+post_slaverace_enc (void)
+{
+}
+
+LOCDATA*
+init_slaverace_comm (void)
+{
+	LOCDATA *retval;
+
+	slaverace_desc.init_encounter_func = Intro;
+	slaverace_desc.post_encounter_func = post_slaverace_enc;
+	slaverace_desc.uninit_encounter_func = uninit_slaverace;
+
+	slaverace_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
+	slaverace_desc.AlienTextBaseline.y = 0;
+	slaverace_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
+
+	SET_GAME_STATE (BATTLE_SEGUE, 0);
+
+	retval = &slaverace_desc;
+
+	return (retval);
+}
diff -ruNp src.orig/uqm/comm/slaverace/strings.h src/uqm/comm/slaverace/strings.h
--- src.orig/uqm/comm/slaverace/strings.h	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/slaverace/strings.h	2017-11-01 15:31:01 -0700
@@ -0,0 +1,44 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _STRINGS_H
+#define _STRINGS_H
+
+enum
+{
+	NULL_PHRASE,
+    INIT_HELLO,
+    we_are,
+    ARE_YOU_ALLIANCE,	
+    worst_nightmare,
+    BRING_IT_ON,
+    sort_of,
+    master_of_the_galaxy,
+    SOVEREIGNTY,
+    WHY_ARE_YOU_HERE,
+    looking_for_assistance,
+    were_lost,
+    looking_for_artefacts,
+    CANNOT_ASSIST,	
+    where_is_masterrace,
+    MASTERRACE_AT,
+    goodbye_slaverace,
+    GOODBYE_EARTHLING
+};
+
+#endif /* _STRINGS_H */
diff -ruNp src.orig/uqm/comm/slyhome/slyhome.c src/uqm/comm/slyhome/slyhome.c
--- src.orig/uqm/comm/slyhome/slyhome.c	2017-11-01 15:30:23 -0700
+++ src/uqm/comm/slyhome/slyhome.c	2017-11-01 15:31:01 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: Totally new dialogue for Slylandros riding Kohr-Ah vessels
+
 #include "../commall.h"
 #include "resinst.h"
 #include "strings.h"
@@ -23,8 +25,9 @@
 #include "uqm/gameev.h"
 
 
-static LOCDATA slylandro_desc =
+static LOCDATA slylandro_desc_1x =
 {
+	SLYLANDRO_HOME_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -169,6 +172,85 @@ static LOCDATA slylandro_desc =
 	NULL, NULL, NULL,
 	NULL,
 	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
+};
+
+static LOCDATA slylandro_desc_4x =
+{
+	SLYLANDRO_HOME_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	SLYLANDRO_PMAP_ANIM, /* AlienFrame */
+	SLYLANDRO_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_TOP, /* AlienTextValign */
+	SLYLANDRO_COLOR_MAP, /* AlienColorMap */
+	SLYLANDRO_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	SLYLANDRO_CONVERSATION_PHRASES, /* PlayerPhrases */
+	3, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{
+			4, /* StartIndex */
+			8, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, 0, /* FrameRate */
+			ONE_SECOND / 15, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			12, /* StartIndex */
+			9, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			21, /* StartIndex */
+			9, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+	},
+	{ /* AlienTransitionDesc - empty */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc - empty */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
 };
 
 static void
@@ -177,716 +259,205 @@ ExitConversation (RESPONSE_REF R)
 	(void) R;  // ignored
 	SET_GAME_STATE (BATTLE_SEGUE, 0);
 
-	switch (GET_GAME_STATE (SLYLANDRO_HOME_VISITS))
-	{
-		case 1:
-			NPCPhrase (GOODBYE_1);
-			break;
-		default:
-			NPCPhrase (GOODBYE_2);
-			break;
-	}
-}
-
-static void HomeWorld (RESPONSE_REF R);
-
-static void
-HumanInfo (RESPONSE_REF R)
-{
-	BYTE InfoLeft;
-
-	if (PLAYER_SAID (R, happy_to_tell_more))
-	{
-		NPCPhrase (TELL_MORE);
-
-		SET_GAME_STATE (SLYLANDRO_STACK4, 1);
-	}
-	else if (PLAYER_SAID (R, would_you_like_to_know_more))
-	{
-		NPCPhrase (YES_TELL_MORE);
-	}
-	else if (PLAYER_SAID (R, we_come_from_earth))
-	{
-		NPCPhrase (OK_EARTH);
-
-		SET_GAME_STATE (SLYLANDRO_KNOW_EARTH, 1);
-	}
-	else if (PLAYER_SAID (R, we_explore))
-	{
-		NPCPhrase (OK_EXPLORE);
-
-		SET_GAME_STATE (SLYLANDRO_KNOW_EXPLORE, 1);
-	}
-	else if (PLAYER_SAID (R, we_fight_urquan))
-	{
-		NPCPhrase (URQUAN_NICE_GUYS);
-
-		SET_GAME_STATE (SLYLANDRO_KNOW_URQUAN, 1);
-	}
-	else if (PLAYER_SAID (R, not_same_urquan))
-	{
-		NPCPhrase (PERSONALITY_CHANGE);
-
-		SET_GAME_STATE (SLYLANDRO_KNOW_URQUAN, 2);
-	}
-	else if (PLAYER_SAID (R, we_gather))
-	{
-		NPCPhrase (MAYBE_INTERESTED);
-
-		SET_GAME_STATE (SLYLANDRO_KNOW_GATHER, 1);
-	}
-
-	InfoLeft = FALSE;
-	if (GET_GAME_STATE (SLYLANDRO_KNOW_URQUAN) == 1)
-	{
-		InfoLeft = TRUE;
-		Response (not_same_urquan, HumanInfo);
-	}
-	if (!GET_GAME_STATE (SLYLANDRO_KNOW_EARTH))
-	{
-		InfoLeft = TRUE;
-		Response (we_come_from_earth, HumanInfo);
-	}
-	if (!GET_GAME_STATE (SLYLANDRO_KNOW_EXPLORE))
-	{
-		InfoLeft = TRUE;
-		Response (we_explore, HumanInfo);
-	}
-	if (!GET_GAME_STATE (SLYLANDRO_KNOW_URQUAN))
-	{
-		InfoLeft = TRUE;
-		Response (we_fight_urquan, HumanInfo);
-	}
-	if (!GET_GAME_STATE (SLYLANDRO_KNOW_GATHER))
-	{
-		InfoLeft = TRUE;
-		Response (we_gather, HumanInfo);
-	}
-
-	Response (enough_about_me, HomeWorld);
-	if (!InfoLeft)
-	{
-		SET_GAME_STATE (SLYLANDRO_STACK4, 2);
-	}
-}
-
-static void
-SlylandroInfo (RESPONSE_REF R)
-{
-	BYTE InfoLeft;
-
-	if (PLAYER_SAID (R, like_more_about_you))
-	{
-		NPCPhrase (SURE_KNOW_WHAT);
-	}
-	else if (PLAYER_SAID (R, what_about_home))
-	{
-		NPCPhrase (ABOUT_HOME);
-
-		DISABLE_PHRASE (what_about_home);
-	}
-	else if (PLAYER_SAID (R, what_about_culture))
-	{
-		NPCPhrase (ABOUT_CULTURE);
-
-		DISABLE_PHRASE (what_about_culture);
-	}
-	else if (PLAYER_SAID (R, what_about_history))
-	{
-		NPCPhrase (ABOUT_HISTORY);
-
-		DISABLE_PHRASE (what_about_history);
-	}
-	else if (PLAYER_SAID (R, what_about_biology))
-	{
-		NPCPhrase (ABOUT_BIOLOGY);
-
-		DISABLE_PHRASE (what_about_biology);
-	}
-
-	InfoLeft = FALSE;
-	if (PHRASE_ENABLED (what_about_home))
-	{
-		InfoLeft = TRUE;
-		Response (what_about_home, SlylandroInfo);
-	}
-	if (PHRASE_ENABLED (what_about_culture))
-	{
-		InfoLeft = TRUE;
-		Response (what_about_culture, SlylandroInfo);
-	}
-	if (PHRASE_ENABLED (what_about_history))
-	{
-		InfoLeft = TRUE;
-		Response (what_about_history, SlylandroInfo);
-	}
-	if (PHRASE_ENABLED (what_about_biology))
-	{
-		InfoLeft = TRUE;
-		Response (what_about_biology, SlylandroInfo);
-	}
-
-	Response (enough_info, HomeWorld);
-	if (!InfoLeft)
-	{
-		DISABLE_PHRASE (like_more_about_you);
-	}
-}
-
-static void
-FixBug (RESPONSE_REF R)
-{
-	if (PLAYER_SAID (R, think_about_rep_priorities))
-		NPCPhrase (UH_OH);
-	else if (PLAYER_SAID (R, hunt_them_down))
-	{
-		NPCPhrase (GROW_TOO_FAST);
-
-		DISABLE_PHRASE (hunt_them_down);
-	}
-	else if (PLAYER_SAID (R, sue_melnorme))
-	{
-		NPCPhrase (SIGNED_WAIVER);
-
-		DISABLE_PHRASE (sue_melnorme);
-	}
-	else if (PLAYER_SAID (R, recall_signal))
-	{
-		NPCPhrase (NOT_THIS_MODEL);
-
-		DISABLE_PHRASE (recall_signal);
-	}
-
-	if (PHRASE_ENABLED (hunt_them_down))
-		Response (hunt_them_down, FixBug);
-	if (PHRASE_ENABLED (sue_melnorme))
-		Response (sue_melnorme, FixBug);
-	if (PHRASE_ENABLED (recall_signal))
-		Response (recall_signal, FixBug);
-	Response (mega_self_destruct, HomeWorld);
-}
-
-static void
-ProbeBug (RESPONSE_REF R)
-{
-	if (PLAYER_SAID (R, probe_has_bug))
-		NPCPhrase (NO_IT_DOESNT);
-	else if (PLAYER_SAID (R, tell_me_about_rep_2))
-	{
-		NPCPhrase (REP_NO_PROBLEM);
-
-		DISABLE_PHRASE (tell_me_about_rep_2);
-	}
-	else if (PLAYER_SAID (R, what_about_rep_priorities))
-	{
-		NPCPhrase (MAXIMUM_SO_WHAT);
-
-		DISABLE_PHRASE (what_about_rep_priorities);
-	}
-	else if (PLAYER_SAID (R, tell_me_about_attack))
-	{
-		NPCPhrase (ATTACK_NO_PROBLEM);
-
-		DISABLE_PHRASE (tell_me_about_attack);
-	}
-
-	if (PHRASE_ENABLED (tell_me_about_rep_2))
-		Response (tell_me_about_rep_2, ProbeBug);
-	else if (PHRASE_ENABLED (what_about_rep_priorities))
-		Response (what_about_rep_priorities, ProbeBug);
-	else
-	{
-		Response (think_about_rep_priorities, FixBug);
-	}
-	if (PHRASE_ENABLED (tell_me_about_attack))
-		Response (tell_me_about_attack, ProbeBug);
-}
-
-static void ProbeInfo (RESPONSE_REF R);
-
-static void
-ProbeFunction (RESPONSE_REF R)
-{
-	BYTE LastStack;
-	RESPONSE_REF pStr[2];
-
-	LastStack = 0;
-	pStr[0] = pStr[1] = 0;
-	if (PLAYER_SAID (R, talk_more_probe_attack))
-	{
-		NPCPhrase (NO_PROBLEM_BUT_SURE);
-	}
-	else if (PLAYER_SAID (R, tell_me_about_basics))
-	{
-		NPCPhrase (BASIC_COMMANDS);
-
-		SET_GAME_STATE (PLAYER_KNOWS_PROGRAM, 1);
-		DISABLE_PHRASE (tell_basics_again);
-	}
-	else if (PLAYER_SAID (R, tell_basics_again))
-	{
-		NPCPhrase (OK_BASICS_AGAIN);
-
-		DISABLE_PHRASE (tell_basics_again);
-	}
-	else if (PLAYER_SAID (R, what_effect))
-	{
-		NPCPhrase (AFFECTS_BEHAVIOR);
-
-		SET_GAME_STATE (PLAYER_KNOWS_EFFECTS, 1);
-		DISABLE_PHRASE (what_effect);
-	}
-	else if (PLAYER_SAID (R, tell_me_about_rep_1))
-	{
-		NPCPhrase (ABOUT_REP);
-
-		LastStack = 2;
-		SET_GAME_STATE (SLYLANDRO_STACK8, 3);
-	}
-	else if (PLAYER_SAID (R, what_set_priority))
-	{
-		NPCPhrase (MAXIMUM);
-
-		SET_GAME_STATE (PLAYER_KNOWS_PRIORITY, 1);
-		DISABLE_PHRASE (what_set_priority);
-	}
-	else if (PLAYER_SAID (R, how_does_probe_defend))
-	{
-		NPCPhrase (ONLY_SELF_DEFENSE);
-
-		LastStack = 1;
-		SET_GAME_STATE (SLYLANDRO_STACK9, 1);
-	}
-	else if (PLAYER_SAID (R, combat_behavior))
-	{
-		NPCPhrase (MISSILE_BATTERIES);
-
-		LastStack = 1;
-		SET_GAME_STATE (SLYLANDRO_STACK9, 2);
-	}
-	else if (PLAYER_SAID (R, what_missile_batteries))
-	{
-		NPCPhrase (LIGHTNING_ONLY_FOR_HARVESTING);
-
-		SET_GAME_STATE (SLYLANDRO_STACK9, 3);
-	}
-
-	switch (GET_GAME_STATE (SLYLANDRO_STACK9))
+	if (PLAYER_SAID (R, not_fooling))
 	{
-		case 0:
-			pStr[0] = how_does_probe_defend;
-			break;
-		case 1:
-			pStr[0] = combat_behavior;
-			break;
-		case 2:
-			pStr[0] = what_missile_batteries;
-			break;
+		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		NPCPhrase (WHY_ATTACK);
 	}
-	switch (GET_GAME_STATE (SLYLANDRO_STACK8))
+	else if(!(GET_GAME_STATE(SLYLANDRO_KOHRAH_PANIC)))
 	{
-		case 2:
-			pStr[1] = tell_me_about_rep_1;
-			break;
-		case 3:
-			if (PHRASE_ENABLED (what_set_priority))
-				pStr[1] = what_set_priority;
-			break;
-	}
-
-	if (LastStack && pStr[LastStack - 1])
-		Response (pStr[LastStack - 1], ProbeFunction);
-	if (!GET_GAME_STATE (PLAYER_KNOWS_PROGRAM))
-		Response (tell_me_about_basics, ProbeFunction);
-	else
-	{
-		if (GET_GAME_STATE (PLAYER_KNOWS_PRIORITY))
+		switch (GET_GAME_STATE (SLYLANDRO_HOME_VISITS))
 		{
-			if (GET_GAME_STATE (PLAYER_KNOWS_EFFECTS))
-			{
-				Response (probe_has_bug, ProbeBug);
-			}
-			if (PHRASE_ENABLED (what_effect))
-				Response (what_effect, ProbeFunction);
+			case 1:
+				NPCPhrase (GOOD_BYE_OK);
+				break;
+			default:
+				NPCPhrase (GOOD_BYE_OK);
+				break;
 		}
-		if (PHRASE_ENABLED (tell_basics_again))
-			Response (tell_basics_again, ProbeFunction);
-	}
-	if (LastStack == 0)
-	{
-		do
-		{
-			if (pStr[LastStack])
-				Response (pStr[LastStack], ProbeFunction);
-		} while (++LastStack < 2);
 	}
 	else
 	{
-		LastStack = (LastStack - 1) ^ 1;
-		if (pStr[LastStack])
-			Response (pStr[LastStack], ProbeFunction);
+		switch (GET_GAME_STATE (SLYLANDRO_HOME_VISITS))
+		{
+			case 1:
+				NPCPhrase (GOOD_BYE_PANIC);
+				break;
+			default:
+				NPCPhrase (GOOD_BYE_PANIC);
+				break;
+		}
 	}
-
-	Response (enough_problem, ProbeInfo);
 }
 
 static void
-ProbeInfo (RESPONSE_REF R)
+MainTalk (RESPONSE_REF R)
 {
-	BYTE i, LastStack, InfoLeft;
-	RESPONSE_REF pStr[3];
-
-	LastStack = 0;
-	pStr[0] = pStr[1] = pStr[2] = 0;
-	if (PLAYER_SAID (R, what_are_probes))
+	BYTE stack2temp;
+	
+	if (PLAYER_SAID(R, close_call))
 	{
-		NPCPhrase (PROBES_ARE);
-
-		SET_GAME_STATE (SLYLANDRO_STACK5, 1);
+		NPCPhrase(WONDERFUL_THING);
+		SET_GAME_STATE(SLYLANDRO_STACK1, (GET_GAME_STATE (SLYLANDRO_STACK1)+1));
+		SET_GAME_STATE(KNOW_SLYLANDRO_KOHRAH, 1);
+		SET_GAME_STATE(SLYLANDRO_KOHRAH_PANIC, 0);
 	}
-	else if (PLAYER_SAID (R, know_more_probe))
-		NPCPhrase (OK_WHAT_MORE_PROBE);
-	else if (PLAYER_SAID (R, why_probe_always_attack))
+	
+	if (PLAYER_SAID(R, who_were_visitors))
 	{
-		NPCPhrase (ONLY_DEFEND);
-
-		SET_GAME_STATE (SLYLANDRO_STACK6, 1);
+		NPCPhrase(THE_VISITORS_WERE);
+		SET_GAME_STATE(SLYLANDRO_STACK1, (GET_GAME_STATE (SLYLANDRO_STACK1)+1));
 	}
-	else if (PLAYER_SAID (R, talk_more_probe_attack))
+
+	if (PLAYER_SAID(R, pose_danger))
 	{
-		ProbeFunction (R);
-		return;
+		NPCPhrase(GOOD_GUYS);
+		SET_GAME_STATE(SLYLANDRO_STACK1, (GET_GAME_STATE (SLYLANDRO_STACK1)+1));
 	}
-	else if (PLAYER_SAID (R, where_probes_from))
+	
+	if (PLAYER_SAID(R, up_no_good))
 	{
-		NPCPhrase (PROBES_FROM_MELNORME);
-
-		LastStack = 1;
-		SET_GAME_STATE (SLYLANDRO_STACK7, 1);
+		NPCPhrase(NO_GO_BACK);
+		SET_GAME_STATE(SLYLANDRO_STACK1, (GET_GAME_STATE (SLYLANDRO_STACK1)+1));
+		Response(your_funeral, MainTalk);
+		DISABLE_PHRASE(better_go_back);
 	}
-	else if (PLAYER_SAID (R, why_sell))
+	
+	if (PLAYER_SAID(R, better_go_back))
 	{
-		NPCPhrase (SELL_FOR_INFO);
-
-		LastStack = 1;
-		SET_GAME_STATE (SLYLANDRO_STACK7, 2);
+		SET_GAME_STATE(KNOW_SLYLANDRO_KOHRAH, 1);
+		SET_GAME_STATE(SLYLANDRO_KOHRAH_PANIC, 0);
+		SET_GAME_STATE(SLYLANDRO_STACK3, (GET_GAME_STATE (SLYLANDRO_STACK3)+1));
+		NPCPhrase(NO_GO_BACK);
+		Response(your_funeral, MainTalk);
+		DISABLE_PHRASE(up_no_good);
+		DISABLE_PHRASE(better_go_back);
 	}
-	else if (PLAYER_SAID (R, how_long_ago))
+	
+	if (PLAYER_SAID(R, your_funeral))
 	{
-		NPCPhrase (FIFTY_THOUSAND_ROTATIONS);
-
-		SET_GAME_STATE (SLYLANDRO_STACK7, 3);
+		NPCPhrase(THANK_YOU);
 	}
-	else if (PLAYER_SAID (R, whats_probes_mission))
+	
+	if (PLAYER_SAID(R, sorry_mistake))
 	{
-		NPCPhrase (SEEK_OUT_NEW_LIFE);
-
-		LastStack = 2;
-		SET_GAME_STATE (SLYLANDRO_STACK8, 1);
+		SET_GAME_STATE(SLYLANDRO_KOHRAH_PANIC, 0);
+		NPCPhrase(MISTAKE_FORGIVEN);
 	}
-	else if (PLAYER_SAID (R, if_only_one))
+	
+	if (PLAYER_SAID(R, ask_news_1))
 	{
-		NPCPhrase (THEY_REPLICATE);
-
-		SET_GAME_STATE (SLYLANDRO_STACK8, 2);
-	}
-	else if (PLAYER_SAID (R, enough_problem))
-		NPCPhrase (OK_ENOUGH_PROBLEM);
-
-	if (!GET_GAME_STATE (SLYLANDRO_KNOW_BROKEN)
-			&& GET_GAME_STATE (PROBE_EXHIBITED_BUG))
-	{
-		switch (GET_GAME_STATE (SLYLANDRO_STACK6))
+		DISABLE_PHRASE(ask_news_1);
+		stack2temp = GET_GAME_STATE (SLYLANDRO_STACK2);
+		
+		switch (stack2temp)
 		{
 			case 0:
-				pStr[0] = why_probe_always_attack;
+				NPCPhrase(GIVE_NEWS_1);
 				break;
-			case 1:
-				pStr[0] = talk_more_probe_attack;
+			default:
+				NPCPhrase(GIVE_NEWS_2);
+				stack2temp--;
 				break;
 		}
+		
+		stack2temp++;
+		SET_GAME_STATE(SLYLANDRO_STACK2, stack2temp);
 	}
-	switch (GET_GAME_STATE (SLYLANDRO_STACK7))
+	
+	switch (GET_GAME_STATE (SLYLANDRO_STACK1))
 	{
 		case 0:
-			pStr[1] = where_probes_from;
+			if (!(GET_GAME_STATE(KNOW_SLYLANDRO_KOHRAH)))
+				Response (not_fooling, ExitConversation);
+			Response (close_call, MainTalk);
 			break;
 		case 1:
-			pStr[1] = why_sell;
+			if(!(GET_GAME_STATE(SLYLANDRO_KOHRAH_PANIC)))
+				Response (who_were_visitors, MainTalk);
 			break;
 		case 2:
-			pStr[1] = how_long_ago;
+			if(!(GET_GAME_STATE(SLYLANDRO_KOHRAH_PANIC)))
+				Response (pose_danger, MainTalk);
 			break;
-	}
-	switch (GET_GAME_STATE (SLYLANDRO_STACK8))
-	{
-		case 0:
-			pStr[2] = whats_probes_mission;
-			break;
-		case 1:
-			pStr[2] = if_only_one;
+		case 3:
+			if (PHRASE_ENABLED(up_no_good) && !(GET_GAME_STATE(SLYLANDRO_KOHRAH_PANIC)))
+				Response (up_no_good, MainTalk);
 			break;
 	}
-
-	InfoLeft = FALSE;
-	if (pStr[LastStack])
+	
+	if (GET_GAME_STATE(SLYLANDRO_STACK1)>0 
+		&& PHRASE_ENABLED(ask_news_1)
+		&& !(GET_GAME_STATE(SLYLANDRO_KOHRAH_PANIC)))
 	{
-		InfoLeft = TRUE;
-		Response (pStr[LastStack], ProbeInfo);
+		Response (ask_news_1, MainTalk);
 	}
-	for (i = 0; i < 3; ++i)
+	
+	if(GET_GAME_STATE(SLYLANDRO_STACK3)<1 && PHRASE_ENABLED(better_go_back))
+		Response (better_go_back, MainTalk);
+	
+	if(GET_GAME_STATE(KNOW_SLYLANDRO_KOHRAH))
 	{
-		if (i != LastStack && pStr[i])
+		if (!(GET_GAME_STATE(SLYLANDRO_KOHRAH_PANIC)))
+			Response (good_bye_ok, ExitConversation);
+		else
 		{
-			InfoLeft = TRUE;
-			Response (pStr[i], ProbeInfo);
+			Response (sorry_mistake, MainTalk);
+			Response (good_bye_short, ExitConversation);
 		}
 	}
-
-	Response (enough_probe, HomeWorld);
-	if (!InfoLeft)
-	{
-		DISABLE_PHRASE (know_more_probe);
-	}
+	else
+		Response (good_bye_confused, ExitConversation);
 }
 
 static void
-HomeWorld (RESPONSE_REF R)
+Intro (void)
 {
-	BYTE i, LastStack;
-	RESPONSE_REF pStr[3];
-
-	LastStack = 0;
-	pStr[0] = pStr[1] = pStr[2] = 0;
-	if (PLAYER_SAID (R, we_are_us0))
-	{
-		NPCPhrase (TERRIBLY_EXCITING);
-
-		SET_GAME_STATE (SLYLANDRO_STACK1, 1);
-		DISABLE_PHRASE (we_are_us0);
-	}
-	else if (PLAYER_SAID (R, what_other_visitors))
-	{
-		NPCPhrase (VISITORS);
-
-		SET_GAME_STATE (PLAYER_KNOWS_PROBE, 1);
-		SET_GAME_STATE (SLYLANDRO_STACK1, 2);
-	}
-	else if (PLAYER_SAID (R, any_other_visitors))
-	{
-		NPCPhrase (LONG_AGO);
-
-		SET_GAME_STATE (SLYLANDRO_STACK1, 3);
-	}
-	else if (PLAYER_SAID (R, what_about_sentient_milieu))
-	{
-		NPCPhrase (MET_TAALO_THEY_ARE_FROM);
-
-		SET_GAME_STATE (SLYLANDRO_STACK1, 4);
-	}
-	else if (PLAYER_SAID (R, who_else))
-	{
-		NPCPhrase (PRECURSORS);
-
-		SET_GAME_STATE (SLYLANDRO_STACK1, 5);
-	}
-	else if (PLAYER_SAID (R, precursors_yow))
-	{
-		NPCPhrase (ABOUT_PRECURSORS);
-
-		SET_GAME_STATE (SLYLANDRO_STACK1, 6);
-	}
-	else if (PLAYER_SAID (R, must_know_more))
-	{
-		NPCPhrase (ALL_WE_KNOW);
-
-		SET_GAME_STATE (SLYLANDRO_STACK1, 7);
-	}
-	else if (PLAYER_SAID (R, who_are_you))
-	{
-		NPCPhrase (WE_ARE_SLY);
-
-		LastStack = 1;
-		SET_GAME_STATE (SLYLANDRO_STACK2, 1);
-	}
-	else if (PLAYER_SAID (R, where_are_you))
-	{
-		NPCPhrase (DOWN_HERE);
-
-		LastStack = 2;
-		SET_GAME_STATE (SLYLANDRO_STACK3, 1);
-	}
-	else if (PLAYER_SAID (R, thats_impossible_1))
-	{
-		NPCPhrase (NO_ITS_NOT_1);
-
-		LastStack = 2;
-		SET_GAME_STATE (SLYLANDRO_STACK3, 2);
-	}
-	else if (PLAYER_SAID (R, thats_impossible_2))
-	{
-		NPCPhrase (NO_ITS_NOT_2);
-
-		LastStack = 2;
-		SET_GAME_STATE (SLYLANDRO_STACK3, 3);
-	}
-	else if (PLAYER_SAID (R, like_more_about_you))
-	{
-		SlylandroInfo (R);
-		return;
-	}
-	else if (PLAYER_SAID (R, enough_about_me))
-		NPCPhrase (OK_ENOUGH_YOU);
-	else if (PLAYER_SAID (R, enough_info))
-		NPCPhrase (OK_ENOUGH_INFO);
-	else if (PLAYER_SAID (R, enough_probe))
-		NPCPhrase (OK_ENOUGH_PROBE);
-	else if (PLAYER_SAID (R, mega_self_destruct))
-	{
-		NPCPhrase (WHY_YES_THERE_IS);
-
-		SET_GAME_STATE (SLYLANDRO_KNOW_BROKEN, 1);
-		SET_GAME_STATE (DESTRUCT_CODE_ON_SHIP, 1);
-		i = GET_GAME_STATE (SLYLANDRO_MULTIPLIER) + 1;
-		SET_GAME_STATE (SLYLANDRO_MULTIPLIER, i);
-		AddEvent (RELATIVE_EVENT, 0, 0, 0, SLYLANDRO_RAMP_DOWN);
-	}
-
-	switch (GET_GAME_STATE (SLYLANDRO_STACK1))
-	{
-		case 0:
-			construct_response (shared_phrase_buf,
-					we_are_us0,
-					GLOBAL_SIS (CommanderName),
-					we_are_us1,
-					GLOBAL_SIS (ShipName),
-					we_are_us2,
-					(UNICODE*)NULL);
-			pStr[0] = we_are_us0;
-			break;
-		case 1:
-			pStr[0] = what_other_visitors;
-			break;
-		case 2:
-			pStr[0] = any_other_visitors;
-			break;
-		case 3:
-			pStr[0] = what_about_sentient_milieu;
-			break;
-		case 4:
-			pStr[0] = who_else;
-			break;
-		case 5:
-			pStr[0] = precursors_yow;
-			break;
-		case 6:
-			pStr[0] = must_know_more;
-			break;
-	}
-	switch (GET_GAME_STATE (SLYLANDRO_STACK2))
-	{
-		case 0:
-			pStr[1] = who_are_you;
-			break;
-		case 1:
-			if (PHRASE_ENABLED (like_more_about_you))
-				pStr[1] = like_more_about_you;
-			break;
-	}
-	switch (GET_GAME_STATE (SLYLANDRO_STACK3))
-	{
-		case 0:
-			pStr[2] = where_are_you;
-			break;
-		case 1:
-			pStr[2] = thats_impossible_1;
-			break;
-		case 2:
-			pStr[2] = thats_impossible_2;
-			break;
-	}
+	BYTE NumVisits;
 
-	if (pStr[LastStack])
-	{
-		if (pStr[LastStack] != we_are_us0)
-			Response (pStr[LastStack], HomeWorld);
-		else
-			DoResponsePhrase (pStr[LastStack], HomeWorld, shared_phrase_buf);
-	}
-	for (i = 0; i < 3; ++i)
+	NumVisits = GET_GAME_STATE (SLYLANDRO_KOHRAH_MET_TIMES);
+	
+	if (!(GET_GAME_STATE(SLYLANDRO_KOHRAH_PANIC)))
 	{
-		if (i != LastStack && pStr[i])
-		{
-			if (pStr[i] != we_are_us0)
-				Response (pStr[i], HomeWorld);
-			else
-				DoResponsePhrase (pStr[i], HomeWorld, shared_phrase_buf);
-		}
-	}
-	if (GET_GAME_STATE (SLYLANDRO_STACK1))
-	{
-		switch (GET_GAME_STATE (SLYLANDRO_STACK4))
+		switch (NumVisits++)
 		{
 			case 0:
-				Response (happy_to_tell_more, HumanInfo);
+				NPCPhrase (HELLO_1);
 				break;
 			case 1:
-				Response (would_you_like_to_know_more, HumanInfo);
+				NPCPhrase (HELLO_2);
 				break;
-		}
-	}
-	if (GET_GAME_STATE (PLAYER_KNOWS_PROBE)
-			&& !GET_GAME_STATE (SLYLANDRO_KNOW_BROKEN))
-	{
-		switch (GET_GAME_STATE (SLYLANDRO_STACK5))
-		{
-			case 0:
-				Response (what_are_probes, ProbeInfo);
+			case 2:
+				NPCPhrase (HELLO_3);
 				break;
-			case 1:
-				if (PHRASE_ENABLED (know_more_probe))
-					Response (know_more_probe, ProbeInfo);
+			case 3:
+				NPCPhrase (HELLO_4);
+				--NumVisits;
 				break;
 		}
 	}
-	Response (bye, ExitConversation);
-}
-
-static void
-Intro (void)
-{
-	BYTE NumVisits;
-
-	if (GET_GAME_STATE (SLYLANDRO_KNOW_BROKEN)
-			&& (NumVisits = GET_GAME_STATE (RECALL_VISITS)) == 0)
-	{
-		NPCPhrase (RECALL_PROGRAM_1);
-		++NumVisits;
-		SET_GAME_STATE (RECALL_VISITS, NumVisits);
-	}
 	else
 	{
-		NumVisits = GET_GAME_STATE (SLYLANDRO_HOME_VISITS);
 		switch (NumVisits++)
 		{
 			case 0:
-				NPCPhrase (HELLO_1);
+				NPCPhrase (PANIC_HELLO_1);
 				break;
 			case 1:
-				NPCPhrase (HELLO_2);
+				NPCPhrase (PANIC_HELLO_2);
 				break;
 			case 2:
-				NPCPhrase (HELLO_3);
+				NPCPhrase (PANIC_HELLO_1);
 				break;
 			case 3:
-				NPCPhrase (HELLO_4);
-				--NumVisits;
+				NPCPhrase (PANIC_HELLO_2);
+				NumVisits -= 2;
 				break;
 		}
-		SET_GAME_STATE (SLYLANDRO_HOME_VISITS, NumVisits);
 	}
 
-	HomeWorld ((RESPONSE_REF)0);
+	SET_GAME_STATE (SLYLANDRO_KOHRAH_MET_TIMES, NumVisits);
+	MainTalk ((RESPONSE_REF)0);
 }
 
 static COUNT
@@ -904,8 +475,20 @@ post_slylandro_enc (void)
 LOCDATA*
 init_slylandro_comm (void)
 {
+	static LOCDATA slylandro_desc;
 	LOCDATA *retval;
 
+	switch (RESOLUTION_FACTOR)
+	{
+	case 2:
+		slylandro_desc = slylandro_desc_4x;
+		break;
+	case 0:
+	default:
+		slylandro_desc = slylandro_desc_1x;
+		break;
+	}
+	
 	slylandro_desc.init_encounter_func = Intro;
 	slylandro_desc.post_encounter_func = post_slylandro_enc;
 	slylandro_desc.uninit_encounter_func = uninit_slylandro;
@@ -914,7 +497,12 @@ init_slylandro_comm (void)
 	slylandro_desc.AlienTextBaseline.y = 0;
 	slylandro_desc.AlienTextWidth = SIS_TEXT_WIDTH;
 
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	// JMS: Always Battle segue 'cause its impossible to tell are these guys kohr-ah or slylandros...
+	SET_GAME_STATE (BATTLE_SEGUE, 1);
+	
+	// JMS: Zero the escape flag
+	SET_GAME_STATE (ENEMY_ESCAPE_OCCURRED, 0);
+	
 	retval = &slylandro_desc;
 
 	return (retval);
diff -ruNp src.orig/uqm/comm/slyhome/strings.h src/uqm/comm/slyhome/strings.h
--- src.orig/uqm/comm/slyhome/strings.h	2017-11-01 15:30:23 -0700
+++ src/uqm/comm/slyhome/strings.h	2017-11-01 15:31:01 -0700
@@ -26,118 +26,31 @@ enum
 	HELLO_2,
 	HELLO_3,
 	HELLO_4,
-	RECALL_PROGRAM_1,
-	we_are_us0,
-	we_are_us1,
-	we_are_us2,
-	TERRIBLY_EXCITING,
-	happy_to_tell_more,
-	TELL_MORE,
-	would_you_like_to_know_more,
-	YES_TELL_MORE,
-	we_come_from_earth,
-	OK_EARTH,
-	we_explore,
-	OK_EXPLORE,
-	we_fight_urquan,
-	URQUAN_NICE_GUYS,
-	not_same_urquan,
-	PERSONALITY_CHANGE,
-	we_gather,
-	MAYBE_INTERESTED,
-	enough_about_me,
-	OK_ENOUGH_YOU,
-	what_other_visitors,
-	VISITORS,
-	any_other_visitors,
-	LONG_AGO,
-	what_about_sentient_milieu,
-	MET_TAALO_THEY_ARE_FROM,
-	who_else,
-	PRECURSORS,
-	precursors_yow,
-	ABOUT_PRECURSORS,
-	must_know_more,
-	ALL_WE_KNOW,
-	who_are_you,
-	WE_ARE_SLY,
-	like_more_about_you,
-	SURE_KNOW_WHAT,
-	what_about_home,
-	ABOUT_HOME,
-	what_about_culture,
-	ABOUT_CULTURE,
-	what_about_history,
-	ABOUT_HISTORY,
-	what_about_biology,
-	ABOUT_BIOLOGY,
-	enough_info,
-	OK_ENOUGH_INFO,
-	where_are_you,
-	DOWN_HERE,
-	thats_impossible_1,
-	NO_ITS_NOT_1,
-	thats_impossible_2,
-	NO_ITS_NOT_2,
-	bye,
-	GOODBYE_1,
-	GOODBYE_2,
-	what_are_probes,
-	PROBES_ARE,
-	know_more_probe,
-	OK_WHAT_MORE_PROBE,
-	where_probes_from,
-	PROBES_FROM_MELNORME,
-	why_sell,
-	SELL_FOR_INFO,
-	how_long_ago,
-	FIFTY_THOUSAND_ROTATIONS,
-	whats_probes_mission,
-	SEEK_OUT_NEW_LIFE,
-	if_only_one,
-	THEY_REPLICATE,
-	enough_probe,
-	OK_ENOUGH_PROBE,
-	why_probe_always_attack,
-	ONLY_DEFEND,
-	talk_more_probe_attack,
-	NO_PROBLEM_BUT_SURE,
-	tell_me_about_basics,
-	BASIC_COMMANDS,
-	tell_basics_again,
-	OK_BASICS_AGAIN,
-	what_effect,
-	AFFECTS_BEHAVIOR,
-	how_does_probe_defend,
-	ONLY_SELF_DEFENSE,
-	combat_behavior,
-	MISSILE_BATTERIES,
-	what_missile_batteries,
-	LIGHTNING_ONLY_FOR_HARVESTING,
-	tell_me_about_rep_1,
-	ABOUT_REP,
-	what_set_priority,
-	MAXIMUM,
-	enough_problem,
-	OK_ENOUGH_PROBLEM,
-	probe_has_bug,
-	NO_IT_DOESNT,
-	tell_me_about_attack,
-	ATTACK_NO_PROBLEM,
-	tell_me_about_rep_2,
-	REP_NO_PROBLEM,
-	what_about_rep_priorities,
-	MAXIMUM_SO_WHAT,
-	think_about_rep_priorities,
-	UH_OH,
-	hunt_them_down,
-	GROW_TOO_FAST,
-	sue_melnorme,
-	SIGNED_WAIVER,
-	recall_signal,
-	NOT_THIS_MODEL,
-	mega_self_destruct,
-	WHY_YES_THERE_IS,
+	PANIC_HELLO_1,
+	PANIC_HELLO_2,
+	not_fooling,
+	WHY_ATTACK,
+	close_call,
+	WONDERFUL_THING,
+	who_were_visitors,
+	THE_VISITORS_WERE,
+	pose_danger,
+	GOOD_GUYS,
+	up_no_good,
+	better_go_back,
+	NO_GO_BACK,
+	your_funeral,
+	THANK_YOU,
+	ask_news_1,
+	GIVE_NEWS_1,
+	GIVE_NEWS_2,
+	sorry_mistake,
+	MISTAKE_FORGIVEN,
+	good_bye_confused,
+	good_bye_ok,
+	good_bye_short,
+	GOOD_BYE_OK,
+	GOOD_BYE_PANIC,
 };
 
 #endif /* _STRINGS_H */
diff -ruNp src.orig/uqm/comm/slyland/slyland.c src/uqm/comm/slyland/slyland.c
--- src.orig/uqm/comm/slyland/slyland.c	2017-11-01 15:30:24 -0700
+++ src/uqm/comm/slyland/slyland.c	2017-11-01 15:31:01 -0700
@@ -17,7 +17,6 @@
  */
 
 #include "../commall.h"
-#include <stdlib.h>
 #include "resinst.h"
 #include "strings.h"
 
@@ -26,10 +25,9 @@
 #include "uqm/setup.h"
 
 
-static const NUMBER_SPEECH_DESC probe_numbers_english;
-
 static LOCDATA slylandro_desc =
 {
+	SLYLANDRO_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -113,95 +111,17 @@ static LOCDATA slylandro_desc =
 		0, 0, /* RestartRate */
 		0, /* BlockMask */
 	},
-	&probe_numbers_english, /* AlienNumberSpeech - default */
+	NULL, /* AlienNumberSpeech - none */
 	/* Filler for loaded resources */
 	NULL, NULL, NULL,
 	NULL,
 	NULL,
-};
-
-static COUNT probe_digit_names[] =
-{
-	ENUMERATE_ZERO,
-	ENUMERATE_ONE,
-	ENUMERATE_TWO,
-	ENUMERATE_THREE,
-	ENUMERATE_FOUR,
-	ENUMERATE_FIVE,
-	ENUMERATE_SIX,
-	ENUMERATE_SEVEN,
-	ENUMERATE_EIGHT,
-	ENUMERATE_NINE,
-};
-
-static COUNT probe_teen_names[] =
-{
-	ENUMERATE_TEN,
-	ENUMERATE_ELEVEN,
-	ENUMERATE_TWELVE,
-	ENUMERATE_THIRTEEN,
-	ENUMERATE_FOURTEEN,
-	ENUMERATE_FIFTEEN,
-	ENUMERATE_SIXTEEN,
-	ENUMERATE_SEVENTEEN,
-	ENUMERATE_EIGHTEEN,
-	ENUMERATE_NINETEEN,
-};
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
 
-static COUNT probe_tens_names[] =
-{
-	0, /* invalid */
-	0, /* skip digit */
-	ENUMERATE_TWENTY,
-	ENUMERATE_THIRTY,
-	ENUMERATE_FOURTY,
-	ENUMERATE_FIFTY,
-	ENUMERATE_SIXTY,
-	ENUMERATE_SEVENTY,
-	ENUMERATE_EIGHTY,
-	ENUMERATE_NINETY,
-};
-
-static const NUMBER_SPEECH_DESC probe_numbers_english =
-{
-	5, /* NumDigits */
-	{
-		{ /* 1000-999999 */
-			1000, /* Divider */
-			0, /* Subtrahend */
-			NULL, /* StrDigits - recurse */
-			NULL, /* Names - not used */
-			ENUMERATE_THOUSAND /* CommonIndex */
-		},
-		{ /* 100-999 */
-			100, /* Divider */
-			0, /* Subtrahend */
-			probe_digit_names, /* StrDigits */
-			NULL, /* Names - not used */
-			ENUMERATE_HUNDRED /* CommonIndex */
-		},
-		{ /* 20-99 */
-			10, /* Divider */
-			0, /* Subtrahend */
-			probe_tens_names, /* StrDigits */
-			NULL, /* Names - not used */
-			0 /* CommonIndex - not used */
-		},
-		{ /* 10-19 */
-			1, /* Divider */
-			10, /* Subtrahend */
-			probe_teen_names, /* StrDigits */
-			NULL, /* Names - not used */
-			0 /* CommonIndex - not used */
-		},
-		{ /* 0-9 */
-			1, /* Divider */
-			0, /* Subtrahend */
-			probe_digit_names, /* StrDigits */
-			NULL, /* Names - not used */
-			0 /* CommonIndex - not used */
-		}
-	}
 };
 
 static RESPONSE_REF threat,
@@ -211,19 +131,6 @@ static RESPONSE_REF threat,
 			bye;
 
 static void
-sayCoord (int coord)
-{
-	int ac;
-	
-	ac = abs (coord);
-
-	NPCPhrase_splice (coord < 0 ? COORD_MINUS : COORD_PLUS);
-	NPCNumber (ac / 10, "%03d");
-	NPCPhrase_splice (COORD_POINT);
-	NPCNumber (ac % 10, NULL);
-}
-
-static void
 CombatIsInevitable (RESPONSE_REF R)
 {
 	if (R == 0)
@@ -366,6 +273,13 @@ CombatIsInevitable (RESPONSE_REF R)
 		else if (PLAYER_SAID (R, we_are_us))
 		{
 			NumVisits = GET_GAME_STATE (SLYLANDRO_PROBE_ID);
+			if (NumVisits == 3 && !optSubtitles)
+			{
+				/* If playing without subtitles, don't use the
+				 * last item in the conversation tree, which mentions
+				 * coordinates which can't be spoken. */
+				NumVisits--;
+			}
 			switch (NumVisits++)
 			{
 				case 0:
@@ -379,16 +293,9 @@ CombatIsInevitable (RESPONSE_REF R)
 					break;
 				case 3:
 				{
-					SIZE dx, dy;
-
-					// Probe's coordinate system is {-Y,X} relative to B Corvi
-					dx = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x)) - 333;
-					dy = 9812 - LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
-
 					NPCPhrase (THIS_IS_PROBE_40);
-					sayCoord (dy);
-					NPCPhrase_splice (THIS_IS_PROBE_41);
-					sayCoord (dx);
+					NPCPhrase (THIS_IS_PROBE_41);
+					NPCPhrase (GLOBAL_PLAYER_LOCATION);
 					NPCPhrase (THIS_IS_PROBE_42);
 
 					--NumVisits;
diff -ruNp src.orig/uqm/comm/slyland/strings.h src/uqm/comm/slyland/strings.h
--- src.orig/uqm/comm/slyland/strings.h	2017-11-01 15:30:24 -0700
+++ src/uqm/comm/slyland/strings.h	2017-11-01 15:31:01 -0700
@@ -75,39 +75,6 @@ enum
 	HOSTILE,
 	DESTRUCT_SEQUENCE,
 	destruct_code,
-	COORD_PLUS,
-	COORD_MINUS,
-	COORD_POINT,
-	ENUMERATE_HUNDRED,
-	ENUMERATE_THOUSAND,
-	ENUMERATE_ZERO,
-	ENUMERATE_ONE,
-	ENUMERATE_TWO,
-	ENUMERATE_THREE,
-	ENUMERATE_FOUR,
-	ENUMERATE_FIVE,
-	ENUMERATE_SIX,
-	ENUMERATE_SEVEN,
-	ENUMERATE_EIGHT,
-	ENUMERATE_NINE,
-	ENUMERATE_TEN,
-	ENUMERATE_ELEVEN,
-	ENUMERATE_TWELVE,
-	ENUMERATE_THIRTEEN,
-	ENUMERATE_FOURTEEN,
-	ENUMERATE_FIFTEEN,
-	ENUMERATE_SIXTEEN,
-	ENUMERATE_SEVENTEEN,
-	ENUMERATE_EIGHTEEN,
-	ENUMERATE_NINETEEN,
-	ENUMERATE_TWENTY,
-	ENUMERATE_THIRTY,
-	ENUMERATE_FOURTY,
-	ENUMERATE_FIFTY,
-	ENUMERATE_SIXTY,
-	ENUMERATE_SEVENTY,
-	ENUMERATE_EIGHTY,
-	ENUMERATE_NINETY,
 };
 
 #endif /* _STRINGS_H */
diff -ruNp src.orig/uqm/comm/spahome/spahome.c src/uqm/comm/spahome/spahome.c
--- src.orig/uqm/comm/spahome/spahome.c	2017-11-01 15:30:24 -0700
+++ src/uqm/comm/spahome/spahome.c	2017-11-01 15:31:01 -0700
@@ -26,6 +26,7 @@
 
 static LOCDATA spahome_desc =
 {
+	SPATHI_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -181,786 +182,79 @@ static LOCDATA spahome_desc =
 	NULL, NULL, NULL,
 	NULL,
 	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
 };
 
 static void
 ExitConversation (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
-	if (PLAYER_SAID (R, we_attack_again))
-	{
-		NPCPhrase (WE_FIGHT_AGAIN);
-
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
-	}
-	else if (PLAYER_SAID (R, surrender_or_die))
-	{
-		NPCPhrase (DEFEND_OURSELVES);
-
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
-	}
-	else if (PLAYER_SAID (R, we_are_vindicator0))
-	{
-		NPCPhrase (NO_PASSWORD);
-
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
-	}
-	else if (PLAYER_SAID (R, gort_merenga)
-			|| PLAYER_SAID (R, guph_florp)
-			|| PLAYER_SAID (R, wagngl_fthagn)
-			|| PLAYER_SAID (R, pleeese))
+	if (PLAYER_SAID (R, huffi_muffi_guffi))
 	{
-		NPCPhrase (WRONG_PASSWORD);
-
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
-	}
-	else if (PLAYER_SAID (R, screw_password))
-	{
-		NPCPhrase (NO_PASSWORD);
-
+		NPCPhrase (CYPHER_OBSOLETE);
 		SET_GAME_STATE (BATTLE_SEGUE, 1);
 	}
-	else if (PLAYER_SAID (R, bye_no_ally_offer))
-		NPCPhrase (GOODBYE_NO_ALLY_OFFER);
-	else if (PLAYER_SAID (R, bye_angry_spathi))
-		NPCPhrase (GOODBYE_ANGRY_SPATHI);
-	else if (PLAYER_SAID (R, bye_ally))
-		NPCPhrase (GOODBYE_ALLY);
-	else if (PLAYER_SAID (R, already_got_them))
+	else if (PLAYER_SAID (R, gods_work))
 	{
-		NPCPhrase (EARLY_BIRD_CHECK);
-
-		SET_GAME_STATE (SPATHI_HOME_VISITS, 0);
-		SET_GAME_STATE (SPATHI_VISITS, 0);
-		SET_GAME_STATE (SPATHI_PARTY, 1);
-		SET_GAME_STATE (SPATHI_MANNER, 3);
-	}
-	else if (PLAYER_SAID (R, too_dangerous))
-		NPCPhrase (WE_AGREE);
-	else if (PLAYER_SAID (R, think_more))
-		NPCPhrase (COWARD);
-	else if (PLAYER_SAID (R, i_accept))
-	{
-		NPCPhrase (AWAIT_RETURN);
-
-		SET_GAME_STATE (SPATHI_QUEST, 1);
-		SET_GAME_STATE (SPATHI_MANNER, 3);
-		SET_GAME_STATE (SPATHI_VISITS, 0);
-	}
-	else if (PLAYER_SAID (R, do_as_we_say))
-	{
-		NPCPhrase (DEPART_FOR_EARTH);
-
-		ActivateStarShip (SPATHI_SHIP, SET_ALLIED);
-		AddEvent (RELATIVE_EVENT, 6, 0, 0, SPATHI_SHIELD_EVENT);
-		SET_GAME_STATE (SPATHI_HOME_VISITS, 0);
-		SET_GAME_STATE (SPATHI_VISITS, 0);
-	}
-	else if (PLAYER_SAID (R, killed_them_all_1))
-	{
-		NPCPhrase (WILL_CHECK_1);
-
-		if (!GET_GAME_STATE (SPATHI_CREATURES_ELIMINATED))
-		{
-			SET_GAME_STATE (LIED_ABOUT_CREATURES, 1);
-		}
-		else
-		{
-			SET_GAME_STATE (SPATHI_HOME_VISITS, 0);
-			SET_GAME_STATE (SPATHI_VISITS, 0);
-			SET_GAME_STATE (SPATHI_PARTY, 1);
-			SET_GAME_STATE (SPATHI_MANNER, 3);
-		}
-	}
-	else if (PLAYER_SAID (R, killed_them_all_2))
-	{
-		NPCPhrase (WILL_CHECK_2);
-
-		if (!GET_GAME_STATE (SPATHI_CREATURES_ELIMINATED))
-		{
-			SET_GAME_STATE (LIED_ABOUT_CREATURES, 2);
-		}
-		else
-		{
-			SET_GAME_STATE (SPATHI_HOME_VISITS, 0);
-			SET_GAME_STATE (SPATHI_VISITS, 0);
-			SET_GAME_STATE (SPATHI_PARTY, 1);
-			SET_GAME_STATE (SPATHI_MANNER, 3);
-		}
-	}
-	else if (PLAYER_SAID (R, bye_before_party))
-	{
-		NPCPhrase (GOODBYE_BEFORE_PARTY);
-	}
-	else if (PLAYER_SAID (R, bye_from_party_1)
-		   || PLAYER_SAID (R, bye_from_party_2)
-		   || PLAYER_SAID (R, bye_from_party_3))
-	{
-		NPCPhrase (GOODBYE_FROM_PARTY);
-	}
-}
-
-static void SpathiAllies (RESPONSE_REF R);
-
-static void
-SpathiInfo (RESPONSE_REF R)
-{
-	BYTE InfoLeft;
-	
-	InfoLeft = FALSE;
-	if (PLAYER_SAID (R, like_some_info))
-		NPCPhrase (WHAT_ABOUT);
-	else if (PLAYER_SAID (R, what_about_hierarchy))
-	{
-		NPCPhrase (ABOUT_HIERARCHY);
-
-		DISABLE_PHRASE (what_about_hierarchy);
-	}
-	else if (PLAYER_SAID (R, what_about_history))
-	{
-		NPCPhrase (ABOUT_HISTORY);
-
-		DISABLE_PHRASE (what_about_history);
-	}
-	else if (PLAYER_SAID (R, what_about_alliance))
-	{
-		NPCPhrase (ABOUT_ALLIANCE);
-
-		DISABLE_PHRASE (what_about_alliance);
-	}
-	else if (PLAYER_SAID (R, what_about_other))
-	{
-		NPCPhrase (ABOUT_OTHER);
-
-		DISABLE_PHRASE (what_about_other);
-	}
-	else if (PLAYER_SAID (R, what_about_precursors))
-	{
-		NPCPhrase (ABOUT_PRECURSORS);
-
-		DISABLE_PHRASE (what_about_precursors);
-	}
-
-	if (PHRASE_ENABLED (what_about_hierarchy))
-	{
-		InfoLeft = TRUE;
-		Response (what_about_hierarchy, SpathiInfo);
-	}
-	if (PHRASE_ENABLED (what_about_history))
-	{
-		InfoLeft = TRUE;
-		Response (what_about_history, SpathiInfo);
-	}
-	if (PHRASE_ENABLED (what_about_alliance))
-	{
-		InfoLeft = TRUE;
-		Response (what_about_alliance, SpathiInfo);
-	}
-	if (PHRASE_ENABLED (what_about_other))
-	{
-		InfoLeft = TRUE;
-		Response (what_about_other, SpathiInfo);
-	}
-	if (PHRASE_ENABLED (what_about_precursors))
-	{
-		InfoLeft = TRUE;
-		Response (what_about_precursors, SpathiInfo);
-	}
-	Response (enough_info, SpathiAllies);
-
-	if (!InfoLeft)
-	{
-		DISABLE_PHRASE (like_some_info);
-	}
-}
-
-static void
-SpathiAllies (RESPONSE_REF R)
-{
-	BYTE NumVisits;
-
-	if (R == 0)
-	{
-		NumVisits = GET_GAME_STATE (SPATHI_HOME_VISITS);
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (HELLO_ALLIES_1);
-				break;
-			case 1:
-				NPCPhrase (HELLO_ALLIES_2);
-				break;
-			case 2:
-				NPCPhrase (HELLO_ALLIES_3);
-				--NumVisits;
-				break;
-		}
-		SET_GAME_STATE (SPATHI_HOME_VISITS, NumVisits);
-	}
-	else if (PLAYER_SAID (R, whats_up))
-	{
-		NumVisits = GET_GAME_STATE (SPATHI_INFO);
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (GENERAL_INFO_1);
-				break;
-			case 1:
-				NPCPhrase (GENERAL_INFO_2);
-				break;
-			case 2:
-				NPCPhrase (GENERAL_INFO_3);
-				SET_GAME_STATE (KNOW_URQUAN_STORY, 1);
-				SET_GAME_STATE (KNOW_KOHR_AH_STORY, 1);
-				break;
-			case 3:
-				NPCPhrase (GENERAL_INFO_4);
-				break;
-			case 4:
-				NPCPhrase (GENERAL_INFO_5);
-				--NumVisits;
-				break;
-			case 5:
-				NPCPhrase (GENERAL_INFO_5);
-				--NumVisits;
-				break;
-		}
-		SET_GAME_STATE (SPATHI_INFO, NumVisits);
-
-		DISABLE_PHRASE (whats_up);
-	}
-	else if (PLAYER_SAID (R, resources_please))
-	{
-		NPCPhrase (SORRY_NO_RESOURCES);
-
-		DISABLE_PHRASE (resources_please);
-	}
-	else if (PLAYER_SAID (R, something_fishy))
-	{
-		NPCPhrase (NOTHING_FISHY);
-
-		SET_GAME_STATE (SPATHI_INFO, 5);
-	}
-	else if (PLAYER_SAID (R, enough_info))
-		NPCPhrase (OK_ENOUGH_INFO);
-
-	if (GET_GAME_STATE (SPATHI_INFO) == 4)
-		Response (something_fishy, SpathiAllies);
-	if (PHRASE_ENABLED (whats_up))
-		Response (whats_up, SpathiAllies);
-	if (PHRASE_ENABLED (resources_please))
-		Response (resources_please, SpathiAllies);
-	if (PHRASE_ENABLED (like_some_info))
-		Response (like_some_info, SpathiInfo);
-	Response (bye_ally, ExitConversation);
-}
-
-static void
-SpathiQuest (RESPONSE_REF R)
-{
-	if (R == 0)
-	{
-		if (!GET_GAME_STATE (LIED_ABOUT_CREATURES))
-			NPCPhrase (HOW_GO_EFFORTS);
-		else
-			NPCPhrase (YOU_LIED_1);
-	}
-	else if (PLAYER_SAID (R, little_mistake))
-	{
-		NPCPhrase (BIG_MISTAKE);
-
-		DISABLE_PHRASE (little_mistake);
-	}
-	else if (PLAYER_SAID (R, talk_test))
-	{
-		NPCPhrase (TEST_AGAIN);
-
-		DISABLE_PHRASE (talk_test);
-	}
-	else if (PLAYER_SAID (R, zapped_a_few))
-	{
-		NPCPhrase (YOU_FORTUNATE);
-
-		DISABLE_PHRASE (zapped_a_few);
-	}
-
-	if (!GET_GAME_STATE (LIED_ABOUT_CREATURES))
-		Response (killed_them_all_1, ExitConversation);
-	else
-	{
-		if (PHRASE_ENABLED (little_mistake))
-		{
-			Response (little_mistake, SpathiQuest);
-		}
-		Response (killed_them_all_2, ExitConversation);
-	}
-	if (!GET_GAME_STATE (SPATHI_CREATURES_ELIMINATED))
-	{
-		if (PHRASE_ENABLED (talk_test))
-		{
-			Response (talk_test, SpathiQuest);
-		}
-		if (PHRASE_ENABLED (zapped_a_few)
-				&& GET_GAME_STATE (SPATHI_CREATURES_EXAMINED))
-		{
-			Response (zapped_a_few, SpathiQuest);
-		}
-		Response (bye_before_party, ExitConversation);
-	}
-}
-
-static void
-LearnQuest (RESPONSE_REF R)
-{
-	if (R == 0)
-	{
-		NPCPhrase (QUEST_AGAIN);
-
-		DISABLE_PHRASE (what_test);
-		if (GET_GAME_STATE (KNOW_SPATHI_EVIL))
-		{
-			DISABLE_PHRASE (tell_evil);
-		}
-	}
-	else if (PLAYER_SAID (R, how_prove))
-		NPCPhrase (BETTER_IDEA);
-	else if (PLAYER_SAID (R, what_test))
-	{
-		NPCPhrase (WIPE_EVIL);
-
-		SET_GAME_STATE (KNOW_SPATHI_QUEST, 1);
-		DISABLE_PHRASE (what_test);
-	}
-	else if (PLAYER_SAID (R, tell_evil))
-	{
-		NPCPhrase (BEFORE_ACCEPT);
-
-		SET_GAME_STATE (KNOW_SPATHI_EVIL, 1);
-		DISABLE_PHRASE (tell_evil);
-		DISABLE_PHRASE (prove_strength);
-	}
-	else if (PLAYER_SAID (R, prove_strength))
-	{
-		NPCPhrase (YOUR_BEHAVIOR);
-
-		DISABLE_PHRASE (prove_strength);
-	}
-	else if (PLAYER_SAID (R, why_dont_you_do_it))
-	{
-		NPCPhrase (WE_WONT_BECAUSE);
-
-		DISABLE_PHRASE (why_dont_you_do_it);
-	}
-
-	if (PHRASE_ENABLED (what_test))
-		Response (what_test, LearnQuest);
-	else if (GET_GAME_STATE (SPATHI_CREATURES_ELIMINATED))
-	{
-		Response (already_got_them, ExitConversation);
-	}
-	else if (PHRASE_ENABLED (tell_evil))
-	{
-		Response (too_dangerous, ExitConversation);
-		Response (tell_evil, LearnQuest);
+		NPCPhrase (GOD_KNOWS);
+		SET_GAME_STATE (BATTLE_SEGUE, 0);
 	}
-	else
+	else if (PLAYER_SAID (R, left_at_home))
 	{
-		Response (too_dangerous, ExitConversation);
-		Response (think_more, ExitConversation);
-		Response (i_accept, ExitConversation);
+		NPCPhrase (GO_GET_CYPHER);
+		SET_GAME_STATE (BATTLE_SEGUE, 0);
 	}
-	if (PHRASE_ENABLED (prove_strength) && !GET_GAME_STATE (KNOW_SPATHI_QUEST))
-		Response (prove_strength, LearnQuest);
-	if (PHRASE_ENABLED (why_dont_you_do_it))
-		Response (why_dont_you_do_it, LearnQuest);
+    else
+    {
+		NPCPhrase (BYE);
+		SET_GAME_STATE (BATTLE_SEGUE, 0);
+    }
 }
 
-static void
-AllianceOffer (RESPONSE_REF R)
-{
-	if (PLAYER_SAID (R, misunderstanding))
-	{
-		NPCPhrase (JUST_MISUNDERSTANDING);
-		XFormColorMap (GetColorMapAddress (
-				SetAbsColorMapIndex (CommData.AlienColorMap, 1)
-				), ONE_SECOND / 4);
-
-		SET_GAME_STATE (SPATHI_MANNER, 3);
-		SET_GAME_STATE (SPATHI_VISITS, 0);
-	}
-	else if (PLAYER_SAID (R, we_come_in_peace))
-		NPCPhrase (OF_COURSE);
-	else if (PLAYER_SAID (R, hand_in_friendship))
-	{
-		NPCPhrase (TOO_AFRAID);
-
-		DISABLE_PHRASE (hand_in_friendship);
-	}
-	else if (PLAYER_SAID (R, stronger))
-	{
-		NPCPhrase (YOURE_NOT);
-
-		DISABLE_PHRASE (stronger);
-	}
-	else if (PLAYER_SAID (R, yes_we_are))
-	{
-		NPCPhrase (NO_YOURE_NOT);
-
-		DISABLE_PHRASE (yes_we_are);
-	}
-	else if (PLAYER_SAID (R, share_info))
-	{
-		NPCPhrase (NO_INFO);
-
-		DISABLE_PHRASE (share_info);
-	}
-	else if (PLAYER_SAID (R, give_us_resources))
-	{
-		NPCPhrase (NO_RESOURCES);
-
-		DISABLE_PHRASE (give_us_resources);
-	}
-
-	if (PHRASE_ENABLED (hand_in_friendship))
-		Response (hand_in_friendship, AllianceOffer);
-	else if (PHRASE_ENABLED (stronger))
-		Response (stronger, AllianceOffer);
-	else if (PHRASE_ENABLED (yes_we_are))
-		Response (yes_we_are, AllianceOffer);
-	else
-	{
-		Response (how_prove, LearnQuest);
-	}
-	if (PHRASE_ENABLED (share_info))
-		Response (share_info, AllianceOffer);
-	if (PHRASE_ENABLED (give_us_resources))
-		Response (give_us_resources, AllianceOffer);
-}
 
 static void
-SpathiAngry (RESPONSE_REF R)
+CivilisedConversation (RESPONSE_REF R)
 {
-	if (R == 0)
-	{
-		NPCPhrase (MEAN_GUYS_RETURN);
-
-		Response (we_apologize, SpathiAngry);
-	}
-	else /* if (R == we_apologize) */
-	{
-		NPCPhrase (DONT_BELIEVE);
-
-		Response (misunderstanding, AllianceOffer);
-	}
-
-	Response (we_attack_again, ExitConversation);
-	Response (bye_angry_spathi, ExitConversation);
+    NPCPhrase (ANYTHING_ELSE);
+    Response (be_back_later, ExitConversation);
 }
 
-static void
-SpathiParty (RESPONSE_REF R)
-{
-	if (R == 0)
-	{
-		BYTE NumVisits;
-
-		NumVisits = GET_GAME_STATE (SPATHI_HOME_VISITS);
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (MUST_PARTY_1);
-				break;
-			case 1:
-				NPCPhrase (MUST_PARTY_2);
-				break;
-			case 2:
-				NPCPhrase (MUST_PARTY_3);
-				--NumVisits;
-				break;
-		}
-		SET_GAME_STATE (SPATHI_HOME_VISITS, NumVisits);
-	}
-	else if (PLAYER_SAID (R, deals_a_deal))
-	{
-		NPCPhrase (WAIT_A_WHILE);
-
-		DISABLE_PHRASE (deals_a_deal);
-	}
-	else if (PLAYER_SAID (R, how_long))
-	{
-		NPCPhrase (TEN_YEARS);
-
-		DISABLE_PHRASE (how_long);
-	}
-	else if (PLAYER_SAID (R, reneging))
-	{
-		NPCPhrase (ADULT_VIEW);
-
-		DISABLE_PHRASE (reneging);
-	}
-	else if (PLAYER_SAID (R, return_beasts))
-	{
-		NPCPhrase (WHAT_RELATIONSHIP);
-
-		DISABLE_PHRASE (return_beasts);
-	}
-	else if (PLAYER_SAID (R, minds_and_might))
-	{
-		NPCPhrase (HUH);
-
-		DISABLE_PHRASE (minds_and_might);
-	}
-	else if (PLAYER_SAID (R, fellowship))
-	{
-		NPCPhrase (WHAT);
-
-		DISABLE_PHRASE (fellowship);
-	}
-
-	if (PHRASE_ENABLED (deals_a_deal))
-		Response (deals_a_deal, SpathiParty);
-	else if (PHRASE_ENABLED (how_long))
-		Response (how_long, SpathiParty);
-	else if (PHRASE_ENABLED (reneging))
-		Response (reneging, SpathiParty);
-	else if (PHRASE_ENABLED (return_beasts))
-		Response (return_beasts, SpathiParty);
-	else
-	{
-		if (PHRASE_ENABLED (minds_and_might))
-			Response (minds_and_might, SpathiParty);
-		if (PHRASE_ENABLED (fellowship))
-			Response (fellowship, SpathiParty);
-		Response (do_as_we_say, ExitConversation);
-
-		return;
-	}
-	switch (GET_GAME_STATE (SPATHI_HOME_VISITS) - 1)
-	{
-		case 0:
-			Response (bye_from_party_1, ExitConversation);
-			break;
-		case 1:
-			Response (bye_from_party_2, ExitConversation);
-			break;
-		default:
-			Response (bye_from_party_3, ExitConversation);
-			break;
-	}
-}
 
 static void
-SpathiCouncil (RESPONSE_REF R)
+TurnLightsOn (RESPONSE_REF R)
 {
-	if (R == 0)
-		NPCPhrase (HELLO_AGAIN);
-	else if (PLAYER_SAID (R, good_password))
-	{
-		NPCPhrase (YES_GOOD_PASSWORD);
-		XFormColorMap (GetColorMapAddress (
-				SetAbsColorMapIndex (CommData.AlienColorMap, 1)
-				), ONE_SECOND / 4);
-
-		SET_GAME_STATE (KNOW_SPATHI_PASSWORD, 1);
-		SET_GAME_STATE (SPATHI_HOME_VISITS, 0);
-	}
-	else if (PLAYER_SAID (R, we_come_in_peace))
-	{
-		NPCPhrase (KILLED_SPATHI);
-
-		DISABLE_PHRASE (we_come_in_peace);
-	}
-	else if (PLAYER_SAID (R, spathi_on_pluto))
-	{
-		NPCPhrase (WHERE_SPATHI);
-
-		DISABLE_PHRASE (spathi_on_pluto);
-	}
-	else if (PLAYER_SAID (R, hostage))
-	{
-		NPCPhrase (GUN_TO_HEAD);
-
-		SET_GAME_STATE (FOUND_PLUTO_SPATHI, 3);
-		DISABLE_PHRASE (hostage);
-	}
-	else if (PLAYER_SAID (R, killed_fwiffo))
-	{
-		NPCPhrase (POOR_FWIFFO);
-
-		SET_GAME_STATE (FOUND_PLUTO_SPATHI, 3);
-		DISABLE_PHRASE (killed_fwiffo);
-	}
-	else if (PLAYER_SAID (R, fwiffo_fine))
-	{
-		NPCPhrase (NOT_LIKELY);
-
-		R = killed_fwiffo;
-		DISABLE_PHRASE (fwiffo_fine);
-	}
-	else if (PLAYER_SAID (R, surrender))
-	{
-		NPCPhrase (NO_SURRENDER);
-
-		DISABLE_PHRASE (surrender);
-	}
-
-	if (GET_GAME_STATE (SPATHI_MANNER) == 0)
-	{
-		Response (we_come_in_peace, AllianceOffer);
-	}
-	else if (PHRASE_ENABLED (we_come_in_peace))
-	{
-		Response (we_come_in_peace, SpathiCouncil);
-	}
-	else
-	{
-		Response (misunderstanding, AllianceOffer);
-	}
-	if (GET_GAME_STATE (FOUND_PLUTO_SPATHI)
-			&& GET_GAME_STATE (FOUND_PLUTO_SPATHI) < 3)
-	{
-		if (PHRASE_ENABLED (spathi_on_pluto))
-			Response (spathi_on_pluto, SpathiCouncil);
-		else if (ActivateStarShip (SPATHI_SHIP, ESCORTING_FLAGSHIP))
-		{
-			if (PHRASE_ENABLED (hostage))
-				Response (hostage, SpathiCouncil);
-		}
-		else if (PHRASE_ENABLED (killed_fwiffo))
-		{
-			Response (killed_fwiffo, SpathiCouncil);
-			if (PHRASE_ENABLED (fwiffo_fine))
-				Response (fwiffo_fine, SpathiCouncil);
-		}
-	}
-	if (PHRASE_ENABLED (surrender))
-		Response (surrender, SpathiCouncil);
-	else
-	{
-		Response (surrender_or_die, ExitConversation);
-	}
-	Response (bye_no_ally_offer, ExitConversation);
+    XFormColorMap (GetColorMapAddress (
+		SetAbsColorMapIndex (CommData.AlienColorMap, 1)), ONE_SECOND / 2);
+    NPCPhrase (LIGHTS_NOW_ON);
+    
+    SET_GAME_STATE (SPATHIHOME_MET, 1);
+    
+    Response (telling_off, CivilisedConversation);
+    Response (be_back_later, ExitConversation);
 }
 
-static void
-SpathiPassword (RESPONSE_REF R)
-{
-	if (R == 0)
-	{
-		BYTE NumVisits;
-
-		NumVisits = GET_GAME_STATE (SPATHI_HOME_VISITS);
-		switch (NumVisits++)
-		{
-			default:
-				NPCPhrase (WHAT_IS_PASSWORD);
-				NumVisits = 1;
-				break;
-			case 1:
-				NPCPhrase (WHAT_IS_PASSWORD_AGAIN);
-				--NumVisits;
-				break;
-		}
-		SET_GAME_STATE (SPATHI_HOME_VISITS, NumVisits);
-	}
-	else if (PLAYER_SAID (R, what_do_i_get))
-	{
-		NPCPhrase (YOU_GET_TO_LIVE);
-
-		DISABLE_PHRASE (what_do_i_get);
-	}
 
-	if (GET_GAME_STATE (FOUND_PLUTO_SPATHI)
-			|| GET_GAME_STATE (KNOW_SPATHI_PASSWORD))
-	{
-		Response (good_password, SpathiCouncil);
-		if (PHRASE_ENABLED (what_do_i_get))
-		{
-			Response (what_do_i_get, SpathiPassword);
-		}
-	}
-	else
-	{
-		construct_response (shared_phrase_buf,
-				we_are_vindicator0,
-				GLOBAL_SIS (CommanderName),
-				we_are_vindicator1,
-				GLOBAL_SIS (ShipName),
-				we_are_vindicator2,
-				(UNICODE*)NULL);
-		DoResponsePhrase (we_are_vindicator0, ExitConversation, shared_phrase_buf);
-		Response (gort_merenga, ExitConversation);
-		Response (guph_florp, ExitConversation);
-		Response (wagngl_fthagn, ExitConversation);
-		Response (pleeese, ExitConversation);
-		Response (screw_password, ExitConversation);
-	}
-}
 
 static void
 Intro (void)
 {
-	BYTE Manner;
-
-	Manner = GET_GAME_STATE (SPATHI_MANNER);
-	if (Manner == 2)
-	{
-		NPCPhrase (HATE_YOU_FOREVER);
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
-	}
-	else if (Manner == 1
-			&& GET_GAME_STATE (KNOW_SPATHI_PASSWORD)
-			&& (GET_GAME_STATE (FOUND_PLUTO_SPATHI)
-			|| GET_GAME_STATE (SPATHI_HOME_VISITS) != 7))
-	{
-		SpathiAngry ((RESPONSE_REF)0);
-	}
-	else if (ActivateStarShip (SPATHI_SHIP, CHECK_ALLIANCE) == GOOD_GUY)
-	{
-		CommData.AlienColorMap =
-				SetAbsColorMapIndex (CommData.AlienColorMap, 1);
-		SpathiAllies ((RESPONSE_REF)0);
-	}
-	else if (GET_GAME_STATE (SPATHI_PARTY))
-	{
-		CommData.AlienColorMap =
-				SetAbsColorMapIndex (CommData.AlienColorMap, 1);
-		SpathiParty ((RESPONSE_REF)0);
-	}
-	else if (GET_GAME_STATE (SPATHI_QUEST))
+	if (GET_GAME_STATE (SPATHIHOME_MET) == 0)
 	{
-		if (GET_GAME_STATE (LIED_ABOUT_CREATURES) < 2)
-		{
-			CommData.AlienColorMap =
-					SetAbsColorMapIndex (CommData.AlienColorMap, 1);
-			SpathiQuest ((RESPONSE_REF)0);
-		}
-		else
-		{
-			NPCPhrase (YOU_LIED_2);
-
-			SET_GAME_STATE (SPATHI_MANNER, 2);
-			SET_GAME_STATE (BATTLE_SEGUE, 1);
-		}
-	}
-	else if (GET_GAME_STATE (KNOW_SPATHI_QUEST))
-	{
-		CommData.AlienColorMap =
-				SetAbsColorMapIndex (CommData.AlienColorMap, 1);
-		LearnQuest ((RESPONSE_REF)0);
-	}
-	else if (GET_GAME_STATE (KNOW_SPATHI_PASSWORD)
-			&& (GET_GAME_STATE (FOUND_PLUTO_SPATHI)
-			|| GET_GAME_STATE (SPATHI_HOME_VISITS) != 7))
-	{
-		CommData.AlienColorMap =
-				SetAbsColorMapIndex (CommData.AlienColorMap, 1);
-		SpathiCouncil ((RESPONSE_REF)0);
-	}
-	else
-	{
-		SpathiPassword ((RESPONSE_REF)0);
-	}
+		NPCPhrase (WHAT_IS_CYPHER);
+        
+        Response (huffi_muffi_guffi, ExitConversation);
+        Response (gods_work, ExitConversation);
+        Response (left_at_home, ExitConversation);
+        Response (turn_lights_on, TurnLightsOn);
+	}
+    else
+    {
+        CommData.AlienColorMap = SetAbsColorMapIndex (CommData.AlienColorMap, 1);
+        CivilisedConversation(0);
+    }
 }
 
 static COUNT
@@ -1003,14 +297,7 @@ init_spahome_comm ()
 	spahome_desc.AlienAltSongRes = SPAHOME_MUSIC;
 	spahome_desc.AlienSongFlags |= LDASF_USE_ALTERNATE;
 
-	if (GET_GAME_STATE (SPATHI_MANNER) == 3)
-	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
-	}
-	else
-	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
-	}
+	SET_GAME_STATE (BATTLE_SEGUE, 0);
 
 	retval = &spahome_desc;
 
diff -ruNp src.orig/uqm/comm/spahome/strings.h src/uqm/comm/spahome/strings.h
--- src.orig/uqm/comm/spahome/strings.h	2017-11-01 15:30:24 -0700
+++ src/uqm/comm/spahome/strings.h	2017-11-01 15:31:01 -0700
@@ -22,153 +22,19 @@
 enum
 {
 	NULL_PHRASE,
-	killed_fwiffo,
-	POOR_FWIFFO,
-	fwiffo_fine,
-	NOT_LIKELY,
-	we_attack_again,
-	WE_FIGHT_AGAIN,
-	bye_no_ally_offer,
-	GOODBYE_NO_ALLY_OFFER,
-	bye_angry_spathi,
-	GOODBYE_ANGRY_SPATHI,
-	why_dont_you_do_it,
-	WE_WONT_BECAUSE,
-	MEAN_GUYS_RETURN,
-	we_apologize,
-	DONT_BELIEVE,
-	HELLO_AGAIN,
-	HATE_YOU_FOREVER,
-	WHAT_IS_PASSWORD,
-	WHAT_IS_PASSWORD_AGAIN,
-	we_are_vindicator0,
-	we_are_vindicator1,
-	we_are_vindicator2,
-	gort_merenga,
-	guph_florp,
-	pleeese,
-	wagngl_fthagn,
-	screw_password,
-	good_password,
-	WRONG_PASSWORD,
-	NO_PASSWORD,
-	what_do_i_get,
-	YOU_GET_TO_LIVE,
-	YES_GOOD_PASSWORD,
-	spathi_on_pluto,
-	WHERE_SPATHI,
-	hostage,
-	GUN_TO_HEAD,
-	we_come_in_peace,
-	OF_COURSE,
-	KILLED_SPATHI,
-	misunderstanding,
-	JUST_MISUNDERSTANDING,
-//	JUST_MISUNDERSTANDING0,
-//	JUST_MISUNDERSTANDING1,
-	give_us_resources,
-	NO_RESOURCES,
-	resources_please,
-	SORRY_NO_RESOURCES,
-	bye_ally,
-	GOODBYE_ALLY,
-	what_about_hierarchy,
-	what_about_history,
-	what_about_alliance,
-	what_about_other,
-	what_about_precursors,
-	enough_info,
-	OK_ENOUGH_INFO,
-	ABOUT_HIERARCHY,
-	ABOUT_HISTORY,
-	ABOUT_ALLIANCE,
-	ABOUT_OTHER,
-	ABOUT_PRECURSORS,
-	little_mistake,
-	BIG_MISTAKE,
-	bye_before_party,
-	QUEST_AGAIN,
-	GOODBYE_BEFORE_PARTY,
-	GOOD_START,
-	something_fishy,
-	NOTHING_FISHY,
-	surrender,
-	NO_SURRENDER,
-	surrender_or_die,
-	DEFEND_OURSELVES,
-	hand_in_friendship,
-	TOO_AFRAID,
-	stronger,
-	YOURE_NOT,
-	yes_we_are,
-	NO_YOURE_NOT,
-	how_prove,
-	BETTER_IDEA,
-	share_info,
-	NO_INFO,
-	WE_UNDERSTAND,
-	prove_strength,
-	YOUR_BEHAVIOR,
-	what_test,
-	BEFORE_ACCEPT,
-	WIPE_EVIL,
-	think_more,
-	COWARD,
-	tell_evil,
-	i_accept,
-	AWAIT_RETURN,
-	talk_test,
-	already_got_them,
-	EARLY_BIRD_CHECK,
-	NOT_SURPRISED,
-	TEST_AGAIN,
-	too_dangerous,
-	WE_AGREE,
-	HOW_GO_EFFORTS,
-	killed_them_all_1,
-	killed_them_all_2,
-	WILL_CHECK_1,
-	WILL_CHECK_2,
-	zapped_a_few,
-	RETURN_COMPLETE,
-	MUST_DESTROY_ALL,
-	no_landing,
-	saw_creatures,
-	YOU_FORTUNATE,
-	YOU_LIED_1,
-	YOU_LIED_2,
-	bye_from_party_1,
-	bye_from_party_2,
-	bye_from_party_3,
-	GOODBYE_FROM_PARTY,
-	MUST_PARTY_1,
-	MUST_PARTY_2,
-	MUST_PARTY_3,
-	deals_a_deal,
-	WAIT_A_WHILE,
-	how_long,
-	TEN_YEARS,
-	reneging,
-	ADULT_VIEW,
-	return_beasts,
-	WHAT_RELATIONSHIP,
-	minds_and_might,
-	HUH,
-	fellowship,
-	WHAT,
-	do_as_we_say,
-	DEPART_FOR_EARTH,
-	HELLO_ALLIES_1,
-	HELLO_ALLIES_2,
-	HELLO_ALLIES_3,
-	whats_up,
-	GENERAL_INFO_1,
-	GENERAL_INFO_2,
-	GENERAL_INFO_3,
-	GENERAL_INFO_4,
-	GENERAL_INFO_5,
-	like_some_info,
-	WHAT_ABOUT
+	WHAT_IS_CYPHER,
+	huffi_muffi_guffi,
+	gods_work,
+	left_at_home,
+	CYPHER_OBSOLETE,
+	GOD_KNOWS,
+	GO_GET_CYPHER,
+    turn_lights_on,
+    LIGHTS_NOW_ON,
+    be_back_later,
+    telling_off,
+    ANYTHING_ELSE,
+    BYE
 };
 
 #endif /* _STRINGS_H */
diff -ruNp src.orig/uqm/comm/spathi/spathic.c src/uqm/comm/spathi/spathic.c
--- src.orig/uqm/comm/spathi/spathic.c	2017-11-01 15:30:24 -0700
+++ src/uqm/comm/spathi/spathic.c	2017-11-01 15:31:01 -0700
@@ -25,6 +25,7 @@
 
 static LOCDATA spathi_desc =
 {
+	SPATHI_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -142,6 +143,11 @@ static LOCDATA spathi_desc =
 	NULL, NULL, NULL,
 	NULL,
 	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
 };
 
 static void
diff -ruNp src.orig/uqm/comm/starbas/starbas.c src/uqm/comm/starbas/starbas.c
--- src.orig/uqm/comm/starbas/starbas.c	2017-11-01 15:30:24 -0700
+++ src/uqm/comm/starbas/starbas.c	2017-11-01 15:31:01 -0700
@@ -16,6 +16,9 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: -Removed the arc welder anims that created black spots on top of earth graphics.
+//			 -Added rudimentary dialogue regarding other races and lost shofixti mission
+
 #include "../commall.h"
 #include "../comandr/resinst.h"
 #include "strings.h"
@@ -31,12 +34,13 @@
 #include "libs/sound/sound.h"
 
 
-static void TellMission (RESPONSE_REF R);
+//static void TellMission (RESPONSE_REF R);
 static void SellMinerals (RESPONSE_REF R);
 
 
 static LOCDATA commander_desc =
 {
+	COMMANDER_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -53,7 +57,7 @@ static LOCDATA commander_desc =
 	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	STARBASE_CONVERSATION_PHRASES, /* PlayerPhrases */
-	10, /* NumAnimations */
+	3, /* NumAnimations */
 	{ /* AlienAmbientArray (ambient animations) */
 		{ /* Blink */
 			1, /* StartIndex */
@@ -71,68 +75,12 @@ static LOCDATA commander_desc =
 			ONE_SECOND * 2, 0, /* RestartRate */
 			0, /* BlockMask */
 		},
-		{ /* Arc welder 0 */
+		{ /* Explorer lights */
 			40, /* StartIndex */
-			7, /* NumFrames */
-			CIRCULAR_ANIM, /* AnimFlags */
-			ONE_SECOND / 40, 0, /* FrameRate */
-			0, ONE_SECOND * 8, /* RestartRate */
-			0, /* BlockMask */
-		},
-		{ /* Arc welder 1 */
-			47, /* StartIndex */
-			8, /* NumFrames */
-			CIRCULAR_ANIM, /* AnimFlags */
-			ONE_SECOND / 40, 0, /* FrameRate */
-			0, ONE_SECOND * 8, /* RestartRate */
-			0, /* BlockMask */
-		},
-		{ /* Arc welder 2 */
-			55, /* StartIndex */
 			6, /* NumFrames */
 			CIRCULAR_ANIM, /* AnimFlags */
-			ONE_SECOND / 40, 0, /* FrameRate */
-			0, ONE_SECOND * 8, /* RestartRate */
-			0, /* BlockMask */
-		},
-		{ /* Arc welder 3 */
-			61, /* StartIndex */
-			6, /* NumFrames */
-			CIRCULAR_ANIM, /* AnimFlags */
-			ONE_SECOND / 40, 0, /* FrameRate */
-			0, ONE_SECOND * 8, /* RestartRate */
-			0, /* BlockMask */
-		},
-		{ /* Arc welder 4 */
-			67, /* StartIndex */
-			7, /* NumFrames */
-			CIRCULAR_ANIM, /* AnimFlags */
-			ONE_SECOND / 40, 0, /* FrameRate */
-			0, ONE_SECOND * 8, /* RestartRate */
-			0, /* BlockMask */
-		},
-		{ /* Arc welder 5 */
-			74, /* StartIndex */
-			11, /* NumFrames */
-			CIRCULAR_ANIM, /* AnimFlags */
-			ONE_SECOND / 40, 0, /* FrameRate */
-			0, ONE_SECOND * 8, /* RestartRate */
-			0, /* BlockMask */
-		},
-		{ /* Arc welder 6 */
-			85, /* StartIndex */
-			10, /* NumFrames */
-			CIRCULAR_ANIM, /* AnimFlags */
-			ONE_SECOND / 40, 0, /* FrameRate */
-			0, ONE_SECOND * 8, /* RestartRate */
-			0, /* BlockMask */
-		},
-		{ /* Flagship picture */
-			95, /* StartIndex */
-			1, /* NumFrames */
-			0, /* AnimFlags */
-			0, 0, /* FrameRate */
-			0, 0, /* RestartRate */
+			ONE_SECOND, 0, /* FrameRate */
+			ONE_SECOND * 5, ONE_SECOND * 5, /* RestartRate */
 			0, /* BlockMask */
 		},
 	},
@@ -157,6 +105,11 @@ static LOCDATA commander_desc =
 	NULL, NULL, NULL,
 	NULL,
 	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
 };
 
 static DWORD CurBulletinMask;
@@ -214,821 +167,278 @@ ByeBye (RESPONSE_REF R)
 		}
 
 		NPCPhrase (pStr0);
-		if (speechVolumeScale == 0.0f)
-		{
-			NPCPhrase (SPACE);
-			NPCPhrase (GLOBAL_PLAYER_NAME);
-		}
-		NPCPhrase (pStr1);
 	}
 }
 
-static void NeedInfo (RESPONSE_REF R);
-static void TellHistory (RESPONSE_REF R);
 static void AlienRaces (RESPONSE_REF R);
 
-static BYTE stack0;
-static BYTE stack1;
-static BYTE stack2;
-static BYTE stack3;
-
 static void
 AllianceInfo (RESPONSE_REF R)
 {
-#define ALLIANCE_SHOFIXTI (1 << 0)
-#define ALLIANCE_YEHAT (1 << 1)
-#define ALLIANCE_ARILOU (1 << 2)
-#define ALLIANCE_CHENJESU (1 << 3)
-#define ALLIANCE_MMRNMHRM (1 << 4)
-#define ALLIANCE_SYREEN (1 << 5)
+#define ALLIANCE_CHMMR (1 << 0)
+#define ALLIANCE_SHOFIXTI (1 << 1)
+#define ALLIANCE_YEHATPKUNK (1 << 2)
+#define ALLIANCE_ARILOU (1 << 3)
+#define ALLIANCE_SYREEN (1 << 4)
+#define ALLIANCE_SPATHI (1 << 5)
+#define ALLIANCE_ORZ	(1 << 6)
+
+#define ALLIANCE_SUPOXUTWIG (1 << 0)
+#define ALLIANCE_ZOQFOT (1 << 1)
+	
 	static BYTE AllianceMask = 0;
+	static BYTE AllianceMask2 = 0;
 
-	if (PLAYER_SAID (R, what_about_alliance))
+	if (PLAYER_SAID (R, alliance_races))
 	{
-		NPCPhrase (WHICH_ALLIANCE);
+		NPCPhrase (WHICH_ALLY);
 		AllianceMask = 0;
+		AllianceMask2 = 0;
+	}
+	else if (PLAYER_SAID (R, chmmr))
+	{
+		NPCPhrase (CHMMR_INFO_SB);
+		AllianceMask |= ALLIANCE_CHMMR;
 	}
 	else if (PLAYER_SAID (R, shofixti))
 	{
-		NPCPhrase (ABOUT_SHOFIXTI);
+		NPCPhrase (SHOFIXTI_INFO_SB);
 		AllianceMask |= ALLIANCE_SHOFIXTI;
+		ActivateStarShip (SHOFIXTI_SHIP, SPHERE_TRACKING);
 	}
-	else if (PLAYER_SAID (R, yehat))
+	else if (PLAYER_SAID (R, yehat_and_pkunk))
 	{
-		NPCPhrase (ABOUT_YEHAT);
-		AllianceMask |= ALLIANCE_YEHAT;
+		NPCPhrase (YEHAT_AND_PKUNK_INFO_SB);
+		AllianceMask |= ALLIANCE_YEHATPKUNK;
+		ActivateStarShip (YEHAT_SHIP, SPHERE_TRACKING);
 	}
 	else if (PLAYER_SAID (R, arilou))
 	{
-		NPCPhrase (ABOUT_ARILOU);
+		NPCPhrase (ARILOU_INFO_SB);
 		AllianceMask |= ALLIANCE_ARILOU;
 	}
-	else if (PLAYER_SAID (R, chenjesu))
-	{
-		NPCPhrase (ABOUT_CHENJESU);
-		AllianceMask |= ALLIANCE_CHENJESU;
-	}
-	else if (PLAYER_SAID (R, mmrnmhrm))
-	{
-		NPCPhrase (ABOUT_MMRNMHRM);
-		AllianceMask |= ALLIANCE_MMRNMHRM;
-	}
 	else if (PLAYER_SAID (R, syreen))
 	{
-		NPCPhrase (ABOUT_SYREEN);
+		NPCPhrase (SYREEN_INFO_SB);
 		AllianceMask |= ALLIANCE_SYREEN;
-	}
-
-	if (!(AllianceMask & ALLIANCE_SHOFIXTI))
-		Response (shofixti, AllianceInfo);
-	if (!(AllianceMask & ALLIANCE_YEHAT))
-		Response (yehat, AllianceInfo);
-	if (!(AllianceMask & ALLIANCE_ARILOU))
-		Response (arilou, AllianceInfo);
-	if (!(AllianceMask & ALLIANCE_CHENJESU))
-		Response (chenjesu, AllianceInfo);
-	if (!(AllianceMask & ALLIANCE_MMRNMHRM))
-		Response (mmrnmhrm, AllianceInfo);
-	if (!(AllianceMask & ALLIANCE_SYREEN))
-		Response (syreen, AllianceInfo);
-	Response (enough_alliance, AlienRaces);
-}
-
-static void
-HierarchyInfo (RESPONSE_REF R)
-{
-#define HIERARCHY_MYCON (1 << 0)
-#define HIERARCHY_SPATHI (1 << 1)
-#define HIERARCHY_UMGAH (1 << 2)
-#define HIERARCHY_ANDROSYNTH (1 << 3)
-#define HIERARCHY_ILWRATH (1 << 4)
-#define HIERARCHY_VUX (1 << 5)
-	static BYTE HierarchyMask = 0;
-
-	if (PLAYER_SAID (R, what_about_hierarchy))
-	{
-		NPCPhrase (WHICH_HIERARCHY);
-		HierarchyMask = 0;
-	}
-	else if (PLAYER_SAID (R, mycon))
-	{
-		NPCPhrase (ABOUT_MYCON);
-		HierarchyMask |= HIERARCHY_MYCON;
+		ActivateStarShip (SYREEN_SHIP, SPHERE_TRACKING);
 	}
 	else if (PLAYER_SAID (R, spathi))
 	{
-		NPCPhrase (ABOUT_SPATHI);
-		HierarchyMask |= HIERARCHY_SPATHI;
-	}
-	else if (PLAYER_SAID (R, umgah))
-	{
-		NPCPhrase (ABOUT_UMGAH);
-		HierarchyMask |= HIERARCHY_UMGAH;
+		NPCPhrase (SPATHI_INFO_SB);
+		AllianceMask |= ALLIANCE_SPATHI;
+		ActivateStarShip (SPATHI_SHIP, SPHERE_TRACKING);
 	}
-	else if (PLAYER_SAID (R, androsynth))
+	else if (PLAYER_SAID (R, orz))
 	{
-		NPCPhrase (ABOUT_ANDROSYNTH);
-		HierarchyMask |= HIERARCHY_ANDROSYNTH;
+		NPCPhrase (ORZ_INFO_SB);
+		AllianceMask |= ALLIANCE_ORZ;
+		ActivateStarShip (ORZ_SHIP, SPHERE_TRACKING);
 	}
-	else if (PLAYER_SAID (R, ilwrath))
+	else if (PLAYER_SAID (R, supox_and_utwig))
 	{
-		NPCPhrase (ABOUT_ILWRATH);
-		HierarchyMask |= HIERARCHY_ILWRATH;
+		NPCPhrase (SUPOX_UTWIG_INFO_SB);
+		AllianceMask2 |= ALLIANCE_SUPOXUTWIG;
 	}
-	else if (PLAYER_SAID (R, vux))
+	else if (PLAYER_SAID (R, zoqfot))
 	{
-		NPCPhrase (ABOUT_VUX);
-		HierarchyMask |= HIERARCHY_VUX;
+		NPCPhrase (ZOQFOT_INFO_SB);
+		AllianceMask2 |= ALLIANCE_ZOQFOT;
 	}
 
-	if (!(HierarchyMask & HIERARCHY_MYCON))
-		Response (mycon, HierarchyInfo);
-	if (!(HierarchyMask & HIERARCHY_SPATHI))
-		Response (spathi, HierarchyInfo);
-	if (!(HierarchyMask & HIERARCHY_UMGAH))
-		Response (umgah, HierarchyInfo);
-	if (!(HierarchyMask & HIERARCHY_ANDROSYNTH))
-		Response (androsynth, HierarchyInfo);
-	if (!(HierarchyMask & HIERARCHY_ILWRATH))
-		Response (ilwrath, HierarchyInfo);
-	if (!(HierarchyMask & HIERARCHY_VUX))
-		Response (vux, HierarchyInfo);
-	Response (enough_hierarchy, AlienRaces);
-}
-
-static void
-AlienRaces (RESPONSE_REF R)
-{
-#define RACES_ALLIANCE (1 << 0)
-#define RACES_HIERARCHY (1 << 1)
-#define RACES_OTHER (1 << 2)
-	static BYTE RacesMask = 0;
-
-	if (PLAYER_SAID (R, alien_races))
-	{
-		NPCPhrase (WHICH_ALIEN);
-		RacesMask = 0;
-	}
-	else if (PLAYER_SAID (R, enough_alliance))
-	{
-		NPCPhrase (OK_ENOUGH_ALLIANCE);
-		RacesMask |= RACES_ALLIANCE;
-	}
-	else if (PLAYER_SAID (R, enough_hierarchy))
-	{
-		NPCPhrase (OK_ENOUGH_HIERARCHY);
-		RacesMask |= RACES_HIERARCHY;
-	}
-	else if (PLAYER_SAID (R, what_about_other))
-	{
-		NPCPhrase (ABOUT_OTHER);
-		RacesMask |= RACES_OTHER;
-	}
-
-	if (!(RacesMask & RACES_ALLIANCE))
-	{
-		Response (what_about_alliance, AllianceInfo);
-	}
-	if (!(RacesMask & RACES_HIERARCHY))
-	{
-		Response (what_about_hierarchy, HierarchyInfo);
-	}
-	if (!(RacesMask & RACES_OTHER))
-	{
-		Response (what_about_other, AlienRaces);
-	}
-	Response (enough_aliens, TellHistory);
-}
-
-static void
-WarInfo (RESPONSE_REF R)
-{
-#define WAR_STARTED (1 << 0)
-#define WAR_WAS_LIKE (1 << 1)
-#define WAR_LOST (1 << 2)
-#define WAR_AFTERMATH (1 << 3)
-	static BYTE WarMask = 0;
-
-	if (PLAYER_SAID (R, the_war))
-	{
-		NPCPhrase (WHICH_WAR);
-		WarMask = 0;
-	}
-	else if (PLAYER_SAID (R, what_started_war))
-	{
-		NPCPhrase (URQUAN_STARTED_WAR);
-		WarMask |= WAR_STARTED;
-	}
-	else if (PLAYER_SAID (R, what_was_war_like))
-	{
-		NPCPhrase (WAR_WAS_LIKE_SO);
-		WarMask |= WAR_WAS_LIKE;
-	}
-	else if (PLAYER_SAID (R, why_lose_war))
-	{
-		NPCPhrase (LOST_WAR_BECAUSE);
-		WarMask |= WAR_LOST;
-	}
-	else if (PLAYER_SAID (R, what_after_war))
-	{
-		NPCPhrase (AFTER_WAR);
-		WarMask |= WAR_AFTERMATH;
-	}
-
-	if (!(WarMask & WAR_STARTED))
-		Response (what_started_war, WarInfo);
-	if (!(WarMask & WAR_WAS_LIKE))
-		Response (what_was_war_like, WarInfo);
-	if (!(WarMask & WAR_LOST))
-		Response (why_lose_war, WarInfo);
-	if (!(WarMask & WAR_AFTERMATH))
-		Response (what_after_war, WarInfo);
-	Response (enough_war, TellHistory);
-}
-
-static void
-AncientHistory (RESPONSE_REF R)
-{
-#define ANCIENT_PRECURSORS (1 << 0)
-#define ANCIENT_RACES (1 << 1)
-#define ANCIENT_EARTH (1 << 2)
-	static BYTE AncientMask = 0;
-
-	if (PLAYER_SAID (R, ancient_history))
-	{
-		NPCPhrase (WHICH_ANCIENT);
-		AncientMask = 0;
-	}
-	else if (PLAYER_SAID (R, precursors))
-	{
-		NPCPhrase (ABOUT_PRECURSORS);
-		AncientMask |= ANCIENT_PRECURSORS;
-	}
-	else if (PLAYER_SAID (R, old_races))
-	{
-		NPCPhrase (ABOUT_OLD_RACES);
-		AncientMask |= ANCIENT_RACES;
-	}
-	else if (PLAYER_SAID (R, aliens_on_earth))
-	{
-		NPCPhrase (ABOUT_ALIENS_ON_EARTH);
-		AncientMask |= ANCIENT_EARTH;
-	}
-
-	if (!(AncientMask & ANCIENT_PRECURSORS))
-		Response (precursors, AncientHistory);
-	if (!(AncientMask & ANCIENT_RACES))
-		Response (old_races, AncientHistory);
-	if (!(AncientMask & ANCIENT_EARTH))
-		Response (aliens_on_earth, AncientHistory);
-	Response (enough_ancient, TellHistory);
+	if (!(AllianceMask & ALLIANCE_CHMMR))
+		Response (chmmr, AllianceInfo);
+	if (!(AllianceMask & ALLIANCE_SHOFIXTI))
+		Response (shofixti, AllianceInfo);
+	if (!(AllianceMask & ALLIANCE_YEHATPKUNK))
+		Response (yehat_and_pkunk, AllianceInfo);
+	if (!(AllianceMask & ALLIANCE_ARILOU))
+		Response (arilou, AllianceInfo);
+	if (!(AllianceMask & ALLIANCE_SYREEN))
+		Response (syreen, AllianceInfo);
+	if (!(AllianceMask & ALLIANCE_SPATHI))
+		Response (spathi, AllianceInfo);
+	if (!(AllianceMask & ALLIANCE_ORZ))
+		Response (orz, AllianceInfo);
+	if (!(AllianceMask2 & ALLIANCE_SUPOXUTWIG))
+		Response (supox_and_utwig, AllianceInfo);
+	if (!(AllianceMask2 & ALLIANCE_ZOQFOT))
+		Response (zoqfot, AllianceInfo);
+	Response (enough_allies, AlienRaces);
 }
 
 static void
-TellHistory (RESPONSE_REF R)
+HostileInfo (RESPONSE_REF R)
 {
-	RESPONSE_REF pstack[3];
+#define HOSTILE_URQUAN (1 << 0)
+#define HOSTILE_KOHRAH (1 << 1)
+#define HOSTILE_VUX (1 << 2)
+#define HOSTILE_MYCON (1 << 3)
+#define HOSTILE_ANDROSYNTH (1 << 4)
+#define HOSTILE_ILWRATH (1 << 5)
+#define HOSTILE_THRADDASH (1 << 6)
+	
+	static BYTE HostileMask = 0;
 
-	if (PLAYER_SAID (R, history))
+	if (PLAYER_SAID (R, hostile_races))
 	{
-		NPCPhrase (WHICH_HISTORY);
-		stack0 = 0;
-		stack1 = 0;
-		stack2 = 0;
+		NPCPhrase (WHICH_ENEMY);
+		HostileMask = 0;
 	}
-	else if (PLAYER_SAID (R, enough_aliens))
+	else if (PLAYER_SAID (R, urquan))
 	{
-		NPCPhrase (OK_ENOUGH_ALIENS);
-
-		stack0 = 1;
-	}
-	else if (PLAYER_SAID (R, enough_war))
-	{
-		NPCPhrase (OK_ENOUGH_WAR);
-
-		stack1 = 1;
-	}
-	else if (PLAYER_SAID (R, enough_ancient))
-	{
-		NPCPhrase (OK_ENOUGH_ANCIENT);
-
-		stack2 = 1;
-	}
-
-	switch (stack0)
-	{
-		case 0:
-			pstack[0] = alien_races;
-			break;
-		default:
-			pstack[0] = 0;
-			break;
-	}
-	switch (stack1)
-	{
-		case 0:
-			pstack[1] = the_war;
-			break;
-		default:
-			pstack[1] = 0;
-			break;
-	}
-	switch (stack2)
-	{
-		case 0:
-			pstack[2] = ancient_history;
-			break;
-		default:
-			pstack[2] = 0;
-			break;
-	}
-
-	if (pstack[0])
-	{
-		Response (pstack[0], AlienRaces);
+		NPCPhrase (UR_QUAN_INFO_SB);
+		HostileMask |= HOSTILE_URQUAN;
 	}
-	if (pstack[1])
+	else if (PLAYER_SAID (R, kohrah))
 	{
-		Response (pstack[1], WarInfo);
+		NPCPhrase (KOHR_AH_INFO_SB);
+		HostileMask |= HOSTILE_KOHRAH;
 	}
-	if (pstack[2])
-	{
-		Response (pstack[2], AncientHistory);
-	}
-	Response (enough_history, NeedInfo);
-}
-
-static void
-DefeatUrquan (RESPONSE_REF R)
-{
-#define HOW_FIND_URQUAN (1 << 0)
-#define HOW_FIGHT_URQUAN (1 << 1)
-#define HOW_ALLY_AGAINST_URQUAN (1 << 2)
-#define HOW_STRONG_AGAINST_URQUAN (1 << 3)
-	static BYTE DefeatMask = 0;
-
-	if (PLAYER_SAID (R, how_defeat))
+	else if (PLAYER_SAID (R, vux))
 	{
-		NPCPhrase (DEFEAT_LIKE_SO);
-		DefeatMask = 0;
+		NPCPhrase (VUX_INFO_SB);
+		HostileMask |= HOSTILE_VUX;
+		ActivateStarShip (VUX_SHIP, SPHERE_TRACKING);
 	}
-	else if (PLAYER_SAID (R, how_find_urquan))
+	else if (PLAYER_SAID (R, mycon))
 	{
-		NPCPhrase (FIND_URQUAN);
-		DefeatMask |= HOW_FIND_URQUAN;
+		NPCPhrase (MYCON_INFO_SB);
+		HostileMask |= HOSTILE_MYCON;
 	}
-	else if (PLAYER_SAID (R, how_fight_urquan))
+	else if (PLAYER_SAID (R, androsynth))
 	{
-		NPCPhrase (FIGHT_URQUAN);
-		DefeatMask |= HOW_FIGHT_URQUAN;
+		NPCPhrase (ANDROSYNTH_INFO_SB);
+		HostileMask |= HOSTILE_ANDROSYNTH;
 	}
-	else if (PLAYER_SAID (R, how_ally))
+	else if (PLAYER_SAID (R, ilwrath))
 	{
-		NPCPhrase (ALLY_LIKE_SO);
-		DefeatMask |= HOW_ALLY_AGAINST_URQUAN;
+		NPCPhrase (ILWRATH_INFO_SB);
+		HostileMask |= HOSTILE_ILWRATH;
 	}
-	else if (PLAYER_SAID (R, how_get_strong))
+	else if (PLAYER_SAID (R, thraddash))
 	{
-		NPCPhrase (STRONG_LIKE_SO);
-		DefeatMask |= HOW_STRONG_AGAINST_URQUAN;
+		NPCPhrase (THRADDASH_INFO_SB);
+		HostileMask |= HOSTILE_THRADDASH;
 	}
 
-	if (!(DefeatMask & HOW_FIND_URQUAN))
-		Response (how_find_urquan, DefeatUrquan);
-	if (!(DefeatMask & HOW_FIGHT_URQUAN))
-		Response (how_fight_urquan, DefeatUrquan);
-	if (!(DefeatMask & HOW_ALLY_AGAINST_URQUAN))
-		Response (how_ally, DefeatUrquan);
-	if (!(DefeatMask & HOW_STRONG_AGAINST_URQUAN))
-		Response (how_get_strong, DefeatUrquan);
-	Response (enough_defeat, TellMission);
+	if (!(HostileMask & HOSTILE_URQUAN))
+		Response (urquan, HostileInfo);
+	if (!(HostileMask & HOSTILE_KOHRAH))
+		Response (kohrah, HostileInfo);
+	if (!(HostileMask & HOSTILE_VUX))
+		Response (vux, HostileInfo);
+	if (!(HostileMask & HOSTILE_MYCON))
+		Response (mycon, HostileInfo);
+	if (!(HostileMask & HOSTILE_ANDROSYNTH))
+		Response (androsynth, HostileInfo);
+	if (!(HostileMask & HOSTILE_ILWRATH))
+		Response (ilwrath, HostileInfo);
+	if (!(HostileMask & HOSTILE_THRADDASH))
+		Response (thraddash, HostileInfo);
+	Response (enough_enemies, AlienRaces);
 }
 
 static void
-AnalyzeCondition (void)
+NeutralInfo (RESPONSE_REF R)
 {
-	BYTE i;
-	BYTE num_thrusters = 0,
-				num_jets = 0,
-				num_guns = 0,
-				num_bays = 0,
-				num_batts = 0,
-				num_track = 0,
-				num_defense = 0;
-	BOOLEAN HasMinimum;
-
-	for (i = 0; i < NUM_DRIVE_SLOTS; ++i)
+#define NEUTRAL_DRUUGE (1 << 0)
+#define NEUTRAL_UMGAH (1 << 1)
+#define NEUTRAL_MELNORME (1 << 2)
+#define NEUTRAL_SLYLANDRO (1 << 3)
+	static BYTE NeutralMask = 0;
+	static BYTE MelnormeInfoState = 0;
+	
+	if (PLAYER_SAID (R, neutral_races))
 	{
-		if (GLOBAL_SIS (DriveSlots[i]) < EMPTY_SLOT)
-			++num_thrusters;
+		NPCPhrase (WHICH_NEUTRAL);
+		NeutralMask = 0;
 	}
-	for (i = 0; i < NUM_JET_SLOTS; ++i)
+	else if (PLAYER_SAID (R, druuge))
 	{
-		if (GLOBAL_SIS (JetSlots[i]) < EMPTY_SLOT)
-			++num_jets;
+		NPCPhrase (DRUUGE_INFO_SB);
+		NeutralMask |= NEUTRAL_DRUUGE;
 	}
-	for (i = 0; i < NUM_MODULE_SLOTS; ++i)
+	else if (PLAYER_SAID (R, umgah))
 	{
-		BYTE which_piece;
-
-		switch (which_piece = GLOBAL_SIS (ModuleSlots[i]))
-		{
-			case STORAGE_BAY:
-				++num_bays;
-				break;
-			case DYNAMO_UNIT:
-			case SHIVA_FURNACE:
-				num_batts += 1 + (which_piece - DYNAMO_UNIT);
-				break;
-			case GUN_WEAPON:
-			case BLASTER_WEAPON:
-			case CANNON_WEAPON:
-				num_guns += 1 + (which_piece - GUN_WEAPON);
-				break;
-			case TRACKING_SYSTEM:
-				++num_track;
-				break;
-			case ANTIMISSILE_DEFENSE:
-				++num_defense;
-				break;
-		}
+		NPCPhrase (UMGAH_INFO_SB);
+		NeutralMask |= NEUTRAL_UMGAH;
 	}
-	if (num_track && num_guns)
-		num_guns += 2;
-
-	HasMinimum = (num_thrusters >= 7 && num_jets >= 5
-			&& GLOBAL_SIS (CrewEnlisted) >= CREW_POD_CAPACITY
-			&& GLOBAL_SIS (FuelOnBoard) >= FUEL_TANK_CAPACITY
-			&& num_bays >= 1 && GLOBAL_SIS (NumLanders)
-			&& num_batts >= 1 && num_guns >= 2);
-	NPCPhrase (LETS_SEE);
-	if (!HasMinimum && GET_GAME_STATE (CHMMR_BOMB_STATE) < 2)
-	{
-		NPCPhrase (IMPROVE_1);
-		if (num_thrusters < 7)
-			NPCPhrase (NEED_THRUSTERS_1);
-		if (num_jets < 5)
-			NPCPhrase (NEED_TURN_1);
-		if (num_guns < 2)
-			NPCPhrase (NEED_GUNS_1);
-		if (GLOBAL_SIS (CrewEnlisted) < CREW_POD_CAPACITY)
-			NPCPhrase (NEED_CREW_1);
-		if (GLOBAL_SIS (FuelOnBoard) < FUEL_TANK_CAPACITY)
-			NPCPhrase (NEED_FUEL_1);
-		if (num_bays < 1)
-			NPCPhrase (NEED_STORAGE_1);
-		if (GLOBAL_SIS (NumLanders) == 0)
-			NPCPhrase (NEED_LANDERS_1);
-		if (num_batts < 1)
-			NPCPhrase (NEED_DYNAMOS_1);
-
-		if (GLOBAL_SIS (ResUnits) >= 3000)
-			NPCPhrase (IMPROVE_FLAGSHIP_WITH_RU);
-		else
-			NPCPhrase (GO_GET_MINERALS);
-	}
-	else
+	else if (PLAYER_SAID (R, melnorme))
 	{
-		BYTE num_aliens = 0;
-		COUNT FleetStrength;
-		BOOLEAN HasMaximum;
-
-		FleetStrength = ActivateStarShip (0, ESCORT_WORTH);
-		for (i = 0; i < NUM_AVAILABLE_RACES; ++i)
-		{
-			if (i != HUMAN_SHIP
-					&& ActivateStarShip (i, CHECK_ALLIANCE) == GOOD_GUY)
-				++num_aliens;
-		}
-
-		HasMaximum = (num_thrusters == NUM_DRIVE_SLOTS
-				&& num_jets == NUM_JET_SLOTS
-				&& GLOBAL_SIS (CrewEnlisted) >= CREW_POD_CAPACITY * 3
-				&& GLOBAL_SIS (FuelOnBoard) >= FUEL_TANK_CAPACITY * 3
-				&& GLOBAL_SIS (NumLanders) >= 3
-				&& num_batts >= 4 && num_guns >= 7 && num_defense >= 2);
-		if (!HasMaximum && GET_GAME_STATE (CHMMR_BOMB_STATE) < 2)
-			NPCPhrase (GOT_OK_FLAGSHIP);
-		else
-			NPCPhrase (GOT_AWESOME_FLAGSHIP);
-
-		if (GET_GAME_STATE (CHMMR_BOMB_STATE) >= 2)
-		{
-			NPCPhrase (CHMMR_IMPROVED_BOMB);
-			if (FleetStrength < 20000)
-				NPCPhrase (MUST_ACQUIRE_AWESOME_FLEET);
-			else
-			{
-				NPCPhrase (GOT_AWESOME_FLEET);
-				if (!GET_GAME_STATE (TALKING_PET_ON_SHIP))
-					NPCPhrase (MUST_ELIMINATE_URQUAN_GUARDS);
-				else
-					NPCPhrase (GO_DESTROY_SAMATRA);
-			}
-		}
-		else if (num_aliens < 2)
-			NPCPhrase (GO_ALLY_WITH_ALIENS);
-		else
-		{
-			NPCPhrase (MADE_SOME_ALLIES);
-			if (FleetStrength < 6000)
-			{
-				if (GLOBAL_SIS (ResUnits) >= 3000)
-					NPCPhrase (BUY_COMBAT_SHIPS);
-				else
-					NPCPhrase (GET_SHIPS_BY_MINING_OR_ALLIANCE);
-			}
-			else
-			{
-				NPCPhrase (GOT_OK_FLEET);
-				if (!HasMaximum)
-				{
-					NPCPhrase (IMPROVE_2);
-					if (num_thrusters < NUM_DRIVE_SLOTS)
-						NPCPhrase (NEED_THRUSTERS_2);
-					if (num_jets < NUM_JET_SLOTS)
-						NPCPhrase (NEED_TURN_2);
-					if (num_guns < 7)
-						NPCPhrase (NEED_GUNS_2);
-					if (GLOBAL_SIS (CrewEnlisted) < CREW_POD_CAPACITY * 3)
-						NPCPhrase (NEED_CREW_2);
-					if (GLOBAL_SIS (FuelOnBoard) < FUEL_TANK_CAPACITY * 3)
-						NPCPhrase (NEED_FUEL_2);
-					if (GLOBAL_SIS (NumLanders) < 3)
-						NPCPhrase (NEED_LANDERS_2);
-					if (num_batts < 4)
-						NPCPhrase (NEED_DYNAMOS_2);
-					if (num_defense < 2)
-						NPCPhrase (NEED_POINT);
-				}
-				else if (!GET_GAME_STATE (AWARE_OF_SAMATRA))
-					NPCPhrase (GO_LEARN_ABOUT_URQUAN);
-				else
-				{
-					NPCPhrase (KNOW_ABOUT_SAMATRA);
-					if (!GET_GAME_STATE (UTWIG_BOMB))
-						NPCPhrase (FIND_WAY_TO_DESTROY_SAMATRA);
-					else if (GET_GAME_STATE (UTWIG_BOMB_ON_SHIP))
-						NPCPhrase (MUST_INCREASE_BOMB_STRENGTH);
-				}
-			}
-		}
-	}
+		NPCPhrase (MELNORME_INFO_SB);
+		NeutralMask |= NEUTRAL_MELNORME;
+		++MelnormeInfoState;
+	}
+	else if (PLAYER_SAID (R, where_melnorme_planet))
+	{
+		NPCPhrase (MELNORME_INFO_SB_2);
+		++MelnormeInfoState;
+	}
+	else if (PLAYER_SAID (R, slylandro))
+	{
+		NPCPhrase (SLYLANDRO_INFO_SB);
+		NeutralMask |= NEUTRAL_SLYLANDRO;
+	}
+	
+	if (!(NeutralMask & NEUTRAL_UMGAH))
+		Response (umgah, NeutralInfo);
+	if (!(NeutralMask & NEUTRAL_DRUUGE))
+		Response (druuge, NeutralInfo);
+	if (!(NeutralMask & NEUTRAL_MELNORME))
+		Response (melnorme, NeutralInfo);
+	if (MelnormeInfoState == 1)
+		Response (where_melnorme_planet, NeutralInfo);
+	if (!(NeutralMask & NEUTRAL_SLYLANDRO))
+		Response (slylandro, NeutralInfo);
+	Response (enough_neutral, AlienRaces);
 }
 
-static void
-TellMission (RESPONSE_REF R)
-{
-	RESPONSE_REF pstack[4];
-
-	if (PLAYER_SAID (R, our_mission))
-	{
-		NPCPhrase (WHICH_MISSION);
-		stack0 = 0;
-		stack1 = 0;
-		stack2 = 0;
-		stack3 = 0;
-	}
-	else if (PLAYER_SAID (R, where_get_minerals))
-	{
-		NPCPhrase (GET_MINERALS);
-
-		stack0 = 1;
-	}
-	else if (PLAYER_SAID (R, what_about_aliens))
-	{
-		NPCPhrase (ABOUT_ALIENS);
-
-		stack1 = 1;
-	}
-	else if (PLAYER_SAID (R, what_do_now))
-	{
-		AnalyzeCondition ();
-
-		stack2 = 1;
-	}
-	else if (PLAYER_SAID (R, what_about_urquan))
-	{
-		NPCPhrase (MUST_DEFEAT);
-
-		stack3 = 1;
-	}
-	else if (PLAYER_SAID (R, enough_defeat))
-	{
-		NPCPhrase (OK_ENOUGH_DEFEAT);
-
-		stack3 = 2;
-	}
-
-	switch (stack0)
-	{
-		case 0:
-			pstack[0] = where_get_minerals;
-			break;
-		default:
-			pstack[0] = 0;
-			break;
-	}
-	switch (stack1)
-	{
-		case 0:
-			pstack[1] = what_about_aliens;
-			break;
-		default:
-			pstack[1] = 0;
-			break;
-	}
-	switch (stack2)
-	{
-		case 0:
-			pstack[2] = what_do_now;
-			break;
-		default:
-			pstack[2] = 0;
-			break;
-	}
-	switch (stack3)
-	{
-		case 0:
-			pstack[3] = what_about_urquan;
-			break;
-		case 1:
-			pstack[3] = how_defeat;
-			break;
-		default:
-			pstack[3] = 0;
-			break;
-	}
-
-	if (pstack[0])
-		Response (pstack[0], TellMission);
-	if (pstack[1])
-		Response (pstack[1], TellMission);
-	if (pstack[2])
-		Response (pstack[2], TellMission);
-	if (pstack[3])
-	{
-		if (stack3 == 1)
-			Response (pstack[3], DefeatUrquan);
-		else
-			Response (pstack[3], TellMission);
-	}
-
-	Response (enough_mission, NeedInfo);
-}
+static void NormalStarbase (RESPONSE_REF R);
 
 static void
-TellStarBase (RESPONSE_REF R)
+AlienRaces (RESPONSE_REF R)
 {
-	RESPONSE_REF pstack[4];
-	static UNICODE buf0[80];
-
-	if (PLAYER_SAID (R, starbase_functions))
-	{
-		NPCPhrase (WHICH_FUNCTION);
-		stack0 = 0;
-		stack1 = 0;
-		stack2 = 0;
-		stack3 = 0;
-	}
-	else if (PLAYER_SAID (R, tell_me_about_fuel0))
-	{
-		NPCPhrase (ABOUT_FUEL);
-
-		stack1 = 1;
-	}
-	else if (PLAYER_SAID (R, tell_me_about_crew))
-	{
-		NPCPhrase (ABOUT_CREW0);
-		if (speechVolumeScale > 0.0f)
-			NPCPhrase (YOUR_FLAGSHIP_3DO2);
-		else {
-			NPCPhrase (YOUR_FLAGSHIP_PC);
-			NPCPhrase (GLOBAL_SHIP_NAME);
-		}
-		NPCPhrase (ABOUT_CREW1);
-
-		stack2 = 2;
-	}
-	else if (PLAYER_SAID (R, tell_me_about_modules0))
-	{
-		NPCPhrase (ABOUT_MODULES);
+#define RACES_ALLIANCE (1 << 0)
+#define RACES_HOSTILE (1 << 1)
+#define RACES_NEUTRAL (1 << 2)
+	static BYTE RacesMask = 0;
 
-		stack0 = 1;
-	}
-	else if (PLAYER_SAID (R, tell_me_about_ships))
+	if (PLAYER_SAID (R, info_on_races))
 	{
-		NPCPhrase (ABOUT_SHIPS);
-
-		stack2 = 1;
+		NPCPhrase (WHICH_ALIEN);
+		RacesMask = 0;
 	}
-	else if (PLAYER_SAID (R, tell_me_about_ru))
+	else if (PLAYER_SAID (R, enough_allies))
 	{
-		NPCPhrase (ABOUT_RU);
-
-		stack3 = 1;
+		NPCPhrase (ENOUGH_ALLIES_OK);
+		RacesMask |= RACES_ALLIANCE;
 	}
-	else if (PLAYER_SAID (R, tell_me_about_minerals))
+	else if (PLAYER_SAID (R, enough_enemies))
 	{
-		NPCPhrase (ABOUT_MINERALS);
-
-		stack3 = 2;
+		NPCPhrase (ENOUGH_HOSTILES_OK);
+		RacesMask |= RACES_HOSTILE;
 	}
-	else if (PLAYER_SAID (R, tell_me_about_life))
+	else if (PLAYER_SAID (R, enough_neutral))
 	{
-		NPCPhrase (ABOUT_LIFE);
-
-		stack3 = 3;
+		NPCPhrase (ENOUGH_NEUTRAL_OK);
+		RacesMask |= RACES_NEUTRAL;
 	}
 
-	switch (stack0)
-	{
-		case 0:
-			construct_response (
-					buf0,
-					tell_me_about_modules0,
-					GLOBAL_SIS (ShipName),
-					tell_me_about_modules1,
-					(UNICODE*)NULL);
-			pstack[0] = tell_me_about_modules0;
-			break;
-		default:
-			pstack[0] = 0;
-			break;
-	}
-	switch (stack1)
+	if (!(RacesMask & RACES_ALLIANCE))
 	{
-		case 0:
-			construct_response (
-					shared_phrase_buf,
-					tell_me_about_fuel0,
-					GLOBAL_SIS (ShipName),
-					tell_me_about_fuel1,
-					(UNICODE*)NULL);
-			pstack[1] = tell_me_about_fuel0;
-			break;
-		default:
-			pstack[1] = 0;
-			break;
+		Response (alliance_races, AllianceInfo);
 	}
-	switch (stack2)
+	if (!(RacesMask & RACES_HOSTILE))
 	{
-		case 0:
-			pstack[2] = tell_me_about_ships;
-			break;
-		case 1:
-			pstack[2] = tell_me_about_crew;
-			break;
-		default:
-			pstack[2] = 0;
-			break;
+		Response (hostile_races, HostileInfo);
 	}
-	switch (stack3)
+	if (!(RacesMask & RACES_NEUTRAL))
 	{
-		case 0:
-			pstack[3] = tell_me_about_ru;
-			break;
-		case 1:
-			pstack[3] = tell_me_about_minerals;
-			break;
-		case 2:
-			pstack[3] = tell_me_about_life;
-			break;
-		default:
-			pstack[3] = 0;
-			break;
+		Response (neutral_races, NeutralInfo);
 	}
-
-	if (pstack[0])
-		DoResponsePhrase (pstack[0], TellStarBase, buf0);
-	if (pstack[1])
-		DoResponsePhrase (pstack[1], TellStarBase, shared_phrase_buf);
-	if (pstack[2])
-		Response (pstack[2], TellStarBase);
-	if (pstack[3])
-		Response (pstack[3], TellStarBase);
-
-	Response (enough_starbase, NeedInfo);
-}
-
-static void NormalStarbase (RESPONSE_REF R);
-
-static void
-NeedInfo (RESPONSE_REF R)
-{
-	if (PLAYER_SAID (R, need_info))
-		NPCPhrase (WHAT_KIND_OF_INFO);
-	else if (PLAYER_SAID (R, enough_starbase))
-		NPCPhrase (OK_ENOUGH_STARBASE);
-	else if (PLAYER_SAID (R, enough_history))
-		NPCPhrase (OK_ENOUGH_HISTORY);
-	else if (PLAYER_SAID (R, enough_mission))
-		NPCPhrase (OK_ENOUGH_MISSION);
-
-	Response (starbase_functions, TellStarBase);
-	Response (history, TellHistory);
-	Response (our_mission, TellMission);
-	Response (no_need_info, NormalStarbase);
+	
+	Response (enough_info_races, NormalStarbase);
 }
 
 static BOOLEAN
@@ -1050,14 +460,6 @@ DiscussDevices (BOOLEAN TalkAbout)
 		pStr = 0;
 		switch (i)
 		{
-			case ROSY_SPHERE_DEVICE:
-				if (GET_GAME_STATE (ROSY_SPHERE_ON_SHIP)
-						&& !GET_GAME_STATE (DISCUSSED_ROSY_SPHERE))
-				{
-					pStr = ABOUT_SPHERE;
-					SET_GAME_STATE (DISCUSSED_ROSY_SPHERE, TalkAbout);
-				}
-				break;
 			case ARTIFACT_2_DEVICE:
 				if (GET_GAME_STATE (ARTIFACT_2_ON_SHIP)
 						&& !GET_GAME_STATE (DISCUSSED_ARTIFACT_2))
@@ -1122,14 +524,6 @@ DiscussDevices (BOOLEAN TalkAbout)
 					SET_GAME_STATE (DISCUSSED_ULTRON, TalkAbout);
 				}
 				break;
-			case MAIDENS_DEVICE:
-				if (GET_GAME_STATE (MAIDENS_ON_SHIP)
-						&& !GET_GAME_STATE (DISCUSSED_MAIDENS))
-				{
-					pStr = ABOUT_MAIDENS;
-					SET_GAME_STATE (DISCUSSED_MAIDENS, TalkAbout);
-				}
-				break;
 			case TALKING_PET_DEVICE:
 				if (GET_GAME_STATE (TALKING_PET_ON_SHIP)
 						&& !GET_GAME_STATE (DISCUSSED_TALKING_PET))
@@ -1146,14 +540,6 @@ DiscussDevices (BOOLEAN TalkAbout)
 					SET_GAME_STATE (DISCUSSED_AQUA_HELIX, TalkAbout);
 				}
 				break;
-			case CLEAR_SPINDLE_DEVICE:
-				if (GET_GAME_STATE (CLEAR_SPINDLE_ON_SHIP)
-						&& !GET_GAME_STATE (DISCUSSED_CLEAR_SPINDLE))
-				{
-					pStr = ABOUT_SPINDLE;
-					SET_GAME_STATE (DISCUSSED_CLEAR_SPINDLE, TalkAbout);
-				}
-				break;
 			case UMGAH_HYPERWAVE_DEVICE:
 				if (GET_GAME_STATE (UMGAH_BROADCASTERS_ON_SHIP)
 						&& !GET_GAME_STATE (DISCUSSED_UMGAH_HYPERWAVE))
@@ -1348,327 +734,22 @@ CheckTiming (COUNT month_index, COUNT da
 }
 
 static void
-CheckBulletins (BOOLEAN Repeat)
-{
-	RESPONSE_REF pIntro;
-	BYTE b0;
-	DWORD BulletinMask;
-
-	if (Repeat)
-		BulletinMask = CurBulletinMask ^ 0xFFFFFFFFL;
-	else
-		BulletinMask = GET_GAME_STATE_32 (STARBASE_BULLETS0);
-
-	pIntro = 0;
-	for (b0 = 0; b0 < 32; ++b0)
-	{
-		if (!(BulletinMask & (1L << b0)))
-		{
-			RESPONSE_REF pStr;
-
-			pStr = 0;
-			switch (b0)
-			{
-				case 0:
-					if (ActivateStarShip (SPATHI_SHIP, CHECK_ALLIANCE)
-							== GOOD_GUY)
-					{
-						pStr = STARBASE_BULLETIN_1;
-					}
-					break;
-				case 1:
-					if (ActivateStarShip (ZOQFOTPIK_SHIP, CHECK_ALLIANCE)
-							== GOOD_GUY)
-					{
-						pStr = STARBASE_BULLETIN_2;
-					}
-					break;
-				case 2:
-					if (ActivateStarShip (SUPOX_SHIP, CHECK_ALLIANCE)
-							== GOOD_GUY)
-					{
-						pStr = STARBASE_BULLETIN_3;
-					}
-					break;
-				case 3:
-					if (ActivateStarShip (UTWIG_SHIP, CHECK_ALLIANCE)
-							== GOOD_GUY)
-					{
-						pStr = STARBASE_BULLETIN_4;
-					}
-					break;
-				case 4:
-					if (ActivateStarShip (ORZ_SHIP, CHECK_ALLIANCE)
-							== GOOD_GUY)
-					{
-						pStr = STARBASE_BULLETIN_5;
-					}
-					break;
-				case 5:
-					if (GET_GAME_STATE (ARILOU_MANNER) == 2)
-						BulletinMask |= 1L << b0;
-					else if (GET_GAME_STATE (PORTAL_SPAWNER)
-							&& (Repeat || ActivateStarShip (
-									ARILOU_SHIP, FEASIBILITY_STUDY
-									)))
-					{
-#define NUM_GIFT_ARILOUS 3
-						pStr = STARBASE_BULLETIN_6;
-						if (!Repeat)
-							ActivateStarShip (ARILOU_SHIP, NUM_GIFT_ARILOUS);
-					}
-					break;
-				case 6:
-					if (GET_GAME_STATE (ZOQFOT_DISTRESS) == 1)
-					{
-						pStr = STARBASE_BULLETIN_7;
-					}
-					break;
-				case 7:
-					if (GET_GAME_STATE (MET_MELNORME))
-						BulletinMask |= 1L << b0;
-					else if (CheckTiming (3, 0))
-					{
-						pStr = STARBASE_BULLETIN_8;
-					}
-					break;
-				case 8:
-					if (GET_GAME_STATE (MET_MELNORME))
-						BulletinMask |= 1L << b0;
-					else if (CheckTiming (6, 0))
-					{
-						pStr = STARBASE_BULLETIN_9;
-					}
-					break;
-				case 9:
-					if (GET_GAME_STATE (FOUND_PLUTO_SPATHI))
-						BulletinMask |= 1L << b0;
-					else if (CheckTiming (0, 7))
-					{
-						pStr = STARBASE_BULLETIN_10;
-					}
-					break;
-				case 10:
-					if (GET_GAME_STATE (SPATHI_SHIELDED_SELVES))
-					{
-						pStr = STARBASE_BULLETIN_11;
-					}
-					break;
-				case 11:
-					if (GET_GAME_STATE (ZOQFOT_HOME_VISITS)
-							|| GET_GAME_STATE_32 (ZOQFOT_GRPOFFS0))
-						BulletinMask |= 1L << b0;
-					else if (CheckTiming (0, 42))
-					{
-						pStr = STARBASE_BULLETIN_12;
-					}
-					break;
-				case 12:
-					if (ActivateStarShip (CHMMR_SHIP, CHECK_ALLIANCE)
-							== GOOD_GUY)
-					{
-						pStr = STARBASE_BULLETIN_13;
-					}
-					break;
-				case 13:
-					if (ActivateStarShip (SHOFIXTI_SHIP, CHECK_ALLIANCE)
-							== GOOD_GUY)
-					{
-						pStr = STARBASE_BULLETIN_14;
-					}
-					break;
-				case 14:
-					if (GET_GAME_STATE (PKUNK_MISSION))
-					{
-						pStr = STARBASE_BULLETIN_15;
-					}
-					break;
-				case 15:
-					if (GET_GAME_STATE (DESTRUCT_CODE_ON_SHIP))
-						BulletinMask |= 1L << b0;
-					else if (CheckTiming (7, 0))
-					{
-						pStr = STARBASE_BULLETIN_16;
-					}
-					break;
-				case 16:
-					break;
-				case 17:
-					if (GET_GAME_STATE (YEHAT_ABSORBED_PKUNK))
-					{
-						pStr = STARBASE_BULLETIN_18;
-					}
-					break;
-				case 18:
-					if (GET_GAME_STATE (CHMMR_BOMB_STATE) == 2)
-					{
-						pStr = STARBASE_BULLETIN_19;
-					}
-					break;
-				case 19:
-					break;
-				case 20:
-					break;
-				case 21:
-					if (GET_GAME_STATE (ZOQFOT_DISTRESS) == 2)
-					{
-						pStr = STARBASE_BULLETIN_22;
-					}
-					break;
-				case 22:
-					break;
-				case 23:
-					break;
-				case 24:
-					break;
-				case 25:
-					break;
-				case 26:
-				{
-					COUNT crew_sold;
-
-					crew_sold = MAKE_WORD (
-							GET_GAME_STATE (CREW_SOLD_TO_DRUUGE0),
-							GET_GAME_STATE (CREW_SOLD_TO_DRUUGE1)
-							);
-					if (crew_sold > 100)
-						BulletinMask |= 1L << b0;
-					else if (crew_sold)
-					{
-						pStr = STARBASE_BULLETIN_27;
-					}
-					break;
-				}
-				case 27:
-				{
-					COUNT crew_sold;
-
-					crew_sold = MAKE_WORD (
-							GET_GAME_STATE (CREW_SOLD_TO_DRUUGE0),
-							GET_GAME_STATE (CREW_SOLD_TO_DRUUGE1)
-							);
-					if (crew_sold > 250)
-						BulletinMask |= 1L << b0;
-					else if (crew_sold > 100)
-					{
-						pStr = STARBASE_BULLETIN_28;
-					}
-					break;
-				}
-				case 28:
-				{
-					COUNT crew_bought;
-
-					crew_bought = MAKE_WORD (
-							GET_GAME_STATE (CREW_PURCHASED0),
-							GET_GAME_STATE (CREW_PURCHASED1)
-							);
-					if (crew_bought >= CREW_EXPENSE_THRESHOLD)
-					{
-						pStr = STARBASE_BULLETIN_29;
-					}
-					break;
-				}
-				case 29:
-					if (MAKE_WORD (
-							GET_GAME_STATE (CREW_SOLD_TO_DRUUGE0),
-							GET_GAME_STATE (CREW_SOLD_TO_DRUUGE1)
-							) > 250)
-					{
-						pStr = STARBASE_BULLETIN_30;
-					}
-					break;
-				case 30:
-					break;
-				case 31:
-					break;
-			}
-
-			if (pStr)
-			{
-				if (pIntro)
-					NPCPhrase (BETWEEN_BULLETINS);
-				else if (Repeat)
-					pIntro = BEFORE_WE_GO_ON_1;
-				else
-				{
-					switch ((BYTE)TFB_Random () % 7)
-					{
-						case 0:
-							pIntro = BEFORE_WE_GO_ON_1;
-							break;
-						case 1:
-							pIntro = BEFORE_WE_GO_ON_2;
-							break;
-						case 2:
-							pIntro = BEFORE_WE_GO_ON_3;
-							break;
-						case 3:
-							pIntro = BEFORE_WE_GO_ON_4;
-							break;
-						case 4:
-							pIntro = BEFORE_WE_GO_ON_5;
-							break;
-						case 5:
-							pIntro = BEFORE_WE_GO_ON_6;
-							break;
-						default:
-							pIntro = BEFORE_WE_GO_ON_7;
-							break;
-					}
-
-					NPCPhrase (pIntro);
-				}
-
-				NPCPhrase (pStr);
-				CurBulletinMask |= 1L << b0;
-			}
-		}
-	}
-
-	if (pIntro == 0 && GET_GAME_STATE (STARBASE_VISITED))
-		NPCPhrase (RETURN_HELLO);
-	else if (!Repeat)
-		SET_GAME_STATE_32 (STARBASE_BULLETS0, BulletinMask);
-}
-
-static void
 NormalStarbase (RESPONSE_REF R)
-{
-	if (PLAYER_SAID (R, no_need_info))
-		NPCPhrase (OK_NO_NEED_INFO);
-	else if (PLAYER_SAID (R, new_devices))
-		DiscussDevices (TRUE);
-	else if (PLAYER_SAID (R, repeat_bulletins))
-		CheckBulletins (TRUE);
-	else if (R == 0)
+{	
+	static BYTE ExplorerInfoState = 0;
+	static BYTE LandingInfoState = 0;
+	static BYTE NewsState = 0;
+	
+	if (R == 0)
 	{
-		if (GET_GAME_STATE (MOONBASE_ON_SHIP))
+		if(!(GET_GAME_STATE(STARBASE_VISITED_FOR_FIRST_TIME)))
 		{
-			NPCPhrase (STARBASE_IS_READY_A);
-			if (speechVolumeScale > 0.0f)
-				NPCPhrase (YOUR_FLAGSHIP_3DO1);
-			else {
-				NPCPhrase (YOUR_FLAGSHIP_PC);
-				NPCPhrase (GLOBAL_SHIP_NAME);
-			}
-			NPCPhrase (STARBASE_IS_READY_B);
-			if (speechVolumeScale > 0.0f)
-				NPCPhrase (YOUR_FLAGSHIP_3DO0);
-			else
-				NPCPhrase (GLOBAL_SHIP_NAME);
-			NPCPhrase (STARBASE_IS_READY_C);
-			LockMutex (GraphicsLock);
-			DeltaSISGauges (0, 0, 2500);
-			UnlockMutex (GraphicsLock);
 			SET_GAME_STATE (STARBASE_MONTH,
 					GLOBAL (GameClock.month_index));
 			SET_GAME_STATE (STARBASE_DAY,
 					GLOBAL (GameClock.day_index));
-		}
-		else if (GET_GAME_STATE (STARBASE_VISITED))
-		{
-			CheckBulletins (FALSE);
+			NPCPhrase (FIRST_HELLO);
+			SET_GAME_STATE(STARBASE_VISITED_FOR_FIRST_TIME, 1);
 		}
 		else
 		{
@@ -1711,25 +792,103 @@ NormalStarbase (RESPONSE_REF R)
 					break;
 			}
 			NPCPhrase (pStr0);
-			if (speechVolumeScale == 0.0f)
-			{
-				NPCPhrase (SPACE);
-				NPCPhrase (GLOBAL_PLAYER_NAME);
-			}
-			NPCPhrase (pStr1);
-			CheckBulletins (FALSE);
 		}
 
 		SET_GAME_STATE (STARBASE_VISITED, 1);
 	}
-
+	
+	////// ANSWERS
+	// Answer returning from AlienRaces
+	if (PLAYER_SAID (R, enough_info_races))
+		NPCPhrase (ENOUGH_INFO_RACES_OK);
+	
+	// Answer about landing on alliance home planets.
+	else if (PLAYER_SAID (R, lame_landing_question_1))
+	{
+		NPCPhrase (LAME_LANDING_ANSWER_1);
+		++LandingInfoState;
+	}
+	else if (PLAYER_SAID (R, lame_landing_question_2))
+	{
+		NPCPhrase (LAME_LANDING_ANSWER_2);
+		++LandingInfoState;
+	}
+	else if (PLAYER_SAID (R, lame_landing_question_3))
+	{
+		NPCPhrase (LAME_LANDING_ANSWER_3);
+		DISABLE_PHRASE(lame_landing_question_1);
+		LandingInfoState = 0;
+	}
+	
+	// Answer about ship
+	else if (PLAYER_SAID (R, explorer_info))
+	{
+		NPCPhrase (ABOUT_EXPLORER_SHIP);
+		++ExplorerInfoState;
+	}
+	else if (PLAYER_SAID (R, explorer_drawbacks))
+	{
+		NPCPhrase (ABOUT_EXPLORER_SHIP_2);
+		++ExplorerInfoState;
+	}
+	else if (PLAYER_SAID (R, explorer_run))
+	{
+		NPCPhrase (ABOUT_EXPLORER_SHIP_3);
+		DISABLE_PHRASE(explorer_info);
+		ExplorerInfoState = 0;
+	}
+	
+	// Answer news
+	else if (PLAYER_SAID (R, current_news))
+	{
+		NPCPhrase (SHOFIXTI_MISSING);
+		DISABLE_PHRASE(current_news);
+		++NewsState;
+	}
+	// Answer map limits
+	else if (PLAYER_SAID (R, lame_map_limit_question))
+	{
+		NPCPhrase (LAME_MAP_LIMIT_ANSWER);
+		DISABLE_PHRASE(lame_map_limit_question);
+		--NewsState;
+	}
+	
+	///////QUESTIONS
+	// Ask news
+	if (PHRASE_ENABLED (current_news))
+		Response (current_news, NormalStarbase);
+	// Ask about map limitations
+	else if (NewsState==1 && PHRASE_ENABLED (lame_map_limit_question))
+		Response (lame_map_limit_question, NormalStarbase);
+	
+	// Minerals to offload
 	if (GLOBAL_SIS (TotalElementMass))
 		Response (have_minerals, SellMinerals);
-	if (DiscussDevices (FALSE))
-		Response (new_devices, NormalStarbase);
-	if (CurBulletinMask)
-		Response (repeat_bulletins, NormalStarbase);
-	Response (need_info, NeedInfo);
+	
+	// Ask about ship
+	if (ExplorerInfoState == 0 && PHRASE_ENABLED (explorer_info))
+		Response (explorer_info, NormalStarbase);
+	else if (ExplorerInfoState == 1)
+		Response (explorer_drawbacks, NormalStarbase);
+	else if (ExplorerInfoState == 2)
+		Response (explorer_run, NormalStarbase);
+	
+	// Ask about landing on alliance home planets
+	if (LandingInfoState == 0 && PHRASE_ENABLED (lame_landing_question_1))
+		Response (lame_landing_question_1, NormalStarbase);
+	else if (LandingInfoState == 1)
+		Response (lame_landing_question_2, NormalStarbase);
+	else if (LandingInfoState == 2)
+		Response (lame_landing_question_3, NormalStarbase);
+	
+	// Devices
+	//if (DiscussDevices (FALSE))
+	//	Response (new_devices, NormalStarbase);
+	
+	// Ask about aliens and other info
+	Response (info_on_races, AlienRaces);
+	
+	// Leave
 	Response (goodbye_commander, ByeBye);
 }
 
@@ -1799,7 +958,7 @@ SellMinerals (RESPONSE_REF R)
 	LockMutex (GraphicsLock);
 	ClearSISRect (DRAW_SIS_DISPLAY);
 	UnlockMutex (GraphicsLock);
-// DrawStorageBays (FALSE);
+	//DrawStorageBays (FALSE);
 
 	if (total < 1000)
 	{
@@ -1914,11 +1073,11 @@ SellMinerals (RESPONSE_REF R)
 	}
 
 	NPCPhrase (pStr1);
-	if (speechVolumeScale == 0.0f)
+	/*if (speechVolumeScale == 0.0f)
 	{
 		NPCPhrase (SPACE);
 		NPCPhrase (GLOBAL_PLAYER_NAME);
-	}
+	}*/
 	NPCPhrase (pStr2);
 
 	NormalStarbase (R);
@@ -1939,11 +1098,6 @@ uninit_starbase (void)
 static void
 post_starbase_enc (void)
 {
-	SET_GAME_STATE (MOONBASE_ON_SHIP, 0);
-	if (GET_GAME_STATE (CHMMR_BOMB_STATE) == 2)
-	{
-		SET_GAME_STATE (CHMMR_BOMB_STATE, 3);
-	}
 }
 
 LOCDATA*
@@ -1955,9 +1109,9 @@ init_starbase_comm ()
 	commander_desc.post_encounter_func = post_starbase_enc;
 	commander_desc.uninit_encounter_func = uninit_starbase;
 
-	commander_desc.AlienTextWidth = 143;
-	commander_desc.AlienTextBaseline.x = 164;
-	commander_desc.AlienTextBaseline.y = 20;
+	commander_desc.AlienTextWidth = RES_SIS_SCALE(143);
+	commander_desc.AlienTextBaseline.x = RES_SIS_SCALE(164);
+	commander_desc.AlienTextBaseline.y = RES_SIS_SCALE(20);
 
 	// use alternate Starbase track if available
 	commander_desc.AlienAltSongRes = STARBASE_ALT_MUSIC;
diff -ruNp src.orig/uqm/comm/starbas/strings.h src/uqm/comm/starbas/strings.h
--- src.orig/uqm/comm/starbas/strings.h	2017-11-01 15:30:24 -0700
+++ src/uqm/comm/starbas/strings.h	2017-11-01 15:31:01 -0700
@@ -21,6 +21,81 @@
 enum
 {
 	NULL_PHRASE,
+	explorer_info,
+	ABOUT_EXPLORER_SHIP,
+	explorer_drawbacks,
+	ABOUT_EXPLORER_SHIP_2,
+	explorer_run,
+	ABOUT_EXPLORER_SHIP_3,
+	info_on_races,
+	INFO_RACES,
+	alliance_races,
+	WHICH_ALLY,
+	chmmr,
+	CHMMR_INFO_SB,
+	shofixti,
+	SHOFIXTI_INFO_SB,
+	yehat_and_pkunk,
+	YEHAT_AND_PKUNK_INFO_SB,
+	arilou,
+	ARILOU_INFO_SB,
+	syreen,
+	SYREEN_INFO_SB,
+	spathi,
+	SPATHI_INFO_SB,
+	zoqfot,
+	ZOQFOT_INFO_SB,
+	orz,
+	ORZ_INFO_SB,
+	supox_and_utwig,
+	SUPOX_UTWIG_INFO_SB,
+	enough_allies,
+	hostile_races,
+	WHICH_ENEMY,
+	urquan,
+	UR_QUAN_INFO_SB,
+	kohrah,
+	KOHR_AH_INFO_SB,
+	vux,
+	VUX_INFO_SB,
+	mycon,
+	MYCON_INFO_SB,
+	androsynth,
+	ANDROSYNTH_INFO_SB,
+	ilwrath,
+	ILWRATH_INFO_SB,
+	thraddash,
+	THRADDASH_INFO_SB,
+	enough_enemies,
+	neutral_races,
+	WHICH_NEUTRAL,
+	umgah,
+	UMGAH_INFO_SB,
+	melnorme,
+	MELNORME_INFO_SB,
+	where_melnorme_planet,
+	MELNORME_INFO_SB_2,
+	druuge,
+	DRUUGE_INFO_SB,
+	slylandro,
+	SLYLANDRO_INFO_SB,
+	enough_neutral,
+	enough_info_races,
+	ENOUGH_ALLIES_OK,
+	ENOUGH_HOSTILES_OK,
+	ENOUGH_NEUTRAL_OK,
+	ENOUGH_INFO_RACES_OK,
+	current_news,
+	SHOFIXTI_MISSING,
+	lame_map_limit_question,
+	LAME_MAP_LIMIT_ANSWER,
+	lame_landing_question_1,
+	LAME_LANDING_ANSWER_1,
+	lame_landing_question_2,
+	LAME_LANDING_ANSWER_2,
+	lame_landing_question_3,
+	LAME_LANDING_ANSWER_3,
+	FIRST_HELLO,
 	BEFORE_WE_GO_ON_1,
 	BEFORE_WE_GO_ON_2,
 	BEFORE_WE_GO_ON_3,
@@ -290,20 +365,7 @@ enum
 	what_about_hierarchy,
 	what_about_other,
 	enough_aliens,
-	shofixti,
-	yehat,
-	arilou,
-	chenjesu,
-	mmrnmhrm,
-	syreen,
 	enough_alliance,
-	urquan,
-	mycon,
-	spathi,
-	umgah,
-	androsynth,
-	vux,
-	ilwrath,
 	enough_hierarchy,
 	precursors,
 	old_races,
diff -ruNp src.orig/uqm/comm/supox/supoxc.c src/uqm/comm/supox/supoxc.c
--- src.orig/uqm/comm/supox/supoxc.c	2017-11-01 15:30:24 -0700
+++ src/uqm/comm/supox/supoxc.c	2017-11-01 15:31:01 -0700
@@ -25,6 +25,7 @@
 
 static LOCDATA supox_desc =
 {
+	SUPOX_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -98,6 +99,11 @@ static LOCDATA supox_desc =
 	NULL, NULL, NULL,
 	NULL,
 	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
 };
 
 static void
diff -ruNp src.orig/uqm/comm/syreen/resinst.h src/uqm/comm/syreen/resinst.h
--- src.orig/uqm/comm/syreen/resinst.h	2017-11-01 15:30:24 -0700
+++ src/uqm/comm/syreen/resinst.h	2017-11-01 15:31:01 -0700
@@ -1,4 +1,5 @@
 #define SYREEN_PMAP_ANIM "comm.syreen.graphics"
+#define SYREEN2_PMAP_ANIM "comm.syreen2.graphics"
 #define SYREEN_FONT "comm.syreen.font"
 #define SYREEN_COLOR_MAP "comm.syreen.colortable"
 #define SYREEN_CONVERSATION_PHRASES "comm.syreen.dialogue"
diff -ruNp src.orig/uqm/comm/syreen/strings.h src/uqm/comm/syreen/strings.h
--- src.orig/uqm/comm/syreen/strings.h	2017-11-01 15:30:24 -0700
+++ src/uqm/comm/syreen/strings.h	2017-11-01 15:31:01 -0700
@@ -22,137 +22,23 @@
 enum
 {
 	NULL_PHRASE,
-	HELLO_BEFORE_AMBUSH_1,
-	HELLO_BEFORE_AMBUSH_2,
-	HELLO_BEFORE_AMBUSH_3,
-	HELLO_BEFORE_AMBUSH_4,
-	we_are_vice_squad,
-	OK_VICE,
-	we_are_the_one_for_you_baby,
-	MAYBE_CAPTAIN,
-	we_are_vindicator0,
-	we_are_vindicator1,
-	we_are_vindicator2,
-	WELCOME_VINDICATOR0,
-	WELCOME_VINDICATOR1,
-	WELCOME_VINDICATOR2,
-	we_are_impressed,
-	SO_AM_I_CAPTAIN,
-	HOW_CAN_YOU_BE_HERE,
-	we_here_to_help,
-	NO_NEED_HELP,
-	we_need_help,
-	CANT_GIVE_HELP,
-	i_need_you,
-	OK_NEED,
-	i_need_touch_o_vision,
-	TOUCH_O_VISION,
-	know_about_deep_children,
-	WHAT_ABOUT_DEEP_CHILDREN,
-	mycons_involved,
-	WHAT_PROOF,
-	have_no_proof,
-	NEED_PROOF,
-	have_proof,
-	SEE_PROOF,
-	look_at_egg_sacks,
-	HORRIBLE_TRUTH,
-	what_doing_here,
-	OUR_NEW_WORLD,
-	what_about_war,
-	ABOUT_WAR,
-	help_us,
-	WONT_HELP,
-	what_about_history,
-	BEFORE_WAR,
-	what_about_homeworld,
-	ABOUT_HOMEWORLD,
-	what_happened,
-	DONT_KNOW_HOW,
-	what_about_outfit,
-	HOPE_YOU_LIKE_IT,
-	where_mates,
-	MATES_KILLED,
-	get_lonely,
-	MAKE_OUT_ALL_RIGHT,
-	bye,
-	GOODBYE,
-	MUST_ACT,
-	whats_next_step,
-	OPEN_VAULT,
-	where_is_it,
-	DONT_KNOW_WHERE,
-	been_there,
-	GREAT,
-	GIVE_SHUTTLE,
-	im_on_my_way,
-	doing_this_for_you,
-	if_i_die,
-	GOOD_LUCK,
-	OK_FOUND_VAULT,
-	what_now,
-	HERES_THE_PLAN,
-	whats_my_reward,
-	HERES_REWARD,
-	bye_after_vault,
-	GOODBYE_AFTER_VAULT,
-	HELLO_AFTER_AMBUSH_1,
-	HELLO_AFTER_AMBUSH_2,
-	HELLO_AFTER_AMBUSH_3,
-	HELLO_AFTER_AMBUSH_4,
-	what_now_after_ambush,
-	DO_THIS_AFTER_AMBUSH,
-	what_about_you,
-	ABOUT_ME,
-	whats_up_after_ambush,
-	GENERAL_INFO_AFTER_AMBUSH_1,
-	GENERAL_INFO_AFTER_AMBUSH_2,
-	GENERAL_INFO_AFTER_AMBUSH_3,
-	GENERAL_INFO_AFTER_AMBUSH_4,
-	bye_after_ambush,
-	GOODBYE_AFTER_AMBUSH,
-	FOUND_VAULT_YET_1,
-	FOUND_VAULT_YET_2,
-	vault_hint,
-	OK_HINT,
-	found_vault,
-	bye_before_vault,
-	GOODBYE_BEFORE_VAULT,
-	what_do_i_get_for_this,
-	GRATITUDE,
-	not_sure,
-	PLEASE,
-	READY_FOR_AMBUSH,
-	repeat_plan,
-	OK_REPEAT_PLAN,
-	bye_before_ambush,
-	GOODBYE_BEFORE_AMBUSH,
-	what_about_us,
-	ABOUT_US,
-	MORE_COMFORTABLE,
-	in_the_spirit,
-	OK_SPIRIT,
-	what_in_mind,
-	SOMETHING_LIKE_THIS,
-	hands_off,
-	OK_WONT_USE_HANDS,
-	why_lights_off,
-	LIGHTS_OFF_BECAUSE,
-	evil_monster,
-	NOT_EVIL_MONSTER,
-	disease,
-	JUST_RELAX,
-	what_happens_if_i_touch_this,
-	THIS_HAPPENS,
-	are_you_sure_this_is_ok,
-	YES_SURE,
-	boy_they_never_taught,
-	THEN_LET_ME_TEACH,
-	not_much_more_to_say,
-	THEN_STOP_TALKING,
-	LATER,
-	SEX_GOODBYE,
-	OUT_TAKES,
+	SYREEN_GREETING1,
+	because_we_can,
+	looking_for_artefacts,
+	spacebabes,
+	NICE_TUG,
+	thanks_tug_complement,
+	not_fooled,
+	DOUBLE_WHATNOW, 
+	SURE_I_WAS,
+	ANY_ASSISTANCE,
+	roam_stars,
+	WE_DONT_STRAY,
+	any_news,
+	NO_NEWS,
+	spot_you_later,
+	COME_BACK_ANYTIME,
+
 };
 
 #endif /* _STRINGS_H */
diff -ruNp src.orig/uqm/comm/syreen/syreenc.c src/uqm/comm/syreen/syreenc.c
--- src.orig/uqm/comm/syreen/syreenc.c	2017-11-01 15:30:24 -0700
+++ src/uqm/comm/syreen/syreenc.c	2017-11-01 15:31:01 -0700
@@ -16,16 +16,22 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: -Cleaned up the comm logic a bit...
+//			 -Added a whole slew of new animations
+
 #include "../commall.h"
 #include "resinst.h"
 #include "strings.h"
-
+#include "libs/mathlib.h"
 #include "libs/sound/sound.h"
 #include "uqm/build.h"
+#include "uqm/encount.h"
+// BW: for EncounterGroup, no longer included in commall.h
 
 
-static LOCDATA syreen_desc =
+static LOCDATA syreen_desc_1x =
 {
+	SYREEN_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -36,136 +42,161 @@ static LOCDATA syreen_desc =
 	{0, 0}, /* AlienTextBaseline */
 	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
 	ALIGN_CENTER, /* AlienTextAlign */
-	VALIGN_TOP, /* AlienTextValign */
+	VALIGN_BOTTOM, /* AlienTextValign */
 	SYREEN_COLOR_MAP, /* AlienColorMap */
 	SYREEN_MUSIC, /* AlienSong */
 	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	SYREEN_CONVERSATION_PHRASES, /* PlayerPhrases */
-	15, /* NumAnimations */
+	9, /* NumAnimations */
 	{ /* AlienAmbientArray (ambient animations) */
-		{
-			5, /* StartIndex */
-			2, /* NumFrames */
-			RANDOM_ANIM, /* AnimFlags */
-			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
-			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+		{	// 0 - Flash eyes
+			1, /* StartIndex */
+			5, /* NumFrames */
+			YOYO_ANIM | WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 24, ONE_SECOND / 24, /* FrameRate */
+			ONE_SECOND * 7, ONE_SECOND * 6, /* RestartRate */
 			0, /* BlockMask */
 		},
-		{
-			7, /* StartIndex */
-			2, /* NumFrames */
-			RANDOM_ANIM, /* AnimFlags */
-			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
-			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
-			0, /* BlockMask */
+		{	// 1 - Bust pump
+			6, /* StartIndex */
+			4, /* NumFrames */
+			YOYO_ANIM | WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 7, 0, /* FrameRate */
+			ONE_SECOND * 4, ONE_SECOND, /* RestartRate */
+			(1 << 2) | (1 << 3), /* BlockMask */
+		},
+		{	// 2 - The seductive leg movement
+			10, /* StartIndex */
+			12, /* NumFrames */
+			YOYO_ANIM | WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 13, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 10, ONE_SECOND * 3, /* RestartRate */
+			(1 << 1) | (1 << 5), /* BlockMask */
 		},
-		{
-			9, /* StartIndex */
-			2, /* NumFrames */
-			RANDOM_ANIM, /* AnimFlags */
-			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
-			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
-			0, /* BlockMask */
+		{	// 3 - Hand moving joystick, resulting in electricity on Tesla coil
+			22, /* StartIndex */
+			28, /* NumFrames */
+			CIRCULAR_ANIM | WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 15, 0, /* FrameRate */
+			ONE_SECOND * 8, ONE_SECOND * 4, /* RestartRate */
+			(1 << 1) | (1 << 5), /* BlockMask */
 		},
-		{
-			11, /* StartIndex */
-			2, /* NumFrames */
-			RANDOM_ANIM, /* AnimFlags */
-			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
-			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+		{	// 4 - Green syreen ship in oscilloscope view
+			50, /* StartIndex */
+			6, /* NumFrames */
+			CIRCULAR_ANIM | WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 12, ONE_SECOND / 15, /* FrameRate */
+			0, 0, /* RestartRate */
 			0, /* BlockMask */
 		},
-		{
-			13, /* StartIndex */
-			2, /* NumFrames */
-			RANDOM_ANIM, /* AnimFlags */
-			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
-			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+		{	// 5 - Hand stroking joystick
+			56, /* StartIndex */
+			4, /* NumFrames */
+			YOYO_ANIM | WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 8, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 6, ONE_SECOND * 2, /* RestartRate */
+			(1 << 2) | (1 << 3), /* BlockMask */
+		},
+		{	// 6 - The looong ship spin anim on big screen
+			60, /* StartIndex */
+			106, /* NumFrames */
+			CIRCULAR_ANIM | WAIT_TALKING | FAST_STOP_AT_TALK_START, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			ONE_SECOND * 3, ONE_SECOND * 2, /* RestartRate */
 			0, /* BlockMask */
 		},
-		{
-			15, /* StartIndex */
-			2, /* NumFrames */
-			RANDOM_ANIM, /* AnimFlags */
-			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
-			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
-			(1 << 12), /* BlockMask */
-		},
-		{
-			17, /* StartIndex */
-			2, /* NumFrames */
-			RANDOM_ANIM, /* AnimFlags */
-			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
-			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
-			0, /* BlockMask */
+		{	// 7 - Close-up eyes blink
+			182, /* StartIndex */
+			7, /* NumFrames */
+			CIRCULAR_ANIM | WHEN_TALKING, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			ONE_SECOND * 2, ONE_SECOND * 2, /* RestartRate */
+			(1 << 8), /* BlockMask */
+		},
+		{	// 8 - Close-up eyebrow lift
+			189, /* StartIndex */
+			17, /* NumFrames */
+			CIRCULAR_ANIM | WHEN_TALKING, /* AnimFlags */
+			ONE_SECOND / 16, 0, /* FrameRate */
+			ONE_SECOND * 5, ONE_SECOND * 4, /* RestartRate */
+			(1 << 7), /* BlockMask */
 		},
-		{
-			19, /* StartIndex */
+	},
+	{ /* AlienTransitionDesc */
+		166, /* StartIndex */
+		8, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 30, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		174, /* StartIndex */
+		8, /* NumFrames */
+		TALK_INTRO, /* AnimFlags */
+		ONE_SECOND / 16, ONE_SECOND / 30, /* FrameRate */
+		ONE_SECOND / 10, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
+};
+
+
+static LOCDATA syreen_desc_4x =
+{
+	SYREEN_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	SYREEN_PMAP_ANIM, /* AlienFrame */
+	SYREEN_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_BOTTOM, /* AlienTextValign */
+	SYREEN_COLOR_MAP, /* AlienColorMap */
+	SYREEN_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	SYREEN_CONVERSATION_PHRASES, /* PlayerPhrases */
+	3, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{	// 0 - Eyes blink
+			1, /* StartIndex */
 			2, /* NumFrames */
-			RANDOM_ANIM, /* AnimFlags */
-			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
-			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
-			(1 << 13),
-		},
-		{
-			21, /* StartIndex */
-			6, /* NumFrames */
-			RANDOM_ANIM, /* AnimFlags */
-			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
-			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			ONE_SECOND * 2, ONE_SECOND * 2, /* RestartRate */
 			0, /* BlockMask */
 		},
-		{
-			27, /* StartIndex */
-			4, /* NumFrames */
-			YOYO_ANIM, /* AnimFlags */
-			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
-			ONE_SECOND * 10, ONE_SECOND * 3, /* RestartRate */
-			(1 << 14), /* BlockMask */
-		},
-		{
-			31, /* StartIndex */
+		{	// 1 - Oscilloscope view
+			10, /* StartIndex */
 			6, /* NumFrames */
 			CIRCULAR_ANIM, /* AnimFlags */
-			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
-			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			ONE_SECOND / 2, 0, /* FrameRate */
+			ONE_SECOND / 2, 0, /* RestartRate */
 			0, /* BlockMask */
 		},
-		{
-			37, /* StartIndex */
-			4, /* NumFrames */
-			RANDOM_ANIM, /* AnimFlags */
-			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
-			ONE_SECOND / 15, ONE_SECOND / 15, /* RestartRate */
+		{	// 2 - Electricity on Tesla coil
+			16, /* StartIndex */
+			5, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND / 60, 0, /* RestartRate */
 			0, /* BlockMask */
 		},
-		{
-			41, /* StartIndex */
-			3, /* NumFrames */
-			YOYO_ANIM, /* AnimFlags */
-			ONE_SECOND / 10, ONE_SECOND / 15, /* FrameRate */
-			ONE_SECOND * 10, ONE_SECOND * 3, /* RestartRate */
-			(1 << 5), /* BlockMask */
-		},
-		{
-			44, /* StartIndex */
-			4, /* NumFrames */
-			YOYO_ANIM
-					| WAIT_TALKING, /* AnimFlags */
-			ONE_SECOND / 6, 0, /* FrameRate */
-			ONE_SECOND * 3, ONE_SECOND, /* RestartRate */
-			(1 << 7) | (1 << 14), /* BlockMask */
-		},
-		{
-			48, /* StartIndex */
-			3, /* NumFrames */
-			YOYO_ANIM
-					| WAIT_TALKING, /* AnimFlags */
-			ONE_SECOND * 2 / 15, ONE_SECOND / 15, /* FrameRate */
-			ONE_SECOND * 10, ONE_SECOND,/* RestartRate */
-			(1 << 9) | (1 << 13), /* BlockMask */
-		},
 	},
 	{ /* AlienTransitionDesc */
 		0, /* StartIndex */
@@ -176,11 +207,11 @@ static LOCDATA syreen_desc =
 		0, /* BlockMask */
 	},
 	{ /* AlienTalkDesc */
-		1, /* StartIndex */
-		4, /* NumFrames */
-		0, /* AnimFlags */
-		ONE_SECOND / 15, 0, /* FrameRate */
-		ONE_SECOND / 12, 0, /* RestartRate */
+		3, /* StartIndex */
+		7, /* NumFrames */
+		TALK_INTRO, /* AnimFlags */
+		ONE_SECOND / 20, ONE_SECOND / 15, /* FrameRate */
+		ONE_SECOND / 20, ONE_SECOND / 15, /* RestartRate */
 		0, /* BlockMask */
 	},
 	NULL, /* AlienNumberSpeech - none */
@@ -188,664 +219,120 @@ static LOCDATA syreen_desc =
 	NULL, NULL, NULL,
 	NULL,
 	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
 };
 
+
 static void
-FriendlyExit (RESPONSE_REF R)
+ExitConversation (RESPONSE_REF R)
 {
+	(void) R; // satisfy compiler
+	NPCPhrase (COME_BACK_ANYTIME);
 	SET_GAME_STATE (BATTLE_SEGUE, 0);
-
-	if (PLAYER_SAID (R, bye))
-		NPCPhrase (GOODBYE);
-	else if (PLAYER_SAID (R, im_on_my_way)
-			|| PLAYER_SAID (R, doing_this_for_you)
-			|| PLAYER_SAID (R, if_i_die))
-		NPCPhrase (GOOD_LUCK);
-	else if (PLAYER_SAID (R, bye_before_vault))
-		NPCPhrase (GOODBYE_BEFORE_VAULT);
-	else if (PLAYER_SAID (R, bye_after_vault))
-		NPCPhrase (GOODBYE_AFTER_VAULT);
-	else if (PLAYER_SAID (R, bye_before_ambush))
-		NPCPhrase (GOODBYE_BEFORE_AMBUSH);
-	else if (PLAYER_SAID (R, bye_after_ambush))
-		NPCPhrase (GOODBYE_AFTER_AMBUSH);
-	else
-	{
-		if (PLAYER_SAID (R, hands_off))
-			NPCPhrase (OK_WONT_USE_HANDS);
-		else if (PLAYER_SAID (R, not_much_more_to_say))
-			NPCPhrase (THEN_STOP_TALKING);
-		NPCPhrase (LATER);
-		NPCPhrase (SEX_GOODBYE);
-
-		AlienTalkSegue (2);
-		XFormColorMap (GetColorMapAddress (
-				SetAbsColorMapIndex (CommData.AlienColorMap, 0)
-				), ONE_SECOND / 2);
-		AlienTalkSegue ((COUNT)~0);
-
-		SET_GAME_STATE (PLAYER_HAD_SEX, 1);
-		SET_GAME_STATE (PLAYER_HAVING_SEX, 0);
-	}
 }
 
-static void
-Sex (RESPONSE_REF R)
-{
-	if (PLAYER_SAID (R, in_the_spirit))
-		NPCPhrase (OK_SPIRIT);
-	else if (PLAYER_SAID (R, what_in_mind))
-		NPCPhrase (SOMETHING_LIKE_THIS);
-	else if (PLAYER_SAID (R, disease))
-		NPCPhrase (JUST_RELAX);
-	else if (PLAYER_SAID (R, what_happens_if_i_touch_this))
-	{
-		NPCPhrase (THIS_HAPPENS);
-
-		DISABLE_PHRASE (what_happens_if_i_touch_this);
-	}
-	else if (PLAYER_SAID (R, are_you_sure_this_is_ok))
-	{
-		NPCPhrase (YES_SURE);
-
-		DISABLE_PHRASE (are_you_sure_this_is_ok);
-	}
-	else if (PLAYER_SAID (R, boy_they_never_taught))
-	{
-		NPCPhrase (THEN_LET_ME_TEACH);
-
-		DISABLE_PHRASE (boy_they_never_taught);
-	}
-
-	if (!PHRASE_ENABLED (what_happens_if_i_touch_this)
-			&& !PHRASE_ENABLED (are_you_sure_this_is_ok)
-			&& !PHRASE_ENABLED (boy_they_never_taught))
-		Response (not_much_more_to_say, FriendlyExit);
-	else
-	{
-		if (PHRASE_ENABLED (what_happens_if_i_touch_this))
-			Response (what_happens_if_i_touch_this, Sex);
-		if (PHRASE_ENABLED (are_you_sure_this_is_ok))
-			Response (are_you_sure_this_is_ok, Sex);
-		if (PHRASE_ENABLED (boy_they_never_taught))
-			Response (boy_they_never_taught, Sex);
-	}
-}
 
 static void
-Foreplay (RESPONSE_REF R)
-{
-	if (PLAYER_SAID (R, whats_my_reward)
-			|| PLAYER_SAID (R, what_about_us))
-	{
-		if (PLAYER_SAID (R, whats_my_reward))
-			NPCPhrase (HERES_REWARD);
-		else
-			NPCPhrase (ABOUT_US);
-		NPCPhrase (MORE_COMFORTABLE);
-		AlienTalkSegue (1);
-		XFormColorMap (GetColorMapAddress (
-				SetAbsColorMapIndex (CommData.AlienColorMap, 1)
-				), ONE_SECOND);
-		AlienTalkSegue ((COUNT)~0);
-
-		SET_GAME_STATE (PLAYER_HAVING_SEX, 1);
-	}
-	else if (PLAYER_SAID (R, why_lights_off))
-	{
-		NPCPhrase (LIGHTS_OFF_BECAUSE);
-
-		DISABLE_PHRASE (why_lights_off);
-	}
-	else if (PLAYER_SAID (R, evil_monster))
-	{
-		NPCPhrase (NOT_EVIL_MONSTER);
+AskMenu1 (RESPONSE_REF R)
+{	
+	/* Alien speech */
 
-		DISABLE_PHRASE (evil_monster);
-	}
-
-	if (PHRASE_ENABLED (why_lights_off))
-		Response (why_lights_off, Foreplay);
-	else if (PHRASE_ENABLED (evil_monster))
-		Response (evil_monster, Foreplay);
-	else
-		Response (disease, Sex);
-	Response (in_the_spirit, Sex);
-	Response (what_in_mind, Sex);
-	Response (hands_off, FriendlyExit);
-}
 
-static void
-AfterAmbush (RESPONSE_REF R)
-{
-	if (PLAYER_SAID (R, what_now_after_ambush))
+	if (PLAYER_SAID (R, any_news))
 	{
-		NPCPhrase (DO_THIS_AFTER_AMBUSH);
-
-		DISABLE_PHRASE (what_now_after_ambush);
+		NPCPhrase (NO_NEWS);
+		DISABLE_PHRASE (any_news);
 	}
-	else if (PLAYER_SAID (R, what_about_you))
+	else if (PLAYER_SAID (R, roam_stars))
 	{
-		NPCPhrase (ABOUT_ME);
-
-		DISABLE_PHRASE (what_about_you);
+		NPCPhrase (WE_DONT_STRAY);
+		DISABLE_PHRASE (roam_stars);
 	}
-	else if (PLAYER_SAID (R, whats_up_after_ambush))
+			
+	/* Human speech options */
+	
+	if (PHRASE_ENABLED (any_news))
 	{
-		BYTE NumVisits;
-
-		NumVisits = GET_GAME_STATE (SYREEN_INFO);
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (GENERAL_INFO_AFTER_AMBUSH_1);
-				break;
-			case 1:
-				NPCPhrase (GENERAL_INFO_AFTER_AMBUSH_2);
-				break;
-			case 2:
-				NPCPhrase (GENERAL_INFO_AFTER_AMBUSH_3);
-				break;
-			case 3:
-				NPCPhrase (GENERAL_INFO_AFTER_AMBUSH_4);
-				--NumVisits;
-				break;
-		}
-		SET_GAME_STATE (SYREEN_INFO, NumVisits);
-
-		DISABLE_PHRASE (whats_up_after_ambush);
+		Response (any_news, AskMenu1);
 	}
 
-	if (PHRASE_ENABLED (what_about_you))
-		Response (what_about_you, AfterAmbush);
-	else if (!GET_GAME_STATE (PLAYER_HAD_SEX))
+    if (PHRASE_ENABLED (roam_stars))
 	{
-		Response (what_about_us, Foreplay);
+		Response (roam_stars, AskMenu1);
 	}
-	if (PHRASE_ENABLED (what_now_after_ambush))
-		Response (what_now_after_ambush, AfterAmbush);
-	if (PHRASE_ENABLED (whats_up_after_ambush))
-		Response (whats_up_after_ambush, AfterAmbush);
-	Response (bye_after_ambush, FriendlyExit);
-}
-
-static void
-AmbushReady (RESPONSE_REF R)
-{
-	if (PLAYER_SAID (R, repeat_plan))
+	
+	if (PHRASE_ENABLED (spot_you_later))
 	{
-		NPCPhrase (OK_REPEAT_PLAN);
-
-		DISABLE_PHRASE (repeat_plan);
+		Response (spot_you_later, ExitConversation);
 	}
-
-	if (PHRASE_ENABLED (repeat_plan))
-		Response (repeat_plan, AmbushReady);
-	Response (bye_before_ambush, FriendlyExit);
 }
 
-static void
-SyreenShuttle (RESPONSE_REF R)
-{
-	if (PLAYER_SAID (R, whats_next_step))
-	{
-		NPCPhrase (OPEN_VAULT);
-
-		DISABLE_PHRASE (whats_next_step);
-	}
-	else if (PLAYER_SAID (R, what_do_i_get_for_this))
-	{
-		NPCPhrase (GRATITUDE);
-
-		DISABLE_PHRASE (what_do_i_get_for_this);
-	}
-	else if (PLAYER_SAID (R, not_sure))
-	{
-		NPCPhrase (PLEASE);
-
-		DISABLE_PHRASE (not_sure);
-	}
-	else if (PLAYER_SAID (R, where_is_it))
-	{
-		NPCPhrase (DONT_KNOW_WHERE);
-		NPCPhrase (GIVE_SHUTTLE);
-
-		SET_GAME_STATE (SYREEN_SHUTTLE, 1);
-		SET_GAME_STATE (SYREEN_SHUTTLE_ON_SHIP, 1);
-
-		DISABLE_PHRASE (where_is_it);
-	}
-	else if (PLAYER_SAID (R, been_there))
-	{
-		NPCPhrase (GREAT);
-		NPCPhrase (GIVE_SHUTTLE);
-
-		SET_GAME_STATE (SYREEN_SHUTTLE, 1);
-		SET_GAME_STATE (SYREEN_SHUTTLE_ON_SHIP, 1);
-
-		DISABLE_PHRASE (been_there);
-	}
 
-	if (PHRASE_ENABLED (whats_next_step))
-		Response (whats_next_step, SyreenShuttle);
-	else
-	{
-		if (!GET_GAME_STATE (KNOW_SYREEN_VAULT))
-		{
-			if (PHRASE_ENABLED (where_is_it))
-				Response (where_is_it, SyreenShuttle);
-		}
-		else
-		{
-			if (PHRASE_ENABLED (been_there))
-				Response (been_there, SyreenShuttle);
-		}
-		if (!PHRASE_ENABLED (where_is_it)
-				|| !PHRASE_ENABLED (been_there))
-		{
-			Response (im_on_my_way, FriendlyExit);
-			Response (doing_this_for_you, FriendlyExit);
-			Response (if_i_die, FriendlyExit);
-		}
-	}
-	if (PHRASE_ENABLED (what_do_i_get_for_this))
-		Response (what_do_i_get_for_this, SyreenShuttle);
-	if (PHRASE_ENABLED (not_sure))
-		Response (not_sure, SyreenShuttle);
-}
 
 static void
-NormalSyreen (RESPONSE_REF R)
-{
-	BYTE i, LastStack;
-	RESPONSE_REF pStr[4];
-
-	LastStack = 0;
-	pStr[0] = pStr[1] = pStr[2] = pStr[3] = 0;
-	if (PLAYER_SAID (R, we_here_to_help))
-		NPCPhrase (NO_NEED_HELP);
-	else if (PLAYER_SAID (R, we_need_help))
-		NPCPhrase (CANT_GIVE_HELP);
-	else if (PLAYER_SAID (R, know_about_deep_children))
-	{
-		NPCPhrase (WHAT_ABOUT_DEEP_CHILDREN);
-
-		DISABLE_PHRASE (know_about_deep_children);
-	}
-	else if (PLAYER_SAID (R, mycons_involved))
-	{
-		NPCPhrase (WHAT_PROOF);
-
-		SET_GAME_STATE (KNOW_ABOUT_SHATTERED, 3);
-	}
-	else if (PLAYER_SAID (R, have_no_proof))
-	{
-		NPCPhrase (NEED_PROOF);
-
-		SET_GAME_STATE (SYREEN_WANT_PROOF, 1);
-	}
-	else if (PLAYER_SAID (R, have_proof))
-	{
-		NPCPhrase (SEE_PROOF);
-
-		DISABLE_PHRASE (have_proof);
-	}
-	else if (PLAYER_SAID (R, what_doing_here))
-	{
-		NPCPhrase (OUR_NEW_WORLD);
-
-		SET_GAME_STATE (SYREEN_STACK0, 1);
-		LastStack = 1;
-	}
-	else if (PLAYER_SAID (R, what_about_war))
-	{
-		NPCPhrase (ABOUT_WAR);
-
-		SET_GAME_STATE (SYREEN_STACK0, 2);
-		LastStack = 1;
-	}
-	else if (PLAYER_SAID (R, help_us))
-	{
-		NPCPhrase (WONT_HELP);
-
-		SET_GAME_STATE (SYREEN_STACK0, 3);
-	}
-	else if (PLAYER_SAID (R, what_about_history))
-	{
-		NPCPhrase (BEFORE_WAR);
-
-		SET_GAME_STATE (SYREEN_STACK1, 1);
-		LastStack = 2;
-	}
-	else if (PLAYER_SAID (R, what_about_homeworld))
+SyreenResponse1 (RESPONSE_REF R)
+{	
+	if (PLAYER_SAID (R, thanks_tug_complement))
 	{
-		NPCPhrase (ABOUT_HOMEWORLD);
-
-		SET_GAME_STATE (SYREEN_STACK1, 2);
-		LastStack = 2;
+		NPCPhrase (SURE_I_WAS);
 	}
-	else if (PLAYER_SAID (R, what_happened))
+	else if (PLAYER_SAID (R, not_fooled))
 	{
-		NPCPhrase (DONT_KNOW_HOW);
-
-		SET_GAME_STATE (KNOW_SYREEN_WORLD_SHATTERED, 1);
-		SET_GAME_STATE (SYREEN_STACK1, 3);
+		NPCPhrase (DOUBLE_WHATNOW);
 	}
-	else if (PLAYER_SAID (R, what_about_outfit))
-	{
-		NPCPhrase (HOPE_YOU_LIKE_IT);
-
-		SET_GAME_STATE (SYREEN_STACK2, 1);
-		LastStack = 3;
-	}
-	else if (PLAYER_SAID (R, where_mates))
-	{
-		NPCPhrase (MATES_KILLED);
 
-		SET_GAME_STATE (SYREEN_STACK2, 2);
-		LastStack = 3;
-	}
-	else if (PLAYER_SAID (R, get_lonely))
-	{
-		NPCPhrase (MAKE_OUT_ALL_RIGHT);
-
-		SET_GAME_STATE (SYREEN_STACK2, 3);
-	}
-	else if (PLAYER_SAID (R, look_at_egg_sacks))
-	{
-		NPCPhrase (HORRIBLE_TRUTH);
-
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
-		SET_GAME_STATE (SYREEN_HOME_VISITS, 0);
-		SET_GAME_STATE (SYREEN_KNOW_ABOUT_MYCON, 1);
-
-		SyreenShuttle ((RESPONSE_REF)0);
-		return;
-	}
-
-	if (GET_GAME_STATE (KNOW_ABOUT_SHATTERED) < 3)
-	{
-		if (GET_GAME_STATE (KNOW_ABOUT_SHATTERED) == 2
-				&& GET_GAME_STATE (KNOW_SYREEN_WORLD_SHATTERED))
-		{
-			if (PHRASE_ENABLED (know_about_deep_children))
-				pStr[0] = know_about_deep_children;
-			else
-				pStr[0] = mycons_involved;
-		}
-	}
-	else
-	{
-		if (GET_GAME_STATE (EGG_CASE0_ON_SHIP)
-				|| GET_GAME_STATE (EGG_CASE1_ON_SHIP)
-				|| GET_GAME_STATE (EGG_CASE2_ON_SHIP))
-		{
-			if (PHRASE_ENABLED (have_proof))
-				pStr[0] = have_proof;
-			else
-				pStr[0] = look_at_egg_sacks;
-		}
-		else if (!GET_GAME_STATE (SYREEN_WANT_PROOF))
-		{
-			pStr[0] = have_no_proof;
-		}
-	}
-	switch (GET_GAME_STATE (SYREEN_STACK0))
-	{
-		case 0:
-			pStr[1] = what_doing_here;
-			break;
-		case 1:
-			pStr[1] = what_about_war;
-			break;
-		case 2:
-			pStr[1] = help_us;
-			break;
-	}
-	switch (GET_GAME_STATE (SYREEN_STACK1))
-	{
-		case 0:
-			pStr[2] = what_about_history;
-			break;
-		case 1:
-			pStr[2] = what_about_homeworld;
-			break;
-		case 2:
-			pStr[2] = what_happened;
-			break;
-	}
-	switch (GET_GAME_STATE (SYREEN_STACK2))
-	{
-		case 0:
-			pStr[3] = what_about_outfit;
-			break;
-		case 1:
-			pStr[3] = where_mates;
-			break;
-		case 2:
-			pStr[3] = get_lonely;
-			break;
-	}
-	if (pStr[LastStack])
-		Response (pStr[LastStack], NormalSyreen);
-	for (i = 0; i < 4; ++i)
-	{
-		if (i != LastStack && pStr[i])
-			Response (pStr[i], NormalSyreen);
-	}
-	Response (bye, FriendlyExit);
+	Response (roam_stars, AskMenu1);
+	Response (any_news, AskMenu1);
+	Response (spot_you_later, ExitConversation);
 }
 
+
 static void
-InitialSyreen (RESPONSE_REF R)
-{
-	if (PLAYER_SAID (R, we_are_vice_squad))
-	{
-		NPCPhrase (OK_VICE);
-		NPCPhrase (HOW_CAN_YOU_BE_HERE);
-	}
-	else if (PLAYER_SAID (R, we_are_the_one_for_you_baby))
-	{
-		NPCPhrase (MAYBE_CAPTAIN);
-		NPCPhrase (HOW_CAN_YOU_BE_HERE);
-	}
-	else if (PLAYER_SAID (R, we_are_vindicator0))
+NiceComplement (RESPONSE_REF R)
+{	
+	if (PLAYER_SAID (R, spacebabes))
 	{
-		NPCPhrase (WELCOME_VINDICATOR0);
-		if (speechVolumeScale == 0.0f)
-		{
-			NPCPhrase (GLOBAL_PLAYER_NAME);
-			NPCPhrase (WELCOME_VINDICATOR1);
-			NPCPhrase (GLOBAL_SHIP_NAME);
-			NPCPhrase (WELCOME_VINDICATOR2);
-		}
-		NPCPhrase (HOW_CAN_YOU_BE_HERE);
+		NPCPhrase (NICE_TUG);
 	}
-	else if (PLAYER_SAID (R, we_are_impressed))
-	{
-		NPCPhrase (SO_AM_I_CAPTAIN);
-		NPCPhrase (HOW_CAN_YOU_BE_HERE);
-	}
-	else if (PLAYER_SAID (R, i_need_you))
-	{
-		NPCPhrase (OK_NEED);
-
-		DISABLE_PHRASE (i_need_you);
-		DISABLE_PHRASE (i_need_touch_o_vision);
-	}
-	else if (PLAYER_SAID (R, i_need_touch_o_vision))
-	{
-		NPCPhrase (TOUCH_O_VISION);
-
-		DISABLE_PHRASE (i_need_you);
-		DISABLE_PHRASE (i_need_touch_o_vision);
-	}
-
-	Response (we_here_to_help, NormalSyreen);
-	Response (we_need_help, NormalSyreen);
-	if (PHRASE_ENABLED (i_need_you))
-		Response (i_need_you, InitialSyreen);
-	if (PHRASE_ENABLED (i_need_touch_o_vision))
-		Response (i_need_touch_o_vision, InitialSyreen);
-}
-
-static void
-PlanAmbush (RESPONSE_REF R)
-{
-	(void) R;  // ignored
-	NPCPhrase (OK_FOUND_VAULT);
-
-	SET_GAME_STATE (MYCON_AMBUSH, 1);
-	// This is redundant but left here for clarity
-	SET_GAME_STATE (SYREEN_HOME_VISITS, 0);
-
-	Response (whats_my_reward, Foreplay);
-	Response (bye_after_vault, FriendlyExit);
+	
+	Response (thanks_tug_complement, SyreenResponse1);
+	Response (not_fooled, SyreenResponse1);
+	Response (spot_you_later, ExitConversation);
 }
 
 static void
-SyreenVault (RESPONSE_REF R)
-{
-	if (PLAYER_SAID (R, vault_hint))
+AnyAssistance (RESPONSE_REF R)
+{	
+	if (PLAYER_SAID (R, looking_for_artefacts))
 	{
-		NPCPhrase (OK_HINT);
-
-		DISABLE_PHRASE (vault_hint);
+		NPCPhrase (ANY_ASSISTANCE);
 	}
 
-	if (PHRASE_ENABLED (vault_hint))
+	else if (PLAYER_SAID (R, because_we_can))
 	{
-		Response (vault_hint, SyreenVault);
+		NPCPhrase (ANY_ASSISTANCE);
 	}
-	Response (bye_before_vault, FriendlyExit);
+
+	Response (roam_stars, AskMenu1);
+	Response (any_news, AskMenu1);
+	Response (spot_you_later, ExitConversation);
 }
 
 static void
 Intro (void)
 {
-	BYTE NumVisits;
+	NPCPhrase (SYREEN_GREETING1);
 
-	if (LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
-	{
-		NPCPhrase (OUT_TAKES);
-
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
-		return;
-	}
-
-	NumVisits = GET_GAME_STATE (SYREEN_HOME_VISITS);
-	if (GET_GAME_STATE (MYCON_KNOW_AMBUSH))
-	{
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (HELLO_AFTER_AMBUSH_1);
-				ActivateStarShip (SYREEN_SHIP, SET_ALLIED);
-				break;
-			case 1:
-				NPCPhrase (HELLO_AFTER_AMBUSH_2);
-				break;
-			case 2:
-				NPCPhrase (HELLO_AFTER_AMBUSH_3);
-				break;
-			case 3:
-				NPCPhrase (HELLO_AFTER_AMBUSH_3);
-				--NumVisits;
-				break;
-		}
-
-		AfterAmbush ((RESPONSE_REF)0);
-	}
-	else if (GET_GAME_STATE (MYCON_AMBUSH))
-	{
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (READY_FOR_AMBUSH);
-				--NumVisits;
-				break;
-		}
-
-		AmbushReady ((RESPONSE_REF)0);
-	}
-	else if (!GET_GAME_STATE (SYREEN_KNOW_ABOUT_MYCON))
-	{
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (HELLO_BEFORE_AMBUSH_1);
-				break;
-			case 1:
-				NPCPhrase (HELLO_BEFORE_AMBUSH_2);
-				break;
-			case 2:
-				NPCPhrase (HELLO_BEFORE_AMBUSH_3);
-				break;
-			case 3:
-				NPCPhrase (HELLO_BEFORE_AMBUSH_4);
-				--NumVisits;
-				break;
-		}
-
-		if (NumVisits > 1)
-			NormalSyreen ((RESPONSE_REF)0);
-		else
-		{
-			construct_response (shared_phrase_buf,
-					we_are_vindicator0,
-					GLOBAL_SIS (CommanderName),
-					we_are_vindicator1,
-					GLOBAL_SIS (ShipName),
-					we_are_vindicator2,
-					(UNICODE*)NULL);
-			Response (we_are_vice_squad, InitialSyreen);
-			Response (we_are_the_one_for_you_baby, InitialSyreen);
-			DoResponsePhrase (we_are_vindicator0, InitialSyreen, shared_phrase_buf);
-			Response (we_are_impressed, InitialSyreen);
-		}
-	}
-#ifdef NEVER
-	else if (!GET_GAME_STATE (SYREEN_SHUTTLE))
-	{
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (MUST_ACT);
-				--NumVisits;
-				break;
-		}
-
-		SyreenShuttle ((RESPONSE_REF)0);
-	}
-#endif /* NEVER */
-	else if (GET_GAME_STATE (SHIP_VAULT_UNLOCKED))
-	{
-		PlanAmbush ((RESPONSE_REF)0);
-		// XXX: PlanAmbush() sets SYREEN_HOME_VISITS=0, but then this value
-		// is immediately reset to NumVisits just below. The intent was to
-		// reset the HELLO stack so that is what we will do here as well.
-		// Note that it is completely redundant because genvault.c resets
-		// SYREEN_HOME_VISITS when it sets SHIP_VAULT_UNLOCKED=1.
-		NumVisits = 0;
-	}
-	else
-	{
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (FOUND_VAULT_YET_1);
-				break;
-			case 1:
-				NPCPhrase (FOUND_VAULT_YET_2);
-				--NumVisits;
-				break;
-		}
-
-		SyreenVault ((RESPONSE_REF)0);
-	}
-	SET_GAME_STATE (SYREEN_HOME_VISITS, NumVisits);
+	Response (because_we_can, AnyAssistance);
+	Response (looking_for_artefacts, AnyAssistance);
+	Response (spacebabes, NiceComplement);
 }
 
+
 static COUNT
 uninit_syreen (void)
 {
@@ -862,14 +349,42 @@ LOCDATA*
 init_syreen_comm (void)
 {
 	LOCDATA *retval;
+	BOOLEAN captain;
+	static LOCDATA syreen_desc;
+
+	switch (RESOLUTION_FACTOR)
+	{
+	case 2:
+		syreen_desc = syreen_desc_4x;
+		break;
+	case 1:
+		syreen_desc = syreen_desc_4x;
+		break;
+	case 0:
+	default:
+		syreen_desc = syreen_desc_1x;
+		break;
+	}
+
+	if(LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+		captain = (TFB_Random()%2);
+	// JMS: In Interplanetary pick graphics based on battle group index number.
+	// This way the same ship has always the same captain as long as it exists.
+	else
+		captain = (EncounterGroup%2);
+
+	if (captain)
+	{
+		syreen_desc.AlienFrameRes = SYREEN2_PMAP_ANIM;
+	}
 
 	syreen_desc.init_encounter_func = Intro;
 	syreen_desc.post_encounter_func = post_syreen_enc;
 	syreen_desc.uninit_encounter_func = uninit_syreen;
 
 	syreen_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
-	syreen_desc.AlienTextBaseline.y = 0;
-	syreen_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
+	syreen_desc.AlienTextBaseline.y = 100 << RESOLUTION_FACTOR;
+	syreen_desc.AlienTextWidth = SIS_TEXT_WIDTH - 4;
 
 	SET_GAME_STATE (BATTLE_SEGUE, 0);
 	retval = &syreen_desc;
diff -ruNp src.orig/uqm/comm/syreenbase/Makeinfo src/uqm/comm/syreenbase/Makeinfo
--- src.orig/uqm/comm/syreenbase/Makeinfo	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/syreenbase/Makeinfo	2017-11-01 15:31:01 -0700
@@ -0,0 +1 @@
+uqm_CFILES="syreenbasec.c"
diff -ruNp src.orig/uqm/comm/syreenbase/resinst.h src/uqm/comm/syreenbase/resinst.h
--- src.orig/uqm/comm/syreenbase/resinst.h	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/syreenbase/resinst.h	2017-11-01 15:31:01 -0700
@@ -0,0 +1,5 @@
+#define SYREEN_BASE_COLOR_MAP "comm.syreenbase.colortable"
+#define SYREEN_BASE_PMAP_ANIM "comm.syreenbase.graphics"
+#define SYREEN_BASE_FONT "comm.syreenbase.font"
+#define SYREEN_BASE_CONVERSATION_PHRASES "comm.syreenbase.dialogue"
+#define SYREEN_BASE_MUSIC "comm.syreenbase.music"
diff -ruNp src.orig/uqm/comm/syreenbase/strings.h src/uqm/comm/syreenbase/strings.h
--- src.orig/uqm/comm/syreenbase/strings.h	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/syreenbase/strings.h	2017-11-01 15:31:01 -0700
@@ -0,0 +1,48 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _STRINGS_H
+#define _STRINGS_H
+
+enum
+{
+	NULL_PHRASE,
+	LUCIELLE_GREETING,
+	holy_crap,
+	hello,
+	am_i_lost,
+	had_to_stop_by,
+	LUCY_SAYS_HI,
+	i_ll_tell_her,
+	perfect_name,
+	minerals_here,
+	WELCOME,
+	THANKS_SUGAR, 
+	YOU_CUTIE,
+	TALK_TO_COMMANDER,
+	MINERALS,
+	huge_fan,
+	JEALOUS,
+        not_hot,
+	MUCH_WOMAN,
+	must_be_going,
+	COME_BACK_ANYTIME_LUCIELLE,
+
+};
+
+#endif /* _STRINGS_H */
diff -ruNp src.orig/uqm/comm/syreenbase/syreenbasec.c src/uqm/comm/syreenbase/syreenbasec.c
--- src.orig/uqm/comm/syreenbase/syreenbasec.c	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/syreenbase/syreenbasec.c	2017-11-01 15:31:01 -0700
@@ -0,0 +1,318 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+// JMS 2010: Totally new file for syreen starbase comm.
+
+#include "../commall.h"
+#include "resinst.h"
+#include "strings.h"
+#include "libs/sound/sound.h"
+#include "libs/inplib.h"
+
+#include "uqm/build.h"
+#include "uqm/setup.h"
+#include "uqm/shipcont.h"
+
+
+static void SellMinerals (RESPONSE_REF R);
+
+static LOCDATA syreenbase_desc =
+{
+	SYREENBASE_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	SYREEN_BASE_PMAP_ANIM, /* AlienFrame */
+	SYREEN_BASE_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_BOTTOM, /* AlienTextValign */
+	SYREEN_BASE_COLOR_MAP, /* AlienColorMap */
+	SYREEN_BASE_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	SYREEN_BASE_CONVERSATION_PHRASES, /* PlayerPhrases */
+	0, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{
+			0, /* StartIndex */
+			0, /* NumFrames */
+			0, /* AnimFlags */
+			0, 0, /* FrameRate */
+			0, 0, /* RestartRate */
+			0, /* BlockMask */
+		}
+	},
+	{ /* AlienTransitionDesc */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		1, /* StartIndex */
+		4, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 15, 0, /* FrameRate */
+		ONE_SECOND / 12, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
+};
+
+
+static void
+ExitConversation (RESPONSE_REF R)
+{
+	(void) R; // satisfy compiler
+	NPCPhrase (COME_BACK_ANYTIME_LUCIELLE);
+	SET_GAME_STATE (BATTLE_SEGUE, 0);
+}
+
+
+static void
+AskMenu1 (RESPONSE_REF R)
+{	
+	/* Alien speech */
+
+
+	if (PLAYER_SAID (R, not_hot))
+	{
+		NPCPhrase (MUCH_WOMAN);
+		DISABLE_PHRASE (not_hot);
+	}
+	else if (PLAYER_SAID (R, huge_fan))
+	{
+		NPCPhrase (JEALOUS);
+		DISABLE_PHRASE (huge_fan);
+	}
+			
+	/* Human speech options */
+	
+	if (PHRASE_ENABLED (not_hot))
+	{
+		Response (not_hot, AskMenu1);
+	}
+
+	if (PHRASE_ENABLED (huge_fan))
+	{
+		Response (huge_fan, AskMenu1);
+	}
+	
+	if (GLOBAL_SIS (TotalElementMass))
+		Response (minerals_here, SellMinerals);
+
+	if (PHRASE_ENABLED (must_be_going))
+	{
+		Response (must_be_going, ExitConversation);
+	}
+}
+
+
+
+static void
+SyreenResponse1 (RESPONSE_REF R)
+{	
+	if (PLAYER_SAID (R, i_ll_tell_her))
+	{
+		NPCPhrase (YOU_CUTIE);
+	}
+	else if (PLAYER_SAID (R, perfect_name))
+	{
+		NPCPhrase (THANKS_SUGAR);
+	}
+
+	Response (huge_fan, AskMenu1);
+	Response (not_hot, AskMenu1);
+	if (GLOBAL_SIS (TotalElementMass))
+		Response (minerals_here, SellMinerals);
+	Response (must_be_going, ExitConversation);
+}
+
+
+static void
+NiceComplement (RESPONSE_REF R)
+{	
+	if (PLAYER_SAID (R, had_to_stop_by))
+	{
+		NPCPhrase (LUCY_SAYS_HI);
+	}
+	
+	Response (i_ll_tell_her, SyreenResponse1);
+	Response (perfect_name, SyreenResponse1);
+	if (GLOBAL_SIS (TotalElementMass))
+		Response (minerals_here, SellMinerals);
+	Response (must_be_going, ExitConversation);
+}
+
+static void
+AnyAssistance (RESPONSE_REF R)
+{	
+	if (PLAYER_SAID (R, am_i_lost))
+	{
+		NPCPhrase (TALK_TO_COMMANDER);
+	}
+
+	else if (PLAYER_SAID (R, holy_crap))
+	{
+		NPCPhrase (YOU_CUTIE);
+	}
+
+	else if  (PLAYER_SAID (R, hello))
+	{
+		NPCPhrase (WELCOME);
+	}
+
+	Response (huge_fan, AskMenu1);
+	Response (not_hot, AskMenu1);
+	if (GLOBAL_SIS (TotalElementMass))
+		Response (minerals_here, SellMinerals);
+	Response (must_be_going, ExitConversation);
+}
+
+static void
+SellMinerals (RESPONSE_REF R)
+{
+	COUNT i, total;
+	BOOLEAN Sleepy;
+
+	total = 0;
+	Sleepy = TRUE;
+	for (i = 0; i < NUM_ELEMENT_CATEGORIES; ++i)
+	{
+		COUNT amount;
+		DWORD TimeIn = 0;
+
+		if (i == 0)
+		{
+			DrawCargoStrings ((BYTE)~0, (BYTE)~0);
+			SleepThread (ONE_SECOND / 2);
+			TimeIn = GetTimeCounter ();
+			DrawCargoStrings ((BYTE)0, (BYTE)0);
+		}
+		else if (Sleepy)
+		{
+			DrawCargoStrings ((BYTE)(i - 1), (BYTE)i);
+			TimeIn = GetTimeCounter ();
+		}
+
+		if ((amount = GLOBAL_SIS (ElementAmounts[i])) != 0)
+		{
+			total += amount * GLOBAL (ElementWorth[i]);
+			do
+			{
+				if (!Sleepy || AnyButtonPress (TRUE) ||
+						(GLOBAL (CurrentActivity) & CHECK_ABORT))
+				{
+					Sleepy = FALSE;
+					GLOBAL_SIS (ElementAmounts[i]) = 0;
+					GLOBAL_SIS (TotalElementMass) -= amount;
+					LockMutex (GraphicsLock);
+					DeltaSISGauges (0, 0, amount * GLOBAL (ElementWorth[i]));
+					UnlockMutex (GraphicsLock);
+					break;
+				}
+				
+				--GLOBAL_SIS (ElementAmounts[i]);
+				--GLOBAL_SIS (TotalElementMass);
+				TaskSwitch ();
+				TimeIn = GetTimeCounter ();
+				DrawCargoStrings ((BYTE)i, (BYTE)i);
+				LockMutex (GraphicsLock);
+				ShowRemainingCapacity ();
+				DeltaSISGauges (0, 0, GLOBAL (ElementWorth[i]));
+				UnlockMutex (GraphicsLock);
+			} while (--amount);
+		}
+		if (Sleepy) {
+			SleepThreadUntil (TimeIn + (ONE_SECOND / 4));
+			TimeIn = GetTimeCounter ();
+		}
+	}
+	SleepThread (ONE_SECOND / 2);
+
+	LockMutex (GraphicsLock);
+	ClearSISRect (DRAW_SIS_DISPLAY);
+	UnlockMutex (GraphicsLock);
+
+	NPCPhrase (MINERALS);
+
+	AskMenu1 (R);
+}
+
+static void
+Intro (void)
+{
+	if (GET_GAME_STATE (SYREEN_MET) == 0)
+	{
+		SET_GAME_STATE (SYREEN_MET, 1);
+	}
+
+	NPCPhrase (LUCIELLE_GREETING);
+
+	Response (holy_crap, AnyAssistance);
+	Response (hello, AnyAssistance);
+	Response (am_i_lost, AnyAssistance);
+	Response (had_to_stop_by, NiceComplement);
+}
+
+
+static COUNT
+uninit_syreen (void)
+{
+	return (0);
+}
+
+static void
+post_syreen_enc (void)
+{
+	// nothing defined so far
+}
+
+LOCDATA*
+init_syreenbase_comm (void)
+{
+	LOCDATA *retval;
+
+	syreenbase_desc.init_encounter_func = Intro;
+	syreenbase_desc.post_encounter_func = post_syreen_enc;
+	syreenbase_desc.uninit_encounter_func = uninit_syreen;
+
+	syreenbase_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
+	syreenbase_desc.AlienTextBaseline.y = 100 << RESOLUTION_FACTOR;
+	syreenbase_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
+
+	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	retval = &syreenbase_desc;
+
+	return (retval);
+}
diff -ruNp src.orig/uqm/comm/syreenhome/Makeinfo src/uqm/comm/syreenhome/Makeinfo
--- src.orig/uqm/comm/syreenhome/Makeinfo	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/syreenhome/Makeinfo	2017-11-01 15:31:01 -0700
@@ -0,0 +1 @@
+uqm_CFILES="syreenhomec.c"
diff -ruNp src.orig/uqm/comm/syreenhome/resinst.h src/uqm/comm/syreenhome/resinst.h
--- src.orig/uqm/comm/syreenhome/resinst.h	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/syreenhome/resinst.h	2017-11-01 15:31:01 -0700
@@ -0,0 +1,5 @@
+#define SYREEN_HOME_COLOR_MAP "comm.syreenhome.colortable"
+#define SYREEN_HOME_PMAP_ANIM "comm.syreenhome.graphics"
+#define SYREEN_HOME_FONT "comm.syreenhome.font"
+#define SYREEN_HOME_CONVERSATION_PHRASES "comm.syreenhome.dialogue"
+#define SYREEN_HOME_MUSIC "comm.syreenhome.music"
diff -ruNp src.orig/uqm/comm/syreenhome/strings.h src/uqm/comm/syreenhome/strings.h
--- src.orig/uqm/comm/syreenhome/strings.h	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/syreenhome/strings.h	2017-11-01 15:31:01 -0700
@@ -0,0 +1,47 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _STRINGS_H
+#define _STRINGS_H
+
+enum
+{
+	NULL_PHRASE,
+	SYREENHOME_GREETING1,
+	SYREENHOME_GREETING2,
+	got_drink,
+	no_seats,
+	thanks_for_hospitality,
+	ill_stand,
+	ETHANOL_FLUIDS,
+	LOTUS_POSITION,
+	PLEASURE_OURS,
+	AS_YOU_WISH,
+	searching_for_shofixti, 
+	where_do_i_start,
+	thats_all,
+	NO_INFORMATION,
+	GIVE_VESSEL_1,
+	REFUEL_AT_STARBASE,
+	GIVE_VESSEL_2,
+	NO_ROOM_FOR_VESSEL,
+	TAKE_CARE,
+	
+};
+
+#endif /* _STRINGS_H */
diff -ruNp src.orig/uqm/comm/syreenhome/syreenhomec.c src/uqm/comm/syreenhome/syreenhomec.c
--- src.orig/uqm/comm/syreenhome/syreenhomec.c	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/syreenhome/syreenhomec.c	2017-11-01 15:31:01 -0700
@@ -0,0 +1,407 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+// JMS 2010: Totally new file for syreen starbase comm.
+
+#include "../commall.h"
+#include "resinst.h"
+#include "strings.h"
+#include "libs/sound/sound.h"
+
+#include "uqm/build.h"
+#include "uqm/encount.h"
+#include "uqm/gameev.h"
+
+static LOCDATA syreenhome_desc_1x =
+{
+	SYREENHOME_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	SYREEN_HOME_PMAP_ANIM, /* AlienFrame */
+	SYREEN_HOME_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_BOTTOM, /* AlienTextValign */
+	SYREEN_HOME_COLOR_MAP, /* AlienColorMap */
+	SYREEN_HOME_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	SYREEN_HOME_CONVERSATION_PHRASES, /* PlayerPhrases */
+	12, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+	  {             // 0 - left girl turning head
+			1, /* StartIndex */
+			2, /* NumFrames */
+			CIRCULAR_ANIM | WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 2, ONE_SECOND, /* FrameRate */
+			ONE_SECOND * 3, ONE_SECOND * 5, /* RestartRate */
+			(1 << 1), /* BlockMask */
+		},
+	  {             // 1 - left girl manipulating starmap
+			3, /* StartIndex */
+			7, /* NumFrames */
+			CIRCULAR_ANIM | WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND * 3, ONE_SECOND * 5, /* RestartRate */
+			(1 << 0), /* BlockMask */
+		},
+	  {             // 2 - water flow
+			10, /* StartIndex */
+			4, /* NumFrames */
+			CIRCULAR_ANIM | WAIT_TALKING | FAST_STOP_AT_TALK_START, /* AnimFlags */
+			ONE_SECOND / 2, 0,/* FrameRate */
+			0, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+	  {             // 3 - right girl moving pieces
+			14, /* StartIndex */
+			8, /* NumFrames */
+			CIRCULAR_ANIM | WAIT_TALKING | FAST_STOP_AT_TALK_START, /* AnimFlags */
+			ONE_SECOND / 5, ONE_SECOND / 5, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+	  {             // 4 - lights switching on board
+			22, /* StartIndex */
+			5, /* NumFrames */
+			CIRCULAR_ANIM | WAIT_TALKING | FAST_STOP_AT_TALK_START, /* AnimFlags */
+			ONE_SECOND / 2, 0, /* FrameRate */
+			ONE_SECOND, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+	  {             // 5 - front girl breathing
+			27, /* StartIndex */
+			4, /* NumFrames */
+			YOYO_ANIM | WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 7, 0, /* FrameRate */
+			ONE_SECOND * 4, ONE_SECOND, /* RestartRate */
+			(1 << 7), /* BlockMask */
+		},
+	  {             // 6 - blinking eyes
+			31, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM | WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND / 10, ONE_SECOND * 5, /* RestartRate */
+			(1 << 7) | (1 << 8), /* BlockMask */
+		},
+	  {             // 7 - moving hip
+			34, /* StartIndex */
+			19, /* NumFrames */
+			CIRCULAR_ANIM | WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			ONE_SECOND * 10, ONE_SECOND * 3, /* RestartRate */
+			(1 << 5) | (1 << 6) | (1 << 8), /* BlockMask */
+		},
+	  {             // 8 - smiley face
+			53, /* StartIndex */
+			17, /* NumFrames */
+			YOYO_ANIM | WAIT_TALKING | FAST_STOP_AT_TALK_START, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 20, /* FrameRate */
+			ONE_SECOND * 3, ONE_SECOND * 5, /* RestartRate */
+			(1 << 6) | (1 << 7), /* BlockMask */
+		},
+	  {             // 9 - zoomed left girl turning head
+			140, /* StartIndex */
+			2, /* NumFrames */
+			CIRCULAR_ANIM | WHEN_TALKING, /* AnimFlags */
+			ONE_SECOND / 2, ONE_SECOND, /* FrameRate */
+			ONE_SECOND * 3, ONE_SECOND * 5, /* RestartRate */
+			(1 << 10), /* BlockMask */
+		},
+	  {             // 10 - zoomed left girl manipulating starmap
+			142, /* StartIndex */
+			7, /* NumFrames */
+			CIRCULAR_ANIM | WHEN_TALKING, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND * 3, ONE_SECOND * 5, /* RestartRate */
+			(1 << 9), /* BlockMask */
+		},
+	  {             // 11 - zoomed front girl breathing
+			149, /* StartIndex */
+			7, /* NumFrames */
+			CIRCULAR_ANIM | WHEN_TALKING, /* AnimFlags */
+			ONE_SECOND / 7, 0, /* FrameRate */
+			ONE_SECOND * 4, ONE_SECOND, /* RestartRate */
+			0, /* BlockMask */
+		},
+	},
+	{ /* AlienTransitionDesc */
+		70, /* StartIndex */
+		9, /* NumFrames */
+		WHEN_TALKING, /* AnimFlags */
+		ONE_SECOND / 30, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		79, /* StartIndex */
+		59, /* NumFrames */
+		TALK_INTRO, /* AnimFlags */
+		ONE_SECOND / 15, ONE_SECOND / 30, /* FrameRate */
+		ONE_SECOND / 12, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
+};
+
+static LOCDATA syreenhome_desc_4x =
+{
+	SYREENHOME_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	SYREEN_HOME_PMAP_ANIM, /* AlienFrame */
+	SYREEN_HOME_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_BOTTOM, /* AlienTextValign */
+	SYREEN_HOME_COLOR_MAP, /* AlienColorMap */
+	SYREEN_HOME_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	SYREEN_HOME_CONVERSATION_PHRASES, /* PlayerPhrases */
+	3, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+	  {             // 0 - blinking eyes
+			7, /* StartIndex */
+			2, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND / 10, ONE_SECOND * 5, /* RestartRate */
+			0, /* BlockMask */
+		},
+	  {             // 1 - left girl manipulating starmap
+			9, /* StartIndex */
+			9, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND * 3, ONE_SECOND * 5, /* RestartRate */
+			0, /* BlockMask */
+		},
+	  {             // 2 - right girl moving pieces
+			18, /* StartIndex */
+			6, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 5, ONE_SECOND / 5, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+	},
+	{ /* AlienTransitionDesc */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		1, /* StartIndex */
+		6, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 20, ONE_SECOND / 20, /* FrameRate */
+		ONE_SECOND / 12, ONE_SECOND / 20, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
+};
+
+static void
+ExitConversation (RESPONSE_REF R)
+{
+	(void) R; // satisfy compiler
+	NPCPhrase (TAKE_CARE);
+	
+	if(GET_GAME_STATE (SYREEN_WILL_GIVE_VESSEL))
+	{
+		BYTE mi, di, yi;
+		
+		mi = GLOBAL (GameClock.month_index);
+		SET_GAME_STATE (SYREEN_SHIP_MONTH, mi);
+		if ((di = GLOBAL (GameClock.day_index)) > 28)
+			di = 28;
+		SET_GAME_STATE (SYREEN_SHIP_DAY, di);
+		yi = (BYTE)(GLOBAL (GameClock.year_index) - START_YEAR) + 1;
+		SET_GAME_STATE (SYREEN_SHIP_YEAR, yi);
+		
+		ActivateStarShip (SYREEN_SHIP, 1);
+		SET_GAME_STATE (SYREEN_WILL_GIVE_VESSEL, 0);
+	}
+	
+	SET_GAME_STATE (BATTLE_SEGUE, 0);
+}
+
+
+static void
+AskMenu1 (RESPONSE_REF R)
+{	
+	SIZE i;
+	BOOLEAN ShipsReadySyreen = !((i = (GLOBAL (GameClock.year_index) - START_YEAR) - GET_GAME_STATE (SYREEN_SHIP_YEAR)) < 0
+									|| ((i == 0 && (i = GLOBAL (GameClock.month_index) - GET_GAME_STATE (SYREEN_SHIP_MONTH)) < 0)
+									|| (i == 0 && GLOBAL (GameClock.day_index) < GET_GAME_STATE (SYREEN_SHIP_DAY))));
+	
+	if (PLAYER_SAID (R, searching_for_shofixti))
+	{
+		NPCPhrase (NO_INFORMATION);
+		
+		if (ActivateStarShip (SYREEN_SHIP, FEASIBILITY_STUDY))
+		{
+			if (ShipsReadySyreen)
+			{
+				NPCPhrase (GIVE_VESSEL_1);
+				SET_GAME_STATE (SYREEN_WILL_GIVE_VESSEL, 1);
+			}
+		}
+		else
+			NPCPhrase (NO_ROOM_FOR_VESSEL);
+	}
+
+	else if (PLAYER_SAID (R, where_do_i_start))
+	{
+		NPCPhrase (REFUEL_AT_STARBASE);
+		
+		if (ActivateStarShip (SYREEN_SHIP, FEASIBILITY_STUDY))
+		{
+			if (ShipsReadySyreen)
+			{
+				NPCPhrase (GIVE_VESSEL_2);
+				SET_GAME_STATE (SYREEN_WILL_GIVE_VESSEL, 1);
+			}
+		}
+		else
+			NPCPhrase (NO_ROOM_FOR_VESSEL);
+	}
+		
+	Response (thats_all, ExitConversation);
+}
+
+static void
+Hospitality (RESPONSE_REF R)
+{	
+	if (PLAYER_SAID (R, got_drink))
+	{
+		NPCPhrase (ETHANOL_FLUIDS);
+	}
+	else if (PLAYER_SAID (R, no_seats))
+	{
+		NPCPhrase (LOTUS_POSITION);
+	}
+	else if (PLAYER_SAID (R, thanks_for_hospitality))
+	{
+		NPCPhrase (PLEASURE_OURS);
+	}
+	else if (PLAYER_SAID (R, ill_stand))
+	{
+		NPCPhrase (AS_YOU_WISH);
+	}
+
+	Response (searching_for_shofixti, AskMenu1);
+	Response (where_do_i_start, AskMenu1);
+	Response (thats_all, ExitConversation);
+}
+
+
+static void
+Intro (void)
+{
+	if (GET_GAME_STATE (SYREEN_MET) == 0)
+	{
+		NPCPhrase (SYREENHOME_GREETING1);
+		SET_GAME_STATE (SYREEN_MET, 1);
+	}
+	else
+		NPCPhrase (SYREENHOME_GREETING2);
+
+	Response (got_drink, Hospitality);
+	Response (no_seats, Hospitality);
+	Response (thanks_for_hospitality, Hospitality);
+	Response (ill_stand, Hospitality);
+}
+
+
+static COUNT
+uninit_syreenhome (void)
+{
+	return (0);
+}
+
+static void
+post_syreenhome_enc (void)
+{
+	// nothing defined so far
+}
+
+LOCDATA*
+init_syreenhome_comm (void)
+{
+	static LOCDATA syreenhome_desc;
+	LOCDATA *retval;
+
+	switch (RESOLUTION_FACTOR)
+	{
+	case 2:
+		syreenhome_desc = syreenhome_desc_4x;
+		break;
+	case 1:
+		syreenhome_desc = syreenhome_desc_4x;
+		break;
+	case 0:
+	default:
+		syreenhome_desc = syreenhome_desc_1x;
+		break;
+	}
+	
+	syreenhome_desc.init_encounter_func = Intro;
+	syreenhome_desc.post_encounter_func = post_syreenhome_enc;
+	syreenhome_desc.uninit_encounter_func = uninit_syreenhome;
+
+	syreenhome_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
+	syreenhome_desc.AlienTextBaseline.y = 100 << RESOLUTION_FACTOR;
+	syreenhome_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
+
+	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	retval = &syreenhome_desc;
+
+	return (retval);
+}
diff -ruNp src.orig/uqm/comm/talkpet/talkpet.c src/uqm/comm/talkpet/talkpet.c
--- src.orig/uqm/comm/talkpet/talkpet.c	2017-11-01 15:30:24 -0700
+++ src/uqm/comm/talkpet/talkpet.c	2017-11-01 15:31:01 -0700
@@ -28,6 +28,7 @@
 
 static LOCDATA talkpet_desc =
 {
+	TALKING_PET_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
diff -ruNp src.orig/uqm/comm/thradd/thraddc.c src/uqm/comm/thradd/thraddc.c
--- src.orig/uqm/comm/thradd/thraddc.c	2017-11-01 15:30:24 -0700
+++ src/uqm/comm/thradd/thraddc.c	2017-11-01 15:31:01 -0700
@@ -26,6 +26,7 @@
 
 static LOCDATA thradd_desc =
 {
+	THRADD_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -131,6 +132,11 @@ static LOCDATA thradd_desc =
 	NULL, NULL, NULL,
 	NULL,
 	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
 };
 
 static int
diff -ruNp src.orig/uqm/comm/transport/Makeinfo src/uqm/comm/transport/Makeinfo
--- src.orig/uqm/comm/transport/Makeinfo	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/transport/Makeinfo	2017-11-01 15:31:01 -0700
@@ -0,0 +1 @@
+uqm_CFILES="transportc.c"
\ No newline at end of file
diff -ruNp src.orig/uqm/comm/transport/resinst.h src/uqm/comm/transport/resinst.h
--- src.orig/uqm/comm/transport/resinst.h	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/transport/resinst.h	2017-11-01 15:31:01 -0700
@@ -0,0 +1,5 @@
+#define TRANSPORT_COLOR_MAP "comm.transport.colortable"
+#define TRANSPORT_PMAP_ANIM "comm.transport.graphics"
+#define TRANSPORT_FONT "comm.transport.font"
+#define TRANSPORT_CONVERSATION_PHRASES "comm.transport.dialogue"
+#define TRANSPORT_MUSIC "comm.transport.music"
diff -ruNp src.orig/uqm/comm/transport/strings.h src/uqm/comm/transport/strings.h
--- src.orig/uqm/comm/transport/strings.h	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/transport/strings.h	2017-11-01 15:31:01 -0700
@@ -0,0 +1,64 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _STRINGS_H
+#define _STRINGS_H
+
+enum
+{
+	NULL_PHRASE,
+	GREETINGS_1,
+	GREETINGS_2,
+	GREETINGS_3,
+	GREETINGS_4,
+	whats_up,
+	WAITING_FOR_LEAVE_1,
+	WAITING_FOR_LEAVE_2,
+	WAITING_FOR_LEAVE_3,
+	what_cargo,
+	CARGO_INIT,
+	CARGO_1,
+	CARGO_2,
+	CARGO_3,
+	CARGO_4,
+	CARGO_5,
+	CARGO_6,
+	CARGO_7,
+	CARGO_8,
+	CARGO_9,
+	CARGO_10,
+	CARGO_11,
+	CARGO_12,
+	LEAVING_1,
+	LEAVING_2,
+	HYPERSPACE_1,
+	HYPERSPACE_2,
+	ARRIVING_1,
+	ARRIVING_2,
+	ARRIVED_1,
+	ARRIVED_2,
+	AT_PROCYON_1,
+	AT_PROCYON_2,
+	whats_your_schedule,
+	SCHEDULE_1,
+	SCHEDULE_2,
+	good_bye_safe_trip,
+	GOOD_BYE,
+};
+
+#endif /* _STRINGS_H */
diff -ruNp src.orig/uqm/comm/transport/transportc.c src/uqm/comm/transport/transportc.c
--- src.orig/uqm/comm/transport/transportc.c	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/transport/transportc.c	2017-11-01 15:31:01 -0700
@@ -0,0 +1,447 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+// JMS 2010: -Completely new file for transport ship dialogue. Lot of randomly picked lines here.
+//			  When asking about cargo, the same ship can have many kinds of crap aboard then. Kind of buggy but funny :D
+
+#include "../commall.h"
+#include "resinst.h"
+#include "strings.h"
+
+#include "libs/mathlib.h"
+
+#include "uqm/build.h"
+#include "uqm/encount.h"
+// BW: for SOL/CHMMR_DEFINED, no longer included in commall.h
+
+
+static LOCDATA transport_desc_1x =
+{
+	TRANSPORT_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	TRANSPORT_PMAP_ANIM, /* AlienFrame */
+	TRANSPORT_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_TOP, /* AlienTextValign */
+	TRANSPORT_COLOR_MAP, /* AlienColorMap */
+	TRANSPORT_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	TRANSPORT_CONVERSATION_PHRASES, /* PlayerPhrases */
+	10, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{ /* Blink */
+			1, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			ONE_SECOND, (ONE_SECOND / 10) * 22, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Captain's "Picard Tug" */
+			11, /* StartIndex */
+			2, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 6, 0, /* FrameRate */
+			ONE_SECOND * 4, ONE_SECOND * 5, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Big Ceiling Monitor */
+			13, /* StartIndex */
+			125, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			ONE_SECOND * 1, ONE_SECOND * 4, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Small Monitor - left */
+			138, /* StartIndex */
+			94, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			ONE_SECOND * 1, ONE_SECOND * 2, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Small Monitor - Right */
+			232, /* StartIndex */
+			26, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			ONE_SECOND * 1, ONE_SECOND * 1, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Green Pulsing Stuff */
+			258, /* StartIndex */
+			18, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			0, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Back Wall Computer */
+			276, /* StartIndex */
+			12, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			0, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Guy in the Back */
+			288, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			(ONE_SECOND / 10) * 2, (ONE_SECOND / 10) * 13, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Woman's Left Arm */
+			291, /* StartIndex */
+			3, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			ONE_SECOND / 12, (ONE_SECOND / 12) * 15, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Woman's Right Arm */
+			294, /* StartIndex */
+			3, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			ONE_SECOND / 12, (ONE_SECOND / 12) * 15, /* RestartRate */
+			0, /* BlockMask */
+		},
+	},
+	{ /* AlienTransitionDesc */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		4, /* StartIndex */
+		7, /* NumFrames */
+		RANDOM_ANIM, /* AnimFlags */
+		ONE_SECOND / 12, ONE_SECOND / 15, /* FrameRate */
+		ONE_SECOND * 7 / 60, ONE_SECOND / 12, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
+};
+
+static LOCDATA transport_desc_4x =
+{
+	TRANSPORT_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	TRANSPORT_PMAP_ANIM, /* AlienFrame */
+	TRANSPORT_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_TOP, /* AlienTextValign */
+	TRANSPORT_COLOR_MAP, /* AlienColorMap */
+	TRANSPORT_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	TRANSPORT_CONVERSATION_PHRASES, /* PlayerPhrases */
+	7, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{ /* Blink */
+			1, /* StartIndex */
+			2, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			ONE_SECOND, (ONE_SECOND / 10) * 22, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Big Ceiling Monitor */
+			8, /* StartIndex */
+			40, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			ONE_SECOND * 1, ONE_SECOND * 4, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Small Monitor - left */
+			48, /* StartIndex */
+			68, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			ONE_SECOND * 1, ONE_SECOND * 2, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Small Monitor - Right */
+			116, /* StartIndex */
+			26, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			ONE_SECOND * 1, ONE_SECOND * 1, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Green Pulsing Stuff and girl */
+			142, /* StartIndex */
+			27, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			(ONE_SECOND / 10) * 2, (ONE_SECOND / 10) * 13, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Back Wall Computer */
+			169, /* StartIndex */
+			11, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 24, 0, /* FrameRate */
+			0, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Guy in the Back */
+			180, /* StartIndex */
+			5, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			(ONE_SECOND / 10) * 2, (ONE_SECOND / 10) * 13, /* RestartRate */
+			0, /* BlockMask */
+		},
+	},
+	{ /* AlienTransitionDesc */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		3, /* StartIndex */
+		5, /* NumFrames */
+		RANDOM_ANIM, /* AnimFlags */
+		ONE_SECOND / 12, ONE_SECOND / 15, /* FrameRate */
+		ONE_SECOND * 7 / 60, ONE_SECOND / 12, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
+};
+
+static void
+ExitConversation (RESPONSE_REF R)
+{
+	//	BYTE NumVisits;
+	(void) R; // satisfy compiler
+	
+	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	
+	NPCPhrase(GOOD_BYE);
+}
+
+static void
+TransportConversationMain (RESPONSE_REF R)
+{
+	BYTE NumVisits;
+	
+	if (PLAYER_SAID (R, whats_up))
+	{
+		COUNT phrase;
+		NumVisits = GET_GAME_STATE (TRANSPORT_SHIP_0_STATUS);
+		
+		switch (NumVisits)
+		{
+			case 0:
+				if(CurStarDescPtr->Index==SOL_DEFINED)
+				{
+					phrase=WAITING_FOR_LEAVE_1;
+					phrase+=(COUNT)TFB_Random () % 3;
+				}
+				else
+				{
+					phrase=ARRIVED_1;
+					phrase+=(COUNT)TFB_Random () % 2;
+				}
+				
+				NPCPhrase (phrase);
+				if(CurStarDescPtr->Index==CHMMR_DEFINED)
+				{
+					phrase=AT_PROCYON_1;
+					phrase+=(COUNT)TFB_Random () % 2;
+					NPCPhrase (phrase);
+				}
+				break;
+			case 1:
+				phrase=LEAVING_1;
+				phrase+=(COUNT)TFB_Random () % 2;
+				NPCPhrase (phrase);
+				break;
+			case 2:
+				phrase=HYPERSPACE_1;
+				phrase+=(COUNT)TFB_Random () % 2;
+				NPCPhrase (phrase);
+				break;
+			case 3:
+				phrase=HYPERSPACE_1;
+				phrase+=(COUNT)TFB_Random () % 2;
+				NPCPhrase (phrase);
+				break;
+			case 4:
+				phrase=ARRIVING_1;
+				phrase+=(COUNT)TFB_Random () % 2;
+				NPCPhrase (phrase);
+				break;
+		}
+		
+		DISABLE_PHRASE (whats_up);
+	}
+	
+	if (PLAYER_SAID (R, what_cargo))
+	{
+		COUNT phrase;
+		
+		phrase= CARGO_1 + (COUNT)TFB_Random () % 12;
+		NPCPhrase(CARGO_INIT);
+		NPCPhrase(phrase);
+		
+		DISABLE_PHRASE (what_cargo);
+	}
+	
+	if (PLAYER_SAID (R, whats_your_schedule))
+	{
+		COUNT phrase;
+		
+		phrase= SCHEDULE_1 + (COUNT)TFB_Random () % 2;
+		NPCPhrase(phrase);
+		
+		DISABLE_PHRASE (whats_your_schedule);
+	}
+	
+	if (PHRASE_ENABLED (whats_up))
+	{
+		Response (whats_up, TransportConversationMain);
+	}
+	
+	if (PHRASE_ENABLED (whats_your_schedule))
+	{
+		Response (whats_your_schedule, TransportConversationMain);
+	}
+	
+	if (PHRASE_ENABLED (what_cargo))
+	{
+		Response (what_cargo, TransportConversationMain);
+	}
+	
+	Response (good_bye_safe_trip, ExitConversation);
+}
+
+static void
+Intro (void)
+{
+	BYTE NumVisits;
+	
+	NumVisits = (COUNT)TFB_Random () % 4;
+	switch (NumVisits)
+	{
+		case 0:
+			NPCPhrase (GREETINGS_1);
+			break;
+		case 1:
+			NPCPhrase (GREETINGS_2);
+			break;
+		case 2:
+			NPCPhrase (GREETINGS_3);
+			break;
+		case 3:
+			NPCPhrase (GREETINGS_4);
+			break;
+	}
+	
+	TransportConversationMain ((RESPONSE_REF)0);
+
+}
+
+static COUNT
+uninit_transport (void)
+{
+	return (0);
+}
+
+static void
+post_transport_enc (void)
+{
+	// nothing defined so far
+}
+
+LOCDATA*
+init_transport_comm (void)
+{
+	LOCDATA *retval;
+	static LOCDATA transport_desc;
+
+	switch (RESOLUTION_FACTOR)
+	{
+	case 2:
+		transport_desc = transport_desc_4x;
+		break;
+	case 1:
+		transport_desc = transport_desc_4x;
+		break;
+	case 0:
+	default:
+		transport_desc = transport_desc_1x;
+		break;
+	}
+	
+	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	
+	transport_desc.init_encounter_func = Intro;
+	transport_desc.post_encounter_func = post_transport_enc;
+	transport_desc.uninit_encounter_func = uninit_transport;
+
+	transport_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
+	transport_desc.AlienTextBaseline.y = 0;
+	transport_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
+
+	retval = &transport_desc;
+	
+	return (retval);
+}
diff -ruNp src.orig/uqm/comm/umgah/umgahc.c src/uqm/comm/umgah/umgahc.c
--- src.orig/uqm/comm/umgah/umgahc.c	2017-11-01 15:30:24 -0700
+++ src/uqm/comm/umgah/umgahc.c	2017-11-01 15:31:02 -0700
@@ -25,6 +25,7 @@
 
 static LOCDATA umgah_desc =
 {
+	UMGAH_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -193,6 +194,11 @@ static LOCDATA umgah_desc =
 	NULL, NULL, NULL,
 	NULL,
 	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
 };
 
 static void
diff -ruNp src.orig/uqm/comm/urquan/urquanc.c src/uqm/comm/urquan/urquanc.c
--- src.orig/uqm/comm/urquan/urquanc.c	2017-11-01 15:30:24 -0700
+++ src/uqm/comm/urquan/urquanc.c	2017-11-01 15:31:02 -0700
@@ -22,6 +22,7 @@
 
 static LOCDATA urquan_desc =
 {
+	URQUAN_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -118,6 +119,11 @@ static LOCDATA urquan_desc =
 	NULL, NULL, NULL,
 	NULL,
 	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
 };
 
 static void
diff -ruNp src.orig/uqm/comm/utwig/utwigc.c src/uqm/comm/utwig/utwigc.c
--- src.orig/uqm/comm/utwig/utwigc.c	2017-11-01 15:30:24 -0700
+++ src/uqm/comm/utwig/utwigc.c	2017-11-01 15:31:02 -0700
@@ -26,6 +26,7 @@
 
 static LOCDATA utwig_desc =
 {
+	UTWIG_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -195,6 +196,11 @@ static LOCDATA utwig_desc =
 	NULL, NULL, NULL,
 	NULL,
 	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
 };
 
 static void
@@ -968,7 +974,7 @@ init_utwig_comm (void)
 	utwig_desc.uninit_encounter_func = uninit_utwig;
 
 	utwig_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
-	utwig_desc.AlienTextBaseline.y = 70;
+	utwig_desc.AlienTextBaseline.y = RES_SIS_SCALE(70);
 	utwig_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
 
 	if (GET_GAME_STATE (UTWIG_HAVE_ULTRON))
diff -ruNp src.orig/uqm/comm/vux/strings.h src/uqm/comm/vux/strings.h
--- src.orig/uqm/comm/vux/strings.h	2017-11-01 15:30:24 -0700
+++ src/uqm/comm/vux/strings.h	2017-11-01 15:31:02 -0700
@@ -22,108 +22,77 @@
 enum
 {
 	NULL_PHRASE,
-	ZEX_HELLO_1,
-	ZEX_HELLO_2,
-	ZEX_HELLO_3,
-	ZEX_HELLO_4,
-	FIGHT_OR_TRADE_1,
-	FIGHT_OR_TRADE_2,
-	what_you_do_here,
-	MY_MENAGERIE,
-	what_about_menagerie,
-	NEED_NEW_CREATURE,
-	what_about_creature,
-	ABOUT_CREATURE,
-	about_creature_again,
-	CREATURE_AGAIN,
-	i_have_beast,
-	GIVE_BEAST,
-	ok_take_beast,
-	FOOL_AIEE0,
-	FOOL_AIEE1,
-	why_trust_1,
-	TRUST_1,
-	why_trust_2,
-	TRUST_2,
-	why_trust_3,
-	TRUST_3,
-	why_dont_you_attack,
-	LIKE_YOU,
-	why_like_me,
-	LIKE_BECAUSE,
-	are_you_a_pervert,
-	CALL_ME_WHAT_YOU_WISH,
-	take_by_force,
-	PRECURSOR_DEVICE,
-	regardless,
-	THEN_FIGHT,
-	you_lied,
-	YUP_LIED,
-	kill_you,
-	FIGHT_AGAIN,
-	bye_zex,
-	GOODBYE_ZEX,
-	HOMEWORLD_HELLO_1,
-	HOMEWORLD_HELLO_2,
-	HOMEWORLD_HELLO_3,
-	HOMEWORLD_HELLO_4,
-	SPACE_HELLO_1,
-	SPACE_HELLO_2,
-	SPACE_HELLO_3,
-	SPACE_HELLO_4,
-	kill_you_squids_1,
-	kill_you_squids_2,
-	kill_you_squids_3,
-	kill_you_squids_4,
-	WE_FIGHT,
-	why_so_mean,
-	URQUAN_SLAVES,
-	deeper_reason,
-	OLD_INSULT,
-	if_we_apologize,
-	PROBABLY_NOT,
-	try_any_way,
-	NOPE,
-	APOLOGIZE_IN_SPACE,
+	VUX_GREETING1,
+	VUX_GREETING2,
+	greeting_1_who_you,
+	STRONG_STOMACH,
+	greeting_1_whats_like,
+	TAKE_GUESS,
+	SILENT,
+	greeting_1_to_apology,
+	KILL_LIKE_OTHERS,
+	whats_news,
+	DAX_INFORMATION,
+	sb1_science_teams,
+	sb2_neglect_mismanagement,
+	NOT_IDIOTS,
+	sb3_rethinking_position,
+	ARGUMENT_SUBJECT,
+	sb4_seriously_how_is,
+	RANT,
+	AFTER_RANT,
+	sb5_safe_under_shield,
+	SPITEFUL_VUX_1,
+	SPITEFUL_VUX_2,
+	sb6_okay_then,
 	apology_1,
-	NOT_ACCEPTED_1,
+	APOLOGY_1_ANSWER,
 	apology_2,
-	NOT_ACCEPTED_2,
+	APOLOGY_2_ANSWER,
 	apology_3,
-	NOT_ACCEPTED_3,
+	APOLOGY_3_ANSWER,
 	apology_4,
-	NOT_ACCEPTED_4,
-	apology_5,
-	NOT_ACCEPTED_5,
-	apology_6,
-	NOT_ACCEPTED_6,
-	apology_7,
-	NOT_ACCEPTED_7,
-	apology_8,
-	NOT_ACCEPTED_8,
-	apology_9,
-	NOT_ACCEPTED_9,
-	apology_10,
-	TRUTH,
-	whats_up_hostile,
-	GENERAL_INFO_HOSTILE_1,
-	GENERAL_INFO_HOSTILE_2,
-	GENERAL_INFO_HOSTILE_3,
-	GENERAL_INFO_HOSTILE_4,
-	cant_we_be_friends_1,
-	NEVER_UGLY_HUMANS_1,
-	cant_we_be_friends_2,
-	NEVER_UGLY_HUMANS_2,
-	cant_we_be_friends_3,
-	NEVER_UGLY_HUMANS_3,
-	cant_we_be_friends_4,
-	NEVER_UGLY_HUMANS_4,
-	bye_hostile_space,
-	GOODBYE_AND_DIE_HOSTILE_SPACE_1,
-	GOODBYE_AND_DIE_HOSTILE_SPACE_2,
-	GOODBYE_AND_DIE_HOSTILE_SPACE_3,
-	GOODBYE_AND_DIE_HOSTILE_SPACE_4,
-	OUT_TAKES,
+	APOLOGY_4_ANSWER,
+	a2apology_1,
+	A2APOLOGY_1_ANSWER,
+	a2apology_2,
+	A2APOLOGY_2_ANSWER,
+	a2apology_3,
+	A2APOLOGY_3_ANSWER,
+	a2apology_4,
+	A2APOLOGY_4_ANSWER,
+	a3apology_1,
+	A3APOLOGY_1_ANSWER,
+	a3apology_2,
+	A3APOLOGY_2_ANSWER,
+	a3apology_3,
+	A3APOLOGY_3_ANSWER,
+	a3apology_4,
+	A3APOLOGY_4_ANSWER,
+	a4apology_1,
+	A4APOLOGY_1_ANSWER,
+	a4apology_2,
+	A4APOLOGY_2_ANSWER,
+	a4apology_3,
+	A4APOLOGY_3_ANSWER,
+	a4apology_4,
+	A4APOLOGY_4_ANSWER,
+	a5apology_1,
+	A5APOLOGY_1_ANSWER,
+	a5apology_2,
+	A5APOLOGY_2_ANSWER,
+	a5apology_3,
+	A5APOLOGY_3_ANSWER,
+	a5apology_4,
+	A5APOLOGY_4_ANSWER,
+	a6apology_1,
+	A6APOLOGY_1_ANSWER,
+	a6apology_2,
+	A6APOLOGY_2_ANSWER,
+	a6apology_3,
+	A6APOLOGY_3_ANSWER,
+	goodbye_vux,
+	GOODBYE_EARTHLING,
 };
 
 #endif /* _STRINGS_H */
diff -ruNp src.orig/uqm/comm/vux/vuxc.c src/uqm/comm/vux/vuxc.c
--- src.orig/uqm/comm/vux/vuxc.c	2017-11-01 15:30:24 -0700
+++ src/uqm/comm/vux/vuxc.c	2017-11-01 15:31:02 -0700
@@ -22,6 +22,7 @@
 
 static LOCDATA vux_desc =
 {
+	VUX_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -198,563 +199,284 @@ static LOCDATA vux_desc =
 	NULL, NULL, NULL,
 	NULL,
 	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
 };
 
 static void
-CombatIsInevitable (RESPONSE_REF R)
-{
-	BYTE NumVisits;
+Intro (RESPONSE_REF R);
 
-	SET_GAME_STATE (BATTLE_SEGUE, 1);
 
-	if (PLAYER_SAID (R, ok_take_beast))
-	{
-		NPCPhrase (FOOL_AIEE0);
-		NPCPhrase (FOOL_AIEE1);
+static void
+ExitConversation (RESPONSE_REF R)
+{
+	(void) R; // satisfy compiler
+	NPCPhrase (GOODBYE_EARTHLING);
+	SET_GAME_STATE (BATTLE_SEGUE, 0);
+}
 
-		AlienTalkSegue (1);
-		XFormColorMap (GetColorMapAddress (
-				SetAbsColorMapIndex (CommData.AlienColorMap, 1)
-				), ONE_SECOND / 4);
-		AlienTalkSegue ((COUNT)~0);
-
-		SET_GAME_STATE (VUX_BEAST_ON_SHIP, 0);
-		SET_GAME_STATE (ZEX_IS_DEAD, 1);
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
-	}
-	else if (PLAYER_SAID (R, try_any_way))
-	{
-		NPCPhrase (NOPE);
+static void
+ExitConversationSilent (RESPONSE_REF R)
+{
+	(void) R; // satisfy compiler
+	NPCPhrase (SILENT);
+	SET_GAME_STATE (BATTLE_SEGUE, 0);	
+}
 
-		SET_GAME_STATE (VUX_STACK_1, 4);
-	}
-	else if (PLAYER_SAID (R, kill_you_squids_1)
-			|| PLAYER_SAID (R, kill_you_squids_2)
-			|| PLAYER_SAID (R, kill_you_squids_3)
-			|| PLAYER_SAID (R, kill_you_squids_4))
-	{
-		NPCPhrase (WE_FIGHT);
 
-		NumVisits = GET_GAME_STATE (VUX_STACK_2) + 1;
-		if (NumVisits <= 3)
-		{
-			SET_GAME_STATE (VUX_STACK_2, NumVisits);
-		}
-	}
-	else if (PLAYER_SAID (R, cant_we_be_friends_1)
-			|| PLAYER_SAID (R, cant_we_be_friends_2)
-			|| PLAYER_SAID (R, cant_we_be_friends_3)
-			|| PLAYER_SAID (R, cant_we_be_friends_4))
-	{
-		NumVisits = GET_GAME_STATE (VUX_STACK_3);
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (NEVER_UGLY_HUMANS_1);
-				break;
-			case 1:
-				NPCPhrase (NEVER_UGLY_HUMANS_2);
-				break;
-			case 2:
-				NPCPhrase (NEVER_UGLY_HUMANS_3);
-				break;
-			case 3:
-				NPCPhrase (NEVER_UGLY_HUMANS_4);
-				--NumVisits;
-				break;
-		}
-		SET_GAME_STATE (VUX_STACK_3, NumVisits);
-	}
-	else if (PLAYER_SAID (R, bye_hostile_space))
-	{
-		NumVisits = GET_GAME_STATE (VUX_STACK_4);
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (GOODBYE_AND_DIE_HOSTILE_SPACE_1);
-				break;
-			case 1:
-				NPCPhrase (GOODBYE_AND_DIE_HOSTILE_SPACE_2);
-				break;
-			case 2:
-				NPCPhrase (GOODBYE_AND_DIE_HOSTILE_SPACE_3);
-				break;
-			case 3:
-				NPCPhrase (GOODBYE_AND_DIE_HOSTILE_SPACE_4);
-				--NumVisits;
-				break;
-		}
-		SET_GAME_STATE (VUX_STACK_4, NumVisits);
-	}
-	else if (PLAYER_SAID (R, bye_zex))
-	{
-		NPCPhrase (GOODBYE_ZEX);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
-	}
-	else
-	{
-		NumVisits = GET_GAME_STATE (VUX_STACK_1);
-		switch (NumVisits++)
-		{
-			case 4:
-				NPCPhrase (NOT_ACCEPTED_1);
-				break;
-			case 5:
-				NPCPhrase (NOT_ACCEPTED_2);
-				break;
-			case 6:
-				NPCPhrase (NOT_ACCEPTED_3);
-				break;
-			case 7:
-				NPCPhrase (NOT_ACCEPTED_4);
-				break;
-			case 8:
-				NPCPhrase (NOT_ACCEPTED_5);
-				break;
-			case 9:
-				NPCPhrase (NOT_ACCEPTED_6);
-				break;
-			case 10:
-				NPCPhrase (NOT_ACCEPTED_7);
-				break;
-			case 11:
-				NPCPhrase (NOT_ACCEPTED_8);
-				break;
-			case 12:
-				NPCPhrase (NOT_ACCEPTED_9);
-				break;
-			case 13:
-				NPCPhrase (TRUTH);
-				break;
-		}
-		SET_GAME_STATE (VUX_STACK_1, NumVisits);
-	}
+static void
+ApologyMenu6 (RESPONSE_REF R)
+{	
+	if (PLAYER_SAID (R, a5apology_3))
+		NPCPhrase (A5APOLOGY_3_ANSWER);
+	
+	Response (a6apology_1, Intro);
+	Response (a6apology_2, Intro);
+	Response (a6apology_3, Intro);
 }
 
 static void
-Menagerie (RESPONSE_REF R)
-{
-	BYTE i, LastStack;
-	RESPONSE_REF pStr[3];
+ApologyMenu5 (RESPONSE_REF R)
+{	
+	if (PLAYER_SAID (R, a4apology_1))
+		NPCPhrase (A4APOLOGY_1_ANSWER);
+	if (PLAYER_SAID (R, a4apology_2))
+		NPCPhrase (A4APOLOGY_2_ANSWER);
+	
+	Response (a5apology_1, Intro);
+	Response (a5apology_2, Intro);
+	Response (a5apology_3, ApologyMenu6);
+	Response (a5apology_4, Intro);
+}
 
-	if (PLAYER_SAID (R, i_have_beast)
-			|| PLAYER_SAID (R, why_trust_1)
-			|| PLAYER_SAID (R, why_trust_2)
-			|| PLAYER_SAID (R, why_trust_3))
-	{
-		if (PLAYER_SAID (R, i_have_beast))
-			NPCPhrase (GIVE_BEAST);
-		else if (PLAYER_SAID (R, why_trust_1))
-		{
-			NPCPhrase (TRUST_1);
-
-			DISABLE_PHRASE (why_trust_1);
-		}
-		else if (PLAYER_SAID (R, why_trust_2))
-		{
-			NPCPhrase (TRUST_2);
-
-			DISABLE_PHRASE (why_trust_2);
-		}
-		else if (PLAYER_SAID (R, why_trust_3))
-		{
-			NPCPhrase (TRUST_3);
-
-			DISABLE_PHRASE (why_trust_3);
-		}
-
-		if (PHRASE_ENABLED (why_trust_1))
-			Response (why_trust_1, Menagerie);
-		else if (PHRASE_ENABLED (why_trust_2))
-			Response (why_trust_2, Menagerie);
-		else if (PHRASE_ENABLED (why_trust_3))
-			Response (why_trust_3, Menagerie);
-		Response (ok_take_beast, CombatIsInevitable);
-	}
-	else if (PLAYER_SAID (R, kill_you))
-	{
-		NPCPhrase (FIGHT_AGAIN);
+static void
+ApologyMenu4 (RESPONSE_REF R)
+{	
+	if (PLAYER_SAID (R, a3apology_1))
+		NPCPhrase (A3APOLOGY_1_ANSWER);
+	if (PLAYER_SAID (R, a3apology_4))
+		NPCPhrase (A3APOLOGY_4_ANSWER);
+	
+	Response (a4apology_1, ApologyMenu5);
+	Response (a4apology_2, ApologyMenu5);
+	Response (a4apology_3, Intro);
+	Response (a4apology_4, Intro);
+}
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
-	}
-	else if (PLAYER_SAID (R, regardless))
-	{
-		NPCPhrase (THEN_FIGHT);
+static void
+ApologyMenu3 (RESPONSE_REF R)
+{	
+	if (PLAYER_SAID (R, a2apology_2))
+		NPCPhrase (A2APOLOGY_2_ANSWER);
+	if (PLAYER_SAID (R, a2apology_3))
+		NPCPhrase (A2APOLOGY_3_ANSWER);
+	
+	Response (a3apology_1, ApologyMenu4);
+	Response (a3apology_2, Intro);
+	Response (a3apology_3, Intro);
+	Response (a3apology_4, ApologyMenu4);
+}
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
-		SET_GAME_STATE (ZEX_STACK_3, 2);
-		SET_GAME_STATE (ZEX_VISITS, 0);
-	}
-	else
-	{
-		LastStack = 0;
-		pStr[0] = pStr[1] = pStr[2] = 0;
-		if (R == 0)
-		{
-			BYTE NumVisits;
-
-			NumVisits = GET_GAME_STATE (ZEX_VISITS);
-			if (GET_GAME_STATE (ZEX_STACK_3) >= 2)
-			{
-				switch (NumVisits++)
-				{
-					case 0:
-						NPCPhrase (FIGHT_OR_TRADE_1);
-						break;
-					case 1:
-						NPCPhrase (FIGHT_OR_TRADE_2);
-						--NumVisits;
-						break;
-				}
-			}
-			else
-			{
-				switch (NumVisits++)
-				{
-					case 0:
-						NPCPhrase (ZEX_HELLO_1);
-						break;
-					case 1:
-						NPCPhrase (ZEX_HELLO_2);
-						break;
-					case 2:
-						NPCPhrase (ZEX_HELLO_3);
-						break;
-					case 3:
-						NPCPhrase (ZEX_HELLO_4);
-						--NumVisits;
-						break;
-				}
-			}
-			SET_GAME_STATE (ZEX_VISITS, NumVisits);
-		}
-		else if (PLAYER_SAID (R, what_you_do_here))
-		{
-			NPCPhrase (MY_MENAGERIE);
-
-			SET_GAME_STATE (ZEX_STACK_1, 1);
-		}
-		else if (PLAYER_SAID (R, what_about_menagerie))
-		{
-			NPCPhrase (NEED_NEW_CREATURE);
-
-			SET_GAME_STATE (ZEX_STACK_1, 2);
-		}
-		else if (PLAYER_SAID (R, what_about_creature))
-		{
-			NPCPhrase (ABOUT_CREATURE);
-
-			SET_GAME_STATE (KNOW_ZEX_WANTS_MONSTER, 1);
-			SET_GAME_STATE (ZEX_STACK_1, 3);
-
-			R = about_creature_again;
-			DISABLE_PHRASE (what_about_creature);
-		}
-		else if (PLAYER_SAID (R, about_creature_again))
-		{
-			NPCPhrase (CREATURE_AGAIN);
-
-			DISABLE_PHRASE (about_creature_again);
-		}
-		else if (PLAYER_SAID (R, why_dont_you_attack))
-		{
-			NPCPhrase (LIKE_YOU);
-
-			LastStack = 1;
-			SET_GAME_STATE (ZEX_STACK_2, 1);
-		}
-		else if (PLAYER_SAID (R, why_like_me))
-		{
-			NPCPhrase (LIKE_BECAUSE);
-
-			LastStack = 1;
-			SET_GAME_STATE (ZEX_STACK_2, 2);
-		}
-		else if (PLAYER_SAID (R, are_you_a_pervert))
-		{
-			NPCPhrase (CALL_ME_WHAT_YOU_WISH);
-
-			SET_GAME_STATE (ZEX_STACK_2, 3);
-		}
-		else if (PLAYER_SAID (R, take_by_force))
-		{
-			NPCPhrase (PRECURSOR_DEVICE);
-
-			LastStack = 2;
-			SET_GAME_STATE (ZEX_STACK_3, 1);
-		}
-		else if (PLAYER_SAID (R, you_lied))
-		{
-			NPCPhrase (YUP_LIED);
-
-			LastStack = 2;
-			SET_GAME_STATE (ZEX_STACK_3, 3);
-		}
-
-		if (GET_GAME_STATE (KNOW_ZEX_WANTS_MONSTER)
-				&& GET_GAME_STATE (VUX_BEAST_ON_SHIP))
-			pStr[0] = i_have_beast;
-		else
-		{
-			switch (GET_GAME_STATE (ZEX_STACK_1))
-			{
-				case 0:
-					pStr[0] = what_you_do_here;
-					break;
-				case 1:
-					pStr[0] = what_about_menagerie;
-					break;
-				case 2:
-					pStr[0] = what_about_creature;
-					break;
-				case 3:
-					if (PHRASE_ENABLED (about_creature_again))
-						pStr[0] = about_creature_again;
-					break;
-			}
-		}
-		switch (GET_GAME_STATE (ZEX_STACK_2))
-		{
-			case 0:
-				pStr[1] = why_dont_you_attack;
-				break;
-			case 1:
-				pStr[1] = why_like_me;
-				break;
-			case 2:
-				pStr[1] = are_you_a_pervert;
-				break;
-		}
-		switch (GET_GAME_STATE (ZEX_STACK_3))
-		{
-			case 0:
-				pStr[2] = take_by_force;
-				break;
-			case 1:
-				pStr[2] = regardless;
-				break;
-			case 2:
-				pStr[2] = you_lied;
-				break;
-			case 3:
-				pStr[2] = kill_you;
-				break;
-		}
-
-		if (pStr[LastStack])
-			Response (pStr[LastStack], Menagerie);
-		for (i = 0; i < 3; ++i)
-		{
-			if (i != LastStack && pStr[i])
-				Response (pStr[i], Menagerie);
-		}
-		Response (bye_zex, CombatIsInevitable);
-	}
+static void
+ApologyMenu2 (RESPONSE_REF R)
+{	
+	if (PLAYER_SAID (R, apology_1))
+		NPCPhrase (APOLOGY_1_ANSWER);
+	if (PLAYER_SAID (R, apology_2))
+		NPCPhrase (APOLOGY_2_ANSWER);
+	if (PLAYER_SAID (R, apology_3))
+		NPCPhrase (APOLOGY_3_ANSWER);
+	
+	Response (a2apology_1, Intro);
+	Response (a2apology_2, ApologyMenu3);
+	Response (a2apology_3, ApologyMenu3);
+	Response (a2apology_4, ExitConversationSilent);
 }
 
 static void
-NormalVux (RESPONSE_REF R)
-{
-	if (PLAYER_SAID (R, why_so_mean))
+ApologyMenu1 (RESPONSE_REF R)
+{	
+	if (PLAYER_SAID (R, greeting_1_to_apology))
 	{
-		NPCPhrase (URQUAN_SLAVES);
+		if (GET_GAME_STATE (VUX_APOLOGY_TRIED) == 0)
+			NPCPhrase (KILL_LIKE_OTHERS);
+		else
+			NPCPhrase (SILENT);
+		
+		SET_GAME_STATE (VUX_APOLOGY_TRIED, 1);
+		DISABLE_PHRASE (greeting_1_to_apology);
+	}
+	
+	Response (apology_1, ApologyMenu2);
+	Response (apology_2, ApologyMenu2);
+	Response (apology_3, ApologyMenu2);
+	Response (apology_4, Intro);
+}
 
-		SET_GAME_STATE (VUX_STACK_1, 1);
-	}
-	else if (PLAYER_SAID (R, deeper_reason))
-	{
-		NPCPhrase (OLD_INSULT);
 
-		SET_GAME_STATE (VUX_STACK_1, 2);
-	}
-	else if (PLAYER_SAID (R, if_we_apologize))
+static void
+StarBaseMenu (RESPONSE_REF R)
+{	
+	static BYTE spiteful_answers = 0;
+	
+	/* Alien speech */
+	if (PLAYER_SAID (R, greeting_1_whats_like))
 	{
-		NPCPhrase (PROBABLY_NOT);
-
-		SET_GAME_STATE (VUX_STACK_1, 3);
+		NPCPhrase (TAKE_GUESS);
+		DISABLE_PHRASE (greeting_1_whats_like);
 	}
-	else if (PLAYER_SAID (R, whats_up_hostile))
+	
+	else if (PLAYER_SAID (R, sb1_science_teams))
 	{
-		BYTE NumVisits;
-
-		NumVisits = GET_GAME_STATE (VUX_INFO);
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (GENERAL_INFO_HOSTILE_1);
-				break;
-			case 1:
-				NPCPhrase (GENERAL_INFO_HOSTILE_2);
-				break;
-			case 2:
-				NPCPhrase (GENERAL_INFO_HOSTILE_3);
-				break;
-			case 3:
-				NPCPhrase (GENERAL_INFO_HOSTILE_4);
-				--NumVisits;
-				break;
-		}
-		SET_GAME_STATE (VUX_INFO, NumVisits);
-
-		DISABLE_PHRASE (whats_up_hostile);
+		NPCPhrase (SILENT);
+		DISABLE_PHRASE (sb1_science_teams);
 	}
-
-	switch (GET_GAME_STATE (VUX_STACK_1))
+	
+	else if (PLAYER_SAID (R, sb2_neglect_mismanagement))
 	{
-		case 0:
-			Response (why_so_mean, NormalVux);
-			break;
-		case 1:
-			Response (deeper_reason, NormalVux);
-			break;
-		case 2:
-			Response (if_we_apologize, NormalVux);
-			break;
-		case 3:
-			Response (try_any_way, CombatIsInevitable);
-			break;
-		case 4:
-			Response (apology_1, CombatIsInevitable);
-			break;
-		case 5:
-			Response (apology_2, CombatIsInevitable);
-			break;
-		case 6:
-			Response (apology_3, CombatIsInevitable);
-			break;
-		case 7:
-			Response (apology_4, CombatIsInevitable);
-			break;
-		case 8:
-			Response (apology_5, CombatIsInevitable);
-			break;
-		case 9:
-			Response (apology_6, CombatIsInevitable);
-			break;
-		case 10:
-			Response (apology_7, CombatIsInevitable);
-			break;
-		case 11:
-			Response (apology_8, CombatIsInevitable);
-			break;
-		case 12:
-			Response (apology_9, CombatIsInevitable);
-			break;
-		case 13:
-			Response (apology_10, CombatIsInevitable);
-			break;
+		NPCPhrase (NOT_IDIOTS);
+		DISABLE_PHRASE (sb2_neglect_mismanagement);
 	}
-
-	switch (GET_GAME_STATE (VUX_STACK_2))
+	
+	else if (PLAYER_SAID (R, sb3_rethinking_position))
 	{
-		case 0:
-			Response (kill_you_squids_1, CombatIsInevitable);
-			break;
-		case 1:
-			Response (kill_you_squids_2, CombatIsInevitable);
-			break;
-		case 2:
-			Response (kill_you_squids_3, CombatIsInevitable);
-			break;
-		case 3:
-			Response (kill_you_squids_4, CombatIsInevitable);
-			break;
+		NPCPhrase (ARGUMENT_SUBJECT);
+		DISABLE_PHRASE (sb3_rethinking_position);
 	}
-
-	if (PHRASE_ENABLED (whats_up_hostile))
+	
+	else if (PLAYER_SAID (R, sb4_seriously_how_is))
 	{
-		Response (whats_up_hostile, NormalVux);
+		if (GET_GAME_STATE (VUX_RANT_HEARD) == 0)
+			NPCPhrase (RANT);
+		else
+			NPCPhrase (AFTER_RANT);
+		
+		SET_GAME_STATE (VUX_RANT_HEARD, 1);
+		DISABLE_PHRASE (sb4_seriously_how_is);
 	}
-
-	if (GET_GAME_STATE (VUX_STACK_1) > 13)
+	
+	else if (PLAYER_SAID (R, sb5_safe_under_shield))
 	{
-		switch (GET_GAME_STATE (VUX_STACK_3))
-		{
-			case 0:
-				Response (cant_we_be_friends_1, CombatIsInevitable);
-				break;
-			case 1:
-				Response (cant_we_be_friends_2, CombatIsInevitable);
-				break;
-			case 2:
-				Response (cant_we_be_friends_3, CombatIsInevitable);
-				break;
-			case 3:
-				Response (cant_we_be_friends_4, CombatIsInevitable);
-				break;
-		}
-	}
+		if (spiteful_answers)
+			NPCPhrase (SPITEFUL_VUX_2);
+		else
+			NPCPhrase (SPITEFUL_VUX_1);
+		
+		DISABLE_PHRASE (sb5_safe_under_shield);
+			
+		spiteful_answers++;
+		spiteful_answers %= 2;
+	}
+
+	/* Human speech options */
+    if (PHRASE_ENABLED (sb1_science_teams))
+		Response (sb1_science_teams, StarBaseMenu);
+	
+	if (PHRASE_ENABLED (sb2_neglect_mismanagement))
+		Response (sb2_neglect_mismanagement, StarBaseMenu);
+	
+	if (PHRASE_ENABLED (sb3_rethinking_position))
+		Response (sb3_rethinking_position, StarBaseMenu);
+	
+	if (!(PHRASE_ENABLED (sb1_science_teams)) && !(PHRASE_ENABLED (sb2_neglect_mismanagement)) 
+		&& !(PHRASE_ENABLED (sb3_rethinking_position)) && PHRASE_ENABLED (sb4_seriously_how_is))
+		Response (sb4_seriously_how_is, StarBaseMenu);
+	
+	if (PHRASE_ENABLED (sb5_safe_under_shield) && (GET_GAME_STATE (VUX_RANT_HEARD) == 1))
+		Response (sb5_safe_under_shield, StarBaseMenu);
 
-	Response (bye_hostile_space, CombatIsInevitable);
+	Response (sb6_okay_then, Intro);
 }
 
+
+
 static void
-Intro (void)
+Intro (RESPONSE_REF R)
 {
-	if (LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
+	/* Alien speech */
+	if (PLAYER_SAID (R, greeting_1_who_you))
 	{
-		NPCPhrase (OUT_TAKES);
-
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
-		return;
+		NPCPhrase (STRONG_STOMACH);
+		SET_GAME_STATE (VUX_MET, 1);
 	}
+	
+	else if (PLAYER_SAID (R, a2apology_1))
+		NPCPhrase (A2APOLOGY_1_ANSWER);
+	
+	else if (PLAYER_SAID (R, apology_4))
+		NPCPhrase (APOLOGY_4_ANSWER);
+	
+	else if (PLAYER_SAID (R, a3apology_2))
+		NPCPhrase (A3APOLOGY_2_ANSWER);
+	
+	else if (PLAYER_SAID (R, a3apology_3))
+		NPCPhrase (A3APOLOGY_3_ANSWER);
+	
+	else if (PLAYER_SAID (R, a4apology_3))
+		NPCPhrase (A4APOLOGY_3_ANSWER);
+	
+	else if (PLAYER_SAID (R, a4apology_4))
+		NPCPhrase (A4APOLOGY_4_ANSWER);
+	
+	else if (PLAYER_SAID (R, a5apology_1))
+		NPCPhrase (A5APOLOGY_1_ANSWER);
+	
+	else if (PLAYER_SAID (R, a5apology_2))
+		NPCPhrase (A5APOLOGY_2_ANSWER);
+	
+	else if (PLAYER_SAID (R, a5apology_4))
+		NPCPhrase (A5APOLOGY_4_ANSWER);
+	
+	else if (PLAYER_SAID (R, a6apology_1))
+		NPCPhrase (A6APOLOGY_1_ANSWER);
+	
+	else if (PLAYER_SAID (R, a6apology_2))
+		NPCPhrase (A6APOLOGY_2_ANSWER);
+	
+	else if (PLAYER_SAID (R, a6apology_3))
+		NPCPhrase (A6APOLOGY_3_ANSWER);
+	
+	else if (PLAYER_SAID (R, whats_news))
+	{
+		NPCPhrase (DAX_INFORMATION);
+		DISABLE_PHRASE (whats_news);
+	}
+	
+	else if (PLAYER_SAID (R, sb6_okay_then))
+		NPCPhrase (SILENT);
+	
+	/* Human speech options */
+	if (PHRASE_ENABLED (greeting_1_who_you) && GET_GAME_STATE (VUX_MET) == 0)
+		Response (greeting_1_who_you, Intro);
+	
+	if (PHRASE_ENABLED (greeting_1_whats_like))
+		Response (greeting_1_whats_like, StarBaseMenu);
+	
+	if (PHRASE_ENABLED (greeting_1_to_apology))
+		Response (greeting_1_to_apology, ApologyMenu1);
+	
+	if (PHRASE_ENABLED (whats_news))
+		Response (whats_news, Intro);
+	
+	Response (goodbye_vux, ExitConversation);
+}
 
-	if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 6))
-	{
-		Menagerie ((RESPONSE_REF)0);
-	}
+static void
+StartComm (void)
+{
+	if (GET_GAME_STATE (VUX_MET) == 0)
+		NPCPhrase (VUX_GREETING1);
 	else
-	{
-		BYTE NumVisits;
+		NPCPhrase (VUX_GREETING2);
 
-		if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 7))
-		{
-			NumVisits = GET_GAME_STATE (VUX_HOME_VISITS);
-			switch (NumVisits++)
-			{
-				case 0:
-					NPCPhrase (HOMEWORLD_HELLO_1);
-					break;
-				case 1:
-					NPCPhrase (HOMEWORLD_HELLO_2);
-					break;
-				case 2:
-					NPCPhrase (HOMEWORLD_HELLO_3);
-					break;
-				case 3:
-					NPCPhrase (HOMEWORLD_HELLO_4);
-					--NumVisits;
-					break;
-			}
-			SET_GAME_STATE (VUX_HOME_VISITS, NumVisits);
-		}
-		else
-		{
-			NumVisits = GET_GAME_STATE (VUX_VISITS);
-			switch (NumVisits++)
-			{
-				case 0:
-					NPCPhrase (SPACE_HELLO_1);
-					break;
-				case 1:
-					NPCPhrase (SPACE_HELLO_2);
-					break;
-				case 2:
-					NPCPhrase (SPACE_HELLO_3);
-					break;
-				case 3:
-					NPCPhrase (SPACE_HELLO_4);
-					--NumVisits;
-					break;
-			}
-			SET_GAME_STATE (VUX_VISITS, NumVisits);
-		}
-
-		NormalVux ((RESPONSE_REF)0);
-	}
+	Intro (0);
 }
 
+
 static COUNT
 uninit_vux (void)
 {
@@ -772,24 +494,15 @@ init_vux_comm (void)
 {
 	LOCDATA *retval;
 
-	vux_desc.init_encounter_func = Intro;
+	vux_desc.init_encounter_func = StartComm;
 	vux_desc.post_encounter_func = post_vux_enc;
 	vux_desc.uninit_encounter_func = uninit_vux;
 
-	vux_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1)
-			+ (SIS_TEXT_WIDTH >> 2);
+	vux_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1) + (SIS_TEXT_WIDTH >> 2);
 	vux_desc.AlienTextBaseline.y = 0;
 	vux_desc.AlienTextWidth = (SIS_TEXT_WIDTH - 16) >> 1;
 
-	if ((GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 6))
-			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
-	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
-	}
-	else
-	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
-	}
+	SET_GAME_STATE (BATTLE_SEGUE, 0);
 	retval = &vux_desc;
 
 	return (retval);
diff -ruNp src.orig/uqm/comm/yehat/strings.h src/uqm/comm/yehat/strings.h
--- src.orig/uqm/comm/yehat/strings.h	2017-11-01 15:30:24 -0700
+++ src/uqm/comm/yehat/strings.h	2017-11-01 15:31:02 -0700
@@ -22,81 +22,27 @@
 enum
 {
 	NULL_PHRASE,
-	HOMEWORLD_HELLO_1,
-	HOMEWORLD_HELLO_2,
-	whats_up_homeworld,
-	GENERAL_INFO_HOMEWORLD_1,
-	GENERAL_INFO_HOMEWORLD_2,
-	i_demand_you_ally_homeworld0,
-	i_demand_you_ally_homeworld1,
-	i_demand_you_ally_homeworld2,
-	i_demand_you_ally_homeworld3,
-	ENEMY_MUST_DIE,
-	at_least_help_us_homeworld,
-	NO_HELP_ENEMY,
-	give_info,
-	NO_INFO_FOR_ENEMY,
-	what_about_pkunk_royalist,
-	PKUNK_ABSORBED_ROYALIST,
-	HATE_PKUNK_ROYALIST,
-	bye_homeworld,
-	GOODBYE_AND_DIE_HOMEWORLD,
-	SPACE_HELLO_1,
-	SPACE_HELLO_2,
-	SPACE_HELLO_3,
-	SPACE_HELLO_4,
-	whats_up_space_1,
-	GENERAL_INFO_SPACE_1,
-	whats_up_space_2,
-	GENERAL_INFO_SPACE_2,
-	whats_up_space_3,
-	GENERAL_INFO_SPACE_3,
-	whats_up_space_4,
-	GENERAL_INFO_SPACE_4,
-	i_demand_you_ally_space0,
-	i_demand_you_ally_space1,
-	i_demand_you_ally_space2,
-	i_demand_you_ally_space3,
-	WE_CANNOT_1,
-	obligation,
-	WE_CANNOT_2,
-	at_least_help_us_space,
-	SORRY_CANNOT,
-	dishonor,
-	HERES_A_HINT,
-	what_about_pkunk_space,
-	PKUNK_ABSORBED_SPACE,
-	HATE_PKUNK_SPACE,
-	bye_space,
-	GO_IN_PEACE,
-	GOODBYE_AND_DIE_SPACE,
-	shofixti_alive_1,
-	shofixti_alive_2,
-	SEND_HIM_OVER_1,
-	SEND_HIM_OVER_2,
-	not_here,
-	not_send,
-	JUST_A_TRICK_1,
-	JUST_A_TRICK_2,
-	ok_send,
-	WE_REVOLT,
-	ROYALIST_SPACE_HELLO_1,
-	ROYALIST_SPACE_HELLO_2,
-	ROYALIST_HOMEWORLD_HELLO_1,
-	ROYALIST_HOMEWORLD_HELLO_2,
-	how_is_rebellion,
-	ROYALIST_REBELLION_1,
-	ROYALIST_REBELLION_2,
-	sorry_about_revolution,
-	ALL_YOUR_FAULT,
-	bye_royalist,
-	GOODBYE_AND_DIE_ROYALIST,
-	name_1,
-	name_2,
-	name_3,
-	name_40,
-	name_41,
-	OUT_TAKES,
+	YEHAT_GREETING1,
+	hail_yehat,
+	what_up,
+	must_scoot,
+	WHY_ARE_YOU_HERE1,
+	WHY_ARE_YOU_HERE2,
+	WHY_CHMMR_STARSHIP,
+	investigating_precursors,
+	PLEASED_TO_SEE_ALLY,
+	reinstate_veepneep,
+	BAD_HUMOUR,
+	how_are_you,
+	YEHAT_DOING_GOOD,
+	how_are_shofixti,
+	SHOFIXTI_INFO,
+	how_are_pkunk,
+	PKUNK_INFORMATION,
+	more_news,
+	CHMMR_INFO,
+	GOODBYE_EARTHLING
+
 };
 
 #endif /* _STRINGS_H */
diff -ruNp src.orig/uqm/comm/yehat/yehatc.c src/uqm/comm/yehat/yehatc.c
--- src.orig/uqm/comm/yehat/yehatc.c	2017-11-01 15:30:24 -0700
+++ src/uqm/comm/yehat/yehatc.c	2017-11-01 15:31:02 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: Yeaht no longer are hostile upon encountering.
+
 #include "../commall.h"
 #include "resinst.h"
 #include "strings.h"
@@ -25,8 +27,9 @@
 #include "libs/mathlib.h"
 
 
-static LOCDATA yehat_desc =
+static LOCDATA yehat_desc_1x =
 {
+	YEHAT_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -69,7 +72,7 @@ static LOCDATA yehat_desc =
 			YOYO_ANIM, /* AnimFlags */
 			ONE_SECOND / 20, 0, /* FrameRate */
 			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
-			(1 << 4) | (1 << 14),
+			(1 << 5) | (1 << 14),
 		},
 		{
 			13, /* StartIndex */
@@ -85,7 +88,7 @@ static LOCDATA yehat_desc =
 			YOYO_ANIM, /* AnimFlags */
 			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
 			ONE_SECOND * 6, ONE_SECOND * 3,/* RestartRate */
-			(1 << 2) | (1 << 14),
+			0,
 		},
 		{
 			21, /* StartIndex */
@@ -93,7 +96,7 @@ static LOCDATA yehat_desc =
 			YOYO_ANIM, /* AnimFlags */
 			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
 			ONE_SECOND * 6, ONE_SECOND * 3,/* RestartRate */
-			(1 << 3),
+			(1 << 2) | (1 << 3) | (1 << 14),
 		},
 		{ /* right arm-wing rising; front guy */
 			26, /* StartIndex */
@@ -165,7 +168,7 @@ static LOCDATA yehat_desc =
 			YOYO_ANIM | WAIT_TALKING, /* AnimFlags */
 			ONE_SECOND / 30, 0, /* FrameRate */
 			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
-			(1 << 2) | (1 << 4),
+			(1 << 2) | (1 << 5),
 		},
 	},
 	{ /* AlienTransitionDesc - empty */
@@ -189,463 +192,438 @@ static LOCDATA yehat_desc =
 	NULL, NULL, NULL,
 	NULL,
 	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
 };
 
-static void
-ExitConversation (RESPONSE_REF R)
+static LOCDATA yehat_desc_2x =
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 1);
-
-	if (PLAYER_SAID (R, bye_homeworld))
-		NPCPhrase (GOODBYE_AND_DIE_HOMEWORLD);
-	else if (PLAYER_SAID (R, bye_royalist))
-		NPCPhrase (GOODBYE_AND_DIE_ROYALIST);
-	else if (PLAYER_SAID (R, i_demand_you_ally_homeworld0))
-	{
-		NPCPhrase (ENEMY_MUST_DIE);
-
-		SET_GAME_STATE (NO_YEHAT_ALLY_HOME, 1);
-	}
-	else if (PLAYER_SAID (R, bye_space))
-	{
-		if ((BYTE)TFB_Random () & 1)
-			NPCPhrase (GOODBYE_AND_DIE_SPACE);
-		else
+	YEHAT_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	YEHAT_PMAP_ANIM, /* AlienFrame */
+	YEHAT_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* (SIS_TEXT_WIDTH - 16) * 2 / 3, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_MIDDLE, /* AlienTextValign */
+	YEHAT_COLOR_MAP, /* AlienColorMap */
+	YEHAT_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	YEHAT_CONVERSATION_PHRASES, /* PlayerPhrases */
+	13, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{ /* right hand-wing tapping keyboard; front guy */
+			4, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM
+			| WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 10, /* FrameRate */
+			ONE_SECOND / 4, ONE_SECOND / 2,/* RestartRate */
+			0,
+		},
+		{ /* left hand-wing tapping keyboard; front guy */
+			7, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM
+			| WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 10, /* FrameRate */
+			ONE_SECOND / 4, ONE_SECOND / 2,/* RestartRate */
+			0,
+		},
 		{
-			NPCPhrase (GO_IN_PEACE);
-
-			SET_GAME_STATE (BATTLE_SEGUE, 0);
-		}
-	}
-	else if (PLAYER_SAID (R, not_here)
-			|| PLAYER_SAID (R, not_send))
-	{
-		switch (GET_GAME_STATE (YEHAT_REBEL_VISITS))
+			10, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 5) | (1 << 12),
+		},
 		{
-			case 0:
-				NPCPhrase (JUST_A_TRICK_1);
-				break;
-			case 1:
-				NPCPhrase (JUST_A_TRICK_2);
-				break;
-		}
-		SET_GAME_STATE (YEHAT_REBEL_VISITS, 1);
-	}
-	else if (PLAYER_SAID (R, ok_send))
-	{
-		NPCPhrase (WE_REVOLT);
-
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
-		SET_GAME_STATE (YEHAT_CIVIL_WAR, 1);
-		SET_GAME_STATE (YEHAT_VISITS, 0);
-		SET_GAME_STATE (YEHAT_HOME_VISITS, 0);
-		SET_GAME_STATE (YEHAT_REBEL_VISITS, 0);
-		SET_GAME_STATE (YEHAT_REBEL_INFO, 0);
-		SET_GAME_STATE (YEHAT_REBEL_TOLD_PKUNK, 0);
-		SET_GAME_STATE (NO_YEHAT_INFO, 0);
-
-		AddEvent (RELATIVE_EVENT, 0, 0, 0, YEHAT_REBEL_EVENT);
-	}
-}
+			13, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 5),
+		},
+		{
+			16, /* StartIndex */
+			5, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 6, ONE_SECOND * 3,/* RestartRate */
+			0,
+		},
+		{
+			21, /* StartIndex */
+			5, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 6, ONE_SECOND * 3,/* RestartRate */
+			(1 << 2) | (1 << 3) | (1 << 12),
+		},
+		{
+			26, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			29, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			32, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			35, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			38, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			41, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			44, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM | WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 30, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 2) | (1 << 5),
+		},
+	},
+	{ /* AlienTransitionDesc - empty */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		1, /* StartIndex */
+		3, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 15, 0, /* FrameRate */
+		ONE_SECOND / 12, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
+};
 
-static void
-Royalists (RESPONSE_REF R)
+static LOCDATA yehat_desc_4x =
 {
-	if (PLAYER_SAID (R, how_is_rebellion))
-	{
-		BYTE NumVisits;
-
-		NumVisits = GET_GAME_STATE (YEHAT_ROYALIST_INFO);
-		switch (NumVisits++)
+	YEHAT_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	YEHAT_PMAP_ANIM, /* AlienFrame */
+	YEHAT_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* (SIS_TEXT_WIDTH - 16) * 2 / 3, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_MIDDLE, /* AlienTextValign */
+	YEHAT_COLOR_MAP, /* AlienColorMap */
+	YEHAT_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	YEHAT_CONVERSATION_PHRASES, /* PlayerPhrases */
+	13, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{ /* right hand-wing tapping keyboard; front guy */
+			4, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM
+					| WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 10, /* FrameRate */
+			ONE_SECOND / 4, ONE_SECOND / 2,/* RestartRate */
+			0,
+		},
+		{ /* left hand-wing tapping keyboard; front guy */
+			7, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM
+					| WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 10, /* FrameRate */
+			ONE_SECOND / 4, ONE_SECOND / 2,/* RestartRate */
+			0,
+		},
 		{
-			case 0:
-				NPCPhrase (ROYALIST_REBELLION_1);
-				break;
-			case 1:
-				NPCPhrase (ROYALIST_REBELLION_2);
-				--NumVisits;
-				break;
-		}
-		SET_GAME_STATE (YEHAT_ROYALIST_INFO, NumVisits);
-
-		DISABLE_PHRASE (how_is_rebellion);
-	}
-	else if (PLAYER_SAID (R, what_about_pkunk_royalist))
-	{
-		if (GET_GAME_STATE (YEHAT_ABSORBED_PKUNK))
-			NPCPhrase (PKUNK_ABSORBED_ROYALIST);
-		else
-			NPCPhrase (HATE_PKUNK_ROYALIST);
-
-		SET_GAME_STATE (YEHAT_ROYALIST_TOLD_PKUNK, 1);
-	}
-	else if (PLAYER_SAID (R, sorry_about_revolution))
-	{
-		NPCPhrase (ALL_YOUR_FAULT);
-
-		SET_GAME_STATE (NO_YEHAT_INFO, 1);
-	}
-
-	if (PHRASE_ENABLED (how_is_rebellion))
-		Response (how_is_rebellion, Royalists);
-	if (!GET_GAME_STATE (YEHAT_ROYALIST_TOLD_PKUNK)
-			&& GET_GAME_STATE (PKUNK_VISITS)
-			&& GET_GAME_STATE (PKUNK_HOME_VISITS))
-		Response (what_about_pkunk_royalist, Royalists);
-	if (!GET_GAME_STATE (NO_YEHAT_INFO))
-		Response (sorry_about_revolution, Royalists);
-	Response (bye_royalist, ExitConversation);
-}
+			10, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 5) | (1 << 12),
+		},
+		{
+			13, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 5),
+		},
+		{
+			16, /* StartIndex */
+			5, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 6, ONE_SECOND * 3,/* RestartRate */
+			0,
+		},
+		{
+			21, /* StartIndex */
+			5, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 6, ONE_SECOND * 3,/* RestartRate */
+			(1 << 2) | (1 << 3) | (1 << 12),
+		},
+		{
+			26, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			29, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			32, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			35, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			38, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			41, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			44, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM | WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 30, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 2) | (1 << 5),
+		},
+	},
+	{ /* AlienTransitionDesc - empty */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		1, /* StartIndex */
+		3, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 15, 0, /* FrameRate */
+		ONE_SECOND / 12, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
+};
 
 static void
-StartRevolt (RESPONSE_REF R)
+ExitConversation (RESPONSE_REF R)
 {
-	if (PLAYER_SAID (R, shofixti_alive_1))
-	{
-		NPCPhrase (SEND_HIM_OVER_1);
-
-		SET_GAME_STATE (YEHAT_REBEL_TOLD_PKUNK, 1);
-	}
-	else if (PLAYER_SAID (R, shofixti_alive_2))
-		NPCPhrase (SEND_HIM_OVER_2);
-
-	if (ActivateStarShip (SHOFIXTI_SHIP, ESCORTING_FLAGSHIP))
-		Response (ok_send, ExitConversation);
-	else
-		Response (not_here, ExitConversation);
-	Response (not_send, ExitConversation);
+	(void) R; // satisfy compiler
+	NPCPhrase (GOODBYE_EARTHLING);
+	SET_GAME_STATE (BATTLE_SEGUE, 0);
 }
 
 static void
-YehatHome (RESPONSE_REF R)
-{
-
-	if (PLAYER_SAID (R, whats_up_homeworld))
+AskMenu (RESPONSE_REF R)
+{	
+	/* Alien speech */
+	if (PLAYER_SAID (R, investigating_precursors))
 	{
-		BYTE NumVisits;
-
-		NumVisits = GET_GAME_STATE (YEHAT_ROYALIST_INFO);
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (GENERAL_INFO_HOMEWORLD_1);
-				break;
-			case 1:
-				NPCPhrase (GENERAL_INFO_HOMEWORLD_2);
-				--NumVisits;
-				break;
-		}
-		SET_GAME_STATE (YEHAT_ROYALIST_INFO, NumVisits);
-
-		DISABLE_PHRASE (whats_up_homeworld);
+		NPCPhrase (PLEASED_TO_SEE_ALLY);
+		if (GET_GAME_STATE(YEHAT_PRECURSOR_ARTIFACT) == 0)
+			SET_GAME_STATE(YEHAT_PRECURSOR_ARTIFACT, 1);
 	}
-	else if (PLAYER_SAID (R, at_least_help_us_homeworld))
+	else if (PLAYER_SAID (R, reinstate_veepneep))
 	{
-		NPCPhrase (NO_HELP_ENEMY);
-
-		SET_GAME_STATE (NO_YEHAT_HELP_HOME, 1);
+		NPCPhrase (BAD_HUMOUR);
 	}
-	else if (PLAYER_SAID (R, give_info))
+	if (PLAYER_SAID (R, how_are_you))
 	{
-		NPCPhrase (NO_INFO_FOR_ENEMY);
-
-		SET_GAME_STATE (NO_YEHAT_INFO, 1);
+		NPCPhrase (YEHAT_DOING_GOOD);
+		DISABLE_PHRASE (how_are_you);
 	}
-	else if (PLAYER_SAID (R, what_about_pkunk_royalist))
+	else if (PLAYER_SAID (R, how_are_shofixti))
 	{
-		if (GET_GAME_STATE (YEHAT_ABSORBED_PKUNK))
-			NPCPhrase (PKUNK_ABSORBED_ROYALIST);
-		else
-			NPCPhrase (HATE_PKUNK_ROYALIST);
-
-		SET_GAME_STATE (YEHAT_ROYALIST_TOLD_PKUNK, 1);
+		NPCPhrase (SHOFIXTI_INFO);
+		DISABLE_PHRASE (how_are_shofixti);
 	}
-
-	if (PHRASE_ENABLED (whats_up_homeworld))
-		Response (whats_up_homeworld, YehatHome);
-	if (!GET_GAME_STATE (YEHAT_ROYALIST_TOLD_PKUNK)
-			&& GET_GAME_STATE (PKUNK_VISITS)
-			&& GET_GAME_STATE (PKUNK_HOME_VISITS))
-		Response (what_about_pkunk_royalist, YehatHome);
-	if (!GET_GAME_STATE (NO_YEHAT_HELP_HOME))
-		Response (at_least_help_us_homeworld, YehatHome);
-	if (!GET_GAME_STATE (NO_YEHAT_INFO))
-		Response (give_info, YehatHome);
-	if (!GET_GAME_STATE (NO_YEHAT_ALLY_HOME))
+	else if (PLAYER_SAID (R, how_are_pkunk))
 	{
-		UNICODE buf[ALLIANCE_NAME_BUFSIZE];
-
-		GetAllianceName (buf, name_1);
-		construct_response (
-				shared_phrase_buf,
-				i_demand_you_ally_homeworld0,
-				GLOBAL_SIS (CommanderName),
-				i_demand_you_ally_homeworld1,
-				buf,
-				i_demand_you_ally_homeworld2,
-				GLOBAL_SIS (ShipName),
-				i_demand_you_ally_homeworld3,
-				(UNICODE*)NULL);
-		DoResponsePhrase (i_demand_you_ally_homeworld0,
-				ExitConversation, shared_phrase_buf);
+		NPCPhrase (PKUNK_INFORMATION);
+		DISABLE_PHRASE (how_are_pkunk);
 	}
-	Response (bye_homeworld, ExitConversation);
-}
-
-static void
-YehatSpace (RESPONSE_REF R)
-{
-	BYTE i, LastStack;
-	RESPONSE_REF pStr[3];
-
-	LastStack = 0;
-	pStr[0] = pStr[1] = pStr[2] = 0;
-	if (PLAYER_SAID (R, whats_up_space_1)
-			|| PLAYER_SAID (R, whats_up_space_2)
-			|| PLAYER_SAID (R, whats_up_space_3)
-			|| PLAYER_SAID (R, whats_up_space_4))
+	else if (PLAYER_SAID (R, more_news))
 	{
-		BYTE NumVisits;
-
-		NumVisits = GET_GAME_STATE (YEHAT_REBEL_INFO);
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (GENERAL_INFO_SPACE_1);
-				break;
-			case 1:
-				NPCPhrase (GENERAL_INFO_SPACE_2);
-				break;
-			case 2:
-				NPCPhrase (GENERAL_INFO_SPACE_3);
-				break;
-			case 3:
-				NPCPhrase (GENERAL_INFO_SPACE_4);
-				--NumVisits;
-				break;
-		}
-		SET_GAME_STATE (YEHAT_REBEL_INFO, NumVisits);
-
-		DISABLE_PHRASE (whats_up_space_1);
+		NPCPhrase (CHMMR_INFO);
+		DISABLE_PHRASE (more_news);
 	}
-	else if (PLAYER_SAID (R, i_demand_you_ally_space0))
-	{
-		NPCPhrase (WE_CANNOT_1);
+	
 
-		LastStack = 2;
-		SET_GAME_STATE (NO_YEHAT_ALLY_SPACE, 1);
-	}
-	else if (PLAYER_SAID (R, obligation))
+	/* Human speech options */
+	
+	if (PHRASE_ENABLED (how_are_you))
 	{
-		NPCPhrase (WE_CANNOT_2);
-
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
-		SET_GAME_STATE (NO_YEHAT_ALLY_SPACE, 2);
-
-		return;
+		Response (how_are_you, AskMenu);
 	}
-	else if (PLAYER_SAID (R, at_least_help_us_space))
-	{
-		NPCPhrase (SORRY_CANNOT);
 
-		LastStack = 1;
-		SET_GAME_STATE (NO_YEHAT_HELP_SPACE, 1);
-	}
-	else if (PLAYER_SAID (R, dishonor))
+    if (PHRASE_ENABLED (how_are_shofixti))
 	{
-		NPCPhrase (HERES_A_HINT);
-
-		SET_GAME_STATE (NO_YEHAT_HELP_SPACE, 2);
+		Response (how_are_shofixti, AskMenu);
 	}
-	else if (PLAYER_SAID (R, what_about_pkunk_royalist))
+	
+    if (PHRASE_ENABLED (how_are_pkunk))
 	{
-		if (GET_GAME_STATE (YEHAT_ABSORBED_PKUNK))
-			NPCPhrase (PKUNK_ABSORBED_ROYALIST);
-		else
-			NPCPhrase (HATE_PKUNK_ROYALIST);
-
-		SET_GAME_STATE (YEHAT_ROYALIST_TOLD_PKUNK, 1);
+		Response (how_are_pkunk, AskMenu);
 	}
 
-// SET_FUNCPTR (&PtrDesc, YehatSpace);
-	if (PHRASE_ENABLED (whats_up_space_1))
+	if (PHRASE_ENABLED (more_news))
 	{
-		switch (GET_GAME_STATE (YEHAT_REBEL_INFO))
-		{
-			case 0:
-				pStr[0] = whats_up_space_1;
-				break;
-			case 1:
-				pStr[0] = whats_up_space_2;
-				break;
-			case 2:
-				pStr[0] = whats_up_space_3;
-				break;
-			case 3:
-				pStr[0] = whats_up_space_4;
-				break;
-		}
+		Response (more_news, AskMenu);
 	}
-	switch (GET_GAME_STATE (NO_YEHAT_HELP_SPACE))
+
+	if (PHRASE_ENABLED (must_scoot))
 	{
-		case 0:
-			pStr[1] = at_least_help_us_space;
-			break;
-		case 1:
-			pStr[1] = dishonor;
-			break;
+		Response (must_scoot, ExitConversation);
 	}
-	switch (GET_GAME_STATE (NO_YEHAT_ALLY_SPACE))
-	{
-		case 0:
-		{
-			UNICODE buf[ALLIANCE_NAME_BUFSIZE];
+}
 
-			GetAllianceName (buf, name_1);
-			construct_response (
-					shared_phrase_buf,
-					i_demand_you_ally_space0,
-					GLOBAL_SIS (CommanderName),
-					i_demand_you_ally_space1,
-					GLOBAL_SIS (ShipName),
-					i_demand_you_ally_space2,
-					buf,
-					i_demand_you_ally_space3,
-					(UNICODE*)NULL);
-			pStr[2] = i_demand_you_ally_space0;
-			break;
-		}
-		case 1:
-			pStr[2] = obligation;
-			break;
-	}
 
-	if (pStr[LastStack])
-	{
-		if (pStr[LastStack] != i_demand_you_ally_space0)
-			Response (pStr[LastStack], YehatSpace);
-		else
-			DoResponsePhrase (pStr[LastStack], YehatSpace, shared_phrase_buf);
-	}
-	for (i = 0; i < 3; ++i)
+
+static void
+WhyHere (RESPONSE_REF R)
+{	
+	if (PLAYER_SAID (R, hail_yehat))
 	{
-		if (i != LastStack && pStr[i])
-		{
-			if (pStr[i] != i_demand_you_ally_space0)
-				Response (pStr[i], YehatSpace);
-			else
-				DoResponsePhrase (pStr[i], YehatSpace, shared_phrase_buf);
-		}
+		NPCPhrase (WHY_ARE_YOU_HERE2);
 	}
-	if (!GET_GAME_STATE (YEHAT_ROYALIST_TOLD_PKUNK)
-			&& GET_GAME_STATE (PKUNK_VISITS)
-			&& GET_GAME_STATE (PKUNK_HOME_VISITS))
-		Response (what_about_pkunk_royalist, YehatSpace);
-	if (GET_GAME_STATE (SHOFIXTI_VISITS))
+	else
 	{
-		switch (GET_GAME_STATE (YEHAT_REBEL_TOLD_PKUNK))
-		{
-			case 0:
-				Response (shofixti_alive_1, StartRevolt);
-				break;
-			case 1:
-				Response (shofixti_alive_2, StartRevolt);
-				break;
-		}
+		NPCPhrase (WHY_ARE_YOU_HERE1);
 	}
-	Response (bye_space, ExitConversation);
+	NPCPhrase (WHY_CHMMR_STARSHIP);
+
+	Response (investigating_precursors, AskMenu);
+	Response (reinstate_veepneep, AskMenu);
+	Response (must_scoot, ExitConversation);
 }
 
+
+
+
 static void
 Intro (void)
 {
-	BYTE NumVisits;
-
-	if (LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
+	if (GET_GAME_STATE (YEHAT_MET) == 0)
 	{
-		NPCPhrase (OUT_TAKES);
-
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
-		return;
+		SET_GAME_STATE (YEHAT_MET, 1);
 	}
 
-	if (GET_GAME_STATE (YEHAT_CIVIL_WAR))
-	{
-		if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 7))
-		{
-			NumVisits = GET_GAME_STATE (YEHAT_HOME_VISITS);
-			switch (NumVisits++)
-			{
-				case 0:
-					NPCPhrase (ROYALIST_HOMEWORLD_HELLO_1);
-					break;
-				case 1:
-					NPCPhrase (ROYALIST_HOMEWORLD_HELLO_2);
-					--NumVisits;
-					break;
-			}
-			SET_GAME_STATE (YEHAT_HOME_VISITS, NumVisits);
-		}
-		else
-		{
-			NumVisits = GET_GAME_STATE (YEHAT_VISITS);
-			switch (NumVisits++)
-			{
-				case 0:
-					NPCPhrase (ROYALIST_SPACE_HELLO_1);
-					break;
-				case 1:
-					NPCPhrase (ROYALIST_SPACE_HELLO_2);
-					--NumVisits;
-					break;
-			}
-			SET_GAME_STATE (YEHAT_VISITS, NumVisits);
-		}
-
-		Royalists ((RESPONSE_REF)0);
-	}
-	else if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 7))
-	{
-		NumVisits = GET_GAME_STATE (YEHAT_HOME_VISITS);
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (HOMEWORLD_HELLO_1);
-				break;
-			case 1:
-				NPCPhrase (HOMEWORLD_HELLO_2);
-				--NumVisits;
-				break;
-		}
-		SET_GAME_STATE (YEHAT_HOME_VISITS, NumVisits);
+	NPCPhrase (YEHAT_GREETING1);
 
-		YehatHome ((RESPONSE_REF)0);
-	}
-	else
-	{
-		NumVisits = GET_GAME_STATE (YEHAT_VISITS);
-		switch (NumVisits++)
-		{
-			case 0:
-				NPCPhrase (SPACE_HELLO_1);
-				break;
-			case 1:
-				NPCPhrase (SPACE_HELLO_2);
-				break;
-			case 2:
-				NPCPhrase (SPACE_HELLO_3);
-				break;
-			case 3:
-				NPCPhrase (SPACE_HELLO_4);
-				--NumVisits;
-				break;
-		}
-		SET_GAME_STATE (YEHAT_VISITS, NumVisits);
 
-		YehatSpace ((RESPONSE_REF)0);
-	}
+	Response (hail_yehat, WhyHere);
+	Response (what_up, WhyHere);
+	Response (must_scoot, ExitConversation);
 }
 
+
+
 static COUNT
 uninit_yehat (void)
 {
@@ -661,24 +639,34 @@ post_yehat_enc (void)
 LOCDATA*
 init_yehat_comm (void)
 {
+	static LOCDATA yehat_desc;
 	LOCDATA *retval;
 
+	switch (RESOLUTION_FACTOR)
+	{
+	case 2:
+		yehat_desc = yehat_desc_4x;
+		break;
+	case 1:
+		yehat_desc = yehat_desc_2x;
+		break;
+	case 0:
+	default:
+		yehat_desc = yehat_desc_1x;
+		break;
+	}
+	
 	yehat_desc.init_encounter_func = Intro;
 	yehat_desc.post_encounter_func = post_yehat_enc;
 	yehat_desc.uninit_encounter_func = uninit_yehat;
 
 	yehat_desc.AlienTextBaseline.x = SIS_SCREEN_WIDTH * 2 / 3;
-	yehat_desc.AlienTextBaseline.y = 60;
+	yehat_desc.AlienTextBaseline.y = RES_SIS_SCALE(60);
 	yehat_desc.AlienTextWidth = (SIS_TEXT_WIDTH - 16) * 2 / 3;
 
-	if (LOBYTE (GLOBAL (CurrentActivity)) != WON_LAST_BATTLE)
-	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
-	}
-	else
-	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
-	}
+	// JMS: Yehat are no longer hostile upon the encountering
+	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	
 	retval = &yehat_desc;
 
 	return (retval);
diff -ruNp src.orig/uqm/comm/yehatpkunk/Makeinfo src/uqm/comm/yehatpkunk/Makeinfo
--- src.orig/uqm/comm/yehatpkunk/Makeinfo	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/yehatpkunk/Makeinfo	2017-11-01 15:31:02 -0700
@@ -0,0 +1 @@
+uqm_CFILES="yehatpkunkc.c"
diff -ruNp src.orig/uqm/comm/yehatpkunk/resinst.h src/uqm/comm/yehatpkunk/resinst.h
--- src.orig/uqm/comm/yehatpkunk/resinst.h	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/yehatpkunk/resinst.h	2017-11-01 15:31:02 -0700
@@ -0,0 +1,6 @@
+#define YEHATPKUNK_PMAP_ANIM "comm.yehatpkunk.graphics"
+#define YEHAT_FONT "comm.yehat.font"
+#define PKUNK_FONT "comm.pkunk.font"
+#define YEHAT_COLOR_MAP "comm.yehat.colortable"
+#define YEHATPKUNK_CONVERSATION_PHRASES "comm.yehatpkunk.dialogue"
+#define YEHAT_MUSIC "comm.yehat.music"
diff -ruNp src.orig/uqm/comm/yehatpkunk/strings.h src/uqm/comm/yehatpkunk/strings.h
--- src.orig/uqm/comm/yehatpkunk/strings.h	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/yehatpkunk/strings.h	2017-11-01 15:31:02 -0700
@@ -0,0 +1,31 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _STRINGS_H
+#define _STRINGS_H
+
+enum
+{
+	NULL_PHRASE,
+	Y_HELLO,
+	P_HELLO,
+	Y_BYEBYE,
+};
+
+#endif /* _STRINGS_H */
+
diff -ruNp src.orig/uqm/comm/yehatpkunk/yehatpkunkc.c src/uqm/comm/yehatpkunk/yehatpkunkc.c
--- src.orig/uqm/comm/yehatpkunk/yehatpkunkc.c	1969-12-31 16:00:00 -0800
+++ src/uqm/comm/yehatpkunk/yehatpkunkc.c	2017-11-01 15:31:02 -0700
@@ -0,0 +1,411 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "../commall.h"
+#include "resinst.h"
+#include "strings.h"
+#include "uqm/nameref.h"
+
+#include "uqm/build.h"
+#include "uqm/gameev.h"
+
+
+#define YEHAT_FG_COLOR WHITE_COLOR
+#define YEHAT_BG_COLOR BLACK_COLOR
+#define YEHAT_BASE_X (SIS_SCREEN_WIDTH * 2 / 3)
+#define YEHAT_BASE_Y RES_SIS_SCALE(60)
+#define YEHAT_TALK_INDEX 35
+#define YEHAT_TALK_FRAMES 3
+
+#define PKUNK_FG_COLOR WHITE_COLOR
+#define PKUNK_BG_COLOR BLACK_COLOR
+#define PKUNK_BASE_X (SIS_SCREEN_WIDTH / 3)
+#define PKUNK_BASE_Y RES_SIS_SCALE(75)
+#define PKUNK_TALK_INDEX 14
+#define PKUNK_TALK_FRAMES 2
+
+static LOCDATA yehatpkunk_desc =
+{
+	YEHATPKUNK_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	YEHATPKUNK_PMAP_ANIM, /* AlienFrame */
+	YEHAT_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_MIDDLE, /* AlienTextValign */
+	YEHAT_COLOR_MAP, /* AlienColorMap */
+	YEHAT_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	YEHATPKUNK_CONVERSATION_PHRASES, /* PlayerPhrases */
+	15, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{ /* 0 Pkunk eye blink */
+			1, /* StartIndex */
+			4, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 1), /* BlockMask */
+		},
+		{ /* 1 Pkunk eye roll */
+			5, /* StartIndex */
+			4, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 0), /* BlockMask */
+		},
+		{ /* 2 Gulp */
+			9, /* StartIndex */
+			5, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* 3 Pkunk light */
+			16, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			(1 << 4) | (1 << 5), /* BlockMask */
+		},
+		{ /* 4 Pkunk light */
+			19, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			(1 << 3) | (1 << 5), /* BlockMask */
+		},
+		{ /* 5 Pkunk light */
+			22, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			(1 << 3) | (1 << 4), /* BlockMask */
+		},
+		{ /* 6 Pkunk left hand */
+			25, /* StartIndex */
+			7, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 6, ONE_SECOND * 3,/* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* 7 Pkunk right hand */
+			32, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 6, ONE_SECOND * 3,/* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* 8 Yehat right hand */
+			38, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM | WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 10, /* FrameRate */
+			ONE_SECOND / 4, ONE_SECOND / 2,/* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* 9 Yehat left hand */
+			41, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM | WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 10, /* FrameRate */
+			ONE_SECOND / 4, ONE_SECOND / 2,/* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* 10 Yehat eye glow */
+			44, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 14), /* BlockMask */
+		},
+		{ /* 11 Yehat light */
+			47, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			(1 << 12) | (1 << 13), /* BlockMask */
+		},
+		{ /* 12 Yehat light */
+			50, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			(1 << 11) | (1 << 13), /* BlockMask */
+		},
+		{ /* 13 Yehat light */
+			53, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			(1 << 11) | (1 << 12), /* BlockMask */
+		},
+		{ /* 14 Yehat eye blink */
+			56, /* StartIndex */
+			4, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 10), /* BlockMask */
+		},
+	},
+	{ /* AlienTransitionDesc */
+		47, /* StartIndex */
+		3, /* NumFrames */
+		YOYO_ANIM, /* AnimFlags */
+		ONE_SECOND / 30, 0, /* FrameRate */
+		ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		YEHAT_TALK_INDEX, /* StartIndex */
+		YEHAT_TALK_FRAMES, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 15, 0, /* FrameRate */
+		ONE_SECOND / 12, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
+};
+
+enum
+{
+	YEHAT_ALIEN,
+	PKUNK_ALIEN
+};
+
+static int LastAlien;
+static FONT PkunkFont, YehatFont;
+
+static void
+SelectAlienYEHAT (void)
+{
+	if (LastAlien != YEHAT_ALIEN)
+	{
+		// XXX: This should hold the GraphicsLock to block comm anims and
+		//   prevent CommData half-updates, but if we do so, the stream
+		//   decoder will deadlock with the drawing thread.
+
+		// // Transition to neutral state first if Pik was talking
+		CommData.AlienTransitionDesc.AnimFlags |= TALK_DONE;
+		LastAlien = YEHAT_ALIEN;
+		CommData.AlienTransitionDesc.AnimFlags |= TALK_INTRO;
+		// CommData.AlienTransitionDesc.StartIndex = FOT_TO_YEHAT;
+		CommData.AlienTalkDesc.StartIndex = YEHAT_TALK_INDEX;
+		CommData.AlienTalkDesc.NumFrames = YEHAT_TALK_FRAMES;
+		CommData.AlienAmbientArray[0].AnimFlags &= ~WAIT_TALKING;
+		CommData.AlienAmbientArray[1].AnimFlags &= ~WAIT_TALKING;
+		CommData.AlienAmbientArray[2].AnimFlags &= ~WAIT_TALKING;
+		CommData.AlienAmbientArray[8].AnimFlags |= WAIT_TALKING;
+		CommData.AlienAmbientArray[9].AnimFlags |= WAIT_TALKING;
+
+		CommData.AlienTextBaseline.x = (SWORD)YEHAT_BASE_X;
+		CommData.AlienTextBaseline.y = YEHAT_BASE_Y;
+		CommData.AlienTextFColor = YEHAT_FG_COLOR;
+		CommData.AlienTextBColor = YEHAT_BG_COLOR;
+		CommData.AlienFont = YehatFont;
+	}
+}
+
+static void
+SelectAlienPKUNK (void)
+{
+	if (LastAlien != PKUNK_ALIEN)
+	{
+		// XXX: This should hold the GraphicsLock to block comm anims and
+		//   prevent CommData half-updates, but if we do so, the stream
+		//   decoder will deadlock with the drawing thread.
+
+		// // Transition to neutral state first if Zoq was talking
+		// if (LastAlien != FOT_ALIEN)
+		CommData.AlienTransitionDesc.AnimFlags |= TALK_DONE;
+		LastAlien = PKUNK_ALIEN;
+		CommData.AlienTransitionDesc.AnimFlags |= TALK_INTRO;
+		// CommData.AlienTransitionDesc.StartIndex = FOT_TO_PIK;
+		CommData.AlienTalkDesc.StartIndex = PKUNK_TALK_INDEX;
+		CommData.AlienTalkDesc.NumFrames = PKUNK_TALK_FRAMES;
+		CommData.AlienAmbientArray[0].AnimFlags |= WAIT_TALKING;
+		CommData.AlienAmbientArray[1].AnimFlags |= WAIT_TALKING;
+		CommData.AlienAmbientArray[2].AnimFlags |= WAIT_TALKING;
+		CommData.AlienAmbientArray[8].AnimFlags &= ~WAIT_TALKING;
+		CommData.AlienAmbientArray[9].AnimFlags &= ~WAIT_TALKING;
+
+		CommData.AlienTextBaseline.x = (SWORD)PKUNK_BASE_X;
+		CommData.AlienTextBaseline.y = PKUNK_BASE_Y;
+		CommData.AlienTextFColor = PKUNK_FG_COLOR;
+		CommData.AlienTextBColor = PKUNK_BG_COLOR;
+		CommData.AlienFont = PkunkFont;
+	}
+}
+
+static void
+YPTalkSegue (COUNT wait_track)
+{
+	LastAlien = PKUNK_ALIEN;
+	SelectAlienYEHAT ();
+	AlienTalkSegue (wait_track);
+}
+
+static void
+ExitConversation (RESPONSE_REF R)
+{
+	(void) R;
+	
+	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	/***
+	if (PLAYER_SAID (R, bye_homeworld))
+	{
+		NPCPhrase_cb (GOODBYE_HOME0, &SelectAlienZOQ);
+		NPCPhrase_cb (GOODBYE_HOME1, &SelectAlienPIK);
+		ZFPTalkSegue ((COUNT)~0);
+	}
+	else if (PLAYER_SAID (R, decide_later))
+	{
+		NPCPhrase_cb (PLEASE_HURRY0, &SelectAlienZOQ);
+		NPCPhrase_cb (PLEASE_HURRY1, &SelectAlienPIK);
+		ZFPTalkSegue ((COUNT)~0);
+	}
+	else if (PLAYER_SAID (R, valuable_info))
+	{
+		NPCPhrase_cb (GOODBYE0, &SelectAlienZOQ);
+		NPCPhrase_cb (GOODBYE1, &SelectAlienPIK);
+		NPCPhrase_cb (GOODBYE2, &SelectAlienZOQ);
+		NPCPhrase_cb (GOODBYE3, &SelectAlienPIK);
+		ZFPTalkSegue ((COUNT)~0);
+	}
+	else if (PLAYER_SAID (R, how_can_i_help))
+	{
+		NPCPhrase_cb (EMMISSARIES0, &SelectAlienZOQ);
+		NPCPhrase_cb (EMMISSARIES1, &SelectAlienPIK);
+		NPCPhrase_cb (EMMISSARIES2, &SelectAlienZOQ);
+		NPCPhrase_cb (EMMISSARIES3, &SelectAlienPIK);
+		NPCPhrase_cb (EMMISSARIES4, &SelectAlienZOQ);
+		NPCPhrase_cb (EMMISSARIES5, &SelectAlienPIK);
+		NPCPhrase_cb (EMMISSARIES6, &SelectAlienZOQ);
+		NPCPhrase_cb (EMMISSARIES7, &SelectAlienPIK);
+		ZFPTalkSegue ((COUNT)~0);
+	}
+	else if (PLAYER_SAID (R, sure))
+	{
+		NPCPhrase_cb (WE_ALLY0, &SelectAlienZOQ);
+		NPCPhrase_cb (WE_ALLY1, &SelectAlienPIK);
+		NPCPhrase_cb (WE_ALLY2, &SelectAlienZOQ);
+		NPCPhrase_cb (WE_ALLY3, &SelectAlienPIK);
+		NPCPhrase_cb (WE_ALLY4, &SelectAlienZOQ);
+		NPCPhrase_cb (WE_ALLY5, &SelectAlienPIK);
+		ZFPTalkSegue ((COUNT)~0);
+		ActivateStarShip (ZOQFOTPIK_SHIP, SET_ALLIED);
+		AddEvent (RELATIVE_EVENT, 3, 0, 0, ZOQFOT_DISTRESS_EVENT);
+		SET_GAME_STATE (ZOQFOT_HOME_VISITS, 0);
+	}
+	else if (PLAYER_SAID (R, all_very_interesting))
+	{
+		NPCPhrase_cb (SEE_TOLD_YOU0, &SelectAlienZOQ);
+		NPCPhrase_cb (SEE_TOLD_YOU1, &SelectAlienPIK);
+		NPCPhrase_cb (SEE_TOLD_YOU2, &SelectAlienZOQ);
+		NPCPhrase_cb (SEE_TOLD_YOU3, &SelectAlienPIK);
+		ZFPTalkSegue ((COUNT)~0);
+
+		SET_GAME_STATE (ZOQFOT_HOSTILE, 1);
+		SET_GAME_STATE (ZOQFOT_HOME_VISITS, 0);
+		SET_GAME_STATE (BATTLE_SEGUE, 1);
+	}
+	else if (PLAYER_SAID (R, never))
+	{
+		NPCPhrase_cb (WE_ENEMIES0, &SelectAlienZOQ);
+		NPCPhrase_cb (WE_ENEMIES1, &SelectAlienPIK);
+		ZFPTalkSegue ((COUNT)~0);
+
+		SET_GAME_STATE (ZOQFOT_HOME_VISITS, 0);
+		SET_GAME_STATE (ZOQFOT_HOSTILE, 1);
+		SET_GAME_STATE (BATTLE_SEGUE, 1);
+	}
+	***/
+}
+
+static void
+Intro (void)
+{
+	YehatFont = CommData.AlienFont;
+	
+	NPCPhrase_cb (Y_HELLO, &SelectAlienYEHAT);
+	NPCPhrase_cb (P_HELLO, &SelectAlienPKUNK);
+	NPCPhrase_cb (Y_BYEBYE, &SelectAlienYEHAT);
+	//	YPTalkSegue ((COUNT)~0);
+	ExitConversation ((RESPONSE_REF)0);
+}
+
+static COUNT
+uninit_yehatpkunk (void)
+{
+	return (0);
+}
+
+static void
+post_yehatpkunk_enc (void)
+{
+	DestroyFont(PkunkFont);
+	// nothing defined so far
+}
+
+LOCDATA*
+init_yehatpkunk_comm (void)
+{
+	LOCDATA *retval;
+
+	yehatpkunk_desc.init_encounter_func = Intro;
+	yehatpkunk_desc.post_encounter_func = post_yehatpkunk_enc;
+	yehatpkunk_desc.uninit_encounter_func = uninit_yehatpkunk;
+
+	yehatpkunk_desc.AlienTextBaseline.x = (SWORD)YEHAT_BASE_X;
+	yehatpkunk_desc.AlienTextBaseline.y = YEHAT_BASE_Y;
+	yehatpkunk_desc.AlienTextWidth = (SIS_TEXT_WIDTH - 16) * 2 / 3;	
+	PkunkFont = LoadFont (PKUNK_FONT);
+	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	
+	retval = &yehatpkunk_desc;
+
+	return (retval);
+}
+
diff -ruNp src.orig/uqm/comm/zoqfot/zoqfotc.c src/uqm/comm/zoqfot/zoqfotc.c
--- src.orig/uqm/comm/zoqfot/zoqfotc.c	2017-11-01 15:30:24 -0700
+++ src/uqm/comm/zoqfot/zoqfotc.c	2017-11-01 15:31:02 -0700
@@ -27,7 +27,7 @@
 #define ZOQ_FG_COLOR WHITE_COLOR
 #define ZOQ_BG_COLOR BLACK_COLOR
 #define ZOQ_BASE_X (TEXT_X_OFFS + ((SIS_TEXT_WIDTH >> 1) >> 1))
-#define ZOQ_BASE_Y 24
+#define ZOQ_BASE_Y RES_SIS_SCALE(24)
 #define ZOQ_TALK_INDEX 18
 #define ZOQ_TALK_FRAMES 5
 #define FOT_TO_ZOQ 23
@@ -35,13 +35,14 @@
 #define PIK_FG_COLOR WHITE_COLOR
 #define PIK_BG_COLOR BLACK_COLOR
 #define PIK_BASE_X (SIS_SCREEN_WIDTH - (TEXT_X_OFFS + ((SIS_TEXT_WIDTH >> 1) >> 1)))
-#define PIK_BASE_Y 24
+#define PIK_BASE_Y RES_SIS_SCALE(24)
 #define PIK_TALK_INDEX 29
 #define PIK_TALK_FRAMES 2
 #define FOT_TO_PIK 26
 
 static LOCDATA zoqfot_desc =
 {
+	ZOQFOTPIK_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -107,6 +108,11 @@ static LOCDATA zoqfot_desc =
 	NULL, NULL, NULL,
 	NULL,
 	NULL,
+	0, /* NumFeatures */
+	{{0, 0, {0}} /*AlienFeatureArray (alternative features) */
+	},
+	{0 /* AlienFeatureChoice (will be computed later) */
+	},
 };
 
 enum
diff -ruNp src.orig/uqm/comm.c src/uqm/comm.c
--- src.orig/uqm/comm.c	2017-11-01 15:30:24 -0700
+++ src/uqm/comm.c	2017-11-01 15:31:02 -0700
@@ -16,7 +16,23 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: -Commented out a line related to chmmrs in RaceCommunication to avoid vanishing avatars
+//			 after encounter in interplanetary.
+//
+//			 -Some changes to InitCommunication to remove bugs from fighting against Chmmr
+//
+//			 -Freight transport ships do not disappear after encountering in hyperspace.
+//			 -Increased maximum number of communication responses from 8 to 10
+//
+// JMS 2011: -Changed COMM_ANIM_RATE to 120 fps since hires4x seems to like it... 
+
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
 #define COMM_INTERNAL
+//#include "port.h"
+//#include SDL_INCLUDE(SDL.h)
+//#include "libs/graphics/gfxintrn.h"
+//#include "libs/graphics/gfx_common.h"
 #include "comm.h"
 
 #include "build.h"
@@ -42,10 +58,11 @@
 #include "libs/sound/sound.h"
 #include "libs/sound/trackplayer.h"
 #include "libs/log.h"
+#include "libs/mathlib.h"
 
 #include <ctype.h>
 
-#define MAX_RESPONSES 8
+#define MAX_RESPONSES 10 // JMS: Increased this from default 8 to house starbase communications
 #define BACKGROUND_VOL \
 		(speechVolumeScale == 0.0f ? NORMAL_VOLUME : (NORMAL_VOLUME >> 1))
 #define FOREGROUND_VOL NORMAL_VOLUME
@@ -55,18 +72,31 @@
 // XXX: was 32 picked experimentally?
 #define OSCILLOSCOPE_RATE   (ONE_SECOND / 32)
 
+// JMS_GFX
+#define RESPONSE_EXTRA_Y (RES_CASE(0,12,22))
+
 // Maximum comm animation frame rate (actual execution rate)
 // A gfx frame is not always produced during an execution frame,
 // and several animations are combined into one gfx frame.
 // The rate was originally 120fps which allowed for more animation
 // precision which is ultimately wasted on the human eye anyway.
 // The highest known stable animation rate is 40fps, so that's what we use.
-#define COMM_ANIM_RATE   (ONE_SECOND / 40)
+//
+// JMS: Changed this back to 120 fps since hires4x seems to like it... 
+#define COMM_ANIM_RATE   (ONE_SECOND / 120)
+
+
+/* This symbol, when appearing in alien text, toggles the computer font. */
+#define COMPUTER_TOKEN '$'
+
+/* Whether the current conversation uses computer tokens.  Currently only Orz and the Shofixti Colony. */
+#define isComputerTokenConv (CommData.AlienConv == ORZ_CONVERSATION || CommData.AlienConv == SHOFIXTICOLONY_CONVERSATION)
 
 static CONTEXT AnimContext;
 
 LOCDATA CommData;
 UNICODE shared_phrase_buf[2048];
+FONT ComputerFont;
 
 static BOOLEAN TalkingFinished;
 static CommIntroMode curIntroMode = CIM_DEFAULT;
@@ -74,9 +104,9 @@ static TimeCount fadeTime;
 
 typedef struct response_entry
 {
-	RESPONSE_REF response_ref;
-	TEXT response_text;
-	RESPONSE_FUNC response_func;
+	RESPONSE_REF response_ref; // RESPONSE_REF is a uint16 by way of COUNT and UWORD
+	TEXT response_text; // TEXT defined in libs/gfxlib.h, a typedef for struct text
+	RESPONSE_FUNC response_func; // any pointer-to-void function taking a RESPONSE_REF argument
 } RESPONSE_ENTRY;
 
 typedef struct encounter_state
@@ -105,7 +135,7 @@ static FRAME TextCacheFrame;
 
 RECT CommWndRect = {
 	// default values; actually inited by HailAlien()
-	{SIS_ORG_X, SIS_ORG_Y},
+	{0, 0}, //{SIS_ORG_X, SIS_ORG_Y}, // JMS_GFX
 	{0, 0}
 };
 
@@ -157,6 +187,7 @@ add_text (int status, TEXT *pTextIn)
 	static COORD last_baseline;
 	BOOLEAN eol;
 	CONTEXT OldContext = NULL;
+	COUNT computerOn = 0;
 	
 	BatchGraphics ();
 
@@ -192,20 +223,19 @@ add_text (int status, TEXT *pTextIn)
 	}
 	else if (GetContextFontLeading (&leading), status <= -4)
 	{
-		text_width = (SIZE) (SIS_SCREEN_WIDTH - 8 - (TEXT_X_OFFS << 2));
+		text_width = (SIZE) (SIS_SCREEN_WIDTH - (8 << RESOLUTION_FACTOR) - (TEXT_X_OFFS << 2)); // JMS_GFX
 
 		pText = pTextIn;
 	}
 	else
 	{
-		text_width = (SIZE) (SIS_SCREEN_WIDTH - 8 - (TEXT_X_OFFS << 2));
+		text_width = (SIZE) (SIS_SCREEN_WIDTH - (8 << RESOLUTION_FACTOR) - (TEXT_X_OFFS << 2)); // JMS_GFX
 
 		switch (status)
 		{
 			case -3:
 				// Unknown. Never reached; color matches the background color.
-				SetContextForeGroundColor (
-						BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01));
+				SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01));
 				break;
 			case -2:
 				// Not highlighted dialog options.
@@ -219,10 +249,11 @@ add_text (int status, TEXT *pTextIn)
 
 		maxchars = pTextIn->CharCount;
 		locText = *pTextIn;
-		locText.baseline.x -= 8;
+		locText.baseline.x -= (8 << RESOLUTION_FACTOR) - 4 * RESOLUTION_FACTOR; // JMS_GFX
 		locText.CharCount = (COUNT)~0;
 		locText.pStr = STR_BULLET;
-		font_DrawText (&locText);
+		if (!((status == -2 || status == -1) && pTextIn->baseline.y >= SIS_SCREEN_HEIGHT))
+			font_DrawText (&locText);
 
 		locText = *pTextIn;
 		pText = &locText;
@@ -260,7 +291,7 @@ add_text (int status, TEXT *pTextIn)
 		{
 			// Player dialog option or (status == -4) other non-alien
 			// text.
-			if (pText->baseline.y < SIS_SCREEN_HEIGHT)
+			if ((pText->baseline.y + RESPONSE_EXTRA_Y) < SIS_SCREEN_HEIGHT)
 				font_DrawText (pText);
 
 			if (status < -4 && pText->baseline.y >= -status - 10)
@@ -273,8 +304,112 @@ add_text (int status, TEXT *pTextIn)
 		else
 		{
 			// Alien speech
-			font_DrawTracedText (pText,
-					CommData.AlienTextFColor, CommData.AlienTextBColor);
+			if (isComputerTokenConv)
+			{
+				// BW : special case for the Orz conversations
+				// the character COMPUTER_TOKEN (currently '$')
+                                // is recycled as a marker to
+				// switch from and to computer font.
+				//
+				// JMS: Computer font also used when first encountering Shofixti colony.
+				
+				const char *ptr;
+				RECT rect;
+				COORD baselinex = pText->baseline.x;
+				COORD width = 0;
+				COUNT remChars = pText->CharCount;
+			        // Remaining chars until end of line within width
+				const char *bakptr;
+				COUNT bakChars = remChars;
+				COUNT bakcompOn = computerOn;
+				FONT bakFont = SetContextFont(ComputerFont);
+				
+				SetContextFont(bakFont);
+				ptr = pText->pStr;
+				bakptr = ptr;
+				
+				// We need to manually center the line because
+				// the computer font is larger than the Orzfont
+				
+				// This loop computes the width of the line
+				while (remChars > 0)
+					{
+						while ((*ptr != COMPUTER_TOKEN) && remChars > 0)
+							{
+								getCharFromString (&ptr);
+								remChars--;
+							}
+						
+						pText->CharCount -= remChars;
+						TextRect (pText, &rect, NULL);
+						
+						width += rect.extent.width;
+						
+						if (*ptr == COMPUTER_TOKEN)
+							{
+								getCharFromString (&ptr);
+								remChars--;
+								computerOn = 1 - computerOn;
+								if (computerOn)
+									SetContextFont (ComputerFont);
+								else
+									SetContextFont (CommData.AlienFont);
+							}
+						pText->CharCount = remChars;
+						pText->pStr = ptr;
+					}
+
+				// This to simulate a centered line
+				pText->baseline.x = baselinex - (width >> 1);
+				pText->align = ALIGN_LEFT;
+				
+				// Put everything back in place for the
+				// actual display 
+				remChars = bakChars;
+				pText->CharCount = bakChars;
+				ptr = bakptr;
+				pText->pStr = bakptr;
+				computerOn = bakcompOn;
+				SetContextFont(bakFont);
+				
+				// This loop is used to look up for $
+				while (remChars > 0)
+					{
+						while ((*ptr != COMPUTER_TOKEN) && remChars > 0)
+							{
+								getCharFromString (&ptr);
+								remChars--;
+							}
+						
+						pText->CharCount -= remChars;
+						TextRect (pText, &rect, NULL);
+						
+						font_DrawTracedText (pText,
+								     CommData.AlienTextFColor, CommData.AlienTextBColor);
+						
+						pText->baseline.x += rect.extent.width;
+						
+						if (*ptr == COMPUTER_TOKEN)
+							{
+								getCharFromString (&ptr);
+								remChars--;
+								computerOn = 1 - computerOn;
+								if (computerOn)
+									SetContextFont (ComputerFont);
+								else
+									SetContextFont (CommData.AlienFont);
+							}
+						pText->CharCount = remChars;
+						pText->pStr = ptr;
+					}
+				pText->baseline.x = baselinex;
+				pText->align = ALIGN_CENTER;
+			}
+			else
+			{
+				// Normal case : other races than Orz
+				font_DrawTracedText (pText, CommData.AlienTextFColor, CommData.AlienTextBColor);
+			}
 		}
 	} while (!eol && maxchars);
 	pText->pStr = pStr;
@@ -416,19 +551,22 @@ RefreshResponses (ENCOUNTER_STATE *pES)
 	BYTE response;
 	SIZE leading;
 	STAMP s;
+	BYTE extra_y; // JMS_GFX
 
 	SetContext (SpaceContext);
 	GetContextFontLeading (&leading);
 	BatchGraphics ();
 
 	DrawSISComWindow ();
-	y = SLIDER_Y + SLIDER_HEIGHT + 1;
-	for (response = pES->top_response; response < pES->num_responses;
-			++response)
+	y = SLIDER_Y + SLIDER_HEIGHT + (1 << RESOLUTION_FACTOR); // JMS_GFX
+	for (response = pES->top_response; response < pES->num_responses; ++response)
 	{
-		pES->response_list[response].response_text.baseline.x = TEXT_X_OFFS + 8;
-		pES->response_list[response].response_text.baseline.y = y + leading;
+		extra_y = (response == pES->top_response ? 0 : RESPONSE_EXTRA_Y); // JMS_GFX
+		
+		pES->response_list[response].response_text.baseline.x = TEXT_X_OFFS + (8 << RESOLUTION_FACTOR); // JMS_GFX
+		pES->response_list[response].response_text.baseline.y = y + leading + extra_y; // JMS_GFX
 		pES->response_list[response].response_text.align = ALIGN_LEFT;
+		
 		if (response == pES->cur_response)
 			y = add_text (-1, &pES->response_list[response].response_text);
 		else
@@ -440,7 +578,7 @@ RefreshResponses (ENCOUNTER_STATE *pES)
 		s.origin.y = SLIDER_Y + SLIDER_HEIGHT + 1;
 		s.frame = SetAbsFrameIndex (ActivityFrame, 6);
 	}
-	else if (y > SIS_SCREEN_HEIGHT)
+	else if ((y + extra_y) > SIS_SCREEN_HEIGHT)
 	{
 		s.origin.y = SIS_SCREEN_HEIGHT - 2;
 		s.frame = SetAbsFrameIndex (ActivityFrame, 7);
@@ -471,7 +609,7 @@ FeedbackPlayerPhrase (UNICODE *pStr)
 		TEXT ct;
 
 		ct.baseline.x = SIS_SCREEN_WIDTH >> 1;
-		ct.baseline.y = SLIDER_Y + SLIDER_HEIGHT + 13;
+		ct.baseline.y = SLIDER_Y + SLIDER_HEIGHT + (13 << RESOLUTION_FACTOR); // JMS_GFX
 		ct.align = ALIGN_CENTER;
 		ct.CharCount = (COUNT)~0;
 
@@ -480,7 +618,7 @@ FeedbackPlayerPhrase (UNICODE *pStr)
 		SetContextForeGroundColor (COMM_RESPONSE_INTRO_TEXT_COLOR);
 		font_DrawText (&ct);
 
-		ct.baseline.y += 16;
+		ct.baseline.y += (16 << RESOLUTION_FACTOR); // JMS_GFX
 		SetContextForeGroundColor (COMM_FEEDBACK_TEXT_COLOR);
 		ct.pStr = pStr;
 		add_text (-4, &ct);
@@ -767,7 +905,11 @@ AlienTalkSegue (COUNT wait_track)
 		LockMutex (GraphicsLock);
 		SetColorMap (GetColorMapAddress (CommData.AlienColorMap));
 		SetContext (AnimContext);
-		DrawAlienFrame (NULL, 0, TRUE);
+		
+		// JMS: Shofixti Colony comm screen is blacked out upon the first encounter.
+		if (!(CommData.AlienConv == SHOFIXTICOLONY_CONVERSATION && GET_GAME_STATE (SHOFIXTI_COLONY_MET) == 0))
+			DrawAlienFrame (NULL, 0, TRUE);
+		
 		UpdateSpeechGraphics ();
 		CommIntroTransition ();
 		UnlockMutex (GraphicsLock);
@@ -801,12 +943,43 @@ typedef struct summary_state
 
 } SUMMARY_STATE;
 
+/* Removes the computer tokens from a prepared text line. */
+static void removeComputerTokens(TEXT *pText)
+{
+    static char buffer[512];
+    const char *ptr = pText->pStr;
+    char *ptr2 = buffer;
+    char *pend = buffer + sizeof(buffer) - 1;
+    COUNT remChars = pText->CharCount;
+    COUNT usedChars = 0;
+    
+    while (remChars > 0)
+    {
+        UniChar ch = getCharFromString(&ptr);
+        remChars--;
+        
+        if (ch != COMPUTER_TOKEN)
+        {
+            int used = getStringFromChar(ptr2, pend - ptr2, ch);
+            if (used > 0)
+            {
+                ptr2 += used;
+                usedChars++;
+            }
+        }
+    }
+    
+    *ptr2 = 0;
+    pText->CharCount = usedChars;
+    pText->pStr = buffer;
+}
+
 static BOOLEAN
 DoConvSummary (SUMMARY_STATE *pSS)
 {
-#define DELTA_Y_SUMMARY 8
-#define MAX_SUMM_ROWS ((SIS_SCREEN_HEIGHT - SLIDER_Y - SLIDER_HEIGHT) \
-			/ DELTA_Y_SUMMARY) - 1
+#define DELTA_Y_SUMMARY ((8 << RESOLUTION_FACTOR) - 2 * RESOLUTION_FACTOR) // JMS_GFX
+//#define MAX_SUMM_ROWS ((SIS_SCREEN_HEIGHT - SLIDER_Y - SLIDER_HEIGHT) / DELTA_Y_SUMMARY
+#define MAX_SUMM_ROWS (SLIDER_Y	/ DELTA_Y_SUMMARY) - (1 << RESOLUTION_FACTOR) // JMS_GFX
 
 	if (!pSS->Initialized)
 	{
@@ -843,7 +1016,7 @@ DoConvSummary (SUMMARY_STATE *pSS)
 		r.corner.x = 0;
 		r.corner.y = 0;
 		r.extent.width = SIS_SCREEN_WIDTH;
-		r.extent.height = SIS_SCREEN_HEIGHT - SLIDER_Y - SLIDER_HEIGHT + 2;
+		r.extent.height = SLIDER_Y; //SIS_SCREEN_HEIGHT - SLIDER_Y - SLIDER_HEIGHT + (2 << RESOLUTION_FACTOR) + 16 * RESOLUTION_FACTOR; // JMS_GFX
 
 		LockMutex (GraphicsLock);
 		SetContext (AnimContext);
@@ -853,7 +1026,7 @@ DoConvSummary (SUMMARY_STATE *pSS)
 		SetContextForeGroundColor (COMM_HISTORY_TEXT_COLOR);
 
 		r.extent.width -= 2 + 2;
-		t.baseline.x = 2;
+		t.baseline.x = 2 << RESOLUTION_FACTOR; // JMS_GFX
 		t.align = ALIGN_LEFT;
 		t.baseline.y = DELTA_Y_SUMMARY;
 		SetContextFont (TinyFont);
@@ -880,6 +1053,8 @@ DoConvSummary (SUMMARY_STATE *pSS)
 					!getLineWithinWidth (&t, &next, r.extent.width, (COUNT)~0);
 					++row)
 			{
+                                if (isComputerTokenConv)
+                                    removeComputerTokens(&t);
 				font_DrawText (&t);
 				t.baseline.y += DELTA_Y_SUMMARY;
 				t.pStr = next;
@@ -894,6 +1069,8 @@ DoConvSummary (SUMMARY_STATE *pSS)
 			}
 		
 			// this subtitle fit completely
+                        if (isComputerTokenConv)
+                            removeComputerTokens(&t);
 			font_DrawText (&t);
 			t.baseline.y += DELTA_Y_SUMMARY;
 		}
@@ -926,7 +1103,15 @@ DoConvSummary (SUMMARY_STATE *pSS)
 	return TRUE; // keep going
 }
 
-// Called when the player presses the select button on a response.
+/**
+ * Called when the player presses the select button on a response.
+ * Edits ENCOUNTER_STATE's response list to add the response indicated by
+ * its cur_response value to its phrase_buf...
+ * calls FeedbackPlayerPhrase on its phrase_buf...
+ * sets the music and some graphics appropriately...
+ * calls that item's response_func with the response_ref it started with
+ * That is, it primes the next set of selections.
+ */
 static void
 SelectResponse (ENCOUNTER_STATE *pES)
 {
@@ -1031,23 +1216,23 @@ PlayerResponseInput (ENCOUNTER_STATE *pE
 
 			LockMutex (GraphicsLock);
 			BatchGraphics ();
-			add_text (-2,
-					&pES->response_list[pES->cur_response].response_text);
+			add_text (-2, &pES->response_list[pES->cur_response].response_text);
 
 			pES->cur_response = response;
 
-			y = add_text (-1,
-					&pES->response_list[pES->cur_response].response_text);
+			y = add_text (-1, &pES->response_list[pES->cur_response].response_text);
+			
 			if (response < pES->top_response)
 			{
 				pES->top_response = 0;
-				RefreshResponses (pES);
+				// RefreshResponses (pES);
 			}
-			else if (y > SIS_SCREEN_HEIGHT)
+			else if ((y + RESPONSE_EXTRA_Y) > SIS_SCREEN_HEIGHT)
 			{
 				pES->top_response = response;
-				RefreshResponses (pES);
+				// RefreshResponses (pES);
 			}
+			RefreshResponses (pES);
 			UnbatchGraphics ();
 			UnlockMutex (GraphicsLock);
 		}
@@ -1152,6 +1337,14 @@ DoCommunication (ENCOUNTER_STATE *pES)
 	return FALSE;
 }
 
+/**
+ * Prepares a response to be displayed for possible selection by the player
+ * Usually called via the Response macro, from within a race's response_func.
+ * 
+ * @param ConstructStr If set, use this string. Otherwise, use the text of
+ * the (R-1)st element of ConversationPhrases. Note, this string will lose the
+ * reference it gains here - you are responsible for deallocating it.
+ */
 void
 DoResponsePhrase (RESPONSE_REF R, RESPONSE_FUNC response_func,
 		UNICODE *ConstructStr)
@@ -1196,11 +1389,13 @@ DoResponsePhrase (RESPONSE_REF R, RESPON
 static void
 HailAlien (void)
 {
+	COUNT i;
 	ENCOUNTER_STATE ES;
 	FONT PlayerFont, OldFont;
 	MUSIC_REF SongRef = 0;
 	Color TextBack;
-
+	DWORD tmpseed;
+	
 	pCurInputState = &ES;
 	memset (pCurInputState, 0, sizeof (*pCurInputState));
 
@@ -1208,6 +1403,7 @@ HailAlien (void)
 
 	ES.InputFunc = DoCommunication;
 	PlayerFont = LoadFont (PLAYER_FONT);
+	ComputerFont = LoadFont (COMPUTER_FONT);
 
 	CommData.AlienFrame = CaptureDrawable (
 			LoadGraphic (CommData.AlienFrameRes));
@@ -1222,9 +1418,24 @@ HailAlien (void)
 	else
 		CommData.AlienSong = LoadMusic (CommData.AlienSongRes);
 
-	CommData.ConversationPhrases = CaptureStringTable (
-			LoadStringTable (CommData.ConversationPhrasesRes));
-
+  if (CommData.ConversationPhrases == NULL) // could be initialized by conversation manager
+	  CommData.ConversationPhrases = CaptureStringTable (
+	  		LoadStringTable (CommData.ConversationPhrasesRes));
+
+	// BW: choose the features for the captain
+	// When available, EncounterGroup is used as a seed
+	// so that the same ship always gets the same captain
+	if(LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY)
+		tmpseed = TFB_SeedRandom(EncounterGroup);
+	for (i = 0 ; i < CommData.NumFeatures ; i++)
+		{
+			CommData.AlienFeatureChoice[i] = CommData.AlienFeatureArray[i].StartIndex;
+			CommData.AlienFeatureChoice[i] += (COUNT)TFB_Random () % CommData.AlienFeatureArray[i].NumFrames ;
+		}
+	if(LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY)
+		TFB_SeedRandom(tmpseed);
+	
+	
 	SubtitleText.baseline = CommData.AlienTextBaseline;
 	SubtitleText.align = CommData.AlienTextAlign;
 
@@ -1234,14 +1445,15 @@ HailAlien (void)
 	TextCacheContext = CreateContext ("TextCacheContext");
 	TextCacheFrame = CaptureDrawable (
 			CreateDrawable (WANT_PIXMAP, SIS_SCREEN_WIDTH,
-			SIS_SCREEN_HEIGHT - SLIDER_Y - SLIDER_HEIGHT + 2, 1));
+			SLIDER_Y + 2, 1));
 	SetContext (TextCacheContext);
 	SetContextFGFrame (TextCacheFrame);
-	TextBack = BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x10), 0x00);
+	TextBack = BUILD_COLOR (MAKE_RGB15 (0x01, 0x01, 0x01), 0x00);
 			// Color key for the background.
 	SetContextBackGroundColor (TextBack);
 	ClearDrawable ();
 	SetFrameTransparentColor (TextCacheFrame, TextBack);
+	//	SDL_SetAlpha(TextCacheFrame->image->NormalImg, SDL_SRCALPHA, 128);
 
 	ES.phrase_buf[0] = '\0';
 
@@ -1256,6 +1468,8 @@ HailAlien (void)
 		SetContextFGFrame (Screen);
 		GetFrameRect (CommData.AlienFrame, &r);
 		r.extent.width = SIS_SCREEN_WIDTH;
+		CommWndRect.corner.x = SIS_ORG_X; // JMS_GFX: Added these lines because of the 
+		CommWndRect.corner.y = SIS_ORG_Y; // changed init of CommWndRect in the beginning of comm.c
 		CommWndRect.extent = r.extent;
 		
 		SetTransitionSource (NULL);
@@ -1307,7 +1521,8 @@ HailAlien (void)
 	SetContextFont (OldFont);
 	UnlockMutex (GraphicsLock);
 
-	DestroyStringTable (ReleaseStringTable (CommData.ConversationPhrases));
+  if (CommData.ConversationPhrases != NULL)
+  	DestroyStringTable (ReleaseStringTable (CommData.ConversationPhrases));
 	DestroyMusic (CommData.AlienSong);
 	DestroyColorMap (ReleaseColorMap (CommData.AlienColorMap));
 	DestroyFont (CommData.AlienFont);
@@ -1317,6 +1532,7 @@ HailAlien (void)
 	DestroyDrawable (ReleaseDrawable (TextCacheFrame));
 
 	DestroyFont (PlayerFont);
+	DestroyFont (ComputerFont);
 
 	// Some support code tests either of these to see if the
 	// game is currently in comm or encounter
@@ -1371,10 +1587,10 @@ InitCommunication (CONVERSATION which_co
 
 	UnlockMutex (GraphicsLock);
 
-	if (which_comm == URQUAN_DRONE_CONVERSATION)
+	if (which_comm == TRANSPORT_CONVERSATION)
 	{
-		status = URQUAN_DRONE_SHIP;
-		which_comm = URQUAN_CONVERSATION;
+		status = TRANSPORT_SHIP;
+		which_comm = TRANSPORT_CONVERSATION;
 	}
 	else
 	{
@@ -1391,24 +1607,24 @@ InitCommunication (CONVERSATION which_co
 			status = commToShip[which_comm];
 			if (status >= YEHAT_REBEL_SHIP) {
 				/* conversation exception, set to self */
-				status = HUMAN_SHIP;
+				status = YEHAT_REBEL_SHIP;
 			}
 		}
 		ActivateStarShip (status, SPHERE_TRACKING);
 
-		if (which_comm == ORZ_CONVERSATION
+		// JMS: This initializes computer controlled battle group for melee.
+		// JMS: Removed the if condition so battle groups are inited for every race.
+		//
+		/*if (which_comm == ORZ_CONVERSATION
 				|| (which_comm == TALKING_PET_CONVERSATION
 				&& (!GET_GAME_STATE (TALKING_PET_ON_SHIP)
 				|| LOBYTE (GLOBAL (CurrentActivity)) == IN_LAST_BATTLE))
-				|| (which_comm != CHMMR_CONVERSATION
-				&& which_comm != SYREEN_CONVERSATION
-				))//&& ActivateStarShip (status, CHECK_ALLIANCE) == BAD_GUY))
-			BuildBattle (NPC_PLAYER_NUM);
+				|| (which_comm != SYREEN_CONVERSATION
+				))//&& (ActivateStarShip (status, CHECK_ALLIANCE) & BAD_GUY)))*/
+		BuildBattle (NPC_PLAYER_NUM);
 	}
 
-	LocDataPtr = init_race (
-			status != YEHAT_REBEL_SHIP ? which_comm :
-			YEHAT_REBEL_CONVERSATION);
+	LocDataPtr = init_race ( status != YEHAT_REBEL_SHIP ? which_comm : YEHAT_REBEL_CONVERSATION);
 	if (LocDataPtr)
 	{	// We make a copy here
 		CommData = *LocDataPtr;
@@ -1455,8 +1671,7 @@ InitCommunication (CONVERSATION which_co
 
 		// Clear the location flags
 		SET_GAME_STATE (GLOBAL_FLAGS_AND_DATA, 0);
-		status = (GET_GAME_STATE (BATTLE_SEGUE)
-				&& GetHeadLink (&GLOBAL (npc_built_ship_q)));
+		status = (GET_GAME_STATE (BATTLE_SEGUE) && GetHeadLink (&GLOBAL (npc_built_ship_q)));
 		if (status)
 		{
 			// Start combat
@@ -1491,7 +1706,7 @@ RaceCommunication (void)
 		/* Going into talking pet conversation */
 		ReinitQueue (&GLOBAL (npc_built_ship_q));
 		CloneShipFragment (SAMATRA_SHIP, &GLOBAL (npc_built_ship_q), 0);
-		InitCommunication (TALKING_PET_CONVERSATION);
+		InitCommunication (INVALID_CONVERSATION); // JMS: Quick fix after removing talking_pet_conversation enum.
 		if (!(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD))
 				&& GLOBAL_SIS (CrewEnlisted) != (COUNT)~0)
 		{
@@ -1508,7 +1723,7 @@ RaceCommunication (void)
 		if (GET_GAME_STATE (FOUND_PLUTO_SPATHI) == 1)
 			InitCommunication (SPATHI_CONVERSATION);
 		else if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) == 0)
-			InitCommunication (TALKING_PET_CONVERSATION);
+			InitCommunication (INVALID_CONVERSATION);  // JMS: Quick fix after removing talking_pet_conversation enum.
 		else if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) &
 				((1 << 4) | (1 << 5)))
 			// Communicate with the Ilwrath using a Hyperwave Broadcaster.
@@ -1572,8 +1787,13 @@ RaceCommunication (void)
 	if (GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD))
 		return;
 
-	if (i == CHMMR_SHIP)
-		ReinitQueue (&GLOBAL (npc_built_ship_q));
+	// JMS: What the heck is this supposed to do???
+	// Commented this one out so the chmmr battlegroups don't vanish after encounter in interplanetary.
+	// ...I think this has something to do with the fact that when sun device is used, the communication
+	// routine creates a fake "Chmmr ship" which the player is actually talking to. I'm not sure though.
+	//
+	//if (i == CHMMR_SHIP)
+	//	ReinitQueue (&GLOBAL (npc_built_ship_q));
 
 	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY)
 	{
@@ -1592,7 +1812,11 @@ RaceCommunication (void)
 		NumShips = (BYTE)CountLinks (&GLOBAL (npc_built_ship_q));
 		EncounterPtr->SD.Index = MAKE_BYTE (NumShips,
 				HINIBBLE (EncounterPtr->SD.Index));
-		EncounterPtr->SD.Index |= ENCOUNTER_REFORMING;
+		
+		// JMS: This condition makes it so that freight transport ships do not disappear upon encountering in hyperspace.
+		if(FragPtr->race_id != TRANSPORT_SHIP)
+			EncounterPtr->SD.Index |= ENCOUNTER_REFORMING;
+		
 		if (status == 0)
 			EncounterPtr->SD.Index |= ONE_SHOT_ENCOUNTER;
 
diff -ruNp src.orig/uqm/comm.h src/uqm/comm.h
--- src.orig/uqm/comm.h	2017-11-01 15:30:24 -0700
+++ src/uqm/comm.h	2017-11-01 15:31:02 -0700
@@ -14,6 +14,10 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
+// JMS 2011: Shofixti Colony comm screen is blacked out upon the first encounter.
+
 #ifndef _COMM_H
 #define _COMM_H
 
@@ -26,8 +30,8 @@
 
 #ifdef COMM_INTERNAL
 
-#define SLIDER_Y 107
-#define SLIDER_HEIGHT 15
+#define SLIDER_Y ((107 << RESOLUTION_FACTOR) + RES_CASE(0,23,46)) // JMS_GFX
+#define SLIDER_HEIGHT RES_CASE(15, 15, 30) // JMS_GFX
 
 #include "commanim.h"
 
@@ -36,7 +40,15 @@ extern LOCDATA CommData;
 static inline BOOLEAN
 haveTalkingAnim (void)
 {
-	return CommData.AlienTalkDesc.NumFrames > 0;
+	// JMS: Shofixti Colony comm screen is blacked out upon the first encounter.
+	if (CommData.AlienConv == SHOFIXTICOLONY_CONVERSATION && GET_GAME_STATE (SHOFIXTI_COLONY_MET) < 3)
+	{	
+		if (GET_GAME_STATE (SHOFIXTI_COLONY_MET) == 2)
+			SET_GAME_STATE (SHOFIXTI_COLONY_MET, 3);
+		return 0;
+	}
+	else
+		return CommData.AlienTalkDesc.NumFrames > 0;
 }
 
 static inline BOOLEAN
@@ -101,8 +113,8 @@ signaledStopTalkingAnim (void)
 
 #endif
 
-#define TEXT_X_OFFS 1
-#define TEXT_Y_OFFS 1
+#define TEXT_X_OFFS (1 << RESOLUTION_FACTOR) // JMS_GFX
+#define TEXT_Y_OFFS (1 << RESOLUTION_FACTOR) // JMS_GFX
 #define SIS_TEXT_WIDTH (SIS_SCREEN_WIDTH - (TEXT_X_OFFS << 1))
 
 extern void init_communication (void);
diff -ruNp src.orig/uqm/commanim.c src/uqm/commanim.c
--- src.orig/uqm/commanim.c	2017-11-01 15:30:24 -0700
+++ src/uqm/commanim.c	2017-11-01 15:31:02 -0700
@@ -16,6 +16,13 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: Added several mechanics pertaining to talk transition animations (tailor-made for syreen comm zoom-in!)
+
+// BW: to be checked. I've tried to remove what's supposed to be removed while keeping the Syreen zoom-in feature.
+// It may have to be re-programmed in the new commanim style.
+
+// JMS 2011: Shofixti Colony comm screen is blacked out upon the first encounter.
+
 #define COMM_INTERNAL
 #include "commanim.h"
 
@@ -26,6 +33,8 @@
 #include "libs/graphics/cmap.h"
 #include "libs/mathlib.h"
 
+#include "libs/graphics/gfx_common.h"
+
 
 static TimeCount LastTime;
 static SEQUENCE Sequences[MAX_ANIMATIONS + 2];
@@ -354,10 +363,30 @@ AdvanceTransitSequence (SEQUENCE *pSeq,
 void
 InitCommAnimations (void)
 {
+	COUNT i;
+	
 	ActiveMask = 0;
 
 	TalkDesc = CommData.AlienTalkDesc;
 	TransitDesc = CommData.AlienTransitionDesc;
+	
+	// JMS: Shofixti Colony comm screen is blacked out upon the first encounter.
+	if (CommData.AlienConv == SHOFIXTICOLONY_CONVERSATION)
+	{
+		if (GET_GAME_STATE (SHOFIXTI_COLONY_MET) < 2)
+			TalkDesc.AnimFlags |= ANIM_DISABLED;
+	
+		for (i = 0; i < CommData.NumAnimations; ++i)
+		{
+			ANIMATION_DESC *ADPtr = &CommData.AlienAmbientArray[i];
+		
+			// JMS: Turn on the anims & disable black screen when the time is right.
+			if ((GET_GAME_STATE (SHOFIXTI_COLONY_MET) == 0 && i < CommData.NumAnimations - 1)
+				|| (GET_GAME_STATE (SHOFIXTI_COLONY_MET) >= 1 && i == CommData.NumAnimations - 1)
+				)
+				ADPtr->AnimFlags |= ANIM_DISABLED;
+		}
+	}
 
 	// Animation sequences have to be drawn in reverse, and
 	// talk animations have to be drawn last (so we add them first)
@@ -406,8 +435,24 @@ ProcessCommAnimations (BOOLEAN FullRedra
 		{
 			ANIMATION_DESC *ADPtr = pSeq->ADPtr;
 			DWORD ActiveBit = 1L << i;
-
-			if (ADPtr->AnimFlags & ANIM_DISABLED)
+			
+			// JMS: Shofixti Colony comm screen anims start after lighting up.
+			if (ADPtr->AnimFlags & ANIM_DISABLED
+				&& CommData.AlienConv == SHOFIXTICOLONY_CONVERSATION 
+				&& GET_GAME_STATE (SHOFIXTI_COLONY_MET) > 1
+				&& i < CommData.NumAnimations - 1
+				)
+				ADPtr->AnimFlags &= ~ANIM_DISABLED;
+
+			// JMS: Shofixti Colony comm screen is blacked out upon the first encounter.
+			if ((ADPtr->AnimFlags & ANIM_DISABLED) 
+				|| (CommData.AlienConv == SHOFIXTICOLONY_CONVERSATION 
+					&& GET_GAME_STATE (SHOFIXTI_COLONY_MET) == 0
+					&& i < CommData.NumAnimations - 1)
+				|| (CommData.AlienConv == SHOFIXTICOLONY_CONVERSATION 
+					&& GET_GAME_STATE (SHOFIXTI_COLONY_MET) >= 1
+					&& i == CommData.NumAnimations - 1)
+				)
 				continue;
 			
 			if (pSeq->Direction == NO_DIR)
@@ -465,14 +510,51 @@ ProcessCommAnimations (BOOLEAN FullRedra
 					CanTalk = FALSE;
 				}
 			}
+// BW: to be checked. I've tried to remove what's supposed to be removed while keeping the Syreen zoom-in feature.
+// It may have to be re-programmed in the new commanim style.
+			if (pSeq->AnimType == PICTURE_ANIM
+				&& (ADPtr->AnimFlags & CommData.AlienTalkDesc.AnimFlags & WAIT_TALKING)
+				&& pSeq->Direction != NO_DIR)
+			{
+				// JMS: Cut marked animations short when starting talk.
+				// The animations are marked with FAST_STOP_AT_TALK_START in the races' comm source codes.
+				if (ADPtr->AnimFlags & FAST_STOP_AT_TALK_START)
+				{	CanTalk = TRUE;
+					//pSeq->AnimObj.CurFrame = SetAbsFrameIndex(pSeq->AnimObj.CurFrame, ADPtr->StartIndex);
+					pSeq->Direction = NO_DIR;
+				}
+			}
+			
+			// JMS: This handles ambient animations which should occur only during talk
+			// A lot of conditions are necessary to eliminate unwanted animations
+			// from the duration of talk transition!
+			if (pSeq->AnimType == PICTURE_ANIM
+				&& ADPtr->AnimFlags & WHEN_TALKING 
+				&& (!(CommData.AlienTalkDesc.AnimFlags & WAIT_TALKING) 
+					|| (CommData.AlienTalkDesc.AnimFlags & TALK_INTRO)
+					|| (CommData.AlienTalkDesc.AnimFlags & TALK_DONE))
+				&& !(CommData.AlienTransitionDesc.AnimFlags & PAUSE_TALKING)
+				&& pSeq->Direction != NO_DIR)
+			{
+				// Stop the anim if not talking
+				pSeq->Direction = NO_DIR;
+			}
+			
 		}
 		// All ambient animations have been processed. Advance the mask.
 		ActiveMask = NextActiveMask;
-
+		
 		// Process the talking and transition animations
 		if (CanTalk	&& haveTalkingAnim () && runningTalkingAnim ())
 		{
 			BOOLEAN done = FALSE;
+//			for (i = 0; i < CommData.NumAnimations; i++)
+//				if (ActiveMask & (1L << i)
+//					&& CommData.AlienAmbientArray[i].AnimFlags & WAIT_TALKING
+//					&& !(CommData.AlienAmbientArray[i].AnimFlags & FAST_STOP_AT_TALK_START)) // JMS: Don't wait for fast-stopped animations
+//					done = TRUE;															 // to finish (would have to wait forever).
+//			if (!done)
+//			{
 
 			if (signaledStopTalkingAnim () && haveTransitionAnim ())
 			{	// Run the transition. We will clear everything
@@ -520,6 +602,19 @@ ProcessCommAnimations (BOOLEAN FullRedra
 
 			if (ColorChange)
 				FullRedraw = TRUE;
+			
+			// JMS: Shofixti Colony comm screen lights up.
+			if (CommData.AlienConv == SHOFIXTICOLONY_CONVERSATION 
+				&& GET_GAME_STATE (SHOFIXTI_COLONY_MET) == 1)
+			{
+				LockMutex (GraphicsLock);
+				SetTransitionSource (&CommWndRect);
+				DrawAlienFrame (NULL, 0, TRUE);
+				ScreenTransition (3, &CommWndRect);
+				UnlockMutex (GraphicsLock);
+				SET_GAME_STATE (SHOFIXTI_COLONY_MET, 2);
+				CommData.AlienAmbientArray[CommData.NumAnimations-1].AnimFlags |= ANIM_DISABLED;
+			}
 
 			// Colormap animations are processed separately
 			// from picture anims (see XFormColorMap_step)
diff -ruNp src.orig/uqm/commanim.h src/uqm/commanim.h
--- src.orig/uqm/commanim.h	2017-11-01 15:30:24 -0700
+++ src/uqm/commanim.h	2017-11-01 15:31:02 -0700
@@ -52,7 +52,11 @@
 #define TALK_DONE (1 << 6)
 		// In AlienTransitionDesc: indicates a transition to silent state
 		// In AlienTalkDesc: signals the end of talking animation
-#define ANIM_DISABLED (1 << 7)
+#define WHEN_TALKING (1L << 7) // JMS
+#define ANIM_DISABLED (1L << 8) // BW (needed for news anchor and animated background)
+
+#define FAST_STOP_AT_TALK_START TALK_DONE // JMS: If there's a very loooong animation, it can be forced to stop when talking with this.
+					  // (otherwise there'll be nasty, unwanted pauses in the conversation.)
 
 #define COLORXFORM_ANIM PAUSE_TALKING
 
@@ -68,9 +72,10 @@ typedef struct
 	BYTE NumFrames;
 			// Number of frames in the animation.
 
-	BYTE AnimFlags;
+	COUNT AnimFlags;
 			// One of RANDOM_ANIM, CIRCULAR_ANIM, or YOYO_ANIM
 			// plus flags (WAIT_TALKING, ANIM_DISABLED)
+			// JMS: Changed from BYTE to COUNT to house more possible flags
 
 	COUNT BaseFrameRate;
 			// Minimum interframe delay
@@ -89,7 +94,7 @@ typedef struct
 			// due to the image overlap conflicts.
 } ANIMATION_DESC;
 
-#define MAX_ANIMATIONS 20
+#define MAX_ANIMATIONS 30 // JMS: Was 20
 
 
 #ifdef COMM_INTERNAL
diff -ruNp src.orig/uqm/commglue.c src/uqm/commglue.c
--- src.orig/uqm/commglue.c	2017-11-01 15:30:24 -0700
+++ src/uqm/commglue.c	2017-11-01 15:31:02 -0700
@@ -16,6 +16,10 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2009: -Added earthling ship and Androsynth dialogue screen hooks
+// JMS 2010: -Removed unnecessary init_commander_comm
+//			 -Added transport ship dialogue screen hook
+
 #include "commglue.h"
 
 #include "races.h"
@@ -26,12 +30,26 @@
 #include <assert.h>
 #include "libs/log.h"
 
-static int NPCNumberPhrase (int number, const char *fmt, UNICODE **ptrack);
+int NPCNumberPhrase (int number, UNICODE **ptrack);
 
+/**
+ * Gets the content for index and loads it into the current conversation,
+ * using the voice track cb if provided, or making one itself if not.
+ * 
+ * The indices are:
+ * - 1 000 000 : captain's name
+ *   - 999 999 : ship's name
+ *   - 999 998 : ship's location
+ * numbers from -999 997 to 998 997 : display the name of your alliance
+ * (not sure why this one option needs 1001 indices)
+ * numbers from -998 996 to -1 : alien number speech (sign is flipped)
+ *           0 : say and do nothing
+ * positive numbers : entries from the current alien conversation's string table 
+ */
 void
 NPCPhrase_cb (int index,  TFB_TrackCB cb)
 {
-	UNICODE *pStr, buf[400];
+	UNICODE *pStr, numbuf[400];
 	void *pClip, *pTimeStamp;
 
 	switch (index)
@@ -46,25 +64,54 @@ NPCPhrase_cb (int index,  TFB_TrackCB cb
 			pClip = 0;
 			pTimeStamp = 0;
 			break;
+		case GLOBAL_PLAYER_LOCATION:
+		{
+			SIZE dx, dy;
+			COUNT adx, ady;
+
+			dx = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x)) - 333;
+			adx = dx >= 0 ? dx : -dx;
+			dy = 9812 - LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
+			ady = dy >= 0 ? dy : -dy;
+			sprintf (numbuf,
+					"%+04d.%01u,%+04d.%01u",
+					(SIZE)(dy / 10), (COUNT)(ady % 10),
+					(SIZE)(dx / 10), (COUNT)(adx % 10));
+			pStr = numbuf;
+			pClip = 0;
+			pTimeStamp = 0;
+			break;
+		}
 		case 0:
 		{
 			return;
 		}
 		default:
 			if (index < 0)
-			{	// One of the alliance name variants
-				COUNT i;
-				STRING S;
-
-				index -= GLOBAL_ALLIANCE_NAME;
-
-				i = GET_GAME_STATE (NEW_ALLIANCE_NAME);
-				S = SetAbsStringTableIndex (CommData.ConversationPhrases, (index - 1) + i);
-				strcpy (buf, (UNICODE *)GetStringAddress (S));
-				if (i == 3)
-					strcat (buf, GLOBAL_SIS (CommanderName));
+			{
+				if (index > UNREASONABLE_NUMBER)
+				{
+					if (CommData.AlienNumberSpeech)
+					{
+						NPCNumberPhrase (-index, NULL);
+						return;
+					}
+					sprintf (numbuf, "%d", -index);
+				}
+				else
+				{
+					COUNT i;
+					STRING S;
 
-				pStr = buf;
+					index -= GLOBAL_ALLIANCE_NAME;
+
+					i = GET_GAME_STATE (NEW_ALLIANCE_NAME);
+					S = SetAbsStringTableIndex (CommData.ConversationPhrases, (index - 1) + i);
+					strcpy (numbuf, (UNICODE *)GetStringAddress (S));
+					if (i == 3)
+						strcat (numbuf, GLOBAL_SIS (CommanderName));
+				}
+				pStr = numbuf;
 				pClip = 0;
 				pTimeStamp = 0;
 			}
@@ -83,59 +130,13 @@ NPCPhrase_cb (int index,  TFB_TrackCB cb
 			break;
 	}
 
+	if (GLOBAL (glob_flags) & VOICE_DISABLED || pClip == NULL)
+		pClip = "noname.ogg";
 	SpliceTrack (pClip, pStr, pTimeStamp, cb);
 }
 
-// Special case variant: prevents page breaks.
-void
-NPCPhrase_splice (int index)
-{
-	UNICODE *pStr;
-	void *pClip;
-
-	assert (index >= 0);
-	if (index == 0)
-		return;
-
-	pStr = (UNICODE *)GetStringAddress (
-			SetAbsStringTableIndex (CommData.ConversationPhrases, index - 1));
-	pClip = GetStringSoundClip (
-			SetAbsStringTableIndex (CommData.ConversationPhrases, index - 1));
-
-	if (!pClip)
-	{	// Just appending some text
-		SpliceTrack (NULL, pStr, NULL, NULL);
-	}
-	else
-	{	// Splicing in some voice
-		UNICODE *tracks[] = {NULL, NULL};
-
-		tracks[0] = pClip;
-		SpliceMultiTrack (tracks, pStr);
-	}
-}
-
-void
-NPCNumber (int number, const char *fmt)
-{
-	UNICODE buf[32];
-
-	if (!fmt)
-		fmt = "%d";
-
-	if (CommData.AlienNumberSpeech)
-	{
-		NPCNumberPhrase (number, fmt, NULL);
-		return;
-	}
-	
-	// just splice in the subtitle text
-	snprintf (buf, sizeof buf, fmt, number);
-	SpliceTrack (NULL, buf, NULL, NULL);
-}
-
-static int
-NPCNumberPhrase (int number, const char *fmt, UNICODE **ptrack)
+int
+NPCNumberPhrase (int number, UNICODE **ptrack)
 {
 #define MAX_NUMBER_TRACKS 20
 	NUMBER_SPEECH speech = CommData.AlienNumberSpeech;
@@ -144,7 +145,6 @@ NPCNumberPhrase (int number, const char
 	int toplevel = 0;
 	UNICODE *TrackNames[MAX_NUMBER_TRACKS];
 	UNICODE numbuf[60];
-	const SPEECH_DIGIT* dig = NULL;
 
 	if (!speech)
 		return 0;
@@ -152,17 +152,15 @@ NPCNumberPhrase (int number, const char
 	if (!ptrack)
 	{
 		toplevel = 1;
-		if (!fmt)
-			fmt = "%d";
-		sprintf (numbuf, fmt, number);
+		sprintf (numbuf, "%d", number);
 		ptrack = TrackNames;
 	}
 
 	for (i = 0; i < speech->NumDigits; ++i)
 	{
+		SPEECH_DIGIT* dig = speech->Digits + i;
 		int quot;
 
-		dig = speech->Digits + i;
 		quot = number / dig->Divider;
 	
 		if (quot == 0)
@@ -188,7 +186,7 @@ NPCNumberPhrase (int number, const char
 		}
 		else
 		{
-			int ctracks = NPCNumberPhrase (quot, NULL, ptrack);
+			int ctracks = NPCNumberPhrase (quot, ptrack);
 			ptrack += ctracks;
 			queued += ctracks;
 		}
@@ -203,7 +201,9 @@ NPCNumberPhrase (int number, const char
 				{
 					*ptrack++ = GetStringSoundClip (
 							SetAbsStringTableIndex (
-							CommData.ConversationPhrases, name->StrIndex - 1));
+							CommData.ConversationPhrases,
+							(COUNT) (name->StrIndex - 1)
+							));
 					queued++;
 					break;
 				}
@@ -212,7 +212,9 @@ NPCNumberPhrase (int number, const char
 		else if (dig->CommonNameIndex != 0)
 		{
 			*ptrack++ = GetStringSoundClip (SetAbsStringTableIndex (
-					CommData.ConversationPhrases, dig->CommonNameIndex - 1));
+					CommData.ConversationPhrases,
+					(COUNT) (dig->CommonNameIndex - 1)
+					));
 			queued++;
 		}
 
@@ -223,9 +225,11 @@ NPCNumberPhrase (int number, const char
 	{
 		if (queued == 0)
 		{	// nothing queued, say "zero"
-			assert (number == 0);
 			*ptrack++ = GetStringSoundClip (SetAbsStringTableIndex (
-					CommData.ConversationPhrases, dig->StrDigits[number] - 1));
+					CommData.ConversationPhrases,
+					speech->Digits[speech->NumDigits - 1].StrDigits[0]
+					));
+			
 		}
 		*ptrack++ = NULL; // term
 		
@@ -313,6 +317,8 @@ init_race (CONVERSATION comm_id)
 {
 	switch (comm_id)
 	{
+		case ANDROSYNTH_CONVERSATION:		// BY JMS - Hook to Androsynth dialogue screen
+			return init_androsynth_comm ();
 		case ARILOU_CONVERSATION:
 			return init_arilou_comm ();
 		case BLACKURQ_CONVERSATION:
@@ -320,14 +326,19 @@ init_race (CONVERSATION comm_id)
 		case CHMMR_CONVERSATION:
 			return init_chmmr_comm ();
 		case COMMANDER_CONVERSATION:
-			if (!GET_GAME_STATE (STARBASE_AVAILABLE))
-				return init_commander_comm ();
-			else
-				return init_starbase_comm ();
+			// JMS: Commented out the unnecessary init_commander_comm
+			//if (!GET_GAME_STATE (STARBASE_AVAILABLE))
+			//	return init_commander_comm ();
+			//else
+			return init_starbase_comm ();
 		case DRUUGE_CONVERSATION:
 			return init_druuge_comm ();
+		case HUMAN_CONVERSATION:			// BY JMS - Hook to earthling ship dialogue screen
+			return init_human_comm ();
 		case ILWRATH_CONVERSATION:
 			return init_ilwrath_comm ();
+		case LURG_CONVERSATION:				// BY JMS - Hook to Lurg ship dialogue screen
+			return init_lurg_comm ();
 		case MELNORME_CONVERSATION:
 			return init_melnorme_comm ();
 		case MYCON_CONVERSATION:
@@ -338,23 +349,26 @@ init_race (CONVERSATION comm_id)
 			return init_pkunk_comm ();
 		case SHOFIXTI_CONVERSATION:
 			return init_shofixti_comm ();
+		case SHOFIXTICOLONY_CONVERSATION:
+			return init_shofixticolony_comm (); // BY JMS - Hook to Shofixti colony dialogue screen
 		case SLYLANDRO_CONVERSATION:
 			return init_slyland_comm ();
 		case SLYLANDRO_HOME_CONVERSATION:
 			return init_slylandro_comm ();
 		case SPATHI_CONVERSATION:
-			if (!(GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 7)))
-				return init_spathi_comm ();
-			else
-				return init_spahome_comm ();
+			return init_spahome_comm ();
 		case SUPOX_CONVERSATION:
 			return init_supox_comm ();
 		case SYREEN_CONVERSATION:
 			return init_syreen_comm ();
-		case TALKING_PET_CONVERSATION:
-			return init_talkpet_comm ();
+		case SYREENBASE_CONVERSATION:
+			return init_syreenbase_comm ();
+		case SYREENHOME_CONVERSATION:
+			return init_syreenhome_comm ();
 		case THRADD_CONVERSATION:
 			return init_thradd_comm ();
+		case TRANSPORT_CONVERSATION:			// BY JMS - Hook to transport ship dialogue screen
+			return init_transport_comm ();
 		case UMGAH_CONVERSATION:
 			return init_umgah_comm ();
 		case URQUAN_CONVERSATION:
@@ -367,6 +381,8 @@ init_race (CONVERSATION comm_id)
 			return init_rebel_yehat_comm ();
 		case YEHAT_CONVERSATION:
 			return init_yehat_comm ();
+		case YEHATPKUNK_CONVERSATION:
+			return init_yehatpkunk_comm ();
 		case ZOQFOTPIK_CONVERSATION:
 			return init_zoqfot_comm ();
 		default:
diff -ruNp src.orig/uqm/commglue.h src/uqm/commglue.h
--- src.orig/uqm/commglue.h	2017-11-01 15:30:24 -0700
+++ src/uqm/commglue.h	2017-11-01 15:31:02 -0700
@@ -16,6 +16,10 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2009: -Added earthling ship conversation enum and extern locdata
+//			 -Added Androsynth conversation enum and extern locdata
+// JMS 2010: -AddedTransport conversation enum and extern locdata
+
 #ifndef _COMMGLUE_H
 #define _COMMGLUE_H
 
@@ -23,36 +27,6 @@
 #include "resinst.h"
 #include "libs/sound/trackplayer.h"
 
-typedef enum {
-	ARILOU_CONVERSATION,
-	CHMMR_CONVERSATION,
-	COMMANDER_CONVERSATION,
-	ORZ_CONVERSATION,
-	PKUNK_CONVERSATION,
-	SHOFIXTI_CONVERSATION,
-	SPATHI_CONVERSATION,
-	SUPOX_CONVERSATION,
-	THRADD_CONVERSATION,
-	UTWIG_CONVERSATION,
-	VUX_CONVERSATION,
-	YEHAT_CONVERSATION,
-	MELNORME_CONVERSATION,
-	DRUUGE_CONVERSATION,
-	ILWRATH_CONVERSATION,
-	MYCON_CONVERSATION,
-	SLYLANDRO_CONVERSATION,
-	UMGAH_CONVERSATION,
-	URQUAN_CONVERSATION,
-	ZOQFOTPIK_CONVERSATION,
-	SYREEN_CONVERSATION,
-	BLACKURQ_CONVERSATION,
-	TALKING_PET_CONVERSATION,
-	SLYLANDRO_HOME_CONVERSATION,
-	URQUAN_DRONE_CONVERSATION,
-	YEHAT_REBEL_CONVERSATION,
-	INVALID_CONVERSATION,
-} CONVERSATION;
-
 extern LOCDATA CommData;
 extern UNICODE shared_phrase_buf[2048];
 
@@ -74,7 +48,10 @@ enum
 {
 	GLOBAL_PLAYER_NAME = -1000000,
 	GLOBAL_SHIP_NAME,
+	GLOBAL_PLAYER_LOCATION,
+
 	GLOBAL_ALLIANCE_NAME,
+	UNREASONABLE_NUMBER = GLOBAL_ALLIANCE_NAME + 1000,
 };
 
 typedef COUNT RESPONSE_REF;
@@ -87,8 +64,6 @@ extern void DoNPCPhrase (UNICODE *pStr);
 
 extern void NPCPhrase_cb (int index, TFB_TrackCB cb);
 #define NPCPhrase(index) NPCPhrase_cb ((index), NULL)
-extern void NPCPhrase_splice (int index);
-extern void NPCNumber (int number, const char *fmt);
 
 #define ALLIANCE_NAME_BUFSIZE 256
 extern void GetAllianceName (UNICODE *buf, RESPONSE_REF name_1);
@@ -98,6 +73,8 @@ extern void construct_response (UNICODE
 
 extern LOCDATA* init_race (CONVERSATION comm_id);
 
+extern LOCDATA* init_androsynth_comm (void);	// BY JMS
+
 extern LOCDATA* init_arilou_comm (void);
 
 extern LOCDATA* init_blackurq_comm (void);
@@ -108,7 +85,11 @@ extern LOCDATA* init_commander_comm (voi
 
 extern LOCDATA* init_druuge_comm (void);
 
-extern LOCDATA* init_ilwrath_comm (void);
+extern LOCDATA* init_human_comm (void);			// BY JMS
+
+extern LOCDATA* init_ilwrath_comm (void);		// BY JMS
+
+extern LOCDATA* init_lurg_comm (void);
 
 extern LOCDATA* init_melnorme_comm (void);
 
@@ -122,6 +103,8 @@ extern LOCDATA* init_rebel_yehat_comm (v
 
 extern LOCDATA* init_shofixti_comm (void);
 
+extern LOCDATA* init_shofixticolony_comm (void);
+
 extern LOCDATA* init_slyland_comm (void);
 
 extern LOCDATA* init_slylandro_comm (void);
@@ -136,10 +119,16 @@ extern LOCDATA* init_supox_comm (void);
 
 extern LOCDATA* init_syreen_comm (void);
 
+extern LOCDATA* init_syreenbase_comm (void); // BW
+
+extern LOCDATA* init_syreenhome_comm (void); // JMS
+
 extern LOCDATA* init_talkpet_comm (void);
 
 extern LOCDATA* init_thradd_comm (void);
 
+extern LOCDATA* init_transport_comm (void); // JMS
+
 extern LOCDATA* init_umgah_comm (void);
 
 extern LOCDATA* init_urquan_comm (void);
@@ -150,6 +139,8 @@ extern LOCDATA* init_vux_comm (void);
 
 extern LOCDATA* init_yehat_comm (void);
 
+extern LOCDATA* init_yehatpkunk_comm (void);
+
 extern LOCDATA* init_zoqfot_comm (void);
 
 extern LOCDATA* init_umgah_comm (void);
diff -ruNp src.orig/uqm/confirm.c src/uqm/confirm.c
--- src.orig/uqm/confirm.c	2017-11-01 15:30:24 -0700
+++ src/uqm/confirm.c	2017-11-01 15:31:02 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
 #include "controls.h"
 #include "colors.h"
 #include "settings.h"
@@ -32,8 +34,8 @@
 #include <stdlib.h>
 
 
-#define CONFIRM_WIN_WIDTH 80
-#define CONFIRM_WIN_HEIGHT 22
+#define CONFIRM_WIN_WIDTH (80 << RESOLUTION_FACTOR) // JMS_GFX
+#define CONFIRM_WIN_HEIGHT (22 << RESOLUTION_FACTOR) // JMS_GFX
 
 static void
 DrawConfirmationWindow (BOOLEAN answer)
@@ -53,12 +55,12 @@ DrawConfirmationWindow (BOOLEAN answer)
 			SHADOWBOX_DARK_COLOR, SHADOWBOX_MEDIUM_COLOR);
 
 	t.baseline.x = r.corner.x + (r.extent.width >> 1);
-	t.baseline.y = r.corner.y + 8;
+	t.baseline.y = r.corner.y + (8 << RESOLUTION_FACTOR); // JMS_GFX
 	t.pStr = GAME_STRING (QUITMENU_STRING_BASE); // "Really Quit?"
 	t.align = ALIGN_CENTER;
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
-	t.baseline.y += 10;
+	t.baseline.y += (10 << RESOLUTION_FACTOR); // JMS_GFX
 	t.baseline.x = r.corner.x + (r.extent.width >> 2);
 	t.pStr = GAME_STRING (QUITMENU_STRING_BASE + 1); // "Yes"
 	SetContextForeGroundColor (answer ? MENU_HIGHLIGHT_COLOR : MENU_TEXT_COLOR);
diff -ruNp src.orig/uqm/conversation.c src/uqm/conversation.c
--- src.orig/uqm/conversation.c	1969-12-31 16:00:00 -0800
+++ src/uqm/conversation.c	2017-11-01 15:31:02 -0700
@@ -0,0 +1,1401 @@
+/*
+ *  conversation.c
+ * 
+ *  Created by Luke Somers on 2012-01-20, for Project 6014.
+ *
+ */
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <math.h>
+
+#include "libs/strings/strintrn.h"
+#include "libs/strlib.h"
+#include "libs/uio.h"
+
+#include "conversation.h"
+#include "comm.h"
+#include "options.h"
+
+#include <glib.h>
+
+# define GET_LINE (get_line (line, sizeof (line), hook))
+/* with its whitespace trimmed and any '//'-style comments stripped */
+/* if there's no such line, return NULL */
+
+/*
+ Concerning members  'GSList *lines;':
+ 
+ The format of this is alternating.
+ 
+ Odd element: index, stored directly by casting to pointer, of text in string table, or '0' for nothing.
+ Even element: char* pointing to string that needs to be evaluated, or '0' for nothing.
+ 
+ Indices in string table start at 1.
+ */
+
+
+struct ConditionsConsequences_s { /* all these lists are type char* */
+	GSList *needed;
+	GSList *blocking;
+	GSList *consequences;
+};
+typedef struct ConditionsConsequences_s ConditionsConsequences;
+
+static void freeCC(ConditionsConsequences *cc) {
+	g_slist_free_full(cc->needed, g_free);
+	g_slist_free_full(cc->blocking, g_free);
+	g_slist_free_full(cc->consequences, g_free);
+	g_free(cc);
+}
+
+struct DeclarationGoodies_s {
+	char *name;
+	ConditionsConsequences *cc;
+};
+typedef struct DeclarationGoodies_s DeclarationGoodies;
+
+struct ConversationGreeting_s {
+	GSList *lines; // see note above
+	char *proceed;
+	ConditionsConsequences *cc;
+};
+typedef struct ConversationGreeting_s ConversationGreeting;
+
+static void freeLines(GSList *lines) {
+	GSList *walk = lines;
+	while (walk) {
+		// odd entries are integers. don't free.
+		walk = g_slist_next(walk);
+		if (!walk) break;
+		g_free(walk->data);
+		walk = g_slist_next(walk);
+	}
+	g_slist_free(lines);
+} // end freeLines(GSList *lines)
+
+static void freeGreeting(ConversationGreeting *cg) {
+	freeLines(cg->lines);
+	g_free(cg->proceed);
+	freeCC(cg->cc);
+	g_free(cg);
+}
+
+struct ConversationOption_s {
+	char *name;
+	char *say;  // a string that needs to be substituted-into.
+	GSList *lines; // see note above
+	char *proceed;
+	ConditionsConsequences *cc;
+};
+typedef struct ConversationOption_s ConversationOption;
+
+static void freeOption(ConversationOption *co) {
+	g_free(co->name);
+	g_free(co->say);
+	freeLines(co->lines);
+	g_free(co->proceed);
+	freeCC(co->cc);
+	g_free(co);
+}
+
+struct ConversationNode_s {
+	char *name;
+	GSList *options; /* the data type is ConversationOption*, with that a pointer, not array */
+	ConditionsConsequences *cc;
+};
+typedef struct ConversationNode_s ConversationNode;
+
+static void freeNode(ConversationNode *cn) {
+	g_free(cn->name);
+	g_slist_free_full(cn->options, freeOption);
+	freeCC(cn->cc);
+	g_free(cn);
+}
+
+struct ConversationText_s {
+	char *name;
+	GSList* lines; // see note above
+	ConditionsConsequences *cc;
+};
+typedef struct ConversationText_s ConversationText;
+
+static void freeText(ConversationText *ct) {
+	g_free(ct->name);
+	freeLines(ct->lines);
+	freeCC(ct->cc);
+	g_free(ct);
+}
+
+struct ConversationModel_s {
+	GSList *initializers;
+	GSList *greetings;
+	GSList *nodes;
+	GSList *texts;
+	const char *name;
+	STRING_TABLE table;
+};
+typedef struct ConversationModel_s ConversationModel;
+
+static void freeModel(ConversationModel *cm) {
+	g_slist_free_full(cm->initializers, freeCC);
+	g_slist_free_full(cm->greetings, freeGreeting);
+	g_slist_free_full(cm->nodes, freeNode);
+	g_slist_free_full(cm->texts, freeText);
+	g_free(cm->name);
+// 	DestroyStringTable (cm->table);
+	// ^ no need to do this for now, since it's done in comm: HailAlien
+	g_free(cm);
+}
+
+struct StringTableBuilder_s {
+	GSList *list; // in 'mommy', of type STRING_TABLE_ENTRY_DESC. In 'baby', of type char
+	int length;
+	STRING_TABLE parent; // not used by 'baby' string table builders
+};
+typedef struct StringTableBuilder_s StringTableBuilder;
+
+/*
+ perhaps ConversationModel should contain the pointer to the whole file and its length,
+ so that when the time comes to free it, the disposal is very easy. Then we don't need to
+ reallocate anything, just insert nulls and set the pointers appropriately. There will be
+ a little bloat for the comments and the keywords, but it could be better overall.
+ */
+
+# define ERR1 "In file \n"
+# define ERR2 "Found a line where we were expecting a keyword 'greeting', 'node', or 'text':"
+# define ERR3 "Check for a dialog line beginning with '.' - if so, put a {} before it. It'll be invisible."
+
+# define ERR4 "A body of text (not necessarily a text item) was not terminated with a '.'"
+
+
+/* could also maintain a line number for pinpointing errors,
+ in which case we'll need to include a pointer to that in uio_Stream *hook. */
+
+static DeclarationGoodies initCode (char *line);
+static GSList *extractSubstitutions(StringTableBuilder *stb, uio_Stream *hook, char **lastLine);
+static ConversationGreeting *parseGreeting (char *line, uio_Stream *hook, StringTableBuilder *stb);
+static ConversationNode *parseNode (char *line);
+static ConversationOption *parseOption (char *line, uio_Stream *hook, StringTableBuilder *stb);
+static ConversationText *parseTextItem (char *line, uio_Stream *hook, StringTableBuilder *stb);
+static void validateNode (ConversationNode *node);
+static int add_string (StringTableBuilder *stb, char *line);
+static char *get_line (char *buf, int len, uio_Stream *hook);
+static int checkForCase (const char* str);
+static int plusesAndMinuses (const char *expression);
+static char *nextPlusOrBinaryMinus (const char *string);
+static void applyConsequences (ConditionsConsequences *cc, ConversationModel *cm);
+static void setVal (char *name, int newval, ConversationModel *cm);
+// static guint hash_djb2i(gconstpointer *p);
+static GSList *getOptionList(ConversationNode* cn, ConversationModel *cm);
+static ConversationNode *getNode (char *name, ConversationModel *cm);
+static ConversationText *getTextItem (char *name, ConversationModel *cm);
+static gboolean checkConditions (ConditionsConsequences* cc, ConversationModel* cm);
+static int arithmetic(char *expression, ConversationModel *cm);
+static int innerArithmetic (char *expression, ConversationModel *cm);
+static int evaluatePrimitive (char* expression, ConversationModel *cm);
+static int import_string (StringTableBuilder *baby, StringTableBuilder *mommy);
+static void displaySubstituted (GSList *things);
+static int myRandom();
+
+
+// GLOBAL INTERNAL STATE
+static GSList *currentOptions;
+static ConversationModel *currentModel;
+static GHashTable *transientState;
+static char *source;
+static int percent;
+static ConversationModel *allModels;
+// END GLOBALS
+
+
+/*
+ 
+ overall status:
+ ALL: untested, probably won't compile. 'okay' means just that I don't KNOW
+ of any errors or incompleteness.
+ 
+ -- parsing:
+  added lines to string tables and store indices instead of storing in
+ objects as strings
+ 
+ -- conversation logic:
+ once the above is handled, call the appropriate usual functions on it. Will
+ be easy, I hope?
+ add in state gets and sets
+ 
+ -- substitution and arithmetic:
+ need to incorporate callbacks to speech generation (if nonnull)
+ 
+ 
+ Every other aspect of each category is fine.
+ */
+ 
+//34567890123456789012345678901234567890123456789012345678901234567890123456
+
+// ~~~~~~~~~~ PARSING ~~~~~~~~
+/**
+ * Handles parsing a whole conversation file.
+ * 
+ * status: OKAY?
+ */
+static ConversationModel
+*parseConversationModel (const char* who )
+{
+	char *path = NULL; 
+	uio_Stream *hook;
+	char line[1024];
+	StringTableBuilder stb;
+	GSList *readout, *head;
+	int i;
+	ConversationModel *out;
+	ConversationNode *currentNode;
+	DeclarationGoodies dg;
+	
+	memset (&stb, 0, sizeof (stb));
+	
+  /* set up input system here - */
+	
+	path = g_strdup_printf ("comm/%s/%s.txt", who, who);
+	if (source)
+		g_free(source);
+	source = path;
+	hook = res_OpenResFile (contentDir, path, "rb");
+	if (hook == NULL)
+	{
+//		log_add (log_warning, "Warning: Can't open '%s'", path);
+		g_free (path);
+		source = NULL;
+		return NULL; // haven't opened, so don't need to goto err.
+	}
+	
+	if (LengthResFile (hook) == 0)
+	{
+//		log_add (log_warning, "Warning: Trying to load empty file '%s'.", path);
+		goto err;
+	}
+	
+	currentNode = NULL;
+	out = g_new(ConversationModel, 1);
+	out->name = who;
+	
+	while (GET_LINE)
+	{
+		
+		switch (line[0])
+		{ /* at this level of parsing, we only expect to
+												encounter one of 3 keywords */
+				/* also, you may consider using a switch AND an 'if' weird practice,
+				 but having the break helps with error control. I miss 'throw'. */
+			case 't':
+				if (strncmp(line, "text", 4) != 0)
+					break; /* switch, not while. Basically, go to the error handler. */
+				out->texts = g_slist_append (out->texts,
+							parseTextItem ( line,  hook, &stb ));
+				continue; /* the while, not the switch. */
+			case 'i':
+				if (strncmp(line, "init", 4) != 0)
+					break;
+				dg = initCode(line);
+				out->initializers = g_slist_append(out->initializers, dg.cc);
+			case 'g':
+				if (strncmp(line, "greeting", 8) != 0)
+					break;
+				out->greetings = g_slist_append (out->greetings,
+							parseGreeting( line, hook, &stb ));
+				continue;
+			case 'n':
+				if (strncmp(line, "node", 4) != 0)
+					break;
+				if (currentNode != NULL)
+					validateNode (currentNode);
+				currentNode = parseNode ( line);
+				out->nodes = g_slist_append (out->nodes, currentNode);
+        continue;
+			case 'o':
+				if (strncmp (line, "option", 6) != 0)
+					break;
+				if (currentNode == NULL){
+/*					log_add (g_strdup_sprintf (
+								"%s\nOption declared before first node declaration!",
+								source));
+ */
+				} else
+					currentNode->options = g_slist_append (currentNode->options,
+								parseOption ( line, hook, &stb));
+				continue;
+		}
+		// Getting here means an error!
+		printf ("%s%s\n%s\n%s\n%s\n", ERR1, source, ERR2, line, ERR3);
+	} /* end while over file contents */
+
+	out->table = g_new (STRING_TABLE_DESC, 1);
+	out->table->strings = g_new(STRING_TABLE_ENTRY_DESC, stb.length+1);
+	out->table->size = stb.length;
+	
+	readout = head = g_slist_reverse(stb.list);
+	for (i = 1; i <= stb.length; i++, readout = g_slist_next(readout))
+	{
+		out->table->strings[i] = *((STRING_TABLE_ENTRY_DESC*)(readout->data));
+		g_free(readout->data);
+	}
+	g_slist_free(stb.list);
+	g_slist_free(head);
+	
+  err:
+	res_CloseResFile (hook);
+	return out;
+} /* end parseConversation(...) */
+
+
+
+/**
+ * Handles parsing a greeting, once you know that the line begins with
+ * 'greeting'.
+ * 
+ * param stb: the string table builder. A GSList and the indices so far
+ * 
+ * status: OK
+ */
+static ConversationGreeting
+*parseGreeting (char *line, uio_Stream *hook, StringTableBuilder *stb)
+{
+	DeclarationGoodies dg;
+	ConversationGreeting *out = g_new(ConversationGreeting, 1);
+
+	
+	dg = initCode(line);
+	out->cc = dg.cc;
+/*	if (dg->name != NULL)
+		log_add (g_strdup_printf ("%s%s\nGreeting had a name. They don't get names.",
+					ERR1, source));
+*/
+
+	out->lines = extractSubstitutions (stb, hook, &line);
+	
+	
+/*	if (line == NULL)
+		log_add (g_strdup_printf ("%s%s\n%s", ERR1, source, ERR4));
+ */
+  // not exceptional case - we're looking at a '.' line
+	out->proceed = g_strdup (line+1);
+	g_free(line);
+
+	return out;
+} /* end parseGreeting(...) */
+
+/**
+ * gives the pointer-to-GSList encoding the alien dialog in the manner described in conversation.h
+ *
+ * @param lastLine the address of a pointer-to-char. This will set this address to point to the last line.
+ *
+ * Status: OK?
+ */
+static GSList
+*extractSubstitutions (StringTableBuilder *stb, uio_Stream *hook , char **lastLine)
+{
+	GSList *build = NULL; // list of alternating string table indices and (char*) strings to codes.
+	GSList *flip; // for reversing the order of build
+	StringTableBuilder currentText;
+	char  *line, *bra, *ket; // ket normally points to the character AFTER a ']'
+	int brackets;
+	int index;
+	
+	
+	while (GET_LINE)
+	{
+		if ( line[0] == '.') { // all done!
+			index = import_string(&currentText, stb);
+			build = g_slist_prepend(build, GINT_TO_POINTER(index));
+			break;
+		}
+		
+		if ((bra = strchr(ket, '[')))
+		{
+			
+			// now organize that bracket entry!
+			ket = line;
+			do
+			{
+				// TERMINATE PREVIOUS STRING, IF ANY
+				*bra = '\0';
+				if ((ket == bra) && (currentText.length == 0)) {
+					// the second condition is in case '[' starts a new line following text
+					build = g_slist_prepend(build, 0);
+				}
+				else
+				{
+					// now that we know where the end of the 
+					if (ket != bra)
+						add_string(&currentText, ket); // top it off
+					index = import_string(&currentText, stb); // this clears out currentText
+					build = g_slist_prepend(build, GINT_TO_POINTER(index));
+				}
+				// DONE TERMINATING PREVIOUS STRING
+				
+				brackets = 1;
+				for (ket = bra+1; *ket; ket++)
+				{
+					if (*ket == '[') 
+						brackets++;
+					else if (*ket == ']')
+					{
+						brackets--;
+						if (brackets == 0) {
+							*ket++ = '\0'; // set it null and restore the 'after' property.
+							
+							build = g_slist_prepend(build, g_strdup(bra));
+							
+							break;
+						} // end if we're all out of brackets
+					} // end if it was a closing bracket
+				} // end for each character before the brackets are closed
+			} 
+			while ((bra = strchr(ket, '['))); // end while we find brackets on this line
+			
+		}
+		else // there were no brackets. Simple case!
+		{
+			add_string(&currentText, line);
+		}
+	} // end for all lines
+	
+	if (lastLine)
+		*lastLine = line;
+	else
+		g_free(line);
+
+	
+	flip = g_slist_reverse(build);
+	g_slist_free(build);
+	return flip;
+}
+
+/**
+ * Handles parsing a node, once you know that the line begins with 'node'.
+ * Does not attempt to load up the options within the node.
+ * 
+ * status: OK
+ */
+static ConversationNode*
+parseNode(char* line)
+{
+  DeclarationGoodies dg;
+	ConversationNode *out;
+	
+	out = g_new(ConversationNode, 1);
+	
+	dg = initCode(line);
+	out->cc = dg.cc;
+	out->name = dg.name;
+	
+/*	if (name == NULL)
+		log_add(g_strdup_printf("%s%s\nNode provided with no valid name!\n%s\n\
+					Names go right after the declaration, \n\
+					and must start with an alphanumeric symbol.",
+					ERR1, source, line));
+ */
+  return out;
+} /* end parseNode(...) */
+
+/**
+ * Checks that the passed node is properly formed.
+ *
+ * status: Partially implemented; moderately useful as it stands.
+ * Nothing blocking.
+ */
+static void
+validateNode (ConversationNode* node)
+{
+
+ if (g_slist_length(node->options) == 0)
+	{
+		printf ("%s%s\nNode provided with no options!",
+					ERR1, source);
+	}
+	
+	/* TODO: check that each option name occurs at least twice */
+	/* TODO: check that no named option occurs after an option of the
+	   same name with no conditions */
+	/*
+	 TODO: check that each option has no transparently invalid evaluations:
+	 "[", "]" - mismatched brackets
+	 */
+}
+
+/**
+ * Handles parsing an option, once you know that the line begins with
+ * 'option'.
+ * 
+ * status: OK
+ */
+static ConversationOption*
+parseOption (char* line, uio_Stream *hook, StringTableBuilder *stb)
+{
+	DeclarationGoodies dg; // not DeclarationGoodies*
+	ConversationOption *out = g_new (ConversationOption, 1);
+	StringTableBuilder lines;
+	
+	lines.list = NULL;
+	lines.length = 0;
+	
+	dg = initCode (line);
+	out->cc = dg.cc;
+	out->name = dg.name;
+	
+	out->lines = extractSubstitutions(stb, hook, &line);
+	
+	out->proceed = g_strdup (line+1);
+	g_free(line);
+	
+	return out;
+} /* end parseOption(...) */
+
+/**
+ * parses a 'text' item, once you know that the line begins with 'text'.
+ *
+ * status: OK
+ */
+static ConversationText*
+parseTextItem (char* line, uio_Stream *hook, StringTableBuilder *stb)
+{
+	ConversationText *out;
+	DeclarationGoodies dg;
+	StringTableBuilder lines;
+	
+	lines.list = NULL;
+	lines.length = 0;
+	
+	dg = initCode(line);
+	out->cc = dg.cc;
+	out->name = dg.name;
+	
+	out->lines = extractSubstitutions(stb, hook, NULL);
+	/*
+	if (line == NULL) log_add (g_strdup_printf ("%s\n%s\n%s", ERR1, source, ERR4));
+	*/
+	return out;
+}
+
+/**
+ * parses the opening line of an item (greeting, node, option, text),
+ * sorting the conditions and consequences, identifying the name (if any).
+ * Modifies the passed string. 
+ *
+ * status: OK
+ */
+static DeclarationGoodies /* yes, return by value */
+initCode (char* line )
+{
+	char *token;
+	DeclarationGoodies out;
+	ConditionsConsequences *cc;
+	
+	memset (&out, 0, sizeof (out));
+	cc = g_new0 (ConditionsConsequences, 1);
+	out.cc = cc;
+	token = strpbrk (line, " \t");
+	if (!token) return out;
+	
+	line = g_strdup (line);
+	token = strtok (line, " \t"); // looking at the keyword. Move past that
+	token = strtok (NULL, " \t");
+	
+	if (isalnum (token[0]))
+	{
+		out.name = g_strdup (token);
+		token = strtok (NULL, " \t");
+	}
+	
+	while (token)
+	{
+		if ('=' == token[0])
+		{
+			cc->needed = g_slist_append (cc->needed, g_strdup (token+1));
+		}
+		else if ('<' == token[0])
+		{
+			cc->needed = g_slist_append (cc->needed, g_strdup (token+1));
+			token[0] = '-';
+			cc->consequences =
+						g_slist_append (cc->consequences, g_strdup (token));
+		}
+		else if ('!' == token[0])
+		{
+			cc->blocking = g_slist_append (cc->blocking, g_strdup (token+1));
+		}
+		else if ('>' == token[0])
+		{
+			cc->blocking = g_slist_append (cc->blocking, g_strdup (token+1));
+			token[0] = '+';
+			cc->consequences =
+						g_slist_append (cc->consequences, g_strdup (token));
+		}
+		else
+		{ // cases +, -, ~
+			cc->consequences =
+						g_slist_append (cc->consequences, g_strdup (token));
+		}
+		
+		token = strtok(NULL, " \t");
+	} // end while more tokens
+	return out;
+}
+
+/**
+ * returns a version of the passed string without comments
+ * marked with "//" or initial and ending spaces.
+ * Copies the passed string.
+ * If line is entirely comment or space, returns NULL.
+ * 
+ * status: OK
+ */
+static char*
+trim(const char* src)
+{
+	int i, len;
+	char *buf;
+
+	
+	buf = strstr (src, "//");
+	if (buf != NULL)
+	{
+		buf[0] = '\0'; // terminate string	
+		len = buf-src;
+	}
+	
+	for (i = len-1; i >= 0 && isspace(src[i]); i--)
+	{;	} /* end walkback */
+	
+	if (i == -1)
+		return NULL; // empty!
+	
+	len = i+1;
+	
+	for (i = 0; i < len && isspace (src[i]); i++)
+	{;	}
+	len -= i;
+	buf = g_new (char, len );
+	strncpy (buf, src+i, len );
+
+	return buf;
+} /* end trim */
+
+/**
+ * Gets the next line from the stream given, trims it, skips any blank
+ * lines
+ * 
+ * status: OK
+ */
+static char
+*get_line (char* buf, int len, uio_Stream *hook)
+{
+	char *out, *tmp;
+	do {
+	  tmp = uio_fgets (buf, len, hook);
+		if (tmp == NULL) return NULL;
+	  out = trim (tmp);
+	  free (tmp);
+	}	while (out == NULL);
+	
+	return out;
+}
+
+/**
+ * the improved version of the djb2 hash function of Dan Bernstein
+ * (original used + instead of ^ )
+ */
+/*
+static unsigned guint
+hash_djb2i (gconstpointer *p)
+{
+	unsigned long hash = 5381;
+	gint c;
+	char *str = (char*) p;
+ 
+	while ((c = *str++) != '\0')
+		hash = ((hash << 5) + hash) ^ c;
+
+	return (guint)hash;
+}
+*/
+
+/**
+ * wraps strncmp(a, b, 100) so it returns TRUE or FALSE instead of either
+ * "0 or something else".
+ */
+/*
+ static gboolean
+strings_equal(const char *a, const char *b)
+{
+  return strncmp(a, b, 100) == 0 ? TRUE:FALSE;
+}
+*/
+						
+/**
+ * Adds the line for gathering-up.
+ * NOT intended to feed the master string table,
+ * JUST for adding strings to the temp list.
+ *
+ * @param line This will be copied with g_strdup and stored.
+ * @return the number of characters in this string table so far.
+ * 
+ * status: OKAY
+ */
+static int
+add_string (StringTableBuilder *stb, char *line)
+{
+	stb->list = g_slist_prepend(stb->list, g_strdup(line));
+	return stb->length += strlen(line)+1;
+}
+
+/**
+ * Handles importing an individual STRING_TABLE_ENTRY_DESC object to
+ * the parent string table, via StringTableBuilder objects.
+ * This disposes of the baby (freeing the GSList elements and
+ * setting all values to 0), but leaves the mommy in place.
+ *
+ * status: OKAY
+ */
+static int import_string (StringTableBuilder *baby, StringTableBuilder *mommy) {
+	GSList *walk;
+	char *build;
+	STRING_TABLE_ENTRY_DESC *nova;
+	int linelength;
+	
+	
+	nova = g_new (STRING_TABLE_ENTRY_DESC, 1);
+	nova->data = g_new (char, baby->length);
+	nova->length = baby->length;
+	nova->parent = mommy->parent;
+	nova->index = ++(mommy->length);
+	
+	build = nova->data + nova->length; // start at the end since we were prepending
+	
+	for (walk = baby->list; walk; walk = g_slist_next (walk)) {
+		linelength = strlen (walk->data);
+		build -= linelength+1;
+		strncpy (build, walk->data, linelength);
+		g_free (walk->data);
+		build[linelength] = '\0';
+	}
+	g_slist_free (baby->list);
+	mommy->list = g_slist_prepend (mommy->list, nova);
+	
+	baby->list = NULL;
+	baby->length = 0;
+	
+	return nova->index;
+}
+
+// ~~~~~~~~ CONVERSATION LOGIC ~~~~~~~~~
+
+
+
+static COUNT
+uninit () {
+	freeModel(currentModel);
+	return 0;
+}
+
+static void
+post() {
+	return;
+}
+
+/**
+ * If a race will be using this comm system, put this function in a
+ * race's init_foo_comm function,
+ * and pass the race's name as the argument.
+ */
+void prep_conversation_module (char* who, LOCDATA *fill ) {
+	GSList *inits;
+	
+	if (transientState) {
+		g_hash_table_remove_all (transientState);
+	} else {
+		transientState = g_hash_table_new_full ( &g_str_hash, &g_str_equal, &g_free, NULL);
+	}
+	
+	currentModel = parseConversationModel (who);
+	fill->init_encounter_func = cm_intro;
+	fill->uninit_encounter_func = uninit;
+	fill->post_encounter_func = post;
+	fill->ConversationPhrases = currentModel->table->strings;
+	
+	percent = myRandom();
+	
+	for (inits = currentModel->initializers; inits; inits = g_slist_next(inits)) {
+		if (TRUE == checkConditions(inits->data, currentModel)) {
+			applyConsequences(inits->data, currentModel);
+			break;
+		}
+	}
+		
+} // end init_conversation
+
+#define MAX_FAIR_RAND ((RAND_MAX / 100)*100)
+
+static int myRandom() {
+	int out = rand();
+	while (out > MAX_FAIR_RAND) out = rand();
+	return out/100;
+}
+
+static gboolean
+checkConditions(ConditionsConsequences* cc, ConversationModel* cm)
+{
+  GSList *conds;
+  int bit;
+	GSList *tmp;
+	tmp = g_slist_append (tmp, "");
+	for (conds = cc->needed; conds; conds = g_slist_next (conds))
+	{
+		bit = arithmetic ((char*)(conds->data), cm);
+		if (!bit)
+			 return FALSE;
+	}
+	for (conds = cc->blocking; conds; conds = g_slist_next (conds))
+	{
+		bit = arithmetic ((char*)(conds->data), cm);
+		if (bit)
+			return FALSE;
+	}
+	return TRUE;
+}
+
+static int
+getGreeting(ConversationModel* cm)
+{
+	GSList *greetings = cm->greetings;
+	ConversationGreeting *cg;
+	int index = 0;
+	do
+	{
+		cg = (ConversationGreeting*)greetings->data;
+		if (checkConditions (cg->cc, cm) == TRUE)
+			return index;
+		index++;
+	}
+	while ((greetings = g_slist_next (greetings)) != NULL);
+	return 0;
+}
+
+/**
+ * The use as init_encounter_func
+ */
+void
+cm_intro ()
+{
+	ConversationManager ( -1 - getGreeting (currentModel));
+}
+
+/**
+ * status: PARTIALLY IMPLEMENTED
+ *
+ * Missing:
+ * display directives
+ */
+void
+ConversationManager (RESPONSE_REF R)
+{	
+	GSList *walk;
+	char *nextNode;
+	RESPONSE_REF i = 1;
+    ConversationNode *currentNode;
+	
+	if (R > 0)
+	{ 
+		ConversationOption *taken = g_slist_nth (currentOptions, R-1)->data;
+		applyConsequences (taken->cc, currentModel);
+		nextNode = taken->proceed;
+		walk = taken->lines;
+		g_slist_free (currentOptions); // not free_full, since these are held elsewhere
+	}
+	else
+	{
+		ConversationGreeting *cg = (g_slist_nth (currentModel->greetings, -1 - R ))->data;
+		applyConsequences (cg->cc, currentModel);
+		nextNode = cg->proceed;
+		walk = cg->lines;
+	}
+	
+  displaySubstituted(walk);
+
+	if (0 == strncmp(nextNode, "done", 5))
+	{
+		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		return;
+	}
+	if (0 == strncmp(nextNode, "fight", 6))
+	{
+		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		return;
+	}
+		
+	currentNode = getNode (nextNode, currentModel);
+	
+	currentOptions = getOptionList (currentNode, currentModel);
+	
+	for (walk = currentOptions; walk; walk = walk->next)
+	{
+		ConversationOption* opt = walk->data;
+		DoResponsePhrase (i++, &ConversationManager, (UNICODE*)(opt->say));
+	}
+	
+} // end ConversationManager
+
+static void
+displaySubstituted(GSList *walk) {
+	ConversationText *ct;
+	
+	while (walk)
+	{
+	  NPCPhrase (GPOINTER_TO_INT(walk->data));
+		walk = g_slist_next(walk);
+		if (walk == NULL)
+			return;
+		ct = getTextItem(walk->data, currentModel);
+		if (ct) 
+			displaySubstituted(ct->lines); // recurse into text items
+		else
+  		NPCPhrase (-arithmetic(walk->data, currentModel));
+		
+		walk = g_slist_next(walk);
+	}	
+}
+
+/**
+ * Determines the set of conversation options.
+ * 
+ * status: OK
+ */
+static GSList*
+getOptionList(ConversationNode* cn, ConversationModel *cm)
+{
+	GSList *out, *walk, *acceptedNames;
+	ConversationOption *step;
+	out = acceptedNames = NULL;
+	
+	for (walk = cn->options; walk; walk = g_slist_next (walk))
+	{
+		step = walk->data;
+    if (step->name != NULL)
+		{
+			if (g_slist_find_custom (acceptedNames, step->name, g_strcmp0))
+				continue;
+		}
+		if (checkConditions (step->cc, cm) == FALSE)
+			continue;
+		out = g_slist_append (out, step);
+		if (step->name != NULL)
+			acceptedNames = g_slist_prepend (acceptedNames, step->name);
+	}
+	return out;
+}
+
+/**
+ * Finds the appropriate node to go to next.
+ *
+ * status: OK
+ */
+static ConversationNode*
+getNode (char* name, ConversationModel* cm)
+{
+	GSList *walk;
+	if (name == NULL)
+		return NULL;
+	for (walk = cm->nodes; walk; walk = g_slist_next(walk))
+	{
+		ConversationNode *node = (ConversationNode*)walk->data;
+		if (g_strcmp0(node->name, name) != 0)
+			continue;
+		if (checkConditions (node->cc, cm) == TRUE)
+			return node;
+	}
+	return NULL;
+}
+
+/**
+ * Finds the appropriate text to use.
+ * Does not substitute any variables or text items to find the
+ * text name, just looks it up.
+ *
+ * status: OK
+ */
+static ConversationText*
+getTextItem (char* name, ConversationModel* cm)
+{
+	GSList *walk;
+	if (name == NULL)
+		return NULL;
+	for (walk = cm->texts; walk; walk = g_slist_next(walk))
+	{
+		ConversationText *node = (ConversationText*)(walk->data);
+		if (g_strcmp0(node->name, name) != 0)
+			continue;
+		if (checkConditions (node->cc, cm) == TRUE)
+			return node;
+	}
+	return NULL;
+}
+
+/**
+ * Applies the consequences of an item being taken.
+ * 
+ * status: OKAY
+ */
+static void
+applyConsequences (ConditionsConsequences* cc, ConversationModel *cm)
+{
+	GSList *walk;
+	char *con, *LHS, *RHS, *cmp, *assemble;
+	int newval, statement;
+	int offset;
+	
+	for (walk = cc->consequences; walk; walk = g_slist_next(walk))
+	{
+		con = walk->data;
+		
+		cmp = strpbrk(con, "=<>"); // take the FIRST comparator
+		if (cmp)
+		{ // explicit comparison or assignment - numeric flags
+			offset = cmp-con;
+			LHS = strncpy( g_new (char, offset+1), con, offset);
+			LHS[offset] = '\0';
+			RHS = cmp + 1;
+		}
+		else
+		{ // case of implicit assignment - typically boolean flags
+			LHS = con;
+			cmp = "=";
+			RHS = "1";
+		}
+		newval = 0;
+		assemble = g_strdup_printf ("%s%s%s", con, cmp, RHS);
+		statement = arithmetic (assemble, cm);
+
+		switch (*con)
+		{
+			case '~':
+				if (statement)	break; // leave newval as 0
+					// else fall through and set the new value
+			case '+':
+				if (statement)
+					return; // setting an already satisfied condition? Do nothing.
+				// otherwise...
+				newval = arithmetic (RHS, cm);
+
+				switch (*cmp)
+			  {
+					case '<': newval--; break;
+					case '>': newval++; // break;
+//					case '=':
+				}
+//			case '-': // leave newval as 0
+//			default:
+		} // end switch on style of consequence
+		setVal (LHS, newval, cm);
+	} // end for each consequence
+}	// end applyConsequences(...)
+
+
+static void
+setVal (char *name, int newval, ConversationModel *cm)
+{
+	if (*name == '%') {
+		percent = myRandom();
+		return;
+	}
+	switch (checkForCase (name))
+	{
+		case 2: // only lower-case
+			g_hash_table_insert (transientState, name, GINT_TO_POINTER(newval));
+			return;
+		case 3: // mixed case
+			SetGameStateByName (g_strdup_printf ("%s[%s]", cm->name, name), (BYTE)newval);
+			return;
+	}
+	SetGameStateByName (name, (BYTE)newval);
+} // end setVal(...)
+
+// ~~~~~~~ SUBSTITUTION AND ARITHMETIC ~~~~~~~~~
+
+
+
+
+/**
+ * This handles arithmetic without grouping. If it doesn't find any
+ * arithmetic or numbers, returns 0.
+ * This alters the passed string.
+ *
+ * Recognized operators, in order of increasing precedence are:
+ * = (equals) and < (less than) and > (greater than),
+ * + (add) and - (subtract),
+ * / (divide),
+ * * (multiply),
+ *  (radical binary operator) and ^ (exponential)
+ *
+ * The separation of * from / enables expressions like (a*b)/(c*d)
+ * to do without the parentheses with need for
+ * neither double division nor the explicit groupings.
+ *
+ * The same does NOT apply to addition and subtraction, which are
+ * performed strictly left to right:
+ * if you want a-(b+c), you can just write a-b-c.
+ * 
+ * The  operator ab is what b^[1/a] would be if 1/a weren't going
+ * to be int-trimmed.
+ * 
+ * Operations / and later resolve RIGHT to LEFT, so ab^c is made
+ * bigger, then smaller (good for avoiding int-trimming)
+ *
+ * status: OKAY
+ */
+static int arithmetic(char* expression, ConversationModel* cm) {
+	char *divider, *out, *next;
+	char operator, nextop;
+	int left, right;
+	
+	if (*expression == '\0')
+		return 0;
+	
+	divider = strpbrk (out, "=<>");
+	if (divider)
+	{
+		operator = *divider;
+		*divider = '\0';
+		
+		left = arithmetic (expression, cm);
+		
+		while (divider != NULL)
+		{
+			next = strpbrk (out, "=<>");
+			if (next)
+			{
+				nextop = *next;
+			  *next = '\0';
+			}
+			right = arithmetic (divider+1, cm);
+			
+			switch (operator)
+			{
+				case '=': left = (left == right)? 1: 0; break;
+				case '<': left = (left <  right)? 1: 0; break;
+				case '>': left = (left >  right)? 1: 0; break;
+				default:  left = 0;
+			}
+			operator = nextop;
+			divider = next;
+		}
+	}
+
+	// lowest priority, so split on this and evaluate each side before going.
+  divider = nextPlusOrBinaryMinus (expression);
+	if (divider)
+	{
+		operator = *divider;
+		*divider = '\0';
+		
+		left = innerArithmetic (expression, cm);
+		
+		while (divider != NULL)
+		{ // identify and close off the next element of the sum
+			next = nextPlusOrBinaryMinus (divider+1); 
+			if (next)
+			{
+				nextop = *next;
+			  *next = '\0';
+			}
+			
+			right = innerArithmetic (divider+1, cm);
+			
+			left = (operator == '+') ? left+right : left-right;
+			
+			operator = nextop;
+			divider = next;
+		}
+		return left;
+	}
+	
+	return innerArithmetic (expression, cm);
+	
+} // end arithmetic(...)
+
+/**
+ * returns the pointer to the next + or -, NOT counting any unary - signs.
+ * If there aren't any, returns NULL.
+ *
+ * status: OK
+ */
+static char *
+nextPlusOrBinaryMinus (const char *expression)
+{
+	char* out;
+	
+	out = strpbrk(out, "-+");
+	if (out == expression)
+		out = strpbrk (out+1, "-+"); // manually make sure we don't back out of the string
+	while (out && strchr ("+-*/^", *(out - 1)) )
+	{ // while the character before this - sign is another operator...
+		out = strpbrk (out+1, "-+");
+	}
+	
+	return out;
+}
+
+static int
+innerArithmetic (char* expression, ConversationModel *cm)
+{
+	char *divider;
+	char operator;
+	int left, right;
+	
+	divider = strpbrk (expression, "/");
+	if (divider != NULL)
+	{
+		*divider = '\0';
+		
+		left = innerArithmetic (expression, cm);
+		right = innerArithmetic (divider + 1, cm);
+		
+		return left/right;
+	}
+	
+	divider = strpbrk (expression, "*");
+	if (divider != NULL)
+	{
+		*divider = '\0';
+		left = innerArithmetic (expression, cm);
+		right = innerArithmetic (divider + 1, cm);
+		return left*right;
+	}
+	
+	// highest priority. The left-side is a number or nothing.
+	divider = strpbrk (expression, "^"); 
+	
+	if (divider != NULL)
+	{
+		operator = *divider;
+		*divider = '\0';
+		left = innerArithmetic (expression, cm);
+		right = innerArithmetic (divider + 1, cm);
+		
+		return (operator == '^')?
+					(int)(pow (left, right)) :
+					(int)(pow (right, 1.0 / left));
+	}
+	return evaluatePrimitive (expression, cm);
+}
+
+/**
+ * Gets a number, either parsing it as int or by getting from
+ * GetGameState or transientState, as appropriate
+ * Alters the expression passed.
+ *
+ * status: OK but needs an implementation of GetGameState
+ */
+static int
+evaluatePrimitive (char* expression, ConversationModel *cm)
+{
+	int out, jump;
+	
+	if (*expression == '%')
+		return percent;
+	
+	// clear sequential - signs
+	jump = plusesAndMinuses (expression);
+	if (jump < 0)
+	{
+		expression -= jump;
+		expression--;
+		expression[0] = '-';
+	}
+	else
+	{
+		expression += jump;
+	}
+	
+	if (strlen(expression) == 1 && expression[0] == '0')
+		return 0; // check for an ACTUAL 0 instead of atoi bombing out.
+	
+	out = atoi (expression);
+	if (out != 0)
+		return out;
+	switch (checkForCase (expression))
+	{
+		case 2: // only lower-case
+			return (int)(g_hash_table_lookup (transientState, expression));
+		case 3: // mixed case
+			return (int)(GetGameStateByName (g_strdup_printf ("%s[%s]", cm->name, expression)));
+	}
+	return ((int)(GetGameStateByName (expression)));
+}
+
+/**
+ * returns the leading - and + signs 
+ * negative if the number of - signs is odd.
+ * 
+ * status: OK
+ */
+static int
+plusesAndMinuses (const char* expression)
+{
+  int out, odd;
+	out = odd = 0;
+	for ( ; expression; expression++, out++)
+	{
+		if (*expression == '-')
+			odd++;
+		else if (*expression != '+')
+			break;
+	}
+	if (odd & 1) return -out;
+	return out;
+}
+
+/**
+ * returns a bitmask with the corresponding values:
+ * 1 -> there is an upper-case letter
+ * 2 -> there is a lower-case letter
+ * 
+ * status: OK
+ */
+static int
+checkForCase (const char* str)
+{
+  int out;
+	const char *walk;
+	walk = str;
+	for (walk = str; *walk != '\0'; walk++)
+	{
+		if (*walk >= 'A' && *walk <='Z')
+		{
+			out |= 1;
+		}
+		else if (*walk >= 'a' && *walk <= 'z')
+		{
+			out |= 2;
+		}
+		if (out == 3) return out;
+	}
+  return out;
+}
diff -ruNp src.orig/uqm/conversation.h src/uqm/conversation.h
--- src.orig/uqm/conversation.h	1969-12-31 16:00:00 -0800
+++ src/uqm/conversation.h	2017-11-01 15:31:02 -0700
@@ -0,0 +1,14 @@
+/*
+ *  conversation.h
+ * 
+ *  Created by Luke Somers on 2012-01-20, for Project 6014.
+ */
+#include "globdata.h" // for LOCDATA
+#include "commglue.h" // for RESPONSE_REF
+
+
+void ConversationManager (RESPONSE_REF R);
+
+void cm_intro ();
+
+void prep_conversation_module (char* who, LOCDATA *fill );
diff -ruNp src.orig/uqm/corecode.h src/uqm/corecode.h
--- src.orig/uqm/corecode.h	2017-11-01 15:30:24 -0700
+++ src/uqm/corecode.h	2017-11-01 15:31:02 -0700
@@ -19,13 +19,17 @@
 
 #include "ships/androsyn/icode.h"
 #include "ships/arilou/icode.h"
+#include "ships/baul/icode.h"
 #include "ships/blackurq/icode.h"
 #include "ships/chenjesu/icode.h"
 #include "ships/chmmr/icode.h"
 #include "ships/druuge/icode.h"
+#include "ships/foonfoon/icode.h"
 #include "ships/human/icode.h"
+#include "ships/isd/icode.h"
 #include "ships/ilwrath/icode.h"
 #include "ships/lastbat/icode.h"
+#include "ships/lurg/icode.h"
 #include "ships/melnorme/icode.h"
 #include "ships/mmrnmhrm/icode.h"
 #include "ships/mycon/icode.h"
@@ -34,6 +38,7 @@
 #include "ships/probe/icode.h"
 #include "ships/shofixti/icode.h"
 #include "ships/sis_ship/icode.h"
+#include "ships/slykohr/icode.h"
 #include "ships/slylandr/icode.h"
 #include "ships/spathi/icode.h"
 #include "ships/supox/icode.h"
diff -ruNp src.orig/uqm/credits.c src/uqm/credits.c
--- src.orig/uqm/credits.c	2017-11-01 15:30:24 -0700
+++ src/uqm/credits.c	2017-11-01 15:31:02 -0700
@@ -32,10 +32,10 @@
 #include <math.h>
 
 // Rates in pixel lines per second
-#define CREDITS_BASE_RATE   9
-#define CREDITS_MAX_RATE    130
+#define CREDITS_BASE_RATE   (15 << RESOLUTION_FACTOR) // JMS_GFX
+#define CREDITS_MAX_RATE    (130 << RESOLUTION_FACTOR) // JMS_GFX
 // Maximum frame rate
-#define CREDITS_FRAME_RATE  36
+#define CREDITS_FRAME_RATE  (36 << RESOLUTION_FACTOR) // JMS_GFX
 
 #define CREDITS_TIMEOUT   (ONE_SECOND * 5)
 
@@ -382,14 +382,12 @@ InitCredits (void)
 	oldContext = SetContext (LocalContext);
 	// Local screen copy. We draw everything to this frame, then cut
 	// the Outtakes rect out and draw this frame to the screen.
-	CreditsFrame = Credits_MakeTransFrame (CreditsExtent.width,
-			CreditsExtent.height, TRANS_COLOR);
+	CreditsFrame = Credits_MakeTransFrame (CreditsExtent.width, CreditsExtent.height, TRANS_COLOR);
 	SetContextFGFrame (CreditsFrame);
 	
 	// The first credits frame is fake, the height of the screen,
 	// so that the credits can roll in from the bottom
-	textFrames[0].frame = Credits_MakeTransFrame (1, CreditsExtent.height,
-			TRANS_COLOR);
+	textFrames[0].frame = Credits_MakeTransFrame (1, CreditsExtent.height, TRANS_COLOR);
 	textFrames[0].strIndex = -1;
 	firstFrame = 0;
 	lastFrame = firstFrame + 1;
@@ -617,7 +615,15 @@ LoadCredits (void)
 	CreditsTab = CaptureStringTable (LoadStringTable (CREDITS_STRTAB));
 	if (!CreditsTab)
 		return FALSE;
-	CreditsBack = CaptureDrawable (LoadGraphic (CREDITS_BACK_ANIM));
+	
+	// JMS: Load the different menus depending on the resolution factor.
+	if (resolutionFactor < 1)
+		CreditsBack = CaptureDrawable (LoadGraphic (CREDITS_BACK_ANIM));
+	if (resolutionFactor == 1)
+		CreditsBack = CaptureDrawable (LoadGraphic (CREDITS_BACK_ANIM2X));
+	if (resolutionFactor > 1)
+		CreditsBack = CaptureDrawable (LoadGraphic (CREDITS_BACK_ANIM4X));
+	
 	// load fonts
 	for (fdef = CreditsFont; fdef->size; ++fdef)
 		fdef->font = LoadFont (fdef->res);
@@ -647,11 +653,10 @@ FreeCredits (void)
 static void
 OutTakes (void)
 {
-#define NUM_OUTTAKES 15
+#define NUM_OUTTAKES 14 // JMS: Removed talking pet conversation.
 	static CONVERSATION outtake_list[NUM_OUTTAKES] =
 	{
 		ZOQFOTPIK_CONVERSATION,
-		TALKING_PET_CONVERSATION,
 		ORZ_CONVERSATION,
 		UTWIG_CONVERSATION,
 		THRADD_CONVERSATION,
@@ -803,8 +808,7 @@ Credits (BOOLEAN WithOuttakes)
 	UnlockMutex (GraphicsLock);
 
 	// set the position of outtakes comm
-	CommWndRect.corner.x = (screenRect.extent.width - CommWndRect.extent.width)
-			/ 2;
+	CommWndRect.corner.x = (screenRect.extent.width - CommWndRect.extent.width) / 2;
 	CommWndRect.corner.y = 5;
 	
 	InitCredits ();
diff -ruNp src.orig/uqm/cyborg.c src/uqm/cyborg.c
--- src.orig/uqm/cyborg.c	2017-11-01 15:30:24 -0700
+++ src/uqm/cyborg.c	2017-11-01 15:31:02 -0700
@@ -16,6 +16,12 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: - Amended Pursue -function: Ur-Quan, Kohr-Ah and ISD pursue Earthling slowly but surely. Now they won't turn away mid-chase.
+//			 - Enable Down key in melee (comment tag JMS_KEYS)
+
+// JMS_GFX:	 - Added RESOLUTION_FACTORs to LONG_RANGE_WEAPONs and CLOSE_RANGE_WEAPONs
+//			 - Amended some constant values with RESOLUTION_FACTOR
+
 #include "colors.h"
 #include "collide.h"
 #include "element.h"
@@ -33,13 +39,13 @@ COUNT
 PlotIntercept (ELEMENT *ElementPtr0, ELEMENT *ElementPtr1,
 		COUNT max_turns, COUNT margin_of_error)
 {
-	SIZE dy;
-	SIZE time_y_0, time_y_1;
-	POINT dst[2];
+	SDWORD dy;
+	SDWORD time_y_0, time_y_1;
+	DPOINT dst[2];
 	RECT r0 = {{0, 0}, {0, 0}};
 	RECT r1 = {{0, 0}, {0, 0}};
-	SIZE dx_0, dy_0, dx_1, dy_1;
-
+	SDWORD dx_0, dy_0, dx_1, dy_1; // JMS:These were SIZE. No overflows now.
+	
 	if ((ElementPtr0->state_flags | ElementPtr1->state_flags) & FINITE_LIFE)
 	{
 		if (!(ElementPtr0->state_flags & FINITE_LIFE))
@@ -61,15 +67,17 @@ PlotIntercept (ELEMENT *ElementPtr0, ELE
 		}
 	}
 
-	dst[0] = ElementPtr0->current.location;
-	GetCurrentVelocityComponents (&ElementPtr0->velocity, &dx_0, &dy_0);
-	dx_0 = (SIZE)VELOCITY_TO_WORLD ((long)dx_0 * (long)max_turns);
-	dy_0 = (SIZE)VELOCITY_TO_WORLD ((long)dy_0 * (long)max_turns);
-
-	dst[1] = ElementPtr1->current.location;
-	GetCurrentVelocityComponents (&ElementPtr1->velocity, &dx_1, &dy_1);
-	dx_1 = (SIZE)VELOCITY_TO_WORLD ((long)dx_1 * (long)max_turns);
-	dy_1 = (SIZE)VELOCITY_TO_WORLD ((long)dy_1 * (long)max_turns);
+	dst[0].x = (SDWORD)ElementPtr0->current.location.x;
+	dst[0].y = (SDWORD)ElementPtr0->current.location.y;
+	GetCurrentVelocityComponentsSdword (&ElementPtr0->velocity, &dx_0, &dy_0);
+	dx_0 = (SDWORD)VELOCITY_TO_WORLD ((long)dx_0 * (long)max_turns);
+	dy_0 = (SDWORD)VELOCITY_TO_WORLD ((long)dy_0 * (long)max_turns);
+
+	dst[1].x = (SDWORD)ElementPtr1->current.location.x;
+	dst[1].y = (SDWORD)ElementPtr1->current.location.y;
+	GetCurrentVelocityComponentsSdword (&ElementPtr1->velocity, &dx_1, &dy_1);
+	dx_1 = (SDWORD)VELOCITY_TO_WORLD ((long)dx_1 * (long)max_turns);
+	dy_1 = (SDWORD)VELOCITY_TO_WORLD ((long)dy_1 * (long)max_turns);
 
 	if (margin_of_error)
 	{
@@ -97,8 +105,8 @@ PlotIntercept (ELEMENT *ElementPtr0, ELE
 			|| (time_y_0 > 0 && dy >= time_y_0)
 			|| (time_y_1 < 0 && dy <= time_y_1))
 	{
-		SIZE dx;
-		SIZE time_x_0, time_x_1;
+		SDWORD dx;
+		SDWORD time_x_0, time_x_1;
 
 		if (margin_of_error)
 		{
@@ -127,7 +135,7 @@ PlotIntercept (ELEMENT *ElementPtr0, ELE
 				time_y_0 = time_y_1 = 0;
 			else
 			{
-				SIZE t;
+				SDWORD t;
 				long time_beg, time_end, fract;
 
 				if (time_y_1 < 0)
@@ -194,12 +202,12 @@ PlotIntercept (ELEMENT *ElementPtr0, ELE
 				if ((time_beg *= max_turns) < fract)
 					time_y_0 = 0;
 				else
-					time_y_0 = (SIZE)(time_beg / fract);
+					time_y_0 = (SDWORD)(time_beg / fract);
 
 				if (time_end >= fract) /* just in case of overflow */
 					time_y_1 = max_turns - 1;
 				else
-					time_y_1 = (SIZE)((time_end * max_turns) / fract);
+					time_y_1 = (SDWORD)((time_end * max_turns) / fract);
 			}
 
 			if (time_y_0 <= time_y_1)
@@ -208,27 +216,29 @@ PlotIntercept (ELEMENT *ElementPtr0, ELE
 					return ((COUNT)time_y_0 + 1);
 				else
 				{
-					POINT Pt0, Pt1;
+					DPOINT Pt0, Pt1;
 					VELOCITY_DESC Velocity0, Velocity1;
 					INTERSECT_CONTROL Control0, Control1;
 
-					Pt0 = ElementPtr0->current.location;
+					Pt0.x = (SDWORD)ElementPtr0->current.location.x;
+					Pt0.y = (SDWORD)ElementPtr0->current.location.y;
 					Velocity0 = ElementPtr0->velocity;
 					Control0 = ElementPtr0->IntersectControl;
 
-					Pt1 = ElementPtr1->current.location;
+					Pt1.x = (SDWORD)ElementPtr1->current.location.x;
+					Pt1.y = (SDWORD)ElementPtr1->current.location.y;
 					Velocity1 = ElementPtr1->velocity;
 					Control1 = ElementPtr1->IntersectControl;
 
 					if (time_y_0)
 					{
-						GetNextVelocityComponents (&Velocity0, &dx_0, &dy_0, time_y_0);
+						GetNextVelocityComponentsSdword (&Velocity0, &dx_0, &dy_0, time_y_0);
 						Pt0.x += dx_0;
 						Pt0.y += dy_0;
 						Control0.EndPoint.x = WORLD_TO_DISPLAY (Pt0.x);
 						Control0.EndPoint.y = WORLD_TO_DISPLAY (Pt0.y);
 						
-						GetNextVelocityComponents (&Velocity1, &dx_1, &dy_1, time_y_0);
+						GetNextVelocityComponentsSdword (&Velocity1, &dx_1, &dy_1, time_y_0);
 						Pt1.x += dx_1;
 						Pt1.y += dy_1;
 						Control1.EndPoint.x = WORLD_TO_DISPLAY (Pt1.x);
@@ -241,11 +251,11 @@ PlotIntercept (ELEMENT *ElementPtr0, ELE
 
 						++time_y_0;
 
-						GetNextVelocityComponents (&Velocity0, &dx_0, &dy_0, 1);
+						GetNextVelocityComponentsSdword (&Velocity0, &dx_0, &dy_0, 1);
 						Pt0.x += dx_0;
 						Pt0.y += dy_0;
 
-						GetNextVelocityComponents (&Velocity1, &dx_1, &dy_1, 1);
+						GetNextVelocityComponentsSdword (&Velocity1, &dx_1, &dy_1, 1);
 						Pt1.x += dx_1;
 						Pt1.y += dy_1;
 
@@ -256,8 +266,9 @@ PlotIntercept (ELEMENT *ElementPtr0, ELE
 						Control1.IntersectStamp.origin = Control1.EndPoint;
 						Control1.EndPoint.x = WORLD_TO_DISPLAY (Pt1.x);
 						Control1.EndPoint.y = WORLD_TO_DISPLAY (Pt1.y);
-						when = DrawablesIntersect (&Control0,
-								&Control1, MAX_TIME_VALUE);
+						
+						when = DrawablesIntersect (&Control0, &Control1, MAX_TIME_VALUE);
+						
 						if (when)
 						{
 							if (when == 1
@@ -331,6 +342,9 @@ ship_movement (ELEMENT *ShipPtr, EVALUAT
 		case ENTICE:
 			Entice (ShipPtr, EvalDescPtr);
 			break;
+		case IN_GAS: // JMS
+			InGas (ShipPtr, EvalDescPtr);
+			break;
 		case NO_MOVEMENT:
 			break;
 	}
@@ -346,7 +360,7 @@ ship_weapons (ELEMENT *ShipPtr, ELEMENT
 	STARSHIP *StarShipPtr;
 
 	if (OBJECT_CLOAKED (OtherPtr))
-		margin_of_error += DISPLAY_TO_WORLD (40);
+		margin_of_error += DISPLAY_TO_WORLD (40 << RESOLUTION_FACTOR); // JMS_GFX
 
 	Ship = *ShipPtr;
 	GetNextVelocityComponents (&Ship.velocity,
@@ -416,6 +430,7 @@ ship_intelligence (ELEMENT *ShipPtr, EVA
 	BOOLEAN ShipMoved, ShipFired;
 	COUNT margin_of_error;
 	STARSHIP *StarShipPtr;
+	EVALUATE_DESC *ObjectsOfConcernEWeapon;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 
@@ -436,11 +451,14 @@ ship_intelligence (ELEMENT *ShipPtr, EVA
 	if (StarShipPtr->control & AWESOME_RATING)
 		margin_of_error = 0;
 	else if (StarShipPtr->control & GOOD_RATING)
-		margin_of_error = DISPLAY_TO_WORLD (20);
+		margin_of_error = DISPLAY_TO_WORLD (20 << RESOLUTION_FACTOR); // JMS_GFX
 	else /* if (StarShipPtr->control & STANDARD_RATING) */
-		margin_of_error = DISPLAY_TO_WORLD (40);
+		margin_of_error = DISPLAY_TO_WORLD (40 << RESOLUTION_FACTOR); // JMS_GFX
 
 	ObjectsOfConcern += ConcernCounter;
+	
+	ObjectsOfConcernEWeapon = ObjectsOfConcern - ConcernCounter + ENEMY_WEAPON_INDEX;
+	
 	while (ConcernCounter--)
 	{
 		--ObjectsOfConcern;
@@ -449,25 +467,32 @@ ship_intelligence (ELEMENT *ShipPtr, EVA
 			if (!ShipMoved
 					&& (ConcernCounter != ENEMY_WEAPON_INDEX
 					|| ObjectsOfConcern->MoveState == PURSUE
+					|| (ObjectsOfConcernEWeapon->MoveState == IN_GAS && ConcernCounter == ENEMY_WEAPON_INDEX)
 					|| (ObjectsOfConcern->ObjectPtr->state_flags & CREW_OBJECT)
 					|| MANEUVERABILITY (
 							&StarShipPtr->RaceDescPtr->cyborg_control
-							) >= MEDIUM_SHIP))
+							) >= (MEDIUM_SHIP << RESOLUTION_FACTOR) // JMS_GFX
+						)
+				)
 			{
 				ship_movement (ShipPtr, ObjectsOfConcern);
 				ShipMoved = TRUE;
 			}
 			if (!ShipFired
-					&& (ConcernCounter == ENEMY_SHIP_INDEX
+				&& (ConcernCounter == ENEMY_SHIP_INDEX
 					|| (ConcernCounter == ENEMY_WEAPON_INDEX
-					&& ObjectsOfConcern->MoveState != AVOID
+						&& ObjectsOfConcern->MoveState != AVOID
+						&& !(ObjectsOfConcern->ObjectPtr->state_flags & GASSY_SUBSTANCE) // Don't fire at baul gas. It's useless doing that.
+						&& StarShipPtr->SpeciesID != BAUL_ID // Baul AI doesn't try to shoot enemy projectiles. It would only hurt itself more.
 #ifdef NEVER
-					&& !(StarShipPtr->control & STANDARD_RATING)
-#endif /* NEVER */
-					)))
+						&& !(StarShipPtr->control & STANDARD_RATING)
+#endif /* NEVER */		
+						)
+					)
+				)
 			{
-				ShipFired = ship_weapons (ShipPtr,
-						ObjectsOfConcern->ObjectPtr, margin_of_error);
+				ShipFired = ship_weapons (ShipPtr,ObjectsOfConcern->ObjectPtr, margin_of_error);
+				
 				if (ShipFired)
 					StarShipPtr->ship_input_state |= WEAPON;
 			}
@@ -574,6 +599,7 @@ Pursue (ELEMENT *ShipPtr, EVALUATE_DESC
 	SIZE other_delta_x, other_delta_y;
 	ELEMENT *OtherObjPtr;
 	VELOCITY_DESC ShipVelocity, OtherVelocity;
+	COUNT distance_to_give_up_and_turn; // JMS
 
 	ShipVelocity = ShipPtr->velocity;
 	GetNextVelocityComponents (&ShipVelocity,
@@ -584,6 +610,7 @@ Pursue (ELEMENT *ShipPtr, EVALUATE_DESC
 			ShipPtr->current.location.y + ship_delta_y;
 
 	OtherObjPtr = EvalDescPtr->ObjectPtr;
+		
 	OtherVelocity = OtherObjPtr->velocity;
 	GetNextVelocityComponents (&OtherVelocity,
 			&other_delta_x, &other_delta_y, EvalDescPtr->which_turn);
@@ -602,7 +629,9 @@ Pursue (ELEMENT *ShipPtr, EVALUATE_DESC
 	if (ShipPtr->thrust_wait == 0
 			&& ((OtherObjPtr->state_flags & PLAYER_SHIP)
 			|| elementsOfSamePlayer (OtherObjPtr, ShipPtr)
-			|| OtherObjPtr->preprocess_func == crew_preprocess))
+			|| OtherObjPtr->preprocess_func == crew_preprocess
+			)
+		)
 		maneuver_state |= THRUST;
 
 	desired_turn_angle = NORMALIZE_ANGLE (desired_thrust_angle + HALF_CIRCLE);
@@ -617,9 +646,9 @@ Pursue (ELEMENT *ShipPtr, EVALUATE_DESC
 		GetElementStarShip (OtherObjPtr, &EnemyStarShipPtr);
 		if ((MANEUVERABILITY (
 				&StarShipPtr->RaceDescPtr->cyborg_control
-				) >= FAST_SHIP
+				) >= (FAST_SHIP << RESOLUTION_FACTOR) // JMS_GFX
 				&& WEAPON_RANGE (&StarShipPtr->RaceDescPtr->cyborg_control)
-				> CLOSE_RANGE_WEAPON)
+				> (CLOSE_RANGE_WEAPON << RESOLUTION_FACTOR)) // JMS_GFX
 				|| (EvalDescPtr->which_turn >= 24
 				&& (StarShipPtr->RaceDescPtr->characteristics.max_thrust * 2 / 3 <
 				EnemyStarShipPtr->RaceDescPtr->characteristics.max_thrust
@@ -631,7 +660,7 @@ Pursue (ELEMENT *ShipPtr, EVALUATE_DESC
 						/* you're maneuverable */
 			if (MANEUVERABILITY (
 					&StarShipPtr->RaceDescPtr->cyborg_control
-					) >= MEDIUM_SHIP)
+					) >= (MEDIUM_SHIP << RESOLUTION_FACTOR)) // JMS_GFX
 			{
 				UWORD fire_flags;
 				COUNT facing;
@@ -666,9 +695,17 @@ Pursue (ELEMENT *ShipPtr, EVALUATE_DESC
 				}
 			}
 
+			// This code prevents Kohr-Ah, Ur-Quan and ISD from turning around mid-chase while pursuing Earthling.
+			if (StarShipPtr->SpeciesID == (KOHR_AH_ID | UR_QUAN_ID | ISD_ID)
+				&& EnemyStarShipPtr->SpeciesID == EARTHLING_ID 
+				&& !(EnemyStarShipPtr->cur_status_flags & (SHIP_BEYOND_MAX_SPEED | SHIP_IN_GRAVITY_WELL)))
+				distance_to_give_up_and_turn = 44;
+			else
+				distance_to_give_up_and_turn = 24;
+			
 			if (desired_thrust_angle != desired_turn_angle
 					&& (other_delta_x || other_delta_y)
-					&& EvalDescPtr->which_turn >= 24
+					&& EvalDescPtr->which_turn >= distance_to_give_up_and_turn
 					&& NORMALIZE_ANGLE (desired_thrust_angle
 					- GetVelocityTravelAngle (&OtherVelocity)
 					+ OCTANT) <= QUADRANT
@@ -859,8 +896,8 @@ Entice (ELEMENT *ShipPtr, EVALUATE_DESC
 				)
 				{
 						/* need to be close for a kill */
-					if (WRange < LONG_RANGE_WEAPON
-							&& EvalDescPtr->which_turn <= 32)
+					if (WRange < (LONG_RANGE_WEAPON << RESOLUTION_FACTOR)
+						&& EvalDescPtr->which_turn <= 32)
 					{
 						/* catch him on the back side */
 						desired_thrust_angle = desired_turn_angle;
@@ -880,15 +917,13 @@ Entice (ELEMENT *ShipPtr, EVALUATE_DESC
 		if
 		(
 #ifdef NOTYET
-			WRange < LONG_RANGE_WEAPON
+			WRange < (LONG_RANGE_WEAPON << RESOLUTION_FACTOR)
 			&&
 #endif /* NOTYET */
 					/* not at full speed */
 			!(StarShipPtr->cur_status_flags
 			& (SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED))
-			&& (PlotIntercept (
-					ShipPtr, OtherObjPtr, 40, CLOSE_RANGE_WEAPON << 1
-					)
+			&& (PlotIntercept (ShipPtr, OtherObjPtr, 40, (CLOSE_RANGE_WEAPON << RESOLUTION_FACTOR) << 1) // JMS_GFX
 #ifdef NOTYET
 			||
 			(
@@ -963,9 +998,7 @@ desired_turn_angle = desired_thrust_angl
 					- ARCTAN (ship_delta_x, ship_delta_y)
 					+ (OCTANT + 2)) <= ((OCTANT + 2) << 1)
 							/* or not on collision course */
-					|| !PlotIntercept (
-							ShipPtr, OtherObjPtr, 30, CLOSE_RANGE_WEAPON << 1
-							)))
+					|| !PlotIntercept (ShipPtr, OtherObjPtr, 30, (CLOSE_RANGE_WEAPON << RESOLUTION_FACTOR) << 1))) // JMS_GFX
 				maneuver_state &= ~THRUST;
 					/* veer off */
 			else if (cone_of_fire == 1
@@ -1003,6 +1036,120 @@ Avoid (ELEMENT *ShipPtr, EVALUATE_DESC *
 	(void) EvalDescPtr;  /* Satisfying compiler (unused parameter) */
 }
 
+void
+InGas (ELEMENT *ShipPtr, EVALUATE_DESC *EvalDescPtr)
+{
+	STARSHIP *StarShipPtr;
+	BYTE maneuver_state, facing_correct;
+	COUNT desired_thrust_angle, desired_turn_angle;
+	SIZE delta_x, delta_y;
+	SIZE ship_delta_x, ship_delta_y;
+	SIZE other_delta_x, other_delta_y;
+	ELEMENT *OtherObjPtr;
+	EVALUATE_DESC *EvalDescPtr2; // JMS
+	VELOCITY_DESC ShipVelocity, OtherVelocity;
+	
+	GetElementStarShip (ShipPtr, &StarShipPtr);
+	
+	ShipVelocity = ShipPtr->velocity;
+	GetNextVelocityComponents (&ShipVelocity, &ship_delta_x, &ship_delta_y, EvalDescPtr->which_turn);
+	ShipPtr->next.location.x = ShipPtr->current.location.x + ship_delta_x;
+	ShipPtr->next.location.y = ShipPtr->current.location.y + ship_delta_y;
+	
+	OtherObjPtr = EvalDescPtr->ObjectPtr;
+	
+	// JMS: Pointer to [ENEMY_SHIP_INDEX] has to be taken with pointer arithmetic.
+	if (!(OtherObjPtr->state_flags & PLAYER_SHIP))
+		EvalDescPtr2 = EvalDescPtr - ENEMY_WEAPON_INDEX;
+	// If for some reason this function is called as the ship's movement behavior against some other
+	// object than enemy weapon object (Baul gas cloud), we have no guarantees that
+	// "EvalDescPtr - ENEMY_WEAPON_INDEX" will actually point to enemy ship.
+	// To make sure things don't crash then, we make our ship target the gas cloud itself, not the enemy ship.
+	// Of course, this results in not-so-good AI in that case, but at least the game won't crash.
+	else
+		EvalDescPtr2 = EvalDescPtr;
+	
+	/*log_add (log_Debug, "%d, %d, %d, %d, %d, %d", 
+			 OtherObjPtr->state_flags & GASSY_SUBSTANCE,
+			 !(OtherObjPtr->state_flags & IGNORE_VELOCITY),
+			 OtherObjPtr->mass_points == 0,
+			 EvalDescPtr->which_turn <= 1,
+			 EvalDescPtr2->ObjectPtr,
+			 !(OtherObjPtr->state_flags & PLAYER_SHIP));*/
+	
+	// If Baul gas is stuck to ship and enemy ship is alive, let's aim at avoiding the enemy ship.
+	if (OtherObjPtr->state_flags & GASSY_SUBSTANCE 
+		&& !(OtherObjPtr->state_flags & IGNORE_VELOCITY)
+		&& OtherObjPtr->mass_points == 0
+		&& EvalDescPtr->which_turn <= 1
+		&& EvalDescPtr2->ObjectPtr
+		&& !(OtherObjPtr->state_flags & PLAYER_SHIP))
+	{
+		// If we're a suitable distance away from the enemy ship, avoid it.
+		if (EvalDescPtr2->which_turn > 12 && EvalDescPtr2->which_turn <= 24 && StarShipPtr->SpeciesID != KOHR_AH_ID)
+		{	
+			OtherObjPtr = EvalDescPtr2->ObjectPtr;
+			facing_correct = 32;
+		}
+		// Kohr-Ah coasts away while looking at the enemy ship.
+		else if (StarShipPtr->SpeciesID == KOHR_AH_ID)
+		{
+			OtherObjPtr = EvalDescPtr2->ObjectPtr;
+			facing_correct = 0;
+		}
+		// If we're really close or really far away, don't try to avoid enemy ship.
+		// (If we're really close, we want to fire at the enemy, and if we're far away, the Baul can't hit us anyway.)
+		else
+		{
+			OtherObjPtr = EvalDescPtr->ObjectPtr;
+			facing_correct = 0;
+		}
+	}
+	// If this ain't Baul gas we're dealing with here, examine the enemy weapon object normally.
+	else
+	{
+		OtherObjPtr = EvalDescPtr->ObjectPtr;
+		facing_correct = 0;
+	}
+	
+	OtherVelocity = OtherObjPtr->velocity;
+	GetNextVelocityComponents (&OtherVelocity, &other_delta_x, &other_delta_y, EvalDescPtr->which_turn);
+	
+	delta_x = (OtherObjPtr->current.location.x + other_delta_x) - ShipPtr->next.location.x;
+	delta_y = (OtherObjPtr->current.location.y + other_delta_y) - ShipPtr->next.location.y;
+	delta_x = WRAP_DELTA_X (delta_x);
+	delta_y = WRAP_DELTA_Y (delta_y);
+	desired_thrust_angle = (ARCTAN (delta_x, delta_y) + facing_correct) % 64;
+	
+	//log_add (log_Debug, "%d", desired_thrust_angle);
+	
+	// Return to examining the enemy weapon object.
+	OtherObjPtr = EvalDescPtr->ObjectPtr;
+	
+	maneuver_state = 0;
+	if (ShipPtr->turn_wait == 0)
+		maneuver_state |= LEFT | RIGHT;
+	if (ShipPtr->thrust_wait == 0
+		&& (StarShipPtr->SpeciesID != KOHR_AH_ID
+			|| (StarShipPtr->SpeciesID == KOHR_AH_ID && EvalDescPtr2->which_turn < 12)) // Up-close, Kohr-Ah chases. Far away it coasts.
+		&& ((OtherObjPtr->state_flags & PLAYER_SHIP)
+			|| elementsOfSamePlayer (OtherObjPtr, ShipPtr)
+			|| OtherObjPtr->preprocess_func == crew_preprocess
+			|| ((OtherObjPtr->state_flags & GASSY_SUBSTANCE) 
+				&& !(OtherObjPtr->state_flags & IGNORE_VELOCITY))
+			)
+		)
+		maneuver_state |= THRUST;
+	
+	desired_turn_angle = NORMALIZE_ANGLE (desired_thrust_angle + HALF_CIRCLE);
+	
+	if (maneuver_state & (LEFT | RIGHT))
+		TurnShip (ShipPtr, desired_thrust_angle);
+	
+	if (maneuver_state & THRUST)
+		ThrustShip (ShipPtr, desired_thrust_angle);
+}
+
 BATTLE_INPUT_STATE
 tactical_intelligence (ComputerInputContext *context, STARSHIP *StarShipPtr)
 {
@@ -1056,7 +1203,7 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 	UltraManeuverable = (BOOLEAN)(
 			RDPtr->characteristics.thrust_increment ==
 			RDPtr->characteristics.max_thrust
-			&& MANEUVERABILITY (&RDPtr->cyborg_control) >= MEDIUM_SHIP
+			&& MANEUVERABILITY (&RDPtr->cyborg_control) >= (MEDIUM_SHIP << RESOLUTION_FACTOR) // JMS_GFX
 			);
 
 	if (Ship.turn_wait == 0)
@@ -1096,7 +1243,7 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 
 				if (UltraManeuverable)
 					maneuver_turn = 16;
-				else if (MANEUVERABILITY (&RDPtr->cyborg_control) <= MEDIUM_SHIP)
+				else if (MANEUVERABILITY (&RDPtr->cyborg_control) <= (MEDIUM_SHIP << RESOLUTION_FACTOR)) // JMS_GFX
 					maneuver_turn = 48;
 				else
 					maneuver_turn = 32;
@@ -1109,14 +1256,14 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 
 				if (!ShipMoved && (ed.which_turn =
 						PlotIntercept (ed.ObjectPtr, &Ship, maneuver_turn,
-						DISPLAY_TO_WORLD (30 + (ship_bounds * 3 /* << 2 */)))))
+						DISPLAY_TO_WORLD ((30 << RESOLUTION_FACTOR) + (ship_bounds * 3 /* << 2 */))))) // JMS_GFX
 				{
 					if (ed.which_turn > 1
 							|| PlotIntercept (ed.ObjectPtr, &Ship, 1,
-							DISPLAY_TO_WORLD (35 + ship_bounds))
+							DISPLAY_TO_WORLD ((35 << RESOLUTION_FACTOR) + ship_bounds)) // JMS_GFX
 							|| PlotIntercept (ed.ObjectPtr, &Ship,
 							maneuver_turn << 1,
-							DISPLAY_TO_WORLD (40 + ship_bounds)) > 1)
+							DISPLAY_TO_WORLD ((40 << RESOLUTION_FACTOR) + ship_bounds)) > 1) // JMS_GFX
 					{
 						ed.facing = ARCTAN (-dx, -dy);
 						if (UltraManeuverable)
@@ -1142,10 +1289,9 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 				if (EnemyRDPtr->cyborg_control.ManeuverabilityIndex == 0)
 					InitCyborg (EnemyStarShipPtr);
 
-				ed.which_turn = WORLD_TO_TURN (
-						square_root ((long)dx * dx + (long)dy * dy));
-				if (ed.which_turn >
-						ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn)
+				ed.which_turn = (WORLD_TO_TURN (square_root ((long)dx * dx + (long)dy * dy))) >> RESOLUTION_FACTOR; // JMS_GFX
+				
+				if (ed.which_turn > ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn)
 				{
 					UnlockElement (hElement);
 					continue;
@@ -1164,9 +1310,9 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 
 				if (ShipMoved
 						|| ed.ObjectPtr->mass_points > MAX_SHIP_MASS
-						|| (WEAPON_RANGE (&RDPtr->cyborg_control) < LONG_RANGE_WEAPON
-						&& (WEAPON_RANGE (&RDPtr->cyborg_control) <= CLOSE_RANGE_WEAPON
-						|| (WEAPON_RANGE (&EnemyRDPtr->cyborg_control) >= LONG_RANGE_WEAPON
+						|| (WEAPON_RANGE (&RDPtr->cyborg_control) < (LONG_RANGE_WEAPON << RESOLUTION_FACTOR)
+						&& (WEAPON_RANGE (&RDPtr->cyborg_control) <= (CLOSE_RANGE_WEAPON << RESOLUTION_FACTOR)
+						|| (WEAPON_RANGE (&EnemyRDPtr->cyborg_control) >= (LONG_RANGE_WEAPON << RESOLUTION_FACTOR)
 						&& (EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags & SEEKING_WEAPON))
 						|| (
 #ifdef OLD
@@ -1196,12 +1342,9 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 			{
 				if (!(ed.ObjectPtr->state_flags & FINITE_LIFE))
 				{
-					ed.which_turn = WORLD_TO_TURN (
-							square_root ((long)dx * dx + (long)dy * dy)
-							);
+					ed.which_turn = (WORLD_TO_TURN (square_root ((long)dx * dx + (long)dy * dy))) >> RESOLUTION_FACTOR; // JMS_GFX
 
-					if (ed.which_turn <
-							ObjectsOfConcern[FIRST_EMPTY_INDEX].which_turn)
+					if (ed.which_turn < ObjectsOfConcern[FIRST_EMPTY_INDEX].which_turn)
 					{
 						ed.MoveState = PURSUE;
 						ed.facing = GetVelocityTravelAngle (
@@ -1227,7 +1370,7 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 						EnemyRDPtr->ship_data.special))
 				{
 					if ((!(ed.ObjectPtr->state_flags & (FINITE_LIFE | CREW_OBJECT))
-							&& RDPtr->characteristics.max_thrust > DISPLAY_TO_WORLD (8))
+							&& RDPtr->characteristics.max_thrust > DISPLAY_TO_WORLD (8 << RESOLUTION_FACTOR)) // JMS_GFX
 							|| NORMALIZE_ANGLE (GetVelocityTravelAngle (
 									&ed.ObjectPtr->velocity
 									) - ARCTAN (-dx, -dy)
@@ -1235,25 +1378,15 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 						ed.which_turn = 0;
 					else
 					{
-						ed.which_turn = WORLD_TO_TURN (
-								square_root ((long)dx * dx + (long)dy * dy)
-								);
+						ed.which_turn = (WORLD_TO_TURN (square_root ((long)dx * dx + (long)dy * dy))) >> RESOLUTION_FACTOR; // JMS_GFX;
 
 						ed.MoveState = ENTICE;
-						if (UltraManeuverable)
-						{
-							if (ed.which_turn == 0)
-								ed.which_turn = 1;
-							else if (ed.which_turn > 16)
-								ed.which_turn = 0;
-						}
-						else if (ed.which_turn == 0)
+
+						if (ed.which_turn == 0)
 							ed.which_turn = 1;
-						else if (ed.which_turn > 16
-								|| (MANEUVERABILITY (
-								&RDPtr->cyborg_control
-								) > MEDIUM_SHIP
-								&& ed.which_turn > 8))
+						/* Shiver: The cap on which_turn for seeking weapons raised from 16 to 20.
+							The horrible cap of 8 for above-medium speed ships has been obliterated. */
+						else if (ed.which_turn > 20)
 							ed.which_turn = 0;
 					}
 				}
@@ -1264,8 +1397,31 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 					ed.which_turn =
 							PlotIntercept (ed.ObjectPtr,
 							&Ship, ed.ObjectPtr->life_span,
-							DISPLAY_TO_WORLD (40));
-					ed.MoveState = AVOID;
+							DISPLAY_TO_WORLD (40 << RESOLUTION_FACTOR)); // JMS_GFX
+					
+					// Avoid normal shots and Baul gas that is not yet sticking to the ship.
+					if (!(ed.ObjectPtr->state_flags & GASSY_SUBSTANCE) 
+						|| (ed.ObjectPtr->state_flags & GASSY_SUBSTANCE && ed.ObjectPtr->state_flags & IGNORE_VELOCITY))
+							ed.MoveState = AVOID;
+					// This tries to make the AI behave better when Baul gas has stuck to it.
+					else if (ed.ObjectPtr->state_flags & GASSY_SUBSTANCE)
+					{
+						// This means "how should I move in reference to the gas cloud". We use a special InGas() behavior for this.
+						ed.MoveState = IN_GAS;
+						
+						// Androsynth and Druuge normally go apeshit when in gas cloud. Better make them just ignore the gas.
+						// Mmrnmhrm didn't go as batty, but it's still better when ignoring the gas clouds.
+						if (StarShipPtr->SpeciesID == ANDROSYNTH_ID 
+							|| StarShipPtr->SpeciesID == DRUUGE_ID
+							|| StarShipPtr->SpeciesID == MMRNMHRM_ID)
+						{
+							ed.MoveState = AVOID;
+							ed.which_turn = 0;
+						}
+						// Mycon works better in plain AVOID mode than with IN_GAS
+						else if (StarShipPtr->SpeciesID == MYCON_ID)
+							ed.MoveState = AVOID;
+					}
 				}
 
 				if (ed.which_turn > 0
@@ -1278,7 +1434,7 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 					ed.facing = GetVelocityTravelAngle (
 							&ed.ObjectPtr->velocity
 							);
-
+	
 					ObjectsOfConcern[ENEMY_WEAPON_INDEX] = ed;
 				}
 			}
@@ -1288,9 +1444,7 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 					|| ed.ObjectPtr->preprocess_func == crew_preprocess)
 					&& ObjectsOfConcern[CREW_OBJECT_INDEX].which_turn > 1)
 			{
-				ed.which_turn = WORLD_TO_TURN (
-						square_root ((long)dx * dx + (long)dy * dy)
-						);
+				ed.which_turn = (WORLD_TO_TURN (square_root ((long)dx * dx + (long)dy * dy))) >> RESOLUTION_FACTOR; // JMS_GFX
 
 				if (ed.which_turn == 0)
 					ed.which_turn = 1;
@@ -1331,6 +1485,8 @@ StarShipPtr->ship_input_state &= ~SPECIA
 			InputState |= BATTLE_WEAPON;
 		if (StarShipPtr->ship_input_state & SPECIAL)
 			InputState |= BATTLE_SPECIAL;
+		if (StarShipPtr->ship_input_state & DOWN) // JMS_KEYS
+			InputState |= BATTLE_DOWN;
 
 		(void) context;
 		return (InputState);
diff -ruNp src.orig/uqm/dummy.c src/uqm/dummy.c
--- src.orig/uqm/dummy.c	2017-11-01 15:30:24 -0700
+++ src/uqm/dummy.c	2017-11-01 15:31:02 -0700
@@ -21,6 +21,11 @@
  * much.
  */
 
+// JMS 2010: -Added Transport ship resource pointer, which replaces that of the Ur-Quan Probe.
+//			 -Added resource pointer for Slylandros-riding-kohrah-vessels
+//			 -Added resource pointer for Lurg
+//			 -Added resource pointer for ISD
+
 #include "dummy.h"
 
 #include "coderes.h"
@@ -67,10 +72,14 @@ typedef enum
 	VUX_CODE_RES,
 	YEHAT_CODE_RES,
 	ZOQFOT_CODE_RES,
-
-	SAMATRA_CODE_RES,
-	SIS_CODE_RES,
-	PROBE_CODE_RES
+	BAUL_CODE_RES,				// JMS
+	FOONFOON_CODE_RES,			// JMS
+	LURG_CODE_RES,				// JMS
+	ISD_CODE_RES,				// JMS
+	SLYLANDRO_KOHRAH_CODE_RES,	// JMS	
+	EXP_CODE_RES,
+	TRANSPORT_CODE_RES,			// JMS
+	SAMATRA_CODE_RES,			// JMS: Moved this under EXP_CODE_RES and TRANSPORT_CODE_RES
 } ShipCodeRes;
 
 typedef RACE_DESC *(*RaceDescInitFunc)(void);
@@ -105,9 +114,14 @@ CodeResToInitFunc(ShipCodeRes res)
 		case VUX_CODE_RES: return &init_vux;
 		case YEHAT_CODE_RES: return &init_yehat;
 		case ZOQFOT_CODE_RES: return &init_zoqfotpik;
+		case BAUL_CODE_RES: return &init_baul;
+		case FOONFOON_CODE_RES: return &init_foonfoon;
+		case LURG_CODE_RES: return &init_lurg;
+		case ISD_CODE_RES: return &init_isd;
+		case SLYLANDRO_KOHRAH_CODE_RES: return &init_slylandro_kohrah;
+		case EXP_CODE_RES: return &init_exp;
 		case SAMATRA_CODE_RES: return &init_samatra;
-		case SIS_CODE_RES: return &init_sis;
-		case PROBE_CODE_RES: return &init_probe;
+		case TRANSPORT_CODE_RES: return &init_transport;
 		default:
 		{
 			log_add (log_Warning, "Unknown SHIP identifier '%d'", res);
@@ -204,4 +218,3 @@ ReleaseCodeRes (void *CodeRef)
 {
 	return CodeRef;
 }
-
diff -ruNp src.orig/uqm/dummy.h src/uqm/dummy.h
--- src.orig/uqm/dummy.h	2017-11-01 15:30:24 -0700
+++ src/uqm/dummy.h	2017-11-01 15:31:02 -0700
@@ -21,10 +21,12 @@
 
 #include "ships/androsyn/androsyn.h"
 #include "ships/arilou/arilou.h"
+#include "ships/baul/baul.h"
 #include "ships/blackurq/blackurq.h"
 #include "ships/chenjesu/chenjesu.h"
 #include "ships/chmmr/chmmr.h"
 #include "ships/druuge/druuge.h"
+#include "ships/foonfoon/foonfoon.h"
 #include "ships/human/human.h"
 #include "ships/ilwrath/ilwrath.h"
 #include "ships/melnorme/melnorme.h"
@@ -46,7 +48,10 @@
 #include "ships/zoqfot/zoqfot.h"
 #include "ships/lastbat/lastbat.h"
 #include "ships/sis_ship/sis_ship.h"
-#include "ships/probe/probe.h"
+#include "ships/transport/transport.h"
+#include "ships/slykohr/slykohr.h"
+#include "ships/lurg/lurg.h"
+#include "ships/isd/isd.h"
 
 #endif  /* DUMMY_H */
 
diff -ruNp src.orig/uqm/element.h src/uqm/element.h
--- src.orig/uqm/element.h	2017-11-01 15:30:24 -0700
+++ src/uqm/element.h	2017-11-01 15:31:02 -0700
@@ -16,6 +16,15 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: - Added extern declaration of do_instrument_damage
+//			 - Enable Down key in melee (comment tag JMS_KEYS)
+
+// DN DEC10: - added int creature_arr_index to keep track of creature type after
+//			   player has subdued it with lander
+
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
+
 #ifndef _ELEMENT_H
 #define _ELEMENT_H
 
@@ -30,7 +39,10 @@
 typedef HLINK HELEMENT;
 
 // Bits for ELEMENT_FLAGS:
-// bits 0 and 1 are now available
+// bit 0 is now available
+#define GASSY_SUBSTANCE (1 << 1)
+		// JMS: This is used for Baul gas and spray.
+
 #define PLAYER_SHIP (1 << 2)
 		// The ELEMENT is a player controlable ship, and not some bullet,
 		// crew, asteroid, fighter, etc. This does not mean that the ship
@@ -160,6 +172,13 @@ struct element
 	void *pParent;
 			// The ship this element belongs to.
 	HELEMENT hTarget;
+	
+	union
+	{
+		BYTE creature_arr_index;	// populated by lander.c planetside when creature dies  -DN 29DEC10
+		BYTE weapon_element_index;	// Used by etc. Baul ship to remember which of it's gas clouds is which.
+	};
+	
 };
 
 #define NEUTRAL_PLAYER_NUM  -1
@@ -191,7 +210,7 @@ extern PRIMITIVE DisplayArray[MAX_DISPLA
 #define MAX_ENERGY_SIZE 42
 #define MAX_SHIP_MASS 10
 #define GRAVITY_MASS(m) ((m) > MAX_SHIP_MASS * 10)
-#define GRAVITY_THRESHOLD (COUNT)255
+#define GRAVITY_THRESHOLD (COUNT)(255 << RESOLUTION_FACTOR) // JMS_GFX
 
 #define OBJECT_CLOAKED(eptr) \
 		(GetPrimType (&GLOBAL (DisplayArray[(eptr)->PrimIndex])) >= NUM_PRIMS \
@@ -215,6 +234,8 @@ extern void RemoveElement (HLINK hLink);
 extern void spawn_planet (void);
 extern void spawn_asteroid (ELEMENT *ElementPtr);
 extern void do_damage (ELEMENT *ElementPtr, SIZE damage);
+extern void do_instrument_damage (ELEMENT *ElementPtr, SIZE damage); // JMS
+extern void do_engine_damage (ELEMENT *ElementPtr); // JMS
 extern void crew_preprocess (ELEMENT *ElementPtr);
 extern void crew_collision (ELEMENT *ElementPtr0, POINT *pPt0,
 		ELEMENT *ElementPtr1, POINT *pPt1);
@@ -225,7 +246,7 @@ extern COUNT PlotIntercept (ELEMENT *Ele
 		ELEMENT *ElementPtr1, COUNT max_turns, COUNT margin_of_error);
 
 extern void InitGalaxy (void);
-extern void MoveGalaxy (VIEW_STATE view_state, SIZE dx, SIZE dy);
+extern void MoveGalaxy (VIEW_STATE view_state, SDWORD dx, SDWORD dy);
 
 extern BOOLEAN CalculateGravity (ELEMENT *ElementPtr);
 
diff -ruNp src.orig/uqm/encount.c src/uqm/encount.c
--- src.orig/uqm/encount.c	2017-11-01 15:30:24 -0700
+++ src/uqm/encount.c	2017-11-01 15:31:02 -0700
@@ -16,6 +16,12 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2009		-Text for Orz space ship group encounter segue screen "encounter in *Below*
+// JMS 2010		-Also no planet name for the segue screen. Portal gfx instead of planet.
+//				-If enemy escape occurred, don't scavenge debris
+
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
 #include "encount.h"
 
 #include "battle.h"
@@ -28,8 +34,7 @@
 #include "gameopt.h"
 #include "gamestr.h"
 #include "globdata.h"
-#include "sis.h"
-		// for DrawStatusMessage(), SetStatusMessageMode()
+#include "sis.h" // for DrawStatusMessage(), SetStatusMessageMode()
 #include "init.h"
 #include "pickship.h"
 #include "intel.h"
@@ -38,16 +43,16 @@
 #include "settings.h"
 #include "setup.h"
 #include "sounds.h"
+#include "util.h" // JMS: For SaveContextFrame()
 #include "libs/graphics/gfx_common.h"
 #include "libs/log.h"
 #include "libs/mathlib.h"
 #include "libs/inplib.h"
 #include "libs/misc.h"
+#include "libs/log.h"
 
 
-static void DrawFadeText (const UNICODE *str1, const UNICODE *str2,
-		BOOLEAN fade_in, RECT *pRect);
-
+static void DrawFadeText (const UNICODE *str1, const UNICODE *str2, BOOLEAN fade_in, RECT *pRect);
 
 static BOOLEAN
 DoSelectAction (MENU_STATE *pMS)
@@ -102,13 +107,14 @@ GetShipFragQueueForPlayer (COUNT playerN
 void
 BuildBattle (COUNT which_player)
 {
+
 	QUEUE *pQueue;
 	HSHIPFRAG hStarShip, hNextShip;
 	HSTARSHIP hBuiltShip;
 	STARSHIP *BuiltShipPtr;
-
+	
 	EncounterRace = -1;
-
+	
 	if (GetHeadLink (&GLOBAL (npc_built_ship_q)) == 0)
 	{
 		SET_GAME_STATE (BATTLE_SEGUE, 0);
@@ -147,6 +153,7 @@ BuildBattle (COUNT which_player)
 		hBuiltShip = Build (&race_q[which_player],
 				FragPtr->race_id == SAMATRA_SHIP ?
 					SA_MATRA_ID : FragPtr->SpeciesID);
+
 		if (hBuiltShip)
 		{
 			BuiltShipPtr = LockStarShip (&race_q[which_player], hBuiltShip);
@@ -292,9 +299,8 @@ InitEncounter (void)
 	s.frame = SegueFrame;
 	DrawStamp (&s);
 
-//    t.baseline.x = SIS_SCREEN_WIDTH >> 1;
 	t.baseline.x = (SIS_SCREEN_WIDTH >> 1) + 1;
-	t.baseline.y = 10;
+	t.baseline.y = 10 << RESOLUTION_FACTOR; // JMS_GFX
 	t.align = ALIGN_CENTER;
 
 	SetContextFont (MicroFont);
@@ -306,8 +312,12 @@ InitEncounter (void)
 				// "ENCOUNTER IN"
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
-		t.baseline.y += 12;
-		t.pStr = GAME_STRING (ENCOUNTER_STRING_BASE + 1);
+		t.baseline.y += 12 << RESOLUTION_FACTOR; // JMS_GFX
+		if (GET_GAME_STATE (ORZ_SPACE_SIDE) > 1)
+			t.pStr = GAME_STRING (NAVIGATION_STRING_BASE + 6);
+				// JMS: * Below *
+		else
+			t.pStr = GAME_STRING (ENCOUNTER_STRING_BASE + 1);
 				// "DEEP SPACE"
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
@@ -320,20 +330,38 @@ InitEncounter (void)
 				// "ENCOUNTER AT"
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
-		t.baseline.y += 12;
+		t.baseline.y += 12 << RESOLUTION_FACTOR; // JMS_GFX
 		GetClusterName (CurStarDescPtr, buf);
 		t.pStr = buf;
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
-		t.baseline.y += 12;
-		t.pStr = GLOBAL_SIS (PlanetName);
+		t.baseline.y += 12 << RESOLUTION_FACTOR; // JMS_GFX
+		
+		// JMS: Orz space portal shenanigans. Don't display planet name.
+		if(CurStarDescPtr->Index == ORZ_SPACE_PORTAL_DEFINED)
+			t.pStr = "";
+		else
+			t.pStr = GLOBAL_SIS (PlanetName);
+		
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
+		
 	}
 
 	s.origin.x = SIS_SCREEN_WIDTH >> 1;
 	s.origin.y = SIS_SCREEN_HEIGHT >> 1;
 	s.frame = planet[0];
+	
+	// JMS: Orz space portal gfx shenanigans.
+	// Let's replace the planet graphics with portal graphics when encountering
+	// ships in Orz space portal "star system". This doesn't do anything to the actual
+	// battle graphics, just for the pre-battle communicate/attack! screen.
+	if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
+	{
+		if(CurStarDescPtr->Index == ORZ_SPACE_PORTAL_DEFINED)
+			s.frame = CaptureDrawable (LoadGraphic (SEGUE_ORZSPACEPORTAL_ANIM));
+	}
+	
 	DrawStamp (&s);
 
 	if (LOBYTE (GLOBAL (CurrentActivity)) != IN_LAST_BATTLE)
@@ -350,8 +378,8 @@ InitEncounter (void)
 			{-49,  18},
 			{ 52,  -6},
 			{-52,  -6},
-			{ 44, -27},
-			{-44, -27},
+			{ 44,  -27},
+			{-44,  -27},
 		};
 
 		for (hStarShip = GetHeadLink (&GLOBAL (npc_built_ship_q)), i = 0;
@@ -367,18 +395,27 @@ InitEncounter (void)
 				hNextShip = hStarShip;
 
 			s.origin = display_pt[i % NUM_DISPLAY_PTS];
+			
 			if (i >= NUM_DISPLAY_PTS)
 			{
 				COUNT angle, radius;
-
+				
 				radius = square_root ((long)s.origin.x * s.origin.x
-						+ (long)s.origin.y * s.origin.y)
-						+ ((i / NUM_DISPLAY_PTS) * 18);
-
+									  + (long)s.origin.y * s.origin.y)
+				+ ((i / NUM_DISPLAY_PTS) * 18);
+				
+				radius <<= RESOLUTION_FACTOR; // JMS_GFX
+				
 				angle = ARCTAN (s.origin.x, s.origin.y);
-				s.origin.x = COSINE (angle, radius);
-				s.origin.y = SINE (angle, radius);
+				s.origin.x = (COSINE (angle, radius));
+				s.origin.y = (SINE (angle, radius));
+			}
+			else
+			{
+				s.origin.x <<= RESOLUTION_FACTOR; // JMS_GFX
+				s.origin.y <<= RESOLUTION_FACTOR; // JMS_GFX
 			}
+			
 			s.frame = SetAbsFrameIndex (FragPtr->icons, 0);
 			GetFrameRect (s.frame, &r);
 			s.origin.x += (SIS_SCREEN_WIDTH >> 1) - (r.extent.width >> 1);
@@ -417,12 +454,13 @@ InitEncounter (void)
 }
 
 static void
-DrawFadeText (const UNICODE *str1, const UNICODE *str2, BOOLEAN fade_in,
-		RECT *pRect)
+DrawFadeText (const UNICODE *str1, const UNICODE *str2, BOOLEAN fade_in, RECT *pRect)
 {
 	SIZE i;
 	DWORD TimeIn;
 	TEXT t1, t2;
+	RECT r1, r2;
+	
 	static const Color fade_cycle[] =
 	{
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0A, 0x0A, 0x0A), 0x1D),
@@ -435,13 +473,13 @@ DrawFadeText (const UNICODE *str1, const
 	};
 #define NUM_FADES (sizeof (fade_cycle) / sizeof (fade_cycle[0]))
 
-	t1.baseline.x = pRect->corner.x + 100;
-	t1.baseline.y = pRect->corner.y + 45;
+	t1.baseline.x = pRect->corner.x + (100 << RESOLUTION_FACTOR); // JMS_GFX
+	t1.baseline.y = pRect->corner.y + (45 << RESOLUTION_FACTOR); // JMS_GFX
 	t1.align = ALIGN_CENTER;
 	t1.pStr = str1;
 	t1.CharCount = (COUNT)~0;
 	t2 = t1;
-	t2.baseline.y += 11;
+	t2.baseline.y += 11 << RESOLUTION_FACTOR; // JMS_GFX
 	t2.pStr = str2;
 
 	FlushInput ();
@@ -477,10 +515,15 @@ DrawFadeText (const UNICODE *str1, const
 			SleepThreadUntil (TimeIn + (ONE_SECOND / 20));
 			TimeIn = GetTimeCounter ();
 		}
-		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
-		font_DrawText (&t1);
-		font_DrawText (&t2);
+		SetContextForeGroundColor (BUILD_COLOR_RGBA (0x50, 0x50, 0x50, 0xff));
+		TextRect(&t1, &r1, NULL);
+		TextRect(&t2, &r2, NULL);
+		
+		if (RESOLUTION_FACTOR == 0)
+		{
+			DrawFilledRectangle (&r1);
+			DrawFilledRectangle (&r2);
+		}
 	}
 }
 
@@ -521,6 +564,11 @@ UninitEncounter (void)
 		UNICODE buf[80];
 		HSHIPFRAG hStarShip;
 		SHIP_FRAGMENT *FragPtr;
+		
+		// JMS: These are for fixing a bug at drawing "debris scavenged" in hires4x
+		RECT	save_r;
+		STAMP	saveMetallicFrame;
+		
 		static const Color fade_ship_cycle[] =
 		{
 			BUILD_COLOR (MAKE_RGB15_INIT (0x07, 0x00, 0x00), 0x2F),
@@ -548,8 +596,9 @@ UninitEncounter (void)
 		VictoryState = (
 				battle_counter[1] || !battle_counter[0]
 				|| GET_GAME_STATE (URQUAN_PROTECTING_SAMATRA)
+				|| GET_GAME_STATE (ENEMY_ESCAPE_OCCURRED) // JMS: If enemy escaped we can't scavenge debris.
 				) ? 0 : 1;
-
+		
 		hStarShip = GetHeadLink (&GLOBAL (npc_built_ship_q));
 		FragPtr = LockShipFrag (&GLOBAL (npc_built_ship_q), hStarShip);
 		EncounterRace = FragPtr->race_id;
@@ -619,12 +668,11 @@ UninitEncounter (void)
 
 								DrawStatusMessage (NULL);
 								
-								ship_s.origin.x = scavenge_r.corner.x + 32;
-								ship_s.origin.y = scavenge_r.corner.y + 56;
+								ship_s.origin.x = scavenge_r.corner.x + (32 << RESOLUTION_FACTOR); // JMS_GFX
+								ship_s.origin.y = scavenge_r.corner.y + (56 << RESOLUTION_FACTOR); // JMS_GFX
 								ship_s.frame = IncFrameIndex (FragPtr->icons);
 								DrawStamp (&ship_s);
-								SetContextForeGroundColor (
-										BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
+								SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
 								SetContextFont (TinyFont);
 
 								utf8StringCopy (buf, sizeof buf,
@@ -632,13 +680,13 @@ UninitEncounter (void)
 								// XXX: this will not work with UTF-8 strings
 								strupr (buf);
 
-								t.baseline.x = scavenge_r.corner.x + 100;
-								t.baseline.y = scavenge_r.corner.y + 68;
+								t.baseline.x = scavenge_r.corner.x + (100 << RESOLUTION_FACTOR); // JMS_GFX
+								t.baseline.y = scavenge_r.corner.y + (68 << RESOLUTION_FACTOR); // JMS_GFX
 								t.align = ALIGN_CENTER;
 								t.pStr = buf;
 								t.CharCount = (COUNT)~0;
 								font_DrawText (&t);
-								t.baseline.y += 6;
+								t.baseline.y += 6 << RESOLUTION_FACTOR; // JMS_GFX
 								t.pStr = GAME_STRING (
 										ENCOUNTER_STRING_BASE + 3);
 										// "BATTLE GROUP"
@@ -648,32 +696,48 @@ UninitEncounter (void)
 								ship_s.frame = FragPtr->icons;
 
 								SetContextFont (MicroFont);
-								str1 = GAME_STRING (
-										ENCOUNTER_STRING_BASE + 4);
+								
+								// JMS: Let's store the rectangle behind "Enemy ships destroyed" (before drawing the text on it).
+								if (RESOLUTION_FACTOR != 0)
+								{
+									// These values are inferred from DrawFadeText.
+									// However, they're not the same (100 and 45) because the text there is centered,
+									// but these rect coords are for the upper-left corner, not center.
+									save_r.corner.x = scavenge_r.corner.x + (70 << RESOLUTION_FACTOR); // JMS_GFX
+									save_r.corner.y = scavenge_r.corner.y + (35 << RESOLUTION_FACTOR); // JMS_GFX
+									
+									// These are wild-assed guesses.
+									save_r.extent.width  = 60 << RESOLUTION_FACTOR;
+									save_r.extent.height = 30 << RESOLUTION_FACTOR; 
+									
+									// Now that we have the size and placement of the rectangle, let's store it.
+									saveMetallicFrame = SaveContextFrame (&save_r);
+								}
+								
+								str1 = GAME_STRING (ENCOUNTER_STRING_BASE + 4);
 										// "Enemy Ships"
-								str2 = GAME_STRING (
-										ENCOUNTER_STRING_BASE + 5),
+								str2 = GAME_STRING (ENCOUNTER_STRING_BASE + 5),
 										// "Destroyed"
 								DrawFadeText (str1, str2, TRUE, &scavenge_r);
 							}
 
-							r.corner.y = scavenge_r.corner.y + 9;
-							r.extent.height = 22;
+							r.corner.y = scavenge_r.corner.y + (9 << RESOLUTION_FACTOR); // JMS_GFX
+							r.extent.height = 22 << RESOLUTION_FACTOR; // JMS_GFX
 
 							SetContextForeGroundColor (BLACK_COLOR);
 
-							r.extent.width = 34;
+							r.extent.width = 34 << RESOLUTION_FACTOR; // JMS_GFX
 							r.corner.x = scavenge_r.corner.x +
 									scavenge_r.extent.width
-									- (10 + r.extent.width);
+									- ((10 << RESOLUTION_FACTOR) + r.extent.width); // JMS_GFX
 							DrawFilledRectangle (&r);
 
 							/* collect bounty ResUnits */
 							j = race_bounty[EncounterRace] >> 3;
 							RecycleAmount += j;
 							sprintf (buf, "%u", RecycleAmount);
-							t.baseline.x = r.corner.x + r.extent.width - 1;
-							t.baseline.y = r.corner.y + 14;
+							t.baseline.x = r.corner.x + r.extent.width - 1 - 5 * RESOLUTION_FACTOR; // JMS_GFX;
+							t.baseline.y = r.corner.y + (14 << RESOLUTION_FACTOR); // JMS_GFX
 							t.align = ALIGN_RIGHT;
 							t.pStr = buf;
 							t.CharCount = (COUNT)~0;
@@ -683,17 +747,17 @@ UninitEncounter (void)
 							DeltaSISGauges (0, 0, j);
 
 							if ((VictoryState++ - 1) % MAX_DEAD_DISPLAYED)
-								ship_s.origin.x += 17;
+								ship_s.origin.x += 17 << RESOLUTION_FACTOR; // JMS_GFX
 							else
 							{
 								SetContextForeGroundColor (BLACK_COLOR);
 
-								r.corner.x = scavenge_r.corner.x + 10;
-								r.extent.width = 104;
+								r.corner.x = scavenge_r.corner.x + (10 << RESOLUTION_FACTOR); // JMS_GFX
+								r.extent.width = (104 << RESOLUTION_FACTOR); // JMS_GFX
 								DrawFilledRectangle (&r);
 
-								ship_s.origin.x = r.corner.x + 2;
-								ship_s.origin.y = scavenge_r.corner.y + 12;
+								ship_s.origin.x = r.corner.x + (2 << RESOLUTION_FACTOR); // JMS_GFX
+								ship_s.origin.y = scavenge_r.corner.y + (12 << RESOLUTION_FACTOR); // JMS_GFX
 							}
 
 							if (Sleepy)
@@ -746,30 +810,38 @@ UninitEncounter (void)
 				if (!CurrentInputState.key[PlayerControls[0]][KEY_ESCAPE])
 				{
 					SetContextForeGroundColor (BLACK_COLOR);
-					r.corner.x = scavenge_r.corner.x + 10;
-					r.extent.width = 132;
+					r.corner.x = scavenge_r.corner.x + (10 << RESOLUTION_FACTOR); // JMS_GFX
+					r.extent.width = 132 << RESOLUTION_FACTOR; // JMS_GFX
 					DrawFilledRectangle (&r);
-					sprintf (buf, "%u %s", RecycleAmount,
-							GAME_STRING (STATUS_STRING_BASE + 1)); // "RU"
+					sprintf (buf, "%u %s", RecycleAmount, GAME_STRING (STATUS_STRING_BASE + 1)); // "RU"
 					t.baseline.x = r.corner.x + (r.extent.width >> 1);
-					t.baseline.y = r.corner.y + 14;
+					t.baseline.y = r.corner.y + (14 << RESOLUTION_FACTOR); // JMS_GFX
 					t.align = ALIGN_CENTER;
 					t.pStr = buf;
 					t.CharCount = (COUNT)~0;
-					SetContextForeGroundColor (
-							BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x18), 0x50));
+					SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x18), 0x50));
 					font_DrawText (&t);
 
 					str1 = GAME_STRING (ENCOUNTER_STRING_BASE + 6);
 							// "Debris"
 					str2 = GAME_STRING (ENCOUNTER_STRING_BASE + 7);
 							// "Scavenged"
+					
+					// JMS: Now we draw the clean metallic frame to erase the "Enemy ships destroyed"
+					// text before drawing "debris scavenged."
+					if(RESOLUTION_FACTOR != 0)
+						DrawStamp (&saveMetallicFrame);
+					
 					DrawFadeText (str1, str2, TRUE, &scavenge_r);
 					UnlockMutex (GraphicsLock);
 					WaitForAnyButton (TRUE, ONE_SECOND * 2, FALSE);
 					LockMutex (GraphicsLock);
 					if (!CurrentInputState.key[PlayerControls[0]][KEY_ESCAPE])
 						DrawFadeText (str1, str2, FALSE, &scavenge_r);
+					
+					// JMS: The final cleanup of the "Debris scavenged". Without this, an ugly grey ghost-text would remain.
+					if(RESOLUTION_FACTOR != 0)
+						DrawStamp (&saveMetallicFrame);
 				}
 			}
 
@@ -793,7 +865,7 @@ ExitUninitEncounter:
 
 void
 EncounterBattle (void)
-{
+{ 
 	ACTIVITY OldActivity;
 	extern UWORD nth_frame;
 	InputContext *savedPlayerInput = NULL;
diff -ruNp src.orig/uqm/encount.h src/uqm/encount.h
--- src.orig/uqm/encount.h	2017-11-01 15:30:25 -0700
+++ src/uqm/encount.h	2017-11-01 15:31:02 -0700
@@ -16,6 +16,13 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2009 - Portal to Orz space enum
+// JMS 2010 - Lurg home system enum
+//			- Enum for those guys that have mysteriously vanished
+//			- Enum for Gamma Janus
+
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
 #ifndef _ENCOUNT_H
 #define _ENCOUNT_H
 
@@ -58,6 +65,9 @@ struct encounter
 	POINT origin;
 	COUNT radius;
 
+	POINT destination_pt;	// JMS: This one helps when we want to designate a target destination to a Hyperspace spoor.
+	POINT home_pt;			// JMS: This one helps when we want to designate a starting point to a Hyperspace spoor.
+	
 	STAR_DESC SD;
 	BRIEF_SHIP_INFO ShipList[MAX_HYPER_SHIPS];
 
@@ -109,7 +119,6 @@ enum
 	URQUAN_WRECK_DEFINED,
 	VUX_BEAST_DEFINED,
 	SAMATRA_DEFINED,
-	ZOQ_SCOUT_DEFINED,
 	MYCON_DEFINED,
 	EGG_CASE0_DEFINED,
 	EGG_CASE1_DEFINED,
@@ -122,9 +131,18 @@ enum
 	ORZ_DEFINED,
 	THRADD_DEFINED,
 	RAINBOW_DEFINED,
+	RAINBOW_KNOWN_DEFINED,
 	ILWRATH_DEFINED,
 	ANDROSYNTH_DEFINED,
-	MYCON_TRAP_DEFINED
+	MYCON_TRAP_DEFINED,
+	LURG_DEFINED,					// JMS: Lurg home system
+	SHOFIXTI_CRASH_SITE_DEFINED,	// JMS: Shofixti distress site
+	SLAVERACE_DEFINED,
+	MELNORME_HOME_DEFINED,          // Also generates deflection shield in hyperspace
+	ORZ_SPACE_PORTAL_DEFINED,		// JMS: Portal to ORZ space
+	HINT_DEFINED,					// JMS: Those guys that have mysteriously vanished
+	HINT2_DEFINED,					// JMS: Gamma Janus, the supposed precursor artifact that Yehat tell player about
+	SHOFIXTI_COLONY_DEFINED,		// JMS: Crappy Shofixti colony
 };
 
 #define UMGAH_DEFINED TALKING_PET_DEFINED
@@ -183,6 +201,12 @@ extern void GeneratePkunk (BYTE control)
 extern void GenerateSupox (BYTE control);
 extern void GenerateRainbow (BYTE control);
 extern void GenerateIlwrath (BYTE control);
+extern void GenerateSlaveRace (BYTE control);
+extern void GenerateOrzSpacePortal (BYTE control);		// JMS
+extern void GenerateLurg (BYTE control);				// JMS
+extern void GenerateShofixtiCrashSite (BYTE control);	// JMS
+extern void GenerateHint (BYTE control);				// JMS
+extern void GenerateHint2 (BYTE control);				// JMS
 
 // Last race the player battled with, or -1 if no battle took place.
 // Set to -1 by some funcs to inhibit IP groups from intercepting
diff -ruNp src.orig/uqm/flash.c src/uqm/flash.c
--- src.orig/uqm/flash.c	2017-11-01 15:30:25 -0700
+++ src/uqm/flash.c	2017-11-01 15:31:02 -0700
@@ -14,6 +14,8 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+// JMS_GFX: Hi-res fixes to Flash_setOverlay().
+
 // NOTE: A lot of this code is untested. Only highlite and overlay flash
 //       areas, drawing directly to the screen, using a cache, are
 //       currently in use.
@@ -155,7 +157,7 @@ Flash_createOverlay (CONTEXT gfxContext,
 		context->rect.extent.width = 0;
 		context->rect.extent.height = 0;
 	} else
-		Flash_setOverlay (context, origin, overlay);
+		Flash_setOverlay (context, origin, overlay, FALSE);
 	
 	return context;
 }
@@ -449,18 +451,23 @@ Flash_getRect (FlashContext *context, RE
 	*rect = context->rect;
 }
 
+// JMS_GFX: The cleanup boolean can be used when changing between normal and hi-res modes.
+// It ensures that an ugly wrong-sized flash overlay from previous resolution is cleaned
+// from the flash process.
 void
-Flash_setOverlay (FlashContext *context, const POINT *origin, FRAME overlay)
+Flash_setOverlay (FlashContext *context, const POINT *origin, FRAME overlay, BOOLEAN cleanup)
 {
 	assert(context->type == FlashType_overlay);
 
-	if (context->started)
+	if (context->started && !cleanup)
 	{
 		Flash_drawFrame (context, context->original);
 		Flash_clearCache (context);
 	}
 	
-	context->u.overlay.frame = overlay;
+	if (!cleanup)
+		context->u.overlay.frame = overlay;
+	
 	GetFrameRect (overlay, &context->rect);
 	context->rect.corner.x += origin->x;
 	context->rect.corner.y += origin->y;
diff -ruNp src.orig/uqm/flash.h src/uqm/flash.h
--- src.orig/uqm/flash.h	2017-11-01 15:30:25 -0700
+++ src/uqm/flash.h	2017-11-01 15:31:02 -0700
@@ -203,13 +203,11 @@ void Flash_setFrameTime (FlashContext *c
 TimeCount Flash_nextTime (FlashContext *context);
 void Flash_setRect (FlashContext *context, const RECT *rect);
 void Flash_getRect (FlashContext *context, RECT *rect);
-void Flash_setOverlay(FlashContext *context, const POINT *origin,
-		FRAME overlay);
+void Flash_setOverlay(FlashContext *context, const POINT *origin, FRAME overlay, BOOLEAN cleanup); // JMS_GFX
 void Flash_preUpdate (FlashContext *context);
 void Flash_postUpdate (FlashContext *context);
 void Flash_setCacheSize (FlashContext *context, COUNT size);
 COUNT Flash_getCacheSize (const FlashContext *context);
 
-
 #endif  /* _FLASH_H */
 
diff -ruNp src.orig/uqm/fmv.c src/uqm/fmv.c
--- src.orig/uqm/fmv.c	2017-11-01 15:30:25 -0700
+++ src/uqm/fmv.c	2017-11-01 15:31:02 -0700
@@ -16,6 +16,10 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: Added Lurg cutscene.
+
+// JMS_GFX 2011: Merged resolution Factor stuff from UQM-HD.
+
 #include "fmv.h"
 
 #include "controls.h"
@@ -82,7 +86,27 @@ SplashScreen (void (* DoProcessing)(DWOR
 	LockMutex (GraphicsLock);
 	SetContext (ScreenContext);
 	s.origin.x = s.origin.y = 0;
-	s.frame = CaptureDrawable (LoadGraphic (TITLE_ANIM));
+	
+	//DC: Title Splashscreen.
+	if (resolutionFactor < 1)
+	{
+		printf("Loading 1x Splashscreen\n");
+		s.frame = CaptureDrawable (LoadGraphic (TITLE_ANIM));
+	}
+	
+	else if (resolutionFactor == 1)
+	{
+		printf("Loading 2x Splashscreen\n");
+		s.frame = CaptureDrawable (LoadGraphic (TITLE_2X));
+	}
+	
+	else if(resolutionFactor > 1)
+	{
+		printf("Loading 4x Splashscreen\n");
+		s.frame = CaptureDrawable (LoadGraphic (TITLE_4X));
+	}
+	// DC: End of spashscreen resolutions.
+	
 	DrawStamp (&s);
 	DestroyDrawable (ReleaseDrawable (s.frame));
 	UnlockMutex (GraphicsLock);
@@ -132,5 +156,23 @@ Victory (void)
 	FadeScreen (FadeAllToBlack, 0);
 }
 
+// JMS: This displays the Lurg cutscene after finding the black orb & new precursor ship
+void
+LurgCutScene (void)
+{
+	SleepThreadUntil (FadeScreen (FadeAllToBlack, ONE_SECOND / 2));
+
+	ShowPresentation (LURGPRES_STRTAB); // JMS: Changed to UQM 0.7. style.
+	
+	FadeScreen (FadeAllToBlack, 0);
+}
+
+void
+Logo (void)
+{
+	ShowPresentation ("slides.logo");
+}
+
+
 
 
diff -ruNp src.orig/uqm/fmv.h src/uqm/fmv.h
--- src.orig/uqm/fmv.h	2017-11-01 15:30:25 -0700
+++ src/uqm/fmv.h	2017-11-01 15:31:02 -0700
@@ -14,6 +14,8 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+// JMS 2010: Added declaration of Lurg cutscene function (At finding black orb & new ship)
+
 #ifndef _FMV_H
 #define _FMV_H
 
@@ -22,9 +24,11 @@
 #include "libs/gfxlib.h"
 #define WANT_SHIP_SPINS
 
+extern void Logo (void);
 extern void SplashScreen (void (* DoProcessing)(DWORD TimeOut));
 extern void Introduction (void);
 extern void Victory (void);
+extern void LurgCutScene (void); // JMS
 extern void DoShipSpin (COUNT index, MUSIC_REF hMusic);
 
 extern BOOLEAN ShowPresentation (RESOURCE presentation);
diff -ruNp src.orig/uqm/galaxy.c src/uqm/galaxy.c
--- src.orig/uqm/galaxy.c	2017-11-01 15:30:25 -0700
+++ src/uqm/galaxy.c	2017-11-01 15:31:02 -0700
@@ -18,6 +18,10 @@
 
 /* background starfield - used to generate agalaxy.asm */
 
+// JMS 2009: Added some blue color thingy for ORZ space, but not sure what it actually does...
+
+// JMS 2011: Changed a lot of SIZEs and COORDs to SDWORDs and POINTs to DPOINTs to avoid overflows in hi-res.
+
 #include "element.h"
 #include "globdata.h"
 #include "init.h"
@@ -41,8 +45,9 @@ extern PRIM_LINKS DisplayLinks;
 			+ MED_STAR_COUNT \
 			+ SML_STAR_COUNT)
 
-POINT SpaceOrg;
-static POINT log_star_array[NUM_STARS];
+// JMS: Changed from POINT to DPOINT
+DPOINT SpaceOrg;
+static DPOINT log_star_array[NUM_STARS];
 
 #define NUM_STAR_PLANES 3
 
@@ -50,9 +55,9 @@ typedef struct
 {
 	COUNT min_star_index;
 	COUNT num_stars;
-	POINT *star_array;
-	POINT *pmin_star;
-	POINT *plast_star;
+	DPOINT *star_array; // JMS: Changed from POINT to DPOINT
+	DPOINT *pmin_star;  // JMS: Changed from POINT to DPOINT
+	DPOINT *plast_star; // JMS: Changed from POINT to DPOINT
 } STAR_BLOCK;
 
 STAR_BLOCK StarBlock[NUM_STAR_PLANES] =
@@ -87,7 +92,7 @@ SortStarBlock (STAR_BLOCK *pStarBlock)
 		{
 			if (pStarBlock->star_array[i].y > pStarBlock->star_array[j].y)
 			{
-				POINT temp;
+				DPOINT temp; // JMS: Changed from POINT to DPOINT
 
 				temp = pStarBlock->star_array[i];
 				pStarBlock->star_array[i] = pStarBlock->star_array[j];
@@ -97,17 +102,17 @@ SortStarBlock (STAR_BLOCK *pStarBlock)
 	}
 
 	pStarBlock->min_star_index = 0;
-	pStarBlock->pmin_star = &pStarBlock->star_array[0];
-	pStarBlock->plast_star =
-			&pStarBlock->star_array[pStarBlock->num_stars - 1];
+	pStarBlock->pmin_star  = &pStarBlock->star_array[0];
+	pStarBlock->plast_star = &pStarBlock->star_array[pStarBlock->num_stars - 1];
 }
 
+// JMS: Changed dx, dy from SIZE to SDWORD
 static void
-WrapStarBlock (SIZE plane, SIZE dx, SIZE dy)
+WrapStarBlock (SIZE plane, SDWORD dx, SDWORD dy)
 {
 	COUNT i;
-	POINT *ppt;
-	SIZE offs_y;
+	DPOINT *ppt; // JMS: Changed from POINT to DPOINT
+	SDWORD offs_y; // JMS: Changed from SIZE to SDWORD
 	COUNT num_stars;
 	STAR_BLOCK *pStarBlock;
 
@@ -237,13 +242,9 @@ void
 InitGalaxy (void)
 {
 	COUNT i, factor;
-	POINT *ppt;
+	DPOINT *ppt; // JMS: Changed POINT to DPOINT
 	PRIM_LINKS Links;
 
-	log_add (log_Debug, "InitGalaxy(): transition_width = %d, "
-			"transition_height = %d",
-			TRANSITION_WIDTH, TRANSITION_HEIGHT);
-
 	Links = MakeLinks (END_OF_LIST, END_OF_LIST);
 	factor = ONE_SHIFT + MAX_REDUCTION + (BACKGROUND_SHIFT - 3);
 	for (i = 0, ppt = log_star_array; i < NUM_STARS; ++i, ++ppt)
@@ -255,28 +256,27 @@ InitGalaxy (void)
 		if (i == BIG_STAR_COUNT || i == BIG_STAR_COUNT + MED_STAR_COUNT)
 			++factor;
 
-		ppt->x = (COORD)((UWORD)TFB_Random () % SPACE_WIDTH) << factor;
-		ppt->y = (COORD)((UWORD)TFB_Random () % SPACE_HEIGHT) << factor;
+		// JMS Changed COORDS to SDWORDS
+		ppt->x = (SDWORD)((UWORD)TFB_Random () % SPACE_WIDTH) << factor;
+		ppt->y = (SDWORD)((UWORD)TFB_Random () % SPACE_HEIGHT) << factor;
 
 		if (i < BIG_STAR_COUNT + MED_STAR_COUNT)
 		{
 			SetPrimType (&DisplayArray[p], STAMP_PRIM);
-			SetPrimColor (&DisplayArray[p],
-					BUILD_COLOR (MAKE_RGB15 (0x0B, 0x0B, 0x1F), 0x09));
+			SetPrimColor (&DisplayArray[p], BUILD_COLOR (MAKE_RGB15 (0x0B, 0x0B, 0x1F), 0x09));
 			DisplayArray[p].Object.Stamp.frame = stars_in_space;
 		}
 		else
 		{
 			SetPrimType (&DisplayArray[p], POINT_PRIM);
 			if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
-				SetPrimColor (&DisplayArray[p],
-						BUILD_COLOR (MAKE_RGB15 (0x15, 0x15, 0x15), 0x07));
+				SetPrimColor (&DisplayArray[p], BUILD_COLOR (MAKE_RGB15 (0x15, 0x15, 0x15), 0x07)); // Grey small dot stars in melee.
+			else if (GET_GAME_STATE (ORZ_SPACE_SIDE) > 1)
+				SetPrimColor (&DisplayArray[p], BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x15), 0x8C));
 			else if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
-				SetPrimColor (&DisplayArray[p],
-						BUILD_COLOR (MAKE_RGB15 (0x14, 0x00, 0x00), 0x8C));
+				SetPrimColor (&DisplayArray[p], BUILD_COLOR (MAKE_RGB15 (0x14, 0x00, 0x00), 0x8C));
 			else
-				SetPrimColor (&DisplayArray[p],
-						BUILD_COLOR (MAKE_RGB15 (0x00, 0x0E, 0x00), 0x8C));
+				SetPrimColor (&DisplayArray[p], BUILD_COLOR (MAKE_RGB15 (0x00, 0x0E, 0x00), 0x8C));
 		}
 
 		InsertPrim (&Links, p, GetPredLink (Links));
@@ -287,9 +287,9 @@ InitGalaxy (void)
 	SortStarBlock (&StarBlock[2]);
 }
 
+// JMS: Changed POINT *pt2 to DPOINT *pt2 and dx, dy from SIZE to SDWORD
 static BOOLEAN
-CmpMovePoints (const POINT *pt1, const POINT *pt2, SIZE dx, SIZE dy,
-			   SIZE reduction)
+CmpMovePoints (const POINT *pt1, const DPOINT *pt2, SDWORD dx, SDWORD dy, SIZE reduction)
 {
 	if (optMeleeScale == TFB_SCALE_STEP)
 	{
@@ -303,8 +303,9 @@ CmpMovePoints (const POINT *pt1, const P
 	}
 }
 
+// JMS: Changed dx, dy from SIZE to SDWORD
 void
-MoveGalaxy (VIEW_STATE view_state, SIZE dx, SIZE dy)
+MoveGalaxy (VIEW_STATE view_state, SDWORD dx, SDWORD dy)
 {
 	PRIMITIVE *pprim;
 	static const COUNT star_counts[] =
@@ -320,7 +321,7 @@ MoveGalaxy (VIEW_STATE view_state, SIZE
 		COUNT reduction;
 		COUNT i;
 		COUNT iss;
-		POINT *ppt;
+		DPOINT *ppt;
 		int wrap_around;
 
 		reduction = zoom_out;
@@ -417,10 +418,11 @@ MoveGalaxy (VIEW_STATE view_state, SIZE
 		}
 		else
 		{
-			dx = (COORD)(LOG_SPACE_WIDTH >> 1)
+			// JMS: Changed COORDs to SDWORDs
+			dx = (SDWORD)(LOG_SPACE_WIDTH >> 1)
 					- (LOG_SPACE_WIDTH >> ((MAX_REDUCTION + 1)
 					- MAX_VIS_REDUCTION));
-			dy = (COORD)(LOG_SPACE_HEIGHT >> 1)
+			dy = (SDWORD)(LOG_SPACE_HEIGHT >> 1)
 					- (LOG_SPACE_HEIGHT >> ((MAX_REDUCTION + 1)
 					- MAX_VIS_REDUCTION));
 			if (optMeleeScale == TFB_SCALE_STEP)
@@ -431,9 +433,7 @@ MoveGalaxy (VIEW_STATE view_state, SIZE
 
 		ppt = log_star_array;
 		for (iss = 0, pprim = DisplayArray, wrap_around = LOG_SPACE_WIDTH;
-				iss < 3 && 
-				(view_state == VIEW_CHANGE || CmpMovePoints (
-					&pprim->Object.Point, ppt, dx, dy, reduction));
+				iss < 3 && (view_state == VIEW_CHANGE || CmpMovePoints (&pprim->Object.Point, ppt, dx, dy, reduction));
 				++iss, wrap_around <<= 1, dx <<= 1, dy <<= 1)
 		{
 			for (i = star_counts[iss]; i > 0; --i, ++pprim, ++ppt)
@@ -447,10 +447,8 @@ MoveGalaxy (VIEW_STATE view_state, SIZE
 				}
 				else
 				{
-					pprim->Object.Point.x = ((ppt->x - dx) << ZOOM_SHIFT)
-							/ reduction;
-					pprim->Object.Point.y = ((ppt->y - dy) << ZOOM_SHIFT)
-							/ reduction;
+					pprim->Object.Point.x = ((ppt->x - dx) << ZOOM_SHIFT) / reduction;
+					pprim->Object.Point.y = ((ppt->y - dy) << ZOOM_SHIFT) / reduction;
 				}
 			}
 			if (optMeleeScale == TFB_SCALE_STEP)
diff -ruNp src.orig/uqm/gameev.c src/uqm/gameev.c
--- src.orig/uqm/gameev.c	2017-11-01 15:30:25 -0700
+++ src/uqm/gameev.c	2017-11-01 15:31:02 -0700
@@ -15,6 +15,8 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+// JMS 2010: Created events, which move transport ships
+
 #include "gameev.h"
 
 #include "build.h"
@@ -26,6 +28,8 @@
 #include "libs/compiler.h"
 #include "libs/mathlib.h"
 
+#include "libs/log.h"
+
 
 static void arilou_entrance_event (void);
 static void arilou_exit_event (void);
@@ -36,6 +40,7 @@ static void thradd_mission (void);
 static void ilwrath_mission (void);
 static void utwig_supox_mission (void);
 static void mycon_mission (void);
+static void transport_starts_event (void);
 
 
 void
@@ -45,6 +50,9 @@ AddInitialGameEvents (void) {
 	AddEvent (RELATIVE_EVENT, 0, 0, YEARS_TO_KOHRAH_VICTORY,
 			KOHR_AH_VICTORIOUS_EVENT);
 	AddEvent (RELATIVE_EVENT, 0, 0, 0, SLYLANDRO_RAMP_UP);
+	
+	// JMS: Start transport ships
+	AddEvent (ABSOLUTE_EVENT, 3, 28, START_YEAR, TRANSPORT_STARTS_EVENT);
 }
 
 void
@@ -207,7 +215,62 @@ EventHandler (BYTE selector)
 			SET_GAME_STATE (SLYLANDRO_MULTIPLIER, ramp_factor);
 			break;
 		}
+		case TRANSPORT_STARTS_EVENT:
+			transport_starts_event();
+			
+			// If transport is leaving from truespace, force it to hyperspace after 2 days.
+			AddEvent (RELATIVE_EVENT, 0, 2, 0, TRANSPORT_FROM_TRUESPACE_TO_HYPERSPACE_EVENT);
+			break;
+		case TRANSPORT_FROM_TRUESPACE_TO_HYPERSPACE_EVENT:
+			if(GET_GAME_STATE(TRANSPORT_SHIP_0_STATUS) == 1)
+				SET_GAME_STATE (TRANSPORT_SHIP_0_STATUS,2);
+			break;
+		case TRANSPORT_HAS_ARRIVED_AT_DESTINATION_EVENT:
+			if(GET_GAME_STATE(TRANSPORT_SHIP_0_STATUS) == 4)
+				SET_GAME_STATE (TRANSPORT_SHIP_0_STATUS,0);
+			break;
+		case SHOFIXTI_PATROL_RETURNS_HOME_EVENT:
+			SET_GAME_STATE (SHOFIXTI_PATROL_RETURNED, 1);
+			break;
+
+	}
+}
+
+// JMS: Transport ship starts its journey. Whee!!!
+
+
+void
+transport_starts_event(void)
+{
+	COUNT month_index, year_index, day_index;
+
+	day_index = GLOBAL (GameClock.day_index);
+	year_index = GLOBAL (GameClock.year_index);
+	
+	if(GLOBAL (GameClock).day_index % 7 == 0 && GET_GAME_STATE(TRANSPORT_SHIP_0_STATUS) == 0)
+		SET_GAME_STATE (TRANSPORT_SHIP_0_STATUS,1);
+	
+	month_index = GLOBAL (GameClock.month_index) % 12;
+
+	if (day_index == 28)
+	{
+		
+		// If december 28th, next transport starts next year.
+		if (month_index == 0)
+			++year_index;
+		
+		// Next transport starts on a date of next month.
+		++month_index;
+		
+		// Next transport starts on the 7th of the correct year and month.
+		AddEvent (ABSOLUTE_EVENT, month_index, 7, year_index, TRANSPORT_STARTS_EVENT);
+		//log_add(log_Debug, "next day 7, next month %d, next year %d, status %d", month_index, year_index, GET_GAME_STATE(TRANSPORT_SHIP_0_STATUS));
 	}
+	// Dates other than 28th are pretty straightforward: Just add 7 to the current day number.
+	else
+		AddEvent (RELATIVE_EVENT, 0, 7, 0, TRANSPORT_STARTS_EVENT);
+	
+	//log_add(log_Debug, "next day %d, next month %d, next year %d, status %d", day_index, month_index,year_index+7,GET_GAME_STATE(TRANSPORT_SHIP_0_STATUS));
 }
 
 void
diff -ruNp src.orig/uqm/gameev.h src/uqm/gameev.h
--- src.orig/uqm/gameev.h	2017-11-01 15:30:25 -0700
+++ src/uqm/gameev.h	2017-11-01 15:31:02 -0700
@@ -14,6 +14,9 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+// JMS 2010: -Added transport ship events
+//			 -Added shofixti patrol returns -event
+
 #ifndef _GAMEEV_H
 #define _GAMEEV_H
 
@@ -41,6 +44,10 @@ enum
 	YEHAT_REBEL_EVENT,
 	SLYLANDRO_RAMP_UP,
 	SLYLANDRO_RAMP_DOWN,
+	TRANSPORT_STARTS_EVENT,							// JMS
+	TRANSPORT_FROM_TRUESPACE_TO_HYPERSPACE_EVENT,	// JMS
+	TRANSPORT_HAS_ARRIVED_AT_DESTINATION_EVENT,		// JMS
+	SHOFIXTI_PATROL_RETURNS_HOME_EVENT,				// JMS
 
 	NUM_EVENTS
 };
diff -ruNp src.orig/uqm/gameopt.c src/uqm/gameopt.c
--- src.orig/uqm/gameopt.c	2017-11-01 15:30:25 -0700
+++ src/uqm/gameopt.c	2017-11-01 15:31:02 -0700
@@ -16,6 +16,10 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2009: Added case IN_ORZSPACE to showsummary so it displays "* Below *" when checking out a saved game summary
+
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
 #include "gameopt.h"
 
 #include "build.h"
@@ -41,8 +45,8 @@
 extern FRAME PlayFrame;
 
 #define MAX_SAVED_GAMES 50
-#define SUMMARY_X_OFFS 14
-#define SUMMARY_SIDE_OFFS 7
+#define SUMMARY_X_OFFS (14 << RESOLUTION_FACTOR) // JMS_GFX
+#define SUMMARY_SIDE_OFFS (7 << RESOLUTION_FACTOR) // JMS_GFX
 #define SAVES_PER_PAGE 5
 
 #define MAX_NAME_SIZE  SIS_NAME_SIZE
@@ -61,7 +65,7 @@ ConfirmSaveLoad (STAMP *MsgStamp)
 	GetContextClipRect (&clip_r);
 
 	t.baseline.x = clip_r.extent.width >> 1;
-	t.baseline.y = (clip_r.extent.height >> 1) + 3;
+	t.baseline.y = (clip_r.extent.height >> 1) + (3 << RESOLUTION_FACTOR); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.CharCount = (COUNT)~0;
 	if (MsgStamp)
@@ -71,20 +75,32 @@ ConfirmSaveLoad (STAMP *MsgStamp)
 		t.pStr = GAME_STRING (SAVEGAME_STRING_BASE + 1);
 				// "Loading . . ."
 	TextRect (&t, &r, NULL);
-	r.corner.x -= 4;
-	r.corner.y -= 4;
-	r.extent.width += 8;
-	r.extent.height += 8;
+	r.corner.x -= 4 << RESOLUTION_FACTOR; // JMS_GFX
+	r.corner.y -= 4 << RESOLUTION_FACTOR; // JMS_GFX
+	r.extent.width += 8 << RESOLUTION_FACTOR; // JMS_GFX
+	r.extent.height += 8 << RESOLUTION_FACTOR; // JMS_GFX
 	if (MsgStamp)
 	{
 		*MsgStamp = SaveContextFrame (&r);
 	}
-	DrawStarConBox (&r, 2,
+	
+	if (RESOLUTION_FACTOR == 0)
+	{
+		DrawStarConBox (&r, 2,
 			BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19),
 			BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F),
 			TRUE, BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x14, 0x14, 0x14), 0x0F));
+		SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x14, 0x14, 0x14), 0x0F));
+	}
+	else
+	{
+		DrawStarConBox (&r, 2,
+			PCMENU_TOP_LEFT_BORDER_COLOR,
+			PCMENU_BOTTOM_RIGHT_BORDER_COLOR,
+			TRUE, PCMENU_BACKGROUND_COLOR);
+		SetContextForeGroundColor (PCMENU_SELECTION_TEXT_COLOR);
+	}
+	
 	font_DrawText (&t);
 }
 
@@ -103,6 +119,8 @@ enum
 	SOUND_OFF_SETTING,
 	MUSIC_ON_SETTING,
 	MUSIC_OFF_SETTING,
+	VOICE_ON_SETTING,
+	VOICE_OFF_SETTING,
 	CYBORG_OFF_SETTING,
 	CYBORG_NORMAL_SETTING,
 	CYBORG_DOUBLE_SETTING,
@@ -129,16 +147,24 @@ FeedbackSetting (BYTE which_setting)
 			snprintf (buf, sizeof (buf) - 1, "%s %s",
 					GAME_STRING (OPTION_STRING_BASE + 0),
 					GLOBAL (glob_flags) & SOUND_DISABLED
-					? GAME_STRING (OPTION_STRING_BASE + 3) :
-					GAME_STRING (OPTION_STRING_BASE + 4));
+					? GAME_STRING (OPTION_STRING_BASE + 4) :
+					GAME_STRING (OPTION_STRING_BASE + 5));
 			break;
 		case MUSIC_ON_SETTING:
 		case MUSIC_OFF_SETTING:
 			snprintf (buf, sizeof (buf) - 1, "%s %s",
 					GAME_STRING (OPTION_STRING_BASE + 1),
 					GLOBAL (glob_flags) & MUSIC_DISABLED
-					? GAME_STRING (OPTION_STRING_BASE + 3) :
-					GAME_STRING (OPTION_STRING_BASE + 4));
+					? GAME_STRING (OPTION_STRING_BASE + 4) :
+					GAME_STRING (OPTION_STRING_BASE + 5));
+			break;
+		case VOICE_ON_SETTING:
+		case VOICE_OFF_SETTING:
+			snprintf (buf, sizeof (buf) - 1, "%s %s",
+					GAME_STRING (OPTION_STRING_BASE + 2),
+					GLOBAL (glob_flags) & VOICE_DISABLED
+					? GAME_STRING (OPTION_STRING_BASE + 4) :
+					GAME_STRING (OPTION_STRING_BASE + 5));
 			break;
 		case CYBORG_OFF_SETTING:
 		case CYBORG_NORMAL_SETTING:
@@ -155,10 +181,10 @@ FeedbackSetting (BYTE which_setting)
 			else
 				tmpstr = "";
 			snprintf (buf, sizeof (buf) - 1, "%s %s%s",
-					GAME_STRING (OPTION_STRING_BASE + 2),
+					GAME_STRING (OPTION_STRING_BASE + 3),
 					!(GLOBAL (glob_flags) & CYBORG_ENABLED)
-					? GAME_STRING (OPTION_STRING_BASE + 3) :
-					GAME_STRING (OPTION_STRING_BASE + 4),
+					? GAME_STRING (OPTION_STRING_BASE + 4) :
+					GAME_STRING (OPTION_STRING_BASE + 5),
 					tmpstr);
 			break;
 		case CHANGE_CAPTAIN_SETTING:
@@ -189,18 +215,18 @@ DrawNameString (bool nameCaptain, UNICOD
 	LockMutex (GraphicsLock);
 
 	{
-		r.corner.x = 2;
-		r.extent.width = SHIP_NAME_WIDTH;
+		r.extent.width = SHIP_NAME_WIDTH; // JMS_GFX
 		r.extent.height = SHIP_NAME_HEIGHT;
 
 		SetContext (StatusContext);
 		if (nameCaptain)
 		{	// Naming the captain
 			Font = TinyFont;
-			r.corner.y = 10;
-			++r.corner.x;
-			r.extent.width -= 2;
-			lf.baseline.x = r.corner.x + (r.extent.width >> 1) - 1;
+			r.corner.x = RES_STAT_SCALE(3); // JMS_GFX;
+			r.corner.y = RES_CASE(10,18,30); // JMS_GFX
+			r.extent.width -= RES_STAT_SCALE(2); // JMS_GFX;
+			lf.baseline.x = (STATUS_WIDTH >> 1) - RES_CASE(1,0,-1);
+			lf.baseline.y = r.corner.y + r.extent.height - RES_CASE(1,4,3);
 
 			BackGround = BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x1F), 0x09);
 			ForeGround = BUILD_COLOR (MAKE_RGB15 (0x0A, 0x1F, 0x1F), 0x0B);
@@ -208,14 +234,15 @@ DrawNameString (bool nameCaptain, UNICOD
 		else
 		{	// Naming the flagship
 			Font = StarConFont;
-			r.corner.y = 20;
+			r.corner.x = RES_CASE(2,4,7); // JMS_GFX;
+			r.corner.y = RES_CASE(20,40,62); // JMS_GFX;
 			lf.baseline.x = r.corner.x + (r.extent.width >> 1);
+			lf.baseline.y = r.corner.y + r.extent.height - RES_CASE(1,3,3); // JMS_GFX
 
 			BackGround = BUILD_COLOR (MAKE_RGB15 (0x0F, 0x00, 0x00), 0x2D);
 			ForeGround = BUILD_COLOR (MAKE_RGB15 (0x1F, 0x0A, 0x00), 0x7D);
-		}
+		}		
 
-		lf.baseline.y = r.corner.y + r.extent.height - 1;
 		lf.align = ALIGN_CENTER;
 	}
 
@@ -238,6 +265,7 @@ DrawNameString (bool nameCaptain, UNICOD
 		BYTE *pchar_deltas;
 
 		TextRect (&lf, &text_r, char_deltas);
+		
 		if ((text_r.extent.width + 2) >= r.extent.width)
 		{	// the text does not fit the input box size and so
 			// will not fit when displayed later
@@ -393,6 +421,12 @@ DoSettings (MENU_STATE *pMS)
 				pMS->CurState ^= 1;
 				DrawMenuStateStrings (PM_SOUND_ON, pMS->CurState);
 				break;
+			case VOICE_ON_SETTING:
+			case VOICE_OFF_SETTING:
+				ToggleVoice ();
+				pMS->CurState ^= 1;
+				DrawMenuStateStrings (PM_SOUND_ON, pMS->CurState);
+				break;
 			case CHANGE_CAPTAIN_SETTING:
 			case CHANGE_SHIP_SETTING:
 				NameCaptainOrShip (pMS->CurState == CHANGE_CAPTAIN_SETTING);
@@ -406,7 +440,7 @@ DoSettings (MENU_STATE *pMS)
 					GLOBAL (glob_flags) &= ~CYBORG_ENABLED;
 				}
 				GLOBAL (glob_flags) =
-						((GLOBAL (glob_flags) & ~COMBAT_SPEED_MASK)
+						(UWORD)((GLOBAL (glob_flags) & ~COMBAT_SPEED_MASK)
 						| (cur_speed << COMBAT_SPEED_SHIFT));
 				pMS->CurState = CYBORG_OFF_SETTING + cur_speed;
 				DrawMenuStateStrings (PM_SOUND_ON, pMS->CurState);
@@ -495,9 +529,9 @@ DrawSavegameCargo (SIS_STATE *sisState)
 		BUILD_COLOR (MAKE_RGB15_INIT (0x14, 0x00, 0x14), 0x05),
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x00, 0x19), 0x00),
 	};
-#define ELEMENT_ORG_Y      17
-#define ELEMENT_SPACING_Y  12
-#define ELEMENT_SPACING_X  36
+#define ELEMENT_ORG_Y      (17 << RESOLUTION_FACTOR) // JMS_GFX
+#define ELEMENT_SPACING_Y  (12 << RESOLUTION_FACTOR) // JMS_GFX
+#define ELEMENT_SPACING_X  (36 << RESOLUTION_FACTOR) // JMS_GFX
 
 	SetContext (SpaceContext);
 	BatchGraphics ();
@@ -506,11 +540,11 @@ DrawSavegameCargo (SIS_STATE *sisState)
 	// setup element icons
 	s.frame = SetAbsFrameIndex (MiscDataFrame,
 			(NUM_SCANDOT_TRANSITIONS << 1) + 3);
-	s.origin.x = 7 + SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS + 3;
+	s.origin.x = SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS + (10 << RESOLUTION_FACTOR); // JMS_GFX
 	s.origin.y = ELEMENT_ORG_Y;
 	// setup element amounts
-	t.baseline.x = 33 + SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS + 3;
-	t.baseline.y = ELEMENT_ORG_Y + 3;
+	t.baseline.x = SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS + ELEMENT_SPACING_X;
+	t.baseline.y = ELEMENT_ORG_Y + (3 << RESOLUTION_FACTOR); // JMS_GFX
 	t.align = ALIGN_RIGHT;
 	t.pStr = buf;
 
@@ -522,7 +556,7 @@ DrawSavegameCargo (SIS_STATE *sisState)
 			s.origin.x += ELEMENT_SPACING_X;
 			s.origin.y = ELEMENT_ORG_Y;
 			t.baseline.x += ELEMENT_SPACING_X;
-			t.baseline.y = ELEMENT_ORG_Y + 3;
+			t.baseline.y = ELEMENT_ORG_Y + (3 << RESOLUTION_FACTOR); // JMS_GFX
 		}
 		// draw element icon
 		DrawStamp (&s);
@@ -537,13 +571,13 @@ DrawSavegameCargo (SIS_STATE *sisState)
 	}
 
 	// draw Bio icon
-	s.origin.x = 24 + SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS;
-	s.origin.y = 68;
+	s.origin.x = (24 << RESOLUTION_FACTOR) + SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS; // JMS_GFX
+	s.origin.y = 68 << RESOLUTION_FACTOR; // JMS_GFX
 	s.frame = SetAbsFrameIndex (s.frame, 68);
 	DrawStamp (&s);
 	// print Bio amount
-	t.baseline.x = 50 + SUMMARY_X_OFFS;
-	t.baseline.y = s.origin.y + 3;
+	t.baseline.x = (50 << RESOLUTION_FACTOR) + SUMMARY_X_OFFS; // JMS_GFX
+	t.baseline.y = s.origin.y + (3 << RESOLUTION_FACTOR); // JMS_GFX
 	SetContextForeGroundColor (cargo_color[i]);
 	snprintf (buf, sizeof buf, "%u", sisState->TotalBioMass);
 	t.CharCount = (COUNT)~0;
@@ -581,7 +615,7 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 		SIS_STATE SaveSS;
 		UNICODE buf[256];
 		POINT starPt;
-
+		
 		// Save the states because we will hack them
 		SaveSS = GlobData.SIS_state;
 		player_q = GLOBAL (built_ship_q);
@@ -589,22 +623,18 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 		OldContext = SetContext (StatusContext);
 		// Hack StatusContext so we can use standard SIS display funcs
 		GetContextClipRect (&OldRect);
-		r.corner.x = SIS_ORG_X + ((SIS_SCREEN_WIDTH - STATUS_WIDTH) >> 1) +
-				SAFE_X - 16 + SUMMARY_X_OFFS;
-//		r.corner.x = SIS_ORG_X + ((SIS_SCREEN_WIDTH - STATUS_WIDTH) >> 1);
-		r.corner.y = SIS_ORG_Y;
+		r.corner.x = SIS_ORG_X + ((SIS_SCREEN_WIDTH - STATUS_WIDTH) >> 1) + SAFE_X - (16 << RESOLUTION_FACTOR) + SUMMARY_X_OFFS; // JMS_GFX
+		r.corner.y = SIS_ORG_Y + RESOLUTION_FACTOR; // JMS_GFX
 		r.extent.width = STATUS_WIDTH;
 		r.extent.height = STATUS_HEIGHT;
 		SetContextClipRect (&r);
 
 		// Hack the states so that we can use standard SIS display funcs
 		GlobData.SIS_state = pSD->SS;
-		InitQueue (&GLOBAL (built_ship_q),
-				MAX_BUILT_SHIPS, sizeof (SHIP_FRAGMENT));
+		InitQueue (&GLOBAL (built_ship_q), MAX_BUILT_SHIPS, sizeof (SHIP_FRAGMENT));
 		for (i = 0; i < pSD->NumShips; ++i)
 			CloneShipFragment (pSD->ShipList[i], &GLOBAL (built_ship_q), 0);
-		DateToString (buf, sizeof buf,
-				pSD->month_index, pSD->day_index, pSD->year_index),
+		DateToString (buf, sizeof buf, pSD->month_index, pSD->day_index, pSD->year_index),
 		ClearSISRect (DRAW_SIS_DISPLAY);
 		DrawStatusMessage (buf);
 		UninitQueue (&GLOBAL (built_ship_q));
@@ -613,12 +643,13 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 		
 		SetContext (SpaceContext);
 		// draw devices
-		s.origin.y = 13;
+		s.origin.y = 13 << RESOLUTION_FACTOR; // JMS_GFX
 		for (i = 0; i < 4; ++i)
 		{
 			COUNT j;
 
-			s.origin.x = 140 + SUMMARY_X_OFFS + SUMMARY_SIDE_OFFS;
+			s.origin.x = (140 << RESOLUTION_FACTOR) + SUMMARY_X_OFFS + SUMMARY_SIDE_OFFS + RES_CASE(0,10,110); // JMS_GFX
+			
 			for (j = 0; j < 4; ++j)
 			{
 				COUNT devIndex = (i * 4) + j;
@@ -628,20 +659,22 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 							+ pSD->DeviceList[devIndex]);
 					DrawStamp (&s);
 				}
-				s.origin.x += 18;
+				s.origin.x += 18 << RESOLUTION_FACTOR; // JMS_GFX
 			}
-			s.origin.y += 18;
+			s.origin.y += 18 << RESOLUTION_FACTOR; // JMS_GFX
 		}
 
+		// Placement of the RU and bio-credit amounts.
 		SetContextFont (StarConFont);
-		t.baseline.x = 173 + SUMMARY_X_OFFS + SUMMARY_SIDE_OFFS;
+		t.baseline.x = (173 << RESOLUTION_FACTOR) + SUMMARY_X_OFFS + SUMMARY_SIDE_OFFS + RES_CASE(0,15,110); // JMS_GFX
+		
 		t.align = ALIGN_CENTER;
 		t.CharCount = (COUNT)~0;
 		t.pStr = buf;
 		if (pSD->Flags & AFTER_BOMB_INSTALLED)
 		{
 			// draw the bomb and the escape pod
-			s.origin.x = SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS + 6;
+			s.origin.x = SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS + (6 << RESOLUTION_FACTOR); // JMS_GFX
 			s.origin.y = 0;
 			s.frame = SetRelFrameIndex (pickState->SummaryFrame, 0);
 			DrawStamp (&s);
@@ -654,11 +687,12 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 		{
 			DrawSavegameCargo (&pSD->SS);
 
+			// RU amount.
 			SetContext (RadarContext);
 			// Hack RadarContext so we can use standard Lander display funcs
 			GetContextClipRect (&OldRect);
-			r.corner.x = SIS_ORG_X + 10 + SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS;
-			r.corner.y = SIS_ORG_Y + 84;
+			r.corner.x = SIS_ORG_X + RES_CASE(10,20,70) + SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS; // JMS_GFX
+			r.corner.y = SIS_ORG_Y + (84 << RESOLUTION_FACTOR); // JMS_GFX
 			r.extent = OldRect.extent;
 			SetContextClipRect (&r);
 			UnlockMutex (GraphicsLock);
@@ -667,28 +701,30 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 			LockMutex (GraphicsLock);
 			SetContextClipRect (&OldRect);
 			SetContext (SpaceContext);
-
 			snprintf (buf, sizeof buf, "%u", pSD->SS.ResUnits);
-			t.baseline.y = 102;
-			SetContextForeGroundColor (
-					BUILD_COLOR (MAKE_RGB15 (0x10, 0x00, 0x10), 0x01));
+			t.baseline.y = 102 << RESOLUTION_FACTOR; // JMS_GFX
+			SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x10, 0x00, 0x10), 0x01));
 			font_DrawText (&t);
 			t.CharCount = (COUNT)~0;
 		}
-		t.baseline.y = 126;
+		
+		// Bio credit amount.
+		t.baseline.y = 126 << RESOLUTION_FACTOR; // JMS_GFX
 		snprintf (buf, sizeof buf, "%u",
 				MAKE_WORD (pSD->MCreditLo, pSD->MCreditHi));
-		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x10, 0x00, 0x10), 0x01));
+		SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x10, 0x00, 0x10), 0x01));
 		font_DrawText (&t);
 		
 		// print the location
-		t.baseline.x = 6;
-		t.baseline.y = 139 + 6;
+		t.baseline.x = 6 << RESOLUTION_FACTOR; // JMS_GFX
+		t.baseline.y = (139 + 6) << RESOLUTION_FACTOR; // JMS_GFX;
 		t.align = ALIGN_LEFT;
 		t.pStr = buf;
+		
+		// Reading the hyperspace coordinates to RECT r.
 		starPt.x = LOGX_TO_UNIVERSE (pSD->SS.log_x);
 		starPt.y = LOGY_TO_UNIVERSE (pSD->SS.log_y);
+
 		switch (pSD->Activity)
 		{
 			case IN_LAST_BATTLE:
@@ -721,16 +757,19 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 				utf8StringCopy (buf, sizeof (buf),
 						GAME_STRING (NAVIGATION_STRING_BASE + 1));
 				break;
+			case IN_ORZSPACE:	// JMS: This displays " * Below * " instead of "hyper/quasispace" when savegame is in Orz space
+				utf8StringCopy (buf, sizeof (buf),
+								GAME_STRING (NAVIGATION_STRING_BASE + 6));
+				break;
 		}
 
+		// Printing the planet name or hyperspace coordinates.
 		SetContextFont (TinyFont);
-		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x1B, 0x00, 0x1B), 0x33));
+		SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x1B, 0x00, 0x1B), 0x33));
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
 		t.align = ALIGN_CENTER;
-		t.baseline.x = SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH - 4
-				+ (SIS_TITLE_WIDTH >> 1);
+		t.baseline.x = SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH - (4 << RESOLUTION_FACTOR) + (SIS_TITLE_WIDTH >> 1); // JMS_GFX
 		switch (pSD->Activity)
 		{
 			case IN_STARBASE:
@@ -777,10 +816,10 @@ DrawGameSelection (PICK_GAME_STATE *pick
 	SetContextFont (TinyFont);
 	
 	// Erase the selection menu
-	r.extent.width = 240;
-	r.extent.height = 65;
-	r.corner.x = 1;
-	r.corner.y = 160;
+	r.extent.width = 240 << RESOLUTION_FACTOR; // JMS_GFX
+	r.extent.height = 65 << RESOLUTION_FACTOR; // JMS_GFX
+	r.corner.x = 1 << RESOLUTION_FACTOR; // JMS_GFX
+	r.corner.y = 160 << RESOLUTION_FACTOR; // JMS_GFX
 	SetContextForeGroundColor (BLACK_COLOR);
 	DrawFilledRectangle (&r);
 
@@ -798,25 +837,25 @@ DrawGameSelection (PICK_GAME_STATE *pick
 		SetContextForeGroundColor ((curSlot == selSlot) ?
 				(BUILD_COLOR (MAKE_RGB15 (0x1B, 0x00, 0x1B), 0x33)):
 				(BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01)));
-		r.extent.width = 15;
+		r.extent.width = 15 << RESOLUTION_FACTOR; // JMS_GFX
 		if (MAX_SAVED_GAMES > 99)
-			r.extent.width += 5;
-		r.extent.height = 11;
-		r.corner.x = 8;
-		r.corner.y = 160 + (i * 13);
+			r.extent.width += 5 << RESOLUTION_FACTOR; // JMS_GFX
+		r.extent.height = 11 << RESOLUTION_FACTOR; // JMS_GFX
+		r.corner.x = 8 << RESOLUTION_FACTOR; // JMS_GFX
+		r.corner.y = (160 + (i * 13)) << RESOLUTION_FACTOR; // JMS_GFX
 		DrawRectangle (&r);
 
-		t.baseline.x = r.corner.x + 3;
-		t.baseline.y = r.corner.y + 8;
+		t.baseline.x = r.corner.x + (3 << RESOLUTION_FACTOR); // JMS_GFX
+		t.baseline.y = r.corner.y + (8 << RESOLUTION_FACTOR); // JMS_GFX
 		snprintf (buf, sizeof buf, (MAX_SAVED_GAMES > 99) ? "%03u" : "%02u",
 				curSlot);
 		font_DrawText (&t);
 
-		r.extent.width = 204 - SAFE_X;
-		r.corner.x = 30 + SAFE_X;
+		r.extent.width = (204 - SAFE_X) << RESOLUTION_FACTOR; // JMS_GFX
+		r.corner.x = (30 + SAFE_X) << RESOLUTION_FACTOR; // JMS_GFX
 		DrawRectangle (&r);
 
-		t.baseline.x = r.corner.x + 3;
+		t.baseline.x = r.corner.x + (3 << RESOLUTION_FACTOR); // JMS_GFX
 		if (desc->year_index == 0)
 		{
 			utf8StringCopy (buf, sizeof buf,
diff -ruNp src.orig/uqm/gamestate.inc src/uqm/gamestate.inc
--- src.orig/uqm/gamestate.inc	1969-12-31 16:00:00 -0800
+++ src/uqm/gamestate.inc	2017-11-01 15:31:02 -0700
@@ -0,0 +1,903 @@
+
+/*
+ * PLAYER VISITED BETA NAOS? DN 27FEB11
+ */
+ADD_GAME_STATE (PLAYER_VISITED_BETA_NAOS, 1)
+ 
+/* Melnorme Easter Egg stuff DN 04JAN11 */
+
+/*
+ * 0 - not collected
+ * 1 - collected but not sold to Melnorme
+ * 2 - collected AND sold to Melnorme
+ *
+ * DN 04JAN11
+ */
+ADD_GAME_STATE (MELNORME_ECHINOSOL_TYPE_FOUND, 2)
+ADD_GAME_STATE (MELNORME_FLORA_FLATULENSIS_TYPE_FOUND, 2)
+ADD_GAME_STATE (MELNORME_HOPPING_HATCHLING_TYPE_FOUND, 2)
+ADD_GAME_STATE (MELNORME_DIZZY_FNARBLE_TYPE_FOUND, 2)
+ADD_GAME_STATE (MELNORME_FLAGELLUM_PEST_TYPE_FOUND, 2)
+ADD_GAME_STATE (MELNORME_FLYING_OHAIRY_TYPE_FOUND, 2)
+ADD_GAME_STATE (MELNORME_BOBBING_WHIBBIT_TYPE_FOUND, 2)
+ADD_GAME_STATE (MELNORME_MUDDY_MORPHLEGM_TYPE_FOUND, 2)
+ADD_GAME_STATE (MELNORME_ULTRAMOEBA_TYPE_FOUND, 2)
+ADD_GAME_STATE (MELNORME_ELECTROPTERA_TYPE_FOUND, 2)
+ADD_GAME_STATE (MELNORME_QUARTZERBACK_TYPE_FOUND, 2)
+ADD_GAME_STATE (MELNORME_TUBERUS_HUMUNGUS_TYPE_FOUND, 2)
+ADD_GAME_STATE (MELNORME_VENUS_FRYTRAP_TYPE_FOUND, 2)
+ADD_GAME_STATE (MELNORME_WATCHFUL_WILLOW_TYPE_FOUND, 2)
+ADD_GAME_STATE (MELNORME_XEROPHYTIC_AUTOVORE_TYPE_FOUND, 2)
+ADD_GAME_STATE (MELNORME_MIGRATOR_BLIMP_TYPE_FOUND, 2)
+ADD_GAME_STATE (MELNORME_TENTACLE_DUJOUR_TYPE_FOUND, 2)
+ADD_GAME_STATE (MELNORME_VANISHING_VERMIN_TYPE_FOUND, 2)
+ADD_GAME_STATE (MELNORME_TRIPAZOID_TUMBLER_TYPE_FOUND, 2)
+ADD_GAME_STATE (MELNORME_DUMPY_DWEEJUS_TYPE_FOUND, 2)
+ADD_GAME_STATE (MELNORME_RADIAL_ARACHNID_TYPE_FOUND, 2)
+ADD_GAME_STATE (MELNORME_WACKODEMON_TYPE_FOUND, 2)
+ADD_GAME_STATE (MELNORME_CRABBY_OCTOPUS_TYPE_FOUND, 2)
+ADD_GAME_STATE (MELNORME_BLINKING_BEHOLDER_TYPE_FOUND, 2)
+ADD_GAME_STATE (MELNORME_CREEPING_HEAD_TYPE_FOUND, 2)
+
+/* 
+ * Melnorme all life form types found flag
+ * 0 = false
+ * 1 = true
+ * 2 = true and already accounted for
+ * DN 27DEC10
+ */
+ADD_GAME_STATE (MELNORME_ALL_LIFE_TYPE_FOUND, 2)	
+
+
+
+/* Shofixti states */
+ADD_GAME_STATE (SHOFIXTI_VISITS, 3)
+ADD_GAME_STATE (SHOFIXTI_STACK1, 2)
+ADD_GAME_STATE (SHOFIXTI_STACK2, 3)
+ADD_GAME_STATE (SHOFIXTI_STACK3, 2)
+ADD_GAME_STATE (SHOFIXTI_KIA, 1)
+ADD_GAME_STATE (SHOFIXTI_BRO_KIA, 1)
+ADD_GAME_STATE (SHOFIXTI_RECRUITED, 1)
+ADD_GAME_STATE (SHOFIXTI_RELIGIOUS_MET, 1)
+ADD_GAME_STATE (SHOFIXTI_TECH_MET, 1)
+ADD_GAME_STATE (SHOFIXTI_MET, 1)
+ADD_GAME_STATE (SHOFIXTI_RELIGIOUS_GROUP, 1) // JMS: Is the current Shofixti group talking to us religious or not.
+ADD_GAME_STATE (SHOFIXTI_ANGRY, 2) // JMS: How angry the shofixti are.
+                                                   // 0: Friendly, 1: Pissed, but peaceful, 2: Attack, but can be calmed, 3: All is lost.
+ADD_GAME_STATE (SHOFIXTI_MAIDENS, 1) /* Did you find the babes yet? */
+ADD_GAME_STATE (MAIDENS_ON_SHIP, 1)
+
+ADD_GAME_STATE (BATTLE_SEGUE, 1)
+/* Set to 0 in init_xxx_comm() if communications directly
+ * follows an encounter.
+ * Set to 1 in init_xxx_comm() if the player gets to decide
+ * whether to attack or talk.
+ * Set to 1 in communication when battle follows the
+ * communication. It is still valid when uninit_xxx_comm() gets
+ * called after combat or communication.
+ */
+ADD_GAME_STATE (PLANETARY_LANDING, 1)
+ADD_GAME_STATE (PLANETARY_CHANGE, 1)
+/* Flag set to 1 when the planet information for the current
+ * world is changed since it was last saved to the starinfo.dat
+ * file. Set when picking up bio, mineral, or energy nodes.
+ * When there's no current world, it should be 0.
+ */
+
+/* Spathi states */
+ADD_GAME_STATE (SPATHI_VISITS, 3)
+ADD_GAME_STATE (SPATHI_HOME_VISITS, 3)
+ADD_GAME_STATE (FOUND_PLUTO_SPATHI, 2)
+/* 0 - Haven't met Fwiffo.
+ * 1 - Met Fwiffo on Pluto, now talking to him.
+ * 2 - Met Fwiffo on Pluto, after dialog.
+ * 3 - Met Fwiffo, and have reported to the Safe Ones on
+ *     the Spathi moon that he was either killed, or that
+ *     you have him on board.
+ */
+ADD_GAME_STATE (SPATHI_SHIELDED_SELVES, 1)
+ADD_GAME_STATE (SPATHI_CREATURES_EXAMINED, 1)
+ADD_GAME_STATE (SPATHI_CREATURES_ELIMINATED, 1)
+ADD_GAME_STATE (UMGAH_BROADCASTERS, 1)
+ADD_GAME_STATE (SPATHI_MANNER, 2)
+ADD_GAME_STATE (SPATHI_QUEST, 1)
+ADD_GAME_STATE (LIED_ABOUT_CREATURES, 2)
+ADD_GAME_STATE (SPATHI_PARTY, 1)
+ADD_GAME_STATE (KNOW_SPATHI_PASSWORD, 1)
+ADD_GAME_STATE (SPATHIHOME_MET, 1)
+
+ADD_GAME_STATE (ILWRATH_HOME_VISITS, 3)
+ADD_GAME_STATE (ILWRATH_CHMMR_VISITS, 1)
+
+ADD_GAME_STATE (ARILOU_SPACE, 1)
+/* 0 if the periodically opening QuasiSpace portal is
+ * closed or closing.
+ * 1 if the periodically opening QuasiSpace portal is
+ * open or opening.
+ */
+ADD_GAME_STATE (ARILOU_SPACE_SIDE, 2)
+/* 0 if in HyperSpace and not just emerged from the periodically
+ * opening QuasiSpace portal.
+ * 1 if in HyperSpace and just emerged from the periodically
+ * QuasiSpace portal (still on the portal).
+ * 2 if in QuasiSpace and just emerged from the periodically
+ * opening portal (still on the portal).
+ * 3 if in QuasiSpace and not just emerged from the
+ * periodically opening portal.
+ */
+ADD_GAME_STATE (ARILOU_SPACE_COUNTER, 4)
+/* Keeps track of how far the periodically opening QuasiSpace
+ * portal is open. (This determines the image)
+ * 0 <= ARILOU_SPACE_COUNTER <= 9
+ * 0 means totally closed.
+ * 9 means completely open.
+ */
+
+ADD_GAME_STATE (LANDER_SHIELDS, 4)
+
+ADD_GAME_STATE (LURG_GRPOFFS0, 8)
+
+ADD_GAME_STATE (SHOFIXTI_GRPOFFS0, 8)
+ADD_GAME_STATE (SHOFIXTI_GRPOFFS1, 8)
+ADD_GAME_STATE (SHOFIXTI_GRPOFFS2, 8)
+ADD_GAME_STATE (SHOFIXTI_GRPOFFS3, 8)
+
+ADD_GAME_STATE (ZOQFOT_GRPOFFS0, 8)
+ADD_GAME_STATE (ZOQFOT_GRPOFFS1, 8)
+ADD_GAME_STATE (ZOQFOT_GRPOFFS2, 8)
+ADD_GAME_STATE (ZOQFOT_GRPOFFS3, 8)
+
+ADD_GAME_STATE (MELNORME0_GRPOFFS0, 8)
+ADD_GAME_STATE (MELNORME0_GRPOFFS1, 8)
+ADD_GAME_STATE (MELNORME0_GRPOFFS2, 8)
+ADD_GAME_STATE (MELNORME0_GRPOFFS3, 8)
+
+ADD_GAME_STATE (MELNORME1_GRPOFFS0, 8)
+ADD_GAME_STATE (MELNORME1_GRPOFFS1, 8)
+ADD_GAME_STATE (MELNORME1_GRPOFFS2, 8)
+ADD_GAME_STATE (MELNORME1_GRPOFFS3, 8)
+
+ADD_GAME_STATE (MELNORME2_GRPOFFS0, 8)
+ADD_GAME_STATE (MELNORME2_GRPOFFS1, 8)
+ADD_GAME_STATE (MELNORME2_GRPOFFS2, 8)
+ADD_GAME_STATE (MELNORME2_GRPOFFS3, 8)
+
+ADD_GAME_STATE (MELNORME3_GRPOFFS0, 8)
+ADD_GAME_STATE (MELNORME3_GRPOFFS1, 8)
+ADD_GAME_STATE (MELNORME3_GRPOFFS2, 8)
+ADD_GAME_STATE (MELNORME3_GRPOFFS3, 8)
+
+ADD_GAME_STATE (MELNORME4_GRPOFFS0, 8)
+ADD_GAME_STATE (MELNORME4_GRPOFFS1, 8)
+ADD_GAME_STATE (MELNORME4_GRPOFFS2, 8)
+ADD_GAME_STATE (MELNORME4_GRPOFFS3, 8)
+
+ADD_GAME_STATE (MELNORME5_GRPOFFS0, 8)
+ADD_GAME_STATE (MELNORME5_GRPOFFS1, 8)
+ADD_GAME_STATE (MELNORME5_GRPOFFS2, 8)
+ADD_GAME_STATE (MELNORME5_GRPOFFS3, 8)
+
+ADD_GAME_STATE (MELNORME6_GRPOFFS0, 8)
+ADD_GAME_STATE (MELNORME6_GRPOFFS1, 8)
+ADD_GAME_STATE (MELNORME6_GRPOFFS2, 8)
+ADD_GAME_STATE (MELNORME6_GRPOFFS3, 8)
+
+ADD_GAME_STATE (MELNORME7_GRPOFFS0, 8)
+ADD_GAME_STATE (MELNORME7_GRPOFFS1, 8)
+ADD_GAME_STATE (MELNORME7_GRPOFFS2, 8)
+ADD_GAME_STATE (MELNORME7_GRPOFFS3, 8)
+
+ADD_GAME_STATE (MELNORME8_GRPOFFS0, 8)
+ADD_GAME_STATE (MELNORME8_GRPOFFS1, 8)
+ADD_GAME_STATE (MELNORME8_GRPOFFS2, 8)
+ADD_GAME_STATE (MELNORME8_GRPOFFS3, 8)
+
+ADD_GAME_STATE (MET_MELNORME, 1)  //TODO rename MELNORME_MET
+ADD_GAME_STATE (MELNORME_RESCUE_REFUSED, 1)
+ADD_GAME_STATE (MELNORME_RESCUE_COUNT, 3)
+ADD_GAME_STATE (TRADED_WITH_MELNORME, 1)
+ADD_GAME_STATE (WHY_MELNORME_PURPLE, 1)
+ADD_GAME_STATE (MELNORME_CREDIT0, 8)
+ADD_GAME_STATE (MELNORME_CREDIT1, 8)
+ADD_GAME_STATE (MELNORME_BUSINESS_COUNT, 2)
+ADD_GAME_STATE (MELNORME_YACK_STACK0, 2)
+ADD_GAME_STATE (MELNORME_YACK_STACK1, 2)
+ADD_GAME_STATE (MELNORME_YACK_STACK2, 4)
+ADD_GAME_STATE (MELNORME_YACK_STACK3, 3)
+ADD_GAME_STATE (MELNORME_YACK_STACK4, 2)
+ADD_GAME_STATE (WHY_MELNORME_BLUE, 1)
+ADD_GAME_STATE (MELNORME_ANGER, 2)
+ADD_GAME_STATE (MELNORME_MIFFED_COUNT, 2)
+ADD_GAME_STATE (MELNORME_PISSED_COUNT, 2)
+ADD_GAME_STATE (MELNORME_HATE_COUNT, 2)
+
+ADD_GAME_STATE (URQUAN_PROBE_GRPOFFS0, 8)
+ADD_GAME_STATE (URQUAN_PROBE_GRPOFFS1, 8)
+ADD_GAME_STATE (URQUAN_PROBE_GRPOFFS2, 8)
+ADD_GAME_STATE (URQUAN_PROBE_GRPOFFS3, 8)
+ADD_GAME_STATE (PROBE_MESSAGE_DELIVERED, 1)
+ADD_GAME_STATE (PROBE_ILWRATH_ENCOUNTER, 1)
+
+ADD_GAME_STATE (STARBASE_AVAILABLE, 1)
+ADD_GAME_STATE (STARBASE_VISITED, 1)
+ADD_GAME_STATE (RADIOACTIVES_PROVIDED, 1)
+ADD_GAME_STATE (LANDERS_LOST, 1)
+ADD_GAME_STATE (GIVEN_FUEL_BEFORE, 1)
+
+ADD_GAME_STATE (AWARE_OF_SAMATRA, 1)
+ADD_GAME_STATE (YEHAT_CAVALRY_ARRIVED, 1)
+ADD_GAME_STATE (URQUAN_MESSED_UP, 1)
+
+ADD_GAME_STATE (MOONBASE_DESTROYED, 1)
+ADD_GAME_STATE (WILL_DESTROY_BASE, 1)
+
+ADD_GAME_STATE (ARTIFACT_2_ON_SHIP, 1)
+ADD_GAME_STATE (ARTIFACT_3_ON_SHIP, 1)
+
+ADD_GAME_STATE (KOHR_AH_KILLED_ALL, 1)
+
+ADD_GAME_STATE (STARBASE_YACK_STACK1, 1)
+
+ADD_GAME_STATE (DISCUSSED_PORTAL_SPAWNER, 1)
+ADD_GAME_STATE (DISCUSSED_TALKING_PET, 1)
+ADD_GAME_STATE (DISCUSSED_UTWIG_BOMB, 1)
+ADD_GAME_STATE (DISCUSSED_SUN_EFFICIENCY, 1)
+ADD_GAME_STATE (DISCUSSED_ROSY_SPHERE, 1)
+ADD_GAME_STATE (DISCUSSED_AQUA_HELIX, 1)
+ADD_GAME_STATE (DISCUSSED_CLEAR_SPINDLE, 1)
+ADD_GAME_STATE (DISCUSSED_ULTRON, 1)
+ADD_GAME_STATE (DISCUSSED_MAIDENS, 1)
+ADD_GAME_STATE (DISCUSSED_UMGAH_HYPERWAVE, 1)
+ADD_GAME_STATE (DISCUSSED_BURVIX_HYPERWAVE, 1)
+ADD_GAME_STATE (SYREEN_WANT_PROOF, 1)
+ADD_GAME_STATE (PLAYER_HAVING_SEX, 1)
+ADD_GAME_STATE (MET_ARILOU, 1)
+ADD_GAME_STATE (DISCUSSED_TAALO_PROTECTOR, 1)
+ADD_GAME_STATE (DISCUSSED_EGG_CASING0, 1)
+ADD_GAME_STATE (DISCUSSED_EGG_CASING1, 1)
+ADD_GAME_STATE (DISCUSSED_EGG_CASING2, 1)
+ADD_GAME_STATE (DISCUSSED_SYREEN_SHUTTLE, 1)
+ADD_GAME_STATE (DISCUSSED_VUX_BEAST, 1)
+ADD_GAME_STATE (DISCUSSED_DESTRUCT_CODE, 1)
+ADD_GAME_STATE (DISCUSSED_URQUAN_WARP, 1)
+ADD_GAME_STATE (DISCUSSED_ARTIFACT_2, 1)
+ADD_GAME_STATE (DISCUSSED_ARTIFACT_3, 1)
+
+ADD_GAME_STATE (ATTACKED_DRUUGE, 1)
+
+ADD_GAME_STATE (NEW_ALLIANCE_NAME, 2)
+
+ADD_GAME_STATE (PORTAL_COUNTER, 4)
+/* Set to 1 when the player opens a QuasiSpace portal.
+ * It will then be increased to 10, at which time
+ * the portal is completely open. (This determines the image).
+ */
+
+ADD_GAME_STATE (BURVIXESE_BROADCASTERS, 1)
+ADD_GAME_STATE (BURV_BROADCASTERS_ON_SHIP, 1)
+
+ADD_GAME_STATE (UTWIG_BOMB, 1)
+ADD_GAME_STATE (UTWIG_BOMB_ON_SHIP, 1)
+
+ADD_GAME_STATE (AQUA_HELIX, 1)
+ADD_GAME_STATE (AQUA_HELIX_ON_SHIP, 1)
+
+ADD_GAME_STATE (SUN_DEVICE, 1)
+ADD_GAME_STATE (SUN_DEVICE_ON_SHIP, 1)
+
+ADD_GAME_STATE (TAALO_PROTECTOR, 1)
+ADD_GAME_STATE (TAALO_PROTECTOR_ON_SHIP, 1)
+
+ADD_GAME_STATE (SHIP_VAULT_UNLOCKED, 1)
+ADD_GAME_STATE (SYREEN_SHUTTLE, 1)
+
+ADD_GAME_STATE (PORTAL_KEY, 1)
+ADD_GAME_STATE (PORTAL_KEY_ON_SHIP, 1)
+
+ADD_GAME_STATE (VUX_BEAST, 1)
+ADD_GAME_STATE (VUX_BEAST_ON_SHIP, 1)
+
+ADD_GAME_STATE (TALKING_PET, 1)
+ADD_GAME_STATE (TALKING_PET_ON_SHIP, 1)
+
+ADD_GAME_STATE (MOONBASE_ON_SHIP, 1)
+
+ADD_GAME_STATE (KOHR_AH_FRENZY, 1)
+ADD_GAME_STATE (KOHR_AH_VISITS, 2)
+ADD_GAME_STATE (KOHR_AH_BYES, 1)
+
+ADD_GAME_STATE (SLYLANDRO_HOME_VISITS, 3)
+ADD_GAME_STATE (DESTRUCT_CODE_ON_SHIP, 1)
+
+ADD_GAME_STATE (ILWRATH_VISITS, 3)
+ADD_GAME_STATE (ILWRATH_DECEIVED, 1)
+ADD_GAME_STATE (FLAGSHIP_CLOAKED, 1)
+
+ADD_GAME_STATE (MYCON_VISITS, 3)
+ADD_GAME_STATE (MYCON_HOME_VISITS, 3)
+ADD_GAME_STATE (MYCON_AMBUSH, 1)
+ADD_GAME_STATE (MYCON_FELL_FOR_AMBUSH, 1)
+/* Set to 1 when the Mycon have been told about Organon
+ * and are moving towards it.
+ */
+
+ADD_GAME_STATE (GLOBAL_FLAGS_AND_DATA, 8)
+/* This state seems to be used to distinguish between different
+ * places where one may have an conversation with an alien.
+ * Like home world, other world, space.
+ * Why this needs 8 bits I don't know. Only specific
+ * combinations of bits seem to be used (0, 1, or all bits).
+ * A closer investigation is desirable. - SvdB
+ * Bit 4 is set when initiating communication with the Ilwrath
+ * 		homeworld by means of a HyperWave Broadcaster.
+ * Bit 5 is set when initiating communication with an Ilwrath
+ * 		ship by means of a HyperWave Broadcaster.
+ * All bits are cleared when communication is over.
+ */
+
+ADD_GAME_STATE (ORZ_VISITS, 3)
+ADD_GAME_STATE (TAALO_VISITS, 3)
+ADD_GAME_STATE (ORZ_MANNER, 2)
+ADD_GAME_STATE (ORZ_MET, 1)
+
+ADD_GAME_STATE (PROBE_EXHIBITED_BUG, 1)
+ADD_GAME_STATE (CLEAR_SPINDLE_ON_SHIP, 1)
+
+ADD_GAME_STATE (URQUAN_VISITS, 3)
+ADD_GAME_STATE (PLAYER_HYPNOTIZED, 1)
+
+ADD_GAME_STATE (VUX_VISITS, 3)
+ADD_GAME_STATE (VUX_HOME_VISITS, 3)
+ADD_GAME_STATE (ZEX_VISITS, 3)
+ADD_GAME_STATE (ZEX_IS_DEAD, 1)
+ADD_GAME_STATE (KNOW_ZEX_WANTS_MONSTER, 1)
+
+ADD_GAME_STATE (UTWIG_VISITS, 3)
+ADD_GAME_STATE (UTWIG_HOME_VISITS, 3)
+ADD_GAME_STATE (BOMB_VISITS, 3)
+ADD_GAME_STATE (ULTRON_CONDITION, 3)
+/* 0 if the Supox still have the Ultron
+ * 1 if the Captain has the Ultron, completely broken
+ * 2 if the Captain has the Ultron, with 1 fix
+ * 3 if the Captain has the Ultron, with 2 fixes
+ * 4 if the Captain has the Ultron, completely restored
+ * 5 if the Ultron has been returned to the Utwig
+ */
+ADD_GAME_STATE (UTWIG_HAVE_ULTRON, 1)
+ADD_GAME_STATE (BOMB_UNPROTECTED, 1)
+
+ADD_GAME_STATE (TAALO_UNPROTECTED, 1)
+
+ADD_GAME_STATE (TALKING_PET_VISITS, 3)
+ADD_GAME_STATE (TALKING_PET_HOME_VISITS, 3)
+ADD_GAME_STATE (UMGAH_ZOMBIE_BLOBBIES, 1)
+/* The Umgah have come under the influence of the Talking Pet */
+ADD_GAME_STATE (KNOW_UMGAH_ZOMBIES, 1)
+/* The Captain is aware that something is up with the Umgah */
+
+ADD_GAME_STATE (ARILOU_VISITS, 3)
+ADD_GAME_STATE (ARILOU_HOME_VISITS, 3)
+ADD_GAME_STATE (KNOW_ARILOU_WANT_WRECK, 1)
+ADD_GAME_STATE (ARILOU_CHECKED_UMGAH, 2)
+ADD_GAME_STATE (PORTAL_SPAWNER, 1)
+ADD_GAME_STATE (PORTAL_SPAWNER_ON_SHIP, 1)
+
+ADD_GAME_STATE (UMGAH_VISITS, 3)
+ADD_GAME_STATE (UMGAH_HOME_VISITS, 3)
+ADD_GAME_STATE (MET_NORMAL_UMGAH, 1)
+
+ADD_GAME_STATE (SYREEN_HOME_VISITS, 3)
+ADD_GAME_STATE (SYREEN_SHUTTLE_ON_SHIP, 1)
+ADD_GAME_STATE (KNOW_SYREEN_VAULT, 1)
+
+ADD_GAME_STATE (EGG_CASE0_ON_SHIP, 1)
+ADD_GAME_STATE (SUN_DEVICE_UNGUARDED, 1)
+
+ADD_GAME_STATE (ROSY_SPHERE_ON_SHIP, 1)
+/* The Rosy Sphere is aboard the flagship, i.e. It has been
+ * acquired from the Druuge, but not yet inserted in the broken
+ * Ultron. cf. ROSY_SPHERE */
+
+ADD_GAME_STATE (CHMMR_HOME_VISITS, 3)
+ADD_GAME_STATE (CHMMR_EMERGING, 1)
+ADD_GAME_STATE (CHMMR_UNLEASHED, 1)
+ADD_GAME_STATE (CHMMR_BOMB_STATE, 2)
+ADD_GAME_STATE (CHMMR_MET, 2)
+
+/* 0 - Nothing is known about the Precursor Bomb.
+ * 1 - The captain knows from the Chmmr that some extremely
+ *     powerful weapon is needed to destroy the Sa-Matra.
+ * 2 - Installation of the precursor bomb has started.
+ * 3 - Left the starbase after installation of the Precursor bomb.
+ */
+
+ADD_GAME_STATE (DRUUGE_DISCLAIMER, 1)
+
+ADD_GAME_STATE (YEHAT_VISITS, 3)
+ADD_GAME_STATE (YEHAT_REBEL_VISITS, 3)
+ADD_GAME_STATE (YEHAT_HOME_VISITS, 3)
+ADD_GAME_STATE (YEHAT_CIVIL_WAR, 1)
+ADD_GAME_STATE (YEHAT_ABSORBED_PKUNK, 1)
+ADD_GAME_STATE (YEHAT_SHIP_MONTH, 4)
+ADD_GAME_STATE (YEHAT_SHIP_DAY, 5)
+ADD_GAME_STATE (YEHAT_SHIP_YEAR, 5)
+ADD_GAME_STATE (YEHAT_MET, 2)
+
+ADD_GAME_STATE (CLEAR_SPINDLE, 1)
+ADD_GAME_STATE (PKUNK_VISITS, 3)
+ADD_GAME_STATE (PKUNK_HOME_VISITS, 3)
+ADD_GAME_STATE (PKUNK_SHIP_MONTH, 4)
+/* The month in PKUNK_SHIP_YEAR that new ships are available
+ * from the Pkunk. */
+ADD_GAME_STATE (PKUNK_SHIP_DAY, 5)
+/* The day of the month in PKUNK_SHIP_MONTH in PKUNK_SHIP_YEAR
+ * that new ships are available. */
+ADD_GAME_STATE (PKUNK_SHIP_YEAR, 5)
+/* The year that new ships are available from the Pkunk
+ * (stored as an offset from the year the game starts). */
+ADD_GAME_STATE (PKUNK_MISSION, 3)
+
+ADD_GAME_STATE (SUPOX_VISITS, 3)
+ADD_GAME_STATE (SUPOX_HOME_VISITS, 3)
+
+ADD_GAME_STATE (THRADD_VISITS, 3)
+ADD_GAME_STATE (THRADD_HOME_VISITS, 3)
+ADD_GAME_STATE (HELIX_VISITS, 3)
+ADD_GAME_STATE (HELIX_UNPROTECTED, 1)
+ADD_GAME_STATE (THRADD_CULTURE, 2)
+ADD_GAME_STATE (THRADD_MISSION, 3)
+/* 0 if the Thraddash fleet hasn't left the Thraddash home world.
+ * 1 if the Thraddash are heading towards Kohr-Ah territory.
+ * 2 if the Thraddash are fighting the Kohr-Ah.
+ * 3 if the Thraddash are returning from Kohr-Ah territory.
+ * 4 if the Thraddash fleet is back at the Thraddash home world.
+ */
+
+ADD_GAME_STATE (DRUUGE_VISITS, 3)
+ADD_GAME_STATE (DRUUGE_HOME_VISITS, 3)
+ADD_GAME_STATE (ROSY_SPHERE, 1)
+/* The play has or has had the Rosy Sphere.
+ * cf. ROSY_SHERE_ON_SHIP */
+ADD_GAME_STATE (SCANNED_MAIDENS, 1)
+ADD_GAME_STATE (SCANNED_FRAGMENTS, 1)
+ADD_GAME_STATE (SCANNED_CASTER, 1)
+ADD_GAME_STATE (SCANNED_SPAWNER, 1)
+ADD_GAME_STATE (SCANNED_ULTRON, 1)
+
+ADD_GAME_STATE (ZOQFOT_INFO, 2)
+ADD_GAME_STATE (ZOQFOT_HOSTILE, 1)
+ADD_GAME_STATE (ZOQFOT_HOME_VISITS, 3)
+ADD_GAME_STATE (MET_ZOQFOT, 1)
+ADD_GAME_STATE (ZOQFOT_DISTRESS, 2)
+/* 0 if the Zoq-Fot-Pik aren't in distress
+ * 1 if the Zoq-Fot-Pik are under attack by the Kohr-Ah
+ * 2 if the Zoq-Fot-Pik have been destroyed because of this
+ *   attack (not by the Kohr-Ah final victory cleansing)
+ */
+
+ADD_GAME_STATE (EGG_CASE1_ON_SHIP, 1)
+ADD_GAME_STATE (EGG_CASE2_ON_SHIP, 1)
+ADD_GAME_STATE (MYCON_SUN_VISITS, 3)
+ADD_GAME_STATE (ORZ_HOME_VISITS, 3)
+
+ADD_GAME_STATE (MELNORME_FUEL_PROCEDURE, 1)
+ADD_GAME_STATE (MELNORME_TECH_PROCEDURE, 1)
+ADD_GAME_STATE (MELNORME_INFO_PROCEDURE, 1)
+
+ADD_GAME_STATE (MELNORME_TECH_STACK, 4)
+ADD_GAME_STATE (MELNORME_EVENTS_INFO_STACK, 5)
+ADD_GAME_STATE (MELNORME_ALIEN_INFO_STACK, 5)
+ADD_GAME_STATE (MELNORME_HISTORY_INFO_STACK, 5)
+
+ADD_GAME_STATE (RAINBOW_WORLD0, 8)
+/* Low byte of a bit array, one bit per rainbow world.
+ * Each bit is set if the rainbow world has been visited.
+ * The lowest bit is for the first star in the star_array
+ * with RAINBOW_DEFINED, and so on.
+ */
+ADD_GAME_STATE (RAINBOW_WORLD1, 2)
+/* High 2 bits of the bit array of which RAINBOW_WORLD0
+ * is the low byte.
+ */
+ADD_GAME_STATE (MELNORME_RAINBOW_COUNT, 4)
+/* The number of rainbow world locations sold to the Melnorme. */
+ADD_GAME_STATE (FOUND_KNOWN_RAINBOW_WORLD, 2)
+/* JMS: Zeta Sextantis rainbow world which the Melnorme already know about. */
+/* The Melnorme don't revenue the player for this rainbow world, instead    */
+/* tell him it's useless - they already know about it.						*/
+/* 0 when not visited. 1 when visited. 2 when tried to sell it to Melnorme. */
+
+ADD_GAME_STATE (USED_BROADCASTER, 1)
+ADD_GAME_STATE (BROADCASTER_RESPONSE, 1)
+
+ADD_GAME_STATE (IMPROVED_LANDER_SPEED, 1)
+ADD_GAME_STATE (IMPROVED_LANDER_CARGO, 1)
+ADD_GAME_STATE (IMPROVED_LANDER_SHOT, 1)
+
+ADD_GAME_STATE (MET_ORZ_BEFORE, 1)
+ADD_GAME_STATE (YEHAT_REBEL_TOLD_PKUNK, 1)
+ADD_GAME_STATE (PLAYER_HAD_SEX, 1)
+ADD_GAME_STATE (UMGAH_BROADCASTERS_ON_SHIP, 1)
+
+ADD_GAME_STATE (LIGHT_MINERAL_LOAD, 3)
+ADD_GAME_STATE (MEDIUM_MINERAL_LOAD, 3)
+ADD_GAME_STATE (HEAVY_MINERAL_LOAD, 3)
+
+ADD_GAME_STATE (STARBASE_BULLETS0, 8)
+ADD_GAME_STATE (STARBASE_BULLETS1, 8)
+ADD_GAME_STATE (STARBASE_BULLETS2, 8)
+ADD_GAME_STATE (STARBASE_BULLETS3, 8)
+
+ADD_GAME_STATE (STARBASE_MONTH, 4)
+ADD_GAME_STATE (STARBASE_DAY, 5)
+
+ADD_GAME_STATE (CREW_SOLD_TO_DRUUGE0, 8)
+ADD_GAME_STATE (CREW_PURCHASED0, 8)
+ADD_GAME_STATE (CREW_PURCHASED1, 8)
+
+ADD_GAME_STATE (URQUAN_PROTECTING_SAMATRA, 1)
+
+ADD_GAME_STATE (COLONY_GRPOFFS0, 8)
+ADD_GAME_STATE (COLONY_GRPOFFS1, 8)
+ADD_GAME_STATE (COLONY_GRPOFFS2, 8)
+ADD_GAME_STATE (COLONY_GRPOFFS3, 8)
+
+ADD_GAME_STATE (THRADDASH_BODY_COUNT, 5)
+
+ADD_GAME_STATE (UTWIG_SUPOX_MISSION, 3)
+/* 0 if the Utwig and Supox fleet haven't left their home world.
+ * 1 if the U&S are on their way towards the Kohr-Ah
+ * 2 if the U&S are fighting the Kohr-Ah (first 80 days)
+ * 3 does not occur
+ * 4 if the U&S are fighting the Kohr-Ah (second 80 days)
+ * 5 if the U&S are returning home.
+ * 6 if the U&S are back at their home world.
+ */
+ADD_GAME_STATE (SPATHI_INFO, 3)
+
+ADD_GAME_STATE (ILWRATH_INFO, 2)
+ADD_GAME_STATE (ILWRATH_GODS_SPOKEN, 4)
+ADD_GAME_STATE (ILWRATH_WORSHIP, 2)
+ADD_GAME_STATE (ILWRATH_FIGHT_THRADDASH, 1)
+
+ADD_GAME_STATE (SAMATRA_GRPOFFS0, 8)
+ADD_GAME_STATE (SAMATRA_GRPOFFS1, 8)
+ADD_GAME_STATE (SAMATRA_GRPOFFS2, 8)
+ADD_GAME_STATE (SAMATRA_GRPOFFS3, 8)
+
+ADD_GAME_STATE (READY_TO_CONFUSE_URQUAN, 1)
+ADD_GAME_STATE (URQUAN_HYPNO_VISITS, 1)
+ADD_GAME_STATE (MENTIONED_PET_COMPULSION, 1)
+ADD_GAME_STATE (URQUAN_INFO, 2)
+ADD_GAME_STATE (KNOW_URQUAN_STORY, 2)
+
+ADD_GAME_STATE (MYCON_INFO, 4)
+ADD_GAME_STATE (MYCON_RAMBLE, 5)
+ADD_GAME_STATE (KNOW_ABOUT_SHATTERED, 2)
+/* 0 if the player doesn't known about shattered worlds
+ * 1 if the player has encountered a shattered world
+ * 2 if the player knows that shatterred worlds are caused
+ *   by Mycon deep children.
+ * 3 if the player has told the Syreen that Mycon Deep Children
+ *   cause shattered worlds. Proof doesn't have to be presented
+ *   yet at this time.
+ */
+ADD_GAME_STATE (MYCON_INSULTS, 3)
+ADD_GAME_STATE (MYCON_KNOW_AMBUSH, 1)
+/* Set to 1 when the Mycon have been butchered at Organon,
+ * just before the remaining Mycon head back home.
+ */
+
+ADD_GAME_STATE (SYREEN_INFO, 2)
+ADD_GAME_STATE (KNOW_SYREEN_WORLD_SHATTERED, 1)
+ADD_GAME_STATE (SYREEN_KNOW_ABOUT_MYCON, 1)
+
+ADD_GAME_STATE (TALKING_PET_INFO, 3)
+ADD_GAME_STATE (TALKING_PET_SUGGESTIONS, 3)
+ADD_GAME_STATE (LEARNED_TALKING_PET, 1)
+ADD_GAME_STATE (DNYARRI_LIED, 1)
+/* Set when the Talking Pet tells you his version of their
+ * race's history with the Ur-Quan.
+ * Cleared once you confront him about this lie.
+ */
+ADD_GAME_STATE (SHIP_TO_COMPEL, 1)
+
+ADD_GAME_STATE (ORZ_GENERAL_INFO, 2)
+ADD_GAME_STATE (ORZ_PERSONAL_INFO, 3)
+ADD_GAME_STATE (ORZ_ANDRO_STATE, 2)
+ADD_GAME_STATE (REFUSED_ORZ_ALLIANCE, 1)
+
+ADD_GAME_STATE (PKUNK_MANNER, 2)
+/* 0 not met the Pkunk
+ * 1 fought the Pkunk, but relations are still salvagable.
+ * 2 hostile relations with the Pkunk, no way back.
+ * 3 friendly relations with the Pkunk
+ */
+ADD_GAME_STATE (PKUNK_ON_THE_MOVE, 1)
+ADD_GAME_STATE (PKUNK_FLEET, 2)
+ADD_GAME_STATE (PKUNK_MIGRATE, 2)
+ADD_GAME_STATE (PKUNK_RETURN, 1)
+ADD_GAME_STATE (PKUNK_WORRY, 2)
+ADD_GAME_STATE (PKUNK_INFO, 3)
+ADD_GAME_STATE (PKUNK_WAR, 2)
+ADD_GAME_STATE (PKUNK_FORTUNE, 3)
+ADD_GAME_STATE (PKUNK_MIGRATE_VISITS, 3)
+ADD_GAME_STATE (PKUNK_REASONS, 4)
+ADD_GAME_STATE (PKUNK_SWITCH, 1)
+ADD_GAME_STATE (PKUNK_SENSE_VICTOR, 1)
+ADD_GAME_STATE (PKUNK_JOKE, 1)
+
+ADD_GAME_STATE (KOHR_AH_REASONS, 2)
+ADD_GAME_STATE (KOHR_AH_PLEAD, 2)
+ADD_GAME_STATE (KOHR_AH_INFO, 2)
+ADD_GAME_STATE (KNOW_KOHR_AH_STORY, 2)
+ADD_GAME_STATE (KOHR_AH_SENSES_EVIL, 1)
+ADD_GAME_STATE (URQUAN_SENSES_EVIL, 1)
+
+ADD_GAME_STATE (SLYLANDRO_PROBE_VISITS, 3)
+ADD_GAME_STATE (SLYLANDRO_PROBE_THREAT, 2)
+ADD_GAME_STATE (SLYLANDRO_PROBE_WRONG, 2)
+ADD_GAME_STATE (SLYLANDRO_PROBE_ID, 2)
+ADD_GAME_STATE (SLYLANDRO_PROBE_INFO, 2)
+ADD_GAME_STATE (SLYLANDRO_PROBE_EXIT, 2)
+
+ADD_GAME_STATE (UMGAH_HOSTILE, 1)
+ADD_GAME_STATE (UMGAH_EVIL_BLOBBIES, 1)
+ADD_GAME_STATE (UMGAH_MENTIONED_TRICKS, 2)
+
+ADD_GAME_STATE (BOMB_CARRIER, 1)
+/* 0 when the flagship is not in battle, or it doesn't have the
+ *   enhanced precursor bomb installed.
+ * 1 when the flagship is in battle and the bomb is installed.
+ * This determines whether you can flee (if the warp escape unit
+ * is installed at all), and whether taking the ship into the
+ * Sa-Matra defense structure will trigger the end of the game.
+ */
+
+ADD_GAME_STATE (THRADD_MANNER, 1)
+ADD_GAME_STATE (THRADD_INTRO, 2)
+ADD_GAME_STATE (THRADD_DEMEANOR, 3)
+ADD_GAME_STATE (THRADD_INFO, 2)
+ADD_GAME_STATE (THRADD_BODY_LEVEL, 2)
+ADD_GAME_STATE (THRADD_MISSION_VISITS, 1)
+ADD_GAME_STATE (THRADD_STACK_1, 3)
+ADD_GAME_STATE (THRADD_HOSTILE_STACK_2, 1)
+ADD_GAME_STATE (THRADD_HOSTILE_STACK_3, 1)
+ADD_GAME_STATE (THRADD_HOSTILE_STACK_4, 1)
+ADD_GAME_STATE (THRADD_HOSTILE_STACK_5, 1)
+
+ADD_GAME_STATE (CHMMR_STACK, 2)
+
+ADD_GAME_STATE (ARILOU_MANNER, 2)
+ADD_GAME_STATE (NO_PORTAL_VISITS, 1)
+ADD_GAME_STATE (ARILOU_STACK_1, 2)
+ADD_GAME_STATE (ARILOU_STACK_2, 1)
+ADD_GAME_STATE (ARILOU_STACK_3, 2)
+ADD_GAME_STATE (ARILOU_STACK_4, 1)
+ADD_GAME_STATE (ARILOU_STACK_5, 2)
+ADD_GAME_STATE (ARILOU_INFO, 2)
+ADD_GAME_STATE (ARILOU_HINTS, 2)
+
+ADD_GAME_STATE (DRUUGE_MANNER, 1)
+ADD_GAME_STATE (DRUUGE_SPACE_INFO, 2)
+ADD_GAME_STATE (DRUUGE_HOME_INFO, 2)
+ADD_GAME_STATE (DRUUGE_SALVAGE, 1)
+ADD_GAME_STATE (KNOW_DRUUGE_SLAVERS, 2)
+ADD_GAME_STATE (FRAGMENTS_BOUGHT, 2)
+
+ADD_GAME_STATE (ZEX_STACK_1, 2)
+ADD_GAME_STATE (ZEX_STACK_2, 2)
+ADD_GAME_STATE (ZEX_STACK_3, 2)
+
+ADD_GAME_STATE (VUX_INFO, 2)
+ADD_GAME_STATE (VUX_STACK_1, 4)
+ADD_GAME_STATE (VUX_STACK_2, 2)
+ADD_GAME_STATE (VUX_STACK_3, 2)
+ADD_GAME_STATE (VUX_STACK_4, 2)
+ADD_GAME_STATE (VUX_MET, 2)
+
+ADD_GAME_STATE (SHOFIXTI_STACK4, 2)
+
+ADD_GAME_STATE (YEHAT_REBEL_INFO, 3)
+ADD_GAME_STATE (YEHAT_ROYALIST_INFO, 1)
+ADD_GAME_STATE (YEHAT_ROYALIST_TOLD_PKUNK, 1)
+ADD_GAME_STATE (NO_YEHAT_ALLY_HOME, 1)
+ADD_GAME_STATE (NO_YEHAT_HELP_HOME, 1)
+ADD_GAME_STATE (NO_YEHAT_INFO, 1)
+ADD_GAME_STATE (NO_YEHAT_ALLY_SPACE, 2)
+ADD_GAME_STATE (NO_YEHAT_HELP_SPACE, 2)
+
+ADD_GAME_STATE (ZOQFOT_KNOW_MASK, 4)
+
+ADD_GAME_STATE (SUPOX_HOSTILE, 1)
+ADD_GAME_STATE (SUPOX_INFO, 1)
+ADD_GAME_STATE (SUPOX_WAR_NEWS, 2)
+ADD_GAME_STATE (SUPOX_ULTRON_HELP, 1)
+ADD_GAME_STATE (SUPOX_STACK1, 3)
+ADD_GAME_STATE (SUPOX_STACK2, 2)
+
+ADD_GAME_STATE (UTWIG_HOSTILE, 1)
+ADD_GAME_STATE (UTWIG_INFO, 1)
+ADD_GAME_STATE (UTWIG_WAR_NEWS, 2)
+ADD_GAME_STATE (UTWIG_STACK1, 3)
+ADD_GAME_STATE (UTWIG_STACK2, 2)
+ADD_GAME_STATE (BOMB_INFO, 1)
+ADD_GAME_STATE (BOMB_STACK1, 2)
+ADD_GAME_STATE (BOMB_STACK2, 2)
+
+ADD_GAME_STATE (SLYLANDRO_KNOW_BROKEN, 1)
+ADD_GAME_STATE (PLAYER_KNOWS_PROBE, 1)
+ADD_GAME_STATE (PLAYER_KNOWS_PROGRAM, 1)
+ADD_GAME_STATE (PLAYER_KNOWS_EFFECTS, 1)
+ADD_GAME_STATE (PLAYER_KNOWS_PRIORITY, 1)
+ADD_GAME_STATE (SLYLANDRO_STACK1, 3)
+ADD_GAME_STATE (SLYLANDRO_STACK2, 1)
+ADD_GAME_STATE (SLYLANDRO_STACK3, 2)
+ADD_GAME_STATE (SLYLANDRO_STACK4, 2)
+ADD_GAME_STATE (SLYLANDRO_STACK5, 1)
+ADD_GAME_STATE (SLYLANDRO_STACK6, 1)
+ADD_GAME_STATE (SLYLANDRO_STACK7, 2)
+ADD_GAME_STATE (SLYLANDRO_STACK8, 2)
+ADD_GAME_STATE (SLYLANDRO_STACK9, 2)
+ADD_GAME_STATE (SLYLANDRO_KNOW_EARTH, 1)
+ADD_GAME_STATE (SLYLANDRO_KNOW_EXPLORE, 1)
+ADD_GAME_STATE (SLYLANDRO_KNOW_GATHER, 1)
+ADD_GAME_STATE (SLYLANDRO_KNOW_URQUAN, 2)
+ADD_GAME_STATE (RECALL_VISITS, 2)
+
+ADD_GAME_STATE (SLYLANDRO_MULTIPLIER, 3)
+ADD_GAME_STATE (KNOW_SPATHI_QUEST, 1)
+ADD_GAME_STATE (KNOW_SPATHI_EVIL, 1)
+
+ADD_GAME_STATE (BATTLE_PLANET, 8)
+ADD_GAME_STATE (ESCAPE_COUNTER, 8)
+
+ADD_GAME_STATE (CREW_SOLD_TO_DRUUGE1, 8)
+ADD_GAME_STATE (PKUNK_DONE_WAR, 1)
+
+ADD_GAME_STATE (SYREEN_STACK0, 2)
+ADD_GAME_STATE (SYREEN_STACK1, 2)
+ADD_GAME_STATE (SYREEN_STACK2, 2)
+ADD_GAME_STATE (SYREEN_MET, 2)
+
+ADD_GAME_STATE (REFUSED_ULTRON_AT_BOMB, 1)
+ADD_GAME_STATE (NO_TRICK_AT_SUN, 1)
+
+ADD_GAME_STATE (SPATHI_STACK0, 2)
+ADD_GAME_STATE (SPATHI_STACK1, 1)
+ADD_GAME_STATE (SPATHI_STACK2, 1)
+
+// JMS: Resized Orz stacks
+ADD_GAME_STATE (ORZ_STACK0, 2)
+ADD_GAME_STATE (ORZ_STACK1, 2)
+
+// JMS: Androsynth states
+ADD_GAME_STATE (ANDROSYNTH_VISITS, 3)
+ADD_GAME_STATE (ANDROSYNTH_HOSTILE, 1)
+ADD_GAME_STATE (ANDROSYNTH_MET, 1)
+ADD_GAME_STATE (KNOW_ANDROSYNTH_STATE, 1)
+ADD_GAME_STATE (ANDROSYNTH_STACK_1, 3)
+ADD_GAME_STATE (ANDROSYNTH_STACK_2, 1)
+
+// JMS: New Chmmr states
+ADD_GAME_STATE (CHMMR_SPACE_VISITS, 2)
+
+// JMS: Human states
+ADD_GAME_STATE (HUMAN_VISITS, 3)
+ADD_GAME_STATE (HUMAN_NEWS, 3)
+ADD_GAME_STATE (HUMAN_FUEL_INFO, 3)
+ADD_GAME_STATE (HUMAN_NUKES_DONE, 1)
+
+// JMS: ORZ space states
+ADD_GAME_STATE (ORZ_SPACE_SIDE, 2)
+ADD_GAME_STATE (LEAVING_ORZ_SPACE, 1)
+
+// JMS: Vela Precursor factory
+ADD_GAME_STATE (VELA_FACTORY_VISITED, 1)
+
+// JMS: Which ship is the flagship
+ADD_GAME_STATE (WHICH_SHIP_PLAYER_HAS, 2)
+// 0 - Chmmr Explorer
+// 1 - Precursor vessel
+// 2 - Precursor Battleship, full game
+// 3 - UNUSED
+
+// JMS: New devices. They either are or aren't on ship.
+ADD_GAME_STATE (BLACK_ORB_ON_SHIP, 1)
+ADD_GAME_STATE (BLACK_ORB, 1)
+ADD_GAME_STATE (TEMPORAL_WRAPPER_ON_SHIP, 1)
+ADD_GAME_STATE (SHIELD_BUSTER_ON_SHIP, 1)
+
+// JMS: Transport ship states
+ADD_GAME_STATE (TRANSPORT_SHIP_0_STATUS, 3)
+// 0 - Waiting for leaving in orbit.
+// 1 - Leaving for hyperspace, still in home system.
+// 2 - "Left truespace, not yet appeared in hyperspace.
+// 3 - Now in hyperspace.
+// 4 - Arriving destination.
+// 5 - UNUSED
+// 6 - UNUSED
+// 7 - UNUSED
+
+// JMS: Slaveshield buster crap
+ADD_GAME_STATE (USED_BUSTER, 1)
+
+// JMS: How many times player has met Slylandros in kohr-ah vessels
+ADD_GAME_STATE (SLYLANDRO_KOHRAH_MET_TIMES, 2)
+ADD_GAME_STATE (KNOW_SLYLANDRO_KOHRAH, 1)
+ADD_GAME_STATE (SLYLANDRO_KOHRAH_PANIC, 1)
+
+// JMS: Did enemy ship escape from combat
+ADD_GAME_STATE (ENEMY_ESCAPE_OCCURRED, 1)
+
+// JMS: Initer, which is related to starbase month and day tracking (See comm/starbas.c for more info.)
+ADD_GAME_STATE (STARBASE_VISITED_FOR_FIRST_TIME, 1)
+
+// JMS: It is allowed for the autopilot to engage
+ADD_GAME_STATE (AUTOPILOT_OK, 1)
+
+// JMS: Set shofixti crash site triangulation spheres visible in starmap
+ADD_GAME_STATE (TRIANGULATION_SPHERES_CHMMR, 1)
+ADD_GAME_STATE (TRIANGULATION_SPHERES_SHOFIXTI, 1)
+// JMS: Once the artifact is found, the spheres are no longer necessary
+ADD_GAME_STATE (HIDE_TRIANGULATION_SPHERES, 1)
+
+// JMS: Shofixti patrol that was late has returned home
+ADD_GAME_STATE (SHOFIXTI_PATROL_RETURNED, 1)
+// JMS: Player has heard shofixti tell the patrol returned home
+ADD_GAME_STATE (SHOFIXTI_GREAT_NEWS_HEARD, 1)
+// JMS: Player has visited Shofixti Colony
+ADD_GAME_STATE (SHOFIXTI_COLONY_MET, 2) 
+// 0 - Not met
+// 1 - Met, playing "lights up" transition graphics.
+// 2 - Met, lights are up.
+// 3 - Talking allowed.
+
+// JMS: Player has been introduced to Hiroku.
+ADD_GAME_STATE (SHOFIXTI_COLONY_INTRODUCED, 1)
+
+// JMS: News 'n' shit at the colony.
+ADD_GAME_STATE (SHOFIXTICOL_CURRENT_NEWS_STACK, 3)
+
+// JMS: Are the Lurg hanging out at the Shofixti distress site planet
+ADD_GAME_STATE (CRASH_SITE_UNPROTECTED, 1)
+ADD_GAME_STATE (CRASH_SITE_VISITED, 1)
+ADD_GAME_STATE (CRASH_SITE_LURG_SURVIVORS, 3)
+
+// JMS: Are the Lurg hanging out at the Shofixti distress site planet
+ADD_GAME_STATE (BLACK_ORB_STATE, 2)
+// 0 - Black orb not found yet
+// 1 - Black orb found, lander enroute to orbit from finding it
+// 2 - Black orb found, lander back in orbit
+
+// JMS: Syreen ship giving states
+ADD_GAME_STATE (SYREEN_WILL_GIVE_VESSEL, 1)
+ADD_GAME_STATE (SYREEN_SHIP_MONTH, 4)
+/* The month in SYREEN_SHIP_YEAR that new ships are available
+* from the Syreen. */
+ADD_GAME_STATE (SYREEN_SHIP_DAY, 5)
+/* The day of the month in SYREEN_SHIP_MONTH in SYREEN_SHIP_YEAR
+* that new ships are available. */
+ADD_GAME_STATE (SYREEN_SHIP_YEAR, 5)
+/* The year that new ships are available from the Syreen
+* (stored as an offset from the year the game starts). */
+
+// JMS: Yehat Precursor artifact hint at Gamma Janus
+ADD_GAME_STATE (YEHAT_PRECURSOR_ARTIFACT, 2)
+// 0 - Precursor artifact not seen or heard of
+// 1 - Heard about Precursor artifact from the Yehat OR seen it on the planet
+// 2 - "Precursor artifact" seen on the planet AND heard the Yehat story on it 
+// 3 - Information on "artifact" dealt to melnorme
+
+// JMS: The location of those that left in a hurry
+ADD_GAME_STATE (HINT_WORLD_LOCATION, 2)
+
+// JMS: Stronger lander shot is more effective and required for destroying certain enemies.
+ADD_GAME_STATE (STRONGER_LANDER_SHOT, 1)
+
+// JMS: Stupid joke in Chmmr & Melnorme encounters...
+ADD_GAME_STATE (TZZRAK_TZON_PICS, 1)
+
+// JMS: Has player yet tried to apologize to the VUX.
+ADD_GAME_STATE (VUX_APOLOGY_TRIED, 1)
+ADD_GAME_STATE (VUX_RANT_HEARD, 1)
diff -ruNp src.orig/uqm/gamestr.h src/uqm/gamestr.h
--- src.orig/uqm/gamestr.h	2017-11-01 15:30:25 -0700
+++ src/uqm/gamestr.h	2017-11-01 15:31:02 -0700
@@ -19,6 +19,8 @@
  * the game. libs/strlib.h is for the string library.
  */
 
+// JMS 2009: Added label for ORZ space = "*below*"
+
 #ifndef _GAMESTR_H
 #define _GAMESTR_H
 
@@ -30,22 +32,22 @@
 #define CARGO_STRING_COUNT       10
 #define ELEMENTS_STRING_COUNT   133
 #define SCAN_STRING_COUNT        56
-#define STAR_NUMBER_COUNT        14
+#define STAR_NUMBER_COUNT        15
 #define PLANET_NUMBER_COUNT      33
 #define MONTHS_STRING_COUNT      12
-#define FEEDBACK_STRING_COUNT     2
+#define FEEDBACK_STRING_COUNT     3
 #define STARBASE_STRING_COUNT     5
 #define ENCOUNTER_STRING_COUNT    8
-#define NAVIGATION_STRING_COUNT   6
+#define NAVIGATION_STRING_COUNT   7 // JMS: Original value was 6. This facilitates the text "*below*".
 #define NAMING_STRING_COUNT       4
 #define MELEE_STRING_COUNT        9
 #define SAVEGAME_STRING_COUNT     5
-#define OPTION_STRING_COUNT       5
+#define OPTION_STRING_COUNT       6
 #define QUITMENU_STRING_COUNT     3
 #define STATUS_STRING_COUNT       6
 #define FLAGSHIP_STRING_COUNT    13
 #define ORBITSCAN_STRING_COUNT   19
-#define MAINMENU_STRING_COUNT    55
+#define MAINMENU_STRING_COUNT    57
 #define NETMELEE_STRING_COUNT    19
 
 enum {
diff -ruNp src.orig/uqm/gendef.c src/uqm/gendef.c
--- src.orig/uqm/gendef.c	2017-11-01 15:30:25 -0700
+++ src/uqm/gendef.c	2017-11-01 15:31:02 -0700
@@ -16,6 +16,11 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2009: Function call for initing orz space portal when encountering its enum label
+// JMS 2010: -Function call for initing Lurg home system when encountering its enum label
+//			 -Function call for initing those ones that mysteriously vanished in a hurry
+//			 -Function call for initing Gamma Janus, the supposed precursor artifact
+
 #include "gendef.h"
 #include "encount.h"
 #include "planets/generate.h"
@@ -28,20 +33,26 @@ extern GenerateFunctions generateBurvixe
 extern GenerateFunctions generateChmmrFunctions;
 extern GenerateFunctions generateColonyFunctions;
 extern GenerateFunctions generateDruugeFunctions;
+extern GenerateFunctions generateHint1Functions;
+extern GenerateFunctions generateHint2Functions;
 extern GenerateFunctions generateIlwrathFunctions;
+extern GenerateFunctions generateLurgFunctions;
 extern GenerateFunctions generateMelnormeFunctions;
 extern GenerateFunctions generateMyconFunctions;
 extern GenerateFunctions generateOrzFunctions;
+extern GenerateFunctions generateOrzSpacePortalFunctions;
 extern GenerateFunctions generatePkunkFunctions;
 extern GenerateFunctions generateRainbowWorldFunctions;
 extern GenerateFunctions generateSaMatraFunctions;
 extern GenerateFunctions generateShofixtiFunctions;
+extern GenerateFunctions generateShofixtiCrashSiteFunctions;
+extern GenerateFunctions generateShofixtiColonyFunctions;
+extern GenerateFunctions generateSlaveraceFunctions;
 extern GenerateFunctions generateSlylandroFunctions;
 extern GenerateFunctions generateSolFunctions;
 extern GenerateFunctions generateSpathiFunctions;
 extern GenerateFunctions generateSupoxFunctions;
 extern GenerateFunctions generateSyreenFunctions;
-extern GenerateFunctions generateTalkingPetFunctions;
 extern GenerateFunctions generateThraddashFunctions;
 extern GenerateFunctions generateTrapFunctions;
 extern GenerateFunctions generateUtwigFunctions;
@@ -50,7 +61,6 @@ extern GenerateFunctions generateVuxFunc
 extern GenerateFunctions generateWreckFunctions;
 extern GenerateFunctions generateYehatFunctions;
 extern GenerateFunctions generateZoqFotPikFunctions;
-extern GenerateFunctions generateZoqFotPikScoutFunctions;
 
 
 const GenerateFunctions *
@@ -76,8 +86,6 @@ getGenerateFunctions (BYTE Index)
 		case MELNORME7_DEFINED:
 		case MELNORME8_DEFINED:
 			return &generateMelnormeFunctions;
-		case TALKING_PET_DEFINED:
-			return &generateTalkingPetFunctions;
 		case CHMMR_DEFINED:
 			return &generateChmmrFunctions;
 		case SYREEN_DEFINED:
@@ -119,8 +127,6 @@ getGenerateFunctions (BYTE Index)
 			return &generateSaMatraFunctions;
 		case ZOQFOT_DEFINED:
 			return &generateZoqFotPikFunctions;
-		case ZOQ_SCOUT_DEFINED:
-			return &generateZoqFotPikScoutFunctions;
 		case YEHAT_DEFINED:
 			return &generateYehatFunctions;
 		case PKUNK_DEFINED:
@@ -128,9 +134,25 @@ getGenerateFunctions (BYTE Index)
 		case SUPOX_DEFINED:
 			return &generateSupoxFunctions;
 		case RAINBOW_DEFINED:
+		case RAINBOW_KNOWN_DEFINED:  // JMS - hook to generating the Zeta Sextantis rainbow world which is already known to Melnorme
 			return &generateRainbowWorldFunctions;
 		case ILWRATH_DEFINED:
 			return &generateIlwrathFunctions;
+		case SLAVERACE_DEFINED:
+			return &generateSlaveraceFunctions;
+		case ORZ_SPACE_PORTAL_DEFINED: // JMS - hook to generating the contents of portal star system 
+			return &generateOrzSpacePortalFunctions;
+		case LURG_DEFINED:
+			return &generateLurgFunctions;	 // JMS - hook to generating Lurg home system
+		case SHOFIXTI_CRASH_SITE_DEFINED:
+			return &generateShofixtiCrashSiteFunctions;	 // JMS - hook to generating Shofixti crash site
+		case HINT_DEFINED:
+			return &generateHint1Functions;	 // JMS - hook to generating hint for those ones mysteriously vanished in a hurry
+		case HINT2_DEFINED:
+			return &generateHint2Functions; // JMS - hook to generating hint in Gamma Janus for the supposed precursor artifact
+		case SHOFIXTI_COLONY_DEFINED:
+			return &generateShofixtiColonyFunctions;	 // JMS - hook to generating Shofixti colony
+			break;
 		default:
 			return &generateDefaultFunctions;
 	}
diff -ruNp src.orig/uqm/globdata.c src/uqm/globdata.c
--- src.orig/uqm/globdata.c	2017-11-01 15:30:25 -0700
+++ src/uqm/globdata.c	2017-11-01 15:31:02 -0700
@@ -16,6 +16,23 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2009: -Added maximum number of races into InitSIS function to facilitate Androsynth into the game.
+// It is very important to remember to update this number of races here when adding races to the game, otherwise
+// the races won't show up in the game AND the defines and enums in races.h will have quirky side-effects.
+//
+// Originally the max number of races was defined by KOHR_AH_ID and some constant numbers.
+// Max num of races is now defined by ISD_ID plus the constant numbers because of the added new races.
+//
+// JMS 2010: -Added SET_GAME_STATE (STARBASE_AVAILABLE, 1); to InitSIS so starbase is available right
+// from the start of the game. Kind of hack, maybe we should just remove the whole starbase_available variable...
+//
+//			 -Changed the starting number of thrusters and turning jets for Chmmr Explorer
+//			 -Game now starts at Procyon
+//			 -Show human and Chmmr SoIs right from the start
+//			 -Utwig ships not available for buying at starbases anymore
+// 
+// JMS 2011: -The locations of known races' home planets is shown right from the start of the game (but not the whole SoIs).
+
 #include "globdata.h"
 
 #include "coderes.h"
@@ -27,14 +44,17 @@
 #include "resinst.h"
 #include "nameref.h"
 #include "build.h"
+#include "hyper.h"
 #include "state.h"
 #include "grpinfo.h"
 #include "gamestr.h"
 
 #include <stdlib.h>
-#ifdef STATE_DEBUG
-#	include "libs/log.h"
-#endif
+#include "libs/log.h"
+
+#include "libs/mathlib.h"
+
+#include <glib.h>
 
 
 static void CreateRadar (void);
@@ -198,9 +218,8 @@ InitGameStructures (void)
 		COUNT num_ships;
 		SPECIES_ID s_id = ARILOU_ID;
 
-		num_ships = KOHR_AH_ID - s_id + 1
-				+ 2; /* Yehat Rebels and Ur-Quan probe */
-
+		num_ships = LAST_MELEE_ID - s_id + 2; /* Yehat Rebels and Transport ship */
+		
 		InitQueue (&GLOBAL (avail_race_q), num_ships, sizeof (FLEET_INFO));
 		for (i = 0; i < num_ships; ++i)
 		{
@@ -213,7 +232,7 @@ InitGameStructures (void)
 			else if (i == num_ships - 2)
 				ship_ref = YEHAT_ID;
 			else  /* (i == num_ships - 1) */
-				ship_ref = UR_QUAN_PROBE_ID;
+				ship_ref = TRANSPORT_ID;
 			
 			hFleet = AllocLink (&GLOBAL (avail_race_q));
 			if (!hFleet)
@@ -235,7 +254,7 @@ InitGameStructures (void)
 			}
 			else
 			{
-				// Ur-Quan probe.
+				// Transport ship.
 				RACE_DESC *RDPtr = load_ship (FleetPtr->SpeciesID,
 						FALSE);
 				if (RDPtr)
@@ -246,7 +265,6 @@ InitGameStructures (void)
 					free_ship (RDPtr, FALSE, FALSE);
 				}
 			}
-
 			FleetPtr->allied_state = BAD_GUY;
 			FleetPtr->known_strength = 0;
 			FleetPtr->loc = FleetPtr->known_loc;
@@ -291,20 +309,36 @@ InitGameStructures (void)
 
 	for (i = 0; i < NUM_DRIVE_SLOTS; ++i)
 		GLOBAL_SIS (DriveSlots[i]) = EMPTY_SLOT + 0;
-	GLOBAL_SIS (DriveSlots[5]) =
-			GLOBAL_SIS (DriveSlots[6]) = FUSION_THRUSTER;
+	GLOBAL_SIS (DriveSlots[0]) =  // JMS
+	GLOBAL_SIS (DriveSlots[1]) =  // JMS
+	GLOBAL_SIS (DriveSlots[2]) =  // JMS
+	GLOBAL_SIS (DriveSlots[3]) =
+	GLOBAL_SIS (DriveSlots[4]) = // JMS
+	GLOBAL_SIS (DriveSlots[5]) = // JMS
+	GLOBAL_SIS (DriveSlots[6]) = // JMS
+			GLOBAL_SIS (DriveSlots[7]) = FUSION_THRUSTER;
 	for (i = 0; i < NUM_JET_SLOTS; ++i)
 		GLOBAL_SIS (JetSlots[i]) = EMPTY_SLOT + 1;
 	GLOBAL_SIS (JetSlots[0]) =
-			GLOBAL_SIS (JetSlots[6]) = TURNING_JETS;
-	for (i = 0; i < NUM_MODULE_SLOTS; ++i)
-		GLOBAL_SIS (ModuleSlots[i]) = EMPTY_SLOT + 2;
-	GLOBAL_SIS (ModuleSlots[15]) = GUN_WEAPON;
+	GLOBAL_SIS (JetSlots[1]) = // JMS
+	GLOBAL_SIS (JetSlots[2]) = // JMS
+	GLOBAL_SIS (JetSlots[3]) = // JMS
+	GLOBAL_SIS (JetSlots[4]) = // JMS
+	GLOBAL_SIS (JetSlots[5]) = // JMS
+	GLOBAL_SIS (JetSlots[6]) = // JMS
+		GLOBAL_SIS (JetSlots[7]) = TURNING_JETS;
+
+	if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) != CHMMR_EXPLORER_SHIP)
+		for (i = 0; i < NUM_MODULE_SLOTS; ++i)
+			GLOBAL_SIS (ModuleSlots[i]) = EMPTY_SLOT + 2;
+	
+	/*GLOBAL_SIS (ModuleSlots[15]) = GUN_WEAPON;
 	GLOBAL_SIS (ModuleSlots[2]) = CREW_POD;
-	GLOBAL_SIS (CrewEnlisted) = CREW_POD_CAPACITY;
-	GLOBAL_SIS (ModuleSlots[8]) = STORAGE_BAY;
-	GLOBAL_SIS (ModuleSlots[1]) = FUEL_TANK;
-	GLOBAL_SIS (FuelOnBoard) = 10 * FUEL_TANK_SCALE;
+	GLOBAL_SIS (ModuleSlots[1]) = FUEL_TANK;*/
+	
+	GLOBAL_SIS (ModuleSlots[0]) = STORAGE_BAY; // BW: no storage if commented
+	GLOBAL_SIS (CrewEnlisted) = EXPLORER_CREW_CAPACITY;
+	GLOBAL_SIS (FuelOnBoard) = EXPLORER_FUEL_CAPACITY;
 
 	InitQueue (&GLOBAL (built_ship_q),
 			MAX_BUILT_SHIPS, sizeof (SHIP_FRAGMENT));
@@ -314,10 +348,29 @@ InitGameStructures (void)
 			sizeof (IP_GROUP));
 	InitQueue (&GLOBAL (encounter_q), MAX_ENCOUNTERS, sizeof (ENCOUNTER));
 
+	// DN 27FEB11 INITIALIZE BETA_NAOS FLAG 
+	SET_GAME_STATE (PLAYER_VISITED_BETA_NAOS, 0);
+	
+	// JMS: Starbase is available right from the start!
+	SET_GAME_STATE (STARBASE_AVAILABLE, 1);
+	// BW: Lander is fully shielded from the start
+	SET_GAME_STATE (LANDER_SHIELDS,
+			(1 << EARTHQUAKE_DISASTER) |
+			(1 << BIOLOGICAL_DISASTER) |
+			(1 << LIGHTNING_DISASTER) |
+			(1 << LAVASPOT_DISASTER));
+	
+	// JMS: Lander currently has "stronger" shot from the beginning. 
+	// Currently it does nothing else than enables killing the critters marked with INVULNERABLE_TO_BASIC_WEAPON.
+	SET_GAME_STATE (STRONGER_LANDER_SHOT, 1);
+	
+	SET_GAME_STATE (IMPROVED_LANDER_SHOT, 1);
+	SET_GAME_STATE (IMPROVED_LANDER_SPEED, 1);
+	
 	GLOBAL (CurrentActivity) = IN_INTERPLANETARY | START_INTERPLANETARY;
 
-	GLOBAL_SIS (ResUnits) = 0;
-	GLOBAL (CrewCost) = 3;
+	GLOBAL_SIS (ResUnits) = 6500;
+	GLOBAL (CrewCost) = 5;
 	GLOBAL (FuelCost) = 20;
 	GLOBAL (ModuleCost[PLANET_LANDER]) = 500 / MODULE_COST_SCALE;
 	GLOBAL (ModuleCost[FUSION_THRUSTER]) = 500 / MODULE_COST_SCALE;
@@ -336,14 +389,41 @@ InitGameStructures (void)
 			sizeof (GLOBAL_SIS (CommanderName)),
 			GAME_STRING (NAMING_STRING_BASE + 3));
 
+	// BW: all NAFS ships available but no ship allocated by default
+	// JMS: Except Utwig. They're all pacifists now!
+	ActivateStarShip (ZOQFOTPIK_SHIP, SET_ALLIED);
 	ActivateStarShip (HUMAN_SHIP, SET_ALLIED);
-	CloneShipFragment (HUMAN_SHIP, &GLOBAL (built_ship_q), 0);
-
-	GLOBAL_SIS (log_x) = UNIVERSE_TO_LOGX (SOL_X);
-	GLOBAL_SIS (log_y) = UNIVERSE_TO_LOGY (SOL_Y);
+	ActivateStarShip (SYREEN_SHIP, SET_ALLIED);
+	ActivateStarShip (YEHAT_SHIP, SET_ALLIED);
+	ActivateStarShip (SHOFIXTI_SHIP, SET_ALLIED);
+	ActivateStarShip (CHMMR_SHIP, SET_ALLIED);
+	ActivateStarShip (SUPOX_SHIP, SET_ALLIED);
+	// ActivateStarShip (UTWIG_SHIP, SET_ALLIED);
+	ActivateStarShip (ORZ_SHIP, SET_ALLIED);
+	//	CloneShipFragment (HUMAN_SHIP, &GLOBAL (built_ship_q), 0);
+	
+	// JMS: Show human and Chmmr SoIs right from the start
+	ActivateStarShip (CHMMR_SHIP, SPHERE_TRACKING);
+	ActivateStarShip (HUMAN_SHIP, SPHERE_TRACKING);
+	
+	// JMS: Show where other known races' home planets are, not the whole SoIs.
+	ActivateStarShip (ORZ_SHIP, SPHERE_INITIAL);
+	ActivateStarShip (SHOFIXTI_SHIP, SPHERE_INITIAL);
+	ActivateStarShip (SPATHI_SHIP, SPHERE_INITIAL);
+	ActivateStarShip (SYREEN_SHIP, SPHERE_INITIAL);
+	ActivateStarShip (VUX_SHIP, SPHERE_INITIAL);
+	ActivateStarShip (YEHAT_SHIP, SPHERE_INITIAL);
+
+	// JMS: Start at Procyon
+	GLOBAL_SIS (log_x) = UNIVERSE_TO_LOGX (PROCYON_X);
+	GLOBAL_SIS (log_y) = UNIVERSE_TO_LOGY (PROCYON_Y);
 	CurStarDescPtr = 0;
 	GLOBAL (autopilot.x) = ~0;
 	GLOBAL (autopilot.y) = ~0;
+	
+	// JMS: Vary the possible location of the ones that left in hurry
+	SET_GAME_STATE(HINT_WORLD_LOCATION, ((COUNT)TFB_Random () % 3));
+	log_add (log_Debug, "Hint world location randomly set to %d.", GET_GAME_STATE(HINT_WORLD_LOCATION));
 
 	/* In case the program is exited before the full game is terminated,
 	 * make sure that the temporary files are deleted.
@@ -410,6 +490,36 @@ UninitGameStructures (void)
 	initedGameStructs = FALSE;
 }
 
+
+// Name-based game state accessibility
+
+//ENHANCE: allocate map_entries more efficiently, not one for every single bit position
+
+struct map_entry
+{
+    char *stateName;
+    int statePos;
+    int stateLen;
+};
+
+static struct map_entry gameStateMap[NUM_GAME_STATE_BITS];
+
+static GHashTable *gameStateNameMap = NULL;
+
+void DumpAllGameStates(void)
+{
+    COUNT i;
+    for (i = 0; i < NUM_GAME_STATE_BITS; i++)
+    {
+        if (gameStateMap[i].stateName)
+        {
+            BYTE val = getGameState(i, i+gameStateMap[i].stateLen);
+            printf("%s = %d, ", gameStateMap[i].stateName, val);
+        }
+    }
+    printf("\n");
+}
+
 void
 InitGlobData (void)
 {
@@ -420,7 +530,50 @@ InitGlobData (void)
 	GLOBAL (glob_flags) = (BYTE)i;
 
 	GLOBAL (DisplayArray) = DisplayArray;
+    
+        /* This data is static, so really only needs to be initalised once. */
+    if (gameStateNameMap == NULL)
+    {
+        gameStateNameMap = g_hash_table_new(g_str_hash, g_str_equal);
+        
+        memset (&gameStateMap, 0, sizeof (gameStateMap));
+        
+        i = 0;
+#define ADD_GAME_STATE(name, len) \
+        gameStateMap[i].stateName = #name; \
+        gameStateMap[i].statePos = i; \
+        gameStateMap[i].stateLen = len; \
+        g_hash_table_insert(gameStateNameMap, gameStateMap[i].stateName, &gameStateMap[i]); \
+        i += len;
+#include "gamestate.inc"
+    
+    }
+}
+
+BYTE GetGameStateByName(const char *name)
+{
+    struct map_entry *e = g_hash_table_lookup(gameStateNameMap, name);
+    BYTE val;
+    
+    if (!e)
+    {
+        log_add (log_Warning, "Cannot retrieve unknown game state '%s'; assuming 0!", name);
+        return 0;
+    }
+    
+    val = getGameState(e->statePos, e->statePos + e->stateLen);
+    return val;
+}
+
+void SetGameStateByName(const char *name, BYTE val)
+{
+    struct map_entry *e = g_hash_table_lookup(gameStateNameMap, name);
+
+    if (!e)
+    {
+        log_add (log_Warning, "Cannot set unknown game state '%s' !", name);
+        return;
+    }
+    
+    setGameState(e->statePos, e->statePos + e->stateLen, val);
 }
-
-
-
diff -ruNp src.orig/uqm/globdata.h src/uqm/globdata.h
--- src.orig/uqm/globdata.h	2017-11-01 15:30:25 -0700
+++ src/uqm/globdata.h	2017-11-01 15:31:02 -0700
@@ -16,6 +16,20 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2009: -Added new game states for "new" race - humans
+//			 -Added IN_ORZSPACE flag for saved game summaries
+//			 -Added new game state for Vela factory visit
+// JMS 2010: -Added new game state for which ship is the flagship
+//			 -Added new device: Black orb
+//			 -Added new device: Temporal wrapper
+//			 -Increased max number of comm screen animations for one race from 20 to 30
+//			 -Added BLACK_ORB_STATE game state for handling the events upon finding the black orb.
+//			 -Added BLACK_ORB_CUTSCENE activity enum for initiating the cutscene
+//			 -Changed Animflags size from BYTE to COUNT (Possibility to add more flags later on.)
+//			 -Lots of new game states... see the bottom of the ADD_GAME_STATE list.			
+//
+// DN DEC10		-added game state flags for Melnorme Bio-Data easter egg
+
 #ifndef _GLOBDATA_H
 #define _GLOBDATA_H
 
@@ -28,6 +42,21 @@
 #include "commanim.h"
 
 
+#define MAX_FEATURE_OPTIONS 5
+
+typedef struct
+{
+	COUNT StartIndex;
+			// Index of the first possible image
+	BYTE NumFrames;
+			// Number of distinct possible images for the feature.
+
+	DWORD BlockMaskArray[MAX_FEATURE_OPTIONS];
+			// Array of the bit masks of indices of all
+			// animations that are incompatible with each
+			// option for this feature.
+} FEATURE_DESC;
+
 // general numbers-speech generator info
 // should accomodate most common base-10 languages
 // many languages require various plural forms
@@ -82,14 +111,55 @@ typedef struct
 	// 0-9, 10-19, ..20-90, ..100-900, etc.
 	SPEECH_DIGIT Digits[MAX_SPEECH_DIGITS];
 } NUMBER_SPEECH_DESC;
-typedef const NUMBER_SPEECH_DESC *NUMBER_SPEECH;
+typedef NUMBER_SPEECH_DESC *NUMBER_SPEECH;
 
 typedef DWORD LDAS_FLAGS;
 #define LDASF_NONE           ((LDAS_FLAGS)      0 )
 #define LDASF_USE_ALTERNATE  ((LDAS_FLAGS)(1 << 0))
 
+
+// BW: had to move that from commglue.h to here because now LOCDATA features it
+typedef enum {
+	ARILOU_CONVERSATION,
+	CHMMR_CONVERSATION,
+	COMMANDER_CONVERSATION,
+	ORZ_CONVERSATION,
+	PKUNK_CONVERSATION,
+	SHOFIXTI_CONVERSATION,
+	SPATHI_CONVERSATION,
+	SUPOX_CONVERSATION,
+	THRADD_CONVERSATION,
+	UTWIG_CONVERSATION,
+	VUX_CONVERSATION,
+	YEHAT_CONVERSATION,
+	MELNORME_CONVERSATION,
+	DRUUGE_CONVERSATION,
+	ILWRATH_CONVERSATION,
+	MYCON_CONVERSATION,
+	SLYLANDRO_CONVERSATION,
+	UMGAH_CONVERSATION,
+	URQUAN_CONVERSATION,
+	ZOQFOTPIK_CONVERSATION,
+	SYREEN_CONVERSATION,
+	BLACKURQ_CONVERSATION,
+	ANDROSYNTH_CONVERSATION,	// JMS
+	BAUL_CONVERSATION,			// JMS
+	FOONFOON_CONVERSATION,		// JMS
+	LURG_CONVERSATION,			// JMS
+	HUMAN_CONVERSATION,			// JMS
+	SLYLANDRO_HOME_CONVERSATION,
+	YEHAT_REBEL_CONVERSATION,
+	TRANSPORT_CONVERSATION,		// JMS
+	SYREENBASE_CONVERSATION,
+	SYREENHOME_CONVERSATION,
+	YEHATPKUNK_CONVERSATION,  // BW
+	SHOFIXTICOLONY_CONVERSATION,// JMS
+	INVALID_CONVERSATION,
+} CONVERSATION;
+
 typedef struct
 {
+	CONVERSATION AlienConv;
 	void (*init_encounter_func) (void);
 			/* Called when entering communications */
 	void (*post_encounter_func) (void);
@@ -130,22 +200,37 @@ typedef struct
 	MUSIC_REF AlienSong;
 	STRING ConversationPhrases;
 	
+	COUNT NumFeatures;
+	FEATURE_DESC AlienFeatureArray[MAX_ANIMATIONS];
+	COUNT AlienFeatureChoice[MAX_ANIMATIONS];
 } LOCDATA;
 
+typedef struct
+{
+        RESOURCE StarbaseFrameRes;
+	COUNT NumAnimations;
+	ANIMATION_DESC StarbaseAmbientArray[MAX_ANIMATIONS];
+
+	FRAME StarbaseFrame;
+	COLORMAP StarbaseColorMap;
+	
+} SBDATA;
+
+
 enum
 {
 	PORTAL_SPAWNER_DEVICE = 0,
 	TALKING_PET_DEVICE,
 	UTWIG_BOMB_DEVICE,
 	SUN_EFFICIENCY_DEVICE,
-	ROSY_SPHERE_DEVICE,
+	BLACK_ORB_DEVICE,	// JMS: Replaces ROSY_SPHERE_DEVICE
 	AQUA_HELIX_DEVICE,
-	CLEAR_SPINDLE_DEVICE,
+	SHIELD_BUSTER_DEVICE,	// JMS: Replaces CLEAR_SPINDLE_DEVICE
 	ULTRON_0_DEVICE,
 	ULTRON_1_DEVICE,
 	ULTRON_2_DEVICE,
 	ULTRON_3_DEVICE,
-	MAIDENS_DEVICE,
+	TEMPORAL_WRAPPER_DEVICE,	// JMS: Replaces MAIDENS_DEVICE
 	UMGAH_HYPERWAVE_DEVICE,
 	BURVIX_HYPERWAVE_DEVICE,
 	DATA_PLATE_1_DEVICE,
@@ -173,714 +258,35 @@ enum
 #define END_GAME_STATE NUM_GAME_STATE_BITS };
 
 START_GAME_STATE
-		/* Shofixti states */
-	ADD_GAME_STATE (SHOFIXTI_VISITS, 3)
-	ADD_GAME_STATE (SHOFIXTI_STACK1, 2)
-	ADD_GAME_STATE (SHOFIXTI_STACK2, 3)
-	ADD_GAME_STATE (SHOFIXTI_STACK3, 2)
-	ADD_GAME_STATE (SHOFIXTI_KIA, 1)
-	ADD_GAME_STATE (SHOFIXTI_BRO_KIA, 1)
-	ADD_GAME_STATE (SHOFIXTI_RECRUITED, 1)
-
-	ADD_GAME_STATE (SHOFIXTI_MAIDENS, 1) /* Did you find the babes yet? */
-	ADD_GAME_STATE (MAIDENS_ON_SHIP, 1)
-	ADD_GAME_STATE (BATTLE_SEGUE, 1)
-			/* Set to 0 in init_xxx_comm() if communications directly
-			 * follows an encounter.
-			 * Set to 1 in init_xxx_comm() if the player gets to decide
-			 * whether to attack or talk.
-			 * Set to 1 in communication when battle follows the
-			 * communication. It is still valid when uninit_xxx_comm() gets
-			 * called after combat or communication.
-			 */
-	ADD_GAME_STATE (PLANETARY_LANDING, 1)
-	ADD_GAME_STATE (PLANETARY_CHANGE, 1)
-			/* Flag set to 1 when the planet information for the current
-			 * world is changed since it was last saved to the starinfo.dat
-			 * file. Set when picking up bio, mineral, or energy nodes.
-			 * When there's no current world, it should be 0.
-			 */
-
-		/* Spathi states */
-	ADD_GAME_STATE (SPATHI_VISITS, 3)
-	ADD_GAME_STATE (SPATHI_HOME_VISITS, 3)
-	ADD_GAME_STATE (FOUND_PLUTO_SPATHI, 2)
-			/* 0 - Haven't met Fwiffo.
-			 * 1 - Met Fwiffo on Pluto, now talking to him.
-			 * 2 - Met Fwiffo on Pluto, after dialog.
-			 * 3 - Met Fwiffo, and have reported to the Safe Ones on
-			 *     the Spathi moon that he was either killed, or that
-			 *     you have him on board.
-			 */
-	ADD_GAME_STATE (SPATHI_SHIELDED_SELVES, 1)
-	ADD_GAME_STATE (SPATHI_CREATURES_EXAMINED, 1)
-	ADD_GAME_STATE (SPATHI_CREATURES_ELIMINATED, 1)
-	ADD_GAME_STATE (UMGAH_BROADCASTERS, 1)
-	ADD_GAME_STATE (SPATHI_MANNER, 2)
-	ADD_GAME_STATE (SPATHI_QUEST, 1)
-	ADD_GAME_STATE (LIED_ABOUT_CREATURES, 2)
-	ADD_GAME_STATE (SPATHI_PARTY, 1)
-	ADD_GAME_STATE (KNOW_SPATHI_PASSWORD, 1)
-
-	ADD_GAME_STATE (ILWRATH_HOME_VISITS, 3)
-	ADD_GAME_STATE (ILWRATH_CHMMR_VISITS, 1)
-
-	ADD_GAME_STATE (ARILOU_SPACE, 1)
-			/* 0 if the periodically opening QuasiSpace portal is
-			 * closed or closing.
-			 * 1 if the periodically opening QuasiSpace portal is
-			 * open or opening.
-			 */
-	ADD_GAME_STATE (ARILOU_SPACE_SIDE, 2)
-			/* 0 if in HyperSpace and not just emerged from the periodically
-			 * opening QuasiSpace portal.
-			 * 1 if in HyperSpace and just emerged from the periodically
-			 * QuasiSpace portal (still on the portal).
-			 * 2 if in QuasiSpace and just emerged from the periodically
-			 * opening portal (still on the portal).
-			 * 3 if in QuasiSpace and not just emerged from the
-			 * periodically opening portal.
-			 */
-	ADD_GAME_STATE (ARILOU_SPACE_COUNTER, 4)
-			/* Keeps track of how far the periodically opening QuasiSpace
-			 * portal is open. (This determines the image)
-			 * 0 <= ARILOU_SPACE_COUNTER <= 9
-			 * 0 means totally closed.
-			 * 9 means completely open.
-			 */
-
-	ADD_GAME_STATE (LANDER_SHIELDS, 4)
-
-	ADD_GAME_STATE (SHOFIXTI_GRPOFFS0, 8)
-	ADD_GAME_STATE (SHOFIXTI_GRPOFFS1, 8)
-	ADD_GAME_STATE (SHOFIXTI_GRPOFFS2, 8)
-	ADD_GAME_STATE (SHOFIXTI_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (ZOQFOT_GRPOFFS0, 8)
-	ADD_GAME_STATE (ZOQFOT_GRPOFFS1, 8)
-	ADD_GAME_STATE (ZOQFOT_GRPOFFS2, 8)
-	ADD_GAME_STATE (ZOQFOT_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (MELNORME0_GRPOFFS0, 8)
-	ADD_GAME_STATE (MELNORME0_GRPOFFS1, 8)
-	ADD_GAME_STATE (MELNORME0_GRPOFFS2, 8)
-	ADD_GAME_STATE (MELNORME0_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (MELNORME1_GRPOFFS0, 8)
-	ADD_GAME_STATE (MELNORME1_GRPOFFS1, 8)
-	ADD_GAME_STATE (MELNORME1_GRPOFFS2, 8)
-	ADD_GAME_STATE (MELNORME1_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (MELNORME2_GRPOFFS0, 8)
-	ADD_GAME_STATE (MELNORME2_GRPOFFS1, 8)
-	ADD_GAME_STATE (MELNORME2_GRPOFFS2, 8)
-	ADD_GAME_STATE (MELNORME2_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (MELNORME3_GRPOFFS0, 8)
-	ADD_GAME_STATE (MELNORME3_GRPOFFS1, 8)
-	ADD_GAME_STATE (MELNORME3_GRPOFFS2, 8)
-	ADD_GAME_STATE (MELNORME3_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (MELNORME4_GRPOFFS0, 8)
-	ADD_GAME_STATE (MELNORME4_GRPOFFS1, 8)
-	ADD_GAME_STATE (MELNORME4_GRPOFFS2, 8)
-	ADD_GAME_STATE (MELNORME4_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (MELNORME5_GRPOFFS0, 8)
-	ADD_GAME_STATE (MELNORME5_GRPOFFS1, 8)
-	ADD_GAME_STATE (MELNORME5_GRPOFFS2, 8)
-	ADD_GAME_STATE (MELNORME5_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (MELNORME6_GRPOFFS0, 8)
-	ADD_GAME_STATE (MELNORME6_GRPOFFS1, 8)
-	ADD_GAME_STATE (MELNORME6_GRPOFFS2, 8)
-	ADD_GAME_STATE (MELNORME6_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (MELNORME7_GRPOFFS0, 8)
-	ADD_GAME_STATE (MELNORME7_GRPOFFS1, 8)
-	ADD_GAME_STATE (MELNORME7_GRPOFFS2, 8)
-	ADD_GAME_STATE (MELNORME7_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (MELNORME8_GRPOFFS0, 8)
-	ADD_GAME_STATE (MELNORME8_GRPOFFS1, 8)
-	ADD_GAME_STATE (MELNORME8_GRPOFFS2, 8)
-	ADD_GAME_STATE (MELNORME8_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (MET_MELNORME, 1)
-	ADD_GAME_STATE (MELNORME_RESCUE_REFUSED, 1)
-	ADD_GAME_STATE (MELNORME_RESCUE_COUNT, 3)
-	ADD_GAME_STATE (TRADED_WITH_MELNORME, 1)
-	ADD_GAME_STATE (WHY_MELNORME_PURPLE, 1)
-	ADD_GAME_STATE (MELNORME_CREDIT0, 8)
-	ADD_GAME_STATE (MELNORME_CREDIT1, 8)
-	ADD_GAME_STATE (MELNORME_BUSINESS_COUNT, 2)
-	ADD_GAME_STATE (MELNORME_YACK_STACK0, 2)
-	ADD_GAME_STATE (MELNORME_YACK_STACK1, 2)
-	ADD_GAME_STATE (MELNORME_YACK_STACK2, 4)
-	ADD_GAME_STATE (MELNORME_YACK_STACK3, 3)
-	ADD_GAME_STATE (MELNORME_YACK_STACK4, 2)
-	ADD_GAME_STATE (WHY_MELNORME_BLUE, 1)
-	ADD_GAME_STATE (MELNORME_ANGER, 2)
-	ADD_GAME_STATE (MELNORME_MIFFED_COUNT, 2)
-	ADD_GAME_STATE (MELNORME_PISSED_COUNT, 2)
-	ADD_GAME_STATE (MELNORME_HATE_COUNT, 2)
-
-	ADD_GAME_STATE (URQUAN_PROBE_GRPOFFS0, 8)
-	ADD_GAME_STATE (URQUAN_PROBE_GRPOFFS1, 8)
-	ADD_GAME_STATE (URQUAN_PROBE_GRPOFFS2, 8)
-	ADD_GAME_STATE (URQUAN_PROBE_GRPOFFS3, 8)
-	ADD_GAME_STATE (PROBE_MESSAGE_DELIVERED, 1)
-	ADD_GAME_STATE (PROBE_ILWRATH_ENCOUNTER, 1)
-
-	ADD_GAME_STATE (STARBASE_AVAILABLE, 1)
-	ADD_GAME_STATE (STARBASE_VISITED, 1)
-	ADD_GAME_STATE (RADIOACTIVES_PROVIDED, 1)
-	ADD_GAME_STATE (LANDERS_LOST, 1)
-	ADD_GAME_STATE (GIVEN_FUEL_BEFORE, 1)
-
-	ADD_GAME_STATE (AWARE_OF_SAMATRA, 1)
-	ADD_GAME_STATE (YEHAT_CAVALRY_ARRIVED, 1)
-	ADD_GAME_STATE (URQUAN_MESSED_UP, 1)
-
-	ADD_GAME_STATE (MOONBASE_DESTROYED, 1)
-	ADD_GAME_STATE (WILL_DESTROY_BASE, 1)
-
-	ADD_GAME_STATE (ARTIFACT_2_ON_SHIP, 1)
-	ADD_GAME_STATE (ARTIFACT_3_ON_SHIP, 1)
-
-	ADD_GAME_STATE (KOHR_AH_KILLED_ALL, 1)
-
-	ADD_GAME_STATE (STARBASE_YACK_STACK1, 1)
-
-	ADD_GAME_STATE (DISCUSSED_PORTAL_SPAWNER, 1)
-	ADD_GAME_STATE (DISCUSSED_TALKING_PET, 1)
-	ADD_GAME_STATE (DISCUSSED_UTWIG_BOMB, 1)
-	ADD_GAME_STATE (DISCUSSED_SUN_EFFICIENCY, 1)
-	ADD_GAME_STATE (DISCUSSED_ROSY_SPHERE, 1)
-	ADD_GAME_STATE (DISCUSSED_AQUA_HELIX, 1)
-	ADD_GAME_STATE (DISCUSSED_CLEAR_SPINDLE, 1)
-	ADD_GAME_STATE (DISCUSSED_ULTRON, 1)
-	ADD_GAME_STATE (DISCUSSED_MAIDENS, 1)
-	ADD_GAME_STATE (DISCUSSED_UMGAH_HYPERWAVE, 1)
-	ADD_GAME_STATE (DISCUSSED_BURVIX_HYPERWAVE, 1)
-	ADD_GAME_STATE (SYREEN_WANT_PROOF, 1)
-	ADD_GAME_STATE (PLAYER_HAVING_SEX, 1)
-	ADD_GAME_STATE (MET_ARILOU, 1)
-	ADD_GAME_STATE (DISCUSSED_TAALO_PROTECTOR, 1)
-	ADD_GAME_STATE (DISCUSSED_EGG_CASING0, 1)
-	ADD_GAME_STATE (DISCUSSED_EGG_CASING1, 1)
-	ADD_GAME_STATE (DISCUSSED_EGG_CASING2, 1)
-	ADD_GAME_STATE (DISCUSSED_SYREEN_SHUTTLE, 1)
-	ADD_GAME_STATE (DISCUSSED_VUX_BEAST, 1)
-	ADD_GAME_STATE (DISCUSSED_DESTRUCT_CODE, 1)
-	ADD_GAME_STATE (DISCUSSED_URQUAN_WARP, 1)
-	ADD_GAME_STATE (DISCUSSED_ARTIFACT_2, 1)
-	ADD_GAME_STATE (DISCUSSED_ARTIFACT_3, 1)
-
-	ADD_GAME_STATE (ATTACKED_DRUUGE, 1)
-
-	ADD_GAME_STATE (NEW_ALLIANCE_NAME, 2)
-
-	ADD_GAME_STATE (PORTAL_COUNTER, 4)
-			/* Set to 1 when the player opens a QuasiSpace portal.
-			 * It will then be increased to 10, at which time
-			 * the portal is completely open. (This determines the image).
-			 */
-
-	ADD_GAME_STATE (BURVIXESE_BROADCASTERS, 1)
-	ADD_GAME_STATE (BURV_BROADCASTERS_ON_SHIP, 1)
-
-	ADD_GAME_STATE (UTWIG_BOMB, 1)
-	ADD_GAME_STATE (UTWIG_BOMB_ON_SHIP, 1)
-
-	ADD_GAME_STATE (AQUA_HELIX, 1)
-	ADD_GAME_STATE (AQUA_HELIX_ON_SHIP, 1)
-
-	ADD_GAME_STATE (SUN_DEVICE, 1)
-	ADD_GAME_STATE (SUN_DEVICE_ON_SHIP, 1)
-
-	ADD_GAME_STATE (TAALO_PROTECTOR, 1)
-	ADD_GAME_STATE (TAALO_PROTECTOR_ON_SHIP, 1)
-
-	ADD_GAME_STATE (SHIP_VAULT_UNLOCKED, 1)
-	ADD_GAME_STATE (SYREEN_SHUTTLE, 1)
-
-	ADD_GAME_STATE (PORTAL_KEY, 1)
-	ADD_GAME_STATE (PORTAL_KEY_ON_SHIP, 1)
-
-	ADD_GAME_STATE (VUX_BEAST, 1)
-	ADD_GAME_STATE (VUX_BEAST_ON_SHIP, 1)
-
-	ADD_GAME_STATE (TALKING_PET, 1)
-	ADD_GAME_STATE (TALKING_PET_ON_SHIP, 1)
-
-	ADD_GAME_STATE (MOONBASE_ON_SHIP, 1)
-
-	ADD_GAME_STATE (KOHR_AH_FRENZY, 1)
-	ADD_GAME_STATE (KOHR_AH_VISITS, 2)
-	ADD_GAME_STATE (KOHR_AH_BYES, 1)
-
-	ADD_GAME_STATE (SLYLANDRO_HOME_VISITS, 3)
-	ADD_GAME_STATE (DESTRUCT_CODE_ON_SHIP, 1)
-
-	ADD_GAME_STATE (ILWRATH_VISITS, 3)
-	ADD_GAME_STATE (ILWRATH_DECEIVED, 1)
-	ADD_GAME_STATE (FLAGSHIP_CLOAKED, 1)
-
-	ADD_GAME_STATE (MYCON_VISITS, 3)
-	ADD_GAME_STATE (MYCON_HOME_VISITS, 3)
-	ADD_GAME_STATE (MYCON_AMBUSH, 1)
-	ADD_GAME_STATE (MYCON_FELL_FOR_AMBUSH, 1)
-			/* Set to 1 when the Mycon have been told about Organon
-			 * and are moving towards it.
-			 */
-
-	ADD_GAME_STATE (GLOBAL_FLAGS_AND_DATA, 8)
-			/* This state seems to be used to distinguish between different
-			 * places where one may have an conversation with an alien.
-			 * Like home world, other world, space.
-			 * Why this needs 8 bits I don't know. Only specific
-			 * combinations of bits seem to be used (0, 1, or all bits).
-			 * A closer investigation is desirable. - SvdB
-			 * Bit 4 is set when initiating communication with the Ilwrath
-			 * 		homeworld by means of a HyperWave Broadcaster.
-			 * Bit 5 is set when initiating communication with an Ilwrath
-			 * 		ship by means of a HyperWave Broadcaster.
-			 * All bits are cleared when communication is over.
-			 */
-
-	ADD_GAME_STATE (ORZ_VISITS, 3)
-	ADD_GAME_STATE (TAALO_VISITS, 3)
-	ADD_GAME_STATE (ORZ_MANNER, 2)
-
-	ADD_GAME_STATE (PROBE_EXHIBITED_BUG, 1)
-	ADD_GAME_STATE (CLEAR_SPINDLE_ON_SHIP, 1)
-
-	ADD_GAME_STATE (URQUAN_VISITS, 3)
-	ADD_GAME_STATE (PLAYER_HYPNOTIZED, 1)
-
-	ADD_GAME_STATE (VUX_VISITS, 3)
-	ADD_GAME_STATE (VUX_HOME_VISITS, 3)
-	ADD_GAME_STATE (ZEX_VISITS, 3)
-	ADD_GAME_STATE (ZEX_IS_DEAD, 1)
-	ADD_GAME_STATE (KNOW_ZEX_WANTS_MONSTER, 1)
-
-	ADD_GAME_STATE (UTWIG_VISITS, 3)
-	ADD_GAME_STATE (UTWIG_HOME_VISITS, 3)
-	ADD_GAME_STATE (BOMB_VISITS, 3)
-	ADD_GAME_STATE (ULTRON_CONDITION, 3)
-			/* 0 if the Supox still have the Ultron
-			 * 1 if the Captain has the Ultron, completely broken
-			 * 2 if the Captain has the Ultron, with 1 fix
-			 * 3 if the Captain has the Ultron, with 2 fixes
-			 * 4 if the Captain has the Ultron, completely restored
-			 * 5 if the Ultron has been returned to the Utwig
-			 */
-	ADD_GAME_STATE (UTWIG_HAVE_ULTRON, 1)
-	ADD_GAME_STATE (BOMB_UNPROTECTED, 1)
-
-	ADD_GAME_STATE (TAALO_UNPROTECTED, 1)
-
-	ADD_GAME_STATE (TALKING_PET_VISITS, 3)
-	ADD_GAME_STATE (TALKING_PET_HOME_VISITS, 3)
-	ADD_GAME_STATE (UMGAH_ZOMBIE_BLOBBIES, 1)
-			/* The Umgah have come under the influence of the Talking Pet */
-	ADD_GAME_STATE (KNOW_UMGAH_ZOMBIES, 1)
-			/* The Captain is aware that something is up with the Umgah */
-
-	ADD_GAME_STATE (ARILOU_VISITS, 3)
-	ADD_GAME_STATE (ARILOU_HOME_VISITS, 3)
-	ADD_GAME_STATE (KNOW_ARILOU_WANT_WRECK, 1)
-	ADD_GAME_STATE (ARILOU_CHECKED_UMGAH, 2)
-	ADD_GAME_STATE (PORTAL_SPAWNER, 1)
-	ADD_GAME_STATE (PORTAL_SPAWNER_ON_SHIP, 1)
-
-	ADD_GAME_STATE (UMGAH_VISITS, 3)
-	ADD_GAME_STATE (UMGAH_HOME_VISITS, 3)
-	ADD_GAME_STATE (MET_NORMAL_UMGAH, 1)
-
-	ADD_GAME_STATE (SYREEN_HOME_VISITS, 3)
-	ADD_GAME_STATE (SYREEN_SHUTTLE_ON_SHIP, 1)
-	ADD_GAME_STATE (KNOW_SYREEN_VAULT, 1)
-
-	ADD_GAME_STATE (EGG_CASE0_ON_SHIP, 1)
-	ADD_GAME_STATE (SUN_DEVICE_UNGUARDED, 1)
-
-	ADD_GAME_STATE (ROSY_SPHERE_ON_SHIP, 1)
-			/* The Rosy Sphere is aboard the flagship, i.e. It has been
-			 * acquired from the Druuge, but not yet inserted in the broken
-			 * Ultron. cf. ROSY_SPHERE */
-
-	ADD_GAME_STATE (CHMMR_HOME_VISITS, 3)
-	ADD_GAME_STATE (CHMMR_EMERGING, 1)
-	ADD_GAME_STATE (CHMMR_UNLEASHED, 1)
-	ADD_GAME_STATE (CHMMR_BOMB_STATE, 2)
-			/* 0 - Nothing is known about the Precursor Bomb.
-			 * 1 - The captain knows from the Chmmr that some extremely
-			 *     powerful weapon is needed to destroy the Sa-Matra.
-			 * 2 - Installation of the precursor bomb has started.
-			 * 3 - Left the starbase after installation of the Precursor bomb.
-			 */
-
-	ADD_GAME_STATE (DRUUGE_DISCLAIMER, 1)
-
-	ADD_GAME_STATE (YEHAT_VISITS, 3)
-	ADD_GAME_STATE (YEHAT_REBEL_VISITS, 3)
-	ADD_GAME_STATE (YEHAT_HOME_VISITS, 3)
-	ADD_GAME_STATE (YEHAT_CIVIL_WAR, 1)
-	ADD_GAME_STATE (YEHAT_ABSORBED_PKUNK, 1)
-	ADD_GAME_STATE (YEHAT_SHIP_MONTH, 4)
-	ADD_GAME_STATE (YEHAT_SHIP_DAY, 5)
-	ADD_GAME_STATE (YEHAT_SHIP_YEAR, 5)
-
-	ADD_GAME_STATE (CLEAR_SPINDLE, 1)
-	ADD_GAME_STATE (PKUNK_VISITS, 3)
-	ADD_GAME_STATE (PKUNK_HOME_VISITS, 3)
-	ADD_GAME_STATE (PKUNK_SHIP_MONTH, 4)
-			/* The month in PKUNK_SHIP_YEAR that new ships are available
-			 * from the Pkunk. */
-	ADD_GAME_STATE (PKUNK_SHIP_DAY, 5)
-			/* The day of the month in PKUNK_SHIP_MONTH in PKUNK_SHIP_YEAR
-			 * that new ships are available. */
-	ADD_GAME_STATE (PKUNK_SHIP_YEAR, 5)
-			/* The year that new ships are available from the Pkunk
-			 * (stored as an offset from the year the game starts). */
-	ADD_GAME_STATE (PKUNK_MISSION, 3)
-
-	ADD_GAME_STATE (SUPOX_VISITS, 3)
-	ADD_GAME_STATE (SUPOX_HOME_VISITS, 3)
-
-	ADD_GAME_STATE (THRADD_VISITS, 3)
-	ADD_GAME_STATE (THRADD_HOME_VISITS, 3)
-	ADD_GAME_STATE (HELIX_VISITS, 3)
-	ADD_GAME_STATE (HELIX_UNPROTECTED, 1)
-	ADD_GAME_STATE (THRADD_CULTURE, 2)
-	ADD_GAME_STATE (THRADD_MISSION, 3)
-			/* 0 if the Thraddash fleet hasn't left the Thraddash home world.
-			 * 1 if the Thraddash are heading towards Kohr-Ah territory.
-			 * 2 if the Thraddash are fighting the Kohr-Ah.
-			 * 3 if the Thraddash are returning from Kohr-Ah territory.
-			 * 4 if the Thraddash fleet is back at the Thraddash home world.
-			 */
-
-	ADD_GAME_STATE (DRUUGE_VISITS, 3)
-	ADD_GAME_STATE (DRUUGE_HOME_VISITS, 3)
-	ADD_GAME_STATE (ROSY_SPHERE, 1)
-			/* The play has or has had the Rosy Sphere.
-			 * cf. ROSY_SHERE_ON_SHIP */
-	ADD_GAME_STATE (SCANNED_MAIDENS, 1)
-	ADD_GAME_STATE (SCANNED_FRAGMENTS, 1)
-	ADD_GAME_STATE (SCANNED_CASTER, 1)
-	ADD_GAME_STATE (SCANNED_SPAWNER, 1)
-	ADD_GAME_STATE (SCANNED_ULTRON, 1)
-
-	ADD_GAME_STATE (ZOQFOT_INFO, 2)
-	ADD_GAME_STATE (ZOQFOT_HOSTILE, 1)
-	ADD_GAME_STATE (ZOQFOT_HOME_VISITS, 3)
-	ADD_GAME_STATE (MET_ZOQFOT, 1)
-	ADD_GAME_STATE (ZOQFOT_DISTRESS, 2)
-			/* 0 if the Zoq-Fot-Pik aren't in distress
-			 * 1 if the Zoq-Fot-Pik are under attack by the Kohr-Ah
-			 * 2 if the Zoq-Fot-Pik have been destroyed because of this
-			 *   attack (not by the Kohr-Ah final victory cleansing)
-			 */
-
-	ADD_GAME_STATE (EGG_CASE1_ON_SHIP, 1)
-	ADD_GAME_STATE (EGG_CASE2_ON_SHIP, 1)
-	ADD_GAME_STATE (MYCON_SUN_VISITS, 3)
-	ADD_GAME_STATE (ORZ_HOME_VISITS, 3)
-
-	ADD_GAME_STATE (MELNORME_FUEL_PROCEDURE, 1)
-	ADD_GAME_STATE (MELNORME_TECH_PROCEDURE, 1)
-	ADD_GAME_STATE (MELNORME_INFO_PROCEDURE, 1)
-
-	ADD_GAME_STATE (MELNORME_TECH_STACK, 4)
-	ADD_GAME_STATE (MELNORME_EVENTS_INFO_STACK, 5)
-	ADD_GAME_STATE (MELNORME_ALIEN_INFO_STACK, 5)
-	ADD_GAME_STATE (MELNORME_HISTORY_INFO_STACK, 5)
-
-	ADD_GAME_STATE (RAINBOW_WORLD0, 8)
-			/* Low byte of a bit array, one bit per rainbow world.
-			 * Each bit is set if the rainbow world has been visited.
-			 * The lowest bit is for the first star in the star_array
-			 * with RAINBOW_DEFINED, and so on.
-			 */
-	ADD_GAME_STATE (RAINBOW_WORLD1, 2)
-			/* High 2 bits of the bit array of which RAINBOW_WORLD0
-			 * is the low byte.
-			 */
-	ADD_GAME_STATE (MELNORME_RAINBOW_COUNT, 4)
-			/* The number of rainbow world locations sold to the Melnorme. */
-
-	ADD_GAME_STATE (USED_BROADCASTER, 1)
-	ADD_GAME_STATE (BROADCASTER_RESPONSE, 1)
-
-	ADD_GAME_STATE (IMPROVED_LANDER_SPEED, 1)
-	ADD_GAME_STATE (IMPROVED_LANDER_CARGO, 1)
-	ADD_GAME_STATE (IMPROVED_LANDER_SHOT, 1)
-
-	ADD_GAME_STATE (MET_ORZ_BEFORE, 1)
-	ADD_GAME_STATE (YEHAT_REBEL_TOLD_PKUNK, 1)
-	ADD_GAME_STATE (PLAYER_HAD_SEX, 1)
-	ADD_GAME_STATE (UMGAH_BROADCASTERS_ON_SHIP, 1)
-
-	ADD_GAME_STATE (LIGHT_MINERAL_LOAD, 3)
-	ADD_GAME_STATE (MEDIUM_MINERAL_LOAD, 3)
-	ADD_GAME_STATE (HEAVY_MINERAL_LOAD, 3)
-
-	ADD_GAME_STATE (STARBASE_BULLETS0, 8)
-	ADD_GAME_STATE (STARBASE_BULLETS1, 8)
-	ADD_GAME_STATE (STARBASE_BULLETS2, 8)
-	ADD_GAME_STATE (STARBASE_BULLETS3, 8)
-
-	ADD_GAME_STATE (STARBASE_MONTH, 4)
-	ADD_GAME_STATE (STARBASE_DAY, 5)
-
-	ADD_GAME_STATE (CREW_SOLD_TO_DRUUGE0, 8)
-	ADD_GAME_STATE (CREW_PURCHASED0, 8)
-	ADD_GAME_STATE (CREW_PURCHASED1, 8)
-
-	ADD_GAME_STATE (URQUAN_PROTECTING_SAMATRA, 1)
-
-	ADD_GAME_STATE (COLONY_GRPOFFS0, 8)
-	ADD_GAME_STATE (COLONY_GRPOFFS1, 8)
-	ADD_GAME_STATE (COLONY_GRPOFFS2, 8)
-	ADD_GAME_STATE (COLONY_GRPOFFS3, 8)
+#include "gamestate.inc"
+END_GAME_STATE
+
+#undef ADD_GAME_STATE
 
+// See game state THRADDASH_BODY_COUNT
 #define THRADDASH_BODY_THRESHOLD 25
-	ADD_GAME_STATE (THRADDASH_BODY_COUNT, 5)
 
-	ADD_GAME_STATE (UTWIG_SUPOX_MISSION, 3)
-			/* 0 if the Utwig and Supox fleet haven't left their home world.
-			 * 1 if the U&S are on their way towards the Kohr-Ah
-			 * 2 if the U&S are fighting the Kohr-Ah (first 80 days)
-			 * 3 does not occur
-             * 4 if the U&S are fighting the Kohr-Ah (second 80 days)
-			 * 5 if the U&S are returning home.
-			 * 6 if the U&S are back at their home world.
-			 */
-	ADD_GAME_STATE (SPATHI_INFO, 3)
-
-	ADD_GAME_STATE (ILWRATH_INFO, 2)
-	ADD_GAME_STATE (ILWRATH_GODS_SPOKEN, 4)
-	ADD_GAME_STATE (ILWRATH_WORSHIP, 2)
-	ADD_GAME_STATE (ILWRATH_FIGHT_THRADDASH, 1)
-
-	ADD_GAME_STATE (SAMATRA_GRPOFFS0, 8)
-	ADD_GAME_STATE (SAMATRA_GRPOFFS1, 8)
-	ADD_GAME_STATE (SAMATRA_GRPOFFS2, 8)
-	ADD_GAME_STATE (SAMATRA_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (READY_TO_CONFUSE_URQUAN, 1)
-	ADD_GAME_STATE (URQUAN_HYPNO_VISITS, 1)
-	ADD_GAME_STATE (MENTIONED_PET_COMPULSION, 1)
-	ADD_GAME_STATE (URQUAN_INFO, 2)
-	ADD_GAME_STATE (KNOW_URQUAN_STORY, 2)
-
-	ADD_GAME_STATE (MYCON_INFO, 4)
-	ADD_GAME_STATE (MYCON_RAMBLE, 5)
-	ADD_GAME_STATE (KNOW_ABOUT_SHATTERED, 2)
-			/* 0 if the player doesn't known about shattered worlds
-			 * 1 if the player has encountered a shattered world
-			 * 2 if the player knows that shatterred worlds are caused
-			 *   by Mycon deep children.
-			 * 3 if the player has told the Syreen that Mycon Deep Children
-			 *   cause shattered worlds. Proof doesn't have to be presented
-			 *   yet at this time.
-			 */
-	ADD_GAME_STATE (MYCON_INSULTS, 3)
-	ADD_GAME_STATE (MYCON_KNOW_AMBUSH, 1)
-			/* Set to 1 when the Mycon have been butchered at Organon,
-			 * just before the remaining Mycon head back home.
-			 */
-
-	ADD_GAME_STATE (SYREEN_INFO, 2)
-	ADD_GAME_STATE (KNOW_SYREEN_WORLD_SHATTERED, 1)
-	ADD_GAME_STATE (SYREEN_KNOW_ABOUT_MYCON, 1)
-
-	ADD_GAME_STATE (TALKING_PET_INFO, 3)
-	ADD_GAME_STATE (TALKING_PET_SUGGESTIONS, 3)
-	ADD_GAME_STATE (LEARNED_TALKING_PET, 1)
-	ADD_GAME_STATE (DNYARRI_LIED, 1)
-			/* Set when the Talking Pet tells you his version of their
-			 * race's history with the Ur-Quan.
-			 * Cleared once you confront him about this lie.
-			 */
-	ADD_GAME_STATE (SHIP_TO_COMPEL, 1)
-
-	ADD_GAME_STATE (ORZ_GENERAL_INFO, 2)
-	ADD_GAME_STATE (ORZ_PERSONAL_INFO, 3)
-	ADD_GAME_STATE (ORZ_ANDRO_STATE, 2)
-	ADD_GAME_STATE (REFUSED_ORZ_ALLIANCE, 1)
-
-	ADD_GAME_STATE (PKUNK_MANNER, 2)
-			/* 0 not met the Pkunk
-			 * 1 fought the Pkunk, but relations are still salvagable.
-			 * 2 hostile relations with the Pkunk, no way back.
-			 * 3 friendly relations with the Pkunk
-			 */
-	ADD_GAME_STATE (PKUNK_ON_THE_MOVE, 1)
-	ADD_GAME_STATE (PKUNK_FLEET, 2)
-	ADD_GAME_STATE (PKUNK_MIGRATE, 2)
-	ADD_GAME_STATE (PKUNK_RETURN, 1)
-	ADD_GAME_STATE (PKUNK_WORRY, 2)
-	ADD_GAME_STATE (PKUNK_INFO, 3)
-	ADD_GAME_STATE (PKUNK_WAR, 2)
-	ADD_GAME_STATE (PKUNK_FORTUNE, 3)
-	ADD_GAME_STATE (PKUNK_MIGRATE_VISITS, 3)
-	ADD_GAME_STATE (PKUNK_REASONS, 4)
-	ADD_GAME_STATE (PKUNK_SWITCH, 1)
-	ADD_GAME_STATE (PKUNK_SENSE_VICTOR, 1)
-
-	ADD_GAME_STATE (KOHR_AH_REASONS, 2)
-	ADD_GAME_STATE (KOHR_AH_PLEAD, 2)
-	ADD_GAME_STATE (KOHR_AH_INFO, 2)
-	ADD_GAME_STATE (KNOW_KOHR_AH_STORY, 2)
-	ADD_GAME_STATE (KOHR_AH_SENSES_EVIL, 1)
-	ADD_GAME_STATE (URQUAN_SENSES_EVIL, 1)
-
-	ADD_GAME_STATE (SLYLANDRO_PROBE_VISITS, 3)
-	ADD_GAME_STATE (SLYLANDRO_PROBE_THREAT, 2)
-	ADD_GAME_STATE (SLYLANDRO_PROBE_WRONG, 2)
-	ADD_GAME_STATE (SLYLANDRO_PROBE_ID, 2)
-	ADD_GAME_STATE (SLYLANDRO_PROBE_INFO, 2)
-	ADD_GAME_STATE (SLYLANDRO_PROBE_EXIT, 2)
-
-	ADD_GAME_STATE (UMGAH_HOSTILE, 1)
-	ADD_GAME_STATE (UMGAH_EVIL_BLOBBIES, 1)
-	ADD_GAME_STATE (UMGAH_MENTIONED_TRICKS, 2)
-
-	ADD_GAME_STATE (BOMB_CARRIER, 1)
-			/* 0 when the flagship is not in battle, or it doesn't have the
-			 *   enhanced precursor bomb installed.
-			 * 1 when the flagship is in battle and the bomb is installed.
-			 * This determines whether you can flee (if the warp escape unit
-			 * is installed at all), and whether taking the ship into the
-			 * Sa-Matra defense structure will trigger the end of the game.
-			 */
-	
-	ADD_GAME_STATE (THRADD_MANNER, 1)
-	ADD_GAME_STATE (THRADD_INTRO, 2)
-	ADD_GAME_STATE (THRADD_DEMEANOR, 3)
-	ADD_GAME_STATE (THRADD_INFO, 2)
-	ADD_GAME_STATE (THRADD_BODY_LEVEL, 2)
-	ADD_GAME_STATE (THRADD_MISSION_VISITS, 1)
-	ADD_GAME_STATE (THRADD_STACK_1, 3)
-	ADD_GAME_STATE (THRADD_HOSTILE_STACK_2, 1)
-	ADD_GAME_STATE (THRADD_HOSTILE_STACK_3, 1)
-	ADD_GAME_STATE (THRADD_HOSTILE_STACK_4, 1)
-	ADD_GAME_STATE (THRADD_HOSTILE_STACK_5, 1)
-
-	ADD_GAME_STATE (CHMMR_STACK, 2)
-
-	ADD_GAME_STATE (ARILOU_MANNER, 2)
-	ADD_GAME_STATE (NO_PORTAL_VISITS, 1)
-	ADD_GAME_STATE (ARILOU_STACK_1, 2)
-	ADD_GAME_STATE (ARILOU_STACK_2, 1)
-	ADD_GAME_STATE (ARILOU_STACK_3, 2)
-	ADD_GAME_STATE (ARILOU_STACK_4, 1)
-	ADD_GAME_STATE (ARILOU_STACK_5, 2)
-	ADD_GAME_STATE (ARILOU_INFO, 2)
-	ADD_GAME_STATE (ARILOU_HINTS, 2)
-
-	ADD_GAME_STATE (DRUUGE_MANNER, 1)
-	ADD_GAME_STATE (DRUUGE_SPACE_INFO, 2)
-	ADD_GAME_STATE (DRUUGE_HOME_INFO, 2)
-	ADD_GAME_STATE (DRUUGE_SALVAGE, 1)
-	ADD_GAME_STATE (KNOW_DRUUGE_SLAVERS, 2)
-	ADD_GAME_STATE (FRAGMENTS_BOUGHT, 2)
-
-	ADD_GAME_STATE (ZEX_STACK_1, 2)
-	ADD_GAME_STATE (ZEX_STACK_2, 2)
-	ADD_GAME_STATE (ZEX_STACK_3, 2)
-
-	ADD_GAME_STATE (VUX_INFO, 2)
-	ADD_GAME_STATE (VUX_STACK_1, 4)
-	ADD_GAME_STATE (VUX_STACK_2, 2)
-	ADD_GAME_STATE (VUX_STACK_3, 2)
-	ADD_GAME_STATE (VUX_STACK_4, 2)
-
-	ADD_GAME_STATE (SHOFIXTI_STACK4, 2)
-
-	ADD_GAME_STATE (YEHAT_REBEL_INFO, 3)
-	ADD_GAME_STATE (YEHAT_ROYALIST_INFO, 1)
-	ADD_GAME_STATE (YEHAT_ROYALIST_TOLD_PKUNK, 1)
-	ADD_GAME_STATE (NO_YEHAT_ALLY_HOME, 1)
-	ADD_GAME_STATE (NO_YEHAT_HELP_HOME, 1)
-	ADD_GAME_STATE (NO_YEHAT_INFO, 1)
-	ADD_GAME_STATE (NO_YEHAT_ALLY_SPACE, 2)
-	ADD_GAME_STATE (NO_YEHAT_HELP_SPACE, 2)
-
-	ADD_GAME_STATE (ZOQFOT_KNOW_MASK, 4)
-
-	ADD_GAME_STATE (SUPOX_HOSTILE, 1)
-	ADD_GAME_STATE (SUPOX_INFO, 1)
-	ADD_GAME_STATE (SUPOX_WAR_NEWS, 2)
-	ADD_GAME_STATE (SUPOX_ULTRON_HELP, 1)
-	ADD_GAME_STATE (SUPOX_STACK1, 3)
-	ADD_GAME_STATE (SUPOX_STACK2, 2)
-
-	ADD_GAME_STATE (UTWIG_HOSTILE, 1)
-	ADD_GAME_STATE (UTWIG_INFO, 1)
-	ADD_GAME_STATE (UTWIG_WAR_NEWS, 2)
-	ADD_GAME_STATE (UTWIG_STACK1, 3)
-	ADD_GAME_STATE (UTWIG_STACK2, 2)
-	ADD_GAME_STATE (BOMB_INFO, 1)
-	ADD_GAME_STATE (BOMB_STACK1, 2)
-	ADD_GAME_STATE (BOMB_STACK2, 2)
-
-	ADD_GAME_STATE (SLYLANDRO_KNOW_BROKEN, 1)
-	ADD_GAME_STATE (PLAYER_KNOWS_PROBE, 1)
-	ADD_GAME_STATE (PLAYER_KNOWS_PROGRAM, 1)
-	ADD_GAME_STATE (PLAYER_KNOWS_EFFECTS, 1)
-	ADD_GAME_STATE (PLAYER_KNOWS_PRIORITY, 1)
-	ADD_GAME_STATE (SLYLANDRO_STACK1, 3)
-	ADD_GAME_STATE (SLYLANDRO_STACK2, 1)
-	ADD_GAME_STATE (SLYLANDRO_STACK3, 2)
-	ADD_GAME_STATE (SLYLANDRO_STACK4, 2)
-	ADD_GAME_STATE (SLYLANDRO_STACK5, 1)
-	ADD_GAME_STATE (SLYLANDRO_STACK6, 1)
-	ADD_GAME_STATE (SLYLANDRO_STACK7, 2)
-	ADD_GAME_STATE (SLYLANDRO_STACK8, 2)
-	ADD_GAME_STATE (SLYLANDRO_STACK9, 2)
-	ADD_GAME_STATE (SLYLANDRO_KNOW_EARTH, 1)
-	ADD_GAME_STATE (SLYLANDRO_KNOW_EXPLORE, 1)
-	ADD_GAME_STATE (SLYLANDRO_KNOW_GATHER, 1)
-	ADD_GAME_STATE (SLYLANDRO_KNOW_URQUAN, 2)
-	ADD_GAME_STATE (RECALL_VISITS, 2)
-
-	ADD_GAME_STATE (SLYLANDRO_MULTIPLIER, 3)
-	ADD_GAME_STATE (KNOW_SPATHI_QUEST, 1)
-	ADD_GAME_STATE (KNOW_SPATHI_EVIL, 1)
-
-	ADD_GAME_STATE (BATTLE_PLANET, 8)
-	ADD_GAME_STATE (ESCAPE_COUNTER, 8)
-
-	ADD_GAME_STATE (CREW_SOLD_TO_DRUUGE1, 8)
-	ADD_GAME_STATE (PKUNK_DONE_WAR, 1)
-
-	ADD_GAME_STATE (SYREEN_STACK0, 2)
-	ADD_GAME_STATE (SYREEN_STACK1, 2)
-	ADD_GAME_STATE (SYREEN_STACK2, 2)
-
-	ADD_GAME_STATE (REFUSED_ULTRON_AT_BOMB, 1)
-	ADD_GAME_STATE (NO_TRICK_AT_SUN, 1)
-
-	ADD_GAME_STATE (SPATHI_STACK0, 2)
-	ADD_GAME_STATE (SPATHI_STACK1, 1)
-	ADD_GAME_STATE (SPATHI_STACK2, 1)
+// See game state WHICH_SHIP_PLAYER_HAS
+#define CHMMR_EXPLORER_SHIP 0
+#define PRECURSOR_SERVICE_VEHICLE 1
+#define PRECURSOR_BATTLESHIP 2
+
+// Various defines to enable game-related features
+// These can control whether they are enabled; they also serve as useful words
+// to search for to find the related code.
+
+// Is Orz Space non-Euclidean?  (Slow near the bottom; autopilot follows geodesics.)
+#define ENABLE_NON_EUCLIDEAN_ORZ_SPACE 1
 
-	ADD_GAME_STATE (ORZ_STACK0, 1)
-	ADD_GAME_STATE (ORZ_STACK1, 1)
-END_GAME_STATE
 
 // Values for GAME_STATE.glob_flags:
-#define COMBAT_SPEED_SHIFT 6
+#define COMBAT_SPEED_SHIFT 7
 #define COMBAT_SPEED_MASK (((1 << 2) - 1) << COMBAT_SPEED_SHIFT)
 #define NUM_COMBAT_SPEEDS 4
 #define MUSIC_DISABLED (1 << 3)
 #define SOUND_DISABLED (1 << 4)
-#define CYBORG_ENABLED (1 << 5)
+#define VOICE_DISABLED (1 << 5)
+#define CYBORG_ENABLED (1 << 6)
 
 enum
 {
@@ -891,12 +297,16 @@ enum
 	IN_INTERPLANETARY,
 	WON_LAST_BATTLE,
 
-	/* The following three are only used when displaying save game
+	/* The following four are only used when displaying save game
 	 * summaries */
 	IN_QUASISPACE,
 	IN_PLANET_ORBIT,
 	IN_STARBASE,
-
+	IN_ORZSPACE,	// JMS: In *below* (Orz space) or not
+	
+	BLACK_ORB_CUTSCENE, // JMS: For initiating cutscene after finding the black orb
+//#define BLACK_ORB_CUTSCENE SUPER_MELEE
+	
 	CHECK_PAUSE = MAKE_WORD (0, (1 << 0)),
 	IN_BATTLE = MAKE_WORD (0, (1 << 1)),
 	START_ENCOUNTER = MAKE_WORD (0, (1 << 2)),
@@ -909,7 +319,7 @@ typedef UWORD ACTIVITY;
 
 typedef struct
 {
-	BYTE glob_flags;
+	UWORD glob_flags;
 			// See above for the meaning of the bits.
 
 	BYTE CrewCost, FuelCost;
@@ -922,6 +332,8 @@ typedef struct
 	CLOCK_STATE GameClock;
 
 	POINT autopilot;
+    DPOINT autopilotOrzSpaceCenter;
+    SDWORD autopilotOrzSpaceRadius;
 	POINT ip_location;
 	STAMP ShipStamp;
 	UWORD ShipFacing;
@@ -998,7 +410,12 @@ extern void setGameState32 (int startBit
 			setGameState32 ((SName), (val))
 #endif
 
-	
+
+/* Name-based game state accessors. */
+extern BYTE GetGameStateByName(const char *name);
+extern void SetGameStateByName(const char *name, BYTE val);
+
+
 extern CONTEXT RadarContext;
 
 extern void FreeSC2Data (void);
@@ -1009,5 +426,7 @@ extern void InitGlobData (void);
 extern BOOLEAN InitGameStructures (void);
 extern void UninitGameStructures (void);
 
+extern void DumpAllGameStates(void);
+
 #endif /* _GLOBDATA_H */
 
diff -ruNp src.orig/uqm/gravity.c src/uqm/gravity.c
--- src.orig/uqm/gravity.c	2017-11-01 15:30:25 -0700
+++ src/uqm/gravity.c	2017-11-01 15:31:02 -0700
@@ -30,8 +30,8 @@ CalculateGravity (ELEMENT *ElementPtr)
 	HELEMENT hTestElement, hSuccElement;
 
 	retval = FALSE;
-	HasGravity = (BOOLEAN)(CollidingElement (ElementPtr)
-			&& GRAVITY_MASS (ElementPtr->mass_points + 1));
+	HasGravity = (BOOLEAN)(CollidingElement (ElementPtr) && GRAVITY_MASS (ElementPtr->mass_points + 1));
+	
 	for (hTestElement = GetHeadElement ();
 			hTestElement != 0; hTestElement = hSuccElement)
 	{
@@ -41,8 +41,7 @@ CalculateGravity (ELEMENT *ElementPtr)
 		LockElement (hTestElement, &TestElementPtr);
 		if (TestElementPtr != ElementPtr
 				&& CollidingElement (TestElementPtr)
-				&& (TestHasGravity =
-				GRAVITY_MASS (TestElementPtr->mass_points + 1)) != HasGravity)
+				&& (TestHasGravity = GRAVITY_MASS (TestElementPtr->mass_points + 1)) != HasGravity)
 		{
 			COUNT abs_dx, abs_dy;
 			SIZE dx, dy;
@@ -96,7 +95,7 @@ CalculateGravity (ELEMENT *ElementPtr)
 #ifdef NEVER
 					COUNT magnitude;
 
-#define DIFUSE_GRAVITY 175
+#define DIFUSE_GRAVITY (175 << RESOLUTION_FACTOR) // JMS_GFX: Because of the ifdef NEVER this is actually never run. Well, changed it for consistency.
 					dist_squared += (DWORD)abs_dx * (DIFUSE_GRAVITY << 1)
 							+ (DWORD)abs_dy * (DIFUSE_GRAVITY << 1)
 							+ ((DWORD)(DIFUSE_GRAVITY * DIFUSE_GRAVITY) << 1);
@@ -104,7 +103,7 @@ CalculateGravity (ELEMENT *ElementPtr)
 							* GRAVITY_THRESHOLD) / dist_squared)) == 0)
 						magnitude = 1;
 
-#define MAX_MAGNITUDE 6
+#define MAX_MAGNITUDE (6 << RESOLUTION_FACTOR) // JMS_GFX: Because of the ifdef NEVER this is actually never run. Well, changed it for consistency.
 					else if (magnitude > MAX_MAGNITUDE)
 						magnitude = MAX_MAGNITUDE;
 					log_add (log_Debug, "magnitude = %u", magnitude);
@@ -126,8 +125,8 @@ CalculateGravity (ELEMENT *ElementPtr)
 
 						angle = ARCTAN (dx, dy);
 						DeltaVelocityComponents (&TestElementPtr->velocity,
-								COSINE (angle, WORLD_TO_VELOCITY (1)),
-								SINE (angle, WORLD_TO_VELOCITY (1)));
+								COSINE (angle, WORLD_TO_VELOCITY (1 << RESOLUTION_FACTOR)),
+								SINE (angle, WORLD_TO_VELOCITY (1 << RESOLUTION_FACTOR))); // JMS_GFX
 						if (TestElementPtr->state_flags & PLAYER_SHIP)
 						{
 							STARSHIP *StarShipPtr;
diff -ruNp src.orig/uqm/grpinfo.c src/uqm/grpinfo.c
--- src.orig/uqm/grpinfo.c	2017-11-01 15:30:25 -0700
+++ src/uqm/grpinfo.c	2017-11-01 15:31:02 -0700
@@ -16,6 +16,12 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2009: -Implemented changes to make 0 planet star systems work
+// JMS 2010: -Some systems now have a freight transport ship in interplanetary.
+//			 -Can't encounter Kohr-ahs before meeting slylandros riding kohr-ah vessels first at least once
+//			 -Changed the encounter probability calculation for Kohr-Ah and Slylandros riding Kohr-Ah vessels.
+//			 -Gave Lurg groups a homeworld
+
 #include "build.h"
 // XXX: for CurStarDescPtr and XXX_DEFINED constants
 #include "encount.h"
@@ -32,6 +38,8 @@
 #include <unistd.h>
 #endif
 
+#include "libs/log.h"
+
 static BYTE LastEncGroup;
 		// Last encountered group, saved into state files
 
@@ -254,11 +262,11 @@ BuildGroups (void)
 	BYTE HomeWorld[] =
 	{
 		0,                /* ARILOU_SHIP */
-		0,                /* CHMMR_SHIP */
-		0,                /* HUMAN_SHIP */
+		CHMMR_DEFINED,    /* CHMMR_SHIP */
+		SOL_DEFINED,	  /* JMS: HUMAN_SHIP */
 		ORZ_DEFINED,      /* ORZ_SHIP */
 		PKUNK_DEFINED,    /* PKUNK_SHIP */
-		0,                /* SHOFIXTI_SHIP */
+		SHOFIXTI_DEFINED, /* JMS: SHOFIXTI_SHIP */
 		SPATHI_DEFINED,   /* SPATHI_SHIP */
 		SUPOX_DEFINED,    /* SUPOX_SHIP */
 		THRADD_DEFINED,   /* THRADDASH_SHIP */
@@ -274,15 +282,29 @@ BuildGroups (void)
 		0,                /* URQUAN_SHIP */
 		ZOQFOT_DEFINED,   /* ZOQFOTPIK_SHIP */
 
-		0,                /* SYREEN_SHIP */
-		0,                /* BLACK_URQUAN_SHIP */
-		0,                /* YEHAT_REBEL_SHIP */
+		SYREEN_DEFINED,		/* SYREEN_SHIP */
+		0,					/* BLACK_URQUAN_SHIP */
+		0,					/* ANDROSYNTH_SHIP */
+
+		0,					/* CHENJESU_SHIP */
+		0,					/* MMRNMHRM_SHIP */
+		
+		0,					/* JMS: BAUL_SHIP */
+		0,					/* JMS: FOONFOON_SHIP */
+		LURG_SHIP,			/* JMS: LURG_SHIP */
+		0,					/* JMS: ISD_SHIP */
+		0,					/* JMS: SLYLANDRO_KOHRAH_SHIP */
+		0,					/* YEHAT_REBEL_SHIP */
 	};
 	BYTE EncounterPercent[] =
 	{
 		RACE_INTERPLANETARY_PERCENT
 	};
 
+	// JMS: Can't encounter Kohr-ahs before meeting slylandros riding kohr-ah vessels first at least once
+	if (GET_GAME_STATE(SLYLANDRO_KOHRAH_MET_TIMES)==0)
+		EncounterPercent[BLACK_URQUAN_SHIP] = 0;
+	
 	EncounterPercent[SLYLANDRO_SHIP] *= GET_GAME_STATE (SLYLANDRO_MULTIPLIER);
 	Index = GET_GAME_STATE (UTWIG_SUPOX_MISSION);
 	if (Index > 1 && Index < 5)
@@ -331,14 +353,15 @@ BuildGroups (void)
 			if (encounter_radius == INFINITE_RADIUS)
 				encounter_radius = (MAX_X_UNIVERSE + 1) << 1;
 			else
-				encounter_radius =
-						(encounter_radius * SPHERE_RADIUS_INCREMENT) >> 1;
+				encounter_radius = (encounter_radius * SPHERE_RADIUS_INCREMENT) >> 1;
+			
 			dx = universe.x - FleetPtr->loc.x;
 			if (dx < 0)
 				dx = -dx;
 			dy = universe.y - FleetPtr->loc.y;
 			if (dy < 0)
 				dy = -dy;
+			
 			if ((COUNT)dx < encounter_radius
 					&& (COUNT)dy < encounter_radius
 					&& (d_squared = (DWORD)dx * dx + (DWORD)dy * dy) <
@@ -348,8 +371,13 @@ BuildGroups (void)
 
 				// EncounterPercent is only used in practice for the Slylandro
 				// Probes, for the rest of races the chance of encounter is
-				// calced directly below from the distance to the Homeworld
-				if (FleetPtr->actual_strength != INFINITE_RADIUS)
+				// calced directly below from the distance to the Homeworld.
+				//
+				// JMS: Also Kohr-Ah ships and Slylandros riding Kohr-Ah vessels
+				// now have EncounterPercent as their probability.
+				if (FleetPtr->actual_strength != INFINITE_RADIUS
+					&& FleetPtr->SpeciesID != SLYLANDRO_KOHRAH_ID
+					&& FleetPtr->SpeciesID != KOHR_AH_ID)
 				{
 					i = 70 - (COUNT)((DWORD)square_root (d_squared)
 							* 60L / encounter_radius);
@@ -357,14 +385,14 @@ BuildGroups (void)
 
 				rand_val = TFB_Random ();
 				if ((int)(LOWORD (rand_val) % 100) < (int)i
-						&& (BestPercent == 0
-						|| (HIWORD (rand_val) % (i + BestPercent)) < i))
+						&& (BestPercent == 0 || (HIWORD (rand_val) % (i + BestPercent)) < i))
 				{
-					if (FleetPtr->actual_strength == INFINITE_RADIUS)
-					{	// The prevailing encounter chance is hereby limitted
-						// to 4% for races with infinite SoI (currently, it
-						// is only the Slylandro Probes)
-						i = 4;
+					if ((FleetPtr->SpeciesID == SLYLANDRO_KOHRAH_ID || FleetPtr->SpeciesID == KOHR_AH_ID)
+						&& CurStarDescPtr->Index != 0)
+					{	
+						// Races with INFINITE_RADIUS (Sly-kohr, Kohr-Ah) don't appear
+						// at special star systems, e.g. homeworlds.
+						i = 0;
 					}
 
 					BestPercent = i;
@@ -398,10 +426,20 @@ FoundHome:
 			for (Index = HINIBBLE (EncounterMakeup[BestIndex]); Index;
 					--Index)
 			{
-				if (Index <= LONIBBLE (EncounterMakeup[BestIndex])
-						|| (COUNT)TFB_Random () % 100 < 50)
-					CloneShipFragment (BestIndex,
-							&GLOBAL (npc_built_ship_q), 0);
+				if (Index <= LONIBBLE (EncounterMakeup[BestIndex]) || (COUNT)TFB_Random () % 100 < 50)
+				{
+					// JMS: Generate freight transport ship in specific systems.
+					if(which_group == 0 && (
+					     (CurStarDescPtr->Index==SOL_DEFINED && GET_GAME_STATE(TRANSPORT_SHIP_0_STATUS)<2 )
+					  || (CurStarDescPtr->Index==CHMMR_DEFINED && GET_GAME_STATE(TRANSPORT_SHIP_0_STATUS)>3 )
+					  //|| CurStarDescPtr->Index==SYREEN_DEFINED
+					  //|| CurStarDescPtr->Index==YEHAT_DEFINED			
+							)
+					   )
+						CloneShipFragment (TRANSPORT_SHIP, &GLOBAL (npc_built_ship_q), 0);
+					else
+						CloneShipFragment (BestIndex, &GLOBAL (npc_built_ship_q), 0);
+				}
 			}
 
 			PutGroupInfo (GROUPS_RANDOM, ++which_group);
@@ -556,14 +594,14 @@ GetGroupInfo (DWORD offset, BYTE which_g
 		fp = OpenStateFile (DEFGRPINFO_FILE, "r+b");
 	else
 		fp = OpenStateFile (RANDGRPINFO_FILE, "r+b");
-
+			
 	if (!fp)
-		return FALSE;
+			return FALSE;
 
 	SeekStateFile (fp, offset, SEEK_SET);
 	ReadGroupHeader (fp, &GH);
 #ifdef DEBUG_GROUPS
-	log_add (log_Debug, "GetGroupInfo(%lu): %u(%lu) out of %u", offset,
+	log_add (log_Debug, "******GetGroupInfo(%lu): %u(%lu) out of %u", offset,
 			which_group, GH.GroupOffset[which_group], GH.NumGroups);
 #endif /* DEBUG_GROUPS */
 
@@ -621,6 +659,7 @@ GetGroupInfo (DWORD offset, BYTE which_g
 			SeekStateFile (fp, GH.GroupOffset[which_group], SEEK_SET);
 			sread_8 (fp, &RaceType);
 			sread_8 (fp, &NumShips);
+
 			if (!NumShips)
 				continue; /* group is dead */
 
@@ -636,15 +675,28 @@ GetGroupInfo (DWORD offset, BYTE which_g
 			GroupPtr->orbit_pos = NORMALIZE_FACING (
 					LOBYTE (HIWORD (rand_val)));
 
-			group_loc = pSolarSysState->SunDesc[0].NumPlanets;
+			if (pSolarSysState->SunDesc[0].NumPlanets==0)			// JMS:
+				group_loc = 1;										// Originally
+			else													// Only
+				group_loc = pSolarSysState->SunDesc[0].NumPlanets;	// THIS line existed. Modified to enable 0 planet systems.
 			if (group_loc == 1 && task == EXPLORE)
 				task = IN_ORBIT;
 			else
 				group_loc = (BYTE)((HIBYTE (LOWORD (rand_val)) % group_loc) + 1);
 			GroupPtr->dest_loc = group_loc;
 			rand_val = TFB_Random ();
-			GroupPtr->loc.x = (LOWORD (rand_val) % 10000) - 5000;
-			GroupPtr->loc.y = (HIWORD (rand_val) % 10000) - 5000;
+			
+			if (pSolarSysState->SunDesc[0].NumPlanets==0)			// JMS:
+			{														// Modified to enable 0 planet star systems.
+				GroupPtr->loc.x = (LOWORD (rand_val) % 1000) + 5000;//
+				GroupPtr->loc.y = (HIWORD (rand_val) % 1000) + 5000;//
+			}														//
+			else													// Originally only lines within this else existed.
+			{														
+				GroupPtr->loc.x = (LOWORD (rand_val) % 10000) - 5000;
+				GroupPtr->loc.y = (HIWORD (rand_val) % 10000) - 5000;
+			}
+			
 			GroupPtr->group_counter = 0;
 			if (task == EXPLORE)
 			{
@@ -658,13 +710,61 @@ GetGroupInfo (DWORD offset, BYTE which_g
 
 				org = planetOuterLocation (group_loc - 1);
 				angle = FACING_TO_ANGLE (GroupPtr->orbit_pos + 1);
-				GroupPtr->loc.x = org.x + COSINE (angle, STATION_RADIUS);
-				GroupPtr->loc.y = org.y + SINE (angle, STATION_RADIUS);
+				
+				if (pSolarSysState->SunDesc[0].NumPlanets==0)			// JMS:
+				{														// Modified to enable 0 planet star systems.
+					XFormIPLoc (&pSolarSysState->SunDesc[0]				//
+								.image.origin, &org, FALSE);			//
+					GroupPtr->loc.x = (LOWORD (rand_val) % 1000)+1000;	//
+					GroupPtr->loc.y = (LOWORD (rand_val) % 1000)+1000;	//
+				}														//
+				else													// Originally only lines within this else existed.
+				{
+					GroupPtr->loc.x = org.x + COSINE (angle, STATION_RADIUS);
+					GroupPtr->loc.y = org.y + SINE (angle, STATION_RADIUS);
+				}
+				
 				group_loc = 0;
 			}
-
-			GroupPtr->task = task;
-			GroupPtr->sys_loc = group_loc;
+			
+			// JMS: Transport ship resides near starbase / home planet
+			if (GroupPtr->race_id==TRANSPORT_SHIP) {
+				
+				COUNT startposition;
+
+				// Transport ship is leaving system with status 1, otherwise it sits tight in planet orbit
+				if (GET_GAME_STATE(TRANSPORT_SHIP_0_STATUS) == 1) {
+					GroupPtr->task = FLEE | IGNORE_FLAGSHIP;
+				}
+				else
+					GroupPtr->task = IN_ORBIT | IGNORE_FLAGSHIP;
+				
+				startposition = 1;
+				if(CurStarDescPtr->Index==SOL_DEFINED)
+					startposition=3; /* orbitting earth */
+				if(CurStarDescPtr->Index==CHMMR_DEFINED)
+					startposition=2; /* orbitting Procyon II */
+				//if(CurStarDescPtr->Index==SYREEN_DEFINED)					
+				//	startposition=1; /* orbitting Betelgeuse I */
+				//if(CurStarDescPtr->Index==YEHAT_DEFINED)
+				//	startposition=1; /* orbitting Gamma Serpentis I */
+				
+				// JMS: Transport ship is arriving from hyperspace
+				if(GET_GAME_STATE(TRANSPORT_SHIP_0_STATUS) == 4)
+				{
+					GroupPtr->loc.x = 18000;
+					GroupPtr->loc.y = 6000;
+				}
+				else
+					GroupPtr->sys_loc = startposition;
+				
+				GroupPtr->dest_loc = startposition;
+			}
+			else
+			{
+				GroupPtr->task = task;
+				GroupPtr->sys_loc = group_loc;
+			}
 
 #ifdef DEBUG_GROUPS
 			log_add (log_Debug, "battle group %u(0x%04x) strength "
@@ -780,7 +880,7 @@ GetGroupInfo (DWORD offset, BYTE which_g
 	{
 		/* Read 'which_group' group into npc_built_ship_q */
 		BYTE NumShips;
-
+		
 		// XXX: Hack: The assumption here is that we only read the makeup
 		//   of a particular group when initializing an encounter, which
 		//   makes this group 'last encountered'. Also the state of all
diff -ruNp src.orig/uqm/grpinfo.h src/uqm/grpinfo.h
--- src.orig/uqm/grpinfo.h	2017-11-01 15:30:25 -0700
+++ src/uqm/grpinfo.h	2017-11-01 15:31:02 -0700
@@ -53,6 +53,10 @@ typedef struct
 	POINT loc;
 
 	FRAME melee_icon;
+	
+	// JMS: direction memory prevents jittering of battle group icons when they change direction they're flying to.
+	BYTE lastDirection;
+	
 } IP_GROUP;
 
 enum
diff -ruNp src.orig/uqm/hyper.c src/uqm/hyper.c
--- src.orig/uqm/hyper.c	2017-11-01 15:30:25 -0700
+++ src/uqm/hyper.c	2017-11-01 15:31:02 -0700
@@ -16,8 +16,20 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-#include "hyper.h"
+// JMS 2009: -ORZ space has its own colors
+//			 -Entering a star/npcship/portal in ORZ space (unhypertransition function)
+//			 -ORZ space check in allochyperelement. -> Do we draw a star or a hyperspace portal
+//			 -ORZ space checks to portal spawner shit
+//			 -ORZ space element graphics in AllocHyperElement
+//			 -Androsynth ship meeting percent in ORZ space in Checkhyperspaceencounter
+//			 -Can't meet melnorme/slylando in orz space, in Checkhyperspaceencounter
+//			 -Ship doesn't consume fuel in Orz space
+//
+// JMS 2010: -Helluva lot of things regarding Freight Transport ships in hyperspace.
+//
+//			 -Can't meet Kohr-ah ships before first meeting Slylandros riding Kohr-ah vessels
 
+#include "hyper.h"
 #include "build.h"
 #include "collide.h"
 #include "colors.h"
@@ -40,13 +52,19 @@
 #include "options.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/mathlib.h"
+#include "libs/log.h"
 
+#include "gameev.h"
 
 #define XOFFS ((RADAR_SCAN_WIDTH + (UNIT_SCREEN_WIDTH << 2)) >> 1)
 #define YOFFS ((RADAR_SCAN_HEIGHT + (UNIT_SCREEN_HEIGHT << 2)) >> 1)
 
-static FRAME hyperstars[3];
-static COLORMAP hypercmaps[2];
+static FRAME npcbubble; // BW: animated bubble
+//static FRAME hyperspacesuns; // BW: array of all the truespace suns needed
+static FRAME hyperholes[4];			// BW: One for each flavour of space
+// hyperholes[0] is never used for numbering consistency with hyperstars
+static FRAME hyperstars[4];			// JMS: Extra slot for ORZ space star gfx
+static COLORMAP hypercmaps[3];		// JMS: Extra slot for ORZ space color map
 static BYTE fuel_ticks;
 static COUNT hyper_dx, hyper_dy, hyper_extra;
 
@@ -64,9 +82,9 @@ enum HyperMenuItems
 
 
 void
-MoveSIS (SIZE *pdx, SIZE *pdy)
+MoveSIS (SDWORD *pdx, SDWORD *pdy)
 {
-	SIZE new_dx, new_dy;
+	SDWORD new_dx, new_dy;
 
 	new_dx = *pdx;
 	GLOBAL_SIS (log_x) -= new_dx;
@@ -121,7 +139,8 @@ MoveSIS (SIZE *pdx, SIZE *pdy)
 		}
 	}
 
-	if (GLOBAL_SIS (FuelOnBoard) && GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
+	if (GLOBAL_SIS (FuelOnBoard)
+			&& GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1 && GET_GAME_STATE (ORZ_SPACE_SIDE) <= 1) // JMS: Orz space check
 	{
 		COUNT cur_fuel_ticks;
 		COUNT hyper_dist;
@@ -195,10 +214,26 @@ check_hyperspace_encounter (void)
 			encounter_flags = 0;
 			percent = EncounterPercent[Type];
 			
+			// JMS: Exception: Can meet ORZ in ORZ space of course, Androsynth too...
+			if( (GET_GAME_STATE (ORZ_SPACE_SIDE) > 1 ) && (Type == ORZ_SHIP || Type == ANDROSYNTH_SHIP) )
+				encounter_radius = INFINITE_RADIUS;
+			
 			if (encounter_radius != INFINITE_RADIUS)
 			{
-				encounter_radius =
-						(encounter_radius * SPHERE_RADIUS_INCREMENT) >> 1;
+				// JMS: Can't encounter ships with non-infinite sphere of influence in ORZ space.
+				if( GET_GAME_STATE (ORZ_SPACE_SIDE) <= 1 )
+					encounter_radius = (encounter_radius * SPHERE_RADIUS_INCREMENT) >> 1;
+				else
+					encounter_radius = 0;
+				
+				// JMS: Can't meet Kohr-ahs ships before talking to Slylandros in kohr-ah ships first.
+				if (Type == BLACK_URQUAN_SHIP)
+				{
+					if(GET_GAME_STATE(SLYLANDRO_KOHRAH_MET_TIMES)>0)
+						encounter_radius = (encounter_radius * SPHERE_RADIUS_INCREMENT) >> 1;
+					else
+						encounter_radius = 0;
+				}
 			}
 			else /* encounter_radius == infinity */
 			{
@@ -208,15 +243,22 @@ check_hyperspace_encounter (void)
 				if (Type == SLYLANDRO_SHIP)
 				{
 					encounter_flags = ONE_SHOT_ENCOUNTER;
-					if (!GET_GAME_STATE (STARBASE_AVAILABLE))
-						percent = 100;
+					if(GET_GAME_STATE (ORZ_SPACE_SIDE) <= 1)  // JMS: ORZ space check
+					{
+						if (!GET_GAME_STATE (STARBASE_AVAILABLE))
+							percent = 100;
+						else
+							percent *= GET_GAME_STATE (SLYLANDRO_MULTIPLIER);
+					}
 					else
-						percent *= GET_GAME_STATE (SLYLANDRO_MULTIPLIER);
+						percent = 0;
 				}
+				
 				else if (Type == MELNORME_SHIP
 						&& (GLOBAL_SIS (FuelOnBoard) == 0
 						|| GET_GAME_STATE (USED_BROADCASTER))
-						&& GET_GAME_STATE (MELNORME_ANGER) < 3)
+						&& GET_GAME_STATE (MELNORME_ANGER) < 3
+						&& GET_GAME_STATE (ORZ_SPACE_SIDE) <= 1)  // JMS: ORZ space check
 				{
 					if (!GET_GAME_STATE (USED_BROADCASTER))
 						percent = 30;
@@ -224,6 +266,17 @@ check_hyperspace_encounter (void)
 						percent = 100;
 					encounter_flags = ONE_SHOT_ENCOUNTER;
 				}
+				
+				// JMS: If transport ship has left truespace and player is in hyperspace, transport ship appears there too.
+				if (Type == TRANSPORT_SHIP
+						 && GET_GAME_STATE (ORZ_SPACE_SIDE) <= 1
+						 && (GET_GAME_STATE (TRANSPORT_SHIP_0_STATUS)==2 
+							 || GET_GAME_STATE (USED_BUSTER) ))  // JMS: ORZ space check
+				{
+					percent = 100;
+					encounter_flags = ONE_SHOT_ENCOUNTER;
+					SET_GAME_STATE(TRANSPORT_SHIP_0_STATUS, 3);
+				}
 
 
 				for (hEncounter = GetHeadEncounter ();
@@ -268,8 +321,17 @@ check_hyperspace_encounter (void)
 					EncounterPtr->radius = encounter_radius;
 					EncounterPtr->SD.Index = encounter_flags;
 					EncounterPtr->SD.Type = Type;
+					
+					// JMS: Set source and destination for freight transport ship
+					if (Type == TRANSPORT_SHIP)
+					{
+						EncounterPtr->home_pt.x=6752;
+						EncounterPtr->home_pt.y=7450;
+						EncounterPtr->destination_pt.x=5742;
+						EncounterPtr->destination_pt.y=8268;
+					}
+					
 					UnlockEncounter (hEncounter);
-
 					PutEncounter (hEncounter);
 				}
 			}
@@ -284,22 +346,57 @@ check_hyperspace_encounter (void)
 void
 FreeHyperData (void)
 {
+	if (RESOLUTION_FACTOR > 0)
+	{
+		DestroyDrawable (ReleaseDrawable (hyperholes[1]));
+		hyperholes[1] = 0;
+		// BW: TODO left out for demo
+		// DestroyDrawable (ReleaseDrawable (hyperholes[1]));
+		// hyperholes[2] = 0;
+		// DestroyDrawable (ReleaseDrawable (hyperholes[2]));
+		// hyperholes[3] = 0;
+		// DestroyDrawable (ReleaseDrawable (hyperspacesuns));
+		// hyperspacesuns = 0;
+		DestroyDrawable (ReleaseDrawable (npcbubble));
+		npcbubble = 0;
+	}
+
 	DestroyDrawable (ReleaseDrawable (hyperstars[0]));
 	hyperstars[0] = 0;
 	DestroyDrawable (ReleaseDrawable (hyperstars[1]));
 	hyperstars[1] = 0;
 	DestroyDrawable (ReleaseDrawable (hyperstars[2]));
 	hyperstars[2] = 0;
+	DestroyDrawable (ReleaseDrawable (hyperstars[3])); // JMS: Release Orz space star and npcship gfx
+	hyperstars[3] = 0;
 
 	DestroyColorMap (ReleaseColorMap (hypercmaps[0]));
 	hypercmaps[0] = 0;
 	DestroyColorMap (ReleaseColorMap (hypercmaps[1]));
 	hypercmaps[1] = 0;
+	DestroyColorMap (ReleaseColorMap (hypercmaps[2])); // JMS: Release Orz space color map
+	hypercmaps[2] = 0;
 }
 
 static void
 LoadHyperData (void)
 {
+	if (RESOLUTION_FACTOR > 0)
+	{
+		if (hyperholes[1] == 0)
+		{
+			hyperholes[1] = CaptureDrawable (
+					LoadGraphic (HYPERHOLES_MASK_PMAP_ANIM));
+			// BW: TODO left out for demo
+			// hyperholes[2] = CaptureDrawable (
+			// 		LoadGraphic (ARIHOLES_MASK_PMAP_ANIM));
+			// hyperstars[3] = CaptureDrawable (
+			// 		LoadGraphic (ORZHOLES_MASK_PMAP_ANIM));
+		}
+		//	hyperspacesuns = CaptureDrawable (LoadGraphic (HYPERSUNS_MASK_PMAP_ANIM));
+		npcbubble = CaptureDrawable (LoadGraphic (NPCBUBBLE_MASK_PMAP_ANIM));
+	}
+
 	if (hyperstars[0] == 0)
 	{
 		hyperstars[0] = CaptureDrawable (
@@ -311,6 +408,9 @@ LoadHyperData (void)
 		hyperstars[2] = CaptureDrawable (
 				LoadGraphic (ARISPACE_MASK_PMAP_ANIM));
 		hypercmaps[1] = CaptureColorMap (LoadColorMap (ARISPACE_COLOR_TAB));
+		hyperstars[3] = CaptureDrawable (
+				LoadGraphic (ORZSPACE_MASK_PMAP_ANIM));							// JMS: Read Orz space star and npcship gfx
+		hypercmaps[2] = CaptureColorMap (LoadColorMap (ORZSPACE_COLOR_TAB));	// JMS: Read Orz space color map
 	}
 }
 
@@ -351,18 +451,29 @@ LoadHyperspace (void)
 	DrawSISMessage (NULL);
 
 	SetContext (RadarContext);
-	SetContextBackGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x00, 0x0E, 0x00), 0x6C));
+	if (GET_GAME_STATE (ORZ_SPACE_SIDE) > 1)		// JMS: In ORZ space, radar has its own colors
+		SetContextBackGroundColor (					// Radar foreground (grid) color defined in DrawHyperGrid
+				BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x0E), 0x6C));
+	else
+		SetContextBackGroundColor (
+				BUILD_COLOR (MAKE_RGB15 (0x00, 0x0E, 0x00), 0x6C));
 
 	SetContext (SpaceContext);
-	if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
+	if (GET_GAME_STATE (ORZ_SPACE_SIDE) > 1 && GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
+	{// JMS: To Orzspace. ORZ space has its own colors
+		SetContextBackGroundColor (BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x13), 0x2F));
+		SetColorMap (GetColorMapAddress (hypercmaps[2]));
+	}
+	else if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
 	{
+		// To hyperspace
 		SetContextBackGroundColor (
 				BUILD_COLOR (MAKE_RGB15 (0x07, 0x00, 0x00), 0x2F));
 		SetColorMap (GetColorMapAddress (hypercmaps[0]));
 	}
 	else
 	{
+		// To Quasispace
 		SetContextBackGroundColor (
 				BUILD_COLOR (MAKE_RGB15 (0x00, 0x1A, 0x00), 0x2F));
 		SetColorMap (GetColorMapAddress (hypercmaps[1]));
@@ -416,6 +527,7 @@ cleanup_hyperspace (void)
 
 		LockEncounter (hEncounter, &EncounterPtr);
 		hNextEncounter = GetSuccEncounter (EncounterPtr);
+		
 		if (EncounterPtr->hElement)
 		{
 			ELEMENT *ElementPtr;
@@ -432,6 +544,7 @@ cleanup_hyperspace (void)
 
 			UnlockElement (EncounterPtr->hElement);
 		}
+		
 		EncounterPtr->hElement = 0;
 		UnlockEncounter (hEncounter);
 	}
@@ -451,6 +564,39 @@ InterplanetaryTransition (ELEMENT *Eleme
 	GLOBAL (in_orbit) = 0;
 	GLOBAL (ShipFacing) = 0; /* Not reentering the system */
 	SET_GAME_STATE (USED_BROADCASTER, 0);
+	// JMS: Entering star or portal in ORZ space
+	if (GET_GAME_STATE (ORZ_SPACE_SIDE) > 1)
+	{
+		POINT orz_pt;
+		COUNT orz_index;
+
+		POINT orz_portal_pt[] =
+		{
+			{8654, 8587}, // Exit from Orz space brings ship to these hyperspace coordinates.
+		};
+
+		GLOBAL (autopilot.x) = ~0;
+		GLOBAL (autopilot.y) = ~0;
+
+		ElementToUniverse (ElementPtr, &orz_pt);
+		CurStarDescPtr = FindStar (NULL, &orz_pt, 5, 5);
+
+		orz_index = CurStarDescPtr
+			- &star_array[NUM_SOLAR_SYSTEMS + 15 + 2 +1]; // JMS: Number of solar systems + 1 + number of vortices + 1  
+		GLOBAL_SIS (log_x) =							  // + arilou home world
+			UNIVERSE_TO_LOGX (orz_portal_pt[orz_index].x);
+		GLOBAL_SIS (log_y) =
+			UNIVERSE_TO_LOGY (orz_portal_pt[orz_index].y);
+
+		GLOBAL (CurrentActivity) |= START_INTERPLANETARY;  // JMS: Returns inside portal star system interplanetary
+		SET_GAME_STATE (ESCAPE_COUNTER, 0);			
+		SET_GAME_STATE (LEAVING_ORZ_SPACE, 1);			// JMS: Added this so returning to interplanetary instead of hyperspace works.
+		// (Check ExploreSolarSys  in solarsys.c for more info)
+		SET_GAME_STATE (ORZ_SPACE_SIDE, 0);
+		SET_GAME_STATE (ARILOU_SPACE_SIDE, 0);
+
+	} // JMS ENDS
+
 	if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
 	{
 		// Enter a solar system from HyperSpace.
@@ -465,7 +611,7 @@ InterplanetaryTransition (ELEMENT *Eleme
 		GLOBAL (autopilot.y) = ~0;
 
 		ElementToUniverse (ElementPtr, &pt);
-		CurStarDescPtr = FindStar (NULL, &pt, 5, 5);
+		CurStarDescPtr = FindStar (NULL, &pt, 5,5); // JMS_GFX
 		if (CurStarDescPtr->star_pt.x == ARILOU_HOME_X
 				&& CurStarDescPtr->star_pt.y == ARILOU_HOME_Y)
 		{
@@ -500,18 +646,20 @@ ArilouSpaceTransition (void)
 	GLOBAL (autopilot.y) = ~0;
 	if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
 	{
-		// From HyperSpace to QuasiSpace.
+		// From Orz space or HyperSpace to QuasiSpace.
 		GLOBAL_SIS (log_x) = UNIVERSE_TO_LOGX (QUASI_SPACE_X);
 		GLOBAL_SIS (log_y) = UNIVERSE_TO_LOGY (QUASI_SPACE_Y);
 		if (GET_GAME_STATE (PORTAL_COUNTER) == 0)
 		{
 			// Periodically appearing portal.
+			SET_GAME_STATE (ORZ_SPACE_SIDE, 0);		// JMS: Don't think this is necessary, but won't hurt either.
 			SET_GAME_STATE (ARILOU_SPACE_SIDE, 3);
 		}
 		else
 		{
 			// Player-induced portal.
 			SET_GAME_STATE (PORTAL_COUNTER, 0);
+			SET_GAME_STATE (ORZ_SPACE_SIDE, 0);		// JMS: Well, this is necessary.
 			SET_GAME_STATE (ARILOU_SPACE_SIDE, 3);
 		}
 	}
@@ -522,6 +670,7 @@ ArilouSpaceTransition (void)
 		GLOBAL_SIS (log_x) = UNIVERSE_TO_LOGX (ARILOU_SPACE_X);
 		GLOBAL_SIS (log_y) = UNIVERSE_TO_LOGY (ARILOU_SPACE_Y);
 		SET_GAME_STATE (ARILOU_SPACE_SIDE, 0);
+		SET_GAME_STATE (ORZ_SPACE_SIDE, 0);		// JMS: Don't think this is necessary, but won't hurt either.
 	}
 }
 
@@ -687,6 +836,21 @@ hyper_collision (ELEMENT *ElementPtr0, P
 			CurStarDescPtr = SDPtr;
 			ElementPtr0->state_flags |= DEFY_PHYSICS | COLLISION;
 		}
+		else if (SDPtr->Index == MELNORME_HOME_DEFINED)
+		{
+			//TODO If the player has the "Deflection nullifier device", they can enter the Melnorme home world.
+			SIZE dx, dy;
+
+			dx = WORLD_TO_VELOCITY (ElementPtr0->next.location.x
+					- ElementPtr1->next.location.x);
+			dy = WORLD_TO_VELOCITY (ElementPtr0->next.location.y
+					- ElementPtr1->next.location.y);
+
+			//Deflect at angle -- probably need to do more trig here...
+			DeltaVelocityComponents (&ElementPtr1->velocity,
+					-dy/4, -dx/4);
+			ElementPtr0->state_flags |= DEFY_PHYSICS;
+		}
 		else if ((GLOBAL (CurrentActivity) & IN_BATTLE)
 				&& (GLOBAL (autopilot.x) == ~0
 				|| GLOBAL (autopilot.y) == ~0
@@ -789,7 +953,13 @@ AllocHyperElement (STAR_DESC *SDPtr)
 				STAMP_PRIM);
 		HyperSpaceElementPtr->current.image.farray =
 				&hyperstars[1 + (GET_GAME_STATE (ARILOU_SPACE_SIDE) >> 1)];
-
+		
+		if( GET_GAME_STATE (ORZ_SPACE_SIDE) > 1) // JMS: Load ORZ space style graphics for stars and npcships
+		{
+			HyperSpaceElementPtr->current.image.farray =
+			&hyperstars[3];
+		}
+		
 		UnlockElement (hHyperSpaceElement);
 	}
 
@@ -817,9 +987,8 @@ AddAmbientElement (void)
 		HyperSpaceElementPtr->preprocess_func = animation_preprocess;
 
 		rand_val = TFB_Random ();
-		dy = LOWORD (rand_val);
-		dx = (SIZE)(LOBYTE (dy) % SPACE_WIDTH) - (SPACE_WIDTH >> 1);
-		dy = (SIZE)(HIBYTE (dy) % SPACE_HEIGHT) - (SPACE_HEIGHT >> 1);
+		dx = (SIZE)(LOWORD (rand_val) % SPACE_WIDTH) - (SPACE_WIDTH >> 1);
+		dy = (SIZE)(HIWORD (rand_val) % SPACE_HEIGHT) - (SPACE_HEIGHT >> 1);
 		HyperSpaceElementPtr->current.location.x = (LOG_SPACE_WIDTH >> 1)
 				+ DISPLAY_TO_WORLD (dx);
 		HyperSpaceElementPtr->current.location.y = (LOG_SPACE_HEIGHT >> 1)
@@ -871,7 +1040,17 @@ encounter_transition (ELEMENT *ElementPt
 			if (f != ElementPtr->current.image.farray[0])
 				ElementPtr->next.image.frame = f;
 			else
+			{
 				ElementPtr->death_func = NULL;
+				// BW: the bubble has reached full size so we start animation
+				if (RESOLUTION_FACTOR > 0)
+				{
+					ElementPtr->current.image.farray = &npcbubble;
+					ElementPtr->next.image.farray = &npcbubble;
+					ElementPtr->current.image.frame = SetAbsFrameIndex(npcbubble, 0);
+					ElementPtr->next.image.frame = SetAbsFrameIndex(npcbubble, 0);
+				}			
+			}
 		}
 
 		ElementPtr->turn_wait = VORTEX_WAIT;
@@ -915,7 +1094,7 @@ encounter_collision (ELEMENT *ElementPtr
 	if (!(ElementPtr1->state_flags & PLAYER_SHIP)
 			|| !(GLOBAL (CurrentActivity) & IN_BATTLE))
 		return;
-
+		
 	init_transition (ElementPtr0, ElementPtr1, RANDOM_ENCOUNTER_TRANSITION);
 
 	for (hEncounter = GetHeadEncounter ();
@@ -952,14 +1131,20 @@ AddEncounterElement (ENCOUNTER *Encounte
 	BOOLEAN NewEncounter;
 	HELEMENT hElement;
 	STAR_DESC SD;
-	
+
 	if (GET_GAME_STATE (ARILOU_SPACE_SIDE) >= 2)
 		return 0;
-
+	
 	if (EncounterPtr->SD.Index & ENCOUNTER_REFORMING)
 	{
+		// JMS: This condition makes it so that Sly-kohrs don't reappear in HS after escaping.
+		if(EncounterPtr->SD.Type == SLYLANDRO_KOHRAH_SHIP)
+		{
+			EncounterPtr->SD.Index &= ~ENCOUNTER_REFORMING;
+			return 0;
+		}
+		
 		EncounterPtr->SD.Index &= ~ENCOUNTER_REFORMING;
-
 		EncounterPtr->transition_state = 100;
 		if ((EncounterPtr->SD.Index & ONE_SHOT_ENCOUNTER)
 				|| LONIBBLE (EncounterPtr->SD.Index) == 0)
@@ -1032,11 +1217,18 @@ AddEncounterElement (ENCOUNTER *Encounte
 			if (SD.star_pt.y < 0)
 				SD.star_pt.y = 0;
 			else if (SD.star_pt.y > MAX_Y_UNIVERSE)
-				SD.star_pt.y = MAX_Y_UNIVERSE;
+					SD.star_pt.y = MAX_Y_UNIVERSE;
 
 			dx = SD.star_pt.x - EncounterPtr->origin.x;
 			dy = SD.star_pt.y - EncounterPtr->origin.y;
 		} while ((DWORD)((long)dx * dx + (long)dy * dy) > radius_squared);
+		
+		// JMS: Spawn Transport ship always at its home system's location in hyperspace.
+		if(EncounterPtr->SD.Type == TRANSPORT_SHIP)
+		{
+			SD.star_pt.x=EncounterPtr->home_pt.x;
+			SD.star_pt.y=EncounterPtr->home_pt.y;
+		}
 
 		EncounterPtr->SD.star_pt = SD.star_pt;
 		EncounterPtr->log_x = UNIVERSE_TO_LOGX (SD.star_pt.x);
@@ -1044,6 +1236,7 @@ AddEncounterElement (ENCOUNTER *Encounte
 	}
 
 	hElement = AllocHyperElement (&SD);
+	
 	if (hElement)
 	{
 		SIZE i;
@@ -1051,8 +1244,9 @@ AddEncounterElement (ENCOUNTER *Encounte
 
 		LockElement (hElement, &ElementPtr);
 		
-		i = EncounterPtr->transition_state;
-		if (i || NewEncounter)
+		// JMS: Force Orz fingers in Orz space to use other than normal npcship graphics.
+		if (((i = EncounterPtr->transition_state) || NewEncounter) 
+			&& !( (GET_GAME_STATE (ORZ_SPACE_SIDE) > 1) && (EncounterPtr->SD.Type== ORZ_SHIP) ) )
 		{
 			if (i < 0)
 			{
@@ -1062,14 +1256,31 @@ AddEncounterElement (ENCOUNTER *Encounte
 			if (i == 0 || i > NUM_VORTEX_TRANSITIONS)
 				i = NUM_VORTEX_TRANSITIONS;
 
-			ElementPtr->current.image.frame = SetRelFrameIndex (
-					ElementPtr->current.image.farray[0], -i);
+			ElementPtr->current.image.frame = SetRelFrameIndex (ElementPtr->current.image.farray[0], -i);
 			ElementPtr->death_func = encounter_transition;
 		}
 		else
 		{
-			ElementPtr->current.image.frame =
-					DecFrameIndex (ElementPtr->current.image.farray[0]);
+			// JMS: Orz fingers use the big black hole gfx. But now there's no animation for the
+			// "birth" of the finger!
+			if ( (GET_GAME_STATE (ORZ_SPACE_SIDE) > 1) && (EncounterPtr->SD.Type== ORZ_SHIP) )
+			{
+				ElementPtr->current.image.frame = SetAbsFrameIndex (hyperstars[3],5);
+			}
+			else
+			{
+				if (RESOLUTION_FACTOR > 0)
+				{
+					ElementPtr->current.image.farray = &npcbubble;
+					ElementPtr->next.image.farray = &npcbubble;
+					ElementPtr->current.image.frame = SetAbsFrameIndex(npcbubble, 0);
+					ElementPtr->next.image.frame = SetAbsFrameIndex(npcbubble, 0);
+				}
+				else
+				{
+					ElementPtr->current.image.frame = DecFrameIndex (ElementPtr->current.image.farray[0]);
+				}
+			}
 		}
 
 		ElementPtr->turn_wait = VORTEX_WAIT;
@@ -1102,8 +1313,12 @@ DrawHyperGrid (COORD ux, COORD uy, COORD
 	RECT r;
 
 	ClearDrawable ();
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x00, 0x10, 0x00), 0x6B));
+	if (GET_GAME_STATE (ORZ_SPACE_SIDE) > 1)	// JMS: Different color radar for Orz space just for the heck of it.
+		SetContextForeGroundColor (
+					BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x10), 0x6B));
+	else
+		SetContextForeGroundColor (
+					BUILD_COLOR (MAKE_RGB15 (0x00, 0x10, 0x00), 0x6B));
 
 	sx = ux - (RADAR_SCAN_WIDTH >> 1);
 	if (sx  < 0)
@@ -1146,7 +1361,7 @@ DrawHyperGrid (COORD ux, COORD uy, COORD
 	}
 }
 
-// Returns false iff the encounter is to be removed.
+// Returns false if the encounter is to be removed.
 static bool
 ProcessEncounter (ENCOUNTER *EncounterPtr, POINT *puniverse,
 		COORD ox, COORD oy, STAMP *stamp)
@@ -1184,6 +1399,9 @@ ProcessEncounter (ENCOUNTER *EncounterPt
 		SIZE delta_x, delta_y;
 		COUNT encounter_radius;
 
+		SIZE shx, shy;
+		SIZE destx, desty;
+				
 		ElementPtr->life_span = 1;
 		GetNextVelocityComponents (&ElementPtr->velocity,
 				&delta_x, &delta_y, 1);
@@ -1196,9 +1414,21 @@ ProcessEncounter (ENCOUNTER *EncounterPt
 
 			cur_facing = ANGLE_TO_FACING (
 					GetVelocityTravelAngle (&ElementPtr->velocity));
-			delta_facing = NORMALIZE_FACING (cur_facing - ANGLE_TO_FACING (
-					ARCTAN (puniverse->x - EncounterPtr->SD.star_pt.x,
-					puniverse->y - EncounterPtr->SD.star_pt.y)));
+			// JMS: Transport ship doesn't chase player, heads for target system instead.
+			if (EncounterPtr->SD.Type == TRANSPORT_SHIP) 
+			{
+				delta_facing = NORMALIZE_FACING (cur_facing
+					- ANGLE_TO_FACING (ARCTAN (
+					EncounterPtr->destination_pt.x - EncounterPtr->SD.star_pt.x,
+					EncounterPtr->destination_pt.y - EncounterPtr->SD.star_pt.y)));
+			}
+			// Normal ships chase player.
+			else
+			{
+				delta_facing = NORMALIZE_FACING (cur_facing - ANGLE_TO_FACING (
+						ARCTAN (puniverse->x - EncounterPtr->SD.star_pt.x,
+						puniverse->y - EncounterPtr->SD.star_pt.y)));
+			}
 			if (delta_facing || (delta_x == 0 && delta_y == 0))
 			{
 				SIZE speed;
@@ -1235,6 +1465,10 @@ ProcessEncounter (ENCOUNTER *EncounterPt
 		EncounterPtr->log_y -= delta_y;
 		EncounterPtr->SD.star_pt.x = LOGX_TO_UNIVERSE (EncounterPtr->log_x);
 		EncounterPtr->SD.star_pt.y = LOGY_TO_UNIVERSE (EncounterPtr->log_y);
+		
+		// BW: Animate the NPC bubble in hi-res modes.
+		if (RESOLUTION_FACTOR > 0)
+			ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->current.image.frame);
 
 		encounter_radius = EncounterPtr->radius + (GRID_OFFSET >> 1);
 		delta_x = EncounterPtr->SD.star_pt.x - EncounterPtr->origin.x;
@@ -1264,6 +1498,35 @@ ProcessEncounter (ENCOUNTER *EncounterPt
 				return false;
 			}
 		}
+				
+				shx=EncounterPtr->SD.star_pt.x;
+				shy=EncounterPtr->SD.star_pt.y;
+				destx=EncounterPtr->destination_pt.x;
+				desty=EncounterPtr->destination_pt.y;
+				
+				// JMS: Transport ship reaches target. Transport ship disappears ("into target").
+				if (( (destx-shx)*(destx-shx)<5 && (desty-shy)*(desty-shy)<5)
+					&& (EncounterPtr->SD.Type == TRANSPORT_SHIP) )
+				{
+					SET_GAME_STATE(TRANSPORT_SHIP_0_STATUS, 4);
+					AddEvent (RELATIVE_EVENT, 0, 3, 0, TRANSPORT_HAS_ARRIVED_AT_DESTINATION_EVENT);
+					ElementPtr->state_flags |= NONSOLID;
+					ElementPtr->life_span = 0;
+					
+					if (EncounterPtr->transition_state == 0)
+					{
+						ElementPtr->death_func = encounter_transition;
+						EncounterPtr->transition_state = -1;
+						ElementPtr->hit_points = 1;
+					}
+					else
+					{
+						ElementPtr->death_func = NULL;
+						UnlockElement (EncounterPtr->hElement);
+						return false;
+					}
+				}
+
 	}
 
 	ex = EncounterPtr->SD.star_pt.x;
@@ -1344,6 +1607,9 @@ ProcessEncounters (POINT *puniverse, COO
 	}
 }
 
+#define NUM_HOLES_FRAMES 32 // BW
+#define NUM_SUNS_FRAMES 32 // BW
+
 void
 SeedUniverse (void)
 {
@@ -1356,7 +1622,9 @@ SeedUniverse (void)
 	STAR_DESC *SDPtr;
 	HELEMENT hHyperSpaceElement;
 	ELEMENT *HyperSpaceElementPtr;
+	static COUNT frameCounter; // BW
 
+	frameCounter++; // BW
 	universe.x = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x));
 	universe.y = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
 
@@ -1456,6 +1724,7 @@ SeedUniverse (void)
 		// Process the i portals from SD.
 		do
 		{
+			int which_spaces_star_gfx;
 			--i;
 			sx = SD[i].star_pt.x - universe.x + XOFFS;
 			sy = SD[i].star_pt.y - universe.y + YOFFS;
@@ -1487,8 +1756,16 @@ SeedUniverse (void)
 				continue;
 
 			LockElement (hHyperSpaceElement, &HyperSpaceElementPtr);
+
+			// JMS: Orzspace element graphics
+			
+			if (GET_GAME_STATE (ORZ_SPACE_SIDE))
+				which_spaces_star_gfx = 3;
+			else 
+				which_spaces_star_gfx = 1 + (GET_GAME_STATE (ARILOU_SPACE_SIDE) >> 1);
+
 			HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (
-					hyperstars[1 + (GET_GAME_STATE (ARILOU_SPACE_SIDE) >> 1)],
+					hyperstars[which_spaces_star_gfx],	// JMS: was "hyperstars[1 + (GET_GAME_STATE (ARILOU_SPACE_SIDE) >> 1)],"
 					SD[i].Index);
 			HyperSpaceElementPtr->preprocess_func = NULL;
 			HyperSpaceElementPtr->postprocess_func = NULL;
@@ -1516,6 +1793,7 @@ SeedUniverse (void)
 		while ((SDPtr = FindStar (SDPtr, &universe, XOFFS, YOFFS)))
 		{
 			BYTE star_type;
+			int which_spaces_star_gfx;
 
 			ex = SDPtr->star_pt.x - universe.x;
 			if (ex < 0)
@@ -1526,37 +1804,134 @@ SeedUniverse (void)
 			if (ex > (XOFFS / NUM_RADAR_SCREENS)
 					|| ey > (YOFFS / NUM_RADAR_SCREENS))
 				continue;
+				
+			star_type = SDPtr->Type;
 
-			hHyperSpaceElement = AllocHyperElement (SDPtr);
-			if (hHyperSpaceElement == 0)
-				continue;
+			if (RESOLUTION_FACTOR == 0)
+			{
+				hHyperSpaceElement = AllocHyperElement (SDPtr);
+				if (hHyperSpaceElement == 0)
+					continue;
 
-			star_type = SDPtr->Type;
+				LockElement (hHyperSpaceElement, &HyperSpaceElementPtr);
 
-			LockElement (hHyperSpaceElement, &HyperSpaceElementPtr);
-			HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (
-					hyperstars[1 + (GET_GAME_STATE (ARILOU_SPACE_SIDE) >> 1)],
+				// DEBUG BY JMS: ORZ space element gfx
+			
+				if (GET_GAME_STATE (ORZ_SPACE_SIDE))
+					which_spaces_star_gfx = 3;
+				else
+					which_spaces_star_gfx = 1 + (GET_GAME_STATE (ARILOU_SPACE_SIDE) >> 1);
+
+				HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (
+					hyperstars[which_spaces_star_gfx],
 					STAR_TYPE (star_type) * NUM_STAR_COLORS
 					+ STAR_COLOR (star_type));
-			HyperSpaceElementPtr->preprocess_func = NULL;
-			HyperSpaceElementPtr->postprocess_func = NULL;
-			HyperSpaceElementPtr->collision_func = hyper_collision;
-
-			SetUpElement (HyperSpaceElementPtr);
+				HyperSpaceElementPtr->preprocess_func = NULL;
+				HyperSpaceElementPtr->postprocess_func = NULL;
+				HyperSpaceElementPtr->collision_func = hyper_collision;
+
+				SetUpElement (HyperSpaceElementPtr);
+
+				if (SDPtr == CurStarDescPtr
+				    && GET_GAME_STATE (PORTAL_COUNTER) == 0)
+					HyperSpaceElementPtr->death_func = hyper_death;
+				else
+				{
+					HyperSpaceElementPtr->death_func = NULL;
+					HyperSpaceElementPtr->IntersectControl.IntersectStamp.frame =
+						DecFrameIndex (stars_in_space);
+				}
+				UnlockElement (hHyperSpaceElement);
 
-			if (SDPtr == CurStarDescPtr
-					&& GET_GAME_STATE (PORTAL_COUNTER) == 0)
-				HyperSpaceElementPtr->death_func = hyper_death;
+				InsertElement (hHyperSpaceElement, GetHeadElement ());
+			}
 			else
 			{
+				// BW: first the actual star
+				hHyperSpaceElement = AllocHyperElement (SDPtr);
+				if (hHyperSpaceElement == 0)
+					continue;
+
+				LockElement (hHyperSpaceElement, &HyperSpaceElementPtr);
+
+				HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (
+				      hyperspacesuns, STAR_COLOR (star_type) * NUM_STAR_TYPES * NUM_SUNS_FRAMES
+				      + STAR_TYPE (star_type) * NUM_SUNS_FRAMES
+				      + frameCounter % NUM_SUNS_FRAMES);
+				// The color, then the size and finally
+				// the frame offset for the actual animation
+
+				HyperSpaceElementPtr->current.image.farray = &hyperspacesuns;
+				HyperSpaceElementPtr->preprocess_func = NULL;
+				HyperSpaceElementPtr->postprocess_func = NULL;
+				HyperSpaceElementPtr->collision_func = hyper_collision;
+
+				SetUpElement (HyperSpaceElementPtr);
+
 				HyperSpaceElementPtr->death_func = NULL;
-				HyperSpaceElementPtr->IntersectControl.IntersectStamp.frame =
+				HyperSpaceElementPtr->IntersectControl.IntersectStamp.frame = DecFrameIndex (stars_in_space);
+
+				UnlockElement (hHyperSpaceElement);
+
+				InsertElement (hHyperSpaceElement, GetHeadElement ());
+				// BW: and then the animated hyperspace portal
+				hHyperSpaceElement = AllocHyperElement (SDPtr);
+				if (hHyperSpaceElement == 0)
+					continue;
+
+				LockElement (hHyperSpaceElement, &HyperSpaceElementPtr);
+
+				if (GET_GAME_STATE (ORZ_SPACE_SIDE))
+					which_spaces_star_gfx = 3;
+				else
+					which_spaces_star_gfx = 1 + (GET_GAME_STATE (ARILOU_SPACE_SIDE) >> 1);
+
+				// Most holes go 100, 150, 200 or 150, 200, 250
+				HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (
+                                        hyperholes[which_spaces_star_gfx],
+                                        STAR_TYPE (star_type) * NUM_HOLES_FRAMES);
+				// Green, orange and yellow need bigger holes
+				if (STAR_COLOR (star_type) == GREEN_BODY || STAR_COLOR (star_type) == ORANGE_BODY || STAR_COLOR (star_type) == YELLOW_BODY)
+					HyperSpaceElementPtr->current.image.frame = SetRelFrameIndex (
+                                        HyperSpaceElementPtr->current.image.frame,
+                                        NUM_HOLES_FRAMES);
+				// Super giant blue needs a bigger hole
+				if (STAR_COLOR (star_type) == BLUE_BODY && STAR_TYPE (star_type) == SUPER_GIANT_STAR)
+                                        HyperSpaceElementPtr->current.image.frame = SetRelFrameIndex (
+                                        HyperSpaceElementPtr->current.image.frame,
+                                        NUM_HOLES_FRAMES);
+				// The actual animation
+				HyperSpaceElementPtr->current.image.frame = SetRelFrameIndex (
+                                        HyperSpaceElementPtr->current.image.frame,
+                                        frameCounter % NUM_HOLES_FRAMES);
+
+				HyperSpaceElementPtr->current.image.farray = &hyperholes[which_spaces_star_gfx];
+				HyperSpaceElementPtr->preprocess_func = NULL;
+				HyperSpaceElementPtr->postprocess_func = NULL;
+				HyperSpaceElementPtr->collision_func = hyper_collision;
+
+				SetUpElement (HyperSpaceElementPtr);
+
+				if (SDPtr == CurStarDescPtr
+					&& GET_GAME_STATE (PORTAL_COUNTER) == 0)
+					HyperSpaceElementPtr->death_func = hyper_death;
+				else
+				{
+					HyperSpaceElementPtr->death_func = NULL;
+					HyperSpaceElementPtr->IntersectControl.IntersectStamp.frame =
 						DecFrameIndex (stars_in_space);
-			}
-			UnlockElement (hHyperSpaceElement);
+				}
+				UnlockElement (hHyperSpaceElement);
 
-			InsertElement (hHyperSpaceElement, GetHeadElement ());
+				InsertElement (hHyperSpaceElement, GetHeadElement ());				
+			}
 		}
+		
+		// JMS: If player left system before transport ship and the transport ship was on its way to leaving system,
+		// force the transport ship out of the system.
+		if (GET_GAME_STATE(TRANSPORT_SHIP_0_STATUS) == 1)
+			SET_GAME_STATE(TRANSPORT_SHIP_0_STATUS, 2);
+		
 		ProcessEncounters (&universe, ox, oy);
 	}
 
diff -ruNp src.orig/uqm/hyper.h src/uqm/hyper.h
--- src.orig/uqm/hyper.h	2017-11-01 15:30:25 -0700
+++ src/uqm/hyper.h	2017-11-01 15:31:02 -0700
@@ -16,6 +16,10 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010:- Defined procyon system coords to PROCYON_X and PROCYON_Y for use in game start location, in globdata.c
+
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
 #ifndef _HYPER_H
 #define _HYPER_H
 
@@ -25,8 +29,8 @@
 
 #define NUM_RADAR_SCREENS 12
 
-#define RADAR_SCAN_WIDTH (UNIT_SCREEN_WIDTH * NUM_RADAR_SCREENS)
-#define RADAR_SCAN_HEIGHT (UNIT_SCREEN_HEIGHT * NUM_RADAR_SCREENS)
+#define RADAR_SCAN_WIDTH ((UNIT_SCREEN_WIDTH * NUM_RADAR_SCREENS) >> RESOLUTION_FACTOR)
+#define RADAR_SCAN_HEIGHT ((UNIT_SCREEN_HEIGHT * NUM_RADAR_SCREENS) >> RESOLUTION_FACTOR)
 
 // Hyperspace coordinates of the naturally occuring portal into QuasiSpace
 #define ARILOU_SPACE_X   438
@@ -37,8 +41,8 @@
 #define QUASI_SPACE_Y  5000
 
 // QuasiSpace coordinates of the Arilou home world
-#define ARILOU_HOME_X  (QUASI_SPACE_X + ((RADAR_SCAN_WIDTH >> 1) * 3))
-#define ARILOU_HOME_Y  (QUASI_SPACE_Y + ((RADAR_SCAN_HEIGHT >> 1) * 3))
+#define ARILOU_HOME_X  6134
+#define ARILOU_HOME_Y  5900
 
 // HyperSpace coordinates of the locations where the QuasiSpace portals
 // take you.
@@ -63,14 +67,19 @@
 
 // Hyperspace coordinates of the Sol system
 // Should be the same as in plandata.c
-#define SOL_X  1752
-#define SOL_Y  1450
+#define SOL_X  6752
+#define SOL_Y  7450
+
+// JMS: Hyperspace coordinates of the Procyon system
+// Should be the same as in plandata.c
+#define PROCYON_X  5742
+#define PROCYON_Y  8268
 
 
 extern BOOLEAN LoadHyperspace (void);
 extern BOOLEAN FreeHyperspace (void);
 extern void SeedUniverse (void);
-extern void MoveSIS (SIZE *pdx, SIZE *pdy);
+extern void MoveSIS (SDWORD *pdx, SDWORD *pdy);
 
 extern void FreeHyperData (void);
 extern void check_hyperspace_encounter (void);
diff -ruNp src.orig/uqm/ifontres.h src/uqm/ifontres.h
--- src.orig/uqm/ifontres.h	2017-11-01 15:30:25 -0700
+++ src/uqm/ifontres.h	2017-11-01 15:31:02 -0700
@@ -2,8 +2,13 @@
    should not be edited directly.  Modify the master resource list
    instead and regenerate. */
 
+#define COMPUTER_FONT "font.computer"
+#define FALLBACK_TO1X_FONT "font.fallbackto1x"
+#define FALLBACK_TO2X_FONT "font.fallbackto2x"
+#define FALLBACK_TO4X_FONT "font.fallbackto4x"
 #define LANDER_FONT "font.lander"
 #define MICRO_FONT "font.micro"
+#define NANO_FONT "font.nano"
 #define PLAYER_FONT "font.player"
 #define PT13AA_FONT "credits.font.pt13"
 #define PT17AA_FONT "credits.font.pt17"
diff -ruNp src.orig/uqm/igfxres.h src/uqm/igfxres.h
--- src.orig/uqm/igfxres.h	2017-11-01 15:30:25 -0700
+++ src/uqm/igfxres.h	2017-11-01 15:31:03 -0700
@@ -18,13 +18,21 @@
 #define BOOM_SML_MASK_PMAP_ANIM "graphics.boom.small"
 #define BURV_BCS_MASK_PMAP_ANIM "graphics.burvixcaster"
 #define CANNISTER_MASK_PMAP_ANIM "graphics.lifecan"
+#define CIRCLES_A_MASK_PMAP_ANIM "graphics.circles_a"
+#define CIRCLES_B_MASK_PMAP_ANIM "graphics.circles_b"
+#define CIRCLES_C_MASK_PMAP_ANIM "graphics.circles_c"
 #define CREDITS_BACK_ANIM "credits.background"
+#define CREDITS_BACK_ANIM2X "credits.background2x"
+#define CREDITS_BACK_ANIM4X "credits.background4x"
 #define EARTH_MASK_ANIM "graphics.earthmask"
 #define EGG_CASE_MASK_PMAP_ANIM "graphics.eggcase"
 #define FLAGSTAT_MASK_PMAP_ANIM "graphics.flagshipstatus"
 #define FONTGRAD_PMAP_ANIM "graphics.fontgradient"
+#define HYPERHOLES_MASK_PMAP_ANIM "graphics.hyperholes"
 #define HYPERSTARS_MASK_PMAP_ANIM "graphics.hyperstars"
+#define HYPERSUNS_MASK_PMAP_ANIM "graphics.hypersuns"
 #define IPBKGND_MASK_PMAP_ANIM "graphics.orbitbackground"
+#define LANDENEMY_MASK_PMAP_ANIM "graphics.landenemy"
 #define LANDER_FONTEFF_PMAP_ANIM "graphics.landerfonteffect"
 #define LANDER_LAUNCH_MASK_PMAP_ANIM "graphics.landerlaunch"
 #define LANDER_MASK_PMAP_ANIM "graphics.lander"
@@ -57,17 +65,51 @@
 #define LIFE23_MASK_PMAP_ANIM "graphics.life.23"
 #define LIFE24_MASK_PMAP_ANIM "graphics.life.24"
 #define LIFE25_MASK_PMAP_ANIM "graphics.life.25"
+#define LIFE26_MASK_PMAP_ANIM "graphics.life.26"
+#define LIFE27_MASK_PMAP_ANIM "graphics.life.27"
+#define LIFE28_MASK_PMAP_ANIM "graphics.life.28"
+#define LIFE29_MASK_PMAP_ANIM "graphics.life.29"
+#define LIFE30_MASK_PMAP_ANIM "graphics.life.30"
+#define LIFE31_MASK_PMAP_ANIM "graphics.life.31"
+#define LIFE32_MASK_PMAP_ANIM "graphics.life.32"
+#define LIFE33_MASK_PMAP_ANIM "graphics.life.33"
+#define LIFE34_MASK_PMAP_ANIM "graphics.life.34"
+#define LIFE35_MASK_PMAP_ANIM "graphics.life.35"
+#define LIFE36_MASK_PMAP_ANIM "graphics.life.36"
+#define LIFE37_MASK_PMAP_ANIM "graphics.life.37"
+#define LIFE38_MASK_PMAP_ANIM "graphics.life.38"
+#define LIFE39_MASK_PMAP_ANIM "graphics.life.39"
+#define LIFE40_MASK_PMAP_ANIM "graphics.life.40"
+#define LIFE41_MASK_PMAP_ANIM "graphics.life.41"
+#define LIFE42_MASK_PMAP_ANIM "graphics.life.42"
+#define LIFE43_MASK_PMAP_ANIM "graphics.life.43"
+#define LIFE44_MASK_PMAP_ANIM "graphics.life.44"
+#define LIFE45SML_MASK_PMAP_ANIM "graphics.life.45sml"
+#define LIFE45_MASK_PMAP_ANIM "graphics.life.45"
+#define LIFE46_MASK_PMAP_ANIM "graphics.life.46"
+#define LIFE47_MASK_PMAP_ANIM "graphics.life.47"
+#define LIFE48_MASK_PMAP_ANIM "graphics.life.48"
+#define LIFE49_MASK_PMAP_ANIM "graphics.life.49"
+#define LIFE50_MASK_PMAP_ANIM "graphics.life.50"
+#define LIFE51_MASK_PMAP_ANIM "graphics.life.51"
 #define LIGHTNING_MASK_ANIM "graphics.lightning"
 #define MAIDENS_MASK_PMAP_ANIM "graphics.maidens"
+#define MARS_MASK_ANIM "graphics.marsmask"
 #define MELEE_PICK_MASK_PMAP_ANIM "graphics.meleepickship"
 #define MELEE_SCREEN_PMAP_ANIM "graphics.meleemenu"
 #define MENUBKG_PMAP_ANIM "graphics.setupmenu"
+#define MENUBKG_PMAP_ANIM2X "graphics.setupmenu2x"
+#define MENUBKG_PMAP_ANIM4X "graphics.setupmenu4x"
 #define MISCDATA_MASK_PMAP_ANIM "graphics.miscdata"
 #define MODULES_PMAP_ANIM "graphics.modulesmenu"
 #define MOONBASE_MASK_PMAP_ANIM "graphics.moonbase"
+#define NEBULAE_PMAP_ANIM "graphics.nebulae"
+#define NPCBUBBLE_MASK_PMAP_ANIM "graphics.npcbubble"
 #define ORBENTER_PMAP_ANIM "graphics.orbitenter"
 #define ORBIT_VIEW_ANIM "graphics.orbview"
 #define ORBPLAN_MASK_PMAP_ANIM "graphics.planets"
+#define ORZSPACEPORTAL_MASK_PMAP_ANIM "graphics.orzspaceportal"
+#define ORZSPACE_MASK_PMAP_ANIM "graphics.orzspace"
 #define OUTFIT_PMAP_ANIM "graphics.outfit"
 #define PLANET00_BIG_MASK_PMAP_ANIM "planet.oolite.large"
 #define PLANET00_MED_MASK_PMAP_ANIM "planet.oolite.medium"
@@ -247,11 +289,15 @@
 #define PLANET58_MED_MASK_PMAP_ANIM "planet.yellowgas.medium"
 #define PLANET58_SML_MASK_PMAP_ANIM "planet.yellowgas.small"
 #define PLAYMENU_ANIM "graphics.playmenu"
+#define PRECURSOR_BATTLESHIP_MASK_PMAP_ANIM "graphics.precbattleship"
 #define QUAKE_MASK_PMAP_ANIM "graphics.quake"
 #define RESTART_PMAP_ANIM "graphics.newgame"
+#define RESTART_PMAP_ANIM2X "graphics.newgame2x"
+#define RESTART_PMAP_ANIM4X "graphics.newgame4x"
 #define RUINS_MASK_PMAP_ANIM "graphics.ruins"
 #define SAMATRA_BIG_MASK_PMAP_ANIM "planet.samatra.large"
 #define SC2_PICK_PMAP_ANIM "graphics.pickship"
+#define SEGUE_ORZSPACEPORTAL_ANIM "graphics.segue_orzspaceportal"
 #define SEGUE_PMAP_ANIM "graphics.segue"
 #define SHIELDED_BIG_MASK_PMAP_ANIM "planet.slaveshield.large"
 #define SHIELDED_MED_MASK_PMAP_ANIM "planet.slaveshield.medium"
@@ -263,11 +309,21 @@
 #define SISSKEL_MASK_PMAP_ANIM "graphics.flagshipskeleton"
 #define SPAPLUTO_MASK_PMAP_ANIM "graphics.fwiffo"
 #define STARBASE_ANIM "graphics.starbase"
+#define STARBASE_GAIA_ANIM "graphics.starbase_gaia"
+#define STARBASE_PROCYON_ANIM "graphics.starbase_procyon"
 #define STAR_MASK_PMAP_ANIM "graphics.stars"
 #define STATUS_MASK_PMAP_ANIM "graphics.status"
+#define SUNBLUE_MASK_PMAP_ANIM "graphics.truespacesunblue"
+#define SUNGREEN_MASK_PMAP_ANIM "graphics.truespacesungreen"
+#define SUNORANGE_MASK_PMAP_ANIM "graphics.truespacesunorange"
+#define SUNRED_MASK_PMAP_ANIM "graphics.truespacesunred"
+#define SUNWHITE_MASK_PMAP_ANIM "graphics.truespacesunwhite"
+#define SUNYELLOW_MASK_PMAP_ANIM "graphics.truespacesunyellow"
 #define SUN_DEVICE_MASK_PMAP_ANIM "graphics.sundevice"
 #define SUN_MASK_PMAP_ANIM "graphics.truespacesun"
 #define TAALO_DEVICE_MASK_PMAP_ANIM "graphics.taalodevice"
+#define TITLE_2X "graphics.title2x"
+#define TITLE_4X "graphics.title4x"
 #define TITLE_ANIM "graphics.title"
 #define UMGAH_BCS_MASK_PMAP_ANIM "graphics.umgahcaster"
 #define VAULT_MASK_PMAP_ANIM "graphics.syreenvault"
diff -ruNp src.orig/uqm/imusicre.h src/uqm/imusicre.h
--- src.orig/uqm/imusicre.h	2017-11-01 15:30:25 -0700
+++ src/uqm/imusicre.h	2017-11-01 15:31:03 -0700
@@ -13,6 +13,7 @@
 #define ORBIT3_MUSIC "music.orbit3"
 #define ORBIT4_MUSIC "music.orbit4"
 #define ORBIT5_MUSIC "music.orbit5"
+#define ORZSPACE_MUSIC "music.orzspace"
 #define OUTFIT_MUSIC "music.outfit"
 #define QUASISPACE_MUSIC "music.quasispace"
 #define REDALERT_MUSIC "music.redalert"
diff -ruNp src.orig/uqm/init.c src/uqm/init.c
--- src.orig/uqm/init.c	2017-11-01 15:30:25 -0700
+++ src/uqm/init.c	2017-11-01 15:31:03 -0700
@@ -350,5 +350,3 @@ UninitShips (void)
 			FreeHyperspace ();
 	}
 }
-
-
diff -ruNp src.orig/uqm/intel.h src/uqm/intel.h
--- src.orig/uqm/intel.h	2017-11-01 15:30:25 -0700
+++ src/uqm/intel.h	2017-11-01 15:31:03 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+ // JMS_GFX: Added definitions for hi-res modes.
+
 #ifndef _INTEL_H
 #define _INTEL_H
 
@@ -35,6 +37,20 @@
 #define MEDIUM_SHIP 45
 #define SLOW_SHIP 25
 
+// JMS_GFX
+#define CLOSE_RANGE_WEAPON_2XRES DISPLAY_TO_WORLD (100)
+#define LONG_RANGE_WEAPON_2XRES DISPLAY_TO_WORLD (2000)
+#define FAST_SHIP_2XRES 300
+#define MEDIUM_SHIP_2XRES 90
+#define SLOW_SHIP_2XRES 50
+
+// JMS_GFX
+#define CLOSE_RANGE_WEAPON_4XRES DISPLAY_TO_WORLD (200)
+#define LONG_RANGE_WEAPON_4XRES DISPLAY_TO_WORLD (4000)
+#define FAST_SHIP_4XRES 600
+#define MEDIUM_SHIP_4XRES 180
+#define SLOW_SHIP_4XRES 100
+
 enum
 {
 	ENEMY_SHIP_INDEX = 0,
@@ -56,6 +72,7 @@ extern BOOLEAN ship_weapons (ELEMENT *Sh
 extern void Pursue (ELEMENT *ShipPtr, EVALUATE_DESC *EvalDescPtr);
 extern void Entice (ELEMENT *ShipPtr, EVALUATE_DESC *EvalDescPtr);
 extern void Avoid (ELEMENT *ShipPtr, EVALUATE_DESC *EvalDescPtr);
+extern void InGas (ELEMENT *ShipPtr, EVALUATE_DESC *EvalDescPtr); // JMS
 extern BOOLEAN TurnShip (ELEMENT *ShipPtr, COUNT angle);
 extern BOOLEAN ThrustShip (ELEMENT *ShipPtr, COUNT angle);
 
diff -ruNp src.orig/uqm/intro.c src/uqm/intro.c
--- src.orig/uqm/intro.c	2017-11-01 15:30:25 -0700
+++ src/uqm/intro.c	2017-11-01 15:31:03 -0700
@@ -218,40 +218,43 @@ Present_GenerateSIS (PRESENTATION_INPUT_
 	s.origin.y = 0;
 	DrawStamp (&s);
 
-	for (slot = 0; slot < NUM_DRIVE_SLOTS; ++slot)
+	if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) != CHMMR_EXPLORER_SHIP)
 	{
-		piece = GLOBAL_SIS (DriveSlots[slot]);
-		if (piece < EMPTY_SLOT)
+		for (slot = 0; slot < NUM_DRIVE_SLOTS; ++slot)
 		{
-			s.origin.x = DRIVE_TOP_X;
-			s.origin.y = DRIVE_TOP_Y_P;
-			s.origin.x += slot * SHIP_PIECE_OFFSET;
-			s.frame = SetAbsFrameIndex (ModuleFrame, piece);
-			DrawStamp (&s);
+			piece = GLOBAL_SIS (DriveSlots[slot]);
+			if (piece < EMPTY_SLOT)
+			{
+				s.origin.x = DRIVE_TOP_X;
+				s.origin.y = DRIVE_TOP_Y_P;
+				s.origin.x += slot * SHIP_PIECE_OFFSET;
+				s.frame = SetAbsFrameIndex (ModuleFrame, piece);
+				DrawStamp (&s);
+			}
 		}
-	}
-	for (slot = 0; slot < NUM_JET_SLOTS; ++slot)
-	{
-		piece = GLOBAL_SIS (JetSlots[slot]);
-		if (piece < EMPTY_SLOT)
+	    for (slot = 0; slot < NUM_JET_SLOTS; ++slot)
 		{
-			s.origin.x = JET_TOP_X;
-			s.origin.y = JET_TOP_Y_P;
-			s.origin.x += slot * SHIP_PIECE_OFFSET;
-			s.frame = SetAbsFrameIndex (ModuleFrame, piece);
-			DrawStamp (&s);
+			piece = GLOBAL_SIS (JetSlots[slot]);
+			if (piece < EMPTY_SLOT)
+			{
+				s.origin.x = JET_TOP_X;
+				s.origin.y = JET_TOP_Y_P;
+				s.origin.x += slot * SHIP_PIECE_OFFSET;
+				s.frame = SetAbsFrameIndex (ModuleFrame, piece);
+				DrawStamp (&s);
+			}
 		}
-	}
-	for (slot = 0; slot < NUM_MODULE_SLOTS; ++slot)
-	{
-		piece = GLOBAL_SIS (ModuleSlots[slot]);
-		if (piece < EMPTY_SLOT)
+	    for (slot = 0; slot < NUM_MODULE_SLOTS; ++slot)
 		{
-			s.origin.x = MODULE_TOP_X;
-			s.origin.y = MODULE_TOP_Y_P;
-			s.origin.x += slot * SHIP_PIECE_OFFSET;
-			s.frame = SetAbsFrameIndex (ModuleFrame, piece);
-			DrawStamp (&s);
+			piece = GLOBAL_SIS (ModuleSlots[slot]);
+			if (piece < EMPTY_SLOT)
+			{
+				s.origin.x = MODULE_TOP_X;
+				s.origin.y = MODULE_TOP_Y_P;
+				s.origin.x += slot * SHIP_PIECE_OFFSET;
+				s.frame = SetAbsFrameIndex (ModuleFrame, piece);
+				DrawStamp (&s);
+			}
 		}
 	}
 
diff -ruNp src.orig/uqm/ipdisp.c src/uqm/ipdisp.c
--- src.orig/uqm/ipdisp.c	2017-11-01 15:30:25 -0700
+++ src/uqm/ipdisp.c	2017-11-01 15:31:03 -0700
@@ -16,6 +16,18 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: - Certain systems have freight transport ships. These ships leave the system for their 
+//			  supposed freight run on first day of the month + every date divisible with seven thereafter.
+//			 
+//			 - More Transport ship mechanics: The ship's status flag is 0 when orbiting a planet, 1 when
+//			  leaving for hyperspace and 2 when arriving from hyperspace.
+//
+//			 - Transport ship tells the intercepting ships in star system that all is well, stop chasing.
+//			  When at sol, it notifies human ships, when at procyon, it notifies chmmr ships.
+//
+//			 - Removed some Ur-Quan probe conditions.
+//			 - Enhanced battle group behavior when they orbit planets: They don't jitter no more when changing facing.
+
 #include "ipdisp.h"
 
 #include "collide.h"
@@ -27,6 +39,7 @@
 #include "encount.h"
 		// for EncounterGroup, EncounterRace
 #include "libs/mathlib.h"
+#include "libs/log.h"
 
 
 void
@@ -49,7 +62,6 @@ NotifyOthers (COUNT which_race, BYTE tar
 			UnlockIpGroup (&GLOBAL (ip_group_q), hGroup);
 			continue;
 		}
-
 		if (target_loc == IPNL_INTERCEPT_PLAYER)
 		{
 			GroupPtr->task &= ~IGNORE_FLAGSHIP;
@@ -70,9 +82,20 @@ NotifyOthers (COUNT which_race, BYTE tar
 				GroupPtr->dest_loc = GroupPtr->orbit_pos;
 				GroupPtr->orbit_pos = NORMALIZE_FACING (TFB_Random ());
 #ifdef OLD
-				GroupPtr->dest_loc = (BYTE)(((COUNT)TFB_Random ()
-						% pSolarSysState->SunDesc[0].NumPlanets) + 1);
+				GroupPtr->dest_loc = (BYTE)(((COUNT)TFB_Random ()% pSolarSysState->SunDesc[0].NumPlanets) + 1);
 #endif /* OLD */
+				
+				// JMS
+				if (GroupPtr->dest_loc==0 && GroupPtr->race_id == SLYLANDRO_KOHRAH_SHIP)
+				{
+				GroupPtr->task &= ~IGNORE_FLAGSHIP;
+				GroupPtr->task = ON_STATION;
+				GroupPtr->dest_loc = (BYTE)((
+						(COUNT)TFB_Random ()
+						% pSolarSysState->SunDesc[0].NumPlanets) + 1);
+					
+				}
+				
 			}
 			// If the group wasn't intercepting, it will just continue
 			// going about its business.
@@ -143,6 +166,7 @@ ip_group_preprocess (ELEMENT *ElementPtr
 	SIZE radius;
 	POINT dest_pt;
 	SIZE vdx, vdy;
+	SIZE tdx, tdy;
 	ELEMENT *EPtr;
 	IP_GROUP *GroupPtr;
 
@@ -176,17 +200,44 @@ ip_group_preprocess (ELEMENT *ElementPtr
 		if ((task & ~IGNORE_FLAGSHIP) != EXPLORE)
 			GroupPtr->group_counter = 0;
 		else
-			GroupPtr->group_counter = ((COUNT)TFB_Random ()
-					% MAX_REVOLUTIONS) << FACING_SHIFT;
+			GroupPtr->group_counter = ((COUNT)TFB_Random () % MAX_REVOLUTIONS) << FACING_SHIFT;
+	}
+	
+	// JMS: If Slylandro-kohrah battlegroup is fought, all Slylandro battle groups escape from the system
+	if (GroupPtr->race_id == SLYLANDRO_KOHRAH_SHIP && GET_GAME_STATE (ENEMY_ESCAPE_OCCURRED))
+	{
+		GroupPtr->task = FLEE;
+		GroupPtr->dest_loc = 0;
+	}
+	
+	// JMS: A transport ship leaves star system on the first day of the month and on every seventh day thereafter.
+	if (GroupPtr->race_id == TRANSPORT_SHIP && GET_GAME_STATE(TRANSPORT_SHIP_0_STATUS) == 1)
+	{
+		GroupPtr->task = FLEE;
+		GroupPtr->dest_loc = 0;
 	}
 
+	// JMS: If a transport ship is arriving its destination, zero its status flag once it reaches destination planet.
+	if (GroupPtr->race_id == TRANSPORT_SHIP 
+		&& GET_GAME_STATE(TRANSPORT_SHIP_0_STATUS) == 4
+		&& group_loc == GroupPtr->dest_loc)
+	{
+		tdx = GroupPtr->loc.x;
+		tdy = GroupPtr->loc.y;
+
+		if ((long)tdx * tdx + (long)tdy * tdy <= (long)ORBIT_RADIUS * ORBIT_RADIUS)
+		{
+			SET_GAME_STATE(TRANSPORT_SHIP_0_STATUS, 0);
+		}
+	}
+	
 	// If fleeing *and* ignoring flagship
 	if ((task & ~(IGNORE_FLAGSHIP | REFORM_GROUP)) == FLEE
 			&& (task & IGNORE_FLAGSHIP))
 	{	// Make fleeing groups non-collidable
 		EPtr->state_flags |= NONSOLID;
 	}
-
+	
 	target_loc = GroupPtr->dest_loc;
 	if (!(task & (IGNORE_FLAGSHIP | REFORM_GROUP)))
 	{
@@ -208,8 +259,9 @@ ip_group_preprocess (ELEMENT *ElementPtr
 			if (group_loc != 0) /* if in planetary views */
 			{
 				detect_dist *= (MAX_ZOOM_RADIUS / MIN_ZOOM_RADIUS);
-				if (GroupPtr->race_id == URQUAN_DRONE_SHIP)
-					detect_dist <<= 1;
+				// JMS: Bye bye, Ur-Quan drone.
+				//if (GroupPtr->race_id == URQUAN_DRONE_SHIP)
+				//	detect_dist <<= 1;
 			}
 			vdx = GLOBAL (ip_location.x) - GroupPtr->loc.x;
 			vdy = GLOBAL (ip_location.y) - GroupPtr->loc.y;
@@ -227,6 +279,18 @@ ip_group_preprocess (ELEMENT *ElementPtr
 			}
 		}
 	}
+	
+	// JMS: If escaping Slylandro-kohrah battlegroup is caught and talked to peace, the battlegroups stop fleeing from system.
+	if (GroupPtr->race_id == SLYLANDRO_KOHRAH_SHIP 
+		&& GET_GAME_STATE (ENEMY_ESCAPE_OCCURRED) == 0
+		&& GroupPtr->task == FLEE)
+	{
+		GroupPtr->task = ON_STATION | IGNORE_FLAGSHIP;
+		GroupPtr->dest_loc = (BYTE)(((COUNT)TFB_Random () % pSolarSysState->SunDesc[0].NumPlanets) + 1);
+		
+		if (GroupPtr->dest_loc == 0)
+			GroupPtr->dest_loc = 1;
+	}	
 
 	GetCurrentVelocityComponents (&EPtr->velocity, &vdx, &vdy);
 
@@ -237,12 +301,15 @@ ip_group_preprocess (ELEMENT *ElementPtr
 	if (task <= ON_STATION)
 #endif /* NEVER */
 	{
-		BOOLEAN Transition;
+		BOOLEAN Transition, isOrbiting;
 		SIZE dx, dy;
 		SIZE delta_x, delta_y;
 		COUNT angle;
-
+		FRAME suggestedFrame; // JMS
+		
 		Transition = FALSE;
+		isOrbiting = FALSE;
+		
 		if (task == FLEE)
 		{
 			dest_pt.x = GroupPtr->loc.x << 1;
@@ -257,11 +324,14 @@ ip_group_preprocess (ELEMENT *ElementPtr
 		{
 			if (GroupPtr->dest_loc == IPNL_INTERCEPT_PLAYER)
 				dest_pt = GLOBAL (ip_location);
+			
+			// ship is circling around a planet.
 			else
 			{
 				COUNT orbit_dist;
 				POINT org;
 
+				isOrbiting = TRUE;
 				if (task != ON_STATION)
 				{
 					orbit_dist = ORBIT_RADIUS;
@@ -400,7 +470,7 @@ CheckGetAway:
 
 			if (Transition)
 			{
-						/* no collisions during transition */
+				/* no collisions during transition */
 				EPtr->state_flags |= NONSOLID;
 
 				vdx = 0;
@@ -417,7 +487,11 @@ CheckGetAway:
 					/* Group completely left the star system */
 					EPtr->life_span = 0;
 					EPtr->state_flags |= DISAPPEARING | NONSOLID;
-					GroupPtr->in_system = 0;
+					GroupPtr->in_system = 0;					
+
+					// JMS: Freight Transport ship has left the system.
+					if (GroupPtr->race_id==TRANSPORT_SHIP && GET_GAME_STATE(TRANSPORT_SHIP_0_STATUS) == 1)
+						SET_GAME_STATE(TRANSPORT_SHIP_0_STATUS, 2);
 					return;
 				}
 				else
@@ -426,11 +500,8 @@ CheckGetAway:
 
 					if (target_loc == GroupPtr->dest_loc)
 					{
-						GroupPtr->orbit_pos = NORMALIZE_FACING (
-								ANGLE_TO_FACING (angle + HALF_CIRCLE));
-						GroupPtr->group_counter =
-								((COUNT)TFB_Random () % MAX_REVOLUTIONS)
-								<< FACING_SHIFT;
+						GroupPtr->orbit_pos = NORMALIZE_FACING (ANGLE_TO_FACING (angle + HALF_CIRCLE));
+						GroupPtr->group_counter = ((COUNT)TFB_Random () % MAX_REVOLUTIONS) << FACING_SHIFT;
 					}
 					// The group enters inner system exactly on the edge of a
 					// circle with radius = 9/16 * window-dim, which is
@@ -448,6 +519,21 @@ CheckGetAway:
 				}
 			}
 		}
+		//BW : make IP ships face the direction they're going into
+		suggestedFrame = SetAbsFrameIndex(ElementPtr->next.image.farray[0], 1 + NORMALIZE_FACING (ANGLE_TO_FACING (ARCTAN (delta_x, delta_y))));
+		
+		// JMS: Direction memory prevents jittering of battle group icons when they are orbiting a planet (and not chasing the player ship).		
+		if (isOrbiting)
+		{
+			// This works because ships always orbit planets clockwise.
+			if (GroupPtr->lastDirection < NORMALIZE_FACING (ANGLE_TO_FACING (ARCTAN (delta_x, delta_y)))
+				|| GroupPtr->lastDirection == 15)
+				ElementPtr->next.image.frame = suggestedFrame;
+		}
+		else
+			ElementPtr->next.image.frame = suggestedFrame;
+		
+		GroupPtr->lastDirection = NORMALIZE_FACING (ANGLE_TO_FACING (ARCTAN (delta_x, delta_y)));
 	}
 
 	radius = zoomRadiusForLocation (group_loc);
@@ -544,6 +630,19 @@ ip_group_collision (ELEMENT *ElementPtr0
 		// resent.
 		NotifyOthers (GroupPtr->race_id, IPNL_ALL_CLEAR);
 
+		// JMS: Transport ship tells the intercepting ships in star system that all is well, stop chasing.
+		if (GroupPtr->race_id == TRANSPORT_SHIP)
+		{
+			if (CurStarDescPtr->Index == SOL_DEFINED)
+				NotifyOthers (HUMAN_SHIP, IPNL_ALL_CLEAR);
+			else if (CurStarDescPtr->Index == CHMMR_DEFINED)
+				NotifyOthers (CHMMR_SHIP, IPNL_ALL_CLEAR);
+		}
+		else
+		{
+			NotifyOthers (GroupPtr->race_id, IPNL_ALL_CLEAR);
+		}
+
 		if (!(ElementPtr1->state_flags & COLLISION))
 		{	// The other element's collision has not been processed yet
 			// Defer starting the encounter until it is.
diff -ruNp src.orig/uqm/istrtab.h src/uqm/istrtab.h
--- src.orig/uqm/istrtab.h	2017-11-01 15:30:25 -0700
+++ src/uqm/istrtab.h	2017-11-01 15:31:03 -0700
@@ -46,6 +46,7 @@
 #define FINALPRES_STRTAB "slides.ending"
 #define FLUORESCENT_COLOR_TAB "planet.fluorescent.colortable"
 #define FLUORESCENT_XLAT_TAB "planet.fluorescent.translatetable"
+#define GAMMAJANUS_STRTAB "text.gammajanus"
 #define GREEN_COLOR_TAB "planet.green.colortable"
 #define GREEN_XLAT_TAB "planet.green.translatetable"
 #define GRN_GAS_COLOR_TAB "planet.greengas.colortable"
@@ -67,6 +68,8 @@
 #define JOYSTICK_ALPHA_STRTAB "text.joyalpha"
 #define LANTHANIDE_COLOR_TAB "planet.lanthanide.colortable"
 #define LANTHANIDE_XLAT_TAB "planet.lanthanide.translatetable"
+#define LEFTHURRY_STRTAB "text.lefthurry"
+#define LURGPRES_STRTAB "slides.lurgcutscene"
 #define MAGMA_COLOR_TAB "planet.magma.colortable"
 #define MAGMA_XLAT_TAB "planet.magma.translatetable"
 #define MAGNETIC_COLOR_TAB "planet.magnetic.colortable"
@@ -88,6 +91,7 @@
 #define ORBPLAN_COLOR_MAP "colortable.orbplan"
 #define ORGANIC_COLOR_TAB "planet.organic.colortable"
 #define ORGANIC_XLAT_TAB "planet.organic.translatetable"
+#define ORZSPACE_COLOR_TAB "colortable.orzspace"
 #define PELLUCID_COLOR_TAB "planet.pellucid.colortable"
 #define PELLUCID_XLAT_TAB "planet.pellucid.translatetable"
 #define PKUNK_RUINS_STRTAB "text.spindle"
@@ -119,13 +123,13 @@
 #define SETUP_MENU_STRTAB "text.setupmenu"
 #define SHATTERED_COLOR_TAB "planet.shattered.colortable"
 #define SHATTERED_XLAT_TAB "planet.shattered.translatetable"
+#define SHOFIXTI_CRASH_SITE_STRTAB "text.shocrashsite"
 #define SPAPLUTO_STRTAB "text.fwiffo"
 #define STARCON_COLOR_MAP "colortable.main"
 #define STARCON_GAME_STRINGS "text.starcon"
 #define SUN_DEVICE_STRTAB "text.sundevice"
 #define SUPER_DENSE_COLOR_TAB "planet.superdense.colortable"
 #define SUPER_DENSE_XLAT_TAB "planet.superdense.translatetable"
-#define SUPOX_RUINS_STRTAB "text.ultron"
 #define TAALO_DEVICE_STRTAB "text.taalodevice"
 #define TELLURIC_COLOR_TAB "planet.telluric.colortable"
 #define TELLURIC_XLAT_TAB "planet.telluric.translatetable"
@@ -139,6 +143,7 @@
 #define UREA_COLOR_TAB "planet.urea.colortable"
 #define UREA_XLAT_TAB "planet.urea.translatetable"
 #define VAULT_STRTAB "text.syreenvault"
+#define VELA_FACTORY_STRTAB "text.velafactory"
 #define VINYLOGOUS_COLOR_TAB "planet.vinylogous.colortable"
 #define VINYLOGOUS_XLAT_TAB "planet.vinylogous.translatetable"
 #define VIO_GAS_COLOR_TAB "planet.violetgas.colortable"
diff -ruNp src.orig/uqm/load.c src/uqm/load.c
--- src.orig/uqm/load.c	2017-11-01 15:30:25 -0700
+++ src/uqm/load.c	2017-11-01 15:31:03 -0700
@@ -16,6 +16,9 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: - Added Encounter pointer's home and destination pt's to house transport ships to LoadEncounter
+// JMS 2011: - Added loading res_factor to summary_desc. It'll help making saves between different resolutions compatible.
+
 #include <assert.h>
 
 #include "load.h"
@@ -37,6 +40,13 @@
 
 //#define DEBUG_LOAD
 
+//log_add (log_Debug, "Autopilot - X:%d, Y:%d", GSPtr->autopilot.x, GSPtr->autopilot.y);
+//log_add (log_Debug, "IP location - X:%d, Y:%d", GSPtr->ip_location.x, GSPtr->ip_location.y);
+//log_add (log_Debug, "Sis Ship Log - X:%d, Y:%d", SSPtr->log_x, SSPtr->log_y);
+//log_add (log_Debug, "Fleet%d: Loc		- X:%d, Y:%d", num_links, FleetPtr->loc.x, FleetPtr->loc.y);
+//log_add (log_Debug, "Fleet%d: Known_loc - X:%d, Y:%d", num_links, FleetPtr->known_loc.x, FleetPtr->known_loc.y);
+//log_add (log_Debug, "Fleet%d: Dest Loc	- X:%d, Y:%d", num_links, FleetPtr->dest_loc.x, FleetPtr->dest_loc.y);
+
 ACTIVITY NextActivity;
 
 // XXX: these should handle endian conversions later
@@ -107,7 +117,7 @@ cread_a8 (DECODE_REF fh, BYTE *ar, COUNT
 	return cread (ar, 1, count, fh) == count;
 }
 
-static inline size_t
+static inline COUNT
 read_8 (void *fp, BYTE *v)
 {
 	BYTE t;
@@ -116,7 +126,7 @@ read_8 (void *fp, BYTE *v)
 	return ReadResFile (v, 1, 1, fp);
 }
 
-static inline size_t
+static inline COUNT
 read_16 (void *fp, UWORD *v)
 {
 	UWORD t;
@@ -125,7 +135,7 @@ read_16 (void *fp, UWORD *v)
 	return ReadResFile (v, 2, 1, fp);
 }
 
-static inline size_t
+static inline COUNT
 read_32 (void *fp, DWORD *v)
 {
 	DWORD t;
@@ -134,7 +144,7 @@ read_32 (void *fp, DWORD *v)
 	return ReadResFile (v, 4, 1, fp);
 }
 
-static inline size_t
+static inline COUNT
 read_32s (void *fp, SDWORD *v)
 {
 	DWORD t;
@@ -147,28 +157,28 @@ read_32s (void *fp, SDWORD *v)
 	return ret;
 }
 
-static inline size_t
+static inline COUNT
 read_ptr (void *fp)
 {
 	DWORD t;
 	return read_32 (fp, &t); /* ptrs are useless in saves */
 }
 
-static inline size_t
+static inline COUNT
 read_a8 (void *fp, BYTE *ar, COUNT count)
 {
 	assert (ar != NULL);
 	return ReadResFile (ar, 1, count, fp) == count;
 }
 
-static inline size_t
+static inline COUNT
 read_str (void *fp, char *str, COUNT count)
 {
 	// no type conversion needed for strings
 	return read_a8 (fp, (BYTE *)str, count);
 }
 
-static inline size_t
+static inline COUNT
 read_a16 (void *fp, UWORD *ar, COUNT count)
 {
 	assert (ar != NULL);
@@ -254,7 +264,7 @@ LoadRaceQueue (DECODE_REF fh, QUEUE *pQu
 
 		hStarShip = GetStarShipFromIndex (pQueue, Index);
 		FleetPtr = LockFleetInfo (pQueue, hStarShip);
-
+		
 		// Read FLEET_INFO elements
 		cread_16 (fh, &FleetPtr->allied_state);
 		cread_8  (fh, &FleetPtr->days_left);
@@ -336,6 +346,10 @@ LoadEncounter (ENCOUNTER *EncounterPtr,
 	cread_16s (fh, &EncounterPtr->origin.x);
 	cread_16s (fh, &EncounterPtr->origin.y);
 	cread_16  (fh, &EncounterPtr->radius);
+	cread_16s  (fh, &EncounterPtr->destination_pt.x);//JMS
+	cread_16s  (fh, &EncounterPtr->destination_pt.y);//JMS
+	cread_16s  (fh, &EncounterPtr->home_pt.x);		//JMS
+	cread_16s  (fh, &EncounterPtr->home_pt.y);		//JMS
 	// STAR_DESC fields
 	cread_16s (fh, &EncounterPtr->SD.star_pt.x);
 	cread_16s (fh, &EncounterPtr->SD.star_pt.y);
@@ -369,6 +383,10 @@ LoadEncounter (ENCOUNTER *EncounterPtr,
 	// Load the stuff after the BRIEF_SHIP_INFO array
 	cread_32s (fh, &EncounterPtr->log_x);
 	cread_32s (fh, &EncounterPtr->log_y);
+	
+	// JMS: Let's make savegames work even between different resolution modes.
+	EncounterPtr->log_x <<= RESOLUTION_FACTOR;
+	EncounterPtr->log_y <<= RESOLUTION_FACTOR;
 }
 
 static void
@@ -426,9 +444,10 @@ static void
 LoadGameState (GAME_STATE *GSPtr, DECODE_REF fh)
 {
 	BYTE dummy8;
+	BYTE res_scale; // JMS
 
 	cread_8   (fh, &dummy8); /* obsolete */
-	cread_8   (fh, &GSPtr->glob_flags);
+	cread_16   (fh, &GSPtr->glob_flags);
 	cread_8   (fh, &GSPtr->CrewCost);
 	cread_8   (fh, &GSPtr->FuelCost);
 	cread_a8  (fh, GSPtr->ModuleCost, NUM_MODULES);
@@ -436,6 +455,12 @@ LoadGameState (GAME_STATE *GSPtr, DECODE
 	cread_ptr (fh); /* not loading ptr; PRIMITIVE *DisplayArray */
 	cread_16  (fh, &GSPtr->CurrentActivity);
 	
+	// JMS
+	if (LOBYTE (GSPtr->CurrentActivity) != IN_INTERPLANETARY)
+		res_scale = RESOLUTION_FACTOR;
+	else
+		res_scale = 0;
+	
 	cread_16  (fh, NULL); /* CLOCK_STATE alignment padding */
 	LoadClockState (&GSPtr->GameClock, fh);
 
@@ -449,6 +474,9 @@ LoadGameState (GAME_STATE *GSPtr, DECODE
 	cread_16  (fh, &GSPtr->ShipFacing);
 	cread_8   (fh, &GSPtr->ip_planet);
 	cread_8   (fh, &GSPtr->in_orbit);
+	
+	GSPtr->ShipStamp.origin.x <<= RESOLUTION_FACTOR; // JMS: Let's make savegames work even between different resolution modes.
+	GSPtr->ShipStamp.origin.y <<= RESOLUTION_FACTOR; // JMS: Let's make savegames work even between different resolution modes.
 
 	/* VELOCITY_DESC velocity */
 	cread_16  (fh, &GSPtr->velocity.TravelAngle);
@@ -461,6 +489,15 @@ LoadGameState (GAME_STATE *GSPtr, DECODE
 	cread_16s (fh, &GSPtr->velocity.incr.width);
 	cread_16s (fh, &GSPtr->velocity.incr.height);
 	cread_16  (fh, NULL); /* VELOCITY_DESC padding */
+	
+	GSPtr->velocity.vector.width  <<= res_scale; // JMS: Let's make savegames work even between different resolution modes.
+	GSPtr->velocity.vector.height <<= res_scale; // JMS: Let's make savegames work even between different resolution modes.
+	GSPtr->velocity.fract.width	  <<= res_scale; // JMS: Let's make savegames work even between different resolution modes.
+	GSPtr->velocity.fract.height  <<= res_scale; // JMS: Let's make savegames work even between different resolution modes.
+	GSPtr->velocity.error.width	  <<= res_scale; // JMS: Let's make savegames work even between different resolution modes.
+	GSPtr->velocity.error.height  <<= res_scale; // JMS: Let's make savegames work even between different resolution modes.
+	GSPtr->velocity.incr.width	  <<= res_scale; // JMS: Let's make savegames work even between different resolution modes.
+	GSPtr->velocity.incr.height	  <<= res_scale; // JMS: Let's make savegames work even between different resolution modes.
 
 	cread_32  (fh, &GSPtr->BattleGroupRef);
 	
@@ -472,7 +509,7 @@ LoadGameState (GAME_STATE *GSPtr, DECODE
 
 	cread_a8  (fh, GSPtr->GameState, sizeof (GSPtr->GameState));
 
-	assert (sizeof (GSPtr->GameState) % 4 == 3);
+	//assert (sizeof (GSPtr->GameState) % 4 == 3);
 	cread_8  (fh, NULL); /* GAME_STATE alignment padding */
 }
 
@@ -501,7 +538,12 @@ LoadSisState (SIS_STATE *SSPtr, void *fp
 		)
 		return FALSE;
 	else
+	{
+		// JMS: Let's make savegames work even between different resolution modes.
+		SSPtr->log_x <<= RESOLUTION_FACTOR;
+		SSPtr->log_y <<= RESOLUTION_FACTOR;
 		return TRUE;
+	}
 }
 
 static BOOLEAN
@@ -522,6 +564,7 @@ LoadSummary (SUMMARY_DESC *SummPtr, void
 			read_8  (fp, &SummPtr->NumDevices) != 1 ||
 			read_a8 (fp, SummPtr->ShipList, MAX_BUILT_SHIPS) != 1 ||
 			read_a8 (fp, SummPtr->DeviceList, MAX_EXCLUSIVE_DEVICES) != 1 ||
+			read_8  (fp, &SummPtr->res_factor) != 1 || // JMS: This'll help making saves between different resolutions compatible.
 
 			read_16  (fp, NULL) != 1 /* padding */
 		)
diff -ruNp src.orig/uqm/loadship.c src/uqm/loadship.c
--- src.orig/uqm/loadship.c	2017-11-01 15:30:25 -0700
+++ src/uqm/loadship.c	2017-11-01 15:31:03 -0700
@@ -16,6 +16,11 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: -Added code resource for slylandros-riding-kohrah-vessels
+//			 -Added code resource for Lurg
+//			 -Added code resource for ISD
+// JMS 2011: -Added code resources for Baul & Foon-foon
+
 #include "build.h"
 #include "coderes.h"
 #include "corecode.h"
@@ -51,6 +56,11 @@ static RESOURCE code_resources[] = {
 		ANDROSYNTH_CODE,
 		CHENJESU_CODE,
 		MMRNMHRM_CODE,
+		BAUL_CODE,				// JMS
+		FOONFOON_CODE,			// JMS
+		LURG_CODE,				// JMS
+		ISD_CODE,				// JMS
+		SLYLANDRO_KOHRAH_CODE,	// JMS
 		SIS_CODE,
 		SAMATRA_CODE,
 		URQUAN_DRONE_CODE };
@@ -71,34 +81,25 @@ load_ship (SPECIES_ID SpeciesID, BOOLEAN
 		goto BadLoad;
 	RDPtr->CodeRef = CodeRef;
 
-	if (RDPtr->ship_info.icons_rsc != NULL_RESOURCE)
+	RDPtr->ship_info.icons = CaptureDrawable (LoadGraphic (
+			RDPtr->ship_info.icons_rsc));
+	if (!RDPtr->ship_info.icons)
 	{
-		RDPtr->ship_info.icons = CaptureDrawable (LoadGraphic (
-				RDPtr->ship_info.icons_rsc));
-		if (!RDPtr->ship_info.icons)
-		{
-			/* goto BadLoad */
-		}
+		/* goto BadLoad */
 	}
-	
-	if (RDPtr->ship_info.melee_icon_rsc != NULL_RESOURCE)
+		
+	RDPtr->ship_info.melee_icon = CaptureDrawable (LoadGraphic (
+			RDPtr->ship_info.melee_icon_rsc));
+	if (!RDPtr->ship_info.melee_icon)
 	{
-		RDPtr->ship_info.melee_icon = CaptureDrawable (LoadGraphic (
-				RDPtr->ship_info.melee_icon_rsc));
-		if (!RDPtr->ship_info.melee_icon)
-		{
-			/* goto BadLoad */
-		}
+		/* goto BadLoad */
 	}
 
-	if (RDPtr->ship_info.race_strings_rsc != NULL_RESOURCE)
+	RDPtr->ship_info.race_strings =	CaptureStringTable (LoadStringTable (
+			RDPtr->ship_info.race_strings_rsc));
+	if (!RDPtr->ship_info.race_strings)
 	{
-		RDPtr->ship_info.race_strings =	CaptureStringTable (LoadStringTable (
-				RDPtr->ship_info.race_strings_rsc));
-		if (!RDPtr->ship_info.race_strings)
-		{
-			/* goto BadLoad */
-		}
+		/* goto BadLoad */
 	}
 
 	if (LoadBattleData)
diff -ruNp src.orig/uqm/master.c src/uqm/master.c
--- src.orig/uqm/master.c	2017-11-01 15:30:25 -0700
+++ src/uqm/master.c	2017-11-01 15:31:03 -0700
@@ -16,6 +16,13 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: -Slylandros-in-kohrah-vessel is ruled out from supermelee...
+//			 -...But the Sis ship is added into it
+//			 -Lurg ship likewise!
+//			 -As well as ISD
+
+// JMS 2011: - Added Baul & Foon-foon
+
 #include "master.h"
 
 #include "build.h"
@@ -23,6 +30,10 @@
 #include "displist.h"
 #include "supermelee/melee.h"
 
+#include "libs/log.h"
+
+
+#define NUM_OF_NEW_SHIPS (LAST_MELEE_ID - MMRNMHRM_ID)
 
 QUEUE master_q;
 
@@ -65,29 +76,84 @@ LoadMasterShipList (void (* YieldProcess
 		BuiltPtr->Fleet = RDPtr->fleet;
 		free_ship (RDPtr, FALSE, FALSE);
 
-		builtName = GetStringAddress (SetAbsStringTableIndex (
-				BuiltPtr->ShipInfo.race_strings, 2));
+		builtName = GetStringAddress (SetAbsStringTableIndex (BuiltPtr->ShipInfo.race_strings, 2));
 		UnlockMasterShip (&master_q, hBuiltShip);
 
 		// Insert the ship in the master queue in the right location
 		// to keep the list sorted on the name of the race.
-		for (hStarShip = GetHeadLink (&master_q);
-				hStarShip; hStarShip = hNextShip)
+		for (hStarShip = GetHeadLink (&master_q); hStarShip; hStarShip = hNextShip)
 		{
 			char *curName;
 			MASTER_SHIP_INFO *MasterPtr;
 
 			MasterPtr = LockMasterShip (&master_q, hStarShip);
 			hNextShip = _GetSuccLink (MasterPtr);
-			curName = GetStringAddress (SetAbsStringTableIndex (
-					MasterPtr->ShipInfo.race_strings, 2));
+			curName = GetStringAddress (SetAbsStringTableIndex (MasterPtr->ShipInfo.race_strings, 2));
 			UnlockMasterShip (&master_q, hStarShip);
+			
+			// JMS: Debug stuff.
+			// log_add (log_Debug, "%d:%s", num_entries, curName);
 
 			if (strcmp (builtName, curName) < 0)
 				break;
 		}
-		InsertQueue (&master_q, hBuiltShip, hStarShip);
-	}
+		
+		// JMS: Deal with original melee ships normally.
+		if(num_entries > (NUM_OF_NEW_SHIPS - 1))
+			InsertQueue (&master_q, hBuiltShip, hStarShip);
+
+		// JMS: New ships have to go last so they don't break the existing
+		// saved ship lists (in addition to creating all sorts of freaky shit).
+		else
+		{
+			// JMS: Baul goes last.
+			if(BuiltPtr->SpeciesID==BAUL_ID)
+				PutQueue (&master_q, hBuiltShip);
+			
+			// JMS: Foon-foon goes last.
+			else if(BuiltPtr->SpeciesID==FOONFOON_ID)
+				PutQueue (&master_q, hBuiltShip);
+			
+			// JMS: Lurg goes last.
+			else if(BuiltPtr->SpeciesID==LURG_ID)
+				PutQueue (&master_q, hBuiltShip);
+			
+			// JMS: ISD goes last.
+			else if(BuiltPtr->SpeciesID==ISD_ID)
+				PutQueue (&master_q, hBuiltShip);
+			
+			// JMS: Slykohr goes last.
+			else if(BuiltPtr->SpeciesID==SLYLANDRO_KOHRAH_ID)
+				PutQueue (&master_q, hBuiltShip);
+			
+			// JMS: Explorer goes second last, right before the Slykohr.
+			else if(BuiltPtr->SpeciesID==SIS_SHIP_ID)
+			{
+				hStarShip = GetTailLink (&master_q);			
+				InsertQueue (&master_q, hBuiltShip, hStarShip);
+			}
+			
+			// JMS: You can use the following lines to insert a ship before the last ship.
+			/*if (BuiltPtr->SpeciesID==SOME_SHIP_ID)
+			 {
+			 hStarShip = GetTailLink (&master_q);			
+			 InsertQueue (&master_q, hBuiltShip, hStarShip);
+			 }*/
+			
+			// JMS: Alternative way to do the same thing.
+			/*else if(BuiltPtr->SpeciesID==SIS_SHIP_ID)
+			{
+				MASTER_SHIP_INFO *MasterPtr;
+				
+				hStarShip = GetTailLink (&master_q);
+				MasterPtr = LockMasterShip (&master_q, hStarShip);
+				hNextShip = _GetPredLink (MasterPtr);
+				InsertQueue (&master_q, hBuiltShip, hNextShip);
+				UnlockMasterShip (&master_q, hStarShip);
+			}*/
+			
+		}
+	}		
 }
 
 void
@@ -213,5 +279,3 @@ GetShipMeleeIconsFromIndex (unsigned Ind
 
 	return val;
 }
-
-
diff -ruNp src.orig/uqm/menu.c src/uqm/menu.c
--- src.orig/uqm/menu.c	2017-11-01 15:30:25 -0700
+++ src/uqm/menu.c	2017-11-01 15:31:03 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
 #include "menustat.h"
 
 #include "colors.h"
@@ -79,7 +81,7 @@ static UNICODE pm_fuel_str[128];
 static void
 DrawPCMenu (BYTE beg_index, BYTE end_index, BYTE NewState, BYTE hilite, RECT *r)
 {
-#define PC_MENU_HEIGHT 8
+#define PC_MENU_HEIGHT (RES_STAT_SCALE(8)) // JMS_GFX
 	BYTE pos;
 	COUNT i;
 	int num_items;
@@ -101,7 +103,7 @@ DrawPCMenu (BYTE beg_index, BYTE end_ind
 	OldFont = SetContextFont (StarConFont);
 	t.align = ALIGN_LEFT;
 	t.baseline.x = r->corner.x + 2;
-	t.baseline.y = r->corner.y + PC_MENU_HEIGHT -1;
+	t.baseline.y = r->corner.y + PC_MENU_HEIGHT - (1 << RESOLUTION_FACTOR);// - RESOLUTION_FACTOR; // JMS_GFX
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 	r->corner.x++;
@@ -112,13 +114,14 @@ DrawPCMenu (BYTE beg_index, BYTE end_ind
 						(i == PM_FUEL) ? pm_fuel_str :
 						(i == PM_CREW) ? pm_crew_str :
 						GAME_STRING (MAINMENU_STRING_BASE + i));
+		
 		if (hilite && pos == i)
 		{
 			// Currently selected menu option.
 			
 			// Draw the background of the selection.
 			SetContextForeGroundColor (PCMENU_SELECTION_BACKGROUND_COLOR);
-			r->corner.y = t.baseline.y - PC_MENU_HEIGHT + 2;
+			r->corner.y = t.baseline.y - PC_MENU_HEIGHT + RES_STAT_SCALE(2);// + RESOLUTION_FACTOR; // JMS_GFX
 			r->extent.height = PC_MENU_HEIGHT - 1;
 			DrawFilledRectangle (r);
 
@@ -201,6 +204,11 @@ FixMenuState (BYTE BadState)
 				return PM_MUSIC_OFF;
 			else
 				return PM_MUSIC_ON;
+		case PM_VOICE_ON:
+			if (GLOBAL (glob_flags) & VOICE_DISABLED)
+				return (PM_VOICE_OFF);
+			else
+				return (PM_VOICE_ON);
 		case PM_CYBORG_OFF:
 			return (PM_CYBORG_OFF +
 				((BYTE)(GLOBAL (glob_flags) & COMBAT_SPEED_MASK) >>
@@ -227,6 +235,10 @@ NextMenuState (BYTE BaseState, BYTE CurS
 			break;
 		case PM_MUSIC_ON:
 		case PM_MUSIC_OFF:
+			NextState = PM_VOICE_ON;
+			break;
+		case PM_VOICE_ON:
+		case PM_VOICE_OFF:
 			NextState = PM_CYBORG_OFF;
 			break;
 		case PM_CYBORG_OFF:
@@ -262,11 +274,15 @@ PreviousMenuState (BYTE BaseState, BYTE
 		case PM_MUSIC_OFF:
 			NextState = PM_SOUND_ON;
 			break;
+		case PM_VOICE_ON:
+		case PM_VOICE_OFF:
+			NextState = PM_MUSIC_ON;
+			break;
 		case PM_CYBORG_OFF:
 		case PM_CYBORG_NORMAL:
 		case PM_CYBORG_DOUBLE:
 		case PM_CYBORG_SUPER:
-			NextState = PM_MUSIC_ON;
+			NextState = PM_VOICE_ON;
 			break;
 		case PM_CHANGE_CAPTAIN:
 			NextState = PM_CYBORG_OFF;
@@ -506,7 +522,7 @@ DrawMenuStateStrings (BYTE beg_index, SW
 	s.origin.x = RADAR_X - r.corner.x;
 	s.origin.y = RADAR_Y - r.corner.y;
 	r.corner.x = s.origin.x - 1;
-	r.corner.y = s.origin.y - 11;
+	r.corner.y = s.origin.y - (11 << RESOLUTION_FACTOR); // JMS_GFX
 	r.extent.width = RADAR_WIDTH + 2;
 	BatchGraphics ();
 	SetContextForeGroundColor (
@@ -523,7 +539,7 @@ DrawMenuStateStrings (BYTE beg_index, SW
 					 GLOBAL (FuelCost));
 		if (beg_index == PM_SOUND_ON)
 		{
-			end_index = beg_index + 5;
+			end_index = beg_index + 6;
 			switch (beg_index + NewState)
 			{
 				case PM_SOUND_ON:
@@ -534,24 +550,28 @@ DrawMenuStateStrings (BYTE beg_index, SW
 				case PM_MUSIC_OFF:
 					NewState = 1;
 					break;
+				case PM_VOICE_ON:
+				case PM_VOICE_OFF:
+					NewState = 2;
+					break;
 				case PM_CYBORG_OFF:
 				case PM_CYBORG_NORMAL:
 				case PM_CYBORG_DOUBLE:
 				case PM_CYBORG_SUPER:
-					NewState = 2;
+					NewState = 3;
 					break;
 				case PM_CHANGE_CAPTAIN:
-					NewState = 3;
+					NewState = 4;
 					break;
 				case PM_CHANGE_SHIP:
-					NewState = 4;
+					NewState = 5;
 					break;
 				case PM_EXIT_SETTINGS:
-					NewState = 5;
+					NewState = 6;
 					break;
 			}
 		}
-		r.extent.height = RADAR_HEIGHT + 11;
+		r.extent.height = RADAR_HEIGHT + (11 << RESOLUTION_FACTOR); // STATUS_HEIGHT - r.corner.y - 2; // JMS_GFX
 		DrawPCMenu (beg_index, end_index, (BYTE)NewState, hilite, &r);
 		s.frame = 0;
 	}
@@ -561,10 +581,11 @@ DrawMenuStateStrings (BYTE beg_index, SW
 		{
 			r.corner.x -= 1;
 			r.extent.width += 1;
-			r.extent.height = RADAR_HEIGHT + 11;
+			r.extent.height = RADAR_HEIGHT + (11 << RESOLUTION_FACTOR); // STATUS_HEIGHT - r.corner.y - 2; // JMS_GFX
 		}
 		else
-			r.extent.height = 11;
+			r.extent.height = 11 << RESOLUTION_FACTOR; // JMS_GFX
+		
 		DrawFilledRectangle (&r);
 	}
 	if (s.frame)
diff -ruNp src.orig/uqm/menustat.h src/uqm/menustat.h
--- src.orig/uqm/menustat.h	2017-11-01 15:30:25 -0700
+++ src/uqm/menustat.h	2017-11-01 15:31:03 -0700
@@ -90,6 +90,8 @@ enum
 	PM_SOUND_OFF,
 	PM_MUSIC_ON,
 	PM_MUSIC_OFF,
+	PM_VOICE_ON,
+	PM_VOICE_OFF,
 	PM_CYBORG_OFF,
 	PM_CYBORG_NORMAL,
 	PM_CYBORG_DOUBLE,
diff -ruNp src.orig/uqm/misc.c src/uqm/misc.c
--- src.orig/uqm/misc.c	2017-11-01 15:30:25 -0700
+++ src/uqm/misc.c	2017-11-01 15:31:03 -0700
@@ -16,6 +16,14 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: -Added do_instrument_damage which applies damage to ship instruments upon damaging hit.
+//			  Instrument damage is drawn from random number. The bigger the hit, the greater the
+//			  probability of instrument damage. do_instrument_damage is called from do_damage.
+//			  The damage numbers are defined in races.h
+//			
+//			 -One of the instrument damages is engine damage which is in separate function.
+//			  Engine damage works like how VUX limpets affect thrust.
+
 #include "element.h"
 #include "init.h"
 #include "races.h"
@@ -26,6 +34,8 @@
 #include "weapon.h"
 #include "libs/mathlib.h"
 
+#include "libs/log.h"
+
 
 void
 spawn_planet (void)
@@ -86,8 +96,13 @@ spawn_rubble (ELEMENT *AsteroidElementPt
 		RubbleElementPtr->turn_wait = RubbleElementPtr->next_turn = 0;
 		SetPrimType (&DisplayArray[RubbleElementPtr->PrimIndex], STAMP_PRIM);
 		RubbleElementPtr->current.image.farray = asteroid;
-		RubbleElementPtr->current.image.frame =
-				SetAbsFrameIndex (asteroid[0], ANGLE_TO_FACING (FULL_CIRCLE));
+		
+		// JMS_GFX
+		if (RESOLUTION_FACTOR == 0)
+			RubbleElementPtr->current.image.frame = SetAbsFrameIndex (asteroid[0], ANGLE_TO_FACING (FULL_CIRCLE));
+		else
+			RubbleElementPtr->current.image.frame = SetAbsFrameIndex (asteroid[0], 30);
+		
 		RubbleElementPtr->current.location = AsteroidElementPtr->current.location;
 		RubbleElementPtr->preprocess_func = animation_preprocess;
 		RubbleElementPtr->death_func = spawn_asteroid;
@@ -105,15 +120,19 @@ asteroid_preprocess (ELEMENT *ElementPtr
 		COUNT frame_index;
 
 		frame_index = GetFrameIndex (ElementPtr->current.image.frame);
+		
 		if (ElementPtr->thrust_wait & (1 << 7))
 			--frame_index;
 		else
 			++frame_index;
-		ElementPtr->next.image.frame =
-				SetAbsFrameIndex (ElementPtr->current.image.frame,
-				NORMALIZE_FACING (frame_index));
+		
+		// JMS_GFX
+		if (RESOLUTION_FACTOR == 0)
+			ElementPtr->next.image.frame = SetAbsFrameIndex (ElementPtr->current.image.frame, NORMALIZE_FACING (frame_index));
+		else
+			ElementPtr->next.image.frame = SetAbsFrameIndex (ElementPtr->current.image.frame, frame_index % 30);
+		
 		ElementPtr->state_flags |= CHANGING;
-
 		ElementPtr->turn_wait = (unsigned char)(ElementPtr->thrust_wait & ((1 << 7) - 1));
 	}
 }
@@ -144,19 +163,20 @@ spawn_asteroid (ELEMENT *ElementPtr)
 		AsteroidElementPtr->state_flags = APPEARING;
 		AsteroidElementPtr->life_span = NORMAL_LIFE;
 		SetPrimType (&DisplayArray[AsteroidElementPtr->PrimIndex], STAMP_PRIM);
+		
 		if ((val = (COUNT)TFB_Random ()) & (1 << 0))
 		{
 			if (!(val & (1 << 1)))
 				AsteroidElementPtr->current.location.x = 0;
 			else
 				AsteroidElementPtr->current.location.x = LOG_SPACE_WIDTH;
-			AsteroidElementPtr->current.location.y =
-					WRAP_Y (DISPLAY_ALIGN_Y (TFB_Random ()));
+			
+			AsteroidElementPtr->current.location.y = WRAP_Y (DISPLAY_ALIGN_Y (TFB_Random ()));
 		}
 		else
 		{
-			AsteroidElementPtr->current.location.x =
-					WRAP_X (DISPLAY_ALIGN_X (TFB_Random ()));
+			AsteroidElementPtr->current.location.x = WRAP_X (DISPLAY_ALIGN_X (TFB_Random ()));
+			
 			if (!(val & (1 << 1)))
 				AsteroidElementPtr->current.location.y = 0;
 			else
@@ -167,11 +187,9 @@ spawn_asteroid (ELEMENT *ElementPtr)
 			// Using these temporary variables because the execution order
 			// of function arguments may vary per system, which may break
 			// synchronisation on network games.
-			SIZE magnitude =
-					DISPLAY_TO_WORLD (((SIZE)TFB_Random () & 7) + 4);
+			SIZE magnitude = DISPLAY_TO_WORLD (((SIZE)TFB_Random () & 7) + 4);
 			COUNT facing = (COUNT)TFB_Random ();
-			SetVelocityVector (&AsteroidElementPtr->velocity, magnitude,
-					facing);
+			SetVelocityVector (&AsteroidElementPtr->velocity, magnitude, facing);
 		}
 		AsteroidElementPtr->current.image.farray = asteroid;
 		AsteroidElementPtr->current.image.frame =
@@ -191,11 +209,18 @@ spawn_asteroid (ELEMENT *ElementPtr)
 	}
 }
 
+// change this to 1 to enable instrument damage
+#define INSTRUMENT_DAMAGE_IS_ENABLED 0
+
 void
 do_damage (ELEMENT *ElementPtr, SIZE damage)
 {
 	if (ElementPtr->state_flags & PLAYER_SHIP)
 	{
+		// JMS: Calculate damage to ship instruments
+		if(INSTRUMENT_DAMAGE_IS_ENABLED)
+			do_instrument_damage(ElementPtr, damage);
+		
 		if (!DeltaCrew (ElementPtr, -damage))
 		{
 			ElementPtr->life_span = 0;
@@ -219,6 +244,72 @@ do_damage (ELEMENT *ElementPtr, SIZE dam
 		BUILD_COLOR (MAKE_RGB15 (0x00, 0x14, 0x00), 0x02)
 #define CREW_COLOR_HIGH_INTENSITY \
 		BUILD_COLOR (MAKE_RGB15 (0x0A, 0x1E, 0x0A), 0x0A)
+
+// JMS: Apply instrument damage to ship
+void
+do_instrument_damage (ELEMENT *ElementPtr, SIZE damage)
+{
+	// Make the necessary pointers
+	STARSHIP *StarShipPtr;
+	SHIP_INFO *ShipInfoPtr;
+	COUNT damage_probability;
+	BOOLEAN hit_damages_instruments;
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+	ShipInfoPtr = &StarShipPtr->RaceDescPtr->ship_info;
+	
+	// Calculate instrument damage probability based on a random number multiplied by the amount of crew damage
+#define INSTRUMENT_DAMAGE_THRESHOLD 1000 
+	damage_probability = (COUNT)TFB_Random () % 100;
+	hit_damages_instruments = (damage_probability*(10+damage) > 1000);
+	log_add (log_Info, "Damage %d\n", damage_probability*(10+damage));
+	
+	// Apply instrument damages if damage probability was big enough
+	if(hit_damages_instruments)
+	{
+		COUNT damagecounter=(COUNT)TFB_Random () % 3;
+		log_add (log_Info, "Damagecounter %d\n", damagecounter);
+		if (damagecounter == 0)
+			ShipInfoPtr->damage_flags |= DAMAGE_GAUGE_ENERGY;
+		if (damagecounter == 1)
+			ShipInfoPtr->damage_flags |= DAMAGE_GAUGE_CREW;
+		if (damagecounter == 2)
+			do_engine_damage(ElementPtr);
+	}
+}
+
+// JMS: Apply engine damage to ship (Copied from VUX limpet code)
+void
+do_engine_damage(ELEMENT *ElementPtr)
+{
+	STARSHIP *StarShipPtr2;
+	SHIP_INFO *ShipInfoPtr2;
+	GetElementStarShip (ElementPtr, &StarShipPtr2);
+	ShipInfoPtr2 = &StarShipPtr2->RaceDescPtr->ship_info;
+	
+	if (!(ShipInfoPtr2->damage_flags & DAMAGE_THRUST))
+	{
+		RACE_DESC *RDPtr;
+
+		GetElementStarShip (ElementPtr, &StarShipPtr2);
+		RDPtr = StarShipPtr2->RaceDescPtr;
+#define MIN_THRUST_INCREMENT DISPLAY_TO_WORLD (1)
+		if (RDPtr->characteristics.thrust_increment <= MIN_THRUST_INCREMENT)
+		{
+			RDPtr->characteristics.max_thrust =
+			RDPtr->characteristics.thrust_increment << 1;
+		}
+		else
+		{
+			COUNT num_thrusts;
+			num_thrusts = RDPtr->characteristics.max_thrust / RDPtr->characteristics.thrust_increment;
+			--RDPtr->characteristics.thrust_increment;
+			RDPtr->characteristics.max_thrust = RDPtr->characteristics.thrust_increment * num_thrusts;
+		}
+		RDPtr->cyborg_control.ManeuverabilityIndex = 0;
+		ShipInfoPtr2->damage_flags |= DAMAGE_THRUST;
+	}
+}
+	
 void
 crew_preprocess (ELEMENT *ElementPtr)
 {
@@ -251,7 +342,7 @@ crew_preprocess (ELEMENT *ElementPtr)
 
 	if (hTarget)
 	{
-#define CREW_DELTA SCALED_ONE
+#define CREW_DELTA (SCALED_ONE << RESOLUTION_FACTOR)
 		SIZE delta;
 		ELEMENT *ShipPtr;
 
diff -ruNp src.orig/uqm/oscill.c src/uqm/oscill.c
--- src.orig/uqm/oscill.c	2017-11-01 15:30:25 -0700
+++ src/uqm/oscill.c	2017-11-01 15:31:03 -0700
@@ -25,6 +25,7 @@
 #include "libs/sound/sound.h"
 #include "libs/sound/trackplayer.h"
 
+#include "libs/log.h"
 
 static FRAME scope_frame;
 static int scope_init = 0;
@@ -71,7 +72,7 @@ void
 DrawOscilloscope (void)
 {
 	STAMP s;
-	BYTE scope_data[128];
+	BYTE scope_data[192];
 
 	if (oscillDisabled)
 		return;
diff -ruNp src.orig/uqm/outfit.c src/uqm/outfit.c
--- src.orig/uqm/outfit.c	2017-11-01 15:30:25 -0700
+++ src/uqm/outfit.c	2017-11-01 15:31:03 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD. 
+
 #include "options.h"
 #include "colors.h"
 #include "controls.h"
@@ -57,20 +59,18 @@ DrawModuleStrings (MENU_STATE *pMS, BYTE
 	s.origin.x = RADAR_X - r.corner.x;
 	s.origin.y = RADAR_Y - r.corner.y;
 	r.corner.x = s.origin.x - 1;
-	r.corner.y = s.origin.y - 11;
+	r.corner.y = s.origin.y - (11 << RESOLUTION_FACTOR);
 	r.extent.width = RADAR_WIDTH + 2;
-	r.extent.height = 11;
+	r.extent.height = 11 << RESOLUTION_FACTOR;
 	BatchGraphics ();
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
+	SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
 	DrawFilledRectangle (&r);
 	if (NewModule >= EMPTY_SLOT)
 	{
 		r.corner = s.origin;
 		r.extent.width = RADAR_WIDTH;
 		r.extent.height = RADAR_HEIGHT;
-		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x00), 0x00));
+		SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x00), 0x00));
 		DrawFilledRectangle (&r);
 	}
 	else if (pMS->CurFrame)
@@ -80,15 +80,14 @@ DrawModuleStrings (MENU_STATE *pMS, BYTE
 
 		s.frame = SetAbsFrameIndex (pMS->CurFrame, NewModule);
 		DrawStamp (&s);
-		t.baseline.x = s.origin.x + RADAR_WIDTH - 2;
+		t.baseline.x = s.origin.x + RADAR_WIDTH  - 2;
 		t.baseline.y = s.origin.y + RADAR_HEIGHT - 2;
 		t.align = ALIGN_RIGHT;
 		t.CharCount = (COUNT)~0;
 		t.pStr = buf;
 		sprintf (buf, "%u", GLOBAL (ModuleCost[NewModule]) * MODULE_COST_SCALE);
 		SetContextFont (TinyFont);
-		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x00, 0x1F, 0x00), 0x02));
+		SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x00, 0x1F, 0x00), 0x02));
 		font_DrawText (&t);
 	}
 	UnbatchGraphics ();
@@ -103,45 +102,45 @@ RedistributeFuel (void)
 	RECT r;
 
 	FuelVolume = GLOBAL_SIS (FuelOnBoard);
-	if (FuelVolume <= FUEL_RESERVE)
+	if (FuelVolume <= EXPLORER_FUEL_VOLUME_PER_ROW) // FUEL_RESERVE)
 		return;
 
 	GLOBAL_SIS (FuelOnBoard) = 0;
-	m = FUEL_VOLUME_PER_ROW;
+	m = EXPLORER_FUEL_VOLUME_PER_ROW;
 
-	r.extent.width = 3;
-	r.extent.height = 1;
+	r.extent.width = 1;
 	while (FuelVolume -= m)
 	{
-		GLOBAL_SIS (FuelOnBoard) += FUEL_VOLUME_PER_ROW;
+		GLOBAL_SIS (FuelOnBoard) += EXPLORER_FUEL_VOLUME_PER_ROW;
 		GetFTankCapacity (&r.corner);
-		DrawPoint (&r.corner);
-		r.corner.x += r.extent.width + 1;
-		DrawPoint (&r.corner);
-		r.corner.x -= r.extent.width;
+		r.extent.height = RES_CASE(7, 10, 19); // JMS_GFX
+		DrawFilledRectangle (&r);
+		r.corner.y += RES_CASE(1,2,2);
+		r.extent.height = RES_CASE(5, 6, 15);
 		SetContextForeGroundColor (SetContextBackGroundColor (BLACK_COLOR));
 		DrawFilledRectangle (&r);
-		if (FuelVolume < FUEL_VOLUME_PER_ROW)
+		if (FuelVolume < EXPLORER_FUEL_VOLUME_PER_ROW)
 			m = (COUNT)FuelVolume;
 	}
 
 	FuelVolume = GLOBAL_SIS (FuelOnBoard) + m;
 
-	r.extent.width = 5;
-	while ((GLOBAL_SIS (FuelOnBoard) += FUEL_VOLUME_PER_ROW) <
-			GetFTankCapacity (&r.corner))
+	r.extent.height = RES_CASE(7, 10, 19); // JMS_GFX
+	while ((GLOBAL_SIS (FuelOnBoard) += EXPLORER_FUEL_VOLUME_PER_ROW) < GetFTankCapacity (&r.corner))
 	{
-		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x0B, 0x00, 0x00), 0x2E));
+		SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x0B, 0x00, 0x00), 0x2E));
 		DrawFilledRectangle (&r);
 	}
 
 	GLOBAL_SIS (FuelOnBoard) = FuelVolume;
 }
 
-#define LANDER_X 24
-#define LANDER_Y 67
-#define LANDER_WIDTH 15
+#define LANDER_X (24 << RESOLUTION_FACTOR) // JMS_GFX
+#define LANDER_Y (67 << RESOLUTION_FACTOR) // JMS_GFX
+
+#define EXPLORER_LANDER_X (180 << RESOLUTION_FACTOR) // JMS_GFX
+#define EXPLORER_LANDER_Y (18 << RESOLUTION_FACTOR) // JMS_GFX
+#define LANDER_WIDTH (15 << RESOLUTION_FACTOR) // JMS_GFX
 
 static void
 DisplayLanders (MENU_STATE *pMS)
@@ -159,8 +158,16 @@ DisplayLanders (MENU_STATE *pMS)
 	{
 		COUNT i;
 
-		s.origin.x = LANDER_X;
-		s.origin.y = LANDER_Y;
+		if ((GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS)) == 0)
+		{
+			s.origin.x = EXPLORER_LANDER_X;
+			s.origin.y = EXPLORER_LANDER_Y;
+		}
+		else
+		{
+			s.origin.x = LANDER_X;
+			s.origin.y = LANDER_Y;
+		}
 		for (i = 0; i < GLOBAL_SIS (NumLanders); ++i)
 		{
 			DrawStamp (&s);
@@ -290,8 +297,15 @@ DoInstallModule (MENU_STATE *pMS)
 				}
 				else if (old_slot_piece == STORAGE_BAY)
 				{
-					if (GLOBAL_SIS (TotalElementMass) > STORAGE_BAY_CAPACITY
-							* (CountSISPieces (STORAGE_BAY) - 1))
+					COUNT StorageBayCapacity; // JMS
+					
+					// JMS: Due to popular demand, let's give Explorer a small mineral storage bay!
+					if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == CHMMR_EXPLORER_SHIP)
+						StorageBayCapacity = EXPLORER_STORAGE_BAY_CAPACITY;
+					else
+						StorageBayCapacity = STORAGE_BAY_CAPACITY;
+					
+					if (GLOBAL_SIS (TotalElementMass) > StorageBayCapacity * (CountSISPieces (STORAGE_BAY) - 1))
 					{	// storage bay still needed for the cargo
 						PlayMenuSound (MENU_SOUND_FAILURE);
 						return (TRUE);
@@ -403,8 +417,14 @@ DoInstallModule (MENU_STATE *pMS)
 		do
 		{
 			if (NewState >= EMPTY_SLOT && (PulsedInputState.menu[KEY_MENU_UP] || PulsedInputState.menu[KEY_MENU_DOWN]))
-			{
-				if (PulsedInputState.menu[KEY_MENU_UP])
+			  {
+			    // BW: Explorer has only lander slots
+			    if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == CHMMR_EXPLORER_SHIP)
+			      {
+			      }
+			    else
+			      {
+			        if (PulsedInputState.menu[KEY_MENU_UP])
 				{
 					if (NewState-- == EMPTY_SLOT)
 						NewState = EMPTY_SLOT + 3;
@@ -415,7 +435,8 @@ DoInstallModule (MENU_STATE *pMS)
 						NewState = EMPTY_SLOT;
 				}
 				NewItem = 0;
-				if (GET_GAME_STATE (CHMMR_BOMB_STATE) == 3)
+			      }
+			    if (GET_GAME_STATE (CHMMR_BOMB_STATE) == 3)
 				{
 					if (NewState == EMPTY_SLOT + 3)
 						NewState = PulsedInputState.menu[KEY_MENU_UP] ?
@@ -423,7 +444,7 @@ DoInstallModule (MENU_STATE *pMS)
 					if (NewState == EMPTY_SLOT + 2)
 						NewItem = NUM_BOMB_MODULES;
 				}
-				pMS->delta_item = NewItem;
+			    pMS->delta_item = NewItem;
 			}
 			else if (PulsedInputState.menu[KEY_MENU_LEFT] ||
 					PulsedInputState.menu[KEY_MENU_UP])
@@ -461,8 +482,7 @@ DoInstallModule (MENU_STATE *pMS)
 			{
 				case PLANET_LANDER:
 				case EMPTY_SLOT + 3:
-					new_slot_piece = NewItem < GLOBAL_SIS (NumLanders)
-							? PLANET_LANDER : (EMPTY_SLOT + 3);
+					new_slot_piece = NewItem < GLOBAL_SIS (NumLanders) ? PLANET_LANDER : (EMPTY_SLOT + 3);
 					break;
 				case FUSION_THRUSTER:
 				case EMPTY_SLOT + 0:
@@ -499,10 +519,18 @@ InitFlash:
 				{
 					case PLANET_LANDER:
 					case EMPTY_SLOT + 3:
-						pMS->flash_rect0.corner.x = LANDER_X - 1;
-						pMS->flash_rect0.corner.y = LANDER_Y - 1;
-						pMS->flash_rect0.extent.width = 11 + 2;
-						pMS->flash_rect0.extent.height = 13 + 2;
+						if ((GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS)) == 0)
+						{
+							pMS->flash_rect0.corner.x = EXPLORER_LANDER_X - (1 << RESOLUTION_FACTOR); // JMS_GFX
+							pMS->flash_rect0.corner.y = EXPLORER_LANDER_Y - (1 << RESOLUTION_FACTOR); // JMS_GFX
+						}
+						else
+						{
+							pMS->flash_rect0.corner.x = LANDER_X - (1 << RESOLUTION_FACTOR); // JMS_GFX
+							pMS->flash_rect0.corner.y = LANDER_Y - (1 << RESOLUTION_FACTOR); // JMS_GFX
+						}
+						pMS->flash_rect0.extent.width = RES_CASE(11 + 2, 22 + 4, 40 + 8); // JMS_GFX
+						pMS->flash_rect0.extent.height = RES_CASE(13 + 2, 26 + 4, 48 + 8); // JMS_GFX
 
 						w = LANDER_WIDTH;
 						break;
@@ -510,23 +538,23 @@ InitFlash:
 					case EMPTY_SLOT + 0:
 						pMS->flash_rect0.corner.x = DRIVE_TOP_X - 1;
 						pMS->flash_rect0.corner.y = DRIVE_TOP_Y - 1;
-						pMS->flash_rect0.extent.width = 8;
-						pMS->flash_rect0.extent.height = 6;
+						pMS->flash_rect0.extent.width = 8 << RESOLUTION_FACTOR; // JMS_GFX
+						pMS->flash_rect0.extent.height = 6 << RESOLUTION_FACTOR; // JMS_GFX
 
 						break;
 					case TURNING_JETS:
 					case EMPTY_SLOT + 1:
 						pMS->flash_rect0.corner.x = JET_TOP_X - 1;
 						pMS->flash_rect0.corner.y = JET_TOP_Y - 1;
-						pMS->flash_rect0.extent.width = 9;
-						pMS->flash_rect0.extent.height = 10;
+						pMS->flash_rect0.extent.width = 9 << RESOLUTION_FACTOR; // JMS_GFX
+						pMS->flash_rect0.extent.height = 10 << RESOLUTION_FACTOR; // JMS_GFX
 
 						break;
 					default:
 						pMS->flash_rect0.corner.x = MODULE_TOP_X - 1;
 						pMS->flash_rect0.corner.y = MODULE_TOP_Y - 1;
 						pMS->flash_rect0.extent.width = SHIP_PIECE_OFFSET + 2;
-						pMS->flash_rect0.extent.height = 34;
+						pMS->flash_rect0.extent.height = 34 << RESOLUTION_FACTOR; // JMS_GFX
 
 						break;
 				}
@@ -553,7 +581,7 @@ ChangeFuelQuantity (void)
 {
 	RECT r;
 	
-	r.extent.height = 1;
+	r.extent.width = 1 << RESOLUTION_FACTOR; // JMS_GFX
 	
 	if (PulsedInputState.menu[KEY_MENU_UP])
 	{
@@ -562,17 +590,7 @@ ChangeFuelQuantity (void)
 		if (GetFTankCapacity (&r.corner) > GLOBAL_SIS (FuelOnBoard)
 			&& GLOBAL_SIS (ResUnits) >= (DWORD)GLOBAL (FuelCost))
 		{
-			if (GLOBAL_SIS (FuelOnBoard) >= FUEL_RESERVE)
-			{
-				r.extent.width = 3;
-				DrawPoint (&r.corner);
-				r.corner.x += r.extent.width + 1;
-				DrawPoint (&r.corner);
-				r.corner.x -= r.extent.width;
-				SetContextForeGroundColor (
-						SetContextBackGroundColor (BLACK_COLOR));
-				DrawFilledRectangle (&r);
-			}
+			RedistributeFuel();
 			DeltaSISGauges (0, FUEL_TANK_SCALE, -GLOBAL (FuelCost));
 			SetContext (StatusContext);
 			GetGaugeRect (&r, FALSE);
@@ -590,16 +608,9 @@ ChangeFuelQuantity (void)
 		SetContext (SpaceContext);
 		if (GLOBAL_SIS (FuelOnBoard))
 		{
-			DeltaSISGauges (0, -FUEL_TANK_SCALE, GLOBAL (FuelCost));
-			if (GLOBAL_SIS (FuelOnBoard) % FUEL_VOLUME_PER_ROW == 0 &&
-					GLOBAL_SIS (FuelOnBoard) >= FUEL_RESERVE)
-			{
-				GetFTankCapacity (&r.corner);
-				SetContextForeGroundColor (
-						BUILD_COLOR (MAKE_RGB15 (0x0B, 0x00, 0x00), 0x2E));
-				r.extent.width = 5;
-				DrawFilledRectangle (&r);
-			}
+			DeltaSISGauges (0, -FUEL_TANK_SCALE,
+				GLOBAL (FuelCost));
+			RedistributeFuel();
 		}
 		else
 		{	// no fuel left to drain
@@ -645,8 +656,13 @@ DoOutfit (MENU_STATE *pMS)
 			pMS->ModuleFrame = CaptureDrawable (
 					LoadGraphic (SISMODS_MASK_PMAP_ANIM));
 			s.origin.x = s.origin.y = 0;
+
 			s.frame = CaptureDrawable (
 					LoadGraphic (OUTFIT_PMAP_ANIM));
+			if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == CHMMR_EXPLORER_SHIP)
+			  {
+				s.frame = SetAbsFrameIndex(s.frame, 1);
+			  }
 
 			LockMutex (GraphicsLock);
 			SetTransitionSource (NULL);
@@ -660,54 +676,59 @@ DoOutfit (MENU_STATE *pMS)
 			DrawStamp (&s);
 			DestroyDrawable (ReleaseDrawable (s.frame));
 
-			for (num_frames = 0; num_frames < NUM_DRIVE_SLOTS; ++num_frames)
+			if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == CHMMR_EXPLORER_SHIP)
 			{
-				BYTE which_piece;
-
-				which_piece = GLOBAL_SIS (DriveSlots[num_frames]);
-				if (which_piece < EMPTY_SLOT)
-					DrawShipPiece (pMS->ModuleFrame, which_piece,
-							num_frames, FALSE);
+				RedistributeFuel ();
+				DisplayLanders (pMS);
 			}
-			for (num_frames = 0; num_frames < NUM_JET_SLOTS; ++num_frames)
+			else
 			{
-				BYTE which_piece;
+				for (num_frames = 0; num_frames < NUM_DRIVE_SLOTS; ++num_frames)
+				{
+					BYTE which_piece;
 
-				which_piece = GLOBAL_SIS (JetSlots[num_frames]);
-				if (which_piece < EMPTY_SLOT)
-					DrawShipPiece (pMS->ModuleFrame, which_piece,
-						num_frames, FALSE);
-			}
-			for (num_frames = 0; num_frames < NUM_MODULE_SLOTS; ++num_frames)
-			{
-				BYTE which_piece;
+					which_piece = GLOBAL_SIS (DriveSlots[num_frames]);
+					if (which_piece < EMPTY_SLOT)
+						DrawShipPiece (pMS->ModuleFrame, which_piece, num_frames, FALSE);
+				}
+				for (num_frames = 0; num_frames < NUM_JET_SLOTS; ++num_frames)
+				{
+					BYTE which_piece;
 
-				which_piece = GLOBAL_SIS (ModuleSlots[num_frames]);
-				if (which_piece < EMPTY_SLOT)
-					DrawShipPiece (pMS->ModuleFrame, which_piece,
-							num_frames, FALSE);
-			}
-			RedistributeFuel ();
-			DisplayLanders (pMS);
-			if (GET_GAME_STATE (CHMMR_BOMB_STATE) < 3)
-			{
-				BYTE ShieldFlags;
-				
-				ShieldFlags = GET_GAME_STATE (LANDER_SHIELDS);
+					which_piece = GLOBAL_SIS (JetSlots[num_frames]);
+					if (which_piece < EMPTY_SLOT)
+						DrawShipPiece (pMS->ModuleFrame, which_piece, num_frames, FALSE);
+				}
+				for (num_frames = 0; num_frames < NUM_MODULE_SLOTS; ++num_frames)
+				{
+					BYTE which_piece;
 
-				s.frame = SetAbsFrameIndex (pMS->ModuleFrame,
-						GetFrameCount (pMS->ModuleFrame) - 5);
-				if (ShieldFlags & (1 << EARTHQUAKE_DISASTER))
-					DrawStamp (&s);
-				s.frame = IncFrameIndex (s.frame);
-				if (ShieldFlags & (1 << BIOLOGICAL_DISASTER))
-					DrawStamp (&s);
-				s.frame = IncFrameIndex (s.frame);
-				if (ShieldFlags & (1 << LIGHTNING_DISASTER))
-					DrawStamp (&s);
-				s.frame = IncFrameIndex (s.frame);
-				if (ShieldFlags & (1 << LAVASPOT_DISASTER))
-					DrawStamp (&s);
+					which_piece = GLOBAL_SIS (ModuleSlots[num_frames]);
+					if (which_piece < EMPTY_SLOT)
+						DrawShipPiece (pMS->ModuleFrame, which_piece, num_frames, FALSE);
+				}
+				RedistributeFuel ();
+				DisplayLanders (pMS);
+				if (GET_GAME_STATE (CHMMR_BOMB_STATE) < 3)
+				{
+					BYTE ShieldFlags;
+					
+					ShieldFlags = GET_GAME_STATE (LANDER_SHIELDS);
+
+					s.frame = SetAbsFrameIndex (pMS->ModuleFrame,
+							GetFrameCount (pMS->ModuleFrame) - 5);
+					if (ShieldFlags & (1 << EARTHQUAKE_DISASTER))
+						DrawStamp (&s);
+					s.frame = IncFrameIndex (s.frame);
+					if (ShieldFlags & (1 << BIOLOGICAL_DISASTER))
+						DrawStamp (&s);
+					s.frame = IncFrameIndex (s.frame);
+					if (ShieldFlags & (1 << LIGHTNING_DISASTER))
+						DrawStamp (&s);
+					s.frame = IncFrameIndex (s.frame);
+					if (ShieldFlags & (1 << LAVASPOT_DISASTER))
+						DrawStamp (&s);
+				}
 			}
 
 			UnlockMutex (GraphicsLock);
@@ -781,7 +802,7 @@ ExitOutfit:
 				UnlockMutex (GraphicsLock);
 				break;
 			case OUTFIT_MODULES:
-				pMS->CurState = EMPTY_SLOT + 2;
+				pMS->CurState = EMPTY_SLOT+3;
 				if (GET_GAME_STATE (CHMMR_BOMB_STATE) != 3)
 					pMS->delta_item = 0;
 				else
diff -ruNp src.orig/uqm/pickship.c src/uqm/pickship.c
--- src.orig/uqm/pickship.c	2017-11-01 15:30:25 -0700
+++ src/uqm/pickship.c	2017-11-01 15:31:03 -0700
@@ -16,6 +16,10 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: Chmmr Explorer and precursor vessel now have different graphics for ship picking before fight in full game.
+
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
 #include "pickship.h"
 
 #include "build.h"
@@ -33,17 +37,25 @@
 #include "sounds.h"
 #include "libs/mathlib.h"
 
+#include "libs/log.h"
 
 #define NUM_PICK_SHIP_ROWS 2
 #define NUM_PICK_SHIP_COLUMNS 6
 
-#define ICON_WIDTH 16
-#define ICON_HEIGHT 16
+#define NUM_PICK_SHIP_EXPLORER_COLUMNS 4
+
+#define ICON_WIDTH (16 << RESOLUTION_FACTOR)				// JMS_GFX
+#define ICON_HEIGHT (16 << RESOLUTION_FACTOR)				// JMS_GFX
 
-#define FLAGSHIP_X_OFFS 65
-#define FLAGSHIP_Y_OFFS 4
-#define FLAGSHIP_WIDTH 22
-#define FLAGSHIP_HEIGHT 48
+#define FLAGSHIP_X_OFFS (65 << RESOLUTION_FACTOR)			// JMS_GFX
+#define FLAGSHIP_Y_OFFS (4 << RESOLUTION_FACTOR)			// JMS_GFX
+#define FLAGSHIP_WIDTH (22 << RESOLUTION_FACTOR)			// JMS_GFX
+#define FLAGSHIP_HEIGHT (48 << RESOLUTION_FACTOR)			// JMS_GFX
+
+#define FLAGSHIP_EXPLORER_WIDTH (36 << RESOLUTION_FACTOR)	// JMS_GFX
+#define FLAGSHIP_EXPLORER_HEIGHT (36 << RESOLUTION_FACTOR)	// JMS_GFX
+#define FLAGSHIP_EXPLORER_X_OFFS (58 << RESOLUTION_FACTOR)	// JMS_GFX
+#define FLAGSHIP_EXPLORER_Y_OFFS (16 << RESOLUTION_FACTOR)	// JMS_GFX
 
 static BOOLEAN
 DoPickBattleShip (MENU_STATE *pMS)
@@ -84,6 +96,7 @@ DoPickBattleShip (MENU_STATE *pMS)
 
 		new_col = pMS->first_item.x + dx;
 		new_row = pMS->first_item.y + dy;
+
 		if (new_row != pMS->first_item.y
 				|| new_col != pMS->first_item.x)
 		{
@@ -93,16 +106,47 @@ DoPickBattleShip (MENU_STATE *pMS)
 			COUNT ship_index;
 			HSTARSHIP hBattleShip, hNextShip;
 			STARSHIP *StarShipPtr;
-
-			if (new_col < 0)
-				new_col = NUM_PICK_SHIP_COLUMNS;
-			else if (new_col > NUM_PICK_SHIP_COLUMNS)
-				new_col = 0;
-
-			if (new_row < 0)
-				new_row = NUM_PICK_SHIP_ROWS - 1;
-			else if (new_row == NUM_PICK_SHIP_ROWS)
-				new_row = 0;
+			
+			COUNT num_cols;
+			
+			// JMS: Chmmr Explorer gfx
+			if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == CHMMR_EXPLORER_SHIP)
+			{
+				if (new_row == 0 && new_col < 0)
+					new_col = NUM_PICK_SHIP_EXPLORER_COLUMNS;
+				else if (new_row > 0 && new_col < 0)
+					new_col = 1;
+				else if ( (new_row == 0 && new_col > NUM_PICK_SHIP_EXPLORER_COLUMNS) || (new_row > 0 && new_col > 1 ) )
+					new_col = 0;
+				
+				if (new_row == 0 && pMS->first_item.x == 1 && pMS->first_item.y == 1)
+					new_col = 3;
+				else if (new_row == 0 && pMS->first_item.x == 0 && pMS->first_item.y == 1)
+					new_col = 1;
+				
+				if ((new_row == 1 || new_row < 0) && pMS->first_item.x < 2 && pMS->first_item.y == 0)
+					new_col = 0;
+				else if ((new_row == 1 || new_row < 0) && pMS->first_item.x > 2 && pMS->first_item.y == 0)
+					new_col = 1;
+	
+				if (new_row < 0)
+					new_row = NUM_PICK_SHIP_ROWS - 1;
+				else if (new_row == NUM_PICK_SHIP_ROWS)
+					new_row = 0;
+			}
+			// JMS: Precursor vessel gfx
+			else if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == PRECURSOR_SERVICE_VEHICLE)
+			{
+				if (new_col < 0)
+					new_col = NUM_PICK_SHIP_COLUMNS;
+				else if (new_col > NUM_PICK_SHIP_COLUMNS)
+					new_col = 0;
+
+				if (new_row < 0)
+					new_row = NUM_PICK_SHIP_ROWS - 1;
+				else if (new_row == NUM_PICK_SHIP_ROWS)
+					new_row = 0;
+			}
 
 			PlayMenuSound (MENU_SOUND_MOVE);
 
@@ -117,35 +161,86 @@ DoPickBattleShip (MENU_STATE *pMS)
 			pMS->first_item.x = new_col;
 
 ChangeSelection:
-			if (pMS->first_item.x == (NUM_PICK_SHIP_COLUMNS >> 1))
+			// JMS
+			if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == CHMMR_EXPLORER_SHIP)
+				num_cols = NUM_PICK_SHIP_EXPLORER_COLUMNS;
+			else if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == PRECURSOR_SERVICE_VEHICLE)
+				num_cols = NUM_PICK_SHIP_COLUMNS;
+			
+			if (pMS->first_item.x == (num_cols >> 1))
 			{
-				pMS->flash_rect0.corner.x =
-						pMS->flash_rect1.corner.x - 2 + FLAGSHIP_X_OFFS;
-				pMS->flash_rect0.corner.y =
-						pMS->flash_rect1.corner.y - 2 + FLAGSHIP_Y_OFFS;
-				pMS->flash_rect0.extent.width = FLAGSHIP_WIDTH + 4;
-				pMS->flash_rect0.extent.height = FLAGSHIP_HEIGHT + 4;
+				// JMS: Chmmr Explorer graphics
+				if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == CHMMR_EXPLORER_SHIP)
+				{
+					pMS->flash_rect0.corner.x = pMS->flash_rect1.corner.x + FLAGSHIP_EXPLORER_X_OFFS - (2 << RESOLUTION_FACTOR) - 1 * RESOLUTION_FACTOR; // JMS_GFX
+					pMS->flash_rect0.corner.y = pMS->flash_rect1.corner.y + FLAGSHIP_EXPLORER_Y_OFFS - 3 * RESOLUTION_FACTOR; // JMS_GFX
+					pMS->flash_rect0.extent.width  = FLAGSHIP_EXPLORER_WIDTH  + (4 << RESOLUTION_FACTOR); // JMS_GFX
+					pMS->flash_rect0.extent.height = FLAGSHIP_EXPLORER_HEIGHT + (4 << RESOLUTION_FACTOR) - 3 * RESOLUTION_FACTOR; // JMS_GFX
+				}
+				// JMS: Precursor vessel graphics
+				else if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == PRECURSOR_SERVICE_VEHICLE)
+				{
+					pMS->flash_rect0.corner.x = pMS->flash_rect1.corner.x - (2 << RESOLUTION_FACTOR) + FLAGSHIP_X_OFFS; // JMS_GFX
+					pMS->flash_rect0.corner.y = pMS->flash_rect1.corner.y - (2 << RESOLUTION_FACTOR) + FLAGSHIP_Y_OFFS; // JMS_GFX
+					pMS->flash_rect0.extent.width  = FLAGSHIP_WIDTH  + (4 << RESOLUTION_FACTOR); // JMS_GFX
+					pMS->flash_rect0.extent.height = FLAGSHIP_HEIGHT + 4;
+				}
 
 				hBattleShip = GetTailLink (&race_q[0]); /* Flagship */
 			}
+			// Escort ships
 			else
 			{
-				new_col = pMS->first_item.x;
-				pMS->flash_rect0.corner.x = 5 + pMS->flash_rect1.corner.x - 2
-						+ ((ICON_WIDTH + 4) * new_col);
-				if (new_col > (NUM_PICK_SHIP_COLUMNS >> 1))
+				// The Escort ships of Chmmr Explorer
+				if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == CHMMR_EXPLORER_SHIP)
 				{
-					--new_col;
-					pMS->flash_rect0.corner.x += FLAGSHIP_WIDTH - ICON_WIDTH;
+					new_col = pMS->first_item.x;
+					pMS->flash_rect0.corner.x = pMS->flash_rect1.corner.x + ((9 - 2) << RESOLUTION_FACTOR)
+					+ ((ICON_WIDTH + (8 << RESOLUTION_FACTOR)) * new_col) + (RESOLUTION_FACTOR); // JMS_GFX
+					
+					if (new_col > (NUM_PICK_SHIP_EXPLORER_COLUMNS >> 1))
+					{
+						--new_col;
+						pMS->flash_rect0.corner.x += FLAGSHIP_EXPLORER_WIDTH - ICON_WIDTH
+						+ (2 << RESOLUTION_FACTOR);// + (RESOLUTION_FACTOR - 1); // JMS_GFX
+					}
+					if (new_row > 0)
+					{
+						pMS->flash_rect0.corner.x += (ICON_WIDTH + (8 << RESOLUTION_FACTOR)); // JMS_GFX
+						pMS->flash_rect0.corner.x += (FLAGSHIP_EXPLORER_WIDTH + (10 << RESOLUTION_FACTOR)) * new_col; // JMS_GFX
+					}
+					
+					pMS->flash_rect0.corner.y = pMS->flash_rect1.corner.y + ((16 - 2) << RESOLUTION_FACTOR)
+					+ ((ICON_HEIGHT + (4 << RESOLUTION_FACTOR)) * pMS->first_item.y) + RESOLUTION_FACTOR; // JMS_GFX
+					pMS->flash_rect0.extent.width = ICON_WIDTH + (4 << RESOLUTION_FACTOR) - 2 * RESOLUTION_FACTOR; // JMS_GFX
+					pMS->flash_rect0.extent.height = ICON_HEIGHT + (4 << RESOLUTION_FACTOR) - 2 * RESOLUTION_FACTOR; // JMS_GFX
+					
+					ship_index = (pMS->first_item.y * NUM_PICK_SHIP_EXPLORER_COLUMNS)
+					+ new_col;
 				}
-				pMS->flash_rect0.corner.y = 16 + pMS->flash_rect1.corner.y - 2
-						+ ((ICON_HEIGHT + 4) * pMS->first_item.y);
-				pMS->flash_rect0.extent.width = ICON_WIDTH + 4;
-				pMS->flash_rect0.extent.height = ICON_HEIGHT + 4;
+				
+				// The Escort ships of Precursor vessel
+				else if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == PRECURSOR_SERVICE_VEHICLE)
+				{
+					new_col = pMS->first_item.x;
+					pMS->flash_rect0.corner.x = pMS->flash_rect1.corner.x + ((5 - 2) << RESOLUTION_FACTOR)
+						+ ((ICON_WIDTH + (4 << RESOLUTION_FACTOR)) * new_col);
+					
+					if (new_col > (NUM_PICK_SHIP_COLUMNS >> 1))
+					{
+						--new_col;
+						pMS->flash_rect0.corner.x += FLAGSHIP_WIDTH - ICON_WIDTH;
+					}
+					
+					pMS->flash_rect0.corner.y = pMS->flash_rect1.corner.y + ((16 - 2) << RESOLUTION_FACTOR)
+						+ ((ICON_HEIGHT + (4 << RESOLUTION_FACTOR)) * pMS->first_item.y); // JMS_GFX
+					pMS->flash_rect0.extent.width = ICON_WIDTH + (4 << RESOLUTION_FACTOR); // JMS_GFX
+					pMS->flash_rect0.extent.height = ICON_HEIGHT + (4 << RESOLUTION_FACTOR); // JMS_GFX
 
-				ship_index = (pMS->first_item.y * NUM_PICK_SHIP_COLUMNS)
+					ship_index = (pMS->first_item.y * NUM_PICK_SHIP_COLUMNS)
 						+ new_col;
-
+				}
+				
 				for (hBattleShip = GetHeadLink (&race_q[0]);
 						hBattleShip != GetTailLink (&race_q[0]);
 						hBattleShip = hNextShip)
@@ -168,11 +263,12 @@ ChangeSelection:
 
 			pMS->CurFrame = (FRAME)hBattleShip;
 
+			// Black box for ship's captain's name
 			SetContextForeGroundColor (BLACK_COLOR);
-			r.corner.x = pMS->flash_rect1.corner.x + 6;
-			r.corner.y = pMS->flash_rect1.corner.y + 5;
-			r.extent.width = ((ICON_WIDTH + 4) * 3) - 4;
-			r.extent.height = 7;
+			r.corner.x = pMS->flash_rect1.corner.x + (6 << RESOLUTION_FACTOR)- 2 * RESOLUTION_FACTOR; // JMS_GFX
+			r.corner.y = pMS->flash_rect1.corner.y + (5 << RESOLUTION_FACTOR) - 1 * RESOLUTION_FACTOR; // JMS_GFX
+			r.extent.width = ((ICON_WIDTH + (4 << RESOLUTION_FACTOR)) * 3) - (4 << RESOLUTION_FACTOR); // JMS_GFX
+			r.extent.height = (7 << RESOLUTION_FACTOR) - 1 * RESOLUTION_FACTOR; // JMS_GFX
 			DrawFilledRectangle (&r);
 
 			if (hBattleShip == 0)
@@ -186,7 +282,7 @@ ChangeSelection:
 				SetContextFont (TinyFont);
 
 				t.baseline.x = r.corner.x + (r.extent.width >> 1);
-				t.baseline.y = r.corner.y + (r.extent.height - 1);
+				t.baseline.y = r.corner.y + (r.extent.height - 1) - 2 * RESOLUTION_FACTOR; // JMS_GFX
 				t.align = ALIGN_CENTER;
 
 				StarShipPtr = LockStarShip (&race_q[0], hBattleShip);
@@ -217,9 +313,10 @@ ChangeSelection:
 				SetContextForeGroundColor (BLACK_COLOR);
 			}
 
-			r.corner.x += (ICON_WIDTH + 4)
+			// Black box for crew amount text
+			r.corner.x += (ICON_WIDTH + (4 << RESOLUTION_FACTOR))
 					* ((NUM_PICK_SHIP_COLUMNS >> 1) + 1)
-					+ FLAGSHIP_WIDTH - ICON_WIDTH;
+					+ FLAGSHIP_WIDTH - ICON_WIDTH; // JMS_GFX
 			DrawFilledRectangle (&r);
 
 			if (crew_level)
@@ -264,7 +361,7 @@ GetArmadaStarShip (void)
 	
 //    MenuSounds = CaptureSound (LoadSound (MENU_SOUNDS));
 
-OldContext = SetContext (SpaceContext);
+	OldContext = SetContext (SpaceContext);
 	DrawArmadaPickShip (FALSE, &pick_r);
 
 	{
@@ -272,7 +369,10 @@ OldContext = SetContext (SpaceContext);
 
 		MenuState.InputFunc = DoPickBattleShip;
 		MenuState.Initialized = FALSE;
-		MenuState.first_item.x = NUM_PICK_SHIP_COLUMNS >> 1;
+		if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == CHMMR_EXPLORER_SHIP)
+			MenuState.first_item.x = NUM_PICK_SHIP_EXPLORER_COLUMNS >> 1;
+		else
+			MenuState.first_item.x = NUM_PICK_SHIP_COLUMNS >> 1;
 		MenuState.first_item.y = 0;
 		MenuState.CurFrame = 0;
 		MenuState.flash_rect1.corner = pick_r.corner;
@@ -410,6 +510,11 @@ DrawArmadaPickShip (BOOLEAN draw_salvage
 	BatchGraphics ();
 
 	s.frame = PickFrame;
+	
+	// JMS: Correct graphics for Chmmr Explorer (for ship picking in full game before fight.)
+	if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == CHMMR_EXPLORER_SHIP)
+		s.frame = IncFrameIndex (s.frame);
+	
 	SetFrameHot (s.frame, MAKE_HOT_SPOT (0, 0));
 	GetFrameRect (s.frame, &pick_r);
 	GetContextClipRect (&r);
@@ -427,6 +532,11 @@ DrawArmadaPickShip (BOOLEAN draw_salvage
 		s.origin.x -= r.extent.width >> 1;
 		s.origin.y = pick_r.corner.y - (r.extent.height >> 1);
 		DrawStamp (&s);
+		
+		// JMS: Correct graphics for Precursor vessel (for ship picking in full game before fight)
+		if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS)== PRECURSOR_SERVICE_VEHICLE)
+			s.frame = DecFrameIndex (s.frame);
+		
 		s.frame = DecFrameIndex (s.frame);
 		pick_r.corner.y = s.origin.y + r.extent.height;
 
@@ -438,7 +548,7 @@ DrawArmadaPickShip (BOOLEAN draw_salvage
 	DrawStamp (&s);
 
 	t.baseline.x = pick_r.corner.x + (pick_r.extent.width >> 1);
-	t.baseline.y = pick_r.corner.y + pick_r.extent.height - 5;
+	t.baseline.y = pick_r.corner.y + pick_r.extent.height - (5 << RESOLUTION_FACTOR) - 2 * RESOLUTION_FACTOR; // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.pStr = GLOBAL_SIS (ShipName);
 	t.CharCount = (COUNT)~0;
@@ -460,19 +570,48 @@ DrawArmadaPickShip (BOOLEAN draw_salvage
 
 			ship_index = StarShipPtr->index;
 
-			s.origin.x = pick_r.corner.x
-					+ (5 + ((ICON_WIDTH + 4)
-					* (ship_index % NUM_PICK_SHIP_COLUMNS)));
-			if ((ship_index % NUM_PICK_SHIP_COLUMNS) >=
+			// JMS: Chmmr explorer graphics
+			if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == CHMMR_EXPLORER_SHIP)
+			{
+				s.origin.x = pick_r.corner.x
+				+ ((9 << RESOLUTION_FACTOR) + ((ICON_WIDTH + (8 << RESOLUTION_FACTOR))
+						* (ship_index % NUM_PICK_SHIP_EXPLORER_COLUMNS))); // JMS_GFX
+				
+				s.origin.y = pick_r.corner.y
+				+ ((16 << RESOLUTION_FACTOR) + ((ICON_HEIGHT + (4 << RESOLUTION_FACTOR))
+						 * (ship_index / NUM_PICK_SHIP_EXPLORER_COLUMNS))); // JMS_GFX
+				
+				if ((ship_index / NUM_PICK_SHIP_EXPLORER_COLUMNS)>0)
+				{
+					s.origin.x += ICON_WIDTH + (8 << RESOLUTION_FACTOR); // JMS_GFX
+					
+					if((ship_index % NUM_PICK_SHIP_EXPLORER_COLUMNS)>0)
+						s.origin.x += FLAGSHIP_EXPLORER_WIDTH + (10 << RESOLUTION_FACTOR); // JMS_GFX
+				}
+				
+				if ((ship_index % NUM_PICK_SHIP_EXPLORER_COLUMNS) >=
+					(NUM_PICK_SHIP_EXPLORER_COLUMNS >> 1))
+					s.origin.x += FLAGSHIP_EXPLORER_WIDTH + (10 << RESOLUTION_FACTOR); // JMS_GFX
+			}
+			// JMS: Precursor vessel graphics
+			else if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == PRECURSOR_SERVICE_VEHICLE)
+			{
+				s.origin.x = pick_r.corner.x
+				+ ((5 << RESOLUTION_FACTOR) + ((ICON_WIDTH + (4 << RESOLUTION_FACTOR))
+						* (ship_index % NUM_PICK_SHIP_COLUMNS))); // JMS_GFX
+				if ((ship_index % NUM_PICK_SHIP_COLUMNS) >=
 					(NUM_PICK_SHIP_COLUMNS >> 1))
-				s.origin.x += FLAGSHIP_WIDTH + 4;
-			s.origin.y = pick_r.corner.y
-					+ (16 + ((ICON_HEIGHT + 4)
-					* (ship_index / NUM_PICK_SHIP_COLUMNS)));
+					s.origin.x += FLAGSHIP_WIDTH + (4 << RESOLUTION_FACTOR); // JMS_GFX
+				s.origin.y = pick_r.corner.y
+				+ ((16 << RESOLUTION_FACTOR) + ((ICON_HEIGHT + (4 << RESOLUTION_FACTOR))
+						 * (ship_index / NUM_PICK_SHIP_COLUMNS))); // JMS_GFX
+			}
+ 
 			s.frame = StarShipPtr->icons;
 			r.corner = s.origin;
 			SetContextForeGroundColor (BLACK_COLOR);
 			DrawFilledRectangle (&r);
+			
 			if ((StarShipPtr->SpeciesID != NO_ID) || (StarShipPtr->crew_level == 0))
 			{
 				DrawStamp (&s);
@@ -503,4 +642,3 @@ DrawArmadaPickShip (BOOLEAN draw_salvage
 
 	SetContext (OldContext);
 }
-
diff -ruNp src.orig/uqm/plandata.c src/uqm/plandata.c
--- src.orig/uqm/plandata.c	2017-11-01 15:30:25 -0700
+++ src/uqm/plandata.c	2017-11-01 15:31:03 -0700
@@ -16,522 +16,535 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2009: -Made Alpha Vulpeculae Orz space portal
+//			 -Added a system into Orz space starmap_array
+// JMS 2010: -Added Lurg home system
+//			 -Added shofixti crash site
+//			 -Added possible systems for those who mysteriously vanished in a hurry...
+//			 -Added little something to Gamma Janus
+
 // XXX: for XXX_DEFINED constants
 #include "encount.h"
+#include "hyper.h" // JMS: For ARILOU_HOME_X and Y
 #include "resinst.h"
 #include "planets/planets.h"
 #include "planets/elemdata.h"
 
 
+// NOTE: each block of stars (hyperspace, quasispace, etc.) MUST be
+// ordered by the y-coordinate (from smallest to biggest) for the 
+// FindStar binary search to work!  Typical symptom of it NOT 
+// working is flying up to a star but not being sucked into it.
 STAR_DESC starmap_array[] =
 {
-	//                           postfix name index (like 'Normae')
-	//                         prefix name index (like 'Alpha')   |
-	//                                        alien presence  |   |
-	//                                     owner (unused)  |  |   |
-	//   x,    y              star type   colour       |   |  |   |
-	{{5007,   35}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 6, 74},
-	{{ 708,   41}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 7, 91},
-	{{4714,   78}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 7, 74},
-	{{2187,   83}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 0, 126},
-	{{2814,   89}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 82},
-	{{4244,   91}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 0, 125},
-	{{5652,   98}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 124},
-	{{2939,  116}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 82},
-	{{2771,  146}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 82},
-	{{5313,  150}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 6, 73},
-	{{ 265,  156}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 5, 92},
-	{{4529,  169}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 8, 74},
-	{{4911,  180}, MAKE_STAR (GIANT_STAR, ORANGE_BODY, -1), 0, 1, 74},
-	{{4747,  221}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 4, 74},
-	{{9708,  250}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 0, 112},
-	{{4861,  262}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 2, 74},
-	{{2908,  269}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), SHOFIXTI_DEFINED, 4, 82},
-	{{1855,  270}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 5, 81},
-	{{7958,  270}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 8},
-	{{5160,  280}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 4, 73},
-	{{ 570,  289}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 4, 92},
-	{{4923,  294}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), YEHAT_DEFINED, 3, 74},
-	{{2820,  301}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 5, 82},
-	{{7934,  318}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 8},
-	{{8062,  318}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 8},
-	{{1116,  334}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 6, 91},
-	{{ 803,  337}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 3, 91},
-	{{1787,  338}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 6, 81},
-	{{ 877,  340}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 4, 91},
-	{{5338,  355}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 5, 73},
-	{{5039,  373}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 1, 73},
-	{{ 843,  380}, MAKE_STAR (GIANT_STAR, ORANGE_BODY, -1), 0, 1, 91},
-	{{4872,  408}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 5, 74},
-	{{1740,  423}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 7, 81},
-	{{4596,  429}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 9, 74},
-	{{ 843,  431}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 2, 91},
-	{{2156,  440}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 4, 81},
-	{{2004,  441}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 81},
-	{{ 530,  442}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 2, 92},
-	{{ 958,  468}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 5, 91},
-	{{2058,  475}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 2, 81},
-	{{ 304,  477}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 1, 92},
-	{{ 522,  525}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), PKUNK_DEFINED, 3, 92},
-	{{2100,  554}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 3, 81},
-	{{ 134,  565}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 6, 92},
-	{{6858,  577}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), MYCON_TRAP_DEFINED, 0, 123},
-	{{5014,  584}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 73},
-	{{5256,  608}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 73},
-	{{2411,  718}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 1, 9},
-	{{2589,  741}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 9},
-	{{ 675,  742}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 8, 91},
-	{{9292,  750}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 4, 5},
-	{{1463,  779}, MAKE_STAR (GIANT_STAR, RED_BODY, -1), 0, 6, 80},
-	{{3089,  782}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 4, 9},
-	{{2854,  787}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 9},
-	{{3333,  801}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 5, 9},
-	{{9237,  821}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 5, 5},
-	{{9339,  843}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 1, 5},
-	{{ 242,  857}, MAKE_STAR (GIANT_STAR, ORANGE_BODY, -1), 0, 3, 90},
-	{{1515,  866}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 5, 80},
-	{{4770,  895}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 5, 75},
-	{{1412,  905}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 80},
-	{{4681,  916}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), RAINBOW_DEFINED, 6, 75},
-	{{9333,  937}, MAKE_STAR (SUPER_GIANT_STAR, YELLOW_BODY, -1), MELNORME0_DEFINED, 2, 5},
-	{{9419,  942}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 3, 5},
-	{{ 230,  952}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 2, 90},
-	{{ 146,  955}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 1, 90},
-	{{4873,  968}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 4, 75},
-	{{1559,  993}, MAKE_STAR (SUPER_GIANT_STAR, RED_BODY, -1), MELNORME1_DEFINED, 1, 80},
-	{{1895, 1041}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 93},
-	{{4337, 1066}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 75},
-	{{3732, 1067}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 0, 122},
-	{{1579, 1115}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 80},
-	{{4875, 1145}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 75},
-	{{4604, 1187}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 75},
-	{{5812, 1208}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 4, 72},
-	{{1312, 1260}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 4, 80},
-	{{1916, 1270}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 1, 93},
-	{{6562, 1270}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 0, 121},
-	{{ 416, 1301}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 0, 120},
-	{{3958, 1354}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 89},
-	{{4000, 1363}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 1, 89},
-	{{1752, 1450}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), SOL_DEFINED, 0, 129},
-	{{2187, 1500}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 0, 127},
-	{{1806, 1507}, MAKE_STAR (GIANT_STAR, WHITE_BODY, -1), 0, 0, 128},
-	{{5708, 1520}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 5, 72},
-	{{9469, 1548}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 6},
-	{{4333, 1562}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 88},
-	{{6041, 1562}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 72},
-	{{9375, 1583}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 6},
-	{{2881, 1614}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 96},
-	{{6083, 1625}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 72},
-	{{4250, 1645}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 1, 88},
-	{{ 650, 1646}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 7, 85},
-	{{9477, 1670}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 3, 6},
-	{{2840, 1676}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 96},
-	{{9541, 1687}, MAKE_STAR (GIANT_STAR, RED_BODY, -1), 0, 4, 6},
-	{{7395, 1687}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 3, 69},
-	{{4333, 1687}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), VUX_DEFINED, 2, 88},
-	{{9559, 1735}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 5, 6},
-	{{ 736, 1737}, MAKE_STAR (GIANT_STAR, BLUE_BODY, -1), 0, 6, 85},
-	{{1601, 1746}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 1, 94},
-	{{7395, 1750}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 69},
-	{{ 951, 1770}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 1, 85},
-	{{1666, 1812}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 2, 94},
-	{{7187, 1833}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 2, 69},
-	{{ 705, 1838}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 5, 85},
-	{{1140, 1847}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 2, 85},
-	{{6467, 1878}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 71},
-	{{2791, 1895}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 96},
-	{{6500, 1916}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 2, 71},
-	{{5458, 1916}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 0, 119},
-	{{1048, 1919}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 85},
-	{{3678, 1926}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 99},
-	{{3345, 1931}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), START_COLONY_DEFINED, 0, 98},
-	{{8187, 1937}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 4, 7},
-	{{3352, 1940}, MAKE_STAR (SUPER_GIANT_STAR, WHITE_BODY, -1), MELNORME2_DEFINED, 0, 97},
-	{{ 977, 1953}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 4, 85},
-	{{4221, 1986}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), MAIDENS_DEFINED, 1, 100},
-	{{4500, 2000}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 100},
-	{{6833, 2000}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 70},
-	{{8163, 2009}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 3, 7},
-	{{8080, 2011}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 7},
-	{{6036, 2035}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 4, 71},
-	{{6479, 2062}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), EGG_CASE1_DEFINED, 3, 71},
-	{{2104, 2083}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), ZOQ_SCOUT_DEFINED, 0, 118},
-	{{8062, 2083}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 1, 7},
-	{{ 270, 2187}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 79},
-	{{6500, 2208}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 6, 71},
-	{{6291, 2208}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), MYCON_DEFINED, 5, 71},
-	{{ 125, 2229}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 79},
-	{{ 312, 2250}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 3, 79},
-	{{3884, 2262}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 3, 99},
-	{{ 742, 2268}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), CHMMR_DEFINED, 0, 117},
-	{{2306, 2285}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 1, 95},
-	{{2402, 2309}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 95},
-	{{6395, 2312}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), SUN_DEVICE_DEFINED, 2, 12},
-	{{8875, 2312}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 9, 61},
-	{{3551, 2320}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 1, 99},
-	{{6208, 2333}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 1, 12},
-	{{3354, 2354}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 4, 99},
-	{{9909, 2359}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 0, 111},
-	{{2298, 2385}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 95},
-	{{7020, 2395}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 2, 70},
-	{{9038, 2407}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 5, 61},
-	{{9375, 2416}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 8, 61},
-	{{6500, 2458}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 6, 12},
-	{{ 217, 2509}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 4, 78},
-	{{3641, 2512}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 86},
-	{{5625, 2520}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 14},
-	{{3713, 2537}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), ORZ_DEFINED, 3, 86},
-	{{3587, 2566}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), ANDROSYNTH_DEFINED, 7, 86},
-	{{9291, 2583}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 61},
-	{{3654, 2587}, MAKE_STAR (SUPER_GIANT_STAR, GREEN_BODY, -1), MELNORME3_DEFINED, 1, 86},
-	{{3721, 2619}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), TAALO_PROTECTOR_DEFINED, 4, 86},
-	{{5791, 2625}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 14},
-	{{6416, 2625}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 5, 12},
-	{{6008, 2631}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), EGG_CASE0_DEFINED, 2, 14},
-	{{3608, 2637}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 6, 86},
-	{{3499, 2648}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 87},
-	{{9479, 2666}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 2, 61},
-	{{3668, 2666}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 5, 86},
-	{{ 229, 2666}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 78},
-	{{8895, 2687}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 7, 61},
-	{{ 138, 2696}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 5, 78},
-	{{5375, 2729}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 0, 116},
-	{{6354, 2729}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), EGG_CASE2_DEFINED, 3, 12},
-	{{6458, 2750}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 4, 12},
-	{{2458, 2750}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 6, 106},
-	{{ 351, 2758}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 2, 78},
-	{{7083, 2770}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 70},
-	{{3759, 2778}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 4, 87},
-	{{9333, 2791}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 61},
-	{{3400, 2804}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 2, 87},
-	{{9469, 2806}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), DRUUGE_DEFINED, 6, 61},
-	{{3619, 2830}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 87},
-	{{2208, 2854}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 7, 106},
-	{{9250, 2854}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 4, 61},
-	{{ 672, 2863}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 7, 78},
-	{{ 167, 2875}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 6, 78},
-	{{4030, 2887}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 105},
-	{{ 384, 2900}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 78},
-	{{2727, 2951}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 5, 106},
-	{{4645, 2958}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 105},
-	{{5625, 2958}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 13},
-	{{8270, 2958}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 66},
-	{{8291, 2979}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 66},
-	{{6020, 2979}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), RAINBOW_DEFINED, 3, 13},
-	{{6562, 3020}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 4, 70},
-	{{2011, 3043}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 8, 106},
-	{{8125, 3083}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 1, 66},
-	{{2354, 3166}, MAKE_STAR (GIANT_STAR, YELLOW_BODY, -1), 0, 4, 106},
-	{{3833, 3187}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 1, 105},
-	{{5812, 3208}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 1, 13},
-	{{9000, 3250}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 0, 113},
-	{{ 291, 3250}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 84},
-	{{ 501, 3259}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 84},
-	{{ 791, 3270}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 84},
-	{{2354, 3291}, MAKE_STAR (SUPER_GIANT_STAR, RED_BODY, -1), MELNORME4_DEFINED, 1, 106},
-	{{1104, 3333}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 4, 84},
-	{{2687, 3333}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 3, 106},
-	{{3187, 3375}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 107},
-	{{1758, 3418}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 108},
-	{{2520, 3437}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 106},
-	{{8437, 3458}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 64},
-	{{8770, 3458}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 4, 64},
-	{{3000, 3500}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 107},
-	{{ 149, 3519}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 5, 76},
-	{{8791, 3541}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 64},
-	{{2148, 3551}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 2, 109},
-	{{7375, 3562}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 0, 115},
-	{{9312, 3562}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 63},
-	{{9599, 3583}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 4, 63},
-	{{9375, 3604}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 3, 63},
-	{{  90, 3614}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 6, 76},
-	{{2770, 3625}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 4, 107},
-	{{8708, 3625}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 64},
-	{{ 267, 3645}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 3, 76},
-	{{1604, 3645}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 1, 108},
-	{{2274, 3663}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 1, 109},
-	{{ 229, 3666}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), ILWRATH_DEFINED, 1, 76},
-	{{3083, 3674}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 107},
-	{{2416, 3687}, MAKE_STAR (GIANT_STAR, ORANGE_BODY, -1), SPATHI_DEFINED, 5, 109},
-	{{9333, 3708}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 63},
-	{{2250, 3708}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 3, 109},
-	{{ 288, 3735}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 2, 76},
-	{{2354, 3741}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 4, 109},
-	{{2583, 3750}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 6, 109},
-	{{4125, 3770}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), SYREEN_DEFINED, 0, 114},
-	{{ 166, 3770}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 4, 76},
-	{{6270, 3833}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 4, 10},
-	{{2145, 3916}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 110},
-	{{6125, 3937}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 10},
-	{{6291, 3937}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 9, 10},
-	{{5937, 3937}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), SHIP_VAULT_DEFINED, 5, 10},
-	{{2479, 3958}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 7, 109},
-	{{ 926, 3972}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 83},
-	{{2062, 3991}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 110},
-	{{5895, 4020}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 8, 10},
-	{{ 285, 4020}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 1, 77},
-	{{6062, 4041}, MAKE_STAR (GIANT_STAR, YELLOW_BODY, -1), 0, 1, 10},
-	{{2875, 4041}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 20},
-	{{8645, 4062}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 65},
-	{{ 860, 4065}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 83},
-	{{5958, 4083}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 10},
-	{{3038, 4083}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 3, 20},
-	{{ 291, 4104}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 77},
-	{{6166, 4125}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 6, 10},
-	{{9812, 4145}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 3, 62},
-	{{8520, 4166}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 1, 65},
-	{{9573, 4182}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 62},
-	{{ 500, 4187}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 3, 77},
-	{{2145, 4208}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 110},
-	{{6208, 4229}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 7, 10},
-	{{2812, 4250}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 7, 20},
-	{{2937, 4306}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 4, 20},
-	{{9416, 4395}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 62},
-	{{2875, 4479}, MAKE_STAR (GIANT_STAR, WHITE_BODY, -1), 0, 1, 20},
-	{{ 250, 4583}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 5, 26},
-	{{7250, 4583}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 4, 68},
-	{{ 479, 4583}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 26},
-	{{5708, 4604}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 0, 104},
-	{{ 479, 4645}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 26},
-	{{2895, 4687}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 6, 20},
-	{{2708, 4708}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 5, 20},
-	{{ 562, 4708}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 26},
-	{{ 416, 4717}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 4, 26},
-	{{5094, 4931}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 4, 11},
-	{{9000, 5000}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 67},
-	{{8958, 5000}, MAKE_STAR (GIANT_STAR, BLUE_BODY, -1), 0, 1, 67},
-	{{5006, 5011}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 11},
-	{{7312, 5062}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 1, 68},
-	{{3679, 5068}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 3, 17},
-	{{9062, 5083}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 67},
-	{{7416, 5083}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), RAINBOW_DEFINED, 3, 68},
-	{{5155, 5122}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 11},
-	{{3875, 5145}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 4, 17},
-	{{4937, 5145}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 11},
-	{{2979, 5166}, MAKE_STAR (GIANT_STAR, ORANGE_BODY, -1), 0, 1, 15},
-	{{3035, 5178}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 15},
-	{{3994, 5185}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 5, 17},
-	{{3541, 5187}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 17},
-	{{5977, 5246}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 102},
-	{{3770, 5250}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 17},
-	{{1520, 5261}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 55},
-	{{1613, 5279}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 4, 55},
-	{{7020, 5291}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 68},
-	{{1416, 5315}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 2, 55},
-	{{2993, 5318}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 15},
-	{{1425, 5404}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 55},
-	{{1854, 5416}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 5, 55},
-	{{3625, 5437}, MAKE_STAR (GIANT_STAR, GREEN_BODY, -1), 0, 1, 16},
-	{{3416, 5437}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 16},
-	{{4000, 5437}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), ZOQFOT_DEFINED, 1, 18},
-	{{6270, 5479}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 102},
-	{{3583, 5479}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 16},
-	{{4083, 5513}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 18},
-	{{2159, 5614}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 6, 55},
-	{{3937, 5625}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 18},
-	{{6014, 5632}, MAKE_STAR (GIANT_STAR, BLUE_BODY, -1), 0, 1, 21},
-	{{ 250, 5687}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 25},
-	{{3625, 5750}, MAKE_STAR (GIANT_STAR, RED_BODY, -1), 0, 2, 19},
-	{{ 371, 5772}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 25},
-	{{6107, 5785}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 2, 21},
-	{{9645, 5791}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), BURVIXESE_DEFINED, 0, 130},
-	{{1545, 5818}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 5, 54},
-	{{3750, 5833}, MAKE_STAR (GIANT_STAR, GREEN_BODY, -1), 0, 1, 19},
-	{{6301, 5875}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 5, 21},
-	{{1923, 5878}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 54},
-	{{4625, 5895}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 131},
-	{{ 152, 5900}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 25},
-	{{5437, 5916}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 4, 33},
-	{{1714, 5926}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 4, 54},
-	{{6200, 5935}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), SAMATRA_DEFINED, 4, 21},
-	{{6429, 5958}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 7, 21},
-	{{4729, 5958}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 4, 131},
-	{{1978, 5968}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), TALKING_PET_DEFINED, 2, 54},
-	{{ 395, 5979}, MAKE_STAR (GIANT_STAR, GREEN_BODY, -1), 0, 1, 22},
-	{{ 563, 5980}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 5, 22},
-	{{ 456, 5989}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 6, 22},
-	{{4625, 6000}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 131},
-	{{6166, 6000}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 3, 21},
-	{{6496, 6032}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 6, 21},
-	{{2228, 6038}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 12, 54},
-	{{4583, 6041}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 131},
-	{{1558, 6058}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 6, 54},
-	{{1902, 6065}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 54},
-	{{2159, 6073}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 11, 54},
-	{{ 365, 6093}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 22},
-	{{ 541, 6145}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 4, 22},
-	{{2200, 6176}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 10, 54},
-	{{ 729, 6208}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 23},
-	{{5250, 6229}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 3, 33},
-	{{8166, 6250}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 40},
-	{{6215, 6255}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 8, 21},
-	{{ 437, 6270}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 3, 22},
-	{{5583, 6291}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 1, 33},
-	{{1881, 6308}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 8, 54},
-	{{1795, 6329}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 7, 54},
-	{{2118, 6379}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 9, 54},
-	{{ 750, 6458}, MAKE_STAR (GIANT_STAR, WHITE_BODY, -1), 0, 1, 23},
-	{{3716, 6458}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 1, 30},
-	{{1360, 6489}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 56},
-	{{7333, 6500}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 1, 40},
-	{{3770, 6500}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 30},
-	{{4500, 6500}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 0, 37},
-	{{ 187, 6520}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 4, 24},
-	{{ 125, 6541}, MAKE_STAR (GIANT_STAR, RED_BODY, -1), 0, 1, 24},
-	{{7812, 6562}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 40},
-	{{ 770, 6602}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 23},
-	{{5910, 6624}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 29},
-	{{ 208, 6625}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 24},
-	{{2604, 6645}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 1, 101},
-	{{1578, 6668}, MAKE_STAR (SUPER_GIANT_STAR, GREEN_BODY, -1), MELNORME5_DEFINED, 1, 56},
-	{{5479, 6687}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 33},
-	{{ 375, 6716}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 2, 24},
-	{{ 312, 6728}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 5, 24},
-	{{6020, 6729}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 29},
-	{{5062, 6750}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 10, 28},
-	{{4208, 6854}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 1, 31},
-	{{5145, 6875}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 9, 28},
-	{{4291, 6937}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 31},
-	{{5145, 6958}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 8, 28},
-	{{7208, 7000}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 39},
-	{{8625, 7000}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), RAINBOW_DEFINED, 1, 41},
-	{{4955, 7034}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 28},
-	{{4895, 7041}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 28},
-	{{4971, 7104}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 1, 28},
-	{{8666, 7104}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 41},
-	{{4854, 7125}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 4, 28},
-	{{5083, 7145}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 7, 28},
-	{{7360, 7184}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 4, 39},
-	{{1020, 7187}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 58},
-	{{3875, 7187}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 1, 32},
-	{{4879, 7201}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 5, 28},
-	{{4958, 7229}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 6, 28},
-	{{7125, 7250}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 39},
-	{{7532, 7258}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 5, 39},
-	{{2416, 7291}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 101},
-	{{3854, 7291}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 32},
-	{{9687, 7333}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 3, 44},
-	{{ 395, 7458}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), RAINBOW_DEFINED, 2, 60},
-	{{4895, 7458}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 36},
-	{{4645, 7479}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 4, 36},
-	{{6940, 7514}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 11, 39},
-	{{7443, 7538}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 6, 39},
-	{{6479, 7541}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 0, 38},
-	{{7208, 7541}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 1, 39},
-	{{5791, 7583}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 3, 34},
-	{{ 333, 7625}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 60},
-	{{5958, 7645}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 2, 34},
-	{{1041, 7708}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 58},
-	{{5875, 7729}, MAKE_STAR (SUPER_GIANT_STAR, YELLOW_BODY, -1), MELNORME6_DEFINED, 1, 34},
-	{{1125, 7791}, MAKE_STAR (GIANT_STAR, BLUE_BODY, -1), 0, 1, 58},
-	{{4979, 7791}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 2, 36},
-	{{4958, 7791}, MAKE_STAR (GIANT_STAR, WHITE_BODY, -1), 0, 1, 36},
-	{{6889, 7803}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 10, 39},
-	{{7200, 7849}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 8, 39},
-	{{7395, 7854}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 7, 39},
-	{{9437, 7854}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 44},
-	{{2836, 7857}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), RAINBOW_DEFINED, 5, 53},
-	{{5375, 7875}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 1, 35},
-	{{6187, 7875}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 7, 35},
-	{{6041, 7916}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 5, 35},
-	{{5979, 7979}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 4, 35},
-	{{7083, 7993}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 9, 39},
-	{{3270, 8000}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 8, 53},
-	{{6104, 8000}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 6, 35},
-	{{ 687, 8000}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 59},
-	{{ 562, 8000}, MAKE_STAR (GIANT_STAR, GREEN_BODY, -1), URQUAN_WRECK_DEFINED, 1, 59},
-	{{5645, 8020}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 35},
-	{{1395, 8041}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 4, 58},
-	{{8229, 8041}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 43},
-	{{2518, 8056}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 3, 53},
-	{{5875, 8062}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 3, 35},
-	{{8416, 8083}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 43},
-	{{9000, 8229}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 44},
-	{{3562, 8250}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 9, 53},
-	{{5437, 8270}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), RAINBOW_DEFINED, 5, 48},
-	{{1520, 8333}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 5, 58},
-	{{2771, 8351}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 53},
-	{{2535, 8358}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), THRADD_DEFINED, 4, 53},
-	{{3151, 8390}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 7, 53},
-	{{2362, 8395}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 11, 53},
-	{{2822, 8395}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 53},
-	{{5500, 8395}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 48},
-	{{2536, 8504}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 4, 2},
-	{{2582, 8507}, MAKE_STAR (SUPER_GIANT_STAR, YELLOW_BODY, -1), MELNORME7_DEFINED, 1, 2},
-	{{8625, 8562}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 6, 3},
-	{{4375, 8562}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 0, 50},
-	{{2593, 8569}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 2},
-	{{2562, 8572}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 2},
-	{{8492, 8578}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 7, 3},
-	{{1125, 8583}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 6, 58},
-	{{8073, 8588}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 1, 46},
-	{{8560, 8638}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 3},
-	{{8750, 8645}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 5, 3},
-	{{5562, 8645}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 48},
-	{{2588, 8653}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 14, 53},
-	{{2458, 8666}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 10, 53},
-	{{7666, 8666}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), RAINBOW_DEFINED, 2, 46},
-	{{2776, 8673}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), AQUA_HELIX_DEFINED, 6, 53},
-	{{8630, 8693}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), UTWIG_DEFINED, 2, 3},
-	{{2310, 8702}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 12, 53},
-	{{ 437, 8770}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 1, 57},
-	{{8534, 8797}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), RAINBOW_DEFINED, 3, 3},
-	{{8588, 8812}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 4, 3},
-	{{7187, 8812}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 3, 46},
-	{{5475, 8823}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 48},
-	{{3050, 8833}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 4, 1},
-	{{2831, 8854}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 1},
-	{{2300, 8861}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 13, 53},
-	{{ 479, 8875}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 57},
-	{{2706, 8910}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 2, 1},
-	{{ 333, 8916}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 57},
-	{{2535, 8917}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 5, 1},
-	{{8322, 8934}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 1, 45},
-	{{8249, 8958}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 4, 45},
-	{{8375, 8958}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 45},
-	{{5645, 8979}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 4, 48},
-	{{2687, 9000}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 1},
-	{{8375, 9041}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 45},
-	{{9960, 9042}, MAKE_STAR (GIANT_STAR, WHITE_BODY, -1), RAINBOW_DEFINED, 0, 42},
-	{{7354, 9062}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 47},
-	{{7833, 9083}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 6, 47},
-	{{2581, 9105}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 6, 1},
-	{{7545, 9107}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 47},
-	{{7414, 9124}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), SUPOX_DEFINED, 2, 47},
-	{{8500, 9125}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 5, 45},
-	{{ 104, 9125}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 5, 27},
-	{{7889, 9181}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 7, 47},
-	{{7791, 9187}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 4, 47},
-	{{7791, 9229}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 5, 47},
-	{{4812, 9270}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 0, 51},
-	{{8500, 9372}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), BOMB_DEFINED, 6, 45},
-	{{7255, 9374}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 11, 45},
-	{{8458, 9393}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 7, 45},
-	{{1000, 9395}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 4, 27},
-	{{5711, 9475}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 49},
-	{{  62, 9479}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 27},
-	{{5989, 9496}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 7, 49},
-	{{8000, 9505}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 9, 45},
-	{{5329, 9538}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 5, 49},
-	{{2916, 9541}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 103},
-	{{8296, 9548}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 8, 45},
-	{{5600, 9552}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 1, 49},
-	{{7664, 9589}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 10, 45},
-	{{6125, 9604}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 8, 49},
-	{{9144, 9686}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 4, 4},
-	{{5781, 9711}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 3, 49},
-	{{5229, 9729}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 6, 49},
-	{{9120, 9741}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 4},
-	{{9186, 9741}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 4},
-	{{9159, 9745}, MAKE_STAR (SUPER_GIANT_STAR, BLUE_BODY, -1), MELNORME8_DEFINED, 1, 4},
-	{{ 333, 9750}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 0, 0},
-	{{9147, 9790}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 5, 4},
-	{{5704, 9795}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), VUX_BEAST_DEFINED, 4, 49},
-	{{ 333, 9812}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), SLYLANDRO_DEFINED, 2, 27},
-	{{1020, 9937}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 7, 27},
-	{{  83, 9979}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 6, 27},
-	{{1937, 9979}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 1, 103},
-	{{4395, 9979}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 0, 52},
+//                           postfix name index (like 'Normae')
+//                         prefix name index (like 'Alpha')   |
+//                                        alien presence  |   |
+//                                     owner (unused)  |  |   |
+//   x,    y              star type   colour       |   |  |   |
+{{5207,  83}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 29},
+{{4256, 122}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 0, 25},
+{{7703, 145}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 115},
+{{1827, 172}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 3, 104},
+{{3468, 182}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 1, 17},
+{{5314, 210}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 29},
+{{9044, 228}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 1, 49},
+{{1325, 230}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), MELNORME_HOME_DEFINED, 2, 104},  //TODO pick a better star somewhere round here
+{{6886, 317}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 36},
+{{1877, 355}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 1, 104},
+{{3254, 357}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 4, 17},
+{{9246, 368}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 56},
+{{3456, 418}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 17},
+{{6749, 429}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 1, 36},
+{{2379, 458}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 4, 104},
+{{9862, 467}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 0, 32},
+{{5482, 480}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 6, 29},
+{{5184, 485}, MAKE_STAR (GIANT_STAR, BLUE_BODY, -1), 0, 1, 29},
+{{4817, 501}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 7, 29},
+{{5386, 520}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 5, 29},
+{{7727, 525}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 115},
+{{3256, 528}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 17},
+{{ 606, 602}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 1, 58},
+{{3717, 656}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 59},
+{{ 702, 660}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 58},
+{{4123, 667}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 4, 28},
+{{8560, 707}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 3, 49},
+{{8012, 712}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 115},
+{{1162, 724}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 12, 43},
+{{5664, 727}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), RAINBOW_DEFINED, 4, 29},
+{{1275, 743}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 11, 43},
+{{1547, 761}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 10, 43},
+{{6635, 766}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 77},
+{{6462, 789}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 1, 77},
+{{8844, 790}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 49},
+{{3524, 796}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 59},
+{{3999, 812}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 1, 28},
+{{7791, 819}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 4, 115},
+{{1570, 846}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 9, 43},
+{{3759, 879}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 5, 28},
+{{1305, 894}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 15, 43},
+{{1402, 902}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 43},
+{{4009, 923}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 28},
+{{6670, 935}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 77},
+{{1190, 943}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 14, 43},
+{{6230, 968}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 4, 77},
+{{6882, 989}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 9, 53},
+{{1233, 997}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 13, 43},
+{{1338,1043}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 43},
+{{4925,1043}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 3, 123},
+{{4161,1075}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 28},
+{{5035,1082}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 123},
+{{1567,1104}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 8, 43},
+{{1279,1132}, MAKE_STAR (SUPER_GIANT_STAR, ORANGE_BODY, -1), MELNORME0_DEFINED, 1, 43},
+{{  66,1134}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 70},
+{{1355,1137}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 4, 43},
+{{5229,1140}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 1, 123},
+{{3422,1144}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 1, 12},
+{{6915,1174}, MAKE_STAR (SUPER_GIANT_STAR, GREEN_BODY, -1), MELNORME1_DEFINED, 1, 53},
+{{3294,1184}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 12},
+{{4335,1207}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 1, 71},
+{{8610,1218}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 34},
+{{4495,1227}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 71},
+{{6966,1231}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 4, 53},
+{{2816,1241}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 3, 111},
+{{1510,1247}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 5, 43},
+{{9654,1252}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 68},
+{{2927,1304}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 111},
+{{1186,1305}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 7, 43},
+{{9714,1317}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 4, 68},
+{{2667,1321}, MAKE_STAR (SUPER_GIANT_STAR, ORANGE_BODY, -1), MELNORME2_DEFINED, 1, 31},
+{{6912,1326}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 5, 53},
+{{6496,1363}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 54},
+{{1602,1364}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 6, 43},
+{{3460,1368}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 12},
+{{9396,1384}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 6, 68},
+{{7275,1396}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 65},
+{{6358,1399}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 54},
+{{4630,1410}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 3, 42},
+{{9880,1422}, MAKE_STAR (GIANT_STAR, GREEN_BODY, -1), 0, 1, 68},
+{{9470,1431}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 5, 68},
+{{9705,1442}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 68},
+{{4890,1450}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 8, 42},
+{{6780,1469}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 53},
+{{2942,1489}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 111},
+{{4570,1490}, MAKE_STAR (GIANT_STAR, WHITE_BODY, -1), 0, 1, 42},
+{{6949,1517}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 53},
+{{6470,1522}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 2, 54},
+{{5669,1539}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 4, 19},
+{{4670,1570}, MAKE_STAR (GIANT_STAR, GREEN_BODY, -1), 0, 2, 42},
+{{4800,1580}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 7, 42},
+{{2750,1610}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 4, 31},
+{{6741,1665}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 6, 53},
+{{6450,1684}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 8, 54},
+{{4740,1700}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 6, 42},
+{{6577,1711}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 7, 54},
+{{7460,1725}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 1, 65},
+{{4640,1740}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 5, 42},
+{{9196,1753}, MAKE_STAR (GIANT_STAR, WHITE_BODY, -1), 0, 1, 13},
+{{3151,1765}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 31},
+{{8286,1772}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 34},
+{{5826,1773}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 19},
+{{4510,1780}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 4, 42},
+{{2337,1822}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 31},
+{{9274,1909}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 2, 13},
+{{7665,2035}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 3, 65},
+{{5627,2062}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 3, 19},
+{{6890,2078}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 9, 19},
+{{ 338,2148}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 46},
+{{5851,2171}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 19},
+{{5407,2185}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 5, 19},
+{{5079,2233}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 20},
+{{ 897,2242}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 46},
+{{6001,2288}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 6, 19},
+{{8068,2306}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 45},
+{{6291,2352}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 0, 15},
+{{1442,2373}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 1, 46},
+{{9663,2386}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 5},
+{{8412,2410}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 45},
+{{6654,2446}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 8, 19},
+{{8497,2572}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 45},
+{{6259,2587}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 7, 19},
+{{5259,2595}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 3, 20},
+{{5119,2618}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 2, 20},
+{{8240,2700}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 5, 45},
+{{8513,2719}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 4, 45},
+{{7723,2737}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 0, 1},
+{{4661,2741}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 5, 69},
+{{7003,2790}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), RAINBOW_DEFINED, 1, 67},
+{{3180,2811}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 0, 116},
+{{3989,2982}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 41},
+{{ 132,3027}, MAKE_STAR (SUPER_GIANT_STAR, BLUE_BODY, -1), MELNORME3_DEFINED, 1, 30},
+{{1381,3066}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 5, 27},
+{{2115,3099}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 0, 131},
+{{7495,3100}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 6, 2},
+{{1329,3105}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 4, 27},
+{{6915,3125}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 67},
+{{4916,3127}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 1, 69},
+{{1730,3146}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 7, 27},
+{{5200,3162}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 69},
+{{3964,3177}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 1, 41},
+{{1638,3189}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 6, 27},
+{{1143,3215}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 3, 27},
+{{5491,3218}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 69},
+{{ 162,3233}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 30},
+{{7533,3271}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 5, 2},
+{{3474,3286}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 1, 57},
+{{1425,3291}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 1, 27},
+{{4173,3300}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 4, 41},
+{{6185,3310}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 66},
+{{5725,3333}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 4, 69},
+{{9330,3338}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 6},
+{{3860,3415}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 41},
+{{3231,3436}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 57},
+{{1486,3453}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 27},
+{{2446,3453}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 37},
+{{4976,3543}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 1, 8},
+{{3013,3571}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 40},
+{{3462,3594}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 57},
+{{7585,3611}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 4, 2},
+{{2538,3619}, MAKE_STAR (GIANT_STAR, BLUE_BODY, -1), 0, 1, 37},
+{{1508,3635}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 35},
+{{6909,3641}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 3, 61},
+{{6317,3646}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 1, 66},
+{{2406,3650}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 4, 37},
+{{4447,3709}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 6, 8},
+{{7610,3744}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), RAINBOW_DEFINED, 1, 2}, //Capt. Trivates added Rainbow World because it was on "the line" to Zeta Sextantis
+{{6416,3758}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 66},
+{{2521,3787}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 37},
+{{7045,3789}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), HINT_DEFINED, 2, 61},  // JMS: Someone was here, but left in a hurry... possibility #1
+{{6940,3797}, MAKE_STAR (GIANT_STAR, YELLOW_BODY, -1), 0, 1, 61},
+{{7768,3812}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 2},
+{{8892,3813}, MAKE_STAR (GIANT_STAR, RED_BODY, -1), 0, 1, 6},
+{{4800,3820}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 8},
+{{4750,3850}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 4, 8},
+{{9074,3852}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 6},
+{{6835,3874}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 4, 61},
+{{2689,3908}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 5, 37},
+{{6615,3930}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 7},
+{{2376,3941}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 6, 37},
+{{3062,3951}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 40},
+{{4942,3957}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 2, 8},
+{{6480,3970}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), HINT_DEFINED, 4, 7}, // JMS: Someone was here, but left in a hurry... possibility #2
+{{1471,4000}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 35},
+{{ 239,4026}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 113},
+{{9142,4075}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 4, 6},
+{{4690,4080}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 5, 8},
+{{2821,4083}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 2, 40},
+{{7657,4083}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 3, 2},
+{{6667,4100}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 2, 7},
+{{6370,4110}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 5, 7},
+{{5855,4125}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 0, 0},
+{{ 441,4172}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 1, 113},
+{{6564,4183}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), HINT_DEFINED, 1, 7}, // JMS: Someone was here, but left in a hurry... possibility #3
+{{  87,4190}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 113},
+{{1239,4228}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 1, 35},
+{{3822,4230}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 1, 112},
+{{6510,4276}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 6, 7},
+{{6375,4300}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 9, 7},
+{{6615,4310}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 7, 7},
+{{3002,4326}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 4, 40},
+{{9786,4377}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 39},
+{{3710,4387}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 112}, // JMS: This baby should have LURG_DEFINED in full game...
+{{6540,4400}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 8, 7},
+{{9680,4495}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 3, 39},
+{{2251,4502}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 0, 121},
+{{ 171,4516}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 4, 113},
+{{9870,4573}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 39},
+{{4445,4626}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 1, 103},
+{{6099,4776}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 3, 119},
+{{6828,4781}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 3, 50},
+{{7130,4790}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 1, 50},
+{{ 396,4799}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 5, 113},
+{{1738,4812}, MAKE_STAR (GIANT_STAR, WHITE_BODY, -1), 0, 0, 52},
+{{8342,4853}, MAKE_STAR (GIANT_STAR, BLUE_BODY, -1), RAINBOW_DEFINED, 0, 101},
+{{5807,4872}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 4, 119},
+{{4395,4908}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 103},
+{{9023,4920}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 1, 44},
+{{ 808,4930}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 0, 62},
+{{5882,4940}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 1, 119},
+{{6816,4970}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 50},
+{{6074,4989}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 2, 119},
+{{ 674,5055}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 6, 113},
+{{1216,5057}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 5, 51},
+{{9062,5083}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 44},
+{{ 440,5236}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 4, 73},
+{{5977,5246}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 5, 119},
+{{4177,5248}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 3, 103},
+{{1213,5295}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 51},
+{{1164,5307}, MAKE_STAR (GIANT_STAR, ORANGE_BODY, -1), 0, 1, 51},
+{{  58,5311}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 5, 73},
+{{ 569,5314}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 73},
+{{1253,5342}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 51},
+{{6270,5479}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 21},
+{{2351,5516}, MAKE_STAR (SUPER_GIANT_STAR, RED_BODY, -1), MELNORME4_DEFINED, 1, 11},
+{{4688,5537}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 64},
+{{3759,5572}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 2, 18},
+{{1105,5575}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 4, 51},
+{{7266,5623}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 1, 33},
+{{2881,5630}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 8, 18},
+{{6014,5632}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 21},
+{{4416,5633}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), SHOFIXTI_CRASH_SITE_DEFINED, 2, 64}, // JMS
+{{3537,5652}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 5, 18},
+{{8066,5653}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 3, 72},
+{{ 822,5659}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 73},
+{{9420,5664}, MAKE_STAR (GIANT_STAR, ORANGE_BODY, -1), 0, 1, 47},
+{{5479,5686}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 55},
+{{7862,5691}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 4, 72},
+{{7467,5714}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 1, 72},
+{{2382,5718}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 11},
+{{9510,5758}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 47},
+{{ 385,5774}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 73},
+{{4699,5780}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 1, 64},
+{{8123,5784}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 2, 72},
+{{6107,5785}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 1, 21},
+{{9645,5791}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 4, 47},
+{{7704,5794}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 5, 72},
+{{5316,5817}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 2, 55},
+{{3398,5840}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 6, 18},
+{{7312,5841}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 33},
+{{3855,5853}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 1, 18},
+{{9388,5863}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), HINT2_DEFINED, 3, 47}, // JMS: Gamma Janus, Yehat hint about precursor artifact
+{{6301,5875}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 5, 21},
+{{7398,5889}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 33},
+{{3974,5892}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 4, 18},
+{{3183,5901}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 7, 18},
+{{9864,5911}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 10, 74},
+{{5437,5916}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 3, 55},
+{{9564,5930}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 5, 47},
+{{6200,5935}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 4, 21},
+{{2304,5954}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 11},
+{{6429,5958}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 6, 21},
+{{3842,6030}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 3, 18},
+{{5708,6041}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 7, 91},
+{{4884,6048}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 4, 64},
+{{9714,6078}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 7, 74},
+{{7187,6083}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 0, 126},
+{{7814,6089}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), SHOFIXTI_COLONY_DEFINED, 2, 82},
+{{9244,6091}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 0, 125},
+{{4923,6101}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 5, 64},
+{{7939,6116}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 82},
+{{2100,6122}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 4, 11},
+{{7771,6146}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 82},
+{{5265,6156}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 5, 92},
+{{9529,6169}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 8, 74},
+{{9911,6180}, MAKE_STAR (GIANT_STAR, ORANGE_BODY, -1), 0, 1, 74},
+{{1920,6193}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 5, 11},
+{{9747,6221}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 4, 74},
+{{1731,6249}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 6, 11},
+{{9861,6262}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 2, 74},
+{{7908,6269}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), SHOFIXTI_DEFINED, 4, 82},
+{{6855,6270}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 5, 81},
+{{5570,6289}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 4, 92},
+{{9923,6294}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), YEHAT_DEFINED, 3, 74},
+{{4967,6295}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 6, 64},
+{{7820,6301}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 5, 82},
+{{2761,6303}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 9, 38},
+{{1296,6322}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 7, 11},
+{{6116,6334}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 6, 91},
+{{5803,6337}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 3, 91},
+{{6787,6338}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 6, 81},
+{{5877,6340}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 4, 91},
+{{5843,6380}, MAKE_STAR (GIANT_STAR, ORANGE_BODY, -1), 0, 1, 91},
+{{9872,6408}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 5, 74},
+{{6740,6423}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 7, 81},
+{{9596,6429}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 9, 74},
+{{5843,6431}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 2, 91},
+{{7156,6440}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 4, 81},
+{{7004,6441}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 81},
+{{5530,6442}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 2, 92},
+{{5958,6468}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 5, 91},
+{{7058,6475}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 2, 81},
+{{5304,6477}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 1, 92},
+{{5522,6525}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), PKUNK_DEFINED, 3, 92},
+{{7100,6554}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 3, 81},
+{{2785,6560}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 8, 38},
+{{5134,6565}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 6, 92},
+{{3980,6592}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 1, 63},
+{{3085,6674}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 38},
+{{7411,6718}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 1, 9},
+{{3160,6731}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 38},
+{{7589,6741}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 9},
+{{5675,6742}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 8, 91},
+{{1796,6763}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 26},
+{{6463,6779}, MAKE_STAR (GIANT_STAR, RED_BODY, -1), 0, 6, 80},
+{{8089,6782}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 4, 9},
+{{2917,6787}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 7, 38},
+{{7854,6787}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 9},
+{{8333,6801}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 5, 9},
+{{3075,6818}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 1, 38},
+{{3223,6854}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 4, 38},
+{{5242,6857}, MAKE_STAR (GIANT_STAR, ORANGE_BODY, -1), 0, 3, 90},
+{{6515,6866}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 5, 80},
+{{9770,6895}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 5, 75},
+{{6412,6905}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 80},
+{{9681,6916}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), RAINBOW_KNOWN_DEFINED, 6, 75},
+{{5230,6952}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 2, 90},
+{{5146,6955}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 1, 90},
+{{9873,6968}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 4, 75},
+{{3043,6969}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 6, 38},
+{{3136,6978}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 5, 38},
+{{4078,6978}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 2, 63},
+{{6559,6993}, MAKE_STAR (SUPER_GIANT_STAR, RED_BODY, -1), MELNORME5_DEFINED, 1, 80},
+{{1508,6994}, MAKE_STAR (GIANT_STAR, ORANGE_BODY, -1), 0, 1, 26},
+{{6895,7041}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 93},
+{{1830,7060}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 26},
+{{9337,7066}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 75},
+{{8732,7067}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 0, 122},
+{{6579,7115}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 80},
+{{9875,7145}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 75},
+{{4260,7175}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 63},
+{{9604,7187}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 75},
+{{6312,7260}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 4, 80},
+{{6916,7270}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 1, 93},
+{{5416,7301}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 0, 120},
+{{8958,7354}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 89},
+{{9000,7363}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 1, 89},
+{{6752,7450}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), SOL_DEFINED, 0, 129},
+{{3025,7480}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 6, 48},
+{{7187,7500}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 0, 127},
+{{6806,7507}, MAKE_STAR (GIANT_STAR, WHITE_BODY, -1), 0, 0, 128},
+{{9333,7562}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 88},
+{{ 596,7610}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 4},
+{{7881,7614}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 96},
+{{3743,7623}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 48},
+{{9250,7645}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 1, 88},
+{{5650,7646}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 7, 85},
+{{1485,7651}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 4, 26},
+{{4829,7666}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 4, 10},
+{{7840,7676}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 96},
+{{9333,7687}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), VUX_DEFINED, 2, 88},
+{{4880,7698}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 10},
+{{3260,7724}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 5, 48},
+{{5736,7737}, MAKE_STAR (GIANT_STAR, BLUE_BODY, -1), 0, 6, 85},
+{{4654,7745}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 10},
+{{6601,7746}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 1, 94},
+{{4841,7764}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 5, 10},
+{{3527,7768}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 48},
+{{5951,7770}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 1, 85},
+{{1772,7783}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 5, 26},
+{{ 570,7790}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 4, 4},
+{{4947,7805}, MAKE_STAR (GIANT_STAR, GREEN_BODY, -1), 0, 1, 10},
+{{3418,7809}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 4, 48},
+{{6666,7812}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 2, 94},
+{{3755,7823}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 24},
+{{5705,7838}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 5, 85},
+{{ 832,7841}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 4},
+{{6140,7847}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 2, 85},
+{{3845,7881}, MAKE_STAR (GIANT_STAR, RED_BODY, -1), 0, 1, 24},
+{{7791,7895}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 96},
+{{6048,7919}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 85},
+{{3487,7924}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 8, 48},
+{{8678,7926}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 99},
+{{8345,7931}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), START_COLONY_DEFINED, 0, 98},
+{{ 180,7940}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 3, 60},
+{{1040,7940}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 1, 4},
+{{8352,7940}, MAKE_STAR (SUPER_GIANT_STAR, WHITE_BODY, -1), MELNORME6_DEFINED, 0, 97},
+{{5977,7953}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 4, 85},
+{{9221,7986}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), MAIDENS_DEFINED, 1, 100},
+{{ 640,7992}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 5, 4},
+{{9500,8000}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 100},
+{{3690,8065}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 7, 48},
+{{ 340,8066}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 2, 60},
+{{7104,8083}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 0, 118},
+{{ 199,8140}, MAKE_STAR (SUPER_GIANT_STAR, WHITE_BODY, -1), MELNORME7_DEFINED, 1, 60},
+{{2114,8140}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 6, 26},
+{{5270,8187}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 79},
+{{ 509,8190}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 2, 16},
+{{5125,8229}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 79},
+{{ 370,8240}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 5, 16},
+{{5312,8250}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 3, 79},
+{{8884,8262}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 3, 99},
+{{5742,8268}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), CHMMR_DEFINED, 0, 117},
+{{7306,8285}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 1, 95},
+{{7402,8309}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 95},
+{{8551,8320}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 1, 99},
+{{8354,8354}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 4, 99},
+{{3349,8362}, MAKE_STAR (SUPER_GIANT_STAR, YELLOW_BODY, -1), MELNORME8_DEFINED, 1, 48},
+{{7298,8385}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 95},
+{{ 523,8412}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 16},
+{{5217,8509}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 4, 78},
+{{8641,8512}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 86},
+{{3962,8535}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 4, 102},
+{{8713,8537}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), ORZ_DEFINED, 3, 86},
+{{8587,8566}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), ANDROSYNTH_DEFINED, 7, 86},			 // JMS: Truespace Androsynth are here
+{{8654,8587}, MAKE_STAR (SUPER_GIANT_STAR, BLUE_BODY, -1), ORZ_SPACE_PORTAL_DEFINED, 1, 86}, // JMS: Orz space portal is in here!
+{{8721,8619}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), TAALO_PROTECTOR_DEFINED, 4, 86},
+{{8608,8637}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 6, 86},
+{{8499,8648}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 87},
+{{5229,8666}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 78},
+{{8668,8666}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 5, 86},
+{{ 617,8669}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 16},
+{{ 419,8677}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 4, 16},
+{{4841,8686}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 9, 78},
+{{5138,8696}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 5, 78},
+{{4092,8717}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 102},
+{{4895,8732}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 8, 78},
+{{7458,8750}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 6, 106},
+{{5351,8758}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 2, 78},
+{{8759,8778}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 4, 87},
+{{8400,8804}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 2, 87},
+{{8619,8830}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 87},
+{{7208,8854}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 7, 106},
+{{5672,8863}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 7, 78},
+{{5167,8875}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 6, 78},
+{{ 481,8882}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 6, 16},
+{{4119,8882}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 102},
+{{9030,8887}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 105},
+{{5384,8900}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 78},
+{{7727,8951}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 5, 106},
+{{9645,8958}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 105},
+{{7011,9043}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 8, 106},
+{{2246,9092}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 3},
+{{4790,9093}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 0, 22},
+{{2190,9125}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 3},
+{{4165,9152}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 102},
+{{7354,9166}, MAKE_STAR (GIANT_STAR, YELLOW_BODY, -1), 0, 4, 106},
+{{8833,9187}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 1, 105},
+{{1294,9221}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 23},
+{{5291,9250}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 84},
+{{5501,9259}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 84},
+{{5791,9270}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 84},
+{{7354,9291}, MAKE_STAR (SUPER_GIANT_STAR, RED_BODY, -1), MELNORME3_DEFINED, 1, 106},
+{{6104,9333}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 4, 84},
+{{7687,9333}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 3, 106},
+{{2374,9335}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 3},
+{{4239,9347}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 5, 102},
+{{3913,9353}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 6, 102},
+{{8187,9375}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 107},
+{{1545,9392}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 23},
+{{6758,9418}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 108},
+{{7520,9437}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 106},
+{{8000,9500}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 107},
+{{4083,9504}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 7, 102},
+{{5149,9519}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 5, 76},
+{{7148,9551}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 2, 109},
+{{ 616,9613}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 130},
+{{5090,9614}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 6, 76},
+{{7770,9625}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 4, 107},
+{{5267,9645}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 3, 76},
+{{6604,9645}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 1, 108},
+{{7274,9663}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 1, 109},
+{{5229,9666}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), ILWRATH_DEFINED, 1, 76},
+{{8083,9674}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 107},
+{{7416,9687}, MAKE_STAR (GIANT_STAR, ORANGE_BODY, -1), SPATHI_DEFINED, 5, 109},
+{{ 801,9707}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 2, 130},
+{{7250,9708}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 3, 109},
+{{5288,9735}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 2, 76},
+{{4429,9739}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 1, 14},
+{{7354,9741}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 4, 109},
+{{7583,9750}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 6, 109},
+{{5166,9770}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 4, 76},
+{{9125,9770}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), SYREEN_DEFINED, 0, 114},
+{{4470,9815}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 14},
+{{4862,9823}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 124},
+{{4960,9858}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 4, 124},
+{{4892,9870}, MAKE_STAR (GIANT_STAR, RED_BODY, -1), 0, 1, 124},
+{{7145,9916}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 110},
+{{4889,9938}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 2, 124},
+{{7479,9958}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 7, 109},
+{{5926,9972}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 83},
+{{7062,9991}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 110},
+	
 
 	{{MAX_X_UNIVERSE << 1, MAX_Y_UNIVERSE << 1}, 0, 0, 0, 0},
 
@@ -567,9 +580,11 @@ STAR_DESC starmap_array[] =
 			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
 	{{(10 * VORTEX_SCALE) + 5000, (20 * VORTEX_SCALE) + 5000},
 			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
-
-	{{6134, 5900}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 0, 132},
-
+	{{ARILOU_HOME_X, ARILOU_HOME_Y}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 0, 132},
+	{{MAX_X_UNIVERSE << 1, MAX_Y_UNIVERSE << 1}, 0, 0, 0, 0},
+	
+	// JMS: ORZ space locations
+	{{5000, 5000}, MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
 	{{MAX_X_UNIVERSE << 1, MAX_Y_UNIVERSE << 1}, 0, 0, 0, 0},
 };
 
diff -ruNp src.orig/uqm/planets/Makeinfo src/uqm/planets/Makeinfo
--- src.orig/uqm/planets/Makeinfo	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/Makeinfo	2017-11-01 15:31:03 -0700
@@ -1,4 +1,4 @@
 uqm_SUBDIRS="generate"
 uqm_CFILES="calc.c cargo.c devices.c gentopo.c lander.c orbits.c
 		oval.c pl_stuff.c planets.c plangen.c pstarmap.c report.c
-		roster.c scan.c solarsys.c surface.c"
+		roster.c scan.c solarsys.c surface.c triangul.c"
diff -ruNp src.orig/uqm/planets/calc.c src/uqm/planets/calc.c
--- src.orig/uqm/planets/calc.c	2017-11-01 15:30:25 -0700
+++ src/uqm/planets/calc.c	2017-11-01 15:31:03 -0700
@@ -201,14 +201,19 @@ CalcTemp (SYSTEM_INFO *SysInfoPtr, SIZE
 }
 
 static COUNT
-CalcRotation (PLANET_INFO *PlanetInfoPtr)
+CalcRotation (PLANET_INFO *PlanetInfoPtr, PLANET_DESC *planet)
 {
+	COUNT period;
 	if (PLANSIZE (PlanetInfoPtr->PlanDataPtr->Type) == GAS_GIANT)
-		return ((COUNT)CalcFromBase (80, 80));
+		period = ((COUNT)CalcFromBase (80, 80));
 	else if (((BYTE)TFB_Random () % 10) == 0)
-		return ((COUNT)CalcFromBase ((UWORD)50 * 240, (UWORD)200 * 240));
+		period = ((COUNT)CalcFromBase ((UWORD)50 * 240, (UWORD)200 * 240));
 	else
-		return ((COUNT)CalcFromBase (150, 150));
+		period = ((COUNT)CalcFromBase (150, 150));
+	// BW 2011: Research shows that most major moons have a synchronous rotation
+	if (planet->pPrevDesc != pSolarSysState->SunDesc)
+		period = ((COUNT)(FULL_CIRCLE * 240 / planet->orb_speed));
+	return period;
 }
 
 static SIZE
@@ -324,7 +329,7 @@ DoPlanetaryAnalysis (SYSTEM_INFO *SysInf
 				break;
 		}
 
-		SysInfoPtr->PlanetInfo.RotationPeriod = CalcRotation (&SysInfoPtr->PlanetInfo);
+		SysInfoPtr->PlanetInfo.RotationPeriod = CalcRotation (&SysInfoPtr->PlanetInfo, pPlanetDesc);
 		SysInfoPtr->PlanetInfo.SurfaceGravity =
 				CalcGravity (SysInfoPtr->PlanetInfo.PlanetDensity,
 				SysInfoPtr->PlanetInfo.PlanetRadius);
diff -ruNp src.orig/uqm/planets/cargo.c src/uqm/planets/cargo.c
--- src.orig/uqm/planets/cargo.c	2017-11-01 15:30:25 -0700
+++ src/uqm/planets/cargo.c	2017-11-01 15:31:03 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
 #include "../colors.h"
 #include "../controls.h"
 #include "../gamestr.h"
@@ -29,22 +31,19 @@
 #include "libs/graphics/drawable.h"
 		// for GetFrameBounds()
 
+#define ELEMENT_ORG_Y      RES_STAT_SCALE(35) // JMS_GFX
+#define FREE_ORG_Y         (ELEMENT_ORG_Y + (NUM_ELEMENT_CATEGORIES * ELEMENT_SPACING_Y))
+#define BIO_ORG_Y          RES_STAT_SCALE(119) // JMS_GFX
+#define ELEMENT_SPACING_Y  RES_STAT_SCALE(9) // JMS_GFX
+
+#define ELEMENT_COL_0      RES_STAT_SCALE(7) // JMS_GFX
+#define ELEMENT_COL_1      RES_STAT_SCALE(32) // JMS_GFX
+#define ELEMENT_COL_2      RES_STAT_SCALE(58) // JMS_GFX
 
-#define ELEMENT_ORG_Y      35
-#define FREE_ORG_Y         (ELEMENT_ORG_Y + (NUM_ELEMENT_CATEGORIES \
-							* ELEMENT_SPACING_Y))
-#define BIO_ORG_Y          119
-#define ELEMENT_SPACING_Y  9
-
-#define ELEMENT_COL_0      7
-#define ELEMENT_COL_1      32
-#define ELEMENT_COL_2      58
-
-#define ELEMENT_SEL_ORG_X  (ELEMENT_COL_0 + 7 + 5)
-#define ELEMENT_SEL_WIDTH  (ELEMENT_COL_2 - ELEMENT_SEL_ORG_X + 1)
-
-#define TEXT_BASELINE      6
+#define ELEMENT_SEL_ORG_X  (ELEMENT_COL_0 + RES_STAT_SCALE(7 + 5)) // JMS_GFX
+#define ELEMENT_SEL_WIDTH  (ELEMENT_COL_2 - ELEMENT_SEL_ORG_X + RES_STAT_SCALE(1)) // JMS_GFX
 
+#define TEXT_BASELINE      RES_STAT_SCALE(6) // JMS_GFX
 
 void
 ShowRemainingCapacity (void)
@@ -57,19 +56,19 @@ ShowRemainingCapacity (void)
 	OldContext = SetContext (StatusContext);
 	SetContextFont (TinyFont);
 
-	r.corner.x = 40;
-	r.corner.y = FREE_ORG_Y;
-
-	snprintf (buf, sizeof buf, "%u",
-			GetStorageBayCapacity () - GLOBAL_SIS (TotalElementMass));
-	t.baseline.x = ELEMENT_COL_2 + 1;
+	r.corner.x = RES_STAT_SCALE(40); // JMS_GFX
+	r.corner.y = FREE_ORG_Y; // JMS_GFX
+	
+	snprintf (buf, sizeof buf, "%u", GetStorageBayCapacity () - GLOBAL_SIS (TotalElementMass));
+	
+	t.baseline.x = ELEMENT_COL_2 + RES_STAT_SCALE(1); // JMS_GFX
 	t.baseline.y = r.corner.y + TEXT_BASELINE;
 	t.align = ALIGN_RIGHT;
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 
-	r.extent.width = t.baseline.x - r.corner.x + 1;
-	r.extent.height = ELEMENT_SPACING_Y - 2;
+	r.extent.width = t.baseline.x - r.corner.x + RES_STAT_SCALE(1); // JMS_GFX
+	r.extent.height = ELEMENT_SPACING_Y - RES_STAT_SCALE(2); // JMS_GFX
 
 	BatchGraphics ();
 	// erase previous free amount
@@ -92,7 +91,7 @@ DrawElementAmount (COUNT element, bool s
 
 	r.corner.x = ELEMENT_SEL_ORG_X;
 	r.extent.width = ELEMENT_SEL_WIDTH;
-	r.extent.height = ELEMENT_SPACING_Y - 2;
+	r.extent.height = ELEMENT_SPACING_Y - RES_STAT_SCALE(2); // JMS_GFX
 
 	if (element == NUM_ELEMENT_CATEGORIES)
 		r.corner.y = BIO_ORG_Y;
@@ -142,20 +141,20 @@ DrawCargoDisplay (void)
 	COORD cy;
 	COUNT i;
 
-	r.corner.x = 2;
-	r.extent.width = FIELD_WIDTH + 1;
-	r.corner.y = 20;
+	r.corner.x = RES_STAT_SCALE(2); // JMS_GFX
+	r.corner.y = RES_STAT_SCALE(20); // JMS_GFX
+	r.extent.width = FIELD_WIDTH + RES_STAT_SCALE(1) + RES_CASE(0,3,3); // JMS_GFX
 	// XXX: Shouldn't the height be 1 less? This draws the bottom border
 	//   1 pixel too low. Or if not, why do we need another box anyway?
-	r.extent.height = 129 - r.corner.y;
+	r.extent.height = RES_STAT_SCALE(129) - r.corner.y + RES_CASE(0,3,2); // JMS_GFX
 	DrawStarConBox (&r, 1,
 			SHADOWBOX_MEDIUM_COLOR, SHADOWBOX_DARK_COLOR,
 			TRUE, CARGO_BACK_COLOR);
 
 	// draw the "CARGO" title
 	SetContextFont (StarConFont);
-	t.baseline.x = (STATUS_WIDTH >> 1) - 1;
-	t.baseline.y = 27;
+	t.baseline.x = (STATUS_WIDTH >> 1) - RES_STAT_SCALE(1); // JMS_GFX
+	t.baseline.y = RES_STAT_SCALE(27); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.pStr = GAME_STRING (CARGO_STRING_BASE);
 	t.CharCount = (COUNT)~0;
@@ -166,6 +165,9 @@ DrawCargoDisplay (void)
 
 	s.frame = SetAbsFrameIndex (MiscDataFrame,
 			(NUM_SCANDOT_TRANSITIONS * 2) + 3);
+	if (RESOLUTION_FACTOR == 2)
+		s.frame = SetRelFrameIndex (s.frame, -1); // JMS_GFX
+
 	r.corner.x = ELEMENT_COL_0;
 	r.extent = GetFrameBounds (s.frame);
 	s.origin.x = r.corner.x + (r.extent.width >> 1);
@@ -174,7 +176,7 @@ DrawCargoDisplay (void)
 
 	// print element column headings
 	t.align = ALIGN_RIGHT;
-	t.baseline.y = cy - 1;
+	t.baseline.y = cy - RES_STAT_SCALE(1); // JMS_GFX
 	t.CharCount = (COUNT)~0;
 
 	SetContextForeGroundColor (CARGO_WORTH_COLOR);
@@ -216,15 +218,15 @@ DrawCargoDisplay (void)
 	DrawElementAmount (NUM_ELEMENT_CATEGORIES, false);
 
 	// draw the line over the Bio amount
-	r.corner.x = 4;
-	r.corner.y = BIO_ORG_Y - 2;
-	r.extent.width = FIELD_WIDTH - 3;
+	r.corner.x = RES_STAT_SCALE(4); // JMS_GFX
+	r.corner.y = BIO_ORG_Y - RES_STAT_SCALE(2); // JMS_GFX
+	r.extent.width = FIELD_WIDTH - RES_STAT_SCALE(3); // JMS_GFX
 	r.extent.height = 1;
 	SetContextForeGroundColor (CARGO_SELECTED_BACK_COLOR);
 	DrawFilledRectangle (&r);
 
 	// print "Free"
-	t.baseline.x = 5;
+	t.baseline.x = RES_STAT_SCALE(5); // JMS_GFX
 	t.baseline.y = FREE_ORG_Y + TEXT_BASELINE;
 	t.align = ALIGN_LEFT;
 	t.pStr = GAME_STRING (CARGO_STRING_BASE + 1);
diff -ruNp src.orig/uqm/planets/devices.c src/uqm/planets/devices.c
--- src.orig/uqm/planets/devices.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/devices.c	2017-11-01 15:31:03 -0700
@@ -16,6 +16,14 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2009 -In Orz space no one can hear your 'caster...
+// JMS 2010 -Black orb replaces rosy sphere
+//			-Temporal wrapper replaces shofixti maidens
+//			-Slaveshield buster replaces Clear spindle
+//			-Disabled sun device's and casters' effect on Chmmr at Procyon orbit.
+
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
 #include "../build.h"
 #include "../colors.h"
 #include "../encount.h"
@@ -36,6 +44,8 @@
 #include "planets.h"
 		// for SaveSolarSysLocation() and tests
 #include "libs/strlib.h"
+#include "libs/graphics/gfx_common.h"
+                // for scaling down devices in 4x
 
 
 // If DEBUG_DEVICES is defined, the device list shown in the game will
@@ -43,24 +53,24 @@
 // devices the player actually possesses.
 //#define DEBUG_DEVICES
 
-#define DEVICE_ICON_WIDTH  16
-#define DEVICE_ICON_HEIGHT 16
+#define DEVICE_ICON_WIDTH  RES_STAT_SCALE(16) // JMS_GFX
+#define DEVICE_ICON_HEIGHT RES_STAT_SCALE(16) // JMS_GFX
 
-#define DEVICE_ORG_Y       33
-#define DEVICE_SPACING_Y   (DEVICE_ICON_HEIGHT + 2)
+#define DEVICE_ORG_Y       RES_STAT_SCALE(33) // JMS_GFX
+#define DEVICE_SPACING_Y   (DEVICE_ICON_HEIGHT + RES_STAT_SCALE(2)) // JMS_GFX
 
-#define DEVICE_COL_0       4
-#define DEVICE_COL_1       40
+#define DEVICE_COL_0       RES_STAT_SCALE(4) // JMS_GFX
+#define DEVICE_COL_1       RES_STAT_SCALE(40) // JMS_GFX
 
-#define DEVICE_SEL_ORG_X  (DEVICE_COL_0 + DEVICE_ICON_WIDTH)
-#define DEVICE_SEL_WIDTH  (FIELD_WIDTH + 1 - DEVICE_SEL_ORG_X + 1)
+#define DEVICE_SEL_ORG_X  (DEVICE_COL_0 + DEVICE_ICON_WIDTH + RES_CASE(0,2,4))
+#define DEVICE_SEL_WIDTH  (FIELD_WIDTH + RES_STAT_SCALE(1) - DEVICE_SEL_ORG_X + RES_STAT_SCALE(1)) // JMS_GFX
 
-#define ICON_OFS_Y         1
-#define NAME_OFS_Y         2
-#define TEXT_BASELINE      6
-#define TEXT_SPACING_Y     7
+#define ICON_OFS_Y         RES_STAT_SCALE(1) // JMS_GFX
+#define NAME_OFS_Y         RES_STAT_SCALE(2) // JMS_GFX
+#define TEXT_BASELINE      RES_STAT_SCALE(6) // JMS_GFX
+#define TEXT_SPACING_Y     RES_STAT_SCALE(7) // JMS_GFX
 
-#define MAX_VIS_DEVICES    ((129 - DEVICE_ORG_Y) / DEVICE_SPACING_Y)
+#define MAX_VIS_DEVICES    ((RES_STAT_SCALE(129) - DEVICE_ORG_Y) / DEVICE_SPACING_Y) // JMS_GFX
 
 
 typedef enum
@@ -87,8 +97,8 @@ EraseDevicesBackground (void)
 {
 	RECT r;
 
-	r.corner.x = 2 + 1;
-	r.extent.width = FIELD_WIDTH + 1 - 2;
+	r.corner.x = RES_STAT_SCALE(2 + 1); // JMS_GFX
+	r.extent.width = FIELD_WIDTH + RES_STAT_SCALE(1) - RES_STAT_SCALE(2); // JMS_GFX
 	r.corner.y = DEVICE_ORG_Y;
 	r.extent.height = MAX_VIS_DEVICES * DEVICE_SPACING_Y;
 	SetContextForeGroundColor (DEVICES_BACK_COLOR);
@@ -139,20 +149,20 @@ DrawDevicesDisplay (DEVICES_STATE *devSt
 	COORD cy;
 	COUNT i;
 
-	r.corner.x = 2;
-	r.corner.y = 20;
-	r.extent.width = FIELD_WIDTH + 1;
+	r.corner.x = RES_STAT_SCALE(2); // JMS_GFX
+	r.corner.y = RES_STAT_SCALE(20); // JMS_GFX
+	r.extent.width = FIELD_WIDTH + RES_STAT_SCALE(1) + RES_CASE(0,3,3); // JMS_GFX
 	// XXX: Shouldn't the height be 1 less? This draws the bottom border
 	//   1 pixel too low. Or if not, why do we need another box anyway?
-	r.extent.height = 129 - r.corner.y;
+	r.extent.height = RES_STAT_SCALE(129) - r.corner.y + RES_CASE(0,3,2); // JMS_GFX
 	DrawStarConBox (&r, 1,
 			SHADOWBOX_MEDIUM_COLOR, SHADOWBOX_DARK_COLOR,
 			TRUE, DEVICES_BACK_COLOR);
 
 	// print the "DEVICES" title
 	SetContextFont (StarConFont);
-	t.baseline.x = (STATUS_WIDTH >> 1) - 1;
-	t.baseline.y = r.corner.y + 7;
+	t.baseline.x = (STATUS_WIDTH >> 1) - RES_STAT_SCALE(1); // JMS_GFX
+	t.baseline.y = r.corner.y + RES_STAT_SCALE(7); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.pStr = GAME_STRING (DEVICE_STRING_BASE);
 	t.CharCount = (COUNT)~0;
@@ -174,7 +184,19 @@ DrawDevicesDisplay (DEVICES_STATE *devSt
 		s.origin.y = cy + ICON_OFS_Y;
 		s.frame = SetAbsFrameIndex (MiscDataFrame,
 				77 + devState->list[devIndex]);
-		DrawStamp (&s);
+		if (RESOLUTION_FACTOR < 2)
+		{
+			DrawStamp (&s);			
+		}
+		else
+		{
+			int oldMode, oldScale;
+			oldMode = SetGraphicScaleMode (TFB_SCALE_BILINEAR);
+			oldScale = SetGraphicScale ((int)(3 * GSCALE_IDENTITY / 4));
+			DrawStamp (&s);
+			SetGraphicScale (oldScale);
+			SetGraphicScaleMode (oldMode);
+		}
 
 		DrawDevice (devState->list[devIndex], i, false);
 	}
@@ -219,23 +241,25 @@ UseCaster (void)
 {
 	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
 	{
-		if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
+		// BY JMS: ORZ space condition added - can't use caster in ORZ space.
+		if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1 && GET_GAME_STATE (ORZ_SPACE_SIDE) <= 1)
 		{
 			SET_GAME_STATE (USED_BROADCASTER, 1);
 			return TRUE;
 		}
 		return FALSE;
 	}
-
+	
 	if (LOBYTE (GLOBAL (CurrentActivity)) != IN_INTERPLANETARY
 			|| !playerInSolarSystem ())
 		return FALSE;
 
-	if (playerInPlanetOrbit ()
-			&& matchWorld (pSolarSysState, pSolarSysState->pOrbitalDesc,
-				1, MATCH_PLANET)
+	/*if (pSolarSysState->pOrbitalDesc == &pSolarSysState->PlanetDesc[1]
+			&& playerInPlanetOrbit ()
 			&& CurStarDescPtr->Index == CHMMR_DEFINED
-			&& !GET_GAME_STATE (CHMMR_UNLEASHED))
+			&& !GET_GAME_STATE (CHMMR_UNLEASHED)) */
+	// JMS: Disabled the caster's effect on CHMMR at Procyon.
+	if(0)
 	{
 		// In orbit around the Chenjesu/Mmrnmhrm home planet.
 		NextActivity |= CHECK_LOAD;  /* fake a load game */
@@ -255,9 +279,8 @@ UseCaster (void)
 		BOOLEAN FoundIlwrath;
 		HIPGROUP hGroup;
 
-		FoundIlwrath = (CurStarDescPtr->Index == ILWRATH_DEFINED)
-				&& ActivateStarShip (ILWRATH_SHIP, SPHERE_TRACKING);
-				// In the Ilwrath home system and they are alive?
+		FoundIlwrath = (BOOLEAN)(CurStarDescPtr->Index == ILWRATH_DEFINED);
+				// In the Ilwrath home system?
 
 		if (!FoundIlwrath &&
 				(hGroup = GetHeadLink (&GLOBAL (ip_group_q))))
@@ -307,16 +330,8 @@ InvokeDevice (BYTE which_device)
 
 	switch (which_device)
 	{
-		case ROSY_SPHERE_DEVICE:
-			val = GET_GAME_STATE (ULTRON_CONDITION);
-			if (val)
-			{
-				SET_GAME_STATE (ULTRON_CONDITION, val + 1);
-				SET_GAME_STATE (ROSY_SPHERE_ON_SHIP, 0);
-				SET_GAME_STATE (DISCUSSED_ULTRON, 0);
-				SET_GAME_STATE (SUPOX_ULTRON_HELP, 0);
-				return DEVICE_SUCCESS;
-			}
+		// JMS: Added Black orb device
+		case BLACK_ORB_DEVICE:
 			break;
 		case ARTIFACT_2_DEVICE:
 			break;
@@ -329,10 +344,14 @@ InvokeDevice (BYTE which_device)
 				PlayMenuSound (MENU_SOUND_INVOKED);
 				SleepThreadUntil (FadeScreen (FadeAllToWhite, ONE_SECOND * 1)
 						+ (ONE_SECOND * 2));
-				if (CurStarDescPtr->Index != CHMMR_DEFINED
-						|| !matchWorld (pSolarSysState,
-								pSolarSysState->pOrbitalDesc,
-								1, MATCH_PLANET))
+				
+				
+				//if (CurStarDescPtr->Index != CHMMR_DEFINED
+				//		|| pSolarSysState->pOrbitalDesc !=
+				//		&pSolarSysState->PlanetDesc[1])
+				// JMS: Although the Sun device won't be in the final game, disabled its
+				// effect on Chmmr at procyon anyways.
+				if(1)
 				{
 					FadeScreen (FadeAllToColor, ONE_SECOND * 2);
 				}
@@ -366,7 +385,8 @@ InvokeDevice (BYTE which_device)
 			break;
 		case ULTRON_3_DEVICE:
 			break;
-		case MAIDENS_DEVICE:
+		// JMS: Temporal Wrapper replaces Maidens device
+		case TEMPORAL_WRAPPER_DEVICE:
 			break;
 		case TALKING_PET_DEVICE:
 			NextActivity |= CHECK_LOAD; /* fake a load game */
@@ -413,14 +433,14 @@ InvokeDevice (BYTE which_device)
 				return DEVICE_SUCCESS;
 			}
 			break;
-		case CLEAR_SPINDLE_DEVICE:
-			val = GET_GAME_STATE (ULTRON_CONDITION);
-			if (val)
+			// JMS: Slaveshield buster replaces Clear Spindle
+		case SHIELD_BUSTER_DEVICE:
+			if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
 			{
-				SET_GAME_STATE (ULTRON_CONDITION, val + 1);
-				SET_GAME_STATE (CLEAR_SPINDLE_ON_SHIP, 0);
-				SET_GAME_STATE (DISCUSSED_ULTRON, 0);
-				SET_GAME_STATE (SUPOX_ULTRON_HELP, 0);
+				if(!GET_GAME_STATE(USED_BUSTER))
+					SET_GAME_STATE (USED_BUSTER, 1);
+				else
+					SET_GAME_STATE (USED_BUSTER, 0);
 				return DEVICE_SUCCESS;
 			}
 			break;
@@ -560,8 +580,9 @@ InventoryDevices (BYTE *pDeviceMap, COUN
 		DeviceState = 0;
 		switch (i)
 		{
-			case ROSY_SPHERE_DEVICE:
-				DeviceState = GET_GAME_STATE (ROSY_SPHERE_ON_SHIP);
+			// JMS: Black orb device
+			case BLACK_ORB_DEVICE:
+				DeviceState = GET_GAME_STATE (BLACK_ORB_ON_SHIP);
 				break;
 			case ARTIFACT_2_DEVICE:
 				DeviceState = GET_GAME_STATE (ARTIFACT_2_ON_SHIP);
@@ -587,8 +608,9 @@ InventoryDevices (BYTE *pDeviceMap, COUN
 			case ULTRON_3_DEVICE:
 				DeviceState = (GET_GAME_STATE (ULTRON_CONDITION) == 4);
 				break;
-			case MAIDENS_DEVICE:
-				DeviceState = GET_GAME_STATE (MAIDENS_ON_SHIP);
+			// JMS: Temporal Wrapper device
+			case TEMPORAL_WRAPPER_DEVICE:
+				DeviceState = GET_GAME_STATE (TEMPORAL_WRAPPER_ON_SHIP);
 				break;
 			case TALKING_PET_DEVICE:
 				DeviceState = GET_GAME_STATE (TALKING_PET_ON_SHIP);
@@ -596,8 +618,9 @@ InventoryDevices (BYTE *pDeviceMap, COUN
 			case AQUA_HELIX_DEVICE:
 				DeviceState = GET_GAME_STATE (AQUA_HELIX_ON_SHIP);
 				break;
-			case CLEAR_SPINDLE_DEVICE:
-				DeviceState = GET_GAME_STATE (CLEAR_SPINDLE_ON_SHIP);
+			// JMS: Slaveshield buster device
+			case SHIELD_BUSTER_DEVICE:
+				DeviceState = GET_GAME_STATE (SHIELD_BUSTER_ON_SHIP);
 				break;
 			case UMGAH_HYPERWAVE_DEVICE:
 				DeviceState = GET_GAME_STATE (UMGAH_BROADCASTERS_ON_SHIP);
diff -ruNp src.orig/uqm/planets/generate/Makeinfo src/uqm/planets/generate/Makeinfo
--- src.orig/uqm/planets/generate/Makeinfo	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/Makeinfo	2017-11-01 15:31:03 -0700
@@ -1,5 +1,7 @@
 uqm_CFILES="gendefault.c genand.c genburv.c genchmmr.c gencol.c gendru.c
-		genilw.c genmel.c genmyc.c genorz.c genpet.c genpku.c genrain.c
-		gensam.c genshof.c gensly.c gensol.c genspa.c gensup.c gensyr.c
+		genhint1.c genhint2.c genilw.c genlurg.c genmel.c genmyc.c
+		genorz.c genorzspaceportal.c genpku.c genrain.c
+		gensam.c genshof.c genshocrash.c genshofixticolony.c 
+		genslaverace.c gensly.c gensol.c genspa.c gensup.c gensyr.c
 		genthrad.c gentrap.c genutw.c genvault.c genvux.c genwreck.c
-		genyeh.c genzfpscout.c genzoq.c"
+		genyeh.c genzoq.c"
diff -ruNp src.orig/uqm/planets/generate/genand.c src/uqm/planets/generate/genand.c
--- src.orig/uqm/planets/generate/genand.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/genand.c	2017-11-01 15:31:03 -0700
@@ -16,10 +16,11 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: -Removed the mechanism that varies landing party text at three different androsynth ruins.
+
 #include "genall.h"
 #include "../lander.h"
 #include "../planets.h"
-#include "../scan.h"
 #include "../../globdata.h"
 #include "../../nameref.h"
 #include "../../resinst.h"
@@ -30,10 +31,8 @@
 static bool GenerateAndrosynth_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateAndrosynth_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateAndrosynth_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static bool GenerateAndrosynth_pickupEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static bool GenerateAndrosynth_generateEnergy (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
 
 
 const GenerateFunctions generateAndrosynthFunctions = {
@@ -47,9 +46,6 @@ const GenerateFunctions generateAndrosyn
 	/* .generateMinerals = */ GenerateDefault_generateMinerals,
 	/* .generateEnergy   = */ GenerateAndrosynth_generateEnergy,
 	/* .generateLife     = */ GenerateDefault_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GenerateAndrosynth_pickupEnergy,
-	/* .pickupLife       = */ GenerateDefault_pickupLife,
 };
 
 
@@ -68,6 +64,7 @@ GenerateAndrosynth_generatePlanets (SOLA
 			COSINE (angle, solarSys->PlanetDesc[1].radius);
 	solarSys->PlanetDesc[1].location.y =
 			SINE (angle, solarSys->PlanetDesc[1].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[1], FALSE, 1);
 
 	return true;
 }
@@ -77,8 +74,7 @@ GenerateAndrosynth_generateOrbital (SOLA
 {
 	if (matchWorld (solarSys, world, 1, MATCH_PLANET))
 	{
-		COUNT i;
-		COUNT visits = 0;
+		UWORD retval;
 
 		LoadStdLanderFont (&solarSys->SysInfo.PlanetInfo);
 		solarSys->PlanetSideFrame[1] =
@@ -86,28 +82,25 @@ GenerateAndrosynth_generateOrbital (SOLA
 		solarSys->SysInfo.PlanetInfo.DiscoveryString =
 				CaptureStringTable (
 				LoadStringTable (ANDROSYNTH_RUINS_STRTAB));
-		// Androsynth ruins are a special case. The DiscoveryString contains
-		// several lander reports which form a story. Each report is given
-		// when the player collides with a new city ruin. Ruins previously
-		// visited are marked in the upper 16 bits of ScanRetrieveMask, and
-		// the lower bits are cleared to keep the ruin nodes on the map.
-		for (i = 16; i < 32; ++i)
+		retval = HIWORD (
+				solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]);
+		while (retval)
 		{
-			if (isNodeRetrieved (&solarSys->SysInfo.PlanetInfo, ENERGY_SCAN, i))
-				++visits;
-		}
-		if (visits >= GetStringTableCount (
-				solarSys->SysInfo.PlanetInfo.DiscoveryString))
-		{	// All the reports were already given
-			DestroyStringTable (ReleaseStringTable (
-					solarSys->SysInfo.PlanetInfo.DiscoveryString));
-			solarSys->SysInfo.PlanetInfo.DiscoveryString = 0;
-		}
-		else
-		{	// Advance the report sequence to the first unread
-			solarSys->SysInfo.PlanetInfo.DiscoveryString =
-					SetRelStringTableIndex (
-					solarSys->SysInfo.PlanetInfo.DiscoveryString, visits);
+			if (retval & 1)
+			{
+				solarSys->SysInfo.PlanetInfo.DiscoveryString =
+						SetRelStringTableIndex (
+						solarSys->SysInfo.PlanetInfo.DiscoveryString, 1);
+				if (GetStringTableIndex (
+						solarSys->SysInfo.PlanetInfo.DiscoveryString) == 0)
+				{
+					DestroyStringTable (ReleaseStringTable (
+							solarSys->SysInfo.PlanetInfo.DiscoveryString));
+					solarSys->SysInfo.PlanetInfo.DiscoveryString = 0;
+				}
+			}
+
+			retval >>= 1;
 		}
 	}
 
@@ -126,39 +119,70 @@ GenerateAndrosynth_generateOrbital (SOLA
 }
 
 static bool
-GenerateAndrosynth_pickupEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateAndrosynth_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
+		COUNT *whichNode)
 {
+	DWORD rand_val;
+	DWORD old_rand;
+
 	if (matchWorld (solarSys, world, 1, MATCH_PLANET))
 	{
-		PLANET_INFO *planetInfo = &solarSys->SysInfo.PlanetInfo;
-
-		// Ruins previously visited are marked in the upper 16 bits
-		if (isNodeRetrieved (planetInfo, ENERGY_SCAN, whichNode + 16))
-			return false; // already visited this ruin, do not remove
+		COUNT i;
+		COUNT nodeI;
 
-		setNodeRetrieved (planetInfo, ENERGY_SCAN, whichNode + 16);
-		// We set the retrieved bit manually here and need to indicate
-		// the change to the solar system state functions
-		SET_GAME_STATE (PLANETARY_CHANGE, 1);
+		old_rand = TFB_SeedRandom (
+				solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN]);
 
-		// Androsynth ruins have several lander reports which form a story
-		GenerateDefault_landerReportCycle (solarSys);
+		nodeI = 0;
+		i = 0;
+		do
+		{
+			rand_val = TFB_Random ();
+			solarSys->SysInfo.PlanetInfo.CurPt.x = ((LOWORD (rand_val)) % (MAP_WIDTH - (8 << 1))) + 8;
+			solarSys->SysInfo.PlanetInfo.CurPt.y = ((LOWORD (rand_val)) % (MAP_HEIGHT - (8 << 1))) + 8;
+			solarSys->SysInfo.PlanetInfo.CurType = 0;
+			solarSys->SysInfo.PlanetInfo.CurDensity = 0;
+
+			if (solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+					& (1L << i))
+			{
+				solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+						&= ~(1L << i);
+				if (!(solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+						& (1L << (i + 16))))
+				{
+					SET_GAME_STATE (PLANETARY_CHANGE, 1);
+
+					solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+							|= (1L << (i + 16));
+					if (solarSys->SysInfo.PlanetInfo.DiscoveryString)
+					{
+						UnbatchGraphics ();
+						DoDiscoveryReport (MenuSounds);
+						BatchGraphics ();
+						// JMS: Removed the mechanism that varies landing party text 
+						// at three different androsynth ruins.
+						/*solarSys->SysInfo.PlanetInfo.DiscoveryString =
+								SetRelStringTableIndex (
+								solarSys->SysInfo.PlanetInfo.DiscoveryString,
+								1);*/
+					}
+				}
+			}
+
+			if (nodeI >= *whichNode
+					&& !(solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+					& (1L << i)))
+				break;
+			++nodeI;
+		} while (++i < 16);
+		*whichNode = nodeI;
 
-		return false; // do not remove the node from the surface
+		TFB_SeedRandom (old_rand);
+		return true;
 	}
 
-	return false;
+	*whichNode = 0;
+	return true;
 }
 
-static COUNT
-GenerateAndrosynth_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
-{
-	if (matchWorld (solarSys, world, 1, MATCH_PLANET))
-	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
-	}
-
-	return 0;
-}
diff -ruNp src.orig/uqm/planets/generate/genburv.c src/uqm/planets/generate/genburv.c
--- src.orig/uqm/planets/generate/genburv.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/genburv.c	2017-11-01 15:31:03 -0700
@@ -17,7 +17,6 @@
  */
 
 #include "genall.h"
-#include "../lander.h"
 #include "../planets.h"
 #include "../../globdata.h"
 #include "../../nameref.h"
@@ -30,10 +29,8 @@ static bool GenerateBurvixese_generateMo
 		PLANET_DESC *planet);
 static bool GenerateBurvixese_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateBurvixese_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static bool GenerateBurvixese_pickupEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static bool GenerateBurvixese_generateEnergy (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
 
 
 const GenerateFunctions generateBurvixeseFunctions = {
@@ -47,9 +44,6 @@ const GenerateFunctions generateBurvixes
 	/* .generateMinerals = */ GenerateDefault_generateMinerals,
 	/* .generateEnergy   = */ GenerateBurvixese_generateEnergy,
 	/* .generateLife     = */ GenerateDefault_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GenerateBurvixese_pickupEnergy,
-	/* .pickupLife       = */ GenerateDefault_pickupLife,
 };
 
 
@@ -69,6 +63,7 @@ GenerateBurvixese_generatePlanets (SOLAR
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 	return true;
 }
 
@@ -91,6 +86,7 @@ GenerateBurvixese_generateMoons (SOLARSY
 				COSINE (angle, solarSys->MoonDesc[0].radius);
 		solarSys->MoonDesc[0].location.y =
 				SINE (angle, solarSys->MoonDesc[0].radius);
+		ComputeSpeed(&solarSys->MoonDesc[0], TRUE, 1);
 	}
 	return true;
 }
@@ -140,54 +136,77 @@ GenerateBurvixese_generateOrbital (SOLAR
 	return true;
 }
 
-static COUNT
+static bool
 GenerateBurvixese_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+		COUNT *whichNode)
 {
+	DWORD rand_val;
+	DWORD old_rand;
+
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
-	}
+		COUNT nodeI;
+		COUNT i;
 
-	if (matchWorld (solarSys, world, 0, 0))
-	{
-		// This check is redundant since the retrieval bit will keep the
-		// node from showing up again
-		if (GET_GAME_STATE (BURVIXESE_BROADCASTERS))
-		{	// already picked up
-			return 0;
-		}
-		
-		return GenerateDefault_generateArtifact (solarSys, whichNode);
-	}
+		old_rand = TFB_SeedRandom (
+				solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN]);
 
-	return 0;
-}
+		nodeI = 0;
+		i = 0;
+		do
+		{
+			rand_val = TFB_Random ();
+			solarSys->SysInfo.PlanetInfo.CurPt.x =
+					(LOBYTE (LOWORD (rand_val)) % (MAP_WIDTH - (8 << 1))) + 8;
+			solarSys->SysInfo.PlanetInfo.CurPt.y =
+					(HIBYTE (LOWORD (rand_val)) % (MAP_HEIGHT - (8 << 1))) + 8;
+			solarSys->SysInfo.PlanetInfo.CurType = 1;
+			solarSys->SysInfo.PlanetInfo.CurDensity = 0;
+			if (nodeI >= *whichNode
+					&& !(solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+					& (1L << i)))
+				break;
+			++nodeI;
+		} while (++i < 16);
+		*whichNode = nodeI;
 
-static bool
-GenerateBurvixese_pickupEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
-{
-	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
-	{
-		// Standard ruins report
-		GenerateDefault_landerReportCycle (solarSys);
-		return false;
+		TFB_SeedRandom (old_rand);
+		return true;
 	}
 
-	if (matchWorld (solarSys, world, 0, 0))
+	if (matchWorld (solarSys, world, 0, 0)
+			&& !GET_GAME_STATE (BURVIXESE_BROADCASTERS))
 	{
-		assert (!GET_GAME_STATE (BURVIXESE_BROADCASTERS) && whichNode == 0);
-
-		GenerateDefault_landerReport (solarSys);
-		SetLanderTakeoff ();
+		old_rand = TFB_SeedRandom (
+				solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN]);
 
-		SET_GAME_STATE (BURVIXESE_BROADCASTERS, 1);
-		SET_GAME_STATE (BURV_BROADCASTERS_ON_SHIP, 1);
+		rand_val = TFB_Random ();
+		solarSys->SysInfo.PlanetInfo.CurPt.x =
+				(LOBYTE (LOWORD (rand_val)) % (MAP_WIDTH - (8 << 1))) + 8;
+		solarSys->SysInfo.PlanetInfo.CurPt.y =
+				(HIBYTE (LOWORD (rand_val)) % (MAP_HEIGHT - (8 << 1))) + 8;
+		solarSys->SysInfo.PlanetInfo.CurDensity = 0;
+		solarSys->SysInfo.PlanetInfo.CurType = 0;
+		if (!(solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+				& (1L << 0))
+				&& *whichNode == (COUNT)~0)
+			*whichNode = 1;
+		else
+		{
+			*whichNode = 0;
+			if (solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+					& (1L << 0))
+			{
+				SET_GAME_STATE (BURVIXESE_BROADCASTERS, 1);
+				SET_GAME_STATE (BURV_BROADCASTERS_ON_SHIP, 1);
+			}
+		}
 
-		return true; // picked up
+		TFB_SeedRandom (old_rand);
+		return true;
 	}
 
-	(void) whichNode;
-	return false;
+	*whichNode = 0;
+	return true;
 }
+
diff -ruNp src.orig/uqm/planets/generate/genchmmr.c src/uqm/planets/generate/genchmmr.c
--- src.orig/uqm/planets/generate/genchmmr.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/genchmmr.c	2017-11-01 15:31:03 -0700
@@ -16,6 +16,9 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: -Added Chmmr to starbase
+//			 -Chmmr home planet is now restricted from landing
+
 #include "genall.h"
 #include "../lander.h"
 #include "../planets.h"
@@ -46,9 +49,6 @@ const GenerateFunctions generateChmmrFun
 	/* .generateMinerals = */ GenerateDefault_generateMinerals,
 	/* .generateEnergy   = */ GenerateDefault_generateEnergy,
 	/* .generateLife     = */ GenerateDefault_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GenerateDefault_pickupEnergy,
-	/* .pickupLife       = */ GenerateDefault_pickupLife,
 };
 
 
@@ -58,8 +58,7 @@ GenerateChmmr_generatePlanets (SOLARSYS_
 	GenerateDefault_generatePlanets (solarSys);
 
 	solarSys->PlanetDesc[1].data_index = SAPPHIRE_WORLD;
-	if (!GET_GAME_STATE (CHMMR_UNLEASHED))
-		solarSys->PlanetDesc[1].data_index |= PLANET_SHIELDED;
+	solarSys->PlanetDesc[1].flags = PLANET_RESTRICTED;
 	solarSys->PlanetDesc[1].NumPlanets = 1;
 
 	return true;
@@ -83,6 +82,7 @@ GenerateChmmr_generateMoons (SOLARSYS_ST
 				COSINE (angle, solarSys->MoonDesc[0].radius);
 		solarSys->MoonDesc[0].location.y =
 				SINE (angle, solarSys->MoonDesc[0].radius);
+		ComputeSpeed(&solarSys->MoonDesc[0], TRUE, 1);
 	}
 
 	return true;
@@ -105,49 +105,26 @@ GenerateChmmr_generateOrbital (SOLARSYS_
 		
 			return true;
 		}
-		else if (GET_GAME_STATE (SUN_DEVICE_ON_SHIP)
-				&& !GET_GAME_STATE (ILWRATH_DECEIVED)
-				&& ActivateStarShip (ILWRATH_SHIP, SPHERE_TRACKING))
-		{
-			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
-			ReinitQueue (&GLOBAL (ip_group_q));
-			assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
-
-			CloneShipFragment (ILWRATH_SHIP,
-					&GLOBAL (npc_built_ship_q), INFINITE_FLEET);
-
-			SET_GAME_STATE (GLOBAL_FLAGS_AND_DATA, 1 << 6);
-			GLOBAL (CurrentActivity) |= START_INTERPLANETARY;
-			InitCommunication (ILWRATH_CONVERSATION);
-
-			if (!(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD)))
+	}
+	else if (matchWorld (solarSys, world, 1, 0))
+	{
+		/* Starbase */
+		// JMS: The Chmmr reside in starbase
+		CloneShipFragment (CHMMR_SHIP, &GLOBAL (npc_built_ship_q), INFINITE_FLEET);
+		
+		// JMS: This code summons starbase subroutine. (The global_flags_and_data == ~0
+		// is checked in Starcon2Main function in starcon.c)
+		GLOBAL (CurrentActivity) |= START_ENCOUNTER;
+		SET_GAME_STATE (GLOBAL_FLAGS_AND_DATA, (BYTE)~0);
+		
+		// JMS: Necessary to empty the NPC ship queue after visit.
+		// Otherwise next encounter with a ship crashes the game.
+		if (!(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD)))
 			{
 				GLOBAL (CurrentActivity) &= ~START_INTERPLANETARY;
 				ReinitQueue (&GLOBAL (npc_built_ship_q));
 				GetGroupInfo (GROUPS_RANDOM, GROUP_LOAD_IP);
 			}
-
-			return true;
-		}
-	}
-	else if (matchWorld (solarSys, world, 1, 0))
-	{
-		/* Starbase */
-		LockMutex (GraphicsLock);
-
-		LoadStdLanderFont (&solarSys->SysInfo.PlanetInfo);
-		solarSys->SysInfo.PlanetInfo.DiscoveryString =
-				CaptureStringTable (LoadStringTable (CHMMR_BASE_STRTAB));
-
-		DoDiscoveryReport (MenuSounds);
-
-		DestroyStringTable (ReleaseStringTable (
-				solarSys->SysInfo.PlanetInfo.DiscoveryString));
-		solarSys->SysInfo.PlanetInfo.DiscoveryString = 0;
-		FreeLanderFont (&solarSys->SysInfo.PlanetInfo);
-
-		UnlockMutex (GraphicsLock);
-
 		return true;
 	}
 
diff -ruNp src.orig/uqm/planets/generate/gencol.c src/uqm/planets/generate/gencol.c
--- src.orig/uqm/planets/generate/gencol.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/gencol.c	2017-11-01 15:31:03 -0700
@@ -16,16 +16,26 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: -Removed slave shield and the lone ur-quan ship from the system
+
 #include "genall.h"
 #include "../planets.h"
 #include "../../build.h"
 #include "../../globdata.h"
 #include "../../grpinfo.h"
+#include "../../nameref.h" // JMS
+#include "../../resinst.h" // JMS
+#include "../../sounds.h" //JMS
 #include "../../state.h"
 #include "libs/mathlib.h"
+#include "libs/mathlib.h" // JMS
+#include "libs/log.h" // JMS
+#include "../lander.h" //JMS
 
 
 static bool GenerateColony_initNpcs (SOLARSYS_STATE *solarSys);
+static bool GenerateColony_generateEnergy (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
 static bool GenerateColony_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateColony_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
@@ -40,11 +50,8 @@ const GenerateFunctions generateColonyFu
 	/* .generateName     = */ GenerateDefault_generateName,
 	/* .generateOrbital  = */ GenerateColony_generateOrbital,
 	/* .generateMinerals = */ GenerateDefault_generateMinerals,
-	/* .generateEnergy   = */ GenerateDefault_generateEnergy,
+	/* .generateEnergy   = */ GenerateColony_generateEnergy,
 	/* .generateLife     = */ GenerateDefault_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GenerateDefault_pickupEnergy,
-	/* .pickupLife       = */ GenerateDefault_pickupLife,
 };
 
 
@@ -53,6 +60,8 @@ GenerateColony_initNpcs (SOLARSYS_STATE
 {
 	HIPGROUP hGroup;
 
+	/* JMS: No Ur-Quans in Vela anymore...
+			 
 	GLOBAL (BattleGroupRef) = GET_GAME_STATE_32 (COLONY_GRPOFFS0);
 	if (GLOBAL (BattleGroupRef) == 0)
 	{
@@ -61,7 +70,7 @@ GenerateColony_initNpcs (SOLARSYS_STATE
 		GLOBAL (BattleGroupRef) = PutGroupInfo (GROUPS_ADD_NEW, 1);
 		ReinitQueue (&GLOBAL (npc_built_ship_q));
 		SET_GAME_STATE_32 (COLONY_GRPOFFS0, GLOBAL (BattleGroupRef));
-	}
+	}*/
 
 	GenerateDefault_initNpcs (solarSys);
 
@@ -83,6 +92,44 @@ GenerateColony_initNpcs (SOLARSYS_STATE
 	return true;
 }
 
+// JMS: The whole GENERATE_ENERGY case is new here. Its purpose is to create energy blip of the Precursor factory remnants.
+static bool
+GenerateColony_generateEnergy (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode)
+{
+	DWORD rand_val, old_rand;
+	
+	if (solarSys->pOrbitalDesc == &solarSys->PlanetDesc[0])
+		{
+			old_rand = TFB_SeedRandom (
+						   solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN]);
+			
+			rand_val = TFB_Random ();
+			solarSys->SysInfo.PlanetInfo.CurPt.x = MAP_WIDTH * 5 / 9;
+			solarSys->SysInfo.PlanetInfo.CurPt.y = MAP_HEIGHT * 2 / 5;
+			solarSys->SysInfo.PlanetInfo.CurDensity = 0;
+			solarSys->SysInfo.PlanetInfo.CurType = 1;
+			if (!(solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN] & (1L << 0))
+			    && solarSys->CurNode == (COUNT)~0)
+				{
+					solarSys->CurNode = 1;
+				}
+			else
+				{
+					solarSys->CurNode = 0;
+					if (solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN] & (1L << 0))
+						{
+							SET_GAME_STATE (VELA_FACTORY_VISITED, 1);
+						}
+				}
+			
+			TFB_SeedRandom (old_rand);
+			return true;
+		}
+	solarSys->CurNode = 0;
+	return true;
+}
+
 static bool
 GenerateColony_generatePlanets (SOLARSYS_STATE *solarSys)
 {
@@ -96,8 +143,8 @@ GenerateColony_generatePlanets (SOLARSYS
 	angle = ARCTAN (pMinPlanet->location.x, pMinPlanet->location.y);
 	pMinPlanet->location.x = COSINE (angle, pMinPlanet->radius);
 	pMinPlanet->location.y = SINE (angle, pMinPlanet->radius);
-	pMinPlanet->data_index = WATER_WORLD | PLANET_SHIELDED;
-
+	pMinPlanet->data_index = WATER_WORLD; // JMS: Vela colony is not shielded anymore.
+	ComputeSpeed(pMinPlanet, FALSE, 1);
 	return true;
 }
 
@@ -108,8 +155,16 @@ GenerateColony_generateOrbital (SOLARSYS
 	{
 		DoPlanetaryAnalysis (&solarSys->SysInfo, world);
 
+		// JMS: This displays the graphics of the Precursor factory remnants
+		// and gives the landing team message upon finding it.
+		LoadStdLanderFont (&solarSys->SysInfo.PlanetInfo);
+		solarSys->PlanetSideFrame[1] =
+			CaptureDrawable (LoadGraphic (UMGAH_BCS_MASK_PMAP_ANIM));
+		solarSys->SysInfo.PlanetInfo.DiscoveryString =
+			CaptureStringTable (LoadStringTable (VELA_FACTORY_STRTAB));
+		
 		solarSys->SysInfo.PlanetInfo.AtmoDensity =
-				EARTH_ATMOSPHERE * 98 / 100;
+			EARTH_ATMOSPHERE * 98 / 100;
 		solarSys->SysInfo.PlanetInfo.Weather = 0;
 		solarSys->SysInfo.PlanetInfo.Tectonics = 0;
 		solarSys->SysInfo.PlanetInfo.SurfaceTemperature = 28;
diff -ruNp src.orig/uqm/planets/generate/gendefault.c src/uqm/planets/generate/gendefault.c
--- src.orig/uqm/planets/generate/gendefault.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/gendefault.c	2017-11-01 15:31:03 -0700
@@ -16,14 +16,12 @@
 
 #include "genall.h"
 #include "../planets.h"
-#include "../lander.h"
 #include "../../encount.h"
 #include "../../gamestr.h"
 #include "../../globdata.h"
 #include "../../grpinfo.h"
 #include "../../races.h"
 #include "../../state.h"
-#include "../../sounds.h"
 #include "libs/mathlib.h"
 
 
@@ -37,6 +35,12 @@ bool GenerateDefault_generateName (SOLAR
 		PLANET_DESC *world);
 bool GenerateDefault_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
+bool GenerateDefault_generateMinerals (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
+bool GenerateDefault_generateEnergy (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
+bool GenerateDefault_generateLife (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
 
 static void GeneratePlanets (SOLARSYS_STATE *system);
 static void check_yehat_rebellion (void);
@@ -53,9 +57,6 @@ const GenerateFunctions generateDefaultF
 	/* .generateMinerals = */ GenerateDefault_generateMinerals,
 	/* .generateEnergy   = */ GenerateDefault_generateEnergy,
 	/* .generateLife     = */ GenerateDefault_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GenerateDefault_pickupEnergy,
-	/* .pickupLife       = */ GenerateDefault_pickupLife,
 };
 
 
@@ -116,9 +117,14 @@ bool
 GenerateDefault_generateName (SOLARSYS_STATE *solarSys, PLANET_DESC *world)
 {
 	COUNT i = planetIndex (solarSys, world);
-	utf8StringCopy (GLOBAL_SIS (PlanetName), sizeof (GLOBAL_SIS (PlanetName)),
-			GAME_STRING (PLANET_NUMBER_BASE + (9 + 7) + i));
-	SET_GAME_STATE (BATTLE_PLANET, world->data_index);
+	utf8StringCopy (GLOBAL_SIS (PlanetName), sizeof (GLOBAL_SIS (PlanetName)), GAME_STRING (PLANET_NUMBER_BASE + (9 + 7) + i));
+	
+	// JMS: This is to make 0 planet systems work (e.g. Orz space portal).
+	if (pSolarSysState->SunDesc[0].NumPlanets != 0)
+		SET_GAME_STATE (BATTLE_PLANET, world->data_index);
+	else 
+		SET_GAME_STATE (BATTLE_PLANET, solarSys->PlanetDesc[0].data_index);
+
 
 	return true;
 }
@@ -162,137 +168,34 @@ GenerateDefault_generateOrbital (SOLARSY
 	return true;
 }
 
-COUNT
+bool
 GenerateDefault_generateMinerals (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode)
+		PLANET_DESC *world, COUNT *whichNode)
 {
-	GenerateMineralDeposits (&solarSys->SysInfo, &whichNode);
+	GenerateMineralDeposits (&solarSys->SysInfo, whichNode);
 	(void) world;
-	return whichNode;
-}
-
-bool
-GenerateDefault_pickupMinerals (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
-{
-	// Minerals do not need any extra handling as of now
-	(void) solarSys;
-	(void) world;
-	(void) whichNode;
 	return true;
 }
 
-COUNT
+bool
 GenerateDefault_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+		COUNT *whichNode)
 {
-	(void) whichNode;
+	*whichNode = 0;
 	(void) solarSys;
 	(void) world;
-	return 0;
+	return true;
 }
 
 bool
-GenerateDefault_pickupEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
-{
-	// This should never be called since every energy node needs
-	// special handling and the function should be overridden
-	assert (false);
-	(void) solarSys;
-	(void) world;
-	(void) whichNode;
-	return false;
-}
-
-COUNT
 GenerateDefault_generateLife (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
-{
-	GenerateLifeForms (&solarSys->SysInfo, &whichNode);
-	(void) world;
-	return whichNode;
-}
-
-bool
-GenerateDefault_pickupLife (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+		COUNT *whichNode)
 {
-	// Bio does not need any extra handling as of now
-	(void) solarSys;
+	GenerateLifeForms (&solarSys->SysInfo, whichNode);
 	(void) world;
-	(void) whichNode;
 	return true;
 }
 
-COUNT
-GenerateDefault_generateArtifact (SOLARSYS_STATE *solarSys, COUNT whichNode)
-{
-	// Generate an energy node at a random location
-	GenerateRandomNodes (&solarSys->SysInfo, ENERGY_SCAN, 1, 0, &whichNode);
-	return whichNode;
-}
-
-COUNT
-GenerateDefault_generateRuins (SOLARSYS_STATE *solarSys, COUNT whichNode)
-{
-	// Generate a standard spread of city ruins of a destroyed civilization
-	GenerateRandomNodes (&solarSys->SysInfo, ENERGY_SCAN, NUM_RACE_RUINS,
-			0, &whichNode);
-	return whichNode;
-}
-
-static inline void
-runLanderReport (void)
-{
-	UnbatchGraphics ();
-	DoDiscoveryReport (MenuSounds);
-	BatchGraphics ();
-}
-
-bool
-GenerateDefault_landerReport (SOLARSYS_STATE *solarSys)
-{
-	PLANET_INFO *planetInfo = &solarSys->SysInfo.PlanetInfo;
-
-	if (!planetInfo->DiscoveryString)
-		return false;
-
-	runLanderReport ();
-
-	// XXX: A non-cycling report is given only once and has to be deleted
-	//   in some circumstances (like the Syreen Vault). It does not
-	//   hurt to simply delete it in all cases. Nothing should rely on
-	//   the presence of DiscoveryString, but the Syreen Vault and the
-	//   Mycon Egg Cases rely on its absence.
-	DestroyStringTable (ReleaseStringTable (planetInfo->DiscoveryString));
-	planetInfo->DiscoveryString = 0;
-
-	return true;
-}
-
-bool
-GenerateDefault_landerReportCycle (SOLARSYS_STATE *solarSys)
-{
-	PLANET_INFO *planetInfo = &solarSys->SysInfo.PlanetInfo;
-
-	if (!planetInfo->DiscoveryString)
-		return false;
-
-	runLanderReport ();
-	// Advance to the next report
-	planetInfo->DiscoveryString = SetRelStringTableIndex (
-			planetInfo->DiscoveryString, 1);
-
-	// If our discovery strings have cycled, we're done
-	if (GetStringTableIndex (planetInfo->DiscoveryString) == 0)
-	{
-		DestroyStringTable (ReleaseStringTable (planetInfo->DiscoveryString));
-		planetInfo->DiscoveryString = 0;
-	}
-
-	return true;
-}
 
 // NB. This function modifies the RNG state.
 static void
diff -ruNp src.orig/uqm/planets/generate/gendefault.h src/uqm/planets/generate/gendefault.h
--- src.orig/uqm/planets/generate/gendefault.h	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/gendefault.h	2017-11-01 15:31:03 -0700
@@ -31,24 +31,12 @@ bool GenerateDefault_generateName (SOLAR
 		PLANET_DESC *world);
 bool GenerateDefault_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-COUNT GenerateDefault_generateMinerals (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-COUNT GenerateDefault_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-COUNT GenerateDefault_generateLife (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-bool GenerateDefault_pickupMinerals (SOLARSYS_STATE *, PLANET_DESC *world,
-		COUNT whichNode);
-bool GenerateDefault_pickupEnergy (SOLARSYS_STATE *, PLANET_DESC *world,
-		COUNT whichNode);
-bool GenerateDefault_pickupLife (SOLARSYS_STATE *, PLANET_DESC *world,
-		COUNT whichNode);
-
-COUNT GenerateDefault_generateArtifact (SOLARSYS_STATE *, COUNT whichNode);
-COUNT GenerateDefault_generateRuins (SOLARSYS_STATE *, COUNT whichNode);
-bool GenerateDefault_landerReport (SOLARSYS_STATE *);
-bool GenerateDefault_landerReportCycle (SOLARSYS_STATE *);
-
+bool GenerateDefault_generateMinerals (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
+bool GenerateDefault_generateEnergy (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
+bool GenerateDefault_generateLife (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
 
 extern const GenerateFunctions generateDefaultFunctions;
 
diff -ruNp src.orig/uqm/planets/generate/gendru.c src/uqm/planets/generate/gendru.c
--- src.orig/uqm/planets/generate/gendru.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/gendru.c	2017-11-01 15:31:03 -0700
@@ -33,10 +33,8 @@
 static bool GenerateDruuge_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateDruuge_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateDruuge_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static bool GenerateDruuge_pickupEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static bool GenerateDruuge_generateEnergy (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
 
 
 const GenerateFunctions generateDruugeFunctions = {
@@ -50,9 +48,6 @@ const GenerateFunctions generateDruugeFu
 	/* .generateMinerals = */ GenerateDefault_generateMinerals,
 	/* .generateEnergy   = */ GenerateDruuge_generateEnergy,
 	/* .generateLife     = */ GenerateDefault_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GenerateDruuge_pickupEnergy,
-	/* .pickupLife       = */ GenerateDefault_pickupLife,
 };
 
 
@@ -79,6 +74,7 @@ GenerateDruuge_generatePlanets (SOLARSYS
 	solarSys->PlanetDesc[0].rand_seed = MAKE_DWORD (
 			solarSys->PlanetDesc[0].location.x,
 			solarSys->PlanetDesc[0].location.y);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
@@ -118,11 +114,9 @@ GenerateDruuge_generateOrbital (SOLARSYS
 					CaptureStringTable (
 							LoadStringTable (DRUUGE_RUINS_STRTAB));
 			if (GET_GAME_STATE (ROSY_SPHERE))
-			{	// Already picked up Rosy Sphere, skip the report
 				solarSys->SysInfo.PlanetInfo.DiscoveryString =
 						SetAbsStringTableIndex (
 						solarSys->SysInfo.PlanetInfo.DiscoveryString, 1);
-			}
 		}
 	}
 
@@ -132,38 +126,62 @@ GenerateDruuge_generateOrbital (SOLARSYS
 }
 
 static bool
-GenerateDruuge_pickupEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateDruuge_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
+		COUNT *whichNode)
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		GenerateDefault_landerReportCycle (solarSys);
+		COUNT i;
+		COUNT nodeI;
+		DWORD rand_val;
+		DWORD old_rand;
+
+		old_rand = TFB_SeedRandom (
+				solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN]);
+
+		nodeI = 0;
+		i = 0;
+		do
+		{
+			rand_val = TFB_Random ();
+			solarSys->SysInfo.PlanetInfo.CurPt.x =
+					(LOBYTE (LOWORD (rand_val)) % (MAP_WIDTH - (8 << 1))) + 8;
+			solarSys->SysInfo.PlanetInfo.CurPt.y =
+					(HIBYTE (LOWORD (rand_val)) % (MAP_HEIGHT - (8 << 1))) + 8;
+			if (!GET_GAME_STATE (ROSY_SPHERE))
+				solarSys->SysInfo.PlanetInfo.CurType = 0;
+			else
+				solarSys->SysInfo.PlanetInfo.CurType = 1;
+			solarSys->SysInfo.PlanetInfo.CurDensity = 0;
+			if (solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+					& (1L << i))
+			{
+				solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+						&= ~(1L << i);
 
-		// The artifact can be picked up from any ruin
-		if (!GET_GAME_STATE (ROSY_SPHERE))
-		{	// Just picked up the Rosy Sphere from a ruin
-			SetLanderTakeoff ();
+				if (!GET_GAME_STATE (ROSY_SPHERE))
+				{
+					SetLanderTakeoff ();
+
+					SET_GAME_STATE (ROSY_SPHERE, 1);
+					SET_GAME_STATE (ROSY_SPHERE_ON_SHIP, 1);
+				}
+			}
+			if (nodeI >= *whichNode
+					&& !(solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+					& (1L << i)))
+				break;
+			++nodeI;
+		} while (++i < 16);
+		*whichNode = nodeI;
 
-			SET_GAME_STATE (ROSY_SPHERE, 1);
-			SET_GAME_STATE (ROSY_SPHERE_ON_SHIP, 1);
-		}
+		TFB_SeedRandom (old_rand);
 
-		return false; // do not remove the node
+		return true;
 	}
 
-	(void) whichNode;
-	return false;
-}
-
-static COUNT
-GenerateDruuge_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
-{
-	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
-	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
-	}
+	*whichNode = 0;
 
-	return 0;
+	return true;
 }
 
diff -ruNp src.orig/uqm/planets/generate/genhint1.c src/uqm/planets/generate/genhint1.c
--- src.orig/uqm/planets/generate/genhint1.c	1969-12-31 16:00:00 -0800
+++ src/uqm/planets/generate/genhint1.c	2017-11-01 15:31:03 -0700
@@ -0,0 +1,244 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+// JMS 2010: - This is a completely new file which creates home systems for those who left in a hurry...
+
+#include "../../encount.h"
+#include "../../globdata.h"
+#include "../../nameref.h"
+#include "../../resinst.h"
+#include "genall.h"
+#include "libs/mathlib.h"
+
+#include "libs/log.h"
+
+static bool GenerateHint1_generatePlanets (SOLARSYS_STATE *solarSys);
+static bool GenerateHint1_generateMoons (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *planet);
+static bool GenerateHint1_generateOrbital (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world);
+static bool GenerateHint1_generateEnergy (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
+static bool GenerateHint1_generateLife (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
+
+
+const GenerateFunctions generateHint1Functions = {
+	/* .initNpcs         = */ GenerateDefault_initNpcs,
+	/* .reinitNpcs       = */ GenerateDefault_reinitNpcs,
+	/* .uninitNpcs       = */ GenerateDefault_uninitNpcs,
+	/* .generatePlanets  = */ GenerateHint1_generatePlanets,
+	/* .generateMoons    = */ GenerateHint1_generateMoons,
+	/* .generateName     = */ GenerateDefault_generateName,
+	/* .generateOrbital  = */ GenerateHint1_generateOrbital,
+	/* .generateMinerals = */ GenerateDefault_generateMinerals,
+	/* .generateEnergy   = */ GenerateHint1_generateEnergy,
+	/* .generateLife     = */ GenerateHint1_generateLife,
+};
+
+
+BYTE which_hintworld_is_it ()
+{
+	BYTE which_hintworld;
+	STAR_DESC *SDPtr;
+	
+	which_hintworld = 0;
+	SDPtr = &star_array[0];
+	
+	while (SDPtr != CurStarDescPtr)
+	{
+		if (SDPtr->Index == HINT_DEFINED)
+			++which_hintworld;
+		++SDPtr;
+	}
+	return which_hintworld;
+}
+
+static bool GenerateHint1_generatePlanets (SOLARSYS_STATE *solarSys)
+{
+	BYTE which_hintworld = which_hintworld_is_it ();
+	
+	GenerateDefault_generatePlanets(solarSys);
+	
+	if (which_hintworld == 1)
+	{
+		COUNT angle;
+		
+		solarSys->SunDesc[0].NumPlanets = 2;
+		
+		solarSys->PlanetDesc[0].data_index = METAL_WORLD;
+		solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 64L / 100;
+		angle = ARCTAN (
+				solarSys->PlanetDesc[0].location.x,
+				solarSys->PlanetDesc[0].location.y);
+		solarSys->PlanetDesc[0].location.x = COSINE (angle, solarSys->PlanetDesc[0].radius);
+		solarSys->PlanetDesc[0].location.y = SINE (angle, solarSys->PlanetDesc[0].radius);
+		ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
+
+		solarSys->PlanetDesc[1].data_index = PRIMORDIAL_WORLD;
+		solarSys->PlanetDesc[1].radius = EARTH_RADIUS * 352L / 100;
+		solarSys->PlanetDesc[1].NumPlanets = 1;
+		angle = ARCTAN (
+				solarSys->PlanetDesc[1].location.x,
+				solarSys->PlanetDesc[1].location.y);
+		solarSys->PlanetDesc[1].location.x = COSINE (angle, solarSys->PlanetDesc[1].radius);
+		solarSys->PlanetDesc[1].location.y = SINE (angle, solarSys->PlanetDesc[1].radius);
+		ComputeSpeed(&solarSys->PlanetDesc[1], FALSE, 1);
+	}
+	return true;
+}
+
+static bool GenerateHint1_generateMoons (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *planet)
+{
+	DWORD rand_val;
+	BYTE which_hintworld = which_hintworld_is_it ();
+
+	GenerateDefault_generateMoons (solarSys, planet);
+
+	if (matchWorld(solarSys, planet, 1, MATCH_PLANET)
+	    && which_hintworld == 1)
+	{
+		COUNT angle;
+		
+		solarSys->MoonDesc[0].data_index = PELLUCID_WORLD;
+		solarSys->MoonDesc[0].radius = MIN_MOON_RADIUS * 2;
+		rand_val = TFB_Random ();
+		angle = NORMALIZE_ANGLE (LOWORD (rand_val));
+		solarSys->MoonDesc[0].location.x = COSINE (angle, solarSys->MoonDesc[0].radius);
+		solarSys->MoonDesc[0].location.y = SINE (angle, solarSys->MoonDesc[0].radius);
+		ComputeSpeed(&solarSys->MoonDesc[0], TRUE, 1);
+	}	
+	return true;
+}
+
+static bool GenerateHint1_generateOrbital (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world)
+{
+	COUNT i;
+	DWORD rand_val;
+	BYTE which_hintworld = which_hintworld_is_it ();
+	if ((GET_GAME_STATE(HINT_WORLD_LOCATION) == which_hintworld) || (which_hintworld == 1))
+	{
+		rand_val = DoPlanetaryAnalysis (&solarSys->SysInfo, solarSys->pOrbitalDesc);
+		
+		solarSys->SysInfo.PlanetInfo.ScanSeed[BIOLOGICAL_SCAN] = rand_val;
+		i = (COUNT)~0;
+		rand_val = GenerateLifeForms (&solarSys->SysInfo, &i);
+		
+		solarSys->SysInfo.PlanetInfo.ScanSeed[MINERAL_SCAN] = rand_val;
+		i = (COUNT)~0;
+		GenerateMineralDeposits (&solarSys->SysInfo, &i);
+		
+		solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN] = rand_val;
+		
+		if (matchWorld(solarSys, world, 0, MATCH_PLANET))
+			solarSys->SysInfo.PlanetInfo.PlanetToSunDist = EARTH_RADIUS * 64L / 100;
+		
+		if (matchWorld(solarSys, world, 1, MATCH_PLANET))
+		{
+			LoadStdLanderFont (&solarSys->SysInfo.PlanetInfo);
+			solarSys->PlanetSideFrame[1] = CaptureDrawable (LoadGraphic (CIRCLES_A_MASK_PMAP_ANIM));
+			solarSys->PlanetSideFrame[2] = CaptureDrawable (LoadGraphic (CIRCLES_B_MASK_PMAP_ANIM));
+			solarSys->SysInfo.PlanetInfo.DiscoveryString = CaptureStringTable (LoadStringTable (LEFTHURRY_STRTAB));
+			solarSys->SysInfo.PlanetInfo.Weather = 2;
+			solarSys->SysInfo.PlanetInfo.Tectonics = 1;
+			
+			solarSys->SysInfo.PlanetInfo.PlanetToSunDist = EARTH_RADIUS * 352L / 100;
+			solarSys->SysInfo.PlanetInfo.AtmoDensity = 159;
+			solarSys->SysInfo.PlanetInfo.PlanetDensity = 104;
+			solarSys->SysInfo.PlanetInfo.PlanetRadius = 120;
+			solarSys->SysInfo.PlanetInfo.RotationPeriod = 288;
+			solarSys->SysInfo.PlanetInfo.SurfaceTemperature = -47;
+		}
+		
+		LoadPlanet (NULL);
+	}
+	else
+	{
+		GenerateDefault_generateOrbital (solarSys, world);
+	}
+	return true;
+}
+
+static bool
+GenerateHint1_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world, COUNT *whichNode)
+{
+	COUNT i;
+	BYTE which_hintworld = which_hintworld_is_it ();
+	
+	//log_add (log_Debug, "which_hintworld = %d. Stuff is in %d.", which_hintworld, GET_GAME_STATE(HINT_WORLD_LOCATION));
+	
+	if (!(GET_GAME_STATE(HINT_WORLD_LOCATION) == which_hintworld))
+	{
+		GenerateDefault_generateEnergy (solarSys, world, whichNode);
+	}
+	else
+	{
+		DWORD rand_val, old_rand;
+	
+		if (matchWorld(solarSys, world, 1, MATCH_PLANET))
+		{
+			COUNT nodeI;
+			
+			old_rand = TFB_SeedRandom (solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN]);
+			
+			nodeI = 0;
+			i = 0;
+		
+			do
+			{
+				rand_val = TFB_Random ();
+				solarSys->SysInfo.PlanetInfo.CurPt.x = (LOWORD (rand_val)) % (MAP_WIDTH - (8 << 1)) + 8;
+				solarSys->SysInfo.PlanetInfo.CurPt.y = (HIWORD (rand_val)) % (MAP_HEIGHT - (8 << 1)) + 8;
+				solarSys->SysInfo.PlanetInfo.CurType = 1;
+				solarSys->SysInfo.PlanetInfo.CurDensity = 0;
+				
+				if (nodeI >= *whichNode
+				    && !(solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN] & (1L << i)))
+					break;
+				++nodeI;
+			} while (++i < 24);
+			
+			*whichNode = nodeI;
+		
+			TFB_SeedRandom (old_rand);
+			return true;
+		}
+	}
+	solarSys->CurNode = 0;
+	return true;
+}
+
+static bool GenerateHint1_generateLife (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode)
+{
+	BYTE which_hintworld = which_hintworld_is_it ();
+	if (!(GET_GAME_STATE(HINT_WORLD_LOCATION) == which_hintworld))
+	{
+		GenerateDefault_generateLife (solarSys, world, whichNode);
+	}
+	else
+	{
+		if (matchWorld(solarSys, world, 1, MATCH_PLANET))
+			solarSys->CurNode = 0;
+                else
+			GenerateDefault_generateLife (solarSys, world, whichNode);
+	}
+	return true;
+}
diff -ruNp src.orig/uqm/planets/generate/genhint2.c src/uqm/planets/generate/genhint2.c
--- src.orig/uqm/planets/generate/genhint2.c	1969-12-31 16:00:00 -0800
+++ src/uqm/planets/generate/genhint2.c	2017-11-01 15:31:03 -0700
@@ -0,0 +1,113 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+// JMS 2010: - This is a completely new file which puts a spaceship imprint on a planet near Yehat system.
+
+#include "../../encount.h"
+#include "../../globdata.h"
+#include "../../nameref.h"
+#include "../../resinst.h"
+#include "genall.h"
+#include "libs/mathlib.h"
+
+static bool GenerateHint2_generateOrbital (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world);
+static bool GenerateHint2_generateEnergy (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
+
+
+const GenerateFunctions generateHint2Functions = {
+	/* .initNpcs         = */ GenerateDefault_initNpcs,
+	/* .reinitNpcs       = */ GenerateDefault_reinitNpcs,
+	/* .uninitNpcs       = */ GenerateDefault_uninitNpcs,
+	/* .generatePlanets  = */ GenerateDefault_generatePlanets,
+	/* .generateMoons    = */ GenerateDefault_generateMoons,
+	/* .generateName     = */ GenerateDefault_generateName,
+	/* .generateOrbital  = */ GenerateHint2_generateOrbital,
+	/* .generateMinerals = */ GenerateDefault_generateMinerals,
+	/* .generateEnergy   = */ GenerateHint2_generateEnergy,
+	/* .generateLife     = */ GenerateDefault_generateLife,
+};
+
+
+static bool
+GenerateHint2_generateOrbital (SOLARSYS_STATE *solarSys, PLANET_DESC *world)
+{
+	COUNT i;
+	DWORD rand_val;
+
+	rand_val = DoPlanetaryAnalysis (&solarSys->SysInfo, solarSys->pOrbitalDesc);
+	
+	solarSys->SysInfo.PlanetInfo.ScanSeed[BIOLOGICAL_SCAN] = rand_val;
+	i = (COUNT)~0;
+	rand_val = GenerateLifeForms (&solarSys->SysInfo, &i);
+	
+	solarSys->SysInfo.PlanetInfo.ScanSeed[MINERAL_SCAN] = rand_val;
+	i = (COUNT)~0;
+	GenerateMineralDeposits (&solarSys->SysInfo, &i);
+	
+	solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN] = rand_val;
+	if (matchWorld(solarSys, world, 1, MATCH_PLANET))
+	{
+		LoadStdLanderFont (&solarSys->SysInfo.PlanetInfo);
+		solarSys->PlanetSideFrame[1] = CaptureDrawable (LoadGraphic (CIRCLES_C_MASK_PMAP_ANIM));
+		solarSys->SysInfo.PlanetInfo.DiscoveryString = CaptureStringTable (LoadStringTable (GAMMAJANUS_STRTAB));
+	}
+	
+	if (GET_GAME_STATE(YEHAT_PRECURSOR_ARTIFACT) > 0)
+	{
+		solarSys->SysInfo.PlanetInfo.DiscoveryString =
+			SetRelStringTableIndex (solarSys->SysInfo.PlanetInfo.DiscoveryString,1);
+	}
+	
+	if (GET_GAME_STATE(YEHAT_PRECURSOR_ARTIFACT) < 2)
+		SET_GAME_STATE(YEHAT_PRECURSOR_ARTIFACT, 2);
+	
+	LoadPlanet (NULL);
+	return true;
+}
+
+
+static bool
+GenerateHint2_generateEnergy (SOLARSYS_STATE *solarSys,
+			      PLANET_DESC *world, COUNT *whichNode)
+{
+	DWORD rand_val, old_rand;
+	
+	if (matchWorld(solarSys, world, 1, MATCH_PLANET))
+	{
+		old_rand = TFB_SeedRandom (solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN]);
+		
+		rand_val = TFB_Random ();
+		solarSys->SysInfo.PlanetInfo.CurPt.x = (LOBYTE (LOWORD (rand_val)) % (MAP_WIDTH - (8 << 1))) + 8;
+		solarSys->SysInfo.PlanetInfo.CurPt.y = (HIBYTE (LOWORD (rand_val)) % (MAP_HEIGHT - (8 << 1))) + 8;
+		solarSys->SysInfo.PlanetInfo.CurType = 1;
+		solarSys->SysInfo.PlanetInfo.CurDensity = 0;
+		
+		if (!(solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN] & (1L << 0)) && solarSys->CurNode == (COUNT)~0)
+			solarSys->CurNode = 1;
+		else
+			solarSys->CurNode = 0;
+		
+		TFB_SeedRandom (old_rand);
+		return true;
+	}
+	
+	solarSys->CurNode = 0;
+	return true;
+}
diff -ruNp src.orig/uqm/planets/generate/genilw.c src/uqm/planets/generate/genilw.c
--- src.orig/uqm/planets/generate/genilw.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/genilw.c	2017-11-01 15:31:03 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: No ships orbiting Ilwrath homeworld anymore.
+
 #include "genall.h"
 #include "../planets.h"
 #include "../../build.h"
@@ -30,10 +32,8 @@
 static bool GenerateIlwrath_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateIlwrath_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateIlwrath_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static bool GenerateIlwrath_pickupEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static bool GenerateIlwrath_generateEnergy (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
 
 
 const GenerateFunctions generateIlwrathFunctions = {
@@ -47,9 +47,6 @@ const GenerateFunctions generateIlwrathF
 	/* .generateMinerals = */ GenerateDefault_generateMinerals,
 	/* .generateEnergy   = */ GenerateIlwrath_generateEnergy,
 	/* .generateLife     = */ GenerateDefault_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GenerateIlwrath_pickupEnergy,
-	/* .pickupLife       = */ GenerateDefault_pickupLife,
 };
 
 
@@ -69,6 +66,7 @@ GenerateIlwrath_generatePlanets (SOLARSY
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
@@ -78,7 +76,9 @@ GenerateIlwrath_generateOrbital (SOLARSY
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		if (ActivateStarShip (ILWRATH_SHIP, SPHERE_TRACKING))
+		// JMS: By deactivating this if, Ilwrath homeworld no longer has any ships
+		//if (ActivateStarShip (ILWRATH_SHIP, SPHERE_TRACKING))
+		if(0)
 		{
 			NotifyOthers (ILWRATH_SHIP, IPNL_ALL_CLEAR);
 			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
@@ -122,29 +122,45 @@ GenerateIlwrath_generateOrbital (SOLARSY
 	return true;
 }
 
-static COUNT
+static bool
 GenerateIlwrath_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+		COUNT *whichNode)
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
-	}
-
-	return 0;
-}
+		COUNT i;
+		COUNT nodeI;
+		DWORD rand_val;
+		DWORD old_rand;
+
+		old_rand = TFB_SeedRandom (
+				solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN]);
+
+		nodeI = 0;
+		i = 0;
+		do
+		{
+			rand_val = TFB_Random ();
+			solarSys->SysInfo.PlanetInfo.CurPt.x =
+					((LOWORD (rand_val)) % (MAP_WIDTH - (8 << 1))) + 8;
+			solarSys->SysInfo.PlanetInfo.CurPt.y =
+					((LOWORD (rand_val)) % (MAP_HEIGHT - (8 << 1))) + 8;
+			solarSys->SysInfo.PlanetInfo.CurType = 1;
+			solarSys->SysInfo.PlanetInfo.CurDensity = 0;
+			if (nodeI >= *whichNode
+					&& !(solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+					& (1L << i)))
+				break;
+			++nodeI;
+		} while (++i < 16);
+		*whichNode = nodeI;
 
-static bool
-GenerateIlwrath_pickupEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
-{
-	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
-	{
-		// Standard ruins report
-		GenerateDefault_landerReportCycle (solarSys);
-		return false;
+		TFB_SeedRandom (old_rand);
+		return true;
 	}
 
-	(void) whichNode;
-	return false;
+	*whichNode = 0;
+
+	return true;
 }
+
diff -ruNp src.orig/uqm/planets/generate/genlurg.c src/uqm/planets/generate/genlurg.c
--- src.orig/uqm/planets/generate/genlurg.c	1969-12-31 16:00:00 -0800
+++ src/uqm/planets/generate/genlurg.c	2017-11-01 15:31:03 -0700
@@ -0,0 +1,93 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+// JMS 2010: - Totally new file: Lurg home system
+
+#include "../../build.h"
+#include "../../encount.h"
+#include "../../globdata.h"
+#include "../../ipdisp.h"
+#include "../lander.h"
+#include "../../nameref.h"
+#include "../../resinst.h"
+#include "../../setup.h"
+#include "../../state.h"
+#include "genall.h"
+#include "libs/mathlib.h"
+#include "libs/log.h"
+#include "../../grpinfo.h"
+
+
+static bool GenerateLurg_generateOrbital (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world);
+
+
+const GenerateFunctions generateLurgFunctions = {
+	/* .initNpcs         = */ GenerateDefault_initNpcs,
+	/* .reinitNpcs       = */ GenerateDefault_reinitNpcs,
+	/* .uninitNpcs       = */ GenerateDefault_uninitNpcs,
+	/* .generatePlanets  = */ GenerateDefault_generatePlanets,
+	/* .generateMoons    = */ GenerateDefault_generateMoons,
+	/* .generateName     = */ GenerateDefault_generateName,
+	/* .generateOrbital  = */ GenerateLurg_generateOrbital,
+	/* .generateMinerals = */ GenerateDefault_generateMinerals,
+	/* .generateEnergy   = */ GenerateDefault_generateEnergy,
+	/* .generateLife     = */ GenerateDefault_generateLife,
+};
+
+
+static bool
+GenerateLurg_generateOrbital (SOLARSYS_STATE *solarSys,	PLANET_DESC *world)
+{
+	if (matchWorld(solarSys, world, 0, MATCH_PLANET))
+	{
+		if (ActivateStarShip (LURG_SHIP, SPHERE_TRACKING))
+		{
+			NotifyOthers (LURG_SHIP, IPNL_ALL_CLEAR);
+			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
+			ReinitQueue (&GLOBAL (ip_group_q));
+			assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
+			
+			CloneShipFragment (LURG_SHIP, &GLOBAL (npc_built_ship_q), INFINITE_FLEET);
+			
+			GLOBAL (CurrentActivity) |= START_INTERPLANETARY;
+			SET_GAME_STATE (GLOBAL_FLAGS_AND_DATA, 1 << 7);
+			InitCommunication (LURG_CONVERSATION);
+			
+			if (!(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD)))
+			{
+				GLOBAL (CurrentActivity) &= ~START_INTERPLANETARY;
+				ReinitQueue (&GLOBAL (npc_built_ship_q));
+				GetGroupInfo (GROUPS_RANDOM, GROUP_LOAD_IP);
+			}
+			return true;
+		}
+		else
+		{
+			LoadStdLanderFont (&solarSys->SysInfo.PlanetInfo);
+			solarSys->PlanetSideFrame[1] = CaptureDrawable (LoadGraphic (RUINS_MASK_PMAP_ANIM));
+			solarSys->SysInfo.PlanetInfo.DiscoveryString = CaptureStringTable (LoadStringTable (RUINS_STRTAB));
+			if (!GET_GAME_STATE (ULTRON_CONDITION))
+				solarSys->SysInfo.PlanetInfo.DiscoveryString =
+					SetAbsStringTableIndex (
+								solarSys->SysInfo.PlanetInfo.DiscoveryString, 1);
+		}
+	}
+	GenerateDefault_generateOrbital (solarSys, world);
+	return true;
+}
diff -ruNp src.orig/uqm/planets/generate/genmel.c src/uqm/planets/generate/genmel.c
--- src.orig/uqm/planets/generate/genmel.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/genmel.c	2017-11-01 15:31:03 -0700
@@ -42,9 +42,6 @@ const GenerateFunctions generateMelnorme
 	/* .generateMinerals = */ GenerateDefault_generateMinerals,
 	/* .generateEnergy   = */ GenerateDefault_generateEnergy,
 	/* .generateLife     = */ GenerateDefault_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GenerateDefault_pickupEnergy,
-	/* .pickupLife       = */ GenerateDefault_pickupLife,
 };
 
 
diff -ruNp src.orig/uqm/planets/generate/genmyc.c src/uqm/planets/generate/genmyc.c
--- src.orig/uqm/planets/generate/genmyc.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/genmyc.c	2017-11-01 15:31:03 -0700
@@ -17,9 +17,7 @@
  */
 
 #include "genall.h"
-#include "../lander.h"
 #include "../planets.h"
-#include "../scan.h"
 #include "../../build.h"
 #include "../../comm.h"
 #include "../../encount.h"
@@ -34,12 +32,10 @@
 static bool GenerateMycon_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateMycon_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateMycon_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static COUNT GenerateMycon_generateLife (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static bool GenerateMycon_pickupEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static bool GenerateMycon_generateEnergy (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
+static bool GenerateMycon_generateLife (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
 
 
 const GenerateFunctions generateMyconFunctions = {
@@ -53,9 +49,6 @@ const GenerateFunctions generateMyconFun
 	/* .generateMinerals = */ GenerateDefault_generateMinerals,
 	/* .generateEnergy   = */ GenerateMycon_generateEnergy,
 	/* .generateLife     = */ GenerateMycon_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GenerateMycon_pickupEnergy,
-	/* .pickupLife       = */ GenerateDefault_pickupLife,
 };
 
 
@@ -77,6 +70,7 @@ GenerateMycon_generatePlanets (SOLARSYS_
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
@@ -168,8 +162,8 @@ GenerateMycon_generateOrbital (SOLARSYS_
 				if (GET_GAME_STATE (KNOW_ABOUT_SHATTERED) == 0)
 					SET_GAME_STATE (KNOW_ABOUT_SHATTERED, 1);
 
-				if (!isNodeRetrieved (&solarSys->SysInfo.PlanetInfo,
-						ENERGY_SCAN, 0))
+				if (!(solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+						& (1L << 0)))
 				{
 					LoadStdLanderFont (&solarSys->SysInfo.PlanetInfo);
 					solarSys->PlanetSideFrame[1] =
@@ -187,99 +181,88 @@ GenerateMycon_generateOrbital (SOLARSYS_
 	return true;
 }
 
-static COUNT
+static bool
 GenerateMycon_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+		COUNT *whichNode)
 {
-	if (CurStarDescPtr->Index == SUN_DEVICE_DEFINED
-			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
+	if (CurStarDescPtr->Index != MYCON_DEFINED
+		&& matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		// This check is redundant since the retrieval bit will keep the
-		// node from showing up again
-		if (GET_GAME_STATE (SUN_DEVICE))
-		{	// already picked up
-			return 0;
-		}
+		DWORD rand_val;
+		DWORD old_rand;
 
-		return GenerateDefault_generateArtifact (solarSys, whichNode);
-	}
+		old_rand = TFB_SeedRandom (
+				solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN]);
 
-	if ((CurStarDescPtr->Index == EGG_CASE0_DEFINED
-			|| CurStarDescPtr->Index == EGG_CASE1_DEFINED
-			|| CurStarDescPtr->Index == EGG_CASE2_DEFINED)
-			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
-	{
-		// This check is redundant since the retrieval bit will keep the
-		// node from showing up again
-		// XXX: DiscoveryString is set by generateOrbital() only when the
-		//   node has not been picked up yet
-		if (!solarSys->SysInfo.PlanetInfo.DiscoveryString)
-		{	// already picked up
-			return 0;
+		rand_val = TFB_Random ();
+		solarSys->SysInfo.PlanetInfo.CurPt.x =
+				(LOBYTE (LOWORD (rand_val)) % (MAP_WIDTH - (8 << 1))) + 8;
+		solarSys->SysInfo.PlanetInfo.CurPt.y =
+				(HIBYTE (LOWORD (rand_val)) % (MAP_HEIGHT - (8 << 1))) + 8;
+		solarSys->SysInfo.PlanetInfo.CurDensity = 0;
+		solarSys->SysInfo.PlanetInfo.CurType = 0;
+		if (CurStarDescPtr->Index == SUN_DEVICE_DEFINED)
+		{
+			if (!(solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+					& (1L << 0))
+					&& *whichNode == (COUNT)~0)
+				*whichNode = 1;
+			else
+			{
+				*whichNode = 0;
+				if (solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+						& (1L << 0))
+				{
+					SET_GAME_STATE (SUN_DEVICE, 1);
+					SET_GAME_STATE (SUN_DEVICE_ON_SHIP, 1);
+					SET_GAME_STATE (MYCON_VISITS, 0);
+				}
+			}
 		}
-
-		return GenerateDefault_generateArtifact (solarSys, whichNode);
-	}
-
-	return 0;
-}
-
-static bool
-GenerateMycon_pickupEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
-{
-	if (CurStarDescPtr->Index == SUN_DEVICE_DEFINED
-			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
-	{
-		assert (!GET_GAME_STATE (SUN_DEVICE) && whichNode == 0);
-
-		GenerateDefault_landerReport (solarSys);
-		SetLanderTakeoff ();
-
-		SET_GAME_STATE (SUN_DEVICE, 1);
-		SET_GAME_STATE (SUN_DEVICE_ON_SHIP, 1);
-		SET_GAME_STATE (MYCON_VISITS, 0);
-
-		return true; // picked up
-	}
-
-	if ((CurStarDescPtr->Index == EGG_CASE0_DEFINED
-			|| CurStarDescPtr->Index == EGG_CASE1_DEFINED
-			|| CurStarDescPtr->Index == EGG_CASE2_DEFINED)
-			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
-	{
-		assert (whichNode == 0);
-
-		GenerateDefault_landerReport (solarSys);
-		SetLanderTakeoff ();
-
-		switch (CurStarDescPtr->Index)
+		else
 		{
-			case EGG_CASE0_DEFINED:
-				SET_GAME_STATE (EGG_CASE0_ON_SHIP, 1);
-				break;
-			case EGG_CASE1_DEFINED:
-				SET_GAME_STATE (EGG_CASE1_ON_SHIP, 1);
-				break;
-			case EGG_CASE2_DEFINED:
-				SET_GAME_STATE (EGG_CASE2_ON_SHIP, 1);
-				break;
+			if (!(solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+					& (1L << 0))
+					&& *whichNode == (COUNT)~0)
+				*whichNode = 1;
+			else
+			{
+				*whichNode = 0;
+				if ((solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+						& (1L << 0))
+						&& solarSys->SysInfo.PlanetInfo.DiscoveryString)
+				{
+					switch (CurStarDescPtr->Index)
+					{
+						case EGG_CASE0_DEFINED:
+							SET_GAME_STATE (EGG_CASE0_ON_SHIP, 1);
+							break;
+						case EGG_CASE1_DEFINED:
+							SET_GAME_STATE (EGG_CASE1_ON_SHIP, 1);
+							break;
+						case EGG_CASE2_DEFINED:
+							SET_GAME_STATE (EGG_CASE2_ON_SHIP, 1);
+							break;
+					}
+				}
+			}
 		}
 
-		return true; // picked up
+		TFB_SeedRandom (old_rand);
+		return true;
 	}
 
-	(void) whichNode;
-	return false;
+	*whichNode = 0;
+	return true;
 }
 
-static COUNT
+static bool
 GenerateMycon_generateLife (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+		COUNT *whichNode)
 {
-	(void) whichNode;
+	*whichNode = 0;
 	(void) solarSys;
 	(void) world;
-	return 0;
+	return true;
 }
 
diff -ruNp src.orig/uqm/planets/generate/genorz.c src/uqm/planets/generate/genorz.c
--- src.orig/uqm/planets/generate/genorz.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/genorz.c	2017-11-01 15:31:03 -0700
@@ -16,8 +16,9 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: -Removed the Taalo shield from the planet surface at Delta Vulpeculae II-C.
+
 #include "genall.h"
-#include "../lander.h"
 #include "../planets.h"
 #include "../../build.h"
 #include "../../comm.h"
@@ -33,10 +34,8 @@
 static bool GenerateOrz_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateOrz_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateOrz_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static bool GenerateOrz_pickupEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static bool GenerateOrz_generateEnergy (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
 
 
 const GenerateFunctions generateOrzFunctions = {
@@ -50,9 +49,6 @@ const GenerateFunctions generateOrzFunct
 	/* .generateMinerals = */ GenerateDefault_generateMinerals,
 	/* .generateEnergy   = */ GenerateOrz_generateEnergy,
 	/* .generateLife     = */ GenerateDefault_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GenerateOrz_pickupEnergy,
-	/* .pickupLife       = */ GenerateDefault_pickupLife,
 };
 
 
@@ -74,6 +70,7 @@ GenerateOrz_generatePlanets (SOLARSYS_ST
 				COSINE (angle, solarSys->PlanetDesc[0].radius);
 		solarSys->PlanetDesc[0].location.y =
 				SINE (angle, solarSys->PlanetDesc[0].radius);
+		ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 	}
 
 	return true;
@@ -88,7 +85,7 @@ GenerateOrz_generateOrbital (SOLARSYS_ST
 			&& matchWorld (solarSys, world, 1, 2)
 			&& !GET_GAME_STATE (TAALO_PROTECTOR)))
 	{
-		COUNT i;
+		//		COUNT i;
 
 		if ((CurStarDescPtr->Index == ORZ_DEFINED
 				|| !GET_GAME_STATE (TAALO_UNPROTECTED))
@@ -107,11 +104,14 @@ GenerateOrz_generateOrbital (SOLARSYS_ST
 			}
 			else
 			{
-				for (i = 0; i < 14; ++i)
+				// JMS: Changed the size of ORZ fleet at Delta Vulpeculae II-C to infinite
+				/*for (i = 0; i < 14; ++i)
 				{
 					CloneShipFragment (ORZ_SHIP,
-							&GLOBAL (npc_built_ship_q), 0);
-				}
+					&GLOBAL (npc_built_ship_q), 0);
+					}*/
+				CloneShipFragment (ORZ_SHIP,
+						   &GLOBAL (npc_built_ship_q), INFINITE_FLEET);
 				SET_GAME_STATE (GLOBAL_FLAGS_AND_DATA, 1 << 6);
 			}
 			GLOBAL (CurrentActivity) |= START_INTERPLANETARY;
@@ -166,58 +166,83 @@ GenerateOrz_generateOrbital (SOLARSYS_ST
 	return true;
 }
 
-static COUNT
+static bool
 GenerateOrz_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+		COUNT *whichNode)
 {
-	if (CurStarDescPtr->Index == TAALO_PROTECTOR_DEFINED
-			&& matchWorld (solarSys, world, 1, 2))
+	DWORD rand_val;
+	DWORD old_rand;
+
+	// JMS: Removed the Taalo shield from the planet surface at Delta Vulpeculae II-C.
+	//
+	/*if (CurStarDescPtr->Index != ORZ_DEFINED
+			&& matchWorld (solarSys, world, 1, 2)
+			&& !GET_GAME_STATE (TAALO_PROTECTOR))
 	{
-		// This check is redundant since the retrieval bit will keep the
-		// node from showing up again
-		if (GET_GAME_STATE (TAALO_PROTECTOR))
-		{	// already picked up
-			return 0;
+		old_rand = TFB_SeedRandom (
+				solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN]);
+
+		rand_val = TFB_Random ();
+		solarSys->SysInfo.PlanetInfo.CurPt.x =
+				(LOBYTE (LOWORD (rand_val)) % (MAP_WIDTH - (8 << 1))) + 8;
+		solarSys->SysInfo.PlanetInfo.CurPt.y =
+				(HIBYTE (LOWORD (rand_val)) % (MAP_HEIGHT - (8 << 1))) + 8;
+		solarSys->SysInfo.PlanetInfo.CurDensity = 0;
+		solarSys->SysInfo.PlanetInfo.CurType = 0;
+		if (!(solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+				& (1L << 0))
+				&& *whichNode == (COUNT)~0)
+			*whichNode = 1;
+		else
+		{
+			*whichNode = 0;
+			if (solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+					& (1L << 0))
+			{
+				SET_GAME_STATE (TAALO_PROTECTOR, 1);
+				SET_GAME_STATE (TAALO_PROTECTOR_ON_SHIP, 1);
+			}
 		}
 
-		return GenerateDefault_generateArtifact (solarSys, whichNode);
-	}
+		TFB_SeedRandom (old_rand);
 
+		return true;
+	}
+	*/
+	
 	if (CurStarDescPtr->Index == ORZ_DEFINED
 			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
-	}
-
-	return 0;
-}
-
-static bool
-GenerateOrz_pickupEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
-{
-	if (CurStarDescPtr->Index == TAALO_PROTECTOR_DEFINED
-			&& matchWorld (solarSys, world, 1, 2))
-	{
-		assert (!GET_GAME_STATE (TAALO_PROTECTOR) && whichNode == 0);
-
-		GenerateDefault_landerReport (solarSys);
-		SetLanderTakeoff ();
+		COUNT i;
+		COUNT nodeI;
 
-		SET_GAME_STATE (TAALO_PROTECTOR, 1);
-		SET_GAME_STATE (TAALO_PROTECTOR_ON_SHIP, 1);
+		old_rand = TFB_SeedRandom (
+				solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN]);
 
-		return true; // picked up
-	}
+		nodeI = 0;
+		i = 0;
+		do
+		{
+			rand_val = TFB_Random ();
+			solarSys->SysInfo.PlanetInfo.CurPt.x =
+					(LOBYTE (LOWORD (rand_val)) % (MAP_WIDTH - (8 << 1))) + 8;
+			solarSys->SysInfo.PlanetInfo.CurPt.y =
+					(HIBYTE (LOWORD (rand_val)) % (MAP_HEIGHT - (8 << 1))) + 8;
+			solarSys->SysInfo.PlanetInfo.CurType = 1;
+			solarSys->SysInfo.PlanetInfo.CurDensity = 0;
+			if (nodeI >= *whichNode &&
+					!(solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+					& (1L << i)))
+				break;
+			++nodeI;
+		} while (++i < 16);
+		*whichNode = nodeI;
 
-	if (CurStarDescPtr->Index == ORZ_DEFINED
-			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
-	{
-		// Standard ruins report
-		GenerateDefault_landerReportCycle (solarSys);
-		return false;
+		TFB_SeedRandom (old_rand);
+		return true;
 	}
 
-	(void) whichNode;
-	return false;
+	*whichNode = 0;
+	return true;
 }
+
diff -ruNp src.orig/uqm/planets/generate/genorzspaceportal.c src/uqm/planets/generate/genorzspaceportal.c
--- src.orig/uqm/planets/generate/genorzspaceportal.c	1969-12-31 16:00:00 -0800
+++ src/uqm/planets/generate/genorzspaceportal.c	2017-11-01 15:31:03 -0700
@@ -0,0 +1,96 @@
+// JMS 2009:
+// Generates rift to ORZ space
+
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+// JMS 2009: Totally new file: Orz space portal
+
+#include "../../build.h"
+#include "genall.h"
+#include "../../grpinfo.h"
+#include "../../races.h"
+#include "../../state.h"
+#include "../../encount.h"
+
+#include "../../hyper.h"
+// for SOL_X/SOL_Y
+
+static bool GenerateOrzSpacePortal_initNpcs (SOLARSYS_STATE *solarSys);
+static bool GenerateOrzSpacePortal_generatePlanets (SOLARSYS_STATE *solarSys);
+static bool GenerateOrzSpacePortal_generateOrbital (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world);
+
+
+const GenerateFunctions generateOrzSpacePortalFunctions = {
+	/* .initNpcs         = */ GenerateOrzSpacePortal_initNpcs,
+	/* .reinitNpcs       = */ GenerateDefault_reinitNpcs,
+	/* .uninitNpcs       = */ GenerateDefault_uninitNpcs,
+	/* .generatePlanets  = */ GenerateOrzSpacePortal_generatePlanets,
+	/* .generateMoons    = */ GenerateDefault_generateMoons,
+	/* .generateName     = */ GenerateDefault_generateName,
+	/* .generateOrbital  = */ GenerateOrzSpacePortal_generateOrbital,
+	/* .generateMinerals = */ GenerateDefault_generateMinerals,
+	/* .generateEnergy   = */ GenerateDefault_generateEnergy,
+	/* .generateLife     = */ GenerateDefault_generateLife,
+};
+
+
+static bool
+GenerateOrzSpacePortal_initNpcs (SOLARSYS_STATE *solarSys)
+{
+	CloneShipFragment (ORZ_SHIP, &GLOBAL (npc_built_ship_q), 0);
+	GLOBAL (BattleGroupRef) = PutGroupInfo (GROUPS_ADD_NEW, 1);
+	ReinitQueue (&GLOBAL (npc_built_ship_q));
+	
+	GenerateDefault_initNpcs(solarSys);
+	return true;
+}
+
+static bool
+GenerateOrzSpacePortal_generatePlanets (SOLARSYS_STATE *solarSys)
+{
+	solarSys->SunDesc[0].NumPlanets = 1;
+	GenerateDefault_generatePlanets (solarSys);
+	FillOrbits (solarSys, solarSys->SunDesc[0].NumPlanets, &solarSys->PlanetDesc[0], FALSE);
+	solarSys->SunDesc[0].NumPlanets = 0;
+	return true;
+}
+
+static bool
+GenerateOrzSpacePortal_generateOrbital (SOLARSYS_STATE *solarSys, PLANET_DESC *world)
+{
+	//GenerateRandomIP (GENERATE_ORBITAL);
+	/* The PORTAL */
+	// BW: matchWorld() wouldn't work here, we're colliding with the sun
+	if (solarSys->pOrbitalDesc == &solarSys->SunDesc[0])
+	{
+		if(!(GET_GAME_STATE(TEMPORAL_WRAPPER_ON_SHIP)))
+		{  // Arilou Communication if one doesn't have proper protective device along
+			InitCommunication (ARILOU_CONVERSATION);
+		}
+		else   
+		{	// Thru the portal to ORZ space
+			GLOBAL_SIS (log_x) = UNIVERSE_TO_LOGX (QUASI_SPACE_X);
+			GLOBAL_SIS (log_y) = UNIVERSE_TO_LOGY (QUASI_SPACE_Y);
+			SET_GAME_STATE (ORZ_SPACE_SIDE, 3);
+			GLOBAL (CurrentActivity) |= END_INTERPLANETARY;
+		}
+	}
+	return true;
+}
diff -ruNp src.orig/uqm/planets/generate/genpet.c src/uqm/planets/generate/genpet.c
--- src.orig/uqm/planets/generate/genpet.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/genpet.c	2017-11-01 15:31:03 -0700
@@ -72,6 +72,7 @@ GenerateTalkingPet_generatePlanets (SOLA
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp src.orig/uqm/planets/generate/genpku.c src/uqm/planets/generate/genpku.c
--- src.orig/uqm/planets/generate/genpku.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/genpku.c	2017-11-01 15:31:03 -0700
@@ -16,6 +16,9 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: -No ships orbit Pkunk homeworld anymore.
+//			 -Removed clear spindle
+
 #include "genall.h"
 #include "../lander.h"
 #include "../planets.h"
@@ -31,10 +34,8 @@
 static bool GeneratePkunk_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GeneratePkunk_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GeneratePkunk_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static bool GeneratePkunk_pickupEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static bool GeneratePkunk_generateEnergy (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
 
 
 const GenerateFunctions generatePkunkFunctions = {
@@ -48,9 +49,6 @@ const GenerateFunctions generatePkunkFun
 	/* .generateMinerals = */ GenerateDefault_generateMinerals,
 	/* .generateEnergy   = */ GeneratePkunk_generateEnergy,
 	/* .generateLife     = */ GenerateDefault_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GeneratePkunk_pickupEnergy,
-	/* .pickupLife       = */ GenerateDefault_pickupLife,
 };
 
 
@@ -70,6 +68,7 @@ GeneratePkunk_generatePlanets (SOLARSYS_
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
@@ -79,7 +78,9 @@ GeneratePkunk_generateOrbital (SOLARSYS_
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		if (ActivateStarShip (PKUNK_SHIP, SPHERE_TRACKING))
+		// JMS: No ships orbit Pkunk homeworld anymore.
+		//if (ActivateStarShip (PKUNK_SHIP, SPHERE_TRACKING))
+		if (0)
 		{
 			NotifyOthers (PKUNK_SHIP, IPNL_ALL_CLEAR);
 			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
@@ -108,12 +109,11 @@ GeneratePkunk_generateOrbital (SOLARSYS_
 					CaptureDrawable (LoadGraphic (RUINS_MASK_PMAP_ANIM));
 			solarSys->SysInfo.PlanetInfo.DiscoveryString =
 					CaptureStringTable (LoadStringTable (PKUNK_RUINS_STRTAB));
-			if (GET_GAME_STATE (CLEAR_SPINDLE))
-			{	// Already picked up the Clear Spindle, skip the report
-				solarSys->SysInfo.PlanetInfo.DiscoveryString =
-						SetAbsStringTableIndex (
-						solarSys->SysInfo.PlanetInfo.DiscoveryString, 1);
-			}
+			// JMS: No more clear spindles!
+			//if (GET_GAME_STATE (CLEAR_SPINDLE))
+			solarSys->SysInfo.PlanetInfo.DiscoveryString =
+				SetAbsStringTableIndex (
+							solarSys->SysInfo.PlanetInfo.DiscoveryString, 1);
 		}
 	}
 
@@ -122,38 +122,62 @@ GeneratePkunk_generateOrbital (SOLARSYS_
 }
 
 static bool
-GeneratePkunk_pickupEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GeneratePkunk_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
+		COUNT *whichNode)
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		GenerateDefault_landerReportCycle (solarSys);
-
-		// The artifact can be picked up from any ruin
-		if (!GET_GAME_STATE (CLEAR_SPINDLE))
-		{	// Just picked up the Clear Spindle from a ruin
-			SetLanderTakeoff ();
-
-			SET_GAME_STATE (CLEAR_SPINDLE, 1);
-			SET_GAME_STATE (CLEAR_SPINDLE_ON_SHIP, 1);
-		}
-
-		return false; // do not remove the node
-	}
+		COUNT i;
+		COUNT nodeI;
+		DWORD rand_val;
+		DWORD old_rand;
+
+		old_rand = TFB_SeedRandom (
+				solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN]);
+
+		nodeI = 0;
+		i = 0;
+		do
+		{
+			rand_val = TFB_Random ();
+			solarSys->SysInfo.PlanetInfo.CurPt.x =
+					((LOWORD (rand_val)) % (MAP_WIDTH - (8 << 1))) + 8;
+			solarSys->SysInfo.PlanetInfo.CurPt.y =
+					((LOWORD (rand_val)) % (MAP_HEIGHT - (8 << 1))) + 8;
+			// JMS: No more clear spindles!
+			/*if (!GET_GAME_STATE (CLEAR_SPINDLE))
+				solarSys->SysInfo.PlanetInfo.CurType = 0;
+				else*/
+			solarSys->SysInfo.PlanetInfo.CurType = 1;
+			solarSys->SysInfo.PlanetInfo.CurDensity = 0;
+			if (solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+					& (1L << i))
+			{
+				solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+						&= ~(1L << i);
 
-	(void) whichNode;
-	return false;
-}
+				// JMS: No more clear spindles!
+				/*if (!GET_GAME_STATE (CLEAR_SPINDLE))
+				{
+					SetLanderTakeoff ();
+
+					SET_GAME_STATE (CLEAR_SPINDLE, 1);
+					SET_GAME_STATE (CLEAR_SPINDLE_ON_SHIP, 1);
+					}*/
+			}
+			if (nodeI >= *whichNode
+					&& !(solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+					& (1L << i)))
+				break;
+			++nodeI;
+		} while (++i < 16);
+		*whichNode = nodeI;
 
-static COUNT
-GeneratePkunk_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
-{
-	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
-	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
+		TFB_SeedRandom (old_rand);
+		return true;
 	}
 
-	return 0;
+	*whichNode = 0;
+	return true;
 }
 
diff -ruNp src.orig/uqm/planets/generate/genrain.c src/uqm/planets/generate/genrain.c
--- src.orig/uqm/planets/generate/genrain.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/genrain.c	2017-11-01 15:31:03 -0700
@@ -39,9 +39,6 @@ const GenerateFunctions generateRainbowW
 	/* .generateMinerals = */ GenerateDefault_generateMinerals,
 	/* .generateEnergy   = */ GenerateDefault_generateEnergy,
 	/* .generateLife     = */ GenerateDefault_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GenerateDefault_pickupEnergy,
-	/* .pickupLife       = */ GenerateDefault_pickupLife,
 };
 
 
@@ -65,6 +62,7 @@ GenerateRainbowWorld_generatePlanets (SO
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
@@ -86,13 +84,16 @@ GenerateRainbowWorld_generateOrbital (SO
 		SDPtr = &star_array[0];
 		while (SDPtr != CurStarDescPtr)
 		{
-			if (SDPtr->Index == RAINBOW_DEFINED)
+			if (SDPtr->Index == RAINBOW_DEFINED || SDPtr->Index == RAINBOW_KNOWN_DEFINED)
 				++which_rainbow;
 			++SDPtr;
 		}
 		rainbow_mask |= 1 << which_rainbow;
 		SET_GAME_STATE (RAINBOW_WORLD0, LOBYTE (rainbow_mask));
 		SET_GAME_STATE (RAINBOW_WORLD1, HIBYTE (rainbow_mask));
+		
+		if(CurStarDescPtr->Index == RAINBOW_KNOWN_DEFINED && (GET_GAME_STATE(FOUND_KNOWN_RAINBOW_WORLD) == 0))
+			SET_GAME_STATE (FOUND_KNOWN_RAINBOW_WORLD, 1);
 	}
 
 	GenerateDefault_generateOrbital (solarSys, world);
diff -ruNp src.orig/uqm/planets/generate/gensam.c src/uqm/planets/generate/gensam.c
--- src.orig/uqm/planets/generate/gensam.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/gensam.c	2017-11-01 15:31:03 -0700
@@ -49,9 +49,6 @@ const GenerateFunctions generateSaMatraF
 	/* .generateMinerals = */ GenerateDefault_generateMinerals,
 	/* .generateEnergy   = */ GenerateDefault_generateEnergy,
 	/* .generateLife     = */ GenerateDefault_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GenerateDefault_pickupEnergy,
-	/* .pickupLife       = */ GenerateDefault_pickupLife,
 };
 
 
@@ -156,6 +153,7 @@ GenerateSaMatra_generateMoons (SOLARSYS_
 				COSINE (angle, solarSys->MoonDesc[0].radius);
 		solarSys->MoonDesc[0].location.y =
 				SINE (angle, solarSys->MoonDesc[0].radius);
+		ComputeSpeed(&solarSys->MoonDesc[0], TRUE, 1);
 	}
 
 	return true;
diff -ruNp src.orig/uqm/planets/generate/genshocrash.c src/uqm/planets/generate/genshocrash.c
--- src.orig/uqm/planets/generate/genshocrash.c	1969-12-31 16:00:00 -0800
+++ src/uqm/planets/generate/genshocrash.c	2017-11-01 15:31:03 -0700
@@ -0,0 +1,260 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+// JMS 2010: - Totally new file: Shofixti crash site
+//			 - Now the number of Lurg ships at Shofixti crash site is remembered by the game
+
+#include "../../build.h"
+#include "../../encount.h"
+#include "../../globdata.h"
+#include "../../ipdisp.h"
+#include "../lander.h"
+#include "../../nameref.h"
+#include "../../resinst.h"
+#include "../../setup.h"
+#include "../../state.h"
+#include "genall.h"
+#include "libs/mathlib.h"
+#include "libs/log.h"
+#include "../../grpinfo.h"
+
+
+static bool GenerateShofixtiCrashSite_initNpcs (SOLARSYS_STATE *solarSys);
+static bool GenerateShofixtiCrashSite_generatePlanets (SOLARSYS_STATE *solarSys);
+static bool GenerateShofixtiCrashSite_generateMoons (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *planet);
+static bool GenerateShofixtiCrashSite_generateOrbital (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world);
+static bool GenerateShofixtiCrashSite_generateEnergy (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
+
+
+const GenerateFunctions generateShofixtiCrashSiteFunctions = {
+	/* .initNpcs         = */ GenerateShofixtiCrashSite_initNpcs,
+	/* .reinitNpcs       = */ GenerateDefault_reinitNpcs,
+	/* .uninitNpcs       = */ GenerateDefault_uninitNpcs,
+	/* .generatePlanets  = */ GenerateShofixtiCrashSite_generatePlanets,
+	/* .generateMoons    = */ GenerateShofixtiCrashSite_generateMoons,
+	/* .generateName     = */ GenerateDefault_generateName,
+	/* .generateOrbital  = */ GenerateShofixtiCrashSite_generateOrbital,
+	/* .generateMinerals = */ GenerateDefault_generateMinerals,
+	/* .generateEnergy   = */ GenerateShofixtiCrashSite_generateEnergy,
+	/* .generateLife     = */ GenerateDefault_generateLife,
+};
+
+
+static int
+init_lurg_teaser (void)
+{
+	HIPGROUP hGroup;
+
+	if (!GET_GAME_STATE (PLAYER_VISITED_BETA_NAOS)
+			&& GetGroupInfo (GLOBAL (BattleGroupRef), GROUP_INIT_IP)
+			&& (hGroup = GetHeadLink (&GLOBAL (ip_group_q))))
+	{
+		IP_GROUP *GroupPtr;
+		SET_GAME_STATE (PLAYER_VISITED_BETA_NAOS, 1);
+
+		GroupPtr = LockIpGroup (&GLOBAL (ip_group_q), hGroup);
+		GroupPtr->task = FLEE;
+		GroupPtr->sys_loc = 0; 
+		GroupPtr->dest_loc = 0; 
+		GroupPtr->loc.x = 9500;
+		GroupPtr->loc.y = 9000;
+		GroupPtr->group_counter = 0;
+		UnlockIpGroup (&GLOBAL (ip_group_q), hGroup);
+		return 1;
+	}
+	else
+		return 0;
+}
+
+
+static bool GenerateShofixtiCrashSite_initNpcs (SOLARSYS_STATE *solarSys)
+{
+	if (!GET_GAME_STATE (PLAYER_VISITED_BETA_NAOS))
+	{
+		GLOBAL (BattleGroupRef) = GET_GAME_STATE_32 (LURG_GRPOFFS0);
+		
+		if (GLOBAL (BattleGroupRef) == 0)
+		{			
+			CloneShipFragment (LURG_SHIP, &GLOBAL (npc_built_ship_q), 0);
+			GLOBAL (BattleGroupRef) = PutGroupInfo (GROUPS_ADD_NEW, 1);
+			ReinitQueue (&GLOBAL (npc_built_ship_q));
+			SET_GAME_STATE_32 (LURG_GRPOFFS0, GLOBAL (BattleGroupRef));
+		}
+		
+	}
+	if (!init_lurg_teaser ()) 
+		GenerateDefault_initNpcs (solarSys);
+	
+	return true;
+}
+
+static bool
+GenerateShofixtiCrashSite_generatePlanets (SOLARSYS_STATE *solarSys)
+{
+	COUNT angle;
+	
+	GenerateDefault_generatePlanets (solarSys);
+	
+	solarSys->PlanetDesc[2].data_index = MAROON_WORLD;
+	solarSys->PlanetDesc[2].NumPlanets = 1;
+	angle = ARCTAN (solarSys->PlanetDesc[2].location.x, solarSys->PlanetDesc[2].location.y);
+	solarSys->PlanetDesc[2].location.x = COSINE (angle, solarSys->PlanetDesc[2].radius);
+	solarSys->PlanetDesc[2].location.y = SINE (angle, solarSys->PlanetDesc[2].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[2], FALSE, 1);
+	return true;
+}
+
+
+	
+static bool
+GenerateShofixtiCrashSite_generateMoons (SOLARSYS_STATE *solarSys,
+					 PLANET_DESC *planet)
+{
+	DWORD rand_val;
+	
+	GenerateDefault_generateMoons (solarSys, planet);
+	if (matchWorld(solarSys, planet, 2, MATCH_PLANET))
+	{
+		COUNT angle;
+		
+		solarSys->MoonDesc[0].data_index = SELENIC_WORLD;
+		solarSys->MoonDesc[0].radius = MIN_MOON_RADIUS + (MAX_MOONS - 1) * MOON_DELTA;
+		rand_val = TFB_Random ();
+		angle = NORMALIZE_ANGLE (LOWORD (rand_val));
+		solarSys->MoonDesc[0].location.x = COSINE (angle, solarSys->MoonDesc[0].radius);
+		solarSys->MoonDesc[0].location.y = SINE (angle, solarSys->MoonDesc[0].radius);
+		ComputeSpeed(&solarSys->MoonDesc[0], TRUE, 1);
+	}
+	return true;
+}
+
+#define LURG_TASKFORCE_SIZE 3
+
+static bool
+GenerateShofixtiCrashSite_generateOrbital (SOLARSYS_STATE *solarSys,
+					   PLANET_DESC *world)
+{
+	if (matchWorld(solarSys, world, 2, MATCH_PLANET)
+	    && !GET_GAME_STATE (CRASH_SITE_UNPROTECTED)
+	    && ActivateStarShip (LURG_SHIP, SPHERE_TRACKING))
+	{
+		COUNT i;
+					
+		PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
+		ReinitQueue (&GLOBAL (ip_group_q));
+		assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
+				
+		if(!(GET_GAME_STATE(CRASH_SITE_VISITED)))
+		{
+			SET_GAME_STATE(CRASH_SITE_VISITED, 1);
+			SET_GAME_STATE(CRASH_SITE_LURG_SURVIVORS, LURG_TASKFORCE_SIZE);
+			for (i = 0; i < LURG_TASKFORCE_SIZE; ++i)
+				CloneShipFragment (LURG_SHIP, &GLOBAL (npc_built_ship_q), 0);
+		}
+		else
+		{
+			for (i = 0; i < GET_GAME_STATE(CRASH_SITE_LURG_SURVIVORS); ++i)
+				CloneShipFragment (LURG_SHIP, &GLOBAL (npc_built_ship_q), 0);
+		}
+					
+		GLOBAL (CurrentActivity) |= START_INTERPLANETARY;
+		SET_GAME_STATE (GLOBAL_FLAGS_AND_DATA, 1 << 6);
+		InitCommunication (LURG_CONVERSATION);
+		
+		if (GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD))
+		{	
+			// JMS: Empty the Lurg ship queue upon quitting so the game won't crash.
+			ReinitQueue (&GLOBAL (npc_built_ship_q));
+			GetGroupInfo (GROUPS_RANDOM, GROUP_LOAD_IP);
+			return true;
+		}
+		else
+		{
+			BOOLEAN LurgSurvivors;
+			
+			LurgSurvivors = (GetHeadLink ( &GLOBAL (npc_built_ship_q) ) != 0);
+			SET_GAME_STATE(CRASH_SITE_LURG_SURVIVORS, CountLinks (&GLOBAL (npc_built_ship_q)));
+			GLOBAL (CurrentActivity) &= ~START_INTERPLANETARY;
+			ReinitQueue (&GLOBAL (npc_built_ship_q));
+			GetGroupInfo (GROUPS_RANDOM, GROUP_LOAD_IP);
+			
+			if (LurgSurvivors)
+				return true;
+		
+			LockMutex (GraphicsLock);
+			RepairSISBorder ();
+			UnlockMutex (GraphicsLock);
+			SET_GAME_STATE (CRASH_SITE_UNPROTECTED, 1);
+		}
+	}
+	
+	LoadStdLanderFont (&solarSys->SysInfo.PlanetInfo);
+	solarSys->PlanetSideFrame[1] = CaptureDrawable (LoadGraphic (PRECURSOR_BATTLESHIP_MASK_PMAP_ANIM) );
+	solarSys->SysInfo.PlanetInfo.DiscoveryString = CaptureStringTable (LoadStringTable (SHOFIXTI_CRASH_SITE_STRTAB));
+	
+	GenerateDefault_generateOrbital (solarSys, world);
+	if (matchWorld(solarSys, world, 2, MATCH_PLANET))
+	{
+		solarSys->SysInfo.PlanetInfo.Weather = 0;
+		solarSys->SysInfo.PlanetInfo.Tectonics = 1;
+	}
+	
+	return true;
+}
+
+
+static bool
+GenerateShofixtiCrashSite_generateEnergy (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode)
+{
+	DWORD rand_val, old_rand;
+
+	if (matchWorld(solarSys, world, 2, MATCH_PLANET)
+	    && (GET_GAME_STATE (WHICH_SHIP_PLAYER_HAS) != PRECURSOR_BATTLESHIP) )
+	{
+		old_rand = TFB_SeedRandom (solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN]);
+		rand_val = TFB_Random ();
+		
+		solarSys->SysInfo.PlanetInfo.CurPt.x = 187 << RESOLUTION_FACTOR;
+		solarSys->SysInfo.PlanetInfo.CurPt.y = MAP_HEIGHT - (16 << RESOLUTION_FACTOR);
+		solarSys->SysInfo.PlanetInfo.CurDensity = 0;
+		solarSys->SysInfo.PlanetInfo.CurType = 0; // JMS: Fake picking the blip up upon finding...
+		
+		solarSys->CurNode = 1;
+		
+		// ... which allows us to use this retrieve switch to make things happen
+		if (solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN] & (1L << 0))
+		{
+			// Now we reverse the fake picking up so the blip stays on the planet.
+			solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN] &= ~(1L << 0); 
+			
+			SetLanderTakeoff ();
+			SET_GAME_STATE (BLACK_ORB_STATE, 1);
+			SET_GAME_STATE (WHICH_SHIP_PLAYER_HAS, PRECURSOR_BATTLESHIP);
+		}
+		
+		TFB_SeedRandom (old_rand);
+		return true;
+	}
+	
+	solarSys->CurNode = 0;
+	return true;
+}
diff -ruNp src.orig/uqm/planets/generate/genshof.c src/uqm/planets/generate/genshof.c
--- src.orig/uqm/planets/generate/genshof.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/genshof.c	2017-11-01 15:31:03 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: Removed all Tanaka/Katana related crap
+
 #include "genall.h"
 #include "../../build.h"
 #include "../../globdata.h"
@@ -24,18 +26,13 @@
 #include "../planets.h"
 
 
-static bool GenerateShofixti_initNpcs (SOLARSYS_STATE *solarSys);
-static bool GenerateShofixti_reinitNpcs (SOLARSYS_STATE *solarSys);
-static bool GenerateShofixti_uninitNpcs (SOLARSYS_STATE *solarSys);
 static bool GenerateShofixti_generatePlanets (SOLARSYS_STATE *solarSys);
 
-static void check_old_shofixti (void);
-
 
 const GenerateFunctions generateShofixtiFunctions = {
-	/* .initNpcs         = */ GenerateShofixti_initNpcs,
-	/* .reinitNpcs       = */ GenerateShofixti_reinitNpcs,
-	/* .uninitNpcs       = */ GenerateShofixti_uninitNpcs,
+	/* .initNpcs         = */ GenerateDefault_initNpcs,
+	/* .reinitNpcs       = */ GenerateDefault_reinitNpcs,
+	/* .uninitNpcs       = */ GenerateDefault_uninitNpcs,
 	/* .generatePlanets  = */ GenerateShofixti_generatePlanets,
 	/* .generateMoons    = */ GenerateDefault_generateMoons,
 	/* .generateName     = */ GenerateDefault_generateName,
@@ -43,90 +40,10 @@ const GenerateFunctions generateShofixti
 	/* .generateMinerals = */ GenerateDefault_generateMinerals,
 	/* .generateEnergy   = */ GenerateDefault_generateEnergy,
 	/* .generateLife     = */ GenerateDefault_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GenerateDefault_pickupEnergy,
-	/* .pickupLife       = */ GenerateDefault_pickupLife,
 };
 
 
 static bool
-GenerateShofixti_initNpcs (SOLARSYS_STATE *solarSys)
-{
-	if (!GET_GAME_STATE (SHOFIXTI_RECRUITED)
-			&& (!GET_GAME_STATE (SHOFIXTI_KIA)
-			|| (!GET_GAME_STATE (SHOFIXTI_BRO_KIA)
-			&& GET_GAME_STATE (MAIDENS_ON_SHIP))))
-	{
-		GLOBAL (BattleGroupRef) = GET_GAME_STATE_32 (SHOFIXTI_GRPOFFS0);
-		if (GLOBAL (BattleGroupRef) == 0
-				|| !GetGroupInfo (GLOBAL (BattleGroupRef), GROUP_INIT_IP))
-		{
-			HSHIPFRAG hStarShip;
-
-			if (GLOBAL (BattleGroupRef) == 0)
-				GLOBAL (BattleGroupRef) = ~0L;
-
-			hStarShip = CloneShipFragment (SHOFIXTI_SHIP,
-					&GLOBAL (npc_built_ship_q), 1);
-			if (hStarShip)
-			{	/* Set old Shofixti name; his brother if Tanaka died */
-				SHIP_FRAGMENT *FragPtr = LockShipFrag (
-						&GLOBAL (npc_built_ship_q), hStarShip);
-				/* Name Tanaka or Katana (+1) */
-				FragPtr->captains_name_index =
-						NAME_OFFSET + NUM_CAPTAINS_NAMES +
-						(GET_GAME_STATE (SHOFIXTI_KIA) & 1);
-				UnlockShipFrag (&GLOBAL (npc_built_ship_q), hStarShip);
-			}
-
-			GLOBAL (BattleGroupRef) = PutGroupInfo (
-					GLOBAL (BattleGroupRef), 1);
-			ReinitQueue (&GLOBAL (npc_built_ship_q));
-			SET_GAME_STATE_32 (SHOFIXTI_GRPOFFS0, GLOBAL (BattleGroupRef));
-		}
-	}
-
-	// This was originally a fallthrough to REINIT_NPCS.
-	// XXX: is the call to check_old_shofixti() needed?
-	GenerateDefault_initNpcs (solarSys);
-	check_old_shofixti ();
-
-	return true;
-}
-
-static bool
-GenerateShofixti_reinitNpcs (SOLARSYS_STATE *solarSys)
-{
-	GenerateDefault_reinitNpcs (solarSys);
-	check_old_shofixti ();
-
-	(void) solarSys;
-	return true;
-}
-
-static bool
-GenerateShofixti_uninitNpcs (SOLARSYS_STATE *solarSys)
-{
-	if (GLOBAL (BattleGroupRef)
-			&& !GET_GAME_STATE (SHOFIXTI_RECRUITED)
-			&& GetHeadLink (&GLOBAL (ip_group_q)) == 0)
-	{
-		if (!GET_GAME_STATE (SHOFIXTI_KIA))
-		{
-			SET_GAME_STATE (SHOFIXTI_KIA, 1);
-			SET_GAME_STATE (SHOFIXTI_VISITS, 0);
-		}
-		else if (GET_GAME_STATE (MAIDENS_ON_SHIP))
-		{
-			SET_GAME_STATE (SHOFIXTI_BRO_KIA, 1);
-		}
-	}
-	
-	GenerateDefault_uninitNpcs (solarSys);
-	return true;
-}
-
-static bool
 GenerateShofixti_generatePlanets (SOLARSYS_STATE *solarSys)
 {
 	COUNT i;
@@ -148,31 +65,3 @@ GenerateShofixti_generatePlanets (SOLARS
 
 	return true;
 }
-
-
-static void
-check_old_shofixti (void)
-{
-	HIPGROUP hGroup;
-	IP_GROUP *GroupPtr;
-
-	if (!GLOBAL (BattleGroupRef))
-		return; // nothing to check
-
-	hGroup = GetHeadLink (&GLOBAL (ip_group_q));
-	if (!hGroup)
-		return; // still nothing to check
-
-	GroupPtr = LockIpGroup (&GLOBAL (ip_group_q), hGroup);
-	// REFORM_GROUP was set in ipdisp.c:ip_group_collision()
-	// during a collision with the flagship.
-	if (GroupPtr->race_id == SHOFIXTI_SHIP
-			&& (GroupPtr->task & REFORM_GROUP)
-			&& GET_GAME_STATE (SHOFIXTI_RECRUITED))
-	{
-		GroupPtr->task = FLEE | IGNORE_FLAGSHIP | REFORM_GROUP;
-		GroupPtr->dest_loc = 0;
-	}
-	UnlockIpGroup (&GLOBAL (ip_group_q), hGroup);
-}
-
diff -ruNp src.orig/uqm/planets/generate/genshofixticolony.c src/uqm/planets/generate/genshofixticolony.c
--- src.orig/uqm/planets/generate/genshofixticolony.c	1969-12-31 16:00:00 -0800
+++ src/uqm/planets/generate/genshofixticolony.c	2017-11-01 15:31:03 -0700
@@ -0,0 +1,130 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+// JMS 2011: - Totally new file: Shofixti colony
+
+#include "../../build.h"
+#include "../../encount.h"
+#include "../../globdata.h"
+#include "../../ipdisp.h"
+#include "../lander.h"
+#include "../../nameref.h"
+#include "../../resinst.h"
+#include "../../setup.h"
+#include "../../state.h"
+#include "genall.h"
+#include "libs/mathlib.h"
+#include "libs/log.h"
+#include "../../grpinfo.h"
+
+
+static bool GenerateShofixtiColony_generatePlanets (SOLARSYS_STATE *solarSys);
+static bool GenerateShofixtiColony_generateMoons (SOLARSYS_STATE *solarSys, PLANET_DESC *planet);
+static bool GenerateShofixtiColony_generateOrbital (SOLARSYS_STATE *solarSys, PLANET_DESC *world);
+
+const GenerateFunctions generateShofixtiColonyFunctions = {
+	/* .initNpcs         = */ GenerateDefault_initNpcs,
+	/* .reinitNpcs       = */ GenerateDefault_reinitNpcs,
+	/* .uninitNpcs       = */ GenerateDefault_uninitNpcs,
+	/* .generatePlanets  = */ GenerateShofixtiColony_generatePlanets,
+	/* .generateMoons    = */ GenerateShofixtiColony_generateMoons,
+	/* .generateName     = */ GenerateDefault_generateName,
+	/* .generateOrbital  = */ GenerateShofixtiColony_generateOrbital,
+	/* .generateMinerals = */ GenerateDefault_generateMinerals,
+	/* .generateEnergy   = */ GenerateDefault_generateEnergy,
+	/* .generateLife     = */ GenerateDefault_generateLife,
+};
+
+static bool
+GenerateShofixtiColony_generatePlanets (SOLARSYS_STATE *solarSys)
+{
+	COUNT angle;
+	
+	GenerateDefault_generatePlanets (solarSys);
+	
+	solarSys->PlanetDesc[0].data_index = XENOLITHIC_WORLD;
+	solarSys->PlanetDesc[0].NumPlanets = 1;
+	solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 123L / 100;
+	angle = ARCTAN (solarSys->PlanetDesc[0].location.x, solarSys->PlanetDesc[0].location.y);
+	solarSys->PlanetDesc[0].location.x = COSINE (angle, solarSys->PlanetDesc[0].radius);
+	solarSys->PlanetDesc[0].location.y = SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
+	return true;
+}
+
+
+	
+static bool
+GenerateShofixtiColony_generateMoons (SOLARSYS_STATE *solarSys,
+					 PLANET_DESC *planet)
+{
+	DWORD rand_val;
+	
+	GenerateDefault_generateMoons (solarSys, planet);
+	if (matchWorld(solarSys, planet, 0, MATCH_PLANET))
+	{
+		COUNT angle;
+		
+		solarSys->MoonDesc[0].radius = MIN_MOON_RADIUS + (MAX_MOONS - 2) * MOON_DELTA;
+		rand_val = TFB_Random ();
+		angle = NORMALIZE_ANGLE (LOWORD (rand_val));
+		solarSys->MoonDesc[0].location.x = COSINE (angle, solarSys->MoonDesc[0].radius);
+		solarSys->MoonDesc[0].location.y = SINE (angle, solarSys->MoonDesc[0].radius);
+		ComputeSpeed(&solarSys->MoonDesc[0], TRUE, 1);
+	}
+	return true;
+}
+
+
+static bool
+GenerateShofixtiColony_generateOrbital (SOLARSYS_STATE *solarSys,
+					   PLANET_DESC *world)
+{
+	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
+	{
+		if (ActivateStarShip (SHOFIXTI_SHIP, SPHERE_TRACKING))
+		{
+			NotifyOthers (SHOFIXTI_SHIP, IPNL_ALL_CLEAR);
+			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
+			ReinitQueue (&GLOBAL (ip_group_q));
+			assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
+			
+			CloneShipFragment (SHOFIXTI_SHIP, &GLOBAL (npc_built_ship_q), 15);
+			
+			GLOBAL (CurrentActivity) |= START_INTERPLANETARY;
+			SET_GAME_STATE (GLOBAL_FLAGS_AND_DATA, 1 << 7);
+			InitCommunication (SHOFIXTICOLONY_CONVERSATION);
+			
+			if (!(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD)))
+			{
+				GLOBAL (CurrentActivity) &= ~START_INTERPLANETARY;
+				ReinitQueue (&GLOBAL (npc_built_ship_q));
+				GetGroupInfo (GROUPS_RANDOM, GROUP_LOAD_IP);
+			}
+			
+			return true;
+		}
+		
+		LoadStdLanderFont (&solarSys->SysInfo.PlanetInfo);
+		solarSys->PlanetSideFrame[1] = CaptureDrawable (LoadGraphic (RUINS_MASK_PMAP_ANIM));
+		solarSys->SysInfo.PlanetInfo.DiscoveryString = CaptureStringTable (LoadStringTable (RUINS_STRTAB));
+	}
+	
+	GenerateDefault_generateOrbital (solarSys, world);
+	return true;
+}
diff -ruNp src.orig/uqm/planets/generate/genslaverace.c src/uqm/planets/generate/genslaverace.c
--- src.orig/uqm/planets/generate/genslaverace.c	1969-12-31 16:00:00 -0800
+++ src/uqm/planets/generate/genslaverace.c	2017-11-01 15:31:03 -0700
@@ -0,0 +1,163 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "../../build.h"
+#include "../../encount.h"
+#include "../../globdata.h"
+#include "../../ipdisp.h"
+#include "../lander.h"
+#include "../../nameref.h"
+#include "../../resinst.h"
+#include "../../setup.h"
+#include "../../state.h"
+#include "../../sounds.h"
+#include "genall.h"
+#include "libs/mathlib.h"
+
+static bool GenerateSlaverace_generatePlanets (SOLARSYS_STATE *solarSys);
+static bool GenerateSlaverace_generateOrbital (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world);
+
+
+const GenerateFunctions generateSlaveraceFunctions = {
+	/* .initNpcs         = */ GenerateDefault_initNpcs,
+	/* .reinitNpcs       = */ GenerateDefault_reinitNpcs,
+	/* .uninitNpcs       = */ GenerateDefault_uninitNpcs,
+	/* .generatePlanets  = */ GenerateSlaverace_generatePlanets,
+	/* .generateMoons    = */ GenerateDefault_generateMoons,
+	/* .generateName     = */ GenerateDefault_generateName,
+	/* .generateOrbital  = */ GenerateSlaverace_generateOrbital,
+	/* .generateMinerals = */ GenerateDefault_generateMinerals,
+	/* .generateEnergy   = */ GenerateDefault_generateEnergy,
+	/* .generateLife     = */ GenerateDefault_generateLife,
+};
+
+
+static bool
+GenerateSlaverace_generatePlanets (SOLARSYS_STATE *solarSys)
+{
+	COUNT angle;
+	
+	GenerateDefault_generatePlanets (solarSys);
+	if (CurStarDescPtr->Index == SLAVERACE_DEFINED)
+	{
+		solarSys->PlanetDesc[0].data_index = WATER_WORLD;
+		solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 156L / 100;
+		solarSys->PlanetDesc[0].NumPlanets = 0;
+		angle = ARCTAN (
+				solarSys->PlanetDesc[0].location.x,
+				solarSys->PlanetDesc[0].location.y
+				);
+		solarSys->PlanetDesc[0].location.x =
+			COSINE (angle, solarSys->PlanetDesc[0].radius);
+		solarSys->PlanetDesc[0].location.y =
+			SINE (angle, solarSys->PlanetDesc[0].radius);
+		ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
+	}
+	return true;
+}
+
+static bool
+GenerateSlaverace_generateOrbital (SOLARSYS_STATE *solarSys,
+				   PLANET_DESC *world)
+{
+	if ((CurStarDescPtr->Index == SLAVERACE_DEFINED
+	     && matchWorld(solarSys, world, 0, MATCH_PLANET))
+	    || (CurStarDescPtr->Index == TAALO_PROTECTOR_DEFINED
+		&& matchWorld(solarSys, world, 1, 2)
+		&& !GET_GAME_STATE (TAALO_PROTECTOR)))
+	{
+		COUNT i;
+		
+		if ((CurStarDescPtr->Index == ORZ_DEFINED
+		     || !GET_GAME_STATE (TAALO_UNPROTECTED))
+		    && ActivateStarShip (ORZ_SHIP, SPHERE_TRACKING))
+		{
+			NotifyOthers (ORZ_SHIP, IPNL_ALL_CLEAR);
+			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
+			ReinitQueue (&GLOBAL (ip_group_q));
+			assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
+			
+			if (CurStarDescPtr->Index == SLAVERACE_DEFINED)
+			{
+				CloneShipFragment (ORZ_SHIP,
+						   &GLOBAL (npc_built_ship_q), INFINITE_FLEET);
+				SET_GAME_STATE (GLOBAL_FLAGS_AND_DATA, 1 << 7);
+			}
+			else
+			{
+				for (i = 0; i < 14; ++i)
+					CloneShipFragment (ORZ_SHIP,
+							   &GLOBAL (npc_built_ship_q), 0);
+				SET_GAME_STATE (GLOBAL_FLAGS_AND_DATA, 1 << 6);
+			}
+			GLOBAL (CurrentActivity) |= START_INTERPLANETARY;
+			InitCommunication (CHMMR_CONVERSATION);
+			
+			if (GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD))
+				return true;
+			else
+			{
+				BOOLEAN OrzSurvivors;
+				
+				OrzSurvivors = GetHeadLink (&GLOBAL (npc_built_ship_q))
+					&& (CurStarDescPtr->Index == SLAVERACE_DEFINED
+					    || !GET_GAME_STATE (TAALO_UNPROTECTED));
+				
+				GLOBAL (CurrentActivity) &= ~START_INTERPLANETARY;
+				ReinitQueue (&GLOBAL (npc_built_ship_q));
+				GetGroupInfo (GROUPS_RANDOM, GROUP_LOAD_IP);
+				
+				if (OrzSurvivors)
+					return true;
+				
+				LockMutex (GraphicsLock);
+				RepairSISBorder ();
+				UnlockMutex (GraphicsLock);
+			}
+		}
+		
+		SET_GAME_STATE (TAALO_UNPROTECTED, 1);
+		if (CurStarDescPtr->Index == TAALO_PROTECTOR_DEFINED)
+		{
+			LoadStdLanderFont (&solarSys->SysInfo.PlanetInfo);
+			solarSys->PlanetSideFrame[1] =
+				CaptureDrawable (
+						 LoadGraphic (TAALO_DEVICE_MASK_PMAP_ANIM)
+						 );
+			solarSys->SysInfo.PlanetInfo.DiscoveryString =
+				CaptureStringTable (
+						    LoadStringTable (TAALO_DEVICE_STRTAB)
+						    );
+		}
+		else
+		{
+			LoadStdLanderFont (&solarSys->SysInfo.PlanetInfo);
+			solarSys->PlanetSideFrame[1] =
+				CaptureDrawable (
+						 LoadGraphic (RUINS_MASK_PMAP_ANIM)
+						 );
+			solarSys->SysInfo.PlanetInfo.DiscoveryString =
+				CaptureStringTable (
+						    LoadStringTable (RUINS_STRTAB)
+						    );
+		}
+	}
+	GenerateDefault_generateOrbital (solarSys, world);
+	return true;
+}
diff -ruNp src.orig/uqm/planets/generate/gensly.c src/uqm/planets/generate/gensly.c
--- src.orig/uqm/planets/generate/gensly.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/gensly.c	2017-11-01 15:31:03 -0700
@@ -37,9 +37,6 @@ const GenerateFunctions generateSlylandr
 	/* .generateMinerals = */ GenerateDefault_generateMinerals,
 	/* .generateEnergy   = */ GenerateDefault_generateEnergy,
 	/* .generateLife     = */ GenerateDefault_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GenerateDefault_pickupEnergy,
-	/* .pickupLife       = */ GenerateDefault_pickupLife,
 };
 
 
diff -ruNp src.orig/uqm/planets/generate/gensol.c src/uqm/planets/generate/gensol.c
--- src.orig/uqm/planets/generate/gensol.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/gensol.c	2017-11-01 15:31:03 -0700
@@ -16,6 +16,12 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2009: -Don't create Ur-quan probe.
+// JMS 2010: -Removed Fwiffo from Pluto.
+//			 -Removed tractors and base from moon.
+//			 -Earth is now restricted planet meaning it cannot be landed on.
+//			 -If starbase is encountered, the chasing ships turn away.
+
 #include "genall.h"
 #include "../lander.h"
 #include "../lifeform.h"
@@ -25,10 +31,13 @@
 #include "../../globdata.h"
 #include "../../gamestr.h"
 #include "../../grpinfo.h"
+#include "../../ipdisp.h"
 #include "../../nameref.h"
 #include "../../state.h"
 #include "libs/mathlib.h"
+#include "libs/log.h"
 
+#include <math.h>
 
 static bool GenerateSol_initNpcs (SOLARSYS_STATE *solarSys);
 static bool GenerateSol_reinitNpcs (SOLARSYS_STATE *solarSys);
@@ -39,15 +48,13 @@ static bool GenerateSol_generateName (SO
 		PLANET_DESC *world);
 static bool GenerateSol_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateSol_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static COUNT GenerateSol_generateLife (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static bool GenerateSol_pickupEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+// static bool GenerateSol_generateEnergy (SOLARSYS_STATE *solarSys,
+//		PLANET_DESC *world, COUNT *whichNode);
+static bool GenerateSol_generateLife (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
 
-static int init_probe (void);
-static void check_probe (void);
+// static int init_probe (void);
+// static void check_probe (void);
 
 
 const GenerateFunctions generateSolFunctions = {
@@ -59,17 +66,16 @@ const GenerateFunctions generateSolFunct
 	/* .generateName     = */ GenerateSol_generateName,
 	/* .generateOrbital  = */ GenerateSol_generateOrbital,
 	/* .generateMinerals = */ GenerateDefault_generateMinerals,
-	/* .generateEnergy   = */ GenerateSol_generateEnergy,
+	/* .generateEnergy   = */ GenerateDefault_generateEnergy, //GenerateSol_generateEnergy,
 	/* .generateLife     = */ GenerateSol_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GenerateSol_pickupEnergy,
-	/* .pickupLife       = */ GenerateDefault_pickupLife,
 };
 
 
 static bool
 GenerateSol_initNpcs (SOLARSYS_STATE *solarSys)
 {
+	// JMS: Don't create Ur-quan probe
+	/*
 	GLOBAL (BattleGroupRef) = GET_GAME_STATE_32 (URQUAN_PROBE_GRPOFFS0);
 	if (GLOBAL (BattleGroupRef) == 0)
 	{
@@ -80,7 +86,8 @@ GenerateSol_initNpcs (SOLARSYS_STATE *so
 	}
 
 	if (!init_probe ())
-		GenerateDefault_initNpcs (solarSys);
+	*/
+	GenerateDefault_initNpcs (solarSys);
 
 	return true;
 }
@@ -91,7 +98,7 @@ GenerateSol_reinitNpcs (SOLARSYS_STATE *
 	if (GET_GAME_STATE (CHMMR_BOMB_STATE) != 3)
 	{
 		GenerateDefault_reinitNpcs (solarSys);
-		check_probe ();
+		//		check_probe ();
 	}
 	else
 	{
@@ -113,14 +120,13 @@ GenerateSol_generatePlanets (SOLARSYS_ST
 	solarSys->SunDesc[0].NumPlanets = 9;
 	for (planetI = 0; planetI < 9; ++planetI)
 	{
-		COUNT angle;
 		DWORD rand_val;
 		UWORD word_val;
 		PLANET_DESC *pCurDesc = &solarSys->PlanetDesc[planetI];
 
 		pCurDesc->rand_seed = rand_val = TFB_Random ();
 		word_val = LOWORD (rand_val);
-		angle = NORMALIZE_ANGLE ((COUNT)HIBYTE (word_val));
+		pCurDesc->angle = NORMALIZE_ANGLE ((COUNT)HIBYTE (word_val));
 
 		switch (planetI)
 		{
@@ -133,10 +139,11 @@ GenerateSol_generatePlanets (SOLARSYS_ST
 				pCurDesc->data_index = PRIMORDIAL_WORLD;
 				pCurDesc->radius = EARTH_RADIUS * 72L / 100;
 				pCurDesc->NumPlanets = 0;
-				angle = NORMALIZE_ANGLE (FULL_CIRCLE - angle);
+				pCurDesc->angle = NORMALIZE_ANGLE (FULL_CIRCLE - pCurDesc->angle);
 				break;
 			case 2: /* EARTH */
-				pCurDesc->data_index = WATER_WORLD | PLANET_SHIELDED;
+				pCurDesc->data_index = WATER_WORLD;
+				pCurDesc->flags = PLANET_RESTRICTED; // JMS: Earth cannot be landed on.
 				pCurDesc->radius = EARTH_RADIUS;
 				pCurDesc->NumPlanets = 2;
 				break;
@@ -169,12 +176,13 @@ GenerateSol_generatePlanets (SOLARSYS_ST
 				pCurDesc->data_index = PELLUCID_WORLD;
 				pCurDesc->radius = EARTH_RADIUS * 1550L /* 3937L */ / 100;
 				pCurDesc->NumPlanets = 0;
-				angle = FULL_CIRCLE - OCTANT;
+				pCurDesc->angle = FULL_CIRCLE - OCTANT;
 				break;
 		}
 
-		pCurDesc->location.x = COSINE (angle, pCurDesc->radius);
-		pCurDesc->location.y = SINE (angle, pCurDesc->radius);
+		pCurDesc->orb_speed = FULL_CIRCLE / (365.25 * pow((float)pCurDesc->radius / EARTH_RADIUS, 1.5));
+		pCurDesc->location.x = COSINE (pCurDesc->angle, pCurDesc->radius);
+		pCurDesc->location.y = SINE (pCurDesc->angle, pCurDesc->radius);
 	}
 
 	return true;
@@ -203,6 +211,7 @@ GenerateSol_generateMoons (SOLARSYS_STAT
 					COSINE (angle, solarSys->MoonDesc[0].radius);
 			solarSys->MoonDesc[0].location.y =
 					SINE (angle, solarSys->MoonDesc[0].radius);
+			solarSys->MoonDesc[0].orb_speed = FULL_CIRCLE / 11.46;
 
 			/* Luna: */
 			solarSys->MoonDesc[1].data_index = SELENIC_WORLD;
@@ -214,24 +223,33 @@ GenerateSol_generateMoons (SOLARSYS_STAT
 					COSINE (angle, solarSys->MoonDesc[1].radius);
 			solarSys->MoonDesc[1].location.y =
 					SINE (angle, solarSys->MoonDesc[1].radius);
+			solarSys->MoonDesc[1].orb_speed = FULL_CIRCLE / 29;
 			break;
 		}
 		case 4: /* moons of JUPITER */
 			solarSys->MoonDesc[0].data_index = RADIOACTIVE_WORLD;
+			solarSys->MoonDesc[0].orb_speed = FULL_CIRCLE / 1.77;
 					/* Io */
 			solarSys->MoonDesc[1].data_index = HALIDE_WORLD;
+			solarSys->MoonDesc[1].orb_speed = FULL_CIRCLE / 3.55;
 					/* Europa */
 			solarSys->MoonDesc[2].data_index = CYANIC_WORLD;
+			solarSys->MoonDesc[2].orb_speed = FULL_CIRCLE / 7.16;
 					/* Ganymede */
 			solarSys->MoonDesc[3].data_index = PELLUCID_WORLD;
+			solarSys->MoonDesc[3].orb_speed = FULL_CIRCLE / 16.69;
 					/* Callisto */
 			break;
 		case 5: /* moons of SATURN */
 			solarSys->MoonDesc[0].data_index = ALKALI_WORLD;
+			solarSys->MoonDesc[0].radius = MIN_MOON_RADIUS
+					+ (MAX_MOONS - 1) * MOON_DELTA;
+			solarSys->MoonDesc[0].orb_speed = FULL_CIRCLE / 15.95;
 					/* Titan */
 			break;
 		case 7: /* moons of NEPTUNE */
 			solarSys->MoonDesc[0].data_index = VINYLOGOUS_WORLD;
+			solarSys->MoonDesc[0].orb_speed = FULL_CIRCLE / -5.88;
 					/* Triton */
 			break;
 	}
@@ -259,6 +277,9 @@ GenerateSol_generateOrbital (SOLARSYS_ST
 	if (matchWorld (solarSys, world, 2, 0))
 	{
 		/* Starbase */
+		// JMS: If starbase is encountered, the chasing ships turn away
+		NotifyOthers (HUMAN_SHIP, IPNL_ALL_CLEAR);
+		
 		PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
 		ReinitQueue (&GLOBAL (ip_group_q));
 		assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
@@ -380,17 +401,7 @@ GenerateSol_generateOrbital (SOLARSYS_ST
 						EARTH_RADIUS * 2999L / 100;
 				break;
 			case 8: /* PLUTO */
-				if (!GET_GAME_STATE (FOUND_PLUTO_SPATHI))
-				{
-					LoadStdLanderFont (&solarSys->SysInfo.PlanetInfo);
-					solarSys->PlanetSideFrame[1] =
-							CaptureDrawable (
-							LoadGraphic (SPAPLUTO_MASK_PMAP_ANIM));
-					solarSys->SysInfo.PlanetInfo.DiscoveryString =
-							CaptureStringTable (
-							LoadStringTable (SPAPLUTO_STRTAB));
-				}
-
+				// JMS: Removed Fwiffo stuff.
 				solarSys->SysInfo.PlanetInfo.AtmoDensity = 0;
 				solarSys->SysInfo.PlanetInfo.PlanetDensity = 33;
 				solarSys->SysInfo.PlanetInfo.PlanetRadius = 18;
@@ -407,8 +418,18 @@ GenerateSol_generateOrbital (SOLARSYS_ST
 		solarSys->SysInfo.PlanetInfo.SurfaceGravity =
 				CalcGravity (solarSys->SysInfo.PlanetInfo.PlanetDensity,
 				solarSys->SysInfo.PlanetInfo.PlanetRadius);
-		LoadPlanet (planetNr == 2 ?
-				CaptureDrawable (LoadGraphic (EARTH_MASK_ANIM)) : NULL);
+		switch (planetNr)
+			{
+			case 2: /* EARTH */
+				LoadPlanet (CaptureDrawable (LoadGraphic (EARTH_MASK_ANIM)));
+				break;
+			case 3: /* MARS */
+				LoadPlanet (CaptureDrawable (LoadGraphic (MARS_MASK_ANIM)));
+				break;
+			default:
+				LoadPlanet (NULL);
+				break;
+			}
 	}
 	else
 	{
@@ -424,17 +445,6 @@ GenerateSol_generateOrbital (SOLARSYS_ST
 				solarSys->SysInfo.PlanetInfo.ScanSeed[BIOLOGICAL_SCAN] =
 						rand_val;
 
-				if (!GET_GAME_STATE (MOONBASE_DESTROYED))
-				{
-					LoadStdLanderFont (&solarSys->SysInfo.PlanetInfo);
-					solarSys->PlanetSideFrame[1] =
-							CaptureDrawable (
-							LoadGraphic (MOONBASE_MASK_PMAP_ANIM));
-					solarSys->SysInfo.PlanetInfo.DiscoveryString =
-							CaptureStringTable (
-							LoadStringTable (MOONBASE_STRTAB));
-				}
-
 				solarSys->SysInfo.PlanetInfo.PlanetDensity = 60;
 				solarSys->SysInfo.PlanetInfo.PlanetRadius = 25;
 				solarSys->SysInfo.PlanetInfo.AxialTilt = 0;
@@ -513,103 +523,59 @@ GenerateSol_generateOrbital (SOLARSYS_ST
 	return true;
 }
 
-static COUNT
-GenerateSol_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
-{
-	if (matchWorld (solarSys, world, 8, MATCH_PLANET))
-	{
-		/* Pluto */
-		// This check is needed because the retrieval bit is not set for
-		// this node to keep it on the surface while the lander is taking off
-		if (GET_GAME_STATE (FOUND_PLUTO_SPATHI))
-		{	// already picked up
-			return 0;
-		}
-
-		solarSys->SysInfo.PlanetInfo.CurPt.x = 20;
-		solarSys->SysInfo.PlanetInfo.CurPt.y = MAP_HEIGHT - 8;
-
-		return 1; // only matters when count is requested
-	}
-	
-	if (matchWorld (solarSys, world, 2, 1))
-	{
-		/* Earth Moon */
-		// This check is redundant since the retrieval bit will keep the
-		// node from showing up again
-		if (GET_GAME_STATE (MOONBASE_DESTROYED))
-		{	// already picked up
-			return 0;
-		}
-
-		solarSys->SysInfo.PlanetInfo.CurPt.x = MAP_WIDTH * 3 / 4;
-		solarSys->SysInfo.PlanetInfo.CurPt.y = MAP_HEIGHT * 1 / 4;
-
-		return 1; // only matters when count is requested
-	}
-
-	(void) whichNode;
-	return 0;
-}
 
 static bool
-GenerateSol_pickupEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateSol_generateLife (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
+		COUNT *whichNode)
 {
-	if (matchWorld (solarSys, world, 8, MATCH_PLANET))
-	{	// Pluto
-		assert (!GET_GAME_STATE (FOUND_PLUTO_SPATHI) && whichNode == 0);
-	
-		// Ran into Fwiffo on Pluto
-		#define FWIFFO_FRAGS  8
-		if (!KillLanderCrewSeq (FWIFFO_FRAGS, ONE_SECOND / 20))
-			return false; // lander probably died
-
-		SET_GAME_STATE (FOUND_PLUTO_SPATHI, 1);
-
-		GenerateDefault_landerReport (solarSys);
-		SetLanderTakeoff ();
-
-		// Do not remove the node from the surface while the lander is
-		// taking off. FOUND_PLUTO_SPATHI bit will keep the node from
-		// showing up on subsequent visits.
-		return false;
+	if (!matchWorld (solarSys, world, 2, MATCH_PLANET))
+	{
+		*whichNode = 0;
 	}
-	
-	if (matchWorld (solarSys, world, 2, 1))
-	{	// Earth Moon
-		assert (!GET_GAME_STATE (MOONBASE_DESTROYED) && whichNode == 0);
+	else // Earth is thriving with life but can't be landed on anyways
+		// Actually they're tanks :)
+	{
+		COUNT i;
+		COUNT nodeI;
+		DWORD old_rand;
+		DWORD rand_val;
 
-		GenerateDefault_landerReport (solarSys);
-		SetLanderTakeoff ();
+		old_rand = TFB_SeedRandom (
+				solarSys->SysInfo.PlanetInfo.ScanSeed[BIOLOGICAL_SCAN]);
 
-		SET_GAME_STATE (MOONBASE_DESTROYED, 1);
-		SET_GAME_STATE (MOONBASE_ON_SHIP, 1);
+		nodeI = 0;
+		i = 0;
+		do
+		{
+			rand_val = TFB_Random ();
+			solarSys->SysInfo.PlanetInfo.CurPt.x =
+					(LOBYTE (LOWORD (rand_val)) % (MAP_WIDTH - (8 << 1))) + 8;
+			solarSys->SysInfo.PlanetInfo.CurPt.y =
+					(HIBYTE (LOWORD (rand_val)) % (MAP_HEIGHT - (8 << 1))) + 8;
+			solarSys->SysInfo.PlanetInfo.CurType = NUM_CREATURE_TYPES + 1;
+			if (nodeI >= *whichNode
+					&& !(solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[BIOLOGICAL_SCAN]
+					& (1L << i)))
+				break;
+			++nodeI;
+		} while (++i < 30);
+		*whichNode = nodeI;
 
-		return true; // picked up
+		TFB_SeedRandom (old_rand);
 	}
 
-	(void) whichNode;
-	return false;
+	return true;
 }
 
-static COUNT
-GenerateSol_generateLife (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+/***
+    static bool
+GenerateSol_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
+		COUNT *whichNode)
 {
-	if (matchWorld (solarSys, world, 2, 1))
-	{
-		/* Earth Moon */
-		GenerateRandomNodes (&solarSys->SysInfo, BIOLOGICAL_SCAN, 10,
-				NUM_CREATURE_TYPES + 1, &whichNode);
-		return whichNode;
-	}
-
-	return 0;
+	*whichNode = 0;
+	return true;
 }
 
-
 static int
 init_probe (void)
 {
@@ -623,8 +589,8 @@ init_probe (void)
 
 		GroupPtr = LockIpGroup (&GLOBAL (ip_group_q), hGroup);
 		GroupPtr->task = IN_ORBIT;
-		GroupPtr->sys_loc = 2 + 1; /* orbitting earth */
-		GroupPtr->dest_loc = 2 + 1; /* orbitting earth */
+		GroupPtr->sys_loc = 2 + 1; // orbitting earth
+		GroupPtr->dest_loc = 2 + 1; // orbitting earth
 		GroupPtr->loc.x = 0;
 		GroupPtr->loc.y = 0;
 		GroupPtr->group_counter = 0;
@@ -662,4 +628,4 @@ check_probe (void)
 	}
 	UnlockIpGroup (&GLOBAL (ip_group_q), hGroup);
 }
-
+***/
diff -ruNp src.orig/uqm/planets/generate/genspa.c src/uqm/planets/generate/genspa.c
--- src.orig/uqm/planets/generate/genspa.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/genspa.c	2017-11-01 15:31:03 -0700
@@ -18,9 +18,7 @@
 
 #include "genall.h"
 #include "../lifeform.h"
-#include "../lander.h"
 #include "../planets.h"
-#include "../scan.h"
 #include "../../build.h"
 #include "../../comm.h"
 #include "../../globdata.h"
@@ -35,14 +33,6 @@ static bool GenerateSpathi_generateMoons
 		PLANET_DESC *planet);
 static bool GenerateSpathi_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateSpathi_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static COUNT GenerateSpathi_generateLife (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static bool GenerateSpathi_pickupEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static bool GenerateSpathi_pickupLife (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
 
 
 const GenerateFunctions generateSpathiFunctions = {
@@ -54,11 +44,8 @@ const GenerateFunctions generateSpathiFu
 	/* .generateName     = */ GenerateDefault_generateName,
 	/* .generateOrbital  = */ GenerateSpathi_generateOrbital,
 	/* .generateMinerals = */ GenerateDefault_generateMinerals,
-	/* .generateEnergy   = */ GenerateSpathi_generateEnergy,
-	/* .generateLife     = */ GenerateSpathi_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GenerateSpathi_pickupEnergy,
-	/* .pickupLife       = */ GenerateSpathi_pickupLife,
+	/* .generateEnergy   = */ GenerateDefault_generateEnergy,
+	/* .generateLife     = */ GenerateDefault_generateLife,
 };
 
 
@@ -77,10 +64,9 @@ GenerateSpathi_generatePlanets (SOLARSYS
 	angle = ARCTAN (pMinPlanet->location.x, pMinPlanet->location.y);
 	pMinPlanet->location.x = COSINE (angle, pMinPlanet->radius);
 	pMinPlanet->location.y = SINE (angle, pMinPlanet->radius);
-	pMinPlanet->data_index = WATER_WORLD;
-	if (GET_GAME_STATE (SPATHI_SHIELDED_SELVES))
-		pMinPlanet->data_index |= PLANET_SHIELDED;
-	pMinPlanet->NumPlanets = 1;
+	pMinPlanet->data_index = WATER_WORLD | PLANET_SHIELDED;
+	pMinPlanet->NumPlanets = 2;
+	ComputeSpeed(pMinPlanet, FALSE, 1);
 
 	return true;
 }
@@ -94,19 +80,27 @@ GenerateSpathi_generateMoons (SOLARSYS_S
 
 	if (matchWorld (solarSys, planet, 0, MATCH_PLANET))
 	{
-#ifdef NOTYET
-		utf8StringCopy (GLOBAL_SIS (PlanetName),
-				sizeof (GLOBAL_SIS (PlanetName)),
-				"Spathiwa");
-#endif /* NOTYET */
+
+/*Spathi moon*/
+
 
 		solarSys->MoonDesc[0].data_index = PELLUCID_WORLD;
 		solarSys->MoonDesc[0].radius = MIN_MOON_RADIUS + MOON_DELTA;
-		angle = NORMALIZE_ANGLE (LOWORD (TFB_Random ()));
+		angle = 58;
 		solarSys->MoonDesc[0].location.x =
 				COSINE (angle, solarSys->MoonDesc[0].radius);
 		solarSys->MoonDesc[0].location.y =
 				SINE (angle, solarSys->MoonDesc[0].radius);
+		ComputeSpeed(&solarSys->MoonDesc[0], TRUE, 1);
+		/*Spathi Starbase*/
+		pSolarSysState->MoonDesc[1].data_index = (BYTE)~0;
+		pSolarSysState->MoonDesc[1].radius = MIN_MOON_RADIUS;
+		angle = HALF_CIRCLE + QUADRANT;
+		pSolarSysState->MoonDesc[1].location.x =
+			COSINE (angle, pSolarSysState->MoonDesc[1].radius);
+		pSolarSysState->MoonDesc[1].location.y =
+			SINE (angle, pSolarSysState->MoonDesc[1].radius);
+		ComputeSpeed(&solarSys->MoonDesc[1], TRUE, 1);
 	}
 
 	return true;
@@ -115,170 +109,14 @@ GenerateSpathi_generateMoons (SOLARSYS_S
 static bool
 GenerateSpathi_generateOrbital (SOLARSYS_STATE *solarSys, PLANET_DESC *world)
 {
-	DWORD rand_val;
-	COUNT i;
-
-	if (matchWorld (solarSys, world, 0, 0))
-	{
-		/* Spathiwa's moon */
-		if (!GET_GAME_STATE (SPATHI_SHIELDED_SELVES)
-				&& ActivateStarShip (SPATHI_SHIP, SPHERE_TRACKING))
-		{
-			NotifyOthers (SPATHI_SHIP, IPNL_ALL_CLEAR);
-			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
-			ReinitQueue (&GLOBAL (ip_group_q));
-			assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
-
-			CloneShipFragment (SPATHI_SHIP, &GLOBAL (npc_built_ship_q),
-					INFINITE_FLEET);
-
-			SET_GAME_STATE (GLOBAL_FLAGS_AND_DATA, 1 << 7);
-			GLOBAL (CurrentActivity) |= START_INTERPLANETARY;
-			InitCommunication (SPATHI_CONVERSATION);
-
-			if (!(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD)))
-			{
-				GLOBAL (CurrentActivity) &= ~START_INTERPLANETARY;
-				ReinitQueue (&GLOBAL (npc_built_ship_q));
-				GetGroupInfo (GROUPS_RANDOM, GROUP_LOAD_IP);
-			}
-			return true;
-		}
-		rand_val = DoPlanetaryAnalysis (&solarSys->SysInfo, world);
-
-		solarSys->SysInfo.PlanetInfo.ScanSeed[BIOLOGICAL_SCAN] = rand_val;
-		i = (COUNT)~0;
-		rand_val = GenerateLifeForms (&solarSys->SysInfo, &i);
-
-		solarSys->SysInfo.PlanetInfo.ScanSeed[MINERAL_SCAN] = rand_val;
-		i = (COUNT)~0;
-		GenerateMineralDeposits (&solarSys->SysInfo, &i);
-
-		solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN] = rand_val;
-
-		solarSys->SysInfo.PlanetInfo.Weather = 0;
-		solarSys->SysInfo.PlanetInfo.Tectonics = 0;
-		solarSys->SysInfo.PlanetInfo.SurfaceTemperature = 28;
-		if (!GET_GAME_STATE (UMGAH_BROADCASTERS))
-		{
-			LoadStdLanderFont (&solarSys->SysInfo.PlanetInfo);
-			solarSys->PlanetSideFrame[1] =
-					CaptureDrawable (LoadGraphic (UMGAH_BCS_MASK_PMAP_ANIM));
-			solarSys->SysInfo.PlanetInfo.DiscoveryString =
-					CaptureStringTable (LoadStringTable (UMGAH_BCS_STRTAB));
-			if (!GET_GAME_STATE (SPATHI_SHIELDED_SELVES))
-			{	// The first report talks extensively about Spathi
-				// slave-shielding selves. If they never did so, the report
-				// makes no sense, so use an alternate.
-				solarSys->SysInfo.PlanetInfo.DiscoveryString =	
-						SetAbsStringTableIndex (
-						solarSys->SysInfo.PlanetInfo.DiscoveryString, 1);
-			}
-		}
-		LoadPlanet (NULL);
-		return true;
-	}
-	else if (matchWorld (solarSys, world, 0, MATCH_PLANET))
+	if (matchWorld (solarSys, world, 0, 1))
 	{
-		/* visiting Spathiwa */
-		rand_val = DoPlanetaryAnalysis (&solarSys->SysInfo, world);
-
-		solarSys->SysInfo.PlanetInfo.ScanSeed[MINERAL_SCAN] = rand_val;
-		i = (COUNT)~0;
-		rand_val = GenerateMineralDeposits (&solarSys->SysInfo, &i);
-
-		solarSys->SysInfo.PlanetInfo.ScanSeed[BIOLOGICAL_SCAN] = rand_val;
-
-		solarSys->SysInfo.PlanetInfo.PlanetRadius = 120;
-		solarSys->SysInfo.PlanetInfo.SurfaceGravity =
-				CalcGravity (solarSys->SysInfo.PlanetInfo.PlanetDensity,
-				solarSys->SysInfo.PlanetInfo.PlanetRadius);
-		solarSys->SysInfo.PlanetInfo.Weather = 0;
-		solarSys->SysInfo.PlanetInfo.Tectonics = 0;
-		solarSys->SysInfo.PlanetInfo.SurfaceTemperature = 31;
+		InitCommunication (SPATHI_CONVERSATION);		/* Spathiwa's moon */
 
-		LoadPlanet (NULL);
 		return true;
 	}
-	
+
 	GenerateDefault_generateOrbital (solarSys, world);
 
 	return true;
 }
-
-static COUNT
-GenerateSpathi_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
-{
-	if (matchWorld (solarSys, world, 0, 0))
-	{
-		// This check is redundant since the retrieval bit will keep the
-		// node from showing up again
-		if (GET_GAME_STATE (UMGAH_BROADCASTERS))
-		{	// already picked up
-			return 0;
-		}
-
-		return GenerateDefault_generateArtifact (solarSys, whichNode);
-	}
-
-	return 0;
-}
-
-static bool
-GenerateSpathi_pickupEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
-{
-	if (matchWorld (solarSys, world, 0, 0))
-	{
-		assert (!GET_GAME_STATE (UMGAH_BROADCASTERS) && whichNode == 0);
-
-		GenerateDefault_landerReport (solarSys);
-		SetLanderTakeoff ();
-
-		SET_GAME_STATE (UMGAH_BROADCASTERS, 1);
-		SET_GAME_STATE (UMGAH_BROADCASTERS_ON_SHIP, 1);
-
-		return true; // picked up
-	}
-
-	(void) whichNode;
-	return false;
-}
-
-static COUNT
-GenerateSpathi_generateLife (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
-{
-	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
-	{
-		#define NUM_EVIL_ONES  32
-		GenerateRandomNodes (&solarSys->SysInfo, BIOLOGICAL_SCAN, NUM_EVIL_ONES,
-				NUM_CREATURE_TYPES, &whichNode);
-		return whichNode;
-	}
-
-	return 0;
-}
-
-static bool
-GenerateSpathi_pickupLife (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
-{
-	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
-	{
-		assert (!GET_GAME_STATE (SPATHI_CREATURES_ELIMINATED) &&
-				!GET_GAME_STATE (SPATHI_SHIELDED_SELVES));
-
-		SET_GAME_STATE (SPATHI_CREATURES_EXAMINED, 1);
-		if (countNodesRetrieved (&solarSys->SysInfo.PlanetInfo, BIOLOGICAL_SCAN)
-				+ 1 == NUM_EVIL_ONES)
-		{	// last creature picked up
-			SET_GAME_STATE (SPATHI_CREATURES_ELIMINATED, 1);
-		}
-
-		return true; // picked up
-	}
-
-	return GenerateDefault_pickupLife (solarSys, world, whichNode);
-}
diff -ruNp src.orig/uqm/planets/generate/gensup.c src/uqm/planets/generate/gensup.c
--- src.orig/uqm/planets/generate/gensup.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/gensup.c	2017-11-01 15:31:03 -0700
@@ -31,10 +31,8 @@
 static bool GenerateSupox_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateSupox_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateSupox_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static bool GenerateSupox_pickupEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static bool GenerateSupox_generateEnergy (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
 
 
 const GenerateFunctions generateSupoxFunctions = {
@@ -48,9 +46,6 @@ const GenerateFunctions generateSupoxFun
 	/* .generateMinerals = */ GenerateDefault_generateMinerals,
 	/* .generateEnergy   = */ GenerateSupox_generateEnergy,
 	/* .generateLife     = */ GenerateDefault_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GenerateSupox_pickupEnergy,
-	/* .pickupLife       = */ GenerateDefault_pickupLife,
 };
 
 
@@ -70,6 +65,7 @@ GenerateSupox_generatePlanets (SOLARSYS_
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
@@ -107,9 +103,9 @@ GenerateSupox_generateOrbital (SOLARSYS_
 			solarSys->PlanetSideFrame[1] =
 					CaptureDrawable (LoadGraphic (RUINS_MASK_PMAP_ANIM));
 			solarSys->SysInfo.PlanetInfo.DiscoveryString =
-					CaptureStringTable (LoadStringTable (SUPOX_RUINS_STRTAB));
-			if (GET_GAME_STATE (ULTRON_CONDITION))
-			{	// Already picked up the Ultron, skip the report
+					CaptureStringTable (LoadStringTable (RUINS_STRTAB));
+			if (!GET_GAME_STATE (ULTRON_CONDITION))
+			{
 				solarSys->SysInfo.PlanetInfo.DiscoveryString =
 						SetAbsStringTableIndex (
 						solarSys->SysInfo.PlanetInfo.DiscoveryString, 1);
@@ -123,37 +119,59 @@ GenerateSupox_generateOrbital (SOLARSYS_
 }
 
 static bool
-GenerateSupox_pickupEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateSupox_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
+		COUNT *whichNode)
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		GenerateDefault_landerReportCycle (solarSys);
-
-		// The artifact can be picked up from any ruin
-		if (!GET_GAME_STATE (ULTRON_CONDITION))
-		{	// Just picked up the Ultron from a ruin
-			SetLanderTakeoff ();
-
-			SET_GAME_STATE (ULTRON_CONDITION, 1);
-		}
+		COUNT i;
+		COUNT nodeI;
+		DWORD rand_val;
+		DWORD old_rand;
+
+		old_rand = TFB_SeedRandom (
+				solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN]);
+
+		nodeI = 0;
+		i = 0;
+		do
+		{
+			rand_val = TFB_Random ();
+			solarSys->SysInfo.PlanetInfo.CurPt.x =
+					(LOBYTE (LOWORD (rand_val)) % (MAP_WIDTH - (8 << 1))) + 8;
+			solarSys->SysInfo.PlanetInfo.CurPt.y =
+					(HIBYTE (LOWORD (rand_val)) % (MAP_HEIGHT - (8 << 1))) + 8;
+			if (!GET_GAME_STATE (ULTRON_CONDITION))
+				solarSys->SysInfo.PlanetInfo.CurType = 0;
+			else
+				solarSys->SysInfo.PlanetInfo.CurType = 1;
+			solarSys->SysInfo.PlanetInfo.CurDensity = 0;
+			if (solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+					& (1L << i))
+			{
+				solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+						&= ~(1L << i);
 
-		return false; // do not remove the node
-	}
+				if (!GET_GAME_STATE (ULTRON_CONDITION))
+				{
+					SetLanderTakeoff ();
 
-	(void) whichNode;
-	return false;
-}
+					SET_GAME_STATE (ULTRON_CONDITION, 1);
+				}
+			}
+			if (nodeI >= *whichNode
+					&& !(solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+					& (1L << i)))
+				break;
+			++nodeI;
+		} while (++i < 16);
+		*whichNode = nodeI;
 
-static COUNT
-GenerateSupox_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
-{
-	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
-	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
+		TFB_SeedRandom (old_rand);
+		return true;
 	}
 
-	return 0;
+	*whichNode = 0;
+	return true;
 }
 
diff -ruNp src.orig/uqm/planets/generate/gensyr.c src/uqm/planets/generate/gensyr.c
--- src.orig/uqm/planets/generate/gensyr.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/gensyr.c	2017-11-01 15:31:03 -0700
@@ -16,9 +16,17 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: -Syreen home planet is now restricted from landing
+//			 -Syreen starbase fully operational
+
+#include "../../build.h"
 #include "genall.h"
 #include "../planets.h"
 #include "../../comm.h"
+#include "../../globdata.h"
+#include "../../nameref.h"
+#include "../../setup.h"
+#include "../../state.h"
 
 static bool GenerateSyreen_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateSyreen_generateMoons (SOLARSYS_STATE *solarSys,
@@ -38,9 +46,6 @@ const GenerateFunctions generateSyreenFu
 	/* .generateMinerals = */ GenerateDefault_generateMinerals,
 	/* .generateEnergy   = */ GenerateDefault_generateEnergy,
 	/* .generateLife     = */ GenerateDefault_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GenerateDefault_pickupEnergy,
-	/* .pickupLife       = */ GenerateDefault_pickupLife,
 };
 
 
@@ -49,7 +54,8 @@ GenerateSyreen_generatePlanets (SOLARSYS
 {
 	GenerateDefault_generatePlanets (solarSys);
 
-	solarSys->PlanetDesc[0].data_index = WATER_WORLD | PLANET_SHIELDED;
+	solarSys->PlanetDesc[0].data_index = WATER_WORLD;
+	solarSys->PlanetDesc[0].flags = PLANET_RESTRICTED; // JMS: Can't land on syreen turf
 	solarSys->PlanetDesc[0].NumPlanets = 1;
 
 	return true;
@@ -68,6 +74,7 @@ GenerateSyreen_generateMoons (SOLARSYS_S
 				COSINE (QUADRANT, solarSys->MoonDesc[0].radius);
 		solarSys->MoonDesc[0].location.y =
 				SINE (QUADRANT, solarSys->MoonDesc[0].radius);
+		ComputeSpeed(&solarSys->MoonDesc[0], TRUE, 1);
 	}
 
 	return true;
@@ -79,19 +86,29 @@ GenerateSyreen_generateOrbital (SOLARSYS
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
 		/* Syreen home planet */
-		GenerateDefault_generateOrbital (solarSys, world);
-
-		solarSys->SysInfo.PlanetInfo.SurfaceTemperature = 19;
-		solarSys->SysInfo.PlanetInfo.Tectonics = 0;
-		solarSys->SysInfo.PlanetInfo.Weather = 0;
-		solarSys->SysInfo.PlanetInfo.AtmoDensity = EARTH_ATMOSPHERE * 9 / 10;
+		InitCommunication (SYREENHOME_CONVERSATION);
 		return true;
 	}
 
 	if (matchWorld (solarSys, world, 0, 0))
 	{
 		/* Starbase */
-		InitCommunication (SYREEN_CONVERSATION);
+		// JMS: The Syreen have a fleet in starbase
+		CloneShipFragment (SYREEN_SHIP, &GLOBAL (npc_built_ship_q), INFINITE_FLEET);
+		
+		// JMS: This code summons starbase subroutine. (The global_flags_and_data == ~0
+		// is checked in Starcon2Main function in starcon.c)
+		GLOBAL (CurrentActivity) |= START_ENCOUNTER;
+		SET_GAME_STATE (GLOBAL_FLAGS_AND_DATA, (BYTE)~0);
+				
+		// JMS: Necessary to empty the NPC ship queue after visit.
+		// Otherwise next encounter with a ship crashes the game.
+		if (!(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD)))
+		{
+			GLOBAL (CurrentActivity) &= ~START_INTERPLANETARY;
+			ReinitQueue (&GLOBAL (npc_built_ship_q));
+			GetGroupInfo (GROUPS_RANDOM, GROUP_LOAD_IP);
+		}
 		return true;
 	}
 
diff -ruNp src.orig/uqm/planets/generate/genthrad.c src/uqm/planets/generate/genthrad.c
--- src.orig/uqm/planets/generate/genthrad.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/genthrad.c	2017-11-01 15:31:03 -0700
@@ -17,7 +17,6 @@
  */
 
 #include "genall.h"
-#include "../lander.h"
 #include "../planets.h"
 #include "../../build.h"
 #include "../../comm.h"
@@ -33,10 +32,8 @@
 static bool GenerateThraddash_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateThraddash_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateThraddash_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static bool GenerateThraddash_pickupEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static bool GenerateThraddash_generateEnergy (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
 
 
 const GenerateFunctions generateThraddashFunctions = {
@@ -50,9 +47,6 @@ const GenerateFunctions generateThraddas
 	/* .generateMinerals = */ GenerateDefault_generateMinerals,
 	/* .generateEnergy   = */ GenerateThraddash_generateEnergy,
 	/* .generateLife     = */ GenerateDefault_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GenerateThraddash_pickupEnergy,
-	/* .pickupLife       = */ GenerateDefault_pickupLife,
 };
 
 
@@ -73,6 +67,7 @@ GenerateThraddash_generatePlanets (SOLAR
 				COSINE (angle, solarSys->PlanetDesc[0].radius);
 		solarSys->PlanetDesc[0].location.y =
 				SINE (angle, solarSys->PlanetDesc[0].radius);
+		ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 	}
 	else  /* CurStarDescPtr->Index == THRADD_DEFINED */
 	{
@@ -85,6 +80,7 @@ GenerateThraddash_generatePlanets (SOLAR
 				COSINE (angle, solarSys->PlanetDesc[0].radius);
 		solarSys->PlanetDesc[0].location.y =
 				SINE (angle, solarSys->PlanetDesc[0].radius);
+		ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 	}
 	return true;
 }
@@ -159,60 +155,80 @@ GenerateThraddash_generateOrbital (SOLAR
 	return true;
 }
 
-static COUNT
+static bool
 GenerateThraddash_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode)
+		PLANET_DESC *world, COUNT *whichNode)
 {
-	if (CurStarDescPtr->Index == THRADD_DEFINED
-			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
-	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
-	}
-
-	if (CurStarDescPtr->Index == AQUA_HELIX_DEFINED
-			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
+	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		// This check is redundant since the retrieval bit will keep the
-		// node from showing up again
-		if (GET_GAME_STATE (AQUA_HELIX))
-		{	// already picked up
-			return 0;
-		}
+		DWORD rand_val;
+		DWORD old_rand;
 
-		return GenerateDefault_generateArtifact (solarSys, whichNode);
-	}
+		if (CurStarDescPtr->Index != AQUA_HELIX_DEFINED)
+		{
+			COUNT i;
+			COUNT nodeI;
 
-	return 0;
-}
+			old_rand = TFB_SeedRandom (
+					solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN]);
 
-static bool
-GenerateThraddash_pickupEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
-{
-	if (CurStarDescPtr->Index == THRADD_DEFINED
-			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
-	{
-		// Standard ruins report
-		GenerateDefault_landerReportCycle (solarSys);
-		return false;
-	}
+			nodeI = 0;
+			i = 0;
+			do
+			{
+				rand_val = TFB_Random ();
+				solarSys->SysInfo.PlanetInfo.CurPt.x =
+						(LOBYTE (LOWORD (rand_val)) % (MAP_WIDTH - (8 << 1))) + 8;
+				solarSys->SysInfo.PlanetInfo.CurPt.y =
+						(HIBYTE (LOWORD (rand_val)) % (MAP_HEIGHT - (8 << 1))) + 8;
+				solarSys->SysInfo.PlanetInfo.CurType = 1;
+				solarSys->SysInfo.PlanetInfo.CurDensity = 0;
+				if (nodeI >= *whichNode
+						&& !(solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+						& (1L << i)))
+					break;
+				++nodeI;
+			} while (++i < 16);
+			*whichNode = nodeI;
 
-	if (CurStarDescPtr->Index == AQUA_HELIX_DEFINED
-			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
-	{
-		assert (!GET_GAME_STATE (AQUA_HELIX) && whichNode == 0);
+			TFB_SeedRandom (old_rand);
+			return true;
+		}
 
-		GenerateDefault_landerReport (solarSys);
-		SetLanderTakeoff ();
+		if (!GET_GAME_STATE (AQUA_HELIX))
+		{
+			old_rand = TFB_SeedRandom (
+					solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN]);
 
-		SET_GAME_STATE (HELIX_VISITS, 0);
-		SET_GAME_STATE (AQUA_HELIX, 1);
-		SET_GAME_STATE (AQUA_HELIX_ON_SHIP, 1);
-		SET_GAME_STATE (HELIX_UNPROTECTED, 1);
+			rand_val = TFB_Random ();
+			solarSys->SysInfo.PlanetInfo.CurPt.x =
+					(LOBYTE (LOWORD (rand_val)) % (MAP_WIDTH - (8 << 1))) + 8;
+			solarSys->SysInfo.PlanetInfo.CurPt.y =
+					(HIBYTE (LOWORD (rand_val)) % (MAP_HEIGHT - (8 << 1))) + 8;
+			solarSys->SysInfo.PlanetInfo.CurDensity = 0;
+			solarSys->SysInfo.PlanetInfo.CurType = 0;
+			if (!(solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+					& (1L << 0)) && *whichNode == (COUNT)~0)
+				*whichNode = 1;
+			else
+			{
+				*whichNode = 0;
+				if (solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+						& (1L << 0))
+				{
+					SET_GAME_STATE (HELIX_VISITS, 0);
+					SET_GAME_STATE (AQUA_HELIX, 1);
+					SET_GAME_STATE (AQUA_HELIX_ON_SHIP, 1);
+					SET_GAME_STATE (HELIX_UNPROTECTED, 1);
+				}
+			}
 
-		return true; // picked up
+			TFB_SeedRandom (old_rand);
+			return true;
+		}
 	}
 
-	(void) whichNode;
-	return false;
+	*whichNode = 0;
+	return true;
 }
+
diff -ruNp src.orig/uqm/planets/generate/gentrap.c src/uqm/planets/generate/gentrap.c
--- src.orig/uqm/planets/generate/gentrap.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/gentrap.c	2017-11-01 15:31:03 -0700
@@ -36,9 +36,6 @@ const GenerateFunctions generateTrapFunc
 	/* .generateMinerals = */ GenerateDefault_generateMinerals,
 	/* .generateEnergy   = */ GenerateDefault_generateEnergy,
 	/* .generateLife     = */ GenerateDefault_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GenerateDefault_pickupEnergy,
-	/* .pickupLife       = */ GenerateDefault_pickupLife,
 };
 
 
@@ -58,6 +55,7 @@ GenerateTrap_generatePlanets (SOLARSYS_S
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp src.orig/uqm/planets/generate/genutw.c src/uqm/planets/generate/genutw.c
--- src.orig/uqm/planets/generate/genutw.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/genutw.c	2017-11-01 15:31:03 -0700
@@ -17,7 +17,6 @@
  */
 
 #include "genall.h"
-#include "../lander.h"
 #include "../planets.h"
 #include "../../build.h"
 #include "../../comm.h"
@@ -34,10 +33,8 @@ static bool GenerateUtwig_initNpcs (SOLA
 static bool GenerateUtwig_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateUtwig_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateUtwig_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static bool GenerateUtwig_pickupEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static bool GenerateUtwig_generateEnergy (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
 
 
 const GenerateFunctions generateUtwigFunctions = {
@@ -51,9 +48,6 @@ const GenerateFunctions generateUtwigFun
 	/* .generateMinerals = */ GenerateDefault_generateMinerals,
 	/* .generateEnergy   = */ GenerateUtwig_generateEnergy,
 	/* .generateLife     = */ GenerateDefault_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GenerateUtwig_pickupEnergy,
-	/* .pickupLife       = */ GenerateDefault_pickupLife,
 };
 
 
@@ -92,6 +86,7 @@ GenerateUtwig_generatePlanets (SOLARSYS_
 				COSINE (angle, solarSys->PlanetDesc[0].radius);
 		solarSys->PlanetDesc[0].location.y =
 				SINE (angle, solarSys->PlanetDesc[0].radius);
+		ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 	}
 
 	return true;
@@ -210,61 +205,82 @@ GenerateUtwig_generateOrbital (SOLARSYS_
 	return true;
 }
 
-static COUNT
+static bool
 GenerateUtwig_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+		COUNT *whichNode)
 {
+	DWORD rand_val;
+	DWORD old_rand;
+
 	if (CurStarDescPtr->Index == UTWIG_DEFINED
 			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
-	}
+		COUNT i;
+		COUNT nodeI;
 
-	if (CurStarDescPtr->Index == BOMB_DEFINED
-			&& matchWorld (solarSys, world, 5, 1))
-	{
-		// This check is redundant since the retrieval bit will keep the
-		// node from showing up again
-		if (GET_GAME_STATE (UTWIG_BOMB))
-		{	// already picked up
-			return 0;
-		}
+		old_rand = TFB_SeedRandom (
+				solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN]);
 
-		return GenerateDefault_generateArtifact (solarSys, whichNode);
-	}
-
-	return 0;
-}
+		nodeI = 0;
+		i = 0;
+		do
+		{
+			rand_val = TFB_Random ();
+			solarSys->SysInfo.PlanetInfo.CurPt.x =
+					(LOBYTE (LOWORD (rand_val)) % (MAP_WIDTH - (8 << 1))) + 8;
+			solarSys->SysInfo.PlanetInfo.CurPt.y =
+					(HIBYTE (LOWORD (rand_val)) % (MAP_HEIGHT - (8 << 1))) + 8;
+			solarSys->SysInfo.PlanetInfo.CurType = 1;
+			solarSys->SysInfo.PlanetInfo.CurDensity = 0;
+			if (nodeI >= *whichNode
+					&& !(solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+					& (1L << i)))
+				break;
+			++nodeI;
+		} while (++i < 16);
+		*whichNode = nodeI;
 
-static bool
-GenerateUtwig_pickupEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
-{
-	if (CurStarDescPtr->Index == UTWIG_DEFINED
-			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
-	{
-		// Standard ruins report
-		GenerateDefault_landerReportCycle (solarSys);
-		return false;
+		TFB_SeedRandom (old_rand);
+		return true;
 	}
 
 	if (CurStarDescPtr->Index == BOMB_DEFINED
-			&& matchWorld (solarSys, world, 5, 1))
+			&& matchWorld (solarSys, world, 5, 1)
+			&& !GET_GAME_STATE (UTWIG_BOMB))
 	{
-		assert (!GET_GAME_STATE (UTWIG_BOMB) && whichNode == 0);
-
-		GenerateDefault_landerReport (solarSys);
-		SetLanderTakeoff ();
+		old_rand = TFB_SeedRandom (
+				solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN]);
 
-		SET_GAME_STATE (UTWIG_BOMB, 1);
-		SET_GAME_STATE (UTWIG_BOMB_ON_SHIP, 1);
-		SET_GAME_STATE (DRUUGE_MANNER, 1);
-		SET_GAME_STATE (DRUUGE_VISITS, 0);
-		SET_GAME_STATE (DRUUGE_HOME_VISITS, 0);
+		rand_val = TFB_Random ();
+		solarSys->SysInfo.PlanetInfo.CurPt.x =
+				(LOBYTE (LOWORD (rand_val)) % (MAP_WIDTH - (8 << 1))) + 8;
+		solarSys->SysInfo.PlanetInfo.CurPt.y =
+				(HIBYTE (LOWORD (rand_val)) % (MAP_HEIGHT - (8 << 1))) + 8;
+		solarSys->SysInfo.PlanetInfo.CurDensity = 0;
+		solarSys->SysInfo.PlanetInfo.CurType = 0;
+		if (!(solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+				& (1L << 0))
+				&& *whichNode == (COUNT)~0)
+			*whichNode = 1;
+		else
+		{
+			*whichNode = 0;
+			if (solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+					& (1L << 0))
+			{
+				SET_GAME_STATE (UTWIG_BOMB, 1);
+				SET_GAME_STATE (UTWIG_BOMB_ON_SHIP, 1);
+				SET_GAME_STATE (DRUUGE_MANNER, 1);
+				SET_GAME_STATE (DRUUGE_VISITS, 0);
+				SET_GAME_STATE (DRUUGE_HOME_VISITS, 0);
+			}
+		}
 
-		return true; // picked up
+		TFB_SeedRandom (old_rand);
+		return true;
 	}
 
-	(void) whichNode;
-	return false;
+	*whichNode = 0;
+	return true;
 }
+
diff -ruNp src.orig/uqm/planets/generate/genvault.c src/uqm/planets/generate/genvault.c
--- src.orig/uqm/planets/generate/genvault.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/genvault.c	2017-11-01 15:31:03 -0700
@@ -27,10 +27,8 @@
 
 static bool GenerateVault_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateVault_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static bool GenerateVault_pickupEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static bool GenerateVault_generateEnergy (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
 
 
 const GenerateFunctions generateVaultFunctions = {
@@ -44,9 +42,6 @@ const GenerateFunctions generateVaultFun
 	/* .generateMinerals = */ GenerateDefault_generateMinerals,
 	/* .generateEnergy   = */ GenerateVault_generateEnergy,
 	/* .generateLife     = */ GenerateDefault_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GenerateVault_pickupEnergy,
-	/* .pickupLife       = */ GenerateDefault_pickupLife,
 };
 
 
@@ -78,53 +73,55 @@ GenerateVault_generateOrbital (SOLARSYS_
 	return true;
 }
 
-static COUNT
+static bool
 GenerateVault_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+		COUNT *whichNode)
 {
 	if (matchWorld (solarSys, world, 0, 0))
 	{
-		return GenerateDefault_generateArtifact (solarSys, whichNode);
-	}
+		DWORD rand_val;
+		DWORD old_rand;
 
-	return 0;
-}
-
-static bool
-GenerateVault_pickupEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
-{
-	if (matchWorld (solarSys, world, 0, 0))
-	{
-		assert (whichNode == 0);
+		old_rand = TFB_SeedRandom (
+				solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN]);
 
-		if (GET_GAME_STATE (SHIP_VAULT_UNLOCKED))
-		{	// Give the final report, "omg empty" and whatnot
-			GenerateDefault_landerReportCycle (solarSys);
-		}
-		else if (GET_GAME_STATE (SYREEN_SHUTTLE_ON_SHIP))
-		{
-			GenerateDefault_landerReportCycle (solarSys);
-			SetLanderTakeoff ();
-
-			SET_GAME_STATE (SHIP_VAULT_UNLOCKED, 1);
-			SET_GAME_STATE (SYREEN_SHUTTLE_ON_SHIP, 0);
-			SET_GAME_STATE (SYREEN_HOME_VISITS, 0);
-		}
+		rand_val = TFB_Random ();
+		solarSys->SysInfo.PlanetInfo.CurPt.x =
+				(LOBYTE (LOWORD (rand_val)) % (MAP_WIDTH - (8 << 1))) + 8;
+		solarSys->SysInfo.PlanetInfo.CurPt.y =
+				(HIBYTE (LOWORD (rand_val)) % (MAP_HEIGHT - (8 << 1))) + 8;
+		solarSys->SysInfo.PlanetInfo.CurDensity = 0;
+		if (!GET_GAME_STATE (SHIP_VAULT_UNLOCKED))
+			solarSys->SysInfo.PlanetInfo.CurType = 0;
 		else
+			solarSys->SysInfo.PlanetInfo.CurType = 1;
+		*whichNode = 1;
+
+		if (solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+				& (1L << 0))
 		{
-			GenerateDefault_landerReport (solarSys);
+			solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+					&= ~(1L << 0);
+			if (GET_GAME_STATE (SYREEN_SHUTTLE_ON_SHIP))
+			{
+				SetLanderTakeoff ();
 
-			if (!GET_GAME_STATE (KNOW_SYREEN_VAULT))
+				SET_GAME_STATE (SHIP_VAULT_UNLOCKED, 1);
+				SET_GAME_STATE (SYREEN_SHUTTLE_ON_SHIP, 0);
+				SET_GAME_STATE (SYREEN_HOME_VISITS, 0);
+			}
+			else if (!GET_GAME_STATE (KNOW_SYREEN_VAULT))
 			{
 				SET_GAME_STATE (KNOW_SYREEN_VAULT, 1);
+				SET_GAME_STATE (SYREEN_HOME_VISITS, 0);
 			}
 		}
 
-		// The Vault cannot be "picked up". It is always on the surface.
-		return false;
+		TFB_SeedRandom (old_rand);
+		return true;
 	}
 
-	(void) whichNode;
-	return false;
+	*whichNode = 0;
+	return true;
 }
+
diff -ruNp src.orig/uqm/planets/generate/genvux.c src/uqm/planets/generate/genvux.c
--- src.orig/uqm/planets/generate/genvux.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/genvux.c	2017-11-01 15:31:03 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: Removed shofixti maidens
+
 #include "genall.h"
 #include "../lander.h"
 #include "../lifeform.h"
@@ -33,32 +35,26 @@
 
 
 static bool GenerateVux_generatePlanets (SOLARSYS_STATE *solarSys);
+static bool GenerateVux_generateMoons (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *planet);
 static bool GenerateVux_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateVux_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static COUNT GenerateVux_generateLife (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static bool GenerateVux_pickupEnergy (SOLARSYS_STATE *, PLANET_DESC *world,
-		COUNT whichNode);
-static bool GenerateVux_pickupLife (SOLARSYS_STATE *, PLANET_DESC *world,
-		COUNT whichNode);
-
+static bool GenerateVux_generateEnergy (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
+static bool GenerateVux_generateLife (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
 
 const GenerateFunctions generateVuxFunctions = {
 	/* .initNpcs         = */ GenerateDefault_initNpcs,
 	/* .reinitNpcs       = */ GenerateDefault_reinitNpcs,
 	/* .uninitNpcs       = */ GenerateDefault_uninitNpcs,
 	/* .generatePlanets  = */ GenerateVux_generatePlanets,
-	/* .generateMoons    = */ GenerateDefault_generateMoons,
+	/* .generateMoons    = */ GenerateVux_generateMoons,
 	/* .generateName     = */ GenerateDefault_generateName,
 	/* .generateOrbital  = */ GenerateVux_generateOrbital,
 	/* .generateMinerals = */ GenerateDefault_generateMinerals,
 	/* .generateEnergy   = */ GenerateVux_generateEnergy,
 	/* .generateLife     = */ GenerateVux_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GenerateVux_pickupEnergy,
-	/* .pickupLife       = */ GenerateVux_pickupLife,
 };
 
 
@@ -83,15 +79,18 @@ GenerateVux_generatePlanets (SOLARSYS_ST
 				COSINE (angle, solarSys->PlanetDesc[0].radius);
 		solarSys->PlanetDesc[0].location.y =
 				SINE (angle, solarSys->PlanetDesc[0].radius);
+		ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 	}
 	else
 	{
 		if (CurStarDescPtr->Index == VUX_DEFINED)
 		{
-			solarSys->PlanetDesc[0].data_index = REDUX_WORLD;
-			solarSys->PlanetDesc[0].NumPlanets = 1;
+			solarSys->PlanetDesc[0].data_index = REDUX_WORLD | PLANET_SHIELDED;
+			solarSys->PlanetDesc[0].flags = BLUE_SHIELD;
+			solarSys->PlanetDesc[0].NumPlanets = 2;
 			solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 42L / 100;
 			angle = HALF_CIRCLE + OCTANT;
+			ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 		}
 		else /* if (CurStarDescPtr->Index == VUX_BEAST_DEFINED) */
 		{
@@ -104,6 +103,7 @@ GenerateVux_generatePlanets (SOLARSYS_ST
 			solarSys->PlanetDesc[0].data_index = WATER_WORLD;
 			solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 110L / 100;
 			solarSys->PlanetDesc[0].NumPlanets = 0;
+			ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 		}
 
 		solarSys->PlanetDesc[0].location.x =
@@ -118,159 +118,114 @@ GenerateVux_generatePlanets (SOLARSYS_ST
 }
 
 static bool
-GenerateVux_generateOrbital (SOLARSYS_STATE *solarSys, PLANET_DESC *world)
+GenerateVux_generateMoons (SOLARSYS_STATE *solarSys, PLANET_DESC *planet)
 {
-	if ((matchWorld (solarSys, world, 0, MATCH_PLANET)
-			&& (CurStarDescPtr->Index == VUX_DEFINED
-			|| (CurStarDescPtr->Index == MAIDENS_DEFINED
-			&& !GET_GAME_STATE (ZEX_IS_DEAD))))
-			&& ActivateStarShip (VUX_SHIP, SPHERE_TRACKING))
-	{
-		NotifyOthers (VUX_SHIP, IPNL_ALL_CLEAR);
-		PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
-		ReinitQueue (&GLOBAL (ip_group_q));
-		assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
-
-		CloneShipFragment (VUX_SHIP,
-				&GLOBAL (npc_built_ship_q), INFINITE_FLEET);
-		if (CurStarDescPtr->Index == VUX_DEFINED)
-		{
-			SET_GAME_STATE (GLOBAL_FLAGS_AND_DATA, 1 << 7);
-		}
-		else
-		{
-			SET_GAME_STATE (GLOBAL_FLAGS_AND_DATA, 1 << 6);
-		}
-
-		GLOBAL (CurrentActivity) |= START_INTERPLANETARY;
-		InitCommunication (VUX_CONVERSATION);
-
-		if (GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD))
-			return true;
-
-		{
-			GLOBAL (CurrentActivity) &= ~START_INTERPLANETARY;
-			ReinitQueue (&GLOBAL (npc_built_ship_q));
-			GetGroupInfo (GROUPS_RANDOM, GROUP_LOAD_IP);
-
-			if (CurStarDescPtr->Index == VUX_DEFINED
-					|| !GET_GAME_STATE (ZEX_IS_DEAD))
-				return true;
-
-			LockMutex (GraphicsLock);
-			RepairSISBorder ();
-			UnlockMutex (GraphicsLock);
-		}
-	}
-
-	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
-	{
-		if (CurStarDescPtr->Index == MAIDENS_DEFINED)
-		{
-			if (!GET_GAME_STATE (SHOFIXTI_MAIDENS))
-			{
-				LoadStdLanderFont (&solarSys->SysInfo.PlanetInfo);
-				solarSys->PlanetSideFrame[1] = CaptureDrawable (
-						LoadGraphic (MAIDENS_MASK_PMAP_ANIM));
-				solarSys->SysInfo.PlanetInfo.DiscoveryString =
-						CaptureStringTable (
-						LoadStringTable (MAIDENS_STRTAB));
-			}
-		}
-		else if (CurStarDescPtr->Index == VUX_BEAST_DEFINED)
-		{
-			if (!GET_GAME_STATE (VUX_BEAST))
-			{
-				LoadStdLanderFont (&solarSys->SysInfo.PlanetInfo);
-				solarSys->PlanetSideFrame[1] = 0;
-				solarSys->SysInfo.PlanetInfo.DiscoveryString =
-						CaptureStringTable (
-						LoadStringTable (BEAST_STRTAB));
-			}
-		}
-		else
-		{
-			LoadStdLanderFont (&solarSys->SysInfo.PlanetInfo);
-			solarSys->PlanetSideFrame[1] =
-					CaptureDrawable (LoadGraphic (RUINS_MASK_PMAP_ANIM));
-			solarSys->SysInfo.PlanetInfo.DiscoveryString =
-					CaptureStringTable (LoadStringTable (RUINS_STRTAB));
-		}
-	}
-
-	GenerateDefault_generateOrbital (solarSys, world);
-
-	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
+	GenerateDefault_generateMoons (solarSys, planet);
+	if (CurStarDescPtr->Index == VUX_DEFINED
+	    && matchWorld(solarSys, planet, 0, MATCH_PLANET))
 	{
-		solarSys->SysInfo.PlanetInfo.Weather = 2;
-		solarSys->SysInfo.PlanetInfo.Tectonics = 0;
+		TFB_SeedRandom(10026855);
+		GenerateDefault_generateMoons (solarSys, planet);
+		
+		solarSys->MoonDesc[0].data_index = HIERARCHY_STARBASE;
+		solarSys->MoonDesc[0].radius = MIN_MOON_RADIUS;
+		solarSys->MoonDesc[0].location.x =
+			COSINE (QUADRANT, pSolarSysState->MoonDesc[0].radius);
+		solarSys->MoonDesc[0].location.y =
+			SINE (QUADRANT, pSolarSysState->MoonDesc[0].radius);
+		ComputeSpeed(&solarSys->MoonDesc[0], TRUE, 1);
 	}
 
 	return true;
 }
 
-static COUNT
-GenerateVux_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+static bool
+GenerateVux_generateOrbital (SOLARSYS_STATE *solarSys, PLANET_DESC *world)
 {
-	if (CurStarDescPtr->Index == MAIDENS_DEFINED
-			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
+	if (CurStarDescPtr->Index == VUX_DEFINED
+	    && matchWorld(solarSys, world, 0, 0))
 	{
-		// This check is redundant since the retrieval bit will keep the
-		// node from showing up again
-		if (GET_GAME_STATE (SHOFIXTI_MAIDENS))
-		{	// already picked up
-			return 0;
-		}
-
-		solarSys->SysInfo.PlanetInfo.CurPt.x = MAP_WIDTH / 3;
-		solarSys->SysInfo.PlanetInfo.CurPt.y = MAP_HEIGHT * 5 / 8;
-		
-		return 1; // only matters when count is requested
+		InitCommunication (VUX_CONVERSATION);
 	}
-
-	if (CurStarDescPtr->Index == VUX_DEFINED
-			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
+	else
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
+		GenerateDefault_generateOrbital (solarSys, world);
 	}
-
-	return 0;
+	return true;
 }
 
 static bool
-GenerateVux_pickupEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateVux_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
+		COUNT *whichNode)
 {
-	if (CurStarDescPtr->Index == MAIDENS_DEFINED
-			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
+	if (matchWorld (solarSys, world, 0, MATCH_PLANET)
+			&& CurStarDescPtr->Index != VUX_BEAST_DEFINED)
 	{
-		assert (!GET_GAME_STATE (SHOFIXTI_MAIDENS) && whichNode == 0);
-
-		GenerateDefault_landerReport (solarSys);
-		SetLanderTakeoff ();
+		/*if (CurStarDescPtr->Index == MAIDENS_DEFINED
+				&& !GET_GAME_STATE (SHOFIXTI_MAIDENS))
+		{
+			solarSys->SysInfo.PlanetInfo.CurPt.x = MAP_WIDTH / 3;
+			solarSys->SysInfo.PlanetInfo.CurPt.y = MAP_HEIGHT * 5 / 8;
+			solarSys->SysInfo.PlanetInfo.CurDensity = 0;
+			solarSys->SysInfo.PlanetInfo.CurType = 0;
+			if (!(solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+					& (1L << 0))
+					&& *whichNode == (COUNT)~0)
+				*whichNode = 1;
+			else
+			{
+				*whichNode = 0;
+				if (solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+						& (1L << 0))
+				{
+					SET_GAME_STATE (SHOFIXTI_MAIDENS, 1);
+					SET_GAME_STATE (MAIDENS_ON_SHIP, 1);
+				}
+			}
+			return true;
+			}*/
 
-		SET_GAME_STATE (SHOFIXTI_MAIDENS, 1);
-		SET_GAME_STATE (MAIDENS_ON_SHIP, 1);
-		
-		return true; // picked up
-	}
+		if (CurStarDescPtr->Index == VUX_DEFINED)
+		{
+			COUNT i;
+			COUNT nodeI;
+			DWORD rand_val;
+			DWORD old_rand;
+
+			old_rand = TFB_SeedRandom (
+					solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN]);
+
+			nodeI = 0;
+			i = 0;
+			do
+			{
+				rand_val = TFB_Random ();
+				solarSys->SysInfo.PlanetInfo.CurPt.x =
+						(LOBYTE (LOWORD (rand_val)) % (MAP_WIDTH - (8 << 1))) + 8;
+				solarSys->SysInfo.PlanetInfo.CurPt.y =
+						(HIBYTE (LOWORD (rand_val)) % (MAP_HEIGHT - (8 << 1))) + 8;
+				solarSys->SysInfo.PlanetInfo.CurType = 1;
+				solarSys->SysInfo.PlanetInfo.CurDensity = 0;
+				if (nodeI >= *whichNode
+						&& !(solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+						& (1L << i)))
+					break;
+				++nodeI;
+			} while (++i < 16);
+			*whichNode = nodeI;
 
-	if (CurStarDescPtr->Index == VUX_DEFINED
-			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
-	{
-		// Standard ruins report
-		GenerateDefault_landerReportCycle (solarSys);
-		return false;
+			TFB_SeedRandom (old_rand);
+			return true;
+		}
 	}
 
-	(void) whichNode;
-	return false;
+	*whichNode = 0;
+	return true;
 }
 
-static COUNT
+static bool
 GenerateVux_generateLife (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+		COUNT *whichNode)
 {
 	if (CurStarDescPtr->Index == MAIDENS_DEFINED
 			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
@@ -281,20 +236,29 @@ GenerateVux_generateLife (SOLARSYS_STATE
 		old_rand = TFB_SeedRandom (
 				solarSys->SysInfo.PlanetInfo.ScanSeed[BIOLOGICAL_SCAN]);
 
-		for (i = 0; i <= whichNode && i < 12; ++i)
+		i = 0;
+		do
 		{
-			GenerateRandomLocation (&solarSys->SysInfo);
+			DWORD rand_val = TFB_Random ();
+			solarSys->SysInfo.PlanetInfo.CurPt.x =
+					(LOBYTE (LOWORD (rand_val)) % (MAP_WIDTH - (8 << 1))) + 8;
+			solarSys->SysInfo.PlanetInfo.CurPt.y =
+					(HIBYTE (LOWORD (rand_val)) % (MAP_HEIGHT - (8 << 1))) + 8;
 			if (i < 4)
 				solarSys->SysInfo.PlanetInfo.CurType = 9;
 			else if (i < 8)
 				solarSys->SysInfo.PlanetInfo.CurType = 14;
 			else /* if (i < 12) */
 				solarSys->SysInfo.PlanetInfo.CurType = 18;
-		}
-		
-		TFB_SeedRandom (old_rand);
+			if (i >= *whichNode
+					&& !(solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[BIOLOGICAL_SCAN]
+					& (1L << i)))
+				break;
+		} while (++i < 12);
+		*whichNode = i;
 
-		return 12; // only matters when count is requested
+		TFB_SeedRandom (old_rand);
+		return true;
 	}
 
 	if (CurStarDescPtr->Index == VUX_BEAST_DEFINED
@@ -306,10 +270,15 @@ GenerateVux_generateLife (SOLARSYS_STATE
 		old_rand = TFB_SeedRandom (
 				solarSys->SysInfo.PlanetInfo.ScanSeed[BIOLOGICAL_SCAN]);
 
-		for (i = 0; i <= whichNode && i < 11; ++i)
+		i = 0;
+		do
 		{
-			GenerateRandomLocation (&solarSys->SysInfo);
-			if (i == 0) /* VUX Beast */
+			DWORD rand_val = TFB_Random ();
+			solarSys->SysInfo.PlanetInfo.CurPt.x =
+					(LOBYTE (LOWORD (rand_val)) % (MAP_WIDTH - (8 << 1))) + 8;
+			solarSys->SysInfo.PlanetInfo.CurPt.y =
+					(HIBYTE (LOWORD (rand_val)) % (MAP_HEIGHT - (8 << 1))) + 8;
+			if (i == 0)
 				solarSys->SysInfo.PlanetInfo.CurType = NUM_CREATURE_TYPES + 2;
 			else if (i <= 5)
 					/* {SPEED_MOTIONLESS | DANGER_NORMAL, MAKE_BYTE (5, 3)}, */
@@ -317,36 +286,31 @@ GenerateVux_generateLife (SOLARSYS_STATE
 			else /* if (i <= 10) */
 					/* {BEHAVIOR_UNPREDICTABLE | SPEED_SLOW | DANGER_NORMAL, MAKE_BYTE (3, 8)}, */
 				solarSys->SysInfo.PlanetInfo.CurType = 8;
-		}
-		
-		TFB_SeedRandom (old_rand);
-
-		return  11; // only matters when count is requested
-	}
-
-	return GenerateDefault_generateLife (solarSys, world, whichNode);
-}
-
-static bool
-GenerateVux_pickupLife (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
-{
-	if (CurStarDescPtr->Index == VUX_BEAST_DEFINED
-			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
-	{
-		if (whichNode == 0)
-		{	// Picked up Zex' Beauty
-			assert (!GET_GAME_STATE (VUX_BEAST));
-
-			GenerateDefault_landerReport (solarSys);
-			SetLanderTakeoff ();
+			if (i >= *whichNode
+					&& !(solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[BIOLOGICAL_SCAN]
+					& (1L << i)))
+				break;
+			else if (i == 0
+					&& (solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[BIOLOGICAL_SCAN]
+					& (1L << i))
+					&& !GET_GAME_STATE (VUX_BEAST))
+			{
+				UnbatchGraphics ();
+				DoDiscoveryReport (MenuSounds);
+				BatchGraphics ();
+				SetLanderTakeoff ();
 
-			SET_GAME_STATE (VUX_BEAST, 1);
-			SET_GAME_STATE (VUX_BEAST_ON_SHIP, 1);
-		}
+				SET_GAME_STATE (VUX_BEAST, 1);
+				SET_GAME_STATE (VUX_BEAST_ON_SHIP, 1);
+			}
+		} while (++i < 11);
+		*whichNode = i;
 
-		return true; // picked up
+		TFB_SeedRandom (old_rand);
+		return true;
 	}
 
-	return GenerateDefault_pickupLife (solarSys, world, whichNode);
+	GenerateDefault_generateLife (solarSys, world, whichNode);
+	return true;
 }
+
diff -ruNp src.orig/uqm/planets/generate/genwreck.c src/uqm/planets/generate/genwreck.c
--- src.orig/uqm/planets/generate/genwreck.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/genwreck.c	2017-11-01 15:31:03 -0700
@@ -27,10 +27,8 @@
 
 static bool GenerateWreck_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateWreck_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static bool GenerateWreck_pickupEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static bool GenerateWreck_generateEnergy (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
 
 
 const GenerateFunctions generateWreckFunctions = {
@@ -44,9 +42,6 @@ const GenerateFunctions generateWreckFun
 	/* .generateMinerals = */ GenerateDefault_generateMinerals,
 	/* .generateEnergy   = */ GenerateWreck_generateEnergy,
 	/* .generateLife     = */ GenerateDefault_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GenerateWreck_pickupEnergy,
-	/* .pickupLife       = */ GenerateDefault_pickupLife,
 };
 
 
@@ -61,7 +56,7 @@ GenerateWreck_generateOrbital (SOLARSYS_
 		solarSys->SysInfo.PlanetInfo.DiscoveryString =
 				CaptureStringTable (LoadStringTable (WRECK_STRTAB));
 		if (GET_GAME_STATE (PORTAL_KEY))
-		{	// Already picked it up, skip the first report
+		{
 			solarSys->SysInfo.PlanetInfo.DiscoveryString =
 					SetAbsStringTableIndex (
 					solarSys->SysInfo.PlanetInfo.DiscoveryString, 1);
@@ -72,40 +67,49 @@ GenerateWreck_generateOrbital (SOLARSYS_
 	return true;
 }
 
-static COUNT
-GenerateWreck_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
-{
-	if (matchWorld (solarSys, world, 6, MATCH_PLANET))
-	{
-		return GenerateDefault_generateArtifact (solarSys, whichNode);
-	}
-
-	return 0;
-}
-
 static bool
-GenerateWreck_pickupEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateWreck_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
+		COUNT *whichNode)
 {
 	if (matchWorld (solarSys, world, 6, MATCH_PLANET))
 	{
-		assert (whichNode == 0);
+		DWORD rand_val;
+		DWORD old_rand;
 
-		GenerateDefault_landerReportCycle (solarSys);
+		old_rand = TFB_SeedRandom (
+				solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN]);
 
+		rand_val = TFB_Random ();
+		solarSys->SysInfo.PlanetInfo.CurPt.x =
+				(LOBYTE (LOWORD (rand_val)) % (MAP_WIDTH - (8 << 1))) + 8;
+		solarSys->SysInfo.PlanetInfo.CurPt.y =
+				(HIBYTE (LOWORD (rand_val)) % (MAP_HEIGHT - (8 << 1))) + 8;
+		solarSys->SysInfo.PlanetInfo.CurDensity = 0;
 		if (!GET_GAME_STATE (PORTAL_KEY))
+			solarSys->SysInfo.PlanetInfo.CurType = 0;
+		else
+			solarSys->SysInfo.PlanetInfo.CurType = 1;
+		*whichNode = 1;
+		if (solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+				& (1L << 0))
 		{
-			SetLanderTakeoff ();
+			solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+					&= ~(1L << 0);
 
-			SET_GAME_STATE (PORTAL_KEY, 1);
-			SET_GAME_STATE (PORTAL_KEY_ON_SHIP, 1);
+			if (!GET_GAME_STATE (PORTAL_KEY))
+			{
+				SetLanderTakeoff ();
+
+				SET_GAME_STATE (PORTAL_KEY, 1);
+				SET_GAME_STATE (PORTAL_KEY_ON_SHIP, 1);
+			}
 		}
 
-		// The Wreck cannot be "picked up". It is always on the surface.
-		return false;
+		TFB_SeedRandom (old_rand);
+		return true;
 	}
 
-	(void) whichNode;
-	return false;
+	*whichNode = 0;
+	return true;
 }
+
diff -ruNp src.orig/uqm/planets/generate/genyeh.c src/uqm/planets/generate/genyeh.c
--- src.orig/uqm/planets/generate/genyeh.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/genyeh.c	2017-11-01 15:31:03 -0700
@@ -27,13 +27,12 @@
 #include "libs/mathlib.h"
 
 
+static bool GenerateYehat_generateMoons (SOLARSYS_STATE *solarSys, PLANET_DESC *planet);
 static bool GenerateYehat_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateYehat_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateYehat_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static bool GenerateYehat_pickupEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static bool GenerateYehat_generateEnergy (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
 
 
 const GenerateFunctions generateYehatFunctions = {
@@ -41,15 +40,12 @@ const GenerateFunctions generateYehatFun
 	/* .reinitNpcs       = */ GenerateDefault_reinitNpcs,
 	/* .uninitNpcs       = */ GenerateDefault_uninitNpcs,
 	/* .generatePlanets  = */ GenerateYehat_generatePlanets,
-	/* .generateMoons    = */ GenerateDefault_generateMoons,
+	/* .generateMoons    = */ GenerateYehat_generateMoons,
 	/* .generateName     = */ GenerateDefault_generateName,
 	/* .generateOrbital  = */ GenerateYehat_generateOrbital,
 	/* .generateMinerals = */ GenerateDefault_generateMinerals,
 	/* .generateEnergy   = */ GenerateYehat_generateEnergy,
 	/* .generateLife     = */ GenerateDefault_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GenerateYehat_pickupEnergy,
-	/* .pickupLife       = */ GenerateDefault_pickupLife,
 };
 
 
@@ -68,13 +64,46 @@ GenerateYehat_generatePlanets (SOLARSYS_
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
 
 static bool
+GenerateYehat_generateMoons (SOLARSYS_STATE *solarSys, PLANET_DESC *planet)
+{
+	GenerateDefault_generateMoons (solarSys, planet);
+
+	if (matchWorld (solarSys, planet, 0, MATCH_PLANET))
+	{
+		COUNT angle;
+		DWORD rand_val;
+
+		planet->NumPlanets = 2;
+		solarSys->MoonDesc[1].data_index = HIERARCHY_STARBASE;
+		solarSys->MoonDesc[1].radius = MIN_MOON_RADIUS;
+		rand_val = TFB_Random ();
+		angle = NORMALIZE_ANGLE (LOWORD (rand_val));
+		solarSys->MoonDesc[1].location.x = COSINE (angle, solarSys->MoonDesc[1].radius);
+		solarSys->MoonDesc[1].location.y = SINE (angle, solarSys->MoonDesc[1].radius);
+		solarSys->MoonDesc[1].temp_color = planet->temp_color;
+		ComputeSpeed(&solarSys->MoonDesc[1], TRUE, 1);
+	}
+
+	return true;
+}
+
+
+static bool
 GenerateYehat_generateOrbital (SOLARSYS_STATE *solarSys, PLANET_DESC *world)
 {
+	if (matchWorld (solarSys, world, 0, 1))
+	{
+		InitCommunication (YEHATPKUNK_CONVERSATION);		/* Y+P starbase */
+
+		return true;
+	}
+
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
 		if (ActivateStarShip (YEHAT_SHIP, SPHERE_TRACKING))
@@ -89,7 +118,7 @@ GenerateYehat_generateOrbital (SOLARSYS_
 
 			GLOBAL (CurrentActivity) |= START_INTERPLANETARY;
 			SET_GAME_STATE (GLOBAL_FLAGS_AND_DATA, 1 << 7);
-			InitCommunication (YEHAT_CONVERSATION);
+			InitCommunication (PKUNK_CONVERSATION);
 
 			if (!(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD)))
 			{
@@ -112,29 +141,44 @@ GenerateYehat_generateOrbital (SOLARSYS_
 	return true;
 }
 
-static COUNT
+static bool
 GenerateYehat_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+		COUNT *whichNode)
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
-	}
-
-	return 0;
-}
+		COUNT i;
+		COUNT nodeI;
+		DWORD rand_val;
+		DWORD old_rand;
+
+		old_rand = TFB_SeedRandom (
+				solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN]);
+
+		nodeI = 0;
+		i = 0;
+		do
+		{
+			rand_val = TFB_Random ();
+			solarSys->SysInfo.PlanetInfo.CurPt.x =
+					(LOBYTE (LOWORD (rand_val)) % (MAP_WIDTH - (8 << 1))) + 8;
+			solarSys->SysInfo.PlanetInfo.CurPt.y =
+					(HIBYTE (LOWORD (rand_val)) % (MAP_HEIGHT - (8 << 1))) + 8;
+			solarSys->SysInfo.PlanetInfo.CurType = 1;
+			solarSys->SysInfo.PlanetInfo.CurDensity = 0;
+			if (nodeI >= *whichNode
+					&& !(solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+					& (1L << i)))
+				break;
+			++nodeI;
+		} while (++i < 16);
+		*whichNode = nodeI;
 
-static bool
-GenerateYehat_pickupEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
-{
-	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
-	{
-		// Standard ruins report
-		GenerateDefault_landerReportCycle (solarSys);
-		return false;
+		TFB_SeedRandom (old_rand);
+		return true;
 	}
 
-	(void) whichNode;
-	return false;
+	*whichNode = 0;
+	return true;
 }
+
diff -ruNp src.orig/uqm/planets/generate/genzfpscout.c src/uqm/planets/generate/genzfpscout.c
--- src.orig/uqm/planets/generate/genzfpscout.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/genzfpscout.c	1969-12-31 16:00:00 -0800
@@ -1,96 +0,0 @@
-//Copyright Paul Reiche, Fred Ford. 1992-2002
-
-/*
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include "genall.h"
-#include "../../build.h"
-#include "../../globdata.h"
-#include "../../grpinfo.h"
-#include "../../state.h"
-
-
-static bool GenerateZoqFotPikScout_initNpcs (SOLARSYS_STATE *solarSys);
-static bool GenerateZoqFotPikScout_reinitNpcs (SOLARSYS_STATE *solarSys);
-
-
-const GenerateFunctions generateZoqFotPikScoutFunctions = {
-	/* .initNpcs         = */ GenerateZoqFotPikScout_initNpcs,
-	/* .reinitNpcs       = */ GenerateZoqFotPikScout_reinitNpcs,
-	/* .uninitNpcs       = */ GenerateDefault_uninitNpcs,
-	/* .generatePlanets  = */ GenerateDefault_generatePlanets,
-	/* .generateMoons    = */ GenerateDefault_generateMoons,
-	/* .generateName     = */ GenerateDefault_generateName,
-	/* .generateOrbital  = */ GenerateDefault_generateOrbital,
-	/* .generateMinerals = */ GenerateDefault_generateMinerals,
-	/* .generateEnergy   = */ GenerateDefault_generateEnergy,
-	/* .generateLife     = */ GenerateDefault_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GenerateDefault_pickupEnergy,
-	/* .pickupLife       = */ GenerateDefault_pickupLife,
-};
-
-
-static bool
-GenerateZoqFotPikScout_initNpcs (SOLARSYS_STATE *solarSys)
-{
-	if (!GET_GAME_STATE (MET_ZOQFOT))
-	{
-		GLOBAL (BattleGroupRef) = GET_GAME_STATE_32 (ZOQFOT_GRPOFFS0);
-		if (GLOBAL (BattleGroupRef) == 0)
-		{
-			CloneShipFragment (ZOQFOTPIK_SHIP,
-					&GLOBAL (npc_built_ship_q), 0);
-			GLOBAL (BattleGroupRef) = PutGroupInfo (GROUPS_ADD_NEW, 1);
-			ReinitQueue (&GLOBAL (npc_built_ship_q));
-			SET_GAME_STATE_32 (ZOQFOT_GRPOFFS0, GLOBAL (BattleGroupRef));
-		}
-	}
-
-	GenerateDefault_initNpcs (solarSys);
-
-	return true;
-}
-
-static bool
-GenerateZoqFotPikScout_reinitNpcs (SOLARSYS_STATE *solarSys)
-{
-	HIPGROUP hGroup;
-	IP_GROUP *GroupPtr;
-
-	GenerateDefault_reinitNpcs (solarSys);
-
-	if (!GLOBAL (BattleGroupRef))
-		return true; // nothing to check
-
-	hGroup = GetHeadLink (&GLOBAL (ip_group_q));
-	if (!hGroup)
-		return true; // still nothing to check
-
-	GroupPtr = LockIpGroup (&GLOBAL (ip_group_q), hGroup);
-	// REFORM_GROUP was set in ipdisp.c:ip_group_collision()
-	// during a collision with the flagship.
-	if (GroupPtr->race_id == ZOQFOTPIK_SHIP
-			&& (GroupPtr->task & REFORM_GROUP))
-	{
-		GroupPtr->task = FLEE | IGNORE_FLAGSHIP | REFORM_GROUP;
-		GroupPtr->dest_loc = 0;
-	}
-	UnlockIpGroup (&GLOBAL (ip_group_q), hGroup);
-
-	return true;
-}
-
diff -ruNp src.orig/uqm/planets/generate/genzoq.c src/uqm/planets/generate/genzoq.c
--- src.orig/uqm/planets/generate/genzoq.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate/genzoq.c	2017-11-01 15:31:03 -0700
@@ -30,10 +30,8 @@ static bool GenerateZoqFotPik_initNpcs (
 static bool GenerateZoqFotPik_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateZoqFotPik_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateZoqFotPik_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static bool GenerateZoqFotPik_pickupEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static bool GenerateZoqFotPik_generateEnergy (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
 
 
 const GenerateFunctions generateZoqFotPikFunctions = {
@@ -47,9 +45,6 @@ const GenerateFunctions generateZoqFotPi
 	/* .generateMinerals = */ GenerateDefault_generateMinerals,
 	/* .generateEnergy   = */ GenerateZoqFotPik_generateEnergy,
 	/* .generateLife     = */ GenerateDefault_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GenerateZoqFotPik_pickupEnergy,
-	/* .pickupLife       = */ GenerateDefault_pickupLife,
 };
 
 
@@ -78,6 +73,7 @@ GenerateZoqFotPik_generatePlanets (SOLAR
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
@@ -142,29 +138,44 @@ GenerateZoqFotPik_generateOrbital (SOLAR
 	return true;
 }
 
-static COUNT
+static bool
 GenerateZoqFotPik_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+		COUNT *whichNode)
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
-	}
-
-	return 0;
-}
+		COUNT i;
+		COUNT nodeI;
+		DWORD rand_val;
+		DWORD old_rand;
+
+		old_rand = TFB_SeedRandom (
+				solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN]);
+
+		nodeI = 0;
+		i = 0;
+		do
+		{
+			rand_val = TFB_Random ();
+			solarSys->SysInfo.PlanetInfo.CurPt.x =
+					(LOBYTE (LOWORD (rand_val)) % (MAP_WIDTH - (8 << 1))) + 8;
+			solarSys->SysInfo.PlanetInfo.CurPt.y =
+					(HIBYTE (LOWORD (rand_val)) % (MAP_HEIGHT - (8 << 1))) + 8;
+			solarSys->SysInfo.PlanetInfo.CurType = 1;
+			solarSys->SysInfo.PlanetInfo.CurDensity = 0;
+			if (nodeI >= *whichNode
+					&& !(solarSys->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN]
+					& (1L << i)))
+				break;
+			++nodeI;
+		} while (++i < 16);
+		*whichNode = nodeI;
 
-static bool
-GenerateZoqFotPik_pickupEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
-{
-	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
-	{
-		// Standard ruins report
-		GenerateDefault_landerReportCycle (solarSys);
-		return false;
+		TFB_SeedRandom (old_rand);
+		return true;
 	}
 
-	(void) whichNode;
-	return false;
+	*whichNode = 0;
+	return true;
 }
+
diff -ruNp src.orig/uqm/planets/generate.h src/uqm/planets/generate.h
--- src.orig/uqm/planets/generate.h	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/generate.h	2017-11-01 15:31:03 -0700
@@ -25,10 +25,13 @@ typedef struct GenerateFunctions Generat
 
 /*
  * To do (for further cleanups):
+ * - split off pickupMineral, pickupEnergy, pickupLife from Generate*
  * - split off generateOrbital in a calculation and an activation
  *   (graphics and music) part.
  * - make generateOrbital return a meaningful value, specifically, whether
  *   or not the player is going into orbit
+ * - make generateMinerals et al return the last object number (or count
+ *   if called for all objects) and take non-pointer whichNode
  * - for GenerateNameFunction, set the name in an argument, instead
  *   of in GLOBAL_SYS(PlanetName)
  * - make generateName work for moons
@@ -40,6 +43,8 @@ typedef struct GenerateFunctions Generat
  *   solarSys->genFuncs->..., but use a function for this, which first
  *   checks for solar system dependent handlers, and if this does not exist,
  *   or returns false, calls the default function.
+ * - use isNodeRetrieved, setNodeRetrieved, and setNodeNotRetrieved instead
+ *   of manually messing with bit shifts, etc.
  */
 
 // Any of these functions returning true means that the action has been
@@ -54,22 +59,12 @@ typedef bool (*GenerateOrbitalFunction)(
 		PLANET_DESC *world);
 typedef bool (*GenerateNameFunction)(SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-// The following functions return the number of objects being generated
-// (or the index of the current object in some cases)
-typedef COUNT (*GenerateMineralsFunction)(SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-typedef COUNT (*GenerateEnergyFunction)(SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-typedef COUNT (*GenerateLifeFunction)(SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-// The following functions return true if the node should be removed
-// from the surface, i.e. picked up.
-typedef bool (*PickupMineralsFunction)(SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-typedef bool (*PickupEnergyFunction)(SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-typedef bool (*PickupLifeFunction)(SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+typedef bool (*GenerateMineralsFunction)(SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
+typedef bool (*GenerateEnergyFunction)(SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
+typedef bool (*GenerateLifeFunction)(SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *whichNode);
 
 
 struct GenerateFunctions {
@@ -93,9 +88,6 @@ struct GenerateFunctions {
 			// Energy sources on the planet surface.
 	GenerateLifeFunction generateLife;
 			// Bio on the planet surface.
-	PickupMineralsFunction pickupMinerals;
-	PickupEnergyFunction pickupEnergy;
-	PickupLifeFunction pickupLife;
 };
 
 
diff -ruNp src.orig/uqm/planets/gentopo.c src/uqm/planets/gentopo.c
--- src.orig/uqm/planets/gentopo.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/gentopo.c	2017-11-01 15:31:03 -0700
@@ -18,10 +18,14 @@
 
 // See doc/devel/planettopo for details.
 
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
 #include "libs/gfxlib.h"
 #include "libs/mathlib.h"
 #include "planets.h"
 
+#include "libs/log.h"
+
 void
 DeltaTopography (COUNT num_iterations, SBYTE *DepthArray, RECT *pRect,
 		SIZE depth_delta)
@@ -39,8 +43,8 @@ DeltaTopography (COUNT num_iterations, S
 	do
 	{
 		SIZE d;
-		COUNT h, w1, w2;
-		DWORD rand_val;
+		COUNT h, w1, w2;//, w1_b, w2_b;
+		DWORD rand_val;//, rand_val_b;
 		SBYTE *lpDst;
 
 		depth_delta = ((((SIZE)TFB_Random () & 1) << 1) - 1) * depth_delta;
@@ -49,8 +53,15 @@ DeltaTopography (COUNT num_iterations, S
 		w1 = LOWORD (rand_val);
 		w2 = HIWORD (rand_val);
 
-		LineDDA0.x_top = LOBYTE (w1) % width;
-		LineDDA0.x_bot = HIBYTE (w1) % width;
+		LineDDA0.x_top = (LOBYTE (w1) % ORIGINAL_MAP_WIDTH) * width / ORIGINAL_MAP_WIDTH;
+		LineDDA0.x_bot = (HIBYTE (w1) % ORIGINAL_MAP_WIDTH) * width / ORIGINAL_MAP_WIDTH;
+		
+		//LineDDA0.x_top = w1 % width; // JMS_GFX: Replaced previous lines with these: BYTE is too small for 640x480 sized maps.
+		//LineDDA0.x_bot = w2 % width; // Using w1 and w2 to get difference between top and bottom.
+		// BW: reinstate previous method and adapt it for higher res.
+		// Overusing w1 and w2 was hampering randomness.
+		// Now planets will look the same no matter what the res is.
+		
 		LineDDA0.delta_x = (LineDDA0.x_bot - LineDDA0.x_top) << 1;
 		if (LineDDA0.delta_x >= 0)
 			LineDDA0.x_incr = 1;
@@ -64,8 +75,14 @@ DeltaTopography (COUNT num_iterations, S
 		else
 			LineDDA0.error_term = -(delta_y >> 1);
 
-		LineDDA1.x_top = (LOBYTE (w2) % (width - 1)) + LineDDA0.x_top + 1;
-		LineDDA1.x_bot = (HIBYTE (w2) % (width - 1)) + LineDDA0.x_bot + 1;
+		LineDDA1.x_top = (LOBYTE (w2) % (ORIGINAL_MAP_WIDTH - 1)) * width / ORIGINAL_MAP_WIDTH + LineDDA0.x_top + 1;
+		LineDDA1.x_bot = (HIBYTE (w2) % (ORIGINAL_MAP_WIDTH - 1)) * width / ORIGINAL_MAP_WIDTH + LineDDA0.x_bot + 1;
+		
+		// JMS_GFX: Replaced previous lines with these: BYTE is too small for 640x480 sized maps.
+		//LineDDA1.x_top = (w2 % (width - 1)) + LineDDA0.x_top + 1;
+		//LineDDA1.x_bot = (w1 % (width - 1)) + LineDDA0.x_bot + 1;
+		// BW: the same as above
+		
 		LineDDA1.delta_x = (LineDDA1.x_bot - LineDDA1.x_top) << 1;
 		if (LineDDA1.delta_x >= 0)
 			LineDDA1.x_incr = 1;
@@ -200,6 +217,3 @@ DeltaTopography (COUNT num_iterations, S
 		} while (--h);
 	} while (--num_iterations);
 }
-
-
-
diff -ruNp src.orig/uqm/planets/lander.c src/uqm/planets/lander.c
--- src.orig/uqm/planets/lander.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/lander.c	2017-11-01 15:31:03 -0700
@@ -16,6 +16,16 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: - Added a special case for collecting the new Precursor ship energy blip.
+//			 - Tweaked hopping hatchling so it is invulnerable whilst inside its egg.
+//			 - Made Wackodemon explode upon dying with a certain chance, dealing damage to other critters and lander.
+//			 - Increased Wackodemon biovalue since its more hazardous to hunt now.
+//			 - Created a new function which enables the biocritters to shoot projectiles. Quartzerback critter uses this function.
+//			 - Dumpy Dweejus divides into smaller creatures when "killed".
+//			 - Created a new function which handles the exploding and dividing critters upon their death
+
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
 #include "lander.h"
 
 #include "lifeform.h"
@@ -35,12 +45,12 @@
 #include "../element.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/mathlib.h"
-#include "libs/log.h"
-
+#include "libs/log.h" //added to aid in debugging of new functions DN 29DEC10
+#include "../load.h"
 
 //define SPIN_ON_LAUNCH to let the planet spin while
 // the lander animation is playing
-#define SPIN_ON_LAUNCH
+#define SPIN_ON_LAUNCH 1
 
 // PLANET_SIDE_RATE governs how fast the lander,
 // bio and planet effects will be
@@ -51,6 +61,16 @@
 #define PLANET_SIDE_RATE (ONE_SECOND / 35)
 
 
+/*
+ * creature_data_index is populated by the collision detection 
+ * routine and reset back to -1 by the FillLanderHold method. 
+ * this is so we can keep track of what kind of life forms the
+ * player has scooped up. 
+ *
+ * DN 29DEC10
+ */
+int creature_data_index = -1;
+
 // This is a derived type from INPUT_STATE_DESC.
 typedef struct LanderInputState LanderInputState;
 struct LanderInputState {
@@ -62,7 +82,7 @@ struct LanderInputState {
 			// Frame rate control
 };
 
-FRAME LanderFrame[8];
+FRAME LanderFrame[10]; // JMS: Was 8, added one slot for critter explosion frames and one for dividing critter's small frames.
 static SOUND LanderSounds;
 MUSIC_REF LanderMusic;
 #define NUM_ORBIT_THEMES 5
@@ -70,59 +90,115 @@ static MUSIC_REF OrbitMusic[NUM_ORBIT_TH
 
 const LIFEFORM_DESC CreatureData[] =
 {
-	{SPEED_MOTIONLESS | DANGER_HARMLESS, MAKE_BYTE (1, 1)},
+  {SPEED_MOTIONLESS | DANGER_HARMLESS, MAKE_BYTE (1, 1), 4, NONE},
 			// Roto-Dendron
-	{SPEED_MOTIONLESS | DANGER_HARMLESS, MAKE_BYTE (6, 1)},
+	{SPEED_MOTIONLESS | DANGER_HARMLESS, MAKE_BYTE (6, 1), 4, NONE},
 			// Macrocillia
-	{SPEED_MOTIONLESS | DANGER_WEAK, MAKE_BYTE (3, 1)},
+	{SPEED_MOTIONLESS | DANGER_WEAK, MAKE_BYTE (3, 1), 4, NONE},
 			// Splort Wort
-	{SPEED_MOTIONLESS | DANGER_NORMAL, MAKE_BYTE (5, 3)},
+	{SPEED_MOTIONLESS | DANGER_NORMAL, MAKE_BYTE (5, 3), 4, NONE},
 			// Whackin' Bush
-	{SPEED_MOTIONLESS | DANGER_HARMLESS, MAKE_BYTE (2, 10)},
+	{SPEED_MOTIONLESS | DANGER_HARMLESS, MAKE_BYTE (2, 10), 4, NONE},
 			// Slot Machine Tree
-	{BEHAVIOR_UNPREDICTABLE | SPEED_SLOW | DANGER_HARMLESS, MAKE_BYTE (1, 2)},
+	{BEHAVIOR_UNPREDICTABLE | SPEED_SLOW | DANGER_HARMLESS, MAKE_BYTE (1, 2), 4, NONE},
 			// Neon Worm
-	{BEHAVIOR_FLEE | AWARENESS_MEDIUM | SPEED_SLOW | DANGER_HARMLESS, MAKE_BYTE (8, 5)},
+	{BEHAVIOR_FLEE | AWARENESS_MEDIUM | SPEED_SLOW | DANGER_HARMLESS, MAKE_BYTE (8, 5), 4, NONE},
 			// Stiletto Urchin
-	{BEHAVIOR_HUNT | AWARENESS_LOW | SPEED_SLOW | DANGER_WEAK, MAKE_BYTE (2, 2)},
+	{BEHAVIOR_HUNT | AWARENESS_LOW | SPEED_SLOW | DANGER_WEAK, MAKE_BYTE (2, 2), 4, NONE},
 			// Deluxe Blob
-	{BEHAVIOR_UNPREDICTABLE | SPEED_SLOW | DANGER_NORMAL, MAKE_BYTE (3, 8)},
+	{BEHAVIOR_UNPREDICTABLE | SPEED_SLOW | DANGER_NORMAL, MAKE_BYTE (3, 8), 4, NONE},
 			// Glowing Medusa
-	{BEHAVIOR_HUNT | AWARENESS_MEDIUM | SPEED_SLOW | DANGER_MONSTROUS, MAKE_BYTE (10, 15)},
+	{BEHAVIOR_HUNT | AWARENESS_MEDIUM | SPEED_SLOW | DANGER_MONSTROUS, MAKE_BYTE (10, 15), 4, NONE},
 			// Carousel Beast
-	{BEHAVIOR_HUNT | AWARENESS_MEDIUM | SPEED_MEDIUM | DANGER_WEAK, MAKE_BYTE (3, 3)},
+	{BEHAVIOR_HUNT | AWARENESS_MEDIUM | SPEED_MEDIUM | DANGER_WEAK, MAKE_BYTE (3, 3), 4, NONE},
 			// Mysterious Bees
-	{BEHAVIOR_FLEE | AWARENESS_MEDIUM | SPEED_MEDIUM | DANGER_HARMLESS, MAKE_BYTE (2, 1)},
+	{BEHAVIOR_FLEE | AWARENESS_MEDIUM | SPEED_MEDIUM | DANGER_HARMLESS, MAKE_BYTE (2, 1), 4, NONE},
 			// Hopping Blobby
-	{BEHAVIOR_UNPREDICTABLE | SPEED_MEDIUM | DANGER_WEAK, MAKE_BYTE (2, 2)},
+	{BEHAVIOR_UNPREDICTABLE | SPEED_MEDIUM | DANGER_WEAK, MAKE_BYTE (2, 2), 4, NONE},
 			// Blood Monkey
-	{BEHAVIOR_HUNT | AWARENESS_HIGH | SPEED_MEDIUM | DANGER_NORMAL, MAKE_BYTE (4, 6)},
+	{BEHAVIOR_HUNT | AWARENESS_HIGH | SPEED_MEDIUM | DANGER_NORMAL, MAKE_BYTE (4, 6), 4, NONE},
 			// Yompin Yiminy
-	{BEHAVIOR_UNPREDICTABLE | SPEED_MEDIUM | DANGER_MONSTROUS, MAKE_BYTE (9, 12)},
+	{BEHAVIOR_UNPREDICTABLE | SPEED_MEDIUM | DANGER_MONSTROUS, MAKE_BYTE (9, 12), 4, NONE},
 			// Amorphous Trandicula
-	{BEHAVIOR_HUNT | AWARENESS_HIGH | SPEED_FAST | DANGER_WEAK, MAKE_BYTE (3, 1)},
+	{BEHAVIOR_HUNT | AWARENESS_HIGH | SPEED_FAST | DANGER_WEAK, MAKE_BYTE (3, 1), 4, NONE},
 			// Crazy Weasel
-	{BEHAVIOR_FLEE | AWARENESS_HIGH | SPEED_FAST | DANGER_HARMLESS, MAKE_BYTE (1, 1)},
+	{BEHAVIOR_FLEE | AWARENESS_HIGH | SPEED_FAST | DANGER_HARMLESS, MAKE_BYTE (1, 1), 4, NONE},
 			// Merry Whumpet
-	{BEHAVIOR_HUNT | AWARENESS_LOW | SPEED_FAST | DANGER_NORMAL, MAKE_BYTE (7, 8)},
+	{BEHAVIOR_HUNT | AWARENESS_LOW | SPEED_FAST | DANGER_NORMAL, MAKE_BYTE (7, 8), 4, NONE},
 			// Fungal Squid
-	{BEHAVIOR_FLEE | AWARENESS_HIGH | SPEED_FAST | DANGER_WEAK, MAKE_BYTE (15, 2)},
+	{BEHAVIOR_FLEE | AWARENESS_HIGH | SPEED_FAST | DANGER_WEAK, MAKE_BYTE (15, 2), 4, NONE},
 			// Penguin Cyclops
-	{BEHAVIOR_FLEE | AWARENESS_LOW | SPEED_FAST | DANGER_WEAK, MAKE_BYTE (1, 1)},
+	{BEHAVIOR_FLEE | AWARENESS_LOW | SPEED_FAST | DANGER_WEAK, MAKE_BYTE (1, 1), 4, NONE},
 			// Chicken
-	{BEHAVIOR_UNPREDICTABLE | SPEED_SLOW | DANGER_WEAK, MAKE_BYTE (6, 2)},
+	{BEHAVIOR_UNPREDICTABLE | SPEED_SLOW | DANGER_WEAK, MAKE_BYTE (6, 2), 4, NONE},
 			// Bubble Vine
-	{BEHAVIOR_FLEE | AWARENESS_HIGH | SPEED_SLOW | DANGER_WEAK, MAKE_BYTE (4, 2)},
+	{BEHAVIOR_FLEE | AWARENESS_HIGH | SPEED_SLOW | DANGER_WEAK, MAKE_BYTE (4, 2), 4, NONE},
 			// Bug-Eyed Bait
-	{SPEED_MOTIONLESS | DANGER_WEAK, MAKE_BYTE (8, 5)},
+	{SPEED_MOTIONLESS | DANGER_WEAK, MAKE_BYTE (8, 5), 4, NONE},
 			// Goo Burger
-
-	{SPEED_MOTIONLESS | DANGER_MONSTROUS, MAKE_BYTE (1, 1)},
+	{SPEED_MOTIONLESS | DANGER_MONSTROUS, MAKE_BYTE (1, 1), 4, NONE},
 			// Evil One
-	{BEHAVIOR_UNPREDICTABLE | SPEED_SLOW | DANGER_HARMLESS, MAKE_BYTE (0, 1)},
+	{BEHAVIOR_UNPREDICTABLE | SPEED_SLOW | DANGER_HARMLESS, MAKE_BYTE (0, 1), 4, NONE},
 			// Brainbox Bulldozers
-	{BEHAVIOR_HUNT | AWARENESS_HIGH | SPEED_FAST | DANGER_MONSTROUS, MAKE_BYTE (15, 15)},
+	{BEHAVIOR_HUNT | AWARENESS_HIGH | SPEED_FAST | DANGER_MONSTROUS, MAKE_BYTE (15, 15), 4, NONE},
 			// Zex's Beauty
+
+	// ---- New Critters from here on ----
+	/* AREA B CRITTERS: creatures appearing in the southern region */
+	{SPEED_MOTIONLESS | DANGER_HARMLESS, MAKE_BYTE (1, 3), 5, NONE},
+			// Echinosol
+	{SPEED_MOTIONLESS | DANGER_WEAK, MAKE_BYTE (3, 1), 2, NONE},
+			// Flora Flatulensis
+	{SPEED_MOTIONLESS | DANGER_HARMLESS, MAKE_BYTE (6, 1), 2, INVULNERABLE_PART_TIME},
+			// Hopping Hatchling
+#define HOPPING_HATCHLING_INVULNERABILITY_FRAMES 45 // JMS: XXX, This is still kinda hacky.
+	{BEHAVIOR_FLEE | AWARENESS_MEDIUM | SPEED_SLOW | DANGER_HARMLESS, MAKE_BYTE (8, 5), 2, NONE},
+			// Dizzy Fnarble
+	{BEHAVIOR_FLEE | AWARENESS_HIGH | SPEED_FAST | DANGER_HARMLESS, MAKE_BYTE (1, 1), 2, NONE},
+			// Flagellum Pest
+	{BEHAVIOR_FLEE | AWARENESS_LOW | SPEED_FAST | DANGER_WEAK, MAKE_BYTE (2, 1), 1, NONE},
+			// Flying O'Hairy
+	{BEHAVIOR_UNPREDICTABLE | SPEED_MEDIUM | DANGER_WEAK, MAKE_BYTE (2, 2), 2, SHOOTS_LIMPET},
+			// Bobbing Whibbit
+	{BEHAVIOR_UNPREDICTABLE | SPEED_SLOW | DANGER_NORMAL, MAKE_BYTE (3, 8), 2, NONE},
+			// Muddy Morphlegm
+	{BEHAVIOR_UNPREDICTABLE | SPEED_SLOW | DANGER_WEAK, MAKE_BYTE (6, 2), 2, NONE},
+			// Ultramoeba
+	{BEHAVIOR_HUNT | AWARENESS_HIGH | SPEED_FAST | DANGER_WEAK, MAKE_BYTE (3, 1), 3, NONE},
+			// Electroptera
+	{BEHAVIOR_HUNT | AWARENESS_HIGH | SPEED_MEDIUM | DANGER_NORMAL, MAKE_BYTE (4, 6), 2, SHOOTS_LASER},
+			// Quartzerback
+	{BEHAVIOR_HUNT | AWARENESS_MEDIUM | SPEED_MEDIUM | DANGER_WEAK, MAKE_BYTE (3, 3), 2, NONE},
+			// Tuberus Humungus
+	{SPEED_MOTIONLESS | DANGER_NORMAL, MAKE_BYTE (5, 3), 2, NONE},
+			// Venus Frytrap
+	/* AREA C CRITTERS: creatures appearing in the western region */
+	{SPEED_MOTIONLESS | DANGER_HARMLESS, MAKE_BYTE (2, 10), 5, NONE},
+			// Watchful Willow
+	{SPEED_MOTIONLESS | DANGER_WEAK, MAKE_BYTE (8, 5), 1, NONE},
+			// Xerophytic Autovore
+	{BEHAVIOR_FLEE | AWARENESS_HIGH | SPEED_FAST | DANGER_WEAK, MAKE_BYTE (15, 2), 3, NONE},
+			// Migrator Blimp
+	{BEHAVIOR_FLEE | AWARENESS_HIGH | SPEED_SLOW | DANGER_WEAK, MAKE_BYTE (4, 2), 5, NONE},
+			// Tentacle Du Jour
+	{BEHAVIOR_FLEE | AWARENESS_MEDIUM | SPEED_MEDIUM | DANGER_HARMLESS, MAKE_BYTE (2, 1), 2, NONE},
+			// Vanishing Vermin
+	{BEHAVIOR_UNPREDICTABLE | SPEED_SLOW | DANGER_HARMLESS, MAKE_BYTE (1, 2), 5, NONE},
+			// Tripazoid Tumbler
+	{BEHAVIOR_UNPREDICTABLE | SPEED_MEDIUM | DANGER_MONSTROUS, MAKE_BYTE (9, 6), 2, WHEN_DYING_DIVIDES},
+			// Dumpy Dweejus
+	{BEHAVIOR_HUNT | AWARENESS_MEDIUM | SPEED_SLOW | DANGER_MONSTROUS, MAKE_BYTE (10, 15), 1, INVULNERABLE_TO_BASIC_WEAPON},
+			// Radial Arachnid
+	{BEHAVIOR_HUNT | AWARENESS_LOW | SPEED_SLOW | DANGER_WEAK, MAKE_BYTE (7, 2), 0, WHEN_DYING_EXPLODES},
+			// Wackodemon
+	{BEHAVIOR_HUNT | AWARENESS_LOW | SPEED_FAST | DANGER_NORMAL, MAKE_BYTE (7, 8), 2, NONE},
+			// Crabby Octopus
+	{BEHAVIOR_UNPREDICTABLE | SPEED_FAST | DANGER_NORMAL, MAKE_BYTE (9, 8), 2, NONE},
+			// Blinking Beholder
+	{BEHAVIOR_FLEE | AWARENESS_MEDIUM | SPEED_MEDIUM | DANGER_WEAK, MAKE_BYTE (4, 5), 3, NONE},
+			// Creeping head
+	{SPEED_MOTIONLESS | DANGER_MONSTROUS, MAKE_BYTE (3, 5), 4, NONE},
+			// Mineral Monster
 };
 
 
@@ -141,6 +217,9 @@ extern PRIM_LINKS DisplayLinks;
 
 #define DEATH_EXPLOSION 0
 
+#define BIOCRITTER_PROJECTILE 4 // JMS: Chose 4 and 5 so they wouldn't mix up with EARTHQUAKE, LIGHTNING and LAVASPOT _DISASTERS.
+#define BIOCRITTER_LIMPET 5
+
 // TODO: redefine these in terms of CONTEXT width/height
 #define SURFACE_WIDTH SIS_SCREEN_WIDTH
 #define SURFACE_HEIGHT (SIS_SCREEN_HEIGHT - MAP_HEIGHT - MAP_BORDER_HEIGHT)
@@ -151,7 +230,7 @@ extern PRIM_LINKS DisplayLinks;
 #define ADD_AT_END (1 << 4)
 #define REPAIR_COUNT (0xf)
 
-#define LANDER_SPEED_DENOM 10
+#define LANDER_SPEED_DENOM (10) // JMS_GFX
 
 static BYTE lander_flags;
 static POINT curLanderLoc;
@@ -209,13 +288,137 @@ DamageColorCycle (Color c, COUNT i)
 }
 
 static HELEMENT AddGroundDisaster (COUNT which_disaster);
+void object_animation (ELEMENT *ElementPtr);
+
+// JMS: This is a new function, which adds limpets to the lander status window.
+FRAME
+ModifyLanderSilhouette ()
+{
+	FRAME f;
+	STAMP s;
+	RECT r, or;
+	INTERSECT_CONTROL LanderIntersect, ObjectIntersect;
+	CONTEXT OldContext;
+	
+	f = 0;
+	s.frame = SetAbsFrameIndex (LanderFrame[8], 26); // JMS: first limpet frame
+	ObjectIntersect.IntersectStamp = s;
+	GetFrameRect (ObjectIntersect.IntersectStamp.frame, &or);
+	
+	LanderIntersect.IntersectStamp.frame = SetAbsFrameIndex (LanderFrame[8], 30); // JMS: lander hull frame
+	if (LanderIntersect.IntersectStamp.frame == 0)
+		return (0);
+	GetFrameRect (LanderIntersect.IntersectStamp.frame, &r);
+	
+	LanderIntersect.IntersectStamp.origin.x = 0;
+	LanderIntersect.IntersectStamp.origin.y = 0;
+	LanderIntersect.EndPoint = LanderIntersect.IntersectStamp.origin;
+	
+	do
+	{
+		ObjectIntersect.IntersectStamp.origin.x = ((COUNT)TFB_Random () % (r.extent.width - or.extent.width));
+		ObjectIntersect.IntersectStamp.origin.y = ((COUNT)TFB_Random () % (r.extent.height - or.extent.height));
+		ObjectIntersect.EndPoint = ObjectIntersect.IntersectStamp.origin;
+	} while (!DrawablesIntersect (&ObjectIntersect, &LanderIntersect, MAX_TIME_VALUE));
+		
+	ObjectIntersect.IntersectStamp.origin.x += 23 << RESOLUTION_FACTOR;
+	ObjectIntersect.IntersectStamp.origin.y += 187 << RESOLUTION_FACTOR;
+	
+	OldContext = SetContext (StatusContext);
+	DrawStamp (&ObjectIntersect.IntersectStamp);
+	SetContext (OldContext);
+	
+	return (f);
+}
+
+// JMS: This is a new function, which creates a biocritter's laser shot.
+static void
+AddEnemyShot (ELEMENT *CritterElementPtr, COUNT angle, COUNT speed)
+{
+	HELEMENT hWeaponElement;
+	
+	hWeaponElement = AllocElement ();
+	if (hWeaponElement)
+	{
+		ELEMENT *WeaponElementPtr;
+		COUNT shotFrameIndex;
+		
+		// JMS: Get the shot's PNG frame from its angle. Constrain the frame number to 15, 
+		// since for some reason this crap went to 16 with this kinda setup, but sometimes went to -1 if I subtracted 1 from the result.
+		if ((shotFrameIndex = ANGLE_TO_FACING (NORMALIZE_ANGLE(angle))) > 15)
+			shotFrameIndex = 15;
+			
+		LockElement (hWeaponElement, &WeaponElementPtr);
+		
+		WeaponElementPtr->mass_points = BIOCRITTER_PROJECTILE;
+		WeaponElementPtr->life_span = 12;
+		WeaponElementPtr->state_flags = FINITE_LIFE;
+		WeaponElementPtr->playerNr = PS_NON_PLAYER; // JMS: Lander's own shots have PS_HUMAN_PLAYER. Baddies have PS_NON_PLAYER.
+		WeaponElementPtr->next.location = CritterElementPtr->next.location;
+		
+		SetPrimType (&DisplayArray[WeaponElementPtr->PrimIndex], STAMP_PRIM);
+		
+		// JMS: Let's use LanderFrame[8] instead of [0] so the game doesn't think this shot belongs to lander (which uses LanderFrame[0]).
+		DisplayArray[WeaponElementPtr->PrimIndex].Object.Stamp.frame = SetAbsFrameIndex (LanderFrame[8], shotFrameIndex); 
+		
+		SetVelocityComponents (&WeaponElementPtr->velocity, 
+							   COSINE (angle, WORLD_TO_VELOCITY (6 << RESOLUTION_FACTOR)) + speed,
+							   SINE   (angle, WORLD_TO_VELOCITY (6 << RESOLUTION_FACTOR)) + speed);
+		
+		UnlockElement (hWeaponElement);
+		InsertElement (hWeaponElement, GetHeadElement ());
+		
+		PlaySound (SetAbsSoundIndex (LanderSounds, LANDER_SHOOTS), NotPositional (), NULL, GAME_SOUND_PRIORITY);
+	}
+}
+
+// JMS: This is a new function, which creates a biocritter's limpet shot.
+static void
+AddEnemyLimpet (ELEMENT *CritterElementPtr, COUNT shot_angle, COUNT critter_angle, COUNT speed)
+{
+	HELEMENT hWeaponElement;
+	
+	hWeaponElement = AllocElement ();
+	if (hWeaponElement)
+	{
+		ELEMENT *WeaponElementPtr;
+		COUNT shotFrameIndex;
+		
+		shotFrameIndex = 26;
+		
+		LockElement (hWeaponElement, &WeaponElementPtr);
+		
+		WeaponElementPtr->mass_points = BIOCRITTER_LIMPET;
+		WeaponElementPtr->life_span = LIMPET_LIFESPAN;
+		WeaponElementPtr->state_flags = FINITE_LIFE;
+		WeaponElementPtr->playerNr = PS_NON_PLAYER;
+		WeaponElementPtr->next.location = CritterElementPtr->next.location;
+		WeaponElementPtr->preprocess_func = object_animation;
+		
+		SetPrimType (&DisplayArray[WeaponElementPtr->PrimIndex], STAMP_PRIM);
+		
+		// JMS: Let's use LanderFrame[8] instead of [0] so the game doesn't think this shot belongs to lander (which uses LanderFrame[0]).
+		DisplayArray[WeaponElementPtr->PrimIndex].Object.Stamp.frame = SetAbsFrameIndex (LanderFrame[8], shotFrameIndex); 
+		
+		// JMS: The critter's own speed is decreased from the limpet speed to give constant speed for the limpet.
+		SetVelocityComponents (&WeaponElementPtr->velocity, 
+							   COSINE (shot_angle, LIMPET_ACCEL) + COSINE (critter_angle, speed),
+							   SINE   (shot_angle, LIMPET_ACCEL) + SINE   (critter_angle, speed));
+		
+		UnlockElement (hWeaponElement);
+		InsertElement (hWeaponElement, GetHeadElement ());
+		
+		PlaySound (SetAbsSoundIndex (LanderSounds, LANDER_SHOOTS), NotPositional (), NULL, GAME_SOUND_PRIORITY);
+		
+	}
+}
 
 void
 object_animation (ELEMENT *ElementPtr)
 {
-	COUNT frame_index, angle;
+	COUNT frame_index, angle, hunt_angle; // JMS: Added the hunt_angle
 	PRIMITIVE *pPrim;
-
+	
 	pPrim = &DisplayArray[ElementPtr->PrimIndex];
 	if (GetPrimType (pPrim) == STAMPFILL_PRIM
 			&& !((ElementPtr->state_flags & FINITE_LIFE)
@@ -230,18 +433,16 @@ object_animation (ELEMENT *ElementPtr)
 			if (ElementPtr->hit_points == 0)
 			{
 				ZeroVelocityComponents (&ElementPtr->velocity);
-				pPrim->Object.Stamp.frame =
-						SetAbsFrameIndex (pPrim->Object.Stamp.frame, 0);
-
-				PlaySound (SetAbsSoundIndex (LanderSounds, LIFEFORM_CANNED),
-						NotPositional (), NULL, GAME_SOUND_PRIORITY);
+				pPrim->Object.Stamp.frame = SetAbsFrameIndex (pPrim->Object.Stamp.frame, 0);
+				PlaySound (SetAbsSoundIndex (LanderSounds, LIFEFORM_CANNED), NotPositional (), NULL, GAME_SOUND_PRIORITY);
 			}
 		}
 
 		SetPrimColor (pPrim, c);
 	}
-
+	
 	frame_index = GetFrameIndex (pPrim->Object.Stamp.frame) + 1;
+
 	if (LONIBBLE (ElementPtr->turn_wait))
 		--ElementPtr->turn_wait;
 	else
@@ -258,22 +459,78 @@ object_animation (ELEMENT *ElementPtr)
 				++explosion_index;
 				if (explosion_index >= EXPLOSION_LIFE)
 				{	// XXX: The last frame is drawn twice
-					pPrim->Object.Stamp.frame =
-							DecFrameIndex (pPrim->Object.Stamp.frame);
+					pPrim->Object.Stamp.frame = DecFrameIndex (pPrim->Object.Stamp.frame);
 				}
 			}
+			// JMS: Since Biocritter explosion doesn't use pMS->Curstate to keep track of which frame the explosion is in (like DEATH_EXPLOSION does),
+			// we must limit the number of explosion frames with a constant number. (Critter laser shots never reach this 'if'.)
+			else if (ElementPtr->mass_points == BIOCRITTER_PROJECTILE)
+			{
+				int k;
+				
+				if (frame_index >= 26)
+					pPrim->Object.Stamp.frame = DecFrameIndex (pPrim->Object.Stamp.frame);
+				
+				// JMS: Add earthquakes and fire to accompany the explosion just for the heck of it!
+				for (k = 0; k < 2; k++)
+				{
+					AddGroundDisaster (EARTHQUAKE_DISASTER);
+					AddGroundDisaster (LAVASPOT_DISASTER);
+				}
+			}
+			else if (ElementPtr->mass_points == BIOCRITTER_LIMPET)
+			{
+				SIZE ldx, ldy;
+				SIZE current_limpet_speed;
+				COUNT limpet_angle;
+				
+				ldx = curLanderLoc.x - ElementPtr->next.location.x;
+				ldy = curLanderLoc.y - ElementPtr->next.location.y;
+				
+				if (ldx < 0 && ldx < -(MAP_WIDTH << (MAG_SHIFT - 1)))
+					ldx += MAP_WIDTH << MAG_SHIFT;
+				else if (ldx > (MAP_WIDTH << (MAG_SHIFT - 1)))
+					ldx -= MAP_WIDTH << MAG_SHIFT;
+			
+				// Angle is now set straight towards the lander.
+				limpet_angle = ARCTAN (ldx, ldy);
+				
+				// 1. The first possible method for homing projectiles:
+				// Accelerate the limpet to a new direction
+				DeltaVelocityComponents (&ElementPtr->velocity, COSINE (limpet_angle, LIMPET_ACCEL),SINE (limpet_angle, LIMPET_ACCEL));
+				// Compare the new velocity to a maximum. Force the velocity to not exceed the limit.
+				GetCurrentVelocityComponents (&ElementPtr->velocity, &ldx, &ldy);
+				current_limpet_speed = square_root ((long)ldx * ldx + (long)ldy * ldy);
+				if (current_limpet_speed > LIMPET_MAX_SPEED)
+				{
+					ldx = (ldx * LIMPET_MAX_SPEED * LIMPET_MAX_SPEED) / (current_limpet_speed * current_limpet_speed);
+					ldy = (ldy * LIMPET_MAX_SPEED * LIMPET_MAX_SPEED) / (current_limpet_speed * current_limpet_speed);
+					SetVelocityComponents (&ElementPtr->velocity, ldx, ldy);
+				}
+				//
+				// 2. The second possible method for homing projectiles:
+				// SetVelocityComponents (&ElementPtr->velocity, COSINE (limpet_angle, LIMPET_MAX_SPEED),SINE (limpet_angle, LIMPET_MAX_SPEED));
+				
+				// JMS: Cycle the limpet frames
+				if (frame_index >= 30)
+					pPrim->Object.Stamp.frame = SetAbsFrameIndex (pPrim->Object.Stamp.frame, 26);
+				
+			}
 			else if (ElementPtr->mass_points == EARTHQUAKE_DISASTER)
 			{
 				SIZE s;
-
-				if (frame_index >= 13)
+				SIZE frame_amount; // JMS_GFX
+	
+				frame_amount = 14;
+				
+				if (frame_index >= (frame_amount-1))
 					s = 0;
 				else
-					s = (14 - frame_index) >> 1;
+					s = (frame_amount - frame_index) >> 1;
 				// XXX: Was 0x8000 the background flag on 3DO?
 				//SetPrimColor (pPrim, BUILD_COLOR (0x8000 | MAKE_RGB15 (0x1F, 0x1F, 0x1F), s));
 				SetPrimColor (pPrim, BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x1F), s));
-				if (frame_index == 13)
+				if (frame_index == (frame_amount - 1))
 					PlaySound (SetAbsSoundIndex (LanderSounds, EARTHQUAKE_DISASTER),
 							NotPositional (), NULL, GAME_SOUND_PRIORITY);
 			}
@@ -293,8 +550,9 @@ object_animation (ELEMENT *ElementPtr)
 					angle = FACING_TO_ANGLE (ElementPtr->facing);
 					LockElement (hLavaElement, &LavaElementPtr);
 					LavaElementPtr->next.location = ElementPtr->next.location;
-					LavaElementPtr->next.location.x += COSINE (angle, 4);
-					LavaElementPtr->next.location.y += SINE (angle, 4);
+					LavaElementPtr->next.location.x += COSINE (angle, 4 << RESOLUTION_FACTOR); // JMS_GFX
+					LavaElementPtr->next.location.y += SINE (angle, 4 << RESOLUTION_FACTOR); // JMS_GFX
+					
 					if (LavaElementPtr->next.location.y < 0)
 						LavaElementPtr->next.location.y = 0;
 					else if (LavaElementPtr->next.location.y >= (MAP_HEIGHT << MAG_SHIFT))
@@ -316,6 +574,7 @@ object_animation (ELEMENT *ElementPtr)
 
 			index = ElementPtr->mass_points & ~CREATURE_AWARE;
 			speed = CreatureData[index].Attributes & SPEED_MASK;
+			
 			if (speed)
 			{
 				SIZE dx, dy;
@@ -327,13 +586,16 @@ object_animation (ELEMENT *ElementPtr)
 				else if (dx > (MAP_WIDTH << (MAG_SHIFT - 1)))
 					dx -= MAP_WIDTH << MAG_SHIFT;
 				dy = curLanderLoc.y - ElementPtr->next.location.y;
-				angle = ARCTAN (dx, dy);
+				angle = ARCTAN (dx, dy); // At this point, the critter heads straight towards the lander.
+				hunt_angle = angle; // JMS
+				
 				if (dx < 0)
 					dx = -dx;
 				if (dy < 0)
 					dy = -dy;
 
-				if (dx >= SURFACE_WIDTH || dy >= SURFACE_WIDTH
+				if (dx >= SURFACE_WIDTH 
+						|| dy >= SURFACE_WIDTH
 						|| dx * dx + dy * dy >= SURFACE_WIDTH * SURFACE_WIDTH)
 					ElementPtr->mass_points &= ~CREATURE_AWARE;
 				else if (!(ElementPtr->mass_points & CREATURE_AWARE))
@@ -360,12 +622,11 @@ object_animation (ELEMENT *ElementPtr)
 					}
 				}
 
-				if (ElementPtr->next.location.y == 0
-						|| ElementPtr->next.location.y ==
-						(MAP_HEIGHT << MAG_SHIFT) - 1)
+				if (ElementPtr->next.location.y == 0 || ElementPtr->next.location.y == (MAP_HEIGHT << MAG_SHIFT) - 1)
 					ElementPtr->thrust_wait = 0;
 
 				old_angle = GetVelocityTravelAngle (&ElementPtr->velocity);
+				
 				if (ElementPtr->thrust_wait)
 				{
 					--ElementPtr->thrust_wait;
@@ -391,8 +652,7 @@ object_animation (ELEMENT *ElementPtr)
 					{
 						if (angle & (HALF_CIRCLE - 1))
 							angle = HALF_CIRCLE - angle;
-						else if (old_angle == QUADRANT
-								|| old_angle == (FULL_CIRCLE - QUADRANT))
+						else if (old_angle == QUADRANT || old_angle == (FULL_CIRCLE - QUADRANT))
 							angle = old_angle;
 						else
 							angle = ((TFB_Random () & 1)
@@ -414,9 +674,33 @@ object_animation (ELEMENT *ElementPtr)
 						speed = WORLD_TO_VELOCITY (2 * 1) * 9 / 10;
 						break;
 				}
+				speed = speed << RESOLUTION_FACTOR; // JMS_GFX
 
-				SetVelocityComponents (&ElementPtr->velocity,
-						COSINE (angle, speed), SINE (angle, speed));
+				SetVelocityComponents (&ElementPtr->velocity, COSINE (angle, speed), SINE (angle, speed));
+
+#define MAX_ENEMYSHOT_DISTANCE (100 << RESOLUTION_FACTOR) // JMS
+				// JMS: Shooting critters may fire now if they're close enough and are at the correct PNG frame.
+				// This way the fire rate can be (a bit hackily) controlled by adding frames to the .ani file.
+				//
+				// Also, the critters don't shoot if the lander hasn't yet completely landed on the planet.
+				{
+					BYTE creatureHasWeapon;
+					creatureHasWeapon = CreatureData[index].SpecialAttributes & SHOOTING_SPECIALS;
+					
+					if (creatureHasWeapon
+						&& frame_index == 4
+						&& (ElementPtr->mass_points & CREATURE_AWARE)
+						&& !((planetSideDesc)->InTransit)
+						&& (dx <= MAX_ENEMYSHOT_DISTANCE 
+							&& dy <= MAX_ENEMYSHOT_DISTANCE
+							&& dx * dx + dy * dy <= MAX_ENEMYSHOT_DISTANCE * MAX_ENEMYSHOT_DISTANCE))
+					{
+						if (creatureHasWeapon & SHOOTS_LASER) 
+							AddEnemyShot(ElementPtr, angle, speed);
+						else if (creatureHasWeapon & SHOOTS_LIMPET)
+							AddEnemyLimpet(ElementPtr, hunt_angle, angle, speed);
+					}
+				}
 			}
 		}
 	}
@@ -468,8 +752,21 @@ DeltaLanderCrew (SIZE crew_delta, COUNT
 				NotPositional (), NULL, GAME_SOUND_PRIORITY);
 	}
 
-	s.origin.x = 11 + (6 * (crew_delta % NUM_CREW_COLS));
-	s.origin.y = 35 - (6 * (crew_delta / NUM_CREW_COLS));
+	if (RESOLUTION_FACTOR == 0)
+	{
+		s.origin.x = ((11 + ((6 << RESOLUTION_FACTOR) * (crew_delta % NUM_CREW_COLS)))); // JMS_GFX
+		s.origin.y = (35 - (6 * (crew_delta / NUM_CREW_COLS))) << RESOLUTION_FACTOR; // JMS_GFX
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		s.origin.x = ((23 + ((6 << RESOLUTION_FACTOR) * (crew_delta % NUM_CREW_COLS)))); // JMS_GFX
+		s.origin.y = 1 + ((35 - (6 * (crew_delta / NUM_CREW_COLS))) << RESOLUTION_FACTOR); // JMS_GFX
+	}
+	else
+	{
+		s.origin.x = 32 + ((9 * RESOLUTION_FACTOR) * (crew_delta % NUM_CREW_COLS)); // JMS_GFX
+		s.origin.y = (52 * RESOLUTION_FACTOR - (9 * RESOLUTION_FACTOR * (crew_delta / NUM_CREW_COLS))); // JMS_GFX
+	}
 
 	OldContext = SetContext (RadarContext);
 	DrawStamp (&s);
@@ -487,9 +784,41 @@ FillLanderHold (PLANETSIDE_DESC *pPSD, C
 			NotPositional (), NULL, GAME_SOUND_PRIORITY);
 
 	if (scan == BIOLOGICAL_SCAN)
-	{
+	{	
+			/* Melnorme Easter Egg stuff
+			 * -DN 18JAN11
+			 */
+		switch(creature_data_index)
+		{
+			case 26 : SET_GAME_STATE(MELNORME_ECHINOSOL_TYPE_FOUND, 1); break;
+			case 27 : SET_GAME_STATE(MELNORME_FLORA_FLATULENSIS_TYPE_FOUND, 1); break;
+			case 28 : SET_GAME_STATE(MELNORME_HOPPING_HATCHLING_TYPE_FOUND, 1); break;
+			case 29 : SET_GAME_STATE(MELNORME_DIZZY_FNARBLE_TYPE_FOUND, 1); break;
+			case 30 : SET_GAME_STATE(MELNORME_FLAGELLUM_PEST_TYPE_FOUND, 1); break;
+			case 31 : SET_GAME_STATE(MELNORME_FLYING_OHAIRY_TYPE_FOUND, 1); break;
+			case 32 : SET_GAME_STATE(MELNORME_BOBBING_WHIBBIT_TYPE_FOUND, 1); break;
+			case 33 : SET_GAME_STATE(MELNORME_MUDDY_MORPHLEGM_TYPE_FOUND, 1); break;
+			case 34 : SET_GAME_STATE(MELNORME_ULTRAMOEBA_TYPE_FOUND, 1); break;
+			case 35 : SET_GAME_STATE(MELNORME_ELECTROPTERA_TYPE_FOUND, 1); break;
+			case 36 : SET_GAME_STATE(MELNORME_QUARTZERBACK_TYPE_FOUND, 1); break;
+			case 37 : SET_GAME_STATE(MELNORME_TUBERUS_HUMUNGUS_TYPE_FOUND, 1); break;
+			case 38 : SET_GAME_STATE(MELNORME_VENUS_FRYTRAP_TYPE_FOUND, 1); break;
+			case 39 : SET_GAME_STATE(MELNORME_WATCHFUL_WILLOW_TYPE_FOUND, 1); break;
+			case 40 : SET_GAME_STATE(MELNORME_XEROPHYTIC_AUTOVORE_TYPE_FOUND, 1); break;
+			case 41 : SET_GAME_STATE(MELNORME_MIGRATOR_BLIMP_TYPE_FOUND, 1); break;
+			case 42 : SET_GAME_STATE(MELNORME_TENTACLE_DUJOUR_TYPE_FOUND, 1); break;
+			case 43 : SET_GAME_STATE(MELNORME_VANISHING_VERMIN_TYPE_FOUND, 1); break;
+			case 44 : SET_GAME_STATE(MELNORME_TRIPAZOID_TUMBLER_TYPE_FOUND, 1); break;
+			case 45 : SET_GAME_STATE(MELNORME_DUMPY_DWEEJUS_TYPE_FOUND, 1); break;
+			case 46 : SET_GAME_STATE(MELNORME_RADIAL_ARACHNID_TYPE_FOUND, 1); break;
+			case 47 : SET_GAME_STATE(MELNORME_WACKODEMON_TYPE_FOUND, 1); break;
+			case 48 : SET_GAME_STATE(MELNORME_CRABBY_OCTOPUS_TYPE_FOUND, 1); break;
+			case 49 : SET_GAME_STATE(MELNORME_BLINKING_BEHOLDER_TYPE_FOUND, 1); break;
+			case 50 : SET_GAME_STATE(MELNORME_CREEPING_HEAD_TYPE_FOUND, 1); break;
+		}
+		
+		creature_data_index = -1;	 
 		start_count = pPSD->BiologicalLevel;
-
 		s.frame = SetAbsFrameIndex (LanderFrame[0], 41);
 
 		pPSD->BiologicalLevel += NumRetrieved;
@@ -499,20 +828,26 @@ FillLanderHold (PLANETSIDE_DESC *pPSD, C
 		start_count = pPSD->ElementLevel;
 		pPSD->ElementLevel += NumRetrieved;
 		if (GET_GAME_STATE (IMPROVED_LANDER_CARGO))
-		{
-			start_count >>= 1;
-			NumRetrieved = (pPSD->ElementLevel >> 1) - start_count;
-		}
+			NumRetrieved = (pPSD->ElementLevel >> 1) - (start_count >> 1);
 
 		s.frame = SetAbsFrameIndex (LanderFrame[0], 43);
 	}
-
+	
+	start_count *= RES_STAT_SCALE(1); // JMS_GFX
+	if (GET_GAME_STATE (IMPROVED_LANDER_CARGO))
+		start_count >>= 1;
+	
 	s.origin.x = 0;
-	s.origin.y = -(int)start_count;
+	s.origin.y =  -(int)start_count;
 	if (!(start_count & 1))
 		s.frame = IncFrameIndex (s.frame);
-
+	
 	OldContext = SetContext (RadarContext);
+	
+	NumRetrieved *= RES_STAT_SCALE(1); // JMS_GFX
+	if (GET_GAME_STATE (IMPROVED_LANDER_CARGO) && RESOLUTION_FACTOR > 0)
+		NumRetrieved >>= 1;
+	
 	while (NumRetrieved--)
 	{
 		if (start_count++ & 1)
@@ -520,7 +855,7 @@ FillLanderHold (PLANETSIDE_DESC *pPSD, C
 		else
 			s.frame = DecFrameIndex (s.frame);
 		DrawStamp (&s);
-		--s.origin.y;
+		s.origin.y -= RES_STAT_SCALE(1); // JMS_GFX
 	}
 	SetContext (OldContext);
 }
@@ -534,10 +869,13 @@ pickupMineralNode (PLANETSIDE_DESC *pPSD
 	BYTE EType;
 	UNICODE ch;
 	UNICODE *pStr;
+	
+	// JMS: The rest of partially scavenged minerals stay on the surface.
+	bool partialPickup = false;
 
 	if (pPSD->ElementLevel >= pPSD->MaxElementLevel)
 	{
-		// Lander full
+		// Lander full.
 		PlaySound (SetAbsSoundIndex (LanderSounds, LANDER_FULL),
 				NotPositional (), NULL, GAME_SOUND_PRIORITY);
 		return false;
@@ -545,8 +883,46 @@ pickupMineralNode (PLANETSIDE_DESC *pPSD
 
 	if (pPSD->ElementLevel + NumRetrieved > pPSD->MaxElementLevel)
 	{
+		SIZE which_node;
+		COUNT oldsize = ElementPtr->mass_points;
+		
 		// Deposit could only be picked up partially.
 		NumRetrieved = (COUNT)(pPSD->MaxElementLevel - pPSD->ElementLevel);
+		
+		// JMS: Subtract the scavenged kilotons from the mineral deposit.
+		// The rest will stay on the surface.
+		ElementPtr->mass_points -= NumRetrieved;
+		
+		// JMS: This makes the mineral deposit subtraction keep  
+		// in effect even after leaving & re-entering the planet.
+		which_node = HIBYTE (ElementPtr->scan_node) - 1;
+		pSolarSysState->SysInfo.PlanetInfo.PartiallyScavengedList[MINERAL_SCAN][which_node] = NumRetrieved;
+		
+		// JMS: If the deposit was large and its amount now equates to a smaller
+		// deposit, change its graphics.
+		if ((oldsize > 22 && ElementPtr->mass_points < 22)
+			|| (oldsize > 15 && ElementPtr->mass_points < 15))
+		{
+			PRIMITIVE *pPrim = &DisplayArray[ElementPtr->PrimIndex];
+			BYTE gfx_index_change = 0;
+			
+			if (oldsize > 22 && ElementPtr->mass_points < 15)
+				gfx_index_change = 2;
+			else
+				gfx_index_change = 1;
+			
+			// Change the scan screen gfx.
+			ElementPtr->next.image.frame = SetRelFrameIndex (
+				ElementPtr->current.image.frame, (3 - gfx_index_change));
+			
+			// Notify the engine that the scan screen gfx should be updated.
+			ElementPtr->state_flags |= CHANGING;
+			
+			// Change the surface screen gfx.
+			pPrim->Object.Stamp.frame = SetRelFrameIndex (pPrim->Object.Stamp.frame, -gfx_index_change);
+		}
+		
+		partialPickup = true;
 	}
 
 	FillLanderHold (pPSD, MINERAL_SCAN, NumRetrieved);
@@ -561,7 +937,7 @@ pickupMineralNode (PLANETSIDE_DESC *pPSD
 	pPSD->MineralText[0].baseline.x = (SURFACE_WIDTH >> 1)
 			+ (ElementControl->EndPoint.x - LanderControl->EndPoint.x);
 	pPSD->MineralText[0].baseline.y = (SURFACE_HEIGHT >> 1)
-			+ (ElementControl->EndPoint.y - LanderControl->EndPoint.y);
+		+ ((ElementControl->EndPoint.y - LanderControl->EndPoint.y) << RESOLUTION_FACTOR); // JMS_GFX;
 	pPSD->MineralText[0].CharCount = (COUNT)~0;
 	pPSD->MineralText[1].pStr = pStr;
 
@@ -582,7 +958,11 @@ pickupMineralNode (PLANETSIDE_DESC *pPSD
 		pPSD->MineralText[2].CharCount = (COUNT)~0;
 	}
 
-	return true;
+	// JMS
+	if (partialPickup)
+		return false;
+	else
+		return true;
 }
 
 static bool
@@ -607,29 +987,190 @@ pickupBioNode (PLANETSIDE_DESC *pPSD, CO
 	return true;
 }
 
+static int
+CheckSpecialAttributes (ELEMENT *ElementPtr, COUNT WhichSpecial)
+{
+	COUNT WhichCreature;
+	WhichCreature = ElementPtr->mass_points & ~CREATURE_AWARE;
+	
+	if (WhichSpecial == INVULNERABILITY_SPECIALS)
+	{
+		COUNT frame_index;
+		PRIMITIVE *pPrim;
+		pPrim = &DisplayArray[ElementPtr->PrimIndex];
+		frame_index = GetFrameIndex (pPrim->Object.Stamp.frame) + 1;
+		
+		// JMS: The Hopping Hatchling doesn't suffer damage when eye is in the egg.
+		if ((CreatureData[WhichCreature].SpecialAttributes & INVULNERABLE_PART_TIME)
+			&& frame_index < HOPPING_HATCHLING_INVULNERABILITY_FRAMES
+			/*&& !(GET_GAME_STATE(STRONGER_LANDER_SHOT))*/)
+		{
+			return (1);
+		}
+		// JMS: Some creatures can only be killed with upgraded weapon.
+		else if (CreatureData[WhichCreature].SpecialAttributes & INVULNERABLE_TO_BASIC_WEAPON
+				 && !(GET_GAME_STATE(STRONGER_LANDER_SHOT)))
+		{
+			return (1);
+		}
+	}
+	else if (WhichSpecial == WHEN_DYING_SPECIALS)
+	{
+		// JMS: Some critters may explode when killed!!!
+		if (CreatureData[WhichCreature].SpecialAttributes & WHEN_DYING_EXPLODES)
+		{
+			// JMS: Chance of exploding is drawn here from random number. 
+			if ((TFB_Random() % 100) < CRITTER_EXPLOSION_PERCENT)
+			{
+				HELEMENT hExplosionElement;
+				SIZE temp_which_node;
+				
+				hExplosionElement = AllocElement ();
+				if (hExplosionElement)
+				{
+					ELEMENT *ExplosionElementPtr;
+					
+					LockElement (hExplosionElement, &ExplosionElementPtr);
+					
+					ExplosionElementPtr->mass_points = BIOCRITTER_PROJECTILE;
+					ExplosionElementPtr->state_flags = FINITE_LIFE;
+					ExplosionElementPtr->playerNr = PS_NON_PLAYER;
+					ExplosionElementPtr->next.location = ElementPtr->next.location;
+					ExplosionElementPtr->preprocess_func = object_animation;
+					ExplosionElementPtr->turn_wait = MAKE_BYTE (2, 2);
+					ExplosionElementPtr->life_span = EXPLOSION_LIFE * (LONIBBLE (ExplosionElementPtr->turn_wait) + 1);
+					
+					SetPrimType (&DisplayArray[ExplosionElementPtr->PrimIndex], STAMP_PRIM);
+					
+					// JMS: Must use separate LanderFrame instead of LanderFrame[0]:
+					// Otherwise the game thinks this explosion belongs to lander
+					// itself, and it won't collide with lander at all (->no damage).
+					DisplayArray[ExplosionElementPtr->PrimIndex].Object.Stamp.frame = SetAbsFrameIndex (LanderFrame[8], 16);
+					
+					UnlockElement (hExplosionElement);
+					InsertElement (hExplosionElement, GetHeadElement ());
+					
+					PlaySound (SetAbsSoundIndex (LanderSounds, LANDER_DESTROYED), NotPositional (), NULL, GAME_SOUND_PRIORITY + 1);
+					
+					ElementPtr->state_flags |= DISAPPEARING; // JMS: Delete the critter frame
+					ElementPtr->mass_points = 0;			 // JMS: Make sure critter/explosion doesn't give biodata.
+					
+					// JMS: This marks the exploded critter "collected". (even though there was no biodata to collect).
+					// This ensures the critter isn't resurrected when visiting the planet next time.
+					temp_which_node = HIBYTE (ElementPtr->scan_node) - 1;
+					pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[BIOLOGICAL_SCAN] |= (1L << temp_which_node); // Mark this bio-blip's state as "collected".
+					pSolarSysState->CurNode = (COUNT)~0; // GenerateLifeForms will update the states of ALL bio-blips when run.
+					callGenerateForScanType (pSolarSysState, pSolarSysState->pOrbitalDesc, &pSolarSysState->CurNode, BIOLOGICAL_SCAN); // Re-run GenerateLifeForms so the changed state takes effect
+					SET_GAME_STATE (PLANETARY_CHANGE, 1); // Save the changes to the file containing the states of all lifeforms.
+				}
+				
+				return (1); // JMS: Return (1) only if the thing exploded. If not, the return (0) at the end of the function is encountered.
+			}
+		}
+		// JMS: Divisible critter splits into smaller versions of itself when it "dies".
+		else if (CreatureData[WhichCreature].SpecialAttributes & WHEN_DYING_DIVIDES)
+		{
+			COUNT ii;
+			SIZE temp_which_node;
+			
+			for(ii = 0; ii < DIVIDED_CRITTER_NUMBER; ++ii)
+			{
+				HELEMENT hCritterElement;
+				
+				hCritterElement = AllocElement ();
+				if (hCritterElement)
+				{
+					ELEMENT *CritterElementPtr;
+					BYTE CritterIndex;
+					//BYTE which_extra_node;
+					
+					LockElement (hCritterElement, &CritterElementPtr);
+					CritterIndex = (BYTE)43; // JMS XXX: Currently hacked to point to vanishing vermin stats...
+					
+					CritterElementPtr->mass_points = CritterIndex;
+					CritterElementPtr->hit_points = HINIBBLE (CreatureData[CritterIndex].ValueAndHitPoints);
+					CritterElementPtr->playerNr = PS_NON_PLAYER;
+					CritterElementPtr->next.location.x = ElementPtr->next.location.x + (((TFB_Random() % 24) - 12) << RESOLUTION_FACTOR);
+					CritterElementPtr->next.location.y = ElementPtr->next.location.y + (((TFB_Random() % 24) - 12) << RESOLUTION_FACTOR);
+					CritterElementPtr->preprocess_func = object_animation;
+					CritterElementPtr->turn_wait = MAKE_BYTE (0, CreatureData[CritterIndex].FrameRate);
+					CritterElementPtr->thrust_wait = 0;
+					CritterElementPtr->life_span = DIVIDED_CRITTER_LIFESPAN; // JMS XXX: For some reason, we need to have some lifespan here??
+					CritterElementPtr->scan_node = BIOLOGICAL_SCAN; // JMS: This makes the collision check recognize this as bio.
+					
+					SetPrimType (&DisplayArray[CritterElementPtr->PrimIndex], STAMP_PRIM);
+					DisplayArray[CritterElementPtr->PrimIndex].Object.Stamp.frame = SetAbsFrameIndex (LanderFrame[9], 0);
+					
+					UnlockElement (hCritterElement);
+					InsertElement (hCritterElement, GetHeadElement ());
+					
+				}
+			}
+			
+			PlaySound (SetAbsSoundIndex (LanderSounds, LANDER_DEPARTS), NotPositional (), NULL, GAME_SOUND_PRIORITY + 1);
+			
+			ElementPtr->state_flags |= DISAPPEARING; // JMS: Delete the original critter frame
+			ElementPtr->mass_points = 0;			 // JMS: Make sure the original critter doesn't give biodata.
+			
+			// JMS: This marks the big divided critter "collected". (even though there was no biodata to collect).
+			// This ensures the big divided critter isn't resurrected when visiting the planet next time.
+			temp_which_node = HIBYTE (ElementPtr->scan_node) - 1;
+			pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[BIOLOGICAL_SCAN] |= (1L << temp_which_node);
+			pSolarSysState->CurNode = (COUNT)~0;
+			callGenerateForScanType (pSolarSysState, pSolarSysState->pOrbitalDesc, &pSolarSysState->CurNode, BIOLOGICAL_SCAN);
+			SET_GAME_STATE (PLANETARY_CHANGE, 1);
+			
+			return (1);
+		}
+	}
+	
+	return (0);
+}
+
 static void
 shotCreature (ELEMENT *ElementPtr, BYTE value,
 		INTERSECT_CONTROL *LanderControl, PRIMITIVE *pPrim)
 {
+	COUNT frame_index;
+	PRIMITIVE *pPrimFrame;
+	
 	if (ElementPtr->hit_points == 0)
 	{
 		// Creature is already canned.
 		return;
 	}
 
+	pPrimFrame = &DisplayArray[ElementPtr->PrimIndex];
+	frame_index = GetFrameIndex (pPrimFrame->Object.Stamp.frame) + 1;
+	
+	// 1) Critter is invulnerable: stop the function here - critter is unharmed.
+	if (CheckSpecialAttributes(ElementPtr, INVULNERABILITY_SPECIALS))
+	{
+		PlaySound (SetAbsSoundIndex (LanderSounds, BIOLOGICAL_DISASTER), NotPositional (), NULL, GAME_SOUND_PRIORITY);
+		return;
+	}
+	
 	--ElementPtr->hit_points;
 	if (ElementPtr->hit_points == 0)
 	{
-		// Can creature.
-		ElementPtr->mass_points = value;
-		DisplayArray[ElementPtr->PrimIndex].Object.Stamp.frame =
+		// 2) Can creature.
+		if (CheckSpecialAttributes(ElementPtr, WHEN_DYING_SPECIALS))
+		{
+			// JMS: The special cases like exploding/dividing creatures are handled in a separate function.
+		}
+		else
+		{
+			ElementPtr->mass_points = value;
+			DisplayArray[ElementPtr->PrimIndex].Object.Stamp.frame =
 				pSolarSysState->PlanetSideFrame[0];
+		}
 	}
+	// 3) Critter is weakened.
 	else if (CreatureData[ElementPtr->mass_points & ~CREATURE_AWARE]
 			.Attributes & SPEED_MASK)
 	{
 		COUNT angle;
-
+		
 		angle = FACING_TO_ANGLE (GetFrameIndex (
 				LanderControl->IntersectStamp.frame) -
 				ANGLE_TO_FACING (FULL_CIRCLE));
@@ -683,8 +1224,7 @@ CheckObjectCollision (COUNT index)
 		ElementControl.IntersectStamp = pPrim->Object.Stamp;
 		ElementControl.EndPoint = ElementControl.IntersectStamp.origin;
 
-		if (GetFrameParentDrawable (ElementControl.IntersectStamp.frame)
-				== LanderHandle)
+		if (GetFrameParentDrawable (ElementControl.IntersectStamp.frame) == LanderHandle)
 		{
 			CheckObjectCollision (index);
 			continue;
@@ -725,8 +1265,44 @@ CheckObjectCollision (COUNT index)
 					/* Collision of lander with another object */
 					if (crew_left == 0 || pPSD->InTransit)
 						break;
+					
+					// JMS: Lander collides with biocritter explosion or critters' lasers.
+					if (ElementPtr->mass_points == BIOCRITTER_PROJECTILE
+						&& ElementPtr->state_flags & FINITE_LIFE)
+					{	
+						if ((BYTE)TFB_Random () < (256 >> 2))
+							DeltaLanderCrew (-1, LANDER_INJURED); // No shield prevents explosion damage.
+						
+						UnlockElement (hElement); 
+						
+						continue;
+					}
+					
+					// JMS: Lander collides with limpets.
+					else if (ElementPtr->mass_points == BIOCRITTER_LIMPET
+						&& ElementPtr->state_flags & FINITE_LIFE)
+					{	
+						BYTE maxlimpets;
+						
+						if (!GET_GAME_STATE (IMPROVED_LANDER_SPEED))
+							maxlimpets = MAX_LIMPETS_LO_SPEED;
+						else
+							maxlimpets = MAX_LIMPETS_HI_SPEED;
+						
+						if (pPSD->LimpetLevel < maxlimpets)
+							(pPSD->LimpetLevel)++;
+						
+						ElementPtr->life_span = 0;
+						PlaySound (SetAbsSoundIndex (LanderSounds, BIOLOGICAL_DISASTER), NotPositional (), NULL, GAME_SOUND_PRIORITY);
+						
+						ModifyLanderSilhouette ();
+						
+						UnlockElement (hElement); 
 
-					if (ElementPtr->state_flags & FINITE_LIFE)
+						continue;
+					}
+					
+					else if (ElementPtr->state_flags & FINITE_LIFE)
 					{
 						/* A natural disaster */
 						scan = ElementPtr->mass_points;
@@ -743,8 +1319,34 @@ CheckObjectCollision (COUNT index)
 						continue;
 					}
 					else if (scan == ENERGY_SCAN)
-					{
-						// noop; handled by generation funcs, see below
+					{	
+						if (ElementPtr->mass_points == 1)
+						{
+							#define FWIFFO_FRAGS  8
+							DWORD TimeIn;
+
+							// JMS: Finding the new Precursor ship and black orb. (This if was "Ran into Spathi on Pluto".)
+							// Currently does nothing, but all kinds of nice crap can be added here.
+							TimeIn = GetTimeCounter ();
+
+						}
+
+						if (crew_left
+								&& pSolarSysState->SysInfo.PlanetInfo.DiscoveryString
+								&& CurStarDescPtr->Index != ANDROSYNTH_DEFINED)
+						{
+							UnbatchGraphics ();
+							DoDiscoveryReport (MenuSounds);
+							BatchGraphics ();
+						}
+						
+						if (ElementPtr->mass_points == 0)
+						{
+							DestroyStringTable (ReleaseStringTable (pSolarSysState->SysInfo.PlanetInfo.DiscoveryString));
+							pSolarSysState->SysInfo.PlanetInfo.DiscoveryString = 0;
+							UnlockElement (hElement);
+							continue;
+						}
 					}
 					else if (scan == BIOLOGICAL_SCAN && ElementPtr->hit_points)
 					{
@@ -752,11 +1354,8 @@ CheckObjectCollision (COUNT index)
 						{
 							0, 6, 13, 26
 						};
-						int creatureIndex = ElementPtr->mass_points
-								& ~CREATURE_AWARE;
-						int dangerLevel =
-								(CreatureData[creatureIndex].Attributes &
-								DANGER_MASK) >> DANGER_SHIFT;
+						int creatureIndex = ElementPtr->mass_points & ~CREATURE_AWARE;
+						int dangerLevel = (CreatureData[creatureIndex].Attributes & DANGER_MASK) >> DANGER_SHIFT;
 
 						if (TFB_Random () % 128 < danger_vals[dangerLevel])
 						{
@@ -769,7 +1368,7 @@ CheckObjectCollision (COUNT index)
 						UnlockElement (hElement);
 						continue;
 					}
-
+					
 					NumRetrieved = ElementPtr->mass_points;
 				}
 				else if (ElementPtr->state_flags & FINITE_LIFE)
@@ -779,9 +1378,9 @@ CheckObjectCollision (COUNT index)
 					continue;
 				}
 				else
-				{
+				{					
 					BYTE value;
-
+	
 					if (scan == ENERGY_SCAN)
 					{
 						/* Collision of a stun bolt with an energy node */
@@ -825,11 +1424,28 @@ CheckObjectCollision (COUNT index)
 				}
 
 				which_node = HIBYTE (ElementPtr->scan_node) - 1;
-				if (callPickupForScanType (pSolarSysState,
-						pSolarSysState->pOrbitalDesc, which_node, scan))
-				{	// Node retrieved, remove from the surface
-					setNodeRetrieved (&pSolarSysState->SysInfo.PlanetInfo,
-							scan, which_node);
+				pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[scan] |= (1L << which_node);
+				pSolarSysState->CurNode = (COUNT)~0;
+				callGenerateForScanType (pSolarSysState,
+						pSolarSysState->pOrbitalDesc,
+						&pSolarSysState->CurNode, scan);
+
+				if (!(pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[scan] & (1L << which_node)))
+				{
+					/* If our discovery strings have cycled, we're done */
+					if (GetStringTableIndex (pSolarSysState->SysInfo.PlanetInfo.DiscoveryString) == 0)
+					{
+						if (DestroyStringTable (ReleaseStringTable (
+								pSolarSysState->SysInfo.PlanetInfo.DiscoveryString
+								)))
+							pSolarSysState->SysInfo.PlanetInfo.DiscoveryString = 0;
+					}
+				}
+				else
+				{
+					if (NumRetrieved && scan == ENERGY_SCAN)
+						pPSD->InTransit = TRUE;
+
 					SET_GAME_STATE (PLANETARY_CHANGE, 1);
 					ElementPtr->state_flags |= DISAPPEARING;
 				}
@@ -911,6 +1527,7 @@ AddLightning (void)
 		LightningElementPtr->playerNr = PS_NON_PLAYER;
 		LightningElementPtr->state_flags = FINITE_LIFE;
 		LightningElementPtr->preprocess_func = lightning_process;
+		
 		if (TFB_Random () % 100 >= 25)
 			LightningElementPtr->mass_points = 0; /* harmless */
 		else
@@ -918,14 +1535,30 @@ AddLightning (void)
 
 		rand_val = TFB_Random ();
 		LightningElementPtr->life_span = 10 + (HIWORD (rand_val) % 10) + 1;
-		LightningElementPtr->next.location.x = (curLanderLoc.x
+		
+		// JMS_GFX
+		if (RESOLUTION_FACTOR == 0)
+		{
+			LightningElementPtr->next.location.x = (curLanderLoc.x
 				+ ((MAP_WIDTH << MAG_SHIFT) - ((SURFACE_WIDTH >> 1) - 6))
 				+ (LOBYTE (rand_val) % (SURFACE_WIDTH - 12))
 				) % (MAP_WIDTH << MAG_SHIFT);
-		LightningElementPtr->next.location.y = (curLanderLoc.y
+			LightningElementPtr->next.location.y = (curLanderLoc.y
 				+ ((MAP_HEIGHT << MAG_SHIFT) - ((SURFACE_HEIGHT >> 1) - 6))
 				+ (HIBYTE (rand_val) % (SURFACE_HEIGHT - 12))
 				) % (MAP_HEIGHT << MAG_SHIFT);
+		}
+		else
+		{
+			LightningElementPtr->next.location.x = (curLanderLoc.x
+				+ ((MAP_WIDTH << MAG_SHIFT) - ((SURFACE_WIDTH >> 1) - 6))
+				+ (rand_val % (SURFACE_WIDTH - (12 << RESOLUTION_FACTOR)))
+				) % (MAP_WIDTH << MAG_SHIFT);
+			LightningElementPtr->next.location.y = (curLanderLoc.y
+				+ ((MAP_HEIGHT << MAG_SHIFT) - ((SURFACE_HEIGHT >> 1) - 6))
+				+ (rand_val % (SURFACE_HEIGHT - (12 << RESOLUTION_FACTOR)))
+				) % (MAP_HEIGHT << MAG_SHIFT);
+		}
 
 		LightningElementPtr->cycle = LightningElementPtr->life_span;
 		
@@ -976,7 +1609,7 @@ AddGroundDisaster (COUNT which_disaster)
 
 		if (which_disaster == EARTHQUAKE_DISASTER)
 		{
-			SetPrimType (pPrim, STAMPFILL_PRIM);
+			SetPrimType (pPrim, STAMP_PRIM); // JMS: was STAMPFILL_PRIM (this rendered it totally white).
 			pPrim->Object.Stamp.frame = LanderFrame[1];
 			GroundDisasterElementPtr->turn_wait = MAKE_BYTE (2, 2);
 		}
@@ -1039,8 +1672,7 @@ BuildObjectList (void)
 
 		LockElement (hElement, &ElementPtr);
 
-		if (ElementPtr->life_span == 0
-				|| (ElementPtr->state_flags & DISAPPEARING))
+		if (ElementPtr->life_span == 0 || (ElementPtr->state_flags & DISAPPEARING))
 		{
 			hNextElement = GetSuccElement (ElementPtr);
 			UnlockElement (hElement);
@@ -1236,12 +1868,12 @@ ScrollPlanetSide (SIZE dx, SIZE dy, int
 			pPSD->MineralText[1].baseline.x =
 					pPSD->MineralText[0].baseline.x;
 			pPSD->MineralText[1].baseline.y =
-					pPSD->MineralText[0].baseline.y + 7;
+					pPSD->MineralText[0].baseline.y + (7 << RESOLUTION_FACTOR); // JMS_GFX
 			font_DrawText (&pPSD->MineralText[1]);
 			pPSD->MineralText[2].baseline.x =
 					pPSD->MineralText[1].baseline.x;
 			pPSD->MineralText[2].baseline.y =
-					pPSD->MineralText[1].baseline.y + 7;
+					pPSD->MineralText[1].baseline.y + (7 << RESOLUTION_FACTOR); // JMS_GFX
 			font_DrawText (&pPSD->MineralText[2]);
 		}
 	}
@@ -1274,7 +1906,7 @@ animationInterframe (TimeCount *TimeIn,
 }
 
 static void
-AnimateLaunch (FRAME farray)
+AnimateLaunch (FRAME farray, BOOLEAN landing)
 {
 	RECT r;
 	STAMP s;
@@ -1296,7 +1928,7 @@ AnimateLaunch (FRAME farray)
 		NextTime = GetTimeCounter () + (ONE_SECOND / 22);
 
 		BatchGraphics ();
-		RepairBackRect (&r);
+		RepairBackRect (&r, TRUE);
 #ifdef SPIN_ON_LAUNCH
 		RotatePlanetSphere (FALSE);
 #else
@@ -1314,7 +1946,10 @@ AnimateLaunch (FRAME farray)
 		LockMutex (GraphicsLock);
 	}
 
-	RepairBackRect (&r);
+	// This clears the last lander return / launch) anim frame from the planet window.
+	if (RESOLUTION_FACTOR == 0 || !landing)
+		RepairBackRect (&r, FALSE);
+	
 	UnlockMutex (GraphicsLock);
 }
 
@@ -1403,7 +2038,7 @@ static void
 InitPlanetSide (POINT pt)
 {
 	// Adjust landing location by a random jitter.
-#define RANDOM_MISS 64
+#define RANDOM_MISS (64 << RESOLUTION_FACTOR) // JMS_GFX
 	// Jitter the X landing point.
 	pt.x -= RANDOM_MISS - TFB_Random () % (RANDOM_MISS << 1);
 	if (pt.x < 0)
@@ -1419,23 +2054,22 @@ InitPlanetSide (POINT pt)
 		pt.y = (MAP_HEIGHT << MAG_SHIFT) - 1;
 
 	curLanderLoc = pt;
-
+	
 	LockMutex (GraphicsLock);
 	SetContext (PlanetContext);
 	SetContextFont (TinyFont);
 
 	{
 		RECT r;
-
+		
 		GetContextClipRect (&r);
-
 		SetTransitionSource (&r);
 		BatchGraphics ();
-		
+
 		{
 			STAMP s;
 
-			// Note - This code is the same as in ScrollPlanetSize,
+			// Note - This code is the same as in ScrollPlanetSide,
 			// Display planet area, accounting for horizontal wrapping if
 			// near the edges.
 			ClearDrawable ();
@@ -1498,8 +2132,8 @@ LanderFire (SIZE facing)
 	angle = FACING_TO_ANGLE (facing);
 	SetVelocityComponents (
 			&WeaponElementPtr->velocity,
-			COSINE (angle, WORLD_TO_VELOCITY (2 * 3)) + wdx,
-			SINE (angle, WORLD_TO_VELOCITY (2 * 3)) + wdy);
+			COSINE (angle, WORLD_TO_VELOCITY ((2 * 3) << RESOLUTION_FACTOR)) + wdx,
+			SINE (angle, WORLD_TO_VELOCITY ((2 * 3) << RESOLUTION_FACTOR)) + wdy); // JMS_GFX
 
 	UnlockElement (hWeaponElement);
 
@@ -1568,11 +2202,11 @@ DoPlanetSide (LanderInputState *pMS)
 
 		angle = FACING_TO_ANGLE (GetFrameIndex (LanderFrame[0]));
 		landerSpeedNumer = GET_GAME_STATE (IMPROVED_LANDER_SPEED) ?
-				WORLD_TO_VELOCITY (2 * 14) :
-				WORLD_TO_VELOCITY (2 * 8);
+				WORLD_TO_VELOCITY (2 * (14 << RESOLUTION_FACTOR)) :
+				WORLD_TO_VELOCITY (2 * (8 << RESOLUTION_FACTOR)); // JMS_GFX
 
 #ifdef FAST_FAST
-landerSpeedNumer = WORLD_TO_VELOCITY (48);
+landerSpeedNumer = WORLD_TO_VELOCITY (48 << RESOLUTION_FACTOR); // JMS_GFX
 #endif
 
 		SetVelocityComponents (&GLOBAL (velocity),
@@ -1614,6 +2248,9 @@ landerSpeedNumer = WORLD_TO_VELOCITY (48
 	}
 	else
 	{
+		PLANETSIDE_DESC *pPSD;	// JMS
+		pPSD = planetSideDesc;	// JMS
+
 		if (crew_left)
 		{
 			SIZE index = GetFrameIndex (LanderFrame[0]);
@@ -1635,11 +2272,11 @@ landerSpeedNumer = WORLD_TO_VELOCITY (48
 
 				angle = FACING_TO_ANGLE (index);
 				landerSpeedNumer = GET_GAME_STATE (IMPROVED_LANDER_SPEED) ?
-						WORLD_TO_VELOCITY (2 * 14) :
-						WORLD_TO_VELOCITY (2 * 8);
+						WORLD_TO_VELOCITY (((2 * 14) - pPSD->LimpetLevel) << RESOLUTION_FACTOR) :
+						WORLD_TO_VELOCITY (((2 * 8) - pPSD->LimpetLevel) << RESOLUTION_FACTOR); // JMS_GFX
 
 #ifdef FAST_FAST
-landerSpeedNumer = WORLD_TO_VELOCITY (48);
+landerSpeedNumer = WORLD_TO_VELOCITY (48 - pPSD->LimpetLevel);
 #endif
 
 				SetVelocityComponents (&GLOBAL (velocity),
@@ -1727,6 +2364,10 @@ LoadLanderData (void)
 			CaptureDrawable (LoadGraphic (LANDER_RETURN_MASK_PMAP_ANIM));
 	LanderFrame[7] =
 			CaptureDrawable (LoadGraphic (ORBIT_VIEW_ANIM));
+	LanderFrame[8] =
+		        CaptureDrawable (LoadGraphic (LANDENEMY_MASK_PMAP_ANIM)); // JMS: Added this for critter explosion and biocritters' shots.
+	LanderFrame[9] =
+		        CaptureDrawable (LoadGraphic (LIFE45SML_MASK_PMAP_ANIM)); // JMS: Added this for dividing critter's small bastards' frames.
 	
 	LanderSounds = CaptureSound (LoadSound (LANDER_SOUNDS));
 
@@ -1775,7 +2416,7 @@ IdlePlanetSide (LanderInputState *inputS
 	while (GetTimeCounter () < TimeOut)
 	{
 		// 10 to clear the lander off of the screen
-		ScrollPlanetSide (0, 0, -(SURFACE_HEIGHT / 2 + 10));
+		ScrollPlanetSide (0, 0, -(SURFACE_HEIGHT / 2 + (10 << RESOLUTION_FACTOR))); // JMS_GFX
 		SleepThreadUntil (inputState->NextTime);
 		inputState->NextTime += PLANET_SIDE_RATE;
 	}
@@ -1786,20 +2427,35 @@ LandingTakeoffSequence (LanderInputState
 {
 // We cannot solve a quadratic equation in a macro, so use a sensible max
 #define MAX_OFFSETS  20
-// 10 to clear the lander off of the screen
-#define DISTANCE_COVERED  (SURFACE_HEIGHT / 2 + 10)
+#define MAX_OFFSETS_4X 400 // JMS_GFX
+// 10 << RESOLUTION_FACTOR to clear the lander off of the screen
+#define DISTANCE_COVERED  ((SURFACE_HEIGHT / 2) + (10 << RESOLUTION_FACTOR))
+	
 	int landingOfs[MAX_OFFSETS];
 	int start;
 	int end;
 	int delta;
 	int index;
+	int max_offsets; // JMS_GFX
+	int landingOfs4x[MAX_OFFSETS_4X]; // JMS_GFX
 
 	// Produce smooth acceleration deltas from a simple 1..x progression
 	delta = 0;
-	for (index = 0; index < MAX_OFFSETS && delta < DISTANCE_COVERED; ++index)
+	
+	// JMS_GFX: At 4x resolution we run out of default offsets. -> Use larger offset value.
+	max_offsets = MAX_OFFSETS;
+	if (RESOLUTION_FACTOR == 2) 
+		max_offsets = MAX_OFFSETS_4X;
+	
+	for (index = 0; index < max_offsets && delta < DISTANCE_COVERED; ++index)
 	{
 		delta += index + 1;
-		landingOfs[index] = -delta;
+		
+		// JMS_GFX
+		if (RESOLUTION_FACTOR == 2)
+			landingOfs4x[index] = -delta;
+		else
+			landingOfs[index] = -delta;
 	}
 	assert (delta >= DISTANCE_COVERED && "Increase MAX_OFFSETS!");
 
@@ -1822,7 +2478,12 @@ LandingTakeoffSequence (LanderInputState
 	// Draw the landing/takeoff lander positions
 	for (index = start; index != end; index += delta)
 	{
-		ScrollPlanetSide (0, 0, landingOfs[index]);
+		// JMS_GFX
+		if (RESOLUTION_FACTOR == 2)
+			ScrollPlanetSide (0, 0, landingOfs4x[index]);
+		else
+			ScrollPlanetSide (0, 0, landingOfs[index]);
+		
 		SleepThreadUntil (inputState->NextTime);
 		inputState->NextTime += PLANET_SIDE_RATE;
 	}
@@ -1839,24 +2500,6 @@ SetLanderTakeoff (void)
 		planetSideDesc->InTransit = TRUE;
 }
 
-// Returns whether the lander is still alive at the end of the sequence
-bool
-KillLanderCrewSeq (COUNT numKilled, DWORD period)
-{
-	TimeCount TimeOut;
-	COUNT i;
-
-	TimeOut = GetTimeCounter ();
-	for (i = 0; i < numKilled && crew_left; ++i)
-	{
-		TimeOut += period;
-		DeltaLanderCrew (-1, LANDER_INJURED);
-		SleepThreadUntil (TimeOut);
-	}
-	
-	return crew_left > 0;
-}
-
 void
 PlanetSide (POINT planetLoc)
 {
@@ -1870,11 +2513,10 @@ PlanetSide (POINT planetLoc)
 	memset (&PSD, 0, sizeof (PSD));
 	PSD.InTransit = TRUE;
 
-	PSD.TectonicsChance =
-			TectonicsChanceTab[pSolarSysState->SysInfo.PlanetInfo.Tectonics];
-	PSD.WeatherChance =
-			WeatherChanceTab[pSolarSysState->SysInfo.PlanetInfo.Weather];
+	PSD.TectonicsChance = TectonicsChanceTab[pSolarSysState->SysInfo.PlanetInfo.Tectonics];
+	PSD.WeatherChance = WeatherChanceTab[pSolarSysState->SysInfo.PlanetInfo.Weather];
 	index = pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature;
+	
 	if (index < 50)
 		PSD.FireChance = FireChanceTab[0];
 	else if (index < 100)
@@ -1909,19 +2551,17 @@ PlanetSide (POINT planetLoc)
 	PSD.ColorCycle[1] = BUILD_COLOR (MAKE_RGB15 (0x1F, 0x0A, 0x00), 0x7D);
 	PSD.ColorCycle[2] = BUILD_COLOR (MAKE_RGB15 (0x1F, 0x11, 0x00), 0x7B);
 	PSD.ColorCycle[3] = BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x00), 0x71);
+	
 	for (index = 4; index < (NUM_TEXT_FRAMES >> 1) - 4; ++index)
 	{
 		PSD.ColorCycle[index] =
 				BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x1F), 0x0F);
 	}
-	PSD.ColorCycle[(NUM_TEXT_FRAMES >> 1) - 4] =
-			BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x00), 0x71);
-	PSD.ColorCycle[(NUM_TEXT_FRAMES >> 1) - 3] =
-			BUILD_COLOR (MAKE_RGB15 (0x1F, 0x11, 0x00), 0x7B);
-	PSD.ColorCycle[(NUM_TEXT_FRAMES >> 1) - 2] =
-			BUILD_COLOR (MAKE_RGB15 (0x1F, 0x0A, 0x00), 0x7D);
-	PSD.ColorCycle[(NUM_TEXT_FRAMES >> 1) - 1] =
-			BUILD_COLOR (MAKE_RGB15 (0x1F, 0x03, 0x00), 0x7F);
+	
+	PSD.ColorCycle[(NUM_TEXT_FRAMES >> 1) - 4] = BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x00), 0x71);
+	PSD.ColorCycle[(NUM_TEXT_FRAMES >> 1) - 3] = BUILD_COLOR (MAKE_RGB15 (0x1F, 0x11, 0x00), 0x7B);
+	PSD.ColorCycle[(NUM_TEXT_FRAMES >> 1) - 2] = BUILD_COLOR (MAKE_RGB15 (0x1F, 0x0A, 0x00), 0x7D);
+	PSD.ColorCycle[(NUM_TEXT_FRAMES >> 1) - 1] = BUILD_COLOR (MAKE_RGB15 (0x1F, 0x03, 0x00), 0x7F);
 	planetSideDesc = &PSD;
 	
 	index = NORMALIZE_FACING (TFB_Random ());
@@ -1931,7 +2571,7 @@ PlanetSide (POINT planetLoc)
 	explosion_index = 0;
 
 	AnimateLanderWarmup ();
-	AnimateLaunch (LanderFrame[5]);
+	AnimateLaunch (LanderFrame[5], TRUE);
 	InitPlanetSide (planetLoc);
 
 	landerInputState.NextTime = GetTimeCounter () + PLANET_SIDE_RATE;
@@ -1945,6 +2585,7 @@ PlanetSide (POINT planetLoc)
 
 	if (!(GLOBAL (CurrentActivity) & CHECK_ABORT))
 	{
+		
 		if (crew_left == 0)
 		{
 			--GLOBAL_SIS (NumLanders);
@@ -1957,12 +2598,11 @@ PlanetSide (POINT planetLoc)
 		else
 		{
 			PSD.InTransit = TRUE;
-			PlaySound (SetAbsSoundIndex (LanderSounds, LANDER_RETURNS),
-					NotPositional (), NULL, GAME_SOUND_PRIORITY + 1);
+			PlaySound (SetAbsSoundIndex (LanderSounds, LANDER_RETURNS), NotPositional (), NULL, GAME_SOUND_PRIORITY + 1);
 
 			LandingTakeoffSequence (&landerInputState, FALSE);
 			ReturnToOrbit ();
-			AnimateLaunch (LanderFrame[6]);
+			AnimateLaunch (LanderFrame[6], FALSE);
 			
 			LockMutex (GraphicsLock);
 			DeltaSISGauges (crew_left, 0, 0);
@@ -1971,10 +2611,8 @@ PlanetSide (POINT planetLoc)
 			{
 				for (index = 0; index < NUM_ELEMENT_CATEGORIES; ++index)
 				{
-					GLOBAL_SIS (ElementAmounts[index]) +=
-							PSD.ElementAmounts[index];
-					GLOBAL_SIS (TotalElementMass) +=
-							PSD.ElementAmounts[index];
+					GLOBAL_SIS (ElementAmounts[index]) += PSD.ElementAmounts[index];
+					GLOBAL_SIS (TotalElementMass) += PSD.ElementAmounts[index];
 				}
 				DrawStorageBays (FALSE);
 			}
@@ -2039,8 +2677,7 @@ InitLander (BYTE LanderFlags)
 
 		s.origin.x = 0; /* set up powered-down lander */
 		s.origin.y = 0;
-		s.frame = SetAbsFrameIndex (LanderFrame[0],
-				ANGLE_TO_FACING (FULL_CIRCLE) << 1);
+		s.frame = SetAbsFrameIndex (LanderFrame[0], ANGLE_TO_FACING (FULL_CIRCLE) << 1);
 		DrawStamp (&s);
 		if (LanderFlags == 0)
 		{
@@ -2060,8 +2697,7 @@ InitLander (BYTE LanderFlags)
 				s.frame = SetAbsFrameIndex (s.frame, 57);
 			else
 			{
-				s.frame = SetAbsFrameIndex (s.frame,
-						(ANGLE_TO_FACING (FULL_CIRCLE) << 1) + 3);
+				s.frame = SetAbsFrameIndex (s.frame, (ANGLE_TO_FACING (FULL_CIRCLE) << 1) + 3);
 				DrawStamp (&s);
 				s.frame = IncFrameIndex (s.frame);
 			}
@@ -2077,18 +2713,17 @@ InitLander (BYTE LanderFlags)
 			if (LanderFlags & (1 << (4 + 2)))
 				s.frame = SetAbsFrameIndex (s.frame, 58);
 			else
-				s.frame = SetAbsFrameIndex (s.frame,
-						(ANGLE_TO_FACING (FULL_CIRCLE) << 1) + 2);
+				s.frame = SetAbsFrameIndex (s.frame, (ANGLE_TO_FACING (FULL_CIRCLE) << 1) + 2);
 			DrawStamp (&s);
 		}
 
 		free_space = GetStorageBayCapacity () - GLOBAL_SIS (TotalElementMass);
+		
 		if ((int)free_space < (int)(MAX_SCROUNGED << capacity_shift))
 		{
 			r.corner.x = 1;
-			r.extent.width = 4;
-			r.extent.height = MAX_SCROUNGED
-					- (free_space >> capacity_shift) + 1;
+			r.extent.width = RES_STAT_SCALE(4) + RESOLUTION_FACTOR; // JMS_GFX
+			r.extent.height = RES_STAT_SCALE(MAX_SCROUNGED - (free_space >> capacity_shift) + 1);
 			SetContextForeGroundColor (BLACK_COLOR);
 			DrawFilledRectangle (&r);
 		}
diff -ruNp src.orig/uqm/planets/lander.h src/uqm/planets/lander.h
--- src.orig/uqm/planets/lander.h	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/lander.h	2017-11-01 15:31:03 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: Added LimpetLevel variable to Planetside_dexc structure
+
 #ifndef _LANDER_H
 #define _LANDER_H
 
@@ -26,7 +28,6 @@
 #include "libs/timelib.h"
 #include "../element.h"
 
-
 // Surface magnification shift (x4)
 #define MAG_SHIFT 2
 
@@ -54,6 +55,8 @@ typedef struct
 	BYTE TectonicsChance;
 	BYTE WeatherChance;
 	BYTE FireChance;
+	
+	BYTE LimpetLevel; // JMS: How many limpets have been stuck on lander.
 } PLANETSIDE_DESC;
 
 extern MUSIC_REF LanderMusic;
@@ -67,7 +70,6 @@ extern void FreeLanderData (void);
 extern void object_animation (ELEMENT *ElementPtr);
 
 extern void SetLanderTakeoff (void);
-extern bool KillLanderCrewSeq (COUNT numKilled, DWORD period);
 
 // ELEMENT.playerNr constants
 enum
diff -ruNp src.orig/uqm/planets/lifeform.h src/uqm/planets/lifeform.h
--- src.orig/uqm/planets/lifeform.h	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/lifeform.h	2017-11-01 15:31:03 -0700
@@ -54,15 +54,50 @@
 
 #define NUM_CREATURE_TYPES 23
 #define NUM_SPECIAL_CREATURE_TYPES 3
+#define NUM_B_CREATURE_TYPES 13 // BW: creatures appearing in the southern region
+#define NUM_C_CREATURE_TYPES 13 // BW: creatures appearing in the western region
 #define MAX_LIFE_VARIATION 3
 
 #define CREATURE_AWARE (BYTE)(1 << 7)
 
+// JMS: The SpecialAttributes of critters:
+#define NONE 0
+#define SHOOTS_LASER (1 << 0)
+#define SHOOTS_LIMPET (1 << 1)
+#define WHEN_DYING_EXPLODES (1 << 2)
+#define WHEN_DYING_DIVIDES (1 << 3)
+#define INVULNERABLE_PART_TIME (1 << 4)
+#define INVULNERABLE_TO_BASIC_WEAPON (1 << 5)
+
+#define SHOOTING_SPECIALS 0x03 // binary 11
+#define WHEN_DYING_SPECIALS 0x0C // binary 1100
+#define INVULNERABILITY_SPECIALS 0x30 // binary 110000
+
+#define LIMPET_ACCEL (WORLD_TO_VELOCITY(1 << RESOLUTION_FACTOR))		// JMS_GFX
+#define LIMPET_MAX_SPEED (WORLD_TO_VELOCITY(3 << RESOLUTION_FACTOR))	// JMS_GFX
+#define LIMPET_LIFESPAN 50
+#define MAX_LIMPETS_LO_SPEED 16 // JMS: Max number of limpets that can stick on the lander
+#define MAX_LIMPETS_HI_SPEED 28 // JMS: Max number of limpets that can stick on the lander
+
+#define CRITTER_EXPLOSION_PERCENT 60 // JMS: This concerns only WHEN_DYING_EXPLODES critters.
+
+#define DIVIDED_CRITTER_NUMBER 3
+#define DIVIDED_CRITTER_LIFESPAN 1
+
 typedef struct
 {
 	BYTE Attributes, ValueAndHitPoints;
+        COUNT FrameRate, SpecialAttributes;
 } LIFEFORM_DESC;
 
+// BW: FrameRate is an integer between 0 and 15
+// where (FrameRate+1)/32 is (roughly ?) the number of seconds
+// between two frames when animating the lifeform.
+// This should be defined with ONE_SECOND to comply with the other animations
+//
+// JMS: SpecialAttributes is a 16-bit bitmask which houses all the new
+// skills the creatures might have: shooting back, exploding etc.
+
 extern const LIFEFORM_DESC CreatureData[];
 
 #endif /* _LIFEFORM_H */
diff -ruNp src.orig/uqm/planets/orbits.c src/uqm/planets/orbits.c
--- src.orig/uqm/planets/orbits.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/orbits.c	2017-11-01 15:31:03 -0700
@@ -16,13 +16,18 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
 #include "planets.h"
 // XXX: for CurStarDescPtr
 #include "../encount.h"
+#include "../clock.h"
 #include "libs/compiler.h"
 #include "libs/mathlib.h"
 #include "libs/log.h"
 
+#include <math.h> // JMS: For 'pow'
+
 
 //#define DEBUG_ORBITS
 
@@ -470,6 +475,24 @@ YellowDistribution (BYTE which_world)
 #define SUPERGIANT_ROCK_DIST SCALE_RADIUS (16)
 #define SUPERGIANT_GASG_DIST SCALE_RADIUS (33)
 
+void ComputeSpeed(PLANET_DESC *planet, BOOLEAN GeneratingMoons, UWORD rand_val)
+{
+	//BW : empiric values, which would give roughly correct
+	// rotation periods for most moons in the solar system
+	if (GeneratingMoons)
+		{
+			planet->orb_speed = FULL_CIRCLE / (29 * pow((double)planet->radius / (MIN_MOON_RADIUS + (MAX_MOONS - 1) * MOON_DELTA), 1.5));
+			if ((planet->pPrevDesc->data_index & ~PLANET_SHIELDED) >= FIRST_GAS_GIANT)
+				planet->orb_speed *= 2;
+			if (!(rand_val % 7))
+				planet->orb_speed = - planet->orb_speed;
+		}
+		else
+		{
+			planet->orb_speed = FULL_CIRCLE / (ONE_YEAR * pow((double)planet->radius / EARTH_RADIUS, 1.5));
+		}
+}
+
 void
 FillOrbits (SOLARSYS_STATE *system, BYTE NumPlanets,
 		PLANET_DESC *pBaseDesc, BOOLEAN TypesDefined)
@@ -522,7 +545,7 @@ char scolor[] = {'B', 'G', 'O', 'R', 'W'
 	{
 		BYTE chance;
 		DWORD rand_val;
-		COUNT min_radius, angle;
+		DWORD min_radius; //, angle; // JMS_GFX: Was COUNT. Changed to avoid overflows in 1280x960.
 		SIZE delta_r;
 		PLANET_DESC *pLocPD;
 
@@ -532,8 +555,7 @@ char scolor[] = {'B', 'G', 'O', 'R', 'W'
 			if (TypesDefined)
 				rand_val = 0;
 			else
-				pPD->data_index =
-						(BYTE)(HIBYTE (LOWORD (rand_val)) % MaxPlanet);
+				pPD->data_index = (BYTE)(HIBYTE (LOWORD (rand_val)) % MaxPlanet);
 
 			chance = PLANET_NEVER;
 			switch (StarColor)
@@ -593,10 +615,25 @@ RelocatePlanet:
 		}
 
 		rand_val = TFB_Random ();
-		angle = NORMALIZE_ANGLE (LOWORD (rand_val));
-		pPD->location.x = COSINE (angle, pPD->radius);
-		pPD->location.y = SINE (angle, pPD->radius);
-		pPD->rand_seed = MAKE_DWORD (pPD->location.x, pPD->location.y);
+		// Initial angle & coordinates as in Vanilla UQM
+		// Still used to compute rand_seed and the position
+		// of the planet at the start of the game
+		pPD->angle = NORMALIZE_ANGLE (LOWORD (rand_val));
+		pPD->location.x = COSINE (pPD->angle, pPD->radius);
+		pPD->location.y = SINE (pPD->angle, pPD->radius);
+		if (GeneratingMoons)
+		{
+		pPD->rand_seed = MAKE_DWORD (
+		     COSINE (pPD->angle, pPD->radius >> RESOLUTION_FACTOR),
+		     SINE (pPD->angle, pPD->radius >> RESOLUTION_FACTOR));
+		}
+		else
+		{
+			pPD->rand_seed = MAKE_DWORD (pPD->location.x, pPD->location.y);
+		}
+		// Angle is kept for reference but location will be adjusted
+		// to take orbiting into account
+		ComputeSpeed(pPD, GeneratingMoons, HIWORD (rand_val));
 
 		++pPD;
 	}
diff -ruNp src.orig/uqm/planets/oval.c src/uqm/planets/oval.c
--- src.orig/uqm/planets/oval.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/oval.c	2017-11-01 15:31:03 -0700
@@ -16,6 +16,9 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// BW 2011: thickness can be either 0 (if you want regular dots)
+// or 1 (for plusses). num_off_pixels has to be adjusted manually.
+
 #include "../units.h"
 #include "libs/gfxlib.h"
 #include "libs/graphics/context.h"
@@ -25,7 +28,38 @@
 #define NUM_QUADS 4
 
 void
-DrawOval (RECT *pRect, BYTE num_off_pixels)
+DrawPlus (PRIMITIVE *prim, COUNT StartPrim)
+{
+	COUNT quad;
+
+	for (quad = 0; quad < NUM_QUADS; ++quad)
+	{
+		--prim[quad].Object.Point.x;
+	}
+	DrawBatch (prim, StartPrim, 0);
+
+	for (quad = 0; quad < NUM_QUADS; ++quad)
+	{
+		prim[quad].Object.Point.x += 2;
+	}
+	DrawBatch (prim, StartPrim, 0);
+	
+	for (quad = 0; quad < NUM_QUADS; ++quad)
+	{
+		--prim[quad].Object.Point.x;
+		--prim[quad].Object.Point.y;
+	}
+	DrawBatch (prim, StartPrim, 0);
+	
+	for (quad = 0; quad < NUM_QUADS; ++quad)
+	{
+		prim[quad].Object.Point.y += 2;
+	}
+	DrawBatch (prim, StartPrim, 0);
+}
+
+void
+DrawOval (RECT *pRect, BYTE num_off_pixels, BYTE thickness)
 {
 #define FIRST_QUAD (1 << 0)
 #define SECOND_QUAD (1 << 1)
@@ -170,8 +204,11 @@ DrawOval (RECT *pRect, BYTE num_off_pixe
 			prim[0].Object.Point.y = prim[1].Object.Point.y = B - y;
 			prim[1].Object.Point.x = prim[2].Object.Point.x = A - x;
 			prim[2].Object.Point.y = prim[3].Object.Point.y = B + y;
-
 			DrawBatch (prim, StartPrim, 0);
+
+			if (thickness == 1)
+				DrawPlus (prim, StartPrim);
+
 			off = num_off_pixels;
 		}
 
@@ -197,8 +234,11 @@ DrawOval (RECT *pRect, BYTE num_off_pixe
 			prim[0].Object.Point.y = prim[1].Object.Point.y = B - y;
 			prim[1].Object.Point.x = prim[2].Object.Point.x = A - x;
 			prim[2].Object.Point.y = prim[3].Object.Point.y = B + y;
-
 			DrawBatch (prim, StartPrim, 0);
+
+			if (thickness == 1)
+				DrawPlus (prim, StartPrim);
+
 			off = num_off_pixels;
 		}
 
@@ -220,8 +260,7 @@ DrawFilledOval (RECT *pRect)
 {
 	COORD x, y;
 	SIZE A, B;
-	long Asquared, TwoAsquared,
-						Bsquared, TwoBsquared;
+	long Asquared, TwoAsquared, Bsquared, TwoBsquared;
 	long d, dx, dy;
 	LINE corners;
 	PRIMITIVE prim[NUM_QUADS >> 1];
@@ -303,14 +342,18 @@ DrawFilledOval (RECT *pRect)
 
 	while (y >= 0)
 	{
-		prim[0].Object.Rect.corner.x =
-				prim[1].Object.Rect.corner.x = A - x;
-		prim[0].Object.Rect.extent.width =
-				prim[1].Object.Rect.extent.width = (x << 1) + 1;
+		prim[0].Object.Rect.corner.x = prim[1].Object.Rect.corner.x = A - x;
+		prim[0].Object.Rect.extent.width = prim[1].Object.Rect.extent.width = (x << 1) + 1;
 		prim[0].Object.Rect.corner.y = B - y;
+		
+		// JMS: This little sucker prevents drawing a double line in the middle
+		// which would look pretty ugly when using alpha channel.
+		if (y == 0)
+			SetPrimColor (&prim[1], BUILD_COLOR_RGBA(0x00,0x00,0x00,0x00));
+		
 		prim[1].Object.Rect.corner.y = B + y;
-
-		DrawBatch (prim, StartPrim, 0);
+			
+			DrawBatch (prim, StartPrim, 0);
 
 		if (d < 0)
 		{
diff -ruNp src.orig/uqm/planets/pl_stuff.c src/uqm/planets/pl_stuff.c
--- src.orig/uqm/planets/pl_stuff.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/pl_stuff.c	2017-11-01 15:31:03 -0700
@@ -27,6 +27,8 @@
 
 #include <math.h>
 
+#include "libs/log.h"
+
 
 // define USE_ADDITIVE_SCAN_BLIT to use additive blittting
 // instead of transparency for the planet scans.
@@ -38,6 +40,9 @@ static int rotDirection;
 static bool throbShield;
 static int rotPointIndex;
 
+static int rotwidth;
+static int rotheight;
+
 // Draw the planet sphere and any extra graphic (like a shield) if present
 void
 DrawPlanetSphere (int x, int y)
@@ -70,10 +75,13 @@ DrawDefaultPlanetSphere (void)
 }
 
 void
-InitSphereRotation (int direction, BOOLEAN shielded)
+InitSphereRotation (int direction, BOOLEAN shielded, COUNT width, COUNT height)
 {
 	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
 
+	rotwidth = width;
+	rotheight = height;
+	
 	rotDirection = direction;
 	rotPointIndex = 0;
 	throbShield = shielded && optWhichShield == OPT_3DO;
@@ -122,13 +130,13 @@ PrepareNextRotationFrame (void)
 	// Go to next point, taking care of wraparounds
 	rotPointIndex += rotDirection;
 	if (rotPointIndex < 0)
-		rotPointIndex = MAP_WIDTH - 1;
-	else if (rotPointIndex >= MAP_WIDTH)
+		rotPointIndex = rotwidth - 1;
+	else if (rotPointIndex >= rotwidth)
 		rotPointIndex = 0;
 
 	// prepare the next sphere frame
 	Orbit->SphereFrame = SetAbsFrameIndex (Orbit->SphereFrame, rotFrameIndex);
-	RenderPlanetSphere (Orbit->SphereFrame, rotPointIndex, throbShield);
+	RenderPlanetSphere (Orbit, Orbit->SphereFrame, rotPointIndex, pSolarSysState->pOrbitalDesc->data_index & PLANET_SHIELDED, pSolarSysState->pOrbitalDesc->flags, throbShield, rotwidth, rotheight, (rotheight >> 1) - RESOLUTION_FACTOR); // RADIUS
 	
 	if (throbShield)
 	{	// prepare the next shield throb frame
@@ -139,6 +147,66 @@ PrepareNextRotationFrame (void)
 	}
 }
 
+void
+PrepareNextRotationFrameForIP (PLANET_DESC *pPlanetDesc, SIZE frameCounter)
+{
+	PLANET_ORBIT *Orbit = &pPlanetDesc->orbit;
+	COUNT framerate;
+	int oldPointIndex = pPlanetDesc->rotPointIndex;
+	// Go to next point, taking care of wraparounds
+
+	// No need to rotate planets that are off screen
+	if (pPlanetDesc->radius > 4 * pSolarSysState->SunDesc[0].radius)
+		return;
+
+	// Optimization : the smallest worlds are rotated only once in a while
+	// The framerate is fine-tuned so that the planet is updated
+	// when the landscape has moved 1 pixel approximately
+	switch (pPlanetDesc->size)
+	{
+	case 3: framerate = 15;
+		break;
+	case 4: framerate = 10;
+		break;
+	case 7: framerate = 4;
+		break;
+	case 11: framerate = 2;
+		break;
+	default: framerate = 1;
+		break;
+	}
+	framerate = 2 * framerate; //Skip every other frame for performance
+	if ((frameCounter % framerate) != 0)
+		return;
+
+	// BW: account for rotation period
+	pPlanetDesc->rotPointIndex = (int)(fmod(pPlanetDesc->rot_speed * daysElapsed(), pPlanetDesc->rotwidth));
+	if (pPlanetDesc->rotPointIndex < 0)
+		pPlanetDesc->rotPointIndex += pPlanetDesc->rotwidth;
+
+	// Nothing to do if there has been no visible rotation
+	if (pPlanetDesc->rotPointIndex == oldPointIndex)
+		return;
+
+	// Generate the next rotation frame
+	// We alternate between the frames because we do not call FlushGraphics()
+	// The frame we just drew may not have made it to the screen yet
+	pPlanetDesc->rotFrameIndex ^= 1;
+
+	// pPlanetDesc->rotPointIndex += pPlanetDesc->rotDirection;
+	// if (pPlanetDesc->rotPointIndex < 0)
+	//	pPlanetDesc->rotPointIndex = pPlanetDesc->rotwidth - 1;
+	// else if (pPlanetDesc->rotPointIndex >= pPlanetDesc->rotwidth)
+	//	pPlanetDesc->rotPointIndex = 0;
+
+	// prepare the next sphere frame
+	Orbit->SphereFrame = SetAbsFrameIndex (Orbit->SphereFrame, pPlanetDesc->rotFrameIndex);
+	RenderPlanetSphere (Orbit, Orbit->SphereFrame, pPlanetDesc->rotPointIndex, pPlanetDesc->data_index & PLANET_SHIELDED, pPlanetDesc->flags, FALSE, pPlanetDesc->rotwidth, pPlanetDesc->rotheight, (pPlanetDesc->rotheight >> 1) - RESOLUTION_FACTOR); // RADIUS
+	Orbit->SphereFrame->image->dirty = TRUE;
+	// BW: slightly hacky but, in DrawTexturedBody, the call
+	// to DrawStamp won't re-blit the frame unless scale has changed.
+}
+
 #define ZOOM_RATE  24
 #define ZOOM_TIME  (ONE_SECOND * 6 / 5)
 
@@ -197,7 +265,7 @@ ZoomInPlanetSphere (void)
 
 		BatchGraphics ();
 		if (i > 0)
-			RepairBackRect (&repairRect);
+			RepairBackRect (&repairRect, FALSE);
 
 		oldMode = SetGraphicScaleMode (TFB_SCALE_BILINEAR);
 		oldScale = SetGraphicScale ((int)(base * scale + 0.5));
diff -ruNp src.orig/uqm/planets/plandata.h src/uqm/planets/plandata.h
--- src.orig/uqm/planets/plandata.h	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/plandata.h	2017-11-01 15:31:03 -0700
@@ -275,6 +275,16 @@ typedef struct
 
 	DWORD ScanSeed[NUM_SCAN_TYPES];
 	DWORD ScanRetrieveMask[NUM_SCAN_TYPES];
+	
+	// JMS: This stores the amount of partially scavenged minerals.
+	//
+	// How it works: When the mineral deposits are generated in scan.c, first the deposit
+	// is given its normal kiloton-size (decided by pseudo-random number). Then, the value
+	// stored in this list is subtracted from the initial value.
+	// There can be max DWORD = 32 mineral deposits on the planet, thus the 32.
+	//
+	// This can be later made to support also partially scavenged biodata.
+	BYTE  PartiallyScavengedList[NUM_SCAN_TYPES][32];
 
 	// The CurPt, CurDensity and CurType fields are filled in
 	// when a GENERATE_MINERAL, GENERATE_ENERGY, or GENERATE_LIFE
@@ -293,11 +303,16 @@ typedef struct
 			//          NUM_CREATURE_TYPES     is an Evil One
 			//          NUM_CREATURE_TYPES + 1 is a Brainbox Bulldozer
 			//          NUM_CREATURE_TYPES + 2 is Zex' Beauty
-			// For energy: undefined
+			//          NUM_CREATURE_TYPES + 3 through NUM_CREATURE_TYPES + 2 + NUM_B_CREATURE_TYPES are creatures for the southern part of the new quadrant
+			//          NUM_CREATURE_TYPES + 2 + NUM_B_CREATURE_TYPES through NUM_CREATURE_TYPES + 2 + NUM_B_CREATURE_TYPES + NUM_C_CREATURE_TYPES are creatures for the western part of the new quadrant
+			// For energy: 0 - Liftoff on collision
+			//             1 - No liftoff on collision
+			//             2 - (special case) Fwiffo
 
 	STRING DiscoveryString;
 	FONT LanderFont;
 	FRAME LanderFontEff;
+	
 } PLANET_INFO;
 
 enum
diff -ruNp src.orig/uqm/planets/planets.c src/uqm/planets/planets.c
--- src.orig/uqm/planets/planets.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/planets.c	2017-11-01 15:31:03 -0700
@@ -182,7 +182,7 @@ typedef enum
 	DRAW_ORBITAL_FULL,
 	DRAW_ORBITAL_WAIT,
 	DRAW_ORBITAL_UPDATE,
-
+	
 } DRAW_ORBITAL_MODE;
 
 static void
@@ -236,7 +236,11 @@ DrawOrbitalDisplay (DRAW_ORBITAL_MODE Mo
 	UnbatchGraphics ();
 
 	// for later RepairBackRect()
-	LoadIntoExtraScreen (&r);
+	// JMS_GFX
+	if (RESOLUTION_FACTOR == 0)
+		LoadIntoExtraScreen (&r);
+	else
+		LoadIntoExtraScreen_Fs (&r);
 }
 
 // Initialise the surface graphics, and start the planet music.
@@ -296,7 +300,7 @@ LoadPlanet (FRAME SurfDefFrame)
 void
 FreePlanet (void)
 {
-	COUNT i;
+	COUNT i, j;
 	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
 
 	UninitSphereRotation ();
@@ -311,7 +315,7 @@ FreePlanet (void)
 		pSolarSysState->PlanetSideFrame[i] = 0;
 	}
 
-//    FreeLanderData ();
+    //FreeLanderData ();
 
 	DestroyStringTable (ReleaseStringTable (pSolarSysState->XlatRef));
 	pSolarSysState->XlatRef = 0;
@@ -340,6 +344,19 @@ FreePlanet (void)
 	Orbit->TopoColors = NULL;
 	HFree (Orbit->ScratchArray);
 	Orbit->ScratchArray = NULL;
+	if (Orbit->map_rotate && Orbit->light_diff)
+	{
+		for (j=0 ; j < MAP_HEIGHT+1 ; j++)
+		{
+			HFree (Orbit->map_rotate[j]);
+			HFree (Orbit->light_diff[j]);
+		}
+	}
+
+	HFree (Orbit->map_rotate);
+	Orbit->map_rotate = NULL;
+	HFree (Orbit->light_diff);
+	Orbit->light_diff = NULL;
 
 	DestroyStringTable (ReleaseStringTable (
 			pSolarSysState->SysInfo.PlanetInfo.DiscoveryString
diff -ruNp src.orig/uqm/planets/planets.h src/uqm/planets/planets.h
--- src.orig/uqm/planets/planets.h	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/planets.h	2017-11-01 15:31:03 -0700
@@ -16,11 +16,24 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: Added definition of PLANET_RESTRICTED. Restricted planets cannot be landed on.
+
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
 #ifndef _PLANETS_H
 #define _PLANETS_H
 
 #define END_INTERPLANETARY START_INTERPLANETARY
 
+#define ORBITING_PLANETS TRUE
+#define ROTATING_PLANETS TRUE
+#define TEXTURED_PLANETS (TRUE || ROTATING_PLANETS)
+// TEXTURED_PLANETS should always be defined TRUE if ROTATING_PLANETS is.
+#define ONE_YEAR 365.25
+#ifndef M_PI
+#define M_PI 3.141592653589
+#endif
+
 enum PlanetScanTypes
 {
 	MINERAL_SCAN = 0,
@@ -31,7 +44,9 @@ enum PlanetScanTypes
 };
 
 #define MAP_WIDTH SIS_SCREEN_WIDTH
-#define MAP_HEIGHT (75 - SAFE_Y)
+#define MAP_HEIGHT RES_CASE(75,150,330) // JMS_GFX
+#define ORIGINAL_MAP_WIDTH 242			// JMS_GFX
+#define ORIGINAL_MAP_HEIGHT 75			// JMS_GFX
 
 enum
 {
@@ -54,6 +69,8 @@ enum
 
 #define MAX_SCROUNGED 50 /* max lander can hold */
 
+#define DEPLETION_RATE 0.1
+
 #define SCALE_RADIUS(r) ((r) << 6)
 #define UNSCALE_RADIUS(r) ((r) >> 6)
 #define MAX_ZOOM_RADIUS SCALE_RADIUS(128)
@@ -67,23 +84,31 @@ enum
 
 #define NUM_SCANDOT_TRANSITIONS 4
 
-#define MIN_MOON_RADIUS 35
-#define MOON_DELTA 20
+#define MIN_MOON_RADIUS (35 << RESOLUTION_FACTOR) // JMS_GFX
+#define MOON_DELTA (20 << RESOLUTION_FACTOR) // JMS_GFX
+
+#define BLUE_SHIELD (1 << 0)
+
+// JMS: Restricted planets are not allowed to land on. For example race homeworlds
+// Earth, Procyon, Syreen homeworld. Plotwise this is because you wouldn't want aliens
+// landing on your backyard, stealing your minerals, would you?
+// Actually this is implemented just to hide the fact that Earth surface graphics
+// don't load properly upon landing... 
+#define PLANET_RESTRICTED (1 << 1)
+
 
 #define MAX_SUNS 1
 #define MAX_PLANETS 16
 #define MAX_MOONS 4
 
-#define MAP_BORDER_HEIGHT  5
+#define MAP_BORDER_HEIGHT  RES_CASE(5,10,10) // JMS_GFX
 #define SCAN_SCREEN_HEIGHT (SIS_SCREEN_HEIGHT - MAP_HEIGHT - MAP_BORDER_HEIGHT)
 
 #define PLANET_ROTATION_TIME (ONE_SECOND * 12)
-#define PLANET_ROTATION_RATE (PLANET_ROTATION_TIME / MAP_WIDTH)
+#define PLANET_ROTATION_RATE (PLANET_ROTATION_TIME / (MAP_WIDTH >> RESOLUTION_FACTOR))
 // XXX: -9 to match the original, but why? I have no idea
 #define PLANET_ORG_Y ((SCAN_SCREEN_HEIGHT - 9) / 2)
 
-#define NUM_RACE_RUINS  16
-
 typedef struct planet_desc PLANET_DESC;
 typedef struct star_desc STAR_DESC;
 typedef struct planet_orbit PLANET_ORBIT;
@@ -99,12 +124,47 @@ typedef struct solarsys_state SOLARSYS_S
 #include "plandata.h"
 #include "sundata.h"
 
+typedef struct 
+{
+	POINT p[4];
+	DWORD m[4];
+} MAP3D_POINT;
+
+struct planet_orbit
+{
+	FRAME TopoZoomFrame;
+			// 4x scaled topo image for planet-side
+	SBYTE  *lpTopoData;
+			// normal topo data; expressed in elevation levels
+			// data is signed for planets other than gas giants
+			// transformed to light variance map for 3d planet
+	FRAME SphereFrame;
+			// rotating 3d planet frames (current and next)
+	FRAME ObjectFrame;
+			// any extra planetary object (shield, atmo, rings)
+			// automatically drawn if present
+	FRAME TintFrame;
+			// tinted topo images for current scan type (dynamic)
+	Color TintColor;
+			// the color of the last used tint
+	Color *TopoColors;
+			// RGBA version of topo image; for 3d planet
+	Color *ScratchArray;
+			// temp RGBA data for whatever transforms (nuked often)
+	FRAME WorkFrame;
+			// any extra frame workspace (for dynamic objects)
+	// BW: extra stuff for animated IP
+	DWORD **light_diff;
+	MAP3D_POINT **map_rotate;
+	// doubly dynamically allocated depending on map size
+};
 
 struct planet_desc
 {
 	DWORD rand_seed;
 
 	BYTE data_index;
+	BYTE flags;
 	BYTE NumPlanets;
 	SIZE radius;
 	POINT location;
@@ -115,6 +175,13 @@ struct planet_desc
 
 	PLANET_DESC *pPrevDesc;
 			// The Sun or planet that this world is orbiting around.
+	// BW : new stuff for animated solar systems
+	PLANET_ORBIT orbit;
+	COUNT size;
+	COUNT angle;
+	double orb_speed;
+	double rot_speed;
+	int rotFrameIndex, rotPointIndex, rotDirection, rotwidth, rotheight;
 };
 
 struct star_desc
@@ -128,31 +195,6 @@ struct star_desc
 
 typedef void (*PLAN_GEN_FUNC) (BYTE control);
 
-struct planet_orbit
-{
-	FRAME TopoZoomFrame;
-			// 4x scaled topo image for planet-side
-	SBYTE  *lpTopoData;
-			// normal topo data; expressed in elevation levels
-			// data is signed for planets other than gas giants
-			// transformed to light variance map for 3d planet
-	FRAME SphereFrame;
-			// rotating 3d planet frames (current and next)
-	FRAME ObjectFrame;
-			// any extra planetary object (shield, atmo, rings)
-			// automatically drawn if present
-	FRAME TintFrame;
-			// tinted topo images for current scan type (dynamic)
-	Color TintColor;
-			// the color of the last used tint
-	Color *TopoColors;
-			// RGBA version of topo image; for 3d planet
-	Color *ScratchArray;
-			// temp RGBA data for whatever transforms (nuked often)
-	FRAME WorkFrame;
-			// any extra frame workspace (for dynamic objects)
-};
-
 // See doc/devel/generate for information on how this structure is
 // filled.
 struct solarsys_state
@@ -206,6 +248,7 @@ struct solarsys_state
 
 	SYSTEM_INFO SysInfo;
 
+	COUNT CurNode;
 	const GenerateFunctions *genFuncs;
 			// Functions to call to fill in various parts of this structure.
 			// See generate.h, doc/devel/generate
@@ -255,18 +298,20 @@ extern void ExploreSolarSys (void);
 extern void DrawStarBackGround (void);
 extern void XFormIPLoc (POINT *pIn, POINT *pOut, BOOLEAN ToDisplay);
 extern PLAN_GEN_FUNC GenerateIP (BYTE Index);
-extern void DrawOval (RECT *pRect, BYTE num_off_pixels);
+extern void DrawOval (RECT *pRect, BYTE num_off_pixels, BYTE thickness);
 extern void DrawFilledOval (RECT *pRect);
+extern void ComputeSpeed(PLANET_DESC *planet, BOOLEAN GeneratingMoons, UWORD rand_val);
 extern void FillOrbits (SOLARSYS_STATE *system, BYTE NumPlanets,
 		PLANET_DESC *pBaseDesc, BOOLEAN TypesDefined);
 extern void InitLander (BYTE LanderFlags);
 
-extern void InitSphereRotation (int direction, BOOLEAN shielded);
+extern void InitSphereRotation (int direction, BOOLEAN shielded, COUNT width, COUNT height);
 extern void UninitSphereRotation (void);
 extern void PrepareNextRotationFrame (void);
+extern void PrepareNextRotationFrameForIP (PLANET_DESC *pPlanetDesc, SIZE frameCounter);
 extern void DrawPlanetSphere (int x, int y);
 extern void DrawDefaultPlanetSphere (void);
-extern void RenderPlanetSphere (FRAME Frame, int offset, BOOLEAN doThrob);
+extern void RenderPlanetSphere (PLANET_ORBIT *Orbit, FRAME Frame, int offset, BOOLEAN shielded, BYTE flags, BOOLEAN doThrob, COUNT width, COUNT height, COUNT radius);
 extern void SetShieldThrobEffect (FRAME FromFrame, int offset, FRAME ToFrame);
 
 extern void ZoomInPlanetSphere (void);
@@ -275,6 +320,8 @@ extern void RotatePlanetSphere (BOOLEAN
 extern void DrawScannedObjects (BOOLEAN Reversed);
 extern void GeneratePlanetSurface (PLANET_DESC *pPlanetDesc,
 		FRAME SurfDefFrame);
+extern void GeneratePlanetSurfaceForIP (PLANET_DESC *pPlanetDesc,
+		FRAME SurfDefFrame, COUNT width, COUNT height);
 extern void DeltaTopography (COUNT num_iterations, SBYTE *DepthArray,
 		RECT *pRect, SIZE depth_delta);
 
diff -ruNp src.orig/uqm/planets/plangen.c src/uqm/planets/plangen.c
--- src.orig/uqm/planets/plangen.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/plangen.c	2017-11-01 15:31:03 -0700
@@ -16,6 +16,15 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: -Don't draw 4x image of restricted planets since they cannot be landed on anyway.
+
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
+// BW 2011: fixed using pixmaps to define planet surfaces so it actually works
+// on planets you can land on. The second frame of planetmask.ani has to be a
+// (Black & White) indexed pic with 128 colors top. Lesser indices (black)
+// will correspond to lower altitudes.
+
 #include "planets.h"
 #include "scan.h"
 #include "../nameref.h"
@@ -41,14 +50,15 @@
 #define SHIELD_REFLECT_COMP 100
 
 #define NUM_BATCH_POINTS 64
-#define RADIUS 37
+#define RADIUS RES_CASE(37,74,163) // JMS_GFX
 //2*RADIUS
 #define TWORADIUS (RADIUS << 1)
 //RADIUS^2
 #define RADIUS_2 (RADIUS * RADIUS)
 // distance beyond which all pixels are transparent (for aa)
 #define RADIUS_THRES  ((RADIUS + 1) * (RADIUS + 1))
-#define DIAMETER (TWORADIUS + 1)
+#define DIAMETER (TWORADIUS + 1) // JMS_GFX
+
 #if 0
 #	define SPHERE_SPAN_X (MAP_WIDTH >> 1)
 #else
@@ -72,77 +82,69 @@
 #define M_DEG2RAD (M_TWOPI / 360.0)
 #endif
 
-DWORD light_diff[DIAMETER][DIAMETER];
-
-typedef struct 
-{
-	POINT p[4];
-	DWORD m[4];
-} MAP3D_POINT;
-
-MAP3D_POINT map_rotate[DIAMETER][DIAMETER];
+// BW: dynamically allocated in the orbit structure
+// JMS_GFX: Changed initialization to constant numbers since DIAMETER is now variably defined
+// The value 330 is the value that's reached at the biggest resolution, 4x.
+// DWORD light_diff[330][330]; //DWORD light_diff[DIAMETER][DIAMETER];
+
+// JMS_GFX: Changed initialization to constant numbers since DIAMETER is now variably defined
+// The value 330 is the value that's reached at the biggest resolution, 4x.
+// MAP3D_POINT map_rotate[330][330];//MAP3D_POINT map_rotate[DIAMETER][DIAMETER];
 
 typedef struct
 {
 	double x, y, z;
 } POINT3;
 
+// BW : changed rendering method to direct SDL routines like in
+// RenderPlanetSphere to improve performance at 4x
 static void
-RenderTopography (FRAME DstFrame, SBYTE *pTopoData, int w, int h)
+RenderTopography (FRAME DstFrame, SBYTE *pTopoData, int w, int h, BOOLEAN SurfDef)
 {
-	FRAME OldFrame;
-
-	OldFrame = SetContextFGFrame (DstFrame);
-
 	if (pSolarSysState->XlatRef == 0)
 	{
 		// There is currently nothing we can do w/o an xlat table
 		// This is still called for Earth for 4x scaled topo, but we
 		// do not need it because we cannot land on Earth.
+		log_add(log_Warning, "No xlat table -- could not generate surface.\n");
 	}
 	else
 	{
-		COUNT i;
 		BYTE AlgoType;
 		SIZE base, d;
 		const XLAT_DESC *xlatDesc;
 		POINT pt;
 		const PlanetFrame *PlanDataPtr;
-		PRIMITIVE BatchArray[NUM_BATCH_POINTS];
-		PRIMITIVE *pBatch;
 		SBYTE *pSrc;
 		const BYTE *xlat_tab;
 		BYTE *cbase;
-		POINT oldOrigin;
-		RECT ClipRect;
+		Color *pix;
+		Color *map;
 
-		oldOrigin = SetContextOrigin (MAKE_POINT (0, 0));
-		GetContextClipRect (&ClipRect);
-		SetContextClipRect (NULL);
-
-		pBatch = &BatchArray[0];
-		for (i = 0; i < NUM_BATCH_POINTS; ++i, ++pBatch)
-		{
-			SetPrimNextLink (pBatch, i + 1);
-			SetPrimType (pBatch, POINT_PRIM);
-		}
-		SetPrimNextLink (&pBatch[-1], END_OF_LIST);
+		map = HMalloc (sizeof (Color) * w * h);
+		pix = map;
 
 		PlanDataPtr = &PlanData[
 				pSolarSysState->pOrbitalDesc->data_index & ~PLANET_SHIELDED
 				];
 		AlgoType = PLANALGO (PlanDataPtr->Type);
-		base = PlanDataPtr->base_elevation;
+		if (SurfDef)
+			{
+				// Planets given by a pixmap have elevations between -128 and +128
+				base = 256;
+			}
+		else
+			{
+				base = PlanDataPtr->base_elevation;
+			}
 		xlatDesc = (const XLAT_DESC *) pSolarSysState->XlatPtr;
 		xlat_tab = (const BYTE *) xlatDesc->xlat_tab;
 		cbase = GetColorMapAddress (pSolarSysState->OrbitalCMap);
 
-		i = NUM_BATCH_POINTS;
-		pBatch = &BatchArray[i];
 		pSrc = pTopoData;
 		for (pt.y = 0; pt.y < h; ++pt.y)
 		{
-			for (pt.x = 0; pt.x < w; ++pt.x, ++pSrc)
+			for (pt.x = 0; pt.x < w; ++pt.x, ++pSrc, ++pix)
 			{
 				BYTE *ctab;
 
@@ -160,37 +162,18 @@ RenderTopography (FRAME DstFrame, SBYTE
 						d = 255;
 				}
 
-				--pBatch;
-				pBatch->Object.Point.x = pt.x;
-				pBatch->Object.Point.y = pt.y;
-
 				d = xlat_tab[d] - cbase[0];
 				ctab = (cbase + 2) + d * 3;
 
 				// fixed planet surfaces being too dark
 				// ctab shifts were previously >> 3 .. -Mika
-				SetPrimColor (pBatch, BUILD_COLOR (MAKE_RGB15 (ctab[0] >> 1,
-								ctab[1] >> 1, ctab[2] >> 1), d));
-				
-				if (--i == 0)
-				{	// flush the batch and start the next one
-					DrawBatch (BatchArray, 0, 0);
-					i = NUM_BATCH_POINTS;
-					pBatch = &BatchArray[i];
-				}
+				*pix = BUILD_COLOR (MAKE_RGB15 (ctab[0] >> 1, ctab[1] >> 1, ctab[2] >> 1), d);				
 			}
 		}
 
-		if (i < NUM_BATCH_POINTS)
-		{
-			DrawBatch (BatchArray, i, 0);
-		}
-
-		SetContextClipRect (&ClipRect);
-		SetContextOrigin (oldOrigin);
+		WriteFramePixelColors (DstFrame, map, w, h);
+		HFree(map);
 	}
-
-	SetContextFGFrame (OldFrame);
 }
 
 static inline void
@@ -225,13 +208,16 @@ P3norm (POINT3 *res, POINT3 *vec)
 // GenerateSphereMask builds a shadow map for the rotating planet
 //  loc indicates the planet's position relative to the sun
 static void
-GenerateSphereMask (POINT loc)
+GenerateSphereMask (POINT loc, COUNT radius)
 {
 	POINT pt;
 	POINT3 light;
 	double lrad;
 	const DWORD step = 1 << DIFFUSE_BITS;
 	int y, x;
+	COUNT tworadius = radius << 1;
+	COUNT radius_thres = (radius + 1) * (radius + 1);
+	COUNT radius_2 = radius * radius;
 
 #define AMBIENT_LIGHT 0.1
 #define LIGHT_Z       1.2
@@ -244,11 +230,11 @@ GenerateSphereMask (POINT loc)
 	light.z = LIGHT_Z * lrad;
 	P3norm (&light, &light);
 	
-	for (pt.y = 0, y = -RADIUS; pt.y <= TWORADIUS; ++pt.y, y++)
+	for (pt.y = 0, y = -radius; pt.y <= tworadius; ++pt.y, y++)
 	{
 		DWORD y_2 = y * y;
 
-		for (pt.x = 0, x = -RADIUS; pt.x <= TWORADIUS; ++pt.x, x++)
+		for (pt.x = 0, x = -radius; pt.x <= tworadius; ++pt.x, x++)
 		{
 			DWORD x_2 = x * x;
 			DWORD rad_2 = x_2 + y_2;
@@ -256,13 +242,13 @@ GenerateSphereMask (POINT loc)
 			POINT3 norm;
 			double diff;
 			
-			if (rad_2 < RADIUS_THRES) 
+			if (rad_2 < radius_thres) 
 			{
 				// norm is the sphere's surface normal.
 				norm.x = (double)x;
 				norm.y = (double)y;
-				norm.z = (sqrt (RADIUS_2 - x_2) * sqrt (RADIUS_2 - y_2)) /
-						RADIUS;
+				norm.z = (sqrt (radius_2 - x_2) * sqrt (radius_2 - y_2)) /
+						radius;
 				P3norm (&norm, &norm);
 				// diffuse component is norm dot light
 				diff = P3dot (&norm, &light);
@@ -305,9 +291,9 @@ GenerateSphereMask (POINT loc)
 				if (diff < AMBIENT_LIGHT)
 					diff = AMBIENT_LIGHT;
 				// Now we antialias the edge of the spere to look nice
-				if (rad_2 > RADIUS_2) 
+				if (rad_2 > radius_2) 
 				{
-					diff *= 1 - (sqrt(rad_2) - RADIUS);
+					diff *= 1 - (sqrt(rad_2) - radius);
 					if (diff < 0) 
 						diff = 0;
 				}
@@ -316,7 +302,7 @@ GenerateSphereMask (POINT loc)
 				diff_int = (DWORD)(diff * step);
 			}
 
-			light_diff[pt.y][pt.x] = diff_int;
+			pSolarSysState->Orbit.light_diff[pt.y][pt.x] = diff_int;
 		}
 	}
 }
@@ -324,23 +310,26 @@ GenerateSphereMask (POINT loc)
 //create_aa_points creates weighted averages for
 //  4 points around the 'ideal' point at x,y
 //  the concept is to compute the weight based on the
-//  distance from the integer location points to the ideal point
+//  distance from the integer location points to the ideal point.
+//
+// JMS_GFX: Added 'height' variable, used it to replace MAP_HEIGHT and SPHERE_SPAN_X.
 static void
-create_aa_points (MAP3D_POINT *ppt, double x, double y)
+create_aa_points (MAP3D_POINT *ppt, double x, double y, COUNT height)
 {
 	double deltax, deltay, inv_deltax, inv_deltay;
 	COORD nextx, nexty;
 	COUNT i;
 	double d1, d2, d3, d4, m[4];
+	COUNT spherespanx = height;
 
 	if (x < 0)
 		x = 0;
-	else if (x >= SPHERE_SPAN_X)
-		x = SPHERE_SPAN_X - 1;
+	else if (x >= spherespanx) // was SPHERE_SPAN_X
+		x = spherespanx - 1;
 	if (y < 0)
 		y = 0;
-	else if (y >= MAP_HEIGHT)
-		y = MAP_HEIGHT - 1;
+	else if (y >= height)
+		y = height - 1;
 
 	// get  the integer value of this point
 	ppt->p[0].x = (COORD)x;
@@ -435,32 +424,36 @@ get_avg_channel (Color p[4], DWORD mult[
 }
 
 // CreateSphereTiltMap creates 'map_rotate' to map the topo data
-//  for a tilted planet.  It also does the sphere->plane mapping
+//  for a tilted planet.  It also does the sphere->plane mapping.
+//
+// JMS_GFX: Added 'height' and 'radius' to make hi-res work.
 static void
-CreateSphereTiltMap (int angle)
+CreateSphereTiltMap (int angle, COUNT height, COUNT radius)
 {
 	int x, y;
-	const double multx = ((double)SPHERE_SPAN_X / M_PI);
-	const double multy = ((double)MAP_HEIGHT / M_PI);
-	const double xadj = ((double)SPHERE_SPAN_X / 2.0);
-
-	for (y = -RADIUS; y <= RADIUS; y++)
+	COUNT spherespanx = height;							// JMS_GFX
+	COUNT radius_thres = (radius + 1) * (radius + 1);	// JMS_GFX
+	const double multx = ((double)spherespanx / M_PI);
+	const double multy = ((double)height / M_PI);
+	const double xadj = ((double)spherespanx / 2.0);
+	
+	for (y = -radius; y <= radius; y++)
 	{
 		int y_2 = y * y;
 
-		for (x = -RADIUS; x <= RADIUS; x++)
+		for (x = -radius; x <= radius; x++)
 		{
 			double dx, dy, newx, newy;
 			double da, rad, rad_2;
 			double xa, ya;
-			MAP3D_POINT *ppt = &map_rotate[y + RADIUS][x + RADIUS];
+			MAP3D_POINT *ppt = &pSolarSysState->Orbit.map_rotate[y + radius][x + radius];
 			
 			rad_2 = x * x + y_2;
 
-			if (rad_2 >= RADIUS_THRES)
+			if (rad_2 >= radius_thres)
 			{	// pixel won't be present
-				ppt->p[0].x = x + RADIUS;
-				ppt->p[0].y = y + RADIUS;
+				ppt->p[0].x = x + radius;
+				ppt->p[0].y = y + radius;
 				ppt->m[0] = 0;
 
 				continue;
@@ -468,8 +461,10 @@ CreateSphereTiltMap (int angle)
 			
 			rad = sqrt (rad_2);
 			// antialiasing goes beyond the actual radius
-			if (rad >= RADIUS)
-				rad = (double)RADIUS - 0.1;
+            // N.B. Was >=radius, but in extreme cases would result in the next
+            // aa pixel being 330, when the maximum value row is 329.
+            if (rad > (radius-1))
+				rad = (double)radius - 0.1;
 			
 			da = atan2 ((double)y, (double)x);
 			// compute the planet-tilt
@@ -478,8 +473,8 @@ CreateSphereTiltMap (int angle)
 			dy = rad * sin (da);
 
 			// Map the sphere onto a plane
-			xa = acos (-dx / RADIUS);
-			ya = acos (-dy / RADIUS);
+			xa = acos (-dx / radius);
+			ya = acos (-dy / radius);
 			newx = multx * xa;
 			newy = multy * ya;
 			// Adjust for vertical curvature
@@ -488,7 +483,7 @@ CreateSphereTiltMap (int angle)
 			else
 				newx = xadj + ((newx - xadj) / sin (ya));
 
-			create_aa_points (ppt, newx, newy);
+			create_aa_points (ppt, newx, newy, height);
 		}
 	}
 }
@@ -501,34 +496,38 @@ CreateSphereTiltMap (int angle)
 // this routine, but a filter can be applied if desired too.
 
 // HALO rim size
-#define SHIELD_HALO          7
+#define SHIELD_HALO          (7 << RESOLUTION_FACTOR) // JMS_GFX
 #define SHIELD_RADIUS        (RADIUS + SHIELD_HALO)
-#define SHIELD_DIAM          ((SHIELD_RADIUS << 1) + 1)
+#define SHIELD_DIAM          ((SHIELD_RADIUS << 1) + 1) 
 #define SHIELD_RADIUS_2      (SHIELD_RADIUS * SHIELD_RADIUS)
-#define SHIELD_RADIUS_THRES  ((SHIELD_RADIUS + 1) * (SHIELD_RADIUS + 1))
+#define SHIELD_RADIUS_THRES  ((SHIELD_RADIUS + (1 << RESOLUTION_FACTOR)) * (SHIELD_RADIUS + (1 << RESOLUTION_FACTOR))) // JMS_GFX
 #define SHIELD_HALO_GLOW     (SHIELD_GLOW_COMP + SHIELD_REFLECT_COMP)
 #define SHIELD_HALO_GLOW_MIN (SHIELD_HALO_GLOW >> 2)
 
 static FRAME
-CreateShieldMask (void)
+CreateShieldMask (COUNT radius, BYTE flags)
 {
 	Color clear;
 	Color *pix;
 	int x, y;
 	FRAME ShieldFrame;
 	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
-
+	COUNT shieldradius = SHIELD_RADIUS * radius / RADIUS;
+	COUNT shielddiam = (shieldradius << 1) + 1;
+	COUNT radius_2 = radius * radius;
+	COUNT shieldradius_thres = (shieldradius + 1) * (shieldradius + 1);
+	
 	ShieldFrame = CaptureDrawable (
 			CreateDrawable (WANT_PIXMAP | WANT_ALPHA,
-				SHIELD_DIAM, SHIELD_DIAM, 1));
+					shielddiam, shielddiam, 1));
 
 	pix = Orbit->ScratchArray;
 	//  This is 100% transparent.
 	clear = BUILD_COLOR_RGBA (0, 0, 0, 0);
 
-	for (y = -SHIELD_RADIUS; y <= SHIELD_RADIUS; y++)
+	for (y = -shieldradius; y <= shieldradius; y++)
 	{
-		for (x = -SHIELD_RADIUS; x <= SHIELD_RADIUS; ++x, ++pix)
+		for (x = -shieldradius; x <= shieldradius; ++x, ++pix)
 		{
 			int rad_2 = x * x + y * y;
 			// This is a non-transparent red for the halo
@@ -536,13 +535,13 @@ CreateShieldMask (void)
 			int alpha = 255;
 			double rad;
 			
-			if (rad_2 >= SHIELD_RADIUS_THRES)
+			if (rad_2 >= shieldradius_thres)
 			{	// outside all bounds
 				*pix = clear;
 				continue;
 			}
 			// Inside the halo
-			if (rad_2 <= RADIUS_2)
+			if (rad_2 <= radius_2)
 			{	// planet's pixels, ours transparent
 				*pix = clear;
 				continue;
@@ -551,28 +550,31 @@ CreateShieldMask (void)
 			// The halo itself
 			rad = sqrt (rad_2);
 
-			if (rad <= RADIUS + 0.8)
+			if (rad <= radius + 0.8)
 			{	// pixels common between the shield and planet
 				// do antialiasing using alpha
-				alpha = (int) (red * (rad - RADIUS));
+				alpha = (int) (red * (rad - radius));
 				red = 255;
 			}
 			else
 			{	// shield pixels
-				red -= (int) ((red - SHIELD_HALO_GLOW_MIN) * (rad - RADIUS)
-						/ SHIELD_HALO);
+				red -= (int) ((red - SHIELD_HALO_GLOW_MIN) * (rad - radius)
+						/ (SHIELD_HALO * radius / RADIUS));
 				if (red < 0)
 					red = 0;
 			}
 			
-			*pix = BUILD_COLOR_RGBA (red, 0, 0, alpha);
+			if (flags & BLUE_SHIELD)
+				*pix = BUILD_COLOR_RGBA (0, 0, red, alpha);
+			else
+				*pix = BUILD_COLOR_RGBA (red, 0, 0, alpha);
 		}
 	}
 	
 	WriteFramePixelColors (ShieldFrame, Orbit->ScratchArray,
-			SHIELD_DIAM, SHIELD_DIAM);
-	SetFrameHot (ShieldFrame, MAKE_HOT_SPOT (SHIELD_RADIUS + 1,
-				SHIELD_RADIUS + 1));
+			shielddiam, shielddiam);
+	SetFrameHot (ShieldFrame, MAKE_HOT_SPOT (shieldradius + 1,
+				shieldradius + 1));
 	
 	return ShieldFrame;
 }
@@ -589,13 +591,15 @@ CreateShieldMask (void)
 #define THROB_D_LEVEL   (THROB_MAX_LEVEL - THROB_MIN_LEVEL)
 
 static inline int
-shield_level (int offset)
+shield_level (int offset, int width)
 {
 	int level;
+	int throb_cycle = ((width << 8) / SHIELD_THROBS);
+	int throb_half_cycle = throb_cycle >> 1;
 
-	offset = (offset << 8) % THROB_CYCLE;
-	level = abs (offset - THROB_HALF_CYCLE);
-	level = THROB_MIN_LEVEL + level * THROB_D_LEVEL / THROB_HALF_CYCLE;
+	offset = (offset << 8) % throb_cycle;
+	level = abs (offset - throb_half_cycle);
+	level = THROB_MIN_LEVEL + level * THROB_D_LEVEL / throb_half_cycle;
 
 	return level;
 }
@@ -610,11 +614,12 @@ SetShieldThrobEffect (FRAME ShieldFrame,
 	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
 	Color *pix;
 	int level;
-
-	level = shield_level (offset);
-
+	
 	width = GetFrameWidth (ShieldFrame);
 	height = GetFrameHeight (ShieldFrame);
+
+	level = shield_level (offset, width);
+
 	ReadFramePixelColors (ShieldFrame, Orbit->ScratchArray, width, height);
 	
 	for (i = 0, pix = Orbit->ScratchArray; i < width * height; ++i, ++pix)
@@ -641,19 +646,22 @@ SetShieldThrobEffect (FRAME ShieldFrame,
 
 // Apply the shield to the topo image
 static void
-ApplyShieldTint (void)
+ApplyShieldTint (BYTE flags)
 {
 	DrawMode mode, oldMode;
 	FRAME oldFrame;
 	Color tint;
 	RECT r;
-
+	
 	// TopoFrame will be permanently changed
 	oldFrame = SetContextFGFrame (pSolarSysState->TopoFrame);
 	SetContextClipRect (NULL);
 	GetContextClipRect (&r);
 
-	tint = BUILD_COLOR_RGBA (0xff, 0x00, 0x00, 0xff);
+	if (flags & BLUE_SHIELD)
+		tint = BUILD_COLOR_RGBA (0x00, 0x00, 0xff, 0xff);
+	else
+		tint = BUILD_COLOR_RGBA (0xff, 0x00, 0x00, 0xff);
 #ifdef USE_ALPHA_SHIELD
 	mode = MAKE_DRAW_MODE (DRAW_ALPHA, 150);
 #else
@@ -670,7 +678,7 @@ static inline UBYTE
 calc_map_light (UBYTE val, DWORD dif, int lvf)
 {
 	int i;
-
+	
 	// apply diffusion
 	i = (dif * val) >> DIFFUSE_BITS;
 	// apply light variance for 3d lighting effect
@@ -685,24 +693,23 @@ calc_map_light (UBYTE val, DWORD dif, in
 }
 
 static inline Color
-get_map_pixel (Color *pixels, int x, int y)
-{
-	return pixels[y * (MAP_WIDTH + SPHERE_SPAN_X) + x];
+get_map_pixel (Color *pixels, int x, int y, COUNT width, COUNT spherespanx)
+{ 
+	return pixels[y * (width + spherespanx) + x];
 }
 
 static inline int
-get_map_elev (SBYTE *elevs, int x, int y, int offset)
+get_map_elev (SBYTE *elevs, int x, int y, int offset, COUNT width)
 {
-	return elevs[y * MAP_WIDTH + (offset + x) % MAP_WIDTH];
+	return elevs[y * width + (offset + x) % width];
 }
 
 // RenderPlanetSphere builds a frame for the rotating planet view
 // offset is effectively the angle of rotation around the planet's axis
 // We use the SDL routines to directly write to the SDL_Surface to improve performance
 void
-RenderPlanetSphere (FRAME MaskFrame, int offset, BOOLEAN doThrob)
+RenderPlanetSphere (PLANET_ORBIT *Orbit, FRAME MaskFrame, int offset, BOOLEAN shielded, BYTE flags, BOOLEAN doThrob, COUNT width, COUNT height, COUNT radius)
 {
-	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
 	POINT pt;
 	Color *pix;
 	Color clear;
@@ -710,6 +717,9 @@ RenderPlanetSphere (FRAME MaskFrame, int
 	Color *pixels;
 	SBYTE *elevs;
 	int shLevel;
+	COUNT spherespanx = height;
+	COUNT tworadius = radius << 1;
+	COUNT diameter = tworadius + 1;
 
 #if PROFILE_ROTATION
 	static clock_t t = 0;
@@ -718,22 +728,21 @@ RenderPlanetSphere (FRAME MaskFrame, int
 	t1 = clock ();
 #endif
 
-
-	shLevel = shield_level (offset);
+	shLevel = shield_level (offset, width);
 
 	pix = Orbit->ScratchArray;
 	clear = BUILD_COLOR_RGBA (0, 0, 0, 0);
 	pixels = Orbit->TopoColors + offset;
 	elevs = Orbit->lpTopoData;
 	
-	for (pt.y = 0, y = -RADIUS; pt.y <= TWORADIUS; ++pt.y, ++y)
+	for (pt.y = 0, y = -radius; pt.y <= tworadius; ++pt.y, ++y)
 	{
-		for (pt.x = 0, x = -RADIUS; pt.x <= TWORADIUS; ++pt.x, ++x, ++pix)
+		for (pt.x = 0, x = -radius; pt.x <= tworadius; ++pt.x, ++x, ++pix)
 		{
 			Color c;
-			DWORD diffus = light_diff[pt.y][pt.x];
+			DWORD diffus = Orbit->light_diff[pt.y][pt.x];
 			int i;
-			MAP3D_POINT *ppt = &map_rotate[pt.y][pt.x];
+			MAP3D_POINT *ppt = &Orbit->map_rotate[pt.y][pt.x];
 			int lvf; // light variance factor
 	
 			if (diffus == 0)
@@ -745,8 +754,8 @@ RenderPlanetSphere (FRAME MaskFrame, int
 			// get pixel from topo map and factor from light variance map
 			if (ppt->m[0] == 0) 
 			{	// exact pixel from the topo map
-				c = get_map_pixel (pixels, ppt->p[0].x, ppt->p[0].y);
-				lvf = get_map_elev (elevs, ppt->p[0].x, ppt->p[0].y, offset);
+				c = get_map_pixel (pixels, ppt->p[0].x, ppt->p[0].y, width, spherespanx);
+				lvf = get_map_elev (elevs, ppt->p[0].x, ppt->p[0].y, offset, width);
 			}
 			else
 			{	// fractional pixel -- blend from 4
@@ -755,7 +764,7 @@ RenderPlanetSphere (FRAME MaskFrame, int
 
 				// compute 'ideal' pixel
 				for (i = 0; i < 4; i++)
-					p[i] = get_map_pixel (pixels, ppt->p[i].x, ppt->p[i].y);
+					p[i] = get_map_pixel (pixels, ppt->p[i].x, ppt->p[i].y, width, spherespanx);
 				
 				c.r = get_avg_channel (p, ppt->m, 0);
 				c.g = get_avg_channel (p, ppt->m, 1);
@@ -764,19 +773,24 @@ RenderPlanetSphere (FRAME MaskFrame, int
 				// compute 'ideal' light variance
 				for (i = 0, lvsum = 0; i < 4; i++)
 					lvsum += get_map_elev (elevs, ppt->p[0].x, ppt->p[0].y,
-							offset) * ppt->m[i];
+							       offset, width) * ppt->m[i];
 				lvf = lvsum >> AA_WEIGHT_BITS;
 			}
 		
-			// Apply the lighting model.  This also bounds the sphere
+			// Apply the lighting model. This also bounds the sphere
 			// to make it circular.
-			if (pSolarSysState->pOrbitalDesc->data_index & PLANET_SHIELDED)
+			if (shielded)
 			{
 				int r;
 				
 				// add lite red filter (3/4) component
+				// JMS: Blue filter for blue shielded planets
+				if (flags & BLUE_SHIELD)
+					c.r = (c.r >> 1) + (c.r >> 2);
+				else
+					c.b = (c.b >> 1) + (c.b >> 2);
 				c.g = (c.g >> 1) + (c.g >> 2);
-				c.b = (c.b >> 1) + (c.b >> 2);
+				
 
 				c.r = calc_map_light (c.r, diffus, lvf);
 				c.g = calc_map_light (c.g, diffus, lvf);
@@ -791,10 +805,20 @@ RenderPlanetSphere (FRAME MaskFrame, int
 					r = r * shLevel / THROB_MAX_LEVEL;
 				}
 
-				r += c.r;
-				if (r > 255)
-					r = 255;
-				c.r = r;
+				if (flags & BLUE_SHIELD)
+				{
+					r += c.b;
+					if (r > 255)
+						r = 255;
+					c.b = r;
+				}
+				else
+				{
+					r += c.r;
+					if (r > 255)
+						r = 255;
+					c.r = r;
+				}
 			} 
 			else
 			{
@@ -808,12 +832,12 @@ RenderPlanetSphere (FRAME MaskFrame, int
 		}
 	}
 	
-	WriteFramePixelColors (MaskFrame, Orbit->ScratchArray, DIAMETER, DIAMETER);
-	SetFrameHot (MaskFrame, MAKE_HOT_SPOT (RADIUS + 1, RADIUS + 1));
+	WriteFramePixelColors (MaskFrame, Orbit->ScratchArray, diameter, diameter);
+	SetFrameHot (MaskFrame, MAKE_HOT_SPOT (radius + 1, radius + 1));
 
 #if PROFILE_ROTATION
 	t += clock() - t1;
-	if (frames_done == MAP_WIDTH)
+	if (frames_done == width)
 	{
 		log_add (log_Debug, "Rotation frames/sec: %d/%ld(msec)=%f",
 				frames_done,
@@ -831,14 +855,14 @@ RenderPlanetSphere (FRAME MaskFrame, int
 #define RANGE_SHIFT 6
 
 static void
-DitherMap (SBYTE *DepthArray)
+DitherMap (SBYTE *DepthArray, COUNT width, COUNT height)
 {
 #define DITHER_VARIANCE  (1 << (RANGE_SHIFT - 3))
-	COUNT i;
+	DWORD i;
 	SBYTE *elev;
 	DWORD rand_val = 0;
-
-	for (i = 0, elev = DepthArray; i < MAP_WIDTH * MAP_HEIGHT; ++i, ++elev)
+	
+	for (i = 0, elev = DepthArray; i < width * height; ++i, ++elev)
 	{
 		// Use up the random value byte by byte
 		if ((i & 3) == 0)
@@ -853,15 +877,14 @@ DitherMap (SBYTE *DepthArray)
 
 static void
 MakeCrater (RECT *pRect, SBYTE *DepthArray, SIZE rim_delta, SIZE
-		crater_delta, BOOLEAN SetDepth)
+		crater_delta, BOOLEAN SetDepth, COUNT width)
 {
 	COORD x, y, lf_x, rt_x;
 	SIZE A, B;
-	long Asquared, TwoAsquared,
-				Bsquared, TwoBsquared;
-	long d, dx, dy;
-	COUNT TopIndex, BotIndex, rim_pixels;
-
+	long int Asquared, TwoAsquared, Bsquared, TwoBsquared;
+	long int d, dx, dy;
+	DWORD TopIndex, BotIndex, rim_pixels;				// JMS_GFX: Was COUNT - type changed because of overflow at 4x
+	
 	A = pRect->extent.width >> 1;
 	B = pRect->extent.height >> 1;
 
@@ -879,8 +902,8 @@ MakeCrater (RECT *pRect, SBYTE *DepthArr
 
 	A += pRect->corner.x;
 	B += pRect->corner.y;
-	TopIndex = (B - y) * MAP_WIDTH;
-	BotIndex = (B + y) * MAP_WIDTH;
+	TopIndex = (B - y) * width;
+	BotIndex = (B + y) * width;
 	rim_pixels = 1;
 	while (dx < dy)
 	{
@@ -932,8 +955,8 @@ MakeCrater (RECT *pRect, SBYTE *DepthArr
 			}
 		
 			--y;
-			TopIndex += MAP_WIDTH;
-			BotIndex -= MAP_WIDTH;
+			TopIndex += width;
+			BotIndex -= width;
 			dy -= TwoAsquared;
 			d -= dy;
 		}
@@ -1001,8 +1024,8 @@ MakeCrater (RECT *pRect, SBYTE *DepthArr
 
 		rim_pixels = 1;
 		--y;
-		TopIndex += MAP_WIDTH;
-		BotIndex -= MAP_WIDTH;
+		TopIndex += width;
+		BotIndex -= width;
 		dy -= TwoAsquared;
 		d += Asquared - dy;
 	}
@@ -1044,13 +1067,13 @@ MakeCrater (RECT *pRect, SBYTE *DepthArr
 #define NUM_BAND_COLORS 4
 
 static void
-MakeStorms (COUNT storm_count, SBYTE *DepthArray)
+MakeStorms (COUNT storm_count, SBYTE *DepthArray, COUNT width, COUNT height)
 {
-#define MAX_STORMS 8
+#define MAX_STORMS 12 // JMS_GFX: was 8
 	COUNT i;
 	RECT storm_r[MAX_STORMS];
 	RECT *pstorm_r;
-
+	
 	pstorm_r = &storm_r[i = storm_count];
 	while (i--)
 	{
@@ -1073,20 +1096,20 @@ MakeStorms (COUNT storm_count, SBYTE *De
 			{
 				case 0:
 					pstorm_r->extent.height =
-							(LOBYTE (hiword) % (MAP_HEIGHT >> 2))
-							+ (MAP_HEIGHT >> 2);
+							(LOBYTE (hiword) % (ORIGINAL_MAP_HEIGHT >> 2))
+							+ (ORIGINAL_MAP_HEIGHT >> 2);
 					break;
 				case 1:
 				case 2:
 				case 3:
 				case 4:
 					pstorm_r->extent.height =
-							(LOBYTE (hiword) % (MAP_HEIGHT >> 3))
-							+ (MAP_HEIGHT >> 3);
+							(LOBYTE (hiword) % (ORIGINAL_MAP_HEIGHT >> 3))
+							+ (ORIGINAL_MAP_HEIGHT >> 3);
 					break;
 				default:
 					pstorm_r->extent.height =
-							(LOBYTE (hiword) % (MAP_HEIGHT >> 4))
+							(LOBYTE (hiword) % (ORIGINAL_MAP_HEIGHT >> 4))
 							+ 4;
 					break;
 			}
@@ -1098,14 +1121,17 @@ MakeStorms (COUNT storm_count, SBYTE *De
 			loword = LOWORD (rand_val);
 			hiword = HIWORD (rand_val);
 
-			pstorm_r->extent.width = pstorm_r->extent.height
-					+ (LOBYTE (loword) % pstorm_r->extent.height);
-
-			pstorm_r->corner.x = HIBYTE (loword)
-					% (MAP_WIDTH - pstorm_r->extent.width);
-			pstorm_r->corner.y = LOBYTE (loword)
-					% (MAP_HEIGHT - pstorm_r->extent.height);
+			pstorm_r->extent.width = pstorm_r->extent.height + (LOBYTE (loword) % pstorm_r->extent.height);
 
+			//pstorm_r->corner.x = HIBYTE (loword) % (MAP_WIDTH - pstorm_r->extent.width);
+			pstorm_r->corner.x = HIBYTE (loword) % (ORIGINAL_MAP_WIDTH - pstorm_r->extent.width); // JMS_GFX: changed the previous line to this. BYTE was too small for 640x480 resolution
+			pstorm_r->corner.y = LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT - pstorm_r->extent.height);
+			
+			pstorm_r->corner.x = pstorm_r->corner.x * width / ORIGINAL_MAP_WIDTH;
+			pstorm_r->extent.width = pstorm_r->extent.width * width / ORIGINAL_MAP_WIDTH;
+			pstorm_r->corner.y = pstorm_r->corner.y * height / ORIGINAL_MAP_HEIGHT;
+			pstorm_r->extent.height = pstorm_r->extent.height * height / ORIGINAL_MAP_HEIGHT;
+			
 			for (j = i + 1; j < storm_count; ++j)
 			{
 				COORD x, y;
@@ -1124,7 +1150,7 @@ MakeStorms (COUNT storm_count, SBYTE *De
 
 		} while (intersect);
 
-		MakeCrater (pstorm_r, DepthArray, 6, 6, FALSE);
+		MakeCrater (pstorm_r, DepthArray, 6, 6, FALSE, width);
 		++pstorm_r->corner.x;
 		++pstorm_r->corner.y;
 		pstorm_r->extent.width -= 2;
@@ -1133,7 +1159,7 @@ MakeStorms (COUNT storm_count, SBYTE *De
 		band_delta = HIBYTE (loword) & ((3 << RANGE_SHIFT) + 20);
 
 		MakeCrater (pstorm_r, DepthArray,
-				band_delta, band_delta, TRUE);
+				band_delta, band_delta, TRUE, width);
 		++pstorm_r->corner.x;
 		++pstorm_r->corner.y;
 		pstorm_r->extent.width -= 2;
@@ -1143,7 +1169,7 @@ MakeStorms (COUNT storm_count, SBYTE *De
 		if (pstorm_r->extent.width > 2 && pstorm_r->extent.height > 2)
 		{
 			MakeCrater (pstorm_r, DepthArray,
-					band_delta, band_delta, TRUE);
+					band_delta, band_delta, TRUE, width);
 			++pstorm_r->corner.x;
 			++pstorm_r->corner.y;
 			pstorm_r->extent.width -= 2;
@@ -1154,7 +1180,7 @@ MakeStorms (COUNT storm_count, SBYTE *De
 		if (pstorm_r->extent.width > 2 && pstorm_r->extent.height > 2)
 		{
 			MakeCrater (pstorm_r, DepthArray,
-					band_delta, band_delta, TRUE);
+					band_delta, band_delta, TRUE, width);
 			++pstorm_r->corner.x;
 			++pstorm_r->corner.y;
 			pstorm_r->extent.width -= 2;
@@ -1163,7 +1189,7 @@ MakeStorms (COUNT storm_count, SBYTE *De
 
 		band_delta += 4;
 		MakeCrater (pstorm_r, DepthArray,
-				band_delta, band_delta, TRUE);
+				band_delta, band_delta, TRUE, width);
 	}
 }
 
@@ -1177,9 +1203,12 @@ MakeGasGiant (COUNT num_bands, SBYTE *De
 	SBYTE *lpDst;
 	UWORD loword, hiword;
 	DWORD rand_val;
-
-	band_height = pRect->extent.height / num_bands;
-	band_bump = pRect->extent.height % num_bands;
+	
+	// band_height = pRect->extent.height / num_bands;
+	band_height = ORIGINAL_MAP_HEIGHT / num_bands;
+	// band_bump = pRect->extent.height % num_bands;
+	band_bump = ORIGINAL_MAP_HEIGHT % num_bands;
+	
 	band_error = num_bands >> 1;
 	lpDst = DepthArray;
 
@@ -1207,14 +1236,14 @@ MakeGasGiant (COUNT num_bands, SBYTE *De
 		{
 			RECT r;
 
-			cur_y = next_y
-					+ ((band_height - 2) >> 1)
-					- ((LOBYTE (hiword) % (band_height - 2)) + 1);
+			cur_y = next_y + ((band_height - 2) >> 1) - ((LOBYTE (hiword) % (band_height - 2)) + 1);
+			cur_y = cur_y * pRect->extent.height / ORIGINAL_MAP_HEIGHT;
 			r.corner.x = r.corner.y = 0;
 			r.extent.width = pRect->extent.width;
-			r.extent.height = 5;
+			// r.extent.height = 5;
+			r.extent.height = 5 * pRect->extent.height / ORIGINAL_MAP_HEIGHT;
 			DeltaTopography (50,
-					&DepthArray[(cur_y - 2) * r.extent.width],
+					&DepthArray[(cur_y - (r.extent.height >>1)) * r.extent.width],
 					&r, depth_delta);
 		}
 
@@ -1232,21 +1261,21 @@ MakeGasGiant (COUNT num_bands, SBYTE *De
 				& (((1 << RANGE_SHIFT) * NUM_BAND_COLORS) - 1);
 	}
 
-	MakeStorms (4 + (TFB_Random () & 3) + 1, DepthArray);
+	MakeStorms (4 + (TFB_Random () & 7) + 1, DepthArray, pRect->extent.width, pRect->extent.height);
 
-	DitherMap (DepthArray);
+	DitherMap (DepthArray, pRect->extent.width, pRect->extent.height);
 }
 
 static void
-ValidateMap (SBYTE *DepthArray)
+ValidateMap (SBYTE *DepthArray, COUNT width, COUNT height)
 {
 	BYTE state;
 	BYTE pixel_count[2], lb[2];
 	SBYTE last_byte;
-	COUNT i;
+	DWORD i;  // JMS_GFX: changed from COUNT to avoid overflow at higher resolutions.
 	SBYTE *lpDst;
-
-	i = MAP_WIDTH - 1;
+	
+	i = width - 1;
 	lpDst = DepthArray;
 	last_byte = *lpDst++;
 	state = pixel_count[0] = pixel_count[1] = 0;
@@ -1268,7 +1297,7 @@ ValidateMap (SBYTE *DepthArray)
 		last_byte = *lpDst++;
 	} while (--i);
 
-	i = MAP_WIDTH * MAP_HEIGHT;
+	i = width * height;
 	lpDst = DepthArray;
 	if (pixel_count[0] > pixel_count[1])
 		last_byte = lb[0];
@@ -1291,24 +1320,40 @@ ValidateMap (SBYTE *DepthArray)
 }
 
 static void
-planet_orbit_init (void)
+planet_orbit_init (COUNT width, COUNT height, BOOLEAN forOrbit)
 {
 	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
-
+	COUNT spherespanx = height;
+	COUNT shieldradius = (height >> 1) * SHIELD_RADIUS / RADIUS;
+	COUNT shielddiam = (shieldradius << 1) + 1;
+	COUNT diameter = height + 1;
+	COUNT i;
+	
 	Orbit->SphereFrame = CaptureDrawable (CreateDrawable (
-			WANT_PIXMAP | WANT_ALPHA, DIAMETER, DIAMETER, 2));
-	Orbit->TintFrame = CaptureDrawable (CreateDrawable (
-			WANT_PIXMAP, MAP_WIDTH, MAP_HEIGHT, 1));
+			WANT_PIXMAP | WANT_ALPHA, diameter, diameter, 2));
 	Orbit->ObjectFrame = 0;
 	Orbit->WorkFrame = 0;
-	Orbit->lpTopoData = HCalloc (MAP_WIDTH * MAP_HEIGHT);
-	Orbit->TopoZoomFrame = CaptureDrawable (CreateDrawable (
-			WANT_PIXMAP, MAP_WIDTH << 2, MAP_HEIGHT << 2, 1));
+	Orbit->lpTopoData = HCalloc (width * height);
 	Orbit->TopoColors = HMalloc (sizeof (Orbit->TopoColors[0])
-			* (MAP_HEIGHT * (MAP_WIDTH + SPHERE_SPAN_X)));
+			* (height * (width + spherespanx)));
 	// always allocate the scratch array to largest needed size
 	Orbit->ScratchArray = HMalloc (sizeof (Orbit->ScratchArray[0])
-			* (SHIELD_DIAM) * (SHIELD_DIAM));
+			* (shielddiam) * (shielddiam));
+	Orbit->light_diff = HMalloc (sizeof (DWORD *) * diameter);
+	Orbit->map_rotate = HMalloc (sizeof (MAP3D_POINT *) * diameter);
+	for (i=0 ; i < diameter ; i++)
+	{
+		Orbit->light_diff[i] = HMalloc (sizeof (DWORD)* diameter);
+		Orbit->map_rotate[i] = HMalloc (sizeof (MAP3D_POINT) * diameter);
+	}
+
+	if (forOrbit)
+	{
+		Orbit->TintFrame = CaptureDrawable (CreateDrawable (
+				WANT_PIXMAP, width, height, 1));
+		Orbit->TopoZoomFrame = CaptureDrawable (CreateDrawable (
+				WANT_PIXMAP, width << 2, height << 2, 1));
+	}
 }
 
 static unsigned
@@ -1542,7 +1587,7 @@ TopoScale4x (SBYTE *pDstTopo, SBYTE *pSr
 // Lots of pure Voodoo here ;)
 //  the goal is a 3D illusion, not mathematically correct lighting
 
-#define LMAP_AVG_BLOCK    ((MAP_HEIGHT + 4) / 5)
+#define LMAP_AVG_BLOCK    ((75 + 4) / 5) // BW: hacky but this shouldn't really depend on the size of the original map
 #define LMAP_MAX_DIST     ((LMAP_AVG_BLOCK + 1) >> 1)
 #define LMAP_WEIGHT_THRES (LMAP_MAX_DIST * 2 / 3)
 
@@ -1555,7 +1600,7 @@ typedef struct
 } elev_block_t;
 
 static inline void
-get_vblock_avg (elev_block_t *pblk, SBYTE *pTopo, int x, int y)
+get_vblock_avg (elev_block_t *pblk, SBYTE *pTopo, int x, int y, COUNT width, COUNT height)
 {
 	SBYTE *elev = pTopo;
 	int y0, y1, i;
@@ -1563,17 +1608,17 @@ get_vblock_avg (elev_block_t *pblk, SBYT
 	int avg = 0, total_weight = 0;
 
 	// surface wraps around along x
-	x = (x + MAP_WIDTH) % MAP_WIDTH;
+	x = (x + width) % width;
 	
 	y0 = y - LMAP_MAX_DIST;
 	y1 = y + LMAP_MAX_DIST;
 	if (y0 < 0)
 		y0 = 0;
-	if (y1 > MAP_HEIGHT)
-		y1 = MAP_HEIGHT;
+	if (y1 > height)
+		y1 = height;
 
-	elev = pTopo + y0 * MAP_HEIGHT + x;
-	for (i = y0; i < y1; ++i, elev += MAP_HEIGHT)
+	elev = pTopo + y0 * height + x;
+	for (i = y0; i < y1; ++i, elev += height)
 	{
 		int delta = abs (i - y);
 		int weight = 255; // full weight
@@ -1605,7 +1650,7 @@ GenerateLightMap (SBYTE *pTopo, int w, i
 {
 #define LMAP_BLOCKS       (2 * LMAP_MAX_DIST + 1)
 	int x, y;
-	elev_block_t vblocks[LMAP_BLOCKS];
+	elev_block_t vblocks[100];
 			// we use a running block average to reduce the amount of work
 			// where a block is a vertical line of map points
 	SBYTE *elev;
@@ -1663,7 +1708,7 @@ GenerateLightMap (SBYTE *pTopo, int w, i
 			// blocks wrap around on both sides
 			pblk = vblocks + ((i + LMAP_BLOCKS) % LMAP_BLOCKS);
 
-			get_vblock_avg (pblk, pTopo, i, y);
+			get_vblock_avg (pblk, pTopo, i, y, w, h);
 		}
 
 		for (x = 0; x < w; ++x, ++elev)
@@ -1675,7 +1720,7 @@ GenerateLightMap (SBYTE *pTopo, int w, i
 
 			// prepare next block as we move along x
 			pblk = vblocks + ((x + LMAP_MAX_DIST) % LMAP_BLOCKS);
-			get_vblock_avg (pblk, pTopo, x + LMAP_MAX_DIST, y);
+			get_vblock_avg (pblk, pTopo, x + LMAP_MAX_DIST, y, w, h);
 
 			// compute the min, max and weighted avg of blocks
 			for (i = x - LMAP_MAX_DIST; i <= x + LMAP_MAX_DIST; ++i)
@@ -1725,11 +1770,12 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 	DWORD old_seed;
 	const PlanetFrame *PlanDataPtr;
 	PLANET_INFO *PlanetInfo = &pSolarSysState->SysInfo.PlanetInfo;
-	COUNT i, y;
+	DWORD i, y;  // JMS_GFX: changed from COUNT to avoid overflow at higher resolutions.
 	POINT loc;
 	CONTEXT OldContext;
 	CONTEXT TopoContext;
 	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
+	BOOLEAN SurfDef = FALSE;
 	BOOLEAN shielded = (pPlanetDesc->data_index & PLANET_SHIELDED) != 0;
 
 	old_seed = TFB_SeedRandom (pPlanetDesc->rand_seed);
@@ -1737,7 +1783,7 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 	TopoContext = CreateContext ("Plangen.TopoContext");
 	LockMutex (GraphicsLock);
 	OldContext = SetContext (TopoContext);
-	planet_orbit_init ();
+	planet_orbit_init (MAP_WIDTH, MAP_HEIGHT, TRUE);
 
 	PlanDataPtr = &PlanData[pPlanetDesc->data_index & ~PLANET_SHIELDED];
 
@@ -1745,9 +1791,11 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 	{	// This is a defined planet; pixmap for the topography and
 		// elevation data is supplied in Surface Definition frame
 		BOOLEAN DeleteDef = FALSE;
+		BOOLEAN DeleteElev = FALSE;
 		FRAME ElevFrame;
-
+		
 		// surface pixmap
+		SurfDef = TRUE;
 		SurfDefFrame = SetAbsFrameIndex (SurfDefFrame, 0);
 		if (GetFrameWidth (SurfDefFrame) != MAP_WIDTH
 				|| GetFrameHeight (SurfDefFrame) != MAP_HEIGHT)
@@ -1771,6 +1819,7 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 			{
 				ElevFrame = CaptureDrawable (RescaleFrame (ElevFrame,
 						MAP_WIDTH, MAP_HEIGHT));
+				DeleteElev = TRUE;
 			}
 
 			// grab the elevation data in 1 byte per pixel format
@@ -1789,8 +1838,31 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 			memset (Orbit->lpTopoData, 0, MAP_WIDTH * MAP_HEIGHT);
 		}
 
+		pSolarSysState->OrbitalCMap = CaptureColorMap (
+				LoadColorMap (PlanDataPtr->CMapInstance));
+		pSolarSysState->XlatRef = CaptureStringTable (
+				LoadStringTable (PlanDataPtr->XlatTabInstance));
+
+		if (PlanetInfo->SurfaceTemperature > HOT_THRESHOLD)
+		{
+			pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
+					pSolarSysState->OrbitalCMap, 2);
+			pSolarSysState->XlatRef = SetAbsStringTableIndex (
+					pSolarSysState->XlatRef, 2);
+		}
+		else if (PlanetInfo->SurfaceTemperature > COLD_THRESHOLD)
+		{
+			pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
+					pSolarSysState->OrbitalCMap, 1);
+			pSolarSysState->XlatRef = SetAbsStringTableIndex (
+					pSolarSysState->XlatRef, 1);
+		}
+		pSolarSysState->XlatPtr = GetStringAddress (pSolarSysState->XlatRef);
+
 		if (DeleteDef)
 			DestroyDrawable (ReleaseDrawable (SurfDefFrame));
+		if (DeleteElev)
+			DestroyDrawable (ReleaseDrawable (ElevFrame));
 	}
 	else
 	{	// Generate planet surface elevation data and look
@@ -1816,46 +1888,56 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 					for (i = 0; i < PlanDataPtr->num_blemishes; ++i)
 					{
 						RECT crater_r;
+						DWORD random_value; // JMS_GFX
 						UWORD loword;
 				
-						loword = LOWORD (TFB_Random ());
+						random_value = TFB_Random(); // JMS_GFX
+						loword = LOWORD (random_value); // JMS_GFX: Was loword = LOWORD (TFB_Random ());
 						switch (HIBYTE (loword) & 31)
 						{
 							case 0:
 								crater_r.extent.width =
-										(LOBYTE (loword) % (MAP_HEIGHT >> 2))
-										+ (MAP_HEIGHT >> 2);
+										(LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT >> 2))
+										+ (ORIGINAL_MAP_HEIGHT >> 2);
 								break;
 							case 1:
 							case 2:
 							case 3:
 							case 4:
 								crater_r.extent.width =
-										(LOBYTE (loword) % (MAP_HEIGHT >> 3))
-										+ (MAP_HEIGHT >> 3);
+										(LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT >> 3))
+										+ (ORIGINAL_MAP_HEIGHT >> 3);
 								break;
 							default:
 								crater_r.extent.width =
-										(LOBYTE (loword) % (MAP_HEIGHT >> 4))
+										(LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT >> 4))
 										+ 4;
 								break;
 						}
 					
-						loword = LOWORD (TFB_Random ());
+						random_value = TFB_Random(); // JMS_GFX
+						loword = LOWORD (random_value); // JMS_GFX: Was loword = LOWORD (TFB_Random ());
+						
+						crater_r.extent.height = crater_r.extent.width;	
+						crater_r.corner.x = HIBYTE (loword) % (ORIGINAL_MAP_WIDTH - crater_r.extent.width);
+						// crater_r.corner.x = loword % (MAP_WIDTH - crater_r.extent.width); // JMS_GFX: changed the previous line to this. BYTE was too small for 4x resolution
+						crater_r.corner.y = LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT - crater_r.extent.height);
+						// crater_r.corner.y = hiword % (MAP_HEIGHT - crater_r.extent.height); // JMS_GFX: The same
+						// BW: ... then scale them up
+						crater_r.extent.width = crater_r.extent.width * MAP_WIDTH / ORIGINAL_MAP_WIDTH;
 						crater_r.extent.height = crater_r.extent.width;
-						crater_r.corner.x = HIBYTE (loword)
-								% (MAP_WIDTH - crater_r.extent.width);
-						crater_r.corner.y = LOBYTE (loword)
-								% (MAP_HEIGHT - crater_r.extent.height);
+						crater_r.corner.x = crater_r.corner.x * MAP_WIDTH / ORIGINAL_MAP_WIDTH;
+						crater_r.corner.y = crater_r.corner.y * MAP_HEIGHT / ORIGINAL_MAP_HEIGHT;
+						
 						MakeCrater (&crater_r, Orbit->lpTopoData,
 								PlanDataPtr->fault_depth << 2,
 								-(PlanDataPtr->fault_depth << 2),
-								FALSE);
+								FALSE, MAP_WIDTH);
 					}
 
 					if (PLANALGO (PlanDataPtr->Type) == CRATERED_ALGO)
-						DitherMap (Orbit->lpTopoData);
-					ValidateMap (Orbit->lpTopoData);
+						DitherMap (Orbit->lpTopoData, MAP_WIDTH, MAP_HEIGHT);
+					ValidateMap (Orbit->lpTopoData, MAP_WIDTH, MAP_HEIGHT);
 					break;
 			}
 		}
@@ -1883,11 +1965,13 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 		}
 		pSolarSysState->XlatPtr = GetStringAddress (pSolarSysState->XlatRef);
 		RenderTopography (pSolarSysState->TopoFrame,
-				Orbit->lpTopoData, MAP_WIDTH, MAP_HEIGHT);
+				  Orbit->lpTopoData, MAP_WIDTH, MAP_HEIGHT, FALSE);
 
 	}
 
-	if (!shielded && PlanetInfo->AtmoDensity != GAS_GIANT_ATMOSPHERE)
+	// JMS Don't create 4x image for restricted planets since they cannot be landed on anyway.
+	if (!shielded && !(pPlanetDesc->flags & PLANET_RESTRICTED)
+			&& PlanetInfo->AtmoDensity != GAS_GIANT_ATMOSPHERE)
 	{	// produce 4x scaled topo image for Planetside
 		// for the planets that we can land on
 		SBYTE *pScaledTopo = HMalloc (MAP_WIDTH * 4 * MAP_HEIGHT * 4);
@@ -1897,12 +1981,11 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 					PlanDataPtr->num_faults, PlanDataPtr->fault_depth
 					* (PLANALGO (PlanDataPtr->Type) == CRATERED_ALGO ? 2 : 1  ));
 			RenderTopography (Orbit->TopoZoomFrame, pScaledTopo,
-					MAP_WIDTH * 4, MAP_HEIGHT * 4);
-
+					  MAP_WIDTH * 4, MAP_HEIGHT * 4, SurfDef);
+			
 			HFree (pScaledTopo);
 		}
 	}
-
 	// Generate a pixel array from the Topography map.
 	// We use this instead of lpTopoData because it needs to be
 	// WAP_WIDTH+SPHERE_SPAN_X wide and we need this method for Earth anyway.
@@ -1910,12 +1993,14 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 	// FRAMPTR though.
 	ReadFramePixelColors (pSolarSysState->TopoFrame, Orbit->TopoColors,
 			MAP_WIDTH + SPHERE_SPAN_X, MAP_HEIGHT);
+	
 	// Extend the width from MAP_WIDTH to MAP_WIDTH+SPHERE_SPAN_X
 	for (y = 0; y < MAP_HEIGHT * (MAP_WIDTH + SPHERE_SPAN_X);
 			y += MAP_WIDTH + SPHERE_SPAN_X)
+	{
 		memcpy (Orbit->TopoColors + y + MAP_WIDTH, Orbit->TopoColors + y,
 				SPHERE_SPAN_X * sizeof (Orbit->TopoColors[0]));
-
+	}
 	if (PLANALGO (PlanDataPtr->Type) != GAS_GIANT_ALGO)
 	{	// convert topo data to a light map, based on relative
 		// map point elevations
@@ -1925,7 +2010,6 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 	{	// gas giants are pretty much flat
 		memset (Orbit->lpTopoData, 0, MAP_WIDTH * MAP_HEIGHT);
 	}
-			
 	if (pSolarSysState->pOrbitalDesc->pPrevDesc ==
 			&pSolarSysState->SunDesc[0])
 	{	// this is a planet -- get its location
@@ -1935,18 +2019,17 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 	{	// this is a moon -- get its planet's location
 		loc = pSolarSysState->pOrbitalDesc->pPrevDesc->location;
 	}
-	
 	// Rotating planet sphere initialization
-	GenerateSphereMask (loc);
-	CreateSphereTiltMap (PlanetInfo->AxialTilt);
+	GenerateSphereMask (loc, RADIUS);
+	CreateSphereTiltMap (PlanetInfo->AxialTilt, MAP_HEIGHT, RADIUS);
 	if (shielded)
-		Orbit->ObjectFrame = CreateShieldMask ();
-	InitSphereRotation (1 - 2 * (PlanetInfo->AxialTilt & 1), shielded);
+		Orbit->ObjectFrame = CreateShieldMask (RADIUS, pPlanetDesc->flags);
+	InitSphereRotation (1 - 2 * (PlanetInfo->AxialTilt & 1), shielded, MAP_WIDTH, MAP_HEIGHT);
 
 	if (shielded)
 	{	// This overwrites pSolarSysState->TopoFrame, so everything that
 		// needs it has to come before
-		ApplyShieldTint ();
+		ApplyShieldTint (pPlanetDesc->flags);
 	}
 
 	SetContext (OldContext);
@@ -1956,3 +2039,278 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 	TFB_SeedRandom (old_seed);
 }
 
+
+
+void
+GeneratePlanetSurfaceForIP (PLANET_DESC *pPlanetDesc, FRAME SurfDefFrame, COUNT width, COUNT height)
+{
+	RECT r;
+	DWORD old_seed;
+	const PlanetFrame *PlanDataPtr;
+	PLANET_INFO *PlanetInfo = &pSolarSysState->SysInfo.PlanetInfo;
+	DWORD i, y;  // JMS_GFX: changed from COUNT to avoid overflow at higher resolutions.
+	POINT loc;
+	CONTEXT OldContext;
+	CONTEXT TopoContext;
+	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
+	BOOLEAN SurfDef = FALSE;
+	BOOLEAN shielded = (pPlanetDesc->data_index & PLANET_SHIELDED) != 0;
+	COUNT spherespanx = height;
+	COUNT radius = (height >> 1) - RESOLUTION_FACTOR;
+	
+	old_seed = TFB_SeedRandom (pPlanetDesc->rand_seed);
+
+	TopoContext = CreateContext ("Plangen.TopoContext");
+	LockMutex (GraphicsLock);
+	OldContext = SetContext (TopoContext);
+	planet_orbit_init (width, height, FALSE);
+
+	PlanDataPtr = &PlanData[pPlanetDesc->data_index & ~PLANET_SHIELDED];
+
+	if (SurfDefFrame)
+	{	// This is a defined planet; pixmap for the topography and
+		// elevation data is supplied in Surface Definition frame
+		BOOLEAN DeleteDef = FALSE;
+		BOOLEAN DeleteElev = FALSE;
+		FRAME ElevFrame;
+
+		// surface pixmap
+		SurfDef = TRUE;
+		SurfDefFrame = SetAbsFrameIndex (SurfDefFrame, 0);
+		if (GetFrameWidth (SurfDefFrame) != width
+				|| GetFrameHeight (SurfDefFrame) != height)
+		{
+			pSolarSysState->TopoFrame = CaptureDrawable (RescaleFrame (
+					SurfDefFrame, width, height));
+			// will not need the passed FRAME anymore
+			DeleteDef = TRUE;
+		}
+		else
+			pSolarSysState->TopoFrame = SurfDefFrame;
+
+		if (GetFrameCount (SurfDefFrame) > 1)
+		{	// 2nd frame is elevation data 
+			int i;
+			SBYTE* elev;
+
+			ElevFrame = SetAbsFrameIndex (SurfDefFrame, 1);
+			if (GetFrameWidth (ElevFrame) != width
+					|| GetFrameHeight (ElevFrame) != height)
+			{
+				ElevFrame = CaptureDrawable (RescaleFrame (ElevFrame,
+						width, height));
+				DeleteElev = TRUE;
+			}
+
+			// grab the elevation data in 1 byte per pixel format
+			ReadFramePixelIndexes (ElevFrame, (BYTE *)Orbit->lpTopoData,
+					width, height);
+			// the supplied data is in unsigned format, must convert
+			for (i = 0, elev = Orbit->lpTopoData;
+					i < width * height;
+					++i, ++elev)
+			{
+				*elev = *(BYTE *)elev - 128;
+			}
+		}
+		else
+		{	// no elevation data -- planet flat as a pancake
+			memset (Orbit->lpTopoData, 0, width * height);
+		}
+
+		pSolarSysState->OrbitalCMap = CaptureColorMap (
+				LoadColorMap (PlanDataPtr->CMapInstance));
+		pSolarSysState->XlatRef = CaptureStringTable (
+				LoadStringTable (PlanDataPtr->XlatTabInstance));
+
+		if (PlanetInfo->SurfaceTemperature > HOT_THRESHOLD)
+		{
+			pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
+					pSolarSysState->OrbitalCMap, 2);
+			pSolarSysState->XlatRef = SetAbsStringTableIndex (
+					pSolarSysState->XlatRef, 2);
+		}
+		else if (PlanetInfo->SurfaceTemperature > COLD_THRESHOLD)
+		{
+			pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
+					pSolarSysState->OrbitalCMap, 1);
+			pSolarSysState->XlatRef = SetAbsStringTableIndex (
+					pSolarSysState->XlatRef, 1);
+		}
+		pSolarSysState->XlatPtr = GetStringAddress (pSolarSysState->XlatRef);
+
+		if (DeleteDef)
+			DestroyDrawable (ReleaseDrawable (SurfDefFrame));
+		if (DeleteElev)
+			DestroyDrawable (ReleaseDrawable (ElevFrame));
+	}
+	else
+	{	// Generate planet surface elevation data and look
+
+		r.corner.x = r.corner.y = 0;
+		r.extent.width = width;
+		r.extent.height = height;
+		{
+			memset (Orbit->lpTopoData, 0, width * height);
+			switch (PLANALGO (PlanDataPtr->Type))
+			{
+				case GAS_GIANT_ALGO:
+					MakeGasGiant (PlanDataPtr->num_faults,
+							Orbit->lpTopoData, &r, PlanDataPtr->fault_depth);
+					break;
+				case TOPO_ALGO:
+				case CRATERED_ALGO:
+					if (PlanDataPtr->num_faults)
+						DeltaTopography (PlanDataPtr->num_faults,
+								Orbit->lpTopoData, &r,
+								PlanDataPtr->fault_depth);
+
+					for (i = 0; i < PlanDataPtr->num_blemishes; ++i)
+					{
+						RECT crater_r;
+						DWORD random_value; // JMS_GFX
+						UWORD loword;
+						// UWORD hiword; // JMS_GFX
+						// BW: reinstate original values...
+						
+						random_value = TFB_Random(); // JMS_GFX
+						loword = LOWORD (random_value); // JMS_GFX: Was loword = LOWORD (TFB_Random ());
+						switch (HIBYTE (loword) & 31)
+						{
+							case 0:
+								// if (RESOLUTION_FACTOR == 0)
+								crater_r.extent.width = (LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT >> 2)) + (ORIGINAL_MAP_HEIGHT >> 2);
+								// else
+								// 	crater_r.extent.width = (loword % (MAP_HEIGHT >> 2)) + (MAP_HEIGHT >> 2);
+								
+								break;
+							case 1:
+							case 2:
+							case 3:
+							case 4:
+								// if (RESOLUTION_FACTOR == 0)
+								crater_r.extent.width = (LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT >> 3)) + (ORIGINAL_MAP_HEIGHT >> 3);
+								// else
+								// 	crater_r.extent.width = (loword % (MAP_HEIGHT >> 3)) + (MAP_HEIGHT >> 3);
+								break;
+							default:
+								// if (RESOLUTION_FACTOR == 0)
+								crater_r.extent.width = (LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT >> 4)) + 4;
+								// else
+								// 	crater_r.extent.width = (loword % (MAP_HEIGHT >> 4)) + 4;
+								break;
+						}
+
+						random_value = TFB_Random(); // JMS_GFX
+						loword = LOWORD (random_value); // JMS_GFX: Was loword = LOWORD (TFB_Random ());
+						// hiword = HIWORD (random_value); 
+						// JMS_GFX
+	
+						crater_r.extent.height = crater_r.extent.width;
+						crater_r.corner.x = HIBYTE (loword) % (ORIGINAL_MAP_WIDTH - crater_r.extent.width);
+						// crater_r.corner.x = loword % (MAP_WIDTH - crater_r.extent.width); // JMS_GFX: changed the previous line to this. BYTE was too small for 4x resolution
+						crater_r.corner.y = LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT - crater_r.extent.height);
+						// crater_r.corner.y = hiword % (MAP_HEIGHT - crater_r.extent.height); // JMS_GFX: The same
+
+						// BW: ... then scale them up
+						crater_r.extent.width = crater_r.extent.width * height / ORIGINAL_MAP_HEIGHT;
+						crater_r.extent.height = crater_r.extent.width;
+						crater_r.corner.x = crater_r.corner.x * width / ORIGINAL_MAP_WIDTH;					
+						crater_r.corner.y = crater_r.corner.y * height / ORIGINAL_MAP_HEIGHT;
+						
+						MakeCrater (&crater_r, Orbit->lpTopoData,
+								PlanDataPtr->fault_depth << 2,
+								-(PlanDataPtr->fault_depth << 2),
+							    FALSE, width);
+					}
+					if (PLANALGO (PlanDataPtr->Type) == CRATERED_ALGO)
+						DitherMap (Orbit->lpTopoData, width, height);
+					ValidateMap (Orbit->lpTopoData, width, height);
+					break;
+			}
+		}
+		pSolarSysState->TopoFrame = CaptureDrawable (
+				CreateDrawable (WANT_PIXMAP, (SIZE)width,
+				(SIZE)height, 1));
+		pSolarSysState->OrbitalCMap = CaptureColorMap (
+				LoadColorMap (PlanDataPtr->CMapInstance));
+		pSolarSysState->XlatRef = CaptureStringTable (
+				LoadStringTable (PlanDataPtr->XlatTabInstance));
+
+		if (PlanetInfo->SurfaceTemperature > HOT_THRESHOLD)
+		{
+			pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
+					pSolarSysState->OrbitalCMap, 2);
+			pSolarSysState->XlatRef = SetAbsStringTableIndex (
+					pSolarSysState->XlatRef, 2);
+		}
+		else if (PlanetInfo->SurfaceTemperature > COLD_THRESHOLD)
+		{
+			pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
+					pSolarSysState->OrbitalCMap, 1);
+			pSolarSysState->XlatRef = SetAbsStringTableIndex (
+					pSolarSysState->XlatRef, 1);
+		}
+		pSolarSysState->XlatPtr = GetStringAddress (pSolarSysState->XlatRef);
+		RenderTopography (pSolarSysState->TopoFrame, Orbit->lpTopoData, width, height, FALSE);
+
+	}
+
+	// Generate a pixel array from the Topography map.
+	// We use this instead of lpTopoData because it needs to be
+	// WAP_WIDTH+SPHERE_SPAN_X wide and we need this method for Earth anyway.
+	// It may be more efficient to build it from lpTopoData instead of the
+	// FRAMPTR though.
+	ReadFramePixelColors (pSolarSysState->TopoFrame, Orbit->TopoColors,
+			width + spherespanx, height);
+	// Extend the width from MAP_WIDTH to MAP_WIDTH+SPHERE_SPAN_X
+	for (y = 0; y < height * (width + spherespanx);
+			y += width + spherespanx)
+		memcpy (Orbit->TopoColors + y + width, Orbit->TopoColors + y,
+				spherespanx * sizeof (Orbit->TopoColors[0]));
+
+	if (PLANALGO (PlanDataPtr->Type) != GAS_GIANT_ALGO)
+	{	// convert topo data to a light map, based on relative
+		// map point elevations
+		GenerateLightMap (Orbit->lpTopoData, width, height);
+	}
+	else
+	{	// gas giants are pretty much flat
+		memset (Orbit->lpTopoData, 0, width * height);
+	}
+
+	if (pSolarSysState->pOrbitalDesc->pPrevDesc ==
+			&pSolarSysState->SunDesc[0])
+	{	// this is a planet -- get its location
+		loc = pSolarSysState->pOrbitalDesc->location;
+	}
+	else
+	{	// this is a moon -- get its planet's location
+		loc = pSolarSysState->pOrbitalDesc->pPrevDesc->location;
+	}
+	
+	// Rotating planet sphere initialization
+	GenerateSphereMask (loc, radius);
+	CreateSphereTiltMap (PlanetInfo->AxialTilt, height, radius);
+	if (shielded)
+		Orbit->ObjectFrame = CreateShieldMask (radius, pPlanetDesc->flags);
+	InitSphereRotation (1 - 2 * (PlanetInfo->AxialTilt & 1), shielded, width, height);
+	pPlanetDesc->rotDirection = 1 - 2 * (PlanetInfo->AxialTilt & 1);
+	pPlanetDesc->rotwidth = width;
+	pPlanetDesc->rotheight = height;
+	pPlanetDesc->rotFrameIndex = 0;
+	pPlanetDesc->rotPointIndex = 0;
+	pPlanetDesc->rot_speed = ((double)(pPlanetDesc->rotwidth * pPlanetDesc->rotDirection * 240)) / PlanetInfo->RotationPeriod;
+	
+	if (shielded)
+	{	// This overwrites pSolarSysState->TopoFrame, so everything that
+		// needs it has to come before
+		ApplyShieldTint (pPlanetDesc->flags);
+	}
+
+	SetContext (OldContext);
+	UnlockMutex (GraphicsLock);
+	DestroyContext (TopoContext);
+
+	TFB_SeedRandom (old_seed);
+}
diff -ruNp src.orig/uqm/planets/pstarmap.c src/uqm/planets/pstarmap.c
--- src.orig/uqm/planets/pstarmap.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/pstarmap.c	2017-11-01 15:31:03 -0700
@@ -16,7 +16,17 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2009: -Orz space starmap colors and star locations
+// JMS 2010: -Do not draw Sphere of Influence for Slylandros riding Kohr-Ah ships
+//			 -Do not draw Sphere of Influence for Kohr-Ahs.
+//			 -Display hint for the player to use the star search facility in the starmap
+// JMS 2011: -In the beginning of game, known races' home planets are marked on the map as small SoIs.
+//			 -The hi-res modes now have a more user-friendly starmap cursor.
+
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
 #include "scan.h"
+#include "triangul.h"
 #include "../colors.h"
 #include "../controls.h"
 #include "../menustat.h"
@@ -28,7 +38,7 @@
 #include "../globdata.h"
 #include "../shipcont.h"
 #include "../units.h"
-#include "../hyper.h"
+#include "../hyper.h" // for SOL_X/SOL_Y
 #include "../sis.h"
 		// for DrawHyperCoords(), DrawStatusMessage()
 #include "../settings.h"
@@ -43,7 +53,11 @@
 #include "libs/mathlib.h"
 #include "libs/memlib.h"
 
+#include "libs/log.h"
+#include "../nameref.h"
+
 #include <stdlib.h>
+#include <math.h>
 
 
 static POINT cursorLoc;
@@ -155,26 +169,14 @@ DrawCursor (COORD curs_x, COORD curs_y)
 	DrawStamp (&s);
 }
 
-static void
-DrawAutoPilot (POINT *pDstPt)
+static void DrawAutoPilotSegment(POINT *pt, POINT *destPt)
 {
 	SIZE dx, dy,
 				xincr, yincr,
 				xerror, yerror,
 				cycle, delta;
-	POINT pt;
-
-	if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
-		pt = CurStarDescPtr->star_pt;
-	else
-	{
-		pt.x = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x));
-		pt.y = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
-	}
-	pt.x = UNIVERSE_TO_DISPX (pt.x);
-	pt.y = UNIVERSE_TO_DISPY (pt.y);
 
-	dx = UNIVERSE_TO_DISPX (pDstPt->x) - pt.x;
+	dx = destPt->x - pt->x;
 	if (dx >= 0)
 		xincr = 1;
 	else
@@ -184,7 +186,7 @@ DrawAutoPilot (POINT *pDstPt)
 	}
 	dx <<= 1;
 
-	dy = UNIVERSE_TO_DISPY (pDstPt->y) - pt.y;
+	dy = destPt->y - pt->y;
 	if (dy >= 0)
 		yincr = 1;
 	else
@@ -200,42 +202,144 @@ DrawAutoPilot (POINT *pDstPt)
 		cycle = dy;
 	delta = xerror = yerror = cycle >> 1;
 
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x04, 0x04, 0x1F), 0x01));
-
 	delta &= ~1;
 	while (delta--)
 	{
 		if (!(delta & 1))
-			DrawPoint (&pt);
+			DrawPoint (pt);
 
 		if ((xerror -= dx) <= 0)
 		{
-			pt.x += xincr;
+			pt->x += xincr;
 			xerror += cycle;
 		}
 		if ((yerror -= dy) <= 0)
 		{
-			pt.y += yincr;
+			pt->y += yincr;
 			yerror += cycle;
 		}
 	}
 }
 
 static void
+DrawAutoPilot (POINT *pDstPt)
+{
+	SIZE dx, dy,
+				xincr, yincr,
+				xerror, yerror,
+				cycle, delta;
+	POINT pt;
+    POINT destPt;
+
+	if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
+		pt = CurStarDescPtr->star_pt;
+	else
+	{
+		pt.x = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x));
+		pt.y = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
+	}
+	pt.x = UNIVERSE_TO_DISPX (pt.x);
+	pt.y = UNIVERSE_TO_DISPY (pt.y);
+
+    destPt.x = UNIVERSE_TO_DISPX (pDstPt->x);
+    destPt.y = UNIVERSE_TO_DISPY (pDstPt->y);
+
+	SetContextForeGroundColor (
+			BUILD_COLOR (MAKE_RGB15 (0x04, 0x04, 0x1F), 0x01));
+
+    DrawAutoPilotSegment(&pt, &destPt);
+}
+
+void SetOrzSpaceAutoPilot(void)
+{
+    float px = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x));
+    float py = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
+    float qx = GLOBAL (autopilot).x;
+    float qy = GLOBAL (autopilot).y;
+
+    float dx = qx - px;
+    float dy = qy - py;
+
+    float tx = (px + qx)/2.0;
+    float ty = (py + qy)/2.0;
+
+    float k = ty/dx;
+    float cx = tx + k*dy;
+
+    float r2 = qy*qy + (qx-cx)*(qx-cx);
+    float rad = sqrt(r2);
+
+    GLOBAL (autopilotOrzSpaceCenter).x = cx;
+    GLOBAL (autopilotOrzSpaceCenter).y = 0;
+
+    GLOBAL (autopilotOrzSpaceRadius) = rad;
+}
+
+static void
+DrawOrzSpaceAutoPilot (POINT *pDstPt)
+{
+    SDWORD cx = GLOBAL (autopilotOrzSpaceCenter).x;
+    SDWORD cy = GLOBAL (autopilotOrzSpaceCenter).y;
+    SDWORD rad = GLOBAL (autopilotOrzSpaceRadius);
+
+    SDWORD x1 = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x));
+    SDWORD y1 = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
+    SDWORD x2 = GLOBAL (autopilot).x;
+    SDWORD y2 = GLOBAL (autopilot).y;
+
+    float a1, a2;
+    float deltaA;
+    int numSegs;
+    int i;
+
+    POINT pt, destPt;
+
+    a1 = atan2(y1 - cy, x1 - cx);
+    a2 = atan2(y2 - cy, x2 - cx);
+
+    numSegs = abs(32.0*(a2 - a1)/M_PI);
+    if (numSegs < 1)
+        numSegs = 1;
+
+    deltaA = (a2 - a1)/numSegs;
+
+	SetContextForeGroundColor (
+			BUILD_COLOR (MAKE_RGB15 (0x04, 0x04, 0x1F), 0x01));
+
+    pt.x = UNIVERSE_TO_DISPX (x1);
+    pt.y = UNIVERSE_TO_DISPY (y1);
+
+    for (i = 0; i < numSegs; i++)
+    {
+        a1 += deltaA;
+        destPt.x = UNIVERSE_TO_DISPX (cx + rad * cos(a1));
+        destPt.y = UNIVERSE_TO_DISPY (cy + rad * sin(a1));
+
+        DrawAutoPilotSegment(&pt, &destPt);
+    }
+}
+
+static void
 GetSphereRect (FLEET_INFO *FleetPtr, RECT *pRect, RECT *pRepairRect)
 {
 	long diameter;
-
-	diameter = (long)(FleetPtr->known_strength * SPHERE_RADIUS_INCREMENT);
-	pRect->extent.width = UNIVERSE_TO_DISPX (diameter)
-			- UNIVERSE_TO_DISPX (0);
+	
+	// JMS: Negative known strength marks initial state of the SoI's: 
+	// Only the home planet of certain races is known -> show small sphere.
+	if (FleetPtr->known_strength >= 0)
+		diameter = (long)(FleetPtr->known_strength * SPHERE_RADIUS_INCREMENT);
+	else
+		diameter = (long)(-(FleetPtr->known_strength) * SPHERE_RADIUS_INCREMENT);
+		
+	pRect->extent.width = UNIVERSE_TO_DISPX (diameter) - UNIVERSE_TO_DISPX (0);
+	
 	if (pRect->extent.width < 0)
 		pRect->extent.width = -pRect->extent.width;
 	else if (pRect->extent.width == 0)
 		pRect->extent.width = 1;
-	pRect->extent.height = UNIVERSE_TO_DISPY (diameter)
-			- UNIVERSE_TO_DISPY (0);
+	
+	pRect->extent.height = UNIVERSE_TO_DISPY (diameter)- UNIVERSE_TO_DISPY (0);
+	
 	if (pRect->extent.height < 0)
 		pRect->extent.height = -pRect->extent.height;
 	else if (pRect->extent.height == 0)
@@ -283,15 +387,17 @@ static void
 DrawStarMap (COUNT race_update, RECT *pClipRect)
 {
 #define GRID_DELTA 500
-	SIZE i;
+	SIZE i, j;
 	COUNT which_space;
+	COUNT orz_space;	// JMS
 	long diameter;
 	RECT r, old_r;
 	POINT oldOrigin = {0, 0};
-	STAMP s;
+	STAMP s, nebula;
 	FRAME star_frame;
 	STAR_DESC *SDPtr;
 	BOOLEAN draw_cursor;
+	Color OldColor; // JMS: Relocated here from the fuel range drawing loop, needed for transparent grid.
 
 	if (pClipRect == (RECT*)-1)
 	{
@@ -325,6 +431,7 @@ DrawStarMap (COUNT race_update, RECT *pC
 	BatchGraphics ();
 	
 	which_space = GET_GAME_STATE (ARILOU_SPACE_SIDE);
+	orz_space= GET_GAME_STATE (ORZ_SPACE_SIDE);	// JMS
 
 	if (which_space <= 1)
 	{
@@ -332,6 +439,7 @@ DrawStarMap (COUNT race_update, RECT *pC
 		SetContextForeGroundColor (
 				BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x07), 0x57));
 		SetContextBackGroundColor (BLACK_COLOR);
+		
 	}
 	else
 	{
@@ -341,14 +449,29 @@ DrawStarMap (COUNT race_update, RECT *pC
 		SetContextBackGroundColor (
 				BUILD_COLOR (MAKE_RGB15 (0x00, 0x08, 0x00), 0x6E));
 	}
+	if(orz_space > 1)// JMS: ORZ space starmap BG color
+	{
+		SDPtr = &star_array[NUM_SOLAR_SYSTEMS + 15 + 2 + 1]; // JMS: ORZ space starsystems, 15 = number of 
+		SetContextForeGroundColor (						     // quasispace vortices, 2 = Two space size definitions, 1 = arilou world  
+								   BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x0B), 0x6D));
+		SetContextBackGroundColor (
+								   BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x08), 0x6E));
+	}
 	ClearDrawable ();
-
+	
+	// JMS: Draw a sexy nebula on the map's background (Only in Hyperspace, not in QS/Orzspace!).
+	if (which_space <= 1)
+	{
+		nebula.origin.x = nebula.origin.y = 0;
+		nebula.frame = SetAbsFrameIndex (nebulaeFrame, 16);
+		DrawStamp(&nebula);
+	}
+	
 	if (race_update == 0
 			&& which_space < 2
+			&& orz_space < 2 // JMS: Orz space check
 			&& (diameter = (long)GLOBAL_SIS (FuelOnBoard) << 1))
 	{
-		Color OldColor;
-
 		if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
 			r.corner = CurStarDescPtr->star_pt;
 		else
@@ -371,34 +494,50 @@ DrawStarMap (COUNT race_update, RECT *pC
 		r.corner.y = UNIVERSE_TO_DISPY (r.corner.y)
 				- (r.extent.height >> 1);
 
-		OldColor = SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x03, 0x03, 0x03), 0x22));
+		// JMS: This was the original fuel range circle color.
+		//OldColor = SetContextForeGroundColor (
+		//		BUILD_COLOR (MAKE_RGB15 (0x03, 0x03, 0x03), 0x22));
+		
+		// JMS: The fuel range circle is now partially Transparent
+		OldColor = SetContextForeGroundColor (BUILD_COLOR_RGBA(0x66,0x66,0x66,0x22));
+		
 		DrawFilledOval (&r);
+		
 		SetContextForeGroundColor (OldColor);
 	}
-
-	for (i = MAX_Y_UNIVERSE + 1; i >= 0; i -= GRID_DELTA)
+	
+	// JMS: The grid is now partially transparent for HS map.
+	// Hi-res modes have less transparency since thin lines are harder to see.
+	// JvdD: The grid is now bright red, to account for the background 
+	if (which_space <= 1)
+		OldColor = SetContextForeGroundColor (BUILD_COLOR_RGBA(0xAE,0x30,0x30,RES_CASE(0x55,0x80,0xCC)));
+	
+	// The Grid. (For more information, see TRON)
+	for (i = MAX_Y_UNIVERSE + 1, j = MAX_X_UNIVERSE + 1; i >= 0; i -= GRID_DELTA, j -= GRID_DELTA)
 	{
-		SIZE j;
-
+		// Horizontal lines.
 		r.corner.x = UNIVERSE_TO_DISPX (0);
 		r.corner.y = UNIVERSE_TO_DISPY (i);
 		r.extent.width = SIS_SCREEN_WIDTH << zoomLevel;
 		r.extent.height = 1;
 		DrawFilledRectangle (&r);
 
+		// Vertical lines
 		r.corner.y = UNIVERSE_TO_DISPY (MAX_Y_UNIVERSE + 1);
 		r.extent.width = 1;
 		r.extent.height = SIS_SCREEN_HEIGHT << zoomLevel;
-		for (j = MAX_X_UNIVERSE + 1; j >= 0; j -= GRID_DELTA)
-		{
-			r.corner.x = UNIVERSE_TO_DISPX (j);
-			DrawFilledRectangle (&r);
-		}
+		r.corner.x = UNIVERSE_TO_DISPX (j);
+		DrawFilledRectangle (&r);
 	}
+	
+	// JMS: Return original nontransparent grid color, just in case.
+	if (which_space <= 1)
+		SetContextForeGroundColor (OldColor);
 
 	star_frame = SetRelFrameIndex (StarMapFrame, 2);
-	if (which_space <= 1)
+	
+	// Draw Spheres of Influence
+	if (which_space <= 1 && orz_space <= 1) // JMS: Orz space check
 	{
 		COUNT index;
 		HFLEETINFO hStarShip, hNextShip;
@@ -416,7 +555,9 @@ DrawStarMap (COUNT race_update, RECT *pC
 			FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
 			hNextShip = _GetSuccLink (FleetPtr);
 
-			if (FleetPtr->known_strength)
+			if (FleetPtr->known_strength 
+				&& FleetPtr->SpeciesID!=SLYLANDRO_KOHRAH_ID // JMS: Don't draw circle for Slylandro-Kohrahs
+				&& FleetPtr->SpeciesID!=KOHR_AH_ID)			// JMS: Don't draw circle for Kohr-Ahs
 			{
 				RECT repair_r;
 
@@ -440,7 +581,7 @@ DrawStarMap (COUNT race_update, RECT *pC
 						SetContextForeGroundColor (WHITE_COLOR);
 					else
 						SetContextForeGroundColor (c);
-					DrawOval (&r, 0);
+					DrawOval (&r, 0, 0);
 
 					SetContextFont (TinyFont);
 
@@ -482,31 +623,38 @@ DrawStarMap (COUNT race_update, RECT *pC
 		}
 	}
 
+	// JMS: Shofixti crash site triangulation sphere drawing, defined in planets/triangul.c
+	//if(!(GET_GAME_STATE(HIDE_TRIANGULATION_SPHERES)))
+	if(1)
+		drawTriangulationSpheres(which_space, orz_space, pClipRect, mapOrigin, zoomLevel);
+
 	do
 	{
 		BYTE star_type;
-
 		star_type = SDPtr->Type;
 
-		s.origin.x = UNIVERSE_TO_DISPX (SDPtr->star_pt.x);
-		s.origin.y = UNIVERSE_TO_DISPY (SDPtr->star_pt.y);
-		if (which_space <= 1)
-			s.frame = SetRelFrameIndex (star_frame,
-					STAR_TYPE (star_type)
-					* NUM_STAR_COLORS
-					+ STAR_COLOR (star_type));
-		else if (SDPtr->star_pt.x == ARILOU_HOME_X
-				&& SDPtr->star_pt.y == ARILOU_HOME_Y)
-			s.frame = SetRelFrameIndex (star_frame,
-					SUPER_GIANT_STAR * NUM_STAR_COLORS + GREEN_BODY);
-		else
-			s.frame = SetRelFrameIndex (star_frame,
-					GIANT_STAR * NUM_STAR_COLORS + GREEN_BODY);
-		DrawStamp (&s);
+		if (SDPtr->Index != MELNORME_HOME_DEFINED)
+		{
+
+			s.origin.x = UNIVERSE_TO_DISPX (SDPtr->star_pt.x);
+			s.origin.y = UNIVERSE_TO_DISPY (SDPtr->star_pt.y);
+			if (which_space <= 1)
+				s.frame = SetRelFrameIndex (star_frame,
+						STAR_TYPE (star_type)
+						* NUM_STAR_COLORS
+						+ STAR_COLOR (star_type));
+			else if (SDPtr->star_pt.x == ARILOU_HOME_X
+					&& SDPtr->star_pt.y == ARILOU_HOME_Y)
+				s.frame = SetRelFrameIndex (star_frame,
+						SUPER_GIANT_STAR * NUM_STAR_COLORS + GREEN_BODY);
+			else
+				s.frame = SetRelFrameIndex (star_frame,
+						GIANT_STAR * NUM_STAR_COLORS + GREEN_BODY);
+			DrawStamp (&s);
+		}
 
 		++SDPtr;
-	} while (SDPtr->star_pt.x <= MAX_X_UNIVERSE
-			&& SDPtr->star_pt.y <= MAX_Y_UNIVERSE);
+	} while (SDPtr->star_pt.x <= MAX_X_UNIVERSE && SDPtr->star_pt.y <= MAX_Y_UNIVERSE);
 
 	if (GET_GAME_STATE (ARILOU_SPACE))
 	{
@@ -520,15 +668,19 @@ DrawStarMap (COUNT race_update, RECT *pC
 			s.origin.x = UNIVERSE_TO_DISPX (QUASI_SPACE_X);
 			s.origin.y = UNIVERSE_TO_DISPY (QUASI_SPACE_Y);
 		}
-		s.frame = SetRelFrameIndex (star_frame,
-				GIANT_STAR * NUM_STAR_COLORS + GREEN_BODY);
+		s.frame = SetRelFrameIndex (star_frame, GIANT_STAR * NUM_STAR_COLORS + GREEN_BODY);
 		DrawStamp (&s);
 	}
 
 	if (race_update == 0
 			&& GLOBAL (autopilot.x) != ~0
 			&& GLOBAL (autopilot.y) != ~0)
-		DrawAutoPilot (&GLOBAL (autopilot));
+    {
+        if (ENABLE_NON_EUCLIDEAN_ORZ_SPACE && GET_GAME_STATE (ORZ_SPACE_SIDE) > 1)
+		    DrawOrzSpaceAutoPilot (&GLOBAL (autopilot));
+        else
+            DrawAutoPilot (&GLOBAL (autopilot));
+    }
 
 	if (transition_pending)
 	{
@@ -536,7 +688,6 @@ DrawStarMap (COUNT race_update, RECT *pC
 		ScreenTransition (3, &r);
 		transition_pending = FALSE;
 	}
-	
 	UnbatchGraphics ();
 
 	if (pClipRect)
@@ -555,7 +706,6 @@ DrawStarMap (COUNT race_update, RECT *pC
 					UNIVERSE_TO_DISPY (cursorLoc.y));
 		}
 	}
-
 	if (draw_cursor)
 		UnlockMutex (GraphicsLock);
 }
@@ -583,7 +733,7 @@ EraseCursor (COORD curs_x, COORD curs_y)
 		r.extent.height = SIS_SCREEN_HEIGHT - r.corner.y;
 
 #ifndef OLD
-	RepairBackRect (&r);
+	RepairBackRect (&r, FALSE);
 #else /* NEW */
 	r.extent.height += r.corner.y & 1;
 	r.corner.y &= ~1;
@@ -596,7 +746,7 @@ EraseCursor (COORD curs_x, COORD curs_y)
 static void
 ZoomStarMap (SIZE dir)
 {
-#define MAX_ZOOM_SHIFT 4
+#define MAX_ZOOM_SHIFT (BYTE)(4 - RESOLUTION_FACTOR)
 	if (dir > 0)
 	{
 		if (zoomLevel < MAX_ZOOM_SHIFT)
@@ -675,6 +825,11 @@ UpdateCursorLocation (int sx, int sy, co
 			cursorLoc.y = MAX_Y_UNIVERSE;
 
 		s.origin.y = UNIVERSE_TO_DISPY (cursorLoc.y);
+		if (s.origin.y < 0)
+		{
+			s.origin.y = 0;
+			cursorLoc.y = DISP_TO_UNIVERSEY (0);
+		}
 	}
 
 	if (s.origin.x < 0 || s.origin.y < 0
@@ -699,30 +854,42 @@ UpdateCursorLocation (int sx, int sy, co
 
 #define CURSOR_INFO_BUFSIZE 256
 
+// JMS: How close to a star the cursor has to be to 'snap' into it.
+// Don't make this larger than 1 for lo-res(1x). Otherwise the cursor gets stuck on stars.
+#define CURSOR_SNAP_AREA (RES_CASE(0,3,6))
+
 static void
 UpdateCursorInfo (UNICODE *prevbuf)
-{
-	UNICODE buf[CURSOR_INFO_BUFSIZE] = "";
+{	
+	// JMS: Display hint for the player to use the star search facility
+	UNICODE buf[CURSOR_INFO_BUFSIZE];
 	POINT pt;
 	STAR_DESC *SDPtr;
 	STAR_DESC *BestSDPtr;
 
+	// "(Star search: default F6)"
+	utf8StringCopy (buf, sizeof (buf), GAME_STRING (FEEDBACK_STRING_BASE + 2));
+        
 	pt.x = UNIVERSE_TO_DISPX (cursorLoc.x);
 	pt.y = UNIVERSE_TO_DISPY (cursorLoc.y);
 
 	SDPtr = BestSDPtr = 0;
+	
 	while ((SDPtr = FindStar (SDPtr, &cursorLoc, 75, 75)))
 	{
-		if (UNIVERSE_TO_DISPX (SDPtr->star_pt.x) == pt.x
-				&& UNIVERSE_TO_DISPY (SDPtr->star_pt.y) == pt.y
-				&& (BestSDPtr == 0
-				|| STAR_TYPE (SDPtr->Type) >= STAR_TYPE (BestSDPtr->Type)))
+		if ((UNIVERSE_TO_DISPX (SDPtr->star_pt.x) >= pt.x - CURSOR_SNAP_AREA && UNIVERSE_TO_DISPX (SDPtr->star_pt.x) <= pt.x + CURSOR_SNAP_AREA)
+				&& (UNIVERSE_TO_DISPY (SDPtr->star_pt.y) >= pt.y - CURSOR_SNAP_AREA && UNIVERSE_TO_DISPY (SDPtr->star_pt.y) <= pt.y + CURSOR_SNAP_AREA)
+				&& (BestSDPtr == 0 || STAR_TYPE (SDPtr->Type) >= STAR_TYPE (BestSDPtr->Type)))
 			BestSDPtr = SDPtr;
 	}
 
 	if (BestSDPtr)
-	{
-		cursorLoc = BestSDPtr->star_pt;
+	{	// A star is near the cursor:
+		// Snap cursor onto star only in 1x res. In hi-res modes,  
+		// snapping is done when the star is selected as auto-pilot target.
+		if (RESOLUTION_FACTOR == 0)
+			cursorLoc = BestSDPtr->star_pt;
+		
 		GetClusterName (BestSDPtr, buf);
 	}
 	else
@@ -768,7 +935,18 @@ UpdateCursorInfo (UNICODE *prevbuf)
 	if (strcmp (buf, prevbuf) != 0)
 	{
 		strcpy (prevbuf, buf);
-		DrawSISMessage (buf);
+		
+		if (BestSDPtr)
+			DrawSISMessage (buf);
+		else
+		{
+			CONTEXT OldContext;
+			
+			OldContext = SetContext (OffScreenContext);
+			SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x0E, 0xA7, 0xD9), 0x00));
+			DrawSISMessageEx (buf, -1, -1, DSME_MYCOLOR);
+			SetContext (OldContext);
+		}
 	}
 	UnlockMutex (GraphicsLock);
 }
@@ -792,7 +970,7 @@ UpdateFuelRequirement (void)
 	pt.y -= cursorLoc.y;
 
 	f = (DWORD)((long)pt.x * pt.x + (long)pt.y * pt.y);
-	if (f == 0 || GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1)
+	if (f == 0 || GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1 || GET_GAME_STATE (ORZ_SPACE_SIDE) > 1) // JMS: ORZ space check
 		fuel_required = 0;
 	else
 		fuel_required = square_root (f) + (FUEL_TANK_SCALE / 20);
@@ -1228,11 +1406,42 @@ DoStarSearch (MENU_STATE *pMS)
 static BOOLEAN
 DoMoveCursor (MENU_STATE *pMS)
 {
-#define MIN_ACCEL_DELAY (ONE_SECOND / 60)
-#define MAX_ACCEL_DELAY (ONE_SECOND / 8)
-#define STEP_ACCEL_DELAY (ONE_SECOND / 120)
+#define MIN_ACCEL_DELAY_1X (ONE_SECOND / 60)
+#define MAX_ACCEL_DELAY_1X (ONE_SECOND / 8)
+#define STEP_ACCEL_DELAY_1X (ONE_SECOND / 120)
+#define MIN_ACCEL_DELAY_2X (ONE_SECOND / 60)
+#define MAX_ACCEL_DELAY_2X (ONE_SECOND / 10)
+#define STEP_ACCEL_DELAY_2X (ONE_SECOND / 120)
+#define MIN_ACCEL_DELAY_4X (ONE_SECOND / 60)
+#define MAX_ACCEL_DELAY_4X (ONE_SECOND / 10)
+#define STEP_ACCEL_DELAY_4X (ONE_SECOND / 120)
+
 	static UNICODE last_buf[CURSOR_INFO_BUFSIZE];
 	DWORD TimeIn = GetTimeCounter ();
+	static COUNT moveRepeats;
+	BOOLEAN isMove = FALSE;
+	
+	COUNT MIN_ACCEL_DELAY, MAX_ACCEL_DELAY, STEP_ACCEL_DELAY;
+	
+	if (RESOLUTION_FACTOR == 0)
+	{
+		MIN_ACCEL_DELAY = MIN_ACCEL_DELAY_1X;
+		MAX_ACCEL_DELAY = MAX_ACCEL_DELAY_1X;
+		STEP_ACCEL_DELAY = STEP_ACCEL_DELAY_1X;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		MIN_ACCEL_DELAY = MIN_ACCEL_DELAY_2X;
+		MAX_ACCEL_DELAY = MAX_ACCEL_DELAY_2X;
+		STEP_ACCEL_DELAY = STEP_ACCEL_DELAY_2X;
+	}
+	else
+	{
+		MIN_ACCEL_DELAY = MIN_ACCEL_DELAY_4X;
+		MAX_ACCEL_DELAY = MAX_ACCEL_DELAY_4X;
+		STEP_ACCEL_DELAY = STEP_ACCEL_DELAY_4X;
+	}
+	
 
 	if (!pMS->Initialized)
 	{
@@ -1262,7 +1471,40 @@ DoMoveCursor (MENU_STATE *pMS)
 	}
 	else if (PulsedInputState.menu[KEY_MENU_SELECT])
 	{
+		// JMS: The hi-res modes now have a user-friendly starmap cursor.
+		// The cursor finds a star even if the cursor is several pixels away from it (CURSOR_SNAP_AREA)
+		// The cursor centers on the star only when selected as an auto-pilot target.
+		if (RESOLUTION_FACTOR > 0)
+		{
+			STAR_DESC *SDPtr;
+			STAR_DESC *BestSDPtr;
+			POINT pt;
+			
+			pt.x = UNIVERSE_TO_DISPX (cursorLoc.x);
+			pt.y = UNIVERSE_TO_DISPY (cursorLoc.y);
+			SDPtr = BestSDPtr = 0;
+			
+			while ((SDPtr = FindStar (SDPtr, &cursorLoc, 75, 75)))
+			{
+				if ((UNIVERSE_TO_DISPX (SDPtr->star_pt.x) >= pt.x - CURSOR_SNAP_AREA && UNIVERSE_TO_DISPX (SDPtr->star_pt.x) <= pt.x + CURSOR_SNAP_AREA)
+					&& (UNIVERSE_TO_DISPY (SDPtr->star_pt.y) >= pt.y -CURSOR_SNAP_AREA && UNIVERSE_TO_DISPY (SDPtr->star_pt.y) <= pt.y + CURSOR_SNAP_AREA)
+					&& (BestSDPtr == 0 || STAR_TYPE (SDPtr->Type) >= STAR_TYPE (BestSDPtr->Type)))
+					BestSDPtr = SDPtr;
+			}
+			
+			if (BestSDPtr)
+			{
+				cursorLoc = BestSDPtr->star_pt;
+				UpdateCursorLocation (0, 0, &BestSDPtr->star_pt);
+			}
+		}
+		
 		GLOBAL (autopilot) = cursorLoc;
+        if (ENABLE_NON_EUCLIDEAN_ORZ_SPACE && GET_GAME_STATE (ORZ_SPACE_SIDE) > 1)
+        {
+            SetOrzSpaceAutoPilot();
+        }
+
 #ifdef DEBUG
 		if (instantMove)
 		{
@@ -1302,8 +1544,7 @@ DoMoveCursor (MENU_STATE *pMS)
 			UpdateCursorInfo (last_buf);
 			UpdateFuelRequirement ();
 
-			SetMenuRepeatDelay (MIN_ACCEL_DELAY, MAX_ACCEL_DELAY,
-					STEP_ACCEL_DELAY, TRUE);
+			SetMenuRepeatDelay (MIN_ACCEL_DELAY, MAX_ACCEL_DELAY, STEP_ACCEL_DELAY, TRUE);
 			SetMenuSounds (MENU_SOUND_NONE, MENU_SOUND_NONE);
 		}
 		else
@@ -1330,15 +1571,36 @@ DoMoveCursor (MENU_STATE *pMS)
 		if (PulsedInputState.menu[KEY_MENU_UP])      sy =   -1;
 		if (PulsedInputState.menu[KEY_MENU_DOWN])    sy =    1;
 
+		if (moveRepeats > 25)
+		{
+			sx *= RES_CASE(1,2,2);
+			sy *= RES_CASE(1,2,2);
+		}
+		if (moveRepeats > 50)
+		{
+			sx *= RES_CASE(1,1,2);
+			sy *= RES_CASE(1,1,2);
+		}
+		
+		// BW: we need to go through this because 4x only checks for
+		// input every ONE_SECOND/40 or so, thus reducing
+		// MIN_ACCEL_DELAY is of no use. In practice it's similar.
+		
 		if (sx != 0 || sy != 0)
 		{
 			UpdateCursorLocation (sx, sy, NULL);
 			UpdateCursorInfo (last_buf);
 			UpdateFuelRequirement ();
+			isMove = TRUE;
 		}
-
+	
 		SleepThreadUntil (TimeIn + MIN_ACCEL_DELAY);
 	}
+	
+	if (isMove)
+		++moveRepeats;
+	else
+		moveRepeats = 0;
 
 	flashCurrentLocation (NULL);
 
@@ -1416,9 +1678,7 @@ UpdateMap (void)
 			if (!AnyButtonPress (TRUE))
 				ButtonState = 0;
 		}
-		else if ((Interrupted = (BOOLEAN)(
-				Interrupted || AnyButtonPress (TRUE)
-				)))
+		else if ((Interrupted = (BOOLEAN)(Interrupted || AnyButtonPress (TRUE))))
 			MapDrawn = TRUE;
 
 		if (FleetPtr->known_strength)
@@ -1517,7 +1777,13 @@ DoneSphereMove:
 				FleetPtr->known_loc = FleetPtr->loc;
 			}
 
-			delta = FleetPtr->actual_strength - FleetPtr->known_strength;
+			// JMS: Negative known strength marks initial state of the SoI's: 
+			// Only the home planet of certain races is known -> show small sphere.
+			if (FleetPtr->known_strength > 0)
+				delta = FleetPtr->actual_strength - FleetPtr->known_strength;
+			else if (FleetPtr->known_strength < 0)
+				delta = 10;
+			
 			if (delta)
 			{
 				if (!MapDrawn)
@@ -1543,7 +1809,11 @@ DoneSphereMove:
 				{
 					do
 					{
-						FleetPtr->known_strength += dx;
+						// JMS: Negative known strength marks initial state of the SoI's: 
+						// Only the home planet of certain races is known -> show small sphere.
+						if (FleetPtr->known_strength > 0)
+							FleetPtr->known_strength += dx;
+						
 						GetSphereRect (FleetPtr, &temp_r1, &r);
 					} while (delta--
 							&& ((delta & 0xF)
@@ -1554,9 +1824,7 @@ DoneSphereMove:
 						if (!AnyButtonPress (TRUE))
 							ButtonState = 0;
 					}
-					else if ((Interrupted = (BOOLEAN)(
-								Interrupted || AnyButtonPress (TRUE)
-								)))
+					else if ((Interrupted = (BOOLEAN)(Interrupted || AnyButtonPress (TRUE))))
 					{
 						MapDrawn = TRUE;
 						goto DoneSphereGrowth;
@@ -1573,7 +1841,10 @@ DoneSphereMove:
 					RepairMap ((COUNT)~0, &last_r, &r);
 
 DoneSphereGrowth:
-				FleetPtr->known_strength = FleetPtr->actual_strength;
+				// JMS: Negative known strength marks initial state of the SoI's: 
+				// Only the home planet of certain races is known -> show small sphere.
+				if (FleetPtr->known_strength > 0)
+					FleetPtr->known_strength = FleetPtr->actual_strength;
 			}
 		}
 
@@ -1590,6 +1861,27 @@ StarMap (void)
 	RECT clip_r;
 	CONTEXT OldContext;
 
+	COUNT MIN_ACCEL_DELAY, MAX_ACCEL_DELAY, STEP_ACCEL_DELAY;
+	
+	if (RESOLUTION_FACTOR == 0)
+	{
+		MIN_ACCEL_DELAY = MIN_ACCEL_DELAY_1X;
+		MAX_ACCEL_DELAY = MAX_ACCEL_DELAY_1X;
+		STEP_ACCEL_DELAY = STEP_ACCEL_DELAY_1X;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		MIN_ACCEL_DELAY = MIN_ACCEL_DELAY_2X;
+		MAX_ACCEL_DELAY = MAX_ACCEL_DELAY_2X;
+		STEP_ACCEL_DELAY = STEP_ACCEL_DELAY_2X;
+	}
+	else
+	{
+		MIN_ACCEL_DELAY = MIN_ACCEL_DELAY_4X;
+		MAX_ACCEL_DELAY = MAX_ACCEL_DELAY_4X;
+		STEP_ACCEL_DELAY = STEP_ACCEL_DELAY_4X;
+	}
+	
 	memset (&MenuState, 0, sizeof (MenuState));
 
 	zoomLevel = 0;
diff -ruNp src.orig/uqm/planets/report.c src/uqm/planets/report.c
--- src.orig/uqm/planets/report.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/report.c	2017-11-01 15:31:03 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
 #include "lander.h"
 #include "scan.h"
 #include "planets.h"
@@ -33,8 +35,8 @@
 #include <string.h>
 
 
-#define NUM_CELL_COLS MAP_WIDTH / 6
-#define NUM_CELL_ROWS MAP_HEIGHT / 6
+#define NUM_CELL_COLS (MAP_WIDTH / (6 << RESOLUTION_FACTOR) + 3 * RESOLUTION_FACTOR) // JMS_GFX 
+#define NUM_CELL_ROWS (MAP_HEIGHT / (6 << RESOLUTION_FACTOR) + RESOLUTION_FACTOR) // JMS_GFX
 #define MAX_CELL_COLS 40
 
 extern FRAME SpaceJunkFrame;
@@ -43,10 +45,23 @@ static void
 ClearReportArea (void)
 {
 	COUNT x, y;
+	BYTE emptycols, emptyrows;  // JMS_GFX
 	RECT r;
 	STAMP s;
 	COORD startx;
 
+	// JMS_GFX
+	if (RESOLUTION_FACTOR > 0)
+	{
+		emptycols = NUM_CELL_COLS + 1;
+		emptyrows = NUM_CELL_ROWS + 1;
+	}
+	else
+	{
+		emptycols = NUM_CELL_COLS;
+		emptyrows = NUM_CELL_ROWS;
+	}
+	
 	if (optWhichFonts == OPT_PC)
 		s.frame = SetAbsFrameIndex (SpaceJunkFrame, 21);
 	else
@@ -57,15 +72,14 @@ ClearReportArea (void)
 
 	SetContextBackGroundColor (BLACK_COLOR);
 	ClearDrawable ();
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x00, 0x07, 0x00), 0x57));
+	SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x00, 0x07, 0x00), 0x57));
 	
-	startx = 1 + (r.extent.width >> 1) - 1;
+	startx = 1 + (r.extent.width >> 1) - 1 - 4 * RESOLUTION_FACTOR;  // JMS_GFX
 	s.origin.y = 1;
-	for (y = 0; y < NUM_CELL_ROWS; ++y)
+	for (y = 0; y < emptyrows; ++y)
 	{
 		s.origin.x = startx;
-		for (x = 0; x < NUM_CELL_COLS; ++x)
+		for (x = 0; x < emptycols; ++x)
 		{
 			if (optWhichFonts == OPT_PC)
 				DrawStamp (&s);
@@ -126,15 +140,13 @@ MakeReport (SOUND ReadOutSounds, UNICODE
 
 		col_cells = 0;
 		// check if the remaining text fits on current screen
-		if (row_cells == NUM_CELL_ROWS - 1
-				&& (StrLen > NUM_CELL_COLS || lf_pos > 1))
+		if (row_cells == NUM_CELL_ROWS - 1 && (StrLen > NUM_CELL_COLS || lf_pos > 1))
 		{
 			col_cells = (NUM_CELL_COLS >> 1) - (end_page_len >> 1);
 			t.pStr = end_page_buf;
 			StrLen += end_page_len;
 		}
-		t.baseline.x = 1 + (r.extent.width >> 1)
-				+ (col_cells * (r.extent.width + 1)) - 1;
+		t.baseline.x = 1 + (r.extent.width >> 1) + (col_cells * (r.extent.width + 1)) - 1 - 3 * RESOLUTION_FACTOR; // JMS_GFX
 		do
 		{
 			COUNT word_chars;
@@ -212,7 +224,7 @@ MakeReport (SOUND ReadOutSounds, UNICODE
 
 InitPageCell:
 			ButtonState = 1;
-			t.baseline.y = r.extent.height + 1;
+			t.baseline.y = r.extent.height + (1 << RESOLUTION_FACTOR) + 3 * RESOLUTION_FACTOR; // JMS_GFX
 			row_cells = 0;
 			if (StrLen)
 			{
diff -ruNp src.orig/uqm/planets/roster.c src/uqm/planets/roster.c
--- src.orig/uqm/planets/roster.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/roster.c	2017-11-01 15:31:03 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
 #include "../build.h"
 #include "../colors.h"
 #include "../controls.h"
@@ -32,9 +34,17 @@
 #include <stdlib.h>
 
 // Ship icon positions in status display around the flagship
-static const POINT ship_pos[MAX_BUILT_SHIPS] =
+static const POINT ship_pos_1x[MAX_BUILT_SHIPS] =
+{
+	SUPPORT_SHIP_PTS_1X
+};
+static const POINT ship_pos_2x[MAX_BUILT_SHIPS] =
 {
-	SUPPORT_SHIP_PTS
+	SUPPORT_SHIP_PTS_2X
+};
+static const POINT ship_pos_4x[MAX_BUILT_SHIPS] =
+{
+	SUPPORT_SHIP_PTS_4X
 };
 
 typedef struct
@@ -65,7 +75,8 @@ drawSupportShip (ROSTER_STATE *rosterSta
 	if (!rosterState->curShipFrame)
 		return;
 
-	s.origin = rosterState->curShipPt;
+	s.origin.x = RES_STAT_SCALE(rosterState->curShipPt.x);
+	s.origin.y = RES_STAT_SCALE(rosterState->curShipPt.y);
 	s.frame = rosterState->curShipFrame;
 	
 	if (filled)
@@ -85,7 +96,7 @@ getSupportShipIcon (ROSTER_STATE *roster
 	if (!ShipFragPtr)
 		return;
 
-	rosterState->curShipFrame = ShipFragPtr->icons;
+	rosterState->curShipFrame = SetAbsFrameIndex (ShipFragPtr->icons, 2);
 	UnlockShipFrag (&GLOBAL (built_ship_q), hShipFrag);
 }
 
@@ -130,6 +141,8 @@ LockSupportShip (ROSTER_STATE *rosterSta
 {
 	const POINT *pship_pos;
 	HSHIPFRAG hStarShip, hNextShip;
+	
+	const POINT *ship_pos = RES_CASE(ship_pos_1x,ship_pos_2x,ship_pos_4x);
 
 	// Lookup the current escort's location in the unsorted points list
 	// to find the original escort index
@@ -398,6 +411,7 @@ RosterMenu (void)
 {
 	MENU_STATE MenuState;
 	ROSTER_STATE RosterState;
+	const POINT *ship_pos = RES_CASE(ship_pos_1x,ship_pos_2x,ship_pos_4x);
 
 	memset (&MenuState, 0, sizeof MenuState);
 	MenuState.privData = &RosterState;
@@ -409,8 +423,8 @@ RosterMenu (void)
 		return FALSE;
 
 	// Get the escort positions we will use and sort on X then Y
-	assert (sizeof (RosterState.shipPos) == sizeof (ship_pos));
-	memcpy (RosterState.shipPos, ship_pos, sizeof (ship_pos));
+	assert (sizeof (RosterState.shipPos) == sizeof (ship_pos_1x));
+	memcpy (RosterState.shipPos, ship_pos, sizeof (ship_pos_1x));
 	qsort (RosterState.shipPos, RosterState.count,
 			sizeof (RosterState.shipPos[0]), compShipPos);
 
diff -ruNp src.orig/uqm/planets/scan.c src/uqm/planets/scan.c
--- src.orig/uqm/planets/scan.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/scan.c	2017-11-01 15:31:03 -0700
@@ -16,6 +16,13 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: -Cannot dispatch landers on restricted planets
+//			 -Certain star systems can have more than one energy blip graphics on planet surface simultaneously
+//			 -If black orb is found and the lander returned to Explorer ship, initiate cutscene.
+
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
+#include "../fmv.h"
 #include "lander.h"
 #include "lifeform.h"
 #include "scan.h"
@@ -50,6 +57,7 @@ extern FRAME SpaceJunkFrame;
 #undef SPIN_ON_SCAN
 
 #define FLASH_INDEX 105
+#define OUTLINECOLOR (BUILD_COLOR_RGBA(0x00,0x00,0x00,0x66))
 
 static CONTEXT ScanContext;
 
@@ -66,9 +74,8 @@ enum ScanMenuItems
 	DISPATCH_SHUTTLE,
 };
 
-
 void
-RepairBackRect (RECT *pRect)
+RepairBackRect (RECT *pRect, BOOLEAN Fullscreen)
 {
 	RECT new_r, old_r;
 
@@ -79,7 +86,11 @@ RepairBackRect (RECT *pRect)
 
 	new_r.extent.height += new_r.corner.y & 1;
 	new_r.corner.y &= ~1;
-	DrawFromExtraScreen (&new_r);
+	
+	if (Fullscreen)
+		DrawFromExtraScreen_Fs (&new_r);
+	else
+		DrawFromExtraScreen (&new_r);
 }
 
 static void
@@ -103,7 +114,8 @@ PrintScanTitlePC (TEXT *t, RECT *r, cons
 	SetContextForeGroundColor (SCAN_PC_TITLE_COLOR);
 	t->pStr = txt;
 	t->CharCount = (COUNT)~0;
-	font_DrawText (t);
+	//font_DrawText (t);
+	font_DrawTracedText (t, SCAN_PC_TITLE_COLOR, OUTLINECOLOR);
 	TextRect (t, r, NULL);
 	t->baseline.x += r->extent.width;
 	SetContextForeGroundColor (SCAN_INFO_COLOR);
@@ -152,7 +164,7 @@ GetPlanetTitle (UNICODE *buf, COUNT bufs
 static void
 PrintCoarseScanPC (void)
 {
-#define SCAN_LEADING_PC 14
+#define SCAN_LEADING_PC (14 << RESOLUTION_FACTOR) // JMS_GFX
 	SDWORD val;
 	TEXT t;
 	RECT r;
@@ -165,20 +177,21 @@ PrintCoarseScanPC (void)
 
 	t.align = ALIGN_CENTER;
 	t.baseline.x = SIS_SCREEN_WIDTH >> 1;
-	t.baseline.y = 13;
+	t.baseline.y = 13 << RESOLUTION_FACTOR; // JMS_GFX
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 
 	SetContextForeGroundColor (SCAN_PC_TITLE_COLOR);
 	SetContextFont (MicroFont);
-	font_DrawText (&t);
+	//font_DrawText (&t);
+	font_DrawTracedText (&t, SCAN_INFO_COLOR, OUTLINECOLOR);
 
 	SetContextFont (TinyFont);
 	UnlockMutex (GraphicsLock);
 
-#define LEFT_SIDE_BASELINE_X_PC 5
-#define RIGHT_SIDE_BASELINE_X_PC (SIS_SCREEN_WIDTH - 75)
-#define SCAN_BASELINE_Y_PC 40
+#define LEFT_SIDE_BASELINE_X_PC (5 << RESOLUTION_FACTOR) // JMS_GFX
+#define RIGHT_SIDE_BASELINE_X_PC (SIS_SCREEN_WIDTH - (75 << RESOLUTION_FACTOR)) // JMS_GFX
+#define SCAN_BASELINE_Y_PC (40 << RESOLUTION_FACTOR) // JMS_GFX
 
 	t.baseline.y = SCAN_BASELINE_Y_PC;
 	t.align = ALIGN_LEFT;
@@ -192,7 +205,8 @@ PrintCoarseScanPC (void)
 			GAME_STRING (ORBITSCAN_STRING_BASE + 1)); // " a.u."
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	//font_DrawText (&t);
+	font_DrawTracedText (&t, SCAN_INFO_COLOR, OUTLINECOLOR);
 	t.baseline.y += SCAN_LEADING_PC;
 	UnlockMutex (GraphicsLock);
 
@@ -214,7 +228,8 @@ PrintCoarseScanPC (void)
 	}
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	//font_DrawText (&t);
+	font_DrawTracedText (&t, SCAN_INFO_COLOR, OUTLINECOLOR);
 	t.baseline.y += SCAN_LEADING_PC;
 	UnlockMutex (GraphicsLock);
 
@@ -225,7 +240,8 @@ PrintCoarseScanPC (void)
 			pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature);
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	//font_DrawText (&t);
+	font_DrawTracedText (&t, SCAN_INFO_COLOR, OUTLINECOLOR);
 	t.baseline.y += SCAN_LEADING_PC;
 	UnlockMutex (GraphicsLock);
 
@@ -242,7 +258,8 @@ PrintCoarseScanPC (void)
 		t.pStr = buf;
 	}
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	//font_DrawText (&t);
+	font_DrawTracedText (&t, SCAN_INFO_COLOR, OUTLINECOLOR);
 	t.baseline.y += SCAN_LEADING_PC;
 	UnlockMutex (GraphicsLock);
 
@@ -260,7 +277,8 @@ PrintCoarseScanPC (void)
 		t.pStr = buf;
 	}
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	//font_DrawText (&t);
+	font_DrawTracedText (&t, SCAN_INFO_COLOR, OUTLINECOLOR);
 	UnlockMutex (GraphicsLock);
 
 	t.baseline.y = SCAN_BASELINE_Y_PC;
@@ -278,7 +296,8 @@ PrintCoarseScanPC (void)
 			GAME_STRING (ORBITSCAN_STRING_BASE + 12)); // " e.s."
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	//font_DrawText (&t);
+	font_DrawTracedText (&t, SCAN_INFO_COLOR, OUTLINECOLOR);
 	t.baseline.y += SCAN_LEADING_PC;
 	UnlockMutex (GraphicsLock);
 
@@ -290,7 +309,8 @@ PrintCoarseScanPC (void)
 			GAME_STRING (ORBITSCAN_STRING_BASE + 12)); // " e.s."
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	//font_DrawText (&t);
+	font_DrawTracedText (&t, SCAN_INFO_COLOR, OUTLINECOLOR);
 	t.baseline.y += SCAN_LEADING_PC;
 	UnlockMutex (GraphicsLock);
 
@@ -304,7 +324,8 @@ PrintCoarseScanPC (void)
 			GAME_STRING (ORBITSCAN_STRING_BASE + 15)); // " g."
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	//font_DrawText (&t);
+	font_DrawTracedText (&t, SCAN_INFO_COLOR, OUTLINECOLOR);
 	t.baseline.y += SCAN_LEADING_PC;
 	UnlockMutex (GraphicsLock);
 
@@ -317,7 +338,8 @@ PrintCoarseScanPC (void)
 			GAME_STRING (ORBITSCAN_STRING_BASE + 17)); // " days"
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	//font_DrawText (&t);
+	font_DrawTracedText (&t, SCAN_INFO_COLOR, OUTLINECOLOR);
 	t.baseline.y += SCAN_LEADING_PC;
 	UnlockMutex (GraphicsLock);
 
@@ -330,14 +352,15 @@ PrintCoarseScanPC (void)
 	t.pStr = buf;
 	sprintf (buf, "%d" STR_DEGREE_SIGN, val);
 	t.CharCount = (COUNT)~0;
-	font_DrawText (&t);
+	//font_DrawText (&t);
+	font_DrawTracedText (&t, SCAN_INFO_COLOR, OUTLINECOLOR);
 	UnlockMutex (GraphicsLock);
 }
 
 static void
 PrintCoarseScan3DO (void)
 {
-#define SCAN_LEADING 19
+#define SCAN_LEADING (19 << RESOLUTION_FACTOR) // JMS_GFX
 	SDWORD val;
 	TEXT t;
 	STAMP s;
@@ -350,7 +373,7 @@ PrintCoarseScan3DO (void)
 
 	t.align = ALIGN_CENTER;
 	t.baseline.x = SIS_SCREEN_WIDTH >> 1;
-	t.baseline.y = 13;
+	t.baseline.y = 13 << RESOLUTION_FACTOR; // JMS_GFX
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 
@@ -359,15 +382,15 @@ PrintCoarseScan3DO (void)
 	font_DrawText (&t);
 
 	s.origin.x = s.origin.y = 0;
-	s.origin.x = 16 - SAFE_X;
+	s.origin.x = (16 - SAFE_X) << RESOLUTION_FACTOR; // JMS_GFX
 	s.frame = SetAbsFrameIndex (SpaceJunkFrame, 20);
 	DrawStamp (&s);
 
 	UnlockMutex (GraphicsLock);
 
-#define LEFT_SIDE_BASELINE_X (27 + (16 - SAFE_X))
-#define RIGHT_SIDE_BASELINE_X (SIS_SCREEN_WIDTH - LEFT_SIDE_BASELINE_X)
-#define SCAN_BASELINE_Y 25
+#define LEFT_SIDE_BASELINE_X ((27 + (16 - SAFE_X)) << RESOLUTION_FACTOR) // JMS_GFX
+#define RIGHT_SIDE_BASELINE_X ((SIS_SCREEN_WIDTH - LEFT_SIDE_BASELINE_X) << RESOLUTION_FACTOR) // JMS_GFX
+#define SCAN_BASELINE_Y (25 << RESOLUTION_FACTOR) // JMS_GFX
 
 	t.baseline.x = LEFT_SIDE_BASELINE_X;
 	t.baseline.y = SCAN_BASELINE_Y;
@@ -509,6 +532,7 @@ savePlanetLocationImage (void)
 	r = cursorRect;
 	r.corner.x -= hs.x;
 	r.corner.y -= hs.y;
+		
 	eraseFrame = CaptureDrawable (CopyContextRect (&r));
 	SetFrameHot (eraseFrame, hs);
 }
@@ -559,7 +583,7 @@ setPlanetLoc (POINT new_pt, BOOLEAN rest
 static void
 flashPlanetLocation (void)
 {
-#define FLASH_FRAME_DELAY  (ONE_SECOND / 16)
+#define FLASH_FRAME_DELAY  (ONE_SECOND / (16 << RESOLUTION_FACTOR))
 	static BYTE c = 0x00;
 	static int val = -2;
 	static POINT prevPt;
@@ -567,8 +591,7 @@ flashPlanetLocation (void)
 	BOOLEAN locChanged;
 	TimeCount Now = GetTimeCounter ();
 
-	locChanged = prevPt.x != cursorRect.corner.x
-				|| prevPt.y != cursorRect.corner.y;
+	locChanged = prevPt.x != cursorRect.corner.x || prevPt.y != cursorRect.corner.y;
 
 	if (!locChanged && Now < NextTime)
 		return; // nothing to do
@@ -677,6 +700,35 @@ DispatchLander (void)
 	if (GLOBAL (CurrentActivity) & CHECK_ABORT)
 		return FALSE;
 
+	// JMS: If black orb is found and the lander returned to Explorer ship, allow initiating cutscene
+	if(GET_GAME_STATE(BLACK_ORB_STATE) == 1)
+	{
+		InputFrameCallback *oldCallback;
+		SET_GAME_STATE(BLACK_ORB_STATE, 2); // Now the black orb is fetched - prevent playing this
+		StopMusic ();
+		// Deactivate planet rotation -- is this really necessary ?
+		oldCallback = SetInputCallback (NULL);
+		LurgCutScene ();
+
+		FadeScreen(FadeAllToBlack, ONE_SECOND / 2);
+		GLOBAL (CurrentActivity) = CHECK_ABORT;
+
+		// JMS: Commented the next lines out for the demo.
+		// For the full game remove the GLOBAL (CurrentActivity) = CHECK_ABORT line above
+		// and uncomment the lines below. Also, replace the last Fade to black (FTB) in cinematic
+		// cutscene with (WAIT). (Otherwise the graphics stay black even after the cutscene.)
+		/*LockMutex (GraphicsLock);
+		  DrawSISFrame ();
+		  DrawSISMessage (NULL);
+		  DrawSISTitle (GLOBAL_SIS (PlanetName));
+		  DrawStarBackGround (TRUE);
+		  DrawPlanet (SIS_SCREEN_WIDTH - MAP_WIDTH + 7, SIS_SCREEN_HEIGHT - MAP_HEIGHT + 10, 0, 0);
+		  UnlockMutex (GraphicsLock);
+		  // Reactivate planet rotation
+		  SetInputCallback (oldCallback);
+		  PlayMusic (LanderMusic, TRUE, 1);*/
+	}
+
 	if (GET_GAME_STATE (FOUND_PLUTO_SPATHI) == 1)
 	{
 		/* Create Fwiffo group and go into comm with it */
@@ -712,6 +764,7 @@ DoPickPlanetSide (MENU_STATE *pMS)
 	PICK_PLANET_STATE *pickState = pMS->privData;
 	DWORD TimeIn = GetTimeCounter ();
 	BOOLEAN select, cancel;
+	POINT	new_pt;
 
 	select = PulsedInputState.menu[KEY_MENU_SELECT];
 	cancel = PulsedInputState.menu[KEY_MENU_CANCEL];
@@ -721,7 +774,7 @@ DoPickPlanetSide (MENU_STATE *pMS)
 		pickState->success = false;
 		return FALSE;
 	}
-
+			
 	if (cancel)
 	{
 		pickState->success = false;
@@ -734,9 +787,9 @@ DoPickPlanetSide (MENU_STATE *pMS)
 	}
 	else
 	{
-		SIZE dx = 0;
-		SIZE dy = 0;
-		POINT new_pt;
+		COUNT	i, j = 0; // JMS_GFX
+		SIZE	dx = 0;
+		SIZE	dy = 0;
 
 		new_pt = planetLoc;
 
@@ -749,38 +802,78 @@ DoPickPlanetSide (MENU_STATE *pMS)
 		if (CurrentInputState.menu[KEY_MENU_DOWN])
 			dy = 1;
 
-		LockMutex (GraphicsLock);
-		BatchGraphics ();
-
 		dx = dx << MAG_SHIFT;
-		if (dx)
-		{
-			new_pt.x += dx;
-			if (new_pt.x < 0)
-				new_pt.x += (MAP_WIDTH << MAG_SHIFT);
-			else if (new_pt.x >= (MAP_WIDTH << MAG_SHIFT))
-				new_pt.x -= (MAP_WIDTH << MAG_SHIFT);
-		}
 		dy = dy << MAG_SHIFT;
-		if (dy)
+		
+		// JMS_GFX: 1 for 320x240, 3 for 640x480, 7 for 1280x960
+		// XXX: This was good for debugging build, but too fast on opitmized release build.
+		//j = (1 << (RESOLUTION_FACTOR + 1)) - 1;
+		
+		// JMS_GFX: 1 for 320x240, 2 for 640x480, 4 for 1280x960
+		j = 1 << RESOLUTION_FACTOR;
+		
+		// JMS_GFX: This makes the scan cursor faster in hi-res modes.
+		// (Originally there was no loop, just the contents.)
+		for (i = 0; i < j; i++)
 		{
-			new_pt.y += dy;
-			if (new_pt.y < 0 || new_pt.y >= (MAP_HEIGHT << MAG_SHIFT))
-				new_pt.y = planetLoc.y;
-		}
+			LockMutex (GraphicsLock);
+			BatchGraphics ();
+		
+			if (dx)
+			{
+				new_pt.x += dx;
+				if (new_pt.x < 0)
+					new_pt.x += (MAP_WIDTH << MAG_SHIFT);
+				else if (new_pt.x >= (MAP_WIDTH << MAG_SHIFT))
+					new_pt.x -= (MAP_WIDTH << MAG_SHIFT);
+			}
+		
+			if (dy)
+			{
+				new_pt.y += dy;
+				if (new_pt.y < 0 || new_pt.y >= (MAP_HEIGHT << MAG_SHIFT))
+					new_pt.y = planetLoc.y;
+			}
 
+			if (!pointsEqual (new_pt, planetLoc))
+				setPlanetLoc (new_pt, TRUE);
+			
+			flashPlanetLocation ();
+		
+			// JMS_GFX: Just upping the denominator wouldn't do no good since
+			// something else limits entering this function to about once per 1/40 secs...
+			// Since I couldn't find that mysterious element, I had to do speed things up
+			// with a loop and this thing here.
+			// XXX: Actually, with the optimized release build the best solution now seems is to keep all at 1/40th, but keep the loop...
+			if (RESOLUTION_FACTOR == 0)
+				SleepThreadUntil (TimeIn + ONE_SECOND / 40);
+			else if (RESOLUTION_FACTOR == 1)
+				SleepThreadUntil (TimeIn + ONE_SECOND / 40);
+			else
+				SleepThreadUntil (TimeIn + ONE_SECOND / 40);
+			
+			UnbatchGraphics ();
+			UnlockMutex (GraphicsLock);
+		}
+	}
+	
+	// JMS_GFX: For some reason, 1280x960 is choppy, no matter how many iterations
+	// the loop has or how short the sleepthread is. This final redraw makes things
+	// a bit smoother.
+	// XXX: This was good at debugging build but mad the cursor blink too fast in optimized release build.
+	/*if (RESOLUTION_FACTOR == 2)
+	{
+		LockMutex (GraphicsLock);
+		BatchGraphics ();
+	
 		if (!pointsEqual (new_pt, planetLoc))
-		{
 			setPlanetLoc (new_pt, TRUE);
-		}
-
+	
 		flashPlanetLocation ();
-
+	
 		UnbatchGraphics ();
 		UnlockMutex (GraphicsLock);
-
-		SleepThreadUntil (TimeIn + ONE_SECOND / 40);
-	}
+	}*/
 
 	return TRUE;
 }
@@ -875,7 +968,24 @@ DrawScannedStuff (COUNT y, COUNT scan)
 
 		dy = y - ElementPtr->current.location.y;
 		if (LOBYTE (ElementPtr->scan_node) != scan || dy < 0)
-		{	// node of wrong type, or not time for it yet
+		{
+			if (scan == MINERAL_SCAN && LOBYTE (ElementPtr->scan_node) == BIOLOGICAL_SCAN
+				&& ElementPtr->mass_points == 51 && dy >= 0)
+			{
+				// JMS: Show Mineral Monster (critter index 51 during the mineral scan).
+			}
+			// node of wrong type, or not time for it yet
+			else
+			{
+				UnlockElement (hElement);
+				continue;
+			}
+		}
+		
+		// JMS: Don't show Mineral Monster in biological scan.
+		else if (scan == BIOLOGICAL_SCAN && LOBYTE (ElementPtr->scan_node) == BIOLOGICAL_SCAN
+				 && ElementPtr->mass_points == 51 )
+		{
 			UnlockElement (hElement);
 			continue;
 		}
@@ -934,9 +1044,9 @@ DrawScannedStuff (COUNT y, COUNT scan)
 	SetContextForeGroundColor (OldColor);
 }
 
-COUNT
+bool
 callGenerateForScanType (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT node, BYTE scanType)
+		COUNT *node, BYTE scanType)
 {
 	switch (scanType)
 	{
@@ -952,34 +1062,13 @@ callGenerateForScanType (SOLARSYS_STATE
 	}
 
 	assert (false);
-	return 0;
-}
-
-bool
-callPickupForScanType (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT node, BYTE scanType)
-{
-	switch (scanType)
-	{
-		case MINERAL_SCAN:
-			return (*solarSys->genFuncs->pickupMinerals) (
-					solarSys, world, node);
-		case ENERGY_SCAN:
-			return (*solarSys->genFuncs->pickupEnergy) (
-					solarSys, world, node);
-		case BIOLOGICAL_SCAN:
-			return (*solarSys->genFuncs->pickupLife) (
-					solarSys, world, node);
-	}
-
-	assert (false);
 	return false;
 }
 
 static void
 ScanPlanet (COUNT scanType)
 {
-#define SCAN_DURATION   (ONE_SECOND * 7 / 4)
+#define SCAN_DURATION   (ONE_SECOND * 7 / 4) // JMS_GFX
 // NUM_FLASH_COLORS for flashing blips; 1 for the final frame
 #define SCAN_LINES      (MAP_HEIGHT + NUM_FLASH_COLORS + 1)
 #define SCAN_LINE_WAIT  (SCAN_DURATION / SCAN_LINES)
@@ -1020,21 +1109,25 @@ ScanPlanet (COUNT scanType)
 		TimeCount TimeOut;
 
 		t.baseline.x = SIS_SCREEN_WIDTH >> 1;
-		t.baseline.y = SIS_SCREEN_HEIGHT - MAP_HEIGHT - 7;
+		t.baseline.y = SIS_SCREEN_HEIGHT - MAP_HEIGHT - (7 << RESOLUTION_FACTOR);
 		t.align = ALIGN_CENTER;
 		t.CharCount = (COUNT)~0;
 
+		pSolarSysState->CurNode = (COUNT)~0;
+		callGenerateForScanType (pSolarSysState,
+				pSolarSysState->pOrbitalDesc, &pSolarSysState->CurNode,
+				scan);
 		t.pStr = GAME_STRING (SCAN_STRING_BASE + scan);
 
 		LockMutex (GraphicsLock);
 		SetContext (PlanetContext);
 		r.corner.x = 0;
-		r.corner.y = t.baseline.y - 10;
+		r.corner.y = t.baseline.y - (10 << RESOLUTION_FACTOR); // JMS_GFX
 		r.extent.width = SIS_SCREEN_WIDTH;
 		r.extent.height = t.baseline.y - r.corner.y + 1;
 		// XXX: I do not know why we are repairing it here, as there
 		//   should not be anything drawn over the stars at the moment
-		RepairBackRect (&r);
+		RepairBackRect (&r, FALSE);
 
 		SetContextFont (MicroFont);
 		SetContextForeGroundColor (textColors[scan]);
@@ -1084,7 +1177,7 @@ ScanPlanet (COUNT scanType)
 
 	LockMutex (GraphicsLock);
 	SetContext (PlanetContext);
-	RepairBackRect (&r);
+	RepairBackRect (&r, FALSE);
 
 	SetContext (ScanContext);
 	if (scanType == AUTO_SCAN)
@@ -1119,9 +1212,10 @@ DoScan (MENU_STATE *pMS)
 			COUNT fuel_required;
 
 			if ((pSolarSysState->pOrbitalDesc->data_index & PLANET_SHIELDED)
+					||	pSolarSysState->pOrbitalDesc->flags & PLANET_RESTRICTED
 					|| (pSolarSysState->SysInfo.PlanetInfo.AtmoDensity ==
 						GAS_GIANT_ATMOSPHERE))
-			{	// cannot dispatch to shielded planets or gas giants
+			{	// JMS: cannot dispatch to shielded planets, restricted planets, or gas giants
 				PlayMenuSound (MENU_SOUND_FAILURE);
 				return TRUE;
 			}
@@ -1297,6 +1391,7 @@ generateBioNode (SOLARSYS_STATE *system,
 {
 	COUNT i;
 	COUNT creatureType;
+	DWORD j;
 
 	creatureType = system->SysInfo.PlanetInfo.CurType;
 
@@ -1304,19 +1399,24 @@ generateBioNode (SOLARSYS_STATE *system,
 	{
 		// Place moving creatures at a random location.
 		i = (COUNT)TFB_Random ();
-		NodeElementPtr->current.location.x =
-				(LOBYTE (i) % (MAP_WIDTH - (8 << 1))) + 8;
-		NodeElementPtr->current.location.y =
-				(HIBYTE (i) % (MAP_HEIGHT - (8 << 1))) + 8;
+		j = (DWORD)TFB_Random ();
+		
+		if (RESOLUTION_FACTOR == 0)
+		{
+			NodeElementPtr->current.location.x = (LOBYTE (i) % (MAP_WIDTH - (8 << 1))) + 8;
+			NodeElementPtr->current.location.y = (HIBYTE (i) % (MAP_HEIGHT - (8 << 1))) + 8;
+		}
+		else 
+		{
+			NodeElementPtr->current.location.x = (LOWORD (j) % (MAP_WIDTH - (8 << 1))) + 8;	// JMS_GFX: Replaced previous line with this line (BYTE was too small for 640x480 maps.)
+			NodeElementPtr->current.location.y = (HIWORD (j) % (MAP_HEIGHT - (8 << 1))) + 8;  // JMS_GFX: Replaced previous line with this line (BYTE was too small for 1280x960 maps.)
+		}
 	}
 
 	if (system->PlanetSideFrame[0] == 0)
-		system->PlanetSideFrame[0] =
-				CaptureDrawable (LoadGraphic (CANNISTER_MASK_PMAP_ANIM));
+		system->PlanetSideFrame[0] = CaptureDrawable (LoadGraphic (CANNISTER_MASK_PMAP_ANIM));
 
-	for (i = 0; i < MAX_LIFE_VARIATION
-			&& life_init_tab[i] != (BYTE)(creatureType + 1);
-			++i)
+	for (i = 0; i < MAX_LIFE_VARIATION && life_init_tab[i] != (BYTE)(creatureType + 1); ++i)
 	{
 		if (life_init_tab[i] != 0)
 			continue;
@@ -1327,9 +1427,9 @@ generateBioNode (SOLARSYS_STATE *system,
 		break;
 	}
 
+	NodeElementPtr->turn_wait = MAKE_BYTE (0, CreatureData[creatureType].FrameRate);
 	NodeElementPtr->mass_points = (BYTE)creatureType;
-	NodeElementPtr->hit_points = HINIBBLE (
-			CreatureData[creatureType].ValueAndHitPoints);
+	NodeElementPtr->hit_points = HINIBBLE (CreatureData[creatureType].ValueAndHitPoints);
 	DisplayArray[NodeElementPtr->PrimIndex].
 			Object.Stamp.frame = SetAbsFrameIndex (
 			system->PlanetSideFrame[i + 3], (COUNT)TFB_Random ());
@@ -1355,12 +1455,12 @@ GeneratePlanetSide (void)
 		COUNT num_nodes;
 		FRAME f;
 
-		f = SetAbsFrameIndex (MiscDataFrame,
-				NUM_SCANDOT_TRANSITIONS * (scan - ENERGY_SCAN));
+		f = SetAbsFrameIndex (MiscDataFrame, NUM_SCANDOT_TRANSITIONS * (scan - ENERGY_SCAN));
 
-		num_nodes = callGenerateForScanType (pSolarSysState,
-				pSolarSysState->pOrbitalDesc, ~0, scan);
+		pSolarSysState->CurNode = (COUNT)~0;
+		callGenerateForScanType (pSolarSysState, pSolarSysState->pOrbitalDesc, &pSolarSysState->CurNode, scan);
 
+		num_nodes = pSolarSysState->CurNode;
 		while (num_nodes--)
 		{
 			HELEMENT hNodeElement;
@@ -1376,59 +1476,90 @@ GeneratePlanetSide (void)
 
 			LockElement (hNodeElement, &NodeElementPtr);
 
-			callGenerateForScanType (pSolarSysState,
-					pSolarSysState->pOrbitalDesc, num_nodes,
-					scan);
+			pSolarSysState->CurNode = num_nodes;
+			callGenerateForScanType (pSolarSysState, pSolarSysState->pOrbitalDesc, &pSolarSysState->CurNode, scan);
 
 			NodeElementPtr->scan_node = MAKE_WORD (scan, num_nodes + 1);
 			NodeElementPtr->playerNr = PS_NON_PLAYER;
-			NodeElementPtr->current.location.x =
-					pSolarSysState->SysInfo.PlanetInfo.CurPt.x;
-			NodeElementPtr->current.location.y =
-					pSolarSysState->SysInfo.PlanetInfo.CurPt.y;
+			NodeElementPtr->current.location.x = pSolarSysState->SysInfo.PlanetInfo.CurPt.x;
+			NodeElementPtr->current.location.y = pSolarSysState->SysInfo.PlanetInfo.CurPt.y;
 
 			SetPrimType (&DisplayArray[NodeElementPtr->PrimIndex], STAMP_PRIM);
+			
 			if (scan == MINERAL_SCAN)
 			{
 				COUNT EType;
 
 				EType = pSolarSysState->SysInfo.PlanetInfo.CurType;
 				NodeElementPtr->turn_wait = (BYTE)EType;
-				NodeElementPtr->mass_points = HIBYTE (
-						pSolarSysState->SysInfo.PlanetInfo.CurDensity);
+				
+				// JMS: Partially scavenged energy blips won't return anymore to original size after leaving planet.
+				NodeElementPtr->mass_points = HIBYTE (pSolarSysState->SysInfo.PlanetInfo.CurDensity)
+						- pSolarSysState->SysInfo.PlanetInfo.PartiallyScavengedList[scan][num_nodes];
+				
 				NodeElementPtr->current.image.frame = SetAbsFrameIndex (
 						MiscDataFrame, (NUM_SCANDOT_TRANSITIONS * 2)
 						+ ElementCategory (EType) * 5);
 				NodeElementPtr->next.image.frame = SetRelFrameIndex (
 						NodeElementPtr->current.image.frame, LOBYTE (
 						pSolarSysState->SysInfo.PlanetInfo.CurDensity) + 1);
-				DisplayArray[NodeElementPtr->PrimIndex].Object.Stamp.frame =
-						IncFrameIndex (NodeElementPtr->next.image.frame);
+				DisplayArray[NodeElementPtr->PrimIndex].Object.Stamp.frame = IncFrameIndex (NodeElementPtr->next.image.frame);
 			}
 			else  /* (scan == BIOLOGICAL_SCAN || scan == ENERGY_SCAN) */
 			{
-				NodeElementPtr->current.image.frame = f;
-				NodeElementPtr->next.image.frame = SetRelFrameIndex (
-						f, NUM_SCANDOT_TRANSITIONS - 1);
+				// JMS: The Mineral Monster critter (at index 51) looks like a radioactive element in scan.
+				if (scan == BIOLOGICAL_SCAN && pSolarSysState->SysInfo.PlanetInfo.CurType == 51)
+				{
+					NodeElementPtr->current.image.frame = SetAbsFrameIndex (
+						MiscDataFrame, (NUM_SCANDOT_TRANSITIONS * 2) + 6 * 5);
+				
+					NodeElementPtr->next.image.frame = SetRelFrameIndex (
+						NodeElementPtr->current.image.frame, LOBYTE (
+						pSolarSysState->SysInfo.PlanetInfo.CurDensity) + 1);
+				}
+				else
+				{
+					NodeElementPtr->current.image.frame = f;
+					NodeElementPtr->next.image.frame = SetRelFrameIndex (f, NUM_SCANDOT_TRANSITIONS - 1);
+				}
+				
 				NodeElementPtr->turn_wait = MAKE_BYTE (4, 4);
 				NodeElementPtr->preprocess_func = object_animation;
+				
 				if (scan == ENERGY_SCAN)
 				{
-					NodeElementPtr->mass_points = MAX_SCROUNGED;
-					DisplayArray[NodeElementPtr->PrimIndex].Object.Stamp.frame =
-							pSolarSysState->PlanetSideFrame[1];
+					if (pSolarSysState->SysInfo.PlanetInfo.CurType == 1)
+					{
+						NodeElementPtr->mass_points = 0;
+					}
+					else if (pSolarSysState->SysInfo.PlanetInfo.CurType == 2)
+					{
+						// Special case: Fwiffo
+						NodeElementPtr->mass_points = 1;
+					}
+					else
+						NodeElementPtr->mass_points = MAX_SCROUNGED;
+					
+					// JMS: At GenerateHint star system, there can be more than on energy blip graphics on the planet surface simultaneously.
+					if (CurStarDescPtr->Index == HINT_DEFINED)
+					{
+						if (num_nodes % 2)
+							DisplayArray[NodeElementPtr->PrimIndex].Object.Stamp.frame = pSolarSysState->PlanetSideFrame[1];
+						else
+							DisplayArray[NodeElementPtr->PrimIndex].Object.Stamp.frame = pSolarSysState->PlanetSideFrame[2];
+					}
+					// JMS: Elsewhere - there can be only one.
+					else
+						DisplayArray[NodeElementPtr->PrimIndex].Object.Stamp.frame = pSolarSysState->PlanetSideFrame[1];
 				}
 				else /* (scan == BIOLOGICAL_SCAN) */
 				{
-					generateBioNode (pSolarSysState, NodeElementPtr,
-							life_init_tab);
+					generateBioNode (pSolarSysState, NodeElementPtr, life_init_tab);
 				}
 			}
 
-			NodeElementPtr->next.location.x =
-					NodeElementPtr->current.location.x << MAG_SHIFT;
-			NodeElementPtr->next.location.y =
-					NodeElementPtr->current.location.y << MAG_SHIFT;
+			NodeElementPtr->next.location.x = NodeElementPtr->current.location.x << MAG_SHIFT;
+			NodeElementPtr->next.location.y = NodeElementPtr->current.location.y << MAG_SHIFT;
 			UnlockElement (hNodeElement);
 
 			PutElement (hNodeElement);
@@ -1443,22 +1574,6 @@ isNodeRetrieved (PLANET_INFO *planetInfo
 			!= 0;
 }
 
-COUNT
-countNodesRetrieved (PLANET_INFO *planetInfo, BYTE scanType)
-{
-	COUNT count;
-	DWORD mask = planetInfo->ScanRetrieveMask[scanType];
-
-	// count the number of bits set
-	// Caution: 'mask' must be unsigned
-	for (count = 0; mask != 0; mask >>= 1)
-	{
-		if (mask & 1)
-			++count;
-	}
-	return count;
-}
-
 void
 setNodeRetrieved (PLANET_INFO *planetInfo, BYTE scanType, BYTE nodeNr)
 {
diff -ruNp src.orig/uqm/planets/scan.h src/uqm/planets/scan.h
--- src.orig/uqm/planets/scan.h	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/scan.h	2017-11-01 15:31:03 -0700
@@ -45,20 +45,16 @@ struct scan_block
 
 extern void ScanSystem (void);
 
-extern void RepairBackRect (RECT *pRect);
+extern void RepairBackRect (RECT *pRect, BOOLEAN Fullscreen);
 extern void GeneratePlanetSide (void);
-extern COUNT callGenerateForScanType (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT node, BYTE scanType);
-// Returns true if the node should be removed from the surface
-extern bool callPickupForScanType (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT node, BYTE scanType);
+extern bool callGenerateForScanType (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT *node, BYTE scanType);
 
 extern void RedrawSurfaceScan (const POINT *newLoc);
 extern CONTEXT GetScanContext (BOOLEAN *owner);
 extern void DestroyScanContext (void);
 
 bool isNodeRetrieved (PLANET_INFO *planetInfo, BYTE scanType, BYTE nodeNr);
-COUNT countNodesRetrieved (PLANET_INFO *planetInfo, BYTE scanType);
 void setNodeRetrieved (PLANET_INFO *planetInfo, BYTE scanType, BYTE nodeNr);
 void setNodeNotRetrieved (PLANET_INFO *planetInfo, BYTE scanType, BYTE nodeNr);
 
diff -ruNp src.orig/uqm/planets/solarsys.c src/uqm/planets/solarsys.c
--- src.orig/uqm/planets/solarsys.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/solarsys.c	2017-11-01 15:31:03 -0700
@@ -15,8 +15,16 @@
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
+// JMS 2009: -Can intersect with suns in 0 planet star systems (e.g. ORZ space portal)
+//			 -Some other shit related to ORZ space portal / 0 planet star systems
+// JMS 2010: -Different gfx for ORZ space portal/sun in interplanetary
+//			 -Option to add randomness to interplanetary background stars
+//			 -The flag which controls escaping enemies is zeroed now in uninitsolarsys
+
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
 
 #include "lander.h"
+#include "scan.h"
 #include "../colors.h"
 #include "../controls.h"
 #include "../menustat.h"
@@ -47,17 +55,28 @@
 #include "libs/log.h"
 #include "libs/misc.h"
 
+#include <math.h>
 
 //#define DEBUG_SOLARSYS
 //#define SMOOTH_SYSTEM_ZOOM  1
 
 #define IP_FRAME_RATE  (ONE_SECOND / 30)
 
+// BW: those do not depend on the resolution because numbers too small
+// cause crashes in the generation and rendering
+#define GENERATE_PLANET_DIAMETER (29 << 2)
+#define GENERATE_MOON_DIAMETER (7 << 2)
+#define GENERATE_PLANET_PERIMETER (GENERATE_PLANET_DIAMETER * ORIGINAL_MAP_WIDTH / ORIGINAL_MAP_HEIGHT)
+#define GENERATE_MOON_PERIMETER (GENERATE_MOON_DIAMETER * ORIGINAL_MAP_WIDTH / ORIGINAL_MAP_HEIGHT)
+
+static void AnimateSun (SIZE radius); // JMS
 static BOOLEAN DoIpFlight (SOLARSYS_STATE *pSS);
 static void DrawSystem (SIZE radius, BOOLEAN IsInnerSystem);
 static FRAME CreateStarBackGround (void);
 static void DrawInnerSystem (void);
 static void DrawOuterSystem (void);
+static void SetPlanetColorMap (PLANET_DESC *planet); // JMS, BW
+static void ValidateInnerOrbits (void);
 static void ValidateOrbits (void);
 
 // SolarSysMenu() items
@@ -90,7 +109,6 @@ static FRAME StarsFrame;
 		// prepared star-field graphic
 static FRAME SolarSysFrame;
 		// saved solar system view graphic
-
 static RECT scaleRect;
 		// system zooms in when the flagship enters this rect
 
@@ -148,9 +166,14 @@ worldIsMoon (const SOLARSYS_STATE *solar
 COUNT
 planetIndex (const SOLARSYS_STATE *solarSys, const PLANET_DESC *world)
 {
-	const PLANET_DESC *planet = worldIsPlanet (solarSys, world) ?
-			world : world->pPrevDesc;
-	return planet - solarSys->PlanetDesc;
+	// JMS: Don't check index in e.g. Orz space portal system since it'd crash.
+	if (pSolarSysState->SunDesc[0].NumPlanets != 0)
+	{
+		const PLANET_DESC *planet = worldIsPlanet (solarSys, world) ? world : world->pPrevDesc;
+		return planet - solarSys->PlanetDesc;
+	}
+	else
+		return 1;
 }
 
 COUNT
@@ -210,6 +233,50 @@ playerInInnerSystem (void)
 	return pSolarSysState->pBaseDesc != pSolarSysState->PlanetDesc;
 }
 
+void GenerateTexturedMoons (SOLARSYS_STATE *system, PLANET_DESC *planet)
+{
+	COUNT i;
+	PLANET_DESC *pMoonDesc;
+	PLANET_DESC *previousOrbitalDesc;
+	previousOrbitalDesc = pSolarSysState->pOrbitalDesc;
+	
+	for (i = 0, pMoonDesc = &system->MoonDesc[0];
+			i < planet->NumPlanets; ++i, ++pMoonDesc)
+	{		
+		// BW : precompute the generated texture to display it in IP
+		if (!(pMoonDesc->data_index & WORLD_TYPE_SPECIAL))
+		{
+			DoPlanetaryAnalysis (&pSolarSysState->SysInfo, pMoonDesc);
+			if (CurStarDescPtr->Index == SOL_DEFINED)
+				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 0;
+
+			pSolarSysState->pOrbitalDesc = pMoonDesc;
+
+			GeneratePlanetSurfaceForIP (pMoonDesc, NULL, GENERATE_MOON_PERIMETER, GENERATE_MOON_DIAMETER);
+			pMoonDesc->orbit = pSolarSysState->Orbit;
+			PrepareNextRotationFrameForIP (pMoonDesc, 0);
+
+			// Clean up some parasitic use of pSolarSysState
+			LockMutex (GraphicsLock);
+			DestroyDrawable (ReleaseDrawable (pSolarSysState->Orbit.TintFrame));
+			pSolarSysState->Orbit.TintFrame = 0;
+			pSolarSysState->Orbit.TintColor = BLACK_COLOR;
+		
+			DestroyDrawable (ReleaseDrawable (pSolarSysState->Orbit.TopoZoomFrame));
+			pSolarSysState->Orbit.TopoZoomFrame = 0;
+			DestroyStringTable (ReleaseStringTable (pSolarSysState->XlatRef));
+			pSolarSysState->XlatRef = 0;
+			DestroyDrawable (ReleaseDrawable (pSolarSysState->TopoFrame));
+			pSolarSysState->TopoFrame = 0;
+			DestroyColorMap (ReleaseColorMap (pSolarSysState->OrbitalCMap));
+			pSolarSysState->OrbitalCMap = 0;
+			UnlockMutex (GraphicsLock);
+			// End clean up
+		}
+	}
+	pSolarSysState->pOrbitalDesc = previousOrbitalDesc;
+}
+
 static void
 GenerateMoons (SOLARSYS_STATE *system, PLANET_DESC *planet)
 {
@@ -220,11 +287,6 @@ GenerateMoons (SOLARSYS_STATE *system, P
 
 	old_seed = TFB_SeedRandom (planet->rand_seed);
 
-	(*system->genFuncs->generateName) (system, planet);
-	(*system->genFuncs->generateMoons) (system, planet);
-
-	facing = NORMALIZE_FACING (ANGLE_TO_FACING (
-			ARCTAN (planet->location.x, planet->location.y)));
 	for (i = 0, pMoonDesc = &system->MoonDesc[0];
 			i < MAX_MOONS; ++i, ++pMoonDesc)
 	{
@@ -235,6 +297,11 @@ GenerateMoons (SOLARSYS_STATE *system, P
 		pMoonDesc->temp_color = planet->temp_color;
 	}
 
+	(*system->genFuncs->generateName) (system, planet);
+	(*system->genFuncs->generateMoons) (system, planet);
+
+	facing = NORMALIZE_FACING (ANGLE_TO_FACING (
+			ARCTAN (planet->location.x, planet->location.y)));
 	TFB_SeedRandom (old_seed);
 }
 
@@ -259,18 +326,44 @@ FreeIPData (void)
 
 void
 LoadIPData (void)
-{
+{	
+	// JMS: ORZ space portal gfx replaces normal sun gfx. 
+	// Originally there was only the statement within else block and it was within the if (SpaceJunkFrame == 0) block.
+	
+	if (RESOLUTION_FACTOR == 0)
+	{
+		if (CurStarDescPtr->Index==ORZ_SPACE_PORTAL_DEFINED) 
+			SunFrame = CaptureDrawable (LoadGraphic (ORZSPACEPORTAL_MASK_PMAP_ANIM));
+		else
+			SunFrame = CaptureDrawable (LoadGraphic (SUN_MASK_PMAP_ANIM));
+	}
+	// JMS: In hi-res separate animations are used for each star color.
+	else 
+	{
+		if (CurStarDescPtr->Index==ORZ_SPACE_PORTAL_DEFINED) 
+			SunFrame = CaptureDrawable (LoadGraphic (ORZSPACEPORTAL_MASK_PMAP_ANIM));
+		else if (STAR_COLOR(CurStarDescPtr->Type) == BLUE_BODY)
+			SunFrame = CaptureDrawable (LoadGraphic (SUNBLUE_MASK_PMAP_ANIM));
+		else if (STAR_COLOR(CurStarDescPtr->Type) == GREEN_BODY)
+			SunFrame = CaptureDrawable (LoadGraphic (SUNGREEN_MASK_PMAP_ANIM));
+		else if (STAR_COLOR(CurStarDescPtr->Type) == ORANGE_BODY)
+			SunFrame = CaptureDrawable (LoadGraphic (SUNORANGE_MASK_PMAP_ANIM));
+		else if (STAR_COLOR(CurStarDescPtr->Type) == RED_BODY)
+			SunFrame = CaptureDrawable (LoadGraphic (SUNRED_MASK_PMAP_ANIM));
+		else if (STAR_COLOR(CurStarDescPtr->Type)== WHITE_BODY)
+			SunFrame = CaptureDrawable (LoadGraphic (SUNWHITE_MASK_PMAP_ANIM));
+		else if (STAR_COLOR(CurStarDescPtr->Type) == YELLOW_BODY)
+			SunFrame = CaptureDrawable (LoadGraphic (SUNYELLOW_MASK_PMAP_ANIM));
+	}
+	
 	if (SpaceJunkFrame == 0)
 	{
-		SpaceJunkFrame = CaptureDrawable (
-				LoadGraphic (IPBKGND_MASK_PMAP_ANIM));
+		SpaceJunkFrame = CaptureDrawable (LoadGraphic (IPBKGND_MASK_PMAP_ANIM));
 		SISIPFrame = CaptureDrawable (LoadGraphic (SISIP_MASK_PMAP_ANIM));
 
 		OrbitalCMap = CaptureColorMap (LoadColorMap (ORBPLAN_COLOR_MAP));
-		OrbitalFrame = CaptureDrawable (
-				LoadGraphic (ORBPLAN_MASK_PMAP_ANIM));
+		OrbitalFrame = CaptureDrawable (LoadGraphic (ORBPLAN_MASK_PMAP_ANIM));
 		SunCMap = CaptureColorMap (LoadColorMap (IPSUN_COLOR_MAP));
-		SunFrame = CaptureDrawable (LoadGraphic (SUN_MASK_PMAP_ANIM));
 
 		SpaceMusic = LoadMusic (IP_MUSIC);
 	}
@@ -338,8 +431,12 @@ initSolarSysSISCharacteristics (void)
 		if (GLOBAL_SIS (DriveSlots[i]) == FUSION_THRUSTER)
 			++num_thrusters;
 	}
-	pSolarSysState->max_ship_speed = (BYTE)(
-			(num_thrusters + 5) * IP_SHIP_THRUST_INCREMENT);
+	
+	// JMS: Chmmr explorer is not dependent from number of thrusters
+	if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == CHMMR_EXPLORER_SHIP)
+		pSolarSysState->max_ship_speed = (BYTE)(102);
+	else
+		pSolarSysState->max_ship_speed = (BYTE)((num_thrusters + 5) * IP_SHIP_THRUST_INCREMENT);
 
 	pSolarSysState->turn_wait = IP_SHIP_TURN_WAIT;
 	for (i = 0; i < NUM_JET_SLOTS; ++i)
@@ -352,10 +449,97 @@ initSolarSysSISCharacteristics (void)
 static DWORD
 seedRandomForSolarSys (void)
 {
-	return TFB_SeedRandom (MAKE_DWORD (CurStarDescPtr->star_pt.x,
-			CurStarDescPtr->star_pt.y));
+	return TFB_SeedRandom (MAKE_DWORD (CurStarDescPtr->star_pt.x - 5000,
+			CurStarDescPtr->star_pt.y - 6000));
+}
+
+void GenerateTexturedPlanets (void)
+{
+	COUNT i;
+	FRAME SurfFrame;
+	PLANET_DESC *pCurDesc;
+	PLANET_DESC *previousOrbitalDesc;
+	previousOrbitalDesc = pSolarSysState->pOrbitalDesc;
+	
+	for (i = 0, pCurDesc = pSolarSysState->PlanetDesc;
+			i < pSolarSysState->SunDesc[0].NumPlanets; ++i, ++pCurDesc)
+	{
+		SurfFrame = NULL;
+		
+		DoPlanetaryAnalysis (&pSolarSysState->SysInfo, pCurDesc);
+		
+		// BW : precompute the generated texture to display it in IP
+		pSolarSysState->pOrbitalDesc = pCurDesc;
+		if (CurStarDescPtr->Index == SOL_DEFINED)
+		{	// png defined planets in Sol
+			switch (i)
+			{
+			case 0: /* MERCURY */
+				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 3;
+				pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 59 * 240;
+				break;
+			case 1: /* VENUS */
+				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 177;
+				pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 243 * 240;
+				break;
+			case 2: // EARTH
+				SurfFrame = CaptureDrawable (LoadGraphic (EARTH_MASK_ANIM));
+				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 23;
+				pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 240;
+				break;
+			case 3: // MARS
+				SurfFrame = CaptureDrawable (LoadGraphic (MARS_MASK_ANIM));
+				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 24;
+				pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 246;
+				break;
+			case 4: /* JUPITER */
+				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 3;
+				pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 98;
+				break;
+			case 5: /* SATURN */
+				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 27;
+				pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 102;
+				break;
+			case 6: /* URANUS */
+				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 98;
+				pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 172;
+				break;
+			case 7: /* NEPTUNE */
+				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 30;
+				pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 182;
+				break;
+			case 8: /* PLUTO */
+				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 119;
+				pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 1533;
+				break;
+			}
+		}
+		
+		GeneratePlanetSurfaceForIP (pCurDesc, SurfFrame, GENERATE_PLANET_PERIMETER, GENERATE_PLANET_DIAMETER);
+		pCurDesc->orbit = pSolarSysState->Orbit;
+		PrepareNextRotationFrameForIP (pCurDesc, 0);
+		
+		// Clean up some parasitic use of pSolarSysState
+		LockMutex (GraphicsLock);
+		DestroyDrawable (ReleaseDrawable (pSolarSysState->Orbit.TintFrame));
+		pSolarSysState->Orbit.TintFrame = 0;
+		pSolarSysState->Orbit.TintColor = BLACK_COLOR;
+		
+		DestroyDrawable (ReleaseDrawable (pSolarSysState->Orbit.TopoZoomFrame));
+		pSolarSysState->Orbit.TopoZoomFrame = 0;
+		DestroyStringTable (ReleaseStringTable (pSolarSysState->XlatRef));
+		pSolarSysState->XlatRef = 0;
+		DestroyDrawable (ReleaseDrawable (pSolarSysState->TopoFrame));
+		pSolarSysState->TopoFrame = 0;
+		DestroyColorMap (ReleaseColorMap (pSolarSysState->OrbitalCMap));
+		pSolarSysState->OrbitalCMap = 0;
+		UnlockMutex (GraphicsLock);
+		// End clean up
+	}
+	pSolarSysState->pOrbitalDesc = previousOrbitalDesc;
 }
 
+
 // Returns an orbital PLANET_DESC when player is in orbit
 static PLANET_DESC *
 LoadSolarSys (void)
@@ -376,7 +560,11 @@ LoadSolarSys (void)
 
 	old_seed = seedRandomForSolarSys ();
 
-	SunFrame = SetAbsFrameIndex (SunFrame, STAR_TYPE (CurStarDescPtr->Type));
+	// JMS: Animating IP sun in hi-res...
+	if (RESOLUTION_FACTOR == 0)
+		SunFrame = SetAbsFrameIndex (SunFrame, STAR_TYPE (CurStarDescPtr->Type));
+	else
+		SunFrame = SetAbsFrameIndex (SunFrame, (STAR_TYPE (CurStarDescPtr->Type)) * 32);
 
 	pCurDesc = &pSolarSysState->SunDesc[0];
 	pCurDesc->pPrevDesc = 0;
@@ -494,6 +682,9 @@ saveNonOrbitalLocation (void)
 static void
 FreeSolarSys (void)
 {
+	COUNT i, j;
+	PLANET_DESC *pCurDesc;
+
 	if (pSolarSysState->InIpFlight)
 	{
 		pSolarSysState->InIpFlight = FALSE;
@@ -505,9 +696,115 @@ FreeSolarSys (void)
 	DestroyDrawable (ReleaseDrawable (SolarSysFrame));
 	SolarSysFrame = NULL;
 
-	StopMusic ();
+	if (TEXTURED_PLANETS)
+	{
+	// BW: clean up data generated for textured IP planets
+		for (i = 0, pCurDesc = pSolarSysState->PlanetDesc;
+		     i < pSolarSysState->SunDesc[0].NumPlanets; ++i, ++pCurDesc)
+		{
+			PLANET_ORBIT *Orbit = &pCurDesc->orbit;
+			
+			LockMutex (GraphicsLock);
+
+			HFree (Orbit->lpTopoData);
+			Orbit->lpTopoData = 0;
+			DestroyDrawable (ReleaseDrawable (Orbit->SphereFrame));
+			Orbit->SphereFrame = 0;
+
+			DestroyDrawable (ReleaseDrawable (Orbit->ObjectFrame));
+			Orbit->ObjectFrame = 0;
+			DestroyDrawable (ReleaseDrawable (Orbit->WorkFrame));
+			Orbit->WorkFrame = 0;
+			
+			// JMS: Not sure if these do any good...
+			DestroyDrawable (ReleaseDrawable (pSolarSysState->Orbit.TintFrame));
+			pSolarSysState->Orbit.TintFrame = 0;
+			pSolarSysState->Orbit.TintColor = BLACK_COLOR;
+			DestroyDrawable (ReleaseDrawable (pSolarSysState->Orbit.TopoZoomFrame));
+			pSolarSysState->Orbit.TopoZoomFrame = 0;
+			DestroyStringTable (ReleaseStringTable (pSolarSysState->XlatRef));
+			pSolarSysState->XlatRef = 0;
+			DestroyDrawable (ReleaseDrawable (pSolarSysState->TopoFrame));
+			pSolarSysState->TopoFrame = 0;
+			DestroyColorMap (ReleaseColorMap (pSolarSysState->OrbitalCMap));
+			pSolarSysState->OrbitalCMap = 0;
+			// JMS ends.
+
+			HFree (Orbit->TopoColors);
+			Orbit->TopoColors = NULL;
+			HFree (Orbit->ScratchArray);
+			Orbit->ScratchArray = NULL;
+			if (Orbit->map_rotate && Orbit->light_diff)
+			{
+				for (j=0 ; j < GENERATE_PLANET_DIAMETER+1 ; j++)
+				{
+					HFree (Orbit->map_rotate[j]);
+					HFree (Orbit->light_diff[j]);
+				}
+			}
+
+			HFree (Orbit->map_rotate);
+			Orbit->map_rotate = NULL;
+			HFree (Orbit->light_diff);
+			Orbit->light_diff = NULL;
+
+			UnlockMutex (GraphicsLock);
+		}
+
+		// BW: if we were in Inner System, clean up data for textured IP moons
+		if (playerInInnerSystem())
+		{
+			COUNT numMoons;
+			if (worldIsMoon (pSolarSysState, pSolarSysState->pOrbitalDesc))
+				numMoons = pSolarSysState->pOrbitalDesc->pPrevDesc->NumPlanets;
+			else
+				numMoons = pSolarSysState->pOrbitalDesc->NumPlanets;
+
+			for (i = 0, pCurDesc = pSolarSysState->MoonDesc;
+			     i < numMoons; ++i, ++pCurDesc)
+			{
+				if (!(pCurDesc->data_index & WORLD_TYPE_SPECIAL))
+				{
+					PLANET_ORBIT *Orbit = &pCurDesc->orbit;
 
-//    FreeIPData ();
+					LockMutex (GraphicsLock);
+
+					HFree (Orbit->lpTopoData);
+					Orbit->lpTopoData = 0;
+					DestroyDrawable (ReleaseDrawable (Orbit->SphereFrame));
+					Orbit->SphereFrame = NULL;
+
+					DestroyDrawable (ReleaseDrawable (Orbit->ObjectFrame));
+					Orbit->ObjectFrame = 0;
+					DestroyDrawable (ReleaseDrawable (Orbit->WorkFrame));
+					Orbit->WorkFrame = 0;
+
+					HFree (Orbit->TopoColors);
+					Orbit->TopoColors = NULL;
+					HFree (Orbit->ScratchArray);
+					Orbit->ScratchArray = NULL;
+					if (Orbit->map_rotate && Orbit->light_diff)
+					{
+						for (j=0 ; j < GENERATE_MOON_DIAMETER+1 ; j++)
+						{
+							HFree (Orbit->map_rotate[j]);
+							HFree (Orbit->light_diff[j]);
+						}
+					}
+
+					HFree (Orbit->map_rotate);
+					Orbit->map_rotate = NULL;
+					HFree (Orbit->light_diff);
+					Orbit->light_diff = NULL;
+
+					UnlockMutex (GraphicsLock);
+				}
+			}
+		}
+		// End clean up
+	} // #endif TEXTURED_PLANETS
+
+	StopMusic ();
 }
 
 static FRAME
@@ -528,7 +825,7 @@ getCollisionFrame (PLANET_DESC *planet,
 // Returns the planet with which the flagship is colliding
 static PLANET_DESC *
 CheckIntersect (BOOLEAN just_checking)
-{
+{	
 	COUNT i;
 	PLANET_DESC *pCurDesc;
 	INTERSECT_CONTROL ShipIntersect, PlanetIntersect;
@@ -555,9 +852,12 @@ CheckIntersect (BOOLEAN just_checking)
 	// Start with no collisions
 	NewWaitPlanet = 0;
 
-	if (pCurDesc != pSolarSysState->SunDesc /* can't intersect with sun */
-			&& DrawablesIntersect (&ShipIntersect,
-			&PlanetIntersect, MAX_TIME_VALUE))
+	if ( (pCurDesc != pSolarSysState->SunDesc /* JMS: can't intersect with sun... */
+		  && DrawablesIntersect (&ShipIntersect, &PlanetIntersect, MAX_TIME_VALUE)) 
+		  ||									//
+		(pCurDesc == pSolarSysState->SunDesc /* ...except in systems with 0 planets. JMS */
+		 && DrawablesIntersect (&ShipIntersect, &PlanetIntersect, MAX_TIME_VALUE) //
+		 && pSolarSysState->SunDesc[0].NumPlanets == 0) )//
 	{
 #ifdef DEBUG_SOLARSYS
 		log_add (log_Debug, "0: Planet %d, Moon %d", PlanetOffset,
@@ -673,6 +973,19 @@ ValidateOrbit (PLANET_DESC *planet, int
 {
 	COUNT index;
 
+	if (ORBITING_PLANETS)
+	{
+		// BW: recompute planet position to account for orbiting
+		// COUNT newAngle;
+		// newAngle = NORMALIZE_ANGLE(planet->angle + (COUNT)(daysElapsed() * planet->orb_speed));
+		// planet->location.x = COSINE (newAngle, planet->radius);
+		// planet->location.y = SINE (newAngle, planet->radius);
+		double newAngle;
+		newAngle = (planet->angle + daysElapsed() * planet->orb_speed) * M_PI / 32 - M_PI/2 ;
+		planet->location.x = (COORD)(cos(newAngle) * planet->radius);
+		planet->location.y = (COORD)(sin(newAngle) * planet->radius);
+	} // #endif ORBITING_PLANETS
+
 	if (sizeNumer <= DISPLAY_FACTOR)
 	{	// All planets in outer view, and moons in inner
 		RECT r;
@@ -706,7 +1019,9 @@ ValidateOrbit (PLANET_DESC *planet, int
 		}
 		else if (worldIsMoon (pSolarSysState, planet))
 		{
-			Size += 2;
+			Size = 2; // += 2;
+			// BW: Force moons to size 2 to avoid issues with
+			//     Triton (the one and only large rocky moon)
 		}
 		else if (denom <= (MAX_ZOOM_RADIUS >> 2))
 		{
@@ -724,9 +1039,38 @@ ValidateOrbit (PLANET_DESC *planet, int
 			angle = ARCTAN (planet->pPrevDesc->location.x,
 					planet->pPrevDesc->location.y);
 		}
-		planet->image.frame =	SetAbsFrameIndex (OrbitalFrame,
+		if (TEXTURED_PLANETS)
+		{
+			// Those match the sizes of the png planets
+			switch (Size)
+			{
+			case 0: planet->size = 3;
+				break;
+			case 1: planet->size = 4;
+				break;
+			case 2: planet->size = 7;
+				break;
+			case 3: planet->size = 11;
+				break;
+			case 4: planet->size = 15;
+				break;
+			case 5: planet->size = 29;
+				break;
+			}
+		} // #endif TEXTURED_PLANETS
+		// JMS:
+		// Originally there was no if statement and brackets.
+		// This is to make 0 planet star systems work.
+		if(pSolarSysState->SunDesc[0].NumPlanets!=0)
+		{
+			planet->image.frame =	SetAbsFrameIndex (OrbitalFrame,
 				(Size << FACING_SHIFT) + NORMALIZE_FACING (
 				ANGLE_TO_FACING (angle)));
+		}
+		else // JMS: This is the case for 0 planet system
+		{
+			planet->image.frame = SetAbsFrameIndex (SunFrame, (Size << FACING_SHIFT)+2);
+		}
 	}
 	else if (planet->data_index == HIERARCHY_STARBASE)
 	{
@@ -746,7 +1090,10 @@ DrawOrbit (PLANET_DESC *planet, int size
 	GetPlanetOrbitRect (&r, planet, sizeNumer, dyNumer, denom);
 
 	SetContextForeGroundColor (planet->temp_color);
-	DrawOval (&r, 1);
+	if (RESOLUTION_FACTOR < 2)
+		DrawOval (&r, 1, 0);
+	else
+		DrawOval (&r, 3, 1);
 }
 
 static SIZE
@@ -790,13 +1137,17 @@ flagship_inertial_thrust (COUNT CurrentA
 		return (SHIP_AT_MAX_SPEED);
 	else
 	{
-		SIZE delta_x, delta_y;
+		SIZE delta_x, delta_y, ip_increment;
 		DWORD desired_speed;
-
-		delta_x = cur_delta_x
-				+ COSINE (CurrentAngle, IP_SHIP_THRUST_INCREMENT);
-		delta_y = cur_delta_y
-				+ SINE (CurrentAngle, IP_SHIP_THRUST_INCREMENT);
+		
+		// JMS: Explorer accelerates at its own pace.
+		if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == CHMMR_EXPLORER_SHIP)
+			ip_increment = EXPLORER_IP_SHIP_THRUST_INCREMENT;
+		else
+			ip_increment = IP_SHIP_THRUST_INCREMENT;
+			
+		delta_x = cur_delta_x + COSINE (CurrentAngle, ip_increment);
+		delta_y = cur_delta_y + SINE (CurrentAngle, ip_increment);
 		desired_speed = (DWORD) ((long) delta_x * delta_x)
 				+ (DWORD) ((long) delta_y * delta_y);
 		if (desired_speed <= (DWORD) ((UWORD) max_speed * max_speed))
@@ -815,10 +1166,10 @@ flagship_inertial_thrust (COUNT CurrentA
 			v = *VelocityPtr;
 
 			DeltaVelocityComponents (&v,
-					COSINE (CurrentAngle, IP_SHIP_THRUST_INCREMENT >> 1)
-					- COSINE (TravelAngle, IP_SHIP_THRUST_INCREMENT),
-					SINE (CurrentAngle, IP_SHIP_THRUST_INCREMENT >> 1)
-					- SINE (TravelAngle, IP_SHIP_THRUST_INCREMENT));
+					COSINE (CurrentAngle, ip_increment >> 1)
+					- COSINE (TravelAngle, ip_increment),
+					SINE (CurrentAngle, ip_increment >> 1)
+					- SINE (TravelAngle, ip_increment));
 			GetCurrentVelocityComponents (&v, &cur_delta_x, &cur_delta_y);
 			desired_speed =
 					(DWORD) ((long) cur_delta_x * cur_delta_x)
@@ -843,7 +1194,7 @@ ProcessShipControls (void)
 {
 	COUNT index;
 	SIZE delta_x, delta_y;
-
+	
 	if (CurrentInputState.key[PlayerControls[0]][KEY_UP])
 		delta_y = -1;
 	else
@@ -919,6 +1270,8 @@ enterInnerSystem (PLANET_DESC *planet)
 	ZeroVelocityComponents (&GLOBAL (velocity));
 
 	GenerateMoons (pSolarSysState, planet);
+	if (TEXTURED_PLANETS)
+		GenerateTexturedMoons (pSolarSysState, planet);
 	pSolarSysState->pBaseDesc = pSolarSysState->MoonDesc;
 	pSolarSysState->pOrbitalDesc = planet;
 }
@@ -927,17 +1280,70 @@ static void
 leaveInnerSystem (PLANET_DESC *planet)
 {
 	COUNT outerPlanetWait;
+	COUNT i, j;
+	PLANET_DESC *pMoonDesc;
 
 	pSolarSysState->pBaseDesc = pSolarSysState->PlanetDesc;
 	pSolarSysState->pOrbitalDesc = NULL;
 
 	outerPlanetWait = MAKE_WORD (planet - pSolarSysState->PlanetDesc + 1, 0);
+	// BW: planet may have moved while we were into Inner System
+	ValidateOrbit (planet, DISPLAY_FACTOR, DISPLAY_FACTOR / 4,
+		       pSolarSysState->SunDesc[0].radius);
+	pSolarSysState->SunDesc[0].location =
+			planetOuterLocation (planetIndex (pSolarSysState, planet));
 	GLOBAL (ip_location) = pSolarSysState->SunDesc[0].location;
 	XFormIPLoc (&GLOBAL (ip_location), &GLOBAL (ShipStamp.origin), TRUE);
 	ZeroVelocityComponents (&GLOBAL (velocity));
 
 	// Now the ship is in outer system (as per game logic)
 
+	if (TEXTURED_PLANETS)
+	{
+		// BW: clean up data generated for textured IP moons
+		for (i = 0, pMoonDesc = pSolarSysState->MoonDesc;
+		     i < planet->NumPlanets; ++i, ++pMoonDesc)
+		{
+			if (!(pMoonDesc->data_index & WORLD_TYPE_SPECIAL))
+			{
+				PLANET_ORBIT *Orbit = &pMoonDesc->orbit;
+
+				LockMutex (GraphicsLock);
+
+				HFree (Orbit->lpTopoData);
+				Orbit->lpTopoData = 0;
+				DestroyDrawable (ReleaseDrawable (Orbit->SphereFrame));
+				Orbit->SphereFrame = NULL;
+
+				DestroyDrawable (ReleaseDrawable (Orbit->ObjectFrame));
+				Orbit->ObjectFrame = 0;
+				DestroyDrawable (ReleaseDrawable (Orbit->WorkFrame));
+				Orbit->WorkFrame = 0;
+
+				HFree (Orbit->TopoColors);
+				Orbit->TopoColors = NULL;
+				HFree (Orbit->ScratchArray);
+				Orbit->ScratchArray = NULL;
+				if (Orbit->map_rotate && Orbit->light_diff)
+				{
+					for (j=0 ; j < GENERATE_MOON_DIAMETER+1 ; j++)
+					{
+						HFree (Orbit->map_rotate[j]);
+						HFree (Orbit->light_diff[j]);
+					}
+				}
+
+				HFree (Orbit->map_rotate);
+				Orbit->map_rotate = NULL;
+				HFree (Orbit->light_diff);
+				Orbit->light_diff = NULL;
+
+				UnlockMutex (GraphicsLock);
+			}
+		}
+		// End clean up
+	} //#endif TEXTURED_PLANETS
+
 	pSolarSysState->WaitIntersect = outerPlanetWait;
 	// See if we also intersect with another planet, and if we do,
 	// disable collisions comletely until we stop intersecting
@@ -1001,7 +1407,9 @@ CheckShipLocation (SIZE *newRadius)
 		PLANET_DESC *planet = CheckIntersect (FALSE);
 		if (planet)
 		{	// Collision with a planet
-			if (playerInInnerSystem ())
+			// BW: special case, orz portal sends to Orbital
+			// straight from Outer system
+			if (playerInInnerSystem () || (planet == pSolarSysState->SunDesc))
 			{	// Entering planet orbit (scans, etc.)
 				enterOrbital (planet);
 				return FALSE; // no location change
@@ -1052,7 +1460,7 @@ ScaleSystem (SIZE new_radius)
 	//   controls are not handled in the loop, and the flagship
 	//   can collide with a group while zooming, and that is not handled
 	//   100% correctly.
-#define NUM_STEPS 10
+#define NUM_STEPS 30
 	COUNT i;
 	SIZE old_radius;
 	SIZE d, step;
@@ -1114,20 +1522,245 @@ RestoreSystemView (void)
 	DrawStamp (&s);
 }
 
+// JMS: This animates the truespace suns!
+#define SUN_ANIMFRAMES_NUM 32
+static void
+AnimateSun (SIZE radius)
+{
+	PLANET_DESC *pSunDesc = &pSolarSysState->SunDesc[0];
+	PLANET_DESC *pNearestPlanetDesc = &pSolarSysState->PlanetDesc[0];
+	static COUNT sunAnimIndex = 0;
+	COUNT zoomLevelIndex = 0;
+
+	// Advance to the next frame.
+	sunAnimIndex++;
+	
+	// Go back to start of the anim after advancing past the last frame.
+	if (sunAnimIndex % SUN_ANIMFRAMES_NUM == 0)
+		sunAnimIndex = 0;
+	
+	// Zoom according to how close we are to the sun.
+	if (radius <= (MAX_ZOOM_RADIUS >> 1))
+	{
+		zoomLevelIndex += SUN_ANIMFRAMES_NUM;
+		if (radius <= (MAX_ZOOM_RADIUS >> 2))
+			zoomLevelIndex += SUN_ANIMFRAMES_NUM;
+	}
+	
+	// Tell the imageset which frame it should use.
+	pSunDesc->image.frame = SetRelFrameIndex (SunFrame, zoomLevelIndex + sunAnimIndex);
+	
+	// Draw the image.
+	DrawStamp (&pSunDesc->image);
+
+	// BW: temporary workaround, drawing order will have to be redone anyway
+	if (!TEXTURED_PLANETS)
+	{
+		// Re-draw the image of the nearest planet, so the sun won't obscure it.
+		SetPlanetColorMap (pNearestPlanetDesc);
+		DrawStamp (&pNearestPlanetDesc->image);
+	}
+}
+
+static void
+CalcSunSize (PLANET_DESC *pSunDesc, SIZE radius)
+{
+	SIZE index = 0;
+
+	if (radius <= (MAX_ZOOM_RADIUS >> 1))
+	{
+		++index;
+		if (radius <= (MAX_ZOOM_RADIUS >> 2))
+			++index;
+	}
+
+	pSunDesc->image.origin.x = SIS_SCREEN_WIDTH >> 1;
+	pSunDesc->image.origin.y = SIS_SCREEN_HEIGHT >> 1;
+	// JMS: Animating IP sun in hi-res modes...
+	if (RESOLUTION_FACTOR == 0)
+		pSunDesc->image.frame = SetRelFrameIndex (SunFrame, index);
+	else
+		pSunDesc->image.frame = SetRelFrameIndex (SunFrame, index * SUN_ANIMFRAMES_NUM);
+}
+
+static void
+SetPlanetColorMap (PLANET_DESC *planet)
+{
+	COUNT index = planet->data_index & ~WORLD_TYPE_SPECIAL;
+	assert (index < NUMBER_OF_PLANET_TYPES);
+	SetColorMap (GetColorMapAddress (SetAbsColorMapIndex (OrbitalCMap,
+			PLANCOLOR (PlanData[index].Type))));
+}
+
+static void
+DrawTexturedBody (PLANET_DESC* planet, STAMP s)
+{
+	int oldScale;
+	int oldMode;
+
+	//SetContext (SpaceContext);
+	
+	BatchGraphics ();
+	oldMode = SetGraphicScaleMode (TFB_SCALE_BILINEAR);
+	if (worldIsMoon(pSolarSysState, planet))
+		oldScale = SetGraphicScale (GSCALE_IDENTITY * (planet->size << RESOLUTION_FACTOR) / GENERATE_MOON_DIAMETER);
+	else
+		oldScale = SetGraphicScale (GSCALE_IDENTITY * (planet->size << RESOLUTION_FACTOR) / GENERATE_PLANET_DIAMETER);
+	s.frame = planet->orbit.SphereFrame;
+	DrawStamp (&s);
+	if (planet->orbit.ObjectFrame)
+	{
+		s.frame = planet->orbit.ObjectFrame;
+		DrawStamp (&s);
+	}
+	SetGraphicScale (oldScale);
+	SetGraphicScaleMode (oldMode);
+	
+	UnbatchGraphics ();
+}
+
+static void
+DrawInnerPlanets (PLANET_DESC *planet)
+{
+	STAMP s;
+	COUNT i;
+	PLANET_DESC *moon;
+
+	s.origin.x = SIS_SCREEN_WIDTH >> 1;
+	s.origin.y = SIS_SCREEN_HEIGHT >> 1;
+
+	if (TEXTURED_PLANETS)
+	{
+		// Draw the planet image
+		DrawTexturedBody (planet, s);
+		
+		// Draw the moon images
+		for (i = planet->NumPlanets, moon = pSolarSysState->MoonDesc;
+		     i; --i, ++moon)
+		{
+			if (moon->data_index & WORLD_TYPE_SPECIAL)
+				DrawStamp (&moon->image);
+			else
+				DrawTexturedBody(moon, moon->image);
+		}
+	}
+	else /* ! TEXTURED_PLANETS */
+	{
+		// Draw the planet image
+		SetPlanetColorMap (planet);
+		s.frame = planet->image.frame;
+
+		i = planet->data_index & ~WORLD_TYPE_SPECIAL;
+		if (i < NUMBER_OF_PLANET_TYPES
+			&& (planet->data_index & PLANET_SHIELDED))
+		{	// Shielded world looks "shielded" in inner view
+			s.frame = SetAbsFrameIndex (SpaceJunkFrame, 17);
+		}
+		DrawStamp (&s);
+
+		// Draw the moon images
+		for (i = planet->NumPlanets, moon = pSolarSysState->MoonDesc;
+			i; --i, ++moon)
+		{
+			if (!(moon->data_index & WORLD_TYPE_SPECIAL))
+				SetPlanetColorMap (moon);
+			DrawStamp (&moon->image);
+		}
+	} // #endif TEXTURED_PLANETS
+}
+
+static void
+DrawOuterPlanets (SIZE radius)
+{
+	SIZE index;
+	PLANET_DESC *pCurDesc;
+	
+	CalcSunSize (&pSolarSysState->SunDesc[0], radius);
+	
+	index = pSolarSysState->FirstPlanetIndex;
+	for (;;)
+	{
+		pCurDesc = &pSolarSysState->PlanetDesc[index];
+		if (TEXTURED_PLANETS)
+		{
+			if (pCurDesc == &pSolarSysState->SunDesc[0])
+			{	// It's a sun
+				SetColorMap (GetColorMapAddress (SetAbsColorMapIndex (
+					SunCMap, STAR_COLOR (CurStarDescPtr->Type))));
+				DrawStamp (&pCurDesc->image);
+			}
+			else
+			{	// It's a planet
+				DrawTexturedBody(pCurDesc, pCurDesc->image);
+			}
+		}
+		else /* TEXTURED_PLANETS */
+		{
+			if (pCurDesc == &pSolarSysState->SunDesc[0])
+			{	// It's a sun
+				SetColorMap (GetColorMapAddress (SetAbsColorMapIndex (
+					SunCMap, STAR_COLOR (CurStarDescPtr->Type))));
+			}
+			else
+			{	// It's a planet
+				SetPlanetColorMap (pCurDesc);
+			}
+			DrawStamp (&pCurDesc->image);
+		} // #endif TEXTURED_PLANETS
+		
+		if (index == pSolarSysState->LastPlanetIndex)
+			break;
+		index = pCurDesc->NextIndex;
+	}
+}
+
+void RotatePlanets (BOOLEAN IsInnerSystem, SIZE frameCounter)
+{
+	PLANET_DESC *planet;
+	PLANET_DESC *moon;
+	COUNT i;
+
+	// Do not try to rotate planets that haven't been generated yet.
+	if (!pSolarSysState->PlanetDesc->orbit.lpTopoData)
+		return;
+	
+	if (IsInnerSystem)
+	{
+		planet = pSolarSysState->pOrbitalDesc;
+		PrepareNextRotationFrameForIP (planet, frameCounter);
+		for (i = 0; i < planet->NumPlanets; ++i)
+		{
+			moon = &pSolarSysState->MoonDesc[i];
+			if (!(moon->data_index & WORLD_TYPE_SPECIAL))
+				PrepareNextRotationFrameForIP (moon, frameCounter);
+		}
+	}
+	else
+	{
+		for (i = pSolarSysState->SunDesc[0].NumPlanets,
+			     planet = &pSolarSysState->PlanetDesc[0]; i; --i, ++planet)
+			PrepareNextRotationFrameForIP (planet, frameCounter);
+	}
+}
+
 // Normally called by DoIpFlight() to process a frame
 static void
 IP_frame (void)
 {
 	BOOLEAN locChange;
 	SIZE newRadius;
+	static SIZE frameCounter;
 
 	LockMutex (GraphicsLock);
 	SetContext (SpaceContext);
 
 	GameClockTick ();
+	++frameCounter;
 	ProcessShipControls ();
 	
 	locChange = CheckShipLocation (&newRadius);
+	
+	// Transitioning to/from planet or zooming.
 	if (locChange)
 	{
 		if (playerInInnerSystem ())
@@ -1143,10 +1776,54 @@ IP_frame (void)
 			ScaleSystem (newRadius);
 		}
 	}
-	else
+	else if (!pSolarSysState->InOrbit)
 	{	// Just flying around, minding own business..
 		BatchGraphics ();
 		RestoreSystemView ();
+		
+		if (ORBITING_PLANETS)
+		{	// BW: recompute planet position to account for orbiting
+			if (playerInInnerSystem ())
+			{	// Draw the inner system view
+				ValidateInnerOrbits ();
+			}
+			else
+			{	// Draw the outer system view
+				ValidateOrbits ();
+			}
+		}
+
+		if (ROTATING_PLANETS)
+		{
+		// BW: rotate planets
+		// every frame in Inner (not much CPU required)
+		// depending on planet size and speed in Outer
+			if (playerInInnerSystem ())
+			{
+				RotatePlanets (TRUE, frameCounter);
+			}
+			else
+			{
+				RotatePlanets (FALSE, frameCounter);
+			}
+		}
+
+		if (ORBITING_PLANETS || ROTATING_PLANETS)
+		{ // Planets have probably moved or changed
+			if (playerInInnerSystem ())
+			{	// Draw the inner system view
+				DrawInnerPlanets (pSolarSysState->pOrbitalDesc);
+			}
+			else
+			{	// Draw the outer system view
+				DrawOuterPlanets (pSolarSysState->SunDesc[0].radius);
+			}
+		}
+
+		// JMS: Animating IP sun in hi-res modes...
+		if (!playerInInnerSystem () && RESOLUTION_FACTOR != 0)
+			AnimateSun (newRadius);
+		
 		RedrawQueue (FALSE);
 		DrawAutoPilotMessage (FALSE);
 		UnbatchGraphics ();
@@ -1167,8 +1844,8 @@ CheckZoomLevel (void)
 	else
 		shipLoc = GLOBAL (ip_location);
 
-	pSolarSysState->SunDesc[0].radius = FindRadius (shipLoc,
-			MAX_ZOOM_RADIUS << 1);
+	pSolarSysState->SunDesc[0].radius = FindRadius (shipLoc, MAX_ZOOM_RADIUS << 1);
+	
 	if (!InnerSystem)
 	{	// Update ship stamp since the radius probably changed
 		XFormIPLoc (&shipLoc, &GLOBAL (ShipStamp.origin), TRUE);
@@ -1200,8 +1877,7 @@ ValidateInnerOrbits (void)
 	assert (playerInInnerSystem ());
 
 	planet = pSolarSysState->pOrbitalDesc;
-	ValidateOrbit (planet, DISPLAY_FACTOR * 4, DISPLAY_FACTOR,
-			planet->radius);
+	ValidateOrbit (planet, DISPLAY_FACTOR * 4, DISPLAY_FACTOR, planet->radius);
 
 	for (i = 0; i < planet->NumPlanets; ++i)
 	{
@@ -1215,6 +1891,8 @@ DrawInnerSystem (void)
 {
 	ValidateInnerOrbits ();
 	DrawSystem (pSolarSysState->pOrbitalDesc->radius, TRUE);
+	if (ORBITING_PLANETS || ROTATING_PLANETS)
+		DrawInnerPlanets(pSolarSysState->pOrbitalDesc);
 	DrawSISTitle (GLOBAL_SIS (PlanetName));
 }
 
@@ -1223,6 +1901,8 @@ DrawOuterSystem (void)
 {
 	ValidateOrbits ();
 	DrawSystem (pSolarSysState->SunDesc[0].radius, FALSE);
+	if (ORBITING_PLANETS || ROTATING_PLANETS)
+		DrawOuterPlanets(pSolarSysState->SunDesc[0].radius);
 	DrawHyperCoords (CurStarDescPtr->star_pt);
 }
 
@@ -1258,33 +1938,37 @@ ResetSolarSys (void)
 static void
 EnterPlanetOrbit (void)
 {
-	if (pSolarSysState->InIpFlight)
-	{	// This means we hit a planet in IP flight; not a Load into orbit
-		FreeSolarSys ();
+	//	if (pSolarSysState->InIpFlight)
+	//	{	// This means we hit a planet in IP flight; not a Load into orbit
+	// BW: It seems that even a Load generates a solar system...
+	FreeSolarSys ();
 
-		if (worldIsMoon (pSolarSysState, pSolarSysState->pOrbitalDesc))
-		{	// Moon -- use its origin
-			// XXX: The conversion functions do not error-correct, so the
-			//   point we set here will change once flag_ship_preprocess()
-			//   in ipdisp.c starts over again.
-			GLOBAL (ShipStamp.origin) =
-					pSolarSysState->pOrbitalDesc->image.origin;
-		}
-		else
-		{	// Planet -- its origin is for the outer view, so use mid-screen
-			GLOBAL (ShipStamp.origin.x) = SIS_SCREEN_WIDTH >> 1;
-			GLOBAL (ShipStamp.origin.y) = SIS_SCREEN_HEIGHT >> 1;
-		}
+	if (worldIsMoon (pSolarSysState, pSolarSysState->pOrbitalDesc))
+	{	// Moon -- use its origin
+		// XXX: The conversion functions do not error-correct, so the
+		//   point we set here will change once flag_ship_preprocess()
+		//   in ipdisp.c starts over again.
+		GLOBAL (ShipStamp.origin) =
+			pSolarSysState->pOrbitalDesc->image.origin;
 	}
+	else
+	{	// Planet -- its origin is for the outer view, so use mid-screen
+		GLOBAL (ShipStamp.origin.x) = SIS_SCREEN_WIDTH >> 1;
+		GLOBAL (ShipStamp.origin.y) = SIS_SCREEN_HEIGHT >> 1;
+	}
+	//	}
 
 	GetPlanetInfo ();
-	(*pSolarSysState->genFuncs->generateOrbital) (pSolarSysState,
-			pSolarSysState->pOrbitalDesc);
+	(*pSolarSysState->genFuncs->generateOrbital) (pSolarSysState, pSolarSysState->pOrbitalDesc);
 	LastActivity &= ~(CHECK_LOAD | CHECK_RESTART);
-	if ((GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD |
-			START_ENCOUNTER)) || GLOBAL_SIS (CrewEnlisted) == (COUNT)~0
-			|| GET_GAME_STATE (CHMMR_BOMB_STATE) == 2)
-		return;
+	
+	// JMS: Also check for END_INTERPLANETARY which can be set by e.g. the Orz space portal.
+	if ((GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD | START_ENCOUNTER | END_INTERPLANETARY)) 
+		|| GLOBAL_SIS (CrewEnlisted) == (COUNT)~0
+		|| GET_GAME_STATE (CHMMR_BOMB_STATE) == 2)
+		{
+			return;
+		}
 
 	// Implement a to-do in generate.h for a better test
 	if (pSolarSysState->TopoFrame)
@@ -1299,17 +1983,31 @@ EnterPlanetOrbit (void)
 	// Talking Pet, Sun Device or a Caster over Chmmr, or
 	// a Caster for Ilwrath
 	// Could also have blown self up with Utwig Bomb
-	if (!(GLOBAL (CurrentActivity) & (START_ENCOUNTER |
-			CHECK_ABORT | CHECK_LOAD))
+	// JMS: Also check for END_INTERPLANETARY which can be set by e.g. the Orz space portal.
+	if (!(GLOBAL (CurrentActivity) & (START_ENCOUNTER | CHECK_ABORT | CHECK_LOAD | END_INTERPLANETARY))
 			&& GLOBAL_SIS (CrewEnlisted) != (COUNT)~0)
 	{	// Reload the system and return to the inner view
 		PLANET_DESC *orbital = LoadSolarSys ();
 		assert (!orbital);
 		CheckZoomLevel ();
 		ValidateOrbits ();
-		ValidateInnerOrbits ();
+		
+		// JMS: Don't check inner orbits in 0 planet systems e.g. Orz space portal system since it'd crash.
+		if (pSolarSysState->SunDesc[0].NumPlanets != 0)
+			ValidateInnerOrbits ();
+		
 		ResetSolarSys ();
-
+		if (TEXTURED_PLANETS && pSolarSysState->SunDesc[0].NumPlanets != 0)
+		{
+			if (worldIsMoon (pSolarSysState, pSolarSysState->pOrbitalDesc))
+			{
+				GenerateTexturedMoons(pSolarSysState, pSolarSysState->pOrbitalDesc->pPrevDesc);
+			}
+			else
+			{
+				GenerateTexturedMoons(pSolarSysState, pSolarSysState->pOrbitalDesc);
+			}
+		}
 		LockMutex (GraphicsLock);
 		RepairSISBorder ();
 		UnlockMutex (GraphicsLock);
@@ -1337,10 +2035,19 @@ InitSolarSys (void)
 		GLOBAL (autopilot.y) = ~0;
 
 		GLOBAL (ShipStamp.origin.x) = SIS_SCREEN_WIDTH >> 1;
-		GLOBAL (ShipStamp.origin.y) = SIS_SCREEN_HEIGHT - 2;
 		
-		GLOBAL (ip_location) = displayToLocation (GLOBAL (ShipStamp.origin),
-				MAX_ZOOM_RADIUS);
+		// JMS: When exiting Orz space, exit to middle of star
+		if (GET_GAME_STATE(LEAVING_ORZ_SPACE) == 1)
+		{
+			SET_GAME_STATE(LEAVING_ORZ_SPACE, 0);
+			GLOBAL (ShipStamp.origin.y) = SIS_SCREEN_HEIGHT >> 1;
+		}
+		else
+		{
+			GLOBAL (ShipStamp.origin.y) = SIS_SCREEN_HEIGHT - 2;
+		}
+		
+		GLOBAL (ip_location) = displayToLocation (GLOBAL (ShipStamp.origin), MAX_ZOOM_RADIUS);
 	}
 
 	LockMutex (GraphicsLock);
@@ -1408,7 +2115,13 @@ InitSolarSys (void)
 		else
 		{	// Entered a new system, or loaded into inner or outer
 			if (InnerSystem)
+			{
+				if (TEXTURED_PLANETS)
+				{
+					GenerateTexturedMoons(pSolarSysState, pSolarSysState->pOrbitalDesc);
+				}
 				DrawInnerSystem ();
+			}
 			else
 				DrawOuterSystem ();
 			RedrawQueue (FALSE);
@@ -1472,10 +2185,13 @@ static void
 UninitSolarSys (void)
 {
 	FreeSolarSys ();
+	//FreeLanderData (); // JMS: This is not needed since the landerframes won't reload if they're already loaded once.
+	FreeIPData (); // JMS This IS necessary.
 
-//FreeLanderData ();
-//FreeIPData ();
-
+	// JMS: Zero the flag which controls escaping enemies.
+	if(GET_GAME_STATE(ENEMY_ESCAPE_OCCURRED))
+		SET_GAME_STATE (ENEMY_ESCAPE_OCCURRED, 0);
+	
 	DestroyDrawable (ReleaseDrawable (StarsFrame));
 	StarsFrame = NULL;
 
@@ -1502,63 +2218,6 @@ UninitSolarSys (void)
 }
 
 static void
-CalcSunSize (PLANET_DESC *pSunDesc, SIZE radius)
-{
-	SIZE index = 0;
-
-	if (radius <= (MAX_ZOOM_RADIUS >> 1))
-	{
-		++index;
-		if (radius <= (MAX_ZOOM_RADIUS >> 2))
-			++index;
-	}
-
-	pSunDesc->image.origin.x = SIS_SCREEN_WIDTH >> 1;
-	pSunDesc->image.origin.y = SIS_SCREEN_HEIGHT >> 1;
-	pSunDesc->image.frame = SetRelFrameIndex (SunFrame, index);
-}
-
-static void
-SetPlanetColorMap (PLANET_DESC *planet)
-{
-	COUNT index = planet->data_index & ~WORLD_TYPE_SPECIAL;
-	assert (index < NUMBER_OF_PLANET_TYPES);
-	SetColorMap (GetColorMapAddress (SetAbsColorMapIndex (OrbitalCMap,
-			PLANCOLOR (PlanData[index].Type))));
-}
-
-static void
-DrawInnerPlanets (PLANET_DESC *planet)
-{
-	STAMP s;
-	COUNT i;
-	PLANET_DESC *moon;
-
-	// Draw the planet image
-	SetPlanetColorMap (planet);
-	s.origin.x = SIS_SCREEN_WIDTH >> 1;
-	s.origin.y = SIS_SCREEN_HEIGHT >> 1;
-	s.frame = planet->image.frame;
-
-	i = planet->data_index & ~WORLD_TYPE_SPECIAL;
-	if (i < NUMBER_OF_PLANET_TYPES
-			&& (planet->data_index & PLANET_SHIELDED))
-	{	// Shielded world looks "shielded" in inner view
-		s.frame = SetAbsFrameIndex (SpaceJunkFrame, 17);
-	}
-	DrawStamp (&s);
-
-	// Draw the moon images
-	for (i = planet->NumPlanets, moon = pSolarSysState->MoonDesc;
-			i; --i, ++moon)
-	{
-		if (!(moon->data_index & WORLD_TYPE_SPECIAL))
-			SetPlanetColorMap (moon);
-		DrawStamp (&moon->image);
-	}
-}
-
-static void
 DrawSystem (SIZE radius, BOOLEAN IsInnerSystem)
 {
 	BYTE i;
@@ -1567,6 +2226,13 @@ DrawSystem (SIZE radius, BOOLEAN IsInner
 	CONTEXT oldContext;
 	STAMP s;
 
+	if (TEXTURED_PLANETS)
+	{
+		// BW: This to test if we have already rendered 
+		if (!pSolarSysState->PlanetDesc->orbit.lpTopoData)
+			GenerateTexturedPlanets();
+	}
+	
 	if (!SolarSysFrame)
 	{	// Create the saved view graphic
 		RECT clipRect;
@@ -1600,37 +2266,19 @@ DrawSystem (SIZE radius, BOOLEAN IsInner
 					radius);
 	}
 
-	if (IsInnerSystem)
-	{	// Draw the inner system view
-		DrawInnerPlanets (pSolarSysState->pOrbitalDesc);
-	}
-	else
-	{	// Draw the outer system view
-		SIZE index;
-
-		CalcSunSize (&pSolarSysState->SunDesc[0], radius);
-
-		index = pSolarSysState->FirstPlanetIndex;
-		for (;;)
-		{
-			pCurDesc = &pSolarSysState->PlanetDesc[index];
-			if (pCurDesc == &pSolarSysState->SunDesc[0])
-			{	// It's a sun
-				SetColorMap (GetColorMapAddress (SetAbsColorMapIndex (
-						SunCMap, STAR_COLOR (CurStarDescPtr->Type))));
-			}
-			else
-			{	// It's a planet
-				SetPlanetColorMap (pCurDesc);
-			}
-			DrawStamp (&pCurDesc->image);
-
-			if (index == pSolarSysState->LastPlanetIndex)
-				break;
-			index = pCurDesc->NextIndex;
+	if (!ORBITING_PLANETS && !ROTATING_PLANETS)
+	{
+		if (IsInnerSystem)
+		{	// Draw the inner system view
+			DrawInnerPlanets (pSolarSysState->pOrbitalDesc);
+		}
+		else
+		{	// Draw the outer system view
+			DrawOuterPlanets (radius);
 		}
 	}
 
+
 	SetContext (oldContext);
 
 	// Draw the now-saved view graphic
@@ -1656,7 +2304,7 @@ CreateStarBackGround (void)
 {
 	COUNT i, j;
 	DWORD rand_val;
-	STAMP s;
+	STAMP s, nebula;
 	DWORD old_seed;
 	CONTEXT oldContext;
 	RECT clipRect;
@@ -1677,11 +2325,22 @@ CreateStarBackGround (void)
 
 	old_seed = seedRandomForSolarSys ();
 
+	// JMS, BW: The beautiful nebula background.
+	nebula.origin.x = nebula.origin.y = 0;
+#define NUM_NEBULAE 16
+ 	nebula.frame = SetAbsFrameIndex (nebulaeFrame, CurStarDescPtr->star_pt.x % NUM_NEBULAE);
+ 	DrawStamp(&nebula);
+
+	// JMS: You can add randomness to background stars by uncommenting the Global tick_counts
+	// old_seed = TFB_SeedRandom (
+	//		MAKE_DWORD (CurStarDescPtr->star_pt.x - 5000/*+(GLOBAL (GameClock).tick_count)*/,
+	//		CurStarDescPtr->star_pt.y - 6000/*+(GLOBAL (GameClock).tick_count <= 0)*/ ));
+
 #define NUM_DIM_PIECES 8
 	s.frame = SpaceJunkFrame;
 	for (i = 0; i < NUM_DIM_PIECES; ++i)
 	{
-#define NUM_DIM_DRAWN 5
+#define NUM_DIM_DRAWN (5 << RESOLUTION_FACTOR)
 		for (j = 0; j < NUM_DIM_DRAWN; ++j)
 		{
 			rand_val = TFB_Random ();
@@ -1695,7 +2354,7 @@ CreateStarBackGround (void)
 #define NUM_BRT_PIECES 8
 	for (i = 0; i < NUM_BRT_PIECES; ++i)
 	{
-#define NUM_BRT_DRAWN 30
+#define NUM_BRT_DRAWN RES_CASE(30, 60, 90) // JMS_GFX
 		for (j = 0; j < NUM_BRT_DRAWN; ++j)
 		{
 			rand_val = TFB_Random ();
@@ -1728,12 +2387,12 @@ ExploreSolarSys (void)
 {
 	SOLARSYS_STATE SolarSysState;
 	
-	if (CurStarDescPtr == 0)
+	if (CurStarDescPtr == 0 || GET_GAME_STATE (LEAVING_ORZ_SPACE) >= 1) // JMS: Added Leaving Orz space check
 	{
 		POINT universe;
-
 		universe.x = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x));
 		universe.y = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
+		
 		CurStarDescPtr = FindStar (0, &universe, 1, 1);
 		if (!CurStarDescPtr)
 		{
@@ -1741,6 +2400,7 @@ ExploreSolarSys (void)
 			explode ();
 		}
 	}
+	
 	GLOBAL_SIS (log_x) = UNIVERSE_TO_LOGX (CurStarDescPtr->star_pt.x);
 	GLOBAL_SIS (log_y) = UNIVERSE_TO_LOGY (CurStarDescPtr->star_pt.y);
 
@@ -1816,8 +2476,7 @@ GetNamedPlanetaryBody (void)
 	}
 	else if (CurStarDescPtr->Index == SPATHI_DEFINED)
 	{
-		if (matchWorld (pSolarSysState, pSolarSysState->pOrbitalDesc,
-				0, MATCH_PLANET))
+		if (matchWorld (pSolarSysState, pSolarSysState->pOrbitalDesc, 0, MATCH_PLANET))
 		{
 #ifdef NOTYET
 			return "Spathiwa";
diff -ruNp src.orig/uqm/planets/sundata.h src/uqm/planets/sundata.h
--- src.orig/uqm/planets/sundata.h	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/sundata.h	2017-11-01 15:31:03 -0700
@@ -43,9 +43,6 @@ typedef struct
 extern DWORD GenerateMineralDeposits (SYSTEM_INFO *SysInfoPtr,
 		COUNT *pwhich_deposit);
 extern DWORD GenerateLifeForms (SYSTEM_INFO *SysInfoPtr, COUNT *pwhich_life);
-extern void GenerateRandomLocation (SYSTEM_INFO *);
-extern DWORD GenerateRandomNodes (SYSTEM_INFO *, COUNT scan, COUNT numNodes,
-		COUNT type, COUNT *whichNode);
 
 #define DWARF_ELEMENT_DENSITY  1
 #define GIANT_ELEMENT_DENSITY 3
diff -ruNp src.orig/uqm/planets/surface.c src/uqm/planets/surface.c
--- src.orig/uqm/planets/surface.c	2017-11-01 15:30:26 -0700
+++ src/uqm/planets/surface.c	2017-11-01 15:31:03 -0700
@@ -16,6 +16,9 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
+#include "../globdata.h"
 #include "lifeform.h"
 #include "planets.h"
 #include "libs/mathlib.h"
@@ -47,34 +50,60 @@ CalcMineralDeposits (SYSTEM_INFO *SysInf
 		{
 #define MEDIUM_DEPOSIT_THRESHOLD 150
 #define LARGE_DEPOSIT_THRESHOLD 225
+			DWORD rand_val;
+			UWORD loword, hiword;
 			COUNT deposit_quality_fine,
 						deposit_quality_gross;
-
+			
+			// JMS: For making the mineral blip smaller in case it is partially scavenged.
+			SDWORD temp_deposit_quality;
+			
 			deposit_quality_fine = ((COUNT)TFB_Random () % 100)
-					+ (
-					DEPOSIT_QUALITY (eptr->Density)
-					+ SysInfoPtr->StarSize
-					) * 50;
+			  + (
+			     DEPOSIT_QUALITY (eptr->Density)
+			     + SysInfoPtr->StarSize
+			     ) * 50;
+
+			// BW: Check whether we're in the NE quadrant
+			if ((GLOBAL_SIS (log_x) > UNIVERSE_TO_LOGX(5000)) && (GLOBAL_SIS (log_y) < UNIVERSE_TO_LOGY(6000)))
+			  {
+			    deposit_quality_fine = (COUNT)(deposit_quality_fine * DEPLETION_RATE);
+			  }
+			
+			// JMS: This makes the mineral blip smaller in case it is partially scavenged.
+			temp_deposit_quality = deposit_quality_fine - (SysInfoPtr->PlanetInfo.PartiallyScavengedList[MINERAL_SCAN][which_deposit] * 10);
+			if (temp_deposit_quality < 0)
+				temp_deposit_quality = 0;
+			
 			if (deposit_quality_fine < MEDIUM_DEPOSIT_THRESHOLD)
-				deposit_quality_gross = 0;
+			  deposit_quality_gross = 0;
 			else if (deposit_quality_fine < LARGE_DEPOSIT_THRESHOLD)
-				deposit_quality_gross = 1;
+			  deposit_quality_gross = 1;
 			else
-				deposit_quality_gross = 2;
-
-			GenerateRandomLocation (SysInfoPtr);
-
-			SysInfoPtr->PlanetInfo.CurDensity =
-					MAKE_WORD (
-					deposit_quality_gross, deposit_quality_fine / 10 + 1
-					);
+			  deposit_quality_gross = 2;
+			
+			rand_val = TFB_Random ();
+			loword = LOWORD (rand_val);
+			hiword = HIWORD (rand_val);
+			
+			if (RESOLUTION_FACTOR == 0)
+				SysInfoPtr->PlanetInfo.CurPt.x = (LOBYTE (loword) % (MAP_WIDTH - (8 << 1))) + 8;
+			else
+				SysInfoPtr->PlanetInfo.CurPt.x = loword % (MAP_WIDTH - (8 << 1)) + 8; // JMS_GFX: Replaced previous line with this line (BYTE was too small for 640x480 maps.)
+			
+			if (RESOLUTION_FACTOR == 0)
+				SysInfoPtr->PlanetInfo.CurPt.y = (HIBYTE (loword) % (MAP_HEIGHT - (8 << 1))) + 8;
+			else
+				SysInfoPtr->PlanetInfo.CurPt.y = hiword % (MAP_HEIGHT - (8 << 1)) + 8;  // JMS_GFX: Replaced previous line with this line (BYTE was too small for 1280x960 maps.)
+			
+			SysInfoPtr->PlanetInfo.CurDensity = MAKE_WORD (deposit_quality_gross, deposit_quality_fine / 10 + 1);
 			SysInfoPtr->PlanetInfo.CurType = eptr->ElementType;
 #ifdef DEBUG_SURFACE
 			log_add (log_Debug, "\t\t%d units of %Fs",
 					SysInfoPtr->PlanetInfo.CurDensity,
 					Elements[eptr->ElementType].name);
 #endif /* DEBUG_SURFACE */
-			if (num_deposits >= which_deposit
+			if ((num_deposits >= which_deposit && !(SysInfoPtr->PlanetInfo.ScanRetrieveMask[MINERAL_SCAN] & (1L << num_deposits)))
 					|| ++num_deposits == sizeof (DWORD) * 8)
 				goto ExitCalcMinerals;
 		}
@@ -203,19 +232,79 @@ CalcLifeForms (SYSTEM_INFO *SysInfoPtr,
 			num_types = (BYTE)(((BYTE)TFB_Random () % MAX_LIFE_VARIATION) + 1);
 			do
 			{
-				BYTE index, num_creatures;
-				UWORD rand_val;
+				BYTE index, num_creatures, range_types;
+				DWORD rand_val; // JMS_GFX: Was UWORD
+				UWORD loword, hiword;
+				BOOLEAN zoneA, zoneB, zoneC;
 
 				rand_val = (UWORD)TFB_Random ();
-				index = LOBYTE (rand_val) % NUM_CREATURE_TYPES;
-				num_creatures = (BYTE)((HIBYTE (rand_val) % 10) + 1);
+				
+				// BW: Compute which life forms should appear				
+				zoneA = (LOGX_TO_UNIVERSE(GLOBAL_SIS (log_x)) + LOGY_TO_UNIVERSE(GLOBAL_SIS (log_y)) > 9000);
+				zoneB = (LOGX_TO_UNIVERSE(GLOBAL_SIS (log_x)) + 3 * LOGY_TO_UNIVERSE(GLOBAL_SIS (log_y)) < 21000);
+				zoneC = (3 * LOGX_TO_UNIVERSE(GLOBAL_SIS (log_x)) + LOGY_TO_UNIVERSE(GLOBAL_SIS (log_y)) < 19000);
+				
+				range_types = 0;
+				if (zoneA)
+				  range_types += NUM_CREATURE_TYPES;
+				if (zoneB)
+				  range_types += NUM_B_CREATURE_TYPES;
+				if (zoneC)
+				  range_types += NUM_C_CREATURE_TYPES;
+
+				//index = LOBYTE (rand_val) % range_types;
+				index = LOBYTE ((UWORD)rand_val) % range_types; // JMS_GFX
+				
+				// BW: adjust index so that it takes creatures from the correct set.
+				if (!zoneA)
+				  {
+				    index += NUM_CREATURE_TYPES + NUM_SPECIAL_CREATURE_TYPES;
+				    if (!zoneB)
+				      index += NUM_B_CREATURE_TYPES;
+				  }
+				if (zoneA && index >= NUM_CREATURE_TYPES)
+				  {
+				    index += NUM_SPECIAL_CREATURE_TYPES;
+				    if (!zoneB)
+				      index += NUM_B_CREATURE_TYPES;
+				  }
+	
+				// BW: Reduce amounts in the NE quadrant
+				if ((GLOBAL_SIS (log_x) > UNIVERSE_TO_LOGX(5000)) && (GLOBAL_SIS (log_y) < UNIVERSE_TO_LOGY(6000)))
+				  num_creatures = (BYTE)((HIBYTE ((UWORD)rand_val) % 3) + 1);
+				else
+				  num_creatures = (BYTE)((HIBYTE ((UWORD)rand_val) % 10) + 1);
+
 				do
 				{
-					GenerateRandomLocation (SysInfoPtr);
+					rand_val = (DWORD)TFB_Random ();
+					loword = LOWORD (rand_val);
+					hiword = HIWORD (rand_val);
+					
+					/*
+					if (RESOLUTION_FACTOR == 0)
+						SysInfoPtr->PlanetInfo.CurPt.x = (LOBYTE (rand_val) % (MAP_WIDTH - (8 << 1))) + 8;
+					else
+						SysInfoPtr->PlanetInfo.CurPt.x = rand_val % (MAP_WIDTH - (8 << 1)) + 8; // JMS_GFX: Replaced previous line with this line (BYTE was too small for 640x480 maps.)
+					
+					SysInfoPtr->PlanetInfo.CurPt.y = (HIBYTE (rand_val) % (MAP_HEIGHT - (8 << 1))) + 8; // JMS_GFX
+					*/
+					
+					if (RESOLUTION_FACTOR == 0)
+						SysInfoPtr->PlanetInfo.CurPt.x = (LOBYTE ((UWORD)rand_val) % (MAP_WIDTH - (8 << 1))) + 8;
+					else
+						SysInfoPtr->PlanetInfo.CurPt.x = loword % (MAP_WIDTH - (8 << 1)) + 8; // JMS_GFX: Replaced previous line with this line (BYTE was too small for 640x480 maps.)
+					
+					if (RESOLUTION_FACTOR == 0)
+						SysInfoPtr->PlanetInfo.CurPt.y = (HIBYTE ((UWORD)rand_val) % (MAP_HEIGHT - (8 << 1))) + 8;
+					else
+						SysInfoPtr->PlanetInfo.CurPt.y = hiword % (MAP_HEIGHT - (8 << 1)) + 8;  // JMS_GFX: Replaced previous line with this line (BYTE was too small for 1280x960 maps.)
+					
 					SysInfoPtr->PlanetInfo.CurType = index;
 
-					if (num_life_forms >= which_life
-							|| ++num_life_forms == sizeof (DWORD) * 8)
+					if ((num_life_forms >= which_life 
+						&& !(SysInfoPtr->PlanetInfo.ScanRetrieveMask[BIOLOGICAL_SCAN] & (1L << num_life_forms)))
+						|| ++num_life_forms == sizeof (DWORD) * 8)
 					{
 						num_types = 1;
 						break;
@@ -238,46 +327,7 @@ GenerateLifeForms (SYSTEM_INFO *SysInfoP
 {
 	DWORD old_rand;
 
-	old_rand = TFB_SeedRandom (
-			SysInfoPtr->PlanetInfo.ScanSeed[BIOLOGICAL_SCAN]);
+	old_rand = TFB_SeedRandom (SysInfoPtr->PlanetInfo.ScanSeed[BIOLOGICAL_SCAN]);
 	*pwhich_life = CalcLifeForms (SysInfoPtr, *pwhich_life);
 	return (TFB_SeedRandom (old_rand));
 }
-
-void
-GenerateRandomLocation (SYSTEM_INFO *SysInfoPtr)
-{
-	UWORD rand_val;
-
-	rand_val = (UWORD)TFB_Random ();
-	SysInfoPtr->PlanetInfo.CurPt.x =
-			(LOBYTE (rand_val) % (MAP_WIDTH - (8 << 1))) + 8;
-	SysInfoPtr->PlanetInfo.CurPt.y =
-			(HIBYTE (rand_val) % (MAP_HEIGHT - (8 << 1))) + 8;
-}
-
-DWORD
-GenerateRandomNodes (SYSTEM_INFO *SysInfoPtr, COUNT scan, COUNT numNodes,
-		COUNT type, COUNT *whichNode)
-{
-	DWORD old_rand;
-	COUNT i;
-
-	old_rand = TFB_SeedRandom (SysInfoPtr->PlanetInfo.ScanSeed[scan]);
-
-	for (i = 0; i < numNodes; ++i)
-	{
-		GenerateRandomLocation (SysInfoPtr);
-		// CurType is irrelevant for energy nodes
-		SysInfoPtr->PlanetInfo.CurType = type;
-		// CurDensity is irrelevant for energy and bio nodes
-		SysInfoPtr->PlanetInfo.CurDensity = 0;
-
-		if (i >= *whichNode)
-			break;
-	}
-	
-	*whichNode = i; // only matters when count is requested
-
-	return (TFB_SeedRandom (old_rand));
-}
diff -ruNp src.orig/uqm/planets/triangul.c src/uqm/planets/triangul.c
--- src.orig/uqm/planets/triangul.c	1969-12-31 16:00:00 -0800
+++ src/uqm/planets/triangul.c	2017-11-01 15:31:04 -0700
@@ -0,0 +1,189 @@
+// Copyright Jaakko Markus Seppala 2010
+
+#include "libs/strlib.h"
+#include "libs/graphics/gfx_common.h"
+#include "libs/mathlib.h"
+
+#include "../setup.h"
+#include "triangul.h"
+#include "planets.h"
+// for DrawOval
+
+// Shamelessly copied from pstarmap.c and should be updated to reflect
+// any changes on the original
+static inline long
+signedDivWithError (long val, long divisor)
+{
+	int invert = 0;
+	if (val < 0)
+	{
+		invert = 1;
+		val = -val;
+	}
+	val = (val + ROUNDING_ERROR (divisor)) / divisor;
+	return invert ? -val : val;
+}
+
+#define MAP_FIT_X ((MAX_X_UNIVERSE + 1) / SIS_SCREEN_WIDTH + 1)
+
+static inline COORD
+universeToDispx (COORD ux, POINT mapOrigin, int zoomLevel)
+{
+	return signedDivWithError ((((long)ux - mapOrigin.x) << zoomLevel)
+			* SIS_SCREEN_WIDTH, MAX_X_UNIVERSE + MAP_FIT_X)
+			+ ((SIS_SCREEN_WIDTH - 1) >> 1);
+}
+#define UNIVERSE_TO_DISPX(ux, mapOrigin, zoomLevel)  universeToDispx(ux, mapOrigin, zoomLevel)
+
+static inline COORD
+universeToDispy (COORD uy, POINT mapOrigin, int zoomLevel)
+{
+	return signedDivWithError ((((long)mapOrigin.y - uy) << zoomLevel)
+			* SIS_SCREEN_HEIGHT, MAX_Y_UNIVERSE + 2)
+			+ ((SIS_SCREEN_HEIGHT - 1) >> 1);
+}
+#define UNIVERSE_TO_DISPY(uy, mapOrigin, zoomLevel)  universeToDispy(uy, mapOrigin, zoomLevel)
+
+// JMS
+static void
+GetTriangulationSphereRect (COUNT radius, POINT coords, char sphereString[], RECT *pRect, RECT *pRepairRect, POINT mapOrigin, int zoomLevel)
+{
+	long diameter;
+	
+	diameter = (long)(radius * SPHERE_RADIUS_INCREMENT);
+	pRect->extent.width = UNIVERSE_TO_DISPX (diameter, mapOrigin, zoomLevel) - UNIVERSE_TO_DISPX (0, mapOrigin, zoomLevel);
+	if (pRect->extent.width < 0)
+		pRect->extent.width = -pRect->extent.width;
+	else if (pRect->extent.width == 0)
+		pRect->extent.width = 1;
+	pRect->extent.height = UNIVERSE_TO_DISPY (diameter, mapOrigin, zoomLevel) - UNIVERSE_TO_DISPY (0, mapOrigin, zoomLevel);
+	if (pRect->extent.height < 0)
+		pRect->extent.height = -pRect->extent.height;
+	else if (pRect->extent.height == 0)
+		pRect->extent.height = 1;
+	
+	pRect->corner.x = UNIVERSE_TO_DISPX (coords.x, mapOrigin, zoomLevel);
+	pRect->corner.y = UNIVERSE_TO_DISPY (coords.y, mapOrigin, zoomLevel);
+	pRect->corner.x -= pRect->extent.width >> 1;
+	pRect->corner.y -= pRect->extent.height >> 1;
+	
+	{
+		TEXT t;
+		
+		SetContextFont (TinyFont);
+		
+		t.baseline.x = pRect->corner.x + (pRect->extent.width >> 1);
+		t.baseline.y = pRect->corner.y + (pRect->extent.height + (8 * RESOLUTION_FACTOR)) - 1; // JMS_GFX
+		t.align = ALIGN_CENTER;
+		t.CharCount =sizeof(sphereString);
+		t.pStr = (UNICODE *)sphereString;
+		TextRect (&t, pRepairRect, NULL);
+		
+		if (pRepairRect->corner.x <= 0)
+			pRepairRect->corner.x = 1;
+		else if (pRepairRect->corner.x + pRepairRect->extent.width >= SIS_SCREEN_WIDTH)
+			pRepairRect->corner.x = SIS_SCREEN_WIDTH - pRepairRect->extent.width - 1;
+		if (pRepairRect->corner.y <= 0)
+			pRepairRect->corner.y = 1;
+		else if (pRepairRect->corner.y + pRepairRect->extent.height >= SIS_SCREEN_HEIGHT)
+			pRepairRect->corner.y = SIS_SCREEN_HEIGHT - pRepairRect->extent.height - 1;
+		
+		BoxUnion (pRepairRect, pRect, pRepairRect);
+		pRepairRect->extent.width++;
+		pRepairRect->extent.height++;
+	}
+}
+
+// JMS: Draw Triangulation Spheres
+void drawTriangulationSpheres (COUNT which_space, COUNT orz_space, RECT *pClipRect, POINT mapOrigin, int zoomLevel)
+{	
+	if (which_space <= 1 && orz_space <= 1) // JMS: Orz space check
+	{
+		COUNT index;
+		Color c = BUILD_COLOR (MAKE_RGB15 (0x1F, 0x00, 0x00), 0x2D);
+		
+		// JMS: Sphere_statuses, getgamestates defined at triangul.h
+		BYTE sphere_statuses[] =
+		  {
+		    SPHERE_STATUSES
+		  };
+		
+		// JMS: Sphere centre coordinates, defined at triangul.h
+		static const POINT sphere_coords[] =
+		  {
+		    SPHERE_COORDS
+		  };
+
+	        // JMS: Sphere radiuses, defined at triangul.h
+		static const COUNT sphere_radiuses[] =
+		  {
+		    SPHERE_RADIUSES
+		  };
+
+		// JMS: Sphere texts, defined at triangul.h
+		char sphere_strings[][64] =
+		  {
+			  SPHERE_STRINGS
+		  };
+		
+		// JMS: Loop through every sphere
+		for (index = 0; index < sizeof(sphere_statuses) ; ++index)
+		{
+			// JMS: If the sphere is marked visible
+			if (sphere_statuses[index])
+			{
+				RECT r, repair_r;
+				COUNT radius = sphere_radiuses[index];
+				POINT coords = sphere_coords[index];
+
+				GetTriangulationSphereRect (radius, coords, sphere_strings[index], &r, &repair_r, mapOrigin, zoomLevel);
+
+				if (r.corner.x < SIS_SCREEN_WIDTH
+					&& r.corner.y < SIS_SCREEN_HEIGHT
+					&& r.corner.x + r.extent.width > 0
+					&& r.corner.y + r.extent.height > 0
+					&& (pClipRect == 0
+						|| (repair_r.corner.x < pClipRect->corner.x + pClipRect->extent.width
+							&& repair_r.corner.y < pClipRect->corner.y + pClipRect->extent.height
+							&& repair_r.corner.x + repair_r.extent.width > pClipRect->corner.x
+							&& repair_r.corner.y + repair_r.extent.height > pClipRect->corner.y)))
+				{
+					TEXT t;
+
+					SetContextForeGroundColor (c);
+					DrawOval (&r, 1, 0);
+
+					SetContextFont (TinyFont);
+					
+					t.baseline.x = r.corner.x + (r.extent.width >> 1);
+					t.baseline.y = r.corner.y + (r.extent.height + (8 * RESOLUTION_FACTOR)) - 1; // JMS_GFX
+					t.align = ALIGN_CENTER;
+					t.CharCount = sizeof(sphere_strings[index]);
+					t.pStr = (UNICODE *)sphere_strings[index];
+					TextRect (&t, &r, NULL);
+
+					if (r.corner.x <= 0)
+						t.baseline.x -= r.corner.x - 1;
+					else if (r.corner.x + r.extent.width >= SIS_SCREEN_WIDTH)
+						t.baseline.x -= (r.corner.x + r.extent.width) - SIS_SCREEN_WIDTH + 1;
+					if (r.corner.y <= 0)
+						t.baseline.y -= r.corner.y - 1;
+					else if (r.corner.y + r.extent.height >= SIS_SCREEN_HEIGHT)
+						t.baseline.y -= (r.corner.y + r.extent.height)- SIS_SCREEN_HEIGHT + 1;
+					
+					// The text color is slightly lighter than the color of
+					// the SoI.
+					c.r = (c.r >= 0xff - CC5TO8 (0x03)) ?
+							0xff : c.r + CC5TO8 (0x03);
+					c.g = (c.g >= 0xff - CC5TO8 (0x03)) ?
+							0xff : c.g + CC5TO8 (0x03);
+					c.b = (c.b >= 0xff - CC5TO8 (0x03)) ?
+							0xff : c.b + CC5TO8 (0x03);
+
+					SetContextForeGroundColor (c);
+					font_DrawText (&t);
+				}
+			}
+		}
+	}
+}
diff -ruNp src.orig/uqm/planets/triangul.h src/uqm/planets/triangul.h
--- src.orig/uqm/planets/triangul.h	1969-12-31 16:00:00 -0800
+++ src/uqm/planets/triangul.h	2017-11-01 15:31:04 -0700
@@ -0,0 +1,53 @@
+// Copyright Jaakko Markus Seppala 2010
+
+#ifndef _TRIANGUL_H
+#define _TRIANGUL_H
+
+#include "../races.h"
+#include "../globdata.h"
+
+#define TRIANGUL_SPHERE_CHMMR_1_RAD (3060 / SPHERE_RADIUS_INCREMENT * 2)
+#define TRIANGUL_SPHERE_CHMMR_2_RAD (3610 / SPHERE_RADIUS_INCREMENT * 2)
+#define TRIANGUL_SPHERE_SHOFIXTI_RAD (850 / SPHERE_RADIUS_INCREMENT * 2)
+
+#define TRIANGUL_SPHERE_CHMMR_X		(5742)
+#define TRIANGUL_SPHERE_CHMMR_Y		(8628)
+#define TRIANGUL_SPHERE_SHOFIXTI_1_X (3950)
+#define TRIANGUL_SPHERE_SHOFIXTI_1_Y (5850)
+#define TRIANGUL_SPHERE_SHOFIXTI_2_X (6850)
+#define TRIANGUL_SPHERE_SHOFIXTI_2_Y (4400)
+#define TRIANGUL_SPHERE_SHOFIXTI_3_X (9600)
+#define TRIANGUL_SPHERE_SHOFIXTI_3_Y (4000)
+
+#define SPHERE_STATUSES \
+    GET_GAME_STATE(TRIANGULATION_SPHERES_CHMMR),\
+    GET_GAME_STATE(TRIANGULATION_SPHERES_CHMMR), \
+    GET_GAME_STATE(TRIANGULATION_SPHERES_SHOFIXTI), \
+    GET_GAME_STATE(TRIANGULATION_SPHERES_SHOFIXTI), \
+    (GET_GAME_STATE(TRIANGULATION_SPHERES_SHOFIXTI) && !(GET_GAME_STATE(SHOFIXTI_GREAT_NEWS_HEARD))), \
+
+#define SPHERE_COORDS \
+  {TRIANGUL_SPHERE_CHMMR_X, TRIANGUL_SPHERE_CHMMR_Y}, \
+  {TRIANGUL_SPHERE_CHMMR_X, TRIANGUL_SPHERE_CHMMR_Y}, \
+  {TRIANGUL_SPHERE_SHOFIXTI_1_X, TRIANGUL_SPHERE_SHOFIXTI_1_Y}, \
+  {TRIANGUL_SPHERE_SHOFIXTI_2_X, TRIANGUL_SPHERE_SHOFIXTI_2_Y}, \
+  {TRIANGUL_SPHERE_SHOFIXTI_3_X, TRIANGUL_SPHERE_SHOFIXTI_3_Y}, \
+
+#define SPHERE_RADIUSES \
+	TRIANGUL_SPHERE_CHMMR_1_RAD,  	\
+    TRIANGUL_SPHERE_CHMMR_2_RAD, 	\
+    TRIANGUL_SPHERE_SHOFIXTI_RAD,\
+    TRIANGUL_SPHERE_SHOFIXTI_RAD,\
+    TRIANGUL_SPHERE_SHOFIXTI_RAD, \
+
+#define SPHERE_STRINGS	\
+	"Crash site?",	\
+    "", \
+    "Patrol1", \
+    "Patrol2", \
+    "Patrol3", \
+
+void init_triangulation_spheres ();
+void drawTriangulationSpheres (COUNT which_space, COUNT orz_space, RECT *pClipRect, POINT mapOrigin, int zoomLevel);
+
+#endif /* _TRIANGUL_H */
diff -ruNp src.orig/uqm/process.c src/uqm/process.c
--- src.orig/uqm/process.c	2017-11-01 15:30:26 -0700
+++ src/uqm/process.c	2017-11-01 15:31:04 -0700
@@ -16,6 +16,9 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2011: Changed a shitload of POINTs to DPOINTs and SIZEs to SDWORDs to
+// avoid overflows in hi-res.
+
 #include "process.h"
 
 #include "races.h"
@@ -39,7 +42,7 @@
 
 COUNT DisplayFreeList;
 PRIMITIVE DisplayArray[MAX_DISPLAY_PRIMS];
-extern POINT SpaceOrg;
+extern DPOINT SpaceOrg; // JMS: Changed to DPOINT from POINT
 
 SIZE zoom_out = 1 << ZOOM_SHIFT;
 static SIZE opt_max_zoom_out;
@@ -159,13 +162,14 @@ PreProcess (ELEMENT *ElementPtr)
 			if ((state_flags & CHANGING) && CollidingElement (ElementPtr))
 				InitIntersectFrame (ElementPtr);
 		}
-
-		if (!(state_flags & IGNORE_VELOCITY))
+		
+		// JMS: Was originally "if (!(state_flags & IGNORE_VELOCITY)". Added the ugly extra clause to enable moving
+		// Baul gas clouds. This is ugly hack and makes the Baul gas attracted to planet gravity. Oh well...
+		if (!(state_flags & IGNORE_VELOCITY) || ((state_flags & IGNORE_VELOCITY) && (state_flags & GASSY_SUBSTANCE)))
 		{
 			SIZE delta_x, delta_y;
 
-			GetNextVelocityComponents (&ElementPtr->velocity,
-					&delta_x, &delta_y, 1);
+			GetNextVelocityComponents (&ElementPtr->velocity, &delta_x, &delta_y, 1);
 			if (delta_x != 0 || delta_y != 0)
 			{
 				state_flags |= CHANGING;
@@ -181,8 +185,7 @@ PreProcess (ELEMENT *ElementPtr)
 			--ElementPtr->life_span;
 	}
 
-	ElementPtr->state_flags = (state_flags & ~(POST_PROCESS | COLLISION))
-			| PRE_PROCESS;
+	ElementPtr->state_flags = (state_flags & ~(POST_PROCESS | COLLISION)) | PRE_PROCESS;
 }
 
 static void
@@ -203,8 +206,10 @@ PostProcess (ELEMENT *ElementPtr)
 			| POST_PROCESS;
 }
 
+// JMS: Changed a shitload of POINTs to DPOINTs and SIZEs to SDWORDs to
+// avoid overflows in hi-res.
 static COUNT
-CalcReduction (SIZE dx, SIZE dy)
+CalcReduction (SDWORD dx, SDWORD dy)
 {
 	COUNT next_reduction;
 
@@ -214,7 +219,7 @@ CalcReduction (SIZE dx, SIZE dy)
 
 	if (optMeleeScale == TFB_SCALE_STEP)
 	{
-		SIZE sdx, sdy;
+		SDWORD sdx, sdy;
 
 		if (LOBYTE (GLOBAL (CurrentActivity)) > IN_ENCOUNTER)
 			return (0);
@@ -232,8 +237,8 @@ CalcReduction (SIZE dx, SIZE dy)
 		if (next_reduction < zoom_out
 				&& zoom_out <= MAX_VIS_REDUCTION)
 		{
-#define HYSTERESIS_X DISPLAY_TO_WORLD(24)
-#define HYSTERESIS_Y DISPLAY_TO_WORLD(20)
+#define HYSTERESIS_X DISPLAY_TO_WORLD(24 << RESOLUTION_FACTOR) // JMS_GFX
+#define HYSTERESIS_Y DISPLAY_TO_WORLD(20 << RESOLUTION_FACTOR) // JMS_GFX
 		if (((sdx + HYSTERESIS_X)
 				<< (MAX_VIS_REDUCTION - next_reduction)) > TRANSITION_WIDTH
 				|| ((sdy + HYSTERESIS_Y)
@@ -242,8 +247,7 @@ CalcReduction (SIZE dx, SIZE dy)
 		   next_reduction += REDUCTION_SHIFT;
 		}
 
-		if (next_reduction == 0
-				&& LOBYTE (GLOBAL (CurrentActivity)) == IN_LAST_BATTLE)
+		if (next_reduction == 0 && LOBYTE (GLOBAL (CurrentActivity)) == IN_LAST_BATTLE)
 			next_reduction += REDUCTION_SHIFT;
 	}
 	else
@@ -280,26 +284,30 @@ CalcReduction (SIZE dx, SIZE dy)
 	return (next_reduction);
 }
 
+// JMS: Changed a shitload of POINTs to DPOINTs and SIZEs to SDWORDs to
+// avoid overflows in hi-res.
 static VIEW_STATE
-CalcView (POINT *pNewScrollPt, SIZE next_reduction,
-		SIZE *pdx, SIZE *pdy, COUNT ships_alive)
+CalcView (DPOINT *pNewScrollPt, SIZE next_reduction,
+		SDWORD *pdx, SDWORD *pdy, COUNT ships_alive)
 {
-	SIZE dx, dy;
+	SDWORD dx, dy;
 	VIEW_STATE view_state;
 
 #ifdef KDEBUG
 	log_add (log_Debug, "CalcView:");
 #endif
-	dx = ((COORD)(LOG_SPACE_WIDTH >> 1) - pNewScrollPt->x);
-	dy = ((COORD)(LOG_SPACE_HEIGHT >> 1) - pNewScrollPt->y);
+	dx = ((SDWORD)(LOG_SPACE_WIDTH >> 1) - pNewScrollPt->x);
+	dy = ((SDWORD)(LOG_SPACE_HEIGHT >> 1) - pNewScrollPt->y);
 	dx = WRAP_DELTA_X (dx);
 	dy = WRAP_DELTA_Y (dy);
 	if (ships_alive == 1)
 	{
-#define ORG_JUMP_X ((SIZE)DISPLAY_ALIGN(LOG_SPACE_WIDTH / 75))
-#define ORG_JUMP_Y ((SIZE)DISPLAY_ALIGN(LOG_SPACE_HEIGHT / 75))
+#define ORG_JUMP_X ((SDWORD)DISPLAY_ALIGN(LOG_SPACE_WIDTH / 75))
+#define ORG_JUMP_Y ((SDWORD)DISPLAY_ALIGN(LOG_SPACE_HEIGHT / 75))
 		if (dx > ORG_JUMP_X)
+		{
 			dx = ORG_JUMP_X;
+		}
 		else if (dx < -ORG_JUMP_X)
 			dx = -ORG_JUMP_X;
 		if (dy > ORG_JUMP_Y)
@@ -319,12 +327,8 @@ CalcView (POINT *pNewScrollPt, SIZE next
 	{
 		if (optMeleeScale == TFB_SCALE_STEP)
 		{
-			SpaceOrg.x = (COORD)(LOG_SPACE_WIDTH >> 1)
-					- (LOG_SPACE_WIDTH >> ((MAX_REDUCTION + 1)
-					- next_reduction));
-			SpaceOrg.y = (COORD)(LOG_SPACE_HEIGHT >> 1)
-					- (LOG_SPACE_HEIGHT >> ((MAX_REDUCTION + 1)
-					- next_reduction));
+			SpaceOrg.x = (SDWORD)(LOG_SPACE_WIDTH >> 1) - (LOG_SPACE_WIDTH >> ((MAX_REDUCTION + 1) - next_reduction));
+			SpaceOrg.y = (SDWORD)(LOG_SPACE_HEIGHT >> 1) - (LOG_SPACE_HEIGHT >> ((MAX_REDUCTION + 1) - next_reduction));
 		}
 		else
 		{
@@ -337,10 +341,8 @@ CalcView (POINT *pNewScrollPt, SIZE next
 				
 			// Always align the origin on a whole pixel to reduce the
 			// amount of object positioning jitter
-			SpaceOrg.x = DISPLAY_ALIGN((int)(LOG_SPACE_WIDTH >> 1) -
-					(LOG_SPACE_WIDTH * next_reduction / (MAX_ZOOM_OUT << 2)));
-			SpaceOrg.y = DISPLAY_ALIGN((int)(LOG_SPACE_HEIGHT >> 1) -
-					(LOG_SPACE_HEIGHT * next_reduction / (MAX_ZOOM_OUT << 2)));
+			SpaceOrg.x = DISPLAY_ALIGN((int)(LOG_SPACE_WIDTH >> 1) - (LOG_SPACE_WIDTH * next_reduction / (MAX_ZOOM_OUT << 2)));
+			SpaceOrg.y = DISPLAY_ALIGN((int)(LOG_SPACE_HEIGHT >> 1) - (LOG_SPACE_HEIGHT * next_reduction / (MAX_ZOOM_OUT << 2)));
 		}
 		zoom_out = next_reduction;
 		view_state = VIEW_CHANGE;
@@ -358,10 +360,8 @@ CalcView (POINT *pNewScrollPt, SIZE next
 	return (view_state);
 }
 
-
 static ELEMENT_FLAGS
-ProcessCollisions (HELEMENT hSuccElement, ELEMENT *ElementPtr,
-		TIME_VALUE min_time, ELEMENT_FLAGS process_flags)
+ProcessCollisions (HELEMENT hSuccElement, ELEMENT *ElementPtr, TIME_VALUE min_time, ELEMENT_FLAGS process_flags)
 {
 	HELEMENT hTestElement;
 
@@ -372,6 +372,7 @@ ProcessCollisions (HELEMENT hSuccElement
 		LockElement (hTestElement, &TestElementPtr);
 		if (!(TestElementPtr->state_flags & process_flags))
 			PreProcess (TestElementPtr);
+		
 		hSuccElement = GetSuccElement (TestElementPtr);
 
 		if (TestElementPtr == ElementPtr)
@@ -379,9 +380,9 @@ ProcessCollisions (HELEMENT hSuccElement
 			UnlockElement (hTestElement);
 			continue;
 		}
-
+	
 		if (CollisionPossible (TestElementPtr, ElementPtr))
-		{
+		{		
 			ELEMENT_FLAGS state_flags, test_state_flags;
 			TIME_VALUE time_val;
 
@@ -406,24 +407,21 @@ ProcessCollisions (HELEMENT hSuccElement
 					if (state_flags & COLLISION)
 					{
 						InitIntersectEndPoint (TestElementPtr);
-						TestElementPtr->IntersectControl.IntersectStamp.origin =
-								TestElementPtr->IntersectControl.EndPoint;
-						time_val = DrawablesIntersect (&ElementPtr->IntersectControl,
-								&TestElementPtr->IntersectControl, 1);
+						TestElementPtr->IntersectControl.IntersectStamp.origin = TestElementPtr->IntersectControl.EndPoint;
+						time_val = DrawablesIntersect (&ElementPtr->IntersectControl, &TestElementPtr->IntersectControl, 1);
 						InitIntersectStartPoint (TestElementPtr);
 					}
 
 					if (time_val == 1)
 					{
-						FRAME CurFrame, NextFrame,
-								TestCurFrame, TestNextFrame;
+						FRAME CurFrame, NextFrame, TestCurFrame, TestNextFrame;
 
 						CurFrame = ElementPtr->current.image.frame;
 						NextFrame = ElementPtr->next.image.frame;
 						TestCurFrame = TestElementPtr->current.image.frame;
 						TestNextFrame = TestElementPtr->next.image.frame;
-						if (NextFrame == CurFrame
-								&& TestNextFrame == TestCurFrame)
+						
+						if (NextFrame == CurFrame && TestNextFrame == TestCurFrame)
 						{
 							if (test_state_flags & APPEARING)
 							{
@@ -453,24 +451,19 @@ ProcessCollisions (HELEMENT hSuccElement
 						}
 						else
 						{
-							if (GetFrameIndex (CurFrame) !=
-									GetFrameIndex (NextFrame))
-								ElementPtr->next.image.frame =
-										SetEquFrameIndex (NextFrame,
-										CurFrame);
+							if (GetFrameIndex (CurFrame) != GetFrameIndex (NextFrame))
+								ElementPtr->next.image.frame = SetEquFrameIndex (NextFrame, CurFrame);
+							
 							else if (NextFrame != CurFrame)
 							{
-								ElementPtr->next.image =
-										ElementPtr->current.image;
+								ElementPtr->next.image = ElementPtr->current.image;
+								
 								if (ElementPtr->life_span > NORMAL_LIFE)
 									ElementPtr->life_span = NORMAL_LIFE;
 							}
 
-							if (GetFrameIndex (TestCurFrame) !=
-									GetFrameIndex (TestNextFrame))
-								TestElementPtr->next.image.frame =
-										SetEquFrameIndex (TestNextFrame,
-										TestCurFrame);
+							if (GetFrameIndex (TestCurFrame) != GetFrameIndex (TestNextFrame))
+								TestElementPtr->next.image.frame = SetEquFrameIndex (TestNextFrame, TestCurFrame);
 							else if (TestNextFrame != TestCurFrame)
 							{
 								TestElementPtr->next.image =
@@ -487,9 +480,7 @@ ProcessCollisions (HELEMENT hSuccElement
 								STARSHIP *StarShipPtr;
 
 								GetElementStarShip (ElementPtr, &StarShipPtr);
-								StarShipPtr->ShipFacing =
-										GetFrameIndex (
-										ElementPtr->next.image.frame);
+								StarShipPtr->ShipFacing = GetFrameIndex (ElementPtr->next.image.frame);
 							}
 
 							InitIntersectStartPoint (TestElementPtr);
@@ -500,9 +491,7 @@ ProcessCollisions (HELEMENT hSuccElement
 								STARSHIP *StarShipPtr;
 
 								GetElementStarShip (TestElementPtr, &StarShipPtr);
-								StarShipPtr->ShipFacing =
-										GetFrameIndex (
-										TestElementPtr->next.image.frame);
+								StarShipPtr->ShipFacing = GetFrameIndex (TestElementPtr->next.image.frame);
 							}
 						}
 					}
@@ -522,8 +511,7 @@ ProcessCollisions (HELEMENT hSuccElement
 				POINT SavePt, TestSavePt;
 
 #ifdef DEBUG_PROCESS
-				log_add (log_Debug, "0x%x <--> 0x%x at %u", ElementPtr,
-						TestElementPtr, time_val);
+				log_add (log_Debug, "0x%x <--> 0x%x at %u", ElementPtr, TestElementPtr, time_val);
 #endif /* DEBUG_PROCESS */
 				SavePt = ElementPtr->IntersectControl.EndPoint;
 				TestSavePt = TestElementPtr->IntersectControl.EndPoint;
@@ -549,37 +537,22 @@ ProcessCollisions (HELEMENT hSuccElement
 #endif /* DEBUG_PROCESS */
 					if (test_state_flags & PLAYER_SHIP)
 					{
-						(*TestElementPtr->collision_func) (
-								TestElementPtr, &TestSavePt,
-								ElementPtr, &SavePt
-								);
-						(*ElementPtr->collision_func) (
-								ElementPtr, &SavePt,
-								TestElementPtr, &TestSavePt
-								);
+						(*TestElementPtr->collision_func) (TestElementPtr, &TestSavePt,ElementPtr, &SavePt);
+						(*ElementPtr->collision_func) (ElementPtr, &SavePt,TestElementPtr, &TestSavePt);
 					}
 					else
 					{
-						(*ElementPtr->collision_func) (
-								ElementPtr, &SavePt,
-								TestElementPtr, &TestSavePt
-								);
-						(*TestElementPtr->collision_func) (
-								TestElementPtr, &TestSavePt,
-								ElementPtr, &SavePt
-								);
+						(*ElementPtr->collision_func) (ElementPtr, &SavePt,TestElementPtr, &TestSavePt);
+						(*TestElementPtr->collision_func) (TestElementPtr, &TestSavePt,ElementPtr, &SavePt);
 					}
 
 					if (TestElementPtr->state_flags & COLLISION)
 					{
 						if (!(test_state_flags & COLLISION))
 						{
-							TestElementPtr->IntersectControl.IntersectStamp.origin =
-									TestSavePt;
-							TestElementPtr->next.location.x =
-									DISPLAY_TO_WORLD (TestSavePt.x);
-							TestElementPtr->next.location.y =
-									DISPLAY_TO_WORLD (TestSavePt.y);
+							TestElementPtr->IntersectControl.IntersectStamp.origin = TestSavePt;
+							TestElementPtr->next.location.x = DISPLAY_TO_WORLD (TestSavePt.x);
+							TestElementPtr->next.location.y = DISPLAY_TO_WORLD (TestSavePt.y);
 							InitIntersectEndPoint (TestElementPtr);
 						}
 					}
@@ -588,25 +561,20 @@ ProcessCollisions (HELEMENT hSuccElement
 					{
 						if (!(state_flags & COLLISION))
 						{
-							ElementPtr->IntersectControl.IntersectStamp.origin =
-									SavePt;
-							ElementPtr->next.location.x =
-									DISPLAY_TO_WORLD (SavePt.x);
-							ElementPtr->next.location.y =
-									DISPLAY_TO_WORLD (SavePt.y);
+							ElementPtr->IntersectControl.IntersectStamp.origin = SavePt;
+							ElementPtr->next.location.x = DISPLAY_TO_WORLD (SavePt.x);
+							ElementPtr->next.location.y = DISPLAY_TO_WORLD (SavePt.y);
 							InitIntersectEndPoint (ElementPtr);
 
-							if (!(state_flags & FINITE_LIFE) &&
-									!(test_state_flags & FINITE_LIFE))
+							if (!(state_flags & FINITE_LIFE) && !(test_state_flags & FINITE_LIFE))
 							{
 								collide (ElementPtr, TestElementPtr);
 
-								ProcessCollisions (GetHeadElement (), ElementPtr,
-										MAX_TIME_VALUE, process_flags);
-								ProcessCollisions (GetHeadElement (), TestElementPtr,
-										MAX_TIME_VALUE, process_flags);
+								ProcessCollisions (GetHeadElement (), ElementPtr, MAX_TIME_VALUE, process_flags);
+								ProcessCollisions (GetHeadElement (), TestElementPtr, MAX_TIME_VALUE, process_flags);
 							}
 						}
+						
 						UnlockElement (hTestElement);
 						return (COLLISION);
 					}
@@ -627,12 +595,14 @@ ProcessCollisions (HELEMENT hSuccElement
 	return (ElementPtr->state_flags & COLLISION);
 }
 
+// JMS: Changed a shitload of POINTs to DPOINTs and SIZEs to SDWORDs to
+// avoid overflows in hi-res.
 static VIEW_STATE
-PreProcessQueue (SIZE *pscroll_x, SIZE *pscroll_y)
+PreProcessQueue (SDWORD *pscroll_x, SDWORD *pscroll_y)
 {
 	SIZE min_reduction, max_reduction;
 	COUNT sides_active;
-	POINT Origin;
+	DPOINT Origin;
 	HELEMENT hElement;
 	COUNT ships_alive;
 
@@ -647,8 +617,8 @@ PreProcessQueue (SIZE *pscroll_x, SIZE *
 	else
 		min_reduction = max_reduction = MAX_ZOOM_OUT + (1 << ZOOM_SHIFT);
 
-	Origin.x = (COORD)(LOG_SPACE_WIDTH >> 1);
-	Origin.y = (COORD)(LOG_SPACE_HEIGHT >> 1);
+	Origin.x = (SDWORD)(LOG_SPACE_WIDTH >> 1);
+	Origin.y = (SDWORD)(LOG_SPACE_HEIGHT >> 1);
 
 	hElement = GetHeadElement ();
 	ships_alive = 0;
@@ -663,16 +633,15 @@ PreProcessQueue (SIZE *pscroll_x, SIZE *
 			PreProcess (ElementPtr);
 		hNextElement = GetSuccElement (ElementPtr);
 
-		if (CollidingElement (ElementPtr)
-				&& !(ElementPtr->state_flags & COLLISION))
-			ProcessCollisions (hNextElement, ElementPtr,
-					MAX_TIME_VALUE, PRE_PROCESS);
+		if (CollidingElement (ElementPtr) && !(ElementPtr->state_flags & COLLISION))
+			ProcessCollisions (hNextElement, ElementPtr, MAX_TIME_VALUE, PRE_PROCESS);
 
 		if (ElementPtr->state_flags & PLAYER_SHIP)
 		{
-			SIZE dx, dy;
+			SDWORD dx, dy;
 
 			ships_alive++;
+			
 			if (max_reduction > opt_max_zoom_out
 					&& min_reduction > opt_max_zoom_out)
 			{
@@ -722,8 +691,6 @@ PreProcessQueue (SIZE *pscroll_x, SIZE *
 						|| reduction < min_reduction)
 					min_reduction = reduction;
 			}
-//			log_add (log_Debug, "dx = %d dy = %d min_red = %d max_red = %d",
-//					dx, dy, min_reduction, max_reduction);
 		}
 
 		UnlockElement (hElement);
@@ -783,8 +750,10 @@ InsertPrim (PRIM_LINKS *pLinks, COUNT pr
 
 PRIM_LINKS DisplayLinks;
 
-static inline COORD
-CalcDisplayCoord (COORD c, COORD orgc, SIZE reduction)
+// JMS: Changed a shitload of POINTs to DPOINTs and SIZEs to SDWORDs to
+// avoid overflows in hi-res.
+static inline SDWORD
+CalcDisplayCoord (SDWORD c, SDWORD orgc, SIZE reduction)
 {
 	if (optMeleeScale == TFB_SCALE_STEP)
 	{	/* old fixed-step zoom style */
@@ -796,11 +765,12 @@ CalcDisplayCoord (COORD c, COORD orgc, S
 	}
 }
 
+// JMS: Changed a shitload of POINTs to DPOINTs and SIZEs to SDWORDs to
+// avoid overflows in hi-res.
 static void
-PostProcessQueue (VIEW_STATE view_state, SIZE scroll_x,
-		SIZE scroll_y)
+PostProcessQueue (VIEW_STATE view_state, SDWORD scroll_x, SDWORD scroll_y)
 {
-	POINT delta;
+	DPOINT delta;
 	SIZE reduction;
 	HELEMENT hElement;
 
@@ -890,35 +860,28 @@ PostProcessQueue (VIEW_STATE view_state,
 
 				if (ObjType == LINE_PRIM)
 				{
-					SIZE dx, dy;
+					SDWORD dx, dy;
 
-					dx = ElementPtr->next.location.x
-							- ElementPtr->current.location.x;
-					dy = ElementPtr->next.location.y
-							- ElementPtr->current.location.y;
+					dx = ElementPtr->next.location.x - ElementPtr->current.location.x;
+					dy = ElementPtr->next.location.y - ElementPtr->current.location.y;
 
 					next.x = WRAP_X (ElementPtr->current.location.x + delta.x);
 					next.y = WRAP_Y (ElementPtr->current.location.y + delta.y);
-					DisplayArray[ElementPtr->PrimIndex].Object.Line.first.x =
-							CalcDisplayCoord (next.x, SpaceOrg.x, reduction);
-					DisplayArray[ElementPtr->PrimIndex].Object.Line.first.y =
-							CalcDisplayCoord (next.y, SpaceOrg.y, reduction);
+					DisplayArray[ElementPtr->PrimIndex].Object.Line.first.x = CalcDisplayCoord (next.x, SpaceOrg.x, reduction);
+					DisplayArray[ElementPtr->PrimIndex].Object.Line.first.y = CalcDisplayCoord (next.y, SpaceOrg.y, reduction);
 
 					next.x += dx;
 					next.y += dy;
-					DisplayArray[ElementPtr->PrimIndex].Object.Line.second.x =
-							CalcDisplayCoord (next.x, SpaceOrg.x, reduction);
-					DisplayArray[ElementPtr->PrimIndex].Object.Line.second.y =
-							CalcDisplayCoord (next.y, SpaceOrg.y, reduction);
+					DisplayArray[ElementPtr->PrimIndex].Object.Line.second.x = CalcDisplayCoord (next.x, SpaceOrg.x, reduction);
+					DisplayArray[ElementPtr->PrimIndex].Object.Line.second.y = CalcDisplayCoord (next.y, SpaceOrg.y, reduction);
 				}
 				else
 				{
 					next.x = WRAP_X (ElementPtr->next.location.x + delta.x);
 					next.y = WRAP_Y (ElementPtr->next.location.y + delta.y);
-					DisplayArray[ElementPtr->PrimIndex].Object.Point.x =
-							CalcDisplayCoord (next.x, SpaceOrg.x, reduction);
-					DisplayArray[ElementPtr->PrimIndex].Object.Point.y =
-							CalcDisplayCoord (next.y, SpaceOrg.y, reduction);
+					
+					DisplayArray[ElementPtr->PrimIndex].Object.Point.x = CalcDisplayCoord (next.x, SpaceOrg.x, reduction);
+					DisplayArray[ElementPtr->PrimIndex].Object.Point.y = CalcDisplayCoord (next.y, SpaceOrg.y, reduction);
 
 					if (ObjType == STAMP_PRIM || ObjType == STAMPFILL_PRIM)
 					{
@@ -1010,10 +973,12 @@ InitDisplayList (void)
 
 UWORD nth_frame = 0;
 
+// JMS: Changed a shitload of POINTs to DPOINTs and SIZEs to SDWORDs to
+// avoid overflows in hi-res.
 void
 RedrawQueue (BOOLEAN clear)
 {
-	SIZE scroll_x, scroll_y;
+	SDWORD scroll_x, scroll_y;
 	VIEW_STATE view_state;
 
 	SetContext (StatusContext);
diff -ruNp src.orig/uqm/races.h src/uqm/races.h
--- src.orig/uqm/races.h	2017-11-01 15:30:26 -0700
+++ src/uqm/races.h	2017-11-01 15:31:04 -0700
@@ -16,6 +16,19 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2009:- Added Androsynth ship enum 
+//			- Defined Androsynth conversation, Interplanetary and hyperspace encounter percents and encounter ship number limits
+// JMS 2010:- Added ship damage flags to SHIP_INFO structure and the damage definitions
+//			- Added Slylandro_kohrah ship enums, and all the other relevant stuff
+//			- Added Lurg shipenums, and all the other relevant stuff
+//			- Reduced Kohrah and slykohr max taskforce sizes to 2 ships
+//			- Added ISD shipenums, and all the other relevant stuff
+//			- Enable down key in melee (comment tag JMS_KEYS)
+// JMS 2011:- Added Baul & Foon-foon
+
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
+
 #ifndef _RACES_H
 #define _RACES_H
 
@@ -38,19 +51,20 @@ typedef HLINK HSTARSHIP;
 
 /* SHIP_INFO.ship_flags - ship specific flags */
 /* bits 0 and 1 are now available */
-#define SEEKING_WEAPON    (1 << 2)
-#define SEEKING_SPECIAL   (1 << 3)
-#define POINT_DEFENSE     (1 << 4)
+#define SEEKING_WEAPON			(1 << 2)
+#define SEEKING_SPECIAL			(1 << 3)
+#define LIGHT_POINT_DEFENSE     (1 << 4)
+#define HEAVY_POINT_DEFENSE     (1 << 5)
 		/* Ship has some point-defense capabilities */
-#define IMMEDIATE_WEAPON  (1 << 5)
-#define CREW_IMMUNE       (1 << 6)
-#define FIRES_FORE        (1 << 7)
-#define FIRES_RIGHT       (1 << 8)
-#define FIRES_AFT         (1 << 9)
-#define FIRES_LEFT        (1 << 10)
-#define SHIELD_DEFENSE    (1 << 11)
-#define DONT_CHASE        (1 << 12)
-#define PLAYER_CAPTAIN    (1 << 13)
+#define IMMEDIATE_WEAPON		(1 << 6)
+#define CREW_IMMUNE				(1 << 7)
+#define FIRES_FORE				(1 << 8)
+#define FIRES_RIGHT				(1 << 9)
+#define FIRES_AFT				(1 << 10)
+#define FIRES_LEFT				(1 << 12)
+#define SHIELD_DEFENSE			(1 << 13)
+#define DONT_CHASE				(1 << 14)
+#define PLAYER_CAPTAIN			(1 << 15)
 		/* The protagonist himself is on board. He gets a different color. */
 
 typedef UWORD STATUS_FLAGS;
@@ -66,6 +80,20 @@ typedef UWORD STATUS_FLAGS;
 #define SHIP_AT_MAX_SPEED      (1 << 7)
 #define SHIP_IN_GRAVITY_WELL   (1 << 8)
 #define PLAY_VICTORY_DITTY     (1 << 9)
+#define DOWN				   (1 << 10) // JMS_KEYS
+
+// JMS: Damage flags for a ship
+#define SHIP_IS_NOT_DAMAGED		(1 << 0)
+#define DAMAGE_GAUGE_ENERGY		(1 << 1)
+#define DAMAGE_GAUGE_CREW		(1 << 2)
+#define DAMAGE_GAUGE_CAPTAIN	(1 << 3)
+#define DAMAGE_THRUST			(1 << 4)
+#define DAMAGE_TEMP_WEAPON		(1 << 5)
+#define DAMAGE_TEMP_SPECIAL		(1 << 6)
+#define DAMAGE_TEMP_TURN		(1 << 7)
+#define DAMAGE_8				(1 << 8)
+#define DAMAGE_9				(1 << 9)
+
 
 /* These track the old resource package orderings for the ship resource indices */
 typedef enum
@@ -96,10 +124,15 @@ typedef enum
 	ANDROSYNTH_ID,
 	CHENJESU_ID,
 	MMRNMHRM_ID,
-	LAST_MELEE_ID = MMRNMHRM_ID,
-	SIS_SHIP_ID,
+	BAUL_ID,				// JMS
+	FOONFOON_ID,			// JMS
+	LURG_ID,				// JMS
+	ISD_ID,					// JMS
+	SLYLANDRO_KOHRAH_ID,	// JMS
+	SIS_SHIP_ID,			// JMS
+	LAST_MELEE_ID =	SIS_SHIP_ID,// JMS
 	SA_MATRA_ID,
-	UR_QUAN_PROBE_ID,
+	TRANSPORT_ID,			// JMS
 	NUM_SPECIES_ID
 } SPECIES_ID;
 
@@ -118,6 +151,7 @@ typedef enum
 	PURSUE = 0,
 	AVOID,
 	ENTICE,
+	IN_GAS, // JMS
 	NO_MOVEMENT
 } MOVEMENT_STATE;
 
@@ -170,6 +204,10 @@ typedef struct
 	STRING race_strings;
 	FRAME icons;
 	FRAME melee_icon;
+	
+	// JMS: Damage Flags
+	UWORD damage_flags;
+	
 } SHIP_INFO;
 
 typedef struct
@@ -262,13 +300,15 @@ struct STARSHIP
 			// In battle: frames left before primary weapon can be used
 	BYTE special_counter;
 			// In battle: frames left before special can be used
+	BYTE auxiliary_counter;
+			// In battle: frames left before auxiliary can be used
 	BYTE energy_counter;
 			// In battle: frames left before energy regeneration
 
-	BYTE ship_input_state;
+	COUNT ship_input_state; // JMS_KEYS: Was BYTE
 	STATUS_FLAGS cur_status_flags;
 	STATUS_FLAGS old_status_flags;
-
+	
 	HELEMENT hShip;
 	COUNT ShipFacing;
 
@@ -359,10 +399,12 @@ typedef struct
 			 * 0 if there is none and no ships will be generated.
 	         * '(COUNT) ~0' if there is none, and the ship generation
 			 * is handled separately. */
-	COUNT known_strength;
+	SIZE known_strength;
 			/* Measure for the size of the sphere of influence when last
 			 * checked the starmap.
 			 * 0 if the race's SoI is not known. */
+			// JMS: Was COUNT. We need negative numbers to pull of some creative hackery regarding intitial SoI sizes.
+			// -> Negative number if we want to make a small SoI into starmap (which doesn't correspond to the actual SoI's size.
 	POINT known_loc;
 			/* Location of the SoI (center) when last checked
 			 * the starmap. */
@@ -416,12 +458,19 @@ enum
 	UMGAH_SHIP,
 	URQUAN_SHIP,
 	ZOQFOTPIK_SHIP,
-
 	SYREEN_SHIP,
 	BLACK_URQUAN_SHIP,
+	ANDROSYNTH_SHIP,		// JMS: Added this line for Androsynth ship enum.
+	CHENJESU_SHIP,
+	MMRNMHRM_SHIP,
+	BAUL_SHIP,				// JMS
+	FOONFOON_SHIP,			// JMS
+	LURG_SHIP,				// JMS: The fearsome Lurg
+	ISD_SHIP,				// JMS: The mysterious ISD
+	SLYLANDRO_KOHRAH_SHIP,	// JMS: Slylandros flying Kohr-ah vessel	
 	YEHAT_REBEL_SHIP,
-	URQUAN_DRONE_SHIP,
-	SAMATRA_SHIP = URQUAN_DRONE_SHIP,
+	TRANSPORT_SHIP,			// JMS: Transport replaces Ur-Quan probe
+	SAMATRA_SHIP = TRANSPORT_SHIP,
 
 	NUM_AVAILABLE_RACES
 };
@@ -429,7 +478,7 @@ enum
 #define RACE_COMMUNICATION \
 		ARILOU_CONVERSATION,       /* ARILOU_SHIP */ \
 		CHMMR_CONVERSATION,        /* CHMMR_SHIP */ \
-		INVALID_CONVERSATION,      /* HUMAN_SHIP */ \
+		HUMAN_CONVERSATION,		   /* JMS: HUMAN_SHIP */ \
 		ORZ_CONVERSATION,          /* ORZ_SHIP */ \
 		PKUNK_CONVERSATION,        /* PKUNK_SHIP */ \
 		SHOFIXTI_CONVERSATION,     /* SHOFIXTI_SHIP */ \
@@ -447,39 +496,63 @@ enum
 		UMGAH_CONVERSATION,        /* UMGAH_SHIP */ \
 		URQUAN_CONVERSATION,       /* URQUAN_SHIP */ \
 		ZOQFOTPIK_CONVERSATION,    /* ZOQFOTPIK_SHIP */ \
-		INVALID_CONVERSATION,      /* SYREEN_SHIP */ \
+		SYREEN_CONVERSATION,       /* SYREEN_SHIP */ \
 		BLACKURQ_CONVERSATION,     /* BLACK_URQUAN_SHIP */ \
+		ANDROSYNTH_CONVERSATION,   /* JMS: ANDROSYNTH_SHIP */ \
+		INVALID_CONVERSATION,      /* JMS: CHENJESU_SHIP */ \
+		INVALID_CONVERSATION,      /* JMS: MMRNMHRM_SHIP */ \
+		INVALID_CONVERSATION,      /* JMS: BAUL_SHIP */ \
+		INVALID_CONVERSATION,      /* JMS: FOONFOON_SHIP */ \
+		LURG_CONVERSATION,		   /* JMS: LURG_SHIP */ \
+		INVALID_CONVERSATION,      /* JMS: ISD_SHIP */ \
+		SLYLANDRO_HOME_CONVERSATION,/* JMS: SLYLANDRO_KOHRAH_SHIP */ \
 		YEHAT_REBEL_CONVERSATION,  /* YEHAT_REBEL_SHIP */ \
-		URQUAN_DRONE_CONVERSATION, /* URQUAN_DRONE_SHIP */
+		TRANSPORT_CONVERSATION,    /* JMS: TRANSPORT_SHIP */ \
+		SYREENBASE_CONVERSATION,   /* SYREEN_BASE */ \
+		SYREENHOME_CONVERSATION,   /* SYREEN_HOME */ \
+		YEHATPKUNK_CONVERSATION,   /* YEHAT HOME PLANET */ \
+		SHOFIXTICOLONY_CONVERSATION,/* SHOFIXTI COLONY */ \
 
 #define RACE_SHIP_FOR_COMM \
-	ARILOU_SHIP,       /* ARILOU_CONVERSATION */ \
-	CHMMR_SHIP,        /* CHMMR_CONVERSATION */ \
-	HUMAN_SHIP,        /* COMMANDER_CONVERSATION */ \
-	ORZ_SHIP,          /* ORZ_CONVERSATION */ \
-	PKUNK_SHIP,        /* PKUNK_CONVERSATION */ \
-	SHOFIXTI_SHIP,     /* SHOFIXTI_CONVERSATION */ \
-	SPATHI_SHIP,       /* SPATHI_CONVERSATION */ \
-	SUPOX_SHIP,        /* SUPOX_CONVERSATION */ \
-	THRADDASH_SHIP,    /* THRADD_CONVERSATION */ \
-	UTWIG_SHIP,        /* UTWIG_CONVERSATION */ \
-	VUX_SHIP,          /* VUX_CONVERSATION */ \
-	YEHAT_SHIP,        /* YEHAT_CONVERSATION */ \
-	MELNORME_SHIP,     /* MELNORME_CONVERSATION */ \
-	DRUUGE_SHIP,       /* DRUUGE_CONVERSATION */ \
-	ILWRATH_SHIP,      /* ILWRATH_CONVERSATION */ \
-	MYCON_SHIP,        /* MYCON_CONVERSATION */ \
-	SLYLANDRO_SHIP,    /* SLYLANDRO_CONVERSATION */ \
-	UMGAH_SHIP,        /* UMGAH_CONVERSATION */ \
-	URQUAN_SHIP,       /* URQUAN_CONVERSATION */ \
-	ZOQFOTPIK_SHIP,    /* ZOQFOTPIK_CONVERSATION */ \
-	SYREEN_SHIP,       /* SYREEN_CONVERSATION */ \
-	BLACK_URQUAN_SHIP, /* BLACKURQ_CONVERSATION */ \
-	UMGAH_SHIP,        /* TALKING_PET_CONVERSATION */ \
-	SLYLANDRO_SHIP,    /* SLYLANDRO_HOME_CONVERSATION */ \
-	URQUAN_DRONE_SHIP, /* URQUAN_DRONE_CONVERSATION */ \
-	YEHAT_SHIP,        /* YEHAT_REBEL_CONVERSATION */ \
-	HUMAN_SHIP         /* INVALID_CONVERSATION */
+	ARILOU_SHIP,		/* ARILOU_CONVERSATION */ \
+	CHMMR_SHIP,			/* CHMMR_CONVERSATION */ \
+	HUMAN_SHIP,			/* JMS: HUMAN_CONVERSATION */ \
+	ORZ_SHIP,			/* ORZ_CONVERSATION */ \
+	PKUNK_SHIP,			/* PKUNK_CONVERSATION */ \
+	SHOFIXTI_SHIP,		/* SHOFIXTI_CONVERSATION */ \
+	SPATHI_SHIP,		/* SPATHI_CONVERSATION */ \
+	SUPOX_SHIP,			/* SUPOX_CONVERSATION */ \
+	THRADDASH_SHIP,		/* THRADD_CONVERSATION */ \
+	UTWIG_SHIP,			/* UTWIG_CONVERSATION */ \
+	VUX_SHIP,			/* VUX_CONVERSATION */ \
+	YEHAT_SHIP,			/* YEHAT_CONVERSATION */ \
+	MELNORME_SHIP,		/* MELNORME_CONVERSATION */ \
+	DRUUGE_SHIP,		/* DRUUGE_CONVERSATION */ \
+	ILWRATH_SHIP,		/* ILWRATH_CONVERSATION */ \
+	MYCON_SHIP,			/* MYCON_CONVERSATION */ \
+	SLYLANDRO_SHIP,		/* SLYLANDRO_CONVERSATION */ \
+	UMGAH_SHIP,			/* UMGAH_CONVERSATION */ \
+	URQUAN_SHIP,		/* URQUAN_CONVERSATION */ \
+	ZOQFOTPIK_SHIP,		/* ZOQFOTPIK_CONVERSATION */ \
+	SYREEN_SHIP,		/* SYREEN_CONVERSATION */ \
+	BLACK_URQUAN_SHIP,	/* BLACKURQ_CONVERSATION */ \
+	ANDROSYNTH_SHIP,	/* JMS: ANDROSYNTH_CONVERSATION */ \
+	CHENJESU_SHIP,		/* JMS: CHENJESU_CONVERSATION */ \
+	MMRNMHRM_SHIP,		/* JMS: MMRNMHRM_CONVERSATION */ \
+	BAUL_SHIP,			/* JMS: BAUL_CONVERSATION */ \
+	FOONFOON_SHIP,		/* JMS: FOONFOON_CONVERSATION */ \
+	LURG_SHIP,			/* JMS: LURG_CONVERSATION */ \
+	ISD_SHIP,			/* JMS: INVALID_CONVERSATION */ \
+	SLYLANDRO_KOHRAH_SHIP, /* JMS: SLYLANDRO_HOME_CONVERSATION */ \
+	YEHAT_SHIP,         /* YEHAT_REBEL_CONVERSATION */ \
+	HUMAN_SHIP,			/* TRANSPORT_CONVERSATION */ \
+    SYREEN_SHIP,		/* SYREENBASE_CONVERSATION */ \
+    SYREEN_SHIP,		/* SYREENHOME_CONVERSATION */ \
+	YEHAT_SHIP,         /* YEHATPKUNK_CONVERSATION */ \
+	SHOFIXTI_SHIP,		/* SHOFIXTICOLONY_CONVERSATION */ \
+	YEHAT_SHIP,         /* YEHAT_REBEL_CONVERSATION */ \
+	YEHAT_SHIP          /* INVALID_CONVERSATION */
+	
  
 #define RACE_SHIP_COST \
 		1600,  /* ARILOU_SHIP */ \
@@ -504,12 +577,21 @@ enum
 		 600,  /* ZOQFOTPIK_SHIP */ \
 		1300,  /* SYREEN_SHIP */ \
 		3000,  /* BLACK_URQUAN_SHIP */ \
+		1900,  /* JMS: ANDROSYNTH_SHIP*/ \
+		2800,  /* JMS: CHENJESU_SHIP */ \
+		1800,  /* JMS: MMRNMHRM_SHIP */ \
+		2200,  /* JMS: BAUL_SHIP */ \
+		1600,  /* JMS: FOONFOON_SHIP */ \
+		2000,  /* JMS: LURG_SHIP */ \
+		3000,  /* JMS: ISD_SHIP */ \
+		3000,  /* JMS: SLYLANDRO_KOHRAH_SHIP */ \
 		2300,  /* YEHAT_REBEL_SHIP */
+		 
 
 #define LOG_TO_IP(s) ((s) << 1)
 #define RACE_IP_SPEED \
 		LOG_TO_IP (40),  /* ARILOU_SHIP */ \
-		LOG_TO_IP (27),  /* CHMMR_SHIP */ \
+		LOG_TO_IP (30),  /* CHMMR_SHIP */ \
 		LOG_TO_IP (24),  /* HUMAN_SHIP */ \
 		LOG_TO_IP (40),  /* ORZ_SHIP */ \
 		LOG_TO_IP (40),  /* PKUNK_SHIP */ \
@@ -530,97 +612,130 @@ enum
 		LOG_TO_IP (40),  /* ZOQFOTPIK_SHIP */ \
 		LOG_TO_IP (36),  /* SYREEN_SHIP */ \
 		LOG_TO_IP (30),  /* BLACK_URQUAN_SHIP */ \
+		LOG_TO_IP (40),  /* JMS: ANDROSYNTH_SHIP */ \
+		LOG_TO_IP (30),  /* JMS: CHENJESU_SHIP */ \
+		LOG_TO_IP (42),  /* JMS: MMRNMHRM_SHIP */ \
+		LOG_TO_IP (33),  /* JMS: BAUL_SHIP */ \
+		LOG_TO_IP (44),  /* JMS: FOONFOON_SHIP */ \
+		LOG_TO_IP (28),  /* JMS: LURG_SHIP */ \
+		LOG_TO_IP (20),  /* JMS: ISD_SHIP */ \
+		LOG_TO_IP (30),  /* JMS: SLYLANDRO_KOHRAH_SHIP */ \
 		LOG_TO_IP (30),  /* YEHAT_REBEL_SHIP */ \
-		LOG_TO_IP (90),  /* URQUAN_DRONE_SHIP */
+		LOG_TO_IP (24),  /* JMS: TRANSPORT_SHIP */ 
 
 #define LOG_TO_HYPER(s) (WORLD_TO_VELOCITY (s) >> 1)
 #define RACE_HYPER_SPEED \
-		LOG_TO_HYPER (40),  /* ARILOU_SHIP */ \
-		LOG_TO_HYPER (27),  /* CHMMR_SHIP */ \
-		LOG_TO_HYPER (24),  /* HUMAN_SHIP */ \
-		LOG_TO_HYPER (40),  /* ORZ_SHIP */ \
-		LOG_TO_HYPER (40),  /* PKUNK_SHIP */ \
-		LOG_TO_HYPER (35),  /* SHOFIXTI_SHIP */ \
-		LOG_TO_HYPER (48),  /* SPATHI_SHIP */ \
-		LOG_TO_HYPER (40),  /* SUPOX_SHIP */ \
-		LOG_TO_HYPER (50),  /* THRADDASH_SHIP */ \
-		LOG_TO_HYPER (30),  /* UTWIG_SHIP */ \
-		LOG_TO_HYPER (21),  /* VUX_SHIP */ \
-		LOG_TO_HYPER (30),  /* YEHAT_SHIP */ \
-		LOG_TO_HYPER (40),  /* MELNORME_SHIP */ \
-		LOG_TO_HYPER (20),  /* DRUUGE_SHIP */ \
-		LOG_TO_HYPER (25),  /* ILWRATH_SHIP */ \
-		LOG_TO_HYPER (27),  /* MYCON_SHIP */ \
-		LOG_TO_HYPER (60),  /* SLYLANDRO_SHIP */ \
-		LOG_TO_HYPER (18),  /* UMGAH_SHIP */ \
-		LOG_TO_HYPER (30),  /* URQUAN_SHIP */ \
-		LOG_TO_HYPER (40),  /* ZOQFOTPIK_SHIP */ \
-		LOG_TO_HYPER (36),  /* SYREEN_SHIP */ \
-		LOG_TO_HYPER (30),  /* BLACK_URQUAN_SHIP */ \
-		LOG_TO_HYPER (30),  /* YEHAT_REBEL_SHIP */
+		LOG_TO_HYPER (40 << RESOLUTION_FACTOR),  /* ARILOU_SHIP */ \
+		LOG_TO_HYPER (30 << RESOLUTION_FACTOR),  /* CHMMR_SHIP */ \
+		LOG_TO_HYPER (24 << RESOLUTION_FACTOR),  /* HUMAN_SHIP */ \
+		LOG_TO_HYPER (40 << RESOLUTION_FACTOR),  /* ORZ_SHIP */ \
+		LOG_TO_HYPER (40 << RESOLUTION_FACTOR),  /* PKUNK_SHIP */ \
+		LOG_TO_HYPER (35 << RESOLUTION_FACTOR),  /* SHOFIXTI_SHIP */ \
+		LOG_TO_HYPER (48 << RESOLUTION_FACTOR),  /* SPATHI_SHIP */ \
+		LOG_TO_HYPER (40 << RESOLUTION_FACTOR),  /* SUPOX_SHIP */ \
+		LOG_TO_HYPER (50 << RESOLUTION_FACTOR),  /* THRADDASH_SHIP */ \
+		LOG_TO_HYPER (30 << RESOLUTION_FACTOR),  /* UTWIG_SHIP */ \
+		LOG_TO_HYPER (21 << RESOLUTION_FACTOR),  /* VUX_SHIP */ \
+		LOG_TO_HYPER (30 << RESOLUTION_FACTOR),  /* YEHAT_SHIP */ \
+		LOG_TO_HYPER (40 << RESOLUTION_FACTOR),  /* MELNORME_SHIP */ \
+		LOG_TO_HYPER (20 << RESOLUTION_FACTOR),  /* DRUUGE_SHIP */ \
+		LOG_TO_HYPER (25 << RESOLUTION_FACTOR),  /* ILWRATH_SHIP */ \
+		LOG_TO_HYPER (27 << RESOLUTION_FACTOR),  /* MYCON_SHIP */ \
+		LOG_TO_HYPER (60 << RESOLUTION_FACTOR),  /* SLYLANDRO_SHIP */ \
+		LOG_TO_HYPER (18 << RESOLUTION_FACTOR),  /* UMGAH_SHIP */ \
+		LOG_TO_HYPER (30 << RESOLUTION_FACTOR),  /* URQUAN_SHIP */ \
+		LOG_TO_HYPER (40 << RESOLUTION_FACTOR),  /* ZOQFOTPIK_SHIP */ \
+		LOG_TO_HYPER (36 << RESOLUTION_FACTOR),  /* SYREEN_SHIP */ \
+		LOG_TO_HYPER (30 << RESOLUTION_FACTOR),  /* BLACK_URQUAN_SHIP */ \
+		LOG_TO_HYPER (40 << RESOLUTION_FACTOR),  /* JMS: ANDROSYNTH_SHIP */ \
+		LOG_TO_HYPER (30 << RESOLUTION_FACTOR),  /* JMS: CHENJESU_SHIP */ \
+		LOG_TO_HYPER (42 << RESOLUTION_FACTOR),  /* JMS: MMRNMHRM_SHIP */ \
+		LOG_TO_HYPER (33 << RESOLUTION_FACTOR),  /* JMS BAUL_SHIP */ \
+		LOG_TO_HYPER (44 << RESOLUTION_FACTOR),  /* JMS FOONFOON_SHIP */ \
+		LOG_TO_HYPER (28 << RESOLUTION_FACTOR),  /* JMS LURG_SHIP */ \
+		LOG_TO_HYPER (20 << RESOLUTION_FACTOR),  /* JMS ISD_SHIP */ \
+		LOG_TO_HYPER (30 << RESOLUTION_FACTOR),  /* JMS: SLYLANDRO_KOHRAH_SHIP */ \
+		LOG_TO_HYPER (30 << RESOLUTION_FACTOR),  /* YEHAT_REBEL_SHIP */ \
+		LOG_TO_HYPER (24 << RESOLUTION_FACTOR),  /* JMS: TRANSPORT_SHIP */ \
 
 #define RACE_HYPERSPACE_PERCENT \
-		20,  /* ARILOU_SHIP */ \
-		 0,  /* CHMMR_SHIP */ \
-		 0,  /* HUMAN_SHIP */ \
-		20,  /* ORZ_SHIP */ \
-		40,  /* PKUNK_SHIP */ \
-		 0,  /* SHOFIXTI_SHIP */ \
-		20,  /* SPATHI_SHIP */ \
-		40,  /* SUPOX_SHIP */ \
-		60,  /* THRADDASH_SHIP */ \
-		40,  /* UTWIG_SHIP */ \
-		40,  /* VUX_SHIP */ \
-		60,  /* YEHAT_SHIP */ \
-		 0,  /* MELNORME_SHIP */ \
-		30,  /* DRUUGE_SHIP */ \
-		60,  /* ILWRATH_SHIP */ \
-		40,  /* MYCON_SHIP */ \
-		 2,  /* SLYLANDRO_SHIP */ \
-		30,  /* UMGAH_SHIP */ \
-		70,  /* URQUAN_SHIP */ \
-		 0,  /* ZOQFOTPIK_SHIP */ \
-		 0,  /* SYREEN_SHIP */ \
-		70,  /* BLACK_URQUAN_SHIP */ \
-		60,  /* YEHAT_REBEL_SHIP */ \
-		 0,  /* URQUAN_DRONE_SHIP */
+		13, /* ARILOU_SHIP */ \
+		50, /* CHMMR_SHIP */ \
+		30, /* HUMAN_SHIP */ \
+		20, /* ORZ_SHIP */ \
+		40, /* PKUNK_SHIP */ \
+		20, /* SHOFIXTI_SHIP */ \
+		 0, /* SPATHI_SHIP */ \
+		 0, /* SUPOX_SHIP */ \
+		 0, /* THRADDASH_SHIP */ \
+		 0, /* UTWIG_SHIP */ \
+		 0, /* VUX_SHIP */ \
+		45, /* YEHAT_SHIP */ \
+		 0, /* MELNORME_SHIP */ \
+		30, /* DRUUGE_SHIP */ \
+		 0, /* ILWRATH_SHIP */ \
+		40, /* MYCON_SHIP */ \
+		 0, /* SLYLANDRO_SHIP */ \
+		30, /* UMGAH_SHIP */ \
+		 0, /* URQUAN_SHIP */ \
+		 0, /* ZOQFOTPIK_SHIP */ \
+		30, /* SYREEN_SHIP */ \
+		12, /* BLACK_URQUAN_SHIP */ \
+	    20, /* JMS: ANDROSYNTH_SHIP */ \
+		 0, /* JMS: CHENJESU_SHIP */ \
+		20, /* JMS: MMRNMHRM_SHIP */ \
+		25, /* JMS: BAUL_SHIP */ \
+		17, /* JMS: FOONFOON_SHIP */ \
+		45, /* JMS: LURG_SHIP */ \
+		 0, /* JMS: ISD_SHIP */ \
+		12, /* JMS: SLYLANDRO_KOHRAH_SHIP */ \
+		60, /* YEHAT_REBEL_SHIP */ \
+		 0, /* JMS: TRANSPORT_SHIP */
 
 #define RACE_INTERPLANETARY_PERCENT \
-		 0,  /* ARILOU_SHIP */ \
-		 0,  /* CHMMR_SHIP */ \
-		 0,  /* HUMAN_SHIP */ \
-		20,  /* ORZ_SHIP */ \
-		20,  /* PKUNK_SHIP */ \
-		 0,  /* SHOFIXTI_SHIP */ \
-		10,  /* SPATHI_SHIP */ \
-		20,  /* SUPOX_SHIP */ \
-		20,  /* THRADDASH_SHIP */ \
-		20,  /* UTWIG_SHIP */ \
-		20,  /* VUX_SHIP */ \
-		40,  /* YEHAT_SHIP */ \
-		 0,  /* MELNORME_SHIP */ \
-		20,  /* DRUUGE_SHIP */ \
-		60,  /* ILWRATH_SHIP */ \
-		20,  /* MYCON_SHIP */ \
-		 5,  /* SLYLANDRO_SHIP */ \
-		20,  /* UMGAH_SHIP */ \
-		40,  /* URQUAN_SHIP */ \
-		 0,  /* ZOQFOTPIK_SHIP */ \
-		 0,  /* SYREEN_SHIP */ \
-		40,  /* BLACK_URQUAN_SHIP */ \
-		40,  /* YEHAT_REBEL_SHIP */ \
-		 0,  /* URQUAN_DRONE_SHIP */
+		 0, /* ARILOU_SHIP */ \
+		60, /* CHMMR_SHIP */ \
+		30, /* HUMAN_SHIP */ \
+		20, /* ORZ_SHIP */ \
+		20, /* PKUNK_SHIP */ \
+		40, /* SHOFIXTI_SHIP */ \
+		0,  /* SPATHI_SHIP */ \
+		20, /* SUPOX_SHIP */ \
+		20, /* THRADDASH_SHIP */ \
+		20, /* UTWIG_SHIP */ \
+		 0, /* VUX_SHIP */ \
+		40, /* YEHAT_SHIP */ \
+		 0, /* MELNORME_SHIP */ \
+		20, /* DRUUGE_SHIP */ \
+		 0, /* ILWRATH_SHIP */ \
+		20, /* MYCON_SHIP */ \
+		 0, /* SLYLANDRO_SHIP */ \
+		20, /* UMGAH_SHIP */ \
+		 0, /* URQUAN_SHIP */ \
+		 0, /* ZOQFOTPIK_SHIP */ \
+	    20, /* SYREEN_SHIP */ \
+		12, /* BLACK_URQUAN_SHIP */ \
+		50, /* JMS: ANDROSYNTH_SHIP */ \
+		 0, /* JMS: CHENJESU_SHIP */ \
+		30, /* JMS: MMRNMHRM_SHIP */ \
+		35, /* JMS: BAUL_SHIP */ \
+		25, /* JMS: FOONFOON_SHIP */ \
+		45, /* JMS: LURG_SHIP */ \
+		 0, /* JMS: ISD_SHIP */ \
+		12, /* JMS: SLYLANDRO_KOHRAH_SHIP */ \
+		40, /* YEHAT_REBEL_SHIP */ \
+		 0, /* TRANSPORT_SHIP */ \
 
 // How many ships will an encounter consist of.
 // The first number specifies the minimum, the second the maximum.
 // The chance is 50% for each ship past the minimum to be present.
 #define RACE_ENCOUNTER_MAKEUP \
 		MAKE_BYTE (1, 5),  /* ARILOU_SHIP */ \
-		0,                 /* CHMMR_SHIP */ \
-		0,                 /* HUMAN_SHIP */ \
+		MAKE_BYTE (1, 5),  /* CHMMR_SHIP */ \
+		MAKE_BYTE (1, 5),  /* HUMAN_SHIP */ \
 		MAKE_BYTE (1, 5),  /* ORZ_SHIP */ \
 		MAKE_BYTE (1, 5),  /* PKUNK_SHIP */ \
-		0,                 /* SHOFIXTI_SHIP */ \
+		MAKE_BYTE (1, 5),  /* SHOFIXTI_SHIP */ \
 		MAKE_BYTE (1, 5),  /* SPATHI_SHIP */ \
 		MAKE_BYTE (1, 5),  /* SUPOX_SHIP */ \
 		MAKE_BYTE (1, 5),  /* THRADDASH_SHIP */ \
@@ -635,17 +750,26 @@ enum
 		MAKE_BYTE (1, 5),  /* UMGAH_SHIP */ \
 		MAKE_BYTE (1, 5),  /* URQUAN_SHIP */ \
 		MAKE_BYTE (1, 5),  /* ZOQFOTPIK_SHIP */ \
-		0,                 /* SYREEN_SHIP */ \
-		MAKE_BYTE (1, 5),  /* BLACK_URQUAN_SHIP */ \
-		MAKE_BYTE (1, 5),  /* YEHAT_REBEL_SHIP */
+		MAKE_BYTE (1, 5),  /* SYREEN_SHIP */ \
+		MAKE_BYTE (1, 2),  /* JMS: BLACK_URQUAN_SHIP REDUCED TO MAX 2 SHIPS */ \
+		MAKE_BYTE (1, 5),  /* JMS: ANDROSYNTH_SHIP*/ \
+		MAKE_BYTE (1, 5),  /* JMS: CHENJESU_SHIP */\
+		MAKE_BYTE (1, 5),  /* JMS: MMRNMHRM_SHIP */\
+		MAKE_BYTE (1, 5),  /* JMS: BAUL_SHIP */ \
+		MAKE_BYTE (1, 5),  /* JMS: FOONFOON_SHIP */ \
+		MAKE_BYTE (1, 5),  /* JMS: LURG_SHIP */ \
+		MAKE_BYTE (1, 1),  /* JMS: ISD_SHIP */ \
+		MAKE_BYTE (1, 2),  /* JMS: SLYLANDRO_KOHRAH_SHIP REDUCED TO MAX 2 SHIPS */ \
+		MAKE_BYTE (1, 5),  /* YEHAT_REBEL_SHIP */\
+		MAKE_BYTE (1, 1),  /* JMS:TRANSPORT_SHIP */ \
 
 #define RACE_COLORS \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x10), 0x53),  /* ARILOU_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x00), 0x00),  /* CHMMR_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x01, 0x1f), 0x4D),  /* HUMAN_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x0E, 0x00, 0x0E), 0x36),  /* ORZ_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x0F, 0x0F), 0x00),  /* CHMMR_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x01, 0x1F), 0x4D),  /* HUMAN_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x07, 0x09), 0x36),  /* ORZ_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x06, 0x08), 0x62),  /* PKUNK_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x00), 0x00),  /* SHOFIXTI_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x0A, 0x06, 0x00), 0x00),  /* SHOFIXTI_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0C, 0x05, 0x00), 0x76),  /* SPATHI_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0C, 0x05, 0x00), 0x76),  /* SUPOX_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x06, 0x08), 0x62),  /* THRADDASH_SHIP */ \
@@ -660,9 +784,17 @@ enum
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0A, 0x00, 0x11), 0x3D),  /* UMGAH_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x08, 0x00), 0x6E),  /* URQUAN_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x00, 0x00), 0x2D),  /* ZOQFOTPIK_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x00), 0x00),  /* SYREEN_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x1E, 0x09, 0x03), 0x00),  /* SYREEN_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x06, 0x06, 0x06), 0x20),  /* BLACK_URQUAN_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x14, 0x07, 0x1F), 0x39),  /* YEHAT_REBEL_SHIP */
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x1F, 0x00), 0x4D),  /* ANDROSYNTH_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x2A, 0x2A, 0x2A), 0x39),  /* JMS: CHENJESU_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x1F, 0x1F, 0x00), 0x4D),  /* JMS: MMRNMHRM_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x07, 0x00, 0x01), 0x4D),  /* JMS: BAUL_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x0A, 0x00, 0x09), 0x4D),  /* JMS: FOONFOON_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x1B, 0x02), 0x4D),  /* JMS: LURG_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x1B, 0x02), 0x4D),  /* JMS: ISD_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x02, 0x02, 0x02), 0x39),  /* JMS: SLYLANDRO_KOHRAH_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x2A, 0x00, 0x00), 0x39),  /* YEHAT_REBEL_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x03, 0x1F), 0x39),  /* JMS:TRANSPORT_SHIP */ \
 
 #endif /* _RACES_H */
-
diff -ruNp src.orig/uqm/respkg.h src/uqm/respkg.h
--- src.orig/uqm/respkg.h	1969-12-31 16:00:00 -0800
+++ src/uqm/respkg.h	2017-11-01 15:31:04 -0700
@@ -0,0 +1,338 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+enum
+{
+	INIT_PACKAGE = 1,
+	TITLE_PACKAGE,
+	ARILOU_SHIP_PACKAGE,
+	CHMMR_SHIP_PACKAGE,
+	EARTHLING_SHIP_PACKAGE,
+	ORZ_SHIP_PACKAGE,
+	PKUNK_SHIP_PACKAGE,
+	SHOFIXTI_SHIP_PACKAGE,
+	SPATHI_SHIP_PACKAGE,
+	SUPOX_SHIP_PACKAGE,
+	THRADD_SHIP_PACKAGE,
+	UTWIG_SHIP_PACKAGE,
+	VUX_SHIP_PACKAGE,
+	YEHAT_SHIP_PACKAGE,
+	MELNORME_SHIP_PACKAGE,
+	DRUUGE_SHIP_PACKAGE,
+	ILWRATH_SHIP_PACKAGE,
+	MYCON_SHIP_PACKAGE,
+	SLYLANDRO_SHIP_PACKAGE,
+	UMGAH_SHIP_PACKAGE,
+	URQUAN_SHIP_PACKAGE,
+	ZOQFOTPIK_SHIP_PACKAGE,
+	SLAVERACE_SHIP_PACKAGE,
+	SYREEN_SHIP_PACKAGE,
+	BLACKURQ_SHIP_PACKAGE,
+	ANDROSYN_SHIP_PACKAGE,
+	CHENJESU_SHIP_PACKAGE,
+	MMRNMHRM_SHIP_PACKAGE,
+	KERNEL_PACKAGE,
+	SC2KERNEL_PACKAGE,
+	MICROFONT_PACKAGE,
+	SC2DATA_PACKAGE,
+	MENU_SOUND_PACKAGE,
+	SOUND_PACKAGE,
+	SPACE_PACKAGE,
+	AMBIENT_HYPER_PACKAGE,
+	HYPER_PACKAGE,
+	ARISPACE_PACKAGE,
+	HYPERSPACE_MUSIC_PACKAGE,
+	QUASISPACE_MUSIC_PACKAGE,
+	INIT_PACKAGE,
+	IP_PACKAGE,
+	LANDER_PACKAGE,
+	ORBIT_VIEW_PACKAGE,
+	EARTH_PACKAGE,
+	CANNISTER_PACKAGE,
+	LIFE00_PACKAGE,
+	LIFE01_PACKAGE,
+	LIFE02_PACKAGE,
+	LIFE03_PACKAGE,
+	LIFE04_PACKAGE,
+	LIFE05_PACKAGE,
+	LIFE06_PACKAGE,
+	LIFE07_PACKAGE,
+	LIFE08_PACKAGE,
+	LIFE09_PACKAGE,
+	LIFE10_PACKAGE,
+	LIFE11_PACKAGE,
+	LIFE12_PACKAGE,
+	LIFE13_PACKAGE,
+	LIFE14_PACKAGE,
+	LIFE15_PACKAGE,
+	LIFE16_PACKAGE,
+	LIFE17_PACKAGE,
+	LIFE18_PACKAGE,
+	LIFE19_PACKAGE,
+	LIFE20_PACKAGE,
+	LIFE21_PACKAGE,
+	LIFE22_PACKAGE,
+	LIFE23_PACKAGE,
+	LIFE24_PACKAGE,
+	LIFE25_PACKAGE,
+	LIFE26_PACKAGE,
+	LIFE27_PACKAGE,
+	LIFE28_PACKAGE,
+	LIFE29_PACKAGE,
+	LIFE30_PACKAGE,
+	LIFE31_PACKAGE,
+	LIFE32_PACKAGE,
+	LIFE33_PACKAGE,
+	LIFE34_PACKAGE,
+	LIFE35_PACKAGE,
+	LIFE36_PACKAGE,
+	LIFE37_PACKAGE,
+	LIFE38_PACKAGE,
+	LIFE39_PACKAGE,
+	LIFE40_PACKAGE,
+	LIFE41_PACKAGE,
+	LIFE42_PACKAGE,
+	LIFE43_PACKAGE,
+	LIFE44_PACKAGE,
+	LIFE45_PACKAGE,
+	LIFE46_PACKAGE,
+	LIFE47_PACKAGE,
+	LIFE48_PACKAGE,
+	LIFE49_PACKAGE,
+	LIFE50_PACKAGE,
+	OOLITE_PACKAGE,
+	YTTRIC_COLOR_PACKAGE,
+	YTTRIC_XLAT_PACKAGE,
+	QD_COLOR_PACKAGE,
+	QD_XLAT_PACKAGE,
+	LANTHANIDE_COLOR_PACKAGE,
+	TREASURE_COLOR_PACKAGE,
+	UREA_COLOR_PACKAGE,
+	UREA_XLAT_PACKAGE,
+	METAL_PACKAGE,
+	RADIOACTIVE_COLOR_PACKAGE,
+	OPALESCENT_COLOR_PACKAGE,
+	OPALESCENT_XLAT_PACKAGE,
+	CYANIC_COLOR_PACKAGE,
+	ACID_COLOR_PACKAGE,
+	ALKALI_COLOR_PACKAGE,
+	HALIDE_COLOR_PACKAGE,
+	GREEN_COLOR_PACKAGE,
+	COPPER_COLOR_PACKAGE,
+	CARBIDE_COLOR_PACKAGE,
+	ULTRAMARINE_COLOR_PACKAGE,
+	NOBLE_COLOR_PACKAGE,
+	AZURE_COLOR_PACKAGE,
+	CHONDRITE_PACKAGE,
+	PURPLE_COLOR_PACKAGE,
+	SUPER_DENSE_COLOR_PACKAGE,
+	PELLUCID_COLOR_PACKAGE,
+	DUST_COLOR_PACKAGE,
+	MAROON_COLOR_PACKAGE,
+	CIMMERIAN_COLOR_PACKAGE,
+	INFRARED_COLOR_PACKAGE,
+	SELENIC_COLOR_PACKAGE,
+	AURIC_COLOR_PACKAGE,
+	FLUORESCENT_COLOR_PACKAGE,
+	ULTRAVIOLET_COLOR_PACKAGE,
+	PLUTONIC_COLOR_PACKAGE,
+	RAINBOW_COLOR_PACKAGE,
+	SHATTERED_PACKAGE,
+	SAPPHIRE_COLOR_PACKAGE,
+	SAPPHIRE_XLAT_PACKAGE,
+	ORGANIC_COLOR_PACKAGE,
+	XENOLITHIC_COLOR_PACKAGE,
+	REDUX_PACKAGE,
+	PRIMORDIAL_COLOR_PACKAGE,
+	EMERALD_COLOR_PACKAGE,
+	CHLORINE_COLOR_PACKAGE,
+	CHLORINE_XLAT_PACKAGE,
+	MAGNETIC_COLOR_PACKAGE,
+	WATER_COLOR_PACKAGE,
+	TELLURIC_COLOR_PACKAGE,
+	HYDROCARBON_COLOR_PACKAGE,
+	IODINE_COLOR_PACKAGE,
+	VINYLOGOUS_COLOR_PACKAGE,
+	RUBY_COLOR_PACKAGE,
+	MAGMA_COLOR_PACKAGE,
+	CRIMSON_COLOR_PACKAGE,
+	GAS_XLAT_PACKAGE,
+	BLU_GAS_CT_PACKAGE,
+	CYA_GAS_CT_PACKAGE,
+	GRN_GAS_CT_PACKAGE,
+	GRY_GAS_CT_PACKAGE,
+	ORA_GAS_CT_PACKAGE,
+	PUR_GAS_CT_PACKAGE,
+	RED_GAS_CT_PACKAGE,
+	VIO_GAS_CT_PACKAGE,
+	YEL_GAS_CT_PACKAGE,
+	REPORT_PACKAGE,
+	MOONBASE_PACKAGE,
+	MAIDENS_PACKAGE,
+	CHMMR_BASE_PACKAGE,
+	AQUA_PACKAGE,
+	BURV_BCS_PACKAGE,
+	TAALO_DEVICE_PACKAGE,
+	SUN_DEVICE_PACKAGE,
+	VAULT_PACKAGE,
+	WRECK_PACKAGE,
+	BOMB_PACKAGE,
+	BEAST_PACKAGE,
+	EGG_CASE_PACKAGE,
+	SPAPLUTO_PACKAGE,
+	BURV_RUINS_PACKAGE,
+	ANDROSYNTH_RUINS_PACKAGE,
+	DRUUGE_RUINS_PACKAGE,
+	PKUNK_RUINS_PACKAGE,
+	RACE_RUINS_PACKAGE,
+	RACE_RUINS_TEXT_PACKAGE,
+	UMGAH_BCS_PACKAGE,
+	IP_MUSIC_PACKAGE,
+	ORBIT_MUSIC_PACKAGE,
+	MELEE_BGROUND_PACKAGE,
+	MELEE_PICK_PACKAGE,
+	SC2_SEGUE_PACKAGE,
+	SC2_PICK_PACKAGE,
+	ARILOU_CONVERSATION_PACKAGE,
+	CHMMR_CONVERSATION_PACKAGE,
+	COMMANDER_CONVERSATION_PACKAGE,
+	ORZ_CONVERSATION_PACKAGE,
+	PKUNK_CONVERSATION_PACKAGE,
+	SHOFIXTI_CONVERSATION_PACKAGE,
+	SPATHI_CONVERSATION_PACKAGE,
+	SUPOX_CONVERSATION_PACKAGE,
+	THRADD_CONVERSATION_PACKAGE,
+	UTWIG_CONVERSATION_PACKAGE,
+	VUX_CONVERSATION_PACKAGE,
+	YEHAT_CONVERSATION_PACKAGE,
+	MELNORME_CONVERSATION_PACKAGE,
+	DRUUGE_CONVERSATION_PACKAGE,
+	ILWRATH_CONVERSATION_PACKAGE,
+	MYCON_CONVERSATION_PACKAGE,
+	SLYLANDRO_CONVERSATION_PACKAGE,
+	UMGAH_CONVERSATION_PACKAGE,
+	URQUAN_CONVERSATION_PACKAGE,
+	ZOQFOTPIK_CONVERSATION_PACKAGE,
+	SYREEN_CONVERSATION_PACKAGE,
+	BLACKURQ_CONVERSATION_PACKAGE,
+	TALKING_PET_CONVERSATION_PACKAGE,
+	SLYLANDRO_HOME_CONVERSATION_PACKAGE,
+	PLAYER_CONVERSATION_PACKAGE,
+	SIS_PACKAGE,
+	SAMATRA_PACKAGE,
+	URQUAN_PROBE_PACKAGE,
+	RESTART_PACKAGE,
+	MODULE_PACKAGE,
+	OUTFIT_PACKAGE,
+	OUTFIT_MUSIC_PACKAGE,
+	BLUEPRINT_PACKAGE,
+	SHIPYARD_MUSIC_PACKAGE,
+	STARBASE_PACKAGE,
+	SAMATRA_BATTLE_PACKAGE,
+	SHIELDED_BATTLE_PACKAGE,
+	PLANET00_PACKAGE,
+	PLANET01_PACKAGE,
+	PLANET02_PACKAGE,
+	PLANET03_PACKAGE,
+	PLANET04_PACKAGE,
+	PLANET05_PACKAGE,
+	PLANET06_PACKAGE,
+	PLANET07_PACKAGE,
+	PLANET08_PACKAGE,
+	PLANET09_PACKAGE,
+	PLANET10_PACKAGE,
+	PLANET11_PACKAGE,
+	PLANET12_PACKAGE,
+	PLANET13_PACKAGE,
+	PLANET14_PACKAGE,
+	PLANET15_PACKAGE,
+	PLANET16_PACKAGE,
+	PLANET17_PACKAGE,
+	PLANET18_PACKAGE,
+	PLANET19_PACKAGE,
+	PLANET20_PACKAGE,
+	PLANET21_PACKAGE,
+	PLANET22_PACKAGE,
+	PLANET23_PACKAGE,
+	PLANET24_PACKAGE,
+	PLANET25_PACKAGE,
+	PLANET26_PACKAGE,
+	PLANET27_PACKAGE,
+	PLANET28_PACKAGE,
+	PLANET29_PACKAGE,
+	PLANET30_PACKAGE,
+	PLANET31_PACKAGE,
+	PLANET32_PACKAGE,
+	PLANET33_PACKAGE,
+	PLANET34_PACKAGE,
+	PLANET35_PACKAGE,
+	PLANET36_PACKAGE,
+	PLANET37_PACKAGE,
+	PLANET38_PACKAGE,
+	PLANET39_PACKAGE,
+	PLANET40_PACKAGE,
+	PLANET41_PACKAGE,
+	PLANET42_PACKAGE,
+	PLANET43_PACKAGE,
+	PLANET44_PACKAGE,
+	PLANET45_PACKAGE,
+	PLANET46_PACKAGE,
+	PLANET47_PACKAGE,
+	PLANET48_PACKAGE,
+	PLANET49_PACKAGE,
+	PLANET50_PACKAGE,
+	PLANET51_PACKAGE,
+	PLANET52_PACKAGE,
+	PLANET53_PACKAGE,
+	PLANET54_PACKAGE,
+	PLANET55_PACKAGE,
+	PLANET56_PACKAGE,
+	PLANET57_PACKAGE,
+	PLANET58_PACKAGE,
+	BATTLE_MUSIC_PACKAGE,
+	CREDITBKGD_PACKAGE,
+	UNUSED_01_PACKAGE_,
+	UNUSED_02_PACKAGE_,
+	UNUSED_03_PACKAGE_,
+	UNUSED_04_PACKAGE_,
+	UNUSED_05_PACKAGE_,
+	UNUSED_06_PACKAGE_,
+	UNUSED_07_PACKAGE_,
+	UNUSED_08_PACKAGE_,
+	UNUSED_09_PACKAGE_,
+	UNUSED_10_PACKAGE_,
+	UNUSED_11_PACKAGE_,
+	UNUSED_12_PACKAGE_,
+	UNUSED_13_PACKAGE_,
+	UNUSED_14_PACKAGE_,
+	UNUSED_15_PACKAGE_,
+	UNUSED_16_PACKAGE_,
+	UNUSED_17_PACKAGE_,
+	UNUSED_18_PACKAGE_,
+	UNUSED_19_PACKAGE_,
+	CREDIT_MUSIC_PACKAGE,
+	SISSKEL_PACKAGE,
+	ORBENTER_PACKAGE,
+	MENUBKG_PACKAGE,
+	INTRO_PACKAGE,
+	FINAL_PACKAGE,
+	CREDIT_FONTS_PACKAGE,
+	CREDITS_PACKAGE,
+	JOYSTICK_ALPHA_PACKAGE,
+};
+
diff -ruNp src.orig/uqm/restart.c src/uqm/restart.c
--- src.orig/uqm/restart.c	2017-11-01 15:30:26 -0700
+++ src/uqm/restart.c	2017-11-01 15:31:04 -0700
@@ -16,8 +16,14 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: Upon finding black orb & new ship, initiate Lurg cutscene
+
+// JMS_GFX: 1x, 2x and 4x restart menu graphics.
+//#define FLASH_INTERNAL
+
 #include "restart.h"
 
+#include "options.h"
 #include "colors.h"
 #include "controls.h"
 #include "credits.h"
@@ -41,8 +47,10 @@
 #include "uqmversion.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/inplib.h"
+#include "libs/log.h"
 
-
+#include "libs/graphics/sdl/pure.h" // JMS_GFX
+ 
 // TODO: This entire module fails to uphold the GraphicsLock semantics
 //   This either has to be fixed, or GraphicsLock completely ignored,
 //   or will become irrelevant if GraphicsLock completely removed.
@@ -64,8 +72,28 @@ DrawRestartMenuGraphic (MENU_STATE *pMS)
 	STAMP s;
 	TEXT t;
 	UNICODE buf[64];
-
-	s.frame = CaptureDrawable (LoadGraphic (RESTART_PMAP_ANIM));
+	
+	//DC: Load the different menus depending on the resolution factor.
+	if (resolutionFactor < 1)
+		s.frame = CaptureDrawable (LoadGraphic (RESTART_PMAP_ANIM));
+	if (resolutionFactor == 1)
+		s.frame = CaptureDrawable (LoadGraphic (RESTART_PMAP_ANIM2X));
+	if (resolutionFactor > 1)
+		s.frame = CaptureDrawable (LoadGraphic (RESTART_PMAP_ANIM4X));
+
+	// Re-load the info box font so the text shows in correct size after changing the resolution.
+	if (resFactorWasChanged)
+	{	
+		DestroyFont (StarConFont);
+		
+		if (resolutionFactor < 1)
+			StarConFont = LoadFont (FALLBACK_TO1X_FONT);
+		if (resolutionFactor == 1)
+			StarConFont = LoadFont (FALLBACK_TO2X_FONT);
+		if (resolutionFactor > 1)
+			StarConFont = LoadFont (FALLBACK_TO4X_FONT);
+	}
+	
 	pMS->CurFrame = s.frame;
 	GetFrameRect (s.frame, &r);
 	s.origin.x = (SCREEN_WIDTH - r.extent.width) >> 1;
@@ -76,6 +104,7 @@ DrawRestartMenuGraphic (MENU_STATE *pMS)
 	ClearDrawable ();
 	FlushColorXForms ();
 	LockMutex (GraphicsLock);
+ 
 	DrawStamp (&s);
 
 	// Put the version number in the bottom right corner.
@@ -85,8 +114,8 @@ DrawRestartMenuGraphic (MENU_STATE *pMS)
 	t.baseline.y = SCREEN_HEIGHT - 2;
 	t.align = ALIGN_RIGHT;
 	t.CharCount = (COUNT)~0;
-	sprintf (buf, "v%d.%d.%d%s", UQM_MAJOR_VERSION, UQM_MINOR_VERSION,
-			UQM_PATCH_VERSION, UQM_EXTRA_VERSION);
+	sprintf (buf, "v%d.%d.%d%s", P6014_MAJOR_VERSION, P6014_MINOR_VERSION, P6014_PATCH_VERSION, P6014_EXTRA_VERSION);
+	//sprintf (buf, "X:%d.Y:%d", ScreenContext->ForeGroundFrame->Bounds.width, ScreenContext->ForeGroundFrame->Bounds.height);
 	SetContextForeGroundColor (WHITE_COLOR);
 	font_DrawText (&t);
 
@@ -94,14 +123,14 @@ DrawRestartMenuGraphic (MENU_STATE *pMS)
 	UnbatchGraphics ();
 }
 
+// JMS_GFX: The cleanup boolean can be used to avoid drawing a wrong-sized "Setup" flash overlay.
 static void
-DrawRestartMenu (MENU_STATE *pMS, BYTE NewState, FRAME f)
+DrawRestartMenu (MENU_STATE *pMS, BYTE NewState, FRAME f, BOOLEAN cleanup)
 {
 	POINT origin;
 	origin.x = 0;
 	origin.y = 0;
-	Flash_setOverlay(pMS->flashContext,
-			&origin, SetAbsFrameIndex (f, NewState + 1));
+	Flash_setOverlay (pMS->flashContext, &origin, SetAbsFrameIndex (f, NewState + 1), cleanup);
 }
 
 static BOOLEAN
@@ -127,15 +156,12 @@ DoRestart (MENU_STATE *pMS)
 		}
 		pMS->hMusic = LoadMusic (MAINMENU_MUSIC);
 		InactTimeOut = (pMS->hMusic ? 120 : 20) * ONE_SECOND;
-		pMS->flashContext = Flash_createOverlay (ScreenContext,
-				NULL, NULL);
+		pMS->flashContext = Flash_createOverlay (ScreenContext, NULL, NULL);
 		Flash_setMergeFactors (pMS->flashContext, -3, 3, 16);
-		Flash_setSpeed (pMS->flashContext, (6 * ONE_SECOND) / 16, 0,
-				(6 * ONE_SECOND) / 16, 0);
+		Flash_setSpeed (pMS->flashContext, (6 * ONE_SECOND) / 16, 0, (6 * ONE_SECOND) / 16, 0);
 		Flash_setFrameTime (pMS->flashContext, ONE_SECOND / 16);
-		Flash_setState(pMS->flashContext, FlashState_fadeIn,
-				(3 * ONE_SECOND) / 16);
-		DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame);
+		Flash_setState(pMS->flashContext, FlashState_fadeIn, (3 * ONE_SECOND) / 16);
+		DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
 		Flash_start (pMS->flashContext);
 		PlayMusic (pMS->hMusic, TRUE, 1);
 		LastInputTime = GetTimeCounter ();
@@ -149,34 +175,158 @@ DoRestart (MENU_STATE *pMS)
 	}
 	else if (PulsedInputState.menu[KEY_MENU_SELECT])
 	{
+		COUNT oldresfactor;
+		BOOLEAN packsInstalled;
+		
+		if (resolutionFactor == 0)
+			packsInstalled = TRUE;
+		else if (resolutionFactor == 1 && hires2xPackPresent)
+			packsInstalled = TRUE;
+		else if (resolutionFactor == 2 && hires4xPackPresent)
+			packsInstalled = TRUE;
+		else
+			packsInstalled = FALSE;
+		
 		switch (pMS->CurState)
 		{
 			case LOAD_SAVED_GAME:
-				LastActivity = CHECK_LOAD;
-				GLOBAL (CurrentActivity) = IN_INTERPLANETARY;
+				if (resFactorWasChanged)
+				{
+					LockMutex (GraphicsLock);
+					SetFlashRect (NULL);
+					UnlockMutex (GraphicsLock);
+					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35));
+					// Got to restart -message
+					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
+					SetTransitionSource (NULL);
+					BatchGraphics ();
+					DrawRestartMenuGraphic (pMS);
+					DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
+					ScreenTransition (3, NULL);
+					UnbatchGraphics ();
+					SleepThreadUntil (FadeScreen(FadeAllToBlack, ONE_SECOND / 2));
+					GLOBAL (CurrentActivity) = CHECK_ABORT;
+				}
+				else if (!packsInstalled)
+				{
+					Flash_pause(pMS->flashContext);
+					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35 + resolutionFactor));
+					// Could not find graphics pack - message
+					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
+					SetTransitionSource (NULL);
+					BatchGraphics ();
+					DrawRestartMenuGraphic (pMS);
+					DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
+					ScreenTransition (3, NULL);
+					UnbatchGraphics ();
+					Flash_continue(pMS->flashContext);
+					SleepThreadUntil (TimeIn + ONE_SECOND / 30);
+					return TRUE;
+				}
+				else
+				{
+					LastActivity = CHECK_LOAD;
+					GLOBAL (CurrentActivity) = IN_INTERPLANETARY;
+				}
 				break;
 			case START_NEW_GAME:
-				LastActivity = CHECK_LOAD | CHECK_RESTART;
-				GLOBAL (CurrentActivity) = IN_INTERPLANETARY;
+				if (resFactorWasChanged)
+				{
+					LockMutex (GraphicsLock);
+					SetFlashRect (NULL);
+					UnlockMutex (GraphicsLock);
+					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35));
+					// Got to restart -message
+					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
+					SetTransitionSource (NULL);
+					BatchGraphics ();
+					DrawRestartMenuGraphic (pMS);
+					DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
+					ScreenTransition (3, NULL);
+					UnbatchGraphics ();
+					SleepThreadUntil (FadeScreen(FadeAllToBlack, ONE_SECOND / 2));
+					GLOBAL (CurrentActivity) = CHECK_ABORT;
+				}
+				else if (!packsInstalled)
+				{
+					Flash_pause(pMS->flashContext);
+					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35 + resolutionFactor));
+					// Could not find graphics pack - message
+					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
+					SetTransitionSource (NULL);
+					BatchGraphics ();
+					DrawRestartMenuGraphic (pMS);
+					DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
+					ScreenTransition (3, NULL);
+					UnbatchGraphics ();
+					Flash_continue(pMS->flashContext);
+					SleepThreadUntil (TimeIn + ONE_SECOND / 30);
+					return TRUE;
+				}
+				else
+				{
+					LastActivity = CHECK_LOAD | CHECK_RESTART;
+					GLOBAL (CurrentActivity) = IN_INTERPLANETARY;
+				}
 				break;
 			case PLAY_SUPER_MELEE:
-				GLOBAL (CurrentActivity) = SUPER_MELEE;
+				if (resFactorWasChanged)
+				{
+					LockMutex (GraphicsLock);
+					SetFlashRect (NULL);
+					UnlockMutex (GraphicsLock);
+					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35));
+					// Got to restart -message
+					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
+					SetTransitionSource (NULL);
+					BatchGraphics ();
+					DrawRestartMenuGraphic (pMS);
+					DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
+					ScreenTransition (3, NULL);
+					UnbatchGraphics ();
+					SleepThreadUntil (FadeScreen(FadeAllToBlack, ONE_SECOND / 2));
+					GLOBAL (CurrentActivity) = CHECK_ABORT;
+				}
+				else if (!packsInstalled)
+				{
+					Flash_pause(pMS->flashContext);
+					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35 + resolutionFactor));
+					// Could not find graphics pack - message
+					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
+					SetTransitionSource (NULL);
+					BatchGraphics ();
+					DrawRestartMenuGraphic (pMS);
+					DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
+					ScreenTransition (3, NULL);
+					UnbatchGraphics ();
+					Flash_continue(pMS->flashContext);
+					SleepThreadUntil (TimeIn + ONE_SECOND / 30);
+					return TRUE;
+				}
+				else
+				{
+					GLOBAL (CurrentActivity) = SUPER_MELEE;
+				}
 				break;
 			case SETUP_GAME:
+				oldresfactor = resolutionFactor;
 				Flash_pause(pMS->flashContext);
-				Flash_setState(pMS->flashContext, FlashState_fadeIn,
-						(3 * ONE_SECOND) / 16);
+				Flash_setState(pMS->flashContext, FlashState_fadeIn, (3 * ONE_SECOND) / 16);
 				SetupMenu ();
-				SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN,
-						MENU_SOUND_SELECT);
+				SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);
 				LastInputTime = GetTimeCounter ();
 				SetTransitionSource (NULL);
 				BatchGraphics ();
 				DrawRestartMenuGraphic (pMS);
 				ScreenTransition (3, NULL);
-				DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame);
-				Flash_continue(pMS->flashContext);
+				
+				// JMS_GFX: This prevents drawing an annoying wrong-sized "Setup" frame when changing resolution. 
+				if (oldresfactor < resolutionFactor)
+					DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, TRUE);
+				
+				DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
 				UnbatchGraphics ();
+				Flash_continue(pMS->flashContext);
 				return TRUE;
 			case QUIT_GAME:
 				SleepThreadUntil (FadeScreen (FadeAllToBlack, ONE_SECOND / 2));
@@ -211,7 +361,7 @@ DoRestart (MENU_STATE *pMS)
 		if (NewState != pMS->CurState)
 		{
 			BatchGraphics ();
-			DrawRestartMenu (pMS, NewState, pMS->CurFrame);
+			DrawRestartMenu (pMS, NewState, pMS->CurFrame, FALSE);
 			UnbatchGraphics ();
 			pMS->CurState = NewState;
 		}
@@ -226,13 +376,13 @@ DoRestart (MENU_STATE *pMS)
 	else if (MouseButtonDown)
 	{
 		Flash_pause(pMS->flashContext);
-		DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 54));
+		DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 56));
 				// Mouse not supported message
 		SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
 		SetTransitionSource (NULL);
 		BatchGraphics ();
 		DrawRestartMenuGraphic (pMS);
-		DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame);
+		DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
 		ScreenTransition (3, NULL);
 		UnbatchGraphics ();
 		Flash_continue(pMS->flashContext);
@@ -274,10 +424,8 @@ RestartMenu (MENU_STATE *pMS)
 	{	// player blew himself up with Utwig bomb
 		SET_GAME_STATE (UTWIG_BOMB_ON_SHIP, 0);
 
-		SleepThreadUntil (FadeScreen (FadeAllToWhite, ONE_SECOND / 8)
-				+ ONE_SECOND / 60);
-		SetContextBackGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x1F), 0x0F));
+		SleepThreadUntil (FadeScreen (FadeAllToWhite, ONE_SECOND / 8) + ONE_SECOND / 60);
+		SetContextBackGroundColor (BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x1F), 0x0F));
 		ClearDrawable ();
 		FlushColorXForms ();
 
@@ -286,7 +434,7 @@ RestartMenu (MENU_STATE *pMS)
 	else
 	{
 		TimeOut = ONE_SECOND / 2;
-
+		
 		if (LOBYTE (LastActivity) == WON_LAST_BATTLE)
 		{
 			GLOBAL (CurrentActivity) = WON_LAST_BATTLE;
@@ -307,6 +455,7 @@ RestartMenu (MENU_STATE *pMS)
 	SleepThreadUntil (FadeScreen (FadeAllToBlack, TimeOut));
 	if (TimeOut == ONE_SECOND / 8)
 		SleepThread (ONE_SECOND * 3);
+	
 	DrawRestartMenuGraphic (pMS);
 	GLOBAL (CurrentActivity) &= ~CHECK_ABORT;
 	SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);
diff -ruNp src.orig/uqm/save.c src/uqm/save.c
--- src.orig/uqm/save.c	2017-11-01 15:30:26 -0700
+++ src/uqm/save.c	2017-11-01 15:31:04 -0700
@@ -16,6 +16,10 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2009: - Added IN_ORZSPACE condition check to PrepareSummary
+// JMS 2010: - Added Encounter pointer's home and destination pt's to house transport ships to SaveEncounter
+// JMS 2011: - Added saving res_factor to summary_desc. It'll help making saves between different resolutions compatible.
+
 #include <assert.h>
 
 #include "save.h"
@@ -74,44 +78,44 @@ cwrite_a8 (DECODE_REF fh, const BYTE *ar
 	return cwrite (ar, 1, count, fh) == count;
 }
 
-static inline size_t
+static inline COUNT
 write_8 (void *fp, BYTE v)
 {
 	return WriteResFile (&v, 1, 1, fp);
 }
 
-static inline size_t
+static inline COUNT
 write_16 (void *fp, UWORD v)
 {
 	return WriteResFile (&v, 2, 1, fp);
 }
 
-static inline size_t
+static inline COUNT
 write_32 (void *fp, DWORD v)
 {
 	return WriteResFile (&v, 4, 1, fp);
 }
 
-static inline size_t
+static inline COUNT
 write_ptr (void *fp)
 {
 	return write_32 (fp, 0); /* ptrs are useless in saves */
 }
 
-static inline size_t
+static inline COUNT
 write_a8 (void *fp, const BYTE *ar, COUNT count)
 {
 	return WriteResFile (ar, 1, count, fp) == count;
 }
 
-static inline size_t
+static inline COUNT
 write_str (void *fp, const char *str, COUNT count)
 {
 	// no type conversion needed for strings
 	return write_a8 (fp, (const BYTE *)str, count);
 }
 
-static inline size_t
+static inline COUNT
 write_a16 (void *fp, const UWORD *ar, COUNT count)
 {
 	for ( ; count > 0; --count, ++ar)
@@ -276,6 +280,10 @@ SaveEncounter (const ENCOUNTER *Encounte
 	cwrite_16  (fh, EncounterPtr->origin.x);
 	cwrite_16  (fh, EncounterPtr->origin.y);
 	cwrite_16  (fh, EncounterPtr->radius);
+	cwrite_16  (fh, EncounterPtr->destination_pt.x);// JMS
+	cwrite_16  (fh, EncounterPtr->destination_pt.y);// JMS
+	cwrite_16  (fh, EncounterPtr->home_pt.x);		// JMS
+	cwrite_16  (fh, EncounterPtr->home_pt.y);		// JMS
 	// STAR_DESC fields
 	cwrite_16  (fh, EncounterPtr->SD.star_pt.x);
 	cwrite_16  (fh, EncounterPtr->SD.star_pt.y);
@@ -304,8 +312,9 @@ SaveEncounter (const ENCOUNTER *Encounte
 	}
 	
 	// Save the stuff after the BRIEF_SHIP_INFO array
-	cwrite_32  (fh, EncounterPtr->log_x);
-	cwrite_32  (fh, EncounterPtr->log_y);
+	// JMS: Let's make savegames work even between different resolution modes.
+	cwrite_32  (fh, ((EncounterPtr->log_x) >> RESOLUTION_FACTOR));
+	cwrite_32  (fh, ((EncounterPtr->log_y) >> RESOLUTION_FACTOR));
 }
 
 static void
@@ -360,8 +369,16 @@ SaveClockState (const CLOCK_STATE *Clock
 static void
 SaveGameState (const GAME_STATE *GSPtr, DECODE_REF fh)
 {
+	BYTE res_scale; // JMS
+	
+	// JMS
+	if (LOBYTE (GSPtr->CurrentActivity) != IN_INTERPLANETARY)
+		res_scale = RESOLUTION_FACTOR; 
+	else
+		res_scale = 0;
+	
 	cwrite_8   (fh, 0); /* obsolete; BYTE cur_state */
-	cwrite_8   (fh, GSPtr->glob_flags);
+	cwrite_16   (fh, GSPtr->glob_flags);
 	cwrite_8   (fh, GSPtr->CrewCost);
 	cwrite_8   (fh, GSPtr->FuelCost);
 	cwrite_a8  (fh, GSPtr->ModuleCost, NUM_MODULES);
@@ -377,24 +394,23 @@ SaveGameState (const GAME_STATE *GSPtr,
 	cwrite_16  (fh, GSPtr->ip_location.x);
 	cwrite_16  (fh, GSPtr->ip_location.y);
 	/* STAMP ShipStamp */
-	cwrite_16  (fh, GSPtr->ShipStamp.origin.x);
-	cwrite_16  (fh, GSPtr->ShipStamp.origin.y);
+	cwrite_16  (fh, (GSPtr->ShipStamp.origin.x >> RESOLUTION_FACTOR)); // JMS: Let's make savegames work even between different resolution modes.
+	cwrite_16  (fh, (GSPtr->ShipStamp.origin.y >> RESOLUTION_FACTOR)); // JMS: Let's make savegames work even between different resolution modes.
 	cwrite_16  (fh, GSPtr->ShipFacing);
 	cwrite_8   (fh, GSPtr->ip_planet);
 	cwrite_8   (fh, GSPtr->in_orbit);
 
 	/* VELOCITY_DESC velocity */
 	cwrite_16  (fh, GSPtr->velocity.TravelAngle);
-	cwrite_16  (fh, GSPtr->velocity.vector.width);
-	cwrite_16  (fh, GSPtr->velocity.vector.height);
-	cwrite_16  (fh, GSPtr->velocity.fract.width);
-	cwrite_16  (fh, GSPtr->velocity.fract.height);
-	cwrite_16  (fh, GSPtr->velocity.error.width);
-	cwrite_16  (fh, GSPtr->velocity.error.height);
-	cwrite_16  (fh, GSPtr->velocity.incr.width);
-	cwrite_16  (fh, GSPtr->velocity.incr.height);
+	cwrite_16  (fh, GSPtr->velocity.vector.width >> res_scale); // JMS: Let's make savegames work even between different resolution modes.
+	cwrite_16  (fh, GSPtr->velocity.vector.height >> res_scale);// JMS: Let's make savegames work even between different resolution modes.
+	cwrite_16  (fh, GSPtr->velocity.fract.width >> res_scale);	// JMS: Let's make savegames work even between different resolution modes.
+	cwrite_16  (fh, GSPtr->velocity.fract.height >> res_scale); // JMS: Let's make savegames work even between different resolution modes.
+	cwrite_16  (fh, GSPtr->velocity.error.width >> res_scale);	// JMS: Let's make savegames work even between different resolution modes.
+	cwrite_16  (fh, GSPtr->velocity.error.height >> res_scale);	// JMS: Let's make savegames work even between different resolution modes.
+	cwrite_16  (fh, GSPtr->velocity.incr.width >> res_scale);	// JMS: Let's make savegames work even between different resolution modes.
+	cwrite_16  (fh, GSPtr->velocity.incr.height >> res_scale);	// JMS: Let's make savegames work even between different resolution modes.
 	cwrite_16  (fh, 0); /* VELOCITY_DESC padding */
-
 	cwrite_32  (fh, GSPtr->BattleGroupRef);
 	
 	DummySaveQueue (&GSPtr->avail_race_q, fh);
@@ -405,7 +421,7 @@ SaveGameState (const GAME_STATE *GSPtr,
 
 	cwrite_a8  (fh, GSPtr->GameState, sizeof (GSPtr->GameState));
 
-	assert (sizeof (GSPtr->GameState) % 4 == 3);
+	//assert (sizeof (GSPtr->GameState) % 4 == 3);
 	cwrite_8  (fh, 0); /* GAME_STATE alignment padding */
 }
 
@@ -413,8 +429,8 @@ static BOOLEAN
 SaveSisState (const SIS_STATE *SSPtr, void *fp)
 {
 	if (
-			write_32  (fp, SSPtr->log_x) != 1 ||
-			write_32  (fp, SSPtr->log_y) != 1 ||
+			write_32  (fp, ((SSPtr->log_x) >> RESOLUTION_FACTOR)) != 1 || // JMS: Let's make savegames work even between different resolution modes.
+			write_32  (fp, ((SSPtr->log_y) >> RESOLUTION_FACTOR)) != 1 || // JMS: Let's make savegames work even between different resolution modes.
 			write_32  (fp, SSPtr->ResUnits) != 1 ||
 			write_32  (fp, SSPtr->FuelOnBoard) != 1 ||
 			write_16  (fp, SSPtr->CrewEnlisted) != 1 ||
@@ -455,6 +471,7 @@ SaveSummary (const SUMMARY_DESC *SummPtr
 			write_8  (fp, SummPtr->NumDevices) != 1 ||
 			write_a8 (fp, SummPtr->ShipList, MAX_BUILT_SHIPS) != 1 ||
 			write_a8 (fp, SummPtr->DeviceList, MAX_EXCLUSIVE_DEVICES) != 1 ||
+			write_8  (fp, SummPtr->res_factor) != 1 || // JMS: This'll help making saves in different resolutions compatible.
 
 			write_16  (fp, 0) != 1 /* padding */
 		)
@@ -483,6 +500,8 @@ PrepareSummary (SUMMARY_DESC *SummPtr)
 	switch (SummPtr->Activity)
 	{
 		case IN_HYPERSPACE:
+			if (GET_GAME_STATE (ORZ_SPACE_SIDE) > 1) // JMS: this condition stores that we're in ORZ space.
+				SummPtr->Activity = IN_ORZSPACE;
 			if (GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1)
 				SummPtr->Activity = IN_QUASISPACE;
 			break;
@@ -532,6 +551,8 @@ PrepareSummary (SUMMARY_DESC *SummPtr)
 	SummPtr->day_index = GLOBAL (GameClock.day_index);
 	SummPtr->month_index = GLOBAL (GameClock.month_index);
 	SummPtr->year_index = GLOBAL (GameClock.year_index);
+	
+	SummPtr->res_factor = RESOLUTION_FACTOR; // JMS: This'll help making saves in different resolutions compatible.
 }
 
 static void
@@ -830,15 +851,15 @@ RetrySave:
 
 		// Write the memory file to the actual savegame file.
 		sprintf (file, "starcon2.%02u", which_game);
-		log_add (log_Debug, "'%s' is %u bytes long", file,
-				flen + sizeof (*SummPtr));
+		log_add (log_Debug, "'%s' is %lu bytes long", file, flen + sizeof (*SummPtr));
 		if (flen && (out_fp = res_OpenResFile (saveDir, file, "wb")))
 		{
 			PrepareSummary (SummPtr);
 
 			success = SaveSummary (SummPtr, out_fp);
 			// Then write the rest of the data.
-			if (success && WriteResFile (h, flen, 1, out_fp) != 1)
+			if (success && WriteResFile (h, (COUNT)flen, 1,
+						out_fp) == 0)
 				success = FALSE;
 
 			if (res_CloseResFile ((uio_Stream *)out_fp) == 0)
diff -ruNp src.orig/uqm/settings.c src/uqm/settings.c
--- src.orig/uqm/settings.c	2017-11-01 15:30:26 -0700
+++ src/uqm/settings.c	2017-11-01 15:31:04 -0700
@@ -95,3 +95,9 @@ PlaySoundEffect (SOUND S, COUNT Channel,
 	}
 }
 
+void
+ToggleVoice (void)
+{
+	GLOBAL (glob_flags) ^= VOICE_DISABLED;
+}
+
diff -ruNp src.orig/uqm/settings.h src/uqm/settings.h
--- src.orig/uqm/settings.h	2017-11-01 15:30:26 -0700
+++ src/uqm/settings.h	2017-11-01 15:31:04 -0700
@@ -24,6 +24,7 @@ extern void StopMusic (void);
 extern void ResumeMusic (void);
 extern void PauseMusic (void);
 extern void ToggleSoundEffect (void);
+extern void ToggleVoice (void);
 
 extern void PlayMusic (MUSIC_REF MusicRef, BOOLEAN Continuous, BYTE Priority);
 extern void PlaySoundEffect (SOUND S, COUNT Channel, SoundPosition Pos,
diff -ruNp src.orig/uqm/setup.c src/uqm/setup.c
--- src.orig/uqm/setup.c	2017-11-01 15:30:26 -0700
+++ src/uqm/setup.c	2017-11-01 15:31:04 -0700
@@ -16,6 +16,10 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: Bullet hole gfx frames for melee.
+
+// JMS_GFX 2011: Merged resolution Factor stuff from UQM-HD.
+
 #include "setup.h"
 
 #include "coderes.h"
@@ -44,7 +48,6 @@
 #include <errno.h>
 #include <string.h>
 
-
 ACTIVITY LastActivity;
 BYTE PlayerControl[NUM_PLAYERS];
 
@@ -59,15 +62,20 @@ FRAME Screen;
 FONT StarConFont;
 FONT MicroFont;
 FONT TinyFont;
+FONT NanoFont; // JMS
 QUEUE race_q[NUM_PLAYERS];
 FRAME ActivityFrame;
 FRAME StatusFrame;
+FRAME hyperspacesuns; // BW
+FRAME nebulaeFrame; // JMS
 FRAME FlagStatFrame;
 FRAME MiscDataFrame;
 FRAME FontGradFrame;
 Mutex GraphicsLock;
 STRING GameStrings;
 QUEUE disp_q;
+BOOLEAN hires2xPackPresent; // JMS_GFX
+BOOLEAN hires4xPackPresent; // JMS_GFX
 
 uio_Repository *repository;
 uio_DirHandle *rootDir;
@@ -110,8 +118,7 @@ LoadKernel (int argc, char *argv[])
 		return FALSE;
 	
 	/* Load base content. */
-	if (loadIndices (contentDir) == 0)
-		return FALSE; // Must have at least one index in content dir
+	loadIndices (contentDir);
 
 	/* Load addons demanded by the current configuration. */
 	if (opt3doMusic)
@@ -120,19 +127,32 @@ LoadKernel (int argc, char *argv[])
 	}
 
 	/* Always try to use voice data */
-	if (!loadAddon ("3dovoice"))
+	if (!loadAddon ("voice"))
 		speechVolumeScale = 0.0f; // XXX: need better no-speech indicator
 
+	loadAddon ("voice"); /* Project 6014 voice files. */
+
 	if (optRemixMusic)
 	{
 		loadAddon ("remix");
 	}
-
-	if (optWhichIntro == OPT_3DO)
+	
+	// JMS_GFX
+	if (resolutionFactor == 1 && loadAddon ("hires2x"))
 	{
-		loadAddon ("3dovideo");
+		hires2xPackPresent = TRUE;
+		printf ("loading addon hires2x\n");
 	}
-
+	else if (resolutionFactor == 2 && loadAddon ("hires4x"))
+	{
+		hires4xPackPresent = TRUE;
+		printf ("loading addon hires4x\n");
+	}
+	// END JMS_GFX
+	
+	// JMS: Force loading russian translation addon since the prepareAddons doesn't want to find it.
+	loadAddon ("Translation_RU");
+	
 	/* Now load the rest of the addons, in order. */
 	prepareAddons (optAddons);
 
@@ -140,8 +160,6 @@ LoadKernel (int argc, char *argv[])
 		COLORMAP ColorMapTab;
 
 		ColorMapTab = CaptureColorMap (LoadColorMap (STARCON_COLOR_MAP));
-		if (ColorMapTab == NULL)
-			return FALSE; // The most basic resource is missing
 		SetColorMap (GetColorMapAddress (ColorMapTab));
 		DestroyColorMap (ReleaseColorMap (ColorMapTab));
 	}
@@ -198,6 +216,11 @@ InitKernel (void)
 	TinyFont = LoadFont (TINY_FONT);
 	if (TinyFont == NULL)
 		return FALSE;
+	
+	// JMS: Nanofont for hi-res
+	NanoFont = LoadFont (NANO_FONT);
+	if (NanoFont == NULL)
+		return FALSE;
 
 	ActivityFrame = CaptureDrawable (LoadGraphic (ACTIVITY_ANIM));
 	if (ActivityFrame == NULL)
@@ -207,6 +230,16 @@ InitKernel (void)
 	if (StatusFrame == NULL)
 		return FALSE;
 
+	// JMS: Animated hyperspace suns.
+	hyperspacesuns = CaptureDrawable (LoadGraphic (HYPERSUNS_MASK_PMAP_ANIM));
+	if (hyperspacesuns == NULL)
+		return FALSE;
+
+	// JMS: Background nebulae in IP.
+	nebulaeFrame = CaptureDrawable (LoadGraphic (NEBULAE_PMAP_ANIM));
+	if (nebulaeFrame == NULL)
+		return FALSE;
+	
 	GameStrings = CaptureStringTable (LoadStringTable (STARCON_GAME_STRINGS));
 	if (GameStrings == 0)
 		return FALSE;
diff -ruNp src.orig/uqm/setup.h src/uqm/setup.h
--- src.orig/uqm/setup.h	2017-11-01 15:30:26 -0700
+++ src/uqm/setup.h	2017-11-01 15:31:04 -0700
@@ -29,6 +29,8 @@ extern RESOURCE_INDEX hResIndex;
 extern FRAME Screen;
 extern FRAME ActivityFrame;
 extern FRAME StatusFrame;
+extern FRAME nebulaeFrame;	// JMS
+extern FRAME hyperspacesuns;	// BW
 extern FRAME FlagStatFrame;
 extern FRAME MiscDataFrame;
 extern FRAME FontGradFrame;
@@ -46,6 +48,7 @@ extern SIZE screen_width, screen_height;
 extern FONT StarConFont;
 extern FONT MicroFont;
 extern FONT TinyFont;
+extern FONT NanoFont; // JMS
 
 extern Mutex GraphicsLock;
 extern CondVar RenderingCond;
@@ -54,6 +57,9 @@ extern QUEUE race_q[];
 		/* Array of lists of ships involved in a battle, one queue per side;
 		 * queue element is STARSHIP */
 
+extern BOOLEAN hires2xPackPresent; // JMS
+extern BOOLEAN hires4xPackPresent; // JMS
+
 extern ACTIVITY LastActivity;
 
 extern BYTE PlayerControl[];
diff -ruNp src.orig/uqm/setupmenu.c src/uqm/setupmenu.c
--- src.orig/uqm/setupmenu.c	2017-11-01 15:30:26 -0700
+++ src/uqm/setupmenu.c	2017-11-01 15:31:04 -0700
@@ -16,6 +16,12 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2011: Originally, the smooth zoom was TFB_SCALE_TRILINEAR instead of bilinear.
+// Using bilinear alleviates the smooth zoom performance choppiness problems in 2x and 4x, but
+// is kinda hacky solution...
+
+// JMS_GFX 2011: Merged resolution Factor stuff from UQM-HD.
+
 #include "setupmenu.h"
 
 #include "controls.h"
@@ -38,6 +44,10 @@
 #include "resinst.h"
 #include "nameref.h"
 
+#include "gamestr.h"
+
+#include "libs/graphics/bbox.h"
+
 static STRING SetupTab;
 
 typedef struct setup_menu_state {
@@ -67,13 +77,13 @@ static void rebind_control (WIDGET_CONTR
 static void clear_control (WIDGET_CONTROLENTRY *widget);
 
 #ifdef HAVE_OPENGL
-#define RES_OPTS 4
+#define RES_OPTS 3 // JMS_GFX was 4
 #else
-#define RES_OPTS 2
+#define RES_OPTS 3 // JMS_GFX was 2
 #endif
 
 #define MENU_COUNT          8
-#define CHOICE_COUNT       22
+#define CHOICE_COUNT       23
 #define SLIDER_COUNT        3
 #define BUTTON_COUNT       10
 #define LABEL_COUNT         4
@@ -94,9 +104,9 @@ static WIDGET_CONTROLENTRY controlentrie
 typedef int (*HANDLER)(WIDGET *, int);
 
 static int choice_widths[CHOICE_COUNT] = {
-	3, 2, 3, 3, 2, 2, 2, 2, 2, 2, 
-	2, 2, 3, 2, 2, 3, 3, 2,	3, 3, 
-	3, 2 };
+	3, 2, 3, 2, 2, 2, 2, 2, 2, 2, 
+	2, 2, 2, 2, 2, 3, 3, 2,	3, 3, 
+	3, 2, 3 };
 
 static HANDLER button_handlers[BUTTON_COUNT] = {
 	quit_main_menu, quit_sub_menu, do_graphics, do_engine,
@@ -104,7 +114,7 @@ static HANDLER button_handlers[BUTTON_CO
 	do_keyconfig };
 
 static int menu_sizes[MENU_COUNT] = {
-	7, 5, 7, 9, 2, 5,
+	7, 6, 7, 9, 2, 5,
 #ifdef HAVE_OPENGL
 	5,
 #else
@@ -128,6 +138,7 @@ static WIDGET *main_widgets[] = {
 
 static WIDGET *graphics_widgets[] = {
 	(WIDGET *)(&choices[0]),
+	(WIDGET *)(&choices[22]), // JMS: lores blowup
 	(WIDGET *)(&choices[10]),
 	(WIDGET *)(&choices[2]),
 	(WIDGET *)(&choices[3]),
@@ -357,14 +368,14 @@ SetDefaults (void)
 	GLOBALOPTS opts;
 	
 	GetGlobalOptions (&opts);
-	if (opts.res == OPTVAL_CUSTOM)
+	/*if (opts.res == OPTVAL_CUSTOM)
 	{
 		choices[0].numopts = RES_OPTS + 1;
 	}
 	else
-	{
+	{*/
 		choices[0].numopts = RES_OPTS;
-	}
+	//}
 	choices[0].selected = opts.res;
 	choices[1].selected = opts.driver;
 	choices[2].selected = opts.scaler;
@@ -387,6 +398,7 @@ SetDefaults (void)
 	choices[19].selected = opts.player2;
 	choices[20].selected = 0;
 	choices[21].selected = opts.musicremix;
+	choices[22].selected = opts.loresBlowup; // JMS
 
 	sliders[0].value = opts.musicvol;
 	sliders[1].value = opts.sfxvol;
@@ -418,6 +430,7 @@ PropagateResults (void)
 	opts.player1 = choices[18].selected;
 	opts.player2 = choices[19].selected;
 	opts.musicremix = choices[21].selected;
+	opts.loresBlowup = choices[22].selected; // JMS
 
 	opts.musicvol = sliders[0].value;
 	opts.sfxvol = sliders[1].value;
@@ -617,9 +630,15 @@ init_widgets (void)
 		bank = StringBank_Create ();
 	}
 	
-	if (setup_frame == NULL)
+	if (setup_frame == NULL || resFactorWasChanged)
 	{
-		setup_frame = CaptureDrawable (LoadGraphic (MENUBKG_PMAP_ANIM));
+		// JMS: Load the different menus depending on the resolution factor.
+		if (resolutionFactor < 1)
+			setup_frame = CaptureDrawable (LoadGraphic (MENUBKG_PMAP_ANIM));
+		if (resolutionFactor == 1)
+			setup_frame = CaptureDrawable (LoadGraphic (MENUBKG_PMAP_ANIM2X));
+		if (resolutionFactor > 1)
+			setup_frame = CaptureDrawable (LoadGraphic (MENUBKG_PMAP_ANIM4X));
 	}
 
 	count = GetStringTableCount (SetupTab);
@@ -635,7 +654,7 @@ init_widgets (void)
 	if (SplitString (GetStringAddress (SetAbsStringTableIndex (SetupTab, 1)), '\n', 100, buffer, bank) != MENU_COUNT)
 	{
 		/* TODO: Ignore extras instead of dying. */
-		log_add (log_Fatal, "PANIC: Incorrect number of Menu Subtitles");
+		log_add (log_Fatal, "PANIC: Incorrect number of Menu Subtitles:");
 		exit (EXIT_FAILURE);
 	}
 
@@ -661,7 +680,7 @@ init_widgets (void)
 	/* Options */
 	if (SplitString (GetStringAddress (SetAbsStringTableIndex (SetupTab, 2)), '\n', 100, buffer, bank) != CHOICE_COUNT)
 	{
-		log_add (log_Fatal, "PANIC: Incorrect number of Choice Options");
+		log_add (log_Fatal, "PANIC: Incorrect number of Choice Options: %d. Should be %d", CHOICE_COUNT, SplitString (GetStringAddress (SetAbsStringTableIndex (SetupTab, 2)), '\n', 100, buffer, bank));
 		exit (EXIT_FAILURE);
 	}
 
@@ -1117,8 +1136,10 @@ GetGlobalOptions (GLOBALOPTS *opts)
 		opts->aquality = OPTVAL_MEDIUM;
 	}
 
+	
 	/* Work out resolution.  On the way, try to guess a good default
 	 * for config.alwaysgl, then overwrite it if it was set previously. */
+	opts->loresBlowup = res_GetInteger ("config.loresBlowupScale");
 	opts->driver = OPTVAL_PURE_IF_POSSIBLE;
 	switch (ScreenWidthActual)
 	{
@@ -1129,57 +1150,43 @@ GetGlobalOptions (GLOBALOPTS *opts)
 		}
 		else
 		{
-			if (ScreenHeightActual != 240)
-			{
-				opts->res = OPTVAL_CUSTOM;
-			}
-			else
-			{
-				opts->res = OPTVAL_320_240;
-				opts->driver = OPTVAL_ALWAYS_GL;
-			}
+			opts->res = OPTVAL_320_240;
+			opts->driver = OPTVAL_ALWAYS_GL;
 		}
 		break;
 	case 640:
-		if (GraphicsDriver == TFB_GFXDRIVER_SDL_PURE)
-		{
-			opts->res = OPTVAL_640_480;
-		}
-		else
+		if (resolutionFactor == 1) // JMS_GFX
 		{
-			if (ScreenHeightActual != 480)
-			{
-				opts->res = OPTVAL_CUSTOM;
-			}
-			else
-			{
-				opts->res = OPTVAL_640_480;
-				opts->driver = OPTVAL_ALWAYS_GL;
-			}
+			opts->res = OPTVAL_REAL_640_480;
+			opts->loresBlowup = NO_BLOWUP;
 		}
-		break;
-	case 800:
-		if (ScreenHeightActual != 600)
+		else if (GraphicsDriver == TFB_GFXDRIVER_SDL_PURE)
 		{
-			opts->res = OPTVAL_CUSTOM;
+			opts->res = OPTVAL_320_240;
+			opts->loresBlowup = OPTVAL_320_TO_640;
 		}
 		else
 		{
-			opts->res = OPTVAL_800_600;
+			opts->res = OPTVAL_320_240;
+			opts->loresBlowup = OPTVAL_320_TO_640;
+			opts->driver = OPTVAL_ALWAYS_GL;
 		}
 		break;
+	case 800:
+		opts->res = OPTVAL_320_240;
+		opts->loresBlowup = OPTVAL_320_TO_800;
+		break;
 	case 1024:
-		if (ScreenHeightActual != 768)
-		{
-			opts->res = OPTVAL_CUSTOM;
-		}
-		else
-		{
-			opts->res = OPTVAL_1024_768;
-		}		
+		opts->res = OPTVAL_320_240;
+		opts->loresBlowup = OPTVAL_320_TO_1024;	
 		break;
+	case 1280:							 // DC_GFX
+		opts->res = OPTVAL_REAL_1280_960;// DC_GFX
+		opts->loresBlowup = NO_BLOWUP;	 // DC_GFX
+		break;							 // DC_GFX
 	default:
-		opts->res = OPTVAL_CUSTOM;
+		opts->res = OPTVAL_320_240;
+		opts->loresBlowup = NO_BLOWUP;
 		break;
 	}
 
@@ -1201,7 +1208,6 @@ GetGlobalOptions (GLOBALOPTS *opts)
 	opts->musicvol = (((int)(musicVolumeScale * 100.0f) + 2) / 5) * 5;
 	opts->sfxvol = (((int)(sfxVolumeScale * 100.0f) + 2) / 5) * 5;
 	opts->speechvol = (((int)(speechVolumeScale * 100.0f) + 2) / 5) * 5;
-	
 }
 
 void
@@ -1211,9 +1217,11 @@ SetGlobalOptions (GLOBALOPTS *opts)
 	int NewWidth = ScreenWidthActual;
 	int NewHeight = ScreenHeightActual;
 	int NewDriver = GraphicsDriver;
+	
+	unsigned int oldResFactor = resolutionFactor; // JMS_GFX
 
 	NewGfxFlags &= ~TFB_GFXFLAGS_SCALE_ANY;
-
+	
 	switch (opts->res) {
 	case OPTVAL_320_240:
 		NewWidth = 320;
@@ -1223,35 +1231,72 @@ SetGlobalOptions (GLOBALOPTS *opts)
 #else
 		NewDriver = TFB_GFXDRIVER_SDL_PURE;
 #endif
+		resolutionFactor = 0;				// JMS_GFX
 		break;
-	case OPTVAL_640_480:
-		NewWidth = 640;
-		NewHeight = 480;
-#ifdef HAVE_OPENGL	       
-		NewDriver = (opts->driver == OPTVAL_ALWAYS_GL ? TFB_GFXDRIVER_SDL_OPENGL : TFB_GFXDRIVER_SDL_PURE);
-#else
-		NewDriver = TFB_GFXDRIVER_SDL_PURE;
-#endif
-		break;
-	case OPTVAL_800_600:
-		NewWidth = 800;
-		NewHeight = 600;
-		NewDriver = TFB_GFXDRIVER_SDL_OPENGL;
-		break;
-	case OPTVAL_1024_768:
-		NewWidth = 1024;
-		NewHeight = 768;
-		NewDriver = TFB_GFXDRIVER_SDL_OPENGL;
-		break;
+	case OPTVAL_REAL_640_480:				// JMS_GFX
+		NewWidth = 640;						// JMS_GFX
+		NewHeight = 480;					// JMS_GFX
+		NewDriver = TFB_GFXDRIVER_SDL_PURE; // JMS_GFX
+		resolutionFactor = 1;				// JMS_GFX
+		break;								// JMS_GFX
+	case OPTVAL_REAL_1280_960:				// JMS_GFX
+		NewWidth = 1280;					// JMS_GFX
+		NewHeight = 960;					// JMS_GFX
+		NewDriver = TFB_GFXDRIVER_SDL_PURE; // JMS_GFX
+		resolutionFactor = 2;				// JMS_GFX
+		break;								// JMS_GFX
 	default:
 		/* Don't mess with the custom value */
+		resolutionFactor = 0; // JMS_GFX
 		break;
 	}
-
+	
+	if (NewWidth == 320 && NewHeight == 240)
+	{
+		switch (opts->loresBlowup) {
+			case NO_BLOWUP:
+				// JMS: Default value: Don't do anything.
+				break;
+			case OPTVAL_320_TO_640:					// JMS_GFX
+				NewWidth = 640;						// JMS_GFX
+				NewHeight = 480;					// JMS_GFX
+#ifdef HAVE_OPENGL	       
+				NewDriver = (opts->driver == OPTVAL_ALWAYS_GL ? TFB_GFXDRIVER_SDL_OPENGL : TFB_GFXDRIVER_SDL_PURE);
+#else
+				NewDriver = TFB_GFXDRIVER_SDL_PURE;
+#endif
+				resolutionFactor = 0;				// JMS_GFX
+				break;
+			case OPTVAL_320_TO_800:					// JMS_GFX
+				NewWidth = 800;						// JMS_GFX
+				NewHeight = 600;					// JMS_GFX
+				NewDriver = TFB_GFXDRIVER_SDL_OPENGL;// JMS_GFX
+				resolutionFactor = 0;				// JMS_GFX
+				break;								// JMS_GFX
+			case OPTVAL_320_TO_1024:				// JMS_GFX
+				NewWidth = 1024;					// JMS_GFX
+				NewHeight = 768;					// JMS_GFX
+				NewDriver = TFB_GFXDRIVER_SDL_OPENGL;// JMS_GFX
+				resolutionFactor = 0;				// JMS_GFX
+				break;								// JMS_GFX
+			default:
+				break;
+		}
+	}
+	else
+		opts->loresBlowup = NO_BLOWUP;
+	
+	if (oldResFactor != resolutionFactor)
+		resFactorWasChanged = TRUE;
+	
 	res_PutInteger ("config.reswidth", NewWidth);
 	res_PutInteger ("config.resheight", NewHeight);
 	res_PutBoolean ("config.alwaysgl", opts->driver == OPTVAL_ALWAYS_GL);
 	res_PutBoolean ("config.usegl", NewDriver == TFB_GFXDRIVER_SDL_OPENGL);
+	
+	// JMS_GFX
+	res_PutInteger ("config.resolutionfactor", resolutionFactor);
+	res_PutInteger ("config.loresBlowupScale", opts->loresBlowup);
 
 	switch (opts->scaler) {
 	case OPTVAL_BILINEAR_SCALE:
@@ -1296,10 +1341,31 @@ SetGlobalOptions (GLOBALOPTS *opts)
 	if ((NewWidth != ScreenWidthActual) ||
 	    (NewHeight != ScreenHeightActual) ||
 	    (NewDriver != GraphicsDriver) ||
+		(resFactorWasChanged) || // JMS_GFX
 	    (NewGfxFlags != GfxFlags)) 
 	{
 		FlushGraphics ();
 		UninitVideoPlayer ();
+		
+		// JMS_GFX
+		if (resFactorWasChanged)
+		{
+			// Tell the game the new screen's size.
+			ScreenWidth  = 320 << resolutionFactor; // res_GetInteger ("config.reswidth");
+			ScreenHeight = 240 << resolutionFactor; // res_GetInteger ("config.resheight");
+			
+			// These solve the FUCKING context problem that plagued the setupmenu when changing to higher resolution.
+			TFB_BBox_Reset ();
+			TFB_BBox_Init (ScreenWidth, ScreenHeight);
+		
+			// Change how big area of the screen is update-able.
+			DestroyDrawable (ReleaseDrawable (Screen));
+			Screen = CaptureDrawable (CreateDisplay (WANT_MASK | WANT_PIXMAP, &screen_width, &screen_height));
+			SetContext (ScreenContext);
+			SetContextFGFrame ((FRAME)NULL);
+			SetContextFGFrame (Screen);
+		}
+		
 		TFB_DrawScreen_ReinitVideo (NewDriver, NewGfxFlags, NewWidth, NewHeight);
 		FlushGraphics ();
 		InitVideoPlayer (TRUE);
@@ -1311,7 +1377,12 @@ SetGlobalOptions (GLOBALOPTS *opts)
 	optWhichCoarseScan = (opts->cscan == OPTVAL_3DO) ? OPT_3DO : OPT_PC;
 	optSmoothScroll = (opts->scroll == OPTVAL_3DO) ? OPT_3DO : OPT_PC;
 	optWhichShield = (opts->shield == OPTVAL_3DO) ? OPT_3DO : OPT_PC;
-	optMeleeScale = (opts->meleezoom == OPTVAL_3DO) ? TFB_SCALE_TRILINEAR : TFB_SCALE_STEP;
+	
+	// JMS: Originally, the smooth zoom was TFB_SCALE_TRILINEAR instead of bilinear.
+	// Using bilinear alleviates the smooth zoom performance choppiness problems in 2x and 4x, but
+	// is kinda hacky solution...
+	optMeleeScale = (opts->meleezoom == OPTVAL_3DO) ? TFB_SCALE_BILINEAR : TFB_SCALE_STEP;
+	
 	optWhichIntro = (opts->intro == OPTVAL_3DO) ? OPT_3DO : OPT_PC;
 	PlayerControls[0] = opts->player1;
 	PlayerControls[1] = opts->player2;
diff -ruNp src.orig/uqm/setupmenu.h src/uqm/setupmenu.h
--- src.orig/uqm/setupmenu.h	2017-11-01 15:30:26 -0700
+++ src/uqm/setupmenu.h	2017-11-01 15:31:04 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2011: Merged resolution Factor stuff from UQM-HD.
+
 #ifndef _SETUPMENU_H
 #define _SETUPMENU_H
 
@@ -42,13 +44,18 @@ typedef enum {
 
 typedef enum {
 	OPTVAL_320_240,
-	OPTVAL_640_480,
-	OPTVAL_800_600,
-	OPTVAL_1024_768,
-	OPTVAL_CUSTOM
+	OPTVAL_REAL_640_480, // JMS_GFX
+	OPTVAL_REAL_1280_960, // DC_GFX
 } OPT_RESTYPE;
 
 typedef enum {
+	NO_BLOWUP,
+	OPTVAL_320_TO_640,
+	OPTVAL_320_TO_800,
+	OPTVAL_320_TO_1024,
+} OPT_LORESBLOWUPTYPE;
+
+typedef enum {
 	OPTVAL_PURE_IF_POSSIBLE,
 	OPTVAL_ALWAYS_GL
 } OPT_DRIVERTYPE;
@@ -71,6 +78,7 @@ typedef enum {
 typedef struct globalopts_struct {
 	OPT_SCALETYPE scaler;
 	OPT_RESTYPE res;
+	OPT_LORESBLOWUPTYPE loresBlowup;
 	OPT_DRIVERTYPE driver;
 	OPT_ADRIVERTYPE adriver;
 	OPT_AQUALITYTYPE aquality;
diff -ruNp src.orig/uqm/ship.c src/uqm/ship.c
--- src.orig/uqm/ship.c	2017-11-01 15:30:26 -0700
+++ src/uqm/ship.c	2017-11-01 15:31:04 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010 - Enable Down key in melee (comment tag JMS_KEYS)
+
 #include "ship.h"
 
 #include "build.h"
@@ -35,6 +37,7 @@
 #include "sounds.h"
 #include "libs/mathlib.h"
 
+#include "libs/log.h"
 
 void
 animation_preprocess (ELEMENT *ElementPtr)
@@ -55,7 +58,7 @@ animation_preprocess (ELEMENT *ElementPt
 STATUS_FLAGS
 inertial_thrust (ELEMENT *ElementPtr)
 {
-#define MAX_ALLOWED_SPEED     WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (18))
+#define MAX_ALLOWED_SPEED     WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (18 << RESOLUTION_FACTOR)) // JMS_GFX
 #define MAX_ALLOWED_SPEED_SQR ((DWORD)MAX_ALLOWED_SPEED * MAX_ALLOWED_SPEED)
 
 	COUNT CurrentAngle, TravelAngle;
@@ -97,6 +100,14 @@ inertial_thrust (ELEMENT *ElementPtr)
 		delta_x = cur_delta_x + COSINE (CurrentAngle, thrust_increment);
 		delta_y = cur_delta_y + SINE (CurrentAngle, thrust_increment);
 		desired_speed = VelocitySquared (delta_x, delta_y);
+
+        // In Orz Space, max speed is proportion to distance from bottom edge!
+        if (ENABLE_NON_EUCLIDEAN_ORZ_SPACE && GET_GAME_STATE (ORZ_SPACE_SIDE) > 1)
+        {
+            float prop = 1.0 - GLOBAL_SIS (log_y) / (float) MAX_X_LOGICAL;
+            max_thrust *= prop;
+        }
+
 		max_speed = VelocitySquared (WORLD_TO_VELOCITY (max_thrust), 0);
 		
 		if (desired_speed <= max_speed)
@@ -158,11 +169,11 @@ ship_preprocess (ELEMENT *ElementPtr)
 
 	cur_status_flags =
 			StarShipPtr->cur_status_flags
-			& ~(LEFT | RIGHT | THRUST | WEAPON | SPECIAL);
+			& ~(LEFT | RIGHT | THRUST | WEAPON | SPECIAL | DOWN); // JMS_KEYS
 	if (!(ElementPtr->state_flags & APPEARING))
 	{
 		cur_status_flags |= StarShipPtr->ship_input_state
-				& (LEFT | RIGHT | THRUST | WEAPON | SPECIAL);
+				& (LEFT | RIGHT | THRUST | WEAPON | SPECIAL | DOWN); // JMS_KEYS
 	}
 	else
 	{	// Preprocessing for the first time
@@ -186,7 +197,7 @@ ship_preprocess (ELEMENT *ElementPtr)
 		{
 			CONTEXT OldContext;
 
-			InitShipStatus (&RDPtr->ship_info, StarShipPtr, NULL);
+			InitShipStatus (&RDPtr->ship_info, StarShipPtr, NULL, FALSE);
 			OldContext = SetContext (StatusContext);
 			DrawCaptainsWindow (StarShipPtr);
 			SetContext (OldContext);
@@ -339,6 +350,9 @@ ship_postprocess (ELEMENT *ElementPtr)
 	if (StarShipPtr->special_counter)
 		--StarShipPtr->special_counter;
 
+	if (StarShipPtr->auxiliary_counter)
+		--StarShipPtr->auxiliary_counter;
+
 	if (RDPtr->postprocess_func)
 		(*RDPtr->postprocess_func) (ElementPtr);
 
@@ -407,6 +421,7 @@ spawn_ship (STARSHIP *StarShipPtr)
 	StarShipPtr->energy_counter = 0;
 	StarShipPtr->weapon_counter = 0;
 	StarShipPtr->special_counter = 0;
+	StarShipPtr->auxiliary_counter = 0;
 
 	hShip = StarShipPtr->hShip;
 	if (hShip == 0)
@@ -519,6 +534,7 @@ GetNextStarShip (STARSHIP *LastStarShipP
 		if (!spawn_ship (StarShipPtr))
 		{
 			UnlockStarShip (&race_q[which_side], hBattleShip);
+			
 			return (FALSE);
 		}
 		UnlockStarShip (&race_q[which_side], hBattleShip);
diff -ruNp src.orig/uqm/shipcont.h src/uqm/shipcont.h
--- src.orig/uqm/shipcont.h	2017-11-01 15:30:26 -0700
+++ src/uqm/shipcont.h	2017-11-01 15:31:04 -0700
@@ -21,7 +21,7 @@
 
 #include "menustat.h"
 
-#define FIELD_WIDTH (STATUS_WIDTH - 5)
+#define FIELD_WIDTH (STATUS_WIDTH - RES_STAT_SCALE(5)) // JMS_GFX
 
 extern void CargoMenu (void);
 extern BOOLEAN RosterMenu (void);
diff -ruNp src.orig/uqm/ships/Makeinfo src/uqm/ships/Makeinfo
--- src.orig/uqm/ships/Makeinfo	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/Makeinfo	2017-11-01 15:31:04 -0700
@@ -1,4 +1,4 @@
-uqm_SUBDIRS="androsyn arilou blackurq chenjesu chmmr druuge human ilwrath
-		lastbat melnorme mmrnmhrm mycon orz pkunk probe shofixti sis_ship
-		slylandr spathi supox syreen thradd umgah urquan utwig vux yehat
+uqm_SUBDIRS="androsyn arilou baul blackurq chenjesu chmmr druuge foonfoon human ilwrath isd
+		lastbat lurg melnorme mmrnmhrm mycon orz pkunk probe shofixti sis_ship
+		slylandr slykohr spathi supox syreen thradd transport umgah urquan utwig vux yehat
 		zoqfot"
diff -ruNp src.orig/uqm/ships/androsyn/androsyn.c src/uqm/ships/androsyn/androsyn.c
--- src.orig/uqm/ships/androsyn/androsyn.c	2017-11-01 15:30:26 -0700
+++ src/uqm/ships/androsyn/androsyn.c	2017-11-01 15:31:04 -0700
@@ -48,13 +48,12 @@ static RACE_DESC androsynth_desc =
 		ANDROSYNTH_RACE_STRINGS,
 		ANDROSYNTH_ICON_MASK_PMAP_ANIM,
 		ANDROSYNTH_MICON_MASK_PMAP_ANIM,
-		NULL, NULL, NULL
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
 	},
 	{ /* FLEET_STUFF */
-		INFINITE_RADIUS, /* Initial sphere of influence radius */
-				// XXX: Why infinite radius? Bug?
+		0 / SPHERE_RADIUS_INCREMENT * 2, /* Initial sphere of influence radius */
 		{ /* Known location (center of SoI) */
-			MAX_X_UNIVERSE >> 1, MAX_Y_UNIVERSE >> 1,
+			6816, 4970,
 		},
 	},
 	{
@@ -110,6 +109,156 @@ static RACE_DESC androsynth_desc =
 	0, /* CodeRef */
 };
 
+#define MAX_THRUST_2XRES 48  // JMS_GFX
+#define THRUST_INCREMENT_2XRES 6 // JMS_GFX
+
+ // JMS_GFX
+static RACE_DESC androsynth_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_WEAPON,
+		15, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ANDROSYNTH_RACE_STRINGS,
+		ANDROSYNTH_ICON_MASK_PMAP_ANIM,
+		ANDROSYNTH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0 / SPHERE_RADIUS_INCREMENT * 2, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			6816, 4970,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ANDROSYNTH_BIG_MASK_PMAP_ANIM,
+			ANDROSYNTH_MED_MASK_PMAP_ANIM,
+			ANDROSYNTH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BUBBLE_BIG_MASK_PMAP_ANIM,
+			BUBBLE_MED_MASK_PMAP_ANIM,
+			BUBBLE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BLAZER_BIG_MASK_PMAP_ANIM,
+			BLAZER_MED_MASK_PMAP_ANIM,
+			BLAZER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ANDROSYNTH_CAPT_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ANDROSYNTH_VICTORY_SONG,
+		ANDROSYNTH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		LONG_RANGE_WEAPON_2XRES >> 2,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+#define MAX_THRUST_4XRES 96  // JMS_GFX
+#define THRUST_INCREMENT_4XRES 12 // JMS_GFX
+
+// JMS_GFX
+static RACE_DESC androsynth_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_WEAPON,
+		15, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ANDROSYNTH_RACE_STRINGS,
+		ANDROSYNTH_ICON_MASK_PMAP_ANIM,
+		ANDROSYNTH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0 / SPHERE_RADIUS_INCREMENT * 2, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			6816, 4970,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ANDROSYNTH_BIG_MASK_PMAP_ANIM,
+			ANDROSYNTH_MED_MASK_PMAP_ANIM,
+			ANDROSYNTH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BUBBLE_BIG_MASK_PMAP_ANIM,
+			BUBBLE_MED_MASK_PMAP_ANIM,
+			BUBBLE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BLAZER_BIG_MASK_PMAP_ANIM,
+			BLAZER_MED_MASK_PMAP_ANIM,
+			BLAZER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ANDROSYNTH_CAPT_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ANDROSYNTH_VICTORY_SONG,
+		ANDROSYNTH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		LONG_RANGE_WEAPON_4XRES >> 2,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 #define BLAZER_DAMAGE 3
 #define BLAZER_MASS 1
 
@@ -117,27 +266,30 @@ static void
 blazer_collision (ELEMENT *ElementPtr0, POINT *pPt0,
 		ELEMENT *ElementPtr1, POINT *pPt1)
 {
-#define BLAZER_OFFSET 10
+#define BLAZER_OFFSET (10 << RESOLUTION_FACTOR) // JMS_GFX
 	BYTE old_offs;
 	COUNT old_crew_level;
 	COUNT old_life;
-
-	old_crew_level = ElementPtr0->crew_level;
-	old_life = ElementPtr0->life_span;
-	old_offs = ElementPtr0->blast_offset;
-	ElementPtr0->blast_offset = BLAZER_OFFSET;
-	ElementPtr0->mass_points = BLAZER_DAMAGE;
-	weapon_collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
-	ElementPtr0->mass_points = BLAZER_MASS;
-	ElementPtr0->blast_offset = old_offs;
-	ElementPtr0->life_span = old_life;
-	ElementPtr0->crew_level = old_crew_level;
-
-	ElementPtr0->state_flags &= ~(DISAPPEARING | NONSOLID);
-	collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
+	
+	// JMS: This prevents the Blazer from getting stuck to Baul Gas clouds.
+	if (!(ElementPtr1->state_flags & GASSY_SUBSTANCE))
+	{
+		old_crew_level = ElementPtr0->crew_level;
+		old_life = ElementPtr0->life_span;
+		old_offs = ElementPtr0->blast_offset;
+		ElementPtr0->blast_offset = BLAZER_OFFSET;
+		ElementPtr0->mass_points = BLAZER_DAMAGE;
+		weapon_collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
+		ElementPtr0->mass_points = BLAZER_MASS;
+		ElementPtr0->blast_offset = old_offs;
+		ElementPtr0->life_span = old_life;
+		ElementPtr0->crew_level = old_crew_level;
+		ElementPtr0->state_flags &= ~(DISAPPEARING | NONSOLID);
+		collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
+	}
 }
 
-#define MISSILE_SPEED DISPLAY_TO_WORLD (8)
+#define MISSILE_SPEED DISPLAY_TO_WORLD (8 << RESOLUTION_FACTOR) // JMS_GFX
 
 static void
 bubble_preprocess (ELEMENT *ElementPtr)
@@ -188,8 +340,8 @@ bubble_preprocess (ELEMENT *ElementPtr)
 static COUNT
 initialize_bubble (ELEMENT *ShipPtr, HELEMENT BubbleArray[])
 {
-#define ANDROSYNTH_OFFSET 14
-#define MISSILE_OFFSET 3
+#define ANDROSYNTH_OFFSET (14 << RESOLUTION_FACTOR) // JMS_GFX
+#define MISSILE_OFFSET (3 << RESOLUTION_FACTOR) // JMS_GFX
 #define MISSILE_HITS 3
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
@@ -256,10 +408,11 @@ androsynth_intelligence (ELEMENT *ShipPt
 		if (lpEvalDesc->ObjectPtr)
 		{
 			GetElementStarShip (lpEvalDesc->ObjectPtr, &pEnemyStarShip);
+			// JMS_GFX
 			if (lpEvalDesc->which_turn <= 16
 					&& (StarShipPtr->special_counter > 0
 					|| StarShipPtr->RaceDescPtr->ship_info.energy_level < MAX_ENERGY / 3
-					|| ((WEAPON_RANGE (&pEnemyStarShip->RaceDescPtr->cyborg_control) <= CLOSE_RANGE_WEAPON
+					|| ((WEAPON_RANGE (&pEnemyStarShip->RaceDescPtr->cyborg_control) <= (CLOSE_RANGE_WEAPON << RESOLUTION_FACTOR)
 					&& lpEvalDesc->ObjectPtr->crew_level > BLAZER_DAMAGE)
 					|| (lpEvalDesc->ObjectPtr->crew_level > (BLAZER_DAMAGE * 3)
 					&& MANEUVERABILITY (&pEnemyStarShip->RaceDescPtr->cyborg_control) > SLOW_SHIP))))
@@ -271,6 +424,7 @@ androsynth_intelligence (ELEMENT *ShipPt
 		if (StarShipPtr->special_counter == 0)
 		{
 			StarShipPtr->ship_input_state &= ~SPECIAL;
+			// JMS_GFX
 			if ((ObjectsOfConcern[ENEMY_WEAPON_INDEX].ObjectPtr
 					&& ObjectsOfConcern[ENEMY_WEAPON_INDEX].which_turn <= 4)
 					|| (lpEvalDesc->ObjectPtr
@@ -278,7 +432,7 @@ androsynth_intelligence (ELEMENT *ShipPt
 					&& (WEAPON_RANGE (&pEnemyStarShip->RaceDescPtr->cyborg_control) >=
 					WEAPON_RANGE (&StarShipPtr->RaceDescPtr->cyborg_control) << 1
 					|| (lpEvalDesc->which_turn < 16
-					&& (WEAPON_RANGE (&pEnemyStarShip->RaceDescPtr->cyborg_control) > CLOSE_RANGE_WEAPON
+					&& (WEAPON_RANGE (&pEnemyStarShip->RaceDescPtr->cyborg_control) > (CLOSE_RANGE_WEAPON << RESOLUTION_FACTOR)
 					|| lpEvalDesc->ObjectPtr->crew_level <= BLAZER_DAMAGE)
 					&& (lpEvalDesc->ObjectPtr->crew_level <= (BLAZER_DAMAGE * 3)
 					|| MANEUVERABILITY (&pEnemyStarShip->RaceDescPtr->cyborg_control) <=
@@ -441,7 +595,7 @@ androsynth_preprocess (ELEMENT *ElementP
 				--ElementPtr->thrust_wait;
 			else
 			{
-#define BLAZER_THRUST 60
+#define BLAZER_THRUST (60 << RESOLUTION_FACTOR) // JMS_GFX
 				COUNT facing;
 
 				facing = StarShipPtr->ShipFacing;
@@ -468,12 +622,31 @@ init_androsynth (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	androsynth_desc.preprocess_func = androsynth_preprocess;
-	androsynth_desc.postprocess_func = androsynth_postprocess;
-	androsynth_desc.init_weapon_func = initialize_bubble;
-	androsynth_desc.cyborg_control.intelligence_func = androsynth_intelligence;
-
-	RaceDescPtr = &androsynth_desc;
+	// JMS_GFX: A rather clumsy way of giving ship correct stats at hi-res modes.
+	if (RESOLUTION_FACTOR == 0)
+	{
+		androsynth_desc.preprocess_func = androsynth_preprocess;
+		androsynth_desc.postprocess_func = androsynth_postprocess;
+		androsynth_desc.init_weapon_func = initialize_bubble;
+		androsynth_desc.cyborg_control.intelligence_func = androsynth_intelligence;
+		RaceDescPtr = &androsynth_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		androsynth_desc_2xres.preprocess_func = androsynth_preprocess;
+		androsynth_desc_2xres.postprocess_func = androsynth_postprocess;
+		androsynth_desc_2xres.init_weapon_func = initialize_bubble;
+		androsynth_desc_2xres.cyborg_control.intelligence_func = androsynth_intelligence;
+		RaceDescPtr = &androsynth_desc_2xres;
+	}
+	else
+	{
+		androsynth_desc_4xres.preprocess_func = androsynth_preprocess;
+		androsynth_desc_4xres.postprocess_func = androsynth_postprocess;
+		androsynth_desc_4xres.init_weapon_func = initialize_bubble;
+		androsynth_desc_4xres.cyborg_control.intelligence_func = androsynth_intelligence;
+		RaceDescPtr = &androsynth_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp src.orig/uqm/ships/androsyn/icode.h src/uqm/ships/androsyn/icode.h
--- src.orig/uqm/ships/androsyn/icode.h	2017-11-01 15:30:26 -0700
+++ src/uqm/ships/androsyn/icode.h	2017-11-01 15:31:04 -0700
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define ANDROSYNTH_CODE "ship.androsynth.code"
diff -ruNp src.orig/uqm/ships/arilou/arilou.c src/uqm/ships/arilou/arilou.c
--- src.orig/uqm/ships/arilou/arilou.c	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/arilou/arilou.c	2017-11-01 15:31:04 -0700
@@ -50,10 +50,10 @@ static RACE_DESC arilou_desc =
 		ARILOU_RACE_STRINGS,
 		ARILOU_ICON_MASK_PMAP_ANIM,
 		ARILOU_MICON_MASK_PMAP_ANIM,
-		NULL, NULL, NULL
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
 	},
 	{ /* FLEET_STUFF */
-		250 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		0, // JMS: Was 250 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
 		{ /* Known location (center of SoI) */
 			438, 6372,
 		},
@@ -111,6 +111,162 @@ static RACE_DESC arilou_desc =
 	0, /* CodeRef */
 };
 
+#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (20) */ 80					// JMS_GFX
+#define THRUST_INCREMENT_2XRES MAX_THRUST_2XRES							// JMS_GFX
+#define ARILOU_OFFSET_2XRES 18											// JMS_GFX
+#define LASER_RANGE_2XRES DISPLAY_TO_WORLD (200 + ARILOU_OFFSET_2XRES)	// JMS_GFX
+
+// JMS_GFX
+static RACE_DESC arilou_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		/* FIRES_FORE | */ IMMEDIATE_WEAPON,
+		16, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ARILOU_RACE_STRINGS,
+		ARILOU_ICON_MASK_PMAP_ANIM,
+		ARILOU_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, // JMS: Was 250 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			438, 6372,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ARILOU_BIG_MASK_PMAP_ANIM,
+			ARILOU_MED_MASK_PMAP_ANIM,
+			ARILOU_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			WARP_BIG_MASK_PMAP_ANIM,
+			WARP_MED_MASK_PMAP_ANIM,
+			WARP_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ARILOU_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ARILOU_VICTORY_SONG,
+		ARILOU_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		LASER_RANGE_2XRES >> 1,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (20) */ 160				// JMS_GFX
+#define THRUST_INCREMENT_4XRES MAX_THRUST_4XRES							// JMS_GFX
+#define ARILOU_OFFSET_4XRES 36											// JMS_GFX
+#define LASER_RANGE_4XRES DISPLAY_TO_WORLD (400 + ARILOU_OFFSET_4XRES)	// JMS_GFX
+
+// JMS_GFX
+static RACE_DESC arilou_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		/* FIRES_FORE | */ IMMEDIATE_WEAPON,
+		16, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ARILOU_RACE_STRINGS,
+		ARILOU_ICON_MASK_PMAP_ANIM,
+		ARILOU_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, // JMS: Was 250 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			438, 6372,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ARILOU_BIG_MASK_PMAP_ANIM,
+			ARILOU_MED_MASK_PMAP_ANIM,
+			ARILOU_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			WARP_BIG_MASK_PMAP_ANIM,
+			WARP_MED_MASK_PMAP_ANIM,
+			WARP_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ARILOU_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ARILOU_VICTORY_SONG,
+		ARILOU_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		LASER_RANGE_4XRES >> 1,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+
+
 static COUNT
 initialize_autoaim_laser (ELEMENT *ShipPtr, HELEMENT LaserArray[])
 {
@@ -118,6 +274,16 @@ initialize_autoaim_laser (ELEMENT *ShipP
 	SIZE delta_facing;
 	STARSHIP *StarShipPtr;
 	LASER_BLOCK LaserBlock;
+	
+	COUNT laser_range_resscaled; // JMS_GFX
+	
+	// JMS_GFX
+	if (RESOLUTION_FACTOR == 0)
+		laser_range_resscaled = LASER_RANGE;
+	else if (RESOLUTION_FACTOR == 1)
+		laser_range_resscaled = LASER_RANGE_2XRES;
+	else
+		laser_range_resscaled = LASER_RANGE_4XRES;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	LaserBlock.face = orig_facing = StarShipPtr->ShipFacing;
@@ -127,11 +293,11 @@ initialize_autoaim_laser (ELEMENT *ShipP
 
 	LaserBlock.cx = ShipPtr->next.location.x;
 	LaserBlock.cy = ShipPtr->next.location.y;
-	LaserBlock.ex = COSINE (FACING_TO_ANGLE (LaserBlock.face), LASER_RANGE);
-	LaserBlock.ey = SINE (FACING_TO_ANGLE (LaserBlock.face), LASER_RANGE);
+	LaserBlock.ex = COSINE (FACING_TO_ANGLE (LaserBlock.face), laser_range_resscaled);
+	LaserBlock.ey = SINE (FACING_TO_ANGLE (LaserBlock.face), laser_range_resscaled);
 	LaserBlock.sender = ShipPtr->playerNr;
 	LaserBlock.flags = IGNORE_SIMILAR;
-	LaserBlock.pixoffs = ARILOU_OFFSET;
+	LaserBlock.pixoffs = ARILOU_OFFSET << RESOLUTION_FACTOR; // JMS_GFX
 	LaserBlock.color = BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x0A), 0x0E);
 	LaserArray[0] = initialize_laser (&LaserBlock);
 
@@ -147,7 +313,7 @@ arilou_intelligence (ELEMENT *ShipPtr, E
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	StarShipPtr->ship_input_state |= THRUST;
 
-	 ObjectsOfConcern[ENEMY_SHIP_INDEX].MoveState = ENTICE;
+	ObjectsOfConcern[ENEMY_SHIP_INDEX].MoveState = ENTICE;
 	ship_intelligence (ShipPtr, ObjectsOfConcern, ConcernCounter);
 
 	if (StarShipPtr->special_counter == 0)
@@ -175,10 +341,16 @@ arilou_intelligence (ELEMENT *ShipPtr, E
 			else
 				IsTrackingWeapon = FALSE;
 
+			// JMS: Added the GASSY_SUBSTANCE clauses to prevent 'long teleport' if Baul gas is sticking to the Arilou ship.
 			if (((lpEvalDesc->ObjectPtr->state_flags & PLAYER_SHIP) /* means IMMEDIATE WEAPON */
 					|| (IsTrackingWeapon && (lpEvalDesc->which_turn == 1
 					|| (lpEvalDesc->ObjectPtr->state_flags & CREW_OBJECT))) /* FIGHTERS!!! */
-					|| PlotIntercept (lpEvalDesc->ObjectPtr, ShipPtr, 3, 0))
+					|| (PlotIntercept (lpEvalDesc->ObjectPtr, ShipPtr, 3, 0)
+						&& (!(lpEvalDesc->ObjectPtr->state_flags & GASSY_SUBSTANCE) // Ignore stuck gas
+							|| (lpEvalDesc->ObjectPtr->state_flags & GASSY_SUBSTANCE && EnemyStarShipPtr->ship_input_state & WEAPON
+								&& ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn <= 20) // If sticking to gas, teleport when Baul is near&firing primary
+							|| (lpEvalDesc->ObjectPtr->state_flags & GASSY_SUBSTANCE && lpEvalDesc->ObjectPtr->state_flags & IGNORE_VELOCITY))) // non-stuck gas
+					)
 					&& !(TFB_Random () & 3))
 			{
 				StarShipPtr->ship_input_state &= ~(LEFT | RIGHT | THRUST | WEAPON);
@@ -289,12 +461,28 @@ init_arilou (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	arilou_desc.preprocess_func = arilou_preprocess;
-	arilou_desc.init_weapon_func = initialize_autoaim_laser;
-	arilou_desc.cyborg_control.intelligence_func = arilou_intelligence;
-
-	RaceDescPtr = &arilou_desc;
-
+	// JMS_GFX: A rather clumsy way of giving ship correct stats at hi-res mode
+	if (RESOLUTION_FACTOR == 0)
+	{
+		arilou_desc.preprocess_func = arilou_preprocess;
+		arilou_desc.init_weapon_func = initialize_autoaim_laser;
+		arilou_desc.cyborg_control.intelligence_func = arilou_intelligence;
+		RaceDescPtr = &arilou_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		arilou_desc_2xres.preprocess_func = arilou_preprocess;
+		arilou_desc_2xres.init_weapon_func = initialize_autoaim_laser;
+		arilou_desc_2xres.cyborg_control.intelligence_func = arilou_intelligence;
+		RaceDescPtr = &arilou_desc_2xres;
+	}
+	else
+	{
+		arilou_desc_4xres.preprocess_func = arilou_preprocess;
+		arilou_desc_4xres.init_weapon_func = initialize_autoaim_laser;
+		arilou_desc_4xres.cyborg_control.intelligence_func = arilou_intelligence;
+		RaceDescPtr = &arilou_desc_4xres;
+	}
 	return (RaceDescPtr);
 }
 
diff -ruNp src.orig/uqm/ships/arilou/icode.h src/uqm/ships/arilou/icode.h
--- src.orig/uqm/ships/arilou/icode.h	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/arilou/icode.h	2017-11-01 15:31:04 -0700
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define ARILOU_CODE "ship.arilou.code"
diff -ruNp src.orig/uqm/ships/baul/Makeinfo src/uqm/ships/baul/Makeinfo
--- src.orig/uqm/ships/baul/Makeinfo	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/baul/Makeinfo	2017-11-01 15:31:04 -0700
@@ -0,0 +1 @@
+uqm_CFILES="baul.c"
diff -ruNp src.orig/uqm/ships/baul/baul.c src/uqm/ships/baul/baul.c
--- src.orig/uqm/ships/baul/baul.c	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/baul/baul.c	2017-11-01 15:31:04 -0700
@@ -0,0 +1,1251 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "../ship.h"
+#include "baul.h"
+#include "resinst.h"
+
+#include "uqm/globdata.h"
+#include "libs/log.h"
+
+
+#define MAX_CREW 28
+#define MAX_ENERGY 22
+#define ENERGY_REGENERATION 3
+#define WEAPON_ENERGY_COST 0
+#define SPECIAL_ENERGY_COST 2
+#define ENERGY_WAIT 24
+#define MAX_THRUST 32
+#define THRUST_INCREMENT 6
+#define TURN_WAIT 2
+#define THRUST_WAIT 5
+#define WEAPON_WAIT 18
+#define SPECIAL_WAIT 7
+
+#define SHIP_MASS 9
+#define MISSILE_SPEED DISPLAY_TO_WORLD (30)
+#define MISSILE_LIFE 10
+
+// Weapon graphics
+#define LAST_SPRAY_INDEX 5
+#define SHOCKWAVE_FRAMES 8
+#define LAST_GAS_INDEX 8
+#define LAST_SHOCKWAVE_INDEX (LAST_GAS_INDEX + SHOCKWAVE_FRAMES)
+#define NUM_DISSOLVE_FRAMES 4
+#define LAST_DISSOLVE_INDEX (LAST_SHOCKWAVE_INDEX + NUM_DISSOLVE_FRAMES)
+#define NUM_EMERGE_FRAMES 3
+
+// Weapon attributes
+#define SHOCKWAVE_RANGE (150 << RESOLUTION_FACTOR) // JMS_GFX
+#define MAX_DESTRUCTION ((SHOCKWAVE_RANGE >> RESOLUTION_FACTOR) / 25) // JMS_GFX
+
+#define GAS_HITS 100
+#define GAS_DAMAGE 0
+#define GAS_LIFE 480 // How many 1/24 secs the gas lives.
+#define GAS_OFFSET (4 << RESOLUTION_FACTOR)
+#define GAS_INIT_SPEED (100 << RESOLUTION_FACTOR) // Baul's gas now flies forward.
+#define GAS_HORZ_OFFSET (DISPLAY_TO_WORLD(5 << RESOLUTION_FACTOR))
+#define GAS_BATCH_SIZE 1
+
+#define SPRAY_HORZ_OFFSET (DISPLAY_TO_WORLD((-5) << RESOLUTION_FACTOR))
+#define MISSILE_HITS 2
+#define MISSILE_DAMAGE 1 // Must be at least 1 to make the weapon hit gas clouds.
+#define MISSILE_OFFSET (3 << RESOLUTION_FACTOR) // JMS_GFX
+#define NUM_SPRAYS 5
+#define SPRAY_DIST 4
+
+#include "../orz/orz.h"
+#define ORZ_MARINE(ptr) (ptr->preprocess_func == intruder_preprocess && ptr->collision_func == marine_collision)
+#define IS_GAS(ptr) (ptr->preprocess_func == gas_preprocess && ptr->collision_func == gas_collision && ptr->life_span > 1)
+
+static RACE_DESC baul_desc =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		21, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		BAUL_RACE_STRINGS,
+		BAUL_ICON_MASK_PMAP_ANIM,
+		BAUL_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			0,0,
+		},
+	},
+	{
+		MAX_THRUST,
+		THRUST_INCREMENT,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			BAUL_BIG_MASK_PMAP_ANIM,
+			BAUL_MED_MASK_PMAP_ANIM,
+			BAUL_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BAULSPRAY_BIG_MASK_PMAP_ANIM,
+			BAULSPRAY_MED_MASK_PMAP_ANIM,
+			BAULSPRAY_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BAULGAS_BIG_MASK_PMAP_ANIM,
+			BAULGAS_MED_MASK_PMAP_ANIM,
+			BAULGAS_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BAUL_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		BAUL_VICTORY_SONG,
+		BAUL_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(MISSILE_SPEED * MISSILE_LIFE),
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_2XRES 64
+#define THRUST_INCREMENT_2XRES 12
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
+
+// JMS_GFX
+static RACE_DESC baul_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		21, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		BAUL_RACE_STRINGS,
+		BAUL_ICON_MASK_PMAP_ANIM,
+		BAUL_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			0,0,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			BAUL_BIG_MASK_PMAP_ANIM,
+			BAUL_MED_MASK_PMAP_ANIM,
+			BAUL_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BAULSPRAY_BIG_MASK_PMAP_ANIM,
+			BAULSPRAY_MED_MASK_PMAP_ANIM,
+			BAULSPRAY_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BAULGAS_BIG_MASK_PMAP_ANIM,
+			BAULGAS_MED_MASK_PMAP_ANIM,
+			BAULGAS_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BAUL_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		BAUL_VICTORY_SONG,
+		BAUL_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(MISSILE_SPEED_2XRES * MISSILE_LIFE),
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 128
+#define THRUST_INCREMENT_4XRES 24
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
+
+// JMS_GFX
+static RACE_DESC baul_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		21, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		BAUL_RACE_STRINGS,
+		BAUL_ICON_MASK_PMAP_ANIM,
+		BAUL_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			0,0,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			BAUL_BIG_MASK_PMAP_ANIM,
+			BAUL_MED_MASK_PMAP_ANIM,
+			BAUL_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BAULSPRAY_BIG_MASK_PMAP_ANIM,
+			BAULSPRAY_MED_MASK_PMAP_ANIM,
+			BAULSPRAY_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BAULGAS_BIG_MASK_PMAP_ANIM,
+			BAULGAS_MED_MASK_PMAP_ANIM,
+			BAULGAS_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BAUL_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		BAUL_VICTORY_SONG,
+		BAUL_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(MISSILE_SPEED_4XRES * MISSILE_LIFE),
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// Forward declarations
+static void
+gas_preprocess (ELEMENT *ElementPtr);
+
+static void
+gas_collision (ELEMENT *ElementPtr0, POINT *pPt0, ELEMENT *ElementPtr1, POINT *pPt1);
+
+static void
+gas_death (ELEMENT *ElementPtr);
+
+static COUNT
+initialize_spray (ELEMENT *ShipPtr, HELEMENT SprayArray[]);
+
+// This is used by AI for testing would it hit the enemy ship with gas.
+static COUNT
+initialize_test_gas (ELEMENT *ElementPtr, HELEMENT GasArray[])
+{
+	STARSHIP *StarShipPtr;
+	MISSILE_BLOCK MissileBlock;
+	
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+	
+	MissileBlock.cx = ElementPtr->next.location.x;
+	MissileBlock.cy = ElementPtr->next.location.y;
+	MissileBlock.farray = StarShipPtr->RaceDescPtr->ship_data.special;
+	MissileBlock.face = StarShipPtr->ShipFacing;
+	MissileBlock.index = LAST_DISSOLVE_INDEX;
+	MissileBlock.sender = ElementPtr->playerNr;
+	MissileBlock.flags =  GASSY_SUBSTANCE | IGNORE_VELOCITY;
+	MissileBlock.pixoffs = GAS_OFFSET;
+	MissileBlock.speed = GAS_INIT_SPEED;
+	MissileBlock.hit_points = GAS_HITS;
+	MissileBlock.damage = GAS_DAMAGE;
+	MissileBlock.life = 20; // Not GAS_LIFE because this test gas doesn't slow down at all -> life has to be short.
+	MissileBlock.preprocess_func = gas_preprocess;
+	MissileBlock.blast_offs = 0;
+	GasArray[0] = initialize_missile (&MissileBlock);
+	
+	return (1);
+}
+
+static void
+baul_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+						COUNT ConcernCounter)
+{
+	BYTE old_count;
+	STARSHIP *StarShipPtr;
+	EVALUATE_DESC *lpEvalDesc;
+	BYTE in_gas_cloud = 0;
+	
+	GetElementStarShip (ShipPtr, &StarShipPtr);
+	old_count = StarShipPtr->weapon_counter;
+	
+	// Don't spawn gas unless specifically told to.
+	StarShipPtr->ship_input_state &= ~SPECIAL;
+	
+	// See if there is gas sticking to OUR ship.
+	lpEvalDesc = &ObjectsOfConcern[ENEMY_WEAPON_INDEX];
+	if (lpEvalDesc->ObjectPtr)
+	{
+		if (lpEvalDesc->ObjectPtr->state_flags & GASSY_SUBSTANCE 
+			&& lpEvalDesc->ObjectPtr->mass_points == 0
+			&& lpEvalDesc->which_turn <= 1)
+			in_gas_cloud = 1;
+	}
+	
+	// Now that we're done with the gas examinations, examine enemy ship.
+	lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
+	
+	// Actions towards enemy ship: 
+	if (lpEvalDesc->ObjectPtr)
+	{
+#define STATIONARY_SPEED WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (4 << RESOLUTION_FACTOR)) // JMS_GFX
+		SIZE dx, dy;
+		
+		GetCurrentVelocityComponents (&lpEvalDesc->ObjectPtr->velocity, &dx, &dy);
+		
+		// Chase the ship if it's within a reasonable distance and there's no gas sticking to OUR ship.
+		if ((lpEvalDesc->which_turn < 20
+			|| (long)dx * dx + (long)dy * dy <= (long)STATIONARY_SPEED * STATIONARY_SPEED)
+			&& !in_gas_cloud)
+			lpEvalDesc->MoveState = PURSUE;
+		// Otherwise, entice.
+		else
+			lpEvalDesc->MoveState = ENTICE;
+	}
+	
+	// Normal ship intelligence.
+	ship_intelligence (ShipPtr, ObjectsOfConcern, ConcernCounter);
+	
+	// We don't want the Baul shooting all the time so it doesn't kill itself so easily.
+	if (lpEvalDesc->ObjectPtr)
+	{	
+		STARSHIP *EnemyStarShipPtr;
+		GetElementStarShip (lpEvalDesc->ObjectPtr, &EnemyStarShipPtr);
+		
+		// If the enemy is very close, don't shoot him with the primary to avoid damage to self.
+		// We shoot however, if the enemy ship has lazer or tries to shoot us.
+		// The philosophy: Better to kill both than do nothing and die.
+		if (StarShipPtr->ship_input_state & WEAPON && lpEvalDesc->which_turn < 8
+			&& !(EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags & IMMEDIATE_WEAPON)
+			&& !(EnemyStarShipPtr->ship_input_state & WEAPON)
+			&& !(EnemyStarShipPtr->ship_input_state & SPECIAL) )
+			StarShipPtr->ship_input_state &= ~WEAPON;
+	}
+	
+	// Drop gas whenever the battery tops off and when we are far away from the enemy.
+	if ((StarShipPtr->RaceDescPtr->ship_info.energy_level 
+		 == StarShipPtr->RaceDescPtr->ship_info.max_energy)
+		&& lpEvalDesc->which_turn > 12
+		&& !in_gas_cloud)
+		StarShipPtr->ship_input_state |= SPECIAL;
+	
+	// Consider dropping gas also when the enemy is in our sights.
+	if (StarShipPtr->special_counter == 0)
+	{
+		BYTE old_input_state;
+		old_input_state = StarShipPtr->ship_input_state;
+		
+		// The final decision of "to gas or not to gas" is made by evaluating a test weapon function.
+		StarShipPtr->RaceDescPtr->init_weapon_func = initialize_test_gas;
+		ship_intelligence (ShipPtr, ObjectsOfConcern, ENEMY_SHIP_INDEX + 1);
+		
+		// Since we faked using primary weapon even though we really are gonna use special,
+		// change the WEAPON button press to SPECIAL.
+		if (StarShipPtr->ship_input_state & WEAPON)
+		{
+			StarShipPtr->ship_input_state &= ~WEAPON;
+			StarShipPtr->ship_input_state |= SPECIAL;
+		}
+		
+		StarShipPtr->ship_input_state = (unsigned char)(old_input_state | (StarShipPtr->ship_input_state & SPECIAL));
+	}
+	
+	// Return the original stats.
+	StarShipPtr->weapon_counter = old_count;
+	StarShipPtr->RaceDescPtr->init_weapon_func = initialize_spray;
+}
+
+static void
+shockwave_preprocess (ELEMENT *ElementPtr)
+{
+	ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->current.image.frame);
+	
+	// This makes the shockwave animate even if the ships are not moving and the screen is stationary.
+	ElementPtr->state_flags |= CHANGING;
+}
+
+// We cannot use the normal generate_shockwave as death_func since it has two input parameters.
+// To circumvent this, we define an otherwise similar function generate_shockwave_2 here, but
+// which only has 1 input parameter.
+// This function is required for daisy-chaining shockwave explosions.
+static void
+generate_shockwave_2 (ELEMENT *ElementPtr)
+{
+	STARSHIP *StarShipPtr;
+	BYTE which_player;
+	
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+	
+	which_player = -1;//ElementPtr->playerNr; XXX
+	
+	// Gas is still 'solid' when it's hit by the spray. Let's make a shockwave and kill the gas cloud. 
+	if (!(ElementPtr->state_flags & NONSOLID))
+	{
+		HELEMENT hShockwave;
+		
+		hShockwave = AllocElement ();
+		if (hShockwave)
+		{
+			ELEMENT *ShockwavePtr;
+			STARSHIP *StarShipPtr;
+			
+			GetElementStarShip (ElementPtr, &StarShipPtr);
+			
+			PutElement (hShockwave);
+			LockElement (hShockwave, &ShockwavePtr);
+			SetElementStarShip (ShockwavePtr, StarShipPtr);
+			ShockwavePtr->hit_points = ShockwavePtr->mass_points = 0;
+			ShockwavePtr->playerNr = which_player; // Can damage both ships. //XXX Don't damage self.
+			ShockwavePtr->state_flags = APPEARING | FINITE_LIFE | NONSOLID | IGNORE_SIMILAR;
+			ShockwavePtr->life_span = SHOCKWAVE_FRAMES;
+			SetPrimType (&(GLOBAL (DisplayArray))[ShockwavePtr->PrimIndex], STAMP_PRIM);
+			ShockwavePtr->current.image.farray = StarShipPtr->RaceDescPtr->ship_data.special;
+			ShockwavePtr->current.image.frame = SetAbsFrameIndex(StarShipPtr->RaceDescPtr->ship_data.special[0], LAST_GAS_INDEX);
+			ShockwavePtr->next.image.frame = SetAbsFrameIndex(ElementPtr->current.image.frame, LAST_GAS_INDEX);
+			ShockwavePtr->current.location = ElementPtr->current.location;
+			ShockwavePtr->preprocess_func = shockwave_preprocess;
+			ShockwavePtr->postprocess_func = NULL;
+			ShockwavePtr->death_func = NULL;
+			ZeroVelocityComponents (&ShockwavePtr->velocity);
+			UnlockElement (hShockwave);
+		}
+		
+		// Gas dies on the next turn.
+		ElementPtr->state_flags |= NONSOLID;
+		
+		// Explosion sounds.
+		ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 2), ElementPtr);
+		ProcessSound (SetAbsSoundIndex (GameSounds, TARGET_DAMAGED_FOR_6_PLUS_PT), ElementPtr);
+	}
+	
+	{
+		// This is called during PostProcessQueue(), close to or at the end,
+		// for the temporary shockwave element to apply the damage.
+		// The effects are not seen until the next frame.
+		HELEMENT hElement, hNextElement;
+		
+		for (hElement = GetHeadElement (); hElement != 0; hElement = hNextElement)
+		{
+			ELEMENT *ObjPtr;
+			
+			LockElement (hElement, &ObjPtr);
+			hNextElement = GetSuccElement (ObjPtr);
+			
+			if (IS_GAS (ObjPtr))
+			{
+				SIZE delta_x, delta_y;
+				DWORD dist;
+				
+				if ((delta_x = ObjPtr->next.location.x - ElementPtr->next.location.x) < 0) delta_x = -delta_x;
+				if ((delta_y = ObjPtr->next.location.y - ElementPtr->next.location.y) < 0) delta_y = -delta_y;
+				
+				delta_x = WORLD_TO_DISPLAY (delta_x);
+				delta_y = WORLD_TO_DISPLAY (delta_y);
+				
+				if (delta_x <= SHOCKWAVE_RANGE && delta_y <= SHOCKWAVE_RANGE
+					&& (dist = (DWORD)(delta_x * delta_x) + (DWORD)(delta_y * delta_y)) <= (DWORD)(SHOCKWAVE_RANGE * SHOCKWAVE_RANGE))
+				{
+					SIZE destruction;
+					
+					destruction = ((MAX_DESTRUCTION * (SHOCKWAVE_RANGE - square_root (dist))) / SHOCKWAVE_RANGE) + 1;
+					
+					// The shockwave is delayed according to how far it is from the shockwave that set it off.
+					ObjPtr->life_span = (10 / destruction);
+					ObjPtr->death_func = generate_shockwave_2;
+					ObjPtr->playerNr = which_player;
+				}
+			}
+			else if (CollidingElement (ObjPtr) || ORZ_MARINE (ObjPtr))
+			{
+				SIZE delta_x, delta_y;
+				DWORD dist;
+				
+				if ((delta_x = ObjPtr->next.location.x - ElementPtr->next.location.x) < 0) delta_x = -delta_x;
+				if ((delta_y = ObjPtr->next.location.y - ElementPtr->next.location.y) < 0) delta_y = -delta_y;
+				
+				delta_x = WORLD_TO_DISPLAY (delta_x);
+				delta_y = WORLD_TO_DISPLAY (delta_y);
+				
+				if (delta_x <= SHOCKWAVE_RANGE && delta_y <= SHOCKWAVE_RANGE
+					&& (dist = (DWORD)(delta_x * delta_x) + (DWORD)(delta_y * delta_y)) <= (DWORD)(SHOCKWAVE_RANGE * SHOCKWAVE_RANGE))
+				{
+					SIZE destruction;
+					
+					destruction = ((MAX_DESTRUCTION * (SHOCKWAVE_RANGE - square_root (dist))) / SHOCKWAVE_RANGE) + 1;
+					
+					if (ObjPtr->state_flags & PLAYER_SHIP && ObjPtr->playerNr != which_player)
+					{
+						STARSHIP *EnemyShipPtr;
+						
+						GetElementStarShip (ObjPtr, &EnemyShipPtr);
+						
+						// Deal damage to ships except shield-using Yehat & Utwig.
+						if (!((EnemyShipPtr->SpeciesID == YEHAT_ID || EnemyShipPtr->SpeciesID == UTWIG_ID) 
+							  && ObjPtr->life_span > NORMAL_LIFE))
+						{
+							if (!DeltaCrew (ObjPtr, -destruction))
+								ObjPtr->life_span = 0;
+						}
+						// Charge Utwig shield.
+						else if (EnemyShipPtr->SpeciesID == UTWIG_ID && ObjPtr->life_span > NORMAL_LIFE)
+							ObjPtr->life_span += destruction;
+					}
+					else if (!GRAVITY_MASS (ObjPtr->mass_points) && ObjPtr->playerNr != which_player)
+					{
+						if ((BYTE)destruction < ObjPtr->hit_points)
+							ObjPtr->hit_points -= (BYTE)destruction;
+						else
+						{
+							ObjPtr->hit_points = 0;
+							ObjPtr->life_span = 0;
+						}
+					}
+				}
+			}
+			
+			UnlockElement (hElement);
+		}
+	}
+}
+
+// When hit by Baul spray, gas clouds explodes transforming into a lethal shockwave.
+static void
+generate_shockwave (ELEMENT *ElementPtr, BYTE which_player)
+{
+	STARSHIP *StarShipPtr;
+	
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+	
+	// Gas is still 'solid' when it's hit by the spray. Let's make a shockwave and kill the gas cloud. 
+	if (!(ElementPtr->state_flags & NONSOLID))
+	{
+		HELEMENT hShockwave;
+				
+		hShockwave = AllocElement ();
+		if (hShockwave)
+		{
+			ELEMENT *ShockwavePtr;
+			STARSHIP *StarShipPtr;
+			
+			GetElementStarShip (ElementPtr, &StarShipPtr);
+			
+			PutElement (hShockwave);
+			LockElement (hShockwave, &ShockwavePtr);
+			SetElementStarShip (ShockwavePtr, StarShipPtr);
+			ShockwavePtr->hit_points = ShockwavePtr->mass_points = 0;
+			ShockwavePtr->playerNr = which_player;
+			ShockwavePtr->state_flags = APPEARING | FINITE_LIFE | NONSOLID | IGNORE_SIMILAR;
+			ShockwavePtr->life_span = SHOCKWAVE_FRAMES;
+			SetPrimType (&(GLOBAL (DisplayArray))[ShockwavePtr->PrimIndex], STAMP_PRIM);
+			ShockwavePtr->current.image.farray = StarShipPtr->RaceDescPtr->ship_data.special;
+			ShockwavePtr->current.image.frame = SetAbsFrameIndex(StarShipPtr->RaceDescPtr->ship_data.special[0], LAST_GAS_INDEX);
+			ShockwavePtr->next.image.frame = SetAbsFrameIndex(ElementPtr->current.image.frame, LAST_GAS_INDEX);
+			ShockwavePtr->current.location = ElementPtr->current.location;
+			ShockwavePtr->preprocess_func = shockwave_preprocess;
+			ShockwavePtr->postprocess_func = NULL;
+			ShockwavePtr->death_func = NULL;
+			ZeroVelocityComponents (&ShockwavePtr->velocity);
+			UnlockElement (hShockwave);
+		}
+		
+		// Gas dies on the next turn.
+		ElementPtr->state_flags |= NONSOLID;
+		
+		// Explosion sounds.
+		ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 2), ElementPtr);
+		ProcessSound (SetAbsSoundIndex (GameSounds, TARGET_DAMAGED_FOR_6_PLUS_PT), ElementPtr);
+	}
+
+	{
+		// This is called during PostProcessQueue(), close to or at the end,
+		// for the temporary shockwave element to apply the damage.
+		// The effects are not seen until the next frame.
+		HELEMENT hElement, hNextElement;
+		
+		for (hElement = GetHeadElement (); hElement != 0; hElement = hNextElement)
+		{
+			ELEMENT *ObjPtr;
+			
+			LockElement (hElement, &ObjPtr);
+			hNextElement = GetSuccElement (ObjPtr);
+			
+			if (IS_GAS (ObjPtr))
+			{
+				SIZE delta_x, delta_y;
+				DWORD dist;
+				
+				if ((delta_x = ObjPtr->next.location.x - ElementPtr->next.location.x) < 0) delta_x = -delta_x;
+				if ((delta_y = ObjPtr->next.location.y - ElementPtr->next.location.y) < 0) delta_y = -delta_y;
+				
+				delta_x = WORLD_TO_DISPLAY (delta_x);
+				delta_y = WORLD_TO_DISPLAY (delta_y);
+				
+				if (delta_x <= SHOCKWAVE_RANGE && delta_y <= SHOCKWAVE_RANGE
+					&& (dist = (DWORD)(delta_x * delta_x) + (DWORD)(delta_y * delta_y)) <= (DWORD)(SHOCKWAVE_RANGE * SHOCKWAVE_RANGE))
+				{
+					SIZE destruction;
+					
+					destruction = ((MAX_DESTRUCTION * (SHOCKWAVE_RANGE - square_root (dist))) / SHOCKWAVE_RANGE) + 1;
+					
+					// The shockwave is delayed according to how far it is from the shockwave that set it off.
+					ObjPtr->life_span = (10 / destruction);
+					ObjPtr->death_func = generate_shockwave_2;
+					ObjPtr->playerNr = which_player;
+				}
+			}
+			else if (CollidingElement (ObjPtr) || ORZ_MARINE (ObjPtr))
+			{
+				SIZE delta_x, delta_y;
+				DWORD dist;
+				
+				if ((delta_x = ObjPtr->next.location.x - ElementPtr->next.location.x) < 0) delta_x = -delta_x;
+				if ((delta_y = ObjPtr->next.location.y - ElementPtr->next.location.y) < 0) delta_y = -delta_y;
+				
+				delta_x = WORLD_TO_DISPLAY (delta_x);
+				delta_y = WORLD_TO_DISPLAY (delta_y);
+				
+				if (delta_x <= SHOCKWAVE_RANGE && delta_y <= SHOCKWAVE_RANGE
+					&& (dist = (DWORD)(delta_x * delta_x) + (DWORD)(delta_y * delta_y)) <= (DWORD)(SHOCKWAVE_RANGE * SHOCKWAVE_RANGE))
+				{
+					SIZE destruction;
+					
+					destruction = ((MAX_DESTRUCTION * (SHOCKWAVE_RANGE - square_root (dist))) / SHOCKWAVE_RANGE) + 1;
+					
+					if (ObjPtr->state_flags & PLAYER_SHIP && ObjPtr->playerNr != which_player)
+					{
+						STARSHIP *EnemyShipPtr;
+						
+						GetElementStarShip (ObjPtr, &EnemyShipPtr);
+						
+						// Deal damage to ships except shield-using Yehat & Utwig.
+						if (!((EnemyShipPtr->SpeciesID == YEHAT_ID || EnemyShipPtr->SpeciesID == UTWIG_ID) 
+							  && ObjPtr->life_span > NORMAL_LIFE))
+						{
+							if (!DeltaCrew (ObjPtr, -destruction))
+								ObjPtr->life_span = 0;
+						}
+						// Charge Utwig shield.
+						else if (EnemyShipPtr->SpeciesID == UTWIG_ID && ObjPtr->life_span > NORMAL_LIFE)
+							ObjPtr->life_span += destruction;
+					}
+					else if (!GRAVITY_MASS (ObjPtr->mass_points) && ObjPtr->playerNr != which_player)
+					{
+						if ((BYTE)destruction < ObjPtr->hit_points)
+							ObjPtr->hit_points -= (BYTE)destruction;
+						else
+						{
+							ObjPtr->hit_points = 0;
+							ObjPtr->life_span = 0;
+						}
+					}
+				}
+			}
+			
+			UnlockElement (hElement);
+		}
+	}
+}
+
+// This forwards the gas dissolving animation.
+static void
+gas_death_animation (ELEMENT *ElementPtr)
+{
+	ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->current.image.frame);
+	ElementPtr->state_flags |= CHANGING;
+}
+
+// When gas expires, display animation of the gas dissolving.
+static void
+gas_death (ELEMENT *ElementPtr)
+{
+	STARSHIP *StarShipPtr;
+	
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+	
+	if (StarShipPtr->hShip)
+	{
+		HELEMENT hDissolve;
+		ELEMENT *ShipPtr;
+		
+		LockElement (StarShipPtr->hShip, &ShipPtr);
+	
+		if ((hDissolve = AllocElement ()))
+		{
+			ELEMENT *DissolvePtr;
+			
+			LockElement (hDissolve, &DissolvePtr);
+			DissolvePtr->playerNr = ElementPtr->playerNr;
+			DissolvePtr->state_flags = FINITE_LIFE | NONSOLID | IGNORE_SIMILAR | APPEARING;
+			DissolvePtr->turn_wait = 0;
+			DissolvePtr->life_span = NUM_DISSOLVE_FRAMES;
+			DissolvePtr->current.location.x = ElementPtr->current.location.x;
+			DissolvePtr->current.location.y = ElementPtr->current.location.y;
+			DissolvePtr->current.image.farray = StarShipPtr->RaceDescPtr->ship_data.special;
+			DissolvePtr->current.image.frame = SetAbsFrameIndex (ElementPtr->current.image.frame, LAST_SHOCKWAVE_INDEX);
+			DissolvePtr->preprocess_func = gas_death_animation;
+			SetElementStarShip (DissolvePtr, StarShipPtr);
+			SetPrimType (&(GLOBAL (DisplayArray))[DissolvePtr->PrimIndex], STAMP_PRIM);
+			
+			UnlockElement (hDissolve);
+			PutElement (hDissolve);
+		}
+		
+		UnlockElement (StarShipPtr->hShip);
+	}
+}
+
+static void
+gas_preprocess (ELEMENT *ElementPtr)
+{	
+	STARSHIP *StarShipPtr;
+	SDWORD dx, dy;
+	
+	// Baul's gas now flies forward. Slow down the gas smoothly.
+	GetCurrentVelocityComponentsSdword (&ElementPtr->velocity, &dx, &dy);
+	if (dx != 0 || dy != 0)
+	{
+		dx = (SDWORD)(dx * 9 / 10);
+		dy = (SDWORD)(dy * 9 / 10);
+		SetVelocityComponents (&ElementPtr->velocity, dx, dy);
+	}
+		
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+	
+	// Move to next image frame. (Abusing thrust_wait to slow down the anim.)
+	if (ElementPtr->thrust_wait > 0)
+		--ElementPtr->thrust_wait;
+	else
+	{
+		// Abusing thrust_wait to slow down the anim. (Should help performance a bit.)
+		ElementPtr->thrust_wait = 1;
+		
+		// This makes the gas animate even if the ships are not moving and the screen is stationary.
+		ElementPtr->state_flags |= CHANGING;
+		
+		if (GetFrameIndex (ElementPtr->current.image.frame) >= LAST_DISSOLVE_INDEX
+			&& GetFrameIndex (ElementPtr->current.image.frame) < LAST_DISSOLVE_INDEX + NUM_EMERGE_FRAMES)
+			ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->current.image.frame);
+		else if (GetFrameIndex (ElementPtr->current.image.frame) < LAST_GAS_INDEX - 1)
+			ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->current.image.frame);
+		else
+			ElementPtr->next.image.frame = SetAbsFrameIndex (ElementPtr->current.image.frame, 0);
+	}
+	
+	// If enemy ship dies, remove the gas (this prevents game crashing upon enemy ship dying with gas on it).
+	if ((!(ElementPtr->state_flags & IGNORE_VELOCITY) && ElementPtr->hTarget == 0)
+		|| StarShipPtr->RaceDescPtr->ship_info.crew_level == 0)
+	{
+		ElementPtr->life_span = 0;
+		ElementPtr->state_flags |= DISAPPEARING;
+	}
+	// When the gas has collided with enemy ship, it sticks to the ship until expires.
+	// (When the gas is sticking to enemy ship, the gas's IGNORE_VELOCITY flag is disabled.)
+	else if (!(ElementPtr->state_flags & IGNORE_VELOCITY) && !(ElementPtr->state_flags & DISAPPEARING))
+	{
+		ELEMENT *eptr;
+		SIZE offs_x, offs_y;
+		SBYTE leftOrRight, upOrDown;
+		COUNT angle, angleCorrect;
+		static BYTE alignment[NUM_SIDES]={0,0};
+		
+		// eptr points to enemy ship now.
+		LockElement (ElementPtr->hTarget, &eptr);
+		
+		// Make gas's location the same as the enemy ship's.
+		ElementPtr->next.location = eptr->next.location;
+		
+		// Randomize the gas's location so every gas cloud doesn't stick to the same place on the enemy ship.
+		GetElementStarShip (eptr, &StarShipPtr);
+		angle = (ElementPtr->weapon_element_index) % 16;
+		alignment[ElementPtr->playerNr] = ElementPtr->weapon_element_index % 4;
+		if (alignment[ElementPtr->playerNr] == 0)
+		{
+			leftOrRight = -1;
+			upOrDown = 1;
+			angleCorrect = 0;
+		}
+		else if (alignment[ElementPtr->playerNr] == 1)
+		{
+			leftOrRight = 1;
+			upOrDown = -1;
+			angleCorrect = 0;
+		}
+		else if (alignment[ElementPtr->playerNr] == 2)
+		{
+			leftOrRight = -1;
+			upOrDown = 1;
+			angleCorrect = HALF_CIRCLE / 2;
+		}
+		else
+		{
+			leftOrRight = 1;
+			upOrDown = -1;
+			angleCorrect = HALF_CIRCLE / 2;
+		}
+		offs_x = SINE (angle - angleCorrect, (ElementPtr->weapon_element_index % 16) * (5 << RESOLUTION_FACTOR));
+		offs_y = COSINE (angle - angleCorrect, (ElementPtr->weapon_element_index % 16) * (5 << RESOLUTION_FACTOR));
+		ElementPtr->next.location.x = ElementPtr->next.location.x + leftOrRight * offs_x;
+		ElementPtr->next.location.y = ElementPtr->next.location.y + upOrDown * offs_y;
+	
+		if (ElementPtr->turn_wait)
+		{
+			HELEMENT hEffect;
+			
+			hEffect = AllocElement ();
+			if (hEffect)
+			{
+				// eptr points to the new gas element now.
+				LockElement (hEffect, &eptr);
+				eptr->playerNr = ElementPtr->playerNr;
+				eptr->state_flags = FINITE_LIFE | GASSY_SUBSTANCE | CHANGING;
+				eptr->life_span = 1;
+				eptr->thrust_wait = 1;
+				eptr->weapon_element_index = ElementPtr->weapon_element_index;
+				eptr->current = eptr->next = ElementPtr->next;
+				eptr->preprocess_func = gas_preprocess;
+				eptr->collision_func = gas_collision;
+				// No need to have death_func here: It carries on from the declaration in gas_collision.
+				// In fact, if gas_death is put here as death_func, it just messes up the graphics.
+				
+				SetPrimType (&(GLOBAL (DisplayArray))[eptr->PrimIndex], STAMP_PRIM);
+				GetElementStarShip (ElementPtr, &StarShipPtr);
+				SetElementStarShip (eptr, StarShipPtr);
+				eptr->hTarget = ElementPtr->hTarget;
+				
+				UnlockElement (hEffect);
+				PutElement (hEffect);
+			}
+		}
+		
+		UnlockElement (ElementPtr->hTarget);
+	}
+}
+
+static void
+gas_collision (ELEMENT *ElementPtr0, POINT *pPt0, ELEMENT *ElementPtr1, POINT *pPt1)
+{
+	STARSHIP *StarShipPtr;
+	STARSHIP *EnemyStarShipPtr;
+	BYTE	 enemyShipIsBaul = 0;
+	BYTE	 enemyShipIsChmmr = 0;
+	
+	// This is the ship this gas cloud belongs to.
+	GetElementStarShip (ElementPtr0, &StarShipPtr);
+	
+	// Check if the colliding element is a ship. If it is not, check if it's a projectile from Baul or Chmmr ship.
+	if (!elementsOfSamePlayer(ElementPtr0, ElementPtr1) && !(ElementPtr1->state_flags & PLAYER_SHIP) 
+		&& ElementPtr1->playerNr > -1)
+	{
+		GetElementStarShip (ElementPtr1, &EnemyStarShipPtr);
+		if (EnemyStarShipPtr->SpeciesID == BAUL_ID)
+			enemyShipIsBaul = 1;
+		else if (EnemyStarShipPtr->SpeciesID == CHMMR_ID) 
+			enemyShipIsChmmr = 1; // This is important because the gas can stick to zapsats.
+	}
+	
+	// If colliding with Baul's spray weapon or shockwave, EXPLODE!!!
+	if (ElementPtr1->current.image.farray == StarShipPtr->RaceDescPtr->ship_data.weapon
+		|| (enemyShipIsBaul && ElementPtr1->current.image.farray == EnemyStarShipPtr->RaceDescPtr->ship_data.weapon))
+	{
+		// Move to shockwave graphics.
+		ElementPtr0->current.image.frame = SetAbsFrameIndex (ElementPtr0->current.image.frame, LAST_GAS_INDEX);
+		ElementPtr0->next.image.frame = SetAbsFrameIndex (ElementPtr0->current.image.frame, LAST_GAS_INDEX);
+		
+		// Remove the lock on enemy ship and make the gas die on next turn.
+		ElementPtr0->hTarget = 0;
+		ElementPtr0->life_span = 1;
+		
+		// Don't do the gas dissolve anim now that the shockwave appears.
+		ElementPtr0->death_func = NULL;
+		
+		// Generate the actual shockwave.
+		generate_shockwave (ElementPtr0, -1); // XXX ElementPtr1->playerNr);
+	}
+	// If colliding with enemy ship, stick to the ship.
+	// Also stick to Chmmr's zapsats.
+	else if (ElementPtr0->state_flags & IGNORE_VELOCITY
+			 && ElementPtr1->playerNr != ElementPtr0->playerNr
+			 && (ElementPtr1->state_flags & PLAYER_SHIP 
+				 || (enemyShipIsChmmr && ElementPtr1->mass_points == 10) ))
+	{
+		HELEMENT hGasElement;
+		HELEMENT hTargetElement;
+		ELEMENT *GasPtr;
+		
+		// Create a new gas element which is sticking to the enemy ship.
+		if ((hGasElement = AllocElement ()))
+		{
+			LockElement (hGasElement, &GasPtr);
+			
+			if (GasPtr->state_flags == 0) /* not allocated before */
+			{
+				InsertElement (hGasElement, GetHeadElement ());
+				
+				GasPtr->current = ElementPtr0->next;
+				GasPtr->next = GasPtr->current;
+				GasPtr->playerNr = ElementPtr0->playerNr;
+				GasPtr->state_flags = FINITE_LIFE | GASSY_SUBSTANCE | CHANGING;
+				GasPtr->preprocess_func = gas_preprocess;
+				GasPtr->collision_func = gas_collision;
+				SetPrimType (&(GLOBAL (DisplayArray))[GasPtr->PrimIndex], NO_PRIM);
+				
+				SetElementStarShip (GasPtr, StarShipPtr);
+				GetElementStarShip (ElementPtr1, &StarShipPtr);
+				
+				// Ships and Chmmr Zapsats require different ways of making them the target of the gas cloud.
+				if (ElementPtr1->state_flags & PLAYER_SHIP)
+					GasPtr->hTarget = StarShipPtr->hShip;
+				else
+				{
+					GasPtr->life_span = 0;
+					LockElement (ElementPtr1, &hTargetElement);
+					GasPtr->hTarget = hTargetElement;
+				}
+			}
+			GasPtr->hit_points = ElementPtr0->hit_points;
+			GasPtr->life_span = ElementPtr0->life_span;
+			GasPtr->thrust_wait = 1;
+			GasPtr->weapon_element_index = ElementPtr0->weapon_element_index;
+			GasPtr->turn_wait = (BYTE)(1 << ((BYTE)TFB_Random () & 1)); /* LEFT or RIGHT */
+			GasPtr->death_func = gas_death;
+			
+			UnlockElement (hGasElement);
+		}
+		
+		// Erase the original gas element.
+		ElementPtr0->hit_points = 0;
+		ElementPtr0->life_span = 0;
+		ElementPtr0->state_flags |= DISAPPEARING | COLLISION | NONSOLID;
+	}
+	(void) pPt0;  /* Satisfying compiler (unused parameter) */
+	(void) pPt1;  /* Satisfying compiler (unused parameter) */
+}
+
+// Secondary weapon: Gas cloud.
+// The IGNORE_VELOCITY flag is very important: It doesn't only stop the gas from reacting to gravity,
+// (see collide.h) but it also makes it possible for the gas to stick to enemy ship (see this file's other gas functions).
+static void spawn_gas (ELEMENT *ShipPtr)
+{	
+	STARSHIP *StarShipPtr;
+	MISSILE_BLOCK MissileBlock;
+	HELEMENT Missile;
+	SIZE offs_x, offs_y;
+	COUNT angle;
+	static COUNT gas_side[NUM_SIDES]   = {0, 0};
+	static COUNT gas_number[NUM_SIDES] = {0, 0};
+	
+	GetElementStarShip (ShipPtr, &StarShipPtr);
+	
+	gas_number[ShipPtr->playerNr] = (gas_number[ShipPtr->playerNr] + 1) % 32;
+	gas_side[ShipPtr->playerNr] = (gas_side[ShipPtr->playerNr] + 1) % 2;
+	angle = FACING_TO_ANGLE (StarShipPtr->ShipFacing);
+	
+	// This mechanism can be used to alter the "pipe" from which the gas clouds come.
+	if(gas_side[ShipPtr->playerNr])
+	{
+		offs_x = -SINE (angle, GAS_HORZ_OFFSET);
+		offs_y = COSINE (angle, GAS_HORZ_OFFSET);
+	}
+	else
+	{
+		offs_x = -SINE (angle, GAS_HORZ_OFFSET);
+		offs_y = COSINE (angle, GAS_HORZ_OFFSET);
+	}
+		
+	MissileBlock.cx = ShipPtr->next.location.x + offs_x;
+	MissileBlock.cy = ShipPtr->next.location.y + offs_y;
+	MissileBlock.farray = StarShipPtr->RaceDescPtr->ship_data.special;
+	MissileBlock.face = StarShipPtr->ShipFacing;// Baul's gas now flies forward. (this was: (StarShipPtr->ShipFacing - 8) % 16;)
+	MissileBlock.index = LAST_DISSOLVE_INDEX; // Start with the gas emerge animation which is the last .pngs in gasXX.ani
+	MissileBlock.sender = ShipPtr->playerNr;
+	MissileBlock.flags = GASSY_SUBSTANCE | IGNORE_VELOCITY; // Don't erase the IGNORE_VELOCITY. It's very important.
+	MissileBlock.pixoffs = GAS_OFFSET;
+	MissileBlock.speed = GAS_INIT_SPEED;
+	MissileBlock.hit_points = GAS_HITS;
+	MissileBlock.damage = GAS_DAMAGE;
+	MissileBlock.life = GAS_LIFE;
+	MissileBlock.preprocess_func = gas_preprocess;
+	MissileBlock.blast_offs = 0;
+	Missile = initialize_missile (&MissileBlock);
+	
+	if (Missile)
+	{
+		ELEMENT *GasPtr;
+		SIZE	dx, dy; // Baul's gas now flies forward.
+		
+		LockElement (Missile, &GasPtr);
+		
+		// Baul's gas now flies forward.
+		GetCurrentVelocityComponents (&ShipPtr->velocity, &dx, &dy);
+		DeltaVelocityComponents (&GasPtr->velocity, dx, dy);
+		GasPtr->current.location.x -= VELOCITY_TO_WORLD (dx);
+		GasPtr->current.location.y -= VELOCITY_TO_WORLD (dy);
+		
+		GasPtr->collision_func = gas_collision;
+		GasPtr->death_func = gas_death;
+		GasPtr->thrust_wait = 1;
+		GasPtr->weapon_element_index = gas_number[ShipPtr->playerNr];
+		SetElementStarShip (GasPtr, StarShipPtr);
+		ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 1), GasPtr);
+		UnlockElement (Missile);
+		PutElement (Missile);
+	}
+}
+
+// The spray preprocess function animates spray.
+static void
+spray_preprocess (ELEMENT *ElementPtr)
+{
+	// Abusing thrust_wait to slow down the anim.
+	if (ElementPtr->thrust_wait > 0)
+		--ElementPtr->thrust_wait;
+	// Move to next frame.
+	else
+	{
+		// Abusing thrust_wait to slow down the anim. (Should help performance a bit.)
+		ElementPtr->thrust_wait = 1;
+		
+		// This makes the gas animate even if the ships are not moving and the screen is stationary.
+		ElementPtr->state_flags |= CHANGING;
+		
+		if (GetFrameIndex (ElementPtr->current.image.frame) < LAST_SPRAY_INDEX)
+			ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->current.image.frame);
+		// This is a safeguard to prevent going over frame boundaries if someone messes up the 
+		// MISSILE_LIFE <-> LAST_SPRAY_INDEX <-> thrust_wait correspondence.
+		else
+			ElementPtr->next.image.frame = SetAbsFrameIndex (ElementPtr->current.image.frame, 0);
+	}
+}
+
+// This makes the spray not collide with anything (except gas clouds: gas_collision handles them.)
+static void
+spray_collision (ELEMENT *ElementPtr0, POINT *pPt0, ELEMENT *ElementPtr1, POINT *pPt1)
+{
+	(void) ElementPtr0;  /* Satisfying compiler (unused parameter) */
+	(void) ElementPtr1;  /* Satisfying compiler (unused parameter) */
+	(void) pPt0;  /* Satisfying compiler (unused parameter) */
+	(void) pPt1;  /* Satisfying compiler (unused parameter) */
+}
+
+// Primary weapon. It must deal at least 1 damage, otherwise it won't interact with other 
+// elements, not even gas. However, we can prevent this damage with a separate collision function.
+static COUNT
+initialize_spray (ELEMENT *ShipPtr, HELEMENT SprayArray[])
+{
+	STARSHIP *StarShipPtr;
+	MISSILE_BLOCK MissileBlock;
+	SIZE offs_x, offs_y;
+	COUNT i, angle;
+	static COUNT spray_side[NUM_SIDES]={0,0};
+	
+	GetElementStarShip (ShipPtr, &StarShipPtr);
+	angle = FACING_TO_ANGLE (StarShipPtr->ShipFacing);
+	
+	for (i = 0; i < NUM_SPRAYS; i++)
+	{
+		BYTE damage;
+		
+		// Only the foremost one deals damage
+		if (i == NUM_SPRAYS-1)
+			damage = 1;
+		else
+			damage = 0;
+		
+		// This mechanism can be used to alter the "pipe" from which the spray particles come.
+		spray_side[ShipPtr->playerNr] = (spray_side[ShipPtr->playerNr] + 1) % 2;
+		if(spray_side[ShipPtr->playerNr])
+		{
+			offs_x = -SINE (angle,  SPRAY_HORZ_OFFSET + (i << RESOLUTION_FACTOR));
+			offs_y = COSINE (angle, SPRAY_HORZ_OFFSET + (i << RESOLUTION_FACTOR));
+		}
+		else
+		{
+			offs_x = -SINE (angle,  SPRAY_HORZ_OFFSET + (i << RESOLUTION_FACTOR));
+			offs_y = COSINE (angle, SPRAY_HORZ_OFFSET + (i << RESOLUTION_FACTOR));
+		}
+	
+		MissileBlock.cx = ShipPtr->next.location.x + offs_x;
+		MissileBlock.cy = ShipPtr->next.location.y + offs_y;
+		MissileBlock.farray = StarShipPtr->RaceDescPtr->ship_data.weapon;
+		MissileBlock.face = StarShipPtr->ShipFacing;
+		MissileBlock.index = 0;
+		MissileBlock.sender = ShipPtr->playerNr;
+		MissileBlock.flags = IGNORE_SIMILAR | GASSY_SUBSTANCE;
+		MissileBlock.pixoffs = 4 + ((i * SPRAY_DIST) << RESOLUTION_FACTOR);
+		MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
+		MissileBlock.hit_points = MISSILE_HITS;
+		MissileBlock.damage = damage;
+		MissileBlock.life = MISSILE_LIFE;
+		MissileBlock.preprocess_func = spray_preprocess;
+		MissileBlock.blast_offs = MISSILE_OFFSET;
+		SprayArray[i] = initialize_missile (&MissileBlock);
+		
+		if (SprayArray[i])
+		{
+			ELEMENT *SprayPtr;
+			
+			LockElement (SprayArray[i], &SprayPtr);
+			SprayPtr->collision_func = spray_collision;
+			SprayPtr->thrust_wait = 1;
+			
+			// This makes the spray shoot in a slight angle towards the centerline.
+			// If you want a "curved" shot, put this mechanism into spray_preprocess
+			// where it accelerates the whot towards the centerline on every frame.
+			offs_x = -SINE (angle, (100 << RESOLUTION_FACTOR));
+			offs_y = COSINE (angle, (100 << RESOLUTION_FACTOR));
+			DeltaVelocityComponents (&SprayPtr->velocity, offs_x, offs_y);
+			
+			UnlockElement (SprayArray[i]);
+		}
+	}
+	
+	return (NUM_SPRAYS);
+}
+
+// Gas spawning happens in postprocess, because  the game seems to like to put specials on the playing field
+// in postprocess (I guess it has something to do with keeping the queue of elements in the right order.)
+static void
+baul_postprocess (ELEMENT *ElementPtr)
+{
+	STARSHIP *StarShipPtr;
+	
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+	
+	if ((StarShipPtr->cur_status_flags & SPECIAL)
+		&& StarShipPtr->special_counter == 0
+		&& DeltaEnergy (ElementPtr, -SPECIAL_ENERGY_COST))
+	{
+		int i;
+		
+		ProcessSound (SetAbsSoundIndex // Spawn gas.
+					  (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 1), ElementPtr);
+		
+		for (i = 0; i < GAS_BATCH_SIZE; i++)
+			spawn_gas (ElementPtr);
+		
+		StarShipPtr->special_counter = SPECIAL_WAIT;
+	}
+}
+
+static void
+baul_preprocess (ELEMENT *ElementPtr)
+{
+	STARSHIP *StarShipPtr;
+	
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+}
+
+RACE_DESC*
+init_baul (void)
+{
+	RACE_DESC *RaceDescPtr;
+	
+	if (RESOLUTION_FACTOR == 0)
+	{
+		baul_desc.preprocess_func = baul_preprocess;
+		baul_desc.postprocess_func = baul_postprocess;
+		baul_desc.init_weapon_func = initialize_spray;
+		baul_desc.cyborg_control.intelligence_func = baul_intelligence;
+		RaceDescPtr = &baul_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		baul_desc_2xres.preprocess_func = baul_preprocess;
+		baul_desc_2xres.postprocess_func = baul_postprocess;
+		baul_desc_2xres.init_weapon_func = initialize_spray;
+		baul_desc_2xres.cyborg_control.intelligence_func = baul_intelligence;
+		RaceDescPtr = &baul_desc_2xres;
+	}
+	else
+	{
+		baul_desc_4xres.preprocess_func = baul_preprocess;
+		baul_desc_4xres.postprocess_func = baul_postprocess;
+		baul_desc_4xres.init_weapon_func = initialize_spray;
+		baul_desc_4xres.cyborg_control.intelligence_func = baul_intelligence;
+		RaceDescPtr = &baul_desc_4xres;
+	}
+	
+	return (RaceDescPtr);
+}
diff -ruNp src.orig/uqm/ships/baul/baul.h src/uqm/ships/baul/baul.h
--- src.orig/uqm/ships/baul/baul.h	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/baul/baul.h	2017-11-01 15:31:04 -0700
@@ -0,0 +1,23 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef BAUL_H
+#define BAUL_H
+
+RACE_DESC *init_baul (void);
+
+#endif  /* BAUL_H */
+
diff -ruNp src.orig/uqm/ships/baul/icode.h src/uqm/ships/baul/icode.h
--- src.orig/uqm/ships/baul/icode.h	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/baul/icode.h	2017-11-01 15:31:04 -0700
@@ -0,0 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
+#define BAUL_CODE "ship.baul.code"
diff -ruNp src.orig/uqm/ships/baul/igfxres.h src/uqm/ships/baul/igfxres.h
--- src.orig/uqm/ships/baul/igfxres.h	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/baul/igfxres.h	2017-11-01 15:31:04 -0700
@@ -0,0 +1,16 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
+#define BAULGAS_BIG_MASK_PMAP_ANIM "ship.baul.graphics.baulgas.large"
+#define BAULGAS_MED_MASK_PMAP_ANIM "ship.baul.graphics.baulgas.medium"
+#define BAULGAS_SML_MASK_PMAP_ANIM "ship.baul.graphics.baulgas.small"
+#define BAULSPRAY_BIG_MASK_PMAP_ANIM "ship.baul.graphics.baulspray.large"
+#define BAULSPRAY_MED_MASK_PMAP_ANIM "ship.baul.graphics.baulspray.medium"
+#define BAULSPRAY_SML_MASK_PMAP_ANIM "ship.baul.graphics.baulspray.small"
+#define BAUL_BIG_MASK_PMAP_ANIM "ship.baul.graphics.punisher.large"
+#define BAUL_CAPTAIN_MASK_PMAP_ANIM "ship.baul.graphics.captain"
+#define BAUL_ICON_MASK_PMAP_ANIM "ship.baul.icons"
+#define BAUL_MED_MASK_PMAP_ANIM "ship.baul.graphics.punisher.medium"
+#define BAUL_MICON_MASK_PMAP_ANIM "ship.baul.meleeicons"
+#define BAUL_SML_MASK_PMAP_ANIM "ship.baul.graphics.punisher.small"
diff -ruNp src.orig/uqm/ships/baul/imusicre.h src/uqm/ships/baul/imusicre.h
--- src.orig/uqm/ships/baul/imusicre.h	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/baul/imusicre.h	2017-11-01 15:31:04 -0700
@@ -0,0 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
+#define BAUL_VICTORY_SONG "ship.baul.ditty"
diff -ruNp src.orig/uqm/ships/baul/isndres.h src/uqm/ships/baul/isndres.h
--- src.orig/uqm/ships/baul/isndres.h	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/baul/isndres.h	2017-11-01 15:31:04 -0700
@@ -0,0 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
+#define BAUL_SHIP_SOUNDS "ship.baul.sounds"
diff -ruNp src.orig/uqm/ships/baul/istrtab.h src/uqm/ships/baul/istrtab.h
--- src.orig/uqm/ships/baul/istrtab.h	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/baul/istrtab.h	2017-11-01 15:31:04 -0700
@@ -0,0 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
+#define BAUL_RACE_STRINGS "ship.baul.text"
diff -ruNp src.orig/uqm/ships/baul/resinst.h src/uqm/ships/baul/resinst.h
--- src.orig/uqm/ships/baul/resinst.h	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/baul/resinst.h	2017-11-01 15:31:04 -0700
@@ -0,0 +1,17 @@
+#define BAULSPRAY_BIG_MASK_PMAP_ANIM "ship.baul.graphics.baulspray.large"
+#define BAULSPRAY_MED_MASK_PMAP_ANIM "ship.baul.graphics.baulspray.medium"
+#define BAULSPRAY_SML_MASK_PMAP_ANIM "ship.baul.graphics.baulspray.small"
+#define BAULGAS_BIG_MASK_PMAP_ANIM "ship.baul.graphics.baulgas.large"
+#define BAULGAS_MED_MASK_PMAP_ANIM "ship.baul.graphics.baulgas.medium"
+#define BAULGAS_SML_MASK_PMAP_ANIM "ship.baul.graphics.baulgas.small"
+#define BAUL_BIG_MASK_PMAP_ANIM "ship.baul.graphics.punisher.large"
+#define BAUL_CAPTAIN_MASK_PMAP_ANIM "ship.baul.graphics.captain"
+#define BAUL_ICON_MASK_PMAP_ANIM "ship.baul.icons"
+#define BAUL_MED_MASK_PMAP_ANIM "ship.baul.graphics.punisher.medium"
+#define BAUL_MICON_MASK_PMAP_ANIM "ship.baul.meleeicons"
+#define BAUL_SML_MASK_PMAP_ANIM "ship.baul.graphics.punisher.small"
+#define BAUL_RACE_STRINGS "ship.baul.text"
+#define BAUL_SHIP_SOUNDS "ship.baul.sounds"
+#define BAUL_VICTORY_SONG "ship.baul.ditty"
+
+#include "icode.h"
diff -ruNp src.orig/uqm/ships/blackurq/blackurq.c src/uqm/ships/blackurq/blackurq.c
--- src.orig/uqm/ships/blackurq/blackurq.c	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/blackurq/blackurq.c	2017-11-01 15:31:04 -0700
@@ -37,10 +37,8 @@
 #define SPECIAL_WAIT 9
 
 #define SHIP_MASS 10
-#define MISSILE_SPEED 64
-#define MISSILE_LIFE 64 /* actually, it's as long as you
-										 * hold the button down.
-										 */
+#define MISSILE_SPEED (64 << RESOLUTION_FACTOR) // JMS_GFX
+#define MISSILE_LIFE 64 /* actually, it's as long as you hold the button down.*/
 
 static RACE_DESC black_urquan_desc =
 {
@@ -52,12 +50,12 @@ static RACE_DESC black_urquan_desc =
 		KOHR_AH_RACE_STRINGS,
 		KOHR_AH_ICON_MASK_PMAP_ANIM,
 		KOHR_AH_MICON_MASK_PMAP_ANIM,
-		NULL, NULL, NULL
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
 	},
 	{ /* FLEET_STUFF */
-		2666 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		4000 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
 		{ /* Known location (center of SoI) */
-			6000, 6250,
+			9999,9999,
 		},
 	},
 	{
@@ -113,6 +111,156 @@ static RACE_DESC black_urquan_desc =
 	0, /* CodeRef */
 };
 
+#define MAX_THRUST_2XRES 60			// JMS_GFX
+#define THRUST_INCREMENT_2XRES 12	// JMS_GFX
+
+// JMS_GFX
+static RACE_DESC black_urquan_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		30, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		KOHR_AH_RACE_STRINGS,
+		KOHR_AH_ICON_MASK_PMAP_ANIM,
+		KOHR_AH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		4000 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			9999,9999,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			KOHR_AH_BIG_MASK_PMAP_ANIM,
+			KOHR_AH_MED_MASK_PMAP_ANIM,
+			KOHR_AH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BUZZSAW_BIG_MASK_PMAP_ANIM,
+			BUZZSAW_MED_MASK_PMAP_ANIM,
+			BUZZSAW_SML_MASK_PMAP_ANIM,
+		},
+		{
+			GAS_BIG_MASK_PMAP_ANIM,
+			GAS_MED_MASK_PMAP_ANIM,
+			GAS_SML_MASK_PMAP_ANIM,
+		},
+		{
+			KOHR_AH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		KOHR_AH_VICTORY_SONG,
+		KOHR_AH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+#define MAX_THRUST_4XRES 120		// JMS_GFX
+#define THRUST_INCREMENT_4XRES 24	// JMS_GFX
+
+// JMS_GFX
+static RACE_DESC black_urquan_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		30, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		KOHR_AH_RACE_STRINGS,
+		KOHR_AH_ICON_MASK_PMAP_ANIM,
+		KOHR_AH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		4000 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			9999,9999,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			KOHR_AH_BIG_MASK_PMAP_ANIM,
+			KOHR_AH_MED_MASK_PMAP_ANIM,
+			KOHR_AH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BUZZSAW_BIG_MASK_PMAP_ANIM,
+			BUZZSAW_MED_MASK_PMAP_ANIM,
+			BUZZSAW_SML_MASK_PMAP_ANIM,
+		},
+		{
+			GAS_BIG_MASK_PMAP_ANIM,
+			GAS_MED_MASK_PMAP_ANIM,
+			GAS_SML_MASK_PMAP_ANIM,
+		},
+		{
+			KOHR_AH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		KOHR_AH_VICTORY_SONG,
+		KOHR_AH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 #define SAW_RATE 0
 #define MAX_SAWS 8
 
@@ -172,7 +320,7 @@ buzztrack_preprocess (ELEMENT *ElementPt
 		}
 		else
 		{
-#define ACTIVATE_RANGE 224 /* Originally SPACE_WIDTH */
+#define ACTIVATE_RANGE (224 << RESOLUTION_FACTOR) /* Originally SPACE_WIDTH */ // JMS_GFX
 			SIZE delta_x, delta_y;
 			ELEMENT *eptr;
 
@@ -206,7 +354,7 @@ buzztrack_preprocess (ELEMENT *ElementPt
 			{
 				ElementPtr->thrust_wait = TRACK_WAIT;
 				SetVelocityVector (&ElementPtr->velocity,
-						DISPLAY_TO_WORLD (2), facing);
+						DISPLAY_TO_WORLD (2 << RESOLUTION_FACTOR), facing); // JMS_GFX
 			}
 		}
 	}
@@ -234,8 +382,7 @@ decelerate_preprocess (ELEMENT *ElementP
 static void
 splinter_preprocess (ELEMENT *ElementPtr)
 {
-	ElementPtr->next.image.frame =
-			IncFrameIndex (ElementPtr->current.image.frame);
+	ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->current.image.frame);
 	ElementPtr->state_flags |= CHANGING;
 }
 
@@ -250,8 +397,7 @@ buzzsaw_collision (ELEMENT *ElementPtr0,
 		ElementPtr0->state_flags &= ~DISAPPEARING;
 		ElementPtr0->state_flags |= NONSOLID | CHANGING;
 		ElementPtr0->life_span = 5;
-		ElementPtr0->next.image.frame =
-				SetAbsFrameIndex (ElementPtr0->current.image.frame, 2);
+		ElementPtr0->next.image.frame = SetAbsFrameIndex (ElementPtr0->current.image.frame, 2);
 
 		ElementPtr0->preprocess_func = splinter_preprocess;
 	}
@@ -289,8 +435,7 @@ buzzsaw_postprocess (ELEMENT *ElementPtr
 		primIndex = ListElementPtr->PrimIndex;
 		*ListElementPtr = *ElementPtr;
 		ListElementPtr->PrimIndex = primIndex;
-		(GLOBAL (DisplayArray))[primIndex] =
-				(GLOBAL (DisplayArray))[ElementPtr->PrimIndex];
+		(GLOBAL (DisplayArray))[primIndex] = (GLOBAL (DisplayArray))[ElementPtr->PrimIndex];
 		ListElementPtr->current = ListElementPtr->next;
 		InitIntersectStartPoint (ListElementPtr);
 		InitIntersectEndPoint (ListElementPtr);
@@ -313,8 +458,8 @@ initialize_buzzsaw (ELEMENT *ShipPtr, HE
 {
 #define MISSILE_HITS 10
 #define MISSILE_DAMAGE 4
-#define MISSILE_OFFSET 9
-#define KOHR_AH_OFFSET 28
+#define MISSILE_OFFSET (9 << RESOLUTION_FACTOR) // JMS_GFX
+#define KOHR_AH_OFFSET (28 << RESOLUTION_FACTOR) // JMS_GFX
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -327,7 +472,7 @@ initialize_buzzsaw (ELEMENT *ShipPtr, HE
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = KOHR_AH_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = MISSILE_SPEED; // JMS_GFX
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -356,7 +501,7 @@ black_urquan_intelligence (ELEMENT *Ship
 {
 	EVALUATE_DESC *lpEvalDesc;
 	STARSHIP *StarShipPtr;
-
+	
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_WEAPON_INDEX];
 	if (lpEvalDesc->ObjectPtr
 			&& lpEvalDesc->MoveState == ENTICE
@@ -364,8 +509,7 @@ black_urquan_intelligence (ELEMENT *Ship
 			&& lpEvalDesc->which_turn <= 8)
 		lpEvalDesc->MoveState = PURSUE;
 
-	ship_intelligence (ShipPtr,
-			ObjectsOfConcern, ConcernCounter);
+	ship_intelligence (ShipPtr, ObjectsOfConcern, ConcernCounter);
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	StarShipPtr->ship_input_state &= ~SPECIAL;
@@ -373,6 +517,7 @@ black_urquan_intelligence (ELEMENT *Ship
 	if (StarShipPtr->special_counter == 0
 			&& StarShipPtr->RaceDescPtr->ship_info.energy_level >= SPECIAL_ENERGY_COST
 			&& lpEvalDesc->ObjectPtr
+			&& !(lpEvalDesc->ObjectPtr->state_flags & GASSY_SUBSTANCE)
 			&& lpEvalDesc->which_turn <= 8)
 		StarShipPtr->ship_input_state |= SPECIAL;
 
@@ -467,9 +612,9 @@ gas_cloud_collision (ELEMENT *ElementPtr
 static void
 spawn_gas_cloud (ELEMENT *ElementPtr)
 {
-#define GAS_SPEED 16
+#define GAS_SPEED (16 << RESOLUTION_FACTOR) // JMS_GFX
 #define GAS_HITS 100
-#define GAS_OFFSET 2
+#define GAS_OFFSET (2 << RESOLUTION_FACTOR) // JMS_GFX
 #define NUM_GAS_CLOUDS 16
 	SIZE dx, dy;
 	STARSHIP *StarShipPtr;
@@ -482,7 +627,7 @@ spawn_gas_cloud (ELEMENT *ElementPtr)
 	MissileBlock.index = 0;
 	MissileBlock.sender = ElementPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
-	MissileBlock.pixoffs = 20;
+	MissileBlock.pixoffs = 20 << RESOLUTION_FACTOR; // JMS_GFX
 	MissileBlock.speed = GAS_SPEED;
 	MissileBlock.hit_points = GAS_HITS;
 	MissileBlock.damage = GAS_DAMAGE;
@@ -554,12 +699,30 @@ init_black_urquan (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	black_urquan_desc.preprocess_func = black_urquan_preprocess;
-	black_urquan_desc.postprocess_func = black_urquan_postprocess;
-	black_urquan_desc.init_weapon_func = initialize_buzzsaw;
-	black_urquan_desc.cyborg_control.intelligence_func = black_urquan_intelligence;
-
-	RaceDescPtr = &black_urquan_desc;
-
+	// JMS_GFX: A rather clumsy way of giving ship correct stats at hi-res mode
+	if (RESOLUTION_FACTOR == 0)
+	{
+		black_urquan_desc.preprocess_func = black_urquan_preprocess;
+		black_urquan_desc.postprocess_func = black_urquan_postprocess;
+		black_urquan_desc.init_weapon_func = initialize_buzzsaw;
+		black_urquan_desc.cyborg_control.intelligence_func = black_urquan_intelligence;
+		RaceDescPtr = &black_urquan_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		black_urquan_desc_2xres.preprocess_func = black_urquan_preprocess;
+		black_urquan_desc_2xres.postprocess_func = black_urquan_postprocess;
+		black_urquan_desc_2xres.init_weapon_func = initialize_buzzsaw;
+		black_urquan_desc_2xres.cyborg_control.intelligence_func = black_urquan_intelligence;
+		RaceDescPtr = &black_urquan_desc_2xres;
+	}
+	else
+	{
+		black_urquan_desc_4xres.preprocess_func = black_urquan_preprocess;
+		black_urquan_desc_4xres.postprocess_func = black_urquan_postprocess;
+		black_urquan_desc_4xres.init_weapon_func = initialize_buzzsaw;
+		black_urquan_desc_4xres.cyborg_control.intelligence_func = black_urquan_intelligence;
+		RaceDescPtr = &black_urquan_desc_4xres;
+	}
 	return (RaceDescPtr);
 }
diff -ruNp src.orig/uqm/ships/blackurq/icode.h src/uqm/ships/blackurq/icode.h
--- src.orig/uqm/ships/blackurq/icode.h	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/blackurq/icode.h	2017-11-01 15:31:04 -0700
@@ -1 +1,6 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define KOHR_AH_CODE "ship.kohrah.code"
+#define SLYLANDRO_KOHRAH_CODE "ship.slykohr.code"
diff -ruNp src.orig/uqm/ships/chenjesu/chenjesu.c src/uqm/ships/chenjesu/chenjesu.c
--- src.orig/uqm/ships/chenjesu/chenjesu.c	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/chenjesu/chenjesu.c	2017-11-01 15:31:04 -0700
@@ -41,9 +41,7 @@
 
 #define SHIP_MASS 10
 #define MISSILE_SPEED DISPLAY_TO_WORLD (16)
-#define MISSILE_LIFE 90 /* actually, it's as long as you
-										 * hold the button down.
-										 */
+#define MISSILE_LIFE 90 /* actually, it's as long as you hold the button down. */
 
 static RACE_DESC chenjesu_desc =
 {
@@ -55,7 +53,7 @@ static RACE_DESC chenjesu_desc =
 		CHENJESU_RACE_STRINGS,
 		CHENJESU_ICON_MASK_PMAP_ANIM,
 		CHENJESU_MICON_MASK_PMAP_ANIM,
-		NULL, NULL, NULL
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
 	},
 	{ /* FLEET_STUFF */
 		0, /* Initial sphere of influence radius */
@@ -116,6 +114,156 @@ static RACE_DESC chenjesu_desc =
 	0, /* CodeRef */
 };
 
+#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (14) */ 54 // JMS_GFX
+#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (4) */ 6 // JMS_GFX
+
+// JMS_GFX
+static RACE_DESC chenjesu_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_SPECIAL | SEEKING_WEAPON,
+		28, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		CHENJESU_RACE_STRINGS,
+		CHENJESU_ICON_MASK_PMAP_ANIM,
+		CHENJESU_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			CHENJESU_BIG_MASK_PMAP_ANIM,
+			CHENJESU_MED_MASK_PMAP_ANIM,
+			CHENJESU_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SPARK_BIG_MASK_PMAP_ANIM,
+			SPARK_MED_MASK_PMAP_ANIM,
+			SPARK_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DOGGY_BIG_MASK_PMAP_ANIM,
+			DOGGY_MED_MASK_PMAP_ANIM,
+			DOGGY_SML_MASK_PMAP_ANIM,
+		},
+		{
+			CHENJESU_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		CHENJESU_VICTORY_SONG,
+		CHENJESU_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		LONG_RANGE_WEAPON_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (14) */ 108 // JMS_GFX
+#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (4) */ 12 // JMS_GFX
+
+// JMS_GFX
+static RACE_DESC chenjesu_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_SPECIAL | SEEKING_WEAPON,
+		28, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		CHENJESU_RACE_STRINGS,
+		CHENJESU_ICON_MASK_PMAP_ANIM,
+		CHENJESU_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			CHENJESU_BIG_MASK_PMAP_ANIM,
+			CHENJESU_MED_MASK_PMAP_ANIM,
+			CHENJESU_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SPARK_BIG_MASK_PMAP_ANIM,
+			SPARK_MED_MASK_PMAP_ANIM,
+			SPARK_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DOGGY_BIG_MASK_PMAP_ANIM,
+			DOGGY_MED_MASK_PMAP_ANIM,
+			DOGGY_SML_MASK_PMAP_ANIM,
+		},
+		{
+			CHENJESU_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		CHENJESU_VICTORY_SONG,
+		CHENJESU_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		LONG_RANGE_WEAPON_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 #define FRAGMENT_LIFE 10
 #define FRAGMENT_SPEED MISSILE_SPEED
 #define FRAGMENT_RANGE (FRAGMENT_LIFE * FRAGMENT_SPEED)
@@ -125,7 +273,7 @@ crystal_postprocess (ELEMENT *ElementPtr
 {
 #define FRAGMENT_HITS 1
 #define FRAGMENT_DAMAGE 2
-#define FRAGMENT_OFFSET 2
+#define FRAGMENT_OFFSET (2 << RESOLUTION_FACTOR) // JMS_GFX
 #define NUM_FRAGMENTS 8
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
@@ -138,7 +286,7 @@ crystal_postprocess (ELEMENT *ElementPtr
 	MissileBlock.sender = ElementPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = 0;
-	MissileBlock.speed = FRAGMENT_SPEED;
+	MissileBlock.speed = FRAGMENT_SPEED << RESOLUTION_FACTOR; // JMS_GFX
 	MissileBlock.hit_points = FRAGMENT_HITS;
 	MissileBlock.damage = FRAGMENT_DAMAGE;
 	MissileBlock.life = FRAGMENT_LIFE;
@@ -231,8 +379,8 @@ crystal_collision (ELEMENT *ElementPtr0,
 	}
 }
 
-#define DOGGY_OFFSET 18
-#define DOGGY_SPEED DISPLAY_TO_WORLD (8)
+#define DOGGY_OFFSET ((18 << RESOLUTION_FACTOR) + 10 * RESOLUTION_FACTOR) // JMS_GFX: Let's ensure the doggy doesn't spawn on top of Chenjesu ship and die.
+#define DOGGY_SPEED DISPLAY_TO_WORLD (8 << RESOLUTION_FACTOR) // JMS_GFX
 
 static void
 doggy_preprocess (ELEMENT *ElementPtr)
@@ -248,10 +396,8 @@ doggy_preprocess (ELEMENT *ElementPtr)
 		COUNT facing, orig_facing;
 		SIZE delta_facing;
 
-		facing = orig_facing =
-				NORMALIZE_FACING (ANGLE_TO_FACING (
-				GetVelocityTravelAngle (&ElementPtr->velocity)
-				));
+		facing = orig_facing = NORMALIZE_FACING (ANGLE_TO_FACING (GetVelocityTravelAngle (&ElementPtr->velocity)));
+		
 		if ((delta_facing = TrackShip (ElementPtr, &facing)) < 0)
 			facing = NORMALIZE_FACING (TFB_Random ());
 		else
@@ -265,8 +411,7 @@ doggy_preprocess (ELEMENT *ElementPtr)
 					ShipPtr->current.location.y -
 					ElementPtr->current.location.y)
 					));
-			delta_facing = NORMALIZE_FACING (facing -
-					GetFrameIndex (ShipPtr->current.image.frame));
+			delta_facing = NORMALIZE_FACING (facing - GetFrameIndex (ShipPtr->current.image.frame));
 			UnlockElement (ElementPtr->hTarget);
 
 			if (delta_facing > ANGLE_TO_FACING (HALF_CIRCLE - OCTANT) &&
@@ -282,8 +427,7 @@ doggy_preprocess (ELEMENT *ElementPtr)
 		}
 
 		if (facing != orig_facing)
-			SetVelocityVector (&ElementPtr->velocity,
-					DOGGY_SPEED, facing);
+			SetVelocityVector (&ElementPtr->velocity, DOGGY_SPEED, facing);
 	}
 }
 
@@ -335,7 +479,7 @@ doggy_collision (ELEMENT *ElementPtr0, P
 		ElementPtr0->thrust_wait += COLLISION_THRUST_WAIT << 1;
 }
 
-#define CHENJESU_OFFSET 16
+#define CHENJESU_OFFSET (16 << RESOLUTION_FACTOR) // JMS_GFX
 
 static void
 spawn_doggy (ELEMENT *ElementPtr)
@@ -376,8 +520,7 @@ spawn_doggy (ELEMENT *ElementPtr)
 		DoggyElementPtr->current.image.farray = StarShipPtr->RaceDescPtr->ship_data.special;
 		DoggyElementPtr->current.image.frame = StarShipPtr->RaceDescPtr->ship_data.special[0];
 
-		SetVelocityVector (&DoggyElementPtr->velocity,
-				DOGGY_SPEED, NORMALIZE_FACING (ANGLE_TO_FACING (angle)));
+		SetVelocityVector (&DoggyElementPtr->velocity, DOGGY_SPEED, NORMALIZE_FACING (ANGLE_TO_FACING (angle)));
 
 		SetElementStarShip (DoggyElementPtr, StarShipPtr);
 
@@ -408,13 +551,13 @@ chenjesu_intelligence (ELEMENT *ShipPtr,
 		if ((lpEvalDesc->which_turn <= 16
 				&& MANEUVERABILITY (
 				&EnemyStarShipPtr->RaceDescPtr->cyborg_control
-				) >= MEDIUM_SHIP)
+				) >= (MEDIUM_SHIP << RESOLUTION_FACTOR)) // JMS_GFX
 				|| (MANEUVERABILITY (
 				&EnemyStarShipPtr->RaceDescPtr->cyborg_control
-				) <= SLOW_SHIP
+				) <= (SLOW_SHIP << RESOLUTION_FACTOR) // JMS_GFX
 				&& WEAPON_RANGE (
 				&EnemyStarShipPtr->RaceDescPtr->cyborg_control
-				) >= LONG_RANGE_WEAPON * 3 / 4
+				) >= (LONG_RANGE_WEAPON << RESOLUTION_FACTOR) * 3 / 4 // JMS_GFX
 				&& (EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags & SEEKING_WEAPON)))
 			lpEvalDesc->MoveState = PURSUE;
 	}
@@ -453,11 +596,11 @@ chenjesu_intelligence (ELEMENT *ShipPtr,
 					if ((which_turn = PlotIntercept (CrystalPtr,
 							ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr,
 							CrystalPtr->life_span,
-							FRAGMENT_RANGE / 2)) == 0
+							(FRAGMENT_RANGE << RESOLUTION_FACTOR) / 2)) == 0
 							|| (which_turn == 1
 							&& PlotIntercept (CrystalPtr,
 							ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr,
-							CrystalPtr->life_span, 0) == 0))
+							CrystalPtr->life_span, 0) == 0)) // JMS_GFX
 						StarShipPtr->ship_input_state &= ~WEAPON;
 					else if (StarShipPtr->weapon_counter == 0)
 					{
@@ -482,7 +625,7 @@ chenjesu_intelligence (ELEMENT *ShipPtr,
 					StarShipPtr->weapon_counter = 3;
 			}
 			else if (StarShipPtr->weapon_counter == 0
-					&& ship_weapons (ShipPtr, lpEvalDesc->ObjectPtr, FRAGMENT_RANGE / 2))
+					&& ship_weapons (ShipPtr, lpEvalDesc->ObjectPtr, (FRAGMENT_RANGE << RESOLUTION_FACTOR) / 2)) // JMS_GFX
 				StarShipPtr->ship_input_state |= WEAPON;
 		}
 	}
@@ -514,7 +657,7 @@ initialize_crystal (ELEMENT *ShipPtr, HE
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = CHENJESU_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -573,13 +716,32 @@ init_chenjesu (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	chenjesu_desc.preprocess_func = chenjesu_preprocess;
-	chenjesu_desc.postprocess_func = chenjesu_postprocess;
-	chenjesu_desc.init_weapon_func = initialize_crystal;
-	chenjesu_desc.cyborg_control.intelligence_func = chenjesu_intelligence;
-
-	RaceDescPtr = &chenjesu_desc;
-
+	// JMS_GFX: A rather clumsy way of giving ship correct stats at hi-res mode
+	if (RESOLUTION_FACTOR == 0)
+	{
+		chenjesu_desc.preprocess_func = chenjesu_preprocess;
+		chenjesu_desc.postprocess_func = chenjesu_postprocess;
+		chenjesu_desc.init_weapon_func = initialize_crystal;
+		chenjesu_desc.cyborg_control.intelligence_func = chenjesu_intelligence;
+		RaceDescPtr = &chenjesu_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		chenjesu_desc_2xres.preprocess_func = chenjesu_preprocess;
+		chenjesu_desc_2xres.postprocess_func = chenjesu_postprocess;
+		chenjesu_desc_2xres.init_weapon_func = initialize_crystal;
+		chenjesu_desc_2xres.cyborg_control.intelligence_func = chenjesu_intelligence;
+		RaceDescPtr = &chenjesu_desc_2xres;
+	}
+	else
+	{
+		chenjesu_desc_4xres.preprocess_func = chenjesu_preprocess;
+		chenjesu_desc_4xres.postprocess_func = chenjesu_postprocess;
+		chenjesu_desc_4xres.init_weapon_func = initialize_crystal;
+		chenjesu_desc_4xres.cyborg_control.intelligence_func = chenjesu_intelligence;
+		RaceDescPtr = &chenjesu_desc_4xres;
+	}
+	
 	return (RaceDescPtr);
 }
 
diff -ruNp src.orig/uqm/ships/chenjesu/icode.h src/uqm/ships/chenjesu/icode.h
--- src.orig/uqm/ships/chenjesu/icode.h	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/chenjesu/icode.h	2017-11-01 15:31:04 -0700
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define CHENJESU_CODE "ship.chenjesu.code"
diff -ruNp src.orig/uqm/ships/chmmr/chmmr.c src/uqm/ships/chmmr/chmmr.c
--- src.orig/uqm/ships/chmmr/chmmr.c	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/chmmr/chmmr.c	2017-11-01 15:31:04 -0700
@@ -45,19 +45,19 @@
 static RACE_DESC chmmr_desc =
 {
 	{ /* SHIP_INFO */
-		FIRES_FORE | IMMEDIATE_WEAPON | SEEKING_SPECIAL | POINT_DEFENSE,
+		FIRES_FORE | IMMEDIATE_WEAPON | SEEKING_SPECIAL | HEAVY_POINT_DEFENSE,
 		30, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY, MAX_ENERGY,
 		CHMMR_RACE_STRINGS,
 		CHMMR_ICON_MASK_PMAP_ANIM,
 		CHMMR_MICON_MASK_PMAP_ANIM,
-		NULL, NULL, NULL
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
 	},
 	{ /* FLEET_STUFF */
-		0, /* Initial sphere of influence radius */
+		1400 / SPHERE_RADIUS_INCREMENT * 2, /* Initial sphere of influence radius */
 		{ /* Known location (center of SoI) */
-			0, 0,
+			5562, 8518,
 		},
 	},
 	{
@@ -113,6 +113,158 @@ static RACE_DESC chmmr_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+#define MAX_THRUST_2XRES 70
+#define THRUST_INCREMENT_2XRES 14
+
+// JMS_GFX
+static RACE_DESC chmmr_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | IMMEDIATE_WEAPON | SEEKING_SPECIAL | HEAVY_POINT_DEFENSE,
+		30, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		CHMMR_RACE_STRINGS,
+		CHMMR_ICON_MASK_PMAP_ANIM,
+		CHMMR_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		1400 / SPHERE_RADIUS_INCREMENT * 2, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			5562, 8518,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			CHMMR_BIG_MASK_PMAP_ANIM,
+			CHMMR_MED_MASK_PMAP_ANIM,
+			CHMMR_SML_MASK_PMAP_ANIM,
+		},
+		{
+			MUZZLE_BIG_MASK_PMAP_ANIM,
+			MUZZLE_MED_MASK_PMAP_ANIM,
+			MUZZLE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SATELLITE_BIG_MASK_PMAP_ANIM,
+			SATELLITE_MED_MASK_PMAP_ANIM,
+			SATELLITE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			CHMMR_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		CHMMR_VICTORY_SONG,
+		CHMMR_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 140
+#define THRUST_INCREMENT_4XRES 28
+
+// JMS_GFX
+static RACE_DESC chmmr_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | IMMEDIATE_WEAPON | SEEKING_SPECIAL | HEAVY_POINT_DEFENSE,
+		30, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		CHMMR_RACE_STRINGS,
+		CHMMR_ICON_MASK_PMAP_ANIM,
+		CHMMR_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		1400 / SPHERE_RADIUS_INCREMENT * 2, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			5562, 8518,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			CHMMR_BIG_MASK_PMAP_ANIM,
+			CHMMR_MED_MASK_PMAP_ANIM,
+			CHMMR_SML_MASK_PMAP_ANIM,
+		},
+		{
+			MUZZLE_BIG_MASK_PMAP_ANIM,
+			MUZZLE_MED_MASK_PMAP_ANIM,
+			MUZZLE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SATELLITE_BIG_MASK_PMAP_ANIM,
+			SATELLITE_MED_MASK_PMAP_ANIM,
+			SATELLITE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			CHMMR_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		CHMMR_VICTORY_SONG,
+		CHMMR_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static void
 animate (ELEMENT *ElementPtr)
 {
@@ -120,10 +272,8 @@ animate (ELEMENT *ElementPtr)
 		--ElementPtr->turn_wait;
 	else
 	{
-		ElementPtr->next.image.frame =
-				IncFrameIndex (ElementPtr->current.image.frame);
+		ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->current.image.frame);
 		ElementPtr->state_flags |= CHANGING;
-
 		ElementPtr->turn_wait = ElementPtr->next_turn;
 	}
 }
@@ -145,14 +295,13 @@ laser_death (ELEMENT *ElementPtr)
 
 		LockElement (StarShipPtr->hShip, &ShipPtr);
 
-		dx = ElementPtr->current.location.x
-				- ShipPtr->current.location.x;
-		dy = ElementPtr->current.location.y
-				- ShipPtr->current.location.y;
+		dx = ElementPtr->current.location.x - ShipPtr->current.location.x;
+		dy = ElementPtr->current.location.y - ShipPtr->current.location.y;
+		
 		if (((BYTE)TFB_Random () & 0x07)
 				&& (dist = (long)dx * dx + (long)dy * dy) >=
-				(long)DISPLAY_TO_WORLD (CHMMR_OFFSET + 10)
-				* DISPLAY_TO_WORLD (CHMMR_OFFSET + 10)
+				(long)DISPLAY_TO_WORLD ((CHMMR_OFFSET + 10) << RESOLUTION_FACTOR) // JMS_GFX
+				* DISPLAY_TO_WORLD ((CHMMR_OFFSET + 10) << RESOLUTION_FACTOR) // JMS_GFX
 				&& (hIonSpots = AllocElement ()))
 		{
 			COUNT angle, magnitude;
@@ -160,16 +309,16 @@ laser_death (ELEMENT *ElementPtr)
 
 			LockElement (hIonSpots, &IonSpotsPtr);
 			IonSpotsPtr->playerNr = ElementPtr->playerNr;
-			IonSpotsPtr->state_flags = FINITE_LIFE | NONSOLID
-					| IGNORE_SIMILAR | APPEARING;
+			IonSpotsPtr->state_flags = FINITE_LIFE | NONSOLID | IGNORE_SIMILAR | APPEARING;
 			IonSpotsPtr->turn_wait = IonSpotsPtr->next_turn = 0;
-			IonSpotsPtr->life_span = 9;
+			IonSpotsPtr->life_span = RES_CASE(9,9,14);
+			// BW: account for the extra frames in the hires version
 
 			angle = ARCTAN (dx, dy);
 			magnitude = ((COUNT)TFB_Random ()
 					% ((square_root (dist) + 1)
-					- DISPLAY_TO_WORLD (CHMMR_OFFSET + 10)))
-					+ DISPLAY_TO_WORLD (CHMMR_OFFSET + 10);
+					- DISPLAY_TO_WORLD ((CHMMR_OFFSET + 10) << RESOLUTION_FACTOR))) // JMS_GFX
+					+ DISPLAY_TO_WORLD ((CHMMR_OFFSET + 10) << RESOLUTION_FACTOR); // JMS_GFX
 			IonSpotsPtr->current.location.x =
 					ShipPtr->current.location.x
 					+ COSINE (angle, magnitude);
@@ -187,9 +336,7 @@ laser_death (ELEMENT *ElementPtr)
 
 			SetElementStarShip (IonSpotsPtr, StarShipPtr);
 
-			SetPrimType (&(GLOBAL (DisplayArray))[
-					IonSpotsPtr->PrimIndex
-					], STAMP_PRIM);
+			SetPrimType (&(GLOBAL (DisplayArray))[IonSpotsPtr->PrimIndex], STAMP_PRIM);
 
 			UnlockElement (hIonSpots);
 			PutElement (hIonSpots);
@@ -216,15 +363,13 @@ initialize_megawatt_laser (ELEMENT *Ship
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	LaserBlock.face = StarShipPtr->ShipFacing;
-	GetFrameRect (SetAbsFrameIndex (
-			StarShipPtr->RaceDescPtr->ship_data.weapon[0], LaserBlock.face
-			), &r);
-	LaserBlock.cx = DISPLAY_ALIGN (ShipPtr->next.location.x)
-			+ DISPLAY_TO_WORLD (r.corner.x);
-	LaserBlock.cy = DISPLAY_ALIGN (ShipPtr->next.location.y)
-			+ DISPLAY_TO_WORLD (r.corner.y);
-	LaserBlock.ex = COSINE (FACING_TO_ANGLE (LaserBlock.face), LASER_RANGE);
-	LaserBlock.ey = SINE (FACING_TO_ANGLE (LaserBlock.face), LASER_RANGE);
+	GetFrameRect (SetAbsFrameIndex (StarShipPtr->RaceDescPtr->ship_data.weapon[0], LaserBlock.face), &r);
+	
+	LaserBlock.cx = DISPLAY_ALIGN (ShipPtr->next.location.x) + DISPLAY_TO_WORLD (r.corner.x);
+	LaserBlock.cy = DISPLAY_ALIGN (ShipPtr->next.location.y) + DISPLAY_TO_WORLD (r.corner.y);
+	
+	LaserBlock.ex = COSINE (FACING_TO_ANGLE (LaserBlock.face), (LASER_RANGE << RESOLUTION_FACTOR)); // JMS_GFX
+	LaserBlock.ey = SINE (FACING_TO_ANGLE (LaserBlock.face), (LASER_RANGE << RESOLUTION_FACTOR)); // JMS_GFX
 	LaserBlock.sender = ShipPtr->playerNr;
 	LaserBlock.flags = IGNORE_SIMILAR;
 	LaserBlock.pixoffs = 0;
@@ -239,8 +384,7 @@ initialize_megawatt_laser (ELEMENT *Ship
 
 		LaserPtr->mass_points = 2;
 		LaserPtr->death_func = laser_death;
-		LaserPtr->turn_wait = (BYTE)((StarShipPtr->special_counter + 1)
-				% NUM_CYCLES);
+		LaserPtr->turn_wait = (BYTE)((StarShipPtr->special_counter + 1) % NUM_CYCLES);
 
 		UnlockElement (LaserArray[0]);
 	}
@@ -249,8 +393,7 @@ initialize_megawatt_laser (ELEMENT *Ship
 }
 
 static void
-chmmr_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
-		COUNT ConcernCounter)
+chmmr_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern, COUNT ConcernCounter)
 {
 	STARSHIP *StarShipPtr;
 	EVALUATE_DESC *lpEvalDesc;
@@ -296,13 +439,11 @@ chmmr_postprocess (ELEMENT *ElementPtr)
 		{
 			LockElement (hMuzzleFlash, &MuzzleFlashPtr);
 			MuzzleFlashPtr->playerNr = ElementPtr->playerNr;
-			MuzzleFlashPtr->state_flags = FINITE_LIFE | NONSOLID
-					| IGNORE_SIMILAR | APPEARING;
+			MuzzleFlashPtr->state_flags = FINITE_LIFE | NONSOLID | IGNORE_SIMILAR | APPEARING;
 			MuzzleFlashPtr->life_span = 1;
 
 			MuzzleFlashPtr->current = ElementPtr->next;
-			MuzzleFlashPtr->current.image.farray =
-					StarShipPtr->RaceDescPtr->ship_data.weapon;
+			MuzzleFlashPtr->current.image.farray = StarShipPtr->RaceDescPtr->ship_data.weapon;
 			MuzzleFlashPtr->current.image.frame = SetAbsFrameIndex (
 					StarShipPtr->RaceDescPtr->ship_data.weapon[0],
 					StarShipPtr->ShipFacing + ANGLE_TO_FACING (FULL_CIRCLE)
@@ -320,18 +461,13 @@ chmmr_postprocess (ELEMENT *ElementPtr)
 		UnlockElement (GetTailElement ());
 	}
 
-	if ((StarShipPtr->cur_status_flags & SPECIAL)
-			&& DeltaEnergy (ElementPtr, -SPECIAL_ENERGY_COST))
+	if ((StarShipPtr->cur_status_flags & SPECIAL) && DeltaEnergy (ElementPtr, -SPECIAL_ENERGY_COST))
 	{
 		COUNT facing;
 		ELEMENT *ShipElementPtr;
 
 		LockElement (ElementPtr->hTarget, &ShipElementPtr);
-		
-		ProcessSound (SetAbsSoundIndex (
-				StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 1),
-				ShipElementPtr);
-
+		ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 1), ShipElementPtr);
 		UnlockElement (ElementPtr->hTarget);
 
 		facing = 0;
@@ -355,6 +491,22 @@ chmmr_postprocess (ELEMENT *ElementPtr)
 					DISPLAY_TO_WORLD (8 + 9 + 11 + 14),
 					DISPLAY_TO_WORLD (8 + 9 + 11 + 14 + 18),
 				};
+				static const SIZE shadow_offs_2xres[] =
+				{
+					DISPLAY_TO_WORLD (16),
+					DISPLAY_TO_WORLD (16 + 18),
+					DISPLAY_TO_WORLD (16 + 18 + 22),
+					DISPLAY_TO_WORLD (16 + 18 + 22 + 28),
+					DISPLAY_TO_WORLD (16 + 18 + 22 + 28 + 36),
+				};
+				static const SIZE shadow_offs_4xres[] =
+				{
+					DISPLAY_TO_WORLD (32),
+					DISPLAY_TO_WORLD (32 + 36),
+					DISPLAY_TO_WORLD (32 + 36 + 44),
+					DISPLAY_TO_WORLD (32 + 36 + 44 + 56),
+					DISPLAY_TO_WORLD (32 + 36 + 44 + 56 + 72),
+				};
 				static const Color color_tab[] =
 				{
 					BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x10), 0x53),
@@ -368,33 +520,27 @@ chmmr_postprocess (ELEMENT *ElementPtr)
 				// calculate tractor beam effect
 				angle = FACING_TO_ANGLE (StarShipPtr->ShipFacing);
 				dx = (ElementPtr->next.location.x
-						+ COSINE (angle, (LASER_RANGE / 3)
-						+ DISPLAY_TO_WORLD (CHMMR_OFFSET)))
+						+ COSINE (angle, ((LASER_RANGE << RESOLUTION_FACTOR) / 3) // JMS_GFX
+						+ DISPLAY_TO_WORLD (CHMMR_OFFSET << RESOLUTION_FACTOR))) // JMS_GFX
 						- ShipElementPtr->next.location.x;
 				dy = (ElementPtr->next.location.y
-						+ SINE (angle, (LASER_RANGE / 3)
-						+ DISPLAY_TO_WORLD (CHMMR_OFFSET)))
+						+ SINE (angle, ((LASER_RANGE << RESOLUTION_FACTOR) / 3) // JMS_GFX
+						+ DISPLAY_TO_WORLD (CHMMR_OFFSET << RESOLUTION_FACTOR))) // JMS_GFX
 						- ShipElementPtr->next.location.y;
 				angle = ARCTAN (dx, dy);
-				magnitude = WORLD_TO_VELOCITY (12) /
-						ShipElementPtr->mass_points;
-				DeltaVelocityComponents (&ShipElementPtr->velocity,
-						COSINE (angle, magnitude), SINE (angle, magnitude));
+				magnitude = WORLD_TO_VELOCITY (12 << RESOLUTION_FACTOR) / ShipElementPtr->mass_points; // JMS_GFX
+				DeltaVelocityComponents (&ShipElementPtr->velocity, COSINE (angle, magnitude), SINE (angle, magnitude));
 
-				GetCurrentVelocityComponents (&ShipElementPtr->velocity,
-						&dx, &dy);
+				GetCurrentVelocityComponents (&ShipElementPtr->velocity,&dx, &dy);
 				GetElementStarShip (ShipElementPtr, &EnemyStarShipPtr);
 
 				// set the effected ship's speed flags
 				current_speed = VelocitySquared (dx, dy);
-				max_speed = VelocitySquared (WORLD_TO_VELOCITY (
-						EnemyStarShipPtr->RaceDescPtr->characteristics.max_thrust),
-						0);
-				EnemyStarShipPtr->cur_status_flags &= ~(SHIP_AT_MAX_SPEED
-						| SHIP_BEYOND_MAX_SPEED);
+				max_speed = VelocitySquared (WORLD_TO_VELOCITY (EnemyStarShipPtr->RaceDescPtr->characteristics.max_thrust),0);
+				
+				EnemyStarShipPtr->cur_status_flags &= ~(SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED);
 				if (current_speed > max_speed)
-					EnemyStarShipPtr->cur_status_flags |= (SHIP_AT_MAX_SPEED
-							| SHIP_BEYOND_MAX_SPEED);
+					EnemyStarShipPtr->cur_status_flags |= (SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED);
 				else if (current_speed == max_speed)
 					EnemyStarShipPtr->cur_status_flags |= SHIP_AT_MAX_SPEED;
 
@@ -407,23 +553,28 @@ chmmr_postprocess (ELEMENT *ElementPtr)
 					if (hShadow)
 					{
 						ELEMENT *ShadowElementPtr;
+						COUNT shadow_magnitude; // JMS_GFX
+						
+						// JMS_GFX
+						if (RESOLUTION_FACTOR == 0)
+							shadow_magnitude = shadow_offs[i];
+						else if (RESOLUTION_FACTOR == 1)
+							shadow_magnitude = shadow_offs_2xres[i];
+						else
+							shadow_magnitude = shadow_offs_4xres[i];
 
 						LockElement (hShadow, &ShadowElementPtr);
 						ShadowElementPtr->playerNr = ShipElementPtr->playerNr;
-						ShadowElementPtr->state_flags = FINITE_LIFE | NONSOLID
-								| IGNORE_SIMILAR | POST_PROCESS;
+						ShadowElementPtr->state_flags = FINITE_LIFE | NONSOLID | IGNORE_SIMILAR | POST_PROCESS;
 						ShadowElementPtr->life_span = 1;
 
 						ShadowElementPtr->current = ShipElementPtr->next;
-						ShadowElementPtr->current.location.x +=
-								COSINE (angle, shadow_offs[i]);
-						ShadowElementPtr->current.location.y +=
-								SINE (angle, shadow_offs[i]);
+						ShadowElementPtr->current.location.x += COSINE (angle, shadow_magnitude); // JMS_GFX: replaced shadow_offs[i] with shadow_magnitude
+						ShadowElementPtr->current.location.y += SINE (angle, shadow_magnitude);   // JMS_GFX
 						ShadowElementPtr->next = ShadowElementPtr->current;
 
 						SetElementStarShip (ShadowElementPtr, EnemyStarShipPtr);
-						SetVelocityComponents (&ShadowElementPtr->velocity,
-								dx, dy);
+						SetVelocityComponents (&ShadowElementPtr->velocity, dx, dy);
 
 						SetPrimType (&(GLOBAL (DisplayArray))[
 								ShadowElementPtr->PrimIndex
@@ -444,7 +595,7 @@ chmmr_postprocess (ELEMENT *ElementPtr)
 	StarShipPtr->special_counter = 0;
 }
 
-#define SATELLITE_OFFSET DISPLAY_TO_WORLD (64)
+#define SATELLITE_OFFSET DISPLAY_TO_WORLD (64 << RESOLUTION_FACTOR) // JMS_GFX
 
 static void
 satellite_preprocess (ELEMENT *ElementPtr)
@@ -468,7 +619,7 @@ satellite_preprocess (ELEMENT *ElementPt
 		SIZE dx, dy;
 		ELEMENT *ShipPtr;
 
-		StarShipPtr->RaceDescPtr->ship_info.ship_flags |= POINT_DEFENSE;
+		StarShipPtr->RaceDescPtr->ship_info.ship_flags |= HEAVY_POINT_DEFENSE;
 
 		LockElement (StarShipPtr->hShip, &ShipPtr);
 
@@ -481,7 +632,7 @@ satellite_preprocess (ELEMENT *ElementPt
 		dx = WRAP_DELTA_X (dx);
 		dy = WRAP_DELTA_Y (dy);
 		if ((long)dx * dx + (long)dy * dy
-				<= DISPLAY_TO_WORLD (20L) * DISPLAY_TO_WORLD (20L))
+				<= DISPLAY_TO_WORLD (20L << RESOLUTION_FACTOR) * DISPLAY_TO_WORLD (20L << RESOLUTION_FACTOR)) // JMS_GFX
 			SetVelocityComponents (&ElementPtr->velocity,
 					WORLD_TO_VELOCITY (dx),
 					WORLD_TO_VELOCITY (dy));
@@ -491,8 +642,8 @@ satellite_preprocess (ELEMENT *ElementPt
 
 			angle = ARCTAN (dx, dy);
 			SetVelocityComponents (&ElementPtr->velocity,
-					COSINE (angle, WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (20))),
-					SINE (angle, WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (20))));
+					COSINE (angle, WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (20 << RESOLUTION_FACTOR))),
+					SINE (angle, WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (20 << RESOLUTION_FACTOR)))); // JMS_GFX
 		}
 
 		UnlockElement (StarShipPtr->hShip);
@@ -502,7 +653,7 @@ satellite_preprocess (ELEMENT *ElementPt
 static void
 spawn_point_defense (ELEMENT *ElementPtr)
 {
-#define DEFENSE_RANGE (UWORD)64
+#define DEFENSE_RANGE (UWORD)(64 << RESOLUTION_FACTOR) // JMS_GFX
 #define DEFENSE_WAIT 2
 	BYTE weakest;
 	UWORD best_dist;
@@ -514,7 +665,7 @@ spawn_point_defense (ELEMENT *ElementPtr
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	hBestObject = 0;
-	best_dist = DEFENSE_RANGE + 1;
+	best_dist = DEFENSE_RANGE + (1 << RESOLUTION_FACTOR); // JMS_GFX
 	weakest = 255;
 	LockElement (StarShipPtr->hShip, &ShipPtr);
 	LockElement (ElementPtr->hTarget, &SattPtr);
@@ -526,7 +677,8 @@ spawn_point_defense (ELEMENT *ElementPtr
 		if (!elementsOfSamePlayer (ObjectPtr, ShipPtr)
 				&& ObjectPtr->playerNr != NEUTRAL_PLAYER_NUM
 				&& CollisionPossible (ObjectPtr, ShipPtr)
-				&& !OBJECT_CLOAKED (ObjectPtr))
+				&& !OBJECT_CLOAKED (ObjectPtr)
+				&& !(ObjectPtr->state_flags & GASSY_SUBSTANCE))
 		{
 			SIZE delta_x, delta_y;
 			UWORD dist;
@@ -569,10 +721,8 @@ spawn_point_defense (ELEMENT *ElementPtr
 		LaserBlock.cx = SattPtr->next.location.x;
 		LaserBlock.cy = SattPtr->next.location.y;
 		LaserBlock.face = 0;
-		LaserBlock.ex = ObjectPtr->next.location.x
-				- SattPtr->next.location.x;
-		LaserBlock.ey = ObjectPtr->next.location.y
-				- SattPtr->next.location.y;
+		LaserBlock.ex = ObjectPtr->next.location.x - SattPtr->next.location.x;
+		LaserBlock.ey = ObjectPtr->next.location.y - SattPtr->next.location.y;
 		LaserBlock.sender = SattPtr->playerNr;
 		LaserBlock.flags = IGNORE_SIMILAR;
 		LaserBlock.pixoffs = 0;
@@ -655,7 +805,7 @@ satellite_death (ELEMENT *ElementPtr)
 	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
-	StarShipPtr->RaceDescPtr->ship_info.ship_flags &= ~POINT_DEFENSE;
+	StarShipPtr->RaceDescPtr->ship_info.ship_flags &= ~HEAVY_POINT_DEFENSE;
 
 	ElementPtr->state_flags &= ~DISAPPEARING;
 	ElementPtr->state_flags |= NONSOLID | FINITE_LIFE | CHANGING;
@@ -694,8 +844,7 @@ spawn_satellites (ELEMENT *ElementPtr)
 
 				LockElement (hSatellite, &SattPtr);
 				SattPtr->playerNr = ElementPtr->playerNr;
-				SattPtr->state_flags = IGNORE_SIMILAR | APPEARING
-						| FINITE_LIFE;
+				SattPtr->state_flags = IGNORE_SIMILAR | APPEARING | FINITE_LIFE | GASSY_SUBSTANCE; // JMS: The GASSY_SUBSTANCE makes the baul gas stick to zapsat.
 				SattPtr->life_span = NORMAL_LIFE + 1;
 				SattPtr->hit_points = 10;
 				SattPtr->mass_points = 10;
@@ -748,8 +897,7 @@ chmmr_preprocess (ELEMENT *ElementPtr)
 
 		LockElement (hSatellite, &SattPtr);
 		SattPtr->playerNr = ElementPtr->playerNr;
-		SattPtr->state_flags = FINITE_LIFE | NONSOLID | IGNORE_SIMILAR
-				| APPEARING;
+		SattPtr->state_flags = FINITE_LIFE | NONSOLID | IGNORE_SIMILAR | APPEARING;
 		SattPtr->life_span = HYPERJUMP_LIFE + 1;
 
 		SattPtr->death_func = spawn_satellites;
@@ -773,12 +921,31 @@ init_chmmr (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	chmmr_desc.preprocess_func = chmmr_preprocess;
-	chmmr_desc.postprocess_func = chmmr_postprocess;
-	chmmr_desc.init_weapon_func = initialize_megawatt_laser;
-	chmmr_desc.cyborg_control.intelligence_func = chmmr_intelligence;
-
-	RaceDescPtr = &chmmr_desc;
+	// JMS_GFX: A rather clumsy way of giving ship correct stats at hi-res mode
+	if (RESOLUTION_FACTOR == 0)
+	{
+		chmmr_desc.preprocess_func = chmmr_preprocess;
+		chmmr_desc.postprocess_func = chmmr_postprocess;
+		chmmr_desc.init_weapon_func = initialize_megawatt_laser;
+		chmmr_desc.cyborg_control.intelligence_func = chmmr_intelligence;
+		RaceDescPtr = &chmmr_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		chmmr_desc_2xres.preprocess_func = chmmr_preprocess;
+		chmmr_desc_2xres.postprocess_func = chmmr_postprocess;
+		chmmr_desc_2xres.init_weapon_func = initialize_megawatt_laser;
+		chmmr_desc_2xres.cyborg_control.intelligence_func = chmmr_intelligence;
+		RaceDescPtr = &chmmr_desc_2xres;
+	}
+	else
+	{
+		chmmr_desc_4xres.preprocess_func = chmmr_preprocess;
+		chmmr_desc_4xres.postprocess_func = chmmr_postprocess;
+		chmmr_desc_4xres.init_weapon_func = initialize_megawatt_laser;
+		chmmr_desc_4xres.cyborg_control.intelligence_func = chmmr_intelligence;
+		RaceDescPtr = &chmmr_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp src.orig/uqm/ships/chmmr/icode.h src/uqm/ships/chmmr/icode.h
--- src.orig/uqm/ships/chmmr/icode.h	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/chmmr/icode.h	2017-11-01 15:31:04 -0700
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define CHMMR_CODE "ship.chmmr.code"
diff -ruNp src.orig/uqm/ships/druuge/druuge.c src/uqm/ships/druuge/druuge.c
--- src.orig/uqm/ships/druuge/druuge.c	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/druuge/druuge.c	2017-11-01 15:31:04 -0700
@@ -48,12 +48,12 @@ static RACE_DESC druuge_desc =
 		DRUUGE_RACE_STRINGS,
 		DRUUGE_ICON_MASK_PMAP_ANIM,
 		DRUUGE_MICON_MASK_PMAP_ANIM,
-		NULL, NULL, NULL
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
 	},
 	{ /* FLEET_STUFF */
-		1400 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		0, /* Initial SoI radius */
 		{ /* Known location (center of SoI) */
-			9500, 2792,
+			0,0,
 		},
 	},
 	{
@@ -109,7 +109,163 @@ static RACE_DESC druuge_desc =
 	0, /* CodeRef */
 };
 
-#define RECOIL_VELOCITY WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (6))
+// JMS_GFX
+#define MAX_THRUST_2XRES 40
+#define THRUST_INCREMENT_2XRES 4
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
+#define MISSILE_RANGE_2XRES (MISSILE_SPEED_2XRES * MISSILE_LIFE)
+
+// JMS_GFX
+static RACE_DESC druuge_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		17, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		DRUUGE_RACE_STRINGS,
+		DRUUGE_ICON_MASK_PMAP_ANIM,
+		DRUUGE_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			0,0,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			DRUUGE_BIG_MASK_PMAP_ANIM,
+			DRUUGE_MED_MASK_PMAP_ANIM,
+			DRUUGE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DRUUGE_CANNON_BIG_MASK_PMAP_ANIM,
+			DRUUGE_CANNON_MED_MASK_PMAP_ANIM,
+			DRUUGE_CANNON_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			DRUUGE_CAPT_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		DRUUGE_VICTORY_SONG,
+		DRUUGE_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_RANGE_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 80
+#define THRUST_INCREMENT_4XRES 8
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
+#define MISSILE_RANGE_4XRES (MISSILE_SPEED_4XRES * MISSILE_LIFE)
+
+// JMS_GFX
+static RACE_DESC druuge_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		17, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		DRUUGE_RACE_STRINGS,
+		DRUUGE_ICON_MASK_PMAP_ANIM,
+		DRUUGE_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			0,0,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			DRUUGE_BIG_MASK_PMAP_ANIM,
+			DRUUGE_MED_MASK_PMAP_ANIM,
+			DRUUGE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DRUUGE_CANNON_BIG_MASK_PMAP_ANIM,
+			DRUUGE_CANNON_MED_MASK_PMAP_ANIM,
+			DRUUGE_CANNON_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			DRUUGE_CAPT_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		DRUUGE_VICTORY_SONG,
+		DRUUGE_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_RANGE_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+#define RECOIL_VELOCITY WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (6 << RESOLUTION_FACTOR)) // JMS_GFX
 #define MAX_RECOIL_VELOCITY (RECOIL_VELOCITY * 4)
 
 static void
@@ -127,8 +283,7 @@ cannon_collision (ELEMENT *ElementPtr0,
 		STARSHIP *StarShipPtr;
 
 		GetElementStarShip (ElementPtr1, &StarShipPtr);
-		StarShipPtr->cur_status_flags &=
-				~(SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED);
+		StarShipPtr->cur_status_flags &= ~(SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED);
 
 		angle = FACING_TO_ANGLE (
 				GetFrameIndex (ElementPtr0->next.image.frame)
@@ -153,8 +308,8 @@ cannon_collision (ELEMENT *ElementPtr0,
 static COUNT
 initialize_cannon (ELEMENT *ShipPtr, HELEMENT CannonArray[])
 {
-#define DRUUGE_OFFSET 24
-#define MISSILE_OFFSET 6
+#define DRUUGE_OFFSET (24 << RESOLUTION_FACTOR) // JMS_GFX
+#define MISSILE_OFFSET (6 << RESOLUTION_FACTOR) // JMS_GFX
 #define MISSILE_HITS 4
 #define MISSILE_DAMAGE 6
 	STARSHIP *StarShipPtr;
@@ -169,7 +324,7 @@ initialize_cannon (ELEMENT *ShipPtr, HEL
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = DRUUGE_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = (MISSILE_SPEED << RESOLUTION_FACTOR); // JMS_GFX
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -190,8 +345,7 @@ initialize_cannon (ELEMENT *ShipPtr, HEL
 }
 
 static void
-druuge_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
-		COUNT ConcernCounter)
+druuge_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern, COUNT ConcernCounter)
 {
 	UWORD ship_flags = 0;
 	STARSHIP *StarShipPtr;
@@ -204,7 +358,7 @@ druuge_intelligence (ELEMENT *ShipPtr, E
 	if (StarShipPtr->cur_status_flags & SHIP_BEYOND_MAX_SPEED)
 		lpEvalDesc->MoveState = ENTICE;
 	else if (lpEvalDesc->ObjectPtr
-			&& lpEvalDesc->which_turn <= WORLD_TO_TURN (MISSILE_RANGE * 3 / 4))
+			&& lpEvalDesc->which_turn <= (WORLD_TO_TURN ((MISSILE_RANGE << RESOLUTION_FACTOR) * 3 / 4)) >> RESOLUTION_FACTOR) // JMS_GFX
 	{
 		GetElementStarShip (lpEvalDesc->ObjectPtr, &EnemyStarShipPtr);
 		ship_flags = EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags;
@@ -309,12 +463,30 @@ init_druuge (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	druuge_desc.preprocess_func = druuge_preprocess;
-	druuge_desc.postprocess_func = druuge_postprocess;
-	druuge_desc.init_weapon_func = initialize_cannon;
-	druuge_desc.cyborg_control.intelligence_func = druuge_intelligence;
-
-	RaceDescPtr = &druuge_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		druuge_desc.preprocess_func = druuge_preprocess;
+		druuge_desc.postprocess_func = druuge_postprocess;
+		druuge_desc.init_weapon_func = initialize_cannon;
+		druuge_desc.cyborg_control.intelligence_func = druuge_intelligence;
+		RaceDescPtr = &druuge_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		druuge_desc_2xres.preprocess_func = druuge_preprocess;
+		druuge_desc_2xres.postprocess_func = druuge_postprocess;
+		druuge_desc_2xres.init_weapon_func = initialize_cannon;
+		druuge_desc_2xres.cyborg_control.intelligence_func = druuge_intelligence;
+		RaceDescPtr = &druuge_desc_2xres;
+	}
+	else
+	{
+		druuge_desc_4xres.preprocess_func = druuge_preprocess;
+		druuge_desc_4xres.postprocess_func = druuge_postprocess;
+		druuge_desc_4xres.init_weapon_func = initialize_cannon;
+		druuge_desc_4xres.cyborg_control.intelligence_func = druuge_intelligence;
+		RaceDescPtr = &druuge_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp src.orig/uqm/ships/druuge/icode.h src/uqm/ships/druuge/icode.h
--- src.orig/uqm/ships/druuge/icode.h	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/druuge/icode.h	2017-11-01 15:31:04 -0700
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define DRUUGE_CODE "ship.druuge.code"
diff -ruNp src.orig/uqm/ships/foonfoon/Makeinfo src/uqm/ships/foonfoon/Makeinfo
--- src.orig/uqm/ships/foonfoon/Makeinfo	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/foonfoon/Makeinfo	2017-11-01 15:31:04 -0700
@@ -0,0 +1 @@
+uqm_CFILES="foonfoon.c"
diff -ruNp src.orig/uqm/ships/foonfoon/foonfoon.c src/uqm/ships/foonfoon/foonfoon.c
--- src.orig/uqm/ships/foonfoon/foonfoon.c	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/foonfoon/foonfoon.c	2017-11-01 15:31:04 -0700
@@ -0,0 +1,1303 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "../ship.h" 
+#include "foonfoon.h"
+#include "resinst.h"
+
+#include "uqm/globdata.h"
+#include "libs/log.h"
+#include "libs/mathlib.h"
+#include "libs/sound/sound.h" // For StopSource
+#include <math.h> // For sqrt
+
+#define MAX_CREW 12
+#define MAX_ENERGY 32
+#define ENERGY_REGENERATION 1
+#define WEAPON_ENERGY_COST 3
+#define SPECIAL_ENERGY_COST 10
+#define ENERGY_WAIT 2
+#define MAX_THRUST 52
+#define THRUST_INCREMENT 12
+#define TURN_WAIT 1
+#define THRUST_WAIT 1
+#define WEAPON_WAIT 1
+#define SPECIAL_WAIT 0
+
+#define SHIP_MASS 2
+#define MISSILE_SPEED DISPLAY_TO_WORLD (27)
+#define MISSILE_LIFE 6
+#define MISSILE_RANGE (MISSILE_SPEED * MISSILE_LIFE)
+
+// Weapon gfx
+#define REVERSE_DIR (BYTE)(1 << 7)
+#define NUM_SHIP_FACINGS 16
+#define FOCUSBALL_OFFSET (7 << RESOLUTION_FACTOR)
+#define FOCUSBALL_FRAME_STARTINDEX 64
+#define NUM_FOCUSBALL_FRAMES 3
+#define NUM_BURST_FRAMES 4
+// Weapon attributes
+#define BURST_CHARGE_TIME 39 // Divide this by BATTLE_FRAME_RATE to get the time in seconds.
+#define NUM_SABERS 5
+#define DERVISH_DEGENERATION (-1)
+#define DERVISH_COOLDOWN_TIME 36 // Seconds *BATTLE_FRAME_RATE
+#define DERVISH_THRUST (80 << RESOLUTION_FACTOR) // JMS_GFX
+#define RECOIL_VELOCITY WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (6 << RESOLUTION_FACTOR)) // JMS_GFX
+#define MAX_RECOIL_VELOCITY (RECOIL_VELOCITY * 6)
+
+static RACE_DESC foonfoon_desc =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | IMMEDIATE_WEAPON,
+		18, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		FOONFOON_RACE_STRINGS,
+		FOONFOON_ICON_MASK_PMAP_ANIM,
+		FOONFOON_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST,
+		THRUST_INCREMENT,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			FOONFOON_BIG_MASK_PMAP_ANIM,
+			FOONFOON_MED_MASK_PMAP_ANIM,
+			FOONFOON_SML_MASK_PMAP_ANIM,
+		},
+		{
+			FOONFOON_BURST_BIG_MASK_PMAP_ANIM,
+			FOONFOON_BURST_MED_MASK_PMAP_ANIM,
+			FOONFOON_BURST_SML_MASK_PMAP_ANIM,
+		},
+		{
+			FOONFOON_SABRE_BIG_MASK_PMAP_ANIM,
+			FOONFOON_SABRE_MED_MASK_PMAP_ANIM,
+			FOONFOON_SABRE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			FOONFOON_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		FOONFOON_VICTORY_SONG,
+		FOONFOON_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_RANGE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_2XRES 104
+#define THRUST_INCREMENT_2XRES 24
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (54)
+#define MISSILE_RANGE_2XRES (MISSILE_SPEED_2XRES * MISSILE_LIFE)
+
+// JMS_GFX
+static RACE_DESC foonfoon_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | IMMEDIATE_WEAPON,
+		18, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		FOONFOON_RACE_STRINGS,
+		FOONFOON_ICON_MASK_PMAP_ANIM,
+		FOONFOON_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			FOONFOON_BIG_MASK_PMAP_ANIM,
+			FOONFOON_MED_MASK_PMAP_ANIM,
+			FOONFOON_SML_MASK_PMAP_ANIM,
+		},
+		{
+			FOONFOON_BURST_BIG_MASK_PMAP_ANIM,
+			FOONFOON_BURST_MED_MASK_PMAP_ANIM,
+			FOONFOON_BURST_SML_MASK_PMAP_ANIM,
+		},
+		{
+			FOONFOON_SABRE_BIG_MASK_PMAP_ANIM,
+			FOONFOON_SABRE_MED_MASK_PMAP_ANIM,
+			FOONFOON_SABRE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			FOONFOON_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		FOONFOON_VICTORY_SONG,
+		FOONFOON_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_RANGE_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 208
+#define THRUST_INCREMENT_4XRES 48
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (108)
+#define MISSILE_RANGE_4XRES (MISSILE_SPEED_4XRES * MISSILE_LIFE)
+
+// JMS_GFX
+static RACE_DESC foonfoon_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | IMMEDIATE_WEAPON,
+		18, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		FOONFOON_RACE_STRINGS,
+		FOONFOON_ICON_MASK_PMAP_ANIM,
+		FOONFOON_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			FOONFOON_BIG_MASK_PMAP_ANIM,
+			FOONFOON_MED_MASK_PMAP_ANIM,
+			FOONFOON_SML_MASK_PMAP_ANIM,
+		},
+		{
+			FOONFOON_BURST_BIG_MASK_PMAP_ANIM,
+			FOONFOON_BURST_MED_MASK_PMAP_ANIM,
+			FOONFOON_BURST_SML_MASK_PMAP_ANIM,
+		},
+		{
+			FOONFOON_SABRE_BIG_MASK_PMAP_ANIM,
+			FOONFOON_SABRE_MED_MASK_PMAP_ANIM,
+			FOONFOON_SABRE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			FOONFOON_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		FOONFOON_VICTORY_SONG,
+		FOONFOON_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_RANGE_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// Forward declarations.
+static COUNT
+initialize_test_burst (ELEMENT *ElementPtr, HELEMENT BurstArray[]);
+
+static COUNT
+initialize_test_saber (ELEMENT *ElementPtr, HELEMENT SabreArray[]);
+
+static COUNT 
+initialize_focusball (ELEMENT *ShipPtr, HELEMENT FocusArray[]);
+
+static COUNT
+initialize_focusball_which_bursts (ELEMENT *ShipPtr, HELEMENT BurstArray[]);
+
+static void
+focusball_postprocess (ELEMENT *ElementPtr);
+
+// The Almighty AI.
+static void
+foonfoon_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern, COUNT ConcernCounter)
+{
+#define IS_FOCUSBALL(ptr) (ptr->postprocess_func == focusball_postprocess && ptr->mass_points > 0)
+	BYTE old_count;
+	STARSHIP *StarShipPtr, *FBStarShipPtr;
+	EVALUATE_DESC *lpEvalDesc;
+	HELEMENT hElement, hNextElement;
+	ELEMENT  *FocusballCandidatePtr;
+	SIZE charge_amount = 0;
+	SIZE charge_time_left = 255;
+	BYTE enemy_is_Chmmr = 0;
+	
+	GetElementStarShip (ShipPtr, &StarShipPtr);
+	
+	// Find the focusball element (if one exists).
+	for (hElement = GetHeadElement (); hElement != 0; hElement = hNextElement)
+	{
+		LockElement (hElement, &FocusballCandidatePtr);
+		hNextElement = GetSuccElement (FocusballCandidatePtr);
+		
+		// Ensure this is not the enemy's focusball.
+		if (IS_FOCUSBALL(FocusballCandidatePtr))
+		{
+			GetElementStarShip (FocusballCandidatePtr, &FBStarShipPtr);
+			
+			// If this is this ship's focusball, see how charged the focusball is.
+			if (FBStarShipPtr == StarShipPtr)
+			{
+				charge_amount	 = FocusballCandidatePtr->mass_points;
+				charge_time_left = FocusballCandidatePtr->thrust_wait;
+				break;
+			}
+		}
+	}
+	
+	// Release the SPECIAL button when energy is drained.
+	if (StarShipPtr->RaceDescPtr->ship_info.energy_level == 0 || StarShipPtr->RaceDescPtr->ship_info.energy_level == MAX_ENERGY)
+		StarShipPtr->ship_input_state &= ~SPECIAL;
+	// Otherwise, when dervish has been started, keep dervishing until all energy is drained.
+	else if (StarShipPtr->ship_input_state & SPECIAL 
+			 && StarShipPtr->RaceDescPtr->ship_info.energy_level > 0)
+	{
+		StarShipPtr->ship_input_state &= ~WEAPON;
+		StarShipPtr->ship_input_state |= SPECIAL;
+		
+		lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
+		ship_intelligence (ShipPtr, ObjectsOfConcern, ConcernCounter);
+		goto end_intelligence;
+	}
+	
+	// We test the possibility of primary weapon hitting with a test function.
+	StarShipPtr->RaceDescPtr->init_weapon_func = initialize_test_burst;
+	old_count = StarShipPtr->weapon_counter;
+	
+	// This, like the lot of this code is copied from Melnorme AI.
+	// I don't know if the following has any real meaning, but since this works fine, let's keep it...
+	if (StarShipPtr->weapon_counter == WEAPON_WAIT)
+		StarShipPtr->weapon_counter = 0;
+	
+	// Action towards enemy ship: If we don't have weapon ready and don't have enough battery,
+	// escape until battery is charged. When we have enough battery, pursue the enemy!!
+	lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
+	if (lpEvalDesc->ObjectPtr)
+	{
+		STARSHIP *EnemyStarShipPtr;
+		GetElementStarShip (lpEvalDesc->ObjectPtr, &EnemyStarShipPtr);
+		
+		// Check if the enemy ship is Chmmr. We want to use the dervish more against it.
+		if(EnemyStarShipPtr->SpeciesID == CHMMR_ID)
+			enemy_is_Chmmr = 1;
+		else
+			enemy_is_Chmmr = 0;
+		
+		if (StarShipPtr->RaceDescPtr->ship_info.energy_level < SPECIAL_ENERGY_COST + WEAPON_ENERGY_COST
+			&& !(StarShipPtr->old_status_flags & WEAPON)
+			&& !enemy_is_Chmmr)
+			lpEvalDesc->MoveState = ENTICE;
+		else if (enemy_is_Chmmr && StarShipPtr->RaceDescPtr->ship_info.energy_level < SPECIAL_ENERGY_COST + WEAPON_ENERGY_COST)
+			lpEvalDesc->MoveState = ENTICE;
+		else
+			lpEvalDesc->MoveState = PURSUE;
+	}
+	ship_intelligence (ShipPtr, ObjectsOfConcern, ConcernCounter);
+	
+	// Charge focusball...
+	if (StarShipPtr->weapon_counter == 0
+		&& (old_count != 0
+			|| ((StarShipPtr->special_counter
+			|| StarShipPtr->RaceDescPtr->ship_info.energy_level >= MAX_ENERGY - 2 * WEAPON_ENERGY_COST)
+				&& !(StarShipPtr->ship_input_state & WEAPON))
+			)
+		)
+		StarShipPtr->ship_input_state ^= WEAPON;
+	
+	// ...but let it go just before it would start inducing damage to own ship.
+	if (charge_amount >= 4 && charge_time_left < 3)
+		StarShipPtr->ship_input_state &= ~WEAPON;
+	
+	// Consider dervishing if we don't have a heavily charged primary weapon handy and we have enough battery.
+	if (StarShipPtr->special_counter == 0
+		&& (enemy_is_Chmmr
+			|| (charge_amount < 2 && StarShipPtr->RaceDescPtr->ship_info.energy_level >= MAX_ENERGY - 4 * WEAPON_ENERGY_COST))
+		)
+	{
+		BYTE old_input_state;
+		old_input_state = StarShipPtr->ship_input_state;
+		
+		// The final decision of "to dervish or not to dervish" is made by evaluating a test weapon function,
+		// which is pretty similar to the primary weapon test function. This one only has different stats.
+		StarShipPtr->RaceDescPtr->init_weapon_func = initialize_test_saber;
+		ship_intelligence (ShipPtr, ObjectsOfConcern, ENEMY_SHIP_INDEX + 1);
+		
+		// Since we faked using primary weapon even though we really are gonna use special,
+		// change the WEAPON button press to SPECIAL.
+		if (StarShipPtr->ship_input_state & WEAPON)
+		{
+			BYTE right_or_left;
+			right_or_left = TFB_Random () % 2;
+			
+			StarShipPtr->ship_input_state &= ~WEAPON;
+			StarShipPtr->ship_input_state |= SPECIAL;
+			
+			// Also turn the ship to either direction, otherwise the dervish won't activate.
+			if (right_or_left)
+				StarShipPtr->ship_input_state |= RIGHT;
+			else
+				StarShipPtr->ship_input_state |= LEFT;
+		}
+		
+		StarShipPtr->ship_input_state = (unsigned char)(old_input_state | (StarShipPtr->ship_input_state & SPECIAL));
+	}
+	
+	// Check if the enemy weapon is a zapsat. We want to use the dervish more against it.
+	lpEvalDesc = &ObjectsOfConcern[ENEMY_WEAPON_INDEX];
+	if (lpEvalDesc->ObjectPtr)
+	{
+		STARSHIP *EnemyStarShipPtr;
+		GetElementStarShip (lpEvalDesc->ObjectPtr, &EnemyStarShipPtr);
+		
+		if(EnemyStarShipPtr->SpeciesID == CHMMR_ID 
+		   && lpEvalDesc->ObjectPtr->mass_points == 10
+		   && StarShipPtr->special_counter == 0
+		   && StarShipPtr->RaceDescPtr->ship_info.energy_level >= MAX_ENERGY / 2)
+		{
+			BYTE old_input_state;
+			old_input_state = StarShipPtr->ship_input_state;
+			
+			// The final decision of "to dervish or not to dervish" is made by evaluating a test weapon function,
+			// which is pretty similar to the primary weapon test function. This one only has different stats.
+			StarShipPtr->RaceDescPtr->init_weapon_func = initialize_test_saber;
+			ship_intelligence (ShipPtr, ObjectsOfConcern, ENEMY_SHIP_INDEX + 1);
+			
+			// Since we faked using primary weapon even though we really are gonna use special,
+			// change the WEAPON button press to SPECIAL.
+			if (StarShipPtr->ship_input_state & WEAPON)
+			{
+				BYTE right_or_left;
+				right_or_left = TFB_Random () % 2;
+				
+				StarShipPtr->ship_input_state &= ~WEAPON;
+				StarShipPtr->ship_input_state |= SPECIAL;
+				
+				// Also turn the ship to either direction, otherwise the dervish won't activate.
+				if (right_or_left)
+					StarShipPtr->ship_input_state |= RIGHT;
+				else
+					StarShipPtr->ship_input_state |= LEFT;
+			}
+			
+			StarShipPtr->ship_input_state = (unsigned char)(old_input_state | (StarShipPtr->ship_input_state & SPECIAL));
+		}
+	}
+	
+	StarShipPtr->weapon_counter = old_count;
+	
+end_intelligence:
+	StarShipPtr->RaceDescPtr->init_weapon_func = initialize_focusball_which_bursts;
+}
+
+// This animates the primary burst.
+static void
+animate_burst (ELEMENT *ElementPtr)
+{
+	STARSHIP *StarShipPtr;
+	
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+	
+	if ((GetFrameIndex (ElementPtr->next.image.frame) > 1) && !((GetFrameIndex (ElementPtr->next.image.frame) + 1) % NUM_BURST_FRAMES))
+		ElementPtr->next.image.frame = DecFrameIndex (ElementPtr->current.image.frame);
+	else
+		ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->current.image.frame);
+	
+	ElementPtr->state_flags |= CHANGING;
+}
+
+// This turns the focusball into a primary burst.
+static void
+fire_burst (ELEMENT *ElementPtr)
+{
+	STARSHIP *StarShipPtr;
+	MISSILE_BLOCK MissileBlock;
+	HELEMENT hMissile;
+	ELEMENT *ShipPtr;
+	
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+	LockElement (StarShipPtr->hShip, &ShipPtr);
+	
+	MissileBlock.cx = ElementPtr->next.location.x;
+	MissileBlock.cy = ElementPtr->next.location.y;
+	MissileBlock.farray = StarShipPtr->RaceDescPtr->ship_data.weapon;
+	MissileBlock.face = StarShipPtr->ShipFacing;
+	MissileBlock.index = (StarShipPtr->ShipFacing) * NUM_BURST_FRAMES;
+	MissileBlock.sender = ElementPtr->playerNr;
+	MissileBlock.flags =  IGNORE_SIMILAR;
+	MissileBlock.pixoffs = FOCUSBALL_OFFSET;
+	MissileBlock.speed = (MISSILE_SPEED << RESOLUTION_FACTOR);
+	MissileBlock.hit_points = ElementPtr->mass_points;
+	MissileBlock.damage = ElementPtr->mass_points;
+	MissileBlock.life = MISSILE_LIFE;
+	MissileBlock.preprocess_func = animate_burst;
+	MissileBlock.blast_offs = 50 << RESOLUTION_FACTOR; // Don't change this value. Otherwise a special clause in weapon.c will stop working :(
+	
+	hMissile = initialize_missile (&MissileBlock);
+	
+	if (hMissile)
+	{
+		ELEMENT *BurstPtr;
+		SIZE dx, dy;
+		
+		LockElement (hMissile, &BurstPtr);
+		SetElementStarShip (BurstPtr, StarShipPtr);
+		GetCurrentVelocityComponents (&ShipPtr->velocity, &dx, &dy);
+		DeltaVelocityComponents (&BurstPtr->velocity, dx, dy);
+		BurstPtr->current.location.x -= VELOCITY_TO_WORLD (dx);
+		BurstPtr->current.location.y -= VELOCITY_TO_WORLD (dy);
+		UnlockElement (hMissile);
+		PutElement (hMissile);
+
+		// Play different 'shot release' sound according to how powerful the shot is.
+		if (ElementPtr->mass_points >= 7)
+			ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 10), ElementPtr);
+		else if (ElementPtr->mass_points == 4)
+			ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 9), ElementPtr);
+		else if (ElementPtr->mass_points == 2)
+			ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 8), ElementPtr);
+		else
+			ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 7), ElementPtr);
+	}
+
+	// Recoil the ship with powerful enough shots.
+	if (ElementPtr->mass_points >= 4)
+	{
+		COUNT angle;
+		SIZE cur_delta_x, cur_delta_y;
+		BYTE mult;
+		
+		// More powerful shots knock the ship back more.
+		if (ElementPtr->mass_points >= 7)
+		{
+			mult = 2;
+		}
+		else
+			mult = 1;
+		
+		StarShipPtr->cur_status_flags &= ~SHIP_AT_MAX_SPEED;
+		angle = FACING_TO_ANGLE (StarShipPtr->ShipFacing) + HALF_CIRCLE;
+		
+		DeltaVelocityComponents (&ShipPtr->velocity,
+								 COSINE (angle, RECOIL_VELOCITY * mult),
+								 SINE (angle, RECOIL_VELOCITY * mult));
+		GetCurrentVelocityComponents (&ShipPtr->velocity, &cur_delta_x, &cur_delta_y);
+		
+		if ((long)cur_delta_x * (long)cur_delta_x
+			+ (long)cur_delta_y * (long)cur_delta_y
+			> (long)MAX_RECOIL_VELOCITY * (long)MAX_RECOIL_VELOCITY)
+		{
+			angle = ARCTAN (cur_delta_x, cur_delta_y);
+			SetVelocityComponents (&ShipPtr->velocity,
+								   COSINE (angle, MAX_RECOIL_VELOCITY),
+								   SINE (angle, MAX_RECOIL_VELOCITY));
+		}
+		
+		UnlockElement (StarShipPtr->hShip);
+	}
+}
+
+// This function plays the primary weapon charge-up sound.
+static void
+focusball_preprocess (ELEMENT *ElementPtr)
+{
+	if (ElementPtr->thrust_wait == 1 && ElementPtr->mass_points < 7)
+	{
+		BYTE chargesound, i;
+		ELEMENT *ShipPtr;
+		STARSHIP *StarShipPtr;
+		
+		GetElementStarShip (ElementPtr, &StarShipPtr);
+		LockElement (StarShipPtr->hShip, &ShipPtr);
+		
+		// End the old charge-up sound.
+		for (i = FIRST_SFX_CHANNEL; i <= LAST_SFX_CHANNEL; ++i)
+		{
+			ELEMENT *posobj;
+			if (!ChannelPlaying(i))
+				continue;
+			
+			posobj = GetPositionalObject (i);
+			if (posobj == ShipPtr)
+				StopSource (i);
+		}
+		
+		// Start playing the new charge-up sound.
+		chargesound = 3 + (BYTE)(log(ElementPtr->mass_points * 2) / log(2));
+		ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, chargesound), ShipPtr);
+		
+		UnlockElement (StarShipPtr->hShip);
+	}	
+}
+
+// This function handles the life and death of a focusball.
+static void
+focusball_postprocess (ELEMENT *ElementPtr)
+{
+	if (ElementPtr->state_flags & APPEARING)
+		ZeroVelocityComponents (&ElementPtr->velocity);
+	else
+	{
+		HELEMENT hFocusBall;
+		ELEMENT *EPtr;
+		ELEMENT *ShipPtr;
+		STARSHIP *StarShipPtr;
+		COUNT frame_index;
+		static BYTE shake[NUM_SIDES] = {0};
+		
+		// The original focusball actually dies in the end of this function.
+		// But here we create a new one to replace it so no one notices.
+		GetElementStarShip (ElementPtr, &StarShipPtr);
+		LockElement (StarShipPtr->hShip, &ShipPtr);
+		initialize_focusball (ShipPtr, &hFocusBall);
+		
+		// When holding WEAPON button down, don't drain energy.
+		if (StarShipPtr->cur_status_flags & WEAPON)
+		{
+			DeltaEnergy (ShipPtr, 0);
+			StarShipPtr->weapon_counter = WEAPON_WAIT;
+		}
+		// Ensure the focusball doesn't reach ship-damaging charge when holding the SPECIAL button down.
+		else if (StarShipPtr->cur_status_flags & SPECIAL)
+		{
+			ElementPtr->mass_points = 0;
+			ElementPtr->thrust_wait = 255;
+		}
+			
+		// Copy the old focusball's values to the new focusball element.
+		LockElement (hFocusBall, &EPtr);
+		SetElementStarShip (EPtr, StarShipPtr);
+		EPtr->thrust_wait = ElementPtr->thrust_wait;
+		EPtr->mass_points = ElementPtr->mass_points;
+		EPtr->turn_wait = ElementPtr->turn_wait;
+		EPtr->current.image.frame = ElementPtr->current.image.frame;
+		
+		// Animate the focusball ping-pong between frames 0...2.
+		frame_index = GetFrameIndex (EPtr->current.image.frame) - FOCUSBALL_FRAME_STARTINDEX;
+		if	(((EPtr->turn_wait & REVERSE_DIR) && (frame_index % NUM_FOCUSBALL_FRAMES) != 0)
+			||  (!(EPtr->turn_wait & REVERSE_DIR) && ((frame_index + 1) % NUM_FOCUSBALL_FRAMES) == 0))
+		{
+			--frame_index;
+			EPtr->turn_wait |= REVERSE_DIR;
+		}
+		else
+		{
+			++frame_index;
+			EPtr->turn_wait &= ~REVERSE_DIR;
+		}
+		EPtr->current.image.frame = SetAbsFrameIndex (EPtr->current.image.frame, FOCUSBALL_FRAME_STARTINDEX + frame_index);
+		
+		// When player releases WEAPON or SPECIAL key, kill the focusball.
+		if (!(StarShipPtr->cur_status_flags & StarShipPtr->old_status_flags & WEAPON)
+			&& !(StarShipPtr->cur_status_flags & StarShipPtr->old_status_flags & SPECIAL))
+		{
+			BYTE i;
+			
+			EPtr->life_span = 1;
+			EPtr->preprocess_func = 0;
+			if (ElementPtr->mass_points)
+				EPtr->death_func = fire_burst;
+			
+			// End the charge-up sound.
+			if (ShipPtr->crew_level > 0)
+			{
+				for (i = FIRST_SFX_CHANNEL; i <= LAST_SFX_CHANNEL; ++i)
+				{
+					ELEMENT *posobj;
+					if (!ChannelPlaying(i))
+						continue;
+				
+					posobj = GetPositionalObject (i);
+					if (posobj == ShipPtr)
+						StopSource (i);
+				}
+			}
+			
+			if (EPtr->mass_points >= 7)
+			{
+				// Also suffer some damage if the shot is big enough!
+				if (!DeltaCrew (ShipPtr, -2))
+					ShipPtr->life_span = 0;
+				ShipPtr->state_flags |= CHANGING;
+				ProcessSound (SetAbsSoundIndex (GameSounds, 4), ShipPtr);
+			}
+				
+			// Return the ship to normal graphics if the ship was pulsating.
+			if ((GetFrameIndex (ShipPtr->current.image.frame)) >= NUM_SHIP_FACINGS)
+			{
+				ShipPtr->next.image.frame = SetAbsFrameIndex (ShipPtr->next.image.frame, StarShipPtr->ShipFacing);
+				ShipPtr->state_flags |= CHANGING;
+			}
+		}
+		
+		// Charge the primary weapon when holding down the WEAPON key.
+		// The more charged up the primary, the more it deals damage.
+		if (EPtr->thrust_wait == 0)
+		{
+			EPtr->mass_points <<= 1;
+			EPtr->thrust_wait = BURST_CHARGE_TIME;
+			
+			// Nerf the most powerful shot's strength. Also give some 'mercy time' to avoid exploding your own ship too easily.
+			if (EPtr->mass_points == 8)
+			{
+				EPtr->mass_points = 7;
+				EPtr->thrust_wait += (BURST_CHARGE_TIME / 3);
+			}
+		}
+		else
+			--EPtr->thrust_wait;
+		
+		// At dangerously large charge levels, the ship starts pulsating.
+		if (EPtr->mass_points == 4)
+		{
+			// Alternate between normal and blurred graphics.
+			if ((GetFrameIndex (ShipPtr->current.image.frame)) < NUM_SHIP_FACINGS && EPtr->life_span > 1)
+				ShipPtr->next.image.frame = SetAbsFrameIndex (ShipPtr->next.image.frame, StarShipPtr->ShipFacing + NUM_SHIP_FACINGS);
+			else
+				ShipPtr->next.image.frame = SetAbsFrameIndex (ShipPtr->next.image.frame, StarShipPtr->ShipFacing);
+		}
+		else if (EPtr->mass_points >= 7)
+		{
+			shake[ShipPtr->playerNr] = ((shake[ShipPtr->playerNr] + (BYTE)TFB_Random()) % 4) - 1;
+			if (shake[ShipPtr->playerNr] > 1)
+				shake[ShipPtr->playerNr] = 0;
+			
+			// Alternate between normal and blurred graphics.
+			if ((GetFrameIndex (ShipPtr->current.image.frame)) < NUM_SHIP_FACINGS && EPtr->life_span > 1)
+				ShipPtr->next.image.frame = SetAbsFrameIndex (ShipPtr->next.image.frame, 
+					(StarShipPtr->ShipFacing + shake[ShipPtr->playerNr]) + NUM_SHIP_FACINGS);
+			else
+				ShipPtr->next.image.frame = SetAbsFrameIndex (ShipPtr->next.image.frame, StarShipPtr->ShipFacing);
+		}
+		
+		// If the player charges the primary too much, the whole ship explodes!!!
+		if (EPtr->mass_points >= 10)
+		{
+			EPtr->mass_points = 7;
+			
+			if (!DeltaCrew (ShipPtr, -MAX_CREW))
+				ShipPtr->life_span = 0;
+			ShipPtr->state_flags |= CHANGING;
+		}
+		
+		UnlockElement (StarShipPtr->hShip);
+			
+		// Put the focusball to the queue of elements.
+		UnlockElement (hFocusBall);
+		PutElement (hFocusBall);
+		
+		SetPrimType (&(GLOBAL (DisplayArray))[ElementPtr->PrimIndex],  NO_PRIM);
+		ElementPtr->state_flags |= NONSOLID;
+	}
+}
+
+// This is the collision function for both the secondary saber.
+static void
+saber_collision (ELEMENT *ElementPtr0, POINT *pPt0, ELEMENT *ElementPtr1, POINT *pPt1)
+{
+	HELEMENT hBlastElement;
+	STARSHIP *StarShipPtr;	
+
+	GetElementStarShip (ElementPtr0, &StarShipPtr);
+	StarShipPtr->weapon_counter = 0;
+	
+	hBlastElement = weapon_collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
+	if (hBlastElement)
+	{
+		RemoveElement (hBlastElement);
+		FreeElement (hBlastElement);
+		
+		ElementPtr0->state_flags &= ~DISAPPEARING;
+	}
+}
+
+// This is used by AI for testing would the primary weapon hit if shot.
+static COUNT
+initialize_test_burst (ELEMENT *ElementPtr, HELEMENT BurstArray[])
+{
+	STARSHIP *StarShipPtr;
+	MISSILE_BLOCK MissileBlock;
+	
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+	
+	MissileBlock.cx = ElementPtr->next.location.x;
+	MissileBlock.cy = ElementPtr->next.location.y;
+	MissileBlock.farray = StarShipPtr->RaceDescPtr->ship_data.weapon;
+	MissileBlock.face = StarShipPtr->ShipFacing;
+	MissileBlock.index = (StarShipPtr->ShipFacing) * NUM_BURST_FRAMES;
+	MissileBlock.sender = ElementPtr->playerNr;
+	MissileBlock.flags =  IGNORE_SIMILAR;
+	MissileBlock.pixoffs = FOCUSBALL_OFFSET;
+	MissileBlock.speed = (MISSILE_SPEED << RESOLUTION_FACTOR);
+	MissileBlock.hit_points = ElementPtr->mass_points;
+	MissileBlock.damage = ElementPtr->mass_points;
+	MissileBlock.life = NUM_BURST_FRAMES;
+	MissileBlock.preprocess_func = animate_burst;
+	MissileBlock.blast_offs = 50 << RESOLUTION_FACTOR;
+	BurstArray[0] = initialize_missile (&MissileBlock);
+	
+	return (1);
+}
+
+// This is used by AI for testing would it hit the enemy ship with dervish mode.
+static COUNT
+initialize_test_saber (ELEMENT *ElementPtr, HELEMENT SaberArray[])
+{
+	STARSHIP *StarShipPtr;
+	MISSILE_BLOCK MissileBlock;
+	
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+	
+	MissileBlock.cx = ElementPtr->next.location.x;
+	MissileBlock.cy = ElementPtr->next.location.y;
+	MissileBlock.farray = StarShipPtr->RaceDescPtr->ship_data.weapon;
+	MissileBlock.face = StarShipPtr->ShipFacing;
+	MissileBlock.index = (StarShipPtr->ShipFacing) * NUM_BURST_FRAMES;
+	MissileBlock.sender = ElementPtr->playerNr;
+	MissileBlock.flags =  IGNORE_SIMILAR;
+	MissileBlock.pixoffs = FOCUSBALL_OFFSET;
+	MissileBlock.speed = DERVISH_THRUST;
+	MissileBlock.hit_points = ElementPtr->mass_points;
+	MissileBlock.damage = ElementPtr->mass_points;
+	MissileBlock.life = 10;
+	MissileBlock.preprocess_func = animate_burst;
+	MissileBlock.blast_offs = 25 << RESOLUTION_FACTOR;
+	SaberArray[0] = initialize_missile (&MissileBlock);
+	
+	return (1);
+}
+
+// This generates a focus ball.
+static COUNT
+initialize_focusball (ELEMENT *ShipPtr, HELEMENT FocusArray[])
+{
+	STARSHIP *StarShipPtr;
+	MISSILE_BLOCK MissileBlock;
+	
+	GetElementStarShip (ShipPtr, &StarShipPtr);
+	
+	MissileBlock.cx = ShipPtr->next.location.x;
+	MissileBlock.cy = ShipPtr->next.location.y;
+	MissileBlock.farray = StarShipPtr->RaceDescPtr->ship_data.weapon;
+	MissileBlock.face = StarShipPtr->ShipFacing;
+	MissileBlock.index = FOCUSBALL_FRAME_STARTINDEX;
+	MissileBlock.sender = ShipPtr->playerNr;
+	MissileBlock.flags =  NONSOLID | IGNORE_SIMILAR;
+	MissileBlock.pixoffs = FOCUSBALL_OFFSET;
+	MissileBlock.speed = DISPLAY_TO_WORLD (FOCUSBALL_OFFSET);
+	MissileBlock.hit_points = 1;
+	MissileBlock.damage = 0;
+	MissileBlock.life = 2;
+	MissileBlock.preprocess_func = focusball_preprocess;
+	MissileBlock.blast_offs = 0;
+	FocusArray[0] = initialize_missile (&MissileBlock);
+	
+	if (FocusArray[0])
+	{
+		ELEMENT *FocusPtr;
+		
+		LockElement (FocusArray[0], &FocusPtr);
+		FocusPtr->postprocess_func = focusball_postprocess;
+		FocusPtr->thrust_wait = 255; // Let's ensure the secondary sabre's focusball doesn't grow it's damage amount.
+		UnlockElement (FocusArray[0]);
+	}
+	
+	return (1);
+}
+
+// Primary weapon: This generates a focusball which turns into beam burst when the weapon button is released.
+static COUNT
+initialize_focusball_which_bursts (ELEMENT *ShipPtr, HELEMENT BurstArray[])
+{
+	STARSHIP *StarShipPtr;
+	MISSILE_BLOCK MissileBlock;
+
+	GetElementStarShip (ShipPtr, &StarShipPtr);
+	MissileBlock.cx = ShipPtr->next.location.x;
+	MissileBlock.cy = ShipPtr->next.location.y;
+	MissileBlock.farray = StarShipPtr->RaceDescPtr->ship_data.weapon;
+	MissileBlock.face = StarShipPtr->ShipFacing;
+	MissileBlock.index = FOCUSBALL_FRAME_STARTINDEX;
+	MissileBlock.sender = ShipPtr->playerNr;
+	MissileBlock.flags =  NONSOLID | IGNORE_SIMILAR;
+	MissileBlock.pixoffs = FOCUSBALL_OFFSET;
+	MissileBlock.speed = DISPLAY_TO_WORLD (FOCUSBALL_OFFSET);
+	MissileBlock.hit_points = 100;
+	MissileBlock.damage = 1;
+	MissileBlock.life = 2;
+	MissileBlock.preprocess_func = focusball_preprocess;
+	MissileBlock.blast_offs = 0;
+	
+	if (!(StarShipPtr->old_status_flags & WEAPON))
+	{
+		BurstArray[0] = initialize_missile (&MissileBlock);
+	
+		if (BurstArray[0])
+		{
+			ELEMENT *FocusPtr;
+		
+			LockElement (BurstArray[0], &FocusPtr);
+			FocusPtr->postprocess_func = focusball_postprocess;
+			FocusPtr->thrust_wait = BURST_CHARGE_TIME;
+			UnlockElement (BurstArray[0]);
+		}
+	
+		return (1);
+	}
+	else
+	{
+		DeltaEnergy (ShipPtr, 0);
+		return (0);
+	}
+}
+
+// Secondary weapon: This generates the wide saber.
+static COUNT
+initialize_saber (ELEMENT *ShipPtr, HELEMENT SaberArray[], COUNT facingfix)
+{
+	STARSHIP *StarShipPtr;
+	MISSILE_BLOCK MissileBlock;
+	COUNT facing; 
+	
+	GetElementStarShip (ShipPtr, &StarShipPtr);
+	facing = (StarShipPtr->ShipFacing + NUM_SABERS - 1 - facingfix) % NUM_SHIP_FACINGS;
+	
+	MissileBlock.cx = ShipPtr->next.location.x;
+	MissileBlock.cy = ShipPtr->next.location.y;
+	MissileBlock.farray  = StarShipPtr->RaceDescPtr->ship_data.special;
+	MissileBlock.index   = MissileBlock.face = facing;
+	MissileBlock.sender  = ShipPtr->playerNr;
+	MissileBlock.flags   = IGNORE_SIMILAR;
+	MissileBlock.pixoffs = FOCUSBALL_OFFSET;
+	MissileBlock.speed   = DERVISH_THRUST;
+	MissileBlock.damage  = 1;
+	MissileBlock.life    = 1;
+	MissileBlock.hit_points = 100;
+	MissileBlock.preprocess_func = 0;
+	MissileBlock.blast_offs      = 0;
+			
+	if ((SaberArray[0] = initialize_missile (&MissileBlock)))
+	{
+		ELEMENT *SaberPtr;
+		
+		LockElement (SaberArray[0], &SaberPtr);
+		SetElementStarShip (SaberPtr, StarShipPtr);
+		SaberPtr->collision_func = saber_collision;
+		InitIntersectStartPoint (SaberPtr);
+		InitIntersectEndPoint (SaberPtr);
+		SaberPtr->IntersectControl.IntersectStamp.frame = StarShipPtr->RaceDescPtr->ship_data.special[facing];
+		UnlockElement (SaberArray[0]);
+	}
+	
+	return (1);
+}
+
+static void
+foonfoon_postprocess (ELEMENT *ElementPtr)
+{
+	RACE_DESC *RDPtr;
+	STARSHIP *StarShipPtr;
+	STATUS_FLAGS cur_status_flags;
+	BYTE frame_index, i;
+	static BYTE not_had_pause[NUM_SIDES]	= {0};
+	static BYTE focusball_exists[NUM_SIDES]	= {0};
+	
+	// For keeping the VUX limpet effects after spinning blade.
+	static BYTE basic_max_thrust[3 * NUM_SIDES] = {MAX_THRUST, MAX_THRUST, MAX_THRUST_2XRES, MAX_THRUST_2XRES, MAX_THRUST_4XRES, MAX_THRUST_4XRES};
+	static BYTE basic_thrust_wait[NUM_SIDES]= {THRUST_WAIT, THRUST_WAIT};
+	static BYTE basic_turn_wait[NUM_SIDES]	= {TURN_WAIT, TURN_WAIT};
+	
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+	RDPtr = StarShipPtr->RaceDescPtr;
+	
+	cur_status_flags = StarShipPtr->cur_status_flags;
+	
+	frame_index = GetFrameIndex (ElementPtr->current.image.frame);
+	
+	// Store the original turning rate & max speed if not in dervish mode, or the slow state after dervish.
+	if (StarShipPtr->special_counter == 0 
+		&& RDPtr->characteristics.turn_wait > 0
+		&& (frame_index < NUM_SHIP_FACINGS && !(StarShipPtr->cur_status_flags & WEAPON)) // Weapon check because the primary weapon also can set the ship graphics
+		&& !(StarShipPtr->RaceDescPtr->ship_info.damage_flags & DAMAGE_THRUST))
+	{
+		basic_max_thrust[2 * RESOLUTION_FACTOR + ElementPtr->playerNr]  = RDPtr->characteristics.max_thrust;
+		basic_thrust_wait[ElementPtr->playerNr] = RDPtr->characteristics.thrust_wait;
+		basic_turn_wait[ElementPtr->playerNr]	= RDPtr->characteristics.turn_wait;
+	}
+	
+	// After using special: Thrust is sloooow for a while.
+	if (StarShipPtr->special_counter > 0)
+	{
+		// Slooooow.
+		if ((MAX_THRUST << RESOLUTION_FACTOR) / 4 < basic_max_thrust[2 * RESOLUTION_FACTOR + ElementPtr->playerNr])
+			RDPtr->characteristics.max_thrust = (MAX_THRUST << RESOLUTION_FACTOR) / 4;
+		else
+			RDPtr->characteristics.max_thrust = basic_max_thrust[2 * RESOLUTION_FACTOR + ElementPtr->playerNr];
+		
+		if (basic_thrust_wait[ElementPtr->playerNr] > 3)
+			RDPtr->characteristics.thrust_wait	= basic_thrust_wait[ElementPtr->playerNr];
+		else
+			RDPtr->characteristics.thrust_wait	= 3;
+
+		// Blue ion trail tells the player when dervish mode is unusable.
+		StarShipPtr->RaceDescPtr->ship_info.damage_flags |= DAMAGE_THRUST;
+		
+		// Turning just returns to normal.
+		RDPtr->characteristics.turn_wait = basic_turn_wait[ElementPtr->playerNr];
+		
+		// Battery charges normally when not in dervish mode.
+		RDPtr->characteristics.energy_regeneration = ENERGY_REGENERATION;
+		ElementPtr->state_flags |= CHANGING;
+	}
+	
+	// Special: The dervish mode.
+	else if (StarShipPtr->cur_status_flags & SPECIAL
+			 && RDPtr->ship_info.energy_level > 0
+			 && frame_index >= NUM_SHIP_FACINGS
+			 && !not_had_pause[ElementPtr->playerNr])
+	{
+		// Add sabre elements.
+		// The more sabres there are, the wider it is (and the more damage it deals).
+		for (i = 0; i < NUM_SABERS; i++)
+		{
+			HELEMENT Saber;
+			
+			initialize_saber (ElementPtr, &Saber, i);
+			if (Saber)
+			{
+				ELEMENT *SMissilePtr;
+				LockElement (Saber, &SMissilePtr);
+			
+				UnlockElement (Saber);
+				PutElement (Saber);
+			}
+		}
+		
+		// Add a nice little focusball.
+		if (!focusball_exists[ElementPtr->playerNr])
+		{
+			HELEMENT Focusball;
+			
+			initialize_focusball (ElementPtr, &Focusball);
+			if (Focusball)
+			{
+				ELEMENT *FBMissilePtr;
+				LockElement (Focusball, &FBMissilePtr);
+				
+				SetElementStarShip (FBMissilePtr, StarShipPtr);
+				FBMissilePtr->mass_points = 0;
+				
+				UnlockElement (Focusball);
+				PutElement (Focusball);
+			}
+			
+			// Don't create multiple focusballs. This makes 
+			// a) the game run better, b) focusball animation visible. 
+			focusball_exists[ElementPtr->playerNr] = 1;
+		}
+		
+		// Turning rate & max speed increase.
+		RDPtr->characteristics.thrust_wait = 0;
+		RDPtr->characteristics.turn_wait   = 0;
+		RDPtr->characteristics.max_thrust  = DERVISH_THRUST;
+		StarShipPtr->RaceDescPtr->ship_info.damage_flags &= ~(DAMAGE_THRUST);
+		
+		// Battery slowly drops.
+		RDPtr->characteristics.energy_regeneration = (BYTE)DERVISH_DEGENERATION;
+		ElementPtr->state_flags |= CHANGING;
+	}
+	// Not using special.
+	else
+	{
+		// When dervish ends...
+		if ((StarShipPtr->old_status_flags & SPECIAL || RDPtr->ship_info.energy_level == 0)
+			&& frame_index >= NUM_SHIP_FACINGS)
+		{
+			COUNT i;
+			
+			// Set a cooldown period before next dervish.
+			StarShipPtr->special_counter = DERVISH_COOLDOWN_TIME;
+			
+			// Using dervish always drains the battery totally.
+			DeltaEnergy (ElementPtr, -StarShipPtr->RaceDescPtr->ship_info.energy_level);
+			
+			// Slow down.
+			SetVelocityVector (&ElementPtr->velocity, ((MAX_THRUST << RESOLUTION_FACTOR) / 4), NORMALIZE_FACING (StarShipPtr->ShipFacing));
+			
+			// We're not past max speed any more.
+			cur_status_flags &= ~(SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED);
+			
+			// Return to normal graphics.
+			if ((GetFrameIndex (ElementPtr->current.image.frame)) >= NUM_SHIP_FACINGS)
+				ElementPtr->next.image.frame = SetAbsFrameIndex (ElementPtr->next.image.frame, StarShipPtr->ShipFacing);
+			
+			// End the spinning blade sound.
+			for (i = FIRST_SFX_CHANNEL; i <= LAST_SFX_CHANNEL; ++i)
+			{
+				ELEMENT *posobj;
+				if (!ChannelPlaying(i))
+					continue;
+				
+				posobj = GetPositionalObject (i);
+				if (posobj == ElementPtr)
+					StopSource (i);
+			}
+			
+			// Play the ending sound.
+			ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 1), ElementPtr);			
+			
+			// The focusball dies with the dervish mode.
+			focusball_exists[ElementPtr->playerNr] = 0;
+			
+			// Prevent spamming the special key.
+			cur_status_flags &= ~(SPECIAL);
+			StarShipPtr->cur_status_flags = cur_status_flags;
+			not_had_pause[ElementPtr->playerNr] = 1;
+		}
+		
+		// Turning rate & max speed are normal when not in dervish mode.
+		RDPtr->characteristics.max_thrust	= basic_max_thrust[2 * RESOLUTION_FACTOR + ElementPtr->playerNr];
+		RDPtr->characteristics.thrust_wait	= basic_thrust_wait[ElementPtr->playerNr];
+		RDPtr->characteristics.turn_wait	= basic_turn_wait[ElementPtr->playerNr];
+		StarShipPtr->RaceDescPtr->ship_info.damage_flags &= ~(DAMAGE_THRUST);
+		
+		// Battery charges normally when not in dervish mode.
+		RDPtr->characteristics.energy_regeneration = ENERGY_REGENERATION;
+		ElementPtr->state_flags |= CHANGING;
+	}
+	
+	// The player must let go of the special key between dervishes.
+	// This requirement eliminates all sorts of bugs.
+	if (!(StarShipPtr->old_status_flags & SPECIAL) 
+		&& !(StarShipPtr->cur_status_flags & SPECIAL)
+		&& StarShipPtr->RaceDescPtr->ship_info.energy_level > SPECIAL_ENERGY_COST)
+		not_had_pause[ElementPtr->playerNr] = 0;
+}
+
+static void
+foonfoon_preprocess (ELEMENT *ElementPtr)
+{
+	STARSHIP *StarShipPtr;
+	STATUS_FLAGS cur_status_flags;
+	BYTE frame_index;
+	static BYTE not_had_pause[NUM_SIDES] = {0};
+	static BYTE turn_direction[NUM_SIDES] = {0};
+	
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+	cur_status_flags = StarShipPtr->cur_status_flags;
+	
+	frame_index = GetFrameIndex (ElementPtr->current.image.frame);
+	
+	if (StarShipPtr->cur_status_flags & SPECIAL
+		&& !not_had_pause[ElementPtr->playerNr])
+	{
+		// Can't use primary weapon and special simultaneously.
+		cur_status_flags &= ~(WEAPON);
+		
+		// Not enough juice for dervish mode.
+		if ((StarShipPtr->RaceDescPtr->ship_info.energy_level < SPECIAL_ENERGY_COST && !(StarShipPtr->old_status_flags & SPECIAL))
+			|| StarShipPtr->RaceDescPtr->ship_info.energy_level == 0)
+		{
+			// Flash the 'batt' text.
+			DeltaEnergy (ElementPtr, -SPECIAL_ENERGY_COST);
+			
+			// Prevent spamming the special key.
+			cur_status_flags &= ~(SPECIAL);
+			StarShipPtr->old_status_flags &= ~(SPECIAL);
+			not_had_pause[ElementPtr->playerNr] = 1;
+			turn_direction[ElementPtr->playerNr] = 0;
+		}
+		else if (!not_had_pause[ElementPtr->playerNr])
+		{
+			COUNT facing;
+			SIZE  speedx, speedy;
+			SDWORD totalspeed;
+			
+			// Find out the ship facing and speed.
+			facing = StarShipPtr->ShipFacing;
+			GetCurrentVelocityComponents (&ElementPtr->velocity, &speedx, &speedy);
+			totalspeed = sqrt (speedx * speedx + speedy * speedy);
+
+			// Upon pressing the special key, speed rapidly to the direction which the ship was heading to.
+			if (frame_index < NUM_SHIP_FACINGS
+				&& StarShipPtr->RaceDescPtr->ship_info.energy_level >= SPECIAL_ENERGY_COST
+				&& StarShipPtr->cur_status_flags & (LEFT | RIGHT)
+				)//&& totalspeed < DERVISH_THRUST)
+			{
+				// Decrement battery.
+				DeltaEnergy (ElementPtr, -SPECIAL_ENERGY_COST);
+				
+				// Go FAAAAST!
+				SetVelocityVector (&ElementPtr->velocity, DERVISH_THRUST, NORMALIZE_FACING (facing));
+				
+				// Dervish swoosh sound.
+				ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 1), ElementPtr);
+				
+				// Spinning blade sound.
+				ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 2), ElementPtr);
+				
+				if (StarShipPtr->cur_status_flags & LEFT)
+					turn_direction[ElementPtr->playerNr] = 1;
+				else if (StarShipPtr->cur_status_flags & RIGHT)
+					turn_direction[ElementPtr->playerNr] = 2;
+			}
+			
+
+			// Can't turn or use primary weapon in dervish mode.
+			cur_status_flags &= ~(THRUST | WEAPON | LEFT | RIGHT);
+			
+			// Turn ship around whilst in dervish mode.
+			if (turn_direction[ElementPtr->playerNr] == 1)
+				facing -= 2;
+			else if (turn_direction[ElementPtr->playerNr] == 2)
+				facing += 2;
+			facing %= NUM_SHIP_FACINGS;
+			StarShipPtr->ShipFacing = facing;
+			
+			// Change to blur graphics.
+			if (turn_direction[ElementPtr->playerNr])
+			{
+				ElementPtr->next.image.frame = SetAbsFrameIndex (ElementPtr->current.image.frame, facing + NUM_SHIP_FACINGS);
+				cur_status_flags |= SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED;
+			}
+		}
+	}
+	// The player must let go of the special key between dervishes.
+	// This requirement eliminates all sorts of bugs.
+	else if (!(StarShipPtr->old_status_flags & SPECIAL) 
+		&& !(StarShipPtr->cur_status_flags & SPECIAL)
+		&& StarShipPtr->RaceDescPtr->ship_info.energy_level > SPECIAL_ENERGY_COST)
+	{
+		not_had_pause[ElementPtr->playerNr] = 0;
+		turn_direction[ElementPtr->playerNr] = 0;
+	}
+	
+	StarShipPtr->cur_status_flags = cur_status_flags;
+}
+
+RACE_DESC*
+init_foonfoon (void)
+{
+	RACE_DESC *RaceDescPtr;
+	
+	if (RESOLUTION_FACTOR == 0)
+	{
+		foonfoon_desc.postprocess_func = foonfoon_postprocess;
+		foonfoon_desc.preprocess_func  = foonfoon_preprocess;
+		foonfoon_desc.init_weapon_func = initialize_focusball_which_bursts;
+		foonfoon_desc.cyborg_control.intelligence_func = foonfoon_intelligence;
+		RaceDescPtr = &foonfoon_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		foonfoon_desc_2xres.postprocess_func = foonfoon_postprocess;
+		foonfoon_desc_2xres.preprocess_func  = foonfoon_preprocess;
+		foonfoon_desc_2xres.init_weapon_func = initialize_focusball_which_bursts;
+		foonfoon_desc_2xres.cyborg_control.intelligence_func = foonfoon_intelligence;
+		RaceDescPtr = &foonfoon_desc_2xres;
+	}
+	else
+	{
+		foonfoon_desc_4xres.postprocess_func = foonfoon_postprocess;
+		foonfoon_desc_4xres.preprocess_func  = foonfoon_preprocess;
+		foonfoon_desc_4xres.init_weapon_func = initialize_focusball_which_bursts;
+		foonfoon_desc_4xres.cyborg_control.intelligence_func = foonfoon_intelligence;
+		RaceDescPtr = &foonfoon_desc_4xres;
+	}
+	
+	return (RaceDescPtr);
+}
diff -ruNp src.orig/uqm/ships/foonfoon/foonfoon.h src/uqm/ships/foonfoon/foonfoon.h
--- src.orig/uqm/ships/foonfoon/foonfoon.h	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/foonfoon/foonfoon.h	2017-11-01 15:31:04 -0700
@@ -0,0 +1,23 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef FOONFOON_H
+#define FOONFOON_H
+
+RACE_DESC *init_foonfoon (void);
+
+#endif  /* FOONFOON_H */
+
diff -ruNp src.orig/uqm/ships/foonfoon/icode.h src/uqm/ships/foonfoon/icode.h
--- src.orig/uqm/ships/foonfoon/icode.h	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/foonfoon/icode.h	2017-11-01 15:31:04 -0700
@@ -0,0 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
+#define FOONFOON_CODE "ship.foonfoon.code"
diff -ruNp src.orig/uqm/ships/foonfoon/igfxres.h src/uqm/ships/foonfoon/igfxres.h
--- src.orig/uqm/ships/foonfoon/igfxres.h	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/foonfoon/igfxres.h	2017-11-01 15:31:04 -0700
@@ -0,0 +1,16 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
+#define FOONFOON_BIG_MASK_PMAP_ANIM "ship.foonfoon.graphics.typhoon.large"
+#define FOONFOON_BURST_BIG_MASK_PMAP_ANIM "ship.foonfoon.graphics.burst.large"
+#define FOONFOON_BURST_MED_MASK_PMAP_ANIM "ship.foonfoon.graphics.burst.medium"
+#define FOONFOON_BURST_SML_MASK_PMAP_ANIM "ship.foonfoon.graphics.burst.small"
+#define FOONFOON_CAPTAIN_MASK_PMAP_ANIM "ship.foonfoon.graphics.captain"
+#define FOONFOON_ICON_MASK_PMAP_ANIM "ship.foonfoon.icons"
+#define FOONFOON_MED_MASK_PMAP_ANIM "ship.foonfoon.graphics.typhoon.medium"
+#define FOONFOON_MICON_MASK_PMAP_ANIM "ship.foonfoon.meleeicons"
+#define FOONFOON_SABRE_BIG_MASK_PMAP_ANIM "ship.foonfoon.graphics.sabre.large"
+#define FOONFOON_SABRE_MED_MASK_PMAP_ANIM "ship.foonfoon.graphics.sabre.medium"
+#define FOONFOON_SABRE_SML_MASK_PMAP_ANIM "ship.foonfoon.graphics.sabre.small"
+#define FOONFOON_SML_MASK_PMAP_ANIM "ship.foonfoon.graphics.typhoon.small"
diff -ruNp src.orig/uqm/ships/foonfoon/imusicre.h src/uqm/ships/foonfoon/imusicre.h
--- src.orig/uqm/ships/foonfoon/imusicre.h	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/foonfoon/imusicre.h	2017-11-01 15:31:04 -0700
@@ -0,0 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
+#define FOONFOON_VICTORY_SONG "ship.foonfoon.ditty"
diff -ruNp src.orig/uqm/ships/foonfoon/isndres.h src/uqm/ships/foonfoon/isndres.h
--- src.orig/uqm/ships/foonfoon/isndres.h	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/foonfoon/isndres.h	2017-11-01 15:31:04 -0700
@@ -0,0 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
+#define FOONFOON_SHIP_SOUNDS "ship.foonfoon.sounds"
diff -ruNp src.orig/uqm/ships/foonfoon/istrtab.h src/uqm/ships/foonfoon/istrtab.h
--- src.orig/uqm/ships/foonfoon/istrtab.h	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/foonfoon/istrtab.h	2017-11-01 15:31:04 -0700
@@ -0,0 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
+#define FOONFOON_RACE_STRINGS "ship.foonfoon.text"
diff -ruNp src.orig/uqm/ships/foonfoon/resinst.h src/uqm/ships/foonfoon/resinst.h
--- src.orig/uqm/ships/foonfoon/resinst.h	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/foonfoon/resinst.h	2017-11-01 15:31:04 -0700
@@ -0,0 +1,17 @@
+#define FOONFOON_BIG_MASK_PMAP_ANIM "ship.foonfoon.graphics.typhoon.large"
+#define FOONFOON_CAPTAIN_MASK_PMAP_ANIM "ship.foonfoon.graphics.captain"
+#define FOONFOON_ICON_MASK_PMAP_ANIM "ship.foonfoon.icons"
+#define FOONFOON_MED_MASK_PMAP_ANIM "ship.foonfoon.graphics.typhoon.medium"
+#define FOONFOON_MICON_MASK_PMAP_ANIM "ship.foonfoon.meleeicons"
+#define FOONFOON_BURST_BIG_MASK_PMAP_ANIM "ship.foonfoon.graphics.burst.large"
+#define FOONFOON_BURST_MED_MASK_PMAP_ANIM "ship.foonfoon.graphics.burst.medium"
+#define FOONFOON_BURST_SML_MASK_PMAP_ANIM "ship.foonfoon.graphics.burst.small"
+#define FOONFOON_SABRE_BIG_MASK_PMAP_ANIM "ship.foonfoon.graphics.sabre.large"
+#define FOONFOON_SABRE_MED_MASK_PMAP_ANIM "ship.foonfoon.graphics.sabre.medium"
+#define FOONFOON_SABRE_SML_MASK_PMAP_ANIM "ship.foonfoon.graphics.sabre.small"
+#define FOONFOON_SML_MASK_PMAP_ANIM "ship.foonfoon.graphics.typhoon.small"
+#define FOONFOON_VICTORY_SONG "ship.foonfoon.ditty"
+#define FOONFOON_SHIP_SOUNDS "ship.foonfoon.sounds"
+#define FOONFOON_RACE_STRINGS "ship.foonfoon.text"
+
+#include "icode.h"
diff -ruNp src.orig/uqm/ships/human/human.c src/uqm/ships/human/human.c
--- src.orig/uqm/ships/human/human.c	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/human/human.c	2017-11-01 15:31:04 -0700
@@ -39,25 +39,25 @@
 
 #define SHIP_MASS 6
 #define MISSILE_LIFE 60
-#define MIN_MISSILE_SPEED DISPLAY_TO_WORLD (10)
-#define MAX_MISSILE_SPEED DISPLAY_TO_WORLD (20)
+#define MIN_MISSILE_SPEED DISPLAY_TO_WORLD (10 << RESOLUTION_FACTOR) // JMS_GFX
+#define MAX_MISSILE_SPEED DISPLAY_TO_WORLD (20 << RESOLUTION_FACTOR) // JMS_GFX
 
 static RACE_DESC human_desc =
 {
 	{ /* SHIP_INFO */
-		FIRES_FORE | SEEKING_WEAPON | POINT_DEFENSE,
+		FIRES_FORE | SEEKING_WEAPON | LIGHT_POINT_DEFENSE,
 		11, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY, MAX_ENERGY,
 		HUMAN_RACE_STRINGS,
 		HUMAN_ICON_MASK_PMAP_ANIM,
 		HUMAN_MICON_MASK_PMAP_ANIM,
-		NULL, NULL, NULL
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
 	},
 	{ /* FLEET_STUFF */
-		0, /* Initial sphere of influence radius */
+		400 / SPHERE_RADIUS_INCREMENT * 2, /* Initial sphere of influence radius */
 		{ /* Known location (center of SoI) */
-			1752, 1450,
+			6752, 7450,
 		},
 	},
 	{
@@ -113,8 +113,159 @@ static RACE_DESC human_desc =
 	0, /* CodeRef */
 };
 
-#define MISSILE_SPEED (MAX_THRUST >= MIN_MISSILE_SPEED ? \
-										MAX_THRUST : MIN_MISSILE_SPEED)
+// JMS_GFX
+#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (12) */ 48
+#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (4) */ 6
+
+// JMS_GFX
+static RACE_DESC human_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_WEAPON | LIGHT_POINT_DEFENSE,
+		11, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		HUMAN_RACE_STRINGS,
+		HUMAN_ICON_MASK_PMAP_ANIM,
+		HUMAN_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		400 / SPHERE_RADIUS_INCREMENT * 2, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			6752, 7450,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			HUMAN_BIG_MASK_PMAP_ANIM,
+			HUMAN_MED_MASK_PMAP_ANIM,
+			HUMAN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SATURN_BIG_MASK_PMAP_ANIM,
+			SATURN_MED_MASK_PMAP_ANIM,
+			SATURN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			HUMAN_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		HUMAN_VICTORY_SONG,
+		HUMAN_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		LONG_RANGE_WEAPON_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (24) */ 96
+#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (8) */ 12
+
+// JMS_GFX
+static RACE_DESC human_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_WEAPON | LIGHT_POINT_DEFENSE,
+		11, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		HUMAN_RACE_STRINGS,
+		HUMAN_ICON_MASK_PMAP_ANIM,
+		HUMAN_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		400 / SPHERE_RADIUS_INCREMENT * 2, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			6752, 7450,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			HUMAN_BIG_MASK_PMAP_ANIM,
+			HUMAN_MED_MASK_PMAP_ANIM,
+			HUMAN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SATURN_BIG_MASK_PMAP_ANIM,
+			SATURN_MED_MASK_PMAP_ANIM,
+			SATURN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			HUMAN_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		HUMAN_VICTORY_SONG,
+		HUMAN_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		LONG_RANGE_WEAPON_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+#define MISSILE_SPEED ((MAX_THRUST << RESOLUTION_FACTOR) >= MIN_MISSILE_SPEED ? (MAX_THRUST << RESOLUTION_FACTOR) : MIN_MISSILE_SPEED) // JMS_GFX
 #define TRACK_WAIT 3
 
 static void
@@ -141,10 +292,8 @@ nuke_preprocess (ELEMENT *ElementPtr)
 	{
 		SIZE speed;
 
-#define THRUST_SCALE DISPLAY_TO_WORLD (1)
-		if ((speed = MISSILE_SPEED +
-				((MISSILE_LIFE - ElementPtr->life_span) *
-				THRUST_SCALE)) > MAX_MISSILE_SPEED)
+#define THRUST_SCALE DISPLAY_TO_WORLD (1 << RESOLUTION_FACTOR) // JMS_GFX
+		if ((speed = MISSILE_SPEED + ((MISSILE_LIFE - ElementPtr->life_span) * THRUST_SCALE)) > MAX_MISSILE_SPEED)
 			speed = MAX_MISSILE_SPEED;
 		SetVelocityVector (&ElementPtr->velocity,
 				speed, facing);
@@ -193,10 +342,12 @@ spawn_point_defense (ELEMENT *ElementPtr
 
 			LockElement (hObject, &ObjectPtr);
 			hNextObject = GetPredElement (ObjectPtr);
-			if (ObjectPtr != ShipPtr && CollidingElement (ObjectPtr) &&
-					!OBJECT_CLOAKED (ObjectPtr))
+			if (ObjectPtr != ShipPtr 
+				&& CollidingElement (ObjectPtr) 
+				&& !OBJECT_CLOAKED (ObjectPtr)
+				&& !(ObjectPtr->state_flags & GASSY_SUBSTANCE)) // JMS: Don't zap Baul gas clouds.
 			{
-#define LASER_RANGE (UWORD)100
+#define LASER_RANGE (UWORD)(100 << RESOLUTION_FACTOR) // JMS_GFX
 				SIZE delta_x, delta_y;
 
 				delta_x = ObjectPtr->next.location.x -
@@ -265,10 +416,10 @@ spawn_point_defense (ELEMENT *ElementPtr
 static COUNT
 initialize_nuke (ELEMENT *ShipPtr, HELEMENT NukeArray[])
 {
-#define HUMAN_OFFSET 42
+#define HUMAN_OFFSET (42 << RESOLUTION_FACTOR) // JMS_GFX
 #define MISSILE_DAMAGE 4
 #define MISSILE_HITS 1
-#define NUKE_OFFSET 8
+#define NUKE_OFFSET (8 << RESOLUTION_FACTOR) // JMS_GFX
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -280,7 +431,7 @@ initialize_nuke (ELEMENT *ShipPtr, HELEM
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = 0;
 	MissileBlock.pixoffs = HUMAN_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -347,11 +498,27 @@ init_human (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	human_desc.postprocess_func = human_postprocess;
-	human_desc.init_weapon_func = initialize_nuke;
-	human_desc.cyborg_control.intelligence_func = human_intelligence;
-
-	RaceDescPtr = &human_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		human_desc.postprocess_func = human_postprocess;
+		human_desc.init_weapon_func = initialize_nuke;
+		human_desc.cyborg_control.intelligence_func = human_intelligence;
+		RaceDescPtr = &human_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		human_desc_2xres.postprocess_func = human_postprocess;
+		human_desc_2xres.init_weapon_func = initialize_nuke;
+		human_desc_2xres.cyborg_control.intelligence_func = human_intelligence;
+		RaceDescPtr = &human_desc_2xres;
+	}
+	else
+	{
+		human_desc_4xres.postprocess_func = human_postprocess;
+		human_desc_4xres.init_weapon_func = initialize_nuke;
+		human_desc_4xres.cyborg_control.intelligence_func = human_intelligence;
+		RaceDescPtr = &human_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp src.orig/uqm/ships/human/icode.h src/uqm/ships/human/icode.h
--- src.orig/uqm/ships/human/icode.h	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/human/icode.h	2017-11-01 15:31:04 -0700
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define HUMAN_CODE "ship.earthling.code"
diff -ruNp src.orig/uqm/ships/ilwrath/icode.h src/uqm/ships/ilwrath/icode.h
--- src.orig/uqm/ships/ilwrath/icode.h	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/ilwrath/icode.h	2017-11-01 15:31:04 -0700
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define ILWRATH_CODE "ship.ilwrath.code"
diff -ruNp src.orig/uqm/ships/ilwrath/ilwrath.c src/uqm/ships/ilwrath/ilwrath.c
--- src.orig/uqm/ships/ilwrath/ilwrath.c	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/ilwrath/ilwrath.c	2017-11-01 15:31:04 -0700
@@ -50,12 +50,12 @@ static RACE_DESC ilwrath_desc =
 		ILWRATH_RACE_STRINGS,
 		ILWRATH_ICON_MASK_PMAP_ANIM,
 		ILWRATH_MICON_MASK_PMAP_ANIM,
-		NULL, NULL, NULL
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
 	},
 	{ /* FLEET_STUFF */
-		1410 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		0, /* Initial SoI radius */
 		{ /* Known location (center of SoI) */
-			48, 1700,
+			0,0,
 		},
 	},
 	{
@@ -111,6 +111,158 @@ static RACE_DESC ilwrath_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+#define MAX_THRUST_2XRES 50
+#define THRUST_INCREMENT_2XRES 10
+
+// JMS_GFX
+static RACE_DESC ilwrath_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		10, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ILWRATH_RACE_STRINGS,
+		ILWRATH_ICON_MASK_PMAP_ANIM,
+		ILWRATH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			0,0,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ILWRATH_BIG_MASK_PMAP_ANIM,
+			ILWRATH_MED_MASK_PMAP_ANIM,
+			ILWRATH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			FIRE_BIG_MASK_PMAP_ANIM,
+			FIRE_MED_MASK_PMAP_ANIM,
+			FIRE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			ILWRATH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ILWRATH_VICTORY_SONG,
+		ILWRATH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 100
+#define THRUST_INCREMENT_4XRES 20
+
+// JMS_GFX
+static RACE_DESC ilwrath_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		10, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ILWRATH_RACE_STRINGS,
+		ILWRATH_ICON_MASK_PMAP_ANIM,
+		ILWRATH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			0,0,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ILWRATH_BIG_MASK_PMAP_ANIM,
+			ILWRATH_MED_MASK_PMAP_ANIM,
+			ILWRATH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			FIRE_BIG_MASK_PMAP_ANIM,
+			FIRE_MED_MASK_PMAP_ANIM,
+			FIRE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			ILWRATH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ILWRATH_VICTORY_SONG,
+		ILWRATH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static void
 flame_preprocess (ELEMENT *ElementPtr)
 {
@@ -118,10 +270,8 @@ flame_preprocess (ELEMENT *ElementPtr)
 		--ElementPtr->turn_wait;
 	else
 	{
-		ElementPtr->next.image.frame =
-				IncFrameIndex (ElementPtr->current.image.frame);
+		ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->current.image.frame);
 		ElementPtr->state_flags |= CHANGING;
-
 		ElementPtr->turn_wait = ElementPtr->next_turn;
 	}
 }
@@ -136,14 +286,14 @@ flame_collision (ELEMENT *ElementPtr0, P
 }
 
 static void
-ilwrath_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
-		COUNT ConcernCounter)
+ilwrath_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern, COUNT ConcernCounter)
 {
 	EVALUATE_DESC *lpEvalDesc;
 	STARSHIP *StarShipPtr;
 
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
-	 lpEvalDesc->MoveState = PURSUE;
+	lpEvalDesc->MoveState = PURSUE;
+	
 	if (lpEvalDesc->ObjectPtr && lpEvalDesc->which_turn <= 10)
 				/* don't want to dodge when you could be flaming */
 		ObjectsOfConcern[ENEMY_WEAPON_INDEX].ObjectPtr = 0;
@@ -178,8 +328,8 @@ ilwrath_intelligence (ELEMENT *ShipPtr,
 static COUNT
 initialize_flame (ELEMENT *ShipPtr, HELEMENT FlameArray[])
 {
-#define ILWRATH_OFFSET 29
-#define MISSILE_SPEED MAX_THRUST
+#define ILWRATH_OFFSET (29 << RESOLUTION_FACTOR)		// JMS_GFX
+#define MISSILE_SPEED (MAX_THRUST << RESOLUTION_FACTOR) // JMS_GFX
 #define MISSILE_HITS 1
 #define MISSILE_DAMAGE 1
 #define MISSILE_OFFSET 0
@@ -269,8 +419,9 @@ ilwrath_preprocess (ELEMENT *ElementPtr)
 				ProcessSound (SetAbsSoundIndex (
 								/* CLOAKING_OFF */
 						StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 2), ElementPtr);
-				SetPrimColor (lpPrim,
-						BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01));
+				
+				SetPrimColor (lpPrim, BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01));
+				
 				if (weapon_discharge)
 				{
 					COUNT facing;
@@ -342,11 +493,30 @@ ilwrath_preprocess (ELEMENT *ElementPtr)
 		}
 		else if (!sameColor (color, BLACK_COLOR))
 		{
-			if (sameColor (color,
-					BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01)))
+			if (sameColor (color, BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01)))
 			{
+				HELEMENT hElement, hNextElement;
+				ELEMENT  *EnemyShipCandidatePtr;
+				STARSHIP *EnemyStarShipCandidatePtr;
+				
 				SetPrimColor (lpPrim, BLACK_COLOR);
-				Untarget (ElementPtr);
+				
+				// JMS: Don't untarget Baul gas clouds. (Otherwise they would just vanish upon cloaking.)
+				for (hElement = GetHeadElement (); hElement != 0; hElement = hNextElement)
+				{
+					LockElement (hElement, &EnemyShipCandidatePtr);
+					hNextElement = GetSuccElement (EnemyShipCandidatePtr);
+					
+					if (EnemyShipCandidatePtr->state_flags & PLAYER_SHIP)
+					{
+						GetElementStarShip (EnemyShipCandidatePtr, &EnemyStarShipCandidatePtr);
+						
+						if (EnemyStarShipCandidatePtr->SpeciesID != BAUL_ID)
+							Untarget (ElementPtr);
+						
+						break;
+					}
+				}
 			}
 			else if (sameColor (color,
 					BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x1F), 0x09)))
@@ -392,11 +562,27 @@ init_ilwrath (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	ilwrath_desc.preprocess_func = ilwrath_preprocess;
-	ilwrath_desc.init_weapon_func = initialize_flame;
-	ilwrath_desc.cyborg_control.intelligence_func = ilwrath_intelligence;
-
-	RaceDescPtr = &ilwrath_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		ilwrath_desc.preprocess_func = ilwrath_preprocess;
+		ilwrath_desc.init_weapon_func = initialize_flame;
+		ilwrath_desc.cyborg_control.intelligence_func = ilwrath_intelligence;
+		RaceDescPtr = &ilwrath_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		ilwrath_desc_2xres.preprocess_func = ilwrath_preprocess;
+		ilwrath_desc_2xres.init_weapon_func = initialize_flame;
+		ilwrath_desc_2xres.cyborg_control.intelligence_func = ilwrath_intelligence;
+		RaceDescPtr = &ilwrath_desc_2xres;
+	}
+	else
+	{
+		ilwrath_desc_4xres.preprocess_func = ilwrath_preprocess;
+		ilwrath_desc_4xres.init_weapon_func = initialize_flame;
+		ilwrath_desc_4xres.cyborg_control.intelligence_func = ilwrath_intelligence;
+		RaceDescPtr = &ilwrath_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp src.orig/uqm/ships/isd/Makeinfo src/uqm/ships/isd/Makeinfo
--- src.orig/uqm/ships/isd/Makeinfo	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/isd/Makeinfo	2017-11-01 15:31:04 -0700
@@ -0,0 +1 @@
+uqm_CFILES="isd.c"
diff -ruNp src.orig/uqm/ships/isd/icode.h src/uqm/ships/isd/icode.h
--- src.orig/uqm/ships/isd/icode.h	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/isd/icode.h	2017-11-01 15:31:04 -0700
@@ -0,0 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
+#define ISD_CODE "ship.isd.code"
diff -ruNp src.orig/uqm/ships/isd/isd.c src/uqm/ships/isd/isd.c
--- src.orig/uqm/ships/isd/isd.c	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/isd/isd.c	2017-11-01 15:31:04 -0700
@@ -0,0 +1,948 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "../ship.h"
+#include "isd.h"
+#include "resinst.h"
+#include "uqm/colors.h"
+#include "uqm/globdata.h"
+#include "libs/mathlib.h"
+#include <stdlib.h>
+
+#define MAX_CREW MAX_CREW_SIZE
+#define MAX_ENERGY MAX_ENERGY_SIZE
+#define ENERGY_REGENERATION 3
+#define ENERGY_WAIT 10
+#define MAX_THRUST 30
+#define THRUST_INCREMENT 6
+#define TURN_WAIT 6
+#define THRUST_WAIT 6
+#define SPECIAL_WAIT 9
+#define SHIP_MASS 10
+
+#define WEAPON_ENERGY_COST 1
+#define WEAPON_WAIT 2
+#define MISSILE_SPEED DISPLAY_TO_WORLD (25)
+#define MISSILE_LIFE 15
+#define MISSILE_HITS 2
+#define MISSILE_DAMAGE 2
+#define MISSILE_OFFSET (8 << RESOLUTION_FACTOR) // JMS_GFX
+#define ISD_OFFSET (42 << RESOLUTION_FACTOR) // JMS_GFX
+
+#define SPECIAL_ENERGY_COST 8
+#define TRACK_THRESHOLD 6
+#define ONE_WAY_FLIGHT 125
+#define FIGHTER_LIFE (ONE_WAY_FLIGHT + ONE_WAY_FLIGHT + 150)
+#define FIGHTER_SPEED DISPLAY_TO_WORLD (8 << RESOLUTION_FACTOR) // JMS_GFX
+#define FIGHTER_WEAPON_WAIT 8
+#define FIGHTER_LASER_SPEED DISPLAY_TO_WORLD (20 << RESOLUTION_FACTOR) // JMS_GFX
+#define FIGHTER_LASER_HITS 1
+#define FIGHTER_LASER_DAMAGE 1
+#define FIGHTER_LASER_LIFE 10
+#define FIGHTER_LASER_OFFSET (2 << RESOLUTION_FACTOR) // JMS_GFX
+#define FIGHTER_LASER_BLAST_OFFSET (4 << RESOLUTION_FACTOR) // JMS_GFX
+#define FIGHTER_LASER_RANGE DISPLAY_TO_WORLD ((120 << RESOLUTION_FACTOR) + FIGHTER_LASER_OFFSET) // JMS_GFX
+
+#define AUXILIARY_ENERGY_COST 1
+#define AUTOTURRET_RANGE ((MISSILE_SPEED * MISSILE_LIFE) << RESOLUTION_FACTOR) // JMS_GFX
+#define AUTOTURRET_WAIT 11
+#define AUTOTURRET_OFFSET (20 << RESOLUTION_FACTOR) // JMS_GFX
+
+static RACE_DESC isd_desc =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_SPECIAL,
+		30, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ISD_RACE_STRINGS,
+		ISD_ICON_MASK_PMAP_ANIM,
+		ISD_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			0,0,
+		},
+	},
+	{
+		MAX_THRUST,
+		THRUST_INCREMENT,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ISD_BIG_MASK_PMAP_ANIM,
+			ISD_MED_MASK_PMAP_ANIM,
+			ISD_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ISDLASER_BIG_MASK_PMAP_ANIM,
+			ISDLASER_MED_MASK_PMAP_ANIM,
+			ISDLASER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ISDFIGHTER_BIG_MASK_PMAP_ANIM,
+			ISDFIGHTER_MED_MASK_PMAP_ANIM,
+			ISDFIGHTER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ISD_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ISD_VICTORY_SONG,
+		ISD_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_SPEED * MISSILE_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_2XRES 60
+#define THRUST_INCREMENT_2XRES 12
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (50)
+
+// JMS_GFX
+static RACE_DESC isd_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_SPECIAL,
+		30, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ISD_RACE_STRINGS,
+		ISD_ICON_MASK_PMAP_ANIM,
+		ISD_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			0,0,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ISD_BIG_MASK_PMAP_ANIM,
+			ISD_MED_MASK_PMAP_ANIM,
+			ISD_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ISDLASER_BIG_MASK_PMAP_ANIM,
+			ISDLASER_MED_MASK_PMAP_ANIM,
+			ISDLASER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ISDFIGHTER_BIG_MASK_PMAP_ANIM,
+			ISDFIGHTER_MED_MASK_PMAP_ANIM,
+			ISDFIGHTER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ISD_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ISD_VICTORY_SONG,
+		ISD_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_SPEED_2XRES * MISSILE_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 120
+#define THRUST_INCREMENT_4XRES 24
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (100)
+
+// JMS_GFX
+static RACE_DESC isd_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_SPECIAL,
+		30, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ISD_RACE_STRINGS,
+		ISD_ICON_MASK_PMAP_ANIM,
+		ISD_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			0,0,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ISD_BIG_MASK_PMAP_ANIM,
+			ISD_MED_MASK_PMAP_ANIM,
+			ISD_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ISDLASER_BIG_MASK_PMAP_ANIM,
+			ISDLASER_MED_MASK_PMAP_ANIM,
+			ISDLASER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ISDFIGHTER_BIG_MASK_PMAP_ANIM,
+			ISDFIGHTER_MED_MASK_PMAP_ANIM,
+			ISDFIGHTER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ISD_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ISD_VICTORY_SONG,
+		ISD_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_SPEED_4XRES * MISSILE_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+static COUNT
+initialize_turbolaser (ELEMENT *ShipPtr, HELEMENT MissileArray[])
+{
+	STARSHIP *StarShipPtr;
+	MISSILE_BLOCK MissileBlock;
+	int turret;
+	// COUNT shot_facing;
+	
+	GetElementStarShip (ShipPtr, &StarShipPtr);
+	MissileBlock.farray = StarShipPtr->RaceDescPtr->ship_data.weapon;
+	MissileBlock.face = MissileBlock.index = NORMALIZE_FACING (StarShipPtr->ShipFacing);
+	MissileBlock.sender = ShipPtr->playerNr;
+	MissileBlock.flags = IGNORE_SIMILAR;
+	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
+	MissileBlock.hit_points = MISSILE_HITS;
+	MissileBlock.damage = MISSILE_DAMAGE;
+	MissileBlock.life = MISSILE_LIFE;
+	MissileBlock.preprocess_func = NULL;
+	MissileBlock.blast_offs = MISSILE_OFFSET;
+	MissileBlock.pixoffs = ISD_OFFSET;
+
+	turret = TFB_Random () % 7;
+
+	if (turret == 0)
+	{
+		MissileBlock.cx = ShipPtr->next.location.x;
+		MissileBlock.cy = ShipPtr->next.location.y;
+	}
+	else if (turret == 1)
+	{
+		MissileBlock.cx = ShipPtr->next.location.x + COSINE(FACING_TO_ANGLE (MissileBlock.face + 4), (32 << RESOLUTION_FACTOR))
+			+ COSINE(FACING_TO_ANGLE(StarShipPtr->ShipFacing), -(52 << RESOLUTION_FACTOR));
+		MissileBlock.cy = ShipPtr->next.location.y + SINE(FACING_TO_ANGLE (MissileBlock.face + 4), (32 << RESOLUTION_FACTOR))
+			+ SINE(FACING_TO_ANGLE(StarShipPtr->ShipFacing), -(52 << RESOLUTION_FACTOR));
+	}
+	else if (turret == 2)
+	{
+		MissileBlock.cx = ShipPtr->next.location.x + COSINE(FACING_TO_ANGLE (MissileBlock.face + 4), -(32 << RESOLUTION_FACTOR))
+			+ COSINE(FACING_TO_ANGLE(StarShipPtr->ShipFacing), -(52 << RESOLUTION_FACTOR));
+		MissileBlock.cy = ShipPtr->next.location.y + SINE(FACING_TO_ANGLE (MissileBlock.face + 4), -(32 << RESOLUTION_FACTOR))
+			+ SINE(FACING_TO_ANGLE(StarShipPtr->ShipFacing), -(52 << RESOLUTION_FACTOR));
+	}
+	else if (turret == 3)
+	{
+		MissileBlock.cx = ShipPtr->next.location.x + COSINE(FACING_TO_ANGLE (MissileBlock.face + 4), (48 << RESOLUTION_FACTOR))
+			+ COSINE(FACING_TO_ANGLE(StarShipPtr->ShipFacing), -(120 << RESOLUTION_FACTOR));
+		MissileBlock.cy = ShipPtr->next.location.y + SINE(FACING_TO_ANGLE (MissileBlock.face + 4), (48 << RESOLUTION_FACTOR))
+			+ SINE(FACING_TO_ANGLE(StarShipPtr->ShipFacing), -(120 << RESOLUTION_FACTOR));
+	}
+	else if (turret == 4)
+	{
+		MissileBlock.cx = ShipPtr->next.location.x + COSINE(FACING_TO_ANGLE (MissileBlock.face + 4), -(48 << RESOLUTION_FACTOR))
+			+ COSINE(FACING_TO_ANGLE(StarShipPtr->ShipFacing), -(136 << RESOLUTION_FACTOR));
+		MissileBlock.cy = ShipPtr->next.location.y + SINE(FACING_TO_ANGLE (MissileBlock.face + 4), -(48 << RESOLUTION_FACTOR))
+			+ SINE(FACING_TO_ANGLE(StarShipPtr->ShipFacing), -(136 << RESOLUTION_FACTOR));
+	}
+	else if (turret == 5)
+	{
+		MissileBlock.cx = ShipPtr->next.location.x + COSINE(FACING_TO_ANGLE (MissileBlock.face + 4), (64 << RESOLUTION_FACTOR))
+			+ COSINE(FACING_TO_ANGLE(StarShipPtr->ShipFacing), -(156 << RESOLUTION_FACTOR));
+		MissileBlock.cy = ShipPtr->next.location.y + SINE(FACING_TO_ANGLE (MissileBlock.face + 4), (64 << RESOLUTION_FACTOR))
+			+ SINE(FACING_TO_ANGLE(StarShipPtr->ShipFacing), -(156 << RESOLUTION_FACTOR));
+	}
+	else if (turret == 6)
+	{
+		MissileBlock.cx = ShipPtr->next.location.x + COSINE(FACING_TO_ANGLE (MissileBlock.face + 4), -(64 << RESOLUTION_FACTOR))
+			+ COSINE(FACING_TO_ANGLE(StarShipPtr->ShipFacing), -(156 << RESOLUTION_FACTOR));
+		MissileBlock.cy = ShipPtr->next.location.y + SINE(FACING_TO_ANGLE (MissileBlock.face + 4), -(64 << RESOLUTION_FACTOR))
+			+ SINE(FACING_TO_ANGLE(StarShipPtr->ShipFacing), -(156 << RESOLUTION_FACTOR));
+	}
+	
+	MissileArray[0] = initialize_missile (&MissileBlock);
+	return (1);
+}
+
+static COUNT
+initialize_fighterlaser (ELEMENT *ElementPtr, HELEMENT LaserArray[])
+{
+	STARSHIP *StarShipPtr;
+	MISSILE_BLOCK MissileBlock;
+	
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+	
+	MissileBlock.cx = ElementPtr->next.location.x;
+	MissileBlock.cy = ElementPtr->next.location.y;
+	MissileBlock.face = ElementPtr->thrust_wait;
+	MissileBlock.sender = ElementPtr->playerNr;
+	MissileBlock.flags = IGNORE_SIMILAR;
+	MissileBlock.pixoffs = FIGHTER_LASER_OFFSET;
+	// The fighter laser graphics are after the first 16 frames (which are the fighter hull graphics).
+	MissileBlock.index = MissileBlock.face + 16;
+	MissileBlock.farray = StarShipPtr->RaceDescPtr->ship_data.special;
+	MissileBlock.speed = FIGHTER_LASER_SPEED;
+	MissileBlock.hit_points = FIGHTER_LASER_HITS;
+	MissileBlock.damage = FIGHTER_LASER_DAMAGE;
+	MissileBlock.life = FIGHTER_LASER_LIFE;
+
+	MissileBlock.preprocess_func = NULL;
+	MissileBlock.blast_offs = FIGHTER_LASER_BLAST_OFFSET;
+	LaserArray[0] = initialize_missile (&MissileBlock);
+	
+	return (1);
+}
+
+/*static void
+fighter_postprocess (ELEMENT *ElementPtr)
+{
+	HELEMENT Laser;
+	STARSHIP *StarShipPtr;
+	
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+	initialize_fighterlaser (ElementPtr, &Laser);
+	
+	if (Laser)
+	{
+		ELEMENT *LaserPtr;
+
+		LockElement (Laser, &LaserPtr);
+		SetElementStarShip (LaserPtr, StarShipPtr);
+
+		// FIGHTER ZAP
+		ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 2), LaserPtr);
+
+		UnlockElement (Laser);
+		PutElement (Laser);
+	}
+	
+	ElementPtr->postprocess_func = 0;
+	ElementPtr->thrust_wait = FIGHTER_WEAPON_WAIT;
+}*/
+
+static void
+fighter_preprocess (ELEMENT *ElementPtr)
+{
+	STARSHIP *StarShipPtr;
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+
+	++StarShipPtr->RaceDescPtr->characteristics.special_wait;
+	
+	if (FIGHTER_LIFE - ElementPtr->life_span > TRACK_THRESHOLD && !(ElementPtr->state_flags & CHANGING))
+	{
+		BOOLEAN Enroute;
+		COUNT orig_facing, facing;
+		SIZE delta_x, delta_y;
+		ELEMENT *eptr;
+
+		Enroute = TRUE;
+
+		delta_x = StarShipPtr->RaceDescPtr->ship_info.crew_level;
+		delta_y = ElementPtr->life_span;
+
+		orig_facing = facing = GetFrameIndex (ElementPtr->current.image.frame);
+		if (((delta_y & 1) || ElementPtr->hTarget || TrackShip (ElementPtr, &facing) >= 0)
+				&& (delta_x == 0 || delta_y >= ONE_WAY_FLIGHT))
+			ElementPtr->state_flags |= IGNORE_SIMILAR;
+		else if (delta_x)
+		{
+			LockElement (StarShipPtr->hShip, &eptr);
+			delta_x = eptr->current.location.x - ElementPtr->current.location.x;
+			delta_y = eptr->current.location.y - ElementPtr->current.location.y;
+			UnlockElement (StarShipPtr->hShip);
+			delta_x = WRAP_DELTA_X (delta_x);
+			delta_y = WRAP_DELTA_Y (delta_y);
+			facing = NORMALIZE_FACING (ANGLE_TO_FACING (ARCTAN (delta_x, delta_y)));
+
+			ElementPtr->state_flags &= ~IGNORE_SIMILAR;
+
+			Enroute = FALSE;
+		}
+
+		if (ElementPtr->thrust_wait > 0)
+			--ElementPtr->thrust_wait;
+
+		if (ElementPtr->hTarget)
+		{
+			LockElement (ElementPtr->hTarget, &eptr);
+			delta_x = eptr->current.location.x - ElementPtr->current.location.x;
+			delta_y = eptr->current.location.y - ElementPtr->current.location.y;
+			UnlockElement (ElementPtr->hTarget);
+			delta_x = WRAP_DELTA_X (delta_x);
+			delta_y = WRAP_DELTA_Y (delta_y);
+
+			if (ElementPtr->thrust_wait == 0
+					&& abs (delta_x) < FIGHTER_LASER_RANGE * 3 / 4
+					&& abs (delta_y) < FIGHTER_LASER_RANGE * 3 / 4
+					&& delta_x * delta_x + delta_y * delta_y < 
+						(FIGHTER_LASER_RANGE * 3 / 4) * (FIGHTER_LASER_RANGE * 3 / 4))
+			{
+				HELEMENT Laser;
+
+				ElementPtr->thrust_wait =
+					(BYTE)NORMALIZE_FACING (ANGLE_TO_FACING (ARCTAN (delta_x, delta_y)));
+
+				initialize_fighterlaser (ElementPtr, &Laser);
+				if (Laser)
+				{
+					ELEMENT *LaserPtr;
+
+					LockElement (Laser, &LaserPtr);
+					SetElementStarShip (LaserPtr, StarShipPtr);
+
+					// FIGHTER ZAP
+					ProcessSound (SetAbsSoundIndex
+						(StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 2), LaserPtr);
+
+					UnlockElement (Laser);
+					PutElement (Laser);
+				}
+				
+				ElementPtr->thrust_wait = FIGHTER_WEAPON_WAIT;
+			}
+
+			if (Enroute)
+			{
+				facing = GetFrameIndex (eptr->current.image.frame);
+				if (ElementPtr->turn_wait & LEFT)
+				{
+					delta_x += COSINE (FACING_TO_ANGLE (facing - 4), DISPLAY_TO_WORLD (30 << RESOLUTION_FACTOR));
+					delta_y += SINE (FACING_TO_ANGLE (facing - 4), DISPLAY_TO_WORLD (30 << RESOLUTION_FACTOR));
+				}
+				else
+				{
+					delta_x += COSINE (FACING_TO_ANGLE (facing + 4), DISPLAY_TO_WORLD (30 << RESOLUTION_FACTOR));
+					delta_y += SINE (FACING_TO_ANGLE (facing + 4), DISPLAY_TO_WORLD (30 << RESOLUTION_FACTOR));
+				}
+				facing = NORMALIZE_FACING (ANGLE_TO_FACING (ARCTAN (delta_x, delta_y)));
+			}
+		}
+		ElementPtr->state_flags |= CHANGING;
+
+		if (facing != orig_facing)
+			ElementPtr->next.image.frame = SetAbsFrameIndex (ElementPtr->next.image.frame, facing);
+		
+		SetVelocityVector (&ElementPtr->velocity, FIGHTER_SPEED, facing);
+	}
+}
+
+static void
+fighter_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
+{
+	STARSHIP *StarShipPtr;
+
+	GetElementStarShip (ElementPtr0, &StarShipPtr);
+	if (GRAVITY_MASS (ElementPtr1->mass_points))
+	{
+		HELEMENT hFighterElement;
+
+		hFighterElement = AllocElement ();
+		if (hFighterElement)
+		{
+			COUNT primIndex, travel_facing;
+			SIZE delta_facing;
+			ELEMENT *FighterElementPtr;
+
+			LockElement (hFighterElement, &FighterElementPtr);
+			primIndex = FighterElementPtr->PrimIndex;
+			*FighterElementPtr = *ElementPtr0;
+			FighterElementPtr->PrimIndex = primIndex;
+			(GLOBAL (DisplayArray))[primIndex] = (GLOBAL (DisplayArray))[ElementPtr0->PrimIndex];
+			FighterElementPtr->state_flags &= ~PRE_PROCESS;
+			FighterElementPtr->state_flags |= CHANGING;
+			FighterElementPtr->next = FighterElementPtr->current;
+			travel_facing = GetVelocityTravelAngle (&FighterElementPtr->velocity);
+			delta_facing = NORMALIZE_ANGLE (ARCTAN (pPt1->x - pPt0->x, pPt1->y - pPt0->y)- travel_facing);
+		
+			if (delta_facing == 0)
+			{
+				if (FighterElementPtr->turn_wait & LEFT)
+					travel_facing -= QUADRANT;
+				else
+					travel_facing += QUADRANT;
+			}
+			else if (delta_facing <= HALF_CIRCLE)
+				travel_facing -= QUADRANT;
+			else
+				travel_facing += QUADRANT;
+
+			travel_facing = NORMALIZE_FACING (ANGLE_TO_FACING (NORMALIZE_ANGLE (travel_facing)));
+			FighterElementPtr->next.image.frame =
+					SetAbsFrameIndex (FighterElementPtr->next.image.frame,travel_facing);
+			SetVelocityVector (&FighterElementPtr->velocity, FIGHTER_SPEED, travel_facing);
+			UnlockElement (hFighterElement);
+
+			PutElement (hFighterElement);
+		}
+
+		ElementPtr0->state_flags |= DISAPPEARING | COLLISION;
+	}
+	else if (ElementPtr0->pParent != ElementPtr1->pParent)
+	{
+		ElementPtr0->blast_offset = 0;
+		weapon_collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
+		ElementPtr0->state_flags |= DISAPPEARING | COLLISION;
+	}
+	else if (ElementPtr1->state_flags & PLAYER_SHIP)
+	{
+		ProcessSound (SetAbsSoundIndex (
+						/* FIGHTERS_RETURN */
+				StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 3), ElementPtr1);
+		DeltaCrew (ElementPtr1, 1);
+		ElementPtr0->state_flags |= DISAPPEARING | COLLISION;
+	}
+
+	if (ElementPtr0->state_flags & DISAPPEARING)
+	{
+		ElementPtr0->state_flags &= ~DISAPPEARING;
+
+		ElementPtr0->hit_points = 0;
+		ElementPtr0->life_span = 0;
+		ElementPtr0->state_flags |= NONSOLID;
+
+		--StarShipPtr->RaceDescPtr->characteristics.special_wait;
+	}
+}
+
+static void
+spawn_fighters (ELEMENT *ElementPtr)
+{
+	SIZE i;
+	COUNT facing;
+	SIZE delta_x, delta_y;
+	HELEMENT hFighterElement;
+	STARSHIP *StarShipPtr;
+
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+	facing = StarShipPtr->ShipFacing + ANGLE_TO_FACING (HALF_CIRCLE);
+	delta_x = COSINE (FACING_TO_ANGLE (facing), DISPLAY_TO_WORLD (14 << RESOLUTION_FACTOR));
+	delta_y = SINE (FACING_TO_ANGLE (facing), DISPLAY_TO_WORLD (14 << RESOLUTION_FACTOR));
+
+	i = ElementPtr->crew_level > 2 ? 2 : 1;
+	while (i-- && (hFighterElement = AllocElement ()))
+	{
+		SIZE sx, sy;
+		COUNT fighter_facing;
+		ELEMENT *FighterElementPtr;
+
+		DeltaCrew (ElementPtr, -1);
+
+		PutElement (hFighterElement);
+		LockElement (hFighterElement, &FighterElementPtr);
+		FighterElementPtr->hit_points = 1;
+		FighterElementPtr->mass_points = 0;
+		FighterElementPtr->thrust_wait = TRACK_THRESHOLD + 1;
+		FighterElementPtr->state_flags = APPEARING | FINITE_LIFE | CREW_OBJECT | IGNORE_SIMILAR ;
+		FighterElementPtr->playerNr = ElementPtr->playerNr;
+		FighterElementPtr->life_span = FIGHTER_LIFE;
+		SetPrimType (&(GLOBAL (DisplayArray))[FighterElementPtr->PrimIndex], STAMP_PRIM);
+		{
+			FighterElementPtr->preprocess_func = fighter_preprocess;
+			FighterElementPtr->postprocess_func = 0;
+			FighterElementPtr->collision_func = fighter_collision;
+			FighterElementPtr->death_func = NULL;
+		}
+
+		FighterElementPtr->current.location = ElementPtr->next.location;
+		if (i == 1)
+		{
+			FighterElementPtr->turn_wait = LEFT;
+			fighter_facing = NORMALIZE_FACING (facing + 2);
+			FighterElementPtr->current.location.x += delta_x - delta_y;
+			FighterElementPtr->current.location.y += delta_y + delta_x;
+		}
+		else
+		{
+			FighterElementPtr->turn_wait = RIGHT;
+			fighter_facing = NORMALIZE_FACING (facing - 2);
+			FighterElementPtr->current.location.x += delta_x + delta_y;
+			FighterElementPtr->current.location.y += delta_y - delta_x;
+		}
+		
+		sx = COSINE (FACING_TO_ANGLE (fighter_facing), WORLD_TO_VELOCITY (FIGHTER_SPEED));
+		sy = SINE (FACING_TO_ANGLE (fighter_facing), WORLD_TO_VELOCITY (FIGHTER_SPEED));
+		SetVelocityComponents (&FighterElementPtr->velocity, sx, sy);
+		FighterElementPtr->current.location.x -= VELOCITY_TO_WORLD (sx);
+		FighterElementPtr->current.location.y -= VELOCITY_TO_WORLD (sy);
+
+		FighterElementPtr->current.image.farray = StarShipPtr->RaceDescPtr->ship_data.special;
+		FighterElementPtr->current.image.frame = SetAbsFrameIndex (StarShipPtr->RaceDescPtr->ship_data.special[0], fighter_facing);
+		SetElementStarShip (FighterElementPtr, StarShipPtr);
+		UnlockElement (hFighterElement);
+	}
+}
+
+static void
+isd_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern, COUNT ConcernCounter)
+{
+	STARSHIP *StarShipPtr;
+	EVALUATE_DESC *lpEvalDesc;
+
+	GetElementStarShip (ShipPtr, &StarShipPtr);
+
+	ObjectsOfConcern[ENEMY_SHIP_INDEX].MoveState = PURSUE;
+	lpEvalDesc = &ObjectsOfConcern[ENEMY_WEAPON_INDEX];
+
+	if (lpEvalDesc->ObjectPtr
+			&& lpEvalDesc->MoveState == ENTICE
+			&& (!(lpEvalDesc->ObjectPtr->state_flags & CREW_OBJECT)
+			|| lpEvalDesc->which_turn <= 8)
+			&& (!(lpEvalDesc->ObjectPtr->state_flags & FINITE_LIFE)
+			|| (lpEvalDesc->ObjectPtr->mass_points >= 4
+			&& lpEvalDesc->which_turn == 2
+			&& ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn > 16)))
+		lpEvalDesc->MoveState = PURSUE;
+
+	// Basic ship intelligence
+	ship_intelligence (ShipPtr, ObjectsOfConcern, ConcernCounter);
+
+	lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
+	{
+		STARSHIP *EnemyStarShipPtr;
+
+		if (lpEvalDesc->ObjectPtr)
+		{
+			GetElementStarShip (lpEvalDesc->ObjectPtr, &EnemyStarShipPtr);
+
+			// ISD will attack if the enemy is within approximate reach.
+			if (ship_weapons (ShipPtr, ObjectsOfConcern->ObjectPtr, DISPLAY_TO_WORLD (25 << RESOLUTION_FACTOR)))
+				StarShipPtr->ship_input_state |= WEAPON;
+		}
+		if (StarShipPtr->special_counter == 0
+				&& lpEvalDesc->ObjectPtr
+				&& StarShipPtr->RaceDescPtr->ship_info.crew_level >
+				(StarShipPtr->RaceDescPtr->ship_info.max_crew >> 2)
+				&& !(EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags
+					& (LIGHT_POINT_DEFENSE | HEAVY_POINT_DEFENSE))
+				&& (StarShipPtr->RaceDescPtr->characteristics.special_wait < 6
+				|| (MANEUVERABILITY (&EnemyStarShipPtr->RaceDescPtr->cyborg_control) <= (SLOW_SHIP << RESOLUTION_FACTOR) // JMS_GFX
+				&& !(EnemyStarShipPtr->cur_status_flags & SHIP_BEYOND_MAX_SPEED))
+				|| (lpEvalDesc->which_turn <= 12
+				&& (StarShipPtr->ship_input_state & (LEFT | RIGHT))
+				&& StarShipPtr->RaceDescPtr->ship_info.energy_level >=
+				(BYTE)(StarShipPtr->RaceDescPtr->ship_info.max_energy >> 1))))
+			StarShipPtr->ship_input_state |= SPECIAL;
+		else
+			StarShipPtr->ship_input_state &= ~SPECIAL;
+	}
+
+	StarShipPtr->RaceDescPtr->characteristics.special_wait = 0;
+}
+
+static void
+initialize_autoturret (ELEMENT *ElementPtr)
+{
+	BYTE weakest;
+	STARSHIP *StarShipPtr;
+	HELEMENT hObject, hNextObject, hBestObject;
+	ELEMENT *ShipPtr, *ObjectPtr;
+	SIZE delta_x, delta_y;
+	long dist, best_dist;
+
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+	hBestObject = 0;
+	best_dist = AUTOTURRET_RANGE + 1;
+	weakest = 255;
+	LockElement (StarShipPtr->hShip, &ShipPtr);
+
+	// Is an enemy object within range?
+	for (hObject = GetPredElement (ElementPtr);
+			hObject; hObject = hNextObject)
+	{
+		LockElement (hObject, &ObjectPtr);
+		hNextObject = GetPredElement (ObjectPtr);
+		if (!elementsOfSamePlayer(ObjectPtr, ShipPtr)
+		        && ObjectPtr->playerNr != NEUTRAL_PLAYER_NUM
+			&& CollisionPossible (ObjectPtr, ShipPtr)
+			&& !OBJECT_CLOAKED (ObjectPtr)
+			&& !(ObjectPtr->state_flags & GASSY_SUBSTANCE))
+		{
+			delta_x = ObjectPtr->next.location.x
+					- ShipPtr->next.location.x;
+			delta_y = ObjectPtr->next.location.y
+					- ShipPtr->next.location.y;
+			if (delta_x < 0)
+				delta_x = -delta_x;
+			if (delta_y < 0)
+				delta_y = -delta_y;
+
+			// Range check.
+			if (delta_x <= AUTOTURRET_RANGE
+				&& delta_y <= AUTOTURRET_RANGE
+				&& (dist = (long)delta_x * delta_x + (long)delta_y * delta_y)
+				<= (long)AUTOTURRET_RANGE * AUTOTURRET_RANGE)
+			{
+				// The enemy ship is the highest priority target.
+				if (ObjectPtr->state_flags & PLAYER_SHIP)
+				{
+					hBestObject = hObject;
+					best_dist = 0;
+					weakest = 0;
+				}
+				// Otherwise target an enemy projectile. Lower hitpoints and closer proximity are preferable.
+				else if (ObjectPtr->hit_points < weakest
+					|| (ObjectPtr->hit_points == weakest
+					&& dist < best_dist))
+				{
+					hBestObject = hObject;
+					best_dist = dist;
+					weakest = ObjectPtr->hit_points;
+				}
+			}
+		}
+		UnlockElement (hObject);
+	}
+
+	// Fire autoturret.
+	if (hBestObject)
+	{
+		COUNT num_frames;
+		HELEMENT hAutoLaser;
+		MISSILE_BLOCK MissileBlock;
+
+		LockElement (hBestObject, &ObjectPtr);
+
+		delta_x = ObjectPtr->current.location.x
+				- ShipPtr->current.location.x;
+		delta_x = WRAP_DELTA_X (delta_x);
+		delta_y = ObjectPtr->current.location.y
+				- ShipPtr->current.location.y;
+		delta_y = WRAP_DELTA_Y (delta_y);
+	
+		num_frames = (square_root ((long)delta_x * delta_x
+				+ (long)delta_y * delta_y)) / (MISSILE_SPEED << RESOLUTION_FACTOR);
+		if (num_frames == 0)
+			num_frames = 1;
+	
+		GetNextVelocityComponents (&ObjectPtr->velocity,
+				&delta_x, &delta_y, num_frames);
+	
+		// This calculation causes the autoturret to lead its target.
+		delta_x = (ObjectPtr->current.location.x + (delta_x / 2))
+				- ShipPtr->current.location.x;
+		delta_y = (ObjectPtr->current.location.y + (delta_y / 2))
+				- ShipPtr->current.location.y;
+
+		MissileBlock.cx = ShipPtr->next.location.x;
+		MissileBlock.cy = ShipPtr->next.location.y;
+		MissileBlock.farray = StarShipPtr->RaceDescPtr->ship_data.weapon;
+		MissileBlock.face = MissileBlock.index = NORMALIZE_FACING (ANGLE_TO_FACING (ARCTAN (delta_x, delta_y)));
+		MissileBlock.sender = ShipPtr->playerNr;
+		MissileBlock.flags = IGNORE_SIMILAR;
+		MissileBlock.pixoffs = AUTOTURRET_OFFSET;
+		MissileBlock.speed = (MISSILE_SPEED << RESOLUTION_FACTOR);
+		MissileBlock.hit_points = MISSILE_HITS;
+		MissileBlock.damage = MISSILE_DAMAGE;
+		MissileBlock.life = MISSILE_LIFE;
+		MissileBlock.preprocess_func = NULL;
+		MissileBlock.blast_offs = MISSILE_OFFSET;
+		
+		hAutoLaser = initialize_missile (&MissileBlock);
+		if (hAutoLaser)
+		{
+			ELEMENT *AutoLaserPtr;
+
+			LockElement (hAutoLaser, &AutoLaserPtr);
+			SetElementStarShip (AutoLaserPtr, StarShipPtr);
+			AutoLaserPtr->hTarget = 0;
+			ProcessSound (SetAbsSoundIndex (
+					/* Primary weapon sound */
+			StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 0), ElementPtr);
+			UnlockElement (hAutoLaser);
+			PutElement (hAutoLaser);
+
+			DeltaEnergy (ElementPtr, -AUXILIARY_ENERGY_COST);
+			StarShipPtr->auxiliary_counter = AUTOTURRET_WAIT;
+		}
+
+		UnlockElement (hBestObject);
+	}
+
+	UnlockElement (StarShipPtr->hShip);
+}
+
+static void
+isd_postprocess (ELEMENT *ElementPtr)
+{
+	STARSHIP *StarShipPtr;
+
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+		
+	if ((StarShipPtr->cur_status_flags & SPECIAL)
+			&& ElementPtr->crew_level > 1
+			&& StarShipPtr->special_counter == 0
+			&& DeltaEnergy (ElementPtr, -SPECIAL_ENERGY_COST))
+	{
+		ProcessSound (SetAbsSoundIndex (
+						/* LAUNCH_FIGHTERS */
+				StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 1), ElementPtr);
+		spawn_fighters (ElementPtr);
+
+		StarShipPtr->special_counter = SPECIAL_WAIT;
+	}
+
+	if (StarShipPtr->auxiliary_counter == 0
+		&& StarShipPtr->RaceDescPtr->ship_info.energy_level >= AUXILIARY_ENERGY_COST)
+	{
+		HELEMENT hDefense;
+
+		hDefense = AllocElement ();
+		if (hDefense)
+		{
+			ELEMENT *DefensePtr;
+			
+			PutElement (hDefense);
+
+			LockElement (hDefense, &DefensePtr);
+			DefensePtr->state_flags = APPEARING | NONSOLID | FINITE_LIFE ;
+			DefensePtr->playerNr = ElementPtr->playerNr;
+
+			{
+				ELEMENT *SuccPtr;
+
+				LockElement (GetSuccElement (ElementPtr), &SuccPtr);
+				DefensePtr->hTarget = GetPredElement (SuccPtr);
+				UnlockElement (GetSuccElement (ElementPtr));
+
+				DefensePtr->death_func = initialize_autoturret;
+			}
+
+			SetElementStarShip (DefensePtr, StarShipPtr);
+			
+			UnlockElement (hDefense);
+		}
+	}
+}
+
+RACE_DESC*
+init_isd (void)
+{
+	RACE_DESC *RaceDescPtr;
+
+	if (RESOLUTION_FACTOR == 0)
+	{
+		// isd_desc.preprocess_func = isd_preprocess;
+		isd_desc.postprocess_func = isd_postprocess;
+		isd_desc.init_weapon_func = initialize_turbolaser;
+		isd_desc.cyborg_control.intelligence_func = isd_intelligence;
+		RaceDescPtr = &isd_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		// isd_desc_2xres.preprocess_func = isd_preprocess;
+		isd_desc_2xres.postprocess_func = isd_postprocess;
+		isd_desc_2xres.init_weapon_func = initialize_turbolaser;
+		isd_desc_2xres.cyborg_control.intelligence_func = isd_intelligence;
+		RaceDescPtr = &isd_desc_2xres;
+	}
+	else
+	{
+		// isd_desc_4xres.preprocess_func = isd_preprocess;
+		isd_desc_4xres.postprocess_func = isd_postprocess;
+		isd_desc_4xres.init_weapon_func = initialize_turbolaser;
+		isd_desc_4xres.cyborg_control.intelligence_func = isd_intelligence;
+		RaceDescPtr = &isd_desc_4xres;
+	}
+
+	return (RaceDescPtr);
+}
diff -ruNp src.orig/uqm/ships/isd/isd.h src/uqm/ships/isd/isd.h
--- src.orig/uqm/ships/isd/isd.h	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/isd/isd.h	2017-11-01 15:31:04 -0700
@@ -0,0 +1,23 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef ISD_H
+#define ISD_H
+
+RACE_DESC *init_isd (void);
+
+#endif  /* ISD_H */
+
diff -ruNp src.orig/uqm/ships/isd/resinst.h src/uqm/ships/isd/resinst.h
--- src.orig/uqm/ships/isd/resinst.h	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/isd/resinst.h	2017-11-01 15:31:04 -0700
@@ -0,0 +1,17 @@
+#define ISDFIGHTER_BIG_MASK_PMAP_ANIM "ship.isd.graphics.fighter.large"
+#define ISDFIGHTER_MED_MASK_PMAP_ANIM "ship.isd.graphics.fighter.medium"
+#define ISDFIGHTER_SML_MASK_PMAP_ANIM "ship.isd.graphics.fighter.small"
+#define ISDLASER_BIG_MASK_PMAP_ANIM "ship.isd.graphics.laser.large"
+#define ISDLASER_MED_MASK_PMAP_ANIM "ship.isd.graphics.laser.medium"
+#define ISDLASER_SML_MASK_PMAP_ANIM "ship.isd.graphics.laser.small"
+#define ISD_BIG_MASK_PMAP_ANIM "ship.isd.graphics.isd.large"
+#define ISD_CAPTAIN_MASK_PMAP_ANIM "ship.isd.graphics.captain"
+#define ISD_ICON_MASK_PMAP_ANIM "ship.isd.icons"
+#define ISD_MED_MASK_PMAP_ANIM "ship.isd.graphics.isd.medium"
+#define ISD_MICON_MASK_PMAP_ANIM "ship.isd.meleeicons"
+#define ISD_SML_MASK_PMAP_ANIM "ship.isd.graphics.isd.small"
+#define ISD_RACE_STRINGS "ship.isd.text"
+#define ISD_SHIP_SOUNDS "ship.isd.sounds"
+#define ISD_VICTORY_SONG "ship.isd.ditty"
+
+#include "icode.h"
diff -ruNp src.orig/uqm/ships/lastbat/icode.h src/uqm/ships/lastbat/icode.h
--- src.orig/uqm/ships/lastbat/icode.h	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/lastbat/icode.h	2017-11-01 15:31:04 -0700
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SAMATRA_CODE "ship.samatra.code"
diff -ruNp src.orig/uqm/ships/lastbat/lastbat.c src/uqm/ships/lastbat/lastbat.c
--- src.orig/uqm/ships/lastbat/lastbat.c	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/lastbat/lastbat.c	2017-11-01 15:31:04 -0700
@@ -57,7 +57,7 @@ static RACE_DESC samatra_desc =
 		NULL_RESOURCE,
 		NULL_RESOURCE,
 		NULL_RESOURCE,
-		NULL, NULL, NULL
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
 	},
 	{ /* FLEET_STUFF */
 		0, /* Initial sphere of influence radius */
@@ -545,10 +545,10 @@ sentinel_preprocess (ELEMENT *ElementPtr
 					- ElementPtr->current.location.y;
 			delta_y = WRAP_DELTA_Y (delta_y);
 
-			if ((num_frames = WORLD_TO_TURN (
+			if ((num_frames = (WORLD_TO_TURN (
 					square_root ((long)delta_x * delta_x
 					+ (long)delta_y * delta_y)
-					)) == 0)
+					)) >> RESOLUTION_FACTOR) == 0)
 				num_frames = 1;
 
 			TargetVelocity = TargetPtr->velocity;
diff -ruNp src.orig/uqm/ships/lurg/Makeinfo src/uqm/ships/lurg/Makeinfo
--- src.orig/uqm/ships/lurg/Makeinfo	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/lurg/Makeinfo	2017-11-01 15:31:04 -0700
@@ -0,0 +1 @@
+uqm_CFILES="lurg.c"
diff -ruNp src.orig/uqm/ships/lurg/icode.h src/uqm/ships/lurg/icode.h
--- src.orig/uqm/ships/lurg/icode.h	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/lurg/icode.h	2017-11-01 15:31:04 -0700
@@ -0,0 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
+#define LURG_CODE "ship.lurg.code"
diff -ruNp src.orig/uqm/ships/lurg/lurg.c src/uqm/ships/lurg/lurg.c
--- src.orig/uqm/ships/lurg/lurg.c	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/lurg/lurg.c	2017-11-01 15:31:04 -0700
@@ -0,0 +1,750 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "../ship.h"
+#include "lurg.h"
+#include "resinst.h"
+#include "libs/mathlib.h"
+
+
+// Core characteristics
+#define MAX_CREW 20
+#define MAX_ENERGY 20
+#define ENERGY_REGENERATION 1
+#define ENERGY_WAIT 6
+#define MAX_THRUST 20
+#define THRUST_INCREMENT 5
+#define THRUST_WAIT 2
+#define TURN_WAIT 1
+#define SHIP_MASS 6
+
+// Primary weapon
+#define WEAPON_ENERGY_COST 4
+#define WEAPON_WAIT 10
+#define MISSILE_SPEED DISPLAY_TO_WORLD (18)
+#define MISSILE_LIFE 23
+#define MISSILE_HITS 5
+#define MISSILE_DAMAGE 4
+#define MISSILE_OFFSET (2 << RESOLUTION_FACTOR) // JMS_GFX
+#define LURG_OFFSET (23 << RESOLUTION_FACTOR) // JMS_GFX
+
+// Secondary weapon
+#define SPECIAL_ENERGY_COST 2
+#define SPECIAL_WAIT 2
+#define OIL_BATCH_SIZE 6
+#define OIL_SPEED DISPLAY_TO_WORLD (2 << RESOLUTION_FACTOR) // JMS_GFX
+#define OIL_INIT_SPEED DISPLAY_TO_WORLD (6 << RESOLUTION_FACTOR) // JMS_GFX
+#define OIL_HITS 3
+#define OIL_DAMAGE 1 // Oil inflicts damage against projectiles, not ships.
+#define OIL_SPREAD_MINIMUM 6
+#define OIL_SPREAD_VARIATION 4
+#define OIL_LIFE 300
+#define OIL_LIFE_VARIATION 100
+#define OIL_DELAY 6
+#define OIL_DELAY_MAX 36
+#define OIL_SNARE WORLD_TO_VELOCITY (-1)
+#define OIL_OFFSET (3 << RESOLUTION_FACTOR) // JMS_GFX
+#define LURG_OFFSET_2 (16 << RESOLUTION_FACTOR) // JMS_GFX
+
+// Bonus ability
+#define REPAIR_WAIT 192
+
+static RACE_DESC lurg_desc =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_SPECIAL | LIGHT_POINT_DEFENSE,
+		20, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		LURG_RACE_STRINGS,
+		LURG_ICON_MASK_PMAP_ANIM,
+		LURG_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, //1525 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			3710, 4389,
+		},
+	},
+	{
+		MAX_THRUST,
+		THRUST_INCREMENT,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			LURG_BIG_MASK_PMAP_ANIM,
+			LURG_MED_MASK_PMAP_ANIM,
+			LURG_SML_MASK_PMAP_ANIM,
+		},
+		{
+			LURGGOB_BIG_MASK_PMAP_ANIM,
+			LURGGOB_MED_MASK_PMAP_ANIM,
+			LURGGOB_SML_MASK_PMAP_ANIM,
+		},
+		{
+			OIL_BIG_MASK_PMAP_ANIM,
+			OIL_MED_MASK_PMAP_ANIM,
+			OIL_SML_MASK_PMAP_ANIM,
+		},
+		{
+			LURG_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		LURG_VICTORY_SONG,
+		LURG_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(MISSILE_SPEED * MISSILE_LIFE) *  4/5,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_2XRES 40
+#define THRUST_INCREMENT_2XRES 12
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (36)
+
+// JMS_GFX
+static RACE_DESC lurg_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_SPECIAL | LIGHT_POINT_DEFENSE,
+		20, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		LURG_RACE_STRINGS,
+		LURG_ICON_MASK_PMAP_ANIM,
+		LURG_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, //1525 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			3710, 4389,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			LURG_BIG_MASK_PMAP_ANIM,
+			LURG_MED_MASK_PMAP_ANIM,
+			LURG_SML_MASK_PMAP_ANIM,
+		},
+		{
+			LURGGOB_BIG_MASK_PMAP_ANIM,
+			LURGGOB_MED_MASK_PMAP_ANIM,
+			LURGGOB_SML_MASK_PMAP_ANIM,
+		},
+		{
+			OIL_BIG_MASK_PMAP_ANIM,
+			OIL_MED_MASK_PMAP_ANIM,
+			OIL_SML_MASK_PMAP_ANIM,
+		},
+		{
+			LURG_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		LURG_VICTORY_SONG,
+		LURG_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(MISSILE_SPEED_2XRES * MISSILE_LIFE) *  4/5,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 80
+#define THRUST_INCREMENT_4XRES 24
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (72)
+
+// JMS_GFX
+static RACE_DESC lurg_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_SPECIAL | LIGHT_POINT_DEFENSE,
+		20, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		LURG_RACE_STRINGS,
+		LURG_ICON_MASK_PMAP_ANIM,
+		LURG_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, //1525 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			3710, 4389,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			LURG_BIG_MASK_PMAP_ANIM,
+			LURG_MED_MASK_PMAP_ANIM,
+			LURG_SML_MASK_PMAP_ANIM,
+		},
+		{
+			LURGGOB_BIG_MASK_PMAP_ANIM,
+			LURGGOB_MED_MASK_PMAP_ANIM,
+			LURGGOB_SML_MASK_PMAP_ANIM,
+		},
+		{
+			OIL_BIG_MASK_PMAP_ANIM,
+			OIL_MED_MASK_PMAP_ANIM,
+			OIL_SML_MASK_PMAP_ANIM,
+		},
+		{
+			LURG_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		LURG_VICTORY_SONG,
+		LURG_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(MISSILE_SPEED_4XRES * MISSILE_LIFE) *  4/5,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+static void
+lurg_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern, COUNT ConcernCounter)
+{
+	STARSHIP *StarShipPtr;
+	EVALUATE_DESC *lpEvalDesc;
+	
+	GetElementStarShip (ShipPtr, &StarShipPtr);
+
+	// Don't use the special unless specifically told to.
+	StarShipPtr->ship_input_state &= ~SPECIAL;
+
+	lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
+	if (lpEvalDesc->ObjectPtr)
+	{
+		STARSHIP *EnemyStarShipPtr;
+		SIZE EnemyTravelFacing, TestFacing, CurrentEnemySpeed, delta_x, delta_y;
+
+		GetElementStarShip (lpEvalDesc->ObjectPtr, &EnemyStarShipPtr);
+
+		// Be more responsive against slow ships.
+		if (MANEUVERABILITY (&EnemyStarShipPtr->RaceDescPtr->cyborg_control) <= (SLOW_SHIP << RESOLUTION_FACTOR)) // JMS_GFX
+			lpEvalDesc->which_turn = lpEvalDesc->which_turn * 4/5;
+
+		// Start of crazy calculations //
+		// Transform enemy velocity into cute little world units for easy comparison.
+		GetCurrentVelocityComponents (&lpEvalDesc->ObjectPtr->velocity, &delta_x, &delta_y);
+		CurrentEnemySpeed = VELOCITY_TO_WORLD (square_root (VelocitySquared (delta_x, delta_y)));
+
+		// Draw a line from the enemy's current position to the enemy's projected future position.
+		EnemyTravelFacing = ANGLE_TO_FACING (ARCTAN (
+			lpEvalDesc->ObjectPtr->next.location.x	
+				- lpEvalDesc->ObjectPtr->current.location.x,
+			lpEvalDesc->ObjectPtr->next.location.y
+				- lpEvalDesc->ObjectPtr->current.location.y));
+
+		// Draw a line from the Prawn to the enemy.
+		TestFacing = ANGLE_TO_FACING (ARCTAN (
+			lpEvalDesc->ObjectPtr->current.location.x
+				- ShipPtr->current.location.x,
+			lpEvalDesc->ObjectPtr->current.location.y
+				- ShipPtr->current.location.y));
+
+		// Compare enemy's direction of travel to the Prawn's position.
+		TestFacing = NORMALIZE_FACING (TestFacing - EnemyTravelFacing);
+		// End of crazy calculations //
+
+		// Avoid contact when the enemy is warping in or moving directly away.
+		if (lpEvalDesc->ObjectPtr->state_flags & APPEARING
+			|| (TestFacing > 6 && TestFacing < 10
+				&& CurrentEnemySpeed >= (16 << RESOLUTION_FACTOR)))
+		{
+			lpEvalDesc->MoveState = AVOID;
+		}
+		// Attack when the enemy is ensnared, attempting an escape sequence or at short range.
+		else if ((lpEvalDesc->which_turn <= 32
+			&& lpEvalDesc->ObjectPtr->turn_wait >= OIL_DELAY
+			&& lpEvalDesc->ObjectPtr->thrust_wait >= OIL_DELAY)
+			|| lpEvalDesc->which_turn <= 15
+			|| lpEvalDesc->ObjectPtr->mass_points > MAX_SHIP_MASS)
+		{
+			lpEvalDesc->MoveState = PURSUE;
+
+			// Disregard enemy weapons in these circumstances.
+			ObjectsOfConcern[ENEMY_WEAPON_INDEX].ObjectPtr = NULL;
+		}
+		// Stall for time when the enemy is far away.
+		else if (lpEvalDesc->which_turn > 20 && lpEvalDesc->which_turn < 47)
+		{
+			lpEvalDesc->MoveState = AVOID;
+		}
+		// Entice rather than retreat when the enemy is very far away.
+		else if (lpEvalDesc->which_turn >= 47)
+		{
+			lpEvalDesc->MoveState = ENTICE;
+		}
+	}
+
+	lpEvalDesc = &ObjectsOfConcern[ENEMY_WEAPON_INDEX];
+
+	// Drop oil in the way of various incoming projectiles.
+	if (lpEvalDesc->ObjectPtr
+		&& StarShipPtr->RaceDescPtr->ship_info.energy_level >= 8
+		&& lpEvalDesc->ObjectPtr->hit_points < 4 // Forget high HP projectiles.
+		&& (lpEvalDesc->ObjectPtr->mass_points
+			|| lpEvalDesc->ObjectPtr->state_flags & (CREW_OBJECT | FINITE_LIFE))
+		&& lpEvalDesc->which_turn <= 10)
+	{
+		StarShipPtr->ship_input_state |= SPECIAL;
+	}
+	
+	// Otherwise disregard all enemy weapons unless there's a crew weapon or huge weapon present.
+	if (lpEvalDesc->ObjectPtr
+			&& !(lpEvalDesc->ObjectPtr->state_flags & CREW_OBJECT)
+			&& !(lpEvalDesc->ObjectPtr->hit_points >= 6)
+			&& !(lpEvalDesc->ObjectPtr->mass_points >= 6))
+	{
+		ObjectsOfConcern[ENEMY_WEAPON_INDEX].ObjectPtr = NULL;
+	}
+	
+	// Basic ship intelligence.
+	ship_intelligence (ShipPtr, ObjectsOfConcern, ConcernCounter);
+
+	lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
+	if (lpEvalDesc->ObjectPtr)
+	{
+		// Cut thrust when attacking...
+		if (lpEvalDesc->MoveState == PURSUE
+			// ...unless the enemy is ensnared...
+			&& (lpEvalDesc->ObjectPtr->turn_wait < OIL_DELAY
+				|| lpEvalDesc->ObjectPtr->thrust_wait < OIL_DELAY)
+			// ...or the enemy is attempting an escape sequence...
+			&& (lpEvalDesc->ObjectPtr->mass_points <= MAX_SHIP_MASS)
+			// ...or the Prawn is completely stationary.
+			&& ShipPtr->next.location.x != ShipPtr->current.location.x
+			&& ShipPtr->next.location.y != ShipPtr->current.location.y)
+		{
+			StarShipPtr->ship_input_state &= ~THRUST;
+		}
+
+		// Don't shoot unless specifically told to OR a particular enemy weapon type is active.
+		if (ObjectsOfConcern[ENEMY_WEAPON_INDEX].ObjectPtr == NULL)
+		{
+			StarShipPtr->ship_input_state &= ~WEAPON;
+		}
+
+		// Frequently disregard good firing opportunities.
+		if (ship_weapons (ShipPtr, lpEvalDesc->ObjectPtr, DISPLAY_TO_WORLD (10 << RESOLUTION_FACTOR))) // JMS_GFX
+		{
+			if (TFB_Random () & 3)
+				StarShipPtr->ship_input_state |= WEAPON;
+		}
+		// Sometimes take shots that don't line up with the opponent's current trajectory.
+		else if (ship_weapons (ShipPtr, lpEvalDesc->ObjectPtr, DISPLAY_TO_WORLD (20 << RESOLUTION_FACTOR))) // JMS_GFX
+		{
+			if (TFB_Random () & 5)
+				StarShipPtr->ship_input_state |= WEAPON;
+		}
+		else if (ship_weapons (ShipPtr, lpEvalDesc->ObjectPtr, DISPLAY_TO_WORLD (30 << RESOLUTION_FACTOR))) // JMS_GFX
+		{
+			if (TFB_Random () % 11)
+				StarShipPtr->ship_input_state |= WEAPON;
+		}
+		
+		// Drop several batches of oil whenever the battery tops off.
+		if ((StarShipPtr->RaceDescPtr->ship_info.energy_level ==
+					StarShipPtr->RaceDescPtr->ship_info.max_energy)
+				|| (StarShipPtr->RaceDescPtr->ship_info.energy_level >
+						StarShipPtr->RaceDescPtr->ship_info.max_energy - 6
+					&& StarShipPtr->old_status_flags & SPECIAL))
+		{
+			StarShipPtr->ship_input_state |= SPECIAL;
+		}
+	}
+}
+
+static void
+acid_preprocess (ELEMENT *ElementPtr)
+{
+	COUNT facing;
+
+	facing = (GetFrameIndex (ElementPtr->next.image.frame)) % 16;
+	// JMS: Modulo 16 here ensures that the explosion frames are not used in wrong place.
+	
+	if (ElementPtr->thrust_wait == 1) // Left start.
+	{
+		--facing;
+		ElementPtr->turn_wait += 1;
+		ElementPtr->thrust_wait = 0;
+		ElementPtr->turn_wait = 3;
+	}
+
+	if (ElementPtr->thrust_wait == 2) // Right start.
+	{
+		++facing;
+		ElementPtr->turn_wait += 1;
+		ElementPtr->thrust_wait = 0;
+		ElementPtr->turn_wait = 0;
+	}
+
+	if (ElementPtr->thrust_wait == 0) // Main loop.
+	{
+		if (ElementPtr->turn_wait < 2) // Turn left.
+		{
+			--facing;
+			ElementPtr->turn_wait += 1;
+		} 
+		else if (ElementPtr->turn_wait < 3) // Wait.
+		{
+			ElementPtr->turn_wait += 1;
+		}
+		else if (ElementPtr->turn_wait < 5) // Turn right.
+		{
+			++facing;
+			ElementPtr->turn_wait += 1;
+		}
+		else if (ElementPtr->turn_wait < 6) // Wait.
+		{
+			ElementPtr->turn_wait += 1;
+		}
+		else if (ElementPtr->turn_wait == 6) // Wait and reset the loop.
+		{
+			ElementPtr->turn_wait = 0;
+		}
+	}
+
+	ElementPtr->next.image.frame = SetAbsFrameIndex (ElementPtr->next.image.frame, facing);
+	ElementPtr->state_flags |= CHANGING;
+	
+	SetVelocityVector (&ElementPtr->velocity, (MISSILE_SPEED << RESOLUTION_FACTOR), facing); // JMS_GFX
+}
+
+static COUNT
+initialize_acid (ELEMENT *ShipPtr, HELEMENT AcidArray[])
+{
+	STARSHIP *StarShipPtr;
+	MISSILE_BLOCK MissileBlock;
+
+	GetElementStarShip (ShipPtr, &StarShipPtr);
+	MissileBlock.cx = ShipPtr->next.location.x;
+	MissileBlock.cy = ShipPtr->next.location.y;
+	MissileBlock.farray = StarShipPtr->RaceDescPtr->ship_data.weapon;
+	MissileBlock.face = MissileBlock.index = StarShipPtr->ShipFacing;
+	MissileBlock.sender = ShipPtr->playerNr;
+	MissileBlock.flags = IGNORE_SIMILAR;
+	MissileBlock.pixoffs = LURG_OFFSET;
+	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.hit_points = MISSILE_HITS;
+	MissileBlock.damage = MISSILE_DAMAGE;
+	MissileBlock.life = MISSILE_LIFE;
+	MissileBlock.blast_offs = MISSILE_OFFSET;
+	MissileBlock.preprocess_func = acid_preprocess;
+
+	AcidArray[0] = initialize_missile (&MissileBlock);
+	
+	if (AcidArray[0])
+	{
+		ELEMENT *AcidPtr;
+
+		LockElement (AcidArray[0], &AcidPtr);
+		if ((BYTE)TFB_Random () & 1) // Left or right?
+			AcidPtr->thrust_wait = 1;
+		else
+			AcidPtr->thrust_wait = 2;
+		UnlockElement (AcidArray[0]);
+	}
+	
+	return (1);
+}
+
+static void
+oil_preprocess (ELEMENT *ElementPtr)
+{
+	BYTE thrust_wait, turn_wait;
+
+	thrust_wait = HINIBBLE (ElementPtr->turn_wait);
+	turn_wait = LONIBBLE (ElementPtr->turn_wait);
+
+	if (thrust_wait > 0)
+		--thrust_wait;
+	else
+	{
+		ElementPtr->next.image.frame =
+				IncFrameIndex (ElementPtr->current.image.frame);
+		ElementPtr->state_flags |= CHANGING;
+
+		thrust_wait = (BYTE)((COUNT)TFB_Random () & 7);
+	}
+
+	if (turn_wait > 0)
+		--turn_wait;
+	else
+	{
+		COUNT facing;
+
+		facing = (COUNT)TFB_Random ();
+
+		SetVelocityVector (&ElementPtr->velocity,
+				OIL_SPEED, facing);
+
+		turn_wait = 4;
+	}
+
+	ElementPtr->turn_wait = MAKE_BYTE (turn_wait, thrust_wait);
+}
+
+static void
+oil_collision (ELEMENT *ElementPtr0, POINT *pPt0, ELEMENT *ElementPtr1, POINT *pPt1)
+{
+	if (!(ElementPtr1->state_flags & (APPEARING | PLAYER_SHIP | FINITE_LIFE))
+	    && (ElementPtr1->playerNr == NEUTRAL_PLAYER_NUM)
+	    && !GRAVITY_MASS (ElementPtr1->mass_points))
+	{
+		ElementPtr0->mass_points = 0;
+		// Oil does no damage against asteroids
+	}
+	else if (!elementsOfSamePlayer(ElementPtr0, ElementPtr1))
+	{
+		STARSHIP *StarShipPtr;
+		STARSHIP *EnemyStarShipPtr;
+
+		GetElementStarShip (ElementPtr0, &StarShipPtr);
+		GetElementStarShip (ElementPtr1, &EnemyStarShipPtr);
+		
+		if (ElementPtr1->state_flags & PLAYER_SHIP)
+		{
+			COUNT facing;
+
+			ElementPtr1->thrust_wait += OIL_DELAY;
+			if (ElementPtr1->thrust_wait > OIL_DELAY_MAX)
+				ElementPtr1->thrust_wait = OIL_DELAY_MAX;
+			ElementPtr1->turn_wait += OIL_DELAY;
+			if (ElementPtr1->turn_wait > OIL_DELAY_MAX)
+				ElementPtr1->turn_wait = OIL_DELAY_MAX;
+
+			if(EnemyStarShipPtr->SpeciesID == SUPOX_ID)
+			{
+				EnemyStarShipPtr->special_counter += OIL_DELAY;
+				if (EnemyStarShipPtr->special_counter > OIL_DELAY_MAX)
+					EnemyStarShipPtr->special_counter = OIL_DELAY_MAX;
+			}
+				
+			
+			facing = NORMALIZE_FACING (
+				ANGLE_TO_FACING (GetVelocityTravelAngle (&ElementPtr1->velocity) + HALF_CIRCLE));
+		
+			DeltaVelocityComponents (&ElementPtr1->velocity,
+				COSINE (facing, OIL_SNARE),
+				SINE (facing, OIL_SNARE));
+
+			ElementPtr0->mass_points = 0;
+
+			// ProcessSound (SetAbsSoundIndex (
+					/* Sound effect?? */
+			// StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 1), ElementPtr0);
+		}
+		else
+		{
+			if (ElementPtr1->hit_points > 3)
+			{
+				SIZE xHits;
+				xHits = ElementPtr1->hit_points;
+				ElementPtr0->mass_points = (TFB_Random () & 3) == 1;
+				// Oil is ineffective against large projectiles
+			}
+			else
+				ElementPtr0->mass_points = 1;
+				// Do full, guaranteed damage against small projectiles
+		}
+	}
+
+	weapon_collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
+}
+
+static void spill_oil (ELEMENT *ShipPtr)
+{
+	STARSHIP *StarShipPtr;
+	MISSILE_BLOCK MissileBlock;
+	HELEMENT Missile;
+
+	GetElementStarShip (ShipPtr, &StarShipPtr);
+	MissileBlock.cx = ShipPtr->next.location.x;
+	MissileBlock.cy = ShipPtr->next.location.y;
+	MissileBlock.farray = StarShipPtr->RaceDescPtr->ship_data.special;
+	MissileBlock.face = (COUNT)TFB_Random (); // Deploy at random in every direction.
+	MissileBlock.index = 0;
+	MissileBlock.sender = ShipPtr->playerNr;
+	MissileBlock.flags = IGNORE_SIMILAR;
+	MissileBlock.pixoffs = LURG_OFFSET_2;
+	MissileBlock.life = OIL_LIFE + (TFB_Random () & OIL_LIFE_VARIATION);
+	MissileBlock.speed = OIL_INIT_SPEED;
+	MissileBlock.hit_points = OIL_HITS;
+	MissileBlock.damage = OIL_DAMAGE;
+	MissileBlock.preprocess_func = oil_preprocess;
+	MissileBlock.blast_offs = OIL_OFFSET;
+	Missile = initialize_missile (&MissileBlock);
+
+	if (Missile)
+	{
+		ELEMENT *OilPtr;
+
+		LockElement (Missile, &OilPtr);
+		// OilPtr->turn_wait affects how long the projectile travels at OIL_INIT_SPEED.
+		OilPtr->turn_wait = OIL_SPREAD_MINIMUM + ((COUNT)TFB_Random () & OIL_SPREAD_VARIATION);
+		SetElementStarShip (OilPtr, StarShipPtr);
+		OilPtr->collision_func = oil_collision;
+		UnlockElement (Missile);
+		PutElement (Missile);
+	}
+}
+
+static void
+lurg_postprocess (ELEMENT *ElementPtr)
+{
+	STARSHIP *StarShipPtr;
+
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+	
+	if ((StarShipPtr->cur_status_flags & SPECIAL)
+			&& StarShipPtr->special_counter == 0
+			&& DeltaEnergy (ElementPtr, -SPECIAL_ENERGY_COST))
+	{
+		int i;
+
+		ProcessSound (SetAbsSoundIndex // Spill oil.
+			(StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 1), ElementPtr);
+		
+		for (i = 0; i < OIL_BATCH_SIZE; i++)
+			spill_oil (ElementPtr);
+
+		StarShipPtr->special_counter = SPECIAL_WAIT;
+	}
+
+	// Start timer for passive regeneration when damaged.
+	if (ElementPtr->hit_points < MAX_CREW
+		&& StarShipPtr->auxiliary_counter == 0)
+	{
+		StarShipPtr->auxiliary_counter += REPAIR_WAIT;
+	}
+
+	// Slowly regenerate crew.
+	if (StarShipPtr->auxiliary_counter == 1
+			&& ElementPtr->hit_points > 0)
+	{
+		DeltaCrew (ElementPtr, 1);
+
+		ProcessSound (SetAbsSoundIndex // Regenerate.
+			(StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 2), ElementPtr);
+	}
+}
+
+RACE_DESC*
+init_lurg (void)
+{
+	RACE_DESC *RaceDescPtr;
+
+	if (RESOLUTION_FACTOR == 0)
+	{
+		lurg_desc.postprocess_func = lurg_postprocess;
+		lurg_desc.init_weapon_func = initialize_acid;
+		lurg_desc.cyborg_control.intelligence_func = lurg_intelligence;
+		RaceDescPtr = &lurg_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		lurg_desc_2xres.postprocess_func = lurg_postprocess;
+		lurg_desc_2xres.init_weapon_func = initialize_acid;
+		lurg_desc_2xres.cyborg_control.intelligence_func = lurg_intelligence;
+		RaceDescPtr = &lurg_desc_2xres;
+	}
+	else
+	{
+		lurg_desc_4xres.postprocess_func = lurg_postprocess;
+		lurg_desc_4xres.init_weapon_func = initialize_acid;
+		lurg_desc_4xres.cyborg_control.intelligence_func = lurg_intelligence;
+		RaceDescPtr = &lurg_desc_4xres;
+	}
+
+	return (RaceDescPtr);
+}
diff -ruNp src.orig/uqm/ships/lurg/lurg.h src/uqm/ships/lurg/lurg.h
--- src.orig/uqm/ships/lurg/lurg.h	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/lurg/lurg.h	2017-11-01 15:31:04 -0700
@@ -0,0 +1,23 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef LURG_H
+#define LURG_H
+
+RACE_DESC *init_lurg (void);
+
+#endif  /* LURG_H */
+
diff -ruNp src.orig/uqm/ships/lurg/resinst.h src/uqm/ships/lurg/resinst.h
--- src.orig/uqm/ships/lurg/resinst.h	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/lurg/resinst.h	2017-11-01 15:31:04 -0700
@@ -0,0 +1,17 @@
+#define LURGGOB_BIG_MASK_PMAP_ANIM "ship.lurg.graphics.gob.large"
+#define LURGGOB_MED_MASK_PMAP_ANIM "ship.lurg.graphics.gob.medium"
+#define LURGGOB_SML_MASK_PMAP_ANIM "ship.lurg.graphics.gob.small"
+#define LURG_BIG_MASK_PMAP_ANIM "ship.lurg.graphics.lurg.large"
+#define LURG_CAPTAIN_MASK_PMAP_ANIM "ship.lurg.graphics.captain"
+#define LURG_ICON_MASK_PMAP_ANIM "ship.lurg.icons"
+#define LURG_MED_MASK_PMAP_ANIM "ship.lurg.graphics.lurg.medium"
+#define LURG_MICON_MASK_PMAP_ANIM "ship.lurg.meleeicons"
+#define LURG_SML_MASK_PMAP_ANIM "ship.lurg.graphics.lurg.small"
+#define OIL_BIG_MASK_PMAP_ANIM "ship.lurg.graphics.oil.large"
+#define OIL_MED_MASK_PMAP_ANIM "ship.lurg.graphics.oil.medium"
+#define OIL_SML_MASK_PMAP_ANIM "ship.lurg.graphics.oil.small"
+#define LURG_RACE_STRINGS "ship.lurg.text"
+#define LURG_SHIP_SOUNDS "ship.lurg.sounds"
+#define LURG_VICTORY_SONG "ship.lurg.ditty"
+
+#include "icode.h"
diff -ruNp src.orig/uqm/ships/melnorme/icode.h src/uqm/ships/melnorme/icode.h
--- src.orig/uqm/ships/melnorme/icode.h	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/melnorme/icode.h	2017-11-01 15:31:04 -0700
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define MELNORME_CODE "ship.melnorme.code"
diff -ruNp src.orig/uqm/ships/melnorme/melnorme.c src/uqm/ships/melnorme/melnorme.c
--- src.orig/uqm/ships/melnorme/melnorme.c	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/melnorme/melnorme.c	2017-11-01 15:31:04 -0700
@@ -51,7 +51,7 @@ static RACE_DESC melnorme_desc =
 		MELNORME_RACE_STRINGS,
 		MELNORME_ICON_MASK_PMAP_ANIM,
 		MELNORME_MICON_MASK_PMAP_ANIM,
-		NULL, NULL, NULL
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
 	},
 	{ /* FLEET_STUFF */
 		INFINITE_RADIUS, /* Initial sphere of influence radius */
@@ -112,6 +112,160 @@ static RACE_DESC melnorme_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+#define MAX_THRUST_2XRES 72
+#define THRUST_INCREMENT_2XRES 12
+#define PUMPUP_SPEED_2XRES DISPLAY_TO_WORLD (90)
+
+// JMS_GFX
+static RACE_DESC melnorme_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		18, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		MELNORME_RACE_STRINGS,
+		MELNORME_ICON_MASK_PMAP_ANIM,
+		MELNORME_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		INFINITE_RADIUS, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			MAX_X_UNIVERSE >> 1, MAX_Y_UNIVERSE >> 1,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			MELNORME_BIG_MASK_PMAP_ANIM,
+			MELNORME_MED_MASK_PMAP_ANIM,
+			MELNORME_SML_MASK_PMAP_ANIM,
+		},
+		{
+			PUMPUP_BIG_MASK_PMAP_ANIM,
+			PUMPUP_MED_MASK_PMAP_ANIM,
+			PUMPUP_SML_MASK_PMAP_ANIM,
+		},
+		{
+			CONFUSE_BIG_MASK_PMAP_ANIM,
+			CONFUSE_MED_MASK_PMAP_ANIM,
+			CONFUSE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			MELNORME_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		MELNORME_VICTORY_SONG,
+		MELNORME_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		PUMPUP_SPEED_2XRES * PUMPUP_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 144
+#define THRUST_INCREMENT_4XRES 24
+#define PUMPUP_SPEED_4XRES DISPLAY_TO_WORLD (180)
+
+// JMS_GFX
+static RACE_DESC melnorme_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		18, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		MELNORME_RACE_STRINGS,
+		MELNORME_ICON_MASK_PMAP_ANIM,
+		MELNORME_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		INFINITE_RADIUS, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			MAX_X_UNIVERSE >> 1, MAX_Y_UNIVERSE >> 1,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			MELNORME_BIG_MASK_PMAP_ANIM,
+			MELNORME_MED_MASK_PMAP_ANIM,
+			MELNORME_SML_MASK_PMAP_ANIM,
+		},
+		{
+			PUMPUP_BIG_MASK_PMAP_ANIM,
+			PUMPUP_MED_MASK_PMAP_ANIM,
+			PUMPUP_SML_MASK_PMAP_ANIM,
+		},
+		{
+			CONFUSE_BIG_MASK_PMAP_ANIM,
+			CONFUSE_MED_MASK_PMAP_ANIM,
+			CONFUSE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			MELNORME_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		MELNORME_VICTORY_SONG,
+		MELNORME_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		PUMPUP_SPEED_4XRES * PUMPUP_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 #define NUM_PUMP_ANIMS 5
 #define REVERSE_DIR (BYTE)(1 << 7)
 
@@ -146,7 +300,7 @@ pump_up_preprocess (ELEMENT *ElementPtr)
 
 static COUNT initialize_pump_up (ELEMENT *ShipPtr, HELEMENT PumpUpArray[]);
 
-#define MELNORME_OFFSET 24
+#define MELNORME_OFFSET (24 << RESOLUTION_FACTOR) // JMS_GFX
 #define LEVEL_COUNTER 72
 #define MAX_PUMP 4
 #define PUMPUP_DAMAGE 2
@@ -232,8 +386,8 @@ pump_up_postprocess (ELEMENT *ElementPtr
 
 			angle = FACING_TO_ANGLE (StarShipPtr->ShipFacing);
 			SetVelocityComponents (&EPtr->velocity,
-					COSINE (angle, WORLD_TO_VELOCITY (PUMPUP_SPEED)),
-					SINE (angle, WORLD_TO_VELOCITY (PUMPUP_SPEED)));
+					COSINE (angle, WORLD_TO_VELOCITY (PUMPUP_SPEED << RESOLUTION_FACTOR)), // JMS_GFX
+					SINE (angle, WORLD_TO_VELOCITY (PUMPUP_SPEED << RESOLUTION_FACTOR))); // JMS_GFX
 
 			ProcessSound (SetAbsSoundIndex (
 					StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 3), EPtr);
@@ -474,11 +628,11 @@ confusion_collision (ELEMENT *ElementPtr
 static COUNT
 initialize_confusion (ELEMENT *ShipPtr, HELEMENT ConfusionArray[])
 {
-#define CMISSILE_SPEED DISPLAY_TO_WORLD (30)
+#define CMISSILE_SPEED DISPLAY_TO_WORLD (30 << RESOLUTION_FACTOR) // JMS_GFX
 #define CMISSILE_HITS 200
 #define CMISSILE_DAMAGE 0
 #define CMISSILE_LIFE 20
-#define CMISSILE_OFFSET 4
+#define CMISSILE_OFFSET (4 << RESOLUTION_FACTOR) // JMS_GFX
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK ConfusionBlock;
 
@@ -527,7 +681,7 @@ initialize_test_pump_up (ELEMENT *ShipPt
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = MELNORME_OFFSET;
-	MissileBlock.speed = PUMPUP_SPEED;
+	MissileBlock.speed = (PUMPUP_SPEED << RESOLUTION_FACTOR); // JMS_GFX
 	MissileBlock.hit_points = PUMPUP_DAMAGE;
 	MissileBlock.damage = PUMPUP_DAMAGE;
 	MissileBlock.life = PUMPUP_LIFE;
@@ -646,11 +800,27 @@ init_melnorme (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	melnorme_desc.postprocess_func = melnorme_postprocess;
-	melnorme_desc.init_weapon_func = initialize_pump_up;
-	melnorme_desc.cyborg_control.intelligence_func = melnorme_intelligence;
-
-	RaceDescPtr = &melnorme_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		melnorme_desc.postprocess_func = melnorme_postprocess;
+		melnorme_desc.init_weapon_func = initialize_pump_up;
+		melnorme_desc.cyborg_control.intelligence_func = melnorme_intelligence;
+		RaceDescPtr = &melnorme_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		melnorme_desc_2xres.postprocess_func = melnorme_postprocess;
+		melnorme_desc_2xres.init_weapon_func = initialize_pump_up;
+		melnorme_desc_2xres.cyborg_control.intelligence_func = melnorme_intelligence;
+		RaceDescPtr = &melnorme_desc_2xres;
+	}
+	else
+	{
+		melnorme_desc_4xres.postprocess_func = melnorme_postprocess;
+		melnorme_desc_4xres.init_weapon_func = initialize_pump_up;
+		melnorme_desc_4xres.cyborg_control.intelligence_func = melnorme_intelligence;
+		RaceDescPtr = &melnorme_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp src.orig/uqm/ships/mmrnmhrm/icode.h src/uqm/ships/mmrnmhrm/icode.h
--- src.orig/uqm/ships/mmrnmhrm/icode.h	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/mmrnmhrm/icode.h	2017-11-01 15:31:04 -0700
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define MMRNMHRM_CODE "ship.mmrnmhrm.code"
diff -ruNp src.orig/uqm/ships/mmrnmhrm/mmrnmhrm.c src/uqm/ships/mmrnmhrm/mmrnmhrm.c
--- src.orig/uqm/ships/mmrnmhrm/mmrnmhrm.c	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/mmrnmhrm/mmrnmhrm.c	2017-11-01 15:31:04 -0700
@@ -38,16 +38,16 @@
 #define YWING_WEAPON_ENERGY_COST 1
 #define YWING_SPECIAL_ENERGY_COST MAX_ENERGY
 #define YWING_ENERGY_WAIT 6
-#define YWING_MAX_THRUST 50
-#define YWING_THRUST_INCREMENT 10
+#define YWING_MAX_THRUST (50 << RESOLUTION_FACTOR) // JMS_GFX
+#define YWING_THRUST_INCREMENT (10 << RESOLUTION_FACTOR) // JMS_GFX
 #define YWING_TURN_WAIT 14
 #define YWING_THRUST_WAIT 0
 #define YWING_WEAPON_WAIT 20
 #define YWING_SPECIAL_WAIT 0
 
 #define SHIP_MASS 3
-#define MMRNMHRM_OFFSET 16
-#define LASER_RANGE DISPLAY_TO_WORLD (125 + MMRNMHRM_OFFSET)
+#define MMRNMHRM_OFFSET (16 << RESOLUTION_FACTOR) // JMS_GFX
+#define LASER_RANGE DISPLAY_TO_WORLD ((125 << RESOLUTION_FACTOR) + MMRNMHRM_OFFSET) // JMS_GFX
 
 
 static RACE_DESC mmrnmhrm_desc =
@@ -60,7 +60,7 @@ static RACE_DESC mmrnmhrm_desc =
 		MMRNMHRM_RACE_STRINGS,
 		MMRNMHRM_ICON_MASK_PMAP_ANIM,
 		MMRNMHRM_MICON_MASK_PMAP_ANIM,
-		NULL, NULL, NULL
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
 	},
 	{ /* FLEET_STUFF */
 		0, /* Initial sphere of influence radius */
@@ -121,7 +121,159 @@ static RACE_DESC mmrnmhrm_desc =
 	0, /* CodeRef */
 };
 
-#define MISSILE_SPEED DISPLAY_TO_WORLD (20)
+// JMS_GFX
+#define MAX_THRUST_2XRES 40
+#define THRUST_INCREMENT_2XRES 10
+
+// JMS_GFX
+static RACE_DESC mmrnmhrm_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | IMMEDIATE_WEAPON,
+		19, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		MMRNMHRM_RACE_STRINGS,
+		MMRNMHRM_ICON_MASK_PMAP_ANIM,
+		MMRNMHRM_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			MMRNMHRM_BIG_MASK_PMAP_ANIM,
+			MMRNMHRM_MED_MASK_PMAP_ANIM,
+			MMRNMHRM_SML_MASK_PMAP_ANIM,
+		},
+		{
+			TORP_BIG_MASK_PMAP_ANIM,
+			TORP_MED_MASK_PMAP_ANIM,
+			TORP_SML_MASK_PMAP_ANIM,
+		},
+		{
+			YWING_BIG_MASK_PMAP_ANIM,
+			YWING_MED_MASK_PMAP_ANIM,
+			YWING_SML_MASK_PMAP_ANIM,
+		},
+		{
+			MMRNMHRM_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		MMRNMHRM_VICTORY_SONG,
+		MMRNMHRM_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 80
+#define THRUST_INCREMENT_4XRES 20
+
+// JMS_GFX
+static RACE_DESC mmrnmhrm_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | IMMEDIATE_WEAPON,
+		19, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		MMRNMHRM_RACE_STRINGS,
+		MMRNMHRM_ICON_MASK_PMAP_ANIM,
+		MMRNMHRM_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			MMRNMHRM_BIG_MASK_PMAP_ANIM,
+			MMRNMHRM_MED_MASK_PMAP_ANIM,
+			MMRNMHRM_SML_MASK_PMAP_ANIM,
+		},
+		{
+			TORP_BIG_MASK_PMAP_ANIM,
+			TORP_MED_MASK_PMAP_ANIM,
+			TORP_SML_MASK_PMAP_ANIM,
+		},
+		{
+			YWING_BIG_MASK_PMAP_ANIM,
+			YWING_MED_MASK_PMAP_ANIM,
+			YWING_SML_MASK_PMAP_ANIM,
+		},
+		{
+			MMRNMHRM_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		MMRNMHRM_VICTORY_SONG,
+		MMRNMHRM_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+#define MISSILE_SPEED DISPLAY_TO_WORLD (20 << RESOLUTION_FACTOR) // JMS_GFX
 #define TRACK_WAIT 5
 
 static void
@@ -199,7 +351,7 @@ mmrnmhrm_intelligence (ELEMENT *ShipPtr,
 		{
 			if (lpEvalDesc->which_turn > 8)
 			{
-				if (MANEUVERABILITY (&EnemyStarShipPtr->RaceDescPtr->cyborg_control) <= SLOW_SHIP
+				if (MANEUVERABILITY (&EnemyStarShipPtr->RaceDescPtr->cyborg_control) <= (SLOW_SHIP << RESOLUTION_FACTOR) // JMS_GFX
 						|| NORMALIZE_ANGLE (
 								direction_angle - travel_angle + QUADRANT
 								) > HALF_CIRCLE)
@@ -253,7 +405,7 @@ twin_laser_collision (ELEMENT *ElementPt
 static COUNT
 initialize_dual_weapons (ELEMENT *ShipPtr, HELEMENT WeaponArray[])
 {
-#define CENTER_OFFS DISPLAY_TO_WORLD (4)
+#define CENTER_OFFS DISPLAY_TO_WORLD (4 << RESOLUTION_FACTOR) // JMS_GFX
 	COORD cx, cy;
 	COUNT facing, angle;
 	SIZE offs_x, offs_y;
@@ -267,7 +419,7 @@ initialize_dual_weapons (ELEMENT *ShipPt
 
 	if (ShipPtr->next.image.farray == StarShipPtr->RaceDescPtr->ship_data.ship)
 	{
-#define WING_OFFS DISPLAY_TO_WORLD (10)
+#define WING_OFFS DISPLAY_TO_WORLD (10 << RESOLUTION_FACTOR) // JMS_GFX
 		COORD ex, ey;
 		LASER_BLOCK LaserBlock;
 		ELEMENT *LaserPtr;
@@ -311,7 +463,7 @@ initialize_dual_weapons (ELEMENT *ShipPt
 #define MISSILE_DAMAGE 1
 #define MISSILE_OFFSET 0
 #define MISSILE_LIFE 40
-#define LAUNCH_OFFS DISPLAY_TO_WORLD (4)
+#define LAUNCH_OFFS DISPLAY_TO_WORLD (4 << RESOLUTION_FACTOR) // JMS_GFX
 		MISSILE_BLOCK TorpBlock;
 		ELEMENT *TorpPtr;
 
@@ -373,8 +525,7 @@ mmrnmhrm_postprocess (ELEMENT *ElementPt
 		StarShipPtr->weapon_counter = 0;
 
 		/* Swap characteristics descriptors around */
-		otherwing_desc = (CHARACTERISTIC_STUFF *)
-				StarShipPtr->RaceDescPtr->data;
+		otherwing_desc = (CHARACTERISTIC_STUFF *)StarShipPtr->RaceDescPtr->data;
 		t = *otherwing_desc;
 		*otherwing_desc = StarShipPtr->RaceDescPtr->characteristics;
 		StarShipPtr->RaceDescPtr->characteristics = t;
@@ -382,7 +533,7 @@ mmrnmhrm_postprocess (ELEMENT *ElementPt
 
 		if (ElementPtr->next.image.farray == StarShipPtr->RaceDescPtr->ship_data.special)
 		{
-			StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = LONG_RANGE_WEAPON - 1;
+			StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = (LONG_RANGE_WEAPON - 1) << RESOLUTION_FACTOR; // JMS_GFX
 			StarShipPtr->RaceDescPtr->ship_info.ship_flags &= ~IMMEDIATE_WEAPON;
 			StarShipPtr->RaceDescPtr->ship_info.ship_flags |= SEEKING_WEAPON;
 			StarShipPtr->RaceDescPtr->ship_data.ship_sounds =
@@ -393,7 +544,7 @@ mmrnmhrm_postprocess (ELEMENT *ElementPt
 		}
 		else
 		{
-			StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = CLOSE_RANGE_WEAPON;
+			StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = CLOSE_RANGE_WEAPON << RESOLUTION_FACTOR; // JMS_GFX
 			StarShipPtr->RaceDescPtr->ship_info.ship_flags &= ~SEEKING_WEAPON;
 			StarShipPtr->RaceDescPtr->ship_info.ship_flags |= IMMEDIATE_WEAPON;
 			StarShipPtr->RaceDescPtr->ship_data.ship_sounds =
@@ -420,8 +571,7 @@ mmrnmhrm_preprocess (ELEMENT *ElementPtr
 				&& StarShipPtr->special_counter == 0)
 		{
 			/* Either we transform or text will flash */
-			if (DeltaEnergy (ElementPtr,
-					-StarShipPtr->RaceDescPtr->characteristics.special_energy_cost))
+			if (DeltaEnergy (ElementPtr, -StarShipPtr->RaceDescPtr->characteristics.special_energy_cost))
 			{
 				if (ElementPtr->next.image.farray == StarShipPtr->RaceDescPtr->ship_data.ship)
 					ElementPtr->next.image.farray =
@@ -452,18 +602,37 @@ RACE_DESC*
 init_mmrnmhrm (void)
 {
 	RACE_DESC *RaceDescPtr;
-
 	static RACE_DESC new_mmrnmhrm_desc;
 	CHARACTERISTIC_STUFF *otherwing_desc;
-
-	mmrnmhrm_desc.uninit_func = uninit_mmrnmhrm;
-	mmrnmhrm_desc.preprocess_func = mmrnmhrm_preprocess;
-	mmrnmhrm_desc.postprocess_func = mmrnmhrm_postprocess;
-	mmrnmhrm_desc.init_weapon_func = initialize_dual_weapons;
-	mmrnmhrm_desc.cyborg_control.intelligence_func = mmrnmhrm_intelligence;
-
-	new_mmrnmhrm_desc = mmrnmhrm_desc;
-
+	
+	if (RESOLUTION_FACTOR == 0)
+	{
+		mmrnmhrm_desc.uninit_func = uninit_mmrnmhrm;
+		mmrnmhrm_desc.preprocess_func = mmrnmhrm_preprocess;
+		mmrnmhrm_desc.postprocess_func = mmrnmhrm_postprocess;
+		mmrnmhrm_desc.init_weapon_func = initialize_dual_weapons;
+		mmrnmhrm_desc.cyborg_control.intelligence_func = mmrnmhrm_intelligence;
+		new_mmrnmhrm_desc = mmrnmhrm_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		mmrnmhrm_desc_2xres.uninit_func = uninit_mmrnmhrm;
+		mmrnmhrm_desc_2xres.preprocess_func = mmrnmhrm_preprocess;
+		mmrnmhrm_desc_2xres.postprocess_func = mmrnmhrm_postprocess;
+		mmrnmhrm_desc_2xres.init_weapon_func = initialize_dual_weapons;
+		mmrnmhrm_desc_2xres.cyborg_control.intelligence_func = mmrnmhrm_intelligence;
+		new_mmrnmhrm_desc = mmrnmhrm_desc_2xres;
+	}
+	else
+	{
+		mmrnmhrm_desc_4xres.uninit_func = uninit_mmrnmhrm;
+		mmrnmhrm_desc_4xres.preprocess_func = mmrnmhrm_preprocess;
+		mmrnmhrm_desc_4xres.postprocess_func = mmrnmhrm_postprocess;
+		mmrnmhrm_desc_4xres.init_weapon_func = initialize_dual_weapons;
+		mmrnmhrm_desc_4xres.cyborg_control.intelligence_func = mmrnmhrm_intelligence;
+		new_mmrnmhrm_desc = mmrnmhrm_desc_4xres;
+	}
+	
 	otherwing_desc = HMalloc (sizeof (*otherwing_desc));
 	otherwing_desc->max_thrust = YWING_MAX_THRUST;
 	otherwing_desc->thrust_increment = YWING_THRUST_INCREMENT;
@@ -476,9 +645,8 @@ init_mmrnmhrm (void)
 	otherwing_desc->weapon_wait = YWING_WEAPON_WAIT;
 	otherwing_desc->special_wait = YWING_SPECIAL_WAIT;
 	otherwing_desc->ship_mass = SHIP_MASS;
-
 	new_mmrnmhrm_desc.data = (intptr_t) otherwing_desc;
-
+	
 	RaceDescPtr = &new_mmrnmhrm_desc;
 
 	return (RaceDescPtr);
diff -ruNp src.orig/uqm/ships/mycon/icode.h src/uqm/ships/mycon/icode.h
--- src.orig/uqm/ships/mycon/icode.h	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/mycon/icode.h	2017-11-01 15:31:04 -0700
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define MYCON_CODE "ship.mycon.code"
diff -ruNp src.orig/uqm/ships/mycon/mycon.c src/uqm/ships/mycon/mycon.c
--- src.orig/uqm/ships/mycon/mycon.c	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/mycon/mycon.c	2017-11-01 15:31:04 -0700
@@ -39,7 +39,7 @@
 #define NUM_GLOBALLS 8
 #define PLASMA_DURATION 13
 #define MISSILE_LIFE (NUM_PLASMAS * PLASMA_DURATION)
-#define MISSILE_SPEED DISPLAY_TO_WORLD (8)
+#define MISSILE_SPEED DISPLAY_TO_WORLD (8 << RESOLUTION_FACTOR) // JMS_GFX
 
 static RACE_DESC mycon_desc =
 {
@@ -51,12 +51,12 @@ static RACE_DESC mycon_desc =
 		MYCON_RACE_STRINGS,
 		MYCON_ICON_MASK_PMAP_ANIM,
 		MYCON_MICON_MASK_PMAP_ANIM,
-		NULL, NULL, NULL
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
 	},
 	{ /* FLEET_STUFF */
-		1070 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		0, /* Initial SoI radius */
 		{ /* Known location (center of SoI) */
-			6392, 2200,
+			0,0,
 		},
 	},
 	{
@@ -112,8 +112,159 @@ static RACE_DESC mycon_desc =
 	0, /* CodeRef */
 };
 
-#define MISSILE_DAMAGE 10
+// JMS_GFX
+#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (14) */ 54
+#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (4) */ 18
 
+// JMS_GFX
+static RACE_DESC mycon_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_WEAPON,
+		21, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		MYCON_RACE_STRINGS,
+		MYCON_ICON_MASK_PMAP_ANIM,
+		MYCON_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			0,0,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			MYCON_BIG_MASK_PMAP_ANIM,
+			MYCON_MED_MASK_PMAP_ANIM,
+			MYCON_SML_MASK_PMAP_ANIM,
+		},
+		{
+			PLASMA_BIG_MASK_PMAP_ANIM,
+			PLASMA_MED_MASK_PMAP_ANIM,
+			PLASMA_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			MYCON_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		MYCON_VICTORY_SONG,
+		MYCON_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		DISPLAY_TO_WORLD (1600),
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (28) */ 108
+#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (8) */ 36
+
+// JMS_GFX
+static RACE_DESC mycon_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_WEAPON,
+		21, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		MYCON_RACE_STRINGS,
+		MYCON_ICON_MASK_PMAP_ANIM,
+		MYCON_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			0,0,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			MYCON_BIG_MASK_PMAP_ANIM,
+			MYCON_MED_MASK_PMAP_ANIM,
+			MYCON_SML_MASK_PMAP_ANIM,
+		},
+		{
+			PLASMA_BIG_MASK_PMAP_ANIM,
+			PLASMA_MED_MASK_PMAP_ANIM,
+			PLASMA_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			MYCON_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		MYCON_VICTORY_SONG,
+		MYCON_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		DISPLAY_TO_WORLD (3200),
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+#define MISSILE_DAMAGE 10
 #define TRACK_WAIT 1
 
 static void
@@ -124,16 +275,14 @@ plasma_preprocess (ELEMENT *ElementPtr)
 	if (ElementPtr->mass_points > ElementPtr->hit_points)
 		ElementPtr->life_span = ElementPtr->hit_points * PLASMA_DURATION;
 	else
-		ElementPtr->hit_points = (BYTE)((ElementPtr->life_span *
-				MISSILE_DAMAGE + (MISSILE_LIFE - 1)) / MISSILE_LIFE);
+		ElementPtr->hit_points = (BYTE)((ElementPtr->life_span * MISSILE_DAMAGE + (MISSILE_LIFE - 1)) / MISSILE_LIFE);
+	
 	ElementPtr->mass_points = ElementPtr->hit_points;
-	plasma_index = NUM_PLASMAS - ((ElementPtr->life_span +
-			(PLASMA_DURATION - 1)) / PLASMA_DURATION);
+	plasma_index = NUM_PLASMAS - ((ElementPtr->life_span + (PLASMA_DURATION - 1)) / PLASMA_DURATION);
+	
 	if (plasma_index != GetFrameIndex (ElementPtr->next.image.frame))
 	{
-		ElementPtr->next.image.frame =
-				SetAbsFrameIndex (ElementPtr->next.image.frame,
-				plasma_index);
+		ElementPtr->next.image.frame = SetAbsFrameIndex (ElementPtr->next.image.frame, plasma_index);
 		ElementPtr->state_flags |= CHANGING;
 	}
 
@@ -143,12 +292,10 @@ plasma_preprocess (ELEMENT *ElementPtr)
 	{
 		COUNT facing;
 
-		facing = NORMALIZE_FACING (ANGLE_TO_FACING (
-				GetVelocityTravelAngle (&ElementPtr->velocity)
-				));
+		facing = NORMALIZE_FACING (ANGLE_TO_FACING ( GetVelocityTravelAngle (&ElementPtr->velocity)));
+		
 		if (TrackShip (ElementPtr, &facing) > 0)
-			SetVelocityVector (&ElementPtr->velocity,
-					MISSILE_SPEED, facing);
+			SetVelocityVector (&ElementPtr->velocity, MISSILE_SPEED, facing);
 
 		ElementPtr->turn_wait = TRACK_WAIT;
 	}
@@ -283,7 +430,7 @@ mycon_intelligence (ELEMENT *ShipPtr, EV
 	if (StarShipPtr->special_counter == 0)
 	{
 		StarShipPtr->ship_input_state &= ~SPECIAL;
-		StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = DISPLAY_TO_WORLD (800);
+		StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = DISPLAY_TO_WORLD (800 << RESOLUTION_FACTOR); // JMS_GFX
 		if (ShipPtr->crew_level < StarShipPtr->RaceDescPtr->ship_info.max_crew)
 		{
 			StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = MISSILE_SPEED * MISSILE_LIFE;
@@ -297,7 +444,7 @@ mycon_intelligence (ELEMENT *ShipPtr, EV
 static COUNT
 initialize_plasma (ELEMENT *ShipPtr, HELEMENT PlasmaArray[])
 {
-#define MYCON_OFFSET 24
+#define MYCON_OFFSET (24 << RESOLUTION_FACTOR) // JMS_GFX
 #define MISSILE_OFFSET 0
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
@@ -364,11 +511,27 @@ init_mycon (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	mycon_desc.postprocess_func = mycon_postprocess;
-	mycon_desc.init_weapon_func = initialize_plasma;
-	mycon_desc.cyborg_control.intelligence_func = mycon_intelligence;
-
-	RaceDescPtr = &mycon_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		mycon_desc.postprocess_func = mycon_postprocess;
+		mycon_desc.init_weapon_func = initialize_plasma;
+		mycon_desc.cyborg_control.intelligence_func = mycon_intelligence;
+		RaceDescPtr = &mycon_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		mycon_desc_2xres.postprocess_func = mycon_postprocess;
+		mycon_desc_2xres.init_weapon_func = initialize_plasma;
+		mycon_desc_2xres.cyborg_control.intelligence_func = mycon_intelligence;
+		RaceDescPtr = &mycon_desc_2xres;
+	}
+	else
+	{
+		mycon_desc_4xres.postprocess_func = mycon_postprocess;
+		mycon_desc_4xres.init_weapon_func = initialize_plasma;
+		mycon_desc_4xres.cyborg_control.intelligence_func = mycon_intelligence;
+		RaceDescPtr = &mycon_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp src.orig/uqm/ships/orz/icode.h src/uqm/ships/orz/icode.h
--- src.orig/uqm/ships/orz/icode.h	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/orz/icode.h	2017-11-01 15:31:04 -0700
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define ORZ_CODE "ship.orz.code"
diff -ruNp src.orig/uqm/ships/orz/orz.c src/uqm/ships/orz/orz.c
--- src.orig/uqm/ships/orz/orz.c	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/orz/orz.c	2017-11-01 15:31:04 -0700
@@ -53,12 +53,12 @@ static RACE_DESC orz_desc =
 		ORZ_RACE_STRINGS,
 		ORZ_ICON_MASK_PMAP_ANIM,
 		ORZ_MICON_MASK_PMAP_ANIM,
-		NULL, NULL, NULL
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
 	},
 	{ /* FLEET_STUFF */
-		333 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		350 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
 		{ /* Known location (center of SoI) */
-			3608, 2637,
+			8587,8566,
 		},
 	},
 	{
@@ -114,6 +114,160 @@ static RACE_DESC orz_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+#define MAX_THRUST_2XRES 70
+#define THRUST_INCREMENT_2XRES 10
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
+
+// JMS_GFX
+static RACE_DESC orz_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_SPECIAL,
+		23, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ORZ_RACE_STRINGS,
+		ORZ_ICON_MASK_PMAP_ANIM,
+		ORZ_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		350 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			8587,8566,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ORZ_BIG_MASK_PMAP_ANIM,
+			ORZ_MED_MASK_PMAP_ANIM,
+			ORZ_SML_MASK_PMAP_ANIM,
+		},
+		{
+			HOWITZER_BIG_MASK_PMAP_ANIM,
+			HOWITZER_MED_MASK_PMAP_ANIM,
+			HOWITZER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			TURRET_BIG_MASK_PMAP_ANIM,
+			TURRET_MED_MASK_PMAP_ANIM,
+			TURRET_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ORZ_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ORZ_VICTORY_SONG,
+		ORZ_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_SPEED_2XRES * MISSILE_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 140
+#define THRUST_INCREMENT_4XRES 20
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
+
+// JMS_GFX
+static RACE_DESC orz_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_SPECIAL,
+		23, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ORZ_RACE_STRINGS,
+		ORZ_ICON_MASK_PMAP_ANIM,
+		ORZ_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		350 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			8587,8566,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ORZ_BIG_MASK_PMAP_ANIM,
+			ORZ_MED_MASK_PMAP_ANIM,
+			ORZ_SML_MASK_PMAP_ANIM,
+		},
+		{
+			HOWITZER_BIG_MASK_PMAP_ANIM,
+			HOWITZER_MED_MASK_PMAP_ANIM,
+			HOWITZER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			TURRET_BIG_MASK_PMAP_ANIM,
+			TURRET_MED_MASK_PMAP_ANIM,
+			TURRET_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ORZ_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ORZ_VICTORY_SONG,
+		ORZ_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_SPEED_4XRES * MISSILE_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static void
 howitzer_collision (ELEMENT *ElementPtr0, POINT *pPt0,
 		ELEMENT *ElementPtr1, POINT *pPt1)
@@ -122,7 +276,7 @@ howitzer_collision (ELEMENT *ElementPtr0
 		weapon_collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
 }
 
-#define TURRET_OFFSET 14
+#define TURRET_OFFSET (14 << RESOLUTION_FACTOR) // JMS_GFX
 #define TURRET_WAIT 3
 
 static COUNT
@@ -130,7 +284,7 @@ initialize_turret_missile (ELEMENT *Ship
 {
 #define MISSILE_HITS 2
 #define MISSILE_DAMAGE 3
-#define MISSILE_OFFSET 1
+#define MISSILE_OFFSET (1 << RESOLUTION_FACTOR) // JMS_GFX
 	ELEMENT *TurretPtr;
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
@@ -160,7 +314,7 @@ initialize_turret_missile (ELEMENT *Ship
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = TURRET_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -229,8 +383,7 @@ count_marines (STARSHIP *StarShipPtr, BO
 }
 
 static void
-orz_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
-		COUNT ConcernCounter)
+orz_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern, COUNT ConcernCounter)
 {
 	ELEMENT *TurretPtr;
 	STARSHIP *StarShipPtr;
@@ -295,8 +448,7 @@ orz_intelligence (ELEMENT *ShipPtr, EVAL
 				&& !(StarShipPtr->ship_input_state & WEAPON)
 				&& StarShipPtr->RaceDescPtr->ship_info.crew_level >
 				(BYTE)(StarShipPtr->RaceDescPtr->ship_info.max_crew >> 2)
-				&& !(EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags
-				& POINT_DEFENSE)
+				&& !(EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags & HEAVY_POINT_DEFENSE)
 				&& (MANEUVERABILITY (
 						&EnemyStarShipPtr->RaceDescPtr->cyborg_control
 						) < SLOW_SHIP
@@ -363,10 +515,8 @@ intruder_preprocess (ELEMENT *ElementPtr
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	LockElement (StarShipPtr->hShip, &ShipPtr);
-	if (ShipPtr->crew_level == 0
-			&& ShipPtr->life_span == 1
-			&& (ShipPtr->state_flags & (FINITE_LIFE | NONSOLID)) ==
-			(FINITE_LIFE | NONSOLID))
+	if (ShipPtr->crew_level == 0 && ShipPtr->life_span == 1
+		&& (ShipPtr->state_flags & (FINITE_LIFE | NONSOLID)) == (FINITE_LIFE | NONSOLID))
 	{
 		ElementPtr->life_span = 0;
 		ElementPtr->state_flags |= DISAPPEARING;
@@ -388,23 +538,37 @@ intruder_preprocess (ELEMENT *ElementPtr
 			{
 				--ElementPtr->thrust_wait;
 
-				s.origin.x = 16 + (ElementPtr->turn_wait & 3) * 9;
-				s.origin.y = 14 + (ElementPtr->turn_wait >> 2) * 11;
-				s.frame = SetAbsFrameIndex (ElementPtr->next.image.farray[0],
-						GetFrameCount (ElementPtr->next.image.farray[0]) - 2);
+				if (RESOLUTION_FACTOR < 2)
+				{
+					s.origin.x = (16 << RESOLUTION_FACTOR) + (ElementPtr->turn_wait & 3) * ((9 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
+					s.origin.y = (14 << RESOLUTION_FACTOR) + (ElementPtr->turn_wait >> 2) * ((11 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
+				}
+				else
+				{
+					s.origin.x = (16 - (RESOLUTION_FACTOR * 3 / 2) + (ElementPtr->turn_wait & 3) * (9 + RESOLUTION_FACTOR * 3 / 2)) << RESOLUTION_FACTOR; // JMS_GFX
+					s.origin.y = (14 + (ElementPtr->turn_wait >> 2) * (11 + RESOLUTION_FACTOR)) << RESOLUTION_FACTOR; // JMS_GFX
+				}
+				s.frame = SetAbsFrameIndex (ElementPtr->next.image.farray[0], GetFrameCount (ElementPtr->next.image.farray[0]) - 2);
 				ModifySilhouette (ShipPtr, &s, 0);
 			}
 
 			ElementPtr->next.location = ShipPtr->next.location;
 
-			if (ShipPtr->crew_level == 0
-					|| ElementPtr->life_span == 0)
+			if (ShipPtr->crew_level == 0 || ElementPtr->life_span == 0)
 			{
 				UnlockElement (hElement);
 				hElement = 0;
 LeftShip:
-				s.origin.x = 16 + (ElementPtr->turn_wait & 3) * 9;
-				s.origin.y = 14 + (ElementPtr->turn_wait >> 2) * 11;
+				if (RESOLUTION_FACTOR < 2)
+				{
+					s.origin.x = (16 << RESOLUTION_FACTOR) + (ElementPtr->turn_wait & 3) * ((9 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
+					s.origin.y = (14 << RESOLUTION_FACTOR) + (ElementPtr->turn_wait >> 2) * ((11 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
+				}
+				else
+				{
+					s.origin.x = (16 - (RESOLUTION_FACTOR * 3 / 2) + (ElementPtr->turn_wait & 3) * (9 + RESOLUTION_FACTOR * 3 / 2)) << RESOLUTION_FACTOR; // JMS_GFX
+					s.origin.y = (14 + (ElementPtr->turn_wait >> 2) * (11 + RESOLUTION_FACTOR)) << RESOLUTION_FACTOR; // JMS_GFX
+				}
 				s.frame = ElementPtr->next.image.frame;
 				ModifySilhouette (ShipPtr, &s, MODIFY_SWAP);
 			}
@@ -420,8 +584,7 @@ LeftShip:
 					ElementPtr->life_span = 0;
 					ElementPtr->state_flags |= DISAPPEARING;
 
-					ProcessSound (SetAbsSoundIndex (
-							StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 4), ElementPtr);
+					ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 4), ElementPtr);
 					goto LeftShip;
 				}
 				else if (randval < (0x0100 / 2 + 0x0100 / 16))
@@ -430,13 +593,19 @@ LeftShip:
 						ShipPtr->life_span = 0;
 
 					++ElementPtr->thrust_wait;
-					s.origin.x = 16 + (ElementPtr->turn_wait & 3) * 9;
-					s.origin.y = 14 + (ElementPtr->turn_wait >> 2) * 11;
-					s.frame = SetAbsFrameIndex (ElementPtr->next.image.farray[0],
-							GetFrameCount (ElementPtr->next.image.farray[0]) - 1);
+					if (RESOLUTION_FACTOR < 2)
+					{
+						s.origin.x = (16 << RESOLUTION_FACTOR) + (ElementPtr->turn_wait & 3) * ((9 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
+						s.origin.y = (14 << RESOLUTION_FACTOR) + (ElementPtr->turn_wait >> 2) * ((11 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
+					}
+					else
+					{
+						s.origin.x = (16 - (RESOLUTION_FACTOR * 3 / 2) + (ElementPtr->turn_wait & 3) * (9 + RESOLUTION_FACTOR * 3 / 2)) << RESOLUTION_FACTOR; // JMS_GFX
+						s.origin.y = (14 + (ElementPtr->turn_wait >> 2) * (11 + RESOLUTION_FACTOR)) << RESOLUTION_FACTOR; // JMS_GFX
+					}
+					s.frame = SetAbsFrameIndex (ElementPtr->next.image.farray[0], GetFrameCount (ElementPtr->next.image.farray[0]) - 1);
 					ModifySilhouette (ShipPtr, &s, 0);
-					ProcessSound (SetAbsSoundIndex (
-							StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 3), ElementPtr);
+					ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 3), ElementPtr);
 				}
 			}
 
@@ -451,8 +620,7 @@ LeftShip:
 	{
 		ElementPtr->state_flags &= ~NONSOLID;
 		ElementPtr->state_flags |= CHANGING | CREW_OBJECT;
-		SetPrimType (&(GLOBAL (DisplayArray))[ElementPtr->PrimIndex],
-				STAMP_PRIM);
+		SetPrimType (&(GLOBAL (DisplayArray))[ElementPtr->PrimIndex], STAMP_PRIM);
 
 		ElementPtr->current.image.frame =
 				ElementPtr->next.image.frame =
@@ -496,10 +664,8 @@ spawn_marine_ion_trail (ELEMENT *Element
 				START_ION_COLOR);
 		IonElementPtr->colorCycleIndex = 0;
 		IonElementPtr->current.location = ElementPtr->current.location;
-		IonElementPtr->current.location.x +=
-				(COORD)COSINE (angle, DISPLAY_TO_WORLD (2));
-		IonElementPtr->current.location.y +=
-				(COORD)SINE (angle, DISPLAY_TO_WORLD (2));
+		IonElementPtr->current.location.x += (COORD)COSINE (angle, DISPLAY_TO_WORLD (2 << RESOLUTION_FACTOR)); // JMS_GFX
+		IonElementPtr->current.location.y += (COORD)SINE (angle, DISPLAY_TO_WORLD (2 << RESOLUTION_FACTOR));   // JMS_GFX
 		IonElementPtr->death_func = ion_preprocess;
 
 		SetElementStarShip (IonElementPtr, StarShipPtr);
@@ -542,7 +708,7 @@ marine_preprocess (ELEMENT *ElementPtr)
 	else
 	{
 		COUNT facing, pfacing = 0;
-		SIZE delta_x, delta_y, delta_facing;
+		SDWORD delta_x, delta_y, delta_facing;
 		HELEMENT hObject, hNextObject, hTarget;
 		ELEMENT *ObjectPtr;
 
@@ -551,25 +717,25 @@ marine_preprocess (ELEMENT *ElementPtr)
 		ElementPtr->thrust_wait &= ~(SHIP_IN_GRAVITY_WELL >> 6);
 
 		hTarget = 0;
-		for (hObject = GetHeadElement ();
-				hObject; hObject = hNextObject)
+		for (hObject = GetHeadElement (); hObject; hObject = hNextObject)
 		{
 			LockElement (hObject, &ObjectPtr);
 			hNextObject = GetSuccElement (ObjectPtr);
+			
+			// Accelerate near planet.
 			if (GRAVITY_MASS (ObjectPtr->mass_points))
 			{
-				delta_x = ObjectPtr->current.location.x
-						- ElementPtr->current.location.x;
+				delta_x = (SDWORD)ObjectPtr->current.location.x - (SDWORD)ElementPtr->current.location.x;
 				delta_x = WRAP_DELTA_X (delta_x);
 
-				delta_y = ObjectPtr->current.location.y
-						- ElementPtr->current.location.y;
+				delta_y = (SDWORD)ObjectPtr->current.location.y - (SDWORD)ElementPtr->current.location.y;
 				delta_y = WRAP_DELTA_Y (delta_y);
+				
 				if ((long)delta_x * delta_x + (long)delta_y * delta_y <=
 						(long)(DISPLAY_TO_WORLD (GRAVITY_THRESHOLD)
 						* DISPLAY_TO_WORLD (GRAVITY_THRESHOLD)))
 				{
-					pfacing = ANGLE_TO_FACING (ARCTAN (delta_x, delta_y));
+					pfacing = ANGLE_TO_FACING (ARCTAN ((SIZE)delta_x, (SIZE)delta_y));
 					delta_facing = NORMALIZE_FACING (
 							pfacing - ANGLE_TO_FACING (
 							GetVelocityTravelAngle (&ElementPtr->velocity))
@@ -583,6 +749,8 @@ marine_preprocess (ELEMENT *ElementPtr)
 					ElementPtr->thrust_wait |= (SHIP_IN_GRAVITY_WELL >> 6);
 				}
 			}
+			
+			// Enemy ship. If it's alive and not cloaked, choose it as a target.
 			else if ((ObjectPtr->state_flags & PLAYER_SHIP)
 					&& ObjectPtr->crew_level
 					&& !OBJECT_CLOAKED (ObjectPtr))
@@ -599,21 +767,23 @@ marine_preprocess (ELEMENT *ElementPtr)
 		}
 
 		facing = HINIBBLE (ElementPtr->turn_wait);
+		
+		// There was no ship available to chase.
 		if (hTarget == 0)
 			delta_facing = -1;
+		
 		else
 		{
 			LockElement (hTarget, &ObjectPtr);
-			delta_x = ObjectPtr->current.location.x
-					- ElementPtr->current.location.x;
+			delta_x = (SDWORD)ObjectPtr->current.location.x - (SDWORD)ElementPtr->current.location.x;
 			delta_x = WRAP_DELTA_X (delta_x);
-			delta_y = ObjectPtr->current.location.y
-					- ElementPtr->current.location.y;
+			delta_y = (SDWORD)ObjectPtr->current.location.y - (SDWORD)ElementPtr->current.location.y;
 			delta_y = WRAP_DELTA_Y (delta_y);
+			
+			// ? Something to do with the planet.
 			if (GRAVITY_MASS (ObjectPtr->mass_points))
 			{
-				delta_facing = NORMALIZE_FACING (pfacing - facing
-						+ ANGLE_TO_FACING (OCTANT));
+				delta_facing = NORMALIZE_FACING (pfacing - facing + ANGLE_TO_FACING (OCTANT));
 
 				if (delta_facing > ANGLE_TO_FACING (QUADRANT))
 					delta_facing = 0;
@@ -627,38 +797,33 @@ marine_preprocess (ELEMENT *ElementPtr)
 						--facing;
 				}
 			}
+			
+			// Chase the enemy ship.
 			else
 			{
-				COUNT num_frames;
+				DWORD num_frames; // JMS_GFX: Was COUNT
 				VELOCITY_DESC ShipVelocity;
 
-				if (elementsOfSamePlayer (ObjectPtr, ElementPtr)
-						&& (ElementPtr->state_flags & IGNORE_SIMILAR))
+				if (elementsOfSamePlayer (ObjectPtr, ElementPtr) && (ElementPtr->state_flags & IGNORE_SIMILAR))
 				{
-					ElementPtr->next.image.frame = SetAbsFrameIndex (
-							StarShipPtr->RaceDescPtr->ship_data.special[0],
-							21);
+					ElementPtr->next.image.frame = SetAbsFrameIndex (StarShipPtr->RaceDescPtr->ship_data.special[0],21);
 					ElementPtr->state_flags &= ~IGNORE_SIMILAR;
 					ElementPtr->state_flags |= CHANGING;
 				}
 
-				num_frames = WORLD_TO_TURN (
-						square_root ((long)delta_x * delta_x
-						+ (long)delta_y * delta_y));
+				num_frames = (WORLD_TO_TURN (square_root ((long)delta_x * delta_x + (long)delta_y * delta_y))) >> RESOLUTION_FACTOR; // JMS_GFX
+				
 				if (num_frames == 0)
 					num_frames = 1;
 
 				ShipVelocity = ObjectPtr->velocity;
-				GetNextVelocityComponents (&ShipVelocity,
-						&delta_x, &delta_y, num_frames);
+				GetNextVelocityComponentsSdword (&ShipVelocity, &delta_x, &delta_y, num_frames);
 
-				delta_x = (ObjectPtr->current.location.x + delta_x)
-						- ElementPtr->current.location.x;
-				delta_y = (ObjectPtr->current.location.y + delta_y)
-						- ElementPtr->current.location.y;
+				// JMS_GFX: Made the calculations use SDWORD to avoid overflows.
+				delta_x = ((SDWORD)ObjectPtr->current.location.x + delta_x) - (SDWORD)ElementPtr->current.location.x;
+				delta_y = ((SDWORD)ObjectPtr->current.location.y + delta_y) - (SDWORD)ElementPtr->current.location.y;
 
-				delta_facing = NORMALIZE_FACING (
-						ANGLE_TO_FACING (ARCTAN (delta_x, delta_y)) - facing);
+				delta_facing = NORMALIZE_FACING (ANGLE_TO_FACING (ARCTAN ((SIZE)delta_x, (SIZE)delta_y)) - facing);
 
 				if (delta_facing > 0)
 				{
@@ -674,6 +839,7 @@ marine_preprocess (ELEMENT *ElementPtr)
 		}
 
 		ElementPtr->turn_wait = MAKE_BYTE (0, NORMALIZE_FACING (facing));
+		
 		if (delta_facing == 0
 				 || ((ElementPtr->thrust_wait & (SHIP_BEYOND_MAX_SPEED >> 6))
 				 && !(ElementPtr->thrust_wait & (SHIP_IN_GRAVITY_WELL >> 6))))
@@ -690,22 +856,20 @@ marine_preprocess (ELEMENT *ElementPtr)
 			//   to call inertial_thrust() for a marine
 			OldFacing = StarShipPtr->ShipFacing;
 			OldStatus = StarShipPtr->cur_status_flags;
-			OldIncrement = StarShipPtr->RaceDescPtr->characteristics.
-					thrust_increment;
+			OldIncrement = StarShipPtr->RaceDescPtr->characteristics.thrust_increment;
 			OldThrust = StarShipPtr->RaceDescPtr->characteristics.max_thrust;
 
 			StarShipPtr->ShipFacing = facing;
 			// XXX: thrust_wait is abused to store marine speed and
 			//   gravity well flags
 			StarShipPtr->cur_status_flags = ElementPtr->thrust_wait << 6;
-			StarShipPtr->RaceDescPtr->characteristics.thrust_increment = 8;
-			StarShipPtr->RaceDescPtr->characteristics.max_thrust = 32;
+			StarShipPtr->RaceDescPtr->characteristics.thrust_increment = 8 << RESOLUTION_FACTOR; // JMS_GFX
+			StarShipPtr->RaceDescPtr->characteristics.max_thrust = 32 << RESOLUTION_FACTOR; // JMS_GFX
 
 			thrust_status = inertial_thrust (ElementPtr);
 
 			StarShipPtr->RaceDescPtr->characteristics.max_thrust = OldThrust;
-			StarShipPtr->RaceDescPtr->characteristics.thrust_increment =
-					OldIncrement;
+			StarShipPtr->RaceDescPtr->characteristics.thrust_increment = OldIncrement;
 			StarShipPtr->cur_status_flags = OldStatus;
 			StarShipPtr->ShipFacing = OldFacing;
 
@@ -734,10 +898,8 @@ marine_collision (ELEMENT *ElementPtr0,
 	{
 		if (!elementsOfSamePlayer (ElementPtr0, ElementPtr1))
 		{
-			ElementPtr0->turn_wait =
-					MAKE_BYTE (5, HINIBBLE (ElementPtr0->turn_wait));
-			ElementPtr0->thrust_wait &=
-					~((SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED) >> 6);
+			ElementPtr0->turn_wait = MAKE_BYTE (5, HINIBBLE (ElementPtr0->turn_wait));
+			ElementPtr0->thrust_wait &= ~((SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED) >> 6);
 			ElementPtr0->state_flags |= COLLISION;
 		}
 
@@ -757,10 +919,9 @@ marine_collision (ELEMENT *ElementPtr0,
 			{
 				DeltaCrew (ElementPtr1, 1);
 
-				ElementPtr0->state_flags |=
-						DISAPPEARING | NONSOLID | FINITE_LIFE;
-				ElementPtr0->hit_points = 0;
-				ElementPtr0->life_span = 0;
+				ElementPtr0->state_flags |= DISAPPEARING | NONSOLID | FINITE_LIFE;
+				ElementPtr0->hit_points	  = 0;
+				ElementPtr0->life_span	  = 0;
 			}
 			else if ((ElementPtr0->state_flags & IGNORE_SIMILAR)
 					&& ElementPtr1->crew_level
@@ -779,19 +940,29 @@ marine_collision (ELEMENT *ElementPtr0,
 				{
 					ElementPtr0->turn_wait = count_marines (StarShipPtr, TRUE);
 					ElementPtr0->thrust_wait = MARINE_WAIT;
-					ElementPtr0->next.image.frame = SetAbsFrameIndex (
-							ElementPtr0->next.image.farray[0],
-							22 + ElementPtr0->turn_wait
-							);
+					ElementPtr0->next.image.frame = SetAbsFrameIndex (ElementPtr0->next.image.farray[0], 31); // JMS: Draw a shadow first.
 					ElementPtr0->state_flags |= NONSOLID;
 					ElementPtr0->state_flags &= ~CREW_OBJECT;
-					SetPrimType (&(GLOBAL (DisplayArray))[
-							ElementPtr0->PrimIndex
-							], NO_PRIM);
+					SetPrimType (&(GLOBAL (DisplayArray))[ElementPtr0->PrimIndex], NO_PRIM);
 					ElementPtr0->preprocess_func = intruder_preprocess;
-
-					s.origin.x = 16 + (ElementPtr0->turn_wait & 3) * 9;
-					s.origin.y = 14 + (ElementPtr0->turn_wait >> 2) * 11;
+					
+					if (RESOLUTION_FACTOR < 2)
+					{
+						s.origin.x = (16 << RESOLUTION_FACTOR) + (ElementPtr0->turn_wait & 3) * ((9 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
+						s.origin.y = (14 << RESOLUTION_FACTOR) + (ElementPtr0->turn_wait >> 2) * ((11 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
+					}
+					else
+					{
+						s.origin.x = (16 - (RESOLUTION_FACTOR * 3 / 2) + (ElementPtr0->turn_wait & 3) * (9 + RESOLUTION_FACTOR * 3 / 2)) << RESOLUTION_FACTOR; // JMS_GFX
+						s.origin.y = (14 + (ElementPtr0->turn_wait >> 2) * (11 + RESOLUTION_FACTOR)) << RESOLUTION_FACTOR; // JMS_GFX
+					}
+						
+					// JMS: Draw the shadow.
+					s.frame = ElementPtr0->next.image.frame;
+					ModifySilhouette (ElementPtr1, &s, 0);
+					
+					// JMS: Draw the marine.
+					ElementPtr0->next.image.frame = SetAbsFrameIndex (ElementPtr0->next.image.farray[0], 22 + ElementPtr0->turn_wait);
 					s.frame = ElementPtr0->next.image.frame;
 					ModifySilhouette (ElementPtr1, &s, 0);
 				}
@@ -894,9 +1065,9 @@ turret_postprocess (ELEMENT *ElementPtr)
 							&& (hTurretEffect = AllocElement ()))
 					{
 						TurretPtr->current.location.x -=
-								COSINE (facing, DISPLAY_TO_WORLD (2));
+							COSINE (facing, DISPLAY_TO_WORLD (2) << RESOLUTION_FACTOR);
 						TurretPtr->current.location.y -=
-								SINE (facing, DISPLAY_TO_WORLD (2));
+							SINE (facing, DISPLAY_TO_WORLD (2) << RESOLUTION_FACTOR);
 
 						LockElement (hTurretEffect, &TurretEffectPtr);
 						TurretEffectPtr->playerNr = ElementPtr->playerNr;
@@ -971,10 +1142,10 @@ turret_postprocess (ELEMENT *ElementPtr)
 				facing = FACING_TO_ANGLE (StarShipPtr->ShipFacing);
 				SpaceMarinePtr->current.location.x =
 						ShipPtr->current.location.x
-						- COSINE (facing, DISPLAY_TO_WORLD (TURRET_OFFSET));
+					- COSINE (facing, DISPLAY_TO_WORLD (TURRET_OFFSET << ((RESOLUTION_FACTOR + 1)/2))); // JMS_GFX
 				SpaceMarinePtr->current.location.y =
 						ShipPtr->current.location.y
-						- SINE (facing, DISPLAY_TO_WORLD (TURRET_OFFSET));
+						- SINE (facing, DISPLAY_TO_WORLD (TURRET_OFFSET << ((RESOLUTION_FACTOR + 1)/2))); // JMS_GFX
 				SpaceMarinePtr->current.image.farray =
 						StarShipPtr->RaceDescPtr->ship_data.special;
 				SpaceMarinePtr->current.image.frame = SetAbsFrameIndex (
@@ -1065,11 +1236,27 @@ init_orz (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	orz_desc.preprocess_func = orz_preprocess;
-	orz_desc.init_weapon_func = initialize_turret_missile;
-	orz_desc.cyborg_control.intelligence_func = orz_intelligence;
-
-	RaceDescPtr = &orz_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		orz_desc.preprocess_func = orz_preprocess;
+		orz_desc.init_weapon_func = initialize_turret_missile;
+		orz_desc.cyborg_control.intelligence_func = orz_intelligence;
+		RaceDescPtr = &orz_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		orz_desc_2xres.preprocess_func = orz_preprocess;
+		orz_desc_2xres.init_weapon_func = initialize_turret_missile;
+		orz_desc_2xres.cyborg_control.intelligence_func = orz_intelligence;
+		RaceDescPtr = &orz_desc_2xres;
+	}
+	else
+	{
+		orz_desc_4xres.preprocess_func = orz_preprocess;
+		orz_desc_4xres.init_weapon_func = initialize_turret_missile;
+		orz_desc_4xres.cyborg_control.intelligence_func = orz_intelligence;
+		RaceDescPtr = &orz_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp src.orig/uqm/ships/pkunk/icode.h src/uqm/ships/pkunk/icode.h
--- src.orig/uqm/ships/pkunk/icode.h	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/pkunk/icode.h	2017-11-01 15:31:04 -0700
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define PKUNK_CODE "ship.pkunk.code"
diff -ruNp src.orig/uqm/ships/pkunk/pkunk.c src/uqm/ships/pkunk/pkunk.c
--- src.orig/uqm/ships/pkunk/pkunk.c	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/pkunk/pkunk.c	2017-11-01 15:31:04 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: -Remove instrument damage upon rebirth
+
 #include "../ship.h"
 #include "pkunk.h"
 #include "resinst.h"
@@ -51,12 +53,12 @@ static RACE_DESC pkunk_desc =
 		PKUNK_RACE_STRINGS,
 		PKUNK_ICON_MASK_PMAP_ANIM,
 		PKUNK_MICON_MASK_PMAP_ANIM,
-		NULL, NULL, NULL
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
 	},
 	{ /* FLEET_STUFF */
-		666 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		0, /* Initial SoI radius */
 		{ /* Known location (center of SoI) */
-			502, 401,
+			0, 0,
 		},
 	},
 	{
@@ -112,6 +114,158 @@ static RACE_DESC pkunk_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+#define MAX_THRUST_2XRES 128
+#define THRUST_INCREMENT_2XRES 32
+
+// JMS_GFX
+static RACE_DESC pkunk_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | FIRES_LEFT | FIRES_RIGHT,
+		20, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		PKUNK_RACE_STRINGS,
+		PKUNK_ICON_MASK_PMAP_ANIM,
+		PKUNK_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		0, /* SPECIAL_WAIT */
+		SHIP_MASS,
+	},
+	{
+		{
+			PKUNK_BIG_MASK_PMAP_ANIM,
+			PKUNK_MED_MASK_PMAP_ANIM,
+			PKUNK_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BUG_BIG_MASK_PMAP_ANIM,
+			BUG_MED_MASK_PMAP_ANIM,
+			BUG_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			PKUNK_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		PKUNK_VICTORY_SONG,
+		PKUNK_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_2XRES + 2,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 256
+#define THRUST_INCREMENT_4XRES 64
+
+// JMS_GFX
+static RACE_DESC pkunk_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | FIRES_LEFT | FIRES_RIGHT,
+		20, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		PKUNK_RACE_STRINGS,
+		PKUNK_ICON_MASK_PMAP_ANIM,
+		PKUNK_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		0, /* SPECIAL_WAIT */
+		SHIP_MASS,
+	},
+	{
+		{
+			PKUNK_BIG_MASK_PMAP_ANIM,
+			PKUNK_MED_MASK_PMAP_ANIM,
+			PKUNK_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BUG_BIG_MASK_PMAP_ANIM,
+			BUG_MED_MASK_PMAP_ANIM,
+			BUG_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			PKUNK_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		PKUNK_VICTORY_SONG,
+		PKUNK_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_4XRES + 4,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static void
 animate (ELEMENT *ElementPtr)
 {
@@ -119,10 +273,8 @@ animate (ELEMENT *ElementPtr)
 		--ElementPtr->turn_wait;
 	else
 	{
-		ElementPtr->next.image.frame =
-				IncFrameIndex (ElementPtr->current.image.frame);
+		ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->current.image.frame);
 		ElementPtr->state_flags |= CHANGING;
-
 		ElementPtr->turn_wait = ElementPtr->next_turn;
 	}
 }
@@ -130,10 +282,10 @@ animate (ELEMENT *ElementPtr)
 static COUNT
 initialize_bug_missile (ELEMENT *ShipPtr, HELEMENT MissileArray[])
 {
-#define PKUNK_OFFSET 15
+#define PKUNK_OFFSET (15 << RESOLUTION_FACTOR) // JMS_GFX
 #define MISSILE_HITS 1
 #define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET 1
+#define MISSILE_OFFSET (1 << RESOLUTION_FACTOR) // JMS_GFX
 	COUNT i;
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
@@ -146,7 +298,7 @@ initialize_bug_missile (ELEMENT *ShipPtr
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = PKUNK_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -155,11 +307,11 @@ initialize_bug_missile (ELEMENT *ShipPtr
 
 	for (i = 0; i < 3; ++i)
 	{
-		MissileBlock.face =
-				StarShipPtr->ShipFacing
-				+ (ANGLE_TO_FACING (QUADRANT) * i);
+		MissileBlock.face = StarShipPtr->ShipFacing + (ANGLE_TO_FACING (QUADRANT) * i);
+		
 		if (i == 2)
 			MissileBlock.face += ANGLE_TO_FACING (QUADRANT);
+		
 		MissileBlock.face = NORMALIZE_FACING (MissileBlock.face);
 
 		if ((MissileArray[i] = initialize_missile (&MissileBlock)))
@@ -214,6 +366,7 @@ static void
 new_pkunk (ELEMENT *ElementPtr)
 {
 	STARSHIP *StarShipPtr;
+	SHIP_INFO *ShipInfoPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (!(ElementPtr->state_flags & PLAYER_SHIP))
@@ -239,8 +392,8 @@ new_pkunk (ELEMENT *ElementPtr)
 		StarShipPtr->RaceDescPtr->ship_info.crew_level = MAX_CREW;
 		StarShipPtr->RaceDescPtr->ship_info.energy_level = MAX_ENERGY;
 					/* fix vux impairment */
-		StarShipPtr->RaceDescPtr->characteristics.max_thrust = MAX_THRUST;
-		StarShipPtr->RaceDescPtr->characteristics.thrust_increment = THRUST_INCREMENT;
+		StarShipPtr->RaceDescPtr->characteristics.max_thrust = MAX_THRUST << RESOLUTION_FACTOR; // JMS_GFX
+		StarShipPtr->RaceDescPtr->characteristics.thrust_increment = THRUST_INCREMENT << RESOLUTION_FACTOR; // JMS_GFX
 		StarShipPtr->RaceDescPtr->characteristics.turn_wait = TURN_WAIT;
 		StarShipPtr->RaceDescPtr->characteristics.thrust_wait = THRUST_WAIT;
 		StarShipPtr->RaceDescPtr->characteristics.special_wait = 0;
@@ -255,15 +408,17 @@ new_pkunk (ELEMENT *ElementPtr)
 		ElementPtr->turn_wait = 0;
 		ElementPtr->thrust_wait = 0;
 		ElementPtr->life_span = NORMAL_LIFE;
+		
+		// JMS: Fix instrument damage
+		ShipInfoPtr = &StarShipPtr->RaceDescPtr->ship_info;
+		ShipInfoPtr->damage_flags = 0;
 
 		StarShipPtr->ShipFacing = NORMALIZE_FACING (TFB_Random ());
 		ElementPtr->current.image.farray = StarShipPtr->RaceDescPtr->ship_data.ship;
 		ElementPtr->current.image.frame =
 				SetAbsFrameIndex (StarShipPtr->RaceDescPtr->ship_data.ship[0],
 				StarShipPtr->ShipFacing);
-		SetPrimType (&(GLOBAL (DisplayArray))[
-				ElementPtr->PrimIndex
-				], STAMP_PRIM);
+		SetPrimType (&(GLOBAL (DisplayArray))[ElementPtr->PrimIndex], STAMP_PRIM);
 
 		do
 		{
@@ -366,7 +521,7 @@ phoenix_transition (ELEMENT *ElementPtr)
 	}
 	else if ((hShipImage = AllocElement ()))
 	{
-#define TRANSITION_SPEED DISPLAY_TO_WORLD (20)
+#define TRANSITION_SPEED DISPLAY_TO_WORLD (20 << RESOLUTION_FACTOR) // JMS_GFX
 		COUNT angle;
 
 		PutElement (hShipImage);
@@ -543,12 +698,30 @@ init_pkunk (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	pkunk_desc.preprocess_func = pkunk_preprocess;
-	pkunk_desc.postprocess_func = pkunk_postprocess;
-	pkunk_desc.init_weapon_func = initialize_bug_missile;
-	pkunk_desc.cyborg_control.intelligence_func = pkunk_intelligence;
-
-	RaceDescPtr = &pkunk_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		pkunk_desc.preprocess_func = pkunk_preprocess;
+		pkunk_desc.postprocess_func = pkunk_postprocess;
+		pkunk_desc.init_weapon_func = initialize_bug_missile;
+		pkunk_desc.cyborg_control.intelligence_func = pkunk_intelligence;
+		RaceDescPtr = &pkunk_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		pkunk_desc_2xres.preprocess_func = pkunk_preprocess;
+		pkunk_desc_2xres.postprocess_func = pkunk_postprocess;
+		pkunk_desc_2xres.init_weapon_func = initialize_bug_missile;
+		pkunk_desc_2xres.cyborg_control.intelligence_func = pkunk_intelligence;
+		RaceDescPtr = &pkunk_desc_2xres;
+	}
+	else
+	{
+		pkunk_desc_4xres.preprocess_func = pkunk_preprocess;
+		pkunk_desc_4xres.postprocess_func = pkunk_postprocess;
+		pkunk_desc_4xres.init_weapon_func = initialize_bug_missile;
+		pkunk_desc_4xres.cyborg_control.intelligence_func = pkunk_intelligence;
+		RaceDescPtr = &pkunk_desc_4xres;
+	}
 
 	LastSound = 0;
 			// We need to reinitialise it at least each battle, to ensure
diff -ruNp src.orig/uqm/ships/probe/icode.h src/uqm/ships/probe/icode.h
--- src.orig/uqm/ships/probe/icode.h	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/probe/icode.h	2017-11-01 15:31:04 -0700
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define URQUAN_DRONE_CODE "ship.drone.code"
diff -ruNp src.orig/uqm/ships/probe/probe.c src/uqm/ships/probe/probe.c
--- src.orig/uqm/ships/probe/probe.c	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/probe/probe.c	2017-11-01 15:31:04 -0700
@@ -45,7 +45,7 @@ static RACE_DESC probe_desc =
 		0,
 		0,
 		URQUAN_DRONE_MICON_MASK_PMAP_ANIM,
-		NULL, NULL, NULL
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
 	},
 	{ /* FLEET_STUFF */
 		0, /* Initial sphere of influence radius */
diff -ruNp src.orig/uqm/ships/shofixti/icode.h src/uqm/ships/shofixti/icode.h
--- src.orig/uqm/ships/shofixti/icode.h	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/shofixti/icode.h	2017-11-01 15:31:04 -0700
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SHOFIXTI_CODE "ship.shofixti.code"
diff -ruNp src.orig/uqm/ships/shofixti/shofixti.c src/uqm/ships/shofixti/shofixti.c
--- src.orig/uqm/ships/shofixti/shofixti.c	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/shofixti/shofixti.c	2017-11-01 15:31:04 -0700
@@ -16,6 +16,9 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: Disabled Tanaka/Katana from the game.
+//			 (Left the code there for reference though.)
+
 #include "../ship.h"
 #include "shofixti.h"
 #include "resinst.h"
@@ -51,12 +54,12 @@ static RACE_DESC shofixti_desc =
 		SHOFIXTI_RACE_STRINGS,
 		SHOFIXTI_ICON_MASK_PMAP_ANIM,
 		SHOFIXTI_MICON_MASK_PMAP_ANIM,
-		NULL, NULL, NULL
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
 	},
 	{ /* FLEET_STUFF */
-		0, /* Initial sphere of influence radius */
+		250 / SPHERE_RADIUS_INCREMENT * 2, /* Initial sphere of influence radius */
 		{ /* Known location (center of SoI) */
-			0, 0,
+			7908,6269,
 		},
 	},
 	{
@@ -112,13 +115,167 @@ static RACE_DESC shofixti_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+#define MAX_THRUST_2XRES 70
+#define THRUST_INCREMENT_2XRES 10
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (48)
+
+// JMS_GFX
+static RACE_DESC shofixti_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		5, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		SHOFIXTI_RACE_STRINGS,
+		SHOFIXTI_ICON_MASK_PMAP_ANIM,
+		SHOFIXTI_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		250 / SPHERE_RADIUS_INCREMENT * 2, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			7908,6269,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SHOFIXTI_BIG_MASK_PMAP_ANIM,
+			SHOFIXTI_MED_MASK_PMAP_ANIM,
+			SHOFIXTI_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DART_BIG_MASK_PMAP_ANIM,
+			DART_MED_MASK_PMAP_ANIM,
+			DART_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DESTRUCT_BIG_MASK_ANIM,
+			DESTRUCT_MED_MASK_ANIM,
+			DESTRUCT_SML_MASK_ANIM,
+		},
+		{
+			SHOFIXTI_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SHOFIXTI_VICTORY_SONG,
+		SHOFIXTI_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_SPEED_2XRES * MISSILE_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 140
+#define THRUST_INCREMENT_4XRES 20
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (96)
+
+// JMS_GFX
+static RACE_DESC shofixti_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		5, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		SHOFIXTI_RACE_STRINGS,
+		SHOFIXTI_ICON_MASK_PMAP_ANIM,
+		SHOFIXTI_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		250 / SPHERE_RADIUS_INCREMENT * 2, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			7908,6269,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SHOFIXTI_BIG_MASK_PMAP_ANIM,
+			SHOFIXTI_MED_MASK_PMAP_ANIM,
+			SHOFIXTI_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DART_BIG_MASK_PMAP_ANIM,
+			DART_MED_MASK_PMAP_ANIM,
+			DART_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DESTRUCT_BIG_MASK_ANIM,
+			DESTRUCT_MED_MASK_ANIM,
+			DESTRUCT_SML_MASK_ANIM,
+		},
+		{
+			SHOFIXTI_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SHOFIXTI_VICTORY_SONG,
+		SHOFIXTI_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_SPEED_4XRES * MISSILE_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static COUNT
 initialize_standard_missile (ELEMENT *ShipPtr, HELEMENT MissileArray[])
 {
-#define SHOFIXTI_OFFSET 15
+#define SHOFIXTI_OFFSET (15 << RESOLUTION_FACTOR) // JMS_GFX
 #define MISSILE_HITS 1
 #define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET 1
+#define MISSILE_OFFSET (1 << RESOLUTION_FACTOR) // JMS_GFX
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -130,7 +287,7 @@ initialize_standard_missile (ELEMENT *Sh
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = SHOFIXTI_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -299,7 +456,7 @@ self_destruct (ELEMENT *ElementPtr)
 
 			if (CollidingElement (ObjPtr) || ORZ_MARINE (ObjPtr))
 			{
-#define DESTRUCT_RANGE 180
+#define DESTRUCT_RANGE (180 << RESOLUTION_FACTOR) // JMS_GFX
 				SIZE delta_x, delta_y;
 				DWORD dist;
 
@@ -316,12 +473,10 @@ self_destruct (ELEMENT *ElementPtr)
 						+ (DWORD)(delta_y * delta_y)) <=
 						(DWORD)(DESTRUCT_RANGE * DESTRUCT_RANGE))
 				{
-#define MAX_DESTRUCTION (DESTRUCT_RANGE / 10)
+#define MAX_DESTRUCTION ((DESTRUCT_RANGE >> RESOLUTION_FACTOR) / 10) // JMS_GFX
 					SIZE destruction;
 
-					destruction = ((MAX_DESTRUCTION
-							* (DESTRUCT_RANGE - square_root (dist)))
-							/ DESTRUCT_RANGE) + 1;
+					destruction = ((MAX_DESTRUCTION * (DESTRUCT_RANGE - square_root (dist))) / DESTRUCT_RANGE) + 1;
 
 					if (ObjPtr->state_flags & PLAYER_SHIP)
 					{
@@ -413,13 +568,32 @@ init_shofixti (void)
 
 	static RACE_DESC new_shofixti_desc;
 
-	shofixti_desc.postprocess_func = shofixti_postprocess;
-	shofixti_desc.init_weapon_func = initialize_standard_missile;
-	shofixti_desc.cyborg_control.intelligence_func = shofixti_intelligence;
-
-	new_shofixti_desc = shofixti_desc;
-	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_ENCOUNTER
-			&& !GET_GAME_STATE (SHOFIXTI_RECRUITED))
+	if (RESOLUTION_FACTOR == 0)
+	{
+		shofixti_desc.postprocess_func = shofixti_postprocess;
+		shofixti_desc.init_weapon_func = initialize_standard_missile;
+		shofixti_desc.cyborg_control.intelligence_func = shofixti_intelligence;
+		new_shofixti_desc = shofixti_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		shofixti_desc_2xres.postprocess_func = shofixti_postprocess;
+		shofixti_desc_2xres.init_weapon_func = initialize_standard_missile;
+		shofixti_desc_2xres.cyborg_control.intelligence_func = shofixti_intelligence;
+		new_shofixti_desc = shofixti_desc_2xres;
+	}
+	else
+	{
+		shofixti_desc_4xres.postprocess_func = shofixti_postprocess;
+		shofixti_desc_4xres.init_weapon_func = initialize_standard_missile;
+		shofixti_desc_4xres.cyborg_control.intelligence_func = shofixti_intelligence;
+		new_shofixti_desc = shofixti_desc_4xres;
+	}
+	
+	// JMS: No more Tanaka/Katana!!
+	//if (LOBYTE (GLOBAL (CurrentActivity)) == IN_ENCOUNTER
+	//		&& !GET_GAME_STATE (SHOFIXTI_RECRUITED))
+	if(0)
 	{
 		// Tanaka/Katana flies in a damaged ship.
 #define NUM_LIMPETS 3
diff -ruNp src.orig/uqm/ships/sis_ship/icode.h src/uqm/ships/sis_ship/icode.h
--- src.orig/uqm/ships/sis_ship/icode.h	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/sis_ship/icode.h	2017-11-01 15:31:04 -0700
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SIS_CODE "ship.flagship.code"
diff -ruNp src.orig/uqm/ships/sis_ship/istrtab.h src/uqm/ships/sis_ship/istrtab.h
--- src.orig/uqm/ships/sis_ship/istrtab.h	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/sis_ship/istrtab.h	2017-11-01 15:31:04 -0700
@@ -0,0 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
+#define EXP_RACE_STRINGS "ship.explorer.text"
diff -ruNp src.orig/uqm/ships/sis_ship/resinst.h src/uqm/ships/sis_ship/resinst.h
--- src.orig/uqm/ships/sis_ship/resinst.h	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/sis_ship/resinst.h	2017-11-01 15:31:05 -0700
@@ -1,13 +1,32 @@
 #define BLASTER_BIG_MASK_PMAP_ANIM "ship.flagship.graphics.blaster.large"
 #define BLASTER_MED_MASK_PMAP_ANIM "ship.flagship.graphics.blaster.medium"
 #define BLASTER_SML_MASK_PMAP_ANIM "ship.flagship.graphics.blaster.small"
+#define EXP_BIG_MASK_PMAP_ANIM "ship.explorer.graphics.exp.large"
+#define EXP_ICON_MASK_PMAP_ANIM "ship.explorer.icons"
+#define EXP_MED_MASK_PMAP_ANIM "ship.explorer.graphics.exp.medium"
+#define EXP_MICON_MASK_PMAP_ANIM "ship.explorer.meleeicons"
+#define EXP_SML_MASK_PMAP_ANIM "ship.explorer.graphics.exp.small"
+#define PULSE_BIG_MASK_PMAP_ANIM "ship.explorer.graphics.con.large"
+#define PULSE_MED_MASK_PMAP_ANIM "ship.explorer.graphics.con.medium"
+#define PULSE_SML_MASK_PMAP_ANIM "ship.explorer.graphics.con.small"
 #define SIS_BIG_MASK_PMAP_ANIM "ship.flagship.graphics.flagship.large"
 #define SIS_CAPTAIN_MASK_PMAP_ANIM "ship.flagship.graphics.captain"
-#define SIS_HYPER_MASK_PMAP_ANIM "ship.flagship.graphics.hyperspace"
+#define SIS_HYPER_MASK_PMAP_ANIM "ship.flagship.graphics.exphyper"
 #define SIS_ICON_MASK_PMAP_ANIM "ship.flagship.icons"
 #define SIS_MED_MASK_PMAP_ANIM "ship.flagship.graphics.flagship.medium"
+#define SIS_ORZ_MASK_PMAP_ANIM "ship.flagship.graphics.exporz"
+#define SIS_QUASI_MASK_PMAP_ANIM "ship.flagship.graphics.expquasi"
 #define SIS_SML_MASK_PMAP_ANIM "ship.flagship.graphics.flagship.small"
+#define SPARK_ONLY_BIG_MASK_PMAP_ANIM "ship.sis_ship.graphics.spark_only.large"
+#define SPARK_ONLY_MED_MASK_PMAP_ANIM "ship.sis_ship.graphics.spark_only.medium"
+#define SPARK_ONLY_SML_MASK_PMAP_ANIM "ship.sis_ship.graphics.spark_only.small"
+#define STUNNER_BIG_MASK_PMAP_ANIM "ship.explorer.graphics.stunner.large"
+#define STUNNER_MED_MASK_PMAP_ANIM "ship.explorer.graphics.stunner.medium"
+#define STUNNER_SML_MASK_PMAP_ANIM "ship.explorer.graphics.stunner.small"
+#define EXP_VICTORY_SONG "ship.explorer.ditty"
+#define EXP_SHIP_SOUNDS "ship.explorer.sounds"
 #define SIS_SHIP_SOUNDS "ship.flagship.sounds"
 #define SIS_VICTORY_SONG "ship.flagship.ditty"
 
 #include "icode.h"
+#include "istrtab.h"
diff -ruNp src.orig/uqm/ships/sis_ship/sis_ship.c src/uqm/ships/sis_ship/sis_ship.c
--- src.orig/uqm/ships/sis_ship/sis_ship.c	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/sis_ship/sis_ship.c	2017-11-01 15:31:05 -0700
@@ -16,49 +16,70 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
 #include "../ship.h"
 #include "sis_ship.h"
 #include "resinst.h"
-
 #include "uqm/colors.h"
 #include "uqm/controls.h"
 #include "uqm/globdata.h"
 #include "uqm/hyper.h"
 #include "libs/mathlib.h"
+#include "libs/log.h"
 
-
-#define MAX_TRACKING 3
-#define MAX_DEFENSE 8
-
-#define MAX_CREW MAX_CREW_SIZE
-#define MAX_ENERGY MAX_ENERGY_SIZE
+#define MAX_CREW EXPLORER_CREW_CAPACITY
+#define MAX_ENERGY 42
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 1
-#define SPECIAL_ENERGY_COST 0
-#define ENERGY_WAIT 10
-#define MAX_THRUST 10
-#define THRUST_INCREMENT 4
-#define TURN_WAIT 17
-#define THRUST_WAIT 6
-#define WEAPON_WAIT 6
-#define SPECIAL_WAIT 9
+#define ENERGY_WAIT 5
+#define SHIP_MASS 10
 
-#define SHIP_MASS MAX_SHIP_MASS
+// These affect Chmmr Explorer in Super Melee and adventure mode.
+#define EXPLORER_MAX_THRUST 36
+#define EXPLORER_THRUST_INCREMENT 4
+#define EXPLORER_TURN_WAIT 1
+#define EXPLORER_THRUST_WAIT 1
 
+#define WEAPON_ENERGY_COST 3
+#define WEAPON_WAIT 2
 #define BLASTER_SPEED DISPLAY_TO_WORLD (24)
-#define BLASTER_LIFE 12
+#define BLASTER_LIFE 9
+#define BLASTER_HITS 2
+#define BLASTER_DAMAGE 2
+#define BLASTER_OFFSET (8 << RESOLUTION_FACTOR) // JMS_GFX
+#define EXP_VERT_OFFSET 28
+#define EXP_HORZ_OFFSET 20
+#define EXP_HORZ_OFFSET_2 (DISPLAY_TO_WORLD(5 << RESOLUTION_FACTOR))  // JMS_GFX
+#define EXP_HORZ_OFFSET_3 (DISPLAY_TO_WORLD(-5 << RESOLUTION_FACTOR)) // JMS_GFX
+
+#define SPECIAL_ENERGY_COST 15
+#define SPECIAL_WAIT 20
+#define STUNBALL_SPEED DISPLAY_TO_WORLD (16 << RESOLUTION_FACTOR) // JMS_GFX
+#define STUNBALL_LIFE 90 // Duration is as long as you hold down the button.
+#define STUNBALL_HITS 10
+#define STUNBALL_DAMAGE 0
+#define STUNBALL_START_OFFSET (36 << RESOLUTION_FACTOR) // JMS_GFX
+#define STUNBALL_BLAST_OFFSET (4 << RESOLUTION_FACTOR) // JMS_GFX
+#define SHOCKWAVE_RANGE_MID (85 << RESOLUTION_FACTOR) // JMS_GFX
+#define SHOCKWAVE_RANGE_END (116 << RESOLUTION_FACTOR) // JMS_GFX
+#define FULL_STUN_DURATION 90
+#define PARTIAL_STUN_DURATION 60
+
+#define MAX_THRUST 10		//
+#define TURN_WAIT 17		// JMS: Kept these defines for now since they might have some effect
+#define THRUST_WAIT 6		// in the speed calculations in some point. Not sure though, got to check in some point!
 
-static RACE_DESC sis_desc =
+static RACE_DESC exp_desc =
 {
 	{ /* SHIP_INFO */
-		0,
-		16, /* Super Melee cost */
+		FIRES_FORE,
+		25, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY, MAX_ENERGY,
-		NULL_RESOURCE,
-		SIS_ICON_MASK_PMAP_ANIM,
-		NULL_RESOURCE,
-		NULL, NULL, NULL
+		EXP_RACE_STRINGS,
+		EXP_ICON_MASK_PMAP_ANIM,	// Explorer icons
+		EXP_MICON_MASK_PMAP_ANIM,	// Explorer melee icons
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
 	},
 	{ /* FLEET_STUFF */
 		0, /* Initial sphere of influence radius */
@@ -68,7 +89,7 @@ static RACE_DESC sis_desc =
 	},
 	{
 		MAX_THRUST,
-		THRUST_INCREMENT,
+		EXPLORER_THRUST_INCREMENT,
 		ENERGY_REGENERATION,
 		WEAPON_ENERGY_COST,
 		SPECIAL_ENERGY_COST,
@@ -81,26 +102,26 @@ static RACE_DESC sis_desc =
 	},
 	{
 		{
-			SIS_BIG_MASK_PMAP_ANIM,
-			SIS_MED_MASK_PMAP_ANIM,
-			SIS_SML_MASK_PMAP_ANIM,
+			EXP_BIG_MASK_PMAP_ANIM,
+			EXP_MED_MASK_PMAP_ANIM,
+			EXP_SML_MASK_PMAP_ANIM,
 		},
 		{
-			BLASTER_BIG_MASK_PMAP_ANIM,
-			BLASTER_MED_MASK_PMAP_ANIM,
-			BLASTER_SML_MASK_PMAP_ANIM,
+			PULSE_BIG_MASK_PMAP_ANIM,
+			PULSE_MED_MASK_PMAP_ANIM,
+			PULSE_SML_MASK_PMAP_ANIM,
 		},
 		{
-			NULL_RESOURCE,
-			NULL_RESOURCE,
-			NULL_RESOURCE,
+			STUNNER_BIG_MASK_PMAP_ANIM,
+			STUNNER_MED_MASK_PMAP_ANIM,
+			STUNNER_SML_MASK_PMAP_ANIM,
 		},
 		{
 			SIS_CAPTAIN_MASK_PMAP_ANIM,
 			NULL, NULL, NULL, NULL, NULL
 		},
-		SIS_VICTORY_SONG,
-		SIS_SHIP_SOUNDS,
+		EXP_VICTORY_SONG,
+		EXP_SHIP_SOUNDS,
 		{ NULL, NULL, NULL },
 		{ NULL, NULL, NULL },
 		{ NULL, NULL, NULL },
@@ -119,58 +140,57 @@ static RACE_DESC sis_desc =
 	0, /* CodeRef */
 };
 
-// Private per-instance SIS data
-typedef struct
-{
-	COUNT num_trackers;
-	COUNT num_blasters;
-	MISSILE_BLOCK MissileBlock[6];
+// static void InitModuleSlots (RACE_DESC *RaceDescPtr);
+static void InitDriveSlots (RACE_DESC *RaceDescPtr, const BYTE *DriveSlots);
+static void InitJetSlots (RACE_DESC *RaceDescPtr, const BYTE *JetSlots);
+void uninit_exp (RACE_DESC *pRaceDesc);
+static COUNT initialize_teststunner (ELEMENT *ShipPtr, HELEMENT MissileArray[]);
 
-} SIS_DATA;
-
-static void InitWeaponSlots (RACE_DESC *RaceDescPtr,
-		const BYTE *ModuleSlots);
-static void InitModuleSlots (RACE_DESC *RaceDescPtr,
-		const BYTE *ModuleSlots);
-static void InitDriveSlots (RACE_DESC *RaceDescPtr,
-		const BYTE *DriveSlots);
-static void InitJetSlots (RACE_DESC *RaceDescPtr,
-		const BYTE *JetSlots);
-void uninit_sis (RACE_DESC *pRaceDesc);
-
-
-static void
-sis_hyper_preprocess (ELEMENT *ElementPtr)
+// Hyperspace movement.
+static void exp_hyper_preprocess (ELEMENT *ElementPtr)
 {
-	SIZE udx = 0, udy = 0;
 	SIZE dx = 0, dy = 0;
 	SIZE AccelerateDirection;
 	STARSHIP *StarShipPtr;
+	SDWORD udx = 0, udy = 0, dtempx, dtempy;	// JMS_GFX: These babies help to make the hyperspace speed calculations not overflow in hires.
 
 	if (ElementPtr->state_flags & APPEARING)
 		ElementPtr->velocity = GLOBAL (velocity);
 
 	AccelerateDirection = 0;
-
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	++StarShipPtr->weapon_counter; /* no shooting in hyperspace! */
+	
 	if ((GLOBAL (autopilot)).x == ~0
 			|| (GLOBAL (autopilot)).y == ~0
-			|| (StarShipPtr->cur_status_flags & (LEFT | RIGHT | THRUST)))
+			|| (StarShipPtr->cur_status_flags & (LEFT | RIGHT | THRUST))
+			|| !(GET_GAME_STATE(AUTOPILOT_OK))) // JMS: This check makes autopilot engage only after coming to full stop
 	{
 LeaveAutoPilot:
-		(GLOBAL (autopilot)).x =
-				(GLOBAL (autopilot)).y = ~0;
+		
+		// JMS: This re-check is now needed because of the added autopilot_ok variable to previous check
+		if ((GLOBAL (autopilot)).x == ~0 || (GLOBAL (autopilot)).y == ~0 || (StarShipPtr->cur_status_flags & (LEFT | RIGHT | THRUST)))
+				(GLOBAL (autopilot)).x = (GLOBAL (autopilot)).y = ~0;
+		
 		if (!(StarShipPtr->cur_status_flags & THRUST)
 				|| (GLOBAL_SIS (FuelOnBoard) == 0
-				&& GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1))
+				&& (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1) && GET_GAME_STATE (ORZ_SPACE_SIDE) <= 1)) // JMS
 		{
 			AccelerateDirection = -1;
-			GetCurrentVelocityComponents (&ElementPtr->velocity,
-					&dx, &dy);
-			udx = dx << 4;
-			udy = dy << 4;
-
+			GetCurrentVelocityComponents (&ElementPtr->velocity, &dx, &dy);
+			
+			// JMS: Engage autopilot only after coming to full stop
+			if (dx==0 && dy==0)
+				SET_GAME_STATE (AUTOPILOT_OK, 1);
+			else
+				SET_GAME_STATE (AUTOPILOT_OK, 0);
+			
+			dtempx = (SDWORD)dx;
+			dtempy = (SDWORD)dy;
+			
+			udx = dtempx;
+			udy = dtempy;
+			
 			StarShipPtr->cur_status_flags &= ~THRUST;
 		}
 	}
@@ -183,11 +203,34 @@ LeaveAutoPilot:
 		universe.y = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
 		udx = (GLOBAL (autopilot)).x - universe.x;
 		udy = -((GLOBAL (autopilot)).y - universe.y);
-		if ((dx = udx) < 0)
+		if ((dx = (SIZE)udx) < 0)
 			dx = -dx;
-		if ((dy = udy) < 0)
+		if ((dy = (SIZE)udy) < 0)
 			dy = -dy;
-		if (dx <= 1 && dy <= 1)
+
+        if (ENABLE_NON_EUCLIDEAN_ORZ_SPACE && GET_GAME_STATE (ORZ_SPACE_SIDE) > 1)
+        {
+            /* If it's just a short distance, use the normal autopilot's straight path.
+               Otherwise, follow the circle path. */
+#define EUCLIDEAN_SHORT_DISTANCE 100
+            if (dx > (EUCLIDEAN_SHORT_DISTANCE << RESOLUTION_FACTOR))
+            {
+                if (udx > 0)
+                {
+                    udy = universe.x - GLOBAL(autopilotOrzSpaceCenter).x;
+                    udx = universe.y - GLOBAL(autopilotOrzSpaceCenter).y;
+                    StarShipPtr->cur_status_flags &= ~SHIP_AT_MAX_SPEED;
+                }
+                else
+                {
+                    udy = -(universe.x - GLOBAL(autopilotOrzSpaceCenter).x);
+                    udx = -(universe.y - GLOBAL(autopilotOrzSpaceCenter).y);
+                    StarShipPtr->cur_status_flags &= ~SHIP_AT_MAX_SPEED;
+                }
+            }
+        }
+        
+		if (dx <= (1 << RESOLUTION_FACTOR) && dy <= (1 << RESOLUTION_FACTOR))
 			goto LeaveAutoPilot;
 
 		facing = NORMALIZE_FACING (ANGLE_TO_FACING (ARCTAN (udx, udy)));
@@ -197,9 +240,7 @@ LeaveAutoPilot:
 		if ((StarShipPtr->cur_status_flags & SHIP_AT_MAX_SPEED)
 				/*|| (ElementPtr->state_flags & APPEARING)*/ )
 		{
-			if (NORMALIZE_FACING (StarShipPtr->ShipFacing
-					+ ANGLE_TO_FACING (QUADRANT)
-					- facing) > ANGLE_TO_FACING (HALF_CIRCLE))
+			if (NORMALIZE_FACING (StarShipPtr->ShipFacing + ANGLE_TO_FACING (QUADRANT) - facing) > ANGLE_TO_FACING (HALF_CIRCLE))
 				goto LeaveAutoPilot;
 
 			facing = StarShipPtr->ShipFacing;
@@ -207,9 +248,7 @@ LeaveAutoPilot:
 		else if ((int)facing != (int)StarShipPtr->ShipFacing
 				&& ElementPtr->turn_wait == 0)
 		{
-			if (NORMALIZE_FACING (
-					StarShipPtr->ShipFacing - facing
-					) >= ANGLE_TO_FACING (HALF_CIRCLE))
+			if (NORMALIZE_FACING (StarShipPtr->ShipFacing - facing) >= ANGLE_TO_FACING (HALF_CIRCLE))
 			{
 				facing = NORMALIZE_FACING (facing - 1);
 				StarShipPtr->cur_status_flags |= RIGHT;
@@ -221,14 +260,13 @@ LeaveAutoPilot:
 			}
 
 			if ((int)facing == (int)StarShipPtr->ShipFacing)
-			{
 				ZeroVelocityComponents (&ElementPtr->velocity);
-			}
 		}
 
 		GetCurrentVelocityComponents (&ElementPtr->velocity, &dx, &dy);
+		
 		if ((GLOBAL_SIS (FuelOnBoard)
-				|| GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1)
+				|| GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1 || GET_GAME_STATE (ORZ_SPACE_SIDE) > 1) // JMS: Orz space check.
 				&& (int)facing == (int)StarShipPtr->ShipFacing)
 		{
 			StarShipPtr->cur_status_flags |= SHIP_AT_MAX_SPEED;
@@ -237,8 +275,8 @@ LeaveAutoPilot:
 		else
 		{
 			AccelerateDirection = -1;
-			udx = dx << 4;
-			udy = dy << 4;
+			udx = dx;// << 4;
+			udy = dy;// << 4;
 		}
 	}
 
@@ -247,16 +285,17 @@ LeaveAutoPilot:
 		COUNT dist;
 		SIZE speed, velocity_increment;
 
-		velocity_increment = WORLD_TO_VELOCITY (
-				StarShipPtr->RaceDescPtr->characteristics.thrust_increment);
+		velocity_increment = WORLD_TO_VELOCITY (StarShipPtr->RaceDescPtr->characteristics.thrust_increment);
 
 		if ((dist = square_root ((long)udx * udx + (long)udy * udy)) == 0)
 			dist = 1; /* prevent divide by zero */
 
 		speed = square_root ((long)dx * dx + (long)dy * dy);
+		
 		if (AccelerateDirection < 0)
 		{
 			dy = (speed / velocity_increment - 1) * velocity_increment;
+			
 			if (dy < speed - velocity_increment)
 				dy = speed - velocity_increment;
 			if ((speed = dy) < 0)
@@ -270,40 +309,44 @@ LeaveAutoPilot:
 
 			AccelerateDirection = 0;
 
-			max_velocity = WORLD_TO_VELOCITY (
-					StarShipPtr->RaceDescPtr->characteristics.max_thrust);
+			max_velocity = WORLD_TO_VELOCITY (StarShipPtr->RaceDescPtr->characteristics.max_thrust);
+
+            // In Orz Space, max speed is proportion to distance from bottom edge!
+            if (ENABLE_NON_EUCLIDEAN_ORZ_SPACE && GET_GAME_STATE (ORZ_SPACE_SIDE) > 1)
+            {
+                float prop = 1.0 - GLOBAL_SIS (log_y) / (float) MAX_X_LOGICAL;
+                max_velocity *= prop;
+            }
 
-			dy = (speed / velocity_increment + 1)
-					* velocity_increment;
+			dy = (speed / velocity_increment + 1) * velocity_increment;
+			
 			if (dy < speed + velocity_increment)
 				dy = speed + velocity_increment;
+			
 			if ((speed = dy) > max_velocity)
 			{
 				speed = max_velocity;
 				StarShipPtr->cur_status_flags |= SHIP_AT_MAX_SPEED;
 			}
 		}
-
-		dx = (SIZE)((long)udx * speed / (long)dist);
-		dy = (SIZE)((long)udy * speed / (long)dist);
-		SetVelocityComponents (&ElementPtr->velocity, dx, dy);
-
-		ElementPtr->thrust_wait =
-				StarShipPtr->RaceDescPtr->characteristics.thrust_wait;
+		
+		dtempx = (SDWORD)((long)udx * speed / (long)dist);
+		dtempy = (SDWORD)((long)udy * speed / (long)dist);
+		
+		SetVelocityComponents (&ElementPtr->velocity, dtempx, dtempy);
+		ElementPtr->thrust_wait =StarShipPtr->RaceDescPtr->characteristics.thrust_wait;
 	}
 }
 
-static void
-sis_hyper_postprocess (ELEMENT *ElementPtr)
+static void exp_hyper_postprocess (ELEMENT *ElementPtr)
 {
 	STARSHIP *StarShipPtr;
 
 	GLOBAL (velocity) = ElementPtr->velocity;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
-	if (((StarShipPtr->cur_status_flags & WEAPON) ||
-			PulsedInputState.menu[KEY_MENU_CANCEL])
-			&& StarShipPtr->special_counter == 0)
+	if ( ((StarShipPtr->cur_status_flags & WEAPON) || PulsedInputState.menu[KEY_MENU_CANCEL])
+			&& StarShipPtr->special_counter == 0 )
 	{
 #define MENU_DELAY 10
 		HyperspaceMenu ();
@@ -312,280 +355,569 @@ sis_hyper_postprocess (ELEMENT *ElementP
 	}
 }
 
-static void
-spawn_point_defense (ELEMENT *ElementPtr)
+// Stunner status effect.
+static void electrify (ELEMENT *ElementPtr)
 {
-	STARSHIP *StarShipPtr;
-
-	GetElementStarShip (ElementPtr, &StarShipPtr);
-	if (ElementPtr->state_flags & PLAYER_SHIP)
+	if (ElementPtr->hTarget == 0)
+	{
+		ElementPtr->life_span = 0;
+		ElementPtr->state_flags |= DISAPPEARING;
+	}
+	else
 	{
-		HELEMENT hDefense;
+		ELEMENT *eptr;
+		
+		LockElement (ElementPtr->hTarget, &eptr);
+
+		ElementPtr->next.location = eptr->next.location;
 
-		hDefense = AllocElement ();
-		if (hDefense)
+		if (ElementPtr->turn_wait)
 		{
-			ELEMENT *DefensePtr;
+			HELEMENT hEffect;
+			STARSHIP *StarShipPtr;
+			COUNT firstElectrifyFrame;
+			
+			if (RESOLUTION_FACTOR == 0)
+				firstElectrifyFrame = 15;
+			else
+				firstElectrifyFrame = 27;
+				
+			ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->current.image.frame);
+
+			if (GetFrameIndex (ElementPtr->next.image.frame) < firstElectrifyFrame)
+				ElementPtr->next.image.frame = SetAbsFrameIndex (ElementPtr->next.image.frame, firstElectrifyFrame);
 
-			LockElement (hDefense, &DefensePtr);
-			DefensePtr->playerNr = ElementPtr->playerNr;
-			DefensePtr->state_flags = APPEARING | NONSOLID | FINITE_LIFE;
-			DefensePtr->death_func = spawn_point_defense;
+			GetElementStarShip (eptr, &StarShipPtr);
+
+			// Disable energy regeneration. Do not prevent Androsynth Blazer degeneration.
+			if (!(eptr->current.image.farray == StarShipPtr->RaceDescPtr->ship_data.special))
+				StarShipPtr->energy_counter += 1;
+
+			// Disable propulsion and weapons.
+			StarShipPtr->ship_input_state = (StarShipPtr->ship_input_state &
+				~(LEFT | RIGHT | THRUST | WEAPON | SPECIAL));
+
+			hEffect = AllocElement ();
+			if (hEffect)
+			{
+				LockElement (hEffect, &eptr);
+			
+				eptr->state_flags = FINITE_LIFE | NONSOLID | CHANGING;
+				eptr->playerNr = ElementPtr->playerNr;
+				eptr->life_span = 1;
+				eptr->current = ElementPtr->current;
+				eptr->next = ElementPtr->next;
+				eptr->preprocess_func = electrify;
+				SetPrimType (&(GLOBAL (DisplayArray))[eptr->PrimIndex], STAMP_PRIM);
 			
-			GetElementStarShip (ElementPtr, &StarShipPtr);
-			SetElementStarShip (DefensePtr, StarShipPtr);
-			UnlockElement (hDefense);
+				GetElementStarShip (ElementPtr, &StarShipPtr);
+				SetElementStarShip (eptr, StarShipPtr);
+				eptr->hTarget = ElementPtr->hTarget;
+			
+				UnlockElement (hEffect);
+				PutElement (hEffect);
+			}
+		}
 
-			PutElement (hDefense);
+		UnlockElement (ElementPtr->hTarget);
+	}
+}
+
+// This is used to fluctuate the stunner.
+static void animate (ELEMENT *ElementPtr)
+{
+	ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->current.image.frame);
+	ElementPtr->state_flags |= CHANGING;
+}
+
+// This is used to fluctuate the blaster weapon.
+static void animate_blaster (ELEMENT *ElementPtr)
+{
+	if (GetFrameIndex (ElementPtr->current.image.frame) >= 3)
+		ElementPtr->next.image.frame = SetAbsFrameIndex (ElementPtr->current.image.frame, 0);
+	else
+		ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->current.image.frame);
+	
+	ElementPtr->state_flags |= CHANGING;
+}
+
+// Stun ball collision.
+static void stunner_collision (ELEMENT *ElementPtr0, POINT *pPt0, ELEMENT *ElementPtr1, POINT *pPt1)
+{
+	COUNT firstElectrifyFrame;
+	
+	if (RESOLUTION_FACTOR == 0)
+		firstElectrifyFrame = 15;
+	else
+		firstElectrifyFrame = 27;
+	
+	if (ElementPtr1->state_flags & PLAYER_SHIP)
+	{
+		HELEMENT hStunElement, hNextElement;
+		ELEMENT *StunPtr;
+		STARSHIP *StarShipPtr;
+
+		GetElementStarShip (ElementPtr0, &StarShipPtr);
+
+		// Check to see if the enemy ship is already electrified.
+		for (hStunElement = GetHeadElement ();
+			hStunElement; hStunElement = hNextElement)
+		{
+			LockElement (hStunElement, &StunPtr);
+			if (elementsOfSamePlayer(StunPtr, ElementPtr0)
+				&& (StunPtr->preprocess_func == electrify))
+			{
+				UnlockElement (hStunElement);
+				break;
+			}
+			hNextElement = GetSuccElement (StunPtr);
+			UnlockElement (hStunElement);
 		}
+
+		if (hStunElement || (hStunElement = AllocElement ()))
+		{
+			LockElement (hStunElement, &StunPtr);
+
+			// Put a status effect on the enemy ship if one is not already there.
+			if (StunPtr->state_flags == 0)
+			{
+				InsertElement (hStunElement, GetHeadElement ());
+
+				StunPtr->current = ElementPtr0->next;
+				StunPtr->current.image.frame = SetAbsFrameIndex (StunPtr->current.image.frame, firstElectrifyFrame);
+				StunPtr->next = StunPtr->current;
+				StunPtr->playerNr = ElementPtr0->playerNr;
+				StunPtr->state_flags = FINITE_LIFE | NONSOLID | CHANGING;
+				StunPtr->preprocess_func = electrify;
+				SetPrimType (&(GLOBAL (DisplayArray))[StunPtr->PrimIndex],	NO_PRIM);
+
+				SetElementStarShip (StunPtr, StarShipPtr);
+				GetElementStarShip (ElementPtr1, &StarShipPtr);
+				StunPtr->hTarget = StarShipPtr->hShip;
+			}
+
+			StunPtr->life_span = FULL_STUN_DURATION;
+			StunPtr->turn_wait = 1;
+			UnlockElement (hStunElement);
+		}
+
+		ElementPtr0->hit_points = 0;
+		ElementPtr0->life_span = 0;
+		ElementPtr0->state_flags |= DISAPPEARING | COLLISION | NONSOLID;
+	}
+	// Asteroids and planets break the stun ball.
+	else if (ElementPtr1->playerNr == NEUTRAL_PLAYER_NUM)
+	{
+		HELEMENT hBlastElement;
+
+		hBlastElement = weapon_collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
+		if (hBlastElement)
+		{
+			ELEMENT *BlastElementPtr;
+
+			LockElement (hBlastElement, &BlastElementPtr);
+			BlastElementPtr->life_span = 9;
+			BlastElementPtr->preprocess_func = animate;
+
+			BlastElementPtr->current.image.farray = ElementPtr0->next.image.farray;
+			BlastElementPtr->current.image.frame = SetAbsFrameIndex (BlastElementPtr->current.image.farray[0], firstElectrifyFrame);
+
+			ZeroVelocityComponents (&ElementPtr0->velocity);
+
+			UnlockElement (hBlastElement);
+		}
+	}
+	// Pass through enemy weapons. Sustain damage from them upon contact, but do not collide.
+}
+
+// Stunner explosion.
+static void shockwave (ELEMENT *ElementPtr)
+{
+	COUNT firstShockwaveFrame, lastShockwaveFrame, firstElectrifyFrame;
+	
+	if (RESOLUTION_FACTOR == 0)
+	{
+		firstShockwaveFrame = 3;
+		lastShockwaveFrame = 14;
+		firstElectrifyFrame = 15;
 	}
 	else
 	{
-		BOOLEAN PaidFor;
-		HELEMENT hObject, hNextObject;
-		ELEMENT *ShipPtr;
-		Color LaserColor;
-		static const Color ColorRange[] =
-		{
-			BUILD_COLOR (MAKE_RGB15_INIT (0x1F, 0x03, 0x00), 0x7F),
-			BUILD_COLOR (MAKE_RGB15_INIT (0x1F, 0x07, 0x00), 0x7E),
-			BUILD_COLOR (MAKE_RGB15_INIT (0x1F, 0x0A, 0x00), 0x7D),
-			BUILD_COLOR (MAKE_RGB15_INIT (0x1F, 0x0E, 0x00), 0x7C),
-			BUILD_COLOR (MAKE_RGB15_INIT (0x1F, 0x11, 0x00), 0x7B),
-			BUILD_COLOR (MAKE_RGB15_INIT (0x1F, 0x15, 0x00), 0x7A),
-			BUILD_COLOR (MAKE_RGB15_INIT (0x1F, 0x18, 0x00), 0x79),
-			BUILD_COLOR (MAKE_RGB15_INIT (0x1F, 0x1C, 0x00), 0x78),
-		};
-
-		PaidFor = FALSE;
-
-		LaserColor = ColorRange[
-				StarShipPtr->RaceDescPtr->characteristics.special_energy_cost
-				];
-		LockElement (StarShipPtr->hShip, &ShipPtr);
-		for (hObject = GetTailElement (); hObject; hObject = hNextObject)
-		{
-			ELEMENT *ObjectPtr;
-
-			LockElement (hObject, &ObjectPtr);
-			hNextObject = GetPredElement (ObjectPtr);
-			if (ObjectPtr != ShipPtr && CollidingElement (ObjectPtr) &&
-					!OBJECT_CLOAKED (ObjectPtr))
+		firstShockwaveFrame = 1;
+		lastShockwaveFrame = 26;
+		firstElectrifyFrame = 27;
+	}
+	
+	ZeroVelocityComponents (&ElementPtr->velocity);
+
+	ElementPtr->state_flags |= (FINITE_LIFE | NONSOLID | CHANGING);
+	
+	ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->current.image.frame);
+
+	if (GetFrameIndex (ElementPtr->next.image.frame) > lastShockwaveFrame 
+		|| GetFrameIndex (ElementPtr->next.image.frame) < firstShockwaveFrame)
+		ElementPtr->next.image.frame = SetAbsFrameIndex (ElementPtr->next.image.frame, firstShockwaveFrame);
+	
+	// A shockwave hit will occur at two different intervals.
+	if (ElementPtr->life_span == 6 || ElementPtr->life_span == 2)
+	{
+		HELEMENT hElement, hNextElement, hTarget;
+		STARSHIP *StarShipPtr, *EnemyStarShipPtr;
+
+		GetElementStarShip (ElementPtr, &StarShipPtr);
+		hTarget = 0;
+
+		// Cycle through all objects in the arena.
+		for (hElement = GetHeadElement ();
+			hElement != 0; hElement = hNextElement)
+		{
+			ELEMENT *ObjPtr;
+
+			LockElement (hElement, &ObjPtr);
+			hNextElement = GetSuccElement (ObjPtr);
+			if (CollidingElement (ObjPtr))
 			{
-#define LASER_RANGE (UWORD)100
 				SIZE delta_x, delta_y;
 
-				delta_x = ObjectPtr->next.location.x -
-						ShipPtr->next.location.x;
-				delta_y = ObjectPtr->next.location.y -
-						ShipPtr->next.location.y;
-				if (delta_x < 0)
+				// Distance check.
+				if ((delta_x = ObjPtr->next.location.x
+						- ElementPtr->next.location.x) < 0)
 					delta_x = -delta_x;
-				if (delta_y < 0)
+				if ((delta_y = ObjPtr->next.location.y
+						- ElementPtr->next.location.y) < 0)
 					delta_y = -delta_y;
 				delta_x = WORLD_TO_DISPLAY (delta_x);
 				delta_y = WORLD_TO_DISPLAY (delta_y);
-				if ((UWORD)delta_x <= LASER_RANGE &&
-						(UWORD)delta_y <= LASER_RANGE &&
-						(UWORD)delta_x * (UWORD)delta_x +
-						(UWORD)delta_y * (UWORD)delta_y <=
-						LASER_RANGE * LASER_RANGE)
+				
+				// Only pay attention to objects within the shockwave.
+				if ((ElementPtr->life_span == 6
+					&& delta_x <= SHOCKWAVE_RANGE_MID && delta_y <= SHOCKWAVE_RANGE_MID
+						&& ((long)(delta_x * delta_x) + (long)(delta_y * delta_y)) <=
+							(long)(SHOCKWAVE_RANGE_MID * SHOCKWAVE_RANGE_MID))
+				|| (ElementPtr->life_span == 2
+					&& delta_x <= SHOCKWAVE_RANGE_END && delta_y <= SHOCKWAVE_RANGE_END
+						&& ((long)(delta_x * delta_x) + (long)(delta_y * delta_y)) <=
+							(long)(SHOCKWAVE_RANGE_END * SHOCKWAVE_RANGE_END)))
 				{
-					HELEMENT hPointDefense;
-					LASER_BLOCK LaserBlock;
-
-					if (!PaidFor)
+					// Enemy ship check.
+					if ((ObjPtr->state_flags & PLAYER_SHIP)
+					    && !elementsOfSamePlayer(ElementPtr, ObjPtr))
 					{
-						if (!DeltaEnergy (ShipPtr,
-								-(StarShipPtr->RaceDescPtr->characteristics.special_energy_cost
-								<< 2)))
-							break;
-
-						ProcessSound (SetAbsSoundIndex (
-										/* POINT_DEFENSE_LASER */
-								StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 1), ElementPtr);
-						StarShipPtr->special_counter =
-								StarShipPtr->RaceDescPtr->characteristics.special_wait;
-						PaidFor = TRUE;
+						hTarget = hElement;
+						GetElementStarShip (ObjPtr, &EnemyStarShipPtr);
 					}
+				}
+			}
 
-					LaserBlock.cx = ShipPtr->next.location.x;
-					LaserBlock.cy = ShipPtr->next.location.y;
-					LaserBlock.face = 0;
-					LaserBlock.ex = ObjectPtr->next.location.x
-							- ShipPtr->next.location.x;
-					LaserBlock.ey = ObjectPtr->next.location.y
-							- ShipPtr->next.location.y;
-					LaserBlock.sender = ShipPtr->playerNr;
-					LaserBlock.flags = IGNORE_SIMILAR;
-					LaserBlock.pixoffs = 0;
-					LaserBlock.color = LaserColor;
-					hPointDefense = initialize_laser (&LaserBlock);
-					if (hPointDefense)
-					{
-						ELEMENT *PDPtr;
+			UnlockElement (hElement);
+		}
 
-						LockElement (hPointDefense, &PDPtr);
-						PDPtr->mass_points =
-								StarShipPtr->RaceDescPtr->characteristics.special_energy_cost;
-						SetElementStarShip (PDPtr, StarShipPtr);
-						PDPtr->hTarget = 0;
-						UnlockElement (hPointDefense);
+		if (hTarget) // Did the enemy ship get hit?
+		{
+			ELEMENT *StunPtr;
 
-						PutElement (hPointDefense);
-					}
+			// Check to see if the enemy ship is already electrified.
+			for (hElement = GetHeadElement ();
+				hElement; hElement = hNextElement)
+			{
+				LockElement (hElement, &StunPtr);
+				if (elementsOfSamePlayer(StunPtr, ElementPtr)
+					&& (StunPtr->preprocess_func == electrify))
+				{
+					UnlockElement (hElement);
+					break;
 				}
+				hNextElement = GetSuccElement (StunPtr);
+				UnlockElement (hElement);
+			}
+
+			if (hElement || (hElement = AllocElement ()))
+			{
+				LockElement (hElement, &StunPtr);
+
+				// Put a status effect on the enemy ship if one is not already there.
+				if (StunPtr->state_flags == 0)
+				{
+					InsertElement (hElement, GetHeadElement ());
+				
+					StunPtr->current = ElementPtr->next;
+					StunPtr->current.image.frame = SetAbsFrameIndex (StunPtr->current.image.frame, firstElectrifyFrame + 1);
+					StunPtr->next = StunPtr->current;
+					StunPtr->state_flags = FINITE_LIFE | NONSOLID | CHANGING;
+					StunPtr->playerNr = ElementPtr->playerNr;
+					StunPtr->preprocess_func = electrify;
+					StunPtr->collision_func = stunner_collision;
+					SetPrimType (&(GLOBAL (DisplayArray))[StunPtr->PrimIndex], NO_PRIM);
+
+					SetElementStarShip (StunPtr, StarShipPtr);
+					StunPtr->hTarget = EnemyStarShipPtr->hShip;
+				}
+
+				StunPtr->life_span = PARTIAL_STUN_DURATION;
+				StunPtr->turn_wait = 1;
+				UnlockElement (hElement);
 			}
-			UnlockElement (hObject);
 		}
-		UnlockElement (StarShipPtr->hShip);
+
+		UnlockElement (hTarget);
 	}
 }
 
-static void
-sis_battle_preprocess (ELEMENT *ElementPtr)
+// This code maintains the stun ball projectile.
+static void stunner_preprocess (ELEMENT *ElementPtr)
 {
 	STARSHIP *StarShipPtr;
+	COUNT lastStunballFrame;
+	
+	if (RESOLUTION_FACTOR == 0)
+		lastStunballFrame = 2;
+	else
+		lastStunballFrame = 0;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
-	if (StarShipPtr->RaceDescPtr->characteristics.special_energy_cost == 0)
+
+	ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->current.image.frame);
+	ElementPtr->state_flags |= CHANGING;
+	
+	if (GetFrameIndex (ElementPtr->current.image.frame) == lastStunballFrame)
+		ElementPtr->next.image.frame = SetAbsFrameIndex (ElementPtr->current.image.frame, 0);
+
+	if (StarShipPtr->cur_status_flags & SPECIAL)
 	{
-		StarShipPtr->cur_status_flags &= ~SPECIAL;
-		StarShipPtr->special_counter = 2;
+		++ElementPtr->life_span; // Keep it going while the key is pressed.
 	}
-	if (!(StarShipPtr->RaceDescPtr->ship_info.ship_flags
-			& (FIRES_FORE | FIRES_RIGHT | FIRES_AFT | FIRES_LEFT)))
+	else
 	{
-		StarShipPtr->cur_status_flags &= ~WEAPON;
-		StarShipPtr->weapon_counter = 2;
+		// Trigger stunner explosion.
+		ElementPtr->life_span = 13;
+		ElementPtr->preprocess_func = shockwave;
+
+		ProcessSound (SetAbsSoundIndex // Shockwave!
+					(StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 2), ElementPtr);
+
+		ElementPtr->current.image.frame = SetAbsFrameIndex (ElementPtr->current.image.frame, lastStunballFrame + 1);
 	}
 }
 
-static void
-sis_battle_postprocess (ELEMENT *ElementPtr)
+static void initialize_stunner (ELEMENT *ShipPtr)
 {
+	HELEMENT SMissile;
 	STARSHIP *StarShipPtr;
-
-	GetElementStarShip (ElementPtr, &StarShipPtr);
-	if ((StarShipPtr->cur_status_flags & SPECIAL)
-			&& StarShipPtr->special_counter == 0
-			&& StarShipPtr->RaceDescPtr->characteristics.special_energy_cost)
+	MISSILE_BLOCK MissileBlock;
+	
+	GetElementStarShip (ShipPtr, &StarShipPtr);
+	MissileBlock.cx = ShipPtr->next.location.x;
+	MissileBlock.cy = ShipPtr->next.location.y;
+	MissileBlock.farray = StarShipPtr->RaceDescPtr->ship_data.special;
+	MissileBlock.face = StarShipPtr->ShipFacing;
+	MissileBlock.index = 0;
+	MissileBlock.sender = ShipPtr->playerNr;
+	MissileBlock.flags = IGNORE_SIMILAR;
+	MissileBlock.pixoffs = STUNBALL_START_OFFSET;
+	MissileBlock.speed = STUNBALL_SPEED;
+	MissileBlock.hit_points = STUNBALL_HITS;
+	MissileBlock.damage = STUNBALL_DAMAGE;
+	MissileBlock.life = STUNBALL_LIFE;
+	MissileBlock.preprocess_func = stunner_preprocess;
+	MissileBlock.blast_offs = STUNBALL_BLAST_OFFSET;
+	SMissile = initialize_missile (&MissileBlock);
+	
+	if (SMissile)
 	{
-		spawn_point_defense (ElementPtr);
+		ELEMENT *StunballPtr;
+		
+		LockElement (SMissile, &StunballPtr);
+		SetElementStarShip (StunballPtr, StarShipPtr);
+		StunballPtr->death_func = NULL;
+		StunballPtr->collision_func = stunner_collision;
+		UnlockElement (SMissile);
+		PutElement (SMissile);
 	}
 }
 
-#define BLASTER_DAMAGE 2
+static COUNT
+initialize_teststunner (ELEMENT *ShipPtr, HELEMENT MissileArray[])
+{
+	STARSHIP *StarShipPtr;
+	MISSILE_BLOCK MissileBlock;
+	
+	GetElementStarShip (ShipPtr, &StarShipPtr);
+	MissileBlock.cx = ShipPtr->next.location.x;
+	MissileBlock.cy = ShipPtr->next.location.y;
+	MissileBlock.farray = StarShipPtr->RaceDescPtr->ship_data.special;
+	MissileBlock.face = StarShipPtr->ShipFacing;
+	MissileBlock.index = 0;
+	MissileBlock.sender = ShipPtr->playerNr;
+	MissileBlock.flags = IGNORE_SIMILAR;
+	MissileBlock.pixoffs = STUNBALL_START_OFFSET;
+	MissileBlock.speed = STUNBALL_SPEED;
+	MissileBlock.hit_points = STUNBALL_HITS;
+	MissileBlock.damage = STUNBALL_DAMAGE;
+	MissileBlock.life = STUNBALL_LIFE;
+	MissileBlock.preprocess_func = stunner_preprocess;
+	MissileBlock.blast_offs = STUNBALL_BLAST_OFFSET;
+	MissileArray[0] = initialize_missile (&MissileBlock);
+	
+	return (1);
+}
 
-static void
-blaster_collision (ELEMENT *ElementPtr0, POINT *pPt0,
-		ELEMENT *ElementPtr1, POINT *pPt1)
+// Melee-related postprocess.
+/* static void exp_battle_postprocess (ELEMENT *ElementPtr)
 {
-	HELEMENT hBlastElement;
+	STARSHIP *StarShipPtr;
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+} */
 
-	hBlastElement = weapon_collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
-	if (hBlastElement)
+// Melee-related preprocess.
+static void exp_battle_preprocess (ELEMENT *ElementPtr)
+{
+	STARSHIP *StarShipPtr;
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+
+	// Only let one stun ball out at a time, but allow special_counter to count down as normal.
+	if (StarShipPtr->special_counter == 1
+			&& (StarShipPtr->cur_status_flags & StarShipPtr->old_status_flags & SPECIAL))
+		++StarShipPtr->special_counter;
+
+	if ((StarShipPtr->cur_status_flags & SPECIAL)
+		&& StarShipPtr->special_counter == 0
+		&& StarShipPtr->RaceDescPtr->ship_info.energy_level >= SPECIAL_ENERGY_COST)
 	{
-		ELEMENT *BlastElementPtr;
+		initialize_stunner (ElementPtr);
 
-		LockElement (hBlastElement, &BlastElementPtr);
-		switch (ElementPtr0->mass_points)
-		{
-			case BLASTER_DAMAGE * 1:
-				BlastElementPtr->life_span = 2;
-				BlastElementPtr->current.image.frame =
-						SetAbsFrameIndex (ElementPtr0->current.image.frame, 0);
-				BlastElementPtr->preprocess_func = NULL;
-				break;
-			case BLASTER_DAMAGE * 2:
-				BlastElementPtr->life_span = 6;
-				BlastElementPtr->current.image.frame =
-						IncFrameIndex (ElementPtr0->current.image.frame);
-				break;
-			case BLASTER_DAMAGE * 3:
-				BlastElementPtr->life_span = 7;
-				BlastElementPtr->current.image.frame =
-						SetAbsFrameIndex (ElementPtr0->current.image.frame, 20);
-				break;
-		}
-		UnlockElement (hBlastElement);
+		ProcessSound (SetAbsSoundIndex // Launch stunner ball.
+			(StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 1), ElementPtr);
+
+		DeltaEnergy (ElementPtr, -SPECIAL_ENERGY_COST);
+		StarShipPtr->special_counter = SPECIAL_WAIT;
 	}
 }
 
-static void
-blaster_preprocess (ELEMENT *ElementPtr)
+static void blaster_collision (ELEMENT *ElementPtr0, POINT *pPt0, ELEMENT *ElementPtr1, POINT *pPt1)
 {
-	BYTE wait;
-
-	switch (ElementPtr->mass_points)
-	{
-		case BLASTER_DAMAGE * 1:
-			if (GetFrameIndex (ElementPtr->current.image.frame) < 8)
-			{
-				ElementPtr->next.image.frame =
-						IncFrameIndex (ElementPtr->current.image.frame);
-				ElementPtr->state_flags |= CHANGING;
-			}
-			break;
-		case BLASTER_DAMAGE * 3:
-			if (GetFrameIndex (ElementPtr->current.image.frame) < 19)
-				ElementPtr->next.image.frame =
-						IncFrameIndex (ElementPtr->current.image.frame);
-			else
-				ElementPtr->next.image.frame =
-						SetAbsFrameIndex (ElementPtr->current.image.frame, 16);
-			ElementPtr->state_flags |= CHANGING;
-			break;
-	}
+	HELEMENT hBlastElement;
 
-	if (LONIBBLE (ElementPtr->turn_wait))
-		--ElementPtr->turn_wait;
-	else if ((wait = HINIBBLE (ElementPtr->turn_wait)))
+	hBlastElement = weapon_collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
+	if (hBlastElement)
 	{
-		COUNT facing;
+		ELEMENT *BlastElementPtr;
 
-		facing = NORMALIZE_FACING (ANGLE_TO_FACING (
-				GetVelocityTravelAngle (&ElementPtr->velocity)));
-		if (TrackShip (ElementPtr, &facing) > 0)
-			SetVelocityVector (&ElementPtr->velocity, BLASTER_SPEED, facing);
+		LockElement (hBlastElement, &BlastElementPtr);
+		BlastElementPtr->life_span = 2;
+		BlastElementPtr->current.image.farray = ElementPtr0->next.image.farray;
+		BlastElementPtr->current.image.frame = SetAbsFrameIndex (ElementPtr0->current.image.frame, 0);
+		BlastElementPtr->preprocess_func = NULL;
 
-		ElementPtr->turn_wait = MAKE_BYTE (wait, wait);
+		UnlockElement (hBlastElement);
 	}
 }
 
-static COUNT
-initialize_blasters (ELEMENT *ShipPtr, HELEMENT BlasterArray[])
+static COUNT initialize_explorer_weaponry (ELEMENT *ShipPtr, HELEMENT BlasterArray[])
 {
-#define SIS_VERT_OFFSET 28
-#define SIS_HORZ_OFFSET 20
-#define BLASTER_HITS 2
-#define BLASTER_OFFSET 8
+	COUNT num_blasters;
+	
 	BYTE nt;
 	COUNT i;
 	STARSHIP *StarShipPtr;
-	SIS_DATA *SisData;
+	MISSILE_BLOCK MissileBlock[6];
+	MISSILE_BLOCK *lpMB;
 
+	
+	COORD cx, cy;
+	static COUNT blaster_side[NUM_SIDES]={0,0};
+	COUNT facing, angle;
+	SIZE offs_x, offs_y;
+	
+	num_blasters = 0;
+	
 	GetElementStarShip (ShipPtr, &StarShipPtr);
-	SisData = (SIS_DATA *) StarShipPtr->RaceDescPtr->data;
+	facing = StarShipPtr->ShipFacing;
+	angle = FACING_TO_ANGLE (facing);
 
-	nt = (BYTE)((4 - SisData->num_trackers) & 3);
-
-	for (i = 0; i < SisData->num_blasters; ++i)
+	blaster_side[ShipPtr->playerNr] = 
+		(blaster_side[ShipPtr->playerNr] + 1) % 2;
+	
+	cx = ShipPtr->next.location.x;
+	cy = ShipPtr->next.location.y;
+	
+	if(blaster_side[ShipPtr->playerNr])
 	{
-		MISSILE_BLOCK MissileBlock = SisData->MissileBlock[i];
-
-		MissileBlock.cx = ShipPtr->next.location.x;
-		MissileBlock.cy = ShipPtr->next.location.y;
-		MissileBlock.farray = StarShipPtr->RaceDescPtr->ship_data.weapon;
-		MissileBlock.sender = ShipPtr->playerNr;
-		MissileBlock.face = NORMALIZE_FACING (StarShipPtr->ShipFacing
-				+ MissileBlock.face);
+		offs_x = -SINE (angle, EXP_HORZ_OFFSET_2);
+		offs_y = COSINE (angle, EXP_HORZ_OFFSET_2);
+	}
+	else
+	{
+		offs_x = -SINE (angle, EXP_HORZ_OFFSET_3);
+		offs_y = COSINE (angle, EXP_HORZ_OFFSET_3);
+	}
+		
+	for (i = 0, lpMB = &MissileBlock[0]; i < 1; ++i)
+	{
+		BYTE which_gun;
 
-		BlasterArray[i] = initialize_missile (&MissileBlock);
-		if (BlasterArray[i])
+		// JMS: Chmmr Explorer always has weapon in nose weapon slot.
+		if(i == 0)
+			which_gun = GUN_WEAPON;
+		else
+			which_gun = 0;
+		
+		if (which_gun >= GUN_WEAPON && which_gun <= CANNON_WEAPON)
+		{
+			which_gun -= GUN_WEAPON - 1;
+			lpMB->cx = cx + offs_x;
+			lpMB->cy = cy + offs_y;
+			lpMB->farray = StarShipPtr->RaceDescPtr->ship_data.weapon;
+			lpMB->sender = ShipPtr->playerNr;
+			lpMB->flags = IGNORE_SIMILAR;
+			lpMB->blast_offs = BLASTER_OFFSET;
+			lpMB->speed = BLASTER_SPEED << RESOLUTION_FACTOR; // JMS_GFX
+			lpMB->preprocess_func = animate_blaster;
+			lpMB->hit_points = BLASTER_HITS * which_gun;
+			lpMB->damage = BLASTER_DAMAGE * which_gun;
+			lpMB->life = BLASTER_LIFE + ((BLASTER_LIFE >> 2) * (which_gun - 1));
+
+			// Which weapon graphics to use
+			if (which_gun == 1)
+				lpMB->index = 0;
+			else if (which_gun == 2)
+				lpMB->index = 9;
+			else
+				lpMB->index = 16;
+			
+			switch (i)
+			{
+				case 0: /* NOSE WEAPON */
+					lpMB->pixoffs = EXP_VERT_OFFSET;
+					lpMB->face = StarShipPtr->ShipFacing;
+					break;
+				case 1: /* SPREAD WEAPON */
+					lpMB->pixoffs = EXP_VERT_OFFSET;
+					lpMB->face = NORMALIZE_FACING (StarShipPtr->ShipFacing + 1);
+					lpMB[1] = lpMB[0];
+					++lpMB;
+					lpMB->face = NORMALIZE_FACING (StarShipPtr->ShipFacing - 1);
+					break;
+				case 2: /* SIDE WEAPON */
+					lpMB->pixoffs = EXP_HORZ_OFFSET;
+					lpMB->face = NORMALIZE_FACING (StarShipPtr->ShipFacing + ANGLE_TO_FACING (QUADRANT));
+					lpMB[1] = lpMB[0];
+					++lpMB;
+					lpMB->face = NORMALIZE_FACING (StarShipPtr->ShipFacing - ANGLE_TO_FACING (QUADRANT));
+					break;
+			}
+			
+			++lpMB;
+		}
+	}
+	
+	nt = (BYTE)((4 - 0) & 3); // Was (BYTE)((4 - num_trackers) & 3);
+	num_blasters = lpMB - &MissileBlock[0];
+	for (i = 0, lpMB = &MissileBlock[0]; i < num_blasters; ++i, ++lpMB)
+	{
+		if ((BlasterArray[i] = initialize_missile (lpMB)))
 		{
 			ELEMENT *BlasterPtr;
-
+			
 			LockElement (BlasterArray[i], &BlasterPtr);
 			BlasterPtr->collision_func = blaster_collision;
 			BlasterPtr->turn_wait = MAKE_BYTE (nt, nt);
@@ -593,38 +925,21 @@ initialize_blasters (ELEMENT *ShipPtr, H
 		}
 	
 	}
+	return (num_blasters);
 
-	return SisData->num_blasters;
 }
 
-static void
-sis_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
-		COUNT ConcernCounter)
+static void exp_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern, COUNT ConcernCounter)
 {
 	EVALUATE_DESC *lpEvalDesc;
 	STARSHIP *StarShipPtr;
-	SIS_DATA *SisData;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
-	SisData = (SIS_DATA *) StarShipPtr->RaceDescPtr->data;
 
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_WEAPON_INDEX];
 	if (lpEvalDesc->ObjectPtr)
 	{
-		if (StarShipPtr->RaceDescPtr->characteristics.special_energy_cost)
-		{
-			if (StarShipPtr->special_counter == 0
-					&& ((lpEvalDesc->ObjectPtr
-					&& lpEvalDesc->which_turn <= 2)
-					|| (ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr != NULL
-					&& ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn <= 4)))
-				StarShipPtr->ship_input_state |= SPECIAL;
-			else
-				StarShipPtr->ship_input_state &= ~SPECIAL;
-			lpEvalDesc->ObjectPtr = NULL;
-		}
-		else if (MANEUVERABILITY (&StarShipPtr->RaceDescPtr->cyborg_control)
-				< MEDIUM_SHIP
+		if (MANEUVERABILITY (&StarShipPtr->RaceDescPtr->cyborg_control) < (MEDIUM_SHIP << RESOLUTION_FACTOR) // JMS_GFX
 				&& lpEvalDesc->MoveState == ENTICE
 				&& (!(lpEvalDesc->ObjectPtr->state_flags & CREW_OBJECT)
 				|| lpEvalDesc->which_turn <= 8)
@@ -635,176 +950,99 @@ sis_intelligence (ELEMENT *ShipPtr, EVAL
 			lpEvalDesc->MoveState = PURSUE;
 	}
 
-	ship_intelligence (ShipPtr, ObjectsOfConcern, ConcernCounter);
-
+	// Act like Melnorme towards enemy ships: Chase most, entice ships with lazers
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
-	if (SisData->num_trackers
-			&& StarShipPtr->weapon_counter == 0
-			&& !(StarShipPtr->ship_input_state & WEAPON)
-			&& lpEvalDesc->ObjectPtr
-			&& lpEvalDesc->which_turn <= 16)
-	{
-		COUNT direction_facing;
-		SIZE delta_x, delta_y;
-		UWORD fire_flags, ship_flags;
-		COUNT facing;
-
-		delta_x = lpEvalDesc->ObjectPtr->current.location.x
-				- ShipPtr->current.location.x;
-		delta_y = lpEvalDesc->ObjectPtr->current.location.y
-				- ShipPtr->current.location.y;
-		direction_facing = NORMALIZE_FACING (
-				ANGLE_TO_FACING (ARCTAN (delta_x, delta_y)));
-
-		ship_flags = StarShipPtr->RaceDescPtr->ship_info.ship_flags;
-		for (fire_flags = FIRES_FORE, facing = StarShipPtr->ShipFacing;
-				fire_flags <= FIRES_LEFT;
-				fire_flags <<= 1, facing += QUADRANT)
-		{
-			if ((ship_flags & fire_flags) && NORMALIZE_FACING (
-					direction_facing - facing + ANGLE_TO_FACING (OCTANT)
-					) <= ANGLE_TO_FACING (QUADRANT))
-			{
-				StarShipPtr->ship_input_state |= WEAPON;
-				break;
-			}
-		}
-	}
-}
-
-static void
-InitWeaponSlots (RACE_DESC *RaceDescPtr, const BYTE *ModuleSlots)
-{
-#define SIS_VERT_OFFSET 28
-#define SIS_HORZ_OFFSET 20
-#define BLASTER_HITS 2
-#define BLASTER_OFFSET 8
-	COUNT i;
-	SIS_DATA *SisData = (SIS_DATA *) RaceDescPtr->data;
-	MISSILE_BLOCK *lpMB = SisData->MissileBlock;
-
-	SisData->num_blasters = 0;
-	for (i = 0; i < NUM_MODULE_SLOTS; ++i)
+	if (lpEvalDesc->ObjectPtr)
 	{
-		COUNT which_gun;
-
-		if (i == 3)
-			i = NUM_MODULE_SLOTS - 1;
-		
-		which_gun = ModuleSlots[(NUM_MODULE_SLOTS - 1) - i];
-		
-		if (which_gun < GUN_WEAPON || which_gun > CANNON_WEAPON)
-			continue; /* not a gun */
-
-		which_gun -= GUN_WEAPON - 1;
-		RaceDescPtr->characteristics.weapon_energy_cost +=
-				which_gun * 2;
-		
-		lpMB->flags = IGNORE_SIMILAR;
-		lpMB->blast_offs = BLASTER_OFFSET;
-		lpMB->speed = BLASTER_SPEED;
-		lpMB->preprocess_func = blaster_preprocess;
-		lpMB->hit_points = BLASTER_HITS * which_gun;
-		lpMB->damage = BLASTER_DAMAGE * which_gun;
-		lpMB->life = BLASTER_LIFE + ((BLASTER_LIFE >> 2) * (which_gun - 1));
-
-		if (which_gun == 1)
-			lpMB->index = 0;
-		else if (which_gun == 2)
-			lpMB->index = 9;
+		if (StarShipPtr->RaceDescPtr->ship_info.energy_level < MAX_ENERGY / 6)
+			lpEvalDesc->MoveState = AVOID;
+		else if (StarShipPtr->RaceDescPtr->ship_info.energy_level < MAX_ENERGY / 3)
+			lpEvalDesc->MoveState = ENTICE;
 		else
-			lpMB->index = 16;
-
-		switch (i)
 		{
-			case 0: /* NOSE WEAPON */
-				RaceDescPtr->ship_info.ship_flags |= FIRES_FORE;
-				lpMB->pixoffs = SIS_VERT_OFFSET;
-				lpMB->face = 0;
-				break;
-			case 1: /* SPREAD WEAPON */
-				RaceDescPtr->ship_info.ship_flags |= FIRES_FORE;
-				lpMB->pixoffs = SIS_VERT_OFFSET;
-				lpMB->face = +1;
-				/* copy it because there are two */
-				lpMB[1] = lpMB[0];
-				++lpMB;
-				++SisData->num_blasters;
-				lpMB->face = NORMALIZE_FACING (-1);
-				break;
-			case 2: /* SIDE WEAPON */
-				RaceDescPtr->ship_info.ship_flags |=
-						FIRES_LEFT | FIRES_RIGHT;
-				lpMB->pixoffs = SIS_HORZ_OFFSET;
-				lpMB->face = ANGLE_TO_FACING (QUADRANT);
-				/* copy it because there are two */
-				lpMB[1] = lpMB[0];
-				++lpMB;
-				++SisData->num_blasters;
-				lpMB->face = NORMALIZE_FACING (-ANGLE_TO_FACING (QUADRANT));
-				break;
-			case NUM_MODULE_SLOTS - 1: /* TAIL WEAPON */
-				RaceDescPtr->ship_info.ship_flags |= FIRES_AFT;
-				lpMB->pixoffs = SIS_VERT_OFFSET;
-				lpMB->face = ANGLE_TO_FACING (HALF_CIRCLE);
-				break;
+			STARSHIP *EnemyStarShipPtr;
+			
+			GetElementStarShip (lpEvalDesc->ObjectPtr, &EnemyStarShipPtr);
+			if (!(EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags & IMMEDIATE_WEAPON))
+				lpEvalDesc->MoveState = PURSUE;
 		}
-
-		++lpMB;
-		++SisData->num_blasters;
 	}
-}
-
-static void
-InitModuleSlots (RACE_DESC *RaceDescPtr, const BYTE *ModuleSlots)
-{
-	COUNT i;
-	COUNT num_trackers;
-	SIS_DATA *SisData = (SIS_DATA *) RaceDescPtr->data;
-
-	RaceDescPtr->ship_info.max_crew = 0;
-	num_trackers = 0;
-	for (i = 0; i < NUM_MODULE_SLOTS; ++i)
+	ship_intelligence (ShipPtr, ObjectsOfConcern, ConcernCounter);
+	
+	// JMS: Use special like Chenjesu uses its primary weapon
+	if (lpEvalDesc->ObjectPtr)
 	{
-		BYTE which_mod;
-
-		which_mod = ModuleSlots[(NUM_MODULE_SLOTS - 1) - i];
-		switch (which_mod)
+		HELEMENT h, hNext;
+		ELEMENT *StunnerPtr;
+		
+		h = (StarShipPtr->old_status_flags & SPECIAL) ? GetTailElement () : (HELEMENT)0;
+		for (; h; h = hNext)
 		{
-			case CREW_POD:
-				RaceDescPtr->ship_info.max_crew += CREW_POD_CAPACITY;
-				break;
-			case TRACKING_SYSTEM:
-				++num_trackers;
-				break;
-			case ANTIMISSILE_DEFENSE:
-				++RaceDescPtr->characteristics.special_energy_cost;
-				break;
-			case SHIVA_FURNACE:
-				++RaceDescPtr->characteristics.energy_regeneration;
-				break;
-			case DYNAMO_UNIT:
-				RaceDescPtr->characteristics.energy_wait -= 2;
-				if (RaceDescPtr->characteristics.energy_wait < 4)
-					RaceDescPtr->characteristics.energy_wait = 4;
-				break;
+			LockElement (h, &StunnerPtr);
+			hNext = GetPredElement (StunnerPtr);
+			if (!(StunnerPtr->state_flags & NONSOLID)
+				&& StunnerPtr->preprocess_func
+				&& StunnerPtr->life_span > 0
+				&& elementsOfSamePlayer (StunnerPtr, ShipPtr))
+			{
+				if (ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr)
+				{
+					COUNT which_turn;
+					
+					if ((which_turn = PlotIntercept (StunnerPtr, ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr,
+							StunnerPtr->life_span, (200 << RESOLUTION_FACTOR))) == 0
+						|| (which_turn == 1
+							&& PlotIntercept (StunnerPtr, ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr,
+							StunnerPtr->life_span, 0) == 0))
+						StarShipPtr->ship_input_state &= ~SPECIAL;
+					else if (StarShipPtr->weapon_counter == 0)
+					{
+						StarShipPtr->ship_input_state |= SPECIAL;
+						lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
+					}
+					
+					UnlockElement (h);
+					break;
+				}
+				hNext = 0;
+			}
+			UnlockElement (h);
+		}
+		
+		if (h == 0)
+		{
+			StarShipPtr->RaceDescPtr->init_weapon_func = initialize_teststunner;
+			
+			if (StarShipPtr->old_status_flags & SPECIAL)
+			{
+				StarShipPtr->ship_input_state &= ~SPECIAL;
+				if (lpEvalDesc == &ObjectsOfConcern[ENEMY_WEAPON_INDEX])
+					StarShipPtr->weapon_counter = 3;
+			}
+			else if (StarShipPtr->weapon_counter == 0
+					 && ship_weapons (ShipPtr, lpEvalDesc->ObjectPtr, (200 << RESOLUTION_FACTOR))
+					 && StarShipPtr->RaceDescPtr->ship_info.energy_level > MAX_ENERGY * 2 / 3) // JMS_GFX
+				StarShipPtr->ship_input_state |= SPECIAL;
+			
+			StarShipPtr->RaceDescPtr->init_weapon_func = initialize_explorer_weaponry;
 		}
-	}
-
-	if (num_trackers > MAX_TRACKING)
-		num_trackers = MAX_TRACKING;
-	RaceDescPtr->characteristics.weapon_energy_cost += num_trackers * 3;
-	SisData->num_trackers = num_trackers;
-	if (RaceDescPtr->characteristics.special_energy_cost)
-	{
-		RaceDescPtr->ship_info.ship_flags |= POINT_DEFENSE;
-		if (RaceDescPtr->characteristics.special_energy_cost > MAX_DEFENSE)
-			RaceDescPtr->characteristics.special_energy_cost = MAX_DEFENSE;
 	}
 }
 
-static void
-InitDriveSlots (RACE_DESC *RaceDescPtr, const BYTE *DriveSlots)
+// Ship configuration.
+/* static void InitModuleSlots (RACE_DESC *RaceDescPtr)
+{       
+        // JMS: Chmmr Explorer has 50 men max crew complement without modules, precursor vessel 0 as usual
+        // Also: Chmmr Explorer has one front firing gun equipped as default.
+        RaceDescPtr->ship_info.max_crew = EXPLORER_CREW_CAPACITY;
+        RaceDescPtr->ship_info.ship_flags |= FIRES_FORE;
+        RaceDescPtr->characteristics.weapon_energy_cost += 3;
+        RaceDescPtr->characteristics.special_energy_cost = 12;
+} */
+
+
+
+static void InitDriveSlots (RACE_DESC *RaceDescPtr, const BYTE *DriveSlots)
 {
 	COUNT i;
 
@@ -815,21 +1053,20 @@ InitDriveSlots (RACE_DESC *RaceDescPtr,
 		switch (DriveSlots[i])
 		{
 			case FUSION_THRUSTER:
-				RaceDescPtr->characteristics.max_thrust += 2;
+				RaceDescPtr->characteristics.max_thrust += 2 << RESOLUTION_FACTOR; // JMS_GFX
 				++RaceDescPtr->characteristics.thrust_wait;
 				break;
 		}
 	}
-	RaceDescPtr->characteristics.thrust_wait = (BYTE)(
-			THRUST_WAIT - (RaceDescPtr->characteristics.thrust_wait >> 1));
+	
+	RaceDescPtr->characteristics.thrust_wait = (BYTE)(THRUST_WAIT - (RaceDescPtr->characteristics.thrust_wait >> 1));
 	RaceDescPtr->characteristics.max_thrust =
 			((RaceDescPtr->characteristics.max_thrust /
 			RaceDescPtr->characteristics.thrust_increment) + 1)
 			* RaceDescPtr->characteristics.thrust_increment;
 }
 
-static void
-InitJetSlots (RACE_DESC *RaceDescPtr, const BYTE *JetSlots)
+static void InitJetSlots (RACE_DESC *RaceDescPtr, const BYTE *JetSlots)
 {
 	COUNT i;
 
@@ -844,77 +1081,95 @@ InitJetSlots (RACE_DESC *RaceDescPtr, co
 	}
 }
 
-RACE_DESC*
-init_sis (void)
+RACE_DESC* init_exp (void)
 {
 	RACE_DESC *RaceDescPtr;
 
 	COUNT i;
-	static RACE_DESC new_sis_desc;
+	static RACE_DESC new_exp_desc;
 
-	/* copy initial ship settings to new_sis_desc */
-	new_sis_desc = sis_desc;
-	
-	new_sis_desc.uninit_func = uninit_sis;
+	new_exp_desc = exp_desc;	
+	new_exp_desc.uninit_func = uninit_exp;
 
+	/* hyperspace */
 	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
 	{
 		for (i = 0; i < NUM_VIEWS; ++i)
 		{
-			new_sis_desc.ship_data.ship_rsc[i] = NULL_RESOURCE;
-			new_sis_desc.ship_data.weapon_rsc[i] = NULL_RESOURCE;
-			new_sis_desc.ship_data.special_rsc[i] = NULL_RESOURCE;
+			new_exp_desc.ship_data.ship_rsc[i] = NULL_RESOURCE;
+			new_exp_desc.ship_data.weapon_rsc[i] = NULL_RESOURCE;
+			new_exp_desc.ship_data.special_rsc[i] = NULL_RESOURCE;
 		}
-		new_sis_desc.ship_info.icons_rsc = NULL_RESOURCE;
-		new_sis_desc.ship_data.captain_control.captain_rsc = NULL_RESOURCE;
-		new_sis_desc.ship_data.victory_ditty_rsc = NULL_RESOURCE;
-		new_sis_desc.ship_data.ship_sounds_rsc = NULL_RESOURCE;
-
-		new_sis_desc.ship_data.ship_rsc[0] = SIS_HYPER_MASK_PMAP_ANIM;
+		
+		new_exp_desc.ship_info.icons_rsc = NULL_RESOURCE;
+		new_exp_desc.ship_data.captain_control.captain_rsc = NULL_RESOURCE;
+		new_exp_desc.ship_data.victory_ditty_rsc = NULL_RESOURCE;
+		new_exp_desc.ship_data.ship_sounds_rsc = NULL_RESOURCE;
+
+		// JMS: Hack: Blue ship in Orz space, green in quasi, red in hyperspace...
+		// Need to use separate set of frames for different colors since
+		// frame PNGs are in RGB mode instead of indexed color.
+		if (GET_GAME_STATE (ORZ_SPACE_SIDE) > 1)
+			new_exp_desc.ship_data.ship_rsc[0] = SIS_ORZ_MASK_PMAP_ANIM;
+		else if (GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1)
+			new_exp_desc.ship_data.ship_rsc[0] = SIS_QUASI_MASK_PMAP_ANIM;
+		else
+			new_exp_desc.ship_data.ship_rsc[0] = SIS_HYPER_MASK_PMAP_ANIM;
 
-		new_sis_desc.preprocess_func = sis_hyper_preprocess;
-		new_sis_desc.postprocess_func = sis_hyper_postprocess;
+		new_exp_desc.preprocess_func = exp_hyper_preprocess;
+		new_exp_desc.postprocess_func = exp_hyper_postprocess;
 
-		new_sis_desc.characteristics.max_thrust -= 4;
+		 // JMS_GFX
+		if (RESOLUTION_FACTOR > 0)
+		{
+			new_exp_desc.characteristics.max_thrust = (10 << RESOLUTION_FACTOR) - (4 << RESOLUTION_FACTOR); // JMS_GFX
+			new_exp_desc.characteristics.thrust_increment <<= RESOLUTION_FACTOR;
+		}
+		else
+			new_exp_desc.characteristics.max_thrust -= 4;
 	}
-	else
+	/* Melee fight */
+	else 
 	{
-		new_sis_desc.preprocess_func = sis_battle_preprocess;
-		new_sis_desc.postprocess_func = sis_battle_postprocess;
-		new_sis_desc.init_weapon_func = initialize_blasters;
-		new_sis_desc.cyborg_control.intelligence_func = sis_intelligence;
-
-		if (GET_GAME_STATE (CHMMR_BOMB_STATE) == 3)
-			SET_GAME_STATE (BOMB_CARRIER, 1);
+		new_exp_desc.preprocess_func = exp_battle_preprocess;
+		// new_exp_desc.postprocess_func = exp_battle_postprocess;
+		new_exp_desc.init_weapon_func = initialize_explorer_weaponry;
+		new_exp_desc.cyborg_control.intelligence_func = exp_intelligence;
 	}
 
-	new_sis_desc.data = (intptr_t) HCalloc (sizeof (SIS_DATA));
-	InitModuleSlots (&new_sis_desc, GLOBAL_SIS (ModuleSlots));
-	InitWeaponSlots (&new_sis_desc, GLOBAL_SIS (ModuleSlots));
-	InitDriveSlots (&new_sis_desc, GLOBAL_SIS (DriveSlots));
-	InitJetSlots (&new_sis_desc, GLOBAL_SIS (JetSlots));
+	InitDriveSlots(&new_exp_desc, GLOBAL_SIS (DriveSlots));
+	InitJetSlots(&new_exp_desc, GLOBAL_SIS (JetSlots));
+	
+	// JMS: Give the explorer some stats so it won't be slow as fuck in supermelee
+	// and does not depend on the thruster/jet numbers in adventure mode
+	if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == CHMMR_EXPLORER_SHIP)
+	{
+		new_exp_desc.characteristics.max_thrust = EXPLORER_MAX_THRUST << RESOLUTION_FACTOR;
+		new_exp_desc.characteristics.thrust_wait = EXPLORER_THRUST_WAIT;
+		new_exp_desc.characteristics.thrust_increment = EXPLORER_THRUST_INCREMENT << RESOLUTION_FACTOR;
+		new_exp_desc.characteristics.turn_wait = EXPLORER_TURN_WAIT;
+	}
 	
 	if (LOBYTE (GLOBAL (CurrentActivity)) == SUPER_MELEE)
 	{
-		new_sis_desc.ship_info.crew_level = new_sis_desc.ship_info.max_crew;
+		new_exp_desc.ship_info.crew_level = new_exp_desc.ship_info.max_crew;
 	}
 	else
 	{
 		// Count the captain too.
-		new_sis_desc.ship_info.max_crew++;
-		new_sis_desc.ship_info.crew_level = GLOBAL_SIS (CrewEnlisted) + 1;
-		new_sis_desc.ship_info.ship_flags |= PLAYER_CAPTAIN;
+		new_exp_desc.ship_info.max_crew++;
+		new_exp_desc.ship_info.crew_level = GLOBAL_SIS (CrewEnlisted) + 1;
+		new_exp_desc.ship_info.ship_flags |= PLAYER_CAPTAIN;
 	}
 	
-	new_sis_desc.ship_info.energy_level = new_sis_desc.ship_info.max_energy;
+	new_exp_desc.ship_info.energy_level = new_exp_desc.ship_info.max_energy;
 
-	RaceDescPtr = &new_sis_desc;
+	RaceDescPtr = &new_exp_desc;
 
 	return (RaceDescPtr);
 }
 
-void
-uninit_sis (RACE_DESC *pRaceDesc)
+void uninit_exp (RACE_DESC *pRaceDesc)
 {
 	if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
 	{
@@ -926,5 +1181,3 @@ uninit_sis (RACE_DESC *pRaceDesc)
 	HFree ((void *)pRaceDesc->data);
 	pRaceDesc->data = 0;
 }
-
-
diff -ruNp src.orig/uqm/ships/sis_ship/sis_ship.h src/uqm/ships/sis_ship/sis_ship.h
--- src.orig/uqm/ships/sis_ship/sis_ship.h	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/sis_ship/sis_ship.h	2017-11-01 15:31:05 -0700
@@ -17,7 +17,7 @@
 #ifndef SIS_SHIP_H
 #define SIS_SHIP_H
 
-RACE_DESC *init_sis (void);
+RACE_DESC *init_exp (void);
 
 #endif  /* SIS_SHIP_H */
 
diff -ruNp src.orig/uqm/ships/slykohr/Makeinfo src/uqm/ships/slykohr/Makeinfo
--- src.orig/uqm/ships/slykohr/Makeinfo	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/slykohr/Makeinfo	2017-11-01 15:31:05 -0700
@@ -0,0 +1 @@
+uqm_CFILES="slykohr.c"
diff -ruNp src.orig/uqm/ships/slykohr/icode.h src/uqm/ships/slykohr/icode.h
--- src.orig/uqm/ships/slykohr/icode.h	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/slykohr/icode.h	2017-11-01 15:31:05 -0700
@@ -0,0 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
+#define SLYLANDRO_KOHRAH_CODE "ship.slykohr.code"
diff -ruNp src.orig/uqm/ships/slykohr/resinst.h src/uqm/ships/slykohr/resinst.h
--- src.orig/uqm/ships/slykohr/resinst.h	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/slykohr/resinst.h	2017-11-01 15:31:05 -0700
@@ -0,0 +1,17 @@
+#define BUZZSAW_BIG_MASK_PMAP_ANIM "ship.slykohr.graphics.buz.large"
+#define BUZZSAW_MED_MASK_PMAP_ANIM "ship.slykohr.graphics.buz.medium"
+#define BUZZSAW_SML_MASK_PMAP_ANIM "ship.slykohr.graphics.buz.small"
+#define GAS_BIG_MASK_PMAP_ANIM "ship.slykohr.graphics.gas.large"
+#define GAS_MED_MASK_PMAP_ANIM "ship.slykohr.graphics.gas.medium"
+#define GAS_SML_MASK_PMAP_ANIM "ship.slykohr.graphics.gas.small"
+#define KOHR_AH_BIG_MASK_PMAP_ANIM "ship.slykohr.graphics.blackurq.large"
+#define KOHR_AH_ICON_MASK_PMAP_ANIM "ship.slykohr.icons"
+#define KOHR_AH_MED_MASK_PMAP_ANIM "ship.slykohr.graphics.blackurq.medium"
+#define KOHR_AH_MICON_MASK_PMAP_ANIM "ship.slykohr.meleeicons"
+#define KOHR_AH_SML_MASK_PMAP_ANIM "ship.slykohr.graphics.blackurq.small"
+#define SLYLANDRO_KOHRAH_CAPTAIN_MASK_PMAP_ANIM "ship.slykohr.graphics.captain"
+#define SLYLANDRO_KOHRAH_RACE_STRINGS "ship.slykohr.text"
+#define KOHR_AH_SHIP_SOUNDS "ship.slykohr.sounds"
+#define KOHR_AH_VICTORY_SONG "ship.slykohr.ditty"
+
+#include "icode.h"
diff -ruNp src.orig/uqm/ships/slykohr/slykohr.c src/uqm/ships/slykohr/slykohr.c
--- src.orig/uqm/ships/slykohr/slykohr.c	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/slykohr/slykohr.c	2017-11-01 15:31:05 -0700
@@ -0,0 +1,771 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "../ship.h"
+#include "slykohr.h"
+#include "resinst.h"
+
+#include "uqm/battle.h"
+#include "uqm/globdata.h"
+
+
+#define MAX_CREW MAX_CREW_SIZE
+#define MAX_ENERGY MAX_ENERGY_SIZE
+#define ENERGY_REGENERATION 1
+#define WEAPON_ENERGY_COST 6
+#define SPECIAL_ENERGY_COST (MAX_ENERGY_SIZE / 2)
+#define ENERGY_WAIT 4
+#define MAX_THRUST 30
+#define THRUST_INCREMENT 6
+#define TURN_WAIT 4
+#define THRUST_WAIT 6
+#define WEAPON_WAIT 6
+#define SPECIAL_WAIT 9
+
+#define SHIP_MASS 10
+#define MISSILE_SPEED (64 << RESOLUTION_FACTOR) // JMS_GFX
+#define MISSILE_LIFE 64 /* actually, it's as long as you
+										 * hold the button down.
+										 */
+static RACE_DESC slylandro_kohrah_desc =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		30, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		SLYLANDRO_KOHRAH_RACE_STRINGS,
+		KOHR_AH_ICON_MASK_PMAP_ANIM,
+		KOHR_AH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		4000 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			9999,9999,
+		},
+	},
+	{
+		MAX_THRUST,
+		THRUST_INCREMENT,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			KOHR_AH_BIG_MASK_PMAP_ANIM,
+			KOHR_AH_MED_MASK_PMAP_ANIM,
+			KOHR_AH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BUZZSAW_BIG_MASK_PMAP_ANIM,
+			BUZZSAW_MED_MASK_PMAP_ANIM,
+			BUZZSAW_SML_MASK_PMAP_ANIM,
+		},
+		{
+			GAS_BIG_MASK_PMAP_ANIM,
+			GAS_MED_MASK_PMAP_ANIM,
+			GAS_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SLYLANDRO_KOHRAH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		KOHR_AH_VICTORY_SONG,
+		KOHR_AH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_2XRES 60
+#define THRUST_INCREMENT_2XRES 12
+
+// JMS_GFX
+static RACE_DESC slylandro_kohrah_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		30, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		SLYLANDRO_KOHRAH_RACE_STRINGS,
+		KOHR_AH_ICON_MASK_PMAP_ANIM,
+		KOHR_AH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		4000 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			9999,9999,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			KOHR_AH_BIG_MASK_PMAP_ANIM,
+			KOHR_AH_MED_MASK_PMAP_ANIM,
+			KOHR_AH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BUZZSAW_BIG_MASK_PMAP_ANIM,
+			BUZZSAW_MED_MASK_PMAP_ANIM,
+			BUZZSAW_SML_MASK_PMAP_ANIM,
+		},
+		{
+			GAS_BIG_MASK_PMAP_ANIM,
+			GAS_MED_MASK_PMAP_ANIM,
+			GAS_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SLYLANDRO_KOHRAH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		KOHR_AH_VICTORY_SONG,
+		KOHR_AH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 120
+#define THRUST_INCREMENT_4XRES 24
+
+// JMS_GFX
+static RACE_DESC slylandro_kohrah_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		30, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		SLYLANDRO_KOHRAH_RACE_STRINGS,
+		KOHR_AH_ICON_MASK_PMAP_ANIM,
+		KOHR_AH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		4000 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			9999,9999,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			KOHR_AH_BIG_MASK_PMAP_ANIM,
+			KOHR_AH_MED_MASK_PMAP_ANIM,
+			KOHR_AH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BUZZSAW_BIG_MASK_PMAP_ANIM,
+			BUZZSAW_MED_MASK_PMAP_ANIM,
+			BUZZSAW_SML_MASK_PMAP_ANIM,
+		},
+		{
+			GAS_BIG_MASK_PMAP_ANIM,
+			GAS_MED_MASK_PMAP_ANIM,
+			GAS_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SLYLANDRO_KOHRAH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		KOHR_AH_VICTORY_SONG,
+		KOHR_AH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+#define SAW_RATE 0
+#define MAX_SAWS 8
+
+static void
+spin_preprocess (ELEMENT *ElementPtr)
+{
+	ELEMENT *ShipPtr;
+	STARSHIP *StarShipPtr;
+
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+	LockElement (StarShipPtr->hShip, &ShipPtr);
+	if (ShipPtr->crew_level && ++StarShipPtr->RaceDescPtr->characteristics.special_wait > MAX_SAWS)
+	{
+		ElementPtr->life_span = 1;
+		ElementPtr->state_flags |= DISAPPEARING;
+	}
+	else
+	{
+		++ElementPtr->life_span;
+		if (ElementPtr->turn_wait)
+			--ElementPtr->turn_wait;
+		else
+		{
+#define LAST_SPIN_INDEX 1
+			if (GetFrameIndex (ElementPtr->current.image.frame) < LAST_SPIN_INDEX)
+				ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->current.image.frame);
+			else
+				ElementPtr->next.image.frame = SetAbsFrameIndex (ElementPtr->current.image.frame, 0);
+			
+			ElementPtr->state_flags |= CHANGING;
+			ElementPtr->turn_wait = SAW_RATE;
+		}
+	}
+	UnlockElement (StarShipPtr->hShip);
+}
+
+#define TRACK_WAIT 4
+
+static void
+buzztrack_preprocess (ELEMENT *ElementPtr)
+{
+	if (ElementPtr->thrust_wait)
+		--ElementPtr->thrust_wait;
+	else
+	{
+		COUNT facing = 0;
+
+		if (ElementPtr->hTarget == 0
+				&& TrackShip (ElementPtr, &facing) < 0)
+		{
+			ZeroVelocityComponents (&ElementPtr->velocity);
+		}
+		else
+		{
+#define ACTIVATE_RANGE (224 << RESOLUTION_FACTOR) // JMS_GFX /* Originally SPACE_WIDTH */
+			SIZE delta_x, delta_y;
+			ELEMENT *eptr;
+
+			LockElement (ElementPtr->hTarget, &eptr);
+			delta_x = eptr->current.location.x
+					- ElementPtr->current.location.x;
+			delta_y = eptr->current.location.y
+					- ElementPtr->current.location.y;
+			UnlockElement (ElementPtr->hTarget);
+			delta_x = WRAP_DELTA_X (delta_x);
+			delta_y = WRAP_DELTA_Y (delta_y);
+			facing = NORMALIZE_FACING (
+					ANGLE_TO_FACING (ARCTAN (delta_x, delta_y))
+					);
+
+			if (delta_x < 0)
+				delta_x = -delta_x;
+			if (delta_y < 0)
+				delta_y = -delta_y;
+			delta_x = WORLD_TO_DISPLAY (delta_x);
+			delta_y = WORLD_TO_DISPLAY (delta_y);
+			if (delta_x >= ACTIVATE_RANGE
+					|| delta_y >= ACTIVATE_RANGE
+					|| (DWORD)((UWORD)delta_x * delta_x)
+					+ (DWORD)((UWORD)delta_y * delta_y) >=
+					(DWORD)ACTIVATE_RANGE * ACTIVATE_RANGE)
+			{
+				ZeroVelocityComponents (&ElementPtr->velocity);
+			}
+			else
+			{
+				ElementPtr->thrust_wait = TRACK_WAIT;
+				SetVelocityVector (&ElementPtr->velocity, DISPLAY_TO_WORLD (2 << RESOLUTION_FACTOR), facing);
+			}
+		}
+	}
+
+	spin_preprocess (ElementPtr);
+}
+
+static void
+decelerate_preprocess (ELEMENT *ElementPtr)
+{
+	SIZE dx, dy;
+
+	GetCurrentVelocityComponents (&ElementPtr->velocity, &dx, &dy);
+	dx /= 2;
+	dy /= 2;
+	SetVelocityComponents (&ElementPtr->velocity, dx, dy);
+	if (dx == 0 && dy == 0)
+	{
+		ElementPtr->preprocess_func = buzztrack_preprocess;
+	}
+
+	spin_preprocess (ElementPtr);
+}
+
+static void
+splinter_preprocess (ELEMENT *ElementPtr)
+{
+	ElementPtr->next.image.frame =
+			IncFrameIndex (ElementPtr->current.image.frame);
+	ElementPtr->state_flags |= CHANGING;
+}
+
+static void
+buzzsaw_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
+{
+	weapon_collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
+
+	if (ElementPtr0->state_flags & DISAPPEARING)
+	{
+		ElementPtr0->state_flags &= ~DISAPPEARING;
+		ElementPtr0->state_flags |= NONSOLID | CHANGING;
+		ElementPtr0->life_span = 5;
+		ElementPtr0->next.image.frame =
+				SetAbsFrameIndex (ElementPtr0->current.image.frame, 2);
+
+		ElementPtr0->preprocess_func = splinter_preprocess;
+	}
+}
+
+static void
+buzzsaw_preprocess (ELEMENT *ElementPtr)
+{
+	STARSHIP *StarShipPtr;
+
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+	if (!(StarShipPtr->cur_status_flags & WEAPON))
+	{
+		ElementPtr->life_span >>= 1;
+		ElementPtr->preprocess_func = decelerate_preprocess;
+	}
+
+	spin_preprocess (ElementPtr);
+}
+
+static void
+buzzsaw_postprocess (ELEMENT *ElementPtr)
+{
+	HELEMENT hElement;
+
+	ElementPtr->postprocess_func = 0;
+	hElement = AllocElement ();
+	if (hElement)
+	{
+		COUNT primIndex;
+		ELEMENT *ListElementPtr;
+		STARSHIP *StarShipPtr;
+
+		LockElement (hElement, &ListElementPtr);
+		primIndex = ListElementPtr->PrimIndex;
+		*ListElementPtr = *ElementPtr;
+		ListElementPtr->PrimIndex = primIndex;
+		(GLOBAL (DisplayArray))[primIndex] =
+				(GLOBAL (DisplayArray))[ElementPtr->PrimIndex];
+		ListElementPtr->current = ListElementPtr->next;
+		InitIntersectStartPoint (ListElementPtr);
+		InitIntersectEndPoint (ListElementPtr);
+		ListElementPtr->state_flags = (ListElementPtr->state_flags
+				& ~(PRE_PROCESS | CHANGING | APPEARING))
+				| POST_PROCESS;
+		UnlockElement (hElement);
+
+		GetElementStarShip (ElementPtr, &StarShipPtr);
+		LockElement (StarShipPtr->hShip, &ListElementPtr);
+		InsertElement (hElement, GetSuccElement (ListElementPtr));
+		UnlockElement (StarShipPtr->hShip);
+
+		ElementPtr->life_span = 0;
+	}
+}
+
+static COUNT
+initialize_buzzsaw (ELEMENT *ShipPtr, HELEMENT SawArray[])
+{
+#define MISSILE_HITS 10
+#define MISSILE_DAMAGE 4
+#define MISSILE_OFFSET (9 << RESOLUTION_FACTOR) // JMS_GFX
+#define KOHR_AH_OFFSET (28 << RESOLUTION_FACTOR) // JMS_GFX
+	STARSHIP *StarShipPtr;
+	MISSILE_BLOCK MissileBlock;
+
+	GetElementStarShip (ShipPtr, &StarShipPtr);
+	MissileBlock.cx = ShipPtr->next.location.x;
+	MissileBlock.cy = ShipPtr->next.location.y;
+	MissileBlock.farray = StarShipPtr->RaceDescPtr->ship_data.weapon;
+	MissileBlock.face = StarShipPtr->ShipFacing;
+	MissileBlock.index = 0;
+	MissileBlock.sender = ShipPtr->playerNr;
+	MissileBlock.flags = IGNORE_SIMILAR;
+	MissileBlock.pixoffs = KOHR_AH_OFFSET;
+	MissileBlock.speed = MISSILE_SPEED; // JMS_GFX
+	MissileBlock.hit_points = MISSILE_HITS;
+	MissileBlock.damage = MISSILE_DAMAGE;
+	MissileBlock.life = MISSILE_LIFE;
+	MissileBlock.preprocess_func = buzzsaw_preprocess;
+	MissileBlock.blast_offs = MISSILE_OFFSET;
+	SawArray[0] = initialize_missile (&MissileBlock);
+
+	if (SawArray[0])
+	{
+		ELEMENT *SawPtr;
+
+		LockElement (SawArray[0], &SawPtr);
+		SawPtr->turn_wait = SAW_RATE;
+		SawPtr->thrust_wait = 0;
+		SawPtr->postprocess_func = buzzsaw_postprocess;
+		SawPtr->collision_func = buzzsaw_collision;
+		UnlockElement (SawArray[0]);
+	}
+
+	return (1);
+}
+
+static void
+slylandro_kohrah_escape (STARSHIP *StarShipPtr)
+{
+	ELEMENT *ElementPtr;
+	
+	SET_GAME_STATE(SLYLANDRO_KOHRAH_PANIC, 1);
+	
+	LockElement (StarShipPtr->hShip, &ElementPtr);
+	if (GetPrimType (&DisplayArray[ElementPtr->PrimIndex]) == STAMP_PRIM
+		&& ElementPtr->life_span == NORMAL_LIFE
+		&& !(ElementPtr->state_flags & FINITE_LIFE)
+		&& ElementPtr->mass_points != MAX_SHIP_MASS * 10
+		&& !(ElementPtr->state_flags & APPEARING))
+	{
+		extern void flee_preprocess (ELEMENT *);
+		
+		// JMS: battle_counter 1 instead of 0, since we're dealing with computer's fleet here, not the player's.
+		battle_counter[1]--;
+		
+		// JMS: This is an ugly way of telling the game that enemy ship escaped, not exploded...
+		SET_GAME_STATE (ENEMY_ESCAPE_OCCURRED, 1);
+		
+		ElementPtr->turn_wait = 3;
+		ElementPtr->thrust_wait = MAKE_BYTE (4, 0);
+		ElementPtr->preprocess_func = flee_preprocess;
+		ElementPtr->mass_points = MAX_SHIP_MASS * 10;
+		ZeroVelocityComponents (&ElementPtr->velocity);
+		StarShipPtr->cur_status_flags &=
+		~(SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED);
+		
+		SetPrimColor (&DisplayArray[ElementPtr->PrimIndex],
+					  BUILD_COLOR (MAKE_RGB15 (0x0B, 0x00, 0x00), 0x2E));
+		SetPrimType (&DisplayArray[ElementPtr->PrimIndex], STAMPFILL_PRIM);
+		
+		StarShipPtr->ship_input_state = 0;
+	}
+	UnlockElement (StarShipPtr->hShip);
+}
+
+static void
+slylandro_kohrah_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+		COUNT ConcernCounter)
+{
+	EVALUATE_DESC *lpEvalDesc;
+	STARSHIP *StarShipPtr;
+
+	lpEvalDesc = &ObjectsOfConcern[ENEMY_WEAPON_INDEX];
+	if (lpEvalDesc->ObjectPtr
+			&& lpEvalDesc->MoveState == ENTICE
+			&& (lpEvalDesc->ObjectPtr->state_flags & CREW_OBJECT)
+			&& lpEvalDesc->which_turn <= 8)
+		lpEvalDesc->MoveState = PURSUE;
+
+	ship_intelligence (ShipPtr,
+			ObjectsOfConcern, ConcernCounter);
+
+	GetElementStarShip (ShipPtr, &StarShipPtr);
+	StarShipPtr->ship_input_state &= ~SPECIAL;
+
+	// JMS: Slylandro-kohrahs will escape from battle ASAP.
+	slylandro_kohrah_escape(StarShipPtr);	
+	
+	if (StarShipPtr->special_counter == 0
+			&& StarShipPtr->RaceDescPtr->ship_info.energy_level >= SPECIAL_ENERGY_COST
+			&& lpEvalDesc->ObjectPtr
+			&& lpEvalDesc->which_turn <= 8)
+		StarShipPtr->ship_input_state |= SPECIAL;
+
+	lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
+	if (lpEvalDesc->ObjectPtr)
+	{
+#define FRAGMENT_LIFE 10
+#define FRAGMENT_SPEED MISSILE_SPEED
+#define FRAGMENT_RANGE (FRAGMENT_LIFE * FRAGMENT_SPEED)
+		HELEMENT h, hNext;
+		ELEMENT *BuzzSawPtr;
+
+		h = (StarShipPtr->old_status_flags & WEAPON) ?
+				GetSuccElement (ShipPtr) : (HELEMENT)0;
+		for (; h; h = hNext)
+		{
+			LockElement (h, &BuzzSawPtr);
+			hNext = GetSuccElement (BuzzSawPtr);
+			if (!(BuzzSawPtr->state_flags & NONSOLID)
+					&& BuzzSawPtr->next.image.farray == StarShipPtr->RaceDescPtr->ship_data.weapon
+					&& BuzzSawPtr->life_span > MISSILE_LIFE * 3 / 4
+			    && elementsOfSamePlayer(BuzzSawPtr, ShipPtr))
+			{
+				{
+					//COUNT which_turn;
+
+					if (!PlotIntercept (BuzzSawPtr,
+							lpEvalDesc->ObjectPtr, BuzzSawPtr->life_span,
+							FRAGMENT_RANGE / 2))
+						StarShipPtr->ship_input_state &= ~WEAPON;
+					else if (StarShipPtr->weapon_counter == 0)
+						StarShipPtr->ship_input_state |= WEAPON;
+
+					UnlockElement (h);
+					break;
+				}
+				hNext = 0;
+			}
+			UnlockElement (h);
+		}
+
+		if (h == 0)
+		{
+			if (StarShipPtr->old_status_flags & WEAPON)
+				StarShipPtr->ship_input_state &= ~WEAPON;
+			else if (StarShipPtr->weapon_counter == 0
+					&& ship_weapons (ShipPtr, lpEvalDesc->ObjectPtr, FRAGMENT_RANGE / 2))
+				StarShipPtr->ship_input_state |= WEAPON;
+
+			if (StarShipPtr->special_counter == 0
+					&& !(StarShipPtr->ship_input_state & WEAPON)
+					&& lpEvalDesc->which_turn <= 8
+					&& (StarShipPtr->ship_input_state & (LEFT | RIGHT))
+					&& StarShipPtr->RaceDescPtr->ship_info.energy_level >=
+					SPECIAL_ENERGY_COST)
+				StarShipPtr->ship_input_state |= SPECIAL;
+		}
+	}
+}
+
+#define GAS_RATE 2
+
+static void
+gas_cloud_preprocess (ELEMENT *ElementPtr)
+{
+	if (ElementPtr->turn_wait)
+		--ElementPtr->turn_wait;
+	else
+	{
+		ElementPtr->next.image.frame =
+				IncFrameIndex (ElementPtr->current.image.frame);
+		ElementPtr->state_flags |= CHANGING;
+
+		ElementPtr->turn_wait = GAS_RATE;
+	}
+}
+
+#define GAS_DAMAGE 3
+
+static void
+gas_cloud_collision (ELEMENT *ElementPtr0, POINT *pPt0,
+		ELEMENT *ElementPtr1, POINT *pPt1)
+{
+	if (ElementPtr1->state_flags & PLAYER_SHIP)
+		ElementPtr0->mass_points = GAS_DAMAGE;
+	else
+		ElementPtr0->mass_points = 50;
+
+	weapon_collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
+}
+
+static void
+spawn_gas_cloud (ELEMENT *ElementPtr)
+{
+#define GAS_SPEED (16 << RESOLUTION_FACTOR) // JMS_GFX
+#define GAS_HITS 100
+#define GAS_OFFSET (2 << RESOLUTION_FACTOR) // JMS_GFX
+#define NUM_GAS_CLOUDS 16
+	SIZE dx, dy;
+	STARSHIP *StarShipPtr;
+	MISSILE_BLOCK MissileBlock;
+
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+	MissileBlock.cx = ElementPtr->next.location.x;
+	MissileBlock.cy = ElementPtr->next.location.y;
+	MissileBlock.farray = StarShipPtr->RaceDescPtr->ship_data.special;
+	MissileBlock.index = 0;
+	MissileBlock.sender = ElementPtr->playerNr;
+	MissileBlock.flags = IGNORE_SIMILAR;
+	MissileBlock.pixoffs = 20 << RESOLUTION_FACTOR; // JMS_GFX
+	MissileBlock.speed = GAS_SPEED;
+	MissileBlock.hit_points = GAS_HITS;
+	MissileBlock.damage = GAS_DAMAGE;
+	MissileBlock.life =
+			GetFrameCount (MissileBlock.farray[0]) * (GAS_RATE + 1) - 1;
+	MissileBlock.preprocess_func = gas_cloud_preprocess;
+	MissileBlock.blast_offs = GAS_OFFSET;
+
+	GetCurrentVelocityComponents (&ElementPtr->velocity, &dx, &dy);
+	for (MissileBlock.face = 0;
+			MissileBlock.face < ANGLE_TO_FACING (FULL_CIRCLE);
+			MissileBlock.face +=
+			(ANGLE_TO_FACING (FULL_CIRCLE) / NUM_GAS_CLOUDS))
+	{
+		HELEMENT hGasCloud;
+
+		hGasCloud = initialize_missile (&MissileBlock);
+		if (hGasCloud)
+		{
+			ELEMENT *GasCloudPtr;
+
+			LockElement (hGasCloud, &GasCloudPtr);
+			SetElementStarShip (GasCloudPtr, StarShipPtr);
+			GasCloudPtr->hTarget = 0;
+			GasCloudPtr->turn_wait = GAS_RATE - 1;
+			GasCloudPtr->collision_func = gas_cloud_collision;
+			DeltaVelocityComponents (&GasCloudPtr->velocity, dx, dy);
+			UnlockElement (hGasCloud);
+			PutElement (hGasCloud);
+		}
+	}
+}
+
+static void
+slylandro_kohrah_postprocess (ELEMENT *ElementPtr)
+{
+	STARSHIP *StarShipPtr;
+
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+	if ((StarShipPtr->cur_status_flags & SPECIAL)
+			&& StarShipPtr->special_counter == 0
+			&& DeltaEnergy (ElementPtr, -SPECIAL_ENERGY_COST))
+	{
+		spawn_gas_cloud (ElementPtr);
+
+		ProcessSound (SetAbsSoundIndex (
+				StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 1), ElementPtr);
+
+		StarShipPtr->special_counter = SPECIAL_WAIT;
+	}
+}
+
+static void
+slylandro_kohrah_preprocess (ELEMENT *ElementPtr)
+{
+	STARSHIP *StarShipPtr;
+
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+			/* no spinning disks */
+	StarShipPtr->RaceDescPtr->characteristics.special_wait = 0;
+	if (StarShipPtr->weapon_counter == 0
+			&& (StarShipPtr->cur_status_flags
+			& StarShipPtr->old_status_flags & WEAPON))
+		++StarShipPtr->weapon_counter;
+}
+
+RACE_DESC*
+init_slylandro_kohrah (void)
+{
+	RACE_DESC *RaceDescPtr;
+
+	if (RESOLUTION_FACTOR == 0)
+	{
+		slylandro_kohrah_desc.preprocess_func = slylandro_kohrah_preprocess;
+		slylandro_kohrah_desc.postprocess_func = slylandro_kohrah_postprocess;
+		slylandro_kohrah_desc.init_weapon_func = initialize_buzzsaw;
+		slylandro_kohrah_desc.cyborg_control.intelligence_func = slylandro_kohrah_intelligence;
+		RaceDescPtr = &slylandro_kohrah_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		slylandro_kohrah_desc_2xres.preprocess_func = slylandro_kohrah_preprocess;
+		slylandro_kohrah_desc_2xres.postprocess_func = slylandro_kohrah_postprocess;
+		slylandro_kohrah_desc_2xres.init_weapon_func = initialize_buzzsaw;
+		slylandro_kohrah_desc_2xres.cyborg_control.intelligence_func = slylandro_kohrah_intelligence;
+		RaceDescPtr = &slylandro_kohrah_desc_2xres;
+	}
+	else
+	{
+		slylandro_kohrah_desc_4xres.preprocess_func = slylandro_kohrah_preprocess;
+		slylandro_kohrah_desc_4xres.postprocess_func = slylandro_kohrah_postprocess;
+		slylandro_kohrah_desc_4xres.init_weapon_func = initialize_buzzsaw;
+		slylandro_kohrah_desc_4xres.cyborg_control.intelligence_func = slylandro_kohrah_intelligence;
+		RaceDescPtr = &slylandro_kohrah_desc_4xres;
+	}
+
+	return (RaceDescPtr);
+}
diff -ruNp src.orig/uqm/ships/slykohr/slykohr.h src/uqm/ships/slykohr/slykohr.h
--- src.orig/uqm/ships/slykohr/slykohr.h	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/slykohr/slykohr.h	2017-11-01 15:31:05 -0700
@@ -0,0 +1,23 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef SLYKOHR_H
+#define SLYKOHR_H
+
+RACE_DESC *init_slylandro_kohrah (void);
+
+#endif  /* SLYKOHR_H */
+
diff -ruNp src.orig/uqm/ships/slylandr/icode.h src/uqm/ships/slylandr/icode.h
--- src.orig/uqm/ships/slylandr/icode.h	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/slylandr/icode.h	2017-11-01 15:31:05 -0700
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SLYLANDRO_CODE "ship.slylandro.code"
diff -ruNp src.orig/uqm/ships/slylandr/slylandr.c src/uqm/ships/slylandr/slylandr.c
--- src.orig/uqm/ships/slylandr/slylandr.c	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/slylandr/slylandr.c	2017-11-01 15:31:05 -0700
@@ -50,12 +50,12 @@ static RACE_DESC slylandro_desc =
 		SLYLANDRO_RACE_STRINGS,
 		SLYLANDRO_ICON_MASK_PMAP_ANIM,
 		SLYLANDRO_MICON_MASK_PMAP_ANIM,
-		NULL, NULL, NULL
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
 	},
 	{ /* FLEET_STUFF */
-		INFINITE_RADIUS, /* Initial sphere of influence radius */
+		0, /* Initial sphere of influence radius */
 		{ /* Known location (center of SoI) */
-			333, 9812,
+			0,0,
 		},
 	},
 	{
@@ -111,8 +111,159 @@ static RACE_DESC slylandro_desc =
 	0, /* CodeRef */
 };
 
-static COUNT initialize_lightning (ELEMENT *ElementPtr,
-		HELEMENT LaserArray[]);
+// JMS_GFX
+#define MAX_THRUST_2XRES 120
+#define THRUST_INCREMENT_2XRES MAX_THRUST_2XRES
+
+// JMS_GFX
+static RACE_DESC slylandro_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		SEEKING_WEAPON | CREW_IMMUNE,
+		17, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		SLYLANDRO_RACE_STRINGS,
+		SLYLANDRO_ICON_MASK_PMAP_ANIM,
+		SLYLANDRO_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0,0,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SLYLANDRO_BIG_MASK_PMAP_ANIM,
+			SLYLANDRO_MED_MASK_PMAP_ANIM,
+			SLYLANDRO_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			SLYLANDRO_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SLYLANDRO_VICTORY_SONG,
+		SLYLANDRO_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_2XRES << 1,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 240
+#define THRUST_INCREMENT_4XRES MAX_THRUST_4XRES
+
+// JMS_GFX
+static RACE_DESC slylandro_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		SEEKING_WEAPON | CREW_IMMUNE,
+		17, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		SLYLANDRO_RACE_STRINGS,
+		SLYLANDRO_ICON_MASK_PMAP_ANIM,
+		SLYLANDRO_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0,0,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SLYLANDRO_BIG_MASK_PMAP_ANIM,
+			SLYLANDRO_MED_MASK_PMAP_ANIM,
+			SLYLANDRO_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			SLYLANDRO_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SLYLANDRO_VICTORY_SONG,
+		SLYLANDRO_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_4XRES << 1,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+static COUNT initialize_lightning (ELEMENT *ElementPtr, HELEMENT LaserArray[]);
 
 static void
 lightning_postprocess (ELEMENT *ElementPtr)
@@ -238,10 +389,8 @@ initialize_lightning (ELEMENT *ElementPt
 			angle += LOWORD (rand_val) & (QUADRANT - 1);
 		else
 			angle -= LOWORD (rand_val) & (QUADRANT - 1);
-#define LASER_RANGE 32
-		delta = WORLD_TO_VELOCITY (
-				DISPLAY_TO_WORLD ((HIWORD (rand_val) & (LASER_RANGE - 1)) + 4)
-				);
+#define LASER_RANGE (32 << RESOLUTION_FACTOR) // JMS_GFX
+		delta = WORLD_TO_VELOCITY (DISPLAY_TO_WORLD ((HIWORD (rand_val) & (LASER_RANGE - 1)) + 4));
 		SetVelocityComponents (&LaserPtr->velocity,
 				COSINE (angle, delta), SINE (angle, delta));
 
@@ -314,7 +463,7 @@ harvest_space_junk (ELEMENT *ElementPtr)
 				&& CollisionPossible (ObjPtr, ElementPtr))
 		{
 //HARVEST_RANGE was originally (SPACE_HEIGHT * 3 / 8)
-#define HARVEST_RANGE (208 * 3 / 8)
+#define HARVEST_RANGE ((208 * 3 / 8) << RESOLUTION_FACTOR) // JMS_GFX
 			SIZE dx, dy;
 
 			if ((dx = ObjPtr->next.location.x
@@ -422,12 +571,30 @@ init_slylandro (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	slylandro_desc.preprocess_func = slylandro_preprocess;
-	slylandro_desc.postprocess_func = slylandro_postprocess;
-	slylandro_desc.init_weapon_func = initialize_lightning;
-	slylandro_desc.cyborg_control.intelligence_func = slylandro_intelligence;
-
-	RaceDescPtr = &slylandro_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		slylandro_desc.preprocess_func = slylandro_preprocess;
+		slylandro_desc.postprocess_func = slylandro_postprocess;
+		slylandro_desc.init_weapon_func = initialize_lightning;
+		slylandro_desc.cyborg_control.intelligence_func = slylandro_intelligence;
+		RaceDescPtr = &slylandro_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		slylandro_desc_2xres.preprocess_func = slylandro_preprocess;
+		slylandro_desc_2xres.postprocess_func = slylandro_postprocess;
+		slylandro_desc_2xres.init_weapon_func = initialize_lightning;
+		slylandro_desc_2xres.cyborg_control.intelligence_func = slylandro_intelligence;
+		RaceDescPtr = &slylandro_desc_2xres;
+	}
+	else
+	{
+		slylandro_desc_4xres.preprocess_func = slylandro_preprocess;
+		slylandro_desc_4xres.postprocess_func = slylandro_postprocess;
+		slylandro_desc_4xres.init_weapon_func = initialize_lightning;
+		slylandro_desc_4xres.cyborg_control.intelligence_func = slylandro_intelligence;
+		RaceDescPtr = &slylandro_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp src.orig/uqm/ships/spathi/icode.h src/uqm/ships/spathi/icode.h
--- src.orig/uqm/ships/spathi/icode.h	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/spathi/icode.h	2017-11-01 15:31:05 -0700
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SPATHI_CODE "ship.spathi.code"
diff -ruNp src.orig/uqm/ships/spathi/spathi.c src/uqm/ships/spathi/spathi.c
--- src.orig/uqm/ships/spathi/spathi.c	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/spathi/spathi.c	2017-11-01 15:31:05 -0700
@@ -48,12 +48,12 @@ static RACE_DESC spathi_desc =
 		SPATHI_RACE_STRINGS,
 		SPATHI_ICON_MASK_PMAP_ANIM,
 		SPATHI_MICON_MASK_PMAP_ANIM,
-		NULL, NULL, NULL
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
 	},
 	{ /* FLEET_STUFF */
-		1000 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		50 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
 		{ /* Known location (center of SoI) */
-			2549, 3600,
+			7416, 9687,
 		},
 	},
 	{
@@ -109,7 +109,163 @@ static RACE_DESC spathi_desc =
 	0, /* CodeRef */
 };
 
-#define DISCRIMINATOR_SPEED DISPLAY_TO_WORLD (8)
+// JMS_GFX
+#define MAX_THRUST_2XRES 96
+#define THRUST_INCREMENT_2XRES 24
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
+#define MISSILE_RANGE_2XRES (MISSILE_SPEED_2XRES * MISSILE_LIFE)
+
+// JMS_GFX
+static RACE_DESC spathi_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | FIRES_AFT | SEEKING_SPECIAL | DONT_CHASE,
+		18, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		SPATHI_RACE_STRINGS,
+		SPATHI_ICON_MASK_PMAP_ANIM,
+		SPATHI_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		50 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			7416, 9687,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SPATHI_BIG_MASK_PMAP_ANIM,
+			SPATHI_MED_MASK_PMAP_ANIM,
+			SPATHI_SML_MASK_PMAP_ANIM,
+		},
+		{
+			MISSILE_BIG_MASK_PMAP_ANIM,
+			MISSILE_MED_MASK_PMAP_ANIM,
+			MISSILE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DISCRIM_BIG_MASK_PMAP_ANIM,
+			DISCRIM_MED_MASK_PMAP_ANIM,
+			DISCRIM_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SPATHI_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SPATHI_VICTORY_SONG,
+		SPATHI_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_RANGE_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 192
+#define THRUST_INCREMENT_4XRES 48
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
+#define MISSILE_RANGE_4XRES (MISSILE_SPEED_2XRES * MISSILE_LIFE)
+
+// JMS_GFX
+static RACE_DESC spathi_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | FIRES_AFT | SEEKING_SPECIAL | DONT_CHASE,
+		18, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		SPATHI_RACE_STRINGS,
+		SPATHI_ICON_MASK_PMAP_ANIM,
+		SPATHI_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		50 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			7416, 9687,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SPATHI_BIG_MASK_PMAP_ANIM,
+			SPATHI_MED_MASK_PMAP_ANIM,
+			SPATHI_SML_MASK_PMAP_ANIM,
+		},
+		{
+			MISSILE_BIG_MASK_PMAP_ANIM,
+			MISSILE_MED_MASK_PMAP_ANIM,
+			MISSILE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DISCRIM_BIG_MASK_PMAP_ANIM,
+			DISCRIM_MED_MASK_PMAP_ANIM,
+			DISCRIM_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SPATHI_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SPATHI_VICTORY_SONG,
+		SPATHI_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_RANGE_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+#define DISCRIMINATOR_SPEED DISPLAY_TO_WORLD (8 << RESOLUTION_FACTOR) // JMS_GFX
 #define TRACK_WAIT 1
 
 static void
@@ -140,11 +296,11 @@ butt_missile_preprocess (ELEMENT *Elemen
 static void
 spawn_butt_missile (ELEMENT *ShipPtr)
 {
-#define SPATHI_REAR_OFFSET 20
+#define SPATHI_REAR_OFFSET (20 << RESOLUTION_FACTOR) // JMS_GFX
 #define DISCRIMINATOR_LIFE 30
 #define DISCRIMINATOR_HITS 1
 #define DISCRIMINATOR_DAMAGE 2
-#define DISCRIMINATOR_OFFSET 4
+#define DISCRIMINATOR_OFFSET (4 << RESOLUTION_FACTOR) // JMS_GFX
 	HELEMENT ButtMissile;
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK ButtMissileBlock;
@@ -239,10 +395,10 @@ spathi_intelligence (ELEMENT *ShipPtr, E
 static COUNT
 initialize_standard_missile (ELEMENT *ShipPtr, HELEMENT MissileArray[])
 {
-#define SPATHI_FORWARD_OFFSET 16
+#define SPATHI_FORWARD_OFFSET (16 << RESOLUTION_FACTOR) // JMS_GFX
 #define MISSILE_HITS 1
 #define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET 1
+#define MISSILE_OFFSET (1 << RESOLUTION_FACTOR) // JMS_GFX
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -254,7 +410,7 @@ initialize_standard_missile (ELEMENT *Sh
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = SPATHI_FORWARD_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -287,11 +443,27 @@ init_spathi (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	spathi_desc.postprocess_func = spathi_postprocess;
-	spathi_desc.init_weapon_func = initialize_standard_missile;
-	spathi_desc.cyborg_control.intelligence_func = spathi_intelligence;
-
-	RaceDescPtr = &spathi_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		spathi_desc.postprocess_func = spathi_postprocess;
+		spathi_desc.init_weapon_func = initialize_standard_missile;
+		spathi_desc.cyborg_control.intelligence_func = spathi_intelligence;
+		RaceDescPtr = &spathi_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		spathi_desc_2xres.postprocess_func = spathi_postprocess;
+		spathi_desc_2xres.init_weapon_func = initialize_standard_missile;
+		spathi_desc_2xres.cyborg_control.intelligence_func = spathi_intelligence;
+		RaceDescPtr = &spathi_desc_2xres;
+	}
+	else
+	{
+		spathi_desc_4xres.postprocess_func = spathi_postprocess;
+		spathi_desc_4xres.init_weapon_func = initialize_standard_missile;
+		spathi_desc_4xres.cyborg_control.intelligence_func = spathi_intelligence;
+		RaceDescPtr = &spathi_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp src.orig/uqm/ships/supox/icode.h src/uqm/ships/supox/icode.h
--- src.orig/uqm/ships/supox/icode.h	2017-11-01 15:30:27 -0700
+++ src/uqm/ships/supox/icode.h	2017-11-01 15:31:05 -0700
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SUPOX_CODE "ship.supox.code"
diff -ruNp src.orig/uqm/ships/supox/supox.c src/uqm/ships/supox/supox.c
--- src.orig/uqm/ships/supox/supox.c	2017-11-01 15:30:28 -0700
+++ src/uqm/ships/supox/supox.c	2017-11-01 15:31:05 -0700
@@ -50,12 +50,12 @@ static RACE_DESC supox_desc =
 		SUPOX_RACE_STRINGS,
 		SUPOX_ICON_MASK_PMAP_ANIM,
 		SUPOX_MICON_MASK_PMAP_ANIM,
-		NULL, NULL, NULL
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
 	},
 	{ /* FLEET_STUFF */
-		333 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		0, /* Initial SoI radius */
 		{ /* Known location (center of SoI) */
-			7468, 9246,
+			0, 0,
 		},
 	},
 	{
@@ -111,9 +111,162 @@ static RACE_DESC supox_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+#define MAX_THRUST_2XRES 80
+#define THRUST_INCREMENT_2XRES 16
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
+
+// JMS_GFX
+static RACE_DESC supox_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		16, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		SUPOX_RACE_STRINGS,
+		SUPOX_ICON_MASK_PMAP_ANIM,
+		SUPOX_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SUPOX_BIG_MASK_PMAP_ANIM,
+			SUPOX_MED_MASK_PMAP_ANIM,
+			SUPOX_SML_MASK_PMAP_ANIM,
+		},
+		{
+			GOB_BIG_MASK_PMAP_ANIM,
+			GOB_MED_MASK_PMAP_ANIM,
+			GOB_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			SUPOX_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SUPOX_VICTORY_SONG,
+		SUPOX_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(MISSILE_SPEED_2XRES * MISSILE_LIFE) >> 1,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 160
+#define THRUST_INCREMENT_4XRES 16
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
+
+// JMS_GFX
+static RACE_DESC supox_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		16, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		SUPOX_RACE_STRINGS,
+		SUPOX_ICON_MASK_PMAP_ANIM,
+		SUPOX_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SUPOX_BIG_MASK_PMAP_ANIM,
+			SUPOX_MED_MASK_PMAP_ANIM,
+			SUPOX_SML_MASK_PMAP_ANIM,
+		},
+		{
+			GOB_BIG_MASK_PMAP_ANIM,
+			GOB_MED_MASK_PMAP_ANIM,
+			GOB_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			SUPOX_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SUPOX_VICTORY_SONG,
+		SUPOX_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(MISSILE_SPEED_4XRES * MISSILE_LIFE) >> 1,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static void
-supox_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
-		COUNT ConcernCounter)
+supox_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern, COUNT ConcernCounter)
 {
 	STARSHIP *StarShipPtr;
 	EVALUATE_DESC *lpEvalDesc;
@@ -182,7 +335,7 @@ initialize_horn (ELEMENT *ShipPtr, HELEM
 #define MISSILE_HITS 1
 #define MISSILE_DAMAGE 1
 #define MISSILE_OFFSET 2
-#define SUPOX_OFFSET 23
+#define SUPOX_OFFSET (23 << RESOLUTION_FACTOR) // JMS_GFX
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -194,7 +347,7 @@ initialize_horn (ELEMENT *ShipPtr, HELEM
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = SUPOX_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -210,7 +363,7 @@ supox_preprocess (ELEMENT *ElementPtr)
 	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
-	if ((StarShipPtr->cur_status_flags & SPECIAL)
+	if ((StarShipPtr->cur_status_flags & SPECIAL) && StarShipPtr->special_counter == 0
 /*
 			&& DeltaEnergy (ElementPtr, -SPECIAL_ENERGY_COST)
 */
@@ -272,11 +425,27 @@ init_supox (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	supox_desc.preprocess_func = supox_preprocess;
-	supox_desc.init_weapon_func = initialize_horn;
-	supox_desc.cyborg_control.intelligence_func = supox_intelligence;
-
-	RaceDescPtr = &supox_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		supox_desc.preprocess_func = supox_preprocess;
+		supox_desc.init_weapon_func = initialize_horn;
+		supox_desc.cyborg_control.intelligence_func = supox_intelligence;
+		RaceDescPtr = &supox_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		supox_desc_2xres.preprocess_func = supox_preprocess;
+		supox_desc_2xres.init_weapon_func = initialize_horn;
+		supox_desc_2xres.cyborg_control.intelligence_func = supox_intelligence;
+		RaceDescPtr = &supox_desc_2xres;
+	}
+	else
+	{
+		supox_desc_4xres.preprocess_func = supox_preprocess;
+		supox_desc_4xres.init_weapon_func = initialize_horn;
+		supox_desc_4xres.cyborg_control.intelligence_func = supox_intelligence;
+		RaceDescPtr = &supox_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp src.orig/uqm/ships/syreen/icode.h src/uqm/ships/syreen/icode.h
--- src.orig/uqm/ships/syreen/icode.h	2017-11-01 15:30:28 -0700
+++ src/uqm/ships/syreen/icode.h	2017-11-01 15:31:05 -0700
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SYREEN_CODE "ship.syreen.code"
diff -ruNp src.orig/uqm/ships/syreen/syreen.c src/uqm/ships/syreen/syreen.c
--- src.orig/uqm/ships/syreen/syreen.c	2017-11-01 15:30:28 -0700
+++ src/uqm/ships/syreen/syreen.c	2017-11-01 15:31:05 -0700
@@ -51,12 +51,12 @@ static RACE_DESC syreen_desc =
 		SYREEN_RACE_STRINGS,
 		SYREEN_ICON_MASK_PMAP_ANIM,
 		SYREEN_MICON_MASK_PMAP_ANIM,
-		NULL, NULL, NULL
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
 	},
 	{ /* FLEET_STUFF */
-		0, /* Initial sphere of influence radius */
+		350 / SPHERE_RADIUS_INCREMENT * 2, /* Initial sphere of influence radius */
 		{ /* Known location (center of SoI) */
-			0, 0,
+			9125,9770,
 		},
 	},
 	{
@@ -112,13 +112,167 @@ static RACE_DESC syreen_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (8) */ 72
+#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (2) */ 18
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
+
+// JMS_GFX
+static RACE_DESC syreen_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		13, /* Super Melee cost */
+		MAX_CREW, SYREEN_MAX_CREW_SIZE,
+		MAX_ENERGY, MAX_ENERGY,
+		SYREEN_RACE_STRINGS,
+		SYREEN_ICON_MASK_PMAP_ANIM,
+		SYREEN_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		350 / SPHERE_RADIUS_INCREMENT * 2, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			9125,9770,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SYREEN_BIG_MASK_PMAP_ANIM,
+			SYREEN_MED_MASK_PMAP_ANIM,
+			SYREEN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DAGGER_BIG_MASK_PMAP_ANIM,
+			DAGGER_MED_MASK_PMAP_ANIM,
+			DAGGER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			SYREEN_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SYREEN_VICTORY_SONG,
+		SYREEN_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(MISSILE_SPEED_2XRES * MISSILE_LIFE * 2 / 3),
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (8) */ 144
+#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (2) */ 36
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
+
+// JMS_GFX
+static RACE_DESC syreen_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		13, /* Super Melee cost */
+		MAX_CREW, SYREEN_MAX_CREW_SIZE,
+		MAX_ENERGY, MAX_ENERGY,
+		SYREEN_RACE_STRINGS,
+		SYREEN_ICON_MASK_PMAP_ANIM,
+		SYREEN_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		350 / SPHERE_RADIUS_INCREMENT * 2, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			9125,9770,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SYREEN_BIG_MASK_PMAP_ANIM,
+			SYREEN_MED_MASK_PMAP_ANIM,
+			SYREEN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DAGGER_BIG_MASK_PMAP_ANIM,
+			DAGGER_MED_MASK_PMAP_ANIM,
+			DAGGER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			SYREEN_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SYREEN_VICTORY_SONG,
+		SYREEN_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(MISSILE_SPEED_4XRES * MISSILE_LIFE * 2 / 3),
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static COUNT
 initialize_dagger (ELEMENT *ShipPtr, HELEMENT DaggerArray[])
 {
-#define SYREEN_OFFSET 30
+#define SYREEN_OFFSET (30 << RESOLUTION_FACTOR) // JMS_GFX
 #define MISSILE_HITS 1
 #define MISSILE_DAMAGE 2
-#define MISSILE_OFFSET 3
+#define MISSILE_OFFSET (3 << RESOLUTION_FACTOR) // JMS_GFX
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -130,7 +284,7 @@ initialize_dagger (ELEMENT *ShipPtr, HEL
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = SYREEN_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -194,7 +348,7 @@ spawn_crew (ELEMENT *ElementPtr)
 
 				dx = WORLD_TO_DISPLAY (dx);
 				dy = WORLD_TO_DISPLAY (dy);
-#define ABANDONER_RANGE 208 /* originally SPACE_HEIGHT */
+#define ABANDONER_RANGE (208 << RESOLUTION_FACTOR) // JMS_GFX /* originally SPACE_HEIGHT */
 				if (dx <= ABANDONER_RANGE && dy <= ABANDONER_RANGE
 						&& (d_squared = (DWORD)((UWORD)dx * (UWORD)dx)
 						+ (DWORD)((UWORD)dy * (UWORD)dy)) <=
@@ -270,12 +424,28 @@ init_syreen (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	syreen_desc.postprocess_func = syreen_postprocess;
-	syreen_desc.init_weapon_func = initialize_dagger;
-	syreen_desc.cyborg_control.intelligence_func = syreen_intelligence;
-
-	RaceDescPtr = &syreen_desc;
-
+	if (RESOLUTION_FACTOR == 0)
+	{
+		syreen_desc.postprocess_func = syreen_postprocess;
+		syreen_desc.init_weapon_func = initialize_dagger;
+		syreen_desc.cyborg_control.intelligence_func = syreen_intelligence;
+		RaceDescPtr = &syreen_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		syreen_desc_2xres.postprocess_func = syreen_postprocess;
+		syreen_desc_2xres.init_weapon_func = initialize_dagger;
+		syreen_desc_2xres.cyborg_control.intelligence_func = syreen_intelligence;
+		RaceDescPtr = &syreen_desc_2xres;
+	}
+	else
+	{
+		syreen_desc_4xres.postprocess_func = syreen_postprocess;
+		syreen_desc_4xres.init_weapon_func = initialize_dagger;
+		syreen_desc_4xres.cyborg_control.intelligence_func = syreen_intelligence;
+		RaceDescPtr = &syreen_desc_4xres;
+	}
+	
 	return (RaceDescPtr);
 }
 
diff -ruNp src.orig/uqm/ships/thradd/icode.h src/uqm/ships/thradd/icode.h
--- src.orig/uqm/ships/thradd/icode.h	2017-11-01 15:30:28 -0700
+++ src/uqm/ships/thradd/icode.h	2017-11-01 15:31:05 -0700
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define THRADDASH_CODE "ship.thraddash.code"
diff -ruNp src.orig/uqm/ships/thradd/thradd.c src/uqm/ships/thradd/thradd.c
--- src.orig/uqm/ships/thradd/thradd.c	2017-11-01 15:30:28 -0700
+++ src/uqm/ships/thradd/thradd.c	2017-11-01 15:31:05 -0700
@@ -37,7 +37,7 @@
 #define SPECIAL_WAIT 0
 
 #define SHIP_MASS 7
-#define THRADDASH_OFFSET 9
+#define THRADDASH_OFFSET (9 << RESOLUTION_FACTOR) // JMS_GFX
 #define MISSILE_SPEED DISPLAY_TO_WORLD (30)
 #define MISSILE_LIFE 15
 
@@ -51,12 +51,12 @@ static RACE_DESC thraddash_desc =
 		THRADDASH_RACE_STRINGS,
 		THRADDASH_ICON_MASK_PMAP_ANIM,
 		THRADDASH_MICON_MASK_PMAP_ANIM,
-		NULL, NULL, NULL
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
 	},
 	{ /* FLEET_STUFF */
-		833 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		0, /* Initial SoI radius */
 		{ /* Known location (center of SoI) */
-			2535, 8358,
+			0,0,
 		},
 	},
 	{
@@ -112,6 +112,160 @@ static RACE_DESC thraddash_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+#define MAX_THRUST_2XRES 56
+#define THRUST_INCREMENT_2XRES 14
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
+
+// JMS_GFX
+static RACE_DESC thraddash_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		10, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		THRADDASH_RACE_STRINGS,
+		THRADDASH_ICON_MASK_PMAP_ANIM,
+		THRADDASH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			0,0,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			THRADDASH_BIG_MASK_PMAP_ANIM,
+			THRADDASH_MED_MASK_PMAP_ANIM,
+			THRADDASH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			HORN_BIG_MASK_PMAP_ANIM,
+			HORN_MED_MASK_PMAP_ANIM,
+			HORN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NAPALM_BIG_MASK_PMAP_ANIM,
+			NAPALM_MED_MASK_PMAP_ANIM,
+			NAPALM_SML_MASK_PMAP_ANIM,
+		},
+		{
+			THRADDASH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		THRADDASH_VICTORY_SONG,
+		THRADDASH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(MISSILE_SPEED_2XRES * MISSILE_LIFE) >> 1,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 112
+#define THRUST_INCREMENT_4XRES 28
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
+
+// JMS_GFX
+static RACE_DESC thraddash_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		10, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		THRADDASH_RACE_STRINGS,
+		THRADDASH_ICON_MASK_PMAP_ANIM,
+		THRADDASH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			0,0,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			THRADDASH_BIG_MASK_PMAP_ANIM,
+			THRADDASH_MED_MASK_PMAP_ANIM,
+			THRADDASH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			HORN_BIG_MASK_PMAP_ANIM,
+			HORN_MED_MASK_PMAP_ANIM,
+			HORN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NAPALM_BIG_MASK_PMAP_ANIM,
+			NAPALM_MED_MASK_PMAP_ANIM,
+			NAPALM_SML_MASK_PMAP_ANIM,
+		},
+		{
+			THRADDASH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		THRADDASH_VICTORY_SONG,
+		THRADDASH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(MISSILE_SPEED_4XRES * MISSILE_LIFE) >> 1,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static void
 thraddash_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
 		COUNT ConcernCounter)
@@ -123,7 +277,7 @@ thraddash_intelligence (ELEMENT *ShipPtr
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
 	if (lpEvalDesc->ObjectPtr)
 	{
-#define STATIONARY_SPEED WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (4))
+#define STATIONARY_SPEED WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (4 << RESOLUTION_FACTOR)) // JMS_GFX
 		SIZE dx, dy;
 
 		GetCurrentVelocityComponents (
@@ -247,7 +401,7 @@ initialize_horn (ELEMENT *ShipPtr, HELEM
 {
 #define MISSILE_HITS 2
 #define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET 3
+#define MISSILE_OFFSET (3 << RESOLUTION_FACTOR) // JMS_GFX
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -259,7 +413,7 @@ initialize_horn (ELEMENT *ShipPtr, HELEM
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = THRADDASH_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -284,8 +438,8 @@ thraddash_preprocess (ELEMENT *ElementPt
 	}
 	else if (DeltaEnergy (ElementPtr, -SPECIAL_ENERGY_COST))
 	{
-#define SPECIAL_THRUST_INCREMENT 12
-#define SPECIAL_MAX_THRUST 72
+#define SPECIAL_THRUST_INCREMENT (12 << RESOLUTION_FACTOR) // JMS_GFX
+#define SPECIAL_MAX_THRUST (72 << RESOLUTION_FACTOR) // JMS_GFX
 		COUNT max_thrust, thrust_increment;
 		STATUS_FLAGS thrust_status;
 		HELEMENT hTrailElement;
@@ -378,11 +532,27 @@ init_thraddash (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	thraddash_desc.preprocess_func = thraddash_preprocess;
-	thraddash_desc.init_weapon_func = initialize_horn;
-	thraddash_desc.cyborg_control.intelligence_func = thraddash_intelligence;
-
-	RaceDescPtr = &thraddash_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		thraddash_desc.preprocess_func = thraddash_preprocess;
+		thraddash_desc.init_weapon_func = initialize_horn;
+		thraddash_desc.cyborg_control.intelligence_func = thraddash_intelligence;
+		RaceDescPtr = &thraddash_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		thraddash_desc_2xres.preprocess_func = thraddash_preprocess;
+		thraddash_desc_2xres.init_weapon_func = initialize_horn;
+		thraddash_desc_2xres.cyborg_control.intelligence_func = thraddash_intelligence;
+		RaceDescPtr = &thraddash_desc_2xres;
+	}
+	else
+	{
+		thraddash_desc_4xres.preprocess_func = thraddash_preprocess;
+		thraddash_desc_4xres.init_weapon_func = initialize_horn;
+		thraddash_desc_4xres.cyborg_control.intelligence_func = thraddash_intelligence;
+		RaceDescPtr = &thraddash_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp src.orig/uqm/ships/transport/Makeinfo src/uqm/ships/transport/Makeinfo
--- src.orig/uqm/ships/transport/Makeinfo	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/transport/Makeinfo	2017-11-01 15:31:05 -0700
@@ -0,0 +1 @@
+uqm_CFILES="transport.c"
diff -ruNp src.orig/uqm/ships/transport/icode.h src/uqm/ships/transport/icode.h
--- src.orig/uqm/ships/transport/icode.h	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/transport/icode.h	2017-11-01 15:31:05 -0700
@@ -0,0 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
+#define TRANSPORT_CODE "ship.transport.code"
diff -ruNp src.orig/uqm/ships/transport/resinst.h src/uqm/ships/transport/resinst.h
--- src.orig/uqm/ships/transport/resinst.h	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/transport/resinst.h	2017-11-01 15:31:05 -0700
@@ -0,0 +1,3 @@
+#define TRANSPORT_MICON_MASK_PMAP_ANIM "ship.transport.meleeicons"
+
+#include "icode.h"
diff -ruNp src.orig/uqm/ships/transport/transport.c src/uqm/ships/transport/transport.c
--- src.orig/uqm/ships/transport/transport.c	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/transport/transport.c	2017-11-01 15:31:05 -0700
@@ -0,0 +1,278 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "../ship.h"
+#include "transport.h"
+#include "resinst.h"
+
+#include "uqm/globdata.h"
+#include "libs/mathlib.h"
+
+#define MAX_CREW 10
+#define MAX_ENERGY 10
+#define ENERGY_REGENERATION 1
+#define WEAPON_ENERGY_COST 5
+#define SPECIAL_ENERGY_COST 5
+#define ENERGY_WAIT 2
+#define MAX_THRUST 5
+#define THRUST_INCREMENT 1
+#define TURN_WAIT 2
+#define THRUST_WAIT 5
+#define WEAPON_WAIT 4
+#define SPECIAL_WAIT 4
+
+#define SHIP_MASS 5
+
+static RACE_DESC transport_desc =
+{
+	{ /* SHIP_INFO */
+		0,
+		0, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		0,
+		0,
+		TRANSPORT_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		INFINITE_RADIUS, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			MAX_X_UNIVERSE >> 1, MAX_Y_UNIVERSE >> 1,
+		},
+	},
+	{
+		MAX_THRUST,
+		THRUST_INCREMENT,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			NULL_RESOURCE,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		NULL_RESOURCE,
+		NULL_RESOURCE,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		0,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_2XRES 10
+#define THRUST_INCREMENT_2XRES 2
+
+// JMS_GFX
+static RACE_DESC transport_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		0,
+		0, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		0,
+		0,
+		TRANSPORT_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		INFINITE_RADIUS, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			MAX_X_UNIVERSE >> 1, MAX_Y_UNIVERSE >> 1,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			NULL_RESOURCE,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		NULL_RESOURCE,
+		NULL_RESOURCE,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		0,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 20
+#define THRUST_INCREMENT_4XRES 4
+
+// JMS_GFX
+static RACE_DESC transport_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		0,
+		0, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		0,
+		0,
+		TRANSPORT_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		INFINITE_RADIUS, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			MAX_X_UNIVERSE >> 1, MAX_Y_UNIVERSE >> 1,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			NULL_RESOURCE,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		NULL_RESOURCE,
+		NULL_RESOURCE,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		0,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+RACE_DESC*
+init_transport (void)
+{
+	RACE_DESC *RaceDescPtr;
+
+	if (RESOLUTION_FACTOR == 0)
+		RaceDescPtr = &transport_desc;
+	else if (RESOLUTION_FACTOR == 1)
+		RaceDescPtr = &transport_desc_2xres;
+	else
+		RaceDescPtr = &transport_desc_4xres;
+
+	return (RaceDescPtr);
+}
+
diff -ruNp src.orig/uqm/ships/transport/transport.h src/uqm/ships/transport/transport.h
--- src.orig/uqm/ships/transport/transport.h	1969-12-31 16:00:00 -0800
+++ src/uqm/ships/transport/transport.h	2017-11-01 15:31:05 -0700
@@ -0,0 +1,23 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef TRANSPORT_H
+#define TRANSPORT_H
+
+RACE_DESC *init_transport (void);
+
+#endif  /* TRANSPORT_H */
+
diff -ruNp src.orig/uqm/ships/umgah/icode.h src/uqm/ships/umgah/icode.h
--- src.orig/uqm/ships/umgah/icode.h	2017-11-01 15:30:28 -0700
+++ src/uqm/ships/umgah/icode.h	2017-11-01 15:31:05 -0700
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define UMGAH_CODE "ship.umgah.code"
diff -ruNp src.orig/uqm/ships/umgah/umgah.c src/uqm/ships/umgah/umgah.c
--- src.orig/uqm/ships/umgah/umgah.c	2017-11-01 15:30:28 -0700
+++ src/uqm/ships/umgah/umgah.c	2017-11-01 15:31:05 -0700
@@ -38,7 +38,6 @@
 
 #define SHIP_MASS 1
 
-
 static RACE_DESC umgah_desc =
 {
 	{ /* SHIP_INFO */
@@ -49,12 +48,12 @@ static RACE_DESC umgah_desc =
 		UMGAH_RACE_STRINGS,
 		UMGAH_ICON_MASK_PMAP_ANIM,
 		UMGAH_MICON_MASK_PMAP_ANIM,
-		NULL, NULL, NULL
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
 	},
 	{ /* FLEET_STUFF */
-		833 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		0, /* Initial SoI radius */
 		{ /* Known location (center of SoI) */
-			1798, 6000,
+			0,0,
 		},
 	},
 	{
@@ -110,6 +109,158 @@ static RACE_DESC umgah_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (5) */ 36
+#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (2) */ 12
+
+// JMS_GFX
+static RACE_DESC umgah_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | IMMEDIATE_WEAPON,
+		7, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		UMGAH_RACE_STRINGS,
+		UMGAH_ICON_MASK_PMAP_ANIM,
+		UMGAH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			0,0,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			UMGAH_BIG_MASK_PMAP_ANIM,
+			UMGAH_MED_MASK_PMAP_ANIM,
+			UMGAH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SPRITZ_MASK_PMAP_ANIM,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			CONE_BIG_MASK_ANIM,
+			CONE_MED_MASK_ANIM,
+			CONE_SML_MASK_ANIM,
+		},
+		{
+			UMGAH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		UMGAH_VICTORY_SONG,
+		UMGAH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(LONG_RANGE_WEAPON_2XRES << 2),
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (5) */ 72
+#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (2) */ 24
+
+// JMS_GFX
+static RACE_DESC umgah_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | IMMEDIATE_WEAPON,
+		7, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		UMGAH_RACE_STRINGS,
+		UMGAH_ICON_MASK_PMAP_ANIM,
+		UMGAH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			0,0,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			UMGAH_BIG_MASK_PMAP_ANIM,
+			UMGAH_MED_MASK_PMAP_ANIM,
+			UMGAH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SPRITZ_MASK_PMAP_ANIM,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			CONE_BIG_MASK_ANIM,
+			CONE_MED_MASK_ANIM,
+			CONE_SML_MASK_ANIM,
+		},
+		{
+			UMGAH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		UMGAH_VICTORY_SONG,
+		UMGAH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(LONG_RANGE_WEAPON_4XRES << 2),
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static void
 cone_preprocess (ELEMENT *ElementPtr)
 {
@@ -139,7 +290,7 @@ cone_collision (ELEMENT *ElementPtr0, PO
 	}
 }
 
-#define JUMP_DIST DISPLAY_TO_WORLD (40)
+#define JUMP_DIST DISPLAY_TO_WORLD (40 << RESOLUTION_FACTOR) // JMS_GFX
 
 static void
 umgah_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
@@ -186,10 +337,10 @@ umgah_intelligence (ELEMENT *ShipPtr, EV
 		else
 			this_turn = (BYTE)lpEvalDesc->which_turn;
 
-		EnoughJuice = (BOOLEAN)(WORLD_TO_TURN (
+		EnoughJuice = (BOOLEAN)((WORLD_TO_TURN (
 				JUMP_DIST * StarShipPtr->RaceDescPtr->ship_info.energy_level
 				/ SPECIAL_ENERGY_COST
-				) > this_turn);
+				) >> RESOLUTION_FACTOR) > this_turn); // JMS_GFX
 		delta_x = lpEvalDesc->ObjectPtr->next.location.x -
 				ShipPtr->next.location.x;
 		delta_y = lpEvalDesc->ObjectPtr->next.location.y -
@@ -207,7 +358,7 @@ umgah_intelligence (ELEMENT *ShipPtr, EV
 				|| (this_turn > 6
 				&& MANEUVERABILITY (
 				&EnemyStarShipPtr->RaceDescPtr->cyborg_control
-				) <= SLOW_SHIP)
+				) <= (SLOW_SHIP << RESOLUTION_FACTOR)) // JMS_GFX
 				|| (this_turn >= 16 && this_turn <= 24)))
 			StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = (LONG_RANGE_WEAPON << 3);
 		else
@@ -309,8 +460,7 @@ initialize_cone (ELEMENT *ShipPtr, HELEM
 		ConePtr->next = ConePtr->current;
 		InitIntersectStartPoint (ConePtr);
 		InitIntersectEndPoint (ConePtr);
-		ConePtr->IntersectControl.IntersectStamp.frame =
-				StarShipPtr->RaceDescPtr->ship_data.special[0];
+		ConePtr->IntersectControl.IntersectStamp.frame = StarShipPtr->RaceDescPtr->ship_data.special[0];
 		UnlockElement (ConeArray[0]);
 	}
 
@@ -371,12 +521,30 @@ init_umgah (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	umgah_desc.preprocess_func = umgah_preprocess;
-	umgah_desc.postprocess_func = umgah_postprocess;
-	umgah_desc.init_weapon_func = initialize_cone;
-	umgah_desc.cyborg_control.intelligence_func = umgah_intelligence;
-
-	RaceDescPtr = &umgah_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		umgah_desc.preprocess_func = umgah_preprocess;
+		umgah_desc.postprocess_func = umgah_postprocess;
+		umgah_desc.init_weapon_func = initialize_cone;
+		umgah_desc.cyborg_control.intelligence_func = umgah_intelligence;
+		RaceDescPtr = &umgah_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		umgah_desc_2xres.preprocess_func = umgah_preprocess;
+		umgah_desc_2xres.postprocess_func = umgah_postprocess;
+		umgah_desc_2xres.init_weapon_func = initialize_cone;
+		umgah_desc_2xres.cyborg_control.intelligence_func = umgah_intelligence;
+		RaceDescPtr = &umgah_desc_2xres;
+	}
+	else
+	{
+		umgah_desc_4xres.preprocess_func = umgah_preprocess;
+		umgah_desc_4xres.postprocess_func = umgah_postprocess;
+		umgah_desc_4xres.init_weapon_func = initialize_cone;
+		umgah_desc_4xres.cyborg_control.intelligence_func = umgah_intelligence;
+		RaceDescPtr = &umgah_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp src.orig/uqm/ships/urquan/icode.h src/uqm/ships/urquan/icode.h
--- src.orig/uqm/ships/urquan/icode.h	2017-11-01 15:30:28 -0700
+++ src/uqm/ships/urquan/icode.h	2017-11-01 15:31:05 -0700
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define URQUAN_CODE "ship.urquan.code"
diff -ruNp src.orig/uqm/ships/urquan/urquan.c src/uqm/ships/urquan/urquan.c
--- src.orig/uqm/ships/urquan/urquan.c	2017-11-01 15:30:28 -0700
+++ src/uqm/ships/urquan/urquan.c	2017-11-01 15:31:05 -0700
@@ -52,12 +52,12 @@ static RACE_DESC urquan_desc =
 		URQUAN_RACE_STRINGS,
 		URQUAN_ICON_MASK_PMAP_ANIM,
 		URQUAN_MICON_MASK_PMAP_ANIM,
-		NULL, NULL, NULL
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
 	},
 	{ /* FLEET_STUFF */
-		2666 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		0, /* Initial SoI radius */
 		{ /* Known location (center of SoI) */
-			5750, 6000,
+			0,0,
 		},
 	},
 	{
@@ -113,13 +113,167 @@ static RACE_DESC urquan_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+#define MAX_THRUST_2XRES 60
+#define THRUST_INCREMENT_2XRES 12
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (40)
+
+// JMS_GFX
+static RACE_DESC urquan_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_SPECIAL,
+		30, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		URQUAN_RACE_STRINGS,
+		URQUAN_ICON_MASK_PMAP_ANIM,
+		URQUAN_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			0,0,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			URQUAN_BIG_MASK_PMAP_ANIM,
+			URQUAN_MED_MASK_PMAP_ANIM,
+			URQUAN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			FUSION_BIG_MASK_PMAP_ANIM,
+			FUSION_MED_MASK_PMAP_ANIM,
+			FUSION_SML_MASK_PMAP_ANIM,
+		},
+		{
+			FIGHTER_BIG_MASK_PMAP_ANIM,
+			FIGHTER_MED_MASK_PMAP_ANIM,
+			FIGHTER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			URQUAN_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		URQUAN_VICTORY_SONG,
+		URQUAN_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_SPEED_2XRES * MISSILE_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 120
+#define THRUST_INCREMENT_4XRES 24
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (80)
+
+// JMS_GFX
+static RACE_DESC urquan_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_SPECIAL,
+		30, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		URQUAN_RACE_STRINGS,
+		URQUAN_ICON_MASK_PMAP_ANIM,
+		URQUAN_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			0,0,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			URQUAN_BIG_MASK_PMAP_ANIM,
+			URQUAN_MED_MASK_PMAP_ANIM,
+			URQUAN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			FUSION_BIG_MASK_PMAP_ANIM,
+			FUSION_MED_MASK_PMAP_ANIM,
+			FUSION_SML_MASK_PMAP_ANIM,
+		},
+		{
+			FIGHTER_BIG_MASK_PMAP_ANIM,
+			FIGHTER_MED_MASK_PMAP_ANIM,
+			FIGHTER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			URQUAN_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		URQUAN_VICTORY_SONG,
+		URQUAN_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_SPEED_4XRES * MISSILE_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static COUNT
 initialize_fusion (ELEMENT *ShipPtr, HELEMENT FusionArray[])
 {
 #define MISSILE_HITS 10
 #define MISSILE_DAMAGE 6
-#define MISSILE_OFFSET 8
-#define URQUAN_OFFSET 32
+#define MISSILE_OFFSET (8 << RESOLUTION_FACTOR) // JMS_GFX
+#define URQUAN_OFFSET (32 << RESOLUTION_FACTOR) // JMS_GFX
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -131,7 +285,7 @@ initialize_fusion (ELEMENT *ShipPtr, HEL
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = URQUAN_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -143,13 +297,13 @@ initialize_fusion (ELEMENT *ShipPtr, HEL
 }
 
 #define TRACK_THRESHOLD 6
-#define FIGHTER_SPEED DISPLAY_TO_WORLD (8)
+#define FIGHTER_SPEED DISPLAY_TO_WORLD (8 << RESOLUTION_FACTOR) // JMS_GFX
 #define ONE_WAY_FLIGHT 125
 #define FIGHTER_LIFE (ONE_WAY_FLIGHT + ONE_WAY_FLIGHT + 150)
 
 #define FIGHTER_WEAPON_WAIT 8
-#define FIGHTER_OFFSET 4
-#define LASER_RANGE DISPLAY_TO_WORLD (40 + FIGHTER_OFFSET)
+#define FIGHTER_OFFSET (4 << RESOLUTION_FACTOR) // JMS_GFX
+#define LASER_RANGE DISPLAY_TO_WORLD ((40 << RESOLUTION_FACTOR) + FIGHTER_OFFSET) // JMS_GFX
 
 static void
 fighter_postprocess (ELEMENT *ElementPtr)
@@ -274,16 +428,16 @@ fighter_preprocess (ELEMENT *ElementPtr)
 				if (ElementPtr->turn_wait & LEFT)
 				{
 					delta_x += COSINE (FACING_TO_ANGLE (facing - 4),
-							DISPLAY_TO_WORLD (30));
+							DISPLAY_TO_WORLD (30 << RESOLUTION_FACTOR)); // JMS_GFX
 					delta_y += SINE (FACING_TO_ANGLE (facing - 4),
-							DISPLAY_TO_WORLD (30));
+							DISPLAY_TO_WORLD (30 << RESOLUTION_FACTOR));
 				}
 				else
 				{
 					delta_x += COSINE (FACING_TO_ANGLE (facing + 4),
-							DISPLAY_TO_WORLD (30));
+							DISPLAY_TO_WORLD (30 << RESOLUTION_FACTOR)); // JMS_GFX
 					delta_y += SINE (FACING_TO_ANGLE (facing + 4),
-							DISPLAY_TO_WORLD (30));
+							DISPLAY_TO_WORLD (30 << RESOLUTION_FACTOR));
 				}
 				facing = NORMALIZE_FACING (
 						ANGLE_TO_FACING (ARCTAN (delta_x, delta_y))
@@ -400,8 +554,8 @@ spawn_fighters (ELEMENT *ElementPtr)
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	facing = StarShipPtr->ShipFacing + ANGLE_TO_FACING (HALF_CIRCLE);
-	delta_x = COSINE (FACING_TO_ANGLE (facing), DISPLAY_TO_WORLD (14));
-	delta_y = SINE (FACING_TO_ANGLE (facing), DISPLAY_TO_WORLD (14));
+	delta_x = COSINE (FACING_TO_ANGLE (facing), DISPLAY_TO_WORLD (14 << RESOLUTION_FACTOR)); // JMS_GFX
+	delta_y = SINE (FACING_TO_ANGLE (facing), DISPLAY_TO_WORLD (14 << RESOLUTION_FACTOR));
 
 	i = ElementPtr->crew_level > 2 ? 2 : 1;
 	while (i-- && (hFighterElement = AllocElement ()))
@@ -468,7 +622,7 @@ urquan_intelligence (ELEMENT *ShipPtr, E
 {
 	EVALUATE_DESC *lpEvalDesc;
 	STARSHIP *StarShipPtr;
-
+	
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 
 	 ObjectsOfConcern[ENEMY_SHIP_INDEX].MoveState = PURSUE;
@@ -482,6 +636,14 @@ urquan_intelligence (ELEMENT *ShipPtr, E
 			&& lpEvalDesc->which_turn == 2
 			&& ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn > 16)))
 		lpEvalDesc->MoveState = PURSUE;
+	
+	/*if (lpEvalDesc->ObjectPtr)
+	{
+		if (lpEvalDesc->ObjectPtr->state_flags & GASSY_SUBSTANCE 
+			&& lpEvalDesc->ObjectPtr->mass_points == 0
+			&& lpEvalDesc->which_turn <= 1)
+			ObjectsOfConcern[ENEMY_SHIP_INDEX].MoveState = ENTICE;
+	}*/
 
 	ship_intelligence (ShipPtr,
 			ObjectsOfConcern, ConcernCounter);
@@ -497,11 +659,14 @@ urquan_intelligence (ELEMENT *ShipPtr, E
 				&& StarShipPtr->RaceDescPtr->ship_info.crew_level >
 				(StarShipPtr->RaceDescPtr->ship_info.max_crew >> 2)
 				&& !(EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags
-				& POINT_DEFENSE)
+					& (LIGHT_POINT_DEFENSE | HEAVY_POINT_DEFENSE))
+				&& (EnemyStarShipPtr->SpeciesID != BAUL_ID
+					|| (EnemyStarShipPtr->SpeciesID == BAUL_ID && lpEvalDesc->which_turn <= 14))
+				&& (EnemyStarShipPtr->SpeciesID != FOONFOON_ID
+					|| (EnemyStarShipPtr->SpeciesID == FOONFOON_ID && lpEvalDesc->which_turn <= 14))
 				&& (StarShipPtr->RaceDescPtr->characteristics.special_wait < 6
-				|| (MANEUVERABILITY (
-						&EnemyStarShipPtr->RaceDescPtr->cyborg_control
-						) <= SLOW_SHIP
+				|| (MANEUVERABILITY (&EnemyStarShipPtr->RaceDescPtr->cyborg_control
+					) <= (SLOW_SHIP << RESOLUTION_FACTOR) // JMS_GFX
 				&& !(EnemyStarShipPtr->cur_status_flags & SHIP_BEYOND_MAX_SPEED))
 				|| (lpEvalDesc->which_turn <= 12
 				&& (StarShipPtr->ship_input_state & (LEFT | RIGHT))
@@ -540,11 +705,27 @@ init_urquan (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	urquan_desc.postprocess_func = urquan_postprocess;
-	urquan_desc.init_weapon_func = initialize_fusion;
-	urquan_desc.cyborg_control.intelligence_func = urquan_intelligence;
-
-	RaceDescPtr = &urquan_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		urquan_desc.postprocess_func = urquan_postprocess;
+		urquan_desc.init_weapon_func = initialize_fusion;
+		urquan_desc.cyborg_control.intelligence_func = urquan_intelligence;
+		RaceDescPtr = &urquan_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		urquan_desc_2xres.postprocess_func = urquan_postprocess;
+		urquan_desc_2xres.init_weapon_func = initialize_fusion;
+		urquan_desc_2xres.cyborg_control.intelligence_func = urquan_intelligence;
+		RaceDescPtr = &urquan_desc_2xres;
+	}
+	else
+	{
+		urquan_desc_4xres.postprocess_func = urquan_postprocess;
+		urquan_desc_4xres.init_weapon_func = initialize_fusion;
+		urquan_desc_4xres.cyborg_control.intelligence_func = urquan_intelligence;
+		RaceDescPtr = &urquan_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp src.orig/uqm/ships/utwig/icode.h src/uqm/ships/utwig/icode.h
--- src.orig/uqm/ships/utwig/icode.h	2017-11-01 15:30:28 -0700
+++ src/uqm/ships/utwig/icode.h	2017-11-01 15:31:05 -0700
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define UTWIG_CODE "ship.utwig.code"
diff -ruNp src.orig/uqm/ships/utwig/utwig.c src/uqm/ships/utwig/utwig.c
--- src.orig/uqm/ships/utwig/utwig.c	2017-11-01 15:30:28 -0700
+++ src/uqm/ships/utwig/utwig.c	2017-11-01 15:31:05 -0700
@@ -23,6 +23,8 @@
 #include "uqm/globdata.h"
 #include "libs/mathlib.h"
 
+#include "libs/log.h"
+
 
 #define MAX_CREW 20
 #define MAX_ENERGY 20
@@ -39,25 +41,25 @@
 
 #define SHIP_MASS 8
 #define UTWIG_OFFSET 9
-#define MISSILE_SPEED DISPLAY_TO_WORLD (30)
+#define MISSILE_SPEED DISPLAY_TO_WORLD (30 << RESOLUTION_FACTOR)
 #define MISSILE_LIFE 10
 
 static RACE_DESC utwig_desc =
 {
 	{ /* SHIP_INFO */
-		FIRES_FORE | POINT_DEFENSE | SHIELD_DEFENSE,
+		FIRES_FORE | SHIELD_DEFENSE | LIGHT_POINT_DEFENSE,
 		22, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
 		MAX_ENERGY >> 1, MAX_ENERGY,
 		UTWIG_RACE_STRINGS,
 		UTWIG_ICON_MASK_PMAP_ANIM,
 		UTWIG_MICON_MASK_PMAP_ANIM,
-		NULL, NULL, NULL
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
 	},
 	{ /* FLEET_STUFF */
-		666 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		0, /* Initial SoI radius */
 		{ /* Known location (center of SoI) */
-			8534, 8797,
+			0,0,
 		},
 	},
 	{
@@ -113,18 +115,170 @@ static RACE_DESC utwig_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+#define MAX_THRUST_2XRES 72
+#define THRUST_INCREMENT_2XRES 12
+
+// JMS_GFX
+static RACE_DESC utwig_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SHIELD_DEFENSE | LIGHT_POINT_DEFENSE,
+		22, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY >> 1, MAX_ENERGY,
+		UTWIG_RACE_STRINGS,
+		UTWIG_ICON_MASK_PMAP_ANIM,
+		UTWIG_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			0,0,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			UTWIG_BIG_MASK_PMAP_ANIM,
+			UTWIG_MED_MASK_PMAP_ANIM,
+			UTWIG_SML_MASK_PMAP_ANIM,
+		},
+		{
+			LANCE_BIG_MASK_PMAP_ANIM,
+			LANCE_MED_MASK_PMAP_ANIM,
+			LANCE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			UTWIG_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		UTWIG_VICTORY_SONG,
+		UTWIG_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 144
+#define THRUST_INCREMENT_4XRES 24
+
+// JMS_GFX
+static RACE_DESC utwig_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SHIELD_DEFENSE | LIGHT_POINT_DEFENSE,
+		22, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY >> 1, MAX_ENERGY,
+		UTWIG_RACE_STRINGS,
+		UTWIG_ICON_MASK_PMAP_ANIM,
+		UTWIG_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			0,0,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			UTWIG_BIG_MASK_PMAP_ANIM,
+			UTWIG_MED_MASK_PMAP_ANIM,
+			UTWIG_SML_MASK_PMAP_ANIM,
+		},
+		{
+			LANCE_BIG_MASK_PMAP_ANIM,
+			LANCE_MED_MASK_PMAP_ANIM,
+			LANCE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			UTWIG_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		UTWIG_VICTORY_SONG,
+		UTWIG_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static COUNT
 initialize_lance (ELEMENT *ShipPtr, HELEMENT WeaponArray[])
 {
-#define LAUNCH_XOFFS0 DISPLAY_TO_WORLD (5)
-#define LAUNCH_YOFFS0 -DISPLAY_TO_WORLD (18)
-#define LAUNCH_XOFFS1 DISPLAY_TO_WORLD (13)
-#define LAUNCH_YOFFS1 -DISPLAY_TO_WORLD (9)
-#define LAUNCH_XOFFS2 DISPLAY_TO_WORLD (17)
-#define LAUNCH_YOFFS2 -DISPLAY_TO_WORLD (4)
+#define LAUNCH_XOFFS0 DISPLAY_TO_WORLD (5 << RESOLUTION_FACTOR) // JMS_GFX
+#define LAUNCH_YOFFS0 -DISPLAY_TO_WORLD (18 << RESOLUTION_FACTOR) // JMS_GFX
+#define LAUNCH_XOFFS1 DISPLAY_TO_WORLD (13 << RESOLUTION_FACTOR) // JMS_GFX
+#define LAUNCH_YOFFS1 -DISPLAY_TO_WORLD (9 << RESOLUTION_FACTOR) // JMS_GFX
+#define LAUNCH_XOFFS2 DISPLAY_TO_WORLD (17 << RESOLUTION_FACTOR) // JMS_GFX
+#define LAUNCH_YOFFS2 -DISPLAY_TO_WORLD (4 << RESOLUTION_FACTOR) // JMS_GFX
 #define MISSILE_HITS 1
 #define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET 1
+#define MISSILE_OFFSET (1 << RESOLUTION_FACTOR) // JMS_GFX
 	COUNT i;
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
@@ -192,6 +346,7 @@ utwig_intelligence (ELEMENT *ShipPtr, EV
 	SIZE ShieldStatus;
 	STARSHIP *StarShipPtr;
 	EVALUATE_DESC *lpEvalDesc;
+	BYTE in_gas_cloud = 0;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 
@@ -203,11 +358,20 @@ utwig_intelligence (ELEMENT *ShipPtr, EV
 		ShieldStatus = -1;
 		if (lpEvalDesc->ObjectPtr && lpEvalDesc->MoveState == ENTICE)
 		{
+			STARSHIP *WeaponStarShipPtr;
+		
+			GetElementStarShip (lpEvalDesc->ObjectPtr, &WeaponStarShipPtr);
+
 			ShieldStatus = 0;
-			if (!(lpEvalDesc->ObjectPtr->state_flags & FINITE_LIFE))
+			if (!(lpEvalDesc->ObjectPtr->state_flags & FINITE_LIFE)
+				// Shiver: AI does not raise shields at Lurg oil blobs.		
+				&& !(WeaponStarShipPtr && WeaponStarShipPtr->SpeciesID == LURG_ID
+					&& lpEvalDesc->ObjectPtr->mass_points < 2))
+			{
 				lpEvalDesc->MoveState = PURSUE;
+			}
 			else if (lpEvalDesc->ObjectPtr->mass_points
-					|| (lpEvalDesc->ObjectPtr->state_flags & CREW_OBJECT))
+				|| lpEvalDesc->ObjectPtr->state_flags & CREW_OBJECT)
 			{
 				if ((lpEvalDesc->which_turn >>= 1) == 0)
 					lpEvalDesc->which_turn = 1;
@@ -220,20 +384,27 @@ utwig_intelligence (ELEMENT *ShipPtr, EV
 			}
 		}
 	}
+	
+	if (lpEvalDesc->ObjectPtr)
+	{
+		if (lpEvalDesc->ObjectPtr->state_flags & GASSY_SUBSTANCE 
+			&& lpEvalDesc->ObjectPtr->mass_points == 0
+			&& lpEvalDesc->which_turn <= 1)
+			in_gas_cloud = 1;
+	}
 
 	if (StarShipPtr->special_counter == 0)
 	{
 		StarShipPtr->ship_input_state &= ~SPECIAL;
 		if (ShieldStatus)
 		{
-			if ((ShieldStatus > 0 || lpEvalDesc->ObjectPtr)
-					&& lpEvalDesc->which_turn <= 2
-					&& (ShieldStatus > 0
-					|| (lpEvalDesc->ObjectPtr->state_flags
-					& PLAYER_SHIP) /* means IMMEDIATE WEAPON */
-					|| PlotIntercept (lpEvalDesc->ObjectPtr,
-					ShipPtr, 2, 0))
-					&& (TFB_Random () & 3))
+			if (((ShieldStatus > 0 || lpEvalDesc->ObjectPtr)
+				&& lpEvalDesc->which_turn <= 2
+				&& (ShieldStatus > 0
+				|| (lpEvalDesc->ObjectPtr->state_flags & PLAYER_SHIP) // means IMMEDIATE_WEAPON.
+				|| PlotIntercept (lpEvalDesc->ObjectPtr, ShipPtr, 2, 0))
+				&& (TFB_Random () & 3))
+				&& (!lpEvalDesc->ObjectPtr || !(lpEvalDesc->ObjectPtr->state_flags & GASSY_SUBSTANCE))) // JMS: means: Don't deflect Baul gas or spray.
 			{
 				StarShipPtr->ship_input_state |= SPECIAL;
 				StarShipPtr->ship_input_state &= ~WEAPON;
@@ -243,27 +414,53 @@ utwig_intelligence (ELEMENT *ShipPtr, EV
 		}
 	}
 
-	if (StarShipPtr->RaceDescPtr->ship_info.energy_level
-			&& (lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX])->ObjectPtr)
+	if ((lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX])->ObjectPtr)
 	{
 		STARSHIP *EnemyStarShipPtr;
+		SBYTE facing_difference;
 
 		GetElementStarShip (lpEvalDesc->ObjectPtr, &EnemyStarShipPtr);
-		if (!(EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags
-				& IMMEDIATE_WEAPON))
+		
+		// JMS: When in Baul gas cloud, engage shield when Baul ship is near, firing primary and facing in Utwig's general direction.
+		// XXX: This is not 100% accurate but works usually since Utwig is most often chasing the enemy and thus facing him.
+		facing_difference = StarShipPtr->ShipFacing - ((EnemyStarShipPtr->ShipFacing + 8) % 16);
+		if (in_gas_cloud
+			&& lpEvalDesc->which_turn <= 20
+			&& (EnemyStarShipPtr->ship_input_state & WEAPON)
+			&& (facing_difference < 2 && facing_difference > -2))
+			StarShipPtr->ship_input_state |= SPECIAL;
+		
+		//log_add (log_Debug, "my_facing %d, his facing-8by16 %d, difference %d", StarShipPtr->ShipFacing, (EnemyStarShipPtr->ShipFacing + 8) % 16, facing_difference);
+		
+		if (!(EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags & IMMEDIATE_WEAPON)
+				&& StarShipPtr->RaceDescPtr->ship_info.energy_level)
+		{
 			lpEvalDesc->MoveState = PURSUE;
+		}
 	}
+
 	ship_intelligence (ShipPtr, ObjectsOfConcern, ConcernCounter);
 }
 
+// Shiver: I have applied several new conditions to Utwig's shield.
 static void
 utwig_collision (ELEMENT *ElementPtr0, POINT *pPt0,
 		ELEMENT *ElementPtr1, POINT *pPt1)
 {
+	STARSHIP *EnemyStarShipPtr;
+
+	GetElementStarShip (ElementPtr1, &EnemyStarShipPtr);
+
 	if (ElementPtr0->life_span > NORMAL_LIFE
 			&& (ElementPtr1->state_flags & FINITE_LIFE)
-			&& ElementPtr1->mass_points)
+			&& ElementPtr1->mass_points
+			// Prevent Chmmr satellites from charging up Utwig's battery during collision.
+			&& !(EnemyStarShipPtr->SpeciesID == CHMMR_ID && ElementPtr1->mass_points == 10)
+			// Do not gain energy from Lurg blobs; these inflict no damage against ships.
+			&& !(EnemyStarShipPtr->SpeciesID == LURG_ID && ElementPtr1->mass_points < 2))
+	{
 		ElementPtr0->life_span += ElementPtr1->mass_points;
+	}
 
 	collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
 }
@@ -296,7 +493,7 @@ utwig_preprocess (ELEMENT *ElementPtr)
 	{
 		if (!DeltaEnergy (ElementPtr, -SPECIAL_ENERGY_COST))
 			StarShipPtr->RaceDescPtr->ship_info.ship_flags &=
-					~(POINT_DEFENSE | SHIELD_DEFENSE);
+					~(LIGHT_POINT_DEFENSE | SHIELD_DEFENSE);
 		else if (StarShipPtr->special_counter == 0)
 		{
 			StarShipPtr->special_counter =
@@ -311,8 +508,7 @@ utwig_preprocess (ELEMENT *ElementPtr)
 	if (StarShipPtr->special_counter == 0)
 	{
 		// The shield is off.
-		SetPrimColor (lpPrim,
-				BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1C, 0x00), 0x78));
+		SetPrimColor (lpPrim, BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1C, 0x00), 0x78));
 		ElementPtr->colorCycleIndex = 0;
 		ElementPtr->life_span = NORMAL_LIFE;
 		SetPrimType (lpPrim, STAMP_PRIM);
@@ -366,11 +562,27 @@ init_utwig (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	utwig_desc.preprocess_func = utwig_preprocess;
-	utwig_desc.init_weapon_func = initialize_lance;
-	utwig_desc.cyborg_control.intelligence_func = utwig_intelligence;
-
-	RaceDescPtr = &utwig_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		utwig_desc.preprocess_func = utwig_preprocess;
+		utwig_desc.init_weapon_func = initialize_lance;
+		utwig_desc.cyborg_control.intelligence_func = utwig_intelligence;
+		RaceDescPtr = &utwig_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		utwig_desc_2xres.preprocess_func = utwig_preprocess;
+		utwig_desc_2xres.init_weapon_func = initialize_lance;
+		utwig_desc_2xres.cyborg_control.intelligence_func = utwig_intelligence;
+		RaceDescPtr = &utwig_desc_2xres;
+	}
+	else
+	{
+		utwig_desc_4xres.preprocess_func = utwig_preprocess;
+		utwig_desc_4xres.init_weapon_func = initialize_lance;
+		utwig_desc_4xres.cyborg_control.intelligence_func = utwig_intelligence;
+		RaceDescPtr = &utwig_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp src.orig/uqm/ships/vux/icode.h src/uqm/ships/vux/icode.h
--- src.orig/uqm/ships/vux/icode.h	2017-11-01 15:30:28 -0700
+++ src/uqm/ships/vux/icode.h	2017-11-01 15:31:05 -0700
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define VUX_CODE "ship.vux.code"
diff -ruNp src.orig/uqm/ships/vux/vux.c src/uqm/ships/vux/vux.c
--- src.orig/uqm/ships/vux/vux.c	2017-11-01 15:30:28 -0700
+++ src/uqm/ships/vux/vux.c	2017-11-01 15:31:05 -0700
@@ -38,9 +38,9 @@
 #define SPECIAL_WAIT 7
 
 #define SHIP_MASS 6
-#define WARP_OFFSET 46 /* How far outside of laser-range ship can warp in */
-#define VUX_OFFSET 12
-#define LASER_BASE 150
+#define WARP_OFFSET (46 << RESOLUTION_FACTOR) // JMS_GFX /* How far outside of laser-range ship can warp in */
+#define VUX_OFFSET (12 << RESOLUTION_FACTOR) // JMS_GFX
+#define LASER_BASE (150 << RESOLUTION_FACTOR) // JMS_GFX
 #define LASER_RANGE DISPLAY_TO_WORLD (LASER_BASE + VUX_OFFSET)
 
 static RACE_DESC vux_desc =
@@ -53,12 +53,12 @@ static RACE_DESC vux_desc =
 		VUX_RACE_STRINGS,
 		VUX_ICON_MASK_PMAP_ANIM,
 		VUX_MICON_MASK_PMAP_ANIM,
-		NULL, NULL, NULL
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
 	},
 	{ /* FLEET_STUFF */
-		900 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		50 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
 		{ /* Known location (center of SoI) */
-			4412, 1558,
+			9333,7687,
 		},
 	},
 	{
@@ -114,7 +114,159 @@ static RACE_DESC vux_desc =
 	0, /* CodeRef */
 };
 
-#define LIMPET_SPEED 25
+// JMS_GFX
+#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (5) */ 42
+#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (2) */ 14
+
+// JMS_GFX
+static RACE_DESC vux_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_SPECIAL | IMMEDIATE_WEAPON,
+		12, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		VUX_RACE_STRINGS,
+		VUX_ICON_MASK_PMAP_ANIM,
+		VUX_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		50 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			9333,7687,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			VUX_BIG_MASK_PMAP_ANIM,
+			VUX_MED_MASK_PMAP_ANIM,
+			VUX_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SLIME_MASK_PMAP_ANIM,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			LIMPETS_BIG_MASK_PMAP_ANIM,
+			LIMPETS_MED_MASK_PMAP_ANIM,
+			LIMPETS_SML_MASK_PMAP_ANIM,
+		},
+		{
+			VUX_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		VUX_VICTORY_SONG,
+		VUX_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (5) */ 84
+#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (2) */ 28
+
+// JMS_GFX
+static RACE_DESC vux_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_SPECIAL | IMMEDIATE_WEAPON,
+		12, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		VUX_RACE_STRINGS,
+		VUX_ICON_MASK_PMAP_ANIM,
+		VUX_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		50 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			9333,7687,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			VUX_BIG_MASK_PMAP_ANIM,
+			VUX_MED_MASK_PMAP_ANIM,
+			VUX_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SLIME_MASK_PMAP_ANIM,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			LIMPETS_BIG_MASK_PMAP_ANIM,
+			LIMPETS_MED_MASK_PMAP_ANIM,
+			LIMPETS_SML_MASK_PMAP_ANIM,
+		},
+		{
+			VUX_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		VUX_VICTORY_SONG,
+		VUX_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+#define LIMPET_SPEED (25 << RESOLUTION_FACTOR) // JMS_GFX
 
 static void
 limpet_preprocess (ELEMENT *ElementPtr)
@@ -122,18 +274,15 @@ limpet_preprocess (ELEMENT *ElementPtr)
 	COUNT facing, orig_facing;
 	SIZE delta_facing;
 
-	facing = orig_facing = NORMALIZE_FACING (ANGLE_TO_FACING (
-			GetVelocityTravelAngle (&ElementPtr->velocity)
-			));
+	facing = orig_facing = NORMALIZE_FACING (ANGLE_TO_FACING (GetVelocityTravelAngle (&ElementPtr->velocity)));
+	
 	if ((delta_facing = TrackShip (ElementPtr, &facing)) > 0)
 	{
 		facing = orig_facing + delta_facing;
-		SetVelocityVector (&ElementPtr->velocity,
-				LIMPET_SPEED, facing);
+		SetVelocityVector (&ElementPtr->velocity, LIMPET_SPEED, facing);
 	}
-	ElementPtr->next.image.frame =
-			 IncFrameIndex (ElementPtr->next.image.frame);
-
+	
+	ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->next.image.frame);
 	ElementPtr->state_flags |= CHANGING;
 }
 
@@ -154,21 +303,18 @@ limpet_collision (ELEMENT *ElementPtr0,
 			--RDPtr->characteristics.turn_wait;
 		if (++RDPtr->characteristics.thrust_wait == 0)
 			--RDPtr->characteristics.thrust_wait;
-#define MIN_THRUST_INCREMENT DISPLAY_TO_WORLD (1)
+#define MIN_THRUST_INCREMENT DISPLAY_TO_WORLD (1 << RESOLUTION_FACTOR) // JMS_GFX
 		if (RDPtr->characteristics.thrust_increment <= MIN_THRUST_INCREMENT)
 		{
-			RDPtr->characteristics.max_thrust =
-					RDPtr->characteristics.thrust_increment << 1;
+			RDPtr->characteristics.max_thrust = RDPtr->characteristics.thrust_increment << 1;
 		}
 		else
 		{
 			COUNT num_thrusts;
 
-			num_thrusts = RDPtr->characteristics.max_thrust /
-					RDPtr->characteristics.thrust_increment;
-			--RDPtr->characteristics.thrust_increment;
-			RDPtr->characteristics.max_thrust =
-					RDPtr->characteristics.thrust_increment * num_thrusts;
+			num_thrusts = RDPtr->characteristics.max_thrust / RDPtr->characteristics.thrust_increment;
+			RDPtr->characteristics.thrust_increment -= 1 << RESOLUTION_FACTOR; // JMS_GFX
+			RDPtr->characteristics.max_thrust = RDPtr->characteristics.thrust_increment * num_thrusts;
 		}
 		RDPtr->cyborg_control.ManeuverabilityIndex = 0;
 
@@ -193,7 +339,7 @@ limpet_collision (ELEMENT *ElementPtr0,
 static void
 spawn_limpets (ELEMENT *ElementPtr)
 {
-#define LIMPET_OFFSET 8
+#define LIMPET_OFFSET (8 << RESOLUTION_FACTOR) // JMS_GFX
 #define LIMPET_LIFE 80
 #define LIMPET_HITS 1
 #define LIMPET_DAMAGE 0
@@ -381,12 +527,30 @@ init_vux (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	vux_desc.preprocess_func = vux_preprocess;
-	vux_desc.postprocess_func = vux_postprocess;
-	vux_desc.init_weapon_func = initialize_horrific_laser;
-	vux_desc.cyborg_control.intelligence_func = vux_intelligence;
-
-	RaceDescPtr = &vux_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		vux_desc.preprocess_func = vux_preprocess;
+		vux_desc.postprocess_func = vux_postprocess;
+		vux_desc.init_weapon_func = initialize_horrific_laser;
+		vux_desc.cyborg_control.intelligence_func = vux_intelligence;
+		RaceDescPtr = &vux_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		vux_desc_2xres.preprocess_func = vux_preprocess;
+		vux_desc_2xres.postprocess_func = vux_postprocess;
+		vux_desc_2xres.init_weapon_func = initialize_horrific_laser;
+		vux_desc_2xres.cyborg_control.intelligence_func = vux_intelligence;
+		RaceDescPtr = &vux_desc_2xres;
+	}
+	else
+	{
+		vux_desc_4xres.preprocess_func = vux_preprocess;
+		vux_desc_4xres.postprocess_func = vux_postprocess;
+		vux_desc_4xres.init_weapon_func = initialize_horrific_laser;
+		vux_desc_4xres.cyborg_control.intelligence_func = vux_intelligence;
+		RaceDescPtr = &vux_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp src.orig/uqm/ships/yehat/icode.h src/uqm/ships/yehat/icode.h
--- src.orig/uqm/ships/yehat/icode.h	2017-11-01 15:30:28 -0700
+++ src/uqm/ships/yehat/icode.h	2017-11-01 15:31:05 -0700
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define YEHAT_CODE "ship.yehat.code"
diff -ruNp src.orig/uqm/ships/yehat/yehat.c src/uqm/ships/yehat/yehat.c
--- src.orig/uqm/ships/yehat/yehat.c	2017-11-01 15:30:28 -0700
+++ src/uqm/ships/yehat/yehat.c	2017-11-01 15:31:05 -0700
@@ -21,6 +21,7 @@
 #include "resinst.h"
 
 #include "libs/mathlib.h"
+#include "libs/log.h"
 
 
 #define MAX_CREW 20
@@ -50,12 +51,12 @@ static RACE_DESC yehat_desc =
 		YEHAT_RACE_STRINGS,
 		YEHAT_ICON_MASK_PMAP_ANIM,
 		YEHAT_MICON_MASK_PMAP_ANIM,
-		NULL, NULL, NULL
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
 	},
 	{ /* FLEET_STUFF */
-		750 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		800/ SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
 		{ /* Known location (center of SoI) */
-			4970, 40,
+			9923, 6294,
 		},
 	},
 	{
@@ -111,14 +112,168 @@ static RACE_DESC yehat_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+#define MAX_THRUST_2XRES 60
+#define THRUST_INCREMENT_2XRES 12
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (40)
+
+// JMS_GFX
+static RACE_DESC yehat_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SHIELD_DEFENSE,
+		23, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		YEHAT_RACE_STRINGS,
+		YEHAT_ICON_MASK_PMAP_ANIM,
+		YEHAT_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		800/ SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			9923, 6294,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			YEHAT_BIG_MASK_PMAP_ANIM,
+			YEHAT_MED_MASK_PMAP_ANIM,
+			YEHAT_SML_MASK_PMAP_ANIM,
+		},
+		{
+			YEHAT_CANNON_BIG_MASK_PMAP_ANIM,
+			YEHAT_CANNON_MED_MASK_PMAP_ANIM,
+			YEHAT_CANNON_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SHIELD_BIG_MASK_ANIM,
+			SHIELD_MED_MASK_ANIM,
+			SHIELD_SML_MASK_ANIM,
+		},
+		{
+			YEHAT_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		YEHAT_VICTORY_SONG,
+		YEHAT_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_SPEED_2XRES * MISSILE_LIFE / 3,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 120
+#define THRUST_INCREMENT_4XRES 24
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (80)
+
+// JMS_GFX
+static RACE_DESC yehat_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SHIELD_DEFENSE,
+		23, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		YEHAT_RACE_STRINGS,
+		YEHAT_ICON_MASK_PMAP_ANIM,
+		YEHAT_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		800/ SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			9923, 6294,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			YEHAT_BIG_MASK_PMAP_ANIM,
+			YEHAT_MED_MASK_PMAP_ANIM,
+			YEHAT_SML_MASK_PMAP_ANIM,
+		},
+		{
+			YEHAT_CANNON_BIG_MASK_PMAP_ANIM,
+			YEHAT_CANNON_MED_MASK_PMAP_ANIM,
+			YEHAT_CANNON_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SHIELD_BIG_MASK_ANIM,
+			SHIELD_MED_MASK_ANIM,
+			SHIELD_SML_MASK_ANIM,
+		},
+		{
+			YEHAT_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		YEHAT_VICTORY_SONG,
+		YEHAT_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_SPEED_4XRES * MISSILE_LIFE / 3,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static COUNT
 initialize_standard_missiles (ELEMENT *ShipPtr, HELEMENT MissileArray[])
 {
-#define YEHAT_OFFSET 16
-#define LAUNCH_OFFS DISPLAY_TO_WORLD (8)
+#define YEHAT_OFFSET (16 << RESOLUTION_FACTOR) // JMS_GFX
+#define LAUNCH_OFFS DISPLAY_TO_WORLD (8 << RESOLUTION_FACTOR) // JMS_GFX
 #define MISSILE_HITS 1
 #define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET 1
+#define MISSILE_OFFSET (1 << RESOLUTION_FACTOR) // JMS_GFX
 	SIZE offs_x, offs_y;
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
@@ -129,7 +284,7 @@ initialize_standard_missiles (ELEMENT *S
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = YEHAT_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -151,22 +306,33 @@ initialize_standard_missiles (ELEMENT *S
 }
 
 static void
-yehat_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
-		COUNT ConcernCounter)
+yehat_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern, COUNT ConcernCounter)
 {
 	SIZE ShieldStatus;
 	STARSHIP *StarShipPtr;
 	EVALUATE_DESC *lpEvalDesc;
+	BYTE in_gas_cloud = 0;
+
+	GetElementStarShip (ShipPtr, &StarShipPtr);
 
 	ShieldStatus = -1;
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_WEAPON_INDEX];
 	if (lpEvalDesc->ObjectPtr && lpEvalDesc->MoveState == ENTICE)
 	{
+		STARSHIP *WeaponStarShipPtr;
+		
+		GetElementStarShip (lpEvalDesc->ObjectPtr, &WeaponStarShipPtr);
+
 		ShieldStatus = 0;
-		if (!(lpEvalDesc->ObjectPtr->state_flags & (FINITE_LIFE | CREW_OBJECT)))
+		if (!(lpEvalDesc->ObjectPtr->state_flags & (FINITE_LIFE | CREW_OBJECT))
+			// Shiver: AI does not raise shields at Lurg oil blobs.		
+			&& !(WeaponStarShipPtr && WeaponStarShipPtr->SpeciesID == LURG_ID
+				&& lpEvalDesc->ObjectPtr->mass_points < 2))
+		{
 			lpEvalDesc->MoveState = PURSUE;
+		}
 		else if (lpEvalDesc->ObjectPtr->mass_points
-				|| (lpEvalDesc->ObjectPtr->state_flags & CREW_OBJECT))
+			|| lpEvalDesc->ObjectPtr->state_flags & CREW_OBJECT)
 		{
 			if (!(lpEvalDesc->ObjectPtr->state_flags & FINITE_LIFE))
 				lpEvalDesc->which_turn <<= 1;
@@ -183,26 +349,31 @@ yehat_intelligence (ELEMENT *ShipPtr, EV
 			ShieldStatus = 1;
 		}
 	}
+	
+	if (lpEvalDesc->ObjectPtr)
+	{
+		if (lpEvalDesc->ObjectPtr->state_flags & GASSY_SUBSTANCE 
+			&& lpEvalDesc->ObjectPtr->mass_points == 0
+			&& lpEvalDesc->which_turn <= 1)
+			in_gas_cloud = 1;
+	}
 
-	GetElementStarShip (ShipPtr, &StarShipPtr);
 	if (StarShipPtr->special_counter == 0)
 	{
 		StarShipPtr->ship_input_state &= ~SPECIAL;
 		if (ShieldStatus)
 		{
-			if (ShipPtr->life_span <= NORMAL_LIFE + 1
-					&& (ShieldStatus > 0 || lpEvalDesc->ObjectPtr)
-					&& lpEvalDesc->which_turn <= 2
-					&& (ShieldStatus > 0
-					|| (lpEvalDesc->ObjectPtr->state_flags
-					& PLAYER_SHIP) /* means IMMEDIATE WEAPON */
-					|| PlotIntercept (lpEvalDesc->ObjectPtr,
-					ShipPtr, 2, 0))
-					&& (TFB_Random () & 3))
+            if (ShipPtr->life_span <= NORMAL_LIFE + 1
+                    && (ShieldStatus > 0 || lpEvalDesc->ObjectPtr)
+                    && lpEvalDesc->which_turn <= 2
+                    && (ShieldStatus > 0
+                            || (lpEvalDesc->ObjectPtr->state_flags & PLAYER_SHIP) // means IMMEDIATE_WEAPON.
+                            || PlotIntercept (lpEvalDesc->ObjectPtr, ShipPtr, 2, 0))
+                    && (TFB_Random () & 3)
+                    && !(lpEvalDesc->ObjectPtr && lpEvalDesc->ObjectPtr->state_flags & GASSY_SUBSTANCE)) // JMS: means: Don't deflect Baul gas or spray.
 				StarShipPtr->ship_input_state |= SPECIAL;
 
-			if (lpEvalDesc->ObjectPtr
-					&& !(lpEvalDesc->ObjectPtr->state_flags & CREW_OBJECT))
+			if (lpEvalDesc->ObjectPtr && !(lpEvalDesc->ObjectPtr->state_flags & CREW_OBJECT))
 				lpEvalDesc->ObjectPtr = 0;
 		}
 	}
@@ -210,12 +381,32 @@ yehat_intelligence (ELEMENT *ShipPtr, EV
 	if ((lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX])->ObjectPtr)
 	{
 		STARSHIP *EnemyStarShipPtr;
+		SBYTE facing_difference;
 
 		GetElementStarShip (lpEvalDesc->ObjectPtr, &EnemyStarShipPtr);
-		if (!(EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags
-				& IMMEDIATE_WEAPON))
+			
+		// JMS: When in Baul gas cloud, engage shield when Baul ship is near, firing primary and facing in Yehat's general direction.
+		// XXX: This is not 100% accurate but works usually since Yehat is most often chasing the enemy and thus facing him.
+		facing_difference = StarShipPtr->ShipFacing - ((EnemyStarShipPtr->ShipFacing + 8) % 16);
+		if (in_gas_cloud
+			&& lpEvalDesc->which_turn <= 20
+			&& (EnemyStarShipPtr->ship_input_state & WEAPON)
+			&& (facing_difference < 2 && facing_difference > -2))
+			StarShipPtr->ship_input_state |= SPECIAL;
+		
+		// JMS: When Foon-foon is near it might damage Yehat in no time with the dervish sabre.
+		// As a precaution, raise shields soon enough.
+		if (EnemyStarShipPtr->SpeciesID == FOONFOON_ID
+			&& lpEvalDesc->which_turn < 10
+			&& (TFB_Random () & 3))
+			StarShipPtr->ship_input_state |= SPECIAL;
+		
+		//log_add (log_Debug, "my_facing %d, his facing-8by16 %d, difference %d", StarShipPtr->ShipFacing, (EnemyStarShipPtr->ShipFacing + 8) % 16, facing_difference);
+		
+		if (!(EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags & IMMEDIATE_WEAPON))
 			lpEvalDesc->MoveState = PURSUE;
 	}
+
 	ship_intelligence (ShipPtr, ObjectsOfConcern, ConcernCounter);
 /*
 	if (StarShipPtr->RaceDescPtr->ship_info.energy_level <= SPECIAL_ENERGY_COST)
@@ -314,10 +505,7 @@ yehat_preprocess (ELEMENT *ElementPtr)
 						== StarShipPtr->RaceDescPtr->ship_data.special))
 		{
 #ifdef NEVER
-			SetPrimType (
-					&(GLOBAL (DisplayArray))[ElementPtr->PrimIndex],
-					STAMP_PRIM
-					);
+			SetPrimType (&(GLOBAL (DisplayArray))[ElementPtr->PrimIndex], STAMP_PRIM);
 #endif /* NEVER */
 
 			ElementPtr->next.image.farray = StarShipPtr->RaceDescPtr->ship_data.ship;
@@ -355,12 +543,30 @@ init_yehat (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	yehat_desc.preprocess_func = yehat_preprocess;
-	yehat_desc.postprocess_func = yehat_postprocess;
-	yehat_desc.init_weapon_func = initialize_standard_missiles;
-	yehat_desc.cyborg_control.intelligence_func = yehat_intelligence;
-
-	RaceDescPtr = &yehat_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		yehat_desc.preprocess_func = yehat_preprocess;
+		yehat_desc.postprocess_func = yehat_postprocess;
+		yehat_desc.init_weapon_func = initialize_standard_missiles;
+		yehat_desc.cyborg_control.intelligence_func = yehat_intelligence;
+		RaceDescPtr = &yehat_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		yehat_desc_2xres.preprocess_func = yehat_preprocess;
+		yehat_desc_2xres.postprocess_func = yehat_postprocess;
+		yehat_desc_2xres.init_weapon_func = initialize_standard_missiles;
+		yehat_desc_2xres.cyborg_control.intelligence_func = yehat_intelligence;
+		RaceDescPtr = &yehat_desc_2xres;
+	}
+	else
+	{
+		yehat_desc_4xres.preprocess_func = yehat_preprocess;
+		yehat_desc_4xres.postprocess_func = yehat_postprocess;
+		yehat_desc_4xres.init_weapon_func = initialize_standard_missiles;
+		yehat_desc_4xres.cyborg_control.intelligence_func = yehat_intelligence;
+		RaceDescPtr = &yehat_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp src.orig/uqm/ships/zoqfot/icode.h src/uqm/ships/zoqfot/icode.h
--- src.orig/uqm/ships/zoqfot/icode.h	2017-11-01 15:30:28 -0700
+++ src/uqm/ships/zoqfot/icode.h	2017-11-01 15:31:05 -0700
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define ZOQFOTPIK_CODE "ship.zoqfotpik.code"
diff -ruNp src.orig/uqm/ships/zoqfot/zoqfot.c src/uqm/ships/zoqfot/zoqfot.c
--- src.orig/uqm/ships/zoqfot/zoqfot.c	2017-11-01 15:30:28 -0700
+++ src/uqm/ships/zoqfot/zoqfot.c	2017-11-01 15:31:05 -0700
@@ -51,12 +51,12 @@ static RACE_DESC zoqfotpik_desc =
 		ZOQFOTPIK_RACE_STRINGS,
 		ZOQFOTPIK_ICON_MASK_PMAP_ANIM,
 		ZOQFOTPIK_MICON_MASK_PMAP_ANIM,
-		NULL, NULL, NULL
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
 	},
 	{ /* FLEET_STUFF */
-		320 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		0, /* Initial SoI radius */
 		{ /* Known location (center of SoI) */
-			3761, 5333,
+			0,0,
 		},
 	},
 	{
@@ -112,7 +112,163 @@ static RACE_DESC zoqfotpik_desc =
 	0, /* CodeRef */
 };
 
-#define ZOQFOTPIK_OFFSET 13
+// JMS_GFX
+#define MAX_THRUST_2XRES 80
+#define THRUST_INCREMENT_2XRES 20
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (20)
+#define MISSILE_RANGE_2XRES (MISSILE_SPEED_2XRES * MISSILE_LIFE)
+
+// JMS_GFX
+static RACE_DESC zoqfotpik_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		6, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ZOQFOTPIK_RACE_STRINGS,
+		ZOQFOTPIK_ICON_MASK_PMAP_ANIM,
+		ZOQFOTPIK_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			0,0,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ZOQFOTPIK_BIG_MASK_PMAP_ANIM,
+			ZOQFOTPIK_MED_MASK_PMAP_ANIM,
+			ZOQFOTPIK_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SPIT_BIG_MASK_PMAP_ANIM,
+			SPIT_MED_MASK_PMAP_ANIM,
+			SPIT_SML_MASK_PMAP_ANIM,
+		},
+		{
+			STINGER_BIG_MASK_PMAP_ANIM,
+			STINGER_MED_MASK_PMAP_ANIM,
+			STINGER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ZOQFOTPIK_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ZOQFOTPIK_VICTORY_SONG,
+		ZOQFOTPIK_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_RANGE_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 160
+#define THRUST_INCREMENT_4XRES 40
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (40)
+#define MISSILE_RANGE_4XRES (MISSILE_SPEED_4XRES * MISSILE_LIFE)
+
+// JMS_GFX
+static RACE_DESC zoqfotpik_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		6, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ZOQFOTPIK_RACE_STRINGS,
+		ZOQFOTPIK_ICON_MASK_PMAP_ANIM,
+		ZOQFOTPIK_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			0,0,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ZOQFOTPIK_BIG_MASK_PMAP_ANIM,
+			ZOQFOTPIK_MED_MASK_PMAP_ANIM,
+			ZOQFOTPIK_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SPIT_BIG_MASK_PMAP_ANIM,
+			SPIT_MED_MASK_PMAP_ANIM,
+			SPIT_SML_MASK_PMAP_ANIM,
+		},
+		{
+			STINGER_BIG_MASK_PMAP_ANIM,
+			STINGER_MED_MASK_PMAP_ANIM,
+			STINGER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ZOQFOTPIK_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ZOQFOTPIK_VICTORY_SONG,
+		ZOQFOTPIK_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_RANGE_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+#define ZOQFOTPIK_OFFSET (13 << RESOLUTION_FACTOR) // JMS_GFX
 #define SPIT_WAIT 2
 
 static void
@@ -124,17 +280,15 @@ spit_preprocess (ELEMENT *ElementPtr)
 	{
 		COUNT index, angle, speed;
 
-		ElementPtr->next.image.frame =
-				IncFrameIndex (ElementPtr->next.image.frame);
+		ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->next.image.frame);
 		angle = GetVelocityTravelAngle (&ElementPtr->velocity);
+		
 		if ((index = GetFrameIndex (ElementPtr->next.image.frame)) == 1)
 			angle = angle + (((COUNT)TFB_Random () % 3) - 1);
 
-		speed = WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (
-				GetFrameCount (ElementPtr->next.image.frame) - index) << 1);
-		SetVelocityComponents (&ElementPtr->velocity,
-				(SIZE)COSINE (angle, speed),
-				(SIZE)SINE (angle, speed));
+		speed = WORLD_TO_VELOCITY (DISPLAY_TO_WORLD ((GetFrameCount (ElementPtr->next.image.frame) - index) << RESOLUTION_FACTOR) << 1); // JMS_GFX
+		
+		SetVelocityComponents (&ElementPtr->velocity, (SIZE)COSINE (angle, speed), (SIZE)SINE (angle, speed));
 
 		ElementPtr->turn_wait = SPIT_WAIT;
 		ElementPtr->state_flags |= CHANGING;
@@ -159,8 +313,7 @@ initialize_spit (ELEMENT *ShipPtr, HELEM
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = ZOQFOTPIK_OFFSET;
-	MissileBlock.speed = DISPLAY_TO_WORLD (
-			GetFrameCount (StarShipPtr->RaceDescPtr->ship_data.weapon[0])) << 1;
+	MissileBlock.speed = DISPLAY_TO_WORLD ((GetFrameCount (StarShipPtr->RaceDescPtr->ship_data.weapon[0])) << RESOLUTION_FACTOR) << 1; // JMS_GFX
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -187,8 +340,7 @@ tongue_collision (ELEMENT *ElementPtr0,
 	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr0, &StarShipPtr);
-	if (StarShipPtr->special_counter ==
-			StarShipPtr->RaceDescPtr->characteristics.special_wait)
+	if (StarShipPtr->special_counter == StarShipPtr->RaceDescPtr->characteristics.special_wait)
 		weapon_collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
 
 	StarShipPtr->special_counter -= ElementPtr0->turn_wait;
@@ -202,7 +354,7 @@ spawn_tongue (ELEMENT *ElementPtr)
 #define TONGUE_SPEED 0
 #define TONGUE_HITS 1
 #define TONGUE_DAMAGE 12
-#define TONGUE_OFFSET 4
+#define TONGUE_OFFSET (4 << RESOLUTION_FACTOR) // JMS_GFX
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK TongueBlock;
 	HELEMENT Tongue;
@@ -322,7 +474,7 @@ zoqfotpik_intelligence (ELEMENT *ShipPtr
 #endif /* NEVER */
 						))
 						&& ship_weapons (ShipPtr,
-						ObjectsOfConcern->ObjectPtr, DISPLAY_TO_WORLD (20)))
+						ObjectsOfConcern->ObjectPtr, DISPLAY_TO_WORLD (20 << RESOLUTION_FACTOR))) // JMS_GFX
 				{
 					StarShipPtr->ship_input_state |= WEAPON;
 					break;
@@ -346,8 +498,7 @@ zoqfotpik_postprocess (ELEMENT *ElementP
 					/* STICK_OUT_TONGUE */
 				StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 1), ElementPtr);
 
-		StarShipPtr->special_counter =
-				StarShipPtr->RaceDescPtr->characteristics.special_wait;
+		StarShipPtr->special_counter = StarShipPtr->RaceDescPtr->characteristics.special_wait;
 	}
 
 	if (StarShipPtr->special_counter)
@@ -359,11 +510,27 @@ init_zoqfotpik (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	zoqfotpik_desc.postprocess_func = zoqfotpik_postprocess;
-	zoqfotpik_desc.init_weapon_func = initialize_spit;
-	zoqfotpik_desc.cyborg_control.intelligence_func = zoqfotpik_intelligence;
-
-	RaceDescPtr = &zoqfotpik_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		zoqfotpik_desc.postprocess_func = zoqfotpik_postprocess;
+		zoqfotpik_desc.init_weapon_func = initialize_spit;
+		zoqfotpik_desc.cyborg_control.intelligence_func = zoqfotpik_intelligence;
+		RaceDescPtr = &zoqfotpik_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		zoqfotpik_desc_2xres.postprocess_func = zoqfotpik_postprocess;
+		zoqfotpik_desc_2xres.init_weapon_func = initialize_spit;
+		zoqfotpik_desc_2xres.cyborg_control.intelligence_func = zoqfotpik_intelligence;
+		RaceDescPtr = &zoqfotpik_desc_2xres;
+	}
+	else
+	{
+		zoqfotpik_desc_4xres.postprocess_func = zoqfotpik_postprocess;
+		zoqfotpik_desc_4xres.init_weapon_func = initialize_spit;
+		zoqfotpik_desc_4xres.cyborg_control.intelligence_func = zoqfotpik_intelligence;
+		RaceDescPtr = &zoqfotpik_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp src.orig/uqm/shipstat.c src/uqm/shipstat.c
--- src.orig/uqm/shipstat.c	2017-11-01 15:30:28 -0700
+++ src/uqm/shipstat.c	2017-11-01 15:31:05 -0700
@@ -16,6 +16,11 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: -If ship's energy gauge is damaged, don't update its graphics
+//			 -If ship's crew gauge is damaged, don't update its graphics
+
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
 #include "colors.h"
 #include "globdata.h"
 #include "options.h"
@@ -23,16 +28,18 @@
 #include "setup.h"
 #include "libs/gfxlib.h"
 
+#include "intel.h"
+
 
 void
 DrawCrewFuelString (COORD y, SIZE state)
 {
 	STAMP Stamp;
 
-	Stamp.origin.y = y + GAUGE_YOFFS + STARCON_TEXT_HEIGHT;
+	Stamp.origin.y = y + GAUGE_YOFFS + STARCON_TEXT_HEIGHT - RES_CASE(0,6,12);//(RESOLUTION_FACTOR == 2 ? 12 : 0);
 	if (state == 0)
 	{
-		Stamp.origin.x = CREW_XOFFS + (STAT_WIDTH >> 1) + 6;
+		Stamp.origin.x = CREW_XOFFS + (STAT_WIDTH >> 1) + RES_STAT_SCALE(6) - RES_CASE(0,8,8);//(RESOLUTION_FACTOR == 2 ? 8 : 0); // JMS_GFX
 		if (optWhichMenu == OPT_PC)
 			Stamp.frame = SetAbsFrameIndex (StatusFrame, 4);
 		else
@@ -40,11 +47,13 @@ DrawCrewFuelString (COORD y, SIZE state)
 		DrawStamp (&Stamp);
 	}
 
-	Stamp.origin.x = ENERGY_XOFFS + (STAT_WIDTH >> 1) - 5;
+	Stamp.origin.x = ENERGY_XOFFS + (STAT_WIDTH >> 1) - RES_STAT_SCALE(5) + RES_CASE(0,10,10);// + (RESOLUTION_FACTOR == 2 ? 10 : 0);  // JMS_GFX
+	
 	if (optWhichMenu == OPT_PC)
 		Stamp.frame = SetAbsFrameIndex (StatusFrame, 5);
 	else
 		Stamp.frame = SetAbsFrameIndex (StatusFrame, 1);
+	
 	if (state >= 0)
 		DrawStamp (&Stamp);
 	else
@@ -67,11 +76,10 @@ DrawShipNameString (UNICODE *pStr, COUNT
 	Text.CharCount = CharCount;
 	Text.align = ALIGN_CENTER;
 
-	Text.baseline.y = STARCON_TEXT_HEIGHT + 3 + y;
+	Text.baseline.y = STARCON_TEXT_HEIGHT + y + (3 << RESOLUTION_FACTOR) - 6 * RESOLUTION_FACTOR; // JMS_GFX
 	Text.baseline.x = STATUS_WIDTH >> 1;
 
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
+	SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
 	font_DrawText (&Text);
 	--Text.baseline.y;
 	SetContextForeGroundColor (BLACK_COLOR);
@@ -81,62 +89,70 @@ DrawShipNameString (UNICODE *pStr, COUNT
 }
 
 void
-ClearShipStatus (COORD y)
+ClearShipStatus (COORD y, COORD w, BOOLEAN inMeleeMenu)
 {
 	RECT r;
 
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
+	SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
 	r.corner.x = 2;
 	r.corner.y = 3 + y;
-	r.extent.width = STATUS_WIDTH - 4;
-	r.extent.height = SHIP_INFO_HEIGHT - 3;
+	r.extent.width = w - 4;
+	r.extent.height = SHIP_INFO_HEIGHT - (inMeleeMenu ? RES_CASE(3,5,6) : 3); // JMS_GFX
 	DrawFilledRectangle (&r);
 }
 
 void
-OutlineShipStatus (COORD y)
+OutlineShipStatus (COORD y, COORD w, BOOLEAN inMeleeMenu)
 {
 	RECT r;
 
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
+	SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
 	r.corner.x = 0;
 	r.corner.y = 1 + y;
-	r.extent.width = STATUS_WIDTH;
+	r.extent.width = w;
 	r.extent.height = 1;
 	DrawFilledRectangle (&r);
 	++r.corner.y;
 	--r.extent.width;
 	DrawFilledRectangle (&r);
 	r.extent.width = 1;
-	r.extent.height = SHIP_INFO_HEIGHT - 2;
+	r.extent.height = SHIP_INFO_HEIGHT - RES_CASE(1,2,inMeleeMenu?5:0);
 	DrawFilledRectangle (&r);
 	++r.corner.x;
 	DrawFilledRectangle (&r);
 
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
-	r.corner.x = STATUS_WIDTH - 1;
+	SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
+	r.corner.x = w - 1;
 	DrawFilledRectangle (&r);
-	r.corner.x = STATUS_WIDTH - 2;
+	r.corner.x = w - 2;
 	++r.corner.y;
 	--r.extent.height;
 	DrawFilledRectangle (&r);
-
+	r.corner.x = 1;
+	r.corner.y = SHIP_INFO_HEIGHT - RES_CASE(-2,1,2);
+	r.extent.width = w - 2;
+	r.extent.height = 1;
+	if (inMeleeMenu)
+		DrawFilledRectangle (&r);
+	++r.corner.x;
+	--r.corner.y;
+	if (inMeleeMenu)
+		DrawFilledRectangle (&r);
+	
 	SetContextForeGroundColor (BLACK_COLOR);
 	r.corner.x = 0;
 	r.corner.y = y;
-	r.extent.width = STATUS_WIDTH;
+	r.extent.width = w;
 	r.extent.height = 1;
 	DrawFilledRectangle (&r);
 }
 
 void
-InitShipStatus (SHIP_INFO *SIPtr, STARSHIP *StarShipPtr, RECT *pClipRect)
+InitShipStatus (SHIP_INFO *SIPtr, STARSHIP *StarShipPtr, RECT *pClipRect, BOOLEAN inMeleeMenu)
 {
 	RECT r;
 	COORD y = 0; // default, for Melee menu
+	COORD width = STATUS_WIDTH; // BW: ShipStatus has less space in 2x and 4x MeleeMenu
 	STAMP Stamp;
 	CONTEXT OldContext;
 	RECT oldClipRect;
@@ -147,6 +163,8 @@ InitShipStatus (SHIP_INFO *SIPtr, STARSH
 		assert (StarShipPtr->playerNr >= 0);
 		y = status_y_offsets[StarShipPtr->playerNr];
 	}
+	else
+		width -= 3 * RESOLUTION_FACTOR;
 
 	OldContext = SetContext (StatusContext);
 	if (pClipRect)
@@ -165,24 +183,33 @@ InitShipStatus (SHIP_INFO *SIPtr, STARSH
 
 	BatchGraphics ();
 	
-	OutlineShipStatus (y);
-	ClearShipStatus (y);
+	OutlineShipStatus (y, width, inMeleeMenu);
+	ClearShipStatus (y, width, inMeleeMenu);
 
 	Stamp.origin.x = (STATUS_WIDTH >> 1);
-	Stamp.origin.y = 31 + y;
+	Stamp.origin.y = (31 << RESOLUTION_FACTOR) + y;
 	Stamp.frame = IncFrameIndex (SIPtr->icons);
 	DrawStamp (&Stamp);
 
 	{
 		SIZE crew_height, energy_height;
-
+		
 #define MIN(a, b) (((a) <= (b)) ? (a) : (b))
-		crew_height = ((MIN(SIPtr->max_crew, MAX_CREW_SIZE) + 1) & ~1) + 1;
+		// At basic resolution.
+		if (RESOLUTION_FACTOR < 1)
+		{
+			crew_height = ((MIN(SIPtr->max_crew, MAX_CREW_SIZE) + 1) & ~1) + 1;
+			energy_height = (((SIPtr->max_energy + 1) >> 1) << 1) + 1;
+		}
+		// At hires 2x and 4x.
+		else
+		{
+			crew_height = ((MIN(SIPtr->max_crew, MAX_CREW_SIZE) + 1) * 1.5);
+			energy_height = (((SIPtr->max_energy + 1) >> 1) * 3) + 1;
+		}
 #undef MIN
-		energy_height = (((SIPtr->max_energy + 1) >> 1) << 1) + 1;
-
-		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
+		
+		SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
 		r.corner.x = CREW_XOFFS - 1;
 		r.corner.y = GAUGE_YOFFS + 1 + y;
 		r.extent.width = STAT_WIDTH + 2;
@@ -200,8 +227,7 @@ InitShipStatus (SHIP_INFO *SIPtr, STARSH
 		r.extent.width = 1;
 		r.extent.height = crew_height;
 		DrawFilledRectangle (&r);
-		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
+		SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
 		r.corner.x = CREW_XOFFS - 1;
 		r.corner.y = GAUGE_YOFFS - crew_height + y;
 		r.extent.width = STAT_WIDTH + 2;
@@ -348,7 +374,12 @@ DeltaStatistics (SHIP_INFO *ShipInfoPtr,
 					r.corner.x += UNIT_WIDTH + 1;
 					r.corner.y -= UNIT_HEIGHT + 1;
 				}
-				DrawFilledRectangle (&r);
+				// JMS: Don't update human player's crew gauge graphics if gauge is damaged.
+				// Always update computer player's gauges (otherwise computer's damage would only hinder the human player!!)
+				if (PlayerControl[1] & COMPUTER_CONTROL && ShipInfoPtr->ship_flags & BAD_GUY)
+					DrawFilledRectangle (&r);
+				else if (!(ShipInfoPtr->damage_flags & DAMAGE_GAUGE_CREW))
+					DrawFilledRectangle (&r);
 			}
 		}
 		else  /* crew_delta < 0 */
@@ -364,7 +395,28 @@ DeltaStatistics (SHIP_INFO *ShipInfoPtr,
 					r.corner.x -= UNIT_WIDTH + 1;
 					r.corner.y += UNIT_HEIGHT + 1;
 				}
-				DrawFilledRectangle (&r);
+				// JMS: Don't update human player's crew gauge graphics if gauge is damaged.
+				// Always update computer player's gauges (otherwise computer's damage would only hinder the human player!!)
+				if (PlayerControl[1] & COMPUTER_CONTROL && ShipInfoPtr->ship_flags & BAD_GUY)
+					DrawFilledRectangle (&r);
+				else
+					// JMS: I'VE DELETED THIS! This used to draw bullet holes to signify critical damage.
+					if (ShipInfoPtr->damage_flags & DAMAGE_GAUGE_CREW)
+					{
+						/*STAMP Stamp;
+						COORD temp_y;
+						
+						temp_y = GAUGE_YOFFS + ((ShipInfoPtr->ship_flags & GOOD_GUY) ?
+										   GOOD_GUY_YOFFS : BAD_GUY_YOFFS);
+			
+						Stamp.origin.y = temp_y - 6;
+						Stamp.origin.x = ENERGY_XOFFS + (STAT_WIDTH >> 1);
+						Stamp.frame = SetAbsFrameIndex (BulletFrame, 1);
+						
+						DrawStamp (&Stamp);*/
+					}
+					else
+						DrawFilledRectangle (&r);
 			}
 		}
 	
@@ -410,7 +462,13 @@ DeltaStatistics (SHIP_INFO *ShipInfoPtr,
 					r.corner.x += UNIT_WIDTH + 1;
 					r.corner.y -= UNIT_HEIGHT + 1;
 				}
-				DrawFilledRectangle (&r);
+				// JMS: Don't update human player's crew gauge graphics if gauge is damaged.
+				// Always update computer player's gauges (otherwise computer's damage would only hinder the human player!!)
+				if (PlayerControl[1] & COMPUTER_CONTROL && ShipInfoPtr->ship_flags & BAD_GUY)
+					DrawFilledRectangle (&r);
+				else if (!(ShipInfoPtr->damage_flags & DAMAGE_GAUGE_ENERGY))
+					DrawFilledRectangle (&r);
+				
 				++ShipInfoPtr->energy_level;
 			} while (--energy_delta);
 		}
@@ -427,7 +485,14 @@ DeltaStatistics (SHIP_INFO *ShipInfoPtr,
 					r.corner.x -= UNIT_WIDTH + 1;
 					r.corner.y += UNIT_HEIGHT + 1;
 				}
-				DrawFilledRectangle (&r);
+				
+				// JMS: Don't update human player's crew gauge graphics if gauge is damaged.
+				// Always update computer player's gauges (otherwise computer's damage would only hinder the human player!!)
+				if (PlayerControl[1] & COMPUTER_CONTROL && ShipInfoPtr->ship_flags & BAD_GUY)
+					DrawFilledRectangle (&r);
+				else if (!(ShipInfoPtr->damage_flags & DAMAGE_GAUGE_ENERGY))
+					DrawFilledRectangle (&r);
+				
 				--ShipInfoPtr->energy_level;
 			} while (++energy_delta);
 		}
diff -ruNp src.orig/uqm/shipyard.c src/uqm/shipyard.c
--- src.orig/uqm/shipyard.c	2017-11-01 15:30:28 -0700
+++ src/uqm/shipyard.c	2017-11-01 15:31:05 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
 #include "build.h"
 #include "colors.h"
 #include "controls.h"
@@ -38,6 +40,7 @@
 #include "libs/graphics/gfx_common.h"
 #include "libs/inplib.h"
 
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
 
 #ifdef USE_3DO_HANGAR
 // 3DO 4x3 hangar layout
@@ -45,7 +48,7 @@
 #	define HANGAR_Y          64
 #	define HANGAR_DY         44
 
-static const COORD hangar_x_coords[HANGAR_SHIPS_ROW] =
+static const COORD hangar_x_coords_1x[HANGAR_SHIPS_ROW] =
 {
 	19, 60, 116, 157
 };
@@ -53,16 +56,26 @@ static const COORD hangar_x_coords[HANGA
 #else // use PC hangar
 // modified PC 6x2 hangar layout
 #	define HANGAR_SHIPS_ROW  6
-#	define HANGAR_Y          88
-#	define HANGAR_DY         84
+#	define HANGAR_Y          RES_CASE(116, 268, 536) // JMS_GFX
+#	define HANGAR_DY         (84 << RESOLUTION_FACTOR) // JMS_GFX
+
+static const COORD hangar_x_coords_1x[HANGAR_SHIPS_ROW] =
+{
+	0, 38, 76, 131, 169, 207
+};
+
+static const COORD hangar_x_coords_2x[HANGAR_SHIPS_ROW] =
+{
+	0, 78, 155, 269, 346, 424
+};
 
-static const COORD hangar_x_coords[HANGAR_SHIPS_ROW] =
+static const COORD hangar_x_coords_4x[HANGAR_SHIPS_ROW] =
 {
-	0, 38, 76,  131, 169, 207
+	48, 204, 358, 586, 741, 897
 };
 #endif // USE_3DO_HANGAR
 
-#define HANGAR_SHIPS      12
+#define HANGAR_SHIPS      6
 #define HANGAR_ROWS       (HANGAR_SHIPS / HANGAR_SHIPS_ROW)
 #define HANGAR_ANIM_RATE  15 // fps
 
@@ -194,9 +207,9 @@ DrawRaceStrings (MENU_STATE *pMS, BYTE N
 	s.origin.x = RADAR_X - r.corner.x;
 	s.origin.y = RADAR_Y - r.corner.y;
 	r.corner.x = s.origin.x - 1;
-	r.corner.y = s.origin.y - 11;
+	r.corner.y = s.origin.y - (11 << RESOLUTION_FACTOR);
 	r.extent.width = RADAR_WIDTH + 2;
-	r.extent.height = 11;
+	r.extent.height = 11 << RESOLUTION_FACTOR;
 	BatchGraphics ();
 	ClearSISRect (CLEAR_SIS_RADAR);
 	SetContextForeGroundColor (
@@ -250,8 +263,8 @@ DrawRaceStrings (MENU_STATE *pMS, BYTE N
 	UnlockMutex (GraphicsLock);
 }
 
-#define SHIP_WIN_WIDTH 34
-#define SHIP_WIN_HEIGHT (SHIP_WIN_WIDTH + 6)
+#define SHIP_WIN_WIDTH RES_CASE(34, 73, 146) // JMS_GFX
+#define SHIP_WIN_HEIGHT (SHIP_WIN_WIDTH + (6 << RESOLUTION_FACTOR)) // JMS_GFX
 #define SHIP_WIN_FRAMES ((SHIP_WIN_WIDTH >> 1) + 1)
 
 static void
@@ -279,15 +292,15 @@ ShowShipCrew (SHIP_FRAGMENT *StarShipPtr
 
 	r = *pRect;
 	t.baseline.x = r.corner.x + (r.extent.width >> 1);
-	t.baseline.y = r.corner.y + r.extent.height - 1;
+	t.baseline.y = r.corner.y + r.extent.height - 1 - (RESOLUTION_FACTOR == 1 ? 1 : 0);
 	t.align = ALIGN_CENTER;
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 	if (r.corner.y)
 	{
-		r.corner.y = t.baseline.y - 6;
+		r.corner.y = t.baseline.y - (6 << RESOLUTION_FACTOR); //JMS_GFX
 		r.extent.width = SHIP_WIN_WIDTH;
-		r.extent.height = 6;
+		r.extent.height = (6 << RESOLUTION_FACTOR) + (RESOLUTION_FACTOR == 1 ? 1 : 0); // JMS_GFX
 		SetContextForeGroundColor (BLACK_COLOR);
 		DrawFilledRectangle (&r);
 	}
@@ -304,6 +317,7 @@ ShowCombatShip (MENU_STATE *pMS, COUNT w
 	COUNT i, num_ships;
 	HSHIPFRAG hStarShip, hNextShip;
 	SHIP_FRAGMENT *StarShipPtr;
+	static const COORD *hangar_x_coords;
 	struct
 	{
 		SHIP_FRAGMENT *StarShipPtr;
@@ -311,6 +325,20 @@ ShowCombatShip (MENU_STATE *pMS, COUNT w
 		STAMP ship_s, lfdoor_s, rtdoor_s;
 	} ship_win_info[MAX_BUILT_SHIPS], *pship_win_info;
 
+	switch (RESOLUTION_FACTOR) // JMS_GFX
+	{
+		case 2:
+			hangar_x_coords = hangar_x_coords_4x;
+			break;
+		case 1:
+			hangar_x_coords = hangar_x_coords_2x;
+			break;
+		case 0:
+		default:
+			hangar_x_coords = hangar_x_coords_1x;
+			break;
+	}
+	
 	num_ships = 1;
 	pship_win_info = &ship_win_info[0];
 	if (YankedStarShipPtr)
@@ -545,6 +573,7 @@ DoModifyShips (MENU_STATE *pMS)
 {
 #define MODIFY_CREW_FLAG (1 << 8)
 	BOOLEAN select, cancel;
+	static const COORD *hangar_x_coords;
 #ifdef WANT_SHIP_SPINS
 	BOOLEAN special;
 
@@ -553,6 +582,20 @@ DoModifyShips (MENU_STATE *pMS)
 	select = PulsedInputState.menu[KEY_MENU_SELECT];
 	cancel = PulsedInputState.menu[KEY_MENU_CANCEL];
 
+	switch (RESOLUTION_FACTOR) // JMS_GFX
+	{
+		case 2:
+			hangar_x_coords = hangar_x_coords_4x;
+			break;
+		case 1:
+			hangar_x_coords = hangar_x_coords_2x;
+			break;
+		case 0:
+		default:
+			hangar_x_coords = hangar_x_coords_1x;
+			break;
+	}
+
 	if (GLOBAL (CurrentActivity) & CHECK_ABORT)
 	{
 		pMS->InputFunc = DoShipyard;
@@ -749,13 +792,11 @@ DoModifyShips (MENU_STATE *pMS)
 							DrawMenuStateStrings (PM_CREW, SHIPYARD_CREW);
 
 							LockMutex (GraphicsLock);
-							DeltaSISGauges (UNDEFINED_DELTA, UNDEFINED_DELTA,
-									-((int)ShipCost[Index]));
+							DeltaSISGauges (UNDEFINED_DELTA, UNDEFINED_DELTA, -((int)ShipCost[Index]));
 							r.corner.x = pMS->flash_rect0.corner.x;
-							r.corner.y = pMS->flash_rect0.corner.y
-									+ pMS->flash_rect0.extent.height - 6;
+							r.corner.y = pMS->flash_rect0.corner.y + pMS->flash_rect0.extent.height - (6 << RESOLUTION_FACTOR);
 							r.extent.width = SHIP_WIN_WIDTH;
-							r.extent.height = 5;
+							r.extent.height = 5 << RESOLUTION_FACTOR; // JMS_GFX
 							SetContext (SpaceContext);
 							SetFlashRect (&r);
 							UnlockMutex (GraphicsLock);
@@ -797,24 +838,20 @@ DoModifyShips (MENU_STATE *pMS)
 				}
 				else if (select || cancel)
 				{
-					if ((pMS->delta_item & MODIFY_CREW_FLAG)
-							&& hStarShip != 0)
+					if ((pMS->delta_item & MODIFY_CREW_FLAG) && hStarShip != 0)
 					{
-						StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q),
-								hStarShip);
+						StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 						if (StarShipPtr->crew_level == 0)
 						{
 							SetFlashRect (NULL);
 							UnlockMutex (GraphicsLock);
 							ShowCombatShip (pMS, pMS->CurState, StarShipPtr);
 							LockMutex (GraphicsLock);
-							UnlockShipFrag (&GLOBAL (built_ship_q),
-									hStarShip);
+							UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 							RemoveQueue (&GLOBAL (built_ship_q), hStarShip);
 							FreeShipFrag (&GLOBAL (built_ship_q), hStarShip);
 							// refresh SIS display
-							DeltaSISGauges (UNDEFINED_DELTA, UNDEFINED_DELTA,
-									UNDEFINED_DELTA);
+							DeltaSISGauges (UNDEFINED_DELTA, UNDEFINED_DELTA, UNDEFINED_DELTA);
 							r.corner.x = pMS->flash_rect0.corner.x;
 							r.corner.y = pMS->flash_rect0.corner.y;
 							r.extent.width = SHIP_WIN_WIDTH;
@@ -845,10 +882,9 @@ DoModifyShips (MENU_STATE *pMS)
 					else
 					{
 						r.corner.x = pMS->flash_rect0.corner.x;
-						r.corner.y = pMS->flash_rect0.corner.y
-								+ pMS->flash_rect0.extent.height - 6;
+						r.corner.y = pMS->flash_rect0.corner.y + pMS->flash_rect0.extent.height - (6 << RESOLUTION_FACTOR);
 						r.extent.width = SHIP_WIN_WIDTH;
-						r.extent.height = 5;
+						r.extent.height = (5 << RESOLUTION_FACTOR); // JMS_GFX
 						SetContext (SpaceContext);
 						SetFlashRect (&r);
 						SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN,
@@ -865,8 +901,8 @@ DoModifyShips (MENU_STATE *pMS)
 					else
 						StarShipPtr = NULL;  // Keeping compiler quiet.
 
-					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN,
-							MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
+					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
+					
 					crew_delta = 0;
 					if (dy < 0)
 					{
@@ -876,7 +912,30 @@ DoModifyShips (MENU_STATE *pMS)
 									&& GLOBAL_SIS (ResUnits) >=
 									(DWORD)GLOBAL (CrewCost))
 							{
-								DrawPoint (&r.corner);
+								// Crew dots/rectangles for 1x and 2x resolutions.
+								if (RESOLUTION_FACTOR < 2)
+								{
+									r.extent.width = 1 << RESOLUTION_FACTOR;
+									r.extent.height = r.extent.width;
+									DrawFilledRectangle (&r);
+								}
+								// Crew balls for 4x resolution.
+								else
+								{
+									r.corner.x += 1;
+									r.extent.width = (1 << RESOLUTION_FACTOR) - 2;
+									r.extent.height = 1 << RESOLUTION_FACTOR;
+									DrawFilledRectangle (&r);
+									
+									r.corner.x -= 1;
+									r.corner.y += 1;
+									r.extent.width = 1 << RESOLUTION_FACTOR;
+									r.extent.height = (1 << RESOLUTION_FACTOR) - 2;
+									DrawFilledRectangle (&r);
+									
+									r.corner.y -= 1;
+								}
+								
 								DeltaSISGauges (1, 0, -GLOBAL (CrewCost));
 								crew_delta = 1;
 
@@ -917,9 +976,9 @@ DoModifyShips (MENU_STATE *pMS)
 								ShowShipCrew (StarShipPtr, &pMS->flash_rect0);
 								r.corner.x = pMS->flash_rect0.corner.x;
 								r.corner.y = pMS->flash_rect0.corner.y
-										+ pMS->flash_rect0.extent.height - 6;
+									+ pMS->flash_rect0.extent.height - (6 << RESOLUTION_FACTOR);
 								r.extent.width = SHIP_WIN_WIDTH;
-								r.extent.height = 5;
+								r.extent.height = 5 << RESOLUTION_FACTOR; // JMS_GFX
 								SetContext (SpaceContext);
 								SetFlashRect (&r);
 							}
@@ -946,8 +1005,11 @@ DoModifyShips (MENU_STATE *pMS)
 								crew_delta = -1;
 
 								GetCPodCapacity (&r.corner);
+								r.extent.width = 1 << RESOLUTION_FACTOR;
+								r.extent.height = r.extent.width;
 								SetContextForeGroundColor (BLACK_COLOR);
-								DrawPoint (&r.corner);
+								
+								DrawFilledRectangle (&r);
 
 								SetContext (StatusContext);
 								GetGaugeRect (&r, TRUE);
@@ -980,9 +1042,9 @@ DoModifyShips (MENU_STATE *pMS)
 							ShowShipCrew (StarShipPtr, &pMS->flash_rect0);
 							r.corner.x = pMS->flash_rect0.corner.x;
 							r.corner.y = pMS->flash_rect0.corner.y
-									+ pMS->flash_rect0.extent.height - 6;
+								+ pMS->flash_rect0.extent.height - (6 << RESOLUTION_FACTOR);
 							r.extent.width = SHIP_WIN_WIDTH;
-							r.extent.height = 5;
+							r.extent.height = 5 << RESOLUTION_FACTOR; // JMS_GFX
 							SetContext (SpaceContext);
 							SetFlashRect (&r);
 						}
@@ -1022,7 +1084,7 @@ ChangeFlashRect:
 					pMS->flash_rect0.corner.x =
 							pMS->flash_rect0.corner.y = 0;
 					pMS->flash_rect0.extent.width = SIS_SCREEN_WIDTH;
-					pMS->flash_rect0.extent.height = 61;
+					pMS->flash_rect0.extent.height = (61 << RESOLUTION_FACTOR); // JMS_GFX
 				}
 				else
 				{
@@ -1056,75 +1118,137 @@ DrawBluePrint (MENU_STATE *pMS)
 	s.origin.x = 0;
 	s.origin.y = 0;
 	s.frame = DecFrameIndex (ModuleFrame);
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x16), 0x01));
-	DrawFilledStamp (&s);
+	SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x16), 0x01));
 
-	for (num_frames = 0; num_frames < NUM_DRIVE_SLOTS; ++num_frames)
+
+	if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == CHMMR_EXPLORER_SHIP)
 	{
-		DrawShipPiece (ModuleFrame, GLOBAL_SIS (DriveSlots[num_frames]),
-				num_frames, TRUE);
+		s.frame = SetAbsFrameIndex (ModuleFrame, 22);
+		DrawFilledStamp (&s);
 	}
-	for (num_frames = 0; num_frames < NUM_JET_SLOTS; ++num_frames)
+	else
 	{
+		DrawFilledStamp (&s);
+		
+	    for (num_frames = 0; num_frames < NUM_DRIVE_SLOTS; ++num_frames)
+	      {
+		DrawShipPiece (ModuleFrame, GLOBAL_SIS (DriveSlots[num_frames]),
+				num_frames, TRUE);
+	      }
+	    for (num_frames = 0; num_frames < NUM_JET_SLOTS; ++num_frames)
+	      {
 		DrawShipPiece (ModuleFrame, GLOBAL_SIS (JetSlots[num_frames]),
 				num_frames, TRUE);
-	}
-	for (num_frames = 0; num_frames < NUM_MODULE_SLOTS; ++num_frames)
-	{
+	      }
+	    for (num_frames = 0; num_frames < NUM_MODULE_SLOTS; ++num_frames)
+	      {
 		BYTE which_piece;
 
 		which_piece = GLOBAL_SIS (ModuleSlots[num_frames]);
 
 		if (!(pMS->CurState == SHIPYARD && which_piece == CREW_POD))
 			DrawShipPiece (ModuleFrame, which_piece, num_frames, TRUE);
-	}
+	      }
 
-	SetContextForeGroundColor (
+	    SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x1F), 0x09));
-	for (num_frames = 0; num_frames < NUM_MODULE_SLOTS; ++num_frames)
-	{
+	    for (num_frames = 0; num_frames < NUM_MODULE_SLOTS; ++num_frames)
+	      {
 		BYTE which_piece;
 
 		which_piece = GLOBAL_SIS (ModuleSlots[num_frames]);
 		if (pMS->CurState == SHIPYARD && which_piece == CREW_POD)
 			DrawShipPiece (ModuleFrame, which_piece, num_frames, TRUE);
+	      }
 	}
-
+	    
+	num_frames = GLOBAL_SIS (CrewEnlisted);
+	GLOBAL_SIS (CrewEnlisted) = 0;
+	
+	while (num_frames--)
 	{
-		num_frames = GLOBAL_SIS (CrewEnlisted);
-		GLOBAL_SIS (CrewEnlisted) = 0;
-
-		while (num_frames--)
+		RECT r;
+		// Crew dots/rectangles for 1x and 2x resolutions.
+		if (RESOLUTION_FACTOR < 2)
 		{
-			POINT pt;
-
-			GetCPodCapacity (&pt);
-			DrawPoint (&pt);
-
-			++GLOBAL_SIS (CrewEnlisted);
+			r.extent.width = 1 << RESOLUTION_FACTOR;
+			r.extent.height = r.extent.width;
+			
+			GetCPodCapacity (&r.corner);
+			DrawFilledRectangle (&r);
 		}
-	}
-	{
-		RECT r;
-
-		num_frames = GLOBAL_SIS (TotalElementMass);
-		GLOBAL_SIS (TotalElementMass) = 0;
-
-		r.extent.width = 9;
-		r.extent.height = 1;
-		while (num_frames)
+		// Crew balls for 4x resolution.
+		else
 		{
-			COUNT m;
-
-			m = num_frames < SBAY_MASS_PER_ROW ?
-					num_frames : SBAY_MASS_PER_ROW;
-			GLOBAL_SIS (TotalElementMass) += m;
-			GetSBayCapacity (&r.corner);
+			GetCPodCapacity (&r.corner);
+			
+			r.corner.x += 1;
+			r.extent.width = (1 << RESOLUTION_FACTOR) - 2;
+			r.extent.height = 1 << RESOLUTION_FACTOR;
+			DrawFilledRectangle (&r);
+			
+			r.corner.x -= 1;
+			r.corner.y += 1;
+			r.extent.width = 1 << RESOLUTION_FACTOR;
+			r.extent.height = (1 << RESOLUTION_FACTOR) - 2;
 			DrawFilledRectangle (&r);
-			num_frames -= m;
+			
+			r.corner.y -= 1;
 		}
+		
+		++GLOBAL_SIS (CrewEnlisted);
 	}
+
+	if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == CHMMR_EXPLORER_SHIP)
+	  {
+	  RECT r;
+	  
+	  num_frames = GLOBAL_SIS (TotalElementMass);
+	  GLOBAL_SIS (TotalElementMass) = 0;
+	  
+	  r.extent.width = 5 << RESOLUTION_FACTOR; // JMS_GFX
+	  r.extent.height = 1 << RESOLUTION_FACTOR; // JMS_GFX
+	  while (num_frames)
+	    {
+	      COUNT m;
+	      
+	      m = num_frames < SBAY_MASS_PER_ROW ?
+		num_frames : SBAY_MASS_PER_ROW;
+	      GLOBAL_SIS (TotalElementMass) += m;
+	      GetSBayCapacity (&r.corner);
+	      if (r.corner.x == 40)
+		{
+		  r.extent.width = 3 << RESOLUTION_FACTOR; // JMS_GFX
+		}
+	      // BW: kinda hacky but the original procedure is not really logical either...
+	      DrawFilledRectangle (&r);
+	      num_frames -= m;
+	    }
+	  }
+	else
+	  {
+	  RECT r;
+	  
+	  num_frames = GLOBAL_SIS (TotalElementMass);
+	  GLOBAL_SIS (TotalElementMass) = 0;
+	  
+	  r.extent.width = 9 << RESOLUTION_FACTOR; // JMS_GFX
+	  r.extent.height = 1 << RESOLUTION_FACTOR; // JMS_GFX
+	  while (num_frames)
+	    {
+	      COUNT m;
+	      
+	      m = num_frames < SBAY_MASS_PER_ROW ?
+		num_frames : SBAY_MASS_PER_ROW;
+	      GLOBAL_SIS (TotalElementMass) += m;
+	      GetSBayCapacity (&r.corner);
+	      DrawFilledRectangle (&r);
+	      num_frames -= m;
+	    }
+	  }
+	
+
+	
 	if (GLOBAL_SIS (FuelOnBoard) > FUEL_RESERVE)
 	{
 		DWORD FuelVolume;
@@ -1133,22 +1257,23 @@ DrawBluePrint (MENU_STATE *pMS)
 		FuelVolume = GLOBAL_SIS (FuelOnBoard) - FUEL_RESERVE;
 		GLOBAL_SIS (FuelOnBoard) = FUEL_RESERVE;
 
-		r.extent.width = 3;
-		r.extent.height = 1;
+		r.extent.width = 1; // JMS_GFX
+		r.extent.height = 1 << RESOLUTION_FACTOR; // JMS_GFX
 		while (FuelVolume)
 		{
 			COUNT m;
 
 			GetFTankCapacity (&r.corner);
+			r.corner.x += (RES_CASE(40,50,48)) << RESOLUTION_FACTOR; // JMS_GFX
+			r.corner.y += (RES_CASE(22,20,19)) << RESOLUTION_FACTOR; // JMS_GFX
 			DrawPoint (&r.corner);
-			r.corner.x += r.extent.width + 1;
+			r.corner.y += r.extent.height + 1; // JMS_GFX;
 			DrawPoint (&r.corner);
-			r.corner.x -= r.extent.width;
-			SetContextForeGroundColor (
-					SetContextBackGroundColor (BLACK_COLOR));
+			r.corner.y -= r.extent.height;
+			SetContextForeGroundColor (SetContextBackGroundColor (BLACK_COLOR));
 			DrawFilledRectangle (&r);
-			m = FuelVolume < FUEL_VOLUME_PER_ROW ?
-					(COUNT)FuelVolume : FUEL_VOLUME_PER_ROW;
+			m = FuelVolume < EXPLORER_FUEL_VOLUME_PER_ROW ?
+					(COUNT)FuelVolume : EXPLORER_FUEL_VOLUME_PER_ROW;
 			GLOBAL_SIS (FuelOnBoard) += m;
 			FuelVolume -= m;
 		}
diff -ruNp src.orig/uqm/sis.c src/uqm/sis.c
--- src.orig/uqm/sis.c	2017-11-01 15:30:28 -0700
+++ src/uqm/sis.c	2017-11-01 15:31:05 -0700
@@ -16,6 +16,10 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2009: Shows *Below* in orz space in the SIS info screen
+
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
 #include "sis.h"
 
 #include "colors.h"
@@ -40,6 +44,61 @@
 
 static StatMsgMode curMsgMode = SMM_DEFAULT;
 
+/**** 1/1-Scale blueprint
+static const COUNT crew_lines_sizes[16] =
+{
+  4,4,3,3,2,1,1,1,2,2,8,7,7,1,2,2
+};
+
+static const COORD crew_lines_x_coords[16] = 
+{
+  93,92,91,90,90,89,90,89,86,85,72,73,73,68,67,67
+};
+
+static const COORD crew_lines_y_coords[16] = 
+{
+  29,27,25,23,21,19,31,29,27,25,23,21,19,23,21,19
+};
+****/
+
+/**** Enlarged BW blueprint
+static const COUNT crew_lines_sizes[16] =
+{
+  4,3,3,2,2,2,1,1,1,2,9,8,7,2,2,1
+};
+
+static const COORD crew_lines_x_coords[16] = 
+{
+  90,89,88,87,86,85,84,84,83,81,66,67,68,60,61,63
+};
+
+static const COORD crew_lines_y_coords[16] = 
+{
+  20,18,16,14,12,10,8,18,16,14,12,10,8,12,10,8
+};
+ ****/
+
+/**** Damon's blueprint ****/
+static const COUNT crew_lines_sizes[11] =
+{
+	4,4,3,2,10,9,7,3,3,3,2
+};
+
+static const COORD crew_lines_x_coords_1x[16] = 
+{
+	86,83,82,81,59,60,63,46,49,52,55
+};
+
+static const COORD crew_lines_x_coords_4x[16] = 
+{
+	98,95,94,93,69,70,73,53,56,59,62
+};
+
+static const COORD crew_lines_y_coords[16] = 
+{
+	13,11,9,7,11,9,7,13,11,9,7
+};
+
 static const UNICODE *describeWeapon (BYTE moduleType);
 
 void
@@ -131,16 +190,16 @@ DrawSISTitle (UNICODE *pStr)
 	RECT r;
 
 	t.baseline.x = SIS_TITLE_WIDTH >> 1;
-	t.baseline.y = SIS_TITLE_HEIGHT - 2;
+	t.baseline.y = SIS_TITLE_HEIGHT - RES_CASE(2,6,8); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.pStr = pStr;
 	t.CharCount = (COUNT)~0;
 
 	OldContext = SetContext (OffScreenContext);
-	r.corner.x = SIS_ORG_X + SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH + 1;
+	r.corner.x = SIS_ORG_X + SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH + (1 << RESOLUTION_FACTOR); // JMS_GFX
 	r.corner.y = SIS_ORG_Y - SIS_TITLE_HEIGHT;
 	r.extent.width = SIS_TITLE_WIDTH;
-	r.extent.height = SIS_TITLE_HEIGHT - 1;
+	r.extent.height = SIS_TITLE_HEIGHT - RES_STAT_SCALE(1); // JMS_GFX
 	SetContextFGFrame (Screen);
 	SetContextClipRect (&r);
 	SetContextFont (TinyFont);
@@ -174,6 +233,7 @@ DrawHyperCoords (POINT universe)
 	DrawSISTitle (buf);
 }
 
+// The large blue box in the upper edge of the screen
 void
 DrawSISMessage (const UNICODE *pStr)
 {
@@ -215,17 +275,19 @@ DrawSISMessageEx (const UNICODE *pStr, S
 				pStr = buf;
 				break;
 			case IN_HYPERSPACE:
-				if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
-				{
-					pStr = GAME_STRING (NAVIGATION_STRING_BASE);
-							// "HyperSpace"
-				}
-				else
-				{
-					pStr = GAME_STRING (NAVIGATION_STRING_BASE + 1);
-							// "QuasiSpace"
-				}
-				break;
+					if (GET_GAME_STATE (ORZ_SPACE_SIDE) > 1)
+					{
+						pStr = GAME_STRING (NAVIGATION_STRING_BASE + 6);
+						// JMS: "ORZ Space = * Below *"
+					}
+					else 
+					{
+						pStr = GAME_STRING (NAVIGATION_STRING_BASE
+								+ (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1
+									? 0 : 1));
+						// "Hyperspace" or "Quasispace"
+					}
+					break;
 		}
 
 	}
@@ -233,7 +295,7 @@ DrawSISMessageEx (const UNICODE *pStr, S
 	if (!(flags & DSME_MYCOLOR))
 		SetContextForeGroundColor (SIS_MESSAGE_TEXT_COLOR);
 
-	t.baseline.y = SIS_MESSAGE_HEIGHT - 2;
+	t.baseline.y = SIS_MESSAGE_HEIGHT - RES_CASE(2,6,8); // JMS_GFX
 	t.pStr = pStr;
 	t.CharCount = (COUNT)~0;
 	SetContextFont (TinyFont);
@@ -257,7 +319,7 @@ DrawSISMessageEx (const UNICODE *pStr, S
 		BYTE char_deltas[128];
 		BYTE *pchar_deltas;
 
-		t.baseline.x = 3;
+		t.baseline.x = RES_STAT_SCALE(3); // JMS_GFX
 		t.align = ALIGN_LEFT;
 
 		TextRect (&t, &text_r, char_deltas);
@@ -353,11 +415,12 @@ DateToString (char *buf, size_t bufLen,
 			day_index, year_index);
 }
 
+// The green screen which contains date etc.
 void
 GetStatusMessageRect (RECT *r)
 {
-	r->corner.x = 2;
-	r->corner.y = 130;
+	r->corner.x = RES_STAT_SCALE(2) + RESOLUTION_FACTOR; // JMS_GFX
+	r->corner.y = RES_STAT_SCALE(130) + RES_CASE(0,0,4); // JMS_GFX
 	r->extent.width = STATUS_MESSAGE_WIDTH;
 	r->extent.height = STATUS_MESSAGE_HEIGHT;
 }
@@ -422,7 +485,7 @@ DrawStatusMessage (const UNICODE *pStr)
 	}
 
 	t.baseline.x = STATUS_MESSAGE_WIDTH >> 1;
-	t.baseline.y = STATUS_MESSAGE_HEIGHT - 1;
+	t.baseline.y = STATUS_MESSAGE_HEIGHT - RES_CASE(1,6,6); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.pStr = pStr;
 	t.CharCount = (COUNT)~0;
@@ -458,14 +521,16 @@ DrawCaptainsName (void)
 	OldFont = SetContextFont (TinyFont);
 	OldColor = SetContextForeGroundColor (CAPTAIN_NAME_BACKGROUND_COLOR);
 
-	r.corner.x = 2 + 1;
-	r.corner.y = 10;
-	r.extent.width = SHIP_NAME_WIDTH - 2;
-	r.extent.height = SHIP_NAME_HEIGHT;
+	// Background of captain's name.	
+	r.corner.x = RES_STAT_SCALE(3);							// JMS_GFX
+	r.corner.y = RES_CASE(10,18,30);						// JMS_GFX
+	r.extent.width = SHIP_NAME_WIDTH - RES_STAT_SCALE(2);	// JMS_GFX
+	r.extent.height = SHIP_NAME_HEIGHT;						// JMS_GFX
 	DrawFilledRectangle (&r);
 
-	t.baseline.x = (STATUS_WIDTH >> 1) - 1;
-	t.baseline.y = r.corner.y + 6;
+	// The name itself.
+	t.baseline.x = (STATUS_WIDTH >> 1) - RES_CASE(1,0,-1);
+	t.baseline.y = r.corner.y + RES_CASE(6,10,18); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.pStr = GLOBAL_SIS (CommanderName);
 	t.CharCount = (COUNT)~0;
@@ -493,9 +558,9 @@ DrawFlagshipName (BOOLEAN InStatusArea)
 		OldContext = SetContext (StatusContext);
 		OldFont = SetContextFont (StarConFont);
 
-		r.corner.x = 2;
-		r.corner.y = 20;
-		r.extent.width = SHIP_NAME_WIDTH;
+		r.corner.x = RES_CASE(2,4,7);		// JMS_GFX
+		r.corner.y = RES_CASE(20,40,62);	// JMS_GFX
+		r.extent.width = SHIP_NAME_WIDTH;	// JMS_GFX
 		r.extent.height = SHIP_NAME_HEIGHT;
 
 		t.pStr = GLOBAL_SIS (ShipName);
@@ -505,10 +570,10 @@ DrawFlagshipName (BOOLEAN InStatusArea)
 		OldContext = SetContext (SpaceContext);
 		OldFont = SetContextFont (MicroFont);
 
-		r.corner.x = 0;
+		r.corner.x = RES_CASE(0,24,0); // JMS_GFX
 		r.corner.y = 1;
-		r.extent.width = SIS_SCREEN_WIDTH;
-		r.extent.height = SHIP_NAME_HEIGHT;
+		r.extent.width = SIS_SCREEN_WIDTH- RES_CASE(0,24,0); // JMS_GFX
+		r.extent.height = SHIP_NAME_HEIGHT + RES_CASE(0,1,0); // JMS_GFX
 
 		t.pStr = buf;
 		snprintf (buf, sizeof buf, "%s %s",
@@ -521,7 +586,8 @@ DrawFlagshipName (BOOLEAN InStatusArea)
 	DrawFilledRectangle (&r);
 
 	t.baseline.x = r.corner.x + (r.extent.width >> 1);
-	t.baseline.y = r.corner.y + (SHIP_NAME_HEIGHT - InStatusArea);
+	t.baseline.y = r.corner.y + (SHIP_NAME_HEIGHT - 
+			(InStatusArea ? RES_CASE(1,3,3) : RES_CASE(0,2,0))); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.CharCount = (COUNT)~0;
 	if (optWhichFonts == OPT_PC)
@@ -529,7 +595,7 @@ DrawFlagshipName (BOOLEAN InStatusArea)
 				InStatusArea ? 0 : 3));
 	else
 		SetContextForeGroundColor (THREEDO_FLAGSHIP_NAME_TEXT_COLOR);
-	
+
 	font_DrawText (&t);
 
 	SetContextFontEffect (OldFontEffect);
@@ -563,25 +629,35 @@ DrawFlagshipStats (void)
 	energy_wait = ENERGY_WAIT;
 	max_thrust = MAX_THRUST;
 	turn_wait = TURN_WAIT;
-	fuel = 10 * FUEL_TANK_SCALE;
 
-	for (i = 0; i < NUM_MODULE_SLOTS; i++)
+
+	if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == CHMMR_EXPLORER_SHIP)
 	{
-		switch (GLOBAL_SIS (ModuleSlots[i])) {
-			case FUEL_TANK:
-				fuel += FUEL_TANK_CAPACITY;
-				break;
-			case HIGHEFF_FUELSYS:
-				fuel += HEFUEL_TANK_CAPACITY;
-				break;
-			case DYNAMO_UNIT:
-				energy_wait -= 2;
-				if (energy_wait < 4)
-					energy_wait = 4;
-				break;
-			case SHIVA_FURNACE:
-				energy_regeneration++;
-				break;
+	    fuel = EXPLORER_FUEL_CAPACITY;
+	}
+	else
+	{
+	    fuel = 10 * FUEL_TANK_SCALE;
+	    
+	    for (i = 0; i < NUM_MODULE_SLOTS; i++)
+		{
+			switch (GLOBAL_SIS (ModuleSlots[i])) 
+			{
+				case FUEL_TANK:
+					fuel += FUEL_TANK_CAPACITY;
+					break;
+				case HIGHEFF_FUELSYS:
+					fuel += HEFUEL_TANK_CAPACITY;
+					break;
+				case DYNAMO_UNIT:
+					energy_wait -= 2;
+					if (energy_wait < 4)
+						energy_wait = 4;
+					break;
+				case SHIVA_FURNACE:
+					energy_regeneration++;
+					break;
+			}
 		}
 	}
 
@@ -613,47 +689,55 @@ DrawFlagshipStats (void)
 	   fact that the leading is way more than is generally needed.
 	*/
 	leading -= 3;
-	t.baseline.x = SIS_SCREEN_WIDTH / 6; //wild-assed guess, but it worked
-	t.baseline.y = r.corner.y + leading + 3;
-	t.align = ALIGN_RIGHT;
-	t.CharCount = (COUNT)~0;
+	
+	if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS)!= CHMMR_EXPLORER_SHIP)
+	{
+		if (RESOLUTION_FACTOR == 0)
+			t.baseline.x = SIS_SCREEN_WIDTH / 6; //wild-assed guess, but it worked
+		else
+			t.baseline.x = SIS_SCREEN_WIDTH / 8; //wild-assed guess number two
+	
+		t.baseline.y = r.corner.y + leading + 3;
+		t.align = ALIGN_RIGHT;
+		t.CharCount = (COUNT)~0;
 
-	SetContextFontEffect (SetAbsFrameIndex (FontGradFrame, 4));
+		SetContextFontEffect (SetAbsFrameIndex (FontGradFrame, 4));
 
-	t.pStr = GAME_STRING (FLAGSHIP_STRING_BASE + 0); // "nose:"
-	font_DrawText (&t);
-	t.baseline.y += leading;
-	t.pStr = GAME_STRING (FLAGSHIP_STRING_BASE + 1); // "spread:"
-	font_DrawText (&t);
-	t.baseline.y += leading;
-	t.pStr = GAME_STRING (FLAGSHIP_STRING_BASE + 2); // "side:"
-	font_DrawText (&t);
-	t.baseline.y += leading;
-	t.pStr = GAME_STRING (FLAGSHIP_STRING_BASE + 3); // "tail:"
-	font_DrawText (&t);
+		t.pStr = GAME_STRING (FLAGSHIP_STRING_BASE + 0); // "nose:"
+		font_DrawText (&t);
+		t.baseline.y += leading;
+		t.pStr = GAME_STRING (FLAGSHIP_STRING_BASE + 1); // "spread:"
+		font_DrawText (&t);
+		t.baseline.y += leading;
+		t.pStr = GAME_STRING (FLAGSHIP_STRING_BASE + 2); // "side:"
+		font_DrawText (&t);
+		t.baseline.y += leading;
+		t.pStr = GAME_STRING (FLAGSHIP_STRING_BASE + 3); // "tail:"
+		font_DrawText (&t);
 
-	t.baseline.x += 5;
-	t.baseline.y = r.corner.y + leading + 3;
-	t.align = ALIGN_LEFT;
-	t.pStr = buf;
+		t.baseline.x += 5;
+		t.baseline.y = r.corner.y + leading + 3;
+		t.align = ALIGN_LEFT;
+		t.pStr = buf;
 
-	snprintf (buf, sizeof buf, "%-7.7s",
+		snprintf (buf, sizeof buf, "%-7.7s",
 			describeWeapon (GLOBAL_SIS (ModuleSlots[15])));
-	font_DrawText (&t);
-	t.baseline.y += leading;
-	snprintf (buf, sizeof buf,
-			"%-7.7s", describeWeapon (GLOBAL_SIS (ModuleSlots[14])));
-	font_DrawText (&t);
-	t.baseline.y += leading;
-	snprintf (buf, sizeof buf,
-			"%-7.7s", describeWeapon (GLOBAL_SIS (ModuleSlots[13])));
-	font_DrawText (&t);
-	t.baseline.y += leading;
-	snprintf (buf, sizeof buf,
-			"%-7.7s", describeWeapon (GLOBAL_SIS (ModuleSlots[0])));
-	font_DrawText (&t);
+		font_DrawText (&t);
+		t.baseline.y += leading;
+		snprintf (buf, sizeof buf,
+				  "%-7.7s", describeWeapon (GLOBAL_SIS (ModuleSlots[14])));
+		font_DrawText (&t);
+		t.baseline.y += leading;
+		snprintf (buf, sizeof buf,
+				  "%-7.7s", describeWeapon (GLOBAL_SIS (ModuleSlots[13])));
+		font_DrawText (&t);
+		t.baseline.y += leading;
+		snprintf (buf, sizeof buf,
+				  "%-7.7s", describeWeapon (GLOBAL_SIS (ModuleSlots[0])));
+		font_DrawText (&t);
+	}
 
-	t.baseline.x = r.extent.width - 25;
+	t.baseline.x = r.extent.width - 25 - 12 * RESOLUTION_FACTOR; // JMS_GFX
 	t.baseline.y = r.corner.y + leading + 3;
 	t.align = ALIGN_RIGHT;
 
@@ -671,7 +755,7 @@ DrawFlagshipStats (void)
 	t.pStr = GAME_STRING (FLAGSHIP_STRING_BASE + 7); // "maximum fuel:"
 	font_DrawText (&t);
 
-	t.baseline.x = r.extent.width - 2;
+	t.baseline.x = r.extent.width - (2 << RESOLUTION_FACTOR); // JMS_GFX
 	t.baseline.y = r.corner.y + leading + 3;
 	t.pStr = buf;
 
@@ -739,11 +823,10 @@ DrawLanders (void)
 	i = GLOBAL_SIS (NumLanders);
 	r.corner.x = (STATUS_WIDTH >> 1) - r.corner.x;
 	s.origin.x = r.corner.x - (((r.extent.width * i) + (2 * (i - 1))) >> 1);
-	s.origin.y = 29;
+	s.origin.y = RES_STAT_SCALE(29); // JMS_GFX
 
 	width = r.extent.width + 2;
-	r.extent.width = (r.extent.width * MAX_LANDERS)
-			+ (2 * (MAX_LANDERS - 1)) + 2;
+	r.extent.width = (r.extent.width * MAX_LANDERS) + (2 * (MAX_LANDERS - 1)) + 2;
 	r.corner.x -= r.extent.width >> 1;
 	r.corner.y += s.origin.y;
 	SetContextForeGroundColor (BLACK_COLOR);
@@ -764,12 +847,20 @@ DrawStorageBays (BOOLEAN Refresh)
 	BYTE i;
 	RECT r;
 	CONTEXT OldContext;
+	COUNT StorageBayCapacity; // JMS
+	
+	// JMS: Due to popular demand, let's give Explorer a small mineral storage bay!
+	if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == CHMMR_EXPLORER_SHIP)
+		StorageBayCapacity = EXPLORER_STORAGE_BAY_CAPACITY;
+	else
+		StorageBayCapacity = STORAGE_BAY_CAPACITY;
 
 	OldContext = SetContext (StatusContext);
 
-	r.extent.width = 2;
-	r.extent.height = 4;
-	r.corner.y = 123;
+	r.extent.width  = RES_STAT_SCALE(2); // JMS_GFX
+	r.extent.height = RES_STAT_SCALE(4); // JMS_GFX
+	r.corner.y		= RES_STAT_SCALE(123) + RES_CASE(0,1,5); // JMS_GFX
+	
 	if (Refresh)
 	{
 		r.extent.width = NUM_MODULE_SLOTS * (r.extent.width + 1);
@@ -777,50 +868,59 @@ DrawStorageBays (BOOLEAN Refresh)
 
 		SetContextForeGroundColor (BLACK_COLOR);
 		DrawFilledRectangle (&r);
-		r.extent.width = 2;
+		r.extent.width = RES_STAT_SCALE(2); // JMS_GFX
 	}
-
+	
 	i = (BYTE)CountSISPieces (STORAGE_BAY);
+	
 	if (i)
 	{
 		COUNT j;
 
-		r.corner.x = (STATUS_WIDTH >> 1)
-				- ((i * (r.extent.width + 1)) >> 1);
+		r.corner.x = (STATUS_WIDTH >> 1) - ((i * (r.extent.width + 1)) >> 1);
+		
+		// Draw full bays.
 		SetContextForeGroundColor (STORAGE_BAY_FULL_COLOR);
-		for (j = GLOBAL_SIS (TotalElementMass);
-				j >= STORAGE_BAY_CAPACITY; j -= STORAGE_BAY_CAPACITY)
+		for (j = GLOBAL_SIS (TotalElementMass); j >= StorageBayCapacity; j -= StorageBayCapacity)
 		{
 			DrawFilledRectangle (&r);
-			r.corner.x += r.extent.width + 1;
+			r.corner.x += r.extent.width + RES_STAT_SCALE(1); // JMS_GFX;
 
 			--i;
 		}
 
-		r.extent.height = (4 * j + (STORAGE_BAY_CAPACITY - 1)) /
-				STORAGE_BAY_CAPACITY;
+		// This sets how full a partially filled bay is.
+		r.extent.height = (RES_STAT_SCALE (4) * j + (StorageBayCapacity - 1)) / StorageBayCapacity;
+		
 		if (r.extent.height)
 		{
-			r.corner.y += 4 - r.extent.height;
+			// Filled part of the bay.
+			r.corner.y += RES_STAT_SCALE (4) - r.extent.height;
+			//r.corner.y += 4 - r.extent.height;
 			DrawFilledRectangle (&r);
-			r.extent.height = 4 - r.extent.height;
+			
+			//
+			r.extent.height = RES_STAT_SCALE(4) - r.extent.height;
+			// r.extent.height = 4 - r.extent.height;
 			if (r.extent.height)
 			{
-				r.corner.y = 123;
+				r.corner.y = RES_STAT_SCALE(123) + RES_CASE(0,1,5);
 				SetContextForeGroundColor (STORAGE_BAY_EMPTY_COLOR);
 				DrawFilledRectangle (&r);
 			}
-			r.corner.x += r.extent.width + 1;
+			
+			r.corner.x += r.extent.width + RES_STAT_SCALE(1);
 
 			--i;
 		}
-		r.extent.height = 4;
 
+		// Draw totally empty bays.
+		r.extent.height = RES_STAT_SCALE(4);
 		SetContextForeGroundColor (STORAGE_BAY_EMPTY_COLOR);
 		while (i--)
 		{
 			DrawFilledRectangle (&r);
-			r.corner.x += r.extent.width + 1;
+			r.corner.x += r.extent.width + RES_STAT_SCALE(1);
 		}
 	}
 
@@ -830,10 +930,10 @@ DrawStorageBays (BOOLEAN Refresh)
 void
 GetGaugeRect (RECT *pRect, BOOLEAN IsCrewRect)
 {
-	pRect->extent.width = 24;
-	pRect->corner.x = (STATUS_WIDTH >> 1) - (pRect->extent.width >> 1);
-	pRect->extent.height = 5;
-	pRect->corner.y = IsCrewRect ? 117 : 38;
+	pRect->extent.width = RES_STAT_SCALE(24) - RES_CASE(0,6,6); // JMS_GFX
+	pRect->corner.x = (STATUS_WIDTH >> 1) - (pRect->extent.width >> 1) + RESOLUTION_FACTOR * 2;
+	pRect->extent.height = RES_STAT_SCALE(5); // JMS_GFX
+	pRect->corner.y = RES_STAT_SCALE((IsCrewRect ? 117 : 38)) + RESOLUTION_FACTOR * 3; // JMS_GFX
 }
 
 static void
@@ -844,23 +944,23 @@ DrawPC_SIS (void)
 
 	GetGaugeRect (&r, FALSE);
 	t.baseline.x = STATUS_WIDTH >> 1;
-	t.baseline.y = r.corner.y - 1;
+	t.baseline.y = r.corner.y - 1; // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.CharCount = (COUNT)~0;
 	SetContextFont (TinyFont);
 	SetContextForeGroundColor (BLACK_COLOR);
 
-	r.corner.y -= 6;
-	r.corner.x--;
-	r.extent.width += 2;
+	r.corner.y -= RES_STAT_SCALE(6); // JMS_GFX
+	r.corner.x -= RES_STAT_SCALE(1); // JMS_GFX
+	r.extent.width += RES_STAT_SCALE(2);
 	DrawFilledRectangle (&r);
 
 	SetContextFontEffect (SetAbsFrameIndex (FontGradFrame, 1));
 	t.pStr = GAME_STRING (STATUS_STRING_BASE + 3); // "FUEL"
 	font_DrawText (&t);
 
-	r.corner.y += 79;
-	t.baseline.y += 79;
+	r.corner.y += RES_STAT_SCALE(79) + (RESOLUTION_FACTOR == 1 ? 2 : 0); // JMS_GFX
+	t.baseline.y += RES_STAT_SCALE(79); // JMS_GFX
 	DrawFilledRectangle (&r);
 
 	SetContextFontEffect (SetAbsFrameIndex (FontGradFrame, 2));
@@ -869,16 +969,16 @@ DrawPC_SIS (void)
 	SetContextFontEffect (NULL);
 
 	// Background of text "CAPTAIN".
-	r.corner.x = 2 + 1;
-	r.corner.y = 3;
-	r.extent.width = 58;
-	r.extent.height = 7;
+	r.corner.x = (2 + 1) << RESOLUTION_FACTOR; // JMS_GFX;
+	r.corner.y = RES_STAT_SCALE(3); // JMS_GFX
+	r.extent.width = RES_STAT_SCALE(58); // JMS_GFX
+	r.extent.height = RES_STAT_SCALE(7); // JMS_GFX
 	SetContextForeGroundColor (PC_CAPTAIN_STRING_BACKGROUND_COLOR);
 	DrawFilledRectangle (&r);
 
 	// Text "CAPTAIN".
 	SetContextForeGroundColor (PC_CAPTAIN_STRING_TEXT_COLOR);
-	t.baseline.y = r.corner.y + 6;
+	t.baseline.y = r.corner.y + RES_CASE(6,10,18); // JMS_GFX
 	t.pStr = GAME_STRING (STATUS_STRING_BASE + 5); // "CAPTAIN"
 	font_DrawText (&t);
 }
@@ -889,7 +989,7 @@ DrawThrusters (void)
 	STAMP s;
 	COUNT i;
 
-	s.origin.x = 1;
+	s.origin.x = RES_STAT_SCALE(1);
 	s.origin.y = 0;
 	for (i = 0; i < NUM_DRIVE_SLOTS; ++i)
 	{
@@ -902,7 +1002,7 @@ DrawThrusters (void)
 			DrawStamp (&s);
 		}
 
-		s.origin.y -= 3;
+		s.origin.y -= RES_STAT_SCALE(3); // JMS_GFX
 	}
 }
 
@@ -912,7 +1012,7 @@ DrawTurningJets (void)
 	STAMP s;
 	COUNT i;
 
-	s.origin.x = 1;
+	s.origin.x = RES_STAT_SCALE(1);
 	s.origin.y = 0;
 	for (i = 0; i < NUM_JET_SLOTS; ++i)
 	{
@@ -925,7 +1025,7 @@ DrawTurningJets (void)
 			DrawStamp (&s);
 		}
 
-		s.origin.y -= 3;
+		s.origin.y -= RES_STAT_SCALE(3); // JMS_GFX
 	}
 }
 
@@ -935,8 +1035,8 @@ DrawModules (void)
 	STAMP s;
 	COUNT i;
 
-	s.origin.x = 1; // This properly centers the modules.
-	s.origin.y = 1;
+	s.origin.x = RES_STAT_SCALE(1); // This properly centers the modules.
+	s.origin.y = RES_STAT_SCALE(1);
 	for (i = 0; i < NUM_MODULE_SLOTS; ++i)
 	{
 		BYTE which_piece = GLOBAL_SIS (ModuleSlots[i]);
@@ -946,7 +1046,7 @@ DrawModules (void)
 			DrawStamp (&s);
 		}
 
-		s.origin.y -= 3;
+		s.origin.y -= RES_STAT_SCALE(3); // JMS_GFX
 	}
 }
 
@@ -957,10 +1057,20 @@ DrawSupportShips (void)
 	HSHIPFRAG hStarShip;
 	HSHIPFRAG hNextShip;
 	const POINT *pship_pos;
-	const POINT ship_pos[MAX_BUILT_SHIPS] =
+	const POINT ship_pos_1x[MAX_BUILT_SHIPS] =
+	{
+		SUPPORT_SHIP_PTS_1X
+	};
+	const POINT ship_pos_2x[MAX_BUILT_SHIPS] =
+	{
+		SUPPORT_SHIP_PTS_2X
+	};
+	const POINT ship_pos_4x[MAX_BUILT_SHIPS] =
 	{
-		SUPPORT_SHIP_PTS
+		SUPPORT_SHIP_PTS_4X
 	};
+	
+	const POINT *ship_pos = RES_CASE(ship_pos_1x,ship_pos_2x,ship_pos_4x);
 
 	for (hStarShip = GetHeadLink (&GLOBAL (built_ship_q)),
 			pship_pos = ship_pos;
@@ -972,8 +1082,9 @@ DrawSupportShips (void)
 		StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 		hNextShip = _GetSuccLink (StarShipPtr);
 
-		s.origin = *pship_pos;
-		s.frame = StarShipPtr->icons;
+		s.origin.x = RES_STAT_SCALE(pship_pos->x);
+		s.origin.y = RES_STAT_SCALE(pship_pos->y);
+		s.frame = SetAbsFrameIndex (StarShipPtr->icons, 2);
 		LockMutex (GraphicsLock);
 		DrawStamp (&s);
 		UnlockMutex (GraphicsLock);
@@ -1014,15 +1125,14 @@ DeltaSISGauges_crewDelta (SIZE crew_delt
 		GetGaugeRect (&r, TRUE);
 		
 		t.baseline.x = STATUS_WIDTH >> 1;
-		t.baseline.y = r.corner.y + r.extent.height;
+		t.baseline.y = r.corner.y + r.extent.height - (RESOLUTION_FACTOR == 1 ? 2 : 0); // JMS_GFX
 		t.align = ALIGN_CENTER;
 		t.pStr = buf;
 		t.CharCount = (COUNT)~0;
 
 		SetContextForeGroundColor (BLACK_COLOR);
 		DrawFilledRectangle (&r);
-		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x00, 0x0E, 0x00), 0x6C));
+		SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x00, 0x0E, 0x00), 0x6C));
 		font_DrawText (&t);
 	}
 }
@@ -1057,8 +1167,8 @@ DeltaSISGauges_fuelDelta (SIZE fuel_delt
 		}
 	}
 
-	new_coarse_fuel = (COUNT)(
-			GLOBAL_SIS (FuelOnBoard) / FUEL_TANK_SCALE);
+	new_coarse_fuel = (COUNT)(GLOBAL_SIS (FuelOnBoard) / FUEL_TANK_SCALE);
+	
 	if (new_coarse_fuel != old_coarse_fuel)
 	{
 		TEXT t;
@@ -1070,15 +1180,14 @@ DeltaSISGauges_fuelDelta (SIZE fuel_delt
 		GetGaugeRect (&r, FALSE);
 		
 		t.baseline.x = STATUS_WIDTH >> 1;
-		t.baseline.y = r.corner.y + r.extent.height;
+		t.baseline.y = r.corner.y + r.extent.height - (RESOLUTION_FACTOR == 1 ? 2 : 0);
 		t.align = ALIGN_CENTER;
 		t.pStr = buf;
 		t.CharCount = (COUNT)~0;
 
 		SetContextForeGroundColor (BLACK_COLOR);
 		DrawFilledRectangle (&r);
-		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x13, 0x00, 0x00), 0x2C));
+		SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x13, 0x00, 0x00), 0x2C));
 		font_DrawText (&t);
 	}
 }
@@ -1103,8 +1212,8 @@ DeltaSISGauges_resunitDelta (SIZE resuni
 	{
 		RECT r;
 
-		r.corner.x = 2;
-		r.corner.y = 130;
+		r.corner.x = RES_STAT_SCALE(2) + RESOLUTION_FACTOR; // JMS_GFX
+		r.corner.y = RES_STAT_SCALE(130) + 2 * RESOLUTION_FACTOR; // JMS_GFX
 		r.extent.width = STATUS_MESSAGE_WIDTH;
 		r.extent.height = STATUS_MESSAGE_HEIGHT;
 		SetContextForeGroundColor (
@@ -1137,9 +1246,15 @@ DeltaSISGauges (SIZE crew_delta, SIZE fu
 		if (optWhichFonts == OPT_PC)
 			DrawPC_SIS();
 
-		DrawThrusters ();
-		DrawTurningJets ();
-		DrawModules ();
+	    if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == CHMMR_EXPLORER_SHIP)
+		{
+		}
+	    else
+		{
+			DrawThrusters ();
+			DrawTurningJets ();
+			DrawModules ();
+		}
 
 		UnlockMutex (GraphicsLock);
 		DrawSupportShips ();
@@ -1195,10 +1310,17 @@ GetCrewPodCapacity (void)
 	COUNT capacity = 0;
 	COUNT slotI;
 
-	for (slotI = 0; slotI < NUM_MODULE_SLOTS; slotI++)
+	if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == CHMMR_EXPLORER_SHIP)
 	{
-		BYTE moduleType = GLOBAL_SIS (ModuleSlots[slotI]);
-		capacity += GetModuleCrewCapacity (moduleType);
+		capacity = EXPLORER_CREW_CAPACITY;
+	}
+	else
+	{
+		for (slotI = 0; slotI < NUM_MODULE_SLOTS; slotI++)
+		{
+			BYTE moduleType = GLOBAL_SIS (ModuleSlots[slotI]);
+			capacity += GetModuleCrewCapacity (moduleType);
+		}
 	}
 
 	return capacity;
@@ -1235,37 +1357,85 @@ GetCrewPodForCrewMember (COUNT crewNr, C
 // set the foreground color to the color for that crew member,
 // and return GetCrewPodCapacity ().
 // TODO: Split of the parts of this function into separate functions.
+// BW: New function for populating the Explorer
 COUNT
 GetCPodCapacity (POINT *ppt)
 {
-	COUNT crewCount;
-	COUNT slotNr;
-	COUNT seatNr;
+	if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == CHMMR_EXPLORER_SHIP)
+	{
+		int i;
+		COUNT line_remainder;
+		COORD x,y;
 
-	COUNT rowNr;
-	COUNT colNr;
-				
-	static const Color crewRows[] = PC_CREW_COLOR_TABLE;
+		line_remainder = GetCrewCount() + 1;
+		i=0;
+  
+		while (line_remainder > crew_lines_sizes[i])
+		{
+			line_remainder -= crew_lines_sizes[i];
+			i++;
+		}
 
-	crewCount = GetCrewCount ();
-	if (!GetCrewPodForCrewMember (crewCount, &slotNr, &seatNr))
-	{
-		// Crew does not fit. *ppt is unchanged.
+		switch (RESOLUTION_FACTOR)
+		{
+			case 2:
+				x = crew_lines_x_coords_4x[i];
+				break;
+			case 1:
+				x = crew_lines_x_coords_4x[i];
+				break;
+			case 0:
+			default:
+				x = crew_lines_x_coords_1x[i];
+				break;
+		}			
+		y = crew_lines_y_coords[i];
+  
+		if (ppt)
+		{
+			static const Color crew_rows[] = PC_EXPLORER_CREW_COLOR_TABLE;
+      
+			ppt->x = (x + 2 * line_remainder) << RESOLUTION_FACTOR;
+			ppt->y = (y << RESOLUTION_FACTOR) + RES_CASE(12,17,34);
+      
+			if (optWhichFonts == OPT_PC)
+				SetContextForeGroundColor (crew_rows[(y-7)/2]);
+			else
+				SetContextForeGroundColor (THREEDO_CREW_COLOR);
+		}
 		return GetCrewPodCapacity ();
 	}
+	else
+	{
+		COUNT crewCount;
+		COUNT slotNr;
+		COUNT seatNr;
 
-	rowNr = seatNr / CREW_PER_ROW;
-	colNr = seatNr % CREW_PER_ROW;
+		COUNT rowNr;
+		COUNT colNr;
+				
+		static const Color crewRows[] = PC_CREW_COLOR_TABLE;
 
-	if (optWhichFonts == OPT_PC)
-		SetContextForeGroundColor (crewRows[rowNr]);
-	else
-		SetContextForeGroundColor (THREEDO_CREW_COLOR);
+		crewCount = GetCrewCount ();
+		if (!GetCrewPodForCrewMember (crewCount, &slotNr, &seatNr))
+		{
+			// Crew does not fit. *ppt is unchanged.
+			return GetCrewPodCapacity ();
+		}
+
+		rowNr = seatNr / CREW_PER_ROW;
+		colNr = seatNr % CREW_PER_ROW;
+
+		if (optWhichFonts == OPT_PC)
+			SetContextForeGroundColor (crewRows[rowNr]);
+		else
+			SetContextForeGroundColor (THREEDO_CREW_COLOR);
 		
-	ppt->x = 27 + (slotNr * SHIP_PIECE_OFFSET) - (colNr * 2);
-	ppt->y = 34 - (rowNr * 2);
+		ppt->x = (27 << RESOLUTION_FACTOR) + (slotNr * SHIP_PIECE_OFFSET) - ((colNr * 2) << RESOLUTION_FACTOR); // JMS_GFX
+		ppt->y = (34 - (rowNr * 2)) << RESOLUTION_FACTOR; // JMS_GFX
 
-	return GetCrewPodCapacity ();
+		return GetCrewPodCapacity ();
+	}
 }
 
 
@@ -1284,8 +1454,16 @@ GetElementMass (void)
 COUNT
 GetModuleStorageCapacity (BYTE moduleType)
 {
+	COUNT StorageBayCapacity; // JMS
+	
+	// JMS: Due to popular demand, let's give Explorer a small mineral storage bay!
+	if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == CHMMR_EXPLORER_SHIP)
+		StorageBayCapacity = EXPLORER_STORAGE_BAY_CAPACITY;
+	else
+		StorageBayCapacity = STORAGE_BAY_CAPACITY;
+	
 	if (moduleType == STORAGE_BAY)
-		return STORAGE_BAY_CAPACITY;
+		return StorageBayCapacity;
 
 	return 0;
 }
@@ -1367,8 +1545,16 @@ GetSBayCapacity (POINT *ppt)
 		SetContextForeGroundColor (colorBars[rowNr]);
 	}
 		
-	ppt->x = 19 + (slotNr * SHIP_PIECE_OFFSET);
-	ppt->y = 34 - (rowNr * 2);
+	ppt->x = (19 << RESOLUTION_FACTOR) + (slotNr * SHIP_PIECE_OFFSET);
+	ppt->y = (34 - (rowNr * 2)) << RESOLUTION_FACTOR;
+	
+	// Graphics positioning for tentative Explorer storage bay
+	if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == CHMMR_EXPLORER_SHIP)
+	{
+		ppt->y = (27 - rowNr) << RESOLUTION_FACTOR;
+		if (rowNr == 9)
+			ppt->x = (40 << RESOLUTION_FACTOR);
+	}
 
 	return GetStorageBayCapacity ();
 }
@@ -1402,16 +1588,23 @@ GetModuleFuelCapacity (BYTE moduleType)
 DWORD
 GetFuelTankCapacity (void)
 {
-	DWORD capacity = FUEL_RESERVE;
-	COUNT slotI;
-
-	for (slotI = 0; slotI < NUM_MODULE_SLOTS; slotI++)
+	if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == CHMMR_EXPLORER_SHIP)
 	{
-		BYTE moduleType = GLOBAL_SIS (ModuleSlots[slotI]);
-		capacity += GetModuleFuelCapacity (moduleType);
+		return EXPLORER_FUEL_CAPACITY;
 	}
+	else
+	{
+		DWORD capacity = FUEL_RESERVE;
+		COUNT slotI;
 
-	return capacity;
+		for (slotI = 0; slotI < NUM_MODULE_SLOTS; slotI++)
+		{
+			BYTE moduleType = GLOBAL_SIS (ModuleSlots[slotI]);
+			capacity += GetModuleFuelCapacity (moduleType);
+		}
+
+		return capacity;
+	}
 }
 
 // Find the slot number of the fuel cell and "compartment" number in that
@@ -1447,49 +1640,73 @@ GetFuelTankForFuelUnit (DWORD unitNr, CO
 // set the foreground color to the color for that unit,
 // and return GetFuelTankCapacity ().
 // TODO: Split of the parts of this function into separate functions.
+// BW: new function for fueling the Explorer
 DWORD
 GetFTankCapacity (POINT *ppt)
 {
 	DWORD capacity;
-	DWORD fuelAmount;
-	COUNT slotNr;
-	DWORD compartmentNr;
-	BYTE moduleType;
-	DWORD volume;
 
-	COUNT rowNr;
+	capacity = GetFuelTankCapacity();
+
+	if (GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS) == CHMMR_EXPLORER_SHIP)
+	{
+		if (ppt)
+		{
+			COUNT which_row;
+			static const Color fuel_colors[] = FUEL_COLOR_TABLE;
+	  
+			which_row = (COUNT)(GetFuelTotal() * EXPLORER_MAX_FUEL_BARS
+					    / (EXPLORER_FUEL_CAPACITY));
 	
-	static const Color fuelColors[] = FUEL_COLOR_TABLE;
+			ppt->x = (31 << RESOLUTION_FACTOR) + which_row; // JMS_GFX
+			ppt->y = RES_CASE(22, 48, 97); // JMS_GFX
 		
-	capacity = GetFuelTankCapacity ();
-	fuelAmount = GetFuelTotal ();
-	if (fuelAmount < FUEL_RESERVE)
-	{
-		// Fuel is in the SIS reserve, not in a fuel tank.
-		// *ppt is unchanged
-		return capacity;
+			which_row = (COUNT)(GetFuelTotal() * 10 / (EXPLORER_FUEL_CAPACITY));
+				
+			SetContextForeGroundColor (fuel_colors[which_row]);
+			SetContextBackGroundColor (fuel_colors[which_row + 1]);
+		}
 	}
-
-	if (!GetFuelTankForFuelUnit (fuelAmount, &slotNr, &compartmentNr))
+	else
 	{
-		// Fuel does not fit. *ppt is unchanged.
-		return capacity;
-	}
+		DWORD fuelAmount;
+		COUNT slotNr;
+		DWORD compartmentNr;
+		BYTE moduleType;
+		DWORD volume;
 
-	moduleType = GLOBAL_SIS (ModuleSlots[slotNr]);
-	volume = GetModuleFuelCapacity (moduleType);
+		COUNT rowNr;
+				
+		static const Color fuelColors[] = FUEL_COLOR_TABLE;
 
-	rowNr = ((volume - compartmentNr) * MAX_FUEL_BARS / HEFUEL_TANK_CAPACITY);
+		fuelAmount = GetFuelTotal ();
+		if (fuelAmount < FUEL_RESERVE)
+		{
+			// Fuel is in the SIS reserve, not in a fuel tank.
+			// *ppt is unchanged
+			return capacity;
+		}
+		if (!GetFuelTankForFuelUnit (fuelAmount, &slotNr, &compartmentNr))
+		{
+			// Fuel does not fit. *ppt is unchanged.
+			return capacity;
+		}
+
+		moduleType = GLOBAL_SIS (ModuleSlots[slotNr]);
+		volume = GetModuleFuelCapacity (moduleType);
+
+		rowNr = ((volume - compartmentNr) * MAX_FUEL_BARS / HEFUEL_TANK_CAPACITY);
 		
-	ppt->x = 21 + (slotNr * SHIP_PIECE_OFFSET);
-	if (volume == FUEL_TANK_CAPACITY)
-		ppt->y = 27 - rowNr;
-	else
-		ppt->y = 30 - rowNr;
+		ppt->x = (21 << RESOLUTION_FACTOR) + (slotNr * SHIP_PIECE_OFFSET);
+		if (volume == FUEL_TANK_CAPACITY)
+			ppt->y = (27 << RESOLUTION_FACTOR) - rowNr;
+		else
+			ppt->y = (30 << RESOLUTION_FACTOR) - rowNr;
 
-	assert (rowNr + 1 < (COUNT) (sizeof fuelColors / sizeof fuelColors[0]));
-	SetContextForeGroundColor (fuelColors[rowNr]);
-	SetContextBackGroundColor (fuelColors[rowNr + 1]);
+		assert (rowNr + 1 < (COUNT) (sizeof fuelColors / sizeof fuelColors[0]));
+		SetContextForeGroundColor (fuelColors[rowNr]);
+		SetContextBackGroundColor (fuelColors[rowNr + 1]);
+	}
 
 	return capacity;
 }
diff -ruNp src.orig/uqm/sis.h src/uqm/sis.h
--- src.orig/uqm/sis.h	2017-11-01 15:30:28 -0700
+++ src/uqm/sis.h	2017-11-01 15:31:05 -0700
@@ -13,6 +13,11 @@
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
+// JMS 2010: Explorer has smaller thrust increment in interplanetary
+// JMS 2011: Added to BYTE res_factor to SUMMARY_DESC to enable saving/loading from different res modes.
+
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
 
 #ifndef SIS_H_INCL__
 #define SIS_H_INCL__
@@ -38,19 +43,32 @@
 #define HEFUEL_TANK_CAPACITY (100 * FUEL_TANK_SCALE)
 #define MODULE_COST_SCALE 50
 
-#define CREW_EXPENSE_THRESHOLD 1000
+/** Capacities for Explorer **/
+#define EXPLORER_CREW_CAPACITY 50
+#define EXPLORER_FUEL_CAPACITY (200 * FUEL_TANK_SCALE)
+#define EXPLORER_STORAGE_BAY_CAPACITY 250 /* km cubed */
 
+#define CREW_EXPENSE_THRESHOLD 1000
 #define CREW_PER_ROW 5
 #define SBAY_MASS_PER_ROW 50
 
+#define EXPLORER_NUM_MODULE_SLOTS 0
+
 #define MAX_FUEL_BARS 10
-#define FUEL_VOLUME_PER_ROW (HEFUEL_TANK_CAPACITY / MAX_FUEL_BARS)
+#define EXPLORER_MAX_FUEL_BARS RES_CASE(20, 56, 110)
+#define FUEL_VOLUME_PER_ROW (1 ? (HEFUEL_TANK_CAPACITY * 2 / 20) : (HEFUEL_TANK_CAPACITY / MAX_FUEL_BARS))
+#define EXPLORER_FUEL_VOLUME_PER_ROW (EXPLORER_FUEL_CAPACITY / EXPLORER_MAX_FUEL_BARS)
 #define FUEL_RESERVE FUEL_VOLUME_PER_ROW
 
+/** Capacities for Explorer end **/
+
 #define IP_SHIP_THRUST_INCREMENT 8
 #define IP_SHIP_TURN_WAIT 17
 #define IP_SHIP_TURN_DECREMENT 2
 
+// JMS
+#define EXPLORER_IP_SHIP_THRUST_INCREMENT 8 // JMS: WAS 5
+
 #define BIO_CREDIT_VALUE 2
 
 enum
@@ -88,40 +106,51 @@ enum
 #define EMPTY_SLOT NUM_MODULES
 #define NUM_BOMB_MODULES 10
 
-#define DRIVE_SIDE_X 31
-#define DRIVE_SIDE_Y 56
-#define DRIVE_TOP_X 33
-#define DRIVE_TOP_Y (65 + 21)
-
-#define JET_SIDE_X 71
-#define JET_SIDE_Y 48
-#define JET_TOP_X 70
-#define JET_TOP_Y (73 + 21)
-
-#define MODULE_SIDE_X 17
-#define MODULE_SIDE_Y 14
-#define MODULE_TOP_X 17
-#define MODULE_TOP_Y (96 + 21)
-
-#define SHIP_PIECE_OFFSET 12
-
-#define MAX_BUILT_SHIPS 12
-		/* Maximum number of ships escorting the SIS */
-#define MAX_LANDERS 10
-
-#define SUPPORT_SHIP_PTS \
-	{3 +  0, 30 + (2 * 16)}, \
-	{3 + 42, 30 + (2 * 16)}, \
-	{3 +  0, 30 + (3 * 16)}, \
-	{3 + 42, 30 + (3 * 16)}, \
+// JMS_GFX
+#define DRIVE_SIDE_X (31 << RESOLUTION_FACTOR)
+#define DRIVE_SIDE_Y (56 << RESOLUTION_FACTOR)
+#define DRIVE_TOP_X (33 << RESOLUTION_FACTOR)
+#define DRIVE_TOP_Y ((65 + 21) << RESOLUTION_FACTOR)
+
+#define JET_SIDE_X (71 << RESOLUTION_FACTOR)
+#define JET_SIDE_Y (48 << RESOLUTION_FACTOR)
+#define JET_TOP_X (70 << RESOLUTION_FACTOR)
+#define JET_TOP_Y ((73 + 21) << RESOLUTION_FACTOR)
+
+#define MODULE_SIDE_X (17 << RESOLUTION_FACTOR)
+#define MODULE_SIDE_Y (14 << RESOLUTION_FACTOR)
+#define MODULE_TOP_X (17 << RESOLUTION_FACTOR)
+#define MODULE_TOP_Y ((96 + 21) << RESOLUTION_FACTOR)
+
+#define SHIP_PIECE_OFFSET (12 << RESOLUTION_FACTOR)
+
+#define MAX_BUILT_SHIPS 6 // No more than 6 companion ships for the Explorer
+#define MAX_LANDERS (((GET_GAME_STATE(WHICH_SHIP_PLAYER_HAS)) == 0) ? 3 : 10) // No more than 3 landers for explorer
+
+#define SUPPORT_SHIP_PTS_1X \
 	{3 +  0, 30 + (1 * 16)}, \
 	{3 + 42, 30 + (1 * 16)}, \
-	{3 +  0, 30 + (4 * 16)}, \
-	{3 + 42, 30 + (4 * 16)}, \
 	{3 +  0, 30 + (0 * 16)}, \
 	{3 + 42, 30 + (0 * 16)}, \
 	{3 +  0, 30 + (5 * 16)}, \
 	{3 + 42, 30 + (5 * 16)},
+#define SUPPORT_SHIP_PTS_2X \
+	{2 +  0, 30 + (1 * 20)}, \
+	{2 + 44, 30 + (1 * 20)}, \
+	{2 +  0, 30 + (0 * 16)}, \
+	{2 + 44, 30 + (0 * 16)}, \
+	{2 +  0, 30 + (5 * 16 + 2)}, \
+	{2 + 44, 30 + (5 * 16 + 2)},
+#define SUPPORT_SHIP_PTS_4X \
+	{3 +  0, 30 + (1 * 20)}, \
+	{3 + 42, 30 + (1 * 20)}, \
+	{3 +  0, 30 + (0 * 16)}, \
+	{3 + 42, 30 + (0 * 16)}, \
+	{3 +  0, 30 + (5 * 16 + 2)}, \
+	{3 + 42, 30 + (5 * 16 + 2)},
+// Only authorized positions according to graphics (chflagstat.0.png)
+// BW: now these need to be constant because they initialize an array
+// in roster.c. Resolution Factor will be appied when effectively drawing.
 
 #define SIS_NAME_SIZE 16
 
@@ -137,7 +166,7 @@ typedef struct
 			// Set to (COUNT) ~0 to indicate game over.
 	COUNT TotalElementMass, TotalBioMass;
 
-	BYTE ModuleSlots[NUM_MODULE_SLOTS];
+	BYTE ModuleSlots[NUM_MODULE_SLOTS+1];  /* FIXME: NUM_MODULE_SLOTS is zero, but that won't compile. */
 	BYTE DriveSlots[NUM_DRIVE_SLOTS];
 	BYTE JetSlots[NUM_JET_SLOTS];
 
@@ -168,6 +197,7 @@ typedef struct
 	BYTE NumShips, NumDevices;
 	BYTE ShipList[MAX_BUILT_SHIPS];
 	BYTE DeviceList[MAX_EXCLUSIVE_DEVICES];
+	BYTE res_factor;	// JMS: Stores resolution factor to enable saving/loading from different res modes.
 } SUMMARY_DESC;
 
 #define OVERRIDE_LANDER_FLAGS (1 << 7)
diff -ruNp src.orig/uqm/starbase.c src/uqm/starbase.c
--- src.orig/uqm/starbase.c	2017-11-01 15:30:28 -0700
+++ src/uqm/starbase.c	2017-11-01 15:31:05 -0700
@@ -16,6 +16,13 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: -Removed unnecessary chmmr_bomb condition related to starbase visiting.
+//			 -Procyon starbase now has different gfx from Sol starbase
+//			 -Added functionality to Betelgeuse starbase. Has the same gfx as sol starbase.
+//			 -When the starbase commander is talked to, chasing ships turn away.
+
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
 #include "build.h"
 #include "colors.h"
 #include "controls.h"
@@ -23,6 +30,7 @@
 #include "encount.h"
 #include "comm.h"
 #include "gamestr.h"
+#include "ipdisp.h"
 #include "load.h"
 #include "starbase.h"
 #include "sis.h"
@@ -33,26 +41,92 @@
 #include "sounds.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/tasklib.h"
+#include "libs/log.h"
 
 
 static void CleanupAfterStarBase (void);
 
+#define STARBASE_AMBIENT_ANIM_RATE   40
+
+SBDATA StarbaseData;
+
+static SBDATA sol_desc =
+{
+  	STARBASE_ANIM, /* StarbaseFrameRes */
+	1, /* NumAnimations */
+	{ /* StarbaseAmbientArray (ambient animations) */
+		{	// 0 - Starbase
+			1, /* StartIndex */
+			32, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			0, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+	},
+  	NULL, /* StarbaseFrame */
+  	NULL, /* StarbaseColorMap */
+};
+static SBDATA procyon_desc =
+{
+  	STARBASE_PROCYON_ANIM, /* StarbaseFrameRes */
+	1, /* NumAnimations */
+	{ /* StarbaseAmbientArray (ambient animations) */
+		{	// 0 - Starbase
+			1, /* StartIndex */
+			32, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			0, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+// 		{	// 1 - Avatar
+// 			33, /* StartIndex */
+// 			47, /* NumFrames */
+// 			CIRCULAR_ANIM, /* AnimFlags */
+// 			ONE_SECOND / 20, 0, /* FrameRate */
+// 			ONE_SECOND, ONE_SECOND * 6, /* RestartRate */
+// 			0, /* BlockMask */
+// 		},
+	},
+  	NULL, /* StarbaseFrame */
+  	NULL, /* StarbaseColorMap */
+};
+static SBDATA gaia_desc =
+{
+  	STARBASE_GAIA_ANIM, /* StarbaseFrameRes */
+	1, /* NumAnimations */
+	{ /* StarbaseAmbientArray (ambient animations) */
+		{	// 0 - Starbase
+			1, /* StartIndex */
+			32, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			0, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+	},
+  	NULL, /* StarbaseFrame */
+  	NULL, /* StarbaseColorMap */
+};
+
 static void
 DrawBaseStateStrings (STARBASE_STATE OldState, STARBASE_STATE NewState)
 {
 	TEXT t;
+	RECT r;
 	//STRING locString;
 
 	SetContext (ScreenContext);
 	SetContextFont (StarConFont);
 	SetContextForeGroundColor (BLACK_COLOR);
 
-	t.baseline.x = 73 - 4 + SAFE_X;
+	t.baseline.x = (73 - 4 + SAFE_X) << RESOLUTION_FACTOR; // JMS_GFX
 	t.align = ALIGN_CENTER;
 
 	if (OldState == (STARBASE_STATE)~0)
 	{
-		t.baseline.y = 106 + 28 + (SAFE_Y + 4);
+		t.baseline.y = ((106 + 28) << RESOLUTION_FACTOR) + (SAFE_Y + 4); // JMS_GFX;
 		for (OldState = TALK_COMMANDER; OldState < DEPART_BASE; ++OldState)
 		{
 			if (OldState != NewState)
@@ -61,18 +135,24 @@ DrawBaseStateStrings (STARBASE_STATE Old
 				t.CharCount = (COUNT)~0;
 				font_DrawText (&t);
 			}
-			t.baseline.y += (23 - 4);
+			t.baseline.y += (23 - 4) << RESOLUTION_FACTOR; // JMS_GFX
 		}
 	}
 
-	t.baseline.y = 106 + 28 + (SAFE_Y + 4) + ((23 - 4) * OldState);
+	t.baseline.y = ((106 + 28 + ((23 - 4) * OldState)) << RESOLUTION_FACTOR) + (SAFE_Y + 4); // JMS_GFX
 	t.pStr = GAME_STRING (STARBASE_STRING_BASE + 1 + OldState);
+	// BW: erase previously selected string before redrawing it
+	TextRect(&t, &r, NULL);
+	SetContextForeGroundColor (
+			   BUILD_COLOR_RGBA (0x88, 0x88, 0x88, 0xff));
+	DrawFilledRectangle (&r);
+	SetContextForeGroundColor (BLACK_COLOR);
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 
 	SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x0A), 0x0E));
-	t.baseline.y = 106 + 28 + (SAFE_Y + 4) + ((23 - 4) * NewState);
+	t.baseline.y = ((106 + 28 + ((23 - 4) * NewState)) << RESOLUTION_FACTOR) + (SAFE_Y + 4); // JMS_GFX
 	t.pStr = GAME_STRING (STARBASE_STRING_BASE + 1 + NewState);
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
@@ -290,6 +370,250 @@ rotateStarbase (MENU_STATE *pMS, FRAME A
 		pMS->flash_frame0 = s.frame;
 	}
 }
+/*** Animated starbase by BW based on tasks ; reformed for now but could be reintegrated into rotateStarbase later
+
+static void
+SetUpSBSequence (SEQUENCE *pSeq)
+{
+	COUNT i;
+	ANIMATION_DESC *ADPtr;
+
+	i = StarbaseData.NumAnimations;
+	pSeq = &pSeq[i];
+	ADPtr = &StarbaseData.StarbaseAmbientArray[i];
+	while (i--)
+	{
+		--ADPtr;
+		--pSeq;
+
+		if (ADPtr->AnimFlags & COLORXFORM_ANIM)
+			pSeq->AnimType = COLOR_ANIM;
+		else
+			pSeq->AnimType = PICTURE_ANIM;
+		pSeq->Direction = UP_DIR;
+		pSeq->FramesLeft = ADPtr->NumFrames;
+		if (pSeq->AnimType == COLOR_ANIM)
+			pSeq->AnimObj.CurCMap = SetAbsColorMapIndex (
+					StarbaseData.StarbaseColorMap, ADPtr->StartIndex);
+		else
+			pSeq->AnimObj.CurFrame = SetAbsFrameIndex (
+					StarbaseData.StarbaseFrame, ADPtr->StartIndex);
+
+		if (ADPtr->AnimFlags & RANDOM_ANIM)
+		{
+			if (pSeq->AnimType == COLOR_ANIM)
+				pSeq->AnimObj.CurCMap =
+						SetRelColorMapIndex (pSeq->AnimObj.CurCMap,
+						(COUNT)((COUNT)TFB_Random () % pSeq->FramesLeft));
+			else
+				pSeq->AnimObj.CurFrame =
+						SetRelFrameIndex (pSeq->AnimObj.CurFrame,
+						(COUNT)((COUNT)TFB_Random () % pSeq->FramesLeft));
+		}
+		else if (ADPtr->AnimFlags & YOYO_ANIM)
+		{
+			--pSeq->FramesLeft;
+			if (pSeq->AnimType == COLOR_ANIM)
+				pSeq->AnimObj.CurCMap =
+						SetRelColorMapIndex (pSeq->AnimObj.CurCMap, 1);
+			else
+				pSeq->AnimObj.CurFrame =
+						IncFrameIndex (pSeq->AnimObj.CurFrame);
+		}
+
+		pSeq->Alarm = ADPtr->BaseRestartRate
+				+ ((COUNT)TFB_Random () % (ADPtr->RandomRestartRate + 1)) + 1;
+	}
+}
+
+static int
+starbase_ambient_anim_task (void *data)
+{
+	FRAME AnimFrame[MAX_ANIMATIONS];
+	COUNT i;
+	DWORD LastTime;
+	FRAME StarbaseFrame;
+	SEQUENCE Sequencer[MAX_ANIMATIONS];
+	SEQUENCE *pSeq;
+	ANIMATION_DESC *ADPtr;
+	DWORD ActiveMask;
+			// Bit mask of all animations that are currently active.
+			// Bit 'i' is set if the animation with index 'i' is active.
+	Task task = (Task) data;
+	BOOLEAN ColorChange = FALSE;
+
+	while ((StarbaseFrame = StarbaseData.StarbaseFrame) == 0
+			&& !Task_ReadState (task, TASK_EXIT))
+		TaskSwitch ();
+
+	LockMutex (GraphicsLock);
+	memset (&DisplayArray[0], 0, sizeof (DisplayArray));
+	SetUpSBSequence (Sequencer);
+	UnlockMutex (GraphicsLock);
+
+	ActiveMask = 0;
+	LastTime = GetTimeCounter ();
+	memset (AnimFrame, 0, sizeof (AnimFrame));
+	for (i = 0; i < StarbaseData.NumAnimations; i++)
+	{
+		COUNT nextIndex;
+
+		if (StarbaseData.StarbaseAmbientArray[i].AnimFlags & YOYO_ANIM)
+			nextIndex = StarbaseData.StarbaseAmbientArray[i].StartIndex;
+		else
+			nextIndex = (StarbaseData.StarbaseAmbientArray[i].StartIndex
+					+ StarbaseData.StarbaseAmbientArray[i].NumFrames - 1);
+		AnimFrame[i] = SetAbsFrameIndex (StarbaseFrame, nextIndex);
+	}
+
+	while (!Task_ReadState (task, TASK_EXIT))
+	{
+		BOOLEAN Change;
+		DWORD CurTime, ElapsedTicks;
+
+		SleepThreadUntil (LastTime + ONE_SECOND / STARBASE_AMBIENT_ANIM_RATE);
+
+		LockMutex (GraphicsLock);
+		BatchGraphics ();
+		CurTime = GetTimeCounter ();
+		ElapsedTicks = CurTime - LastTime;
+		LastTime = CurTime;
+
+		Change = FALSE;
+		i = StarbaseData.NumAnimations;
+
+		pSeq = &Sequencer[i];
+		ADPtr = &StarbaseData.StarbaseAmbientArray[i];
+		while (i-- && !Task_ReadState (task, TASK_EXIT))
+		{
+			--ADPtr;
+			--pSeq;
+			if (ADPtr->AnimFlags & ANIM_DISABLED)
+				continue;
+			if (pSeq->Direction == NO_DIR)
+			{
+			  pSeq->Direction = UP_DIR;
+			}
+			else if ((DWORD)pSeq->Alarm > ElapsedTicks)
+				pSeq->Alarm -= (COUNT)ElapsedTicks;
+			else
+			{
+				if (!(ActiveMask & ADPtr->BlockMask)
+						&& (--pSeq->FramesLeft
+						|| ((ADPtr->AnimFlags & YOYO_ANIM)
+						&& pSeq->Direction == UP_DIR)))
+				{
+					ActiveMask |= 1L << i;
+					pSeq->Alarm = ADPtr->BaseFrameRate
+							+ ((COUNT)TFB_Random ()
+							% (ADPtr->RandomFrameRate + 1)) + 1;
+				}
+				else
+				{
+					ActiveMask &= ~(1L << i);
+					pSeq->Alarm = ADPtr->BaseRestartRate
+							+ ((COUNT)TFB_Random ()
+							% (ADPtr->RandomRestartRate + 1)) + 1;
+					if (ActiveMask & ADPtr->BlockMask)
+						continue;
+				}
+
+				if (pSeq->AnimType == COLOR_ANIM)
+				{
+					XFormColorMap (GetColorMapAddress (pSeq->AnimObj.CurCMap),
+							(COUNT) (pSeq->Alarm - 1));
+				}
+				else
+				{
+					Change = TRUE;
+					AnimFrame[i] = pSeq->AnimObj.CurFrame;
+				}
+
+				if (pSeq->FramesLeft == 0)
+				{
+					pSeq->FramesLeft = (BYTE)(ADPtr->NumFrames - 1);
+
+					if (pSeq->Direction == DOWN_DIR)
+						pSeq->Direction = UP_DIR;
+					else if (ADPtr->AnimFlags & YOYO_ANIM)
+						pSeq->Direction = DOWN_DIR;
+					else
+					{
+						++pSeq->FramesLeft;
+						if (pSeq->AnimType == COLOR_ANIM)
+							pSeq->AnimObj.CurCMap = SetRelColorMapIndex (
+									pSeq->AnimObj.CurCMap,
+									(SWORD) (-pSeq->FramesLeft));
+						else
+						{
+							pSeq->AnimObj.CurFrame = SetRelFrameIndex (
+									pSeq->AnimObj.CurFrame,
+									(SWORD) (-pSeq->FramesLeft));
+						}
+					}
+				}
+
+				if (ADPtr->AnimFlags & RANDOM_ANIM)
+				{
+					COUNT nextIndex = ADPtr->StartIndex +
+							(TFB_Random () % ADPtr->NumFrames);
+
+					if (pSeq->AnimType == COLOR_ANIM)
+						pSeq->AnimObj.CurCMap = SetAbsColorMapIndex (
+								pSeq->AnimObj.CurCMap, nextIndex);
+					else
+						pSeq->AnimObj.CurFrame = SetAbsFrameIndex (
+								pSeq->AnimObj.CurFrame, nextIndex);
+				}
+				else if (pSeq->AnimType == COLOR_ANIM)
+				{
+					if (pSeq->Direction == UP_DIR)
+						pSeq->AnimObj.CurCMap = SetRelColorMapIndex (
+								pSeq->AnimObj.CurCMap, 1);
+					else
+						pSeq->AnimObj.CurCMap = SetRelColorMapIndex (
+								pSeq->AnimObj.CurCMap, -1);
+				}
+				else
+				{
+					if (pSeq->Direction == UP_DIR)
+						pSeq->AnimObj.CurFrame =
+								IncFrameIndex (pSeq->AnimObj.CurFrame);
+					else
+						pSeq->AnimObj.CurFrame =
+								DecFrameIndex (pSeq->AnimObj.CurFrame);
+				}
+			}
+		}
+
+		if (Change)
+		  {
+		    STAMP s;
+		    s.origin.x = SAFE_X;
+		    s.origin.y = SAFE_Y + 4;
+		    s.frame = StarbaseFrame;
+		    DrawStamp (&s);
+		    i = StarbaseData.NumAnimations;
+		    while (i--)
+		      {
+			if (ActiveMask & (1L << i))
+			  {
+			    s.frame = AnimFrame[i];
+			    DrawStamp (&s);
+			  }
+		      }
+		    DrawBaseStateStrings ((STARBASE_STATE)~0, pMenuState->CurState);
+		    Change = FALSE;
+		  }
+		
+		UnbatchGraphics ();
+		UnlockMutex (GraphicsLock);
+		ColorChange = XFormColorMap_step ();
+	}
+	FinishTask (task);
+	return 0;
+}
+***/
 
 BOOLEAN
 DoStarBase (MENU_STATE *pMS)
@@ -321,7 +645,20 @@ DoStarBase (MENU_STATE *pMS)
 		pMS->Initialized = TRUE;
 		UnlockMutex (GraphicsLock);
 
-		pMS->CurFrame = CaptureDrawable (LoadGraphic (STARBASE_ANIM));
+		
+		// JMS: Procyon starbase has different graphics from Sol and Betelgeuse starbases
+		if (CurStarDescPtr->Index == CHMMR_DEFINED)
+		  StarbaseData = procyon_desc;
+		else
+		  if (CurStarDescPtr->Index == SOL_DEFINED)
+		    StarbaseData = sol_desc;
+		  else
+		    StarbaseData = gaia_desc;
+		
+		StarbaseData.StarbaseFrame = CaptureDrawable (LoadGraphic (StarbaseData.StarbaseFrameRes));
+
+		pMS->CurFrame = StarbaseData.StarbaseFrame;
+
 		pMS->hMusic = LoadMusic (STARBASE_MUSIC);
 
 		LockMutex (GraphicsLock);
@@ -362,7 +699,25 @@ ExitStarBase:
 		if (pMS->CurState == TALK_COMMANDER)
 		{
 			FlushInput ();
-			InitCommunication (COMMANDER_CONVERSATION);
+			
+			// JMS: Procyon starbase has Chmmr, Sol naturally humans, Betelgeuse our sweet Moosy.
+			// When the starbase commander is talked to, chasing ships turn away.
+			if (CurStarDescPtr->Index == SOL_DEFINED)
+			{
+				InitCommunication (COMMANDER_CONVERSATION);
+				NotifyOthers (HUMAN_SHIP, IPNL_ALL_CLEAR);
+			}
+			else if (CurStarDescPtr->Index == SYREEN_DEFINED)
+			{
+				InitCommunication (SYREENBASE_CONVERSATION);
+				NotifyOthers (SYREEN_SHIP, IPNL_ALL_CLEAR);
+			}
+			else
+			{
+				InitCommunication (CHMMR_CONVERSATION);
+				NotifyOthers (CHMMR_SHIP, IPNL_ALL_CLEAR);
+			}
+			
 			// XXX: InitCommunication() clears these flags, and we need them
 			//   This marks that we are in Starbase.
 			SET_GAME_STATE (GLOBAL_FLAGS_AND_DATA, (BYTE)~0);
@@ -494,7 +849,9 @@ VisitStarBase (void)
 
 	prevMsgMode = SetStatusMessageMode (SMM_RES_UNITS);
 
-	if (GET_GAME_STATE (MOONBASE_ON_SHIP)
+	
+	// JMS: This is unnecessary for our little sequel...
+	/*if (GET_GAME_STATE (MOONBASE_ON_SHIP)
 			|| GET_GAME_STATE (CHMMR_BOMB_STATE) == 2)
 	{	// Go immediately into a conversation with the Commander when the
 		// Starbase becomes available for the first time, or after Chmmr
@@ -510,7 +867,7 @@ VisitStarBase (void)
 		// XXX: InitCommunication() clears these flags, and we need them
 		//   This marks that we are in Starbase.
 		SET_GAME_STATE (GLOBAL_FLAGS_AND_DATA, (BYTE)~0);
-	}
+	}*/
 
 	memset (&MenuState, 0, sizeof (MenuState));
 	MenuState.InputFunc = DoStarBase;
diff -ruNp src.orig/uqm/starbase.h src/uqm/starbase.h
--- src.orig/uqm/starbase.h	2017-11-01 15:30:28 -0700
+++ src/uqm/starbase.h	2017-11-01 15:31:05 -0700
@@ -20,6 +20,10 @@
 #define _STARBASE_H
 
 #include "menustat.h"
+#include "globdata.h"
+#define COMM_INTERNAL
+#include "commanim.h"
+#include "libs/mathlib.h"
 
 enum
 {
@@ -30,6 +34,7 @@ enum
 };
 typedef BYTE STARBASE_STATE;
 
+extern SBDATA StarbaseData;
 
 extern void InstallBombAtEarth (void);
 extern void VisitStarBase (void);
diff -ruNp src.orig/uqm/starcon.c src/uqm/starcon.c
--- src.orig/uqm/starcon.c	2017-11-01 15:30:28 -0700
+++ src/uqm/starcon.c	2017-11-01 15:31:05 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: Game ends upon finding black orb & new precursor ship and running the corresponding cutscene.
+
 #include <stdlib.h>
 
 #include "comm.h"
@@ -177,16 +179,15 @@ while (--ac > 0)
 	if (!LoadKernel (0,0))
 	{
 		log_add (log_Fatal, "\n  *** FATAL ERROR: Could not load basic content ***\n\nUQM requires at least the base content pack to run properly.");
-		log_add (log_Fatal, "This file is typically called uqm-%d.%d.0-content.uqm.  UQM was expecting", UQM_MAJOR_VERSION, UQM_MINOR_VERSION);
-		log_add (log_Fatal, "it in the %s/packages directory.", baseContentPath);
+		log_add (log_Fatal, "This file is typically called uqm-%d.%d.0.uqm.  UQM was expecting it", P6014_MAJOR_VERSION, P6014_MINOR_VERSION);
+		log_add (log_Fatal, "in the %s/packages directory.", baseContentPath);
 		log_add (log_Fatal, "Either your installation did not install the content pack at all, or it\ninstalled it in a different directory.\n\nFix your installation and rerun UQM.\n\n  *******************\n");
-		log_showBox (true, true);
-
-		MainExited = TRUE;
-		return EXIT_FAILURE;
+		exit (EXIT_FAILURE);
 	}
 	log_add (log_Info, "We've loaded the Kernel");
 
+	Logo ();
+	
 	GLOBAL (CurrentActivity) = 0;
 	// show splash and init the kernel in the meantime
 	SplashScreen (BackgroundInitKernel);
@@ -199,6 +200,7 @@ while (--ac > 0)
 			log_add (log_Fatal, "Could not set player input.");
 			explode ();  // Does not return;
 		}
+		
 		InitGameStructures ();
 		InitGameClock ();
 		AddInitialGameEvents();
@@ -224,7 +226,7 @@ while (--ac > 0)
 					// not going into talking pet conversation
 			else if (GLOBAL (CurrentActivity) & CHECK_LOAD)
 				GLOBAL (CurrentActivity) = NextActivity;
-
+			
 			if ((GLOBAL (CurrentActivity) & START_ENCOUNTER)
 					|| GET_GAME_STATE (CHMMR_BOMB_STATE) == 2)
 			{
@@ -277,9 +279,9 @@ while (--ac > 0)
 			LastActivity = GLOBAL (CurrentActivity);
 
 			if (!(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD))
-					&& (LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE
-							// if died for some reason
-					|| GLOBAL_SIS (CrewEnlisted) == (COUNT)~0))
+					&& (LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE 
+						|| LOBYTE (GLOBAL (CurrentActivity)) == BLACK_ORB_CUTSCENE 	// JMS: End demo at cutscene upon finding black orb.
+						|| GLOBAL_SIS (CrewEnlisted) == (COUNT)~0)) // if died for some reason
 			{
 				if (GET_GAME_STATE (KOHR_AH_KILLED_ALL))
 					InitCommunication (BLACKURQ_CONVERSATION);
@@ -301,7 +303,6 @@ while (--ac > 0)
 	FreeMasterShipList ();
 	FreeKernel ();
 
-	log_showBox (false, false);
 	MainExited = TRUE;
 
 	(void) threadArg;  /* Satisfying compiler (unused parameter) */
diff -ruNp src.orig/uqm/starmap.c src/uqm/starmap.c
--- src.orig/uqm/starmap.c	2017-11-01 15:30:28 -0700
+++ src/uqm/starmap.c	2017-11-01 15:31:05 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2009: Star finding business in Orz space (findstar function)
+
 #include "encount.h"
 #include "gamestr.h"
 #include "globdata.h"
@@ -34,7 +36,15 @@ FindStar (STAR_DESC *LastSDPtr, POINT *p
 	SIZE lo, hi;
 	STAR_DESC *BaseSDPtr;
 
-	if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
+	if (GET_GAME_STATE (ORZ_SPACE_SIDE) > 1)
+	{
+#define NUM_HYPER_VORTICES 15
+#define NUM_ORZ_VORTICES 1
+		BaseSDPtr = &star_array[NUM_SOLAR_SYSTEMS + 1 + NUM_HYPER_VORTICES + 1 + 1];
+		hi = (NUM_ORZ_VORTICES + 1) - 1;
+	} // JMS ENDS
+	
+	else if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
 	{
 		BaseSDPtr = star_array;
 		hi = NUM_SOLAR_SYSTEMS - 1;
@@ -123,4 +133,3 @@ GetClusterName (const STAR_DESC *pSD, UN
 			;
 	}
 }
-
diff -ruNp src.orig/uqm/state.c src/uqm/state.c
--- src.orig/uqm/state.c	2017-11-01 15:30:28 -0700
+++ src/uqm/state.c	2017-11-01 15:31:05 -0700
@@ -233,16 +233,24 @@ UninitPlanetInfo (void)
 }
 
 #define OFFSET_SIZE       (sizeof (DWORD))
-#define SCAN_RECORD_SIZE  (sizeof (DWORD) * NUM_SCAN_TYPES)
+
+// JMS: Increased the size of scan record to house partially scavenged minerals.
+#define SCAN_RECORD_SIZE  ((sizeof (DWORD) * NUM_SCAN_TYPES) + (sizeof(BYTE) * NUM_SCAN_TYPES * 32))
 
 void
 GetPlanetInfo (void)
 {
 	void *fp;
-
+	COUNT k,l;
+	
 	pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[BIOLOGICAL_SCAN] = 0;
 	pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[MINERAL_SCAN] = 0;
 	pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN] = 0;
+	
+	// JMS: Init also the partially scavenged mineral deposit values.
+	for (l = MINERAL_SCAN; l < NUM_SCAN_TYPES; l++)
+		for (k = 0; k < 32; k++)
+			pSolarSysState->SysInfo.PlanetInfo.PartiallyScavengedList[l][k] = 0;
 
 	fp = OpenStateFile (STARINFO_FILE, "rb");
 	if (fp)
@@ -251,13 +259,11 @@ GetPlanetInfo (void)
 		DWORD offset;
 
 		star_index = (COUNT)(CurStarDescPtr - star_array);
-		planet_index = (COUNT)(pSolarSysState->pBaseDesc->pPrevDesc
-				- pSolarSysState->PlanetDesc);
+		planet_index = (COUNT)(pSolarSysState->pBaseDesc->pPrevDesc - pSolarSysState->PlanetDesc);
 		if (pSolarSysState->pOrbitalDesc->pPrevDesc == pSolarSysState->SunDesc)
 			moon_index = 0;
 		else
-			moon_index = (COUNT)(pSolarSysState->pOrbitalDesc
-					- pSolarSysState->MoonDesc + 1);
+			moon_index = (COUNT)(pSolarSysState->pOrbitalDesc - pSolarSysState->MoonDesc + 1);
 
 		SeekStateFile (fp, star_index * OFFSET_SIZE, SEEK_SET);
 		sread_32 (fp, &offset);
@@ -268,15 +274,22 @@ GetPlanetInfo (void)
 
 			// Skip scan records for all preceeding planets to the one we need
 			for (i = 0; i < planet_index; ++i)
-				offset += (pSolarSysState->PlanetDesc[i].NumPlanets + 1) *
-						SCAN_RECORD_SIZE;
+				offset += (pSolarSysState->PlanetDesc[i].NumPlanets + 1) * SCAN_RECORD_SIZE;
 				
 			// Skip scan records for all preceeding moons to the one we need
 			offset += moon_index * SCAN_RECORD_SIZE;
 
 			SeekStateFile (fp, offset, SEEK_SET);
-			sread_a32 (fp, pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask,
-					NUM_SCAN_TYPES);
+			sread_a32 (fp, pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask, NUM_SCAN_TYPES);
+			
+			{
+				BYTE *ar = &(pSolarSysState->SysInfo.PlanetInfo.PartiallyScavengedList[0][0]); // JMS
+				
+				// JMS: Read which mineral deposits are partially retrieved (and how much).
+				for (l = MINERAL_SCAN; l < NUM_SCAN_TYPES; l++)
+					for (k = 0; k < 32; k++, ar++)
+						sread_8 (fp, ar);
+			}
 		}
 
 		CloseStateFile (fp);
@@ -291,7 +304,7 @@ PutPlanetInfo (void)
 	fp = OpenStateFile (STARINFO_FILE, "r+b");
 	if (fp)
 	{
-		COUNT i;
+		COUNT i, k, l;
 		COUNT star_index, planet_index, moon_index;
 		DWORD offset;
 
@@ -313,6 +326,12 @@ PutPlanetInfo (void)
 			{
 				0, 0, 0,
 			};
+			
+			// JMS: Init also the partially scavenged mineral deposit values.
+			BYTE PartiallyScavengedList[NUM_SCAN_TYPES][32];
+			for (l = MINERAL_SCAN; l < NUM_SCAN_TYPES; l++)
+				for (k = 0; k < 32; k++)
+					PartiallyScavengedList[l][k] = 0;
 
 			offset = LengthStateFile (fp);
 
@@ -325,11 +344,27 @@ PutPlanetInfo (void)
 			for (i = 0; i < pSolarSysState->SunDesc[0].NumPlanets; ++i)
 			{
 				COUNT j;
+				BYTE *ar = &(PartiallyScavengedList[0][0]); // JMS
 
 				swrite_a32 (fp, ScanRetrieveMask, NUM_SCAN_TYPES);
+			
+				// JMS: Also init with zeroes the list of partially scavenged mineral amounts.
+				for (l = MINERAL_SCAN; l < NUM_SCAN_TYPES; l++)
+					for (k = 0; k < 32; k++, ar++)
+						swrite_8 (fp, *ar);
+			
 				// init moons
 				for (j = 0; j < pSolarSysState->PlanetDesc[i].NumPlanets; ++j)
+				{
+					BYTE *ar = &(PartiallyScavengedList[0][0]); // JMS
+			
 					swrite_a32 (fp, ScanRetrieveMask, NUM_SCAN_TYPES);
+	
+					// JMS: Ditto for the moons.
+					for (l = MINERAL_SCAN; l < NUM_SCAN_TYPES; l++)
+						for (k = 0; k < 32; k++, ar++)
+							swrite_8 (fp, *ar);
+				}
 			}
 		}
 
@@ -337,14 +372,25 @@ PutPlanetInfo (void)
 		for (i = 0; i < planet_index; ++i)
 			offset += (pSolarSysState->PlanetDesc[i].NumPlanets + 1) *
 					SCAN_RECORD_SIZE;
-				
+			
 		// Skip scan records for all preceeding moons to the one we need
 		offset += moon_index * SCAN_RECORD_SIZE;
 
 		SeekStateFile (fp, offset, SEEK_SET);
+	
+		// Store which mineral deposits we have already retrieved.
 		swrite_a32 (fp, pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask,
 				NUM_SCAN_TYPES);
-
+	
+		{
+			BYTE *ar = &(pSolarSysState->SysInfo.PlanetInfo.PartiallyScavengedList[0][0]); // JMS
+			
+			// JMS: Store which mineral deposits are partially retrieved (and how much).
+			for (l = MINERAL_SCAN; l < NUM_SCAN_TYPES; l++)
+				for (k = 0; k < 32; k++, ar++)
+					swrite_8 (fp, *ar);
+		}
+		
 		CloseStateFile (fp);
 	}
 }
diff -ruNp src.orig/uqm/status.c src/uqm/status.c
--- src.orig/uqm/status.c	2017-11-01 15:30:28 -0700
+++ src/uqm/status.c	2017-11-01 15:31:05 -0700
@@ -16,6 +16,10 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010 - Enable Down key in melee (comment tag JMS_KEYS) (moved to races.h)
+
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
 #include "status.h"
 #include "colors.h"
 #include "globdata.h"
@@ -44,8 +48,7 @@ InitStatusOffsets (void)
 
 static void
 CaptainsWindow (CAPTAIN_STUFF *CSPtr, COORD y,
-		STATUS_FLAGS delta_status_flags, STATUS_FLAGS cur_status_flags,
-		COUNT Pass)
+		STATUS_FLAGS delta_status_flags, STATUS_FLAGS cur_status_flags, COUNT Pass)
 {
 	STAMP Stamp;
 
@@ -137,24 +140,23 @@ DrawBattleCrewAmount (SHIP_INFO *ShipInf
 	TEXT t;
 	UNICODE buf[40];
 
-	t.baseline.x = BATTLE_CREW_X + 2;
+	t.baseline.x = BATTLE_CREW_X + RES_STAT_SCALE(2) - RES_CASE(0,0,2); // JMS_GFX
 	if (optWhichMenu == OPT_PC)
-			t.baseline.x -= 8;
-	t.baseline.y = BATTLE_CREW_Y + y_offs;
+			t.baseline.x -= RES_STAT_SCALE(8); // JMS_GFX
+	t.baseline.y = BATTLE_CREW_Y + y_offs; // JMS_GFX
 	t.align = ALIGN_LEFT;
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 
 	r.corner.x = t.baseline.x;
-	r.corner.y = t.baseline.y - 5;
-	r.extent.width = 6 * MAX_CREW_DIGITS + 6;
-	r.extent.height = 5;
+	r.corner.y = t.baseline.y - (5 << RESOLUTION_FACTOR); // JMS_GFX
+	r.extent.width = 6 * MAX_CREW_DIGITS + (6 << RESOLUTION_FACTOR) + RESOLUTION_FACTOR; // JMS_GFX
+	r.extent.height = (5 << RESOLUTION_FACTOR) + RES_CASE(0,2,3); // JMS_GFX
 
 	sprintf (buf, "%u", ShipInfoPtr->crew_level);
 	SetContextFont (StarConFont);
 
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
+	SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
 	DrawFilledRectangle (&r);
 	SetContextForeGroundColor (BLACK_COLOR);
 	font_DrawText (&t);
@@ -188,19 +190,18 @@ DrawCaptainsWindow (STARSHIP *StarShipPt
 
 	BatchGraphics ();
 	
+	// Grey area under and around captain's window.
 	assert (StarShipPtr->playerNr >= 0);
 	y_offs = status_y_offsets[StarShipPtr->playerNr];
-
-	r.corner.x = CAPTAIN_XOFFS - 2;
+	r.corner.x = CAPTAIN_XOFFS - RES_STAT_SCALE(4); // JMS_GFX
 	r.corner.y = y_offs + SHIP_INFO_HEIGHT;
-	r.extent.width = STATUS_WIDTH - CAPTAIN_XOFFS;
-	r.extent.height = SHIP_STATUS_HEIGHT - CAPTAIN_YOFFS + 2;
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
+	r.extent.width = STATUS_WIDTH - 2;
+	r.extent.height = SHIP_STATUS_HEIGHT - CAPTAIN_YOFFS + (4 << RESOLUTION_FACTOR); // JMS_GFX
+	SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
 	DrawFilledRectangle (&r);
 
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
+	// Left border of the status panel.
+	SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
 	r.corner.x = 1;
 	r.corner.y = y_offs + SHIP_INFO_HEIGHT;
 	r.extent.width = 1;
@@ -210,8 +211,8 @@ DrawCaptainsWindow (STARSHIP *StarShipPt
 	++r.extent.height;
 	DrawFilledRectangle (&r);
 
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
+	// Lower and right border of the status panel.
+	SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
 	r.corner.x = STATUS_WIDTH - 1;
 	r.corner.y = y_offs + SHIP_INFO_HEIGHT;
 	r.extent.width = 1;
@@ -231,30 +232,30 @@ DrawCaptainsWindow (STARSHIP *StarShipPt
 
 	y = y_offs + CAPTAIN_YOFFS;
 
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
-	r.corner.x = 59;
+	// Darker grey rectangle at bottom and right of captain's window
+	SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
+	r.corner.x = CAPTAIN_WIDTH + CAPTAIN_XOFFS; // JMS_GFX
 	r.corner.y = y;
 	r.extent.width = 1;
-	r.extent.height = 30;
+	r.extent.height = CAPTAIN_HEIGHT;
 	DrawFilledRectangle (&r);
-	r.corner.x = 3;
-	r.corner.y += 30;
-	r.extent.width = 57;
+	r.corner.x = CAPTAIN_XOFFS - 1; // JMS_GFX
+	r.corner.y += CAPTAIN_HEIGHT;
+	r.extent.width = CAPTAIN_WIDTH + 2;
 	r.extent.height = 1;
 	DrawFilledRectangle (&r);
 
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
-	r.corner.x = 3;
-	r.extent.width = 57;
+	// Light grey rectangle at top and left of captains window
+	SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
+	r.corner.x = CAPTAIN_XOFFS - 1; // JMS_GFX
+	r.extent.width = CAPTAIN_WIDTH + 2;
 	r.corner.y = y - 1;
 	r.extent.height = 1;
 	DrawFilledRectangle (&r);
-	r.corner.x = 3;
+	r.corner.x = CAPTAIN_XOFFS - 1; // JMS_GFX
 	r.extent.width = 1;
 	r.corner.y = y;
-	r.extent.height = 30;
+	r.extent.height = CAPTAIN_HEIGHT;
 	DrawFilledRectangle (&r);
 
 	s.frame = RDPtr->ship_data.captain_control.background;
@@ -268,12 +269,11 @@ DrawCaptainsWindow (STARSHIP *StarShipPt
 		TEXT t;
 
 		t.baseline.x = STATUS_WIDTH >> 1;
-		t.baseline.y = y + 6;
+		t.baseline.y = y + RES_CASE(6,-22,-44); // JMS_GFX
 		t.align = ALIGN_CENTER;
 		t.pStr = GLOBAL_SIS (CommanderName);
 		t.CharCount = (COUNT)~0;
-		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x00, 0x14, 0x00), 0x02));
+		SetContextForeGroundColor (RES_CASE(BUILD_COLOR (MAKE_RGB15 (0x00, 0x14, 0x00), 0x02), BLACK_COLOR, BLACK_COLOR));
 		SetContextFont (TinyFont);
 		font_DrawText (&t);
 	}
@@ -387,7 +387,7 @@ PreProcessStatus (ELEMENT *ShipPtr)
 		old_status_flags ^= cur_status_flags;
 
 		CSPtr = &StarShipPtr->RaceDescPtr->ship_data.captain_control;
-		old_status_flags &= (LEFT | RIGHT | THRUST | WEAPON | SPECIAL);
+		old_status_flags &= (LEFT | RIGHT | THRUST | WEAPON | SPECIAL | DOWN); // JMS_KEYS
 		if (old_status_flags)
 		{
 			assert (StarShipPtr->playerNr >= 0);
@@ -417,11 +417,11 @@ PostProcessStatus (ELEMENT *ShipPtr)
 		if (ShipPtr->crew_level == 0)
 		{
 			StarShipPtr->cur_status_flags &=
-					~(LEFT | RIGHT | THRUST | WEAPON | SPECIAL);
+					~(LEFT | RIGHT | THRUST | WEAPON | SPECIAL | DOWN); // JMS_KEYS
 
 			if (StarShipPtr->RaceDescPtr->ship_info.crew_level == 0)
 			{
-				BYTE i;
+				BYTE i, j;
 				Color c;
 				RECT r;
 
@@ -469,49 +469,58 @@ PostProcessStatus (ELEMENT *ShipPtr)
 						};
 
 						c = flash_tab1[i];
-						r.corner.x = CAPTAIN_XOFFS + i;
-						r.corner.y = y + CAPTAIN_YOFFS + i;
-						r.extent.width = CAPTAIN_WIDTH - (i << 1);
-						r.extent.height = CAPTAIN_HEIGHT - (i << 1);
+						
+						// JMS_GFX
+						r.corner.x = CAPTAIN_XOFFS + RES_STAT_SCALE(i);
+						r.corner.y = y + CAPTAIN_YOFFS + RES_STAT_SCALE(i);
+						r.extent.width = CAPTAIN_WIDTH - RES_STAT_SCALE((i << 1));
+						r.extent.height = CAPTAIN_HEIGHT - RES_STAT_SCALE((i << 1));
 						if (r.extent.height == 2)
 							++r.extent.height;
-						DrawRectangle (&r);
-						++r.corner.x;
-						++r.corner.y;
-						r.extent.width -= 2;
-						r.extent.height -= 2;
+						
+						// JMS_GFX
+						for (j=0 ; j < RES_STAT_SCALE(1); j++)
+						{
+							DrawRectangle (&r);
+							++r.corner.x;
+							++r.corner.y;
+							r.extent.width -= 2;
+							r.extent.height -= 2;
+						}
 					}
 					else if ((i -= 15) <= 4)
 					{
-						r.corner.y = y + (CAPTAIN_YOFFS + 15);
-						r.extent.width = i + 1;
+						r.corner.y = y + (CAPTAIN_YOFFS + RES_STAT_SCALE(15)); // JMS_GFX
+						r.extent.width = RES_STAT_SCALE(i + 1); // JMS_GFX
 						r.extent.height = 1;
+						
+						// JMS_GFX
 						switch (i)
 						{
 							case 0:
-								r.corner.x = CAPTAIN_XOFFS + 15;
-								i = CAPTAIN_WIDTH - ((15 + 1) << 1);
+								r.corner.x = CAPTAIN_XOFFS + RES_STAT_SCALE(15);
+								i = CAPTAIN_WIDTH - RES_STAT_SCALE((15 + 1) << 1);
 								c = BUILD_COLOR (MAKE_RGB15 (0x13, 0x00, 0x00), 0x2C);
 								break;
 							case 1:
-								r.corner.x = CAPTAIN_XOFFS + 16;
-								i = CAPTAIN_WIDTH - ((17 + 1) << 1);
+								r.corner.x = CAPTAIN_XOFFS + RES_STAT_SCALE(16);
+								i = CAPTAIN_WIDTH - RES_STAT_SCALE((17 + 1) << 1);
 								c = BUILD_COLOR (MAKE_RGB15 (0x07, 0x00, 0x00), 0x2F);
 								break;
 							case 2:
-								r.corner.x = CAPTAIN_XOFFS + 18;
-								i = CAPTAIN_WIDTH - ((20 + 1) << 1);
+								r.corner.x = CAPTAIN_XOFFS + RES_STAT_SCALE(18);
+								i = CAPTAIN_WIDTH - RES_STAT_SCALE((20 + 1) << 1);
 								c = BUILD_COLOR (MAKE_RGB15 (0x1B, 0x00, 0x00), 0x2A);
 								break;
 							case 3:
-								r.corner.x = CAPTAIN_XOFFS + 21;
-								i = CAPTAIN_WIDTH - ((24 + 1) << 1);
+								r.corner.x = CAPTAIN_XOFFS + RES_STAT_SCALE(21);
+								i = CAPTAIN_WIDTH - RES_STAT_SCALE((24 + 1) << 1);
 								c = BUILD_COLOR (MAKE_RGB15 (0x1F, 0x00, 0x00), 0x29);
 								break;
 							case 4:
-								r.corner.x = CAPTAIN_XOFFS + 25;
-								i = 1;
-								r.extent.width = 2;
+								r.corner.x = CAPTAIN_XOFFS + RES_STAT_SCALE(25);
+								i = RES_STAT_SCALE(1);
+								r.extent.width = RES_STAT_SCALE(2);
 								c = BUILD_COLOR (MAKE_RGB15 (0x1F, 0x50, 0x05), 0x28);
 								break;
 							default:
@@ -540,10 +549,8 @@ PostProcessStatus (ELEMENT *ShipPtr)
 
 							c = flash_tab2[i];
 						}
-						r.corner.x = CAPTAIN_XOFFS
-								+ (CAPTAIN_WIDTH >> 1);
-						r.corner.y = y + CAPTAIN_YOFFS
-								 + ((CAPTAIN_HEIGHT + 1) >> 1);
+						r.corner.x = CAPTAIN_XOFFS + (CAPTAIN_WIDTH >> 1);
+						r.corner.y = y + CAPTAIN_YOFFS + ((CAPTAIN_HEIGHT + 1) >> 1);
 						r.extent.width = 1;
 						r.extent.height = 1;
 					}
@@ -555,7 +562,7 @@ PostProcessStatus (ELEMENT *ShipPtr)
 
 		old_status_flags = StarShipPtr->old_status_flags;
 		old_status_flags = (old_status_flags ^ cur_status_flags) &
-				(LEFT | RIGHT | THRUST | WEAPON | SPECIAL | LOW_ON_ENERGY);
+				(LEFT | RIGHT | THRUST | WEAPON | SPECIAL | LOW_ON_ENERGY | DOWN); // JMS_KEYS
 
 		if (old_status_flags)
 		{
@@ -567,7 +574,7 @@ PostProcessStatus (ELEMENT *ShipPtr)
 					DrawCrewFuelString (y, -1);
 			}
 
-			old_status_flags &= (LEFT | RIGHT | THRUST | WEAPON | SPECIAL);
+			old_status_flags &= (LEFT | RIGHT | THRUST | WEAPON | SPECIAL | DOWN); // JMS_KEYS
 			if (old_status_flags)
 			{
 				CaptainsWindow (
diff -ruNp src.orig/uqm/status.h src/uqm/status.h
--- src.orig/uqm/status.h	2017-11-01 15:30:28 -0700
+++ src/uqm/status.h	2017-11-01 15:31:05 -0700
@@ -22,36 +22,35 @@
 #include "races.h"
 #include "libs/compiler.h"
 
-#define CREW_XOFFS 4
-#define ENERGY_XOFFS 52
-#define GAUGE_YOFFS (SHIP_INFO_HEIGHT - 10)
-#define UNIT_WIDTH 2
-#define UNIT_HEIGHT 1
-#define STAT_WIDTH (1 + UNIT_WIDTH + 1 + UNIT_WIDTH + 1)
-
-#define SHIP_INFO_HEIGHT 65
-#define CAPTAIN_XOFFS 4
-#define CAPTAIN_YOFFS (SHIP_INFO_HEIGHT + 4)
-#define CAPTAIN_WIDTH 55
-#define CAPTAIN_HEIGHT 30
+#define CREW_XOFFS RES_STAT_SCALE(4) // JMS_GFX
+#define ENERGY_XOFFS (RES_STAT_SCALE(52) + (3 * RESOLUTION_FACTOR) + (RESOLUTION_FACTOR / 2)) // JMS_GFX
+#define GAUGE_YOFFS (SHIP_INFO_HEIGHT - (10 << RESOLUTION_FACTOR) + 6 * RESOLUTION_FACTOR) // JMS_GFX
+#define UNIT_WIDTH RES_STAT_SCALE(2)
+#define UNIT_HEIGHT (RESOLUTION_FACTOR > 0 ? 2 :1)
+#define STAT_WIDTH (1 + UNIT_WIDTH + 1 + UNIT_WIDTH + 1) // JMS_GFX
+
+#define SHIP_INFO_HEIGHT (65 << RESOLUTION_FACTOR) // JMS_GFX
+#define CAPTAIN_WIDTH RES_STAT_SCALE(55) // JMS_GFX
+#define CAPTAIN_HEIGHT RES_STAT_SCALE(30) // JMS_GFX
+#define CAPTAIN_XOFFS ((STATUS_WIDTH - CAPTAIN_WIDTH) >> 1) // JMS_GFX
+#define CAPTAIN_YOFFS (SHIP_INFO_HEIGHT + (4 << RESOLUTION_FACTOR)) // JMS_GFX
 #define SHIP_STATUS_HEIGHT (STATUS_HEIGHT >> 1)
 #define BAD_GUY_YOFFS 0
 #define GOOD_GUY_YOFFS SHIP_STATUS_HEIGHT
-#define STARCON_TEXT_HEIGHT 7
-#define TINY_TEXT_HEIGHT 9
-
-#define BATTLE_CREW_X 10
-#define BATTLE_CREW_Y (64 - SAFE_Y)
+#define STARCON_TEXT_HEIGHT (7 << RESOLUTION_FACTOR) // JMS_GFX
+#define TINY_TEXT_HEIGHT (9 << RESOLUTION_FACTOR) // JMS_GFX
+#define BATTLE_CREW_X RES_STAT_SCALE(10)
+#define BATTLE_CREW_Y ((64 - SAFE_Y) << RESOLUTION_FACTOR)
 
 extern COORD status_y_offsets[];
 
 extern void InitStatusOffsets (void);
 
 extern void DrawCrewFuelString (COORD y, SIZE state);
-extern void ClearShipStatus (COORD y);
-extern void OutlineShipStatus (COORD y);
+extern void ClearShipStatus (COORD y, COORD w, BOOLEAN inMeleeMenu);
+extern void OutlineShipStatus (COORD y, COORD w, BOOLEAN inMeleeMenu); // JMS: now is needed elsewhere
 extern void InitShipStatus (SHIP_INFO *ShipInfoPtr, STARSHIP *StarShipPtr,
-		RECT *pClipRect);
+		RECT *pClipRect, BOOLEAN inMeleeMenu);
 			// StarShipPtr or pClipRect can be NULL
 extern void DeltaStatistics (SHIP_INFO *ShipInfoPtr, COORD y_offs,
 		SIZE crew_delta, SIZE energy_delta);
diff -ruNp src.orig/uqm/supermelee/buildpick.c src/uqm/supermelee/buildpick.c
--- src.orig/uqm/supermelee/buildpick.c	2017-11-01 15:30:28 -0700
+++ src/uqm/supermelee/buildpick.c	2017-11-01 15:31:05 -0700
@@ -60,6 +60,8 @@ DestroyBuildPickFrame (void)
 	BuildPickFrame = 0;
 }
 
+#define NUM_OF_ALL_SHIPS (LAST_MELEE_ID - ARILOU_ID) // JMS
+
 // Draw a ship icon in the ship selection popup.
 void
 DrawPickIcon (MeleeShip ship, bool DrawErase)
@@ -69,10 +71,10 @@ DrawPickIcon (MeleeShip ship, bool DrawE
 
 	GetFrameRect (BuildPickFrame, &r);
 
-	s.origin.x = r.corner.x + 20 + (ship % NUM_PICK_COLS) * 18;
-	s.origin.y = r.corner.y +  5 + (ship / NUM_PICK_COLS) * 18;
+	s.origin.x = r.corner.x + (20 << RESOLUTION_FACTOR) + (ship % NUM_PICK_COLS) * (18 << RESOLUTION_FACTOR) - RES_CASE(0,0,2); // JMS_GFX
+	s.origin.y = r.corner.y + (5 << RESOLUTION_FACTOR) + (ship / NUM_PICK_COLS) * (18 << RESOLUTION_FACTOR); // JMS_GFX
 	s.frame = GetShipIconsFromIndex (ship);
-	if (DrawErase)
+	if (DrawErase && s.frame && ship != NUM_OF_ALL_SHIPS) // JMS: Don't draw the last ship (It should be slykohr!!) since it is forbidden to be selected anyway.
 	{	// draw icon
 		DrawStamp (&s);
 	}
@@ -99,13 +101,13 @@ DrawPickFrame (MELEE_STATE *pMS)
 
 	s.frame = SetAbsFrameIndex (BuildPickFrame, 0);
 	GetFrameRect (s.frame, &r);
-	r.corner.x = -(ship_r.corner.x
-			+ ((ship_r.extent.width - r.extent.width) >> 1));
+	r.corner.x = -(ship_r.corner.x + ((ship_r.extent.width - r.extent.width) >> 1));
+	
 	if (pMS->side)
 		r.corner.y = -ship_r.corner.y;
 	else
-		r.corner.y = -(ship_r.corner.y
-				+ (ship_r.extent.height - r.extent.height));
+		r.corner.y = -(ship_r.corner.y + (ship_r.extent.height - r.extent.height));
+	
 	SetFrameHot (s.frame, MAKE_HOT_SPOT (r.corner.x, r.corner.y));
 	s.origin.x = 0;
 	s.origin.y = 0;
@@ -161,12 +163,20 @@ DoPickShip (MELEE_STATE *pMS)
 			if (newSelectedShip % NUM_PICK_COLS == 0)
 				newSelectedShip += NUM_PICK_COLS;
 			--newSelectedShip;
+			
+			// JMS: Guard against going over ship list boundaries
+			if (newSelectedShip >= NUM_OF_ALL_SHIPS)
+				newSelectedShip = NUM_OF_ALL_SHIPS - 1;
 		}
 		else if (PulsedInputState.menu[KEY_MENU_RIGHT])
 		{
 			++newSelectedShip;
 			if (newSelectedShip % NUM_PICK_COLS == 0)
 				newSelectedShip -= NUM_PICK_COLS;
+			
+			// JMS: Guard against going over ship list boundaries
+			if (newSelectedShip >= NUM_OF_ALL_SHIPS)
+				newSelectedShip = (NUM_PICK_ROWS - 1) * NUM_PICK_COLS;
 		}
 		
 		if (PulsedInputState.menu[KEY_MENU_UP])
@@ -175,6 +185,10 @@ DoPickShip (MELEE_STATE *pMS)
 				newSelectedShip -= NUM_PICK_COLS;
 			else
 				newSelectedShip += NUM_PICK_COLS * (NUM_PICK_ROWS - 1);
+		
+			// JMS: Guard against going over ship list boundaries
+			if (newSelectedShip >= NUM_OF_ALL_SHIPS)
+				newSelectedShip -= NUM_PICK_COLS;
 		}
 		else if (PulsedInputState.menu[KEY_MENU_DOWN])
 		{
@@ -182,6 +196,10 @@ DoPickShip (MELEE_STATE *pMS)
 				newSelectedShip += NUM_PICK_COLS;
 			else
 				newSelectedShip -= NUM_PICK_COLS * (NUM_PICK_ROWS - 1);
+			
+			// JMS: Guard against going over ship list boundaries
+			if (newSelectedShip >= NUM_OF_ALL_SHIPS)
+				newSelectedShip -= NUM_PICK_COLS * (NUM_PICK_ROWS - 1);
 		}
 
 		if (newSelectedShip != pMS->currentShip)
diff -ruNp src.orig/uqm/supermelee/loadmele.c src/uqm/supermelee/loadmele.c
--- src.orig/uqm/supermelee/loadmele.c	2017-11-01 15:30:28 -0700
+++ src/uqm/supermelee/loadmele.c	2017-11-01 15:31:05 -0700
@@ -18,6 +18,8 @@
 
 // This file handles loading of teams, but the UI and the actual loading.
 
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
 #define MELEESETUP_INTERNAL
 #include "melee.h"
 
@@ -41,9 +43,9 @@
 		BUILD_COLOR (MAKE_RGB15 (0x17, 0x18, 0x1D), 0x00)
 
 
-#define LOAD_MELEE_BOX_WIDTH 34
-#define LOAD_MELEE_BOX_HEIGHT 34
-#define LOAD_MELEE_BOX_SPACE 1
+#define LOAD_MELEE_BOX_WIDTH (34 << RESOLUTION_FACTOR) // JMS_GFX
+#define LOAD_MELEE_BOX_HEIGHT (34 << RESOLUTION_FACTOR) // JMS_GFX
+#define LOAD_MELEE_BOX_SPACE (1 << RESOLUTION_FACTOR) // JMS_GFX
 
 
 static void DrawFileStrings (MELEE_STATE *pMS);
@@ -176,8 +178,7 @@ DrawFileString (const MeleeTeam *team, c
 
 		sprintf (buf, "%u", MeleeTeam_getValue (team));
 		Text.baseline = *origin;
-		Text.baseline.x += NUM_MELEE_COLUMNS *
-				(LOAD_MELEE_BOX_WIDTH + LOAD_MELEE_BOX_SPACE) - 1;
+		Text.baseline.x += NUM_MELEE_COLUMNS * (LOAD_MELEE_BOX_WIDTH + LOAD_MELEE_BOX_SPACE) - 1 - 2 * RESOLUTION_FACTOR;
 		Text.align = ALIGN_RIGHT;
 		Text.pStr = buf;
 		Text.CharCount = (COUNT)~0;
@@ -190,8 +191,8 @@ DrawFileString (const MeleeTeam *team, c
 		STAMP s;
 		FleetShipIndex slotI;
 
-		s.origin.x = origin->x + 1;
-		s.origin.y = origin->y + 4;
+		s.origin.x = origin->x + (1 << RESOLUTION_FACTOR); // JMS_GFX
+		s.origin.y = origin->y + (4 << RESOLUTION_FACTOR); // JMS_GFX
 		for (slotI = 0; slotI < MELEE_FLEET_SIZE; slotI++)
 		{
 			BYTE StarShip;
@@ -201,7 +202,7 @@ DrawFileString (const MeleeTeam *team, c
 			{
 				s.frame = GetShipIconsFromIndex (StarShip);
 				DrawStamp (&s);
-				s.origin.x += 17;
+				s.origin.x += (17 << RESOLUTION_FACTOR); // JMS_GFX
 			}
 		}
 	}
@@ -230,9 +231,9 @@ FillFileView (MELEE_STATE *pMS)
 	return true;
 }
 
-#define FILE_STRING_ORIGIN_X  5
-#define FILE_STRING_ORIGIN_Y  34
-#define ENTRY_HEIGHT 32
+#define FILE_STRING_ORIGIN_X (5 << RESOLUTION_FACTOR) // JMS_GFX
+#define FILE_STRING_ORIGIN_Y  ((34 << RESOLUTION_FACTOR) - 2 * RESOLUTION_FACTOR) // JMS_GFX
+#define ENTRY_HEIGHT (32 << RESOLUTION_FACTOR) // JMS_GFX
 
 static void
 SelectFileString (MELEE_STATE *pMS, bool hilite)
@@ -834,5 +835,3 @@ UninitMeleeLoadState (MELEE_STATE *pMS)
 	if (pMS->load.entryIndices != NULL)
 		HFree (pMS->load.entryIndices);
 }
-
-
diff -ruNp src.orig/uqm/supermelee/melee.c src/uqm/supermelee/melee.c
--- src.orig/uqm/supermelee/melee.c	2017-11-01 15:30:28 -0700
+++ src/uqm/supermelee/melee.c	2017-11-01 15:31:05 -0700
@@ -16,8 +16,16 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-#include "melee.h"
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
+// JMS: Had to include some stuff that actually shouldn't be here in order to get the
+// melee team saving&loading after restart to work.
+#define MELEESETUP_INTERNAL
+#define MELEETEAM_INTERNAL
+#include "meleesetup.h"
 
+#include "melee.h"
+ 
 #include "options.h"
 #include "buildpick.h"
 #include "meleeship.h"
@@ -44,7 +52,7 @@
 		// for DrawShadowedBox()
 #	include "../cnctdlg.h"
 		// for MeleeConnectDialog()
-#endif  /* defined (NETPLAY) */
+#endif
 #include "../resinst.h"
 #include "../settings.h"
 #include "../setup.h"
@@ -61,6 +69,7 @@
 #include "libs/uio.h"
 
 
+
 #include <assert.h>
 #include <string.h>
 
@@ -96,28 +105,27 @@ enum
 #define TOP_ENTRY CONTROLS_TOP
 #endif
 
-#define MELEE_X_OFFS 2
-#define MELEE_Y_OFFS 21
-#define MELEE_BOX_WIDTH 34
-#define MELEE_BOX_HEIGHT 34
-#define MELEE_BOX_SPACE 1
-
-#define MENU_X_OFFS 29
-
-#define INFO_ORIGIN_X 4
-#define INFO_WIDTH 58
-#define TEAM_INFO_ORIGIN_Y 3
-#define TEAM_INFO_HEIGHT (SHIP_INFO_HEIGHT + 75)
-#define MODE_INFO_ORIGIN_Y (TEAM_INFO_HEIGHT + 6)
-#define MODE_INFO_HEIGHT ((STATUS_HEIGHT - 3) - MODE_INFO_ORIGIN_Y)
-#define RACE_INFO_ORIGIN_Y (SHIP_INFO_HEIGHT + 6)
-#define RACE_INFO_HEIGHT ((STATUS_HEIGHT - 3) - RACE_INFO_ORIGIN_Y)
-
-#define MELEE_STATUS_X_OFFS 1
-#define MELEE_STATUS_Y_OFFS 201
-#define MELEE_STATUS_WIDTH  (NUM_MELEE_COLUMNS * \
-		(MELEE_BOX_WIDTH + MELEE_BOX_SPACE))
-#define MELEE_STATUS_HEIGHT 38
+#define MELEE_X_OFFS (2 << RESOLUTION_FACTOR)											// JMS_GFX
+#define MELEE_Y_OFFS ((21 << RESOLUTION_FACTOR) + (RESOLUTION_FACTOR * 21))				// JMS_GFX
+#define MELEE_BOX_WIDTH (34 << RESOLUTION_FACTOR)										// JMS_GFX
+#define MELEE_BOX_HEIGHT (34 << RESOLUTION_FACTOR)										// JMS_GFX
+#define MELEE_BOX_SPACE (1 << RESOLUTION_FACTOR)										// JMS_GFX
+
+#define MENU_X_OFFS (29 << RESOLUTION_FACTOR)											// JMS_GFX
+
+#define INFO_ORIGIN_X (4 << RESOLUTION_FACTOR)											// JMS_GFX
+#define INFO_WIDTH (58 << RESOLUTION_FACTOR)											// JMS_GFX
+#define TEAM_INFO_ORIGIN_Y (3 << RESOLUTION_FACTOR)										// JMS_GFX
+#define TEAM_INFO_HEIGHT (SHIP_INFO_HEIGHT + (75 << RESOLUTION_FACTOR))					// JMS_GFX
+#define MODE_INFO_ORIGIN_Y (TEAM_INFO_HEIGHT + (6 << RESOLUTION_FACTOR))				// JMS_GFX
+#define MODE_INFO_HEIGHT ((STATUS_HEIGHT - (3 << RESOLUTION_FACTOR))-MODE_INFO_ORIGIN_Y)// JMS_GFX
+#define RACE_INFO_ORIGIN_Y (SHIP_INFO_HEIGHT + (6 << RESOLUTION_FACTOR))				// JMS_GFX
+#define RACE_INFO_HEIGHT ((STATUS_HEIGHT - (3 << RESOLUTION_FACTOR))-RACE_INFO_ORIGIN_Y)// JMS_GFX
+
+#define MELEE_STATUS_X_OFFS (1 << RESOLUTION_FACTOR)									// JMS_GFX
+#define MELEE_STATUS_Y_OFFS (201 << RESOLUTION_FACTOR)									// JMS_GFX
+#define MELEE_STATUS_WIDTH  (NUM_MELEE_COLUMNS * (MELEE_BOX_WIDTH + MELEE_BOX_SPACE))
+#define MELEE_STATUS_HEIGHT (38 << RESOLUTION_FACTOR)									// JMS_GFX
 
 #define MELEE_BACKGROUND_COLOR \
 		BUILD_COLOR (MAKE_RGB15 (0x14, 0x00, 0x00), 0x04)
@@ -427,23 +435,21 @@ RedrawMeleeFrame (void)
 static void
 GetTeamStringRect (COUNT side, RECT *r)
 {
-	r->corner.x = MELEE_X_OFFS - 1;
+	r->corner.x = MELEE_X_OFFS - (1 << RESOLUTION_FACTOR); // JMS_GFX
 	r->corner.y = (side + 1) * (MELEE_Y_OFFS
 			+ ((MELEE_BOX_HEIGHT + MELEE_BOX_SPACE) * NUM_MELEE_ROWS + 2));
 	r->extent.width = NUM_MELEE_COLUMNS * (MELEE_BOX_WIDTH + MELEE_BOX_SPACE)
-			- 29;
-	r->extent.height = 13;
+			- (29 << RESOLUTION_FACTOR); // JMS_GFX
+	r->extent.height = 13 << RESOLUTION_FACTOR; // JMS_GFX
 }
 
 static void
 GetFleetValueRect (COUNT side, RECT *r)
 {
-	r->corner.x = MELEE_X_OFFS
-			+ NUM_MELEE_COLUMNS * (MELEE_BOX_WIDTH + MELEE_BOX_SPACE) - 30;
-	r->corner.y = (side + 1) * (MELEE_Y_OFFS
-			+ ((MELEE_BOX_HEIGHT + MELEE_BOX_SPACE) * NUM_MELEE_ROWS + 2));
-	r->extent.width = 29;
-	r->extent.height = 13;
+	r->corner.x = MELEE_X_OFFS + NUM_MELEE_COLUMNS * (MELEE_BOX_WIDTH + MELEE_BOX_SPACE) - (30 << RESOLUTION_FACTOR); // JMS_GFX
+	r->corner.y = (side + 1) * (MELEE_Y_OFFS + ((MELEE_BOX_HEIGHT + MELEE_BOX_SPACE) * NUM_MELEE_ROWS + 2));
+	r->extent.width = 29 << RESOLUTION_FACTOR; // JMS_GFX
+	r->extent.height = 13 << RESOLUTION_FACTOR; // JMS_GFX
 }
 
 static void
@@ -496,8 +502,8 @@ DrawTeamString (MELEE_STATE *pMS, COUNT
 
 	lfText.pStr = (teamName != NULL) ? teamName :
 			MeleeSetup_getTeamName (pMS->meleeSetup, side);
-	lfText.baseline.y = r.corner.y + r.extent.height - 3;
-	lfText.baseline.x = r.corner.x + 1;
+	lfText.baseline.y = r.corner.y + r.extent.height - (3 << RESOLUTION_FACTOR); // JMS_GFX;
+	lfText.baseline.x = r.corner.x + (1 << RESOLUTION_FACTOR); // JMS_GFX;
 	lfText.align = ALIGN_LEFT;
 	lfText.CharCount = strlen (lfText.pStr);
 
@@ -516,7 +522,7 @@ DrawTeamString (MELEE_STATE *pMS, COUNT
 		BYTE *pchar_deltas;
 
 		TextRect (&lfText, &text_r, char_deltas);
-		if ((text_r.extent.width + 2) >= r.extent.width)
+		if ((text_r.extent.width + (2 << RESOLUTION_FACTOR)) >= r.extent.width) // JMS_GFX
 		{	// the text does not fit the input box size and so
 			// will not fit when displayed later
 			UnbatchGraphics ();
@@ -538,25 +544,25 @@ DrawTeamString (MELEE_STATE *pMS, COUNT
 		{	// Use block cursor for keyboardless systems
 			if (pMS->CurIndex == lfText.CharCount)
 			{	// cursor at end-line -- use insertion point
-				text_r.extent.width = 1;
+				text_r.extent.width = 1 << RESOLUTION_FACTOR; // JMS_GFX;
 			}
 			else if (pMS->CurIndex + 1 == lfText.CharCount)
 			{	// extra pixel for last char margin
-				text_r.extent.width = (SIZE)*pchar_deltas + 2;
+				text_r.extent.width = (SIZE)*pchar_deltas + (2 << RESOLUTION_FACTOR); // JMS_GFX;
 			}
 			else
 			{	// normal mid-line char
-				text_r.extent.width = (SIZE)*pchar_deltas + 1;
+				text_r.extent.width = (SIZE)*pchar_deltas + (1 << RESOLUTION_FACTOR); // JMS_GFX
 			}
 		}
 		else
 		{	// Insertion point cursor
-			text_r.extent.width = 1;
+			text_r.extent.width = 1 << RESOLUTION_FACTOR; // JMS_GFX;
 		}
 		// position cursor within input field rect
 		++text_r.corner.x;
 		++text_r.corner.y;
-		text_r.extent.height -= 2;
+		text_r.extent.height -= 2 << RESOLUTION_FACTOR; // JMS_GFX;
 		SetContextForeGroundColor (TEAM_NAME_EDIT_CURS_COLOR);
 		DrawFilledRectangle (&text_r);
 
@@ -880,9 +886,9 @@ DrawMeleeShipStrings (MELEE_STATE *pMS,
 	OldContext = SetContext (StatusContext);
 	GetContextClipRect (&OldRect);
 	r = OldRect;
-	r.corner.x += ((SAFE_X << 1) - 32) + MENU_X_OFFS;
-	r.corner.y += 76;
-	r.extent.height = SHIP_INFO_HEIGHT;
+	r.corner.x += ((SAFE_X << 1) - (32 << RESOLUTION_FACTOR)) + MENU_X_OFFS - RES_CASE(0,0,3); // JMS_GFX
+	r.corner.y += (76 << RESOLUTION_FACTOR) + 3 * RESOLUTION_FACTOR; // JMS_GFX
+	r.extent.height = SHIP_INFO_HEIGHT + 3; // JMS_GFX
 	SetContextClipRect (&r);
 	BatchGraphics ();
 
@@ -891,16 +897,21 @@ DrawMeleeShipStrings (MELEE_STATE *pMS,
 		RECT r;
 		TEXT t;
 
-		ClearShipStatus (0);
+		ClearShipStatus (0, STATUS_WIDTH - 3 * RESOLUTION_FACTOR, TRUE);
+		
+		// JMS_GFX
+		if (RESOLUTION_FACTOR > 0)
+			OutlineShipStatus (0, STATUS_WIDTH - 3 * RESOLUTION_FACTOR, TRUE);
+		
 		SetContextFont (StarConFont);
-		r.corner.x = 3;
-		r.corner.y = 4;
-		r.extent.width = 57;
-		r.extent.height = 60;
+		r.corner.x = RES_STAT_SCALE(3); // JMS_GFX;
+		r.corner.y = RES_STAT_SCALE(4); // JMS_GFX;
+		r.extent.width = RES_STAT_SCALE(57) - 9 * RESOLUTION_FACTOR / 2; // JMS_GFX;
+		r.extent.height = (60 << RESOLUTION_FACTOR) - 3 * RESOLUTION_FACTOR; // JMS_GFX;
 		SetContextForeGroundColor (BLACK_COLOR);
 		DrawRectangle (&r);
 		t.baseline.x = STATUS_WIDTH >> 1;
-		t.baseline.y = 32;
+		t.baseline.y = 32 << RESOLUTION_FACTOR; // JMS_GFX;
 		t.align = ALIGN_CENTER;
 		if (pMS->row < NUM_MELEE_ROWS)
 		{
@@ -930,7 +941,7 @@ DrawMeleeShipStrings (MELEE_STATE *pMS,
 		hMasterShip = GetStarShipFromIndex (&master_q, NewStarShip);
 		MasterPtr = LockMasterShip (&master_q, hMasterShip);
 
-		InitShipStatus (&MasterPtr->ShipInfo, NULL, NULL);
+		InitShipStatus (&MasterPtr->ShipInfo, NULL, NULL, TRUE);
 
 		UnlockMasterShip (&master_q, hMasterShip);
 	}
@@ -1642,8 +1653,8 @@ DoConnectingDialog (MELEE_STATE *pMS)
 		oldfont = SetContextFont (StarConFont);
 		oldcolor = SetContextForeGroundColor (BLACK_COLOR);
 		BatchGraphics ();
-		r.extent.width = 200;
-		r.extent.height = 30;
+		r.extent.width = 200 << RESOLUTION_FACTOR; // JMS_GFX
+		r.extent.height = 30 << RESOLUTION_FACTOR; // JMS_GFX
 		r.corner.x = (SCREEN_WIDTH - r.extent.width) >> 1;
 		r.corner.y = (SCREEN_HEIGHT - r.extent.height) >> 1;
 		DrawShadowedBox (&r, SHADOWBOX_BACKGROUND_COLOR, 
@@ -1659,7 +1670,7 @@ DoConnectingDialog (MELEE_STATE *pMS)
 			t.pStr = GAME_STRING (NETMELEE_STRING_BASE + 2);
 					/* "Awaiting outgoing connection */
 		}
-		t.baseline.y = r.corner.y + 10;
+		t.baseline.y = r.corner.y + (10 << RESOLUTION_FACTOR);
 		t.baseline.x = SCREEN_WIDTH >> 1;
 		t.align = ALIGN_CENTER;
 		t.CharCount = ~0;
@@ -1667,7 +1678,7 @@ DoConnectingDialog (MELEE_STATE *pMS)
 
 		t.pStr = GAME_STRING (NETMELEE_STRING_BASE + 18);
 				/* "Press SPACE to cancel" */
-		t.baseline.y += 16;
+		t.baseline.y += 16 << RESOLUTION_FACTOR;
 		font_DrawText (&t);
 
 		// Restore original graphics
@@ -1994,17 +2005,17 @@ LoadMeleeConfig (MELEE_STATE *pMS)
 	uio_Stream *stream;
 	int status;
 	COUNT side;
-
+	
 	stream = uio_fopen (configDir, "melee.cfg", "rb");
 	if (stream == NULL)
 		goto err;
-	
+
 	{
 		struct stat sb;
 
 		if (uio_fstat(uio_streamHandle(stream), &sb) == -1)
 			goto err;
-		if ((size_t) sb.st_size != (1 + MeleeTeam_serialSize) * NUM_SIDES)
+		if ((size_t) sb.st_size != (1 + MeleeTeam_size) * NUM_SIDES)
 			goto err;
 	}
 
@@ -2013,12 +2024,17 @@ LoadMeleeConfig (MELEE_STATE *pMS)
 		status = uio_getc (stream);
 		if (status == EOF)
 			goto err;
+
 		PlayerControl[side] = (BYTE) status;
 		// XXX: insert sanity check on PlanetControl here.
 
 		if (MeleeSetup_deserializeTeam (pMS->meleeSetup, side, stream) == -1)
 			goto err;
-	
+		
+		// JMS: For some reason these weren't calculated at all which resulted in funky fleet values...
+		pMS->meleeSetup->fleetValue[0] = MeleeTeam_getValue (&(pMS->meleeSetup->teams[0]));
+		pMS->meleeSetup->fleetValue[1] = MeleeTeam_getValue (&(pMS->meleeSetup->teams[1]));
+		
 		/* Do not allow netplay mode at the start. */
 		if (PlayerControl[side] & NETWORK_CONTROL)
 			PlayerControl[side] = HUMAN_CONTROL | STANDARD_RATING;
@@ -2068,7 +2084,7 @@ err:
 
 void
 Melee (void)
-{
+{	
 	InitGlobData ();
 	{
 		MELEE_STATE MenuState;
@@ -2114,6 +2130,7 @@ Melee (void)
 		}
 
 		MenuState.side = 0;
+		
 		SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
 		DoInput (&MenuState, TRUE);
 
@@ -2500,7 +2517,6 @@ Melee_LocalChange_team (MELEE_STATE *pMS
 }
 
 ///////////////////////////////////////////////////////////////////////////
-
 #ifdef NETPLAY
 
 // Send the entire team to the remote side. Used when the connection has
@@ -2531,8 +2547,6 @@ Melee_bootstrapSyncTeam (MELEE_STATE *me
 	MeleeSetup_setSentTeamName (setup, teamNr, teamName);
 }
 
-///////////////////////////////////////////////////////////////////////////
-
 // Melee_RemoteChange_xxx() functions are called when some value in the
 // supermelee fleet setup screen has changed remotely.
 // The behavior of these functions (and the comments therein) follow the
diff -ruNp src.orig/uqm/supermelee/melee.h src/uqm/supermelee/melee.h
--- src.orig/uqm/supermelee/melee.h	2017-11-01 15:30:28 -0700
+++ src/uqm/supermelee/melee.h	2017-11-01 15:31:05 -0700
@@ -16,6 +16,9 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: -Added Slylandros-in-kohrah-vessels and Chmmr Explorer to melee ship list
+//			 -Added Lurg and ISD to the list
+
 #ifndef _MELEE_H
 #define _MELEE_H
 
@@ -34,8 +37,8 @@ typedef struct melee_state MELEE_STATE;
 #define NUM_MELEE_COLUMNS 7
 //#define NUM_MELEE_COLUMNS 6
 #define MELEE_FLEET_SIZE (NUM_MELEE_ROWS * NUM_MELEE_COLUMNS)
-#define ICON_WIDTH 16
-#define ICON_HEIGHT 16
+#define ICON_WIDTH (16 << RESOLUTION_FACTOR) // JMS_GFX
+#define ICON_HEIGHT (16 << RESOLUTION_FACTOR) // JMS_GFX
 
 extern FRAME PickMeleeFrame;
 
@@ -46,7 +49,7 @@ extern FRAME PickMeleeFrame;
 
 #define MAX_TEAM_CHARS 30
 #define NUM_PICK_COLS 5
-#define NUM_PICK_ROWS 5
+#define NUM_PICK_ROWS 6 // JMS
 
 typedef BYTE MELEE_OPTIONS;
 
diff -ruNp src.orig/uqm/supermelee/meleesetup.c src/uqm/supermelee/meleesetup.c
--- src.orig/uqm/supermelee/meleesetup.c	2017-11-01 15:30:28 -0700
+++ src/uqm/supermelee/meleesetup.c	2017-11-01 15:31:05 -0700
@@ -25,8 +25,7 @@
 ///////////////////////////////////////////////////////////////////////////
 
 // Temporary
-const size_t MeleeTeam_serialSize = MELEE_FLEET_SIZE +
-		sizeof (((MeleeTeam*)0)->name);
+const size_t MeleeTeam_size = sizeof (MeleeTeam);
 
 void
 MeleeTeam_init (MeleeTeam *team)
@@ -324,10 +323,7 @@ MeleeSetup_deserializeTeam (MeleeSetup *
 		uio_Stream *stream)
 {
 	MeleeTeam *team = &setup->teams[teamNr];
-	int ret = MeleeTeam_deserialize (team, stream);
-	if (ret == 0)
-		setup->fleetValue[teamNr] = MeleeTeam_getValue (team);
-	return ret;
+	return MeleeTeam_deserialize (team, stream);
 }
 
 int
diff -ruNp src.orig/uqm/supermelee/meleesetup.h src/uqm/supermelee/meleesetup.h
--- src.orig/uqm/supermelee/meleesetup.h	2017-11-01 15:30:28 -0700
+++ src/uqm/supermelee/meleesetup.h	2017-11-01 15:31:05 -0700
@@ -64,7 +64,7 @@ struct MeleeSetup
 
 #endif  /* MELEESETUP_INTERNAL */
 
-extern const size_t MeleeTeam_serialSize;
+extern const size_t MeleeTeam_size;
 
 void MeleeTeam_init (MeleeTeam *team);
 void MeleeTeam_uninit (MeleeTeam *team);
diff -ruNp src.orig/uqm/supermelee/meleeship.h src/uqm/supermelee/meleeship.h
--- src.orig/uqm/supermelee/meleeship.h	2017-11-01 15:30:28 -0700
+++ src/uqm/supermelee/meleeship.h	2017-11-01 15:31:05 -0700
@@ -3,7 +3,7 @@
 
 #include "types.h"
 
-typedef enum MeleeShip {
+enum MeleeShip {
 	MELEE_ANDROSYNTH,
 	MELEE_ARILOU,
 	MELEE_CHENJESU,
@@ -29,13 +29,21 @@ typedef enum MeleeShip {
 	MELEE_VUX,
 	MELEE_YEHAT,
 	MELEE_ZOQFOTPIK,
+	MELEE_BAUL,
+	MELEE_FOONFOON,
+	MELEE_LURG,		 // JMS
+	MELEE_ISD,		 // JMS
+	MELEE_EXPLORER,  // JMS
+	MELEE_SLYKOHR,   // JMS
 	
 	MELEE_UNSET = ((BYTE) ~0) - 1,
 			// Used with the Update protocol, to register in the sentTeam
 	MELEE_NONE = (BYTE) ~0
 			// Empty fleet position.
-} MeleeShip;
-#define NUM_MELEE_SHIPS (MELEE_ZOQFOTPIK + 1)
+};
+
+typedef BYTE MeleeShip; // JMS: Make GCC compiler treat Meleeship entries as 1 byte long.
+#define NUM_MELEE_SHIPS (MELEE_EXPLORER + 1)
 
 static inline bool
 MeleeShip_valid (MeleeShip ship)
diff -ruNp src.orig/uqm/supermelee/netplay/netplay.h src/uqm/supermelee/netplay/netplay.h
--- src.orig/uqm/supermelee/netplay/netplay.h	2017-11-01 15:30:29 -0700
+++ src/uqm/supermelee/netplay/netplay.h	2017-11-01 15:31:05 -0700
@@ -27,9 +27,9 @@
 #define NETPLAY_PROTOCOL_VERSION_MAJOR 0
 #define NETPLAY_PROTOCOL_VERSION_MINOR 4
 
-#define NETPLAY_MIN_UQM_VERSION_MAJOR 0
-#define NETPLAY_MIN_UQM_VERSION_MINOR 6
-#define NETPLAY_MIN_UQM_VERSION_PATCH 9
+#define NETPLAY_MIN_P6014_VERSION_MAJOR 0
+#define NETPLAY_MIN_P6014_VERSION_MINOR 2
+#define NETPLAY_MIN_P6014_VERSION_PATCH 0
 
 #undef NETPLAY_DEBUG
 		/* Extra debugging for netplay */
diff -ruNp src.orig/uqm/supermelee/netplay/packet.c src/uqm/supermelee/netplay/packet.c
--- src.orig/uqm/supermelee/netplay/packet.c	2017-11-01 15:30:29 -0700
+++ src/uqm/supermelee/netplay/packet.c	2017-11-01 15:31:05 -0700
@@ -88,9 +88,9 @@ Packet_Init_create(void) {
 	packet->protoVersion.major = NETPLAY_PROTOCOL_VERSION_MAJOR;
 	packet->protoVersion.minor = NETPLAY_PROTOCOL_VERSION_MINOR;
 	packet->padding0 = 0;
-	packet->uqmVersion.major = UQM_MAJOR_VERSION;
-	packet->uqmVersion.minor = UQM_MINOR_VERSION;
-	packet->uqmVersion.patch = UQM_PATCH_VERSION;
+	packet->uqmVersion.major = P6014_MAJOR_VERSION;
+	packet->uqmVersion.minor = P6014_MINOR_VERSION;
+	packet->uqmVersion.patch = P6014_PATCH_VERSION;
 	packet->padding1 = 0;
 	return packet;
 }
diff -ruNp src.orig/uqm/supermelee/netplay/packethandlers.c src/uqm/supermelee/netplay/packethandlers.c
--- src.orig/uqm/supermelee/netplay/packethandlers.c	2017-11-01 15:30:29 -0700
+++ src/uqm/supermelee/netplay/packethandlers.c	2017-11-01 15:31:05 -0700
@@ -104,16 +104,16 @@ PacketHandler_Init(NetConnection *conn,
 	}
 
 	if (versionCompare(packet->uqmVersion.major, packet->uqmVersion.minor,
-			packet->uqmVersion.patch, NETPLAY_MIN_UQM_VERSION_MAJOR,
-			NETPLAY_MIN_UQM_VERSION_MINOR, NETPLAY_MIN_UQM_VERSION_PATCH)
+			packet->uqmVersion.patch, NETPLAY_MIN_P6014_VERSION_MAJOR,
+			NETPLAY_MIN_P6014_VERSION_MINOR, NETPLAY_MIN_P6014_VERSION_PATCH)
 			< 0) {
 		sendAbort (conn, AbortReason_versionMismatch);
 		abortFeedback(conn, AbortReason_versionMismatch);
-		log_add(log_Error, "Remote side is running a version of UQM that "
+		log_add(log_Error, "Remote side is running a version of P6014 that "
 				"is too old (%d.%d.%d; %d.%d.%d is required).",
 				packet->uqmVersion.major, packet->uqmVersion.minor,
-				packet->uqmVersion.patch, NETPLAY_MIN_UQM_VERSION_MAJOR,
-				NETPLAY_MIN_UQM_VERSION_MINOR, NETPLAY_MIN_UQM_VERSION_PATCH);
+				packet->uqmVersion.patch, NETPLAY_MIN_P6014_VERSION_MAJOR,
+				NETPLAY_MIN_P6014_VERSION_MINOR, NETPLAY_MIN_P6014_VERSION_PATCH);
 		errno = ENOSYS;
 		return -1;
 	}
@@ -200,7 +200,7 @@ PacketHandler_Fleet(NetConnection *conn,
 		// There is not enough room in the packet to contain all
 		// the ships it says it contains.
 		log_add(log_Warning, "Invalid fleet size. Specified size is %d, "
-				"actual size = %d",
+				"actual size = %lu",
 				numShips, (len - sizeof packet) / sizeof(packet->ships[0]));
 		errno = EBADMSG;
 		return -1;
@@ -578,7 +578,7 @@ PacketHandler_Checksum(NetConnection *co
 		log_add(log_Warning, "NETPLAY: [%d] <== Received checksum "
 				"for frame %u, while we only expect checksums on frames "
 				"divisable by %u -- discarding.", conn->player,
-				(unsigned int) frameNr, interval);
+				(unsigned int) frameNr, (unsigned int) interval);
 		return 0;
 				// No need to close the connection; checksums are not
 				// essential.
@@ -593,7 +593,7 @@ PacketHandler_Checksum(NetConnection *co
 		log_add(log_Warning, "NETPLAY: [%d] <== Received checksum "
 				"for a frame too far in the future (frame %u, current "
 				"is %u, input delay is %u) -- discarding.", conn->player,
-				(unsigned int) frameNr, battleFrameCount, delay);
+				(unsigned int) frameNr, (unsigned int) battleFrameCount, (unsigned int)delay);
 		return 0;
 				// No need to close the connection; checksums are not
 				// essential.
@@ -610,7 +610,7 @@ PacketHandler_Checksum(NetConnection *co
 		log_add(log_Warning, "NETPLAY: [%d] <== Received checksum "
 				"for a frame too far in the past (frame %u, current "
 				"is %u, input delay is %u) -- discarding.", conn->player,
-				(unsigned int) frameNr, battleFrameCount, delay);
+				(unsigned int) frameNr, (unsigned int)battleFrameCount, (unsigned int)delay);
 		return 0;
 				// No need to close the connection; checksums are not
 				// essential.
diff -ruNp src.orig/uqm/supermelee/pickmele.c src/uqm/supermelee/pickmele.c
--- src.orig/uqm/supermelee/pickmele.c	2017-11-01 15:30:29 -0700
+++ src/uqm/supermelee/pickmele.c	2017-11-01 15:31:06 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
 #define PICKMELE_INTERNAL
 #include "pickmele.h"
 
@@ -44,13 +46,13 @@
 #define NUM_PICKMELEE_ROWS 2
 #define NUM_PICKMELEE_COLUMNS 7
 
-#define PICK_X_OFFS 57
-#define PICK_Y_OFFS 24
-#define PICK_SIDE_OFFS 100
-
-#define NAME_AREA_HEIGHT 7
-#define MELEE_WIDTH 149
-#define MELEE_HEIGHT (48 + NAME_AREA_HEIGHT)
+#define PICK_X_OFFS (57 << RESOLUTION_FACTOR) // JMS_GFX
+#define PICK_Y_OFFS (24 << RESOLUTION_FACTOR) // JMS_GFX
+#define PICK_SIDE_OFFS (100 << RESOLUTION_FACTOR) // JMS_GFX
+
+#define NAME_AREA_HEIGHT (7 << RESOLUTION_FACTOR) // JMS_GFX
+#define MELEE_WIDTH (149 << RESOLUTION_FACTOR) // JMS_GFX
+#define MELEE_HEIGHT ((48 << RESOLUTION_FACTOR) + NAME_AREA_HEIGHT) // JMS_GFX
 
 #define PICKSHIP_TEAM_NAME_TEXT_COLOR \
 		BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x1F), 0x09)
@@ -147,11 +149,11 @@ static void
 PickMelee_ChangedSelection (GETMELEE_STATE *gms, COUNT playerI)
 {
 	RECT r;
-	r.corner.x = PICK_X_OFFS + ((ICON_WIDTH + 2) * gms->player[playerI].col);
-	r.corner.y = PICK_Y_OFFS + ((ICON_HEIGHT + 2) * gms->player[playerI].row)
-			+ ((1 - playerI) * PICK_SIDE_OFFS);
-	r.extent.width = (ICON_WIDTH + 2);
-	r.extent.height = (ICON_HEIGHT + 2);
+	r.corner.x = PICK_X_OFFS + ((ICON_WIDTH + (2 << RESOLUTION_FACTOR)) * gms->player[playerI].col); // JMS_GFX
+	r.corner.y = PICK_Y_OFFS + ((ICON_HEIGHT +(2 << RESOLUTION_FACTOR)) * gms->player[playerI].row)
+			+ ((1 - playerI) * PICK_SIDE_OFFS); // JMS_GFX
+	r.extent.width = (ICON_WIDTH + (2 << RESOLUTION_FACTOR)); // JMS_GFX
+	r.extent.height = (ICON_HEIGHT + (2 << RESOLUTION_FACTOR));// JMS_GFX
 	Flash_setRect (gms->player[playerI].flashContext, &r);
 }
 
@@ -423,8 +425,8 @@ CrossOutShip (FRAME frame, COUNT shipNr)
 	
 	SetContextFGFrame (frame);
 
-	s.origin.x = 3 + ((ICON_WIDTH + 2) * col);
-	s.origin.y = 9 + ((ICON_HEIGHT + 2) * row);
+	s.origin.x = (3 << RESOLUTION_FACTOR) + ((ICON_WIDTH + (2 << RESOLUTION_FACTOR)) * col);  // JMS_GFX
+	s.origin.y = (9 << RESOLUTION_FACTOR) + ((ICON_HEIGHT + (2 << RESOLUTION_FACTOR)) * row); // JMS_GFX
 	s.frame = SetAbsFrameIndex (StatusFrame, 3);
 			// Cross for through the ship image.
 	DrawStamp (&s);
@@ -450,18 +452,18 @@ UpdatePickMeleeFleetValue (FRAME frame,
 
 	// Erase the old value text.
 	GetFrameRect (frame, &r);
-	r.extent.width -= 4;
+	r.extent.width -= (4 << RESOLUTION_FACTOR); // JMS_GFX
 	t.baseline.x = r.extent.width;
-	r.corner.x = r.extent.width - (6 * 3);
-	r.corner.y = 2;
-	r.extent.width = (6 * 3);
-	r.extent.height = 7 - 2;
+	r.corner.x = r.extent.width - ((6 * 3) << RESOLUTION_FACTOR); // JMS_GFX
+	r.corner.y = 2 << RESOLUTION_FACTOR; // JMS_GFX
+	r.extent.width = (6 * 3) << RESOLUTION_FACTOR; // JMS_GFX
+	r.extent.height = ((7 - 2) << RESOLUTION_FACTOR) + (RESOLUTION_FACTOR); // JMS_GFX
 	SetContextForeGroundColor (PICK_BG_COLOR);
 	DrawFilledRectangle (&r);
 
 	// Draw the new value text.
 	sprintf (buf, "%d", value);
-	t.baseline.y = 7;
+	t.baseline.y = 7 << RESOLUTION_FACTOR; // JMS_GFX
 	t.align = ALIGN_RIGHT;
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
@@ -483,8 +485,7 @@ BuildPickMeleeFrame (void)
 	if (PickMeleeFrame)
 		DestroyDrawable (ReleaseDrawable (PickMeleeFrame));
 
-	PickMeleeFrame = CaptureDrawable (CreateDrawable (
-			WANT_PIXMAP, MELEE_WIDTH, MELEE_HEIGHT, 2));
+	PickMeleeFrame = CaptureDrawable (CreateDrawable (WANT_PIXMAP, MELEE_WIDTH, MELEE_HEIGHT, 2));
 	s.origin.x = 0;
 	s.origin.y = 0;
 
@@ -507,22 +508,20 @@ BuildPickMeleeFrame (void)
 void
 FillPickMeleeFrame (MeleeSetup *setup)
 {
-	COUNT i;
+	COUNT sideI;
 	CONTEXT OldContext;
 
 	OldContext = SetContext (OffScreenContext);
 
-	for (i = 0; i < NUM_SIDES; ++i)
+	for (sideI = 0; sideI < NUM_SIDES; ++sideI)
 	{
 		COUNT side;
-		COUNT sideI;
 		RECT r;
 		TEXT t;
 		STAMP s;
 		UNICODE buf[30];
 		FleetShipIndex index;
 
-		sideI = GetPlayerOrder (i);
 		side = !sideI;
 
 		s.frame = SetAbsFrameIndex (PickMeleeFrame, side);
@@ -530,17 +529,17 @@ FillPickMeleeFrame (MeleeSetup *setup)
 
 		GetFrameRect (s.frame, &r);
 		t.baseline.x = r.extent.width >> 1;
-		t.baseline.y = r.extent.height - NAME_AREA_HEIGHT + 4;
+		t.baseline.y = r.extent.height - NAME_AREA_HEIGHT + (4 << RESOLUTION_FACTOR); // JMS_GFX
 
-		r.corner.x += 2;
-		r.corner.y += 2;
-		r.extent.width -= (2 * 2) + (ICON_WIDTH + 2) + 1;
-		r.extent.height -= (2 * 2) + NAME_AREA_HEIGHT;
+		r.corner.x += 2 << RESOLUTION_FACTOR; // JMS_GFX
+		r.corner.y += 2 << RESOLUTION_FACTOR; // JMS_GFX
+		r.extent.width -=( (2 * 2) + ((ICON_WIDTH >> RESOLUTION_FACTOR) + 2) + 1) << RESOLUTION_FACTOR; // JMS_GFX
+		r.extent.height -=( ((2 * 2) << RESOLUTION_FACTOR) + NAME_AREA_HEIGHT); // JMS_GFX
 		SetContextForeGroundColor (PICK_BG_COLOR);
 		DrawFilledRectangle (&r);
 
-		r.corner.x += 2;
-		r.extent.width += (ICON_WIDTH + 2) - (2 * 2);
+		r.corner.x += 2 << RESOLUTION_FACTOR; // JMS_GFX
+		r.extent.width += (((ICON_WIDTH >> RESOLUTION_FACTOR) + 2) - (2 * 2)) << RESOLUTION_FACTOR; // JMS_GFX
 		r.corner.y += r.extent.height;
 		r.extent.height = NAME_AREA_HEIGHT;
 		DrawFilledRectangle (&r);
@@ -555,8 +554,8 @@ FillPickMeleeFrame (MeleeSetup *setup)
 
 		// Total team value of the starting team:
 		sprintf (buf, "%u", MeleeSetup_getFleetValue (setup, sideI));
-		t.baseline.x = 4;
-		t.baseline.y = 7;
+		t.baseline.x = 4 << RESOLUTION_FACTOR; // JMS_GFX
+		t.baseline.y = 7 << RESOLUTION_FACTOR; // JMS_GFX
 		t.align = ALIGN_LEFT;
 		t.pStr = buf;
 		t.CharCount = (COUNT)~0;
@@ -592,8 +591,8 @@ FillPickMeleeFrame (MeleeSetup *setup)
 				// Draw the icon.
 				row = PickMelee_GetShipRow (index);
 				col = PickMelee_GetShipColumn (index);
-				s.origin.x = 4 + ((ICON_WIDTH + 2) * col);
-				s.origin.y = 10 + ((ICON_HEIGHT + 2) * row);
+				s.origin.x = (4 << RESOLUTION_FACTOR) + ((ICON_WIDTH + (2 << RESOLUTION_FACTOR)) * col); // JMS_GFX
+				s.origin.y = (10 << RESOLUTION_FACTOR) + ((ICON_HEIGHT + (2 << RESOLUTION_FACTOR)) * row); // JMS_GFX
 				s.frame = MasterPtr->ShipInfo.icons;
 				DrawStamp (&s);
 
@@ -635,8 +634,8 @@ DrawPickMeleeFrame (COUNT which_player)
 
 	oldContext = SetContext (SpaceContext);
 	s.frame = SetAbsFrameIndex (PickMeleeFrame, which_player);
-	s.origin.x = PICK_X_OFFS - 3;
-	s.origin.y = PICK_Y_OFFS - 9 + ((1 - which_player) * PICK_SIDE_OFFS);
+	s.origin.x = PICK_X_OFFS - (3 << RESOLUTION_FACTOR); // JMS_GFX
+	s.origin.y = PICK_Y_OFFS - (9 << RESOLUTION_FACTOR) + ((1 - which_player) * PICK_SIDE_OFFS); // JMS_GFX
 	DrawStamp (&s);
 			// Draw the selection box to screen.
 	
diff -ruNp src.orig/uqm/tactrans.c src/uqm/tactrans.c
--- src.orig/uqm/tactrans.c	2017-11-01 15:30:29 -0700
+++ src/uqm/tactrans.c	2017-11-01 15:31:06 -0700
@@ -16,6 +16,11 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: - Damaged thrusters emit differently colored particles
+//			 - Enable Down key in melee (comment tag JMS_KEYS)
+
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
 #include "tactrans.h"
 
 #include "battlecontrols.h"
@@ -41,7 +46,9 @@
 #include "settings.h"
 #include "sounds.h"
 #include "libs/mathlib.h"
+#include "libs/sound/sound.h"
 
+#include "libs/log.h"
 
 static void cleanup_dead_ship (ELEMENT *ElementPtr);
 
@@ -290,6 +297,7 @@ cleanup_dead_ship (ELEMENT *DeadShipPtr)
 	ProcessSound ((SOUND)~0, NULL);
 
 	GetElementStarShip (DeadShipPtr, &DeadStarShipPtr);
+	
 	{
 		// Ship explosion has finished, or ship has just warped out
 		// if DeadStarShipPtr->crew_level != 0
@@ -345,7 +353,7 @@ cleanup_dead_ship (ELEMENT *DeadShipPtr)
 
 			UnlockElement (hElement);
 		}
-
+		DeadShipPtr->state_flags |= DeadShipPtr->turn_wait;
 #define MIN_DITTY_FRAME_COUNT  ((ONE_SECOND * 3) / BATTLE_FRAME_RATE)
 		// The ship will be "alive" for at least 2 more frames to make sure
 		// the elements it owns (set up for deletion above) expire first.
@@ -628,6 +636,24 @@ ship_death (ELEMENT *ShipPtr)
 	StopMusic ();
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
+	
+	// JMS: Make sure the Foon-foon's spinning blade sound ends when the ship dies.
+	if (StarShipPtr->SpeciesID == FOONFOON_ID)
+	{
+		COUNT i;
+		
+		for (i = FIRST_SFX_CHANNEL; i <= LAST_SFX_CHANNEL; ++i)
+		{
+			ELEMENT *posobj;
+			if (!ChannelPlaying(i))
+				continue;
+			
+			posobj = GetPositionalObject (i);
+			
+			if (posobj)
+				StopSource (i);
+		}
+	}
 
 	if (ShipPtr->mass_points <= MAX_SHIP_MASS)
 	{	// Not running away and not reincarnating (Pkunk)
@@ -705,12 +731,17 @@ ship_death (ELEMENT *ShipPtr)
 }
 
 #define START_ION_COLOR BUILD_COLOR (MAKE_RGB15 (0x1F, 0x15, 0x00), 0x7A)
+#define START_ION_COLOR_DAMAGED BUILD_COLOR (MAKE_RGB15 (0x20, 0x20, 0x00), 0x7A)
 
 // Called from the death_func of an element for an ion trail pixel, or a
 // ship shadow (when warping in/out).
 static void
 cycle_ion_trail (ELEMENT *ElementPtr)
 {
+	STARSHIP *StarShipPtr;
+	SHIP_INFO *ShipInfoPtr;
+
+	// Color table for fully functional thrusters
 	static const Color colorTab[] =
 	{
 		BUILD_COLOR (MAKE_RGB15_INIT (0x1F, 0x15, 0x00), 0x7a),
@@ -726,8 +757,31 @@ cycle_ion_trail (ELEMENT *ElementPtr)
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x00, 0x00), 0x2e),
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0B, 0x00, 0x00), 0x2f),
 	};
+
+	// JMS: Color table for damaged thrusters
+	static const Color colorTab2[] =
+	{
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x15, 0x1F), 0x7a),
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x11, 0x1F), 0x7b),
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x0E, 0x1F), 0x7c),
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x0A, 0x1F), 0x7d),
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x07, 0x1F), 0x7e),
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x03, 0x1F), 0x7f),
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x1F), 0x2a),
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x1B), 0x2b),
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x17), 0x2c),
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x13), 0x2d),
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x0F), 0x2e),
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x0B), 0x2f),
+	};
+	
 	const size_t colorTabCount = sizeof colorTab / sizeof colorTab[0];
 			
+	// JMS: Get the pointers to element's owner ship.
+	// They are needed to see if the ship's thrust is damaged
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+	ShipInfoPtr = &StarShipPtr->RaceDescPtr->ship_info;
+
 	assert (!(ElementPtr->state_flags & PLAYER_SHIP));
 
 	ElementPtr->colorCycleIndex++;
@@ -736,8 +790,17 @@ cycle_ion_trail (ELEMENT *ElementPtr)
 		ElementPtr->life_span = ElementPtr->thrust_wait;
 				// Reset the life span.
 		
-		SetPrimColor (&DisplayArray[ElementPtr->PrimIndex],
-				colorTab[ElementPtr->colorCycleIndex]);
+		// JMS: Damaged thruster emits differently colored particles
+		if (ShipInfoPtr->damage_flags & DAMAGE_THRUST)
+		{
+			SetPrimColor (&DisplayArray[ElementPtr->PrimIndex],
+				      colorTab2[ElementPtr->colorCycleIndex]);
+		}
+		else
+		{
+			SetPrimColor (&DisplayArray[ElementPtr->PrimIndex],
+				      colorTab[ElementPtr->colorCycleIndex]);
+		}
 
 		ElementPtr->state_flags &= ~DISAPPEARING;
 		ElementPtr->state_flags |= CHANGING;
@@ -747,10 +810,17 @@ cycle_ion_trail (ELEMENT *ElementPtr)
 void
 spawn_ion_trail (ELEMENT *ElementPtr)
 {
+	STARSHIP *StarShipPtr;
+	SHIP_INFO *ShipInfoPtr;
 	HELEMENT hIonElement;
 
 	assert (ElementPtr->state_flags & PLAYER_SHIP);
 
+	// JMS: Get the pointers to element's owner ship.
+	// They are needed to see if the ship's thrust is damaged
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+	ShipInfoPtr = &StarShipPtr->RaceDescPtr->ship_info;
+
 	hIonElement = AllocElement ();
 	if (hIonElement)
 	{
@@ -775,8 +845,18 @@ spawn_ion_trail (ELEMENT *ElementPtr)
 				// 'cycle_ion_trail', it is given new life a number of
 				// times, by setting life_span to thrust_wait.
 		SetPrimType (&DisplayArray[IonElementPtr->PrimIndex], POINT_PRIM);
-		SetPrimColor (&DisplayArray[IonElementPtr->PrimIndex],
-				START_ION_COLOR);
+		// JMS: Damaged thruster emits differently colored particles
+		if (ShipInfoPtr->damage_flags & DAMAGE_THRUST)
+		{
+			SetPrimColor (&DisplayArray[IonElementPtr->PrimIndex],
+				      START_ION_COLOR_DAMAGED);
+		}
+		else
+		{
+			SetPrimColor (&DisplayArray[IonElementPtr->PrimIndex],
+				      START_ION_COLOR);
+		}
+
 		IonElementPtr->colorCycleIndex = 0;
 		IonElementPtr->current.image.frame =
 				DecFrameIndex (stars_in_space);
@@ -860,7 +940,7 @@ ship_transition (ELEMENT *ElementPtr)
 		}
 		else if ((hShipImage = AllocElement ()))
 		{
-#define TRANSITION_SPEED DISPLAY_TO_WORLD (40)
+#define TRANSITION_SPEED DISPLAY_TO_WORLD (40 << RESOLUTION_FACTOR) // JMS_GFX
 #define TRANSITION_LIFE 1
 			COUNT angle;
 
@@ -970,6 +1050,7 @@ flee_preprocess (ELEMENT *ElementPtr)
 		else
 		{
 			ElementPtr->death_func = cleanup_dead_ship;
+			//if (StarShipPtr->which_side == 0) // JMS: Added this condition so escaping enemy ships are not considered destroyed
 			ElementPtr->crew_level = 0;
 
 			ElementPtr->life_span = HYPERJUMP_LIFE + 1;
@@ -982,7 +1063,7 @@ flee_preprocess (ELEMENT *ElementPtr)
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	StarShipPtr->cur_status_flags &=
-			~(LEFT | RIGHT | THRUST | WEAPON | SPECIAL);
+			~(LEFT | RIGHT | THRUST | WEAPON | SPECIAL | DOWN);
 			// Ignore control input when fleeing.
 	PreProcessStatus (ElementPtr);
 }
diff -ruNp src.orig/uqm/trans.c src/uqm/trans.c
--- src.orig/uqm/trans.c	2017-11-01 15:30:29 -0700
+++ src/uqm/trans.c	2017-11-01 15:31:06 -0700
@@ -139,8 +139,7 @@ ARCTAN (SIZE delta_x, SIZE delta_y)
 	if (v2 < 0)
 		v2 = -v2;
 	if (v1 > v2)
-		v1 = QUADRANT
-				- atantab[(((DWORD)v2 << (CIRCLE_SHIFT - 1)) + (v1 >> 1)) / v1];
+		v1 = QUADRANT - atantab[(((DWORD)v2 << (CIRCLE_SHIFT - 1)) + (v1 >> 1)) / v1];
 	else
 		v1 = atantab[(((DWORD)v1 << (CIRCLE_SHIFT - 1)) + (v2 >> 1)) / v2];
 
@@ -151,4 +150,3 @@ ARCTAN (SIZE delta_x, SIZE delta_y)
 
 	return (NORMALIZE_ANGLE (v1));
 }
-
diff -ruNp src.orig/uqm/units.h src/uqm/units.h
--- src.orig/uqm/units.h	2017-11-01 15:30:29 -0700
+++ src/uqm/units.h	2017-11-01 15:31:06 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2011: Merged the resolution Factor stuff from UQM-HD.
+
 #ifndef _UNITS_H
 #define _UNITS_H
 
@@ -23,16 +25,27 @@
 
 extern int ScreenWidth;
 extern int ScreenHeight;
+extern unsigned int resolutionFactor; // JMS_GFX
 
+				/* Most basic resolution units. */
 #define SCREEN_WIDTH ScreenWidth
 #define SCREEN_HEIGHT ScreenHeight
+#define RESOLUTION_FACTOR resolutionFactor														// JMS_GFX
+#define RES_CASE(a,b,c) (RESOLUTION_FACTOR == 0 ? (a) : (RESOLUTION_FACTOR == 1 ? (b) : (c)))	// JMS_GFX
+#define RES_STAT_SCALE(a) (RESOLUTION_FACTOR < 2 ? ((a) << RESOLUTION_FACTOR) : ((a) * 3))		// JMS_GFX
+
+				/* Margins. */
 #define SAFE_X 0
-		/* Left and right screen margin to be left unused */
+	/* Left and right screen margin to be left unused */
 #define SAFE_Y 0
-		/* Top and bottom screen margin to be left unused */
-#define SIS_ORG_X (7 + SAFE_X)
-#define SIS_ORG_Y (10 + SAFE_Y)
-#define STATUS_WIDTH 64
+	/* Top and bottom screen margin to be left unused */
+#define SIS_ORG_X (7 + SAFE_X)								// JMS_GFX
+	//#define SIS_ORG_X (7 * RESOLUTION_FACTOR + SAFE_X)	// JMS_GFX
+#define SIS_ORG_Y RES_CASE(10, 20, 30)						// DC: top status window. Manually entered in for 4x mode.
+	//#define SIS_ORG_Y (10 * RESOLUTION_FACTOR + SAFE_Y)	// JMS_GFX
+
+				/* Status bar & play area sizes. */
+#define STATUS_WIDTH RES_STAT_SCALE(64)
 		/* Width of the status "window" (the right part of the screen) */
 #define STATUS_HEIGHT (SCREEN_HEIGHT - (SAFE_Y * 2))
 		/* Height of the status "window" (the right part of the screen) */
@@ -40,30 +53,38 @@ extern int ScreenHeight;
 		/* Width of the space "window" (the left part of the screen) */
 #define SPACE_HEIGHT (SCREEN_HEIGHT - (SAFE_Y * 2))
 		/* Height of the space "window" (the left part of the screen) */
-#define SIS_SCREEN_WIDTH (SPACE_WIDTH - 14)
+#define SIS_SCREEN_WIDTH (SPACE_WIDTH - 2 * SIS_ORG_X) // DC: Gray area on the right. just a spacer box
 		/* Width of the usable part of the space "window" */
-#define SIS_SCREEN_HEIGHT (SPACE_HEIGHT - 13)
-		/* Height of the usable part of the space "window" */
-#define RADAR_X (4 + (SCREEN_WIDTH - STATUS_WIDTH - SAFE_X))
-#define RADAR_WIDTH (STATUS_WIDTH - 8)
-#define RADAR_HEIGHT 53
-#define RADAR_Y (SIS_ORG_Y + SIS_SCREEN_HEIGHT - RADAR_HEIGHT)
-
-#define SIS_TITLE_BOX_WIDTH    57
-#define SIS_TITLE_WIDTH        (SIS_TITLE_BOX_WIDTH - 2)
-#define SIS_TITLE_HEIGHT       8
-#define SIS_SPACER_BOX_WIDTH   12
-#define SIS_MESSAGE_BOX_WIDTH  (SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH \
-			- SIS_SPACER_BOX_WIDTH)
+#define SIS_SCREEN_HEIGHT (SPACE_HEIGHT - RES_CASE(3,6,6) - RES_CASE(10,20,30)) // JMS_GFX
+		/* Height of the usable part of the space "window": 3, 6, 6 for the grey bottom border and 10, 20, 30 for the title */
+#define RES_SIS_SCALE(a) ((SIZE)(a) * SIS_SCREEN_WIDTH / 242) // JMS_GFX
+
+
+
+
+				/* Radar. */
+#define RADAR_X (RES_STAT_SCALE(4) + (SCREEN_WIDTH - STATUS_WIDTH - SAFE_X))	// JMS_GFX
+#define RADAR_WIDTH (STATUS_WIDTH - RES_STAT_SCALE(8))							// JMS_GFX
+#define RADAR_HEIGHT RES_STAT_SCALE(53)											// JMS_GFX
+#define RADAR_Y (SIS_ORG_Y + SIS_SCREEN_HEIGHT - (53 << RESOLUTION_FACTOR))		// JMS_GFX
+
+				/* Blue boxes which display messages and the green date box. */
+#define SIS_TITLE_BOX_WIDTH    (57 << RESOLUTION_FACTOR)						// JMS_GFX
+#define SIS_TITLE_WIDTH        (SIS_TITLE_BOX_WIDTH - (2 << RESOLUTION_FACTOR)) // JMS_GFX
+#define SIS_TITLE_HEIGHT       RES_CASE(8,19,29)								// JMS_GFX
+#define SIS_SPACER_BOX_WIDTH   (12 << RESOLUTION_FACTOR)						// JMS_GFX
+
+#define SIS_MESSAGE_BOX_WIDTH  (SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH - SIS_SPACER_BOX_WIDTH)
 #define SIS_MESSAGE_WIDTH      (SIS_MESSAGE_BOX_WIDTH - 2)
 #define SIS_MESSAGE_HEIGHT     SIS_TITLE_HEIGHT
 
-#define STATUS_MESSAGE_WIDTH   (STATUS_WIDTH - 4)
-#define STATUS_MESSAGE_HEIGHT  7
+#define STATUS_MESSAGE_WIDTH   (STATUS_WIDTH - RES_STAT_SCALE(4))				// JMS_GFX
+#define STATUS_MESSAGE_HEIGHT  RES_CASE(7,17,24) // JMS_GFX
 
-#define SHIP_NAME_WIDTH        (STATUS_WIDTH - 4)
-#define SHIP_NAME_HEIGHT       7
+#define SHIP_NAME_WIDTH        (STATUS_WIDTH - RES_STAT_SCALE(4) + RESOLUTION_FACTOR)// JMS_GFX
+#define SHIP_NAME_HEIGHT       RES_STAT_SCALE(7)								// JMS_GFX
 
+				/* A lot of other shit. */
 #define MAX_REDUCTION 3
 #define MAX_VIS_REDUCTION 2
 #define REDUCTION_SHIFT 1
@@ -81,35 +102,94 @@ extern int ScreenHeight;
 #define DISPLAY_ALIGN_X(x) ((COORD)((COUNT)(x)%LOG_SPACE_WIDTH)&~(SCALED_ONE-1))
 #define DISPLAY_ALIGN_Y(y) ((COORD)((COUNT)(y)%LOG_SPACE_HEIGHT)&~(SCALED_ONE-1))
 
-#define LOG_SPACE_WIDTH \
-		(DISPLAY_TO_WORLD (SPACE_WIDTH) << MAX_REDUCTION)
-#define LOG_SPACE_HEIGHT \
-		(DISPLAY_TO_WORLD (SPACE_HEIGHT) << MAX_REDUCTION)
-#define TRANSITION_WIDTH \
-		(DISPLAY_TO_WORLD (SPACE_WIDTH) << MAX_VIS_REDUCTION)
-#define TRANSITION_HEIGHT \
-		(DISPLAY_TO_WORLD (SPACE_HEIGHT) << MAX_VIS_REDUCTION)
+#define LOG_SPACE_WIDTH   (DISPLAY_TO_WORLD (SPACE_WIDTH) << MAX_REDUCTION)
+#define LOG_SPACE_HEIGHT  (DISPLAY_TO_WORLD (SPACE_HEIGHT) << MAX_REDUCTION)
+#define TRANSITION_WIDTH  (DISPLAY_TO_WORLD (SPACE_WIDTH) << MAX_VIS_REDUCTION)
+#define TRANSITION_HEIGHT (DISPLAY_TO_WORLD (SPACE_HEIGHT) << MAX_VIS_REDUCTION)
 		
 #define MAX_X_UNIVERSE 9999
 #define MAX_Y_UNIVERSE 9999
-// Due to the added rounding error correction, the maximum logical X and Y
-// in Hyperspace cannot go past 999.94999, otherwise the values will be
-// rounded up to 1000.0. We do not want that so we subtract half a unit.
 #define MAX_X_LOGICAL \
-		(UNIVERSE_TO_LOGX (MAX_X_UNIVERSE + 1) - (UNIVERSE_TO_LOGX (1) >> 1) \
-			- 1L)
-// The Y axis is inverted with respect to the screen Y axis.
-// (MAX_Y_UNIVERSE - 1) is really 1 for our purposes.
+		((UNIVERSE_TO_LOGX (MAX_X_UNIVERSE + 1) > UNIVERSE_TO_LOGX (-1) ? \
+				UNIVERSE_TO_LOGX (MAX_X_UNIVERSE + 1) : UNIVERSE_TO_LOGX (-1)) - 1L)
 #define MAX_Y_LOGICAL \
-		(UNIVERSE_TO_LOGY (-1) - (UNIVERSE_TO_LOGY (MAX_Y_UNIVERSE - 1) >> 1) \
-			- 1L)
+		((UNIVERSE_TO_LOGY (MAX_Y_UNIVERSE + 1) > UNIVERSE_TO_LOGY (-1) ? \
+				UNIVERSE_TO_LOGY (MAX_Y_UNIVERSE + 1) : UNIVERSE_TO_LOGY (-1)) - 1L)
 
 #define SPHERE_RADIUS_INCREMENT 11
-
 #define MAX_FLEET_STRENGTH (254 * SPHERE_RADIUS_INCREMENT)
 
 // XXX: These corrected for the weird screen aspect ratio on DOS
 //   In part because of them, hyperflight is slower vertically
+#define UNIT_SCREEN_WIDTH ((63 << (COUNT)RESOLUTION_FACTOR) + (COUNT)RESOLUTION_FACTOR * 10) // JMS_GFX
+#define UNIT_SCREEN_HEIGHT ((50 << (COUNT)RESOLUTION_FACTOR) + (COUNT)RESOLUTION_FACTOR * 10) // JMS_GFX
+
+#define NORMALIZED_HYPERSPACE_SPEED // JMS_GFX
+
+// Bug #945: Simplified, these set the speed of SIS in Hyperspace and
+//   Quasispace. The ratio between UNIVERSE_UNITS_ and LOG_UNITS_ is
+//   what sets the speed, and it should be 1:16 to match the original.
+//   The unit factors are reduced to keep the translation math within
+//   32 bits. The original math is unnecessarily complex and depends
+//   on the screen resolution when it should not.
+//   Using the new math will break old savegames.
+#ifdef NORMALIZED_HYPERSPACE_SPEED
+#define LOG_UNITS_X      ((SDWORD)(UNIVERSE_UNITS_X * (16 << RESOLUTION_FACTOR))) // JMS_GFX
+#define LOG_UNITS_Y      ((SDWORD)(UNIVERSE_UNITS_Y * (16 << RESOLUTION_FACTOR))) // JMS_GFX 
+#define UNIVERSE_UNITS_X (((MAX_X_UNIVERSE + 1) >> 4))
+#define UNIVERSE_UNITS_Y (((MAX_Y_UNIVERSE + 1) >> 4))
+#else
+// Original (and now broken) Hyperspace speed factors
+
+#define LOG_UNITS_X      ((SDWORD)(LOG_SPACE_WIDTH >> 4) * SECTOR_WIDTH)
+#define LOG_UNITS_Y      ((SDWORD)(LOG_SPACE_HEIGHT >> 4) * SECTOR_HEIGHT)
+#define UNIVERSE_UNITS_X (((MAX_X_UNIVERSE + 1) >> 4) * 10)
+#define UNIVERSE_UNITS_Y (((MAX_Y_UNIVERSE + 1) >> 4))
+#endif
+
+#define ROUNDING_ERROR(div)  ((div) >> 1)
+
+static inline SDWORD
+logxToUniverse (SDWORD lx)
+{
+	return (SDWORD) ((lx * UNIVERSE_UNITS_X + ROUNDING_ERROR(LOG_UNITS_X))
+					 / LOG_UNITS_X);
+}
+#define LOGX_TO_UNIVERSE(lx) \
+logxToUniverse (lx)
+static inline SDWORD
+logyToUniverse (SDWORD ly)
+{
+	return (SDWORD) (MAX_Y_UNIVERSE -
+					 ((ly * UNIVERSE_UNITS_Y + ROUNDING_ERROR(LOG_UNITS_Y))
+					  / LOG_UNITS_Y));
+}
+#define LOGY_TO_UNIVERSE(ly) \
+logyToUniverse (ly)
+static inline SDWORD
+universeToLogx (COORD ux)
+{
+	return (ux * LOG_UNITS_X + ROUNDING_ERROR(UNIVERSE_UNITS_X))
+	/ UNIVERSE_UNITS_X;
+}
+#define UNIVERSE_TO_LOGX(ux) \
+universeToLogx (ux)
+static inline SDWORD
+universeToLogy (COORD uy)
+{
+	return ((MAX_Y_UNIVERSE - uy) * LOG_UNITS_Y
+			+ ROUNDING_ERROR(UNIVERSE_UNITS_Y))
+	/ UNIVERSE_UNITS_Y;
+}
+#define UNIVERSE_TO_LOGY(uy) \
+universeToLogy (uy)
+
+			/* Here be old junk. */
+/*
+// Hyperspace speed factors (JMS: unused??)
+#define SECTOR_WIDTH (195)
+#define SECTOR_HEIGHT (25)
+
 #define UNIT_SCREEN_WIDTH 63
 #define UNIT_SCREEN_HEIGHT 50
 
@@ -172,6 +252,7 @@ universeToLogy (COORD uy)
 }
 #define UNIVERSE_TO_LOGY(uy) \
 		universeToLogy (uy)
+*/
 
 #define CIRCLE_SHIFT 6
 #define FULL_CIRCLE (1 << CIRCLE_SHIFT)
@@ -207,7 +288,7 @@ extern SIZE sinetab[];
 #define COSINE(a,m) SINE((a)+QUADRANT,m)
 extern COUNT ARCTAN (SIZE delta_x, SIZE delta_y);
 
-#define WRAP_VAL(v,w) ((COUNT)((v)<0?((v)+(w)):((v)>=(w)?((v)-(w)):(v))))
+#define WRAP_VAL(v,w) ((DWORD)((v)<0?((v)+(w)):((v)>=(w)?((v)-(w)):(v)))) // JMS: DWORD was COUNT. Changed to avoid overflows in hires.
 #define WRAP_X(x) WRAP_VAL(x,LOG_SPACE_WIDTH)
 #define WRAP_Y(y) WRAP_VAL(y,LOG_SPACE_HEIGHT)
 #define WRAP_DELTA_X(dx) ((dx)<0 ? \
diff -ruNp src.orig/uqm/uqmdebug.c src/uqm/uqmdebug.c
--- src.orig/uqm/uqmdebug.c	2017-11-01 15:30:29 -0700
+++ src/uqm/uqmdebug.c	2017-11-01 15:31:06 -0700
@@ -1,3 +1,5 @@
+// JMS 2009: Check Orz space in DoInstantMove
+
 /*
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -31,7 +33,6 @@
 #include "gendef.h"
 #include "globdata.h"
 #include "planets/lifeform.h"
-#include "planets/scan.h"
 #include "races.h"
 #include "setup.h"
 #include "state.h"
@@ -74,6 +75,8 @@ BOOLEAN disableInteractivity = FALSE;
 void (* volatile debugHook) (void) = NULL;
 void (* volatile doInputDebugHook) (void) = NULL;
 
+// JMS
+BOOLEAN triangSphereSwitch = FALSE;
 
 void
 debugKeyPressed (void)
@@ -85,26 +88,31 @@ debugKeyPressed (void)
 	// Give the player the ships you can't ally with under normal
 	// conditions.
 	clearEscorts ();
-	ActivateStarShip (ARILOU_SHIP, 1);
+	ActivateStarShip (MYCON_SHIP, 1);
+	ActivateStarShip (ORZ_SHIP, 1);
+	ActivateStarShip (SHOFIXTI_SHIP, 1);
+	ActivateStarShip (SLYLANDRO_SHIP, 1);
+	ActivateStarShip (SPATHI_SHIP, 1);
+	ActivateStarShip (MMRNMHRM_SHIP, 1);
+	/*** No more than 6 escorts for the Explorer
 	ActivateStarShip (PKUNK_SHIP, 1);
+	ActivateStarShip (CHMMR_SHIP, 1);
 	ActivateStarShip (VUX_SHIP, 1);
 	ActivateStarShip (YEHAT_SHIP, 1);
 	ActivateStarShip (MELNORME_SHIP, 1);
-	ActivateStarShip (DRUUGE_SHIP, 1);
-	ActivateStarShip (ILWRATH_SHIP, 1);
-	ActivateStarShip (MYCON_SHIP, 1);
-	ActivateStarShip (SLYLANDRO_SHIP, 1);
-	ActivateStarShip (UMGAH_SHIP, 1);
-	ActivateStarShip (URQUAN_SHIP, 1);
 	ActivateStarShip (BLACK_URQUAN_SHIP, 1);
-
+	****/
+	
 	resetCrewBattle ();
 	resetEnergyBattle ();
 	instantMove = !instantMove;
 	showSpheres ();
 	activateAllShips ();
+	
+	triangSphereSwitch = !triangSphereSwitch;
+	ToggleTriangulationSpheres(triangSphereSwitch);
 //	forwardToNextEvent (TRUE);
-//	SET_GAME_STATE (MELNORME_CREDIT1, 100);
+	SET_GAME_STATE (MELNORME_CREDIT1, 100);
 //	GLOBAL_SIS (ResUnits) = 100000;
 
 	// Tests
@@ -131,6 +139,8 @@ debugKeyPressed (void)
 
 	// Interactive:
 //	uio_debugInteractive(stdin, stdout, stderr);
+
+    DumpAllGameStates();
 }
 
 ////////////////////////////////////////////////////////////////////////////
@@ -281,12 +291,14 @@ equipShip (void)
 			(1 << BIOLOGICAL_DISASTER) |
 			(1 << LIGHTNING_DISASTER) |
 			(1 << LAVASPOT_DISASTER));
-	// Lander upgrades:
-	SET_GAME_STATE (IMPROVED_LANDER_SPEED, 1);
-	SET_GAME_STATE (IMPROVED_LANDER_CARGO, 1);
-	SET_GAME_STATE (IMPROVED_LANDER_SHOT, 1);
+	
+	if(GET_GAME_STATE(IMPROVED_LANDER_SPEED))
+		SET_GAME_STATE (IMPROVED_LANDER_SPEED, 0);
+	else
+		SET_GAME_STATE (IMPROVED_LANDER_SPEED, 1); 
 
 	// Modules:
+	/********  NO MODULES TO EQUIP ON EXPLORER
 	if (GET_GAME_STATE (CHMMR_BOMB_STATE) < 2)
 	{
 		// The Precursor bomb has not been installed.
@@ -325,10 +337,12 @@ equipShip (void)
 	}
 
 	assert (i <= NUM_MODULE_SLOTS);
-
+	****/
+	
 	// Fill the fuel and crew compartments to the maximum.
-	GLOBAL_SIS (FuelOnBoard) = FUEL_RESERVE;
-	GLOBAL_SIS (CrewEnlisted) = 0;
+	GLOBAL_SIS (FuelOnBoard) = EXPLORER_FUEL_CAPACITY;
+	GLOBAL_SIS (CrewEnlisted) = EXPLORER_CREW_CAPACITY;
+
 	for (i = 0; i < NUM_MODULE_SLOTS; i++)
 	{
 		switch (GLOBAL_SIS (ModuleSlots[i])) {
@@ -374,7 +388,6 @@ equipShip (void)
 
 void
 giveDevices (void) {
-	SET_GAME_STATE (ROSY_SPHERE_ON_SHIP, 1);
 	SET_GAME_STATE (ARTIFACT_2_ON_SHIP, 1);
 	SET_GAME_STATE (ARTIFACT_3_ON_SHIP, 1);
 	SET_GAME_STATE (SUN_DEVICE_ON_SHIP, 1);
@@ -383,10 +396,8 @@ giveDevices (void) {
 	//SET_GAME_STATE (ULTRON_CONDITION, 2);
 	//SET_GAME_STATE (ULTRON_CONDITION, 3);
 	//SET_GAME_STATE (ULTRON_CONDITION, 4);
-	SET_GAME_STATE (MAIDENS_ON_SHIP, 1);
 	SET_GAME_STATE (TALKING_PET_ON_SHIP, 1);
 	SET_GAME_STATE (AQUA_HELIX_ON_SHIP, 1);
-	SET_GAME_STATE (CLEAR_SPINDLE_ON_SHIP, 1);
 	SET_GAME_STATE (UMGAH_BROADCASTERS_ON_SHIP, 1);
 	SET_GAME_STATE (TAALO_PROTECTOR_ON_SHIP, 1);
 	SET_GAME_STATE (EGG_CASE0_ON_SHIP, 1);
@@ -397,10 +408,24 @@ giveDevices (void) {
 	SET_GAME_STATE (PORTAL_SPAWNER_ON_SHIP, 1);
 	SET_GAME_STATE (PORTAL_KEY_ON_SHIP, 1);
 	SET_GAME_STATE (BURV_BROADCASTERS_ON_SHIP, 1);
-	SET_GAME_STATE (MOONBASE_ON_SHIP, 1);
+	SET_GAME_STATE (MOONBASE_ON_SHIP, 0);
 	
 	// Not strictly a device (although it originally was one).
 	SET_GAME_STATE (DESTRUCT_CODE_ON_SHIP, 1);
+	
+	// JMS
+	SET_GAME_STATE (BLACK_ORB_ON_SHIP, 1);
+	if (!(GET_GAME_STATE (TEMPORAL_WRAPPER_ON_SHIP)))
+	{
+		SET_GAME_STATE (TEMPORAL_WRAPPER_ON_SHIP, 1);
+	}
+	else
+	{
+		SET_GAME_STATE (TEMPORAL_WRAPPER_ON_SHIP, 0);
+	}
+
+	
+	SET_GAME_STATE (SHIELD_BUSTER_ON_SHIP, 1);
 }
 
 ////////////////////////////////////////////////////////////////////////////
@@ -480,8 +505,8 @@ doInstantMove (void)
 		GLOBAL_SIS (log_y) = UNIVERSE_TO_LOGY((GLOBAL (autopilot)).y);
 	}
 
-	// Check for a solar systems at the destination.
-	if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
+	// Check for a solar systems at the destination. JMS: Orz space side check.
+	if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1 && GET_GAME_STATE (ORZ_SPACE_SIDE) <= 1)
 	{
 		// If there's a solar system at the destination, enter it.
 		CurStarDescPtr = FindStar (0, &(GLOBAL (autopilot)), 0, 0);
@@ -533,6 +558,17 @@ showSpheres (void)
 
 ////////////////////////////////////////////////////////////////////////////
 
+// JMS
+void
+ToggleTriangulationSpheres (BOOLEAN triangSphereSwitch)
+{
+	int onOff = (int)triangSphereSwitch;
+	SET_GAME_STATE (TRIANGULATION_SPHERES_CHMMR, onOff);
+	SET_GAME_STATE (TRIANGULATION_SPHERES_SHOFIXTI, onOff);
+}
+	
+////////////////////////////////////////////////////////////////////////////
+
 void
 activateAllShips (void)
 {
@@ -628,7 +664,7 @@ starRecurse (STAR_DESC *star, void *arg)
 	SOLARSYS_STATE SolarSysState;
 	SOLARSYS_STATE *oldPSolarSysState = pSolarSysState;
 	DWORD oldSeed =
-			TFB_SeedRandom (MAKE_DWORD (star->star_pt.x, star->star_pt.y));
+			TFB_SeedRandom (MAKE_DWORD (star->star_pt.x - 5000, star->star_pt.y - 6000));
 
 	STAR_DESC *oldStarDescPtr = CurStarDescPtr;
 	CurStarDescPtr = star;
@@ -696,7 +732,17 @@ planetRecurse (STAR_DESC *star, SOLARSYS
 	if (universeRecurseArg->moonFunc != NULL)
 	{
 		DWORD oldSeed = TFB_SeedRandom (planet->rand_seed);
-		
+		COUNT i;
+		PLANET_DESC *pMoonDesc;
+
+		for (i = 0, pMoonDesc = &system->MoonDesc[0];
+			i < MAX_MOONS; ++i, ++pMoonDesc)
+		{
+		  pMoonDesc->pPrevDesc = planet;
+		  if (i >= planet->NumPlanets)
+		    continue;
+		}
+
 		(*system->genFuncs->generateMoons) (system, planet);
 
 		forAllMoons (star, system, planet, moonRecurse,
@@ -929,8 +975,6 @@ starPresenceString (BYTE index)
 			return "Zex' beauty";
 		case SAMATRA_DEFINED:
 			return "Sa-Matra";
-		case ZOQ_SCOUT_DEFINED:
-			return "Zoq-Fot-Pik scout";
 		case MYCON_DEFINED:
 			return "Mycon home";
 		case EGG_CASE0_DEFINED:
@@ -1018,6 +1062,7 @@ static void
 dumpWorld (FILE *out, const PLANET_DESC *world)
 {
 	PLANET_INFO *info;
+	//	COUNT bio[NUM_CREATURE_TYPES + NUM_SPECIAL_CREATURE_TYPES + NUM_B_CREATURE_TYPES + NUM_C_CREATURE_TYPES];
 	
 	if (world->data_index == HIERARCHY_STARBASE) {
 		return;
@@ -1046,8 +1091,11 @@ dumpWorld (FILE *out, const PLANET_DESC
 	}
 
 	fprintf (out, "          Bio: %4d    Min: %4d\n",
-			calculateBioValue (pSolarSysState, world),
+		 calculateBioValue (pSolarSysState, world),
 			calculateMineralValue (pSolarSysState, world));
+	//	generateBioIndex(pSolarSysState, world, bio, out);
+	// BW: call this to get a list of critters on each planet
+	// (wrong indexes, probably a wrong type cast or printing)
 }
 
 COUNT
@@ -1059,14 +1107,17 @@ calculateBioValue (const SOLARSYS_STATE
 
 	assert (system->pOrbitalDesc == world);
 	
-	numBio = callGenerateForScanType ((SOLARSYS_STATE *) system,
-			(PLANET_DESC *) world, ~0, BIOLOGICAL_SCAN);
+	((SOLARSYS_STATE *) system)->CurNode = (COUNT)~0;
+	(*system->genFuncs->generateLife) ((SOLARSYS_STATE *) system,
+			(PLANET_DESC *) world, &((SOLARSYS_STATE *) system)->CurNode);
+	numBio = system->CurNode;
 
 	result = 0;
 	for (i = 0; i < numBio; i++)
 	{
-		callGenerateForScanType ((SOLARSYS_STATE *) system,
-				(PLANET_DESC *) world, i, BIOLOGICAL_SCAN);
+		((SOLARSYS_STATE *) system)->CurNode = i;
+		(*system->genFuncs->generateLife) ((SOLARSYS_STATE *) system,
+				(PLANET_DESC *) world, &((SOLARSYS_STATE *) system)->CurNode);
 		result += BIO_CREDIT_VALUE * LONIBBLE (CreatureData[
 				system->SysInfo.PlanetInfo.CurType].ValueAndHitPoints);
 	}
@@ -1074,25 +1125,29 @@ calculateBioValue (const SOLARSYS_STATE
 }
 
 void
-generateBioIndex(const SOLARSYS_STATE *system, const PLANET_DESC *world,
-		COUNT bio[])
+generateBioIndex(const SOLARSYS_STATE *system,
+		 const PLANET_DESC *world, COUNT bio[], FILE *out)
 {
 	COUNT numBio;
 	COUNT i;
 
 	assert (system->pOrbitalDesc == world);
 	
-	numBio = callGenerateForScanType ((SOLARSYS_STATE *) system,
-			(PLANET_DESC *) world, ~0, BIOLOGICAL_SCAN);
+	((SOLARSYS_STATE *) system)->CurNode = (COUNT)~0;
+	(*system->genFuncs->generateLife) ((SOLARSYS_STATE *) system,
+			(PLANET_DESC *) world, &((SOLARSYS_STATE *) system)->CurNode);
+	numBio = system->CurNode;
 
-	for (i = 0; i < NUM_CREATURE_TYPES + NUM_SPECIAL_CREATURE_TYPES; i++)
+	for (i = 0; i < NUM_CREATURE_TYPES + NUM_SPECIAL_CREATURE_TYPES + NUM_B_CREATURE_TYPES + NUM_C_CREATURE_TYPES; i++)
 		bio[i] = 0;
 	
 	for (i = 0; i < numBio; i++)
 	{
-		callGenerateForScanType ((SOLARSYS_STATE *) system,
-				(PLANET_DESC *) world, i, BIOLOGICAL_SCAN);
+		((SOLARSYS_STATE *) system)->CurNode = i;
+		(*system->genFuncs->generateLife) ((SOLARSYS_STATE *) system,
+				(PLANET_DESC *) world, &((SOLARSYS_STATE *) system)->CurNode);
 		bio[system->SysInfo.PlanetInfo.CurType]++;
+		fprintf(out, "Bio type: %4d\n", system->SysInfo.PlanetInfo.CurType);
 	}
 }
 
@@ -1105,14 +1160,17 @@ calculateMineralValue (const SOLARSYS_ST
 
 	assert (system->pOrbitalDesc == world);
 	
-	numDeposits = callGenerateForScanType ((SOLARSYS_STATE *) system,
-			(PLANET_DESC *) world, ~0, MINERAL_SCAN);
+	((SOLARSYS_STATE *) system)->CurNode = (COUNT)~0;
+	(*system->genFuncs->generateMinerals) ((SOLARSYS_STATE *) system,
+			(PLANET_DESC *) world, &((SOLARSYS_STATE *) system)->CurNode);
+	numDeposits = system->CurNode;
 
 	result = 0;
 	for (i = 0; i < numDeposits; i++)
 	{
-		callGenerateForScanType ((SOLARSYS_STATE *) system,
-				(PLANET_DESC *) world, i, MINERAL_SCAN);
+		((SOLARSYS_STATE *) system)->CurNode = i;
+		(*system->genFuncs->generateMinerals) ((SOLARSYS_STATE *) system,
+				(PLANET_DESC *) world, &((SOLARSYS_STATE *) system)->CurNode);
 		result += HIBYTE (system->SysInfo.PlanetInfo.CurDensity) *
 				GLOBAL (ElementWorth[ElementCategory (
 				system->SysInfo.PlanetInfo.CurType)]);
@@ -1129,16 +1187,19 @@ generateMineralIndex(const SOLARSYS_STAT
 
 	assert (system->pOrbitalDesc == world);
 	
-	numDeposits = callGenerateForScanType ((SOLARSYS_STATE *) system,
-			(PLANET_DESC *) world, ~0, MINERAL_SCAN);
+	((SOLARSYS_STATE *) system)->CurNode = (COUNT)~0;
+	(*system->genFuncs->generateMinerals) ((SOLARSYS_STATE *) system,
+			(PLANET_DESC *) world, &((SOLARSYS_STATE *) system)->CurNode);
+	numDeposits = system->CurNode;
 
 	for (i = 0; i < NUM_ELEMENT_CATEGORIES; i++)
 		minerals[i] = 0;
 	
 	for (i = 0; i < numDeposits; i++)
 	{
-		callGenerateForScanType ((SOLARSYS_STATE *) system,
-				(PLANET_DESC *) world, i, MINERAL_SCAN);
+		((SOLARSYS_STATE *) system)->CurNode = i;
+		(*system->genFuncs->generateMinerals) ((SOLARSYS_STATE *) system,
+				(PLANET_DESC *) world, &((SOLARSYS_STATE *) system)->CurNode);
 		minerals[ElementCategory(system->SysInfo.PlanetInfo.CurType)] +=
 				HIBYTE (system->SysInfo.PlanetInfo.CurDensity);
 	}
@@ -1604,7 +1665,7 @@ dumpStrings (FILE *out)
 	
 	if (GAMESTR_COUNT != numStrings) {
 		fprintf(stderr, "Warning: GAMESTR_COUNT is %d, but GameStrings "
-				"contains %d strings.\n", GAMESTR_COUNT, numStrings);
+				"contains %d strings.\n", (int)GAMESTR_COUNT, (int)numStrings);
 	}
 
 	categoryI = 0;
@@ -1613,7 +1674,7 @@ dumpStrings (FILE *out)
 				stringI >= categories[categoryI + 1].base)
 			categoryI++;
 		fprintf(out, "[ %s + %d ]  %s\n", categories[categoryI].name,
-				stringI - categories[categoryI].base, GAME_STRING(stringI));
+				(int)(stringI - categories[categoryI].base), GAME_STRING(stringI));
 	}
 }
 
@@ -1655,6 +1716,7 @@ hsvaToRgba (double hue, double sat, doub
 	return BUILD_COLOR_RGBA (0, 0, 0, alpha);
 }
 
+#ifdef DEBUG
 // Returns true iff this context has a visible FRAME.
 static bool
 isContextVisible (CONTEXT context)
@@ -1776,6 +1838,7 @@ describeContext (FILE *out, const CONTEX
 	
 	SetContext (oldContext);
 }
+#endif
 
 
 typedef struct wait_state
@@ -1830,6 +1893,7 @@ putScreen (FRAME savedFrame) {
 	(void) SetContext (oldContext);
 }
 
+#ifdef DEBUG
 // Show the contexts on the screen.
 // Must be called from the main thread.
 void
@@ -1926,6 +1990,7 @@ debugContexts (void)
 out:
 	inDebugContexts = false;
 }
+#endif
 
 #endif  /* DEBUG */
 
diff -ruNp src.orig/uqm/uqmdebug.h src/uqm/uqmdebug.h
--- src.orig/uqm/uqmdebug.h	2017-11-01 15:30:29 -0700
+++ src/uqm/uqmdebug.h	2017-11-01 15:31:06 -0700
@@ -131,10 +131,10 @@ void generateMineralIndex(const SOLARSYS
 		const PLANET_DESC *world, COUNT minerals[]);
 // Calculate the total value of all bio on a world.
 COUNT calculateBioValue (const SOLARSYS_STATE *system,
-		const PLANET_DESC *world);
+			 const PLANET_DESC *world);
 // Determine how much of each mineral type is present on a world
 void generateBioIndex(const SOLARSYS_STATE *system,
-		const PLANET_DESC *world, COUNT bio[]);
+		      const PLANET_DESC *world, COUNT bio[], FILE *out);
 
 // Tally the resources for each star system.
 void tallyResources (FILE *out);
@@ -185,9 +185,14 @@ extern BOOLEAN instantMove;
 void dumpStrings(FILE *out);
 
 
+// JMS: Toggle shofixt distress site triangulation spheres on / off
+void ToggleTriangulationSpheres (BOOLEAN triangSphereSwitch);
+
+#ifdef DEBUG
 // Graphically and textually show all the contexts.
 // Should be called from debugHook.
 void debugContexts (void);
+#endif
 
 
 // To add some day:
diff -ruNp src.orig/uqm/velocity.c src/uqm/velocity.c
--- src.orig/uqm/velocity.c	2017-11-01 15:30:29 -0700
+++ src/uqm/velocity.c	2017-11-01 15:31:06 -0700
@@ -20,6 +20,7 @@
 
 #include "units.h"
 #include "libs/compiler.h"
+#include "libs/log.h"
 
 
 #define VELOCITY_REMAINDER(v) ((v) & (VELOCITY_SCALE - 1))
@@ -34,28 +35,66 @@ GetCurrentVelocityComponents (VELOCITY_D
 }
 
 void
-GetNextVelocityComponents (VELOCITY_DESC *velocityptr, SIZE *pdx, SIZE *pdy,
-		COUNT num_frames)
+GetCurrentVelocityComponentsSdword (VELOCITY_DESC *velocityptr, SDWORD *pdx, SDWORD *pdy)
+{
+	*pdx = WORLD_TO_VELOCITY (velocityptr->vector.width)
+	+ ((SDWORD)velocityptr->fract.width - (SDWORD)HIBYTE (velocityptr->incr.width));
+	*pdy = WORLD_TO_VELOCITY (velocityptr->vector.height)
+	+ ((SDWORD)velocityptr->fract.height - (SDWORD)HIBYTE (velocityptr->incr.height));
+}
+
+void
+GetNextVelocityComponents (VELOCITY_DESC *velocityptr, SIZE *pdx, SIZE *pdy, COUNT num_frames)
 {
 	COUNT e;
 
 	e = (COUNT)((COUNT)velocityptr->error.width +
 			((COUNT)velocityptr->fract.width * num_frames));
+	
 	*pdx = (velocityptr->vector.width * num_frames)
 			+ ((SIZE)((SBYTE)LOBYTE (velocityptr->incr.width))
 			* (e >> VELOCITY_SHIFT));
+	
 	velocityptr->error.width = VELOCITY_REMAINDER (e);
 
 	e = (COUNT)((COUNT)velocityptr->error.height +
 			((COUNT)velocityptr->fract.height * num_frames));
+	
 	*pdy = (velocityptr->vector.height * num_frames)
 			+ ((SIZE)((SBYTE)LOBYTE (velocityptr->incr.height))
 			* (e >> VELOCITY_SHIFT));
+	
 	velocityptr->error.height = VELOCITY_REMAINDER (e);
 }
 
+// JMS_GFX: New function to prevent overflows in hi-res.
+void
+GetNextVelocityComponentsSdword (VELOCITY_DESC *velocityptr, SDWORD *pdx, SDWORD *pdy, DWORD num_frames)
+{
+	DWORD e;
+	
+	e = (DWORD)((DWORD)velocityptr->error.width +
+				((DWORD)velocityptr->fract.width * num_frames));
+	
+	*pdx = ((SDWORD)velocityptr->vector.width * num_frames)
+	+ ((SDWORD)((SBYTE)LOBYTE (velocityptr->incr.width))
+	   * (e >> VELOCITY_SHIFT));
+	
+	velocityptr->error.width = (COUNT)(VELOCITY_REMAINDER (e));
+	
+	e = (DWORD)((DWORD)velocityptr->error.height +
+				((DWORD)velocityptr->fract.height * num_frames));
+	
+	*pdy = ((SDWORD)velocityptr->vector.height * num_frames)
+	+ ((SDWORD)((SBYTE)LOBYTE (velocityptr->incr.height))
+	   * (e >> VELOCITY_SHIFT));
+	
+	velocityptr->error.height = (COUNT)(VELOCITY_REMAINDER (e));
+}
+
+// JMS_GFX: Preventing overflows in hi-res: The SDWORD in this function's parameters was SIZE.
 void
-SetVelocityVector (VELOCITY_DESC *velocityptr, SIZE magnitude, COUNT facing)
+SetVelocityVector (VELOCITY_DESC *velocityptr, SDWORD magnitude, COUNT facing)
 {
 	COUNT angle;
 	SIZE dx, dy;
@@ -95,8 +134,9 @@ SetVelocityVector (VELOCITY_DESC *veloci
 	velocityptr->error.width = velocityptr->error.height = 0;
 }
 
+// JMS_GFX: Preventing overflows in hi-res: The SDWORDs in this function's parameters were SIZEs.
 void
-SetVelocityComponents (VELOCITY_DESC *velocityptr, SIZE dx, SIZE dy)
+SetVelocityComponents (VELOCITY_DESC *velocityptr, SDWORD dx, SDWORD dy)
 {
 	COUNT angle;
 
@@ -115,8 +155,7 @@ SetVelocityComponents (VELOCITY_DESC *ve
 		{
 			dx = -dx;
 			velocityptr->vector.width = -VELOCITY_TO_WORLD (dx);
-			velocityptr->incr.width =
-					MAKE_WORD ((BYTE)0xFF, (BYTE)(VELOCITY_REMAINDER (dx) << 1));
+			velocityptr->incr.width = MAKE_WORD ((BYTE)0xFF, (BYTE)(VELOCITY_REMAINDER (dx) << 1));
 		}
 		if (dy >= 0)
 		{
@@ -127,8 +166,7 @@ SetVelocityComponents (VELOCITY_DESC *ve
 		{
 			dy = -dy;
 			velocityptr->vector.height = -VELOCITY_TO_WORLD (dy);
-			velocityptr->incr.height =
-					MAKE_WORD ((BYTE)0xFF, (BYTE)(VELOCITY_REMAINDER (dy) << 1));
+			velocityptr->incr.height = MAKE_WORD ((BYTE)0xFF, (BYTE)(VELOCITY_REMAINDER (dy) << 1));
 		}
 
 		velocityptr->fract.width = VELOCITY_REMAINDER (dx);
@@ -139,8 +177,9 @@ SetVelocityComponents (VELOCITY_DESC *ve
 	velocityptr->TravelAngle = angle;
 }
 
+// JMS_GFX: Preventing overflows in hi-res: The SDWORDs in this function's parameters were SIZEs.
 void
-DeltaVelocityComponents (VELOCITY_DESC *velocityptr, SIZE dx, SIZE dy)
+DeltaVelocityComponents (VELOCITY_DESC *velocityptr, SDWORD dx, SDWORD dy)
 {
 
 	dx += WORLD_TO_VELOCITY (velocityptr->vector.width)
diff -ruNp src.orig/uqm/velocity.h src/uqm/velocity.h
--- src.orig/uqm/velocity.h	2017-11-01 15:30:29 -0700
+++ src/uqm/velocity.h	2017-11-01 15:31:06 -0700
@@ -34,16 +34,21 @@ typedef struct velocity_desc
 #define ZeroVelocityComponents(pv) memset(pv,0,sizeof (*(pv)))
 #define GetVelocityTravelAngle(pv) (pv)->TravelAngle
 
-extern void GetCurrentVelocityComponents (VELOCITY_DESC *velocityptr,
-		SIZE *pdx, SIZE *pdy);
-extern void GetNextVelocityComponents (VELOCITY_DESC *velocityptr,
-		SIZE *pdx, SIZE *pdy, COUNT num_frames);
-extern void SetVelocityVector (VELOCITY_DESC *velocityptr, SIZE magnitude,
-		COUNT facing);
-extern void SetVelocityComponents (VELOCITY_DESC *velocityptr, SIZE dx,
-		SIZE dy);
-extern void DeltaVelocityComponents (VELOCITY_DESC *velocityptr, SIZE dx,
-		SIZE dy);
+extern void GetCurrentVelocityComponents (VELOCITY_DESC *velocityptr, SIZE *pdx, SIZE *pdy);
+
+// JMS_GFX: New function to prevent overflows in hi-res.
+extern void GetCurrentVelocityComponentsSdword (VELOCITY_DESC *velocityptr, SDWORD *pdx, SDWORD *pdy);
+
+extern void GetNextVelocityComponents (VELOCITY_DESC *velocityptr, SIZE *pdx, SIZE *pdy, COUNT num_frames);
+
+// JMS_GFX: New function to prevent overflows in hi-res.
+extern void GetNextVelocityComponentsSdword (VELOCITY_DESC *velocityptr, SDWORD *pdx, SDWORD *pdy, DWORD num_frames);
+
+extern void SetVelocityVector (VELOCITY_DESC *velocityptr, SDWORD magnitude, COUNT facing); // JMS_GFX: Changed SIZE to SDWORD to prevent overflows
+
+extern void SetVelocityComponents (VELOCITY_DESC *velocityptr, SDWORD dx, SDWORD dy); // JMS_GFX: Changed SIZE to SDWORD to prevent overflows
+
+extern void DeltaVelocityComponents (VELOCITY_DESC *velocityptr, SDWORD dx, SDWORD dy); // JMS_GFX: Changed SIZE to SDWORD to prevent overflows
 
 static inline BOOLEAN
 IsVelocityZero (VELOCITY_DESC *vptr)
diff -ruNp src.orig/uqm/weapon.c src/uqm/weapon.c
--- src.orig/uqm/weapon.c	2017-11-01 15:30:29 -0700
+++ src/uqm/weapon.c	2017-11-01 15:31:06 -0700
@@ -28,6 +28,7 @@
 #include "sounds.h"
 #include "units.h"
 #include "libs/mathlib.h"
+#include "libs/log.h"
 
 #include <stdio.h>
 
@@ -47,8 +48,7 @@ initialize_laser (LASER_BLOCK *pLaserBlo
 		LaserElementPtr->playerNr = pLaserBlock->sender;
 		LaserElementPtr->hit_points = 1;
 		LaserElementPtr->mass_points = 1;
-		LaserElementPtr->state_flags = APPEARING | FINITE_LIFE
-				| pLaserBlock->flags;
+		LaserElementPtr->state_flags = APPEARING | FINITE_LIFE | pLaserBlock->flags;
 		LaserElementPtr->life_span = LASER_LIFE;
 		LaserElementPtr->collision_func = (CollisionFunc*)weapon_collision;
 		LaserElementPtr->blast_offset = 1;
@@ -60,18 +60,17 @@ initialize_laser (LASER_BLOCK *pLaserBlo
 				+ SINE (FACING_TO_ANGLE (pLaserBlock->face),
 				DISPLAY_TO_WORLD (pLaserBlock->pixoffs));
 		SetPrimType (&DisplayArray[LaserElementPtr->PrimIndex], LINE_PRIM);
-		SetPrimColor (&DisplayArray[LaserElementPtr->PrimIndex],
-				pLaserBlock->color);
+		SetPrimColor (&DisplayArray[LaserElementPtr->PrimIndex], pLaserBlock->color);
 		LaserElementPtr->current.image.frame = DecFrameIndex (stars_in_space);
 		LaserElementPtr->current.image.farray = &stars_in_space;
 		SetVelocityComponents (&LaserElementPtr->velocity,
-				WORLD_TO_VELOCITY ((pLaserBlock->cx + pLaserBlock->ex)
-				- LaserElementPtr->current.location.x),
-				WORLD_TO_VELOCITY ((pLaserBlock->cy + pLaserBlock->ey)
-				- LaserElementPtr->current.location.y));
+			WORLD_TO_VELOCITY ((pLaserBlock->cx + pLaserBlock->ex) - LaserElementPtr->current.location.x),
+			WORLD_TO_VELOCITY ((pLaserBlock->cy + pLaserBlock->ey) - LaserElementPtr->current.location.y));
+		
 		UnlockElement (hLaserElement);
 	}
-
+	
+	
 	return (hLaserElement);
 }
 
@@ -123,8 +122,7 @@ initialize_missile (MISSILE_BLOCK *pMiss
 }
 
 HELEMENT
-weapon_collision (ELEMENT *WeaponElementPtr, POINT *pWPt,
-		ELEMENT *HitElementPtr, POINT *pHPt)
+weapon_collision (ELEMENT *WeaponElementPtr, POINT *pWPt, ELEMENT *HitElementPtr, POINT *pHPt)
 {
 	SIZE damage;
 	HELEMENT hBlastElement;
@@ -133,6 +131,7 @@ weapon_collision (ELEMENT *WeaponElement
 		return ((HELEMENT)0);
 
 	damage = (SIZE)WeaponElementPtr->mass_points;
+	
 	if (damage
 			&& ((HitElementPtr->state_flags & FINITE_LIFE)
 			|| HitElementPtr->life_span == NORMAL_LIFE))
@@ -159,12 +158,10 @@ weapon_collision (ELEMENT *WeaponElement
 			damage = TARGET_DAMAGED_FOR_1_PT + (damage >> 1);
 			if (damage > TARGET_DAMAGED_FOR_6_PLUS_PT)
 				damage = TARGET_DAMAGED_FOR_6_PLUS_PT;
-			ProcessSound (SetAbsSoundIndex (GameSounds, damage),
-					HitElementPtr);
+			ProcessSound (SetAbsSoundIndex (GameSounds, damage), HitElementPtr);
 		}
 
-		if (GetPrimType (&DisplayArray[WeaponElementPtr->PrimIndex])
-				!= LINE_PRIM)
+		if (GetPrimType (&DisplayArray[WeaponElementPtr->PrimIndex]) != LINE_PRIM)
 			WeaponElementPtr->state_flags |= DISAPPEARING;
 
 		WeaponElementPtr->hit_points = 0;
@@ -179,6 +176,7 @@ weapon_collision (ELEMENT *WeaponElement
 			COUNT angle, num_blast_frames;
 			ELEMENT *BlastElementPtr;
 			extern FRAME blast[];
+			STARSHIP *StarShipPtr; // JMS: Added for the ISD fighter lasers
 
 			PutElement (hBlastElement);
 			LockElement (hBlastElement, &BlastElementPtr);
@@ -192,38 +190,39 @@ weapon_collision (ELEMENT *WeaponElement
 			angle = GetVelocityTravelAngle (&WeaponElementPtr->velocity);
 			if ((blast_offs = WeaponElementPtr->blast_offset) > 0)
 			{
-				BlastElementPtr->current.location.x +=
-						COSINE (angle, DISPLAY_TO_WORLD (blast_offs));
-				BlastElementPtr->current.location.y +=
-						SINE (angle, DISPLAY_TO_WORLD (blast_offs));
+				BlastElementPtr->current.location.x += COSINE (angle, DISPLAY_TO_WORLD (blast_offs));
+				BlastElementPtr->current.location.y += SINE (angle, DISPLAY_TO_WORLD (blast_offs));
 			}
 
-			blast_index =
-					NORMALIZE_FACING (ANGLE_TO_FACING (angle + HALF_CIRCLE));
-			blast_index = ((blast_index >> 2) << 1) +
-					(blast_index & 0x3 ? 1 : 0);
-
-			num_blast_frames =
-					GetFrameCount (WeaponElementPtr->next.image.frame);
-			if (num_blast_frames <= ANGLE_TO_FACING (FULL_CIRCLE))
+			blast_index = NORMALIZE_FACING (ANGLE_TO_FACING (angle + HALF_CIRCLE));
+			blast_index = ((blast_index >> 2) << 1) + (blast_index & 0x3 ? 1 : 0);
+
+			num_blast_frames = GetFrameCount (WeaponElementPtr->next.image.frame);
+			
+			GetElementStarShip (WeaponElementPtr, &StarShipPtr); // JMS: Added for the ISD fighter lasers
+			
+			// JMS: Added the ISD clause to allow its fighters to have own graphics for their lasers.
+			// Without this clause the collision effect of the fighter lasers would be buggy.
+			//
+			// Currently, this does prevent ISD's main laser from having separate collision graphics.
+			// Ditto for Foon-foon primary.
+			if (num_blast_frames <= ANGLE_TO_FACING (FULL_CIRCLE) 
+				|| StarShipPtr->SpeciesID == ISD_ID
+				|| StarShipPtr->SpeciesID == FOONFOON_ID
+				|| WeaponElementPtr->blast_offset == 50 << RESOLUTION_FACTOR) // Hack to make dying foon-foon's shots work.
 			{
 				BlastElementPtr->life_span = 2;
 				BlastElementPtr->current.image.farray = blast;
-				BlastElementPtr->current.image.frame =
-						SetAbsFrameIndex (blast[0], blast_index);
+				BlastElementPtr->current.image.frame = SetAbsFrameIndex (blast[0], blast_index);
 			}
 			else
 			{
-				BlastElementPtr->life_span = num_blast_frames
-						- ANGLE_TO_FACING (FULL_CIRCLE);
+				BlastElementPtr->life_span = num_blast_frames - ANGLE_TO_FACING (FULL_CIRCLE);
 				BlastElementPtr->turn_wait = BlastElementPtr->next_turn = 0;
 				BlastElementPtr->preprocess_func = animation_preprocess;
-				BlastElementPtr->current.image.farray =
-						WeaponElementPtr->next.image.farray;
+				BlastElementPtr->current.image.farray = WeaponElementPtr->next.image.farray;
 				BlastElementPtr->current.image.frame =
-						SetAbsFrameIndex (
-						BlastElementPtr->current.image.farray[0],
-						ANGLE_TO_FACING (FULL_CIRCLE));
+						SetAbsFrameIndex (BlastElementPtr->current.image.farray[0], ANGLE_TO_FACING (FULL_CIRCLE));
 			}
 
 			UnlockElement (hBlastElement);
@@ -253,8 +252,8 @@ ModifySilhouette (ELEMENT *ElementPtr, S
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (modify_flags & MODIFY_IMAGE)
 	{
-		ShipIntersect.IntersectStamp.frame = SetAbsFrameIndex (
-				StarShipPtr->RaceDescPtr->ship_info.icons, 1);
+		ShipIntersect.IntersectStamp.frame = SetAbsFrameIndex ( StarShipPtr->RaceDescPtr->ship_info.icons, 1);
+		
 		if (ShipIntersect.IntersectStamp.frame == 0)
 			return (0);
 
@@ -263,6 +262,7 @@ ModifySilhouette (ELEMENT *ElementPtr, S
 		ShipIntersect.IntersectStamp.origin.x = 0;
 		ShipIntersect.IntersectStamp.origin.y = 0;
 		ShipIntersect.EndPoint = ShipIntersect.IntersectStamp.origin;
+		
 		do
 		{
 			ObjectIntersect.IntersectStamp.origin.x = ((COUNT)TFB_Random ()
@@ -276,7 +276,7 @@ ModifySilhouette (ELEMENT *ElementPtr, S
 				&ShipIntersect, MAX_TIME_VALUE));
 
 		ObjectIntersect.IntersectStamp.origin.x += STATUS_WIDTH >> 1;
-		ObjectIntersect.IntersectStamp.origin.y += 31;
+		ObjectIntersect.IntersectStamp.origin.y += (31 << RESOLUTION_FACTOR); // JMS_GFX
 	}
 
 	ObjectIntersect.IntersectStamp.origin.y +=
@@ -286,8 +286,7 @@ ModifySilhouette (ELEMENT *ElementPtr, S
 	{
 		or.corner.x += ObjectIntersect.IntersectStamp.origin.x;
 		or.corner.y += ObjectIntersect.IntersectStamp.origin.y;
-		InitShipStatus (&StarShipPtr->RaceDescPtr->ship_info,
-				StarShipPtr, &or);
+		InitShipStatus (&StarShipPtr->RaceDescPtr->ship_info, StarShipPtr, &or, FALSE);
 	}
 	else
 	{
diff -ruNp src.orig/uqm.c src/uqm.c
--- src.orig/uqm.c	2017-11-01 15:30:29 -0700
+++ src/uqm.c	2017-11-01 15:31:06 -0700
@@ -16,6 +16,13 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2010: If uqm.cfg is not found (running for the first time), start in full-screen mode to prevent color bug on OSX
+// JMS 2011: Originally, the smooth zoom was TFB_SCALE_TRILINEAR instead of bilinear.
+// Using bilinear alleviates the smooth zoom performance choppiness problems in 2x and 4x, but
+// is kinda hacky solution...
+
+// JMS_GFX 2011: Merged resolution Factor stuff from UQM-HD.
+
 #ifdef HAVE_UNISTD_H
 #	include <unistd.h>
 #endif
@@ -55,7 +62,6 @@
 #include "uqm/setup.h"
 #include "uqm/starcon.h"
 
-
 #if defined (GFXMODULE_SDL)
 #	include SDL_INCLUDE(SDL.h)
 			// Including this is actually necessary on OSX.
@@ -127,6 +133,8 @@ struct options_struct
 	DECL_CONFIG_OPTION(float, sfxVolumeScale);
 	DECL_CONFIG_OPTION(float, speechVolumeScale);
 	DECL_CONFIG_OPTION(bool, safeMode);
+	DECL_CONFIG_OPTION(int, resolutionFactor); // JMS_GFX
+	DECL_CONFIG_OPTION(int, loresBlowupScale); // JMS_GFX
 
 #define INIT_CONFIG_OPTION(name, val) \
 	{ val, false }
@@ -155,8 +163,8 @@ static const struct option_list_value sc
 
 static const struct option_list_value meleeScaleList[] = 
 {
-	{"smooth",   TFB_SCALE_TRILINEAR},
-	{"3do",      TFB_SCALE_TRILINEAR},
+	{"smooth",   TFB_SCALE_BILINEAR}, // JMS: Replaced trilinear with bilinear because of performance problems.
+	{"3do",      TFB_SCALE_BILINEAR}, // JMS: Replaced trilinear with bilinear because of performance problems.
 	{"step",     TFB_SCALE_STEP},
 	{"pc",       TFB_SCALE_STEP},
 	{"bilinear", TFB_SCALE_BILINEAR},
@@ -236,7 +244,7 @@ main (int argc, char *argv[])
 		/* .numAddons = */          0,
 
 		INIT_CONFIG_OPTION(  opengl,            false ),
-		INIT_CONFIG_OPTION2( resolution,        640, 480 ),
+		INIT_CONFIG_OPTION2( resolution,        320, 240 ),
 		INIT_CONFIG_OPTION(  fullscreen,        false ),
 		INIT_CONFIG_OPTION(  scanlines,         false ),
 		INIT_CONFIG_OPTION(  scaler,            0 ),
@@ -246,20 +254,22 @@ main (int argc, char *argv[])
 		INIT_CONFIG_OPTION(  soundDriver,       audio_DRIVER_MIXSDL ),
 		INIT_CONFIG_OPTION(  soundQuality,      audio_QUALITY_MEDIUM ),
 		INIT_CONFIG_OPTION(  use3doMusic,       true ),
-		INIT_CONFIG_OPTION(  useRemixMusic,     false ),
+		INIT_CONFIG_OPTION(  usePrecursorsMusic,false ),
 		INIT_CONFIG_OPTION(  whichCoarseScan,   OPT_PC ),
 		INIT_CONFIG_OPTION(  whichMenu,         OPT_PC ),
 		INIT_CONFIG_OPTION(  whichFonts,        OPT_PC ),
 		INIT_CONFIG_OPTION(  whichIntro,        OPT_PC ),
 		INIT_CONFIG_OPTION(  whichShield,       OPT_PC ),
 		INIT_CONFIG_OPTION(  smoothScroll,      OPT_PC ),
-		INIT_CONFIG_OPTION(  meleeScale,        TFB_SCALE_TRILINEAR ),
+		INIT_CONFIG_OPTION(  meleeScale,        TFB_SCALE_BILINEAR ), // JMS: Replaced trilinear with bilinear because of performance problems.
 		INIT_CONFIG_OPTION(  subtitles,         true ),
 		INIT_CONFIG_OPTION(  stereoSFX,         false ),
 		INIT_CONFIG_OPTION(  musicVolumeScale,  1.0f ),
 		INIT_CONFIG_OPTION(  sfxVolumeScale,    1.0f ),
 		INIT_CONFIG_OPTION(  speechVolumeScale, 1.0f ),
 		INIT_CONFIG_OPTION(  safeMode,          false ),
+		INIT_CONFIG_OPTION(  resolutionFactor,  0 ),
+		INIT_CONFIG_OPTION(  loresBlowupScale,  0 ),
 	};
 	struct options_struct defaults = options;
 	int optionsResult;
@@ -287,24 +297,24 @@ main (int argc, char *argv[])
 
 	if (options.runMode == runMode_version)
 	{
- 		printf ("%d.%d.%d%s\n", UQM_MAJOR_VERSION, UQM_MINOR_VERSION,
-				UQM_PATCH_VERSION, UQM_EXTRA_VERSION);
+ 		printf ("%d.%d.%d%s\n", P6014_MAJOR_VERSION, P6014_MINOR_VERSION,
+				P6014_PATCH_VERSION, P6014_EXTRA_VERSION);
 		log_showBox (false, false);
 		return EXIT_SUCCESS;
 	}
 	
-	log_add (log_User, "The Ur-Quan Masters v%d.%d.%d%s (compiled %s %s)\n"
+	log_add (log_User, "The Ur-Quan Masters project6014 v%d.%d.%d%s (compiled %s %s)\n"
 	        "This software comes with ABSOLUTELY NO WARRANTY;\n"
 			"for details see the included 'COPYING' file.\n",
-			UQM_MAJOR_VERSION, UQM_MINOR_VERSION,
-			UQM_PATCH_VERSION, UQM_EXTRA_VERSION,
+			P6014_MAJOR_VERSION, P6014_MINOR_VERSION,
+			P6014_PATCH_VERSION, P6014_EXTRA_VERSION,
 			__DATE__, __TIME__);
 #ifdef NETPLAY
 	log_add (log_User, "Netplay protocol version %d.%d. Netplay opponent "
-			"must have UQM %d.%d.%d or later.",
+			"must have P6014 %d.%d.%d or later.",
 			NETPLAY_PROTOCOL_VERSION_MAJOR, NETPLAY_PROTOCOL_VERSION_MINOR,
-			NETPLAY_MIN_UQM_VERSION_MAJOR, NETPLAY_MIN_UQM_VERSION_MINOR,
-			NETPLAY_MIN_UQM_VERSION_PATCH);
+			NETPLAY_MIN_P6014_VERSION_MAJOR, NETPLAY_MIN_P6014_VERSION_MINOR,
+			NETPLAY_MIN_P6014_VERSION_PATCH);
 #endif
 
 	if (errBuffer[0] != '\0')
@@ -382,7 +392,12 @@ main (int argc, char *argv[])
 	sfxVolumeScale = options.sfxVolumeScale.value;
 	speechVolumeScale = options.speechVolumeScale.value;
 	optAddons = options.addons;
-
+	
+	// JMS_GFX
+	resolutionFactor = (unsigned int) options.resolutionFactor.value; // JMS_GFX
+	loresBlowupScale = (unsigned int) options.loresBlowupScale.value; // JMS_GFX
+	resFactorWasChanged = FALSE;
+	
 	prepareContentDir (options.contentDir, options.addonDir, argv[0]);
 	prepareMeleeDir ();
 	prepareSaveDir ();
@@ -413,8 +428,7 @@ main (int argc, char *argv[])
 		gfxFlags |= TFB_GFXFLAGS_SCANLINES;
 	if (options.showFps.value)
 		gfxFlags |= TFB_GFXFLAGS_SHOWFPS;
-	TFB_InitGraphics (gfxDriver, gfxFlags, options.resolution.width,
-			options.resolution.height);
+	TFB_InitGraphics (gfxDriver, gfxFlags, options.resolution.width, options.resolution.height, resolutionFactor); // JMS_GFX: added resolutionFactor
 	if (options.gamma.set)
 		TFB_SetGamma (options.gamma.value);
 	InitColorMaps ();
@@ -476,6 +490,8 @@ main (int argc, char *argv[])
 		UnInitThreadSystem ();
 		mem_uninit ();
 	}
+
+	log_showBox (false, false);
 	
 	return EXIT_SUCCESS;
 }
@@ -621,8 +637,11 @@ getUserConfigOptions (struct options_str
 	getBoolConfigValue (&options->use3doMusic, "config.3domusic");
 	getBoolConfigValue (&options->useRemixMusic, "config.remixmusic");
 
+	// JMS: Originally, the smooth zoom was TFB_SCALE_TRILINEAR instead of bilinear.
+	// Using bilinear alleviates the smooth zoom performance choppiness problems in 2x and 4x, but
+	// is kinda hacky solution...
 	getBoolConfigValueXlat (&options->meleeScale, "config.smoothmelee",
-			TFB_SCALE_TRILINEAR, TFB_SCALE_STEP);
+			TFB_SCALE_BILINEAR, TFB_SCALE_STEP);
 
 	if (getListConfigValue (&options->soundDriver, "config.audiodriver",
 			audioDriverList))
@@ -640,6 +659,19 @@ getUserConfigOptions (struct options_str
 	getVolumeConfigValue (&options->sfxVolumeScale, "config.sfxvol");
 	getVolumeConfigValue (&options->speechVolumeScale, "config.speechvol");
 	
+	// JMS_GFX
+	if (res_IsInteger ("config.resolutionfactor") && !options->resolutionFactor.set)
+	{
+		options->resolutionFactor.value = res_GetInteger ("config.resolutionfactor");
+		options->resolutionFactor.set = true;
+	}
+	
+	// JMS_GFX
+	if (res_IsInteger ("config.loresBlowupScale"))
+	{
+		options->loresBlowupScale.value = res_GetInteger ("config.loresBlowupScale");
+	}
+	
 	if (res_IsInteger ("config.player1control"))
 	{
 		PlayerControls[0] = res_GetInteger ("config.player1control");
@@ -685,6 +717,7 @@ enum
 	NETPORT2_OPT,
 	NETDELAY_OPT,
 #endif
+	RESFACTOR_OPT, // JMS_GFX
 };
 
 static const char *optString = "+r:foc:b:spC:n:?hM:S:T:m:q:ug:l:i:vwxk";
@@ -732,6 +765,7 @@ static struct option longOptions[] =
 	{"netport2", 1, NULL, NETPORT2_OPT},
 	{"netdelay", 1, NULL, NETDELAY_OPT},
 #endif
+	{"resfactor", 1, NULL, RESFACTOR_OPT}, // JMS_GFX
 	{0, 0, 0, 0}
 };
 
@@ -1050,6 +1084,26 @@ parseOptions (int argc, char *argv[], st
 				break;
 			}
 #endif
+			// JMS_GFX: Added the whole following case. It checks whether the resolutionfactor value is sane.
+			case RESFACTOR_OPT:
+			{
+				int temp;
+				if (parseIntOption (optarg, &temp, "resolution factor")
+					== -1)
+				{
+					badArg = true;
+					break;
+				}
+				options->resolutionFactor.value = temp;
+				
+				if (options->resolutionFactor.value > 2)
+				{
+					saveError ("Resolution factor has to be 0, 1 or 2.");
+					badArg = true;
+				}
+				options->resolutionFactor.set = true;
+				break;
+			}
 			default:
 				saveError ("Error: Unknown option '%s'",
 						optionIndex < 0 ? "<unknown>" :
diff -ruNp src.orig/uqmversion.h src/uqmversion.h
--- src.orig/uqmversion.h	2017-11-01 15:30:29 -0700
+++ src/uqmversion.h	2017-11-01 15:31:06 -0700
@@ -17,22 +17,22 @@
 #ifndef UQMVERSION_H
 #define UQMVERSION_H
 
-#define UQM_MAJOR_VERSION     0
-#define UQM_MAJOR_VERSION_S  "0"
-#define UQM_MINOR_VERSION     7
-#define UQM_MINOR_VERSION_S  "7"
-#define UQM_PATCH_VERSION     0
-#define UQM_PATCH_VERSION_S  "0"
-#define UQM_EXTRA_VERSION    ""
+#define P6014_MAJOR_VERSION     0
+#define P6014_MAJOR_VERSION_S  "0"
+#define P6014_MINOR_VERSION     2
+#define P6014_MINOR_VERSION_S  "2"
+#define P6014_PATCH_VERSION     1
+#define P6014_PATCH_VERSION_S  "1"
+#define P6014_EXTRA_VERSION    ""
 /* The final version is interpreted as:
- * printf ("%d.%d.%d%s", UQM_MAJOR_VERSION, UQM_MINOR_VERSION,
- * 		UQM_PATCH_VERSION, UQM_EXTRA_VERSION);
+ * printf ("%d.%d.%d%s", P6014_MAJOR_VERSION, P6014_MINOR_VERSION,
+ * 		P6014_PATCH_VERSION, P6014_EXTRA_VERSION);
  */
 
-#define UQM_STRING_VERSION \
-		UQM_MAJOR_VERSION_S "." UQM_MINOR_VERSION_S "." UQM_PATCH_VERSION_S \
-		UQM_EXTRA_VERSION
+#define P6014_STRING_VERSION \
+P6014_MAJOR_VERSION_S "." P6014_MINOR_VERSION_S "." P6014_PATCH_VERSION_S \
+P6014_EXTRA_VERSION
 
-#define UQM_SVN_REVISION "$Revision: 3628 $"
+#define P6014_SVN_REVISION "$Revision$"
 
 #endif
