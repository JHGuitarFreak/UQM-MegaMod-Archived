diff -ruNp src.hd/Makeinfo src/Makeinfo
--- src.hd/Makeinfo	2017-12-29 02:25:51 -0800
+++ src/Makeinfo	2017-12-29 00:57:43 -0800
@@ -1,4 +1,6 @@
 uqm_SUBDIRS="libs res uqm"
+uqm_CFILES="options.c port.c uqm.c"
+uqm_HFILES="config.h endian_uqm.h options.h port.h types.h uqmversion.h"
 
 if [ "$uqm_HAVE_GETOPT_LONG" = 0 ]; then
 	uqm_SUBDIRS="$uqm_SUBDIRS getopt"
@@ -8,11 +10,12 @@ case "$HOST_SYSTEM" in
 	Darwin)
 		uqm_SUBDIRS="$uqm_SUBDIRS darwin"
 		;;
+	MSVC)
+		uqm_HFILES="$uqm_HFILES config_vc6.h"
+		;;
 esac
 
 if [ "$uqm_HAVE_REGEX" = 0 ]; then
 	uqm_SUBDIRS="$uqm_SUBDIRS regex"
 fi
 
-uqm_CFILES="options.c port.c uqm.c"
-
diff -ruNp src.hd/config_unix.h.in src/config_unix.h.in
--- src.hd/config_unix.h.in	2017-12-29 02:25:48 -0800
+++ src/config_unix.h.in	2017-12-29 00:57:38 -0800
@@ -14,7 +14,7 @@
 #define CONTENTDIR "@CONTENTDIR@"
 
 /* Directory where game data will be stored */
-#define USERDIR "~/.uqmhd/"
+#define USERDIR "~/.uqm/"
 
 /* Directory where config files will be stored */
 #define CONFIGDIR USERDIR
diff -ruNp src.hd/config_vc6.h src/config_vc6.h
--- src.hd/config_vc6.h	2017-12-29 02:25:48 -0800
+++ src/config_vc6.h	2017-12-29 00:57:38 -0800
@@ -15,7 +15,7 @@
 
 /* Directory where game data will be stored */
 //#define USERDIR "../userdata/"
-#define USERDIR "%APPDATA%/uqmhd/"
+#define USERDIR "%APPDATA%/uqm-080-hd/"
 
 /* Directory where config files will be stored */
 #define CONFIGDIR USERDIR
diff -ruNp src.hd/config_win.h.in src/config_win.h.in
--- src.hd/config_win.h.in	2017-12-29 02:25:48 -0800
+++ src/config_win.h.in	2017-12-29 00:57:38 -0800
@@ -15,7 +15,7 @@
 
 /* Directory where game data will be stored */
 //#define USERDIR "../userdata/"
-#define USERDIR "%APPDATA%/uqmhd/"
+#define USERDIR "%APPDATA%/uqm/"
 
 /* Directory where config files will be stored */
 #define CONFIGDIR USERDIR
diff -ruNp src.hd/darwin/Makeinfo src/darwin/Makeinfo
--- src.hd/darwin/Makeinfo	2017-12-29 02:25:48 -0800
+++ src/darwin/Makeinfo	2017-12-29 00:57:38 -0800
@@ -1,2 +1,2 @@
 uqm_MFILES="SDLMain.m"
-
+uqm_HFILES="SDLMain.h"
diff -ruNp src.hd/darwin/SDLMain.h src/darwin/SDLMain.h
--- src.hd/darwin/SDLMain.h	2017-12-29 02:25:48 -0800
+++ src/darwin/SDLMain.h	2017-12-29 00:57:38 -0800
@@ -1,26 +1,23 @@
-/*	SDLMain.m - main entry point for our Cocoa-ized SDL app
-	Initial Version: Darrell Walisser <dwaliss1@purdue.edu>
-	Non-NIB-Code & other changes: Max Horn <max@quendi.de>
+/*   SDLMain.m - main entry point for our Cocoa-ized SDL app
+       Initial Version: Darrell Walisser <dwaliss1@purdue.edu>
+       Non-NIB-Code & other changes: Max Horn <max@quendi.de>
 
-	Feel free to customize this file to suit your needs
+    Feel free to customize this file to suit your needs
 */
 
-#import <Cocoa/Cocoa.h>
+#ifndef _SDLMain_h_
+#define _SDLMain_h_
 
-/* An internal Apple class used to setup Apple menus */
-@interface NSAppleMenuController:NSObject {}
-- (void)controlMenu:(NSMenu *)aMenu;
-@end
+#import <Cocoa/Cocoa.h>
 
 @interface SDLMain : NSObject
 @end
 
-@interface SDLApplication : NSApplication
-@end
-
 /* For some reaon, Apple removed setAppleMenu from the headers in 10.4,
  but the method still is there and works. To avoid warnings, we declare
  it ourselves here. */
 @interface NSApplication(SDL_Missing_Methods)
 - (void)setAppleMenu:(NSMenu *)menu;
 @end
+
+#endif /* _SDLMain_h_ */
diff -ruNp src.hd/darwin/SDLMain.m src/darwin/SDLMain.m
--- src.hd/darwin/SDLMain.m	2017-12-29 02:25:48 -0800
+++ src/darwin/SDLMain.m	2017-12-29 00:57:38 -0800
@@ -1,285 +1,381 @@
-/*	SDLMain.m - main entry point for our Cocoa-ized SDL app
-	Initial Version: Darrell Walisser <dwaliss1@purdue.edu>
-	Non-NIB-Code & other changes: Max Horn <max@quendi.de>
+/*   SDLMain.m - main entry point for our Cocoa-ized SDL app
+       Initial Version: Darrell Walisser <dwaliss1@purdue.edu>
+       Non-NIB-Code & other changes: Max Horn <max@quendi.de>
 
-	Feel free to customize this file to suit your needs
-
-	Modified for use with The Ur-Quan Masters by Nicolas Simonds
-	<uqm at submedia dot net>
+    Feel free to customize this file to suit your needs
 */
 
-#import "port.h"
-#import SDL_INCLUDE(SDL.h)
-#import "SDLMain.h"
-#import <sys/param.h>
-		/* for PATH_MAX */
-#import <string.h>
-		/* for strrchr() */
-#import <unistd.h>
-
-static int gArgc;
-static char **gArgv;
-static BOOL gFinderLaunch;
-
-@implementation SDLApplication
-/* Invoked from the Quit menu item */
-- (void)terminate:(id)sender
-{
-	/* Post a SDL_QUIT event */
-	SDL_Event event;
-	event.type = SDL_QUIT;
-	SDL_PushEvent (&event);
-	(void) sender;  /* Get rid of unused variable warning */
-}
-
-/* override NSApplication:sendEvent, to keep Cocoa from beeping on
-   non-command keystrokes */
-- (void)sendEvent:(NSEvent *)anEvent {
-	if (NSKeyDown == [anEvent type] || NSKeyUp == [anEvent type]) {
-		if ([anEvent modifierFlags] & NSCommandKeyMask)
-			[super sendEvent: anEvent];
-	} else
-		[super sendEvent: anEvent];
-}
+#include "SDL.h"
+#include "SDLMain.h"
+#include <sys/param.h> /* for MAXPATHLEN */
+#include <unistd.h>
+
+/* For some reaon, Apple removed setAppleMenu from the headers in 10.4,
+ but the method still is there and works. To avoid warnings, we declare
+ it ourselves here. */
+@interface NSApplication(SDL_Missing_Methods)
+- (void)setAppleMenu:(NSMenu *)menu;
 @end
 
-/* The main class of the application, the application's delegate */
-@implementation SDLMain
+/* Use this flag to determine whether we use SDLMain.nib or not */
+#define		SDL_USE_NIB_FILE	0
 
-static char *
-basename (char *path)
+/* Use this flag to determine whether we use CPS (docking) or not */
+#define		SDL_USE_CPS		1
+#ifdef SDL_USE_CPS
+/* Portions of CPS.h */
+typedef struct CPSProcessSerNum
 {
-	char *base;
-
-	base = strrchr (path, '/');
-	if (base == NULL)
-		return path;
+	UInt32		lo;
+	UInt32		hi;
+} CPSProcessSerNum;
+
+extern OSErr	CPSGetCurrentProcess( CPSProcessSerNum *psn);
+extern OSErr 	CPSEnableForegroundOperation( CPSProcessSerNum *psn, UInt32 _arg2, UInt32 _arg3, UInt32 _arg4, UInt32 _arg5);
+extern OSErr	CPSSetFrontProcess( CPSProcessSerNum *psn);
+
+#endif /* SDL_USE_CPS */
+
+static int    gArgc;
+static char  **gArgv;
+static BOOL   gFinderLaunch;
+static BOOL   gCalledAppMainline = FALSE;
 
-	return (base + 1);
-}
-
-/* Set the working directory to the .app's parent directory */
-- (void) setupWorkingDirectory:(BOOL)shouldChdir
+static NSString *getApplicationName(void)
 {
-	char origindir[PATH_MAX];
-	char *c;
-
-	if (!shouldChdir)
-		return;
+    const NSDictionary *dict;
+    NSString *appName = 0;
 
-	strncpy (origindir, gArgv[0], sizeof origindir);
-	origindir[sizeof origindir - 1] = '\0';
+    /* Determine the application name */
+    dict = (const NSDictionary *)CFBundleGetInfoDictionary(CFBundleGetMainBundle());
+    if (dict)
+        appName = [dict objectForKey: @"CFBundleName"];
+    
+    if (![appName length])
+        appName = [[NSProcessInfo processInfo] processName];
 
-	c = basename (origindir);
-	if (c == origindir)
-		strcpy (origindir, ".");
-	else
-		*c = '\0';
-
-	/* chdir to the binary app's point of origin */
-	if (chdir (origindir) != 0)
-		abort ();
-	/* then chdir to the .app's parent */
-	if ( chdir ("../Resources/") != 0 )
-		abort();
+    return appName;
 }
 
-void
-setupAppleMenu (void)
-{
-	NSMenu *appleMenu;
-
-	NSMenuItem *menuItem;
-	NSString *title;
-	NSString *appName;
-
-	appName = [NSString stringWithUTF8String:basename (gArgv[0])];
-	appleMenu = [[NSMenu alloc] initWithTitle:appName];
+#if SDL_USE_NIB_FILE
+/* A helper category for NSString */
+@interface NSString (ReplaceSubString)
+- (NSString *)stringByReplacingRange:(NSRange)aRange with:(NSString *)aString;
+@end
+#endif
 
-	/* Add menu items */
-	title = [@"Hide " stringByAppendingString:appName];
-	[appleMenu addItemWithTitle:title action:@selector(hide:)
-			keyEquivalent:@"h"];
+@interface NSApplication (SDLApplication)
+@end
 
-	menuItem = (NSMenuItem *)[appleMenu addItemWithTitle:@"Hide Others"
-			action:@selector(hideOtherApplications:)
-			keyEquivalent:@"h"];
-	[menuItem setKeyEquivalentModifierMask:(NSAlternateKeyMask|NSCommandKeyMask)];
+@implementation NSApplication (SDLApplication)
+/* Invoked from the Quit menu item */
+- (void)terminate:(id)sender
+{
+    /* Post a SDL_QUIT event */
+    SDL_Event event;
+    event.type = SDL_QUIT;
+    SDL_PushEvent(&event);
+}
+@end
 
-	[appleMenu addItemWithTitle:@"Show All"
-			action:@selector(unhideAllApplications:)
-			keyEquivalent:@""];
+/* The main class of the application, the application's delegate */
+@implementation SDLMain
 
-	[appleMenu addItem:[NSMenuItem separatorItem]];
+/* Set the working directory to the .app's parent directory */
+- (void) setupWorkingDirectory:(BOOL)shouldChdir
+{
+    if (shouldChdir)
+    {
+        char parentdir[MAXPATHLEN];
+        CFURLRef url = CFBundleCopyBundleURL(CFBundleGetMainBundle());
+        CFURLRef url2 = CFURLCreateCopyDeletingLastPathComponent(0, url);
+        if (CFURLGetFileSystemRepresentation(url2, 1, (UInt8 *)parentdir, MAXPATHLEN)) {
+            chdir(parentdir);   /* chdir to the binary app's parent */
+        }
+        CFRelease(url);
+        CFRelease(url2);
+    }
+}
 
-	title = [@"Quit " stringByAppendingString:appName];
-	[appleMenu addItemWithTitle:title action:@selector(terminate:)
-			keyEquivalent:@"q"];
+#if SDL_USE_NIB_FILE
 
-	/* Put menu into the menubar */
-	menuItem = [[NSMenuItem alloc] initWithTitle:@"" action:nil
-			keyEquivalent:@""];
-	[menuItem setSubmenu:appleMenu];
-	[[NSApp mainMenu] addItem:menuItem];
+/* Fix menu to contain the real app name instead of "SDL App" */
+- (void)fixMenu:(NSMenu *)aMenu withAppName:(NSString *)appName
+{
+    NSRange aRange;
+    NSEnumerator *enumerator;
+    NSMenuItem *menuItem;
+
+    aRange = [[aMenu title] rangeOfString:@"SDL App"];
+    if (aRange.length != 0)
+        [aMenu setTitle: [[aMenu title] stringByReplacingRange:aRange with:appName]];
+
+    enumerator = [[aMenu itemArray] objectEnumerator];
+    while ((menuItem = [enumerator nextObject]))
+    {
+        aRange = [[menuItem title] rangeOfString:@"SDL App"];
+        if (aRange.length != 0)
+            [menuItem setTitle: [[menuItem title] stringByReplacingRange:aRange with:appName]];
+        if ([menuItem hasSubmenu])
+            [self fixMenu:[menuItem submenu] withAppName:appName];
+    }
+}
 
-	/* Tell the application object that this is now the application menu */
-	[NSApp setAppleMenu:appleMenu];
+#else
 
-	/* Finally give up our references to the objects */
-	[appleMenu release];
-	[menuItem release];
+static void setApplicationMenu(void)
+{
+    /* warning: this code is very odd */
+    NSMenu *appleMenu;
+    NSMenuItem *menuItem;
+    NSString *title;
+    NSString *appName;
+    
+    appName = getApplicationName();
+    appleMenu = [[NSMenu alloc] initWithTitle:@""];
+    
+    /* Add menu items */
+    title = [@"About " stringByAppendingString:appName];
+    [appleMenu addItemWithTitle:title action:@selector(orderFrontStandardAboutPanel:) keyEquivalent:@""];
+
+    [appleMenu addItem:[NSMenuItem separatorItem]];
+
+    title = [@"Hide " stringByAppendingString:appName];
+    [appleMenu addItemWithTitle:title action:@selector(hide:) keyEquivalent:@"h"];
+
+    menuItem = (NSMenuItem *)[appleMenu addItemWithTitle:@"Hide Others" action:@selector(hideOtherApplications:) keyEquivalent:@"h"];
+    [menuItem setKeyEquivalentModifierMask:(NSAlternateKeyMask|NSCommandKeyMask)];
+
+    [appleMenu addItemWithTitle:@"Show All" action:@selector(unhideAllApplications:) keyEquivalent:@""];
+
+    [appleMenu addItem:[NSMenuItem separatorItem]];
+
+    title = [@"Quit " stringByAppendingString:appName];
+    [appleMenu addItemWithTitle:title action:@selector(terminate:) keyEquivalent:@"q"];
+
+    
+    /* Put menu into the menubar */
+    menuItem = [[NSMenuItem alloc] initWithTitle:@"" action:nil keyEquivalent:@""];
+    [menuItem setSubmenu:appleMenu];
+    [[NSApp mainMenu] addItem:menuItem];
+
+    /* Tell the application object that this is now the application menu */
+    [NSApp setAppleMenu:appleMenu];
+
+    /* Finally give up our references to the objects */
+    [appleMenu release];
+    [menuItem release];
 }
 
 /* Create a window menu */
-void
-setupWindowMenu (void)
+static void setupWindowMenu(void)
 {
-	NSMenu *windowMenu;
-	NSMenuItem *windowMenuItem;
-	NSMenuItem *menuItem;
-
-	windowMenu = [[NSMenu alloc] initWithTitle:@"Window"];
-
-	/* "Minimize" item */
-	menuItem = [[NSMenuItem alloc] initWithTitle:@"Minimize"
-			action:@selector(performMiniaturize:)
-			keyEquivalent:@"m"];
-	[windowMenu addItem:menuItem];
-	[menuItem release];
-
-	/* Put menu into the menubar */
-	windowMenuItem = [[NSMenuItem alloc] initWithTitle:@"Window"
-			action:nil keyEquivalent:@""];
-	[windowMenuItem setSubmenu:windowMenu];
-	[[NSApp mainMenu] addItem:windowMenuItem];
-
-	/* Tell the application object that this is now the window menu */
-	[NSApp setWindowsMenu:windowMenu];
-
-	/* Finally give up our references to the objects */
-	[windowMenu release];
-	[windowMenuItem release];
+    NSMenu      *windowMenu;
+    NSMenuItem  *windowMenuItem;
+    NSMenuItem  *menuItem;
+
+    windowMenu = [[NSMenu alloc] initWithTitle:@"Window"];
+    
+    /* "Minimize" item */
+    menuItem = [[NSMenuItem alloc] initWithTitle:@"Minimize" action:@selector(performMiniaturize:) keyEquivalent:@"m"];
+    [windowMenu addItem:menuItem];
+    [menuItem release];
+    
+    /* Put menu into the menubar */
+    windowMenuItem = [[NSMenuItem alloc] initWithTitle:@"Window" action:nil keyEquivalent:@""];
+    [windowMenuItem setSubmenu:windowMenu];
+    [[NSApp mainMenu] addItem:windowMenuItem];
+    
+    /* Tell the application object that this is now the window menu */
+    [NSApp setWindowsMenu:windowMenu];
+
+    /* Finally give up our references to the objects */
+    [windowMenu release];
+    [windowMenuItem release];
 }
 
 /* Replacement for NSApplicationMain */
-void
-CustomApplicationMain (int argc, char **argv)
+static void CustomApplicationMain (int argc, char **argv)
 {
-	NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
-	SDLMain *sdlMain;
-
-	/* Ensure the application object is initialised */
-	[SDLApplication sharedApplication];
-
-	/* Set up the menubar */
-	[NSApp setMainMenu:[[NSMenu alloc] init]];
-	setupAppleMenu ();
-	setupWindowMenu ();
+    NSAutoreleasePool	*pool = [[NSAutoreleasePool alloc] init];
+    SDLMain				*sdlMain;
 
-	/* Create SDLMain and make it the app delegate */
-	sdlMain = [[SDLMain alloc] init];
-	[NSApp setDelegate:sdlMain];
+    /* Ensure the application object is initialised */
+    [NSApplication sharedApplication];
+    
+#ifdef SDL_USE_CPS
+    {
+        CPSProcessSerNum PSN;
+        /* Tell the dock about us */
+        if (!CPSGetCurrentProcess(&PSN))
+            if (!CPSEnableForegroundOperation(&PSN,0x03,0x3C,0x2C,0x1103))
+                if (!CPSSetFrontProcess(&PSN))
+                    [NSApplication sharedApplication];
+    }
+#endif /* SDL_USE_CPS */
+
+    /* Set up the menubar */
+    [NSApp setMainMenu:[[NSMenu alloc] init]];
+    setApplicationMenu();
+    setupWindowMenu();
+
+    /* Create SDLMain and make it the app delegate */
+    sdlMain = [[SDLMain alloc] init];
+    [NSApp setDelegate:sdlMain];
+    
+    /* Start the main event loop */
+    [NSApp run];
+    
+    [sdlMain release];
+    [pool release];
+}
 
-	/* Start the main event loop */
-	[NSApp run];
+#endif
 
-	[sdlMain release];
-	[pool release];
 
-	(void) argc;  /* Get rid of unused variable warning */
-	(void) argv;  /* Get rid of unused variable warning */
+/*
+ * Catch document open requests...this lets us notice files when the app
+ *  was launched by double-clicking a document, or when a document was
+ *  dragged/dropped on the app's icon. You need to have a
+ *  CFBundleDocumentsType section in your Info.plist to get this message,
+ *  apparently.
+ *
+ * Files are added to gArgv, so to the app, they'll look like command line
+ *  arguments. Previously, apps launched from the finder had nothing but
+ *  an argv[0].
+ *
+ * This message may be received multiple times to open several docs on launch.
+ *
+ * This message is ignored once the app's mainline has been called.
+ */
+- (BOOL)application:(NSApplication *)theApplication openFile:(NSString *)filename
+{
+    const char *temparg;
+    size_t arglen;
+    char *arg;
+    char **newargv;
+
+    if (!gFinderLaunch)  /* MacOS is passing command line args. */
+        return FALSE;
+
+    if (gCalledAppMainline)  /* app has started, ignore this document. */
+        return FALSE;
+
+    temparg = [filename UTF8String];
+    arglen = SDL_strlen(temparg) + 1;
+    arg = (char *) SDL_malloc(arglen);
+    if (arg == NULL)
+        return FALSE;
+
+    newargv = (char **) realloc(gArgv, sizeof (char *) * (gArgc + 2));
+    if (newargv == NULL)
+    {
+        SDL_free(arg);
+        return FALSE;
+    }
+    gArgv = newargv;
+
+    SDL_strlcpy(arg, temparg, arglen);
+    gArgv[gArgc++] = arg;
+    gArgv[gArgc] = NULL;
+    return TRUE;
 }
 
+
 /* Called when the internal event loop has just started running */
 - (void) applicationDidFinishLaunching: (NSNotification *) note
 {
-	int status;
-
-	/* Set the working directory to the .app's parent directory */
-	[self setupWorkingDirectory:gFinderLaunch];
+    int status;
 
-	/* allow Cocoa to hear keystrokes like Command-Q, etc. */
-	setenv ("SDL_ENABLEAPPEVENTS", "1", 1);
+    /* Set the working directory to the .app's parent directory */
+    [self setupWorkingDirectory:gFinderLaunch];
 
-	/* Hand off to main application code */
-	status = SDL_main (gArgc, gArgv);
+#if SDL_USE_NIB_FILE
+    /* Set the main menu to contain the real app name instead of "SDL App" */
+    [self fixMenu:[NSApp mainMenu] withAppName:getApplicationName()];
+#endif
 
-	/* We're done, thank you for playing */
-	exit (status);
+    /* Hand off to main application code */
+    gCalledAppMainline = TRUE;
+    status = SDL_main (gArgc, gArgv);
 
-	(void) note;  /* Get rid of unused variable warning */
+    /* We're done, thank you for playing */
+    exit(status);
 }
 @end
 
+
 @implementation NSString (ReplaceSubString)
 
-- (NSString *) stringByReplacingRange:(NSRange)aRange with:(NSString *)aString
+- (NSString *)stringByReplacingRange:(NSRange)aRange with:(NSString *)aString
 {
-	unsigned int bufferSize;
-	unsigned int selfLen = [self length];
-	unsigned int aStringLen = [aString length];
-	unichar *buffer;
-	NSRange localRange;
-	NSString *result;
-
-	bufferSize = selfLen + aStringLen - aRange.length;
-	buffer = NSAllocateMemoryPages (bufferSize * sizeof (unichar));
-
-	/* Get first part into buffer */
-	localRange.location = 0;
-	localRange.length = aRange.location;
-	[self getCharacters:buffer range:localRange];
-
-	/* Get middle part into buffer */
-	localRange.location = 0;
-	localRange.length = aStringLen;
-	[aString getCharacters:(buffer + aRange.location) range:localRange];
-
-	/* Get last part into buffer */
-	localRange.location = aRange.location + aRange.length;
-	localRange.length = selfLen - localRange.location;
-	[self getCharacters:(buffer + aRange.location+aStringLen)
-			range:localRange];
-
-	/* Build output string */
-	result = [NSString stringWithCharacters:buffer length:bufferSize];
-
-	NSDeallocateMemoryPages (buffer, bufferSize);
-
-	return result;
+    unsigned int bufferSize;
+    unsigned int selfLen = [self length];
+    unsigned int aStringLen = [aString length];
+    unichar *buffer;
+    NSRange localRange;
+    NSString *result;
+
+    bufferSize = selfLen + aStringLen - aRange.length;
+    buffer = (unichar *)NSAllocateMemoryPages(bufferSize*sizeof(unichar));
+    
+    /* Get first part into buffer */
+    localRange.location = 0;
+    localRange.length = aRange.location;
+    [self getCharacters:buffer range:localRange];
+    
+    /* Get middle part into buffer */
+    localRange.location = 0;
+    localRange.length = aStringLen;
+    [aString getCharacters:(buffer+aRange.location) range:localRange];
+     
+    /* Get last part into buffer */
+    localRange.location = aRange.location + aRange.length;
+    localRange.length = selfLen - localRange.location;
+    [self getCharacters:(buffer+aRange.location+aStringLen) range:localRange];
+    
+    /* Build output string */
+    result = [NSString stringWithCharacters:buffer length:bufferSize];
+    
+    NSDeallocateMemoryPages(buffer, bufferSize);
+    
+    return result;
 }
 
 @end
 
+
+
 #ifdef main
 #  undef main
 #endif
 
+
 /* Main entry point to executable - should *not* be SDL_main! */
-int
-main (int argc, char **argv)
+int main (int argc, char **argv)
 {
-	/* Copy the arguments into a global variable */
-	int i;
-
-	/* If we are launched by double-clicking, argv[1] is "-psn_<some_number> */
-	if ( argc >= 2 && strncmp (argv[1], "-psn_", 5) == 0 ) {
-		gArgc = 1;
-		gFinderLaunch = YES;
-	} else {
-		gArgc = argc;
-		gFinderLaunch = NO;
-	}
-	gArgv = (char **) malloc (sizeof *gArgv * (gArgc + 1));
-	if (gArgv == NULL)
-		abort ();
-	for (i = 0; i < gArgc; i++)
-		gArgv[i] = argv[i];
-	gArgv[i] = NULL;
-
-	CustomApplicationMain (argc, argv);
-	free (gArgv);
-	return 0;
+    /* Copy the arguments into a global variable */
+    /* This is passed if we are launched by double-clicking */
+    if ( argc >= 2 && strncmp (argv[1], "-psn", 4) == 0 ) {
+        gArgv = (char **) SDL_malloc(sizeof (char *) * 2);
+        gArgv[0] = argv[0];
+        gArgv[1] = NULL;
+        gArgc = 1;
+        gFinderLaunch = YES;
+    } else {
+        int i;
+        gArgc = argc;
+        gArgv = (char **) SDL_malloc(sizeof (char *) * (argc+1));
+        for (i = 0; i <= argc; i++)
+            gArgv[i] = argv[i];
+        gFinderLaunch = NO;
+    }
+
+#if SDL_USE_NIB_FILE
+    NSApplicationMain (argc, argv);
+#else
+    CustomApplicationMain (argc, argv);
+#endif
+    return 0;
 }
 
-
diff -ruNp src.hd/endian_uqm.h src/endian_uqm.h
--- src.hd/endian_uqm.h	2017-12-29 02:25:48 -0800
+++ src/endian_uqm.h	2017-12-29 00:57:38 -0800
@@ -61,6 +61,11 @@
 #define UQM_Swap32  __arch__swab32
 #endif
 #endif /* linux */
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 /* Use inline functions for compilers that support them, and static
    functions for those that do not.  Because these functions become
    static for compilers that do not support inline functions, this
@@ -124,4 +129,8 @@ static __inline__ uint64 UQM_Swap64(uint
 #define UQM_SwapBE64(X)	(X)
 #endif
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _ENDIAN_H */
diff -ruNp src.hd/getopt/Makeinfo src/getopt/Makeinfo
--- src.hd/getopt/Makeinfo	2017-12-29 02:25:48 -0800
+++ src/getopt/Makeinfo	2017-12-29 00:57:38 -0800
@@ -1 +1,2 @@
 uqm_CFILES="getopt.c getopt1.c"
+uqm_HFILES="getopt.h"
diff -ruNp src.hd/libs/Makeinfo src/libs/Makeinfo
--- src.hd/libs/Makeinfo	2017-12-29 02:25:49 -0800
+++ src/libs/Makeinfo	2017-12-29 00:57:40 -0800
@@ -1,9 +1,13 @@
 uqm_SUBDIRS="callback decomp file graphics heap input list math memory
-		resource sound strings task threads time uio video log"
+		resource sound strings task threads time uio video log luauqm"
 if [ -n "$uqm_USE_INTERNAL_MIKMOD" ]; then
 	uqm_SUBDIRS="$uqm_SUBDIRS mikmod"
 fi
 
+if [ -n "$uqm_USE_INTERNAL_LUA" ]; then
+	uqm_SUBDIRS="$uqm_SUBDIRS lua"
+fi
+
 if [ -n "$uqm_NETPLAY" ]; then
 	uqm_SUBDIRS="$uqm_SUBDIRS network"
 fi
@@ -12,3 +16,9 @@ fi
 #	uqm_SUBDIRS="$UQM_SUBDIRS debug"
 #fi
 
+uqm_HFILES="alarm.h async.h callback.h cdplib.h compiler.h declib.h file.h
+		gfxlib.h heap.h inplib.h list.h log.h mathlib.h md5.h memlib.h
+		misc.h net.h platform.h reslib.h scriptlib.h sndlib.h
+		strlib.h tasklib.h threadlib.h timelib.h uio.h uioutils.h
+		unicode.h vidlib.h"
+
diff -ruNp src.hd/libs/alarm.h src/libs/alarm.h
--- src.hd/libs/alarm.h	2017-12-29 02:25:48 -0800
+++ src/libs/alarm.h	2017-12-29 00:57:38 -0800
@@ -1,2 +1,9 @@
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #include "callback/alarm.h"
 
+#if defined(__cplusplus)
+}
+#endif
diff -ruNp src.hd/libs/async.h src/libs/async.h
--- src.hd/libs/async.h	1969-12-31 16:00:00 -0800
+++ src/libs/async.h	2017-12-29 00:57:38 -0800
@@ -0,0 +1,10 @@
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+#include "callback/async.h"
+
+#if defined(__cplusplus)
+}
+#endif
+
diff -ruNp src.hd/libs/callback/Makeinfo src/libs/callback/Makeinfo
--- src.hd/libs/callback/Makeinfo	2017-12-29 02:25:48 -0800
+++ src/libs/callback/Makeinfo	2017-12-29 00:57:38 -0800
@@ -1,2 +1,2 @@
-uqm_CFILES="alarm.c callback.c"
-
+uqm_CFILES="alarm.c async.c callback.c"
+uqm_HFILES="alarm.h async.h callback.h"
diff -ruNp src.hd/libs/callback/alarm.c src/libs/callback/alarm.c
--- src.hd/libs/callback/alarm.c	2017-12-29 02:25:48 -0800
+++ src/libs/callback/alarm.c	2017-12-29 00:57:38 -0800
@@ -18,6 +18,7 @@
 
 #include "alarm.h"
 
+#include SDL_INCLUDE(SDL.h)
 #include "libs/heap.h"
 
 #include <assert.h>
@@ -71,19 +72,36 @@ Alarm_uninit(void) {
 }
 
 static inline AlarmTime
-AlarmTime_nowMS(void) {
+AlarmTime_nowMs(void) {
 	return SDL_GetTicks();
 }
 
 Alarm *
-Alarm_addRelativeMs(Uint32 ms, AlarmCallback callback,
+Alarm_addAbsoluteMs(uint32 ms, AlarmCallback callback,
 		AlarmCallbackArg arg) {
 	Alarm *alarm;
 
 	assert(alarmHeap != NULL);
 
 	alarm = Alarm_alloc();
-	alarm->time = AlarmTime_nowMS() + ms;
+	alarm->time = ms;
+	alarm->callback = callback;
+	alarm->arg = arg;
+
+	Heap_add(alarmHeap, (HeapValue *) alarm);
+
+	return alarm;
+}
+
+Alarm *
+Alarm_addRelativeMs(uint32 ms, AlarmCallback callback,
+		AlarmCallbackArg arg) {
+	Alarm *alarm;
+
+	assert(alarmHeap != NULL);
+
+	alarm = Alarm_alloc();
+	alarm->time = AlarmTime_nowMs() + ms;
 	alarm->callback = callback;
 	alarm->arg = arg;
 
@@ -99,15 +117,40 @@ Alarm_remove(Alarm *alarm) {
 	Alarm_free(alarm);
 }
 
+// Process at most one alarm, if its time has come.
+// It is safe to call this function again from inside a callback function
+// that it called. It should not be called from multiple threads at once.
+bool
+Alarm_processOne(void)
+{
+	AlarmTime now;
+	Alarm *alarm;
+	
+	assert(alarmHeap != NULL);
+	if (!Heap_hasMore(alarmHeap))
+		return false;
+	
+	now = AlarmTime_nowMs();
+	alarm = (Alarm *) Heap_first(alarmHeap);
+	if (now < alarm->time)
+		return false;
+
+	Heap_pop(alarmHeap);
+	alarm->callback(alarm->arg);
+	Alarm_free(alarm);
+	return true;
+}
+
+#if 0
 // It is safe to call this function again from inside a callback function
 // that it called. It should not be called from multiple threads at once.
 void
-Alarm_process(void) {
+Alarm_processAll(void) {
 	AlarmTime now;
 
 	assert(alarmHeap != NULL);
 	
-	now = AlarmTime_nowMS();
+	now = AlarmTime_nowMs();
 	while (Heap_hasMore(alarmHeap)) {
 		Alarm *alarm = (Alarm *) Heap_first(alarmHeap);
 
@@ -119,8 +162,9 @@ Alarm_process(void) {
 		Alarm_free(alarm);
 	}
 }
+#endif
 
-Uint32
+uint32
 Alarm_timeBeforeNextMs(void) {
 	Alarm *alarm;
 
@@ -131,4 +175,3 @@ Alarm_timeBeforeNextMs(void) {
 	return alarmTimeToMsUint32(alarm->time);
 }
 
-
diff -ruNp src.hd/libs/callback/alarm.h src/libs/callback/alarm.h
--- src.hd/libs/callback/alarm.h	2017-12-29 02:25:48 -0800
+++ src/libs/callback/alarm.h	2017-12-29 00:57:38 -0800
@@ -22,11 +22,10 @@
 #include "port.h"
 #include "types.h"
 
-#include SDL_INCLUDE(SDL.h)
-typedef Uint32 AlarmTime;
-static inline Uint32
+typedef uint32 AlarmTime;
+static inline uint32
 alarmTimeToMsUint32(AlarmTime time) {
-	return (Uint32) time;
+	return (uint32) time;
 }
 
 typedef struct Alarm Alarm;
@@ -44,11 +43,14 @@ struct Alarm {
 
 void Alarm_init(void);
 void Alarm_uninit(void);
-Alarm *Alarm_addRelativeMs(Uint32 ms, AlarmCallback callback,
+Alarm *Alarm_addAbsoluteMs(uint32 ms, AlarmCallback callback,
+		AlarmCallbackArg arg);
+Alarm *Alarm_addRelativeMs(uint32 ms, AlarmCallback callback,
 		AlarmCallbackArg arg);
 void Alarm_remove(Alarm *alarm);
-void Alarm_process(void);
-Uint32 Alarm_timeBeforeNextMs(void);
+bool Alarm_processOne(void);
+void Alarm_processAll(void);
+uint32 Alarm_timeBeforeNextMs(void);
 
 #endif  /* _ALARM_H */
 
diff -ruNp src.hd/libs/callback/async.c src/libs/callback/async.c
--- src.hd/libs/callback/async.c	1969-12-31 16:00:00 -0800
+++ src/libs/callback/async.c	2017-12-29 00:57:38 -0800
@@ -0,0 +1,56 @@
+/*
+ *  Copyright 2012  Serge van den Boom <svdb@stack.nl>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "async.h"
+
+#include "libs/alarm.h"
+#include "libs/callback.h"
+
+
+// Process all alarms and callbacks.
+// First, all scheduled callbacks are called.
+// Then each alarm due is called, and after each of these alarms, the
+// callbacks scheduled by this alarm are called.
+void
+Async_process(void)
+{
+	// Call pending callbacks.
+	Callback_process();
+
+	for (;;) {
+		if (!Alarm_processOne())
+			return;
+
+		// Call callbacks scheduled from the last alarm.
+		Callback_process();
+	}
+}
+
+// Returns the next time that some asynchronous callback is
+// to be called. Note that all values lower than the current time
+// should be considered as 'somewhere in the past'.
+uint32
+Async_timeBeforeNextMs(void) {
+	if (Callback_haveMore()) {
+		// Any time before the current time is ok, though we reserve 0 so
+		// that the caller may use it as a special value in its own code.
+		return 1;
+	}
+	return Alarm_timeBeforeNextMs();
+}
+
diff -ruNp src.hd/libs/callback/async.h src/libs/callback/async.h
--- src.hd/libs/callback/async.h	1969-12-31 16:00:00 -0800
+++ src/libs/callback/async.h	2017-12-29 00:57:38 -0800
@@ -0,0 +1,28 @@
+/*
+ *  Copyright 2012  Serge van den Boom <svdb@stack.nl>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _ASYNC_H
+#define _ASYNC_H
+
+#include "types.h"
+
+void Async_process(void);
+uint32 Async_timeBeforeNextMs(void);
+
+#endif  /* _ASYNC_H */
+
diff -ruNp src.hd/libs/callback/callback.c src/libs/callback/callback.c
--- src.hd/libs/callback/callback.c	2017-12-29 02:25:48 -0800
+++ src/libs/callback/callback.c	2017-12-29 00:57:38 -0800
@@ -23,6 +23,8 @@
 #include <stdlib.h>
 #include <sys/types.h>
 
+#include "libs/threadlib.h"
+
 typedef struct CallbackLink CallbackLink;
 
 #define CALLBACK_INTERNAL
@@ -38,16 +40,16 @@ static CallbackLink *callbacks;
 static CallbackLink **callbacksEnd;
 static CallbackLink *const *callbacksProcessEnd;
 
+static Mutex callbackListLock;
+
 static inline void
 CallbackList_lock(void) {
-	// TODO
-	// Necessary for reentrant operation
+	LockMutex(callbackListLock);
 }
 
 static inline void
 CallbackList_unlock(void) {
-	// TODO
-	// Necessary for reentrant operation
+	UnlockMutex(callbackListLock);
 }
 
 #if 0
@@ -62,6 +64,14 @@ Callback_init(void) {
 	callbacks = NULL;
 	callbacksEnd = &callbacks;
 	callbacksProcessEnd = &callbacks;
+	callbackListLock = CreateMutex("Callback List Lock", SYNC_CLASS_TOPLEVEL);
+}
+
+void
+Callback_uninit(void) {
+	// TODO: cleanup the queue?
+	DestroyMutex (callbackListLock);
+	callbackListLock = 0;
 }
 
 // Callbacks are guaranteed to be called in the order that they are queued.
@@ -170,4 +180,14 @@ Callback_process(void) {
 	}
 }
 
+bool
+Callback_haveMore(void) {
+	bool result;
+
+	CallbackList_lock();
+	result = (callbacks != NULL);
+	CallbackList_unlock();
+
+	return result;
+}
 
diff -ruNp src.hd/libs/callback/callback.h src/libs/callback/callback.h
--- src.hd/libs/callback/callback.h	2017-12-29 02:25:48 -0800
+++ src/libs/callback/callback.h	2017-12-29 00:57:38 -0800
@@ -33,9 +33,11 @@ typedef void *CallbackArg;
 typedef void (*CallbackFunction)(CallbackArg arg);
 
 void Callback_init(void);
+void Callback_uninit(void);
 CallbackID Callback_add(CallbackFunction callback, CallbackArg arg);
 bool Callback_remove(CallbackID id);
 void Callback_process(void);
+bool Callback_haveMore(void);
 
 #endif  /* _CALLBACK_H */
 
diff -ruNp src.hd/libs/callback.h src/libs/callback.h
--- src.hd/libs/callback.h	2017-12-29 02:25:48 -0800
+++ src/libs/callback.h	2017-12-29 00:57:38 -0800
@@ -1,2 +1,10 @@
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #include "callback/callback.h"
 
+#if defined(__cplusplus)
+}
+#endif
+
diff -ruNp src.hd/libs/cdp/Makeinfo src/libs/cdp/Makeinfo
--- src.hd/libs/cdp/Makeinfo	2017-12-29 02:25:48 -0800
+++ src/libs/cdp/Makeinfo	2017-12-29 00:57:38 -0800
@@ -1 +1,3 @@
 uqm_CFILES="cdp.c cdpapi.c"
+uqm_HFILES="cdp_alli.h cdpapi.h cdp.h cdp_iio.h cdp_imem.h cdpint.h
+		cdp_isnd.h cdp_ivid.h cdpmod.h windl.h"
diff -ruNp src.hd/libs/cdplib.h src/libs/cdplib.h
--- src.hd/libs/cdplib.h	2017-12-29 02:25:48 -0800
+++ src/libs/cdplib.h	2017-12-29 00:57:38 -0800
@@ -19,6 +19,14 @@
 #ifndef _CDPLIB_H
 #define _CDPLIB_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #include "cdp/cdp.h"
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _CDPLIB_H */
diff -ruNp src.hd/libs/compiler.h src/libs/compiler.h
--- src.hd/libs/compiler.h	2017-12-29 02:25:48 -0800
+++ src/libs/compiler.h	2017-12-29 00:57:38 -0800
@@ -21,6 +21,10 @@
 
 #include "types.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef uint8             BYTE;
 typedef uint8             UBYTE;
 typedef sint8             SBYTE;
@@ -85,5 +89,9 @@ typedef DWORD    (*PDWORDFUNC) (void);
 #	define _ALIGNED_ON(bytes)
 #endif
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _COMPILER_H */
 
diff -ruNp src.hd/libs/declib.h src/libs/declib.h
--- src.hd/libs/declib.h	2017-12-29 02:25:48 -0800
+++ src/libs/declib.h	2017-12-29 00:57:38 -0800
@@ -20,6 +20,11 @@
 #define _DECLIB_H
 
 #include "libs/compiler.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef struct _LZHCODE_DESC* DECODE_REF;
 
 enum
@@ -45,4 +50,8 @@ extern COUNT cread (void *pStr, COUNT si
 extern COUNT cwrite (const void *pStr, COUNT size, COUNT count,
 		DECODE_REF DecodeRef);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _DECLIB_H */
diff -ruNp src.hd/libs/decomp/Makeinfo src/libs/decomp/Makeinfo
--- src.hd/libs/decomp/Makeinfo	2017-12-29 02:25:48 -0800
+++ src/libs/decomp/Makeinfo	2017-12-29 00:57:38 -0800
@@ -1 +1,2 @@
 uqm_CFILES="lzdecode.c lzencode.c update.c"
+uqm_HFILES="lzh.h"
diff -ruNp src.hd/libs/file/Makeinfo src/libs/file/Makeinfo
--- src.hd/libs/file/Makeinfo	2017-12-29 02:25:48 -0800
+++ src/libs/file/Makeinfo	2017-12-29 00:57:38 -0800
@@ -1 +1,2 @@
 uqm_CFILES="dirs.c files.c"
+uqm_HFILES="filintrn.h"
diff -ruNp src.hd/libs/file/dirs.c src/libs/file/dirs.c
--- src.hd/libs/file/dirs.c	2017-12-29 02:25:48 -0800
+++ src/libs/file/dirs.c	2017-12-29 00:57:38 -0800
@@ -142,7 +142,7 @@ mkdirhier (const char *path)
 
 	if (*pathstart == '\0') {
 		// path exists completely, nothing more to do
-		return 0;
+		goto success;
 	}
 
 	// walk through the path as long as the components exist
@@ -177,7 +177,7 @@ mkdirhier (const char *path)
 		}
 		
 		if (*pathend == '\0')
-			return 0;
+			goto success;
 
 		*ptr = '/';
 		ptr++;
@@ -187,7 +187,7 @@ mkdirhier (const char *path)
 		// pathstart is the next non-slash character
 
 		if (*pathstart == '\0')
-			return 0;
+			goto success;
 	}
 	
 	// create all components left
@@ -221,6 +221,9 @@ mkdirhier (const char *path)
 		ptr += pathend - pathstart;
 		*ptr = '\0';
 	}
+
+success:
+	HFree (buf);
 	return 0;
 
 err:
@@ -641,6 +644,7 @@ expandPath (char *dest, size_t len, cons
 		*destptr = '\0';
 	}
 	
+	HFree (buf);
 	return 0;
 
 err:
@@ -656,7 +660,7 @@ err:
 		// This code is only needed if we have a current working directory
 		// per drive.
 // letter is 0 based: 0 = A, 1 = B, ...
-bool
+static bool
 driveLetterExists(int letter)
 {
 	unsigned long drives;
diff -ruNp src.hd/libs/file/files.c src/libs/file/files.c
--- src.hd/libs/file/files.c	2017-12-29 02:25:48 -0800
+++ src/libs/file/files.c	2017-12-29 00:57:38 -0800
@@ -94,7 +94,7 @@ copyFile (uio_DirHandle *srcDir, const c
 	buf = HMalloc(BUFSIZE);
 			// This was originally a statically allocated buffer,
 			// but as this function might be run from a thread with
-			// a small Stack, this is better.
+			// a small stack, this is better.
 	while (1)
 	{
 		numInBuf = uio_read (src, buf, BUFSIZE);
diff -ruNp src.hd/libs/file.h src/libs/file.h
--- src.hd/libs/file.h	2017-12-29 02:25:48 -0800
+++ src/libs/file.h	2017-12-29 00:57:38 -0800
@@ -25,6 +25,10 @@
 // for bool
 #include "types.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #if 0
 // from temp.h
 void initTempDir (void);
@@ -83,5 +87,9 @@ static inline int isDriveLetter(int c)
 }
 #endif  /* HAVE_DRIVE_LETTERS */
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _FILE_H */
 
diff -ruNp src.hd/libs/gfxlib.h src/libs/gfxlib.h
--- src.hd/libs/gfxlib.h	2017-12-29 02:25:48 -0800
+++ src/libs/gfxlib.h	2017-12-29 00:57:38 -0800
@@ -34,6 +34,10 @@ struct Color {
 
 #include "libs/reslib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef struct context_desc CONTEXT_DESC;
 typedef struct frame_desc FRAME_DESC;
 typedef struct font_desc FONT_DESC;
@@ -241,8 +245,16 @@ typedef struct text
 	COUNT CharCount;
 } TEXT;
 
+#if defined(__cplusplus)
+}
+#endif
+
 #include "libs/strlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef STRING_TABLE COLORMAP_REF;
 typedef STRING COLORMAP;
 // COLORMAPPTR is really a pointer to colortable entry structure
@@ -251,6 +263,7 @@ typedef void *COLORMAPPTR;
 
 #include "graphics/prim.h"
 
+
 typedef BYTE BATCH_FLAGS;
 // This flag is currently unused but it might make sense to restore it
 #define BATCH_BUILD_PAGE (BATCH_FLAGS)(1 << 0)
@@ -468,4 +481,8 @@ extern COLORMAPPTR GetColorMapAddress (C
 void SetSystemRect (const RECT *pRect);
 void ClearSystemRect (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _GFXLIB_H */
diff -ruNp src.hd/libs/graphics/Makeinfo src/libs/graphics/Makeinfo
--- src.hd/libs/graphics/Makeinfo	2017-12-29 02:25:48 -0800
+++ src/libs/graphics/Makeinfo	2017-12-29 00:57:39 -0800
@@ -7,3 +7,6 @@ uqm_CFILES="boxint.c clipline.c cmap.c c
 		font.c frame.c gfx_common.c intersec.c loaddisp.c
 		pixmap.c resgfx.c tfb_draw.c tfb_prim.c widgets.c"
 
+uqm_HFILES="bbox.h cmap.h context.h dcqueue.h drawable.h drawcmd.h font.h
+		gfx_common.h gfxintrn.h prim.h tfb_draw.h tfb_prim.h widgets.h"
+
diff -ruNp src.hd/libs/graphics/cmap.c src/libs/graphics/cmap.c
--- src.hd/libs/graphics/cmap.c	2017-12-29 02:25:48 -0800
+++ src/libs/graphics/cmap.c	2017-12-29 00:57:38 -0800
@@ -64,6 +64,10 @@ static int mapcount;
 static Mutex maplock;
 
 
+static void release_colormap (TFB_ColorMap *map);
+static void delete_colormap (TFB_ColorMap *map);
+
+
 void
 InitColorMaps (void)
 {
@@ -84,13 +88,23 @@ InitColorMaps (void)
 void
 UninitColorMaps (void)
 {
+	int i;
 	TFB_ColorMap *next;
 
+	for (i = 0; i < MAX_COLORMAPS; ++i)
+	{
+		TFB_ColorMap *map = colormaps[i];
+		if (!map)
+			continue;
+		release_colormap (map);
+		colormaps[i] = 0;
+	}
+
 	// free spares
-	for ( ; poolhead; poolhead = next)
+	for ( ; poolhead; poolhead = next, --poolcount)
 	{
 		next = poolhead->next;
-		HFree (poolhead);
+		delete_colormap (poolhead);
 	}
 
 	DestroyMutex (fadeLock);
@@ -155,6 +169,13 @@ clone_colormap (TFB_ColorMap *from, int
 	return map;
 }
 
+static void
+delete_colormap (TFB_ColorMap *map)
+{
+	FreeNativePalette (map->palette);
+	HFree (map);
+}
+
 static inline void
 free_colormap (TFB_ColorMap *map)
 {
@@ -172,8 +193,7 @@ free_colormap (TFB_ColorMap *map)
 	}
 	else
 	{	// don't need any more spares
-		FreeNativePalette (map->palette);
-		HFree (map);
+		delete_colormap (map);
 	}
 }
 
@@ -193,7 +213,7 @@ get_colormap (int index)
 	return map;
 }
 
-static inline void
+static void
 release_colormap (TFB_ColorMap *map)
 {
 	if (!map)
diff -ruNp src.hd/libs/graphics/context.c src/libs/graphics/context.c
--- src.hd/libs/graphics/context.c	2017-12-29 02:25:48 -0800
+++ src/libs/graphics/context.c	2017-12-29 00:57:38 -0800
@@ -123,6 +123,8 @@ FindContextPtr (CONTEXT context) {
 BOOLEAN
 DestroyContext (CONTEXT ContextRef)
 {
+	TFB_Image *img;
+
 	if (ContextRef == 0)
 		return (FALSE);
 
@@ -139,6 +141,10 @@ DestroyContext (CONTEXT ContextRef)
 	}
 #endif  /* DEBUG */
 
+	img = ContextRef->FontBacking;
+	if (img)
+		TFB_DrawImage_Delete (img);
+
 	FreeContext (ContextRef);
 	return TRUE;
 }
diff -ruNp src.hd/libs/graphics/dcqueue.c src/libs/graphics/dcqueue.c
--- src.hd/libs/graphics/dcqueue.c	2017-12-29 02:25:48 -0800
+++ src/libs/graphics/dcqueue.c	2017-12-29 00:57:38 -0800
@@ -14,8 +14,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "port.h"
 #include "libs/threadlib.h"
 #include "libs/graphics/drawcmd.h"
@@ -28,7 +26,7 @@
 #include "libs/log.h"
 #include "libs/misc.h"
 		// for TFB_DEBUG_HALT
-
+#include "options.h"
 
 static RecursiveMutex DCQ_Mutex;
 
@@ -158,8 +156,17 @@ Init_DrawCommandQueue (void)
 void
 Uninit_DrawCommandQueue (void)
 {
-	DestroyCondVar (RenderingCond);
-	DestroyRecursiveMutex (DCQ_Mutex);
+	if (RenderingCond)
+	{
+		DestroyCondVar (RenderingCond);
+		RenderingCond = 0;
+	}
+
+	if (DCQ_Mutex)
+	{
+		DestroyRecursiveMutex (DCQ_Mutex);
+		DCQ_Mutex = 0;
+	}
 }
 
 void
@@ -218,6 +225,30 @@ TFB_DrawCommandQueue_Clear ()
 	UnlockRecursiveMutex (DCQ_Mutex);
 }
 
+static void
+checkExclusiveThread (TFB_DrawCommand* DrawCommand)
+{
+#ifdef DEBUG_DCQ_THREADS
+	static uint32 exclusiveThreadId;
+	extern uint32 SDL_ThreadID(void);
+
+	// Only one thread is currently allowed to enqueue commands
+	// This is not a technical limitation but rather a semantical one atm.
+	if (DrawCommand->Type == TFB_DRAWCOMMANDTYPE_REINITVIDEO)
+	{	// TFB_DRAWCOMMANDTYPE_REINITVIDEO is an exception
+		// It is queued from the main() thread, which is safe to do
+		return;
+	}
+	
+	if (!exclusiveThreadId)
+		exclusiveThreadId = SDL_ThreadID();
+	else
+		assert (SDL_ThreadID() == exclusiveThreadId);
+#else
+	(void) DrawCommand; // suppress unused warning
+#endif
+}
+
 void
 TFB_EnqueueDrawCommand (TFB_DrawCommand* DrawCommand)
 {
@@ -226,6 +257,8 @@ TFB_EnqueueDrawCommand (TFB_DrawCommand*
 		return;
 	}
 
+	checkExclusiveThread (DrawCommand);
+
 	if (DrawCommand->Type <= TFB_DRAWCOMMANDTYPE_COPYTOIMAGE
 			&& _CurFramePtr->Type == SCREEN_DRAWABLE)
 	{
@@ -556,13 +589,13 @@ TFB_FlushGraphics (void)
 				int oldWidth = ScreenWidthActual;
 				int oldHeight = ScreenHeightActual;
 				if (TFB_ReInitGraphics (cmd->driver, cmd->flags,
-						cmd->width, cmd->height, resolutionFactor, forceAspectRatio)) // JMS_GFX: Added resolutionFactor
+						cmd->width, cmd->height, &resolutionFactor))
 				{
 					log_add (log_Error, "Could not provide requested mode: "
 							"reverting to last known driver.");
 					// We don't know what exactly failed, so roll it all back
 					if (TFB_ReInitGraphics (oldDriver, oldFlags,
-							oldWidth, oldHeight, resolutionFactor, forceAspectRatio)) // JMS_GFX: Added resolutionFactor
+							oldWidth, oldHeight, &resolutionFactor))
 					{
 						log_add (log_Fatal,
 								"Couldn't reinit at that point either. "
@@ -589,3 +622,49 @@ TFB_FlushGraphics (void)
 	RenderedFrames++;
 	BroadcastCondVar (RenderingCond);
 }
+
+void
+TFB_PurgeDanglingGraphics (void)
+{
+	Lock_DCQ (-1);
+
+	for (;;)
+	{
+		TFB_DrawCommand DC;
+
+		if (!TFB_DrawCommandQueue_Pop (&DC))
+		{
+			// the Queue is now empty.
+			break;
+		}
+
+		switch (DC.Type)
+		{
+			case TFB_DRAWCOMMANDTYPE_DELETEIMAGE:
+			{
+				TFB_Image *DC_image = DC.data.deleteimage.image;
+				TFB_DrawImage_Delete (DC_image);
+				break;
+			}
+			case TFB_DRAWCOMMANDTYPE_DELETEDATA:
+			{
+				void *data = DC.data.deletedata.data;
+				HFree (data);
+				break;
+			}
+			case TFB_DRAWCOMMANDTYPE_IMAGE:
+			{
+				TFB_ColorMap *cmap = DC.data.image.colormap;
+				if (cmap)
+					TFB_ReturnColorMap (cmap);
+				break;
+			}
+			case TFB_DRAWCOMMANDTYPE_SENDSIGNAL:
+			{
+				ClearSemaphore (DC.data.sendsignal.sem);
+				break;
+			}
+		}
+	}
+	Unlock_DCQ ();
+}
diff -ruNp src.hd/libs/graphics/drawable.c src/libs/graphics/drawable.c
--- src.hd/libs/graphics/drawable.c	2017-12-29 02:25:48 -0800
+++ src/libs/graphics/drawable.c	2017-12-29 00:57:39 -0800
@@ -16,6 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+
 #include "libs/graphics/sdl/sdl_common.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/gfxlib.h"
@@ -429,7 +430,7 @@ RescaleFrame (FRAME frame, int width, in
 	// NOTE: We do not lock the target image because nothing has a
 	//   reference to it yet!
 	src = img->NormalImg;
-	dst = newFrame->image->NormalImg;
+	dst = newFrame->image->NormalImg;	
 	
 	// JMS_GFX
 	if (eight_to_32)
@@ -443,7 +444,7 @@ RescaleFrame (FRAME frame, int width, in
 			dst_sdl->format->BitsPerPixel = 8 * (src_sdl->format->BytesPerPixel);
 		}
 	}
-	
+
 	TFB_DrawCanvas_Rescale_Nearest (src, dst, -1, NULL, NULL, NULL);
 	
 	UnlockMutex (img->mutex);
diff -ruNp src.hd/libs/graphics/frame.c src/libs/graphics/frame.c
--- src.hd/libs/graphics/frame.c	2017-12-29 02:25:48 -0800
+++ src/libs/graphics/frame.c	2017-12-29 00:57:39 -0800
@@ -138,7 +138,7 @@ DrawBatch (PRIMITIVE *lpBasePrim, PRIM_L
 				case POINT_PRIM:
 					color = GetPrimColor (lpWorkPrim);
 					TFB_Prim_Point (&lpWorkPrim->Object.Point, color,
-							mode, origin, FALSE);
+							mode, origin);
 					break;
 				case STAMP_PRIM:
 					TFB_Prim_Stamp (&lpWorkPrim->Object.Stamp, mode, origin);
@@ -169,11 +169,6 @@ DrawBatch (PRIMITIVE *lpBasePrim, PRIM_L
 					TFB_Prim_FillRect (&lpWorkPrim->Object.Rect, color,
 							mode, origin);
 					break;
-				case POINT_PRIM_HD:
-					color = GetPrimColor (lpWorkPrim);
-					TFB_Prim_Point (&lpWorkPrim->Object.Point, color,
-							mode, origin, TRUE);
-					break;
 			}
 		}
 
@@ -201,7 +196,7 @@ DrawPoint (POINT *lpPoint)
 	{
 		Color color = GetPrimColor (&_locPrim);
 		DrawMode mode = _get_context_draw_mode ();
-		TFB_Prim_Point (lpPoint, color, mode, origin, FALSE);
+		TFB_Prim_Point (lpPoint, color, mode, origin);
 	}
 }
 
diff -ruNp src.hd/libs/graphics/gfx_common.c src/libs/graphics/gfx_common.c
--- src.hd/libs/graphics/gfx_common.c	2017-12-29 02:25:48 -0800
+++ src/libs/graphics/gfx_common.c	2017-12-29 00:57:39 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "gfxintrn.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/graphics/drawcmd.h"
@@ -26,7 +24,6 @@
 		// for TFB_DEBUG_HALT
 
 // JMS_GFX
-unsigned int resolutionFactor;
 int fs_height = 0; 
 int fs_width  = 0;
 // End JMS_GFX
@@ -120,7 +117,7 @@ UnbatchGraphics (void)
    been processed. */
 
 void
-FlushGraphics ()
+FlushGraphics (void)
 {
 	TFB_DrawScreen_WaitForSignal ();
 }
diff -ruNp src.hd/libs/graphics/gfx_common.h src/libs/graphics/gfx_common.h
--- src.hd/libs/graphics/gfx_common.h	2017-12-29 02:25:48 -0800
+++ src/libs/graphics/gfx_common.h	2017-12-29 00:57:39 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #ifndef GFX_COMMON_H
 #define GFX_COMMON_H
 
@@ -25,8 +23,6 @@
 #include <stdlib.h>
 
 #include "libs/gfxlib.h"
-//#include "libs/graphics/sdl/opengl.h"
-//#include "libs/graphics/sdl/sdl_common.h"
 
 // driver for TFB_InitGraphics
 enum
@@ -67,11 +63,11 @@ extern int GfxFlags;
 
 // The following functions are driver-defined
 void TFB_PreInit (void);
-int TFB_InitGraphics (int driver, int flags, int width, int height, unsigned int *resolutionFactor, BOOLEAN forceAspectRatio); // JMS_GFX: Added resolutionFactor - MB Updated
-int TFB_ReInitGraphics (int driver, int flags, int width, int height, unsigned int resolutionFactor, BOOLEAN forceAspectRatio); // JMS_GFX: Added resolutionFactor
+int TFB_InitGraphics (int driver, int flags, int width, int height, unsigned int *resFactor);
+int TFB_ReInitGraphics (int driver, int flags, int width, int height, unsigned int *resFactor);
 void TFB_UninitGraphics (void);
 void TFB_ProcessEvents (void);
-void TFB_SetGamma (float gamma);
+bool TFB_SetGamma (float gamma);
 void TFB_UploadTransitionScreen (void);
 // This function should not be called directly
 void TFB_SwapBuffers (int force_full_redraw);
@@ -104,10 +100,9 @@ extern float FrameRate;
 extern int FrameRateTickBase;
 
 void TFB_FlushGraphics (void); // Only call from main thread!!
+void TFB_PurgeDanglingGraphics (void); // Only call from main thread as part of shutdown.
 
 // JMS_GFX
-extern unsigned int resolutionFactor;
-extern BOOLEAN forceAspectRatio;
 extern int fs_height; 
 extern int fs_width;
 // END JMS_GFX
diff -ruNp src.hd/libs/graphics/gfxload.c src/libs/graphics/gfxload.c
--- src.hd/libs/graphics/gfxload.c	2017-12-29 02:25:48 -0800
+++ src/libs/graphics/gfxload.c	2017-12-29 00:57:39 -0800
@@ -321,15 +321,7 @@ _ReleaseCelData (void *handle)
 		return (FALSE);
 
 	cel_ct = DrawablePtr->MaxIndex + 1;
-
-	if (DrawablePtr->Frame)
-	{
-		FramePtr = DrawablePtr->Frame;
-		if (FramePtr->Type == SCREEN_DRAWABLE)
-		{
-			FramePtr = NULL;
-		}
-	}
+	FramePtr = DrawablePtr->Frame;
 
 	HFree (handle);
 	if (FramePtr)
diff -ruNp src.hd/libs/graphics/intersec.c src/libs/graphics/intersec.c
--- src.hd/libs/graphics/intersec.c	2017-12-29 02:25:48 -0800
+++ src/libs/graphics/intersec.c	2017-12-29 00:57:39 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "libs/graphics/context.h"
 #include "libs/graphics/drawable.h"
 #include "libs/graphics/tfb_draw.h"
@@ -29,14 +27,13 @@ static inline BOOLEAN
 images_intersect (IMAGE_BOX *box1, IMAGE_BOX *box2, const RECT *rect)
 {
 	return TFB_DrawImage_Intersect (box1->FramePtr->image, box1->Box.corner,
-									box2->FramePtr->image, box2->Box.corner, rect);
+			box2->FramePtr->image, box2->Box.corner, rect);
 }
 
-// JMS: Changed SIZEs to SDWORDs to prevent overflows. Ditto for COUNTs -> to DWORDs.
 static TIME_VALUE
 frame_intersect (INTERSECT_CONTROL *pControl0, RECT *pr0,
-				 INTERSECT_CONTROL *pControl1, RECT *pr1, TIME_VALUE t0,
-				 TIME_VALUE t1)
+		INTERSECT_CONTROL *pControl1, RECT *pr1, TIME_VALUE t0,
+		TIME_VALUE t1)
 {
 	SDWORD time_error0, time_error1;
 	SDWORD cycle0, cycle1;
@@ -46,7 +43,7 @@ frame_intersect (INTERSECT_CONTROL *pCon
 	RECT r_intersect;
 	IMAGE_BOX IB0, IB1;
 	BOOLEAN check0, check1;
-	
+
 	IB0.FramePtr = pControl0->IntersectStamp.frame;
 	IB0.Box.corner = pr0->corner;
 	IB0.Box.extent.width = GetFrameWidth (IB0.FramePtr);
@@ -55,7 +52,7 @@ frame_intersect (INTERSECT_CONTROL *pCon
 	IB1.Box.corner = pr1->corner;
 	IB1.Box.extent.width = GetFrameWidth (IB1.FramePtr);
 	IB1.Box.extent.height = GetFrameHeight (IB1.FramePtr);
-	
+
 	dx_0 = pr0->extent.width;
 	dy_0 = pr0->extent.height;
 	if (dx_0 >= 0)
@@ -77,7 +74,7 @@ frame_intersect (INTERSECT_CONTROL *pCon
 	else
 		cycle0 = dy_0;
 	xerror0 = yerror0 = cycle0;
-	
+			
 	dx_1 = pr1->extent.width;
 	dy_1 = pr1->extent.height;
 	if (dx_1 >= 0)
@@ -99,7 +96,7 @@ frame_intersect (INTERSECT_CONTROL *pCon
 	else
 		cycle1 = dy_1;
 	xerror1 = yerror1 = cycle1;
-	
+			
 	check0 = check1 = FALSE;
 	if (t0 <= 1)
 	{
@@ -115,13 +112,13 @@ frame_intersect (INTERSECT_CONTROL *pCon
 		SDWORD delta;
 		DWORD start;
 		long error;
-		
+
 		start = (DWORD)cycle0 * (DWORD)(t0 - 1);
 		time_error0 = start & ((1 << TIME_SHIFT) - 1);
 		if ((start >>= (DWORD)TIME_SHIFT) > 0)
 		{
 			if ((error = (long)xerror0
-				 - (long)dx_0 * (long)start) > 0)
+					- (long)dx_0 * (long)start) > 0)
 				xerror0 = (SDWORD)error;
 			else
 			{
@@ -130,7 +127,7 @@ frame_intersect (INTERSECT_CONTROL *pCon
 				xerror0 = (SDWORD)(error + (long)cycle0 * (long)delta);
 			}
 			if ((error = (long)yerror0
-				 - (long)dy_0 * (long)start) > 0)
+					- (long)dy_0 * (long)start) > 0)
 				yerror0 = (SDWORD)error;
 			else
 			{
@@ -140,13 +137,13 @@ frame_intersect (INTERSECT_CONTROL *pCon
 			}
 			pr0->corner = IB0.Box.corner;
 		}
-		
+	
 		start = (DWORD)cycle1 * (DWORD)(t0 - 1);
 		time_error1 = start & ((1 << TIME_SHIFT) - 1);
 		if ((start >>= (DWORD)TIME_SHIFT) > 0)
 		{
 			if ((error = (long)xerror1
-				 - (long)dx_1 * (long)start) > 0)
+					- (long)dx_1 * (long)start) > 0)
 				xerror1 = (SDWORD)error;
 			else
 			{
@@ -155,7 +152,7 @@ frame_intersect (INTERSECT_CONTROL *pCon
 				xerror1 = (SDWORD)(error + (long)cycle1 * (long)delta);
 			}
 			if ((error = (long)yerror1
-				 - (long)dy_1 * (long)start) > 0)
+					- (long)dy_1 * (long)start) > 0)
 				yerror1 = (SDWORD)error;
 			else
 			{
@@ -166,7 +163,7 @@ frame_intersect (INTERSECT_CONTROL *pCon
 			pr1->corner = IB1.Box.corner;
 		}
 	}
-	
+
 	pControl0->last_time_val = pControl1->last_time_val = t0;
 	do
 	{
@@ -183,11 +180,11 @@ frame_intersect (INTERSECT_CONTROL *pCon
 				IB0.Box.corner.y += yincr0;
 				yerror0 += cycle0;
 			}
-			
+
 			check0 = TRUE;
 			time_error0 -= (1 << TIME_SHIFT);
 		}
-		
+			
 		if ((time_error1 += cycle1) >= (1 << TIME_SHIFT))
 		{
 			if ((xerror1 -= dx_1) <= 0)
@@ -200,22 +197,22 @@ frame_intersect (INTERSECT_CONTROL *pCon
 				IB1.Box.corner.y += yincr1;
 				yerror1 += cycle1;
 			}
-			
+
 			check1 = TRUE;
 			time_error1 -= (1 << TIME_SHIFT);
 		}
-		
+
 		if (check0 || check1)
 		{ /* if check0 && check1, this may not be quite right --
-		   * if shapes had a pixel's separation to begin with
-		   * and both moved toward each other, you would actually
-		   * get a pixel overlap but since the last positions were
-		   * separated by a pixel, the shapes wouldn't be touching
-		   * each other.
-		   */
-		CheckFirstIntersection:
+						 * if shapes had a pixel's separation to begin with
+						 * and both moved toward each other, you would actually
+						 * get a pixel overlap but since the last positions were
+						 * separated by a pixel, the shapes wouldn't be touching
+						 * each other.
+						 */
+CheckFirstIntersection:
 			if (BoxIntersect (&IB0.Box, &IB1.Box, &r_intersect)
-				&& images_intersect (&IB0, &IB1, &r_intersect))
+					&& images_intersect (&IB0, &IB1, &r_intersect))
 				return (t0);
 			
 			if (check0)
@@ -232,78 +229,76 @@ frame_intersect (INTERSECT_CONTROL *pCon
 			}
 		}
 	} while (t0 <= t1);
-	
+
 	return ((TIME_VALUE)0);
 }
 
-// JMS: Changed SIZEs to SDWORDs to preven overflows.
 TIME_VALUE
-DrawablesIntersect (INTERSECT_CONTROL *pControl0, INTERSECT_CONTROL *pControl1, TIME_VALUE max_time_val)
+DrawablesIntersect (INTERSECT_CONTROL *pControl0,
+		INTERSECT_CONTROL *pControl1, TIME_VALUE max_time_val)
 {
 	SDWORD dy;
 	SDWORD time_y_0, time_y_1;
 	RECT r0, r1;
 	FRAME FramePtr0, FramePtr1;
-	
+
 	if (!ContextActive () || max_time_val == 0)
 		return ((TIME_VALUE)0);
 	else if (max_time_val > MAX_TIME_VALUE)
 		max_time_val = MAX_TIME_VALUE;
-	
+
 	pControl0->last_time_val = pControl1->last_time_val = 0;
-	
+
 	r0.corner = pControl0->IntersectStamp.origin;
 	r1.corner = pControl1->IntersectStamp.origin;
-	
+
 	r0.extent.width = pControl0->EndPoint.x - r0.corner.x;
 	r0.extent.height = pControl0->EndPoint.y - r0.corner.y;
 	r1.extent.width = pControl1->EndPoint.x - r1.corner.x;
 	r1.extent.height = pControl1->EndPoint.y - r1.corner.y;
-	
+		
 	FramePtr0 = pControl0->IntersectStamp.frame;
 	if (FramePtr0 == 0)
 		return(0);
 	r0.corner.x -= FramePtr0->HotSpot.x;
 	r0.corner.y -= FramePtr0->HotSpot.y;
-	
+
 	FramePtr1 = pControl1->IntersectStamp.frame;
 	if (FramePtr1 == 0)
 		return(0);
 	r1.corner.x -= FramePtr1->HotSpot.x;
 	r1.corner.y -= FramePtr1->HotSpot.y;
-	
-	//log_add (log_Debug, "r0 x:%d y:%d w:%d h:%d r1 x:%d y:%d w:%d h:%d", r0.corner.x, r0.corner.y,GetFrameWidth (FramePtr0), GetFrameHeight (FramePtr0), r1.corner.x, r1.corner.y, GetFrameWidth(FramePtr1), GetFrameHeight (FramePtr1));
-	
+
 	dy = r1.corner.y - r0.corner.y;
 	time_y_0 = dy - GetFrameHeight (FramePtr0) + 1;
 	time_y_1 = dy + GetFrameHeight (FramePtr1) - 1;
 	dy = r0.extent.height - r1.extent.height;
-	
+
 	if ((time_y_0 <= 0 && time_y_1 >= 0)
-		|| (time_y_0 > 0 && dy >= time_y_0)
-		|| (time_y_1 < 0 && dy <= time_y_1))
+			|| (time_y_0 > 0 && dy >= time_y_0)
+			|| (time_y_1 < 0 && dy <= time_y_1))
 	{
 		SDWORD dx;
 		SDWORD time_x_0, time_x_1;
-		
+
 		dx = r1.corner.x - r0.corner.x;
 		time_x_0 = dx - GetFrameWidth (FramePtr0) + 1;
 		time_x_1 = dx + GetFrameWidth (FramePtr1) - 1;
 		dx = r0.extent.width - r1.extent.width;
-		
+
 		if ((time_x_0 <= 0 && time_x_1 >= 0)
-			|| (time_x_0 > 0 && dx >= time_x_0)
-			|| (time_x_1 < 0 && dx <= time_x_1))
+				|| (time_x_0 > 0 && dx >= time_x_0)
+				|| (time_x_1 < 0 && dx <= time_x_1))
 		{
 			TIME_VALUE intersect_time;
-			
+
 			if (dx == 0 && dy == 0)
 				time_y_0 = time_y_1 = 0;
 			else
 			{
 				SDWORD t;
 				long time_beg, time_end, fract;
-				
+
 				if (time_y_1 < 0)
 				{
 					t = time_y_0;
@@ -320,10 +315,10 @@ DrawablesIntersect (INTERSECT_CONTROL *p
 					dy = -dy;
 				if (dy < time_y_1)
 					time_y_1 = dy;
-				/* just to be safe, widen search area */
+					/* just to be safe, widen search area */
 				--time_y_0;
 				++time_y_1;
-				
+
 				if (time_x_1 < 0)
 				{
 					t = time_x_0;
@@ -340,19 +335,19 @@ DrawablesIntersect (INTERSECT_CONTROL *p
 					dx = -dx;
 				if (dx < time_x_1)
 					time_x_1 = dx;
-				/* just to be safe, widen search area */
+					/* just to be safe, widen search area */
 				--time_x_0;
 				++time_x_1;
-				
+
 #ifdef DEBUG_INTERSEC
 				log_add (log_Debug, "FramePtr0<%d, %d> --> <%d, %d>",
-						 GetFrameWidth (FramePtr0), GetFrameHeight (FramePtr0),
-						 r0.corner.x, r0.corner.y);
+						GetFrameWidth (FramePtr0), GetFrameHeight (FramePtr0),
+						r0.corner.x, r0.corner.y);
 				log_add (log_Debug, "FramePtr1<%d, %d> --> <%d, %d>",
-						 GetFrameWidth (FramePtr1), GetFrameHeight (FramePtr1),
-						 r1.corner.x, r1.corner.y);
+						GetFrameWidth (FramePtr1), GetFrameHeight (FramePtr1),
+						r1.corner.x, r1.corner.y);
 				log_add (log_Debug, "time_x(%d, %d)-%d, time_y(%d, %d)-%d",
-						 time_x_0, time_x_1, dx, time_y_0, time_y_1, dy);
+						time_x_0, time_x_1, dx, time_y_0, time_y_1, dy);
 #endif /* DEBUG_INTERSEC */
 				if (dx == 0)
 				{
@@ -369,39 +364,39 @@ DrawablesIntersect (INTERSECT_CONTROL *p
 				else
 				{
 					long time_x, time_y;
-					
+
 					time_x = (long)time_x_0 * (long)dy;
 					time_y = (long)time_y_0 * (long)dx;
 					time_beg = time_x < time_y ? time_y : time_x;
-					
+
 					time_x = (long)time_x_1 * (long)dy;
 					time_y = (long)time_y_1 * (long)dx;
 					time_end = time_x > time_y ? time_y : time_x;
-					
+
 					fract = (long)dx * (long)dy;
 				}
-				
+
 				if ((time_beg <<= TIME_SHIFT) < fract)
 					time_y_0 = 0;
 				else
 					time_y_0 = (SDWORD)(time_beg / fract);
-				
+
 				if (time_end >= fract /* just in case of overflow */
-					|| (time_end <<= TIME_SHIFT) >=
-					fract * (long)max_time_val)
+						|| (time_end <<= TIME_SHIFT) >=
+						fract * (long)max_time_val)
 					time_y_1 = max_time_val - 1;
 				else
 					time_y_1 = (SDWORD)((time_end + fract - 1) / fract) - 1;
 			}
-			
+
 #ifdef DEBUG_INTERSEC
 			log_add (log_Debug, "start_time = %d, end_time = %d",
-					 time_y_0, time_y_1);
+					time_y_0, time_y_1);
 #endif /* DEBUG_INTERSEC */
 			if (time_y_0 <= time_y_1
-				&& (intersect_time = frame_intersect (
-													  pControl0, &r0, pControl1, &r1,
-													  (TIME_VALUE)time_y_0, (TIME_VALUE)time_y_1)))
+					&& (intersect_time = frame_intersect (
+					pControl0, &r0, pControl1, &r1,
+					(TIME_VALUE)time_y_0, (TIME_VALUE)time_y_1)))
 			{
 				FramePtr0 = pControl0->IntersectStamp.frame;
 				pControl0->EndPoint.x = r0.corner.x + FramePtr0->HotSpot.x;
@@ -409,16 +404,12 @@ DrawablesIntersect (INTERSECT_CONTROL *p
 				FramePtr1 = pControl1->IntersectStamp.frame;
 				pControl1->EndPoint.x = r1.corner.x + FramePtr1->HotSpot.x;
 				pControl1->EndPoint.y = r1.corner.y + FramePtr1->HotSpot.y;
-				
-#ifdef DEBUG_INTERSEC
-				log_add (log_Debug, "intersecttime = %d",
-						 intersect_time);
-#endif /* DEBUG_INTERSEC */
-				
+
 				return (intersect_time);
 			}
 		}
 	}
+
 	return ((TIME_VALUE)0);
 }
 
diff -ruNp src.hd/libs/graphics/prim.h src/libs/graphics/prim.h
--- src.hd/libs/graphics/prim.h	2017-12-29 02:25:48 -0800
+++ src/libs/graphics/prim.h	2017-12-29 00:57:39 -0800
@@ -25,7 +25,6 @@ enum gfx_object
 	TEXT_PRIM,
 	RECT_PRIM,
 	RECTFILL_PRIM,
-	POINT_PRIM_HD,
 
 	NUM_PRIMS
 };
diff -ruNp src.hd/libs/graphics/sdl/Makeinfo src/libs/graphics/sdl/Makeinfo
--- src.hd/libs/graphics/sdl/Makeinfo	2017-12-29 02:25:48 -0800
+++ src/libs/graphics/sdl/Makeinfo	2017-12-29 00:57:39 -0800
@@ -1,5 +1,8 @@
-uqm_CFILES="opengl.c palette.c primitives.c pure.c sdl_common.c
-		scalers.c 2xscalers.c
-		2xscalers_mmx.c 2xscalers_sse.c 2xscalers_3dnow.c
-		nearest2x.c bilinear2x.c biadv2x.c triscan2x.c hq2x.c
-		canvas.c sdluio.c rotozoom.c"
+uqm_CFILES="opengl.c palette.c primitives.c pure.c sdl_common.c scalers.c
+		2xscalers.c 2xscalers_mmx.c 2xscalers_sse.c 2xscalers_3dnow.c
+		nearest2x.c bilinear2x.c biadv2x.c triscan2x.c hq2x.c canvas.c
+		sdluio.c rotozoom.c"
+uqm_HFILES="2xscalers.h 2xscalers_mmx.h opengl.h palette.h primitives.h
+		pure.h rotozoom.h scaleint.h scalemmx.h scalers.h sdl_common.h
+		sdluio.h"
+
diff -ruNp src.hd/libs/graphics/sdl/canvas.c src/libs/graphics/sdl/canvas.c
--- src.hd/libs/graphics/sdl/canvas.c	2017-12-29 02:25:48 -0800
+++ src/libs/graphics/sdl/canvas.c	2017-12-29 00:57:39 -0800
@@ -2119,7 +2119,7 @@ TFB_DrawCanvas_TransferIndexes (TFB_Canv
 	if (!TFB_DrawCanvas_IsPaletted (canvas) || fmt->BitsPerPixel != 8)
 	{
 		log_add (log_Warning, "ERROR: TFB_DrawCanvas_TransferIndexes "
-			 "unimplemeted function: %d not an 8bpp indexed canvas", fmt->BitsPerPixel);
+				"unimplemeted function: not an 8bpp indexed canvas", fmt->BitsPerPixel);
 		return FALSE;
 	}
 
diff -ruNp src.hd/libs/graphics/sdl/opengl.c src/libs/graphics/sdl/opengl.c
--- src.hd/libs/graphics/sdl/opengl.c	2017-12-29 02:25:48 -0800
+++ src/libs/graphics/sdl/opengl.c	2017-12-29 00:57:39 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #ifdef HAVE_OPENGL
 
 #include "libs/graphics/sdl/opengl.h"
@@ -26,6 +24,7 @@
 #include "options.h"
 #include "libs/log.h"
 
+
 typedef struct _gl_screeninfo {
 	SDL_Surface *scaled;
 	GLuint texture;
@@ -85,36 +84,14 @@ static TFB_GRAPHICS_BACKEND opengl_unsca
 	TFB_GL_ColorLayer };
 
 
-static SDL_Surface *
-Create_Screen (SDL_Surface *template, int w, int h)
-{
-	SDL_Surface *newsurf = SDL_CreateRGBSurface(SDL_SWSURFACE, w, h,
-			template->format->BitsPerPixel,
-			template->format->Rmask, template->format->Gmask,
-			template->format->Bmask, 0);
-	if (newsurf == 0) {
-		log_add (log_Error, "Couldn't create screen buffers: %s",
-				SDL_GetError());
-	}
-	return newsurf;
-}
-
-static int
-ReInit_Screen (SDL_Surface **screen, SDL_Surface *template, int w, int h)
-{
-	if (*screen)
-		SDL_FreeSurface (*screen);
-	*screen = Create_Screen (template, w, h);
-	
-	return *screen == 0 ? -1 : 0;
-}
-
 static int
-AttemptColorDepth (int flags, int width, int height, int bpp, unsigned int resolutionFactor, BOOLEAN forceAspectRatio)  // JMS_GFX: Added resolutionFactor
+AttemptColorDepth (int flags, int width, int height, int bpp, unsigned int resFactor)
 {
 	int videomode_flags;
 	ScreenColorDepth = bpp;
-	
+	ScreenWidthActual = width;
+	ScreenHeightActual = height;
+
 	switch (bpp) {
 		case 15:
 			SDL_GL_SetAttribute (SDL_GL_RED_SIZE, 5);
@@ -151,7 +128,7 @@ AttemptColorDepth (int flags, int width,
 		videomode_flags |= SDL_FULLSCREEN;
 	videomode_flags |= SDL_ANYFORMAT;
 
-	if (resolutionFactor > 0 && flags & TFB_GFXFLAGS_FULLSCREEN)
+	if (resFactor > 0 && flags & TFB_GFXFLAGS_FULLSCREEN)
 	{
 		height = fs_height;
 		width  = fs_width;
@@ -162,14 +139,14 @@ AttemptColorDepth (int flags, int width,
 	ScreenWidthActual = width;
 	ScreenHeightActual = height;
 
-	SDL_Video = SDL_SetVideoMode (ScreenWidthActual, ScreenHeightActual, bpp, videomode_flags);
-	
+	SDL_Video = SDL_SetVideoMode (ScreenWidthActual, ScreenHeightActual, 
+		bpp, videomode_flags);
 	if (SDL_Video == NULL)
 	{
 		log_add (log_Error, "Couldn't set OpenGL %ix%ix%i video mode: %s",
 				ScreenWidthActual, ScreenHeightActual, bpp,
 				SDL_GetError ());
-		
+
 		if (flags & TFB_GFXFLAGS_FULLSCREEN)
 		{
 			videomode_flags &= ~SDL_FULLSCREEN;
@@ -179,38 +156,37 @@ AttemptColorDepth (int flags, int width,
 			if (SDL_Video != NULL)
 				goto successful_change;
 		}
-		
+
 		return -1;
 	}
 	else
 	{
-	successful_change:
+		successful_change:
 		log_add (log_Info, "Set the resolution to: %ix%ix%i"
 				" (surface reports %ix%ix%i) (res_cat %u)",
 				width, height, bpp,			 
 				SDL_GetVideoSurface()->w, SDL_GetVideoSurface()->h,
-				SDL_GetVideoSurface()->format->BitsPerPixel, resolutionFactor);
+				SDL_GetVideoSurface()->format->BitsPerPixel, resFactor);
 
 		log_add (log_Info, "OpenGL renderer: %s version: %s",
 				glGetString (GL_RENDERER), glGetString (GL_VERSION));
-		
+
 		// JMS: Now, this makes the game center horizontally
 		// between the black bars on the sides.
 		ScreenWidthActual = SDL_GetVideoSurface()->w;
-		
 	}
 	return 0;
 }
 
 int
-TFB_GL_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen, unsigned int resolutionFactor, BOOLEAN forceAspectRatio)  // JMS_GFX: Added resolutionFactor
+TFB_GL_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen, unsigned int resFactor)
 {
 	int i, texture_width, texture_height;
 	GraphicsDriver = driver;
 
-	if (AttemptColorDepth (flags, width, height, 32, resolutionFactor, forceAspectRatio) &&
-			AttemptColorDepth (flags, width, height, 24, resolutionFactor, forceAspectRatio) &&
-			AttemptColorDepth (flags, width, height, 16, resolutionFactor, forceAspectRatio))
+	if (AttemptColorDepth (flags, width, height, 32, resFactor) &&
+			AttemptColorDepth (flags, width, height, 24, resFactor) &&
+			AttemptColorDepth (flags, width, height, 16, resFactor))
 	{
 		log_add (log_Error, "Couldn't set any OpenGL %ix%i video mode!",
 			 width, height);
@@ -275,19 +251,19 @@ TFB_GL_ConfigureVideo (int driver, int f
 	}
 	else
 	{
-		if (resolutionFactor == 0)
+		if (resFactor == 0)
 		{
 			texture_width = 512;
 			texture_height = 256;
 			graphics_backend = &opengl_unscaled_backend;
 		}
-		else if (resolutionFactor == 1)
+		else if (resFactor == 1)
 		{
 			texture_width = 1024;
 			texture_height = 512;
 			graphics_backend = &opengl_unscaled_backend_2x;
 		}
-		else if (resolutionFactor == 2)
+		else if (resFactor == 2)
 		{
 			texture_width = 2048;
 			texture_height = 1024;
@@ -302,7 +278,7 @@ TFB_GL_ConfigureVideo (int driver, int f
 		ScreenFilterMode = GL_LINEAR;
 	else
 		ScreenFilterMode = GL_NEAREST;
-	
+
 	glViewport (0, 0, ScreenWidthActual, ScreenHeightActual);
 	glClearColor (0,0,0,0);
 	glClear (GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
@@ -320,15 +296,15 @@ TFB_GL_ConfigureVideo (int driver, int f
 		glPixelStorei (GL_UNPACK_ALIGNMENT, 1);
 		glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
 		glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
-		glTexImage2D (GL_TEXTURE_2D, 0, GL_RGB, texture_width,
-			texture_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, 0);
+		glTexImage2D (GL_TEXTURE_2D, 0, GL_RGB, texture_width, texture_height,
+				0, GL_RGBA, GL_UNSIGNED_BYTE, 0);
 	}
 
 	return 0;
 }
 
 int
-TFB_GL_InitGraphics (int driver, int flags, int width, int height, unsigned int resolutionFactor, BOOLEAN forceAspectRatio)  // JMS_GFX: Added resolutionFactor
+TFB_GL_InitGraphics (int driver, int flags, int width, int height, unsigned int resFactor)
 {
 	char VideoName[256];
 
@@ -339,10 +315,10 @@ TFB_GL_InitGraphics (int driver, int fla
 	log_add (log_Info, "SDL initialized.");
 	log_add (log_Info, "Initializing Screen.");
 
-	ScreenWidth =  (320 << resolutionFactor); // JMS_GFX
-	ScreenHeight = (240 << resolutionFactor); // JMS_GFX
+	ScreenWidth = (320 << resFactor); // JMS_GFX
+	ScreenHeight = (240 << resFactor); // JMS_GFX
 
-	if (TFB_GL_ConfigureVideo (driver, flags, width, height, 0, resolutionFactor, forceAspectRatio)) 
+	if (TFB_GL_ConfigureVideo (driver, flags, width, height, 0, resFactor))
 	{
 		log_add (log_Fatal, "Could not initialize video: "
 				"no fallback at start of program!");
@@ -355,6 +331,15 @@ TFB_GL_InitGraphics (int driver, int fla
 	return 0;
 }
 
+void
+TFB_GL_UninitGraphics (void)
+{
+	int i;
+
+	for (i = 0; i < TFB_GFX_NUMSCREENS; i++)
+		UnInit_Screen (&GL_Screens[i].scaled);
+}
+
 void TFB_GL_UploadTransitionScreen (void)
 {
 	GL_Screens[TFB_SCREEN_TRANSITION].updated.x = 0;
@@ -364,7 +349,7 @@ void TFB_GL_UploadTransitionScreen (void
 	GL_Screens[TFB_SCREEN_TRANSITION].dirty = TRUE;
 }
 
-void
+static void
 TFB_GL_ScanLines (void)
 {
 	int y;
@@ -372,7 +357,8 @@ TFB_GL_ScanLines (void)
 	glDisable (GL_TEXTURE_2D);
 	glEnable (GL_BLEND);
 	glBlendFunc (GL_DST_COLOR, GL_ZERO);
-	glColor3f (0.85f, 0.85f, 0.85f);
+	// glColor3f (0.85f, 0.85f, 0.85f);
+	glColor3f (0.4f, 0.4f, 0.4f); // Darkened scanlines
 	for (y = 0; y < ScreenHeightActual; y += 2)
 	{
 		glBegin (GL_LINES);
@@ -382,7 +368,7 @@ TFB_GL_ScanLines (void)
 	}
 
 	glBlendFunc (GL_DST_COLOR, GL_ONE);
-	glColor3f (0.2f, 0.2f, 0.2f);
+	glColor3f (0.3f, 0.3f, 0.3f);
 	for (y = 1; y < ScreenHeightActual; y += 2)
 	{
 		glBegin (GL_LINES);
diff -ruNp src.hd/libs/graphics/sdl/opengl.h src/libs/graphics/sdl/opengl.h
--- src.hd/libs/graphics/sdl/opengl.h	2017-12-29 02:25:48 -0800
+++ src/libs/graphics/sdl/opengl.h	2017-12-29 00:57:39 -0800
@@ -21,8 +21,9 @@
 
 #include "libs/graphics/sdl/sdl_common.h"
 
-int TFB_GL_InitGraphics (int driver, int flags, int width, int height, unsigned int resolutionFactor, BOOLEAN	forceAspectRatio);  // JMS_GFX: Added resolutionFactor
-int TFB_GL_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen, unsigned int resolutionFactor, BOOLEAN forceAspectRatio);  // JMS_GFX: Added resolutionFactor
+int TFB_GL_InitGraphics (int driver, int flags, int width, int height, unsigned int resFactor);
+void TFB_GL_UninitGraphics (void);
+int TFB_GL_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen, unsigned int resFactor);
 void TFB_GL_UploadTransitionScreen (void);
 
 #ifdef HAVE_OPENGL
diff -ruNp src.hd/libs/graphics/sdl/pure.c src/libs/graphics/sdl/pure.c
--- src.hd/libs/graphics/sdl/pure.c	2017-12-29 02:25:48 -0800
+++ src/libs/graphics/sdl/pure.c	2017-12-29 00:57:39 -0800
@@ -47,30 +47,6 @@ static TFB_GRAPHICS_BACKEND pure_unscale
 	TFB_Pure_ScreenLayer,
 	TFB_Pure_ColorLayer };
 
-static SDL_Surface *
-Create_Screen (SDL_Surface *template, int w, int h)
-{
-	SDL_Surface *newsurf = SDL_CreateRGBSurface(SDL_SWSURFACE, w, h,
-			template->format->BitsPerPixel,
-			template->format->Rmask, template->format->Gmask,
-			template->format->Bmask, 0);
-	if (newsurf == 0) {
-		log_add (log_Error, "Couldn't create screen buffers: %s",
-				SDL_GetError());
-	}
-	return newsurf;
-}
-
-static int
-ReInit_Screen (SDL_Surface **screen, SDL_Surface *template, int w, int h)
-{
-	if (*screen)
-		SDL_FreeSurface (*screen);
-	*screen = Create_Screen (template, w, h);
-	
-	return *screen == 0 ? -1 : 0;
-}
-
 // We cannot rely on SDL_DisplayFormatAlpha() anymore. It can return
 // formats that we do not expect (SDL v1.2.14 on Mac OSX). Mac likes
 // ARGB surfaces, but SDL_DisplayFormatAlpha thinks that only RGBA are fast.
@@ -124,7 +100,7 @@ CalcAlphaFormat (const SDL_PixelFormat*
 }
 
 int
-TFB_Pure_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen, unsigned int resolutionFactor)  // JMS_GFX: Added resolutionFactor
+TFB_Pure_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen, unsigned int resFactor)
 {
 	int i, videomode_flags;
 	SDL_PixelFormat conv_fmt;
@@ -145,7 +121,7 @@ TFB_Pure_ConfigureVideo (int driver, int
 		videomode_flags = SDL_SWSURFACE;
 		
 		// JMS_GFX: Resolution is calculated with the help of a Resolution factor.
-		if (resolutionFactor == 0)
+		if (resFactor == 0)
 		{
 			// Check the sanity of resolution.
 			if (width != 640 || height != 480)
@@ -163,8 +139,8 @@ TFB_Pure_ConfigureVideo (int driver, int
 		}
 		else
 		{
-			ScreenWidthActual  = (320 << resolutionFactor);
-			ScreenHeightActual = (240 << resolutionFactor);
+			ScreenWidthActual  = (320 << resFactor);
+			ScreenHeightActual = (240 << resFactor);
 			graphics_backend = &pure_unscaled_backend;
 		}
 	}
@@ -172,7 +148,7 @@ TFB_Pure_ConfigureVideo (int driver, int
 	videomode_flags |= SDL_ANYFORMAT;
 	if (flags & TFB_GFXFLAGS_FULLSCREEN)
 		videomode_flags |= SDL_FULLSCREEN;
-	
+
 	/* We'll ask for a 32bpp frame, but it doesn't really matter, because we've set
 	   SDL_ANYFORMAT */
 	SDL_Video = SDL_SetVideoMode (ScreenWidthActual, ScreenHeightActual, 
@@ -272,7 +248,7 @@ TFB_Pure_ConfigureVideo (int driver, int
 }
 
 int
-TFB_Pure_InitGraphics (int driver, int flags, int width, int height, unsigned int resolutionFactor)  // JMS_GFX: Added resolutionFactor
+TFB_Pure_InitGraphics (int driver, int flags, int width, int height, unsigned int resFactor)
 {
 	char VideoName[256];
 
@@ -288,11 +264,10 @@ TFB_Pure_InitGraphics (int driver, int f
 	log_add (log_Info, "SDL initialized.");
 	log_add (log_Info, "Initializing Screen.");
 
-	// JMS_GFX: Resolution is calculated with the help of a Resolution factor.
-	ScreenWidth  = (320 << resolutionFactor); //320
-	ScreenHeight = (240 << resolutionFactor); //240
+	ScreenWidth = (320 << resFactor); // 320
+	ScreenHeight = (240 << resFactor); // 240
 
-	if (TFB_Pure_ConfigureVideo (driver, flags, width, height, 0, resolutionFactor)) // JMS_GFX: Added resolutionFactor
+	if (TFB_Pure_ConfigureVideo (driver, flags, width, height, 0, resFactor))
 	{
 		log_add (log_Fatal, "Could not initialize video: "
 				"no fallback at start of program!");
@@ -305,6 +280,14 @@ TFB_Pure_InitGraphics (int driver, int f
 	return 0;
 }
 
+void
+TFB_Pure_UninitGraphics (void)
+{
+	UnInit_Screen (&scaled_display);
+	UnInit_Screen (&fade_color_surface);
+	UnInit_Screen (&fade_temp);
+}
+
 static void
 ScanLines (SDL_Surface *dst, SDL_Rect *r)
 {
diff -ruNp src.hd/libs/graphics/sdl/pure.h src/libs/graphics/sdl/pure.h
--- src.hd/libs/graphics/sdl/pure.h	2017-12-29 02:25:48 -0800
+++ src/libs/graphics/sdl/pure.h	2017-12-29 00:57:39 -0800
@@ -21,8 +21,9 @@
 
 #include "libs/graphics/sdl/sdl_common.h"
 
-int TFB_Pure_InitGraphics (int driver, int flags, int width, int height, unsigned int resolutionFactor);  // JMS_GFX: Added resolutionFactor
-int TFB_Pure_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen, unsigned int resolutionFactor); // JMS_GFX: Added resolutionFactor
+int TFB_Pure_InitGraphics (int driver, int flags, int width, int height, unsigned int resFactor);
+void TFB_Pure_UninitGraphics (void);
+int TFB_Pure_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen, unsigned int resFactor);
 void Scale_PerfTest (void);
 
 #endif
diff -ruNp src.hd/libs/graphics/sdl/rotozoom.c src/libs/graphics/sdl/rotozoom.c
--- src.hd/libs/graphics/sdl/rotozoom.c	2017-12-29 02:25:48 -0800
+++ src/libs/graphics/sdl/rotozoom.c	2017-12-29 00:57:39 -0800
@@ -222,6 +222,7 @@ int zoomSurfaceRGBA(SDL_Surface * src, S
  
 */
 
+static
 int zoomSurfaceY(SDL_Surface * src, SDL_Surface * dst)
 {
     Uint32 sx, sy, *sax, *say, *csax, *csay, csx, csy;
@@ -342,6 +343,7 @@ int zoomSurfaceY(SDL_Surface * src, SDL_
  
 */
 
+static
 void transformSurfaceRGBA(SDL_Surface * src, SDL_Surface * dst, int cx, int cy, int isin, int icos, int smooth)
 {
     int x, y, t1, t2, dx, dy, xd, yd, sdx, sdy, ax, ay, ex, ey, sw, sh;
@@ -497,6 +499,7 @@ void transformSurfaceRGBA(SDL_Surface *
  
 */
 
+static
 void transformSurfaceY(SDL_Surface * src, SDL_Surface * dst, int cx, int cy, int isin, int icos)
 {
     int x, y, dx, dy, xd, yd, sdx, sdy, ax, ay, sw, sh;
@@ -557,6 +560,7 @@ void transformSurfaceY(SDL_Surface * src
 
 /* Local rotozoom-size function with trig result return */
 
+static
 void rotozoomSurfaceSizeTrig(int width, int height, double angle, double zoom, int *dstwidth, int *dstheight,
 			     double *canglezoom, double *sanglezoom)
 {
@@ -578,8 +582,8 @@ void rotozoomSurfaceSizeTrig(int width,
     cy = *canglezoom * y;
     sx = *sanglezoom * x;
     sy = *sanglezoom * y;
-    dstwidthhalf = MAX((int) ceil(fabs(cx) + fabs(sy)), 1);
-    dstheighthalf = MAX((int) ceil(fabs(sx) + fabs(cy)), 1);
+    dstwidthhalf = MAX(ceil(fabs(cx) + fabs(sy)), 1);
+    dstheighthalf = MAX(ceil(fabs(sx) + fabs(cy)), 1);
     *dstwidth = 2 * dstwidthhalf;
     *dstheight = 2 * dstheighthalf;
 }
diff -ruNp src.hd/libs/graphics/sdl/scalers.c src/libs/graphics/sdl/scalers.c
--- src.hd/libs/graphics/sdl/scalers.c	2017-12-29 02:25:49 -0800
+++ src/libs/graphics/sdl/scalers.c	2017-12-29 00:57:39 -0800
@@ -211,7 +211,7 @@ Scale_PrepPlatform (int flags, const SDL
 	// add better platform techs to the top
 #ifdef MMX_ASM
 	if ( (!force_platform && (SDL_HasSSE () || SDL_HasMMXExt ()))
-			|| force_platform == SCALEPLAT_SSE)
+			|| force_platform == PLATFORM_SSE)
 	{
 		log_add (log_Info, "Screen scalers are using SSE/MMX-Ext/MMX code");
 		Scale_Platform = SCALEPLAT_SSE;
@@ -220,7 +220,7 @@ Scale_PrepPlatform (int flags, const SDL
 	}
 	else
 	if ( (!force_platform && SDL_HasAltiVec ())
-			|| force_platform == SCALEPLAT_ALTIVEC)
+			|| force_platform == PLATFORM_ALTIVEC)
 	{
 		log_add (log_Info, "Screen scalers would use AltiVec code "
 				"if someone actually wrote it");
@@ -228,7 +228,7 @@ Scale_PrepPlatform (int flags, const SDL
 	}
 	else
 	if ( (!force_platform && SDL_Has3DNow ())
-			|| force_platform == SCALEPLAT_3DNOW)
+			|| force_platform == PLATFORM_3DNOW)
 	{
 		log_add (log_Info, "Screen scalers are using 3DNow/MMX code");
 		Scale_Platform = SCALEPLAT_3DNOW;
@@ -237,7 +237,7 @@ Scale_PrepPlatform (int flags, const SDL
 	}
 	else
 	if ( (!force_platform && SDL_HasMMX ())
-			|| force_platform == SCALEPLAT_MMX)
+			|| force_platform == PLATFORM_MMX)
 	{
 		log_add (log_Info, "Screen scalers are using MMX code");
 		Scale_Platform = SCALEPLAT_MMX;
diff -ruNp src.hd/libs/graphics/sdl/sdl_common.c src/libs/graphics/sdl/sdl_common.c
--- src.hd/libs/graphics/sdl/sdl_common.c	2017-12-29 02:25:49 -0800
+++ src/libs/graphics/sdl/sdl_common.c	2017-12-29 00:57:39 -0800
@@ -54,6 +54,8 @@ TFB_GRAPHICS_BACKEND *graphics_backend =
 volatile int QuitPosted = 0;
 volatile int GameActive = 1; // Track the SDL_ACTIVEEVENT state SDL_APPACTIVE
 
+static void TFB_PreQuit (void);
+
 void
 TFB_PreInit (void)
 {
@@ -78,10 +80,18 @@ TFB_PreInit (void)
 		log_add (log_Fatal, "Could not initialize SDL: %s.", SDL_GetError ());
 		exit (EXIT_FAILURE);
 	}
+
+	atexit (TFB_PreQuit);
+}
+
+static void
+TFB_PreQuit (void)
+{
+	SDL_Quit ();
 }
 
 int
-TFB_ReInitGraphics (int driver, int flags, int width, int height, unsigned int resolutionFactor, BOOLEAN forceAspectRatio) // JMS_GFX: Added resolutionFactor
+TFB_ReInitGraphics (int driver, int flags, int width, int height, unsigned int *resFactor) // JMS_GFX: Added resFactor
 {
 	int result;
 	int togglefullscreen = 0;
@@ -100,19 +110,19 @@ TFB_ReInitGraphics (int driver, int flag
 	{
 #ifdef HAVE_OPENGL
 		result = TFB_GL_ConfigureVideo (driver, flags, width, height,
-				togglefullscreen, resolutionFactor, forceAspectRatio); // JMS_GFX: Added resolutionFactor
+				togglefullscreen, *resFactor);
 #else
 		driver = TFB_GFXDRIVER_SDL_PURE;
 		log_add (log_Warning, "OpenGL support not compiled in,"
 				" so using pure SDL driver");
 		result = TFB_Pure_ConfigureVideo (driver, flags, width, height,
-				togglefullscreen, resolutionFactor); // JMS_GFX: Added resolutionFactor
+				togglefullscreen, resFactor);
 #endif
 	}
 	else
 	{
 		result = TFB_Pure_ConfigureVideo (driver, flags, width, height,
-				togglefullscreen, resolutionFactor); // JMS_GFX: Added resolutionFactor
+				togglefullscreen, *resFactor);
 	}
 
 	sprintf (caption, "The Ur-Quan Masters v%d.%d.%d%s",
@@ -129,7 +139,7 @@ TFB_ReInitGraphics (int driver, int flag
 }
 
 int
-TFB_InitGraphics (int driver, int flags, int width, int height, unsigned int *resolutionFactor, BOOLEAN forceAspectRatio) // JMS_GFX: added resolutionFactor
+TFB_InitGraphics (int driver, int flags, int width, int height, unsigned int *resFactor)
 {
 	int result, i;
 	char caption[200];
@@ -167,10 +177,10 @@ TFB_InitGraphics (int driver, int flags,
 		}
 
 		// MB: Sanitising resolution factor:
-		if (fs_height <= 600 && resolutionFactor == 2) { // ie. probably netbook or otherwise
-			*resolutionFactor = 1; // drop down to 640x480. netbook won't be able to handle anything higher and quality difference is minimal
- 		} else if (fs_height <= 300 && resolutionFactor > 0) { // People who like pixels I guess
-			*resolutionFactor = 0; // drop down to 320x240
+		if (fs_height <= 600 && *resFactor == 2) { // ie. probably netbook or otherwise
+			*resFactor = 1; // drop down to 640x480. netbook won't be able to handle anything higher and quality difference is minimal
+ 		} else if (fs_height <= 300 && resFactor > 0) { // People who like pixels I guess
+			*resFactor = 0; // drop down to 320x240
 		}
 		
 		log_add (log_Debug, "fs_height %u, fs_width %u, current_w %u", fs_height, fs_width, SDL_screen_info->current_w);
@@ -179,17 +189,17 @@ TFB_InitGraphics (int driver, int flags,
 	if (driver == TFB_GFXDRIVER_SDL_OPENGL)
 	{
 #ifdef HAVE_OPENGL
-		result = TFB_GL_InitGraphics (driver, flags, width, height, *resolutionFactor, forceAspectRatio); // JMS_GFX: added resolutionFactor
+		result = TFB_GL_InitGraphics (driver, flags, width, height, *resFactor);
 #else
 		driver = TFB_GFXDRIVER_SDL_PURE;
 		log_add (log_Warning, "OpenGL support not compiled in,"
 				" so using pure SDL driver");
-		result = TFB_Pure_InitGraphics (driver, flags, width, height, *resolutionFactor); // JMS_GFX: added resolutionFactor
+		result = TFB_Pure_InitGraphics (driver, flags, width, height, *resFactor);
 #endif
 	}
 	else
 	{
-		result = TFB_Pure_InitGraphics (driver, flags, width, height, *resolutionFactor);  // JMS_GFX: added resolutionFactor
+		result = TFB_Pure_InitGraphics (driver, flags, width, height, *resFactor);
 	}
 
 	sprintf (caption, "The Ur-Quan Masters v%d.%d.%d%s", 
@@ -204,17 +214,25 @@ TFB_InitGraphics (int driver, int flags,
 
 	TFB_DrawCanvas_Initialize ();
 
-	atexit (TFB_UninitGraphics);
-
 	return 0;
 }
 
 void
 TFB_UninitGraphics (void)
 {
+	int i;
+
 	Uninit_DrawCommandQueue ();
-	// TODO: Uninit whatever the drivers have set up for us
-	SDL_Quit ();
+
+	for (i = 0; i < TFB_GFX_NUMSCREENS; i++)
+		UnInit_Screen (&SDL_Screens[i]);
+
+	TFB_Pure_UninitGraphics ();
+#ifdef HAVE_OPENGL
+	TFB_GL_UninitGraphics ();
+#endif
+
+	UnInit_Screen (&format_conv_surf);
 }
 
 void
@@ -222,7 +240,7 @@ TFB_ProcessEvents ()
 {
 	SDL_Event Event;
 
-	while (SDL_PollEvent (&Event))
+	while (SDL_PollEvent (&Event) > 0)
 	{
 		/* Run through the InputEvent filter. */
 		ProcessInputEvent (&Event);
@@ -303,7 +321,6 @@ TFB_SwapBuffers (int force_full_redraw)
 	if (transition_amount != 255)
 	{
 		SDL_Rect r;
-		
 		r.x = TransitionClipRect.corner.x;
 		r.y = TransitionClipRect.corner.y;
 		r.w = TransitionClipRect.extent.width;
@@ -374,251 +391,6 @@ TFB_GetScreenCanvas (SCREEN screen)
 }
 
 void
-TFB_BlitSurface (SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst,
-		SDL_Rect *dstrect, int blend_numer, int blend_denom)
-{
-	BOOLEAN has_colorkey;
-	int x, y, x1, y1, x2, y2, dst_x2, dst_y2, nr, ng, nb;
-	int srcx, srcy, w, h;
-	Uint8 sr, sg, sb, dr, dg, db;
-	Uint32 src_pixval, dst_pixval, colorkey;
-	GetPixelFn src_getpix, dst_getpix;
-	PutPixelFn putpix;
-	SDL_Rect fulldst;
-
-	if (blend_numer == blend_denom)
-	{
-		// normal blit: dst = src
-		
-		// log_add (log_Debug, "normal blit\n");
-		SDL_BlitSurface (src, srcrect, dst, dstrect);
-		return;
-	}
-		
-	// NOTE: following clipping code is copied from SDL-1.2.4 sources
-
-	// If the destination rectangle is NULL, use the entire dest surface
-	if (dstrect == NULL)
-	{
-		fulldst.x = fulldst.y = 0;
-		dstrect = &fulldst;
-	}
-
-	// clip the source rectangle to the source surface
-	if (srcrect)
-	{
-		int maxw, maxh;
-
-		srcx = srcrect->x;
-		w = srcrect->w;
-		if (srcx < 0) 
-		{
-			w += srcx;
-			dstrect->x -= srcx;
-			srcx = 0;
-		}
-		maxw = src->w - srcx;
-		if (maxw < w)
-			w = maxw;
-
-		srcy = srcrect->y;
-		h = srcrect->h;
-		if (srcy < 0) 
-		{
-			h += srcy;
-			dstrect->y -= srcy;
-			srcy = 0;
-		}
-		maxh = src->h - srcy;
-		if (maxh < h)
-			h = maxh;
-	}
-	else
-	{
-		srcx = 0;
-		srcy = 0;
-		w = src->w;
-		h = src->h;
-	}
-
-	// clip the destination rectangle against the clip rectangle
-	{
-		SDL_Rect *clip = &dst->clip_rect;
-		int dx, dy;
-
-		dx = clip->x - dstrect->x;
-		if (dx > 0)
-		{
-			w -= dx;
-			dstrect->x += dx;
-			srcx += dx;
-		}
-		dx = dstrect->x + w - clip->x - clip->w;
-		if (dx > 0)
-			w -= dx;
-
-		dy = clip->y - dstrect->y;
-		if (dy > 0)
-		{
-			h -= dy;
-			dstrect->y += dy;
-			srcy += dy;
-		}
-		dy = dstrect->y + h - clip->y - clip->h;
-		if (dy > 0)
-			h -= dy;
-	}
-
-	dstrect->w = w;
-	dstrect->h = h;
-
-	if (w <= 0 || h <= 0)
-		return;
-
-	x1 = srcx;
-	y1 = srcy;
-	x2 = srcx + w;
-	y2 = srcy + h;
-
-	if (src->flags & SDL_SRCCOLORKEY)
-	{
-		has_colorkey = TRUE;
-		colorkey = src->format->colorkey;
-	}
-	else
-	{
-		has_colorkey = FALSE;
-		colorkey = 0;  /* Satisfying compiler */
-	}
-
-	src_getpix = getpixel_for (src);
-	dst_getpix = getpixel_for (dst);
-	putpix = putpixel_for (dst);
-
-	if (blend_denom < 0)
-	{
-		// additive blit: dst = src + dst
-#if 0
-		log_add (log_Debug, "additive blit %d %d, src %d %d %d %d dst %d %d,"
-				" srcbpp %d", blend_numer, blend_denom, x1, y1, x2, y2,
-				dstrect->x, dstrect->y, src->format->BitsPerPixel);
-#endif		
-		for (y = y1; y < y2; ++y)
-		{
-			dst_y2 = dstrect->y + (y - y1);
-			for (x = x1; x < x2; ++x)
-			{
-				dst_x2 = dstrect->x + (x - x1);
-				src_pixval = src_getpix (src, x, y);
-
-				if (has_colorkey && src_pixval == colorkey)
-					continue;
-
-				dst_pixval = dst_getpix (dst, dst_x2, dst_y2);
-				
-				SDL_GetRGB (src_pixval, src->format, &sr, &sg, &sb);
-				SDL_GetRGB (dst_pixval, dst->format, &dr, &dg, &db);
-
-				nr = sr + dr;
-				ng = sg + dg;
-				nb = sb + db;
-
-				if (nr > 255)
-					nr = 255;
-				if (ng > 255)
-					ng = 255;
-				if (nb > 255)
-					nb = 255;
-
-				putpix (dst, dst_x2, dst_y2,
-						SDL_MapRGB (dst->format, nr, ng, nb));
-			}
-		}
-	}
-	else if (blend_numer < 0)
-	{
-		// subtractive blit: dst = src - dst
-#if 0
-		log_add (log_Debug, "subtractive blit %d %d, src %d %d %d %d"
-				" dst %d %d, srcbpp %d", blend_numer, blend_denom,
-					x1, y1, x2, y2, dstrect->x, dstrect->y,
-					src->format->BitsPerPixel);
-#endif		
-		for (y = y1; y < y2; ++y)
-		{
-			dst_y2 = dstrect->y + (y - y1);
-			for (x = x1; x < x2; ++x)
-			{
-				dst_x2 = dstrect->x + (x - x1);
-				src_pixval = src_getpix (src, x, y);
-
-				if (has_colorkey && src_pixval == colorkey)
-					continue;
-
-				dst_pixval = dst_getpix (dst, dst_x2, dst_y2);
-
-				SDL_GetRGB (src_pixval, src->format, &sr, &sg, &sb);
-				SDL_GetRGB (dst_pixval, dst->format, &dr, &dg, &db);
-
-				nr = sr - dr;
-				ng = sg - dg;
-				nb = sb - db;
-
-				if (nr < 0)
-					nr = 0;
-				if (ng < 0)
-					ng = 0;
-				if (nb < 0)
-					nb = 0;
-
-				putpix (dst, dst_x2, dst_y2,
-						SDL_MapRGB (dst->format, nr, ng, nb));
-			}
-		}
-	}
-	else 
-	{
-		// modulated blit: dst = src * (blend_numer / blend_denom) 
-
-		float f = blend_numer / (float)blend_denom;
-#if 0
-		log_add (log_Debug, "modulated blit %d %d, f %f, src %d %d %d %d"
-				" dst %d %d, srcbpp %d\n", blend_numer, blend_denom, f,
-				x1, y1, x2, y2, dstrect->x, dstrect->y,
-				src->format->BitsPerPixel);
-#endif		
-		for (y = y1; y < y2; ++y)
-		{
-			dst_y2 = dstrect->y + (y - y1);
-			for (x = x1; x < x2; ++x)
-			{
-				dst_x2 = dstrect->x + (x - x1);
-				src_pixval = src_getpix (src, x, y);
-
-				if (has_colorkey && src_pixval == colorkey)
-					continue;
-				
-				SDL_GetRGB (src_pixval, src->format, &sr, &sg, &sb);
-
-				nr = (int)(sr * f);
-				ng = (int)(sg * f);
-				nb = (int)(sb * f);
-
-				if (nr > 255)
-					nr = 255;
-				if (ng > 255)
-					ng = 255;
-				if (nb > 255)
-					nb = 255;
-
-				putpix (dst, dst_x2, dst_y2,
-						SDL_MapRGB (dst->format, nr, ng, nb));
-			}
-		}
-	}
-}
-
-void
 TFB_UploadTransitionScreen (void)
 {
 #ifdef HAVE_OPENGL
@@ -629,16 +401,41 @@ TFB_UploadTransitionScreen (void)
 #endif
 }
 
-void
+bool
 TFB_SetGamma (float gamma)
 {
-	if (SDL_SetGamma (gamma, gamma, gamma) == -1)
-	{
-		log_add (log_Warning, "Unable to set gamma correction.");
-	}
-	else
-	{
-		log_add (log_Info, "Gamma correction set to %1.4f.", gamma);
+	return (SDL_SetGamma (gamma, gamma, gamma) == 0);
+}
+
+SDL_Surface *
+Create_Screen (SDL_Surface *templat, int w, int h)
+{
+	SDL_Surface *newsurf = SDL_CreateRGBSurface(SDL_SWSURFACE, w, h,
+			templat->format->BitsPerPixel,
+			templat->format->Rmask, templat->format->Gmask,
+			templat->format->Bmask, 0);
+	if (newsurf == 0) {
+		log_add (log_Error, "Couldn't create screen buffers: %s",
+				SDL_GetError());
 	}
+	return newsurf;
+}
+
+int
+ReInit_Screen (SDL_Surface **screen, SDL_Surface *templat, int w, int h)
+{
+	UnInit_Screen (screen);
+	*screen = Create_Screen (templat, w, h);
+	
+	return *screen == 0 ? -1 : 0;
 }
 
+void
+UnInit_Screen (SDL_Surface **screen)
+{
+	if (*screen == NULL)
+		return;
+
+	SDL_FreeSurface (*screen);
+	*screen = NULL;
+}
diff -ruNp src.hd/libs/graphics/sdl/sdl_common.h src/libs/graphics/sdl/sdl_common.h
--- src.hd/libs/graphics/sdl/sdl_common.h	2017-12-29 02:25:49 -0800
+++ src/libs/graphics/sdl/sdl_common.h	2017-12-29 00:57:39 -0800
@@ -50,4 +50,8 @@ extern const SDL_VideoInfo *SDL_screen_i
 
 SDL_Surface* TFB_DisplayFormatAlpha (SDL_Surface *surface);
 
+SDL_Surface* Create_Screen (SDL_Surface *templat, int w, int h);
+int ReInit_Screen (SDL_Surface **screen, SDL_Surface *templat, int w, int h);
+void UnInit_Screen (SDL_Surface **screen);
+
 #endif
diff -ruNp src.hd/libs/graphics/tfb_draw.c src/libs/graphics/tfb_draw.c
--- src.hd/libs/graphics/tfb_draw.c	2017-12-29 02:25:49 -0800
+++ src/libs/graphics/tfb_draw.c	2017-12-29 00:57:39 -0800
@@ -14,8 +14,6 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "gfx_common.h"
 #include "tfb_draw.h"
 #include "drawcmd.h"
@@ -325,6 +323,7 @@ TFB_DrawImage_New (TFB_Canvas canvas)
 	img->last_scale_hs = NullHs;
 	img->last_scale_type = -1;
 	img->last_scale = 0;
+	img->dirty = FALSE;
 	TFB_DrawCanvas_GetExtent (canvas, &img->extent);
 
 	if (TFB_DrawCanvas_IsPaletted (canvas))
@@ -438,8 +437,16 @@ TFB_DrawImage_Delete (TFB_Image *image)
 
 	TFB_DrawCanvas_Delete (image->NormalImg);
 			
-	if (image->ScaledImg) {
+	if (image->ScaledImg)
+	{
 		TFB_DrawCanvas_Delete (image->ScaledImg);
+		image->ScaledImg = 0;
+	}
+
+	if (image->FilledImg)
+	{
+		TFB_DrawCanvas_Delete (image->FilledImg);
+		image->FilledImg = 0;
 	}
 
 	UnlockMutex (image->mutex);
diff -ruNp src.hd/libs/graphics/tfb_draw.h src/libs/graphics/tfb_draw.h
--- src.hd/libs/graphics/tfb_draw.h	2017-12-29 02:25:49 -0800
+++ src/libs/graphics/tfb_draw.h	2017-12-29 00:57:39 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #ifndef TFB_DRAW_H
 #define TFB_DRAW_H
 
diff -ruNp src.hd/libs/graphics/tfb_prim.c src/libs/graphics/tfb_prim.c
--- src.hd/libs/graphics/tfb_prim.c	2017-12-29 02:25:49 -0800
+++ src/libs/graphics/tfb_prim.c	2017-12-29 00:57:39 -0800
@@ -28,16 +28,17 @@
 #include "cmap.h"
 #include "libs/log.h"
 #include "uqm/units.h"
+#include "uqm/planets/planets.h"
 
 void
-TFB_Prim_Point (POINT *p, Color color, DrawMode mode, POINT ctxOrigin, BOOLEAN forSyreen)
+TFB_Prim_Point (POINT *p, Color color, DrawMode mode, POINT ctxOrigin)
 {
 	RECT r;
 
 	// The caller must scale the origin!
 	r.corner.x = p->x + ctxOrigin.x;
 	r.corner.y = p->y + ctxOrigin.y;
-	r.extent.width = r.extent.height = (forSyreen ? (1 << RESOLUTION_FACTOR) : 1);
+	r.extent.width = r.extent.height = 1;
 
 	if (_CurFramePtr->Type == SCREEN_DRAWABLE)
 		TFB_DrawScreen_Rect (&r, color, mode, TFB_SCREEN_MAIN);
@@ -132,7 +133,7 @@ TFB_Prim_Stamp (STAMP *stmp, DrawMode mo
 	if (!SrcFramePtr)
 	{
 		log_add (log_Warning, "TFB_Prim_Stamp: Tried to draw a NULL frame"
-				" (Stamp address = %p)", stmp);
+				" (Stamp address = %p)", (void *) stmp);
 		return;
 	}
 	img = SrcFramePtr->image;
@@ -181,7 +182,7 @@ TFB_Prim_StampFill (STAMP *stmp, Color c
 	if (!SrcFramePtr)
 	{
 		log_add (log_Warning, "TFB_Prim_StampFill: Tried to draw a NULL frame"
-				" (Stamp address = %p)", stmp);
+				" (Stamp address = %p)", (void *) stmp);
 		return;
 	}
 	img = SrcFramePtr->image;
diff -ruNp src.hd/libs/graphics/tfb_prim.h src/libs/graphics/tfb_prim.h
--- src.hd/libs/graphics/tfb_prim.h	2017-12-29 02:25:49 -0800
+++ src/libs/graphics/tfb_prim.h	2017-12-29 00:57:39 -0800
@@ -21,7 +21,7 @@
 
 
 void TFB_Prim_Line (LINE *, Color, DrawMode, POINT ctxOrigin);
-void TFB_Prim_Point (POINT *, Color, DrawMode, POINT ctxOrigin, BOOLEAN forSyreen);
+void TFB_Prim_Point (POINT *, Color, DrawMode, POINT ctxOrigin);
 void TFB_Prim_Rect (RECT *, Color, DrawMode, POINT ctxOrigin);
 void TFB_Prim_FillRect (RECT *, Color, DrawMode, POINT ctxOrigin);
 void TFB_Prim_Stamp (STAMP *, DrawMode, POINT ctxOrigin);
diff -ruNp src.hd/libs/graphics/widgets.c src/libs/graphics/widgets.c
--- src.hd/libs/graphics/widgets.c	2017-12-29 02:25:49 -0800
+++ src/libs/graphics/widgets.c	2017-12-29 00:57:39 -0800
@@ -14,31 +14,30 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/*
- * HD Mod: Copied verbatim from p6014 as of r2364, with RESOLUTION_FACTOR
- * search-and-replaced to RESOLUTION_FACTOR and the applicable include added.
- */
-
 #include "gfx_common.h"
 #include "widgets.h"
 #include "libs/strlib.h"
+#include "uqm/colors.h"
 #include "uqm/units.h"
 
 WIDGET *widget_focus = NULL;
 
 /* Some basic color defines */
 #define WIDGET_ACTIVE_COLOR \
-		BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x00), 0x0E)
+		MENU_HIGHLIGHT_COLOR
 #define WIDGET_INACTIVE_COLOR \
-		BUILD_COLOR (MAKE_RGB15 (0x13, 0x13, 0x19), 0x00)
+		BUILD_COLOR (MAKE_RGB15 (0x18, 0x18, 0x1F), 0x00)
 #define WIDGET_INACTIVE_SELECTED_COLOR \
-		BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x1F), 0x0F)
+		WHITE_COLOR
 #define WIDGET_CURSOR_COLOR \
-		BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x00), 0x00)
+		BLACK_COLOR
 #define WIDGET_DIALOG_COLOR \
-		BUILD_COLOR (MAKE_RGB15 (0x14, 0x14, 0x14), 0x07)
+		LTGRAY_COLOR
 #define WIDGET_DIALOG_TEXT_COLOR \
-		BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x00), 0x00)
+		WIDGET_CURSOR_COLOR
+
+#define WIDGET_ENABLED_COLOR \
+		BUILD_COLOR (MAKE_RGB15 (0x00, 0xC8, 0x00), 0x00)
 
 static Color win_bg_clr =
 		BUILD_COLOR (MAKE_RGB15_INIT (0x18, 0x18, 0x1F), 0x00);
@@ -104,7 +103,7 @@ DrawLabelAsWindow (WIDGET_LABEL *label,
 		oldfont = SetContextFont (cur_font);
 
 	/* Compute the dimensions of the label */
-	win_h = label->height ((WIDGET *)label) + 16; // JMS_GFX
+	win_h = label->height ((WIDGET *)label) + (16 << RESOLUTION_FACTOR);
 	win_w = 0;
 	for (i = 0; i < label->line_count; i++)
 	{
@@ -173,11 +172,10 @@ Widget_DrawToolTips (int numlines, const
 {
 	// This functions draws the text at the bottom of the screen
 	// which explains what the current option does.
-	
 	RECT r;
 	FONT  oldfont = 0;
 	FRAME oldFontEffect = SetContextFontEffect (NULL);
-	Color oldtext = SetContextForeGroundColor (WIDGET_INACTIVE_SELECTED_COLOR);
+	Color oldtext = SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x00, 0x18, 0x00), 0x0E));
 	TEXT t;
 	int i;
 
@@ -187,7 +185,7 @@ Widget_DrawToolTips (int numlines, const
 	r.corner.x = 2 << RESOLUTION_FACTOR; // JMS_GFX
 	r.corner.y = 2 << RESOLUTION_FACTOR; // JMS_GFX
 	r.extent.width = ScreenWidth - (4 << RESOLUTION_FACTOR); // JMS_GFX
-	r.extent.height = ScreenHeight - (4 << RESOLUTION_FACTOR); // JMS_GFX
+	r.extent.height = ScreenHeight + (2 << RESOLUTION_FACTOR); // JMS_GFX
 
 	t.align = ALIGN_CENTER;
 	t.CharCount = ~0;
@@ -278,7 +276,7 @@ Widget_DrawChoice (WIDGET *_self, int x,
 {
 	WIDGET_CHOICE *self = (WIDGET_CHOICE *)_self;
 	Color oldtext;
-	Color inactive, default_color, selected;
+	Color default_color, selected, enabled, disabled;
 	FONT  oldfont = 0;
 	FRAME oldFontEffect = SetContextFontEffect (NULL);
 	TEXT t;
@@ -288,10 +286,11 @@ Widget_DrawChoice (WIDGET *_self, int x,
 		oldfont = SetContextFont (cur_font);
 	
 	default_color = WIDGET_INACTIVE_SELECTED_COLOR;
+	enabled = WIDGET_ENABLED_COLOR;
+	disabled = DKGRAY_COLOR;
 	selected = WIDGET_ACTIVE_COLOR;
-	inactive = WIDGET_INACTIVE_COLOR;
 
-	t.baseline.x = x + 64 * RESOLUTION_FACTOR; // JMS_GFX
+	t.baseline.x = x + RES_SCALE(16);
 	t.baseline.y = y;
 	t.align = ALIGN_LEFT;
 	t.CharCount = ~0;
@@ -305,18 +304,17 @@ Widget_DrawChoice (WIDGET *_self, int x,
 		oldtext = SetContextForeGroundColor (default_color);
 	}
 	font_DrawText (&t);
-	
-	t.baseline.x -= 64 * RESOLUTION_FACTOR; // JMS_GFX
+
+	t.baseline.x -= t.baseline.x;
 
 	home_x = t.baseline.x + 3 * (ScreenWidth / ((self->maxcolumns + 1) * 2));
 	home_y = t.baseline.y;
 	t.align = ALIGN_CENTER;
-	
 	for (i = 0; i < self->numopts; i++)
 	{
 		t.baseline.x = home_x + ((i % 3) *
 				(ScreenWidth / (self->maxcolumns + 1)));
-		t.baseline.y = home_y + ((8 * (i / 3)) << RESOLUTION_FACTOR); // JMS_GFX
+		t.baseline.y = home_y + ((10 * (i / 3)) << RESOLUTION_FACTOR); // JMS_GFX // Was 8*(i/3): Changed for readability
 		t.pStr = self->options[i].optname;
 		if ((widget_focus == _self) &&
 		    (self->highlighted == i))
@@ -326,15 +324,14 @@ Widget_DrawChoice (WIDGET *_self, int x,
 		}
 		else if (i == self->selected)
 		{
-			SetContextForeGroundColor (default_color);
+			SetContextForeGroundColor (enabled);
 		}
 		else
 		{
-			SetContextForeGroundColor (inactive);
+			SetContextForeGroundColor (disabled);
 		}
 		font_DrawText (&t);
 	}
-	
 	SetContextFontEffect (oldFontEffect);
 	if (oldfont)
 		SetContextFont (oldfont);
@@ -401,7 +398,7 @@ Widget_DrawLabel (WIDGET *_self, int x,
 	{
 		t.pStr = self->lines[i];
 		font_DrawText (&t);
-		t.baseline.y += (8 << RESOLUTION_FACTOR); // JMS_GFX
+		t.baseline.y += (10 << RESOLUTION_FACTOR); // JMS_GFX
 	}
 	SetContextFontEffect (oldFontEffect);
 	if (oldfont)
@@ -429,7 +426,7 @@ Widget_DrawSlider(WIDGET *_self, int x,
 	selected = WIDGET_ACTIVE_COLOR;
 	inactive = WIDGET_INACTIVE_COLOR;
 
-	t.baseline.x = x + (64 * RESOLUTION_FACTOR); // JMS_GFX;
+	t.baseline.x = x + RES_SCALE(16);
 	t.baseline.y = y;
 	t.align = ALIGN_LEFT;
 	t.CharCount = ~0;
@@ -444,8 +441,8 @@ Widget_DrawSlider(WIDGET *_self, int x,
 		oldtext = SetContextForeGroundColor (default_color);
 	}
 	font_DrawText (&t);
-	
-	t.baseline.x -= 64 * RESOLUTION_FACTOR; // JMS_GFX;
+
+	t.baseline.x -= t.baseline.x;
 
 	r.corner.x = t.baseline.x + 3 * tick;
 	r.corner.y = t.baseline.y - 4;
@@ -504,7 +501,7 @@ Widget_DrawTextEntry (WIDGET *_self, int
 
 	BatchGraphics ();
 
-	t.baseline.x = x + (64 * RESOLUTION_FACTOR); // JMS_GFX
+	t.baseline.x = x + RES_SCALE(16);
 	t.baseline.y = y;
 	t.align = ALIGN_LEFT;
 	t.CharCount = ~0;
@@ -518,8 +515,8 @@ Widget_DrawTextEntry (WIDGET *_self, int
 		oldtext = SetContextForeGroundColor (default_color);
 	}
 	font_DrawText (&t);
-	
-	t.baseline.x -= 64 * RESOLUTION_FACTOR; // JMS_GFX
+
+	t.baseline.x -= t.baseline.x;
 
 	/* Force string termination */
 	self->value[WIDGET_TEXTENTRY_WIDTH-1] = 0;
@@ -642,7 +639,7 @@ Widget_DrawControlEntry (WIDGET *_self,
 	selected = WIDGET_ACTIVE_COLOR;
 	inactive = WIDGET_INACTIVE_COLOR;
 
-	t.baseline.x = x + (64 * RESOLUTION_FACTOR); // JMS_GFX
+	t.baseline.x = x + RES_SCALE(16);
 	t.baseline.y = y;
 	t.align = ALIGN_LEFT;
 	t.CharCount = ~0;
@@ -656,8 +653,8 @@ Widget_DrawControlEntry (WIDGET *_self,
 		oldtext = SetContextForeGroundColor (default_color);
 	}
 	font_DrawText (&t);
-	
-	t.baseline.x -= 64 * RESOLUTION_FACTOR; // JMS_GFX
+
+	t.baseline.x -= t.baseline.x;
 
         // 3 * ScreenWidth / ((self->maxcolumns + 1) * 2)) as per CHOICE, but only two options.
 	home_x = t.baseline.x + (ScreenWidth / 2); 
@@ -713,7 +710,7 @@ int
 Widget_HeightLabel (WIDGET *_self)
 {
 	WIDGET_LABEL *self = (WIDGET_LABEL *)_self;
-	return self->line_count * (8 << RESOLUTION_FACTOR); // JMS_GFX
+	return self->line_count * (8 << RESOLUTION_FACTOR);
 }
 
 int
diff -ruNp src.hd/libs/heap/Makeinfo src/libs/heap/Makeinfo
--- src.hd/libs/heap/Makeinfo	2017-12-29 02:25:49 -0800
+++ src/libs/heap/Makeinfo	2017-12-29 00:57:39 -0800
@@ -1,2 +1,2 @@
 uqm_CFILES="heap.c"
-
+uqm_HFILES="heap.h"
diff -ruNp src.hd/libs/heap/heap.c src/libs/heap/heap.c
--- src.hd/libs/heap/heap.c	2017-12-29 02:25:49 -0800
+++ src/libs/heap/heap.c	2017-12-29 00:57:39 -0800
@@ -49,7 +49,7 @@ Heap_new(HeapValue_Comparator comparator
 	heap->minSize = minSize;
 	heap->minFillQuotient = minFillQuotient;
 	heap->size = nextPower2(initialSize);
-	heap->minFill = (size_t) ceil(((double) (heap->size >> 1))
+	heap->minFill = ceil(((double) (heap->size >> 1))
 			* heap->minFillQuotient);
 	heap->entries = malloc(heap->size * sizeof (HeapValue *));
 	heap->numEntries = 0;
diff -ruNp src.hd/libs/heap.h src/libs/heap.h
--- src.hd/libs/heap.h	2017-12-29 02:25:49 -0800
+++ src/libs/heap.h	2017-12-29 00:57:39 -0800
@@ -1,2 +1,9 @@
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #include "heap/heap.h"
 
+#if defined(__cplusplus)
+}
+#endif
diff -ruNp src.hd/libs/inplib.h src/libs/inplib.h
--- src.hd/libs/inplib.h	2017-12-29 02:25:49 -0800
+++ src/libs/inplib.h	2017-12-29 00:57:39 -0800
@@ -24,6 +24,10 @@
 #include "libs/uio.h"
 #include "libs/unicode.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 
 extern BOOLEAN AnyButtonPress (BOOLEAN DetectSpecial);
 
@@ -49,9 +53,9 @@ UniChar GetLastCharacter (void);
 
 /* Interrogating the current key configuration */
 
-void InterrogateInputState (int template, int control, int index, char *buffer, int maxlen);
-void RemoveInputState (int template, int control, int index);
-void RebindInputState (int template, int control, int index);
+void InterrogateInputState (int templat, int control, int index, char *buffer, int maxlen);
+void RemoveInputState (int templat, int control, int index);
+void RebindInputState (int templat, int control, int index);
 
 void SaveKeyConfiguration (uio_DirHandle *path, const char *fname);
 
@@ -59,5 +63,9 @@ void SaveKeyConfiguration (uio_DirHandle
 
 void BeginInputFrame (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _INPLIB_H */
 
diff -ruNp src.hd/libs/input/Makeinfo src/libs/input/Makeinfo
--- src.hd/libs/input/Makeinfo	2017-12-29 02:25:49 -0800
+++ src/libs/input/Makeinfo	2017-12-29 00:57:39 -0800
@@ -3,3 +3,4 @@ if [ "$uqm_GFXMODULE" = "sdl" ]; then
 fi
 
 uqm_CFILES="input_common.c"
+uqm_HFILES="inpintrn.h input_common.h"
diff -ruNp src.hd/libs/input/sdl/Makeinfo src/libs/input/sdl/Makeinfo
--- src.hd/libs/input/sdl/Makeinfo	2017-12-29 02:25:49 -0800
+++ src/libs/input/sdl/Makeinfo	2017-12-29 00:57:39 -0800
@@ -1 +1,2 @@
 uqm_CFILES="input.c keynames.c vcontrol.c"
+uqm_HFILES="input.h keynames.h vcontrol.h"
diff -ruNp src.hd/libs/input/sdl/input.c src/libs/input/sdl/input.c
--- src.hd/libs/input/sdl/input.c	2017-12-29 02:25:49 -0800
+++ src/libs/input/sdl/input.c	2017-12-29 00:57:39 -0800
@@ -18,8 +18,10 @@
 
 #include <assert.h>
 #include <errno.h>
+#include <string.h>
+#include "input.h"
 #include "../inpintrn.h"
-#include "libs/graphics/sdl/sdl_common.h"
+#include "libs/threadlib.h"
 #include "libs/input/sdl/vcontrol.h"
 #include "libs/input/sdl/keynames.h"
 #include "libs/memlib.h"
@@ -33,7 +35,7 @@
 static int kbdhead=0, kbdtail=0;
 static UniChar kbdbuf[KBDBUFSIZE];
 static UniChar lastchar;
-static unsigned int num_keys = 0;
+static int num_keys = 0;
 static int *kbdstate = NULL;
 		// Holds all SDL keys +1 for holding invalid values
 
@@ -217,22 +219,13 @@ TFB_SetInputVectors (volatile int menu[]
 	num_flight = num_flight_;
 }
 
-int 
-TFB_InitInput (int driver, int flags)
+#ifdef HAVE_JOYSTICK
+
+static void
+initJoystick (void)
 {
-	int i;
 	int nJoysticks;
-	int signed_num_keys; // JMS: New variable to silence warnings
-	(void)driver;
-	(void)flags;
 
-	SDL_EnableUNICODE(1);
-	(void)SDL_GetKeyState (&signed_num_keys);
-	num_keys = (unsigned int) signed_num_keys;
-	kbdstate = (int *)HMalloc (sizeof (int) * (num_keys + 1));
-	
-
-#ifdef HAVE_JOYSTICK
 	if ((SDL_InitSubSystem(SDL_INIT_JOYSTICK)) == -1)
 	{
 		log_add (log_Fatal, "Couldn't initialize joystick subsystem: %s",
@@ -245,6 +238,8 @@ TFB_InitInput (int driver, int flags)
 	nJoysticks = SDL_NumJoysticks ();
 	if (nJoysticks > 0)
 	{
+		int i;
+
 		log_add (log_Info, "The names of the joysticks are:");
 		for (i = 0; i < nJoysticks; i++)
 		{
@@ -252,6 +247,25 @@ TFB_InitInput (int driver, int flags)
 		}
 		SDL_JoystickEventState (SDL_ENABLE);
 	}
+}
+
+#endif /* HAVE_JOYSTICK */
+
+int 
+TFB_InitInput (int driver, int flags)
+{
+	int signed_num_keys; // JMS: New variable to silence warnings
+	(void)driver;
+	(void)flags;
+
+	SDL_EnableUNICODE(1);
+	(void)SDL_GetKeyState (&signed_num_keys);
+	num_keys = (unsigned int) signed_num_keys;
+	kbdstate = (int *)HMalloc (sizeof (int) * (num_keys + 1));
+	
+
+#ifdef HAVE_JOYSTICK
+	initJoystick ();
 #endif /* HAVE_JOYSTICK */
 
 	in_character_mode = FALSE;
@@ -265,7 +279,6 @@ TFB_InitInput (int driver, int flags)
 	VControl_ResetInput ();
 	InputInitialized = TRUE;
 
-	atexit (TFB_UninitInput);
 	return 0;
 }
 
@@ -314,7 +327,7 @@ GetLastCharacter (void)
 
 volatile int MouseButtonDown = 0;
 
-void
+static void
 ProcessMouseEvent (const SDL_Event *e)
 {
 	switch (e->type)
@@ -356,10 +369,12 @@ ProcessInputEvent (const SDL_Event *Even
 
 	if (Event->type == SDL_KEYDOWN || Event->type == SDL_KEYUP)
 	{	// process character input event, if any
-		SDLKey k = Event->key.keysym.sym;
+		// keysym.sym is an SDLKey type which is an enum and can be signed
+		// or unsigned on different platforms; we'll use a guaranteed type
+		int k = Event->key.keysym.sym;
 		UniChar map_key = Event->key.keysym.unicode;
 
-		if (k > num_keys)
+		if (k < 0 || k > num_keys)
 			k = num_keys; // for unknown keys
 
 		if (Event->type == SDL_KEYDOWN)
@@ -410,11 +425,11 @@ TFB_ResetControls (void)
 }
 
 void
-InterrogateInputState (int template, int control, int index, char *buffer, int maxlen)
+InterrogateInputState (int templat, int control, int index, char *buffer, int maxlen)
 {
-	VCONTROL_GESTURE *g = CONTROL_PTR(template, control, index);
+	VCONTROL_GESTURE *g = CONTROL_PTR(templat, control, index);
 
-	if (template >= num_templ || control >= num_flight
+	if (templat >= num_templ || control >= num_flight
 			|| index >= MAX_FLIGHT_ALTERNATES)
 	{
 		log_add (log_Warning, "InterrogateInputState(): invalid control index");
@@ -447,13 +462,13 @@ InterrogateInputState (int template, int
 }
 
 void
-RemoveInputState (int template, int control, int index)
+RemoveInputState (int templat, int control, int index)
 {
-	VCONTROL_GESTURE *g = CONTROL_PTR(template, control, index);
+	VCONTROL_GESTURE *g = CONTROL_PTR(templat, control, index);
 	char keybuf[40];
 	keybuf[39] = '\0';
 
-	if (template >= num_templ || control >= num_flight
+	if (templat >= num_templ || control >= num_flight
 			|| index >= MAX_FLIGHT_ALTERNATES)
 	{
 		log_add (log_Warning, "RemoveInputState(): invalid control index");
@@ -461,23 +476,23 @@ RemoveInputState (int template, int cont
 	}
 
 	VControl_RemoveGestureBinding (g,
-			(int *)(flight_vec + template * num_flight + control));
+			(int *)(flight_vec + templat * num_flight + control));
 	g->type = VCONTROL_NONE;
 
-	snprintf (keybuf, 39, "keys.%d.%s.%d", template+1, flight_res_names[control], index+1);
+	snprintf (keybuf, 39, "keys.%d.%s.%d", templat+1, flight_res_names[control], index+1);
 	res_Remove (keybuf);
 
 	return;
 }
 
 void
-RebindInputState (int template, int control, int index)
+RebindInputState (int templat, int control, int index)
 {
 	VCONTROL_GESTURE g;
 	char keybuf[40], valbuf[40];
 	keybuf[39] = valbuf[39] = '\0';
 
-	if (template >= num_templ || control >= num_flight
+	if (templat >= num_templ || control >= num_flight
 			|| index >= MAX_FLIGHT_ALTERNATES)
 	{
 		log_add (log_Warning, "RebindInputState(): invalid control index");
@@ -485,7 +500,7 @@ RebindInputState (int template, int cont
 	}
 
 	/* Remove the old binding on this spot */
-	RemoveInputState (template, control, index);
+	RemoveInputState (templat, control, index);
 
 	/* Wait for the next interesting bit of user input */
 	VControl_ClearGesture ();
@@ -496,9 +511,9 @@ RebindInputState (int template, int cont
 
 	/* And now, add the new binding. */
 	VControl_AddGestureBinding (&g,
-			(int *)(flight_vec + template * num_flight + control));
-	*CONTROL_PTR(template, control, index) = g;
-	snprintf (keybuf, 39, "keys.%d.%s.%d", template+1, flight_res_names[control], index+1);
+			(int *)(flight_vec + templat * num_flight + control));
+	*CONTROL_PTR(templat, control, index) = g;
+	snprintf (keybuf, 39, "keys.%d.%s.%d", templat+1, flight_res_names[control], index+1);
 	VControl_DumpGesture (valbuf, 39, &g);
 	res_PutString (keybuf, valbuf);
 }
diff -ruNp src.hd/libs/input/sdl/input.h src/libs/input/sdl/input.h
--- src.hd/libs/input/sdl/input.h	2017-12-29 02:25:49 -0800
+++ src/libs/input/sdl/input.h	2017-12-29 00:57:39 -0800
@@ -19,6 +19,9 @@
 #ifndef INPUT_H
 #define INPUT_H
 
+#include "port.h"
+#include SDL_INCLUDE(SDL.h)
+
 extern void ProcessInputEvent (const SDL_Event *Event);
 
 #endif
diff -ruNp src.hd/libs/input/sdl/keynames.c src/libs/input/sdl/keynames.c
--- src.hd/libs/input/sdl/keynames.c	2017-12-29 02:25:49 -0800
+++ src/libs/input/sdl/keynames.c	2017-12-29 00:57:39 -0800
@@ -33,7 +33,7 @@
  * tragedy. */
 
 typedef struct vcontrol_keyname {
-	/* const */ char *name;
+	const char *name;
 	int code;
 } keyname;
 
@@ -182,7 +182,7 @@ static keyname keynames[] = {
 	{"Unknown", 0}};
 /* Last element must have code zero */
 
-char *
+const char *
 VControl_code2name (int code)
 {
 	int i = 0;
@@ -198,12 +198,12 @@ VControl_code2name (int code)
 }
 
 int
-VControl_name2code (char *name)
+VControl_name2code (const char *name)
 {
 	int i = 0;
 	while (1)
 	{
-		char *test = keynames[i].name;
+		const char *test = keynames[i].name;
 		int code = keynames[i].code;
 		if (!strcasecmp(test, name) || !code)
 		{
diff -ruNp src.hd/libs/input/sdl/keynames.h src/libs/input/sdl/keynames.h
--- src.hd/libs/input/sdl/keynames.h	2017-12-29 02:25:49 -0800
+++ src/libs/input/sdl/keynames.h	2017-12-29 00:57:39 -0800
@@ -17,6 +17,6 @@
 #ifndef _KEYNAMES_H_
 #define _KEYNAMES_H_
 
-char *VControl_code2name (int code);
-int VControl_name2code (char *code);
+const char *VControl_code2name (int code);
+int VControl_name2code (const char *code);
 #endif
diff -ruNp src.hd/libs/input/sdl/vcontrol.c src/libs/input/sdl/vcontrol.c
--- src.hd/libs/input/sdl/vcontrol.c	2017-12-29 02:25:49 -0800
+++ src/libs/input/sdl/vcontrol.c	2017-12-29 00:57:39 -0800
@@ -185,6 +185,8 @@ key_init (void)
 {
 	unsigned int i;
 	int signed_num_sdl_keys; // JMS: New variable to silence warnings
+	int num_keys; // Temp to match type of param for SDL_GetKeyState().
+
 	pool = allocate_key_chunk ();
 	(void)SDL_GetKeyState (&signed_num_sdl_keys); // JMS: was num_sdl_keys
 	num_sdl_keys = (unsigned int) signed_num_sdl_keys; // JMS: new line
@@ -1265,7 +1267,7 @@ VControl_ParseGesture (VCONTROL_GESTURE
 	parse_state ps;
 
 	strncpy (ps.line, spec, LINE_SIZE);
-	ps.line[LINE_SIZE] = '\0';
+	ps.line[LINE_SIZE - 1] = '\0';
 	ps.index = ps.error = 0;
 	ps.linenum = -1;
 
diff -ruNp src.hd/libs/list/Makeinfo src/libs/list/Makeinfo
--- src.hd/libs/list/Makeinfo	2017-12-29 02:25:49 -0800
+++ src/libs/list/Makeinfo	2017-12-29 00:57:39 -0800
@@ -1 +1,2 @@
 uqm_CFILES="list.c"
+uqm_HFILES="list.h"
diff -ruNp src.hd/libs/list.h src/libs/list.h
--- src.hd/libs/list.h	2017-12-29 02:25:49 -0800
+++ src/libs/list.h	2017-12-29 00:57:40 -0800
@@ -16,5 +16,14 @@
  *
  */
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #include "list/list.h"
 
+#if defined(__cplusplus)
+}
+#endif
+
+
diff -ruNp src.hd/libs/log/Makeinfo src/libs/log/Makeinfo
--- src.hd/libs/log/Makeinfo	2017-12-29 02:25:49 -0800
+++ src/libs/log/Makeinfo	2017-12-29 00:57:40 -0800
@@ -1,4 +1,5 @@
 uqm_CFILES="uqmlog.c"
+uqm_HFILES="loginternal.h msgbox.h uqmlog.h"
 
 case "$HOST_SYSTEM" in
 	Darwin)
@@ -11,3 +12,4 @@ case "$HOST_SYSTEM" in
 		uqm_CFILES="$uqm_CFILES msgbox_stub.c"
 		;;
 esac
+
diff -ruNp src.hd/libs/log/uqmlog.c src/libs/log/uqmlog.c
--- src.hd/libs/log/uqmlog.c	2017-12-29 02:25:49 -0800
+++ src/libs/log/uqmlog.c	2017-12-29 00:57:40 -0800
@@ -26,7 +26,7 @@
 #include "libs/threadlib.h"
 
 #ifndef MAX_LOG_ENTRY_SIZE
-#	define MAX_LOG_ENTRY_SIZE 256
+#	define MAX_LOG_ENTRY_SIZE 1024
 #endif
 
 #ifndef MAX_LOG_ENTRIES
@@ -159,6 +159,7 @@ log_exit (int code)
 	{
 		qlock = 0;
 		DestroyMutex (qmutex);
+		qmutex = 0;
 	}
 
 	return code;
diff -ruNp src.hd/libs/log.h src/libs/log.h
--- src.hd/libs/log.h	2017-12-29 02:25:49 -0800
+++ src/libs/log.h	2017-12-29 00:57:40 -0800
@@ -14,4 +14,12 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #include "log/uqmlog.h"
+
+#if defined(__cplusplus)
+}
+#endif
diff -ruNp src.hd/libs/lua/Makeinfo src/libs/lua/Makeinfo
--- src.hd/libs/lua/Makeinfo	1969-12-31 16:00:00 -0800
+++ src/libs/lua/Makeinfo	2017-12-29 00:57:40 -0800
@@ -0,0 +1,3 @@
+uqm_CFILES="lapi.c lauxlib.c lbaselib.c lbitlib.c lcode.c lctype.c ldebug.c ldo.c ldump.c lfunc.c lgc.c llex.c lmathlib.c lmem.c lobject.c lopcodes.c lparser.c lstate.c lstring.c lstrlib.c ltable.c ltablib.c ltm.c lundump.c lvm.c lzio.c"
+uqm_HFILES="lapi.h lauxlib.h lcode.h lctype.h ldebug.h ldo.h lfunc.h lgc.h llex.h llimits.h lmem.h lobject.h lopcodes.h lparser.h lstate.h lstring.h ltable.h ltm.h luaconf.h lua.h lualib.h lundump.h lvm.h lzio.h"
+
diff -ruNp src.hd/libs/lua/lapi.c src/libs/lua/lapi.c
--- src.hd/libs/lua/lapi.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lapi.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,1284 @@
+/*
+** $Id: lapi.c,v 2.171 2013/03/16 21:10:18 roberto Exp $
+** Lua API
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdarg.h>
+#include <string.h>
+
+#define lapi_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lapi.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+#include "lundump.h"
+#include "lvm.h"
+
+
+
+const char lua_ident[] =
+  "$LuaVersion: " LUA_COPYRIGHT " $"
+  "$LuaAuthors: " LUA_AUTHORS " $";
+
+
+/* value at a non-valid index */
+#define NONVALIDVALUE		cast(TValue *, luaO_nilobject)
+
+/* corresponding test */
+#define isvalid(o)	((o) != luaO_nilobject)
+
+/* test for pseudo index */
+#define ispseudo(i)		((i) <= LUA_REGISTRYINDEX)
+
+/* test for valid but not pseudo index */
+#define isstackindex(i, o)	(isvalid(o) && !ispseudo(i))
+
+#define api_checkvalidindex(L, o)  api_check(L, isvalid(o), "invalid index")
+
+#define api_checkstackindex(L, i, o)  \
+	api_check(L, isstackindex(i, o), "index not in the stack")
+
+
+static TValue *index2addr (lua_State *L, int idx) {
+  CallInfo *ci = L->ci;
+  if (idx > 0) {
+    TValue *o = ci->func + idx;
+    api_check(L, idx <= ci->top - (ci->func + 1), "unacceptable index");
+    if (o >= L->top) return NONVALIDVALUE;
+    else return o;
+  }
+  else if (!ispseudo(idx)) {  /* negative index */
+    api_check(L, idx != 0 && -idx <= L->top - (ci->func + 1), "invalid index");
+    return L->top + idx;
+  }
+  else if (idx == LUA_REGISTRYINDEX)
+    return &G(L)->l_registry;
+  else {  /* upvalues */
+    idx = LUA_REGISTRYINDEX - idx;
+    api_check(L, idx <= MAXUPVAL + 1, "upvalue index too large");
+    if (ttislcf(ci->func))  /* light C function? */
+      return NONVALIDVALUE;  /* it has no upvalues */
+    else {
+      CClosure *func = clCvalue(ci->func);
+      return (idx <= func->nupvalues) ? &func->upvalue[idx-1] : NONVALIDVALUE;
+    }
+  }
+}
+
+
+/*
+** to be called by 'lua_checkstack' in protected mode, to grow stack
+** capturing memory errors
+*/
+static void growstack (lua_State *L, void *ud) {
+  int size = *(int *)ud;
+  luaD_growstack(L, size);
+}
+
+
+LUA_API int lua_checkstack (lua_State *L, int size) {
+  int res;
+  CallInfo *ci = L->ci;
+  lua_lock(L);
+  if (L->stack_last - L->top > size)  /* stack large enough? */
+    res = 1;  /* yes; check is OK */
+  else {  /* no; need to grow stack */
+    int inuse = cast_int(L->top - L->stack) + EXTRA_STACK;
+    if (inuse > LUAI_MAXSTACK - size)  /* can grow without overflow? */
+      res = 0;  /* no */
+    else  /* try to grow stack */
+      res = (luaD_rawrunprotected(L, &growstack, &size) == LUA_OK);
+  }
+  if (res && ci->top < L->top + size)
+    ci->top = L->top + size;  /* adjust frame top */
+  lua_unlock(L);
+  return res;
+}
+
+
+LUA_API void lua_xmove (lua_State *from, lua_State *to, int n) {
+  int i;
+  if (from == to) return;
+  lua_lock(to);
+  api_checknelems(from, n);
+  api_check(from, G(from) == G(to), "moving among independent states");
+  api_check(from, to->ci->top - to->top >= n, "not enough elements to move");
+  from->top -= n;
+  for (i = 0; i < n; i++) {
+    setobj2s(to, to->top++, from->top + i);
+  }
+  lua_unlock(to);
+}
+
+
+LUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf) {
+  lua_CFunction old;
+  lua_lock(L);
+  old = G(L)->panic;
+  G(L)->panic = panicf;
+  lua_unlock(L);
+  return old;
+}
+
+
+LUA_API const lua_Number *lua_version (lua_State *L) {
+  static const lua_Number version = LUA_VERSION_NUM;
+  if (L == NULL) return &version;
+  else return G(L)->version;
+}
+
+
+
+/*
+** basic stack manipulation
+*/
+
+
+/*
+** convert an acceptable stack index into an absolute index
+*/
+LUA_API int lua_absindex (lua_State *L, int idx) {
+  return (idx > 0 || ispseudo(idx))
+         ? idx
+         : cast_int(L->top - L->ci->func + idx);
+}
+
+
+LUA_API int lua_gettop (lua_State *L) {
+  return cast_int(L->top - (L->ci->func + 1));
+}
+
+
+LUA_API void lua_settop (lua_State *L, int idx) {
+  StkId func = L->ci->func;
+  lua_lock(L);
+  if (idx >= 0) {
+    api_check(L, idx <= L->stack_last - (func + 1), "new top too large");
+    while (L->top < (func + 1) + idx)
+      setnilvalue(L->top++);
+    L->top = (func + 1) + idx;
+  }
+  else {
+    api_check(L, -(idx+1) <= (L->top - (func + 1)), "invalid new top");
+    L->top += idx+1;  /* `subtract' index (index is negative) */
+  }
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_remove (lua_State *L, int idx) {
+  StkId p;
+  lua_lock(L);
+  p = index2addr(L, idx);
+  api_checkstackindex(L, idx, p);
+  while (++p < L->top) setobjs2s(L, p-1, p);
+  L->top--;
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_insert (lua_State *L, int idx) {
+  StkId p;
+  StkId q;
+  lua_lock(L);
+  p = index2addr(L, idx);
+  api_checkstackindex(L, idx, p);
+  for (q = L->top; q > p; q--)  /* use L->top as a temporary */
+    setobjs2s(L, q, q - 1);
+  setobjs2s(L, p, L->top);
+  lua_unlock(L);
+}
+
+
+static void moveto (lua_State *L, TValue *fr, int idx) {
+  TValue *to = index2addr(L, idx);
+  api_checkvalidindex(L, to);
+  setobj(L, to, fr);
+  if (idx < LUA_REGISTRYINDEX)  /* function upvalue? */
+    luaC_barrier(L, clCvalue(L->ci->func), fr);
+  /* LUA_REGISTRYINDEX does not need gc barrier
+     (collector revisits it before finishing collection) */
+}
+
+
+LUA_API void lua_replace (lua_State *L, int idx) {
+  lua_lock(L);
+  api_checknelems(L, 1);
+  moveto(L, L->top - 1, idx);
+  L->top--;
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_copy (lua_State *L, int fromidx, int toidx) {
+  TValue *fr;
+  lua_lock(L);
+  fr = index2addr(L, fromidx);
+  moveto(L, fr, toidx);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushvalue (lua_State *L, int idx) {
+  lua_lock(L);
+  setobj2s(L, L->top, index2addr(L, idx));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+
+/*
+** access functions (stack -> C)
+*/
+
+
+LUA_API int lua_type (lua_State *L, int idx) {
+  StkId o = index2addr(L, idx);
+  return (isvalid(o) ? ttypenv(o) : LUA_TNONE);
+}
+
+
+LUA_API const char *lua_typename (lua_State *L, int t) {
+  UNUSED(L);
+  return ttypename(t);
+}
+
+
+LUA_API int lua_iscfunction (lua_State *L, int idx) {
+  StkId o = index2addr(L, idx);
+  return (ttislcf(o) || (ttisCclosure(o)));
+}
+
+
+LUA_API int lua_isnumber (lua_State *L, int idx) {
+  TValue n;
+  const TValue *o = index2addr(L, idx);
+  return tonumber(o, &n);
+}
+
+
+LUA_API int lua_isstring (lua_State *L, int idx) {
+  int t = lua_type(L, idx);
+  return (t == LUA_TSTRING || t == LUA_TNUMBER);
+}
+
+
+LUA_API int lua_isuserdata (lua_State *L, int idx) {
+  const TValue *o = index2addr(L, idx);
+  return (ttisuserdata(o) || ttislightuserdata(o));
+}
+
+
+LUA_API int lua_rawequal (lua_State *L, int index1, int index2) {
+  StkId o1 = index2addr(L, index1);
+  StkId o2 = index2addr(L, index2);
+  return (isvalid(o1) && isvalid(o2)) ? luaV_rawequalobj(o1, o2) : 0;
+}
+
+
+LUA_API void lua_arith (lua_State *L, int op) {
+  StkId o1;  /* 1st operand */
+  StkId o2;  /* 2nd operand */
+  lua_lock(L);
+  if (op != LUA_OPUNM) /* all other operations expect two operands */
+    api_checknelems(L, 2);
+  else {  /* for unary minus, add fake 2nd operand */
+    api_checknelems(L, 1);
+    setobjs2s(L, L->top, L->top - 1);
+    L->top++;
+  }
+  o1 = L->top - 2;
+  o2 = L->top - 1;
+  if (ttisnumber(o1) && ttisnumber(o2)) {
+    setnvalue(o1, luaO_arith(op, nvalue(o1), nvalue(o2)));
+  }
+  else
+    luaV_arith(L, o1, o1, o2, cast(TMS, op - LUA_OPADD + TM_ADD));
+  L->top--;
+  lua_unlock(L);
+}
+
+
+LUA_API int lua_compare (lua_State *L, int index1, int index2, int op) {
+  StkId o1, o2;
+  int i = 0;
+  lua_lock(L);  /* may call tag method */
+  o1 = index2addr(L, index1);
+  o2 = index2addr(L, index2);
+  if (isvalid(o1) && isvalid(o2)) {
+    switch (op) {
+      case LUA_OPEQ: i = equalobj(L, o1, o2); break;
+      case LUA_OPLT: i = luaV_lessthan(L, o1, o2); break;
+      case LUA_OPLE: i = luaV_lessequal(L, o1, o2); break;
+      default: api_check(L, 0, "invalid option");
+    }
+  }
+  lua_unlock(L);
+  return i;
+}
+
+
+LUA_API lua_Number lua_tonumberx (lua_State *L, int idx, int *isnum) {
+  TValue n;
+  const TValue *o = index2addr(L, idx);
+  if (tonumber(o, &n)) {
+    if (isnum) *isnum = 1;
+    return nvalue(o);
+  }
+  else {
+    if (isnum) *isnum = 0;
+    return 0;
+  }
+}
+
+
+LUA_API lua_Integer lua_tointegerx (lua_State *L, int idx, int *isnum) {
+  TValue n;
+  const TValue *o = index2addr(L, idx);
+  if (tonumber(o, &n)) {
+    lua_Integer res;
+    lua_Number num = nvalue(o);
+    lua_number2integer(res, num);
+    if (isnum) *isnum = 1;
+    return res;
+  }
+  else {
+    if (isnum) *isnum = 0;
+    return 0;
+  }
+}
+
+
+LUA_API lua_Unsigned lua_tounsignedx (lua_State *L, int idx, int *isnum) {
+  TValue n;
+  const TValue *o = index2addr(L, idx);
+  if (tonumber(o, &n)) {
+    lua_Unsigned res;
+    lua_Number num = nvalue(o);
+    lua_number2unsigned(res, num);
+    if (isnum) *isnum = 1;
+    return res;
+  }
+  else {
+    if (isnum) *isnum = 0;
+    return 0;
+  }
+}
+
+
+LUA_API int lua_toboolean (lua_State *L, int idx) {
+  const TValue *o = index2addr(L, idx);
+  return !l_isfalse(o);
+}
+
+
+LUA_API const char *lua_tolstring (lua_State *L, int idx, size_t *len) {
+  StkId o = index2addr(L, idx);
+  if (!ttisstring(o)) {
+    lua_lock(L);  /* `luaV_tostring' may create a new string */
+    if (!luaV_tostring(L, o)) {  /* conversion failed? */
+      if (len != NULL) *len = 0;
+      lua_unlock(L);
+      return NULL;
+    }
+    luaC_checkGC(L);
+    o = index2addr(L, idx);  /* previous call may reallocate the stack */
+    lua_unlock(L);
+  }
+  if (len != NULL) *len = tsvalue(o)->len;
+  return svalue(o);
+}
+
+
+LUA_API size_t lua_rawlen (lua_State *L, int idx) {
+  StkId o = index2addr(L, idx);
+  switch (ttypenv(o)) {
+    case LUA_TSTRING: return tsvalue(o)->len;
+    case LUA_TUSERDATA: return uvalue(o)->len;
+    case LUA_TTABLE: return luaH_getn(hvalue(o));
+    default: return 0;
+  }
+}
+
+
+LUA_API lua_CFunction lua_tocfunction (lua_State *L, int idx) {
+  StkId o = index2addr(L, idx);
+  if (ttislcf(o)) return fvalue(o);
+  else if (ttisCclosure(o))
+    return clCvalue(o)->f;
+  else return NULL;  /* not a C function */
+}
+
+
+LUA_API void *lua_touserdata (lua_State *L, int idx) {
+  StkId o = index2addr(L, idx);
+  switch (ttypenv(o)) {
+    case LUA_TUSERDATA: return (rawuvalue(o) + 1);
+    case LUA_TLIGHTUSERDATA: return pvalue(o);
+    default: return NULL;
+  }
+}
+
+
+LUA_API lua_State *lua_tothread (lua_State *L, int idx) {
+  StkId o = index2addr(L, idx);
+  return (!ttisthread(o)) ? NULL : thvalue(o);
+}
+
+
+LUA_API const void *lua_topointer (lua_State *L, int idx) {
+  StkId o = index2addr(L, idx);
+  switch (ttype(o)) {
+    case LUA_TTABLE: return hvalue(o);
+    case LUA_TLCL: return clLvalue(o);
+    case LUA_TCCL: return clCvalue(o);
+    case LUA_TLCF: return cast(void *, cast(size_t, fvalue(o)));
+    case LUA_TTHREAD: return thvalue(o);
+    case LUA_TUSERDATA:
+    case LUA_TLIGHTUSERDATA:
+      return lua_touserdata(L, idx);
+    default: return NULL;
+  }
+}
+
+
+
+/*
+** push functions (C -> stack)
+*/
+
+
+LUA_API void lua_pushnil (lua_State *L) {
+  lua_lock(L);
+  setnilvalue(L->top);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushnumber (lua_State *L, lua_Number n) {
+  lua_lock(L);
+  setnvalue(L->top, n);
+  luai_checknum(L, L->top,
+    luaG_runerror(L, "C API - attempt to push a signaling NaN"));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushinteger (lua_State *L, lua_Integer n) {
+  lua_lock(L);
+  setnvalue(L->top, cast_num(n));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushunsigned (lua_State *L, lua_Unsigned u) {
+  lua_Number n;
+  lua_lock(L);
+  n = lua_unsigned2number(u);
+  setnvalue(L->top, n);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API const char *lua_pushlstring (lua_State *L, const char *s, size_t len) {
+  TString *ts;
+  lua_lock(L);
+  luaC_checkGC(L);
+  ts = luaS_newlstr(L, s, len);
+  setsvalue2s(L, L->top, ts);
+  api_incr_top(L);
+  lua_unlock(L);
+  return getstr(ts);
+}
+
+
+LUA_API const char *lua_pushstring (lua_State *L, const char *s) {
+  if (s == NULL) {
+    lua_pushnil(L);
+    return NULL;
+  }
+  else {
+    TString *ts;
+    lua_lock(L);
+    luaC_checkGC(L);
+    ts = luaS_new(L, s);
+    setsvalue2s(L, L->top, ts);
+    api_incr_top(L);
+    lua_unlock(L);
+    return getstr(ts);
+  }
+}
+
+
+LUA_API const char *lua_pushvfstring (lua_State *L, const char *fmt,
+                                      va_list argp) {
+  const char *ret;
+  lua_lock(L);
+  luaC_checkGC(L);
+  ret = luaO_pushvfstring(L, fmt, argp);
+  lua_unlock(L);
+  return ret;
+}
+
+
+LUA_API const char *lua_pushfstring (lua_State *L, const char *fmt, ...) {
+  const char *ret;
+  va_list argp;
+  lua_lock(L);
+  luaC_checkGC(L);
+  va_start(argp, fmt);
+  ret = luaO_pushvfstring(L, fmt, argp);
+  va_end(argp);
+  lua_unlock(L);
+  return ret;
+}
+
+
+LUA_API void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n) {
+  lua_lock(L);
+  if (n == 0) {
+    setfvalue(L->top, fn);
+  }
+  else {
+    Closure *cl;
+    api_checknelems(L, n);
+    api_check(L, n <= MAXUPVAL, "upvalue index too large");
+    luaC_checkGC(L);
+    cl = luaF_newCclosure(L, n);
+    cl->c.f = fn;
+    L->top -= n;
+    while (n--)
+      setobj2n(L, &cl->c.upvalue[n], L->top + n);
+    setclCvalue(L, L->top, cl);
+  }
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushboolean (lua_State *L, int b) {
+  lua_lock(L);
+  setbvalue(L->top, (b != 0));  /* ensure that true is 1 */
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_pushlightuserdata (lua_State *L, void *p) {
+  lua_lock(L);
+  setpvalue(L->top, p);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API int lua_pushthread (lua_State *L) {
+  lua_lock(L);
+  setthvalue(L, L->top, L);
+  api_incr_top(L);
+  lua_unlock(L);
+  return (G(L)->mainthread == L);
+}
+
+
+
+/*
+** get functions (Lua -> stack)
+*/
+
+
+LUA_API void lua_getglobal (lua_State *L, const char *var) {
+  Table *reg = hvalue(&G(L)->l_registry);
+  const TValue *gt;  /* global table */
+  lua_lock(L);
+  gt = luaH_getint(reg, LUA_RIDX_GLOBALS);
+  setsvalue2s(L, L->top++, luaS_new(L, var));
+  luaV_gettable(L, gt, L->top - 1, L->top - 1);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_gettable (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  t = index2addr(L, idx);
+  luaV_gettable(L, t, L->top - 1, L->top - 1);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_getfield (lua_State *L, int idx, const char *k) {
+  StkId t;
+  lua_lock(L);
+  t = index2addr(L, idx);
+  setsvalue2s(L, L->top, luaS_new(L, k));
+  api_incr_top(L);
+  luaV_gettable(L, t, L->top - 1, L->top - 1);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawget (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  t = index2addr(L, idx);
+  api_check(L, ttistable(t), "table expected");
+  setobj2s(L, L->top - 1, luaH_get(hvalue(t), L->top - 1));
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawgeti (lua_State *L, int idx, int n) {
+  StkId t;
+  lua_lock(L);
+  t = index2addr(L, idx);
+  api_check(L, ttistable(t), "table expected");
+  setobj2s(L, L->top, luaH_getint(hvalue(t), n));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawgetp (lua_State *L, int idx, const void *p) {
+  StkId t;
+  TValue k;
+  lua_lock(L);
+  t = index2addr(L, idx);
+  api_check(L, ttistable(t), "table expected");
+  setpvalue(&k, cast(void *, p));
+  setobj2s(L, L->top, luaH_get(hvalue(t), &k));
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_createtable (lua_State *L, int narray, int nrec) {
+  Table *t;
+  lua_lock(L);
+  luaC_checkGC(L);
+  t = luaH_new(L);
+  sethvalue(L, L->top, t);
+  api_incr_top(L);
+  if (narray > 0 || nrec > 0)
+    luaH_resize(L, t, narray, nrec);
+  lua_unlock(L);
+}
+
+
+LUA_API int lua_getmetatable (lua_State *L, int objindex) {
+  const TValue *obj;
+  Table *mt = NULL;
+  int res;
+  lua_lock(L);
+  obj = index2addr(L, objindex);
+  switch (ttypenv(obj)) {
+    case LUA_TTABLE:
+      mt = hvalue(obj)->metatable;
+      break;
+    case LUA_TUSERDATA:
+      mt = uvalue(obj)->metatable;
+      break;
+    default:
+      mt = G(L)->mt[ttypenv(obj)];
+      break;
+  }
+  if (mt == NULL)
+    res = 0;
+  else {
+    sethvalue(L, L->top, mt);
+    api_incr_top(L);
+    res = 1;
+  }
+  lua_unlock(L);
+  return res;
+}
+
+
+LUA_API void lua_getuservalue (lua_State *L, int idx) {
+  StkId o;
+  lua_lock(L);
+  o = index2addr(L, idx);
+  api_check(L, ttisuserdata(o), "userdata expected");
+  if (uvalue(o)->env) {
+    sethvalue(L, L->top, uvalue(o)->env);
+  } else
+    setnilvalue(L->top);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+/*
+** set functions (stack -> Lua)
+*/
+
+
+LUA_API void lua_setglobal (lua_State *L, const char *var) {
+  Table *reg = hvalue(&G(L)->l_registry);
+  const TValue *gt;  /* global table */
+  lua_lock(L);
+  api_checknelems(L, 1);
+  gt = luaH_getint(reg, LUA_RIDX_GLOBALS);
+  setsvalue2s(L, L->top++, luaS_new(L, var));
+  luaV_settable(L, gt, L->top - 1, L->top - 2);
+  L->top -= 2;  /* pop value and key */
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_settable (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  api_checknelems(L, 2);
+  t = index2addr(L, idx);
+  luaV_settable(L, t, L->top - 2, L->top - 1);
+  L->top -= 2;  /* pop index and value */
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_setfield (lua_State *L, int idx, const char *k) {
+  StkId t;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  t = index2addr(L, idx);
+  setsvalue2s(L, L->top++, luaS_new(L, k));
+  luaV_settable(L, t, L->top - 1, L->top - 2);
+  L->top -= 2;  /* pop value and key */
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawset (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  api_checknelems(L, 2);
+  t = index2addr(L, idx);
+  api_check(L, ttistable(t), "table expected");
+  setobj2t(L, luaH_set(L, hvalue(t), L->top-2), L->top-1);
+  invalidateTMcache(hvalue(t));
+  luaC_barrierback(L, gcvalue(t), L->top-1);
+  L->top -= 2;
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawseti (lua_State *L, int idx, int n) {
+  StkId t;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  t = index2addr(L, idx);
+  api_check(L, ttistable(t), "table expected");
+  luaH_setint(L, hvalue(t), n, L->top - 1);
+  luaC_barrierback(L, gcvalue(t), L->top-1);
+  L->top--;
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_rawsetp (lua_State *L, int idx, const void *p) {
+  StkId t;
+  TValue k;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  t = index2addr(L, idx);
+  api_check(L, ttistable(t), "table expected");
+  setpvalue(&k, cast(void *, p));
+  setobj2t(L, luaH_set(L, hvalue(t), &k), L->top - 1);
+  luaC_barrierback(L, gcvalue(t), L->top - 1);
+  L->top--;
+  lua_unlock(L);
+}
+
+
+LUA_API int lua_setmetatable (lua_State *L, int objindex) {
+  TValue *obj;
+  Table *mt;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  obj = index2addr(L, objindex);
+  if (ttisnil(L->top - 1))
+    mt = NULL;
+  else {
+    api_check(L, ttistable(L->top - 1), "table expected");
+    mt = hvalue(L->top - 1);
+  }
+  switch (ttypenv(obj)) {
+    case LUA_TTABLE: {
+      hvalue(obj)->metatable = mt;
+      if (mt) {
+        luaC_objbarrierback(L, gcvalue(obj), mt);
+        luaC_checkfinalizer(L, gcvalue(obj), mt);
+      }
+      break;
+    }
+    case LUA_TUSERDATA: {
+      uvalue(obj)->metatable = mt;
+      if (mt) {
+        luaC_objbarrier(L, rawuvalue(obj), mt);
+        luaC_checkfinalizer(L, gcvalue(obj), mt);
+      }
+      break;
+    }
+    default: {
+      G(L)->mt[ttypenv(obj)] = mt;
+      break;
+    }
+  }
+  L->top--;
+  lua_unlock(L);
+  return 1;
+}
+
+
+LUA_API void lua_setuservalue (lua_State *L, int idx) {
+  StkId o;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  o = index2addr(L, idx);
+  api_check(L, ttisuserdata(o), "userdata expected");
+  if (ttisnil(L->top - 1))
+    uvalue(o)->env = NULL;
+  else {
+    api_check(L, ttistable(L->top - 1), "table expected");
+    uvalue(o)->env = hvalue(L->top - 1);
+    luaC_objbarrier(L, gcvalue(o), hvalue(L->top - 1));
+  }
+  L->top--;
+  lua_unlock(L);
+}
+
+
+/*
+** `load' and `call' functions (run Lua code)
+*/
+
+
+#define checkresults(L,na,nr) \
+     api_check(L, (nr) == LUA_MULTRET || (L->ci->top - L->top >= (nr) - (na)), \
+	"results from function overflow current stack size")
+
+
+LUA_API int lua_getctx (lua_State *L, int *ctx) {
+  if (L->ci->callstatus & CIST_YIELDED) {
+    if (ctx) *ctx = L->ci->u.c.ctx;
+    return L->ci->u.c.status;
+  }
+  else return LUA_OK;
+}
+
+
+LUA_API void lua_callk (lua_State *L, int nargs, int nresults, int ctx,
+                        lua_CFunction k) {
+  StkId func;
+  lua_lock(L);
+  api_check(L, k == NULL || !isLua(L->ci),
+    "cannot use continuations inside hooks");
+  api_checknelems(L, nargs+1);
+  api_check(L, L->status == LUA_OK, "cannot do calls on non-normal thread");
+  checkresults(L, nargs, nresults);
+  func = L->top - (nargs+1);
+  if (k != NULL && L->nny == 0) {  /* need to prepare continuation? */
+    L->ci->u.c.k = k;  /* save continuation */
+    L->ci->u.c.ctx = ctx;  /* save context */
+    luaD_call(L, func, nresults, 1);  /* do the call */
+  }
+  else  /* no continuation or no yieldable */
+    luaD_call(L, func, nresults, 0);  /* just do the call */
+  adjustresults(L, nresults);
+  lua_unlock(L);
+}
+
+
+
+/*
+** Execute a protected call.
+*/
+struct CallS {  /* data to `f_call' */
+  StkId func;
+  int nresults;
+};
+
+
+static void f_call (lua_State *L, void *ud) {
+  struct CallS *c = cast(struct CallS *, ud);
+  luaD_call(L, c->func, c->nresults, 0);
+}
+
+
+
+LUA_API int lua_pcallk (lua_State *L, int nargs, int nresults, int errfunc,
+                        int ctx, lua_CFunction k) {
+  struct CallS c;
+  int status;
+  ptrdiff_t func;
+  lua_lock(L);
+  api_check(L, k == NULL || !isLua(L->ci),
+    "cannot use continuations inside hooks");
+  api_checknelems(L, nargs+1);
+  api_check(L, L->status == LUA_OK, "cannot do calls on non-normal thread");
+  checkresults(L, nargs, nresults);
+  if (errfunc == 0)
+    func = 0;
+  else {
+    StkId o = index2addr(L, errfunc);
+    api_checkstackindex(L, errfunc, o);
+    func = savestack(L, o);
+  }
+  c.func = L->top - (nargs+1);  /* function to be called */
+  if (k == NULL || L->nny > 0) {  /* no continuation or no yieldable? */
+    c.nresults = nresults;  /* do a 'conventional' protected call */
+    status = luaD_pcall(L, f_call, &c, savestack(L, c.func), func);
+  }
+  else {  /* prepare continuation (call is already protected by 'resume') */
+    CallInfo *ci = L->ci;
+    ci->u.c.k = k;  /* save continuation */
+    ci->u.c.ctx = ctx;  /* save context */
+    /* save information for error recovery */
+    ci->extra = savestack(L, c.func);
+    ci->u.c.old_allowhook = L->allowhook;
+    ci->u.c.old_errfunc = L->errfunc;
+    L->errfunc = func;
+    /* mark that function may do error recovery */
+    ci->callstatus |= CIST_YPCALL;
+    luaD_call(L, c.func, nresults, 1);  /* do the call */
+    ci->callstatus &= ~CIST_YPCALL;
+    L->errfunc = ci->u.c.old_errfunc;
+    status = LUA_OK;  /* if it is here, there were no errors */
+  }
+  adjustresults(L, nresults);
+  lua_unlock(L);
+  return status;
+}
+
+
+LUA_API int lua_load (lua_State *L, lua_Reader reader, void *data,
+                      const char *chunkname, const char *mode) {
+  ZIO z;
+  int status;
+  lua_lock(L);
+  if (!chunkname) chunkname = "?";
+  luaZ_init(L, &z, reader, data);
+  status = luaD_protectedparser(L, &z, chunkname, mode);
+  if (status == LUA_OK) {  /* no errors? */
+    LClosure *f = clLvalue(L->top - 1);  /* get newly created function */
+    if (f->nupvalues == 1) {  /* does it have one upvalue? */
+      /* get global table from registry */
+      Table *reg = hvalue(&G(L)->l_registry);
+      const TValue *gt = luaH_getint(reg, LUA_RIDX_GLOBALS);
+      /* set global table as 1st upvalue of 'f' (may be LUA_ENV) */
+      setobj(L, f->upvals[0]->v, gt);
+      luaC_barrier(L, f->upvals[0], gt);
+    }
+  }
+  lua_unlock(L);
+  return status;
+}
+
+
+LUA_API int lua_dump (lua_State *L, lua_Writer writer, void *data) {
+  int status;
+  TValue *o;
+  lua_lock(L);
+  api_checknelems(L, 1);
+  o = L->top - 1;
+  if (isLfunction(o))
+    status = luaU_dump(L, getproto(o), writer, data, 0);
+  else
+    status = 1;
+  lua_unlock(L);
+  return status;
+}
+
+
+LUA_API int lua_status (lua_State *L) {
+  return L->status;
+}
+
+
+/*
+** Garbage-collection function
+*/
+
+LUA_API int lua_gc (lua_State *L, int what, int data) {
+  int res = 0;
+  global_State *g;
+  lua_lock(L);
+  g = G(L);
+  switch (what) {
+    case LUA_GCSTOP: {
+      g->gcrunning = 0;
+      break;
+    }
+    case LUA_GCRESTART: {
+      luaE_setdebt(g, 0);
+      g->gcrunning = 1;
+      break;
+    }
+    case LUA_GCCOLLECT: {
+      luaC_fullgc(L, 0);
+      break;
+    }
+    case LUA_GCCOUNT: {
+      /* GC values are expressed in Kbytes: #bytes/2^10 */
+      res = cast_int(gettotalbytes(g) >> 10);
+      break;
+    }
+    case LUA_GCCOUNTB: {
+      res = cast_int(gettotalbytes(g) & 0x3ff);
+      break;
+    }
+    case LUA_GCSTEP: {
+      if (g->gckind == KGC_GEN) {  /* generational mode? */
+        res = (g->GCestimate == 0);  /* true if it will do major collection */
+        luaC_forcestep(L);  /* do a single step */
+      }
+      else {
+       lu_mem debt = cast(lu_mem, data) * 1024 - GCSTEPSIZE;
+       if (g->gcrunning)
+         debt += g->GCdebt;  /* include current debt */
+       luaE_setdebt(g, debt);
+       luaC_forcestep(L);
+       if (g->gcstate == GCSpause)  /* end of cycle? */
+         res = 1;  /* signal it */
+      }
+      break;
+    }
+    case LUA_GCSETPAUSE: {
+      res = g->gcpause;
+      g->gcpause = data;
+      break;
+    }
+    case LUA_GCSETMAJORINC: {
+      res = g->gcmajorinc;
+      g->gcmajorinc = data;
+      break;
+    }
+    case LUA_GCSETSTEPMUL: {
+      res = g->gcstepmul;
+      g->gcstepmul = data;
+      break;
+    }
+    case LUA_GCISRUNNING: {
+      res = g->gcrunning;
+      break;
+    }
+    case LUA_GCGEN: {  /* change collector to generational mode */
+      luaC_changemode(L, KGC_GEN);
+      break;
+    }
+    case LUA_GCINC: {  /* change collector to incremental mode */
+      luaC_changemode(L, KGC_NORMAL);
+      break;
+    }
+    default: res = -1;  /* invalid option */
+  }
+  lua_unlock(L);
+  return res;
+}
+
+
+
+/*
+** miscellaneous functions
+*/
+
+
+LUA_API int lua_error (lua_State *L) {
+  lua_lock(L);
+  api_checknelems(L, 1);
+  luaG_errormsg(L);
+  /* code unreachable; will unlock when control actually leaves the kernel */
+  return 0;  /* to avoid warnings */
+}
+
+
+LUA_API int lua_next (lua_State *L, int idx) {
+  StkId t;
+  int more;
+  lua_lock(L);
+  t = index2addr(L, idx);
+  api_check(L, ttistable(t), "table expected");
+  more = luaH_next(L, hvalue(t), L->top - 1);
+  if (more) {
+    api_incr_top(L);
+  }
+  else  /* no more elements */
+    L->top -= 1;  /* remove key */
+  lua_unlock(L);
+  return more;
+}
+
+
+LUA_API void lua_concat (lua_State *L, int n) {
+  lua_lock(L);
+  api_checknelems(L, n);
+  if (n >= 2) {
+    luaC_checkGC(L);
+    luaV_concat(L, n);
+  }
+  else if (n == 0) {  /* push empty string */
+    setsvalue2s(L, L->top, luaS_newlstr(L, "", 0));
+    api_incr_top(L);
+  }
+  /* else n == 1; nothing to do */
+  lua_unlock(L);
+}
+
+
+LUA_API void lua_len (lua_State *L, int idx) {
+  StkId t;
+  lua_lock(L);
+  t = index2addr(L, idx);
+  luaV_objlen(L, L->top, t);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+
+LUA_API lua_Alloc lua_getallocf (lua_State *L, void **ud) {
+  lua_Alloc f;
+  lua_lock(L);
+  if (ud) *ud = G(L)->ud;
+  f = G(L)->frealloc;
+  lua_unlock(L);
+  return f;
+}
+
+
+LUA_API void lua_setallocf (lua_State *L, lua_Alloc f, void *ud) {
+  lua_lock(L);
+  G(L)->ud = ud;
+  G(L)->frealloc = f;
+  lua_unlock(L);
+}
+
+
+LUA_API void *lua_newuserdata (lua_State *L, size_t size) {
+  Udata *u;
+  lua_lock(L);
+  luaC_checkGC(L);
+  u = luaS_newudata(L, size, NULL);
+  setuvalue(L, L->top, u);
+  api_incr_top(L);
+  lua_unlock(L);
+  return u + 1;
+}
+
+
+
+static const char *aux_upvalue (StkId fi, int n, TValue **val,
+                                GCObject **owner) {
+  switch (ttype(fi)) {
+    case LUA_TCCL: {  /* C closure */
+      CClosure *f = clCvalue(fi);
+      if (!(1 <= n && n <= f->nupvalues)) return NULL;
+      *val = &f->upvalue[n-1];
+      if (owner) *owner = obj2gco(f);
+      return "";
+    }
+    case LUA_TLCL: {  /* Lua closure */
+      LClosure *f = clLvalue(fi);
+      TString *name;
+      Proto *p = f->p;
+      if (!(1 <= n && n <= p->sizeupvalues)) return NULL;
+      *val = f->upvals[n-1]->v;
+      if (owner) *owner = obj2gco(f->upvals[n - 1]);
+      name = p->upvalues[n-1].name;
+      return (name == NULL) ? "" : getstr(name);
+    }
+    default: return NULL;  /* not a closure */
+  }
+}
+
+
+LUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n) {
+  const char *name;
+  TValue *val = NULL;  /* to avoid warnings */
+  lua_lock(L);
+  name = aux_upvalue(index2addr(L, funcindex), n, &val, NULL);
+  if (name) {
+    setobj2s(L, L->top, val);
+    api_incr_top(L);
+  }
+  lua_unlock(L);
+  return name;
+}
+
+
+LUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n) {
+  const char *name;
+  TValue *val = NULL;  /* to avoid warnings */
+  GCObject *owner = NULL;  /* to avoid warnings */
+  StkId fi;
+  lua_lock(L);
+  fi = index2addr(L, funcindex);
+  api_checknelems(L, 1);
+  name = aux_upvalue(fi, n, &val, &owner);
+  if (name) {
+    L->top--;
+    setobj(L, val, L->top);
+    luaC_barrier(L, owner, L->top);
+  }
+  lua_unlock(L);
+  return name;
+}
+
+
+static UpVal **getupvalref (lua_State *L, int fidx, int n, LClosure **pf) {
+  LClosure *f;
+  StkId fi = index2addr(L, fidx);
+  api_check(L, ttisLclosure(fi), "Lua function expected");
+  f = clLvalue(fi);
+  api_check(L, (1 <= n && n <= f->p->sizeupvalues), "invalid upvalue index");
+  if (pf) *pf = f;
+  return &f->upvals[n - 1];  /* get its upvalue pointer */
+}
+
+
+LUA_API void *lua_upvalueid (lua_State *L, int fidx, int n) {
+  StkId fi = index2addr(L, fidx);
+  switch (ttype(fi)) {
+    case LUA_TLCL: {  /* lua closure */
+      return *getupvalref(L, fidx, n, NULL);
+    }
+    case LUA_TCCL: {  /* C closure */
+      CClosure *f = clCvalue(fi);
+      api_check(L, 1 <= n && n <= f->nupvalues, "invalid upvalue index");
+      return &f->upvalue[n - 1];
+    }
+    default: {
+      api_check(L, 0, "closure expected");
+      return NULL;
+    }
+  }
+}
+
+
+LUA_API void lua_upvaluejoin (lua_State *L, int fidx1, int n1,
+                                            int fidx2, int n2) {
+  LClosure *f1;
+  UpVal **up1 = getupvalref(L, fidx1, n1, &f1);
+  UpVal **up2 = getupvalref(L, fidx2, n2, NULL);
+  *up1 = *up2;
+  luaC_objbarrier(L, f1, *up2);
+}
+
diff -ruNp src.hd/libs/lua/lapi.h src/libs/lua/lapi.h
--- src.hd/libs/lua/lapi.h	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lapi.h	2017-12-29 00:57:40 -0800
@@ -0,0 +1,24 @@
+/*
+** $Id: lapi.h,v 2.7 2009/11/27 15:37:59 roberto Exp $
+** Auxiliary functions from Lua API
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lapi_h
+#define lapi_h
+
+
+#include "llimits.h"
+#include "lstate.h"
+
+#define api_incr_top(L)   {L->top++; api_check(L, L->top <= L->ci->top, \
+				"stack overflow");}
+
+#define adjustresults(L,nres) \
+    { if ((nres) == LUA_MULTRET && L->ci->top < L->top) L->ci->top = L->top; }
+
+#define api_checknelems(L,n)	api_check(L, (n) < (L->top - L->ci->func), \
+				  "not enough elements in the stack")
+
+
+#endif
diff -ruNp src.hd/libs/lua/lauxlib.c src/libs/lua/lauxlib.c
--- src.hd/libs/lua/lauxlib.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lauxlib.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,959 @@
+/*
+** $Id: lauxlib.c,v 1.248 2013/03/21 13:54:57 roberto Exp $
+** Auxiliary functions for building Lua libraries
+** See Copyright Notice in lua.h
+*/
+
+
+#include <errno.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+
+/* This file uses only the official API of Lua.
+** Any function declared here could be written as an application function.
+*/
+
+#define lauxlib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+
+
+/*
+** {======================================================
+** Traceback
+** =======================================================
+*/
+
+
+#define LEVELS1	12	/* size of the first part of the stack */
+#define LEVELS2	10	/* size of the second part of the stack */
+
+
+
+/*
+** search for 'objidx' in table at index -1.
+** return 1 + string at top if find a good name.
+*/
+static int findfield (lua_State *L, int objidx, int level) {
+  if (level == 0 || !lua_istable(L, -1))
+    return 0;  /* not found */
+  lua_pushnil(L);  /* start 'next' loop */
+  while (lua_next(L, -2)) {  /* for each pair in table */
+    if (lua_type(L, -2) == LUA_TSTRING) {  /* ignore non-string keys */
+      if (lua_rawequal(L, objidx, -1)) {  /* found object? */
+        lua_pop(L, 1);  /* remove value (but keep name) */
+        return 1;
+      }
+      else if (findfield(L, objidx, level - 1)) {  /* try recursively */
+        lua_remove(L, -2);  /* remove table (but keep name) */
+        lua_pushliteral(L, ".");
+        lua_insert(L, -2);  /* place '.' between the two names */
+        lua_concat(L, 3);
+        return 1;
+      }
+    }
+    lua_pop(L, 1);  /* remove value */
+  }
+  return 0;  /* not found */
+}
+
+
+static int pushglobalfuncname (lua_State *L, lua_Debug *ar) {
+  int top = lua_gettop(L);
+  lua_getinfo(L, "f", ar);  /* push function */
+  lua_pushglobaltable(L);
+  if (findfield(L, top + 1, 2)) {
+    lua_copy(L, -1, top + 1);  /* move name to proper place */
+    lua_pop(L, 2);  /* remove pushed values */
+    return 1;
+  }
+  else {
+    lua_settop(L, top);  /* remove function and global table */
+    return 0;
+  }
+}
+
+
+static void pushfuncname (lua_State *L, lua_Debug *ar) {
+  if (*ar->namewhat != '\0')  /* is there a name? */
+    lua_pushfstring(L, "function " LUA_QS, ar->name);
+  else if (*ar->what == 'm')  /* main? */
+      lua_pushliteral(L, "main chunk");
+  else if (*ar->what == 'C') {
+    if (pushglobalfuncname(L, ar)) {
+      lua_pushfstring(L, "function " LUA_QS, lua_tostring(L, -1));
+      lua_remove(L, -2);  /* remove name */
+    }
+    else
+      lua_pushliteral(L, "?");
+  }
+  else
+    lua_pushfstring(L, "function <%s:%d>", ar->short_src, ar->linedefined);
+}
+
+
+static int countlevels (lua_State *L) {
+  lua_Debug ar;
+  int li = 1, le = 1;
+  /* find an upper bound */
+  while (lua_getstack(L, le, &ar)) { li = le; le *= 2; }
+  /* do a binary search */
+  while (li < le) {
+    int m = (li + le)/2;
+    if (lua_getstack(L, m, &ar)) li = m + 1;
+    else le = m;
+  }
+  return le - 1;
+}
+
+
+LUALIB_API void luaL_traceback (lua_State *L, lua_State *L1,
+                                const char *msg, int level) {
+  lua_Debug ar;
+  int top = lua_gettop(L);
+  int numlevels = countlevels(L1);
+  int mark = (numlevels > LEVELS1 + LEVELS2) ? LEVELS1 : 0;
+  if (msg) lua_pushfstring(L, "%s\n", msg);
+  lua_pushliteral(L, "stack traceback:");
+  while (lua_getstack(L1, level++, &ar)) {
+    if (level == mark) {  /* too many levels? */
+      lua_pushliteral(L, "\n\t...");  /* add a '...' */
+      level = numlevels - LEVELS2;  /* and skip to last ones */
+    }
+    else {
+      lua_getinfo(L1, "Slnt", &ar);
+      lua_pushfstring(L, "\n\t%s:", ar.short_src);
+      if (ar.currentline > 0)
+        lua_pushfstring(L, "%d:", ar.currentline);
+      lua_pushliteral(L, " in ");
+      pushfuncname(L, &ar);
+      if (ar.istailcall)
+        lua_pushliteral(L, "\n\t(...tail calls...)");
+      lua_concat(L, lua_gettop(L) - top);
+    }
+  }
+  lua_concat(L, lua_gettop(L) - top);
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Error-report functions
+** =======================================================
+*/
+
+LUALIB_API int luaL_argerror (lua_State *L, int narg, const char *extramsg) {
+  lua_Debug ar;
+  if (!lua_getstack(L, 0, &ar))  /* no stack frame? */
+    return luaL_error(L, "bad argument #%d (%s)", narg, extramsg);
+  lua_getinfo(L, "n", &ar);
+  if (strcmp(ar.namewhat, "method") == 0) {
+    narg--;  /* do not count `self' */
+    if (narg == 0)  /* error is in the self argument itself? */
+      return luaL_error(L, "calling " LUA_QS " on bad self (%s)",
+                           ar.name, extramsg);
+  }
+  if (ar.name == NULL)
+    ar.name = (pushglobalfuncname(L, &ar)) ? lua_tostring(L, -1) : "?";
+  return luaL_error(L, "bad argument #%d to " LUA_QS " (%s)",
+                        narg, ar.name, extramsg);
+}
+
+
+static int typeerror (lua_State *L, int narg, const char *tname) {
+  const char *msg = lua_pushfstring(L, "%s expected, got %s",
+                                    tname, luaL_typename(L, narg));
+  return luaL_argerror(L, narg, msg);
+}
+
+
+static void tag_error (lua_State *L, int narg, int tag) {
+  typeerror(L, narg, lua_typename(L, tag));
+}
+
+
+LUALIB_API void luaL_where (lua_State *L, int level) {
+  lua_Debug ar;
+  if (lua_getstack(L, level, &ar)) {  /* check function at level */
+    lua_getinfo(L, "Sl", &ar);  /* get info about it */
+    if (ar.currentline > 0) {  /* is there info? */
+      lua_pushfstring(L, "%s:%d: ", ar.short_src, ar.currentline);
+      return;
+    }
+  }
+  lua_pushliteral(L, "");  /* else, no information available... */
+}
+
+
+LUALIB_API int luaL_error (lua_State *L, const char *fmt, ...) {
+  va_list argp;
+  va_start(argp, fmt);
+  luaL_where(L, 1);
+  lua_pushvfstring(L, fmt, argp);
+  va_end(argp);
+  lua_concat(L, 2);
+  return lua_error(L);
+}
+
+
+LUALIB_API int luaL_fileresult (lua_State *L, int stat, const char *fname) {
+  int en = errno;  /* calls to Lua API may change this value */
+  if (stat) {
+    lua_pushboolean(L, 1);
+    return 1;
+  }
+  else {
+    lua_pushnil(L);
+    if (fname)
+      lua_pushfstring(L, "%s: %s", fname, strerror(en));
+    else
+      lua_pushstring(L, strerror(en));
+    lua_pushinteger(L, en);
+    return 3;
+  }
+}
+
+
+#if !defined(inspectstat)	/* { */
+
+#if defined(LUA_USE_POSIX)
+
+#include <sys/wait.h>
+
+/*
+** use appropriate macros to interpret 'pclose' return status
+*/
+#define inspectstat(stat,what)  \
+   if (WIFEXITED(stat)) { stat = WEXITSTATUS(stat); } \
+   else if (WIFSIGNALED(stat)) { stat = WTERMSIG(stat); what = "signal"; }
+
+#else
+
+#define inspectstat(stat,what)  /* no op */
+
+#endif
+
+#endif				/* } */
+
+
+LUALIB_API int luaL_execresult (lua_State *L, int stat) {
+  const char *what = "exit";  /* type of termination */
+  if (stat == -1)  /* error? */
+    return luaL_fileresult(L, 0, NULL);
+  else {
+    inspectstat(stat, what);  /* interpret result */
+    if (*what == 'e' && stat == 0)  /* successful termination? */
+      lua_pushboolean(L, 1);
+    else
+      lua_pushnil(L);
+    lua_pushstring(L, what);
+    lua_pushinteger(L, stat);
+    return 3;  /* return true/nil,what,code */
+  }
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Userdata's metatable manipulation
+** =======================================================
+*/
+
+LUALIB_API int luaL_newmetatable (lua_State *L, const char *tname) {
+  luaL_getmetatable(L, tname);  /* try to get metatable */
+  if (!lua_isnil(L, -1))  /* name already in use? */
+    return 0;  /* leave previous value on top, but return 0 */
+  lua_pop(L, 1);
+  lua_newtable(L);  /* create metatable */
+  lua_pushvalue(L, -1);
+  lua_setfield(L, LUA_REGISTRYINDEX, tname);  /* registry.name = metatable */
+  return 1;
+}
+
+
+LUALIB_API void luaL_setmetatable (lua_State *L, const char *tname) {
+  luaL_getmetatable(L, tname);
+  lua_setmetatable(L, -2);
+}
+
+
+LUALIB_API void *luaL_testudata (lua_State *L, int ud, const char *tname) {
+  void *p = lua_touserdata(L, ud);
+  if (p != NULL) {  /* value is a userdata? */
+    if (lua_getmetatable(L, ud)) {  /* does it have a metatable? */
+      luaL_getmetatable(L, tname);  /* get correct metatable */
+      if (!lua_rawequal(L, -1, -2))  /* not the same? */
+        p = NULL;  /* value is a userdata with wrong metatable */
+      lua_pop(L, 2);  /* remove both metatables */
+      return p;
+    }
+  }
+  return NULL;  /* value is not a userdata with a metatable */
+}
+
+
+LUALIB_API void *luaL_checkudata (lua_State *L, int ud, const char *tname) {
+  void *p = luaL_testudata(L, ud, tname);
+  if (p == NULL) typeerror(L, ud, tname);
+  return p;
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Argument check functions
+** =======================================================
+*/
+
+LUALIB_API int luaL_checkoption (lua_State *L, int narg, const char *def,
+                                 const char *const lst[]) {
+  const char *name = (def) ? luaL_optstring(L, narg, def) :
+                             luaL_checkstring(L, narg);
+  int i;
+  for (i=0; lst[i]; i++)
+    if (strcmp(lst[i], name) == 0)
+      return i;
+  return luaL_argerror(L, narg,
+                       lua_pushfstring(L, "invalid option " LUA_QS, name));
+}
+
+
+LUALIB_API void luaL_checkstack (lua_State *L, int space, const char *msg) {
+  /* keep some extra space to run error routines, if needed */
+  const int extra = LUA_MINSTACK;
+  if (!lua_checkstack(L, space + extra)) {
+    if (msg)
+      luaL_error(L, "stack overflow (%s)", msg);
+    else
+      luaL_error(L, "stack overflow");
+  }
+}
+
+
+LUALIB_API void luaL_checktype (lua_State *L, int narg, int t) {
+  if (lua_type(L, narg) != t)
+    tag_error(L, narg, t);
+}
+
+
+LUALIB_API void luaL_checkany (lua_State *L, int narg) {
+  if (lua_type(L, narg) == LUA_TNONE)
+    luaL_argerror(L, narg, "value expected");
+}
+
+
+LUALIB_API const char *luaL_checklstring (lua_State *L, int narg, size_t *len) {
+  const char *s = lua_tolstring(L, narg, len);
+  if (!s) tag_error(L, narg, LUA_TSTRING);
+  return s;
+}
+
+
+LUALIB_API const char *luaL_optlstring (lua_State *L, int narg,
+                                        const char *def, size_t *len) {
+  if (lua_isnoneornil(L, narg)) {
+    if (len)
+      *len = (def ? strlen(def) : 0);
+    return def;
+  }
+  else return luaL_checklstring(L, narg, len);
+}
+
+
+LUALIB_API lua_Number luaL_checknumber (lua_State *L, int narg) {
+  int isnum;
+  lua_Number d = lua_tonumberx(L, narg, &isnum);
+  if (!isnum)
+    tag_error(L, narg, LUA_TNUMBER);
+  return d;
+}
+
+
+LUALIB_API lua_Number luaL_optnumber (lua_State *L, int narg, lua_Number def) {
+  return luaL_opt(L, luaL_checknumber, narg, def);
+}
+
+
+LUALIB_API lua_Integer luaL_checkinteger (lua_State *L, int narg) {
+  int isnum;
+  lua_Integer d = lua_tointegerx(L, narg, &isnum);
+  if (!isnum)
+    tag_error(L, narg, LUA_TNUMBER);
+  return d;
+}
+
+
+LUALIB_API lua_Unsigned luaL_checkunsigned (lua_State *L, int narg) {
+  int isnum;
+  lua_Unsigned d = lua_tounsignedx(L, narg, &isnum);
+  if (!isnum)
+    tag_error(L, narg, LUA_TNUMBER);
+  return d;
+}
+
+
+LUALIB_API lua_Integer luaL_optinteger (lua_State *L, int narg,
+                                                      lua_Integer def) {
+  return luaL_opt(L, luaL_checkinteger, narg, def);
+}
+
+
+LUALIB_API lua_Unsigned luaL_optunsigned (lua_State *L, int narg,
+                                                        lua_Unsigned def) {
+  return luaL_opt(L, luaL_checkunsigned, narg, def);
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Generic Buffer manipulation
+** =======================================================
+*/
+
+/*
+** check whether buffer is using a userdata on the stack as a temporary
+** buffer
+*/
+#define buffonstack(B)	((B)->b != (B)->initb)
+
+
+/*
+** returns a pointer to a free area with at least 'sz' bytes
+*/
+LUALIB_API char *luaL_prepbuffsize (luaL_Buffer *B, size_t sz) {
+  lua_State *L = B->L;
+  if (B->size - B->n < sz) {  /* not enough space? */
+    char *newbuff;
+    size_t newsize = B->size * 2;  /* double buffer size */
+    if (newsize - B->n < sz)  /* not big enough? */
+      newsize = B->n + sz;
+    if (newsize < B->n || newsize - B->n < sz)
+      luaL_error(L, "buffer too large");
+    /* create larger buffer */
+    newbuff = (char *)lua_newuserdata(L, newsize * sizeof(char));
+    /* move content to new buffer */
+    memcpy(newbuff, B->b, B->n * sizeof(char));
+    if (buffonstack(B))
+      lua_remove(L, -2);  /* remove old buffer */
+    B->b = newbuff;
+    B->size = newsize;
+  }
+  return &B->b[B->n];
+}
+
+
+LUALIB_API void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l) {
+  char *b = luaL_prepbuffsize(B, l);
+  memcpy(b, s, l * sizeof(char));
+  luaL_addsize(B, l);
+}
+
+
+LUALIB_API void luaL_addstring (luaL_Buffer *B, const char *s) {
+  luaL_addlstring(B, s, strlen(s));
+}
+
+
+LUALIB_API void luaL_pushresult (luaL_Buffer *B) {
+  lua_State *L = B->L;
+  lua_pushlstring(L, B->b, B->n);
+  if (buffonstack(B))
+    lua_remove(L, -2);  /* remove old buffer */
+}
+
+
+LUALIB_API void luaL_pushresultsize (luaL_Buffer *B, size_t sz) {
+  luaL_addsize(B, sz);
+  luaL_pushresult(B);
+}
+
+
+LUALIB_API void luaL_addvalue (luaL_Buffer *B) {
+  lua_State *L = B->L;
+  size_t l;
+  const char *s = lua_tolstring(L, -1, &l);
+  if (buffonstack(B))
+    lua_insert(L, -2);  /* put value below buffer */
+  luaL_addlstring(B, s, l);
+  lua_remove(L, (buffonstack(B)) ? -2 : -1);  /* remove value */
+}
+
+
+LUALIB_API void luaL_buffinit (lua_State *L, luaL_Buffer *B) {
+  B->L = L;
+  B->b = B->initb;
+  B->n = 0;
+  B->size = LUAL_BUFFERSIZE;
+}
+
+
+LUALIB_API char *luaL_buffinitsize (lua_State *L, luaL_Buffer *B, size_t sz) {
+  luaL_buffinit(L, B);
+  return luaL_prepbuffsize(B, sz);
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Reference system
+** =======================================================
+*/
+
+/* index of free-list header */
+#define freelist	0
+
+
+LUALIB_API int luaL_ref (lua_State *L, int t) {
+  int ref;
+  if (lua_isnil(L, -1)) {
+    lua_pop(L, 1);  /* remove from stack */
+    return LUA_REFNIL;  /* `nil' has a unique fixed reference */
+  }
+  t = lua_absindex(L, t);
+  lua_rawgeti(L, t, freelist);  /* get first free element */
+  ref = (int)lua_tointeger(L, -1);  /* ref = t[freelist] */
+  lua_pop(L, 1);  /* remove it from stack */
+  if (ref != 0) {  /* any free element? */
+    lua_rawgeti(L, t, ref);  /* remove it from list */
+    lua_rawseti(L, t, freelist);  /* (t[freelist] = t[ref]) */
+  }
+  else  /* no free elements */
+    ref = (int)lua_rawlen(L, t) + 1;  /* get a new reference */
+  lua_rawseti(L, t, ref);
+  return ref;
+}
+
+
+LUALIB_API void luaL_unref (lua_State *L, int t, int ref) {
+  if (ref >= 0) {
+    t = lua_absindex(L, t);
+    lua_rawgeti(L, t, freelist);
+    lua_rawseti(L, t, ref);  /* t[ref] = t[freelist] */
+    lua_pushinteger(L, ref);
+    lua_rawseti(L, t, freelist);  /* t[freelist] = ref */
+  }
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Load functions
+** =======================================================
+*/
+
+typedef struct LoadF {
+  int n;  /* number of pre-read characters */
+  FILE *f;  /* file being read */
+  char buff[LUAL_BUFFERSIZE];  /* area for reading file */
+} LoadF;
+
+
+static const char *getF (lua_State *L, void *ud, size_t *size) {
+  LoadF *lf = (LoadF *)ud;
+  (void)L;  /* not used */
+  if (lf->n > 0) {  /* are there pre-read characters to be read? */
+    *size = lf->n;  /* return them (chars already in buffer) */
+    lf->n = 0;  /* no more pre-read characters */
+  }
+  else {  /* read a block from file */
+    /* 'fread' can return > 0 *and* set the EOF flag. If next call to
+       'getF' called 'fread', it might still wait for user input.
+       The next check avoids this problem. */
+    if (feof(lf->f)) return NULL;
+    *size = fread(lf->buff, 1, sizeof(lf->buff), lf->f);  /* read block */
+  }
+  return lf->buff;
+}
+
+
+static int errfile (lua_State *L, const char *what, int fnameindex) {
+  const char *serr = strerror(errno);
+  const char *filename = lua_tostring(L, fnameindex) + 1;
+  lua_pushfstring(L, "cannot %s %s: %s", what, filename, serr);
+  lua_remove(L, fnameindex);
+  return LUA_ERRFILE;
+}
+
+
+static int skipBOM (LoadF *lf) {
+  const char *p = "\xEF\xBB\xBF";  /* Utf8 BOM mark */
+  int c;
+  lf->n = 0;
+  do {
+    c = getc(lf->f);
+    if (c == EOF || c != *(const unsigned char *)p++) return c;
+    lf->buff[lf->n++] = c;  /* to be read by the parser */
+  } while (*p != '\0');
+  lf->n = 0;  /* prefix matched; discard it */
+  return getc(lf->f);  /* return next character */
+}
+
+
+/*
+** reads the first character of file 'f' and skips an optional BOM mark
+** in its beginning plus its first line if it starts with '#'. Returns
+** true if it skipped the first line.  In any case, '*cp' has the
+** first "valid" character of the file (after the optional BOM and
+** a first-line comment).
+*/
+static int skipcomment (LoadF *lf, int *cp) {
+  int c = *cp = skipBOM(lf);
+  if (c == '#') {  /* first line is a comment (Unix exec. file)? */
+    do {  /* skip first line */
+      c = getc(lf->f);
+    } while (c != EOF && c != '\n') ;
+    *cp = getc(lf->f);  /* skip end-of-line, if present */
+    return 1;  /* there was a comment */
+  }
+  else return 0;  /* no comment */
+}
+
+
+LUALIB_API int luaL_loadfilex (lua_State *L, const char *filename,
+                                             const char *mode) {
+  LoadF lf;
+  int status, readstatus;
+  int c;
+  int fnameindex = lua_gettop(L) + 1;  /* index of filename on the stack */
+  if (filename == NULL) {
+    lua_pushliteral(L, "=stdin");
+    lf.f = stdin;
+  }
+  else {
+    lua_pushfstring(L, "@%s", filename);
+    lf.f = fopen(filename, "r");
+    if (lf.f == NULL) return errfile(L, "open", fnameindex);
+  }
+  if (skipcomment(&lf, &c))  /* read initial portion */
+    lf.buff[lf.n++] = '\n';  /* add line to correct line numbers */
+  if (c == LUA_SIGNATURE[0] && filename) {  /* binary file? */
+    lf.f = freopen(filename, "rb", lf.f);  /* reopen in binary mode */
+    if (lf.f == NULL) return errfile(L, "reopen", fnameindex);
+    skipcomment(&lf, &c);  /* re-read initial portion */
+  }
+  if (c != EOF)
+    lf.buff[lf.n++] = c;  /* 'c' is the first character of the stream */
+  status = lua_load(L, getF, &lf, lua_tostring(L, -1), mode);
+  readstatus = ferror(lf.f);
+  if (filename) fclose(lf.f);  /* close file (even in case of errors) */
+  if (readstatus) {
+    lua_settop(L, fnameindex);  /* ignore results from `lua_load' */
+    return errfile(L, "read", fnameindex);
+  }
+  lua_remove(L, fnameindex);
+  return status;
+}
+
+
+typedef struct LoadS {
+  const char *s;
+  size_t size;
+} LoadS;
+
+
+static const char *getS (lua_State *L, void *ud, size_t *size) {
+  LoadS *ls = (LoadS *)ud;
+  (void)L;  /* not used */
+  if (ls->size == 0) return NULL;
+  *size = ls->size;
+  ls->size = 0;
+  return ls->s;
+}
+
+
+LUALIB_API int luaL_loadbufferx (lua_State *L, const char *buff, size_t size,
+                                 const char *name, const char *mode) {
+  LoadS ls;
+  ls.s = buff;
+  ls.size = size;
+  return lua_load(L, getS, &ls, name, mode);
+}
+
+
+LUALIB_API int luaL_loadstring (lua_State *L, const char *s) {
+  return luaL_loadbuffer(L, s, strlen(s), s);
+}
+
+/* }====================================================== */
+
+
+
+LUALIB_API int luaL_getmetafield (lua_State *L, int obj, const char *event) {
+  if (!lua_getmetatable(L, obj))  /* no metatable? */
+    return 0;
+  lua_pushstring(L, event);
+  lua_rawget(L, -2);
+  if (lua_isnil(L, -1)) {
+    lua_pop(L, 2);  /* remove metatable and metafield */
+    return 0;
+  }
+  else {
+    lua_remove(L, -2);  /* remove only metatable */
+    return 1;
+  }
+}
+
+
+LUALIB_API int luaL_callmeta (lua_State *L, int obj, const char *event) {
+  obj = lua_absindex(L, obj);
+  if (!luaL_getmetafield(L, obj, event))  /* no metafield? */
+    return 0;
+  lua_pushvalue(L, obj);
+  lua_call(L, 1, 1);
+  return 1;
+}
+
+
+LUALIB_API int luaL_len (lua_State *L, int idx) {
+  int l;
+  int isnum;
+  lua_len(L, idx);
+  l = (int)lua_tointegerx(L, -1, &isnum);
+  if (!isnum)
+    luaL_error(L, "object length is not a number");
+  lua_pop(L, 1);  /* remove object */
+  return l;
+}
+
+
+LUALIB_API const char *luaL_tolstring (lua_State *L, int idx, size_t *len) {
+  if (!luaL_callmeta(L, idx, "__tostring")) {  /* no metafield? */
+    switch (lua_type(L, idx)) {
+      case LUA_TNUMBER:
+      case LUA_TSTRING:
+        lua_pushvalue(L, idx);
+        break;
+      case LUA_TBOOLEAN:
+        lua_pushstring(L, (lua_toboolean(L, idx) ? "true" : "false"));
+        break;
+      case LUA_TNIL:
+        lua_pushliteral(L, "nil");
+        break;
+      default:
+        lua_pushfstring(L, "%s: %p", luaL_typename(L, idx),
+                                            lua_topointer(L, idx));
+        break;
+    }
+  }
+  return lua_tolstring(L, -1, len);
+}
+
+
+/*
+** {======================================================
+** Compatibility with 5.1 module functions
+** =======================================================
+*/
+#if defined(LUA_COMPAT_MODULE)
+
+static const char *luaL_findtable (lua_State *L, int idx,
+                                   const char *fname, int szhint) {
+  const char *e;
+  if (idx) lua_pushvalue(L, idx);
+  do {
+    e = strchr(fname, '.');
+    if (e == NULL) e = fname + strlen(fname);
+    lua_pushlstring(L, fname, e - fname);
+    lua_rawget(L, -2);
+    if (lua_isnil(L, -1)) {  /* no such field? */
+      lua_pop(L, 1);  /* remove this nil */
+      lua_createtable(L, 0, (*e == '.' ? 1 : szhint)); /* new table for field */
+      lua_pushlstring(L, fname, e - fname);
+      lua_pushvalue(L, -2);
+      lua_settable(L, -4);  /* set new table into field */
+    }
+    else if (!lua_istable(L, -1)) {  /* field has a non-table value? */
+      lua_pop(L, 2);  /* remove table and value */
+      return fname;  /* return problematic part of the name */
+    }
+    lua_remove(L, -2);  /* remove previous table */
+    fname = e + 1;
+  } while (*e == '.');
+  return NULL;
+}
+
+
+/*
+** Count number of elements in a luaL_Reg list.
+*/
+static int libsize (const luaL_Reg *l) {
+  int size = 0;
+  for (; l && l->name; l++) size++;
+  return size;
+}
+
+
+/*
+** Find or create a module table with a given name. The function
+** first looks at the _LOADED table and, if that fails, try a
+** global variable with that name. In any case, leaves on the stack
+** the module table.
+*/
+LUALIB_API void luaL_pushmodule (lua_State *L, const char *modname,
+                                 int sizehint) {
+  luaL_findtable(L, LUA_REGISTRYINDEX, "_LOADED", 1);  /* get _LOADED table */
+  lua_getfield(L, -1, modname);  /* get _LOADED[modname] */
+  if (!lua_istable(L, -1)) {  /* not found? */
+    lua_pop(L, 1);  /* remove previous result */
+    /* try global variable (and create one if it does not exist) */
+    lua_pushglobaltable(L);
+    if (luaL_findtable(L, 0, modname, sizehint) != NULL)
+      luaL_error(L, "name conflict for module " LUA_QS, modname);
+    lua_pushvalue(L, -1);
+    lua_setfield(L, -3, modname);  /* _LOADED[modname] = new table */
+  }
+  lua_remove(L, -2);  /* remove _LOADED table */
+}
+
+
+LUALIB_API void luaL_openlib (lua_State *L, const char *libname,
+                               const luaL_Reg *l, int nup) {
+  luaL_checkversion(L);
+  if (libname) {
+    luaL_pushmodule(L, libname, libsize(l));  /* get/create library table */
+    lua_insert(L, -(nup + 1));  /* move library table to below upvalues */
+  }
+  if (l)
+    luaL_setfuncs(L, l, nup);
+  else
+    lua_pop(L, nup);  /* remove upvalues */
+}
+
+#endif
+/* }====================================================== */
+
+/*
+** set functions from list 'l' into table at top - 'nup'; each
+** function gets the 'nup' elements at the top as upvalues.
+** Returns with only the table at the stack.
+*/
+LUALIB_API void luaL_setfuncs (lua_State *L, const luaL_Reg *l, int nup) {
+  luaL_checkversion(L);
+  luaL_checkstack(L, nup, "too many upvalues");
+  for (; l->name != NULL; l++) {  /* fill the table with given functions */
+    int i;
+    for (i = 0; i < nup; i++)  /* copy upvalues to the top */
+      lua_pushvalue(L, -nup);
+    lua_pushcclosure(L, l->func, nup);  /* closure with those upvalues */
+    lua_setfield(L, -(nup + 2), l->name);
+  }
+  lua_pop(L, nup);  /* remove upvalues */
+}
+
+
+/*
+** ensure that stack[idx][fname] has a table and push that table
+** into the stack
+*/
+LUALIB_API int luaL_getsubtable (lua_State *L, int idx, const char *fname) {
+  lua_getfield(L, idx, fname);
+  if (lua_istable(L, -1)) return 1;  /* table already there */
+  else {
+    lua_pop(L, 1);  /* remove previous result */
+    idx = lua_absindex(L, idx);
+    lua_newtable(L);
+    lua_pushvalue(L, -1);  /* copy to be left at top */
+    lua_setfield(L, idx, fname);  /* assign new table to field */
+    return 0;  /* false, because did not find table there */
+  }
+}
+
+
+/*
+** stripped-down 'require'. Calls 'openf' to open a module,
+** registers the result in 'package.loaded' table and, if 'glb'
+** is true, also registers the result in the global table.
+** Leaves resulting module on the top.
+*/
+LUALIB_API void luaL_requiref (lua_State *L, const char *modname,
+                               lua_CFunction openf, int glb) {
+  lua_pushcfunction(L, openf);
+  lua_pushstring(L, modname);  /* argument to open function */
+  lua_call(L, 1, 1);  /* open module */
+  luaL_getsubtable(L, LUA_REGISTRYINDEX, "_LOADED");
+  lua_pushvalue(L, -2);  /* make copy of module (call result) */
+  lua_setfield(L, -2, modname);  /* _LOADED[modname] = module */
+  lua_pop(L, 1);  /* remove _LOADED table */
+  if (glb) {
+    lua_pushvalue(L, -1);  /* copy of 'mod' */
+    lua_setglobal(L, modname);  /* _G[modname] = module */
+  }
+}
+
+
+LUALIB_API const char *luaL_gsub (lua_State *L, const char *s, const char *p,
+                                                               const char *r) {
+  const char *wild;
+  size_t l = strlen(p);
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  while ((wild = strstr(s, p)) != NULL) {
+    luaL_addlstring(&b, s, wild - s);  /* push prefix */
+    luaL_addstring(&b, r);  /* push replacement in place of pattern */
+    s = wild + l;  /* continue after `p' */
+  }
+  luaL_addstring(&b, s);  /* push last suffix */
+  luaL_pushresult(&b);
+  return lua_tostring(L, -1);
+}
+
+
+static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) {
+  (void)ud; (void)osize;  /* not used */
+  if (nsize == 0) {
+    free(ptr);
+    return NULL;
+  }
+  else
+    return realloc(ptr, nsize);
+}
+
+
+static int panic (lua_State *L) {
+  luai_writestringerror("PANIC: unprotected error in call to Lua API (%s)\n",
+                   lua_tostring(L, -1));
+  return 0;  /* return to Lua to abort */
+}
+
+
+LUALIB_API lua_State *luaL_newstate (void) {
+  lua_State *L = lua_newstate(l_alloc, NULL);
+  if (L) lua_atpanic(L, &panic);
+  return L;
+}
+
+
+LUALIB_API void luaL_checkversion_ (lua_State *L, lua_Number ver) {
+  const lua_Number *v = lua_version(L);
+  if (v != lua_version(NULL))
+    luaL_error(L, "multiple Lua VMs detected");
+  else if (*v != ver)
+    luaL_error(L, "version mismatch: app. needs %f, Lua core provides %f",
+                  ver, *v);
+  /* check conversions number -> integer types */
+  lua_pushnumber(L, -(lua_Number)0x1234);
+  if (lua_tointeger(L, -1) != -0x1234 ||
+      lua_tounsigned(L, -1) != (lua_Unsigned)-0x1234)
+    luaL_error(L, "bad conversion number->int;"
+                  " must recompile Lua with proper settings");
+  lua_pop(L, 1);
+}
+
diff -ruNp src.hd/libs/lua/lauxlib.h src/libs/lua/lauxlib.h
--- src.hd/libs/lua/lauxlib.h	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lauxlib.h	2017-12-29 00:57:40 -0800
@@ -0,0 +1,212 @@
+/*
+** $Id: lauxlib.h,v 1.120 2011/11/29 15:55:08 roberto Exp $
+** Auxiliary functions for building Lua libraries
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lauxlib_h
+#define lauxlib_h
+
+
+#include <stddef.h>
+#include <stdio.h>
+
+#include "lua.h"
+
+
+
+/* extra error code for `luaL_load' */
+#define LUA_ERRFILE     (LUA_ERRERR+1)
+
+
+typedef struct luaL_Reg {
+  const char *name;
+  lua_CFunction func;
+} luaL_Reg;
+
+
+LUALIB_API void (luaL_checkversion_) (lua_State *L, lua_Number ver);
+#define luaL_checkversion(L)	luaL_checkversion_(L, LUA_VERSION_NUM)
+
+LUALIB_API int (luaL_getmetafield) (lua_State *L, int obj, const char *e);
+LUALIB_API int (luaL_callmeta) (lua_State *L, int obj, const char *e);
+LUALIB_API const char *(luaL_tolstring) (lua_State *L, int idx, size_t *len);
+LUALIB_API int (luaL_argerror) (lua_State *L, int numarg, const char *extramsg);
+LUALIB_API const char *(luaL_checklstring) (lua_State *L, int numArg,
+                                                          size_t *l);
+LUALIB_API const char *(luaL_optlstring) (lua_State *L, int numArg,
+                                          const char *def, size_t *l);
+LUALIB_API lua_Number (luaL_checknumber) (lua_State *L, int numArg);
+LUALIB_API lua_Number (luaL_optnumber) (lua_State *L, int nArg, lua_Number def);
+
+LUALIB_API lua_Integer (luaL_checkinteger) (lua_State *L, int numArg);
+LUALIB_API lua_Integer (luaL_optinteger) (lua_State *L, int nArg,
+                                          lua_Integer def);
+LUALIB_API lua_Unsigned (luaL_checkunsigned) (lua_State *L, int numArg);
+LUALIB_API lua_Unsigned (luaL_optunsigned) (lua_State *L, int numArg,
+                                            lua_Unsigned def);
+
+LUALIB_API void (luaL_checkstack) (lua_State *L, int sz, const char *msg);
+LUALIB_API void (luaL_checktype) (lua_State *L, int narg, int t);
+LUALIB_API void (luaL_checkany) (lua_State *L, int narg);
+
+LUALIB_API int   (luaL_newmetatable) (lua_State *L, const char *tname);
+LUALIB_API void  (luaL_setmetatable) (lua_State *L, const char *tname);
+LUALIB_API void *(luaL_testudata) (lua_State *L, int ud, const char *tname);
+LUALIB_API void *(luaL_checkudata) (lua_State *L, int ud, const char *tname);
+
+LUALIB_API void (luaL_where) (lua_State *L, int lvl);
+LUALIB_API int (luaL_error) (lua_State *L, const char *fmt, ...);
+
+LUALIB_API int (luaL_checkoption) (lua_State *L, int narg, const char *def,
+                                   const char *const lst[]);
+
+LUALIB_API int (luaL_fileresult) (lua_State *L, int stat, const char *fname);
+LUALIB_API int (luaL_execresult) (lua_State *L, int stat);
+
+/* pre-defined references */
+#define LUA_NOREF       (-2)
+#define LUA_REFNIL      (-1)
+
+LUALIB_API int (luaL_ref) (lua_State *L, int t);
+LUALIB_API void (luaL_unref) (lua_State *L, int t, int ref);
+
+LUALIB_API int (luaL_loadfilex) (lua_State *L, const char *filename,
+                                               const char *mode);
+
+#define luaL_loadfile(L,f)	luaL_loadfilex(L,f,NULL)
+
+LUALIB_API int (luaL_loadbufferx) (lua_State *L, const char *buff, size_t sz,
+                                   const char *name, const char *mode);
+LUALIB_API int (luaL_loadstring) (lua_State *L, const char *s);
+
+LUALIB_API lua_State *(luaL_newstate) (void);
+
+LUALIB_API int (luaL_len) (lua_State *L, int idx);
+
+LUALIB_API const char *(luaL_gsub) (lua_State *L, const char *s, const char *p,
+                                                  const char *r);
+
+LUALIB_API void (luaL_setfuncs) (lua_State *L, const luaL_Reg *l, int nup);
+
+LUALIB_API int (luaL_getsubtable) (lua_State *L, int idx, const char *fname);
+
+LUALIB_API void (luaL_traceback) (lua_State *L, lua_State *L1,
+                                  const char *msg, int level);
+
+LUALIB_API void (luaL_requiref) (lua_State *L, const char *modname,
+                                 lua_CFunction openf, int glb);
+
+/*
+** ===============================================================
+** some useful macros
+** ===============================================================
+*/
+
+
+#define luaL_newlibtable(L,l)	\
+  lua_createtable(L, 0, sizeof(l)/sizeof((l)[0]) - 1)
+
+#define luaL_newlib(L,l)	(luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))
+
+#define luaL_argcheck(L, cond,numarg,extramsg)	\
+		((void)((cond) || luaL_argerror(L, (numarg), (extramsg))))
+#define luaL_checkstring(L,n)	(luaL_checklstring(L, (n), NULL))
+#define luaL_optstring(L,n,d)	(luaL_optlstring(L, (n), (d), NULL))
+#define luaL_checkint(L,n)	((int)luaL_checkinteger(L, (n)))
+#define luaL_optint(L,n,d)	((int)luaL_optinteger(L, (n), (d)))
+#define luaL_checklong(L,n)	((long)luaL_checkinteger(L, (n)))
+#define luaL_optlong(L,n,d)	((long)luaL_optinteger(L, (n), (d)))
+
+#define luaL_typename(L,i)	lua_typename(L, lua_type(L,(i)))
+
+#define luaL_dofile(L, fn) \
+	(luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))
+
+#define luaL_dostring(L, s) \
+	(luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))
+
+#define luaL_getmetatable(L,n)	(lua_getfield(L, LUA_REGISTRYINDEX, (n)))
+
+#define luaL_opt(L,f,n,d)	(lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))
+
+#define luaL_loadbuffer(L,s,sz,n)	luaL_loadbufferx(L,s,sz,n,NULL)
+
+
+/*
+** {======================================================
+** Generic Buffer manipulation
+** =======================================================
+*/
+
+typedef struct luaL_Buffer {
+  char *b;  /* buffer address */
+  size_t size;  /* buffer size */
+  size_t n;  /* number of characters in buffer */
+  lua_State *L;
+  char initb[LUAL_BUFFERSIZE];  /* initial buffer */
+} luaL_Buffer;
+
+
+#define luaL_addchar(B,c) \
+  ((void)((B)->n < (B)->size || luaL_prepbuffsize((B), 1)), \
+   ((B)->b[(B)->n++] = (c)))
+
+#define luaL_addsize(B,s)	((B)->n += (s))
+
+LUALIB_API void (luaL_buffinit) (lua_State *L, luaL_Buffer *B);
+LUALIB_API char *(luaL_prepbuffsize) (luaL_Buffer *B, size_t sz);
+LUALIB_API void (luaL_addlstring) (luaL_Buffer *B, const char *s, size_t l);
+LUALIB_API void (luaL_addstring) (luaL_Buffer *B, const char *s);
+LUALIB_API void (luaL_addvalue) (luaL_Buffer *B);
+LUALIB_API void (luaL_pushresult) (luaL_Buffer *B);
+LUALIB_API void (luaL_pushresultsize) (luaL_Buffer *B, size_t sz);
+LUALIB_API char *(luaL_buffinitsize) (lua_State *L, luaL_Buffer *B, size_t sz);
+
+#define luaL_prepbuffer(B)	luaL_prepbuffsize(B, LUAL_BUFFERSIZE)
+
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** File handles for IO library
+** =======================================================
+*/
+
+/*
+** A file handle is a userdata with metatable 'LUA_FILEHANDLE' and
+** initial structure 'luaL_Stream' (it may contain other fields
+** after that initial structure).
+*/
+
+#define LUA_FILEHANDLE          "FILE*"
+
+
+typedef struct luaL_Stream {
+  FILE *f;  /* stream (NULL for incompletely created streams) */
+  lua_CFunction closef;  /* to close stream (NULL for closed streams) */
+} luaL_Stream;
+
+/* }====================================================== */
+
+
+
+/* compatibility with old module system */
+#if defined(LUA_COMPAT_MODULE)
+
+LUALIB_API void (luaL_pushmodule) (lua_State *L, const char *modname,
+                                   int sizehint);
+LUALIB_API void (luaL_openlib) (lua_State *L, const char *libname,
+                                const luaL_Reg *l, int nup);
+
+#define luaL_register(L,n,l)	(luaL_openlib(L,(n),(l),0))
+
+#endif
+
+
+#endif
+
+
diff -ruNp src.hd/libs/lua/lbaselib.c src/libs/lua/lbaselib.c
--- src.hd/libs/lua/lbaselib.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lbaselib.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,458 @@
+/*
+** $Id: lbaselib.c,v 1.276 2013/02/21 13:44:53 roberto Exp $
+** Basic library
+** See Copyright Notice in lua.h
+*/
+
+
+
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define lbaselib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+static int luaB_print (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  int i;
+  lua_getglobal(L, "tostring");
+  for (i=1; i<=n; i++) {
+    const char *s;
+    size_t l;
+    lua_pushvalue(L, -1);  /* function to be called */
+    lua_pushvalue(L, i);   /* value to print */
+    lua_call(L, 1, 1);
+    s = lua_tolstring(L, -1, &l);  /* get result */
+    if (s == NULL)
+      return luaL_error(L,
+         LUA_QL("tostring") " must return a string to " LUA_QL("print"));
+    if (i>1) luai_writestring("\t", 1);
+    luai_writestring(s, l);
+    lua_pop(L, 1);  /* pop result */
+  }
+  luai_writeline();
+  return 0;
+}
+
+
+#define SPACECHARS	" \f\n\r\t\v"
+
+static int luaB_tonumber (lua_State *L) {
+  if (lua_isnoneornil(L, 2)) {  /* standard conversion */
+    int isnum;
+    lua_Number n = lua_tonumberx(L, 1, &isnum);
+    if (isnum) {
+      lua_pushnumber(L, n);
+      return 1;
+    }  /* else not a number; must be something */
+    luaL_checkany(L, 1);
+  }
+  else {
+    size_t l;
+    const char *s = luaL_checklstring(L, 1, &l);
+    const char *e = s + l;  /* end point for 's' */
+    int base = luaL_checkint(L, 2);
+    int neg = 0;
+    luaL_argcheck(L, 2 <= base && base <= 36, 2, "base out of range");
+    s += strspn(s, SPACECHARS);  /* skip initial spaces */
+    if (*s == '-') { s++; neg = 1; }  /* handle signal */
+    else if (*s == '+') s++;
+    if (isalnum((unsigned char)*s)) {
+      lua_Number n = 0;
+      do {
+        int digit = (isdigit((unsigned char)*s)) ? *s - '0'
+                       : toupper((unsigned char)*s) - 'A' + 10;
+        if (digit >= base) break;  /* invalid numeral; force a fail */
+        n = n * (lua_Number)base + (lua_Number)digit;
+        s++;
+      } while (isalnum((unsigned char)*s));
+      s += strspn(s, SPACECHARS);  /* skip trailing spaces */
+      if (s == e) {  /* no invalid trailing characters? */
+        lua_pushnumber(L, (neg) ? -n : n);
+        return 1;
+      }  /* else not a number */
+    }  /* else not a number */
+  }
+  lua_pushnil(L);  /* not a number */
+  return 1;
+}
+
+
+static int luaB_error (lua_State *L) {
+  int level = luaL_optint(L, 2, 1);
+  lua_settop(L, 1);
+  if (lua_isstring(L, 1) && level > 0) {  /* add extra information? */
+    luaL_where(L, level);
+    lua_pushvalue(L, 1);
+    lua_concat(L, 2);
+  }
+  return lua_error(L);
+}
+
+
+static int luaB_getmetatable (lua_State *L) {
+  luaL_checkany(L, 1);
+  if (!lua_getmetatable(L, 1)) {
+    lua_pushnil(L);
+    return 1;  /* no metatable */
+  }
+  luaL_getmetafield(L, 1, "__metatable");
+  return 1;  /* returns either __metatable field (if present) or metatable */
+}
+
+
+static int luaB_setmetatable (lua_State *L) {
+  int t = lua_type(L, 2);
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2,
+                    "nil or table expected");
+  if (luaL_getmetafield(L, 1, "__metatable"))
+    return luaL_error(L, "cannot change a protected metatable");
+  lua_settop(L, 2);
+  lua_setmetatable(L, 1);
+  return 1;
+}
+
+
+static int luaB_rawequal (lua_State *L) {
+  luaL_checkany(L, 1);
+  luaL_checkany(L, 2);
+  lua_pushboolean(L, lua_rawequal(L, 1, 2));
+  return 1;
+}
+
+
+static int luaB_rawlen (lua_State *L) {
+  int t = lua_type(L, 1);
+  luaL_argcheck(L, t == LUA_TTABLE || t == LUA_TSTRING, 1,
+                   "table or string expected");
+  lua_pushinteger(L, lua_rawlen(L, 1));
+  return 1;
+}
+
+
+static int luaB_rawget (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_checkany(L, 2);
+  lua_settop(L, 2);
+  lua_rawget(L, 1);
+  return 1;
+}
+
+static int luaB_rawset (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  luaL_checkany(L, 2);
+  luaL_checkany(L, 3);
+  lua_settop(L, 3);
+  lua_rawset(L, 1);
+  return 1;
+}
+
+
+static int luaB_collectgarbage (lua_State *L) {
+  static const char *const opts[] = {"stop", "restart", "collect",
+    "count", "step", "setpause", "setstepmul",
+    "setmajorinc", "isrunning", "generational", "incremental", NULL};
+  static const int optsnum[] = {LUA_GCSTOP, LUA_GCRESTART, LUA_GCCOLLECT,
+    LUA_GCCOUNT, LUA_GCSTEP, LUA_GCSETPAUSE, LUA_GCSETSTEPMUL,
+    LUA_GCSETMAJORINC, LUA_GCISRUNNING, LUA_GCGEN, LUA_GCINC};
+  int o = optsnum[luaL_checkoption(L, 1, "collect", opts)];
+  int ex = luaL_optint(L, 2, 0);
+  int res = lua_gc(L, o, ex);
+  switch (o) {
+    case LUA_GCCOUNT: {
+      int b = lua_gc(L, LUA_GCCOUNTB, 0);
+      lua_pushnumber(L, res + ((lua_Number)b/1024));
+      lua_pushinteger(L, b);
+      return 2;
+    }
+    case LUA_GCSTEP: case LUA_GCISRUNNING: {
+      lua_pushboolean(L, res);
+      return 1;
+    }
+    default: {
+      lua_pushinteger(L, res);
+      return 1;
+    }
+  }
+}
+
+
+static int luaB_type (lua_State *L) {
+  luaL_checkany(L, 1);
+  lua_pushstring(L, luaL_typename(L, 1));
+  return 1;
+}
+
+
+static int pairsmeta (lua_State *L, const char *method, int iszero,
+                      lua_CFunction iter) {
+  if (!luaL_getmetafield(L, 1, method)) {  /* no metamethod? */
+    luaL_checktype(L, 1, LUA_TTABLE);  /* argument must be a table */
+    lua_pushcfunction(L, iter);  /* will return generator, */
+    lua_pushvalue(L, 1);  /* state, */
+    if (iszero) lua_pushinteger(L, 0);  /* and initial value */
+    else lua_pushnil(L);
+  }
+  else {
+    lua_pushvalue(L, 1);  /* argument 'self' to metamethod */
+    lua_call(L, 1, 3);  /* get 3 values from metamethod */
+  }
+  return 3;
+}
+
+
+static int luaB_next (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  lua_settop(L, 2);  /* create a 2nd argument if there isn't one */
+  if (lua_next(L, 1))
+    return 2;
+  else {
+    lua_pushnil(L);
+    return 1;
+  }
+}
+
+
+static int luaB_pairs (lua_State *L) {
+  return pairsmeta(L, "__pairs", 0, luaB_next);
+}
+
+
+static int ipairsaux (lua_State *L) {
+  int i = luaL_checkint(L, 2);
+  luaL_checktype(L, 1, LUA_TTABLE);
+  i++;  /* next value */
+  lua_pushinteger(L, i);
+  lua_rawgeti(L, 1, i);
+  return (lua_isnil(L, -1)) ? 1 : 2;
+}
+
+
+static int luaB_ipairs (lua_State *L) {
+  return pairsmeta(L, "__ipairs", 1, ipairsaux);
+}
+
+
+static int load_aux (lua_State *L, int status, int envidx) {
+  if (status == LUA_OK) {
+    if (envidx != 0) {  /* 'env' parameter? */
+      lua_pushvalue(L, envidx);  /* environment for loaded function */
+      if (!lua_setupvalue(L, -2, 1))  /* set it as 1st upvalue */
+        lua_pop(L, 1);  /* remove 'env' if not used by previous call */
+    }
+    return 1;
+  }
+  else {  /* error (message is on top of the stack) */
+    lua_pushnil(L);
+    lua_insert(L, -2);  /* put before error message */
+    return 2;  /* return nil plus error message */
+  }
+}
+
+
+static int luaB_loadfile (lua_State *L) {
+  const char *fname = luaL_optstring(L, 1, NULL);
+  const char *mode = luaL_optstring(L, 2, NULL);
+  int env = (!lua_isnone(L, 3) ? 3 : 0);  /* 'env' index or 0 if no 'env' */
+  int status = luaL_loadfilex(L, fname, mode);
+  return load_aux(L, status, env);
+}
+
+
+/*
+** {======================================================
+** Generic Read function
+** =======================================================
+*/
+
+
+/*
+** reserved slot, above all arguments, to hold a copy of the returned
+** string to avoid it being collected while parsed. 'load' has four
+** optional arguments (chunk, source name, mode, and environment).
+*/
+#define RESERVEDSLOT	5
+
+
+/*
+** Reader for generic `load' function: `lua_load' uses the
+** stack for internal stuff, so the reader cannot change the
+** stack top. Instead, it keeps its resulting string in a
+** reserved slot inside the stack.
+*/
+static const char *generic_reader (lua_State *L, void *ud, size_t *size) {
+  (void)(ud);  /* not used */
+  luaL_checkstack(L, 2, "too many nested functions");
+  lua_pushvalue(L, 1);  /* get function */
+  lua_call(L, 0, 1);  /* call it */
+  if (lua_isnil(L, -1)) {
+    lua_pop(L, 1);  /* pop result */
+    *size = 0;
+    return NULL;
+  }
+  else if (!lua_isstring(L, -1))
+    luaL_error(L, "reader function must return a string");
+  lua_replace(L, RESERVEDSLOT);  /* save string in reserved slot */
+  return lua_tolstring(L, RESERVEDSLOT, size);
+}
+
+
+static int luaB_load (lua_State *L) {
+  int status;
+  size_t l;
+  const char *s = lua_tolstring(L, 1, &l);
+  const char *mode = luaL_optstring(L, 3, "bt");
+  int env = (!lua_isnone(L, 4) ? 4 : 0);  /* 'env' index or 0 if no 'env' */
+  if (s != NULL) {  /* loading a string? */
+    const char *chunkname = luaL_optstring(L, 2, s);
+    status = luaL_loadbufferx(L, s, l, chunkname, mode);
+  }
+  else {  /* loading from a reader function */
+    const char *chunkname = luaL_optstring(L, 2, "=(load)");
+    luaL_checktype(L, 1, LUA_TFUNCTION);
+    lua_settop(L, RESERVEDSLOT);  /* create reserved slot */
+    status = lua_load(L, generic_reader, NULL, chunkname, mode);
+  }
+  return load_aux(L, status, env);
+}
+
+/* }====================================================== */
+
+
+static int dofilecont (lua_State *L) {
+  return lua_gettop(L) - 1;
+}
+
+
+static int luaB_dofile (lua_State *L) {
+  const char *fname = luaL_optstring(L, 1, NULL);
+  lua_settop(L, 1);
+  if (luaL_loadfile(L, fname) != LUA_OK)
+    return lua_error(L);
+  lua_callk(L, 0, LUA_MULTRET, 0, dofilecont);
+  return dofilecont(L);
+}
+
+
+static int luaB_assert (lua_State *L) {
+  if (!lua_toboolean(L, 1))
+    return luaL_error(L, "%s", luaL_optstring(L, 2, "assertion failed!"));
+  return lua_gettop(L);
+}
+
+
+static int luaB_select (lua_State *L) {
+  int n = lua_gettop(L);
+  if (lua_type(L, 1) == LUA_TSTRING && *lua_tostring(L, 1) == '#') {
+    lua_pushinteger(L, n-1);
+    return 1;
+  }
+  else {
+    int i = luaL_checkint(L, 1);
+    if (i < 0) i = n + i;
+    else if (i > n) i = n;
+    luaL_argcheck(L, 1 <= i, 1, "index out of range");
+    return n - i;
+  }
+}
+
+
+static int finishpcall (lua_State *L, int status) {
+  if (!lua_checkstack(L, 1)) {  /* no space for extra boolean? */
+    lua_settop(L, 0);  /* create space for return values */
+    lua_pushboolean(L, 0);
+    lua_pushstring(L, "stack overflow");
+    return 2;  /* return false, msg */
+  }
+  lua_pushboolean(L, status);  /* first result (status) */
+  lua_replace(L, 1);  /* put first result in first slot */
+  return lua_gettop(L);
+}
+
+
+static int pcallcont (lua_State *L) {
+  int status = lua_getctx(L, NULL);
+  return finishpcall(L, (status == LUA_YIELD));
+}
+
+
+static int luaB_pcall (lua_State *L) {
+  int status;
+  luaL_checkany(L, 1);
+  lua_pushnil(L);
+  lua_insert(L, 1);  /* create space for status result */
+  status = lua_pcallk(L, lua_gettop(L) - 2, LUA_MULTRET, 0, 0, pcallcont);
+  return finishpcall(L, (status == LUA_OK));
+}
+
+
+static int luaB_xpcall (lua_State *L) {
+  int status;
+  int n = lua_gettop(L);
+  luaL_argcheck(L, n >= 2, 2, "value expected");
+  lua_pushvalue(L, 1);  /* exchange function... */
+  lua_copy(L, 2, 1);  /* ...and error handler */
+  lua_replace(L, 2);
+  status = lua_pcallk(L, n - 2, LUA_MULTRET, 1, 0, pcallcont);
+  return finishpcall(L, (status == LUA_OK));
+}
+
+
+static int luaB_tostring (lua_State *L) {
+  luaL_checkany(L, 1);
+  luaL_tolstring(L, 1, NULL);
+  return 1;
+}
+
+
+static const luaL_Reg base_funcs[] = {
+  {"assert", luaB_assert},
+  {"collectgarbage", luaB_collectgarbage},
+  {"dofile", luaB_dofile},
+  {"error", luaB_error},
+  {"getmetatable", luaB_getmetatable},
+  {"ipairs", luaB_ipairs},
+  {"loadfile", luaB_loadfile},
+  {"load", luaB_load},
+#if defined(LUA_COMPAT_LOADSTRING)
+  {"loadstring", luaB_load},
+#endif
+  {"next", luaB_next},
+  {"pairs", luaB_pairs},
+  {"pcall", luaB_pcall},
+  {"print", luaB_print},
+  {"rawequal", luaB_rawequal},
+  {"rawlen", luaB_rawlen},
+  {"rawget", luaB_rawget},
+  {"rawset", luaB_rawset},
+  {"select", luaB_select},
+  {"setmetatable", luaB_setmetatable},
+  {"tonumber", luaB_tonumber},
+  {"tostring", luaB_tostring},
+  {"type", luaB_type},
+  {"xpcall", luaB_xpcall},
+  {NULL, NULL}
+};
+
+
+LUAMOD_API int luaopen_base (lua_State *L) {
+  /* set global _G */
+  lua_pushglobaltable(L);
+  lua_pushglobaltable(L);
+  lua_setfield(L, -2, "_G");
+  /* open lib into global table */
+  luaL_setfuncs(L, base_funcs, 0);
+  lua_pushliteral(L, LUA_VERSION);
+  lua_setfield(L, -2, "_VERSION");  /* set global _VERSION */
+  return 1;
+}
+
diff -ruNp src.hd/libs/lua/lbitlib.c src/libs/lua/lbitlib.c
--- src.hd/libs/lua/lbitlib.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lbitlib.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,211 @@
+/*
+** $Id: lbitlib.c,v 1.18 2013/03/19 13:19:12 roberto Exp $
+** Standard library for bitwise operations
+** See Copyright Notice in lua.h
+*/
+
+#define lbitlib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+/* number of bits to consider in a number */
+#if !defined(LUA_NBITS)
+#define LUA_NBITS	32
+#endif
+
+
+#define ALLONES		(~(((~(lua_Unsigned)0) << (LUA_NBITS - 1)) << 1))
+
+/* macro to trim extra bits */
+#define trim(x)		((x) & ALLONES)
+
+
+/* builds a number with 'n' ones (1 <= n <= LUA_NBITS) */
+#define mask(n)		(~((ALLONES << 1) << ((n) - 1)))
+
+
+typedef lua_Unsigned b_uint;
+
+
+
+static b_uint andaux (lua_State *L) {
+  int i, n = lua_gettop(L);
+  b_uint r = ~(b_uint)0;
+  for (i = 1; i <= n; i++)
+    r &= luaL_checkunsigned(L, i);
+  return trim(r);
+}
+
+
+static int b_and (lua_State *L) {
+  b_uint r = andaux(L);
+  lua_pushunsigned(L, r);
+  return 1;
+}
+
+
+static int b_test (lua_State *L) {
+  b_uint r = andaux(L);
+  lua_pushboolean(L, r != 0);
+  return 1;
+}
+
+
+static int b_or (lua_State *L) {
+  int i, n = lua_gettop(L);
+  b_uint r = 0;
+  for (i = 1; i <= n; i++)
+    r |= luaL_checkunsigned(L, i);
+  lua_pushunsigned(L, trim(r));
+  return 1;
+}
+
+
+static int b_xor (lua_State *L) {
+  int i, n = lua_gettop(L);
+  b_uint r = 0;
+  for (i = 1; i <= n; i++)
+    r ^= luaL_checkunsigned(L, i);
+  lua_pushunsigned(L, trim(r));
+  return 1;
+}
+
+
+static int b_not (lua_State *L) {
+  b_uint r = ~luaL_checkunsigned(L, 1);
+  lua_pushunsigned(L, trim(r));
+  return 1;
+}
+
+
+static int b_shift (lua_State *L, b_uint r, int i) {
+  if (i < 0) {  /* shift right? */
+    i = -i;
+    r = trim(r);
+    if (i >= LUA_NBITS) r = 0;
+    else r >>= i;
+  }
+  else {  /* shift left */
+    if (i >= LUA_NBITS) r = 0;
+    else r <<= i;
+    r = trim(r);
+  }
+  lua_pushunsigned(L, r);
+  return 1;
+}
+
+
+static int b_lshift (lua_State *L) {
+  return b_shift(L, luaL_checkunsigned(L, 1), luaL_checkint(L, 2));
+}
+
+
+static int b_rshift (lua_State *L) {
+  return b_shift(L, luaL_checkunsigned(L, 1), -luaL_checkint(L, 2));
+}
+
+
+static int b_arshift (lua_State *L) {
+  b_uint r = luaL_checkunsigned(L, 1);
+  int i = luaL_checkint(L, 2);
+  if (i < 0 || !(r & ((b_uint)1 << (LUA_NBITS - 1))))
+    return b_shift(L, r, -i);
+  else {  /* arithmetic shift for 'negative' number */
+    if (i >= LUA_NBITS) r = ALLONES;
+    else
+      r = trim((r >> i) | ~(~(b_uint)0 >> i));  /* add signal bit */
+    lua_pushunsigned(L, r);
+    return 1;
+  }
+}
+
+
+static int b_rot (lua_State *L, int i) {
+  b_uint r = luaL_checkunsigned(L, 1);
+  i &= (LUA_NBITS - 1);  /* i = i % NBITS */
+  r = trim(r);
+  r = (r << i) | (r >> (LUA_NBITS - i));
+  lua_pushunsigned(L, trim(r));
+  return 1;
+}
+
+
+static int b_lrot (lua_State *L) {
+  return b_rot(L, luaL_checkint(L, 2));
+}
+
+
+static int b_rrot (lua_State *L) {
+  return b_rot(L, -luaL_checkint(L, 2));
+}
+
+
+/*
+** get field and width arguments for field-manipulation functions,
+** checking whether they are valid.
+** ('luaL_error' called without 'return' to avoid later warnings about
+** 'width' being used uninitialized.)
+*/
+static int fieldargs (lua_State *L, int farg, int *width) {
+  int f = luaL_checkint(L, farg);
+  int w = luaL_optint(L, farg + 1, 1);
+  luaL_argcheck(L, 0 <= f, farg, "field cannot be negative");
+  luaL_argcheck(L, 0 < w, farg + 1, "width must be positive");
+  if (f + w > LUA_NBITS)
+    luaL_error(L, "trying to access non-existent bits");
+  *width = w;
+  return f;
+}
+
+
+static int b_extract (lua_State *L) {
+  int w;
+  b_uint r = luaL_checkunsigned(L, 1);
+  int f = fieldargs(L, 2, &w);
+  r = (r >> f) & mask(w);
+  lua_pushunsigned(L, r);
+  return 1;
+}
+
+
+static int b_replace (lua_State *L) {
+  int w;
+  b_uint r = luaL_checkunsigned(L, 1);
+  b_uint v = luaL_checkunsigned(L, 2);
+  int f = fieldargs(L, 3, &w);
+  int m = mask(w);
+  v &= m;  /* erase bits outside given width */
+  r = (r & ~(m << f)) | (v << f);
+  lua_pushunsigned(L, r);
+  return 1;
+}
+
+
+static const luaL_Reg bitlib[] = {
+  {"arshift", b_arshift},
+  {"band", b_and},
+  {"bnot", b_not},
+  {"bor", b_or},
+  {"bxor", b_xor},
+  {"btest", b_test},
+  {"extract", b_extract},
+  {"lrotate", b_lrot},
+  {"lshift", b_lshift},
+  {"replace", b_replace},
+  {"rrotate", b_rrot},
+  {"rshift", b_rshift},
+  {NULL, NULL}
+};
+
+
+
+LUAMOD_API int luaopen_bit32 (lua_State *L) {
+  luaL_newlib(L, bitlib);
+  return 1;
+}
+
diff -ruNp src.hd/libs/lua/lcode.c src/libs/lua/lcode.c
--- src.hd/libs/lua/lcode.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lcode.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,881 @@
+/*
+** $Id: lcode.c,v 2.62 2012/08/16 17:34:28 roberto Exp $
+** Code generator for Lua
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdlib.h>
+
+#define lcode_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lcode.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lgc.h"
+#include "llex.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lparser.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "lvm.h"
+
+
+#define hasjumps(e)	((e)->t != (e)->f)
+
+
+static int isnumeral(expdesc *e) {
+  return (e->k == VKNUM && e->t == NO_JUMP && e->f == NO_JUMP);
+}
+
+
+void luaK_nil (FuncState *fs, int from, int n) {
+  Instruction *previous;
+  int l = from + n - 1;  /* last register to set nil */
+  if (fs->pc > fs->lasttarget) {  /* no jumps to current position? */
+    previous = &fs->f->code[fs->pc-1];
+    if (GET_OPCODE(*previous) == OP_LOADNIL) {
+      int pfrom = GETARG_A(*previous);
+      int pl = pfrom + GETARG_B(*previous);
+      if ((pfrom <= from && from <= pl + 1) ||
+          (from <= pfrom && pfrom <= l + 1)) {  /* can connect both? */
+        if (pfrom < from) from = pfrom;  /* from = min(from, pfrom) */
+        if (pl > l) l = pl;  /* l = max(l, pl) */
+        SETARG_A(*previous, from);
+        SETARG_B(*previous, l - from);
+        return;
+      }
+    }  /* else go through */
+  }
+  luaK_codeABC(fs, OP_LOADNIL, from, n - 1, 0);  /* else no optimization */
+}
+
+
+int luaK_jump (FuncState *fs) {
+  int jpc = fs->jpc;  /* save list of jumps to here */
+  int j;
+  fs->jpc = NO_JUMP;
+  j = luaK_codeAsBx(fs, OP_JMP, 0, NO_JUMP);
+  luaK_concat(fs, &j, jpc);  /* keep them on hold */
+  return j;
+}
+
+
+void luaK_ret (FuncState *fs, int first, int nret) {
+  luaK_codeABC(fs, OP_RETURN, first, nret+1, 0);
+}
+
+
+static int condjump (FuncState *fs, OpCode op, int A, int B, int C) {
+  luaK_codeABC(fs, op, A, B, C);
+  return luaK_jump(fs);
+}
+
+
+static void fixjump (FuncState *fs, int pc, int dest) {
+  Instruction *jmp = &fs->f->code[pc];
+  int offset = dest-(pc+1);
+  lua_assert(dest != NO_JUMP);
+  if (abs(offset) > MAXARG_sBx)
+    luaX_syntaxerror(fs->ls, "control structure too long");
+  SETARG_sBx(*jmp, offset);
+}
+
+
+/*
+** returns current `pc' and marks it as a jump target (to avoid wrong
+** optimizations with consecutive instructions not in the same basic block).
+*/
+int luaK_getlabel (FuncState *fs) {
+  fs->lasttarget = fs->pc;
+  return fs->pc;
+}
+
+
+static int getjump (FuncState *fs, int pc) {
+  int offset = GETARG_sBx(fs->f->code[pc]);
+  if (offset == NO_JUMP)  /* point to itself represents end of list */
+    return NO_JUMP;  /* end of list */
+  else
+    return (pc+1)+offset;  /* turn offset into absolute position */
+}
+
+
+static Instruction *getjumpcontrol (FuncState *fs, int pc) {
+  Instruction *pi = &fs->f->code[pc];
+  if (pc >= 1 && testTMode(GET_OPCODE(*(pi-1))))
+    return pi-1;
+  else
+    return pi;
+}
+
+
+/*
+** check whether list has any jump that do not produce a value
+** (or produce an inverted value)
+*/
+static int need_value (FuncState *fs, int list) {
+  for (; list != NO_JUMP; list = getjump(fs, list)) {
+    Instruction i = *getjumpcontrol(fs, list);
+    if (GET_OPCODE(i) != OP_TESTSET) return 1;
+  }
+  return 0;  /* not found */
+}
+
+
+static int patchtestreg (FuncState *fs, int node, int reg) {
+  Instruction *i = getjumpcontrol(fs, node);
+  if (GET_OPCODE(*i) != OP_TESTSET)
+    return 0;  /* cannot patch other instructions */
+  if (reg != NO_REG && reg != GETARG_B(*i))
+    SETARG_A(*i, reg);
+  else  /* no register to put value or register already has the value */
+    *i = CREATE_ABC(OP_TEST, GETARG_B(*i), 0, GETARG_C(*i));
+
+  return 1;
+}
+
+
+static void removevalues (FuncState *fs, int list) {
+  for (; list != NO_JUMP; list = getjump(fs, list))
+      patchtestreg(fs, list, NO_REG);
+}
+
+
+static void patchlistaux (FuncState *fs, int list, int vtarget, int reg,
+                          int dtarget) {
+  while (list != NO_JUMP) {
+    int next = getjump(fs, list);
+    if (patchtestreg(fs, list, reg))
+      fixjump(fs, list, vtarget);
+    else
+      fixjump(fs, list, dtarget);  /* jump to default target */
+    list = next;
+  }
+}
+
+
+static void dischargejpc (FuncState *fs) {
+  patchlistaux(fs, fs->jpc, fs->pc, NO_REG, fs->pc);
+  fs->jpc = NO_JUMP;
+}
+
+
+void luaK_patchlist (FuncState *fs, int list, int target) {
+  if (target == fs->pc)
+    luaK_patchtohere(fs, list);
+  else {
+    lua_assert(target < fs->pc);
+    patchlistaux(fs, list, target, NO_REG, target);
+  }
+}
+
+
+LUAI_FUNC void luaK_patchclose (FuncState *fs, int list, int level) {
+  level++;  /* argument is +1 to reserve 0 as non-op */
+  while (list != NO_JUMP) {
+    int next = getjump(fs, list);
+    lua_assert(GET_OPCODE(fs->f->code[list]) == OP_JMP &&
+                (GETARG_A(fs->f->code[list]) == 0 ||
+                 GETARG_A(fs->f->code[list]) >= level));
+    SETARG_A(fs->f->code[list], level);
+    list = next;
+  }
+}
+
+
+void luaK_patchtohere (FuncState *fs, int list) {
+  luaK_getlabel(fs);
+  luaK_concat(fs, &fs->jpc, list);
+}
+
+
+void luaK_concat (FuncState *fs, int *l1, int l2) {
+  if (l2 == NO_JUMP) return;
+  else if (*l1 == NO_JUMP)
+    *l1 = l2;
+  else {
+    int list = *l1;
+    int next;
+    while ((next = getjump(fs, list)) != NO_JUMP)  /* find last element */
+      list = next;
+    fixjump(fs, list, l2);
+  }
+}
+
+
+static int luaK_code (FuncState *fs, Instruction i) {
+  Proto *f = fs->f;
+  dischargejpc(fs);  /* `pc' will change */
+  /* put new instruction in code array */
+  luaM_growvector(fs->ls->L, f->code, fs->pc, f->sizecode, Instruction,
+                  MAX_INT, "opcodes");
+  f->code[fs->pc] = i;
+  /* save corresponding line information */
+  luaM_growvector(fs->ls->L, f->lineinfo, fs->pc, f->sizelineinfo, int,
+                  MAX_INT, "opcodes");
+  f->lineinfo[fs->pc] = fs->ls->lastline;
+  return fs->pc++;
+}
+
+
+int luaK_codeABC (FuncState *fs, OpCode o, int a, int b, int c) {
+  lua_assert(getOpMode(o) == iABC);
+  lua_assert(getBMode(o) != OpArgN || b == 0);
+  lua_assert(getCMode(o) != OpArgN || c == 0);
+  lua_assert(a <= MAXARG_A && b <= MAXARG_B && c <= MAXARG_C);
+  return luaK_code(fs, CREATE_ABC(o, a, b, c));
+}
+
+
+int luaK_codeABx (FuncState *fs, OpCode o, int a, unsigned int bc) {
+  lua_assert(getOpMode(o) == iABx || getOpMode(o) == iAsBx);
+  lua_assert(getCMode(o) == OpArgN);
+  lua_assert(a <= MAXARG_A && bc <= MAXARG_Bx);
+  return luaK_code(fs, CREATE_ABx(o, a, bc));
+}
+
+
+static int codeextraarg (FuncState *fs, int a) {
+  lua_assert(a <= MAXARG_Ax);
+  return luaK_code(fs, CREATE_Ax(OP_EXTRAARG, a));
+}
+
+
+int luaK_codek (FuncState *fs, int reg, int k) {
+  if (k <= MAXARG_Bx)
+    return luaK_codeABx(fs, OP_LOADK, reg, k);
+  else {
+    int p = luaK_codeABx(fs, OP_LOADKX, reg, 0);
+    codeextraarg(fs, k);
+    return p;
+  }
+}
+
+
+void luaK_checkstack (FuncState *fs, int n) {
+  int newstack = fs->freereg + n;
+  if (newstack > fs->f->maxstacksize) {
+    if (newstack >= MAXSTACK)
+      luaX_syntaxerror(fs->ls, "function or expression too complex");
+    fs->f->maxstacksize = cast_byte(newstack);
+  }
+}
+
+
+void luaK_reserveregs (FuncState *fs, int n) {
+  luaK_checkstack(fs, n);
+  fs->freereg += n;
+}
+
+
+static void freereg (FuncState *fs, int reg) {
+  if (!ISK(reg) && reg >= fs->nactvar) {
+    fs->freereg--;
+    lua_assert(reg == fs->freereg);
+  }
+}
+
+
+static void freeexp (FuncState *fs, expdesc *e) {
+  if (e->k == VNONRELOC)
+    freereg(fs, e->u.info);
+}
+
+
+static int addk (FuncState *fs, TValue *key, TValue *v) {
+  lua_State *L = fs->ls->L;
+  TValue *idx = luaH_set(L, fs->h, key);
+  Proto *f = fs->f;
+  int k, oldsize;
+  if (ttisnumber(idx)) {
+    lua_Number n = nvalue(idx);
+    lua_number2int(k, n);
+    if (luaV_rawequalobj(&f->k[k], v))
+      return k;
+    /* else may be a collision (e.g., between 0.0 and "\0\0\0\0\0\0\0\0");
+       go through and create a new entry for this value */
+  }
+  /* constant not found; create a new entry */
+  oldsize = f->sizek;
+  k = fs->nk;
+  /* numerical value does not need GC barrier;
+     table has no metatable, so it does not need to invalidate cache */
+  setnvalue(idx, cast_num(k));
+  luaM_growvector(L, f->k, k, f->sizek, TValue, MAXARG_Ax, "constants");
+  while (oldsize < f->sizek) setnilvalue(&f->k[oldsize++]);
+  setobj(L, &f->k[k], v);
+  fs->nk++;
+  luaC_barrier(L, f, v);
+  return k;
+}
+
+
+int luaK_stringK (FuncState *fs, TString *s) {
+  TValue o;
+  setsvalue(fs->ls->L, &o, s);
+  return addk(fs, &o, &o);
+}
+
+
+int luaK_numberK (FuncState *fs, lua_Number r) {
+  int n;
+  lua_State *L = fs->ls->L;
+  TValue o;
+  setnvalue(&o, r);
+  if (r == 0 || luai_numisnan(NULL, r)) {  /* handle -0 and NaN */
+    /* use raw representation as key to avoid numeric problems */
+    setsvalue(L, L->top++, luaS_newlstr(L, (char *)&r, sizeof(r)));
+    n = addk(fs, L->top - 1, &o);
+    L->top--;
+  }
+  else
+    n = addk(fs, &o, &o);  /* regular case */
+  return n;
+}
+
+
+static int boolK (FuncState *fs, int b) {
+  TValue o;
+  setbvalue(&o, b);
+  return addk(fs, &o, &o);
+}
+
+
+static int nilK (FuncState *fs) {
+  TValue k, v;
+  setnilvalue(&v);
+  /* cannot use nil as key; instead use table itself to represent nil */
+  sethvalue(fs->ls->L, &k, fs->h);
+  return addk(fs, &k, &v);
+}
+
+
+void luaK_setreturns (FuncState *fs, expdesc *e, int nresults) {
+  if (e->k == VCALL) {  /* expression is an open function call? */
+    SETARG_C(getcode(fs, e), nresults+1);
+  }
+  else if (e->k == VVARARG) {
+    SETARG_B(getcode(fs, e), nresults+1);
+    SETARG_A(getcode(fs, e), fs->freereg);
+    luaK_reserveregs(fs, 1);
+  }
+}
+
+
+void luaK_setoneret (FuncState *fs, expdesc *e) {
+  if (e->k == VCALL) {  /* expression is an open function call? */
+    e->k = VNONRELOC;
+    e->u.info = GETARG_A(getcode(fs, e));
+  }
+  else if (e->k == VVARARG) {
+    SETARG_B(getcode(fs, e), 2);
+    e->k = VRELOCABLE;  /* can relocate its simple result */
+  }
+}
+
+
+void luaK_dischargevars (FuncState *fs, expdesc *e) {
+  switch (e->k) {
+    case VLOCAL: {
+      e->k = VNONRELOC;
+      break;
+    }
+    case VUPVAL: {
+      e->u.info = luaK_codeABC(fs, OP_GETUPVAL, 0, e->u.info, 0);
+      e->k = VRELOCABLE;
+      break;
+    }
+    case VINDEXED: {
+      OpCode op = OP_GETTABUP;  /* assume 't' is in an upvalue */
+      freereg(fs, e->u.ind.idx);
+      if (e->u.ind.vt == VLOCAL) {  /* 't' is in a register? */
+        freereg(fs, e->u.ind.t);
+        op = OP_GETTABLE;
+      }
+      e->u.info = luaK_codeABC(fs, op, 0, e->u.ind.t, e->u.ind.idx);
+      e->k = VRELOCABLE;
+      break;
+    }
+    case VVARARG:
+    case VCALL: {
+      luaK_setoneret(fs, e);
+      break;
+    }
+    default: break;  /* there is one value available (somewhere) */
+  }
+}
+
+
+static int code_label (FuncState *fs, int A, int b, int jump) {
+  luaK_getlabel(fs);  /* those instructions may be jump targets */
+  return luaK_codeABC(fs, OP_LOADBOOL, A, b, jump);
+}
+
+
+static void discharge2reg (FuncState *fs, expdesc *e, int reg) {
+  luaK_dischargevars(fs, e);
+  switch (e->k) {
+    case VNIL: {
+      luaK_nil(fs, reg, 1);
+      break;
+    }
+    case VFALSE: case VTRUE: {
+      luaK_codeABC(fs, OP_LOADBOOL, reg, e->k == VTRUE, 0);
+      break;
+    }
+    case VK: {
+      luaK_codek(fs, reg, e->u.info);
+      break;
+    }
+    case VKNUM: {
+      luaK_codek(fs, reg, luaK_numberK(fs, e->u.nval));
+      break;
+    }
+    case VRELOCABLE: {
+      Instruction *pc = &getcode(fs, e);
+      SETARG_A(*pc, reg);
+      break;
+    }
+    case VNONRELOC: {
+      if (reg != e->u.info)
+        luaK_codeABC(fs, OP_MOVE, reg, e->u.info, 0);
+      break;
+    }
+    default: {
+      lua_assert(e->k == VVOID || e->k == VJMP);
+      return;  /* nothing to do... */
+    }
+  }
+  e->u.info = reg;
+  e->k = VNONRELOC;
+}
+
+
+static void discharge2anyreg (FuncState *fs, expdesc *e) {
+  if (e->k != VNONRELOC) {
+    luaK_reserveregs(fs, 1);
+    discharge2reg(fs, e, fs->freereg-1);
+  }
+}
+
+
+static void exp2reg (FuncState *fs, expdesc *e, int reg) {
+  discharge2reg(fs, e, reg);
+  if (e->k == VJMP)
+    luaK_concat(fs, &e->t, e->u.info);  /* put this jump in `t' list */
+  if (hasjumps(e)) {
+    int final;  /* position after whole expression */
+    int p_f = NO_JUMP;  /* position of an eventual LOAD false */
+    int p_t = NO_JUMP;  /* position of an eventual LOAD true */
+    if (need_value(fs, e->t) || need_value(fs, e->f)) {
+      int fj = (e->k == VJMP) ? NO_JUMP : luaK_jump(fs);
+      p_f = code_label(fs, reg, 0, 1);
+      p_t = code_label(fs, reg, 1, 0);
+      luaK_patchtohere(fs, fj);
+    }
+    final = luaK_getlabel(fs);
+    patchlistaux(fs, e->f, final, reg, p_f);
+    patchlistaux(fs, e->t, final, reg, p_t);
+  }
+  e->f = e->t = NO_JUMP;
+  e->u.info = reg;
+  e->k = VNONRELOC;
+}
+
+
+void luaK_exp2nextreg (FuncState *fs, expdesc *e) {
+  luaK_dischargevars(fs, e);
+  freeexp(fs, e);
+  luaK_reserveregs(fs, 1);
+  exp2reg(fs, e, fs->freereg - 1);
+}
+
+
+int luaK_exp2anyreg (FuncState *fs, expdesc *e) {
+  luaK_dischargevars(fs, e);
+  if (e->k == VNONRELOC) {
+    if (!hasjumps(e)) return e->u.info;  /* exp is already in a register */
+    if (e->u.info >= fs->nactvar) {  /* reg. is not a local? */
+      exp2reg(fs, e, e->u.info);  /* put value on it */
+      return e->u.info;
+    }
+  }
+  luaK_exp2nextreg(fs, e);  /* default */
+  return e->u.info;
+}
+
+
+void luaK_exp2anyregup (FuncState *fs, expdesc *e) {
+  if (e->k != VUPVAL || hasjumps(e))
+    luaK_exp2anyreg(fs, e);
+}
+
+
+void luaK_exp2val (FuncState *fs, expdesc *e) {
+  if (hasjumps(e))
+    luaK_exp2anyreg(fs, e);
+  else
+    luaK_dischargevars(fs, e);
+}
+
+
+int luaK_exp2RK (FuncState *fs, expdesc *e) {
+  luaK_exp2val(fs, e);
+  switch (e->k) {
+    case VTRUE:
+    case VFALSE:
+    case VNIL: {
+      if (fs->nk <= MAXINDEXRK) {  /* constant fits in RK operand? */
+        e->u.info = (e->k == VNIL) ? nilK(fs) : boolK(fs, (e->k == VTRUE));
+        e->k = VK;
+        return RKASK(e->u.info);
+      }
+      else break;
+    }
+    case VKNUM: {
+      e->u.info = luaK_numberK(fs, e->u.nval);
+      e->k = VK;
+      /* go through */
+    }
+    case VK: {
+      if (e->u.info <= MAXINDEXRK)  /* constant fits in argC? */
+        return RKASK(e->u.info);
+      else break;
+    }
+    default: break;
+  }
+  /* not a constant in the right range: put it in a register */
+  return luaK_exp2anyreg(fs, e);
+}
+
+
+void luaK_storevar (FuncState *fs, expdesc *var, expdesc *ex) {
+  switch (var->k) {
+    case VLOCAL: {
+      freeexp(fs, ex);
+      exp2reg(fs, ex, var->u.info);
+      return;
+    }
+    case VUPVAL: {
+      int e = luaK_exp2anyreg(fs, ex);
+      luaK_codeABC(fs, OP_SETUPVAL, e, var->u.info, 0);
+      break;
+    }
+    case VINDEXED: {
+      OpCode op = (var->u.ind.vt == VLOCAL) ? OP_SETTABLE : OP_SETTABUP;
+      int e = luaK_exp2RK(fs, ex);
+      luaK_codeABC(fs, op, var->u.ind.t, var->u.ind.idx, e);
+      break;
+    }
+    default: {
+      lua_assert(0);  /* invalid var kind to store */
+      break;
+    }
+  }
+  freeexp(fs, ex);
+}
+
+
+void luaK_self (FuncState *fs, expdesc *e, expdesc *key) {
+  int ereg;
+  luaK_exp2anyreg(fs, e);
+  ereg = e->u.info;  /* register where 'e' was placed */
+  freeexp(fs, e);
+  e->u.info = fs->freereg;  /* base register for op_self */
+  e->k = VNONRELOC;
+  luaK_reserveregs(fs, 2);  /* function and 'self' produced by op_self */
+  luaK_codeABC(fs, OP_SELF, e->u.info, ereg, luaK_exp2RK(fs, key));
+  freeexp(fs, key);
+}
+
+
+static void invertjump (FuncState *fs, expdesc *e) {
+  Instruction *pc = getjumpcontrol(fs, e->u.info);
+  lua_assert(testTMode(GET_OPCODE(*pc)) && GET_OPCODE(*pc) != OP_TESTSET &&
+                                           GET_OPCODE(*pc) != OP_TEST);
+  SETARG_A(*pc, !(GETARG_A(*pc)));
+}
+
+
+static int jumponcond (FuncState *fs, expdesc *e, int cond) {
+  if (e->k == VRELOCABLE) {
+    Instruction ie = getcode(fs, e);
+    if (GET_OPCODE(ie) == OP_NOT) {
+      fs->pc--;  /* remove previous OP_NOT */
+      return condjump(fs, OP_TEST, GETARG_B(ie), 0, !cond);
+    }
+    /* else go through */
+  }
+  discharge2anyreg(fs, e);
+  freeexp(fs, e);
+  return condjump(fs, OP_TESTSET, NO_REG, e->u.info, cond);
+}
+
+
+void luaK_goiftrue (FuncState *fs, expdesc *e) {
+  int pc;  /* pc of last jump */
+  luaK_dischargevars(fs, e);
+  switch (e->k) {
+    case VJMP: {
+      invertjump(fs, e);
+      pc = e->u.info;
+      break;
+    }
+    case VK: case VKNUM: case VTRUE: {
+      pc = NO_JUMP;  /* always true; do nothing */
+      break;
+    }
+    default: {
+      pc = jumponcond(fs, e, 0);
+      break;
+    }
+  }
+  luaK_concat(fs, &e->f, pc);  /* insert last jump in `f' list */
+  luaK_patchtohere(fs, e->t);
+  e->t = NO_JUMP;
+}
+
+
+void luaK_goiffalse (FuncState *fs, expdesc *e) {
+  int pc;  /* pc of last jump */
+  luaK_dischargevars(fs, e);
+  switch (e->k) {
+    case VJMP: {
+      pc = e->u.info;
+      break;
+    }
+    case VNIL: case VFALSE: {
+      pc = NO_JUMP;  /* always false; do nothing */
+      break;
+    }
+    default: {
+      pc = jumponcond(fs, e, 1);
+      break;
+    }
+  }
+  luaK_concat(fs, &e->t, pc);  /* insert last jump in `t' list */
+  luaK_patchtohere(fs, e->f);
+  e->f = NO_JUMP;
+}
+
+
+static void codenot (FuncState *fs, expdesc *e) {
+  luaK_dischargevars(fs, e);
+  switch (e->k) {
+    case VNIL: case VFALSE: {
+      e->k = VTRUE;
+      break;
+    }
+    case VK: case VKNUM: case VTRUE: {
+      e->k = VFALSE;
+      break;
+    }
+    case VJMP: {
+      invertjump(fs, e);
+      break;
+    }
+    case VRELOCABLE:
+    case VNONRELOC: {
+      discharge2anyreg(fs, e);
+      freeexp(fs, e);
+      e->u.info = luaK_codeABC(fs, OP_NOT, 0, e->u.info, 0);
+      e->k = VRELOCABLE;
+      break;
+    }
+    default: {
+      lua_assert(0);  /* cannot happen */
+      break;
+    }
+  }
+  /* interchange true and false lists */
+  { int temp = e->f; e->f = e->t; e->t = temp; }
+  removevalues(fs, e->f);
+  removevalues(fs, e->t);
+}
+
+
+void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k) {
+  lua_assert(!hasjumps(t));
+  t->u.ind.t = t->u.info;
+  t->u.ind.idx = luaK_exp2RK(fs, k);
+  t->u.ind.vt = (t->k == VUPVAL) ? VUPVAL
+                                 : check_exp(vkisinreg(t->k), VLOCAL);
+  t->k = VINDEXED;
+}
+
+
+static int constfolding (OpCode op, expdesc *e1, expdesc *e2) {
+  lua_Number r;
+  if (!isnumeral(e1) || !isnumeral(e2)) return 0;
+  if ((op == OP_DIV || op == OP_MOD) && e2->u.nval == 0)
+    return 0;  /* do not attempt to divide by 0 */
+  r = luaO_arith(op - OP_ADD + LUA_OPADD, e1->u.nval, e2->u.nval);
+  e1->u.nval = r;
+  return 1;
+}
+
+
+static void codearith (FuncState *fs, OpCode op,
+                       expdesc *e1, expdesc *e2, int line) {
+  if (constfolding(op, e1, e2))
+    return;
+  else {
+    int o2 = (op != OP_UNM && op != OP_LEN) ? luaK_exp2RK(fs, e2) : 0;
+    int o1 = luaK_exp2RK(fs, e1);
+    if (o1 > o2) {
+      freeexp(fs, e1);
+      freeexp(fs, e2);
+    }
+    else {
+      freeexp(fs, e2);
+      freeexp(fs, e1);
+    }
+    e1->u.info = luaK_codeABC(fs, op, 0, o1, o2);
+    e1->k = VRELOCABLE;
+    luaK_fixline(fs, line);
+  }
+}
+
+
+static void codecomp (FuncState *fs, OpCode op, int cond, expdesc *e1,
+                                                          expdesc *e2) {
+  int o1 = luaK_exp2RK(fs, e1);
+  int o2 = luaK_exp2RK(fs, e2);
+  freeexp(fs, e2);
+  freeexp(fs, e1);
+  if (cond == 0 && op != OP_EQ) {
+    int temp;  /* exchange args to replace by `<' or `<=' */
+    temp = o1; o1 = o2; o2 = temp;  /* o1 <==> o2 */
+    cond = 1;
+  }
+  e1->u.info = condjump(fs, op, cond, o1, o2);
+  e1->k = VJMP;
+}
+
+
+void luaK_prefix (FuncState *fs, UnOpr op, expdesc *e, int line) {
+  expdesc e2;
+  e2.t = e2.f = NO_JUMP; e2.k = VKNUM; e2.u.nval = 0;
+  switch (op) {
+    case OPR_MINUS: {
+      if (isnumeral(e))  /* minus constant? */
+        e->u.nval = luai_numunm(NULL, e->u.nval);  /* fold it */
+      else {
+        luaK_exp2anyreg(fs, e);
+        codearith(fs, OP_UNM, e, &e2, line);
+      }
+      break;
+    }
+    case OPR_NOT: codenot(fs, e); break;
+    case OPR_LEN: {
+      luaK_exp2anyreg(fs, e);  /* cannot operate on constants */
+      codearith(fs, OP_LEN, e, &e2, line);
+      break;
+    }
+    default: lua_assert(0);
+  }
+}
+
+
+void luaK_infix (FuncState *fs, BinOpr op, expdesc *v) {
+  switch (op) {
+    case OPR_AND: {
+      luaK_goiftrue(fs, v);
+      break;
+    }
+    case OPR_OR: {
+      luaK_goiffalse(fs, v);
+      break;
+    }
+    case OPR_CONCAT: {
+      luaK_exp2nextreg(fs, v);  /* operand must be on the `stack' */
+      break;
+    }
+    case OPR_ADD: case OPR_SUB: case OPR_MUL: case OPR_DIV:
+    case OPR_MOD: case OPR_POW: {
+      if (!isnumeral(v)) luaK_exp2RK(fs, v);
+      break;
+    }
+    default: {
+      luaK_exp2RK(fs, v);
+      break;
+    }
+  }
+}
+
+
+void luaK_posfix (FuncState *fs, BinOpr op,
+                  expdesc *e1, expdesc *e2, int line) {
+  switch (op) {
+    case OPR_AND: {
+      lua_assert(e1->t == NO_JUMP);  /* list must be closed */
+      luaK_dischargevars(fs, e2);
+      luaK_concat(fs, &e2->f, e1->f);
+      *e1 = *e2;
+      break;
+    }
+    case OPR_OR: {
+      lua_assert(e1->f == NO_JUMP);  /* list must be closed */
+      luaK_dischargevars(fs, e2);
+      luaK_concat(fs, &e2->t, e1->t);
+      *e1 = *e2;
+      break;
+    }
+    case OPR_CONCAT: {
+      luaK_exp2val(fs, e2);
+      if (e2->k == VRELOCABLE && GET_OPCODE(getcode(fs, e2)) == OP_CONCAT) {
+        lua_assert(e1->u.info == GETARG_B(getcode(fs, e2))-1);
+        freeexp(fs, e1);
+        SETARG_B(getcode(fs, e2), e1->u.info);
+        e1->k = VRELOCABLE; e1->u.info = e2->u.info;
+      }
+      else {
+        luaK_exp2nextreg(fs, e2);  /* operand must be on the 'stack' */
+        codearith(fs, OP_CONCAT, e1, e2, line);
+      }
+      break;
+    }
+    case OPR_ADD: case OPR_SUB: case OPR_MUL: case OPR_DIV:
+    case OPR_MOD: case OPR_POW: {
+      codearith(fs, cast(OpCode, op - OPR_ADD + OP_ADD), e1, e2, line);
+      break;
+    }
+    case OPR_EQ: case OPR_LT: case OPR_LE: {
+      codecomp(fs, cast(OpCode, op - OPR_EQ + OP_EQ), 1, e1, e2);
+      break;
+    }
+    case OPR_NE: case OPR_GT: case OPR_GE: {
+      codecomp(fs, cast(OpCode, op - OPR_NE + OP_EQ), 0, e1, e2);
+      break;
+    }
+    default: lua_assert(0);
+  }
+}
+
+
+void luaK_fixline (FuncState *fs, int line) {
+  fs->f->lineinfo[fs->pc - 1] = line;
+}
+
+
+void luaK_setlist (FuncState *fs, int base, int nelems, int tostore) {
+  int c =  (nelems - 1)/LFIELDS_PER_FLUSH + 1;
+  int b = (tostore == LUA_MULTRET) ? 0 : tostore;
+  lua_assert(tostore != 0);
+  if (c <= MAXARG_C)
+    luaK_codeABC(fs, OP_SETLIST, base, b, c);
+  else if (c <= MAXARG_Ax) {
+    luaK_codeABC(fs, OP_SETLIST, base, b, 0);
+    codeextraarg(fs, c);
+  }
+  else
+    luaX_syntaxerror(fs->ls, "constructor too long");
+  fs->freereg = base + 1;  /* free registers with list values */
+}
+
diff -ruNp src.hd/libs/lua/lcode.h src/libs/lua/lcode.h
--- src.hd/libs/lua/lcode.h	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lcode.h	2017-12-29 00:57:40 -0800
@@ -0,0 +1,83 @@
+/*
+** $Id: lcode.h,v 1.58 2011/08/30 16:26:41 roberto Exp $
+** Code generator for Lua
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lcode_h
+#define lcode_h
+
+#include "llex.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lparser.h"
+
+
+/*
+** Marks the end of a patch list. It is an invalid value both as an absolute
+** address, and as a list link (would link an element to itself).
+*/
+#define NO_JUMP (-1)
+
+
+/*
+** grep "ORDER OPR" if you change these enums  (ORDER OP)
+*/
+typedef enum BinOpr {
+  OPR_ADD, OPR_SUB, OPR_MUL, OPR_DIV, OPR_MOD, OPR_POW,
+  OPR_CONCAT,
+  OPR_EQ, OPR_LT, OPR_LE,
+  OPR_NE, OPR_GT, OPR_GE,
+  OPR_AND, OPR_OR,
+  OPR_NOBINOPR
+} BinOpr;
+
+
+typedef enum UnOpr { OPR_MINUS, OPR_NOT, OPR_LEN, OPR_NOUNOPR } UnOpr;
+
+
+#define getcode(fs,e)	((fs)->f->code[(e)->u.info])
+
+#define luaK_codeAsBx(fs,o,A,sBx)	luaK_codeABx(fs,o,A,(sBx)+MAXARG_sBx)
+
+#define luaK_setmultret(fs,e)	luaK_setreturns(fs, e, LUA_MULTRET)
+
+#define luaK_jumpto(fs,t)	luaK_patchlist(fs, luaK_jump(fs), t)
+
+LUAI_FUNC int luaK_codeABx (FuncState *fs, OpCode o, int A, unsigned int Bx);
+LUAI_FUNC int luaK_codeABC (FuncState *fs, OpCode o, int A, int B, int C);
+LUAI_FUNC int luaK_codek (FuncState *fs, int reg, int k);
+LUAI_FUNC void luaK_fixline (FuncState *fs, int line);
+LUAI_FUNC void luaK_nil (FuncState *fs, int from, int n);
+LUAI_FUNC void luaK_reserveregs (FuncState *fs, int n);
+LUAI_FUNC void luaK_checkstack (FuncState *fs, int n);
+LUAI_FUNC int luaK_stringK (FuncState *fs, TString *s);
+LUAI_FUNC int luaK_numberK (FuncState *fs, lua_Number r);
+LUAI_FUNC void luaK_dischargevars (FuncState *fs, expdesc *e);
+LUAI_FUNC int luaK_exp2anyreg (FuncState *fs, expdesc *e);
+LUAI_FUNC void luaK_exp2anyregup (FuncState *fs, expdesc *e);
+LUAI_FUNC void luaK_exp2nextreg (FuncState *fs, expdesc *e);
+LUAI_FUNC void luaK_exp2val (FuncState *fs, expdesc *e);
+LUAI_FUNC int luaK_exp2RK (FuncState *fs, expdesc *e);
+LUAI_FUNC void luaK_self (FuncState *fs, expdesc *e, expdesc *key);
+LUAI_FUNC void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k);
+LUAI_FUNC void luaK_goiftrue (FuncState *fs, expdesc *e);
+LUAI_FUNC void luaK_goiffalse (FuncState *fs, expdesc *e);
+LUAI_FUNC void luaK_storevar (FuncState *fs, expdesc *var, expdesc *e);
+LUAI_FUNC void luaK_setreturns (FuncState *fs, expdesc *e, int nresults);
+LUAI_FUNC void luaK_setoneret (FuncState *fs, expdesc *e);
+LUAI_FUNC int luaK_jump (FuncState *fs);
+LUAI_FUNC void luaK_ret (FuncState *fs, int first, int nret);
+LUAI_FUNC void luaK_patchlist (FuncState *fs, int list, int target);
+LUAI_FUNC void luaK_patchtohere (FuncState *fs, int list);
+LUAI_FUNC void luaK_patchclose (FuncState *fs, int list, int level);
+LUAI_FUNC void luaK_concat (FuncState *fs, int *l1, int l2);
+LUAI_FUNC int luaK_getlabel (FuncState *fs);
+LUAI_FUNC void luaK_prefix (FuncState *fs, UnOpr op, expdesc *v, int line);
+LUAI_FUNC void luaK_infix (FuncState *fs, BinOpr op, expdesc *v);
+LUAI_FUNC void luaK_posfix (FuncState *fs, BinOpr op, expdesc *v1,
+                            expdesc *v2, int line);
+LUAI_FUNC void luaK_setlist (FuncState *fs, int base, int nelems, int tostore);
+
+
+#endif
diff -ruNp src.hd/libs/lua/lcorolib.c src/libs/lua/lcorolib.c
--- src.hd/libs/lua/lcorolib.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lcorolib.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,155 @@
+/*
+** $Id: lcorolib.c,v 1.5 2013/02/21 13:44:53 roberto Exp $
+** Coroutine Library
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdlib.h>
+
+
+#define lcorolib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+static int auxresume (lua_State *L, lua_State *co, int narg) {
+  int status;
+  if (!lua_checkstack(co, narg)) {
+    lua_pushliteral(L, "too many arguments to resume");
+    return -1;  /* error flag */
+  }
+  if (lua_status(co) == LUA_OK && lua_gettop(co) == 0) {
+    lua_pushliteral(L, "cannot resume dead coroutine");
+    return -1;  /* error flag */
+  }
+  lua_xmove(L, co, narg);
+  status = lua_resume(co, L, narg);
+  if (status == LUA_OK || status == LUA_YIELD) {
+    int nres = lua_gettop(co);
+    if (!lua_checkstack(L, nres + 1)) {
+      lua_pop(co, nres);  /* remove results anyway */
+      lua_pushliteral(L, "too many results to resume");
+      return -1;  /* error flag */
+    }
+    lua_xmove(co, L, nres);  /* move yielded values */
+    return nres;
+  }
+  else {
+    lua_xmove(co, L, 1);  /* move error message */
+    return -1;  /* error flag */
+  }
+}
+
+
+static int luaB_coresume (lua_State *L) {
+  lua_State *co = lua_tothread(L, 1);
+  int r;
+  luaL_argcheck(L, co, 1, "coroutine expected");
+  r = auxresume(L, co, lua_gettop(L) - 1);
+  if (r < 0) {
+    lua_pushboolean(L, 0);
+    lua_insert(L, -2);
+    return 2;  /* return false + error message */
+  }
+  else {
+    lua_pushboolean(L, 1);
+    lua_insert(L, -(r + 1));
+    return r + 1;  /* return true + `resume' returns */
+  }
+}
+
+
+static int luaB_auxwrap (lua_State *L) {
+  lua_State *co = lua_tothread(L, lua_upvalueindex(1));
+  int r = auxresume(L, co, lua_gettop(L));
+  if (r < 0) {
+    if (lua_isstring(L, -1)) {  /* error object is a string? */
+      luaL_where(L, 1);  /* add extra info */
+      lua_insert(L, -2);
+      lua_concat(L, 2);
+    }
+    return lua_error(L);  /* propagate error */
+  }
+  return r;
+}
+
+
+static int luaB_cocreate (lua_State *L) {
+  lua_State *NL;
+  luaL_checktype(L, 1, LUA_TFUNCTION);
+  NL = lua_newthread(L);
+  lua_pushvalue(L, 1);  /* move function to top */
+  lua_xmove(L, NL, 1);  /* move function from L to NL */
+  return 1;
+}
+
+
+static int luaB_cowrap (lua_State *L) {
+  luaB_cocreate(L);
+  lua_pushcclosure(L, luaB_auxwrap, 1);
+  return 1;
+}
+
+
+static int luaB_yield (lua_State *L) {
+  return lua_yield(L, lua_gettop(L));
+}
+
+
+static int luaB_costatus (lua_State *L) {
+  lua_State *co = lua_tothread(L, 1);
+  luaL_argcheck(L, co, 1, "coroutine expected");
+  if (L == co) lua_pushliteral(L, "running");
+  else {
+    switch (lua_status(co)) {
+      case LUA_YIELD:
+        lua_pushliteral(L, "suspended");
+        break;
+      case LUA_OK: {
+        lua_Debug ar;
+        if (lua_getstack(co, 0, &ar) > 0)  /* does it have frames? */
+          lua_pushliteral(L, "normal");  /* it is running */
+        else if (lua_gettop(co) == 0)
+            lua_pushliteral(L, "dead");
+        else
+          lua_pushliteral(L, "suspended");  /* initial state */
+        break;
+      }
+      default:  /* some error occurred */
+        lua_pushliteral(L, "dead");
+        break;
+    }
+  }
+  return 1;
+}
+
+
+static int luaB_corunning (lua_State *L) {
+  int ismain = lua_pushthread(L);
+  lua_pushboolean(L, ismain);
+  return 2;
+}
+
+
+static const luaL_Reg co_funcs[] = {
+  {"create", luaB_cocreate},
+  {"resume", luaB_coresume},
+  {"running", luaB_corunning},
+  {"status", luaB_costatus},
+  {"wrap", luaB_cowrap},
+  {"yield", luaB_yield},
+  {NULL, NULL}
+};
+
+
+
+LUAMOD_API int luaopen_coroutine (lua_State *L) {
+  luaL_newlib(L, co_funcs);
+  return 1;
+}
+
diff -ruNp src.hd/libs/lua/lctype.c src/libs/lua/lctype.c
--- src.hd/libs/lua/lctype.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lctype.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,52 @@
+/*
+** $Id: lctype.c,v 1.11 2011/10/03 16:19:23 roberto Exp $
+** 'ctype' functions for Lua
+** See Copyright Notice in lua.h
+*/
+
+#define lctype_c
+#define LUA_CORE
+
+#include "lctype.h"
+
+#if !LUA_USE_CTYPE	/* { */
+
+#include <limits.h>
+
+LUAI_DDEF const lu_byte luai_ctype_[UCHAR_MAX + 2] = {
+  0x00,  /* EOZ */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* 0. */
+  0x00,  0x08,  0x08,  0x08,  0x08,  0x08,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* 1. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x0c,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,	/* 2. */
+  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,
+  0x16,  0x16,  0x16,  0x16,  0x16,  0x16,  0x16,  0x16,	/* 3. */
+  0x16,  0x16,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,
+  0x04,  0x15,  0x15,  0x15,  0x15,  0x15,  0x15,  0x05,	/* 4. */
+  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,
+  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,	/* 5. */
+  0x05,  0x05,  0x05,  0x04,  0x04,  0x04,  0x04,  0x05,
+  0x04,  0x15,  0x15,  0x15,  0x15,  0x15,  0x15,  0x05,	/* 6. */
+  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,
+  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,	/* 7. */
+  0x05,  0x05,  0x05,  0x04,  0x04,  0x04,  0x04,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* 8. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* 9. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* a. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* b. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* c. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* d. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* e. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,	/* f. */
+  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
+};
+
+#endif			/* } */
diff -ruNp src.hd/libs/lua/lctype.h src/libs/lua/lctype.h
--- src.hd/libs/lua/lctype.h	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lctype.h	2017-12-29 00:57:40 -0800
@@ -0,0 +1,95 @@
+/*
+** $Id: lctype.h,v 1.12 2011/07/15 12:50:29 roberto Exp $
+** 'ctype' functions for Lua
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lctype_h
+#define lctype_h
+
+#include "lua.h"
+
+
+/*
+** WARNING: the functions defined here do not necessarily correspond
+** to the similar functions in the standard C ctype.h. They are
+** optimized for the specific needs of Lua
+*/
+
+#if !defined(LUA_USE_CTYPE)
+
+#if 'A' == 65 && '0' == 48
+/* ASCII case: can use its own tables; faster and fixed */
+#define LUA_USE_CTYPE	0
+#else
+/* must use standard C ctype */
+#define LUA_USE_CTYPE	1
+#endif
+
+#endif
+
+
+#if !LUA_USE_CTYPE	/* { */
+
+#include <limits.h>
+
+#include "llimits.h"
+
+
+#define ALPHABIT	0
+#define DIGITBIT	1
+#define PRINTBIT	2
+#define SPACEBIT	3
+#define XDIGITBIT	4
+
+
+#define MASK(B)		(1 << (B))
+
+
+/*
+** add 1 to char to allow index -1 (EOZ)
+*/
+#define testprop(c,p)	(luai_ctype_[(c)+1] & (p))
+
+/*
+** 'lalpha' (Lua alphabetic) and 'lalnum' (Lua alphanumeric) both include '_'
+*/
+#define lislalpha(c)	testprop(c, MASK(ALPHABIT))
+#define lislalnum(c)	testprop(c, (MASK(ALPHABIT) | MASK(DIGITBIT)))
+#define lisdigit(c)	testprop(c, MASK(DIGITBIT))
+#define lisspace(c)	testprop(c, MASK(SPACEBIT))
+#define lisprint(c)	testprop(c, MASK(PRINTBIT))
+#define lisxdigit(c)	testprop(c, MASK(XDIGITBIT))
+
+/*
+** this 'ltolower' only works for alphabetic characters
+*/
+#define ltolower(c)	((c) | ('A' ^ 'a'))
+
+
+/* two more entries for 0 and -1 (EOZ) */
+LUAI_DDEC const lu_byte luai_ctype_[UCHAR_MAX + 2];
+
+
+#else			/* }{ */
+
+/*
+** use standard C ctypes
+*/
+
+#include <ctype.h>
+
+
+#define lislalpha(c)	(isalpha(c) || (c) == '_')
+#define lislalnum(c)	(isalnum(c) || (c) == '_')
+#define lisdigit(c)	(isdigit(c))
+#define lisspace(c)	(isspace(c))
+#define lisprint(c)	(isprint(c))
+#define lisxdigit(c)	(isxdigit(c))
+
+#define ltolower(c)	(tolower(c))
+
+#endif			/* } */
+
+#endif
+
diff -ruNp src.hd/libs/lua/ldblib.c src/libs/lua/ldblib.c
--- src.hd/libs/lua/ldblib.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/ldblib.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,398 @@
+/*
+** $Id: ldblib.c,v 1.132 2012/01/19 20:14:44 roberto Exp $
+** Interface from Lua to its debug API
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define ldblib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+#define HOOKKEY		"_HKEY"
+
+
+
+static int db_getregistry (lua_State *L) {
+  lua_pushvalue(L, LUA_REGISTRYINDEX);
+  return 1;
+}
+
+
+static int db_getmetatable (lua_State *L) {
+  luaL_checkany(L, 1);
+  if (!lua_getmetatable(L, 1)) {
+    lua_pushnil(L);  /* no metatable */
+  }
+  return 1;
+}
+
+
+static int db_setmetatable (lua_State *L) {
+  int t = lua_type(L, 2);
+  luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2,
+                    "nil or table expected");
+  lua_settop(L, 2);
+  lua_setmetatable(L, 1);
+  return 1;  /* return 1st argument */
+}
+
+
+static int db_getuservalue (lua_State *L) {
+  if (lua_type(L, 1) != LUA_TUSERDATA)
+    lua_pushnil(L);
+  else
+    lua_getuservalue(L, 1);
+  return 1;
+}
+
+
+static int db_setuservalue (lua_State *L) {
+  if (lua_type(L, 1) == LUA_TLIGHTUSERDATA)
+    luaL_argerror(L, 1, "full userdata expected, got light userdata");
+  luaL_checktype(L, 1, LUA_TUSERDATA);
+  if (!lua_isnoneornil(L, 2))
+    luaL_checktype(L, 2, LUA_TTABLE);
+  lua_settop(L, 2);
+  lua_setuservalue(L, 1);
+  return 1;
+}
+
+
+static void settabss (lua_State *L, const char *i, const char *v) {
+  lua_pushstring(L, v);
+  lua_setfield(L, -2, i);
+}
+
+
+static void settabsi (lua_State *L, const char *i, int v) {
+  lua_pushinteger(L, v);
+  lua_setfield(L, -2, i);
+}
+
+
+static void settabsb (lua_State *L, const char *i, int v) {
+  lua_pushboolean(L, v);
+  lua_setfield(L, -2, i);
+}
+
+
+static lua_State *getthread (lua_State *L, int *arg) {
+  if (lua_isthread(L, 1)) {
+    *arg = 1;
+    return lua_tothread(L, 1);
+  }
+  else {
+    *arg = 0;
+    return L;
+  }
+}
+
+
+static void treatstackoption (lua_State *L, lua_State *L1, const char *fname) {
+  if (L == L1) {
+    lua_pushvalue(L, -2);
+    lua_remove(L, -3);
+  }
+  else
+    lua_xmove(L1, L, 1);
+  lua_setfield(L, -2, fname);
+}
+
+
+static int db_getinfo (lua_State *L) {
+  lua_Debug ar;
+  int arg;
+  lua_State *L1 = getthread(L, &arg);
+  const char *options = luaL_optstring(L, arg+2, "flnStu");
+  if (lua_isnumber(L, arg+1)) {
+    if (!lua_getstack(L1, (int)lua_tointeger(L, arg+1), &ar)) {
+      lua_pushnil(L);  /* level out of range */
+      return 1;
+    }
+  }
+  else if (lua_isfunction(L, arg+1)) {
+    lua_pushfstring(L, ">%s", options);
+    options = lua_tostring(L, -1);
+    lua_pushvalue(L, arg+1);
+    lua_xmove(L, L1, 1);
+  }
+  else
+    return luaL_argerror(L, arg+1, "function or level expected");
+  if (!lua_getinfo(L1, options, &ar))
+    return luaL_argerror(L, arg+2, "invalid option");
+  lua_createtable(L, 0, 2);
+  if (strchr(options, 'S')) {
+    settabss(L, "source", ar.source);
+    settabss(L, "short_src", ar.short_src);
+    settabsi(L, "linedefined", ar.linedefined);
+    settabsi(L, "lastlinedefined", ar.lastlinedefined);
+    settabss(L, "what", ar.what);
+  }
+  if (strchr(options, 'l'))
+    settabsi(L, "currentline", ar.currentline);
+  if (strchr(options, 'u')) {
+    settabsi(L, "nups", ar.nups);
+    settabsi(L, "nparams", ar.nparams);
+    settabsb(L, "isvararg", ar.isvararg);
+  }
+  if (strchr(options, 'n')) {
+    settabss(L, "name", ar.name);
+    settabss(L, "namewhat", ar.namewhat);
+  }
+  if (strchr(options, 't'))
+    settabsb(L, "istailcall", ar.istailcall);
+  if (strchr(options, 'L'))
+    treatstackoption(L, L1, "activelines");
+  if (strchr(options, 'f'))
+    treatstackoption(L, L1, "func");
+  return 1;  /* return table */
+}
+
+
+static int db_getlocal (lua_State *L) {
+  int arg;
+  lua_State *L1 = getthread(L, &arg);
+  lua_Debug ar;
+  const char *name;
+  int nvar = luaL_checkint(L, arg+2);  /* local-variable index */
+  if (lua_isfunction(L, arg + 1)) {  /* function argument? */
+    lua_pushvalue(L, arg + 1);  /* push function */
+    lua_pushstring(L, lua_getlocal(L, NULL, nvar));  /* push local name */
+    return 1;
+  }
+  else {  /* stack-level argument */
+    if (!lua_getstack(L1, luaL_checkint(L, arg+1), &ar))  /* out of range? */
+      return luaL_argerror(L, arg+1, "level out of range");
+    name = lua_getlocal(L1, &ar, nvar);
+    if (name) {
+      lua_xmove(L1, L, 1);  /* push local value */
+      lua_pushstring(L, name);  /* push name */
+      lua_pushvalue(L, -2);  /* re-order */
+      return 2;
+    }
+    else {
+      lua_pushnil(L);  /* no name (nor value) */
+      return 1;
+    }
+  }
+}
+
+
+static int db_setlocal (lua_State *L) {
+  int arg;
+  lua_State *L1 = getthread(L, &arg);
+  lua_Debug ar;
+  if (!lua_getstack(L1, luaL_checkint(L, arg+1), &ar))  /* out of range? */
+    return luaL_argerror(L, arg+1, "level out of range");
+  luaL_checkany(L, arg+3);
+  lua_settop(L, arg+3);
+  lua_xmove(L, L1, 1);
+  lua_pushstring(L, lua_setlocal(L1, &ar, luaL_checkint(L, arg+2)));
+  return 1;
+}
+
+
+static int auxupvalue (lua_State *L, int get) {
+  const char *name;
+  int n = luaL_checkint(L, 2);
+  luaL_checktype(L, 1, LUA_TFUNCTION);
+  name = get ? lua_getupvalue(L, 1, n) : lua_setupvalue(L, 1, n);
+  if (name == NULL) return 0;
+  lua_pushstring(L, name);
+  lua_insert(L, -(get+1));
+  return get + 1;
+}
+
+
+static int db_getupvalue (lua_State *L) {
+  return auxupvalue(L, 1);
+}
+
+
+static int db_setupvalue (lua_State *L) {
+  luaL_checkany(L, 3);
+  return auxupvalue(L, 0);
+}
+
+
+static int checkupval (lua_State *L, int argf, int argnup) {
+  lua_Debug ar;
+  int nup = luaL_checkint(L, argnup);
+  luaL_checktype(L, argf, LUA_TFUNCTION);
+  lua_pushvalue(L, argf);
+  lua_getinfo(L, ">u", &ar);
+  luaL_argcheck(L, 1 <= nup && nup <= ar.nups, argnup, "invalid upvalue index");
+  return nup;
+}
+
+
+static int db_upvalueid (lua_State *L) {
+  int n = checkupval(L, 1, 2);
+  lua_pushlightuserdata(L, lua_upvalueid(L, 1, n));
+  return 1;
+}
+
+
+static int db_upvaluejoin (lua_State *L) {
+  int n1 = checkupval(L, 1, 2);
+  int n2 = checkupval(L, 3, 4);
+  luaL_argcheck(L, !lua_iscfunction(L, 1), 1, "Lua function expected");
+  luaL_argcheck(L, !lua_iscfunction(L, 3), 3, "Lua function expected");
+  lua_upvaluejoin(L, 1, n1, 3, n2);
+  return 0;
+}
+
+
+#define gethooktable(L)	luaL_getsubtable(L, LUA_REGISTRYINDEX, HOOKKEY)
+
+
+static void hookf (lua_State *L, lua_Debug *ar) {
+  static const char *const hooknames[] =
+    {"call", "return", "line", "count", "tail call"};
+  gethooktable(L);
+  lua_pushthread(L);
+  lua_rawget(L, -2);
+  if (lua_isfunction(L, -1)) {
+    lua_pushstring(L, hooknames[(int)ar->event]);
+    if (ar->currentline >= 0)
+      lua_pushinteger(L, ar->currentline);
+    else lua_pushnil(L);
+    lua_assert(lua_getinfo(L, "lS", ar));
+    lua_call(L, 2, 0);
+  }
+}
+
+
+static int makemask (const char *smask, int count) {
+  int mask = 0;
+  if (strchr(smask, 'c')) mask |= LUA_MASKCALL;
+  if (strchr(smask, 'r')) mask |= LUA_MASKRET;
+  if (strchr(smask, 'l')) mask |= LUA_MASKLINE;
+  if (count > 0) mask |= LUA_MASKCOUNT;
+  return mask;
+}
+
+
+static char *unmakemask (int mask, char *smask) {
+  int i = 0;
+  if (mask & LUA_MASKCALL) smask[i++] = 'c';
+  if (mask & LUA_MASKRET) smask[i++] = 'r';
+  if (mask & LUA_MASKLINE) smask[i++] = 'l';
+  smask[i] = '\0';
+  return smask;
+}
+
+
+static int db_sethook (lua_State *L) {
+  int arg, mask, count;
+  lua_Hook func;
+  lua_State *L1 = getthread(L, &arg);
+  if (lua_isnoneornil(L, arg+1)) {
+    lua_settop(L, arg+1);
+    func = NULL; mask = 0; count = 0;  /* turn off hooks */
+  }
+  else {
+    const char *smask = luaL_checkstring(L, arg+2);
+    luaL_checktype(L, arg+1, LUA_TFUNCTION);
+    count = luaL_optint(L, arg+3, 0);
+    func = hookf; mask = makemask(smask, count);
+  }
+  if (gethooktable(L) == 0) {  /* creating hook table? */
+    lua_pushstring(L, "k");
+    lua_setfield(L, -2, "__mode");  /** hooktable.__mode = "k" */
+    lua_pushvalue(L, -1);
+    lua_setmetatable(L, -2);  /* setmetatable(hooktable) = hooktable */
+  }
+  lua_pushthread(L1); lua_xmove(L1, L, 1);
+  lua_pushvalue(L, arg+1);
+  lua_rawset(L, -3);  /* set new hook */
+  lua_sethook(L1, func, mask, count);  /* set hooks */
+  return 0;
+}
+
+
+static int db_gethook (lua_State *L) {
+  int arg;
+  lua_State *L1 = getthread(L, &arg);
+  char buff[5];
+  int mask = lua_gethookmask(L1);
+  lua_Hook hook = lua_gethook(L1);
+  if (hook != NULL && hook != hookf)  /* external hook? */
+    lua_pushliteral(L, "external hook");
+  else {
+    gethooktable(L);
+    lua_pushthread(L1); lua_xmove(L1, L, 1);
+    lua_rawget(L, -2);   /* get hook */
+    lua_remove(L, -2);  /* remove hook table */
+  }
+  lua_pushstring(L, unmakemask(mask, buff));
+  lua_pushinteger(L, lua_gethookcount(L1));
+  return 3;
+}
+
+
+static int db_debug (lua_State *L) {
+  for (;;) {
+    char buffer[250];
+    luai_writestringerror("%s", "lua_debug> ");
+    if (fgets(buffer, sizeof(buffer), stdin) == 0 ||
+        strcmp(buffer, "cont\n") == 0)
+      return 0;
+    if (luaL_loadbuffer(L, buffer, strlen(buffer), "=(debug command)") ||
+        lua_pcall(L, 0, 0, 0))
+      luai_writestringerror("%s\n", lua_tostring(L, -1));
+    lua_settop(L, 0);  /* remove eventual returns */
+  }
+}
+
+
+static int db_traceback (lua_State *L) {
+  int arg;
+  lua_State *L1 = getthread(L, &arg);
+  const char *msg = lua_tostring(L, arg + 1);
+  if (msg == NULL && !lua_isnoneornil(L, arg + 1))  /* non-string 'msg'? */
+    lua_pushvalue(L, arg + 1);  /* return it untouched */
+  else {
+    int level = luaL_optint(L, arg + 2, (L == L1) ? 1 : 0);
+    luaL_traceback(L, L1, msg, level);
+  }
+  return 1;
+}
+
+
+static const luaL_Reg dblib[] = {
+  {"debug", db_debug},
+  {"getuservalue", db_getuservalue},
+  {"gethook", db_gethook},
+  {"getinfo", db_getinfo},
+  {"getlocal", db_getlocal},
+  {"getregistry", db_getregistry},
+  {"getmetatable", db_getmetatable},
+  {"getupvalue", db_getupvalue},
+  {"upvaluejoin", db_upvaluejoin},
+  {"upvalueid", db_upvalueid},
+  {"setuservalue", db_setuservalue},
+  {"sethook", db_sethook},
+  {"setlocal", db_setlocal},
+  {"setmetatable", db_setmetatable},
+  {"setupvalue", db_setupvalue},
+  {"traceback", db_traceback},
+  {NULL, NULL}
+};
+
+
+LUAMOD_API int luaopen_debug (lua_State *L) {
+  luaL_newlib(L, dblib);
+  return 1;
+}
+
diff -ruNp src.hd/libs/lua/ldebug.c src/libs/lua/ldebug.c
--- src.hd/libs/lua/ldebug.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/ldebug.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,580 @@
+/*
+** $Id: ldebug.c,v 2.90 2012/08/16 17:34:28 roberto Exp $
+** Debug Interface
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdarg.h>
+#include <stddef.h>
+#include <string.h>
+
+
+#define ldebug_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lapi.h"
+#include "lcode.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+#include "lvm.h"
+
+
+
+#define noLuaClosure(f)		((f) == NULL || (f)->c.tt == LUA_TCCL)
+
+
+static const char *getfuncname (lua_State *L, CallInfo *ci, const char **name);
+
+
+static int currentpc (CallInfo *ci) {
+  lua_assert(isLua(ci));
+  return pcRel(ci->u.l.savedpc, ci_func(ci)->p);
+}
+
+
+static int currentline (CallInfo *ci) {
+  return getfuncline(ci_func(ci)->p, currentpc(ci));
+}
+
+
+/*
+** this function can be called asynchronous (e.g. during a signal)
+*/
+LUA_API int lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {
+  if (func == NULL || mask == 0) {  /* turn off hooks? */
+    mask = 0;
+    func = NULL;
+  }
+  if (isLua(L->ci))
+    L->oldpc = L->ci->u.l.savedpc;
+  L->hook = func;
+  L->basehookcount = count;
+  resethookcount(L);
+  L->hookmask = cast_byte(mask);
+  return 1;
+}
+
+
+LUA_API lua_Hook lua_gethook (lua_State *L) {
+  return L->hook;
+}
+
+
+LUA_API int lua_gethookmask (lua_State *L) {
+  return L->hookmask;
+}
+
+
+LUA_API int lua_gethookcount (lua_State *L) {
+  return L->basehookcount;
+}
+
+
+LUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar) {
+  int status;
+  CallInfo *ci;
+  if (level < 0) return 0;  /* invalid (negative) level */
+  lua_lock(L);
+  for (ci = L->ci; level > 0 && ci != &L->base_ci; ci = ci->previous)
+    level--;
+  if (level == 0 && ci != &L->base_ci) {  /* level found? */
+    status = 1;
+    ar->i_ci = ci;
+  }
+  else status = 0;  /* no such level */
+  lua_unlock(L);
+  return status;
+}
+
+
+static const char *upvalname (Proto *p, int uv) {
+  TString *s = check_exp(uv < p->sizeupvalues, p->upvalues[uv].name);
+  if (s == NULL) return "?";
+  else return getstr(s);
+}
+
+
+static const char *findvararg (CallInfo *ci, int n, StkId *pos) {
+  int nparams = clLvalue(ci->func)->p->numparams;
+  if (n >= ci->u.l.base - ci->func - nparams)
+    return NULL;  /* no such vararg */
+  else {
+    *pos = ci->func + nparams + n;
+    return "(*vararg)";  /* generic name for any vararg */
+  }
+}
+
+
+static const char *findlocal (lua_State *L, CallInfo *ci, int n,
+                              StkId *pos) {
+  const char *name = NULL;
+  StkId base;
+  if (isLua(ci)) {
+    if (n < 0)  /* access to vararg values? */
+      return findvararg(ci, -n, pos);
+    else {
+      base = ci->u.l.base;
+      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));
+    }
+  }
+  else
+    base = ci->func + 1;
+  if (name == NULL) {  /* no 'standard' name? */
+    StkId limit = (ci == L->ci) ? L->top : ci->next->func;
+    if (limit - base >= n && n > 0)  /* is 'n' inside 'ci' stack? */
+      name = "(*temporary)";  /* generic name for any valid slot */
+    else
+      return NULL;  /* no name */
+  }
+  *pos = base + (n - 1);
+  return name;
+}
+
+
+LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n) {
+  const char *name;
+  lua_lock(L);
+  if (ar == NULL) {  /* information about non-active function? */
+    if (!isLfunction(L->top - 1))  /* not a Lua function? */
+      name = NULL;
+    else  /* consider live variables at function start (parameters) */
+      name = luaF_getlocalname(clLvalue(L->top - 1)->p, n, 0);
+  }
+  else {  /* active function; get information through 'ar' */
+    StkId pos = 0;  /* to avoid warnings */
+    name = findlocal(L, ar->i_ci, n, &pos);
+    if (name) {
+      setobj2s(L, L->top, pos);
+      api_incr_top(L);
+    }
+  }
+  lua_unlock(L);
+  return name;
+}
+
+
+LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {
+  StkId pos = 0;  /* to avoid warnings */
+  const char *name = findlocal(L, ar->i_ci, n, &pos);
+  lua_lock(L);
+  if (name)
+    setobjs2s(L, pos, L->top - 1);
+  L->top--;  /* pop value */
+  lua_unlock(L);
+  return name;
+}
+
+
+static void funcinfo (lua_Debug *ar, Closure *cl) {
+  if (noLuaClosure(cl)) {
+    ar->source = "=[C]";
+    ar->linedefined = -1;
+    ar->lastlinedefined = -1;
+    ar->what = "C";
+  }
+  else {
+    Proto *p = cl->l.p;
+    ar->source = p->source ? getstr(p->source) : "=?";
+    ar->linedefined = p->linedefined;
+    ar->lastlinedefined = p->lastlinedefined;
+    ar->what = (ar->linedefined == 0) ? "main" : "Lua";
+  }
+  luaO_chunkid(ar->short_src, ar->source, LUA_IDSIZE);
+}
+
+
+static void collectvalidlines (lua_State *L, Closure *f) {
+  if (noLuaClosure(f)) {
+    setnilvalue(L->top);
+    api_incr_top(L);
+  }
+  else {
+    int i;
+    TValue v;
+    int *lineinfo = f->l.p->lineinfo;
+    Table *t = luaH_new(L);  /* new table to store active lines */
+    sethvalue(L, L->top, t);  /* push it on stack */
+    api_incr_top(L);
+    setbvalue(&v, 1);  /* boolean 'true' to be the value of all indices */
+    for (i = 0; i < f->l.p->sizelineinfo; i++)  /* for all lines with code */
+      luaH_setint(L, t, lineinfo[i], &v);  /* table[line] = true */
+  }
+}
+
+
+static int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,
+                       Closure *f, CallInfo *ci) {
+  int status = 1;
+  for (; *what; what++) {
+    switch (*what) {
+      case 'S': {
+        funcinfo(ar, f);
+        break;
+      }
+      case 'l': {
+        ar->currentline = (ci && isLua(ci)) ? currentline(ci) : -1;
+        break;
+      }
+      case 'u': {
+        ar->nups = (f == NULL) ? 0 : f->c.nupvalues;
+        if (noLuaClosure(f)) {
+          ar->isvararg = 1;
+          ar->nparams = 0;
+        }
+        else {
+          ar->isvararg = f->l.p->is_vararg;
+          ar->nparams = f->l.p->numparams;
+        }
+        break;
+      }
+      case 't': {
+        ar->istailcall = (ci) ? ci->callstatus & CIST_TAIL : 0;
+        break;
+      }
+      case 'n': {
+        /* calling function is a known Lua function? */
+        if (ci && !(ci->callstatus & CIST_TAIL) && isLua(ci->previous))
+          ar->namewhat = getfuncname(L, ci->previous, &ar->name);
+        else
+          ar->namewhat = NULL;
+        if (ar->namewhat == NULL) {
+          ar->namewhat = "";  /* not found */
+          ar->name = NULL;
+        }
+        break;
+      }
+      case 'L':
+      case 'f':  /* handled by lua_getinfo */
+        break;
+      default: status = 0;  /* invalid option */
+    }
+  }
+  return status;
+}
+
+
+LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar) {
+  int status;
+  Closure *cl;
+  CallInfo *ci;
+  StkId func;
+  lua_lock(L);
+  if (*what == '>') {
+    ci = NULL;
+    func = L->top - 1;
+    api_check(L, ttisfunction(func), "function expected");
+    what++;  /* skip the '>' */
+    L->top--;  /* pop function */
+  }
+  else {
+    ci = ar->i_ci;
+    func = ci->func;
+    lua_assert(ttisfunction(ci->func));
+  }
+  cl = ttisclosure(func) ? clvalue(func) : NULL;
+  status = auxgetinfo(L, what, ar, cl, ci);
+  if (strchr(what, 'f')) {
+    setobjs2s(L, L->top, func);
+    api_incr_top(L);
+  }
+  if (strchr(what, 'L'))
+    collectvalidlines(L, cl);
+  lua_unlock(L);
+  return status;
+}
+
+
+/*
+** {======================================================
+** Symbolic Execution
+** =======================================================
+*/
+
+static const char *getobjname (Proto *p, int lastpc, int reg,
+                               const char **name);
+
+
+/*
+** find a "name" for the RK value 'c'
+*/
+static void kname (Proto *p, int pc, int c, const char **name) {
+  if (ISK(c)) {  /* is 'c' a constant? */
+    TValue *kvalue = &p->k[INDEXK(c)];
+    if (ttisstring(kvalue)) {  /* literal constant? */
+      *name = svalue(kvalue);  /* it is its own name */
+      return;
+    }
+    /* else no reasonable name found */
+  }
+  else {  /* 'c' is a register */
+    const char *what = getobjname(p, pc, c, name); /* search for 'c' */
+    if (what && *what == 'c') {  /* found a constant name? */
+      return;  /* 'name' already filled */
+    }
+    /* else no reasonable name found */
+  }
+  *name = "?";  /* no reasonable name found */
+}
+
+
+/*
+** try to find last instruction before 'lastpc' that modified register 'reg'
+*/
+static int findsetreg (Proto *p, int lastpc, int reg) {
+  int pc;
+  int setreg = -1;  /* keep last instruction that changed 'reg' */
+  for (pc = 0; pc < lastpc; pc++) {
+    Instruction i = p->code[pc];
+    OpCode op = GET_OPCODE(i);
+    int a = GETARG_A(i);
+    switch (op) {
+      case OP_LOADNIL: {
+        int b = GETARG_B(i);
+        if (a <= reg && reg <= a + b)  /* set registers from 'a' to 'a+b' */
+          setreg = pc;
+        break;
+      }
+      case OP_TFORCALL: {
+        if (reg >= a + 2) setreg = pc;  /* affect all regs above its base */
+        break;
+      }
+      case OP_CALL:
+      case OP_TAILCALL: {
+        if (reg >= a) setreg = pc;  /* affect all registers above base */
+        break;
+      }
+      case OP_JMP: {
+        int b = GETARG_sBx(i);
+        int dest = pc + 1 + b;
+        /* jump is forward and do not skip `lastpc'? */
+        if (pc < dest && dest <= lastpc)
+          pc += b;  /* do the jump */
+        break;
+      }
+      case OP_TEST: {
+        if (reg == a) setreg = pc;  /* jumped code can change 'a' */
+        break;
+      }
+      default:
+        if (testAMode(op) && reg == a)  /* any instruction that set A */
+          setreg = pc;
+        break;
+    }
+  }
+  return setreg;
+}
+
+
+static const char *getobjname (Proto *p, int lastpc, int reg,
+                               const char **name) {
+  int pc;
+  *name = luaF_getlocalname(p, reg + 1, lastpc);
+  if (*name)  /* is a local? */
+    return "local";
+  /* else try symbolic execution */
+  pc = findsetreg(p, lastpc, reg);
+  if (pc != -1) {  /* could find instruction? */
+    Instruction i = p->code[pc];
+    OpCode op = GET_OPCODE(i);
+    switch (op) {
+      case OP_MOVE: {
+        int b = GETARG_B(i);  /* move from 'b' to 'a' */
+        if (b < GETARG_A(i))
+          return getobjname(p, pc, b, name);  /* get name for 'b' */
+        break;
+      }
+      case OP_GETTABUP:
+      case OP_GETTABLE: {
+        int k = GETARG_C(i);  /* key index */
+        int t = GETARG_B(i);  /* table index */
+        const char *vn = (op == OP_GETTABLE)  /* name of indexed variable */
+                         ? luaF_getlocalname(p, t + 1, pc)
+                         : upvalname(p, t);
+        kname(p, pc, k, name);
+        return (vn && strcmp(vn, LUA_ENV) == 0) ? "global" : "field";
+      }
+      case OP_GETUPVAL: {
+        *name = upvalname(p, GETARG_B(i));
+        return "upvalue";
+      }
+      case OP_LOADK:
+      case OP_LOADKX: {
+        int b = (op == OP_LOADK) ? GETARG_Bx(i)
+                                 : GETARG_Ax(p->code[pc + 1]);
+        if (ttisstring(&p->k[b])) {
+          *name = svalue(&p->k[b]);
+          return "constant";
+        }
+        break;
+      }
+      case OP_SELF: {
+        int k = GETARG_C(i);  /* key index */
+        kname(p, pc, k, name);
+        return "method";
+      }
+      default: break;  /* go through to return NULL */
+    }
+  }
+  return NULL;  /* could not find reasonable name */
+}
+
+
+static const char *getfuncname (lua_State *L, CallInfo *ci, const char **name) {
+  TMS tm;
+  Proto *p = ci_func(ci)->p;  /* calling function */
+  int pc = currentpc(ci);  /* calling instruction index */
+  Instruction i = p->code[pc];  /* calling instruction */
+  switch (GET_OPCODE(i)) {
+    case OP_CALL:
+    case OP_TAILCALL:  /* get function name */
+      return getobjname(p, pc, GETARG_A(i), name);
+    case OP_TFORCALL: {  /* for iterator */
+      *name = "for iterator";
+       return "for iterator";
+    }
+    /* all other instructions can call only through metamethods */
+    case OP_SELF:
+    case OP_GETTABUP:
+    case OP_GETTABLE: tm = TM_INDEX; break;
+    case OP_SETTABUP:
+    case OP_SETTABLE: tm = TM_NEWINDEX; break;
+    case OP_EQ: tm = TM_EQ; break;
+    case OP_ADD: tm = TM_ADD; break;
+    case OP_SUB: tm = TM_SUB; break;
+    case OP_MUL: tm = TM_MUL; break;
+    case OP_DIV: tm = TM_DIV; break;
+    case OP_MOD: tm = TM_MOD; break;
+    case OP_POW: tm = TM_POW; break;
+    case OP_UNM: tm = TM_UNM; break;
+    case OP_LEN: tm = TM_LEN; break;
+    case OP_LT: tm = TM_LT; break;
+    case OP_LE: tm = TM_LE; break;
+    case OP_CONCAT: tm = TM_CONCAT; break;
+    default:
+      return NULL;  /* else no useful name can be found */
+  }
+  *name = getstr(G(L)->tmname[tm]);
+  return "metamethod";
+}
+
+/* }====================================================== */
+
+
+
+/*
+** only ANSI way to check whether a pointer points to an array
+** (used only for error messages, so efficiency is not a big concern)
+*/
+static int isinstack (CallInfo *ci, const TValue *o) {
+  StkId p;
+  for (p = ci->u.l.base; p < ci->top; p++)
+    if (o == p) return 1;
+  return 0;
+}
+
+
+static const char *getupvalname (CallInfo *ci, const TValue *o,
+                                 const char **name) {
+  LClosure *c = ci_func(ci);
+  int i;
+  for (i = 0; i < c->nupvalues; i++) {
+    if (c->upvals[i]->v == o) {
+      *name = upvalname(c->p, i);
+      return "upvalue";
+    }
+  }
+  return NULL;
+}
+
+
+l_noret luaG_typeerror (lua_State *L, const TValue *o, const char *op) {
+  CallInfo *ci = L->ci;
+  const char *name = NULL;
+  const char *t = objtypename(o);
+  const char *kind = NULL;
+  if (isLua(ci)) {
+    kind = getupvalname(ci, o, &name);  /* check whether 'o' is an upvalue */
+    if (!kind && isinstack(ci, o))  /* no? try a register */
+      kind = getobjname(ci_func(ci)->p, currentpc(ci),
+                        cast_int(o - ci->u.l.base), &name);
+  }
+  if (kind)
+    luaG_runerror(L, "attempt to %s %s " LUA_QS " (a %s value)",
+                op, kind, name, t);
+  else
+    luaG_runerror(L, "attempt to %s a %s value", op, t);
+}
+
+
+l_noret luaG_concaterror (lua_State *L, StkId p1, StkId p2) {
+  if (ttisstring(p1) || ttisnumber(p1)) p1 = p2;
+  lua_assert(!ttisstring(p1) && !ttisnumber(p2));
+  luaG_typeerror(L, p1, "concatenate");
+}
+
+
+l_noret luaG_aritherror (lua_State *L, const TValue *p1, const TValue *p2) {
+  TValue temp;
+  if (luaV_tonumber(p1, &temp) == NULL)
+    p2 = p1;  /* first operand is wrong */
+  luaG_typeerror(L, p2, "perform arithmetic on");
+}
+
+
+l_noret luaG_ordererror (lua_State *L, const TValue *p1, const TValue *p2) {
+  const char *t1 = objtypename(p1);
+  const char *t2 = objtypename(p2);
+  if (t1 == t2)
+    luaG_runerror(L, "attempt to compare two %s values", t1);
+  else
+    luaG_runerror(L, "attempt to compare %s with %s", t1, t2);
+}
+
+
+static void addinfo (lua_State *L, const char *msg) {
+  CallInfo *ci = L->ci;
+  if (isLua(ci)) {  /* is Lua code? */
+    char buff[LUA_IDSIZE];  /* add file:line information */
+    int line = currentline(ci);
+    TString *src = ci_func(ci)->p->source;
+    if (src)
+      luaO_chunkid(buff, getstr(src), LUA_IDSIZE);
+    else {  /* no source available; use "?" instead */
+      buff[0] = '?'; buff[1] = '\0';
+    }
+    luaO_pushfstring(L, "%s:%d: %s", buff, line, msg);
+  }
+}
+
+
+l_noret luaG_errormsg (lua_State *L) {
+  if (L->errfunc != 0) {  /* is there an error handling function? */
+    StkId errfunc = restorestack(L, L->errfunc);
+    if (!ttisfunction(errfunc)) luaD_throw(L, LUA_ERRERR);
+    setobjs2s(L, L->top, L->top - 1);  /* move argument */
+    setobjs2s(L, L->top - 1, errfunc);  /* push function */
+    L->top++;
+    luaD_call(L, L->top - 2, 1, 0);  /* call it */
+  }
+  luaD_throw(L, LUA_ERRRUN);
+}
+
+
+l_noret luaG_runerror (lua_State *L, const char *fmt, ...) {
+  va_list argp;
+  va_start(argp, fmt);
+  addinfo(L, luaO_pushvfstring(L, fmt, argp));
+  va_end(argp);
+  luaG_errormsg(L);
+}
+
diff -ruNp src.hd/libs/lua/ldebug.h src/libs/lua/ldebug.h
--- src.hd/libs/lua/ldebug.h	1969-12-31 16:00:00 -0800
+++ src/libs/lua/ldebug.h	2017-12-29 00:57:40 -0800
@@ -0,0 +1,34 @@
+/*
+** $Id: ldebug.h,v 2.7 2011/10/07 20:45:19 roberto Exp $
+** Auxiliary functions from Debug Interface module
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ldebug_h
+#define ldebug_h
+
+
+#include "lstate.h"
+
+
+#define pcRel(pc, p)	(cast(int, (pc) - (p)->code) - 1)
+
+#define getfuncline(f,pc)	(((f)->lineinfo) ? (f)->lineinfo[pc] : 0)
+
+#define resethookcount(L)	(L->hookcount = L->basehookcount)
+
+/* Active Lua function (given call info) */
+#define ci_func(ci)		(clLvalue((ci)->func))
+
+
+LUAI_FUNC l_noret luaG_typeerror (lua_State *L, const TValue *o,
+                                                const char *opname);
+LUAI_FUNC l_noret luaG_concaterror (lua_State *L, StkId p1, StkId p2);
+LUAI_FUNC l_noret luaG_aritherror (lua_State *L, const TValue *p1,
+                                                 const TValue *p2);
+LUAI_FUNC l_noret luaG_ordererror (lua_State *L, const TValue *p1,
+                                                 const TValue *p2);
+LUAI_FUNC l_noret luaG_runerror (lua_State *L, const char *fmt, ...);
+LUAI_FUNC l_noret luaG_errormsg (lua_State *L);
+
+#endif
diff -ruNp src.hd/libs/lua/ldo.c src/libs/lua/ldo.c
--- src.hd/libs/lua/ldo.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/ldo.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,673 @@
+/*
+** $Id: ldo.c,v 2.108 2012/10/01 14:05:04 roberto Exp $
+** Stack and Call structure of Lua
+** See Copyright Notice in lua.h
+*/
+
+
+#include <setjmp.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define ldo_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lapi.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lparser.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+#include "lundump.h"
+#include "lvm.h"
+#include "lzio.h"
+
+
+
+
+/*
+** {======================================================
+** Error-recovery functions
+** =======================================================
+*/
+
+/*
+** LUAI_THROW/LUAI_TRY define how Lua does exception handling. By
+** default, Lua handles errors with exceptions when compiling as
+** C++ code, with _longjmp/_setjmp when asked to use them, and with
+** longjmp/setjmp otherwise.
+*/
+#if !defined(LUAI_THROW)
+
+#if defined(__cplusplus) && !defined(LUA_USE_LONGJMP)
+/* C++ exceptions */
+#define LUAI_THROW(L,c)		throw(c)
+#define LUAI_TRY(L,c,a) \
+	try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }
+#define luai_jmpbuf		int  /* dummy variable */
+
+#elif defined(LUA_USE_ULONGJMP)
+/* in Unix, try _longjmp/_setjmp (more efficient) */
+#define LUAI_THROW(L,c)		_longjmp((c)->b, 1)
+#define LUAI_TRY(L,c,a)		if (_setjmp((c)->b) == 0) { a }
+#define luai_jmpbuf		jmp_buf
+
+#else
+/* default handling with long jumps */
+#define LUAI_THROW(L,c)		longjmp((c)->b, 1)
+#define LUAI_TRY(L,c,a)		if (setjmp((c)->b) == 0) { a }
+#define luai_jmpbuf		jmp_buf
+
+#endif
+
+#endif
+
+
+
+/* chain list of long jump buffers */
+struct lua_longjmp {
+  struct lua_longjmp *previous;
+  luai_jmpbuf b;
+  volatile int status;  /* error code */
+};
+
+
+static void seterrorobj (lua_State *L, int errcode, StkId oldtop) {
+  switch (errcode) {
+    case LUA_ERRMEM: {  /* memory error? */
+      setsvalue2s(L, oldtop, G(L)->memerrmsg); /* reuse preregistered msg. */
+      break;
+    }
+    case LUA_ERRERR: {
+      setsvalue2s(L, oldtop, luaS_newliteral(L, "error in error handling"));
+      break;
+    }
+    default: {
+      setobjs2s(L, oldtop, L->top - 1);  /* error message on current top */
+      break;
+    }
+  }
+  L->top = oldtop + 1;
+}
+
+
+l_noret luaD_throw (lua_State *L, int errcode) {
+  if (L->errorJmp) {  /* thread has an error handler? */
+    L->errorJmp->status = errcode;  /* set status */
+    LUAI_THROW(L, L->errorJmp);  /* jump to it */
+  }
+  else {  /* thread has no error handler */
+    L->status = cast_byte(errcode);  /* mark it as dead */
+    if (G(L)->mainthread->errorJmp) {  /* main thread has a handler? */
+      setobjs2s(L, G(L)->mainthread->top++, L->top - 1);  /* copy error obj. */
+      luaD_throw(G(L)->mainthread, errcode);  /* re-throw in main thread */
+    }
+    else {  /* no handler at all; abort */
+      if (G(L)->panic) {  /* panic function? */
+        lua_unlock(L);
+        G(L)->panic(L);  /* call it (last chance to jump out) */
+      }
+      abort();
+    }
+  }
+}
+
+
+int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {
+  unsigned short oldnCcalls = L->nCcalls;
+  struct lua_longjmp lj;
+  lj.status = LUA_OK;
+  lj.previous = L->errorJmp;  /* chain new error handler */
+  L->errorJmp = &lj;
+  LUAI_TRY(L, &lj,
+    (*f)(L, ud);
+  );
+  L->errorJmp = lj.previous;  /* restore old error handler */
+  L->nCcalls = oldnCcalls;
+  return lj.status;
+}
+
+/* }====================================================== */
+
+
+static void correctstack (lua_State *L, TValue *oldstack) {
+  CallInfo *ci;
+  GCObject *up;
+  L->top = (L->top - oldstack) + L->stack;
+  for (up = L->openupval; up != NULL; up = up->gch.next)
+    gco2uv(up)->v = (gco2uv(up)->v - oldstack) + L->stack;
+  for (ci = L->ci; ci != NULL; ci = ci->previous) {
+    ci->top = (ci->top - oldstack) + L->stack;
+    ci->func = (ci->func - oldstack) + L->stack;
+    if (isLua(ci))
+      ci->u.l.base = (ci->u.l.base - oldstack) + L->stack;
+  }
+}
+
+
+/* some space for error handling */
+#define ERRORSTACKSIZE	(LUAI_MAXSTACK + 200)
+
+
+void luaD_reallocstack (lua_State *L, int newsize) {
+  TValue *oldstack = L->stack;
+  int lim = L->stacksize;
+  lua_assert(newsize <= LUAI_MAXSTACK || newsize == ERRORSTACKSIZE);
+  lua_assert(L->stack_last - L->stack == L->stacksize - EXTRA_STACK);
+  luaM_reallocvector(L, L->stack, L->stacksize, newsize, TValue);
+  for (; lim < newsize; lim++)
+    setnilvalue(L->stack + lim); /* erase new segment */
+  L->stacksize = newsize;
+  L->stack_last = L->stack + newsize - EXTRA_STACK;
+  correctstack(L, oldstack);
+}
+
+
+void luaD_growstack (lua_State *L, int n) {
+  int size = L->stacksize;
+  if (size > LUAI_MAXSTACK)  /* error after extra size? */
+    luaD_throw(L, LUA_ERRERR);
+  else {
+    int needed = cast_int(L->top - L->stack) + n + EXTRA_STACK;
+    int newsize = 2 * size;
+    if (newsize > LUAI_MAXSTACK) newsize = LUAI_MAXSTACK;
+    if (newsize < needed) newsize = needed;
+    if (newsize > LUAI_MAXSTACK) {  /* stack overflow? */
+      luaD_reallocstack(L, ERRORSTACKSIZE);
+      luaG_runerror(L, "stack overflow");
+    }
+    else
+      luaD_reallocstack(L, newsize);
+  }
+}
+
+
+static int stackinuse (lua_State *L) {
+  CallInfo *ci;
+  StkId lim = L->top;
+  for (ci = L->ci; ci != NULL; ci = ci->previous) {
+    lua_assert(ci->top <= L->stack_last);
+    if (lim < ci->top) lim = ci->top;
+  }
+  return cast_int(lim - L->stack) + 1;  /* part of stack in use */
+}
+
+
+void luaD_shrinkstack (lua_State *L) {
+  int inuse = stackinuse(L);
+  int goodsize = inuse + (inuse / 8) + 2*EXTRA_STACK;
+  if (goodsize > LUAI_MAXSTACK) goodsize = LUAI_MAXSTACK;
+  if (inuse > LUAI_MAXSTACK ||  /* handling stack overflow? */
+      goodsize >= L->stacksize)  /* would grow instead of shrink? */
+    condmovestack(L);  /* don't change stack (change only for debugging) */
+  else
+    luaD_reallocstack(L, goodsize);  /* shrink it */
+}
+
+
+void luaD_hook (lua_State *L, int event, int line) {
+  lua_Hook hook = L->hook;
+  if (hook && L->allowhook) {
+    CallInfo *ci = L->ci;
+    ptrdiff_t top = savestack(L, L->top);
+    ptrdiff_t ci_top = savestack(L, ci->top);
+    lua_Debug ar;
+    ar.event = event;
+    ar.currentline = line;
+    ar.i_ci = ci;
+    luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */
+    ci->top = L->top + LUA_MINSTACK;
+    lua_assert(ci->top <= L->stack_last);
+    L->allowhook = 0;  /* cannot call hooks inside a hook */
+    ci->callstatus |= CIST_HOOKED;
+    lua_unlock(L);
+    (*hook)(L, &ar);
+    lua_lock(L);
+    lua_assert(!L->allowhook);
+    L->allowhook = 1;
+    ci->top = restorestack(L, ci_top);
+    L->top = restorestack(L, top);
+    ci->callstatus &= ~CIST_HOOKED;
+  }
+}
+
+
+static void callhook (lua_State *L, CallInfo *ci) {
+  int hook = LUA_HOOKCALL;
+  ci->u.l.savedpc++;  /* hooks assume 'pc' is already incremented */
+  if (isLua(ci->previous) &&
+      GET_OPCODE(*(ci->previous->u.l.savedpc - 1)) == OP_TAILCALL) {
+    ci->callstatus |= CIST_TAIL;
+    hook = LUA_HOOKTAILCALL;
+  }
+  luaD_hook(L, hook, -1);
+  ci->u.l.savedpc--;  /* correct 'pc' */
+}
+
+
+static StkId adjust_varargs (lua_State *L, Proto *p, int actual) {
+  int i;
+  int nfixargs = p->numparams;
+  StkId base, fixed;
+  lua_assert(actual >= nfixargs);
+  /* move fixed parameters to final position */
+  fixed = L->top - actual;  /* first fixed argument */
+  base = L->top;  /* final position of first argument */
+  for (i=0; i<nfixargs; i++) {
+    setobjs2s(L, L->top++, fixed + i);
+    setnilvalue(fixed + i);
+  }
+  return base;
+}
+
+
+static StkId tryfuncTM (lua_State *L, StkId func) {
+  const TValue *tm = luaT_gettmbyobj(L, func, TM_CALL);
+  StkId p;
+  ptrdiff_t funcr = savestack(L, func);
+  if (!ttisfunction(tm))
+    luaG_typeerror(L, func, "call");
+  /* Open a hole inside the stack at `func' */
+  for (p = L->top; p > func; p--) setobjs2s(L, p, p-1);
+  incr_top(L);
+  func = restorestack(L, funcr);  /* previous call may change stack */
+  setobj2s(L, func, tm);  /* tag method is the new function to be called */
+  return func;
+}
+
+
+
+#define next_ci(L) (L->ci = (L->ci->next ? L->ci->next : luaE_extendCI(L)))
+
+
+/*
+** returns true if function has been executed (C function)
+*/
+int luaD_precall (lua_State *L, StkId func, int nresults) {
+  lua_CFunction f;
+  CallInfo *ci;
+  int n;  /* number of arguments (Lua) or returns (C) */
+  ptrdiff_t funcr = savestack(L, func);
+  switch (ttype(func)) {
+    case LUA_TLCF:  /* light C function */
+      f = fvalue(func);
+      goto Cfunc;
+    case LUA_TCCL: {  /* C closure */
+      f = clCvalue(func)->f;
+     Cfunc:
+      luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */
+      ci = next_ci(L);  /* now 'enter' new function */
+      ci->nresults = nresults;
+      ci->func = restorestack(L, funcr);
+      ci->top = L->top + LUA_MINSTACK;
+      lua_assert(ci->top <= L->stack_last);
+      ci->callstatus = 0;
+      luaC_checkGC(L);  /* stack grow uses memory */
+      if (L->hookmask & LUA_MASKCALL)
+        luaD_hook(L, LUA_HOOKCALL, -1);
+      lua_unlock(L);
+      n = (*f)(L);  /* do the actual call */
+      lua_lock(L);
+      api_checknelems(L, n);
+      luaD_poscall(L, L->top - n);
+      return 1;
+    }
+    case LUA_TLCL: {  /* Lua function: prepare its call */
+      StkId base;
+      Proto *p = clLvalue(func)->p;
+      luaD_checkstack(L, p->maxstacksize);
+      func = restorestack(L, funcr);
+      n = cast_int(L->top - func) - 1;  /* number of real arguments */
+      for (; n < p->numparams; n++)
+        setnilvalue(L->top++);  /* complete missing arguments */
+      base = (!p->is_vararg) ? func + 1 : adjust_varargs(L, p, n);
+      ci = next_ci(L);  /* now 'enter' new function */
+      ci->nresults = nresults;
+      ci->func = func;
+      ci->u.l.base = base;
+      ci->top = base + p->maxstacksize;
+      lua_assert(ci->top <= L->stack_last);
+      ci->u.l.savedpc = p->code;  /* starting point */
+      ci->callstatus = CIST_LUA;
+      L->top = ci->top;
+      luaC_checkGC(L);  /* stack grow uses memory */
+      if (L->hookmask & LUA_MASKCALL)
+        callhook(L, ci);
+      return 0;
+    }
+    default: {  /* not a function */
+      func = tryfuncTM(L, func);  /* retry with 'function' tag method */
+      return luaD_precall(L, func, nresults);  /* now it must be a function */
+    }
+  }
+}
+
+
+int luaD_poscall (lua_State *L, StkId firstResult) {
+  StkId res;
+  int wanted, i;
+  CallInfo *ci = L->ci;
+  if (L->hookmask & (LUA_MASKRET | LUA_MASKLINE)) {
+    if (L->hookmask & LUA_MASKRET) {
+      ptrdiff_t fr = savestack(L, firstResult);  /* hook may change stack */
+      luaD_hook(L, LUA_HOOKRET, -1);
+      firstResult = restorestack(L, fr);
+    }
+    L->oldpc = ci->previous->u.l.savedpc;  /* 'oldpc' for caller function */
+  }
+  res = ci->func;  /* res == final position of 1st result */
+  wanted = ci->nresults;
+  L->ci = ci = ci->previous;  /* back to caller */
+  /* move results to correct place */
+  for (i = wanted; i != 0 && firstResult < L->top; i--)
+    setobjs2s(L, res++, firstResult++);
+  while (i-- > 0)
+    setnilvalue(res++);
+  L->top = res;
+  return (wanted - LUA_MULTRET);  /* 0 iff wanted == LUA_MULTRET */
+}
+
+
+/*
+** Call a function (C or Lua). The function to be called is at *func.
+** The arguments are on the stack, right after the function.
+** When returns, all the results are on the stack, starting at the original
+** function position.
+*/
+void luaD_call (lua_State *L, StkId func, int nResults, int allowyield) {
+  if (++L->nCcalls >= LUAI_MAXCCALLS) {
+    if (L->nCcalls == LUAI_MAXCCALLS)
+      luaG_runerror(L, "C stack overflow");
+    else if (L->nCcalls >= (LUAI_MAXCCALLS + (LUAI_MAXCCALLS>>3)))
+      luaD_throw(L, LUA_ERRERR);  /* error while handing stack error */
+  }
+  if (!allowyield) L->nny++;
+  if (!luaD_precall(L, func, nResults))  /* is a Lua function? */
+    luaV_execute(L);  /* call it */
+  if (!allowyield) L->nny--;
+  L->nCcalls--;
+}
+
+
+static void finishCcall (lua_State *L) {
+  CallInfo *ci = L->ci;
+  int n;
+  lua_assert(ci->u.c.k != NULL);  /* must have a continuation */
+  lua_assert(L->nny == 0);
+  if (ci->callstatus & CIST_YPCALL) {  /* was inside a pcall? */
+    ci->callstatus &= ~CIST_YPCALL;  /* finish 'lua_pcall' */
+    L->errfunc = ci->u.c.old_errfunc;
+  }
+  /* finish 'lua_callk'/'lua_pcall' */
+  adjustresults(L, ci->nresults);
+  /* call continuation function */
+  if (!(ci->callstatus & CIST_STAT))  /* no call status? */
+    ci->u.c.status = LUA_YIELD;  /* 'default' status */
+  lua_assert(ci->u.c.status != LUA_OK);
+  ci->callstatus = (ci->callstatus & ~(CIST_YPCALL | CIST_STAT)) | CIST_YIELDED;
+  lua_unlock(L);
+  n = (*ci->u.c.k)(L);
+  lua_lock(L);
+  api_checknelems(L, n);
+  /* finish 'luaD_precall' */
+  luaD_poscall(L, L->top - n);
+}
+
+
+static void unroll (lua_State *L, void *ud) {
+  UNUSED(ud);
+  for (;;) {
+    if (L->ci == &L->base_ci)  /* stack is empty? */
+      return;  /* coroutine finished normally */
+    if (!isLua(L->ci))  /* C function? */
+      finishCcall(L);
+    else {  /* Lua function */
+      luaV_finishOp(L);  /* finish interrupted instruction */
+      luaV_execute(L);  /* execute down to higher C 'boundary' */
+    }
+  }
+}
+
+
+/*
+** check whether thread has a suspended protected call
+*/
+static CallInfo *findpcall (lua_State *L) {
+  CallInfo *ci;
+  for (ci = L->ci; ci != NULL; ci = ci->previous) {  /* search for a pcall */
+    if (ci->callstatus & CIST_YPCALL)
+      return ci;
+  }
+  return NULL;  /* no pending pcall */
+}
+
+
+static int recover (lua_State *L, int status) {
+  StkId oldtop;
+  CallInfo *ci = findpcall(L);
+  if (ci == NULL) return 0;  /* no recovery point */
+  /* "finish" luaD_pcall */
+  oldtop = restorestack(L, ci->extra);
+  luaF_close(L, oldtop);
+  seterrorobj(L, status, oldtop);
+  L->ci = ci;
+  L->allowhook = ci->u.c.old_allowhook;
+  L->nny = 0;  /* should be zero to be yieldable */
+  luaD_shrinkstack(L);
+  L->errfunc = ci->u.c.old_errfunc;
+  ci->callstatus |= CIST_STAT;  /* call has error status */
+  ci->u.c.status = status;  /* (here it is) */
+  return 1;  /* continue running the coroutine */
+}
+
+
+/*
+** signal an error in the call to 'resume', not in the execution of the
+** coroutine itself. (Such errors should not be handled by any coroutine
+** error handler and should not kill the coroutine.)
+*/
+static l_noret resume_error (lua_State *L, const char *msg, StkId firstArg) {
+  L->top = firstArg;  /* remove args from the stack */
+  setsvalue2s(L, L->top, luaS_new(L, msg));  /* push error message */
+  api_incr_top(L);
+  luaD_throw(L, -1);  /* jump back to 'lua_resume' */
+}
+
+
+/*
+** do the work for 'lua_resume' in protected mode
+*/
+static void resume (lua_State *L, void *ud) {
+  int nCcalls = L->nCcalls;
+  StkId firstArg = cast(StkId, ud);
+  CallInfo *ci = L->ci;
+  if (nCcalls >= LUAI_MAXCCALLS)
+    resume_error(L, "C stack overflow", firstArg);
+  if (L->status == LUA_OK) {  /* may be starting a coroutine */
+    if (ci != &L->base_ci)  /* not in base level? */
+      resume_error(L, "cannot resume non-suspended coroutine", firstArg);
+    /* coroutine is in base level; start running it */
+    if (!luaD_precall(L, firstArg - 1, LUA_MULTRET))  /* Lua function? */
+      luaV_execute(L);  /* call it */
+  }
+  else if (L->status != LUA_YIELD)
+    resume_error(L, "cannot resume dead coroutine", firstArg);
+  else {  /* resuming from previous yield */
+    L->status = LUA_OK;
+    ci->func = restorestack(L, ci->extra);
+    if (isLua(ci))  /* yielded inside a hook? */
+      luaV_execute(L);  /* just continue running Lua code */
+    else {  /* 'common' yield */
+      if (ci->u.c.k != NULL) {  /* does it have a continuation? */
+        int n;
+        ci->u.c.status = LUA_YIELD;  /* 'default' status */
+        ci->callstatus |= CIST_YIELDED;
+        lua_unlock(L);
+        n = (*ci->u.c.k)(L);  /* call continuation */
+        lua_lock(L);
+        api_checknelems(L, n);
+        firstArg = L->top - n;  /* yield results come from continuation */
+      }
+      luaD_poscall(L, firstArg);  /* finish 'luaD_precall' */
+    }
+    unroll(L, NULL);
+  }
+  lua_assert(nCcalls == L->nCcalls);
+}
+
+
+LUA_API int lua_resume (lua_State *L, lua_State *from, int nargs) {
+  int status;
+  lua_lock(L);
+  luai_userstateresume(L, nargs);
+  L->nCcalls = (from) ? from->nCcalls + 1 : 1;
+  L->nny = 0;  /* allow yields */
+  api_checknelems(L, (L->status == LUA_OK) ? nargs + 1 : nargs);
+  status = luaD_rawrunprotected(L, resume, L->top - nargs);
+  if (status == -1)  /* error calling 'lua_resume'? */
+    status = LUA_ERRRUN;
+  else {  /* yield or regular error */
+    while (status != LUA_OK && status != LUA_YIELD) {  /* error? */
+      if (recover(L, status))  /* recover point? */
+        status = luaD_rawrunprotected(L, unroll, NULL);  /* run continuation */
+      else {  /* unrecoverable error */
+        L->status = cast_byte(status);  /* mark thread as `dead' */
+        seterrorobj(L, status, L->top);
+        L->ci->top = L->top;
+        break;
+      }
+    }
+    lua_assert(status == L->status);
+  }
+  L->nny = 1;  /* do not allow yields */
+  L->nCcalls--;
+  lua_assert(L->nCcalls == ((from) ? from->nCcalls : 0));
+  lua_unlock(L);
+  return status;
+}
+
+
+LUA_API int lua_yieldk (lua_State *L, int nresults, int ctx, lua_CFunction k) {
+  CallInfo *ci = L->ci;
+  luai_userstateyield(L, nresults);
+  lua_lock(L);
+  api_checknelems(L, nresults);
+  if (L->nny > 0) {
+    if (L != G(L)->mainthread)
+      luaG_runerror(L, "attempt to yield across a C-call boundary");
+    else
+      luaG_runerror(L, "attempt to yield from outside a coroutine");
+  }
+  L->status = LUA_YIELD;
+  ci->extra = savestack(L, ci->func);  /* save current 'func' */
+  if (isLua(ci)) {  /* inside a hook? */
+    api_check(L, k == NULL, "hooks cannot continue after yielding");
+  }
+  else {
+    if ((ci->u.c.k = k) != NULL)  /* is there a continuation? */
+      ci->u.c.ctx = ctx;  /* save context */
+    ci->func = L->top - nresults - 1;  /* protect stack below results */
+    luaD_throw(L, LUA_YIELD);
+  }
+  lua_assert(ci->callstatus & CIST_HOOKED);  /* must be inside a hook */
+  lua_unlock(L);
+  return 0;  /* return to 'luaD_hook' */
+}
+
+
+int luaD_pcall (lua_State *L, Pfunc func, void *u,
+                ptrdiff_t old_top, ptrdiff_t ef) {
+  int status;
+  CallInfo *old_ci = L->ci;
+  lu_byte old_allowhooks = L->allowhook;
+  unsigned short old_nny = L->nny;
+  ptrdiff_t old_errfunc = L->errfunc;
+  L->errfunc = ef;
+  status = luaD_rawrunprotected(L, func, u);
+  if (status != LUA_OK) {  /* an error occurred? */
+    StkId oldtop = restorestack(L, old_top);
+    luaF_close(L, oldtop);  /* close possible pending closures */
+    seterrorobj(L, status, oldtop);
+    L->ci = old_ci;
+    L->allowhook = old_allowhooks;
+    L->nny = old_nny;
+    luaD_shrinkstack(L);
+  }
+  L->errfunc = old_errfunc;
+  return status;
+}
+
+
+
+/*
+** Execute a protected parser.
+*/
+struct SParser {  /* data to `f_parser' */
+  ZIO *z;
+  Mbuffer buff;  /* dynamic structure used by the scanner */
+  Dyndata dyd;  /* dynamic structures used by the parser */
+  const char *mode;
+  const char *name;
+};
+
+
+static void checkmode (lua_State *L, const char *mode, const char *x) {
+  if (mode && strchr(mode, x[0]) == NULL) {
+    luaO_pushfstring(L,
+       "attempt to load a %s chunk (mode is " LUA_QS ")", x, mode);
+    luaD_throw(L, LUA_ERRSYNTAX);
+  }
+}
+
+
+static void f_parser (lua_State *L, void *ud) {
+  int i;
+  Closure *cl;
+  struct SParser *p = cast(struct SParser *, ud);
+  int c = zgetc(p->z);  /* read first character */
+  if (c == LUA_SIGNATURE[0]) {
+    checkmode(L, p->mode, "binary");
+    cl = luaU_undump(L, p->z, &p->buff, p->name);
+  }
+  else {
+    checkmode(L, p->mode, "text");
+    cl = luaY_parser(L, p->z, &p->buff, &p->dyd, p->name, c);
+  }
+  lua_assert(cl->l.nupvalues == cl->l.p->sizeupvalues);
+  for (i = 0; i < cl->l.nupvalues; i++) {  /* initialize upvalues */
+    UpVal *up = luaF_newupval(L);
+    cl->l.upvals[i] = up;
+    luaC_objbarrier(L, cl, up);
+  }
+}
+
+
+int luaD_protectedparser (lua_State *L, ZIO *z, const char *name,
+                                        const char *mode) {
+  struct SParser p;
+  int status;
+  L->nny++;  /* cannot yield during parsing */
+  p.z = z; p.name = name; p.mode = mode;
+  p.dyd.actvar.arr = NULL; p.dyd.actvar.size = 0;
+  p.dyd.gt.arr = NULL; p.dyd.gt.size = 0;
+  p.dyd.label.arr = NULL; p.dyd.label.size = 0;
+  luaZ_initbuffer(L, &p.buff);
+  status = luaD_pcall(L, f_parser, &p, savestack(L, L->top), L->errfunc);
+  luaZ_freebuffer(L, &p.buff);
+  luaM_freearray(L, p.dyd.actvar.arr, p.dyd.actvar.size);
+  luaM_freearray(L, p.dyd.gt.arr, p.dyd.gt.size);
+  luaM_freearray(L, p.dyd.label.arr, p.dyd.label.size);
+  L->nny--;
+  return status;
+}
+
+
diff -ruNp src.hd/libs/lua/ldo.h src/libs/lua/ldo.h
--- src.hd/libs/lua/ldo.h	1969-12-31 16:00:00 -0800
+++ src/libs/lua/ldo.h	2017-12-29 00:57:40 -0800
@@ -0,0 +1,46 @@
+/*
+** $Id: ldo.h,v 2.20 2011/11/29 15:55:08 roberto Exp $
+** Stack and Call structure of Lua
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ldo_h
+#define ldo_h
+
+
+#include "lobject.h"
+#include "lstate.h"
+#include "lzio.h"
+
+
+#define luaD_checkstack(L,n)	if (L->stack_last - L->top <= (n)) \
+				    luaD_growstack(L, n); else condmovestack(L);
+
+
+#define incr_top(L) {L->top++; luaD_checkstack(L,0);}
+
+#define savestack(L,p)		((char *)(p) - (char *)L->stack)
+#define restorestack(L,n)	((TValue *)((char *)L->stack + (n)))
+
+
+/* type of protected functions, to be ran by `runprotected' */
+typedef void (*Pfunc) (lua_State *L, void *ud);
+
+LUAI_FUNC int luaD_protectedparser (lua_State *L, ZIO *z, const char *name,
+                                                  const char *mode);
+LUAI_FUNC void luaD_hook (lua_State *L, int event, int line);
+LUAI_FUNC int luaD_precall (lua_State *L, StkId func, int nresults);
+LUAI_FUNC void luaD_call (lua_State *L, StkId func, int nResults,
+                                        int allowyield);
+LUAI_FUNC int luaD_pcall (lua_State *L, Pfunc func, void *u,
+                                        ptrdiff_t oldtop, ptrdiff_t ef);
+LUAI_FUNC int luaD_poscall (lua_State *L, StkId firstResult);
+LUAI_FUNC void luaD_reallocstack (lua_State *L, int newsize);
+LUAI_FUNC void luaD_growstack (lua_State *L, int n);
+LUAI_FUNC void luaD_shrinkstack (lua_State *L);
+
+LUAI_FUNC l_noret luaD_throw (lua_State *L, int errcode);
+LUAI_FUNC int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud);
+
+#endif
+
diff -ruNp src.hd/libs/lua/ldump.c src/libs/lua/ldump.c
--- src.hd/libs/lua/ldump.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/ldump.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,173 @@
+/*
+** $Id: ldump.c,v 2.17 2012/01/23 23:02:10 roberto Exp $
+** save precompiled Lua chunks
+** See Copyright Notice in lua.h
+*/
+
+#include <stddef.h>
+
+#define ldump_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lobject.h"
+#include "lstate.h"
+#include "lundump.h"
+
+typedef struct {
+ lua_State* L;
+ lua_Writer writer;
+ void* data;
+ int strip;
+ int status;
+} DumpState;
+
+#define DumpMem(b,n,size,D)	DumpBlock(b,(n)*(size),D)
+#define DumpVar(x,D)		DumpMem(&x,1,sizeof(x),D)
+
+static void DumpBlock(const void* b, size_t size, DumpState* D)
+{
+ if (D->status==0)
+ {
+  lua_unlock(D->L);
+  D->status=(*D->writer)(D->L,b,size,D->data);
+  lua_lock(D->L);
+ }
+}
+
+static void DumpChar(int y, DumpState* D)
+{
+ char x=(char)y;
+ DumpVar(x,D);
+}
+
+static void DumpInt(int x, DumpState* D)
+{
+ DumpVar(x,D);
+}
+
+static void DumpNumber(lua_Number x, DumpState* D)
+{
+ DumpVar(x,D);
+}
+
+static void DumpVector(const void* b, int n, size_t size, DumpState* D)
+{
+ DumpInt(n,D);
+ DumpMem(b,n,size,D);
+}
+
+static void DumpString(const TString* s, DumpState* D)
+{
+ if (s==NULL)
+ {
+  size_t size=0;
+  DumpVar(size,D);
+ }
+ else
+ {
+  size_t size=s->tsv.len+1;		/* include trailing '\0' */
+  DumpVar(size,D);
+  DumpBlock(getstr(s),size*sizeof(char),D);
+ }
+}
+
+#define DumpCode(f,D)	 DumpVector(f->code,f->sizecode,sizeof(Instruction),D)
+
+static void DumpFunction(const Proto* f, DumpState* D);
+
+static void DumpConstants(const Proto* f, DumpState* D)
+{
+ int i,n=f->sizek;
+ DumpInt(n,D);
+ for (i=0; i<n; i++)
+ {
+  const TValue* o=&f->k[i];
+  DumpChar(ttypenv(o),D);
+  switch (ttypenv(o))
+  {
+   case LUA_TNIL:
+	break;
+   case LUA_TBOOLEAN:
+	DumpChar(bvalue(o),D);
+	break;
+   case LUA_TNUMBER:
+	DumpNumber(nvalue(o),D);
+	break;
+   case LUA_TSTRING:
+	DumpString(rawtsvalue(o),D);
+	break;
+    default: lua_assert(0);
+  }
+ }
+ n=f->sizep;
+ DumpInt(n,D);
+ for (i=0; i<n; i++) DumpFunction(f->p[i],D);
+}
+
+static void DumpUpvalues(const Proto* f, DumpState* D)
+{
+ int i,n=f->sizeupvalues;
+ DumpInt(n,D);
+ for (i=0; i<n; i++)
+ {
+  DumpChar(f->upvalues[i].instack,D);
+  DumpChar(f->upvalues[i].idx,D);
+ }
+}
+
+static void DumpDebug(const Proto* f, DumpState* D)
+{
+ int i,n;
+ DumpString((D->strip) ? NULL : f->source,D);
+ n= (D->strip) ? 0 : f->sizelineinfo;
+ DumpVector(f->lineinfo,n,sizeof(int),D);
+ n= (D->strip) ? 0 : f->sizelocvars;
+ DumpInt(n,D);
+ for (i=0; i<n; i++)
+ {
+  DumpString(f->locvars[i].varname,D);
+  DumpInt(f->locvars[i].startpc,D);
+  DumpInt(f->locvars[i].endpc,D);
+ }
+ n= (D->strip) ? 0 : f->sizeupvalues;
+ DumpInt(n,D);
+ for (i=0; i<n; i++) DumpString(f->upvalues[i].name,D);
+}
+
+static void DumpFunction(const Proto* f, DumpState* D)
+{
+ DumpInt(f->linedefined,D);
+ DumpInt(f->lastlinedefined,D);
+ DumpChar(f->numparams,D);
+ DumpChar(f->is_vararg,D);
+ DumpChar(f->maxstacksize,D);
+ DumpCode(f,D);
+ DumpConstants(f,D);
+ DumpUpvalues(f,D);
+ DumpDebug(f,D);
+}
+
+static void DumpHeader(DumpState* D)
+{
+ lu_byte h[LUAC_HEADERSIZE];
+ luaU_header(h);
+ DumpBlock(h,LUAC_HEADERSIZE,D);
+}
+
+/*
+** dump Lua function as precompiled chunk
+*/
+int luaU_dump (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip)
+{
+ DumpState D;
+ D.L=L;
+ D.writer=w;
+ D.data=data;
+ D.strip=strip;
+ D.status=0;
+ DumpHeader(&D);
+ DumpFunction(f,&D);
+ return D.status;
+}
diff -ruNp src.hd/libs/lua/lfunc.c src/libs/lua/lfunc.c
--- src.hd/libs/lua/lfunc.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lfunc.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,161 @@
+/*
+** $Id: lfunc.c,v 2.30 2012/10/03 12:36:46 roberto Exp $
+** Auxiliary functions to manipulate prototypes and closures
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stddef.h>
+
+#define lfunc_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lfunc.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+
+
+
+Closure *luaF_newCclosure (lua_State *L, int n) {
+  Closure *c = &luaC_newobj(L, LUA_TCCL, sizeCclosure(n), NULL, 0)->cl;
+  c->c.nupvalues = cast_byte(n);
+  return c;
+}
+
+
+Closure *luaF_newLclosure (lua_State *L, int n) {
+  Closure *c = &luaC_newobj(L, LUA_TLCL, sizeLclosure(n), NULL, 0)->cl;
+  c->l.p = NULL;
+  c->l.nupvalues = cast_byte(n);
+  while (n--) c->l.upvals[n] = NULL;
+  return c;
+}
+
+
+UpVal *luaF_newupval (lua_State *L) {
+  UpVal *uv = &luaC_newobj(L, LUA_TUPVAL, sizeof(UpVal), NULL, 0)->uv;
+  uv->v = &uv->u.value;
+  setnilvalue(uv->v);
+  return uv;
+}
+
+
+UpVal *luaF_findupval (lua_State *L, StkId level) {
+  global_State *g = G(L);
+  GCObject **pp = &L->openupval;
+  UpVal *p;
+  UpVal *uv;
+  while (*pp != NULL && (p = gco2uv(*pp))->v >= level) {
+    GCObject *o = obj2gco(p);
+    lua_assert(p->v != &p->u.value);
+    lua_assert(!isold(o) || isold(obj2gco(L)));
+    if (p->v == level) {  /* found a corresponding upvalue? */
+      if (isdead(g, o))  /* is it dead? */
+        changewhite(o);  /* resurrect it */
+      return p;
+    }
+    pp = &p->next;
+  }
+  /* not found: create a new one */
+  uv = &luaC_newobj(L, LUA_TUPVAL, sizeof(UpVal), pp, 0)->uv;
+  uv->v = level;  /* current value lives in the stack */
+  uv->u.l.prev = &g->uvhead;  /* double link it in `uvhead' list */
+  uv->u.l.next = g->uvhead.u.l.next;
+  uv->u.l.next->u.l.prev = uv;
+  g->uvhead.u.l.next = uv;
+  lua_assert(uv->u.l.next->u.l.prev == uv && uv->u.l.prev->u.l.next == uv);
+  return uv;
+}
+
+
+static void unlinkupval (UpVal *uv) {
+  lua_assert(uv->u.l.next->u.l.prev == uv && uv->u.l.prev->u.l.next == uv);
+  uv->u.l.next->u.l.prev = uv->u.l.prev;  /* remove from `uvhead' list */
+  uv->u.l.prev->u.l.next = uv->u.l.next;
+}
+
+
+void luaF_freeupval (lua_State *L, UpVal *uv) {
+  if (uv->v != &uv->u.value)  /* is it open? */
+    unlinkupval(uv);  /* remove from open list */
+  luaM_free(L, uv);  /* free upvalue */
+}
+
+
+void luaF_close (lua_State *L, StkId level) {
+  UpVal *uv;
+  global_State *g = G(L);
+  while (L->openupval != NULL && (uv = gco2uv(L->openupval))->v >= level) {
+    GCObject *o = obj2gco(uv);
+    lua_assert(!isblack(o) && uv->v != &uv->u.value);
+    L->openupval = uv->next;  /* remove from `open' list */
+    if (isdead(g, o))
+      luaF_freeupval(L, uv);  /* free upvalue */
+    else {
+      unlinkupval(uv);  /* remove upvalue from 'uvhead' list */
+      setobj(L, &uv->u.value, uv->v);  /* move value to upvalue slot */
+      uv->v = &uv->u.value;  /* now current value lives here */
+      gch(o)->next = g->allgc;  /* link upvalue into 'allgc' list */
+      g->allgc = o;
+      luaC_checkupvalcolor(g, uv);
+    }
+  }
+}
+
+
+Proto *luaF_newproto (lua_State *L) {
+  Proto *f = &luaC_newobj(L, LUA_TPROTO, sizeof(Proto), NULL, 0)->p;
+  f->k = NULL;
+  f->sizek = 0;
+  f->p = NULL;
+  f->sizep = 0;
+  f->code = NULL;
+  f->cache = NULL;
+  f->sizecode = 0;
+  f->lineinfo = NULL;
+  f->sizelineinfo = 0;
+  f->upvalues = NULL;
+  f->sizeupvalues = 0;
+  f->numparams = 0;
+  f->is_vararg = 0;
+  f->maxstacksize = 0;
+  f->locvars = NULL;
+  f->sizelocvars = 0;
+  f->linedefined = 0;
+  f->lastlinedefined = 0;
+  f->source = NULL;
+  return f;
+}
+
+
+void luaF_freeproto (lua_State *L, Proto *f) {
+  luaM_freearray(L, f->code, f->sizecode);
+  luaM_freearray(L, f->p, f->sizep);
+  luaM_freearray(L, f->k, f->sizek);
+  luaM_freearray(L, f->lineinfo, f->sizelineinfo);
+  luaM_freearray(L, f->locvars, f->sizelocvars);
+  luaM_freearray(L, f->upvalues, f->sizeupvalues);
+  luaM_free(L, f);
+}
+
+
+/*
+** Look for n-th local variable at line `line' in function `func'.
+** Returns NULL if not found.
+*/
+const char *luaF_getlocalname (const Proto *f, int local_number, int pc) {
+  int i;
+  for (i = 0; i<f->sizelocvars && f->locvars[i].startpc <= pc; i++) {
+    if (pc < f->locvars[i].endpc) {  /* is variable active? */
+      local_number--;
+      if (local_number == 0)
+        return getstr(f->locvars[i].varname);
+    }
+  }
+  return NULL;  /* not found */
+}
+
diff -ruNp src.hd/libs/lua/lfunc.h src/libs/lua/lfunc.h
--- src.hd/libs/lua/lfunc.h	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lfunc.h	2017-12-29 00:57:40 -0800
@@ -0,0 +1,33 @@
+/*
+** $Id: lfunc.h,v 2.8 2012/05/08 13:53:33 roberto Exp $
+** Auxiliary functions to manipulate prototypes and closures
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lfunc_h
+#define lfunc_h
+
+
+#include "lobject.h"
+
+
+#define sizeCclosure(n)	(cast(int, sizeof(CClosure)) + \
+                         cast(int, sizeof(TValue)*((n)-1)))
+
+#define sizeLclosure(n)	(cast(int, sizeof(LClosure)) + \
+                         cast(int, sizeof(TValue *)*((n)-1)))
+
+
+LUAI_FUNC Proto *luaF_newproto (lua_State *L);
+LUAI_FUNC Closure *luaF_newCclosure (lua_State *L, int nelems);
+LUAI_FUNC Closure *luaF_newLclosure (lua_State *L, int nelems);
+LUAI_FUNC UpVal *luaF_newupval (lua_State *L);
+LUAI_FUNC UpVal *luaF_findupval (lua_State *L, StkId level);
+LUAI_FUNC void luaF_close (lua_State *L, StkId level);
+LUAI_FUNC void luaF_freeproto (lua_State *L, Proto *f);
+LUAI_FUNC void luaF_freeupval (lua_State *L, UpVal *uv);
+LUAI_FUNC const char *luaF_getlocalname (const Proto *func, int local_number,
+                                         int pc);
+
+
+#endif
diff -ruNp src.hd/libs/lua/lgc.c src/libs/lua/lgc.c
--- src.hd/libs/lua/lgc.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lgc.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,1213 @@
+/*
+** $Id: lgc.c,v 2.140 2013/03/16 21:10:18 roberto Exp $
+** Garbage Collector
+** See Copyright Notice in lua.h
+*/
+
+#include <string.h>
+
+#define lgc_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+
+
+
+/*
+** cost of sweeping one element (the size of a small object divided
+** by some adjust for the sweep speed)
+*/
+#define GCSWEEPCOST	((sizeof(TString) + 4) / 4)
+
+/* maximum number of elements to sweep in each single step */
+#define GCSWEEPMAX	(cast_int((GCSTEPSIZE / GCSWEEPCOST) / 4))
+
+/* maximum number of finalizers to call in each GC step */
+#define GCFINALIZENUM	4
+
+
+/*
+** macro to adjust 'stepmul': 'stepmul' is actually used like
+** 'stepmul / STEPMULADJ' (value chosen by tests)
+*/
+#define STEPMULADJ		200
+
+
+/*
+** macro to adjust 'pause': 'pause' is actually used like
+** 'pause / PAUSEADJ' (value chosen by tests)
+*/
+#define PAUSEADJ		100
+
+
+/*
+** 'makewhite' erases all color bits plus the old bit and then
+** sets only the current white bit
+*/
+#define maskcolors	(~(bit2mask(BLACKBIT, OLDBIT) | WHITEBITS))
+#define makewhite(g,x)	\
+ (gch(x)->marked = cast_byte((gch(x)->marked & maskcolors) | luaC_white(g)))
+
+#define white2gray(x)	resetbits(gch(x)->marked, WHITEBITS)
+#define black2gray(x)	resetbit(gch(x)->marked, BLACKBIT)
+
+
+#define isfinalized(x)		testbit(gch(x)->marked, FINALIZEDBIT)
+
+#define checkdeadkey(n)	lua_assert(!ttisdeadkey(gkey(n)) || ttisnil(gval(n)))
+
+
+#define checkconsistency(obj)  \
+  lua_longassert(!iscollectable(obj) || righttt(obj))
+
+
+#define markvalue(g,o) { checkconsistency(o); \
+  if (valiswhite(o)) reallymarkobject(g,gcvalue(o)); }
+
+#define markobject(g,t) { if ((t) && iswhite(obj2gco(t))) \
+		reallymarkobject(g, obj2gco(t)); }
+
+static void reallymarkobject (global_State *g, GCObject *o);
+
+
+/*
+** {======================================================
+** Generic functions
+** =======================================================
+*/
+
+
+/*
+** one after last element in a hash array
+*/
+#define gnodelast(h)	gnode(h, cast(size_t, sizenode(h)))
+
+
+/*
+** link table 'h' into list pointed by 'p'
+*/
+#define linktable(h,p)	((h)->gclist = *(p), *(p) = obj2gco(h))
+
+
+/*
+** if key is not marked, mark its entry as dead (therefore removing it
+** from the table)
+*/
+static void removeentry (Node *n) {
+  lua_assert(ttisnil(gval(n)));
+  if (valiswhite(gkey(n)))
+    setdeadvalue(gkey(n));  /* unused and unmarked key; remove it */
+}
+
+
+/*
+** tells whether a key or value can be cleared from a weak
+** table. Non-collectable objects are never removed from weak
+** tables. Strings behave as `values', so are never removed too. for
+** other objects: if really collected, cannot keep them; for objects
+** being finalized, keep them in keys, but not in values
+*/
+static int iscleared (global_State *g, const TValue *o) {
+  if (!iscollectable(o)) return 0;
+  else if (ttisstring(o)) {
+    markobject(g, rawtsvalue(o));  /* strings are `values', so are never weak */
+    return 0;
+  }
+  else return iswhite(gcvalue(o));
+}
+
+
+/*
+** barrier that moves collector forward, that is, mark the white object
+** being pointed by a black object.
+*/
+void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {
+  global_State *g = G(L);
+  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));
+  lua_assert(g->gcstate != GCSpause);
+  lua_assert(gch(o)->tt != LUA_TTABLE);
+  if (keepinvariantout(g))  /* must keep invariant? */
+    reallymarkobject(g, v);  /* restore invariant */
+  else {  /* sweep phase */
+    lua_assert(issweepphase(g));
+    makewhite(g, o);  /* mark main obj. as white to avoid other barriers */
+  }
+}
+
+
+/*
+** barrier that moves collector backward, that is, mark the black object
+** pointing to a white object as gray again. (Current implementation
+** only works for tables; access to 'gclist' is not uniform across
+** different types.)
+*/
+void luaC_barrierback_ (lua_State *L, GCObject *o) {
+  global_State *g = G(L);
+  lua_assert(isblack(o) && !isdead(g, o) && gch(o)->tt == LUA_TTABLE);
+  black2gray(o);  /* make object gray (again) */
+  gco2t(o)->gclist = g->grayagain;
+  g->grayagain = o;
+}
+
+
+/*
+** barrier for prototypes. When creating first closure (cache is
+** NULL), use a forward barrier; this may be the only closure of the
+** prototype (if it is a "regular" function, with a single instance)
+** and the prototype may be big, so it is better to avoid traversing
+** it again. Otherwise, use a backward barrier, to avoid marking all
+** possible instances.
+*/
+LUAI_FUNC void luaC_barrierproto_ (lua_State *L, Proto *p, Closure *c) {
+  global_State *g = G(L);
+  lua_assert(isblack(obj2gco(p)));
+  if (p->cache == NULL) {  /* first time? */
+    luaC_objbarrier(L, p, c);
+  }
+  else {  /* use a backward barrier */
+    black2gray(obj2gco(p));  /* make prototype gray (again) */
+    p->gclist = g->grayagain;
+    g->grayagain = obj2gco(p);
+  }
+}
+
+
+/*
+** check color (and invariants) for an upvalue that was closed,
+** i.e., moved into the 'allgc' list
+*/
+void luaC_checkupvalcolor (global_State *g, UpVal *uv) {
+  GCObject *o = obj2gco(uv);
+  lua_assert(!isblack(o));  /* open upvalues are never black */
+  if (isgray(o)) {
+    if (keepinvariant(g)) {
+      resetoldbit(o);  /* see MOVE OLD rule */
+      gray2black(o);  /* it is being visited now */
+      markvalue(g, uv->v);
+    }
+    else {
+      lua_assert(issweepphase(g));
+      makewhite(g, o);
+    }
+  }
+}
+
+
+/*
+** create a new collectable object (with given type and size) and link
+** it to '*list'. 'offset' tells how many bytes to allocate before the
+** object itself (used only by states).
+*/
+GCObject *luaC_newobj (lua_State *L, int tt, size_t sz, GCObject **list,
+                       int offset) {
+  global_State *g = G(L);
+  char *raw = cast(char *, luaM_newobject(L, novariant(tt), sz));
+  GCObject *o = obj2gco(raw + offset);
+  if (list == NULL)
+    list = &g->allgc;  /* standard list for collectable objects */
+  gch(o)->marked = luaC_white(g);
+  gch(o)->tt = tt;
+  gch(o)->next = *list;
+  *list = o;
+  return o;
+}
+
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** Mark functions
+** =======================================================
+*/
+
+
+/*
+** mark an object. Userdata, strings, and closed upvalues are visited
+** and turned black here. Other objects are marked gray and added
+** to appropriate list to be visited (and turned black) later. (Open
+** upvalues are already linked in 'headuv' list.)
+*/
+static void reallymarkobject (global_State *g, GCObject *o) {
+  lu_mem size;
+  white2gray(o);
+  switch (gch(o)->tt) {
+    case LUA_TSHRSTR:
+    case LUA_TLNGSTR: {
+      size = sizestring(gco2ts(o));
+      break;  /* nothing else to mark; make it black */
+    }
+    case LUA_TUSERDATA: {
+      Table *mt = gco2u(o)->metatable;
+      markobject(g, mt);
+      markobject(g, gco2u(o)->env);
+      size = sizeudata(gco2u(o));
+      break;
+    }
+    case LUA_TUPVAL: {
+      UpVal *uv = gco2uv(o);
+      markvalue(g, uv->v);
+      if (uv->v != &uv->u.value)  /* open? */
+        return;  /* open upvalues remain gray */
+      size = sizeof(UpVal);
+      break;
+    }
+    case LUA_TLCL: {
+      gco2lcl(o)->gclist = g->gray;
+      g->gray = o;
+      return;
+    }
+    case LUA_TCCL: {
+      gco2ccl(o)->gclist = g->gray;
+      g->gray = o;
+      return;
+    }
+    case LUA_TTABLE: {
+      linktable(gco2t(o), &g->gray);
+      return;
+    }
+    case LUA_TTHREAD: {
+      gco2th(o)->gclist = g->gray;
+      g->gray = o;
+      return;
+    }
+    case LUA_TPROTO: {
+      gco2p(o)->gclist = g->gray;
+      g->gray = o;
+      return;
+    }
+    default: lua_assert(0); return;
+  }
+  gray2black(o);
+  g->GCmemtrav += size;
+}
+
+
+/*
+** mark metamethods for basic types
+*/
+static void markmt (global_State *g) {
+  int i;
+  for (i=0; i < LUA_NUMTAGS; i++)
+    markobject(g, g->mt[i]);
+}
+
+
+/*
+** mark all objects in list of being-finalized
+*/
+static void markbeingfnz (global_State *g) {
+  GCObject *o;
+  for (o = g->tobefnz; o != NULL; o = gch(o)->next) {
+    makewhite(g, o);
+    reallymarkobject(g, o);
+  }
+}
+
+
+/*
+** mark all values stored in marked open upvalues. (See comment in
+** 'lstate.h'.)
+*/
+static void remarkupvals (global_State *g) {
+  UpVal *uv;
+  for (uv = g->uvhead.u.l.next; uv != &g->uvhead; uv = uv->u.l.next) {
+    if (isgray(obj2gco(uv)))
+      markvalue(g, uv->v);
+  }
+}
+
+
+/*
+** mark root set and reset all gray lists, to start a new
+** incremental (or full) collection
+*/
+static void restartcollection (global_State *g) {
+  g->gray = g->grayagain = NULL;
+  g->weak = g->allweak = g->ephemeron = NULL;
+  markobject(g, g->mainthread);
+  markvalue(g, &g->l_registry);
+  markmt(g);
+  markbeingfnz(g);  /* mark any finalizing object left from previous cycle */
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Traverse functions
+** =======================================================
+*/
+
+static void traverseweakvalue (global_State *g, Table *h) {
+  Node *n, *limit = gnodelast(h);
+  /* if there is array part, assume it may have white values (do not
+     traverse it just to check) */
+  int hasclears = (h->sizearray > 0);
+  for (n = gnode(h, 0); n < limit; n++) {
+    checkdeadkey(n);
+    if (ttisnil(gval(n)))  /* entry is empty? */
+      removeentry(n);  /* remove it */
+    else {
+      lua_assert(!ttisnil(gkey(n)));
+      markvalue(g, gkey(n));  /* mark key */
+      if (!hasclears && iscleared(g, gval(n)))  /* is there a white value? */
+        hasclears = 1;  /* table will have to be cleared */
+    }
+  }
+  if (hasclears)
+    linktable(h, &g->weak);  /* has to be cleared later */
+  else  /* no white values */
+    linktable(h, &g->grayagain);  /* no need to clean */
+}
+
+
+static int traverseephemeron (global_State *g, Table *h) {
+  int marked = 0;  /* true if an object is marked in this traversal */
+  int hasclears = 0;  /* true if table has white keys */
+  int prop = 0;  /* true if table has entry "white-key -> white-value" */
+  Node *n, *limit = gnodelast(h);
+  int i;
+  /* traverse array part (numeric keys are 'strong') */
+  for (i = 0; i < h->sizearray; i++) {
+    if (valiswhite(&h->array[i])) {
+      marked = 1;
+      reallymarkobject(g, gcvalue(&h->array[i]));
+    }
+  }
+  /* traverse hash part */
+  for (n = gnode(h, 0); n < limit; n++) {
+    checkdeadkey(n);
+    if (ttisnil(gval(n)))  /* entry is empty? */
+      removeentry(n);  /* remove it */
+    else if (iscleared(g, gkey(n))) {  /* key is not marked (yet)? */
+      hasclears = 1;  /* table must be cleared */
+      if (valiswhite(gval(n)))  /* value not marked yet? */
+        prop = 1;  /* must propagate again */
+    }
+    else if (valiswhite(gval(n))) {  /* value not marked yet? */
+      marked = 1;
+      reallymarkobject(g, gcvalue(gval(n)));  /* mark it now */
+    }
+  }
+  if (prop)
+    linktable(h, &g->ephemeron);  /* have to propagate again */
+  else if (hasclears)  /* does table have white keys? */
+    linktable(h, &g->allweak);  /* may have to clean white keys */
+  else  /* no white keys */
+    linktable(h, &g->grayagain);  /* no need to clean */
+  return marked;
+}
+
+
+static void traversestrongtable (global_State *g, Table *h) {
+  Node *n, *limit = gnodelast(h);
+  int i;
+  for (i = 0; i < h->sizearray; i++)  /* traverse array part */
+    markvalue(g, &h->array[i]);
+  for (n = gnode(h, 0); n < limit; n++) {  /* traverse hash part */
+    checkdeadkey(n);
+    if (ttisnil(gval(n)))  /* entry is empty? */
+      removeentry(n);  /* remove it */
+    else {
+      lua_assert(!ttisnil(gkey(n)));
+      markvalue(g, gkey(n));  /* mark key */
+      markvalue(g, gval(n));  /* mark value */
+    }
+  }
+}
+
+
+static lu_mem traversetable (global_State *g, Table *h) {
+  const char *weakkey, *weakvalue;
+  const TValue *mode = gfasttm(g, h->metatable, TM_MODE);
+  markobject(g, h->metatable);
+  if (mode && ttisstring(mode) &&  /* is there a weak mode? */
+      ((weakkey = strchr(svalue(mode), 'k')),
+       (weakvalue = strchr(svalue(mode), 'v')),
+       (weakkey || weakvalue))) {  /* is really weak? */
+    black2gray(obj2gco(h));  /* keep table gray */
+    if (!weakkey)  /* strong keys? */
+      traverseweakvalue(g, h);
+    else if (!weakvalue)  /* strong values? */
+      traverseephemeron(g, h);
+    else  /* all weak */
+      linktable(h, &g->allweak);  /* nothing to traverse now */
+  }
+  else  /* not weak */
+    traversestrongtable(g, h);
+  return sizeof(Table) + sizeof(TValue) * h->sizearray +
+                         sizeof(Node) * cast(size_t, sizenode(h));
+}
+
+
+static int traverseproto (global_State *g, Proto *f) {
+  int i;
+  if (f->cache && iswhite(obj2gco(f->cache)))
+    f->cache = NULL;  /* allow cache to be collected */
+  markobject(g, f->source);
+  for (i = 0; i < f->sizek; i++)  /* mark literals */
+    markvalue(g, &f->k[i]);
+  for (i = 0; i < f->sizeupvalues; i++)  /* mark upvalue names */
+    markobject(g, f->upvalues[i].name);
+  for (i = 0; i < f->sizep; i++)  /* mark nested protos */
+    markobject(g, f->p[i]);
+  for (i = 0; i < f->sizelocvars; i++)  /* mark local-variable names */
+    markobject(g, f->locvars[i].varname);
+  return sizeof(Proto) + sizeof(Instruction) * f->sizecode +
+                         sizeof(Proto *) * f->sizep +
+                         sizeof(TValue) * f->sizek +
+                         sizeof(int) * f->sizelineinfo +
+                         sizeof(LocVar) * f->sizelocvars +
+                         sizeof(Upvaldesc) * f->sizeupvalues;
+}
+
+
+static lu_mem traverseCclosure (global_State *g, CClosure *cl) {
+  int i;
+  for (i = 0; i < cl->nupvalues; i++)  /* mark its upvalues */
+    markvalue(g, &cl->upvalue[i]);
+  return sizeCclosure(cl->nupvalues);
+}
+
+static lu_mem traverseLclosure (global_State *g, LClosure *cl) {
+  int i;
+  markobject(g, cl->p);  /* mark its prototype */
+  for (i = 0; i < cl->nupvalues; i++)  /* mark its upvalues */
+    markobject(g, cl->upvals[i]);
+  return sizeLclosure(cl->nupvalues);
+}
+
+
+static lu_mem traversestack (global_State *g, lua_State *th) {
+  StkId o = th->stack;
+  if (o == NULL)
+    return 1;  /* stack not completely built yet */
+  for (; o < th->top; o++)
+    markvalue(g, o);
+  if (g->gcstate == GCSatomic) {  /* final traversal? */
+    StkId lim = th->stack + th->stacksize;  /* real end of stack */
+    for (; o < lim; o++)  /* clear not-marked stack slice */
+      setnilvalue(o);
+  }
+  return sizeof(lua_State) + sizeof(TValue) * th->stacksize;
+}
+
+
+/*
+** traverse one gray object, turning it to black (except for threads,
+** which are always gray).
+*/
+static void propagatemark (global_State *g) {
+  lu_mem size;
+  GCObject *o = g->gray;
+  lua_assert(isgray(o));
+  gray2black(o);
+  switch (gch(o)->tt) {
+    case LUA_TTABLE: {
+      Table *h = gco2t(o);
+      g->gray = h->gclist;  /* remove from 'gray' list */
+      size = traversetable(g, h);
+      break;
+    }
+    case LUA_TLCL: {
+      LClosure *cl = gco2lcl(o);
+      g->gray = cl->gclist;  /* remove from 'gray' list */
+      size = traverseLclosure(g, cl);
+      break;
+    }
+    case LUA_TCCL: {
+      CClosure *cl = gco2ccl(o);
+      g->gray = cl->gclist;  /* remove from 'gray' list */
+      size = traverseCclosure(g, cl);
+      break;
+    }
+    case LUA_TTHREAD: {
+      lua_State *th = gco2th(o);
+      g->gray = th->gclist;  /* remove from 'gray' list */
+      th->gclist = g->grayagain;
+      g->grayagain = o;  /* insert into 'grayagain' list */
+      black2gray(o);
+      size = traversestack(g, th);
+      break;
+    }
+    case LUA_TPROTO: {
+      Proto *p = gco2p(o);
+      g->gray = p->gclist;  /* remove from 'gray' list */
+      size = traverseproto(g, p);
+      break;
+    }
+    default: lua_assert(0); return;
+  }
+  g->GCmemtrav += size;
+}
+
+
+static void propagateall (global_State *g) {
+  while (g->gray) propagatemark(g);
+}
+
+
+static void propagatelist (global_State *g, GCObject *l) {
+  lua_assert(g->gray == NULL);  /* no grays left */
+  g->gray = l;
+  propagateall(g);  /* traverse all elements from 'l' */
+}
+
+/*
+** retraverse all gray lists. Because tables may be reinserted in other
+** lists when traversed, traverse the original lists to avoid traversing
+** twice the same table (which is not wrong, but inefficient)
+*/
+static void retraversegrays (global_State *g) {
+  GCObject *weak = g->weak;  /* save original lists */
+  GCObject *grayagain = g->grayagain;
+  GCObject *ephemeron = g->ephemeron;
+  g->weak = g->grayagain = g->ephemeron = NULL;
+  propagateall(g);  /* traverse main gray list */
+  propagatelist(g, grayagain);
+  propagatelist(g, weak);
+  propagatelist(g, ephemeron);
+}
+
+
+static void convergeephemerons (global_State *g) {
+  int changed;
+  do {
+    GCObject *w;
+    GCObject *next = g->ephemeron;  /* get ephemeron list */
+    g->ephemeron = NULL;  /* tables will return to this list when traversed */
+    changed = 0;
+    while ((w = next) != NULL) {
+      next = gco2t(w)->gclist;
+      if (traverseephemeron(g, gco2t(w))) {  /* traverse marked some value? */
+        propagateall(g);  /* propagate changes */
+        changed = 1;  /* will have to revisit all ephemeron tables */
+      }
+    }
+  } while (changed);
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Sweep Functions
+** =======================================================
+*/
+
+
+/*
+** clear entries with unmarked keys from all weaktables in list 'l' up
+** to element 'f'
+*/
+static void clearkeys (global_State *g, GCObject *l, GCObject *f) {
+  for (; l != f; l = gco2t(l)->gclist) {
+    Table *h = gco2t(l);
+    Node *n, *limit = gnodelast(h);
+    for (n = gnode(h, 0); n < limit; n++) {
+      if (!ttisnil(gval(n)) && (iscleared(g, gkey(n)))) {
+        setnilvalue(gval(n));  /* remove value ... */
+        removeentry(n);  /* and remove entry from table */
+      }
+    }
+  }
+}
+
+
+/*
+** clear entries with unmarked values from all weaktables in list 'l' up
+** to element 'f'
+*/
+static void clearvalues (global_State *g, GCObject *l, GCObject *f) {
+  for (; l != f; l = gco2t(l)->gclist) {
+    Table *h = gco2t(l);
+    Node *n, *limit = gnodelast(h);
+    int i;
+    for (i = 0; i < h->sizearray; i++) {
+      TValue *o = &h->array[i];
+      if (iscleared(g, o))  /* value was collected? */
+        setnilvalue(o);  /* remove value */
+    }
+    for (n = gnode(h, 0); n < limit; n++) {
+      if (!ttisnil(gval(n)) && iscleared(g, gval(n))) {
+        setnilvalue(gval(n));  /* remove value ... */
+        removeentry(n);  /* and remove entry from table */
+      }
+    }
+  }
+}
+
+
+static void freeobj (lua_State *L, GCObject *o) {
+  switch (gch(o)->tt) {
+    case LUA_TPROTO: luaF_freeproto(L, gco2p(o)); break;
+    case LUA_TLCL: {
+      luaM_freemem(L, o, sizeLclosure(gco2lcl(o)->nupvalues));
+      break;
+    }
+    case LUA_TCCL: {
+      luaM_freemem(L, o, sizeCclosure(gco2ccl(o)->nupvalues));
+      break;
+    }
+    case LUA_TUPVAL: luaF_freeupval(L, gco2uv(o)); break;
+    case LUA_TTABLE: luaH_free(L, gco2t(o)); break;
+    case LUA_TTHREAD: luaE_freethread(L, gco2th(o)); break;
+    case LUA_TUSERDATA: luaM_freemem(L, o, sizeudata(gco2u(o))); break;
+    case LUA_TSHRSTR:
+      G(L)->strt.nuse--;
+      /* go through */
+    case LUA_TLNGSTR: {
+      luaM_freemem(L, o, sizestring(gco2ts(o)));
+      break;
+    }
+    default: lua_assert(0);
+  }
+}
+
+
+#define sweepwholelist(L,p)	sweeplist(L,p,MAX_LUMEM)
+static GCObject **sweeplist (lua_State *L, GCObject **p, lu_mem count);
+
+
+/*
+** sweep the (open) upvalues of a thread and resize its stack and
+** list of call-info structures.
+*/
+static void sweepthread (lua_State *L, lua_State *L1) {
+  if (L1->stack == NULL) return;  /* stack not completely built yet */
+  sweepwholelist(L, &L1->openupval);  /* sweep open upvalues */
+  luaE_freeCI(L1);  /* free extra CallInfo slots */
+  /* should not change the stack during an emergency gc cycle */
+  if (G(L)->gckind != KGC_EMERGENCY)
+    luaD_shrinkstack(L1);
+}
+
+
+/*
+** sweep at most 'count' elements from a list of GCObjects erasing dead
+** objects, where a dead (not alive) object is one marked with the "old"
+** (non current) white and not fixed.
+** In non-generational mode, change all non-dead objects back to white,
+** preparing for next collection cycle.
+** In generational mode, keep black objects black, and also mark them as
+** old; stop when hitting an old object, as all objects after that
+** one will be old too.
+** When object is a thread, sweep its list of open upvalues too.
+*/
+static GCObject **sweeplist (lua_State *L, GCObject **p, lu_mem count) {
+  global_State *g = G(L);
+  int ow = otherwhite(g);
+  int toclear, toset;  /* bits to clear and to set in all live objects */
+  int tostop;  /* stop sweep when this is true */
+  if (isgenerational(g)) {  /* generational mode? */
+    toclear = ~0;  /* clear nothing */
+    toset = bitmask(OLDBIT);  /* set the old bit of all surviving objects */
+    tostop = bitmask(OLDBIT);  /* do not sweep old generation */
+  }
+  else {  /* normal mode */
+    toclear = maskcolors;  /* clear all color bits + old bit */
+    toset = luaC_white(g);  /* make object white */
+    tostop = 0;  /* do not stop */
+  }
+  while (*p != NULL && count-- > 0) {
+    GCObject *curr = *p;
+    int marked = gch(curr)->marked;
+    if (isdeadm(ow, marked)) {  /* is 'curr' dead? */
+      *p = gch(curr)->next;  /* remove 'curr' from list */
+      freeobj(L, curr);  /* erase 'curr' */
+    }
+    else {
+      if (testbits(marked, tostop))
+        return NULL;  /* stop sweeping this list */
+      if (gch(curr)->tt == LUA_TTHREAD)
+        sweepthread(L, gco2th(curr));  /* sweep thread's upvalues */
+      /* update marks */
+      gch(curr)->marked = cast_byte((marked & toclear) | toset);
+      p = &gch(curr)->next;  /* go to next element */
+    }
+  }
+  return (*p == NULL) ? NULL : p;
+}
+
+
+/*
+** sweep a list until a live object (or end of list)
+*/
+static GCObject **sweeptolive (lua_State *L, GCObject **p, int *n) {
+  GCObject ** old = p;
+  int i = 0;
+  do {
+    i++;
+    p = sweeplist(L, p, 1);
+  } while (p == old);
+  if (n) *n += i;
+  return p;
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Finalization
+** =======================================================
+*/
+
+static void checkSizes (lua_State *L) {
+  global_State *g = G(L);
+  if (g->gckind != KGC_EMERGENCY) {  /* do not change sizes in emergency */
+    int hs = g->strt.size / 2;  /* half the size of the string table */
+    if (g->strt.nuse < cast(lu_int32, hs))  /* using less than that half? */
+      luaS_resize(L, hs);  /* halve its size */
+    luaZ_freebuffer(L, &g->buff);  /* free concatenation buffer */
+  }
+}
+
+
+static GCObject *udata2finalize (global_State *g) {
+  GCObject *o = g->tobefnz;  /* get first element */
+  lua_assert(isfinalized(o));
+  g->tobefnz = gch(o)->next;  /* remove it from 'tobefnz' list */
+  gch(o)->next = g->allgc;  /* return it to 'allgc' list */
+  g->allgc = o;
+  resetbit(gch(o)->marked, SEPARATED);  /* mark that it is not in 'tobefnz' */
+  lua_assert(!isold(o));  /* see MOVE OLD rule */
+  if (!keepinvariantout(g))  /* not keeping invariant? */
+    makewhite(g, o);  /* "sweep" object */
+  return o;
+}
+
+
+static void dothecall (lua_State *L, void *ud) {
+  UNUSED(ud);
+  luaD_call(L, L->top - 2, 0, 0);
+}
+
+
+static void GCTM (lua_State *L, int propagateerrors) {
+  global_State *g = G(L);
+  const TValue *tm;
+  TValue v;
+  setgcovalue(L, &v, udata2finalize(g));
+  tm = luaT_gettmbyobj(L, &v, TM_GC);
+  if (tm != NULL && ttisfunction(tm)) {  /* is there a finalizer? */
+    int status;
+    lu_byte oldah = L->allowhook;
+    int running  = g->gcrunning;
+    L->allowhook = 0;  /* stop debug hooks during GC metamethod */
+    g->gcrunning = 0;  /* avoid GC steps */
+    setobj2s(L, L->top, tm);  /* push finalizer... */
+    setobj2s(L, L->top + 1, &v);  /* ... and its argument */
+    L->top += 2;  /* and (next line) call the finalizer */
+    status = luaD_pcall(L, dothecall, NULL, savestack(L, L->top - 2), 0);
+    L->allowhook = oldah;  /* restore hooks */
+    g->gcrunning = running;  /* restore state */
+    if (status != LUA_OK && propagateerrors) {  /* error while running __gc? */
+      if (status == LUA_ERRRUN) {  /* is there an error object? */
+        const char *msg = (ttisstring(L->top - 1))
+                            ? svalue(L->top - 1)
+                            : "no message";
+        luaO_pushfstring(L, "error in __gc metamethod (%s)", msg);
+        status = LUA_ERRGCMM;  /* error in __gc metamethod */
+      }
+      luaD_throw(L, status);  /* re-throw error */
+    }
+  }
+}
+
+
+/*
+** move all unreachable objects (or 'all' objects) that need
+** finalization from list 'finobj' to list 'tobefnz' (to be finalized)
+*/
+static void separatetobefnz (lua_State *L, int all) {
+  global_State *g = G(L);
+  GCObject **p = &g->finobj;
+  GCObject *curr;
+  GCObject **lastnext = &g->tobefnz;
+  /* find last 'next' field in 'tobefnz' list (to add elements in its end) */
+  while (*lastnext != NULL)
+    lastnext = &gch(*lastnext)->next;
+  while ((curr = *p) != NULL) {  /* traverse all finalizable objects */
+    lua_assert(!isfinalized(curr));
+    lua_assert(testbit(gch(curr)->marked, SEPARATED));
+    if (!(iswhite(curr) || all))  /* not being collected? */
+      p = &gch(curr)->next;  /* don't bother with it */
+    else {
+      l_setbit(gch(curr)->marked, FINALIZEDBIT); /* won't be finalized again */
+      *p = gch(curr)->next;  /* remove 'curr' from 'finobj' list */
+      gch(curr)->next = *lastnext;  /* link at the end of 'tobefnz' list */
+      *lastnext = curr;
+      lastnext = &gch(curr)->next;
+    }
+  }
+}
+
+
+/*
+** if object 'o' has a finalizer, remove it from 'allgc' list (must
+** search the list to find it) and link it in 'finobj' list.
+*/
+void luaC_checkfinalizer (lua_State *L, GCObject *o, Table *mt) {
+  global_State *g = G(L);
+  if (testbit(gch(o)->marked, SEPARATED) || /* obj. is already separated... */
+      isfinalized(o) ||                           /* ... or is finalized... */
+      gfasttm(g, mt, TM_GC) == NULL)                /* or has no finalizer? */
+    return;  /* nothing to be done */
+  else {  /* move 'o' to 'finobj' list */
+    GCObject **p;
+    GCheader *ho = gch(o);
+    if (g->sweepgc == &ho->next) {  /* avoid removing current sweep object */
+      lua_assert(issweepphase(g));
+      g->sweepgc = sweeptolive(L, g->sweepgc, NULL);
+    }
+    /* search for pointer pointing to 'o' */
+    for (p = &g->allgc; *p != o; p = &gch(*p)->next) { /* empty */ }
+    *p = ho->next;  /* remove 'o' from root list */
+    ho->next = g->finobj;  /* link it in list 'finobj' */
+    g->finobj = o;
+    l_setbit(ho->marked, SEPARATED);  /* mark it as such */
+    if (!keepinvariantout(g))  /* not keeping invariant? */
+      makewhite(g, o);  /* "sweep" object */
+    else
+      resetoldbit(o);  /* see MOVE OLD rule */
+  }
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** GC control
+** =======================================================
+*/
+
+
+/*
+** set a reasonable "time" to wait before starting a new GC cycle;
+** cycle will start when memory use hits threshold
+*/
+static void setpause (global_State *g, l_mem estimate) {
+  l_mem debt, threshold;
+  estimate = estimate / PAUSEADJ;  /* adjust 'estimate' */
+  threshold = (g->gcpause < MAX_LMEM / estimate)  /* overflow? */
+            ? estimate * g->gcpause  /* no overflow */
+            : MAX_LMEM;  /* overflow; truncate to maximum */
+  debt = -cast(l_mem, threshold - gettotalbytes(g));
+  luaE_setdebt(g, debt);
+}
+
+
+#define sweepphases  \
+	(bitmask(GCSsweepstring) | bitmask(GCSsweepudata) | bitmask(GCSsweep))
+
+
+/*
+** enter first sweep phase (strings) and prepare pointers for other
+** sweep phases.  The calls to 'sweeptolive' make pointers point to an
+** object inside the list (instead of to the header), so that the real
+** sweep do not need to skip objects created between "now" and the start
+** of the real sweep.
+** Returns how many objects it swept.
+*/
+static int entersweep (lua_State *L) {
+  global_State *g = G(L);
+  int n = 0;
+  g->gcstate = GCSsweepstring;
+  lua_assert(g->sweepgc == NULL && g->sweepfin == NULL);
+  /* prepare to sweep strings, finalizable objects, and regular objects */
+  g->sweepstrgc = 0;
+  g->sweepfin = sweeptolive(L, &g->finobj, &n);
+  g->sweepgc = sweeptolive(L, &g->allgc, &n);
+  return n;
+}
+
+
+/*
+** change GC mode
+*/
+void luaC_changemode (lua_State *L, int mode) {
+  global_State *g = G(L);
+  if (mode == g->gckind) return;  /* nothing to change */
+  if (mode == KGC_GEN) {  /* change to generational mode */
+    /* make sure gray lists are consistent */
+    luaC_runtilstate(L, bitmask(GCSpropagate));
+    g->GCestimate = gettotalbytes(g);
+    g->gckind = KGC_GEN;
+  }
+  else {  /* change to incremental mode */
+    /* sweep all objects to turn them back to white
+       (as white has not changed, nothing extra will be collected) */
+    g->gckind = KGC_NORMAL;
+    entersweep(L);
+    luaC_runtilstate(L, ~sweepphases);
+  }
+}
+
+
+/*
+** call all pending finalizers
+*/
+static void callallpendingfinalizers (lua_State *L, int propagateerrors) {
+  global_State *g = G(L);
+  while (g->tobefnz) {
+    resetoldbit(g->tobefnz);
+    GCTM(L, propagateerrors);
+  }
+}
+
+
+void luaC_freeallobjects (lua_State *L) {
+  global_State *g = G(L);
+  int i;
+  separatetobefnz(L, 1);  /* separate all objects with finalizers */
+  lua_assert(g->finobj == NULL);
+  callallpendingfinalizers(L, 0);
+  g->currentwhite = WHITEBITS; /* this "white" makes all objects look dead */
+  g->gckind = KGC_NORMAL;
+  sweepwholelist(L, &g->finobj);  /* finalizers can create objs. in 'finobj' */
+  sweepwholelist(L, &g->allgc);
+  for (i = 0; i < g->strt.size; i++)  /* free all string lists */
+    sweepwholelist(L, &g->strt.hash[i]);
+  lua_assert(g->strt.nuse == 0);
+}
+
+
+static l_mem atomic (lua_State *L) {
+  global_State *g = G(L);
+  l_mem work = -cast(l_mem, g->GCmemtrav);  /* start counting work */
+  GCObject *origweak, *origall;
+  lua_assert(!iswhite(obj2gco(g->mainthread)));
+  markobject(g, L);  /* mark running thread */
+  /* registry and global metatables may be changed by API */
+  markvalue(g, &g->l_registry);
+  markmt(g);  /* mark basic metatables */
+  /* remark occasional upvalues of (maybe) dead threads */
+  remarkupvals(g);
+  propagateall(g);  /* propagate changes */
+  work += g->GCmemtrav;  /* stop counting (do not (re)count grays) */
+  /* traverse objects caught by write barrier and by 'remarkupvals' */
+  retraversegrays(g);
+  work -= g->GCmemtrav;  /* restart counting */
+  convergeephemerons(g);
+  /* at this point, all strongly accessible objects are marked. */
+  /* clear values from weak tables, before checking finalizers */
+  clearvalues(g, g->weak, NULL);
+  clearvalues(g, g->allweak, NULL);
+  origweak = g->weak; origall = g->allweak;
+  work += g->GCmemtrav;  /* stop counting (objects being finalized) */
+  separatetobefnz(L, 0);  /* separate objects to be finalized */
+  markbeingfnz(g);  /* mark objects that will be finalized */
+  propagateall(g);  /* remark, to propagate `preserveness' */
+  work -= g->GCmemtrav;  /* restart counting */
+  convergeephemerons(g);
+  /* at this point, all resurrected objects are marked. */
+  /* remove dead objects from weak tables */
+  clearkeys(g, g->ephemeron, NULL);  /* clear keys from all ephemeron tables */
+  clearkeys(g, g->allweak, NULL);  /* clear keys from all allweak tables */
+  /* clear values from resurrected weak tables */
+  clearvalues(g, g->weak, origweak);
+  clearvalues(g, g->allweak, origall);
+  g->currentwhite = cast_byte(otherwhite(g));  /* flip current white */
+  work += g->GCmemtrav;  /* complete counting */
+  return work;  /* estimate of memory marked by 'atomic' */
+}
+
+
+static lu_mem singlestep (lua_State *L) {
+  global_State *g = G(L);
+  switch (g->gcstate) {
+    case GCSpause: {
+      /* start to count memory traversed */
+      g->GCmemtrav = g->strt.size * sizeof(GCObject*);
+      lua_assert(!isgenerational(g));
+      restartcollection(g);
+      g->gcstate = GCSpropagate;
+      return g->GCmemtrav;
+    }
+    case GCSpropagate: {
+      if (g->gray) {
+        lu_mem oldtrav = g->GCmemtrav;
+        propagatemark(g);
+        return g->GCmemtrav - oldtrav;  /* memory traversed in this step */
+      }
+      else {  /* no more `gray' objects */
+        lu_mem work;
+        int sw;
+        g->gcstate = GCSatomic;  /* finish mark phase */
+        g->GCestimate = g->GCmemtrav;  /* save what was counted */;
+        work = atomic(L);  /* add what was traversed by 'atomic' */
+        g->GCestimate += work;  /* estimate of total memory traversed */ 
+        sw = entersweep(L);
+        return work + sw * GCSWEEPCOST;
+      }
+    }
+    case GCSsweepstring: {
+      int i;
+      for (i = 0; i < GCSWEEPMAX && g->sweepstrgc + i < g->strt.size; i++)
+        sweepwholelist(L, &g->strt.hash[g->sweepstrgc + i]);
+      g->sweepstrgc += i;
+      if (g->sweepstrgc >= g->strt.size)  /* no more strings to sweep? */
+        g->gcstate = GCSsweepudata;
+      return i * GCSWEEPCOST;
+    }
+    case GCSsweepudata: {
+      if (g->sweepfin) {
+        g->sweepfin = sweeplist(L, g->sweepfin, GCSWEEPMAX);
+        return GCSWEEPMAX*GCSWEEPCOST;
+      }
+      else {
+        g->gcstate = GCSsweep;
+        return 0;
+      }
+    }
+    case GCSsweep: {
+      if (g->sweepgc) {
+        g->sweepgc = sweeplist(L, g->sweepgc, GCSWEEPMAX);
+        return GCSWEEPMAX*GCSWEEPCOST;
+      }
+      else {
+        /* sweep main thread */
+        GCObject *mt = obj2gco(g->mainthread);
+        sweeplist(L, &mt, 1);
+        checkSizes(L);
+        g->gcstate = GCSpause;  /* finish collection */
+        return GCSWEEPCOST;
+      }
+    }
+    default: lua_assert(0); return 0;
+  }
+}
+
+
+/*
+** advances the garbage collector until it reaches a state allowed
+** by 'statemask'
+*/
+void luaC_runtilstate (lua_State *L, int statesmask) {
+  global_State *g = G(L);
+  while (!testbit(statesmask, g->gcstate))
+    singlestep(L);
+}
+
+
+static void generationalcollection (lua_State *L) {
+  global_State *g = G(L);
+  lua_assert(g->gcstate == GCSpropagate);
+  if (g->GCestimate == 0) {  /* signal for another major collection? */
+    luaC_fullgc(L, 0);  /* perform a full regular collection */
+    g->GCestimate = gettotalbytes(g);  /* update control */
+  }
+  else {
+    lu_mem estimate = g->GCestimate;
+    luaC_runtilstate(L, bitmask(GCSpause));  /* run complete (minor) cycle */
+    g->gcstate = GCSpropagate;  /* skip restart */
+    if (gettotalbytes(g) > (estimate / 100) * g->gcmajorinc)
+      g->GCestimate = 0;  /* signal for a major collection */
+    else
+      g->GCestimate = estimate;  /* keep estimate from last major coll. */
+
+  }
+  setpause(g, gettotalbytes(g));
+  lua_assert(g->gcstate == GCSpropagate);
+}
+
+
+static void incstep (lua_State *L) {
+  global_State *g = G(L);
+  l_mem debt = g->GCdebt;
+  int stepmul = g->gcstepmul;
+  if (stepmul < 40) stepmul = 40;  /* avoid ridiculous low values (and 0) */
+  /* convert debt from Kb to 'work units' (avoid zero debt and overflows) */
+  debt = (debt / STEPMULADJ) + 1;
+  debt = (debt < MAX_LMEM / stepmul) ? debt * stepmul : MAX_LMEM;
+  do {  /* always perform at least one single step */
+    lu_mem work = singlestep(L);  /* do some work */
+    debt -= work;
+  } while (debt > -GCSTEPSIZE && g->gcstate != GCSpause);
+  if (g->gcstate == GCSpause)
+    setpause(g, g->GCestimate);  /* pause until next cycle */
+  else {
+    debt = (debt / stepmul) * STEPMULADJ;  /* convert 'work units' to Kb */
+    luaE_setdebt(g, debt);
+  }
+}
+
+
+/*
+** performs a basic GC step
+*/
+void luaC_forcestep (lua_State *L) {
+  global_State *g = G(L);
+  int i;
+  if (isgenerational(g)) generationalcollection(L);
+  else incstep(L);
+  /* run a few finalizers (or all of them at the end of a collect cycle) */
+  for (i = 0; g->tobefnz && (i < GCFINALIZENUM || g->gcstate == GCSpause); i++)
+    GCTM(L, 1);  /* call one finalizer */
+}
+
+
+/*
+** performs a basic GC step only if collector is running
+*/
+void luaC_step (lua_State *L) {
+  global_State *g = G(L);
+  if (g->gcrunning) luaC_forcestep(L);
+  else luaE_setdebt(g, -GCSTEPSIZE);  /* avoid being called too often */
+}
+
+
+
+/*
+** performs a full GC cycle; if "isemergency", does not call
+** finalizers (which could change stack positions)
+*/
+void luaC_fullgc (lua_State *L, int isemergency) {
+  global_State *g = G(L);
+  int origkind = g->gckind;
+  lua_assert(origkind != KGC_EMERGENCY);
+  if (isemergency)  /* do not run finalizers during emergency GC */
+    g->gckind = KGC_EMERGENCY;
+  else {
+    g->gckind = KGC_NORMAL;
+    callallpendingfinalizers(L, 1);
+  }
+  if (keepinvariant(g)) {  /* may there be some black objects? */
+    /* must sweep all objects to turn them back to white
+       (as white has not changed, nothing will be collected) */
+    entersweep(L);
+  }
+  /* finish any pending sweep phase to start a new cycle */
+  luaC_runtilstate(L, bitmask(GCSpause));
+  luaC_runtilstate(L, ~bitmask(GCSpause));  /* start new collection */
+  luaC_runtilstate(L, bitmask(GCSpause));  /* run entire collection */
+  if (origkind == KGC_GEN) {  /* generational mode? */
+    /* generational mode must be kept in propagate phase */
+    luaC_runtilstate(L, bitmask(GCSpropagate));
+  }
+  g->gckind = origkind;
+  setpause(g, gettotalbytes(g));
+  if (!isemergency)   /* do not run finalizers during emergency GC */
+    callallpendingfinalizers(L, 1);
+}
+
+/* }====================================================== */
+
+
diff -ruNp src.hd/libs/lua/lgc.h src/libs/lua/lgc.h
--- src.hd/libs/lua/lgc.h	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lgc.h	2017-12-29 00:57:40 -0800
@@ -0,0 +1,157 @@
+/*
+** $Id: lgc.h,v 2.58 2012/09/11 12:53:08 roberto Exp $
+** Garbage Collector
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lgc_h
+#define lgc_h
+
+
+#include "lobject.h"
+#include "lstate.h"
+
+/*
+** Collectable objects may have one of three colors: white, which
+** means the object is not marked; gray, which means the
+** object is marked, but its references may be not marked; and
+** black, which means that the object and all its references are marked.
+** The main invariant of the garbage collector, while marking objects,
+** is that a black object can never point to a white one. Moreover,
+** any gray object must be in a "gray list" (gray, grayagain, weak,
+** allweak, ephemeron) so that it can be visited again before finishing
+** the collection cycle. These lists have no meaning when the invariant
+** is not being enforced (e.g., sweep phase).
+*/
+
+
+
+/* how much to allocate before next GC step */
+#if !defined(GCSTEPSIZE)
+/* ~100 small strings */
+#define GCSTEPSIZE	(cast_int(100 * sizeof(TString)))
+#endif
+
+
+/*
+** Possible states of the Garbage Collector
+*/
+#define GCSpropagate	0
+#define GCSatomic	1
+#define GCSsweepstring	2
+#define GCSsweepudata	3
+#define GCSsweep	4
+#define GCSpause	5
+
+
+#define issweepphase(g)  \
+	(GCSsweepstring <= (g)->gcstate && (g)->gcstate <= GCSsweep)
+
+#define isgenerational(g)	((g)->gckind == KGC_GEN)
+
+/*
+** macros to tell when main invariant (white objects cannot point to black
+** ones) must be kept. During a non-generational collection, the sweep
+** phase may break the invariant, as objects turned white may point to
+** still-black objects. The invariant is restored when sweep ends and
+** all objects are white again. During a generational collection, the
+** invariant must be kept all times.
+*/
+
+#define keepinvariant(g)	(isgenerational(g) || g->gcstate <= GCSatomic)
+
+
+/*
+** Outside the collector, the state in generational mode is kept in
+** 'propagate', so 'keepinvariant' is always true.
+*/
+#define keepinvariantout(g)  \
+  check_exp(g->gcstate == GCSpropagate || !isgenerational(g),  \
+            g->gcstate <= GCSatomic)
+
+
+/*
+** some useful bit tricks
+*/
+#define resetbits(x,m)		((x) &= cast(lu_byte, ~(m)))
+#define setbits(x,m)		((x) |= (m))
+#define testbits(x,m)		((x) & (m))
+#define bitmask(b)		(1<<(b))
+#define bit2mask(b1,b2)		(bitmask(b1) | bitmask(b2))
+#define l_setbit(x,b)		setbits(x, bitmask(b))
+#define resetbit(x,b)		resetbits(x, bitmask(b))
+#define testbit(x,b)		testbits(x, bitmask(b))
+
+
+/* Layout for bit use in `marked' field: */
+#define WHITE0BIT	0  /* object is white (type 0) */
+#define WHITE1BIT	1  /* object is white (type 1) */
+#define BLACKBIT	2  /* object is black */
+#define FINALIZEDBIT	3  /* object has been separated for finalization */
+#define SEPARATED	4  /* object is in 'finobj' list or in 'tobefnz' */
+#define FIXEDBIT	5  /* object is fixed (should not be collected) */
+#define OLDBIT		6  /* object is old (only in generational mode) */
+/* bit 7 is currently used by tests (luaL_checkmemory) */
+
+#define WHITEBITS	bit2mask(WHITE0BIT, WHITE1BIT)
+
+
+#define iswhite(x)      testbits((x)->gch.marked, WHITEBITS)
+#define isblack(x)      testbit((x)->gch.marked, BLACKBIT)
+#define isgray(x)  /* neither white nor black */  \
+	(!testbits((x)->gch.marked, WHITEBITS | bitmask(BLACKBIT)))
+
+#define isold(x)	testbit((x)->gch.marked, OLDBIT)
+
+/* MOVE OLD rule: whenever an object is moved to the beginning of
+   a GC list, its old bit must be cleared */
+#define resetoldbit(o)	resetbit((o)->gch.marked, OLDBIT)
+
+#define otherwhite(g)	(g->currentwhite ^ WHITEBITS)
+#define isdeadm(ow,m)	(!(((m) ^ WHITEBITS) & (ow)))
+#define isdead(g,v)	isdeadm(otherwhite(g), (v)->gch.marked)
+
+#define changewhite(x)	((x)->gch.marked ^= WHITEBITS)
+#define gray2black(x)	l_setbit((x)->gch.marked, BLACKBIT)
+
+#define valiswhite(x)	(iscollectable(x) && iswhite(gcvalue(x)))
+
+#define luaC_white(g)	cast(lu_byte, (g)->currentwhite & WHITEBITS)
+
+
+#define luaC_condGC(L,c) \
+	{if (G(L)->GCdebt > 0) {c;}; condchangemem(L);}
+#define luaC_checkGC(L)		luaC_condGC(L, luaC_step(L);)
+
+
+#define luaC_barrier(L,p,v) { if (valiswhite(v) && isblack(obj2gco(p)))  \
+	luaC_barrier_(L,obj2gco(p),gcvalue(v)); }
+
+#define luaC_barrierback(L,p,v) { if (valiswhite(v) && isblack(obj2gco(p)))  \
+	luaC_barrierback_(L,p); }
+
+#define luaC_objbarrier(L,p,o)  \
+	{ if (iswhite(obj2gco(o)) && isblack(obj2gco(p))) \
+		luaC_barrier_(L,obj2gco(p),obj2gco(o)); }
+
+#define luaC_objbarrierback(L,p,o)  \
+   { if (iswhite(obj2gco(o)) && isblack(obj2gco(p))) luaC_barrierback_(L,p); }
+
+#define luaC_barrierproto(L,p,c) \
+   { if (isblack(obj2gco(p))) luaC_barrierproto_(L,p,c); }
+
+LUAI_FUNC void luaC_freeallobjects (lua_State *L);
+LUAI_FUNC void luaC_step (lua_State *L);
+LUAI_FUNC void luaC_forcestep (lua_State *L);
+LUAI_FUNC void luaC_runtilstate (lua_State *L, int statesmask);
+LUAI_FUNC void luaC_fullgc (lua_State *L, int isemergency);
+LUAI_FUNC GCObject *luaC_newobj (lua_State *L, int tt, size_t sz,
+                                 GCObject **list, int offset);
+LUAI_FUNC void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v);
+LUAI_FUNC void luaC_barrierback_ (lua_State *L, GCObject *o);
+LUAI_FUNC void luaC_barrierproto_ (lua_State *L, Proto *p, Closure *c);
+LUAI_FUNC void luaC_checkfinalizer (lua_State *L, GCObject *o, Table *mt);
+LUAI_FUNC void luaC_checkupvalcolor (global_State *g, UpVal *uv);
+LUAI_FUNC void luaC_changemode (lua_State *L, int mode);
+
+#endif
diff -ruNp src.hd/libs/lua/linit.c src/libs/lua/linit.c
--- src.hd/libs/lua/linit.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/linit.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,67 @@
+/*
+** $Id: linit.c,v 1.32 2011/04/08 19:17:36 roberto Exp $
+** Initialization of libraries for lua.c and other clients
+** See Copyright Notice in lua.h
+*/
+
+
+/*
+** If you embed Lua in your program and need to open the standard
+** libraries, call luaL_openlibs in your program. If you need a
+** different set of libraries, copy this file to your project and edit
+** it to suit your needs.
+*/
+
+
+#define linit_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lualib.h"
+#include "lauxlib.h"
+
+
+/*
+** these libs are loaded by lua.c and are readily available to any Lua
+** program
+*/
+static const luaL_Reg loadedlibs[] = {
+  {"_G", luaopen_base},
+  {LUA_LOADLIBNAME, luaopen_package},
+  {LUA_COLIBNAME, luaopen_coroutine},
+  {LUA_TABLIBNAME, luaopen_table},
+  {LUA_IOLIBNAME, luaopen_io},
+  {LUA_OSLIBNAME, luaopen_os},
+  {LUA_STRLIBNAME, luaopen_string},
+  {LUA_BITLIBNAME, luaopen_bit32},
+  {LUA_MATHLIBNAME, luaopen_math},
+  {LUA_DBLIBNAME, luaopen_debug},
+  {NULL, NULL}
+};
+
+
+/*
+** these libs are preloaded and must be required before used
+*/
+static const luaL_Reg preloadedlibs[] = {
+  {NULL, NULL}
+};
+
+
+LUALIB_API void luaL_openlibs (lua_State *L) {
+  const luaL_Reg *lib;
+  /* call open functions from 'loadedlibs' and set results to global table */
+  for (lib = loadedlibs; lib->func; lib++) {
+    luaL_requiref(L, lib->name, lib->func, 1);
+    lua_pop(L, 1);  /* remove lib */
+  }
+  /* add open functions from 'preloadedlibs' into 'package.preload' table */
+  luaL_getsubtable(L, LUA_REGISTRYINDEX, "_PRELOAD");
+  for (lib = preloadedlibs; lib->func; lib++) {
+    lua_pushcfunction(L, lib->func);
+    lua_setfield(L, -2, lib->name);
+  }
+  lua_pop(L, 1);  /* remove _PRELOAD table */
+}
+
diff -ruNp src.hd/libs/lua/liolib.c src/libs/lua/liolib.c
--- src.hd/libs/lua/liolib.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/liolib.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,665 @@
+/*
+** $Id: liolib.c,v 2.111 2013/03/21 13:57:27 roberto Exp $
+** Standard I/O (and system) library
+** See Copyright Notice in lua.h
+*/
+
+
+/*
+** POSIX idiosyncrasy!
+** This definition must come before the inclusion of 'stdio.h'; it
+** should not affect non-POSIX systems
+*/
+#if !defined(_FILE_OFFSET_BITS)
+#define _FILE_OFFSET_BITS 64
+#endif
+
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define liolib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+#if !defined(lua_checkmode)
+
+/*
+** Check whether 'mode' matches '[rwa]%+?b?'.
+** Change this macro to accept other modes for 'fopen' besides
+** the standard ones.
+*/
+#define lua_checkmode(mode) \
+	(*mode != '\0' && strchr("rwa", *(mode++)) != NULL &&	\
+	(*mode != '+' || ++mode) &&  /* skip if char is '+' */	\
+	(*mode != 'b' || ++mode) &&  /* skip if char is 'b' */	\
+	(*mode == '\0'))
+
+#endif
+
+/*
+** {======================================================
+** lua_popen spawns a new process connected to the current
+** one through the file streams.
+** =======================================================
+*/
+
+#if !defined(lua_popen)	/* { */
+
+#if defined(LUA_USE_POPEN)	/* { */
+
+#define lua_popen(L,c,m)	((void)L, fflush(NULL), popen(c,m))
+#define lua_pclose(L,file)	((void)L, pclose(file))
+
+#elif defined(LUA_WIN)		/* }{ */
+
+#define lua_popen(L,c,m)		((void)L, _popen(c,m))
+#define lua_pclose(L,file)		((void)L, _pclose(file))
+
+
+#else				/* }{ */
+
+#define lua_popen(L,c,m)		((void)((void)c, m),  \
+		luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
+#define lua_pclose(L,file)		((void)((void)L, file), -1)
+
+
+#endif				/* } */
+
+#endif			/* } */
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** lua_fseek/lua_ftell: configuration for longer offsets
+** =======================================================
+*/
+
+#if !defined(lua_fseek)	/* { */
+
+#if defined(LUA_USE_POSIX)
+
+#define l_fseek(f,o,w)		fseeko(f,o,w)
+#define l_ftell(f)		ftello(f)
+#define l_seeknum		off_t
+
+#elif defined(LUA_WIN) && !defined(_CRTIMP_TYPEINFO) \
+   && defined(_MSC_VER) && (_MSC_VER >= 1400)
+/* Windows (but not DDK) and Visual C++ 2005 or higher */
+
+#define l_fseek(f,o,w)		_fseeki64(f,o,w)
+#define l_ftell(f)		_ftelli64(f)
+#define l_seeknum		__int64
+
+#else
+
+#define l_fseek(f,o,w)		fseek(f,o,w)
+#define l_ftell(f)		ftell(f)
+#define l_seeknum		long
+
+#endif
+
+#endif			/* } */
+
+/* }====================================================== */
+
+
+#define IO_PREFIX	"_IO_"
+#define IO_INPUT	(IO_PREFIX "input")
+#define IO_OUTPUT	(IO_PREFIX "output")
+
+
+typedef luaL_Stream LStream;
+
+
+#define tolstream(L)	((LStream *)luaL_checkudata(L, 1, LUA_FILEHANDLE))
+
+#define isclosed(p)	((p)->closef == NULL)
+
+
+static int io_type (lua_State *L) {
+  LStream *p;
+  luaL_checkany(L, 1);
+  p = (LStream *)luaL_testudata(L, 1, LUA_FILEHANDLE);
+  if (p == NULL)
+    lua_pushnil(L);  /* not a file */
+  else if (isclosed(p))
+    lua_pushliteral(L, "closed file");
+  else
+    lua_pushliteral(L, "file");
+  return 1;
+}
+
+
+static int f_tostring (lua_State *L) {
+  LStream *p = tolstream(L);
+  if (isclosed(p))
+    lua_pushliteral(L, "file (closed)");
+  else
+    lua_pushfstring(L, "file (%p)", p->f);
+  return 1;
+}
+
+
+static FILE *tofile (lua_State *L) {
+  LStream *p = tolstream(L);
+  if (isclosed(p))
+    luaL_error(L, "attempt to use a closed file");
+  lua_assert(p->f);
+  return p->f;
+}
+
+
+/*
+** When creating file handles, always creates a `closed' file handle
+** before opening the actual file; so, if there is a memory error, the
+** file is not left opened.
+*/
+static LStream *newprefile (lua_State *L) {
+  LStream *p = (LStream *)lua_newuserdata(L, sizeof(LStream));
+  p->closef = NULL;  /* mark file handle as 'closed' */
+  luaL_setmetatable(L, LUA_FILEHANDLE);
+  return p;
+}
+
+
+static int aux_close (lua_State *L) {
+  LStream *p = tolstream(L);
+  lua_CFunction cf = p->closef;
+  p->closef = NULL;  /* mark stream as closed */
+  return (*cf)(L);  /* close it */
+}
+
+
+static int io_close (lua_State *L) {
+  if (lua_isnone(L, 1))  /* no argument? */
+    lua_getfield(L, LUA_REGISTRYINDEX, IO_OUTPUT);  /* use standard output */
+  tofile(L);  /* make sure argument is an open stream */
+  return aux_close(L);
+}
+
+
+static int f_gc (lua_State *L) {
+  LStream *p = tolstream(L);
+  if (!isclosed(p) && p->f != NULL)
+    aux_close(L);  /* ignore closed and incompletely open files */
+  return 0;
+}
+
+
+/*
+** function to close regular files
+*/
+static int io_fclose (lua_State *L) {
+  LStream *p = tolstream(L);
+  int res = fclose(p->f);
+  return luaL_fileresult(L, (res == 0), NULL);
+}
+
+
+static LStream *newfile (lua_State *L) {
+  LStream *p = newprefile(L);
+  p->f = NULL;
+  p->closef = &io_fclose;
+  return p;
+}
+
+
+static void opencheck (lua_State *L, const char *fname, const char *mode) {
+  LStream *p = newfile(L);
+  p->f = fopen(fname, mode);
+  if (p->f == NULL)
+    luaL_error(L, "cannot open file " LUA_QS " (%s)", fname, strerror(errno));
+}
+
+
+static int io_open (lua_State *L) {
+  const char *filename = luaL_checkstring(L, 1);
+  const char *mode = luaL_optstring(L, 2, "r");
+  LStream *p = newfile(L);
+  const char *md = mode;  /* to traverse/check mode */
+  luaL_argcheck(L, lua_checkmode(md), 2, "invalid mode");
+  p->f = fopen(filename, mode);
+  return (p->f == NULL) ? luaL_fileresult(L, 0, filename) : 1;
+}
+
+
+/*
+** function to close 'popen' files
+*/
+static int io_pclose (lua_State *L) {
+  LStream *p = tolstream(L);
+  return luaL_execresult(L, lua_pclose(L, p->f));
+}
+
+
+static int io_popen (lua_State *L) {
+  const char *filename = luaL_checkstring(L, 1);
+  const char *mode = luaL_optstring(L, 2, "r");
+  LStream *p = newprefile(L);
+  p->f = lua_popen(L, filename, mode);
+  p->closef = &io_pclose;
+  return (p->f == NULL) ? luaL_fileresult(L, 0, filename) : 1;
+}
+
+
+static int io_tmpfile (lua_State *L) {
+  LStream *p = newfile(L);
+  p->f = tmpfile();
+  return (p->f == NULL) ? luaL_fileresult(L, 0, NULL) : 1;
+}
+
+
+static FILE *getiofile (lua_State *L, const char *findex) {
+  LStream *p;
+  lua_getfield(L, LUA_REGISTRYINDEX, findex);
+  p = (LStream *)lua_touserdata(L, -1);
+  if (isclosed(p))
+    luaL_error(L, "standard %s file is closed", findex + strlen(IO_PREFIX));
+  return p->f;
+}
+
+
+static int g_iofile (lua_State *L, const char *f, const char *mode) {
+  if (!lua_isnoneornil(L, 1)) {
+    const char *filename = lua_tostring(L, 1);
+    if (filename)
+      opencheck(L, filename, mode);
+    else {
+      tofile(L);  /* check that it's a valid file handle */
+      lua_pushvalue(L, 1);
+    }
+    lua_setfield(L, LUA_REGISTRYINDEX, f);
+  }
+  /* return current value */
+  lua_getfield(L, LUA_REGISTRYINDEX, f);
+  return 1;
+}
+
+
+static int io_input (lua_State *L) {
+  return g_iofile(L, IO_INPUT, "r");
+}
+
+
+static int io_output (lua_State *L) {
+  return g_iofile(L, IO_OUTPUT, "w");
+}
+
+
+static int io_readline (lua_State *L);
+
+
+static void aux_lines (lua_State *L, int toclose) {
+  int i;
+  int n = lua_gettop(L) - 1;  /* number of arguments to read */
+  /* ensure that arguments will fit here and into 'io_readline' stack */
+  luaL_argcheck(L, n <= LUA_MINSTACK - 3, LUA_MINSTACK - 3, "too many options");
+  lua_pushvalue(L, 1);  /* file handle */
+  lua_pushinteger(L, n);  /* number of arguments to read */
+  lua_pushboolean(L, toclose);  /* close/not close file when finished */
+  for (i = 1; i <= n; i++) lua_pushvalue(L, i + 1);  /* copy arguments */
+  lua_pushcclosure(L, io_readline, 3 + n);
+}
+
+
+static int f_lines (lua_State *L) {
+  tofile(L);  /* check that it's a valid file handle */
+  aux_lines(L, 0);
+  return 1;
+}
+
+
+static int io_lines (lua_State *L) {
+  int toclose;
+  if (lua_isnone(L, 1)) lua_pushnil(L);  /* at least one argument */
+  if (lua_isnil(L, 1)) {  /* no file name? */
+    lua_getfield(L, LUA_REGISTRYINDEX, IO_INPUT);  /* get default input */
+    lua_replace(L, 1);  /* put it at index 1 */
+    tofile(L);  /* check that it's a valid file handle */
+    toclose = 0;  /* do not close it after iteration */
+  }
+  else {  /* open a new file */
+    const char *filename = luaL_checkstring(L, 1);
+    opencheck(L, filename, "r");
+    lua_replace(L, 1);  /* put file at index 1 */
+    toclose = 1;  /* close it after iteration */
+  }
+  aux_lines(L, toclose);
+  return 1;
+}
+
+
+/*
+** {======================================================
+** READ
+** =======================================================
+*/
+
+
+static int read_number (lua_State *L, FILE *f) {
+  lua_Number d;
+  if (fscanf(f, LUA_NUMBER_SCAN, &d) == 1) {
+    lua_pushnumber(L, d);
+    return 1;
+  }
+  else {
+   lua_pushnil(L);  /* "result" to be removed */
+   return 0;  /* read fails */
+  }
+}
+
+
+static int test_eof (lua_State *L, FILE *f) {
+  int c = getc(f);
+  ungetc(c, f);
+  lua_pushlstring(L, NULL, 0);
+  return (c != EOF);
+}
+
+
+static int read_line (lua_State *L, FILE *f, int chop) {
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  for (;;) {
+    size_t l;
+    char *p = luaL_prepbuffer(&b);
+    if (fgets(p, LUAL_BUFFERSIZE, f) == NULL) {  /* eof? */
+      luaL_pushresult(&b);  /* close buffer */
+      return (lua_rawlen(L, -1) > 0);  /* check whether read something */
+    }
+    l = strlen(p);
+    if (l == 0 || p[l-1] != '\n')
+      luaL_addsize(&b, l);
+    else {
+      luaL_addsize(&b, l - chop);  /* chop 'eol' if needed */
+      luaL_pushresult(&b);  /* close buffer */
+      return 1;  /* read at least an `eol' */
+    }
+  }
+}
+
+
+#define MAX_SIZE_T	(~(size_t)0)
+
+static void read_all (lua_State *L, FILE *f) {
+  size_t rlen = LUAL_BUFFERSIZE;  /* how much to read in each cycle */
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  for (;;) {
+    char *p = luaL_prepbuffsize(&b, rlen);
+    size_t nr = fread(p, sizeof(char), rlen, f);
+    luaL_addsize(&b, nr);
+    if (nr < rlen) break;  /* eof? */
+    else if (rlen <= (MAX_SIZE_T / 4))  /* avoid buffers too large */
+      rlen *= 2;  /* double buffer size at each iteration */
+  }
+  luaL_pushresult(&b);  /* close buffer */
+}
+
+
+static int read_chars (lua_State *L, FILE *f, size_t n) {
+  size_t nr;  /* number of chars actually read */
+  char *p;
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  p = luaL_prepbuffsize(&b, n);  /* prepare buffer to read whole block */
+  nr = fread(p, sizeof(char), n, f);  /* try to read 'n' chars */
+  luaL_addsize(&b, nr);
+  luaL_pushresult(&b);  /* close buffer */
+  return (nr > 0);  /* true iff read something */
+}
+
+
+static int g_read (lua_State *L, FILE *f, int first) {
+  int nargs = lua_gettop(L) - 1;
+  int success;
+  int n;
+  clearerr(f);
+  if (nargs == 0) {  /* no arguments? */
+    success = read_line(L, f, 1);
+    n = first+1;  /* to return 1 result */
+  }
+  else {  /* ensure stack space for all results and for auxlib's buffer */
+    luaL_checkstack(L, nargs+LUA_MINSTACK, "too many arguments");
+    success = 1;
+    for (n = first; nargs-- && success; n++) {
+      if (lua_type(L, n) == LUA_TNUMBER) {
+        size_t l = (size_t)lua_tointeger(L, n);
+        success = (l == 0) ? test_eof(L, f) : read_chars(L, f, l);
+      }
+      else {
+        const char *p = lua_tostring(L, n);
+        luaL_argcheck(L, p && p[0] == '*', n, "invalid option");
+        switch (p[1]) {
+          case 'n':  /* number */
+            success = read_number(L, f);
+            break;
+          case 'l':  /* line */
+            success = read_line(L, f, 1);
+            break;
+          case 'L':  /* line with end-of-line */
+            success = read_line(L, f, 0);
+            break;
+          case 'a':  /* file */
+            read_all(L, f);  /* read entire file */
+            success = 1; /* always success */
+            break;
+          default:
+            return luaL_argerror(L, n, "invalid format");
+        }
+      }
+    }
+  }
+  if (ferror(f))
+    return luaL_fileresult(L, 0, NULL);
+  if (!success) {
+    lua_pop(L, 1);  /* remove last result */
+    lua_pushnil(L);  /* push nil instead */
+  }
+  return n - first;
+}
+
+
+static int io_read (lua_State *L) {
+  return g_read(L, getiofile(L, IO_INPUT), 1);
+}
+
+
+static int f_read (lua_State *L) {
+  return g_read(L, tofile(L), 2);
+}
+
+
+static int io_readline (lua_State *L) {
+  LStream *p = (LStream *)lua_touserdata(L, lua_upvalueindex(1));
+  int i;
+  int n = (int)lua_tointeger(L, lua_upvalueindex(2));
+  if (isclosed(p))  /* file is already closed? */
+    return luaL_error(L, "file is already closed");
+  lua_settop(L , 1);
+  for (i = 1; i <= n; i++)  /* push arguments to 'g_read' */
+    lua_pushvalue(L, lua_upvalueindex(3 + i));
+  n = g_read(L, p->f, 2);  /* 'n' is number of results */
+  lua_assert(n > 0);  /* should return at least a nil */
+  if (!lua_isnil(L, -n))  /* read at least one value? */
+    return n;  /* return them */
+  else {  /* first result is nil: EOF or error */
+    if (n > 1) {  /* is there error information? */
+      /* 2nd result is error message */
+      return luaL_error(L, "%s", lua_tostring(L, -n + 1));
+    }
+    if (lua_toboolean(L, lua_upvalueindex(3))) {  /* generator created file? */
+      lua_settop(L, 0);
+      lua_pushvalue(L, lua_upvalueindex(1));
+      aux_close(L);  /* close it */
+    }
+    return 0;
+  }
+}
+
+/* }====================================================== */
+
+
+static int g_write (lua_State *L, FILE *f, int arg) {
+  int nargs = lua_gettop(L) - arg;
+  int status = 1;
+  for (; nargs--; arg++) {
+    if (lua_type(L, arg) == LUA_TNUMBER) {
+      /* optimization: could be done exactly as for strings */
+      status = status &&
+          fprintf(f, LUA_NUMBER_FMT, lua_tonumber(L, arg)) > 0;
+    }
+    else {
+      size_t l;
+      const char *s = luaL_checklstring(L, arg, &l);
+      status = status && (fwrite(s, sizeof(char), l, f) == l);
+    }
+  }
+  if (status) return 1;  /* file handle already on stack top */
+  else return luaL_fileresult(L, status, NULL);
+}
+
+
+static int io_write (lua_State *L) {
+  return g_write(L, getiofile(L, IO_OUTPUT), 1);
+}
+
+
+static int f_write (lua_State *L) {
+  FILE *f = tofile(L);
+  lua_pushvalue(L, 1);  /* push file at the stack top (to be returned) */
+  return g_write(L, f, 2);
+}
+
+
+static int f_seek (lua_State *L) {
+  static const int mode[] = {SEEK_SET, SEEK_CUR, SEEK_END};
+  static const char *const modenames[] = {"set", "cur", "end", NULL};
+  FILE *f = tofile(L);
+  int op = luaL_checkoption(L, 2, "cur", modenames);
+  lua_Number p3 = luaL_optnumber(L, 3, 0);
+  l_seeknum offset = (l_seeknum)p3;
+  luaL_argcheck(L, (lua_Number)offset == p3, 3,
+                  "not an integer in proper range");
+  op = l_fseek(f, offset, mode[op]);
+  if (op)
+    return luaL_fileresult(L, 0, NULL);  /* error */
+  else {
+    lua_pushnumber(L, (lua_Number)l_ftell(f));
+    return 1;
+  }
+}
+
+
+static int f_setvbuf (lua_State *L) {
+  static const int mode[] = {_IONBF, _IOFBF, _IOLBF};
+  static const char *const modenames[] = {"no", "full", "line", NULL};
+  FILE *f = tofile(L);
+  int op = luaL_checkoption(L, 2, NULL, modenames);
+  lua_Integer sz = luaL_optinteger(L, 3, LUAL_BUFFERSIZE);
+  int res = setvbuf(f, NULL, mode[op], sz);
+  return luaL_fileresult(L, res == 0, NULL);
+}
+
+
+
+static int io_flush (lua_State *L) {
+  return luaL_fileresult(L, fflush(getiofile(L, IO_OUTPUT)) == 0, NULL);
+}
+
+
+static int f_flush (lua_State *L) {
+  return luaL_fileresult(L, fflush(tofile(L)) == 0, NULL);
+}
+
+
+/*
+** functions for 'io' library
+*/
+static const luaL_Reg iolib[] = {
+  {"close", io_close},
+  {"flush", io_flush},
+  {"input", io_input},
+  {"lines", io_lines},
+  {"open", io_open},
+  {"output", io_output},
+  {"popen", io_popen},
+  {"read", io_read},
+  {"tmpfile", io_tmpfile},
+  {"type", io_type},
+  {"write", io_write},
+  {NULL, NULL}
+};
+
+
+/*
+** methods for file handles
+*/
+static const luaL_Reg flib[] = {
+  {"close", io_close},
+  {"flush", f_flush},
+  {"lines", f_lines},
+  {"read", f_read},
+  {"seek", f_seek},
+  {"setvbuf", f_setvbuf},
+  {"write", f_write},
+  {"__gc", f_gc},
+  {"__tostring", f_tostring},
+  {NULL, NULL}
+};
+
+
+static void createmeta (lua_State *L) {
+  luaL_newmetatable(L, LUA_FILEHANDLE);  /* create metatable for file handles */
+  lua_pushvalue(L, -1);  /* push metatable */
+  lua_setfield(L, -2, "__index");  /* metatable.__index = metatable */
+  luaL_setfuncs(L, flib, 0);  /* add file methods to new metatable */
+  lua_pop(L, 1);  /* pop new metatable */
+}
+
+
+/*
+** function to (not) close the standard files stdin, stdout, and stderr
+*/
+static int io_noclose (lua_State *L) {
+  LStream *p = tolstream(L);
+  p->closef = &io_noclose;  /* keep file opened */
+  lua_pushnil(L);
+  lua_pushliteral(L, "cannot close standard file");
+  return 2;
+}
+
+
+static void createstdfile (lua_State *L, FILE *f, const char *k,
+                           const char *fname) {
+  LStream *p = newprefile(L);
+  p->f = f;
+  p->closef = &io_noclose;
+  if (k != NULL) {
+    lua_pushvalue(L, -1);
+    lua_setfield(L, LUA_REGISTRYINDEX, k);  /* add file to registry */
+  }
+  lua_setfield(L, -2, fname);  /* add file to module */
+}
+
+
+LUAMOD_API int luaopen_io (lua_State *L) {
+  luaL_newlib(L, iolib);  /* new module */
+  createmeta(L);
+  /* create (and set) default files */
+  createstdfile(L, stdin, IO_INPUT, "stdin");
+  createstdfile(L, stdout, IO_OUTPUT, "stdout");
+  createstdfile(L, stderr, NULL, "stderr");
+  return 1;
+}
+
diff -ruNp src.hd/libs/lua/llex.c src/libs/lua/llex.c
--- src.hd/libs/lua/llex.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/llex.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,527 @@
+/*
+** $Id: llex.c,v 2.63 2013/03/16 21:10:18 roberto Exp $
+** Lexical Analyzer
+** See Copyright Notice in lua.h
+*/
+
+
+#include <locale.h>
+#include <string.h>
+
+#define llex_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lctype.h"
+#include "ldo.h"
+#include "llex.h"
+#include "lobject.h"
+#include "lparser.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "lzio.h"
+
+
+
+#define next(ls) (ls->current = zgetc(ls->z))
+
+
+
+#define currIsNewline(ls)	(ls->current == '\n' || ls->current == '\r')
+
+
+/* ORDER RESERVED */
+static const char *const luaX_tokens [] = {
+    "and", "break", "do", "else", "elseif",
+    "end", "false", "for", "function", "goto", "if",
+    "in", "local", "nil", "not", "or", "repeat",
+    "return", "then", "true", "until", "while",
+    "..", "...", "==", ">=", "<=", "~=", "::", "<eof>",
+    "<number>", "<name>", "<string>"
+};
+
+
+#define save_and_next(ls) (save(ls, ls->current), next(ls))
+
+
+static l_noret lexerror (LexState *ls, const char *msg, int token);
+
+
+static void save (LexState *ls, int c) {
+  Mbuffer *b = ls->buff;
+  if (luaZ_bufflen(b) + 1 > luaZ_sizebuffer(b)) {
+    size_t newsize;
+    if (luaZ_sizebuffer(b) >= MAX_SIZET/2)
+      lexerror(ls, "lexical element too long", 0);
+    newsize = luaZ_sizebuffer(b) * 2;
+    luaZ_resizebuffer(ls->L, b, newsize);
+  }
+  b->buffer[luaZ_bufflen(b)++] = cast(char, c);
+}
+
+
+void luaX_init (lua_State *L) {
+  int i;
+  for (i=0; i<NUM_RESERVED; i++) {
+    TString *ts = luaS_new(L, luaX_tokens[i]);
+    luaS_fix(ts);  /* reserved words are never collected */
+    ts->tsv.extra = cast_byte(i+1);  /* reserved word */
+  }
+}
+
+
+const char *luaX_token2str (LexState *ls, int token) {
+  if (token < FIRST_RESERVED) {  /* single-byte symbols? */
+    lua_assert(token == cast(unsigned char, token));
+    return (lisprint(token)) ? luaO_pushfstring(ls->L, LUA_QL("%c"), token) :
+                              luaO_pushfstring(ls->L, "char(%d)", token);
+  }
+  else {
+    const char *s = luaX_tokens[token - FIRST_RESERVED];
+    if (token < TK_EOS)  /* fixed format (symbols and reserved words)? */
+      return luaO_pushfstring(ls->L, LUA_QS, s);
+    else  /* names, strings, and numerals */
+      return s;
+  }
+}
+
+
+static const char *txtToken (LexState *ls, int token) {
+  switch (token) {
+    case TK_NAME:
+    case TK_STRING:
+    case TK_NUMBER:
+      save(ls, '\0');
+      return luaO_pushfstring(ls->L, LUA_QS, luaZ_buffer(ls->buff));
+    default:
+      return luaX_token2str(ls, token);
+  }
+}
+
+
+static l_noret lexerror (LexState *ls, const char *msg, int token) {
+  char buff[LUA_IDSIZE];
+  luaO_chunkid(buff, getstr(ls->source), LUA_IDSIZE);
+  msg = luaO_pushfstring(ls->L, "%s:%d: %s", buff, ls->linenumber, msg);
+  if (token)
+    luaO_pushfstring(ls->L, "%s near %s", msg, txtToken(ls, token));
+  luaD_throw(ls->L, LUA_ERRSYNTAX);
+}
+
+
+l_noret luaX_syntaxerror (LexState *ls, const char *msg) {
+  lexerror(ls, msg, ls->t.token);
+}
+
+
+/*
+** creates a new string and anchors it in function's table so that
+** it will not be collected until the end of the function's compilation
+** (by that time it should be anchored in function's prototype)
+*/
+TString *luaX_newstring (LexState *ls, const char *str, size_t l) {
+  lua_State *L = ls->L;
+  TValue *o;  /* entry for `str' */
+  TString *ts = luaS_newlstr(L, str, l);  /* create new string */
+  setsvalue2s(L, L->top++, ts);  /* temporarily anchor it in stack */
+  o = luaH_set(L, ls->fs->h, L->top - 1);
+  if (ttisnil(o)) {  /* not in use yet? (see 'addK') */
+    /* boolean value does not need GC barrier;
+       table has no metatable, so it does not need to invalidate cache */
+    setbvalue(o, 1);  /* t[string] = true */
+    luaC_checkGC(L);
+  }
+  L->top--;  /* remove string from stack */
+  return ts;
+}
+
+
+/*
+** increment line number and skips newline sequence (any of
+** \n, \r, \n\r, or \r\n)
+*/
+static void inclinenumber (LexState *ls) {
+  int old = ls->current;
+  lua_assert(currIsNewline(ls));
+  next(ls);  /* skip `\n' or `\r' */
+  if (currIsNewline(ls) && ls->current != old)
+    next(ls);  /* skip `\n\r' or `\r\n' */
+  if (++ls->linenumber >= MAX_INT)
+    luaX_syntaxerror(ls, "chunk has too many lines");
+}
+
+
+void luaX_setinput (lua_State *L, LexState *ls, ZIO *z, TString *source,
+                    int firstchar) {
+  ls->decpoint = '.';
+  ls->L = L;
+  ls->current = firstchar;
+  ls->lookahead.token = TK_EOS;  /* no look-ahead token */
+  ls->z = z;
+  ls->fs = NULL;
+  ls->linenumber = 1;
+  ls->lastline = 1;
+  ls->source = source;
+  ls->envn = luaS_new(L, LUA_ENV);  /* create env name */
+  luaS_fix(ls->envn);  /* never collect this name */
+  luaZ_resizebuffer(ls->L, ls->buff, LUA_MINBUFFER);  /* initialize buffer */
+}
+
+
+
+/*
+** =======================================================
+** LEXICAL ANALYZER
+** =======================================================
+*/
+
+
+
+static int check_next (LexState *ls, const char *set) {
+  if (ls->current == '\0' || !strchr(set, ls->current))
+    return 0;
+  save_and_next(ls);
+  return 1;
+}
+
+
+/*
+** change all characters 'from' in buffer to 'to'
+*/
+static void buffreplace (LexState *ls, char from, char to) {
+  size_t n = luaZ_bufflen(ls->buff);
+  char *p = luaZ_buffer(ls->buff);
+  while (n--)
+    if (p[n] == from) p[n] = to;
+}
+
+
+#if !defined(getlocaledecpoint)
+#define getlocaledecpoint()	(localeconv()->decimal_point[0])
+#endif
+
+
+#define buff2d(b,e)	luaO_str2d(luaZ_buffer(b), luaZ_bufflen(b) - 1, e)
+
+/*
+** in case of format error, try to change decimal point separator to
+** the one defined in the current locale and check again
+*/
+static void trydecpoint (LexState *ls, SemInfo *seminfo) {
+  char old = ls->decpoint;
+  ls->decpoint = getlocaledecpoint();
+  buffreplace(ls, old, ls->decpoint);  /* try new decimal separator */
+  if (!buff2d(ls->buff, &seminfo->r)) {
+    /* format error with correct decimal point: no more options */
+    buffreplace(ls, ls->decpoint, '.');  /* undo change (for error message) */
+    lexerror(ls, "malformed number", TK_NUMBER);
+  }
+}
+
+
+/* LUA_NUMBER */
+/*
+** this function is quite liberal in what it accepts, as 'luaO_str2d'
+** will reject ill-formed numerals.
+*/
+static void read_numeral (LexState *ls, SemInfo *seminfo) {
+  const char *expo = "Ee";
+  int first = ls->current;
+  lua_assert(lisdigit(ls->current));
+  save_and_next(ls);
+  if (first == '0' && check_next(ls, "Xx"))  /* hexadecimal? */
+    expo = "Pp";
+  for (;;) {
+    if (check_next(ls, expo))  /* exponent part? */
+      check_next(ls, "+-");  /* optional exponent sign */
+    if (lisxdigit(ls->current) || ls->current == '.')
+      save_and_next(ls);
+    else  break;
+  }
+  save(ls, '\0');
+  buffreplace(ls, '.', ls->decpoint);  /* follow locale for decimal point */
+  if (!buff2d(ls->buff, &seminfo->r))  /* format error? */
+    trydecpoint(ls, seminfo); /* try to update decimal point separator */
+}
+
+
+/*
+** skip a sequence '[=*[' or ']=*]' and return its number of '='s or
+** -1 if sequence is malformed
+*/
+static int skip_sep (LexState *ls) {
+  int count = 0;
+  int s = ls->current;
+  lua_assert(s == '[' || s == ']');
+  save_and_next(ls);
+  while (ls->current == '=') {
+    save_and_next(ls);
+    count++;
+  }
+  return (ls->current == s) ? count : (-count) - 1;
+}
+
+
+static void read_long_string (LexState *ls, SemInfo *seminfo, int sep) {
+  save_and_next(ls);  /* skip 2nd `[' */
+  if (currIsNewline(ls))  /* string starts with a newline? */
+    inclinenumber(ls);  /* skip it */
+  for (;;) {
+    switch (ls->current) {
+      case EOZ:
+        lexerror(ls, (seminfo) ? "unfinished long string" :
+                                 "unfinished long comment", TK_EOS);
+        break;  /* to avoid warnings */
+      case ']': {
+        if (skip_sep(ls) == sep) {
+          save_and_next(ls);  /* skip 2nd `]' */
+          goto endloop;
+        }
+        break;
+      }
+      case '\n': case '\r': {
+        save(ls, '\n');
+        inclinenumber(ls);
+        if (!seminfo) luaZ_resetbuffer(ls->buff);  /* avoid wasting space */
+        break;
+      }
+      default: {
+        if (seminfo) save_and_next(ls);
+        else next(ls);
+      }
+    }
+  } endloop:
+  if (seminfo)
+    seminfo->ts = luaX_newstring(ls, luaZ_buffer(ls->buff) + (2 + sep),
+                                     luaZ_bufflen(ls->buff) - 2*(2 + sep));
+}
+
+
+static void escerror (LexState *ls, int *c, int n, const char *msg) {
+  int i;
+  luaZ_resetbuffer(ls->buff);  /* prepare error message */
+  save(ls, '\\');
+  for (i = 0; i < n && c[i] != EOZ; i++)
+    save(ls, c[i]);
+  lexerror(ls, msg, TK_STRING);
+}
+
+
+static int readhexaesc (LexState *ls) {
+  int c[3], i;  /* keep input for error message */
+  int r = 0;  /* result accumulator */
+  c[0] = 'x';  /* for error message */
+  for (i = 1; i < 3; i++) {  /* read two hexadecimal digits */
+    c[i] = next(ls);
+    if (!lisxdigit(c[i]))
+      escerror(ls, c, i + 1, "hexadecimal digit expected");
+    r = (r << 4) + luaO_hexavalue(c[i]);
+  }
+  return r;
+}
+
+
+static int readdecesc (LexState *ls) {
+  int c[3], i;
+  int r = 0;  /* result accumulator */
+  for (i = 0; i < 3 && lisdigit(ls->current); i++) {  /* read up to 3 digits */
+    c[i] = ls->current;
+    r = 10*r + c[i] - '0';
+    next(ls);
+  }
+  if (r > UCHAR_MAX)
+    escerror(ls, c, i, "decimal escape too large");
+  return r;
+}
+
+
+static void read_string (LexState *ls, int del, SemInfo *seminfo) {
+  save_and_next(ls);  /* keep delimiter (for error messages) */
+  while (ls->current != del) {
+    switch (ls->current) {
+      case EOZ:
+        lexerror(ls, "unfinished string", TK_EOS);
+        break;  /* to avoid warnings */
+      case '\n':
+      case '\r':
+        lexerror(ls, "unfinished string", TK_STRING);
+        break;  /* to avoid warnings */
+      case '\\': {  /* escape sequences */
+        int c;  /* final character to be saved */
+        next(ls);  /* do not save the `\' */
+        switch (ls->current) {
+          case 'a': c = '\a'; goto read_save;
+          case 'b': c = '\b'; goto read_save;
+          case 'f': c = '\f'; goto read_save;
+          case 'n': c = '\n'; goto read_save;
+          case 'r': c = '\r'; goto read_save;
+          case 't': c = '\t'; goto read_save;
+          case 'v': c = '\v'; goto read_save;
+          case 'x': c = readhexaesc(ls); goto read_save;
+          case '\n': case '\r':
+            inclinenumber(ls); c = '\n'; goto only_save;
+          case '\\': case '\"': case '\'':
+            c = ls->current; goto read_save;
+          case EOZ: goto no_save;  /* will raise an error next loop */
+          case 'z': {  /* zap following span of spaces */
+            next(ls);  /* skip the 'z' */
+            while (lisspace(ls->current)) {
+              if (currIsNewline(ls)) inclinenumber(ls);
+              else next(ls);
+            }
+            goto no_save;
+          }
+          default: {
+            if (!lisdigit(ls->current))
+              escerror(ls, &ls->current, 1, "invalid escape sequence");
+            /* digital escape \ddd */
+            c = readdecesc(ls);
+            goto only_save;
+          }
+        }
+       read_save: next(ls);  /* read next character */
+       only_save: save(ls, c);  /* save 'c' */
+       no_save: break;
+      }
+      default:
+        save_and_next(ls);
+    }
+  }
+  save_and_next(ls);  /* skip delimiter */
+  seminfo->ts = luaX_newstring(ls, luaZ_buffer(ls->buff) + 1,
+                                   luaZ_bufflen(ls->buff) - 2);
+}
+
+
+static int llex (LexState *ls, SemInfo *seminfo) {
+  luaZ_resetbuffer(ls->buff);
+  for (;;) {
+    switch (ls->current) {
+      case '\n': case '\r': {  /* line breaks */
+        inclinenumber(ls);
+        break;
+      }
+      case ' ': case '\f': case '\t': case '\v': {  /* spaces */
+        next(ls);
+        break;
+      }
+      case '-': {  /* '-' or '--' (comment) */
+        next(ls);
+        if (ls->current != '-') return '-';
+        /* else is a comment */
+        next(ls);
+        if (ls->current == '[') {  /* long comment? */
+          int sep = skip_sep(ls);
+          luaZ_resetbuffer(ls->buff);  /* `skip_sep' may dirty the buffer */
+          if (sep >= 0) {
+            read_long_string(ls, NULL, sep);  /* skip long comment */
+            luaZ_resetbuffer(ls->buff);  /* previous call may dirty the buff. */
+            break;
+          }
+        }
+        /* else short comment */
+        while (!currIsNewline(ls) && ls->current != EOZ)
+          next(ls);  /* skip until end of line (or end of file) */
+        break;
+      }
+      case '[': {  /* long string or simply '[' */
+        int sep = skip_sep(ls);
+        if (sep >= 0) {
+          read_long_string(ls, seminfo, sep);
+          return TK_STRING;
+        }
+        else if (sep == -1) return '[';
+        else lexerror(ls, "invalid long string delimiter", TK_STRING);
+      }
+      case '=': {
+        next(ls);
+        if (ls->current != '=') return '=';
+        else { next(ls); return TK_EQ; }
+      }
+      case '<': {
+        next(ls);
+        if (ls->current != '=') return '<';
+        else { next(ls); return TK_LE; }
+      }
+      case '>': {
+        next(ls);
+        if (ls->current != '=') return '>';
+        else { next(ls); return TK_GE; }
+      }
+      case '~': {
+        next(ls);
+        if (ls->current != '=') return '~';
+        else { next(ls); return TK_NE; }
+      }
+      case ':': {
+        next(ls);
+        if (ls->current != ':') return ':';
+        else { next(ls); return TK_DBCOLON; }
+      }
+      case '"': case '\'': {  /* short literal strings */
+        read_string(ls, ls->current, seminfo);
+        return TK_STRING;
+      }
+      case '.': {  /* '.', '..', '...', or number */
+        save_and_next(ls);
+        if (check_next(ls, ".")) {
+          if (check_next(ls, "."))
+            return TK_DOTS;   /* '...' */
+          else return TK_CONCAT;   /* '..' */
+        }
+        else if (!lisdigit(ls->current)) return '.';
+        /* else go through */
+      }
+      case '0': case '1': case '2': case '3': case '4':
+      case '5': case '6': case '7': case '8': case '9': {
+        read_numeral(ls, seminfo);
+        return TK_NUMBER;
+      }
+      case EOZ: {
+        return TK_EOS;
+      }
+      default: {
+        if (lislalpha(ls->current)) {  /* identifier or reserved word? */
+          TString *ts;
+          do {
+            save_and_next(ls);
+          } while (lislalnum(ls->current));
+          ts = luaX_newstring(ls, luaZ_buffer(ls->buff),
+                                  luaZ_bufflen(ls->buff));
+          seminfo->ts = ts;
+          if (isreserved(ts))  /* reserved word? */
+            return ts->tsv.extra - 1 + FIRST_RESERVED;
+          else {
+            return TK_NAME;
+          }
+        }
+        else {  /* single-char tokens (+ - / ...) */
+          int c = ls->current;
+          next(ls);
+          return c;
+        }
+      }
+    }
+  }
+}
+
+
+void luaX_next (LexState *ls) {
+  ls->lastline = ls->linenumber;
+  if (ls->lookahead.token != TK_EOS) {  /* is there a look-ahead token? */
+    ls->t = ls->lookahead;  /* use this one */
+    ls->lookahead.token = TK_EOS;  /* and discharge it */
+  }
+  else
+    ls->t.token = llex(ls, &ls->t.seminfo);  /* read next token */
+}
+
+
+int luaX_lookahead (LexState *ls) {
+  lua_assert(ls->lookahead.token == TK_EOS);
+  ls->lookahead.token = llex(ls, &ls->lookahead.seminfo);
+  return ls->lookahead.token;
+}
+
diff -ruNp src.hd/libs/lua/llex.h src/libs/lua/llex.h
--- src.hd/libs/lua/llex.h	1969-12-31 16:00:00 -0800
+++ src/libs/lua/llex.h	2017-12-29 00:57:40 -0800
@@ -0,0 +1,78 @@
+/*
+** $Id: llex.h,v 1.72 2011/11/30 12:43:51 roberto Exp $
+** Lexical Analyzer
+** See Copyright Notice in lua.h
+*/
+
+#ifndef llex_h
+#define llex_h
+
+#include "lobject.h"
+#include "lzio.h"
+
+
+#define FIRST_RESERVED	257
+
+
+
+/*
+* WARNING: if you change the order of this enumeration,
+* grep "ORDER RESERVED"
+*/
+enum RESERVED {
+  /* terminal symbols denoted by reserved words */
+  TK_AND = FIRST_RESERVED, TK_BREAK,
+  TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,
+  TK_GOTO, TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,
+  TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,
+  /* other terminal symbols */
+  TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_DBCOLON, TK_EOS,
+  TK_NUMBER, TK_NAME, TK_STRING
+};
+
+/* number of reserved words */
+#define NUM_RESERVED	(cast(int, TK_WHILE-FIRST_RESERVED+1))
+
+
+typedef union {
+  lua_Number r;
+  TString *ts;
+} SemInfo;  /* semantics information */
+
+
+typedef struct Token {
+  int token;
+  SemInfo seminfo;
+} Token;
+
+
+/* state of the lexer plus state of the parser when shared by all
+   functions */
+typedef struct LexState {
+  int current;  /* current character (charint) */
+  int linenumber;  /* input line counter */
+  int lastline;  /* line of last token `consumed' */
+  Token t;  /* current token */
+  Token lookahead;  /* look ahead token */
+  struct FuncState *fs;  /* current function (parser) */
+  struct lua_State *L;
+  ZIO *z;  /* input stream */
+  Mbuffer *buff;  /* buffer for tokens */
+  struct Dyndata *dyd;  /* dynamic structures used by the parser */
+  TString *source;  /* current source name */
+  TString *envn;  /* environment variable name */
+  char decpoint;  /* locale decimal point */
+} LexState;
+
+
+LUAI_FUNC void luaX_init (lua_State *L);
+LUAI_FUNC void luaX_setinput (lua_State *L, LexState *ls, ZIO *z,
+                              TString *source, int firstchar);
+LUAI_FUNC TString *luaX_newstring (LexState *ls, const char *str, size_t l);
+LUAI_FUNC void luaX_next (LexState *ls);
+LUAI_FUNC int luaX_lookahead (LexState *ls);
+LUAI_FUNC l_noret luaX_syntaxerror (LexState *ls, const char *s);
+LUAI_FUNC const char *luaX_token2str (LexState *ls, int token);
+
+
+#endif
diff -ruNp src.hd/libs/lua/llimits.h src/libs/lua/llimits.h
--- src.hd/libs/lua/llimits.h	1969-12-31 16:00:00 -0800
+++ src/libs/lua/llimits.h	2017-12-29 00:57:40 -0800
@@ -0,0 +1,309 @@
+/*
+** $Id: llimits.h,v 1.103 2013/02/20 14:08:56 roberto Exp $
+** Limits, basic types, and some other `installation-dependent' definitions
+** See Copyright Notice in lua.h
+*/
+
+#ifndef llimits_h
+#define llimits_h
+
+
+#include <limits.h>
+#include <stddef.h>
+
+
+#include "lua.h"
+
+
+typedef unsigned LUA_INT32 lu_int32;
+
+typedef LUAI_UMEM lu_mem;
+
+typedef LUAI_MEM l_mem;
+
+
+
+/* chars used as small naturals (so that `char' is reserved for characters) */
+typedef unsigned char lu_byte;
+
+
+#define MAX_SIZET	((size_t)(~(size_t)0)-2)
+
+#define MAX_LUMEM	((lu_mem)(~(lu_mem)0)-2)
+
+#define MAX_LMEM	((l_mem) ((MAX_LUMEM >> 1) - 2))
+
+
+#define MAX_INT (INT_MAX-2)  /* maximum value of an int (-2 for safety) */
+
+/*
+** conversion of pointer to integer
+** this is for hashing only; there is no problem if the integer
+** cannot hold the whole pointer value
+*/
+#define IntPoint(p)  ((unsigned int)(lu_mem)(p))
+
+
+
+/* type to ensure maximum alignment */
+#if !defined(LUAI_USER_ALIGNMENT_T)
+#define LUAI_USER_ALIGNMENT_T	union { double u; void *s; long l; }
+#endif
+
+typedef LUAI_USER_ALIGNMENT_T L_Umaxalign;
+
+
+/* result of a `usual argument conversion' over lua_Number */
+typedef LUAI_UACNUMBER l_uacNumber;
+
+
+/* internal assertions for in-house debugging */
+#if defined(lua_assert)
+#define check_exp(c,e)		(lua_assert(c), (e))
+/* to avoid problems with conditions too long */
+#define lua_longassert(c)	{ if (!(c)) lua_assert(0); }
+#else
+#define lua_assert(c)		((void)0)
+#define check_exp(c,e)		(e)
+#define lua_longassert(c)	((void)0)
+#endif
+
+/*
+** assertion for checking API calls
+*/
+#if !defined(luai_apicheck)
+
+#if defined(LUA_USE_APICHECK)
+#include <assert.h>
+#define luai_apicheck(L,e)	assert(e)
+#else
+#define luai_apicheck(L,e)	lua_assert(e)
+#endif
+
+#endif
+
+#define api_check(l,e,msg)	luai_apicheck(l,(e) && msg)
+
+
+#if !defined(UNUSED)
+#define UNUSED(x)	((void)(x))	/* to avoid warnings */
+#endif
+
+
+#define cast(t, exp)	((t)(exp))
+
+#define cast_byte(i)	cast(lu_byte, (i))
+#define cast_num(i)	cast(lua_Number, (i))
+#define cast_int(i)	cast(int, (i))
+#define cast_uchar(i)	cast(unsigned char, (i))
+
+
+/*
+** non-return type
+*/
+#if defined(__GNUC__)
+#define l_noret		void __attribute__((noreturn))
+#elif defined(_MSC_VER)
+#define l_noret		void __declspec(noreturn)
+#else
+#define l_noret		void
+#endif
+
+
+
+/*
+** maximum depth for nested C calls and syntactical nested non-terminals
+** in a program. (Value must fit in an unsigned short int.)
+*/
+#if !defined(LUAI_MAXCCALLS)
+#define LUAI_MAXCCALLS		200
+#endif
+
+/*
+** maximum number of upvalues in a closure (both C and Lua). (Value
+** must fit in an unsigned char.)
+*/
+#define MAXUPVAL	UCHAR_MAX
+
+
+/*
+** type for virtual-machine instructions
+** must be an unsigned with (at least) 4 bytes (see details in lopcodes.h)
+*/
+typedef lu_int32 Instruction;
+
+
+
+/* maximum stack for a Lua function */
+#define MAXSTACK	250
+
+
+
+/* minimum size for the string table (must be power of 2) */
+#if !defined(MINSTRTABSIZE)
+#define MINSTRTABSIZE	32
+#endif
+
+
+/* minimum size for string buffer */
+#if !defined(LUA_MINBUFFER)
+#define LUA_MINBUFFER	32
+#endif
+
+
+#if !defined(lua_lock)
+#define lua_lock(L)     ((void) 0)
+#define lua_unlock(L)   ((void) 0)
+#endif
+
+#if !defined(luai_threadyield)
+#define luai_threadyield(L)     {lua_unlock(L); lua_lock(L);}
+#endif
+
+
+/*
+** these macros allow user-specific actions on threads when you defined
+** LUAI_EXTRASPACE and need to do something extra when a thread is
+** created/deleted/resumed/yielded.
+*/
+#if !defined(luai_userstateopen)
+#define luai_userstateopen(L)		((void)L)
+#endif
+
+#if !defined(luai_userstateclose)
+#define luai_userstateclose(L)		((void)L)
+#endif
+
+#if !defined(luai_userstatethread)
+#define luai_userstatethread(L,L1)	((void)L)
+#endif
+
+#if !defined(luai_userstatefree)
+#define luai_userstatefree(L,L1)	((void)L)
+#endif
+
+#if !defined(luai_userstateresume)
+#define luai_userstateresume(L,n)       ((void)L)
+#endif
+
+#if !defined(luai_userstateyield)
+#define luai_userstateyield(L,n)        ((void)L)
+#endif
+
+/*
+** lua_number2int is a macro to convert lua_Number to int.
+** lua_number2integer is a macro to convert lua_Number to lua_Integer.
+** lua_number2unsigned is a macro to convert a lua_Number to a lua_Unsigned.
+** lua_unsigned2number is a macro to convert a lua_Unsigned to a lua_Number.
+** luai_hashnum is a macro to hash a lua_Number value into an integer.
+** The hash must be deterministic and give reasonable values for
+** both small and large values (outside the range of integers).
+*/
+
+#if defined(MS_ASMTRICK) || defined(LUA_MSASMTRICK)	/* { */
+/* trick with Microsoft assembler for X86 */
+
+#define lua_number2int(i,n)  __asm {__asm fld n   __asm fistp i}
+#define lua_number2integer(i,n)		lua_number2int(i, n)
+#define lua_number2unsigned(i,n)  \
+  {__int64 l; __asm {__asm fld n   __asm fistp l} i = (unsigned int)l;}
+
+
+#elif defined(LUA_IEEE754TRICK)		/* }{ */
+/* the next trick should work on any machine using IEEE754 with
+   a 32-bit int type */
+
+union luai_Cast { double l_d; LUA_INT32 l_p[2]; };
+
+#if !defined(LUA_IEEEENDIAN)	/* { */
+#define LUAI_EXTRAIEEE	\
+  static const union luai_Cast ieeeendian = {-(33.0 + 6755399441055744.0)};
+#define LUA_IEEEENDIANLOC	(ieeeendian.l_p[1] == 33)
+#else
+#define LUA_IEEEENDIANLOC	LUA_IEEEENDIAN
+#define LUAI_EXTRAIEEE		/* empty */
+#endif				/* } */
+
+#define lua_number2int32(i,n,t) \
+  { LUAI_EXTRAIEEE \
+    volatile union luai_Cast u; u.l_d = (n) + 6755399441055744.0; \
+    (i) = (t)u.l_p[LUA_IEEEENDIANLOC]; }
+
+#define luai_hashnum(i,n)  \
+  { volatile union luai_Cast u; u.l_d = (n) + 1.0;  /* avoid -0 */ \
+    (i) = u.l_p[0]; (i) += u.l_p[1]; }  /* add double bits for his hash */
+
+#define lua_number2int(i,n)		lua_number2int32(i, n, int)
+#define lua_number2unsigned(i,n)	lua_number2int32(i, n, lua_Unsigned)
+
+/* the trick can be expanded to lua_Integer when it is a 32-bit value */
+#if defined(LUA_IEEELL)
+#define lua_number2integer(i,n)		lua_number2int32(i, n, lua_Integer)
+#endif
+
+#endif				/* } */
+
+
+/* the following definitions always work, but may be slow */
+
+#if !defined(lua_number2int)
+#define lua_number2int(i,n)	((i)=(int)(n))
+#endif
+
+#if !defined(lua_number2integer)
+#define lua_number2integer(i,n)	((i)=(lua_Integer)(n))
+#endif
+
+#if !defined(lua_number2unsigned)	/* { */
+/* the following definition assures proper modulo behavior */
+#if defined(LUA_NUMBER_DOUBLE) || defined(LUA_NUMBER_FLOAT)
+#include <math.h>
+#define SUPUNSIGNED	((lua_Number)(~(lua_Unsigned)0) + 1)
+#define lua_number2unsigned(i,n)  \
+	((i)=(lua_Unsigned)((n) - floor((n)/SUPUNSIGNED)*SUPUNSIGNED))
+#else
+#define lua_number2unsigned(i,n)	((i)=(lua_Unsigned)(n))
+#endif
+#endif				/* } */
+
+
+#if !defined(lua_unsigned2number)
+/* on several machines, coercion from unsigned to double is slow,
+   so it may be worth to avoid */
+#define lua_unsigned2number(u)  \
+    (((u) <= (lua_Unsigned)INT_MAX) ? (lua_Number)(int)(u) : (lua_Number)(u))
+#endif
+
+
+
+#if defined(ltable_c) && !defined(luai_hashnum)
+
+#include <float.h>
+#include <math.h>
+
+#define luai_hashnum(i,n) { int e;  \
+  n = l_mathop(frexp)(n, &e) * (lua_Number)(INT_MAX - DBL_MAX_EXP);  \
+  lua_number2int(i, n); i += e; }
+
+#endif
+
+
+
+/*
+** macro to control inclusion of some hard tests on stack reallocation
+*/
+#if !defined(HARDSTACKTESTS)
+#define condmovestack(L)	((void)0)
+#else
+/* realloc stack keeping its size */
+#define condmovestack(L)	luaD_reallocstack((L), (L)->stacksize)
+#endif
+
+#if !defined(HARDMEMTESTS)
+#define condchangemem(L)	condmovestack(L)
+#else
+#define condchangemem(L)  \
+	((void)(!(G(L)->gcrunning) || (luaC_fullgc(L, 0), 1)))
+#endif
+
+#endif
diff -ruNp src.hd/libs/lua/lmathlib.c src/libs/lua/lmathlib.c
--- src.hd/libs/lua/lmathlib.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lmathlib.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,279 @@
+/*
+** $Id: lmathlib.c,v 1.83 2013/03/07 18:21:32 roberto Exp $
+** Standard mathematical library
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdlib.h>
+#include <math.h>
+
+#define lmathlib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+#undef PI
+#define PI	((lua_Number)(3.1415926535897932384626433832795))
+#define RADIANS_PER_DEGREE	((lua_Number)(PI/180.0))
+
+
+
+static int math_abs (lua_State *L) {
+  lua_pushnumber(L, l_mathop(fabs)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_sin (lua_State *L) {
+  lua_pushnumber(L, l_mathop(sin)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_sinh (lua_State *L) {
+  lua_pushnumber(L, l_mathop(sinh)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_cos (lua_State *L) {
+  lua_pushnumber(L, l_mathop(cos)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_cosh (lua_State *L) {
+  lua_pushnumber(L, l_mathop(cosh)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_tan (lua_State *L) {
+  lua_pushnumber(L, l_mathop(tan)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_tanh (lua_State *L) {
+  lua_pushnumber(L, l_mathop(tanh)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_asin (lua_State *L) {
+  lua_pushnumber(L, l_mathop(asin)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_acos (lua_State *L) {
+  lua_pushnumber(L, l_mathop(acos)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_atan (lua_State *L) {
+  lua_pushnumber(L, l_mathop(atan)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_atan2 (lua_State *L) {
+  lua_pushnumber(L, l_mathop(atan2)(luaL_checknumber(L, 1),
+                                luaL_checknumber(L, 2)));
+  return 1;
+}
+
+static int math_ceil (lua_State *L) {
+  lua_pushnumber(L, l_mathop(ceil)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_floor (lua_State *L) {
+  lua_pushnumber(L, l_mathop(floor)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_fmod (lua_State *L) {
+  lua_pushnumber(L, l_mathop(fmod)(luaL_checknumber(L, 1),
+                               luaL_checknumber(L, 2)));
+  return 1;
+}
+
+static int math_modf (lua_State *L) {
+  lua_Number ip;
+  lua_Number fp = l_mathop(modf)(luaL_checknumber(L, 1), &ip);
+  lua_pushnumber(L, ip);
+  lua_pushnumber(L, fp);
+  return 2;
+}
+
+static int math_sqrt (lua_State *L) {
+  lua_pushnumber(L, l_mathop(sqrt)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_pow (lua_State *L) {
+  lua_Number x = luaL_checknumber(L, 1);
+  lua_Number y = luaL_checknumber(L, 2);
+  lua_pushnumber(L, l_mathop(pow)(x, y));
+  return 1;
+}
+
+static int math_log (lua_State *L) {
+  lua_Number x = luaL_checknumber(L, 1);
+  lua_Number res;
+  if (lua_isnoneornil(L, 2))
+    res = l_mathop(log)(x);
+  else {
+    lua_Number base = luaL_checknumber(L, 2);
+    if (base == (lua_Number)10.0) res = l_mathop(log10)(x);
+    else res = l_mathop(log)(x)/l_mathop(log)(base);
+  }
+  lua_pushnumber(L, res);
+  return 1;
+}
+
+#if defined(LUA_COMPAT_LOG10)
+static int math_log10 (lua_State *L) {
+  lua_pushnumber(L, l_mathop(log10)(luaL_checknumber(L, 1)));
+  return 1;
+}
+#endif
+
+static int math_exp (lua_State *L) {
+  lua_pushnumber(L, l_mathop(exp)(luaL_checknumber(L, 1)));
+  return 1;
+}
+
+static int math_deg (lua_State *L) {
+  lua_pushnumber(L, luaL_checknumber(L, 1)/RADIANS_PER_DEGREE);
+  return 1;
+}
+
+static int math_rad (lua_State *L) {
+  lua_pushnumber(L, luaL_checknumber(L, 1)*RADIANS_PER_DEGREE);
+  return 1;
+}
+
+static int math_frexp (lua_State *L) {
+  int e;
+  lua_pushnumber(L, l_mathop(frexp)(luaL_checknumber(L, 1), &e));
+  lua_pushinteger(L, e);
+  return 2;
+}
+
+static int math_ldexp (lua_State *L) {
+  lua_Number x = luaL_checknumber(L, 1);
+  int ep = luaL_checkint(L, 2);
+  lua_pushnumber(L, l_mathop(ldexp)(x, ep));
+  return 1;
+}
+
+
+
+static int math_min (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  lua_Number dmin = luaL_checknumber(L, 1);
+  int i;
+  for (i=2; i<=n; i++) {
+    lua_Number d = luaL_checknumber(L, i);
+    if (d < dmin)
+      dmin = d;
+  }
+  lua_pushnumber(L, dmin);
+  return 1;
+}
+
+
+static int math_max (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  lua_Number dmax = luaL_checknumber(L, 1);
+  int i;
+  for (i=2; i<=n; i++) {
+    lua_Number d = luaL_checknumber(L, i);
+    if (d > dmax)
+      dmax = d;
+  }
+  lua_pushnumber(L, dmax);
+  return 1;
+}
+
+
+static int math_random (lua_State *L) {
+  /* the `%' avoids the (rare) case of r==1, and is needed also because on
+     some systems (SunOS!) `rand()' may return a value larger than RAND_MAX */
+  lua_Number r = (lua_Number)(rand()%RAND_MAX) / (lua_Number)RAND_MAX;
+  switch (lua_gettop(L)) {  /* check number of arguments */
+    case 0: {  /* no arguments */
+      lua_pushnumber(L, r);  /* Number between 0 and 1 */
+      break;
+    }
+    case 1: {  /* only upper limit */
+      lua_Number u = luaL_checknumber(L, 1);
+      luaL_argcheck(L, (lua_Number)1.0 <= u, 1, "interval is empty");
+      lua_pushnumber(L, l_mathop(floor)(r*u) + (lua_Number)(1.0));  /* [1, u] */
+      break;
+    }
+    case 2: {  /* lower and upper limits */
+      lua_Number l = luaL_checknumber(L, 1);
+      lua_Number u = luaL_checknumber(L, 2);
+      luaL_argcheck(L, l <= u, 2, "interval is empty");
+      lua_pushnumber(L, l_mathop(floor)(r*(u-l+1)) + l);  /* [l, u] */
+      break;
+    }
+    default: return luaL_error(L, "wrong number of arguments");
+  }
+  return 1;
+}
+
+
+static int math_randomseed (lua_State *L) {
+  srand(luaL_checkunsigned(L, 1));
+  (void)rand(); /* discard first value to avoid undesirable correlations */
+  return 0;
+}
+
+
+static const luaL_Reg mathlib[] = {
+  {"abs",   math_abs},
+  {"acos",  math_acos},
+  {"asin",  math_asin},
+  {"atan2", math_atan2},
+  {"atan",  math_atan},
+  {"ceil",  math_ceil},
+  {"cosh",   math_cosh},
+  {"cos",   math_cos},
+  {"deg",   math_deg},
+  {"exp",   math_exp},
+  {"floor", math_floor},
+  {"fmod",   math_fmod},
+  {"frexp", math_frexp},
+  {"ldexp", math_ldexp},
+#if defined(LUA_COMPAT_LOG10)
+  {"log10", math_log10},
+#endif
+  {"log",   math_log},
+  {"max",   math_max},
+  {"min",   math_min},
+  {"modf",   math_modf},
+  {"pow",   math_pow},
+  {"rad",   math_rad},
+  {"random",     math_random},
+  {"randomseed", math_randomseed},
+  {"sinh",   math_sinh},
+  {"sin",   math_sin},
+  {"sqrt",  math_sqrt},
+  {"tanh",   math_tanh},
+  {"tan",   math_tan},
+  {NULL, NULL}
+};
+
+
+/*
+** Open math library
+*/
+LUAMOD_API int luaopen_math (lua_State *L) {
+  luaL_newlib(L, mathlib);
+  lua_pushnumber(L, PI);
+  lua_setfield(L, -2, "pi");
+  lua_pushnumber(L, HUGE_VAL);
+  lua_setfield(L, -2, "huge");
+  return 1;
+}
+
diff -ruNp src.hd/libs/lua/lmem.c src/libs/lua/lmem.c
--- src.hd/libs/lua/lmem.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lmem.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,99 @@
+/*
+** $Id: lmem.c,v 1.84 2012/05/23 15:41:53 roberto Exp $
+** Interface to Memory Manager
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stddef.h>
+
+#define lmem_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+
+
+
+/*
+** About the realloc function:
+** void * frealloc (void *ud, void *ptr, size_t osize, size_t nsize);
+** (`osize' is the old size, `nsize' is the new size)
+**
+** * frealloc(ud, NULL, x, s) creates a new block of size `s' (no
+** matter 'x').
+**
+** * frealloc(ud, p, x, 0) frees the block `p'
+** (in this specific case, frealloc must return NULL);
+** particularly, frealloc(ud, NULL, 0, 0) does nothing
+** (which is equivalent to free(NULL) in ANSI C)
+**
+** frealloc returns NULL if it cannot create or reallocate the area
+** (any reallocation to an equal or smaller size cannot fail!)
+*/
+
+
+
+#define MINSIZEARRAY	4
+
+
+void *luaM_growaux_ (lua_State *L, void *block, int *size, size_t size_elems,
+                     int limit, const char *what) {
+  void *newblock;
+  int newsize;
+  if (*size >= limit/2) {  /* cannot double it? */
+    if (*size >= limit)  /* cannot grow even a little? */
+      luaG_runerror(L, "too many %s (limit is %d)", what, limit);
+    newsize = limit;  /* still have at least one free place */
+  }
+  else {
+    newsize = (*size)*2;
+    if (newsize < MINSIZEARRAY)
+      newsize = MINSIZEARRAY;  /* minimum size */
+  }
+  newblock = luaM_reallocv(L, block, *size, newsize, size_elems);
+  *size = newsize;  /* update only when everything else is OK */
+  return newblock;
+}
+
+
+l_noret luaM_toobig (lua_State *L) {
+  luaG_runerror(L, "memory allocation error: block too big");
+}
+
+
+
+/*
+** generic allocation routine.
+*/
+void *luaM_realloc_ (lua_State *L, void *block, size_t osize, size_t nsize) {
+  void *newblock;
+  global_State *g = G(L);
+  size_t realosize = (block) ? osize : 0;
+  lua_assert((realosize == 0) == (block == NULL));
+#if defined(HARDMEMTESTS)
+  if (nsize > realosize && g->gcrunning)
+    luaC_fullgc(L, 1);  /* force a GC whenever possible */
+#endif
+  newblock = (*g->frealloc)(g->ud, block, osize, nsize);
+  if (newblock == NULL && nsize > 0) {
+    api_check(L, nsize > realosize,
+                 "realloc cannot fail when shrinking a block");
+    if (g->gcrunning) {
+      luaC_fullgc(L, 1);  /* try to free some memory... */
+      newblock = (*g->frealloc)(g->ud, block, osize, nsize);  /* try again */
+    }
+    if (newblock == NULL)
+      luaD_throw(L, LUA_ERRMEM);
+  }
+  lua_assert((nsize == 0) == (newblock == NULL));
+  g->GCdebt = (g->GCdebt + nsize) - realosize;
+  return newblock;
+}
+
diff -ruNp src.hd/libs/lua/lmem.h src/libs/lua/lmem.h
--- src.hd/libs/lua/lmem.h	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lmem.h	2017-12-29 00:57:40 -0800
@@ -0,0 +1,57 @@
+/*
+** $Id: lmem.h,v 1.40 2013/02/20 14:08:21 roberto Exp $
+** Interface to Memory Manager
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lmem_h
+#define lmem_h
+
+
+#include <stddef.h>
+
+#include "llimits.h"
+#include "lua.h"
+
+
+/*
+** This macro avoids the runtime division MAX_SIZET/(e), as 'e' is
+** always constant.
+** The macro is somewhat complex to avoid warnings:
+** +1 avoids warnings of "comparison has constant result";
+** cast to 'void' avoids warnings of "value unused".
+*/
+#define luaM_reallocv(L,b,on,n,e) \
+  (cast(void, \
+     (cast(size_t, (n)+1) > MAX_SIZET/(e)) ? (luaM_toobig(L), 0) : 0), \
+   luaM_realloc_(L, (b), (on)*(e), (n)*(e)))
+
+#define luaM_freemem(L, b, s)	luaM_realloc_(L, (b), (s), 0)
+#define luaM_free(L, b)		luaM_realloc_(L, (b), sizeof(*(b)), 0)
+#define luaM_freearray(L, b, n)   luaM_reallocv(L, (b), n, 0, sizeof((b)[0]))
+
+#define luaM_malloc(L,s)	luaM_realloc_(L, NULL, 0, (s))
+#define luaM_new(L,t)		cast(t *, luaM_malloc(L, sizeof(t)))
+#define luaM_newvector(L,n,t) \
+		cast(t *, luaM_reallocv(L, NULL, 0, n, sizeof(t)))
+
+#define luaM_newobject(L,tag,s)	luaM_realloc_(L, NULL, tag, (s))
+
+#define luaM_growvector(L,v,nelems,size,t,limit,e) \
+          if ((nelems)+1 > (size)) \
+            ((v)=cast(t *, luaM_growaux_(L,v,&(size),sizeof(t),limit,e)))
+
+#define luaM_reallocvector(L, v,oldn,n,t) \
+   ((v)=cast(t *, luaM_reallocv(L, v, oldn, n, sizeof(t))))
+
+LUAI_FUNC l_noret luaM_toobig (lua_State *L);
+
+/* not to be called directly */
+LUAI_FUNC void *luaM_realloc_ (lua_State *L, void *block, size_t oldsize,
+                                                          size_t size);
+LUAI_FUNC void *luaM_growaux_ (lua_State *L, void *block, int *size,
+                               size_t size_elem, int limit,
+                               const char *what);
+
+#endif
+
diff -ruNp src.hd/libs/lua/loadlib.c src/libs/lua/loadlib.c
--- src.hd/libs/lua/loadlib.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/loadlib.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,725 @@
+/*
+** $Id: loadlib.c,v 1.111 2012/05/30 12:33:44 roberto Exp $
+** Dynamic library loader for Lua
+** See Copyright Notice in lua.h
+**
+** This module contains an implementation of loadlib for Unix systems
+** that have dlfcn, an implementation for Windows, and a stub for other
+** systems.
+*/
+
+
+/*
+** if needed, includes windows header before everything else
+*/
+#if defined(_WIN32)
+#include <windows.h>
+#endif
+
+
+#include <stdlib.h>
+#include <string.h>
+
+
+#define loadlib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+/*
+** LUA_PATH and LUA_CPATH are the names of the environment
+** variables that Lua check to set its paths.
+*/
+#if !defined(LUA_PATH)
+#define LUA_PATH	"LUA_PATH"
+#endif
+
+#if !defined(LUA_CPATH)
+#define LUA_CPATH	"LUA_CPATH"
+#endif
+
+#define LUA_PATHSUFFIX		"_" LUA_VERSION_MAJOR "_" LUA_VERSION_MINOR
+
+#define LUA_PATHVERSION		LUA_PATH LUA_PATHSUFFIX
+#define LUA_CPATHVERSION	LUA_CPATH LUA_PATHSUFFIX
+
+/*
+** LUA_PATH_SEP is the character that separates templates in a path.
+** LUA_PATH_MARK is the string that marks the substitution points in a
+** template.
+** LUA_EXEC_DIR in a Windows path is replaced by the executable's
+** directory.
+** LUA_IGMARK is a mark to ignore all before it when building the
+** luaopen_ function name.
+*/
+#if !defined (LUA_PATH_SEP)
+#define LUA_PATH_SEP		";"
+#endif
+#if !defined (LUA_PATH_MARK)
+#define LUA_PATH_MARK		"?"
+#endif
+#if !defined (LUA_EXEC_DIR)
+#define LUA_EXEC_DIR		"!"
+#endif
+#if !defined (LUA_IGMARK)
+#define LUA_IGMARK		"-"
+#endif
+
+
+/*
+** LUA_CSUBSEP is the character that replaces dots in submodule names
+** when searching for a C loader.
+** LUA_LSUBSEP is the character that replaces dots in submodule names
+** when searching for a Lua loader.
+*/
+#if !defined(LUA_CSUBSEP)
+#define LUA_CSUBSEP		LUA_DIRSEP
+#endif
+
+#if !defined(LUA_LSUBSEP)
+#define LUA_LSUBSEP		LUA_DIRSEP
+#endif
+
+
+/* prefix for open functions in C libraries */
+#define LUA_POF		"luaopen_"
+
+/* separator for open functions in C libraries */
+#define LUA_OFSEP	"_"
+
+
+/* table (in the registry) that keeps handles for all loaded C libraries */
+#define CLIBS		"_CLIBS"
+
+#define LIB_FAIL	"open"
+
+
+/* error codes for ll_loadfunc */
+#define ERRLIB		1
+#define ERRFUNC		2
+
+#define setprogdir(L)		((void)0)
+
+
+/*
+** system-dependent functions
+*/
+static void ll_unloadlib (void *lib);
+static void *ll_load (lua_State *L, const char *path, int seeglb);
+static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym);
+
+
+
+#if defined(LUA_USE_DLOPEN)
+/*
+** {========================================================================
+** This is an implementation of loadlib based on the dlfcn interface.
+** The dlfcn interface is available in Linux, SunOS, Solaris, IRIX, FreeBSD,
+** NetBSD, AIX 4.2, HPUX 11, and  probably most other Unix flavors, at least
+** as an emulation layer on top of native functions.
+** =========================================================================
+*/
+
+#include <dlfcn.h>
+
+static void ll_unloadlib (void *lib) {
+  dlclose(lib);
+}
+
+
+static void *ll_load (lua_State *L, const char *path, int seeglb) {
+  void *lib = dlopen(path, RTLD_NOW | (seeglb ? RTLD_GLOBAL : RTLD_LOCAL));
+  if (lib == NULL) lua_pushstring(L, dlerror());
+  return lib;
+}
+
+
+static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
+  lua_CFunction f = (lua_CFunction)dlsym(lib, sym);
+  if (f == NULL) lua_pushstring(L, dlerror());
+  return f;
+}
+
+/* }====================================================== */
+
+
+
+#elif defined(LUA_DL_DLL)
+/*
+** {======================================================================
+** This is an implementation of loadlib for Windows using native functions.
+** =======================================================================
+*/
+
+#undef setprogdir
+
+/*
+** optional flags for LoadLibraryEx
+*/
+#if !defined(LUA_LLE_FLAGS)
+#define LUA_LLE_FLAGS	0
+#endif
+
+
+static void setprogdir (lua_State *L) {
+  char buff[MAX_PATH + 1];
+  char *lb;
+  DWORD nsize = sizeof(buff)/sizeof(char);
+  DWORD n = GetModuleFileNameA(NULL, buff, nsize);
+  if (n == 0 || n == nsize || (lb = strrchr(buff, '\\')) == NULL)
+    luaL_error(L, "unable to get ModuleFileName");
+  else {
+    *lb = '\0';
+    luaL_gsub(L, lua_tostring(L, -1), LUA_EXEC_DIR, buff);
+    lua_remove(L, -2);  /* remove original string */
+  }
+}
+
+
+static void pusherror (lua_State *L) {
+  int error = GetLastError();
+  char buffer[128];
+  if (FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
+      NULL, error, 0, buffer, sizeof(buffer)/sizeof(char), NULL))
+    lua_pushstring(L, buffer);
+  else
+    lua_pushfstring(L, "system error %d\n", error);
+}
+
+static void ll_unloadlib (void *lib) {
+  FreeLibrary((HMODULE)lib);
+}
+
+
+static void *ll_load (lua_State *L, const char *path, int seeglb) {
+  HMODULE lib = LoadLibraryExA(path, NULL, LUA_LLE_FLAGS);
+  (void)(seeglb);  /* not used: symbols are 'global' by default */
+  if (lib == NULL) pusherror(L);
+  return lib;
+}
+
+
+static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
+  lua_CFunction f = (lua_CFunction)GetProcAddress((HMODULE)lib, sym);
+  if (f == NULL) pusherror(L);
+  return f;
+}
+
+/* }====================================================== */
+
+
+#else
+/*
+** {======================================================
+** Fallback for other systems
+** =======================================================
+*/
+
+#undef LIB_FAIL
+#define LIB_FAIL	"absent"
+
+
+#define DLMSG	"dynamic libraries not enabled; check your Lua installation"
+
+
+static void ll_unloadlib (void *lib) {
+  (void)(lib);  /* not used */
+}
+
+
+static void *ll_load (lua_State *L, const char *path, int seeglb) {
+  (void)(path); (void)(seeglb);  /* not used */
+  lua_pushliteral(L, DLMSG);
+  return NULL;
+}
+
+
+static lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {
+  (void)(lib); (void)(sym);  /* not used */
+  lua_pushliteral(L, DLMSG);
+  return NULL;
+}
+
+/* }====================================================== */
+#endif
+
+
+static void *ll_checkclib (lua_State *L, const char *path) {
+  void *plib;
+  lua_getfield(L, LUA_REGISTRYINDEX, CLIBS);
+  lua_getfield(L, -1, path);
+  plib = lua_touserdata(L, -1);  /* plib = CLIBS[path] */
+  lua_pop(L, 2);  /* pop CLIBS table and 'plib' */
+  return plib;
+}
+
+
+static void ll_addtoclib (lua_State *L, const char *path, void *plib) {
+  lua_getfield(L, LUA_REGISTRYINDEX, CLIBS);
+  lua_pushlightuserdata(L, plib);
+  lua_pushvalue(L, -1);
+  lua_setfield(L, -3, path);  /* CLIBS[path] = plib */
+  lua_rawseti(L, -2, luaL_len(L, -2) + 1);  /* CLIBS[#CLIBS + 1] = plib */
+  lua_pop(L, 1);  /* pop CLIBS table */
+}
+
+
+/*
+** __gc tag method for CLIBS table: calls 'll_unloadlib' for all lib
+** handles in list CLIBS
+*/
+static int gctm (lua_State *L) {
+  int n = luaL_len(L, 1);
+  for (; n >= 1; n--) {  /* for each handle, in reverse order */
+    lua_rawgeti(L, 1, n);  /* get handle CLIBS[n] */
+    ll_unloadlib(lua_touserdata(L, -1));
+    lua_pop(L, 1);  /* pop handle */
+  }
+  return 0;
+}
+
+
+static int ll_loadfunc (lua_State *L, const char *path, const char *sym) {
+  void *reg = ll_checkclib(L, path);  /* check loaded C libraries */
+  if (reg == NULL) {  /* must load library? */
+    reg = ll_load(L, path, *sym == '*');
+    if (reg == NULL) return ERRLIB;  /* unable to load library */
+    ll_addtoclib(L, path, reg);
+  }
+  if (*sym == '*') {  /* loading only library (no function)? */
+    lua_pushboolean(L, 1);  /* return 'true' */
+    return 0;  /* no errors */
+  }
+  else {
+    lua_CFunction f = ll_sym(L, reg, sym);
+    if (f == NULL)
+      return ERRFUNC;  /* unable to find function */
+    lua_pushcfunction(L, f);  /* else create new function */
+    return 0;  /* no errors */
+  }
+}
+
+
+static int ll_loadlib (lua_State *L) {
+  const char *path = luaL_checkstring(L, 1);
+  const char *init = luaL_checkstring(L, 2);
+  int stat = ll_loadfunc(L, path, init);
+  if (stat == 0)  /* no errors? */
+    return 1;  /* return the loaded function */
+  else {  /* error; error message is on stack top */
+    lua_pushnil(L);
+    lua_insert(L, -2);
+    lua_pushstring(L, (stat == ERRLIB) ?  LIB_FAIL : "init");
+    return 3;  /* return nil, error message, and where */
+  }
+}
+
+
+
+/*
+** {======================================================
+** 'require' function
+** =======================================================
+*/
+
+
+static int readable (const char *filename) {
+  FILE *f = fopen(filename, "r");  /* try to open file */
+  if (f == NULL) return 0;  /* open failed */
+  fclose(f);
+  return 1;
+}
+
+
+static const char *pushnexttemplate (lua_State *L, const char *path) {
+  const char *l;
+  while (*path == *LUA_PATH_SEP) path++;  /* skip separators */
+  if (*path == '\0') return NULL;  /* no more templates */
+  l = strchr(path, *LUA_PATH_SEP);  /* find next separator */
+  if (l == NULL) l = path + strlen(path);
+  lua_pushlstring(L, path, l - path);  /* template */
+  return l;
+}
+
+
+static const char *searchpath (lua_State *L, const char *name,
+                                             const char *path,
+                                             const char *sep,
+                                             const char *dirsep) {
+  luaL_Buffer msg;  /* to build error message */
+  luaL_buffinit(L, &msg);
+  if (*sep != '\0')  /* non-empty separator? */
+    name = luaL_gsub(L, name, sep, dirsep);  /* replace it by 'dirsep' */
+  while ((path = pushnexttemplate(L, path)) != NULL) {
+    const char *filename = luaL_gsub(L, lua_tostring(L, -1),
+                                     LUA_PATH_MARK, name);
+    lua_remove(L, -2);  /* remove path template */
+    if (readable(filename))  /* does file exist and is readable? */
+      return filename;  /* return that file name */
+    lua_pushfstring(L, "\n\tno file " LUA_QS, filename);
+    lua_remove(L, -2);  /* remove file name */
+    luaL_addvalue(&msg);  /* concatenate error msg. entry */
+  }
+  luaL_pushresult(&msg);  /* create error message */
+  return NULL;  /* not found */
+}
+
+
+static int ll_searchpath (lua_State *L) {
+  const char *f = searchpath(L, luaL_checkstring(L, 1),
+                                luaL_checkstring(L, 2),
+                                luaL_optstring(L, 3, "."),
+                                luaL_optstring(L, 4, LUA_DIRSEP));
+  if (f != NULL) return 1;
+  else {  /* error message is on top of the stack */
+    lua_pushnil(L);
+    lua_insert(L, -2);
+    return 2;  /* return nil + error message */
+  }
+}
+
+
+static const char *findfile (lua_State *L, const char *name,
+                                           const char *pname,
+                                           const char *dirsep) {
+  const char *path;
+  lua_getfield(L, lua_upvalueindex(1), pname);
+  path = lua_tostring(L, -1);
+  if (path == NULL)
+    luaL_error(L, LUA_QL("package.%s") " must be a string", pname);
+  return searchpath(L, name, path, ".", dirsep);
+}
+
+
+static int checkload (lua_State *L, int stat, const char *filename) {
+  if (stat) {  /* module loaded successfully? */
+    lua_pushstring(L, filename);  /* will be 2nd argument to module */
+    return 2;  /* return open function and file name */
+  }
+  else
+    return luaL_error(L, "error loading module " LUA_QS
+                         " from file " LUA_QS ":\n\t%s",
+                          lua_tostring(L, 1), filename, lua_tostring(L, -1));
+}
+
+
+static int searcher_Lua (lua_State *L) {
+  const char *filename;
+  const char *name = luaL_checkstring(L, 1);
+  filename = findfile(L, name, "path", LUA_LSUBSEP);
+  if (filename == NULL) return 1;  /* module not found in this path */
+  return checkload(L, (luaL_loadfile(L, filename) == LUA_OK), filename);
+}
+
+
+static int loadfunc (lua_State *L, const char *filename, const char *modname) {
+  const char *funcname;
+  const char *mark;
+  modname = luaL_gsub(L, modname, ".", LUA_OFSEP);
+  mark = strchr(modname, *LUA_IGMARK);
+  if (mark) {
+    int stat;
+    funcname = lua_pushlstring(L, modname, mark - modname);
+    funcname = lua_pushfstring(L, LUA_POF"%s", funcname);
+    stat = ll_loadfunc(L, filename, funcname);
+    if (stat != ERRFUNC) return stat;
+    modname = mark + 1;  /* else go ahead and try old-style name */
+  }
+  funcname = lua_pushfstring(L, LUA_POF"%s", modname);
+  return ll_loadfunc(L, filename, funcname);
+}
+
+
+static int searcher_C (lua_State *L) {
+  const char *name = luaL_checkstring(L, 1);
+  const char *filename = findfile(L, name, "cpath", LUA_CSUBSEP);
+  if (filename == NULL) return 1;  /* module not found in this path */
+  return checkload(L, (loadfunc(L, filename, name) == 0), filename);
+}
+
+
+static int searcher_Croot (lua_State *L) {
+  const char *filename;
+  const char *name = luaL_checkstring(L, 1);
+  const char *p = strchr(name, '.');
+  int stat;
+  if (p == NULL) return 0;  /* is root */
+  lua_pushlstring(L, name, p - name);
+  filename = findfile(L, lua_tostring(L, -1), "cpath", LUA_CSUBSEP);
+  if (filename == NULL) return 1;  /* root not found */
+  if ((stat = loadfunc(L, filename, name)) != 0) {
+    if (stat != ERRFUNC)
+      return checkload(L, 0, filename);  /* real error */
+    else {  /* open function not found */
+      lua_pushfstring(L, "\n\tno module " LUA_QS " in file " LUA_QS,
+                         name, filename);
+      return 1;
+    }
+  }
+  lua_pushstring(L, filename);  /* will be 2nd argument to module */
+  return 2;
+}
+
+
+static int searcher_preload (lua_State *L) {
+  const char *name = luaL_checkstring(L, 1);
+  lua_getfield(L, LUA_REGISTRYINDEX, "_PRELOAD");
+  lua_getfield(L, -1, name);
+  if (lua_isnil(L, -1))  /* not found? */
+    lua_pushfstring(L, "\n\tno field package.preload['%s']", name);
+  return 1;
+}
+
+
+static void findloader (lua_State *L, const char *name) {
+  int i;
+  luaL_Buffer msg;  /* to build error message */
+  luaL_buffinit(L, &msg);
+  lua_getfield(L, lua_upvalueindex(1), "searchers");  /* will be at index 3 */
+  if (!lua_istable(L, 3))
+    luaL_error(L, LUA_QL("package.searchers") " must be a table");
+  /*  iterate over available searchers to find a loader */
+  for (i = 1; ; i++) {
+    lua_rawgeti(L, 3, i);  /* get a searcher */
+    if (lua_isnil(L, -1)) {  /* no more searchers? */
+      lua_pop(L, 1);  /* remove nil */
+      luaL_pushresult(&msg);  /* create error message */
+      luaL_error(L, "module " LUA_QS " not found:%s",
+                    name, lua_tostring(L, -1));
+    }
+    lua_pushstring(L, name);
+    lua_call(L, 1, 2);  /* call it */
+    if (lua_isfunction(L, -2))  /* did it find a loader? */
+      return;  /* module loader found */
+    else if (lua_isstring(L, -2)) {  /* searcher returned error message? */
+      lua_pop(L, 1);  /* remove extra return */
+      luaL_addvalue(&msg);  /* concatenate error message */
+    }
+    else
+      lua_pop(L, 2);  /* remove both returns */
+  }
+}
+
+
+static int ll_require (lua_State *L) {
+  const char *name = luaL_checkstring(L, 1);
+  lua_settop(L, 1);  /* _LOADED table will be at index 2 */
+  lua_getfield(L, LUA_REGISTRYINDEX, "_LOADED");
+  lua_getfield(L, 2, name);  /* _LOADED[name] */
+  if (lua_toboolean(L, -1))  /* is it there? */
+    return 1;  /* package is already loaded */
+  /* else must load package */
+  lua_pop(L, 1);  /* remove 'getfield' result */
+  findloader(L, name);
+  lua_pushstring(L, name);  /* pass name as argument to module loader */
+  lua_insert(L, -2);  /* name is 1st argument (before search data) */
+  lua_call(L, 2, 1);  /* run loader to load module */
+  if (!lua_isnil(L, -1))  /* non-nil return? */
+    lua_setfield(L, 2, name);  /* _LOADED[name] = returned value */
+  lua_getfield(L, 2, name);
+  if (lua_isnil(L, -1)) {   /* module did not set a value? */
+    lua_pushboolean(L, 1);  /* use true as result */
+    lua_pushvalue(L, -1);  /* extra copy to be returned */
+    lua_setfield(L, 2, name);  /* _LOADED[name] = true */
+  }
+  return 1;
+}
+
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** 'module' function
+** =======================================================
+*/
+#if defined(LUA_COMPAT_MODULE)
+
+/*
+** changes the environment variable of calling function
+*/
+static void set_env (lua_State *L) {
+  lua_Debug ar;
+  if (lua_getstack(L, 1, &ar) == 0 ||
+      lua_getinfo(L, "f", &ar) == 0 ||  /* get calling function */
+      lua_iscfunction(L, -1))
+    luaL_error(L, LUA_QL("module") " not called from a Lua function");
+  lua_pushvalue(L, -2);  /* copy new environment table to top */
+  lua_setupvalue(L, -2, 1);
+  lua_pop(L, 1);  /* remove function */
+}
+
+
+static void dooptions (lua_State *L, int n) {
+  int i;
+  for (i = 2; i <= n; i++) {
+    if (lua_isfunction(L, i)) {  /* avoid 'calling' extra info. */
+      lua_pushvalue(L, i);  /* get option (a function) */
+      lua_pushvalue(L, -2);  /* module */
+      lua_call(L, 1, 0);
+    }
+  }
+}
+
+
+static void modinit (lua_State *L, const char *modname) {
+  const char *dot;
+  lua_pushvalue(L, -1);
+  lua_setfield(L, -2, "_M");  /* module._M = module */
+  lua_pushstring(L, modname);
+  lua_setfield(L, -2, "_NAME");
+  dot = strrchr(modname, '.');  /* look for last dot in module name */
+  if (dot == NULL) dot = modname;
+  else dot++;
+  /* set _PACKAGE as package name (full module name minus last part) */
+  lua_pushlstring(L, modname, dot - modname);
+  lua_setfield(L, -2, "_PACKAGE");
+}
+
+
+static int ll_module (lua_State *L) {
+  const char *modname = luaL_checkstring(L, 1);
+  int lastarg = lua_gettop(L);  /* last parameter */
+  luaL_pushmodule(L, modname, 1);  /* get/create module table */
+  /* check whether table already has a _NAME field */
+  lua_getfield(L, -1, "_NAME");
+  if (!lua_isnil(L, -1))  /* is table an initialized module? */
+    lua_pop(L, 1);
+  else {  /* no; initialize it */
+    lua_pop(L, 1);
+    modinit(L, modname);
+  }
+  lua_pushvalue(L, -1);
+  set_env(L);
+  dooptions(L, lastarg);
+  return 1;
+}
+
+
+static int ll_seeall (lua_State *L) {
+  luaL_checktype(L, 1, LUA_TTABLE);
+  if (!lua_getmetatable(L, 1)) {
+    lua_createtable(L, 0, 1); /* create new metatable */
+    lua_pushvalue(L, -1);
+    lua_setmetatable(L, 1);
+  }
+  lua_pushglobaltable(L);
+  lua_setfield(L, -2, "__index");  /* mt.__index = _G */
+  return 0;
+}
+
+#endif
+/* }====================================================== */
+
+
+
+/* auxiliary mark (for internal use) */
+#define AUXMARK		"\1"
+
+
+/*
+** return registry.LUA_NOENV as a boolean
+*/
+static int noenv (lua_State *L) {
+  int b;
+  lua_getfield(L, LUA_REGISTRYINDEX, "LUA_NOENV");
+  b = lua_toboolean(L, -1);
+  lua_pop(L, 1);  /* remove value */
+  return b;
+}
+
+
+static void setpath (lua_State *L, const char *fieldname, const char *envname1,
+                                   const char *envname2, const char *def) {
+  const char *path = getenv(envname1);
+  if (path == NULL)  /* no environment variable? */
+    path = getenv(envname2);  /* try alternative name */
+  if (path == NULL || noenv(L))  /* no environment variable? */
+    lua_pushstring(L, def);  /* use default */
+  else {
+    /* replace ";;" by ";AUXMARK;" and then AUXMARK by default path */
+    path = luaL_gsub(L, path, LUA_PATH_SEP LUA_PATH_SEP,
+                              LUA_PATH_SEP AUXMARK LUA_PATH_SEP);
+    luaL_gsub(L, path, AUXMARK, def);
+    lua_remove(L, -2);
+  }
+  setprogdir(L);
+  lua_setfield(L, -2, fieldname);
+}
+
+
+static const luaL_Reg pk_funcs[] = {
+  {"loadlib", ll_loadlib},
+  {"searchpath", ll_searchpath},
+#if defined(LUA_COMPAT_MODULE)
+  {"seeall", ll_seeall},
+#endif
+  {NULL, NULL}
+};
+
+
+static const luaL_Reg ll_funcs[] = {
+#if defined(LUA_COMPAT_MODULE)
+  {"module", ll_module},
+#endif
+  {"require", ll_require},
+  {NULL, NULL}
+};
+
+
+static void createsearcherstable (lua_State *L) {
+  static const lua_CFunction searchers[] =
+    {searcher_preload, searcher_Lua, searcher_C, searcher_Croot, NULL};
+  int i;
+  /* create 'searchers' table */
+  lua_createtable(L, sizeof(searchers)/sizeof(searchers[0]) - 1, 0);
+  /* fill it with pre-defined searchers */
+  for (i=0; searchers[i] != NULL; i++) {
+    lua_pushvalue(L, -2);  /* set 'package' as upvalue for all searchers */
+    lua_pushcclosure(L, searchers[i], 1);
+    lua_rawseti(L, -2, i+1);
+  }
+}
+
+
+LUAMOD_API int luaopen_package (lua_State *L) {
+  /* create table CLIBS to keep track of loaded C libraries */
+  luaL_getsubtable(L, LUA_REGISTRYINDEX, CLIBS);
+  lua_createtable(L, 0, 1);  /* metatable for CLIBS */
+  lua_pushcfunction(L, gctm);
+  lua_setfield(L, -2, "__gc");  /* set finalizer for CLIBS table */
+  lua_setmetatable(L, -2);
+  /* create `package' table */
+  luaL_newlib(L, pk_funcs);
+  createsearcherstable(L);
+#if defined(LUA_COMPAT_LOADERS)
+  lua_pushvalue(L, -1);  /* make a copy of 'searchers' table */
+  lua_setfield(L, -3, "loaders");  /* put it in field `loaders' */
+#endif
+  lua_setfield(L, -2, "searchers");  /* put it in field 'searchers' */
+  /* set field 'path' */
+  setpath(L, "path", LUA_PATHVERSION, LUA_PATH, LUA_PATH_DEFAULT);
+  /* set field 'cpath' */
+  setpath(L, "cpath", LUA_CPATHVERSION, LUA_CPATH, LUA_CPATH_DEFAULT);
+  /* store config information */
+  lua_pushliteral(L, LUA_DIRSEP "\n" LUA_PATH_SEP "\n" LUA_PATH_MARK "\n"
+                     LUA_EXEC_DIR "\n" LUA_IGMARK "\n");
+  lua_setfield(L, -2, "config");
+  /* set field `loaded' */
+  luaL_getsubtable(L, LUA_REGISTRYINDEX, "_LOADED");
+  lua_setfield(L, -2, "loaded");
+  /* set field `preload' */
+  luaL_getsubtable(L, LUA_REGISTRYINDEX, "_PRELOAD");
+  lua_setfield(L, -2, "preload");
+  lua_pushglobaltable(L);
+  lua_pushvalue(L, -2);  /* set 'package' as upvalue for next lib */
+  luaL_setfuncs(L, ll_funcs, 1);  /* open lib into global table */
+  lua_pop(L, 1);  /* pop global table */
+  return 1;  /* return 'package' table */
+}
+
diff -ruNp src.hd/libs/lua/lobject.c src/libs/lua/lobject.c
--- src.hd/libs/lua/lobject.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lobject.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,287 @@
+/*
+** $Id: lobject.c,v 2.58 2013/02/20 14:08:56 roberto Exp $
+** Some generic functions over Lua objects
+** See Copyright Notice in lua.h
+*/
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define lobject_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lctype.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "lvm.h"
+
+
+
+LUAI_DDEF const TValue luaO_nilobject_ = {NILCONSTANT};
+
+
+/*
+** converts an integer to a "floating point byte", represented as
+** (eeeeexxx), where the real value is (1xxx) * 2^(eeeee - 1) if
+** eeeee != 0 and (xxx) otherwise.
+*/
+int luaO_int2fb (unsigned int x) {
+  int e = 0;  /* exponent */
+  if (x < 8) return x;
+  while (x >= 0x10) {
+    x = (x+1) >> 1;
+    e++;
+  }
+  return ((e+1) << 3) | (cast_int(x) - 8);
+}
+
+
+/* converts back */
+int luaO_fb2int (int x) {
+  int e = (x >> 3) & 0x1f;
+  if (e == 0) return x;
+  else return ((x & 7) + 8) << (e - 1);
+}
+
+
+int luaO_ceillog2 (unsigned int x) {
+  static const lu_byte log_2[256] = {
+    0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
+    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
+    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
+    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
+    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8
+  };
+  int l = 0;
+  x--;
+  while (x >= 256) { l += 8; x >>= 8; }
+  return l + log_2[x];
+}
+
+
+lua_Number luaO_arith (int op, lua_Number v1, lua_Number v2) {
+  switch (op) {
+    case LUA_OPADD: return luai_numadd(NULL, v1, v2);
+    case LUA_OPSUB: return luai_numsub(NULL, v1, v2);
+    case LUA_OPMUL: return luai_nummul(NULL, v1, v2);
+    case LUA_OPDIV: return luai_numdiv(NULL, v1, v2);
+    case LUA_OPMOD: return luai_nummod(NULL, v1, v2);
+    case LUA_OPPOW: return luai_numpow(NULL, v1, v2);
+    case LUA_OPUNM: return luai_numunm(NULL, v1);
+    default: lua_assert(0); return 0;
+  }
+}
+
+
+int luaO_hexavalue (int c) {
+  if (lisdigit(c)) return c - '0';
+  else return ltolower(c) - 'a' + 10;
+}
+
+
+#if !defined(lua_strx2number)
+
+#include <math.h>
+
+
+static int isneg (const char **s) {
+  if (**s == '-') { (*s)++; return 1; }
+  else if (**s == '+') (*s)++;
+  return 0;
+}
+
+
+static lua_Number readhexa (const char **s, lua_Number r, int *count) {
+  for (; lisxdigit(cast_uchar(**s)); (*s)++) {  /* read integer part */
+    r = (r * cast_num(16.0)) + cast_num(luaO_hexavalue(cast_uchar(**s)));
+    (*count)++;
+  }
+  return r;
+}
+
+
+/*
+** convert an hexadecimal numeric string to a number, following
+** C99 specification for 'strtod'
+*/
+static lua_Number lua_strx2number (const char *s, char **endptr) {
+  lua_Number r = 0.0;
+  int e = 0, i = 0;
+  int neg = 0;  /* 1 if number is negative */
+  *endptr = cast(char *, s);  /* nothing is valid yet */
+  while (lisspace(cast_uchar(*s))) s++;  /* skip initial spaces */
+  neg = isneg(&s);  /* check signal */
+  if (!(*s == '0' && (*(s + 1) == 'x' || *(s + 1) == 'X')))  /* check '0x' */
+    return 0.0;  /* invalid format (no '0x') */
+  s += 2;  /* skip '0x' */
+  r = readhexa(&s, r, &i);  /* read integer part */
+  if (*s == '.') {
+    s++;  /* skip dot */
+    r = readhexa(&s, r, &e);  /* read fractional part */
+  }
+  if (i == 0 && e == 0)
+    return 0.0;  /* invalid format (no digit) */
+  e *= -4;  /* each fractional digit divides value by 2^-4 */
+  *endptr = cast(char *, s);  /* valid up to here */
+  if (*s == 'p' || *s == 'P') {  /* exponent part? */
+    int exp1 = 0;
+    int neg1;
+    s++;  /* skip 'p' */
+    neg1 = isneg(&s);  /* signal */
+    if (!lisdigit(cast_uchar(*s)))
+      goto ret;  /* must have at least one digit */
+    while (lisdigit(cast_uchar(*s)))  /* read exponent */
+      exp1 = exp1 * 10 + *(s++) - '0';
+    if (neg1) exp1 = -exp1;
+    e += exp1;
+  }
+  *endptr = cast(char *, s);  /* valid up to here */
+ ret:
+  if (neg) r = -r;
+  return l_mathop(ldexp)(r, e);
+}
+
+#endif
+
+
+int luaO_str2d (const char *s, size_t len, lua_Number *result) {
+  char *endptr;
+  if (strpbrk(s, "nN"))  /* reject 'inf' and 'nan' */
+    return 0;
+  else if (strpbrk(s, "xX"))  /* hexa? */
+    *result = lua_strx2number(s, &endptr);
+  else
+    *result = lua_str2number(s, &endptr);
+  if (endptr == s) return 0;  /* nothing recognized */
+  while (lisspace(cast_uchar(*endptr))) endptr++;
+  return (endptr == s + len);  /* OK if no trailing characters */
+}
+
+
+
+static void pushstr (lua_State *L, const char *str, size_t l) {
+  setsvalue2s(L, L->top++, luaS_newlstr(L, str, l));
+}
+
+
+/* this function handles only `%d', `%c', %f, %p, and `%s' formats */
+const char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp) {
+  int n = 0;
+  for (;;) {
+    const char *e = strchr(fmt, '%');
+    if (e == NULL) break;
+    luaD_checkstack(L, 2);  /* fmt + item */
+    pushstr(L, fmt, e - fmt);
+    switch (*(e+1)) {
+      case 's': {
+        const char *s = va_arg(argp, char *);
+        if (s == NULL) s = "(null)";
+        pushstr(L, s, strlen(s));
+        break;
+      }
+      case 'c': {
+        char buff;
+        buff = cast(char, va_arg(argp, int));
+        pushstr(L, &buff, 1);
+        break;
+      }
+      case 'd': {
+        setnvalue(L->top++, cast_num(va_arg(argp, int)));
+        break;
+      }
+      case 'f': {
+        setnvalue(L->top++, cast_num(va_arg(argp, l_uacNumber)));
+        break;
+      }
+      case 'p': {
+        char buff[4*sizeof(void *) + 8]; /* should be enough space for a `%p' */
+        int l = sprintf(buff, "%p", va_arg(argp, void *));
+        pushstr(L, buff, l);
+        break;
+      }
+      case '%': {
+        pushstr(L, "%", 1);
+        break;
+      }
+      default: {
+        luaG_runerror(L,
+            "invalid option " LUA_QL("%%%c") " to " LUA_QL("lua_pushfstring"),
+            *(e + 1));
+      }
+    }
+    n += 2;
+    fmt = e+2;
+  }
+  luaD_checkstack(L, 1);
+  pushstr(L, fmt, strlen(fmt));
+  if (n > 0) luaV_concat(L, n + 1);
+  return svalue(L->top - 1);
+}
+
+
+const char *luaO_pushfstring (lua_State *L, const char *fmt, ...) {
+  const char *msg;
+  va_list argp;
+  va_start(argp, fmt);
+  msg = luaO_pushvfstring(L, fmt, argp);
+  va_end(argp);
+  return msg;
+}
+
+
+/* number of chars of a literal string without the ending \0 */
+#define LL(x)	(sizeof(x)/sizeof(char) - 1)
+
+#define RETS	"..."
+#define PRE	"[string \""
+#define POS	"\"]"
+
+#define addstr(a,b,l)	( memcpy(a,b,(l) * sizeof(char)), a += (l) )
+
+void luaO_chunkid (char *out, const char *source, size_t bufflen) {
+  size_t l = strlen(source);
+  if (*source == '=') {  /* 'literal' source */
+    if (l <= bufflen)  /* small enough? */
+      memcpy(out, source + 1, l * sizeof(char));
+    else {  /* truncate it */
+      addstr(out, source + 1, bufflen - 1);
+      *out = '\0';
+    }
+  }
+  else if (*source == '@') {  /* file name */
+    if (l <= bufflen)  /* small enough? */
+      memcpy(out, source + 1, l * sizeof(char));
+    else {  /* add '...' before rest of name */
+      addstr(out, RETS, LL(RETS));
+      bufflen -= LL(RETS);
+      memcpy(out, source + 1 + l - bufflen, bufflen * sizeof(char));
+    }
+  }
+  else {  /* string; format as [string "source"] */
+    const char *nl = strchr(source, '\n');  /* find first new line (if any) */
+    addstr(out, PRE, LL(PRE));  /* add prefix */
+    bufflen -= LL(PRE RETS POS) + 1;  /* save space for prefix+suffix+'\0' */
+    if (l < bufflen && nl == NULL) {  /* small one-line source? */
+      addstr(out, source, l);  /* keep it */
+    }
+    else {
+      if (nl != NULL) l = nl - source;  /* stop at first newline */
+      if (l > bufflen) l = bufflen;
+      addstr(out, source, l);
+      addstr(out, RETS, LL(RETS));
+    }
+    memcpy(out, POS, (LL(POS) + 1) * sizeof(char));
+  }
+}
+
diff -ruNp src.hd/libs/lua/lobject.h src/libs/lua/lobject.h
--- src.hd/libs/lua/lobject.h	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lobject.h	2017-12-29 00:57:40 -0800
@@ -0,0 +1,607 @@
+/*
+** $Id: lobject.h,v 2.71 2012/09/11 18:21:44 roberto Exp $
+** Type definitions for Lua objects
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lobject_h
+#define lobject_h
+
+
+#include <stdarg.h>
+
+
+#include "llimits.h"
+#include "lua.h"
+
+
+/*
+** Extra tags for non-values
+*/
+#define LUA_TPROTO	LUA_NUMTAGS
+#define LUA_TUPVAL	(LUA_NUMTAGS+1)
+#define LUA_TDEADKEY	(LUA_NUMTAGS+2)
+
+/*
+** number of all possible tags (including LUA_TNONE but excluding DEADKEY)
+*/
+#define LUA_TOTALTAGS	(LUA_TUPVAL+2)
+
+
+/*
+** tags for Tagged Values have the following use of bits:
+** bits 0-3: actual tag (a LUA_T* value)
+** bits 4-5: variant bits
+** bit 6: whether value is collectable
+*/
+
+#define VARBITS		(3 << 4)
+
+
+/*
+** LUA_TFUNCTION variants:
+** 0 - Lua function
+** 1 - light C function
+** 2 - regular C function (closure)
+*/
+
+/* Variant tags for functions */
+#define LUA_TLCL	(LUA_TFUNCTION | (0 << 4))  /* Lua closure */
+#define LUA_TLCF	(LUA_TFUNCTION | (1 << 4))  /* light C function */
+#define LUA_TCCL	(LUA_TFUNCTION | (2 << 4))  /* C closure */
+
+
+/* Variant tags for strings */
+#define LUA_TSHRSTR	(LUA_TSTRING | (0 << 4))  /* short strings */
+#define LUA_TLNGSTR	(LUA_TSTRING | (1 << 4))  /* long strings */
+
+
+/* Bit mark for collectable types */
+#define BIT_ISCOLLECTABLE	(1 << 6)
+
+/* mark a tag as collectable */
+#define ctb(t)			((t) | BIT_ISCOLLECTABLE)
+
+
+/*
+** Union of all collectable objects
+*/
+typedef union GCObject GCObject;
+
+
+/*
+** Common Header for all collectable objects (in macro form, to be
+** included in other objects)
+*/
+#define CommonHeader	GCObject *next; lu_byte tt; lu_byte marked
+
+
+/*
+** Common header in struct form
+*/
+typedef struct GCheader {
+  CommonHeader;
+} GCheader;
+
+
+
+/*
+** Union of all Lua values
+*/
+typedef union Value Value;
+
+
+#define numfield	lua_Number n;    /* numbers */
+
+
+
+/*
+** Tagged Values. This is the basic representation of values in Lua,
+** an actual value plus a tag with its type.
+*/
+
+#define TValuefields	Value value_; int tt_
+
+typedef struct lua_TValue TValue;
+
+
+/* macro defining a nil value */
+#define NILCONSTANT	{NULL}, LUA_TNIL
+
+
+#define val_(o)		((o)->value_)
+#define num_(o)		(val_(o).n)
+
+
+/* raw type tag of a TValue */
+#define rttype(o)	((o)->tt_)
+
+/* tag with no variants (bits 0-3) */
+#define novariant(x)	((x) & 0x0F)
+
+/* type tag of a TValue (bits 0-3 for tags + variant bits 4-5) */
+#define ttype(o)	(rttype(o) & 0x3F)
+
+/* type tag of a TValue with no variants (bits 0-3) */
+#define ttypenv(o)	(novariant(rttype(o)))
+
+
+/* Macros to test type */
+#define checktag(o,t)		(rttype(o) == (t))
+#define checktype(o,t)		(ttypenv(o) == (t))
+#define ttisnumber(o)		checktag((o), LUA_TNUMBER)
+#define ttisnil(o)		checktag((o), LUA_TNIL)
+#define ttisboolean(o)		checktag((o), LUA_TBOOLEAN)
+#define ttislightuserdata(o)	checktag((o), LUA_TLIGHTUSERDATA)
+#define ttisstring(o)		checktype((o), LUA_TSTRING)
+#define ttisshrstring(o)	checktag((o), ctb(LUA_TSHRSTR))
+#define ttislngstring(o)	checktag((o), ctb(LUA_TLNGSTR))
+#define ttistable(o)		checktag((o), ctb(LUA_TTABLE))
+#define ttisfunction(o)		checktype(o, LUA_TFUNCTION)
+#define ttisclosure(o)		((rttype(o) & 0x1F) == LUA_TFUNCTION)
+#define ttisCclosure(o)		checktag((o), ctb(LUA_TCCL))
+#define ttisLclosure(o)		checktag((o), ctb(LUA_TLCL))
+#define ttislcf(o)		checktag((o), LUA_TLCF)
+#define ttisuserdata(o)		checktag((o), ctb(LUA_TUSERDATA))
+#define ttisthread(o)		checktag((o), ctb(LUA_TTHREAD))
+#define ttisdeadkey(o)		checktag((o), LUA_TDEADKEY)
+
+#define ttisequal(o1,o2)	(rttype(o1) == rttype(o2))
+
+/* Macros to access values */
+#define nvalue(o)	check_exp(ttisnumber(o), num_(o))
+#define gcvalue(o)	check_exp(iscollectable(o), val_(o).gc)
+#define pvalue(o)	check_exp(ttislightuserdata(o), val_(o).p)
+#define rawtsvalue(o)	check_exp(ttisstring(o), &val_(o).gc->ts)
+#define tsvalue(o)	(&rawtsvalue(o)->tsv)
+#define rawuvalue(o)	check_exp(ttisuserdata(o), &val_(o).gc->u)
+#define uvalue(o)	(&rawuvalue(o)->uv)
+#define clvalue(o)	check_exp(ttisclosure(o), &val_(o).gc->cl)
+#define clLvalue(o)	check_exp(ttisLclosure(o), &val_(o).gc->cl.l)
+#define clCvalue(o)	check_exp(ttisCclosure(o), &val_(o).gc->cl.c)
+#define fvalue(o)	check_exp(ttislcf(o), val_(o).f)
+#define hvalue(o)	check_exp(ttistable(o), &val_(o).gc->h)
+#define bvalue(o)	check_exp(ttisboolean(o), val_(o).b)
+#define thvalue(o)	check_exp(ttisthread(o), &val_(o).gc->th)
+/* a dead value may get the 'gc' field, but cannot access its contents */
+#define deadvalue(o)	check_exp(ttisdeadkey(o), cast(void *, val_(o).gc))
+
+#define l_isfalse(o)	(ttisnil(o) || (ttisboolean(o) && bvalue(o) == 0))
+
+
+#define iscollectable(o)	(rttype(o) & BIT_ISCOLLECTABLE)
+
+
+/* Macros for internal tests */
+#define righttt(obj)		(ttype(obj) == gcvalue(obj)->gch.tt)
+
+#define checkliveness(g,obj) \
+	lua_longassert(!iscollectable(obj) || \
+			(righttt(obj) && !isdead(g,gcvalue(obj))))
+
+
+/* Macros to set values */
+#define settt_(o,t)	((o)->tt_=(t))
+
+#define setnvalue(obj,x) \
+  { TValue *io=(obj); num_(io)=(x); settt_(io, LUA_TNUMBER); }
+
+#define setnilvalue(obj) settt_(obj, LUA_TNIL)
+
+#define setfvalue(obj,x) \
+  { TValue *io=(obj); val_(io).f=(x); settt_(io, LUA_TLCF); }
+
+#define setpvalue(obj,x) \
+  { TValue *io=(obj); val_(io).p=(x); settt_(io, LUA_TLIGHTUSERDATA); }
+
+#define setbvalue(obj,x) \
+  { TValue *io=(obj); val_(io).b=(x); settt_(io, LUA_TBOOLEAN); }
+
+#define setgcovalue(L,obj,x) \
+  { TValue *io=(obj); GCObject *i_g=(x); \
+    val_(io).gc=i_g; settt_(io, ctb(gch(i_g)->tt)); }
+
+#define setsvalue(L,obj,x) \
+  { TValue *io=(obj); \
+    TString *x_ = (x); \
+    val_(io).gc=cast(GCObject *, x_); settt_(io, ctb(x_->tsv.tt)); \
+    checkliveness(G(L),io); }
+
+#define setuvalue(L,obj,x) \
+  { TValue *io=(obj); \
+    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TUSERDATA)); \
+    checkliveness(G(L),io); }
+
+#define setthvalue(L,obj,x) \
+  { TValue *io=(obj); \
+    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TTHREAD)); \
+    checkliveness(G(L),io); }
+
+#define setclLvalue(L,obj,x) \
+  { TValue *io=(obj); \
+    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TLCL)); \
+    checkliveness(G(L),io); }
+
+#define setclCvalue(L,obj,x) \
+  { TValue *io=(obj); \
+    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TCCL)); \
+    checkliveness(G(L),io); }
+
+#define sethvalue(L,obj,x) \
+  { TValue *io=(obj); \
+    val_(io).gc=cast(GCObject *, (x)); settt_(io, ctb(LUA_TTABLE)); \
+    checkliveness(G(L),io); }
+
+#define setdeadvalue(obj)	settt_(obj, LUA_TDEADKEY)
+
+
+
+#define setobj(L,obj1,obj2) \
+	{ const TValue *io2=(obj2); TValue *io1=(obj1); \
+	  io1->value_ = io2->value_; io1->tt_ = io2->tt_; \
+	  checkliveness(G(L),io1); }
+
+
+/*
+** different types of assignments, according to destination
+*/
+
+/* from stack to (same) stack */
+#define setobjs2s	setobj
+/* to stack (not from same stack) */
+#define setobj2s	setobj
+#define setsvalue2s	setsvalue
+#define sethvalue2s	sethvalue
+#define setptvalue2s	setptvalue
+/* from table to same table */
+#define setobjt2t	setobj
+/* to table */
+#define setobj2t	setobj
+/* to new object */
+#define setobj2n	setobj
+#define setsvalue2n	setsvalue
+
+
+/* check whether a number is valid (useful only for NaN trick) */
+#define luai_checknum(L,o,c)	{ /* empty */ }
+
+
+/*
+** {======================================================
+** NaN Trick
+** =======================================================
+*/
+#if defined(LUA_NANTRICK)
+
+/*
+** numbers are represented in the 'd_' field. All other values have the
+** value (NNMARK | tag) in 'tt__'. A number with such pattern would be
+** a "signaled NaN", which is never generated by regular operations by
+** the CPU (nor by 'strtod')
+*/
+
+/* allows for external implementation for part of the trick */
+#if !defined(NNMARK)	/* { */
+
+
+#if !defined(LUA_IEEEENDIAN)
+#error option 'LUA_NANTRICK' needs 'LUA_IEEEENDIAN'
+#endif
+
+
+#define NNMARK		0x7FF7A500
+#define NNMASK		0x7FFFFF00
+
+#undef TValuefields
+#undef NILCONSTANT
+
+#if (LUA_IEEEENDIAN == 0)	/* { */
+
+/* little endian */
+#define TValuefields  \
+	union { struct { Value v__; int tt__; } i; double d__; } u
+#define NILCONSTANT	{{{NULL}, tag2tt(LUA_TNIL)}}
+/* field-access macros */
+#define v_(o)		((o)->u.i.v__)
+#define d_(o)		((o)->u.d__)
+#define tt_(o)		((o)->u.i.tt__)
+
+#else				/* }{ */
+
+/* big endian */
+#define TValuefields  \
+	union { struct { int tt__; Value v__; } i; double d__; } u
+#define NILCONSTANT	{{tag2tt(LUA_TNIL), {NULL}}}
+/* field-access macros */
+#define v_(o)		((o)->u.i.v__)
+#define d_(o)		((o)->u.d__)
+#define tt_(o)		((o)->u.i.tt__)
+
+#endif				/* } */
+
+#endif			/* } */
+
+
+/* correspondence with standard representation */
+#undef val_
+#define val_(o)		v_(o)
+#undef num_
+#define num_(o)		d_(o)
+
+
+#undef numfield
+#define numfield	/* no such field; numbers are the entire struct */
+
+/* basic check to distinguish numbers from non-numbers */
+#undef ttisnumber
+#define ttisnumber(o)	((tt_(o) & NNMASK) != NNMARK)
+
+#define tag2tt(t)	(NNMARK | (t))
+
+#undef rttype
+#define rttype(o)	(ttisnumber(o) ? LUA_TNUMBER : tt_(o) & 0xff)
+
+#undef settt_
+#define settt_(o,t)	(tt_(o) = tag2tt(t))
+
+#undef setnvalue
+#define setnvalue(obj,x) \
+	{ TValue *io_=(obj); num_(io_)=(x); lua_assert(ttisnumber(io_)); }
+
+#undef setobj
+#define setobj(L,obj1,obj2) \
+	{ const TValue *o2_=(obj2); TValue *o1_=(obj1); \
+	  o1_->u = o2_->u; \
+	  checkliveness(G(L),o1_); }
+
+
+/*
+** these redefinitions are not mandatory, but these forms are more efficient
+*/
+
+#undef checktag
+#undef checktype
+#define checktag(o,t)	(tt_(o) == tag2tt(t))
+#define checktype(o,t)	(ctb(tt_(o) | VARBITS) == ctb(tag2tt(t) | VARBITS))
+
+#undef ttisequal
+#define ttisequal(o1,o2)  \
+	(ttisnumber(o1) ? ttisnumber(o2) : (tt_(o1) == tt_(o2)))
+
+
+#undef luai_checknum
+#define luai_checknum(L,o,c)	{ if (!ttisnumber(o)) c; }
+
+#endif
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** types and prototypes
+** =======================================================
+*/
+
+
+union Value {
+  GCObject *gc;    /* collectable objects */
+  void *p;         /* light userdata */
+  int b;           /* booleans */
+  lua_CFunction f; /* light C functions */
+  numfield         /* numbers */
+};
+
+
+struct lua_TValue {
+  TValuefields;
+};
+
+
+typedef TValue *StkId;  /* index to stack elements */
+
+
+
+
+/*
+** Header for string value; string bytes follow the end of this structure
+*/
+typedef union TString {
+  L_Umaxalign dummy;  /* ensures maximum alignment for strings */
+  struct {
+    CommonHeader;
+    lu_byte extra;  /* reserved words for short strings; "has hash" for longs */
+    unsigned int hash;
+    size_t len;  /* number of characters in string */
+  } tsv;
+} TString;
+
+
+/* get the actual string (array of bytes) from a TString */
+#define getstr(ts)	cast(const char *, (ts) + 1)
+
+/* get the actual string (array of bytes) from a Lua value */
+#define svalue(o)       getstr(rawtsvalue(o))
+
+
+/*
+** Header for userdata; memory area follows the end of this structure
+*/
+typedef union Udata {
+  L_Umaxalign dummy;  /* ensures maximum alignment for `local' udata */
+  struct {
+    CommonHeader;
+    struct Table *metatable;
+    struct Table *env;
+    size_t len;  /* number of bytes */
+  } uv;
+} Udata;
+
+
+
+/*
+** Description of an upvalue for function prototypes
+*/
+typedef struct Upvaldesc {
+  TString *name;  /* upvalue name (for debug information) */
+  lu_byte instack;  /* whether it is in stack */
+  lu_byte idx;  /* index of upvalue (in stack or in outer function's list) */
+} Upvaldesc;
+
+
+/*
+** Description of a local variable for function prototypes
+** (used for debug information)
+*/
+typedef struct LocVar {
+  TString *varname;
+  int startpc;  /* first point where variable is active */
+  int endpc;    /* first point where variable is dead */
+} LocVar;
+
+
+/*
+** Function Prototypes
+*/
+typedef struct Proto {
+  CommonHeader;
+  TValue *k;  /* constants used by the function */
+  Instruction *code;
+  struct Proto **p;  /* functions defined inside the function */
+  int *lineinfo;  /* map from opcodes to source lines (debug information) */
+  LocVar *locvars;  /* information about local variables (debug information) */
+  Upvaldesc *upvalues;  /* upvalue information */
+  union Closure *cache;  /* last created closure with this prototype */
+  TString  *source;  /* used for debug information */
+  int sizeupvalues;  /* size of 'upvalues' */
+  int sizek;  /* size of `k' */
+  int sizecode;
+  int sizelineinfo;
+  int sizep;  /* size of `p' */
+  int sizelocvars;
+  int linedefined;
+  int lastlinedefined;
+  GCObject *gclist;
+  lu_byte numparams;  /* number of fixed parameters */
+  lu_byte is_vararg;
+  lu_byte maxstacksize;  /* maximum stack used by this function */
+} Proto;
+
+
+
+/*
+** Lua Upvalues
+*/
+typedef struct UpVal {
+  CommonHeader;
+  TValue *v;  /* points to stack or to its own value */
+  union {
+    TValue value;  /* the value (when closed) */
+    struct {  /* double linked list (when open) */
+      struct UpVal *prev;
+      struct UpVal *next;
+    } l;
+  } u;
+} UpVal;
+
+
+/*
+** Closures
+*/
+
+#define ClosureHeader \
+	CommonHeader; lu_byte nupvalues; GCObject *gclist
+
+typedef struct CClosure {
+  ClosureHeader;
+  lua_CFunction f;
+  TValue upvalue[1];  /* list of upvalues */
+} CClosure;
+
+
+typedef struct LClosure {
+  ClosureHeader;
+  struct Proto *p;
+  UpVal *upvals[1];  /* list of upvalues */
+} LClosure;
+
+
+typedef union Closure {
+  CClosure c;
+  LClosure l;
+} Closure;
+
+
+#define isLfunction(o)	ttisLclosure(o)
+
+#define getproto(o)	(clLvalue(o)->p)
+
+
+/*
+** Tables
+*/
+
+typedef union TKey {
+  struct {
+    TValuefields;
+    struct Node *next;  /* for chaining */
+  } nk;
+  TValue tvk;
+} TKey;
+
+
+typedef struct Node {
+  TValue i_val;
+  TKey i_key;
+} Node;
+
+
+typedef struct Table {
+  CommonHeader;
+  lu_byte flags;  /* 1<<p means tagmethod(p) is not present */
+  lu_byte lsizenode;  /* log2 of size of `node' array */
+  struct Table *metatable;
+  TValue *array;  /* array part */
+  Node *node;
+  Node *lastfree;  /* any free position is before this position */
+  GCObject *gclist;
+  int sizearray;  /* size of `array' array */
+} Table;
+
+
+
+/*
+** `module' operation for hashing (size is always a power of 2)
+*/
+#define lmod(s,size) \
+	(check_exp((size&(size-1))==0, (cast(int, (s) & ((size)-1)))))
+
+
+#define twoto(x)	(1<<(x))
+#define sizenode(t)	(twoto((t)->lsizenode))
+
+
+/*
+** (address of) a fixed nil value
+*/
+#define luaO_nilobject		(&luaO_nilobject_)
+
+
+LUAI_DDEC const TValue luaO_nilobject_;
+
+
+LUAI_FUNC int luaO_int2fb (unsigned int x);
+LUAI_FUNC int luaO_fb2int (int x);
+LUAI_FUNC int luaO_ceillog2 (unsigned int x);
+LUAI_FUNC lua_Number luaO_arith (int op, lua_Number v1, lua_Number v2);
+LUAI_FUNC int luaO_str2d (const char *s, size_t len, lua_Number *result);
+LUAI_FUNC int luaO_hexavalue (int c);
+LUAI_FUNC const char *luaO_pushvfstring (lua_State *L, const char *fmt,
+                                                       va_list argp);
+LUAI_FUNC const char *luaO_pushfstring (lua_State *L, const char *fmt, ...);
+LUAI_FUNC void luaO_chunkid (char *out, const char *source, size_t len);
+
+
+#endif
+
diff -ruNp src.hd/libs/lua/lopcodes.c src/libs/lua/lopcodes.c
--- src.hd/libs/lua/lopcodes.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lopcodes.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,107 @@
+/*
+** $Id: lopcodes.c,v 1.49 2012/05/14 13:34:18 roberto Exp $
+** Opcodes for Lua virtual machine
+** See Copyright Notice in lua.h
+*/
+
+
+#define lopcodes_c
+#define LUA_CORE
+
+
+#include "lopcodes.h"
+
+
+/* ORDER OP */
+
+LUAI_DDEF const char *const luaP_opnames[NUM_OPCODES+1] = {
+  "MOVE",
+  "LOADK",
+  "LOADKX",
+  "LOADBOOL",
+  "LOADNIL",
+  "GETUPVAL",
+  "GETTABUP",
+  "GETTABLE",
+  "SETTABUP",
+  "SETUPVAL",
+  "SETTABLE",
+  "NEWTABLE",
+  "SELF",
+  "ADD",
+  "SUB",
+  "MUL",
+  "DIV",
+  "MOD",
+  "POW",
+  "UNM",
+  "NOT",
+  "LEN",
+  "CONCAT",
+  "JMP",
+  "EQ",
+  "LT",
+  "LE",
+  "TEST",
+  "TESTSET",
+  "CALL",
+  "TAILCALL",
+  "RETURN",
+  "FORLOOP",
+  "FORPREP",
+  "TFORCALL",
+  "TFORLOOP",
+  "SETLIST",
+  "CLOSURE",
+  "VARARG",
+  "EXTRAARG",
+  NULL
+};
+
+
+#define opmode(t,a,b,c,m) (((t)<<7) | ((a)<<6) | ((b)<<4) | ((c)<<2) | (m))
+
+LUAI_DDEF const lu_byte luaP_opmodes[NUM_OPCODES] = {
+/*       T  A    B       C     mode		   opcode	*/
+  opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_MOVE */
+ ,opmode(0, 1, OpArgK, OpArgN, iABx)		/* OP_LOADK */
+ ,opmode(0, 1, OpArgN, OpArgN, iABx)		/* OP_LOADKX */
+ ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_LOADBOOL */
+ ,opmode(0, 1, OpArgU, OpArgN, iABC)		/* OP_LOADNIL */
+ ,opmode(0, 1, OpArgU, OpArgN, iABC)		/* OP_GETUPVAL */
+ ,opmode(0, 1, OpArgU, OpArgK, iABC)		/* OP_GETTABUP */
+ ,opmode(0, 1, OpArgR, OpArgK, iABC)		/* OP_GETTABLE */
+ ,opmode(0, 0, OpArgK, OpArgK, iABC)		/* OP_SETTABUP */
+ ,opmode(0, 0, OpArgU, OpArgN, iABC)		/* OP_SETUPVAL */
+ ,opmode(0, 0, OpArgK, OpArgK, iABC)		/* OP_SETTABLE */
+ ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_NEWTABLE */
+ ,opmode(0, 1, OpArgR, OpArgK, iABC)		/* OP_SELF */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_ADD */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_SUB */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_MUL */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_DIV */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_MOD */
+ ,opmode(0, 1, OpArgK, OpArgK, iABC)		/* OP_POW */
+ ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_UNM */
+ ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_NOT */
+ ,opmode(0, 1, OpArgR, OpArgN, iABC)		/* OP_LEN */
+ ,opmode(0, 1, OpArgR, OpArgR, iABC)		/* OP_CONCAT */
+ ,opmode(0, 0, OpArgR, OpArgN, iAsBx)		/* OP_JMP */
+ ,opmode(1, 0, OpArgK, OpArgK, iABC)		/* OP_EQ */
+ ,opmode(1, 0, OpArgK, OpArgK, iABC)		/* OP_LT */
+ ,opmode(1, 0, OpArgK, OpArgK, iABC)		/* OP_LE */
+ ,opmode(1, 0, OpArgN, OpArgU, iABC)		/* OP_TEST */
+ ,opmode(1, 1, OpArgR, OpArgU, iABC)		/* OP_TESTSET */
+ ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_CALL */
+ ,opmode(0, 1, OpArgU, OpArgU, iABC)		/* OP_TAILCALL */
+ ,opmode(0, 0, OpArgU, OpArgN, iABC)		/* OP_RETURN */
+ ,opmode(0, 1, OpArgR, OpArgN, iAsBx)		/* OP_FORLOOP */
+ ,opmode(0, 1, OpArgR, OpArgN, iAsBx)		/* OP_FORPREP */
+ ,opmode(0, 0, OpArgN, OpArgU, iABC)		/* OP_TFORCALL */
+ ,opmode(0, 1, OpArgR, OpArgN, iAsBx)		/* OP_TFORLOOP */
+ ,opmode(0, 0, OpArgU, OpArgU, iABC)		/* OP_SETLIST */
+ ,opmode(0, 1, OpArgU, OpArgN, iABx)		/* OP_CLOSURE */
+ ,opmode(0, 1, OpArgU, OpArgN, iABC)		/* OP_VARARG */
+ ,opmode(0, 0, OpArgU, OpArgU, iAx)		/* OP_EXTRAARG */
+};
+
diff -ruNp src.hd/libs/lua/lopcodes.h src/libs/lua/lopcodes.h
--- src.hd/libs/lua/lopcodes.h	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lopcodes.h	2017-12-29 00:57:40 -0800
@@ -0,0 +1,288 @@
+/*
+** $Id: lopcodes.h,v 1.142 2011/07/15 12:50:29 roberto Exp $
+** Opcodes for Lua virtual machine
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lopcodes_h
+#define lopcodes_h
+
+#include "llimits.h"
+
+
+/*===========================================================================
+  We assume that instructions are unsigned numbers.
+  All instructions have an opcode in the first 6 bits.
+  Instructions can have the following fields:
+	`A' : 8 bits
+	`B' : 9 bits
+	`C' : 9 bits
+	'Ax' : 26 bits ('A', 'B', and 'C' together)
+	`Bx' : 18 bits (`B' and `C' together)
+	`sBx' : signed Bx
+
+  A signed argument is represented in excess K; that is, the number
+  value is the unsigned value minus K. K is exactly the maximum value
+  for that argument (so that -max is represented by 0, and +max is
+  represented by 2*max), which is half the maximum for the corresponding
+  unsigned argument.
+===========================================================================*/
+
+
+enum OpMode {iABC, iABx, iAsBx, iAx};  /* basic instruction format */
+
+
+/*
+** size and position of opcode arguments.
+*/
+#define SIZE_C		9
+#define SIZE_B		9
+#define SIZE_Bx		(SIZE_C + SIZE_B)
+#define SIZE_A		8
+#define SIZE_Ax		(SIZE_C + SIZE_B + SIZE_A)
+
+#define SIZE_OP		6
+
+#define POS_OP		0
+#define POS_A		(POS_OP + SIZE_OP)
+#define POS_C		(POS_A + SIZE_A)
+#define POS_B		(POS_C + SIZE_C)
+#define POS_Bx		POS_C
+#define POS_Ax		POS_A
+
+
+/*
+** limits for opcode arguments.
+** we use (signed) int to manipulate most arguments,
+** so they must fit in LUAI_BITSINT-1 bits (-1 for sign)
+*/
+#if SIZE_Bx < LUAI_BITSINT-1
+#define MAXARG_Bx        ((1<<SIZE_Bx)-1)
+#define MAXARG_sBx        (MAXARG_Bx>>1)         /* `sBx' is signed */
+#else
+#define MAXARG_Bx        MAX_INT
+#define MAXARG_sBx        MAX_INT
+#endif
+
+#if SIZE_Ax < LUAI_BITSINT-1
+#define MAXARG_Ax	((1<<SIZE_Ax)-1)
+#else
+#define MAXARG_Ax	MAX_INT
+#endif
+
+
+#define MAXARG_A        ((1<<SIZE_A)-1)
+#define MAXARG_B        ((1<<SIZE_B)-1)
+#define MAXARG_C        ((1<<SIZE_C)-1)
+
+
+/* creates a mask with `n' 1 bits at position `p' */
+#define MASK1(n,p)	((~((~(Instruction)0)<<(n)))<<(p))
+
+/* creates a mask with `n' 0 bits at position `p' */
+#define MASK0(n,p)	(~MASK1(n,p))
+
+/*
+** the following macros help to manipulate instructions
+*/
+
+#define GET_OPCODE(i)	(cast(OpCode, ((i)>>POS_OP) & MASK1(SIZE_OP,0)))
+#define SET_OPCODE(i,o)	((i) = (((i)&MASK0(SIZE_OP,POS_OP)) | \
+		((cast(Instruction, o)<<POS_OP)&MASK1(SIZE_OP,POS_OP))))
+
+#define getarg(i,pos,size)	(cast(int, ((i)>>pos) & MASK1(size,0)))
+#define setarg(i,v,pos,size)	((i) = (((i)&MASK0(size,pos)) | \
+                ((cast(Instruction, v)<<pos)&MASK1(size,pos))))
+
+#define GETARG_A(i)	getarg(i, POS_A, SIZE_A)
+#define SETARG_A(i,v)	setarg(i, v, POS_A, SIZE_A)
+
+#define GETARG_B(i)	getarg(i, POS_B, SIZE_B)
+#define SETARG_B(i,v)	setarg(i, v, POS_B, SIZE_B)
+
+#define GETARG_C(i)	getarg(i, POS_C, SIZE_C)
+#define SETARG_C(i,v)	setarg(i, v, POS_C, SIZE_C)
+
+#define GETARG_Bx(i)	getarg(i, POS_Bx, SIZE_Bx)
+#define SETARG_Bx(i,v)	setarg(i, v, POS_Bx, SIZE_Bx)
+
+#define GETARG_Ax(i)	getarg(i, POS_Ax, SIZE_Ax)
+#define SETARG_Ax(i,v)	setarg(i, v, POS_Ax, SIZE_Ax)
+
+#define GETARG_sBx(i)	(GETARG_Bx(i)-MAXARG_sBx)
+#define SETARG_sBx(i,b)	SETARG_Bx((i),cast(unsigned int, (b)+MAXARG_sBx))
+
+
+#define CREATE_ABC(o,a,b,c)	((cast(Instruction, o)<<POS_OP) \
+			| (cast(Instruction, a)<<POS_A) \
+			| (cast(Instruction, b)<<POS_B) \
+			| (cast(Instruction, c)<<POS_C))
+
+#define CREATE_ABx(o,a,bc)	((cast(Instruction, o)<<POS_OP) \
+			| (cast(Instruction, a)<<POS_A) \
+			| (cast(Instruction, bc)<<POS_Bx))
+
+#define CREATE_Ax(o,a)		((cast(Instruction, o)<<POS_OP) \
+			| (cast(Instruction, a)<<POS_Ax))
+
+
+/*
+** Macros to operate RK indices
+*/
+
+/* this bit 1 means constant (0 means register) */
+#define BITRK		(1 << (SIZE_B - 1))
+
+/* test whether value is a constant */
+#define ISK(x)		((x) & BITRK)
+
+/* gets the index of the constant */
+#define INDEXK(r)	((int)(r) & ~BITRK)
+
+#define MAXINDEXRK	(BITRK - 1)
+
+/* code a constant index as a RK value */
+#define RKASK(x)	((x) | BITRK)
+
+
+/*
+** invalid register that fits in 8 bits
+*/
+#define NO_REG		MAXARG_A
+
+
+/*
+** R(x) - register
+** Kst(x) - constant (in constant table)
+** RK(x) == if ISK(x) then Kst(INDEXK(x)) else R(x)
+*/
+
+
+/*
+** grep "ORDER OP" if you change these enums
+*/
+
+typedef enum {
+/*----------------------------------------------------------------------
+name		args	description
+------------------------------------------------------------------------*/
+OP_MOVE,/*	A B	R(A) := R(B)					*/
+OP_LOADK,/*	A Bx	R(A) := Kst(Bx)					*/
+OP_LOADKX,/*	A 	R(A) := Kst(extra arg)				*/
+OP_LOADBOOL,/*	A B C	R(A) := (Bool)B; if (C) pc++			*/
+OP_LOADNIL,/*	A B	R(A), R(A+1), ..., R(A+B) := nil		*/
+OP_GETUPVAL,/*	A B	R(A) := UpValue[B]				*/
+
+OP_GETTABUP,/*	A B C	R(A) := UpValue[B][RK(C)]			*/
+OP_GETTABLE,/*	A B C	R(A) := R(B)[RK(C)]				*/
+
+OP_SETTABUP,/*	A B C	UpValue[A][RK(B)] := RK(C)			*/
+OP_SETUPVAL,/*	A B	UpValue[B] := R(A)				*/
+OP_SETTABLE,/*	A B C	R(A)[RK(B)] := RK(C)				*/
+
+OP_NEWTABLE,/*	A B C	R(A) := {} (size = B,C)				*/
+
+OP_SELF,/*	A B C	R(A+1) := R(B); R(A) := R(B)[RK(C)]		*/
+
+OP_ADD,/*	A B C	R(A) := RK(B) + RK(C)				*/
+OP_SUB,/*	A B C	R(A) := RK(B) - RK(C)				*/
+OP_MUL,/*	A B C	R(A) := RK(B) * RK(C)				*/
+OP_DIV,/*	A B C	R(A) := RK(B) / RK(C)				*/
+OP_MOD,/*	A B C	R(A) := RK(B) % RK(C)				*/
+OP_POW,/*	A B C	R(A) := RK(B) ^ RK(C)				*/
+OP_UNM,/*	A B	R(A) := -R(B)					*/
+OP_NOT,/*	A B	R(A) := not R(B)				*/
+OP_LEN,/*	A B	R(A) := length of R(B)				*/
+
+OP_CONCAT,/*	A B C	R(A) := R(B).. ... ..R(C)			*/
+
+OP_JMP,/*	A sBx	pc+=sBx; if (A) close all upvalues >= R(A) + 1	*/
+OP_EQ,/*	A B C	if ((RK(B) == RK(C)) ~= A) then pc++		*/
+OP_LT,/*	A B C	if ((RK(B) <  RK(C)) ~= A) then pc++		*/
+OP_LE,/*	A B C	if ((RK(B) <= RK(C)) ~= A) then pc++		*/
+
+OP_TEST,/*	A C	if not (R(A) <=> C) then pc++			*/
+OP_TESTSET,/*	A B C	if (R(B) <=> C) then R(A) := R(B) else pc++	*/
+
+OP_CALL,/*	A B C	R(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1)) */
+OP_TAILCALL,/*	A B C	return R(A)(R(A+1), ... ,R(A+B-1))		*/
+OP_RETURN,/*	A B	return R(A), ... ,R(A+B-2)	(see note)	*/
+
+OP_FORLOOP,/*	A sBx	R(A)+=R(A+2);
+			if R(A) <?= R(A+1) then { pc+=sBx; R(A+3)=R(A) }*/
+OP_FORPREP,/*	A sBx	R(A)-=R(A+2); pc+=sBx				*/
+
+OP_TFORCALL,/*	A C	R(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2));	*/
+OP_TFORLOOP,/*	A sBx	if R(A+1) ~= nil then { R(A)=R(A+1); pc += sBx }*/
+
+OP_SETLIST,/*	A B C	R(A)[(C-1)*FPF+i] := R(A+i), 1 <= i <= B	*/
+
+OP_CLOSURE,/*	A Bx	R(A) := closure(KPROTO[Bx])			*/
+
+OP_VARARG,/*	A B	R(A), R(A+1), ..., R(A+B-2) = vararg		*/
+
+OP_EXTRAARG/*	Ax	extra (larger) argument for previous opcode	*/
+} OpCode;
+
+
+#define NUM_OPCODES	(cast(int, OP_EXTRAARG) + 1)
+
+
+
+/*===========================================================================
+  Notes:
+  (*) In OP_CALL, if (B == 0) then B = top. If (C == 0), then `top' is
+  set to last_result+1, so next open instruction (OP_CALL, OP_RETURN,
+  OP_SETLIST) may use `top'.
+
+  (*) In OP_VARARG, if (B == 0) then use actual number of varargs and
+  set top (like in OP_CALL with C == 0).
+
+  (*) In OP_RETURN, if (B == 0) then return up to `top'.
+
+  (*) In OP_SETLIST, if (B == 0) then B = `top'; if (C == 0) then next
+  'instruction' is EXTRAARG(real C).
+
+  (*) In OP_LOADKX, the next 'instruction' is always EXTRAARG.
+
+  (*) For comparisons, A specifies what condition the test should accept
+  (true or false).
+
+  (*) All `skips' (pc++) assume that next instruction is a jump.
+
+===========================================================================*/
+
+
+/*
+** masks for instruction properties. The format is:
+** bits 0-1: op mode
+** bits 2-3: C arg mode
+** bits 4-5: B arg mode
+** bit 6: instruction set register A
+** bit 7: operator is a test (next instruction must be a jump)
+*/
+
+enum OpArgMask {
+  OpArgN,  /* argument is not used */
+  OpArgU,  /* argument is used */
+  OpArgR,  /* argument is a register or a jump offset */
+  OpArgK   /* argument is a constant or register/constant */
+};
+
+LUAI_DDEC const lu_byte luaP_opmodes[NUM_OPCODES];
+
+#define getOpMode(m)	(cast(enum OpMode, luaP_opmodes[m] & 3))
+#define getBMode(m)	(cast(enum OpArgMask, (luaP_opmodes[m] >> 4) & 3))
+#define getCMode(m)	(cast(enum OpArgMask, (luaP_opmodes[m] >> 2) & 3))
+#define testAMode(m)	(luaP_opmodes[m] & (1 << 6))
+#define testTMode(m)	(luaP_opmodes[m] & (1 << 7))
+
+
+LUAI_DDEC const char *const luaP_opnames[NUM_OPCODES+1];  /* opcode names */
+
+
+/* number of list items to accumulate before a SETLIST instruction */
+#define LFIELDS_PER_FLUSH	50
+
+
+#endif
diff -ruNp src.hd/libs/lua/loslib.c src/libs/lua/loslib.c
--- src.hd/libs/lua/loslib.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/loslib.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,323 @@
+/*
+** $Id: loslib.c,v 1.40 2012/10/19 15:54:02 roberto Exp $
+** Standard Operating System library
+** See Copyright Notice in lua.h
+*/
+
+
+#include <errno.h>
+#include <locale.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+
+#define loslib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+/*
+** list of valid conversion specifiers for the 'strftime' function
+*/
+#if !defined(LUA_STRFTIMEOPTIONS)
+
+#if !defined(LUA_USE_POSIX)
+#define LUA_STRFTIMEOPTIONS	{ "aAbBcdHIjmMpSUwWxXyYz%", "" }
+#else
+#define LUA_STRFTIMEOPTIONS \
+	{ "aAbBcCdDeFgGhHIjmMnprRStTuUVwWxXyYzZ%", "" \
+	  "", "E", "cCxXyY",  \
+	  "O", "deHImMSuUVwWy" }
+#endif
+
+#endif
+
+
+
+/*
+** By default, Lua uses tmpnam except when POSIX is available, where it
+** uses mkstemp.
+*/
+#if defined(LUA_USE_MKSTEMP)
+#include <unistd.h>
+#define LUA_TMPNAMBUFSIZE	32
+#define lua_tmpnam(b,e) { \
+        strcpy(b, "/tmp/lua_XXXXXX"); \
+        e = mkstemp(b); \
+        if (e != -1) close(e); \
+        e = (e == -1); }
+
+#elif !defined(lua_tmpnam)
+
+#define LUA_TMPNAMBUFSIZE	L_tmpnam
+#define lua_tmpnam(b,e)		{ e = (tmpnam(b) == NULL); }
+
+#endif
+
+
+/*
+** By default, Lua uses gmtime/localtime, except when POSIX is available,
+** where it uses gmtime_r/localtime_r
+*/
+#if defined(LUA_USE_GMTIME_R)
+
+#define l_gmtime(t,r)		gmtime_r(t,r)
+#define l_localtime(t,r)	localtime_r(t,r)
+
+#elif !defined(l_gmtime)
+
+#define l_gmtime(t,r)		((void)r, gmtime(t))
+#define l_localtime(t,r)  	((void)r, localtime(t))
+
+#endif
+
+
+
+static int os_execute (lua_State *L) {
+  const char *cmd = luaL_optstring(L, 1, NULL);
+  int stat = system(cmd);
+  if (cmd != NULL)
+    return luaL_execresult(L, stat);
+  else {
+    lua_pushboolean(L, stat);  /* true if there is a shell */
+    return 1;
+  }
+}
+
+
+static int os_remove (lua_State *L) {
+  const char *filename = luaL_checkstring(L, 1);
+  return luaL_fileresult(L, remove(filename) == 0, filename);
+}
+
+
+static int os_rename (lua_State *L) {
+  const char *fromname = luaL_checkstring(L, 1);
+  const char *toname = luaL_checkstring(L, 2);
+  return luaL_fileresult(L, rename(fromname, toname) == 0, NULL);
+}
+
+
+static int os_tmpname (lua_State *L) {
+  char buff[LUA_TMPNAMBUFSIZE];
+  int err;
+  lua_tmpnam(buff, err);
+  if (err)
+    return luaL_error(L, "unable to generate a unique filename");
+  lua_pushstring(L, buff);
+  return 1;
+}
+
+
+static int os_getenv (lua_State *L) {
+  lua_pushstring(L, getenv(luaL_checkstring(L, 1)));  /* if NULL push nil */
+  return 1;
+}
+
+
+static int os_clock (lua_State *L) {
+  lua_pushnumber(L, ((lua_Number)clock())/(lua_Number)CLOCKS_PER_SEC);
+  return 1;
+}
+
+
+/*
+** {======================================================
+** Time/Date operations
+** { year=%Y, month=%m, day=%d, hour=%H, min=%M, sec=%S,
+**   wday=%w+1, yday=%j, isdst=? }
+** =======================================================
+*/
+
+static void setfield (lua_State *L, const char *key, int value) {
+  lua_pushinteger(L, value);
+  lua_setfield(L, -2, key);
+}
+
+static void setboolfield (lua_State *L, const char *key, int value) {
+  if (value < 0)  /* undefined? */
+    return;  /* does not set field */
+  lua_pushboolean(L, value);
+  lua_setfield(L, -2, key);
+}
+
+static int getboolfield (lua_State *L, const char *key) {
+  int res;
+  lua_getfield(L, -1, key);
+  res = lua_isnil(L, -1) ? -1 : lua_toboolean(L, -1);
+  lua_pop(L, 1);
+  return res;
+}
+
+
+static int getfield (lua_State *L, const char *key, int d) {
+  int res, isnum;
+  lua_getfield(L, -1, key);
+  res = (int)lua_tointegerx(L, -1, &isnum);
+  if (!isnum) {
+    if (d < 0)
+      return luaL_error(L, "field " LUA_QS " missing in date table", key);
+    res = d;
+  }
+  lua_pop(L, 1);
+  return res;
+}
+
+
+static const char *checkoption (lua_State *L, const char *conv, char *buff) {
+  static const char *const options[] = LUA_STRFTIMEOPTIONS;
+  unsigned int i;
+  for (i = 0; i < sizeof(options)/sizeof(options[0]); i += 2) {
+    if (*conv != '\0' && strchr(options[i], *conv) != NULL) {
+      buff[1] = *conv;
+      if (*options[i + 1] == '\0') {  /* one-char conversion specifier? */
+        buff[2] = '\0';  /* end buffer */
+        return conv + 1;
+      }
+      else if (*(conv + 1) != '\0' &&
+               strchr(options[i + 1], *(conv + 1)) != NULL) {
+        buff[2] = *(conv + 1);  /* valid two-char conversion specifier */
+        buff[3] = '\0';  /* end buffer */
+        return conv + 2;
+      }
+    }
+  }
+  luaL_argerror(L, 1,
+    lua_pushfstring(L, "invalid conversion specifier '%%%s'", conv));
+  return conv;  /* to avoid warnings */
+}
+
+
+static int os_date (lua_State *L) {
+  const char *s = luaL_optstring(L, 1, "%c");
+  time_t t = luaL_opt(L, (time_t)luaL_checknumber, 2, time(NULL));
+  struct tm tmr, *stm;
+  if (*s == '!') {  /* UTC? */
+    stm = l_gmtime(&t, &tmr);
+    s++;  /* skip `!' */
+  }
+  else
+    stm = l_localtime(&t, &tmr);
+  if (stm == NULL)  /* invalid date? */
+    lua_pushnil(L);
+  else if (strcmp(s, "*t") == 0) {
+    lua_createtable(L, 0, 9);  /* 9 = number of fields */
+    setfield(L, "sec", stm->tm_sec);
+    setfield(L, "min", stm->tm_min);
+    setfield(L, "hour", stm->tm_hour);
+    setfield(L, "day", stm->tm_mday);
+    setfield(L, "month", stm->tm_mon+1);
+    setfield(L, "year", stm->tm_year+1900);
+    setfield(L, "wday", stm->tm_wday+1);
+    setfield(L, "yday", stm->tm_yday+1);
+    setboolfield(L, "isdst", stm->tm_isdst);
+  }
+  else {
+    char cc[4];
+    luaL_Buffer b;
+    cc[0] = '%';
+    luaL_buffinit(L, &b);
+    while (*s) {
+      if (*s != '%')  /* no conversion specifier? */
+        luaL_addchar(&b, *s++);
+      else {
+        size_t reslen;
+        char buff[200];  /* should be big enough for any conversion result */
+        s = checkoption(L, s + 1, cc);
+        reslen = strftime(buff, sizeof(buff), cc, stm);
+        luaL_addlstring(&b, buff, reslen);
+      }
+    }
+    luaL_pushresult(&b);
+  }
+  return 1;
+}
+
+
+static int os_time (lua_State *L) {
+  time_t t;
+  if (lua_isnoneornil(L, 1))  /* called without args? */
+    t = time(NULL);  /* get current time */
+  else {
+    struct tm ts;
+    luaL_checktype(L, 1, LUA_TTABLE);
+    lua_settop(L, 1);  /* make sure table is at the top */
+    ts.tm_sec = getfield(L, "sec", 0);
+    ts.tm_min = getfield(L, "min", 0);
+    ts.tm_hour = getfield(L, "hour", 12);
+    ts.tm_mday = getfield(L, "day", -1);
+    ts.tm_mon = getfield(L, "month", -1) - 1;
+    ts.tm_year = getfield(L, "year", -1) - 1900;
+    ts.tm_isdst = getboolfield(L, "isdst");
+    t = mktime(&ts);
+  }
+  if (t == (time_t)(-1))
+    lua_pushnil(L);
+  else
+    lua_pushnumber(L, (lua_Number)t);
+  return 1;
+}
+
+
+static int os_difftime (lua_State *L) {
+  lua_pushnumber(L, difftime((time_t)(luaL_checknumber(L, 1)),
+                             (time_t)(luaL_optnumber(L, 2, 0))));
+  return 1;
+}
+
+/* }====================================================== */
+
+
+static int os_setlocale (lua_State *L) {
+  static const int cat[] = {LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY,
+                      LC_NUMERIC, LC_TIME};
+  static const char *const catnames[] = {"all", "collate", "ctype", "monetary",
+     "numeric", "time", NULL};
+  const char *l = luaL_optstring(L, 1, NULL);
+  int op = luaL_checkoption(L, 2, "all", catnames);
+  lua_pushstring(L, setlocale(cat[op], l));
+  return 1;
+}
+
+
+static int os_exit (lua_State *L) {
+  int status;
+  if (lua_isboolean(L, 1))
+    status = (lua_toboolean(L, 1) ? EXIT_SUCCESS : EXIT_FAILURE);
+  else
+    status = luaL_optint(L, 1, EXIT_SUCCESS);
+  if (lua_toboolean(L, 2))
+    lua_close(L);
+  if (L) exit(status);  /* 'if' to avoid warnings for unreachable 'return' */
+  return 0;
+}
+
+
+static const luaL_Reg syslib[] = {
+  {"clock",     os_clock},
+  {"date",      os_date},
+  {"difftime",  os_difftime},
+  {"execute",   os_execute},
+  {"exit",      os_exit},
+  {"getenv",    os_getenv},
+  {"remove",    os_remove},
+  {"rename",    os_rename},
+  {"setlocale", os_setlocale},
+  {"time",      os_time},
+  {"tmpname",   os_tmpname},
+  {NULL, NULL}
+};
+
+/* }====================================================== */
+
+
+
+LUAMOD_API int luaopen_os (lua_State *L) {
+  luaL_newlib(L, syslib);
+  return 1;
+}
+
diff -ruNp src.hd/libs/lua/lparser.c src/libs/lua/lparser.c
--- src.hd/libs/lua/lparser.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lparser.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,1638 @@
+/*
+** $Id: lparser.c,v 2.130 2013/02/06 13:37:39 roberto Exp $
+** Lua Parser
+** See Copyright Notice in lua.h
+*/
+
+
+#include <string.h>
+
+#define lparser_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lcode.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "llex.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lparser.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+
+
+
+/* maximum number of local variables per function (must be smaller
+   than 250, due to the bytecode format) */
+#define MAXVARS		200
+
+
+#define hasmultret(k)		((k) == VCALL || (k) == VVARARG)
+
+
+
+/*
+** nodes for block list (list of active blocks)
+*/
+typedef struct BlockCnt {
+  struct BlockCnt *previous;  /* chain */
+  short firstlabel;  /* index of first label in this block */
+  short firstgoto;  /* index of first pending goto in this block */
+  lu_byte nactvar;  /* # active locals outside the block */
+  lu_byte upval;  /* true if some variable in the block is an upvalue */
+  lu_byte isloop;  /* true if `block' is a loop */
+} BlockCnt;
+
+
+
+/*
+** prototypes for recursive non-terminal functions
+*/
+static void statement (LexState *ls);
+static void expr (LexState *ls, expdesc *v);
+
+
+static void anchor_token (LexState *ls) {
+  /* last token from outer function must be EOS */
+  lua_assert(ls->fs != NULL || ls->t.token == TK_EOS);
+  if (ls->t.token == TK_NAME || ls->t.token == TK_STRING) {
+    TString *ts = ls->t.seminfo.ts;
+    luaX_newstring(ls, getstr(ts), ts->tsv.len);
+  }
+}
+
+
+/* semantic error */
+static l_noret semerror (LexState *ls, const char *msg) {
+  ls->t.token = 0;  /* remove 'near to' from final message */
+  luaX_syntaxerror(ls, msg);
+}
+
+
+static l_noret error_expected (LexState *ls, int token) {
+  luaX_syntaxerror(ls,
+      luaO_pushfstring(ls->L, "%s expected", luaX_token2str(ls, token)));
+}
+
+
+static l_noret errorlimit (FuncState *fs, int limit, const char *what) {
+  lua_State *L = fs->ls->L;
+  const char *msg;
+  int line = fs->f->linedefined;
+  const char *where = (line == 0)
+                      ? "main function"
+                      : luaO_pushfstring(L, "function at line %d", line);
+  msg = luaO_pushfstring(L, "too many %s (limit is %d) in %s",
+                             what, limit, where);
+  luaX_syntaxerror(fs->ls, msg);
+}
+
+
+static void checklimit (FuncState *fs, int v, int l, const char *what) {
+  if (v > l) errorlimit(fs, l, what);
+}
+
+
+static int testnext (LexState *ls, int c) {
+  if (ls->t.token == c) {
+    luaX_next(ls);
+    return 1;
+  }
+  else return 0;
+}
+
+
+static void check (LexState *ls, int c) {
+  if (ls->t.token != c)
+    error_expected(ls, c);
+}
+
+
+static void checknext (LexState *ls, int c) {
+  check(ls, c);
+  luaX_next(ls);
+}
+
+
+#define check_condition(ls,c,msg)	{ if (!(c)) luaX_syntaxerror(ls, msg); }
+
+
+
+static void check_match (LexState *ls, int what, int who, int where) {
+  if (!testnext(ls, what)) {
+    if (where == ls->linenumber)
+      error_expected(ls, what);
+    else {
+      luaX_syntaxerror(ls, luaO_pushfstring(ls->L,
+             "%s expected (to close %s at line %d)",
+              luaX_token2str(ls, what), luaX_token2str(ls, who), where));
+    }
+  }
+}
+
+
+static TString *str_checkname (LexState *ls) {
+  TString *ts;
+  check(ls, TK_NAME);
+  ts = ls->t.seminfo.ts;
+  luaX_next(ls);
+  return ts;
+}
+
+
+static void init_exp (expdesc *e, expkind k, int i) {
+  e->f = e->t = NO_JUMP;
+  e->k = k;
+  e->u.info = i;
+}
+
+
+static void codestring (LexState *ls, expdesc *e, TString *s) {
+  init_exp(e, VK, luaK_stringK(ls->fs, s));
+}
+
+
+static void checkname (LexState *ls, expdesc *e) {
+  codestring(ls, e, str_checkname(ls));
+}
+
+
+static int registerlocalvar (LexState *ls, TString *varname) {
+  FuncState *fs = ls->fs;
+  Proto *f = fs->f;
+  int oldsize = f->sizelocvars;
+  luaM_growvector(ls->L, f->locvars, fs->nlocvars, f->sizelocvars,
+                  LocVar, SHRT_MAX, "local variables");
+  while (oldsize < f->sizelocvars) f->locvars[oldsize++].varname = NULL;
+  f->locvars[fs->nlocvars].varname = varname;
+  luaC_objbarrier(ls->L, f, varname);
+  return fs->nlocvars++;
+}
+
+
+static void new_localvar (LexState *ls, TString *name) {
+  FuncState *fs = ls->fs;
+  Dyndata *dyd = ls->dyd;
+  int reg = registerlocalvar(ls, name);
+  checklimit(fs, dyd->actvar.n + 1 - fs->firstlocal,
+                  MAXVARS, "local variables");
+  luaM_growvector(ls->L, dyd->actvar.arr, dyd->actvar.n + 1,
+                  dyd->actvar.size, Vardesc, MAX_INT, "local variables");
+  dyd->actvar.arr[dyd->actvar.n++].idx = cast(short, reg);
+}
+
+
+static void new_localvarliteral_ (LexState *ls, const char *name, size_t sz) {
+  new_localvar(ls, luaX_newstring(ls, name, sz));
+}
+
+#define new_localvarliteral(ls,v) \
+	new_localvarliteral_(ls, "" v, (sizeof(v)/sizeof(char))-1)
+
+
+static LocVar *getlocvar (FuncState *fs, int i) {
+  int idx = fs->ls->dyd->actvar.arr[fs->firstlocal + i].idx;
+  lua_assert(idx < fs->nlocvars);
+  return &fs->f->locvars[idx];
+}
+
+
+static void adjustlocalvars (LexState *ls, int nvars) {
+  FuncState *fs = ls->fs;
+  fs->nactvar = cast_byte(fs->nactvar + nvars);
+  for (; nvars; nvars--) {
+    getlocvar(fs, fs->nactvar - nvars)->startpc = fs->pc;
+  }
+}
+
+
+static void removevars (FuncState *fs, int tolevel) {
+  fs->ls->dyd->actvar.n -= (fs->nactvar - tolevel);
+  while (fs->nactvar > tolevel)
+    getlocvar(fs, --fs->nactvar)->endpc = fs->pc;
+}
+
+
+static int searchupvalue (FuncState *fs, TString *name) {
+  int i;
+  Upvaldesc *up = fs->f->upvalues;
+  for (i = 0; i < fs->nups; i++) {
+    if (luaS_eqstr(up[i].name, name)) return i;
+  }
+  return -1;  /* not found */
+}
+
+
+static int newupvalue (FuncState *fs, TString *name, expdesc *v) {
+  Proto *f = fs->f;
+  int oldsize = f->sizeupvalues;
+  checklimit(fs, fs->nups + 1, MAXUPVAL, "upvalues");
+  luaM_growvector(fs->ls->L, f->upvalues, fs->nups, f->sizeupvalues,
+                  Upvaldesc, MAXUPVAL, "upvalues");
+  while (oldsize < f->sizeupvalues) f->upvalues[oldsize++].name = NULL;
+  f->upvalues[fs->nups].instack = (v->k == VLOCAL);
+  f->upvalues[fs->nups].idx = cast_byte(v->u.info);
+  f->upvalues[fs->nups].name = name;
+  luaC_objbarrier(fs->ls->L, f, name);
+  return fs->nups++;
+}
+
+
+static int searchvar (FuncState *fs, TString *n) {
+  int i;
+  for (i = cast_int(fs->nactvar) - 1; i >= 0; i--) {
+    if (luaS_eqstr(n, getlocvar(fs, i)->varname))
+      return i;
+  }
+  return -1;  /* not found */
+}
+
+
+/*
+  Mark block where variable at given level was defined
+  (to emit close instructions later).
+*/
+static void markupval (FuncState *fs, int level) {
+  BlockCnt *bl = fs->bl;
+  while (bl->nactvar > level) bl = bl->previous;
+  bl->upval = 1;
+}
+
+
+/*
+  Find variable with given name 'n'. If it is an upvalue, add this
+  upvalue into all intermediate functions.
+*/
+static int singlevaraux (FuncState *fs, TString *n, expdesc *var, int base) {
+  if (fs == NULL)  /* no more levels? */
+    return VVOID;  /* default is global */
+  else {
+    int v = searchvar(fs, n);  /* look up locals at current level */
+    if (v >= 0) {  /* found? */
+      init_exp(var, VLOCAL, v);  /* variable is local */
+      if (!base)
+        markupval(fs, v);  /* local will be used as an upval */
+      return VLOCAL;
+    }
+    else {  /* not found as local at current level; try upvalues */
+      int idx = searchupvalue(fs, n);  /* try existing upvalues */
+      if (idx < 0) {  /* not found? */
+        if (singlevaraux(fs->prev, n, var, 0) == VVOID) /* try upper levels */
+          return VVOID;  /* not found; is a global */
+        /* else was LOCAL or UPVAL */
+        idx  = newupvalue(fs, n, var);  /* will be a new upvalue */
+      }
+      init_exp(var, VUPVAL, idx);
+      return VUPVAL;
+    }
+  }
+}
+
+
+static void singlevar (LexState *ls, expdesc *var) {
+  TString *varname = str_checkname(ls);
+  FuncState *fs = ls->fs;
+  if (singlevaraux(fs, varname, var, 1) == VVOID) {  /* global name? */
+    expdesc key;
+    singlevaraux(fs, ls->envn, var, 1);  /* get environment variable */
+    lua_assert(var->k == VLOCAL || var->k == VUPVAL);
+    codestring(ls, &key, varname);  /* key is variable name */
+    luaK_indexed(fs, var, &key);  /* env[varname] */
+  }
+}
+
+
+static void adjust_assign (LexState *ls, int nvars, int nexps, expdesc *e) {
+  FuncState *fs = ls->fs;
+  int extra = nvars - nexps;
+  if (hasmultret(e->k)) {
+    extra++;  /* includes call itself */
+    if (extra < 0) extra = 0;
+    luaK_setreturns(fs, e, extra);  /* last exp. provides the difference */
+    if (extra > 1) luaK_reserveregs(fs, extra-1);
+  }
+  else {
+    if (e->k != VVOID) luaK_exp2nextreg(fs, e);  /* close last expression */
+    if (extra > 0) {
+      int reg = fs->freereg;
+      luaK_reserveregs(fs, extra);
+      luaK_nil(fs, reg, extra);
+    }
+  }
+}
+
+
+static void enterlevel (LexState *ls) {
+  lua_State *L = ls->L;
+  ++L->nCcalls;
+  checklimit(ls->fs, L->nCcalls, LUAI_MAXCCALLS, "C levels");
+}
+
+
+#define leavelevel(ls)	((ls)->L->nCcalls--)
+
+
+static void closegoto (LexState *ls, int g, Labeldesc *label) {
+  int i;
+  FuncState *fs = ls->fs;
+  Labellist *gl = &ls->dyd->gt;
+  Labeldesc *gt = &gl->arr[g];
+  lua_assert(luaS_eqstr(gt->name, label->name));
+  if (gt->nactvar < label->nactvar) {
+    TString *vname = getlocvar(fs, gt->nactvar)->varname;
+    const char *msg = luaO_pushfstring(ls->L,
+      "<goto %s> at line %d jumps into the scope of local " LUA_QS,
+      getstr(gt->name), gt->line, getstr(vname));
+    semerror(ls, msg);
+  }
+  luaK_patchlist(fs, gt->pc, label->pc);
+  /* remove goto from pending list */
+  for (i = g; i < gl->n - 1; i++)
+    gl->arr[i] = gl->arr[i + 1];
+  gl->n--;
+}
+
+
+/*
+** try to close a goto with existing labels; this solves backward jumps
+*/
+static int findlabel (LexState *ls, int g) {
+  int i;
+  BlockCnt *bl = ls->fs->bl;
+  Dyndata *dyd = ls->dyd;
+  Labeldesc *gt = &dyd->gt.arr[g];
+  /* check labels in current block for a match */
+  for (i = bl->firstlabel; i < dyd->label.n; i++) {
+    Labeldesc *lb = &dyd->label.arr[i];
+    if (luaS_eqstr(lb->name, gt->name)) {  /* correct label? */
+      if (gt->nactvar > lb->nactvar &&
+          (bl->upval || dyd->label.n > bl->firstlabel))
+        luaK_patchclose(ls->fs, gt->pc, lb->nactvar);
+      closegoto(ls, g, lb);  /* close it */
+      return 1;
+    }
+  }
+  return 0;  /* label not found; cannot close goto */
+}
+
+
+static int newlabelentry (LexState *ls, Labellist *l, TString *name,
+                          int line, int pc) {
+  int n = l->n;
+  luaM_growvector(ls->L, l->arr, n, l->size,
+                  Labeldesc, SHRT_MAX, "labels/gotos");
+  l->arr[n].name = name;
+  l->arr[n].line = line;
+  l->arr[n].nactvar = ls->fs->nactvar;
+  l->arr[n].pc = pc;
+  l->n++;
+  return n;
+}
+
+
+/*
+** check whether new label 'lb' matches any pending gotos in current
+** block; solves forward jumps
+*/
+static void findgotos (LexState *ls, Labeldesc *lb) {
+  Labellist *gl = &ls->dyd->gt;
+  int i = ls->fs->bl->firstgoto;
+  while (i < gl->n) {
+    if (luaS_eqstr(gl->arr[i].name, lb->name))
+      closegoto(ls, i, lb);
+    else
+      i++;
+  }
+}
+
+
+/*
+** "export" pending gotos to outer level, to check them against
+** outer labels; if the block being exited has upvalues, and
+** the goto exits the scope of any variable (which can be the
+** upvalue), close those variables being exited.
+*/
+static void movegotosout (FuncState *fs, BlockCnt *bl) {
+  int i = bl->firstgoto;
+  Labellist *gl = &fs->ls->dyd->gt;
+  /* correct pending gotos to current block and try to close it
+     with visible labels */
+  while (i < gl->n) {
+    Labeldesc *gt = &gl->arr[i];
+    if (gt->nactvar > bl->nactvar) {
+      if (bl->upval)
+        luaK_patchclose(fs, gt->pc, bl->nactvar);
+      gt->nactvar = bl->nactvar;
+    }
+    if (!findlabel(fs->ls, i))
+      i++;  /* move to next one */
+  }
+}
+
+
+static void enterblock (FuncState *fs, BlockCnt *bl, lu_byte isloop) {
+  bl->isloop = isloop;
+  bl->nactvar = fs->nactvar;
+  bl->firstlabel = fs->ls->dyd->label.n;
+  bl->firstgoto = fs->ls->dyd->gt.n;
+  bl->upval = 0;
+  bl->previous = fs->bl;
+  fs->bl = bl;
+  lua_assert(fs->freereg == fs->nactvar);
+}
+
+
+/*
+** create a label named "break" to resolve break statements
+*/
+static void breaklabel (LexState *ls) {
+  TString *n = luaS_new(ls->L, "break");
+  int l = newlabelentry(ls, &ls->dyd->label, n, 0, ls->fs->pc);
+  findgotos(ls, &ls->dyd->label.arr[l]);
+}
+
+/*
+** generates an error for an undefined 'goto'; choose appropriate
+** message when label name is a reserved word (which can only be 'break')
+*/
+static l_noret undefgoto (LexState *ls, Labeldesc *gt) {
+  const char *msg = isreserved(gt->name)
+                    ? "<%s> at line %d not inside a loop"
+                    : "no visible label " LUA_QS " for <goto> at line %d";
+  msg = luaO_pushfstring(ls->L, msg, getstr(gt->name), gt->line);
+  semerror(ls, msg);
+}
+
+
+static void leaveblock (FuncState *fs) {
+  BlockCnt *bl = fs->bl;
+  LexState *ls = fs->ls;
+  if (bl->previous && bl->upval) {
+    /* create a 'jump to here' to close upvalues */
+    int j = luaK_jump(fs);
+    luaK_patchclose(fs, j, bl->nactvar);
+    luaK_patchtohere(fs, j);
+  }
+  if (bl->isloop)
+    breaklabel(ls);  /* close pending breaks */
+  fs->bl = bl->previous;
+  removevars(fs, bl->nactvar);
+  lua_assert(bl->nactvar == fs->nactvar);
+  fs->freereg = fs->nactvar;  /* free registers */
+  ls->dyd->label.n = bl->firstlabel;  /* remove local labels */
+  if (bl->previous)  /* inner block? */
+    movegotosout(fs, bl);  /* update pending gotos to outer block */
+  else if (bl->firstgoto < ls->dyd->gt.n)  /* pending gotos in outer block? */
+    undefgoto(ls, &ls->dyd->gt.arr[bl->firstgoto]);  /* error */
+}
+
+
+/*
+** adds a new prototype into list of prototypes
+*/
+static Proto *addprototype (LexState *ls) {
+  Proto *clp;
+  lua_State *L = ls->L;
+  FuncState *fs = ls->fs;
+  Proto *f = fs->f;  /* prototype of current function */
+  if (fs->np >= f->sizep) {
+    int oldsize = f->sizep;
+    luaM_growvector(L, f->p, fs->np, f->sizep, Proto *, MAXARG_Bx, "functions");
+    while (oldsize < f->sizep) f->p[oldsize++] = NULL;
+  }
+  f->p[fs->np++] = clp = luaF_newproto(L);
+  luaC_objbarrier(L, f, clp);
+  return clp;
+}
+
+
+/*
+** codes instruction to create new closure in parent function.
+** The OP_CLOSURE instruction must use the last available register,
+** so that, if it invokes the GC, the GC knows which registers
+** are in use at that time.
+*/
+static void codeclosure (LexState *ls, expdesc *v) {
+  FuncState *fs = ls->fs->prev;
+  init_exp(v, VRELOCABLE, luaK_codeABx(fs, OP_CLOSURE, 0, fs->np - 1));
+  luaK_exp2nextreg(fs, v);  /* fix it at the last register */
+}
+
+
+static void open_func (LexState *ls, FuncState *fs, BlockCnt *bl) {
+  lua_State *L = ls->L;
+  Proto *f;
+  fs->prev = ls->fs;  /* linked list of funcstates */
+  fs->ls = ls;
+  ls->fs = fs;
+  fs->pc = 0;
+  fs->lasttarget = 0;
+  fs->jpc = NO_JUMP;
+  fs->freereg = 0;
+  fs->nk = 0;
+  fs->np = 0;
+  fs->nups = 0;
+  fs->nlocvars = 0;
+  fs->nactvar = 0;
+  fs->firstlocal = ls->dyd->actvar.n;
+  fs->bl = NULL;
+  f = fs->f;
+  f->source = ls->source;
+  f->maxstacksize = 2;  /* registers 0/1 are always valid */
+  fs->h = luaH_new(L);
+  /* anchor table of constants (to avoid being collected) */
+  sethvalue2s(L, L->top, fs->h);
+  incr_top(L);
+  enterblock(fs, bl, 0);
+}
+
+
+static void close_func (LexState *ls) {
+  lua_State *L = ls->L;
+  FuncState *fs = ls->fs;
+  Proto *f = fs->f;
+  luaK_ret(fs, 0, 0);  /* final return */
+  leaveblock(fs);
+  luaM_reallocvector(L, f->code, f->sizecode, fs->pc, Instruction);
+  f->sizecode = fs->pc;
+  luaM_reallocvector(L, f->lineinfo, f->sizelineinfo, fs->pc, int);
+  f->sizelineinfo = fs->pc;
+  luaM_reallocvector(L, f->k, f->sizek, fs->nk, TValue);
+  f->sizek = fs->nk;
+  luaM_reallocvector(L, f->p, f->sizep, fs->np, Proto *);
+  f->sizep = fs->np;
+  luaM_reallocvector(L, f->locvars, f->sizelocvars, fs->nlocvars, LocVar);
+  f->sizelocvars = fs->nlocvars;
+  luaM_reallocvector(L, f->upvalues, f->sizeupvalues, fs->nups, Upvaldesc);
+  f->sizeupvalues = fs->nups;
+  lua_assert(fs->bl == NULL);
+  ls->fs = fs->prev;
+  /* last token read was anchored in defunct function; must re-anchor it */
+  anchor_token(ls);
+  L->top--;  /* pop table of constants */
+  luaC_checkGC(L);
+}
+
+
+
+/*============================================================*/
+/* GRAMMAR RULES */
+/*============================================================*/
+
+
+/*
+** check whether current token is in the follow set of a block.
+** 'until' closes syntactical blocks, but do not close scope,
+** so it handled in separate.
+*/
+static int block_follow (LexState *ls, int withuntil) {
+  switch (ls->t.token) {
+    case TK_ELSE: case TK_ELSEIF:
+    case TK_END: case TK_EOS:
+      return 1;
+    case TK_UNTIL: return withuntil;
+    default: return 0;
+  }
+}
+
+
+static void statlist (LexState *ls) {
+  /* statlist -> { stat [`;'] } */
+  while (!block_follow(ls, 1)) {
+    if (ls->t.token == TK_RETURN) {
+      statement(ls);
+      return;  /* 'return' must be last statement */
+    }
+    statement(ls);
+  }
+}
+
+
+static void fieldsel (LexState *ls, expdesc *v) {
+  /* fieldsel -> ['.' | ':'] NAME */
+  FuncState *fs = ls->fs;
+  expdesc key;
+  luaK_exp2anyregup(fs, v);
+  luaX_next(ls);  /* skip the dot or colon */
+  checkname(ls, &key);
+  luaK_indexed(fs, v, &key);
+}
+
+
+static void yindex (LexState *ls, expdesc *v) {
+  /* index -> '[' expr ']' */
+  luaX_next(ls);  /* skip the '[' */
+  expr(ls, v);
+  luaK_exp2val(ls->fs, v);
+  checknext(ls, ']');
+}
+
+
+/*
+** {======================================================================
+** Rules for Constructors
+** =======================================================================
+*/
+
+
+struct ConsControl {
+  expdesc v;  /* last list item read */
+  expdesc *t;  /* table descriptor */
+  int nh;  /* total number of `record' elements */
+  int na;  /* total number of array elements */
+  int tostore;  /* number of array elements pending to be stored */
+};
+
+
+static void recfield (LexState *ls, struct ConsControl *cc) {
+  /* recfield -> (NAME | `['exp1`]') = exp1 */
+  FuncState *fs = ls->fs;
+  int reg = ls->fs->freereg;
+  expdesc key, val;
+  int rkkey;
+  if (ls->t.token == TK_NAME) {
+    checklimit(fs, cc->nh, MAX_INT, "items in a constructor");
+    checkname(ls, &key);
+  }
+  else  /* ls->t.token == '[' */
+    yindex(ls, &key);
+  cc->nh++;
+  checknext(ls, '=');
+  rkkey = luaK_exp2RK(fs, &key);
+  expr(ls, &val);
+  luaK_codeABC(fs, OP_SETTABLE, cc->t->u.info, rkkey, luaK_exp2RK(fs, &val));
+  fs->freereg = reg;  /* free registers */
+}
+
+
+static void closelistfield (FuncState *fs, struct ConsControl *cc) {
+  if (cc->v.k == VVOID) return;  /* there is no list item */
+  luaK_exp2nextreg(fs, &cc->v);
+  cc->v.k = VVOID;
+  if (cc->tostore == LFIELDS_PER_FLUSH) {
+    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);  /* flush */
+    cc->tostore = 0;  /* no more items pending */
+  }
+}
+
+
+static void lastlistfield (FuncState *fs, struct ConsControl *cc) {
+  if (cc->tostore == 0) return;
+  if (hasmultret(cc->v.k)) {
+    luaK_setmultret(fs, &cc->v);
+    luaK_setlist(fs, cc->t->u.info, cc->na, LUA_MULTRET);
+    cc->na--;  /* do not count last expression (unknown number of elements) */
+  }
+  else {
+    if (cc->v.k != VVOID)
+      luaK_exp2nextreg(fs, &cc->v);
+    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);
+  }
+}
+
+
+static void listfield (LexState *ls, struct ConsControl *cc) {
+  /* listfield -> exp */
+  expr(ls, &cc->v);
+  checklimit(ls->fs, cc->na, MAX_INT, "items in a constructor");
+  cc->na++;
+  cc->tostore++;
+}
+
+
+static void field (LexState *ls, struct ConsControl *cc) {
+  /* field -> listfield | recfield */
+  switch(ls->t.token) {
+    case TK_NAME: {  /* may be 'listfield' or 'recfield' */
+      if (luaX_lookahead(ls) != '=')  /* expression? */
+        listfield(ls, cc);
+      else
+        recfield(ls, cc);
+      break;
+    }
+    case '[': {
+      recfield(ls, cc);
+      break;
+    }
+    default: {
+      listfield(ls, cc);
+      break;
+    }
+  }
+}
+
+
+static void constructor (LexState *ls, expdesc *t) {
+  /* constructor -> '{' [ field { sep field } [sep] ] '}'
+     sep -> ',' | ';' */
+  FuncState *fs = ls->fs;
+  int line = ls->linenumber;
+  int pc = luaK_codeABC(fs, OP_NEWTABLE, 0, 0, 0);
+  struct ConsControl cc;
+  cc.na = cc.nh = cc.tostore = 0;
+  cc.t = t;
+  init_exp(t, VRELOCABLE, pc);
+  init_exp(&cc.v, VVOID, 0);  /* no value (yet) */
+  luaK_exp2nextreg(ls->fs, t);  /* fix it at stack top */
+  checknext(ls, '{');
+  do {
+    lua_assert(cc.v.k == VVOID || cc.tostore > 0);
+    if (ls->t.token == '}') break;
+    closelistfield(fs, &cc);
+    field(ls, &cc);
+  } while (testnext(ls, ',') || testnext(ls, ';'));
+  check_match(ls, '}', '{', line);
+  lastlistfield(fs, &cc);
+  SETARG_B(fs->f->code[pc], luaO_int2fb(cc.na)); /* set initial array size */
+  SETARG_C(fs->f->code[pc], luaO_int2fb(cc.nh));  /* set initial table size */
+}
+
+/* }====================================================================== */
+
+
+
+static void parlist (LexState *ls) {
+  /* parlist -> [ param { `,' param } ] */
+  FuncState *fs = ls->fs;
+  Proto *f = fs->f;
+  int nparams = 0;
+  f->is_vararg = 0;
+  if (ls->t.token != ')') {  /* is `parlist' not empty? */
+    do {
+      switch (ls->t.token) {
+        case TK_NAME: {  /* param -> NAME */
+          new_localvar(ls, str_checkname(ls));
+          nparams++;
+          break;
+        }
+        case TK_DOTS: {  /* param -> `...' */
+          luaX_next(ls);
+          f->is_vararg = 1;
+          break;
+        }
+        default: luaX_syntaxerror(ls, "<name> or " LUA_QL("...") " expected");
+      }
+    } while (!f->is_vararg && testnext(ls, ','));
+  }
+  adjustlocalvars(ls, nparams);
+  f->numparams = cast_byte(fs->nactvar);
+  luaK_reserveregs(fs, fs->nactvar);  /* reserve register for parameters */
+}
+
+
+static void body (LexState *ls, expdesc *e, int ismethod, int line) {
+  /* body ->  `(' parlist `)' block END */
+  FuncState new_fs;
+  BlockCnt bl;
+  new_fs.f = addprototype(ls);
+  new_fs.f->linedefined = line;
+  open_func(ls, &new_fs, &bl);
+  checknext(ls, '(');
+  if (ismethod) {
+    new_localvarliteral(ls, "self");  /* create 'self' parameter */
+    adjustlocalvars(ls, 1);
+  }
+  parlist(ls);
+  checknext(ls, ')');
+  statlist(ls);
+  new_fs.f->lastlinedefined = ls->linenumber;
+  check_match(ls, TK_END, TK_FUNCTION, line);
+  codeclosure(ls, e);
+  close_func(ls);
+}
+
+
+static int explist (LexState *ls, expdesc *v) {
+  /* explist -> expr { `,' expr } */
+  int n = 1;  /* at least one expression */
+  expr(ls, v);
+  while (testnext(ls, ',')) {
+    luaK_exp2nextreg(ls->fs, v);
+    expr(ls, v);
+    n++;
+  }
+  return n;
+}
+
+
+static void funcargs (LexState *ls, expdesc *f, int line) {
+  FuncState *fs = ls->fs;
+  expdesc args;
+  int base, nparams;
+  switch (ls->t.token) {
+    case '(': {  /* funcargs -> `(' [ explist ] `)' */
+      luaX_next(ls);
+      if (ls->t.token == ')')  /* arg list is empty? */
+        args.k = VVOID;
+      else {
+        explist(ls, &args);
+        luaK_setmultret(fs, &args);
+      }
+      check_match(ls, ')', '(', line);
+      break;
+    }
+    case '{': {  /* funcargs -> constructor */
+      constructor(ls, &args);
+      break;
+    }
+    case TK_STRING: {  /* funcargs -> STRING */
+      codestring(ls, &args, ls->t.seminfo.ts);
+      luaX_next(ls);  /* must use `seminfo' before `next' */
+      break;
+    }
+    default: {
+      luaX_syntaxerror(ls, "function arguments expected");
+    }
+  }
+  lua_assert(f->k == VNONRELOC);
+  base = f->u.info;  /* base register for call */
+  if (hasmultret(args.k))
+    nparams = LUA_MULTRET;  /* open call */
+  else {
+    if (args.k != VVOID)
+      luaK_exp2nextreg(fs, &args);  /* close last argument */
+    nparams = fs->freereg - (base+1);
+  }
+  init_exp(f, VCALL, luaK_codeABC(fs, OP_CALL, base, nparams+1, 2));
+  luaK_fixline(fs, line);
+  fs->freereg = base+1;  /* call remove function and arguments and leaves
+                            (unless changed) one result */
+}
+
+
+
+
+/*
+** {======================================================================
+** Expression parsing
+** =======================================================================
+*/
+
+
+static void primaryexp (LexState *ls, expdesc *v) {
+  /* primaryexp -> NAME | '(' expr ')' */
+  switch (ls->t.token) {
+    case '(': {
+      int line = ls->linenumber;
+      luaX_next(ls);
+      expr(ls, v);
+      check_match(ls, ')', '(', line);
+      luaK_dischargevars(ls->fs, v);
+      return;
+    }
+    case TK_NAME: {
+      singlevar(ls, v);
+      return;
+    }
+    default: {
+      luaX_syntaxerror(ls, "unexpected symbol");
+    }
+  }
+}
+
+
+static void suffixedexp (LexState *ls, expdesc *v) {
+  /* suffixedexp ->
+       primaryexp { '.' NAME | '[' exp ']' | ':' NAME funcargs | funcargs } */
+  FuncState *fs = ls->fs;
+  int line = ls->linenumber;
+  primaryexp(ls, v);
+  for (;;) {
+    switch (ls->t.token) {
+      case '.': {  /* fieldsel */
+        fieldsel(ls, v);
+        break;
+      }
+      case '[': {  /* `[' exp1 `]' */
+        expdesc key;
+        luaK_exp2anyregup(fs, v);
+        yindex(ls, &key);
+        luaK_indexed(fs, v, &key);
+        break;
+      }
+      case ':': {  /* `:' NAME funcargs */
+        expdesc key;
+        luaX_next(ls);
+        checkname(ls, &key);
+        luaK_self(fs, v, &key);
+        funcargs(ls, v, line);
+        break;
+      }
+      case '(': case TK_STRING: case '{': {  /* funcargs */
+        luaK_exp2nextreg(fs, v);
+        funcargs(ls, v, line);
+        break;
+      }
+      default: return;
+    }
+  }
+}
+
+
+static void simpleexp (LexState *ls, expdesc *v) {
+  /* simpleexp -> NUMBER | STRING | NIL | TRUE | FALSE | ... |
+                  constructor | FUNCTION body | suffixedexp */
+  switch (ls->t.token) {
+    case TK_NUMBER: {
+      init_exp(v, VKNUM, 0);
+      v->u.nval = ls->t.seminfo.r;
+      break;
+    }
+    case TK_STRING: {
+      codestring(ls, v, ls->t.seminfo.ts);
+      break;
+    }
+    case TK_NIL: {
+      init_exp(v, VNIL, 0);
+      break;
+    }
+    case TK_TRUE: {
+      init_exp(v, VTRUE, 0);
+      break;
+    }
+    case TK_FALSE: {
+      init_exp(v, VFALSE, 0);
+      break;
+    }
+    case TK_DOTS: {  /* vararg */
+      FuncState *fs = ls->fs;
+      check_condition(ls, fs->f->is_vararg,
+                      "cannot use " LUA_QL("...") " outside a vararg function");
+      init_exp(v, VVARARG, luaK_codeABC(fs, OP_VARARG, 0, 1, 0));
+      break;
+    }
+    case '{': {  /* constructor */
+      constructor(ls, v);
+      return;
+    }
+    case TK_FUNCTION: {
+      luaX_next(ls);
+      body(ls, v, 0, ls->linenumber);
+      return;
+    }
+    default: {
+      suffixedexp(ls, v);
+      return;
+    }
+  }
+  luaX_next(ls);
+}
+
+
+static UnOpr getunopr (int op) {
+  switch (op) {
+    case TK_NOT: return OPR_NOT;
+    case '-': return OPR_MINUS;
+    case '#': return OPR_LEN;
+    default: return OPR_NOUNOPR;
+  }
+}
+
+
+static BinOpr getbinopr (int op) {
+  switch (op) {
+    case '+': return OPR_ADD;
+    case '-': return OPR_SUB;
+    case '*': return OPR_MUL;
+    case '/': return OPR_DIV;
+    case '%': return OPR_MOD;
+    case '^': return OPR_POW;
+    case TK_CONCAT: return OPR_CONCAT;
+    case TK_NE: return OPR_NE;
+    case TK_EQ: return OPR_EQ;
+    case '<': return OPR_LT;
+    case TK_LE: return OPR_LE;
+    case '>': return OPR_GT;
+    case TK_GE: return OPR_GE;
+    case TK_AND: return OPR_AND;
+    case TK_OR: return OPR_OR;
+    default: return OPR_NOBINOPR;
+  }
+}
+
+
+static const struct {
+  lu_byte left;  /* left priority for each binary operator */
+  lu_byte right; /* right priority */
+} priority[] = {  /* ORDER OPR */
+   {6, 6}, {6, 6}, {7, 7}, {7, 7}, {7, 7},  /* `+' `-' `*' `/' `%' */
+   {10, 9}, {5, 4},                 /* ^, .. (right associative) */
+   {3, 3}, {3, 3}, {3, 3},          /* ==, <, <= */
+   {3, 3}, {3, 3}, {3, 3},          /* ~=, >, >= */
+   {2, 2}, {1, 1}                   /* and, or */
+};
+
+#define UNARY_PRIORITY	8  /* priority for unary operators */
+
+
+/*
+** subexpr -> (simpleexp | unop subexpr) { binop subexpr }
+** where `binop' is any binary operator with a priority higher than `limit'
+*/
+static BinOpr subexpr (LexState *ls, expdesc *v, int limit) {
+  BinOpr op;
+  UnOpr uop;
+  enterlevel(ls);
+  uop = getunopr(ls->t.token);
+  if (uop != OPR_NOUNOPR) {
+    int line = ls->linenumber;
+    luaX_next(ls);
+    subexpr(ls, v, UNARY_PRIORITY);
+    luaK_prefix(ls->fs, uop, v, line);
+  }
+  else simpleexp(ls, v);
+  /* expand while operators have priorities higher than `limit' */
+  op = getbinopr(ls->t.token);
+  while (op != OPR_NOBINOPR && priority[op].left > limit) {
+    expdesc v2;
+    BinOpr nextop;
+    int line = ls->linenumber;
+    luaX_next(ls);
+    luaK_infix(ls->fs, op, v);
+    /* read sub-expression with higher priority */
+    nextop = subexpr(ls, &v2, priority[op].right);
+    luaK_posfix(ls->fs, op, v, &v2, line);
+    op = nextop;
+  }
+  leavelevel(ls);
+  return op;  /* return first untreated operator */
+}
+
+
+static void expr (LexState *ls, expdesc *v) {
+  subexpr(ls, v, 0);
+}
+
+/* }==================================================================== */
+
+
+
+/*
+** {======================================================================
+** Rules for Statements
+** =======================================================================
+*/
+
+
+static void block (LexState *ls) {
+  /* block -> statlist */
+  FuncState *fs = ls->fs;
+  BlockCnt bl;
+  enterblock(fs, &bl, 0);
+  statlist(ls);
+  leaveblock(fs);
+}
+
+
+/*
+** structure to chain all variables in the left-hand side of an
+** assignment
+*/
+struct LHS_assign {
+  struct LHS_assign *prev;
+  expdesc v;  /* variable (global, local, upvalue, or indexed) */
+};
+
+
+/*
+** check whether, in an assignment to an upvalue/local variable, the
+** upvalue/local variable is begin used in a previous assignment to a
+** table. If so, save original upvalue/local value in a safe place and
+** use this safe copy in the previous assignment.
+*/
+static void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v) {
+  FuncState *fs = ls->fs;
+  int extra = fs->freereg;  /* eventual position to save local variable */
+  int conflict = 0;
+  for (; lh; lh = lh->prev) {  /* check all previous assignments */
+    if (lh->v.k == VINDEXED) {  /* assigning to a table? */
+      /* table is the upvalue/local being assigned now? */
+      if (lh->v.u.ind.vt == v->k && lh->v.u.ind.t == v->u.info) {
+        conflict = 1;
+        lh->v.u.ind.vt = VLOCAL;
+        lh->v.u.ind.t = extra;  /* previous assignment will use safe copy */
+      }
+      /* index is the local being assigned? (index cannot be upvalue) */
+      if (v->k == VLOCAL && lh->v.u.ind.idx == v->u.info) {
+        conflict = 1;
+        lh->v.u.ind.idx = extra;  /* previous assignment will use safe copy */
+      }
+    }
+  }
+  if (conflict) {
+    /* copy upvalue/local value to a temporary (in position 'extra') */
+    OpCode op = (v->k == VLOCAL) ? OP_MOVE : OP_GETUPVAL;
+    luaK_codeABC(fs, op, extra, v->u.info, 0);
+    luaK_reserveregs(fs, 1);
+  }
+}
+
+
+static void assignment (LexState *ls, struct LHS_assign *lh, int nvars) {
+  expdesc e;
+  check_condition(ls, vkisvar(lh->v.k), "syntax error");
+  if (testnext(ls, ',')) {  /* assignment -> ',' suffixedexp assignment */
+    struct LHS_assign nv;
+    nv.prev = lh;
+    suffixedexp(ls, &nv.v);
+    if (nv.v.k != VINDEXED)
+      check_conflict(ls, lh, &nv.v);
+    checklimit(ls->fs, nvars + ls->L->nCcalls, LUAI_MAXCCALLS,
+                    "C levels");
+    assignment(ls, &nv, nvars+1);
+  }
+  else {  /* assignment -> `=' explist */
+    int nexps;
+    checknext(ls, '=');
+    nexps = explist(ls, &e);
+    if (nexps != nvars) {
+      adjust_assign(ls, nvars, nexps, &e);
+      if (nexps > nvars)
+        ls->fs->freereg -= nexps - nvars;  /* remove extra values */
+    }
+    else {
+      luaK_setoneret(ls->fs, &e);  /* close last expression */
+      luaK_storevar(ls->fs, &lh->v, &e);
+      return;  /* avoid default */
+    }
+  }
+  init_exp(&e, VNONRELOC, ls->fs->freereg-1);  /* default assignment */
+  luaK_storevar(ls->fs, &lh->v, &e);
+}
+
+
+static int cond (LexState *ls) {
+  /* cond -> exp */
+  expdesc v;
+  expr(ls, &v);  /* read condition */
+  if (v.k == VNIL) v.k = VFALSE;  /* `falses' are all equal here */
+  luaK_goiftrue(ls->fs, &v);
+  return v.f;
+}
+
+
+static void gotostat (LexState *ls, int pc) {
+  int line = ls->linenumber;
+  TString *label;
+  int g;
+  if (testnext(ls, TK_GOTO))
+    label = str_checkname(ls);
+  else {
+    luaX_next(ls);  /* skip break */
+    label = luaS_new(ls->L, "break");
+  }
+  g = newlabelentry(ls, &ls->dyd->gt, label, line, pc);
+  findlabel(ls, g);  /* close it if label already defined */
+}
+
+
+/* check for repeated labels on the same block */
+static void checkrepeated (FuncState *fs, Labellist *ll, TString *label) {
+  int i;
+  for (i = fs->bl->firstlabel; i < ll->n; i++) {
+    if (luaS_eqstr(label, ll->arr[i].name)) {
+      const char *msg = luaO_pushfstring(fs->ls->L,
+                          "label " LUA_QS " already defined on line %d",
+                          getstr(label), ll->arr[i].line);
+      semerror(fs->ls, msg);
+    }
+  }
+}
+
+
+/* skip no-op statements */
+static void skipnoopstat (LexState *ls) {
+  while (ls->t.token == ';' || ls->t.token == TK_DBCOLON)
+    statement(ls);
+}
+
+
+static void labelstat (LexState *ls, TString *label, int line) {
+  /* label -> '::' NAME '::' */
+  FuncState *fs = ls->fs;
+  Labellist *ll = &ls->dyd->label;
+  int l;  /* index of new label being created */
+  checkrepeated(fs, ll, label);  /* check for repeated labels */
+  checknext(ls, TK_DBCOLON);  /* skip double colon */
+  /* create new entry for this label */
+  l = newlabelentry(ls, ll, label, line, fs->pc);
+  skipnoopstat(ls);  /* skip other no-op statements */
+  if (block_follow(ls, 0)) {  /* label is last no-op statement in the block? */
+    /* assume that locals are already out of scope */
+    ll->arr[l].nactvar = fs->bl->nactvar;
+  }
+  findgotos(ls, &ll->arr[l]);
+}
+
+
+static void whilestat (LexState *ls, int line) {
+  /* whilestat -> WHILE cond DO block END */
+  FuncState *fs = ls->fs;
+  int whileinit;
+  int condexit;
+  BlockCnt bl;
+  luaX_next(ls);  /* skip WHILE */
+  whileinit = luaK_getlabel(fs);
+  condexit = cond(ls);
+  enterblock(fs, &bl, 1);
+  checknext(ls, TK_DO);
+  block(ls);
+  luaK_jumpto(fs, whileinit);
+  check_match(ls, TK_END, TK_WHILE, line);
+  leaveblock(fs);
+  luaK_patchtohere(fs, condexit);  /* false conditions finish the loop */
+}
+
+
+static void repeatstat (LexState *ls, int line) {
+  /* repeatstat -> REPEAT block UNTIL cond */
+  int condexit;
+  FuncState *fs = ls->fs;
+  int repeat_init = luaK_getlabel(fs);
+  BlockCnt bl1, bl2;
+  enterblock(fs, &bl1, 1);  /* loop block */
+  enterblock(fs, &bl2, 0);  /* scope block */
+  luaX_next(ls);  /* skip REPEAT */
+  statlist(ls);
+  check_match(ls, TK_UNTIL, TK_REPEAT, line);
+  condexit = cond(ls);  /* read condition (inside scope block) */
+  if (bl2.upval)  /* upvalues? */
+    luaK_patchclose(fs, condexit, bl2.nactvar);
+  leaveblock(fs);  /* finish scope */
+  luaK_patchlist(fs, condexit, repeat_init);  /* close the loop */
+  leaveblock(fs);  /* finish loop */
+}
+
+
+static int exp1 (LexState *ls) {
+  expdesc e;
+  int reg;
+  expr(ls, &e);
+  luaK_exp2nextreg(ls->fs, &e);
+  lua_assert(e.k == VNONRELOC);
+  reg = e.u.info;
+  return reg;
+}
+
+
+static void forbody (LexState *ls, int base, int line, int nvars, int isnum) {
+  /* forbody -> DO block */
+  BlockCnt bl;
+  FuncState *fs = ls->fs;
+  int prep, endfor;
+  adjustlocalvars(ls, 3);  /* control variables */
+  checknext(ls, TK_DO);
+  prep = isnum ? luaK_codeAsBx(fs, OP_FORPREP, base, NO_JUMP) : luaK_jump(fs);
+  enterblock(fs, &bl, 0);  /* scope for declared variables */
+  adjustlocalvars(ls, nvars);
+  luaK_reserveregs(fs, nvars);
+  block(ls);
+  leaveblock(fs);  /* end of scope for declared variables */
+  luaK_patchtohere(fs, prep);
+  if (isnum)  /* numeric for? */
+    endfor = luaK_codeAsBx(fs, OP_FORLOOP, base, NO_JUMP);
+  else {  /* generic for */
+    luaK_codeABC(fs, OP_TFORCALL, base, 0, nvars);
+    luaK_fixline(fs, line);
+    endfor = luaK_codeAsBx(fs, OP_TFORLOOP, base + 2, NO_JUMP);
+  }
+  luaK_patchlist(fs, endfor, prep + 1);
+  luaK_fixline(fs, line);
+}
+
+
+static void fornum (LexState *ls, TString *varname, int line) {
+  /* fornum -> NAME = exp1,exp1[,exp1] forbody */
+  FuncState *fs = ls->fs;
+  int base = fs->freereg;
+  new_localvarliteral(ls, "(for index)");
+  new_localvarliteral(ls, "(for limit)");
+  new_localvarliteral(ls, "(for step)");
+  new_localvar(ls, varname);
+  checknext(ls, '=');
+  exp1(ls);  /* initial value */
+  checknext(ls, ',');
+  exp1(ls);  /* limit */
+  if (testnext(ls, ','))
+    exp1(ls);  /* optional step */
+  else {  /* default step = 1 */
+    luaK_codek(fs, fs->freereg, luaK_numberK(fs, 1));
+    luaK_reserveregs(fs, 1);
+  }
+  forbody(ls, base, line, 1, 1);
+}
+
+
+static void forlist (LexState *ls, TString *indexname) {
+  /* forlist -> NAME {,NAME} IN explist forbody */
+  FuncState *fs = ls->fs;
+  expdesc e;
+  int nvars = 4;  /* gen, state, control, plus at least one declared var */
+  int line;
+  int base = fs->freereg;
+  /* create control variables */
+  new_localvarliteral(ls, "(for generator)");
+  new_localvarliteral(ls, "(for state)");
+  new_localvarliteral(ls, "(for control)");
+  /* create declared variables */
+  new_localvar(ls, indexname);
+  while (testnext(ls, ',')) {
+    new_localvar(ls, str_checkname(ls));
+    nvars++;
+  }
+  checknext(ls, TK_IN);
+  line = ls->linenumber;
+  adjust_assign(ls, 3, explist(ls, &e), &e);
+  luaK_checkstack(fs, 3);  /* extra space to call generator */
+  forbody(ls, base, line, nvars - 3, 0);
+}
+
+
+static void forstat (LexState *ls, int line) {
+  /* forstat -> FOR (fornum | forlist) END */
+  FuncState *fs = ls->fs;
+  TString *varname;
+  BlockCnt bl;
+  enterblock(fs, &bl, 1);  /* scope for loop and control variables */
+  luaX_next(ls);  /* skip `for' */
+  varname = str_checkname(ls);  /* first variable name */
+  switch (ls->t.token) {
+    case '=': fornum(ls, varname, line); break;
+    case ',': case TK_IN: forlist(ls, varname); break;
+    default: luaX_syntaxerror(ls, LUA_QL("=") " or " LUA_QL("in") " expected");
+  }
+  check_match(ls, TK_END, TK_FOR, line);
+  leaveblock(fs);  /* loop scope (`break' jumps to this point) */
+}
+
+
+static void test_then_block (LexState *ls, int *escapelist) {
+  /* test_then_block -> [IF | ELSEIF] cond THEN block */
+  BlockCnt bl;
+  FuncState *fs = ls->fs;
+  expdesc v;
+  int jf;  /* instruction to skip 'then' code (if condition is false) */
+  luaX_next(ls);  /* skip IF or ELSEIF */
+  expr(ls, &v);  /* read condition */
+  checknext(ls, TK_THEN);
+  if (ls->t.token == TK_GOTO || ls->t.token == TK_BREAK) {
+    luaK_goiffalse(ls->fs, &v);  /* will jump to label if condition is true */
+    enterblock(fs, &bl, 0);  /* must enter block before 'goto' */
+    gotostat(ls, v.t);  /* handle goto/break */
+    skipnoopstat(ls);  /* skip other no-op statements */
+    if (block_follow(ls, 0)) {  /* 'goto' is the entire block? */
+      leaveblock(fs);
+      return;  /* and that is it */
+    }
+    else  /* must skip over 'then' part if condition is false */
+      jf = luaK_jump(fs);
+  }
+  else {  /* regular case (not goto/break) */
+    luaK_goiftrue(ls->fs, &v);  /* skip over block if condition is false */
+    enterblock(fs, &bl, 0);
+    jf = v.f;
+  }
+  statlist(ls);  /* `then' part */
+  leaveblock(fs);
+  if (ls->t.token == TK_ELSE ||
+      ls->t.token == TK_ELSEIF)  /* followed by 'else'/'elseif'? */
+    luaK_concat(fs, escapelist, luaK_jump(fs));  /* must jump over it */
+  luaK_patchtohere(fs, jf);
+}
+
+
+static void ifstat (LexState *ls, int line) {
+  /* ifstat -> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */
+  FuncState *fs = ls->fs;
+  int escapelist = NO_JUMP;  /* exit list for finished parts */
+  test_then_block(ls, &escapelist);  /* IF cond THEN block */
+  while (ls->t.token == TK_ELSEIF)
+    test_then_block(ls, &escapelist);  /* ELSEIF cond THEN block */
+  if (testnext(ls, TK_ELSE))
+    block(ls);  /* `else' part */
+  check_match(ls, TK_END, TK_IF, line);
+  luaK_patchtohere(fs, escapelist);  /* patch escape list to 'if' end */
+}
+
+
+static void localfunc (LexState *ls) {
+  expdesc b;
+  FuncState *fs = ls->fs;
+  new_localvar(ls, str_checkname(ls));  /* new local variable */
+  adjustlocalvars(ls, 1);  /* enter its scope */
+  body(ls, &b, 0, ls->linenumber);  /* function created in next register */
+  /* debug information will only see the variable after this point! */
+  getlocvar(fs, b.u.info)->startpc = fs->pc;
+}
+
+
+static void localstat (LexState *ls) {
+  /* stat -> LOCAL NAME {`,' NAME} [`=' explist] */
+  int nvars = 0;
+  int nexps;
+  expdesc e;
+  do {
+    new_localvar(ls, str_checkname(ls));
+    nvars++;
+  } while (testnext(ls, ','));
+  if (testnext(ls, '='))
+    nexps = explist(ls, &e);
+  else {
+    e.k = VVOID;
+    nexps = 0;
+  }
+  adjust_assign(ls, nvars, nexps, &e);
+  adjustlocalvars(ls, nvars);
+}
+
+
+static int funcname (LexState *ls, expdesc *v) {
+  /* funcname -> NAME {fieldsel} [`:' NAME] */
+  int ismethod = 0;
+  singlevar(ls, v);
+  while (ls->t.token == '.')
+    fieldsel(ls, v);
+  if (ls->t.token == ':') {
+    ismethod = 1;
+    fieldsel(ls, v);
+  }
+  return ismethod;
+}
+
+
+static void funcstat (LexState *ls, int line) {
+  /* funcstat -> FUNCTION funcname body */
+  int ismethod;
+  expdesc v, b;
+  luaX_next(ls);  /* skip FUNCTION */
+  ismethod = funcname(ls, &v);
+  body(ls, &b, ismethod, line);
+  luaK_storevar(ls->fs, &v, &b);
+  luaK_fixline(ls->fs, line);  /* definition `happens' in the first line */
+}
+
+
+static void exprstat (LexState *ls) {
+  /* stat -> func | assignment */
+  FuncState *fs = ls->fs;
+  struct LHS_assign v;
+  suffixedexp(ls, &v.v);
+  if (ls->t.token == '=' || ls->t.token == ',') { /* stat -> assignment ? */
+    v.prev = NULL;
+    assignment(ls, &v, 1);
+  }
+  else {  /* stat -> func */
+    check_condition(ls, v.v.k == VCALL, "syntax error");
+    SETARG_C(getcode(fs, &v.v), 1);  /* call statement uses no results */
+  }
+}
+
+
+static void retstat (LexState *ls) {
+  /* stat -> RETURN [explist] [';'] */
+  FuncState *fs = ls->fs;
+  expdesc e;
+  int first, nret;  /* registers with returned values */
+  if (block_follow(ls, 1) || ls->t.token == ';')
+    first = nret = 0;  /* return no values */
+  else {
+    nret = explist(ls, &e);  /* optional return values */
+    if (hasmultret(e.k)) {
+      luaK_setmultret(fs, &e);
+      if (e.k == VCALL && nret == 1) {  /* tail call? */
+        SET_OPCODE(getcode(fs,&e), OP_TAILCALL);
+        lua_assert(GETARG_A(getcode(fs,&e)) == fs->nactvar);
+      }
+      first = fs->nactvar;
+      nret = LUA_MULTRET;  /* return all values */
+    }
+    else {
+      if (nret == 1)  /* only one single value? */
+        first = luaK_exp2anyreg(fs, &e);
+      else {
+        luaK_exp2nextreg(fs, &e);  /* values must go to the `stack' */
+        first = fs->nactvar;  /* return all `active' values */
+        lua_assert(nret == fs->freereg - first);
+      }
+    }
+  }
+  luaK_ret(fs, first, nret);
+  testnext(ls, ';');  /* skip optional semicolon */
+}
+
+
+static void statement (LexState *ls) {
+  int line = ls->linenumber;  /* may be needed for error messages */
+  enterlevel(ls);
+  switch (ls->t.token) {
+    case ';': {  /* stat -> ';' (empty statement) */
+      luaX_next(ls);  /* skip ';' */
+      break;
+    }
+    case TK_IF: {  /* stat -> ifstat */
+      ifstat(ls, line);
+      break;
+    }
+    case TK_WHILE: {  /* stat -> whilestat */
+      whilestat(ls, line);
+      break;
+    }
+    case TK_DO: {  /* stat -> DO block END */
+      luaX_next(ls);  /* skip DO */
+      block(ls);
+      check_match(ls, TK_END, TK_DO, line);
+      break;
+    }
+    case TK_FOR: {  /* stat -> forstat */
+      forstat(ls, line);
+      break;
+    }
+    case TK_REPEAT: {  /* stat -> repeatstat */
+      repeatstat(ls, line);
+      break;
+    }
+    case TK_FUNCTION: {  /* stat -> funcstat */
+      funcstat(ls, line);
+      break;
+    }
+    case TK_LOCAL: {  /* stat -> localstat */
+      luaX_next(ls);  /* skip LOCAL */
+      if (testnext(ls, TK_FUNCTION))  /* local function? */
+        localfunc(ls);
+      else
+        localstat(ls);
+      break;
+    }
+    case TK_DBCOLON: {  /* stat -> label */
+      luaX_next(ls);  /* skip double colon */
+      labelstat(ls, str_checkname(ls), line);
+      break;
+    }
+    case TK_RETURN: {  /* stat -> retstat */
+      luaX_next(ls);  /* skip RETURN */
+      retstat(ls);
+      break;
+    }
+    case TK_BREAK:   /* stat -> breakstat */
+    case TK_GOTO: {  /* stat -> 'goto' NAME */
+      gotostat(ls, luaK_jump(ls->fs));
+      break;
+    }
+    default: {  /* stat -> func | assignment */
+      exprstat(ls);
+      break;
+    }
+  }
+  lua_assert(ls->fs->f->maxstacksize >= ls->fs->freereg &&
+             ls->fs->freereg >= ls->fs->nactvar);
+  ls->fs->freereg = ls->fs->nactvar;  /* free registers */
+  leavelevel(ls);
+}
+
+/* }====================================================================== */
+
+
+/*
+** compiles the main function, which is a regular vararg function with an
+** upvalue named LUA_ENV
+*/
+static void mainfunc (LexState *ls, FuncState *fs) {
+  BlockCnt bl;
+  expdesc v;
+  open_func(ls, fs, &bl);
+  fs->f->is_vararg = 1;  /* main function is always vararg */
+  init_exp(&v, VLOCAL, 0);  /* create and... */
+  newupvalue(fs, ls->envn, &v);  /* ...set environment upvalue */
+  luaX_next(ls);  /* read first token */
+  statlist(ls);  /* parse main body */
+  check(ls, TK_EOS);
+  close_func(ls);
+}
+
+
+Closure *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff,
+                      Dyndata *dyd, const char *name, int firstchar) {
+  LexState lexstate;
+  FuncState funcstate;
+  Closure *cl = luaF_newLclosure(L, 1);  /* create main closure */
+  /* anchor closure (to avoid being collected) */
+  setclLvalue(L, L->top, cl);
+  incr_top(L);
+  funcstate.f = cl->l.p = luaF_newproto(L);
+  funcstate.f->source = luaS_new(L, name);  /* create and anchor TString */
+  lexstate.buff = buff;
+  lexstate.dyd = dyd;
+  dyd->actvar.n = dyd->gt.n = dyd->label.n = 0;
+  luaX_setinput(L, &lexstate, z, funcstate.f->source, firstchar);
+  mainfunc(&lexstate, &funcstate);
+  lua_assert(!funcstate.prev && funcstate.nups == 1 && !lexstate.fs);
+  /* all scopes should be correctly finished */
+  lua_assert(dyd->actvar.n == 0 && dyd->gt.n == 0 && dyd->label.n == 0);
+  return cl;  /* it's on the stack too */
+}
+
diff -ruNp src.hd/libs/lua/lparser.h src/libs/lua/lparser.h
--- src.hd/libs/lua/lparser.h	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lparser.h	2017-12-29 00:57:40 -0800
@@ -0,0 +1,119 @@
+/*
+** $Id: lparser.h,v 1.70 2012/05/08 13:53:33 roberto Exp $
+** Lua Parser
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lparser_h
+#define lparser_h
+
+#include "llimits.h"
+#include "lobject.h"
+#include "lzio.h"
+
+
+/*
+** Expression descriptor
+*/
+
+typedef enum {
+  VVOID,	/* no value */
+  VNIL,
+  VTRUE,
+  VFALSE,
+  VK,		/* info = index of constant in `k' */
+  VKNUM,	/* nval = numerical value */
+  VNONRELOC,	/* info = result register */
+  VLOCAL,	/* info = local register */
+  VUPVAL,       /* info = index of upvalue in 'upvalues' */
+  VINDEXED,	/* t = table register/upvalue; idx = index R/K */
+  VJMP,		/* info = instruction pc */
+  VRELOCABLE,	/* info = instruction pc */
+  VCALL,	/* info = instruction pc */
+  VVARARG	/* info = instruction pc */
+} expkind;
+
+
+#define vkisvar(k)	(VLOCAL <= (k) && (k) <= VINDEXED)
+#define vkisinreg(k)	((k) == VNONRELOC || (k) == VLOCAL)
+
+typedef struct expdesc {
+  expkind k;
+  union {
+    struct {  /* for indexed variables (VINDEXED) */
+      short idx;  /* index (R/K) */
+      lu_byte t;  /* table (register or upvalue) */
+      lu_byte vt;  /* whether 't' is register (VLOCAL) or upvalue (VUPVAL) */
+    } ind;
+    int info;  /* for generic use */
+    lua_Number nval;  /* for VKNUM */
+  } u;
+  int t;  /* patch list of `exit when true' */
+  int f;  /* patch list of `exit when false' */
+} expdesc;
+
+
+/* description of active local variable */
+typedef struct Vardesc {
+  short idx;  /* variable index in stack */
+} Vardesc;
+
+
+/* description of pending goto statements and label statements */
+typedef struct Labeldesc {
+  TString *name;  /* label identifier */
+  int pc;  /* position in code */
+  int line;  /* line where it appeared */
+  lu_byte nactvar;  /* local level where it appears in current block */
+} Labeldesc;
+
+
+/* list of labels or gotos */
+typedef struct Labellist {
+  Labeldesc *arr;  /* array */
+  int n;  /* number of entries in use */
+  int size;  /* array size */
+} Labellist;
+
+
+/* dynamic structures used by the parser */
+typedef struct Dyndata {
+  struct {  /* list of active local variables */
+    Vardesc *arr;
+    int n;
+    int size;
+  } actvar;
+  Labellist gt;  /* list of pending gotos */
+  Labellist label;   /* list of active labels */
+} Dyndata;
+
+
+/* control of blocks */
+struct BlockCnt;  /* defined in lparser.c */
+
+
+/* state needed to generate code for a given function */
+typedef struct FuncState {
+  Proto *f;  /* current function header */
+  Table *h;  /* table to find (and reuse) elements in `k' */
+  struct FuncState *prev;  /* enclosing function */
+  struct LexState *ls;  /* lexical state */
+  struct BlockCnt *bl;  /* chain of current blocks */
+  int pc;  /* next position to code (equivalent to `ncode') */
+  int lasttarget;   /* 'label' of last 'jump label' */
+  int jpc;  /* list of pending jumps to `pc' */
+  int nk;  /* number of elements in `k' */
+  int np;  /* number of elements in `p' */
+  int firstlocal;  /* index of first local var (in Dyndata array) */
+  short nlocvars;  /* number of elements in 'f->locvars' */
+  lu_byte nactvar;  /* number of active local variables */
+  lu_byte nups;  /* number of upvalues */
+  lu_byte freereg;  /* first free register */
+} FuncState;
+
+
+LUAI_FUNC Closure *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff,
+                                Dyndata *dyd, const char *name, int firstchar);
+
+
+#endif
diff -ruNp src.hd/libs/lua/lstate.c src/libs/lua/lstate.c
--- src.hd/libs/lua/lstate.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lstate.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,322 @@
+/*
+** $Id: lstate.c,v 2.99 2012/10/02 17:40:53 roberto Exp $
+** Global State
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stddef.h>
+#include <string.h>
+
+#define lstate_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lapi.h"
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "llex.h"
+#include "lmem.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+
+
+#if !defined(LUAI_GCPAUSE)
+#define LUAI_GCPAUSE	200  /* 200% */
+#endif
+
+#if !defined(LUAI_GCMAJOR)
+#define LUAI_GCMAJOR	200  /* 200% */
+#endif
+
+#if !defined(LUAI_GCMUL)
+#define LUAI_GCMUL	200 /* GC runs 'twice the speed' of memory allocation */
+#endif
+
+
+#define MEMERRMSG	"not enough memory"
+
+
+/*
+** a macro to help the creation of a unique random seed when a state is
+** created; the seed is used to randomize hashes.
+*/
+#if !defined(luai_makeseed)
+#include <time.h>
+#define luai_makeseed()		cast(unsigned int, time(NULL))
+#endif
+
+
+
+/*
+** thread state + extra space
+*/
+typedef struct LX {
+#if defined(LUAI_EXTRASPACE)
+  char buff[LUAI_EXTRASPACE];
+#endif
+  lua_State l;
+} LX;
+
+
+/*
+** Main thread combines a thread state and the global state
+*/
+typedef struct LG {
+  LX l;
+  global_State g;
+} LG;
+
+
+
+#define fromstate(L)	(cast(LX *, cast(lu_byte *, (L)) - offsetof(LX, l)))
+
+
+/*
+** Compute an initial seed as random as possible. In ANSI, rely on
+** Address Space Layout Randomization (if present) to increase
+** randomness..
+*/
+#define addbuff(b,p,e) \
+  { size_t t = cast(size_t, e); \
+    memcpy(buff + p, &t, sizeof(t)); p += sizeof(t); }
+
+static unsigned int makeseed (lua_State *L) {
+  char buff[4 * sizeof(size_t)];
+  unsigned int h = luai_makeseed();
+  int p = 0;
+  addbuff(buff, p, L);  /* heap variable */
+  addbuff(buff, p, &h);  /* local variable */
+  addbuff(buff, p, luaO_nilobject);  /* global variable */
+  addbuff(buff, p, &lua_newstate);  /* public function */
+  lua_assert(p == sizeof(buff));
+  return luaS_hash(buff, p, h);
+}
+
+
+/*
+** set GCdebt to a new value keeping the value (totalbytes + GCdebt)
+** invariant
+*/
+void luaE_setdebt (global_State *g, l_mem debt) {
+  g->totalbytes -= (debt - g->GCdebt);
+  g->GCdebt = debt;
+}
+
+
+CallInfo *luaE_extendCI (lua_State *L) {
+  CallInfo *ci = luaM_new(L, CallInfo);
+  lua_assert(L->ci->next == NULL);
+  L->ci->next = ci;
+  ci->previous = L->ci;
+  ci->next = NULL;
+  return ci;
+}
+
+
+void luaE_freeCI (lua_State *L) {
+  CallInfo *ci = L->ci;
+  CallInfo *next = ci->next;
+  ci->next = NULL;
+  while ((ci = next) != NULL) {
+    next = ci->next;
+    luaM_free(L, ci);
+  }
+}
+
+
+static void stack_init (lua_State *L1, lua_State *L) {
+  int i; CallInfo *ci;
+  /* initialize stack array */
+  L1->stack = luaM_newvector(L, BASIC_STACK_SIZE, TValue);
+  L1->stacksize = BASIC_STACK_SIZE;
+  for (i = 0; i < BASIC_STACK_SIZE; i++)
+    setnilvalue(L1->stack + i);  /* erase new stack */
+  L1->top = L1->stack;
+  L1->stack_last = L1->stack + L1->stacksize - EXTRA_STACK;
+  /* initialize first ci */
+  ci = &L1->base_ci;
+  ci->next = ci->previous = NULL;
+  ci->callstatus = 0;
+  ci->func = L1->top;
+  setnilvalue(L1->top++);  /* 'function' entry for this 'ci' */
+  ci->top = L1->top + LUA_MINSTACK;
+  L1->ci = ci;
+}
+
+
+static void freestack (lua_State *L) {
+  if (L->stack == NULL)
+    return;  /* stack not completely built yet */
+  L->ci = &L->base_ci;  /* free the entire 'ci' list */
+  luaE_freeCI(L);
+  luaM_freearray(L, L->stack, L->stacksize);  /* free stack array */
+}
+
+
+/*
+** Create registry table and its predefined values
+*/
+static void init_registry (lua_State *L, global_State *g) {
+  TValue mt;
+  /* create registry */
+  Table *registry = luaH_new(L);
+  sethvalue(L, &g->l_registry, registry);
+  luaH_resize(L, registry, LUA_RIDX_LAST, 0);
+  /* registry[LUA_RIDX_MAINTHREAD] = L */
+  setthvalue(L, &mt, L);
+  luaH_setint(L, registry, LUA_RIDX_MAINTHREAD, &mt);
+  /* registry[LUA_RIDX_GLOBALS] = table of globals */
+  sethvalue(L, &mt, luaH_new(L));
+  luaH_setint(L, registry, LUA_RIDX_GLOBALS, &mt);
+}
+
+
+/*
+** open parts of the state that may cause memory-allocation errors
+*/
+static void f_luaopen (lua_State *L, void *ud) {
+  global_State *g = G(L);
+  UNUSED(ud);
+  stack_init(L, L);  /* init stack */
+  init_registry(L, g);
+  luaS_resize(L, MINSTRTABSIZE);  /* initial size of string table */
+  luaT_init(L);
+  luaX_init(L);
+  /* pre-create memory-error message */
+  g->memerrmsg = luaS_newliteral(L, MEMERRMSG);
+  luaS_fix(g->memerrmsg);  /* it should never be collected */
+  g->gcrunning = 1;  /* allow gc */
+}
+
+
+/*
+** preinitialize a state with consistent values without allocating
+** any memory (to avoid errors)
+*/
+static void preinit_state (lua_State *L, global_State *g) {
+  G(L) = g;
+  L->stack = NULL;
+  L->ci = NULL;
+  L->stacksize = 0;
+  L->errorJmp = NULL;
+  L->nCcalls = 0;
+  L->hook = NULL;
+  L->hookmask = 0;
+  L->basehookcount = 0;
+  L->allowhook = 1;
+  resethookcount(L);
+  L->openupval = NULL;
+  L->nny = 1;
+  L->status = LUA_OK;
+  L->errfunc = 0;
+}
+
+
+static void close_state (lua_State *L) {
+  global_State *g = G(L);
+  luaF_close(L, L->stack);  /* close all upvalues for this thread */
+  luaC_freeallobjects(L);  /* collect all objects */
+  luaM_freearray(L, G(L)->strt.hash, G(L)->strt.size);
+  luaZ_freebuffer(L, &g->buff);
+  freestack(L);
+  lua_assert(gettotalbytes(g) == sizeof(LG));
+  (*g->frealloc)(g->ud, fromstate(L), sizeof(LG), 0);  /* free main block */
+}
+
+
+LUA_API lua_State *lua_newthread (lua_State *L) {
+  lua_State *L1;
+  lua_lock(L);
+  luaC_checkGC(L);
+  L1 = &luaC_newobj(L, LUA_TTHREAD, sizeof(LX), NULL, offsetof(LX, l))->th;
+  setthvalue(L, L->top, L1);
+  api_incr_top(L);
+  preinit_state(L1, G(L));
+  L1->hookmask = L->hookmask;
+  L1->basehookcount = L->basehookcount;
+  L1->hook = L->hook;
+  resethookcount(L1);
+  luai_userstatethread(L, L1);
+  stack_init(L1, L);  /* init stack */
+  lua_unlock(L);
+  return L1;
+}
+
+
+void luaE_freethread (lua_State *L, lua_State *L1) {
+  LX *l = fromstate(L1);
+  luaF_close(L1, L1->stack);  /* close all upvalues for this thread */
+  lua_assert(L1->openupval == NULL);
+  luai_userstatefree(L, L1);
+  freestack(L1);
+  luaM_free(L, l);
+}
+
+
+LUA_API lua_State *lua_newstate (lua_Alloc f, void *ud) {
+  int i;
+  lua_State *L;
+  global_State *g;
+  LG *l = cast(LG *, (*f)(ud, NULL, LUA_TTHREAD, sizeof(LG)));
+  if (l == NULL) return NULL;
+  L = &l->l.l;
+  g = &l->g;
+  L->next = NULL;
+  L->tt = LUA_TTHREAD;
+  g->currentwhite = bit2mask(WHITE0BIT, FIXEDBIT);
+  L->marked = luaC_white(g);
+  g->gckind = KGC_NORMAL;
+  preinit_state(L, g);
+  g->frealloc = f;
+  g->ud = ud;
+  g->mainthread = L;
+  g->seed = makeseed(L);
+  g->uvhead.u.l.prev = &g->uvhead;
+  g->uvhead.u.l.next = &g->uvhead;
+  g->gcrunning = 0;  /* no GC while building state */
+  g->GCestimate = 0;
+  g->strt.size = 0;
+  g->strt.nuse = 0;
+  g->strt.hash = NULL;
+  setnilvalue(&g->l_registry);
+  luaZ_initbuffer(L, &g->buff);
+  g->panic = NULL;
+  g->version = lua_version(NULL);
+  g->gcstate = GCSpause;
+  g->allgc = NULL;
+  g->finobj = NULL;
+  g->tobefnz = NULL;
+  g->sweepgc = g->sweepfin = NULL;
+  g->gray = g->grayagain = NULL;
+  g->weak = g->ephemeron = g->allweak = NULL;
+  g->totalbytes = sizeof(LG);
+  g->GCdebt = 0;
+  g->gcpause = LUAI_GCPAUSE;
+  g->gcmajorinc = LUAI_GCMAJOR;
+  g->gcstepmul = LUAI_GCMUL;
+  for (i=0; i < LUA_NUMTAGS; i++) g->mt[i] = NULL;
+  if (luaD_rawrunprotected(L, f_luaopen, NULL) != LUA_OK) {
+    /* memory allocation error: free partial state */
+    close_state(L);
+    L = NULL;
+  }
+  else
+    luai_userstateopen(L);
+  return L;
+}
+
+
+LUA_API void lua_close (lua_State *L) {
+  L = G(L)->mainthread;  /* only the main thread can be closed */
+  lua_lock(L);
+  luai_userstateclose(L);
+  close_state(L);
+}
+
+
diff -ruNp src.hd/libs/lua/lstate.h src/libs/lua/lstate.h
--- src.hd/libs/lua/lstate.h	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lstate.h	2017-12-29 00:57:40 -0800
@@ -0,0 +1,228 @@
+/*
+** $Id: lstate.h,v 2.82 2012/07/02 13:37:04 roberto Exp $
+** Global State
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lstate_h
+#define lstate_h
+
+#include "lua.h"
+
+#include "lobject.h"
+#include "ltm.h"
+#include "lzio.h"
+
+
+/*
+
+** Some notes about garbage-collected objects:  All objects in Lua must
+** be kept somehow accessible until being freed.
+**
+** Lua keeps most objects linked in list g->allgc. The link uses field
+** 'next' of the CommonHeader.
+**
+** Strings are kept in several lists headed by the array g->strt.hash.
+**
+** Open upvalues are not subject to independent garbage collection. They
+** are collected together with their respective threads. Lua keeps a
+** double-linked list with all open upvalues (g->uvhead) so that it can
+** mark objects referred by them. (They are always gray, so they must
+** be remarked in the atomic step. Usually their contents would be marked
+** when traversing the respective threads, but the thread may already be
+** dead, while the upvalue is still accessible through closures.)
+**
+** Objects with finalizers are kept in the list g->finobj.
+**
+** The list g->tobefnz links all objects being finalized.
+
+*/
+
+
+struct lua_longjmp;  /* defined in ldo.c */
+
+
+
+/* extra stack space to handle TM calls and some other extras */
+#define EXTRA_STACK   5
+
+
+#define BASIC_STACK_SIZE        (2*LUA_MINSTACK)
+
+
+/* kinds of Garbage Collection */
+#define KGC_NORMAL	0
+#define KGC_EMERGENCY	1	/* gc was forced by an allocation failure */
+#define KGC_GEN		2	/* generational collection */
+
+
+typedef struct stringtable {
+  GCObject **hash;
+  lu_int32 nuse;  /* number of elements */
+  int size;
+} stringtable;
+
+
+/*
+** information about a call
+*/
+typedef struct CallInfo {
+  StkId func;  /* function index in the stack */
+  StkId	top;  /* top for this function */
+  struct CallInfo *previous, *next;  /* dynamic call link */
+  short nresults;  /* expected number of results from this function */
+  lu_byte callstatus;
+  ptrdiff_t extra;
+  union {
+    struct {  /* only for Lua functions */
+      StkId base;  /* base for this function */
+      const Instruction *savedpc;
+    } l;
+    struct {  /* only for C functions */
+      int ctx;  /* context info. in case of yields */
+      lua_CFunction k;  /* continuation in case of yields */
+      ptrdiff_t old_errfunc;
+      lu_byte old_allowhook;
+      lu_byte status;
+    } c;
+  } u;
+} CallInfo;
+
+
+/*
+** Bits in CallInfo status
+*/
+#define CIST_LUA	(1<<0)	/* call is running a Lua function */
+#define CIST_HOOKED	(1<<1)	/* call is running a debug hook */
+#define CIST_REENTRY	(1<<2)	/* call is running on same invocation of
+                                   luaV_execute of previous call */
+#define CIST_YIELDED	(1<<3)	/* call reentered after suspension */
+#define CIST_YPCALL	(1<<4)	/* call is a yieldable protected call */
+#define CIST_STAT	(1<<5)	/* call has an error status (pcall) */
+#define CIST_TAIL	(1<<6)	/* call was tail called */
+#define CIST_HOOKYIELD	(1<<7)	/* last hook called yielded */
+
+
+#define isLua(ci)	((ci)->callstatus & CIST_LUA)
+
+
+/*
+** `global state', shared by all threads of this state
+*/
+typedef struct global_State {
+  lua_Alloc frealloc;  /* function to reallocate memory */
+  void *ud;         /* auxiliary data to `frealloc' */
+  lu_mem totalbytes;  /* number of bytes currently allocated - GCdebt */
+  l_mem GCdebt;  /* bytes allocated not yet compensated by the collector */
+  lu_mem GCmemtrav;  /* memory traversed by the GC */
+  lu_mem GCestimate;  /* an estimate of the non-garbage memory in use */
+  stringtable strt;  /* hash table for strings */
+  TValue l_registry;
+  unsigned int seed;  /* randomized seed for hashes */
+  lu_byte currentwhite;
+  lu_byte gcstate;  /* state of garbage collector */
+  lu_byte gckind;  /* kind of GC running */
+  lu_byte gcrunning;  /* true if GC is running */
+  int sweepstrgc;  /* position of sweep in `strt' */
+  GCObject *allgc;  /* list of all collectable objects */
+  GCObject *finobj;  /* list of collectable objects with finalizers */
+  GCObject **sweepgc;  /* current position of sweep in list 'allgc' */
+  GCObject **sweepfin;  /* current position of sweep in list 'finobj' */
+  GCObject *gray;  /* list of gray objects */
+  GCObject *grayagain;  /* list of objects to be traversed atomically */
+  GCObject *weak;  /* list of tables with weak values */
+  GCObject *ephemeron;  /* list of ephemeron tables (weak keys) */
+  GCObject *allweak;  /* list of all-weak tables */
+  GCObject *tobefnz;  /* list of userdata to be GC */
+  UpVal uvhead;  /* head of double-linked list of all open upvalues */
+  Mbuffer buff;  /* temporary buffer for string concatenation */
+  int gcpause;  /* size of pause between successive GCs */
+  int gcmajorinc;  /* pause between major collections (only in gen. mode) */
+  int gcstepmul;  /* GC `granularity' */
+  lua_CFunction panic;  /* to be called in unprotected errors */
+  struct lua_State *mainthread;
+  const lua_Number *version;  /* pointer to version number */
+  TString *memerrmsg;  /* memory-error message */
+  TString *tmname[TM_N];  /* array with tag-method names */
+  struct Table *mt[LUA_NUMTAGS];  /* metatables for basic types */
+} global_State;
+
+
+/*
+** `per thread' state
+*/
+struct lua_State {
+  CommonHeader;
+  lu_byte status;
+  StkId top;  /* first free slot in the stack */
+  global_State *l_G;
+  CallInfo *ci;  /* call info for current function */
+  const Instruction *oldpc;  /* last pc traced */
+  StkId stack_last;  /* last free slot in the stack */
+  StkId stack;  /* stack base */
+  int stacksize;
+  unsigned short nny;  /* number of non-yieldable calls in stack */
+  unsigned short nCcalls;  /* number of nested C calls */
+  lu_byte hookmask;
+  lu_byte allowhook;
+  int basehookcount;
+  int hookcount;
+  lua_Hook hook;
+  GCObject *openupval;  /* list of open upvalues in this stack */
+  GCObject *gclist;
+  struct lua_longjmp *errorJmp;  /* current error recover point */
+  ptrdiff_t errfunc;  /* current error handling function (stack index) */
+  CallInfo base_ci;  /* CallInfo for first level (C calling Lua) */
+};
+
+
+#define G(L)	(L->l_G)
+
+
+/*
+** Union of all collectable objects
+*/
+union GCObject {
+  GCheader gch;  /* common header */
+  union TString ts;
+  union Udata u;
+  union Closure cl;
+  struct Table h;
+  struct Proto p;
+  struct UpVal uv;
+  struct lua_State th;  /* thread */
+};
+
+
+#define gch(o)		(&(o)->gch)
+
+/* macros to convert a GCObject into a specific value */
+#define rawgco2ts(o)  \
+	check_exp(novariant((o)->gch.tt) == LUA_TSTRING, &((o)->ts))
+#define gco2ts(o)	(&rawgco2ts(o)->tsv)
+#define rawgco2u(o)	check_exp((o)->gch.tt == LUA_TUSERDATA, &((o)->u))
+#define gco2u(o)	(&rawgco2u(o)->uv)
+#define gco2lcl(o)	check_exp((o)->gch.tt == LUA_TLCL, &((o)->cl.l))
+#define gco2ccl(o)	check_exp((o)->gch.tt == LUA_TCCL, &((o)->cl.c))
+#define gco2cl(o)  \
+	check_exp(novariant((o)->gch.tt) == LUA_TFUNCTION, &((o)->cl))
+#define gco2t(o)	check_exp((o)->gch.tt == LUA_TTABLE, &((o)->h))
+#define gco2p(o)	check_exp((o)->gch.tt == LUA_TPROTO, &((o)->p))
+#define gco2uv(o)	check_exp((o)->gch.tt == LUA_TUPVAL, &((o)->uv))
+#define gco2th(o)	check_exp((o)->gch.tt == LUA_TTHREAD, &((o)->th))
+
+/* macro to convert any Lua object into a GCObject */
+#define obj2gco(v)	(cast(GCObject *, (v)))
+
+
+/* actual number of total bytes allocated */
+#define gettotalbytes(g)	((g)->totalbytes + (g)->GCdebt)
+
+LUAI_FUNC void luaE_setdebt (global_State *g, l_mem debt);
+LUAI_FUNC void luaE_freethread (lua_State *L, lua_State *L1);
+LUAI_FUNC CallInfo *luaE_extendCI (lua_State *L);
+LUAI_FUNC void luaE_freeCI (lua_State *L);
+
+
+#endif
+
diff -ruNp src.hd/libs/lua/lstring.c src/libs/lua/lstring.c
--- src.hd/libs/lua/lstring.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lstring.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,185 @@
+/*
+** $Id: lstring.c,v 2.26 2013/01/08 13:50:10 roberto Exp $
+** String table (keeps all strings handled by Lua)
+** See Copyright Notice in lua.h
+*/
+
+
+#include <string.h>
+
+#define lstring_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+
+
+/*
+** Lua will use at most ~(2^LUAI_HASHLIMIT) bytes from a string to
+** compute its hash
+*/
+#if !defined(LUAI_HASHLIMIT)
+#define LUAI_HASHLIMIT		5
+#endif
+
+
+/*
+** equality for long strings
+*/
+int luaS_eqlngstr (TString *a, TString *b) {
+  size_t len = a->tsv.len;
+  lua_assert(a->tsv.tt == LUA_TLNGSTR && b->tsv.tt == LUA_TLNGSTR);
+  return (a == b) ||  /* same instance or... */
+    ((len == b->tsv.len) &&  /* equal length and ... */
+     (memcmp(getstr(a), getstr(b), len) == 0));  /* equal contents */
+}
+
+
+/*
+** equality for strings
+*/
+int luaS_eqstr (TString *a, TString *b) {
+  return (a->tsv.tt == b->tsv.tt) &&
+         (a->tsv.tt == LUA_TSHRSTR ? eqshrstr(a, b) : luaS_eqlngstr(a, b));
+}
+
+
+unsigned int luaS_hash (const char *str, size_t l, unsigned int seed) {
+  unsigned int h = seed ^ cast(unsigned int, l);
+  size_t l1;
+  size_t step = (l >> LUAI_HASHLIMIT) + 1;
+  for (l1 = l; l1 >= step; l1 -= step)
+    h = h ^ ((h<<5) + (h>>2) + cast_byte(str[l1 - 1]));
+  return h;
+}
+
+
+/*
+** resizes the string table
+*/
+void luaS_resize (lua_State *L, int newsize) {
+  int i;
+  stringtable *tb = &G(L)->strt;
+  /* cannot resize while GC is traversing strings */
+  luaC_runtilstate(L, ~bitmask(GCSsweepstring));
+  if (newsize > tb->size) {
+    luaM_reallocvector(L, tb->hash, tb->size, newsize, GCObject *);
+    for (i = tb->size; i < newsize; i++) tb->hash[i] = NULL;
+  }
+  /* rehash */
+  for (i=0; i<tb->size; i++) {
+    GCObject *p = tb->hash[i];
+    tb->hash[i] = NULL;
+    while (p) {  /* for each node in the list */
+      GCObject *next = gch(p)->next;  /* save next */
+      unsigned int h = lmod(gco2ts(p)->hash, newsize);  /* new position */
+      gch(p)->next = tb->hash[h];  /* chain it */
+      tb->hash[h] = p;
+      resetoldbit(p);  /* see MOVE OLD rule */
+      p = next;
+    }
+  }
+  if (newsize < tb->size) {
+    /* shrinking slice must be empty */
+    lua_assert(tb->hash[newsize] == NULL && tb->hash[tb->size - 1] == NULL);
+    luaM_reallocvector(L, tb->hash, tb->size, newsize, GCObject *);
+  }
+  tb->size = newsize;
+}
+
+
+/*
+** creates a new string object
+*/
+static TString *createstrobj (lua_State *L, const char *str, size_t l,
+                              int tag, unsigned int h, GCObject **list) {
+  TString *ts;
+  size_t totalsize;  /* total size of TString object */
+  totalsize = sizeof(TString) + ((l + 1) * sizeof(char));
+  ts = &luaC_newobj(L, tag, totalsize, list, 0)->ts;
+  ts->tsv.len = l;
+  ts->tsv.hash = h;
+  ts->tsv.extra = 0;
+  memcpy(ts+1, str, l*sizeof(char));
+  ((char *)(ts+1))[l] = '\0';  /* ending 0 */
+  return ts;
+}
+
+
+/*
+** creates a new short string, inserting it into string table
+*/
+static TString *newshrstr (lua_State *L, const char *str, size_t l,
+                                       unsigned int h) {
+  GCObject **list;  /* (pointer to) list where it will be inserted */
+  stringtable *tb = &G(L)->strt;
+  TString *s;
+  if (tb->nuse >= cast(lu_int32, tb->size) && tb->size <= MAX_INT/2)
+    luaS_resize(L, tb->size*2);  /* too crowded */
+  list = &tb->hash[lmod(h, tb->size)];
+  s = createstrobj(L, str, l, LUA_TSHRSTR, h, list);
+  tb->nuse++;
+  return s;
+}
+
+
+/*
+** checks whether short string exists and reuses it or creates a new one
+*/
+static TString *internshrstr (lua_State *L, const char *str, size_t l) {
+  GCObject *o;
+  global_State *g = G(L);
+  unsigned int h = luaS_hash(str, l, g->seed);
+  for (o = g->strt.hash[lmod(h, g->strt.size)];
+       o != NULL;
+       o = gch(o)->next) {
+    TString *ts = rawgco2ts(o);
+    if (h == ts->tsv.hash &&
+        l == ts->tsv.len &&
+        (memcmp(str, getstr(ts), l * sizeof(char)) == 0)) {
+      if (isdead(G(L), o))  /* string is dead (but was not collected yet)? */
+        changewhite(o);  /* resurrect it */
+      return ts;
+    }
+  }
+  return newshrstr(L, str, l, h);  /* not found; create a new string */
+}
+
+
+/*
+** new string (with explicit length)
+*/
+TString *luaS_newlstr (lua_State *L, const char *str, size_t l) {
+  if (l <= LUAI_MAXSHORTLEN)  /* short string? */
+    return internshrstr(L, str, l);
+  else {
+    if (l + 1 > (MAX_SIZET - sizeof(TString))/sizeof(char))
+      luaM_toobig(L);
+    return createstrobj(L, str, l, LUA_TLNGSTR, G(L)->seed, NULL);
+  }
+}
+
+
+/*
+** new zero-terminated string
+*/
+TString *luaS_new (lua_State *L, const char *str) {
+  return luaS_newlstr(L, str, strlen(str));
+}
+
+
+Udata *luaS_newudata (lua_State *L, size_t s, Table *e) {
+  Udata *u;
+  if (s > MAX_SIZET - sizeof(Udata))
+    luaM_toobig(L);
+  u = &luaC_newobj(L, LUA_TUSERDATA, sizeof(Udata) + s, NULL, 0)->u;
+  u->uv.len = s;
+  u->uv.metatable = NULL;
+  u->uv.env = e;
+  return u;
+}
+
diff -ruNp src.hd/libs/lua/lstring.h src/libs/lua/lstring.h
--- src.hd/libs/lua/lstring.h	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lstring.h	2017-12-29 00:57:40 -0800
@@ -0,0 +1,46 @@
+/*
+** $Id: lstring.h,v 1.49 2012/02/01 21:57:15 roberto Exp $
+** String table (keep all strings handled by Lua)
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lstring_h
+#define lstring_h
+
+#include "lgc.h"
+#include "lobject.h"
+#include "lstate.h"
+
+
+#define sizestring(s)	(sizeof(union TString)+((s)->len+1)*sizeof(char))
+
+#define sizeudata(u)	(sizeof(union Udata)+(u)->len)
+
+#define luaS_newliteral(L, s)	(luaS_newlstr(L, "" s, \
+                                 (sizeof(s)/sizeof(char))-1))
+
+#define luaS_fix(s)	l_setbit((s)->tsv.marked, FIXEDBIT)
+
+
+/*
+** test whether a string is a reserved word
+*/
+#define isreserved(s)	((s)->tsv.tt == LUA_TSHRSTR && (s)->tsv.extra > 0)
+
+
+/*
+** equality for short strings, which are always internalized
+*/
+#define eqshrstr(a,b)	check_exp((a)->tsv.tt == LUA_TSHRSTR, (a) == (b))
+
+
+LUAI_FUNC unsigned int luaS_hash (const char *str, size_t l, unsigned int seed);
+LUAI_FUNC int luaS_eqlngstr (TString *a, TString *b);
+LUAI_FUNC int luaS_eqstr (TString *a, TString *b);
+LUAI_FUNC void luaS_resize (lua_State *L, int newsize);
+LUAI_FUNC Udata *luaS_newudata (lua_State *L, size_t s, Table *e);
+LUAI_FUNC TString *luaS_newlstr (lua_State *L, const char *str, size_t l);
+LUAI_FUNC TString *luaS_new (lua_State *L, const char *str);
+
+
+#endif
diff -ruNp src.hd/libs/lua/lstrlib.c src/libs/lua/lstrlib.c
--- src.hd/libs/lua/lstrlib.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lstrlib.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,1019 @@
+/*
+** $Id: lstrlib.c,v 1.178 2012/08/14 18:12:34 roberto Exp $
+** Standard library for string operations and pattern-matching
+** See Copyright Notice in lua.h
+*/
+
+
+#include <ctype.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define lstrlib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+/*
+** maximum number of captures that a pattern can do during
+** pattern-matching. This limit is arbitrary.
+*/
+#if !defined(LUA_MAXCAPTURES)
+#define LUA_MAXCAPTURES		32
+#endif
+
+
+/* macro to `unsign' a character */
+#define uchar(c)	((unsigned char)(c))
+
+
+
+static int str_len (lua_State *L) {
+  size_t l;
+  luaL_checklstring(L, 1, &l);
+  lua_pushinteger(L, (lua_Integer)l);
+  return 1;
+}
+
+
+/* translate a relative string position: negative means back from end */
+static size_t posrelat (ptrdiff_t pos, size_t len) {
+  if (pos >= 0) return (size_t)pos;
+  else if (0u - (size_t)pos > len) return 0;
+  else return len - ((size_t)-pos) + 1;
+}
+
+
+static int str_sub (lua_State *L) {
+  size_t l;
+  const char *s = luaL_checklstring(L, 1, &l);
+  size_t start = posrelat(luaL_checkinteger(L, 2), l);
+  size_t end = posrelat(luaL_optinteger(L, 3, -1), l);
+  if (start < 1) start = 1;
+  if (end > l) end = l;
+  if (start <= end)
+    lua_pushlstring(L, s + start - 1, end - start + 1);
+  else lua_pushliteral(L, "");
+  return 1;
+}
+
+
+static int str_reverse (lua_State *L) {
+  size_t l, i;
+  luaL_Buffer b;
+  const char *s = luaL_checklstring(L, 1, &l);
+  char *p = luaL_buffinitsize(L, &b, l);
+  for (i = 0; i < l; i++)
+    p[i] = s[l - i - 1];
+  luaL_pushresultsize(&b, l);
+  return 1;
+}
+
+
+static int str_lower (lua_State *L) {
+  size_t l;
+  size_t i;
+  luaL_Buffer b;
+  const char *s = luaL_checklstring(L, 1, &l);
+  char *p = luaL_buffinitsize(L, &b, l);
+  for (i=0; i<l; i++)
+    p[i] = tolower(uchar(s[i]));
+  luaL_pushresultsize(&b, l);
+  return 1;
+}
+
+
+static int str_upper (lua_State *L) {
+  size_t l;
+  size_t i;
+  luaL_Buffer b;
+  const char *s = luaL_checklstring(L, 1, &l);
+  char *p = luaL_buffinitsize(L, &b, l);
+  for (i=0; i<l; i++)
+    p[i] = toupper(uchar(s[i]));
+  luaL_pushresultsize(&b, l);
+  return 1;
+}
+
+
+/* reasonable limit to avoid arithmetic overflow */
+#define MAXSIZE		((~(size_t)0) >> 1)
+
+static int str_rep (lua_State *L) {
+  size_t l, lsep;
+  const char *s = luaL_checklstring(L, 1, &l);
+  int n = luaL_checkint(L, 2);
+  const char *sep = luaL_optlstring(L, 3, "", &lsep);
+  if (n <= 0) lua_pushliteral(L, "");
+  else if (l + lsep < l || l + lsep >= MAXSIZE / n)  /* may overflow? */
+    return luaL_error(L, "resulting string too large");
+  else {
+    size_t totallen = n * l + (n - 1) * lsep;
+    luaL_Buffer b;
+    char *p = luaL_buffinitsize(L, &b, totallen);
+    while (n-- > 1) {  /* first n-1 copies (followed by separator) */
+      memcpy(p, s, l * sizeof(char)); p += l;
+      if (lsep > 0) {  /* avoid empty 'memcpy' (may be expensive) */
+        memcpy(p, sep, lsep * sizeof(char)); p += lsep;
+      }
+    }
+    memcpy(p, s, l * sizeof(char));  /* last copy (not followed by separator) */
+    luaL_pushresultsize(&b, totallen);
+  }
+  return 1;
+}
+
+
+static int str_byte (lua_State *L) {
+  size_t l;
+  const char *s = luaL_checklstring(L, 1, &l);
+  size_t posi = posrelat(luaL_optinteger(L, 2, 1), l);
+  size_t pose = posrelat(luaL_optinteger(L, 3, posi), l);
+  int n, i;
+  if (posi < 1) posi = 1;
+  if (pose > l) pose = l;
+  if (posi > pose) return 0;  /* empty interval; return no values */
+  n = (int)(pose -  posi + 1);
+  if (posi + n <= pose)  /* (size_t -> int) overflow? */
+    return luaL_error(L, "string slice too long");
+  luaL_checkstack(L, n, "string slice too long");
+  for (i=0; i<n; i++)
+    lua_pushinteger(L, uchar(s[posi+i-1]));
+  return n;
+}
+
+
+static int str_char (lua_State *L) {
+  int n = lua_gettop(L);  /* number of arguments */
+  int i;
+  luaL_Buffer b;
+  char *p = luaL_buffinitsize(L, &b, n);
+  for (i=1; i<=n; i++) {
+    int c = luaL_checkint(L, i);
+    luaL_argcheck(L, uchar(c) == c, i, "value out of range");
+    p[i - 1] = uchar(c);
+  }
+  luaL_pushresultsize(&b, n);
+  return 1;
+}
+
+
+static int writer (lua_State *L, const void* b, size_t size, void* B) {
+  (void)L;
+  luaL_addlstring((luaL_Buffer*) B, (const char *)b, size);
+  return 0;
+}
+
+
+static int str_dump (lua_State *L) {
+  luaL_Buffer b;
+  luaL_checktype(L, 1, LUA_TFUNCTION);
+  lua_settop(L, 1);
+  luaL_buffinit(L,&b);
+  if (lua_dump(L, writer, &b) != 0)
+    return luaL_error(L, "unable to dump given function");
+  luaL_pushresult(&b);
+  return 1;
+}
+
+
+
+/*
+** {======================================================
+** PATTERN MATCHING
+** =======================================================
+*/
+
+
+#define CAP_UNFINISHED	(-1)
+#define CAP_POSITION	(-2)
+
+
+typedef struct MatchState {
+  int matchdepth;  /* control for recursive depth (to avoid C stack overflow) */
+  const char *src_init;  /* init of source string */
+  const char *src_end;  /* end ('\0') of source string */
+  const char *p_end;  /* end ('\0') of pattern */
+  lua_State *L;
+  int level;  /* total number of captures (finished or unfinished) */
+  struct {
+    const char *init;
+    ptrdiff_t len;
+  } capture[LUA_MAXCAPTURES];
+} MatchState;
+
+
+/* recursive function */
+static const char *match (MatchState *ms, const char *s, const char *p);
+
+
+/* maximum recursion depth for 'match' */
+#if !defined(MAXCCALLS)
+#define MAXCCALLS	200
+#endif
+
+
+#define L_ESC		'%'
+#define SPECIALS	"^$*+?.([%-"
+
+
+static int check_capture (MatchState *ms, int l) {
+  l -= '1';
+  if (l < 0 || l >= ms->level || ms->capture[l].len == CAP_UNFINISHED)
+    return luaL_error(ms->L, "invalid capture index %%%d", l + 1);
+  return l;
+}
+
+
+static int capture_to_close (MatchState *ms) {
+  int level = ms->level;
+  for (level--; level>=0; level--)
+    if (ms->capture[level].len == CAP_UNFINISHED) return level;
+  return luaL_error(ms->L, "invalid pattern capture");
+}
+
+
+static const char *classend (MatchState *ms, const char *p) {
+  switch (*p++) {
+    case L_ESC: {
+      if (p == ms->p_end)
+        luaL_error(ms->L, "malformed pattern (ends with " LUA_QL("%%") ")");
+      return p+1;
+    }
+    case '[': {
+      if (*p == '^') p++;
+      do {  /* look for a `]' */
+        if (p == ms->p_end)
+          luaL_error(ms->L, "malformed pattern (missing " LUA_QL("]") ")");
+        if (*(p++) == L_ESC && p < ms->p_end)
+          p++;  /* skip escapes (e.g. `%]') */
+      } while (*p != ']');
+      return p+1;
+    }
+    default: {
+      return p;
+    }
+  }
+}
+
+
+static int match_class (int c, int cl) {
+  int res;
+  switch (tolower(cl)) {
+    case 'a' : res = isalpha(c); break;
+    case 'c' : res = iscntrl(c); break;
+    case 'd' : res = isdigit(c); break;
+    case 'g' : res = isgraph(c); break;
+    case 'l' : res = islower(c); break;
+    case 'p' : res = ispunct(c); break;
+    case 's' : res = isspace(c); break;
+    case 'u' : res = isupper(c); break;
+    case 'w' : res = isalnum(c); break;
+    case 'x' : res = isxdigit(c); break;
+    case 'z' : res = (c == 0); break;  /* deprecated option */
+    default: return (cl == c);
+  }
+  return (islower(cl) ? res : !res);
+}
+
+
+static int matchbracketclass (int c, const char *p, const char *ec) {
+  int sig = 1;
+  if (*(p+1) == '^') {
+    sig = 0;
+    p++;  /* skip the `^' */
+  }
+  while (++p < ec) {
+    if (*p == L_ESC) {
+      p++;
+      if (match_class(c, uchar(*p)))
+        return sig;
+    }
+    else if ((*(p+1) == '-') && (p+2 < ec)) {
+      p+=2;
+      if (uchar(*(p-2)) <= c && c <= uchar(*p))
+        return sig;
+    }
+    else if (uchar(*p) == c) return sig;
+  }
+  return !sig;
+}
+
+
+static int singlematch (MatchState *ms, const char *s, const char *p,
+                        const char *ep) {
+  if (s >= ms->src_end)
+    return 0;
+  else {
+    int c = uchar(*s);
+    switch (*p) {
+      case '.': return 1;  /* matches any char */
+      case L_ESC: return match_class(c, uchar(*(p+1)));
+      case '[': return matchbracketclass(c, p, ep-1);
+      default:  return (uchar(*p) == c);
+    }
+  }
+}
+
+
+static const char *matchbalance (MatchState *ms, const char *s,
+                                   const char *p) {
+  if (p >= ms->p_end - 1)
+    luaL_error(ms->L, "malformed pattern "
+                      "(missing arguments to " LUA_QL("%%b") ")");
+  if (*s != *p) return NULL;
+  else {
+    int b = *p;
+    int e = *(p+1);
+    int cont = 1;
+    while (++s < ms->src_end) {
+      if (*s == e) {
+        if (--cont == 0) return s+1;
+      }
+      else if (*s == b) cont++;
+    }
+  }
+  return NULL;  /* string ends out of balance */
+}
+
+
+static const char *max_expand (MatchState *ms, const char *s,
+                                 const char *p, const char *ep) {
+  ptrdiff_t i = 0;  /* counts maximum expand for item */
+  while (singlematch(ms, s + i, p, ep))
+    i++;
+  /* keeps trying to match with the maximum repetitions */
+  while (i>=0) {
+    const char *res = match(ms, (s+i), ep+1);
+    if (res) return res;
+    i--;  /* else didn't match; reduce 1 repetition to try again */
+  }
+  return NULL;
+}
+
+
+static const char *min_expand (MatchState *ms, const char *s,
+                                 const char *p, const char *ep) {
+  for (;;) {
+    const char *res = match(ms, s, ep+1);
+    if (res != NULL)
+      return res;
+    else if (singlematch(ms, s, p, ep))
+      s++;  /* try with one more repetition */
+    else return NULL;
+  }
+}
+
+
+static const char *start_capture (MatchState *ms, const char *s,
+                                    const char *p, int what) {
+  const char *res;
+  int level = ms->level;
+  if (level >= LUA_MAXCAPTURES) luaL_error(ms->L, "too many captures");
+  ms->capture[level].init = s;
+  ms->capture[level].len = what;
+  ms->level = level+1;
+  if ((res=match(ms, s, p)) == NULL)  /* match failed? */
+    ms->level--;  /* undo capture */
+  return res;
+}
+
+
+static const char *end_capture (MatchState *ms, const char *s,
+                                  const char *p) {
+  int l = capture_to_close(ms);
+  const char *res;
+  ms->capture[l].len = s - ms->capture[l].init;  /* close capture */
+  if ((res = match(ms, s, p)) == NULL)  /* match failed? */
+    ms->capture[l].len = CAP_UNFINISHED;  /* undo capture */
+  return res;
+}
+
+
+static const char *match_capture (MatchState *ms, const char *s, int l) {
+  size_t len;
+  l = check_capture(ms, l);
+  len = ms->capture[l].len;
+  if ((size_t)(ms->src_end-s) >= len &&
+      memcmp(ms->capture[l].init, s, len) == 0)
+    return s+len;
+  else return NULL;
+}
+
+
+static const char *match (MatchState *ms, const char *s, const char *p) {
+  if (ms->matchdepth-- == 0)
+    luaL_error(ms->L, "pattern too complex");
+  init: /* using goto's to optimize tail recursion */
+  if (p != ms->p_end) {  /* end of pattern? */
+    switch (*p) {
+      case '(': {  /* start capture */
+        if (*(p + 1) == ')')  /* position capture? */
+          s = start_capture(ms, s, p + 2, CAP_POSITION);
+        else
+          s = start_capture(ms, s, p + 1, CAP_UNFINISHED);
+        break;
+      }
+      case ')': {  /* end capture */
+        s = end_capture(ms, s, p + 1);
+        break;
+      }
+      case '$': {
+        if ((p + 1) != ms->p_end)  /* is the `$' the last char in pattern? */
+          goto dflt;  /* no; go to default */
+        s = (s == ms->src_end) ? s : NULL;  /* check end of string */
+        break;
+      }
+      case L_ESC: {  /* escaped sequences not in the format class[*+?-]? */
+        switch (*(p + 1)) {
+          case 'b': {  /* balanced string? */
+            s = matchbalance(ms, s, p + 2);
+            if (s != NULL) {
+              p += 4; goto init;  /* return match(ms, s, p + 4); */
+            }  /* else fail (s == NULL) */
+            break;
+          }
+          case 'f': {  /* frontier? */
+            const char *ep; char previous;
+            p += 2;
+            if (*p != '[')
+              luaL_error(ms->L, "missing " LUA_QL("[") " after "
+                                 LUA_QL("%%f") " in pattern");
+            ep = classend(ms, p);  /* points to what is next */
+            previous = (s == ms->src_init) ? '\0' : *(s - 1);
+            if (!matchbracketclass(uchar(previous), p, ep - 1) &&
+               matchbracketclass(uchar(*s), p, ep - 1)) {
+              p = ep; goto init;  /* return match(ms, s, ep); */
+            }
+            s = NULL;  /* match failed */
+            break;
+          }
+          case '0': case '1': case '2': case '3':
+          case '4': case '5': case '6': case '7':
+          case '8': case '9': {  /* capture results (%0-%9)? */
+            s = match_capture(ms, s, uchar(*(p + 1)));
+            if (s != NULL) {
+              p += 2; goto init;  /* return match(ms, s, p + 2) */
+            }
+            break;
+          }
+          default: goto dflt;
+        }
+        break;
+      }
+      default: dflt: {  /* pattern class plus optional suffix */
+        const char *ep = classend(ms, p);  /* points to optional suffix */
+        /* does not match at least once? */
+        if (!singlematch(ms, s, p, ep)) {
+          if (*ep == '*' || *ep == '?' || *ep == '-') {  /* accept empty? */
+            p = ep + 1; goto init;  /* return match(ms, s, ep + 1); */
+          }
+          else  /* '+' or no suffix */
+            s = NULL;  /* fail */
+        }
+        else {  /* matched once */
+          switch (*ep) {  /* handle optional suffix */
+            case '?': {  /* optional */
+              const char *res;
+              if ((res = match(ms, s + 1, ep + 1)) != NULL)
+                s = res;
+              else {
+                p = ep + 1; goto init;  /* else return match(ms, s, ep + 1); */
+              }
+              break;
+            }
+            case '+':  /* 1 or more repetitions */
+              s++;  /* 1 match already done */
+              /* go through */
+            case '*':  /* 0 or more repetitions */
+              s = max_expand(ms, s, p, ep);
+              break;
+            case '-':  /* 0 or more repetitions (minimum) */
+              s = min_expand(ms, s, p, ep);
+              break;
+            default:  /* no suffix */
+              s++; p = ep; goto init;  /* return match(ms, s + 1, ep); */
+          }
+        }
+        break;
+      }
+    }
+  }
+  ms->matchdepth++;
+  return s;
+}
+
+
+
+static const char *lmemfind (const char *s1, size_t l1,
+                               const char *s2, size_t l2) {
+  if (l2 == 0) return s1;  /* empty strings are everywhere */
+  else if (l2 > l1) return NULL;  /* avoids a negative `l1' */
+  else {
+    const char *init;  /* to search for a `*s2' inside `s1' */
+    l2--;  /* 1st char will be checked by `memchr' */
+    l1 = l1-l2;  /* `s2' cannot be found after that */
+    while (l1 > 0 && (init = (const char *)memchr(s1, *s2, l1)) != NULL) {
+      init++;   /* 1st char is already checked */
+      if (memcmp(init, s2+1, l2) == 0)
+        return init-1;
+      else {  /* correct `l1' and `s1' to try again */
+        l1 -= init-s1;
+        s1 = init;
+      }
+    }
+    return NULL;  /* not found */
+  }
+}
+
+
+static void push_onecapture (MatchState *ms, int i, const char *s,
+                                                    const char *e) {
+  if (i >= ms->level) {
+    if (i == 0)  /* ms->level == 0, too */
+      lua_pushlstring(ms->L, s, e - s);  /* add whole match */
+    else
+      luaL_error(ms->L, "invalid capture index");
+  }
+  else {
+    ptrdiff_t l = ms->capture[i].len;
+    if (l == CAP_UNFINISHED) luaL_error(ms->L, "unfinished capture");
+    if (l == CAP_POSITION)
+      lua_pushinteger(ms->L, ms->capture[i].init - ms->src_init + 1);
+    else
+      lua_pushlstring(ms->L, ms->capture[i].init, l);
+  }
+}
+
+
+static int push_captures (MatchState *ms, const char *s, const char *e) {
+  int i;
+  int nlevels = (ms->level == 0 && s) ? 1 : ms->level;
+  luaL_checkstack(ms->L, nlevels, "too many captures");
+  for (i = 0; i < nlevels; i++)
+    push_onecapture(ms, i, s, e);
+  return nlevels;  /* number of strings pushed */
+}
+
+
+/* check whether pattern has no special characters */
+static int nospecials (const char *p, size_t l) {
+  size_t upto = 0;
+  do {
+    if (strpbrk(p + upto, SPECIALS))
+      return 0;  /* pattern has a special character */
+    upto += strlen(p + upto) + 1;  /* may have more after \0 */
+  } while (upto <= l);
+  return 1;  /* no special chars found */
+}
+
+
+static int str_find_aux (lua_State *L, int find) {
+  size_t ls, lp;
+  const char *s = luaL_checklstring(L, 1, &ls);
+  const char *p = luaL_checklstring(L, 2, &lp);
+  size_t init = posrelat(luaL_optinteger(L, 3, 1), ls);
+  if (init < 1) init = 1;
+  else if (init > ls + 1) {  /* start after string's end? */
+    lua_pushnil(L);  /* cannot find anything */
+    return 1;
+  }
+  /* explicit request or no special characters? */
+  if (find && (lua_toboolean(L, 4) || nospecials(p, lp))) {
+    /* do a plain search */
+    const char *s2 = lmemfind(s + init - 1, ls - init + 1, p, lp);
+    if (s2) {
+      lua_pushinteger(L, s2 - s + 1);
+      lua_pushinteger(L, s2 - s + lp);
+      return 2;
+    }
+  }
+  else {
+    MatchState ms;
+    const char *s1 = s + init - 1;
+    int anchor = (*p == '^');
+    if (anchor) {
+      p++; lp--;  /* skip anchor character */
+    }
+    ms.L = L;
+    ms.matchdepth = MAXCCALLS;
+    ms.src_init = s;
+    ms.src_end = s + ls;
+    ms.p_end = p + lp;
+    do {
+      const char *res;
+      ms.level = 0;
+      lua_assert(ms.matchdepth == MAXCCALLS);
+      if ((res=match(&ms, s1, p)) != NULL) {
+        if (find) {
+          lua_pushinteger(L, s1 - s + 1);  /* start */
+          lua_pushinteger(L, res - s);   /* end */
+          return push_captures(&ms, NULL, 0) + 2;
+        }
+        else
+          return push_captures(&ms, s1, res);
+      }
+    } while (s1++ < ms.src_end && !anchor);
+  }
+  lua_pushnil(L);  /* not found */
+  return 1;
+}
+
+
+static int str_find (lua_State *L) {
+  return str_find_aux(L, 1);
+}
+
+
+static int str_match (lua_State *L) {
+  return str_find_aux(L, 0);
+}
+
+
+static int gmatch_aux (lua_State *L) {
+  MatchState ms;
+  size_t ls, lp;
+  const char *s = lua_tolstring(L, lua_upvalueindex(1), &ls);
+  const char *p = lua_tolstring(L, lua_upvalueindex(2), &lp);
+  const char *src;
+  ms.L = L;
+  ms.matchdepth = MAXCCALLS;
+  ms.src_init = s;
+  ms.src_end = s+ls;
+  ms.p_end = p + lp;
+  for (src = s + (size_t)lua_tointeger(L, lua_upvalueindex(3));
+       src <= ms.src_end;
+       src++) {
+    const char *e;
+    ms.level = 0;
+    lua_assert(ms.matchdepth == MAXCCALLS);
+    if ((e = match(&ms, src, p)) != NULL) {
+      lua_Integer newstart = e-s;
+      if (e == src) newstart++;  /* empty match? go at least one position */
+      lua_pushinteger(L, newstart);
+      lua_replace(L, lua_upvalueindex(3));
+      return push_captures(&ms, src, e);
+    }
+  }
+  return 0;  /* not found */
+}
+
+
+static int gmatch (lua_State *L) {
+  luaL_checkstring(L, 1);
+  luaL_checkstring(L, 2);
+  lua_settop(L, 2);
+  lua_pushinteger(L, 0);
+  lua_pushcclosure(L, gmatch_aux, 3);
+  return 1;
+}
+
+
+static void add_s (MatchState *ms, luaL_Buffer *b, const char *s,
+                                                   const char *e) {
+  size_t l, i;
+  const char *news = lua_tolstring(ms->L, 3, &l);
+  for (i = 0; i < l; i++) {
+    if (news[i] != L_ESC)
+      luaL_addchar(b, news[i]);
+    else {
+      i++;  /* skip ESC */
+      if (!isdigit(uchar(news[i]))) {
+        if (news[i] != L_ESC)
+          luaL_error(ms->L, "invalid use of " LUA_QL("%c")
+                           " in replacement string", L_ESC);
+        luaL_addchar(b, news[i]);
+      }
+      else if (news[i] == '0')
+          luaL_addlstring(b, s, e - s);
+      else {
+        push_onecapture(ms, news[i] - '1', s, e);
+        luaL_addvalue(b);  /* add capture to accumulated result */
+      }
+    }
+  }
+}
+
+
+static void add_value (MatchState *ms, luaL_Buffer *b, const char *s,
+                                       const char *e, int tr) {
+  lua_State *L = ms->L;
+  switch (tr) {
+    case LUA_TFUNCTION: {
+      int n;
+      lua_pushvalue(L, 3);
+      n = push_captures(ms, s, e);
+      lua_call(L, n, 1);
+      break;
+    }
+    case LUA_TTABLE: {
+      push_onecapture(ms, 0, s, e);
+      lua_gettable(L, 3);
+      break;
+    }
+    default: {  /* LUA_TNUMBER or LUA_TSTRING */
+      add_s(ms, b, s, e);
+      return;
+    }
+  }
+  if (!lua_toboolean(L, -1)) {  /* nil or false? */
+    lua_pop(L, 1);
+    lua_pushlstring(L, s, e - s);  /* keep original text */
+  }
+  else if (!lua_isstring(L, -1))
+    luaL_error(L, "invalid replacement value (a %s)", luaL_typename(L, -1));
+  luaL_addvalue(b);  /* add result to accumulator */
+}
+
+
+static int str_gsub (lua_State *L) {
+  size_t srcl, lp;
+  const char *src = luaL_checklstring(L, 1, &srcl);
+  const char *p = luaL_checklstring(L, 2, &lp);
+  int tr = lua_type(L, 3);
+  size_t max_s = luaL_optinteger(L, 4, srcl+1);
+  int anchor = (*p == '^');
+  size_t n = 0;
+  MatchState ms;
+  luaL_Buffer b;
+  luaL_argcheck(L, tr == LUA_TNUMBER || tr == LUA_TSTRING ||
+                   tr == LUA_TFUNCTION || tr == LUA_TTABLE, 3,
+                      "string/function/table expected");
+  luaL_buffinit(L, &b);
+  if (anchor) {
+    p++; lp--;  /* skip anchor character */
+  }
+  ms.L = L;
+  ms.matchdepth = MAXCCALLS;
+  ms.src_init = src;
+  ms.src_end = src+srcl;
+  ms.p_end = p + lp;
+  while (n < max_s) {
+    const char *e;
+    ms.level = 0;
+    lua_assert(ms.matchdepth == MAXCCALLS);
+    e = match(&ms, src, p);
+    if (e) {
+      n++;
+      add_value(&ms, &b, src, e, tr);
+    }
+    if (e && e>src) /* non empty match? */
+      src = e;  /* skip it */
+    else if (src < ms.src_end)
+      luaL_addchar(&b, *src++);
+    else break;
+    if (anchor) break;
+  }
+  luaL_addlstring(&b, src, ms.src_end-src);
+  luaL_pushresult(&b);
+  lua_pushinteger(L, n);  /* number of substitutions */
+  return 2;
+}
+
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** STRING FORMAT
+** =======================================================
+*/
+
+/*
+** LUA_INTFRMLEN is the length modifier for integer conversions in
+** 'string.format'; LUA_INTFRM_T is the integer type corresponding to
+** the previous length
+*/
+#if !defined(LUA_INTFRMLEN)	/* { */
+#if defined(LUA_USE_LONGLONG)
+
+#define LUA_INTFRMLEN		"ll"
+#define LUA_INTFRM_T		long long
+
+#else
+
+#define LUA_INTFRMLEN		"l"
+#define LUA_INTFRM_T		long
+
+#endif
+#endif				/* } */
+
+
+/*
+** LUA_FLTFRMLEN is the length modifier for float conversions in
+** 'string.format'; LUA_FLTFRM_T is the float type corresponding to
+** the previous length
+*/
+#if !defined(LUA_FLTFRMLEN)
+
+#define LUA_FLTFRMLEN		""
+#define LUA_FLTFRM_T		double
+
+#endif
+
+
+/* maximum size of each formatted item (> len(format('%99.99f', -1e308))) */
+#define MAX_ITEM	512
+/* valid flags in a format specification */
+#define FLAGS	"-+ #0"
+/*
+** maximum size of each format specification (such as '%-099.99d')
+** (+10 accounts for %99.99x plus margin of error)
+*/
+#define MAX_FORMAT	(sizeof(FLAGS) + sizeof(LUA_INTFRMLEN) + 10)
+
+
+static void addquoted (lua_State *L, luaL_Buffer *b, int arg) {
+  size_t l;
+  const char *s = luaL_checklstring(L, arg, &l);
+  luaL_addchar(b, '"');
+  while (l--) {
+    if (*s == '"' || *s == '\\' || *s == '\n') {
+      luaL_addchar(b, '\\');
+      luaL_addchar(b, *s);
+    }
+    else if (*s == '\0' || iscntrl(uchar(*s))) {
+      char buff[10];
+      if (!isdigit(uchar(*(s+1))))
+        sprintf(buff, "\\%d", (int)uchar(*s));
+      else
+        sprintf(buff, "\\%03d", (int)uchar(*s));
+      luaL_addstring(b, buff);
+    }
+    else
+      luaL_addchar(b, *s);
+    s++;
+  }
+  luaL_addchar(b, '"');
+}
+
+static const char *scanformat (lua_State *L, const char *strfrmt, char *form) {
+  const char *p = strfrmt;
+  while (*p != '\0' && strchr(FLAGS, *p) != NULL) p++;  /* skip flags */
+  if ((size_t)(p - strfrmt) >= sizeof(FLAGS)/sizeof(char))
+    luaL_error(L, "invalid format (repeated flags)");
+  if (isdigit(uchar(*p))) p++;  /* skip width */
+  if (isdigit(uchar(*p))) p++;  /* (2 digits at most) */
+  if (*p == '.') {
+    p++;
+    if (isdigit(uchar(*p))) p++;  /* skip precision */
+    if (isdigit(uchar(*p))) p++;  /* (2 digits at most) */
+  }
+  if (isdigit(uchar(*p)))
+    luaL_error(L, "invalid format (width or precision too long)");
+  *(form++) = '%';
+  memcpy(form, strfrmt, (p - strfrmt + 1) * sizeof(char));
+  form += p - strfrmt + 1;
+  *form = '\0';
+  return p;
+}
+
+
+/*
+** add length modifier into formats
+*/
+static void addlenmod (char *form, const char *lenmod) {
+  size_t l = strlen(form);
+  size_t lm = strlen(lenmod);
+  char spec = form[l - 1];
+  strcpy(form + l - 1, lenmod);
+  form[l + lm - 1] = spec;
+  form[l + lm] = '\0';
+}
+
+
+static int str_format (lua_State *L) {
+  int top = lua_gettop(L);
+  int arg = 1;
+  size_t sfl;
+  const char *strfrmt = luaL_checklstring(L, arg, &sfl);
+  const char *strfrmt_end = strfrmt+sfl;
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  while (strfrmt < strfrmt_end) {
+    if (*strfrmt != L_ESC)
+      luaL_addchar(&b, *strfrmt++);
+    else if (*++strfrmt == L_ESC)
+      luaL_addchar(&b, *strfrmt++);  /* %% */
+    else { /* format item */
+      char form[MAX_FORMAT];  /* to store the format (`%...') */
+      char *buff = luaL_prepbuffsize(&b, MAX_ITEM);  /* to put formatted item */
+      int nb = 0;  /* number of bytes in added item */
+      if (++arg > top)
+        luaL_argerror(L, arg, "no value");
+      strfrmt = scanformat(L, strfrmt, form);
+      switch (*strfrmt++) {
+        case 'c': {
+          nb = sprintf(buff, form, luaL_checkint(L, arg));
+          break;
+        }
+        case 'd': case 'i': {
+          lua_Number n = luaL_checknumber(L, arg);
+          LUA_INTFRM_T ni = (LUA_INTFRM_T)n;
+          lua_Number diff = n - (lua_Number)ni;
+          luaL_argcheck(L, -1 < diff && diff < 1, arg,
+                        "not a number in proper range");
+          addlenmod(form, LUA_INTFRMLEN);
+          nb = sprintf(buff, form, ni);
+          break;
+        }
+        case 'o': case 'u': case 'x': case 'X': {
+          lua_Number n = luaL_checknumber(L, arg);
+          unsigned LUA_INTFRM_T ni = (unsigned LUA_INTFRM_T)n;
+          lua_Number diff = n - (lua_Number)ni;
+          luaL_argcheck(L, -1 < diff && diff < 1, arg,
+                        "not a non-negative number in proper range");
+          addlenmod(form, LUA_INTFRMLEN);
+          nb = sprintf(buff, form, ni);
+          break;
+        }
+        case 'e': case 'E': case 'f':
+#if defined(LUA_USE_AFORMAT)
+        case 'a': case 'A':
+#endif
+        case 'g': case 'G': {
+          addlenmod(form, LUA_FLTFRMLEN);
+          nb = sprintf(buff, form, (LUA_FLTFRM_T)luaL_checknumber(L, arg));
+          break;
+        }
+        case 'q': {
+          addquoted(L, &b, arg);
+          break;
+        }
+        case 's': {
+          size_t l;
+          const char *s = luaL_tolstring(L, arg, &l);
+          if (!strchr(form, '.') && l >= 100) {
+            /* no precision and string is too long to be formatted;
+               keep original string */
+            luaL_addvalue(&b);
+            break;
+          }
+          else {
+            nb = sprintf(buff, form, s);
+            lua_pop(L, 1);  /* remove result from 'luaL_tolstring' */
+            break;
+          }
+        }
+        default: {  /* also treat cases `pnLlh' */
+          return luaL_error(L, "invalid option " LUA_QL("%%%c") " to "
+                               LUA_QL("format"), *(strfrmt - 1));
+        }
+      }
+      luaL_addsize(&b, nb);
+    }
+  }
+  luaL_pushresult(&b);
+  return 1;
+}
+
+/* }====================================================== */
+
+
+static const luaL_Reg strlib[] = {
+  {"byte", str_byte},
+  {"char", str_char},
+  {"dump", str_dump},
+  {"find", str_find},
+  {"format", str_format},
+  {"gmatch", gmatch},
+  {"gsub", str_gsub},
+  {"len", str_len},
+  {"lower", str_lower},
+  {"match", str_match},
+  {"rep", str_rep},
+  {"reverse", str_reverse},
+  {"sub", str_sub},
+  {"upper", str_upper},
+  {NULL, NULL}
+};
+
+
+static void createmetatable (lua_State *L) {
+  lua_createtable(L, 0, 1);  /* table to be metatable for strings */
+  lua_pushliteral(L, "");  /* dummy string */
+  lua_pushvalue(L, -2);  /* copy table */
+  lua_setmetatable(L, -2);  /* set table as metatable for strings */
+  lua_pop(L, 1);  /* pop dummy string */
+  lua_pushvalue(L, -2);  /* get string library */
+  lua_setfield(L, -2, "__index");  /* metatable.__index = string */
+  lua_pop(L, 1);  /* pop metatable */
+}
+
+
+/*
+** Open string library
+*/
+LUAMOD_API int luaopen_string (lua_State *L) {
+  luaL_newlib(L, strlib);
+  createmetatable(L);
+  return 1;
+}
+
diff -ruNp src.hd/libs/lua/ltable.c src/libs/lua/ltable.c
--- src.hd/libs/lua/ltable.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/ltable.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,588 @@
+/*
+** $Id: ltable.c,v 2.72 2012/09/11 19:37:16 roberto Exp $
+** Lua tables (hash)
+** See Copyright Notice in lua.h
+*/
+
+
+/*
+** Implementation of tables (aka arrays, objects, or hash tables).
+** Tables keep its elements in two parts: an array part and a hash part.
+** Non-negative integer keys are all candidates to be kept in the array
+** part. The actual size of the array is the largest `n' such that at
+** least half the slots between 0 and n are in use.
+** Hash uses a mix of chained scatter table with Brent's variation.
+** A main invariant of these tables is that, if an element is not
+** in its main position (i.e. the `original' position that its hash gives
+** to it), then the colliding element is in its own main position.
+** Hence even when the load factor reaches 100%, performance remains good.
+*/
+
+#include <string.h>
+
+#define ltable_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lgc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "lvm.h"
+
+
+/*
+** max size of array part is 2^MAXBITS
+*/
+#if LUAI_BITSINT >= 32
+#define MAXBITS		30
+#else
+#define MAXBITS		(LUAI_BITSINT-2)
+#endif
+
+#define MAXASIZE	(1 << MAXBITS)
+
+
+#define hashpow2(t,n)		(gnode(t, lmod((n), sizenode(t))))
+
+#define hashstr(t,str)		hashpow2(t, (str)->tsv.hash)
+#define hashboolean(t,p)	hashpow2(t, p)
+
+
+/*
+** for some types, it is better to avoid modulus by power of 2, as
+** they tend to have many 2 factors.
+*/
+#define hashmod(t,n)	(gnode(t, ((n) % ((sizenode(t)-1)|1))))
+
+
+#define hashpointer(t,p)	hashmod(t, IntPoint(p))
+
+
+#define dummynode		(&dummynode_)
+
+#define isdummy(n)		((n) == dummynode)
+
+static const Node dummynode_ = {
+  {NILCONSTANT},  /* value */
+  {{NILCONSTANT, NULL}}  /* key */
+};
+
+
+/*
+** hash for lua_Numbers
+*/
+static Node *hashnum (const Table *t, lua_Number n) {
+  int i;
+  luai_hashnum(i, n);
+  if (i < 0) {
+    if (cast(unsigned int, i) == 0u - i)  /* use unsigned to avoid overflows */
+      i = 0;  /* handle INT_MIN */
+    i = -i;  /* must be a positive value */
+  }
+  return hashmod(t, i);
+}
+
+
+
+/*
+** returns the `main' position of an element in a table (that is, the index
+** of its hash value)
+*/
+static Node *mainposition (const Table *t, const TValue *key) {
+  switch (ttype(key)) {
+    case LUA_TNUMBER:
+      return hashnum(t, nvalue(key));
+    case LUA_TLNGSTR: {
+      TString *s = rawtsvalue(key);
+      if (s->tsv.extra == 0) {  /* no hash? */
+        s->tsv.hash = luaS_hash(getstr(s), s->tsv.len, s->tsv.hash);
+        s->tsv.extra = 1;  /* now it has its hash */
+      }
+      return hashstr(t, rawtsvalue(key));
+    }
+    case LUA_TSHRSTR:
+      return hashstr(t, rawtsvalue(key));
+    case LUA_TBOOLEAN:
+      return hashboolean(t, bvalue(key));
+    case LUA_TLIGHTUSERDATA:
+      return hashpointer(t, pvalue(key));
+    case LUA_TLCF:
+      return hashpointer(t, fvalue(key));
+    default:
+      return hashpointer(t, gcvalue(key));
+  }
+}
+
+
+/*
+** returns the index for `key' if `key' is an appropriate key to live in
+** the array part of the table, -1 otherwise.
+*/
+static int arrayindex (const TValue *key) {
+  if (ttisnumber(key)) {
+    lua_Number n = nvalue(key);
+    int k;
+    lua_number2int(k, n);
+    if (luai_numeq(cast_num(k), n))
+      return k;
+  }
+  return -1;  /* `key' did not match some condition */
+}
+
+
+/*
+** returns the index of a `key' for table traversals. First goes all
+** elements in the array part, then elements in the hash part. The
+** beginning of a traversal is signaled by -1.
+*/
+static int findindex (lua_State *L, Table *t, StkId key) {
+  int i;
+  if (ttisnil(key)) return -1;  /* first iteration */
+  i = arrayindex(key);
+  if (0 < i && i <= t->sizearray)  /* is `key' inside array part? */
+    return i-1;  /* yes; that's the index (corrected to C) */
+  else {
+    Node *n = mainposition(t, key);
+    for (;;) {  /* check whether `key' is somewhere in the chain */
+      /* key may be dead already, but it is ok to use it in `next' */
+      if (luaV_rawequalobj(gkey(n), key) ||
+            (ttisdeadkey(gkey(n)) && iscollectable(key) &&
+             deadvalue(gkey(n)) == gcvalue(key))) {
+        i = cast_int(n - gnode(t, 0));  /* key index in hash table */
+        /* hash elements are numbered after array ones */
+        return i + t->sizearray;
+      }
+      else n = gnext(n);
+      if (n == NULL)
+        luaG_runerror(L, "invalid key to " LUA_QL("next"));  /* key not found */
+    }
+  }
+}
+
+
+int luaH_next (lua_State *L, Table *t, StkId key) {
+  int i = findindex(L, t, key);  /* find original element */
+  for (i++; i < t->sizearray; i++) {  /* try first array part */
+    if (!ttisnil(&t->array[i])) {  /* a non-nil value? */
+      setnvalue(key, cast_num(i+1));
+      setobj2s(L, key+1, &t->array[i]);
+      return 1;
+    }
+  }
+  for (i -= t->sizearray; i < sizenode(t); i++) {  /* then hash part */
+    if (!ttisnil(gval(gnode(t, i)))) {  /* a non-nil value? */
+      setobj2s(L, key, gkey(gnode(t, i)));
+      setobj2s(L, key+1, gval(gnode(t, i)));
+      return 1;
+    }
+  }
+  return 0;  /* no more elements */
+}
+
+
+/*
+** {=============================================================
+** Rehash
+** ==============================================================
+*/
+
+
+static int computesizes (int nums[], int *narray) {
+  int i;
+  int twotoi;  /* 2^i */
+  int a = 0;  /* number of elements smaller than 2^i */
+  int na = 0;  /* number of elements to go to array part */
+  int n = 0;  /* optimal size for array part */
+  for (i = 0, twotoi = 1; twotoi/2 < *narray; i++, twotoi *= 2) {
+    if (nums[i] > 0) {
+      a += nums[i];
+      if (a > twotoi/2) {  /* more than half elements present? */
+        n = twotoi;  /* optimal size (till now) */
+        na = a;  /* all elements smaller than n will go to array part */
+      }
+    }
+    if (a == *narray) break;  /* all elements already counted */
+  }
+  *narray = n;
+  lua_assert(*narray/2 <= na && na <= *narray);
+  return na;
+}
+
+
+static int countint (const TValue *key, int *nums) {
+  int k = arrayindex(key);
+  if (0 < k && k <= MAXASIZE) {  /* is `key' an appropriate array index? */
+    nums[luaO_ceillog2(k)]++;  /* count as such */
+    return 1;
+  }
+  else
+    return 0;
+}
+
+
+static int numusearray (const Table *t, int *nums) {
+  int lg;
+  int ttlg;  /* 2^lg */
+  int ause = 0;  /* summation of `nums' */
+  int i = 1;  /* count to traverse all array keys */
+  for (lg=0, ttlg=1; lg<=MAXBITS; lg++, ttlg*=2) {  /* for each slice */
+    int lc = 0;  /* counter */
+    int lim = ttlg;
+    if (lim > t->sizearray) {
+      lim = t->sizearray;  /* adjust upper limit */
+      if (i > lim)
+        break;  /* no more elements to count */
+    }
+    /* count elements in range (2^(lg-1), 2^lg] */
+    for (; i <= lim; i++) {
+      if (!ttisnil(&t->array[i-1]))
+        lc++;
+    }
+    nums[lg] += lc;
+    ause += lc;
+  }
+  return ause;
+}
+
+
+static int numusehash (const Table *t, int *nums, int *pnasize) {
+  int totaluse = 0;  /* total number of elements */
+  int ause = 0;  /* summation of `nums' */
+  int i = sizenode(t);
+  while (i--) {
+    Node *n = &t->node[i];
+    if (!ttisnil(gval(n))) {
+      ause += countint(gkey(n), nums);
+      totaluse++;
+    }
+  }
+  *pnasize += ause;
+  return totaluse;
+}
+
+
+static void setarrayvector (lua_State *L, Table *t, int size) {
+  int i;
+  luaM_reallocvector(L, t->array, t->sizearray, size, TValue);
+  for (i=t->sizearray; i<size; i++)
+     setnilvalue(&t->array[i]);
+  t->sizearray = size;
+}
+
+
+static void setnodevector (lua_State *L, Table *t, int size) {
+  int lsize;
+  if (size == 0) {  /* no elements to hash part? */
+    t->node = cast(Node *, dummynode);  /* use common `dummynode' */
+    lsize = 0;
+  }
+  else {
+    int i;
+    lsize = luaO_ceillog2(size);
+    if (lsize > MAXBITS)
+      luaG_runerror(L, "table overflow");
+    size = twoto(lsize);
+    t->node = luaM_newvector(L, size, Node);
+    for (i=0; i<size; i++) {
+      Node *n = gnode(t, i);
+      gnext(n) = NULL;
+      setnilvalue(gkey(n));
+      setnilvalue(gval(n));
+    }
+  }
+  t->lsizenode = cast_byte(lsize);
+  t->lastfree = gnode(t, size);  /* all positions are free */
+}
+
+
+void luaH_resize (lua_State *L, Table *t, int nasize, int nhsize) {
+  int i;
+  int oldasize = t->sizearray;
+  int oldhsize = t->lsizenode;
+  Node *nold = t->node;  /* save old hash ... */
+  if (nasize > oldasize)  /* array part must grow? */
+    setarrayvector(L, t, nasize);
+  /* create new hash part with appropriate size */
+  setnodevector(L, t, nhsize);
+  if (nasize < oldasize) {  /* array part must shrink? */
+    t->sizearray = nasize;
+    /* re-insert elements from vanishing slice */
+    for (i=nasize; i<oldasize; i++) {
+      if (!ttisnil(&t->array[i]))
+        luaH_setint(L, t, i + 1, &t->array[i]);
+    }
+    /* shrink array */
+    luaM_reallocvector(L, t->array, oldasize, nasize, TValue);
+  }
+  /* re-insert elements from hash part */
+  for (i = twoto(oldhsize) - 1; i >= 0; i--) {
+    Node *old = nold+i;
+    if (!ttisnil(gval(old))) {
+      /* doesn't need barrier/invalidate cache, as entry was
+         already present in the table */
+      setobjt2t(L, luaH_set(L, t, gkey(old)), gval(old));
+    }
+  }
+  if (!isdummy(nold))
+    luaM_freearray(L, nold, cast(size_t, twoto(oldhsize))); /* free old array */
+}
+
+
+void luaH_resizearray (lua_State *L, Table *t, int nasize) {
+  int nsize = isdummy(t->node) ? 0 : sizenode(t);
+  luaH_resize(L, t, nasize, nsize);
+}
+
+
+static void rehash (lua_State *L, Table *t, const TValue *ek) {
+  int nasize, na;
+  int nums[MAXBITS+1];  /* nums[i] = number of keys with 2^(i-1) < k <= 2^i */
+  int i;
+  int totaluse;
+  for (i=0; i<=MAXBITS; i++) nums[i] = 0;  /* reset counts */
+  nasize = numusearray(t, nums);  /* count keys in array part */
+  totaluse = nasize;  /* all those keys are integer keys */
+  totaluse += numusehash(t, nums, &nasize);  /* count keys in hash part */
+  /* count extra key */
+  nasize += countint(ek, nums);
+  totaluse++;
+  /* compute new size for array part */
+  na = computesizes(nums, &nasize);
+  /* resize the table to new computed sizes */
+  luaH_resize(L, t, nasize, totaluse - na);
+}
+
+
+
+/*
+** }=============================================================
+*/
+
+
+Table *luaH_new (lua_State *L) {
+  Table *t = &luaC_newobj(L, LUA_TTABLE, sizeof(Table), NULL, 0)->h;
+  t->metatable = NULL;
+  t->flags = cast_byte(~0);
+  t->array = NULL;
+  t->sizearray = 0;
+  setnodevector(L, t, 0);
+  return t;
+}
+
+
+void luaH_free (lua_State *L, Table *t) {
+  if (!isdummy(t->node))
+    luaM_freearray(L, t->node, cast(size_t, sizenode(t)));
+  luaM_freearray(L, t->array, t->sizearray);
+  luaM_free(L, t);
+}
+
+
+static Node *getfreepos (Table *t) {
+  while (t->lastfree > t->node) {
+    t->lastfree--;
+    if (ttisnil(gkey(t->lastfree)))
+      return t->lastfree;
+  }
+  return NULL;  /* could not find a free place */
+}
+
+
+
+/*
+** inserts a new key into a hash table; first, check whether key's main
+** position is free. If not, check whether colliding node is in its main
+** position or not: if it is not, move colliding node to an empty place and
+** put new key in its main position; otherwise (colliding node is in its main
+** position), new key goes to an empty position.
+*/
+TValue *luaH_newkey (lua_State *L, Table *t, const TValue *key) {
+  Node *mp;
+  if (ttisnil(key)) luaG_runerror(L, "table index is nil");
+  else if (ttisnumber(key) && luai_numisnan(L, nvalue(key)))
+    luaG_runerror(L, "table index is NaN");
+  mp = mainposition(t, key);
+  if (!ttisnil(gval(mp)) || isdummy(mp)) {  /* main position is taken? */
+    Node *othern;
+    Node *n = getfreepos(t);  /* get a free place */
+    if (n == NULL) {  /* cannot find a free place? */
+      rehash(L, t, key);  /* grow table */
+      /* whatever called 'newkey' take care of TM cache and GC barrier */
+      return luaH_set(L, t, key);  /* insert key into grown table */
+    }
+    lua_assert(!isdummy(n));
+    othern = mainposition(t, gkey(mp));
+    if (othern != mp) {  /* is colliding node out of its main position? */
+      /* yes; move colliding node into free position */
+      while (gnext(othern) != mp) othern = gnext(othern);  /* find previous */
+      gnext(othern) = n;  /* redo the chain with `n' in place of `mp' */
+      *n = *mp;  /* copy colliding node into free pos. (mp->next also goes) */
+      gnext(mp) = NULL;  /* now `mp' is free */
+      setnilvalue(gval(mp));
+    }
+    else {  /* colliding node is in its own main position */
+      /* new node will go into free position */
+      gnext(n) = gnext(mp);  /* chain new position */
+      gnext(mp) = n;
+      mp = n;
+    }
+  }
+  setobj2t(L, gkey(mp), key);
+  luaC_barrierback(L, obj2gco(t), key);
+  lua_assert(ttisnil(gval(mp)));
+  return gval(mp);
+}
+
+
+/*
+** search function for integers
+*/
+const TValue *luaH_getint (Table *t, int key) {
+  /* (1 <= key && key <= t->sizearray) */
+  if (cast(unsigned int, key-1) < cast(unsigned int, t->sizearray))
+    return &t->array[key-1];
+  else {
+    lua_Number nk = cast_num(key);
+    Node *n = hashnum(t, nk);
+    do {  /* check whether `key' is somewhere in the chain */
+      if (ttisnumber(gkey(n)) && luai_numeq(nvalue(gkey(n)), nk))
+        return gval(n);  /* that's it */
+      else n = gnext(n);
+    } while (n);
+    return luaO_nilobject;
+  }
+}
+
+
+/*
+** search function for short strings
+*/
+const TValue *luaH_getstr (Table *t, TString *key) {
+  Node *n = hashstr(t, key);
+  lua_assert(key->tsv.tt == LUA_TSHRSTR);
+  do {  /* check whether `key' is somewhere in the chain */
+    if (ttisshrstring(gkey(n)) && eqshrstr(rawtsvalue(gkey(n)), key))
+      return gval(n);  /* that's it */
+    else n = gnext(n);
+  } while (n);
+  return luaO_nilobject;
+}
+
+
+/*
+** main search function
+*/
+const TValue *luaH_get (Table *t, const TValue *key) {
+  switch (ttype(key)) {
+    case LUA_TSHRSTR: return luaH_getstr(t, rawtsvalue(key));
+    case LUA_TNIL: return luaO_nilobject;
+    case LUA_TNUMBER: {
+      int k;
+      lua_Number n = nvalue(key);
+      lua_number2int(k, n);
+      if (luai_numeq(cast_num(k), n)) /* index is int? */
+        return luaH_getint(t, k);  /* use specialized version */
+      /* else go through */
+    }
+    default: {
+      Node *n = mainposition(t, key);
+      do {  /* check whether `key' is somewhere in the chain */
+        if (luaV_rawequalobj(gkey(n), key))
+          return gval(n);  /* that's it */
+        else n = gnext(n);
+      } while (n);
+      return luaO_nilobject;
+    }
+  }
+}
+
+
+/*
+** beware: when using this function you probably need to check a GC
+** barrier and invalidate the TM cache.
+*/
+TValue *luaH_set (lua_State *L, Table *t, const TValue *key) {
+  const TValue *p = luaH_get(t, key);
+  if (p != luaO_nilobject)
+    return cast(TValue *, p);
+  else return luaH_newkey(L, t, key);
+}
+
+
+void luaH_setint (lua_State *L, Table *t, int key, TValue *value) {
+  const TValue *p = luaH_getint(t, key);
+  TValue *cell;
+  if (p != luaO_nilobject)
+    cell = cast(TValue *, p);
+  else {
+    TValue k;
+    setnvalue(&k, cast_num(key));
+    cell = luaH_newkey(L, t, &k);
+  }
+  setobj2t(L, cell, value);
+}
+
+
+static int unbound_search (Table *t, unsigned int j) {
+  unsigned int i = j;  /* i is zero or a present index */
+  j++;
+  /* find `i' and `j' such that i is present and j is not */
+  while (!ttisnil(luaH_getint(t, j))) {
+    i = j;
+    j *= 2;
+    if (j > cast(unsigned int, MAX_INT)) {  /* overflow? */
+      /* table was built with bad purposes: resort to linear search */
+      i = 1;
+      while (!ttisnil(luaH_getint(t, i))) i++;
+      return i - 1;
+    }
+  }
+  /* now do a binary search between them */
+  while (j - i > 1) {
+    unsigned int m = (i+j)/2;
+    if (ttisnil(luaH_getint(t, m))) j = m;
+    else i = m;
+  }
+  return i;
+}
+
+
+/*
+** Try to find a boundary in table `t'. A `boundary' is an integer index
+** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).
+*/
+int luaH_getn (Table *t) {
+  unsigned int j = t->sizearray;
+  if (j > 0 && ttisnil(&t->array[j - 1])) {
+    /* there is a boundary in the array part: (binary) search for it */
+    unsigned int i = 0;
+    while (j - i > 1) {
+      unsigned int m = (i+j)/2;
+      if (ttisnil(&t->array[m - 1])) j = m;
+      else i = m;
+    }
+    return i;
+  }
+  /* else must find a boundary in hash part */
+  else if (isdummy(t->node))  /* hash part is empty? */
+    return j;  /* that is easy... */
+  else return unbound_search(t, j);
+}
+
+
+
+#if defined(LUA_DEBUG)
+
+Node *luaH_mainposition (const Table *t, const TValue *key) {
+  return mainposition(t, key);
+}
+
+int luaH_isdummy (Node *n) { return isdummy(n); }
+
+#endif
diff -ruNp src.hd/libs/lua/ltable.h src/libs/lua/ltable.h
--- src.hd/libs/lua/ltable.h	1969-12-31 16:00:00 -0800
+++ src/libs/lua/ltable.h	2017-12-29 00:57:40 -0800
@@ -0,0 +1,41 @@
+/*
+** $Id: ltable.h,v 2.16 2011/08/17 20:26:47 roberto Exp $
+** Lua tables (hash)
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ltable_h
+#define ltable_h
+
+#include "lobject.h"
+
+
+#define gnode(t,i)	(&(t)->node[i])
+#define gkey(n)		(&(n)->i_key.tvk)
+#define gval(n)		(&(n)->i_val)
+#define gnext(n)	((n)->i_key.nk.next)
+
+#define invalidateTMcache(t)	((t)->flags = 0)
+
+
+LUAI_FUNC const TValue *luaH_getint (Table *t, int key);
+LUAI_FUNC void luaH_setint (lua_State *L, Table *t, int key, TValue *value);
+LUAI_FUNC const TValue *luaH_getstr (Table *t, TString *key);
+LUAI_FUNC const TValue *luaH_get (Table *t, const TValue *key);
+LUAI_FUNC TValue *luaH_newkey (lua_State *L, Table *t, const TValue *key);
+LUAI_FUNC TValue *luaH_set (lua_State *L, Table *t, const TValue *key);
+LUAI_FUNC Table *luaH_new (lua_State *L);
+LUAI_FUNC void luaH_resize (lua_State *L, Table *t, int nasize, int nhsize);
+LUAI_FUNC void luaH_resizearray (lua_State *L, Table *t, int nasize);
+LUAI_FUNC void luaH_free (lua_State *L, Table *t);
+LUAI_FUNC int luaH_next (lua_State *L, Table *t, StkId key);
+LUAI_FUNC int luaH_getn (Table *t);
+
+
+#if defined(LUA_DEBUG)
+LUAI_FUNC Node *luaH_mainposition (const Table *t, const TValue *key);
+LUAI_FUNC int luaH_isdummy (Node *n);
+#endif
+
+
+#endif
diff -ruNp src.hd/libs/lua/ltablib.c src/libs/lua/ltablib.c
--- src.hd/libs/lua/ltablib.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/ltablib.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,283 @@
+/*
+** $Id: ltablib.c,v 1.65 2013/03/07 18:17:24 roberto Exp $
+** Library for Table Manipulation
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stddef.h>
+
+#define ltablib_c
+#define LUA_LIB
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+#define aux_getn(L,n)	(luaL_checktype(L, n, LUA_TTABLE), luaL_len(L, n))
+
+
+
+#if defined(LUA_COMPAT_MAXN)
+static int maxn (lua_State *L) {
+  lua_Number max = 0;
+  luaL_checktype(L, 1, LUA_TTABLE);
+  lua_pushnil(L);  /* first key */
+  while (lua_next(L, 1)) {
+    lua_pop(L, 1);  /* remove value */
+    if (lua_type(L, -1) == LUA_TNUMBER) {
+      lua_Number v = lua_tonumber(L, -1);
+      if (v > max) max = v;
+    }
+  }
+  lua_pushnumber(L, max);
+  return 1;
+}
+#endif
+
+
+static int tinsert (lua_State *L) {
+  int e = aux_getn(L, 1) + 1;  /* first empty element */
+  int pos;  /* where to insert new element */
+  switch (lua_gettop(L)) {
+    case 2: {  /* called with only 2 arguments */
+      pos = e;  /* insert new element at the end */
+      break;
+    }
+    case 3: {
+      int i;
+      pos = luaL_checkint(L, 2);  /* 2nd argument is the position */
+      luaL_argcheck(L, 1 <= pos && pos <= e, 2, "position out of bounds");
+      for (i = e; i > pos; i--) {  /* move up elements */
+        lua_rawgeti(L, 1, i-1);
+        lua_rawseti(L, 1, i);  /* t[i] = t[i-1] */
+      }
+      break;
+    }
+    default: {
+      return luaL_error(L, "wrong number of arguments to " LUA_QL("insert"));
+    }
+  }
+  lua_rawseti(L, 1, pos);  /* t[pos] = v */
+  return 0;
+}
+
+
+static int tremove (lua_State *L) {
+  int size = aux_getn(L, 1);
+  int pos = luaL_optint(L, 2, size);
+  if (pos != size)  /* validate 'pos' if given */
+    luaL_argcheck(L, 1 <= pos && pos <= size + 1, 1, "position out of bounds");
+  lua_rawgeti(L, 1, pos);  /* result = t[pos] */
+  for ( ; pos < size; pos++) {
+    lua_rawgeti(L, 1, pos+1);
+    lua_rawseti(L, 1, pos);  /* t[pos] = t[pos+1] */
+  }
+  lua_pushnil(L);
+  lua_rawseti(L, 1, pos);  /* t[pos] = nil */
+  return 1;
+}
+
+
+static void addfield (lua_State *L, luaL_Buffer *b, int i) {
+  lua_rawgeti(L, 1, i);
+  if (!lua_isstring(L, -1))
+    luaL_error(L, "invalid value (%s) at index %d in table for "
+                  LUA_QL("concat"), luaL_typename(L, -1), i);
+  luaL_addvalue(b);
+}
+
+
+static int tconcat (lua_State *L) {
+  luaL_Buffer b;
+  size_t lsep;
+  int i, last;
+  const char *sep = luaL_optlstring(L, 2, "", &lsep);
+  luaL_checktype(L, 1, LUA_TTABLE);
+  i = luaL_optint(L, 3, 1);
+  last = luaL_opt(L, luaL_checkint, 4, luaL_len(L, 1));
+  luaL_buffinit(L, &b);
+  for (; i < last; i++) {
+    addfield(L, &b, i);
+    luaL_addlstring(&b, sep, lsep);
+  }
+  if (i == last)  /* add last value (if interval was not empty) */
+    addfield(L, &b, i);
+  luaL_pushresult(&b);
+  return 1;
+}
+
+
+/*
+** {======================================================
+** Pack/unpack
+** =======================================================
+*/
+
+static int pack (lua_State *L) {
+  int n = lua_gettop(L);  /* number of elements to pack */
+  lua_createtable(L, n, 1);  /* create result table */
+  lua_pushinteger(L, n);
+  lua_setfield(L, -2, "n");  /* t.n = number of elements */
+  if (n > 0) {  /* at least one element? */
+    int i;
+    lua_pushvalue(L, 1);
+    lua_rawseti(L, -2, 1);  /* insert first element */
+    lua_replace(L, 1);  /* move table into index 1 */
+    for (i = n; i >= 2; i--)  /* assign other elements */
+      lua_rawseti(L, 1, i);
+  }
+  return 1;  /* return table */
+}
+
+
+static int unpack (lua_State *L) {
+  int i, e, n;
+  luaL_checktype(L, 1, LUA_TTABLE);
+  i = luaL_optint(L, 2, 1);
+  e = luaL_opt(L, luaL_checkint, 3, luaL_len(L, 1));
+  if (i > e) return 0;  /* empty range */
+  n = e - i + 1;  /* number of elements */
+  if (n <= 0 || !lua_checkstack(L, n))  /* n <= 0 means arith. overflow */
+    return luaL_error(L, "too many results to unpack");
+  lua_rawgeti(L, 1, i);  /* push arg[i] (avoiding overflow problems) */
+  while (i++ < e)  /* push arg[i + 1...e] */
+    lua_rawgeti(L, 1, i);
+  return n;
+}
+
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** Quicksort
+** (based on `Algorithms in MODULA-3', Robert Sedgewick;
+**  Addison-Wesley, 1993.)
+** =======================================================
+*/
+
+
+static void set2 (lua_State *L, int i, int j) {
+  lua_rawseti(L, 1, i);
+  lua_rawseti(L, 1, j);
+}
+
+static int sort_comp (lua_State *L, int a, int b) {
+  if (!lua_isnil(L, 2)) {  /* function? */
+    int res;
+    lua_pushvalue(L, 2);
+    lua_pushvalue(L, a-1);  /* -1 to compensate function */
+    lua_pushvalue(L, b-2);  /* -2 to compensate function and `a' */
+    lua_call(L, 2, 1);
+    res = lua_toboolean(L, -1);
+    lua_pop(L, 1);
+    return res;
+  }
+  else  /* a < b? */
+    return lua_compare(L, a, b, LUA_OPLT);
+}
+
+static void auxsort (lua_State *L, int l, int u) {
+  while (l < u) {  /* for tail recursion */
+    int i, j;
+    /* sort elements a[l], a[(l+u)/2] and a[u] */
+    lua_rawgeti(L, 1, l);
+    lua_rawgeti(L, 1, u);
+    if (sort_comp(L, -1, -2))  /* a[u] < a[l]? */
+      set2(L, l, u);  /* swap a[l] - a[u] */
+    else
+      lua_pop(L, 2);
+    if (u-l == 1) break;  /* only 2 elements */
+    i = (l+u)/2;
+    lua_rawgeti(L, 1, i);
+    lua_rawgeti(L, 1, l);
+    if (sort_comp(L, -2, -1))  /* a[i]<a[l]? */
+      set2(L, i, l);
+    else {
+      lua_pop(L, 1);  /* remove a[l] */
+      lua_rawgeti(L, 1, u);
+      if (sort_comp(L, -1, -2))  /* a[u]<a[i]? */
+        set2(L, i, u);
+      else
+        lua_pop(L, 2);
+    }
+    if (u-l == 2) break;  /* only 3 elements */
+    lua_rawgeti(L, 1, i);  /* Pivot */
+    lua_pushvalue(L, -1);
+    lua_rawgeti(L, 1, u-1);
+    set2(L, i, u-1);
+    /* a[l] <= P == a[u-1] <= a[u], only need to sort from l+1 to u-2 */
+    i = l; j = u-1;
+    for (;;) {  /* invariant: a[l..i] <= P <= a[j..u] */
+      /* repeat ++i until a[i] >= P */
+      while (lua_rawgeti(L, 1, ++i), sort_comp(L, -1, -2)) {
+        if (i>=u) luaL_error(L, "invalid order function for sorting");
+        lua_pop(L, 1);  /* remove a[i] */
+      }
+      /* repeat --j until a[j] <= P */
+      while (lua_rawgeti(L, 1, --j), sort_comp(L, -3, -1)) {
+        if (j<=l) luaL_error(L, "invalid order function for sorting");
+        lua_pop(L, 1);  /* remove a[j] */
+      }
+      if (j<i) {
+        lua_pop(L, 3);  /* pop pivot, a[i], a[j] */
+        break;
+      }
+      set2(L, i, j);
+    }
+    lua_rawgeti(L, 1, u-1);
+    lua_rawgeti(L, 1, i);
+    set2(L, u-1, i);  /* swap pivot (a[u-1]) with a[i] */
+    /* a[l..i-1] <= a[i] == P <= a[i+1..u] */
+    /* adjust so that smaller half is in [j..i] and larger one in [l..u] */
+    if (i-l < u-i) {
+      j=l; i=i-1; l=i+2;
+    }
+    else {
+      j=i+1; i=u; u=j-2;
+    }
+    auxsort(L, j, i);  /* call recursively the smaller one */
+  }  /* repeat the routine for the larger one */
+}
+
+static int sort (lua_State *L) {
+  int n = aux_getn(L, 1);
+  luaL_checkstack(L, 40, "");  /* assume array is smaller than 2^40 */
+  if (!lua_isnoneornil(L, 2))  /* is there a 2nd argument? */
+    luaL_checktype(L, 2, LUA_TFUNCTION);
+  lua_settop(L, 2);  /* make sure there is two arguments */
+  auxsort(L, 1, n);
+  return 0;
+}
+
+/* }====================================================== */
+
+
+static const luaL_Reg tab_funcs[] = {
+  {"concat", tconcat},
+#if defined(LUA_COMPAT_MAXN)
+  {"maxn", maxn},
+#endif
+  {"insert", tinsert},
+  {"pack", pack},
+  {"unpack", unpack},
+  {"remove", tremove},
+  {"sort", sort},
+  {NULL, NULL}
+};
+
+
+LUAMOD_API int luaopen_table (lua_State *L) {
+  luaL_newlib(L, tab_funcs);
+#if defined(LUA_COMPAT_UNPACK)
+  /* _G.unpack = table.unpack */
+  lua_getfield(L, -1, "unpack");
+  lua_setglobal(L, "unpack");
+#endif
+  return 1;
+}
+
diff -ruNp src.hd/libs/lua/ltm.c src/libs/lua/ltm.c
--- src.hd/libs/lua/ltm.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/ltm.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,77 @@
+/*
+** $Id: ltm.c,v 2.14 2011/06/02 19:31:40 roberto Exp $
+** Tag methods
+** See Copyright Notice in lua.h
+*/
+
+
+#include <string.h>
+
+#define ltm_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "lobject.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+
+
+static const char udatatypename[] = "userdata";
+
+LUAI_DDEF const char *const luaT_typenames_[LUA_TOTALTAGS] = {
+  "no value",
+  "nil", "boolean", udatatypename, "number",
+  "string", "table", "function", udatatypename, "thread",
+  "proto", "upval"  /* these last two cases are used for tests only */
+};
+
+
+void luaT_init (lua_State *L) {
+  static const char *const luaT_eventname[] = {  /* ORDER TM */
+    "__index", "__newindex",
+    "__gc", "__mode", "__len", "__eq",
+    "__add", "__sub", "__mul", "__div", "__mod",
+    "__pow", "__unm", "__lt", "__le",
+    "__concat", "__call"
+  };
+  int i;
+  for (i=0; i<TM_N; i++) {
+    G(L)->tmname[i] = luaS_new(L, luaT_eventname[i]);
+    luaS_fix(G(L)->tmname[i]);  /* never collect these names */
+  }
+}
+
+
+/*
+** function to be used with macro "fasttm": optimized for absence of
+** tag methods
+*/
+const TValue *luaT_gettm (Table *events, TMS event, TString *ename) {
+  const TValue *tm = luaH_getstr(events, ename);
+  lua_assert(event <= TM_EQ);
+  if (ttisnil(tm)) {  /* no tag method? */
+    events->flags |= cast_byte(1u<<event);  /* cache this fact */
+    return NULL;
+  }
+  else return tm;
+}
+
+
+const TValue *luaT_gettmbyobj (lua_State *L, const TValue *o, TMS event) {
+  Table *mt;
+  switch (ttypenv(o)) {
+    case LUA_TTABLE:
+      mt = hvalue(o)->metatable;
+      break;
+    case LUA_TUSERDATA:
+      mt = uvalue(o)->metatable;
+      break;
+    default:
+      mt = G(L)->mt[ttypenv(o)];
+  }
+  return (mt ? luaH_getstr(mt, G(L)->tmname[event]) : luaO_nilobject);
+}
+
diff -ruNp src.hd/libs/lua/ltm.h src/libs/lua/ltm.h
--- src.hd/libs/lua/ltm.h	1969-12-31 16:00:00 -0800
+++ src/libs/lua/ltm.h	2017-12-29 00:57:40 -0800
@@ -0,0 +1,57 @@
+/*
+** $Id: ltm.h,v 2.11 2011/02/28 17:32:10 roberto Exp $
+** Tag methods
+** See Copyright Notice in lua.h
+*/
+
+#ifndef ltm_h
+#define ltm_h
+
+
+#include "lobject.h"
+
+
+/*
+* WARNING: if you change the order of this enumeration,
+* grep "ORDER TM"
+*/
+typedef enum {
+  TM_INDEX,
+  TM_NEWINDEX,
+  TM_GC,
+  TM_MODE,
+  TM_LEN,
+  TM_EQ,  /* last tag method with `fast' access */
+  TM_ADD,
+  TM_SUB,
+  TM_MUL,
+  TM_DIV,
+  TM_MOD,
+  TM_POW,
+  TM_UNM,
+  TM_LT,
+  TM_LE,
+  TM_CONCAT,
+  TM_CALL,
+  TM_N		/* number of elements in the enum */
+} TMS;
+
+
+
+#define gfasttm(g,et,e) ((et) == NULL ? NULL : \
+  ((et)->flags & (1u<<(e))) ? NULL : luaT_gettm(et, e, (g)->tmname[e]))
+
+#define fasttm(l,et,e)	gfasttm(G(l), et, e)
+
+#define ttypename(x)	luaT_typenames_[(x) + 1]
+#define objtypename(x)	ttypename(ttypenv(x))
+
+LUAI_DDEC const char *const luaT_typenames_[LUA_TOTALTAGS];
+
+
+LUAI_FUNC const TValue *luaT_gettm (Table *events, TMS event, TString *ename);
+LUAI_FUNC const TValue *luaT_gettmbyobj (lua_State *L, const TValue *o,
+                                                       TMS event);
+LUAI_FUNC void luaT_init (lua_State *L);
+
+#endif
diff -ruNp src.hd/libs/lua/lua.c src/libs/lua/lua.c
--- src.hd/libs/lua/lua.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lua.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,497 @@
+/*
+** $Id: lua.c,v 1.206 2012/09/29 20:07:06 roberto Exp $
+** Lua stand-alone interpreter
+** See Copyright Notice in lua.h
+*/
+
+
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define lua_c
+
+#include "lua.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+
+
+#if !defined(LUA_PROMPT)
+#define LUA_PROMPT		"> "
+#define LUA_PROMPT2		">> "
+#endif
+
+#if !defined(LUA_PROGNAME)
+#define LUA_PROGNAME		"lua"
+#endif
+
+#if !defined(LUA_MAXINPUT)
+#define LUA_MAXINPUT		512
+#endif
+
+#if !defined(LUA_INIT)
+#define LUA_INIT		"LUA_INIT"
+#endif
+
+#define LUA_INITVERSION  \
+	LUA_INIT "_" LUA_VERSION_MAJOR "_" LUA_VERSION_MINOR
+
+
+/*
+** lua_stdin_is_tty detects whether the standard input is a 'tty' (that
+** is, whether we're running lua interactively).
+*/
+#if defined(LUA_USE_ISATTY)
+#include <unistd.h>
+#define lua_stdin_is_tty()	isatty(0)
+#elif defined(LUA_WIN)
+#include <io.h>
+#include <stdio.h>
+#define lua_stdin_is_tty()	_isatty(_fileno(stdin))
+#else
+#define lua_stdin_is_tty()	1  /* assume stdin is a tty */
+#endif
+
+
+/*
+** lua_readline defines how to show a prompt and then read a line from
+** the standard input.
+** lua_saveline defines how to "save" a read line in a "history".
+** lua_freeline defines how to free a line read by lua_readline.
+*/
+#if defined(LUA_USE_READLINE)
+
+#include <stdio.h>
+#include <readline/readline.h>
+#include <readline/history.h>
+#define lua_readline(L,b,p)	((void)L, ((b)=readline(p)) != NULL)
+#define lua_saveline(L,idx) \
+        if (lua_rawlen(L,idx) > 0)  /* non-empty line? */ \
+          add_history(lua_tostring(L, idx));  /* add it to history */
+#define lua_freeline(L,b)	((void)L, free(b))
+
+#elif !defined(lua_readline)
+
+#define lua_readline(L,b,p) \
+        ((void)L, fputs(p, stdout), fflush(stdout),  /* show prompt */ \
+        fgets(b, LUA_MAXINPUT, stdin) != NULL)  /* get line */
+#define lua_saveline(L,idx)	{ (void)L; (void)idx; }
+#define lua_freeline(L,b)	{ (void)L; (void)b; }
+
+#endif
+
+
+
+
+static lua_State *globalL = NULL;
+
+static const char *progname = LUA_PROGNAME;
+
+
+
+static void lstop (lua_State *L, lua_Debug *ar) {
+  (void)ar;  /* unused arg. */
+  lua_sethook(L, NULL, 0, 0);
+  luaL_error(L, "interrupted!");
+}
+
+
+static void laction (int i) {
+  signal(i, SIG_DFL); /* if another SIGINT happens before lstop,
+                              terminate process (default action) */
+  lua_sethook(globalL, lstop, LUA_MASKCALL | LUA_MASKRET | LUA_MASKCOUNT, 1);
+}
+
+
+static void print_usage (const char *badoption) {
+  luai_writestringerror("%s: ", progname);
+  if (badoption[1] == 'e' || badoption[1] == 'l')
+    luai_writestringerror("'%s' needs argument\n", badoption);
+  else
+    luai_writestringerror("unrecognized option '%s'\n", badoption);
+  luai_writestringerror(
+  "usage: %s [options] [script [args]]\n"
+  "Available options are:\n"
+  "  -e stat  execute string " LUA_QL("stat") "\n"
+  "  -i       enter interactive mode after executing " LUA_QL("script") "\n"
+  "  -l name  require library " LUA_QL("name") "\n"
+  "  -v       show version information\n"
+  "  -E       ignore environment variables\n"
+  "  --       stop handling options\n"
+  "  -        stop handling options and execute stdin\n"
+  ,
+  progname);
+}
+
+
+static void l_message (const char *pname, const char *msg) {
+  if (pname) luai_writestringerror("%s: ", pname);
+  luai_writestringerror("%s\n", msg);
+}
+
+
+static int report (lua_State *L, int status) {
+  if (status != LUA_OK && !lua_isnil(L, -1)) {
+    const char *msg = lua_tostring(L, -1);
+    if (msg == NULL) msg = "(error object is not a string)";
+    l_message(progname, msg);
+    lua_pop(L, 1);
+    /* force a complete garbage collection in case of errors */
+    lua_gc(L, LUA_GCCOLLECT, 0);
+  }
+  return status;
+}
+
+
+/* the next function is called unprotected, so it must avoid errors */
+static void finalreport (lua_State *L, int status) {
+  if (status != LUA_OK) {
+    const char *msg = (lua_type(L, -1) == LUA_TSTRING) ? lua_tostring(L, -1)
+                                                       : NULL;
+    if (msg == NULL) msg = "(error object is not a string)";
+    l_message(progname, msg);
+    lua_pop(L, 1);
+  }
+}
+
+
+static int traceback (lua_State *L) {
+  const char *msg = lua_tostring(L, 1);
+  if (msg)
+    luaL_traceback(L, L, msg, 1);
+  else if (!lua_isnoneornil(L, 1)) {  /* is there an error object? */
+    if (!luaL_callmeta(L, 1, "__tostring"))  /* try its 'tostring' metamethod */
+      lua_pushliteral(L, "(no error message)");
+  }
+  return 1;
+}
+
+
+static int docall (lua_State *L, int narg, int nres) {
+  int status;
+  int base = lua_gettop(L) - narg;  /* function index */
+  lua_pushcfunction(L, traceback);  /* push traceback function */
+  lua_insert(L, base);  /* put it under chunk and args */
+  globalL = L;  /* to be available to 'laction' */
+  signal(SIGINT, laction);
+  status = lua_pcall(L, narg, nres, base);
+  signal(SIGINT, SIG_DFL);
+  lua_remove(L, base);  /* remove traceback function */
+  return status;
+}
+
+
+static void print_version (void) {
+  luai_writestring(LUA_COPYRIGHT, strlen(LUA_COPYRIGHT));
+  luai_writeline();
+}
+
+
+static int getargs (lua_State *L, char **argv, int n) {
+  int narg;
+  int i;
+  int argc = 0;
+  while (argv[argc]) argc++;  /* count total number of arguments */
+  narg = argc - (n + 1);  /* number of arguments to the script */
+  luaL_checkstack(L, narg + 3, "too many arguments to script");
+  for (i=n+1; i < argc; i++)
+    lua_pushstring(L, argv[i]);
+  lua_createtable(L, narg, n + 1);
+  for (i=0; i < argc; i++) {
+    lua_pushstring(L, argv[i]);
+    lua_rawseti(L, -2, i - n);
+  }
+  return narg;
+}
+
+
+static int dofile (lua_State *L, const char *name) {
+  int status = luaL_loadfile(L, name);
+  if (status == LUA_OK) status = docall(L, 0, 0);
+  return report(L, status);
+}
+
+
+static int dostring (lua_State *L, const char *s, const char *name) {
+  int status = luaL_loadbuffer(L, s, strlen(s), name);
+  if (status == LUA_OK) status = docall(L, 0, 0);
+  return report(L, status);
+}
+
+
+static int dolibrary (lua_State *L, const char *name) {
+  int status;
+  lua_getglobal(L, "require");
+  lua_pushstring(L, name);
+  status = docall(L, 1, 1);  /* call 'require(name)' */
+  if (status == LUA_OK)
+    lua_setglobal(L, name);  /* global[name] = require return */
+  return report(L, status);
+}
+
+
+static const char *get_prompt (lua_State *L, int firstline) {
+  const char *p;
+  lua_getglobal(L, firstline ? "_PROMPT" : "_PROMPT2");
+  p = lua_tostring(L, -1);
+  if (p == NULL) p = (firstline ? LUA_PROMPT : LUA_PROMPT2);
+  return p;
+}
+
+/* mark in error messages for incomplete statements */
+#define EOFMARK		"<eof>"
+#define marklen		(sizeof(EOFMARK)/sizeof(char) - 1)
+
+static int incomplete (lua_State *L, int status) {
+  if (status == LUA_ERRSYNTAX) {
+    size_t lmsg;
+    const char *msg = lua_tolstring(L, -1, &lmsg);
+    if (lmsg >= marklen && strcmp(msg + lmsg - marklen, EOFMARK) == 0) {
+      lua_pop(L, 1);
+      return 1;
+    }
+  }
+  return 0;  /* else... */
+}
+
+
+static int pushline (lua_State *L, int firstline) {
+  char buffer[LUA_MAXINPUT];
+  char *b = buffer;
+  size_t l;
+  const char *prmt = get_prompt(L, firstline);
+  int readstatus = lua_readline(L, b, prmt);
+  lua_pop(L, 1);  /* remove result from 'get_prompt' */
+  if (readstatus == 0)
+    return 0;  /* no input */
+  l = strlen(b);
+  if (l > 0 && b[l-1] == '\n')  /* line ends with newline? */
+    b[l-1] = '\0';  /* remove it */
+  if (firstline && b[0] == '=')  /* first line starts with `=' ? */
+    lua_pushfstring(L, "return %s", b+1);  /* change it to `return' */
+  else
+    lua_pushstring(L, b);
+  lua_freeline(L, b);
+  return 1;
+}
+
+
+static int loadline (lua_State *L) {
+  int status;
+  lua_settop(L, 0);
+  if (!pushline(L, 1))
+    return -1;  /* no input */
+  for (;;) {  /* repeat until gets a complete line */
+    size_t l;
+    const char *line = lua_tolstring(L, 1, &l);
+    status = luaL_loadbuffer(L, line, l, "=stdin");
+    if (!incomplete(L, status)) break;  /* cannot try to add lines? */
+    if (!pushline(L, 0))  /* no more input? */
+      return -1;
+    lua_pushliteral(L, "\n");  /* add a new line... */
+    lua_insert(L, -2);  /* ...between the two lines */
+    lua_concat(L, 3);  /* join them */
+  }
+  lua_saveline(L, 1);
+  lua_remove(L, 1);  /* remove line */
+  return status;
+}
+
+
+static void dotty (lua_State *L) {
+  int status;
+  const char *oldprogname = progname;
+  progname = NULL;
+  while ((status = loadline(L)) != -1) {
+    if (status == LUA_OK) status = docall(L, 0, LUA_MULTRET);
+    report(L, status);
+    if (status == LUA_OK && lua_gettop(L) > 0) {  /* any result to print? */
+      luaL_checkstack(L, LUA_MINSTACK, "too many results to print");
+      lua_getglobal(L, "print");
+      lua_insert(L, 1);
+      if (lua_pcall(L, lua_gettop(L)-1, 0, 0) != LUA_OK)
+        l_message(progname, lua_pushfstring(L,
+                               "error calling " LUA_QL("print") " (%s)",
+                               lua_tostring(L, -1)));
+    }
+  }
+  lua_settop(L, 0);  /* clear stack */
+  luai_writeline();
+  progname = oldprogname;
+}
+
+
+static int handle_script (lua_State *L, char **argv, int n) {
+  int status;
+  const char *fname;
+  int narg = getargs(L, argv, n);  /* collect arguments */
+  lua_setglobal(L, "arg");
+  fname = argv[n];
+  if (strcmp(fname, "-") == 0 && strcmp(argv[n-1], "--") != 0)
+    fname = NULL;  /* stdin */
+  status = luaL_loadfile(L, fname);
+  lua_insert(L, -(narg+1));
+  if (status == LUA_OK)
+    status = docall(L, narg, LUA_MULTRET);
+  else
+    lua_pop(L, narg);
+  return report(L, status);
+}
+
+
+/* check that argument has no extra characters at the end */
+#define noextrachars(x)		{if ((x)[2] != '\0') return -1;}
+
+
+/* indices of various argument indicators in array args */
+#define has_i		0	/* -i */
+#define has_v		1	/* -v */
+#define has_e		2	/* -e */
+#define has_E		3	/* -E */
+
+#define num_has		4	/* number of 'has_*' */
+
+
+static int collectargs (char **argv, int *args) {
+  int i;
+  for (i = 1; argv[i] != NULL; i++) {
+    if (argv[i][0] != '-')  /* not an option? */
+        return i;
+    switch (argv[i][1]) {  /* option */
+      case '-':
+        noextrachars(argv[i]);
+        return (argv[i+1] != NULL ? i+1 : 0);
+      case '\0':
+        return i;
+      case 'E':
+        args[has_E] = 1;
+        break;
+      case 'i':
+        noextrachars(argv[i]);
+        args[has_i] = 1;  /* go through */
+      case 'v':
+        noextrachars(argv[i]);
+        args[has_v] = 1;
+        break;
+      case 'e':
+        args[has_e] = 1;  /* go through */
+      case 'l':  /* both options need an argument */
+        if (argv[i][2] == '\0') {  /* no concatenated argument? */
+          i++;  /* try next 'argv' */
+          if (argv[i] == NULL || argv[i][0] == '-')
+            return -(i - 1);  /* no next argument or it is another option */
+        }
+        break;
+      default:  /* invalid option; return its index... */
+        return -i;  /* ...as a negative value */
+    }
+  }
+  return 0;
+}
+
+
+static int runargs (lua_State *L, char **argv, int n) {
+  int i;
+  for (i = 1; i < n; i++) {
+    lua_assert(argv[i][0] == '-');
+    switch (argv[i][1]) {  /* option */
+      case 'e': {
+        const char *chunk = argv[i] + 2;
+        if (*chunk == '\0') chunk = argv[++i];
+        lua_assert(chunk != NULL);
+        if (dostring(L, chunk, "=(command line)") != LUA_OK)
+          return 0;
+        break;
+      }
+      case 'l': {
+        const char *filename = argv[i] + 2;
+        if (*filename == '\0') filename = argv[++i];
+        lua_assert(filename != NULL);
+        if (dolibrary(L, filename) != LUA_OK)
+          return 0;  /* stop if file fails */
+        break;
+      }
+      default: break;
+    }
+  }
+  return 1;
+}
+
+
+static int handle_luainit (lua_State *L) {
+  const char *name = "=" LUA_INITVERSION;
+  const char *init = getenv(name + 1);
+  if (init == NULL) {
+    name = "=" LUA_INIT;
+    init = getenv(name + 1);  /* try alternative name */
+  }
+  if (init == NULL) return LUA_OK;
+  else if (init[0] == '@')
+    return dofile(L, init+1);
+  else
+    return dostring(L, init, name);
+}
+
+
+static int pmain (lua_State *L) {
+  int argc = (int)lua_tointeger(L, 1);
+  char **argv = (char **)lua_touserdata(L, 2);
+  int script;
+  int args[num_has];
+  args[has_i] = args[has_v] = args[has_e] = args[has_E] = 0;
+  if (argv[0] && argv[0][0]) progname = argv[0];
+  script = collectargs(argv, args);
+  if (script < 0) {  /* invalid arg? */
+    print_usage(argv[-script]);
+    return 0;
+  }
+  if (args[has_v]) print_version();
+  if (args[has_E]) {  /* option '-E'? */
+    lua_pushboolean(L, 1);  /* signal for libraries to ignore env. vars. */
+    lua_setfield(L, LUA_REGISTRYINDEX, "LUA_NOENV");
+  }
+  /* open standard libraries */
+  luaL_checkversion(L);
+  lua_gc(L, LUA_GCSTOP, 0);  /* stop collector during initialization */
+  luaL_openlibs(L);  /* open libraries */
+  lua_gc(L, LUA_GCRESTART, 0);
+  if (!args[has_E] && handle_luainit(L) != LUA_OK)
+    return 0;  /* error running LUA_INIT */
+  /* execute arguments -e and -l */
+  if (!runargs(L, argv, (script > 0) ? script : argc)) return 0;
+  /* execute main script (if there is one) */
+  if (script && handle_script(L, argv, script) != LUA_OK) return 0;
+  if (args[has_i])  /* -i option? */
+    dotty(L);
+  else if (script == 0 && !args[has_e] && !args[has_v]) {  /* no arguments? */
+    if (lua_stdin_is_tty()) {
+      print_version();
+      dotty(L);
+    }
+    else dofile(L, NULL);  /* executes stdin as a file */
+  }
+  lua_pushboolean(L, 1);  /* signal no errors */
+  return 1;
+}
+
+
+int main (int argc, char **argv) {
+  int status, result;
+  lua_State *L = luaL_newstate();  /* create state */
+  if (L == NULL) {
+    l_message(argv[0], "cannot create state: not enough memory");
+    return EXIT_FAILURE;
+  }
+  /* call 'pmain' in protected mode */
+  lua_pushcfunction(L, &pmain);
+  lua_pushinteger(L, argc);  /* 1st argument */
+  lua_pushlightuserdata(L, argv); /* 2nd argument */
+  status = lua_pcall(L, 2, 1, 0);
+  result = lua_toboolean(L, -1);  /* get result */
+  finalreport(L, status);
+  lua_close(L);
+  return (result && status == LUA_OK) ? EXIT_SUCCESS : EXIT_FAILURE;
+}
+
diff -ruNp src.hd/libs/lua/lua.h src/libs/lua/lua.h
--- src.hd/libs/lua/lua.h	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lua.h	2017-12-29 00:57:40 -0800
@@ -0,0 +1,444 @@
+/*
+** $Id: lua.h,v 1.285 2013/03/15 13:04:22 roberto Exp $
+** Lua - A Scripting Language
+** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
+** See Copyright Notice at the end of this file
+*/
+
+
+#ifndef lua_h
+#define lua_h
+
+#include <stdarg.h>
+#include <stddef.h>
+
+
+#include "luaconf.h"
+
+
+#define LUA_VERSION_MAJOR	"5"
+#define LUA_VERSION_MINOR	"2"
+#define LUA_VERSION_NUM		502
+#define LUA_VERSION_RELEASE	"2"
+
+#define LUA_VERSION	"Lua " LUA_VERSION_MAJOR "." LUA_VERSION_MINOR
+#define LUA_RELEASE	LUA_VERSION "." LUA_VERSION_RELEASE
+#define LUA_COPYRIGHT	LUA_RELEASE "  Copyright (C) 1994-2013 Lua.org, PUC-Rio"
+#define LUA_AUTHORS	"R. Ierusalimschy, L. H. de Figueiredo, W. Celes"
+
+
+/* mark for precompiled code ('<esc>Lua') */
+#define LUA_SIGNATURE	"\033Lua"
+
+/* option for multiple returns in 'lua_pcall' and 'lua_call' */
+#define LUA_MULTRET	(-1)
+
+
+/*
+** pseudo-indices
+*/
+#define LUA_REGISTRYINDEX	LUAI_FIRSTPSEUDOIDX
+#define lua_upvalueindex(i)	(LUA_REGISTRYINDEX - (i))
+
+
+/* thread status */
+#define LUA_OK		0
+#define LUA_YIELD	1
+#define LUA_ERRRUN	2
+#define LUA_ERRSYNTAX	3
+#define LUA_ERRMEM	4
+#define LUA_ERRGCMM	5
+#define LUA_ERRERR	6
+
+
+typedef struct lua_State lua_State;
+
+typedef int (*lua_CFunction) (lua_State *L);
+
+
+/*
+** functions that read/write blocks when loading/dumping Lua chunks
+*/
+typedef const char * (*lua_Reader) (lua_State *L, void *ud, size_t *sz);
+
+typedef int (*lua_Writer) (lua_State *L, const void* p, size_t sz, void* ud);
+
+
+/*
+** prototype for memory-allocation functions
+*/
+typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);
+
+
+/*
+** basic types
+*/
+#define LUA_TNONE		(-1)
+
+#define LUA_TNIL		0
+#define LUA_TBOOLEAN		1
+#define LUA_TLIGHTUSERDATA	2
+#define LUA_TNUMBER		3
+#define LUA_TSTRING		4
+#define LUA_TTABLE		5
+#define LUA_TFUNCTION		6
+#define LUA_TUSERDATA		7
+#define LUA_TTHREAD		8
+
+#define LUA_NUMTAGS		9
+
+
+
+/* minimum Lua stack available to a C function */
+#define LUA_MINSTACK	20
+
+
+/* predefined values in the registry */
+#define LUA_RIDX_MAINTHREAD	1
+#define LUA_RIDX_GLOBALS	2
+#define LUA_RIDX_LAST		LUA_RIDX_GLOBALS
+
+
+/* type of numbers in Lua */
+typedef LUA_NUMBER lua_Number;
+
+
+/* type for integer functions */
+typedef LUA_INTEGER lua_Integer;
+
+/* unsigned integer type */
+typedef LUA_UNSIGNED lua_Unsigned;
+
+
+
+/*
+** generic extra include file
+*/
+#if defined(LUA_USER_H)
+#include LUA_USER_H
+#endif
+
+
+/*
+** RCS ident string
+*/
+extern const char lua_ident[];
+
+
+/*
+** state manipulation
+*/
+LUA_API lua_State *(lua_newstate) (lua_Alloc f, void *ud);
+LUA_API void       (lua_close) (lua_State *L);
+LUA_API lua_State *(lua_newthread) (lua_State *L);
+
+LUA_API lua_CFunction (lua_atpanic) (lua_State *L, lua_CFunction panicf);
+
+
+LUA_API const lua_Number *(lua_version) (lua_State *L);
+
+
+/*
+** basic stack manipulation
+*/
+LUA_API int   (lua_absindex) (lua_State *L, int idx);
+LUA_API int   (lua_gettop) (lua_State *L);
+LUA_API void  (lua_settop) (lua_State *L, int idx);
+LUA_API void  (lua_pushvalue) (lua_State *L, int idx);
+LUA_API void  (lua_remove) (lua_State *L, int idx);
+LUA_API void  (lua_insert) (lua_State *L, int idx);
+LUA_API void  (lua_replace) (lua_State *L, int idx);
+LUA_API void  (lua_copy) (lua_State *L, int fromidx, int toidx);
+LUA_API int   (lua_checkstack) (lua_State *L, int sz);
+
+LUA_API void  (lua_xmove) (lua_State *from, lua_State *to, int n);
+
+
+/*
+** access functions (stack -> C)
+*/
+
+LUA_API int             (lua_isnumber) (lua_State *L, int idx);
+LUA_API int             (lua_isstring) (lua_State *L, int idx);
+LUA_API int             (lua_iscfunction) (lua_State *L, int idx);
+LUA_API int             (lua_isuserdata) (lua_State *L, int idx);
+LUA_API int             (lua_type) (lua_State *L, int idx);
+LUA_API const char     *(lua_typename) (lua_State *L, int tp);
+
+LUA_API lua_Number      (lua_tonumberx) (lua_State *L, int idx, int *isnum);
+LUA_API lua_Integer     (lua_tointegerx) (lua_State *L, int idx, int *isnum);
+LUA_API lua_Unsigned    (lua_tounsignedx) (lua_State *L, int idx, int *isnum);
+LUA_API int             (lua_toboolean) (lua_State *L, int idx);
+LUA_API const char     *(lua_tolstring) (lua_State *L, int idx, size_t *len);
+LUA_API size_t          (lua_rawlen) (lua_State *L, int idx);
+LUA_API lua_CFunction   (lua_tocfunction) (lua_State *L, int idx);
+LUA_API void	       *(lua_touserdata) (lua_State *L, int idx);
+LUA_API lua_State      *(lua_tothread) (lua_State *L, int idx);
+LUA_API const void     *(lua_topointer) (lua_State *L, int idx);
+
+
+/*
+** Comparison and arithmetic functions
+*/
+
+#define LUA_OPADD	0	/* ORDER TM */
+#define LUA_OPSUB	1
+#define LUA_OPMUL	2
+#define LUA_OPDIV	3
+#define LUA_OPMOD	4
+#define LUA_OPPOW	5
+#define LUA_OPUNM	6
+
+LUA_API void  (lua_arith) (lua_State *L, int op);
+
+#define LUA_OPEQ	0
+#define LUA_OPLT	1
+#define LUA_OPLE	2
+
+LUA_API int   (lua_rawequal) (lua_State *L, int idx1, int idx2);
+LUA_API int   (lua_compare) (lua_State *L, int idx1, int idx2, int op);
+
+
+/*
+** push functions (C -> stack)
+*/
+LUA_API void        (lua_pushnil) (lua_State *L);
+LUA_API void        (lua_pushnumber) (lua_State *L, lua_Number n);
+LUA_API void        (lua_pushinteger) (lua_State *L, lua_Integer n);
+LUA_API void        (lua_pushunsigned) (lua_State *L, lua_Unsigned n);
+LUA_API const char *(lua_pushlstring) (lua_State *L, const char *s, size_t l);
+LUA_API const char *(lua_pushstring) (lua_State *L, const char *s);
+LUA_API const char *(lua_pushvfstring) (lua_State *L, const char *fmt,
+                                                      va_list argp);
+LUA_API const char *(lua_pushfstring) (lua_State *L, const char *fmt, ...);
+LUA_API void  (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n);
+LUA_API void  (lua_pushboolean) (lua_State *L, int b);
+LUA_API void  (lua_pushlightuserdata) (lua_State *L, void *p);
+LUA_API int   (lua_pushthread) (lua_State *L);
+
+
+/*
+** get functions (Lua -> stack)
+*/
+LUA_API void  (lua_getglobal) (lua_State *L, const char *var);
+LUA_API void  (lua_gettable) (lua_State *L, int idx);
+LUA_API void  (lua_getfield) (lua_State *L, int idx, const char *k);
+LUA_API void  (lua_rawget) (lua_State *L, int idx);
+LUA_API void  (lua_rawgeti) (lua_State *L, int idx, int n);
+LUA_API void  (lua_rawgetp) (lua_State *L, int idx, const void *p);
+LUA_API void  (lua_createtable) (lua_State *L, int narr, int nrec);
+LUA_API void *(lua_newuserdata) (lua_State *L, size_t sz);
+LUA_API int   (lua_getmetatable) (lua_State *L, int objindex);
+LUA_API void  (lua_getuservalue) (lua_State *L, int idx);
+
+
+/*
+** set functions (stack -> Lua)
+*/
+LUA_API void  (lua_setglobal) (lua_State *L, const char *var);
+LUA_API void  (lua_settable) (lua_State *L, int idx);
+LUA_API void  (lua_setfield) (lua_State *L, int idx, const char *k);
+LUA_API void  (lua_rawset) (lua_State *L, int idx);
+LUA_API void  (lua_rawseti) (lua_State *L, int idx, int n);
+LUA_API void  (lua_rawsetp) (lua_State *L, int idx, const void *p);
+LUA_API int   (lua_setmetatable) (lua_State *L, int objindex);
+LUA_API void  (lua_setuservalue) (lua_State *L, int idx);
+
+
+/*
+** 'load' and 'call' functions (load and run Lua code)
+*/
+LUA_API void  (lua_callk) (lua_State *L, int nargs, int nresults, int ctx,
+                           lua_CFunction k);
+#define lua_call(L,n,r)		lua_callk(L, (n), (r), 0, NULL)
+
+LUA_API int   (lua_getctx) (lua_State *L, int *ctx);
+
+LUA_API int   (lua_pcallk) (lua_State *L, int nargs, int nresults, int errfunc,
+                            int ctx, lua_CFunction k);
+#define lua_pcall(L,n,r,f)	lua_pcallk(L, (n), (r), (f), 0, NULL)
+
+LUA_API int   (lua_load) (lua_State *L, lua_Reader reader, void *dt,
+                                        const char *chunkname,
+                                        const char *mode);
+
+LUA_API int (lua_dump) (lua_State *L, lua_Writer writer, void *data);
+
+
+/*
+** coroutine functions
+*/
+LUA_API int  (lua_yieldk) (lua_State *L, int nresults, int ctx,
+                           lua_CFunction k);
+#define lua_yield(L,n)		lua_yieldk(L, (n), 0, NULL)
+LUA_API int  (lua_resume) (lua_State *L, lua_State *from, int narg);
+LUA_API int  (lua_status) (lua_State *L);
+
+/*
+** garbage-collection function and options
+*/
+
+#define LUA_GCSTOP		0
+#define LUA_GCRESTART		1
+#define LUA_GCCOLLECT		2
+#define LUA_GCCOUNT		3
+#define LUA_GCCOUNTB		4
+#define LUA_GCSTEP		5
+#define LUA_GCSETPAUSE		6
+#define LUA_GCSETSTEPMUL	7
+#define LUA_GCSETMAJORINC	8
+#define LUA_GCISRUNNING		9
+#define LUA_GCGEN		10
+#define LUA_GCINC		11
+
+LUA_API int (lua_gc) (lua_State *L, int what, int data);
+
+
+/*
+** miscellaneous functions
+*/
+
+LUA_API int   (lua_error) (lua_State *L);
+
+LUA_API int   (lua_next) (lua_State *L, int idx);
+
+LUA_API void  (lua_concat) (lua_State *L, int n);
+LUA_API void  (lua_len)    (lua_State *L, int idx);
+
+LUA_API lua_Alloc (lua_getallocf) (lua_State *L, void **ud);
+LUA_API void      (lua_setallocf) (lua_State *L, lua_Alloc f, void *ud);
+
+
+
+/*
+** ===============================================================
+** some useful macros
+** ===============================================================
+*/
+
+#define lua_tonumber(L,i)	lua_tonumberx(L,i,NULL)
+#define lua_tointeger(L,i)	lua_tointegerx(L,i,NULL)
+#define lua_tounsigned(L,i)	lua_tounsignedx(L,i,NULL)
+
+#define lua_pop(L,n)		lua_settop(L, -(n)-1)
+
+#define lua_newtable(L)		lua_createtable(L, 0, 0)
+
+#define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))
+
+#define lua_pushcfunction(L,f)	lua_pushcclosure(L, (f), 0)
+
+#define lua_isfunction(L,n)	(lua_type(L, (n)) == LUA_TFUNCTION)
+#define lua_istable(L,n)	(lua_type(L, (n)) == LUA_TTABLE)
+#define lua_islightuserdata(L,n)	(lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
+#define lua_isnil(L,n)		(lua_type(L, (n)) == LUA_TNIL)
+#define lua_isboolean(L,n)	(lua_type(L, (n)) == LUA_TBOOLEAN)
+#define lua_isthread(L,n)	(lua_type(L, (n)) == LUA_TTHREAD)
+#define lua_isnone(L,n)		(lua_type(L, (n)) == LUA_TNONE)
+#define lua_isnoneornil(L, n)	(lua_type(L, (n)) <= 0)
+
+#define lua_pushliteral(L, s)	\
+	lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)
+
+#define lua_pushglobaltable(L)  \
+	lua_rawgeti(L, LUA_REGISTRYINDEX, LUA_RIDX_GLOBALS)
+
+#define lua_tostring(L,i)	lua_tolstring(L, (i), NULL)
+
+
+
+/*
+** {======================================================================
+** Debug API
+** =======================================================================
+*/
+
+
+/*
+** Event codes
+*/
+#define LUA_HOOKCALL	0
+#define LUA_HOOKRET	1
+#define LUA_HOOKLINE	2
+#define LUA_HOOKCOUNT	3
+#define LUA_HOOKTAILCALL 4
+
+
+/*
+** Event masks
+*/
+#define LUA_MASKCALL	(1 << LUA_HOOKCALL)
+#define LUA_MASKRET	(1 << LUA_HOOKRET)
+#define LUA_MASKLINE	(1 << LUA_HOOKLINE)
+#define LUA_MASKCOUNT	(1 << LUA_HOOKCOUNT)
+
+typedef struct lua_Debug lua_Debug;  /* activation record */
+
+
+/* Functions to be called by the debugger in specific events */
+typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);
+
+
+LUA_API int (lua_getstack) (lua_State *L, int level, lua_Debug *ar);
+LUA_API int (lua_getinfo) (lua_State *L, const char *what, lua_Debug *ar);
+LUA_API const char *(lua_getlocal) (lua_State *L, const lua_Debug *ar, int n);
+LUA_API const char *(lua_setlocal) (lua_State *L, const lua_Debug *ar, int n);
+LUA_API const char *(lua_getupvalue) (lua_State *L, int funcindex, int n);
+LUA_API const char *(lua_setupvalue) (lua_State *L, int funcindex, int n);
+
+LUA_API void *(lua_upvalueid) (lua_State *L, int fidx, int n);
+LUA_API void  (lua_upvaluejoin) (lua_State *L, int fidx1, int n1,
+                                               int fidx2, int n2);
+
+LUA_API int (lua_sethook) (lua_State *L, lua_Hook func, int mask, int count);
+LUA_API lua_Hook (lua_gethook) (lua_State *L);
+LUA_API int (lua_gethookmask) (lua_State *L);
+LUA_API int (lua_gethookcount) (lua_State *L);
+
+
+struct lua_Debug {
+  int event;
+  const char *name;	/* (n) */
+  const char *namewhat;	/* (n) 'global', 'local', 'field', 'method' */
+  const char *what;	/* (S) 'Lua', 'C', 'main', 'tail' */
+  const char *source;	/* (S) */
+  int currentline;	/* (l) */
+  int linedefined;	/* (S) */
+  int lastlinedefined;	/* (S) */
+  unsigned char nups;	/* (u) number of upvalues */
+  unsigned char nparams;/* (u) number of parameters */
+  char isvararg;        /* (u) */
+  char istailcall;	/* (t) */
+  char short_src[LUA_IDSIZE]; /* (S) */
+  /* private part */
+  struct CallInfo *i_ci;  /* active function */
+};
+
+/* }====================================================================== */
+
+
+/******************************************************************************
+* Copyright (C) 1994-2013 Lua.org, PUC-Rio.
+*
+* Permission is hereby granted, free of charge, to any person obtaining
+* a copy of this software and associated documentation files (the
+* "Software"), to deal in the Software without restriction, including
+* without limitation the rights to use, copy, modify, merge, publish,
+* distribute, sublicense, and/or sell copies of the Software, and to
+* permit persons to whom the Software is furnished to do so, subject to
+* the following conditions:
+*
+* The above copyright notice and this permission notice shall be
+* included in all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+******************************************************************************/
+
+
+#endif
diff -ruNp src.hd/libs/lua/lua.hpp src/libs/lua/lua.hpp
--- src.hd/libs/lua/lua.hpp	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lua.hpp	2017-12-29 00:57:40 -0800
@@ -0,0 +1,9 @@
+// lua.hpp
+// Lua header files for C++
+// <<extern "C">> not supplied automatically because Lua also compiles as C++
+
+extern "C" {
+#include "lua.h"
+#include "lualib.h"
+#include "lauxlib.h"
+}
diff -ruNp src.hd/libs/lua/luac.c src/libs/lua/luac.c
--- src.hd/libs/lua/luac.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/luac.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,432 @@
+/*
+** $Id: luac.c,v 1.69 2011/11/29 17:46:33 lhf Exp $
+** Lua compiler (saves bytecodes to files; also list bytecodes)
+** See Copyright Notice in lua.h
+*/
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define luac_c
+#define LUA_CORE
+
+#include "lua.h"
+#include "lauxlib.h"
+
+#include "lobject.h"
+#include "lstate.h"
+#include "lundump.h"
+
+static void PrintFunction(const Proto* f, int full);
+#define luaU_print	PrintFunction
+
+#define PROGNAME	"luac"		/* default program name */
+#define OUTPUT		PROGNAME ".out"	/* default output file */
+
+static int listing=0;			/* list bytecodes? */
+static int dumping=1;			/* dump bytecodes? */
+static int stripping=0;			/* strip debug information? */
+static char Output[]={ OUTPUT };	/* default output file name */
+static const char* output=Output;	/* actual output file name */
+static const char* progname=PROGNAME;	/* actual program name */
+
+static void fatal(const char* message)
+{
+ fprintf(stderr,"%s: %s\n",progname,message);
+ exit(EXIT_FAILURE);
+}
+
+static void cannot(const char* what)
+{
+ fprintf(stderr,"%s: cannot %s %s: %s\n",progname,what,output,strerror(errno));
+ exit(EXIT_FAILURE);
+}
+
+static void usage(const char* message)
+{
+ if (*message=='-')
+  fprintf(stderr,"%s: unrecognized option " LUA_QS "\n",progname,message);
+ else
+  fprintf(stderr,"%s: %s\n",progname,message);
+ fprintf(stderr,
+  "usage: %s [options] [filenames]\n"
+  "Available options are:\n"
+  "  -l       list (use -l -l for full listing)\n"
+  "  -o name  output to file " LUA_QL("name") " (default is \"%s\")\n"
+  "  -p       parse only\n"
+  "  -s       strip debug information\n"
+  "  -v       show version information\n"
+  "  --       stop handling options\n"
+  "  -        stop handling options and process stdin\n"
+  ,progname,Output);
+ exit(EXIT_FAILURE);
+}
+
+#define IS(s)	(strcmp(argv[i],s)==0)
+
+static int doargs(int argc, char* argv[])
+{
+ int i;
+ int version=0;
+ if (argv[0]!=NULL && *argv[0]!=0) progname=argv[0];
+ for (i=1; i<argc; i++)
+ {
+  if (*argv[i]!='-')			/* end of options; keep it */
+   break;
+  else if (IS("--"))			/* end of options; skip it */
+  {
+   ++i;
+   if (version) ++version;
+   break;
+  }
+  else if (IS("-"))			/* end of options; use stdin */
+   break;
+  else if (IS("-l"))			/* list */
+   ++listing;
+  else if (IS("-o"))			/* output file */
+  {
+   output=argv[++i];
+   if (output==NULL || *output==0 || (*output=='-' && output[1]!=0))
+    usage(LUA_QL("-o") " needs argument");
+   if (IS("-")) output=NULL;
+  }
+  else if (IS("-p"))			/* parse only */
+   dumping=0;
+  else if (IS("-s"))			/* strip debug information */
+   stripping=1;
+  else if (IS("-v"))			/* show version */
+   ++version;
+  else					/* unknown option */
+   usage(argv[i]);
+ }
+ if (i==argc && (listing || !dumping))
+ {
+  dumping=0;
+  argv[--i]=Output;
+ }
+ if (version)
+ {
+  printf("%s\n",LUA_COPYRIGHT);
+  if (version==argc-1) exit(EXIT_SUCCESS);
+ }
+ return i;
+}
+
+#define FUNCTION "(function()end)();"
+
+static const char* reader(lua_State *L, void *ud, size_t *size)
+{
+ UNUSED(L);
+ if ((*(int*)ud)--)
+ {
+  *size=sizeof(FUNCTION)-1;
+  return FUNCTION;
+ }
+ else
+ {
+  *size=0;
+  return NULL;
+ }
+}
+
+#define toproto(L,i) getproto(L->top+(i))
+
+static const Proto* combine(lua_State* L, int n)
+{
+ if (n==1)
+  return toproto(L,-1);
+ else
+ {
+  Proto* f;
+  int i=n;
+  if (lua_load(L,reader,&i,"=(" PROGNAME ")",NULL)!=LUA_OK) fatal(lua_tostring(L,-1));
+  f=toproto(L,-1);
+  for (i=0; i<n; i++)
+  {
+   f->p[i]=toproto(L,i-n-1);
+   if (f->p[i]->sizeupvalues>0) f->p[i]->upvalues[0].instack=0;
+  }
+  f->sizelineinfo=0;
+  return f;
+ }
+}
+
+static int writer(lua_State* L, const void* p, size_t size, void* u)
+{
+ UNUSED(L);
+ return (fwrite(p,size,1,(FILE*)u)!=1) && (size!=0);
+}
+
+static int pmain(lua_State* L)
+{
+ int argc=(int)lua_tointeger(L,1);
+ char** argv=(char**)lua_touserdata(L,2);
+ const Proto* f;
+ int i;
+ if (!lua_checkstack(L,argc)) fatal("too many input files");
+ for (i=0; i<argc; i++)
+ {
+  const char* filename=IS("-") ? NULL : argv[i];
+  if (luaL_loadfile(L,filename)!=LUA_OK) fatal(lua_tostring(L,-1));
+ }
+ f=combine(L,argc);
+ if (listing) luaU_print(f,listing>1);
+ if (dumping)
+ {
+  FILE* D= (output==NULL) ? stdout : fopen(output,"wb");
+  if (D==NULL) cannot("open");
+  lua_lock(L);
+  luaU_dump(L,f,writer,D,stripping);
+  lua_unlock(L);
+  if (ferror(D)) cannot("write");
+  if (fclose(D)) cannot("close");
+ }
+ return 0;
+}
+
+int main(int argc, char* argv[])
+{
+ lua_State* L;
+ int i=doargs(argc,argv);
+ argc-=i; argv+=i;
+ if (argc<=0) usage("no input files given");
+ L=luaL_newstate();
+ if (L==NULL) fatal("cannot create state: not enough memory");
+ lua_pushcfunction(L,&pmain);
+ lua_pushinteger(L,argc);
+ lua_pushlightuserdata(L,argv);
+ if (lua_pcall(L,2,0,0)!=LUA_OK) fatal(lua_tostring(L,-1));
+ lua_close(L);
+ return EXIT_SUCCESS;
+}
+
+/*
+** $Id: print.c,v 1.68 2011/09/30 10:21:20 lhf Exp $
+** print bytecodes
+** See Copyright Notice in lua.h
+*/
+
+#include <ctype.h>
+#include <stdio.h>
+
+#define luac_c
+#define LUA_CORE
+
+#include "ldebug.h"
+#include "lobject.h"
+#include "lopcodes.h"
+
+#define VOID(p)		((const void*)(p))
+
+static void PrintString(const TString* ts)
+{
+ const char* s=getstr(ts);
+ size_t i,n=ts->tsv.len;
+ printf("%c",'"');
+ for (i=0; i<n; i++)
+ {
+  int c=(int)(unsigned char)s[i];
+  switch (c)
+  {
+   case '"':  printf("\\\""); break;
+   case '\\': printf("\\\\"); break;
+   case '\a': printf("\\a"); break;
+   case '\b': printf("\\b"); break;
+   case '\f': printf("\\f"); break;
+   case '\n': printf("\\n"); break;
+   case '\r': printf("\\r"); break;
+   case '\t': printf("\\t"); break;
+   case '\v': printf("\\v"); break;
+   default:	if (isprint(c))
+   			printf("%c",c);
+		else
+			printf("\\%03d",c);
+  }
+ }
+ printf("%c",'"');
+}
+
+static void PrintConstant(const Proto* f, int i)
+{
+ const TValue* o=&f->k[i];
+ switch (ttype(o))
+ {
+  case LUA_TNIL:
+	printf("nil");
+	break;
+  case LUA_TBOOLEAN:
+	printf(bvalue(o) ? "true" : "false");
+	break;
+  case LUA_TNUMBER:
+	printf(LUA_NUMBER_FMT,nvalue(o));
+	break;
+  case LUA_TSTRING:
+	PrintString(rawtsvalue(o));
+	break;
+  default:				/* cannot happen */
+	printf("? type=%d",ttype(o));
+	break;
+ }
+}
+
+#define UPVALNAME(x) ((f->upvalues[x].name) ? getstr(f->upvalues[x].name) : "-")
+#define MYK(x)		(-1-(x))
+
+static void PrintCode(const Proto* f)
+{
+ const Instruction* code=f->code;
+ int pc,n=f->sizecode;
+ for (pc=0; pc<n; pc++)
+ {
+  Instruction i=code[pc];
+  OpCode o=GET_OPCODE(i);
+  int a=GETARG_A(i);
+  int b=GETARG_B(i);
+  int c=GETARG_C(i);
+  int ax=GETARG_Ax(i);
+  int bx=GETARG_Bx(i);
+  int sbx=GETARG_sBx(i);
+  int line=getfuncline(f,pc);
+  printf("\t%d\t",pc+1);
+  if (line>0) printf("[%d]\t",line); else printf("[-]\t");
+  printf("%-9s\t",luaP_opnames[o]);
+  switch (getOpMode(o))
+  {
+   case iABC:
+    printf("%d",a);
+    if (getBMode(o)!=OpArgN) printf(" %d",ISK(b) ? (MYK(INDEXK(b))) : b);
+    if (getCMode(o)!=OpArgN) printf(" %d",ISK(c) ? (MYK(INDEXK(c))) : c);
+    break;
+   case iABx:
+    printf("%d",a);
+    if (getBMode(o)==OpArgK) printf(" %d",MYK(bx));
+    if (getBMode(o)==OpArgU) printf(" %d",bx);
+    break;
+   case iAsBx:
+    printf("%d %d",a,sbx);
+    break;
+   case iAx:
+    printf("%d",MYK(ax));
+    break;
+  }
+  switch (o)
+  {
+   case OP_LOADK:
+    printf("\t; "); PrintConstant(f,bx);
+    break;
+   case OP_GETUPVAL:
+   case OP_SETUPVAL:
+    printf("\t; %s",UPVALNAME(b));
+    break;
+   case OP_GETTABUP:
+    printf("\t; %s",UPVALNAME(b));
+    if (ISK(c)) { printf(" "); PrintConstant(f,INDEXK(c)); }
+    break;
+   case OP_SETTABUP:
+    printf("\t; %s",UPVALNAME(a));
+    if (ISK(b)) { printf(" "); PrintConstant(f,INDEXK(b)); }
+    if (ISK(c)) { printf(" "); PrintConstant(f,INDEXK(c)); }
+    break;
+   case OP_GETTABLE:
+   case OP_SELF:
+    if (ISK(c)) { printf("\t; "); PrintConstant(f,INDEXK(c)); }
+    break;
+   case OP_SETTABLE:
+   case OP_ADD:
+   case OP_SUB:
+   case OP_MUL:
+   case OP_DIV:
+   case OP_POW:
+   case OP_EQ:
+   case OP_LT:
+   case OP_LE:
+    if (ISK(b) || ISK(c))
+    {
+     printf("\t; ");
+     if (ISK(b)) PrintConstant(f,INDEXK(b)); else printf("-");
+     printf(" ");
+     if (ISK(c)) PrintConstant(f,INDEXK(c)); else printf("-");
+    }
+    break;
+   case OP_JMP:
+   case OP_FORLOOP:
+   case OP_FORPREP:
+   case OP_TFORLOOP:
+    printf("\t; to %d",sbx+pc+2);
+    break;
+   case OP_CLOSURE:
+    printf("\t; %p",VOID(f->p[bx]));
+    break;
+   case OP_SETLIST:
+    if (c==0) printf("\t; %d",(int)code[++pc]); else printf("\t; %d",c);
+    break;
+   case OP_EXTRAARG:
+    printf("\t; "); PrintConstant(f,ax);
+    break;
+   default:
+    break;
+  }
+  printf("\n");
+ }
+}
+
+#define SS(x)	((x==1)?"":"s")
+#define S(x)	(int)(x),SS(x)
+
+static void PrintHeader(const Proto* f)
+{
+ const char* s=f->source ? getstr(f->source) : "=?";
+ if (*s=='@' || *s=='=')
+  s++;
+ else if (*s==LUA_SIGNATURE[0])
+  s="(bstring)";
+ else
+  s="(string)";
+ printf("\n%s <%s:%d,%d> (%d instruction%s at %p)\n",
+ 	(f->linedefined==0)?"main":"function",s,
+	f->linedefined,f->lastlinedefined,
+	S(f->sizecode),VOID(f));
+ printf("%d%s param%s, %d slot%s, %d upvalue%s, ",
+	(int)(f->numparams),f->is_vararg?"+":"",SS(f->numparams),
+	S(f->maxstacksize),S(f->sizeupvalues));
+ printf("%d local%s, %d constant%s, %d function%s\n",
+	S(f->sizelocvars),S(f->sizek),S(f->sizep));
+}
+
+static void PrintDebug(const Proto* f)
+{
+ int i,n;
+ n=f->sizek;
+ printf("constants (%d) for %p:\n",n,VOID(f));
+ for (i=0; i<n; i++)
+ {
+  printf("\t%d\t",i+1);
+  PrintConstant(f,i);
+  printf("\n");
+ }
+ n=f->sizelocvars;
+ printf("locals (%d) for %p:\n",n,VOID(f));
+ for (i=0; i<n; i++)
+ {
+  printf("\t%d\t%s\t%d\t%d\n",
+  i,getstr(f->locvars[i].varname),f->locvars[i].startpc+1,f->locvars[i].endpc+1);
+ }
+ n=f->sizeupvalues;
+ printf("upvalues (%d) for %p:\n",n,VOID(f));
+ for (i=0; i<n; i++)
+ {
+  printf("\t%d\t%s\t%d\t%d\n",
+  i,UPVALNAME(i),f->upvalues[i].instack,f->upvalues[i].idx);
+ }
+}
+
+static void PrintFunction(const Proto* f, int full)
+{
+ int i,n=f->sizep;
+ PrintHeader(f);
+ PrintCode(f);
+ if (full) PrintDebug(f);
+ for (i=0; i<n; i++) PrintFunction(f->p[i],full);
+}
diff -ruNp src.hd/libs/lua/luaconf.h src/libs/lua/luaconf.h
--- src.hd/libs/lua/luaconf.h	1969-12-31 16:00:00 -0800
+++ src/libs/lua/luaconf.h	2017-12-29 00:57:40 -0800
@@ -0,0 +1,551 @@
+/*
+** $Id: luaconf.h,v 1.176 2013/03/16 21:10:18 roberto Exp $
+** Configuration file for Lua
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lconfig_h
+#define lconfig_h
+
+#include <limits.h>
+#include <stddef.h>
+
+
+/*
+** ==================================================================
+** Search for "@@" to find all configurable definitions.
+** ===================================================================
+*/
+
+
+/*
+@@ LUA_ANSI controls the use of non-ansi features.
+** CHANGE it (define it) if you want Lua to avoid the use of any
+** non-ansi feature or library.
+*/
+#if !defined(LUA_ANSI) && defined(__STRICT_ANSI__)
+#define LUA_ANSI
+#endif
+
+
+#if !defined(LUA_ANSI) && defined(_WIN32) && !defined(_WIN32_WCE)
+#define LUA_WIN		/* enable goodies for regular Windows platforms */
+#endif
+
+#if defined(LUA_WIN)
+#define LUA_DL_DLL
+#define LUA_USE_AFORMAT		/* assume 'printf' handles 'aA' specifiers */
+#endif
+
+
+
+#if defined(LUA_USE_LINUX)
+#define LUA_USE_POSIX
+#define LUA_USE_DLOPEN		/* needs an extra library: -ldl */
+#define LUA_USE_READLINE	/* needs some extra libraries */
+#define LUA_USE_STRTODHEX	/* assume 'strtod' handles hex formats */
+#define LUA_USE_AFORMAT		/* assume 'printf' handles 'aA' specifiers */
+#define LUA_USE_LONGLONG	/* assume support for long long */
+#endif
+
+#if defined(LUA_USE_MACOSX)
+#define LUA_USE_POSIX
+#define LUA_USE_DLOPEN		/* does not need -ldl */
+#define LUA_USE_READLINE	/* needs an extra library: -lreadline */
+#define LUA_USE_STRTODHEX	/* assume 'strtod' handles hex formats */
+#define LUA_USE_AFORMAT		/* assume 'printf' handles 'aA' specifiers */
+#define LUA_USE_LONGLONG	/* assume support for long long */
+#endif
+
+
+
+/*
+@@ LUA_USE_POSIX includes all functionality listed as X/Open System
+@* Interfaces Extension (XSI).
+** CHANGE it (define it) if your system is XSI compatible.
+*/
+#if defined(LUA_USE_POSIX)
+#define LUA_USE_MKSTEMP
+#define LUA_USE_ISATTY
+#define LUA_USE_POPEN
+#define LUA_USE_ULONGJMP
+#define LUA_USE_GMTIME_R
+#endif
+
+
+
+/*
+@@ LUA_PATH_DEFAULT is the default path that Lua uses to look for
+@* Lua libraries.
+@@ LUA_CPATH_DEFAULT is the default path that Lua uses to look for
+@* C libraries.
+** CHANGE them if your machine has a non-conventional directory
+** hierarchy or if you want to install your libraries in
+** non-conventional directories.
+*/
+#if defined(_WIN32)	/* { */
+/*
+** In Windows, any exclamation mark ('!') in the path is replaced by the
+** path of the directory of the executable file of the current process.
+*/
+#define LUA_LDIR	"!\\lua\\"
+#define LUA_CDIR	"!\\"
+#define LUA_PATH_DEFAULT  \
+		LUA_LDIR"?.lua;"  LUA_LDIR"?\\init.lua;" \
+		LUA_CDIR"?.lua;"  LUA_CDIR"?\\init.lua;" ".\\?.lua"
+#define LUA_CPATH_DEFAULT \
+		LUA_CDIR"?.dll;" LUA_CDIR"loadall.dll;" ".\\?.dll"
+
+#else			/* }{ */
+
+#define LUA_VDIR	LUA_VERSION_MAJOR "." LUA_VERSION_MINOR "/"
+#define LUA_ROOT	"/usr/local/"
+#define LUA_LDIR	LUA_ROOT "share/lua/" LUA_VDIR
+#define LUA_CDIR	LUA_ROOT "lib/lua/" LUA_VDIR
+#define LUA_PATH_DEFAULT  \
+		LUA_LDIR"?.lua;"  LUA_LDIR"?/init.lua;" \
+		LUA_CDIR"?.lua;"  LUA_CDIR"?/init.lua;" "./?.lua"
+#define LUA_CPATH_DEFAULT \
+		LUA_CDIR"?.so;" LUA_CDIR"loadall.so;" "./?.so"
+#endif			/* } */
+
+
+/*
+@@ LUA_DIRSEP is the directory separator (for submodules).
+** CHANGE it if your machine does not use "/" as the directory separator
+** and is not Windows. (On Windows Lua automatically uses "\".)
+*/
+#if defined(_WIN32)
+#define LUA_DIRSEP	"\\"
+#else
+#define LUA_DIRSEP	"/"
+#endif
+
+
+/*
+@@ LUA_ENV is the name of the variable that holds the current
+@@ environment, used to access global names.
+** CHANGE it if you do not like this name.
+*/
+#define LUA_ENV		"_ENV"
+
+
+/*
+@@ LUA_API is a mark for all core API functions.
+@@ LUALIB_API is a mark for all auxiliary library functions.
+@@ LUAMOD_API is a mark for all standard library opening functions.
+** CHANGE them if you need to define those functions in some special way.
+** For instance, if you want to create one Windows DLL with the core and
+** the libraries, you may want to use the following definition (define
+** LUA_BUILD_AS_DLL to get it).
+*/
+#if defined(LUA_BUILD_AS_DLL)	/* { */
+
+#if defined(LUA_CORE) || defined(LUA_LIB)	/* { */
+#define LUA_API __declspec(dllexport)
+#else						/* }{ */
+#define LUA_API __declspec(dllimport)
+#endif						/* } */
+
+#else				/* }{ */
+
+#define LUA_API		extern
+
+#endif				/* } */
+
+
+/* more often than not the libs go together with the core */
+#define LUALIB_API	LUA_API
+#define LUAMOD_API	LUALIB_API
+
+
+/*
+@@ LUAI_FUNC is a mark for all extern functions that are not to be
+@* exported to outside modules.
+@@ LUAI_DDEF and LUAI_DDEC are marks for all extern (const) variables
+@* that are not to be exported to outside modules (LUAI_DDEF for
+@* definitions and LUAI_DDEC for declarations).
+** CHANGE them if you need to mark them in some special way. Elf/gcc
+** (versions 3.2 and later) mark them as "hidden" to optimize access
+** when Lua is compiled as a shared library. Not all elf targets support
+** this attribute. Unfortunately, gcc does not offer a way to check
+** whether the target offers that support, and those without support
+** give a warning about it. To avoid these warnings, change to the
+** default definition.
+*/
+#if defined(__GNUC__) && ((__GNUC__*100 + __GNUC_MINOR__) >= 302) && \
+    defined(__ELF__)		/* { */
+#define LUAI_FUNC	__attribute__((visibility("hidden"))) extern
+#define LUAI_DDEC	LUAI_FUNC
+#define LUAI_DDEF	/* empty */
+
+#else				/* }{ */
+#define LUAI_FUNC	extern
+#define LUAI_DDEC	extern
+#define LUAI_DDEF	/* empty */
+#endif				/* } */
+
+
+
+/*
+@@ LUA_QL describes how error messages quote program elements.
+** CHANGE it if you want a different appearance.
+*/
+#define LUA_QL(x)	"'" x "'"
+#define LUA_QS		LUA_QL("%s")
+
+
+/*
+@@ LUA_IDSIZE gives the maximum size for the description of the source
+@* of a function in debug information.
+** CHANGE it if you want a different size.
+*/
+#define LUA_IDSIZE	60
+
+
+/*
+@@ luai_writestring/luai_writeline define how 'print' prints its results.
+** They are only used in libraries and the stand-alone program. (The #if
+** avoids including 'stdio.h' everywhere.)
+*/
+#if defined(LUA_LIB) || defined(lua_c)
+#include <stdio.h>
+#define luai_writestring(s,l)	fwrite((s), sizeof(char), (l), stdout)
+#define luai_writeline()	(luai_writestring("\n", 1), fflush(stdout))
+#endif
+
+/*
+@@ luai_writestringerror defines how to print error messages.
+** (A format string with one argument is enough for Lua...)
+*/
+#define luai_writestringerror(s,p) \
+	(fprintf(stderr, (s), (p)), fflush(stderr))
+
+
+/*
+@@ LUAI_MAXSHORTLEN is the maximum length for short strings, that is,
+** strings that are internalized. (Cannot be smaller than reserved words
+** or tags for metamethods, as these strings must be internalized;
+** #("function") = 8, #("__newindex") = 10.)
+*/
+#define LUAI_MAXSHORTLEN        40
+
+
+
+/*
+** {==================================================================
+** Compatibility with previous versions
+** ===================================================================
+*/
+
+/*
+@@ LUA_COMPAT_ALL controls all compatibility options.
+** You can define it to get all options, or change specific options
+** to fit your specific needs.
+*/
+#if defined(LUA_COMPAT_ALL)	/* { */
+
+/*
+@@ LUA_COMPAT_UNPACK controls the presence of global 'unpack'.
+** You can replace it with 'table.unpack'.
+*/
+#define LUA_COMPAT_UNPACK
+
+/*
+@@ LUA_COMPAT_LOADERS controls the presence of table 'package.loaders'.
+** You can replace it with 'package.searchers'.
+*/
+#define LUA_COMPAT_LOADERS
+
+/*
+@@ macro 'lua_cpcall' emulates deprecated function lua_cpcall.
+** You can call your C function directly (with light C functions).
+*/
+#define lua_cpcall(L,f,u)  \
+	(lua_pushcfunction(L, (f)), \
+	 lua_pushlightuserdata(L,(u)), \
+	 lua_pcall(L,1,0,0))
+
+
+/*
+@@ LUA_COMPAT_LOG10 defines the function 'log10' in the math library.
+** You can rewrite 'log10(x)' as 'log(x, 10)'.
+*/
+#define LUA_COMPAT_LOG10
+
+/*
+@@ LUA_COMPAT_LOADSTRING defines the function 'loadstring' in the base
+** library. You can rewrite 'loadstring(s)' as 'load(s)'.
+*/
+#define LUA_COMPAT_LOADSTRING
+
+/*
+@@ LUA_COMPAT_MAXN defines the function 'maxn' in the table library.
+*/
+#define LUA_COMPAT_MAXN
+
+/*
+@@ The following macros supply trivial compatibility for some
+** changes in the API. The macros themselves document how to
+** change your code to avoid using them.
+*/
+#define lua_strlen(L,i)		lua_rawlen(L, (i))
+
+#define lua_objlen(L,i)		lua_rawlen(L, (i))
+
+#define lua_equal(L,idx1,idx2)		lua_compare(L,(idx1),(idx2),LUA_OPEQ)
+#define lua_lessthan(L,idx1,idx2)	lua_compare(L,(idx1),(idx2),LUA_OPLT)
+
+/*
+@@ LUA_COMPAT_MODULE controls compatibility with previous
+** module functions 'module' (Lua) and 'luaL_register' (C).
+*/
+#define LUA_COMPAT_MODULE
+
+#endif				/* } */
+
+/* }================================================================== */
+
+
+
+/*
+@@ LUAI_BITSINT defines the number of bits in an int.
+** CHANGE here if Lua cannot automatically detect the number of bits of
+** your machine. Probably you do not need to change this.
+*/
+/* avoid overflows in comparison */
+#if INT_MAX-20 < 32760		/* { */
+#define LUAI_BITSINT	16
+#elif INT_MAX > 2147483640L	/* }{ */
+/* int has at least 32 bits */
+#define LUAI_BITSINT	32
+#else				/* }{ */
+#error "you must define LUA_BITSINT with number of bits in an integer"
+#endif				/* } */
+
+
+/*
+@@ LUA_INT32 is an signed integer with exactly 32 bits.
+@@ LUAI_UMEM is an unsigned integer big enough to count the total
+@* memory used by Lua.
+@@ LUAI_MEM is a signed integer big enough to count the total memory
+@* used by Lua.
+** CHANGE here if for some weird reason the default definitions are not
+** good enough for your machine. Probably you do not need to change
+** this.
+*/
+#if LUAI_BITSINT >= 32		/* { */
+#define LUA_INT32	int
+#define LUAI_UMEM	size_t
+#define LUAI_MEM	ptrdiff_t
+#else				/* }{ */
+/* 16-bit ints */
+#define LUA_INT32	long
+#define LUAI_UMEM	unsigned long
+#define LUAI_MEM	long
+#endif				/* } */
+
+
+/*
+@@ LUAI_MAXSTACK limits the size of the Lua stack.
+** CHANGE it if you need a different limit. This limit is arbitrary;
+** its only purpose is to stop Lua to consume unlimited stack
+** space (and to reserve some numbers for pseudo-indices).
+*/
+#if LUAI_BITSINT >= 32
+#define LUAI_MAXSTACK		1000000
+#else
+#define LUAI_MAXSTACK		15000
+#endif
+
+/* reserve some space for error handling */
+#define LUAI_FIRSTPSEUDOIDX	(-LUAI_MAXSTACK - 1000)
+
+
+
+
+/*
+@@ LUAL_BUFFERSIZE is the buffer size used by the lauxlib buffer system.
+** CHANGE it if it uses too much C-stack space.
+*/
+#define LUAL_BUFFERSIZE		BUFSIZ
+
+
+
+
+/*
+** {==================================================================
+@@ LUA_NUMBER is the type of numbers in Lua.
+** CHANGE the following definitions only if you want to build Lua
+** with a number type different from double. You may also need to
+** change lua_number2int & lua_number2integer.
+** ===================================================================
+*/
+
+#define LUA_NUMBER_DOUBLE
+#define LUA_NUMBER	double
+
+/*
+@@ LUAI_UACNUMBER is the result of an 'usual argument conversion'
+@* over a number.
+*/
+#define LUAI_UACNUMBER	double
+
+
+/*
+@@ LUA_NUMBER_SCAN is the format for reading numbers.
+@@ LUA_NUMBER_FMT is the format for writing numbers.
+@@ lua_number2str converts a number to a string.
+@@ LUAI_MAXNUMBER2STR is maximum size of previous conversion.
+*/
+#define LUA_NUMBER_SCAN		"%lf"
+#define LUA_NUMBER_FMT		"%.14g"
+#define lua_number2str(s,n)	sprintf((s), LUA_NUMBER_FMT, (n))
+#define LUAI_MAXNUMBER2STR	32 /* 16 digits, sign, point, and \0 */
+
+
+/*
+@@ l_mathop allows the addition of an 'l' or 'f' to all math operations
+*/
+#define l_mathop(x)		(x)
+
+
+/*
+@@ lua_str2number converts a decimal numeric string to a number.
+@@ lua_strx2number converts an hexadecimal numeric string to a number.
+** In C99, 'strtod' does both conversions. C89, however, has no function
+** to convert floating hexadecimal strings to numbers. For these
+** systems, you can leave 'lua_strx2number' undefined and Lua will
+** provide its own implementation.
+*/
+#define lua_str2number(s,p)	strtod((s), (p))
+
+#if defined(LUA_USE_STRTODHEX)
+#define lua_strx2number(s,p)	strtod((s), (p))
+#endif
+
+
+/*
+@@ The luai_num* macros define the primitive operations over numbers.
+*/
+
+/* the following operations need the math library */
+#if defined(lobject_c) || defined(lvm_c)
+#include <math.h>
+#define luai_nummod(L,a,b)	((a) - l_mathop(floor)((a)/(b))*(b))
+#define luai_numpow(L,a,b)	(l_mathop(pow)(a,b))
+#endif
+
+/* these are quite standard operations */
+#if defined(LUA_CORE)
+#define luai_numadd(L,a,b)	((a)+(b))
+#define luai_numsub(L,a,b)	((a)-(b))
+#define luai_nummul(L,a,b)	((a)*(b))
+#define luai_numdiv(L,a,b)	((a)/(b))
+#define luai_numunm(L,a)	(-(a))
+#define luai_numeq(a,b)		((a)==(b))
+#define luai_numlt(L,a,b)	((a)<(b))
+#define luai_numle(L,a,b)	((a)<=(b))
+#define luai_numisnan(L,a)	(!luai_numeq((a), (a)))
+#endif
+
+
+
+/*
+@@ LUA_INTEGER is the integral type used by lua_pushinteger/lua_tointeger.
+** CHANGE that if ptrdiff_t is not adequate on your machine. (On most
+** machines, ptrdiff_t gives a good choice between int or long.)
+*/
+#define LUA_INTEGER	ptrdiff_t
+
+/*
+@@ LUA_UNSIGNED is the integral type used by lua_pushunsigned/lua_tounsigned.
+** It must have at least 32 bits.
+*/
+#define LUA_UNSIGNED	unsigned LUA_INT32
+
+
+
+/*
+** Some tricks with doubles
+*/
+
+#if defined(LUA_NUMBER_DOUBLE) && !defined(LUA_ANSI)	/* { */
+/*
+** The next definitions activate some tricks to speed up the
+** conversion from doubles to integer types, mainly to LUA_UNSIGNED.
+**
+@@ LUA_MSASMTRICK uses Microsoft assembler to avoid clashes with a
+** DirectX idiosyncrasy.
+**
+@@ LUA_IEEE754TRICK uses a trick that should work on any machine
+** using IEEE754 with a 32-bit integer type.
+**
+@@ LUA_IEEELL extends the trick to LUA_INTEGER; should only be
+** defined when LUA_INTEGER is a 32-bit integer.
+**
+@@ LUA_IEEEENDIAN is the endianness of doubles in your machine
+** (0 for little endian, 1 for big endian); if not defined, Lua will
+** check it dynamically for LUA_IEEE754TRICK (but not for LUA_NANTRICK).
+**
+@@ LUA_NANTRICK controls the use of a trick to pack all types into
+** a single double value, using NaN values to represent non-number
+** values. The trick only works on 32-bit machines (ints and pointers
+** are 32-bit values) with numbers represented as IEEE 754-2008 doubles
+** with conventional endianess (12345678 or 87654321), in CPUs that do
+** not produce signaling NaN values (all NaNs are quiet).
+*/
+
+/* Microsoft compiler on a Pentium (32 bit) ? */
+#if defined(LUA_WIN) && defined(_MSC_VER) && defined(_M_IX86)	/* { */
+
+#define LUA_MSASMTRICK
+#define LUA_IEEEENDIAN		0
+#define LUA_NANTRICK
+
+
+/* pentium 32 bits? */
+#elif defined(__i386__) || defined(__i386) || defined(__X86__) /* }{ */
+
+#define LUA_IEEE754TRICK
+#define LUA_IEEELL
+#define LUA_IEEEENDIAN		0
+#define LUA_NANTRICK
+
+/* pentium 64 bits? */
+#elif defined(__x86_64)						/* }{ */
+
+#define LUA_IEEE754TRICK
+#define LUA_IEEEENDIAN		0
+
+#elif defined(__POWERPC__) || defined(__ppc__)			/* }{ */
+
+#define LUA_IEEE754TRICK
+#define LUA_IEEEENDIAN		1
+
+#else								/* }{ */
+
+/* assume IEEE754 and a 32-bit integer type */
+#define LUA_IEEE754TRICK
+
+#endif								/* } */
+
+#endif							/* } */
+
+/* }================================================================== */
+
+
+
+
+/* =================================================================== */
+
+/*
+** Local configuration. You can use this space to add your redefinitions
+** without modifying the main part of the file.
+*/
+
+
+
+#endif
+
diff -ruNp src.hd/libs/lua/lualib.h src/libs/lua/lualib.h
--- src.hd/libs/lua/lualib.h	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lualib.h	2017-12-29 00:57:40 -0800
@@ -0,0 +1,55 @@
+/*
+** $Id: lualib.h,v 1.43 2011/12/08 12:11:37 roberto Exp $
+** Lua standard libraries
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lualib_h
+#define lualib_h
+
+#include "lua.h"
+
+
+
+LUAMOD_API int (luaopen_base) (lua_State *L);
+
+#define LUA_COLIBNAME	"coroutine"
+LUAMOD_API int (luaopen_coroutine) (lua_State *L);
+
+#define LUA_TABLIBNAME	"table"
+LUAMOD_API int (luaopen_table) (lua_State *L);
+
+#define LUA_IOLIBNAME	"io"
+LUAMOD_API int (luaopen_io) (lua_State *L);
+
+#define LUA_OSLIBNAME	"os"
+LUAMOD_API int (luaopen_os) (lua_State *L);
+
+#define LUA_STRLIBNAME	"string"
+LUAMOD_API int (luaopen_string) (lua_State *L);
+
+#define LUA_BITLIBNAME	"bit32"
+LUAMOD_API int (luaopen_bit32) (lua_State *L);
+
+#define LUA_MATHLIBNAME	"math"
+LUAMOD_API int (luaopen_math) (lua_State *L);
+
+#define LUA_DBLIBNAME	"debug"
+LUAMOD_API int (luaopen_debug) (lua_State *L);
+
+#define LUA_LOADLIBNAME	"package"
+LUAMOD_API int (luaopen_package) (lua_State *L);
+
+
+/* open all previous libraries */
+LUALIB_API void (luaL_openlibs) (lua_State *L);
+
+
+
+#if !defined(lua_assert)
+#define lua_assert(x)	((void)0)
+#endif
+
+
+#endif
diff -ruNp src.hd/libs/lua/lundump.c src/libs/lua/lundump.c
--- src.hd/libs/lua/lundump.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lundump.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,258 @@
+/*
+** $Id: lundump.c,v 2.22 2012/05/08 13:53:33 roberto Exp $
+** load precompiled Lua chunks
+** See Copyright Notice in lua.h
+*/
+
+#include <string.h>
+
+#define lundump_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lmem.h"
+#include "lobject.h"
+#include "lstring.h"
+#include "lundump.h"
+#include "lzio.h"
+
+typedef struct {
+ lua_State* L;
+ ZIO* Z;
+ Mbuffer* b;
+ const char* name;
+} LoadState;
+
+static l_noret error(LoadState* S, const char* why)
+{
+ luaO_pushfstring(S->L,"%s: %s precompiled chunk",S->name,why);
+ luaD_throw(S->L,LUA_ERRSYNTAX);
+}
+
+#define LoadMem(S,b,n,size)	LoadBlock(S,b,(n)*(size))
+#define LoadByte(S)		(lu_byte)LoadChar(S)
+#define LoadVar(S,x)		LoadMem(S,&x,1,sizeof(x))
+#define LoadVector(S,b,n,size)	LoadMem(S,b,n,size)
+
+#if !defined(luai_verifycode)
+#define luai_verifycode(L,b,f)	/* empty */
+#endif
+
+static void LoadBlock(LoadState* S, void* b, size_t size)
+{
+ if (luaZ_read(S->Z,b,size)!=0) error(S,"truncated");
+}
+
+static int LoadChar(LoadState* S)
+{
+ char x;
+ LoadVar(S,x);
+ return x;
+}
+
+static int LoadInt(LoadState* S)
+{
+ int x;
+ LoadVar(S,x);
+ if (x<0) error(S,"corrupted");
+ return x;
+}
+
+static lua_Number LoadNumber(LoadState* S)
+{
+ lua_Number x;
+ LoadVar(S,x);
+ return x;
+}
+
+static TString* LoadString(LoadState* S)
+{
+ size_t size;
+ LoadVar(S,size);
+ if (size==0)
+  return NULL;
+ else
+ {
+  char* s=luaZ_openspace(S->L,S->b,size);
+  LoadBlock(S,s,size*sizeof(char));
+  return luaS_newlstr(S->L,s,size-1);		/* remove trailing '\0' */
+ }
+}
+
+static void LoadCode(LoadState* S, Proto* f)
+{
+ int n=LoadInt(S);
+ f->code=luaM_newvector(S->L,n,Instruction);
+ f->sizecode=n;
+ LoadVector(S,f->code,n,sizeof(Instruction));
+}
+
+static void LoadFunction(LoadState* S, Proto* f);
+
+static void LoadConstants(LoadState* S, Proto* f)
+{
+ int i,n;
+ n=LoadInt(S);
+ f->k=luaM_newvector(S->L,n,TValue);
+ f->sizek=n;
+ for (i=0; i<n; i++) setnilvalue(&f->k[i]);
+ for (i=0; i<n; i++)
+ {
+  TValue* o=&f->k[i];
+  int t=LoadChar(S);
+  switch (t)
+  {
+   case LUA_TNIL:
+	setnilvalue(o);
+	break;
+   case LUA_TBOOLEAN:
+	setbvalue(o,LoadChar(S));
+	break;
+   case LUA_TNUMBER:
+	setnvalue(o,LoadNumber(S));
+	break;
+   case LUA_TSTRING:
+	setsvalue2n(S->L,o,LoadString(S));
+	break;
+    default: lua_assert(0);
+  }
+ }
+ n=LoadInt(S);
+ f->p=luaM_newvector(S->L,n,Proto*);
+ f->sizep=n;
+ for (i=0; i<n; i++) f->p[i]=NULL;
+ for (i=0; i<n; i++)
+ {
+  f->p[i]=luaF_newproto(S->L);
+  LoadFunction(S,f->p[i]);
+ }
+}
+
+static void LoadUpvalues(LoadState* S, Proto* f)
+{
+ int i,n;
+ n=LoadInt(S);
+ f->upvalues=luaM_newvector(S->L,n,Upvaldesc);
+ f->sizeupvalues=n;
+ for (i=0; i<n; i++) f->upvalues[i].name=NULL;
+ for (i=0; i<n; i++)
+ {
+  f->upvalues[i].instack=LoadByte(S);
+  f->upvalues[i].idx=LoadByte(S);
+ }
+}
+
+static void LoadDebug(LoadState* S, Proto* f)
+{
+ int i,n;
+ f->source=LoadString(S);
+ n=LoadInt(S);
+ f->lineinfo=luaM_newvector(S->L,n,int);
+ f->sizelineinfo=n;
+ LoadVector(S,f->lineinfo,n,sizeof(int));
+ n=LoadInt(S);
+ f->locvars=luaM_newvector(S->L,n,LocVar);
+ f->sizelocvars=n;
+ for (i=0; i<n; i++) f->locvars[i].varname=NULL;
+ for (i=0; i<n; i++)
+ {
+  f->locvars[i].varname=LoadString(S);
+  f->locvars[i].startpc=LoadInt(S);
+  f->locvars[i].endpc=LoadInt(S);
+ }
+ n=LoadInt(S);
+ for (i=0; i<n; i++) f->upvalues[i].name=LoadString(S);
+}
+
+static void LoadFunction(LoadState* S, Proto* f)
+{
+ f->linedefined=LoadInt(S);
+ f->lastlinedefined=LoadInt(S);
+ f->numparams=LoadByte(S);
+ f->is_vararg=LoadByte(S);
+ f->maxstacksize=LoadByte(S);
+ LoadCode(S,f);
+ LoadConstants(S,f);
+ LoadUpvalues(S,f);
+ LoadDebug(S,f);
+}
+
+/* the code below must be consistent with the code in luaU_header */
+#define N0	LUAC_HEADERSIZE
+#define N1	(sizeof(LUA_SIGNATURE)-sizeof(char))
+#define N2	N1+2
+#define N3	N2+6
+
+static void LoadHeader(LoadState* S)
+{
+ lu_byte h[LUAC_HEADERSIZE];
+ lu_byte s[LUAC_HEADERSIZE];
+ luaU_header(h);
+ memcpy(s,h,sizeof(char));			/* first char already read */
+ LoadBlock(S,s+sizeof(char),LUAC_HEADERSIZE-sizeof(char));
+ if (memcmp(h,s,N0)==0) return;
+ if (memcmp(h,s,N1)!=0) error(S,"not a");
+ if (memcmp(h,s,N2)!=0) error(S,"version mismatch in");
+ if (memcmp(h,s,N3)!=0) error(S,"incompatible"); else error(S,"corrupted");
+}
+
+/*
+** load precompiled chunk
+*/
+Closure* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff, const char* name)
+{
+ LoadState S;
+ Closure* cl;
+ if (*name=='@' || *name=='=')
+  S.name=name+1;
+ else if (*name==LUA_SIGNATURE[0])
+  S.name="binary string";
+ else
+  S.name=name;
+ S.L=L;
+ S.Z=Z;
+ S.b=buff;
+ LoadHeader(&S);
+ cl=luaF_newLclosure(L,1);
+ setclLvalue(L,L->top,cl); incr_top(L);
+ cl->l.p=luaF_newproto(L);
+ LoadFunction(&S,cl->l.p);
+ if (cl->l.p->sizeupvalues != 1)
+ {
+  Proto* p=cl->l.p;
+  cl=luaF_newLclosure(L,cl->l.p->sizeupvalues);
+  cl->l.p=p;
+  setclLvalue(L,L->top-1,cl);
+ }
+ luai_verifycode(L,buff,cl->l.p);
+ return cl;
+}
+
+#define MYINT(s)	(s[0]-'0')
+#define VERSION		MYINT(LUA_VERSION_MAJOR)*16+MYINT(LUA_VERSION_MINOR)
+#define FORMAT		0		/* this is the official format */
+
+/*
+* make header for precompiled chunks
+* if you change the code below be sure to update LoadHeader and FORMAT above
+* and LUAC_HEADERSIZE in lundump.h
+*/
+void luaU_header (lu_byte* h)
+{
+ int x=1;
+ memcpy(h,LUA_SIGNATURE,sizeof(LUA_SIGNATURE)-sizeof(char));
+ h+=sizeof(LUA_SIGNATURE)-sizeof(char);
+ *h++=cast_byte(VERSION);
+ *h++=cast_byte(FORMAT);
+ *h++=cast_byte(*(char*)&x);			/* endianness */
+ *h++=cast_byte(sizeof(int));
+ *h++=cast_byte(sizeof(size_t));
+ *h++=cast_byte(sizeof(Instruction));
+ *h++=cast_byte(sizeof(lua_Number));
+ *h++=cast_byte(((lua_Number)0.5)==0);		/* is lua_Number integral? */
+ memcpy(h,LUAC_TAIL,sizeof(LUAC_TAIL)-sizeof(char));
+}
diff -ruNp src.hd/libs/lua/lundump.h src/libs/lua/lundump.h
--- src.hd/libs/lua/lundump.h	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lundump.h	2017-12-29 00:57:40 -0800
@@ -0,0 +1,28 @@
+/*
+** $Id: lundump.h,v 1.39 2012/05/08 13:53:33 roberto Exp $
+** load precompiled Lua chunks
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lundump_h
+#define lundump_h
+
+#include "lobject.h"
+#include "lzio.h"
+
+/* load one chunk; from lundump.c */
+LUAI_FUNC Closure* luaU_undump (lua_State* L, ZIO* Z, Mbuffer* buff, const char* name);
+
+/* make header; from lundump.c */
+LUAI_FUNC void luaU_header (lu_byte* h);
+
+/* dump one chunk; from ldump.c */
+LUAI_FUNC int luaU_dump (lua_State* L, const Proto* f, lua_Writer w, void* data, int strip);
+
+/* data to catch conversion errors */
+#define LUAC_TAIL		"\x19\x93\r\n\x1a\n"
+
+/* size in bytes of header of binary files */
+#define LUAC_HEADERSIZE		(sizeof(LUA_SIGNATURE)-sizeof(char)+2+6+sizeof(LUAC_TAIL)-sizeof(char))
+
+#endif
diff -ruNp src.hd/libs/lua/lvm.c src/libs/lua/lvm.c
--- src.hd/libs/lua/lvm.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lvm.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,867 @@
+/*
+** $Id: lvm.c,v 2.155 2013/03/16 21:10:18 roberto Exp $
+** Lua virtual machine
+** See Copyright Notice in lua.h
+*/
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define lvm_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "ldebug.h"
+#include "ldo.h"
+#include "lfunc.h"
+#include "lgc.h"
+#include "lobject.h"
+#include "lopcodes.h"
+#include "lstate.h"
+#include "lstring.h"
+#include "ltable.h"
+#include "ltm.h"
+#include "lvm.h"
+
+
+
+/* limit for table tag-method chains (to avoid loops) */
+#define MAXTAGLOOP	100
+
+
+const TValue *luaV_tonumber (const TValue *obj, TValue *n) {
+  lua_Number num;
+  if (ttisnumber(obj)) return obj;
+  if (ttisstring(obj) && luaO_str2d(svalue(obj), tsvalue(obj)->len, &num)) {
+    setnvalue(n, num);
+    return n;
+  }
+  else
+    return NULL;
+}
+
+
+int luaV_tostring (lua_State *L, StkId obj) {
+  if (!ttisnumber(obj))
+    return 0;
+  else {
+    char s[LUAI_MAXNUMBER2STR];
+    lua_Number n = nvalue(obj);
+    int l = lua_number2str(s, n);
+    setsvalue2s(L, obj, luaS_newlstr(L, s, l));
+    return 1;
+  }
+}
+
+
+static void traceexec (lua_State *L) {
+  CallInfo *ci = L->ci;
+  lu_byte mask = L->hookmask;
+  int counthook = ((mask & LUA_MASKCOUNT) && L->hookcount == 0);
+  if (counthook)
+    resethookcount(L);  /* reset count */
+  if (ci->callstatus & CIST_HOOKYIELD) {  /* called hook last time? */
+    ci->callstatus &= ~CIST_HOOKYIELD;  /* erase mark */
+    return;  /* do not call hook again (VM yielded, so it did not move) */
+  }
+  if (counthook)
+    luaD_hook(L, LUA_HOOKCOUNT, -1);  /* call count hook */
+  if (mask & LUA_MASKLINE) {
+    Proto *p = ci_func(ci)->p;
+    int npc = pcRel(ci->u.l.savedpc, p);
+    int newline = getfuncline(p, npc);
+    if (npc == 0 ||  /* call linehook when enter a new function, */
+        ci->u.l.savedpc <= L->oldpc ||  /* when jump back (loop), or when */
+        newline != getfuncline(p, pcRel(L->oldpc, p)))  /* enter a new line */
+      luaD_hook(L, LUA_HOOKLINE, newline);  /* call line hook */
+  }
+  L->oldpc = ci->u.l.savedpc;
+  if (L->status == LUA_YIELD) {  /* did hook yield? */
+    if (counthook)
+      L->hookcount = 1;  /* undo decrement to zero */
+    ci->u.l.savedpc--;  /* undo increment (resume will increment it again) */
+    ci->callstatus |= CIST_HOOKYIELD;  /* mark that it yielded */
+    ci->func = L->top - 1;  /* protect stack below results */
+    luaD_throw(L, LUA_YIELD);
+  }
+}
+
+
+static void callTM (lua_State *L, const TValue *f, const TValue *p1,
+                    const TValue *p2, TValue *p3, int hasres) {
+  ptrdiff_t result = savestack(L, p3);
+  setobj2s(L, L->top++, f);  /* push function */
+  setobj2s(L, L->top++, p1);  /* 1st argument */
+  setobj2s(L, L->top++, p2);  /* 2nd argument */
+  if (!hasres)  /* no result? 'p3' is third argument */
+    setobj2s(L, L->top++, p3);  /* 3rd argument */
+  /* metamethod may yield only when called from Lua code */
+  luaD_call(L, L->top - (4 - hasres), hasres, isLua(L->ci));
+  if (hasres) {  /* if has result, move it to its place */
+    p3 = restorestack(L, result);
+    setobjs2s(L, p3, --L->top);
+  }
+}
+
+
+void luaV_gettable (lua_State *L, const TValue *t, TValue *key, StkId val) {
+  int loop;
+  for (loop = 0; loop < MAXTAGLOOP; loop++) {
+    const TValue *tm;
+    if (ttistable(t)) {  /* `t' is a table? */
+      Table *h = hvalue(t);
+      const TValue *res = luaH_get(h, key); /* do a primitive get */
+      if (!ttisnil(res) ||  /* result is not nil? */
+          (tm = fasttm(L, h->metatable, TM_INDEX)) == NULL) { /* or no TM? */
+        setobj2s(L, val, res);
+        return;
+      }
+      /* else will try the tag method */
+    }
+    else if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_INDEX)))
+      luaG_typeerror(L, t, "index");
+    if (ttisfunction(tm)) {
+      callTM(L, tm, t, key, val, 1);
+      return;
+    }
+    t = tm;  /* else repeat with 'tm' */
+  }
+  luaG_runerror(L, "loop in gettable");
+}
+
+
+void luaV_settable (lua_State *L, const TValue *t, TValue *key, StkId val) {
+  int loop;
+  for (loop = 0; loop < MAXTAGLOOP; loop++) {
+    const TValue *tm;
+    if (ttistable(t)) {  /* `t' is a table? */
+      Table *h = hvalue(t);
+      TValue *oldval = cast(TValue *, luaH_get(h, key));
+      /* if previous value is not nil, there must be a previous entry
+         in the table; moreover, a metamethod has no relevance */
+      if (!ttisnil(oldval) ||
+         /* previous value is nil; must check the metamethod */
+         ((tm = fasttm(L, h->metatable, TM_NEWINDEX)) == NULL &&
+         /* no metamethod; is there a previous entry in the table? */
+         (oldval != luaO_nilobject ||
+         /* no previous entry; must create one. (The next test is
+            always true; we only need the assignment.) */
+         (oldval = luaH_newkey(L, h, key), 1)))) {
+        /* no metamethod and (now) there is an entry with given key */
+        setobj2t(L, oldval, val);  /* assign new value to that entry */
+        invalidateTMcache(h);
+        luaC_barrierback(L, obj2gco(h), val);
+        return;
+      }
+      /* else will try the metamethod */
+    }
+    else  /* not a table; check metamethod */
+      if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_NEWINDEX)))
+        luaG_typeerror(L, t, "index");
+    /* there is a metamethod */
+    if (ttisfunction(tm)) {
+      callTM(L, tm, t, key, val, 0);
+      return;
+    }
+    t = tm;  /* else repeat with 'tm' */
+  }
+  luaG_runerror(L, "loop in settable");
+}
+
+
+static int call_binTM (lua_State *L, const TValue *p1, const TValue *p2,
+                       StkId res, TMS event) {
+  const TValue *tm = luaT_gettmbyobj(L, p1, event);  /* try first operand */
+  if (ttisnil(tm))
+    tm = luaT_gettmbyobj(L, p2, event);  /* try second operand */
+  if (ttisnil(tm)) return 0;
+  callTM(L, tm, p1, p2, res, 1);
+  return 1;
+}
+
+
+static const TValue *get_equalTM (lua_State *L, Table *mt1, Table *mt2,
+                                  TMS event) {
+  const TValue *tm1 = fasttm(L, mt1, event);
+  const TValue *tm2;
+  if (tm1 == NULL) return NULL;  /* no metamethod */
+  if (mt1 == mt2) return tm1;  /* same metatables => same metamethods */
+  tm2 = fasttm(L, mt2, event);
+  if (tm2 == NULL) return NULL;  /* no metamethod */
+  if (luaV_rawequalobj(tm1, tm2))  /* same metamethods? */
+    return tm1;
+  return NULL;
+}
+
+
+static int call_orderTM (lua_State *L, const TValue *p1, const TValue *p2,
+                         TMS event) {
+  if (!call_binTM(L, p1, p2, L->top, event))
+    return -1;  /* no metamethod */
+  else
+    return !l_isfalse(L->top);
+}
+
+
+static int l_strcmp (const TString *ls, const TString *rs) {
+  const char *l = getstr(ls);
+  size_t ll = ls->tsv.len;
+  const char *r = getstr(rs);
+  size_t lr = rs->tsv.len;
+  for (;;) {
+    int temp = strcoll(l, r);
+    if (temp != 0) return temp;
+    else {  /* strings are equal up to a `\0' */
+      size_t len = strlen(l);  /* index of first `\0' in both strings */
+      if (len == lr)  /* r is finished? */
+        return (len == ll) ? 0 : 1;
+      else if (len == ll)  /* l is finished? */
+        return -1;  /* l is smaller than r (because r is not finished) */
+      /* both strings longer than `len'; go on comparing (after the `\0') */
+      len++;
+      l += len; ll -= len; r += len; lr -= len;
+    }
+  }
+}
+
+
+int luaV_lessthan (lua_State *L, const TValue *l, const TValue *r) {
+  int res;
+  if (ttisnumber(l) && ttisnumber(r))
+    return luai_numlt(L, nvalue(l), nvalue(r));
+  else if (ttisstring(l) && ttisstring(r))
+    return l_strcmp(rawtsvalue(l), rawtsvalue(r)) < 0;
+  else if ((res = call_orderTM(L, l, r, TM_LT)) < 0)
+    luaG_ordererror(L, l, r);
+  return res;
+}
+
+
+int luaV_lessequal (lua_State *L, const TValue *l, const TValue *r) {
+  int res;
+  if (ttisnumber(l) && ttisnumber(r))
+    return luai_numle(L, nvalue(l), nvalue(r));
+  else if (ttisstring(l) && ttisstring(r))
+    return l_strcmp(rawtsvalue(l), rawtsvalue(r)) <= 0;
+  else if ((res = call_orderTM(L, l, r, TM_LE)) >= 0)  /* first try `le' */
+    return res;
+  else if ((res = call_orderTM(L, r, l, TM_LT)) < 0)  /* else try `lt' */
+    luaG_ordererror(L, l, r);
+  return !res;
+}
+
+
+/*
+** equality of Lua values. L == NULL means raw equality (no metamethods)
+*/
+int luaV_equalobj_ (lua_State *L, const TValue *t1, const TValue *t2) {
+  const TValue *tm;
+  lua_assert(ttisequal(t1, t2));
+  switch (ttype(t1)) {
+    case LUA_TNIL: return 1;
+    case LUA_TNUMBER: return luai_numeq(nvalue(t1), nvalue(t2));
+    case LUA_TBOOLEAN: return bvalue(t1) == bvalue(t2);  /* true must be 1 !! */
+    case LUA_TLIGHTUSERDATA: return pvalue(t1) == pvalue(t2);
+    case LUA_TLCF: return fvalue(t1) == fvalue(t2);
+    case LUA_TSHRSTR: return eqshrstr(rawtsvalue(t1), rawtsvalue(t2));
+    case LUA_TLNGSTR: return luaS_eqlngstr(rawtsvalue(t1), rawtsvalue(t2));
+    case LUA_TUSERDATA: {
+      if (uvalue(t1) == uvalue(t2)) return 1;
+      else if (L == NULL) return 0;
+      tm = get_equalTM(L, uvalue(t1)->metatable, uvalue(t2)->metatable, TM_EQ);
+      break;  /* will try TM */
+    }
+    case LUA_TTABLE: {
+      if (hvalue(t1) == hvalue(t2)) return 1;
+      else if (L == NULL) return 0;
+      tm = get_equalTM(L, hvalue(t1)->metatable, hvalue(t2)->metatable, TM_EQ);
+      break;  /* will try TM */
+    }
+    default:
+      lua_assert(iscollectable(t1));
+      return gcvalue(t1) == gcvalue(t2);
+  }
+  if (tm == NULL) return 0;  /* no TM? */
+  callTM(L, tm, t1, t2, L->top, 1);  /* call TM */
+  return !l_isfalse(L->top);
+}
+
+
+void luaV_concat (lua_State *L, int total) {
+  lua_assert(total >= 2);
+  do {
+    StkId top = L->top;
+    int n = 2;  /* number of elements handled in this pass (at least 2) */
+    if (!(ttisstring(top-2) || ttisnumber(top-2)) || !tostring(L, top-1)) {
+      if (!call_binTM(L, top-2, top-1, top-2, TM_CONCAT))
+        luaG_concaterror(L, top-2, top-1);
+    }
+    else if (tsvalue(top-1)->len == 0)  /* second operand is empty? */
+      (void)tostring(L, top - 2);  /* result is first operand */
+    else if (ttisstring(top-2) && tsvalue(top-2)->len == 0) {
+      setobjs2s(L, top - 2, top - 1);  /* result is second op. */
+    }
+    else {
+      /* at least two non-empty string values; get as many as possible */
+      size_t tl = tsvalue(top-1)->len;
+      char *buffer;
+      int i;
+      /* collect total length */
+      for (i = 1; i < total && tostring(L, top-i-1); i++) {
+        size_t l = tsvalue(top-i-1)->len;
+        if (l >= (MAX_SIZET/sizeof(char)) - tl)
+          luaG_runerror(L, "string length overflow");
+        tl += l;
+      }
+      buffer = luaZ_openspace(L, &G(L)->buff, tl);
+      tl = 0;
+      n = i;
+      do {  /* concat all strings */
+        size_t l = tsvalue(top-i)->len;
+        memcpy(buffer+tl, svalue(top-i), l * sizeof(char));
+        tl += l;
+      } while (--i > 0);
+      setsvalue2s(L, top-n, luaS_newlstr(L, buffer, tl));
+    }
+    total -= n-1;  /* got 'n' strings to create 1 new */
+    L->top -= n-1;  /* popped 'n' strings and pushed one */
+  } while (total > 1);  /* repeat until only 1 result left */
+}
+
+
+void luaV_objlen (lua_State *L, StkId ra, const TValue *rb) {
+  const TValue *tm;
+  switch (ttypenv(rb)) {
+    case LUA_TTABLE: {
+      Table *h = hvalue(rb);
+      tm = fasttm(L, h->metatable, TM_LEN);
+      if (tm) break;  /* metamethod? break switch to call it */
+      setnvalue(ra, cast_num(luaH_getn(h)));  /* else primitive len */
+      return;
+    }
+    case LUA_TSTRING: {
+      setnvalue(ra, cast_num(tsvalue(rb)->len));
+      return;
+    }
+    default: {  /* try metamethod */
+      tm = luaT_gettmbyobj(L, rb, TM_LEN);
+      if (ttisnil(tm))  /* no metamethod? */
+        luaG_typeerror(L, rb, "get length of");
+      break;
+    }
+  }
+  callTM(L, tm, rb, rb, ra, 1);
+}
+
+
+void luaV_arith (lua_State *L, StkId ra, const TValue *rb,
+                 const TValue *rc, TMS op) {
+  TValue tempb, tempc;
+  const TValue *b, *c;
+  if ((b = luaV_tonumber(rb, &tempb)) != NULL &&
+      (c = luaV_tonumber(rc, &tempc)) != NULL) {
+    lua_Number res = luaO_arith(op - TM_ADD + LUA_OPADD, nvalue(b), nvalue(c));
+    setnvalue(ra, res);
+  }
+  else if (!call_binTM(L, rb, rc, ra, op))
+    luaG_aritherror(L, rb, rc);
+}
+
+
+/*
+** check whether cached closure in prototype 'p' may be reused, that is,
+** whether there is a cached closure with the same upvalues needed by
+** new closure to be created.
+*/
+static Closure *getcached (Proto *p, UpVal **encup, StkId base) {
+  Closure *c = p->cache;
+  if (c != NULL) {  /* is there a cached closure? */
+    int nup = p->sizeupvalues;
+    Upvaldesc *uv = p->upvalues;
+    int i;
+    for (i = 0; i < nup; i++) {  /* check whether it has right upvalues */
+      TValue *v = uv[i].instack ? base + uv[i].idx : encup[uv[i].idx]->v;
+      if (c->l.upvals[i]->v != v)
+        return NULL;  /* wrong upvalue; cannot reuse closure */
+    }
+  }
+  return c;  /* return cached closure (or NULL if no cached closure) */
+}
+
+
+/*
+** create a new Lua closure, push it in the stack, and initialize
+** its upvalues. Note that the call to 'luaC_barrierproto' must come
+** before the assignment to 'p->cache', as the function needs the
+** original value of that field.
+*/
+static void pushclosure (lua_State *L, Proto *p, UpVal **encup, StkId base,
+                         StkId ra) {
+  int nup = p->sizeupvalues;
+  Upvaldesc *uv = p->upvalues;
+  int i;
+  Closure *ncl = luaF_newLclosure(L, nup);
+  ncl->l.p = p;
+  setclLvalue(L, ra, ncl);  /* anchor new closure in stack */
+  for (i = 0; i < nup; i++) {  /* fill in its upvalues */
+    if (uv[i].instack)  /* upvalue refers to local variable? */
+      ncl->l.upvals[i] = luaF_findupval(L, base + uv[i].idx);
+    else  /* get upvalue from enclosing function */
+      ncl->l.upvals[i] = encup[uv[i].idx];
+  }
+  luaC_barrierproto(L, p, ncl);
+  p->cache = ncl;  /* save it on cache for reuse */
+}
+
+
+/*
+** finish execution of an opcode interrupted by an yield
+*/
+void luaV_finishOp (lua_State *L) {
+  CallInfo *ci = L->ci;
+  StkId base = ci->u.l.base;
+  Instruction inst = *(ci->u.l.savedpc - 1);  /* interrupted instruction */
+  OpCode op = GET_OPCODE(inst);
+  switch (op) {  /* finish its execution */
+    case OP_ADD: case OP_SUB: case OP_MUL: case OP_DIV:
+    case OP_MOD: case OP_POW: case OP_UNM: case OP_LEN:
+    case OP_GETTABUP: case OP_GETTABLE: case OP_SELF: {
+      setobjs2s(L, base + GETARG_A(inst), --L->top);
+      break;
+    }
+    case OP_LE: case OP_LT: case OP_EQ: {
+      int res = !l_isfalse(L->top - 1);
+      L->top--;
+      /* metamethod should not be called when operand is K */
+      lua_assert(!ISK(GETARG_B(inst)));
+      if (op == OP_LE &&  /* "<=" using "<" instead? */
+          ttisnil(luaT_gettmbyobj(L, base + GETARG_B(inst), TM_LE)))
+        res = !res;  /* invert result */
+      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_JMP);
+      if (res != GETARG_A(inst))  /* condition failed? */
+        ci->u.l.savedpc++;  /* skip jump instruction */
+      break;
+    }
+    case OP_CONCAT: {
+      StkId top = L->top - 1;  /* top when 'call_binTM' was called */
+      int b = GETARG_B(inst);      /* first element to concatenate */
+      int total = cast_int(top - 1 - (base + b));  /* yet to concatenate */
+      setobj2s(L, top - 2, top);  /* put TM result in proper position */
+      if (total > 1) {  /* are there elements to concat? */
+        L->top = top - 1;  /* top is one after last element (at top-2) */
+        luaV_concat(L, total);  /* concat them (may yield again) */
+      }
+      /* move final result to final position */
+      setobj2s(L, ci->u.l.base + GETARG_A(inst), L->top - 1);
+      L->top = ci->top;  /* restore top */
+      break;
+    }
+    case OP_TFORCALL: {
+      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_TFORLOOP);
+      L->top = ci->top;  /* correct top */
+      break;
+    }
+    case OP_CALL: {
+      if (GETARG_C(inst) - 1 >= 0)  /* nresults >= 0? */
+        L->top = ci->top;  /* adjust results */
+      break;
+    }
+    case OP_TAILCALL: case OP_SETTABUP: case OP_SETTABLE:
+      break;
+    default: lua_assert(0);
+  }
+}
+
+
+
+/*
+** some macros for common tasks in `luaV_execute'
+*/
+
+#if !defined luai_runtimecheck
+#define luai_runtimecheck(L, c)		/* void */
+#endif
+
+
+#define RA(i)	(base+GETARG_A(i))
+/* to be used after possible stack reallocation */
+#define RB(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i))
+#define RC(i)	check_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i))
+#define RKB(i)	check_exp(getBMode(GET_OPCODE(i)) == OpArgK, \
+	ISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i))
+#define RKC(i)	check_exp(getCMode(GET_OPCODE(i)) == OpArgK, \
+	ISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i))
+#define KBx(i)  \
+  (k + (GETARG_Bx(i) != 0 ? GETARG_Bx(i) - 1 : GETARG_Ax(*ci->u.l.savedpc++)))
+
+
+/* execute a jump instruction */
+#define dojump(ci,i,e) \
+  { int a = GETARG_A(i); \
+    if (a > 0) luaF_close(L, ci->u.l.base + a - 1); \
+    ci->u.l.savedpc += GETARG_sBx(i) + e; }
+
+/* for test instructions, execute the jump instruction that follows it */
+#define donextjump(ci)	{ i = *ci->u.l.savedpc; dojump(ci, i, 1); }
+
+
+#define Protect(x)	{ {x;}; base = ci->u.l.base; }
+
+#define checkGC(L,c)  \
+  Protect( luaC_condGC(L,{L->top = (c);  /* limit of live values */ \
+                          luaC_step(L); \
+                          L->top = ci->top;})  /* restore top */ \
+           luai_threadyield(L); )
+
+
+#define arith_op(op,tm) { \
+        TValue *rb = RKB(i); \
+        TValue *rc = RKC(i); \
+        if (ttisnumber(rb) && ttisnumber(rc)) { \
+          lua_Number nb = nvalue(rb), nc = nvalue(rc); \
+          setnvalue(ra, op(L, nb, nc)); \
+        } \
+        else { Protect(luaV_arith(L, ra, rb, rc, tm)); } }
+
+
+#define vmdispatch(o)	switch(o)
+#define vmcase(l,b)	case l: {b}  break;
+#define vmcasenb(l,b)	case l: {b}		/* nb = no break */
+
+void luaV_execute (lua_State *L) {
+  CallInfo *ci = L->ci;
+  LClosure *cl;
+  TValue *k;
+  StkId base;
+ newframe:  /* reentry point when frame changes (call/return) */
+  lua_assert(ci == L->ci);
+  cl = clLvalue(ci->func);
+  k = cl->p->k;
+  base = ci->u.l.base;
+  /* main loop of interpreter */
+  for (;;) {
+    Instruction i = *(ci->u.l.savedpc++);
+    StkId ra;
+    if ((L->hookmask & (LUA_MASKLINE | LUA_MASKCOUNT)) &&
+        (--L->hookcount == 0 || L->hookmask & LUA_MASKLINE)) {
+      Protect(traceexec(L));
+    }
+    /* WARNING: several calls may realloc the stack and invalidate `ra' */
+    ra = RA(i);
+    lua_assert(base == ci->u.l.base);
+    lua_assert(base <= L->top && L->top < L->stack + L->stacksize);
+    vmdispatch (GET_OPCODE(i)) {
+      vmcase(OP_MOVE,
+        setobjs2s(L, ra, RB(i));
+      )
+      vmcase(OP_LOADK,
+        TValue *rb = k + GETARG_Bx(i);
+        setobj2s(L, ra, rb);
+      )
+      vmcase(OP_LOADKX,
+        TValue *rb;
+        lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
+        rb = k + GETARG_Ax(*ci->u.l.savedpc++);
+        setobj2s(L, ra, rb);
+      )
+      vmcase(OP_LOADBOOL,
+        setbvalue(ra, GETARG_B(i));
+        if (GETARG_C(i)) ci->u.l.savedpc++;  /* skip next instruction (if C) */
+      )
+      vmcase(OP_LOADNIL,
+        int b = GETARG_B(i);
+        do {
+          setnilvalue(ra++);
+        } while (b--);
+      )
+      vmcase(OP_GETUPVAL,
+        int b = GETARG_B(i);
+        setobj2s(L, ra, cl->upvals[b]->v);
+      )
+      vmcase(OP_GETTABUP,
+        int b = GETARG_B(i);
+        Protect(luaV_gettable(L, cl->upvals[b]->v, RKC(i), ra));
+      )
+      vmcase(OP_GETTABLE,
+        Protect(luaV_gettable(L, RB(i), RKC(i), ra));
+      )
+      vmcase(OP_SETTABUP,
+        int a = GETARG_A(i);
+        Protect(luaV_settable(L, cl->upvals[a]->v, RKB(i), RKC(i)));
+      )
+      vmcase(OP_SETUPVAL,
+        UpVal *uv = cl->upvals[GETARG_B(i)];
+        setobj(L, uv->v, ra);
+        luaC_barrier(L, uv, ra);
+      )
+      vmcase(OP_SETTABLE,
+        Protect(luaV_settable(L, ra, RKB(i), RKC(i)));
+      )
+      vmcase(OP_NEWTABLE,
+        int b = GETARG_B(i);
+        int c = GETARG_C(i);
+        Table *t = luaH_new(L);
+        sethvalue(L, ra, t);
+        if (b != 0 || c != 0)
+          luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));
+        checkGC(L, ra + 1);
+      )
+      vmcase(OP_SELF,
+        StkId rb = RB(i);
+        setobjs2s(L, ra+1, rb);
+        Protect(luaV_gettable(L, rb, RKC(i), ra));
+      )
+      vmcase(OP_ADD,
+        arith_op(luai_numadd, TM_ADD);
+      )
+      vmcase(OP_SUB,
+        arith_op(luai_numsub, TM_SUB);
+      )
+      vmcase(OP_MUL,
+        arith_op(luai_nummul, TM_MUL);
+      )
+      vmcase(OP_DIV,
+        arith_op(luai_numdiv, TM_DIV);
+      )
+      vmcase(OP_MOD,
+        arith_op(luai_nummod, TM_MOD);
+      )
+      vmcase(OP_POW,
+        arith_op(luai_numpow, TM_POW);
+      )
+      vmcase(OP_UNM,
+        TValue *rb = RB(i);
+        if (ttisnumber(rb)) {
+          lua_Number nb = nvalue(rb);
+          setnvalue(ra, luai_numunm(L, nb));
+        }
+        else {
+          Protect(luaV_arith(L, ra, rb, rb, TM_UNM));
+        }
+      )
+      vmcase(OP_NOT,
+        TValue *rb = RB(i);
+        int res = l_isfalse(rb);  /* next assignment may change this value */
+        setbvalue(ra, res);
+      )
+      vmcase(OP_LEN,
+        Protect(luaV_objlen(L, ra, RB(i)));
+      )
+      vmcase(OP_CONCAT,
+        int b = GETARG_B(i);
+        int c = GETARG_C(i);
+        StkId rb;
+        L->top = base + c + 1;  /* mark the end of concat operands */
+        Protect(luaV_concat(L, c - b + 1));
+        ra = RA(i);  /* 'luav_concat' may invoke TMs and move the stack */
+        rb = b + base;
+        setobjs2s(L, ra, rb);
+        checkGC(L, (ra >= rb ? ra + 1 : rb));
+        L->top = ci->top;  /* restore top */
+      )
+      vmcase(OP_JMP,
+        dojump(ci, i, 0);
+      )
+      vmcase(OP_EQ,
+        TValue *rb = RKB(i);
+        TValue *rc = RKC(i);
+        Protect(
+          if (cast_int(equalobj(L, rb, rc)) != GETARG_A(i))
+            ci->u.l.savedpc++;
+          else
+            donextjump(ci);
+        )
+      )
+      vmcase(OP_LT,
+        Protect(
+          if (luaV_lessthan(L, RKB(i), RKC(i)) != GETARG_A(i))
+            ci->u.l.savedpc++;
+          else
+            donextjump(ci);
+        )
+      )
+      vmcase(OP_LE,
+        Protect(
+          if (luaV_lessequal(L, RKB(i), RKC(i)) != GETARG_A(i))
+            ci->u.l.savedpc++;
+          else
+            donextjump(ci);
+        )
+      )
+      vmcase(OP_TEST,
+        if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra))
+            ci->u.l.savedpc++;
+          else
+          donextjump(ci);
+      )
+      vmcase(OP_TESTSET,
+        TValue *rb = RB(i);
+        if (GETARG_C(i) ? l_isfalse(rb) : !l_isfalse(rb))
+          ci->u.l.savedpc++;
+        else {
+          setobjs2s(L, ra, rb);
+          donextjump(ci);
+        }
+      )
+      vmcase(OP_CALL,
+        int b = GETARG_B(i);
+        int nresults = GETARG_C(i) - 1;
+        if (b != 0) L->top = ra+b;  /* else previous instruction set top */
+        if (luaD_precall(L, ra, nresults)) {  /* C function? */
+          if (nresults >= 0) L->top = ci->top;  /* adjust results */
+          base = ci->u.l.base;
+        }
+        else {  /* Lua function */
+          ci = L->ci;
+          ci->callstatus |= CIST_REENTRY;
+          goto newframe;  /* restart luaV_execute over new Lua function */
+        }
+      )
+      vmcase(OP_TAILCALL,
+        int b = GETARG_B(i);
+        if (b != 0) L->top = ra+b;  /* else previous instruction set top */
+        lua_assert(GETARG_C(i) - 1 == LUA_MULTRET);
+        if (luaD_precall(L, ra, LUA_MULTRET))  /* C function? */
+          base = ci->u.l.base;
+        else {
+          /* tail call: put called frame (n) in place of caller one (o) */
+          CallInfo *nci = L->ci;  /* called frame */
+          CallInfo *oci = nci->previous;  /* caller frame */
+          StkId nfunc = nci->func;  /* called function */
+          StkId ofunc = oci->func;  /* caller function */
+          /* last stack slot filled by 'precall' */
+          StkId lim = nci->u.l.base + getproto(nfunc)->numparams;
+          int aux;
+          /* close all upvalues from previous call */
+          if (cl->p->sizep > 0) luaF_close(L, oci->u.l.base);
+          /* move new frame into old one */
+          for (aux = 0; nfunc + aux < lim; aux++)
+            setobjs2s(L, ofunc + aux, nfunc + aux);
+          oci->u.l.base = ofunc + (nci->u.l.base - nfunc);  /* correct base */
+          oci->top = L->top = ofunc + (L->top - nfunc);  /* correct top */
+          oci->u.l.savedpc = nci->u.l.savedpc;
+          oci->callstatus |= CIST_TAIL;  /* function was tail called */
+          ci = L->ci = oci;  /* remove new frame */
+          lua_assert(L->top == oci->u.l.base + getproto(ofunc)->maxstacksize);
+          goto newframe;  /* restart luaV_execute over new Lua function */
+        }
+      )
+      vmcasenb(OP_RETURN,
+        int b = GETARG_B(i);
+        if (b != 0) L->top = ra+b-1;
+        if (cl->p->sizep > 0) luaF_close(L, base);
+        b = luaD_poscall(L, ra);
+        if (!(ci->callstatus & CIST_REENTRY))  /* 'ci' still the called one */
+          return;  /* external invocation: return */
+        else {  /* invocation via reentry: continue execution */
+          ci = L->ci;
+          if (b) L->top = ci->top;
+          lua_assert(isLua(ci));
+          lua_assert(GET_OPCODE(*((ci)->u.l.savedpc - 1)) == OP_CALL);
+          goto newframe;  /* restart luaV_execute over new Lua function */
+        }
+      )
+      vmcase(OP_FORLOOP,
+        lua_Number step = nvalue(ra+2);
+        lua_Number idx = luai_numadd(L, nvalue(ra), step); /* increment index */
+        lua_Number limit = nvalue(ra+1);
+        if (luai_numlt(L, 0, step) ? luai_numle(L, idx, limit)
+                                   : luai_numle(L, limit, idx)) {
+          ci->u.l.savedpc += GETARG_sBx(i);  /* jump back */
+          setnvalue(ra, idx);  /* update internal index... */
+          setnvalue(ra+3, idx);  /* ...and external index */
+        }
+      )
+      vmcase(OP_FORPREP,
+        const TValue *init = ra;
+        const TValue *plimit = ra+1;
+        const TValue *pstep = ra+2;
+        if (!tonumber(init, ra))
+          luaG_runerror(L, LUA_QL("for") " initial value must be a number");
+        else if (!tonumber(plimit, ra+1))
+          luaG_runerror(L, LUA_QL("for") " limit must be a number");
+        else if (!tonumber(pstep, ra+2))
+          luaG_runerror(L, LUA_QL("for") " step must be a number");
+        setnvalue(ra, luai_numsub(L, nvalue(ra), nvalue(pstep)));
+        ci->u.l.savedpc += GETARG_sBx(i);
+      )
+      vmcasenb(OP_TFORCALL,
+        StkId cb = ra + 3;  /* call base */
+        setobjs2s(L, cb+2, ra+2);
+        setobjs2s(L, cb+1, ra+1);
+        setobjs2s(L, cb, ra);
+        L->top = cb + 3;  /* func. + 2 args (state and index) */
+        Protect(luaD_call(L, cb, GETARG_C(i), 1));
+        L->top = ci->top;
+        i = *(ci->u.l.savedpc++);  /* go to next instruction */
+        ra = RA(i);
+        lua_assert(GET_OPCODE(i) == OP_TFORLOOP);
+        goto l_tforloop;
+      )
+      vmcase(OP_TFORLOOP,
+        l_tforloop:
+        if (!ttisnil(ra + 1)) {  /* continue loop? */
+          setobjs2s(L, ra, ra + 1);  /* save control variable */
+           ci->u.l.savedpc += GETARG_sBx(i);  /* jump back */
+        }
+      )
+      vmcase(OP_SETLIST,
+        int n = GETARG_B(i);
+        int c = GETARG_C(i);
+        int last;
+        Table *h;
+        if (n == 0) n = cast_int(L->top - ra) - 1;
+        if (c == 0) {
+          lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);
+          c = GETARG_Ax(*ci->u.l.savedpc++);
+        }
+        luai_runtimecheck(L, ttistable(ra));
+        h = hvalue(ra);
+        last = ((c-1)*LFIELDS_PER_FLUSH) + n;
+        if (last > h->sizearray)  /* needs more space? */
+          luaH_resizearray(L, h, last);  /* pre-allocate it at once */
+        for (; n > 0; n--) {
+          TValue *val = ra+n;
+          luaH_setint(L, h, last--, val);
+          luaC_barrierback(L, obj2gco(h), val);
+        }
+        L->top = ci->top;  /* correct top (in case of previous open call) */
+      )
+      vmcase(OP_CLOSURE,
+        Proto *p = cl->p->p[GETARG_Bx(i)];
+        Closure *ncl = getcached(p, cl->upvals, base);  /* cached closure */
+        if (ncl == NULL)  /* no match? */
+          pushclosure(L, p, cl->upvals, base, ra);  /* create a new one */
+        else
+          setclLvalue(L, ra, ncl);  /* push cashed closure */
+        checkGC(L, ra + 1);
+      )
+      vmcase(OP_VARARG,
+        int b = GETARG_B(i) - 1;
+        int j;
+        int n = cast_int(base - ci->func) - cl->p->numparams - 1;
+        if (b < 0) {  /* B == 0? */
+          b = n;  /* get all var. arguments */
+          Protect(luaD_checkstack(L, n));
+          ra = RA(i);  /* previous call may change the stack */
+          L->top = ra + n;
+        }
+        for (j = 0; j < b; j++) {
+          if (j < n) {
+            setobjs2s(L, ra + j, base - n + j);
+          }
+          else {
+            setnilvalue(ra + j);
+          }
+        }
+      )
+      vmcase(OP_EXTRAARG,
+        lua_assert(0);
+      )
+    }
+  }
+}
+
diff -ruNp src.hd/libs/lua/lvm.h src/libs/lua/lvm.h
--- src.hd/libs/lua/lvm.h	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lvm.h	2017-12-29 00:57:40 -0800
@@ -0,0 +1,44 @@
+/*
+** $Id: lvm.h,v 2.18 2013/01/08 14:06:55 roberto Exp $
+** Lua virtual machine
+** See Copyright Notice in lua.h
+*/
+
+#ifndef lvm_h
+#define lvm_h
+
+
+#include "ldo.h"
+#include "lobject.h"
+#include "ltm.h"
+
+
+#define tostring(L,o) (ttisstring(o) || (luaV_tostring(L, o)))
+
+#define tonumber(o,n)	(ttisnumber(o) || (((o) = luaV_tonumber(o,n)) != NULL))
+
+#define equalobj(L,o1,o2)  (ttisequal(o1, o2) && luaV_equalobj_(L, o1, o2))
+
+#define luaV_rawequalobj(o1,o2)		equalobj(NULL,o1,o2)
+
+
+/* not to called directly */
+LUAI_FUNC int luaV_equalobj_ (lua_State *L, const TValue *t1, const TValue *t2);
+
+
+LUAI_FUNC int luaV_lessthan (lua_State *L, const TValue *l, const TValue *r);
+LUAI_FUNC int luaV_lessequal (lua_State *L, const TValue *l, const TValue *r);
+LUAI_FUNC const TValue *luaV_tonumber (const TValue *obj, TValue *n);
+LUAI_FUNC int luaV_tostring (lua_State *L, StkId obj);
+LUAI_FUNC void luaV_gettable (lua_State *L, const TValue *t, TValue *key,
+                                            StkId val);
+LUAI_FUNC void luaV_settable (lua_State *L, const TValue *t, TValue *key,
+                                            StkId val);
+LUAI_FUNC void luaV_finishOp (lua_State *L);
+LUAI_FUNC void luaV_execute (lua_State *L);
+LUAI_FUNC void luaV_concat (lua_State *L, int total);
+LUAI_FUNC void luaV_arith (lua_State *L, StkId ra, const TValue *rb,
+                           const TValue *rc, TMS op);
+LUAI_FUNC void luaV_objlen (lua_State *L, StkId ra, const TValue *rb);
+
+#endif
diff -ruNp src.hd/libs/lua/lzio.c src/libs/lua/lzio.c
--- src.hd/libs/lua/lzio.c	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lzio.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,76 @@
+/*
+** $Id: lzio.c,v 1.35 2012/05/14 13:34:18 roberto Exp $
+** Buffered streams
+** See Copyright Notice in lua.h
+*/
+
+
+#include <string.h>
+
+#define lzio_c
+#define LUA_CORE
+
+#include "lua.h"
+
+#include "llimits.h"
+#include "lmem.h"
+#include "lstate.h"
+#include "lzio.h"
+
+
+int luaZ_fill (ZIO *z) {
+  size_t size;
+  lua_State *L = z->L;
+  const char *buff;
+  lua_unlock(L);
+  buff = z->reader(L, z->data, &size);
+  lua_lock(L);
+  if (buff == NULL || size == 0)
+    return EOZ;
+  z->n = size - 1;  /* discount char being returned */
+  z->p = buff;
+  return cast_uchar(*(z->p++));
+}
+
+
+void luaZ_init (lua_State *L, ZIO *z, lua_Reader reader, void *data) {
+  z->L = L;
+  z->reader = reader;
+  z->data = data;
+  z->n = 0;
+  z->p = NULL;
+}
+
+
+/* --------------------------------------------------------------- read --- */
+size_t luaZ_read (ZIO *z, void *b, size_t n) {
+  while (n) {
+    size_t m;
+    if (z->n == 0) {  /* no bytes in buffer? */
+      if (luaZ_fill(z) == EOZ)  /* try to read more */
+        return n;  /* no more input; return number of missing bytes */
+      else {
+        z->n++;  /* luaZ_fill consumed first byte; put it back */
+        z->p--;
+      }
+    }
+    m = (n <= z->n) ? n : z->n;  /* min. between n and z->n */
+    memcpy(b, z->p, m);
+    z->n -= m;
+    z->p += m;
+    b = (char *)b + m;
+    n -= m;
+  }
+  return 0;
+}
+
+/* ------------------------------------------------------------------------ */
+char *luaZ_openspace (lua_State *L, Mbuffer *buff, size_t n) {
+  if (n > buff->buffsize) {
+    if (n < LUA_MINBUFFER) n = LUA_MINBUFFER;
+    luaZ_resizebuffer(L, buff, n);
+  }
+  return buff->buffer;
+}
+
+
diff -ruNp src.hd/libs/lua/lzio.h src/libs/lua/lzio.h
--- src.hd/libs/lua/lzio.h	1969-12-31 16:00:00 -0800
+++ src/libs/lua/lzio.h	2017-12-29 00:57:40 -0800
@@ -0,0 +1,65 @@
+/*
+** $Id: lzio.h,v 1.26 2011/07/15 12:48:03 roberto Exp $
+** Buffered streams
+** See Copyright Notice in lua.h
+*/
+
+
+#ifndef lzio_h
+#define lzio_h
+
+#include "lua.h"
+
+#include "lmem.h"
+
+
+#define EOZ	(-1)			/* end of stream */
+
+typedef struct Zio ZIO;
+
+#define zgetc(z)  (((z)->n--)>0 ?  cast_uchar(*(z)->p++) : luaZ_fill(z))
+
+
+typedef struct Mbuffer {
+  char *buffer;
+  size_t n;
+  size_t buffsize;
+} Mbuffer;
+
+#define luaZ_initbuffer(L, buff) ((buff)->buffer = NULL, (buff)->buffsize = 0)
+
+#define luaZ_buffer(buff)	((buff)->buffer)
+#define luaZ_sizebuffer(buff)	((buff)->buffsize)
+#define luaZ_bufflen(buff)	((buff)->n)
+
+#define luaZ_resetbuffer(buff) ((buff)->n = 0)
+
+
+#define luaZ_resizebuffer(L, buff, size) \
+	(luaM_reallocvector(L, (buff)->buffer, (buff)->buffsize, size, char), \
+	(buff)->buffsize = size)
+
+#define luaZ_freebuffer(L, buff)	luaZ_resizebuffer(L, buff, 0)
+
+
+LUAI_FUNC char *luaZ_openspace (lua_State *L, Mbuffer *buff, size_t n);
+LUAI_FUNC void luaZ_init (lua_State *L, ZIO *z, lua_Reader reader,
+                                        void *data);
+LUAI_FUNC size_t luaZ_read (ZIO* z, void* b, size_t n);	/* read next n bytes */
+
+
+
+/* --------- Private Part ------------------ */
+
+struct Zio {
+  size_t n;			/* bytes still unread */
+  const char *p;		/* current position in buffer */
+  lua_Reader reader;		/* reader function */
+  void* data;			/* additional data */
+  lua_State *L;			/* Lua state (for reader) */
+};
+
+
+LUAI_FUNC int luaZ_fill (ZIO *z);
+
+#endif
diff -ruNp src.hd/libs/luauqm/Makeinfo src/libs/luauqm/Makeinfo
--- src.hd/libs/luauqm/Makeinfo	1969-12-31 16:00:00 -0800
+++ src/libs/luauqm/Makeinfo	2017-12-29 00:57:40 -0800
@@ -0,0 +1,2 @@
+uqm_CFILES="luauqm.c scriptres.c"
+uqm_HFILES="luauqm.h scriptres.h"
diff -ruNp src.hd/libs/luauqm/luauqm.c src/libs/luauqm/luauqm.c
--- src.hd/libs/luauqm/luauqm.c	1969-12-31 16:00:00 -0800
+++ src/libs/luauqm/luauqm.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,318 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <stdlib.h>
+#ifdef USE_INTERNAL_LUA
+#   include "libs/lua/lualib.h"
+#else
+#	include <lualib.h>
+#endif
+
+#define LUAUQM_INTERNAL
+#include "luauqm.h"
+
+#include "libs/log.h"
+
+
+#define LOADSCRIPT_BUFSIZE	0x10000
+
+
+// We want to give the UQM module writer a good set of functions to work
+// with, but we must be careful not to give access to functions which may
+// break security. Bad Lua scripts should not be able to affect anything
+// outside of UQM.
+// XXX TODO: a better sandbox: http://lua-users.org/wiki/SandBoxes
+static const luaL_Reg safeLibs[] = {
+	{ "",                luaopen_base },
+	{ LUA_BITLIBNAME,    luaopen_bit32 },
+	//{ LUA_COLIBNAME,     luaopen_coroutine },
+	//{ LUA_DBLIBNAME,     luaopen_debug },
+	//{ LUA_LUA_IOLIBNAME, luaopen_io },
+	{ LUA_MATHLIBNAME,   luaopen_math },
+	//{ LUA_LUA_OSLIBNAME, luaopen_os },
+	//{ LUA_LUA_LOADLIBNAME, luaopen_package },
+	{ LUA_STRLIBNAME,    luaopen_string },
+	{ LUA_TABLIBNAME,    luaopen_table },
+	{ NULL, NULL }
+};
+
+void
+luaUqm_loadLib(lua_State *luaState, const luaL_Reg *lib) {
+	lua_pushglobaltable(luaState);
+
+	lua_pushcfunction(luaState, lib->func);
+	lua_pushstring(luaState, lib->name);
+	lua_call(luaState, 1, 1);
+
+	// [-2] -> table globalTable
+	// [-1] -> string libTable
+	lua_setfield(luaState, -2, lib->name);
+	lua_pop(luaState, 1);
+}
+
+void
+luaUqm_loadLibs(lua_State *luaState, const luaL_Reg *libs) {
+	while (libs->func != NULL) {
+		luaUqm_loadLib(luaState, libs);
+		libs++;
+	}
+}
+
+void
+luaUqm_loadSafeDefaultLibs(lua_State *luaState) {
+	luaUqm_loadLibs(luaState, safeLibs);
+}
+
+// Init the lua UQM system.
+void
+luaUqm_init(void) {
+	InstallScriptResType();
+}
+
+// Uninit the lua UQM system. No-op for now.
+void
+luaUqm_uninit(void) {
+}
+
+typedef struct {
+	const char *fileName;
+	uio_Stream *in;
+	char *buf;
+} luaUqm_ReaderState;
+
+static const char *
+luaUqm_reader(lua_State *luaState, void *data, size_t *size) {
+	luaUqm_ReaderState *readerState = (luaUqm_ReaderState *) data;
+
+	size_t numRead = uio_fread(readerState->buf, 1, LOADSCRIPT_BUFSIZE,
+			readerState->in);
+	if (numRead == (size_t) -1) {
+		log_add(log_Error, "luaUqm_loadScript(): Read error readin "
+				"script file '%s'.", readerState->fileName);
+		*size = 0;
+		return NULL;
+	}
+
+	(void) luaState;
+	*size = numRead;
+	return readerState->buf;
+}
+
+void
+luaUqm_prepareEnvironment(lua_State *luaState) {
+	// Redefines _G, to which the global environment (_ENV) of loaded code
+	// is initialised.
+	lua_newtable(luaState);
+	lua_rawseti(luaState, LUA_REGISTRYINDEX, LUA_RIDX_GLOBALS);
+	luaUqm_loadSafeDefaultLibs(luaState);
+}
+
+// On success, the script is on the stack as a function.
+// Returns TRUE on success, and FALSE on error.
+BOOLEAN
+luaUqm_loadScript(lua_State *luaState, uio_DirHandle *dir,
+		const char *fileName) {
+	uio_Stream *in = NULL;
+	char *buf = NULL;
+	luaUqm_ReaderState readerState;
+	
+	log_add(log_Debug, "Loading script '%s'.", fileName);
+	
+	in = uio_fopen(dir, fileName, "rt");
+	if (in == NULL) {
+		log_add(log_Error, "luaUqm_loadScript(): Unable to open script file "
+				"'%s' for reading.", fileName);
+		goto err;
+	}
+
+	buf = malloc(LOADSCRIPT_BUFSIZE);
+	if (buf == NULL)
+		goto err;
+
+	readerState.fileName = fileName;
+	readerState.in = in;
+	readerState.buf = buf;
+
+	if (lua_load (luaState, luaUqm_reader, (void *) &readerState, NULL, NULL)
+			!= LUA_OK) {
+		log_add(log_Error, "luaUqm_loadScript(): lua_load() failed: %s",
+				lua_tostring(luaState, -1));
+		lua_pop(luaState, 1);
+		goto err;
+	}
+
+	free(buf);
+	uio_fclose(in);
+	return TRUE;
+
+err:
+	if (buf != NULL)
+		free(buf);
+
+	if (in != NULL)
+		uio_fclose(in);
+
+	return FALSE;
+}
+
+// Load a script from file and run it.
+BOOLEAN
+luaUqm_runScript(lua_State *luaState, uio_DirHandle *dir,
+		const char *fileName) {
+	if (!luaUqm_loadScript(luaState, dir, fileName)) {
+		// Could not load script. Error is already printed.
+		return FALSE;
+	}
+
+	return luaUqm_callStackFunction(luaState);
+}
+
+// Run all Lua scripts in a directory.
+// Currently, all scripts are run in the same environment.
+// Maybe we do not want this.
+void
+luaUqm_runLuaDir(lua_State *luaState, uio_DirHandle *dirHandle,
+		const char *luaDirName) {
+	uio_DirHandle *luaDir = NULL;
+	uio_DirList *luaFiles = NULL;
+	int fileI;
+
+	luaDir = uio_openDirRelative(dirHandle, luaDirName, 0);
+	if (luaDir == NULL) {
+		log_add(log_Warning, "Warning: Could not open Lua script directory "
+				"'%s'.", luaDirName);
+		goto err;
+	}
+		
+	luaFiles = uio_getDirList(luaDir, "", ".lua", match_MATCH_SUFFIX);
+	if (luaFiles == NULL) {
+		log_add(log_Warning, "Warning: Could not read Lua script directory "
+				"'%s'.", luaDirName);
+		goto err;
+	}
+
+	log_add(log_Debug, "Script directory '%s': loading %d file(s).",
+			luaDirName, luaFiles->numNames);
+	for (fileI = 0; fileI < luaFiles->numNames; fileI++) {
+		const char *fileName = luaFiles->names[fileI];
+		luaUqm_runScript(luaState, luaDir, fileName);
+	}
+
+	uio_DirList_free(luaFiles);
+	uio_closeDir(luaDir);
+	return;
+
+err:
+	if (luaFiles != NULL)
+		uio_DirList_free(luaFiles);
+	if (luaDir != NULL)
+		uio_closeDir(luaDir);
+}
+
+// [-1] -> function fun
+// Call a Lua function which is on the stack, taking no parameters and
+// returning no value.
+// returns FALSE on failure and TRUE on success.
+BOOLEAN
+luaUqm_callStackFunction(lua_State *luaState) {
+	if (lua_pcall(luaState, 0, 0, 0) != 0) {
+		log_add(log_Error, "[script] A script error occurred in "
+				"luaUqm_callStackFunction(): %s", lua_tostring(luaState, -1));
+		lua_pop(luaState, 1);
+				// Pop the error.
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+// Call a Lua function by (char *) name, taking no parameters and returning
+// no value. returns FALSE on failure and TRUE on success.
+BOOLEAN
+luaUqm_callFunction(lua_State *luaState, const char *str) {
+	lua_getglobal(luaState, str);
+	if (!lua_isfunction(luaState, -1)) {
+		lua_pop(luaState, 1);
+		return FALSE;
+	}
+
+	return luaUqm_callStackFunction(luaState);
+}
+
+// Pushes a table on the stack with properties with names and values
+// from enumVals;
+void
+luaUqm_makeEnum(lua_State *luaState, const luaUqm_EnumValue *enumVals) {
+	const luaUqm_EnumValue *enumPtr;
+	size_t enumCount = 0;
+
+	// Count the number of enum values.
+	for (enumPtr = enumVals; enumPtr->name != NULL; enumPtr++)
+		enumCount++;
+
+	lua_createtable(luaState, 0, enumCount);
+	for (enumPtr = enumVals; enumPtr->name != NULL; enumPtr++) {
+		lua_pushinteger(luaState, enumPtr->value);
+
+		// [-2] -> table enumTable
+		// [-1] -> int enumValue
+		lua_setfield(luaState, -2, enumPtr->name);
+	}
+}
+
+#ifdef DEBUG
+void
+luaUqm_dumpStack(lua_State *luaState)
+{
+	int top = lua_gettop(luaState);
+	int stackI;
+
+	for (stackI = 1; stackI <= top; stackI++)
+	{
+		int type = lua_type(luaState, stackI);
+		const char *typeName = lua_typename(luaState, type);
+		log_add(log_Debug, "[%d] (%s)", stackI, typeName);
+		switch (type) {
+			case LUA_TNONE:
+				break;
+			case LUA_TNIL:
+				break;
+			case LUA_TBOOLEAN:
+				log_add(log_Debug, "    %s",
+						lua_toboolean(luaState, stackI) ? "true" : "false");
+				break;
+			case LUA_TLIGHTUSERDATA:
+				break;
+			case LUA_TNUMBER:
+				log_add(log_Debug, "    %g", lua_tonumber(luaState, stackI));
+				break;
+			case LUA_TSTRING:
+				log_add(log_Debug, "    \"%s\"",
+						lua_tostring(luaState, stackI));
+				break;
+			case LUA_TTABLE:
+				break;
+			case LUA_TFUNCTION:
+				break;
+			case LUA_TUSERDATA:
+				break;
+			case LUA_TTHREAD:
+				break;
+		}
+	}
+}
+#endif
+
diff -ruNp src.hd/libs/luauqm/luauqm.h src/libs/luauqm/luauqm.h
--- src.hd/libs/luauqm/luauqm.h	1969-12-31 16:00:00 -0800
+++ src/libs/luauqm/luauqm.h	2017-12-29 00:57:40 -0800
@@ -0,0 +1,79 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _LUAUQM_H
+#define _LUAUQM_H
+
+#ifdef USE_INTERNAL_LUA
+#   include "libs/lua/lua.h"
+#   include "libs/lua/lauxlib.h"
+#else
+#	include <lua.h>
+#	include <lauxlib.h>
+#endif
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+typedef struct luaUqm_EnumValue luaUqm_EnumValue;
+
+#if defined(__cplusplus)
+}
+#endif
+
+#include "libs/compiler.h"
+#include "libs/uio.h"
+
+#include "scriptres.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+struct luaUqm_EnumValue {
+	const char *name;
+	int value;
+};
+
+void luaUqm_init(void);
+void luaUqm_uninit(void);
+
+void luaUqm_prepareEnvironment(lua_State *luaState);
+BOOLEAN luaUqm_loadScript(lua_State *luaState, uio_DirHandle *dir,
+		const char *fileName);
+BOOLEAN luaUqm_runScript(lua_State *luaState, uio_DirHandle *dir,
+		const char *fileName);
+void luaUqm_runLuaDir(lua_State *luaState, uio_DirHandle *dirHandle,
+		const char *luaDirName);
+
+void luaUqm_loadLib(lua_State *luaState, const luaL_Reg *lib);
+void luaUqm_loadLibs(lua_State *luaState, const luaL_Reg *libs);
+void luaUqm_loadSafeDefaultLibs(lua_State *luaState);
+BOOLEAN luaUqm_callStackFunction(lua_State *luaState);
+BOOLEAN luaUqm_callFunction(lua_State *luaState, const char *str);
+void luaUqm_makeEnum(lua_State *luaState, const luaUqm_EnumValue *enumVals);
+
+#ifdef DEBUG
+void luaUqm_dumpStack(lua_State *luaState);
+#endif
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif  /* _LUAUQM_H */
+
diff -ruNp src.hd/libs/luauqm/scriptres.c src/libs/luauqm/scriptres.c
--- src.hd/libs/luauqm/scriptres.c	1969-12-31 16:00:00 -0800
+++ src/libs/luauqm/scriptres.c	2017-12-29 00:57:40 -0800
@@ -0,0 +1,60 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "scriptres.h"
+
+#include <string.h>
+
+
+BOOLEAN
+ReleaseScriptResData (void *data)
+{
+	HFree (data);
+	return TRUE;
+}
+
+static void
+GetScriptResData (const char *pathName, RESOURCE_DATA *resdata)
+{
+	// We don't actually load the data here. We determine the file name, and
+	// load the data when we need it, directly onto the Lua stack.
+	size_t pathNameLen = strlen (pathName);
+	resdata->ptr = HMalloc (pathNameLen + 1);
+	if (resdata->ptr == NULL)
+		return;
+
+	memcpy (resdata->ptr, pathName, pathNameLen + 1);
+}
+
+BOOLEAN
+InstallScriptResType (void)
+{
+	InstallResTypeVectors ("SCRIPT", GetScriptResData, ReleaseScriptResData,
+			NULL);
+	return TRUE;
+}
+
+// Actually just returns the file name of the script.
+char *
+LoadScriptInstance (RESOURCE res)
+{
+	void *data = res_GetResource (res);
+	if (data)
+		res_DetachResource (res);
+
+	return (char *) data;
+}
+
diff -ruNp src.hd/libs/luauqm/scriptres.h src/libs/luauqm/scriptres.h
--- src.hd/libs/luauqm/scriptres.h	1969-12-31 16:00:00 -0800
+++ src/libs/luauqm/scriptres.h	2017-12-29 00:57:40 -0800
@@ -0,0 +1,38 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _SCRIPTRES_H
+#define _SCRIPTRES_H
+
+#include "libs/compiler.h"
+#include "libs/reslib.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+#define LoadScript LoadScriptRes
+
+BOOLEAN ReleaseScriptResData (void *data);
+BOOLEAN InstallScriptResType (void);
+char *LoadScriptInstance (RESOURCE res);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif  /* SCRIPTRES_H */
+
diff -ruNp src.hd/libs/math/Makeinfo src/libs/math/Makeinfo
--- src.hd/libs/math/Makeinfo	2017-12-29 02:25:49 -0800
+++ src/libs/math/Makeinfo	2017-12-29 00:57:40 -0800
@@ -1 +1,2 @@
 uqm_CFILES="random.c random2.c sqrt.c"
+uqm_HFILES="mthintrn.h random.h"
diff -ruNp src.hd/libs/math/random.h src/libs/math/random.h
--- src.hd/libs/math/random.h	2017-12-29 02:25:49 -0800
+++ src/libs/math/random.h	2017-12-29 00:57:40 -0800
@@ -29,13 +29,6 @@
 #ifndef _RANDOM_H
 #define _RANDOM_H
 
-/* ----------------------------DEFINES------------------------------------ */
-
-#define RAND(n) ( (int) ( (unsigned int)TFB_Random() % (n) ) )
-#define SRAND(n) ( (int)TFB_Random() % (n) )
-#define AND_RAND(n) ( (int)TFB_Random() & (n) )
-
-
 /* ----------------------------GLOBALS/EXTERNS---------------------------- */
 
 DWORD TFB_SeedRandom (DWORD seed);
@@ -55,6 +48,7 @@ void RandomContext_Delete (RandomContext
 RandomContext *RandomContext_Copy (const RandomContext *source);
 DWORD RandomContext_Random (RandomContext *context);
 DWORD RandomContext_SeedRandom (RandomContext *context, DWORD new_seed);
+DWORD RandomContext_GetSeed (RandomContext *context);
 
 
 #endif  /* _RANDOM_H */
diff -ruNp src.hd/libs/math/random2.c src/libs/math/random2.c
--- src.hd/libs/math/random2.c	2017-12-29 02:25:49 -0800
+++ src/libs/math/random2.c	2017-12-29 00:57:40 -0800
@@ -82,4 +82,8 @@ RandomContext_SeedRandom (RandomContext
 	return old_seed;
 }
 
-
+DWORD
+RandomContext_GetSeed (RandomContext *context)
+{
+	return context->seed;
+}
diff -ruNp src.hd/libs/mathlib.h src/libs/mathlib.h
--- src.hd/libs/mathlib.h	2017-12-29 02:25:49 -0800
+++ src/libs/mathlib.h	2017-12-29 00:57:40 -0800
@@ -20,10 +20,19 @@
 #define _MATHLIB_H
 
 #include "libs/compiler.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #include "math/random.h"
 
 extern COUNT square_root (DWORD value);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _MATHLIB_H */
 
 
diff -ruNp src.hd/libs/md5/Makeinfo src/libs/md5/Makeinfo
--- src.hd/libs/md5/Makeinfo	2017-12-29 02:25:49 -0800
+++ src/libs/md5/Makeinfo	2017-12-29 00:57:40 -0800
@@ -1,2 +1,2 @@
 uqm_CFILES="md5.c"
-
+uqm_HFILES="md5.h"
diff -ruNp src.hd/libs/md5.h src/libs/md5.h
--- src.hd/libs/md5.h	2017-12-29 02:25:49 -0800
+++ src/libs/md5.h	2017-12-29 00:57:40 -0800
@@ -19,7 +19,15 @@
 #ifndef _LIB_MD5_H
 #define _LIB_MD5_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #include "md5/md5.h"
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _LIB_MD5_H */
 
diff -ruNp src.hd/libs/memlib.h src/libs/memlib.h
--- src.hd/libs/memlib.h	2017-12-29 02:25:49 -0800
+++ src/libs/memlib.h	2017-12-29 00:57:40 -0800
@@ -19,15 +19,25 @@
 #ifndef _MEMLIB_H
 #define _MEMLIB_H
 
+#include <stddef.h>
+
 #include "types.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern bool mem_init (void);
 extern bool mem_uninit (void);
 
-extern void *HMalloc (int size);
+extern void *HMalloc (size_t size);
 extern void HFree (void *p);
-extern void *HCalloc (int size);
-extern void *HRealloc (void *p, int size);
+extern void *HCalloc (size_t size);
+extern void *HRealloc (void *p, size_t size);
+
+#if defined(__cplusplus)
+}
+#endif
 
 #endif /* _MEMLIB_H */
 
diff -ruNp src.hd/libs/memory/w_memlib.c src/libs/memory/w_memlib.c
--- src.hd/libs/memory/w_memlib.c	2017-12-29 02:25:49 -0800
+++ src/libs/memory/w_memlib.c	2017-12-29 00:57:40 -0800
@@ -38,68 +38,47 @@ mem_uninit (void)
 }
 
 void *
-HMalloc (int size)
+HMalloc (size_t size)
 {
-	void *p;
-
-	if (size == 0)
-		return NULL;
-
-	if (size < 0) 
-	{
-		log_add (log_Fatal, "HMalloc() FATAL: "
-				"request for negative amount of memory %d!", size);
-		fflush (stderr);
-		explode ();
-	}
-
-	p = malloc (size);
-	if (p == NULL) 
+	void *p = malloc (size);
+	if (p == NULL && size > 0)
 	{
 		log_add (log_Fatal, "HMalloc() FATAL: out of memory.");
 		fflush (stderr);
 		explode ();
 	}
-	return (p);
+
+	return p;
 }
 
 void
 HFree (void *p)
 {
-	if (p)
-	{
-		free (p);
-	}
+	free (p);
 }
 
 void *
-HCalloc (int size)
+HCalloc (size_t size)
 {
 	void *p;
 
 	p = HMalloc (size);
 	memset (p, 0, size);
 
-	return (p);
+	return p;
 }
 
 void *
-HRealloc (void *p, int size)
+HRealloc (void *p, size_t size)
 {
-	if (size < 0) 
-	{
-		log_add (log_Fatal, "HRealloc() FATAL: "
-				"request for negative amount of memory %d!", size);
-		fflush (stderr);
-		explode ();
-	}
-
 	p = realloc (p, size);
-	if (!p && size > 0) 
+	if (p == NULL && size > 0)
 	{
 		log_add (log_Fatal, "HRealloc() FATAL: out of memory.");
 		fflush (stderr);
 		explode ();
 	}
+
 	return p;
 }
+
diff -ruNp src.hd/libs/mikmod/Makeinfo src/libs/mikmod/Makeinfo
--- src.hd/libs/mikmod/Makeinfo	2017-12-29 02:25:49 -0800
+++ src/libs/mikmod/Makeinfo	2017-12-29 00:57:40 -0800
@@ -2,3 +2,4 @@ uqm_CFILES="drv_nos.c load_it.c load_mod
 		mdreg.c mdriver.c mloader.c
 		mlreg.c mlutil.c mmalloc.c mmerror.c mmio.c mplayer.c munitrk.c
 		mwav.c npertab.c sloader.c virtch.c virtch2.c virtch_common.c"
+uqm_HFILES="mikmod_build.h mikmod.h mikmod_internals.h"
diff -ruNp src.hd/libs/mikmod/drv_nos.c src/libs/mikmod/drv_nos.c
--- src.hd/libs/mikmod/drv_nos.c	2017-12-29 02:25:49 -0800
+++ src/libs/mikmod/drv_nos.c	2017-12-29 00:57:40 -0800
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: drv_nos.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   Driver for no output
 
diff -ruNp src.hd/libs/mikmod/load_it.c src/libs/mikmod/load_it.c
--- src.hd/libs/mikmod/load_it.c	2017-12-29 02:25:49 -0800
+++ src/libs/mikmod/load_it.c	2017-12-29 00:57:40 -0800
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_it.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   Impulse tracker (IT) module loader
 
diff -ruNp src.hd/libs/mikmod/load_mod.c src/libs/mikmod/load_mod.c
--- src.hd/libs/mikmod/load_mod.c	2017-12-29 02:25:49 -0800
+++ src/libs/mikmod/load_mod.c	2017-12-29 00:57:40 -0800
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_mod.c 2421 2006-08-19 00:36:21Z avolkov $
+  $Id$
 
   Generic MOD loader (Protracker, StarTracker, FastTracker, etc)
 
diff -ruNp src.hd/libs/mikmod/load_s3m.c src/libs/mikmod/load_s3m.c
--- src.hd/libs/mikmod/load_s3m.c	2017-12-29 02:25:49 -0800
+++ src/libs/mikmod/load_s3m.c	2017-12-29 00:57:40 -0800
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_s3m.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   Screamtracker (S3M) module loader
 
diff -ruNp src.hd/libs/mikmod/load_stm.c src/libs/mikmod/load_stm.c
--- src.hd/libs/mikmod/load_stm.c	2017-12-29 02:25:49 -0800
+++ src/libs/mikmod/load_stm.c	2017-12-29 00:57:40 -0800
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_stm.c 2421 2006-08-19 00:36:21Z avolkov $
+  $Id$
 
   Screamtracker 2 (STM) module loader
 
diff -ruNp src.hd/libs/mikmod/load_xm.c src/libs/mikmod/load_xm.c
--- src.hd/libs/mikmod/load_xm.c	2017-12-29 02:25:49 -0800
+++ src/libs/mikmod/load_xm.c	2017-12-29 00:57:40 -0800
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: load_xm.c 2421 2006-08-19 00:36:21Z avolkov $
+  $Id$
 
   Fasttracker (XM) module loader
 
diff -ruNp src.hd/libs/mikmod/mdreg.c src/libs/mikmod/mdreg.c
--- src.hd/libs/mikmod/mdreg.c	2017-12-29 02:25:49 -0800
+++ src/libs/mikmod/mdreg.c	2017-12-29 00:57:40 -0800
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mdreg.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   Routine for registering all drivers in libmikmod for the current platform.
 
diff -ruNp src.hd/libs/mikmod/mdriver.c src/libs/mikmod/mdriver.c
--- src.hd/libs/mikmod/mdriver.c	2017-12-29 02:25:49 -0800
+++ src/libs/mikmod/mdriver.c	2017-12-29 00:57:40 -0800
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mdriver.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   These routines are used to access the available soundcard drivers.
 
diff -ruNp src.hd/libs/mikmod/mikmod.h src/libs/mikmod/mikmod.h
--- src.hd/libs/mikmod/mikmod.h	2017-12-29 02:25:49 -0800
+++ src/libs/mikmod/mikmod.h	2017-12-29 00:57:40 -0800
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mikmod.h 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   MikMod sound library include file
 
diff -ruNp src.hd/libs/mikmod/mikmod_internals.h src/libs/mikmod/mikmod_internals.h
--- src.hd/libs/mikmod/mikmod_internals.h	2017-12-29 02:25:49 -0800
+++ src/libs/mikmod/mikmod_internals.h	2017-12-29 00:57:40 -0800
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mikmod_internals.h 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   MikMod sound library internal definitions
 
diff -ruNp src.hd/libs/mikmod/mloader.c src/libs/mikmod/mloader.c
--- src.hd/libs/mikmod/mloader.c	2017-12-29 02:25:49 -0800
+++ src/libs/mikmod/mloader.c	2017-12-29 00:57:40 -0800
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mloader.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   These routines are used to access the available module loaders
 
diff -ruNp src.hd/libs/mikmod/mlreg.c src/libs/mikmod/mlreg.c
--- src.hd/libs/mikmod/mlreg.c	2017-12-29 02:25:49 -0800
+++ src/libs/mikmod/mlreg.c	2017-12-29 00:57:40 -0800
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mlreg.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   Routine for registering all loaders in libmikmod for the current platform.
 
diff -ruNp src.hd/libs/mikmod/mlutil.c src/libs/mikmod/mlutil.c
--- src.hd/libs/mikmod/mlutil.c	2017-12-29 02:25:49 -0800
+++ src/libs/mikmod/mlutil.c	2017-12-29 00:57:40 -0800
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mlutil.c 2421 2006-08-19 00:36:21Z avolkov $
+  $Id$
 
   Utility functions for the module loader
 
diff -ruNp src.hd/libs/mikmod/mmalloc.c src/libs/mikmod/mmalloc.c
--- src.hd/libs/mikmod/mmalloc.c	2017-12-29 02:25:49 -0800
+++ src/libs/mikmod/mmalloc.c	2017-12-29 00:57:40 -0800
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mmalloc.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   Dynamic memory routines
 
diff -ruNp src.hd/libs/mikmod/mmerror.c src/libs/mikmod/mmerror.c
--- src.hd/libs/mikmod/mmerror.c	2017-12-29 02:25:49 -0800
+++ src/libs/mikmod/mmerror.c	2017-12-29 00:57:40 -0800
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mmerror.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   Error handling functions.
   Register an error handler with _mm_RegisterErrorHandler() and you're all set.
diff -ruNp src.hd/libs/mikmod/mmio.c src/libs/mikmod/mmio.c
--- src.hd/libs/mikmod/mmio.c	2017-12-29 02:25:49 -0800
+++ src/libs/mikmod/mmio.c	2017-12-29 00:57:40 -0800
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mmio.c 2421 2006-08-19 00:36:21Z avolkov $
+  $Id$
 
   Portable file I/O routines
 
diff -ruNp src.hd/libs/mikmod/mplayer.c src/libs/mikmod/mplayer.c
--- src.hd/libs/mikmod/mplayer.c	2017-12-29 02:25:49 -0800
+++ src/libs/mikmod/mplayer.c	2017-12-29 00:57:40 -0800
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mplayer.c 2421 2006-08-19 00:36:21Z avolkov $
+  $Id$
 
   The Protracker Player Driver
 
diff -ruNp src.hd/libs/mikmod/munitrk.c src/libs/mikmod/munitrk.c
--- src.hd/libs/mikmod/munitrk.c	2017-12-29 02:25:49 -0800
+++ src/libs/mikmod/munitrk.c	2017-12-29 00:57:40 -0800
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: munitrk.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   All routines dealing with the manipulation of UNITRK streams
 
diff -ruNp src.hd/libs/mikmod/mwav.c src/libs/mikmod/mwav.c
--- src.hd/libs/mikmod/mwav.c	2017-12-29 02:25:49 -0800
+++ src/libs/mikmod/mwav.c	2017-12-29 00:57:40 -0800
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: mwav.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   WAV sample loader
 
diff -ruNp src.hd/libs/mikmod/npertab.c src/libs/mikmod/npertab.c
--- src.hd/libs/mikmod/npertab.c	2017-12-29 02:25:49 -0800
+++ src/libs/mikmod/npertab.c	2017-12-29 00:57:40 -0800
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: npertab.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   MOD format period table.  Used by both the MOD and M15 (15-inst mod) Loaders.
 
diff -ruNp src.hd/libs/mikmod/sloader.c src/libs/mikmod/sloader.c
--- src.hd/libs/mikmod/sloader.c	2017-12-29 02:25:49 -0800
+++ src/libs/mikmod/sloader.c	2017-12-29 00:57:40 -0800
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: sloader.c 2412 2006-08-18 18:37:39Z avolkov $
+  $Id$
 
   Routines for loading samples. The sample loader utilizes the routines
   provided by the "registered" sample loader.
diff -ruNp src.hd/libs/mikmod/virtch.c src/libs/mikmod/virtch.c
--- src.hd/libs/mikmod/virtch.c	2017-12-29 02:25:49 -0800
+++ src/libs/mikmod/virtch.c	2017-12-29 00:57:40 -0800
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: virtch.c 2421 2006-08-19 00:36:21Z avolkov $
+  $Id$
 
   Sample mixing routines, using a 32 bits mixing buffer.
 
diff -ruNp src.hd/libs/mikmod/virtch2.c src/libs/mikmod/virtch2.c
--- src.hd/libs/mikmod/virtch2.c	2017-12-29 02:25:49 -0800
+++ src/libs/mikmod/virtch2.c	2017-12-29 00:57:40 -0800
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: virtch2.c 2421 2006-08-19 00:36:21Z avolkov $
+  $Id$
 
   High-quality sample mixing routines, using a 32 bits mixing buffer,
   interpolation, and sample smoothing to improve sound quality and remove
diff -ruNp src.hd/libs/mikmod/virtch_common.c src/libs/mikmod/virtch_common.c
--- src.hd/libs/mikmod/virtch_common.c	2017-12-29 02:25:49 -0800
+++ src/libs/mikmod/virtch_common.c	2017-12-29 00:57:40 -0800
@@ -20,7 +20,7 @@
 
 /*==============================================================================
 
-  $Id: virtch_common.c 2421 2006-08-19 00:36:21Z avolkov $
+  $Id$
 
   Common source parts between the two software mixers.
   This file is probably the ugliest part of libmikmod...
diff -ruNp src.hd/libs/misc.h src/libs/misc.h
--- src.hd/libs/misc.h	2017-12-29 02:25:49 -0800
+++ src/libs/misc.h	2017-12-29 00:57:41 -0800
@@ -26,6 +26,10 @@
 #include <stdlib.h>
 #include "port.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 
 extern int TFB_DEBUG_HALT;
 
@@ -47,12 +51,16 @@ static inline void explode (void)
 static inline void *
 unconst(const void *arg) {
 	union {
-		char *c;
-		const char *cc;
+		void *c;
+		const void *cc;
 	} u;
 	u.cc = arg;
 	return u.c;
 }
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif
 
diff -ruNp src.hd/libs/net.h src/libs/net.h
--- src.hd/libs/net.h	2017-12-29 02:25:49 -0800
+++ src/libs/net.h	2017-12-29 00:57:41 -0800
@@ -19,11 +19,19 @@
 #ifndef _NET_H
 #define _NET_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #include "network/network.h"
 #include "network/netmanager/netmanager.h"
 #include "network/connect/connect.h"
 #include "network/connect/listen.h"
 #include "network/connect/resolve.h"
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _NET_H */
 
diff -ruNp src.hd/libs/network/Makeinfo src/libs/network/Makeinfo
--- src.hd/libs/network/Makeinfo	2017-12-29 02:25:49 -0800
+++ src/libs/network/Makeinfo	2017-12-29 00:57:41 -0800
@@ -1,9 +1,12 @@
 uqm_SUBDIRS="connect netmanager socket"
 uqm_CFILES="netport.c"
+uqm_HFILES="bytesex.h netport.h network.h"
+
 if [ -n "$uqm_USE_WINSOCK" ]; then
 	uqm_CFILES="$uqm_CFILES network_win.c"
 	if [ -n "$MACRO___MINGW32__" ]; then
 		uqm_CFILES="$uqm_CFILES wspiapiwrap.c"
+		uqm_HFILES="$uqm_HFILES wspiapiwrap.h"
 	fi
 else
 	uqm_CFILES="$uqm_CFILES network_bsd.c"
diff -ruNp src.hd/libs/network/connect/Makeinfo src/libs/network/connect/Makeinfo
--- src.hd/libs/network/connect/Makeinfo	2017-12-29 02:25:49 -0800
+++ src/libs/network/connect/Makeinfo	2017-12-29 00:57:41 -0800
@@ -1,2 +1,2 @@
 uqm_CFILES="connect.c listen.c resolve.c"
-
+uqm_HFILES="connect.h listen.h resolve.h"
diff -ruNp src.hd/libs/network/connect/connect.c src/libs/network/connect/connect.c
--- src.hd/libs/network/connect/connect.c	2017-12-29 02:25:49 -0800
+++ src/libs/network/connect/connect.c	2017-12-29 00:57:41 -0800
@@ -57,7 +57,7 @@ static void doConnectErrorCallback(Conne
 static ConnectState *
 ConnectState_alloc(void) {
 	return (ConnectState *) malloc(sizeof (ConnectState));
-};
+}
 
 static void
 ConnectState_free(ConnectState *connectState) {
diff -ruNp src.hd/libs/network/connect/listen.c src/libs/network/connect/listen.c
--- src.hd/libs/network/connect/listen.c	2017-12-29 02:25:49 -0800
+++ src/libs/network/connect/listen.c	2017-12-29 00:57:41 -0800
@@ -56,7 +56,7 @@ static void doListenErrorCallback(Listen
 static ListenState *
 ListenState_alloc(void) {
 	return (ListenState *) malloc(sizeof (ListenState));
-};
+}
 
 static void
 ListenState_free(ListenState *listenState) {
diff -ruNp src.hd/libs/network/connect/resolve.c src/libs/network/connect/resolve.c
--- src.hd/libs/network/connect/resolve.c	2017-12-29 02:25:49 -0800
+++ src/libs/network/connect/resolve.c	2017-12-29 00:57:41 -0800
@@ -33,7 +33,7 @@
 static ResolveState *
 ResolveState_new(void) {
 	return (ResolveState *) malloc(sizeof (ResolveState));
-};
+}
 
 static void
 ResolveState_free(ResolveState *resolveState) {
diff -ruNp src.hd/libs/network/netmanager/Makeinfo src/libs/network/netmanager/Makeinfo
--- src.hd/libs/network/netmanager/Makeinfo	2017-12-29 02:25:49 -0800
+++ src/libs/network/netmanager/Makeinfo	2017-12-29 00:57:41 -0800
@@ -1,8 +1,11 @@
 uqm_CFILES="ndesc.c"
+uqm_HFILES="ndesc.h netmanager.h"
+
 if [ -n "$uqm_USE_WINSOCK" ]; then
 	uqm_CFILES="$uqm_CFILES netmanager_win.c"
+	uqm_HFILES="$uqm_HFILES netmanager_win.h"
 else
 	uqm_CFILES="$uqm_CFILES netmanager_bsd.c"
+	uqm_HFILES="$uqm_HFILES netmanager_bsd.h"
 fi
 
-
diff -ruNp src.hd/libs/network/socket/Makeinfo src/libs/network/socket/Makeinfo
--- src.hd/libs/network/socket/Makeinfo	2017-12-29 02:25:49 -0800
+++ src/libs/network/socket/Makeinfo	2017-12-29 00:57:41 -0800
@@ -1,7 +1,11 @@
 uqm_CFILES="socket.c"
+uqm_HFILES="socket.h"
+
 if [ -n "$uqm_USE_WINSOCK" ]; then
 	uqm_CFILES="$uqm_CFILES socket_win.c"
+	uqm_HFILES="$uqm_HFILES socket_win.h"
 else
 	uqm_CFILES="$uqm_CFILES socket_bsd.c"
+	uqm_HFILES="$uqm_CFILES socket_bsd.h"
 fi
 
diff -ruNp src.hd/libs/network/socket/socket.h src/libs/network/socket/socket.h
--- src.hd/libs/network/socket/socket.h	2017-12-29 02:25:49 -0800
+++ src/libs/network/socket/socket.h	2017-12-29 00:57:41 -0800
@@ -80,7 +80,11 @@ int Socket_bind(Socket *sock, const stru
 int Socket_listen(Socket *sock, int backlog);
 Socket *Socket_accept(Socket *sock, struct sockaddr *addr, socklen_t *addrLen);
 ssize_t Socket_send(Socket *sock, const void *buf, size_t len, int flags);
+ssize_t Socket_sendto(Socket *sock, const void *buf, size_t len, int flags,
+		const struct sockaddr *addr, socklen_t addrLen);
 ssize_t Socket_recv(Socket *sock, void *buf, size_t len, int flags);
+ssize_t Socket_recvfrom(Socket *sock, void *buf, size_t len, int flags,
+		struct sockaddr *from, socklen_t *fromLen);
 
 int Socket_setNonBlocking(Socket *sock);
 int Socket_setReuseAddr(Socket *sock);
diff -ruNp src.hd/libs/network/socket/socket_bsd.c src/libs/network/socket/socket_bsd.c
--- src.hd/libs/network/socket/socket_bsd.c	2017-12-29 02:25:49 -0800
+++ src/libs/network/socket/socket_bsd.c	2017-12-29 00:57:41 -0800
@@ -130,10 +130,22 @@ Socket_send(Socket *sock, const void *bu
 }
 
 ssize_t
+Socket_sendto(Socket *sock, const void *buf, size_t len, int flags,
+		const struct sockaddr *addr, socklen_t addrLen) {
+	return sendto(sock->fd, buf, len, flags, addr, addrLen);
+}
+
+ssize_t
 Socket_recv(Socket *sock, void *buf, size_t len, int flags) {
 	return recv(sock->fd, buf, len, flags);
 }
 
+ssize_t
+Socket_recvfrom(Socket *sock, void *buf, size_t len, int flags,
+		struct sockaddr *from, socklen_t *fromLen) {
+	return recvfrom(sock->fd, buf, len, flags, from, fromLen);
+}
+
 int
 Socket_setNonBlocking(Socket *sock) {
 	int flags;
diff -ruNp src.hd/libs/network/socket/socket_win.c src/libs/network/socket/socket_win.c
--- src.hd/libs/network/socket/socket_win.c	2017-12-29 02:25:49 -0800
+++ src/libs/network/socket/socket_win.c	2017-12-29 00:57:41 -0800
@@ -160,6 +160,20 @@ Socket_send(Socket *sock, const void *bu
 }
 
 ssize_t
+Socket_sendto(Socket *sock, const void *buf, size_t len, int flags,
+		const struct sockaddr *addr, socklen_t addrLen) {
+	int sendResult;
+
+	sendResult = sendto(sock->sock, buf, len, flags, addr, addrLen);
+	if (sendResult == SOCKET_ERROR) {
+		errno = getWinsockErrno();
+		return -1;
+	}
+
+	return sendResult;
+}
+
+ssize_t
 Socket_recv(Socket *sock, void *buf, size_t len, int flags) {
 	int recvResult;
 
@@ -167,6 +181,20 @@ Socket_recv(Socket *sock, void *buf, siz
 	if (recvResult == SOCKET_ERROR) {
 		errno = getWinsockErrno();
 		return -1;
+	}
+
+	return recvResult;
+}
+
+ssize_t
+Socket_recvfrom(Socket *sock, void *buf, size_t len, int flags,
+		struct sockaddr *from, socklen_t *fromLen) {
+	int recvResult;
+
+	recvResult = recvfrom(sock->sock, buf, len, flags, from, fromLen);
+	if (recvResult == SOCKET_ERROR) {
+		errno = getWinsockErrno();
+		return -1;
 	}
 
 	return recvResult;
diff -ruNp src.hd/libs/platform.h src/libs/platform.h
--- src.hd/libs/platform.h	2017-12-29 02:25:49 -0800
+++ src/libs/platform.h	2017-12-29 00:57:41 -0800
@@ -17,6 +17,10 @@
 #ifndef PLATFORM_H_
 #define PLATFORM_H_
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #if defined(USE_PLATFORM_ACCEL)
 #	if defined(__GNUC__) && (defined(i386) || defined(__x86_64__))
 #		define MMX_ASM
@@ -46,4 +50,8 @@ typedef enum
 
 extern PLATFORM_TYPE force_platform;
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* PLATFORM_H_ */
diff -ruNp src.hd/libs/reslib.h src/libs/reslib.h
--- src.hd/libs/reslib.h	2017-12-29 02:25:49 -0800
+++ src/libs/reslib.h	2017-12-29 00:57:41 -0800
@@ -25,6 +25,10 @@
 #include "libs/memlib.h"
 #include "libs/uio.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef struct resource_index_desc RESOURCE_INDEX_DESC;
 typedef RESOURCE_INDEX_DESC *RESOURCE_INDEX;
 
@@ -33,6 +37,7 @@ typedef const char *RESOURCE;
 typedef union {
 	DWORD num;
 	void *ptr;
+	const char *str;
 } RESOURCE_DATA;
 
 #define NULL_RESOURCE NULL
@@ -78,8 +83,16 @@ void *GetResourceData (uio_Stream *fp, D
 #define AllocResourceData HMalloc
 BOOLEAN FreeResourceData (void *);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #include "libs/strlib.h"
 #include "libs/gfxlib.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
 		// For Color
 
 typedef STRING_TABLE DIRENTRY_REF;
@@ -120,4 +133,8 @@ void res_PutColor (const char *key, Colo
 
 BOOLEAN res_Remove (const char *key);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _RESLIB_H */
diff -ruNp src.hd/libs/resource/Makeinfo src/libs/resource/Makeinfo
--- src.hd/libs/resource/Makeinfo	2017-12-29 02:25:49 -0800
+++ src/libs/resource/Makeinfo	2017-12-29 00:57:41 -0800
@@ -1,2 +1,3 @@
 uqm_CFILES="direct.c filecntl.c getres.c loadres.c stringbank.c
 		propfile.c resinit.c"
+uqm_HFILES="index.h propfile.h resintrn.h stringbank.h"
diff -ruNp src.hd/libs/resource/index.h src/libs/resource/index.h
--- src.hd/libs/resource/index.h	2017-12-29 02:25:49 -0800
+++ src/libs/resource/index.h	2017-12-29 00:57:41 -0800
@@ -19,19 +19,22 @@
 #ifndef _INDEX_H
 #define _INDEX_H
 
+typedef struct resource_handlers ResourceHandlers;
+typedef struct resource_desc ResourceDesc;
+
 #include <stdio.h>
 #include "libs/reslib.h"
 #include "libs/uio/charhashtable.h"
 
-typedef struct resource_handlers
+struct resource_handlers
 {
 	const char *resType;
 	ResourceLoadFun *loadFun;
 	ResourceFreeFun *freeFun;
 	ResourceStringFun *toString;
-} ResourceHandlers;
+};
 
-typedef struct resource_desc
+struct resource_desc
 {
 	RESOURCE res_id;
 	char *fname;
@@ -39,7 +42,7 @@ typedef struct resource_desc
 	RESOURCE_DATA resdata;
 	// refcount is rudimentary as nothing really frees the descriptors
 	unsigned refcount;
-} ResourceDesc;
+};
 
 struct resource_index_desc
 {
diff -ruNp src.hd/libs/resource/resinit.c src/libs/resource/resinit.c
--- src.hd/libs/resource/resinit.c	2017-12-29 02:25:49 -0800
+++ src/libs/resource/resinit.c	2017-12-29 00:57:41 -0800
@@ -34,7 +34,8 @@
 static RESOURCE_INDEX
 allocResourceIndex (void) {
 	RESOURCE_INDEX ndx = HMalloc (sizeof (RESOURCE_INDEX_DESC));
-	ndx->map = CharHashTable_newHashTable (NULL, NULL, NULL, NULL, 0, 0.85, 0.9);
+	ndx->map = CharHashTable_newHashTable (NULL, NULL, NULL, NULL, NULL,
+			0, 0.85, 0.9);
 	return ndx;
 }
 
@@ -138,7 +139,7 @@ process_resource_desc (const char *key,
 static void
 UseDescriptorAsRes (const char *descriptor, RESOURCE_DATA *resdata)
 {
-	resdata->ptr = (void *)descriptor;
+	resdata->str = descriptor;
 }
 
 static void
@@ -285,7 +286,7 @@ fail:
 static void
 RawDescriptor (RESOURCE_DATA *resdata, char *buf, unsigned int size)
 {
-	snprintf (buf, size, "%s", (char *)resdata->ptr);
+	snprintf (buf, size, "%s", resdata->str);
 }
 
 static void
@@ -474,12 +475,12 @@ res_GetString (const char *key)
 {
 	RESOURCE_INDEX idx = _get_current_index_header ();
 	ResourceDesc *desc = lookupResourceDesc (idx, key);
-	if (!desc || !desc->resdata.ptr || strcmp(desc->vtable->resType, "STRING"))
+	if (!desc || !desc->resdata.str || strcmp(desc->vtable->resType, "STRING"))
 		return "";
 	/* TODO: Work out exact STRING semantics, specifically, the lifetime of
 	 *   the returned value. If caller is allowed to reference the returned
 	 *   value forever, STRING has to be ref-counted. */
-	return (const char *)desc->resdata.ptr;
+	return desc->resdata.str;
 }
 
 void
@@ -488,24 +489,24 @@ res_PutString (const char *key, const ch
 	RESOURCE_INDEX idx = _get_current_index_header ();
 	ResourceDesc *desc = lookupResourceDesc (idx, key);
 	int srclen, dstlen;
-	if (!desc || !desc->resdata.ptr || strcmp(desc->vtable->resType, "STRING"))
+	if (!desc || !desc->resdata.str || strcmp(desc->vtable->resType, "STRING"))
 	{
 		/* TODO: This is kind of roundabout. We can do better by refactoring newResourceDesc */
 		process_resource_desc(key, "STRING:undefined");
 		desc = lookupResourceDesc (idx, key);
 	}
 	srclen = strlen (value);
-	dstlen = strlen (desc->resdata.ptr);
+	dstlen = strlen (desc->fname);
 	if (srclen > dstlen) {
 		char *newValue = HMalloc(srclen + 1);
 		char *oldValue = desc->fname;
 		log_add(log_Warning, "Reallocating string space for '%s'", key);
 		strncpy (newValue, value, srclen + 1);
-		desc->resdata.ptr = newValue;
+		desc->resdata.str = newValue;
 		desc->fname = newValue;
 		HFree (oldValue);
 	} else {
-		strncpy (desc->resdata.ptr, value, srclen + 1);
+		strncpy (desc->fname, value, srclen + 1);
 	}
 }
 
diff -ruNp src.hd/libs/scriptlib.h src/libs/scriptlib.h
--- src.hd/libs/scriptlib.h	1969-12-31 16:00:00 -0800
+++ src/libs/scriptlib.h	2017-12-29 00:57:41 -0800
@@ -0,0 +1,23 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _SCRIPTLIB_H
+#define _SCRIPTLIB_H
+
+#include "luauqm/luauqm.h"
+
+#endif  /* _SCRIPTLIB_H */
+
diff -ruNp src.hd/libs/sndlib.h src/libs/sndlib.h
--- src.hd/libs/sndlib.h	2017-12-29 02:25:50 -0800
+++ src/libs/sndlib.h	2017-12-29 00:57:41 -0800
@@ -22,6 +22,10 @@
 #include "port.h"
 #include "libs/strlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef STRING_TABLE SOUND_REF;
 typedef STRING SOUND;
 // SOUNDPTR is really a TFB_SoundSample**
@@ -95,5 +99,9 @@ extern void WaitForSoundEnd (COUNT Chann
 
 extern DWORD FadeMusic (BYTE end_vol, SIZE TimeInterval);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _SNDLIB_H */
 
diff -ruNp src.hd/libs/sound/Makeinfo src/libs/sound/Makeinfo
--- src.hd/libs/sound/Makeinfo	2017-12-29 02:25:50 -0800
+++ src/libs/sound/Makeinfo	2017-12-29 00:57:41 -0800
@@ -6,4 +6,4 @@ else
 fi
 
 uqm_CFILES="audiocore.c fileinst.c resinst.c sound.c sfx.c music.c stream.c trackplayer.c"
-
+uqm_HFILES="audiocore.h sndintrn.h sound.h stream.h trackint.h trackplayer.h"
diff -ruNp src.hd/libs/sound/audiocore.c src/libs/sound/audiocore.c
--- src.hd/libs/sound/audiocore.c	2017-12-29 02:25:50 -0800
+++ src/libs/sound/audiocore.c	2017-12-29 00:57:41 -0800
@@ -20,6 +20,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include "audiocore.h"
+#include "sound.h"
 #include "libs/log.h"
 
 static audio_Driver audiodrv;
@@ -76,6 +77,10 @@ initAudio (sint32 driver, sint32 flags)
 				"NOTICE: Try running UQM with '--sound=none' option");
 		exit (EXIT_FAILURE);
 	}
+
+	SetSFXVolume (sfxVolumeScale);
+	SetSpeechVolume (speechVolumeScale);
+	SetMusicVolume (musicVolume);
 	
 	audio_inited = true;
 	
diff -ruNp src.hd/libs/sound/decoders/Makeinfo src/libs/sound/decoders/Makeinfo
--- src.hd/libs/sound/decoders/Makeinfo	2017-12-29 02:25:50 -0800
+++ src/libs/sound/decoders/Makeinfo	2017-12-29 00:57:41 -0800
@@ -1,6 +1,8 @@
 uqm_CFILES="decoder.c aiffaud.c wav.c dukaud.c modaud.c"
+uqm_HFILES="aiffaud.h decoder.h dukaud.h modaud.h wav.h"
 
 if [ "$uqm_OGGVORBIS" '!=' "none" ]; then
 	uqm_CFILES="$uqm_CFILES oggaud.c"
+	uqm_HFILES="$uqm_HFILES oggaud.h"
 fi
 
diff -ruNp src.hd/libs/sound/decoders/aiffaud.c src/libs/sound/decoders/aiffaud.c
--- src.hd/libs/sound/decoders/aiffaud.c	2017-12-29 02:25:50 -0800
+++ src/libs/sound/decoders/aiffaud.c	2017-12-29 00:57:41 -0800
@@ -307,7 +307,7 @@ aifa_readCommonChunk (TFB_AiffSoundDecod
 {
 	int bytes;
 
-	memset(fmt, sizeof(*fmt), 0);
+	memset(fmt, 0, sizeof(*fmt));
 	if (size < AIFF_COMM_SIZE)
 	{
 		aifa->last_error = aifae_BadFile;
@@ -369,7 +369,7 @@ aifa_Open (THIS_PTR, uio_DirHandle *dir,
 	aifa->max_pcm = 0;
 	aifa->data_ofs = 0;
 	memset(&aifa->fmtHdr, 0, sizeof(aifa->fmtHdr));
-	memset(aifa->prev_val, sizeof(aifa->prev_val), 0);
+	memset(aifa->prev_val, 0, sizeof(aifa->prev_val));
 
 	// read wave header
 	if (!aifa_readFileHeader (aifa, &fileHdr))
@@ -635,7 +635,7 @@ aifa_Seek (THIS_PTR, uint32 pcm_pos)
 
 	// reset previous values for SDX2 on seek ops
 	// the delta will recover faster with reset
-	memset(aifa->prev_val, sizeof(aifa->prev_val), 0);
+	memset(aifa->prev_val, 0, sizeof(aifa->prev_val));
 
 	return pcm_pos;
 }
diff -ruNp src.hd/libs/sound/decoders/dukaud.c src/libs/sound/decoders/dukaud.c
--- src.hd/libs/sound/decoders/dukaud.c	2017-12-29 02:25:50 -0800
+++ src/libs/sound/decoders/dukaud.c	2017-12-29 00:57:41 -0800
@@ -105,7 +105,7 @@ typedef struct
 
 static const TFB_DecoderFormats* duka_formats = NULL;
 
-sint32
+static sint32
 duka_readAudFrameHeader (TFB_DuckSoundDecoder* duka, uint32 iframe,
 		DukAud_AudSubframe* aud)
 {
@@ -246,7 +246,7 @@ decode_nibbles (sint16 *output, sint32 o
 }
 // *** END part copied from MPlayer ***
 
-sint32
+static sint32
 duka_decodeFrame (TFB_DuckSoundDecoder* duka, DukAud_AudSubframe* header,
 		uint8* input)
 {
@@ -273,7 +273,7 @@ duka_decodeFrame (TFB_DuckSoundDecoder*
 }
 
 
-sint32
+static sint32
 duka_readNextFrame (TFB_DuckSoundDecoder* duka)
 {
 	DukAud_FrameHeader hdr;
diff -ruNp src.hd/libs/sound/decoders/modaud.c src/libs/sound/decoders/modaud.c
--- src.hd/libs/sound/decoders/modaud.c	2017-12-29 02:25:50 -0800
+++ src/libs/sound/decoders/modaud.c	2017-12-29 00:57:41 -0800
@@ -88,7 +88,7 @@ static void* buffer;
 static ULONG bufsize;
 static ULONG written;
 
-ULONG*
+static ULONG*
 moda_mmout_SetOutputBuffer (void* buf, ULONG size)
 {
 	buffer = buf;
@@ -132,12 +132,18 @@ moda_mmout_Reset (void)
     return 0;
 }
 
+static char MDRIVER_name[] = "Mem Buffer";
+static char MDRIVER_version[] = "Mem Buffer driver v1.1";
+static char MDRIVER_alias[] = "membuf";
+
 static MDRIVER moda_mmout_drv =
-{   NULL,
-    "Mem Buffer",              // Name
-    "Mem Buffer driver v1.1",  // Version
-    0, 255,                    // Voice limits
-    "membuf",                  // Alias
+{
+	NULL,
+	//xxx libmikmod does not declare these fields const; it probably should.
+	MDRIVER_name,              // Name
+	MDRIVER_version,           // Version
+	0, 255,                    // Voice limits
+	MDRIVER_alias,             // Alias
 
 // The minimum mikmod version we support is 3.1.8
 #if (LIBMIKMOD_VERSION_MAJOR > 3) || \
@@ -215,7 +221,7 @@ moda_uioReader_Tell (MREADER* reader)
 	return uio_ftell (((MUIOREADER*)reader)->file);
 }
 
-MREADER*
+static MREADER*
 moda_new_uioReader (uio_Stream* fp)
 {
 	MUIOREADER* reader = (MUIOREADER*) HMalloc (sizeof(MUIOREADER));
@@ -231,7 +237,7 @@ moda_new_uioReader (uio_Stream* fp)
 	return (MREADER*)reader;
 }
 
-void
+static void
 moda_delete_uioReader (MREADER* reader)
 {
 	if (reader)
@@ -276,7 +282,7 @@ moda_InitModule (int flags, const TFB_De
 	
 	md_pansep = 64;
 
-	if (MikMod_Init (""))
+	if (MikMod_Init (NULL))
 	{
 		log_add (log_Error, "MikMod_Init() failed, %s", 
 			MikMod_strerror (MikMod_errno));
diff -ruNp src.hd/libs/sound/mixer/Makeinfo src/libs/sound/mixer/Makeinfo
--- src.hd/libs/sound/mixer/Makeinfo	2017-12-29 02:25:50 -0800
+++ src/libs/sound/mixer/Makeinfo	2017-12-29 00:57:41 -0800
@@ -1,2 +1,3 @@
 uqm_SUBDIRS="sdl nosound"
 uqm_CFILES="mixer.c"
+uqm_HFILES="mixer.h mixerint.h"
diff -ruNp src.hd/libs/sound/mixer/mixer.c src/libs/sound/mixer/mixer.c
--- src.hd/libs/sound/mixer/mixer.c	2017-12-29 02:25:50 -0800
+++ src/libs/sound/mixer/mixer.c	2017-12-29 00:57:41 -0800
@@ -1569,7 +1569,7 @@ mixer_ResampleNone (mixer_Source *src, b
 	uint8 *d0 = src->nextqueued->data + src->pos;
 	src->pos += mixer_chansize;
 	(void) left; // satisfying compiler - unused arg
-	return (float)mixer_GetSampleInt (d0, mixer_chansize);
+	return mixer_GetSampleInt (d0, mixer_chansize);
 }
 
 /* get a resampled (up/down) sample from source (nearest neighbor) */
@@ -1578,7 +1578,7 @@ mixer_ResampleNearest (mixer_Source *src
 {
 	uint8 *d0 = src->nextqueued->data + src->pos;
 	d0 += mixer_SourceAdvance (src, left);
-	return (float)mixer_GetSampleInt (d0, mixer_chansize);
+	return mixer_GetSampleInt (d0, mixer_chansize);
 }
 
 /* get an upsampled sample from source (linear interpolation) */
@@ -1608,8 +1608,8 @@ mixer_UpsampleLinear (mixer_Source *src,
 	else
 		d1 = d0 + curr->sampsize;
 
-	s0 = (float)mixer_GetSampleInt (d0, mixer_chansize);
-	s1 = (float)mixer_GetSampleInt (d1, mixer_chansize);
+	s0 = mixer_GetSampleInt (d0, mixer_chansize);
+	s1 = mixer_GetSampleInt (d1, mixer_chansize);
 	return s0 + t * (s1 - s0);
 }
 
@@ -1672,10 +1672,10 @@ mixer_UpsampleCubic (mixer_Source *src,
 			d3 = d2 + curr->sampsize;
 	}
 
-	s0 = (float)mixer_GetSampleInt (d0, mixer_chansize);
-	s1 = (float)mixer_GetSampleInt (d1, mixer_chansize);
-	s2 = (float)mixer_GetSampleInt (d2, mixer_chansize);
-	s3 = (float)mixer_GetSampleInt (d3, mixer_chansize);
+	s0 = mixer_GetSampleInt (d0, mixer_chansize);
+	s1 = mixer_GetSampleInt (d1, mixer_chansize);
+	s2 = mixer_GetSampleInt (d2, mixer_chansize);
+	s3 = mixer_GetSampleInt (d3, mixer_chansize);
 
 	a = (3.0f * (s1 - s2) - s0 + s3) * 0.5f;
 	b = 2.0f * s2 + s0 - ((5.0f * s1 + s3) * 0.5f);
diff -ruNp src.hd/libs/sound/mixer/nosound/Makeinfo src/libs/sound/mixer/nosound/Makeinfo
--- src.hd/libs/sound/mixer/nosound/Makeinfo	2017-12-29 02:25:50 -0800
+++ src/libs/sound/mixer/nosound/Makeinfo	2017-12-29 00:57:41 -0800
@@ -1 +1,2 @@
 uqm_CFILES="audiodrv_nosound.c"
+uqm_HFILES="audiodrv_nosound.h"
diff -ruNp src.hd/libs/sound/mixer/nosound/audiodrv_nosound.c src/libs/sound/mixer/nosound/audiodrv_nosound.c
--- src.hd/libs/sound/mixer/nosound/audiodrv_nosound.c	2017-12-29 02:25:50 -0800
+++ src/libs/sound/mixer/nosound/audiodrv_nosound.c	2017-12-29 00:57:41 -0800
@@ -146,12 +146,6 @@ noSound_Init (audio_Driver *driver, sint
 		return -1;
 	}
 
-	atexit (unInitAudio);
-
-	SetSFXVolume (sfxVolumeScale);
-	SetSpeechVolume (speechVolumeScale);
-	SetMusicVolume ((COUNT)musicVolume);
-		
 	PlaybackTask = AssignTask (PlaybackTaskFunc, 1024, 
 		"nosound audio playback");
 
@@ -215,7 +209,7 @@ PlaybackTaskFunc (void *data)
 		mixer_MixFake (NULL, stream, len);
 		delay = period - (GetTimeCounter () - entryTime);
 		if (delay > 0)
-			SleepThread (delay);
+			HibernateThread (delay);
 	}
 
 	HFree (stream);
diff -ruNp src.hd/libs/sound/mixer/sdl/Makeinfo src/libs/sound/mixer/sdl/Makeinfo
--- src.hd/libs/sound/mixer/sdl/Makeinfo	2017-12-29 02:25:50 -0800
+++ src/libs/sound/mixer/sdl/Makeinfo	2017-12-29 00:57:41 -0800
@@ -1 +1,2 @@
 uqm_CFILES="audiodrv_sdl.c"
+uqm_HFILES="audiodrv_sdl.h"
diff -ruNp src.hd/libs/sound/mixer/sdl/audiodrv_sdl.c src/libs/sound/mixer/sdl/audiodrv_sdl.c
--- src.hd/libs/sound/mixer/sdl/audiodrv_sdl.c	2017-12-29 02:25:50 -0800
+++ src/libs/sound/mixer/sdl/audiodrv_sdl.c	2017-12-29 00:57:41 -0800
@@ -90,6 +90,8 @@ static const audio_Driver mixSDL_Driver
 };
 
 
+static void audioCallback (void *userdata, Uint8 *stream, int len);
+
 /*
  * Initialization
  */
@@ -143,7 +145,7 @@ mixSDL_Init (audio_Driver *driver, sint3
 
 	desired.format = AUDIO_S16SYS;
 	desired.channels = 2;
-	desired.callback = mixer_MixChannels;
+	desired.callback = audioCallback;
 	
 	log_add (log_Info, "Opening SDL audio device.");
 	if (SDL_OpenAudio (&desired, &obtained) < 0)
@@ -210,12 +212,6 @@ mixSDL_Init (audio_Driver *driver, sint3
 		return -1;
 	}
 
-	atexit (unInitAudio);
-
-	SetSFXVolume (sfxVolumeScale);
-	SetSpeechVolume (speechVolumeScale);
-	SetMusicVolume ((COUNT)musicVolume);
-				
 	SDL_PauseAudio (0);
 		
 	return 0;
@@ -241,6 +237,7 @@ mixSDL_Uninit (void)
 			HFree (sbuffer);
 		}
 		DestroyMutex (soundSource[i].stream_mutex);
+		soundSource[i].stream_mutex = 0;
 
 		mixSDL_DeleteSources (1, &soundSource[i].handle);
 	}
@@ -251,6 +248,11 @@ mixSDL_Uninit (void)
 	SDL_QuitSubSystem (SDL_INIT_AUDIO);
 }
 
+static void
+audioCallback (void *userdata, Uint8 *stream, int len)
+{
+	mixer_MixChannels (userdata, stream, len);
+}
 
 /*
  * General
diff -ruNp src.hd/libs/sound/openal/Makeinfo src/libs/sound/openal/Makeinfo
--- src.hd/libs/sound/openal/Makeinfo	2017-12-29 02:25:50 -0800
+++ src/libs/sound/openal/Makeinfo	2017-12-29 00:57:41 -0800
@@ -1 +1,2 @@
 uqm_CFILES="audiodrv_openal.c"
+uqm_HFILES="audiodrv_openal.h"
diff -ruNp src.hd/libs/sound/openal/audiodrv_openal.c src/libs/sound/openal/audiodrv_openal.c
--- src.hd/libs/sound/openal/audiodrv_openal.c	2017-12-29 02:25:50 -0800
+++ src/libs/sound/openal/audiodrv_openal.c	2017-12-29 00:57:41 -0800
@@ -126,7 +126,6 @@ openAL_Init (audio_Driver *driver, sint3
 	}
 
 	*driver = openAL_Driver;
-	atexit (unInitAudio);
 
 	alcContext = alcCreateContext (alcDevice, NULL);
 	if (!alcContext)
@@ -193,14 +192,7 @@ openAL_Init (audio_Driver *driver, sint3
 		return -1;
 	}
 	
-	SetSFXVolume (sfxVolumeScale);
-	SetSpeechVolume (speechVolumeScale);
-	SetMusicVolume ((COUNT) musicVolume);
-
-	if (optStereoSFX)
-		alDistanceModel (AL_INVERSE_DISTANCE);
-	else
-		alDistanceModel (AL_NONE);
+	alDistanceModel (AL_INVERSE_DISTANCE);
 
 	(void) driver; // eat compiler warning
 
diff -ruNp src.hd/libs/sound/openal/audiodrv_openal.h src/libs/sound/openal/audiodrv_openal.h
--- src.hd/libs/sound/openal/audiodrv_openal.h	2017-12-29 02:25:50 -0800
+++ src/libs/sound/openal/audiodrv_openal.h	2017-12-29 00:57:41 -0800
@@ -22,7 +22,6 @@
 
 #include "config.h"
 #include "libs/sound/sound.h"
-#include "options.h"
 #include "endian_uqm.h"
 
 #if defined (__APPLE__)
diff -ruNp src.hd/libs/sound/sfx.c src/libs/sound/sfx.c
--- src.hd/libs/sound/sfx.c	2017-12-29 02:25:50 -0800
+++ src/libs/sound/sfx.c	2017-12-29 00:57:41 -0800
@@ -29,6 +29,7 @@
 
 static void CheckFinishedChannels (void);
 
+static const SoundPosition notPositional = {FALSE, 0, 0};
 
 void
 PlayChannel (COUNT channel, SOUND snd, SoundPosition pos,
@@ -50,8 +51,7 @@ PlayChannel (COUNT channel, SOUND snd, S
 	soundSource[channel].sample = sample;
 	soundSource[channel].positional_object = positional_object;
 	
-	if (optStereoSFX)
-		UpdateSoundPosition (channel, pos);
+	UpdateSoundPosition (channel, optStereoSFX ? pos : notPositional);
 
 	audio_Sourcei (soundSource[channel].handle, audio_BUFFER,
 			sample->buffer[0]);
diff -ruNp src.hd/libs/sound/sndintrn.h src/libs/sound/sndintrn.h
--- src.hd/libs/sound/sndintrn.h	2017-12-29 02:25:50 -0800
+++ src/libs/sound/sndintrn.h	2017-12-29 00:57:41 -0800
@@ -46,7 +46,7 @@ struct tfb_soundsample
 	uint32 num_buffers;
 	TFB_SoundTag *buffer_tag;
 	sint32 offset; // initial offset
-	intptr_t data; // user-defined data
+	void* data; // user-defined data
 	TFB_SoundCallbacks callbacks; // user-defined callbacks
 };
 
diff -ruNp src.hd/libs/sound/sound.h src/libs/sound/sound.h
--- src.hd/libs/sound/sound.h	2017-12-29 02:25:50 -0800
+++ src/libs/sound/sound.h	2017-12-29 00:57:41 -0800
@@ -66,8 +66,8 @@ void SetSpeechVolume (float volume);
 TFB_SoundSample *TFB_CreateSoundSample (TFB_SoundDecoder*, uint32 num_buffers,
 		const TFB_SoundCallbacks* /* can be NULL */);
 void TFB_DestroySoundSample (TFB_SoundSample*);
-void TFB_SetSoundSampleData (TFB_SoundSample*, intptr_t data);
-intptr_t TFB_GetSoundSampleData (TFB_SoundSample*);
+void TFB_SetSoundSampleData (TFB_SoundSample*, void* data);
+void* TFB_GetSoundSampleData (TFB_SoundSample*);
 void TFB_SetSoundSampleCallbacks (TFB_SoundSample*,
 		const TFB_SoundCallbacks* /* can be NULL */);
 TFB_SoundDecoder* TFB_GetSoundSampleDecoder (TFB_SoundSample*);
diff -ruNp src.hd/libs/sound/stream.c src/libs/sound/stream.c
--- src.hd/libs/sound/stream.c	2017-12-29 02:25:50 -0800
+++ src/libs/sound/stream.c	2017-12-29 00:57:41 -0800
@@ -225,12 +225,12 @@ TFB_DestroySoundSample (TFB_SoundSample
 }
 
 void
-TFB_SetSoundSampleData (TFB_SoundSample *sample, intptr_t data)
+TFB_SetSoundSampleData (TFB_SoundSample *sample, void* data)
 {
 	sample->data = data;
 }
 
-intptr_t
+void*
 TFB_GetSoundSampleData (TFB_SoundSample *sample)
 {
 	return sample->data;
@@ -568,7 +568,7 @@ StreamDecoderTaskFunc (void *data)
 
 		if (active_streams == 0) 
 		{	// Throttle down the thread when there are no active streams
-			SleepThread (ONE_SECOND / 10);
+			HibernateThread (ONE_SECOND / 10);
 		}
 		else
 			TaskSwitch ();
@@ -593,7 +593,8 @@ readSoundSample (void *ptr, int sample_s
 // We use AGC because different pieces of music and speech can easily be
 // at very different gain levels, because the game is moddable.
 int
-GraphForegroundStream (uint8 *data, sint32 width, sint32 height)
+GraphForegroundStream (uint8 *data, sint32 width, sint32 height,
+		bool wantSpeech)
 {
 	int source_num;
 	TFB_SoundSource *source;
@@ -634,7 +635,7 @@ GraphForegroundStream (uint8 *data, sint
 	source_num = SPEECH_SOURCE;
 	source = &soundSource[source_num];
 	LockMutex (source->stream_mutex);
-	if (speechVolumeScale != 0.0f && (!source->sample ||
+	if (wantSpeech && (!source->sample ||
 			!source->sample->decoder || !source->sample->decoder->is_null))
 	{	// Use speech waveform, since it's available
 		// Step is picked experimentally. Using step of 1 sample at 11025Hz,
@@ -642,9 +643,10 @@ GraphForegroundStream (uint8 *data, sint
 		// better this way.
 		step = 1;
 	}
-	else if (musicVolumeScale != 0.0f)
+	else
 	{	// We do not have speech -- use music waveform
 		UnlockMutex (source->stream_mutex);
+
 		source_num = MUSIC_SOURCE;
 		source = &soundSource[source_num];
 		LockMutex (source->stream_mutex);
@@ -653,11 +655,6 @@ GraphForegroundStream (uint8 *data, sint
 		// It looks better this way.
 		step = 4;
 	}
-	else
-	{	// We do not have anything usable
-		UnlockMutex (source->stream_mutex);
-		return 0;
-	}
 
 	if (!PlayingStream (source_num) || !source->sample
 			|| !source->sample->decoder || !source->sbuffer
diff -ruNp src.hd/libs/sound/stream.h src/libs/sound/stream.h
--- src.hd/libs/sound/stream.h	2017-12-29 02:25:50 -0800
+++ src/libs/sound/stream.h	2017-12-29 00:57:41 -0800
@@ -28,7 +28,8 @@ void ResumeStream (uint32 source);
 void SeekStream (uint32 source, uint32 pos);
 BOOLEAN PlayingStream (uint32 source);
 
-int GraphForegroundStream (uint8 *data, sint32 width, sint32 height);
+int GraphForegroundStream (uint8 *data, sint32 width, sint32 height,
+		bool wantSpeech);
 
 // returns TRUE if the fade was accepted by stream decoder
 bool SetMusicStreamFade (sint32 howLong, int endVolume);
diff -ruNp src.hd/libs/sound/trackint.h src/libs/sound/trackint.h
--- src.hd/libs/sound/trackint.h	2017-12-29 02:25:50 -0800
+++ src/libs/sound/trackint.h	2017-12-29 00:57:41 -0800
@@ -17,6 +17,8 @@
 #ifndef TRACKINT_H
 #define TRACKINT_H
 
+#include "libs/callback.h"
+
 struct tfb_soundchunk
 {
 	TFB_SoundDecoder *decoder;  // decoder for this chunk
@@ -24,7 +26,7 @@ struct tfb_soundchunk
 	int tag_me;                 // set for chunks with subtitles
 	uint32 track_num;           // logical track #, comm code needs this
 	UNICODE *text;              // subtitle text
-	TFB_TrackCB callback;       // comm callback, executed on chunk start
+	CallbackFunction callback;  // comm callback, executed on chunk start
 	struct tfb_soundchunk *next;
 };
 
diff -ruNp src.hd/libs/sound/trackplayer.c src/libs/sound/trackplayer.c
--- src.hd/libs/sound/trackplayer.c	2017-12-29 02:25:50 -0800
+++ src/libs/sound/trackplayer.c	2017-12-29 00:57:41 -0800
@@ -199,7 +199,8 @@ static void
 DoTrackTag (TFB_SoundChunk *chunk)
 {
 	if (chunk->callback)
-		chunk->callback ();
+		Callback_add(chunk->callback, 0);
+	
 	cur_sub_chunk = chunk;
 }
 
@@ -421,7 +422,7 @@ SpliceMultiTrack (UNICODE *TrackNames[],
 
 // XXX: This code and the entire trackplayer are begging to be overhauled
 void
-SpliceTrack (UNICODE *TrackName, UNICODE *TrackText, UNICODE *TimeStamp, TFB_TrackCB cb)
+SpliceTrack (UNICODE *TrackName, UNICODE *TrackText, UNICODE *TimeStamp, CallbackFunction cb)
 {
 	static UNICODE last_track_name[128] = "";
 	static unsigned long dec_offset = 0;
diff -ruNp src.hd/libs/sound/trackplayer.h src/libs/sound/trackplayer.h
--- src.hd/libs/sound/trackplayer.h	2017-12-29 02:25:50 -0800
+++ src/libs/sound/trackplayer.h	2017-12-29 00:57:41 -0800
@@ -20,8 +20,7 @@
 #define TRACKPLAYER_H
 
 #include "libs/compiler.h"
-
-typedef void (*TFB_TrackCB) (void);
+#include "libs/callback.h"
 
 #define ACCEL_SCROLL_SPEED 300
 
@@ -37,7 +36,7 @@ extern void FastForward_Smooth (void);
 extern void FastReverse_Page (void);
 extern void FastForward_Page (void);
 
-extern void SpliceTrack (UNICODE *filespec, UNICODE *textspec, UNICODE *TimeStamp, TFB_TrackCB cb);
+extern void SpliceTrack (UNICODE *filespec, UNICODE *textspec, UNICODE *TimeStamp, CallbackFunction cb);
 extern void SpliceMultiTrack (UNICODE *TrackNames[], UNICODE *TrackText);
 
 extern int GetTrackPosition (int in_units);
diff -ruNp src.hd/libs/strings/Makeinfo src/libs/strings/Makeinfo
--- src.hd/libs/strings/Makeinfo	2017-12-29 02:25:50 -0800
+++ src/libs/strings/Makeinfo	2017-12-29 00:57:41 -0800
@@ -1 +1,2 @@
-uqm_CFILES="getstr.c sfileins.c sresins.c strings.c unicode.c"
+uqm_CFILES="getstr.c sfileins.c sresins.c stringhashtable.c strings.c unicode.c"
+uqm_HFILES="stringhashtable.c strintrn.h"
diff -ruNp src.hd/libs/strings/getstr.c src/libs/strings/getstr.c
--- src.hd/libs/strings/getstr.c	2017-12-29 02:25:50 -0800
+++ src/libs/strings/getstr.c	2017-12-29 00:57:41 -0800
@@ -42,8 +42,9 @@ dword_convert (DWORD *dword_array, COUNT
 	} while (--num_dwords);
 }
 
-static void
-set_strtab_entry (STRING_TABLE_DESC *strtab, int index, const char *value, int len)
+static STRING
+set_strtab_entry (STRING_TABLE_DESC *strtab, int index, const char *value,
+		int len)
 {
 	STRING str = &strtab->strings[index];
 
@@ -59,23 +60,107 @@ set_strtab_entry (STRING_TABLE_DESC *str
 		str->length = len;
 		memcpy (str->data, value, len);
 	}
+	return str;
+}
+
+static void
+copy_strings_to_strtab (STRING_TABLE_DESC *strtab, size_t firstIndex,
+		size_t count, const char *data, const DWORD *lens)
+{
+	size_t stringI;
+	const char *off = data;
+
+	for (stringI = 0; stringI < count; stringI++)
+	{
+		set_strtab_entry(strtab, firstIndex + stringI,
+				off, lens[stringI]);
+		off += lens[stringI];
+	}
+}
+
+// Check whether a buffer has a certain minimum size, and enlarge it
+// if necessary.
+// buf: pointer to the pointer to the buffer. May be NULL.
+// curSize: pointer to the current size (multiple of 'increment')
+// minSize: required minimum size
+// increment: size to increment the buffer with if necessary
+// On success, *buf and *curSize are updated. On failure, they are
+// unchanged.
+// returns FALSE if and only if the buffer needs to be enlarged but
+// memory allocation failed.
+static BOOLEAN
+ensureBufSize (char **buf, size_t *curSize, size_t minSize, size_t increment)
+{
+	char *newBuf;
+	size_t newSize;
+
+	if (minSize <= *curSize)
+	{
+		// Buffer is large enough as it is.
+		return TRUE;
+	}
+
+	newSize = ((minSize + (increment - 1)) / increment) * increment;
+			// Smallest multiple of 'increment' larger or equal to minSize.
+	newBuf = HRealloc (*buf, newSize);
+	if (newBuf == NULL)
+		return FALSE;
+
+	// Success
+	*buf = newBuf;
+	*curSize = newSize;
+	return TRUE;
 }
 
 void
 _GetConversationData (const char *path, RESOURCE_DATA *resdata)
 {
-	uio_Stream *fp;
 	unsigned long dataLen;
 	void *result;
-	int n, path_len, num_data_sets;
-	DWORD opos,
-		slen[MAX_STRINGS], StringOffs, tot_string_size,
-		clen[MAX_STRINGS], ClipOffs, tot_clip_size,
-		tslen[MAX_STRINGS], TSOffs;
-	DWORD tot_ts_size = 0;
-	char CurrentLine[1024], paths[1024], *clip_path, *ts_path,
-		*strdata, *clipdata, *ts_data;
+	int stringI;
+	int path_len;
+	int num_data_sets;
+	DWORD opos;
+	
+	char *namedata = NULL;
+			// Contains the names (indexes) of the dialogs.
+	DWORD nlen[MAX_STRINGS];
+			// Length of each of the names.
+	DWORD NameOffs;
+	size_t tot_name_size;
+
+	char *strdata = NULL;
+			// Contains the dialog strings.
+	DWORD slen[MAX_STRINGS];
+			// Length of each of the dialog strings.
+	DWORD StringOffs;
+	size_t tot_string_size;
+
+	char *clipdata = NULL;
+			// Contains the file names of the speech files.
+	DWORD clen[MAX_STRINGS];
+			// Length of each of the speech file names.
+	DWORD ClipOffs;
+	size_t tot_clip_size;
+
+	char *ts_data = NULL;
+			// Contains the timestamp data for synching the text with the
+			// speech.
+	DWORD tslen[MAX_STRINGS];
+			// Length of each of the timestamp strings.
+	DWORD TSOffs;
+	size_t tot_ts_size = 0;
+
+	char CurrentLine[1024];
+	char paths[1024];
+	char *clip_path;
+	char *ts_path;
+
+	uio_Stream *fp = NULL;
 	uio_Stream *timestamp_fp = NULL;
+	StringHashTable_HashTable *nameHashTable = NULL;
+			// Hash table of string names (such as "GLAD_WHEN_YOU_COME_BACK")
+			// to a STRING.
 
 	/* Parse out the conversation components. */
 	strncpy (paths, path, 1023);
@@ -107,7 +192,8 @@ _GetConversationData (const char *path,
 	}
 
 	dataLen = LengthResFile (fp);
-	log_add (log_Info, "\t'%s' -- conversation phrases -- %lu bytes", paths, dataLen);
+	log_add (log_Info, "\t'%s' -- conversation phrases -- %lu bytes", paths,
+			dataLen);
 	if (clip_path)
 		log_add (log_Info, "\t'%s' -- voice clip directory", clip_path);
 	else
@@ -117,90 +203,135 @@ _GetConversationData (const char *path,
 	else
 		log_add (log_Info, "\tNo associated timestamp file");
 
-	
 	if (dataLen == 0)
 	{
-		log_add (log_Warning, "Warning: Trying to load empty file '%s'.", path);
+		log_add (log_Warning, "Warning: Trying to load empty file '%s'.",
+				path);
 		goto err;
 	}
 	
-	if ((strdata = HMalloc (tot_string_size = POOL_SIZE)) == 0)
+	tot_string_size = POOL_SIZE;
+	strdata = HMalloc (tot_string_size);
+	if (strdata == 0)
 		goto err;
 	
-	if ((clipdata = HMalloc (tot_clip_size = POOL_SIZE)) == 0)
-	{
-		HFree (strdata);
+	tot_name_size = POOL_SIZE;
+	namedata = HMalloc (tot_name_size);
+	if (namedata == 0)
+		goto err;
+	
+	tot_clip_size = POOL_SIZE;
+	clipdata = HMalloc (tot_clip_size);
+	if (clipdata == 0)
 		goto err;
-	}
 	ts_data = NULL;
+
+	nameHashTable = StringHashTable_newHashTable(
+			NULL, NULL, NULL, NULL, NULL, 0, 0.85, 0.9);
+	if (nameHashTable == NULL)
+		goto err;
 	
 	path_len = clip_path ? strlen (clip_path) : 0;
 
-	if (ts_path && (timestamp_fp = uio_fopen (contentDir, ts_path,
-			"rb")))
+	if (ts_path)
 	{
-		if ((ts_data = HMalloc (tot_ts_size = POOL_SIZE)) == 0)
-			goto err;
+		timestamp_fp = uio_fopen (contentDir, ts_path, "rb");
+		if (timestamp_fp != NULL)
+		{
+			tot_ts_size = POOL_SIZE;
+			ts_data = HMalloc (tot_ts_size);
+			if (ts_data == 0)
+				goto err;
+		}
 	}
 	
 	opos = uio_ftell (fp);
-	n = -1;
-	StringOffs = ClipOffs = TSOffs = 0;
-	while (uio_fgets (CurrentLine, sizeof (CurrentLine), fp) && n < MAX_STRINGS - 1)
+	stringI = -1;
+	NameOffs = 0;
+	StringOffs = 0;
+	ClipOffs = 0;
+	TSOffs = 0;
+	for (;;)
 	{
 		int l;
 
+		if (uio_fgets (CurrentLine, sizeof (CurrentLine), fp) == NULL)
+		{
+			// EOF or read error.
+			break;
+		}
+	
+		if (stringI >= MAX_STRINGS - 1)
+		{
+			// Too many strings.
+			break;
+		}
+
 		if (CurrentLine[0] == '#')
 		{
+			// String header, of the following form:
+			//     #(GLAD_WHEN_YOU_COME_BACK) commander-000.ogg
 			char CopyLine[1024];
-			char *s;
+			char *name;
+			char *ts;
 
 			strcpy (CopyLine, CurrentLine);
-			s = strtok (&CopyLine[1], "()");
-			if (s)
+			name = strtok (&CopyLine[1], "()");
+			if (name)
 			{
-				if (n >= 0)
+				if (stringI >= 0)
 				{
-					while (slen[n] > 1 && 
+					while (slen[stringI] > 1 &&
 							(strdata[StringOffs - 2] == '\n' ||
 							strdata[StringOffs - 2] == '\r'))
 					{
-						--slen[n];
+						--slen[stringI];
 						--StringOffs;
 						strdata[StringOffs - 1] = '\0';
 					}
 				}
 
-				slen[++n] = 0;
+				slen[++stringI] = 0;
+
+				// Store the string name.
+				l = strlen (name) + 1;
+				if (!ensureBufSize (&namedata, &tot_name_size,
+						NameOffs + l, POOL_SIZE))
+					goto err;
+				strcpy (&namedata[NameOffs], name);
+				NameOffs += l;
+				nlen[stringI] = l;
+
 				// now lets check for timestamp data
 				if (timestamp_fp)
 				{
-					char TimeStampLine[1024], *tsptr;
+					// We have a time stamp file.
+					char TimeStampLine[1024];
+					char *tsptr;
 					BOOLEAN ts_ok = FALSE;
 					uio_fgets (TimeStampLine, sizeof (TimeStampLine), timestamp_fp);
 					if (TimeStampLine[0] == '#')
 					{
-						tslen[n] = 0;
-						if ((tsptr = strstr (TimeStampLine,s)) 
-								&& (tsptr += strlen(s))
-								&& (++tsptr))
+						// Line is of the following form:
+						//     #(GIVE_FUEL_AGAIN) 3304,3255
+						tslen[stringI] = 0;
+						tsptr = strstr (TimeStampLine, name);
+						if (tsptr)
 						{
+							tsptr += strlen(name) + 1;
 							ts_ok = TRUE;
 							while (! strcspn(tsptr," \t\r\n") && *tsptr)
 								tsptr++;
 							if (*tsptr)
 							{
-								l = strlen (tsptr)  + 1;
-								if (TSOffs + l > tot_ts_size
-									&& (ts_data = HRealloc (ts_data,
-										tot_ts_size += POOL_SIZE)) == 0)
-								{
-									HFree (strdata);
+								l = strlen (tsptr) + 1;
+								if (!ensureBufSize (&ts_data, &tot_ts_size, TSOffs + l,
+										POOL_SIZE))
 									goto err;
-								}
+
 								strcpy (&ts_data[TSOffs], tsptr);
 								TSOffs += l;
-								tslen[n] = l;
+								tslen[stringI] = l;
 							}
 						}
 					}
@@ -208,7 +339,7 @@ _GetConversationData (const char *path,
 					{
 						// timestamp data is invalid, remove all of it
 						log_add (log_Warning, "Invalid timestamp data "
-								"for '%s'.  Disabling timestamps", s);
+								"for '%s'.  Disabling timestamps", name);
 						HFree (ts_data);
 						ts_data = NULL;
 						uio_fclose (timestamp_fp);
@@ -216,46 +347,39 @@ _GetConversationData (const char *path,
 						TSOffs = 0;
 					}
 				}
-				clen[n] = 0;
-				s = strtok (NULL, " \t\r\n)");
-				if (s)
+				clen[stringI] = 0;
+				ts = strtok (NULL, " \t\r\n)");
+				if (ts)
 				{
-					l = path_len + strlen (s) + 1;
-					if (ClipOffs + l > tot_clip_size
-							&& (clipdata = HRealloc (clipdata,
-							tot_clip_size += POOL_SIZE)) == 0)
-					{
-						HFree (strdata);
+					l = path_len + strlen (ts) + 1;
+					if (!ensureBufSize (&clipdata, &tot_clip_size,
+							ClipOffs + l, POOL_SIZE))
 						goto err;
-					}
 
 					if (clip_path)
 						strcpy (&clipdata[ClipOffs], clip_path);
-					strcpy (&clipdata[ClipOffs + path_len], s);
+					strcpy (&clipdata[ClipOffs + path_len], ts);
 					ClipOffs += l;
-					clen[n] = l;
+					clen[stringI] = l;
 				}
 			}
 		}
-		else if (n >= 0)
+		else if (stringI >= 0)
 		{
 			char *s;
 			l = strlen (CurrentLine) + 1;
-			if (StringOffs + l > tot_string_size
-					&& (strdata = HRealloc (strdata,
-					tot_string_size += POOL_SIZE)) == 0)
-			{
-				HFree (clipdata);
+
+			if (!ensureBufSize (&strdata, &tot_string_size, StringOffs + l,
+					POOL_SIZE))
 				goto err;
-			}
 
-			if (slen[n])
+			if (slen[stringI])
 			{
-				--slen[n];
+				--slen[stringI];
 				--StringOffs;
 			}
 			s = &strdata[StringOffs];
-			slen[n] += l;
+			slen[stringI] += l;
 			StringOffs += l;
 
 			strcpy (s, CurrentLine);
@@ -264,12 +388,12 @@ _GetConversationData (const char *path,
 		if ((int)uio_ftell (fp) - (int)opos >= (int)dataLen)
 			break;
 	}
-	if (n >= 0)
+	if (stringI >= 0)
 	{
-		while (slen[n] > 1 && (strdata[StringOffs - 2] == '\n'
+		while (slen[stringI] > 1 && (strdata[StringOffs - 2] == '\n'
 				|| strdata[StringOffs - 2] == '\r'))
 		{
-			--slen[n];
+			--slen[stringI];
 			--StringOffs;
 			strdata[StringOffs - 1] = '\0';
 		}
@@ -280,57 +404,83 @@ _GetConversationData (const char *path,
 
 	result = NULL;
 	num_data_sets = (ClipOffs ? 1 : 0) + (TSOffs ? 1 : 0) + 1;
-	if (++n)
+	if (++stringI)
 	{
 		int flags = 0;
+		int stringCount = stringI;
+
 		if (ClipOffs)
 			flags |= HAS_SOUND_CLIPS;
 		if (TSOffs)
 			flags |= HAS_TIMESTAMP;
-		result = AllocStringTable (n, flags);
+		flags |= HAS_NAMEINDEX;
+
+		result = AllocStringTable (stringCount, flags);
 		if (result)
 		{
-			int StringIndex, ClipIndex, TSIndex;
-			STRING_TABLE_DESC *lpST;
-
-			lpST = (STRING_TABLE) result;
-
-			StringIndex = 0;
-			ClipIndex = n;
-			TSIndex = n * ((flags & HAS_SOUND_CLIPS) ? 2 : 1);
+			// Copy all the gatherered data in a STRING_TABLE
+			STRING_TABLE_DESC *lpST = (STRING_TABLE) result;
+			STRING str;
+			stringI = 0;
+
+			// Store the dialog string.
+			copy_strings_to_strtab (
+					lpST, stringI, stringCount, strdata, slen);
+			stringI += stringCount;
+			
+			// Store the dialog names.
+			copy_strings_to_strtab (
+					lpST, stringI, stringCount, namedata, nlen);
+			stringI += stringCount;
+				
+			// Store sound clip file names.
+			if (lpST->flags & HAS_SOUND_CLIPS)
+			{
+				copy_strings_to_strtab (
+						lpST, stringI, stringCount, clipdata, clen);
+				stringI += stringCount;
+			}
 
-			StringOffs = ClipOffs = TSOffs = 0;
+			// Store time stamp data.
+			if (lpST->flags & HAS_TIMESTAMP)
+			{
+				copy_strings_to_strtab (
+						lpST, stringI, stringCount, ts_data, tslen);
+				//stringI += stringCount;
+			}
 
-			for (n = 0; n < (int)lpST->size;
-					++n, ++StringIndex, ++ClipIndex, ++TSIndex)
+			// Store the STRING in the hash table indexed by the dialog
+			// name.
+			str = &lpST->strings[stringCount];
+			for (stringI = 0; stringI < stringCount; stringI++)
 			{
-				set_strtab_entry(lpST, StringIndex, strdata + StringOffs, slen[n]);
-				StringOffs += slen[n];
-				if (lpST->flags & HAS_SOUND_CLIPS)
-				{
-					set_strtab_entry(lpST, ClipIndex, clipdata + ClipOffs, clen[n]);
-					ClipOffs += clen[n];
-				}
-				if (lpST->flags & HAS_TIMESTAMP)
-				{
-					set_strtab_entry(lpST, TSIndex, ts_data + TSOffs, tslen[n]);
-					TSOffs += tslen[n];
-				}
+				StringHashTable_add (nameHashTable, str[stringI].data,
+						&str[stringI]);
 			}
+
+			lpST->nameIndex = nameHashTable;
 		}
 	}
 	HFree (strdata);
-	HFree (clipdata);
-	if (ts_data)
+	if (clipdata != NULL)
+		HFree (clipdata);
+	if (ts_data != NULL)
 		HFree (ts_data);
 
 	resdata->ptr = result;
 	return;
 
 err:
+	if (nameHashTable != NULL)
+		StringHashTable_deleteHashTable (nameHashTable);
+	if (ts_data != NULL)
+		HFree (ts_data);
+	if (clipdata != NULL)
+		HFree (clipdata);
+	if (strdata != NULL)
+		HFree (strdata);
 	res_CloseResFile (fp);
 	resdata->ptr = NULL;
-
 }
 
 void *
@@ -338,20 +488,38 @@ _GetStringData (uio_Stream *fp, DWORD le
 {
 	void *result;
 
-	int n;
-	DWORD opos, slen[MAX_STRINGS], StringOffs, tot_string_size;
-	char CurrentLine[1024], *strdata;
-
-	if ((strdata = HMalloc (tot_string_size = POOL_SIZE)) == 0)
-		return (0);
+	int stringI;
+	DWORD opos;
+	DWORD slen[MAX_STRINGS];
+	DWORD StringOffs;
+	size_t tot_string_size;
+	char CurrentLine[1024];
+	char *strdata = NULL;
+
+	tot_string_size = POOL_SIZE;
+	strdata = HMalloc (tot_string_size);
+	if (strdata == 0)
+		goto err;
 
 	opos = uio_ftell (fp);
-	n = -1;
+	stringI = -1;
 	StringOffs = 0;
-	while (uio_fgets (CurrentLine, sizeof (CurrentLine), fp) && n < MAX_STRINGS - 1)
+	for (;;)
 	{
 		int l;
 
+		if (uio_fgets (CurrentLine, sizeof (CurrentLine), fp) == NULL)
+		{
+			// EOF or read error.
+			break;
+		}
+	
+		if (stringI >= MAX_STRINGS - 1)
+		{
+			// Too many strings.
+			break;
+		}
+
 		if (CurrentLine[0] == '#')
 		{
 			char CopyLine[1024];
@@ -361,39 +529,37 @@ _GetStringData (uio_Stream *fp, DWORD le
 			s = strtok (&CopyLine[1], "()");
 			if (s)
 			{
-				if (n >= 0)
+				if (stringI >= 0)
 				{
-					while (slen[n] > 1 && 
+					while (slen[stringI] > 1 && 
 							(strdata[StringOffs - 2] == '\n' ||
 							strdata[StringOffs - 2] == '\r'))
 					{
-						--slen[n];
+						--slen[stringI];
 						--StringOffs;
 						strdata[StringOffs - 1] = '\0';
 					}
 				}
 
-				slen[++n] = 0;
+				slen[++stringI] = 0;
 			}
 		}
-		else if (n >= 0)
+		else if (stringI >= 0)
 		{
 			char *s;
 			l = strlen (CurrentLine) + 1;
-			if (StringOffs + l > tot_string_size
-					&& (strdata = HRealloc (strdata,
-					tot_string_size += POOL_SIZE)) == 0)
-			{
-				return (0);
-			}
 
-			if (slen[n])
+			if (!ensureBufSize (&strdata, &tot_string_size, StringOffs + l,
+					POOL_SIZE))
+				goto err;
+
+			if (slen[stringI])
 			{
-				--slen[n];
+				--slen[stringI];
 				--StringOffs;
 			}
 			s = &strdata[StringOffs];
-			slen[n] += l;
+			slen[stringI] += l;
 			StringOffs += l;
 
 			strcpy (s, CurrentLine);
@@ -402,44 +568,38 @@ _GetStringData (uio_Stream *fp, DWORD le
 		if ((int)uio_ftell (fp) - (int)opos >= (int)length)
 			break;
 	}
-	if (n >= 0)
+	if (stringI >= 0)
 	{
-		while (slen[n] > 1 && (strdata[StringOffs - 2] == '\n'
+		while (slen[stringI] > 1 && (strdata[StringOffs - 2] == '\n'
 				|| strdata[StringOffs - 2] == '\r'))
 		{
-			--slen[n];
+			--slen[stringI];
 			--StringOffs;
 			strdata[StringOffs - 1] = '\0';
 		}
 	}
 
 	result = NULL;
-	if (++n)
+	if (++stringI)
 	{
 		int flags = 0;
-		result = AllocStringTable (n, flags);
+		int stringCount = stringI;
+
+		result = AllocStringTable (stringI, flags);
 		if (result)
 		{
-			int StringIndex;
-			STRING_TABLE_DESC *lpST;
-
-			lpST = (STRING_TABLE) result;
-
-			StringIndex = 0;
-
-			StringOffs = 0;
-
-			for (n = 0; n < (int)lpST->size;
-					++n, ++StringIndex)
-			{
-				set_strtab_entry(lpST, StringIndex, strdata + StringOffs, slen[n]);
-				StringOffs += slen[n];
-			}
+			STRING_TABLE_DESC *lpST = (STRING_TABLE) result;
+			copy_strings_to_strtab (lpST, 0, stringCount, strdata, slen);
 		}
 	}
 	HFree (strdata);
 
-	return (result);
+	return result;
+
+err:
+	if (strdata != NULL)
+		HFree (strdata);
+	return 0;
 }
 
 
@@ -478,6 +638,6 @@ _GetBinaryTableData (uio_Stream *fp, DWO
 		result = lpST;
 	}
 
-	return (result);
+	return result;
 }
 
diff -ruNp src.hd/libs/strings/stringhashtable.c src/libs/strings/stringhashtable.c
--- src.hd/libs/strings/stringhashtable.c	1969-12-31 16:00:00 -0800
+++ src/libs/strings/stringhashtable.c	2017-12-29 00:57:41 -0800
@@ -0,0 +1,67 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ * Nota bene: later versions of the GNU General Public License do not apply
+ * to this program.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#define HASHTABLE_INTERNAL
+#include "stringhashtable.h"
+#include "types.h"
+#include "libs/misc.h"
+		// For unconst()
+#include "libs/uio/uioport.h"
+
+static inline uio_uint32 StringHashTable_hash(
+		StringHashTable_HashTable *hashTable, const char *string);
+static inline uio_bool StringHashTable_equal(
+		StringHashTable_HashTable *hashTable,
+		const char *key1, const char *key2);
+static inline char *StringHashTable_copy(
+		StringHashTable_HashTable *hashTable, const char *key);
+
+#include "libs/uio/hashtable.c"
+
+
+static inline uio_uint32
+StringHashTable_hash(StringHashTable_HashTable *hashTable, const char *key) {
+	uio_uint32 hash;
+
+	(void) hashTable;
+	// Rotating hash, variation of something on the web which
+	// wasn't original itself.
+	hash = 0;
+			// Hash was on that web page initialised as the length,
+			// but that isn't known at this time.
+	while (*key != '\0') {
+		hash = (hash << 4) ^ (hash >> 28) ^ *key;
+		key++;
+	}
+	return hash ^ (hash >> 10) ^ (hash >> 20);
+}
+
+static inline uio_bool
+StringHashTable_equal(StringHashTable_HashTable *hashTable,
+		const char *key1, const char *key2) {
+	(void) hashTable;
+	return strcmp(key1, key2) == 0;
+}
+
+static inline char *
+StringHashTable_copy(StringHashTable_HashTable *hashTable,
+		const char *key) {
+	(void) hashTable;
+	return unconst(key);
+}
+
diff -ruNp src.hd/libs/strings/stringhashtable.h src/libs/strings/stringhashtable.h
--- src.hd/libs/strings/stringhashtable.h	1969-12-31 16:00:00 -0800
+++ src/libs/strings/stringhashtable.h	2017-12-29 00:57:41 -0800
@@ -0,0 +1,43 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ * Nota bene: later versions of the GNU General Public License do not apply
+ * to this program.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef _STRINGHASHTABLE_H
+#define _STRINGHASHTABLE_H
+
+// HashTable from 'char *' to STRING.
+// We don't actually copy the index, which means that the caller is
+// responsible for keeping them unchanged during the time that it is used in
+// the hash table.
+
+#include "libs/strlib.h"
+
+#define HASHTABLE_(identifier) StringHashTable ## _ ## identifier
+typedef char HASHTABLE_(Key);
+typedef STRING_TABLE_ENTRY_DESC HASHTABLE_(Value);
+#define StringHashTable_HASH StringHashTable_hash
+#define StringHashTable_EQUAL StringHashTable_equal
+#define StringHashTable_COPY StringHashTable_copy
+#define StringHashTable_FREEKEY(hashTable, key) \
+		((void) (hashTable), (void) (key))
+#define StringHashTable_FREEVALUE(hashTable, value) \
+		((void) (hashTable), (void) (value))
+
+#include "libs/uio/hashtable.h"
+
+
+#endif  /* _STRINGHASHTABLE_H */
diff -ruNp src.hd/libs/strings/strings.c src/libs/strings/strings.c
--- src.hd/libs/strings/strings.c	2017-12-29 02:25:50 -0800
+++ src/libs/strings/strings.c	2017-12-29 00:57:41 -0800
@@ -25,6 +25,10 @@ AllocStringTable (int num_entries, int f
 	STRING_TABLE strtab = HMalloc (sizeof (STRING_TABLE_DESC));
 	int i, multiplier = 1;
 
+	if (flags & HAS_NAMEINDEX)
+	{
+		multiplier++;
+	}
 	if (flags & HAS_SOUND_CLIPS)
 	{
 		multiplier++;
@@ -44,6 +48,7 @@ AllocStringTable (int num_entries, int f
 		strtab->strings[i].parent = strtab;
 		strtab->strings[i].index = i;
 	}
+	strtab->nameIndex = NULL;
 	return strtab;
 }
 
@@ -209,6 +214,40 @@ GetStringLengthBin (STRING String)
 }
 
 STRINGPTR
+GetStringName (STRING String)
+{
+	STRING_TABLE StringTablePtr;
+	COUNT StringIndex;
+
+	if (String == NULL)
+	{
+		return NULL;
+	}
+
+	StringTablePtr = String->parent;
+	if (StringTablePtr == NULL)
+	{
+		return NULL;
+	}
+
+	StringIndex = String->index;
+
+	if (!(StringTablePtr->flags & HAS_NAMEINDEX))
+	{
+		return NULL;
+	}
+	StringIndex += StringTablePtr->size;
+
+	String = &StringTablePtr->strings[StringIndex];
+	if (String->length == 0)
+	{
+		return NULL;
+	}
+
+	return String->data;
+}
+
+STRINGPTR
 GetStringSoundClip (STRING String)
 {
 	STRING_TABLE StringTablePtr;
@@ -230,8 +269,13 @@ GetStringSoundClip (STRING String)
 	{
 		return NULL;
 	}
-
 	StringIndex += StringTablePtr->size;
+
+	if (StringTablePtr->flags & HAS_NAMEINDEX)
+	{
+		StringIndex += StringTablePtr->size;
+	}
+
 	String = &StringTablePtr->strings[StringIndex];
 	if (String->length == 0)
 	{
@@ -246,7 +290,6 @@ GetStringTimeStamp (STRING String)
 {
 	STRING_TABLE StringTablePtr;
 	COUNT StringIndex;
-	int offset;
 
 	if (String == NULL)
 	{
@@ -264,9 +307,18 @@ GetStringTimeStamp (STRING String)
 	{
 		return NULL;
 	}
+	StringIndex += StringTablePtr->size;
+
+	if (StringTablePtr->flags & HAS_NAMEINDEX)
+	{
+		StringIndex += StringTablePtr->size;
+	}
+	
+	if (StringTablePtr->flags & HAS_SOUND_CLIPS)
+	{
+		StringIndex += StringTablePtr->size;
+	}
 
-	offset = (StringTablePtr->flags & HAS_SOUND_CLIPS) ? 1 : 0;
-	StringIndex += StringTablePtr->size << offset;
 	String = &StringTablePtr->strings[StringIndex];
 	if (String->length == 0)
 	{
@@ -285,3 +337,11 @@ GetStringAddress (STRING String)
 	}
 	return String->data;
 }
+
+STRING
+GetStringByName (STRING_TABLE StringTable, const char *index)
+{
+	return (STRING) StringHashTable_find (StringTable->nameIndex, index);
+}
+
+
diff -ruNp src.hd/libs/strings/strintrn.h src/libs/strings/strintrn.h
--- src.hd/libs/strings/strintrn.h	2017-12-29 02:25:50 -0800
+++ src/libs/strings/strintrn.h	2017-12-29 00:57:41 -0800
@@ -23,6 +23,7 @@
 #include <string.h>
 #include "libs/strlib.h"
 #include "libs/reslib.h"
+#include "stringhashtable.h"
 
 struct string_table_entry
 {
@@ -37,10 +38,12 @@ struct string_table
 	unsigned short flags;
 	int size;
 	STRING_TABLE_ENTRY_DESC *strings;
+	StringHashTable_HashTable *nameIndex;
 };
 
-#define HAS_SOUND_CLIPS (1 << 0)
-#define HAS_TIMESTAMP (1 << 1)
+#define HAS_SOUND_CLIPS  (1 << 0)
+#define HAS_TIMESTAMP    (1 << 1)
+#define HAS_NAMEINDEX    (1 << 2)
 
 STRING_TABLE AllocStringTable (int num_entries, int flags);
 void FreeStringTable (STRING_TABLE strtab);
diff -ruNp src.hd/libs/strlib.h src/libs/strlib.h
--- src.hd/libs/strlib.h	2017-12-29 02:25:50 -0800
+++ src/libs/strlib.h	2017-12-29 00:57:41 -0800
@@ -36,6 +36,10 @@ typedef char *STRINGPTR;
 /* This has to go here because reslib requires the above typedefs. */
 #include "libs/reslib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern BOOLEAN InstallStringTableResType (void);
 extern STRING_TABLE LoadStringTableInstance (RESOURCE res);
 extern STRING_TABLE LoadStringTableFile (uio_DirHandle *dir,
@@ -53,8 +57,10 @@ extern STRING SetRelStringTableIndex (ST
 extern COUNT GetStringLength (STRING String);
 extern COUNT GetStringLengthBin (STRING String);
 extern STRINGPTR GetStringAddress (STRING String);
+extern STRINGPTR GetStringName (STRING String);
 extern STRINGPTR GetStringSoundClip (STRING String);
 extern STRINGPTR GetStringTimeStamp (STRING String);
+extern STRING GetStringByName (STRING_TABLE StringTable, const char *index);
 
 #define UNICHAR_DEGREE_SIGN   0x00b0
 #define STR_DEGREE_SIGN     "\xC2\xB0"
@@ -67,5 +73,9 @@ extern STRINGPTR GetStringTimeStamp (STR
 #define UNICHAR_BULLET        0x2022
 #define STR_BULLET          "\xE2\x80\xA2"
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _STRLIB_H */
 
diff -ruNp src.hd/libs/task/tasklib.c src/libs/task/tasklib.c
--- src.hd/libs/task/tasklib.c	2017-12-29 02:25:50 -0800
+++ src/libs/task/tasklib.c	2017-12-29 00:57:41 -0800
@@ -124,7 +124,6 @@ InitTaskSystem (void)
 	{
 		task_array[i].state_mutex = CreateMutex ("task manager lock", SYNC_CLASS_TOPLEVEL | SYNC_CLASS_RESOURCE);
 	}
-	atexit (CleanupTaskSystem);
 }
 
 void 
@@ -134,6 +133,7 @@ CleanupTaskSystem (void)
 	for (i = 0; i < TASK_MAX; ++i)
 	{
 		DestroyMutex (task_array[i].state_mutex);
+		task_array[i].state_mutex = 0;
 	}
 }
 
diff -ruNp src.hd/libs/tasklib.h src/libs/tasklib.h
--- src.hd/libs/tasklib.h	2017-12-29 02:25:50 -0800
+++ src/libs/tasklib.h	2017-12-29 00:57:41 -0800
@@ -26,6 +26,10 @@
 
 #include "libs/threadlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 /* Bitmasks for setting task state. */
 #define TASK_INUSE       1
 #define TASK_EXIT        2
@@ -50,5 +54,9 @@ extern DWORD Task_ReadState (Task task,
 extern void  FinishTask (Task task);
 extern void  ConcludeTask (Task task);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif
 
diff -ruNp src.hd/libs/threadlib.h src/libs/threadlib.h
--- src.hd/libs/threadlib.h	2017-12-29 02:25:50 -0800
+++ src/libs/threadlib.h	2017-12-29 00:57:41 -0800
@@ -45,6 +45,10 @@
 #include <sys/types.h>
 #include "libs/timelib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #if defined (PROFILE_THREADS) || defined (DEBUG_THREADS)
 #define THREAD_NAMES
 #endif
@@ -141,6 +145,8 @@ ThreadLocal *CreateThreadLocal (void);
 void DestroyThreadLocal (ThreadLocal *tl);
 ThreadLocal *GetMyThreadLocal (void);
 
+void HibernateThread (TimePeriod timePeriod);
+void HibernateThreadUntil (TimeCount wakeTime);
 void SleepThread (TimePeriod timePeriod);
 void SleepThreadUntil (TimeCount wakeTime);
 void DestroyThread (Thread);
@@ -173,5 +179,9 @@ void WaitCondVar (CondVar);
 void SignalCondVar (CondVar);
 void BroadcastCondVar (CondVar);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _THREADLIB_H */
 
diff -ruNp src.hd/libs/threads/Makeinfo src/libs/threads/Makeinfo
--- src.hd/libs/threads/Makeinfo	2017-12-29 02:25:50 -0800
+++ src/libs/threads/Makeinfo	2017-12-29 00:57:41 -0800
@@ -6,4 +6,6 @@ case "$uqm_THREADLIB" in
 		uqm_SUBDIRS="pthread"
 		;;
 esac
+
 uqm_CFILES="thrcommon.c"
+uqm_HFILES="thrcommon.h"
diff -ruNp src.hd/libs/threads/pthread/Makeinfo src/libs/threads/pthread/Makeinfo
--- src.hd/libs/threads/pthread/Makeinfo	2017-12-29 02:25:50 -0800
+++ src/libs/threads/pthread/Makeinfo	2017-12-29 00:57:41 -0800
@@ -1 +1,2 @@
 uqm_CFILES="posixthreads.c"
+uqm_HFILES="posixthreads.h"
diff -ruNp src.hd/libs/threads/sdl/Makeinfo src/libs/threads/sdl/Makeinfo
--- src.hd/libs/threads/sdl/Makeinfo	2017-12-29 02:25:50 -0800
+++ src/libs/threads/sdl/Makeinfo	2017-12-29 00:57:41 -0800
@@ -1 +1,2 @@
 uqm_CFILES="sdlthreads.c"
+uqm_HFILES="sdlthreads.h"
diff -ruNp src.hd/libs/threads/thrcommon.c src/libs/threads/thrcommon.c
--- src.hd/libs/threads/thrcommon.c	2017-12-29 02:25:50 -0800
+++ src/libs/threads/thrcommon.c	2017-12-29 00:57:41 -0800
@@ -19,6 +19,7 @@
 #include "libs/threadlib.h"
 #include "libs/timelib.h"
 #include "libs/log.h"
+#include "libs/async.h"
 #include "libs/memlib.h"
 #include "thrcommon.h"
 
@@ -284,16 +285,79 @@ WaitThread (Thread thread, int *status)
 	NativeWaitThread (thread, status);
 }
 
+#ifdef DEBUG_SLEEP
+extern uint32 mainThreadId;
+extern uint32 SDL_ThreadID(void);
+#endif  /* DEBUG_SLEEP */
+
+void
+HibernateThread (TimePeriod timePeriod)
+{
+#ifdef DEBUG_SLEEP
+	if (SDL_ThreadID() == mainThreadId)
+		log_add (log_Debug, "HibernateThread called from main thread.\n");
+#endif  /* DEBUG_SLEEP */
+
+	NativeSleepThread (timePeriod);
+}
+
+void
+HibernateThreadUntil (TimeCount wakeTime)
+{
+#ifdef DEBUG_SLEEP
+	if (SDL_ThreadID() == mainThreadId)
+		log_add (log_Debug, "HibernateThreadUntil called from main "
+				"thread.\n");
+#endif  /* DEBUG_SLEEP */
+
+	NativeSleepThreadUntil (wakeTime);
+}
+
 void
 SleepThread (TimePeriod timePeriod)
 {
-	NativeSleepThread (timePeriod);
+	TimeCount now;
+
+#ifdef DEBUG_SLEEP
+	if (SDL_ThreadID() != mainThreadId)
+		log_add (log_Debug, "SleepThread called from non-main "
+				"thread.\n");
+#endif  /* DEBUG_SLEEP */
+
+	now = GetTimeCounter ();
+	SleepThreadUntil (now + timePeriod);
 }
 
+// Sleep until wakeTime, but call asynchrounous operations until then.
 void
 SleepThreadUntil (TimeCount wakeTime)
 {
-	NativeSleepThreadUntil (wakeTime);
+#ifdef DEBUG_SLEEP
+	if (SDL_ThreadID() != mainThreadId)
+		log_add (log_Debug, "SleepThreadUntil called from non-main "
+				"thread.\n");
+#endif  /* DEBUG_SLEEP */
+
+	for (;;) {
+		uint32 nextTimeMs;
+		TimeCount nextTime;
+		TimeCount now;
+
+		Async_process ();
+
+		now = GetTimeCounter ();
+		if (wakeTime <= now)
+			return;
+		
+		nextTimeMs = Async_timeBeforeNextMs ();
+		nextTime = (nextTimeMs / 1000) * ONE_SECOND +
+				((nextTimeMs % 1000) * ONE_SECOND / 1000);
+				// Overflow-safe conversion.
+		if (wakeTime < nextTime)
+			nextTime = wakeTime;
+
+		NativeSleepThreadUntil (nextTime);
+	}
 }
 
 void
diff -ruNp src.hd/libs/time/Makeinfo src/libs/time/Makeinfo
--- src.hd/libs/time/Makeinfo	2017-12-29 02:25:50 -0800
+++ src/libs/time/Makeinfo	2017-12-29 00:57:41 -0800
@@ -1,2 +1,3 @@
 uqm_SUBDIRS="sdl"
 uqm_CFILES="timecommon.c"
+uqm_HFILES="timecommon.h"
diff -ruNp src.hd/libs/time/sdl/Makeinfo src/libs/time/sdl/Makeinfo
--- src.hd/libs/time/sdl/Makeinfo	2017-12-29 02:25:50 -0800
+++ src/libs/time/sdl/Makeinfo	2017-12-29 00:57:41 -0800
@@ -1 +1,2 @@
 uqm_CFILES="sdltime.c"
+uqm_HFILES="sdltime.h"
diff -ruNp src.hd/libs/timelib.h src/libs/timelib.h
--- src.hd/libs/timelib.h	2017-12-29 02:25:50 -0800
+++ src/libs/timelib.h	2017-12-29 00:57:41 -0800
@@ -21,6 +21,10 @@
 
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 /* ONE_SECOND is the LCM of all the fractions of a second the game uses.
  * Battle is 24 FPS, Landers are 35 FPS, most UI-level things are 15 FPS,
  * The Interplanetary flight is 30 FPS, Comm ambient animation is 40 FPS,
@@ -38,5 +42,9 @@ extern void InitTimeSystem (void);
 extern void UnInitTimeSystem (void);
 extern TimeCount GetTimeCounter (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _TIMLIB_H */
 
diff -ruNp src.hd/libs/uio/Makeinfo src/libs/uio/Makeinfo
--- src.hd/libs/uio/Makeinfo	2017-12-29 02:25:50 -0800
+++ src/libs/uio/Makeinfo	2017-12-29 00:57:42 -0800
@@ -1,8 +1,10 @@
 uqm_SUBDIRS="stdio"
-uqm_CFILES="charhashtable.c defaultfs.c fileblock.c fstypes.c
-		gphys.c io.c ioaux.c match.c mount.c
-		mounttree.c paths.c physical.c uiostream.c uioutils.c
-		utils.c"
+uqm_CFILES="charhashtable.c defaultfs.c fileblock.c fstypes.c gphys.c io.c
+		ioaux.c match.c mount.c mounttree.c paths.c physical.c uiostream.c
+		uioutils.c utils.c"
+uqm_HFILES="charhashtable.h defaultfs.h fileblock.h fstypes.h getint.h
+		gphys.h ioaux.h io.h iointrn.h match.h mem.h mount.h mounttree.h
+		paths.h physical.h types.h uioport.h uiostream.h uioutils.h utils.h"
 
 if [ -n "$uqm_USE_ZIP_IO" ]; then
 	uqm_SUBDIRS="$uqm_SUBDIRS zip"
@@ -10,9 +12,11 @@ fi
 
 #if [ -n "$DEBUG" -o -n "$uqm_UIO_DEBUG" ]; then
 	uqm_CFILES="$uqm_CFILES debug.c"
+	uqm_HFILES="$uqm_HFILES debug.h"
 #fi
 
 if [ -n "$MEMDEBUG" ]; then
 	uqm_CFILES="$uqm_CFILES hashtable.c memdebug.c"
+	uqm_HFILES="$uqm_HFILES hashtable.h memdebug.h"
 fi
 
diff -ruNp src.hd/libs/uio/charhashtable.c src/libs/uio/charhashtable.c
--- src.hd/libs/uio/charhashtable.c	2017-12-29 02:25:50 -0800
+++ src/libs/uio/charhashtable.c	2017-12-29 00:57:41 -0800
@@ -30,7 +30,7 @@ static inline uio_bool CharHashTable_equ
 		const char *key1, const char *key2);
 static inline char *CharHashTable_copy(CharHashTable_HashTable *hashTable,
 		const char *key);
-static inline void CharHashTable_free(CharHashTable_HashTable *hashTable,
+static inline void CharHashTable_freeKey(CharHashTable_HashTable *hashTable,
 		char *key);
 
 #include "hashtable.c"
@@ -56,21 +56,21 @@ CharHashTable_hash(CharHashTable_HashTab
 static inline uio_bool
 CharHashTable_equal(CharHashTable_HashTable *hashTable,
 		const char *key1, const char *key2) {
-	(void) *hashTable;
+	(void) hashTable;
 	return strcmp(key1, key2) == 0;
 }
 
 static inline char *
 CharHashTable_copy(CharHashTable_HashTable *hashTable,
 		const char *key) {
-	(void) *hashTable;
+	(void) hashTable;
 	return uio_strdup(key);
 }
 
 static inline void
-CharHashTable_free(CharHashTable_HashTable *hashTable,
+CharHashTable_freeKey(CharHashTable_HashTable *hashTable,
 		char *key) {
-	(void) *hashTable;
+	(void) hashTable;
 	uio_free(key);
 }
 
diff -ruNp src.hd/libs/uio/charhashtable.h src/libs/uio/charhashtable.h
--- src.hd/libs/uio/charhashtable.h	2017-12-29 02:25:50 -0800
+++ src/libs/uio/charhashtable.h	2017-12-29 00:57:41 -0800
@@ -28,10 +28,12 @@ typedef void HASHTABLE_(Value);
 #define CharHashTable_HASH CharHashTable_hash
 #define CharHashTable_EQUAL CharHashTable_equal
 #define CharHashTable_COPY CharHashTable_copy
-#define CharHashTable_FREE CharHashTable_free
+#define CharHashTable_FREEKEY CharHashTable_freeKey
+#define CharHashTable_FREEVALUE(hashTable, value) \
+		((void) (hashTable), (void) (value))
 
 #include "hashtable.h"
 
 
-#endif  /* _HASHTABLE_H */
+#endif  /* _CHARHASHTABLE_H */
 
diff -ruNp src.hd/libs/uio/debug.c src/libs/uio/debug.c
--- src.hd/libs/uio/debug.c	2017-12-29 02:25:50 -0800
+++ src/libs/uio/debug.c	2017-12-29 00:57:41 -0800
@@ -473,7 +473,7 @@ debugCmdExec(DebugContext *debugContext,
 				O_RDONLY, tempDir);
 		if (handles[i - 1] == NULL) {
 			if (errno == ENOENT) {
-				// No match; we keep what's typed litterally.
+				// No match; we keep what's typed literally.
 				newArgs[i - 1] = argv[i];
 				continue;
 			}
@@ -703,7 +703,7 @@ listOneDir(DebugContext *debugContext, c
 				match_MATCH_PREFIX);
 	} else {
 		dirList = uio_getDirList(debugContext->cwd, cpath, pattern,
-				match_MATCH_LITTERAL);
+				match_MATCH_LITERAL);
 	}
 #endif
 	if (dirList == NULL) {
diff -ruNp src.hd/libs/uio/doc/basics src/libs/uio/doc/basics
--- src.hd/libs/uio/doc/basics	2017-12-29 02:25:50 -0800
+++ src/libs/uio/doc/basics	2017-12-29 00:57:42 -0800
@@ -123,18 +123,56 @@ no problem, as long as the repositories
 -= Internals =-
 
 Types:
-uio_MountTree - A node in a data structure describing the mounted directories.
-uio_PRoot - A struct describing the a physical file system.
-uio_PRootExtra - Filesystem-dependant extra data for a PRoot.
-uio_GPRoot - Generic filesystem-dependant data for a PRoot, used as
-            uio_PRootExtra.
-uio_GPRootExtra - Extra filesystem-dependant data for a PRoot, when using
-                 uio_GPRoot for generic filesystem-dependant data.
-uio_GPDir - Generic structure representing a node in a physical directory
-           structure describing one directory.
-uio_GPFile - Generic structure describing a file in a physical file system.
 
+uio_MountTree
+    A node in a data structure describing the mounted directories.
 
-TODO: functions
+uio_PRoot
+    A struct describing the a physical file system.
+
+uio_PRootExtra
+    Filesystem-dependant extra data for a PRoot.
+
+uio_GPRoot
+    Generic filesystem-dependant data for a PRoot, used as uio_PRootExtra.
+
+uio_GPRootExtra
+    Extra filesystem-dependant data for a PRoot, when using uio_GPRoot for
+    generic filesystem-dependant data.
+
+uio_GPDir
+    Generic structure representing a node in a physical directory structure
+    describing one directory.
+
+uio_GPFile
+    Generic structure describing a file in a physical file system.
+
+
+Helper functions (defined in ioaux.c):
+
+uio_copyFilePhysical
+    Copy a file from one physical directory to another.
+
+uio_getPathPhysicalDirs
+    Get handles to the (existing) physical dirs that are effective in a
+    path 'path' relative from 'dirHandle'
+
+uio_getPhysicalAccess
+    Find PDirHandle and MountInfo structures for reading and writing for a path
+    from a DirHandle.
+
+uio_makePath
+    Create a directory inside a physical directory. All non-existant
+    parent directories will be created as well.
+
+uio_resolvePath
+    Determine the absolute path given a path relative to a given directory.
+
+uio_verifyPath
+    Test whether a path is valid and exists.
+
+uio_walkPhysicalPath
+    Follow a path starting from a specified physical dir for as long as
+    possible.
 
 
diff -ruNp src.hd/libs/uio/gphys.h src/libs/uio/gphys.h
--- src.hd/libs/uio/gphys.h	2017-12-29 02:25:50 -0800
+++ src/libs/uio/gphys.h	2017-12-29 00:57:42 -0800
@@ -33,7 +33,7 @@ typedef struct CharHashTable_HashTable u
 
 #define uio_GPDirEntries_new() \
 		((uio_GPDirEntries *) CharHashTable_newHashTable(NULL, NULL, NULL, \
-		NULL, 0, 0.85, 0.9))
+		NULL, NULL, 0, 0.85, 0.9))
 #define uio_GPDirEntries_add(hashTable, name, item) \
 		CharHashTable_add((CharHashTable_HashTable *) hashTable, name, \
 		(void *) item)
diff -ruNp src.hd/libs/uio/hashtable.c src/libs/uio/hashtable.c
--- src.hd/libs/uio/hashtable.c	2017-12-29 02:25:50 -0800
+++ src/libs/uio/hashtable.c	2017-12-29 00:57:42 -0800
@@ -46,12 +46,14 @@ static inline HASHTABLE_(HashEntry) *HAS
 static inline void HASHTABLE_(freeHashEntry)(
 		HASHTABLE_(HashEntry) *entry);
 
+// Create a new HashTable.
 HASHTABLE_(HashTable) *
 HASHTABLE_(newHashTable)(
 		HASHTABLE_(HashFunction) hashFunction,
 		HASHTABLE_(EqualFunction) equalFunction,
 		HASHTABLE_(CopyFunction) copyFunction,
-		HASHTABLE_(FreeFunction) freeFunction,
+		HASHTABLE_(FreeKeyFunction) freeKeyFunction,
+		HASHTABLE_(FreeValueFunction) freeValueFunction,
 		uio_uint32 initialSize,
 		double minFillQuotient,
 		double maxFillQuotient) {
@@ -63,7 +65,8 @@ HASHTABLE_(newHashTable)(
 	hashTable->hashFunction = hashFunction;
 	hashTable->equalFunction = equalFunction;
 	hashTable->copyFunction = copyFunction;
-	hashTable->freeFunction = freeFunction;
+	hashTable->freeKeyFunction = freeKeyFunction;
+	hashTable->freeValueFunction = freeValueFunction;
 
 	hashTable->minFillQuotient = minFillQuotient;
 	hashTable->maxFillQuotient = maxFillQuotient;
@@ -72,6 +75,7 @@ HASHTABLE_(newHashTable)(
 	return hashTable;
 }
 
+// Add an entry to the HashTable.
 uio_bool
 HASHTABLE_(add)(HASHTABLE_(HashTable) *hashTable,
 		const HASHTABLE_(Key) *key, HASHTABLE_(Value) *value) {
@@ -104,6 +108,7 @@ HASHTABLE_(add)(HASHTABLE_(HashTable) *h
 	return true;
 }
 
+// Remove an entry with a specified Key from the HashTable.
 uio_bool
 HASHTABLE_(remove)(HASHTABLE_(HashTable) *hashTable,
 		const HASHTABLE_(Key) *key) {
@@ -122,7 +127,8 @@ HASHTABLE_(remove)(HASHTABLE_(HashTable)
 		entry = &(*entry)->next;
 	}
 	next = (*entry)->next;
-	HASHTABLE_(FREE)(hashTable, (*entry)->key);
+	HASHTABLE_(FREEKEY)(hashTable, (*entry)->key);
+	HASHTABLE_(FREEVALUE)(hashTable, (*entry)->value);
 	HASHTABLE_(freeHashEntry)(*entry);
 	*entry = next;
 
@@ -133,6 +139,7 @@ HASHTABLE_(remove)(HASHTABLE_(HashTable)
 	return true;
 }
 
+// Find the Value stored for some Key.
 HASHTABLE_(Value) *
 HASHTABLE_(find)(HASHTABLE_(HashTable) *hashTable,
 		const HASHTABLE_(Key) *key) {
@@ -151,21 +158,23 @@ HASHTABLE_(find)(HASHTABLE_(HashTable) *
 	return NULL;
 }
 
+// Returns the number of entries in the HashTable.
 uio_uint32
 HASHTABLE_(count)(const HASHTABLE_(HashTable) *hashTable) {
 	return hashTable->numEntries;
 }
 
+// Auxiliary function to (re)initialise the buckets in the HashTable.
 static void
 HASHTABLE_(setup)(HASHTABLE_(HashTable) *hashTable, uio_uint32 initialSize) {
 	if (initialSize < 4)
 		initialSize = 4;
-	hashTable->size = nextPower2((uio_uint32) ceil(
-				((double) initialSize) / hashTable->maxFillQuotient));
+	hashTable->size = nextPower2(ceil(((double) initialSize) /
+			hashTable->maxFillQuotient));
 	hashTable->hashMask = hashTable->size - 1;
-	hashTable->minSize = (uio_uint32) ceil(((double) (hashTable->size >> 1))
+	hashTable->minSize = ceil(((double) (hashTable->size >> 1))
 			* hashTable->minFillQuotient);
-	hashTable->maxSize = (uio_uint32) floor(((double) hashTable->size)
+	hashTable->maxSize = floor(((double) hashTable->size)
 			* hashTable->maxFillQuotient);
 	hashTable->entries = uio_calloc(hashTable->size,
 			sizeof (HASHTABLE_(HashEntry) *));
@@ -175,6 +184,7 @@ HASHTABLE_(setup)(HASHTABLE_(HashTable)
 #endif
 }
 
+// Resize the buckets in the HashTable.
 static void
 HASHTABLE_(resize)(HASHTABLE_(HashTable) *hashTable) {
 	HASHTABLE_(HashEntry) **oldEntries;
@@ -224,6 +234,7 @@ nextPower2(uio_uint32 x) {
 	return x + 1;
 }
 
+// Get an iterator to iterate through all the entries in the HashTable.
 // NB: Iterator should be considered invalid if the HashTable is changed.
 // TODO: change this (make it thread-safe)
 //       this can be done by only marking items as deleted when
@@ -252,21 +263,26 @@ HASHTABLE_(getIterator)(const HASHTABLE_
 	return iterator;
 }
 
+// Returns true if and only if there are no more entries in the hash table
+// for the Iterator to find.
 int
 HASHTABLE_(iteratorDone)(const HASHTABLE_(Iterator) *iterator) {
 	return iterator->bucketNr >= iterator->hashTable->size;
 }
 
+// Get the Key of the entry pointed to by an Iterator.
 HASHTABLE_(Key) *
 HASHTABLE_(iteratorKey)(HASHTABLE_(Iterator) *iterator) {
 	return iterator->entry->key;
 }
 
+// Get the Value of the entry pointed to by an Iterator.
 HASHTABLE_(Value) *
 HASHTABLE_(iteratorValue)(HASHTABLE_(Iterator) *iterator) {
 	return iterator->entry->value;
 }
 
+// Move the Iterator to the next entry in the HashTable.
 // Should not be called if the iterator is already past the last entry.
 HASHTABLE_(Iterator) *
 HASHTABLE_(iteratorNext)(HASHTABLE_(Iterator) *iterator) {
@@ -293,16 +309,19 @@ HASHTABLE_(iteratorNext)(HASHTABLE_(Iter
 	return iterator;
 }
 
+// Free the Iterator.
 void
 HASHTABLE_(freeIterator)(HASHTABLE_(Iterator) *iterator) {
 	uio_free(iterator);
 }
 
+// Auxiliary function to allocate a HashTable.
 static inline HASHTABLE_(HashTable) *
 HASHTABLE_(allocHashTable)(void) {
 	return uio_malloc(sizeof (HASHTABLE_(HashTable)));
 }
 
+// Auxiliary function to create a HashEntry.
 static inline HASHTABLE_(HashEntry) *
 HASHTABLE_(newHashEntry)(uio_uint32 hash, HASHTABLE_(Key) *key,
 		HASHTABLE_(Value) *value, HASHTABLE_(HashEntry) *next) {
@@ -316,11 +335,13 @@ HASHTABLE_(newHashEntry)(uio_uint32 hash
 	return result;
 }
 
+// Allocate a new HashEntry.
 static inline HASHTABLE_(HashEntry) *
 HASHTABLE_(allocHashEntry)(void) {
 	return uio_malloc(sizeof (HASHTABLE_(HashEntry)));
 }
 
+// Delete the HashTable.
 void
 HASHTABLE_(deleteHashTable)(HASHTABLE_(HashTable) *hashTable) {
 	uio_uint32 i;
@@ -333,7 +354,8 @@ HASHTABLE_(deleteHashTable)(HASHTABLE_(H
 		entry = *bucketPtr;
 		while (entry != NULL) {
 			next = entry->next;
-			HASHTABLE_(FREE)(hashTable, entry->key);
+			HASHTABLE_(FREEKEY)(hashTable, entry->key);
+			HASHTABLE_(FREEVALUE)(hashTable, entry->value);
 			HASHTABLE_(freeHashEntry)(entry);
 			entry = next;
 			i--;
@@ -344,6 +366,7 @@ HASHTABLE_(deleteHashTable)(HASHTABLE_(H
 	uio_free(hashTable);
 }
 
+// Auxiliary function to deallocate a HashEntry.
 static inline void
 HASHTABLE_(freeHashEntry)(HASHTABLE_(HashEntry) *entry) {
 	uio_free(entry);
diff -ruNp src.hd/libs/uio/hashtable.h src/libs/uio/hashtable.h
--- src.hd/libs/uio/hashtable.h	2017-12-29 02:25:50 -0800
+++ src/libs/uio/hashtable.h	2017-12-29 00:57:42 -0800
@@ -39,6 +39,8 @@
 // (and typedefs) from the HASHTABLE_ block below.
 // In the .c file, #define HASHTABLE_INTERNAL, #include the .h file
 // and hashtable.c (in this order), and add the necessary functions.
+// If you do not need to free the Value, you can define HashTable_FREEVALUE
+// as a no-op.
 #ifndef HASHTABLE_
 #	define HASHTABLE_(identifier) HashTable ## _ ## identifier
 	typedef void HashTable_Key;
@@ -49,8 +51,10 @@
 		(hashTable)->equalFunction(hashKey1, hashKey2)
 #	define HashTable_COPY(hashTable, hashKey) \
 		(hashTable)->copyFunction(hashKey)
-#	define HashTable_FREE(hashTable, hashKey) \
-		(hashTable)->freeFunction(hashKey)
+#	define HashTable_FREEKEY(hashTable, hashKey) \
+		(hashTable)->freeKeyFunction(hashKey)
+#	define HashTable_FREEVALUE(hashTable, hashValue) \
+		(hashTable)->freeValueFunction(hashValue)
 #endif
 
 
@@ -59,8 +63,9 @@ typedef uio_uint32 (*HASHTABLE_(HashFunc
 typedef uio_bool (*HASHTABLE_(EqualFunction))(const HASHTABLE_(Key) *,
 		const HASHTABLE_(Key) *);
 typedef HASHTABLE_(Value) *(*HASHTABLE_(CopyFunction))(
-		const HASHTABLE_(Value) *);
-typedef void (*HASHTABLE_(FreeFunction))(HASHTABLE_(Value) *);
+		const HASHTABLE_(Key) *);
+typedef void (*HASHTABLE_(FreeKeyFunction))(HASHTABLE_(Key) *);
+typedef void (*HASHTABLE_(FreeValueFunction))(HASHTABLE_(Value) *);
 
 typedef struct HASHTABLE_(HashTable) HASHTABLE_(HashTable);
 typedef struct HASHTABLE_(HashEntry) HASHTABLE_(HashEntry);
@@ -68,9 +73,17 @@ typedef struct HASHTABLE_(Iterator) HASH
 
 struct HASHTABLE_(HashTable) {
 	HASHTABLE_(HashFunction) hashFunction;	
+			// Function creating a uio_uint32 hash of a key.
 	HASHTABLE_(EqualFunction) equalFunction;
+			// Function used to compare two keys.
 	HASHTABLE_(CopyFunction) copyFunction;
-	HASHTABLE_(FreeFunction) freeFunction;
+			// Function used to copy a key.
+	HASHTABLE_(FreeKeyFunction) freeKeyFunction;
+			// Function used to free a key.
+	HASHTABLE_(FreeValueFunction) freeValueFunction;
+			// Function used to free a value. Called when an entry is
+			// removed using the remove function, or for entries
+			// still in the HashTable when the HashTable is deleted.
 
 	double minFillQuotient;
 			// How much of half of the hashtable needs to be filled
@@ -114,7 +127,9 @@ HASHTABLE_(HashTable) *HASHTABLE_(newHas
 		HASHTABLE_(HashFunction) hashFunction,
 		HASHTABLE_(EqualFunction) equalFunction,
 		HASHTABLE_(CopyFunction) copyFunction,
-		HASHTABLE_(FreeFunction) freeFunction, uio_uint32 initialSize,
+		HASHTABLE_(FreeKeyFunction) freeKeyFunction,
+		HASHTABLE_(FreeValueFunction) freeValueFunction,
+		uio_uint32 initialSize,
 		double minFillQuotient, double maxFillQuotient);
 uio_bool HASHTABLE_(add)(HASHTABLE_(HashTable) *hashTable,
 		const HASHTABLE_(Key) *key, HASHTABLE_(Value) *value);
diff -ruNp src.hd/libs/uio/io.c src/libs/uio/io.c
--- src.hd/libs/uio/io.c	2017-12-29 02:25:50 -0800
+++ src/libs/uio/io.c	2017-12-29 00:57:42 -0800
@@ -287,6 +287,103 @@ uio_mountDir(uio_Repository *destRep, co
 	}
 }
 
+// Mount a repository directory into same repository at a different location
+// From fossil.
+uio_MountHandle *
+uio_transplantDir(const char *mountPoint, uio_DirHandle *sourceDir, int flags,
+		uio_MountHandle *relative) {
+	uio_MountInfo *relativeInfo;
+	int numPDirHandles;
+	uio_PDirHandle **pDirHandles;
+	uio_MountTreeItem **treeItems;
+	int i;
+	uio_MountHandle *handle = NULL;
+
+	if ((flags & uio_MOUNT_RDONLY) != uio_MOUNT_RDONLY) {
+		// Only read-only transplants supported atm
+		errno = ENOSYS;
+		return NULL;
+	}
+
+	switch (flags & uio_MOUNT_LOCATION_MASK) {
+		case uio_MOUNT_TOP:
+		case uio_MOUNT_BOTTOM:
+			if (relative != NULL) {
+				errno = EINVAL;
+				return NULL;
+			}
+			relativeInfo = NULL;
+			break;
+		case uio_MOUNT_BELOW:
+		case uio_MOUNT_ABOVE:
+			if (relative == NULL) {
+				errno = EINVAL;
+				return NULL;
+			}
+			relativeInfo = relative->mountInfo;
+			break;
+		default:
+			abort();
+	}
+
+	if (mountPoint[0] == '/')
+		mountPoint++;
+	if (!validPathName(mountPoint, strlen(mountPoint))) {
+		errno = EINVAL;
+		return NULL;
+	}
+
+	if (uio_getPathPhysicalDirs(sourceDir, "", 0,
+			&pDirHandles, &numPDirHandles, &treeItems) == -1) {
+		// errno is set
+		return NULL;
+	}
+	if (numPDirHandles == 0) {
+		errno = ENOENT;
+		return NULL;
+	}
+	
+	// TODO: We only transplant the first read-only physical dir that we find
+	//    Maybe transplant all of them? We would then have several
+	//    uio_MountHandles to return.
+	for (i = 0; i < numPDirHandles; ++i) {
+		uio_PDirHandle *pDirHandle = pDirHandles[i];
+		uio_MountInfo *oldMountInfo = treeItems[i]->mountInfo;
+		uio_Repository *rep = oldMountInfo->mountHandle->repository;
+		uio_MountInfo *mountInfo;
+		uio_MountTree *mountTree;
+
+		// Only interested in read-only dirs in this incarnation
+		if (!uio_mountInfoIsReadOnly(oldMountInfo))
+			continue;
+	
+		mountInfo = uio_MountInfo_new(oldMountInfo->fsID, NULL, pDirHandle,
+				uio_strdup(""), oldMountInfo->autoMount, NULL, flags);
+		// New mount references the same handles
+		uio_PDirHandle_ref(pDirHandle);
+		uio_PRoot_refMount(pDirHandle->pRoot);
+
+		uio_repositoryAddMount(rep, mountInfo,
+				flags & uio_MOUNT_LOCATION_MASK, relativeInfo);
+		mountTree = uio_mountTreeAddMountInfo(rep, rep->mountTree,
+				mountInfo, mountPoint, flags & uio_MOUNT_LOCATION_MASK,
+				relativeInfo);
+		// mountTree is the node in rep->mountTree where mountInfo leads to
+		mountInfo->mountTree = mountTree;
+		mountInfo->mountHandle = uio_MountHandle_new(rep, mountInfo);
+		handle = mountInfo->mountHandle;
+		break;
+	}
+
+	uio_PDirHandles_delete(pDirHandles, numPDirHandles);
+	uio_free(treeItems);
+	
+	if (handle == NULL)
+		errno = ENOENT;
+
+	return handle;
+}
+
 int
 uio_unmountDir(uio_MountHandle *mountHandle) {
 	uio_PRoot *pRoot;
diff -ruNp src.hd/libs/uio/io.h src/libs/uio/io.h
--- src.hd/libs/uio/io.h	2017-12-29 02:25:50 -0800
+++ src/libs/uio/io.h	2017-12-29 00:57:42 -0800
@@ -82,6 +82,12 @@ uio_MountHandle *uio_mountDir(uio_Reposi
 		const char *inPath, uio_AutoMount **autoMount, int flags,
 		uio_MountHandle *relative);
 
+// Mount a repository directory into same repository at a different
+// location.
+// From fossil.
+uio_MountHandle *uio_transplantDir(const char *mountPoint,
+		uio_DirHandle *sourceDir, int flags, uio_MountHandle *relative);
+
 // Unmount a previously mounted dir.
 int uio_unmountDir(uio_MountHandle *mountHandle);
 
diff -ruNp src.hd/libs/uio/ioaux.c src/libs/uio/ioaux.c
--- src.hd/libs/uio/ioaux.c	2017-12-29 02:25:50 -0800
+++ src/libs/uio/ioaux.c	2017-12-29 00:57:42 -0800
@@ -260,7 +260,7 @@ uio_copyFilePhysical(uio_PDirHandle *fro
  * Closes fromHandle if it's not -1.
  * Removes 'toName' from 'toDir' if it's not NULL.
  * Frees 'buf' if not NULL.
- * Always returns -1.
+ * Always returns -1, setting errno to 'error'.
  */
 static int
 copyError(int error,
@@ -605,15 +605,26 @@ uio_getPhysicalAccess(uio_DirHandle *dir
 	return 0;
 }
 
-// Get handles to the (existing) physical dirs that are effective in a
-// path 'path' relative from 'dirHandle'
-// returns the PDirHandles through '*pDirHandles'. It is NULL if none
-// were found.
-// If resItems != NULL, it returns the MountTreeItems belonging to those
-// PDIrHandles through *resItems. It is NULL if none were found.
-// numPDirHandles will contain the number of PDirHandles found.
-// returns 0 if everything went ok.
-// returns -1 in case of an error; errno is set.
+
+/**
+ * Get handles to the (existing) physical dirs that are effective in a
+ * path 'path' relative from 'dirHandle'
+ *
+ * @param[in]  pDirHandle The physical directory to which 'path' is
+ * 		relative.
+ * @param[in]  path       The path to get the physical dirs for, relative to
+ * 		'pDirHandle'
+ * @param[in]  pathLen    The string length of 'path'.
+ * @param[out] resPDirHandles *resPDirHandles is set to the handles to the
+ * 		(existing) physical dirs that are effective in 'path' (relative to
+ * 		pDirHandle), or NULL if there are none.
+ * @param[out] resNumPDirHandles The number of PDirHandles found.
+ * @param[out] resItems If 'resItems' != NULL, *resItems is set to the
+ * 		MountTreeItems belonging to $pDirHandles, or NULL if none were found.
+ *
+ * @retval 0   if everything went ok.
+ * @retval -1  if an error occurred; #errno is set.
+ */
 int
 uio_getPathPhysicalDirs(uio_DirHandle *dirHandle, const char *path,
 		size_t pathLen, uio_PDirHandle ***resPDirHandles,
diff -ruNp src.hd/libs/uio/match.c src/libs/uio/match.c
--- src.hd/libs/uio/match.c	2017-12-29 02:25:50 -0800
+++ src/libs/uio/match.c	2017-12-29 00:57:42 -0800
@@ -37,9 +37,9 @@
 static inline match_MatchContext *match_allocMatchContext(void);
 static inline void match_freeMatchContext(match_MatchContext *context);
 
-static inline match_LitteralContext *match_newLitteralContext(char *pattern);
-static inline match_LitteralContext *match_allocLitteralContext(void);
-static inline void match_freeLitteralContext(match_LitteralContext *context);
+static inline match_LiteralContext *match_newLiteralContext(char *pattern);
+static inline match_LiteralContext *match_allocLiteralContext(void);
+static inline void match_freeLiteralContext(match_LiteralContext *context);
 static inline match_PrefixContext *match_newPrefixContext(char *pattern);
 static inline match_PrefixContext *match_allocPrefixContext(void);
 static inline void match_freePrefixContext(match_PrefixContext *context);
@@ -85,9 +85,9 @@ match_prepareContext(const char *pattern
 	*contextPtr = match_allocMatchContext();
 	(*contextPtr)->type = type;
 	switch (type) {
-		case match_MATCH_LITTERAL:
-			result = match_prepareLitteral(pattern,
-					&(*contextPtr)->u.litteral);
+		case match_MATCH_LITERAL:
+			result = match_prepareLiteral(pattern,
+					&(*contextPtr)->u.literal);
 			break;
 		case match_MATCH_PREFIX:
 			result = match_preparePrefix(pattern, &(*contextPtr)->u.prefix);
@@ -122,8 +122,8 @@ match_prepareContext(const char *pattern
 match_Result
 match_matchPattern(match_MatchContext *context, const char *string) {
 	switch (context->type) {
-		case match_MATCH_LITTERAL:
-			return match_matchLitteral(context->u.litteral, string);
+		case match_MATCH_LITERAL:
+			return match_matchLiteral(context->u.literal, string);
 		case match_MATCH_PREFIX:
 			return match_matchPrefix(context->u.prefix, string);
 		case match_MATCH_SUFFIX:
@@ -168,8 +168,8 @@ match_errorString(match_MatchContext *co
 
 	switch (context->type) {
 #if 0
-		case match_MATCH_LITTERAL:
-			return match_errorStringLitteral(context->u.litteral, result);
+		case match_MATCH_LITERAL:
+			return match_errorStringLiteral(context->u.literal, result);
 		case match_MATCH_PREFIX:
 			return match_errorStringPrefix(context->u.prefix, result);
 		case match_MATCH_SUFFIX:
@@ -193,8 +193,8 @@ match_errorString(match_MatchContext *co
 void
 match_freeContext(match_MatchContext *context) {
 	switch (context->type) {
-		case match_MATCH_LITTERAL:
-			match_freeLitteral(context->u.litteral);
+		case match_MATCH_LITERAL:
+			match_freeLiteral(context->u.literal);
 			break;
 		case match_MATCH_PREFIX:
 			match_freePrefix(context->u.prefix);
@@ -239,43 +239,43 @@ out:
 }
 
 
-// *** Litteral part ***
+// *** Literal part ***
 
 match_Result
-match_prepareLitteral(const char *pattern,
-		match_LitteralContext **contextPtr) {
-	*contextPtr = match_newLitteralContext(uio_strdup(pattern));
+match_prepareLiteral(const char *pattern,
+		match_LiteralContext **contextPtr) {
+	*contextPtr = match_newLiteralContext(uio_strdup(pattern));
 	return match_OK;
 }
 
 match_Result
-match_matchLitteral(match_LitteralContext *context, const char *string) {
+match_matchLiteral(match_LiteralContext *context, const char *string) {
 	return (strcmp(context->pattern, string) == 0) ?
 			match_MATCH : match_NOMATCH;
 }
 
 void
-match_freeLitteral(match_LitteralContext *context) {
+match_freeLiteral(match_LiteralContext *context) {
 	uio_free(context->pattern);
-	match_freeLitteralContext(context);
+	match_freeLiteralContext(context);
 }
 
-static inline match_LitteralContext *
-match_newLitteralContext(char *pattern) {
-	match_LitteralContext *result;
+static inline match_LiteralContext *
+match_newLiteralContext(char *pattern) {
+	match_LiteralContext *result;
 
-	result = match_allocLitteralContext();
+	result = match_allocLiteralContext();
 	result->pattern = pattern;
 	return result;
 }
 
-static inline match_LitteralContext *
-match_allocLitteralContext(void) {
-	return uio_malloc(sizeof (match_LitteralContext));
+static inline match_LiteralContext *
+match_allocLiteralContext(void) {
+	return uio_malloc(sizeof (match_LiteralContext));
 }
 
 static inline void
-match_freeLitteralContext(match_LitteralContext *context) {
+match_freeLiteralContext(match_LiteralContext *context) {
 	uio_free(context);
 }
 
diff -ruNp src.hd/libs/uio/match.h src/libs/uio/match.h
--- src.hd/libs/uio/match.h	2017-12-29 02:25:50 -0800
+++ src/libs/uio/match.h	2017-12-29 00:57:42 -0800
@@ -31,7 +31,7 @@ typedef struct match_MatchContext match_
 
 
 typedef enum {
-	match_MATCH_LITTERAL = 0,
+	match_MATCH_LITERAL = 0,
 	match_MATCH_PREFIX,
 	match_MATCH_SUFFIX,
 	match_MATCH_SUBSTRING,
@@ -52,7 +52,7 @@ typedef int match_Result;
 #define match_ECUSTOM   -3
 #define match_ENOTINIT  -4
 
-typedef struct match_LitteralContext match_LitteralContext;
+typedef struct match_LiteralContext match_LiteralContext;
 typedef struct match_PrefixContext match_PrefixContext;
 typedef struct match_SuffixContext match_SuffixContext;
 typedef struct match_SubStringContext match_SubStringContext;
@@ -87,7 +87,7 @@ match_Result match_matchPatternOnce(cons
 struct match_MatchContext {
 	match_MatchType type;
 	union {
-		match_LitteralContext *litteral;
+		match_LiteralContext *literal;
 		match_PrefixContext *prefix;
 		match_SuffixContext *suffix;
 		match_SubStringContext *subString;
@@ -100,7 +100,7 @@ struct match_MatchContext {
 	} u;
 };
 
-struct match_LitteralContext {
+struct match_LiteralContext {
 	char *pattern;
 };
 
@@ -134,11 +134,11 @@ struct match_RegexContext {
 };
 #endif
 
-match_Result match_prepareLitteral(const char *pattern,
-		match_LitteralContext **contextPtr);
-match_Result match_matchLitteral(match_LitteralContext *context,
+match_Result match_prepareLiteral(const char *pattern,
+		match_LiteralContext **contextPtr);
+match_Result match_matchLiteral(match_LiteralContext *context,
 		const char *string);
-void match_freeLitteral(match_LitteralContext *context);
+void match_freeLiteral(match_LiteralContext *context);
 
 match_Result match_preparePrefix(const char *pattern,
 		match_PrefixContext **contextPtr);
diff -ruNp src.hd/libs/uio/mount.c src/libs/uio/mount.c
--- src.hd/libs/uio/mount.c	2017-12-29 02:25:50 -0800
+++ src/libs/uio/mount.c	2017-12-29 00:57:42 -0800
@@ -61,7 +61,7 @@ uio_repositoryAddMount(uio_Repository *r
 			repository->mounts[repository->numMounts] = mountInfo;
 			repository->numMounts++;
 			break;
-		case uio_MOUNT_BELOW: {
+		case uio_MOUNT_ABOVE: {
 			int i;
 			uio_MountInfo **newMounts;
 
@@ -76,7 +76,7 @@ uio_repositoryAddMount(uio_Repository *r
 			repository->numMounts++;
 			break;
 		}
-		case uio_MOUNT_ABOVE: {
+		case uio_MOUNT_BELOW: {
 			int i;
 			uio_MountInfo **newMounts;
 
diff -ruNp src.hd/libs/uio/physical.c src/libs/uio/physical.c
--- src.hd/libs/uio/physical.c	2017-12-29 02:25:50 -0800
+++ src/libs/uio/physical.c	2017-12-29 00:57:42 -0800
@@ -157,7 +157,7 @@ uio_PRoot_refMount(uio_PRoot *pRoot) {
 #ifdef uio_MEM_DEBUG
 	uio_MemDebug_debugRef(uio_PRoot, (void *) pRoot);
 #endif
-	pRoot->handleRef++;
+	pRoot->mountRef++;
 }
 
 void
diff -ruNp src.hd/libs/uio/stdio/Makeinfo src/libs/uio/stdio/Makeinfo
--- src.hd/libs/uio/stdio/Makeinfo	2017-12-29 02:25:50 -0800
+++ src/libs/uio/stdio/Makeinfo	2017-12-29 00:57:42 -0800
@@ -1,3 +1,2 @@
 uqm_CFILES="stdio.c"
-
-
+uqm_HFILES="stdio.h"
diff -ruNp src.hd/libs/uio/uiostream.c src/libs/uio/uiostream.c
--- src.hd/libs/uio/uiostream.c	2017-12-29 02:25:50 -0800
+++ src/libs/uio/uiostream.c	2017-12-29 00:57:42 -0800
@@ -265,8 +265,8 @@ uio_ungetc(int c, uio_Stream *stream) {
 	assert(c >= 0 && c <= 255);
 
 	return (int) EOF;
-						// XXX: not implemented
-	//return c;
+			// not implemented
+//	return c;
 }
 
 // JMS: The datastream can be stepped back n bytes with this baby.
diff -ruNp src.hd/libs/uio/uioutils.h src/libs/uio/uioutils.h
--- src.hd/libs/uio/uioutils.h	2017-12-29 02:25:51 -0800
+++ src/libs/uio/uioutils.h	2017-12-29 00:57:42 -0800
@@ -44,8 +44,8 @@ char *dosToUnixPath(const char *path);
 static inline void *
 unconst(const void *arg) {
 	union {
-		char *c;
-		const char *cc;
+		void *c;
+		const void *cc;
 	} u;
 	u.cc = arg;
 	return u.c;
diff -ruNp src.hd/libs/uio/zip/Makeinfo src/libs/uio/zip/Makeinfo
--- src.hd/libs/uio/zip/Makeinfo	2017-12-29 02:25:51 -0800
+++ src/libs/uio/zip/Makeinfo	2017-12-29 00:57:42 -0800
@@ -1,3 +1,2 @@
 uqm_CFILES="zip.c"
-
-
+uqm_HFILES="zip.h"
diff -ruNp src.hd/libs/uio.h src/libs/uio.h
--- src.hd/libs/uio.h	2017-12-29 02:25:51 -0800
+++ src/libs/uio.h	2017-12-29 00:57:42 -0800
@@ -21,7 +21,15 @@
 #ifndef _UIO_H
 #define _UIO_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #include "uio/io.h"
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _UIO_H */
 
diff -ruNp src.hd/libs/uioutils.h src/libs/uioutils.h
--- src.hd/libs/uioutils.h	2017-12-29 02:25:51 -0800
+++ src/libs/uioutils.h	2017-12-29 00:57:42 -0800
@@ -21,7 +21,15 @@
 #ifndef _UIOUTILS_H
 #define _UIOUTILS_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #include "uio/utils.h"
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _UIOUTILS_H */
 
diff -ruNp src.hd/libs/unicode.h src/libs/unicode.h
--- src.hd/libs/unicode.h	2017-12-29 02:25:51 -0800
+++ src/libs/unicode.h	2017-12-29 00:57:42 -0800
@@ -23,6 +23,10 @@
 #include <sys/types.h>
 		// For size_t
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef uint32 UniChar;
 
 #ifdef UNICODE_INTERNAL
@@ -60,5 +64,9 @@ UniChar UniChar_toLower(UniChar ch);
 
 #undef UNICODE_CHAR
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* UNICODE_H */
 
diff -ruNp src.hd/libs/video/Makeinfo src/libs/video/Makeinfo
--- src.hd/libs/video/Makeinfo	2017-12-29 02:25:51 -0800
+++ src/libs/video/Makeinfo	2017-12-29 00:57:42 -0800
@@ -1,2 +1,3 @@
 uqm_CFILES="vfileins.c vresins.c video.c videodec.c vidplayer.c dukvid.c \
             legacyplayer.c"
+uqm_HFILES="dukvid.h videodec.h video.h vidintrn.h vidplayer.h"
diff -ruNp src.hd/libs/video/dukvid.c src/libs/video/dukvid.c
--- src.hd/libs/video/dukvid.c	2017-12-29 02:25:51 -0800
+++ src/libs/video/dukvid.c	2017-12-29 00:57:42 -0800
@@ -727,7 +727,8 @@ dukv_SeekTime (THIS_PTR, float time)
 	//TFB_DuckVideoDecoder* dukv = (TFB_DuckVideoDecoder*) This;
 	uint32 frame = (uint32) (time * DUCK_GENERAL_FPS);
 	
-	return (float) dukv_SeekFrame (This, frame) / DUCK_GENERAL_FPS;
+	// Note that DUCK_GENERAL_FPS is a float constant
+	return dukv_SeekFrame (This, frame) / DUCK_GENERAL_FPS;
 }
 
 static uint32
diff -ruNp src.hd/libs/video/video.c src/libs/video/video.c
--- src.hd/libs/video/video.c	2017-12-29 02:25:51 -0800
+++ src/libs/video/video.c	2017-12-29 00:57:42 -0800
@@ -127,7 +127,6 @@ VidPlayEx (VIDEO_REF vid, MUSIC_REF AudR
 	_cur_speech = 0;
 	_cur_video = NULL_VIDEO_REF;
 
-	LockMutex (GraphicsLock);
 	// play video in the center of the screen
 	if (TFB_PlayVideo (vid, (ScreenWidth - vid->w) / 2,
 			(ScreenHeight - vid->h) / 2))
@@ -144,7 +143,6 @@ VidPlayEx (VIDEO_REF vid, MUSIC_REF AudR
 	{
 		ret = NO_FMV;
 	}
-	UnlockMutex (GraphicsLock);
 
 	return ret;
 }
diff -ruNp src.hd/libs/video/vidintrn.h src/libs/video/vidintrn.h
--- src.hd/libs/video/vidintrn.h	2017-12-29 02:25:51 -0800
+++ src/libs/video/vidintrn.h	2017-12-29 00:57:42 -0800
@@ -38,10 +38,4 @@ struct legacy_video_ref
 	MUSIC_REF speechref;
 };
 
-// XXX: There has to be a better way to synchronize gfx calls with the rest
-//   of the game. The only thing we need to sync is the current context, and
-//   even there only the cliprect. Perhaps a DCQ command that takes an
-//   explicit cliprect would be better.
-extern Mutex GraphicsLock;
-
 #endif
diff -ruNp src.hd/libs/video/vidplayer.c src/libs/video/vidplayer.c
--- src.hd/libs/video/vidplayer.c	2017-12-29 02:25:51 -0800
+++ src/libs/video/vidplayer.c	2017-12-29 00:57:42 -0800
@@ -15,7 +15,7 @@
  */
 
 #include "vidplayer.h"
-
+#include "options.h"
 #include "vidintrn.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/graphics/tfb_draw.h"
@@ -143,14 +143,12 @@ processAudioSyncedFrame (VIDEO_REF vid)
 	vid->cur_frame = vid->decoder->cur_frame;
 
 	// draw the frame
-	LockMutex (GraphicsLock);
 	// We have the cliprect precalculated and don't need the rest
 	oldContext = SetContext (NULL);
 	TFB_DrawScreen_Image (vid->frame,
 			vid->dst_rect.corner.x, vid->dst_rect.corner.y, 0, 0,
 			NULL, DRAW_REPLACE_MODE, TFB_SCREEN_MAIN);
 	SetContext (oldContext);
-	UnlockMutex (GraphicsLock);
 	FlushGraphics (); // needed to prevent half-frame updates
 
 	// increase interframe with positive lag-count to allow audio to catch up
@@ -195,14 +193,12 @@ processMuteFrame (VIDEO_REF vid)
 		
 		vid->cur_frame = vid->decoder->cur_frame;
 
-		LockMutex (GraphicsLock);
 		// We have the cliprect precalculated and don't need the rest
 		oldContext = SetContext (NULL);
 		TFB_DrawScreen_Image (vid->frame,
 				vid->dst_rect.corner.x, vid->dst_rect.corner.y, 0, 0,
 				NULL, DRAW_REPLACE_MODE, TFB_SCREEN_MAIN);
 		SetContext (oldContext);
-		UnlockMutex (GraphicsLock);
 		FlushGraphics (); // needed to prevent half-frame updates
 
 		if (vid->cur_frame == vid->loop_frame)
@@ -235,7 +231,7 @@ TFB_PlayVideo (VIDEO_REF vid, uint32 x,
 	if (!BoxIntersect(&scrn_r, &vid_r, &scrn_r))
 		return false; // drawing outside visible
 
-	sr = dr;    
+	sr = dr;
     // JMS_GFX: Added this if-clause around the following lines to make the
     // 3DO videos work also in 1280x960. They're still small though.
     if (resolutionFactor < 2) {
@@ -277,7 +273,7 @@ TFB_PlayVideo (VIDEO_REF vid, uint32 x,
 		}
 
 		TFB_SetSoundSampleCallbacks (*vid->hAudio, &vp_AudioCBs);
-		TFB_SetSoundSampleData (*vid->hAudio, (intptr_t)vid);
+		TFB_SetSoundSampleData (*vid->hAudio, vid);
 	}
 
 	// get the first frame
@@ -436,7 +432,7 @@ vp_SetTimer (TFB_VideoDecoder* decoder,
 static bool
 vp_AudioStart (TFB_SoundSample* sample)
 {
-	TFB_VideoClip* vid = (TFB_VideoClip*) TFB_GetSoundSampleData (sample);
+	TFB_VideoClip* vid = TFB_GetSoundSampleData (sample);
 	TFB_SoundDecoder *decoder;
 
 	assert (sizeof (intptr_t) >= sizeof (vid));
@@ -454,7 +450,7 @@ vp_AudioStart (TFB_SoundSample* sample)
 static void
 vp_AudioEnd (TFB_SoundSample* sample)
 {
-	TFB_VideoClip* vid = (TFB_VideoClip*) TFB_GetSoundSampleData (sample);
+	TFB_VideoClip* vid = TFB_GetSoundSampleData (sample);
 
 	assert (vid != NULL);
 
@@ -466,7 +462,7 @@ vp_AudioEnd (TFB_SoundSample* sample)
 static void
 vp_BufferTag (TFB_SoundSample* sample, TFB_SoundTag* tag)
 {
-	TFB_VideoClip* vid = (TFB_VideoClip*) TFB_GetSoundSampleData (sample);
+	TFB_VideoClip* vid = TFB_GetSoundSampleData (sample);
 	uint32 frame = (uint32) tag->data;
 
 	assert (sizeof (tag->data) >= sizeof (frame));
diff -ruNp src.hd/libs/vidlib.h src/libs/vidlib.h
--- src.hd/libs/vidlib.h	2017-12-29 02:25:51 -0800
+++ src/libs/vidlib.h	2017-12-29 00:57:43 -0800
@@ -23,6 +23,10 @@
 #include "libs/sndlib.h"
 #include "libs/reslib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef enum
 {
 	NO_FMV = 0,
@@ -57,4 +61,8 @@ extern LEGACY_VIDEO_REF PlayLegacyVideo
 extern void StopLegacyVideo (LEGACY_VIDEO_REF ref);
 extern BOOLEAN PlayingLegacyVideo (LEGACY_VIDEO_REF ref);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _VIDLIB_H */
diff -ruNp src.hd/options.c src/options.c
--- src.hd/options.c	2017-12-29 02:25:51 -0800
+++ src/options.c	2017-12-29 00:57:43 -0800
@@ -14,8 +14,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 /*
  * Eventually this should include all configuration stuff, 
  * for now there's few options which indicate 3do/pc flavors.
@@ -57,18 +55,12 @@ const char **optAddons;
 // JMS_GFX
 unsigned int loresBlowupScale;
 unsigned int resolutionFactor;
-BOOLEAN forceAspectRatio;
 BOOLEAN resFactorWasChanged;
 
-// JMS
-BOOLEAN optMainmenuMusic;
-BOOLEAN optMineralSubmenu;
-BOOLEAN optNebulae;
-BOOLEAN optRotatingIpPlanets;
-BOOLEAN optTexturedIpPlanets;
-BOOLEAN optCheatMode;
-BOOLEAN optGodMode; // Serosis
-unsigned int timeDilationScale;
+BOOLEAN optCheatMode; // JMS
+// Serosis
+BOOLEAN optGodMode;
+int timeDilationScale;
 BOOLEAN optBubbleWarp;
 BOOLEAN optUnlockShips;
 BOOLEAN optHeadStart;
@@ -77,12 +69,32 @@ BOOLEAN optInfiniteRU;
 DWORD oldRU;
 BOOLEAN optSkipIntro;
 BOOLEAN optFMV;
+// JMS
+BOOLEAN optMainMenuMusic;
+BOOLEAN optNebulae;
+BOOLEAN optOrbitingPlanets;
+BOOLEAN optTexturedPlanets;
+// Nic
+int optDateFormat;
+// Serosis
+BOOLEAN optInfiniteFuel;
+DWORD loadFuel;
+BOOLEAN optThraddStory;
+BOOLEAN optPartialPickup;
+BOOLEAN optSubmenu;
+BOOLEAN optAddDevices;
+BOOLEAN optScalePlanets;
+BOOLEAN optSuperMelee;
 
 BOOLEAN opt3doMusic;
 BOOLEAN optRemixMusic;
+BOOLEAN optSpeech;
 BOOLEAN optSubtitles;
 BOOLEAN optStereoSFX;
 BOOLEAN optKeepAspectRatio;
+
+float optGamma;
+
 uio_DirHandle *contentDir;
 uio_DirHandle *configDir;
 uio_DirHandle *saveDir;
@@ -384,7 +396,6 @@ mountAddonDir (uio_Repository *repositor
 	static uio_AutoMount *autoMount[] = { NULL };
 	uio_MountHandle *mountHandle;
 	uio_DirList *availableAddons;
-	char mountname[128]; // MB to JMS: no need to manually terminate string, snprintf does it for you. Moving mountname outside of loop.
 
 	if (addonDirName != NULL)
 	{
@@ -441,10 +452,9 @@ mountAddonDir (uio_Repository *repositor
 				count == 1 ? "" : "s");
 
 		count = 0;
-
 		for (i = 0; i < availableAddons->numNames; ++i)
 		{
-			
+			char mountname[128];
 			uio_DirHandle *addonDir;
 			const char *addon = availableAddons->names[i];
 			
@@ -453,7 +463,7 @@ mountAddonDir (uio_Repository *repositor
 
 			++count;
 			log_add (log_Info, "    %d. %s", count, addon);
-
+		
 			snprintf (mountname, sizeof mountname, "addons/%s", addon);
 
 			addonDir = uio_openDirRelative (addonsDir, addon, 0);
@@ -555,6 +565,11 @@ loadAddon (const char *addon)
 	}
 
 	numLoaded = loadIndices (addonDir);
+	if (!numLoaded)
+	{
+		log_add (log_Error, "No RMP index files were loaded for addon '%s'",
+				addon);
+	}
 
 	uio_closeDir (addonDir);
 	uio_closeDir (addonsDir);
@@ -590,6 +605,14 @@ prepareShadowAddons (const char **addons
 		{
 			log_add (log_Debug, "Mounting shadow content of '%s' addon", addon);
 			mountDirZips (shadowDir, "/", uio_MOUNT_ABOVE, contentMountHandle);
+			// Mount non-zipped shadow content
+			if (uio_transplantDir ("/", shadowDir, uio_MOUNT_RDONLY |
+					uio_MOUNT_ABOVE, contentMountHandle) == NULL)
+			{
+				log_add (log_Warning, "Warning: Could not mount shadow content"
+						" of '%s': %s.", addon, strerror (errno));
+			}
+
 			uio_closeDir (shadowDir);
 		}
 		uio_closeDir (addonDir);
@@ -606,7 +629,46 @@ prepareAddons (const char **addons)
 		log_add (log_Info, "Loading addon '%s'", *addons);
 		if (!loadAddon (*addons))
 		{
+			// TODO: Should we do something like inform the user?
+			//   Why simply refuse to load other addons?
+			//   Maybe exit() to inform the user of the failure?
 			break;
 		}
 	}
 }
+
+void
+unprepareAllDirs (void)
+{
+	if (saveDir)
+	{
+		uio_closeDir (saveDir);
+		saveDir = 0;
+	}
+	if (meleeDir)
+	{
+		uio_closeDir (meleeDir);
+		meleeDir = 0;
+	}
+	if (contentDir)
+	{
+		uio_closeDir (contentDir);
+		contentDir = 0;
+	}
+	if (configDir)
+	{
+		uio_closeDir (configDir);
+		configDir = 0;
+	}
+}
+
+bool
+setGammaCorrection (float gamma)
+{
+	bool set = TFB_SetGamma (gamma);
+	if (set)
+		log_add (log_Info, "Gamma correction set to %.4f.", gamma);
+	else
+		log_add (log_Warning, "Unable to set gamma correction.");
+	return set;
+}
diff -ruNp src.hd/options.h src/options.h
--- src.hd/options.h	2017-12-29 02:25:51 -0800
+++ src/options.h	2017-12-29 00:57:43 -0800
@@ -14,14 +14,11 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 /*
  * Eventually this should include all configuration stuff, 
  * for now there's few options which indicate 3do/pc flavors.
  */
 
-
 #ifndef OPTIONS_H
 #define OPTIONS_H
 
@@ -29,9 +26,13 @@
 #include "libs/compiler.h"
 #include "libs/uio.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #define OPT_3DO 0x01
 #define OPT_PC  0x02
-#define OPT_ALL 0xFF // This is never used, WTF?
+#define OPT_ALL 0xFF
 
 extern int optWhichCoarseScan;
 extern int optWhichMenu;
@@ -44,19 +45,14 @@ extern int optMeleeScale;
 // JMS_GFX
 extern unsigned int loresBlowupScale;
 extern unsigned int resolutionFactor;
-extern BOOLEAN forceAspectRatio;
 extern BOOLEAN resFactorWasChanged;
 
-// JMS
-extern BOOLEAN optMainmenuMusic;
-extern BOOLEAN optMineralSubmenu;
-extern BOOLEAN optNebulae;
-extern BOOLEAN optRotatingIpPlanets;
-extern BOOLEAN optTexturedIpPlanets;
-extern BOOLEAN optCheatMode;
-extern BOOLEAN optGodMode; // Serosis
-extern unsigned int timeDilationScale;
+extern BOOLEAN optCheatMode; // JMS
+// Serosis
+extern BOOLEAN optGodMode;
+extern int timeDilationScale;
 extern BOOLEAN optBubbleWarp;
+extern BOOLEAN optRoseBud;
 extern BOOLEAN optUnlockShips;
 extern BOOLEAN optHeadStart;
 extern BOOLEAN optUnlockUpgrades;
@@ -64,13 +60,33 @@ extern BOOLEAN optInfiniteRU;
 extern DWORD oldRU;
 extern BOOLEAN optSkipIntro;
 extern BOOLEAN optFMV;
+// JMS
+extern BOOLEAN optMainMenuMusic;
+extern BOOLEAN optNebulae;
+extern BOOLEAN optOrbitingPlanets;
+extern BOOLEAN optTexturedPlanets;
+// Nic
+extern int optDateFormat;
+// Serosis
+extern BOOLEAN optInfiniteFuel;
+extern DWORD loadFuel;
+extern BOOLEAN optThraddStory;
+extern BOOLEAN optPartialPickup;
+extern BOOLEAN optSubmenu;
+extern BOOLEAN optAddDevices;
+extern BOOLEAN optScalePlanets;
+extern BOOLEAN optSuperMelee;
 
 extern BOOLEAN opt3doMusic;
 extern BOOLEAN optRemixMusic;
+extern BOOLEAN optSpeech;
 extern BOOLEAN optSubtitles;
 extern BOOLEAN optStereoSFX;
 extern BOOLEAN optKeepAspectRatio;
 
+#define GAMMA_SCALE  1000
+extern float optGamma;
+
 extern uio_DirHandle *contentDir;
 extern uio_DirHandle *configDir;
 extern uio_DirHandle *saveDir;
@@ -98,9 +114,16 @@ void prepareMeleeDir (void);
 void prepareSaveDir (void);
 void prepareAddons (const char **addons);
 void prepareShadowAddons (const char **addons);
+void unprepareAllDirs (void);
 
 BOOLEAN loadAddon (const char *addon);
 int loadIndices (uio_DirHandle *baseDir);
 
+bool setGammaCorrection (float gamma);
+
+#if defined(__cplusplus)
+}
+#endif
+
 #endif
 
diff -ruNp src.hd/port.h src/port.h
--- src.hd/port.h	2017-12-29 02:25:51 -0800
+++ src/port.h	2017-12-29 00:57:43 -0800
@@ -79,12 +79,24 @@
 
 
 #ifndef HAVE_STRUPR
+#if defined(__cplusplus)
+extern "C" {
+#endif
 char *strupr (char *str);
+#if defined(__cplusplus)
+}
+#endif
 #endif
 
 #if !defined (_MSC_VER) && !defined (HAVE_READDIR_R)
 #	include <dirent.h>
+#if defined(__cplusplus)
+extern "C" {
+#endif
 int readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result);
+#if defined(__cplusplus)
+}
+#endif
 #endif
 
 // Directories
@@ -161,10 +173,21 @@ typedef unsigned short mode_t;
 #ifdef _MSC_VER
 #	include <stdarg.h>
 // Defined in port.c
+#if defined(__cplusplus)
+extern "C" {
+#endif
 int snprintf(char *str, size_t size, const char *format, ...);
-// int vsnprintf(char *str, size_t size, const char *format, va_list args);   //DC: Removed as recommended by http://forum.uqm.stack.nl/index.php?topic=4896.0
+// int vsnprintf(char *str, size_t size, const char *format, va_list args);
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _MSC_VER */
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 // setenv()
 #ifndef HAVE_SETENV
 int setenv (const char *name, const char *value, int overwrite);
@@ -178,6 +201,10 @@ typedef unsigned short wchar_t;
 typedef unsigned int wint_t;
 #endif
 
+#if defined(__cplusplus)
+}
+#endif
+
 #if defined (_MSC_VER) || defined(__MINGW32__)
 #	define USE_WINSOCK
 #endif
@@ -546,3 +573,4 @@ typedef unsigned int wint_t;
 // "d:foo/bar" (without a slash after the drive letter) are to be rejected.
 
 #endif  /* _PORT_H */
+
diff -ruNp src.hd/regex/Makeinfo src/regex/Makeinfo
--- src.hd/regex/Makeinfo	2017-12-29 02:25:51 -0800
+++ src/regex/Makeinfo	2017-12-29 00:57:43 -0800
@@ -1,2 +1,2 @@
 uqm_CFILES="regex.c"
-
+uqm_HFILES="regex.h regex_internal.h"
diff -ruNp src.hd/res/darwin/Info.plist src/res/darwin/Info.plist
--- src.hd/res/darwin/Info.plist	2017-12-29 02:25:51 -0800
+++ src/res/darwin/Info.plist	2017-12-29 00:57:43 -0800
@@ -5,7 +5,7 @@
 	<key>CFBundleDevelopmentRegion</key>
 	<string>English</string>
 	<key>CFBundleExecutable</key>
-	<string>The Ur-Quan Masters HD MegaMod</string>
+	<string>The Ur-Quan Masters MegaMod</string>
 	<key>CFBundleIconFile</key>
 	<string>The Ur-Quan Masters.icns</string>
 	<key>CFBundleInfoDictionaryVersion</key>
Files src.hd/res/darwin/The Ur-Quan Masters.icns and src/res/darwin/The Ur-Quan Masters.icns differ
Files src.hd/res/kohr-ah1.ico and src/res/kohr-ah1.ico differ
Files src.hd/res/ur-quan3.ico and src/res/ur-quan3.ico differ
diff -ruNp src.hd/svnversion.h src/svnversion.h
--- src.hd/svnversion.h	2017-12-29 02:25:51 -0800
+++ src/svnversion.h	1969-12-31 16:00:00 -0800
@@ -1 +0,0 @@
-#define UQMHD_SVN_REVISION "1498:1501M"
diff -ruNp src.hd/tools/LICENSE.txt src/tools/LICENSE.txt
--- src.hd/tools/LICENSE.txt	2017-12-29 02:25:51 -0800
+++ src/tools/LICENSE.txt	1969-12-31 16:00:00 -0800
@@ -1,19 +0,0 @@
-Copyright (C) 2010 Joris van de Donk
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-Joris van de Donk - joris@mooses.nl
\ No newline at end of file
Files src.hd/tools/lib/xstream-1.3.1.jar and src/tools/lib/xstream-1.3.1.jar differ
diff -ruNp src.hd/tools/savefont/LICENSE.txt src/tools/savefont/LICENSE.txt
--- src.hd/tools/savefont/LICENSE.txt	2017-12-29 02:25:51 -0800
+++ src/tools/savefont/LICENSE.txt	1969-12-31 16:00:00 -0800
@@ -1,19 +0,0 @@
-Copyright (C) 2010 Benjamin Wack
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-Benjamin Wack - benjamin.wack@free.fr
\ No newline at end of file
diff -ruNp src.hd/tools/savefont/readme.txt src/tools/savefont/readme.txt
--- src.hd/tools/savefont/readme.txt	2017-12-29 02:25:51 -0800
+++ src/tools/savefont/readme.txt	1969-12-31 16:00:00 -0800
@@ -1,9 +0,0 @@
-savefont.scm is a Gimp script.
-To use it, place it in <Home>/.gimp-2.6/script, restart Gimp and you'll find it under File/Create/Save font as images
-
-Given a font, a size in pixels and a destination directory, it creates a set of png images for each character (ascii code ranging from 33 to 125).
-Built-in features which are not accessible directly :
-- created characters are white
-- created characters are anti-aliased (using partial transparency)
-- pngs are cropped horizontally to the exact size of the character, and vertically to the maximum height occupied by font characters (unless the font is ill-defined)
-
diff -ruNp src.hd/tools/savefont/renumber.bat src/tools/savefont/renumber.bat
--- src.hd/tools/savefont/renumber.bat	2017-12-29 02:25:51 -0800
+++ src/tools/savefont/renumber.bat	1969-12-31 16:00:00 -0800
@@ -1,292 +0,0 @@
-REM !
-ren 33.png 00021.png
-
-REM "
-ren 34.png 00022.png
-
-
-REM #
-ren 35.png 0023.png
-
-REM $
-ren 36.png 0024.png
-
-REM %
-ren 37.png 0025.png
-
-REM &
-ren 38.png 0026.png
-
-
-REM '
-ren 39.png 0027.png
-
-REM (
-ren 40.png 0028.png
-
-REM ///
-ren 41.png 0029.png
-
-REM *
-ren 42.png 0002a.png
-
-REM +
-ren 43.png 0002b.png
-
-
-REM ,
-ren 44.png 0002c.png
-
-REM ,
-ren 45.png 0002d.png
-
-REM .
-ren 46.png 0002e.png
-
-REM .
-ren 47.png 0002f.png
-
-REM 0
-ren 48.png 00030.png
-
-REM 1
-ren 49.png 00031.png
-
-REM 2
-ren 50.png 00032.png
-
-REM 3
-ren 51.png 00033.png
-
-REM 4
-ren 52.png 00034.png
-
-REM 5
-ren 53.png 00035.png
-
-REM 6
-ren 54.png 00036.png
-
-REM 7
-ren 55.png 00037.png
-
-REM 8
-ren 56.png 00038.png
-
-
-REM 9
-ren 57.png 00039.png
-
-
-REM :
-ren 58.png 0003a.png
-
-REM ;
-ren 59.png 0003b.png
-
-
-REM <
-ren 60.png 0003c.png
-
-
-REM =
-ren 61.png 0003d.png
-
-
-REM >
-ren 62.png 0003e.png
-
-
-REM ?
-ren 63.png 0003f.png
-
-
-REM @
-ren 64.png 00040.png
-
-REM A
-ren 65.png 00041.png
-
-REM B
-ren 66.png 00042.png
-
-REM C
-ren 67.png 00043.png
-
-REM D
-ren 68.png 00044.png
-
-REM E
-ren 69.png 00045.png
-
-REM F
-ren 70.png 00046.png
-
-REM G
-ren 71.png 00047.png
-
-REM H
-ren 72.png 00048.png
-
-REM I
-ren 73.png 00049.png
-
-REM J
-ren 74.png 0004a.png
-
-REM K
-ren 75.png 0004b.png
-
-REM L
-ren 76.png 0004c.png
-
-REM M
-ren 77.png 0004d.png
-
-REM N
-ren 78.png 0004e.png
-
-REM O
-ren 79.png 0004f.png
-
-REM P
-ren 80.png 00050.png
-
-REM Q
-ren 81.png 00051.png
-
-REM R
-ren 82.png 00052.png
-
-REM S
-ren 83.png 00053.png
-
-REM T
-ren 84.png 00054.png
-
-REM U
-ren 85.png 00055.png
-
-REM V
-ren 86.png 00056.png
-
-REM W
-ren 87.png 00057.png
-
-REM W
-ren 88.png 00058.png
-
-REM Y
-ren 89.png 00059.png
-
-REM Z
-ren 90.png 0005a.png
-
-REM [
-ren 91.png 0005b.png
-
-REM \
-ren 92.png 0005c.png
-
-REM ]
-ren 93.png 0005d.png
-
-REM ^
-ren 94.png 0005e.png
-
-REM _
-ren 95.png 0005f.png
-
-REM `
-ren 96.png 0006a.png
-
-REM a
-ren 97.png 00061.png
-
-REM b
-ren 98.png 00062.png
-
-REM c
-ren 99.png 00063.png
-
-REM d
-ren 100.png 00064.png
-
-REM e
-ren 101.png 00065.png
-
-REM f
-ren 102.png 00066.png
-
-REM g
-ren 103.png 00067.png
-
-REM h
-ren 104.png 00068.png
-
-REM i
-ren 105.png 00069.png
-
-REM j
-ren 106.png 0006a.png
-
-REM k
-ren 107.png 0006b.png
-
-REM l
-ren 108.png 0006c.png
-
-REM m
-ren 109.png 0006d.png
-
-REM n
-ren 110.png 0006e.png
-
-REM o
-ren 111.png 0006f.png
-
-REM p
-ren 112.png 00070.png
-
-REM q
-ren 113.png 00071.png
-
-REM r
-ren 114.png 00072.png
-
-REM s
-ren 115.png 00073.png
-
-REM t
-ren 116.png 00074.png
-
-REM u
-ren 117.png 00075.png
-
-REM v
-ren 118.png 00076.png
-
-REM w
-ren 119.png 00077.png
-
-REM x
-ren 120.png 00078.png
-
-REM y
-ren 121.png 00079.png
-
-REM z
-ren 122.png 0007a.png
-
-REM {
-ren 123.png 0007b.png
-
-REM |
-ren 124.png 0007b.png
-
-REM }
-ren 125.png 0007d.png
-
-REM }
-ren 126.png 0007e.png
-
diff -ruNp src.hd/tools/savefont/savefont.scm src/tools/savefont/savefont.scm
--- src.hd/tools/savefont/savefont.scm	2017-12-29 02:25:51 -0800
+++ src/tools/savefont/savefont.scm	1969-12-31 16:00:00 -0800
@@ -1,146 +0,0 @@
-;; recurse save-character on Ascii codes from 33 to 125
-(define (sfsfrec inAscii inFont inFontsize inDir)
-  (if (<= inAscii 125)
-      (
-       (save-character inAscii inFont inFontsize inDir)
-       (sfsfrec (+ inAscii 1) inFont inFontsize inDir)
-       )
-      ()
-      )
-  )
-
-(define (script-fu-save-font inFont inFontsize inDir)
-  (sfsfrec 33 inFont inFontsize inDir)
-  )
-
-;; save a character by its ascii code into the given dir
-(define (save-character inAscii inFont inFontSize inDir)
-  (let*
-      (
-					; define our local variables
-					; create a new image:
-       (theImageWidth  1)
-       (theImageHeight 1)
-       (theImage (car
-		  (gimp-image-new
-		   theImageWidth
-		   theImageHeight
-		   RGB
-		   )
-		  )
-                 )
-       (theText)
-       (theFontSize inFontSize)
-       (theLayer
-	(car
-	 (gimp-layer-new
-	  theImage
-	  theImageWidth
-	  theImageHeight
-	  RGBA-IMAGE
-	  "layer 1"
-	  100
-	  NORMAL
-	  )
-	 )
-	)
-;       used to crop the image horizontally but not vertically
-       (theBaseLayer
-	(car
-	 (gimp-layer-new
-	  theImage
-	  theImageWidth
-	  theImageHeight
-	  RGBA-IMAGE
-	  "layer 0"
-	  100
-	  NORMAL
-	  )
-	 )
-	)
-       (theFilename (string-append inDir "/" (number->string inAscii) ".png"))
-       )
-    
-					; the function itself
-; create an image with the character and resize it
-    (gimp-image-add-layer theImage theLayer 0)
-    (gimp-image-add-layer theImage theBaseLayer 1)
-    (gimp-context-set-background '(0 0 0))
-    (gimp-context-set-foreground '(255 255 255))
-    (gimp-drawable-fill theLayer TRANSPARENT-FILL)
-    
-       (set! theText
-       	     (car
-       	      (gimp-text-fontname
-       	       theImage theLayer
-       	       0 0
-       	       (string (integer->char inAscii))
-       	       0
-       	       TRUE ; Anti-aliasing
-       	       theFontSize PIXELS
-       	       inFont)
-       	      )
-       	     )
-
-       (set! theImageHeight  (car (gimp-drawable-height theText) ) )
-
-       	(set! theImageWidth   (car (gimp-drawable-width  theText) ) )
-
-        (gimp-image-resize theImage theImageWidth theImageHeight 0 0)
-	
-	(gimp-layer-resize theLayer theImageWidth theImageHeight 0 0)
-
-	(gimp-layer-resize theBaseLayer theImageWidth theImageHeight 0 0)
-
-       (gimp-floating-sel-anchor theText)
-
-
-       ;; Height is resized before autocropping only to keep V-alignment of characters
-	;; Width is resized after to remove whitespaces
-
-	(plug-in-autocrop-layer RUN-NONINTERACTIVE theImage theLayer)
-
-	;; Character has to be pushed to the left
-	(let* (
-	       (ox (car (gimp-drawable-offsets theLayer)))
-	       (oy (cadr (gimp-drawable-offsets theLayer)))
-	       )
-	  
-	  (gimp-layer-translate theLayer (- ox) 0)
-	  )
-	
-        (set! theImageWidth   (car (gimp-drawable-width  theLayer) ) )
-
-        (gimp-image-resize theImage theImageWidth theImageHeight 0 0)
-	
-        (gimp-layer-resize theBaseLayer theImageWidth theImageHeight 0 0)
-
-	(gimp-image-merge-visible-layers theImage EXPAND-AS-NECESSARY)
-	
-;	(gimp-display-new theImage)
-
-;       (gimp-image-clean-all theImage) ; To prevent save prompt during testing
-
-       (file-png-save-defaults RUN-NONINTERACTIVE theImage (car (gimp-image-get-active-drawable theImage)) theFilename theFilename)
-       
-    )
-  )
-
-
-(script-fu-register
-    "script-fu-save-font"                        ;func name
-    "Save Font as Images"                                  ;menu label
-    "Creates pngs for each character in a\
-      font. Characters are white on a transparent\
-      background."              ;description
-    "Benjamin Wack"                             ;author
-    "copyright 2010, Benjamin Wack"        ;copyright notice
-    "November 25, 2010"                          ;date created
-    ""                     ;image type that the script works on
-;    SF-ADJUSTMENT  "Ascii code"          '(65 32 125 1 10 0 SF-SPINNER)   ;an ascii code
-    SF-FONT        "Font"          "Sans"    ;a font variable
-    SF-ADJUSTMENT  "Font size"     '(40 1 1000 1 10 0 1)
-    SF-DIRNAME     "Directory"     "D:/project6014/fontgen"
-;    SF-COLOR       "Color"         '(0 0 0)     ;color variable
-  )
-  (script-fu-menu-register "script-fu-save-font" "<Image>/File/Create")
Files src.hd/tools/starmap-4x.psd and src/tools/starmap-4x.psd differ
diff -ruNp src.hd/tools/uqmanimationtool.conf src/tools/uqmanimationtool.conf
--- src.hd/tools/uqmanimationtool.conf	2017-12-29 02:25:51 -0800
+++ src/tools/uqmanimationtool.conf	1969-12-31 16:00:00 -0800
@@ -1,11 +0,0 @@
-<UQMAnimationToolSettings>
-  <lastDirPath>E:\Dropbox\Batman\UQM-HD\content\addons\russian1x\shadow-content\addons\hires4x\ui</lastDirPath>
-  <hideDupe>false</hideDupe>
-  <showOnlySelected>false</showOnlySelected>
-  <hotspotColor>
-    <red>255</red>
-    <green>0</green>
-    <blue>0</blue>
-    <alpha>255</alpha>
-  </hotspotColor>
-</UQMAnimationToolSettings>
\ No newline at end of file
Files src.hd/tools/uqmanimationtool.jar and src/tools/uqmanimationtool.jar differ
diff -ruNp src.hd/types.h src/types.h
--- src.hd/types.h	2017-12-29 02:25:51 -0800
+++ src/types.h	2017-12-29 00:57:43 -0800
@@ -50,6 +50,10 @@
 #	endif  /* defined(PRIxPTR) */
 #endif
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #if defined(__arch64__) || defined(__alpha) || defined(__x86_64) \
 		|| defined(_M_IA64) || defined(_M_AMD64)
 	/* 64-bit platforms */
@@ -177,4 +181,8 @@ UQM_COMPILE_TIME_ASSERT(uint64, sizeof(u
 #define UINT16_MAX 0xffff /* 65535U */
 #define UINT32_MAX 0xffffffff /* 4294967295U */
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _TYPES_H */
diff -ruNp src.hd/uqm/Makeinfo src/uqm/Makeinfo
--- src.hd/uqm/Makeinfo	2017-12-29 02:25:52 -0800
+++ src/uqm/Makeinfo	2017-12-29 00:57:46 -0800
@@ -1,12 +1,24 @@
-uqm_SUBDIRS="comm planets ships supermelee"
+uqm_SUBDIRS="comm lua planets ships supermelee"
 uqm_CFILES="battle.c battlecontrols.c border.c build.c cleanup.c clock.c
 		cnctdlg.c collide.c comm.c commanim.c commglue.c confirm.c credits.c
 		cyborg.c demo.c displist.c dummy.c encount.c flash.c fmv.c galaxy.c
 		gameev.c gameinp.c gameopt.c gendef.c getchar.c globdata.c gravity.c
 		cons_res.c grpinfo.c hyper.c init.c intel.c intro.c ipdisp.c load.c
+		load_legacy.c
 		loadship.c master.c menu.c misc.c oscill.c outfit.c pickship.c
 		plandata.c process.c restart.c save.c settings.c setup.c setupmenu.c
 		ship.c shipstat.c shipyard.c sis.c sounds.c starbase.c starcon.c
 		starmap.c state.c status.c tactrans.c trans.c uqmdebug.c util.c
 		velocity.c weapon.c"
+uqm_HFILES="battlecontrols.h battle.h build.h clock.h cnctdlg.h coderes.h
+		collide.h colors.h commanim.h commglue.h comm.h cons_res.h controls.h
+		corecode.h credits.h demo.h displist.h dummy.h element.h encount.h
+		flash.h fmv.h gameev.h gameopt.h gamestr.h gendef.h globdata.h
+		grpinfo.h hyper.h ifontres.h igfxres.h ikey_con.h imusicre.h init.h
+		intel.h ipdisp.h isndres.h istrtab.h master.h menustat.h
+		nameref.h oscill.h pickship.h process.h races.h resinst.h respkg.h
+		restart.h save.h settings.h setup.h setupmenu.h shipcont.h ship.h
+		sis.h sounds.h starbase.h starcon.h state.h status.h tactrans.h
+		starmap.h
+		units.h uqmdebug.h util.h velocity.h weapon.h"
 
diff -ruNp src.hd/uqm/battle.c src/uqm/battle.c
--- src.hd/uqm/battle.c	2017-12-29 02:25:51 -0800
+++ src/uqm/battle.c	2017-12-29 00:57:43 -0800
@@ -40,6 +40,7 @@
 #include "setup.h"
 #include "settings.h"
 #include "sounds.h"
+#include "libs/async.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/log.h"
 #include "libs/mathlib.h"
@@ -235,12 +236,12 @@ BattleSong (BOOLEAN DoPlay)
 {
 	if (BattleRef == 0)
 	{
-		if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
-			BattleRef = LoadMusic (BATTLE_MUSIC);
-		else if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
+		if (inHyperSpace ())
 			BattleRef = LoadMusic (HYPERSPACE_MUSIC);
-		else
+		else if (inQuasiSpace ())
 			BattleRef = LoadMusic (QUASISPACE_MUSIC);
+		else
+			BattleRef = LoadMusic (BATTLE_MUSIC);
 	}
 
 	if (DoPlay)
@@ -301,7 +302,6 @@ DoBattle (BATTLE_STATE *bs)
 	}
 #endif
 
-	LockMutex (GraphicsLock);
 	if (bs->first_time)
 	{
 		r.corner.x = SIS_ORG_X;
@@ -324,7 +324,6 @@ DoBattle (BATTLE_STATE *bs)
 		ScreenTransition (3, &r);
 	}
 	UnbatchGraphics ();
-	UnlockMutex (GraphicsLock);
 	if ((!(GLOBAL (CurrentActivity) & IN_BATTLE)) ||
 			(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD)))
 	{
@@ -334,6 +333,7 @@ DoBattle (BATTLE_STATE *bs)
 	battle_speed = HIBYTE (nth_frame);
 	if (battle_speed == (BYTE)~0)
 	{	// maximum speed, nothing rendered at all
+		Async_process ();
 		TaskSwitch ();
 	}
 	else
@@ -397,7 +397,6 @@ Battle (BattleFrameCallback *callback)
 {
 	SIZE num_ships;
 
-	LockMutex (GraphicsLock);
 
 #if !(DEMO_MODE || CREATE_JOURNAL)
 	if (LOBYTE (GLOBAL (CurrentActivity)) != SUPER_MELEE) {
@@ -464,12 +463,9 @@ Battle (BattleFrameCallback *callback)
 #endif  /* NETPLAY */
 		bs.InputFunc = DoBattle;
 		bs.frame_cb = callback;
-		bs.first_time = (BOOLEAN)(LOBYTE (GLOBAL (CurrentActivity)) ==
-				IN_HYPERSPACE);
+		bs.first_time = inHQSpace ();
 
-		UnlockMutex (GraphicsLock);
 		DoInput (&bs, FALSE);
-		LockMutex (GraphicsLock);
 
 AbortBattle:
 		if (LOBYTE (GLOBAL (CurrentActivity)) == SUPER_MELEE)
@@ -479,12 +475,10 @@ AbortBattle:
 				// Do not return to the main menu when a game is aborted,
 				// (just to the supermelee menu).
 #ifdef NETPLAY
-				UnlockMutex (GraphicsLock);
 				waitResetConnections(NetState_inSetup);
 						// A connection may already be in inSetup (set from
 						// GetMeleeStarship). This is not a problem, although
 						// it will generate a warning in debug mode.
-				LockMutex (GraphicsLock);
 #endif
 
 				GLOBAL (CurrentActivity) &= ~CHECK_ABORT;
@@ -512,7 +506,6 @@ AbortBattle:
 	UninitShips ();
 	FreeBattleSong ();
 
-	UnlockMutex (GraphicsLock);
 	
 	return (BOOLEAN) (num_ships < 0);
 }
diff -ruNp src.hd/uqm/battle.h src/uqm/battle.h
--- src.hd/uqm/battle.h	2017-12-29 02:25:51 -0800
+++ src/uqm/battle.h	2017-12-29 00:57:43 -0800
@@ -26,9 +26,12 @@ typedef DWORD BattleFrameCounter;
 #include "init.h"
 		// For NUM_SIDES
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 // The callback function is called on every battle frame
-// with GraphicsLock held, just before the display queue
-// is drawn
+// just before the display queue is drawn
 typedef void (BattleFrameCallback) (void);
 
 typedef struct battlestate_struct {
@@ -56,4 +59,8 @@ BOOLEAN Battle (BattleFrameCallback *);
 extern void BattleSong (BOOLEAN DoPlay);
 extern void FreeBattleSong (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _BATTLE_H */
diff -ruNp src.hd/uqm/battlecontrols.h src/uqm/battlecontrols.h
--- src.hd/uqm/battlecontrols.h	2017-12-29 02:25:51 -0800
+++ src/uqm/battlecontrols.h	2017-12-29 00:57:43 -0800
@@ -30,6 +30,10 @@ typedef struct NetworkInputContext Netwo
 #include "races.h"
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef BATTLE_INPUT_STATE (*BattleFrameInputFunction) (
 		InputContext *context, STARSHIP *StarShipPtr);
 typedef BOOLEAN (*SelectShipFunction) (InputContext *context,
@@ -88,6 +92,10 @@ void InputContext_delete (InputContext *
 		// Call InputContext->handlers->freeContext() to release an
 		// InputContext.
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _BATTLECONTROLS_H */
 
 
diff -ruNp src.hd/uqm/border.c src/uqm/border.c
--- src.hd/uqm/border.c	2017-12-29 02:25:51 -0800
+++ src/uqm/border.c	2017-12-29 00:57:43 -0800
@@ -16,7 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
 
 #include "libs/gfxlib.h"
 #include "libs/threadlib.h"
@@ -62,19 +61,19 @@ DrawSISFrame (void)
 		r.extent.width = SIS_ORG_X + SIS_SCREEN_WIDTH + 1;
 		r.extent.height = SIS_ORG_Y - 1;
 		DrawFilledRectangle (&r);
-			//
+			// Inside Left Border
 		r.corner.x = 0;
 		r.corner.y = 0;
 		r.extent.width = SIS_ORG_X - 1;
 		r.extent.height = SIS_ORG_Y + SIS_SCREEN_HEIGHT + 1;
 		DrawFilledRectangle (&r);
-			//
+			// Bottom left of the border
 		r.corner.x = 0;
 		r.corner.y = r.extent.height;
 		r.extent.width = SIS_ORG_X + SIS_SCREEN_WIDTH + 1;
 		r.extent.height = SCREEN_HEIGHT - SIS_ORG_Y + SIS_SCREEN_HEIGHT;
 		DrawFilledRectangle (&r);
-			//
+			// Top right inside border
 		r.corner.x = SIS_ORG_X + SIS_SCREEN_WIDTH + 1;
 		r.corner.y = 0;
 		r.extent.width = SCREEN_WIDTH - r.corner.x;
@@ -113,12 +112,13 @@ DrawSISFrame (void)
 		SetContextForeGroundColor (BLACK_COLOR);
 		r.corner.x = SAFE_X + SPACE_WIDTH - 1;
 		r.corner.y = 0;
-		r.extent.width = 1; // JMS_GFX
+		r.extent.width = 1;
 		r.extent.height = SCREEN_HEIGHT;
 		DrawFilledRectangle (&r);
 		
+		// Bottom corners of the SIS gauges
 		r.corner.x = SAFE_X + SPACE_WIDTH;
-		r.corner.y = SAFE_Y + RES_STAT_SCALE(139); // JMS_GFX
+		r.corner.y = SAFE_Y + RES_CASE(139, 282, 434); // JMS_GFX
 		DrawPoint (&r.corner);
 		
 		r.corner.x = SCREEN_WIDTH - 1; // JMS_GFX
@@ -155,7 +155,7 @@ DrawSISFrame (void)
 		r.corner.x = SCREEN_WIDTH - 1;
 		r.corner.y = 0;
 		r.extent.width = 1;
-		r.extent.height = SAFE_Y + RES_STAT_SCALE(139); // JMS_GFX
+		r.extent.height = SAFE_Y + RES_CASE(139, 282, 434); // JMS_GFX
 		DrawFilledRectangle (&r);
 		
 		// Horizontal line at the bottom of the screen, menu window side
@@ -167,7 +167,7 @@ DrawSISFrame (void)
 		
 		// Vertical line at the right side of the menu window, lower part
 		r.corner.x = SCREEN_WIDTH - 1;
-		r.corner.y = SAFE_Y + RES_STAT_SCALE(139) + RES_CASE(1,0,0);
+		r.corner.y = SAFE_Y + RES_CASE(140, 283, 435);
 		r.extent.width = 1;
 		r.extent.height = (SCREEN_HEIGHT - 1) - r.corner.y;
 		DrawFilledRectangle (&r);
@@ -176,11 +176,12 @@ DrawSISFrame (void)
 		SetContextForeGroundColor (
 				BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
 		// Vertical line on the right side of the big blue box
-		r.corner.y = 0; // JMS_GFX
+		r.corner.y = 1; // There was a reason this was supposed to be "1": Serosis
 		r.extent.width = 1;
 		r.extent.height = SAFE_Y + SIS_MESSAGE_HEIGHT;
 		r.corner.x = SIS_ORG_X + SIS_MESSAGE_BOX_WIDTH;
 		DrawFilledRectangle (&r);
+
 		// Vertical line on the right side of the small blue box
 		r.corner.x = SIS_ORG_X + SIS_SCREEN_WIDTH;
 		++r.extent.height;
@@ -194,6 +195,7 @@ DrawSISFrame (void)
 		r.corner.x = 0;
 		r.extent.width = SIS_ORG_X - r.corner.x;
 		DrawFilledRectangle (&r);
+
 		// Horizontal line between boxes
 		r.corner.x = SIS_ORG_X + SIS_MESSAGE_BOX_WIDTH;
 		r.extent.width = SIS_SPACER_BOX_WIDTH;
@@ -204,21 +206,24 @@ DrawSISFrame (void)
 		r.extent.width = 1;
 		r.extent.height = (SCREEN_HEIGHT - 1) - r.corner.y;
 		DrawFilledRectangle (&r);
-		//
+
+		// Dark verticle line accent for the top left of the right panel
 		r.corner.x = SAFE_X + SPACE_WIDTH;
 		r.corner.y = 0;
 		r.extent.width = 1;
-		r.extent.height = SAFE_Y + RES_STAT_SCALE(139); // JMS_GFX 
+		r.extent.height = SAFE_Y + RES_CASE(139, 282, 434); // JMS_GFX 
 		DrawFilledRectangle (&r);
-		//
+
+		// Horizontal line of the separator below the SIS gauges 
 		r.corner.x = SAFE_X + SPACE_WIDTH + 1;
-		r.corner.y = SAFE_Y + RES_STAT_SCALE(139); // JMS_GFX
+		r.corner.y = SAFE_Y + RES_CASE(139, 282, 434); // JMS_GFX
 		r.extent.width = STATUS_WIDTH - 2;
 		r.extent.height = 1;
 		DrawFilledRectangle (&r);
-		//
+
+		// Dark verticle line accent for the bottom left of the right panel
 		r.corner.x = SAFE_X + SPACE_WIDTH;
-		r.corner.y = SAFE_Y + RES_STAT_SCALE(140); // JMS_GFX
+		r.corner.y = SAFE_Y + RES_CASE(140, 283, 435); // JMS_GFX
 		r.extent.width = 1;
 		r.extent.height = SCREEN_HEIGHT - r.corner.y;
 		DrawFilledRectangle (&r);
diff -ruNp src.hd/uqm/build.c src/uqm/build.c
--- src.hd/uqm/build.c	2017-12-29 02:25:51 -0800
+++ src/uqm/build.c	2017-12-29 00:57:43 -0800
@@ -17,13 +17,15 @@
  */
 
 #include "build.h"
-
+#include "options.h"
 #include "races.h"
 #include "master.h"
 #include "sis.h"
 #include "setup.h"
 #include "libs/compiler.h"
 #include "libs/mathlib.h"
+#include "planets/planets.h"
+#include <stdlib.h>
 
 
 // Allocate a new STARSHIP or SHIP_FRAGMENT and put it in the queue
@@ -68,254 +70,499 @@ GetStarShipFromIndex (QUEUE *pShipQ, COU
 	return (hStarShip);
 }
 
+HSHIPFRAG
+GetEscortByStarShipIndex (COUNT index)
+{
+	HSHIPFRAG hStarShip;
+	HSHIPFRAG hNextShip;
+	SHIP_FRAGMENT *StarShipPtr;
+
+	for (hStarShip = GetHeadLink (&GLOBAL (built_ship_q));
+			hStarShip; hStarShip = hNextShip)
+	{
+		StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+
+		if (StarShipPtr->index == index)
+		{
+			UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+			break;
+		}
+
+		hNextShip = _GetSuccLink (StarShipPtr);
+		UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+	}
+
+	return hStarShip;
+}
+
+SPECIES_ID
+ShipIdStrToIndex (const char *shipIdStr)
+{
+	HMASTERSHIP hStarShip;
+	HMASTERSHIP hNextShip;
+	SPECIES_ID result = NO_ID;
+
+	for (hStarShip = GetHeadLink (&master_q);
+			hStarShip != 0; hStarShip = hNextShip)
+	{
+		MASTER_SHIP_INFO *MasterPtr;
+
+		MasterPtr = LockMasterShip (&master_q, hStarShip);
+		hNextShip = _GetSuccLink (MasterPtr);
+
+		if (strcmp (shipIdStr, MasterPtr->ShipInfo.idStr) == 0)
+		{
+			result = MasterPtr->SpeciesID;
+			UnlockMasterShip (&master_q, hStarShip);
+			break;
+		}
+
+		UnlockMasterShip (&master_q, hStarShip);
+	}
+
+	return result;
+}
+
+typedef struct {
+	const char *idStr;
+	RACE_ID id;
+} RaceIdMap;
+
+// We would eventually want to unhardcode this.
+static RaceIdMap raceIdMap[] = {
+	// Sorted on the name, for the binary search.
+	{ /* .idStr = */ "arilou",      /* .id = */ ARILOU_SHIP },
+	{ /* .idStr = */ "chmmr",       /* .id = */ CHMMR_SHIP },
+	{ /* .idStr = */ "druuge",      /* .id = */ DRUUGE_SHIP },
+	{ /* .idStr = */ "human",       /* .id = */ HUMAN_SHIP },
+	{ /* .idStr = */ "ilwrath",     /* .id = */ ILWRATH_SHIP },
+	{ /* .idStr = */ "kohrah",      /* .id = */ BLACK_URQUAN_SHIP },
+	{ /* .idStr = */ "melnorme",    /* .id = */ MELNORME_SHIP },
+	{ /* .idStr = */ "mycon",       /* .id = */ MYCON_SHIP },
+	{ /* .idStr = */ "orz",         /* .id = */ ORZ_SHIP },
+	{ /* .idStr = */ "pkunk",       /* .id = */ PKUNK_SHIP },
+	{ /* .idStr = */ "samatra",     /* .id = */ SAMATRA_SHIP },
+	{ /* .idStr = */ "shofixti",    /* .id = */ SHOFIXTI_SHIP },
+	{ /* .idStr = */ "slylandro",   /* .id = */ SLYLANDRO_SHIP },
+	{ /* .idStr = */ "spathi",      /* .id = */ SPATHI_SHIP },
+	{ /* .idStr = */ "supox",       /* .id = */ SUPOX_SHIP },
+	{ /* .idStr = */ "syreen",      /* .id = */ SYREEN_SHIP },
+	{ /* .idStr = */ "thraddash",   /* .id = */ THRADDASH_SHIP },
+	{ /* .idStr = */ "umgah",       /* .id = */ UMGAH_SHIP },
+	{ /* .idStr = */ "urquandrone", /* .id = */ URQUAN_DRONE_SHIP },
+	{ /* .idStr = */ "urquan",      /* .id = */ URQUAN_SHIP },
+	{ /* .idStr = */ "utwig",       /* .id = */ UTWIG_SHIP },
+	{ /* .idStr = */ "vux",         /* .id = */ VUX_SHIP },
+	{ /* .idStr = */ "yehat",       /* .id = */ YEHAT_SHIP },
+	{ /* .idStr = */ "yehatrebel",  /* .id = */ YEHAT_REBEL_SHIP },
+	{ /* .idStr = */ "zoqfotpik",   /* .id = */ ZOQFOTPIK_SHIP },
+			// Same as URQUAN_DRONE_SHIP
+};
+
+static int
+RaceIdCompare (const void *id1, const void *id2)
+{
+	return strcmp (((RaceIdMap *) id1)->idStr, ((RaceIdMap *) id2)->idStr);
+}
+
+RACE_ID
+RaceIdStrToIndex (const char *raceIdStr)
+{
+	RaceIdMap key = { /* .idStr = */ raceIdStr, /* .id = */ -1 };
+	RaceIdMap *found = bsearch (&key, raceIdMap,
+			sizeof raceIdMap / sizeof raceIdMap[0],
+			sizeof raceIdMap[0], RaceIdCompare);
+
+	if (found == NULL)
+		return (RACE_ID) -1;
+
+	return found->id;
+}
+
 /*
- * What this function does depends on the value of the 'state' argument:
- * SPHERE_TRACKING:
- * 	The sphere of influence for the race for 'which_ship' will be shown
- * 	on the starmap in the future.
- * 	The value returned is 'which_ship', unless the type of ship is only
- * 	available in SuperMelee, in which case 0 is returned.
- * SPHERE_KNOWN:
- * 	The size of the fleet of the race of 'which_ship' when the starmap was
- * 	last checked is returned.
- * ESCORT_WORTH:
- * 	The total value of all the ships escorting the SIS is returned.
- * 	'which_ship' is ignored.
- * ESCORTING_FLAGSHIP:
- * 	Test if a ship of type 'which_ship' is among the escorts of the SIS
- * 	0 is returned if false, 1 if true.
- * FEASIBILITY_STUDY:
- * 	Test if the SIS can have an escort of type 'which_ship'.
- * 	0 is returned if 'which_ship' is not available.
- * 	Otherwise, the number of ships that can be added is returned.
- * CHECK_ALLIANCE:
- * 	Test the alliance status of the race of 'which_ship'.
- *      Either GOOD_GUY (allied) or BAD_GUY (not allied) is returned.
- * SET_ALLIED (0):
- * 	Ally with the race of 'which_ship'. This makes their ship available
- *  for building in the shipyard.
- * SET_NOT_ALLIED:
- * 	End an alliance with the race of 'which_ship'. This ends the possibility
- * 	of building their ships in the shipyard.
- * REMOVE_BUILT: 
- *  Make the already built escorts of the race of 'which_ship' disappear.
- *   (as for the Orz when the alliance with them ends)
- * any other positive number:
- * 	Give the player this many ships of type 'which_ship'.
+ * Give the player 'count' ships of the specified race,
+ * limited by the number of free slots.
+ * Returns the number of ships added.
  */
 COUNT
-ActivateStarShip (COUNT which_ship, SIZE state)
+AddEscortShips (RACE_ID race, SIZE count)
 {
 	HFLEETINFO hFleet;
+	BYTE which_window;
+	COUNT i;
 
-	hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q), which_ship);
+	hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q), race);
 	if (!hFleet)
 		return 0;
 
-	switch (state)
+	assert (count > 0);
+
+	which_window = 0;
+	for (i = 0; i < (COUNT) count; i++)
 	{
-		case SPHERE_TRACKING:
-		case SPHERE_KNOWN:
-		{
-			FLEET_INFO *FleetPtr;
+		HSHIPFRAG hStarShip;
+		HSHIPFRAG hOldShip;
+		SHIP_FRAGMENT *StarShipPtr;
 
-			FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hFleet);
-			if (state == SPHERE_KNOWN)
-				which_ship = FleetPtr->known_strength;
-			else if (FleetPtr->actual_strength == 0)
-			{
-				if (FleetPtr->allied_state == DEAD_GUY)
-					which_ship = 0;
-			}
-			else if (FleetPtr->known_strength == 0
-					&& FleetPtr->actual_strength != INFINITE_RADIUS)
-			{
-				FleetPtr->known_strength = 1;
-				FleetPtr->known_loc = FleetPtr->loc;
-			}
-			UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
-			return (which_ship);
-		}
-		case ESCORT_WORTH:
-		{
-			COUNT ShipCost[] =
-			{
-				RACE_SHIP_COST
-			};
-			COUNT total = 0;
-			HSHIPFRAG hStarShip, hNextShip;
-
-			for (hStarShip = GetHeadLink (&GLOBAL (built_ship_q));
-					hStarShip; hStarShip = hNextShip)
-			{
-				SHIP_FRAGMENT *StarShipPtr;
-
-				StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
-				hNextShip = _GetSuccLink (StarShipPtr);
-				total += ShipCost[StarShipPtr->race_id];
-				UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
-			}
-			return total;
-		}
-		case ESCORTING_FLAGSHIP:
-		{
-			HSHIPFRAG hStarShip, hNextShip;
+		hStarShip = CloneShipFragment (race, &GLOBAL (built_ship_q), 0);
+		if (!hStarShip)
+			break;
 
-			for (hStarShip = GetHeadLink (&GLOBAL (built_ship_q));
-					hStarShip; hStarShip = hNextShip)
-			{
-				BYTE ship_type;
-				SHIP_FRAGMENT *StarShipPtr;
-
-				StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
-				hNextShip = _GetSuccLink (StarShipPtr);
-				ship_type = StarShipPtr->race_id;
-				UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
-
-				if (ship_type == which_ship)
-					return 1;
-			}
-			return 0;
-		}
-		case FEASIBILITY_STUDY:
+		RemoveQueue (&GLOBAL (built_ship_q), hStarShip);
+
+		/* Find first available escort window */
+		while ((hOldShip = GetStarShipFromIndex (
+				&GLOBAL (built_ship_q), which_window++)))
 		{
-			return (MAX_BUILT_SHIPS - CountLinks (&GLOBAL (built_ship_q)));
+			BYTE win_loc;
+
+			StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hOldShip);
+			win_loc = StarShipPtr->index;
+			UnlockShipFrag (&GLOBAL (built_ship_q), hOldShip);
+			if (which_window <= win_loc)
+				break;
 		}
-		case CHECK_ALLIANCE:
+
+		StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+		StarShipPtr->index = which_window - 1;
+		UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+
+		InsertQueue (&GLOBAL (built_ship_q), hStarShip, hOldShip);
+	}
+
+	DeltaSISGauges (UNDEFINED_DELTA, UNDEFINED_DELTA, UNDEFINED_DELTA);
+	return i;
+}
+
+/*
+ * Returns the total value of all the ships escorting the SIS.
+ */
+COUNT
+CalculateEscortsWorth (void)
+{
+	COUNT ShipCost[] =
+	{
+		RACE_SHIP_COST
+	};
+	COUNT total = 0;
+	HSHIPFRAG hStarShip, hNextShip;
+
+	for (hStarShip = GetHeadLink (&GLOBAL (built_ship_q));
+			hStarShip; hStarShip = hNextShip)
+	{
+		SHIP_FRAGMENT *StarShipPtr;
+
+		StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+		hNextShip = _GetSuccLink (StarShipPtr);
+		total += ShipCost[StarShipPtr->race_id];
+		UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+	}
+	return total;
+}
+
+#if 0
+/*
+ * Returns the size of the fleet of the specified race when the starmap was
+ * last checked. If the race has no SoI, 0 is returned.
+ */
+COUNT
+GetRaceKnownSize (RACE_ID race)
+{
+	HFLEETINFO hFleet;
+	FLEET_INFO *FleetPtr;
+	COUNT result;
+
+	hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q), race);
+	if (!hFleet)
+		return 0;
+
+	FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+
+	result = FleetPtr->known_strength;
+
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+	return result;
+}
+#endif
+
+/*
+ * Start or end an alliance with the specified race.
+ * Being in an alliance with a race makes their ships available for building
+ * in the shipyard.
+ * flag == TRUE: start an alliance
+ * flag == TRUE: end an alliance
+ */
+BOOLEAN
+SetRaceAllied (RACE_ID race, BOOLEAN flag) {
+	HFLEETINFO hFleet;
+	FLEET_INFO *FleetPtr;
+
+	hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q), race);
+	if (!hFleet)
+		return FALSE;
+
+	FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+
+	if (FleetPtr->allied_state == DEAD_GUY)
+	{
+		/* Strange request, silently ignore it */
+	}
+	else
+	{
+		FleetPtr->allied_state = (flag ? GOOD_GUY : BAD_GUY);
+	}
+
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+	return TRUE;
+}
+
+/*
+ * Allows the building of ships regardless of alliance state
+ * flag == TRUE: Allow to build ship
+ * flag == FALSE: Normal, not allowed to build ships if not allied.
+ */
+BOOLEAN
+SetRaceAllowBuild (RACE_ID race) {
+	HFLEETINFO hFleet;
+	FLEET_INFO *FleetPtr;
+
+	hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q), race);
+	if (!hFleet)
+		return FALSE;
+
+	FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+
+	if (FleetPtr->allied_state != GOOD_GUY) {
+		FleetPtr->allied_state = CAN_BUILD;
+	}
+
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+	return TRUE;
+}
+
+/*
+ * 	Make the sphere of influence for the specified race shown on the starmap
+ * 	in the future.
+ * 	Does nothing for races without a SoI, or for races which have an
+ * 	infinite SoI.
+ * 	The value returned is 'race', unless the type of ship is only available
+ * 	in SuperMelee, in which case 0 is returned.
+ */
+COUNT
+StartSphereTracking (RACE_ID race)
+{
+	HFLEETINFO hFleet;
+	FLEET_INFO *FleetPtr;
+
+	hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q), race);
+	if (!hFleet)
+		return 0;
+
+	FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+
+	if (FleetPtr->actual_strength == 0)
+	{
+		// Race has no Sphere of Influence.
+		if (FleetPtr->allied_state == DEAD_GUY)
 		{
-			UWORD flags;
-			FLEET_INFO *FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q),
-					hFleet);
-			flags = FleetPtr->allied_state;
+			// Race is extinct.
 			UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
-			return flags;
+			return 0;
 		}
-		case SET_ALLIED:
-		case SET_NOT_ALLIED:
-		{
-			FLEET_INFO *FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q),
-					hFleet);
+	}
+	else if (FleetPtr->known_strength == 0
+			&& FleetPtr->actual_strength != INFINITE_RADIUS)
+	{
+		FleetPtr->known_strength = 1;
+		FleetPtr->known_loc = FleetPtr->loc;
+	}
 
-			if (FleetPtr->allied_state == DEAD_GUY)
-			{	/* Strange request, silently ignore it */
-				UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
-				break;
-			}
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+	return race;
+}
 
-			if (state == SET_ALLIED)
-				FleetPtr->allied_state = GOOD_GUY;
-			else
-				FleetPtr->allied_state = BAD_GUY;
-			
-			UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
-			break;
-		}
-		case ALLOW_BUILD:
-		{
-			FLEET_INFO *FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q),
-					hFleet);
+/*
+ * 	Check whether we are tracking the SoI of a race.
+ * 	If a race has no SoI, this function will always return false.
+ */
+BOOLEAN
+CheckSphereTracking (RACE_ID race)
+{
+	HFLEETINFO hFleet;
+	FLEET_INFO *FleetPtr;
+	COUNT result;
 
-			if (FleetPtr->allied_state == GOOD_GUY) {	
-				/* Strange request, silently ignore it */
-				UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
-				break;
-			}
+	hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q), race);
+	if (!hFleet)
+		return FALSE;
 
-			if (state == ALLOW_BUILD){
-				FleetPtr->allied_state = CAN_BUILD;
-			} else {	/* Strange request, silently ignore it */
-				UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
-				break;
-			}
-			
-			UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
-			break;
-		}
-		case REMOVE_BUILT:
-		{
-			HSHIPFRAG hStarShip, hNextShip;
-			BOOLEAN ShipRemoved = FALSE;
+	FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hFleet);
 
-			for (hStarShip = GetHeadLink (&GLOBAL (built_ship_q));
-					hStarShip; hStarShip = hNextShip)
-			{
-				BOOLEAN RemoveShip;
-				SHIP_FRAGMENT *StarShipPtr;
-
-				StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
-				hNextShip = _GetSuccLink (StarShipPtr);
-				RemoveShip = (StarShipPtr->race_id == which_ship);
-				UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
-
-				if (RemoveShip)
-				{
-					ShipRemoved = TRUE;
-
-					RemoveQueue (&GLOBAL (built_ship_q), hStarShip);
-					FreeShipFrag (&GLOBAL (built_ship_q), hStarShip);
-				}
-			}
-			
-			if (ShipRemoved)
-			{
-				LockMutex (GraphicsLock);
-				DeltaSISGauges (UNDEFINED_DELTA, UNDEFINED_DELTA,
-						UNDEFINED_DELTA);
-				UnlockMutex (GraphicsLock);
-			}
-			break;
-		}
-		default:
-		{
-			BYTE which_window;
-			COUNT i;
+	if (FleetPtr->actual_strength == 0) {
+		// Race has no Sphere of Influence.
+		// Maybe it never had one, or maybe the race is extinct.
+		result = FALSE;
+	}
+	else
+	{
+		result = (FleetPtr->known_strength > 0);
+	}
+
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+	return result;
+}
+
+BOOLEAN
+KillRace (RACE_ID race)
+{
+	HFLEETINFO hFleet;
+	FLEET_INFO *FleetPtr;
+
+	hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q), race);
+	if (!hFleet)
+		return FALSE;
+
+	FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+
+	FleetPtr->allied_state = DEAD_GUY;
+	FleetPtr->actual_strength = 0;
+
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+	return TRUE;
+}
+
+/*
+ * Returns the number of ships of the specified race among the
+ * escort ships.
+ */
+COUNT
+CountEscortShips (RACE_ID race)
+{
+	HFLEETINFO hFleet;
+	HSHIPFRAG hStarShip, hNextShip;
+	COUNT result = 0;
+
+	hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q), race);
+	if (!hFleet)
+		return 0;
+
+	for (hStarShip = GetHeadLink (&GLOBAL (built_ship_q)); hStarShip;
+			hStarShip = hNextShip)
+	{
+		BYTE ship_type;
+		SHIP_FRAGMENT *StarShipPtr;
+
+		StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+		hNextShip = _GetSuccLink (StarShipPtr);
+		ship_type = StarShipPtr->race_id;
+		UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 
-			assert (state > 0);
-			/* Add ships to the escorts */
-			which_window = 0;
-			for (i = 0; i < (COUNT)state; i++)
-			{
-				HSHIPFRAG hStarShip;
-				HSHIPFRAG hOldShip;
-				SHIP_FRAGMENT *StarShipPtr;
-
-				hStarShip = CloneShipFragment (which_ship,
-						&GLOBAL (built_ship_q), 0);
-				if (!hStarShip)
-					break;
-
-				RemoveQueue (&GLOBAL (built_ship_q), hStarShip);
-
-				/* Find first available escort window */
-				while ((hOldShip = GetStarShipFromIndex (
-						&GLOBAL (built_ship_q), which_window++)))
-				{
-					BYTE win_loc;
-
-					StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q),
-							hOldShip);
-					win_loc = StarShipPtr->index;
-					UnlockShipFrag (&GLOBAL (built_ship_q), hOldShip);
-					if (which_window <= win_loc)
-						break;
-				}
-
-				StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
-				StarShipPtr->index = which_window - 1;
-				UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
-
-				InsertQueue (&GLOBAL (built_ship_q), hStarShip, hOldShip);
-			}
-
-			LockMutex (GraphicsLock);
-			DeltaSISGauges (UNDEFINED_DELTA,
-					UNDEFINED_DELTA, UNDEFINED_DELTA);
-			UnlockMutex (GraphicsLock);
-			return i;
+		if (ship_type == race)
+			result++;
+	}
+	return result;
+}
+
+/*
+ * Returns true if and only if a ship of the specified race is among the
+ * escort ships.
+ */
+BOOLEAN
+HaveEscortShip (RACE_ID race)
+{
+	return (CountEscortShips (race) > 0);
+}
+
+/*
+ * Test if the SIS can have an escort of the specified race.
+ * Returns 0 if 'race' is not available.
+ * Otherwise, returns the number of ships that can be added.
+ */
+COUNT
+EscortFeasibilityStudy (RACE_ID race)
+{
+	HFLEETINFO hFleet;
+
+	hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q), race);
+	if (!hFleet)
+		return 0;
+
+	return (MAX_BUILT_SHIPS - CountLinks (&GLOBAL (built_ship_q)));
+}
+
+/*
+ * Test the alliance status of the specified race.
+ * Either DEAD_GUY (extinct), GOOD_GUY (allied), or BAD_GUY (not allied) is
+ * returned.
+ */
+COUNT
+CheckAlliance (RACE_ID race)
+{
+	HFLEETINFO hFleet;
+	UWORD flags;
+	FLEET_INFO *FleetPtr;
+
+	hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q), race);
+	if (!hFleet)
+		return 0;
+
+	FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+	flags = FleetPtr->allied_state;
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+
+	return flags;
+}
+
+/*
+ * Remove a number of escort ships of the specified race (if present).
+ * Returns the number of escort ships removed.
+ */
+COUNT
+RemoveSomeEscortShips (RACE_ID race, COUNT count)
+{
+	HSHIPFRAG hStarShip;
+	HSHIPFRAG hNextShip;
+
+	if (count == 0)
+		return 0;
+
+	for (hStarShip = GetHeadLink (&GLOBAL (built_ship_q)); hStarShip;
+			hStarShip = hNextShip)
+	{
+		BOOLEAN RemoveShip;
+		SHIP_FRAGMENT *StarShipPtr;
+
+		StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+		hNextShip = _GetSuccLink (StarShipPtr);
+		RemoveShip = (StarShipPtr->race_id == race);
+		UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+
+		if (RemoveShip)
+		{
+			RemoveQueue (&GLOBAL (built_ship_q), hStarShip);
+			FreeShipFrag (&GLOBAL (built_ship_q), hStarShip);
+			count--;
+			if (count == 0)
+				break;
 		}
 	}
+	
+	if (count > 0)
+	{
+		// Update the display.
+		DeltaSISGauges (UNDEFINED_DELTA, UNDEFINED_DELTA, UNDEFINED_DELTA);
+	}
+
+	return count;
+}
 
-	return 1;
+/*
+ * Remove all escort ships of the specified race.
+ */
+COUNT
+RemoveEscortShips (RACE_ID race)
+{
+	return RemoveSomeEscortShips (race, (COUNT) -1);
 }
 
 COUNT
@@ -377,7 +624,7 @@ NameCaptain (QUEUE *pQueue, SPECIES_ID S
 // crew_level can be set to INFINITE_FLEET for a ship which is to
 // represent an infinite number of ships.
 HSHIPFRAG
-CloneShipFragment (COUNT shipIndex, QUEUE *pDstQueue, COUNT crew_level)
+CloneShipFragment (RACE_ID shipIndex, QUEUE *pDstQueue, COUNT crew_level)
 {
 	HFLEETINFO hFleet;
 	HSHIPFRAG hBuiltShip;
@@ -425,7 +672,7 @@ CloneShipFragment (COUNT shipIndex, QUEU
 /* Set the crew and captain's name on the first fully-crewed escort
  * ship of race 'which_ship' */
 int
-SetEscortCrewComplement (COUNT which_ship, COUNT crew_level, BYTE captain)
+SetEscortCrewComplement (RACE_ID which_ship, COUNT crew_level, BYTE captain)
 {
 	HFLEETINFO hFleet;
 	FLEET_INFO *TemplatePtr;
@@ -461,3 +708,78 @@ SetEscortCrewComplement (COUNT which_shi
 	UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
 	return Index;
 }
+
+void
+loadGameCheats (void){
+	if(optInfiniteRU){
+		oldRU = GlobData.SIS_state.ResUnits;
+	} else {
+		oldRU = 0;
+	}
+	if(optInfiniteFuel){
+		loadFuel = GlobData.SIS_state.FuelOnBoard;
+		GLOBAL_SIS (FuelOnBoard) = GetFuelTankCapacity();
+	} else {
+		loadFuel = 0;
+	}
+	if (optUnlockShips){
+		SetRaceAllowBuild (ARILOU_SHIP);
+		SetRaceAllowBuild (CHMMR_SHIP);
+		SetRaceAllowBuild (ORZ_SHIP);
+		SetRaceAllowBuild (PKUNK_SHIP);
+		SetRaceAllowBuild (SHOFIXTI_SHIP);
+		SetRaceAllowBuild (SPATHI_SHIP);
+		SetRaceAllowBuild (SUPOX_SHIP);
+		SetRaceAllowBuild (THRADDASH_SHIP);
+		SetRaceAllowBuild (UTWIG_SHIP);
+		SetRaceAllowBuild (VUX_SHIP);
+		SetRaceAllowBuild (YEHAT_SHIP);
+		SetRaceAllowBuild (MELNORME_SHIP);
+		SetRaceAllowBuild (DRUUGE_SHIP);
+		SetRaceAllowBuild (ILWRATH_SHIP);
+		SetRaceAllowBuild (MYCON_SHIP);
+		SetRaceAllowBuild (SLYLANDRO_SHIP);
+		SetRaceAllowBuild (UMGAH_SHIP);
+		SetRaceAllowBuild (URQUAN_SHIP);
+		SetRaceAllowBuild (ZOQFOTPIK_SHIP);
+		SetRaceAllowBuild (SYREEN_SHIP);
+		SetRaceAllowBuild (BLACK_URQUAN_SHIP);
+	}
+	if (optUnlockUpgrades){
+		SET_GAME_STATE (IMPROVED_LANDER_SPEED, 1);
+		SET_GAME_STATE (IMPROVED_LANDER_CARGO, 1);
+		SET_GAME_STATE (IMPROVED_LANDER_SHOT, 1);
+		SET_GAME_STATE (LANDER_SHIELDS, (1 << EARTHQUAKE_DISASTER) | (1 << BIOLOGICAL_DISASTER) |
+			(1 << LIGHTNING_DISASTER) | (1 << LAVASPOT_DISASTER));				
+		GLOBAL (ModuleCost[ANTIMISSILE_DEFENSE]) = 4000 / MODULE_COST_SCALE;				
+		GLOBAL (ModuleCost[BLASTER_WEAPON]) = 4000 / MODULE_COST_SCALE;
+		GLOBAL (ModuleCost[HIGHEFF_FUELSYS]) = 1000 / MODULE_COST_SCALE;
+		GLOBAL (ModuleCost[TRACKING_SYSTEM]) = 5000 / MODULE_COST_SCALE;
+		GLOBAL (ModuleCost[CANNON_WEAPON]) = 6000 / MODULE_COST_SCALE;
+		GLOBAL (ModuleCost[SHIVA_FURNACE]) = 4000 / MODULE_COST_SCALE;
+		SET_GAME_STATE (MELNORME_TECH_STACK, 13);
+	}
+	if(optAddDevices){		
+		SET_GAME_STATE (ROSY_SPHERE_ON_SHIP, 1);
+		SET_GAME_STATE (WIMBLIS_TRIDENT_ON_SHIP, 1);
+		SET_GAME_STATE (GLOWING_ROD_ON_SHIP, 1);
+		SET_GAME_STATE (SUN_DEVICE_ON_SHIP, 1);
+		SET_GAME_STATE (UTWIG_BOMB_ON_SHIP, 1);
+		SET_GAME_STATE (ULTRON_CONDITION, 1);
+		SET_GAME_STATE (MAIDENS_ON_SHIP, 1);
+		SET_GAME_STATE (TALKING_PET_ON_SHIP, 1);
+		SET_GAME_STATE (AQUA_HELIX_ON_SHIP, 1);
+		SET_GAME_STATE (CLEAR_SPINDLE_ON_SHIP, 1);
+		SET_GAME_STATE (UMGAH_BROADCASTERS_ON_SHIP, 1);
+		SET_GAME_STATE (TAALO_PROTECTOR_ON_SHIP, 1);
+		SET_GAME_STATE (EGG_CASE0_ON_SHIP, 1);
+		SET_GAME_STATE (EGG_CASE1_ON_SHIP, 1);
+		SET_GAME_STATE (EGG_CASE2_ON_SHIP, 1);
+		SET_GAME_STATE (SYREEN_SHUTTLE_ON_SHIP, 1);
+		SET_GAME_STATE (VUX_BEAST_ON_SHIP, 1);
+		SET_GAME_STATE (PORTAL_SPAWNER_ON_SHIP, 1);
+		SET_GAME_STATE (BURV_BROADCASTERS_ON_SHIP, 1);
+		SET_GAME_STATE (DESTRUCT_CODE_ON_SHIP, 1);
+	}
+}
+
diff -ruNp src.hd/uqm/build.h src/uqm/build.h
--- src.hd/uqm/build.h	2017-12-29 02:25:51 -0800
+++ src/uqm/build.h	2017-12-29 00:57:43 -0800
@@ -23,6 +23,10 @@
 #include "displist.h"
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #define NAME_OFFSET 5
 #define NUM_CAPTAINS_NAMES 16
 
@@ -31,35 +35,40 @@
 								+ NAME_OFFSET)
 
 extern HLINK Build (QUEUE *pQueue, SPECIES_ID SpeciesID);
-extern HSHIPFRAG CloneShipFragment (COUNT shipIndex, QUEUE *pDstQueue,
+extern HSHIPFRAG CloneShipFragment (RACE_ID shipIndex, QUEUE *pDstQueue,
 		COUNT crew_level);
 extern HLINK GetStarShipFromIndex (QUEUE *pShipQ, COUNT Index);
+extern HSHIPFRAG GetEscortByStarShipIndex (COUNT index);
 extern BYTE NameCaptain (QUEUE *pQueue, SPECIES_ID SpeciesID);
 
-/* Possible values for the 'state' argument of
- * COUNT ActivateStarShip (COUNT which_ship, SIZE state)
- * See that function for more information.
- */
-#define SET_ALLIED          0
-#define SET_NOT_ALLIED     -1
-#define CHECK_ALLIANCE     -2
-#define REMOVE_BUILT       -3
-#define ESCORT_WORTH       -4
-#define SPHERE_KNOWN       -5
-#define SPHERE_TRACKING    -6
-#define ESCORTING_FLAGSHIP -7
-#define FEASIBILITY_STUDY  -8
-#define ALLOW_BUILD		   -9
-		/* Check for how many escort ships there's still space */
-
-extern COUNT ActivateStarShip (COUNT which_ship, SIZE state);
 extern COUNT GetIndexFromStarShip (QUEUE *pShipQ, HLINK hStarShip);
-extern int SetEscortCrewComplement (COUNT which_ship, COUNT crew_level,
+extern int SetEscortCrewComplement (RACE_ID which_ship, COUNT crew_level,
 		BYTE captain);
 
+extern SPECIES_ID ShipIdStrToIndex (const char *shipIdStr);
+extern RACE_ID RaceIdStrToIndex (const char *raceIdStr);
+extern COUNT AddEscortShips (RACE_ID race, SIZE count);
+extern COUNT CalculateEscortsWorth (void);
+extern BOOLEAN SetRaceAllowBuild (RACE_ID race);
+extern BOOLEAN SetRaceAllied (RACE_ID race, BOOLEAN flag);
+extern COUNT StartSphereTracking (RACE_ID race);
+extern BOOLEAN CheckSphereTracking (RACE_ID race);
+extern BOOLEAN KillRace (RACE_ID race);
+extern COUNT CountEscortShips (RACE_ID race);
+extern BOOLEAN HaveEscortShip (RACE_ID race);
+extern COUNT EscortFeasibilityStudy (RACE_ID race);
+extern COUNT CheckAlliance (RACE_ID race);
+extern COUNT RemoveSomeEscortShips (RACE_ID race, COUNT count);
+extern COUNT RemoveEscortShips (RACE_ID race);
+
 extern RACE_DESC *load_ship (SPECIES_ID SpeciesID, BOOLEAN LoadBattleData);
 extern void free_ship (RACE_DESC *RaceDescPtr, BOOLEAN FreeIconData,
 		BOOLEAN FreeBattleData);
+extern void loadGameCheats (void);
+
+#if defined(__cplusplus)
+}
+#endif
 
 #endif /* _BUILD_H */
 
diff -ruNp src.hd/uqm/cleanup.c src/uqm/cleanup.c
--- src.hd/uqm/cleanup.c	2017-12-29 02:25:51 -0800
+++ src/uqm/cleanup.c	2017-12-29 00:57:43 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "nameref.h"
 #include "libs/reslib.h"
 #include "gamestr.h"
@@ -27,14 +25,11 @@
 #include "planets/lander.h"
 #include "starcon.h"
 #include "setup.h"
+#include "planets/solarsys.h"
 #include "sounds.h"
 #include "libs/sndlib.h"
 #include "libs/vidlib.h"
 
-// XXX: we do not current have a header for this prototype to live in
-//  should be something like solarsys.h
-extern void FreeIPData (void);
-
 
 void
 FreeKernel (void)
@@ -44,7 +39,9 @@ FreeKernel (void)
 	UninitResourceSystem ();
 
 	DestroyDrawable (ReleaseDrawable (Screen));
+	Screen = 0;
 	DestroyContext (ScreenContext);
+	ScreenContext = 0;
 
 	UninitVideoPlayer ();
 	UninitSound ();
@@ -69,13 +66,14 @@ UninitKernel (void)
 	DestroyFont (MicroFont);
 	DestroyStringTable (ReleaseStringTable (GameStrings));
 	DestroyDrawable (ReleaseDrawable (StatusFrame));
-	DestroyDrawable (ReleaseDrawable (SubmenuStarmapKeysFrame)); // JMS
+	DestroyDrawable (ReleaseDrawable (SubmenuFrame)); // JMS
 	DestroyDrawable (ReleaseDrawable (ConstellationsFrame)); // JMS
 	DestroyDrawable (ReleaseDrawable (NebulaeFrame));	// JMS
 	DestroyDrawable (ReleaseDrawable (hyperspacesuns));	// JMS
 	DestroyDrawable (ReleaseDrawable (ActivityFrame));
 	DestroyFont (TinyFont);
 	DestroyFont (StarConFont);
+	DestroyFont (PlyrFont);
 
 	UninitQueue (&race_q[0]);
 	UninitQueue (&race_q[1]);
diff -ruNp src.hd/uqm/clock.c src/uqm/clock.c
--- src.hd/uqm/clock.c	2017-12-29 02:25:51 -0800
+++ src/uqm/clock.c	2017-12-29 00:57:43 -0800
@@ -93,23 +93,20 @@ daysElapsed (void)
 	COUNT index;
 	
 	// Years
-	for (index = START_YEAR ; index < GLOBAL (GameClock.year_index) ; index++ )
-		{
-			days += 365;
-			if(IsLeapYear(index))
-				days++;
-		}
+	for (index = START_YEAR ; index < GLOBAL (GameClock.year_index) ; index++ ) {
+		days += 365;
+		if(IsLeapYear(index))
+			days++;
+	}
 
-	if (GLOBAL (GameClock.month_index) == 1)
-		{
-			days = days - 31;
-		}
+	if (GLOBAL (GameClock.month_index) == 1) {
+		days = days - 31;
+	}
 	
 	// Months
-	for (index = 2 ; index < GLOBAL (GameClock.month_index) ; index++ )
-		{
-			days += DaysInMonth (index, GLOBAL (GameClock.year_index));
-		}
+	for (index = 2 ; index < GLOBAL (GameClock.month_index) ; index++ ) {
+		days += DaysInMonth (index, GLOBAL (GameClock.year_index));
+	}
 	
 	// Days
 	days = days + GLOBAL (GameClock.day_index) - 17;
@@ -193,22 +190,16 @@ UnlockGameClock (void)
 BOOLEAN
 GameClockRunning (void)
 {
-	SIZE prev_tick, cur_tick;
+	SIZE day_in_ticks;
 
 	if (!clock_mutex)
 		return FALSE;
 
 	LockMutex (clock_mutex);
-	prev_tick = GLOBAL (GameClock.tick_count);
+	day_in_ticks = GLOBAL (GameClock.day_in_ticks);
 	UnlockMutex (clock_mutex);
 	
-	SleepThread (ONE_SECOND / 5);
-	
-	LockMutex (clock_mutex);
-	cur_tick = GLOBAL (GameClock.tick_count);
-	UnlockMutex (clock_mutex);
-
-	return cur_tick != prev_tick;
+	return day_in_ticks != 0;
 }
 
 void
@@ -226,6 +217,7 @@ SetGameClockRate (COUNT seconds_per_day)
 			new_day_in_ticks = new_day_in_ticks / 5;
 			//printf("TD Fast\n");
 			break;
+		case 0:
 		default:
 			//printf("TD Normal\n");
 			break;
@@ -331,7 +323,6 @@ AddEvent (EVENT_TYPE type, COUNT month_i
 	return (0);
 }
 
-// This function must be called with GraphicsLock held.
 void
 GameClockTick (void)
 {
@@ -354,7 +345,6 @@ GameClockTick (void)
 	UnlockMutex (clock_mutex);
 }
 
-// This function must be called with GraphicsLock held.
 void
 MoveGameClockDays (COUNT days)
 {
diff -ruNp src.hd/uqm/clock.h src/uqm/clock.h
--- src.hd/uqm/clock.h	2017-12-29 02:25:51 -0800
+++ src/uqm/clock.h	2017-12-29 00:57:43 -0800
@@ -22,12 +22,12 @@
 #include "libs/tasklib.h"
 #include "displist.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
-#define START_YEAR 2155
 
-#define UPDATE_DAY (1 << 0)
-#define UPDATE_MONTH (1 << 1)
-#define UPDATE_YEAR (1 << 2)
+#define START_YEAR 2155
 
 typedef struct
 {
@@ -102,5 +102,9 @@ extern void UnlockGameClock (void);
 // but not much else
 extern BOOLEAN GameClockRunning (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _CLOCK_H */
 
diff -ruNp src.hd/uqm/cnctdlg.c src/uqm/cnctdlg.c
--- src.hd/uqm/cnctdlg.c	2017-12-29 02:25:51 -0800
+++ src/uqm/cnctdlg.c	2017-12-29 00:57:43 -0800
@@ -531,14 +531,12 @@ DrawConnectDialog (void)
 	r.corner.x = (SCREEN_WIDTH - r.extent.width) >> 1;
 	r.corner.y = (SCREEN_HEIGHT - r.extent.height) >> 1;
 
-	LockMutex (GraphicsLock);
 
 	DrawShadowedBox (&r, SHADOWBOX_BACKGROUND_COLOR,
 			SHADOWBOX_DARK_COLOR, SHADOWBOX_MEDIUM_COLOR);
 
 	menu.draw ((WIDGET *)&menu, r.corner.x + 10, r.corner.y + 10);
 
-	UnlockMutex (GraphicsLock);
 }
 
 static BOOLEAN
diff -ruNp src.hd/uqm/cnctdlg.h src/uqm/cnctdlg.h
--- src.hd/uqm/cnctdlg.h	2017-12-29 02:25:51 -0800
+++ src/uqm/cnctdlg.h	2017-12-29 00:57:43 -0800
@@ -16,16 +16,23 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-#ifdef NETPLAY
-
 #ifndef _CNCTDLG_H
 #define _CNCTDLG_H
 
+#ifdef NETPLAY
+
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 BOOLEAN MeleeConnectDialog (int side);
 
-#endif /* _CNCTDLG_H */
+#if defined(__cplusplus)
+}
+#endif
 
 #endif /* NETPLAY */
 
+#endif /* _CNCTDLG_H */
diff -ruNp src.hd/uqm/coderes.h src/uqm/coderes.h
--- src.hd/uqm/coderes.h	2017-12-29 02:25:51 -0800
+++ src/uqm/coderes.h	2017-12-29 00:57:43 -0800
@@ -21,6 +21,10 @@
 
 #include "libs/reslib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern BOOLEAN InstallCodeResType (void);
 extern void *LoadCodeResInstance (RESOURCE res);
 extern void *CaptureCodeRes (void *hCode, void *pData, void **ppLocData);
@@ -32,5 +36,9 @@ typedef struct
 	UWORD size;
 } CODE_REF;
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _CODERES_H */
 
diff -ruNp src.hd/uqm/collide.h src/uqm/collide.h
--- src.hd/uqm/collide.h	2017-12-29 02:25:51 -0800
+++ src/uqm/collide.h	2017-12-29 00:57:43 -0800
@@ -21,6 +21,10 @@
 
 #include "element.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #define COLLISION_TURN_WAIT 1
 #define COLLISION_THRUST_WAIT 3
 
@@ -59,5 +63,9 @@
 
 extern void collide (ELEMENT *ElementPtr0, ELEMENT *ElementPtr1);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _COLLIDE_H */
 
diff -ruNp src.hd/uqm/comm/Makeinfo src/uqm/comm/Makeinfo
--- src.hd/uqm/comm/Makeinfo	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/Makeinfo	2017-12-29 00:57:43 -0800
@@ -1,3 +1,4 @@
 uqm_SUBDIRS="arilou blackur chmmr comandr druuge ilwrath melnorm mycon
 		orz pkunk rebel shofixt slyhome slyland spahome spathi starbas supox
 		syreen talkpet thradd umgah urquan utwig vux yehat zoqfot"
+uqm_HFILES="commall.h"
diff -ruNp src.hd/uqm/comm/arilou/Makeinfo src/uqm/comm/arilou/Makeinfo
--- src.hd/uqm/comm/arilou/Makeinfo	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/arilou/Makeinfo	2017-12-29 00:57:43 -0800
@@ -1 +1,2 @@
 uqm_CFILES="arilouc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.hd/uqm/comm/arilou/arilouc.c src/uqm/comm/arilou/arilouc.c
--- src.hd/uqm/comm/arilou/arilouc.c	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/arilou/arilouc.c	2017-12-29 00:57:43 -0800
@@ -231,7 +231,7 @@ static LOCDATA arilou_desc =
 static void
 ExitConversation (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 
 	if (PLAYER_SAID (R, bye_angry_space))
 		NPCPhrase (GOODBYE_ANGRY_SPACE);
@@ -491,20 +491,18 @@ AngryHomeArilou (RESPONSE_REF R)
 		DISABLE_PHRASE (i_just_like_to_leave);
 	}
 
-	if (PHRASE_ENABLED (invaders_from_mars)){
+	if (PHRASE_ENABLED (invaders_from_mars))
 		Response (invaders_from_mars, AngryHomeArilou);
-	} else {
+	else
+	{
 		Response (bug_eyed_fruitcakes, ExitConversation);
 	}
-	if (PHRASE_ENABLED (why_should_i_trust)) {
+	if (PHRASE_ENABLED (why_should_i_trust))
 		Response (why_should_i_trust, AngryHomeArilou);
-	} else if (PHRASE_ENABLED (what_about_interference)) {
+	else if (PHRASE_ENABLED (what_about_interference))
 		Response (what_about_interference, AngryHomeArilou);
-	}
 	Response (ok_lets_be_friends, ArilouHome);
-	if (PHRASE_ENABLED (i_just_like_to_leave)){
-		Response (i_just_like_to_leave, AngryHomeArilou);
-	}
+	Response (i_just_like_to_leave, AngryHomeArilou);
 }
 
 static void
@@ -647,7 +645,7 @@ Intro (void)
 	{
 		NPCPhrase (OUT_TAKES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 	else if (!GET_GAME_STATE (MET_ARILOU))
@@ -694,7 +692,7 @@ Intro (void)
 		}
 		SET_GAME_STATE (ARILOU_VISITS, NumVisits);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else if (Manner == 1)
 	{
@@ -804,7 +802,7 @@ post_arilou_enc (void)
 {
 	BYTE Manner;
 
-	if (GET_GAME_STATE (BATTLE_SEGUE) == 1
+	if (getSegue () == Segue_hostile
 			&& (Manner = GET_GAME_STATE (ARILOU_MANNER)) != 2)
 	{
 		SET_GAME_STATE (ARILOU_MANNER, 1);
@@ -846,11 +844,11 @@ init_arilou_comm (void)
 			|| GET_GAME_STATE (ARILOU_MANNER) == 3
 			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	retval = &arilou_desc;
 
diff -ruNp src.hd/uqm/comm/arilou/resinst.h src/uqm/comm/arilou/resinst.h
--- src.hd/uqm/comm/arilou/resinst.h	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/arilou/resinst.h	2017-12-29 00:57:43 -0800
@@ -1,5 +1,10 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define ARILOU_COLOR_MAP "comm.arilou.colortable"
-#define ARILOU_PMAP_ANIM "comm.arilou.graphics"
-#define ARILOU_FONT "comm.arilou.font"
 #define ARILOU_CONVERSATION_PHRASES "comm.arilou.dialogue"
+#define ARILOU_FONT "comm.arilou.font"
 #define ARILOU_MUSIC "comm.arilou.music"
+#define ARILOU_PMAP_ANIM "comm.arilou.graphics"
+#define ARILOU_SCRIPT "comm.arilou.script"
diff -ruNp src.hd/uqm/comm/blackur/Makeinfo src/uqm/comm/blackur/Makeinfo
--- src.hd/uqm/comm/blackur/Makeinfo	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/blackur/Makeinfo	2017-12-29 00:57:43 -0800
@@ -1 +1,2 @@
 uqm_CFILES="blackurc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.hd/uqm/comm/blackur/blackurc.c src/uqm/comm/blackur/blackurc.c
--- src.hd/uqm/comm/blackur/blackurc.c	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/blackur/blackurc.c	2017-12-29 00:57:43 -0800
@@ -92,7 +92,8 @@ static LOCDATA blackurq_desc =
 		{
 			33, /* StartIndex */
 			5, /* NumFrames */
-			CIRCULAR_ANIM | WAIT_TALKING, /* AnimFlags */
+			CIRCULAR_ANIM
+					| WAIT_TALKING, /* AnimFlags */
 			ONE_SECOND / 10, 0, /* FrameRate */
 			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
 			0, /* BlockMask */
@@ -134,7 +135,7 @@ CombatIsInevitable (RESPONSE_REF R)
 {
 	BYTE NumVisits;
 
-	SET_GAME_STATE (BATTLE_SEGUE, 1);
+	setSegue (Segue_hostile);
 
 	if (PLAYER_SAID (R, bye))
 	{
@@ -447,7 +448,7 @@ Intro (void)
 	{
 		NPCPhrase (OUT_TAKES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
@@ -455,7 +456,7 @@ Intro (void)
 	{
 		NPCPhrase (GAME_OVER_DUDE);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
@@ -466,7 +467,7 @@ Intro (void)
 		SET_GAME_STATE (KOHR_AH_SENSES_EVIL, 1);
 	}
 
-	GrpOffs = GET_GAME_STATE_32 (SAMATRA_GRPOFFS0);
+	GrpOffs = GET_GAME_STATE (SAMATRA_GRPOFFS);
 	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
 			&& GLOBAL (BattleGroupRef)
 			&& GLOBAL (BattleGroupRef) == GrpOffs)
@@ -474,7 +475,7 @@ Intro (void)
 		NPCPhrase (HELLO_SAMATRA);
 
 		SET_GAME_STATE (AWARE_OF_SAMATRA, 1);
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else
 	{
@@ -555,11 +556,11 @@ init_blackurq_comm (void)
 	if (!GET_GAME_STATE (KOHR_AH_KILLED_ALL)
 			&& LOBYTE (GLOBAL (CurrentActivity)) != WON_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	retval = &blackurq_desc;
 
diff -ruNp src.hd/uqm/comm/blackur/resinst.h src/uqm/comm/blackur/resinst.h
--- src.hd/uqm/comm/blackur/resinst.h	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/blackur/resinst.h	2017-12-29 00:57:43 -0800
@@ -1,5 +1,10 @@
-#define BLACKURQ_PMAP_ANIM "comm.kohrah.graphics"
-#define BLACKURQ_FONT "comm.kohrah.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define BLACKURQ_COLOR_MAP "comm.kohrah.colortable"
 #define BLACKURQ_CONVERSATION_PHRASES "comm.kohrah.dialogue"
+#define BLACKURQ_FONT "comm.kohrah.font"
 #define BLACKURQ_MUSIC "comm.kohrah.music"
+#define BLACKURQ_PMAP_ANIM "comm.kohrah.graphics"
+#define BLACKURQ_SCRIPT "comm.kohrah.script"
diff -ruNp src.hd/uqm/comm/chmmr/Makeinfo src/uqm/comm/chmmr/Makeinfo
--- src.hd/uqm/comm/chmmr/Makeinfo	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/chmmr/Makeinfo	2017-12-29 00:57:43 -0800
@@ -1 +1,2 @@
 uqm_CFILES="chmmrc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.hd/uqm/comm/chmmr/chmmrc.c src/uqm/comm/chmmr/chmmrc.c
--- src.hd/uqm/comm/chmmr/chmmrc.c	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/chmmr/chmmrc.c	2017-12-29 00:57:43 -0800
@@ -20,13 +20,14 @@
 #include "resinst.h"
 #include "strings.h"
 
+#include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
 #include "uqm/hyper.h"
 			// for SOL_X/SOL_Y
-
 #include "../../nameref.h"
 			// JMS_GFX: For LoadGraphic 
 
+
 static LOCDATA chmmr_desc =
 {
 	CHMMR_CONVERSATION, /* AlienConv */
@@ -123,7 +124,7 @@ static LOCDATA chmmr_desc =
 static void
 ExitConversation (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 
 	if (PLAYER_SAID (R, bye))
 		NPCPhrase (GOODBYE);
@@ -137,7 +138,7 @@ ExitConversation (RESPONSE_REF R)
 
 		NPCPhrase (TAKE_2_WEEKS);
 
-		ActivateStarShip (CHMMR_SHIP, SET_ALLIED);
+		SetRaceAllied (CHMMR_SHIP, TRUE);
 
 		SET_GAME_STATE (CHMMR_HOME_VISITS, 0);
 		SET_GAME_STATE (CHMMR_STACK, 0);
@@ -151,6 +152,11 @@ ExitConversation (RESPONSE_REF R)
 /* Magic numbers for Earth */
 #define EARTH_OUTER_X (-725)
 #define EARTH_OUTER_Y (597)
+#define EARTH_INNER_X (121)
+#define EARTH_INNER_Y (113)
+/* Magic numbers for Earth Starbase */
+#define STARBASE_INNER_X (86)
+#define STARBASE_INNER_Y (113)
 
 		/* transport player to Earth */
 		GLOBAL_SIS (log_x) = UNIVERSE_TO_LOGX (SOL_X);
@@ -174,6 +180,7 @@ ExitConversation (RESPONSE_REF R)
 			for (i = NUM_BOMB_MODULES; i < NUM_MODULE_SLOTS; ++i)
 				GLOBAL_SIS (ModuleSlots[i]) = EMPTY_SLOT + 2;
 
+			/* XXX : this should be unhardcoded eventually */
 			/* transport to Starbase */
 			GLOBAL (ShipStamp.origin.x) = SIS_SCREEN_WIDTH >> 1;
 			GLOBAL (ShipStamp.origin.y) = SIS_SCREEN_HEIGHT >> 1;
@@ -208,10 +215,10 @@ ExitConversation (RESPONSE_REF R)
 
 			/* XXX : this should be unhardcoded eventually */
 			/* transport to Earth itself */
-			GLOBAL (ShipStamp.origin.x) = SIS_SCREEN_WIDTH >> 1;
-			GLOBAL (ShipStamp.origin.y) = SIS_SCREEN_HEIGHT >> 1;
+			GLOBAL (ShipStamp.origin.x) = EARTH_INNER_X - SAFE_X;
+			GLOBAL (ShipStamp.origin.y) = EARTH_INNER_Y - SAFE_Y;
 		}
-		
+
 		/* install Chmmr-supplied modules */
 		for (i = 0; i < NUM_DRIVE_SLOTS; ++i)
 			GLOBAL_SIS (DriveSlots[i]) = FUSION_THRUSTER;
@@ -245,7 +252,7 @@ NotReady (RESPONSE_REF R)
 	{
 		NPCPhrase (USE_OUR_SHIPS_BEFORE);
 
-		ActivateStarShip (CHMMR_SHIP, SET_ALLIED);
+		SetRaceAllied (CHMMR_SHIP, TRUE);
 	}
 	else if (PLAYER_SAID (R, where_weapon))
 	{
@@ -260,7 +267,7 @@ NotReady (RESPONSE_REF R)
 		DISABLE_PHRASE (where_distraction);
 	}
 
-	if (ActivateStarShip (CHMMR_SHIP, CHECK_ALLIANCE) != GOOD_GUY)
+	if (CheckAlliance (CHMMR_SHIP) != GOOD_GUY)
 		Response (tech_help, NotReady);
 	else if (PHRASE_ENABLED (further_assistance))
 		Response (further_assistance, NotReady);
@@ -298,7 +305,7 @@ ImproveBomb (RESPONSE_REF R)
 	{
 		NPCPhrase (USE_OUR_SHIPS_AFTER);
 
-		ActivateStarShip (CHMMR_SHIP, SET_ALLIED);
+		SetRaceAllied (CHMMR_SHIP, TRUE);
 	}
 
 	if (PHRASE_ENABLED (what_now))
@@ -307,7 +314,7 @@ ImproveBomb (RESPONSE_REF R)
 		Response (wont_hurt_my_ship, ImproveBomb);
 	else if (PHRASE_ENABLED (bummer_about_my_ship))
 		Response (bummer_about_my_ship, ImproveBomb);
-	if (ActivateStarShip (CHMMR_SHIP, CHECK_ALLIANCE) != GOOD_GUY)
+	if (CheckAlliance (CHMMR_SHIP) != GOOD_GUY)
 		Response (other_assistance, ImproveBomb);
 	Response (proceed, ExitConversation);
 }
@@ -316,7 +323,7 @@ static void
 ChmmrFree (RESPONSE_REF R)
 {
 	if (R == 0
-			|| PLAYER_SAID (R, i_am_captain0)
+			|| PLAYER_SAID (R, i_am_captain)
 			|| PLAYER_SAID (R, i_am_savior)
 			|| PLAYER_SAID (R, i_am_silly))
 	{
@@ -555,7 +562,7 @@ Intro (void)
 			CommData.AlienColorMap = SetAbsColorMapIndex (
 					CommData.AlienColorMap, 1
 					);
-			
+
 			// JMS_GFX: Use separate graphics in hires instead of colormap transform.
 			if (RESOLUTION_FACTOR > 0)
 			{
@@ -563,7 +570,7 @@ Intro (void)
 				CommData.AlienFrame = CaptureDrawable (
 					LoadGraphic (CommData.AlienFrameRes));
 			}
-				
+
 			switch (NumVisits++)
 			{
 				case 0:
@@ -585,6 +592,9 @@ Intro (void)
 		}
 		else
 		{
+			HFLEETINFO hChmmr = GetStarShipFromIndex (&GLOBAL (avail_race_q), CHMMR_SHIP);
+			FLEET_INFO *ChmmrPtr = LockFleetInfo (&GLOBAL (avail_race_q), hChmmr);
+
 			SetCommIntroMode (CIM_FADE_IN_SCREEN, ONE_SECOND * 2);
 			NPCPhrase (WE_ARE_FREE);
 
@@ -597,19 +607,23 @@ Intro (void)
 			{
 				NPCPhrase (WHO_ARE_YOU);
 
-				construct_response (shared_phrase_buf,
-						i_am_captain0,
-						GLOBAL_SIS (CommanderName),
-						i_am_captain1,
-						GLOBAL_SIS (ShipName),
-						i_am_captain2,
-						(UNICODE*)NULL);
-				DoResponsePhrase (i_am_captain0, ChmmrFree, shared_phrase_buf);
+				Response (i_am_captain, ChmmrFree);
 				Response (i_am_savior, ChmmrFree);
 				Response (i_am_silly, ChmmrFree);
 			}
 
 			SET_GAME_STATE (CHMMR_UNLEASHED, 1);
+
+			// Setup a Chmmr sphere-of-influence, now that they're out
+			// of their shell.  EncounterPercent for the Chmmr is 0,
+			// so this is purely decorative.
+			if (ChmmrPtr) {
+				ChmmrPtr->actual_strength = 1800 / SPHERE_RADIUS_INCREMENT * 2;
+				ChmmrPtr->loc.x = 742;
+				ChmmrPtr->loc.y = 2268;
+				StartSphereTracking (CHMMR_SHIP);
+			}
+			UnlockFleetInfo (&GLOBAL (avail_race_q), hChmmr);
 		}
 		SET_GAME_STATE (CHMMR_HOME_VISITS, NumVisits);
 	}
@@ -618,6 +632,7 @@ Intro (void)
 static COUNT
 uninit_chmmr (void)
 {
+	luaUqm_comm_uninit ();
 	return (0);
 }
 
@@ -636,11 +651,15 @@ init_chmmr_comm (void)
 	chmmr_desc.post_encounter_func = post_chmmr_enc;
 	chmmr_desc.uninit_encounter_func = uninit_chmmr;
 
+	luaUqm_comm_init (NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	chmmr_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
 	chmmr_desc.AlienTextBaseline.y = 0;
 	chmmr_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
 
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 	retval = &chmmr_desc;
 
 	return (retval);
diff -ruNp src.hd/uqm/comm/chmmr/resinst.h src/uqm/comm/chmmr/resinst.h
--- src.hd/uqm/comm/chmmr/resinst.h	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/chmmr/resinst.h	2017-12-29 00:57:43 -0800
@@ -1,6 +1,11 @@
-#define CHMMR_PMAP_ANIM "comm.chmmr.graphics"
-#define CHMMR_RED_PMAP_ANIM "comm.chmmr.red.graphics"
-#define CHMMR_FONT "comm.chmmr.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define CHMMR_COLOR_MAP "comm.chmmr.colortable"
 #define CHMMR_CONVERSATION_PHRASES "comm.chmmr.dialogue"
+#define CHMMR_FONT "comm.chmmr.font"
 #define CHMMR_MUSIC "comm.chmmr.music"
+#define CHMMR_PMAP_ANIM "comm.chmmr.graphics"
+#define CHMMR_RED_PMAP_ANIM "comm.chmmr.red.graphics"
+#define CHMMR_SCRIPT "comm.chmmr.script"
diff -ruNp src.hd/uqm/comm/chmmr/strings.h src/uqm/comm/chmmr/strings.h
--- src.hd/uqm/comm/chmmr/strings.h	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/chmmr/strings.h	2017-12-29 00:57:43 -0800
@@ -52,9 +52,7 @@ enum
 	GOODBYE_SHIELDED,
 	WE_ARE_FREE,
 	WHO_ARE_YOU,
-	i_am_captain0,
-	i_am_captain1,
-	i_am_captain2,
+	i_am_captain,
 	i_am_savior,
 	i_am_silly,
 	WHY_HAVE_YOU_FREED_US,
diff -ruNp src.hd/uqm/comm/comandr/Makeinfo src/uqm/comm/comandr/Makeinfo
--- src.hd/uqm/comm/comandr/Makeinfo	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/comandr/Makeinfo	2017-12-29 00:57:43 -0800
@@ -1 +1,2 @@
 uqm_CFILES="comandr.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.hd/uqm/comm/comandr/comandr.c src/uqm/comm/comandr/comandr.c
--- src.hd/uqm/comm/comandr/comandr.c	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/comandr/comandr.c	2017-12-29 00:57:43 -0800
@@ -16,18 +16,15 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "../commall.h"
 #include "resinst.h"
 #include "strings.h"
-
+#include "uqm/units.h"
 #include "uqm/setup.h"
 #include "uqm/sis.h"
 		// for DeltaSISGauges(), DrawLanders()
 #include "libs/graphics/gfx_common.h"
-
-#include "uqm/units.h" // JMS_GFX
+#include "uqm/lua/luacomm.h"
 
 static LOCDATA commander_desc_1x =
 {
@@ -217,18 +214,12 @@ ByeBye (RESPONSE_REF R)
 		else /* if (R == annihilate_those_monsters) */
 			NPCPhrase (KILL_MONSTERS);
 
-		construct_response (shared_phrase_buf,
-				name_40,
-				GLOBAL_SIS (CommanderName),
-				name_41,
-				(UNICODE*)NULL);
-
 		NPCPhrase (THIS_MAY_SEEM_SILLY);
 
 		Response (name_1, ByeBye);
 		Response (name_2, ByeBye);
 		Response (name_3, ByeBye);
-		DoResponsePhrase (name_40, ByeBye, shared_phrase_buf);
+		Response (name_4, ByeBye);
 
 		SET_GAME_STATE (STARBASE_AVAILABLE, 1);
 	}
@@ -254,9 +245,7 @@ ByeBye (RESPONSE_REF R)
 		}
 		else /* if (PLAYER_SAID (R, name_4)) */
 		{
-			NPCPhrase (OK_THE_NAME_IS_EMPIRE0);
-			NPCPhrase (GLOBAL_PLAYER_NAME);
-			NPCPhrase (OK_THE_NAME_IS_EMPIRE1);
+			NPCPhrase (OK_THE_NAME_IS_EMPIRE);
 
 			SET_GAME_STATE (NEW_ALLIANCE_NAME, 3);
 		}
@@ -290,7 +279,7 @@ NoRadioactives (RESPONSE_REF R)
 
 			DISABLE_PHRASE (where_can_i_get_radios);
 		}
-		else if (PLAYER_SAID (R, no_but_well_help0))
+		else if (PLAYER_SAID (R, no_but_well_help))
 			NPCPhrase (THE_WHAT_FROM_WHERE);
 		else if (PLAYER_SAID (R, what_slave_planet)
 				|| PLAYER_SAID (R, i_lied))
@@ -299,48 +288,32 @@ NoRadioactives (RESPONSE_REF R)
 			NPCPhrase (WHAT_KIND_OF_IDIOT);
 		else if (PLAYER_SAID (R, i_lost_my_lander))
 		{
-			if (GET_GAME_STATE (RADIOACTIVES_PROVIDED))
-				NPCPhrase (HERE_IS_A_NEW_LANDER_CLEAN);
-			else
-				NPCPhrase (HERE_IS_A_NEW_LANDER);
-				
+			NPCPhrase (HERE_IS_A_NEW_LANDER);
 			++GLOBAL_SIS (NumLanders);
-			LockMutex (GraphicsLock);
 			DrawLanders ();
 			DeltaSISGauges (4, 0, 0);
-			UnlockMutex (GraphicsLock);
 
 			SET_GAME_STATE (LANDERS_LOST, 1);
 		}
 		else if (PLAYER_SAID (R, i_lost_another_lander))
 		{
-			if (GET_GAME_STATE (RADIOACTIVES_PROVIDED))
-				NPCPhrase (HERE_IS_ANOTHER_LANDER_CLEAN);
-			else
-				NPCPhrase (HERE_IS_ANOTHER_LANDER);
-				
+			NPCPhrase (HERE_IS_ANOTHER_LANDER);
 			++GLOBAL_SIS (NumLanders);
-			LockMutex (GraphicsLock);
 			DrawLanders ();
 			DeltaSISGauges (4, 0, 0);
-			UnlockMutex (GraphicsLock);
 		}
 		else if (PLAYER_SAID (R, need_fuel_mercury) ||
 				PLAYER_SAID (R, need_fuel_luna))
 		{
 			NPCPhrase (GIVE_FUEL);
-			LockMutex (GraphicsLock);
 			DeltaSISGauges (0, 5 * FUEL_TANK_SCALE, 0);
-			UnlockMutex (GraphicsLock);
 
 			SET_GAME_STATE (GIVEN_FUEL_BEFORE, 1);
 		}
 		else if (PLAYER_SAID (R, need_fuel_again))
 		{
 			NPCPhrase (GIVE_FUEL_AGAIN);
-			LockMutex (GraphicsLock);
 			DeltaSISGauges (0, 5 * FUEL_TANK_SCALE, 0);
-			UnlockMutex (GraphicsLock);
 		}
 
 		if (GLOBAL_SIS (ElementAmounts[RADIOACTIVE]))
@@ -377,48 +350,32 @@ AskAfterRadios (RESPONSE_REF R)
 {
 	if (PLAYER_SAID (R, i_lost_my_lander))
 	{
-		if (GET_GAME_STATE (RADIOACTIVES_PROVIDED))
-			NPCPhrase (HERE_IS_A_NEW_LANDER_CLEAN);
-		else
-			NPCPhrase (HERE_IS_A_NEW_LANDER);
-			
+		NPCPhrase (HERE_IS_A_NEW_LANDER);
 		++GLOBAL_SIS (NumLanders);
-		LockMutex (GraphicsLock);
 		DrawLanders ();
 		DeltaSISGauges (4, 0, 0);
-		UnlockMutex (GraphicsLock);
 
 		SET_GAME_STATE (LANDERS_LOST, 1);
 	}
 	else if (PLAYER_SAID (R, i_lost_another_lander))
 	{
-		if (GET_GAME_STATE (RADIOACTIVES_PROVIDED))
-			NPCPhrase (HERE_IS_ANOTHER_LANDER_CLEAN);
-		else
-			NPCPhrase (HERE_IS_ANOTHER_LANDER);
-			
+		NPCPhrase (HERE_IS_ANOTHER_LANDER);
 		++GLOBAL_SIS (NumLanders);
-		LockMutex (GraphicsLock);
 		DrawLanders ();
 		DeltaSISGauges (4, 0, 0);
-		UnlockMutex (GraphicsLock);
 	}
 	else if (PLAYER_SAID (R, need_fuel_mercury) ||
 			PLAYER_SAID (R, need_fuel_luna))
 	{
 		NPCPhrase (GIVE_FUEL);
-		LockMutex (GraphicsLock);
 		DeltaSISGauges (0, 5 * FUEL_TANK_SCALE, 0);
-		UnlockMutex (GraphicsLock);
 
 		SET_GAME_STATE (GIVEN_FUEL_BEFORE, 1);
 	}
 	else if (PLAYER_SAID (R, need_fuel_again))
 	{
 		NPCPhrase (GIVE_FUEL_AGAIN);
-		LockMutex (GraphicsLock);
 		DeltaSISGauges (0, 5 * FUEL_TANK_SCALE, 0);
-		UnlockMutex (GraphicsLock);
 	}
 	else if (PLAYER_SAID (R, where_get_radios))
 	{
@@ -487,48 +444,32 @@ TellMoonBase (RESPONSE_REF R)
 	}
 	else if (PLAYER_SAID (R, i_lost_my_lander))
 	{
-		if (GET_GAME_STATE (RADIOACTIVES_PROVIDED))
-			NPCPhrase (HERE_IS_A_NEW_LANDER_CLEAN);
-		else
-			NPCPhrase (HERE_IS_A_NEW_LANDER);
-			
+		NPCPhrase (HERE_IS_A_NEW_LANDER);
 		++GLOBAL_SIS (NumLanders);
-		LockMutex (GraphicsLock);
 		DrawLanders ();
 		DeltaSISGauges (4, 0, 0);
-		UnlockMutex (GraphicsLock);
 
 		SET_GAME_STATE (LANDERS_LOST, 1);
 	}
 	else if (PLAYER_SAID (R, i_lost_another_lander))
 	{
-		if (GET_GAME_STATE (RADIOACTIVES_PROVIDED))
-			NPCPhrase (HERE_IS_ANOTHER_LANDER_CLEAN);
-		else
-			NPCPhrase (HERE_IS_ANOTHER_LANDER);
-			
+		NPCPhrase (HERE_IS_ANOTHER_LANDER);
 		++GLOBAL_SIS (NumLanders);
-		LockMutex (GraphicsLock);
 		DrawLanders ();
 		DeltaSISGauges (4, 0, 0);
-		UnlockMutex (GraphicsLock);
 	}
 	else if (PLAYER_SAID (R, need_fuel_mercury) ||
 			PLAYER_SAID (R, need_fuel_luna))
 	{
 		NPCPhrase (GIVE_FUEL);
-		LockMutex (GraphicsLock);
 		DeltaSISGauges (0, 5 * FUEL_TANK_SCALE, 0);
-		UnlockMutex (GraphicsLock);
 
 		SET_GAME_STATE (GIVEN_FUEL_BEFORE, 1);
 	}
 	else if (PLAYER_SAID (R, need_fuel_again))
 	{
 		NPCPhrase (GIVE_FUEL_AGAIN);
-		LockMutex (GraphicsLock);
 		DeltaSISGauges (0, 5 * FUEL_TANK_SCALE, 0);
-		UnlockMutex (GraphicsLock);
 	}
 	else if (PLAYER_SAID (R, we_are_here_to_help))
 	{
@@ -590,11 +531,11 @@ RevealSelf (RESPONSE_REF R)
 	BYTE i, stack;
 
 	stack = 0;
-	if (PLAYER_SAID (R, we_are_vindicator0))
+	if (PLAYER_SAID (R, we_are_vindicator))
 	{
 		NPCPhrase (THATS_IMPOSSIBLE);
 
-		DISABLE_PHRASE (we_are_vindicator0);
+		DISABLE_PHRASE (we_are_vindicator);
 	}
 	else if (PLAYER_SAID (R, our_mission_was_secret))
 	{
@@ -656,17 +597,8 @@ RevealSelf (RESPONSE_REF R)
 		}
 		else
 		{
-			if (PHRASE_ENABLED (we_are_vindicator0))
-			{
-				construct_response (shared_phrase_buf,
-						we_are_vindicator0,
-						GLOBAL_SIS (CommanderName),
-						we_are_vindicator1,
-						GLOBAL_SIS (ShipName),
-						we_are_vindicator2,
-						(UNICODE*)NULL);
-				DoResponsePhrase (we_are_vindicator0, RevealSelf, shared_phrase_buf);
-			}
+			if (PHRASE_ENABLED (we_are_vindicator))
+				Response (we_are_vindicator, RevealSelf);
 			else if (PHRASE_ENABLED (our_mission_was_secret))
 				Response (our_mission_was_secret, RevealSelf);
 			else
@@ -688,14 +620,11 @@ GiveRadios (RESPONSE_REF R)
 		SET_GAME_STATE (RADIOACTIVES_PROVIDED, 1);
 
 		NPCPhrase (FUEL_UP0);
-		NPCPhrase (FUEL_UP1);
+		NPCPhrase (FUEL_UP1);		
 		AlienTalkSegue (1);
 
-		LockMutex (GraphicsLock);
-		
 		// JMS_GFX: Disable noisy static animation in hi-res.
-		if (RESOLUTION_FACTOR > 0)
-		{
+		if (RESOLUTION_FACTOR > 0) {
 			CommData.AlienTalkDesc.AnimFlags &= ~PAUSE_TALKING;
 			CommData.AlienAmbientArray[0].AnimFlags &= ~ANIM_DISABLED;
 			CommData.AlienAmbientArray[1].AnimFlags &= ~ANIM_DISABLED;
@@ -704,8 +633,6 @@ GiveRadios (RESPONSE_REF R)
 		// End color transform anim in lo-res.
 		else
 			CommData.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
-		
-		UnlockMutex (GraphicsLock);
 
 		XFormColorMap (GetColorMapAddress (
 				SetAbsColorMapIndex (CommData.AlienColorMap, 0)
@@ -772,13 +699,7 @@ Intro (void)
 		SET_GAME_STATE (STARBASE_VISITED, 1);
 
 		NPCPhrase (ARE_YOU_SUPPLY_SHIP);
-		construct_response (
-				shared_phrase_buf,
-				no_but_well_help0,
-				GLOBAL_SIS (ShipName),
-				no_but_well_help1,
-				(UNICODE*)NULL);
-		DoResponsePhrase (no_but_well_help0, NoRadioactives, shared_phrase_buf);
+		Response (no_but_well_help, NoRadioactives);
 		Response (yes_this_is_supply_ship, NoRadioactives);
 		Response (what_slave_planet, NoRadioactives);
 	}
@@ -787,6 +708,7 @@ Intro (void)
 static COUNT
 uninit_commander (void)
 {
+	luaUqm_comm_uninit();
 	return (0);
 }
 
@@ -801,27 +723,17 @@ init_commander_comm ()
 {
 	static LOCDATA commander_desc;
 	LOCDATA *retval;
-	
-	// JMS_GFX
-	switch (RESOLUTION_FACTOR)
-	{
-		case 2:
-			commander_desc = commander_desc_4x;
-			break;
-		case 1:
-			commander_desc = commander_desc_4x;
-			break;
-		case 0:
-		default:
-			commander_desc = commander_desc_1x;
-			break;
-	}
-	
+
+	commander_desc = (RESOLUTION_FACTOR == 0 ? commander_desc_1x : commander_desc_4x);
+
 	commander_desc.init_encounter_func = Intro;
 	commander_desc.post_encounter_func = post_commander_enc;
 	commander_desc.uninit_encounter_func = uninit_commander;
-	
-	// Power on - have radioactives.
+
+	luaUqm_comm_init(NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	if (GET_GAME_STATE (RADIOACTIVES_PROVIDED))
 	{
 		// JMS_GFX: Disable noisy static animation in hi-res.
@@ -831,13 +743,10 @@ init_commander_comm ()
 			commander_desc.AlienAmbientArray[0].AnimFlags &= ~ANIM_DISABLED;
 			commander_desc.AlienAmbientArray[1].AnimFlags &= ~ANIM_DISABLED;
 		}
-
 		commander_desc.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
-		
 		// regular track -- let's make sure
 		commander_desc.AlienSongFlags &= ~LDASF_USE_ALTERNATE;
 	}
-	// Low power - no radioactives.
 	else
 	{	
 		// JMS_GFX: Enable noisy static animation in hi-res.
@@ -847,22 +756,19 @@ init_commander_comm ()
 			commander_desc.AlienAmbientArray[0].AnimFlags |= ANIM_DISABLED;
 			commander_desc.AlienAmbientArray[1].AnimFlags |= ANIM_DISABLED;
 		}
-		
 		commander_desc.AlienAmbientArray[2].AnimFlags &= ~ANIM_DISABLED;
-		
 		// use alternate 'low-power' track if available
 		commander_desc.AlienAltSongRes = COMMANDER_LOWPOW_MUSIC;
 		commander_desc.AlienSongFlags |= LDASF_USE_ALTERNATE;
 	}
-	
+
 	// JMS_GFX
 	commander_desc.AlienTextWidth = RES_SIS_SCALE(143); // JMS_GFX
 	commander_desc.AlienTextBaseline.x = RES_SIS_SCALE(164); // JMS_GFX
 	commander_desc.AlienTextBaseline.y = RES_SIS_SCALE(20); // JMS_GFX
-	
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
 
+	setSegue (Segue_peace);
 	retval = &commander_desc;
-	
+
 	return (retval);
-}
+}
\ No newline at end of file
diff -ruNp src.hd/uqm/comm/comandr/resinst.h src/uqm/comm/comandr/resinst.h
--- src.hd/uqm/comm/comandr/resinst.h	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/comandr/resinst.h	2017-12-29 00:57:43 -0800
@@ -1,8 +1,14 @@
-#define COMMANDER_PMAP_ANIM "comm.commander.graphics"
-#define COMMANDER_FONT "comm.commander.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define COMMANDER_COLOR_MAP "comm.commander.colortable"
 #define COMMANDER_CONVERSATION_PHRASES "comm.commander.dialogue"
-#define STARBASE_CONVERSATION_PHRASES "comm.starbase.dialogue"
+#define COMMANDER_FONT "comm.commander.font"
 #define COMMANDER_LOWPOW_MUSIC "comm.commander.lowpower.music"
 #define COMMANDER_MUSIC "comm.commander.music"
+#define COMMANDER_PMAP_ANIM "comm.commander.graphics"
+#define COMMANDER_SCRIPT "comm.commander.script"
 #define STARBASE_ALT_MUSIC "comm.starbase.music"
+#define STARBASE_CONVERSATION_PHRASES "comm.starbase.dialogue"
+#define STARBASE_SCRIPT "comm.starbase.script"
diff -ruNp src.hd/uqm/comm/comandr/strings.h src/uqm/comm/comandr/strings.h
--- src.hd/uqm/comm/comandr/strings.h	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/comandr/strings.h	2017-12-29 00:57:43 -0800
@@ -28,19 +28,16 @@ enum
 	ARE_YOU_SUPPLY_SHIP,
 	DO_YOU_HAVE_RADIO_THIS_TIME,
 	HERE_IS_ANOTHER_LANDER,
-	HERE_IS_ANOTHER_LANDER_CLEAN,
 	THE_WHAT_FROM_WHERE,
 	ABOUT_TIME,
 	MESSAGE_GARBLED_1,
 	MESSAGE_GARBLED_2,
 	HERE_IS_A_NEW_LANDER,
-	HERE_IS_A_NEW_LANDER_CLEAN,
 	THIS_MAY_SEEM_SILLY,
 	OK_THE_NAFS,
 	OK_THE_CAN,
 	OK_THE_UFW,
-	OK_THE_NAME_IS_EMPIRE0,
-	OK_THE_NAME_IS_EMPIRE1,
+	OK_THE_NAME_IS_EMPIRE,
 	FUEL_UP0,
 	FUEL_UP1,
 	WHAT_KIND_OF_IDIOT,
@@ -82,15 +79,12 @@ enum
 	we_will_transfer_now,
 	what_will_you_give_us,
 	before_radios_we_need_info,
-	no_but_well_help0,
-	no_but_well_help1,
+	no_but_well_help,
 	yes_this_is_supply_ship,
 	what_slave_planet,
 	i_lied,
 	plumb_out,
-	we_are_vindicator0,
-	we_are_vindicator1,
-	we_are_vindicator2,
+	we_are_vindicator,
 	first_give_info,
 	we_must_go_now,
 	where_can_i_get_radios,
@@ -111,8 +105,7 @@ enum
 	name_1,
 	name_2,
 	name_3,
-	name_40,
-	name_41,
+	name_4,
 	i_lost_my_lander,
 	i_lost_another_lander,
 	need_fuel_mercury,
diff -ruNp src.hd/uqm/comm/druuge/Makeinfo src/uqm/comm/druuge/Makeinfo
--- src.hd/uqm/comm/druuge/Makeinfo	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/druuge/Makeinfo	2017-12-29 00:57:43 -0800
@@ -1 +1,2 @@
 uqm_CFILES="druugec.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.hd/uqm/comm/druuge/druugec.c src/uqm/comm/druuge/druugec.c
--- src.hd/uqm/comm/druuge/druugec.c	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/druuge/druugec.c	2017-12-29 00:57:43 -0800
@@ -25,6 +25,7 @@
 #include "uqm/sis.h"
 		// for DeltaSISGauges()
 
+
 static LOCDATA druuge_desc_1x =
 {
 	DRUUGE_CONVERSATION, /* AlienConv */
@@ -301,7 +302,7 @@ ExitConversation (RESPONSE_REF R)
 {
 	if (PLAYER_SAID (R, bye))
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 
 		if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 7))
 		{
@@ -345,7 +346,7 @@ ExitConversation (RESPONSE_REF R)
 	}
 	else /* if (R == then_we_take_bomb) */
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 
 		NPCPhrase (FIGHT_FOR_BOMB);
 	}
@@ -362,9 +363,9 @@ Buy (RESPONSE_REF R)
 		NPCPhrase (READY_TO_SELL);
 		if (!GET_GAME_STATE (ROSY_SPHERE))
 			NPCPhrase (HAVE_SPHERE);
-		if (!GET_GAME_STATE (ARTIFACT_2_ON_SHIP))
+		if (!GET_GAME_STATE (WIMBLIS_TRIDENT_ON_SHIP))
 			NPCPhrase (HAVE_ART_1);
-		if (!GET_GAME_STATE (ARTIFACT_3_ON_SHIP))
+		if (!GET_GAME_STATE (GLOWING_ROD_ON_SHIP))
 			NPCPhrase (HAVE_ART_2);
 		NPCPhrase (SHIPS_AND_FUEL);
 
@@ -375,15 +376,13 @@ Buy (RESPONSE_REF R)
 #define SHIP_CREW_COST 100
 		if (GLOBAL_SIS (CrewEnlisted) < SHIP_CREW_COST)
 			NPCPhrase (NOT_ENOUGH_CREW);
-		else if (ActivateStarShip (DRUUGE_SHIP, FEASIBILITY_STUDY) == 0)
+		else if (EscortFeasibilityStudy (DRUUGE_SHIP) == 0)
 			NPCPhrase (NOT_ENOUGH_ROOM);
 		else
 		{
-			LockMutex (GraphicsLock);
 			DeltaSISGauges (-SHIP_CREW_COST, 0, 0);
-			UnlockMutex (GraphicsLock);
 			SlaveryCount += SHIP_CREW_COST;
-			ActivateStarShip (DRUUGE_SHIP, 1);
+			AddEscortShips (DRUUGE_SHIP, 1);
 
 			NPCPhrase (BOUGHT_SHIP);
 		}
@@ -395,9 +394,7 @@ Buy (RESPONSE_REF R)
 			NPCPhrase (NOT_ENOUGH_CREW);
 		else
 		{
-			LockMutex (GraphicsLock);
 			DeltaSISGauges (-ARTIFACT_CREW_COST, 0, 0);
-			UnlockMutex (GraphicsLock);
 			SlaveryCount += ARTIFACT_CREW_COST;
 			SET_GAME_STATE (ROSY_SPHERE_ON_SHIP, 1);
 			SET_GAME_STATE (ROSY_SPHERE, 1);
@@ -411,11 +408,9 @@ Buy (RESPONSE_REF R)
 			NPCPhrase (NOT_ENOUGH_CREW);
 		else
 		{
-			LockMutex (GraphicsLock);
 			DeltaSISGauges (-ARTIFACT_CREW_COST, 0, 0);
-			UnlockMutex (GraphicsLock);
 			SlaveryCount += ARTIFACT_CREW_COST;
-			SET_GAME_STATE (ARTIFACT_2_ON_SHIP, 1);
+			SET_GAME_STATE (WIMBLIS_TRIDENT_ON_SHIP, 1);
 
 			NPCPhrase (BOUGHT_ART_1);
 		}
@@ -426,11 +421,9 @@ Buy (RESPONSE_REF R)
 			NPCPhrase (NOT_ENOUGH_CREW);
 		else
 		{
-			LockMutex (GraphicsLock);
 			DeltaSISGauges (-ARTIFACT_CREW_COST, 0, 0);
-			UnlockMutex (GraphicsLock);
 			SlaveryCount += ARTIFACT_CREW_COST;
-			SET_GAME_STATE (ARTIFACT_3_ON_SHIP, 1);
+			SET_GAME_STATE (GLOWING_ROD_ON_SHIP, 1);
 
 			NPCPhrase (BOUGHT_ART_2);
 		}
@@ -442,10 +435,8 @@ Buy (RESPONSE_REF R)
 			NPCPhrase (NOT_ENOUGH_CREW);
 		else
 		{
-			LockMutex (GraphicsLock);
 			DeltaSISGauges (-FUEL_CREW_COST,
 					FUEL_CREW_COST * FUEL_TANK_SCALE, 0);
-			UnlockMutex (GraphicsLock);
 			SlaveryCount += FUEL_CREW_COST;
 
 			NPCPhrase (BOUGHT_FUEL);
@@ -455,9 +446,9 @@ Buy (RESPONSE_REF R)
 	Response (buy_druuge_ship, Buy);
 	if (!GET_GAME_STATE (ROSY_SPHERE))
 		Response (buy_rosy_sphere, Buy);
-	if (!GET_GAME_STATE (ARTIFACT_2_ON_SHIP))
+	if (!GET_GAME_STATE (WIMBLIS_TRIDENT_ON_SHIP))
 		Response (buy_art_1, Buy);
-	if (!GET_GAME_STATE (ARTIFACT_3_ON_SHIP))
+	if (!GET_GAME_STATE (GLOWING_ROD_ON_SHIP))
 		Response (buy_art_2, Buy);
 	Response (buy_fuel, Buy);
 	Response (done_buying, TradeWorld);
@@ -538,7 +529,7 @@ DoTransaction (RESPONSE_REF R)
 
 		trade_gas = 0;
 		ships_to_trade = 0;
-		ship_slots = ActivateStarShip (DRUUGE_SHIP, FEASIBILITY_STUDY);
+		ship_slots = EscortFeasibilityStudy (DRUUGE_SHIP);
 		if (PLAYER_SAID (R, sell_maidens))
 		{
 			NPCPhrase (BOUGHT_MAIDENS);
@@ -565,7 +556,7 @@ DoTransaction (RESPONSE_REF R)
 		NPCPhrase (YOU_GET);
 		if (ships_to_trade)
 		{
-			ActivateStarShip (DRUUGE_SHIP, ships_to_trade);
+			AddEscortShips (DRUUGE_SHIP, ships_to_trade);
 
 			if (ship_slots >= ships_to_trade)
 				NPCPhrase (DEAL_FOR_STATED_SHIPS);
@@ -601,14 +592,12 @@ DoTransaction (RESPONSE_REF R)
 			capacity -= GLOBAL_SIS (FuelOnBoard);
 			f = (COUNT)((capacity + (FUEL_TANK_SCALE >> 1)) / FUEL_TANK_SCALE);
 
-			LockMutex (GraphicsLock);
 			while (capacity > 0x3FFFL)
 			{
 				DeltaSISGauges (0, 0x3FFF, 0);
 				capacity -= 0x3FFF;
 			}
 			DeltaSISGauges (0, (SIZE)capacity, 0);
-			UnlockMutex (GraphicsLock);
 
 			NPCPhrase (FUEL0);
 			NPCNumber (f, NULL);
@@ -830,7 +819,7 @@ Intro (void)
 	{
 		NPCPhrase (OUT_TAKES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
@@ -867,7 +856,7 @@ Intro (void)
 			SET_GAME_STATE (DRUUGE_VISITS, NumVisits);
 		}
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 7))
 	{
@@ -961,7 +950,7 @@ Intro (void)
 		}
 		SET_GAME_STATE (DRUUGE_VISITS, NumVisits);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else
 	{
@@ -997,7 +986,7 @@ Intro (void)
 			}
 			SET_GAME_STATE (DRUUGE_SALVAGE, NumVisits);
 
-			SET_GAME_STATE (BATTLE_SEGUE, 1);
+			setSegue (Segue_hostile);
 			AttemptedSalvage = TRUE;
 		}
 		else
@@ -1029,7 +1018,7 @@ uninit_druuge (void)
 static void
 post_druuge_enc (void)
 {
-	if (GET_GAME_STATE (BATTLE_SEGUE) == 1
+	if (getSegue () == Segue_hostile
 			&& !AttemptedSalvage
 			&& !GET_GAME_STATE (DRUUGE_MANNER))
 	{
@@ -1045,21 +1034,9 @@ LOCDATA*
 init_druuge_comm (void)
 {
 	static LOCDATA druuge_desc;
-	LOCDATA *retval;
-	
-	switch (RESOLUTION_FACTOR)
-	{
-		case 2:
-			druuge_desc = druuge_desc_4x;
-			break;
-		case 1:
-			druuge_desc = druuge_desc_4x;
-			break;
-		case 0:
-		default:
-			druuge_desc = druuge_desc_1x;
-			break;
-	}
+ 	LOCDATA *retval;
+
+	druuge_desc = (RESOLUTION_FACTOR == 0 ? druuge_desc_1x : druuge_desc_4x);
 
 	SlaveryCount = 0;
 	AttemptedSalvage = FALSE;
@@ -1076,11 +1053,11 @@ init_druuge_comm (void)
 			&& (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 7)))
 			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	retval = &druuge_desc;
 
diff -ruNp src.hd/uqm/comm/druuge/resinst.h src/uqm/comm/druuge/resinst.h
--- src.hd/uqm/comm/druuge/resinst.h	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/druuge/resinst.h	2017-12-29 00:57:43 -0800
@@ -1,5 +1,10 @@
-#define DRUUGE_PMAP_ANIM "comm.druuge.graphics"
-#define DRUUGE_FONT "comm.druuge.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define DRUUGE_COLOR_MAP "comm.druuge.colortable"
 #define DRUUGE_CONVERSATION_PHRASES "comm.druuge.dialogue"
+#define DRUUGE_FONT "comm.druuge.font"
 #define DRUUGE_MUSIC "comm.druuge.music"
+#define DRUUGE_PMAP_ANIM "comm.druuge.graphics"
+#define DRUUGE_SCRIPT "comm.druuge.script"
diff -ruNp src.hd/uqm/comm/ilwrath/Makeinfo src/uqm/comm/ilwrath/Makeinfo
--- src.hd/uqm/comm/ilwrath/Makeinfo	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/ilwrath/Makeinfo	2017-12-29 00:57:43 -0800
@@ -1 +1,2 @@
 uqm_CFILES="ilwrathc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.hd/uqm/comm/ilwrath/ilwrathc.c src/uqm/comm/ilwrath/ilwrathc.c
--- src.hd/uqm/comm/ilwrath/ilwrathc.c	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/ilwrath/ilwrathc.c	2017-12-29 00:57:43 -0800
@@ -103,7 +103,7 @@ static LOCDATA ilwrath_desc =
 static void
 CombatIsInevitable (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 1);
+	setSegue (Segue_hostile);
 
 	if (PLAYER_SAID (R, you_are_weak))
 		NPCPhrase (STRENGTH_NOT_ALL);
@@ -125,7 +125,7 @@ CombatIsInevitable (RESPONSE_REF R)
 	{
 		NPCPhrase (GOODBYE_GODS);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	if (PLAYER_SAID (R, whats_up))
 	{
@@ -587,7 +587,7 @@ Intro (void)
 		else
 			NPCPhrase (JUST_GRUNTS);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 4))
 	{
@@ -597,7 +597,7 @@ Intro (void)
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 
 		if (GET_GAME_STATE (ILWRATH_FIGHT_THRADDASH))
 			NPCPhrase (HAPPY_FIGHTING_THRADDASH);
@@ -638,11 +638,11 @@ init_ilwrath_comm (void)
 			& ((1 << 4) | (1 << 5)))
 			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	retval = &ilwrath_desc;
 
diff -ruNp src.hd/uqm/comm/ilwrath/resinst.h src/uqm/comm/ilwrath/resinst.h
--- src.hd/uqm/comm/ilwrath/resinst.h	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/ilwrath/resinst.h	2017-12-29 00:57:43 -0800
@@ -1,5 +1,10 @@
-#define ILWRATH_PMAP_ANIM "comm.ilwrath.graphics"
-#define ILWRATH_FONT "comm.ilwrath.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define ILWRATH_COLOR_MAP "comm.ilwrath.colortable"
 #define ILWRATH_CONVERSATION_PHRASES "comm.ilwrath.dialogue"
+#define ILWRATH_FONT "comm.ilwrath.font"
 #define ILWRATH_MUSIC "comm.ilwrath.music"
+#define ILWRATH_PMAP_ANIM "comm.ilwrath.graphics"
+#define ILWRATH_SCRIPT "comm.ilwrath.script"
diff -ruNp src.hd/uqm/comm/melnorm/Makeinfo src/uqm/comm/melnorm/Makeinfo
--- src.hd/uqm/comm/melnorm/Makeinfo	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/melnorm/Makeinfo	2017-12-29 00:57:43 -0800
@@ -1 +1,2 @@
 uqm_CFILES="melnorm.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.hd/uqm/comm/melnorm/melnorm.c src/uqm/comm/melnorm/melnorm.c
--- src.hd/uqm/comm/melnorm/melnorm.c	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/melnorm/melnorm.c	2017-12-29 00:57:43 -0800
@@ -21,26 +21,17 @@
 #include "strings.h"
 
 #include "uqm/gameev.h"
-#include "uqm/setup.h"
-		// for GraphicsLock
 #include "uqm/shipcont.h"
 #include "libs/inplib.h"
 #include "libs/mathlib.h"
-
+#include "libs/log.h"
+#include "uqm/lua/luacomm.h"
 #include "uqm/hyper.h"
 			// for SOL_X/SOL_Y
 #include "uqm/planets/planets.h"
 		// for xxx_DISASTER
 #include "uqm/sis.h"
 
-#include "libs/log.h"
-
-#include "options.h"
-
-#define NUM_HISTORY_ITEMS 9
-#define NUM_EVENT_ITEMS 8
-#define NUM_ALIEN_RACE_ITEMS 16
-#define NUM_TECH_ITEMS 13
 
 static const NUMBER_SPEECH_DESC melnorme_numbers_english;
 
@@ -338,6 +329,294 @@ static const NUMBER_SPEECH_DESC melnorme
 	}
 };
 
+#define ARRAY_SIZE(array) (sizeof(array) / sizeof (*array))
+
+
+//////////////Technology System///////////////////////
+// This section deals with enabling and checking for
+// various technologies.  It should probably be
+// migrated to its own file.
+
+// Identifiers for the various technologies
+typedef enum 
+{
+	TECH_MODULE_BLASTER,
+	TECH_LANDER_SPEED,
+	TECH_MODULE_ANTIMISSILE,
+	TECH_LANDER_SHIELD_BIO,
+	TECH_LANDER_CARGO,
+	TECH_MODULE_BIGFUELTANK,
+	TECH_LANDER_RAPIDFIRE,
+	TECH_LANDER_SHIELD_QUAKE,
+	TECH_MODULE_TRACKING,
+	TECH_LANDER_SHIELD_LIGHTNING,
+	TECH_LANDER_SHIELD_HEAT,
+	TECH_MODULE_CANNON,
+	TECH_MODULE_FURNACE,
+} TechId_t;
+
+// Group the technologies into three subtypes
+typedef enum
+{
+	TECH_TYPE_MODULE,         // Flagship modules
+	                          //  subtype = moduleId, info = cost
+                              //   Cost will be scaled by MODULE_COST_SCALE.
+	TECH_TYPE_LANDER_SHIELD,  // Lander shield enhancements
+                              //  subtype = disaster type, info = unused
+	TECH_TYPE_STATE           // Other game state changes
+	                          //  subtype = stateId, info = state value
+} TechType_t;
+
+
+// Define the information specifying a particular technology
+typedef struct
+{
+	TechId_t   id;      // ID of the technology
+	TechType_t type;    // Type of the technology
+	int        subtype; // Subtype of the technology
+	int        info;    // Supplemental information
+} TechData;
+
+
+// A table of the available technologies.
+// This should really be an associative map of TechIds to tech data records,
+// but implementing that would be excessive.
+static const TechData tech_data_table[] = 
+{
+	// Tech ID                      Tech Type,               Supplemental info
+	{ TECH_MODULE_BLASTER,          TECH_TYPE_MODULE,        BLASTER_WEAPON,        4000 },
+	{ TECH_LANDER_SPEED,            TECH_TYPE_STATE,         IMPROVED_LANDER_SPEED,    1 },
+	{ TECH_MODULE_ANTIMISSILE,      TECH_TYPE_MODULE,        ANTIMISSILE_DEFENSE,   4000 },
+	{ TECH_LANDER_SHIELD_BIO,       TECH_TYPE_LANDER_SHIELD, BIOLOGICAL_DISASTER,     -1 },
+	{ TECH_LANDER_CARGO,            TECH_TYPE_STATE,         IMPROVED_LANDER_CARGO,    1 },
+	{ TECH_MODULE_BIGFUELTANK,      TECH_TYPE_MODULE,        HIGHEFF_FUELSYS,       1000 },
+	{ TECH_LANDER_RAPIDFIRE,        TECH_TYPE_STATE,         IMPROVED_LANDER_SHOT,     1 },
+	{ TECH_LANDER_SHIELD_QUAKE,     TECH_TYPE_LANDER_SHIELD, EARTHQUAKE_DISASTER,     -1 },
+	{ TECH_MODULE_TRACKING,         TECH_TYPE_MODULE,        TRACKING_SYSTEM,       5000 },
+	{ TECH_LANDER_SHIELD_LIGHTNING, TECH_TYPE_LANDER_SHIELD, LIGHTNING_DISASTER,      -1 },
+	{ TECH_LANDER_SHIELD_HEAT,      TECH_TYPE_LANDER_SHIELD, LAVASPOT_DISASTER,       -1 },
+	{ TECH_MODULE_CANNON,           TECH_TYPE_MODULE,        CANNON_WEAPON,         6000 },
+	{ TECH_MODULE_FURNACE,          TECH_TYPE_MODULE,        SHIVA_FURNACE,         4000 },
+};
+const size_t NUM_TECHNOLOGIES = ARRAY_SIZE (tech_data_table);
+
+// Lookup function to get the data for a particular tech
+static const TechData* 
+GetTechData (TechId_t techId)
+{
+	size_t i = 0;
+	for (i = 0; i < NUM_TECHNOLOGIES; ++i)
+	{
+		if (tech_data_table[i].id == techId)
+			return &tech_data_table[i];
+	}
+	return NULL;
+}
+
+
+// We have to explicitly switch on the state ID because the xxx_GAME_STATE
+// macros use preprocessor stringizing.
+static bool
+HasStateTech (int stateId)
+{
+	switch (stateId)
+	{
+		case IMPROVED_LANDER_SPEED:
+			return GET_GAME_STATE (IMPROVED_LANDER_SPEED);
+		case IMPROVED_LANDER_CARGO:
+			return GET_GAME_STATE (IMPROVED_LANDER_CARGO);
+		case IMPROVED_LANDER_SHOT:
+			return GET_GAME_STATE (IMPROVED_LANDER_SHOT);
+	}
+	return false;
+}
+
+static void
+GrantStateTech (int stateId, BYTE value)
+{
+	switch (stateId)
+	{
+		case IMPROVED_LANDER_SPEED:
+			SET_GAME_STATE (IMPROVED_LANDER_SPEED, value);
+			return;
+		case IMPROVED_LANDER_CARGO:
+			SET_GAME_STATE (IMPROVED_LANDER_CARGO, value);
+			return;
+		case IMPROVED_LANDER_SHOT:
+			SET_GAME_STATE (IMPROVED_LANDER_SHOT, value);
+			return;
+	}
+}
+
+static bool
+HasTech (TechId_t techId)
+{
+	const TechData* techData = GetTechData (techId);
+	if (!techData)
+		return false;
+
+	switch (techData->type)
+	{
+		case TECH_TYPE_MODULE:
+			return GLOBAL (ModuleCost[techData->subtype]) != 0;
+		case TECH_TYPE_LANDER_SHIELD:
+			return (GET_GAME_STATE (LANDER_SHIELDS) & (1 << techData->subtype)) != 0;
+		case TECH_TYPE_STATE:
+			return HasStateTech (techData->subtype);
+	}
+	return false;
+}
+
+static void
+GrantTech (TechId_t techId)
+{
+	const TechData* techData = GetTechData (techId);
+	if (!techData)
+		return;
+
+	switch (techData->type)
+	{
+		case TECH_TYPE_MODULE:
+			GLOBAL (ModuleCost[techData->subtype]) = techData->info / MODULE_COST_SCALE;
+			return;
+		case TECH_TYPE_LANDER_SHIELD:
+		{
+			COUNT state = GET_GAME_STATE (LANDER_SHIELDS) | (1 << techData->subtype);
+			SET_GAME_STATE (LANDER_SHIELDS, state);
+			return;
+		}
+		case TECH_TYPE_STATE:
+			GrantStateTech (techData->subtype, techData->info);
+			return;
+	}
+}
+
+
+////////////Melnorme Sales System///////////
+// This section contains code related to Melnorme sales
+
+// Many of the conversation lines in strings.h fall into groups
+// of sequential responses.  These structures allow those
+// responses to be interated through.
+static const int ok_buy_event_lines[] =
+{
+	OK_BUY_EVENT_1, OK_BUY_EVENT_2, OK_BUY_EVENT_3, OK_BUY_EVENT_4,
+	OK_BUY_EVENT_5, OK_BUY_EVENT_6, OK_BUY_EVENT_7, OK_BUY_EVENT_8
+};
+const size_t NUM_EVENT_ITEMS = ARRAY_SIZE (ok_buy_event_lines);
+
+static const int ok_buy_alien_race_lines[] =
+{
+	OK_BUY_ALIEN_RACE_1,  OK_BUY_ALIEN_RACE_2,  OK_BUY_ALIEN_RACE_3, 
+	OK_BUY_ALIEN_RACE_4,  OK_BUY_ALIEN_RACE_5,  OK_BUY_ALIEN_RACE_6, 
+	OK_BUY_ALIEN_RACE_7,  OK_BUY_ALIEN_RACE_8,  OK_BUY_ALIEN_RACE_9, 
+	OK_BUY_ALIEN_RACE_10, OK_BUY_ALIEN_RACE_11, OK_BUY_ALIEN_RACE_12,
+	OK_BUY_ALIEN_RACE_13, OK_BUY_ALIEN_RACE_14, OK_BUY_ALIEN_RACE_15, 
+	OK_BUY_ALIEN_RACE_16
+};
+const size_t NUM_ALIEN_RACE_ITEMS = ARRAY_SIZE (ok_buy_alien_race_lines);
+
+static const int ok_buy_history_lines[] =
+{
+	OK_BUY_HISTORY_1, OK_BUY_HISTORY_2, OK_BUY_HISTORY_3, 
+	OK_BUY_HISTORY_4, OK_BUY_HISTORY_5, OK_BUY_HISTORY_6, 
+	OK_BUY_HISTORY_7, OK_BUY_HISTORY_8, OK_BUY_HISTORY_9
+};
+const size_t NUM_HISTORY_ITEMS = ARRAY_SIZE (ok_buy_history_lines);
+
+static const int hello_and_down_to_business_lines[] =
+{
+	HELLO_AND_DOWN_TO_BUSINESS_1, HELLO_AND_DOWN_TO_BUSINESS_2,
+	HELLO_AND_DOWN_TO_BUSINESS_3, HELLO_AND_DOWN_TO_BUSINESS_4,
+	HELLO_AND_DOWN_TO_BUSINESS_5, HELLO_AND_DOWN_TO_BUSINESS_6,
+	HELLO_AND_DOWN_TO_BUSINESS_7, HELLO_AND_DOWN_TO_BUSINESS_8,
+	HELLO_AND_DOWN_TO_BUSINESS_9, HELLO_AND_DOWN_TO_BUSINESS_10
+};
+const size_t NUM_HELLO_LINES = ARRAY_SIZE (hello_and_down_to_business_lines);
+
+static const int rescue_lines[] =
+{
+	RESCUE_EXPLANATION, RESCUE_AGAIN_1, RESCUE_AGAIN_2,
+	RESCUE_AGAIN_3,     RESCUE_AGAIN_4, RESCUE_AGAIN_5
+};
+const size_t NUM_RESCUE_LINES = ARRAY_SIZE (rescue_lines);
+
+// How many lines are available in the given array?
+static size_t
+GetNumLines (const int array[])
+{
+	if (array == ok_buy_event_lines)
+		return NUM_EVENT_ITEMS;
+	else if (array == ok_buy_alien_race_lines)
+		return NUM_ALIEN_RACE_ITEMS;
+	else if (array == ok_buy_history_lines)
+		return NUM_HISTORY_ITEMS;
+	else if (array == hello_and_down_to_business_lines)
+		return NUM_HELLO_LINES;
+	else if (array == rescue_lines)
+		return NUM_RESCUE_LINES;
+	return 0;
+}
+
+// Get the line, with range checking.
+// Returns the last line if the desired one is out of range.
+static int 
+GetLineSafe (const int array[], size_t linenum)
+{
+	const size_t array_size = GetNumLines (array);
+	assert (array_size > 0);
+	if (linenum >= array_size)
+		linenum = array_size - 1;
+	return array[linenum];
+}
+
+// Data structure to hold the Melnorme's info on a technology
+typedef struct
+{
+	TechId_t techId;  // ID of technology
+	int price;        // Melnorme's price to sell
+	int sale_line;    // Sales pitch line ID
+	int sold_line;    // Post-sale line ID
+} TechSaleData;
+
+// Right now, all techs have the same price.
+#define TECHPRICE (75 * BIO_CREDIT_VALUE)
+
+static const TechSaleData tech_sale_catalog[] =
+{
+	{ TECH_MODULE_BLASTER,          TECHPRICE, NEW_TECH_1,  OK_BUY_NEW_TECH_1 },
+	{ TECH_LANDER_SPEED,            TECHPRICE, NEW_TECH_2,  OK_BUY_NEW_TECH_2 },
+	{ TECH_MODULE_ANTIMISSILE,      TECHPRICE, NEW_TECH_3,  OK_BUY_NEW_TECH_3 },
+	{ TECH_LANDER_SHIELD_BIO,       TECHPRICE, NEW_TECH_4,  OK_BUY_NEW_TECH_4 },
+	{ TECH_LANDER_CARGO,            TECHPRICE, NEW_TECH_5,  OK_BUY_NEW_TECH_5 },
+	{ TECH_MODULE_BIGFUELTANK,      TECHPRICE, NEW_TECH_6,  OK_BUY_NEW_TECH_6 },
+	{ TECH_LANDER_RAPIDFIRE,        TECHPRICE, NEW_TECH_7,  OK_BUY_NEW_TECH_7 },
+	{ TECH_LANDER_SHIELD_QUAKE,     TECHPRICE, NEW_TECH_8,  OK_BUY_NEW_TECH_8 },
+	{ TECH_MODULE_TRACKING,         TECHPRICE, NEW_TECH_9,  OK_BUY_NEW_TECH_9 },
+	{ TECH_LANDER_SHIELD_LIGHTNING, TECHPRICE, NEW_TECH_10, OK_BUY_NEW_TECH_10 },
+	{ TECH_LANDER_SHIELD_HEAT,      TECHPRICE, NEW_TECH_11, OK_BUY_NEW_TECH_11 },
+	{ TECH_MODULE_CANNON,           TECHPRICE, NEW_TECH_12, OK_BUY_NEW_TECH_12 },
+	{ TECH_MODULE_FURNACE,          TECHPRICE, NEW_TECH_13, OK_BUY_NEW_TECH_13 },
+};
+const size_t NUM_TECH_ITEMS = ARRAY_SIZE (tech_sale_catalog);
+
+// Return the next tech for sale that the player doesn't already have.
+// Returns NULL if the player has all the techs.
+static const TechSaleData*
+GetNextTechForSale (void)
+{
+	size_t i = 0;
+	for (i = 0; i < NUM_TECH_ITEMS; ++i)
+	{
+		if (!HasTech (tech_sale_catalog[i].techId))
+			return &tech_sale_catalog[i];
+	}
+
+	return NULL;
+}
+
+///////////End Melnorme Sales Section//////////////////
+
 static StatMsgMode prevMsgMode;
 
 static void DoFirstMeeting (RESPONSE_REF R);
@@ -384,6 +663,51 @@ ShipWorth (void)
 static COUNT rescue_fuel;
 static SIS_STATE SIS_copy;
 
+// Extract method to return the response string index
+// for stripping a given module.
+static int 
+GetStripModuleRef (int moduleID)
+{
+	switch (moduleID)
+	{
+		case PLANET_LANDER:       return LANDERS;
+		case FUSION_THRUSTER:     return THRUSTERS;
+		case TURNING_JETS:        return JETS;
+		case CREW_POD:            return PODS;
+		case STORAGE_BAY:         return BAYS;
+		case DYNAMO_UNIT:         return DYNAMOS;
+		case SHIVA_FURNACE:       return FURNACES;
+		case GUN_WEAPON:          return GUNS;
+		case BLASTER_WEAPON:      return BLASTERS;
+		case CANNON_WEAPON:       return CANNONS;
+		case TRACKING_SYSTEM:     return TRACKERS;
+		case ANTIMISSILE_DEFENSE: return DEFENSES;
+		// If a modder has added new modules, should it really
+		// be a fatal error if the Melnorme don't know about
+		// them?
+		default:
+			assert (0 && "Unknown module");
+	}
+	return 0;
+}
+
+static DWORD
+getStripRandomSeed (void)
+{
+	DWORD x, y;
+	// We truncate the location because encounters move the ship slightly in
+	// HSpace, and throw some other relatively immutable values in the mix to
+	// vary the deal when stuck at the same general location again.
+	// It is still possible but unlikely for encounters to move the ship into
+	// another truncation sector so the player could choose from 2 deals.
+	x = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x)) / 100;
+	y = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y)) / 100;
+	// prime numbers help randomness
+	return y * 1013 + x + GLOBAL_SIS (NumLanders)
+			+ GLOBAL_SIS (ModuleSlots[1]) + GLOBAL_SIS (ModuleSlots[4])
+			+ GLOBAL_SIS (ModuleSlots[7]) + GLOBAL_SIS (ModuleSlots[10]);
+}
+
 static BOOLEAN
 StripShip (COUNT fuel_required)
 {
@@ -399,9 +723,7 @@ StripShip (COUNT fuel_required)
 	if (fuel_required == 0)
 	{
 		GlobData.SIS_state = SIS_copy;
-		LockMutex (GraphicsLock);
 		DeltaSISGauges (UNDEFINED_DELTA, rescue_fuel, UNDEFINED_DELTA);
-		UnlockMutex (GraphicsLock);
 	}
 	else if (fuel_required == (COUNT)~0)
 	{
@@ -425,9 +747,7 @@ StripShip (COUNT fuel_required)
 				GLOBAL_SIS (ModuleSlots[i]) = EMPTY_SLOT + 2;
 		}
 
-		LockMutex (GraphicsLock);
 		DeltaSISGauges (UNDEFINED_DELTA, UNDEFINED_DELTA, UNDEFINED_DELTA);
-		UnlockMutex (GraphicsLock);
 	}
 	else if (fuel_required)
 	{
@@ -437,6 +757,15 @@ StripShip (COUNT fuel_required)
 		BYTE module_count[BOMB_MODULE_0];
 		BYTE slot;
 		DWORD capacity;
+		RandomContext *rc;
+		
+		// Bug #567
+		// In order to offer the same deal each time if it is refused, we seed
+		// the random number generator with our location, thus making the deal
+		// a repeatable pseudo-random function of where we got stuck and what,
+		// exactly, is on our ship.
+		rc = RandomContext_New();
+		RandomContext_SeedRandom (rc, getStripRandomSeed ());
 
 		SIS_copy = GlobData.SIS_state;
 		for (i = PLANET_LANDER; i < BOMB_MODULE_0; ++i)
@@ -458,7 +787,11 @@ StripShip (COUNT fuel_required)
 		} while (slot--);
 		if (fuel_required > capacity)
 			fuel_required = capacity;
-		bays = -(SBYTE)( (SIS_copy.TotalElementMass + STORAGE_BAY_CAPACITY - 1) / STORAGE_BAY_CAPACITY );
+
+		bays = -(SBYTE)(
+				(SIS_copy.TotalElementMass + STORAGE_BAY_CAPACITY - 1)
+				/ STORAGE_BAY_CAPACITY
+				);
 		for (i = 0; i < NUM_MODULE_SLOTS; ++i)
 		{
 			which_module = SIS_copy.ModuleSlots[i];
@@ -476,7 +809,7 @@ StripShip (COUNT fuel_required)
 		{
 			DWORD rand_val;
 
-			rand_val = TFB_Random ();
+			rand_val = RandomContext_Random (rc);
 			switch (which_module = LOBYTE (LOWORD (rand_val)) % (CREW_POD + 1))
 			{
 				case PLANET_LANDER:
@@ -526,13 +859,12 @@ StripShip (COUNT fuel_required)
 			++module_count[which_module];
 			total += GLOBAL (ModuleCost[which_module]);
 		}
+		RandomContext_Delete (rc);
 
 		if (total == 0)
 		{
 			NPCPhrase (CHARITY);
-			LockMutex (GraphicsLock);
 			DeltaSISGauges (0, fuel_required, 0);
-			UnlockMutex (GraphicsLock);
 			return (FALSE);
 		}
 		else
@@ -547,54 +879,10 @@ StripShip (COUNT fuel_required)
 			{
 				if (module_count[i])
 				{
-					RESPONSE_REF pStr = 0;
-
-					switch (i)
-					{
-						case PLANET_LANDER:
-							pStr = LANDERS;
-							break;
-						case FUSION_THRUSTER:
-							pStr = THRUSTERS;
-							break;
-						case TURNING_JETS:
-							pStr = JETS;
-							break;
-						case CREW_POD:
-							pStr = PODS;
-							break;
-						case STORAGE_BAY:
-							pStr = BAYS;
-							break;
-						case DYNAMO_UNIT:
-							pStr = DYNAMOS;
-							break;
-						case SHIVA_FURNACE:
-							pStr = FURNACES;
-							break;
-						case GUN_WEAPON:
-							pStr = GUNS;
-							break;
-						case BLASTER_WEAPON:
-							pStr = BLASTERS;
-							break;
-						case CANNON_WEAPON:
-							pStr = CANNONS;
-							break;
-						case TRACKING_SYSTEM:
-							pStr = TRACKERS;
-							break;
-						case ANTIMISSILE_DEFENSE:
-							pStr = DEFENSES;
-							break;
-						default:
-							assert (0 && "Unknown module");
-					}
-
 					if (i == end_mod && i != beg_mod)
 						NPCPhrase (END_LIST_WITH_AND);
 					NPCPhrase (ENUMERATE_ONE + (module_count[i] - 1));
-					NPCPhrase (pStr);
+					NPCPhrase (GetStripModuleRef (i));
 				}
 			}
 		}
@@ -613,14 +901,14 @@ ExitConversation (RESPONSE_REF R)
 		NPCPhrase (YOU_GIVE_US_NO_CHOICE);
 
 		SET_GAME_STATE (MELNORME_ANGER, 1);
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, so_we_can_attack))
 	{
 		NPCPhrase (DECEITFUL_HUMAN);
 
 		SET_GAME_STATE (MELNORME_ANGER, 2);
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, bye_melnorme_slightly_angry))
 		NPCPhrase (MELNORME_SLIGHTLY_ANGRY_GOODBYE);
@@ -642,7 +930,7 @@ ExitConversation (RESPONSE_REF R)
 		NPCPhrase (OK_FIGHT_SOME_MORE);
 
 		SET_GAME_STATE (MELNORME_ANGER, 3);
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, bye_melnorme_pissed_off))
 		NPCPhrase (MELNORME_PISSED_OFF_GOODBYE);
@@ -650,7 +938,7 @@ ExitConversation (RESPONSE_REF R)
 	{
 		NPCPhrase (WE_FIGHT_AGAIN);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, you_hate_us_so_we_go_away))
 		NPCPhrase (HATE_YOU_GOODBYE);
@@ -702,183 +990,108 @@ DoRescue (RESPONSE_REF R)
 	}
 }
 
-static COUNT
+// Extract method for getting the player's current credits.
+static COUNT 
+GetAvailableCredits (void)
+{
+	return MAKE_WORD (GET_GAME_STATE (MELNORME_CREDIT0),
+			GET_GAME_STATE (MELNORME_CREDIT1));
+}
+
+// Extract method for setting the player's current credits.
+static void
+SetAvailableCredits (COUNT credits)
+{
+	SET_GAME_STATE (MELNORME_CREDIT0, LOBYTE (credits));
+	SET_GAME_STATE (MELNORME_CREDIT1, HIBYTE (credits));
+}
+
+// Now returns whether the purchase succeeded instead of the remaining
+// credit balance.  Use GetAvailableCredits() to get the latter.
+static bool
 DeltaCredit (SIZE delta_credit)
 {
-	COUNT Credit;
+	COUNT Credit = GetAvailableCredits ();
 
-	Credit = MAKE_WORD (
-			GET_GAME_STATE (MELNORME_CREDIT0),
-			GET_GAME_STATE (MELNORME_CREDIT1)
-			);
+	// Can they afford it?
 	if ((int)delta_credit >= 0 || ((int)(-delta_credit) <= (int)(Credit)))
 	{
 		Credit += delta_credit;
-		SET_GAME_STATE (MELNORME_CREDIT0, LOBYTE (Credit));
-		SET_GAME_STATE (MELNORME_CREDIT1, HIBYTE (Credit));
-		LockMutex (GraphicsLock);
+		SetAvailableCredits (Credit);
 		DrawStatusMessage (NULL);
-		UnlockMutex (GraphicsLock);
-	}
-	else
-	{
-		NPCPhrase (NEED_MORE_CREDIT0);
-		NPCNumber (-delta_credit - Credit, NULL);
-		NPCPhrase (NEED_MORE_CREDIT1);
+		return true;
 	}
+
+	// Fail
+	NPCPhrase (NEED_MORE_CREDIT0);
+	NPCNumber (-delta_credit - Credit, NULL);
+	NPCPhrase (NEED_MORE_CREDIT1);
 	
-	return (Credit);
+	return false;
 }
 
+
+// Extract methods to process the giving of various bits of information to the
+// player.  Ideally, we'd want to merge these three into a single parameterized
+// function, but the nature of the XXX_GAME_STATE() code makes that tricky.
 static void
 CurrentEvents (void)
 {
-	BYTE stack;
-
-	stack = GET_GAME_STATE (MELNORME_EVENTS_INFO_STACK);
-	switch (stack++)
-	{
-		case 0:
-			NPCPhrase (OK_BUY_EVENT_1);
-			break;
-		case 1:
-			NPCPhrase (OK_BUY_EVENT_2);
-			break;
-		case 2:
-			NPCPhrase (OK_BUY_EVENT_3);
-			break;
-		case 3:
-			NPCPhrase (OK_BUY_EVENT_4);
-			break;
-		case 4:
-			NPCPhrase (OK_BUY_EVENT_5);
-			break;
-		case 5:
-			NPCPhrase (OK_BUY_EVENT_6);
-			break;
-		case 6:
-			NPCPhrase (OK_BUY_EVENT_7);
-			break;
-		case 7:
-			NPCPhrase (OK_BUY_EVENT_8);
-			break;
-	}
-	SET_GAME_STATE (MELNORME_EVENTS_INFO_STACK, stack);
+	BYTE stack = GET_GAME_STATE (MELNORME_EVENTS_INFO_STACK);
+	const int phraseId = GetLineSafe (ok_buy_event_lines, stack);
+	NPCPhrase (phraseId);
+	SET_GAME_STATE (MELNORME_EVENTS_INFO_STACK, stack + 1);
 }
 
 static void
 AlienRaces (void)
 {
-	BYTE stack;
-
-	stack = GET_GAME_STATE (MELNORME_ALIEN_INFO_STACK);
-	switch (stack++)
+	BYTE stack = GET_GAME_STATE (MELNORME_ALIEN_INFO_STACK);
+	const int phraseId = GetLineSafe (ok_buy_alien_race_lines, stack);
+	// Two pieces of alien knowledge trigger state changes.
+	switch (phraseId)
 	{
-		case 0:
-			NPCPhrase (OK_BUY_ALIEN_RACE_1);
-			break;
-		case 1:
-			NPCPhrase (OK_BUY_ALIEN_RACE_2);
-			break;
-		case 2:
-			NPCPhrase (OK_BUY_ALIEN_RACE_3);
-			break;
-		case 3:
-			NPCPhrase (OK_BUY_ALIEN_RACE_4);
-			break;
-		case 4:
-			NPCPhrase (OK_BUY_ALIEN_RACE_5);
-			break;
-		case 5:
-			NPCPhrase (OK_BUY_ALIEN_RACE_6);
-			break;
-		case 6:
-			NPCPhrase (OK_BUY_ALIEN_RACE_7);
-			break;
-		case 7:
-			NPCPhrase (OK_BUY_ALIEN_RACE_8);
-			break;
-		case 8:
-			NPCPhrase (OK_BUY_ALIEN_RACE_9);
-			break;
-		case 9:
-			NPCPhrase (OK_BUY_ALIEN_RACE_10);
-			break;
-		case 10:
-			NPCPhrase (OK_BUY_ALIEN_RACE_11);
-			break;
-		case 11:
-			NPCPhrase (OK_BUY_ALIEN_RACE_12);
-			break;
-		case 12:
-			NPCPhrase (OK_BUY_ALIEN_RACE_13);
-			break;
-		case 13:
-			NPCPhrase (OK_BUY_ALIEN_RACE_14);
+		case OK_BUY_ALIEN_RACE_14:
 			if (!GET_GAME_STATE (FOUND_PLUTO_SPATHI))
 			{
 				SET_GAME_STATE (KNOW_SPATHI_PASSWORD, 1);
 				SET_GAME_STATE (SPATHI_HOME_VISITS, 7);
 			}
 			break;
-		case 14:
-			NPCPhrase (OK_BUY_ALIEN_RACE_15);
+		case OK_BUY_ALIEN_RACE_15:
 			if (GET_GAME_STATE (KNOW_ABOUT_SHATTERED) < 2)
 			{
 				SET_GAME_STATE (KNOW_ABOUT_SHATTERED, 2);
 			}
 			SET_GAME_STATE (KNOW_SYREEN_WORLD_SHATTERED, 1);
 			break;
-		case 15:
-			NPCPhrase (OK_BUY_ALIEN_RACE_16);
-			break;
 	}
-	SET_GAME_STATE (MELNORME_ALIEN_INFO_STACK, stack);
+	NPCPhrase (phraseId);
+	SET_GAME_STATE (MELNORME_ALIEN_INFO_STACK, stack + 1);
 }
 
 static void
 History (void)
 {
-	BYTE stack;
+	BYTE stack = GET_GAME_STATE (MELNORME_HISTORY_INFO_STACK);
+	const int phraseId = GetLineSafe (ok_buy_history_lines, stack);
+	NPCPhrase (phraseId);
+	SET_GAME_STATE (MELNORME_HISTORY_INFO_STACK, stack + 1);
+}
 
-	stack = GET_GAME_STATE (MELNORME_HISTORY_INFO_STACK);
-	switch (stack++)
-	{
-		case 0:
-			NPCPhrase (OK_BUY_HISTORY_1);
-			break;
-		case 1:
-			NPCPhrase (OK_BUY_HISTORY_2);
-			break;
-		case 2:
-			NPCPhrase (OK_BUY_HISTORY_3);
-			break;
-		case 3:
-			NPCPhrase (OK_BUY_HISTORY_4);
-			break;
-		case 4:
-			NPCPhrase (OK_BUY_HISTORY_5);
-			break;
-		case 5:
-			NPCPhrase (OK_BUY_HISTORY_6);
-			break;
-		case 6:
-			NPCPhrase (OK_BUY_HISTORY_7);
-			break;
-		case 7:
-			NPCPhrase (OK_BUY_HISTORY_8);
-			break;
-		case 8:
-			NPCPhrase (OK_BUY_HISTORY_9);
-			break;
-	}
-	SET_GAME_STATE (MELNORME_HISTORY_INFO_STACK, stack);
+// extract method to tell if we have any information left to sell to the player.
+static bool AnyInfoLeftToSell (void)
+{
+	return GET_GAME_STATE (MELNORME_EVENTS_INFO_STACK) < NUM_EVENT_ITEMS
+			|| GET_GAME_STATE (MELNORME_ALIEN_INFO_STACK) < NUM_ALIEN_RACE_ITEMS
+			|| GET_GAME_STATE (MELNORME_HISTORY_INFO_STACK) < NUM_HISTORY_ITEMS;
 }
 
 static void NatureOfConversation (RESPONSE_REF R);
 
 static BYTE AskedToBuy;
 
+
 static void
 DoBuy (RESPONSE_REF R)
 {
@@ -887,10 +1100,7 @@ DoBuy (RESPONSE_REF R)
 	BYTE slot;
 	DWORD capacity;
 
-	credit = MAKE_WORD (
-			GET_GAME_STATE (MELNORME_CREDIT0),
-			GET_GAME_STATE (MELNORME_CREDIT1)
-			);
+	credit = GetAvailableCredits ();
 
 	capacity = FUEL_RESERVE;
 	slot = NUM_MODULE_SLOTS - 1;
@@ -907,6 +1117,7 @@ DoBuy (RESPONSE_REF R)
 		}
 	} while (slot--);
 
+	// If they're out of credits, educate them on how commerce works.
 	if (credit == 0)
 	{
 		AskedToBuy = TRUE;
@@ -959,14 +1170,12 @@ DoBuy (RESPONSE_REF R)
 				NPCPhrase (GOT_FUEL);
 
 				f = (DWORD)needed_credit * FUEL_TANK_SCALE;
-				LockMutex (GraphicsLock);
 				while (f > 0x3FFFL)
 				{
 					DeltaSISGauges (0, 0x3FFF, 0);
 					f -= 0x3FFF;
 				}
 				DeltaSISGauges (0, (SIZE)f, 0);
-				UnlockMutex (GraphicsLock);
 			}
 			needed_credit *= (BIO_CREDIT_VALUE / 2);
 		}
@@ -989,223 +1198,43 @@ TryFuelAgain:
 	else if (PLAYER_SAID (R, buy_technology)
 			|| PLAYER_SAID (R, buy_new_tech))
 	{
-		BYTE stack;
+		// Note that this code no longer uses the MELNORME_TECH_STACK state
+		// buts, as they're not needed; we can tell what technologies the
+		// player has by using the technology API above.  This opens the
+		// possibility of the player acquiring tech from someplace other than
+		// the Melnorme.
+		const TechSaleData* nextTech;
 
-		needed_credit = 0;
-		if (PLAYER_SAID (R, buy_technology))
+		// If it's our first time, give an introduction.
+		if (!GET_GAME_STATE (MELNORME_TECH_PROCEDURE))
 		{
-			if (!GET_GAME_STATE (MELNORME_TECH_PROCEDURE))
-			{
-				NPCPhrase (BUY_NEW_TECH_INTRO);
-				SET_GAME_STATE (MELNORME_TECH_PROCEDURE, 1);
-			}
-			stack = 0;
+			NPCPhrase (BUY_NEW_TECH_INTRO);
+			SET_GAME_STATE (MELNORME_TECH_PROCEDURE, 1);
 		}
-		else
+
+		// Did the player just attempt to buy a tech?
+		if (PLAYER_SAID (R, buy_new_tech))
 		{
-			RESPONSE_REF pStr = 0;
+			nextTech = GetNextTechForSale ();
+			if (!nextTech)
+				goto BuyBuyBuy; // No tech left to buy
 
-			stack = GET_GAME_STATE (MELNORME_TECH_STACK);
-			switch (stack)
-			{
-				case 0:
-					pStr = OK_BUY_NEW_TECH_1;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 1:
-					pStr = OK_BUY_NEW_TECH_2;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 2:
-					pStr = OK_BUY_NEW_TECH_3;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 3:
-					pStr = OK_BUY_NEW_TECH_4;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 4:
-					pStr = OK_BUY_NEW_TECH_5;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 5:
-					pStr = OK_BUY_NEW_TECH_6;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 6:
-					pStr = OK_BUY_NEW_TECH_7;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 7:
-					pStr = OK_BUY_NEW_TECH_8;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 8:
-					pStr = OK_BUY_NEW_TECH_9;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 9:
-					pStr = OK_BUY_NEW_TECH_10;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 10:
-					pStr = OK_BUY_NEW_TECH_11;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 11:
-					pStr = OK_BUY_NEW_TECH_12;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				case 12:
-					pStr = OK_BUY_NEW_TECH_13;
-					needed_credit = 75 * BIO_CREDIT_VALUE;
-					break;
-				default:
-					assert (0 && "Unknown tech");
-			}
-			if ((int)needed_credit > (int)credit)
-			{
-				DeltaCredit (-needed_credit);
-				goto BuyBuyBuy;
-			}
-			else
-			{
-				++stack;
-				NPCPhrase (pStr);
-				DeltaCredit (-needed_credit);
-			}
+			if (!DeltaCredit (-nextTech->price))
+				goto BuyBuyBuy;  // Can't afford it
+
+			// Make the sale
+			GrantTech (nextTech->techId);
+			NPCPhrase (nextTech->sold_line);
 		}
 
-		switch (stack)
+		nextTech = GetNextTechForSale ();
+		if (!nextTech)
 		{
-			case 0:
-				if (GLOBAL (ModuleCost[BLASTER_WEAPON]) == 0)
-				{
-					NPCPhrase (NEW_TECH_1);
-					break;
-				}
-				++stack;
-			case 1:
-				GLOBAL (ModuleCost[BLASTER_WEAPON]) =
-						4000 / MODULE_COST_SCALE;
-				if (!GET_GAME_STATE (IMPROVED_LANDER_SPEED))
-				{
-					NPCPhrase (NEW_TECH_2);
-					break;
-				}
-				++stack;
-			case 2:
-				SET_GAME_STATE (IMPROVED_LANDER_SPEED, 1);
-				if (GLOBAL (ModuleCost[ANTIMISSILE_DEFENSE]) == 0)
-				{
-					NPCPhrase (NEW_TECH_3);
-					break;
-				}
-				++stack;
-			case 3:
-				GLOBAL (ModuleCost[ANTIMISSILE_DEFENSE]) =
-						4000 / MODULE_COST_SCALE;
-				if (!(GET_GAME_STATE (LANDER_SHIELDS)
-						& (1 << BIOLOGICAL_DISASTER)))
-				{
-					NPCPhrase (NEW_TECH_4);
-					break;
-				}
-				++stack;
-			case 4:
-				credit = GET_GAME_STATE (LANDER_SHIELDS)
-						| (1 << BIOLOGICAL_DISASTER);
-				SET_GAME_STATE (LANDER_SHIELDS, credit);
-				if (!GET_GAME_STATE (IMPROVED_LANDER_CARGO))
-				{
-					NPCPhrase (NEW_TECH_5);
-					break;
-				}
-				++stack;
-			case 5:
-				SET_GAME_STATE (IMPROVED_LANDER_CARGO, 1);
-				if (GLOBAL (ModuleCost[HIGHEFF_FUELSYS]) == 0)
-				{
-					NPCPhrase (NEW_TECH_6);
-					break;
-				}
-				++stack;
-			case 6:
-				GLOBAL (ModuleCost[HIGHEFF_FUELSYS]) =
-						1000 / MODULE_COST_SCALE;
-				if (!GET_GAME_STATE (IMPROVED_LANDER_SHOT))
-				{
-					NPCPhrase (NEW_TECH_7);
-					break;
-				}
-				++stack;
-			case 7:
-				SET_GAME_STATE (IMPROVED_LANDER_SHOT, 1);
-				if (!(GET_GAME_STATE (LANDER_SHIELDS)
-						& (1 << EARTHQUAKE_DISASTER)))
-				{
-					NPCPhrase (NEW_TECH_8);
-					break;
-				}
-				++stack;
-			case 8:
-				credit = GET_GAME_STATE (LANDER_SHIELDS)
-						| (1 << EARTHQUAKE_DISASTER);
-				SET_GAME_STATE (LANDER_SHIELDS, credit);
-				if (GLOBAL (ModuleCost[TRACKING_SYSTEM]) == 0)
-				{
-					NPCPhrase (NEW_TECH_9);
-					break;
-				}
-				++stack;
-			case 9:
-				GLOBAL (ModuleCost[TRACKING_SYSTEM]) =
-						5000 / MODULE_COST_SCALE;
-				if (!(GET_GAME_STATE (LANDER_SHIELDS)
-						& (1 << LIGHTNING_DISASTER)))
-				{
-					NPCPhrase (NEW_TECH_10);
-					break;
-				}
-				++stack;
-			case 10:
-				credit = GET_GAME_STATE (LANDER_SHIELDS)
-						| (1 << LIGHTNING_DISASTER);
-				SET_GAME_STATE (LANDER_SHIELDS, credit);
-				if (!(GET_GAME_STATE (LANDER_SHIELDS)
-						& (1 << LAVASPOT_DISASTER)))
-				{
-					NPCPhrase (NEW_TECH_11);
-					break;
-				}
-				++stack;
-			case 11:
-				credit = GET_GAME_STATE (LANDER_SHIELDS)
-						| (1 << LAVASPOT_DISASTER);
-				SET_GAME_STATE (LANDER_SHIELDS, credit);
-				if (GLOBAL (ModuleCost[CANNON_WEAPON]) == 0)
-				{
-					NPCPhrase (NEW_TECH_12);
-					break;
-				}
-				++stack;
-			case 12:
-				GLOBAL (ModuleCost[CANNON_WEAPON]) =
-						6000 / MODULE_COST_SCALE;
-				if (GLOBAL (ModuleCost[SHIVA_FURNACE]) == 0)
-				{
-					NPCPhrase (NEW_TECH_13);
-					break;
-				}
-				++stack;
-			case 13:
-				GLOBAL (ModuleCost[SHIVA_FURNACE]) =
-						4000 / MODULE_COST_SCALE;
-				NPCPhrase (NEW_TECH_ALL_GONE);
-				SET_GAME_STATE (MELNORME_TECH_STACK, stack);
-				goto BuyBuyBuy;
+			NPCPhrase (NEW_TECH_ALL_GONE);
+			goto BuyBuyBuy; // No tech left to buy
 		}
-		SET_GAME_STATE (MELNORME_TECH_STACK, stack);
+
+		NPCPhrase (nextTech->sale_line);
 
 		Response (buy_new_tech, DoBuy);
 		Response (no_buy_new_tech, DoBuy);
@@ -1215,42 +1244,33 @@ TryFuelAgain:
 			|| PLAYER_SAID (R, buy_alien_races)
 			|| PLAYER_SAID (R, buy_history))
 	{
-		needed_credit = 0;
-		if (PLAYER_SAID (R, buy_info))
+		if (!GET_GAME_STATE (MELNORME_INFO_PROCEDURE))
 		{
-			if (GET_GAME_STATE (MELNORME_INFO_PROCEDURE))
-				NPCPhrase (OK_BUY_INFO);
-			else
-			{
-				NPCPhrase (BUY_INFO_INTRO);
-				SET_GAME_STATE (MELNORME_INFO_PROCEDURE, 1);
-			}
+			NPCPhrase (BUY_INFO_INTRO);
+			SET_GAME_STATE (MELNORME_INFO_PROCEDURE, 1);
+		}
+		else if (PLAYER_SAID (R, buy_info))
+		{
+			NPCPhrase (OK_BUY_INFO);
 		}
 		else
 		{
 #define INFO_COST 75
-			needed_credit = INFO_COST;
-			if ((int)credit >= (int)needed_credit)
-			{
-				if (PLAYER_SAID (R, buy_current_events))
-					CurrentEvents ();
-				else if (PLAYER_SAID (R, buy_alien_races))
-					AlienRaces ();
-				else /* if (R == buy_history) */
-					History ();
-			}
-
-			DeltaCredit (-needed_credit);
-			if (GET_GAME_STATE (MELNORME_EVENTS_INFO_STACK) < NUM_EVENT_ITEMS
-					 || GET_GAME_STATE (MELNORME_ALIEN_INFO_STACK) < NUM_ALIEN_RACE_ITEMS
-					 || GET_GAME_STATE (MELNORME_HISTORY_INFO_STACK) < NUM_HISTORY_ITEMS)
-			{
-			}
-			else
-			{
-				NPCPhrase (INFO_ALL_GONE);
+			if (!DeltaCredit (-INFO_COST))
 				goto BuyBuyBuy;
-			}
+
+			if (PLAYER_SAID (R, buy_current_events))
+				CurrentEvents ();
+			else if (PLAYER_SAID (R, buy_alien_races))
+				AlienRaces ();
+			else if (PLAYER_SAID (R, buy_history))
+				History ();
+		}
+
+		if (!AnyInfoLeftToSell ())
+		{
+			NPCPhrase (INFO_ALL_GONE);
+			goto BuyBuyBuy;
 		}
 
 		if (GET_GAME_STATE (MELNORME_EVENTS_INFO_STACK) < NUM_EVENT_ITEMS)
@@ -1275,12 +1295,11 @@ TryFuelAgain:
 BuyBuyBuy:
 		if (GLOBAL_SIS (FuelOnBoard) < capacity)
 			Response (buy_fuel, DoBuy);
-		if (GET_GAME_STATE (MELNORME_TECH_STACK) < NUM_TECH_ITEMS)
+		if (GetNextTechForSale ())
 			Response (buy_technology, DoBuy);
-		if (GET_GAME_STATE (MELNORME_ALIEN_INFO_STACK) < NUM_ALIEN_RACE_ITEMS
-				|| GET_GAME_STATE (MELNORME_HISTORY_INFO_STACK) < NUM_HISTORY_ITEMS
-				|| GET_GAME_STATE (MELNORME_EVENTS_INFO_STACK) < NUM_EVENT_ITEMS)
+		if (AnyInfoLeftToSell ())
 			Response (buy_info, DoBuy);
+
 		Response (done_buying, NatureOfConversation);
 		Response (be_leaving_now, ExitConversation);
 	}
@@ -1355,9 +1374,7 @@ DoSell (RESPONSE_REF R)
 			} while (GLOBAL_SIS (TotalBioMass));
 			SleepThread (ONE_SECOND / 2);
 
-			LockMutex (GraphicsLock);
 			ClearSISRect (DRAW_SIS_DISPLAY);
-			UnlockMutex (GraphicsLock);
 		}
 		else /* if (R == sell_rainbow_locations) */
 		{
@@ -1400,6 +1417,7 @@ DoSell (RESPONSE_REF R)
 	}
 }
 
+
 static void
 NatureOfConversation (RESPONSE_REF R)
 {
@@ -1413,46 +1431,15 @@ NatureOfConversation (RESPONSE_REF R)
 		R = 0;
 	}
 
-	Credit = DeltaCredit (0);
+	// Draw credits display
+	DeltaCredit (0);
+	Credit = GetAvailableCredits ();
 	if (R == 0)
 	{
-		BYTE stack;
-
-		stack = (BYTE)(GET_GAME_STATE (MELNORME_YACK_STACK2) - 5);
-		switch (stack++)
-		{
-			case 0:
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_1);
-				break;
-			case 1:
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_2);
-				break;
-			case 2:
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_3);
-				break;
-			case 3:
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_4);
-				break;
-			case 4:
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_5);
-				break;
-			case 5:
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_6);
-				break;
-			case 6:
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_7);
-				break;
-			case 7:
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_8);
-				break;
-			case 8:
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_9);
-				break;
-			default:
-				--stack;
-				NPCPhrase (HELLO_AND_DOWN_TO_BUSINESS_10);
-				break;
-		}
+		BYTE stack = GET_GAME_STATE (MELNORME_YACK_STACK2) - 5;
+		NPCPhrase (GetLineSafe (hello_and_down_to_business_lines, stack));
+		if (stack < (NUM_HELLO_LINES - 1))
+			++stack;
 		SET_GAME_STATE (MELNORME_YACK_STACK2, stack + 5);
 	}
 
@@ -1483,20 +1470,15 @@ NatureOfConversation (RESPONSE_REF R)
 
 		if (R == 0)
 		{
-			/* Melnorme reports any news and turns purple */
+				/* Melnorme reports any news and turns purple */
 			NPCPhrase (BUY_OR_SELL);
-			AlienTalkSegue(1);
-			
-			if (RESOLUTION_FACTOR == 0)
-			{
+			AlienTalkSegue (1);
+
+			if (RESOLUTION_FACTOR == 0) {
 				XFormColorMap (GetColorMapAddress (
 					SetAbsColorMapIndex (CommData.AlienColorMap, 1)
 					), ONE_SECOND / 2);
-			}
-			else if (RESOLUTION_FACTOR > 0)
-			{
-				LockMutex (GraphicsLock);
-				
+			} else if (RESOLUTION_FACTOR > 0) {
 				CommData.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
 				CommData.AlienAmbientArray[3].AnimFlags |= ANIM_DISABLED;
 				CommData.AlienAmbientArray[4].AnimFlags &= ~ANIM_DISABLED;
@@ -1507,11 +1489,9 @@ NatureOfConversation (RESPONSE_REF R)
 				CommData.AlienAmbientArray[9].AnimFlags |= ANIM_DISABLED;
 				
 				CommData.AlienFrame = SetAbsFrameIndex (CommData.AlienFrame, 33);
-				
-				UnlockMutex (GraphicsLock);
 			} 
-			
-			AlienTalkSegue((COUNT)~0);
+
+			AlienTalkSegue ((COUNT)~0);
 		}
 		else if (PLAYER_SAID (R, why_turned_purple))
 		{
@@ -1549,32 +1529,10 @@ NatureOfConversation (RESPONSE_REF R)
 		}
 		else
 		{
-			BYTE num_rescues;
+			BYTE num_rescues = GET_GAME_STATE (MELNORME_RESCUE_COUNT);
+			NPCPhrase (GetLineSafe (rescue_lines, num_rescues));
 
-			num_rescues = GET_GAME_STATE (MELNORME_RESCUE_COUNT);
-			switch (num_rescues)
-			{
-				case 0:
-					NPCPhrase (RESCUE_EXPLANATION);
-					break;
-				case 1:
-					NPCPhrase (RESCUE_AGAIN_1);
-					break;
-				case 2:
-					NPCPhrase (RESCUE_AGAIN_2);
-					break;
-				case 3:
-					NPCPhrase (RESCUE_AGAIN_3);
-					break;
-				case 4:
-					NPCPhrase (RESCUE_AGAIN_4);
-					break;
-				case 5:
-					NPCPhrase (RESCUE_AGAIN_5);
-					break;
-			 }
-
-			if (num_rescues < 5)
+			if (num_rescues < NUM_RESCUE_LINES - 1)
 			{
 				++num_rescues;
 				SET_GAME_STATE (MELNORME_RESCUE_COUNT, num_rescues);
@@ -1597,29 +1555,22 @@ DoBluster (RESPONSE_REF R)
 	{
 		NPCPhrase (WERE_NOT_AFRAID);
 		AlienTalkSegue ((COUNT)~0);
-		
-		if (RESOLUTION_FACTOR == 0)
-		{
+
+		if (RESOLUTION_FACTOR == 0) {
 			XFormColorMap (GetColorMapAddress (
 				SetAbsColorMapIndex (CommData.AlienColorMap, 2)
 				), ONE_SECOND / 2);
-		}
-		else if (RESOLUTION_FACTOR > 0)
-		{
-			LockMutex (GraphicsLock);
-			
+		} else if (RESOLUTION_FACTOR > 0) {
 			CommData.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
 			CommData.AlienAmbientArray[3].AnimFlags |= ANIM_DISABLED;
-			CommData.AlienAmbientArray[4].AnimFlags |= ANIM_DISABLED;
-			CommData.AlienAmbientArray[5].AnimFlags |= ANIM_DISABLED;
-			CommData.AlienAmbientArray[6].AnimFlags |= ANIM_DISABLED;
-			CommData.AlienAmbientArray[7].AnimFlags &= ~ANIM_DISABLED;
-			CommData.AlienAmbientArray[8].AnimFlags &= ~ANIM_DISABLED;
-			CommData.AlienAmbientArray[9].AnimFlags &= ~ANIM_DISABLED;
-			
+			CommData.AlienAmbientArray[4].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[5].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[6].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[7].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[8].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[9].AnimFlags |= ANIM_DISABLED;
+				
 			CommData.AlienFrame = SetAbsFrameIndex (CommData.AlienFrame, 48);
-			
-			UnlockMutex (GraphicsLock);
 		}
 
 		SET_GAME_STATE (MELNORME_YACK_STACK2, 4);
@@ -1686,18 +1637,8 @@ yack0_respond (void)
 	switch (GET_GAME_STATE (MELNORME_YACK_STACK0))
 	{
 		case 0:
-		{
-			UNICODE buf[ALLIANCE_NAME_BUFSIZE];
-
-			GetAllianceName (buf, name_1);
-			construct_response (
-					shared_phrase_buf,
-					we_are_from_alliance0,
-					buf,
-					(RESPONSE_REF)-1);
-			DoResponsePhrase (we_are_from_alliance0, DoFirstMeeting, shared_phrase_buf);
+			Response (we_are_from_alliance, DoFirstMeeting);
 			break;
-		}
 		case 1:
 			Response (how_know, DoFirstMeeting);
 			break;
@@ -1771,7 +1712,7 @@ DoFirstMeeting (RESPONSE_REF R)
 		}
 		SET_GAME_STATE (MELNORME_BUSINESS_COUNT, business_count);
 	}
-	else if (PLAYER_SAID (R, we_are_from_alliance0))
+	else if (PLAYER_SAID (R, we_are_from_alliance))
 	{
 		SET_GAME_STATE (MELNORME_YACK_STACK0, 1);
 		NPCPhrase (KNOW_OF_YOU);
@@ -1824,7 +1765,6 @@ DoFirstMeeting (RESPONSE_REF R)
 		}
 		else if (RESOLUTION_FACTOR > 0)
 		{
-			LockMutex (GraphicsLock);
 	
 			CommData.AlienAmbientArray[10].AnimFlags &= ~ANIM_DISABLED;
 			CommData.AlienAmbientArray[2].AnimFlags &= ~ANIM_DISABLED;
@@ -1837,14 +1777,11 @@ DoFirstMeeting (RESPONSE_REF R)
 			CommData.AlienAmbientArray[9].AnimFlags |= ANIM_DISABLED;
 			
 			CommData.AlienFrame = SetAbsFrameIndex (CommData.AlienFrame, 0);
-			
-			UnlockMutex (GraphicsLock);
 		}
 	}
 	else if (PLAYER_SAID (R, we_apologize))
 	{
 		SET_GAME_STATE (MELNORME_ANGER, 0);
-		
 		NPCPhrase (APOLOGY_ACCEPTED);
 		AlienTalkSegue ((COUNT)~0);
 		
@@ -1856,7 +1793,6 @@ DoFirstMeeting (RESPONSE_REF R)
 		}
 		else if (RESOLUTION_FACTOR > 0)
 		{
-			LockMutex (GraphicsLock);
 			
 			CommData.AlienAmbientArray[10].AnimFlags &= ~ANIM_DISABLED;	
 			CommData.AlienAmbientArray[2].AnimFlags &= ~ANIM_DISABLED;
@@ -1870,10 +1806,7 @@ DoFirstMeeting (RESPONSE_REF R)
 			
 			CommData.AlienFrame = SetAbsFrameIndex (CommData.AlienFrame, 0);
 			
-			UnlockMutex (GraphicsLock);
 		}
-
-		NPCPhrase (APOLOGY_ACCEPTED);
 	}
 
 	temp_func = stack_func[0];
@@ -1913,12 +1846,11 @@ DoMelnormeMiffed (RESPONSE_REF R)
 		if (RESOLUTION_FACTOR == 0)
 		{
 			XFormColorMap (GetColorMapAddress (
-				SetAbsColorMapIndex (CommData.AlienColorMap, 2)
-				), ONE_SECOND / 2);
+ 				SetAbsColorMapIndex (CommData.AlienColorMap, 2)
+ 				), ONE_SECOND / 2);
 		}
 		else if (RESOLUTION_FACTOR > 0)
 		{
-			LockMutex (GraphicsLock);
 			
 			CommData.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
 			CommData.AlienAmbientArray[3].AnimFlags |= ANIM_DISABLED;
@@ -1930,8 +1862,6 @@ DoMelnormeMiffed (RESPONSE_REF R)
 			CommData.AlienAmbientArray[9].AnimFlags &= ~ANIM_DISABLED;
 			
 			CommData.AlienFrame = SetAbsFrameIndex (CommData.AlienFrame, 48);
-			
-			UnlockMutex (GraphicsLock);
 		}
 	}
 	else if (PLAYER_SAID (R, explore_relationship))
@@ -2007,12 +1937,11 @@ DoMelnormePissed (RESPONSE_REF R)
 		if (RESOLUTION_FACTOR == 0)
 		{
 			XFormColorMap (GetColorMapAddress (
-				SetAbsColorMapIndex (CommData.AlienColorMap, 2)
-				), ONE_SECOND / 2);
+ 				SetAbsColorMapIndex (CommData.AlienColorMap, 2)
+ 				), ONE_SECOND / 2);
 		}
 		else if (RESOLUTION_FACTOR > 0)
 		{
-			LockMutex (GraphicsLock);
 			
 			CommData.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
 			CommData.AlienAmbientArray[3].AnimFlags |= ANIM_DISABLED;
@@ -2024,8 +1953,6 @@ DoMelnormePissed (RESPONSE_REF R)
 			CommData.AlienAmbientArray[9].AnimFlags &= ~ANIM_DISABLED;
 			
 			CommData.AlienFrame = SetAbsFrameIndex (CommData.AlienFrame, 48);
-			
-			UnlockMutex (GraphicsLock);
 		} 
 	}
 	else if (PLAYER_SAID (R, beg_forgiveness))
@@ -2084,12 +2011,11 @@ DoMelnormeHate (RESPONSE_REF R)
 	if (RESOLUTION_FACTOR == 0)
 	{
 		XFormColorMap (GetColorMapAddress (
-			SetAbsColorMapIndex (CommData.AlienColorMap, 2)
-			), ONE_SECOND / 2);
+ 			SetAbsColorMapIndex (CommData.AlienColorMap, 2)
+ 			), ONE_SECOND / 2);
 	}
 	else if (RESOLUTION_FACTOR > 0)
 	{
-		LockMutex (GraphicsLock);
 		
 		CommData.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
 		CommData.AlienAmbientArray[3].AnimFlags |= ANIM_DISABLED;
@@ -2101,8 +2027,6 @@ DoMelnormeHate (RESPONSE_REF R)
 		CommData.AlienAmbientArray[9].AnimFlags &= ~ANIM_DISABLED;
 
 		CommData.AlienFrame = SetAbsFrameIndex (CommData.AlienFrame, 48);
-		
-		UnlockMutex (GraphicsLock);
 	} 
 
 	Response (well_if_thats_the_way_you_feel, ExitConversation);
@@ -2145,47 +2069,38 @@ Intro (void)
 static COUNT
 uninit_melnorme (void)
 {
+	luaUqm_comm_uninit ();
 	return 0;
 }
 
 static void
 post_melnorme_enc (void)
 {
-	LockMutex (GraphicsLock);
 	if (prevMsgMode != SMM_UNDEFINED)
 		SetStatusMessageMode (prevMsgMode);
 	DrawStatusMessage (NULL);
-	UnlockMutex (GraphicsLock);
 }
 
 LOCDATA*
 init_melnorme_comm (void)
 {
 	static LOCDATA melnorme_desc;
-	LOCDATA *retval;
-	
-	switch (RESOLUTION_FACTOR)
-	{
-		case 2:
-			melnorme_desc = melnorme_desc_4x;
-			break;
-		case 1:
-			melnorme_desc = melnorme_desc_4x;
-			break;
-		case 0:
-		default:
-			melnorme_desc = melnorme_desc_1x;
-			break;
-	}
+ 	LOCDATA *retval;
+
+	melnorme_desc = (RESOLUTION_FACTOR == 0 ? melnorme_desc_1x : melnorme_desc_4x);
 
 	melnorme_desc.init_encounter_func = Intro;
 	melnorme_desc.post_encounter_func = post_melnorme_enc;
 	melnorme_desc.uninit_encounter_func = uninit_melnorme;
 
+	luaUqm_comm_init (NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	melnorme_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
 	melnorme_desc.AlienTextBaseline.y = 0;
-	melnorme_desc.AlienTextWidth = SIS_TEXT_WIDTH - (16 << RESOLUTION_FACTOR);
-	
+	melnorme_desc.AlienTextWidth = SIS_TEXT_WIDTH - RES_SCALE(16);
+
 	if (RESOLUTION_FACTOR > 0)
 	{
 		melnorme_desc.AlienAmbientArray[2].AnimFlags &= ~ANIM_DISABLED;
@@ -2204,9 +2119,8 @@ init_melnorme_comm (void)
 
 	prevMsgMode = SMM_UNDEFINED;
 
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 	AskedToBuy = FALSE;
-
 	retval = &melnorme_desc;
 
 	return (retval);
diff -ruNp src.hd/uqm/comm/melnorm/resinst.h src/uqm/comm/melnorm/resinst.h
--- src.hd/uqm/comm/melnorm/resinst.h	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/melnorm/resinst.h	2017-12-29 00:57:43 -0800
@@ -1,5 +1,10 @@
-#define MELNORME_PMAP_ANIM "comm.melnorme.graphics"
-#define MELNORME_FONT "comm.melnorme.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define MELNORME_COLOR_MAP "comm.melnorme.colortable"
 #define MELNORME_CONVERSATION_PHRASES "comm.melnorme.dialogue"
+#define MELNORME_FONT "comm.melnorme.font"
 #define MELNORME_MUSIC "comm.melnorme.music"
+#define MELNORME_PMAP_ANIM "comm.melnorme.graphics"
+#define MELNORME_SCRIPT "comm.melnorme.script"
diff -ruNp src.hd/uqm/comm/melnorm/strings.h src/uqm/comm/melnorm/strings.h
--- src.hd/uqm/comm/melnorm/strings.h	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/melnorm/strings.h	2017-12-29 00:57:43 -0800
@@ -254,7 +254,7 @@ enum
 	OK_BUY_NEW_TECH_13,
 	CHARITY,
 	NEW_TECH_ALL_GONE,
-	we_are_from_alliance0,
+	we_are_from_alliance,
 	STRIP_HEAD,
 	LANDERS,
 	THRUSTERS,
@@ -271,8 +271,7 @@ enum
 	name_1,
 	name_2,
 	name_3,
-	name_40,
-	name_41,
+	name_4,
 	ENUMERATE_ONE,
 	ENUMERATE_TWO,
 	ENUMERATE_THREE,
diff -ruNp src.hd/uqm/comm/mycon/Makeinfo src/uqm/comm/mycon/Makeinfo
--- src.hd/uqm/comm/mycon/Makeinfo	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/mycon/Makeinfo	2017-12-29 00:57:43 -0800
@@ -1 +1,2 @@
 uqm_CFILES="myconc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.hd/uqm/comm/mycon/myconc.c src/uqm/comm/mycon/myconc.c
--- src.hd/uqm/comm/mycon/myconc.c	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/mycon/myconc.c	2017-12-29 00:57:43 -0800
@@ -246,7 +246,7 @@ DoRamble (RESPONSE_REF R)
 static void
 CombatIsInevitable (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 1);
+	setSegue (Segue_hostile);
 
 	if (PLAYER_SAID (R, bye_space))
 		NPCPhrase (BYE_AND_DIE_SPACE);
@@ -258,7 +258,7 @@ CombatIsInevitable (RESPONSE_REF R)
 	{
 		NPCPhrase (GOODBYE_SUN_DEVICE);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
@@ -341,7 +341,7 @@ TrickMycon (RESPONSE_REF R)
 	{
 		NPCPhrase (WE_GO_TO_IMPLANT);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		SET_GAME_STATE (MYCON_FELL_FOR_AMBUSH, 1);
 		AddEvent (RELATIVE_EVENT, 0, 0, 0, ADVANCE_MYCON_MISSION);
 	}
@@ -372,7 +372,7 @@ NormalMycon (RESPONSE_REF R)
 		DoRamble (R);
 		NPCPhrase (RAMBLE_TAIL);
 
-		DISABLE_PHRASE (RESPONSE_TO_REF (R));
+		DISABLE_PHRASE (R);
 	}
 
 	if ((BYTE)TFB_Random () < 256 * 30 / 100)
@@ -506,13 +506,13 @@ Intro (void)
 		}
 		SET_GAME_STATE (MYCON_VISITS, NumVisits);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (GET_GAME_STATE (MYCON_KNOW_AMBUSH))
 	{
 		NPCPhrase (DIE_LIAR);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 6))
 	{
@@ -632,11 +632,11 @@ init_mycon_comm (void)
 
 	if (LOBYTE (GLOBAL (CurrentActivity)) != WON_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	retval = &mycon_desc;
 
diff -ruNp src.hd/uqm/comm/mycon/resinst.h src/uqm/comm/mycon/resinst.h
--- src.hd/uqm/comm/mycon/resinst.h	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/mycon/resinst.h	2017-12-29 00:57:43 -0800
@@ -1,5 +1,10 @@
-#define MYCON_PMAP_ANIM "comm.mycon.graphics"
-#define MYCON_FONT "comm.mycon.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define MYCON_COLOR_MAP "comm.mycon.colortable"
 #define MYCON_CONVERSATION_PHRASES "comm.mycon.dialogue"
+#define MYCON_FONT "comm.mycon.font"
 #define MYCON_MUSIC "comm.mycon.music"
+#define MYCON_PMAP_ANIM "comm.mycon.graphics"
+#define MYCON_SCRIPT "comm.mycon.script"
diff -ruNp src.hd/uqm/comm/orz/Makeinfo src/uqm/comm/orz/Makeinfo
--- src.hd/uqm/comm/orz/Makeinfo	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/orz/Makeinfo	2017-12-29 00:57:44 -0800
@@ -1 +1,2 @@
 uqm_CFILES="orzc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.hd/uqm/comm/orz/orzc.c src/uqm/comm/orz/orzc.c
--- src.hd/uqm/comm/orz/orzc.c	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/orz/orzc.c	2017-12-29 00:57:44 -0800
@@ -20,8 +20,8 @@
 #include "resinst.h"
 #include "strings.h"
 
+#include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
-
 #include "../../nameref.h"
 		//JMS_GFX: For LoadGraphic 
 
@@ -189,7 +189,7 @@ static LOCDATA orz_desc =
 static void
 ExitConversation (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 
 	if (PLAYER_SAID (R, bye_ally))
 		NPCPhrase (GOODBYE_ALLY);
@@ -208,7 +208,7 @@ ExitConversation (RESPONSE_REF R)
 	{
 		NPCPhrase (HOSTILITY_IS_BAD_2);
 		
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, may_we_land))
 	{
@@ -228,13 +228,13 @@ ExitConversation (RESPONSE_REF R)
 		SET_GAME_STATE (ORZ_GENERAL_INFO, 0);
 		SET_GAME_STATE (ORZ_PERSONAL_INFO, 0);
 		SET_GAME_STATE (ORZ_MANNER, 3);
-		ActivateStarShip (ORZ_SHIP, SET_ALLIED);
+		SetRaceAllied (ORZ_SHIP, TRUE);
 	}
 	else if (PLAYER_SAID (R, demand_to_land))
 	{
 		NPCPhrase (NO_DEMAND);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, about_andro_3)
 			|| PLAYER_SAID (R, must_know_about_androsyn))
@@ -250,12 +250,12 @@ ExitConversation (RESPONSE_REF R)
 			CommData.AlienFrameRes = ORZ_ANGRY_PMAP_ANIM;
 			CommData.AlienFrame = CaptureDrawable (LoadGraphic (CommData.AlienFrameRes));
 		}
-		
+
 		if (PLAYER_SAID (R, about_andro_3))
 			NPCPhrase (BLEW_IT);
 		else
 			NPCPhrase (KNOW_TOO_MUCH);
-		
+
 		// JMS_GFX: Use separate graphics in hires instead of colormap transform.
 		if (RESOLUTION_FACTOR > 0)
 		{
@@ -264,14 +264,14 @@ ExitConversation (RESPONSE_REF R)
 			for (ii = 0; ii < CommData.NumAnimations - 1; ii++)
 				CommData.AlienAmbientArray[ii].AnimFlags &= ~ANIM_DISABLED;
 		}
-		
+
 		SET_GAME_STATE (ORZ_VISITS, 0);
 		SET_GAME_STATE (ORZ_MANNER, 2);
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 		if (PLAYER_SAID (R, about_andro_3))
 		{
-			ActivateStarShip (ORZ_SHIP, SET_NOT_ALLIED);
-			ActivateStarShip (ORZ_SHIP, REMOVE_BUILT);
+			SetRaceAllied (ORZ_SHIP, FALSE);
+			RemoveEscortShips (ORZ_SHIP);
 		}
 
 		XFormColorMap (GetColorMapAddress (
@@ -293,13 +293,13 @@ ExitConversation (RESPONSE_REF R)
 				break;
 			case 2:
 				NPCPhrase (INSULTED_3);
-				SET_GAME_STATE (BATTLE_SEGUE, 1);
+				setSegue (Segue_hostile);
 				break;
 			case 7:
 				--NumVisits;
 			default:
 				NPCPhrase (INSULTED_4);
-				SET_GAME_STATE (BATTLE_SEGUE, 1);
+				setSegue (Segue_hostile);
 				break;
 		}
 		SET_GAME_STATE (ORZ_PERSONAL_INFO, NumVisits);
@@ -358,8 +358,7 @@ TaaloWorld (RESPONSE_REF R)
 
 	if (PHRASE_ENABLED (may_we_land))
 	{
-		if (Manner == 3 &&
-				ActivateStarShip (ORZ_SHIP, CHECK_ALLIANCE) == GOOD_GUY)
+		if (Manner == 3 && CheckAlliance (ORZ_SHIP) == GOOD_GUY)
 			Response (may_we_land, ExitConversation);
 		else
 			Response (may_we_land, TaaloWorld);
@@ -512,7 +511,7 @@ OrzNeutral (RESPONSE_REF R)
 		DISABLE_PHRASE (hostile_1);
 		LastStack = 2;
 	}
-	else if (PLAYER_SAID (R, we_are_vindicator0))
+	else if (PLAYER_SAID (R, we_are_vindicator))
 	{
 		NPCPhrase (NICE_TO_MEET_YOU);
 
@@ -577,14 +576,7 @@ OrzNeutral (RESPONSE_REF R)
 	}
 	else if (GET_GAME_STATE (ORZ_STACK0) == 0)
 	{
-		construct_response (shared_phrase_buf,
-				we_are_vindicator0,
-				GLOBAL_SIS (CommanderName),
-				we_are_vindicator1,
-				GLOBAL_SIS (ShipName),
-				we_are_vindicator2,
-				(UNICODE*)NULL);
-		pStr[1] = we_are_vindicator0;
+		pStr[1] = we_are_vindicator;
 	}
 	else
 		pStr[1] = seem_like_nice_guys;
@@ -594,21 +586,12 @@ OrzNeutral (RESPONSE_REF R)
 		pStr[2] = hostile_2;
 
 	if (pStr[LastStack])
-	{
-		if (pStr[LastStack] != we_are_vindicator0)
-			Response (pStr[LastStack], OrzNeutral);
-		else
-			DoResponsePhrase (pStr[LastStack], OrzNeutral, shared_phrase_buf);
-	}
+		Response (pStr[LastStack], OrzNeutral);
+
 	for (i = 0; i < 3; ++i)
 	{
 		if (i != LastStack && pStr[i])
-		{
-			if (pStr[i] != we_are_vindicator0)
-				Response (pStr[i], OrzNeutral);
-			else
-				DoResponsePhrase (pStr[i], OrzNeutral, shared_phrase_buf);
-		}
+			Response (pStr[i], OrzNeutral);
 	}
 	Response (bye_neutral, ExitConversation);
 }
@@ -680,7 +663,7 @@ Intro (void)
 	{
 		NPCPhrase (OUT_TAKES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
@@ -692,15 +675,14 @@ Intro (void)
 	{
 		CommData.AlienColorMap =
 				SetAbsColorMapIndex (CommData.AlienColorMap, 1);
-		
+
 		// JMS_GFX: Use separate red angry graphics in hires instead of colormap transform.
-		if (RESOLUTION_FACTOR > 0)
-		{
+		if (RESOLUTION_FACTOR > 0) {
 			CommData.AlienFrameRes = ORZ_ANGRY_PMAP_ANIM;
 			CommData.AlienFrame = CaptureDrawable (
 				LoadGraphic (CommData.AlienFrameRes));
 		}
-			
+
 		NumVisits = GET_GAME_STATE (ORZ_VISITS);
 		switch (NumVisits++)
 		{
@@ -714,7 +696,7 @@ Intro (void)
 		}
 		SET_GAME_STATE (ORZ_VISITS, NumVisits);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 6))
 	{
@@ -749,8 +731,7 @@ Intro (void)
 
 		TaaloWorld ((RESPONSE_REF)0);
 	}
-	else if (Manner == 3 &&
-			ActivateStarShip (ORZ_SHIP, CHECK_ALLIANCE) == GOOD_GUY)
+	else if (Manner == 3 && CheckAlliance (ORZ_SHIP) == GOOD_GUY)
 	{
 		if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 7))
 		{
@@ -895,6 +876,7 @@ Intro (void)
 static COUNT
 uninit_orz (void)
 {
+	luaUqm_comm_uninit();
 	return (0);
 }
 
@@ -903,7 +885,7 @@ post_orz_enc (void)
 {
 	BYTE Manner;
 
-	if (GET_GAME_STATE (BATTLE_SEGUE) == 1
+	if (getSegue () == Segue_hostile
 			&& (Manner = GET_GAME_STATE (ORZ_MANNER)) != 2)
 	{
 		SET_GAME_STATE (ORZ_MANNER, 1);
@@ -925,6 +907,10 @@ init_orz_comm (void)
 	orz_desc.post_encounter_func = post_orz_enc;
 	orz_desc.uninit_encounter_func = uninit_orz;
 
+	luaUqm_comm_init(NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	orz_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
 	orz_desc.AlienTextBaseline.y = 0;
 	orz_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
@@ -932,13 +918,14 @@ init_orz_comm (void)
 	if (GET_GAME_STATE (ORZ_MANNER) == 3
 			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	retval = &orz_desc;
 
 	return (retval);
 }
+
diff -ruNp src.hd/uqm/comm/orz/resinst.h src/uqm/comm/orz/resinst.h
--- src.hd/uqm/comm/orz/resinst.h	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/orz/resinst.h	2017-12-29 00:57:44 -0800
@@ -1,6 +1,11 @@
-#define ORZ_PMAP_ANIM "comm.orz.graphics"
-#define ORZ_ANGRY_PMAP_ANIM "comm.orz.angry.graphics"
-#define ORZ_FONT "comm.orz.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define ORZ_COLOR_MAP "comm.orz.colortable"
 #define ORZ_CONVERSATION_PHRASES "comm.orz.dialogue"
+#define ORZ_FONT "comm.orz.font"
 #define ORZ_MUSIC "comm.orz.music"
+#define ORZ_PMAP_ANIM "comm.orz.graphics"
+#define ORZ_ANGRY_PMAP_ANIM "comm.orz.angry.graphics"
+#define ORZ_SCRIPT "comm.orz.script"
diff -ruNp src.hd/uqm/comm/orz/strings.h src/uqm/comm/orz/strings.h
--- src.hd/uqm/comm/orz/strings.h	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/orz/strings.h	2017-12-29 00:57:44 -0800
@@ -69,9 +69,7 @@ enum
 	HOSTILITY_IS_BAD_1,
 	hostile_2,
 	HOSTILITY_IS_BAD_2,
-	we_are_vindicator0,
-	we_are_vindicator1,
-	we_are_vindicator2,
+	we_are_vindicator,
 	NICE_TO_MEET_YOU,
 	seem_like_nice_guys,
 	ARE_NICE_WANT_ALLY,
diff -ruNp src.hd/uqm/comm/pkunk/Makeinfo src/uqm/comm/pkunk/Makeinfo
--- src.hd/uqm/comm/pkunk/Makeinfo	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/pkunk/Makeinfo	2017-12-29 00:57:44 -0800
@@ -1 +1,2 @@
 uqm_CFILES="pkunkc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.hd/uqm/comm/pkunk/pkunkc.c src/uqm/comm/pkunk/pkunkc.c
--- src.hd/uqm/comm/pkunk/pkunkc.c	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/pkunk/pkunkc.c	2017-12-29 00:57:44 -0800
@@ -20,6 +20,7 @@
 #include "resinst.h"
 #include "strings.h"
 
+#include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
 #include "uqm/gameev.h"
 
@@ -111,7 +112,7 @@ static void
 PrepareShip (void)
 {
 #define MAX_PKUNK_SHIPS 4
-	if (ActivateStarShip (PKUNK_SHIP, MAX_PKUNK_SHIPS))
+	if (AddEscortShips (PKUNK_SHIP, MAX_PKUNK_SHIPS))
 	{
 		BYTE mi, di, yi;
 
@@ -133,7 +134,7 @@ PrepareShip (void)
 static void
 ExitConversation (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 
 	if (PLAYER_SAID (R, friendly_bye_space))
 		NPCPhrase (FRIENDLY_GOODBYE_SPACE);
@@ -158,7 +159,7 @@ ExitConversation (RESPONSE_REF R)
 		SET_GAME_STATE (PKUNK_INFO, 0);
 
 		AddEvent (RELATIVE_EVENT, 6, 0, 0, ADVANCE_PKUNK_MISSION);
-		if (ActivateStarShip (PKUNK_SHIP, FEASIBILITY_STUDY) == 0)
+		if (EscortFeasibilityStudy (PKUNK_SHIP) == 0)
 			NPCPhrase (INIT_NO_ROOM);
 		else
 		{
@@ -188,13 +189,13 @@ ExitConversation (RESPONSE_REF R)
 
 			SET_GAME_STATE (PKUNK_MANNER, 2);
 		}
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, die_idiot_fools))
 	{
 		NPCPhrase (VERY_WELL);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, suit_yourself))
 		NPCPhrase (GOODBYE_MIGRATION);
@@ -325,7 +326,7 @@ DiscussConquer (RESPONSE_REF R)
 static void
 OfferAlliance (RESPONSE_REF R)
 {
-	if (PLAYER_SAID (R, we_are_vindicator0))
+	if (PLAYER_SAID (R, we_are_vindicator))
 		NPCPhrase (WHY_YOU_HERE);
 	else if (PLAYER_SAID (R, exploring_universe))
 	{
@@ -622,14 +623,7 @@ PkunkHome (RESPONSE_REF R)
 	}
 	if (!GET_GAME_STATE (PKUNK_SHIP_MONTH))
 	{
-		construct_response (shared_phrase_buf,
-				we_are_vindicator0,
-				GLOBAL_SIS (CommanderName),
-				we_are_vindicator1,
-				GLOBAL_SIS (ShipName),
-				we_are_vindicator2,
-				(UNICODE*)NULL);
-		DoResponsePhrase (we_are_vindicator0, OfferAlliance, shared_phrase_buf);
+		Response (we_are_vindicator, OfferAlliance);
 	}
 	if (PHRASE_ENABLED (what_about_you))
 	{
@@ -854,7 +848,7 @@ Intro (void)
 	{
 		NPCPhrase (OUT_TAKES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
@@ -881,7 +875,7 @@ Intro (void)
 		}
 		SET_GAME_STATE (PKUNK_VISITS, NumVisits);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (Manner == 1)
 	{
@@ -950,7 +944,7 @@ Intro (void)
 		{
 			if (NumVisits && ShipsReady ())
 			{
-				if (ActivateStarShip (PKUNK_SHIP, FEASIBILITY_STUDY) == 0)
+				if (EscortFeasibilityStudy (PKUNK_SHIP) == 0)
 					NPCPhrase (NO_ROOM);
 				else
 				{
@@ -1097,6 +1091,7 @@ Intro (void)
 static COUNT
 uninit_pkunk (void)
 {
+	luaUqm_comm_uninit();
 	return (0);
 }
 
@@ -1105,7 +1100,7 @@ post_pkunk_enc (void)
 {
 	BYTE Manner;
 
-	if (GET_GAME_STATE (BATTLE_SEGUE) == 1
+	if (getSegue () == Segue_hostile
 			&& (Manner = GET_GAME_STATE (PKUNK_MANNER)) != 2)
 	{
 		SET_GAME_STATE (PKUNK_MANNER, 1);
@@ -1126,6 +1121,10 @@ init_pkunk_comm (void)
 	pkunk_desc.post_encounter_func = post_pkunk_enc;
 	pkunk_desc.uninit_encounter_func = uninit_pkunk;
 
+	luaUqm_comm_init(NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	pkunk_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
 	pkunk_desc.AlienTextBaseline.y = 0;
 	pkunk_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
@@ -1134,12 +1133,12 @@ init_pkunk_comm (void)
 			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 	{
 		// Enter communications immediately.
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
 		// Ask the player whether to attack or talk.
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	retval = &pkunk_desc;
 
diff -ruNp src.hd/uqm/comm/pkunk/resinst.h src/uqm/comm/pkunk/resinst.h
--- src.hd/uqm/comm/pkunk/resinst.h	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/pkunk/resinst.h	2017-12-29 00:57:44 -0800
@@ -1,5 +1,10 @@
-#define PKUNK_PMAP_ANIM "comm.pkunk.graphics"
-#define PKUNK_FONT "comm.pkunk.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define PKUNK_COLOR_MAP "comm.pkunk.colortable"
 #define PKUNK_CONVERSATION_PHRASES "comm.pkunk.dialogue"
+#define PKUNK_FONT "comm.pkunk.font"
 #define PKUNK_MUSIC "comm.pkunk.music"
+#define PKUNK_PMAP_ANIM "comm.pkunk.graphics"
+#define PKUNK_SCRIPT "comm.pkunk.script"
diff -ruNp src.hd/uqm/comm/pkunk/strings.h src/uqm/comm/pkunk/strings.h
--- src.hd/uqm/comm/pkunk/strings.h	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/pkunk/strings.h	2017-12-29 00:57:44 -0800
@@ -112,9 +112,7 @@ enum
 	BAD_IDEA,
 	no_conquest,
 	GOOD_IDEA,
-	we_are_vindicator0,
-	we_are_vindicator1,
-	we_are_vindicator2,
+	we_are_vindicator,
 	WHY_YOU_HERE,
 	we_here_to_help,
 	NEED_HELP,
diff -ruNp src.hd/uqm/comm/rebel/Makeinfo src/uqm/comm/rebel/Makeinfo
--- src.hd/uqm/comm/rebel/Makeinfo	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/rebel/Makeinfo	2017-12-29 00:57:44 -0800
@@ -1 +1,2 @@
 uqm_CFILES="rebel.c"
+uqm_HFILES="strings.h"
diff -ruNp src.hd/uqm/comm/rebel/rebel.c src/uqm/comm/rebel/rebel.c
--- src.hd/uqm/comm/rebel/rebel.c	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/rebel/rebel.c	2017-12-29 00:57:44 -0800
@@ -47,7 +47,8 @@ static LOCDATA yehat_desc_1x =
 		{ /* right hand-wing tapping keyboard; front guy */
 			4, /* StartIndex */
 			3, /* NumFrames */
-			YOYO_ANIM | WAIT_TALKING, /* AnimFlags */
+			YOYO_ANIM
+            | WAIT_TALKING, /* AnimFlags */
 			ONE_SECOND / 10, ONE_SECOND / 10, /* FrameRate */
 			ONE_SECOND / 4, ONE_SECOND / 2,/* RestartRate */
 			(1 << 6) | (1 << 7),
@@ -55,7 +56,8 @@ static LOCDATA yehat_desc_1x =
 		{ /* left hand-wing tapping keyboard; front guy */
 			7, /* StartIndex */
 			3, /* NumFrames */
-			YOYO_ANIM | WAIT_TALKING, /* AnimFlags */
+			YOYO_ANIM
+            | WAIT_TALKING, /* AnimFlags */
 			ONE_SECOND / 10, ONE_SECOND / 10, /* FrameRate */
 			ONE_SECOND / 4, ONE_SECOND / 2,/* RestartRate */
 			(1 << 6) | (1 << 7),
@@ -188,6 +190,7 @@ static LOCDATA yehat_desc_1x =
 	NULL,
 };
 
+
 static LOCDATA yehat_desc_2x =
 {
 	YEHAT_REBEL_CONVERSATION, /* AlienConv */
@@ -622,7 +625,7 @@ Rebels (RESPONSE_REF R)
 			|| ((NumVisits == 0 && (NumVisits = GLOBAL (GameClock.month_index) - GET_GAME_STATE (YEHAT_SHIP_MONTH)) < 0) 
 			    || (NumVisits == 0 && GLOBAL (GameClock.day_index) < GET_GAME_STATE (YEHAT_SHIP_DAY)))))
 			NPCPhrase (NO_SHIPS_YET);
-		else if ((NumVisits = ActivateStarShip (YEHAT_SHIP, FEASIBILITY_STUDY)) == 0)
+		else if ((NumVisits = EscortFeasibilityStudy (YEHAT_SHIP)) == 0)
 			NPCPhrase (NO_ROOM);
 		else
 		{
@@ -636,7 +639,7 @@ Rebels (RESPONSE_REF R)
 			}
 
 			AlienTalkSegue ((COUNT)~0);
-			ActivateStarShip (YEHAT_SHIP, NumVisits);
+			AddEscortShips (YEHAT_SHIP, NumVisits);
 			PrepareShip ();
 		}
 
@@ -674,18 +677,17 @@ Intro (void)
 {
 	BYTE NumVisits;
 
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_LAST_BATTLE)
 	{
 		NPCPhrase (YEHAT_CAVALRY);
 		AlienTalkSegue ((COUNT)~0);
 
-		if ((NumVisits = (BYTE)ActivateStarShip (
-				YEHAT_REBEL_SHIP, FEASIBILITY_STUDY
-				)) > 8)
+		NumVisits = (BYTE) EscortFeasibilityStudy (YEHAT_REBEL_SHIP);
+		if (NumVisits > 8)
 			NumVisits = 8;
-		ActivateStarShip (YEHAT_REBEL_SHIP, NumVisits - (NumVisits >> 1));
-		ActivateStarShip (PKUNK_SHIP, NumVisits >> 1);
+		AddEscortShips (YEHAT_REBEL_SHIP, NumVisits - (NumVisits >> 1));
+		AddEscortShips (PKUNK_SHIP, NumVisits >> 1);
 	}
 	else
 	{
@@ -730,18 +732,7 @@ init_rebel_yehat_comm (void)
 	static LOCDATA yehat_desc;
 	LOCDATA *retval;
 
-	switch (RESOLUTION_FACTOR) {
-		case 2:
-			yehat_desc = yehat_desc_4x;
-			break;
-		case 1:
-			yehat_desc = yehat_desc_2x;
-			break;
-		case 0:
-		default:
-			yehat_desc = yehat_desc_1x;
-			break;
-	}
+	yehat_desc = (RESOLUTION_FACTOR == 0 ? yehat_desc_1x : (RESOLUTION_FACTOR == 1 ? yehat_desc_2x : yehat_desc_4x));
 
 	yehat_desc.init_encounter_func = Intro;
 	yehat_desc.post_encounter_func = post_yehat_enc;
@@ -755,7 +746,7 @@ init_rebel_yehat_comm (void)
 	yehat_desc.AlienAltSongRes = REBEL_MUSIC;
 	yehat_desc.AlienSongFlags |= LDASF_USE_ALTERNATE;
 
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 	retval = &yehat_desc;
 
 	return (retval);
diff -ruNp src.hd/uqm/comm/shofixt/Makeinfo src/uqm/comm/shofixt/Makeinfo
--- src.hd/uqm/comm/shofixt/Makeinfo	2017-12-29 02:25:51 -0800
+++ src/uqm/comm/shofixt/Makeinfo	2017-12-29 00:57:44 -0800
@@ -1 +1,2 @@
 uqm_CFILES="shofixt.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.hd/uqm/comm/shofixt/resinst.h src/uqm/comm/shofixt/resinst.h
--- src.hd/uqm/comm/shofixt/resinst.h	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/shofixt/resinst.h	2017-12-29 00:57:44 -0800
@@ -1,5 +1,10 @@
-#define SHOFIXTI_PMAP_ANIM "comm.shofixti.graphics"
-#define SHOFIXTI_FONT "comm.shofixti.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SHOFIXTI_COLOR_MAP "comm.shofixti.colortable"
 #define SHOFIXTI_CONVERSATION_PHRASES "comm.shofixti.dialogue"
+#define SHOFIXTI_FONT "comm.shofixti.font"
 #define SHOFIXTI_MUSIC "comm.shofixti.music"
+#define SHOFIXTI_PMAP_ANIM "comm.shofixti.graphics"
+#define SHOFIXTI_SCRIPT "comm.shofixti.script"
diff -ruNp src.hd/uqm/comm/shofixt/shofixt.c src/uqm/comm/shofixt/shofixt.c
--- src.hd/uqm/comm/shofixt/shofixt.c	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/shofixt/shofixt.c	2017-12-29 00:57:44 -0800
@@ -20,6 +20,7 @@
 #include "resinst.h"
 #include "strings.h"
 
+#include "uqm/lua/luacomm.h"
 #include "uqm/gameev.h"
 
 
@@ -290,25 +291,25 @@ GetShofixtiName (void)
 static void
 ExitConversation (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 1);
+	setSegue (Segue_hostile);
 
 	if (PLAYER_SAID (R, bye0))
 	{
 		NPCPhrase (GOODBYE);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else if (PLAYER_SAID (R, go_ahead))
 	{
 		NPCPhrase (ON_SECOND_THOUGHT);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else if (PLAYER_SAID (R, need_you_for_duty))
 	{
 		NPCPhrase (OK_WILL_BE_SENTRY);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else if (PLAYER_SAID (R, females)
 			|| PLAYER_SAID (R, nubiles)
@@ -318,7 +319,7 @@ ExitConversation (RESPONSE_REF R)
 
 		SET_GAME_STATE (SHOFIXTI_RECRUITED, 1);
 		SET_GAME_STATE (MAIDENS_ON_SHIP, 0);
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 
 		AddEvent (RELATIVE_EVENT, 2, 0, 0, SHOFIXTI_RETURN_EVENT);
 	}
@@ -446,7 +447,7 @@ ExplainDefeat (RESPONSE_REF R)
 		NPCPhrase (MUST_UNDERSTAND);
 	else if (PLAYER_SAID (R, i_am_guy))
 		NPCPhrase (NICE_BUT_WHAT_IS_DONKEY);
-	else /* if (PLAYER_SAID (R, i_am_captain0)) */
+	else /* if (PLAYER_SAID (R, i_am_captain)) */
 		NPCPhrase (SO_SORRY);
 	NPCPhrase (IS_DEFEAT_TRUE);
 
@@ -464,22 +465,7 @@ RealizeMistake (RESPONSE_REF R)
 	SET_GAME_STATE (SHOFIXTI_STACK3, 0);
 	SET_GAME_STATE (SHOFIXTI_STACK2, 3);
 
-	{
-		UNICODE buf[ALLIANCE_NAME_BUFSIZE];
-
-		GetAllianceName (buf, name_1);
-		construct_response (
-				shared_phrase_buf,
-				i_am_captain0,
-				GLOBAL_SIS (CommanderName),
-				i_am_captain1,
-				buf,
-				i_am_captain2,
-				GLOBAL_SIS (ShipName),
-				i_am_captain3,
-				(UNICODE*)NULL);
-	}
-	DoResponsePhrase (i_am_captain0, ExplainDefeat, shared_phrase_buf);
+	Response (i_am_captain, ExplainDefeat);
 	Response (i_am_nice, ExplainDefeat);
 	Response (i_am_guy, ExplainDefeat);
 }
@@ -666,7 +652,7 @@ Intro (void)
 	{
 		NPCPhrase (OUT_TAKES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
@@ -742,6 +728,7 @@ Intro (void)
 static COUNT
 uninit_shofixti (void)
 {
+	luaUqm_comm_uninit ();
 	return(0);
 }
 
@@ -755,31 +742,23 @@ LOCDATA*
 init_shofixti_comm (void)
 {
 	static LOCDATA shofixti_desc;
-	LOCDATA *retval;
+ 	LOCDATA *retval;
 	
-	switch (RESOLUTION_FACTOR)
-	{
-		case 2:
-			shofixti_desc = shofixti_desc_4x;
-			break;
-		case 1:
-			shofixti_desc = shofixti_desc_4x;
-			break;
-		case 0:
-		default:
-			shofixti_desc = shofixti_desc_1x;
-			break;
-	}
+	shofixti_desc = (RESOLUTION_FACTOR == 0 ? shofixti_desc_1x : shofixti_desc_4x);
 
 	shofixti_desc.init_encounter_func = Intro;
 	shofixti_desc.post_encounter_func = post_shofixti_enc;
 	shofixti_desc.uninit_encounter_func = uninit_shofixti;
 
+	luaUqm_comm_init (NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	shofixti_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
 	shofixti_desc.AlienTextBaseline.y = 0;
 	shofixti_desc.AlienTextWidth = SIS_TEXT_WIDTH;
 
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 
 	retval = &shofixti_desc;
 
diff -ruNp src.hd/uqm/comm/shofixt/strings.h src/uqm/comm/shofixt/strings.h
--- src.hd/uqm/comm/shofixt/strings.h	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/shofixt/strings.h	2017-12-29 00:57:44 -0800
@@ -25,8 +25,7 @@ enum
 	name_1,
 	name_2,
 	name_3,
-	name_40,
-	name_41,
+	name_4,
 	tanaka,
 	katana,
 	HOSTILE_KATANA_1,
@@ -65,10 +64,7 @@ enum
 	HANG_YOUR,
 	donkey_breath,
 	DGRUNTI,
-	i_am_captain0,
-	i_am_captain1,
-	i_am_captain2,
-	i_am_captain3,
+	i_am_captain,
 	i_am_nice,
 	i_am_guy,
 	SO_SORRY,
diff -ruNp src.hd/uqm/comm/slyhome/Makeinfo src/uqm/comm/slyhome/Makeinfo
--- src.hd/uqm/comm/slyhome/Makeinfo	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/slyhome/Makeinfo	2017-12-29 00:57:44 -0800
@@ -1 +1,2 @@
 uqm_CFILES="slyhome.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.hd/uqm/comm/slyhome/resinst.h src/uqm/comm/slyhome/resinst.h
--- src.hd/uqm/comm/slyhome/resinst.h	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/slyhome/resinst.h	2017-12-29 00:57:44 -0800
@@ -1,5 +1,10 @@
-#define SLYLANDRO_PMAP_ANIM "comm.slylandro.graphics"
-#define SLYLANDRO_FONT "comm.slylandro.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SLYLANDRO_COLOR_MAP "comm.slylandro.colortable"
 #define SLYLANDRO_CONVERSATION_PHRASES "comm.slylandro.dialogue"
+#define SLYLANDRO_FONT "comm.slylandro.font"
 #define SLYLANDRO_MUSIC "comm.slylandro.music"
+#define SLYLANDRO_PMAP_ANIM "comm.slylandro.graphics"
+#define SLYLANDRO_SCRIPT "comm.slylandro.script"
diff -ruNp src.hd/uqm/comm/slyhome/slyhome.c src/uqm/comm/slyhome/slyhome.c
--- src.hd/uqm/comm/slyhome/slyhome.c	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/slyhome/slyhome.c	2017-12-29 00:57:44 -0800
@@ -20,6 +20,7 @@
 #include "resinst.h"
 #include "strings.h"
 
+#include "uqm/lua/luacomm.h"
 #include "uqm/gameev.h"
 
 
@@ -176,7 +177,7 @@ static void
 ExitConversation (RESPONSE_REF R)
 {
 	(void) R;  // ignored
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 
 	switch (GET_GAME_STATE (SLYLANDRO_HOME_VISITS))
 	{
@@ -659,12 +660,12 @@ HomeWorld (RESPONSE_REF R)
 
 	LastStack = 0;
 	pStr[0] = pStr[1] = pStr[2] = 0;
-	if (PLAYER_SAID (R, we_are_us0))
+	if (PLAYER_SAID (R, we_are_us))
 	{
 		NPCPhrase (TERRIBLY_EXCITING);
 
 		SET_GAME_STATE (SLYLANDRO_STACK1, 1);
-		DISABLE_PHRASE (we_are_us0);
+		DISABLE_PHRASE (we_are_us);
 	}
 	else if (PLAYER_SAID (R, what_other_visitors))
 	{
@@ -756,14 +757,7 @@ HomeWorld (RESPONSE_REF R)
 	switch (GET_GAME_STATE (SLYLANDRO_STACK1))
 	{
 		case 0:
-			construct_response (shared_phrase_buf,
-					we_are_us0,
-					GLOBAL_SIS (CommanderName),
-					we_are_us1,
-					GLOBAL_SIS (ShipName),
-					we_are_us2,
-					(UNICODE*)NULL);
-			pStr[0] = we_are_us0;
+			pStr[0] = we_are_us;
 			break;
 		case 1:
 			pStr[0] = what_other_visitors;
@@ -808,21 +802,11 @@ HomeWorld (RESPONSE_REF R)
 	}
 
 	if (pStr[LastStack])
-	{
-		if (pStr[LastStack] != we_are_us0)
-			Response (pStr[LastStack], HomeWorld);
-		else
-			DoResponsePhrase (pStr[LastStack], HomeWorld, shared_phrase_buf);
-	}
+		Response (pStr[LastStack], HomeWorld);
 	for (i = 0; i < 3; ++i)
 	{
 		if (i != LastStack && pStr[i])
-		{
-			if (pStr[i] != we_are_us0)
-				Response (pStr[i], HomeWorld);
-			else
-				DoResponsePhrase (pStr[i], HomeWorld, shared_phrase_buf);
-		}
+			Response (pStr[i], HomeWorld);
 	}
 	if (GET_GAME_STATE (SLYLANDRO_STACK1))
 	{
@@ -893,6 +877,7 @@ Intro (void)
 static COUNT
 uninit_slylandro (void)
 {
+	luaUqm_comm_uninit ();
 	return (0);
 }
 
@@ -911,11 +896,15 @@ init_slylandro_comm (void)
 	slylandro_desc.post_encounter_func = post_slylandro_enc;
 	slylandro_desc.uninit_encounter_func = uninit_slylandro;
 
+	luaUqm_comm_init (NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	slylandro_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
 	slylandro_desc.AlienTextBaseline.y = 0;
 	slylandro_desc.AlienTextWidth = SIS_TEXT_WIDTH;
 
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 	retval = &slylandro_desc;
 
 	return (retval);
diff -ruNp src.hd/uqm/comm/slyhome/strings.h src/uqm/comm/slyhome/strings.h
--- src.hd/uqm/comm/slyhome/strings.h	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/slyhome/strings.h	2017-12-29 00:57:44 -0800
@@ -27,9 +27,7 @@ enum
 	HELLO_3,
 	HELLO_4,
 	RECALL_PROGRAM_1,
-	we_are_us0,
-	we_are_us1,
-	we_are_us2,
+	we_are_us,
 	TERRIBLY_EXCITING,
 	happy_to_tell_more,
 	TELL_MORE,
diff -ruNp src.hd/uqm/comm/slyland/Makeinfo src/uqm/comm/slyland/Makeinfo
--- src.hd/uqm/comm/slyland/Makeinfo	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/slyland/Makeinfo	2017-12-29 00:57:44 -0800
@@ -1 +1,2 @@
 uqm_CFILES="slyland.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.hd/uqm/comm/slyland/resinst.h src/uqm/comm/slyland/resinst.h
--- src.hd/uqm/comm/slyland/resinst.h	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/slyland/resinst.h	2017-12-29 00:57:44 -0800
@@ -1,5 +1,10 @@
-#define SLYLAND_PMAP_ANIM "comm.probe.graphics"
-#define SLYLAND_FONT "comm.probe.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SLYLAND_COLOR_MAP "comm.probe.colortable"
 #define SLYLAND_CONVERSATION_PHRASES "comm.probe.dialogue"
+#define SLYLAND_FONT "comm.probe.font"
 #define SLYLAND_MUSIC "comm.probe.music"
+#define SLYLAND_PMAP_ANIM "comm.probe.graphics"
+#define SLYLAND_SCRIPT "comm.probe.script"
diff -ruNp src.hd/uqm/comm/slyland/slyland.c src/uqm/comm/slyland/slyland.c
--- src.hd/uqm/comm/slyland/slyland.c	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/slyland/slyland.c	2017-12-29 00:57:44 -0800
@@ -315,8 +315,7 @@ CombatIsInevitable (RESPONSE_REF R)
 	else if (PLAYER_SAID (R, destruct_code))
 	{
 		NPCPhrase (DESTRUCT_SEQUENCE);
-		instantVictory = TRUE;
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_victory);
 	}
 	else
 	{
@@ -387,8 +386,8 @@ CombatIsInevitable (RESPONSE_REF R)
 					dy = 9812 - LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
 
 					NPCPhrase (THIS_IS_PROBE_40);
-					NPCPhrase (THIS_IS_PROBE_41);
 					sayCoord (dy);
+					NPCPhrase_splice (THIS_IS_PROBE_41);
 					sayCoord (dx);
 					NPCPhrase (THIS_IS_PROBE_42);
 
@@ -444,7 +443,7 @@ CombatIsInevitable (RESPONSE_REF R)
 		NPCPhrase (HOSTILE);
 
 		SET_GAME_STATE (PROBE_EXHIBITED_BUG, 1);
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 }
 
@@ -512,7 +511,7 @@ init_slyland_comm (void)
 	slylandro_desc.AlienTextBaseline.y = 0;
 	slylandro_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
 
-	SET_GAME_STATE (BATTLE_SEGUE, 1);
+	setSegue (Segue_hostile);
 	retval = &slylandro_desc;
 
 	return (retval);
diff -ruNp src.hd/uqm/comm/spahome/Makeinfo src/uqm/comm/spahome/Makeinfo
--- src.hd/uqm/comm/spahome/Makeinfo	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/spahome/Makeinfo	2017-12-29 00:57:44 -0800
@@ -1 +1,2 @@
 uqm_CFILES="spahome.c"
+uqm_HFILES="strings.h"
diff -ruNp src.hd/uqm/comm/spahome/spahome.c src/uqm/comm/spahome/spahome.c
--- src.hd/uqm/comm/spahome/spahome.c	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/spahome/spahome.c	2017-12-29 00:57:44 -0800
@@ -20,6 +20,7 @@
 #include "../spathi/resinst.h"
 #include "strings.h"
 
+#include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
 #include "uqm/gameev.h"
 
@@ -359,24 +360,24 @@ static LOCDATA spahome_desc_4x =
 static void
 ExitConversation (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 	if (PLAYER_SAID (R, we_attack_again))
 	{
 		NPCPhrase (WE_FIGHT_AGAIN);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, surrender_or_die))
 	{
 		NPCPhrase (DEFEND_OURSELVES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
-	else if (PLAYER_SAID (R, we_are_vindicator0))
+	else if (PLAYER_SAID (R, we_are_vindicator))
 	{
 		NPCPhrase (NO_PASSWORD);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, gort_merenga)
 			|| PLAYER_SAID (R, guph_florp)
@@ -385,13 +386,13 @@ ExitConversation (RESPONSE_REF R)
 	{
 		NPCPhrase (WRONG_PASSWORD);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, screw_password))
 	{
 		NPCPhrase (NO_PASSWORD);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, bye_no_ally_offer))
 		NPCPhrase (GOODBYE_NO_ALLY_OFFER);
@@ -424,7 +425,7 @@ ExitConversation (RESPONSE_REF R)
 	{
 		NPCPhrase (DEPART_FOR_EARTH);
 
-		ActivateStarShip (SPATHI_SHIP, SET_ALLIED);
+		SetRaceAllied (SPATHI_SHIP, TRUE);
 		AddEvent (RELATIVE_EVENT, 6, 0, 0, SPATHI_SHIELD_EVENT);
 		SET_GAME_STATE (SPATHI_HOME_VISITS, 0);
 		SET_GAME_STATE (SPATHI_VISITS, 0);
@@ -754,15 +755,11 @@ AllianceOffer (RESPONSE_REF R)
 	if (PLAYER_SAID (R, misunderstanding))
 	{
 		NPCPhrase (JUST_MISUNDERSTANDING);
-		
-		if (RESOLUTION_FACTOR == 0)
-		{
+		if (RESOLUTION_FACTOR == 0){
 			XFormColorMap (GetColorMapAddress (
 					SetAbsColorMapIndex (CommData.AlienColorMap, 1)
 					), ONE_SECOND / 4);
-		}
-		else
-		{
+		} else {
 			COUNT i = 0;
 			COUNT limit = CommData.NumAnimations;
 			
@@ -947,15 +944,11 @@ SpathiCouncil (RESPONSE_REF R)
 	else if (PLAYER_SAID (R, good_password))
 	{
 		NPCPhrase (YES_GOOD_PASSWORD);
-		
-		if (RESOLUTION_FACTOR == 0)
-		{
+		if (RESOLUTION_FACTOR == 0) {
 			XFormColorMap (GetColorMapAddress (
 					SetAbsColorMapIndex (CommData.AlienColorMap, 1)
 					), ONE_SECOND / 4);
-		}
-		else
-		{
+		} else {
 			COUNT i = 0;
 			COUNT limit = CommData.NumAnimations;
 			
@@ -1028,7 +1021,7 @@ SpathiCouncil (RESPONSE_REF R)
 	{
 		if (PHRASE_ENABLED (spathi_on_pluto))
 			Response (spathi_on_pluto, SpathiCouncil);
-		else if (ActivateStarShip (SPATHI_SHIP, ESCORTING_FLAGSHIP))
+		else if (HaveEscortShip (SPATHI_SHIP))
 		{
 			if (PHRASE_ENABLED (hostage))
 				Response (hostage, SpathiCouncil);
@@ -1088,14 +1081,7 @@ SpathiPassword (RESPONSE_REF R)
 	}
 	else
 	{
-		construct_response (shared_phrase_buf,
-				we_are_vindicator0,
-				GLOBAL_SIS (CommanderName),
-				we_are_vindicator1,
-				GLOBAL_SIS (ShipName),
-				we_are_vindicator2,
-				(UNICODE*)NULL);
-		DoResponsePhrase (we_are_vindicator0, ExitConversation, shared_phrase_buf);
+		Response (we_are_vindicator, ExitConversation);
 		Response (gort_merenga, ExitConversation);
 		Response (guph_florp, ExitConversation);
 		Response (wagngl_fthagn, ExitConversation);
@@ -1108,7 +1094,7 @@ static void
 Intro (void)
 {
 	BYTE Manner;
-	
+
 	if (RESOLUTION_FACTOR > 0)
 		CommData.AlienFrame = SetAbsFrameIndex 
 			(CommData.AlienFrame, 59);
@@ -1117,7 +1103,7 @@ Intro (void)
 	if (Manner == 2)
 	{
 		NPCPhrase (HATE_YOU_FOREVER);
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (Manner == 1
 			&& GET_GAME_STATE (KNOW_SPATHI_PASSWORD)
@@ -1126,15 +1112,12 @@ Intro (void)
 	{
 		SpathiAngry ((RESPONSE_REF)0);
 	}
-	else if (ActivateStarShip (SPATHI_SHIP, CHECK_ALLIANCE) == GOOD_GUY)
+	else if (CheckAlliance (SPATHI_SHIP) == GOOD_GUY)
 	{
-		if (RESOLUTION_FACTOR == 0)
-		{
+		if (RESOLUTION_FACTOR == 0) {
 			CommData.AlienColorMap =
-				SetAbsColorMapIndex (CommData.AlienColorMap, 1);
-		}
-		else
-		{
+ 				SetAbsColorMapIndex (CommData.AlienColorMap, 1);
+		} else {
 			COUNT i = 0;
 			COUNT limit = CommData.NumAnimations - 1;
 			
@@ -1146,18 +1129,14 @@ Intro (void)
 				
 			CommData.AlienTalkDesc.AnimFlags &= ~PAUSE_TALKING;
 		}
-		
 		SpathiAllies ((RESPONSE_REF)0);
 	}
 	else if (GET_GAME_STATE (SPATHI_PARTY))
 	{
-		if (RESOLUTION_FACTOR == 0)
-		{
+		if (RESOLUTION_FACTOR == 0){
 			CommData.AlienColorMap =
-				SetAbsColorMapIndex (CommData.AlienColorMap, 1);
-		}
-		else
-		{
+ 				SetAbsColorMapIndex (CommData.AlienColorMap, 1);
+		} else {
 			COUNT i = 0;
 			COUNT limit = CommData.NumAnimations - 1;
 			
@@ -1168,21 +1147,17 @@ Intro (void)
 				(CommData.AlienFrame, 0);
 				
 			CommData.AlienTalkDesc.AnimFlags &= ~PAUSE_TALKING;
-		}
-		
+		};
 		SpathiParty ((RESPONSE_REF)0);
 	}
 	else if (GET_GAME_STATE (SPATHI_QUEST))
 	{
 		if (GET_GAME_STATE (LIED_ABOUT_CREATURES) < 2)
 		{
-			if (RESOLUTION_FACTOR == 0)
-			{
+			if (RESOLUTION_FACTOR == 0) {
 				CommData.AlienColorMap =
-					SetAbsColorMapIndex (CommData.AlienColorMap, 1);
-			}
-			else
-			{
+ 					SetAbsColorMapIndex (CommData.AlienColorMap, 1);
+			} else {
 				COUNT i = 0;
 				COUNT limit = CommData.NumAnimations - 1;
 			
@@ -1194,7 +1169,6 @@ Intro (void)
 				
 				CommData.AlienTalkDesc.AnimFlags &= ~PAUSE_TALKING;
 			}
-		
 			SpathiQuest ((RESPONSE_REF)0);
 		}
 		else
@@ -1202,18 +1176,15 @@ Intro (void)
 			NPCPhrase (YOU_LIED_2);
 
 			SET_GAME_STATE (SPATHI_MANNER, 2);
-			SET_GAME_STATE (BATTLE_SEGUE, 1);
+			setSegue (Segue_hostile);
 		}
 	}
 	else if (GET_GAME_STATE (KNOW_SPATHI_QUEST))
 	{
-		if (RESOLUTION_FACTOR == 0)
-		{
+		if (RESOLUTION_FACTOR == 0) {
 			CommData.AlienColorMap =
-				SetAbsColorMapIndex (CommData.AlienColorMap, 1);
-		}
-		else
-		{
+ 				SetAbsColorMapIndex (CommData.AlienColorMap, 1);
+		} else {
 			COUNT i = 0;
 			COUNT limit = CommData.NumAnimations - 1;
 			
@@ -1225,20 +1196,16 @@ Intro (void)
 				
 			CommData.AlienTalkDesc.AnimFlags &= ~PAUSE_TALKING;
 		}
-		
 		LearnQuest ((RESPONSE_REF)0);
 	}
 	else if (GET_GAME_STATE (KNOW_SPATHI_PASSWORD)
 			&& (GET_GAME_STATE (FOUND_PLUTO_SPATHI)
 			|| GET_GAME_STATE (SPATHI_HOME_VISITS) != 7))
 	{
-		if (RESOLUTION_FACTOR == 0)
-		{
+		if (RESOLUTION_FACTOR == 0) {
 			CommData.AlienColorMap =
-				SetAbsColorMapIndex (CommData.AlienColorMap, 1);
-		}
-		else
-		{
+ 				SetAbsColorMapIndex (CommData.AlienColorMap, 1);
+		} else {
 			COUNT i = 0;
 			COUNT limit = CommData.NumAnimations - 1;
 			
@@ -1250,7 +1217,6 @@ Intro (void)
 				
 			CommData.AlienTalkDesc.AnimFlags &= ~PAUSE_TALKING;
 		}
-		
 		SpathiCouncil ((RESPONSE_REF)0);
 	}
 	else
@@ -1262,6 +1228,7 @@ Intro (void)
 static COUNT
 uninit_spahome (void)
 {
+	luaUqm_comm_uninit ();
 	return (0);
 }
 
@@ -1270,7 +1237,7 @@ post_spahome_enc (void)
 {
 	BYTE Manner;
 
-	if (GET_GAME_STATE (BATTLE_SEGUE) == 1
+	if (getSegue () == Segue_hostile
 			&& (Manner = GET_GAME_STATE (SPATHI_MANNER)) != 2)
 	{
 		SET_GAME_STATE (SPATHI_MANNER, 1);
@@ -1286,26 +1253,18 @@ LOCDATA*
 init_spahome_comm ()
 {
 	static LOCDATA spahome_desc;
-	LOCDATA *retval;
+ 	LOCDATA *retval;
 	
-	switch (RESOLUTION_FACTOR)
-	{
-		case 2:
-			spahome_desc = spahome_desc_4x;
-			break;
-		case 1:
-			spahome_desc = spahome_desc_4x;
-			break;
-		case 0:
-		default:
-			spahome_desc = spahome_desc_1x;
-			break;
-	}
+	spahome_desc = (RESOLUTION_FACTOR == 0 ? spahome_desc_1x : spahome_desc_4x);
 
 	spahome_desc.init_encounter_func = Intro;
 	spahome_desc.post_encounter_func = post_spahome_enc;
 	spahome_desc.uninit_encounter_func = uninit_spahome;
 
+	luaUqm_comm_init (NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	spahome_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
 	spahome_desc.AlienTextBaseline.y = 0;
 	spahome_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
@@ -1314,8 +1273,7 @@ init_spahome_comm ()
 	spahome_desc.AlienAltSongRes = SPAHOME_MUSIC;
 	spahome_desc.AlienSongFlags |= LDASF_USE_ALTERNATE;
 
-	if (RESOLUTION_FACTOR > 0)
-	{
+	if (RESOLUTION_FACTOR > 0) {
 		COUNT i;
 		COUNT limit = spahome_desc.NumAnimations;
 	
@@ -1327,11 +1285,11 @@ init_spahome_comm ()
 
 	if (GET_GAME_STATE (SPATHI_MANNER) == 3)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 
 	retval = &spahome_desc;
diff -ruNp src.hd/uqm/comm/spahome/strings.h src/uqm/comm/spahome/strings.h
--- src.hd/uqm/comm/spahome/strings.h	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/spahome/strings.h	2017-12-29 00:57:44 -0800
@@ -41,9 +41,7 @@ enum
 	HATE_YOU_FOREVER,
 	WHAT_IS_PASSWORD,
 	WHAT_IS_PASSWORD_AGAIN,
-	we_are_vindicator0,
-	we_are_vindicator1,
-	we_are_vindicator2,
+	we_are_vindicator,
 	gort_merenga,
 	guph_florp,
 	pleeese,
diff -ruNp src.hd/uqm/comm/spathi/Makeinfo src/uqm/comm/spathi/Makeinfo
--- src.hd/uqm/comm/spathi/Makeinfo	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/spathi/Makeinfo	2017-12-29 00:57:44 -0800
@@ -1 +1,2 @@
 uqm_CFILES="spathic.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.hd/uqm/comm/spathi/resinst.h src/uqm/comm/spathi/resinst.h
--- src.hd/uqm/comm/spathi/resinst.h	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/spathi/resinst.h	2017-12-29 00:57:44 -0800
@@ -1,10 +1,15 @@
-#define SPATHI_HOME_PMAP_ANIM "comm.safeones.graphics"
-#define SPATHI_PMAP_ANIM "comm.spathi.graphics"
-#define SPATHI_FONT "comm.spathi.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
+#define FWIFFO_MUSIC "comm.fwiffo.music"
+#define SPAHOME_MUSIC "comm.safeones.music"
 #define SPATHI_COLOR_MAP "comm.spathi.colortable"
 #define SPATHI_CONVERSATION_PHRASES "comm.spathi.dialogue"
+#define SPATHI_FONT "comm.spathi.font"
 #define SPATHI_HOME_COLOR_MAP "comm.safeones.colortable"
 #define SPATHI_HOME_CONVERSATION_PHRASES "comm.safeones.dialogue"
-#define FWIFFO_MUSIC "comm.fwiffo.music"
-#define SPAHOME_MUSIC "comm.safeones.music"
+#define SPATHI_HOME_PMAP_ANIM "comm.safeones.graphics"
 #define SPATHI_MUSIC "comm.spathi.music"
+#define SPATHI_PMAP_ANIM "comm.spathi.graphics"
+#define SPATHI_SCRIPT "comm.spathi.script"
diff -ruNp src.hd/uqm/comm/spathi/spathic.c src/uqm/comm/spathi/spathic.c
--- src.hd/uqm/comm/spathi/spathic.c	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/spathi/spathic.c	2017-12-29 00:57:44 -0800
@@ -148,7 +148,7 @@ static LOCDATA spathi_desc =
 static void
 ExitConversation (RESPONSE_REF Response)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 
 	if (PLAYER_SAID (Response, bye_ally_space))
 		NPCPhrase (GOODBYE_ALLY_SPACE);
@@ -166,13 +166,13 @@ ExitConversation (RESPONSE_REF Response)
 	{
 		NPCPhrase (YIPES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (Response, we_fight_again_space))
 	{
 		NPCPhrase (OK_FIGHT_AGAIN_SPACE);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (Response, die_slugboy)
 			|| PLAYER_SAID (Response, we_fight_1)
@@ -185,18 +185,18 @@ ExitConversation (RESPONSE_REF Response)
 			NPCPhrase (FAKE_COORDINATES);
 		NPCPhrase (OK_WE_FIGHT_AT_PLUTO);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (Response, join_us))
 	{
-		if (ActivateStarShip (SPATHI_SHIP, FEASIBILITY_STUDY) == 0)
+		if (EscortFeasibilityStudy (SPATHI_SHIP) == 0)
 			NPCPhrase (TOO_SCARY);
 		else
 		{
 			NPCPhrase (WILL_JOIN);
 
 			AlienTalkSegue ((COUNT)~0);
-			ActivateStarShip (SPATHI_SHIP, 1);
+			AddEscortShips (SPATHI_SHIP, 1);
 			/* Make the Eluder escort captained by Fwiffo alone */
 			SetEscortCrewComplement (SPATHI_SHIP, 1,
 					NAME_OFFSET + NUM_CAPTAINS_NAMES);
@@ -727,7 +727,7 @@ Intro (void)
 	else if (Manner == 2)
 	{
 		NPCPhrase (HATE_YOU_FOREVER_SPACE);
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (Manner == 1)
 	{
@@ -751,7 +751,7 @@ Intro (void)
 		Response (we_fight_again_space, ExitConversation);
 		Response (bye_angry_space, ExitConversation);
 	}
-	else if (ActivateStarShip (SPATHI_SHIP, CHECK_ALLIANCE) == GOOD_GUY)
+	else if (CheckAlliance (SPATHI_SHIP) == GOOD_GUY)
 	{
 		SpathiAllies ((RESPONSE_REF)0);
 	}
@@ -780,7 +780,7 @@ post_spathi_enc (void)
 	{
 		SET_GAME_STATE (FOUND_PLUTO_SPATHI, 2);
 	}
-	else if (GET_GAME_STATE (BATTLE_SEGUE) == 1
+	else if (getSegue () == Segue_hostile
 			&& (Manner = GET_GAME_STATE (SPATHI_MANNER)) != 2)
 	{
 		SET_GAME_STATE (SPATHI_MANNER, 1);
@@ -823,11 +823,11 @@ init_spathi_comm (void)
 			|| GET_GAME_STATE (SPATHI_MANNER) == 3
 			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	retval = &spathi_desc;
 
diff -ruNp src.hd/uqm/comm/starbas/Makeinfo src/uqm/comm/starbas/Makeinfo
--- src.hd/uqm/comm/starbas/Makeinfo	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/starbas/Makeinfo	2017-12-29 00:57:44 -0800
@@ -1 +1,2 @@
 uqm_CFILES="starbas.c"
+uqm_HFILES="strings.h"
diff -ruNp src.hd/uqm/comm/starbas/starbas.c src/uqm/comm/starbas/starbas.c
--- src.hd/uqm/comm/starbas/starbas.c	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/starbas/starbas.c	2017-12-29 00:57:44 -0800
@@ -19,7 +19,8 @@
 #include "../commall.h"
 #include "../comandr/resinst.h"
 #include "strings.h"
-
+#include "../../../options.h"
+#include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
 #include "uqm/setup.h"
 #include "uqm/shipcont.h"
@@ -28,8 +29,7 @@
 #include "libs/graphics/gfx_common.h"
 #include "libs/mathlib.h"
 #include "libs/inplib.h"
-#include "libs/sound/sound.h"
-#include "../../../options.h"
+
 
 static void TellMission (RESPONSE_REF R);
 static void SellMinerals (RESPONSE_REF R);
@@ -284,60 +284,29 @@ ByeBye (RESPONSE_REF R)
 {
 	(void) R;  // ignored
 
-	CurBulletinMask |= GET_GAME_STATE_32 (STARBASE_BULLETS0);
-	SET_GAME_STATE_32 (STARBASE_BULLETS0, CurBulletinMask);
+	CurBulletinMask |= GET_GAME_STATE (STARBASE_BULLETS);
+	SET_GAME_STATE (STARBASE_BULLETS, CurBulletinMask);
 
 	/* if (R == goodbye_starbase_commander) */
 	if (GET_GAME_STATE (CHMMR_BOMB_STATE) >= 2)
 		NPCPhrase (GOOD_LUCK_AGAIN);
 	else
 	{
-		RESPONSE_REF pStr0 = 0;
-		RESPONSE_REF pStr1 = 0;
+		RESPONSE_REF pStr = 0;
 		
 		switch ((BYTE)TFB_Random () & 7)
 		{
-			case 0:
-				pStr0 = NORMAL_GOODBYE_A0;
-				pStr1 = NORMAL_GOODBYE_A1;
-				break;
-			case 1:
-				pStr0 = NORMAL_GOODBYE_B0;
-				pStr1 = NORMAL_GOODBYE_B1;
-				break;
-			case 2:
-				pStr0 = NORMAL_GOODBYE_C0;
-				pStr1 = NORMAL_GOODBYE_C1;
-				break;
-			case 3:
-				pStr0 = NORMAL_GOODBYE_D0;
-				pStr1 = NORMAL_GOODBYE_D1;
-				break;
-			case 4:
-				pStr0 = NORMAL_GOODBYE_E0;
-				pStr1 = NORMAL_GOODBYE_E1;
-				break;
-			case 5:
-				pStr0 = NORMAL_GOODBYE_F0;
-				pStr1 = NORMAL_GOODBYE_F1;
-				break;
-			case 6:
-				pStr0 = NORMAL_GOODBYE_G0;
-				pStr1 = NORMAL_GOODBYE_G1;
-				break;
-			case 7:
-				pStr0 = NORMAL_GOODBYE_H0;
-				pStr1 = NORMAL_GOODBYE_H1;
-				break;
+			case 0: pStr = NORMAL_GOODBYE_A; break;
+			case 1: pStr = NORMAL_GOODBYE_B; break;
+			case 2: pStr = NORMAL_GOODBYE_C; break;
+			case 3: pStr = NORMAL_GOODBYE_D; break;
+			case 4: pStr = NORMAL_GOODBYE_E; break;
+			case 5: pStr = NORMAL_GOODBYE_F; break;
+			case 6: pStr = NORMAL_GOODBYE_G; break;
+			case 7: pStr = NORMAL_GOODBYE_H; break;
 		}
 
-		NPCPhrase (pStr0);
-		if (speechVolumeScale == 0.0f)
-		{
-			NPCPhrase (SPACE);
-			NPCPhrase (GLOBAL_PLAYER_NAME);
-		}
-		NPCPhrase (pStr1);
+		NPCPhrase (pStr);
 	}
 }
 
@@ -429,6 +398,11 @@ HierarchyInfo (RESPONSE_REF R)
 		NPCPhrase (WHICH_HIERARCHY);
 		HierarchyMask = 0;
 	}
+	else if (PLAYER_SAID (R, urquan))
+	{
+		NPCPhrase (ABOUT_URQUAN);
+		HierarchyMask |= HIERARCHY_URQUAN;
+	}
 	else if (PLAYER_SAID (R, mycon))
 	{
 		NPCPhrase (ABOUT_MYCON);
@@ -458,10 +432,8 @@ HierarchyInfo (RESPONSE_REF R)
 	{
 		NPCPhrase (ABOUT_VUX);
 		HierarchyMask |= HIERARCHY_VUX;
-	} else if (PLAYER_SAID (R, urquan)) {
-		NPCPhrase (ABOUT_URQUAN);
-		HierarchyMask |= HIERARCHY_URQUAN;
 	}
+
 	if (!(HierarchyMask & HIERARCHY_URQUAN))
 		Response (urquan, HierarchyInfo);
 	if (!(HierarchyMask & HIERARCHY_MYCON))
@@ -801,7 +773,7 @@ AnalyzeCondition (void)
 		if (num_bays < 1)
 			NPCPhrase (NEED_STORAGE_1);
 		if (GLOBAL_SIS (NumLanders) == 0)
-			NPCPhrase (NEED_LANDERS_1);
+			NPCPhrase (NEED_LANDERS_2);
 		if (num_batts < 1)
 			NPCPhrase (NEED_DYNAMOS_1);
 
@@ -816,11 +788,10 @@ AnalyzeCondition (void)
 		COUNT FleetStrength;
 		BOOLEAN HasMaximum;
 
-		FleetStrength = ActivateStarShip (0, ESCORT_WORTH);
+		FleetStrength = CalculateEscortsWorth ();
 		for (i = 0; i < NUM_AVAILABLE_RACES; ++i)
 		{
-			if (i != HUMAN_SHIP
-					&& ActivateStarShip (i, CHECK_ALLIANCE) == GOOD_GUY)
+			if (i != HUMAN_SHIP && CheckAlliance (i) == GOOD_GUY)
 				++num_aliens;
 		}
 
@@ -878,7 +849,7 @@ AnalyzeCondition (void)
 					if (GLOBAL_SIS (FuelOnBoard) < FUEL_TANK_CAPACITY * 3)
 						NPCPhrase (NEED_FUEL_2);
 					if (GLOBAL_SIS (NumLanders) < 3)
-						NPCPhrase (NEED_LANDERS_2);
+						NPCPhrase (NEED_LANDERS_1);
 					if (num_batts < 4)
 						NPCPhrase (NEED_DYNAMOS_2);
 					if (num_defense < 2)
@@ -1004,7 +975,6 @@ static void
 TellStarBase (RESPONSE_REF R)
 {
 	RESPONSE_REF pstack[4];
-	static UNICODE buf0[80];
 
 	if (PLAYER_SAID (R, starbase_functions))
 	{
@@ -1014,7 +984,7 @@ TellStarBase (RESPONSE_REF R)
 		stack2 = 0;
 		stack3 = 0;
 	}
-	else if (PLAYER_SAID (R, tell_me_about_fuel0))
+	else if (PLAYER_SAID (R, tell_me_about_fuel))
 	{
 		NPCPhrase (ABOUT_FUEL);
 
@@ -1022,18 +992,11 @@ TellStarBase (RESPONSE_REF R)
 	}
 	else if (PLAYER_SAID (R, tell_me_about_crew))
 	{
-		NPCPhrase (ABOUT_CREW0);
-		if (speechVolumeScale > 0.0f)
-			NPCPhrase (YOUR_FLAGSHIP_3DO2);
-		else {
-			NPCPhrase (YOUR_FLAGSHIP_PC);
-			NPCPhrase (GLOBAL_SHIP_NAME);
-		}
-		NPCPhrase (ABOUT_CREW1);
+		NPCPhrase (ABOUT_CREW);
 
 		stack2 = 2;
 	}
-	else if (PLAYER_SAID (R, tell_me_about_modules0))
+	else if (PLAYER_SAID (R, tell_me_about_modules))
 	{
 		NPCPhrase (ABOUT_MODULES);
 
@@ -1067,13 +1030,7 @@ TellStarBase (RESPONSE_REF R)
 	switch (stack0)
 	{
 		case 0:
-			construct_response (
-					buf0,
-					tell_me_about_modules0,
-					GLOBAL_SIS (ShipName),
-					tell_me_about_modules1,
-					(UNICODE*)NULL);
-			pstack[0] = tell_me_about_modules0;
+			pstack[0] = tell_me_about_modules;
 			break;
 		default:
 			pstack[0] = 0;
@@ -1082,13 +1039,7 @@ TellStarBase (RESPONSE_REF R)
 	switch (stack1)
 	{
 		case 0:
-			construct_response (
-					shared_phrase_buf,
-					tell_me_about_fuel0,
-					GLOBAL_SIS (ShipName),
-					tell_me_about_fuel1,
-					(UNICODE*)NULL);
-			pstack[1] = tell_me_about_fuel0;
+			pstack[1] = tell_me_about_fuel;
 			break;
 		default:
 			pstack[1] = 0;
@@ -1123,9 +1074,9 @@ TellStarBase (RESPONSE_REF R)
 	}
 
 	if (pstack[0])
-		DoResponsePhrase (pstack[0], TellStarBase, buf0);
+		Response (pstack[0], TellStarBase);
 	if (pstack[1])
-		DoResponsePhrase (pstack[1], TellStarBase, shared_phrase_buf);
+		Response (pstack[1], TellStarBase);
 	if (pstack[2])
 		Response (pstack[2], TellStarBase);
 	if (pstack[3])
@@ -1182,7 +1133,7 @@ DiscussDevices (BOOLEAN TalkAbout)
 				}
 				break;
 			case ARTIFACT_2_DEVICE:
-				if (GET_GAME_STATE (ARTIFACT_2_ON_SHIP)
+				if (GET_GAME_STATE (WIMBLIS_TRIDENT_ON_SHIP)
 						&& !GET_GAME_STATE (DISCUSSED_ARTIFACT_2))
 				{
 					pStr = ABOUT_ARTIFACT_2;
@@ -1190,7 +1141,7 @@ DiscussDevices (BOOLEAN TalkAbout)
 				}
 				break;
 			case ARTIFACT_3_DEVICE:
-				if (GET_GAME_STATE (ARTIFACT_3_ON_SHIP)
+				if (GET_GAME_STATE (GLOWING_ROD_ON_SHIP)
 						&& !GET_GAME_STATE (DISCUSSED_ARTIFACT_3))
 				{
 					pStr = ABOUT_ARTIFACT_3;
@@ -1480,7 +1431,7 @@ CheckBulletins (BOOLEAN Repeat)
 	if (Repeat)
 		BulletinMask = CurBulletinMask ^ 0xFFFFFFFFL;
 	else
-		BulletinMask = GET_GAME_STATE_32 (STARBASE_BULLETS0);
+		BulletinMask = GET_GAME_STATE (STARBASE_BULLETS);
 
 	pIntro = 0;
 	for (b0 = 0; b0 < 32; ++b0)
@@ -1493,36 +1444,31 @@ CheckBulletins (BOOLEAN Repeat)
 			switch (b0)
 			{
 				case 0:
-					if (ActivateStarShip (SPATHI_SHIP, CHECK_ALLIANCE)
-							== GOOD_GUY)
+					if (CheckAlliance (SPATHI_SHIP) == GOOD_GUY)
 					{
 						pStr = STARBASE_BULLETIN_1;
 					}
 					break;
 				case 1:
-					if (ActivateStarShip (ZOQFOTPIK_SHIP, CHECK_ALLIANCE)
-							== GOOD_GUY)
+					if (CheckAlliance (ZOQFOTPIK_SHIP) == GOOD_GUY)
 					{
 						pStr = STARBASE_BULLETIN_2;
 					}
 					break;
 				case 2:
-					if (ActivateStarShip (SUPOX_SHIP, CHECK_ALLIANCE)
-							== GOOD_GUY)
+					if (CheckAlliance (SUPOX_SHIP) == GOOD_GUY)
 					{
 						pStr = STARBASE_BULLETIN_3;
 					}
 					break;
 				case 3:
-					if (ActivateStarShip (UTWIG_SHIP, CHECK_ALLIANCE)
-							== GOOD_GUY)
+					if (CheckAlliance (UTWIG_SHIP) == GOOD_GUY)
 					{
 						pStr = STARBASE_BULLETIN_4;
 					}
 					break;
 				case 4:
-					if (ActivateStarShip (ORZ_SHIP, CHECK_ALLIANCE)
-							== GOOD_GUY)
+					if (CheckAlliance (ORZ_SHIP) == GOOD_GUY)
 					{
 						pStr = STARBASE_BULLETIN_5;
 					}
@@ -1531,14 +1477,13 @@ CheckBulletins (BOOLEAN Repeat)
 					if (GET_GAME_STATE (ARILOU_MANNER) == 2)
 						BulletinMask |= 1L << b0;
 					else if (GET_GAME_STATE (PORTAL_SPAWNER)
-							&& (Repeat || ActivateStarShip (
-									ARILOU_SHIP, FEASIBILITY_STUDY
-									)))
+							&& (Repeat || EscortFeasibilityStudy (
+									ARILOU_SHIP)))
 					{
 #define NUM_GIFT_ARILOUS 3
 						pStr = STARBASE_BULLETIN_6;
 						if (!Repeat)
-							ActivateStarShip (ARILOU_SHIP, NUM_GIFT_ARILOUS);
+							AddEscortShips (ARILOU_SHIP, NUM_GIFT_ARILOUS);
 					}
 					break;
 				case 6:
@@ -1579,7 +1524,7 @@ CheckBulletins (BOOLEAN Repeat)
 					break;
 				case 11:
 					if (GET_GAME_STATE (ZOQFOT_HOME_VISITS)
-							|| GET_GAME_STATE_32 (ZOQFOT_GRPOFFS0))
+							|| GET_GAME_STATE (ZOQFOT_GRPOFFS))
 						BulletinMask |= 1L << b0;
 					else if (CheckTiming (0, 42))
 					{
@@ -1587,15 +1532,13 @@ CheckBulletins (BOOLEAN Repeat)
 					}
 					break;
 				case 12:
-					if (ActivateStarShip (CHMMR_SHIP, CHECK_ALLIANCE)
-							== GOOD_GUY)
+					if (CheckAlliance (CHMMR_SHIP) == GOOD_GUY)
 					{
 						pStr = STARBASE_BULLETIN_13;
 					}
 					break;
 				case 13:
-					if (ActivateStarShip (SHOFIXTI_SHIP, CHECK_ALLIANCE)
-							== GOOD_GUY)
+					if (CheckAlliance (SHOFIXTI_SHIP) == GOOD_GUY)
 					{
 						pStr = STARBASE_BULLETIN_14;
 					}
@@ -1752,7 +1695,7 @@ CheckBulletins (BOOLEAN Repeat)
 	if (pIntro == 0 && GET_GAME_STATE (STARBASE_VISITED))
 		NPCPhrase (RETURN_HELLO);
 	else if (!Repeat)
-		SET_GAME_STATE_32 (STARBASE_BULLETS0, BulletinMask);
+		SET_GAME_STATE (STARBASE_BULLETS, BulletinMask);
 }
 
 static void
@@ -1768,25 +1711,11 @@ NormalStarbase (RESPONSE_REF R)
 	{
 		if (GET_GAME_STATE (MOONBASE_ON_SHIP))
 		{
-			NPCPhrase (STARBASE_IS_READY_A);
-			if (speechVolumeScale > 0.0f)
-				NPCPhrase (YOUR_FLAGSHIP_3DO1);
-			else {
-				NPCPhrase (YOUR_FLAGSHIP_PC);
-				NPCPhrase (GLOBAL_SHIP_NAME);
-			}
-			NPCPhrase (STARBASE_IS_READY_B);
-			if (speechVolumeScale > 0.0f)
-				NPCPhrase (YOUR_FLAGSHIP_3DO0);
-			else
-				NPCPhrase (GLOBAL_SHIP_NAME);
-			NPCPhrase (STARBASE_IS_READY_C);
-			LockMutex (GraphicsLock);
+			NPCPhrase (STARBASE_IS_READY);
 			DeltaSISGauges (0, 0, 2500);
 			if(optInfiniteRU){
 				oldRU = 2500;
 			}
-			UnlockMutex (GraphicsLock);
 			SET_GAME_STATE (STARBASE_MONTH,
 					GLOBAL (GameClock.month_index));
 			SET_GAME_STATE (STARBASE_DAY,
@@ -1798,51 +1727,21 @@ NormalStarbase (RESPONSE_REF R)
 		}
 		else
 		{
-			RESPONSE_REF pStr0 = 0;
-			RESPONSE_REF pStr1 = 0;
+			// XXX TODO: This can be simplified now.
+			RESPONSE_REF pStr = 0;
 
 			switch ((BYTE)TFB_Random () & 7)
 			{
-				case 0:
-					pStr0 = NORMAL_HELLO_A0;
-					pStr1 = NORMAL_HELLO_A1;
-					break;
-				case 1:
-					pStr0 = NORMAL_HELLO_B0;
-					pStr1 = NORMAL_HELLO_B1;
-					break;
-				case 2:
-					pStr0 = NORMAL_HELLO_C0;
-					pStr1 = NORMAL_HELLO_C1;
-					break;
-				case 3:
-					pStr0 = NORMAL_HELLO_D0;
-					pStr1 = NORMAL_HELLO_D1;
-					break;
-				case 4:
-					pStr0 = NORMAL_HELLO_E0;
-					pStr1 = NORMAL_HELLO_E1;
-					break;
-				case 5:
-					pStr0 = NORMAL_HELLO_F0;
-					pStr1 = NORMAL_HELLO_F1;
-					break;
-				case 6:
-					pStr0 = NORMAL_HELLO_G0;
-					pStr1 = NORMAL_HELLO_G1;
-					break;
-				case 7:
-					pStr0 = NORMAL_HELLO_H0;
-					pStr1 = NORMAL_HELLO_H1;
-					break;
+				case 0: pStr = NORMAL_HELLO_A; break;
+				case 1: pStr = NORMAL_HELLO_B; break;
+				case 2: pStr = NORMAL_HELLO_C; break;
+				case 3: pStr = NORMAL_HELLO_D; break;
+				case 4: pStr = NORMAL_HELLO_E; break;
+				case 5: pStr = NORMAL_HELLO_F; break;
+				case 6: pStr = NORMAL_HELLO_G; break;
+				case 7: pStr = NORMAL_HELLO_H; break;
 			}
-			NPCPhrase (pStr0);
-			if (speechVolumeScale == 0.0f)
-			{
-				NPCPhrase (SPACE);
-				NPCPhrase (GLOBAL_PLAYER_NAME);
-			}
-			NPCPhrase (pStr1);
+			NPCPhrase (pStr);
 			CheckBulletins (FALSE);
 		}
 
@@ -1898,9 +1797,7 @@ SellMinerals (RESPONSE_REF R)
 					Sleepy = FALSE;
 					GLOBAL_SIS (ElementAmounts[i]) = 0;
 					GLOBAL_SIS (TotalElementMass) -= amount;
-					LockMutex (GraphicsLock);
 					DeltaSISGauges (0, 0, total);
-					UnlockMutex (GraphicsLock);
 					break;
 				}
 				
@@ -1909,10 +1806,8 @@ SellMinerals (RESPONSE_REF R)
 				TaskSwitch ();
 				TimeIn = GetTimeCounter ();
 				DrawCargoStrings ((BYTE)i, (BYTE)i);
-				LockMutex (GraphicsLock);
 				ShowRemainingCapacity ();
 				DeltaSISGauges (0, 0, GLOBAL (ElementWorth[i]));
-				UnlockMutex (GraphicsLock);
 			} while (--amount);
 		}
 		if (Sleepy) {
@@ -1922,9 +1817,7 @@ SellMinerals (RESPONSE_REF R)
 	}
 	SleepThread (ONE_SECOND / 2);
 
-	LockMutex (GraphicsLock);
 	ClearSISRect (DRAW_SIS_DISPLAY);
-	UnlockMutex (GraphicsLock);
 // DrawStorageBays (FALSE);
 
 	if (total < 1000)
@@ -1932,34 +1825,18 @@ SellMinerals (RESPONSE_REF R)
 		total = GET_GAME_STATE (LIGHT_MINERAL_LOAD);
 		switch (total++)
 		{
-			case 0:
-				pStr1 = LIGHT_LOAD_A0;
-				pStr2 = LIGHT_LOAD_A1;
-				break;
-			case 1:
-				pStr1 = LIGHT_LOAD_B0;
-				pStr2 = LIGHT_LOAD_B1;
-				break;
+			case 0: pStr1 = LIGHT_LOAD_A; break;
+			case 1: pStr1 = LIGHT_LOAD_B; break;
 			case 2:
+				// There are two separate sound samples in this case.
 				pStr1 = LIGHT_LOAD_C0;
 				pStr2 = LIGHT_LOAD_C1;
 				break;
-			case 3:
-				pStr1 = LIGHT_LOAD_D0;
-				pStr2 = LIGHT_LOAD_D1;
-				break;
-			case 4:
-				pStr1 = LIGHT_LOAD_E0;
-				pStr2 = LIGHT_LOAD_E1;
-				break;
-			case 5:
-				pStr1 = LIGHT_LOAD_F0;
-				pStr2 = LIGHT_LOAD_F1;
-				break;
-			case 6:
-				--total;
-				pStr1 = LIGHT_LOAD_G0;
-				pStr2 = LIGHT_LOAD_G1;
+			case 3: pStr1 = LIGHT_LOAD_D; break;
+			case 4: pStr1 = LIGHT_LOAD_E; break;
+			case 5: pStr1 = LIGHT_LOAD_F; break;
+			case 6: --total;
+				pStr1 = LIGHT_LOAD_G;
 				break;
 		}
 		SET_GAME_STATE (LIGHT_MINERAL_LOAD, total);
@@ -1969,34 +1846,15 @@ SellMinerals (RESPONSE_REF R)
 		total = GET_GAME_STATE (MEDIUM_MINERAL_LOAD);
 		switch (total++)
 		{
-			case 0:
-				pStr1 = MEDIUM_LOAD_A0;
-				pStr2 = MEDIUM_LOAD_A1;
-				break;
-			case 1:
-				pStr1 = MEDIUM_LOAD_B0;
-				pStr2 = MEDIUM_LOAD_B1;
-				break;
-			case 2:
-				pStr1 = MEDIUM_LOAD_C0;
-				pStr2 = MEDIUM_LOAD_C1;
-				break;
-			case 3:
-				pStr1 = MEDIUM_LOAD_D0;
-				pStr2 = MEDIUM_LOAD_D1;
-				break;
-			case 4:
-				pStr1 = MEDIUM_LOAD_E0;
-				pStr2 = MEDIUM_LOAD_E1;
-				break;
-			case 5:
-				pStr1 = MEDIUM_LOAD_F0;
-				pStr2 = MEDIUM_LOAD_F1;
-				break;
+			case 0: pStr1 = MEDIUM_LOAD_A; break;
+			case 1: pStr1 = MEDIUM_LOAD_B; break;
+			case 2: pStr1 = MEDIUM_LOAD_C; break;
+			case 3: pStr1 = MEDIUM_LOAD_D; break;
+			case 4: pStr1 = MEDIUM_LOAD_E; break;
+			case 5: pStr1 = MEDIUM_LOAD_F; break;
 			case 6:
 				--total;
-				pStr1 = MEDIUM_LOAD_G0;
-				pStr2 = MEDIUM_LOAD_G1;
+				pStr1 = MEDIUM_LOAD_G;
 				break;
 		}
 		SET_GAME_STATE (MEDIUM_MINERAL_LOAD, total);
@@ -2006,46 +1864,23 @@ SellMinerals (RESPONSE_REF R)
 		total = GET_GAME_STATE (HEAVY_MINERAL_LOAD);
 		switch (total++)
 		{
-			case 0:
-				pStr1 = HEAVY_LOAD_A0;
-				pStr2 = HEAVY_LOAD_A1;
-				break;
-			case 1:
-				pStr1 = HEAVY_LOAD_B0;
-				pStr2 = HEAVY_LOAD_B1;
-				break;
-			case 2:
-				pStr1 = HEAVY_LOAD_C0;
-				pStr2 = HEAVY_LOAD_C1;
-				break;
-			case 3:
-				pStr1 = HEAVY_LOAD_D0;
-				pStr2 = HEAVY_LOAD_D1;
-				break;
-			case 4:
-				pStr1 = HEAVY_LOAD_E0;
-				pStr2 = HEAVY_LOAD_E1;
-				break;
-			case 5:
-				pStr1 = HEAVY_LOAD_F0;
-				pStr2 = HEAVY_LOAD_F1;
-				break;
+			case 0: pStr1 = HEAVY_LOAD_A; break;
+			case 1: pStr1 = HEAVY_LOAD_B; break;
+			case 2: pStr1 = HEAVY_LOAD_C; break;
+			case 3: pStr1 = HEAVY_LOAD_D; break;
+			case 4: pStr1 = HEAVY_LOAD_E; break;
+			case 5: pStr1 = HEAVY_LOAD_F; break;
 			case 6:
 				--total;
-				pStr1 = HEAVY_LOAD_G0;
-				pStr2 = HEAVY_LOAD_G1;
+				pStr1 = HEAVY_LOAD_G;
 				break;
 		}
 		SET_GAME_STATE (HEAVY_MINERAL_LOAD, total);
 	}
 
 	NPCPhrase (pStr1);
-	if (speechVolumeScale == 0.0f)
-	{
-		NPCPhrase (SPACE);
-		NPCPhrase (GLOBAL_PLAYER_NAME);
-	}
-	NPCPhrase (pStr2);
+	if (pStr2 != (RESPONSE_REF) 0)
+		NPCPhrase (pStr2);
 
 	NormalStarbase (R);
 }
@@ -2059,6 +1894,7 @@ Intro (void)
 static COUNT
 uninit_starbase (void)
 {
+	luaUqm_comm_uninit ();
 	return (0);
 }
 
@@ -2078,24 +1914,16 @@ init_starbase_comm ()
 	static LOCDATA commander_desc;
 	LOCDATA *retval;
 
-	switch (RESOLUTION_FACTOR)
-	{
-		case 2:
-			commander_desc = commander_desc_4x;
-			break;
-		case 1:
-			commander_desc = commander_desc_4x;
-			break;
-		case 0:
-		default:
-			commander_desc = commander_desc_1x;
-			break;
-	}
-	
+	commander_desc = (RESOLUTION_FACTOR == 0 ? commander_desc_1x : commander_desc_4x);
+
 	commander_desc.init_encounter_func = Intro;
 	commander_desc.post_encounter_func = post_starbase_enc;
 	commander_desc.uninit_encounter_func = uninit_starbase;
 
+	luaUqm_comm_init (NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	commander_desc.AlienTextWidth = RES_SIS_SCALE(143); // JMS_GFX
 	commander_desc.AlienTextBaseline.x = RES_SIS_SCALE(164); // JMS_GFX
 	commander_desc.AlienTextBaseline.y = RES_SIS_SCALE(20); // JMS_GFX
@@ -2103,12 +1931,10 @@ init_starbase_comm ()
 	// use alternate Starbase track if available
 	commander_desc.AlienAltSongRes = STARBASE_ALT_MUSIC;
 	commander_desc.AlienSongFlags |= LDASF_USE_ALTERNATE;
-	
-		
+
 	CurBulletinMask = 0;
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
-	
+	setSegue (Segue_peace);
 	retval = &commander_desc;
-	
+
 	return (retval);
 }
diff -ruNp src.hd/uqm/comm/starbas/strings.h src/uqm/comm/starbas/strings.h
--- src.hd/uqm/comm/starbas/strings.h	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/starbas/strings.h	2017-12-29 00:57:44 -0800
@@ -28,85 +28,46 @@ enum
 	BEFORE_WE_GO_ON_5,
 	BEFORE_WE_GO_ON_6,
 	BEFORE_WE_GO_ON_7,
-	NORMAL_HELLO_A0,
-	NORMAL_HELLO_A1,
-	NORMAL_HELLO_B0,
-	NORMAL_HELLO_B1,
-	NORMAL_HELLO_C0,
-	NORMAL_HELLO_C1,
-	NORMAL_HELLO_D0,
-	NORMAL_HELLO_D1,
-	NORMAL_HELLO_E0,
-	NORMAL_HELLO_E1,
-	NORMAL_HELLO_F0,
-	NORMAL_HELLO_F1,
-	NORMAL_HELLO_G0,
-	NORMAL_HELLO_G1,
-	NORMAL_HELLO_H0,
-	NORMAL_HELLO_H1,
+	NORMAL_HELLO_A,
+	NORMAL_HELLO_B,
+	NORMAL_HELLO_C,
+	NORMAL_HELLO_D,
+	NORMAL_HELLO_E,
+	NORMAL_HELLO_F,
+	NORMAL_HELLO_G,
+	NORMAL_HELLO_H,
 	RETURN_HELLO,
-	NORMAL_HELLO_TAIL,
-	NORMAL_GOODBYE_A0,
-	NORMAL_GOODBYE_A1,
-	NORMAL_GOODBYE_B0,
-	NORMAL_GOODBYE_B1,
-	NORMAL_GOODBYE_C0,
-	NORMAL_GOODBYE_C1,
-	NORMAL_GOODBYE_D0,
-	NORMAL_GOODBYE_D1,
-	NORMAL_GOODBYE_E0,
-	NORMAL_GOODBYE_E1,
-	NORMAL_GOODBYE_F0,
-	NORMAL_GOODBYE_F1,
-	NORMAL_GOODBYE_G0,
-	NORMAL_GOODBYE_G1,
-	NORMAL_GOODBYE_H0,
-	NORMAL_GOODBYE_H1,
-	LIGHT_LOAD_A0,
-	LIGHT_LOAD_A1,
-	LIGHT_LOAD_B0,
-	LIGHT_LOAD_B1,
+	NORMAL_GOODBYE_A,
+	NORMAL_GOODBYE_B,
+	NORMAL_GOODBYE_C,
+	NORMAL_GOODBYE_D,
+	NORMAL_GOODBYE_E,
+	NORMAL_GOODBYE_F,
+	NORMAL_GOODBYE_G,
+	NORMAL_GOODBYE_H,
+	LIGHT_LOAD_A,
+	LIGHT_LOAD_B,
 	LIGHT_LOAD_C0,
 	LIGHT_LOAD_C1,
-	LIGHT_LOAD_D0,
-	LIGHT_LOAD_D1,
-	LIGHT_LOAD_E0,
-	LIGHT_LOAD_E1,
-	LIGHT_LOAD_F0,
-	LIGHT_LOAD_F1,
-	LIGHT_LOAD_G0,
-	LIGHT_LOAD_G1,
-	MEDIUM_LOAD_A0,
-	MEDIUM_LOAD_A1,
-	MEDIUM_LOAD_B0,
-	MEDIUM_LOAD_B1,
-	MEDIUM_LOAD_C0,
-	MEDIUM_LOAD_C1,
-	MEDIUM_LOAD_D0,
-	MEDIUM_LOAD_D1,
-	MEDIUM_LOAD_E0,
-	MEDIUM_LOAD_E1,
-	MEDIUM_LOAD_F0,
-	MEDIUM_LOAD_F1,
-	MEDIUM_LOAD_G0,
-	MEDIUM_LOAD_G1,
-	HEAVY_LOAD_A0,
-	HEAVY_LOAD_A1,
-	HEAVY_LOAD_B0,
-	HEAVY_LOAD_B1,
-	HEAVY_LOAD_C0,
-	HEAVY_LOAD_C1,
-	HEAVY_LOAD_D0,
-	HEAVY_LOAD_D1,
-	HEAVY_LOAD_E0,
-	HEAVY_LOAD_E1,
-	HEAVY_LOAD_F0,
-	HEAVY_LOAD_F1,
-	HEAVY_LOAD_G0 ,
-	HEAVY_LOAD_G1,
-	STARBASE_IS_READY_A,
-	STARBASE_IS_READY_B,
-	STARBASE_IS_READY_C,
+	LIGHT_LOAD_D,
+	LIGHT_LOAD_E,
+	LIGHT_LOAD_F,
+	LIGHT_LOAD_G,
+	MEDIUM_LOAD_A,
+	MEDIUM_LOAD_B,
+	MEDIUM_LOAD_C,
+	MEDIUM_LOAD_D,
+	MEDIUM_LOAD_E,
+	MEDIUM_LOAD_F,
+	MEDIUM_LOAD_G,
+	HEAVY_LOAD_A,
+	HEAVY_LOAD_B,
+	HEAVY_LOAD_C,
+	HEAVY_LOAD_D,
+	HEAVY_LOAD_E,
+	HEAVY_LOAD_F,
+	HEAVY_LOAD_G,
+	STARBASE_IS_READY,
 	WHAT_KIND_OF_INFO,
 	WHICH_FUNCTION,
 	WHICH_HISTORY,
@@ -114,8 +75,7 @@ enum
 	OK_NO_NEED_INFO,
 	ABOUT_FUEL,
 	ABOUT_MODULES,
-	ABOUT_CREW0,
-	ABOUT_CREW1,
+	ABOUT_CREW,
 	ABOUT_SHIPS,
 	ABOUT_RU,
 	ABOUT_MINERALS,
@@ -265,10 +225,8 @@ enum
 	no_need_info,
 	enough_starbase,
 	enough_mission,
-	tell_me_about_fuel0,
-	tell_me_about_fuel1,
-	tell_me_about_modules0,
-	tell_me_about_modules1,
+	tell_me_about_fuel,
+	tell_me_about_modules,
 	tell_me_about_crew,
 	tell_me_about_ships,
 	tell_me_about_ru,
@@ -317,11 +275,6 @@ enum
 	new_devices,
 	how_get_strong,
 	what_do_now,
-	YOUR_FLAGSHIP_PC,
-	YOUR_FLAGSHIP_3DO0,
-	YOUR_FLAGSHIP_3DO1,
-	YOUR_FLAGSHIP_3DO2,
-	SPACE,
 };
 
 #endif /* _STRINGS_H */
diff -ruNp src.hd/uqm/comm/supox/Makeinfo src/uqm/comm/supox/Makeinfo
--- src.hd/uqm/comm/supox/Makeinfo	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/supox/Makeinfo	2017-12-29 00:57:44 -0800
@@ -1 +1,2 @@
 uqm_CFILES="supoxc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.hd/uqm/comm/supox/resinst.h src/uqm/comm/supox/resinst.h
--- src.hd/uqm/comm/supox/resinst.h	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/supox/resinst.h	2017-12-29 00:57:44 -0800
@@ -1,5 +1,10 @@
-#define SUPOX_PMAP_ANIM "comm.supox.graphics"
-#define SUPOX_FONT "comm.supox.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SUPOX_COLOR_MAP "comm.supox.colortable"
 #define SUPOX_CONVERSATION_PHRASES "comm.supox.dialogue"
+#define SUPOX_FONT "comm.supox.font"
 #define SUPOX_MUSIC "comm.supox.music"
+#define SUPOX_PMAP_ANIM "comm.supox.graphics"
+#define SUPOX_SCRIPT "comm.supox.script"
diff -ruNp src.hd/uqm/comm/supox/strings.h src/uqm/comm/supox/strings.h
--- src.hd/uqm/comm/supox/strings.h	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/supox/strings.h	2017-12-29 00:57:44 -0800
@@ -32,14 +32,11 @@ enum
 	ALLIED_HOMEWORLD_HELLO_2,
 	ALLIED_HOMEWORLD_HELLO_3,
 	ALLIED_HOMEWORLD_HELLO_4,
-	i_am0,
-	i_am1,
+	i_am,
 	WE_ARE_SUPOX,
-	my_ship0,
-	my_ship1,
+	my_ship,
 	OUR_SHIP,
-	from_alliance0,
-	from_alliance1,
+	from_alliance,
 	FROM_SUPOX,
 	are_you_copying,
 	YEAH_SORRY,
@@ -116,8 +113,7 @@ enum
 	name_1,
 	name_2,
 	name_3,
-	name_40,
-	name_41,
+	name_4,
 	OUT_TAKES,
 };
 
diff -ruNp src.hd/uqm/comm/supox/supoxc.c src/uqm/comm/supox/supoxc.c
--- src.hd/uqm/comm/supox/supoxc.c	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/supox/supoxc.c	2017-12-29 00:57:44 -0800
@@ -20,6 +20,7 @@
 #include "resinst.h"
 #include "strings.h"
 
+#include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
 
 
@@ -104,7 +105,7 @@ static LOCDATA supox_desc =
 static void
 ExitConversation (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 
 	if (PLAYER_SAID (R, bye_neutral))
 		NPCPhrase (GOODBYE_NEUTRAL);
@@ -127,14 +128,14 @@ ExitConversation (RESPONSE_REF R)
 	else if (PLAYER_SAID (R, can_you_help))
 	{
 		NPCPhrase (HOW_HELP);
-		if (ActivateStarShip (SUPOX_SHIP, FEASIBILITY_STUDY) == 0)
+		if (EscortFeasibilityStudy (SUPOX_SHIP) == 0)
 			NPCPhrase (DONT_NEED);
 		else
 		{
 			NPCPhrase (HAVE_4_SHIPS);
 
 			AlienTalkSegue ((COUNT)~0);
-			ActivateStarShip (SUPOX_SHIP, 4);
+			AddEscortShips (SUPOX_SHIP, 4);
 		}
 	}
 }
@@ -306,26 +307,26 @@ NeutralSupox (RESPONSE_REF R)
 
 	LastStack = 0;
 	pStr[0] = pStr[1] = pStr[2] = 0;
-	if (PLAYER_SAID (R, i_am0))
+	if (PLAYER_SAID (R, i_am))
 	{
 		NPCPhrase (WE_ARE_SUPOX);
 
 		SET_GAME_STATE (SUPOX_STACK1, 1);
-		DISABLE_PHRASE (i_am0);
+		DISABLE_PHRASE (i_am);
 	}
-	else if (PLAYER_SAID (R, my_ship0))
+	else if (PLAYER_SAID (R, my_ship))
 	{
 		NPCPhrase (OUR_SHIP);
 
 		SET_GAME_STATE (SUPOX_STACK1, 2);
-		DISABLE_PHRASE (my_ship0);
+		DISABLE_PHRASE (my_ship);
 	}
-	else if (PLAYER_SAID (R, from_alliance0))
+	else if (PLAYER_SAID (R, from_alliance))
 	{
 		NPCPhrase (FROM_SUPOX);
 
 		SET_GAME_STATE (SUPOX_STACK1, 3);
-		DISABLE_PHRASE (from_alliance0);
+		DISABLE_PHRASE (from_alliance);
 	}
 	else if (PLAYER_SAID (R, are_you_copying))
 	{
@@ -358,7 +359,7 @@ NeutralSupox (RESPONSE_REF R)
 
 		LastStack = 2;
 		SET_GAME_STATE (SUPOX_WAR_NEWS, 1);
-		ActivateStarShip (UTWIG_SHIP, SPHERE_TRACKING);
+		StartSphereTracking (UTWIG_SHIP);
 	}
 	else if (PLAYER_SAID (R, what_relation_to_utwig))
 	{
@@ -423,36 +424,15 @@ NeutralSupox (RESPONSE_REF R)
 	switch (GET_GAME_STATE (SUPOX_STACK1))
 	{
 		case 0:
-			construct_response (shared_phrase_buf,
-					i_am0,
-					GLOBAL_SIS (CommanderName),
-					i_am1,
-					(UNICODE*)NULL);
-			pStr[0] = i_am0;
+			pStr[0] = i_am;
 			pStr[1] = 0;
 			break;
 		case 1:
-			construct_response (shared_phrase_buf,
-					my_ship0,
-					GLOBAL_SIS (ShipName),
-					my_ship1,
-					(UNICODE*)NULL);
-			pStr[0] = my_ship0;
+			pStr[0] = my_ship;
 			pStr[1] = 0;
 			break;
 		case 2:
-			{
-				UNICODE buf[ALLIANCE_NAME_BUFSIZE];
-
-				GetAllianceName (buf, name_1);
-				construct_response (
-						shared_phrase_buf,
-						from_alliance0,
-						buf,
-						from_alliance1,
-						(UNICODE*)NULL);
-			}
-			pStr[0] = from_alliance0;
+			pStr[0] = from_alliance;
 			pStr[1] = 0;
 			break;
 		case 3:
@@ -486,21 +466,11 @@ NeutralSupox (RESPONSE_REF R)
 		}
 	}
 	if (pStr[LastStack])
-	{
-		if (LastStack != 0 || GET_GAME_STATE (SUPOX_STACK1) > 2)
-			Response (pStr[LastStack], NeutralSupox);
-		else
-			DoResponsePhrase (pStr[LastStack], NeutralSupox, shared_phrase_buf);
-	}
+		Response (pStr[LastStack], NeutralSupox);
 	for (i = 0; i < 3; ++i)
 	{
 		if (i != LastStack && pStr[i])
-		{
-			if (i != 0 || GET_GAME_STATE (SUPOX_STACK1) > 2)
-				Response (pStr[i], NeutralSupox);
-			else
-				DoResponsePhrase (pStr[i], NeutralSupox, shared_phrase_buf);
-		}
+			Response (pStr[i], NeutralSupox);
 	}
 	if (!GET_GAME_STATE (SUPOX_ULTRON_HELP))
 	{
@@ -532,7 +502,7 @@ Intro (void)
 	{
 		NPCPhrase (OUT_TAKES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
@@ -551,9 +521,9 @@ Intro (void)
 		}
 		SET_GAME_STATE (SUPOX_VISITS, NumVisits);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
-	else if (ActivateStarShip (SUPOX_SHIP, CHECK_ALLIANCE) == GOOD_GUY)
+	else if (CheckAlliance (SUPOX_SHIP) == GOOD_GUY)
 	{
 		if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 7))
 		{
@@ -672,6 +642,7 @@ Intro (void)
 static COUNT
 uninit_supox (void)
 {
+	luaUqm_comm_uninit ();
 	return (0);
 }
 
@@ -690,6 +661,10 @@ init_supox_comm (void)
 	supox_desc.post_encounter_func = post_supox_enc;
 	supox_desc.uninit_encounter_func = uninit_supox;
 
+	luaUqm_comm_init (NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	supox_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
 	supox_desc.AlienTextBaseline.y = 0;
 	supox_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
@@ -697,11 +672,11 @@ init_supox_comm (void)
 	if (!GET_GAME_STATE (SUPOX_HOSTILE)
 			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	retval = &supox_desc;
 
diff -ruNp src.hd/uqm/comm/syreen/Makeinfo src/uqm/comm/syreen/Makeinfo
--- src.hd/uqm/comm/syreen/Makeinfo	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/syreen/Makeinfo	2017-12-29 00:57:44 -0800
@@ -1 +1,2 @@
 uqm_CFILES="syreenc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.hd/uqm/comm/syreen/resinst.h src/uqm/comm/syreen/resinst.h
--- src.hd/uqm/comm/syreen/resinst.h	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/syreen/resinst.h	2017-12-29 00:57:44 -0800
@@ -1,5 +1,10 @@
-#define SYREEN_PMAP_ANIM "comm.syreen.graphics"
-#define SYREEN_FONT "comm.syreen.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SYREEN_COLOR_MAP "comm.syreen.colortable"
 #define SYREEN_CONVERSATION_PHRASES "comm.syreen.dialogue"
+#define SYREEN_FONT "comm.syreen.font"
 #define SYREEN_MUSIC "comm.syreen.music"
+#define SYREEN_PMAP_ANIM "comm.syreen.graphics"
+#define SYREEN_SCRIPT "comm.syreen.script"
diff -ruNp src.hd/uqm/comm/syreen/strings.h src/uqm/comm/syreen/strings.h
--- src.hd/uqm/comm/syreen/strings.h	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/syreen/strings.h	2017-12-29 00:57:44 -0800
@@ -30,12 +30,8 @@ enum
 	OK_VICE,
 	we_are_the_one_for_you_baby,
 	MAYBE_CAPTAIN,
-	we_are_vindicator0,
-	we_are_vindicator1,
-	we_are_vindicator2,
-	WELCOME_VINDICATOR0,
-	WELCOME_VINDICATOR1,
-	WELCOME_VINDICATOR2,
+	we_are_vindicator,
+	WELCOME_VINDICATOR,
 	we_are_impressed,
 	SO_AM_I_CAPTAIN,
 	HOW_CAN_YOU_BE_HERE,
diff -ruNp src.hd/uqm/comm/syreen/syreenc.c src/uqm/comm/syreen/syreenc.c
--- src.hd/uqm/comm/syreen/syreenc.c	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/syreen/syreenc.c	2017-12-29 00:57:44 -0800
@@ -19,12 +19,10 @@
 #include "../commall.h"
 #include "resinst.h"
 #include "strings.h"
-
-#include "libs/sound/sound.h"
+#include "uqm/gameev.h"
+#include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
-
 #include "uqm/setup.h"
-		// for GraphicsLock
 
 
 static LOCDATA syreen_desc_1x =
@@ -382,7 +380,7 @@ static LOCDATA syreen_desc_4x =
 static void
 FriendlyExit (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 
 	if (PLAYER_SAID (R, bye))
 		NPCPhrase (GOODBYE);
@@ -408,17 +406,12 @@ FriendlyExit (RESPONSE_REF R)
 		NPCPhrase (SEX_GOODBYE);
 
 		AlienTalkSegue (2);
-
-		if (RESOLUTION_FACTOR == 0)
-		{
+		if (RESOLUTION_FACTOR == 0) {
 			XFormColorMap (GetColorMapAddress (
-				SetAbsColorMapIndex (CommData.AlienColorMap, 0)
-				), ONE_SECOND / 2);
-				
+ 				SetAbsColorMapIndex (CommData.AlienColorMap, 0)
+ 				), ONE_SECOND / 2);
 			AlienTalkSegue ((COUNT)~0);
-		}
-		else
-		{
+		} else {
 			COUNT i = 0;
 			COUNT limit = CommData.NumAnimations;
 			
@@ -494,18 +487,14 @@ Foreplay (RESPONSE_REF R)
 			NPCPhrase (HERES_REWARD);
 		else
 			NPCPhrase (ABOUT_US);
-		
 		NPCPhrase (MORE_COMFORTABLE);
 		AlienTalkSegue (1);
-		
-		if (RESOLUTION_FACTOR == 0)
-		{
+
+		if (RESOLUTION_FACTOR == 0) {
 			XFormColorMap (GetColorMapAddress (
 					SetAbsColorMapIndex (CommData.AlienColorMap, 1)
 					), ONE_SECOND);
-		}
-		else
-		{
+		} else {
 			COUNT i = 0;
 			COUNT limit = CommData.NumAnimations - 2;
 			
@@ -518,7 +507,7 @@ Foreplay (RESPONSE_REF R)
 				
 			CommData.AlienTalkDesc.AnimFlags |= PAUSE_TALKING;
 		}
-				
+
 		AlienTalkSegue ((COUNT)~0);
 
 		SET_GAME_STATE (PLAYER_HAVING_SEX, 1);
@@ -787,7 +776,7 @@ NormalSyreen (RESPONSE_REF R)
 	{
 		NPCPhrase (HORRIBLE_TRUTH);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		SET_GAME_STATE (SYREEN_HOME_VISITS, 0);
 		SET_GAME_STATE (SYREEN_KNOW_ABOUT_MYCON, 1);
 
@@ -881,16 +870,9 @@ InitialSyreen (RESPONSE_REF R)
 		NPCPhrase (MAYBE_CAPTAIN);
 		NPCPhrase (HOW_CAN_YOU_BE_HERE);
 	}
-	else if (PLAYER_SAID (R, we_are_vindicator0))
+	else if (PLAYER_SAID (R, we_are_vindicator))
 	{
-		NPCPhrase (WELCOME_VINDICATOR0);
-		if (speechVolumeScale == 0.0f)
-		{
-			NPCPhrase (GLOBAL_PLAYER_NAME);
-			NPCPhrase (WELCOME_VINDICATOR1);
-			NPCPhrase (GLOBAL_SHIP_NAME);
-		}
-		NPCPhrase (WELCOME_VINDICATOR2);
+		NPCPhrase (WELCOME_VINDICATOR);
 		NPCPhrase (HOW_CAN_YOU_BE_HERE);
 	}
 	else if (PLAYER_SAID (R, we_are_impressed))
@@ -924,6 +906,8 @@ InitialSyreen (RESPONSE_REF R)
 static void
 PlanAmbush (RESPONSE_REF R)
 {
+	HFLEETINFO hSyreen = GetStarShipFromIndex (&GLOBAL (avail_race_q), SYREEN_SHIP);
+	FLEET_INFO *SyreenPtr = LockFleetInfo (&GLOBAL (avail_race_q), hSyreen);
 	(void) R;  // ignored
 	NPCPhrase (OK_FOUND_VAULT);
 
@@ -931,6 +915,18 @@ PlanAmbush (RESPONSE_REF R)
 	// This is redundant but left here for clarity
 	SET_GAME_STATE (SYREEN_HOME_VISITS, 0);
 
+	// Send ambush fleet to Organon.  EncounterPercent for the
+	// Syreen is 0, so this is purely decorative.
+
+	if (SyreenPtr) {
+		SyreenPtr->actual_strength = 300 / SPHERE_RADIUS_INCREMENT * 2;
+		SyreenPtr->loc.x = 4125;
+		SyreenPtr->loc.y = 3770;
+		StartSphereTracking (SYREEN_SHIP);
+		SetRaceDest (SYREEN_SHIP, 6858, 577, 15, (BYTE)~0);
+	}
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hSyreen);
+
 	Response (whats_my_reward, Foreplay);
 	Response (bye_after_vault, FriendlyExit);
 }
@@ -961,7 +957,7 @@ Intro (void)
 	{
 		NPCPhrase (OUT_TAKES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
@@ -972,7 +968,7 @@ Intro (void)
 		{
 			case 0:
 				NPCPhrase (HELLO_AFTER_AMBUSH_1);
-				ActivateStarShip (SYREEN_SHIP, SET_ALLIED);
+				SetRaceAllied (SYREEN_SHIP, TRUE);
 				break;
 			case 1:
 				NPCPhrase (HELLO_AFTER_AMBUSH_2);
@@ -1023,16 +1019,9 @@ Intro (void)
 			NormalSyreen ((RESPONSE_REF)0);
 		else
 		{
-			construct_response (shared_phrase_buf,
-					we_are_vindicator0,
-					GLOBAL_SIS (CommanderName),
-					we_are_vindicator1,
-					GLOBAL_SIS (ShipName),
-					we_are_vindicator2,
-					(UNICODE*)NULL);
 			Response (we_are_vice_squad, InitialSyreen);
 			Response (we_are_the_one_for_you_baby, InitialSyreen);
-			DoResponsePhrase (we_are_vindicator0, InitialSyreen, shared_phrase_buf);
+			Response (we_are_vindicator, InitialSyreen);
 			Response (we_are_impressed, InitialSyreen);
 		}
 	}
@@ -1081,6 +1070,7 @@ Intro (void)
 static COUNT
 uninit_syreen (void)
 {
+	luaUqm_comm_uninit ();
 	return (0);
 }
 
@@ -1094,31 +1084,23 @@ LOCDATA*
 init_syreen_comm (void)
 {
 	static LOCDATA syreen_desc;
-	LOCDATA *retval;
+ 	LOCDATA *retval;
 	
-	switch (RESOLUTION_FACTOR)
-	{
-		case 2:
-			syreen_desc = syreen_desc_4x;
-			break;
-		case 1:
-			syreen_desc = syreen_desc_4x;
-			break;
-		case 0:
-		default:
-			syreen_desc = syreen_desc_1x;
-			break;
-	}
+	syreen_desc = (RESOLUTION_FACTOR == 0 ? syreen_desc_1x : syreen_desc_4x);
 
 	syreen_desc.init_encounter_func = Intro;
 	syreen_desc.post_encounter_func = post_syreen_enc;
 	syreen_desc.uninit_encounter_func = uninit_syreen;
 
+	luaUqm_comm_init (NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be 
+			// generalised in the future.
+
 	syreen_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
 	syreen_desc.AlienTextBaseline.y = 0;
 	syreen_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
 
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 	retval = &syreen_desc;
 
 	return (retval);
diff -ruNp src.hd/uqm/comm/talkpet/Makeinfo src/uqm/comm/talkpet/Makeinfo
--- src.hd/uqm/comm/talkpet/Makeinfo	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/talkpet/Makeinfo	2017-12-29 00:57:44 -0800
@@ -1 +1,2 @@
 uqm_CFILES="talkpet.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.hd/uqm/comm/talkpet/resinst.h src/uqm/comm/talkpet/resinst.h
--- src.hd/uqm/comm/talkpet/resinst.h	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/talkpet/resinst.h	2017-12-29 00:57:44 -0800
@@ -1,5 +1,10 @@
-#define TALKING_PET_PMAP_ANIM "comm.talkingpet.graphics"
-#define TALKING_PET_FONT "comm.talkingpet.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define TALKING_PET_COLOR_MAP "comm.talkingpet.colortable"
 #define TALKING_PET_CONVERSATION_PHRASES "comm.talkingpet.dialogue"
+#define TALKING_PET_FONT "comm.talkingpet.font"
 #define TALKING_PET_MUSIC "comm.talkingpet.music"
+#define TALKING_PET_PMAP_ANIM "comm.talkingpet.graphics"
+#define TALKING_PET_SCRIPT "comm.talkingpet.script"
diff -ruNp src.hd/uqm/comm/talkpet/strings.h src/uqm/comm/talkpet/strings.h
--- src.hd/uqm/comm/talkpet/strings.h	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/talkpet/strings.h	2017-12-29 00:57:44 -0800
@@ -31,8 +31,7 @@ enum
 	DID_NOTHING,
 	umgah_zombies,
 	WORKS_LIKE_THIS,
-	we_are_vindicator0,
-	we_are_vindicator1,
+	we_are_vindicator,
 	GOOD_FOR_YOU,
 	must_explain_presence,
 	EXPLAIN_NOTHING_MONKEY_BOY,
diff -ruNp src.hd/uqm/comm/talkpet/talkpet.c src/uqm/comm/talkpet/talkpet.c
--- src.hd/uqm/comm/talkpet/talkpet.c	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/talkpet/talkpet.c	2017-12-29 00:57:44 -0800
@@ -20,6 +20,7 @@
 #include "resinst.h"
 #include "strings.h"
 
+#include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
 
 #define STROBE_RATE   10
@@ -214,7 +215,7 @@ static LOCDATA talkpet_desc =
 static void
 ExitConversation (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 	SET_GAME_STATE (SHIP_TO_COMPEL, 0);
 
 	if (PLAYER_SAID (R, compel_urquan))
@@ -472,11 +473,11 @@ CompelPlayer (RESPONSE_REF R)
 		DISABLE_PHRASE (what_do_to_umgah);
 		LastStack = 1;
 	}
-	else if (PLAYER_SAID (R, we_are_vindicator0))
+	else if (PLAYER_SAID (R, we_are_vindicator))
 	{
 		NPCPhrase (GOOD_FOR_YOU);
 
-		DISABLE_PHRASE (we_are_vindicator0);
+		DISABLE_PHRASE (we_are_vindicator);
 		LastStack = 2;
 	}
 	else if (R != 0)
@@ -499,7 +500,7 @@ CompelPlayer (RESPONSE_REF R)
 		{
 			NPCPhrase (CANT_COMPEL);
 
-			SET_GAME_STATE (BATTLE_SEGUE, 1);
+			setSegue (Segue_hostile);
 		}
 
 		return;
@@ -516,35 +517,17 @@ CompelPlayer (RESPONSE_REF R)
 		else
 			pStr[1] = umgah_zombies;
 	}
-	if (PHRASE_ENABLED (we_are_vindicator0))
-	{
-		construct_response (
-				shared_phrase_buf,
-				we_are_vindicator0,
-				GLOBAL_SIS (ShipName),
-				we_are_vindicator1,
-				(UNICODE*)NULL);
-		pStr[2] = we_are_vindicator0;
-	}
+	if (PHRASE_ENABLED (we_are_vindicator))
+		pStr[2] = we_are_vindicator;
 	else
 		pStr[2] = must_explain_presence;
 
 	if (pStr[LastStack])
-	{
-		if (pStr[LastStack] != we_are_vindicator0)
-			Response (pStr[LastStack], CompelPlayer);
-		else
-			DoResponsePhrase (pStr[LastStack], CompelPlayer, shared_phrase_buf);
-	}
+		Response (pStr[LastStack], CompelPlayer);
 	for (i = 0; i < 3; ++i)
 	{
 		if (i != LastStack && pStr[i])
-		{
-			if (pStr[i] != we_are_vindicator0)
-				Response (pStr[i], CompelPlayer);
-			else
-				DoResponsePhrase (pStr[i], CompelPlayer, shared_phrase_buf);
-		}
+			Response (pStr[i], CompelPlayer);
 	}
 	Response (bye_at_umgah, CompelPlayer);
 }
@@ -650,14 +633,14 @@ Intro (void)
 	{
 		NPCPhrase (OUT_TAKES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
 	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_LAST_BATTLE)
 	{
 		SET_GAME_STATE (SHIP_TO_COMPEL, 0);
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 		if (!(GLOBAL (glob_flags) & CYBORG_ENABLED))
 		{
 			NPCPhrase (HUMAN_PEP_TALK);
@@ -680,13 +663,13 @@ Intro (void)
 			else
 				NPCPhrase (SOUP_UP_BOMB);
 
-			SET_GAME_STATE (BATTLE_SEGUE, 0);
+			setSegue (Segue_peace);
 		}
 		else if (GET_GAME_STATE (URQUAN_MESSED_UP))
 		{
 			NPCPhrase (HELLO_AFTER_COMPEL_URQUAN);
 
-			SET_GAME_STATE (BATTLE_SEGUE, 0);
+			setSegue (Segue_peace);
 		}
 		else
 		{
@@ -770,18 +753,18 @@ Intro (void)
 		else if (!GET_GAME_STATE (TAALO_PROTECTOR_ON_SHIP))
 		{
 			SET_GAME_STATE (PLAYER_HYPNOTIZED, 1);
-			SET_GAME_STATE (BATTLE_SEGUE, 0);
+			setSegue (Segue_peace);
 		}
 		else
 		{
 			NPCPhrase (CANT_COMPEL);
 
-			SET_GAME_STATE (BATTLE_SEGUE, 1);
+			setSegue (Segue_hostile);
 		}
 	}
 	else
 	{
-		if (ActivateStarShip (UMGAH_SHIP, SPHERE_TRACKING))
+		if (StartSphereTracking (UMGAH_SHIP))
 		{
 			NPCPhrase (LETS_MAKE_A_DEAL);
 		}
@@ -805,6 +788,7 @@ Intro (void)
 static COUNT
 uninit_talkpet (void)
 {
+	luaUqm_comm_uninit ();
 	return (0);
 }
 
@@ -823,17 +807,21 @@ init_talkpet_comm (void)
 	talkpet_desc.post_encounter_func = post_talkpet_enc;
 	talkpet_desc.uninit_encounter_func = uninit_talkpet;
 
+	luaUqm_comm_init (NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be 
+			// generalised in the future.
+
 	talkpet_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
 	talkpet_desc.AlienTextBaseline.y = 0;
 	talkpet_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
 
 	if (LOBYTE (GLOBAL (CurrentActivity)) != IN_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 
 	retval = &talkpet_desc;
diff -ruNp src.hd/uqm/comm/thradd/Makeinfo src/uqm/comm/thradd/Makeinfo
--- src.hd/uqm/comm/thradd/Makeinfo	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/thradd/Makeinfo	2017-12-29 00:57:44 -0800
@@ -1 +1,2 @@
 uqm_CFILES="thraddc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.hd/uqm/comm/thradd/resinst.h src/uqm/comm/thradd/resinst.h
--- src.hd/uqm/comm/thradd/resinst.h	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/thradd/resinst.h	2017-12-29 00:57:44 -0800
@@ -1,5 +1,10 @@
-#define THRADD_PMAP_ANIM "comm.thraddash.graphics"
-#define THRADD_FONT "comm.thraddash.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define THRADD_COLOR_MAP "comm.thraddash.colortable"
 #define THRADD_CONVERSATION_PHRASES "comm.thraddash.dialogue"
+#define THRADD_FONT "comm.thraddash.font"
 #define THRADD_MUSIC "comm.thraddash.music"
+#define THRADD_PMAP_ANIM "comm.thraddash.graphics"
+#define THRADD_SCRIPT "comm.thraddash.script"
diff -ruNp src.hd/uqm/comm/thradd/strings.h src/uqm/comm/thradd/strings.h
--- src.hd/uqm/comm/thradd/strings.h	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/thradd/strings.h	2017-12-29 00:57:44 -0800
@@ -160,8 +160,7 @@ enum
 	OK_CULTURE_20,
 	fat,
 	OK_FAT,
-	the_slave_empire0,
-	the_slave_empire1,
+	the_slave_empire,
 	OK_SLAVE,
 	FAT_JERKS,
 	CULTURE,
@@ -169,8 +168,7 @@ enum
 	name_1,
 	name_2,
 	name_3,
-	name_40,
-	name_41,
+	name_4,
 	HAVING_FUN_WITH_ILWRATH_1,
 	HAVING_FUN_WITH_ILWRATH_2,
 	GO_AWAY_FIGHTING_ILWRATH_1,
diff -ruNp src.hd/uqm/comm/thradd/thraddc.c src/uqm/comm/thradd/thraddc.c
--- src.hd/uqm/comm/thradd/thraddc.c	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/thradd/thraddc.c	2017-12-29 00:57:44 -0800
@@ -19,7 +19,8 @@
 #include "../commall.h"
 #include "resinst.h"
 #include "strings.h"
-
+#include "../../../options.h"
+#include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
 #include "uqm/gameev.h"
 
@@ -240,7 +241,7 @@ LikeYouPhrase (BYTE which_phrase)
 static void
 ExitConversation (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 1);
+	setSegue (Segue_hostile);
 
 	if (PLAYER_SAID (R, bye_hostile_2))
 		NPCPhrase (GOODBYE_HOSTILE_2);
@@ -262,7 +263,7 @@ ExitConversation (RESPONSE_REF R)
 	{
 		NPCPhrase (GOOD_IDEA);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		AddEvent (RELATIVE_EVENT, 0, 0, 0, ADVANCE_THRADD_MISSION);
 		SET_GAME_STATE (THRADD_STACK_1, 5);
 	}
@@ -290,14 +291,14 @@ ExitConversation (RESPONSE_REF R)
 				break;
 		}
 		SET_GAME_STATE (THRADD_STACK_1, NumVisits);
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else if (PLAYER_SAID (R, may_i_land))
 	{
 		NPCPhrase (SURE_LAND);
 
 		SET_GAME_STATE (HELIX_UNPROTECTED, 1);
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else if (PLAYER_SAID (R, demand_to_land))
 		NPCPhrase (NO_DEMAND);
@@ -331,7 +332,7 @@ ExitConversation (RESPONSE_REF R)
 		}
 		NPCPhrase (WORK_TO_DO);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 }
 
@@ -444,7 +445,7 @@ ThraddDemeanor (RESPONSE_REF R)
 
 		SET_GAME_STATE (THRADD_CULTURE, 2);
 	}
-	else if (PLAYER_SAID (R, the_slave_empire0))
+	else if (PLAYER_SAID (R, the_slave_empire))
 	{
 		SET_GAME_STATE (THRADD_CULTURE, 3);
 
@@ -487,16 +488,9 @@ ThraddCulture (RESPONSE_REF R)
 	}
 	NPCPhrase (WHAT_NAME_FOR_CULTURE);
 
-	construct_response (
-			shared_phrase_buf,
-			the_slave_empire0,
-			GLOBAL_SIS (CommanderName),
-			the_slave_empire1,
-			(UNICODE*)NULL);
-
 	Response (you_decide, ThraddDemeanor);
 	Response (fat, ThraddDemeanor);
-	DoResponsePhrase (the_slave_empire0, ThraddDemeanor, shared_phrase_buf);
+	Response (the_slave_empire, ThraddDemeanor);
 }
 
 static void
@@ -506,7 +500,7 @@ ThraddWorship (RESPONSE_REF R)
 	SET_GAME_STATE (THRADD_VISITS, 0);
 	SET_GAME_STATE (THRADD_MANNER, 1);
 	SET_GAME_STATE (THRADD_STACK_1, 0);
-	ActivateStarShip (THRADDASH_SHIP, SET_ALLIED);
+	SetRaceAllied (THRADDASH_SHIP, TRUE);
 
 	Response (be_polite, ThraddCulture);
 	Response (speak_pig_latin, ThraddCulture);
@@ -703,11 +697,11 @@ Intro (void)
 	{
 		NPCPhrase (OUT_TAKES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
-	if (GET_GAME_STATE (AQUA_HELIX) && ThraddPtr->allied_state != GOOD_GUY)
+	if (GET_GAME_STATE (AQUA_HELIX) && (ThraddPtr->allied_state != GOOD_GUY || !optThraddStory))
 	{
 		NumVisits = GET_GAME_STATE (HELIX_VISITS);
 		switch (NumVisits++)
@@ -722,7 +716,7 @@ Intro (void)
 		}
 		SET_GAME_STATE (HELIX_VISITS, NumVisits);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (GET_GAME_STATE (ILWRATH_FIGHT_THRADDASH))
 	{
@@ -755,7 +749,7 @@ Intro (void)
 		}
 		SET_GAME_STATE (THRADD_VISITS, NumVisits);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else if (GET_GAME_STATE (THRADD_MANNER))
 	{
@@ -920,6 +914,7 @@ Intro (void)
 static COUNT
 uninit_thradd (void)
 {
+	luaUqm_comm_uninit ();
 	return (0);
 }
 
@@ -938,6 +933,10 @@ init_thradd_comm (void)
 	thradd_desc.post_encounter_func = post_thradd_enc;
 	thradd_desc.uninit_encounter_func = uninit_thradd;
 
+	luaUqm_comm_init (NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	thradd_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
 	thradd_desc.AlienTextBaseline.y = 0;
 	thradd_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
@@ -945,11 +944,11 @@ init_thradd_comm (void)
 	if (GET_GAME_STATE (THRADD_MANNER)
 			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	retval = &thradd_desc;
 
diff -ruNp src.hd/uqm/comm/umgah/Makeinfo src/uqm/comm/umgah/Makeinfo
--- src.hd/uqm/comm/umgah/Makeinfo	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/umgah/Makeinfo	2017-12-29 00:57:44 -0800
@@ -1 +1,2 @@
 uqm_CFILES="umgahc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.hd/uqm/comm/umgah/resinst.h src/uqm/comm/umgah/resinst.h
--- src.hd/uqm/comm/umgah/resinst.h	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/umgah/resinst.h	2017-12-29 00:57:44 -0800
@@ -1,5 +1,10 @@
-#define UMGAH_PMAP_ANIM "comm.umgah.graphics"
-#define UMGAH_FONT "comm.umgah.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define UMGAH_COLOR_MAP "comm.umgah.colortable"
 #define UMGAH_CONVERSATION_PHRASES "comm.umgah.dialogue"
+#define UMGAH_FONT "comm.umgah.font"
 #define UMGAH_MUSIC "comm.umgah.music"
+#define UMGAH_PMAP_ANIM "comm.umgah.graphics"
+#define UMGAH_SCRIPT "comm.umgah.script"
diff -ruNp src.hd/uqm/comm/umgah/strings.h src/uqm/comm/umgah/strings.h
--- src.hd/uqm/comm/umgah/strings.h	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/umgah/strings.h	2017-12-29 00:57:44 -0800
@@ -93,9 +93,7 @@ enum
 	YES_VERY_EVIL,
 	give_up_or_die,
 	NOT_GIVE_UP,
-	we_vindicator0,
-	we_vindicator1,
-	we_vindicator2,
+	we_vindicator,
 	GOOD_FOR_YOU_1,
 	come_in_peace,
 	GOOD_FOR_YOU_2,
diff -ruNp src.hd/uqm/comm/umgah/umgahc.c src/uqm/comm/umgah/umgahc.c
--- src.hd/uqm/comm/umgah/umgahc.c	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/umgah/umgahc.c	2017-12-29 00:57:44 -0800
@@ -20,6 +20,7 @@
 #include "resinst.h"
 #include "strings.h"
 
+#include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
 
 
@@ -199,13 +200,13 @@ static LOCDATA umgah_desc =
 static void
 CombatIsInevitable (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 1);
+	setSegue (Segue_hostile);
 
 	if (PLAYER_SAID (R, bye_zombie))
 	{
 		NPCPhrase (GOODBYE_ZOMBIE);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else if (PLAYER_SAID (R, bye_pre_zombie))
 		NPCPhrase (GOODBYE_PRE_ZOMBIE);
@@ -236,14 +237,14 @@ CombatIsInevitable (RESPONSE_REF R)
 	{
 		NPCPhrase (GOODBYE_UNKNOWN);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else if (PLAYER_SAID (R, bye_post_zombie))
 	{
 		NPCPhrase (FUNNY_IDEA);
 
 		AlienTalkSegue ((COUNT)~0);
-		ActivateStarShip (UMGAH_SHIP, 4);
+		AddEscortShips (UMGAH_SHIP, 4);
 		SET_GAME_STATE (UMGAH_HOSTILE, 1);
 	}
 }
@@ -301,11 +302,11 @@ Zombies (RESPONSE_REF R)
 			DISABLE_PHRASE (evil_blobbies);
 			LastStack = 0;
 		}
-		else if (PLAYER_SAID (R, we_vindicator0))
+		else if (PLAYER_SAID (R, we_vindicator))
 		{
 			NPCPhrase (GOOD_FOR_YOU_1);
 
-			DISABLE_PHRASE (we_vindicator0);
+			DISABLE_PHRASE (we_vindicator);
 			LastStack = 1;
 		}
 		else if (PLAYER_SAID (R, come_in_peace))
@@ -347,14 +348,14 @@ Zombies (RESPONSE_REF R)
 		{
 			NPCPhrase (NOT_GIVE_UP);
 
-			SET_GAME_STATE (BATTLE_SEGUE, 1);
+			setSegue (Segue_hostile);
 			return;
 		}
 		else if (PLAYER_SAID (R, arilou_told_us))
 		{
 			NPCPhrase (THEN_DIE);
 
-			SET_GAME_STATE (BATTLE_SEGUE, 1);
+			setSegue (Segue_hostile);
 			SET_GAME_STATE (KNOW_UMGAH_ZOMBIES, 1);
 			SET_GAME_STATE (UMGAH_VISITS, 0);
 			return;
@@ -365,17 +366,8 @@ Zombies (RESPONSE_REF R)
 		else
 			pStr[0] = give_up_or_die;
 
-		if (PHRASE_ENABLED (we_vindicator0))
-		{
-			construct_response (shared_phrase_buf,
-					we_vindicator0,
-					GLOBAL_SIS (CommanderName),
-					we_vindicator1,
-					GLOBAL_SIS (ShipName),
-					we_vindicator2,
-					(UNICODE*)NULL);
-			pStr[1] = we_vindicator0;
-		}
+		if (PHRASE_ENABLED (we_vindicator))
+			pStr[1] = we_vindicator;
 		else if (PHRASE_ENABLED (come_in_peace))
 			pStr[1] = come_in_peace;
 
@@ -392,21 +384,11 @@ Zombies (RESPONSE_REF R)
 			pStr[3] = arilou_told_us;
 
 		if (pStr[LastStack])
-		{
-			if (pStr[LastStack] != we_vindicator0)
-				Response (pStr[LastStack], Zombies);
-			else
-				DoResponsePhrase (pStr[LastStack], Zombies, shared_phrase_buf);
-		}
+			Response (pStr[LastStack], Zombies);
 		for (i = 0; i < 4; ++i)
 		{
 			if (i != LastStack && pStr[i])
-			{
-				if (pStr[i] != we_vindicator0)
-					Response (pStr[i], Zombies);
-				else
-					DoResponsePhrase (pStr[i], Zombies, shared_phrase_buf);
-			}
+				Response (pStr[i], Zombies);
 		}
 		Response (bye_zombie, CombatIsInevitable);
 	}
@@ -521,6 +503,7 @@ Intro (void)
 {
 	BYTE NumVisits;
 
+
 	if (LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE) {
 		NPCPhrase (OUT_TAKES);
 		SET_GAME_STATE (BATTLE_SEGUE, 0);
@@ -545,7 +528,7 @@ Intro (void)
 		}
 		SET_GAME_STATE (UMGAH_VISITS, NumVisits);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (GET_GAME_STATE (UMGAH_ZOMBIE_BLOBBIES))
 	{
@@ -569,7 +552,7 @@ Intro (void)
 					break;
 			}
 
-			SET_GAME_STATE (BATTLE_SEGUE, 1);
+			setSegue (Segue_hostile);
 		}
 		else if (GET_GAME_STATE (KNOW_UMGAH_ZOMBIES))
 		{
@@ -590,7 +573,7 @@ Intro (void)
 					break;
 			}
 
-			SET_GAME_STATE (BATTLE_SEGUE, 1);
+			setSegue (Segue_hostile);
 		}
 		else
 		{
@@ -685,7 +668,7 @@ Intro (void)
 			}
 			SET_GAME_STATE (UMGAH_VISITS, NumVisits);
 
-			SET_GAME_STATE (BATTLE_SEGUE, 0);
+			setSegue (Segue_peace);
 		}
 	}
 }
@@ -693,6 +676,7 @@ Intro (void)
 static COUNT
 uninit_umgah (void)
 {
+	luaUqm_comm_uninit ();
 	return (0);
 }
 
@@ -714,6 +698,10 @@ init_umgah_comm (void)
 	umgah_desc.post_encounter_func = post_umgah_enc;
 	umgah_desc.uninit_encounter_func = uninit_umgah;
 
+	luaUqm_comm_init (NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	umgah_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
 	umgah_desc.AlienTextBaseline.y = 0;
 	umgah_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
@@ -721,11 +709,11 @@ init_umgah_comm (void)
 	if ((GET_GAME_STATE (TALKING_PET) && !GET_GAME_STATE (UMGAH_HOSTILE))
 			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	retval = &umgah_desc;
 
diff -ruNp src.hd/uqm/comm/urquan/Makeinfo src/uqm/comm/urquan/Makeinfo
--- src.hd/uqm/comm/urquan/Makeinfo	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/urquan/Makeinfo	2017-12-29 00:57:44 -0800
@@ -1 +1,2 @@
 uqm_CFILES="urquanc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.hd/uqm/comm/urquan/resinst.h src/uqm/comm/urquan/resinst.h
--- src.hd/uqm/comm/urquan/resinst.h	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/urquan/resinst.h	2017-12-29 00:57:44 -0800
@@ -1,5 +1,10 @@
-#define URQUAN_PMAP_ANIM "comm.urquan.graphics"
-#define URQUAN_FONT "comm.urquan.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define URQUAN_COLOR_MAP "comm.urquan.colortable"
 #define URQUAN_CONVERSATION_PHRASES "comm.urquan.dialogue"
+#define URQUAN_FONT "comm.urquan.font"
 #define URQUAN_MUSIC "comm.urquan.music"
+#define URQUAN_PMAP_ANIM "comm.urquan.graphics"
+#define URQUAN_SCRIPT "comm.urquan.script"
diff -ruNp src.hd/uqm/comm/urquan/urquanc.c src/uqm/comm/urquan/urquanc.c
--- src.hd/uqm/comm/urquan/urquanc.c	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/urquan/urquanc.c	2017-12-29 00:57:45 -0800
@@ -124,7 +124,7 @@ static LOCDATA urquan_desc =
 static void
 CombatIsInevitable (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 1);
+	setSegue (Segue_hostile);
 
 	if (PLAYER_SAID (R, you_must_surrender))
 		NPCPhrase (NOPE);
@@ -160,9 +160,7 @@ CombatIsInevitable (RESPONSE_REF R)
 	{
 		NPCPhrase (GOOD_CHOICE);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
-		GLOBAL_SIS (CrewEnlisted) = (COUNT)~0;
-		GLOBAL (CurrentActivity) |= CHECK_RESTART;
+		setSegue (Segue_defeat);
 	}
 	else if (PLAYER_SAID (R, like_to_leave))
 		NPCPhrase (INDEPENDENCE_IS_BAD);
@@ -170,7 +168,7 @@ CombatIsInevitable (RESPONSE_REF R)
 	{
 		NPCPhrase (GOODBYE_WARS_OVER);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else if (PLAYER_SAID (R, bye_sub_hypno))
 		NPCPhrase (GOODBYE_AND_DIE_SUB_HYPNO);
@@ -185,7 +183,7 @@ CombatIsInevitable (RESPONSE_REF R)
 	{
 		NPCPhrase (BAD_NEWS);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		SET_GAME_STATE (URQUAN_HYPNO_VISITS, 1);
 	}
 	else if (PLAYER_SAID (R, falling_asleep)
@@ -193,7 +191,7 @@ CombatIsInevitable (RESPONSE_REF R)
 	{
 		NPCPhrase (SOUNDS_FAMILIAR);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		SET_GAME_STATE (URQUAN_HYPNO_VISITS, 1);
 	}
 }
@@ -416,11 +414,11 @@ Intro (void)
 	{
 		NPCPhrase (OUT_TAKES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
-	GrpOffs = GET_GAME_STATE_32 (URQUAN_PROBE_GRPOFFS0);
+	GrpOffs = GET_GAME_STATE (URQUAN_PROBE_GRPOFFS);
 	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
 			&& GLOBAL (BattleGroupRef)
 			&& GLOBAL (BattleGroupRef) == GrpOffs)
@@ -444,18 +442,18 @@ Intro (void)
 			SET_GAME_STATE (URQUAN_SENSES_EVIL, 1);
 		}
 
-		GrpOffs = GET_GAME_STATE_32 (COLONY_GRPOFFS0);
+		GrpOffs = GET_GAME_STATE (COLONY_GRPOFFS);
 		if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
 				&& GLOBAL (BattleGroupRef)
 				&& GLOBAL (BattleGroupRef) == GrpOffs)
 		{
 			NPCPhrase (CAUGHT_YA);
 
-			SET_GAME_STATE (BATTLE_SEGUE, 1);
+			setSegue (Segue_hostile);
 			return;
 		}
 
-		GrpOffs = GET_GAME_STATE_32 (SAMATRA_GRPOFFS0);
+		GrpOffs = GET_GAME_STATE (SAMATRA_GRPOFFS);
 		if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
 				&& GLOBAL (BattleGroupRef)
 				&& GLOBAL (BattleGroupRef) == GrpOffs)
@@ -463,7 +461,7 @@ Intro (void)
 			NPCPhrase (HELLO_SAMATRA);
 
 			SET_GAME_STATE (AWARE_OF_SAMATRA, 1);
-			SET_GAME_STATE (BATTLE_SEGUE, 1);
+			setSegue (Segue_hostile);
 		}
 		else
 		{
@@ -502,7 +500,7 @@ Intro (void)
 						break;
 					case 1:
 						NPCPhrase (SUBSEQUENT_FLEE_HUMAN);
-						SET_GAME_STATE (BATTLE_SEGUE, 0);
+						setSegue (Segue_peace);
 						--NumVisits;
 						break;
 				}
@@ -539,18 +537,18 @@ init_urquan_comm (void)
 	urquan_desc.AlienTextBaseline.y = 0;
 	urquan_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
 
-	GrpOffs = GET_GAME_STATE_32 (URQUAN_PROBE_GRPOFFS0);
+	GrpOffs = GET_GAME_STATE (URQUAN_PROBE_GRPOFFS);
 	if (GET_GAME_STATE (PLAYER_HYPNOTIZED)
 			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE
 			|| (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
 			&& GLOBAL (BattleGroupRef)
 			&& GLOBAL (BattleGroupRef) == GrpOffs))
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	retval = &urquan_desc;
 
diff -ruNp src.hd/uqm/comm/utwig/Makeinfo src/uqm/comm/utwig/Makeinfo
--- src.hd/uqm/comm/utwig/Makeinfo	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/utwig/Makeinfo	2017-12-29 00:57:45 -0800
@@ -1 +1,2 @@
 uqm_CFILES="utwigc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.hd/uqm/comm/utwig/resinst.h src/uqm/comm/utwig/resinst.h
--- src.hd/uqm/comm/utwig/resinst.h	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/utwig/resinst.h	2017-12-29 00:57:45 -0800
@@ -1,6 +1,11 @@
-#define UTWIG_PMAP_ANIM "comm.utwig.graphics"
-#define UTWIG_FONT "comm.utwig.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define UTWIG_COLOR_MAP "comm.utwig.colortable"
 #define UTWIG_CONVERSATION_PHRASES "comm.utwig.dialogue"
+#define UTWIG_FONT "comm.utwig.font"
 #define UTWIG_MUSIC "comm.utwig.music"
+#define UTWIG_PMAP_ANIM "comm.utwig.graphics"
+#define UTWIG_SCRIPT "comm.utwig.script"
 #define UTWIG_ULTRON_MUSIC "comm.utwig.ultron.music"
diff -ruNp src.hd/uqm/comm/utwig/strings.h src/uqm/comm/utwig/strings.h
--- src.hd/uqm/comm/utwig/strings.h	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/utwig/strings.h	2017-12-29 00:57:45 -0800
@@ -57,9 +57,7 @@ enum
 	TAUNT_US_BUT_WE_LOOK,
 	TRICKED_US_1,
 	TRICKED_US_2,
-	we_are_vindicator0,
-	we_are_vindicator1,
-	we_are_vindicator2,
+	we_are_vindicator,
 	WOULD_BE_HAPPY_BUT,
 	why_sad,
 	ULTRON_BROKE,
@@ -89,8 +87,7 @@ enum
 	name_1,
 	name_2,
 	name_3,
-	name_40,
-	name_41,
+	name_4,
 	HAPPY_DAYS,
 	OK_ATTACK_KOHRAH,
 	whats_up_after_space,
diff -ruNp src.hd/uqm/comm/utwig/utwigc.c src/uqm/comm/utwig/utwigc.c
--- src.hd/uqm/comm/utwig/utwigc.c	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/utwig/utwigc.c	2017-12-29 00:57:45 -0800
@@ -20,6 +20,7 @@
 #include "resinst.h"
 #include "strings.h"
 
+#include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
 #include "uqm/gameev.h"
 
@@ -201,7 +202,7 @@ static LOCDATA utwig_desc =
 static void
 ExitConversation (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 
 	if (PLAYER_SAID (R, bye_neutral))
 		NPCPhrase (GOODBYE_NEUTRAL);
@@ -217,7 +218,7 @@ ExitConversation (RESPONSE_REF R)
 	{
 		NPCPhrase (GUARDS_FIGHT);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, got_ultron)
 			|| PLAYER_SAID (R, hey_wait_got_ultron))
@@ -245,7 +246,7 @@ ExitConversation (RESPONSE_REF R)
 						{
 							NPCPhrase (TRICKED_US_1);
 
-							SET_GAME_STATE (BATTLE_SEGUE, 1);
+							setSegue (Segue_hostile);
 						}
 						break;
 					case 1:
@@ -255,7 +256,7 @@ ExitConversation (RESPONSE_REF R)
 						{
 							NPCPhrase (TRICKED_US_2);
 
-							SET_GAME_STATE (BATTLE_SEGUE, 1);
+							setSegue (Segue_hostile);
 						}
 						break;
 				}
@@ -289,22 +290,22 @@ ExitConversation (RESPONSE_REF R)
 				SET_GAME_STATE (SUPOX_HOSTILE, 0);
 				SET_GAME_STATE (UTWIG_HOSTILE, 0);
 
-				ActivateStarShip (UTWIG_SHIP, SET_ALLIED);
-				ActivateStarShip (SUPOX_SHIP, SET_ALLIED);
+				SetRaceAllied (UTWIG_SHIP, TRUE);
+				SetRaceAllied (SUPOX_SHIP, TRUE);
 			}
 		}
 	}
 	else if (PLAYER_SAID (R, can_you_help))
 	{
 		NPCPhrase (HOW_HELP);
-		if (ActivateStarShip (UTWIG_SHIP, FEASIBILITY_STUDY) == 0)
+		if (EscortFeasibilityStudy (UTWIG_SHIP) == 0)
 			NPCPhrase (DONT_NEED);
 		else
 		{
 			NPCPhrase (HAVE_4_SHIPS);
 
 			AlienTalkSegue ((COUNT)~0);
-			ActivateStarShip (UTWIG_SHIP, 4);
+			AddEscortShips (UTWIG_SHIP, 4);
 		}
 	}
 }
@@ -391,7 +392,7 @@ AlliedHome (RESPONSE_REF R)
 		Response (what_now_homeworld, AlliedHome);
 	if (PHRASE_ENABLED (how_is_ultron))
 		Response (how_is_ultron, AlliedHome);
-	if (NumVisits == 0)
+	if (NumVisits == 0 && EscortFeasibilityStudy (UTWIG_SHIP) != 0)
 		Response (can_you_help, ExitConversation);
 	Response (bye_allied_homeworld, ExitConversation);
 }
@@ -476,7 +477,7 @@ NeutralUtwig (RESPONSE_REF R)
 
 	LastStack = 0;
 	pStr[0] = pStr[1] = pStr[2] = pStr[3] = 0;
-	if (PLAYER_SAID (R, we_are_vindicator0))
+	if (PLAYER_SAID (R, we_are_vindicator))
 	{
 		NPCPhrase (WOULD_BE_HAPPY_BUT);
 
@@ -498,7 +499,7 @@ NeutralUtwig (RESPONSE_REF R)
 	{
 		NPCPhrase (MOCK_OUR_PAIN);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 		SET_GAME_STATE (UTWIG_STACK1, 4);
 		SET_GAME_STATE (UTWIG_HOSTILE, 1);
 		SET_GAME_STATE (UTWIG_INFO, 0);
@@ -526,7 +527,7 @@ NeutralUtwig (RESPONSE_REF R)
 		NPCPhrase (ABOUT_US_2);
 
 		LastStack = 2;
-		ActivateStarShip (SUPOX_SHIP, SPHERE_TRACKING);
+		StartSphereTracking (SUPOX_SHIP);
 		SET_GAME_STATE (UTWIG_WAR_NEWS, 2);
 	}
 	else if (PLAYER_SAID (R, what_about_you_3))
@@ -552,20 +553,7 @@ NeutralUtwig (RESPONSE_REF R)
 	switch (GET_GAME_STATE (UTWIG_STACK1))
 	{
 		case 0:
-			{
-				UNICODE buf[ALLIANCE_NAME_BUFSIZE];
-
-				GetAllianceName (buf, name_1);
-				construct_response (
-						shared_phrase_buf,
-						we_are_vindicator0,
-						GLOBAL_SIS (CommanderName),
-						we_are_vindicator1,
-						buf,
-						we_are_vindicator2,
-						(UNICODE*)NULL);
-			}
-			pStr[0] = we_are_vindicator0;
+			pStr[0] = we_are_vindicator;
 			break;
 		case 1:
 			pStr[0] = why_sad;
@@ -601,21 +589,11 @@ NeutralUtwig (RESPONSE_REF R)
 	}
 
 	if (pStr[LastStack])
-	{
-		if (pStr[LastStack] != we_are_vindicator0)
-			Response (pStr[LastStack], NeutralUtwig);
-		else
-			DoResponsePhrase (pStr[LastStack], NeutralUtwig, shared_phrase_buf);
-	}
+		Response (pStr[LastStack], NeutralUtwig);
 	for (i = 0; i < 4; ++i)
 	{
 		if (i != LastStack && pStr[i])
-		{
-			if (pStr[i] != we_are_vindicator0)
-				Response (pStr[i], NeutralUtwig);
-			else
-				DoResponsePhrase (pStr[i], NeutralUtwig, shared_phrase_buf);
-		}
+			Response (pStr[i], NeutralUtwig);
 	}
 	if (GET_GAME_STATE (ULTRON_CONDITION))
 		Response (got_ultron, ExitConversation);
@@ -652,7 +630,7 @@ BombWorld (RESPONSE_REF R)
 	{
 		NPCPhrase (GUARDS_FIGHT);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 		SET_GAME_STATE (UTWIG_HOSTILE, 1);
 		SET_GAME_STATE (UTWIG_INFO, 0);
 		SET_GAME_STATE (UTWIG_HOME_VISITS, 0);
@@ -746,7 +724,7 @@ Intro (void)
 	{
 		NPCPhrase (OUT_TAKES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
@@ -801,14 +779,14 @@ Intro (void)
 		if (!GET_GAME_STATE (ULTRON_CONDITION)
 				|| (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 6)))
 		{
-			SET_GAME_STATE (BATTLE_SEGUE, 1);
+			setSegue (Segue_hostile);
 		}
 		else
 		{
 			Response (hey_wait_got_ultron, ExitConversation);
 		}
 	}
-	else if (ActivateStarShip (UTWIG_SHIP, CHECK_ALLIANCE) == GOOD_GUY)
+	else if (CheckAlliance (UTWIG_SHIP) == GOOD_GUY)
 	{
 		if (GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 7))
 		{
@@ -950,6 +928,7 @@ Intro (void)
 static COUNT
 uninit_utwig (void)
 {
+	luaUqm_comm_uninit ();
 	return (0);
 }
 
@@ -968,6 +947,10 @@ init_utwig_comm (void)
 	utwig_desc.post_encounter_func = post_utwig_enc;
 	utwig_desc.uninit_encounter_func = uninit_utwig;
 
+	luaUqm_comm_init (NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	utwig_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
 	utwig_desc.AlienTextBaseline.y = RES_SIS_SCALE(70);
 	utwig_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
@@ -985,11 +968,11 @@ init_utwig_comm (void)
 	if (GET_GAME_STATE (UTWIG_HAVE_ULTRON)
 			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	retval = &utwig_desc;
 
diff -ruNp src.hd/uqm/comm/vux/Makeinfo src/uqm/comm/vux/Makeinfo
--- src.hd/uqm/comm/vux/Makeinfo	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/vux/Makeinfo	2017-12-29 00:57:45 -0800
@@ -1 +1,2 @@
 uqm_CFILES="vuxc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.hd/uqm/comm/vux/resinst.h src/uqm/comm/vux/resinst.h
--- src.hd/uqm/comm/vux/resinst.h	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/vux/resinst.h	2017-12-29 00:57:45 -0800
@@ -1,5 +1,10 @@
-#define VUX_PMAP_ANIM "comm.vux.graphics"
-#define VUX_FONT "comm.vux.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define VUX_COLOR_MAP "comm.vux.colortable"
 #define VUX_CONVERSATION_PHRASES "comm.vux.dialogue"
+#define VUX_FONT "comm.vux.font"
 #define VUX_MUSIC "comm.vux.music"
+#define VUX_PMAP_ANIM "comm.vux.graphics"
+#define VUX_SCRIPT "comm.vux.script"
diff -ruNp src.hd/uqm/comm/vux/vuxc.c src/uqm/comm/vux/vuxc.c
--- src.hd/uqm/comm/vux/vuxc.c	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/vux/vuxc.c	2017-12-29 00:57:45 -0800
@@ -395,7 +395,7 @@ CombatIsInevitable (RESPONSE_REF R)
 {
 	BYTE NumVisits;
 
-	SET_GAME_STATE (BATTLE_SEGUE, 1);
+	setSegue (Segue_hostile);
 
 	if (PLAYER_SAID (R, ok_take_beast))
 	{
@@ -403,15 +403,12 @@ CombatIsInevitable (RESPONSE_REF R)
 		NPCPhrase (FOOL_AIEE1);
 
 		AlienTalkSegue (1);
-		
-		if (RESOLUTION_FACTOR == 0)
-		{
+
+		if (RESOLUTION_FACTOR == 0) {
 			XFormColorMap (GetColorMapAddress (
 					SetAbsColorMapIndex (CommData.AlienColorMap, 1)
 					), ONE_SECOND / 4);
-		}
-		else
-		{
+		} else {
 			COUNT i = 0;
 			COUNT limit = CommData.NumAnimations - 1;
 			
@@ -424,12 +421,12 @@ CombatIsInevitable (RESPONSE_REF R)
 				
 			CommData.AlienTalkDesc.AnimFlags |= PAUSE_TALKING;
 		}
-		
+
 		AlienTalkSegue ((COUNT)~0);
 
 		SET_GAME_STATE (VUX_BEAST_ON_SHIP, 0);
 		SET_GAME_STATE (ZEX_IS_DEAD, 1);
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else if (PLAYER_SAID (R, try_any_way))
 	{
@@ -499,7 +496,7 @@ CombatIsInevitable (RESPONSE_REF R)
 	{
 		NPCPhrase (GOODBYE_ZEX);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
@@ -585,13 +582,13 @@ Menagerie (RESPONSE_REF R)
 	{
 		NPCPhrase (FIGHT_AGAIN);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, regardless))
 	{
 		NPCPhrase (THEN_FIGHT);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 		SET_GAME_STATE (ZEX_STACK_3, 2);
 		SET_GAME_STATE (ZEX_VISITS, 0);
 	}
@@ -905,7 +902,7 @@ Intro (void)
 	{
 		NPCPhrase (OUT_TAKES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
@@ -980,21 +977,9 @@ LOCDATA*
 init_vux_comm (void)
 {
 	static LOCDATA vux_desc;
-	LOCDATA *retval;
+ 	LOCDATA *retval;
 	
-	switch (RESOLUTION_FACTOR)
-	{
-		case 2:
-			vux_desc = vux_desc_4x;
-			break;
-		case 1:
-			vux_desc = vux_desc_4x;
-			break;
-		case 0:
-		default:
-			vux_desc = vux_desc_1x;
-			break;
-	}
+	vux_desc = (RESOLUTION_FACTOR == 0 ? vux_desc_1x : vux_desc_4x);
 
 	vux_desc.init_encounter_func = Intro;
 	vux_desc.post_encounter_func = post_vux_enc;
@@ -1008,11 +993,11 @@ init_vux_comm (void)
 	if ((GET_GAME_STATE (GLOBAL_FLAGS_AND_DATA) & (1 << 6))
 			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	retval = &vux_desc;
 
diff -ruNp src.hd/uqm/comm/yehat/Makeinfo src/uqm/comm/yehat/Makeinfo
--- src.hd/uqm/comm/yehat/Makeinfo	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/yehat/Makeinfo	2017-12-29 00:57:45 -0800
@@ -1 +1,2 @@
 uqm_CFILES="yehatc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.hd/uqm/comm/yehat/resinst.h src/uqm/comm/yehat/resinst.h
--- src.hd/uqm/comm/yehat/resinst.h	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/yehat/resinst.h	2017-12-29 00:57:45 -0800
@@ -1,7 +1,12 @@
-#define YEHAT_PMAP_ANIM "comm.yehat.graphics"
-#define YEHAT_FONT "comm.yehat.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define REBEL_CONVERSATION_PHRASES "comm.yehat.rebel.dialogue"
+#define REBEL_MUSIC "comm.yehat.rebel.music"
 #define YEHAT_COLOR_MAP "comm.yehat.colortable"
 #define YEHAT_CONVERSATION_PHRASES "comm.yehat.dialogue"
-#define REBEL_MUSIC "comm.yehat.rebel.music"
+#define YEHAT_FONT "comm.yehat.font"
 #define YEHAT_MUSIC "comm.yehat.music"
+#define YEHAT_PMAP_ANIM "comm.yehat.graphics"
+#define YEHAT_SCRIPT "comm.yehat.script"
diff -ruNp src.hd/uqm/comm/yehat/strings.h src/uqm/comm/yehat/strings.h
--- src.hd/uqm/comm/yehat/strings.h	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/yehat/strings.h	2017-12-29 00:57:45 -0800
@@ -27,10 +27,7 @@ enum
 	whats_up_homeworld,
 	GENERAL_INFO_HOMEWORLD_1,
 	GENERAL_INFO_HOMEWORLD_2,
-	i_demand_you_ally_homeworld0,
-	i_demand_you_ally_homeworld1,
-	i_demand_you_ally_homeworld2,
-	i_demand_you_ally_homeworld3,
+	i_demand_you_ally_homeworld,
 	ENEMY_MUST_DIE,
 	at_least_help_us_homeworld,
 	NO_HELP_ENEMY,
@@ -53,10 +50,7 @@ enum
 	GENERAL_INFO_SPACE_3,
 	whats_up_space_4,
 	GENERAL_INFO_SPACE_4,
-	i_demand_you_ally_space0,
-	i_demand_you_ally_space1,
-	i_demand_you_ally_space2,
-	i_demand_you_ally_space3,
+	i_demand_you_ally_space,
 	WE_CANNOT_1,
 	obligation,
 	WE_CANNOT_2,
@@ -94,8 +88,7 @@ enum
 	name_1,
 	name_2,
 	name_3,
-	name_40,
-	name_41,
+	name_4,
 	OUT_TAKES,
 };
 
diff -ruNp src.hd/uqm/comm/yehat/yehatc.c src/uqm/comm/yehat/yehatc.c
--- src.hd/uqm/comm/yehat/yehatc.c	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/yehat/yehatc.c	2017-12-29 00:57:45 -0800
@@ -20,6 +20,7 @@
 #include "resinst.h"
 #include "strings.h"
 
+#include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
 #include "uqm/gameev.h"
 #include "libs/mathlib.h"
@@ -192,7 +193,6 @@ static LOCDATA yehat_desc_1x =
 	NULL,
 };
 
-
 static LOCDATA yehat_desc_2x =
 {
 	YEHAT_CONVERSATION, /* AlienConv */
@@ -498,13 +498,13 @@ static LOCDATA yehat_desc_4x =
 static void
 ExitConversation (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 1);
+	setSegue (Segue_hostile);
 
 	if (PLAYER_SAID (R, bye_homeworld))
 		NPCPhrase (GOODBYE_AND_DIE_HOMEWORLD);
 	else if (PLAYER_SAID (R, bye_royalist))
 		NPCPhrase (GOODBYE_AND_DIE_ROYALIST);
-	else if (PLAYER_SAID (R, i_demand_you_ally_homeworld0))
+	else if (PLAYER_SAID (R, i_demand_you_ally_homeworld))
 	{
 		NPCPhrase (ENEMY_MUST_DIE);
 
@@ -518,7 +518,7 @@ ExitConversation (RESPONSE_REF R)
 		{
 			NPCPhrase (GO_IN_PEACE);
 
-			SET_GAME_STATE (BATTLE_SEGUE, 0);
+			setSegue (Segue_peace);
 		}
 	}
 	else if (PLAYER_SAID (R, not_here)
@@ -539,7 +539,7 @@ ExitConversation (RESPONSE_REF R)
 	{
 		NPCPhrase (WE_REVOLT);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		SET_GAME_STATE (YEHAT_CIVIL_WAR, 1);
 		SET_GAME_STATE (YEHAT_VISITS, 0);
 		SET_GAME_STATE (YEHAT_HOME_VISITS, 0);
@@ -613,7 +613,7 @@ StartRevolt (RESPONSE_REF R)
 	else if (PLAYER_SAID (R, shofixti_alive_2))
 		NPCPhrase (SEND_HIM_OVER_2);
 
-	if (ActivateStarShip (SHOFIXTI_SHIP, ESCORTING_FLAGSHIP))
+	if (HaveEscortShip (SHOFIXTI_SHIP))
 		Response (ok_send, ExitConversation);
 	else
 		Response (not_here, ExitConversation);
@@ -676,23 +676,7 @@ YehatHome (RESPONSE_REF R)
 	if (!GET_GAME_STATE (NO_YEHAT_INFO))
 		Response (give_info, YehatHome);
 	if (!GET_GAME_STATE (NO_YEHAT_ALLY_HOME))
-	{
-		UNICODE buf[ALLIANCE_NAME_BUFSIZE];
-
-		GetAllianceName (buf, name_1);
-		construct_response (
-				shared_phrase_buf,
-				i_demand_you_ally_homeworld0,
-				GLOBAL_SIS (CommanderName),
-				i_demand_you_ally_homeworld1,
-				buf,
-				i_demand_you_ally_homeworld2,
-				GLOBAL_SIS (ShipName),
-				i_demand_you_ally_homeworld3,
-				(UNICODE*)NULL);
-		DoResponsePhrase (i_demand_you_ally_homeworld0,
-				ExitConversation, shared_phrase_buf);
-	}
+		Response (i_demand_you_ally_homeworld, ExitConversation);
 	Response (bye_homeworld, ExitConversation);
 }
 
@@ -732,7 +716,7 @@ YehatSpace (RESPONSE_REF R)
 
 		DISABLE_PHRASE (whats_up_space_1);
 	}
-	else if (PLAYER_SAID (R, i_demand_you_ally_space0))
+	else if (PLAYER_SAID (R, i_demand_you_ally_space))
 	{
 		NPCPhrase (WE_CANNOT_1);
 
@@ -743,7 +727,7 @@ YehatSpace (RESPONSE_REF R)
 	{
 		NPCPhrase (WE_CANNOT_2);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		SET_GAME_STATE (NO_YEHAT_ALLY_SPACE, 2);
 
 		return;
@@ -803,20 +787,7 @@ YehatSpace (RESPONSE_REF R)
 	{
 		case 0:
 		{
-			UNICODE buf[ALLIANCE_NAME_BUFSIZE];
-
-			GetAllianceName (buf, name_1);
-			construct_response (
-					shared_phrase_buf,
-					i_demand_you_ally_space0,
-					GLOBAL_SIS (CommanderName),
-					i_demand_you_ally_space1,
-					GLOBAL_SIS (ShipName),
-					i_demand_you_ally_space2,
-					buf,
-					i_demand_you_ally_space3,
-					(UNICODE*)NULL);
-			pStr[2] = i_demand_you_ally_space0;
+			pStr[2] = i_demand_you_ally_space;
 			break;
 		}
 		case 1:
@@ -825,21 +796,11 @@ YehatSpace (RESPONSE_REF R)
 	}
 
 	if (pStr[LastStack])
-	{
-		if (pStr[LastStack] != i_demand_you_ally_space0)
-			Response (pStr[LastStack], YehatSpace);
-		else
-			DoResponsePhrase (pStr[LastStack], YehatSpace, shared_phrase_buf);
-	}
+		Response (pStr[LastStack], YehatSpace);
 	for (i = 0; i < 3; ++i)
 	{
 		if (i != LastStack && pStr[i])
-		{
-			if (pStr[i] != i_demand_you_ally_space0)
-				Response (pStr[i], YehatSpace);
-			else
-				DoResponsePhrase (pStr[i], YehatSpace, shared_phrase_buf);
-		}
+			Response (pStr[i], YehatSpace);
 	}
 	if (!GET_GAME_STATE (YEHAT_ROYALIST_TOLD_PKUNK)
 			&& GET_GAME_STATE (PKUNK_VISITS)
@@ -869,7 +830,7 @@ Intro (void)
 	{
 		NPCPhrase (OUT_TAKES);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
@@ -953,6 +914,7 @@ Intro (void)
 static COUNT
 uninit_yehat (void)
 {
+	luaUqm_comm_uninit();
 	return (0);
 }
 
@@ -966,37 +928,29 @@ LOCDATA*
 init_yehat_comm (void)
 {
 	static LOCDATA yehat_desc;
-	LOCDATA *retval;
+ 	LOCDATA *retval;
 	
-	switch (RESOLUTION_FACTOR)
-	{
-		case 2:
-			yehat_desc = yehat_desc_4x;
-			break;
-		case 1:
-			yehat_desc = yehat_desc_2x;
-			break;
-		case 0:
-		default:
-			yehat_desc = yehat_desc_1x;
-			break;
-	}
+	yehat_desc = (RESOLUTION_FACTOR == 0 ? yehat_desc_1x : yehat_desc_4x);
 
 	yehat_desc.init_encounter_func = Intro;
 	yehat_desc.post_encounter_func = post_yehat_enc;
 	yehat_desc.uninit_encounter_func = uninit_yehat;
 
+	luaUqm_comm_init(NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	yehat_desc.AlienTextBaseline.x = SIS_SCREEN_WIDTH * 2 / 3;
 	yehat_desc.AlienTextBaseline.y = RES_SIS_SCALE(60);
 	yehat_desc.AlienTextWidth = (SIS_TEXT_WIDTH - 16) * 2 / 3;
 
 	if (LOBYTE (GLOBAL (CurrentActivity)) != WON_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	retval = &yehat_desc;
 
diff -ruNp src.hd/uqm/comm/zoqfot/Makeinfo src/uqm/comm/zoqfot/Makeinfo
--- src.hd/uqm/comm/zoqfot/Makeinfo	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/zoqfot/Makeinfo	2017-12-29 00:57:45 -0800
@@ -1 +1,2 @@
 uqm_CFILES="zoqfotc.c"
+uqm_HFILES="resinst.h strings.h"
diff -ruNp src.hd/uqm/comm/zoqfot/resinst.h src/uqm/comm/zoqfot/resinst.h
--- src.hd/uqm/comm/zoqfot/resinst.h	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/zoqfot/resinst.h	2017-12-29 00:57:45 -0800
@@ -1,5 +1,10 @@
-#define ZOQFOTPIK_PMAP_ANIM "comm.zoqfotpik.graphics"
-#define ZOQFOTPIK_FONT "comm.zoqfotpik.font"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define ZOQFOTPIK_COLOR_MAP "comm.zoqfotpik.colortable"
 #define ZOQFOTPIK_CONVERSATION_PHRASES "comm.zoqfotpik.dialogue"
+#define ZOQFOTPIK_FONT "comm.zoqfotpik.font"
 #define ZOQFOTPIK_MUSIC "comm.zoqfotpik.music"
+#define ZOQFOTPIK_PMAP_ANIM "comm.zoqfotpik.graphics"
+#define ZOQFOTPIK_SCRIPT "comm.zoqfotpik.script"
diff -ruNp src.hd/uqm/comm/zoqfot/strings.h src/uqm/comm/zoqfot/strings.h
--- src.hd/uqm/comm/zoqfot/strings.h	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/zoqfot/strings.h	2017-12-29 00:57:45 -0800
@@ -47,9 +47,7 @@ enum
 	HE_IS5,
 	HE_IS6,
 	HE_IS7,
-	we_are_vindicator0,
-	we_are_vindicator1,
-	we_are_vindicator2,
+	we_are_vindicator,
 	WE_GLAD0,
 	WE_GLAD1,
 	WE_GLAD2,
@@ -343,8 +341,7 @@ enum
 	name_1,
 	name_2,
 	name_3,
-	name_40,
-	name_41,
+	name_4,
 	OUT_TAKES0,
 	OUT_TAKES1,
 	OUT_TAKES2,
diff -ruNp src.hd/uqm/comm/zoqfot/zoqfotc.c src/uqm/comm/zoqfot/zoqfotc.c
--- src.hd/uqm/comm/zoqfot/zoqfotc.c	2017-12-29 02:25:52 -0800
+++ src/uqm/comm/zoqfot/zoqfotc.c	2017-12-29 00:57:45 -0800
@@ -20,6 +20,7 @@
 #include "resinst.h"
 #include "strings.h"
 
+#include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
 #include "uqm/gameev.h"
 
@@ -119,15 +120,12 @@ enum
 
 static int LastAlien;
 
+// Queued and executes synchronously on the Starcon2Main thread
 static void
-SelectAlienZOQ (void)
+SelectAlienZOQ (CallbackArg arg)
 {
 	if (LastAlien != ZOQ_ALIEN)
 	{
-		// XXX: This should hold the GraphicsLock to block comm anims and
-		//   prevent CommData half-updates, but if we do so, the stream
-		//   decoder will deadlock with the drawing thread.
-
 		// Transition to neutral state first if Pik was talking
 		if (LastAlien != FOT_ALIEN)
 			CommData.AlienTransitionDesc.AnimFlags |= TALK_DONE;
@@ -143,17 +141,16 @@ SelectAlienZOQ (void)
 		CommData.AlienTextFColor = ZOQ_FG_COLOR;
 		CommData.AlienTextBColor = ZOQ_BG_COLOR;
 	}
+
+	(void)arg; // ignored
 }
 
+// Queued and executes synchronously on the Starcon2Main thread
 static void
-SelectAlienPIK (void)
+SelectAlienPIK (CallbackArg arg)
 {
 	if (LastAlien != PIK_ALIEN)
 	{
-		// XXX: This should hold the GraphicsLock to block comm anims and
-		//   prevent CommData half-updates, but if we do so, the stream
-		//   decoder will deadlock with the drawing thread.
-
 		// Transition to neutral state first if Zoq was talking
 		if (LastAlien != FOT_ALIEN)
 			CommData.AlienTransitionDesc.AnimFlags |= TALK_DONE;
@@ -169,20 +166,22 @@ SelectAlienPIK (void)
 		CommData.AlienTextFColor = PIK_FG_COLOR;
 		CommData.AlienTextBColor = PIK_BG_COLOR;
 	}
+
+	(void)arg; // ignored
 }
 
 static void
 ZFPTalkSegue (COUNT wait_track)
 {
 	LastAlien = FOT_ALIEN;
-	SelectAlienZOQ ();
+	SelectAlienZOQ (0);
 	AlienTalkSegue (wait_track);
 }
 
 static void
 ExitConversation (RESPONSE_REF R)
 {
-	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	setSegue (Segue_peace);
 
 	if (PLAYER_SAID (R, bye_homeworld))
 	{
@@ -225,7 +224,7 @@ ExitConversation (RESPONSE_REF R)
 		NPCPhrase_cb (WE_ALLY4, &SelectAlienZOQ);
 		NPCPhrase_cb (WE_ALLY5, &SelectAlienPIK);
 		ZFPTalkSegue ((COUNT)~0);
-		ActivateStarShip (ZOQFOTPIK_SHIP, SET_ALLIED);
+		SetRaceAllied (ZOQFOTPIK_SHIP, TRUE);
 		AddEvent (RELATIVE_EVENT, 3, 0, 0, ZOQFOT_DISTRESS_EVENT);
 		SET_GAME_STATE (ZOQFOT_HOME_VISITS, 0);
 	}
@@ -239,7 +238,7 @@ ExitConversation (RESPONSE_REF R)
 
 		SET_GAME_STATE (ZOQFOT_HOSTILE, 1);
 		SET_GAME_STATE (ZOQFOT_HOME_VISITS, 0);
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (PLAYER_SAID (R, never))
 	{
@@ -249,7 +248,7 @@ ExitConversation (RESPONSE_REF R)
 
 		SET_GAME_STATE (ZOQFOT_HOME_VISITS, 0);
 		SET_GAME_STATE (ZOQFOT_HOSTILE, 1);
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 }
 
@@ -273,7 +272,7 @@ FormAlliance (RESPONSE_REF R)
 static void
 ZoqFotIntro (RESPONSE_REF R)
 {
-	if (PLAYER_SAID (R, we_are_vindicator0))
+	if (PLAYER_SAID (R, we_are_vindicator))
 	{
 		NPCPhrase_cb (WE_GLAD0, &SelectAlienZOQ);
 		NPCPhrase_cb (WE_GLAD1, &SelectAlienPIK);
@@ -283,7 +282,7 @@ ZoqFotIntro (RESPONSE_REF R)
 		NPCPhrase_cb (WE_GLAD5, &SelectAlienPIK);
 		ZFPTalkSegue ((COUNT)~0);
 		
-		DISABLE_PHRASE (we_are_vindicator0);
+		DISABLE_PHRASE (we_are_vindicator);
 	}
 	else if (PLAYER_SAID (R, your_race))
 	{
@@ -420,25 +419,10 @@ AquaintZoqFot (RESPONSE_REF R)
 		DISABLE_PHRASE (quiet_toadies);
 	}
 
-	if (PHRASE_ENABLED (we_are_vindicator0))
-	{
-		UNICODE buf[ALLIANCE_NAME_BUFSIZE];
-
-		GetAllianceName (buf, name_1);
-		construct_response (
-				shared_phrase_buf,
-				we_are_vindicator0,
-				buf,
-				we_are_vindicator1,
-				GLOBAL_SIS (ShipName),
-				we_are_vindicator2,
-				(UNICODE*)NULL);
-	}
-
 	if (PHRASE_ENABLED (which_fot))
 		Response (which_fot, AquaintZoqFot);
-	if (PHRASE_ENABLED (we_are_vindicator0))
-		DoResponsePhrase (we_are_vindicator0, ZoqFotIntro, shared_phrase_buf);
+	if (PHRASE_ENABLED (we_are_vindicator))
+		Response (we_are_vindicator, ZoqFotIntro);
 	if (PHRASE_ENABLED (quiet_toadies))
 		Response (quiet_toadies, AquaintZoqFot);
 	Response (all_very_interesting, ExitConversation);
@@ -736,7 +720,7 @@ ZoqFotHome (RESPONSE_REF R)
 		NPCPhrase_cb (GOOD9, &SelectAlienPIK);
 		ZFPTalkSegue ((COUNT)~0);
 
-		ActivateStarShip (ZOQFOTPIK_SHIP, SET_ALLIED);
+		SetRaceAllied (ZOQFOTPIK_SHIP, TRUE);
 		AddEvent (RELATIVE_EVENT, 3, 0, 0, ZOQFOT_DISTRESS_EVENT);
 	}
 	else if (PLAYER_SAID (R, enough_info))
@@ -749,7 +733,7 @@ ZoqFotHome (RESPONSE_REF R)
 		Response (whats_up_homeworld, ZoqFotHome);
 	if (PHRASE_ENABLED (any_war_news))
 		Response (any_war_news, ZoqFotHome);
-	if (ActivateStarShip (ZOQFOTPIK_SHIP, CHECK_ALLIANCE) != GOOD_GUY)
+	if (CheckAlliance (ZOQFOTPIK_SHIP) != GOOD_GUY)
 		Response (i_want_alliance, ZoqFotHome);
 	else if (PHRASE_ENABLED (want_specific_info))
 	{
@@ -780,7 +764,7 @@ Intro (void)
 		NPCPhrase_cb (OUT_TAKES12, &SelectAlienZOQ);
 		NPCPhrase_cb (OUT_TAKES13, &SelectAlienPIK);
 		ZFPTalkSegue ((COUNT)~0);
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 		return;
 	}
 
@@ -817,7 +801,7 @@ Intro (void)
 		}
 		SET_GAME_STATE (ZOQFOT_HOME_VISITS, NumVisits);
 
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	else if (!GET_GAME_STATE (MET_ZOQFOT))
 	{
@@ -871,12 +855,12 @@ Intro (void)
 			ZFPTalkSegue ((COUNT)~0);
 
 			SET_GAME_STATE (ZOQFOT_DISTRESS, 0);
-			ActivateStarShip (ZOQFOTPIK_SHIP, MAX_ZFP_SHIPS);
+			AddEscortShips (ZOQFOTPIK_SHIP, MAX_ZFP_SHIPS);
 		}
 		else
 		{
 			NumVisits = GET_GAME_STATE (ZOQFOT_HOME_VISITS);
-			if (ActivateStarShip (ZOQFOTPIK_SHIP, CHECK_ALLIANCE) != GOOD_GUY)
+			if (CheckAlliance (ZOQFOTPIK_SHIP) != GOOD_GUY)
 			{
 				switch (NumVisits++)
 				{
@@ -941,6 +925,7 @@ Intro (void)
 static COUNT
 uninit_zoqfot (void)
 {
+	luaUqm_comm_uninit ();
 	return (0);
 }
 
@@ -959,16 +944,20 @@ init_zoqfot_comm (void)
 	zoqfot_desc.post_encounter_func = post_zoqfot_enc;
 	zoqfot_desc.uninit_encounter_func = uninit_zoqfot;
 
+	luaUqm_comm_init (NULL, NULL_RESOURCE);
+			// Initialise Lua for string interpolation. This will be
+			// generalised in the future.
+
 	zoqfot_desc.AlienTextWidth = (SIS_TEXT_WIDTH >> 1) - TEXT_X_OFFS;
 
-	if (ActivateStarShip (ZOQFOTPIK_SHIP, CHECK_ALLIANCE) == GOOD_GUY
+	if (CheckAlliance (ZOQFOTPIK_SHIP) == GOOD_GUY
 			|| LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		setSegue (Segue_peace);
 	}
 	else
 	{
-		SET_GAME_STATE (BATTLE_SEGUE, 1);
+		setSegue (Segue_hostile);
 	}
 	
 	retval = &zoqfot_desc;
diff -ruNp src.hd/uqm/comm.c src/uqm/comm.c
--- src.hd/uqm/comm.c	2017-12-29 02:25:52 -0800
+++ src/uqm/comm.c	2017-12-29 01:03:25 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #define COMM_INTERNAL
 #include "comm.h"
 
@@ -29,16 +27,18 @@
 #include "sis.h"
 #include "units.h"
 #include "encount.h"
+#include "starmap.h"
 #include "endian_uqm.h"
 #include "gamestr.h"
 #include "options.h"
-#include "load.h"
 #include "oscill.h"
+#include "save.h"
 #include "settings.h"
 #include "setup.h"
 #include "sounds.h"
 #include "nameref.h"
 #include "uqmdebug.h"
+#include "lua/luacomm.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/inplib.h"
 #include "libs/sound/sound.h"
@@ -48,8 +48,7 @@
 #include <ctype.h>
 
 #define MAX_RESPONSES 8
-#define BACKGROUND_VOL \
-		(speechVolumeScale == 0.0f ? NORMAL_VOLUME : (NORMAL_VOLUME >> 1))
+#define BACKGROUND_VOL (usingSpeech ? (NORMAL_VOLUME / 2) : NORMAL_VOLUME)
 #define FOREGROUND_VOL NORMAL_VOLUME
 
 // Oscilloscope frame rate
@@ -85,6 +84,7 @@ typedef struct response_entry
 	RESPONSE_REF response_ref;
 	TEXT response_text;
 	RESPONSE_FUNC response_func;
+	char *allocedResponse;
 } RESPONSE_ENTRY;
 
 typedef struct encounter_state
@@ -113,8 +113,8 @@ static FRAME TextCacheFrame;
 
 RECT CommWndRect = {
 	// default values; actually inited by HailAlien()
-	{0, 0}, //was {SIS_ORG_X, SIS_ORG_Y}, // JMS_GFX
-	{0, 0}
+	{0, 0},
+	{0, 0} //was {SIS_ORG_X, SIS_ORG_Y}, // JMS_GFX
 };
 
 static void ClearSubtitles (void);
@@ -166,7 +166,7 @@ add_text (int status, TEXT *pTextIn)
 	BOOLEAN eol;
 	CONTEXT OldContext = NULL;
 	COUNT computerOn = 0;
-
+	
 	BatchGraphics ();
 
 	maxchars = (COUNT)~0;
@@ -523,11 +523,11 @@ static void
 RefreshResponses (ENCOUNTER_STATE *pES)
 {
 	COORD y;
-	BYTE response;
+	BYTE response, extra_y; // JMS_GFX
 	SIZE leading;
 	STAMP s;
-	BYTE extra_y; // JMS_GFX
-	
+
+
 	SetContext (SpaceContext);
 	GetContextFontLeading (&leading);
 	BatchGraphics ();
@@ -542,7 +542,6 @@ RefreshResponses (ENCOUNTER_STATE *pES)
 		pES->response_list[response].response_text.baseline.x = TEXT_X_OFFS + (8 << RESOLUTION_FACTOR); // JMS_GFX
 		pES->response_list[response].response_text.baseline.y = y + leading + extra_y; // JMS_GFX
 		pES->response_list[response].response_text.align = ALIGN_LEFT;
-		
 		if (response == pES->cur_response)
 			y = add_text (-1, &pES->response_list[response].response_text);
 		else
@@ -746,13 +745,11 @@ DoTalkSegue (TALKING_STATE *pTS)
 		CheckSubtitles ();
 	}
 
-	LockMutex (GraphicsLock);
 	// XXX: When seeking, all animations (talking and ambient) stop
 	// progressing. This is an original 3DO behavior, and I see no
 	// reason why the animations cannot continue while seeking.
 	UpdateAnimations (pTS->seeking);
 	UpdateSpeechGraphics ();
-	UnlockMutex (GraphicsLock);
 
 	curTrack = PlayingTrack ();
 	pTS->ended = !pTS->seeking && !curTrack;
@@ -767,9 +764,7 @@ DoTalkSegue (TALKING_STATE *pTS)
 static void
 runCommAnimFrame (void)
 {
-	LockMutex (GraphicsLock);
 	UpdateCommGraphics ();
-	UnlockMutex (GraphicsLock);
 	SleepThread (COMM_ANIM_RATE);
 }
 
@@ -801,7 +796,6 @@ TalkSegue (COUNT wait_track)
 	else if (!PlayingTrack ())
 	{	// initial start of player
 		PlayTrack ();
-		assert (PlayingTrack ());
 	}
 
 	// Run the talking controls
@@ -878,13 +872,11 @@ AlienTalkSegue (COUNT wait_track)
 	if (!pCurInputState->Initialized)
 	{
 		InitSpeechGraphics ();
-		LockMutex (GraphicsLock);
 		SetColorMap (GetColorMapAddress (CommData.AlienColorMap));
 		SetContext (AnimContext);
 		DrawAlienFrame (NULL, 0, TRUE);
 		UpdateSpeechGraphics ();
 		CommIntroTransition ();
-		UnlockMutex (GraphicsLock);
 		
 		pCurInputState->Initialized = TRUE;
 
@@ -969,7 +961,6 @@ DoConvSummary (SUMMARY_STATE *pSS)
 		r.extent.width = SIS_SCREEN_WIDTH;
 		r.extent.height = SLIDER_Y; //SIS_SCREEN_HEIGHT - SLIDER_Y - SLIDER_HEIGHT + (2 << RESOLUTION_FACTOR) + 16 * RESOLUTION_FACTOR; // JMS_GFX
 
-		LockMutex (GraphicsLock);
 		SetContext (AnimContext);
 		SetContextForeGroundColor (COMM_HISTORY_BACKGROUND_COLOR);
 		DrawFilledRectangle (&r);
@@ -1010,13 +1001,13 @@ DoConvSummary (SUMMARY_STATE *pSS)
 				} else { // Normal mode
 					font_DrawText(&t);
 				}
-
 				t.baseline.y += DELTA_Y_SUMMARY;
 				t.pStr = next;
 				t.CharCount = (COUNT)~0;
 			}
 
-			if (row >= MAX_SUMM_ROWS) {	// no more space on screen, but some text left over
+			if (row >= MAX_SUMM_ROWS)
+			{	// no more space on screen, but some text left over
 				// from the current subtitle
 				pSS->LeftOver = next;
 				break;
@@ -1032,11 +1023,11 @@ DoConvSummary (SUMMARY_STATE *pSS)
 			} else { // Normal mode
 				font_DrawText(&t);
 			}
-
 			t.baseline.y += DELTA_Y_SUMMARY;
 		}
 
-		if (row >= MAX_SUMM_ROWS && (pSS->NextSub || pSS->LeftOver)) {	// draw *MORE*
+		if (row >= MAX_SUMM_ROWS && (pSS->NextSub || pSS->LeftOver))
+		{	// draw *MORE*
 			TEXT mt;
 			UNICODE buffer[80];
 
@@ -1056,7 +1047,6 @@ DoConvSummary (SUMMARY_STATE *pSS)
 			font_DrawText (&mt);
 		}
 
-		UnlockMutex (GraphicsLock);
 
 		pSS->PrintNext = FALSE;
 	}
@@ -1068,6 +1058,21 @@ DoConvSummary (SUMMARY_STATE *pSS)
 	return TRUE; // keep going
 }
 
+static void
+ClearResponses (ENCOUNTER_STATE *pES)
+{
+	size_t responseI;
+
+	for (responseI = 0; responseI < MAX_RESPONSES; responseI++) {
+		RESPONSE_ENTRY *response = &pES->response_list[responseI];
+		if (response->allocedResponse != NULL)
+		{
+			HFree (response->allocedResponse);
+			response->allocedResponse = NULL;
+		}
+	}
+}
+
 // Called when the player presses the select button on a response.
 static void
 SelectResponse (ENCOUNTER_STATE *pES)
@@ -1076,9 +1081,7 @@ SelectResponse (ENCOUNTER_STATE *pES)
 			&pES->response_list[pES->cur_response].response_text;
 	utf8StringCopy (pES->phrase_buf, sizeof pES->phrase_buf,
 			response_text->pStr);
-	LockMutex (GraphicsLock);
 	FeedbackPlayerPhrase (pES->phrase_buf);
-	UnlockMutex (GraphicsLock);
 	StopTrack ();
 	ClearSubtitles ();
 	SetSliderImage (SetAbsFrameIndex (ActivityFrame, 2));
@@ -1087,6 +1090,7 @@ SelectResponse (ENCOUNTER_STATE *pES)
 
 	TalkingFinished = FALSE;
 	pES->num_responses = 0;
+	ClearResponses (pES);
 	(*pES->response_list[pES->cur_response].response_func)
 			(pES->response_list[pES->cur_response].response_ref);
 }
@@ -1097,29 +1101,23 @@ SelectConversationSummary (ENCOUNTER_STA
 {
 	SUMMARY_STATE SummaryState;
 	
-	LockMutex (GraphicsLock);
 	if (pES)
 		FeedbackPlayerPhrase (pES->phrase_buf);
-	UnlockMutex (GraphicsLock);
 
 	SummaryState.Initialized = FALSE;
 	DoConvSummary (&SummaryState);
 
-	LockMutex (GraphicsLock);
 	if (pES)
 		RefreshResponses (pES);
 	clear_subtitles = TRUE;
-	UnlockMutex (GraphicsLock);
 }
 
 static void
 SelectReplay (ENCOUNTER_STATE *pES)
 {
 	FadeMusic (BACKGROUND_VOL, ONE_SECOND);
-	LockMutex (GraphicsLock);
 	if (pES)
 		FeedbackPlayerPhrase (pES->phrase_buf);
-	UnlockMutex (GraphicsLock);
 
 	TalkSegue (0);
 }
@@ -1132,9 +1130,7 @@ PlayerResponseInput (ENCOUNTER_STATE *pE
 	if (pES->top_response == (BYTE)~0)
 	{
 		pES->top_response = 0;
-		LockMutex (GraphicsLock);
 		RefreshResponses (pES);
-		UnlockMutex (GraphicsLock);
 	}
 
 	if (PulsedInputState.menu[KEY_MENU_SELECT])
@@ -1155,9 +1151,7 @@ PlayerResponseInput (ENCOUNTER_STATE *pE
 
 			if (!(GLOBAL (CurrentActivity) & CHECK_ABORT))
 			{
-				LockMutex (GraphicsLock);
 				RefreshResponses (pES);
-				UnlockMutex (GraphicsLock);
 				FadeMusic (FOREGROUND_VOL, ONE_SECOND);
 			}
 		}
@@ -1171,9 +1165,7 @@ PlayerResponseInput (ENCOUNTER_STATE *pE
 		{
 			COORD y;
 
-			LockMutex (GraphicsLock);
 			BatchGraphics ();
-			// add_text (-2, &pES->response_list[pES->cur_response].response_text);
 
 			pES->cur_response = response;
 
@@ -1182,21 +1174,16 @@ PlayerResponseInput (ENCOUNTER_STATE *pE
 			if (response < pES->top_response)
 			{
 				pES->top_response = 0;
-				// RefreshResponses (pES);
 			}
 			else if (y > SIS_SCREEN_HEIGHT)
 			{
 				pES->top_response = response;
-				// RefreshResponses (pES);
 			}
 			RefreshResponses (pES);
 			UnbatchGraphics ();
-			UnlockMutex (GraphicsLock);
 		}
 
-		LockMutex (GraphicsLock);
 		UpdateCommGraphics ();
-		UnlockMutex (GraphicsLock);
 
 		SleepThreadUntil (pES->NextTime);
 		pES->NextTime = GetTimeCounter () + COMM_ANIM_RATE;
@@ -1236,9 +1223,7 @@ DoLastReplay (LAST_REPLAY_STATE *pLRS)
 		pLRS->TimeOut = FadeMusic (0, ONE_SECOND * 2) + ONE_SECOND / 60;
 	}
 
-	LockMutex (GraphicsLock);
 	UpdateCommGraphics ();
-	UnlockMutex (GraphicsLock);
 	
 	SleepThreadUntil (pLRS->NextTime);
 	pLRS->NextTime = GetTimeCounter () + COMM_ANIM_RATE;
@@ -1277,11 +1262,9 @@ DoCommunication (ENCOUNTER_STATE *pES)
 		return TRUE;
 	}
 
-	LockMutex (GraphicsLock);
 	SetContext (SpaceContext);
 	DestroyContext (AnimContext);
 	AnimContext = NULL;
-	UnlockMutex (GraphicsLock);
 
 	FlushColorXForms ();
 	ClearSubtitles ();
@@ -1323,13 +1306,15 @@ DoResponsePhrase (RESPONSE_REF R, RESPON
 				(COUNT) (R - 1));
 		pEntry->response_text.pStr =
 				(UNICODE *) GetStringAddress (locString);
-		pEntry->response_text.CharCount = GetStringLength (locString);
-//#define BVT_PROBLEM
-#ifdef BVT_PROBLEM
-		if (pEntry->response_text.pStr[pEntry->response_text.CharCount - 1]
-				== '\0')
-			--pEntry->response_text.CharCount;
-#endif /* BVT_PROBLEM */
+
+		if (luaUqm_comm_stringNeedsInterpolate (pEntry->response_text.pStr))
+		{
+			pEntry->allocedResponse = luaUqm_comm_stringInterpolate(
+					pEntry->response_text.pStr);
+			pEntry->response_text.pStr = pEntry->allocedResponse;
+		}
+
+		pEntry->response_text.CharCount = (COUNT)~0;
 	}
 	pEntry->response_func = response_func;
 	++pES->num_responses;
@@ -1371,17 +1356,15 @@ HailAlien (void)
 	SubtitleText.baseline = CommData.AlienTextBaseline;
 	SubtitleText.align = CommData.AlienTextAlign;
 
-	LockMutex (GraphicsLock);
 
 	// init subtitle cache context
 	TextCacheContext = CreateContext ("TextCacheContext");
-	// TextCacheFrame = CaptureDrawable (
-	// 		CreateDrawable (WANT_PIXMAP, SIS_SCREEN_WIDTH,
-	// 		SIS_SCREEN_HEIGHT - SLIDER_Y - SLIDER_HEIGHT + 2, 1));
+	//TextCacheFrame = CaptureDrawable (
+	//		CreateDrawable (WANT_PIXMAP, SIS_SCREEN_WIDTH,
+	//		SIS_SCREEN_HEIGHT - SLIDER_Y - SLIDER_HEIGHT + 2, 1));
 	// BW: previous lines were just a complex and wrong way of obtaining 107
-	TextCacheFrame = CaptureDrawable (
-			CreateDrawable (WANT_PIXMAP, SIS_SCREEN_WIDTH,
-			SLIDER_Y, 1));
+ 	TextCacheFrame = CaptureDrawable (
+ 			CreateDrawable (WANT_PIXMAP, SIS_SCREEN_WIDTH, SLIDER_Y, 1));
 	SetContext (TextCacheContext);
 	SetContextFGFrame (TextCacheFrame);
 	TextBack = BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x10), 0x00);
@@ -1405,7 +1388,6 @@ HailAlien (void)
 		r.extent.width = SIS_SCREEN_WIDTH;
 		CommWndRect.corner.x = SIS_ORG_X; // JMS_GFX: Added these lines because of the 
 		CommWndRect.corner.y = SIS_ORG_Y; // changed init of CommWndRect in the beginning of comm.c
-		CommWndRect.extent = r.extent;
 		
 		SetTransitionSource (NULL);
 		BatchGraphics ();
@@ -1445,7 +1427,6 @@ HailAlien (void)
 		DrawSISComWindow ();
 	}
 
-	UnlockMutex (GraphicsLock);
 
 	LastActivity |= CHECK_LOAD; /* prevent spurious input */
 	(*CommData.init_encounter_func) ();
@@ -1454,10 +1435,9 @@ HailAlien (void)
 		(*CommData.post_encounter_func) ();
 	(*CommData.uninit_encounter_func) ();
 
-	LockMutex (GraphicsLock);
+	ClearResponses (&ES);
 	SetContext (SpaceContext);
 	SetContextFont (OldFont);
-	UnlockMutex (GraphicsLock);
 
 	DestroyStringTable (ReleaseStringTable (CommData.ConversationPhrases));
 	DestroyMusic (CommData.AlienSong);
@@ -1496,7 +1476,6 @@ InitCommunication (CONVERSATION which_co
 		return 0;
 #endif
 	
-	LockMutex (GraphicsLock);
 
 	if (LastActivity & CHECK_LOAD)
 	{
@@ -1513,7 +1492,7 @@ InitCommunication (CONVERSATION which_co
 				RepairSISBorder ();
 			}
 			DrawSISMessage (NULL);
-			if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+			if (inHQSpace ())
 				DrawHyperCoords (GLOBAL (ShipStamp.origin));
 			else if (GLOBAL (ip_planet) == 0)
 				DrawHyperCoords (CurStarDescPtr->star_pt);
@@ -1522,7 +1501,6 @@ InitCommunication (CONVERSATION which_co
 		}
 	}
 
-	UnlockMutex (GraphicsLock);
 
 	if (which_comm == URQUAN_DRONE_CONVERSATION)
 	{
@@ -1547,7 +1525,7 @@ InitCommunication (CONVERSATION which_co
 				status = HUMAN_SHIP;
 			}
 		}
-		ActivateStarShip (status, SPHERE_TRACKING);
+		StartSphereTracking (status);
 
 		if (which_comm == ORZ_CONVERSATION
 				|| (which_comm == TALKING_PET_CONVERSATION
@@ -1555,7 +1533,7 @@ InitCommunication (CONVERSATION which_co
 				|| LOBYTE (GLOBAL (CurrentActivity)) == IN_LAST_BATTLE))
 				|| (which_comm != CHMMR_CONVERSATION
 				&& which_comm != SYREEN_CONVERSATION
-				))//&& ActivateStarShip (status, CHECK_ALLIANCE) == BAD_GUY))
+				))//&& CheckAlliance (status) == BAD_GUY))
 			BuildBattle (NPC_PLAYER_NUM);
 	}
 
@@ -1679,7 +1657,7 @@ RaceCommunication (void)
 		SET_GAME_STATE (ESCAPE_COUNTER, ec);
 		return;
 	}
-	else if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+	else if (inHQSpace ())
 	{
 		ReinitQueue (&GLOBAL (npc_built_ship_q));
 		if (GET_GAME_STATE (ARILOU_SPACE_SIDE) >= 2)
@@ -1690,7 +1668,6 @@ RaceCommunication (void)
 		else
 		{
 			/* Encounter with a black globe in HS, prepare enemy ship list */
-			COUNT NumShips;
 			ENCOUNTER *EncounterPtr;
 
 			// The encounter globe that the flagship collided with is moved
@@ -1698,10 +1675,9 @@ RaceCommunication (void)
 			hEncounter = GetHeadEncounter ();
 			LockEncounter (hEncounter, &EncounterPtr);
 
-			NumShips = LONIBBLE (EncounterPtr->SD.Index);
-			for (i = 0; i < NumShips; ++i)
+			for (i = 0; i < EncounterPtr->num_ships; ++i)
 			{
-				CloneShipFragment (EncounterPtr->SD.Type,
+				CloneShipFragment (EncounterPtr->race_id,
 						&GLOBAL (npc_built_ship_q),
 						EncounterPtr->ShipList[i].crew_level);
 			}
@@ -1742,12 +1718,11 @@ RaceCommunication (void)
 
 		LockEncounter (hEncounter, &EncounterPtr);
 
-		NumShips = (BYTE)CountLinks (&GLOBAL (npc_built_ship_q));
-		EncounterPtr->SD.Index = MAKE_BYTE (NumShips,
-				HINIBBLE (EncounterPtr->SD.Index));
-		EncounterPtr->SD.Index |= ENCOUNTER_REFORMING;
+		NumShips = CountLinks (&GLOBAL (npc_built_ship_q));
+		EncounterPtr->num_ships = NumShips;
+		EncounterPtr->flags |= ENCOUNTER_REFORMING;
 		if (status == 0)
-			EncounterPtr->SD.Index |= ONE_SHOT_ENCOUNTER;
+			EncounterPtr->flags |= ONE_SHOT_ENCOUNTER;
 
 		for (i = 0; i < NumShips; ++i)
 		{
diff -ruNp src.hd/uqm/comm.h src/uqm/comm.h
--- src.hd/uqm/comm.h	2017-12-29 02:25:52 -0800
+++ src/uqm/comm.h	2017-12-29 00:57:45 -0800
@@ -14,8 +14,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #ifndef _COMM_H
 #define _COMM_H
 
@@ -33,6 +31,10 @@
 
 #include "commanim.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern LOCDATA CommData;
 
 static inline BOOLEAN
@@ -133,6 +135,10 @@ extern void SetCommIntroMode (CommIntroM
 
 extern void EnableTalkingAnim (BOOLEAN enable);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _COMM_H */
 
 
diff -ruNp src.hd/uqm/commanim.c src/uqm/commanim.c
--- src.hd/uqm/commanim.c	2017-12-29 02:25:52 -0800
+++ src/uqm/commanim.c	2017-12-29 00:57:45 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #define COMM_INTERNAL
 #include "commanim.h"
 
@@ -466,7 +464,7 @@ ProcessCommAnimations (BOOLEAN FullRedra
 				{	// Otherwise, let the animation run until it's safe
 					CanTalk = FALSE;
 				}
-			}
+			}			
 			
 			// BW: to be checked. I've tried to remove what's supposed to be removed while keeping the Syreen zoom-in feature.
 			// It may have to be re-programmed in the new commanim style.
@@ -497,7 +495,6 @@ ProcessCommAnimations (BOOLEAN FullRedra
 				// Stop the anim if not talking
 				pSeq->Direction = NO_DIR;
 			}
-			
 		}
 		// All ambient animations have been processed. Advance the mask.
 		ActiveMask = NextActiveMask;
diff -ruNp src.hd/uqm/commanim.h src/uqm/commanim.h
--- src.hd/uqm/commanim.h	2017-12-29 02:25:52 -0800
+++ src/uqm/commanim.h	2017-12-29 00:57:45 -0800
@@ -14,14 +14,16 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #ifndef _COMMANIM_H
 #define _COMMANIM_H
 
 #include "libs/compiler.h"
 #include "libs/gfxlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 // Some background: every animation has a neutral frame which returns
 // the image to the state it was in before the animation began. Which
 // frame is neutral depends on the animation type.
@@ -137,6 +139,10 @@ extern BOOLEAN DrawAlienFrame (SEQUENCE
 extern void InitCommAnimations (void);
 extern BOOLEAN ProcessCommAnimations (BOOLEAN fullRedraw, BOOLEAN paused);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _COMMANIM_H */
 
 
diff -ruNp src.hd/uqm/commglue.c src/uqm/commglue.c
--- src.hd/uqm/commglue.c	2017-12-29 02:25:52 -0800
+++ src/uqm/commglue.c	2017-12-29 00:57:45 -0800
@@ -18,72 +18,49 @@
 
 #include "commglue.h"
 
+#include "battle.h"
+		// For instantVictory
 #include "races.h"
+#include "lua/luacomm.h"
+#include "libs/log.h"
 
 #include <stdarg.h>
 #include <stdlib.h>
 #include <stddef.h>
 #include <assert.h>
-#include "libs/log.h"
 
 static int NPCNumberPhrase (int number, const char *fmt, UNICODE **ptrack);
 
+// The CallbackFunction is queued and executes synchronously
+// on the Starcon2Main thread
 void
-NPCPhrase_cb (int index,  TFB_TrackCB cb)
+NPCPhrase_cb (int index, CallbackFunction cb)
 {
-	UNICODE *pStr, buf[400];
-	void *pClip, *pTimeStamp;
+	char *pStr;
+	void *pClip;
+	void *pTimeStamp;
+	BOOLEAN isPStrAlloced = FALSE;
+
+	if (index == 0)
+		return;
 
-	switch (index)
+	pStr = (UNICODE *)GetStringAddress (
+			SetAbsStringTableIndex (CommData.ConversationPhrases, index - 1));
+	pClip = GetStringSoundClip (
+			SetAbsStringTableIndex (CommData.ConversationPhrases, index - 1));
+	pTimeStamp = GetStringTimeStamp (
+			SetAbsStringTableIndex (CommData.ConversationPhrases, index - 1));
+		
+	if (luaUqm_comm_stringNeedsInterpolate (pStr))
 	{
-		case GLOBAL_PLAYER_NAME:
-			pStr = GLOBAL_SIS (CommanderName);
-			pClip = 0;
-			pTimeStamp = 0;
-			break;
-		case GLOBAL_SHIP_NAME:
-			pStr = GLOBAL_SIS (ShipName);
-			pClip = 0;
-			pTimeStamp = 0;
-			break;
-		case 0:
-		{
-			return;
-		}
-		default:
-			if (index < 0)
-			{	// One of the alliance name variants
-				COUNT i;
-				STRING S;
-
-				index -= GLOBAL_ALLIANCE_NAME;
-
-				i = GET_GAME_STATE (NEW_ALLIANCE_NAME);
-				S = SetAbsStringTableIndex (CommData.ConversationPhrases, (index - 1) + i);
-				strcpy (buf, (UNICODE *)GetStringAddress (S));
-				if (i == 3)
-					strcat (buf, GLOBAL_SIS (CommanderName));
-
-				pStr = buf;
-				pClip = 0;
-				pTimeStamp = 0;
-			}
-			else
-			{
-				pStr = (UNICODE *)GetStringAddress (
-						SetAbsStringTableIndex (CommData.ConversationPhrases, index - 1)
-						);
-				pClip = GetStringSoundClip (
-						SetAbsStringTableIndex (CommData.ConversationPhrases, index - 1)
-						);
-				pTimeStamp = GetStringTimeStamp (
-						SetAbsStringTableIndex (CommData.ConversationPhrases, index - 1)
-						);
-			}
-			break;
+		pStr = luaUqm_comm_stringInterpolate (pStr);
+		isPStrAlloced = TRUE;
 	}
 
 	SpliceTrack (pClip, pStr, pTimeStamp, cb);
+
+	if (isPStrAlloced)
+		HFree (pStr);
 }
 
 // Special case variant: prevents page breaks.
@@ -236,24 +213,6 @@ NPCNumberPhrase (int number, const char
 }
 
 void
-GetAllianceName (UNICODE *buf, RESPONSE_REF name_1)
-{
-	COUNT i;
-	STRING S;
-
-	i = GET_GAME_STATE (NEW_ALLIANCE_NAME);
-	S = SetAbsStringTableIndex (CommData.ConversationPhrases, (name_1 - 1) + i);
-	// XXX: this should someday be changed so that the function takes
-	//   the buffer size as an argument
-	strcpy (buf, (UNICODE *)GetStringAddress (S));
-	if (i == 3)
-	{
-		strcat (buf, GLOBAL_SIS (CommanderName));
-		strcat (buf, (UNICODE *)GetStringAddress (SetRelStringTableIndex (S, 1)));
-	}
-}
-
-void
 construct_response (UNICODE *buf, int R /* promoted from RESPONSE_REF */, ...)
 {
 	UNICODE *buf_start = buf;
@@ -308,6 +267,48 @@ construct_response (UNICODE *buf, int R
 	}
 }
 
+void
+setSegue (Segue segue)
+{
+	switch (segue)
+	{
+		case Segue_peace:
+			SET_GAME_STATE (BATTLE_SEGUE, 0);
+			break;
+		case Segue_hostile:
+			SET_GAME_STATE (BATTLE_SEGUE, 1);
+			break;
+		case Segue_victory:
+			instantVictory = TRUE;
+			SET_GAME_STATE (BATTLE_SEGUE, 1);
+			break;
+		case Segue_defeat:
+			SET_GAME_STATE (BATTLE_SEGUE, 0);
+			GLOBAL_SIS(CrewEnlisted) = (COUNT)~0;
+			GLOBAL(CurrentActivity) |= CHECK_RESTART;
+			break;
+	}
+}
+
+Segue
+getSegue (void)
+{
+	if (GET_GAME_STATE(BATTLE_SEGUE) == 0) {
+		if (GLOBAL_SIS(CrewEnlisted) == (COUNT)~0 &&
+				(GLOBAL(CurrentActivity) & CHECK_RESTART)) {
+			return Segue_defeat;
+		} else {
+			return Segue_peace;
+		}
+	} else /* GET_GAME_STATE(BATTLE_SEGUE) == 1) */ {
+		if (instantVictory) {
+			return Segue_victory;
+		} else {
+			return Segue_hostile;
+		}
+	}
+}
+
 LOCDATA*
 init_race (CONVERSATION comm_id)
 {
@@ -373,3 +374,27 @@ init_race (CONVERSATION comm_id)
 			return init_chmmr_comm ();
 	}
 }
+
+RESPONSE_REF
+phraseIdStrToNum(const char *phraseIdStr)
+{
+	STRING phrase = GetStringByName (GetStringTable(
+			CommData.ConversationPhrases), phraseIdStr);
+	if (phrase == NULL)
+		return (RESPONSE_REF) -1;
+
+	return GetStringTableIndex (phrase) + 1;
+			// Index 0 is for NULL_PHRASE, hence the '+ 1"
+}
+
+const char *
+phraseIdNumToStr (RESPONSE_REF response)
+{
+	STRING phrase = SetAbsStringTableIndex (
+			CommData.ConversationPhrases, response - 1);
+			// Index 0 is for NULL_PHRASE, hence the '- 1'.
+	if (phrase == NULL)
+		return NULL;
+	return GetStringName (phrase);
+}
+
diff -ruNp src.hd/uqm/commglue.h src/uqm/commglue.h
--- src.hd/uqm/commglue.h	2017-12-29 02:25:52 -0800
+++ src/uqm/commglue.h	2017-12-29 00:57:45 -0800
@@ -22,6 +22,11 @@
 #include "globdata.h"
 #include "resinst.h"
 #include "libs/sound/trackplayer.h"
+#include "libs/callback.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
 extern LOCDATA CommData;
 extern UNICODE shared_phrase_buf[2048];
@@ -35,37 +40,46 @@ extern UNICODE shared_phrase_buf[2048];
 		(*(UNICODE *)GetStringAddress ( \
 				SetAbsStringTableIndex (CommData.ConversationPhrases, (p)-1) \
 				) = '\0')
-#define RESPONSE_TO_REF(R) (R)
 
 #define Response(i,a) \
 		DoResponsePhrase(i,(RESPONSE_FUNC)a,0)
 
-enum
-{
-	GLOBAL_PLAYER_NAME = -1000000,
-	GLOBAL_SHIP_NAME,
-	GLOBAL_ALLIANCE_NAME,
-};
-
 typedef COUNT RESPONSE_REF;
 
 typedef void (*RESPONSE_FUNC) (RESPONSE_REF R);
 
 extern void DoResponsePhrase (RESPONSE_REF R, RESPONSE_FUNC
 		response_func, UNICODE *ContstructStr);
-extern void DoNPCPhrase (UNICODE *pStr);
 
-extern void NPCPhrase_cb (int index, TFB_TrackCB cb);
+// The CallbackFunction is queued and executes synchronously
+// on the Starcon2Main thread
+extern void NPCPhrase_cb (int index, CallbackFunction cb);
 #define NPCPhrase(index) NPCPhrase_cb ((index), NULL)
 extern void NPCPhrase_splice (int index);
 extern void NPCNumber (int number, const char *fmt);
 
-#define ALLIANCE_NAME_BUFSIZE 256
-extern void GetAllianceName (UNICODE *buf, RESPONSE_REF name_1);
-
 extern void construct_response (UNICODE *buf, int R /* promoted from
 		RESPONSE_REF */, ...);
 
+typedef enum {
+	Segue_peace,
+			// When initiating a conversation, open comms directly.
+			// When terminating a conversation, depart in peace.
+	Segue_hostile,
+			// When initiating a conversation, offer the choice to attack.
+			// When terminating a conversation, go into battle.
+	Segue_victory,
+			// (when terminating a conversation) instant victory
+	Segue_defeat,
+			// (when terminating a conversation) game over
+} Segue;
+
+void setSegue (Segue segue);
+Segue getSegue (void);
+
+extern RESPONSE_REF phraseIdStrToNum(const char *phraseId);
+extern const char *phraseIdNumToStr (RESPONSE_REF response);
+
 extern LOCDATA* init_race (CONVERSATION comm_id);
 
 extern LOCDATA* init_arilou_comm (void);
@@ -124,5 +138,9 @@ extern LOCDATA* init_zoqfot_comm (void);
 
 extern LOCDATA* init_umgah_comm (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _COMMGLUE_H */
 
diff -ruNp src.hd/uqm/confirm.c src/uqm/confirm.c
--- src.hd/uqm/confirm.c	2017-12-29 02:25:52 -0800
+++ src/uqm/confirm.c	2017-12-29 00:57:45 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "controls.h"
 #include "colors.h"
 #include "settings.h"
@@ -85,7 +83,8 @@ DoConfirmExit (void)
 	if (PlayingTrack ())
 		PauseTrack ();
 
-	LockMutex (GraphicsLock);
+	PauseFlash ();
+
 	{
 		RECT r;
 		STAMP s;
@@ -160,7 +159,8 @@ DoConfirmExit (void)
 		SetContextClipRect (&oldRect);
 		SetContext (oldContext);
 	}
-	UnlockMutex (GraphicsLock);
+
+	ContinueFlash ();
 
 	if (PlayingTrack ())
 		ResumeTrack ();
@@ -214,7 +214,7 @@ DoPopupWindow (const char *msg)
 	label.line_count = SplitString (msg, '\n', 30, lines, bank);
 	label.lines = lines;
 
-	LockMutex (GraphicsLock);
+	PauseFlash ();
 
 	oldContext = SetContext (ScreenContext);
 	GetContextClipRect (&oldRect);
@@ -243,7 +243,8 @@ DoPopupWindow (const char *msg)
 	DestroyDrawable (ReleaseDrawable (s.frame));
 	SetContextClipRect (&oldRect);
 	SetContext (oldContext);
-	UnlockMutex (GraphicsLock);
+	ContinueFlash ();
 	SetMenuSounds (s0, s1);
 	StringBank_Free (bank);
 }
+
diff -ruNp src.hd/uqm/cons_res.c src/uqm/cons_res.c
--- src.hd/uqm/cons_res.c	2017-12-29 02:25:52 -0800
+++ src/uqm/cons_res.c	2017-12-29 00:57:45 -0800
@@ -110,3 +110,11 @@ load_orbit_theme (BYTE selector)
 	buffer[79] = '\0'; /* Shouldn't be necessary, but better safe than sorry */	
 	return LoadMusic (buffer);
 }
+
+MUSIC_REF
+loadMainMenuMusic (BYTE selector)
+{
+	snprintf (buffer, 79, "music.mainmenu%d", selector + 1);
+	buffer[79] = '\0'; /* Shouldn't be necessary, but better safe than sorry */	
+	return LoadMusic (buffer);
+}
diff -ruNp src.hd/uqm/cons_res.h src/uqm/cons_res.h
--- src.hd/uqm/cons_res.h	2017-12-29 02:25:52 -0800
+++ src/uqm/cons_res.h	2017-12-29 00:57:45 -0800
@@ -20,11 +20,24 @@
 #include "libs/gfxlib.h"
 #include "libs/sndlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 void load_gravity_well (BYTE selector);
 void free_gravity_well (void);
 
 FRAME load_life_form (BYTE selector);
 
+#define NUM_ORBIT_THEMES 5
+static MUSIC_REF OrbitMusic[NUM_ORBIT_THEMES];
 MUSIC_REF load_orbit_theme (BYTE selector);
 
+#define NUM_MM_THEMES 3
+MUSIC_REF loadMainMenuMusic (BYTE selector);
+
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* CONS_RES_H_ */
diff -ruNp src.hd/uqm/controls.h src/uqm/controls.h
--- src.hd/uqm/controls.h	2017-12-29 02:25:52 -0800
+++ src/uqm/controls.h	2017-12-29 00:57:45 -0800
@@ -23,6 +23,10 @@
 #include "libs/strlib.h"
 #include "libs/timelib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 // Enumerated type for controls
 enum {
 	KEY_UP,
@@ -59,10 +63,10 @@ enum {
 	KEY_MENU_SEARCH,
 	KEY_MENU_NEXT,
 	KEY_MENU_TOGGLEMAP, // JMS: For showing SC1-era starmap
+	KEY_MENU_ANY, /* abstract char key */
 	KEY_DEBUG_2,  // JMS: Secondary debug key
 	KEY_DEBUG_3,  // JMS: Tertiary debug key
 	KEY_DEBUG_4,  // JMS: Quaternary debug key
-	KEY_MENU_ANY, /* abstract char key */
 	NUM_MENU_KEYS
 };
 
@@ -119,9 +123,6 @@ BOOLEAN WaitForNoInputUntil (TimeCount t
 void DoPopupWindow(const char *msg);
 
 typedef void (InputFrameCallback) (void);
-// Anything using input callbacks MUST NOT keep GraphicsLock across
-// InputFunc executions. This also means NOT holding GraphicsLock
-// when calling DoInput().
 InputFrameCallback* SetInputCallback (InputFrameCallback *);
 // pInputState must point to a struct derived from INPUT_STATE_DESC
 void DoInput (void *pInputState, BOOLEAN resetInput);
@@ -165,7 +166,10 @@ typedef struct textentry_state
 } TEXTENTRY_STATE;
 
 extern BOOLEAN DoTextEntry (TEXTENTRY_STATE *pTES);
-extern BOOLEAN DoTextEntrySavename (TEXTENTRY_STATE *pTES);
+
+#if defined(__cplusplus)
+}
+#endif
 
 #endif
 
diff -ruNp src.hd/uqm/credits.c src/uqm/credits.c
--- src.hd/uqm/credits.c	2017-12-29 02:25:52 -0800
+++ src/uqm/credits.c	2017-12-29 00:57:45 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "credits.h"
 
 #include "controls.h"
@@ -242,7 +240,6 @@ Credits_RenderTextFrame (CONTEXT TempCon
 	t.pStr = " ";
 	t.CharCount = 1;
 
-	LockMutex (GraphicsLock);
 	OldContext = SetContext (TempContext);
 
 	// get font dimensions
@@ -269,7 +266,7 @@ Credits_RenderTextFrame (CONTEXT TempCon
 		{	// DOES NOT COMPUTE! :)
 			continue;
 		}
-		
+
 		x <<= RESOLUTION_FACTOR; // JMS_GFX
 
 		switch (c)
@@ -316,7 +313,6 @@ Credits_RenderTextFrame (CONTEXT TempCon
 	
 	SetContextFGFrame (OldFrame);
 	SetContext (OldContext);
-	UnlockMutex (GraphicsLock);
 
 	return f;
 }
@@ -335,7 +331,6 @@ RenderCreditsScreen (CONTEXT targetConte
 	STAMP s;
 	int i;
 
-	LockMutex (GraphicsLock);
 	oldContext = SetContext (targetContext);
 	// draw background
 	s.origin.x = 0;
@@ -362,7 +357,6 @@ RenderCreditsScreen (CONTEXT targetConte
 	}
 	
 	SetContext (oldContext);
-	UnlockMutex (GraphicsLock);
 }
 
 static void
@@ -377,7 +371,6 @@ InitCredits (void)
 	LocalContext = CreateContext ("Credits.LocalContext");
 	DrawContext = CreateContext ("Credits.DrawContext");
 
-	LockMutex (GraphicsLock);
 	targetFrame = GetContextFGFrame ();
 	GetContextClipRect (&ctxRect);
 	CreditsExtent = ctxRect.extent;
@@ -406,7 +399,6 @@ InitCredits (void)
 	SetContextFGFrame (targetFrame);
 
 	SetContext (oldContext);
-	UnlockMutex (GraphicsLock);
 
 	// Prepare the first screen frame
 	RenderCreditsScreen (LocalContext);
@@ -497,12 +489,10 @@ processCreditsFrame (void)
 		s.origin.y = 0;
 		s.frame = CreditsFrame;
 
-		LockMutex (GraphicsLock);
 		OldContext = SetContext (DrawContext);
 		DrawStamp (&s);
 		SetContext (OldContext);
 		FlushGraphics ();
-		UnlockMutex (GraphicsLock);
 
 		// prepare next screen frame
 		deficitHeight = calcDeficitHeight ();
@@ -787,13 +777,11 @@ Credits (BOOLEAN WithOuttakes)
 
 	hMusic = LoadMusic (CREDITS_MUSIC);
 
-	LockMutex (GraphicsLock);
 	SetContext (ScreenContext);
 	SetContextClipRect (NULL);
 	GetContextClipRect (&screenRect);
 	SetContextBackGroundColor (BLACK_COLOR);
 	ClearDrawable ();
-	UnlockMutex (GraphicsLock);
 
 	if (!LoadCredits ())
 		return;
@@ -802,10 +790,8 @@ Credits (BOOLEAN WithOuttakes)
 	s.origin.x = 0;
 	s.origin.y = 0;
 	s.frame = CreditsBack;
-	LockMutex (GraphicsLock);
 	DrawStamp (&s);
 	FadeScreen (FadeAllToColor, ONE_SECOND / 2);
-	UnlockMutex (GraphicsLock);
 
 	// set the position of outtakes comm
 	CommWndRect.corner.x = ((screenRect.extent.width - CommWndRect.extent.width) / 2); // JMS_GFX
@@ -840,11 +826,9 @@ Credits (BOOLEAN WithOuttakes)
 	FadeMusic (0, ONE_SECOND / 2);
 	UninitCredits ();
 
-	LockMutex (GraphicsLock);
 	SetContext (ScreenContext);
 	SleepThreadUntil (FadeScreen (FadeAllToBlack, ONE_SECOND / 2));
 	FlushColorXForms ();
-	UnlockMutex (GraphicsLock);
 
 	if (hMusic)
 	{
diff -ruNp src.hd/uqm/credits.h src/uqm/credits.h
--- src.hd/uqm/credits.h	2017-12-29 02:25:52 -0800
+++ src/uqm/credits.h	2017-12-29 00:57:45 -0800
@@ -19,7 +19,15 @@
 
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern void Credits (BOOLEAN WithOuttakes);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _CREDITS_H */
 
diff -ruNp src.hd/uqm/cyborg.c src/uqm/cyborg.c
--- src.hd/uqm/cyborg.c	2017-12-29 02:25:52 -0800
+++ src/uqm/cyborg.c	2017-12-29 00:57:45 -0800
@@ -16,11 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX:	 - Added RESOLUTION_FACTORs to LONG_RANGE_WEAPONs and CLOSE_RANGE_WEAPONs
-//			 - Amended some constant values with RESOLUTION_FACTOR
-
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "colors.h"
 #include "collide.h"
 #include "element.h"
diff -ruNp src.hd/uqm/demo.h src/uqm/demo.h
--- src.hd/uqm/demo.h	2017-12-29 02:25:52 -0800
+++ src/uqm/demo.h	2017-12-29 00:57:45 -0800
@@ -19,6 +19,10 @@
 #ifndef _DEMO_H
 #define _DEMO_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #ifndef DEMO_MODE
 #define DEMO_MODE 0
 #endif /* DEMO_MODE */
@@ -44,5 +48,9 @@ extern void JournalInput (INPUT_STATE In
 
 #endif
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _DEMO_H */
 
diff -ruNp src.hd/uqm/displist.h src/uqm/displist.h
--- src.hd/uqm/displist.h	2017-12-29 02:25:52 -0800
+++ src/uqm/displist.h	2017-12-29 00:57:45 -0800
@@ -24,6 +24,10 @@
 #include "libs/compiler.h"
 #include "libs/memlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 // Note that we MUST use the QUEUE_TABLE variant at this time, because
 // certain gameplay elements depend on it. Namely, the maximum number
 // of HyperSpace encounter globes chasing the player is defined by the
@@ -120,5 +124,9 @@ extern void RemoveQueue (QUEUE *pq, HLIN
 extern COUNT CountLinks (QUEUE *pq);
 void ForAllLinks(QUEUE *pq, void (*callback)(LINK *, void *), void *arg);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _DISPLIST_H */
 
diff -ruNp src.hd/uqm/element.h src/uqm/element.h
--- src.hd/uqm/element.h	2017-12-29 02:25:52 -0800
+++ src/uqm/element.h	2017-12-29 00:57:45 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #ifndef _ELEMENT_H
 #define _ELEMENT_H
 
@@ -26,6 +24,10 @@
 #include "velocity.h"
 #include "libs/gfxlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 
 #define NORMAL_LIFE 1
 
@@ -94,7 +96,8 @@ typedef struct state
 
 typedef struct element ELEMENT;
 
-typedef void (CollisionFunc) (ELEMENT *ElementPtr0, POINT *pPt0,
+typedef void (ElementProcessFunc) (ELEMENT *ElementPtr);
+typedef void (ElementCollisionFunc) (ELEMENT *ElementPtr0, POINT *pPt0,
 			ELEMENT *ElementPtr1, POINT *pPt1);
 
 // Any physical object in the simulation.
@@ -103,10 +106,10 @@ struct element
 	// LINK elements; must be first
 	HELEMENT pred, succ;
 
-	void (*preprocess_func) (struct element *ElementPtr);
-	void (*postprocess_func) (struct element *ElementPtr);
-	CollisionFunc *collision_func;
-	void (*death_func) (struct element *ElementPtr);
+	ElementProcessFunc *preprocess_func;
+	ElementProcessFunc *postprocess_func;
+	ElementCollisionFunc *collision_func;
+	ElementProcessFunc *death_func;
 
 	// Player this element belongs to
 	// -1: neutral (planets, asteroids, crew, etc.)
@@ -232,5 +235,9 @@ extern void MoveGalaxy (VIEW_STATE view_
 extern BOOLEAN CalculateGravity (ELEMENT *ElementPtr);
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _ELEMENT_H */
 
diff -ruNp src.hd/uqm/encount.c src/uqm/encount.c
--- src.hd/uqm/encount.c	2017-12-29 02:25:52 -0800
+++ src/uqm/encount.c	2017-12-29 00:57:45 -0800
@@ -16,14 +16,13 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "encount.h"
 
 #include "battle.h"
 #include "battlecontrols.h"
 #include "build.h"
 #include "colors.h"
+#include "starmap.h"
 #include "cons_res.h"
 #include "controls.h"
 #include "menustat.h"
@@ -80,9 +79,7 @@ DoSelectAction (MENU_STATE *pMS)
 				if (!GameOptions ())
 					return FALSE;
 				DrawMenuStateStrings (PM_CONVERSE, pMS->CurState);
-				LockMutex (GraphicsLock);
 				SetFlashRect (SFR_MENU_3DO);
-				UnlockMutex (GraphicsLock);
 				break;
 			default:
 				printf ("Unknown option: %d\n", pMS->CurState);
@@ -272,7 +269,6 @@ InitEncounter (void)
 	extern FRAME planet[];
 	MUSIC_REF MR;
 
-	LockMutex (GraphicsLock);
 
 	SetContext (SpaceContext);
 	SetContextFont (TinyFont);
@@ -280,11 +276,9 @@ InitEncounter (void)
 	MR = LoadMusic (REDALERT_MUSIC);
 	PlayMusic (MR, FALSE, 1);
 	SegueFrame = CaptureDrawable (LoadGraphic (SEGUE_PMAP_ANIM));
-	UnlockMutex (GraphicsLock);
 	WaitForSoundEnd (TFBSOUND_WAIT_ALL);
 	StopMusic ();
 	DestroyMusic (MR);
-	LockMutex (GraphicsLock);
 	s.origin.x = s.origin.y = 0;
 
 	SetTransitionSource (NULL);
@@ -303,7 +297,7 @@ InitEncounter (void)
 	SetContextFont (MicroFont);
 	SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01));
-	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+	if (inHQSpace ())
 	{
 		t.pStr = GAME_STRING (ENCOUNTER_STRING_BASE + 0);
 				// "ENCOUNTER IN"
@@ -370,7 +364,6 @@ InitEncounter (void)
 				hNextShip = hStarShip;
 
 			s.origin = display_pt[i % NUM_DISPLAY_PTS];
-			
 			if (i >= NUM_DISPLAY_PTS)
 			{
 				COUNT angle, radius;
@@ -378,19 +371,16 @@ InitEncounter (void)
 				radius = square_root ((long)s.origin.x * s.origin.x
 						+ (long)s.origin.y * s.origin.y)
 						+ ((i / NUM_DISPLAY_PTS) * 18);
-				
+
 				radius <<= RESOLUTION_FACTOR; // JMS_GFX
 
 				angle = ARCTAN (s.origin.x, s.origin.y);
 				s.origin.x = (COSINE (angle, radius));
 				s.origin.y = (SINE (angle, radius));
-			}
-			else
-			{
+			} else {
 				s.origin.x <<= RESOLUTION_FACTOR; // JMS_GFX
 				s.origin.y <<= RESOLUTION_FACTOR; // JMS_GFX
 			}
-				
 			s.frame = SetAbsFrameIndex (FragPtr->icons, 0);
 			GetFrameRect (s.frame, &r);
 			s.origin.x += (SIS_SCREEN_WIDTH >> 1) - (r.extent.width >> 1);
@@ -405,7 +395,6 @@ InitEncounter (void)
 	DestroyDrawable (ReleaseDrawable (SegueFrame));
 	ScreenTransition (3, NULL);
 
-	UnlockMutex (GraphicsLock);
 
 	{
 		MENU_STATE MenuState;
@@ -414,15 +403,11 @@ InitEncounter (void)
 		MenuState.Initialized = FALSE;
 
 		DrawMenuStateStrings (PM_CONVERSE, MenuState.CurState = HAIL);
-		LockMutex (GraphicsLock);
 		SetFlashRect (SFR_MENU_3DO);
-		UnlockMutex (GraphicsLock);
 
 		DoInput (&MenuState, TRUE);
 
-		LockMutex (GraphicsLock);
 		SetFlashRect (NULL);
-		UnlockMutex (GraphicsLock);
 
 		return (MenuState.CurState);
 	}
@@ -463,10 +448,8 @@ DrawFadeText (const UNICODE *str1, const
 	{
 		for (i = 0; i < (SIZE) NUM_FADES; ++i)
 		{
-			UnlockMutex (GraphicsLock);
 			if (AnyButtonPress (TRUE))
 				i = NUM_FADES - 1;
-			LockMutex (GraphicsLock);
 
 			SetContextForeGroundColor (fade_cycle[i]);
 			font_DrawText (&t1);
@@ -479,10 +462,8 @@ DrawFadeText (const UNICODE *str1, const
 	{
 		for (i = NUM_FADES - 1; i >= 0; --i)
 		{
-			UnlockMutex (GraphicsLock);
 			if (AnyButtonPress (TRUE))
 				i = 0;
-			LockMutex (GraphicsLock);
 
 			SetContextForeGroundColor (fade_cycle[i]);
 			font_DrawText (&t1);
@@ -490,18 +471,12 @@ DrawFadeText (const UNICODE *str1, const
 			SleepThreadUntil (TimeIn + (ONE_SECOND / 20));
 			TimeIn = GetTimeCounter ();
 		}
-		// SetContextForeGroundColor (
-		//		BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
-		// font_DrawText (&t1);
-		// font_DrawText (&t2);
-		// BW: previous lines don't work with anti-aliased fonts
 		SetContextForeGroundColor (
-				   BUILD_COLOR_RGBA (0x50, 0x50, 0x50, 0xff));
+				BUILD_COLOR_RGBA (0x50, 0x50, 0x50, 0xff));
 		TextRect(&t1, &r1, NULL);
 		TextRect(&t2, &r2, NULL);
 		DrawFilledRectangle (&r1);
 		DrawFilledRectangle (&r2);
-
 	}
 }
 
@@ -512,7 +487,6 @@ UninitEncounter (void)
 
 	ships_killed = 0;
 
-	LockMutex (GraphicsLock);
 	free_gravity_well ();
 
 	if ((GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD))
@@ -529,24 +503,19 @@ UninitEncounter (void)
 	else
 	{
 		BOOLEAN Sleepy;
-		SIZE VictoryState;
+		SIZE VictoryState, i;
 		COUNT RecycleAmount = 0;
-		SIZE i;
-		RECT r;
+		RECT r, save_r;
 		RECT scavenge_r = {{0, 0}, {0, 0}};
 		TEXT t;
-		STAMP ship_s;
+		STAMP ship_s, saveMetallicFrame;
 		const UNICODE *str1 = NULL;
 		const UNICODE *str2 = NULL;
 		StatMsgMode prevMsgMode;
 		UNICODE buf[80];
 		HSHIPFRAG hStarShip;
 		SHIP_FRAGMENT *FragPtr;
-		
-		// JMS: These are for fixing a bug at drawing "debris scavenged" in hires4x
-		RECT	save_r;
-		STAMP	saveMetallicFrame;
-		
+
 		static const Color fade_ship_cycle[] =
 		{
 			BUILD_COLOR (MAKE_RGB15_INIT (0x07, 0x00, 0x00), 0x2F),
@@ -606,7 +575,7 @@ UninitEncounter (void)
 				{
 					DrawSISFrame ();
 					DrawSISMessage (NULL);
-					if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+					if (inHQSpace ())
 						DrawHyperCoords (GLOBAL (ShipStamp.origin));
 					else if (GLOBAL (ip_planet) == 0)
 						DrawHyperCoords (CurStarDescPtr->star_pt);
@@ -658,6 +627,21 @@ UninitEncounter (void)
 								// XXX: this will not work with UTF-8 strings
 								strupr (buf);
 
+								// JMS: Handling the a-umlaut and o-umlaut characters
+								{
+									unsigned char *ptr;
+									ptr = (unsigned char*)buf;
+									while (*ptr) {
+										if (*ptr == 0xc3) {
+											ptr++;
+											if (*ptr == 0xb6 || *ptr == 0xa4) {
+												*ptr += 'A' - 'a';
+											}
+										}
+										ptr++;
+									}
+								}
+
 								t.baseline.x = scavenge_r.corner.x + (100 << RESOLUTION_FACTOR); // JMS_GFX
 								t.baseline.y = scavenge_r.corner.y + (68 << RESOLUTION_FACTOR); // JMS_GFX
 								t.align = ALIGN_CENTER;
@@ -674,7 +658,7 @@ UninitEncounter (void)
 								ship_s.frame = FragPtr->icons;
 
 								SetContextFont (MicroFont);
-								
+
 								// JMS: Let's store the rectangle behind "Enemy ships destroyed" (before drawing the text on it).
 								if (RESOLUTION_FACTOR != 0)
 								{
@@ -691,7 +675,7 @@ UninitEncounter (void)
 									// Now that we have the size and placement of the rectangle, let's store it.
 									saveMetallicFrame = SaveContextFrame (&save_r);
 								}
-								
+
 								str1 = GAME_STRING (
 										ENCOUNTER_STRING_BASE + 4);
 										// "Enemy Ships"
@@ -745,10 +729,8 @@ UninitEncounter (void)
 								TimeCount Time = GetTimeCounter ();
 								for (j = 0; j < NUM_SHIP_FADES; ++j)
 								{
-									UnlockMutex (GraphicsLock);
 									Sleepy = (BOOLEAN)!AnyButtonPress (TRUE) &&
 											!(GLOBAL (CurrentActivity) & CHECK_ABORT);
-									LockMutex (GraphicsLock);
 									if (!Sleepy)
 										break;
 
@@ -759,18 +741,20 @@ UninitEncounter (void)
 									Time = GetTimeCounter ();
 								}
 							}
-                            if (RESOLUTION_FACTOR > 0) {
-                                SetContextForeGroundColor (BLACK_COLOR);
-                                DrawFilledStamp (&ship_s);
-                                DrawFilledStamp (&ship_s);
-                                DrawFilledStamp (&ship_s);
-                                DrawFilledStamp (&ship_s);
-                                DrawFilledStamp (&ship_s);
-                                DrawFilledStamp (&ship_s);
-                                DrawFilledStamp (&ship_s);
-                                DrawFilledStamp (&ship_s);
-                                DrawFilledStamp (&ship_s);
-                            }
+
+							if (RESOLUTION_FACTOR > 0) {
+								SetContextForeGroundColor (BLACK_COLOR);
+								DrawFilledStamp (&ship_s);
+								DrawFilledStamp (&ship_s);
+								DrawFilledStamp (&ship_s);
+								DrawFilledStamp (&ship_s);
+								DrawFilledStamp (&ship_s);
+								DrawFilledStamp (&ship_s);
+								DrawFilledStamp (&ship_s);
+								DrawFilledStamp (&ship_s);
+								DrawFilledStamp (&ship_s);
+							}
+
 							DrawStamp (&ship_s);
 						}
 					}
@@ -793,9 +777,7 @@ UninitEncounter (void)
 			DestroyDrawable (ReleaseDrawable (s.frame));
 #endif /* NEVER */
 
-			UnlockMutex (GraphicsLock);
 			WaitForAnyButton (TRUE, ONE_SECOND * 3, FALSE);
-			LockMutex (GraphicsLock);
 			if (!CurrentInputState.key[PlayerControls[0]][KEY_ESCAPE])
 			{
 				DrawFadeText (str1, str2, FALSE, &scavenge_r);
@@ -820,19 +802,17 @@ UninitEncounter (void)
 							// "Debris"
 					str2 = GAME_STRING (ENCOUNTER_STRING_BASE + 7);
 							// "Scavenged"
-					
+
 					// JMS: Now we draw the clean metallic frame to erase the "Enemy ships destroyed"
 					// text before drawing "debris scavenged."
 					if(RESOLUTION_FACTOR != 0)
 						DrawStamp (&saveMetallicFrame);
-					
+
 					DrawFadeText (str1, str2, TRUE, &scavenge_r);
-					UnlockMutex (GraphicsLock);
 					WaitForAnyButton (TRUE, ONE_SECOND * 2, FALSE);
-					LockMutex (GraphicsLock);
 					if (!CurrentInputState.key[PlayerControls[0]][KEY_ESCAPE])
 						DrawFadeText (str1, str2, FALSE, &scavenge_r);
-					
+
 					// JMS: The final cleanup of the "Debris scavenged". Without this, an ugly grey ghost-text would remain.
 					if(RESOLUTION_FACTOR != 0)
 						DrawStamp (&saveMetallicFrame);
@@ -852,7 +832,6 @@ UninitEncounter (void)
 		}
 	}
 ExitUninitEncounter:
-	UnlockMutex (GraphicsLock);
 
 	return (ships_killed);
 }
@@ -864,7 +843,6 @@ EncounterBattle (void)
 	extern UWORD nth_frame;
 	InputContext *savedPlayerInput = NULL;
 
-	LockMutex (GraphicsLock);
 
 	SET_GAME_STATE (BATTLE_SEGUE, 1);
 
@@ -903,9 +881,7 @@ EncounterBattle (void)
 
 	GameSounds = CaptureSound (LoadSound (GAME_SOUNDS));
 
-	UnlockMutex (GraphicsLock);
 	Battle (NULL);
-	LockMutex (GraphicsLock);
 
 	DestroySound (ReleaseSound (GameSounds));
 	GameSounds = 0;
@@ -929,6 +905,5 @@ EncounterBattle (void)
 
 	GLOBAL (CurrentActivity) = OldActivity;
 
-	UnlockMutex (GraphicsLock);
 }
 
diff -ruNp src.hd/uqm/encount.h src/uqm/encount.h
--- src.hd/uqm/encount.h	2017-12-29 02:25:52 -0800
+++ src/uqm/encount.h	2017-12-29 00:57:45 -0800
@@ -30,12 +30,24 @@ typedef struct encounter ENCOUNTER;
 #include "element.h"
 #include "races.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 
 typedef HLINK HENCOUNTER;
 
 #define MAX_HYPER_SHIPS 7
+
+// ENCOUNTER.flags
+// XXX: Currently, the flags are combined with num_ships into a single BYTE
+//   in the savegames: num_ships occupy the low nibble and flags the high one.
+//   Bits 4 and 5 are available for more flags in the savegames,
+//   and bits 0-3 available in the game but will not be saved.
 #define ONE_SHOT_ENCOUNTER (1 << 7)
 #define ENCOUNTER_REFORMING (1 << 6)
+#define ENCOUNTER_SHIPS_MASK  0x0f
+#define ENCOUNTER_FLAGS_MASK  0xf0
 
 struct brief_ship_info
 {
@@ -57,9 +69,14 @@ struct encounter
 	SIZE transition_state;
 	POINT origin;
 	COUNT radius;
+	BYTE race_id;
+	BYTE num_ships;
+	BYTE flags;
+			// See ENCOUNTER.flags above
+	POINT loc_pt;
 
-	STAR_DESC SD;
 	BRIEF_SHIP_INFO ShipList[MAX_HYPER_SHIPS];
+			// Only the crew_level member is currently used
 
 	SDWORD log_x, log_y;
 };
@@ -78,78 +95,10 @@ struct encounter
 
 enum
 {
-	SOL_DEFINED = 1,
-	SHOFIXTI_DEFINED,
-	MAIDENS_DEFINED,
-	START_COLONY_DEFINED,
-	SPATHI_DEFINED,
-	ZOQFOT_DEFINED,
-
-	MELNORME0_DEFINED,
-	MELNORME1_DEFINED,
-	MELNORME2_DEFINED,
-	MELNORME3_DEFINED,
-	MELNORME4_DEFINED,
-	MELNORME5_DEFINED,
-	MELNORME6_DEFINED,
-	MELNORME7_DEFINED,
-	MELNORME8_DEFINED,
-
-	TALKING_PET_DEFINED,
-	CHMMR_DEFINED,
-	SYREEN_DEFINED,
-	BURVIXESE_DEFINED,
-	SLYLANDRO_DEFINED,
-	DRUUGE_DEFINED,
-	BOMB_DEFINED,
-	AQUA_HELIX_DEFINED,
-	SUN_DEVICE_DEFINED,
-	TAALO_PROTECTOR_DEFINED,
-	SHIP_VAULT_DEFINED,
-	URQUAN_WRECK_DEFINED,
-	VUX_BEAST_DEFINED,
-	SAMATRA_DEFINED,
-	ZOQ_SCOUT_DEFINED,
-	MYCON_DEFINED,
-	EGG_CASE0_DEFINED,
-	EGG_CASE1_DEFINED,
-	EGG_CASE2_DEFINED,
-	PKUNK_DEFINED,
-	UTWIG_DEFINED,
-	SUPOX_DEFINED,
-	YEHAT_DEFINED,
-	VUX_DEFINED,
-	ORZ_DEFINED,
-	THRADD_DEFINED,
-	RAINBOW_DEFINED,
-	ILWRATH_DEFINED,
-	ANDROSYNTH_DEFINED,
-	MYCON_TRAP_DEFINED,
-	ZOQ_COLONY0_DEFINED,
-	ZOQ_COLONY1_DEFINED,
-};
-
-#define UMGAH_DEFINED TALKING_PET_DEFINED
-
-// XXX: The stuff till EOC does not belong here
-extern STAR_DESC *CurStarDescPtr;
-extern STAR_DESC *star_array;
-
-#define NUM_SOLAR_SYSTEMS 502
-
-extern STAR_DESC* FindStar (STAR_DESC *pLastStar, POINT *puniverse,
-		SIZE xbounds, SIZE ybounds);
-
-extern void GetClusterName (const STAR_DESC *pSD, UNICODE buf[]);
-// <<< EOC
-
-enum
-{
 	HAIL = 0,
 	ATTACK
 };
 
-
 extern void EncounterBattle (void);
 extern void BuildBattle (COUNT which_player);
 extern COUNT InitEncounter (void);
@@ -157,40 +106,15 @@ extern COUNT UninitEncounter (void);
 extern BOOLEAN FleetIsInfinite (COUNT playerNr);
 extern void UpdateShipFragCrew (STARSHIP *);
 
-// XXX: in comm.h, temporary, until solsys generation code is redone
-extern COUNT InitCommunication (CONVERSATION which_comm);
-
-extern void GenerateSOL (BYTE control);
-extern void GenerateShofixti (BYTE control);
-extern void GenerateColony (BYTE control);
-extern void GenerateSpathi (BYTE control);
-extern void GenerateZoqFotPik (BYTE control);
-extern void GenerateMelnorme (BYTE control);
-extern void GenerateTalkingPet (BYTE control);
-extern void GenerateChmmr (BYTE control);
-extern void GenerateSyreen (BYTE control);
-extern void GenerateBurvixes (BYTE control);
-extern void GenerateSlylandro (BYTE control);
-extern void GenerateDruuge (BYTE control);
-extern void GenerateUtwig (BYTE control);
-extern void GenerateThradd (BYTE control);
-extern void GenerateMycon (BYTE control);
-extern void GenerateOrz (BYTE control);
-extern void GenerateShipVault (BYTE control);
-extern void GenerateUrquanWreck (BYTE control);
-extern void GenerateVUX (BYTE control);
-extern void GenerateSamatra (BYTE control);
-extern void GenerateYehat (BYTE control);
-extern void GeneratePkunk (BYTE control);
-extern void GenerateSupox (BYTE control);
-extern void GenerateRainbow (BYTE control);
-extern void GenerateIlwrath (BYTE control);
-
 // Last race the player battled with, or -1 if no battle took place.
 // Set to -1 by some funcs to inhibit IP groups from intercepting
 // the flagship.
 extern SIZE EncounterRace;
 extern BYTE EncounterGroup;
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _ENCOUNT_H */
 
diff -ruNp src.hd/uqm/flash.c src/uqm/flash.c
--- src.hd/uqm/flash.c	2017-12-29 02:25:52 -0800
+++ src/uqm/flash.c	2017-12-29 00:57:45 -0800
@@ -14,12 +14,16 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 // NOTE: A lot of this code is untested. Only highlite and overlay flash
 //       areas, drawing directly to the screen, using a cache, are
 //       currently in use.
 
+// NOTE:
+// - If you change the properties of the original CONTEXT, specifically the
+//   dimensions and origin, you'll need to call Flash_preUpdate() before and
+//   Flash_postUpdate() after that change. Note that this may change which
+//   part of the screen is flashing.
+
 // TODO:
 // - During a few frames during the sequence, the frame to be displayed
 //   is equal to a frame which was supplied as a parameter to the flash
@@ -32,8 +36,6 @@
 #define FLASH_INTERNAL
 #include "flash.h"
 
-#include "setup.h"
-// For GraphicsLock.
 #include "libs/log.h"
 #include "libs/memlib.h"
 #include "libs/threadlib.h"
@@ -46,58 +48,58 @@ static void Flash_clearCache (FlashConte
 static void Flash_initCache (FlashContext *context);
 static void Flash_grabOriginal (FlashContext *context);
 static void Flash_blendFraction (FlashContext *context, int numer, int denom,
-								 int *resNumer, int *resDenom);
+		int *resNumer, int *resDenom);
 static void Flash_makeFrame (FlashContext *context,
-							 FRAME dest, int numer, int denom);
+		FRAME dest, int numer, int denom);
 static inline void Flash_prepareCacheFrame (FlashContext *context,
-											COUNT index);
+		COUNT index);
 static void Flash_drawFrame (FlashContext *context, FRAME frame);
 static void Flash_drawCacheFrame (FlashContext *context, COUNT index);
 static inline void Flash_drawUncachedFrame (FlashContext *context,
-											int numer, int denom);
+		int numer, int denom);
 static inline void Flash_drawCachedFrame (FlashContext *context,
-										  int numer, int denom);
+		int numer, int denom);
 static void Flash_drawCurrentFrame (FlashContext *context);
 
 static CONTEXT workGfxContext;
-// Off-screen internal drawing context
+		// Off-screen internal drawing context
 
 static FlashContext *
 Flash_create (CONTEXT gfxContext)
 {
 	FlashContext *context = HMalloc (sizeof (FlashContext));
-	
+
 	context->gfxContext     = gfxContext;
-	
+
 	context->original       = 0;
-	
+
 	context->startNumer     = 0;
 	context->endNumer       = 1;
 	context->denom          = 1;
-	
+
 	context->fadeInTime     = Flash_DEFAULT_FADE_IN_TIME;
 	context->onTime         = Flash_DEFAULT_ON_TIME;
 	context->fadeOutTime    = Flash_DEFAULT_FADE_OUT_TIME;
 	context->offTime        = Flash_DEFAULT_OFF_TIME;
-	
+
 	context->frameTime      = 0;
-	
+
 	context->state          = FlashState_off;
 	context->lastStateTime  = 0;
 	context->lastFrameTime  = 0;
 	
 	context->started        = false;
 	context->paused         = false;
-	
+
 	context->cache          = 0;
 	context->cacheSize      = Flash_DEFAULT_CACHE_SIZE;
 	
 	context->lastFrameIndex = (COUNT) -1;
-	
+
 	// TODO: Delete the context somewhere
 	if (!workGfxContext)
 		workGfxContext = CreateContext ("Flash.workGfxContext");
-	
+
 	return context;
 }
 
@@ -108,7 +110,7 @@ FlashContext *
 Flash_createHighlight (CONTEXT gfxContext, const RECT *rect)
 {
 	FlashContext *context = Flash_create (gfxContext);
-	
+
 	if (rect == NULL)
 	{
 		// No rectangle specified. It should be specified later with
@@ -121,18 +123,18 @@ Flash_createHighlight (CONTEXT gfxContex
 	else
 		context->rect = *rect;
 	context->type = FlashType_highlight;
-	
+
 	return context;
 }
 
 FlashContext *
 Flash_createTransition (CONTEXT gfxContext, const POINT *origin,
-						FRAME first, FRAME final)
+		FRAME first, FRAME final)
 {
 	FlashContext *context = Flash_create (gfxContext);
 	
 	context->type = FlashType_transition;
-	
+
 	context->u.transition.first = first;
 	context->u.transition.final = final;
 	GetFrameRect (final, &context->rect);
@@ -145,9 +147,9 @@ FlashContext *
 Flash_createOverlay (CONTEXT gfxContext, const POINT *origin, FRAME overlay)
 {
 	FlashContext *context = Flash_create (gfxContext);
-	
+
 	context->type = FlashType_overlay;
-	
+
 	if (origin == NULL || overlay == NULL) {
 		// No overlay specified. It should be specified later with
 		// Flash_setOverlay(), before calling Flash_start().
@@ -166,18 +168,18 @@ Flash_createOverlay (CONTEXT gfxContext,
 // be considered to be already spent in this state.
 void
 Flash_setState (FlashContext *context, FlashState state,
-				TimeCount timeSpentInState)
+		TimeCount timeSpentInState)
 {
 	TimeCount now;
 	
 	now = GetTimeCounter ();
-	
+
 	context->state = state;
 	Flash_fixState (context);
 	
 	context->lastStateTime = now - timeSpentInState;
 	context->lastFrameTime = now;
-	
+
 	if (context->started)
 		Flash_drawCurrentFrame (context);
 }
@@ -188,18 +190,18 @@ Flash_start (FlashContext *context)
 	if (context->started)
 	{
 		log_add (log_Warning, "Flash_start() called on already started "
-				 "FlashContext.\n");
+				"FlashContext.\n");
 		return;
 	}
 	
 	Flash_initCache (context);
-	
+
 	context->started = true;
 	context->paused = false;
-	
+
 	Flash_grabOriginal (context);
 	context->lastFrameIndex = 0;
-	
+
 	Flash_fixState (context);
 	Flash_drawCurrentFrame (context);
 }
@@ -211,11 +213,12 @@ Flash_terminate (FlashContext *context)
 	{
 		// Restore the flash rectangle:
 		Flash_drawFrame (context, context->original);
-		
+
 		Flash_clearCache (context);
+		HFree (context->cache);
 		DestroyDrawable (ReleaseDrawable (context->original));
 	}
-	
+
 	HFree (context);
 }
 
@@ -270,51 +273,50 @@ void
 Flash_process (FlashContext *context)
 {
 	TimeCount now;
-	
+
 	if (!context->started || context->paused)
 		return;
 	
 	now = GetTimeCounter ();
-	
-	if (context->state == FlashState_fadeIn)
+
+	switch (context->state)
 	{
-		if (now >= context->lastStateTime + context->fadeInTime)
-		{
+		case FlashState_fadeIn:
+			if (now >= context->lastStateTime + context->fadeInTime)
+			{
+				Flash_nextState (context);
+				context->lastStateTime = now;
+			}
+			context->lastFrameTime = now;
+			break;
+		case FlashState_on:
+			if (now < context->lastStateTime + context->onTime)
+				return;
 			Flash_nextState (context);
 			context->lastStateTime = now;
-		}
-		context->lastFrameTime = now;
-	}
-	else if (context->state == FlashState_on)
-	{
-		if (now < context->lastStateTime + context->onTime)
-			return;
-		Flash_nextState (context);
-		context->lastStateTime = now;
-	}
-	else if (context->state == FlashState_fadeOut)
-	{
-		if (now >= context->lastStateTime + context->fadeOutTime)
-		{
+			break;
+		case FlashState_fadeOut:
+			if (now >= context->lastStateTime + context->fadeOutTime)
+			{
+				Flash_nextState (context);
+				context->lastStateTime = now;
+			}
+			context->lastFrameTime = now;
+			break;
+		case FlashState_off:
+			if (now < context->lastStateTime + context->offTime)
+				return;
 			Flash_nextState (context);
 			context->lastStateTime = now;
-		}
-		context->lastFrameTime = now;
-	}
-	else /* context->state == FlashState_off */
-	{
-		if (now < context->lastStateTime + context->offTime)
-			return;
-		Flash_nextState (context);
-		context->lastStateTime = now;
+			break;
 	}
-	
+
 	Flash_drawCurrentFrame (context);
 }
 
 void
 Flash_setSpeed (FlashContext *context, TimeCount fadeInTime,
-				TimeCount onTime, TimeCount fadeOutTime, TimeCount offTime)
+		TimeCount onTime, TimeCount fadeOutTime, TimeCount offTime)
 {
 	context->fadeInTime = fadeInTime;
 	context->onTime = onTime;
@@ -341,17 +343,17 @@ Flash_setSpeed (FlashContext *context, T
 // These numbers are relative to the brighness of each original image.
 void
 Flash_setMergeFactors(FlashContext *context, int startNumer, int endNumer,
-					  int denom) {
+		int denom) {
 	if (context->started)
 	{
 		Flash_drawFrame (context, context->original);
 		Flash_clearCache (context);
 	}
-	
+
 	context->startNumer = startNumer;
 	context->endNumer = endNumer;
 	context->denom = denom;
-	
+
 	if (context->started)
 	{
 		Flash_grabOriginal (context);
@@ -372,9 +374,9 @@ Flash_nextTime (FlashContext *context)
 {
 	if (!context->started || context->paused)
 		return (TimeCount) -1;
-	
+
 	if (context->state == FlashState_fadeIn ||
-		context->state == FlashState_fadeOut)
+			context->state == FlashState_fadeOut)
 	{
 		// When we're fading in or out, we need updates during
 		// the fade.
@@ -395,10 +397,10 @@ static void
 Flash_clearCache (FlashContext *context)
 {
 	COUNT i;
-	
+
 #ifdef BEGIN_AND_END_FRAME_EXCEPTIONS
 	if (context->type == FlashType_transition ||
-		context->type == FlashType_overlay)
+			context->type == FlashType_overlay)
 	{
 		// First frame is not allocated by the flash code, so
 		// we shouldn't free it.
@@ -426,16 +428,16 @@ void
 Flash_setRect (FlashContext *context, const RECT *rect)
 {
 	assert(context->type == FlashType_highlight);
-	
+
 	if (context->started)
 	{
 		Flash_drawFrame (context, context->original);
 		Flash_clearCache (context);
 	}
-	
+
 	context->rect = *rect;
 	context->lastFrameIndex = (COUNT) -1;
-	
+
 	if (context->started)
 	{
 		Flash_grabOriginal (context);
@@ -447,7 +449,7 @@ void
 Flash_getRect (FlashContext *context, RECT *rect)
 {
 	assert (!context->type == FlashType_highlight);
-	
+
 	*rect = context->rect;
 }
 
@@ -458,7 +460,7 @@ void
 Flash_setOverlay (FlashContext *context, const POINT *origin, FRAME overlay, BOOLEAN cleanup)
 {
 	assert(context->type == FlashType_overlay);
-	
+
 	if (context->started && !cleanup)
 	{
 		Flash_drawFrame (context, context->original);
@@ -467,11 +469,11 @@ Flash_setOverlay (FlashContext *context,
 	
 	if (!cleanup)
 		context->u.overlay.frame = overlay;
-	
+
 	GetFrameRect (overlay, &context->rect);
 	context->rect.corner.x += origin->x;
 	context->rect.corner.y += origin->y;
-	
+
 	if (context->started)
 	{
 		Flash_grabOriginal (context);
@@ -479,7 +481,8 @@ Flash_setOverlay (FlashContext *context,
 	}
 }
 
-// Call before you update the graphics in the currently flashing area.
+// Call before you update the graphics in the currently flashing area,
+// or before you change the dimensions or origin of the graphics context.
 void
 Flash_preUpdate (FlashContext *context)
 {
@@ -490,7 +493,8 @@ Flash_preUpdate (FlashContext *context)
 	}
 }
 
-// Call after you update the graphics in the currently flashing area.
+// Call after you update the graphics in the currently flashing area,
+// or after you change the dimensions or origin of the graphics context.
 void
 Flash_postUpdate (FlashContext *context)
 {
@@ -506,7 +510,7 @@ static void
 Flash_initCache (FlashContext *context)
 {
 	COUNT i;
-	
+
 	context->cache = HMalloc (context->cacheSize * sizeof (FRAME));
 	for (i = 0; i < context->cacheSize; i++)
 		context->cache[i] = (FRAME) 0;
@@ -516,16 +520,16 @@ void
 Flash_setCacheSize (FlashContext *context, COUNT size)
 {
 	assert (size == 0 || size >= 2);
-	
+
 	if (context->cache != NULL)
 	{
 		Flash_clearCache (context);
 		HFree (context->cache);
 		context->cache = NULL;
 	}
-	
+
 	context->cacheSize = size;
-	
+
 	if (size != 0)
 		Flash_initCache (context);
 }
@@ -540,24 +544,22 @@ static void
 Flash_grabOriginal (FlashContext *context)
 {
 	CONTEXT oldGfxContext;
-	
+
 	if (context->original != (FRAME) 0)
 		DestroyDrawable (ReleaseDrawable (context->original));
-	
-	LockMutex (GraphicsLock);
+
 	oldGfxContext = SetContext (context->gfxContext);
 	context->original = CaptureDrawable (CopyContextRect (&context->rect));
 	SetContext (oldGfxContext);
 	FlushGraphics ();
-	// CopyContextRect() may have queued the command to read
-	// a rectangle from the screen; a FlushGraphics()
-	// is necessary to ensure that it can actually be used.
-	UnlockMutex (GraphicsLock);
+			// CopyContextRect() may have queued the command to read
+			// a rectangle from the screen; a FlushGraphics()
+			// is necessary to ensure that it can actually be used.
 }
 
 static inline void
 Flash_blendFraction (FlashContext *context, int numer, int denom,
-					 int *resNumer, int *resDenom)
+		int *resNumer, int *resDenom)
 {
 	// This function merges two fractions (F0 and F1),
 	// based on another fraction (P) (yielding R).
@@ -569,9 +571,9 @@ Flash_blendFraction (FlashContext *conte
 	//     (denom - numer) * startNumer / denom * context->denom
 	
 	assert (numer >= 0 && numer <= denom);
-	
+
 	*resNumer = numer * context->endNumer +
-	(denom - numer) * context->startNumer;
+			(denom - numer) * context->startNumer;
 	*resDenom = denom * context->denom;
 }
 
@@ -582,16 +584,15 @@ Flash_makeFrame (FlashContext *context,
 	STAMP s;
 	int blendedNumer;
 	int blendedDenom;
-	
+
 	s.origin.x = 0;
 	s.origin.y = 0;
-	
+
 	Flash_blendFraction (context, numer, denom, &blendedNumer, &blendedDenom);
-	
-	LockMutex (GraphicsLock);
+
 	oldGfxContext = SetContext (workGfxContext);
 	SetContextFGFrame (dest);
-	
+
 	switch (context->type) {
 		case FlashType_highlight:
 		{
@@ -600,7 +601,7 @@ Flash_makeFrame (FlashContext *context,
 			ClearDrawable ();
 			// Draw the frame at modulated strength (0 < strength <= 128)
 			SetContextDrawMode (MAKE_DRAW_MODE (DRAW_ADDITIVE,
-												DRAW_FACTOR_1 * blendedNumer / blendedDenom));
+					DRAW_FACTOR_1 * blendedNumer / blendedDenom));
 			s.frame = context->original;
 			DrawStamp (&s);
 			break;
@@ -609,21 +610,21 @@ Flash_makeFrame (FlashContext *context,
 		{
 			FRAME first;
 			FRAME final;
-			
+
 			first = context->u.transition.first;
 			if (first == (FRAME) 0)
 				first = context->original;
 			final = context->u.transition.final;
 			if (final == (FRAME) 0)
 				final = context->original;
-			
+
 			// Draw the first frame at full strength
 			SetContextDrawMode (DRAW_REPLACE_MODE);
 			s.frame = first;
 			DrawStamp (&s);
 			// Merge in the final frame
 			SetContextDrawMode (MAKE_DRAW_MODE (DRAW_ALPHA,
-												DRAW_FACTOR_1 * blendedNumer / blendedDenom));
+					DRAW_FACTOR_1 * blendedNumer / blendedDenom));
 			s.frame = final;
 			DrawStamp (&s);
 			break;
@@ -631,14 +632,14 @@ Flash_makeFrame (FlashContext *context,
 		case FlashType_overlay:
 		{
 			POINT oldOrigin;
-			
+
 			// Draw the original at full strength
 			SetContextDrawMode (DRAW_REPLACE_MODE);
 			s.frame = context->original;
 			DrawStamp (&s);
 			// Add or subtract the overlay at partial strength
 			SetContextDrawMode (MAKE_DRAW_MODE (DRAW_ADDITIVE,
-												DRAW_FACTOR_1 * blendedNumer / blendedDenom));
+					DRAW_FACTOR_1 * blendedNumer / blendedDenom));
 			s.frame = context->u.overlay.frame;
 			// Offset the draw origin to hit the right area
 			oldOrigin = SetContextOrigin (GetFrameHot (s.frame));
@@ -647,9 +648,8 @@ Flash_makeFrame (FlashContext *context,
 			break;
 		}
 	}
-	
+
 	SetContext (oldGfxContext);
-	UnlockMutex (GraphicsLock);
 }
 
 // Prepare an entry in the cache.
@@ -658,24 +658,24 @@ Flash_prepareCacheFrame (FlashContext *c
 {
 	if (context->cache[index] != (FRAME) 0)
 		return;
-	
+
 #ifdef BEGIN_AND_END_FRAME_EXCEPTIONS
 	if (index == 0 && context->type == FlashType_overlay)
 		context->cache[index] = context->original;
 	else if (index == 0 && context->type == FlashType_transition)
 		context->cache[index] = context->u.transition.first != (FRAME) 0 ?
-		context->u.transition.first : context->original;
+				context->u.transition.first : context->original;
 	else if (index == context->cacheSize - 1 &&
-			 context->type == FlashType_transition)
+			context->type == FlashType_transition)
 		context->cache[index] = context->u.transition.final != (FRAME) 0 ?
-		context->u.transition.final : context->original;
+				context->u.transition.final : context->original;
 	else
 #endif  /* BEGIN_AND_END_FRMAE_EXCEPTIONS */
 	{
 		context->cache[index] = CaptureDrawable (CreateDrawable (WANT_PIXMAP,
-																 context->rect.extent.width, context->rect.extent.height, 1));
+				context->rect.extent.width, context->rect.extent.height, 1));
 		Flash_makeFrame (context, context->cache[index],
-						 index, context->cacheSize - 1);
+				index, context->cacheSize - 1);
 	}
 }
 
@@ -684,26 +684,24 @@ Flash_drawFrame (FlashContext *context,
 {
 	CONTEXT oldGfxContext;
 	STAMP stamp;
-	
-	LockMutex (GraphicsLock);
+
 	oldGfxContext = SetContext (context->gfxContext);
-	
+
 	stamp.origin = context->rect.corner;
 	stamp.frame = frame;
 	DrawStamp(&stamp);
-	
+
 	SetContext (oldGfxContext);
-	UnlockMutex (GraphicsLock);
 }
 
 static void
 Flash_drawCacheFrame (FlashContext *context, COUNT index)
 {
 	FRAME frame;
-	
+
 	if (context->lastFrameIndex == index)
 		return;
-	
+
 	frame = context->cache[index];
 	Flash_drawFrame (context, frame);
 	context->lastFrameIndex = index;
@@ -715,12 +713,12 @@ Flash_drawUncachedFrame (FlashContext *c
 #ifdef BEGIN_AND_END_FRAME_EXCEPTIONS
 	// 'lastFrameIndex' is 0 for the first image, 1 for the final
 	// image, and 2 otherwise.
-	
+
 	if (numer == 0 && context->type == FlashType_overlay)
 	{
 		if (context->lastFrameIndex != 0)
 			return;
-		
+
 		Flash_drawFrame (context, context->original);
 		context->lastFrameIndex = 0;
 		return;
@@ -729,7 +727,7 @@ Flash_drawUncachedFrame (FlashContext *c
 	{
 		if (context->lastFrameIndex == 0)
 			return;
-		
+
 		Flash_drawFrame (context, context->u.transition.first);
 		context->lastFrameIndex = 0;
 		return;
@@ -738,24 +736,24 @@ Flash_drawUncachedFrame (FlashContext *c
 	{
 		if (context->lastFrameIndex == 1)
 			return;
-		
+
 		Flash_drawFrame (context, context->u.transition.final);
 		context->lastFrameIndex = 1;
 		return;
 	}
-	
+
 	context->lastFrameIndex = 2;
 #endif  /* BEGIN_AND_END_FRMAE_EXCEPTIONS */
-	
+
 	{
 		// Painting to the screen; we need a temporary frame to draw to.
 		FRAME work;
-		
+
 		work = CaptureDrawable (CreateDrawable (WANT_PIXMAP,
-												context->rect.extent.width, context->rect.extent.height, 1));
+				context->rect.extent.width, context->rect.extent.height, 1));
 		Flash_makeFrame (context, work, numer, denom);
 		Flash_drawFrame (context, work);
-		
+
 		DestroyDrawable (ReleaseDrawable (work));
 	}
 }
@@ -764,7 +762,7 @@ static inline void
 Flash_drawCachedFrame (FlashContext *context, int numer, int denom)
 {
 	COUNT cachePos;
-	
+
 	cachePos = ((context->cacheSize - 1) * numer + (denom / 2)) / denom;
 	Flash_prepareCacheFrame (context, cachePos);
 	Flash_drawCacheFrame (context, cachePos);
@@ -775,7 +773,7 @@ Flash_drawCurrentFrame (FlashContext *co
 {
 	int numer;
 	int denom;
-	
+
 	if (context->state == FlashState_off)
 	{
 		numer = 0;
@@ -789,21 +787,21 @@ Flash_drawCurrentFrame (FlashContext *co
 	else
 	{
 		TimeCount now = GetTimeCounter ();
-		
+
 		if (context->state == FlashState_fadeIn)
 			denom = (int) context->fadeInTime;
 		else
 			denom = (int) context->fadeOutTime;
-		
+
 		numer = (int) (now - context->lastStateTime);
-		
+
 		if (numer > denom)
 			numer = denom;
-		
+
 		if (context->state == FlashState_fadeOut)
 			numer = (int) context->fadeOutTime - numer;
 	}
-	
+
 	if (context->cacheSize == 0)
 		Flash_drawUncachedFrame (context, numer, denom);
 	else
diff -ruNp src.hd/uqm/flash.h src/uqm/flash.h
--- src.hd/uqm/flash.h	2017-12-29 02:25:52 -0800
+++ src/uqm/flash.h	2017-12-29 00:57:45 -0800
@@ -14,8 +14,6 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #ifndef _FLASH_H
 #define _FLASH_H
 
@@ -33,18 +31,17 @@
  *
  * // We create the flash context; it is used to manipulate the flash
  * // rectangle while it exists.
- * FlashContext *fc = Flash_createHighlight (context, (FRAME) 0, rect);
+ * FlashContext *fc = Flash_createHighlight (gfxContext, rect);
  * 
  * // Specify how bright the flash is at the beginning and ending of the
  * // sequence.
- * Flash_setMergeFactors(context, 2, 3, 2);
+ * Flash_setMergeFactors(fc, 2, 3, 2);
  *
  * // We change the flashing speed from the defaults.
- * Flash_setSpeed (ONE_SECOND, ONE_SECOND, ONE_SECOND, ONE_SECOND);
+ * Flash_setSpeed (fc, ONE_SECOND, ONE_SECOND, ONE_SECOND, ONE_SECOND);
  * 
  * // During cross-fades, update 8 times per second.
- * Flash_setFrameTime (gmstate.player[playerI].flashContext,
- *         ONE_SECOND / 8);
+ * Flash_setFrameTime (fc, ONE_SECOND / 8);
  *
  * // We start the flashing. The default is to start from the "off" state.
  * Flash_start (fc);
@@ -65,7 +62,7 @@
  * ...
  * // Modifying the graphics of the area that is flashing:
  * void Flash_preUpdate (fc);
- * ... // do Drawing
+ * ... // do drawing
  * void Flash_postUpdate (fc);
  * ...
  * // We're done. Terminating the flash restores the flash area to its
@@ -80,18 +77,24 @@
  *
  * Limitations:
  *
- * 2) Functions that draw to the gfxContext or read the original gfxContext
- * contents, which is most of them, must be called with gfxContext having
- * the same clip-rect as it did when other drawing functions were called.
- * Otherwise, original contents restoration may draw to the wrong area, or
- * the wrong area may be read.
- * There may be cases where one would *want* that to happen, and such
- * cases are not covered by this limitation.
+ * * Functions that draw to the gfxContext or read the original gfxContext
+ *   contents, which is most of them, must be called with gfxContext having
+ *   the same clip-rect as it did when other drawing functions were called.
+ *   Otherwise, original contents restoration may draw to the wrong area, or
+ *   the wrong area may be read.
+ *   There may be cases where one would *want* that to happen, and such
+ *   cases are not covered by this limitation.
+ * * Multiple flashes may be used simultaneously, but don't let them
+ *   overlap; artifacts would occur.
  */
 
 #include "libs/gfxlib.h"
 #include "libs/timelib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef enum {
 	FlashState_fadeIn = 0,
 			// Someway between on and off, going towards on.
@@ -161,8 +164,8 @@ struct FlashContext {
 	TimeCount lastFrameTime;
 			// Time of the last frame draw.
 
-	BOOLEAN started : 1;
-	BOOLEAN paused : 1;
+	BOOLEAN started;
+	BOOLEAN paused;
 
 	FRAME *cache;
 	COUNT cacheSize;
@@ -213,5 +216,9 @@ void Flash_setCacheSize (FlashContext *c
 COUNT Flash_getCacheSize (const FlashContext *context);
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _FLASH_H */
 
diff -ruNp src.hd/uqm/fmv.c src/uqm/fmv.c
--- src.hd/uqm/fmv.c	2017-12-29 02:25:52 -0800
+++ src/uqm/fmv.c	2017-12-29 00:57:45 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "fmv.h"
 
 #include "controls.h"
@@ -35,7 +33,6 @@
 void
 DoShipSpin (COUNT index, MUSIC_REF hMusic)
 {
-#ifdef WANT_SHIP_SPINS
 	char vnbuf[24]; // From 32 to 24
 	RECT old_r;
 
@@ -49,7 +46,6 @@ DoShipSpin (COUNT index, MUSIC_REF hMusi
 	if (hMusic){
 		StopMusic ();
 	}
-
 	FreeHyperData ();
 
 	// TODO: It would be nice to have better resource names for these.
@@ -64,15 +60,11 @@ DoShipSpin (COUNT index, MUSIC_REF hMusi
 	DrawFromExtraScreen (NULL);
 	SetContextClipRect (&old_r);
 
-	if (hMusic)
+	if (hMusic){
 		PlayMusic (hMusic, TRUE, 1);
-		
+	}
 	SleepThreadUntil (FadeScreen (FadeAllToColor, ONE_SECOND / 4));
 	FlushColorXForms ();
-#else
-	(void) index;  /* Satisfy compiler */
-	(void) hMusic;  /* Satisfy compiler */
-#endif  /* WANT_SHIP_SPINS */
 }
 
 void
@@ -82,35 +74,23 @@ SplashScreen (void (* DoProcessing)(DWOR
 	DWORD TimeOut;
 
 	SleepThreadUntil (FadeScreen (FadeAllToBlack, ONE_SECOND / 120));
-	LockMutex (GraphicsLock);
 	SetContext (ScreenContext);
 	s.origin.x = s.origin.y = 0;
 
-	//s.frame = CaptureDrawable (LoadGraphic (TITLE_ANIM));
-	
 	//DC: Title Splashscreen.
-	if (resolutionFactor < 1)
-	{
+	if (resolutionFactor < 1) {
 		printf("Loading 1x Splashscreen\n");
 		s.frame = CaptureDrawable (LoadGraphic (TITLE_ANIM));
-	}
-
-	else if (resolutionFactor == 1)
-	{
+	} else if (resolutionFactor == 1) {
 		printf("Loading 2x Splashscreen\n");
 		s.frame = CaptureDrawable (LoadGraphic (TITLE_2X));
-	}
-
-	else if(resolutionFactor > 1)
-	{
+	} else if(resolutionFactor > 1) {
 		printf("Loading 4x Splashscreen\n");
 		s.frame = CaptureDrawable (LoadGraphic (TITLE_4X));
 	}
-	// DC: End of spashscreen resolutions.
-	
+
 	DrawStamp (&s);
 	DestroyDrawable (ReleaseDrawable (s.frame));
-	UnlockMutex (GraphicsLock);
 
 	TimeOut = FadeScreen (FadeAllToColor, ONE_SECOND / 2);
 
@@ -156,15 +136,17 @@ Victory (void)
 		
 	FadeScreen (FadeAllToBlack, 0);
 }
-
+ 
 void
-Logo (void) {
+Logo (void)
+{
 	ShowPresentation (LOGOPRES_STRTAB);
 	SleepThreadUntil (FadeScreen (FadeAllToBlack, ONE_SECOND / 2));
 }
 
 void
-Drumall (void) {
+Drumall (void)
+{
 	ShowPresentation (DRUMALLPRES_STRTAB);
 	SleepThreadUntil (FadeScreen (FadeAllToBlack, ONE_SECOND / 2));
 }
diff -ruNp src.hd/uqm/fmv.h src/uqm/fmv.h
--- src.hd/uqm/fmv.h	2017-12-29 02:25:52 -0800
+++ src/uqm/fmv.h	2017-12-29 00:57:45 -0800
@@ -20,7 +20,10 @@
 #include "libs/compiler.h"
 #include "libs/sndlib.h"
 #include "libs/gfxlib.h"
-#define WANT_SHIP_SPINS
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
 extern void SplashScreen (void (* DoProcessing)(DWORD TimeOut));
 extern void Introduction (void);
@@ -31,5 +34,9 @@ extern void Drumall (void);
 
 extern BOOLEAN ShowPresentation (RESOURCE presentation);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _FMV_H */
 
diff -ruNp src.hd/uqm/galaxy.c src/uqm/galaxy.c
--- src.hd/uqm/galaxy.c	2017-12-29 02:25:52 -0800
+++ src/uqm/galaxy.c	2017-12-29 00:57:45 -0800
@@ -18,8 +18,6 @@
 
 /* background starfield - used to generate agalaxy.asm */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "element.h"
 #include "globdata.h"
 #include "init.h"
@@ -43,7 +41,6 @@ extern PRIM_LINKS DisplayLinks;
 			+ MED_STAR_COUNT \
 			+ SML_STAR_COUNT)
 
-// JMS: Changed from POINT to DPOINT
 DPOINT SpaceOrg;
 static DPOINT log_star_array[NUM_STARS];
 
@@ -53,9 +50,9 @@ typedef struct
 {
 	COUNT min_star_index;
 	COUNT num_stars;
-	DPOINT *star_array; // JMS: Changed from POINT to DPOINT
-	DPOINT *pmin_star;  // JMS: Changed from POINT to DPOINT
-	DPOINT *plast_star; // JMS: Changed from POINT to DPOINT
+	DPOINT *star_array;
+	DPOINT *pmin_star;
+	DPOINT *plast_star;
 } STAR_BLOCK;
 
 STAR_BLOCK StarBlock[NUM_STAR_PLANES] =
@@ -90,7 +87,7 @@ SortStarBlock (STAR_BLOCK *pStarBlock)
 		{
 			if (pStarBlock->star_array[i].y > pStarBlock->star_array[j].y)
 			{
-				DPOINT temp; // JMS: Changed from POINT to DPOINT
+				DPOINT temp;
 
 				temp = pStarBlock->star_array[i];
 				pStarBlock->star_array[i] = pStarBlock->star_array[j];
@@ -105,13 +102,12 @@ SortStarBlock (STAR_BLOCK *pStarBlock)
 			&pStarBlock->star_array[pStarBlock->num_stars - 1];
 }
 
-// JMS: Changed dx, dy from SIZE to SDWORD
 static void
 WrapStarBlock (SIZE plane, SDWORD dx, SDWORD dy)
 {
 	COUNT i;
-	DPOINT *ppt; // JMS: Changed from POINT to DPOINT
-	SDWORD offs_y; // JMS: Changed from SIZE to SDWORD
+	DPOINT *ppt;
+	SDWORD offs_y;
 	COUNT num_stars;
 	STAR_BLOCK *pStarBlock;
 
@@ -241,8 +237,9 @@ void
 InitGalaxy (void)
 {
 	COUNT i, factor;
-	DPOINT *ppt; // JMS: Changed POINT to DPOINT
+	DPOINT *ppt;
 	PRIM_LINKS Links;
+	BOOLEAN HSorQS = (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1 ? FALSE : TRUE);
 
 	log_add (log_Debug, "InitGalaxy(): transition_width = %d, "
 			"transition_height = %d",
@@ -258,8 +255,7 @@ InitGalaxy (void)
 
 		if (i == BIG_STAR_COUNT || i == BIG_STAR_COUNT + MED_STAR_COUNT)
 			++factor;
-		
-		// JMS Changed COORDS to SDWORDS
+
 		ppt->x = (SDWORD)((UWORD)TFB_Random () % SPACE_WIDTH) << factor;
 		ppt->y = (SDWORD)((UWORD)TFB_Random () % SPACE_HEIGHT) << factor;
 
@@ -268,7 +264,6 @@ InitGalaxy (void)
 			SetPrimType (&DisplayArray[p], STAMP_PRIM);
 			SetPrimColor (&DisplayArray[p],
 					BUILD_COLOR (MAKE_RGB15 (0x0B, 0x0B, 0x1F), 0x09));
-			
 			// JMS_GFX: This was originally only "DisplayArray[p].Object.Stamp.frame = stars_in_space;"
 			if (RESOLUTION_FACTOR == 0 || (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1))
 				DisplayArray[p].Object.Stamp.frame = stars_in_space;
@@ -277,16 +272,24 @@ InitGalaxy (void)
 		}
 		else
 		{
-			SetPrimType (&DisplayArray[p], POINT_PRIM);
-			if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
-				SetPrimColor (&DisplayArray[p],
-						BUILD_COLOR (MAKE_RGB15 (0x15, 0x15, 0x15), 0x07));
-			else if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
-				SetPrimColor (&DisplayArray[p],
-						BUILD_COLOR (MAKE_RGB15 (0x14, 0x00, 0x00), 0x8C));
-			else
-				SetPrimColor (&DisplayArray[p],
-						BUILD_COLOR (MAKE_RGB15 (0x00, 0x0E, 0x00), 0x8C));
+			if(RESOLUTION_FACTOR > 0){
+				// In HD the starpoints in HS and QS are images
+				SetPrimType (&DisplayArray[p], STAMP_PRIM);
+				if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE){
+					SetPrimType (&DisplayArray[p], POINT_PRIM);
+					SetPrimColor (&DisplayArray[p], BUILD_COLOR (MAKE_RGB15 (0x15, 0x15, 0x15), 0x07));
+				} else
+					DisplayArray[p].Object.Stamp.frame = SetAbsFrameIndex (StarPoints, HSorQS);
+			} else {
+				// Pixel starpoints in original res
+				SetPrimType (&DisplayArray[p], POINT_PRIM);
+				if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
+					SetPrimColor (&DisplayArray[p], BUILD_COLOR (MAKE_RGB15 (0x15, 0x15, 0x15), 0x07));
+				else if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
+					SetPrimColor (&DisplayArray[p], BUILD_COLOR (MAKE_RGB15 (0x14, 0x00, 0x00), 0x8C));
+				else
+					SetPrimColor (&DisplayArray[p], BUILD_COLOR (MAKE_RGB15 (0x00, 0x0E, 0x00), 0x8C));
+			}
 		}
 
 		InsertPrim (&Links, p, GetPredLink (Links));
@@ -297,9 +300,9 @@ InitGalaxy (void)
 	SortStarBlock (&StarBlock[2]);
 }
 
-// JMS: Changed POINT *pt2 to DPOINT *pt2 and dx, dy from SIZE to SDWORD
 static BOOLEAN
-CmpMovePoints (const POINT *pt1, const DPOINT *pt2, SDWORD dx, SDWORD dy, SIZE reduction)
+CmpMovePoints (const POINT *pt1, const DPOINT *pt2, SDWORD dx, SDWORD dy,
+			   SIZE reduction)
 {
 	if (optMeleeScale == TFB_SCALE_STEP)
 	{
@@ -313,7 +316,6 @@ CmpMovePoints (const POINT *pt1, const D
 	}
 }
 
-// JMS: Changed dx, dy from SIZE to SDWORD
 void
 MoveGalaxy (VIEW_STATE view_state, SDWORD dx, SDWORD dy)
 {
@@ -328,15 +330,13 @@ MoveGalaxy (VIEW_STATE view_state, SDWOR
 
 	if (view_state != VIEW_STABLE)
 	{
-		COUNT reduction;
-		COUNT i;
-		COUNT iss;
+		COUNT reduction, i, iss;
 		DPOINT *ppt;
 		FRAME tempframe;
 		int wrap_around;
 
 		reduction = zoom_out;
-		
+
 		// JMS_GFX
 		if (RESOLUTION_FACTOR == 0 || (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1))
 			tempframe = stars_in_space;
@@ -345,13 +345,12 @@ MoveGalaxy (VIEW_STATE view_state, SDWOR
 
 		if (view_state == VIEW_CHANGE)
 		{
-			if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+			if (inHQSpace ())
 			{
 				for (iss = 0, pprim = DisplayArray; iss < 2; ++iss)
 				{
 					for (i = star_counts[iss]; i > 0; --i, ++pprim)
 					{
-						// JMS_GFX: Replaced stars_in_space with tempframe.
 						pprim->Object.Stamp.frame =	SetAbsFrameIndex (
 								tempframe,
 									(COUNT)(TFB_Random () & 31)
@@ -382,7 +381,6 @@ MoveGalaxy (VIEW_STATE view_state, SDWOR
 				}
 				else
 				{	/* on 3DO, the closest stars are pixels when zoomed out */
-					/* In 320x240 mode. */
 					star_object[1] = POINT_PRIM;
 					if (reduction > (1 << ZOOM_SHIFT))
 					{
@@ -450,7 +448,7 @@ MoveGalaxy (VIEW_STATE view_state, SDWOR
 			}
 		}
 
-		if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+		if (inHQSpace ())
 		{
 			for (i = BIG_STAR_COUNT + MED_STAR_COUNT, pprim = DisplayArray;
 					i > 0; --i, ++pprim)
@@ -471,7 +469,7 @@ MoveGalaxy (VIEW_STATE view_state, SDWOR
 		WrapStarBlock (1, dx, dy);
 		WrapStarBlock (0, dx, dy);
 
-		if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
+		if (!inHQSpace ())
 		{
 			dx = SpaceOrg.x;
 			dy = SpaceOrg.y;
@@ -482,7 +480,6 @@ MoveGalaxy (VIEW_STATE view_state, SDWOR
 		}
 		else
 		{
-			// JMS: Changed COORDs to SDWORDs
 			dx = (SDWORD)(LOG_SPACE_WIDTH >> 1)
 					- (LOG_SPACE_WIDTH >> ((MAX_REDUCTION + 1)
 					- MAX_VIS_REDUCTION));
diff -ruNp src.hd/uqm/gameev.c src/uqm/gameev.c
--- src.hd/uqm/gameev.c	2017-12-29 02:25:52 -0800
+++ src/uqm/gameev.c	2017-12-29 00:57:45 -0800
@@ -16,33 +16,126 @@
  */
 
 #include "gameev.h"
-#include "options.h" // JMS: For cheat mode.
-#include "setup.h"
+
 #include "build.h"
 #include "clock.h"
-// XXX: for CurStarDescPtr and XXX_DEFINED constants
-#include "encount.h"
+#include "starmap.h"
+#include "gendef.h"
 #include "globdata.h"
 #include "hyper.h"
+#include "resinst.h"
+#include "lua/luaevent.h"
+#include "lua/luafuncs/customfuncs.h"
 #include "libs/compiler.h"
+#include "libs/log.h"
 #include "libs/mathlib.h"
+#include "options.h"
+#include <stdlib.h>
+#include "setup.h"
 
-
-static void arilou_entrance_event (void);
-static void arilou_exit_event (void);
+static int arilou_entrance_event (int arg);
+static int arilou_exit_event (int arg);
 static void check_race_growth (void);
-static void black_urquan_genocide (void);
-static void pkunk_mission (void);
-static void thradd_mission (void);
-static void ilwrath_mission (void);
-static void utwig_supox_mission (void);
-static void mycon_mission (void);
+static int hyperspace_encounter_event (int arg);
+static int kohr_ah_victorious_event (int arg);
+static int advance_pkunk_mission (int arg);
+static int advance_thradd_mission (int arg);
+static int zoqfot_distress_event (int arg);
+static int zoqfot_death_event (int arg);
+static int shofixti_return_event (int arg);
+static int advance_utwig_supox_mission (int arg);
+static int kohr_ah_genocide_event (int arg);
+static int spathi_shield_event (int arg);
+static int advance_ilwrath_mission (int arg);
+static int advance_mycon_mission (int arg);
+static int arilou_umgah_check (int arg);
+static int yehat_rebel_event (int arg);
+static int slylandro_ramp_up (int arg);
+static int slylandro_ramp_down (int arg);
+
+static const char *eventNames[] = {
+	"ARILOU_ENTRANCE_EVENT",
+	"ARILOU_EXIT_EVENT",
+	"HYPERSPACE_ENCOUNTER_EVENT",
+	"KOHR_AH_VICTORIOUS_EVENT",
+	"ADVANCE_PKUNK_MISSION",
+	"ADVANCE_THRADD_MISSION",
+	"ZOQFOT_DISTRESS_EVENT",
+	"ZOQFOT_DEATH_EVENT",
+	"SHOFIXTI_RETURN_EVENT",
+	"ADVANCE_UTWIG_SUPOX_MISSION",
+	"KOHR_AH_GENOCIDE_EVENT",
+	"SPATHI_SHIELD_EVENT",
+	"ADVANCE_ILWRATH_MISSION",
+	"ADVANCE_MYCON_MISSION",
+	"ARILOU_UMGAH_CHECK",
+	"YEHAT_REBEL_EVENT",
+	"SLYLANDRO_RAMP_UP",
+	"SLYLANDRO_RAMP_DOWN"
+};
 
+void
+initEventSystem (void) {
+	// Register functions which can be called from Lua through
+	// 'custom.<functionName>'. Right now, these are the event functions
+	// which have not been converted to Lua yet.
+	static const luaUqm_custom_Function eventFuncs[] = {
+		{ "arilou_entrance_event",       arilou_entrance_event },
+		{ "arilou_exit_event",           arilou_exit_event },
+		{ "hyperspace_encounter_event",  hyperspace_encounter_event },
+		{ "kohr_ah_victorious_event",    kohr_ah_victorious_event },
+		{ "advance_pkunk_mission",       advance_pkunk_mission },
+		{ "advance_thradd_mission",      advance_thradd_mission },
+		{ "zoqfot_distress_event",       zoqfot_distress_event },
+		{ "zoqfot_death_event",          zoqfot_death_event },
+		{ "shofixti_return_event",       shofixti_return_event },
+		{ "advance_utwig_supox_mission", advance_utwig_supox_mission },
+		{ "kohr_ah_genocide_event",      kohr_ah_genocide_event },
+		{ "spathi_shield_event",         spathi_shield_event },
+		{ "advance_ilwrath_mission",     advance_ilwrath_mission },
+		{ "advance_mycon_mission",       advance_mycon_mission },
+		{ "arilou_umgah_check",          arilou_umgah_check },
+		{ "yehat_rebel_event",           yehat_rebel_event },
+		{ "slylandro_ramp_up",           slylandro_ramp_up },
+		{ "slylandro_ramp_down",         slylandro_ramp_down },
+		{ NULL, NULL }
+	};
+
+	luaUqm_event_init (eventFuncs, EVENT_SCRIPT);
+}
 
 void
-AddInitialGameEvents (void) {
-	COUNT kohrah_winning_years = optCheatMode ? YEARS_TO_KOHRAH_VICTORY + 25 : YEARS_TO_KOHRAH_VICTORY;
+uninitEventSystem (void) {
+	luaUqm_event_uninit ();
+}
+
+int
+eventIdStrToNum (const char *eventIdStr)
+{
+	size_t eventCount = sizeof eventNames / sizeof eventNames[0];
+	size_t eventI;
+
+	// Linear search; acceptable for such a small number of events.
+	for (eventI = 0; eventI < eventCount; eventI++)
+	{
+		if (strcmp (eventIdStr, eventNames[eventI]) == 0)
+			return eventI;
+	}
+	return -1;
+}
 
+const char *
+eventIdNumToStr (int eventNum)
+{
+	size_t eventCount = sizeof eventNames / sizeof eventNames[0];
+	if (eventNum < 0 || (size_t) eventNum >= eventCount)
+		return NULL;
+	return eventNames[eventNum];
+}
+
+void
+AddInitialGameEvents (void) {	
+	COUNT kohrah_winning_years = optCheatMode ? YEARS_TO_KOHRAH_VICTORY + 25 : YEARS_TO_KOHRAH_VICTORY;
 	AddEvent (RELATIVE_EVENT, 0, 1, 0, HYPERSPACE_ENCOUNTER_EVENT);
 	AddEvent (ABSOLUTE_EVENT, 3, 17, START_YEAR, ARILOU_ENTRANCE_EVENT);
 	AddEvent (RELATIVE_EVENT, 0, 0, kohrah_winning_years,
@@ -53,170 +146,21 @@ AddInitialGameEvents (void) {
 void
 EventHandler (BYTE selector)
 {
-	switch (selector)
-	{
-		case ARILOU_ENTRANCE_EVENT:
-			arilou_entrance_event ();
-			break;
-		case ARILOU_EXIT_EVENT:
-			arilou_exit_event ();
-			break;
-		case HYPERSPACE_ENCOUNTER_EVENT:
-			check_race_growth ();
-			if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE
-					&& GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
-				check_hyperspace_encounter ();
-
-			AddEvent (RELATIVE_EVENT, 0, 1, 0, HYPERSPACE_ENCOUNTER_EVENT);
-			break;
-		case KOHR_AH_VICTORIOUS_EVENT:
-			if (GET_GAME_STATE (UTWIG_SUPOX_MISSION))
-			{
-				AddEvent (RELATIVE_EVENT, 0, 0, 1, KOHR_AH_GENOCIDE_EVENT);
-				break;
-			}
-			/* FALLTHROUGH */
-		case KOHR_AH_GENOCIDE_EVENT:
-			if (!GET_GAME_STATE (KOHR_AH_FRENZY)
-					&& LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
-			                && CurStarDescPtr
-					&& CurStarDescPtr->Index == SAMATRA_DEFINED)
-				AddEvent (RELATIVE_EVENT, 0, 7, 0, KOHR_AH_GENOCIDE_EVENT);
-			else
-				black_urquan_genocide ();
-			break;
-		case ADVANCE_PKUNK_MISSION:
-			pkunk_mission ();
-			break;
-		case ADVANCE_THRADD_MISSION:
-			thradd_mission ();
-			break;
-		case ZOQFOT_DISTRESS_EVENT:
-			if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
-			                && CurStarDescPtr
-					&& CurStarDescPtr->Index == ZOQFOT_DEFINED)
-				AddEvent (RELATIVE_EVENT, 0, 7, 0, ZOQFOT_DISTRESS_EVENT);
-			else
-			{
-				SET_GAME_STATE (ZOQFOT_DISTRESS, 1);
-				AddEvent (RELATIVE_EVENT, 6, 0, 0, ZOQFOT_DEATH_EVENT);
-			}
-			break;
-		case ZOQFOT_DEATH_EVENT:
-			if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
-			                && CurStarDescPtr
-					&& CurStarDescPtr->Index == ZOQFOT_DEFINED)
-				AddEvent (RELATIVE_EVENT, 0, 7, 0, ZOQFOT_DEATH_EVENT);
-			else if (GET_GAME_STATE (ZOQFOT_DISTRESS))
-			{
-				HFLEETINFO hZoqFot;
-				FLEET_INFO *ZoqFotPtr;
-
-				hZoqFot = GetStarShipFromIndex (&GLOBAL (avail_race_q),
-						ZOQFOTPIK_SHIP);
-				ZoqFotPtr = LockFleetInfo (&GLOBAL (avail_race_q), hZoqFot);
-				ZoqFotPtr->actual_strength = 0;
-				ZoqFotPtr->allied_state = DEAD_GUY;
-				UnlockFleetInfo (&GLOBAL (avail_race_q), hZoqFot);
-
-				SET_GAME_STATE (ZOQFOT_DISTRESS, 2);
-			}
-			break;
-		case SHOFIXTI_RETURN_EVENT:
-			ActivateStarShip (SHOFIXTI_SHIP, SET_ALLIED);
-			GLOBAL (CrewCost) -= 2;
-					/* crew is not an issue anymore */
-			SET_GAME_STATE (CREW_PURCHASED0, 0);
-			SET_GAME_STATE (CREW_PURCHASED1, 0);
-			break;
-		case ADVANCE_UTWIG_SUPOX_MISSION:
-			utwig_supox_mission ();
-			break;
-		case SPATHI_SHIELD_EVENT:
-			if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
-			                && CurStarDescPtr
-					&& CurStarDescPtr->Index == SPATHI_DEFINED)
-				AddEvent (RELATIVE_EVENT, 0, 7, 0, SPATHI_SHIELD_EVENT);
-			else
-			{
-				HFLEETINFO hSpathi;
-				FLEET_INFO *SpathiPtr;
-
-				hSpathi = GetStarShipFromIndex (&GLOBAL (avail_race_q),
-						SPATHI_SHIP);
-				SpathiPtr = LockFleetInfo (&GLOBAL (avail_race_q), hSpathi);
+	const char *eventIdStr;
 
-				if (SpathiPtr->actual_strength)
-				{
-					ActivateStarShip (SPATHI_SHIP, SET_NOT_ALLIED);
-					ActivateStarShip (SPATHI_SHIP, REMOVE_BUILT);
-					SET_GAME_STATE (SPATHI_SHIELDED_SELVES, 1);
-					SpathiPtr->actual_strength = 0;
-				}
-
-				UnlockFleetInfo (&GLOBAL (avail_race_q), hSpathi);
-			}
-			break;
-		case ADVANCE_ILWRATH_MISSION:
-			ilwrath_mission ();
-			break;
-		case ADVANCE_MYCON_MISSION:
-			mycon_mission ();
-			break;
-		case ARILOU_UMGAH_CHECK:
-			SET_GAME_STATE (ARILOU_CHECKED_UMGAH, 2);
-			break;
-		case YEHAT_REBEL_EVENT:
-		{
-			HFLEETINFO hRebel, hRoyalist;
-			FLEET_INFO *RebelPtr;
-			FLEET_INFO *RoyalistPtr;
-
-			hRebel = GetStarShipFromIndex (&GLOBAL (avail_race_q),
-					YEHAT_REBEL_SHIP);
-			RebelPtr = LockFleetInfo (&GLOBAL (avail_race_q), hRebel);
-			hRoyalist = GetStarShipFromIndex (&GLOBAL (avail_race_q),
-					YEHAT_SHIP);
-			RoyalistPtr = LockFleetInfo (&GLOBAL (avail_race_q), hRoyalist);
-			RoyalistPtr->actual_strength = RoyalistPtr->actual_strength *
-					2 / 3;
-			RebelPtr->actual_strength = RoyalistPtr->actual_strength;
-			RebelPtr->loc.x = 5150;
-			RebelPtr->loc.y = 0;
-			UnlockFleetInfo (&GLOBAL (avail_race_q), hRoyalist);
-			UnlockFleetInfo (&GLOBAL (avail_race_q), hRebel);
-			ActivateStarShip (YEHAT_REBEL_SHIP, SPHERE_TRACKING);
-			break;
-		}
-		case SLYLANDRO_RAMP_UP:
-			if (!GET_GAME_STATE (DESTRUCT_CODE_ON_SHIP))
-			{
-				BYTE ramp_factor;
-
-				ramp_factor = GET_GAME_STATE (SLYLANDRO_MULTIPLIER);
-				if (++ramp_factor <= 4)
-				{
-					SET_GAME_STATE (SLYLANDRO_MULTIPLIER, ramp_factor);
-					AddEvent (RELATIVE_EVENT, 0, 182, 0, SLYLANDRO_RAMP_UP);
-				}
-			}
-			break;
-		case SLYLANDRO_RAMP_DOWN:
-		{
-			BYTE ramp_factor;
-
-			ramp_factor = GET_GAME_STATE (SLYLANDRO_MULTIPLIER);
-			if (--ramp_factor)
-				AddEvent (RELATIVE_EVENT, 0, 23, 0, SLYLANDRO_RAMP_DOWN);
-			SET_GAME_STATE (SLYLANDRO_MULTIPLIER, ramp_factor);
-			break;
-		}
+	eventIdStr = eventIdNumToStr (selector);
+	if (eventIdStr == NULL) {
+		log_add(log_Warning, "Warning: EventHandler(): Event %d is "
+				"unknown.", selector);
+		return;
 	}
+
+	luaUqm_event_callEvent(eventIdStr);
 }
 
 void
-SetRaceDest (BYTE which_race, COORD x, COORD y, BYTE days_left, BYTE
-		func_index)
+SetRaceDest (BYTE which_race, COORD x, COORD y, BYTE days_left,
+		BYTE func_index)
 {
 	HFLEETINFO hFleet;
 	FLEET_INFO *FleetPtr;
@@ -233,16 +177,17 @@ SetRaceDest (BYTE which_race, COORD x, C
 }
 
 
-
-static void
-arilou_entrance_event (void)
+static int
+arilou_entrance_event (int arg)
 {
 	SET_GAME_STATE (ARILOU_SPACE, OPENING);
 	AddEvent (RELATIVE_EVENT, 0, 3, 0, ARILOU_EXIT_EVENT);
+	(void) arg;
+	return 0;
 }
 
-static void
-arilou_exit_event (void)
+static int
+arilou_exit_event (int arg)
 {
 	COUNT month_index, year_index;
 
@@ -254,6 +199,9 @@ arilou_exit_event (void)
 	SET_GAME_STATE (ARILOU_SPACE, CLOSING);
 	AddEvent (ABSOLUTE_EVENT,
 			month_index, 17, year_index, ARILOU_ENTRANCE_EVENT);
+
+	(void) arg;
+	return 0;
 }
 
 static void
@@ -311,108 +259,36 @@ check_race_growth (void)
 	}
 }
 
-static void
-black_urquan_genocide (void)
+static int
+hyperspace_encounter_event (int arg)
 {
-	BYTE Index;
-	long best_dist;
-	SIZE best_dx, best_dy;
-	HFLEETINFO hStarShip, hNextShip;
-	HFLEETINFO hBlackUrquan;
-	FLEET_INFO *BlackUrquanPtr;
-
-	hBlackUrquan = GetStarShipFromIndex (&GLOBAL (avail_race_q),
-			BLACK_URQUAN_SHIP);
-	BlackUrquanPtr = LockFleetInfo (&GLOBAL (avail_race_q), hBlackUrquan);
-
-	best_dist = -1;
-	best_dx = SOL_X - BlackUrquanPtr->loc.x;
-	best_dy = SOL_Y - BlackUrquanPtr->loc.y;
-	for (Index = 0, hStarShip = GetHeadLink (&GLOBAL (avail_race_q));
-			hStarShip; ++Index, hStarShip = hNextShip)
-	{
-		FLEET_INFO *FleetPtr;
-
-		FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
-		hNextShip = _GetSuccLink (FleetPtr);
-
-		if (Index != BLACK_URQUAN_SHIP
-				&& Index != URQUAN_SHIP
-				&& FleetPtr->actual_strength != INFINITE_RADIUS)
-		{
-			SIZE dx, dy;
-
-			dx = FleetPtr->loc.x - BlackUrquanPtr->loc.x;
-			dy = FleetPtr->loc.y - BlackUrquanPtr->loc.y;
-			if (dx == 0 && dy == 0)
-			{
-				// Arrived at the victim's home world. Cleanse it.
-				FleetPtr->allied_state = DEAD_GUY;
-				FleetPtr->actual_strength = 0;
-			}
-			else if (FleetPtr->actual_strength)
-			{
-				long dist;
-
-				dist = (long)dx * dx + (long)dy * dy;
-				if (best_dist < 0 || dist < best_dist || Index == DRUUGE_SHIP)
-				{
-					best_dist = dist;
-					best_dx = dx;
-					best_dy = dy;
-
-					if (Index == DRUUGE_SHIP)
-						hNextShip = 0;
-				}
-			}
-		}
-
-		UnlockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
-	}
+	check_race_growth ();
+	if (inHyperSpace ())
+		check_hyperspace_encounter ();
 
-	if (best_dist < 0 && best_dx == 0 && best_dy == 0)
-	{
-		// All spheres of influence are gone - game over.
-		GLOBAL (CurrentActivity) &= ~IN_BATTLE;
-		GLOBAL_SIS (CrewEnlisted) = (COUNT)~0;
+	AddEvent (RELATIVE_EVENT, 0, 1, 0, HYPERSPACE_ENCOUNTER_EVENT);
+	
+	(void) arg;
+	return 0;
+}
 
-		SET_GAME_STATE (KOHR_AH_KILLED_ALL, 1);
-	}
-	else
+static int
+kohr_ah_victorious_event (int arg)
+{
+	if (GET_GAME_STATE (UTWIG_SUPOX_MISSION))
 	{
-		// Moving towards new race to cleanse.
-		COUNT speed;
-
-		if (best_dist < 0)
-			best_dist = (long)best_dx * best_dx + (long)best_dy * best_dy;
-
-		speed = square_root (best_dist) / 158;
-		if (speed == 0)
-			speed = 1;
-		else if (speed > 255)
-			speed = 255;
-			
-		// JMS: Cheat mode: The Kohr-Ah don't move at all!
-		if (optCheatMode)
-			speed = 0;
-
-		SET_GAME_STATE (KOHR_AH_FRENZY, 1);
-		SET_GAME_STATE (KOHR_AH_VISITS, 0);
-		SET_GAME_STATE (KOHR_AH_REASONS, 0);
-		SET_GAME_STATE (KOHR_AH_PLEAD, 0);
-		SET_GAME_STATE (KOHR_AH_INFO, 0);
-		SET_GAME_STATE (URQUAN_VISITS, 0);
-		SetRaceDest (BLACK_URQUAN_SHIP,
-				BlackUrquanPtr->loc.x + best_dx,
-				BlackUrquanPtr->loc.y + best_dy,
-				(BYTE)speed, KOHR_AH_GENOCIDE_EVENT);
+		// The Utwig/Supox mission delayed the genocide.
+		// Try again in one year.
+		AddEvent (RELATIVE_EVENT, 0, 0, 1, KOHR_AH_GENOCIDE_EVENT);
+		return 0;
 	}
 
-	UnlockFleetInfo (&GLOBAL (avail_race_q), hBlackUrquan);
+	// No more delay; start the genocide.
+	return kohr_ah_genocide_event (arg);
 }
 
-static void
-pkunk_mission (void)
+static int
+advance_pkunk_mission (int arg)
 {
 	HFLEETINFO hPkunk;
 	FLEET_INFO *PkunkPtr;
@@ -439,7 +315,7 @@ pkunk_mission (void)
 				SET_GAME_STATE (PKUNK_ON_THE_MOVE, 0);
 				AddEvent (RELATIVE_EVENT, 3, 0, 0, ADVANCE_PKUNK_MISSION);
 				UnlockFleetInfo (&GLOBAL (avail_race_q), hPkunk);
-				return;
+				return 0;
 			}
 		}
 
@@ -447,7 +323,7 @@ pkunk_mission (void)
 		{
 			SET_GAME_STATE (YEHAT_ABSORBED_PKUNK, 1);
 			PkunkPtr->allied_state = DEAD_GUY;
-			ActivateStarShip (YEHAT_SHIP, SPHERE_TRACKING);
+			StartSphereTracking (YEHAT_SHIP);
 		}
 		else
 		{
@@ -473,10 +349,14 @@ pkunk_mission (void)
 	}
 
 	UnlockFleetInfo (&GLOBAL (avail_race_q), hPkunk);
+
+	(void) arg;
+	return 0;
 }
 
-static void
-thradd_mission (void)
+// Send the Thraddash to fight the Kohr-Ah.
+static int
+advance_thradd_mission (int arg)
 {
 	BYTE MissionState;
 	HFLEETINFO hThradd;
@@ -529,74 +409,73 @@ thradd_mission (void)
 	}
 
 	UnlockFleetInfo (&GLOBAL (avail_race_q), hThradd);
+
+	(void) arg;
+	return 0;
 }
 
-static void
-ilwrath_mission (void)
+static int
+zoqfot_distress_event (int arg)
 {
-	COUNT MaddLength = 128;
-	SIZE strength_loss;
-	BYTE ThraddState = GET_GAME_STATE (THRADD_MISSION);
-	HFLEETINFO	hIlwrath = GetStarShipFromIndex (&GLOBAL (avail_race_q), ILWRATH_SHIP),
-				hThradd = GetStarShipFromIndex (&GLOBAL (avail_race_q), THRADDASH_SHIP);
-	FLEET_INFO	*IlwrathPtr = LockFleetInfo (&GLOBAL (avail_race_q), hIlwrath), 
-				*ThraddPtr = LockFleetInfo (&GLOBAL (avail_race_q), hThradd);
-
-	if (IlwrathPtr->loc.x == ((2500 + 2535) >> 1) && IlwrathPtr->loc.y == ((8070 + 8358) >> 1)) { // What is with the silly math?
-		IlwrathPtr->actual_strength = 0;
-		IlwrathPtr->allied_state = DEAD_GUY;
-		if(ThraddPtr->allied_state != GOOD_GUY){
-			ThraddPtr->actual_strength = 0;
-			ThraddPtr->allied_state = DEAD_GUY;
-		}
-	} else if (IlwrathPtr->actual_strength) {
-		if (!GET_GAME_STATE (ILWRATH_FIGHT_THRADDASH) && (IlwrathPtr->dest_loc.x != 2500 || IlwrathPtr->dest_loc.y != 8070)) {
-			SetRaceDest (ILWRATH_SHIP, 2500, 8070, 90, ADVANCE_ILWRATH_MISSION); //90
-		} else {
-			if (IlwrathPtr->days_left == 0) {	/* arrived for battle */
-				SET_GAME_STATE (ILWRATH_FIGHT_THRADDASH, 1);
-				SET_GAME_STATE (HELIX_UNPROTECTED, 1);
-				strength_loss = (SIZE)IlwrathPtr->actual_strength;
-				IlwrathPtr->growth = (BYTE)(-strength_loss / MaddLength);
-				IlwrathPtr->growth_fract = (BYTE)(((strength_loss % MaddLength) << 8) / MaddLength);
-				SetRaceDest (ILWRATH_SHIP, 2517, 8214, MaddLength - 1, ADVANCE_ILWRATH_MISSION);
+	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
+			&& CurStarDescPtr
+			&& CurStarDescPtr->Index == ZOQFOT_DEFINED)
+	{
+		AddEvent (RELATIVE_EVENT, 0, 7, 0, ZOQFOT_DISTRESS_EVENT);
+	}
+	else
+	{
+		SET_GAME_STATE (ZOQFOT_DISTRESS, 1);
+		AddEvent (RELATIVE_EVENT, 6, 0, 0, ZOQFOT_DEATH_EVENT);
+	}
 
-				if (ThraddPtr->allied_state == GOOD_GUY){
-					strength_loss = (SIZE)(ThraddPtr->actual_strength * 0.25); // Smarterer math
-					ThraddPtr->growth = (BYTE)(-strength_loss / MaddLength);
-					ThraddPtr->growth_fract = (BYTE)(((strength_loss % MaddLength) << 8) / MaddLength);
-					ThraddPtr->growth_err_term = 255 >> 1;
-				} else {
-					SET_GAME_STATE (THRADD_VISITS, 0);
-					strength_loss = (SIZE)ThraddPtr->actual_strength;
-					ThraddPtr->growth = (BYTE)(-strength_loss / MaddLength);
-					ThraddPtr->growth_fract = (BYTE)(((strength_loss % MaddLength) << 8) / MaddLength);
-				}
-			}
+	(void) arg;
+	return 0;
+}
 
-			if (ThraddState == 0 || ThraddState > 3) {	/* never went to Kohr-Ah or returned */
-				SetRaceDest (THRADDASH_SHIP, (2500 + 2535) >> 1, (8070 + 8358) >> 1, IlwrathPtr->days_left + 1, (BYTE)~0);
-			} else if (ThraddState < 3) {	/* recall on the double */
-				SetRaceDest (THRADDASH_SHIP, 2535, 8358, 10, ADVANCE_THRADD_MISSION);
-				SET_GAME_STATE (THRADD_MISSION, 3);
-			}
-		}
+static int
+zoqfot_death_event (int arg)
+{
+	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
+			&& CurStarDescPtr
+			&& CurStarDescPtr->Index == ZOQFOT_DEFINED)
+	{
+		AddEvent (RELATIVE_EVENT, 0, 7, 0, ZOQFOT_DEATH_EVENT);
 	}
-	if(ThraddPtr->allied_state == GOOD_GUY && !IlwrathPtr->actual_strength){		
-		ThraddPtr->growth = 0;
-		ThraddPtr->growth_fract = 0;
-		SET_GAME_STATE (ILWRATH_FIGHT_THRADDASH, 0);		
-		SetRaceDest (THRADDASH_SHIP, 2535, 8358, 3, (BYTE)~0);
-		if(!GET_GAME_STATE(AQUA_HELIX)){
-			SET_GAME_STATE (HELIX_UNPROTECTED, 0);
-		}
+	else if (GET_GAME_STATE (ZOQFOT_DISTRESS))
+	{
+		HFLEETINFO hZoqFot;
+		FLEET_INFO *ZoqFotPtr;
+
+		hZoqFot = GetStarShipFromIndex (&GLOBAL (avail_race_q),
+				ZOQFOTPIK_SHIP);
+		ZoqFotPtr = LockFleetInfo (&GLOBAL (avail_race_q), hZoqFot);
+		ZoqFotPtr->actual_strength = 0;
+		ZoqFotPtr->allied_state = DEAD_GUY;
+		UnlockFleetInfo (&GLOBAL (avail_race_q), hZoqFot);
+
+		SET_GAME_STATE (ZOQFOT_DISTRESS, 2);
 	}
-	UnlockFleetInfo (&GLOBAL (avail_race_q), hThradd);
-	UnlockFleetInfo (&GLOBAL (avail_race_q), hIlwrath);
+
+	(void) arg;
+	return 0;
 }
 
-static void
-utwig_supox_mission (void)
+static int
+shofixti_return_event (int arg)
+{
+	SetRaceAllied (SHOFIXTI_SHIP, TRUE);
+	GLOBAL (CrewCost) -= 2;
+			/* crew is not an issue anymore */
+	SET_GAME_STATE (CREW_PURCHASED0, 0);
+	SET_GAME_STATE (CREW_PURCHASED1, 0);
+
+	(void) arg;
+	return 0;
+}
+
+static int
+advance_utwig_supox_mission (int arg)
 {
 	BYTE MissionState;
 	HFLEETINFO hUtwig, hSupox;
@@ -628,7 +507,8 @@ utwig_supox_mission (void)
 			if (strength_loss)
 			{
 				SupoxPtr->growth = (BYTE)(-strength_loss / 160);
-				SupoxPtr->growth_fract = (BYTE)(((strength_loss % 160) << 8) / 160);
+				SupoxPtr->growth_fract =
+						(BYTE)(((strength_loss % 160) << 8) / 160);
 				SupoxPtr->growth_err_term = 255 >> 1;
 			}
 
@@ -681,10 +561,223 @@ utwig_supox_mission (void)
 
 	UnlockFleetInfo (&GLOBAL (avail_race_q), hSupox);
 	UnlockFleetInfo (&GLOBAL (avail_race_q), hUtwig);
+
+	(void) arg;
+	return 0;
 }
 
-static void
-mycon_mission (void)
+static int
+kohr_ah_genocide_event (int arg)
+{
+	BYTE Index;
+	long best_dist;
+	SIZE best_dx, best_dy;
+	HFLEETINFO hStarShip, hNextShip;
+	HFLEETINFO hBlackUrquan;
+	FLEET_INFO *BlackUrquanPtr;
+
+	if (!GET_GAME_STATE (KOHR_AH_FRENZY)
+			&& LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
+					&& CurStarDescPtr
+			&& CurStarDescPtr->Index == SAMATRA_DEFINED) {
+		AddEvent (RELATIVE_EVENT, 0, 7, 0, KOHR_AH_GENOCIDE_EVENT);
+		return 0;
+	}
+
+	hBlackUrquan = GetStarShipFromIndex (&GLOBAL (avail_race_q),
+			BLACK_URQUAN_SHIP);
+	BlackUrquanPtr = LockFleetInfo (&GLOBAL (avail_race_q), hBlackUrquan);
+
+	best_dist = -1;
+	best_dx = SOL_X - BlackUrquanPtr->loc.x;
+	best_dy = SOL_Y - BlackUrquanPtr->loc.y;
+	for (Index = 0, hStarShip = GetHeadLink (&GLOBAL (avail_race_q));
+			hStarShip; ++Index, hStarShip = hNextShip)
+	{
+		FLEET_INFO *FleetPtr;
+
+		FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
+		hNextShip = _GetSuccLink (FleetPtr);
+
+		if (Index != BLACK_URQUAN_SHIP
+				&& Index != URQUAN_SHIP
+				&& FleetPtr->actual_strength != INFINITE_RADIUS)
+		{
+			SIZE dx, dy;
+
+			dx = FleetPtr->loc.x - BlackUrquanPtr->loc.x;
+			dy = FleetPtr->loc.y - BlackUrquanPtr->loc.y;
+			if (dx == 0 && dy == 0)
+			{
+				// Arrived at the victim's home world. Cleanse it.
+				FleetPtr->allied_state = DEAD_GUY;
+				FleetPtr->actual_strength = 0;
+			}
+			else if (FleetPtr->actual_strength)
+			{
+				long dist;
+
+				dist = (long)dx * dx + (long)dy * dy;
+				if (best_dist < 0 || dist < best_dist || Index == DRUUGE_SHIP)
+				{
+					best_dist = dist;
+					best_dx = dx;
+					best_dy = dy;
+
+					if (Index == DRUUGE_SHIP)
+						hNextShip = 0;
+				}
+			}
+		}
+
+		UnlockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
+	}
+
+	if (best_dist < 0 && best_dx == 0 && best_dy == 0)
+	{
+		// All spheres of influence are gone - game over.
+		GLOBAL (CurrentActivity) &= ~IN_BATTLE;
+		GLOBAL_SIS (CrewEnlisted) = (COUNT)~0;
+
+		SET_GAME_STATE (KOHR_AH_KILLED_ALL, 1);
+	}
+	else
+	{
+		// Moving towards new race to cleanse.
+		COUNT speed;
+
+		if (best_dist < 0)
+			best_dist = (long)best_dx * best_dx + (long)best_dy * best_dy;
+
+		speed = square_root (best_dist) / 158;
+		if (speed == 0)
+			speed = 1;
+		else if (speed > 255)
+			speed = 255;
+ 
+		if (optCheatMode)
+			speed = 0;
+
+		SET_GAME_STATE (KOHR_AH_FRENZY, 1);
+		SET_GAME_STATE (KOHR_AH_VISITS, 0);
+		SET_GAME_STATE (KOHR_AH_REASONS, 0);
+		SET_GAME_STATE (KOHR_AH_PLEAD, 0);
+		SET_GAME_STATE (KOHR_AH_INFO, 0);
+		SET_GAME_STATE (URQUAN_VISITS, 0);
+		SetRaceDest (BLACK_URQUAN_SHIP,
+				BlackUrquanPtr->loc.x + best_dx,
+				BlackUrquanPtr->loc.y + best_dy,
+				(BYTE)speed, KOHR_AH_GENOCIDE_EVENT);
+	}
+
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hBlackUrquan);
+
+	(void) arg;
+	return 0;
+}
+
+static int
+spathi_shield_event (int arg)
+{
+	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
+			&& CurStarDescPtr
+			&& CurStarDescPtr->Index == SPATHI_DEFINED)
+	{
+		AddEvent (RELATIVE_EVENT, 0, 7, 0, SPATHI_SHIELD_EVENT);
+	}
+	else
+	{
+		HFLEETINFO hSpathi;
+		FLEET_INFO *SpathiPtr;
+
+		hSpathi = GetStarShipFromIndex (&GLOBAL (avail_race_q),
+				SPATHI_SHIP);
+		SpathiPtr = LockFleetInfo (&GLOBAL (avail_race_q), hSpathi);
+
+		if (SpathiPtr->actual_strength)
+		{
+			SetRaceAllied (SPATHI_SHIP, FALSE);
+			RemoveEscortShips (SPATHI_SHIP);
+			SET_GAME_STATE (SPATHI_SHIELDED_SELVES, 1);
+			SpathiPtr->actual_strength = 0;
+		}
+
+		UnlockFleetInfo (&GLOBAL (avail_race_q), hSpathi);
+	}
+
+	(void) arg;
+	return 0;
+}
+
+static int
+advance_ilwrath_mission (int arg)
+{
+	COUNT MaddLength = 128; // 128
+	SIZE strength_loss;
+	BYTE ThraddState = GET_GAME_STATE (THRADD_MISSION);
+	HFLEETINFO	hIlwrath = GetStarShipFromIndex (&GLOBAL (avail_race_q), ILWRATH_SHIP),
+				hThradd = GetStarShipFromIndex (&GLOBAL (avail_race_q), THRADDASH_SHIP);
+	FLEET_INFO	*IlwrathPtr = LockFleetInfo (&GLOBAL (avail_race_q), hIlwrath), 
+				*ThraddPtr = LockFleetInfo (&GLOBAL (avail_race_q), hThradd);
+
+	if (IlwrathPtr->loc.x == ((2500 + 2535) >> 1) && IlwrathPtr->loc.y == ((8070 + 8358) >> 1)) {
+		IlwrathPtr->actual_strength = 0;
+		IlwrathPtr->allied_state = DEAD_GUY;	
+		if(ThraddPtr->allied_state != GOOD_GUY || !optThraddStory){
+			ThraddPtr->actual_strength = 0;
+			ThraddPtr->allied_state = DEAD_GUY;
+		}
+	} else if (IlwrathPtr->actual_strength) {
+		if (!GET_GAME_STATE (ILWRATH_FIGHT_THRADDASH) && (IlwrathPtr->dest_loc.x != 2500 || IlwrathPtr->dest_loc.y != 8070)) {
+			SetRaceDest (ILWRATH_SHIP, 2500, 8070, 90, ADVANCE_ILWRATH_MISSION); // 90
+		} else {
+			if (IlwrathPtr->days_left == 0) {	/* arrived for battle */
+				SET_GAME_STATE (ILWRATH_FIGHT_THRADDASH, 1);
+				SET_GAME_STATE (HELIX_UNPROTECTED, 1);
+				strength_loss = (SIZE)IlwrathPtr->actual_strength;
+				IlwrathPtr->growth = (BYTE)(-strength_loss / MaddLength);
+				IlwrathPtr->growth_fract = (BYTE)(((strength_loss % MaddLength) << 8) / MaddLength);
+				SetRaceDest (ILWRATH_SHIP, 2517, 8214, MaddLength - 1, ADVANCE_ILWRATH_MISSION);
+
+				if (ThraddPtr->allied_state == GOOD_GUY && optThraddStory){
+					strength_loss = (SIZE)(ThraddPtr->actual_strength * 0.25); // Smarterer math
+					ThraddPtr->growth = (BYTE)(-strength_loss / MaddLength);
+					ThraddPtr->growth_fract = (BYTE)(((strength_loss % MaddLength) << 8) / MaddLength);
+					ThraddPtr->growth_err_term = 255 >> 1;
+				} else {
+					SET_GAME_STATE (THRADD_VISITS, 0);
+					strength_loss = (SIZE)ThraddPtr->actual_strength;
+					ThraddPtr->growth = (BYTE)(-strength_loss / MaddLength);
+					ThraddPtr->growth_fract = (BYTE)(((strength_loss % MaddLength) << 8) / MaddLength);
+				}
+			}
+
+			if (ThraddState == 0 || ThraddState > 3) {	/* never went to Kohr-Ah or returned */
+				SetRaceDest (THRADDASH_SHIP, (2500 + 2535) >> 1, (8070 + 8358) >> 1, IlwrathPtr->days_left + 1, (BYTE)~0);
+			} else if (ThraddState < 3) {	/* recall on the double */
+				SetRaceDest (THRADDASH_SHIP, 2535, 8358, 10, ADVANCE_THRADD_MISSION);
+				SET_GAME_STATE (THRADD_MISSION, 3);
+			}
+		}
+	}
+	if(ThraddPtr->allied_state == GOOD_GUY && !IlwrathPtr->actual_strength && optThraddStory){		
+		ThraddPtr->growth = 0;
+		ThraddPtr->growth_fract = 0;
+		SET_GAME_STATE (ILWRATH_FIGHT_THRADDASH, 0);		
+		SetRaceDest (THRADDASH_SHIP, 2535, 8358, 3, (BYTE)~0);
+		if(!GET_GAME_STATE(AQUA_HELIX)){
+			SET_GAME_STATE (HELIX_UNPROTECTED, 0);
+		}
+	}
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hThradd);
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hIlwrath);
+	
+	(void) arg;
+	return 0;
+}
+
+static int
+advance_mycon_mission (int arg)
 {
 	HFLEETINFO hMycon;
 	FLEET_INFO *MyconPtr;
@@ -720,5 +813,73 @@ mycon_mission (void)
 	}
 
 	UnlockFleetInfo (&GLOBAL (avail_race_q), hMycon);
+	
+	(void) arg;
+	return 0;
+}
+
+static int
+arilou_umgah_check (int arg)
+{
+	SET_GAME_STATE (ARILOU_CHECKED_UMGAH, 2);
+
+	(void) arg;
+	return 0;
+}
+
+static int
+yehat_rebel_event (int arg)
+{
+	HFLEETINFO hRebel, hRoyalist;
+	FLEET_INFO *RebelPtr;
+	FLEET_INFO *RoyalistPtr;
+
+	hRebel = GetStarShipFromIndex (&GLOBAL (avail_race_q), YEHAT_REBEL_SHIP);
+	RebelPtr = LockFleetInfo (&GLOBAL (avail_race_q), hRebel);
+	hRoyalist = GetStarShipFromIndex (&GLOBAL (avail_race_q), YEHAT_SHIP);
+	RoyalistPtr = LockFleetInfo (&GLOBAL (avail_race_q), hRoyalist);
+	RoyalistPtr->actual_strength = RoyalistPtr->actual_strength * 2 / 3;
+	RebelPtr->actual_strength = RoyalistPtr->actual_strength;
+	RebelPtr->loc.x = 5150;
+	RebelPtr->loc.y = 0;
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hRoyalist);
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hRebel);
+	StartSphereTracking (YEHAT_REBEL_SHIP);
+
+	(void) arg;
+	return 0;
+}
+
+static int
+slylandro_ramp_up (int arg)
+{
+	if (!GET_GAME_STATE (DESTRUCT_CODE_ON_SHIP))
+	{
+		BYTE ramp_factor;
+
+		ramp_factor = GET_GAME_STATE (SLYLANDRO_MULTIPLIER);
+		if (++ramp_factor <= 4)
+		{
+			SET_GAME_STATE (SLYLANDRO_MULTIPLIER, ramp_factor);
+			AddEvent (RELATIVE_EVENT, 0, 182, 0, SLYLANDRO_RAMP_UP);
+		}
+	}
+
+	(void) arg;
+	return 0;
+}
+
+static int
+slylandro_ramp_down (int arg)
+{
+	BYTE ramp_factor;
+
+	ramp_factor = GET_GAME_STATE (SLYLANDRO_MULTIPLIER);
+	if (--ramp_factor)
+		AddEvent (RELATIVE_EVENT, 0, 23, 0, SLYLANDRO_RAMP_DOWN);
+	SET_GAME_STATE (SLYLANDRO_MULTIPLIER, ramp_factor);
+
+	(void) arg;
+	return 0;
 }
 
diff -ruNp src.hd/uqm/gameev.h src/uqm/gameev.h
--- src.hd/uqm/gameev.h	2017-12-29 02:25:52 -0800
+++ src/uqm/gameev.h	2017-12-29 00:57:45 -0800
@@ -20,6 +20,10 @@
 #include "libs/compiler.h"
 #include "libs/gfxlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 
 enum
 {
@@ -51,11 +55,21 @@ typedef enum
 	OPENING
 } ARILOU_GATE_STATE;
 
+extern int eventIdStrToNum (const char *eventIdStr);
+extern const char *eventIdNumToStr (int eventNum);
+
+extern void initEventSystem (void);
+extern void uninitEventSystem (void);
+
 extern void AddInitialGameEvents (void);
 extern void EventHandler (BYTE selector);
 extern void SetRaceDest (BYTE which_race, COORD x, COORD y, BYTE days_left,
 		BYTE func_index);
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _GAMEEV_H */
 
diff -ruNp src.hd/uqm/gameinp.c src/uqm/gameinp.c
--- src.hd/uqm/gameinp.c	2017-12-29 02:25:52 -0800
+++ src/uqm/gameinp.c	2017-12-29 00:57:45 -0800
@@ -28,10 +28,12 @@
 #include "sounds.h"
 #include "tactrans.h"
 #include "uqmdebug.h"
+#include "libs/async.h"
 #include "libs/inplib.h"
 #include "libs/timelib.h"
 #include "libs/threadlib.h"
 #include "setup.h"
+
 // MB: Updated menu delay values so it no longer takes an age to (a) fill up your fuel tanks (b) fill up your crew (c) search through your saved games.
 #define ACCELERATION_INCREMENT (ONE_SECOND / 28)
 #define MENU_REPEAT_DELAY (ONE_SECOND / 3)
@@ -274,6 +276,11 @@ UpdateInputState (void)
 
 	if (CurrentInputState.menu[KEY_EXIT])
 		ExitRequested = TRUE;
+
+#if defined(DEBUG) || defined(USE_DEBUG_KEY)
+	if (PulsedInputState.menu[KEY_DEBUG])
+		debugKeyPressedSynchronous ();
+#endif
 }
 
 InputFrameCallback *
@@ -359,23 +366,11 @@ DoInput (void *pInputState, BOOLEAN rese
 	do
 	{
 		MENU_SOUND_FLAGS soundFlags;
+		Async_process ();
 		TaskSwitch ();
 
 		UpdateInputState ();
 
-#ifdef DEBUG
-		if (doInputDebugHook != NULL)
-		{
-			void (*saveDebugHook) (void);
-			saveDebugHook = doInputDebugHook;
-			doInputDebugHook = NULL;
-					// No further debugHook calls unless the called
-					// function resets doInputDebugHook.
-			(*saveDebugHook) ();
-			continue;
-		}
-#endif
-
 #if DEMO_MODE || CREATE_JOURNAL
 		if (ArrowInput != DemoInput)
 #endif
@@ -433,7 +428,7 @@ ControlInputToBattleInput (const int *ke
 	if (keyState[KEY_RIGHT])
 		InputState |= BATTLE_RIGHT;
 	if (keyState[KEY_WEAPON]){
-	if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
+		if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
 			(((PlayerControl[0] & COMPUTER_CONTROL) && PlayerControl[1] & HUMAN_CONTROL) || 
 			((PlayerControl[1] & COMPUTER_CONTROL) && PlayerControl[0] & HUMAN_CONTROL))))
 		{
@@ -442,7 +437,7 @@ ControlInputToBattleInput (const int *ke
 		InputState |= BATTLE_WEAPON;
 	}
 	if (keyState[KEY_SPECIAL]){
-	if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
+		if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
 			(((PlayerControl[0] & COMPUTER_CONTROL) && PlayerControl[1] & HUMAN_CONTROL) || 
 			((PlayerControl[1] & COMPUTER_CONTROL) && PlayerControl[0] & HUMAN_CONTROL))))
 		{
diff -ruNp src.hd/uqm/gameopt.c src/uqm/gameopt.c
--- src.hd/uqm/gameopt.c	2017-12-29 02:25:52 -0800
+++ src/uqm/gameopt.c	2017-12-29 00:57:45 -0800
@@ -16,20 +16,16 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "gameopt.h"
 
 #include "build.h"
 #include "colors.h"
 #include "controls.h"
-// XXX: for FindStart(), GetClusterName()
-#include "encount.h"
+#include "starmap.h"
 #include "menustat.h"
 #include "sis.h"
 #include "units.h"
 #include "gamestr.h"
-#include "load.h"
 #include "options.h"
 #include "save.h"
 #include "settings.h"
@@ -37,9 +33,6 @@
 #include "sounds.h"
 #include "util.h"
 #include "libs/graphics/gfx_common.h"
-#include "libs/log.h"
-
-#include "process.h" // JMS
 
 #include <ctype.h>
 
@@ -84,24 +77,19 @@ ConfirmSaveLoad (STAMP *MsgStamp)
 	{
 		*MsgStamp = SaveContextFrame (&r);
 	}
-	
-	if (RESOLUTION_FACTOR == 0)
-	{
+	if (RESOLUTION_FACTOR == 0) {
 		DrawStarConBox (&r, 2,
 						BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19),
 						BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F),
 						TRUE, BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
 		SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x14, 0x14, 0x14), 0x0F));
-	}
-	else
-	{
+	} else {
 		DrawStarConBox (&r, 2,
 						PCMENU_TOP_LEFT_BORDER_COLOR,
 						PCMENU_BOTTOM_RIGHT_BORDER_COLOR,
 						TRUE, PCMENU_BACKGROUND_COLOR);
 		SetContextForeGroundColor (PCMENU_SELECTION_TEXT_COLOR);
 	}
-	
 	font_DrawText (&t);
 }
 
@@ -184,10 +172,7 @@ FeedbackSetting (BYTE which_setting)
 					GAME_STRING (NAMING_STRING_BASE + 0));
 			break;
 	}
-
-	LockMutex (GraphicsLock);
 	DrawStatusMessage (buf);
-	UnlockMutex (GraphicsLock);
 }
 
 #define DDSHS_NORMAL   0
@@ -203,12 +188,9 @@ DrawNameString (bool nameCaptain, UNICOD
 	Color BackGround, ForeGround;
 	FONT Font;
 
-	LockMutex (GraphicsLock);
-
 	{
 		r.extent.height = SHIP_NAME_HEIGHT;
 
-		SetContext (StatusContext);
 		if (nameCaptain)
 		{	// Naming the captain
 			Font = TinyFont;
@@ -235,10 +217,10 @@ DrawNameString (bool nameCaptain, UNICOD
 			BackGround = BUILD_COLOR (MAKE_RGB15 (0x0F, 0x00, 0x00), 0x2D);
 			ForeGround = BUILD_COLOR (MAKE_RGB15 (0x1F, 0x0A, 0x00), 0x7D);
 		}
-
 		lf.align = ALIGN_CENTER;
 	}
 
+	SetContext (StatusContext);
 	SetContextFont (Font);
 	lf.pStr = Str;
 	lf.CharCount = (COUNT)~0;
@@ -261,11 +243,12 @@ DrawNameString (bool nameCaptain, UNICOD
 		if ((text_r.extent.width + 2) >= r.extent.width)
 		{	// the text does not fit the input box size and so
 			// will not fit when displayed later
-			UnlockMutex (GraphicsLock);
 			// disallow the change
 			return (FALSE);
 		}
 
+		PreUpdateFlashRect ();
+
 		SetContextForeGroundColor (BackGround);
 		DrawFilledRectangle (&r);
 
@@ -274,7 +257,7 @@ DrawNameString (bool nameCaptain, UNICOD
 			text_r.corner.x += *pchar_deltas++;
 		if (CursorPos < lf.CharCount) /* end of line */
 			--text_r.corner.x;
-		
+
 		if (state & DDSHS_BLOCKCUR)
 		{	// Use block cursor for keyboardless systems
 			if (CursorPos == lf.CharCount)
@@ -294,7 +277,7 @@ DrawNameString (bool nameCaptain, UNICOD
 		{	// Insertion point cursor
 			text_r.extent.width = 1;
 		}
-		
+
 		text_r.corner.y = r.corner.y;
 		text_r.extent.height = r.extent.height;
 		SetContextForeGroundColor (BLACK_COLOR);
@@ -303,10 +286,9 @@ DrawNameString (bool nameCaptain, UNICOD
 		SetContextForeGroundColor (ForeGround);
 		font_DrawText (&lf);
 
-		SetFlashRect (&r);
+		PostUpdateFlashRect ();
 	}
 
-	UnlockMutex (GraphicsLock);
 	return (TRUE);
 }
 
@@ -322,7 +304,6 @@ OnNameChange (TEXTENTRY_STATE *pTES)
 	return DrawNameString (nameCaptain, pTES->BaseStr, pTES->CursorPos, hl);
 }
 
-// JMS: Added the 'gamestart' parameter.
 static void
 NameCaptainOrShip (bool nameCaptain, bool gamestart)
 {
@@ -331,9 +312,7 @@ NameCaptainOrShip (bool nameCaptain, boo
 	UNICODE *Setting;
 	COUNT CursPos = 0; // JMS
 	RECT r; // JMS
-	
-	LockMutex (GraphicsLock);
-	
+
 	// JMS: This should only be invoked when starting a new game.
 	// It prints a prompt window to the center of the screen, urging
 	// the player to name his captain and ship.
@@ -351,15 +330,12 @@ NameCaptainOrShip (bool nameCaptain, boo
 		t.align = ALIGN_CENTER;
 		t.CharCount = (COUNT)~0;
 		
-		if (nameCaptain)
-		{
+		if (nameCaptain) {
 			// "Captain, what is your name?"
 			t.pStr = GAME_STRING (NAMING_STRING_BASE + 4);
 			strcpy (buf,  GAME_STRING (NAMING_STRING_BASE + 3)); // "Zelnick"
 			CursPos = strlen(GAME_STRING (NAMING_STRING_BASE + 3));
-		}
-		else
-		{
+		} else {
 			// "What is the name of your flagship?"
 			t.pStr = GAME_STRING (NAMING_STRING_BASE + 5);
 			strcpy (buf, GAME_STRING (NAMING_STRING_BASE + 2)); // "Vindicator"
@@ -381,17 +357,12 @@ NameCaptainOrShip (bool nameCaptain, boo
 		font_DrawText (&t);
 	}
 
-	
 	SetFlashRect (NULL);
-	UnlockMutex (GraphicsLock);
 
 	DrawNameString (nameCaptain, buf, CursPos, DDSHS_EDIT);
 
-	if (!gamestart)
-	{
-		LockMutex (GraphicsLock);
+	if (!gamestart) {
 		DrawStatusMessage (GAME_STRING (NAMING_STRING_BASE + 0));
-		UnlockMutex (GraphicsLock);
 	}
 
 	if (nameCaptain)
@@ -417,30 +388,24 @@ NameCaptainOrShip (bool nameCaptain, boo
 		utf8StringCopy (Setting, tes.MaxSize, buf);
 	else
 		utf8StringCopy (buf, sizeof (buf), Setting);
-	
-	LockMutex (GraphicsLock);
+
 	SetFlashRect (SFR_MENU_3DO);
-	UnlockMutex (GraphicsLock);
-	
+
 	DrawNameString (nameCaptain, buf, CursPos, DDSHS_NORMAL);
 
 	if (namingCB)
 		namingCB ();
-	
+
 	// JMS: This clears the captain or ship naming prompt.
-	if (gamestart)
-	{
-		LockMutex (GraphicsLock);
+	if (gamestart) {
 		SetContext (ScreenContext);
 		DrawStarConBox (&r, 2,
 			BLACK_COLOR, BLACK_COLOR, TRUE, BLACK_COLOR);
-		UnlockMutex (GraphicsLock);
 	}
 
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
 }
 
-// JMS
 static BOOLEAN
 DrawSaveNameString (UNICODE *Str, COUNT CursorPos, COUNT state, COUNT gameIndex)
 {
@@ -448,9 +413,13 @@ DrawSaveNameString (UNICODE *Str, COUNT
 	TEXT lf;
 	Color BackGround, ForeGround;
 	FONT Font;
-	
-	LockMutex (GraphicsLock);
-	
+	UNICODE fullStr[256], dateStr[80];
+
+	DateToString (dateStr, sizeof dateStr, GLOBAL(GameClock.month_index),
+			GLOBAL(GameClock.day_index), GLOBAL(GameClock.year_index));
+	strncat (dateStr, ": ", sizeof(dateStr) - strlen(dateStr) -1);
+	snprintf (fullStr, sizeof fullStr, "%s%s", dateStr, Str);
+
 	SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x1B, 0x00, 0x1B), 0x33));
 	r.extent.width = 15 << RESOLUTION_FACTOR; // JMS_GFX
 	if (MAX_SAVED_GAMES > 99)
@@ -459,73 +428,75 @@ DrawSaveNameString (UNICODE *Str, COUNT
 	r.corner.x = 8 << RESOLUTION_FACTOR; // JMS_GFX
 	r.corner.y = (160 + ((gameIndex % SAVES_PER_PAGE) * 13)) << RESOLUTION_FACTOR; // JMS_GFX
 	DrawRectangle (&r);
-	
+
 	r.extent.width = (204 - SAFE_X) << RESOLUTION_FACTOR; // JMS_GFX
 	r.corner.x = (30 + SAFE_X) << RESOLUTION_FACTOR; // JMS_GFX
 	DrawRectangle (&r);
-		
+
 	Font = TinyFont;
 	lf.baseline.x = r.corner.x + (3 << RESOLUTION_FACTOR); // JMS_GFX
 	lf.baseline.y = r.corner.y + RES_CASE(8,14,29); // JMS_GFX
-			
+
 	BackGround = BUILD_COLOR (MAKE_RGB15 (0x1B, 0x00, 0x1B), 0x33);
 	ForeGround = BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01);
-		
+
 	lf.align = ALIGN_LEFT;
-	
+
 	SetContextFont (Font);
-	lf.pStr = Str;
+	lf.pStr = fullStr;
 	lf.CharCount = (COUNT)~0;
-	
+
 	if (!(state & DDSHS_EDIT))
-	{	
-		//RECT r;
+	{
 		TEXT t;
-		
+
 		SetContextForeGroundColor (BLACK_COLOR);
 		DrawFilledRectangle (&r);
-		
+
 		t.baseline.x = r.corner.x + (3 << RESOLUTION_FACTOR);
 		t.baseline.y = r.corner.y + (8 << RESOLUTION_FACTOR); // JMS_GFX
 		t.align = ALIGN_LEFT;
-		t.pStr = Global_save_name;
+		t.pStr = Str;
 		t.CharCount = (COUNT)~0;
 		SetContextForeGroundColor (CAPTAIN_NAME_TEXT_COLOR);
-		font_DrawText (&t);
+		font_DrawText (&lf);
 	}
 	else
 	{	// editing state
-		COUNT i;
+		COUNT i, FullCursorPos;
 		RECT text_r;
-		BYTE char_deltas[SAVE_NAME_SIZE];
+		BYTE char_deltas[256];
 		BYTE *pchar_deltas;
-		
+
 		TextRect (&lf, &text_r, char_deltas);
 		if ((text_r.extent.width + 2) >= r.extent.width)
 		{	// the text does not fit the input box size and so
 			// will not fit when displayed later
-			UnlockMutex (GraphicsLock);
 			// disallow the change
 			return (FALSE);
 		}
-		
+
+		PreUpdateFlashRect ();
+
 		SetContextForeGroundColor (BackGround);
 		DrawFilledRectangle (&r);
-		
+
 		pchar_deltas = char_deltas;
-		
-		for (i = CursorPos; i > 0; --i)
+
+		FullCursorPos = CursorPos + strlen(dateStr) - 1;
+		for (i = FullCursorPos; i > 0; --i)
 			text_r.corner.x += *pchar_deltas++;
-		if (CursorPos < lf.CharCount) /* end of line */
+
+		if (FullCursorPos < lf.CharCount) /* end of line */
 			--text_r.corner.x;
-		
+
 		if (state & DDSHS_BLOCKCUR)
 		{	// Use block cursor for keyboardless systems
-			if (CursorPos == lf.CharCount)
+			if (FullCursorPos == lf.CharCount)
 			{	// cursor at end-line -- use insertion point
 				text_r.extent.width = 1;
 			}
-			else if (CursorPos + 1 == lf.CharCount)
+			else if (FullCursorPos + 1 == lf.CharCount)
 			{	// extra pixel for last char margin
 				text_r.extent.width = (SIZE)*pchar_deltas + 2;
 			}
@@ -538,58 +509,45 @@ DrawSaveNameString (UNICODE *Str, COUNT
 		{	// Insertion point cursor
 			text_r.extent.width = 1;
 		}
-		
+
 		text_r.corner.y = r.corner.y;
 		text_r.extent.height = r.extent.height;
 		SetContextForeGroundColor (BLACK_COLOR);
 		DrawFilledRectangle (&text_r);
-		
+
 		SetContextForeGroundColor (ForeGround);
 		font_DrawText (&lf);
-		
-		SetFlashRect (&r);
+		PostUpdateFlashRect ();
 	}
-	
-	UnlockMutex (GraphicsLock);
+
 	return (TRUE);
 }
 
-// JMS
 static BOOLEAN
 OnSaveNameChange (TEXTENTRY_STATE *pTES)
 {
 	COUNT hl = DDSHS_EDIT;
 	COUNT *gameIndex = pTES->CbParam;
-	
+
 	if (pTES->JoystickMode)
 		hl |= DDSHS_BLOCKCUR;
-	
+
 	return DrawSaveNameString (pTES->BaseStr, pTES->CursorPos, hl, *gameIndex);
 }
 
-// JMS
 static BOOLEAN
-NameSaveGame (SUMMARY_DESC *desc, COUNT gameIndex)
+NameSaveGame (COUNT gameIndex, UNICODE *buf)
 {
-	UNICODE buf[SAVE_NAME_SIZE] = "";
 	TEXTENTRY_STATE tes;
-	UNICODE *Setting;
-	COUNT CursPos = 0; // JMS
+	COUNT CursPos = strlen(buf);
 	COUNT *gIndex = HMalloc (sizeof (COUNT));
-	
+	RECT r;
 	*gIndex = gameIndex;
-	
-	if (!(strncmp(desc->SaveNameChecker, SAVE_NAME_CHECKER, SAVE_CHECKER_SIZE)))
-	{
-		strncpy (buf, desc->SaveName, SAVE_NAME_SIZE);
-		CursPos = strlen(desc->SaveName);
-	}
-	
+
 	DrawSaveNameString (buf, CursPos, DDSHS_EDIT, gameIndex);
-	
-	Setting = Global_save_name;
+
 	tes.MaxSize = SAVE_NAME_SIZE;
-	
+
 	// text entry setup
 	tes.Initialized = FALSE;
 	tes.BaseStr = buf;
@@ -597,25 +555,28 @@ NameSaveGame (SUMMARY_DESC *desc, COUNT
 	tes.CbParam = gIndex;
 	tes.ChangeCallback = OnSaveNameChange;
 	tes.FrameCallback = 0;
-	
-	if (DoTextEntrySavename (&tes))
-		utf8StringCopy (Setting, tes.MaxSize, buf);
-	else
-		utf8StringCopy (buf, sizeof (buf), Setting);
-	
+	r.extent.width = (RES_SCALE(204) - SAFE_X);
+	r.extent.height = RES_SCALE(11);
+	r.corner.x = (RES_SCALE(30) + SAFE_X);
+	r.corner.y = (RES_SCALE(160) + ((gameIndex % SAVES_PER_PAGE) * RES_SCALE(13)));
+	SetFlashRect (&r);
+
+	if (!DoTextEntry (&tes))
+		buf[0] = 0;
+
+	SetFlashRect(NULL);
+
 	DrawSaveNameString (buf, CursPos, DDSHS_NORMAL, gameIndex);
 
 	if (namingCB)
 		namingCB ();
-	
+
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
-	
+
 	HFree (gIndex);
-	
-	LockMutex (GraphicsLock);
+
 	SetFlashRect (NULL);
-	UnlockMutex (GraphicsLock);
-	
+
 	if (tes.Success)
 		return (TRUE);
 	else
@@ -623,30 +584,25 @@ NameSaveGame (SUMMARY_DESC *desc, COUNT
 }
 
 // JMS: This is for naming captain and ship at game start.
-void
-AskNameForCaptainAndShip()
+void AskNameForCaptainAndShip(void)
 {
 	// Give sounds for arrows and enter.
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
 
 	// Erase the intro graphics (that are still hidden in the black fade).
-	LockMutex (GraphicsLock);
 	SetContext (ScreenContext);
 	SetContextBackGroundColor (BLACK_COLOR);
 	ClearDrawable ();
 
 	// Enable graphics so the prompt for captain naming will be visible.
 	FadeScreen (FadeAllToColor, ONE_SECOND / 2);
-	UnlockMutex (GraphicsLock);
 	
 	// Name the captain and the ship.
 	NameCaptainOrShip (true, true);
 	NameCaptainOrShip (false, true);
 	
 	// Re-fade to black before loading the first IP graphics.
-	LockMutex (GraphicsLock);
 	FadeScreen (FadeAllToBlack, ONE_SECOND / 2);
-	UnlockMutex (GraphicsLock);
 }
 
 void
@@ -728,9 +684,7 @@ SettingsMenu (void)
 	MenuState.InputFunc = DoSettings;
 	DoInput (&MenuState, FALSE);
 
-	LockMutex (GraphicsLock);
 	DrawStatusMessage (NULL);
-	UnlockMutex (GraphicsLock);
 }
 
 typedef struct
@@ -884,7 +838,7 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 		// Hack StatusContext so we can use standard SIS display funcs
 		GetContextClipRect (&OldRect);
 		r.corner.x = SIS_ORG_X + ((SIS_SCREEN_WIDTH - STATUS_WIDTH) >> 1) +
-			SAFE_X - (16 << RESOLUTION_FACTOR) + SUMMARY_X_OFFS + RES_CASE(0,0,6); // JMS_GFX
+				SAFE_X - (16 << RESOLUTION_FACTOR) + SUMMARY_X_OFFS + RES_CASE(0,0,6); // JMS_GFX
 		r.corner.y = SIS_ORG_Y; // JMS_GFX
 		r.extent.width = STATUS_WIDTH + 2 * RESOLUTION_FACTOR; // JMS_GFX
 		r.extent.height = STATUS_HEIGHT;
@@ -903,7 +857,7 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 		UninitQueue (&GLOBAL (built_ship_q));
 
 		SetContextClipRect (&OldRect);
-		
+
 		SetContext (SpaceContext);
 		// draw devices
 		s.origin.y = 13 << RESOLUTION_FACTOR; // JMS_GFX
@@ -912,7 +866,6 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 			COUNT j;
 
 			s.origin.x = (140 << RESOLUTION_FACTOR) + SUMMARY_X_OFFS + SUMMARY_SIDE_OFFS + RES_CASE(0,10,110); // JMS_GFX
-			
 			for (j = 0; j < 4; ++j)
 			{
 				COUNT devIndex = (i * 4) + j;
@@ -927,10 +880,8 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 			s.origin.y += 18 << RESOLUTION_FACTOR; // JMS_GFX
 		}
 
-		// Placement of the RU and bio-credit amounts.
 		SetContextFont (StarConFont);
 		t.baseline.x = (173 << RESOLUTION_FACTOR) + SUMMARY_X_OFFS + SUMMARY_SIDE_OFFS + RES_CASE(0,15,110); // JMS_GFX
-		
 		t.align = ALIGN_CENTER;
 		t.CharCount = (COUNT)~0;
 		t.pStr = buf;
@@ -957,16 +908,15 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 			r.corner.y = SIS_ORG_Y + (84 << RESOLUTION_FACTOR); // JMS_GFX
 			r.extent = OldRect.extent;
 			SetContextClipRect (&r);
-			UnlockMutex (GraphicsLock);
 			// draw the lander with upgrades
 			InitLander (pSD->Flags | OVERRIDE_LANDER_FLAGS);
-			LockMutex (GraphicsLock);
 			SetContextClipRect (&OldRect);
 			SetContext (SpaceContext);
 
 			snprintf (buf, sizeof buf, "%u", pSD->SS.ResUnits);
 			t.baseline.y = 102 << RESOLUTION_FACTOR; // JMS_GFX
-			SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x10, 0x00, 0x10), 0x01));
+			SetContextForeGroundColor (
+					BUILD_COLOR (MAKE_RGB15 (0x10, 0x00, 0x10), 0x01));
 			font_DrawText (&t);
 			t.CharCount = (COUNT)~0;
 		}
@@ -976,7 +926,7 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 		SetContextForeGroundColor (
 				BUILD_COLOR (MAKE_RGB15 (0x10, 0x00, 0x10), 0x01));
 		font_DrawText (&t);
-		
+
 		// print the location
 		t.baseline.x = 6 << RESOLUTION_FACTOR; // JMS_GFX
 		t.baseline.y = ((139 + 6) << RESOLUTION_FACTOR) + RES_CASE(0,3,0); // JMS_GFX;
@@ -993,7 +943,7 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 			{
 				BYTE QuasiState;
 				STAR_DESC *SDPtr;
-				
+
 				QuasiState = GET_GAME_STATE (ARILOU_SPACE_SIDE);
 				SET_GAME_STATE (ARILOU_SPACE_SIDE, 0);
 				SDPtr = FindStar (NULL, &starPt, 1, 1);
@@ -1045,12 +995,7 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 		}
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
-		
-		// JMS: This can be used to warn the user about bogus savegames.
-		/*if (strncmp(pSD->SaveNameChecker, SAVE_NAME_CHECKER, SAVE_CHECKER_SIZE)
-			&& !(pickState->saving))
-			LoadProblemMessage ();*/
-		
+
 		SetContext (OldContext);
 
 		// Restore the states because we hacked them
@@ -1066,16 +1011,13 @@ DrawGameSelection (PICK_GAME_STATE *pick
 {
 	RECT r;
 	TEXT t;
-	COUNT i;
-	COUNT curSlot;
-	UNICODE buf[256];
-	UNICODE buf2[80];
-	UNICODE *SaveName; // JMS
-	
+	COUNT i, curSlot;
+	UNICODE buf[256], buf2[80], *SaveName;
+
 	BatchGraphics ();
 
 	SetContextFont (TinyFont);
-	
+
 	// Erase the selection menu
 	r.extent.width = 240 << RESOLUTION_FACTOR; // JMS_GFX
 	r.extent.height = 65 << RESOLUTION_FACTOR; // JMS_GFX
@@ -1127,21 +1069,9 @@ DrawGameSelection (PICK_GAME_STATE *pick
 		}
 		else
 		{
-			// JMS: If a savegamename identifier is found, this save
-			// has an user-given name and we can use it.
-			// Otherwise we'll use the default "unnamed save" for this
-			// savegame (it's most probably a save from an older version,
-			// which didn't feature user-given names for saves.)
-			if (!(strncmp(desc->SaveNameChecker, SAVE_NAME_CHECKER, SAVE_CHECKER_SIZE)))
-				SaveName = desc->SaveName;
-			else if (RESOLUTION_FACTOR == 0)
-				SaveName = GAME_STRING (SAVEGAME_STRING_BASE + 5); // "Unnamed save"
-			else
-				SaveName = GAME_STRING (SAVEGAME_STRING_BASE + 6); // "Unnamed save"
-			
 			DateToString (buf2, sizeof buf2, desc->month_index,
 					desc->day_index, desc->year_index);
-			snprintf (buf, sizeof buf, "%s: %s", buf2, SaveName); // JMS
+			snprintf (buf, sizeof buf, "%s: %s", buf2, desc->SaveName[0] ? desc->SaveName : GAME_STRING (SAVEGAME_STRING_BASE + 4));
 		}
 		font_DrawText (&t);
 	}
@@ -1166,7 +1096,7 @@ LoadGameDescriptions (SUMMARY_DESC *pSD)
 
 	for (i = 0; i < MAX_SAVED_GAMES; ++i, ++pSD)
 	{
-		if (!LoadGame (i, pSD, FALSE))
+		if (!LoadGame (i, pSD))
 			pSD->year_index = 0;
 	}
 }
@@ -1192,6 +1122,21 @@ DoPickGame (MENU_STATE *pMS)
 		pSD = &pickState->summary[pMS->CurState];
 		if (pickState->saving || pSD->year_index)
 		{	// valid slot
+			DWORD LoadFuelScaled = loadFuel / FUEL_TANK_SCALE;
+			DWORD TankCapacityScaled = GetFuelTankCapacity() / FUEL_TANK_SCALE;
+
+			if(optInfiniteRU)
+				GLOBAL_SIS (ResUnits) = oldRU;
+
+			if(optInfiniteFuel){
+				if(loadFuel <= GetFuelTankCapacity())
+					GLOBAL_SIS (FuelOnBoard) = loadFuel;
+				else {
+					GLOBAL_SIS (ResUnits) += (LoadFuelScaled - TankCapacityScaled) * GLOBAL (FuelCost);
+					GLOBAL_SIS (FuelOnBoard) = GetFuelTankCapacity();
+				}
+			}
+
 			PlayMenuSound (MENU_SOUND_SUCCESS);
 			pickState->success = TRUE;
 			return FALSE;
@@ -1238,13 +1183,11 @@ DoPickGame (MENU_STATE *pMS)
 
 		if (NewState != pMS->CurState)
 		{
-			LockMutex (GraphicsLock);
 			pMS->CurState = NewState;
 			SetContext (SpaceContext);
 			RedrawPickDisplay (pickState, pMS->CurState);
-			UnlockMutex (GraphicsLock);
 		}
-		
+
 		SleepThreadUntil (TimeIn + ONE_SECOND / 30);
 	}
 
@@ -1255,6 +1198,7 @@ static BOOLEAN
 SaveLoadGame (PICK_GAME_STATE *pickState, COUNT gameIndex, BOOLEAN *canceled_by_user)
 {
 	SUMMARY_DESC *desc = pickState->summary + gameIndex;
+	UNICODE nameBuf[256];
 	STAMP saveStamp;
 	BOOLEAN success;
 
@@ -1262,16 +1206,15 @@ SaveLoadGame (PICK_GAME_STATE *pickState
 
 	if (pickState->saving)
 	{
-		if (NameSaveGame (desc, gameIndex))
-		{			
-			if(optInfiniteRU){
-				GLOBAL_SIS (ResUnits) = oldRU;
-			}
+		// Initialize the save name with whatever name is there already
+		// SAVE_NAME_SIZE is less than 256, so this is safe.
+		strncpy(nameBuf, desc->SaveName, SAVE_NAME_SIZE);
+		nameBuf[SAVE_NAME_SIZE] = 0;
+		if (NameSaveGame (gameIndex, nameBuf))
+		{
 			PlayMenuSound (MENU_SOUND_SUCCESS);
-			LockMutex (GraphicsLock);
 			ConfirmSaveLoad (pickState->saving ? &saveStamp : NULL);
-			UnlockMutex (GraphicsLock);
-			success = SaveGame (gameIndex, desc);
+			success = SaveGame (gameIndex, desc, nameBuf);
 		}
 		else
 		{
@@ -1281,19 +1224,15 @@ SaveLoadGame (PICK_GAME_STATE *pickState
 	}
 	else
 	{
-		LockMutex (GraphicsLock);
 		ConfirmSaveLoad (pickState->saving ? &saveStamp : NULL);
-		UnlockMutex (GraphicsLock);
-		success = LoadGame (gameIndex, NULL, FALSE);
+		success = LoadGame (gameIndex, NULL);
 	}
 
 	// TODO: the same should be done for both save and load if we also
 	//   display a load problem message
 	if (pickState->saving)
 	{	// restore the screen under "SAVING..." message
-		LockMutex (GraphicsLock);
 		DrawStamp (&saveStamp);
-		UnlockMutex (GraphicsLock);
 	}
 
 	DestroyDrawable (ReleaseDrawable (saveStamp.frame));
@@ -1328,12 +1267,10 @@ PickGame (BOOLEAN saving, BOOLEAN fromMa
 
 	LoadGameDescriptions (pickState.summary);
 
-	LockMutex (GraphicsLock);
 	OldContext = SetContext (SpaceContext);
 	// Save the current state of the screen for later restoration
 	DlgStamp = SaveContextFrame (NULL);
 	GetContextClipRect (&DlgRect);
-	UnlockMutex (GraphicsLock);
 
 	SleepThreadUntil (TimeOut);
 	PauseMusic ();
@@ -1341,15 +1278,14 @@ PickGame (BOOLEAN saving, BOOLEAN fromMa
 	FadeMusic (NORMAL_VOLUME, 0);
 
 	// draw the current savegame and fade in
-	LockMutex (GraphicsLock);
 	SetTransitionSource (NULL);
 	BatchGraphics ();
-	
+
 	SetContextBackGroundColor (BLACK_COLOR);
 	ClearDrawable ();
 	RedrawPickDisplay (&pickState, MenuState.CurState);
 	DrawSaveLoad (&pickState);
-	
+
 	if (fromMainMenu)
 	{
 		UnbatchGraphics ();
@@ -1363,16 +1299,16 @@ PickGame (BOOLEAN saving, BOOLEAN fromMa
 		ScreenTransition (3, &ctxRect);
 		UnbatchGraphics ();
 	}
-	UnlockMutex (GraphicsLock);
 
-	SetMenuSounds (MENU_SOUND_ARROWS | MENU_SOUND_PAGEUP | MENU_SOUND_PAGEDOWN, 0);
+	SetMenuSounds (MENU_SOUND_ARROWS | MENU_SOUND_PAGEUP | MENU_SOUND_PAGEDOWN,
+			0);
 	MenuState.InputFunc = DoPickGame;
-	
+
 	// Save/load retry loop
 	while (1)
 	{
 		BOOLEAN canceled_by_user = FALSE;
-		
+
 		pickState.success = FALSE;
 		DoInput (&MenuState, TRUE);
 		if (!pickState.success)
@@ -1390,9 +1326,7 @@ PickGame (BOOLEAN saving, BOOLEAN fromMa
 
 		// reload and redraw everything
 		LoadGameDescriptions (pickState.summary);
-		LockMutex (GraphicsLock);
 		RedrawPickDisplay (&pickState, MenuState.CurState);
-		UnlockMutex (GraphicsLock);
 	}
 
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
@@ -1401,24 +1335,20 @@ PickGame (BOOLEAN saving, BOOLEAN fromMa
 	{	// Load succeeded, signal up the chain
 		GLOBAL (CurrentActivity) |= CHECK_LOAD;
 	}
-	
+
 	if (!(GLOBAL (CurrentActivity) & CHECK_ABORT) &&
 			(saving || (!pickState.success && !fromMainMenu)))
 	{	// Restore previous screen
-		LockMutex (GraphicsLock);
 		SetTransitionSource (&DlgRect);
 		BatchGraphics ();
 		DrawStamp (&DlgStamp);
 		ScreenTransition (3, &DlgRect);
 		UnbatchGraphics ();
-		UnlockMutex (GraphicsLock);
 	}
 
 	DestroyDrawable (ReleaseDrawable (DlgStamp.frame));
 
-	LockMutex (GraphicsLock);
 	SetContext (OldContext);
-	UnlockMutex (GraphicsLock);
 
 	ResumeMusic ();
 
@@ -1446,14 +1376,10 @@ DoGameOptions (MENU_STATE *pMS)
 		{
 			case SAVE_GAME:
 			case LOAD_GAME:
-				LockMutex (GraphicsLock);
 				SetFlashRect (NULL);
-				UnlockMutex (GraphicsLock);
 				if (PickGame (pMS->CurState == SAVE_GAME, FALSE))
 					return FALSE;
-				LockMutex (GraphicsLock);
 				SetFlashRect (SFR_MENU_3DO);
-				UnlockMutex (GraphicsLock);
 				break;
 			case QUIT_GAME:
 				if (ConfirmExit ())
@@ -1495,18 +1421,13 @@ GameOptions (void)
 	MenuState.CurState = SAVE_GAME;
 	DrawMenuStateStrings (PM_SAVE_GAME, MenuState.CurState);
 
-	LockMutex (GraphicsLock);
 	SetFlashRect (SFR_MENU_3DO);
-	UnlockMutex (GraphicsLock);
-	
+
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
 	MenuState.InputFunc = DoGameOptions;
 	DoInput (&MenuState, TRUE);
 
-	LockMutex (GraphicsLock);
 	SetFlashRect (NULL);
-	UnlockMutex (GraphicsLock);
 
 	return !(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD));
 }
-
diff -ruNp src.hd/uqm/gameopt.h src/uqm/gameopt.h
--- src.hd/uqm/gameopt.h	2017-12-29 02:25:52 -0800
+++ src/uqm/gameopt.h	2017-12-29 00:57:45 -0800
@@ -19,14 +19,20 @@
 #include "libs/compiler.h"
 #include "libs/gfxlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern void ConfirmSaveLoad (STAMP *MsgStamp);
 extern BOOLEAN GameOptions (void);
 
 typedef void (NamingCallback) (void);
 extern void SetNamingCallback (NamingCallback *);
-
-// JMS: For naming captain and ship at game start.
 extern void AskNameForCaptainAndShip(void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _GAMEOPT_H */
 
diff -ruNp src.hd/uqm/gamestr.h src/uqm/gamestr.h
--- src.hd/uqm/gamestr.h	2017-12-29 02:25:52 -0800
+++ src/uqm/gamestr.h	2017-12-29 00:57:45 -0800
@@ -25,28 +25,33 @@
 
 #include "libs/strlib.h"
 
-#define STAR_STRING_COUNT       149 // JMS: Was 133. Added 15 QS portals+Arilouhome
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+#define STAR_STRING_COUNT       149
 #define DEVICE_STRING_COUNT      29
 #define CARGO_STRING_COUNT       10
-#define ELEMENTS_STRING_COUNT   134 // JMS: Was 133. Added "Biodata".
+#define ELEMENTS_STRING_COUNT   133
 #define SCAN_STRING_COUNT        56
 #define STAR_NUMBER_COUNT        14
 #define PLANET_NUMBER_COUNT      33
 #define MONTHS_STRING_COUNT      12
-#define FEEDBACK_STRING_COUNT     5 // JMS: Was 2. Added 3 starmap titles.
+#define FEEDBACK_STRING_COUNT     5
 #define STARBASE_STRING_COUNT     5
 #define ENCOUNTER_STRING_COUNT    8
 #define NAVIGATION_STRING_COUNT   6
-#define NAMING_STRING_COUNT       6 // JMS: Was 4. The newgame name queries.
+#define NAMING_STRING_COUNT       6
 #define MELEE_STRING_COUNT        9
-#define SAVEGAME_STRING_COUNT     9 // JMS: Was 5. Added unnamed save stuff.
+#define SAVEGAME_STRING_COUNT     5
 #define OPTION_STRING_COUNT       5
 #define QUITMENU_STRING_COUNT     3
 #define STATUS_STRING_COUNT       6
 #define FLAGSHIP_STRING_COUNT    13
 #define ORBITSCAN_STRING_COUNT   19
 #define MAINMENU_STRING_COUNT    55
-#define NETMELEE_STRING_COUNT    19
+#define NETMELEE_STRING_COUNT    34
+#define BIOLOGICAL_STRING_COUNT  26
 
 enum {
 	STAR_STRING_BASE       = 0,
@@ -71,8 +76,9 @@ enum {
 	ORBITSCAN_STRING_BASE  = FLAGSHIP_STRING_BASE + FLAGSHIP_STRING_COUNT,
 	MAINMENU_STRING_BASE   = ORBITSCAN_STRING_BASE + ORBITSCAN_STRING_COUNT,
 	NETMELEE_STRING_BASE   = MAINMENU_STRING_BASE + MAINMENU_STRING_COUNT,
+	BIOLOGICAL_STRING_BASE = NETMELEE_STRING_BASE + NETMELEE_STRING_COUNT,
 
-	GAMESTR_COUNT          = NETMELEE_STRING_BASE + NETMELEE_STRING_COUNT
+	GAMESTR_COUNT          = BIOLOGICAL_STRING_BASE + BIOLOGICAL_STRING_COUNT
 };
 
 
@@ -82,5 +88,9 @@ extern STRING GameStrings;
 
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _GAMESTR_H */
 
diff -ruNp src.hd/uqm/gendef.c src/uqm/gendef.c
--- src.hd/uqm/gendef.c	2017-12-29 02:25:52 -0800
+++ src/uqm/gendef.c	2017-12-29 00:57:45 -0800
@@ -17,7 +17,6 @@
  */
 
 #include "gendef.h"
-#include "encount.h"
 #include "planets/generate.h"
 
 
@@ -51,8 +50,6 @@ extern GenerateFunctions generateWreckFu
 extern GenerateFunctions generateYehatFunctions;
 extern GenerateFunctions generateZoqFotPikFunctions;
 extern GenerateFunctions generateZoqFotPikScoutFunctions;
-extern GenerateFunctions generateZoqFotPikColony0Functions;
-extern GenerateFunctions generateZoqFotPikColony1Functions;
 
 
 const GenerateFunctions *
@@ -123,10 +120,6 @@ getGenerateFunctions (BYTE Index)
 			return &generateZoqFotPikFunctions;
 		case ZOQ_SCOUT_DEFINED:
 			return &generateZoqFotPikScoutFunctions;
-		case ZOQ_COLONY0_DEFINED:
-			return &generateZoqFotPikColony0Functions;
-		case ZOQ_COLONY1_DEFINED:
-			return &generateZoqFotPikColony1Functions;
 		case YEHAT_DEFINED:
 			return &generateYehatFunctions;
 		case PKUNK_DEFINED:
diff -ruNp src.hd/uqm/gendef.h src/uqm/gendef.h
--- src.hd/uqm/gendef.h	2017-12-29 02:25:52 -0800
+++ src/uqm/gendef.h	2017-12-29 00:57:45 -0800
@@ -4,7 +4,68 @@
 #include "planets/generate.h"
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 const GenerateFunctions *getGenerateFunctions (BYTE Index);
 
+enum
+{
+	SOL_DEFINED = 1,
+	SHOFIXTI_DEFINED,
+	MAIDENS_DEFINED,
+	START_COLONY_DEFINED,
+	SPATHI_DEFINED,
+	ZOQFOT_DEFINED,
+
+	MELNORME0_DEFINED,
+	MELNORME1_DEFINED,
+	MELNORME2_DEFINED,
+	MELNORME3_DEFINED,
+	MELNORME4_DEFINED,
+	MELNORME5_DEFINED,
+	MELNORME6_DEFINED,
+	MELNORME7_DEFINED,
+	MELNORME8_DEFINED,
+
+	TALKING_PET_DEFINED,
+	CHMMR_DEFINED,
+	SYREEN_DEFINED,
+	BURVIXESE_DEFINED,
+	SLYLANDRO_DEFINED,
+	DRUUGE_DEFINED,
+	BOMB_DEFINED,
+	AQUA_HELIX_DEFINED,
+	SUN_DEVICE_DEFINED,
+	TAALO_PROTECTOR_DEFINED,
+	SHIP_VAULT_DEFINED,
+	URQUAN_WRECK_DEFINED,
+	VUX_BEAST_DEFINED,
+	SAMATRA_DEFINED,
+	ZOQ_SCOUT_DEFINED,
+	MYCON_DEFINED,
+	EGG_CASE0_DEFINED,
+	EGG_CASE1_DEFINED,
+	EGG_CASE2_DEFINED,
+	PKUNK_DEFINED,
+	UTWIG_DEFINED,
+	SUPOX_DEFINED,
+	YEHAT_DEFINED,
+	VUX_DEFINED,
+	ORZ_DEFINED,
+	THRADD_DEFINED,
+	RAINBOW_DEFINED,
+	ILWRATH_DEFINED,
+	ANDROSYNTH_DEFINED,
+	MYCON_TRAP_DEFINED
+};
+
+#define UMGAH_DEFINED TALKING_PET_DEFINED
+
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* GENDEF_H */
 
diff -ruNp src.hd/uqm/getchar.c src/uqm/getchar.c
--- src.hd/uqm/getchar.c	2017-12-29 02:25:52 -0800
+++ src/uqm/getchar.c	2017-12-29 00:57:45 -0800
@@ -440,346 +440,3 @@ DoTextEntry (TEXTENTRY_STATE *pTES)
 	return TRUE;
 }
 
-BOOLEAN
-DoTextEntrySavename (TEXTENTRY_STATE *pTES)
-{
-	UniChar ch;
-	UNICODE *pStr;
-	UNICODE *CacheInsPt;
-	int CacheCursorPos;
-	int len;
-	BOOLEAN changed = FALSE;
-	static BOOLEAN giving_first_char = TRUE;
-
-	if (GLOBAL (CurrentActivity) & CHECK_ABORT)
-	{
-		giving_first_char = TRUE;
-		return (FALSE);
-	}
-
-	if (!pTES->Initialized)
-	{	// init basic vars
-		int lwlen;
-
-		pTES->InputFunc = DoTextEntrySavename;
-		pTES->Success = FALSE;
-		pTES->Initialized = TRUE;
-		pTES->JoystickMode = FALSE;
-		pTES->UpperRegister = TRUE;
-	
-		// init insertion point
-		if ((size_t)pTES->CursorPos > utf8StringCount (pTES->BaseStr))
-			pTES->CursorPos = utf8StringCount (pTES->BaseStr);
-		pTES->InsPt = skipUTF8Chars (pTES->BaseStr, pTES->CursorPos);
-
-		// load joystick alphabet
-		pTES->JoyAlphaString = CaptureStringTable (
-				LoadStringTable (JOYSTICK_ALPHA_STRTAB));
-		pTES->JoyAlpha = LoadJoystickAlpha (
-				SetAbsStringTableIndex (pTES->JoyAlphaString, 0),
-				&pTES->JoyAlphaLength);
-		pTES->JoyUpper = LoadJoystickAlpha (
-				SetAbsStringTableIndex (pTES->JoyAlphaString, 1),
-				&pTES->JoyRegLength);
-		pTES->JoyLower = LoadJoystickAlpha (
-				SetAbsStringTableIndex (pTES->JoyAlphaString, 2),
-				&lwlen);
-		if (lwlen != pTES->JoyRegLength)
-		{
-			if (lwlen < pTES->JoyRegLength)
-				pTES->JoyRegLength = lwlen;
-			log_add (log_Warning, "Warning: Joystick upper-lower registers"
-					" size mismatch; using the smallest subset (%d)",
-					pTES->JoyRegLength);
-		}
-
-		pTES->CacheStr = HMalloc (pTES->MaxSize * sizeof (*pTES->CacheStr));
-
-		EnterCharacterMode ();
-		DoInput (pTES, TRUE);
-		ExitCharacterMode ();
-
-		if (pTES->CacheStr)
-			HFree (pTES->CacheStr);
-		if (pTES->JoyLower)
-			HFree (pTES->JoyLower);
-		if (pTES->JoyUpper)
-			HFree (pTES->JoyUpper);
-		if (pTES->JoyAlpha)
-			HFree (pTES->JoyAlpha);
-		DestroyStringTable ( ReleaseStringTable (pTES->JoyAlphaString));
-
-		giving_first_char = TRUE;
-		return pTES->Success;
-	}
-
-	pStr = pTES->InsPt;
-	len = strlen (pStr);
-	// save a copy of string
-	CacheInsPt = pTES->InsPt;
-	CacheCursorPos = pTES->CursorPos;
-	memcpy (pTES->CacheStr, pTES->BaseStr, pTES->MaxSize);
-
-	// process the pending character buffer
-	ch = GetNextCharacter ();
-	if (!ch && PulsedInputState.menu[KEY_MENU_ANY])
-	{	// keyboard repeat, but only when buffer empty
-		ch = GetLastCharacter ();
-	}
-	while (ch)
-	{
-		UNICODE chbuf[8];
-		int chsize;
-
-		pTES->JoystickMode = FALSE;
-
-		chsize = getStringFromChar (chbuf, sizeof (chbuf), ch);
-		if (UniChar_isPrint (ch) && chsize > 0)
-		{
-			if (pStr + len - pTES->BaseStr + chsize < pTES->MaxSize)
-			{	// insert character, when fits
-				memmove (pStr + chsize, pStr, len + 1);
-				memcpy (pStr, chbuf, chsize);
-				pStr += chsize;
-				++pTES->CursorPos;
-				changed = TRUE;
-			}
-			else
-			{	// does not fit
-				PlayMenuSound (MENU_SOUND_FAILURE);
-			}
-			
-			giving_first_char = FALSE;
-		}
-		ch = GetNextCharacter ();
-	}
-
-	if (PulsedInputState.menu[KEY_MENU_DELETE])
-	{
-		if (len)
-		{
-			joy_char_t ch;
-			
-			ReadOneChar (&ch, pStr);
-			memmove (pStr, pStr + ch.len, len - ch.len + 1);
-			len -= ch.len;
-			changed = TRUE;
-		}
-	}
-	else if (PulsedInputState.menu[KEY_MENU_BACKSPACE]&& !giving_first_char)
-	{
-		if (pStr > pTES->BaseStr)
-		{
-			UNICODE *prev = skipUTF8Chars (pTES->BaseStr,
-					pTES->CursorPos - 1);
-			
-			memmove (prev, pStr, len + 1);
-			pStr = prev;
-			--pTES->CursorPos;
-			changed = TRUE;
-		}
-	}
-	else if (PulsedInputState.menu[KEY_MENU_BACKSPACE] && giving_first_char)
-	{
-		while (pStr > pTES->BaseStr)
-		{
-			UNICODE *prev = skipUTF8Chars (pTES->BaseStr,
-					pTES->CursorPos - 1);
-			
-			memmove (prev, pStr, len + 1);
-			pStr = prev;
-			--pTES->CursorPos;
-			changed = TRUE;
-		}
-		giving_first_char = FALSE;
-	}
-	else if (PulsedInputState.menu[KEY_MENU_LEFT])
-	{
-		if (pStr > pTES->BaseStr)
-		{
-			UNICODE *prev = skipUTF8Chars (pTES->BaseStr,
-					pTES->CursorPos - 1);
-
-			pStr = prev;
-			len += (prev - pStr);
-			--pTES->CursorPos;
-			changed = TRUE;
-		}
-		giving_first_char = FALSE;
-	}
-	else if (PulsedInputState.menu[KEY_MENU_RIGHT])
-	{
-		if (len > 0)
-		{
-			joy_char_t ch;
-			
-			ReadOneChar (&ch, pStr);
-			pStr += ch.len;
-			len -= ch.len;
-			++pTES->CursorPos;
-			changed = TRUE;
-		}
-		giving_first_char = FALSE;
-	}
-	else if (PulsedInputState.menu[KEY_MENU_HOME])
-	{
-		if (pStr > pTES->BaseStr)
-		{
-			pStr = pTES->BaseStr;
-			len = strlen (pStr);
-			pTES->CursorPos = 0;
-			changed = TRUE;
-		}
-		giving_first_char = FALSE;
-	}
-	else if (PulsedInputState.menu[KEY_MENU_END])
-	{
-		if (len > 0)
-		{
-			pTES->CursorPos += utf8StringCount (pStr);
-			pStr += len;
-			len = 0;
-			changed = TRUE;
-		}
-		giving_first_char = FALSE;
-	}
-	
-	if (pTES->JoyAlpha && (
-			PulsedInputState.menu[KEY_MENU_UP] ||
-			PulsedInputState.menu[KEY_MENU_DOWN] ||
-			PulsedInputState.menu[KEY_MENU_PAGE_UP] ||
-			PulsedInputState.menu[KEY_MENU_PAGE_DOWN]) )
-	{	// do joystick text
-		joy_char_t ch;
-		joy_char_t newch;
-		joy_char_t cmpch;
-		int i;
-		BOOLEAN curCharUpper;
-
-		pTES->JoystickMode = TRUE;
-
-		if (len)
-		{	// changing an existing character
-			ReadOneChar (&ch, pStr);
-			curCharUpper = !JoyCharIsLower (&ch, pTES);
-		}
-		else
-		{	// adding a new character
-			ch = pTES->JoyAlpha[0];
-			// new characters will have case determined by the
-			// currently selected register
-			curCharUpper = pTES->UpperRegister;
-		}
-		
-		newch = ch;
-		JoyCharToUpper (&cmpch, &ch, pTES);
-
-		// find current char in the alphabet
-		i = JoyCharFindIn (&cmpch, pTES->JoyAlpha, pTES->JoyAlphaLength);
-
-		if (PulsedInputState.menu[KEY_MENU_UP])
-		{
-			--i;
-			if (i < 0)
-				i = pTES->JoyAlphaLength - 1;
-			newch = pTES->JoyAlpha[i];
-		}
-		else if (PulsedInputState.menu[KEY_MENU_DOWN])
-		{
-			++i;
-			if (i >= pTES->JoyAlphaLength)
-				i = 0;
-			newch = pTES->JoyAlpha[i];
-		}
-
-		if (PulsedInputState.menu[KEY_MENU_PAGE_UP] ||
-				PulsedInputState.menu[KEY_MENU_PAGE_DOWN])
-		{
-			if (len)
-			{	// single char change
-				if (!curCharUpper)
-					JoyCharToUpper (&newch, &newch, pTES);
-				else
-					JoyCharToLower (&newch, &newch, pTES);
-			}
-			else
-			{	// register change
-				pTES->UpperRegister = !pTES->UpperRegister;
-			}
-		}
-		else
-		{	// check register
-			if (curCharUpper)
-				JoyCharToUpper (&newch, &newch, pTES);
-			else
-				JoyCharToLower (&newch, &newch, pTES);
-		}
-
-		if (strcmp (newch.enc, ch.enc) != 0)
-		{	// new char is different, put it in
-			if (len)
-			{	// change current -- this is messy with utf8
-				int l = len - ch.len;
-				if (pStr + l - pTES->BaseStr + newch.len < pTES->MaxSize)
-				{
-					// adjust other chars if necessary
-					if (newch.len != ch.len)
-						memmove (pStr + newch.len, pStr + ch.len, l + 1);
-
-					memcpy (pStr, newch.enc, newch.len);
-					len = l + newch.len;
-					changed = TRUE;
-				}
-			}
-			else
-			{	// append
-				if (pStr + len - pTES->BaseStr + newch.len < pTES->MaxSize)
-				{
-					memcpy (pStr, newch.enc, newch.len);
-					pStr[newch.len] = '\0';
-					len += newch.len;
-					changed = TRUE;
-				}
-				else
-				{	// does not fit
-					PlayMenuSound (MENU_SOUND_FAILURE);
-				}
-			}
-		}
-		giving_first_char = FALSE;
-	}
-	
-	if (PulsedInputState.menu[KEY_MENU_SELECT])
-	{	// done entering
-		pTES->Success = TRUE;
-		giving_first_char = TRUE;
-		return FALSE;
-	}
-	else if (PulsedInputState.menu[KEY_MENU_EDIT_CANCEL])
-	{	// canceled entering
-		pTES->Success = FALSE;
-		giving_first_char = TRUE;
-		return FALSE;
-	}
-
-	pTES->InsPt = pStr;
-
-	if (changed && pTES->ChangeCallback)
-	{
-		if (!pTES->ChangeCallback (pTES))
-		{	// changes not accepted - revert
-			memcpy (pTES->BaseStr, pTES->CacheStr, pTES->MaxSize);
-			pTES->InsPt = CacheInsPt;
-			pTES->CursorPos = CacheCursorPos;
-
-			PlayMenuSound (MENU_SOUND_FAILURE);
-		}
-	}
-		
-	if (pTES->FrameCallback)
-		return pTES->FrameCallback (pTES);
-	else
-		SleepThread (ONE_SECOND / 30);
-
-	return TRUE;
-}
\ No newline at end of file
diff -ruNp src.hd/uqm/globdata.c src/uqm/globdata.c
--- src.hd/uqm/globdata.c	2017-12-29 02:25:52 -0800
+++ src/uqm/globdata.c	2017-12-29 00:57:45 -0800
@@ -20,6 +20,7 @@
 
 #include "coderes.h"
 #include "encount.h"
+#include "starmap.h"
 #include "master.h"
 #include "setup.h"
 #include "units.h"
@@ -29,11 +30,13 @@
 #include "build.h"
 #include "state.h"
 #include "grpinfo.h"
-
 #include "gamestr.h"
-#include <stdlib.h>
+#include "libs/scriptlib.h"
 #include "libs/log.h"
 #include "options.h"
+#include <assert.h>
+#include <stdlib.h>
+#include "uqmdebug.h"
 
 static void CreateRadar (void);
 
@@ -41,81 +44,241 @@ CONTEXT RadarContext;
 FRAME PlayFrame;
 
 GLOBDATA GlobData;
-UNICODE Global_save_name[SAVE_NAME_SIZE]; // JMS
 
-static BOOLEAN initedGameStructs = FALSE;
+// Pre: 0 <= bits <= 32
+// This function is necessary because expressions such as '(1 << bits) - 1'
+// or '~(~0 << bits)' may shift by 32 bits, which is undefined (for 32 bits
+// integers). This is not a hypothetical issue; 'uint8_t numBits = 32;
+// printf("%u\n", (1 << numBits));' will return 1 on x86 when compiled with
+// gcc (4.4.3).
+static inline DWORD
+bitmask32 (BYTE bits)
+{
+	return (bits >= 32) ? 0xffffffff : ((1U << bits) - 1);
+}
 
+// Pre: 0 <= bits <= 32
+// This function is necessary because shifting by 32 bits is undefined (for
+// 32 bits integers). This is not a hypothetical issue; 'uint8_t numBits =
+// 32; printf("%u\n", (1 << numBits));' will return 1 on x86 when compiled
+// with gcc (4.4.3).
+static inline DWORD
+shl32 (DWORD value, BYTE shift)
+{
+	return (shift >= 32) ? 0 : (value << shift);
+}
 
-BYTE
-getGameState (int startBit, int endBit)
+// Returns the total number of bits which are needed to store a game state
+// according to 'bm'.
+static size_t
+totalBitsForGameState (const GameStateBitMap *bm)
 {
-	return (BYTE) (((startBit >> 3) == (endBit >> 3)
-			? (GLOBAL (GameState[startBit >> 3]) >> (startBit & 7))
-			: ((GLOBAL (GameState[startBit >> 3]) >> (startBit & 7))
-			  | (GLOBAL (GameState[endBit >> 3])
-			  << (endBit - startBit - (endBit & 7)))))
-			& ((1 << (endBit - startBit + 1)) - 1));
+	size_t totalBits = 0;
+	const GameStateBitMap *bmPtr;
+
+	for (bmPtr = bm; bmPtr->name != NULL; bmPtr++)
+		totalBits += bmPtr->numBits;
+
+	return totalBits;
 }
 
-void
-setGameState (int startBit, int endBit, BYTE val
-#ifdef STATE_DEBUG
-		, const char *name
-#endif
-)
+// Write 'valueBitCount' bits from 'value' into the buffer pointed to
+// by '*bufPtrPtr'.
+// '*restBitsPtr' is used to store the bits in which do not make up
+// a byte yet. The number of bits stored is kept in '*restBitCount'.
+static inline void
+serialiseBits (BYTE **bufPtrPtr, DWORD *restBitsPtr, size_t *restBitCount,
+		BYTE value, size_t valueBitCount)
 {
-	GLOBAL (GameState[startBit >> 3]) =
-			(GLOBAL (GameState[startBit >> 3])
-			& (BYTE) ~(((1 << (endBit - startBit + 1)) - 1) << (startBit & 7)))
-			| (BYTE)((val) << (startBit & 7));
-
-	if ((startBit >> 3) < (endBit >> 3)) {
-		GLOBAL (GameState[endBit >> 3]) =
-				(GLOBAL (GameState[endBit >> 3])
-				& (BYTE)~((1 << ((endBit & 7) + 1)) - 1))
-				| (BYTE)((val) >> (endBit - startBit - (endBit & 7)));
+	BYTE valueBitMask;
+
+	assert (*restBitCount < 8);
+	assert (valueBitCount <= 8);
+
+	valueBitMask = (1 << valueBitCount) - 1;
+
+	// Add the bits from 'value' to the working 'buffer' (*restBits).
+	*restBitsPtr |= (value & valueBitMask) << *restBitCount;
+	*restBitCount += valueBitCount;
+
+	// Write out restBits (possibly partialy), if we have enough bits to
+	// make a byte.
+	if (*restBitCount >= 8)
+	{
+		**bufPtrPtr = *restBitsPtr & 0xff;
+		*restBitsPtr >>= 8;
+		(*bufPtrPtr)++;
+		*restBitCount -= 8;
 	}
-#ifdef STATE_DEBUG
-	log_add (log_Debug, "State '%s' set to %d.", name, (int)val);
-#endif
 }
 
-DWORD
-getGameState32 (int startBit)
+// Serialise the current game state into a newly allocated buffer,
+// according to the GameStateBitMap 'bm'.
+// Only the (integer) values from 'bm' are saved, in the specified order.
+// This function fills in '*buf' with the newly allocated buffer, and
+// '*numBytes' with its size. The caller becomes the owner of '*buf' and
+// is responsible for freeing it.
+BOOLEAN
+serialiseGameState (const GameStateBitMap *bm, BYTE **buf, size_t *numBytes)
 {
-	DWORD v;
-	int shift;
+	size_t totalBits;
+	size_t totalBytes;
+	const GameStateBitMap *bmPtr;
+	BYTE *result;
+	BYTE *bufPtr;
+
+	DWORD restBits = 0;
+			// Bits which have not yet been stored because they did not form
+			// an entire byte.
+	size_t restBitCount = 0;
+
+	// Determine the total number of bits/bytes required.
+	totalBits = totalBitsForGameState (bm);
+	totalBytes = (totalBits + 7) / 8;
+
+	// Allocate memory for the serialised data.
+	result = HMalloc (totalBytes);
+	if (result == NULL)
+		return FALSE;
 
-	for (v = 0, shift = 0; shift < 32; shift += 8, startBit += 8)
+	bufPtr = result;
+	for (bmPtr = bm; bmPtr->name != NULL; bmPtr++)
 	{
-		v |= getGameState (startBit, startBit + 7) << shift;
+		DWORD value = getGameStateUint (bmPtr->name);
+		BYTE numBits = bmPtr->numBits;
+
+#ifdef STATE_DEBUG
+		log_add (log_Debug, "Saving: GameState[\'%s\'] = %u", bmPtr->name,
+				value);
+#endif  /* STATE_DEBUG */
+
+		if (value > bitmask32(numBits))
+		{
+			log_add (log_Error, "Warning: serialiseGameState(): the value "
+					"of the property '%s' (%u) does not fit in the reserved "
+					"number of bits (%d).", bmPtr->name, value, numBits);
+		}
+
+		// Store multi-byte values with the least significant byte first.
+		while (numBits >= 8)
+		{
+		
+			serialiseBits (&bufPtr, &restBits, &restBitCount, value & 0xff, 8);
+			value >>= 8;
+			numBits -= 8;
+		}
+		if (numBits > 0)
+			serialiseBits (&bufPtr, &restBits, &restBitCount, value, numBits);
 	}
 
-	return v;
+	// Pad the end up to a byte.
+	if (restBitCount > 0)
+		serialiseBits (&bufPtr, &restBits, &restBitCount, 0, 8 - restBitCount);
+
+	*buf = result;
+	*numBytes = totalBytes;
+	return TRUE;
 }
 
-void
-setGameState32 (int startBit, DWORD val
-#ifdef STATE_DEBUG
-		, const char *name
-#endif
-)
+// Read 'numBits' bits from '*bytePtr', starting at the bit offset
+// '*bitPtr'. The result is returned.
+// '*bitPtr' and '*bytePtr' are updated by this function.
+static inline DWORD
+deserialiseBits (const BYTE **bytePtr, BYTE *bitPtr, size_t numBits) {
+	assert (*bitPtr < 8);
+	assert (numBits <= 8);
+
+	if (numBits <= (size_t) (8 - *bitPtr))
+	{
+		// Can get the entire value from one byte.
+		// We want bits *bitPtr through (excluding) *bitPtr+numBits
+		DWORD result = ((*bytePtr)[0] >> *bitPtr) & bitmask32(numBits);
+
+		// Update the pointers.
+		if (numBits == (size_t) (8 - *bitPtr))
+		{
+			// The entire (rest of the) byte is read. Go to the next byte.
+			(*bytePtr)++;
+			*bitPtr = 0;
+		}
+		else
+		{
+			// There are still unread bits in the byte.
+			*bitPtr += numBits;
+		}
+		return result;
+	}
+	else
+	{
+		// The result comes from two bytes.
+		// We get the *bitPtr most significant bits from [0], as the least
+		// significant bits of the result, and the (numBits - *bitPtr) least
+		// significant bits from [1], as the most significant bits of the
+		// result.
+		DWORD result = (((*bytePtr)[0] >> *bitPtr)
+				| ((*bytePtr)[1] << (8 - *bitPtr))) &
+				bitmask32(numBits);
+		(*bytePtr)++;
+		*bitPtr += numBits - 8;
+		return result;
+	}
+}
+
+// Deserialise the current game state from the bit array in 'buf', which
+// has size 'numBytes', according to the GameStateBitMap 'bm'.
+BOOLEAN
+deserialiseGameState (const GameStateBitMap *bm,
+		const BYTE *buf, size_t numBytes)
 {
-	DWORD v = val;
-	int i;
+	size_t totalBits;
+	const GameStateBitMap *bmPtr;
 
-	for (i = 0; i < 4; ++i, v >>= 8, startBit += 8)
+	const BYTE *bytePtr = buf;
+	BYTE bitPtr = 0;
+			// Number of bits already processed from the byte pointed at by
+			// bytePtr.
+
+	// Sanity check: determine the number of bits required, and check
+	// whether 'numBytes' is large enough.
+	totalBits = totalBitsForGameState (bm);
+	if (numBytes * 8 < totalBits)
 	{
-		setGameState (startBit, startBit + 7, v & 0xff
-#ifdef STATE_DEBUG
-				, "(ignored)"
-#endif
-				);
+		log_add (log_Error, "Warning: deserialiseGameState(): Corrupt "
+				"save game: state: less bytes available than expected.");
+		return FALSE;
 	}
 
+	for (bmPtr = bm; bmPtr->name != NULL; bmPtr++)
+	{
+		DWORD value = 0;
+		BYTE numBits = bmPtr->numBits;
+		BYTE bitsLeft = numBits;
+
+		// Multi-byte values are stored with the least significant byte
+		// first.
+		while (bitsLeft >= 8)
+		{
+			DWORD bits = deserialiseBits (&bytePtr, &bitPtr, 8);
+			value |= shl32(bits, numBits - bitsLeft);
+			bitsLeft -= 8;
+		}
+		if (bitsLeft > 0) {
+			value |= shl32(deserialiseBits (&bytePtr, &bitPtr, bitsLeft),
+					numBits - bitsLeft);
+		}
+	
+#ifdef STATE_DEBUG
+		log_add (log_Debug, "Loading: GameState[\'%s\'] = %u", bmPtr->name,
+				value);
+#endif  /* STATE_DEBUG */
+
+		setGameStateUint (bmPtr->name, value);
+	}
 #ifdef STATE_DEBUG
-	log_add (log_Debug, "State '%s' set to %u.", name, (unsigned)val);
-#endif
+	fflush (stderr);
+#endif  /* STATE_DEBUG */
+
+	return TRUE;
 }
 
 static void
@@ -159,7 +322,7 @@ LoadSC2Data (void)
 
 	CreateRadar ();
 
-	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+	if (inHQSpace())
 	{
 		GLOBAL (ShipStamp.origin.x) =
 				GLOBAL (ShipStamp.origin.y) = -1;
@@ -176,6 +339,7 @@ copyFleetInfo (FLEET_INFO *dst, SHIP_INF
 	dst->max_crew = src->max_crew;
 	dst->max_energy = src->max_energy;
 
+	dst->shipIdStr = src->idStr;
 	dst->race_strings = src->race_strings;
 	dst->icons = src->icons;
 	dst->melee_icon = src->melee_icon;
@@ -304,7 +468,7 @@ InitGameStructures (void)
 	GLOBAL_SIS (ModuleSlots[8]) = STORAGE_BAY;
 	GLOBAL_SIS (ModuleSlots[1]) = FUEL_TANK;
 	GLOBAL_SIS (FuelOnBoard) = 10 * FUEL_TANK_SCALE;
-
+ 
 	if (optHeadStart){
 		GLOBAL_SIS (ModuleSlots[7]) = STORAGE_BAY;
 		GLOBAL_SIS (ElementAmounts[COMMON]) = 178;
@@ -320,9 +484,7 @@ InitGameStructures (void)
 		SET_GAME_STATE (MOONBASE_DESTROYED, 1);
 	}
 
-	if(optInfiniteRU){
-		oldRU = 0;
-	}
+	loadGameCheats();
 
 	InitQueue (&GLOBAL (built_ship_q),
 			MAX_BUILT_SHIPS, sizeof (SHIP_FRAGMENT));
@@ -354,13 +516,13 @@ InitGameStructures (void)
 			sizeof (GLOBAL_SIS (CommanderName)),
 			GAME_STRING (NAMING_STRING_BASE + 3));
 
-	ActivateStarShip (HUMAN_SHIP, SET_ALLIED);
+	SetRaceAllied (HUMAN_SHIP, TRUE);
 	CloneShipFragment (HUMAN_SHIP, &GLOBAL (built_ship_q), 0);
 
 	if(optHeadStart){
-		ActivateStarShip (SPATHI_SHIP, 1);
+		AddEscortShips (SPATHI_SHIP, 1);
 		/* Make the Eluder escort captained by Fwiffo alone */
-		SetEscortCrewComplement (SPATHI_SHIP, 1, NAME_OFFSET + NUM_CAPTAINS_NAMES);
+		SetEscortCrewComplement (SPATHI_SHIP, 1, NAME_OFFSET + NUM_CAPTAINS_NAMES); // NAME_OFFSET + NUM_CAPTAINS_NAMES = 21 by the way.
 	}
 
 	GLOBAL_SIS (log_x) = UNIVERSE_TO_LOGX (SOL_X);
@@ -368,21 +530,6 @@ InitGameStructures (void)
 	CurStarDescPtr = 0;
 	GLOBAL (autopilot.x) = ~0;
 	GLOBAL (autopilot.y) = ~0;
-	
-	// JMS
-	for (i = 0; i < SAVE_NAME_SIZE ; i++)
-		Global_save_name[i] = 0;
-
-	/* In case the program is exited before the full game is terminated,
-	 * make sure that the temporary files are deleted.
-	 * This can be removed if we make sure if the full game is terminated
-	 * before the game is exited.
-	 * The initedSIS variable is added so the uninit won't happen more
-	 * than once, as you can't remove the atexit function (when the full game
-	 * ends).
-	 */
-	initedGameStructs = TRUE;
-	atexit (UninitGameStructures);
 
 	return (TRUE);
 }
@@ -405,9 +552,6 @@ UninitGameStructures (void)
 {
 	HFLEETINFO hStarShip;
 
-	if (!initedGameStructs)
-		return;
-
 	UninitQueue (&GLOBAL (encounter_q));
 	UninitQueue (&GLOBAL (ip_group_q));
 	UninitQueue (&GLOBAL (npc_built_ship_q));
@@ -435,7 +579,6 @@ UninitGameStructures (void)
 	
 	DestroyDrawable (ReleaseDrawable (PlayFrame));
 	PlayFrame = 0;
-	initedGameStructs = FALSE;
 }
 
 void
@@ -451,4 +594,88 @@ InitGlobData (void)
 }
 
 
+BOOLEAN
+inFullGame (void)
+{
+	ACTIVITY act = LOBYTE (GLOBAL (CurrentActivity));
+	return (act == IN_LAST_BATTLE || act == IN_ENCOUNTER ||
+			act == IN_HYPERSPACE || act == IN_INTERPLANETARY ||
+			act == WON_LAST_BATTLE);
+}
+
+BOOLEAN
+inSuperMelee (void)
+{
+	return (LOBYTE (GLOBAL (CurrentActivity)) == SUPER_MELEE);
+			// TODO: && !inMainMenu ()
+}
+
+#if 0
+BOOLEAN
+inBattle (void)
+{
+	// TODO: IN_BATTLE is also set while in HyperSpace/QuasiSpace.
+	return ((GLOBAL (CurrentActivity) & IN_BATTLE) != 0);
+}
+#endif
+
+#if 0
+// Disabled for now as there are similar functions in uqm/planets/planets.h
+// Pre: inFullGame()
+BOOLEAN
+inInterPlanetary (void)
+{
+	assert (inFullGame ());
+	return (pSolarSysState != NULL);
+}
+
+// Pre: inFullGame()
+BOOLEAN
+inSolarSystem (void)
+{
+	assert (inFullGame ());
+	return (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY);
+}
+
+// Pre: inFullGame()
+BOOLEAN
+inOrbit (void)
+{
+	assert (inFullGame ());
+	return (pSolarSysState != NULL) &&
+			(pSolarSysState->pOrbitalDesc != NULL);
+}
+#endif
+
+// In HyperSpace or QuasiSpace
+// Pre: inFullGame()
+BOOLEAN
+inHQSpace (void)
+{
+	//assert (inFullGame ());
+	return (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE);
+			// IN_HYPERSPACE is also set for QuasiSpace
+}
+
+// In HyperSpace
+// Pre: inFullGame()
+BOOLEAN
+inHyperSpace (void)
+{
+	//assert (inFullGame ());
+	return (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE) &&
+				(GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1);
+			// IN_HYPERSPACE is also set for QuasiSpace
+}
+
+// In QuasiSpace
+// Pre: inFullGame()
+BOOLEAN
+inQuasiSpace (void)
+{
+	//assert (inFullGame ());
+	return (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE) &&
+				(GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1);
+			// IN_HYPERSPACE is also set for QuasiSpace
+}
 
diff -ruNp src.hd/uqm/globdata.h src/uqm/globdata.h
--- src.hd/uqm/globdata.h	2017-12-29 02:25:52 -0800
+++ src/uqm/globdata.h	2017-12-29 00:57:45 -0800
@@ -26,6 +26,12 @@
 #include "sis.h"
 #include "velocity.h"
 #include "commanim.h"
+#include "lua/luastate.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 
 // general numbers-speech generator info
 // should accomodate most common base-10 languages
@@ -199,10 +205,26 @@ enum
 
 #define YEARS_TO_KOHRAH_VICTORY 4
 
+// A structure describing how many bits are used for each game state value.
+typedef struct GameStateBitMap GameStateBitMap;
+struct GameStateBitMap {
+	const char *name;
+	BYTE numBits;
+};
+
+BOOLEAN serialiseGameState (const GameStateBitMap *bm,
+		BYTE **buf, size_t *numBytes);
+BOOLEAN deserialiseGameState (const GameStateBitMap *bm,
+		const BYTE *buf, size_t numBytes);
+
 #define START_GAME_STATE enum {
 #define ADD_GAME_STATE(SName,NumBits) SName, END_##SName = SName + NumBits - 1,
 #define END_GAME_STATE NUM_GAME_STATE_BITS };
 
+// This enum is now only used for the symbolic names, and the comments.
+// XXX: When all the dialogs are moved to Lua scripts, this will become
+// obsolete. Perhaps it would be best to move the comments to
+// content/base/script/initgame/initprops.lua then.
 START_GAME_STATE
 		/* Shofixti states */
 	ADD_GAME_STATE (SHOFIXTI_VISITS, 3)
@@ -282,61 +304,6 @@ START_GAME_STATE
 
 	ADD_GAME_STATE (LANDER_SHIELDS, 4)
 
-	ADD_GAME_STATE (SHOFIXTI_GRPOFFS0, 8)
-	ADD_GAME_STATE (SHOFIXTI_GRPOFFS1, 8)
-	ADD_GAME_STATE (SHOFIXTI_GRPOFFS2, 8)
-	ADD_GAME_STATE (SHOFIXTI_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (ZOQFOT_GRPOFFS0, 8)
-	ADD_GAME_STATE (ZOQFOT_GRPOFFS1, 8)
-	ADD_GAME_STATE (ZOQFOT_GRPOFFS2, 8)
-	ADD_GAME_STATE (ZOQFOT_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (MELNORME0_GRPOFFS0, 8)
-	ADD_GAME_STATE (MELNORME0_GRPOFFS1, 8)
-	ADD_GAME_STATE (MELNORME0_GRPOFFS2, 8)
-	ADD_GAME_STATE (MELNORME0_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (MELNORME1_GRPOFFS0, 8)
-	ADD_GAME_STATE (MELNORME1_GRPOFFS1, 8)
-	ADD_GAME_STATE (MELNORME1_GRPOFFS2, 8)
-	ADD_GAME_STATE (MELNORME1_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (MELNORME2_GRPOFFS0, 8)
-	ADD_GAME_STATE (MELNORME2_GRPOFFS1, 8)
-	ADD_GAME_STATE (MELNORME2_GRPOFFS2, 8)
-	ADD_GAME_STATE (MELNORME2_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (MELNORME3_GRPOFFS0, 8)
-	ADD_GAME_STATE (MELNORME3_GRPOFFS1, 8)
-	ADD_GAME_STATE (MELNORME3_GRPOFFS2, 8)
-	ADD_GAME_STATE (MELNORME3_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (MELNORME4_GRPOFFS0, 8)
-	ADD_GAME_STATE (MELNORME4_GRPOFFS1, 8)
-	ADD_GAME_STATE (MELNORME4_GRPOFFS2, 8)
-	ADD_GAME_STATE (MELNORME4_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (MELNORME5_GRPOFFS0, 8)
-	ADD_GAME_STATE (MELNORME5_GRPOFFS1, 8)
-	ADD_GAME_STATE (MELNORME5_GRPOFFS2, 8)
-	ADD_GAME_STATE (MELNORME5_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (MELNORME6_GRPOFFS0, 8)
-	ADD_GAME_STATE (MELNORME6_GRPOFFS1, 8)
-	ADD_GAME_STATE (MELNORME6_GRPOFFS2, 8)
-	ADD_GAME_STATE (MELNORME6_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (MELNORME7_GRPOFFS0, 8)
-	ADD_GAME_STATE (MELNORME7_GRPOFFS1, 8)
-	ADD_GAME_STATE (MELNORME7_GRPOFFS2, 8)
-	ADD_GAME_STATE (MELNORME7_GRPOFFS3, 8)
-
-	ADD_GAME_STATE (MELNORME8_GRPOFFS0, 8)
-	ADD_GAME_STATE (MELNORME8_GRPOFFS1, 8)
-	ADD_GAME_STATE (MELNORME8_GRPOFFS2, 8)
-	ADD_GAME_STATE (MELNORME8_GRPOFFS3, 8)
-
 	ADD_GAME_STATE (MET_MELNORME, 1)
 	ADD_GAME_STATE (MELNORME_RESCUE_REFUSED, 1)
 	ADD_GAME_STATE (MELNORME_RESCUE_COUNT, 3)
@@ -356,10 +323,6 @@ START_GAME_STATE
 	ADD_GAME_STATE (MELNORME_PISSED_COUNT, 2)
 	ADD_GAME_STATE (MELNORME_HATE_COUNT, 2)
 
-	ADD_GAME_STATE (URQUAN_PROBE_GRPOFFS0, 8)
-	ADD_GAME_STATE (URQUAN_PROBE_GRPOFFS1, 8)
-	ADD_GAME_STATE (URQUAN_PROBE_GRPOFFS2, 8)
-	ADD_GAME_STATE (URQUAN_PROBE_GRPOFFS3, 8)
 	ADD_GAME_STATE (PROBE_MESSAGE_DELIVERED, 1)
 	ADD_GAME_STATE (PROBE_ILWRATH_ENCOUNTER, 1)
 
@@ -376,8 +339,8 @@ START_GAME_STATE
 	ADD_GAME_STATE (MOONBASE_DESTROYED, 1)
 	ADD_GAME_STATE (WILL_DESTROY_BASE, 1)
 
-	ADD_GAME_STATE (ARTIFACT_2_ON_SHIP, 1)
-	ADD_GAME_STATE (ARTIFACT_3_ON_SHIP, 1)
+	ADD_GAME_STATE (WIMBLIS_TRIDENT_ON_SHIP, 1)
+	ADD_GAME_STATE (GLOWING_ROD_ON_SHIP, 1)
 
 	ADD_GAME_STATE (KOHR_AH_KILLED_ALL, 1)
 
@@ -626,6 +589,7 @@ START_GAME_STATE
 	ADD_GAME_STATE (MELNORME_INFO_PROCEDURE, 1)
 
 	ADD_GAME_STATE (MELNORME_TECH_STACK, 4)
+			/* MELNORME_TECH_STACK is now unused */
 	ADD_GAME_STATE (MELNORME_EVENTS_INFO_STACK, 5)
 	ADD_GAME_STATE (MELNORME_ALIEN_INFO_STACK, 5)
 	ADD_GAME_STATE (MELNORME_HISTORY_INFO_STACK, 5)
@@ -656,13 +620,16 @@ START_GAME_STATE
 	ADD_GAME_STATE (UMGAH_BROADCASTERS_ON_SHIP, 1)
 
 	ADD_GAME_STATE (LIGHT_MINERAL_LOAD, 3)
+			/* Number of times the captain has brought in a light mineral
+			 * load (<1000 RU). Max 6. */
 	ADD_GAME_STATE (MEDIUM_MINERAL_LOAD, 3)
+			/* Number of times the captain has brought in a medium mineral
+			 * load (>=1000 RU, <2500 RU). Max 6. */
 	ADD_GAME_STATE (HEAVY_MINERAL_LOAD, 3)
+			/* Number of times the captain has brought in a heavy mineral
+			 * load (>=2500 RU). Max 6. */
 
-	ADD_GAME_STATE (STARBASE_BULLETS0, 8)
-	ADD_GAME_STATE (STARBASE_BULLETS1, 8)
-	ADD_GAME_STATE (STARBASE_BULLETS2, 8)
-	ADD_GAME_STATE (STARBASE_BULLETS3, 8)
+	ADD_GAME_STATE (STARBASE_BULLETS, 32)
 
 	ADD_GAME_STATE (STARBASE_MONTH, 4)
 	ADD_GAME_STATE (STARBASE_DAY, 5)
@@ -673,11 +640,6 @@ START_GAME_STATE
 
 	ADD_GAME_STATE (URQUAN_PROTECTING_SAMATRA, 1)
 
-	ADD_GAME_STATE (COLONY_GRPOFFS0, 8)
-	ADD_GAME_STATE (COLONY_GRPOFFS1, 8)
-	ADD_GAME_STATE (COLONY_GRPOFFS2, 8)
-	ADD_GAME_STATE (COLONY_GRPOFFS3, 8)
-
 #define THRADDASH_BODY_THRESHOLD 25
 	ADD_GAME_STATE (THRADDASH_BODY_COUNT, 5)
 
@@ -697,11 +659,6 @@ START_GAME_STATE
 	ADD_GAME_STATE (ILWRATH_WORSHIP, 2)
 	ADD_GAME_STATE (ILWRATH_FIGHT_THRADDASH, 1)
 
-	ADD_GAME_STATE (SAMATRA_GRPOFFS0, 8)
-	ADD_GAME_STATE (SAMATRA_GRPOFFS1, 8)
-	ADD_GAME_STATE (SAMATRA_GRPOFFS2, 8)
-	ADD_GAME_STATE (SAMATRA_GRPOFFS3, 8)
-
 	ADD_GAME_STATE (READY_TO_CONFUSE_URQUAN, 1)
 	ADD_GAME_STATE (URQUAN_HYPNO_VISITS, 1)
 	ADD_GAME_STATE (MENTIONED_PET_COMPULSION, 1)
@@ -904,6 +861,23 @@ START_GAME_STATE
 	ADD_GAME_STATE (ORZ_STACK0, 1)
 	ADD_GAME_STATE (ORZ_STACK1, 1)
 
+/* These state bits are actually offsets into defgrp.dat. They really
+ * shouldn't be part of the serialized Game State array! --MCM */
+	ADD_GAME_STATE (SHOFIXTI_GRPOFFS, 32)
+	ADD_GAME_STATE (ZOQFOT_GRPOFFS, 32)
+	ADD_GAME_STATE (MELNORME0_GRPOFFS, 32)
+	ADD_GAME_STATE (MELNORME1_GRPOFFS, 32)
+	ADD_GAME_STATE (MELNORME2_GRPOFFS, 32)
+	ADD_GAME_STATE (MELNORME3_GRPOFFS, 32)
+	ADD_GAME_STATE (MELNORME4_GRPOFFS, 32)
+	ADD_GAME_STATE (MELNORME5_GRPOFFS, 32)
+	ADD_GAME_STATE (MELNORME6_GRPOFFS, 32)
+	ADD_GAME_STATE (MELNORME7_GRPOFFS, 32)
+	ADD_GAME_STATE (MELNORME8_GRPOFFS, 32)
+	ADD_GAME_STATE (URQUAN_PROBE_GRPOFFS, 32)
+	ADD_GAME_STATE (COLONY_GRPOFFS, 32)
+	ADD_GAME_STATE (SAMATRA_GRPOFFS, 32)
+
 	// JMS: It is allowed for the autopilot to engage
 	ADD_GAME_STATE (AUTOPILOT_OK, 1)
 
@@ -924,6 +898,7 @@ START_GAME_STATE
 	ADD_GAME_STATE (KNOW_QS_PORTAL_13, 1)
 	ADD_GAME_STATE (KNOW_QS_PORTAL_14, 1)
 	ADD_GAME_STATE (KNOW_QS_PORTAL_15, 1)
+
 END_GAME_STATE
 
 // JMS: For making array of Quasispace portal name flags
@@ -1014,7 +989,7 @@ enum
 	SUPER_MELEE = 0, /* Is also used while in the main menu */
 	IN_LAST_BATTLE,
 	IN_ENCOUNTER,
-	IN_HYPERSPACE /* in Hyperspace or Quasispace */,
+	IN_HYPERSPACE /* in HyperSpace or QuasiSpace */,
 	IN_INTERPLANETARY,
 	WON_LAST_BATTLE,
 
@@ -1026,6 +1001,7 @@ enum
 
 	CHECK_PAUSE = MAKE_WORD (0, (1 << 0)),
 	IN_BATTLE = MAKE_WORD (0, (1 << 1)),
+			/* Is also set while in HyperSpace/QuasiSpace */
 	START_ENCOUNTER = MAKE_WORD (0, (1 << 2)),
 	START_INTERPLANETARY = MAKE_WORD (0, (1 << 3)),
 	CHECK_LOAD = MAKE_WORD (0, (1 << 4)),
@@ -1074,8 +1050,6 @@ typedef struct
 	QUEUE built_ship_q;
 			/* List of SIS escort ships;
 			 * queue element is SHIP_FRAGMENT */
-
-	BYTE GameState[(NUM_GAME_STATE_BITS + 7) >> 3];
 } GAME_STATE;
 
 typedef struct
@@ -1085,48 +1059,41 @@ typedef struct
 } GLOBDATA;
 
 extern GLOBDATA GlobData;
-extern UNICODE Global_save_name[SAVE_NAME_SIZE]; // JMS
 #define GLOBAL(f) GlobData.Game_state.f
 #define GLOBAL_SIS(f) GlobData.SIS_state.f
 
 #define MAX_ENCOUNTERS  16
 #define MAX_BATTLE_GROUPS 32
 
-//#define STATE_DEBUG
-	
-extern BYTE getGameState (int startBit, int endBit);
-extern void setGameState (int startBit, int endBit, BYTE val
-#ifdef STATE_DEBUG
-		, const char *name
-#endif
-		);
-
-#define GET_GAME_STATE(SName) getGameState ((SName), (END_##SName))
-#ifdef STATE_DEBUG
-#	define SET_GAME_STATE(SName, val) \
-			setGameState ((SName), (END_##SName), (val), #SName)
-#else
-#	define SET_GAME_STATE(SName, val) \
-			setGameState ((SName), (END_##SName), (val))
-#endif
+/* DEFGRP enumeration. These identify scripted TrueSpace encounters
+ * more consistently than offsets into the DEFGRPINFO_FILE state
+ * file. */
+enum {
+	DEFGRP_NONE,
+	DEFGRP_SHOFIXTI,
+	DEFGRP_ZOQFOT,
+	DEFGRP_MELNORME0,
+	DEFGRP_MELNORME1,
+	DEFGRP_MELNORME2,
+	DEFGRP_MELNORME3,
+	DEFGRP_MELNORME4,
+	DEFGRP_MELNORME5,
+	DEFGRP_MELNORME6,
+	DEFGRP_MELNORME7,
+	DEFGRP_MELNORME8,
+	DEFGRP_URQUAN_PROBE,
+	DEFGRP_COLONY,
+	DEFGRP_SAMATRA,
+	NUM_DEFGRPS
+};
 
-extern DWORD getGameState32 (int startBit);
-extern void setGameState32 (int startBit, DWORD val
-#ifdef STATE_DEBUG
-		, const char *name
-#endif
-		);
+//#define STATE_DEBUG
 
-#define GET_GAME_STATE_32(SName) getGameState32 ((SName))
-#ifdef STATE_DEBUG
-#	define SET_GAME_STATE_32(SName, val) \
-			setGameState32 ((SName), (val), #SName)
-#else
-#	define SET_GAME_STATE_32(SName, val) \
-			setGameState32 ((SName), (val))
-#endif
+#define SET_GAME_STATE(SName, val) \
+		setGameStateUint (#SName, (val))
+#define GET_GAME_STATE(SName) \
+		getGameStateUint (#SName)
 
-	
 extern CONTEXT RadarContext;
 
 extern void FreeSC2Data (void);
@@ -1134,8 +1101,22 @@ extern BOOLEAN LoadSC2Data (void);
 
 extern void InitGlobData (void);
 
+BOOLEAN inFullGame (void);
+BOOLEAN inSuperMelee (void);
+//BOOLEAN inBattle (void);
+//BOOLEAN inInterPlanetary (void);
+//BOOLEAN inSolarSystem (void);
+//BOOLEAN inOrbit (void);
+BOOLEAN inHQSpace (void);
+BOOLEAN inHyperSpace (void);
+BOOLEAN inQuasiSpace (void);
+
 extern BOOLEAN InitGameStructures (void);
 extern void UninitGameStructures (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _GLOBDATA_H */
 
diff -ruNp src.hd/uqm/gravity.c src/uqm/gravity.c
--- src.hd/uqm/gravity.c	2017-12-29 02:25:52 -0800
+++ src/uqm/gravity.c	2017-12-29 00:57:46 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "collide.h"
 #include "races.h"
 #include "units.h"
diff -ruNp src.hd/uqm/grpinfo.c src/uqm/grpinfo.c
--- src.hd/uqm/grpinfo.c	2017-12-29 02:25:52 -0800
+++ src/uqm/grpinfo.c	2017-12-29 00:57:46 -0800
@@ -17,13 +17,13 @@
  */
 
 #include "build.h"
-// XXX: for CurStarDescPtr and XXX_DEFINED constants
-#include "encount.h"
+#include "starmap.h"
+#include "gendef.h"
 #include "libs/file.h"
 #include "globdata.h"
 #include "intel.h"
 #include "state.h"
-#include "grpinfo.h"
+#include "grpintrn.h"
 
 #include "libs/mathlib.h"
 #include "libs/log.h"
@@ -35,43 +35,8 @@
 static BYTE LastEncGroup;
 		// Last encountered group, saved into state files
 
-//#define DEBUG_GROUPS
-
-// A group header describes battle groups present in a star system. There is
-//    at most 1 group header per system.
-// 'Random' group info file (RANDGRPINFO_FILE) always contains only one
-//    group header record, which describes the last-visited star system,
-//    (which may be the current system). Thus the randomly generated groups
-//    are valid for 7 days (set in PutGroupInfo) after the player leaves 
-//    the system, or until the player enters another star system.
-typedef struct
-{
-	BYTE NumGroups;
-	BYTE day_index, month_index;
-	COUNT star_index, year_index;
-			// day_index, month_index, year_index specify when
-			//   random groups expire (if you were to leave the system
-			//   by going to HSpace and stay there till such time)
-			// star_index is the index of a star this group header
-			//   applies to; ~0 means uninited
-	DWORD GroupOffset[NUM_SAVED_BATTLE_GROUPS + 1];
-			// Absolute offsets of group definitions in a state file
-			// Group 0 is a list of groups present in solarsys
-			//    (RANDGRPINFO_FILE only)
-			// Groups 1..max are definitions of actual battle groups
-			//    containing ship makeup and status
-
-	// Each group has the following format:
-	// 1 byte, RaceType (LastEncGroup in Group 0)
-	// 1 byte, NumShips (NumGroups in Group 0)
-	// Ships follow:
-	// 1 byte, RaceType
-	// 16 bytes, part of SHIP_FRAGMENT struct
-
-} GROUP_HEADER;
-
-static void
-ReadGroupHeader (void *fp, GROUP_HEADER *pGH)
+void
+ReadGroupHeader (GAME_STATE_FILE *fp, GROUP_HEADER *pGH)
 {
 	sread_8   (fp, &pGH->NumGroups);
 	sread_8   (fp, &pGH->day_index);
@@ -82,8 +47,8 @@ ReadGroupHeader (void *fp, GROUP_HEADER
 	sread_a32 (fp, pGH->GroupOffset, NUM_SAVED_BATTLE_GROUPS + 1);
 }
 
-static void
-WriteGroupHeader (void *fp, const GROUP_HEADER *pGH)
+void
+WriteGroupHeader (GAME_STATE_FILE *fp, const GROUP_HEADER *pGH)
 {
 	swrite_8   (fp, pGH->NumGroups);
 	swrite_8   (fp, pGH->day_index);
@@ -94,8 +59,8 @@ WriteGroupHeader (void *fp, const GROUP_
 	swrite_a32 (fp, pGH->GroupOffset, NUM_SAVED_BATTLE_GROUPS + 1);
 }
 
-static void
-ReadShipFragment (void *fp, SHIP_FRAGMENT *FragPtr)
+void
+ReadShipFragment (GAME_STATE_FILE *fp, SHIP_FRAGMENT *FragPtr)
 {
 	BYTE tmpb;
 
@@ -116,8 +81,8 @@ ReadShipFragment (void *fp, SHIP_FRAGMEN
 	sread_16 (fp, NULL); /* unused; was loc.y */
 }
 
-static void
-WriteShipFragment (void *fp, const SHIP_FRAGMENT *FragPtr)
+void
+WriteShipFragment (GAME_STATE_FILE *fp, const SHIP_FRAGMENT *FragPtr)
 {
 	swrite_16 (fp, 0); /* unused: was which_side */
 	swrite_8  (fp, FragPtr->captains_name_index);
@@ -134,8 +99,8 @@ WriteShipFragment (void *fp, const SHIP_
 	swrite_16 (fp, 0); /* unused; was loc.y */
 }
 
-static void
-ReadIpGroup (void *fp, IP_GROUP *GroupPtr)
+void
+ReadIpGroup (GAME_STATE_FILE *fp, IP_GROUP *GroupPtr)
 {
 	BYTE tmpb;
 
@@ -157,8 +122,8 @@ ReadIpGroup (void *fp, IP_GROUP *GroupPt
 	sread_16s(fp, &GroupPtr->loc.y);
 }
 
-static void
-WriteIpGroup (void *fp, const IP_GROUP *GroupPtr)
+void
+WriteIpGroup (GAME_STATE_FILE *fp, const IP_GROUP *GroupPtr)
 {
 	swrite_16 (fp, 0); /* unused; was which_side */
 	swrite_8  (fp, 0); /* unused; was captains_name_index */
@@ -181,7 +146,7 @@ WriteIpGroup (void *fp, const IP_GROUP *
 void
 InitGroupInfo (BOOLEAN FirstTime)
 {
-	void *fp;
+	GAME_STATE_FILE *fp;
 
 	assert (NUM_SAVED_BATTLE_GROUPS >= MAX_BATTLE_GROUPS);
 
@@ -368,11 +333,9 @@ BuildGroups (void)
 					}
 
 					// JMS: No Ur-Quan or Kohr-Ah at Zoqfot home system.
-					if (!(CurStarDescPtr->Index == ZOQFOT_DEFINED
-						  && (FleetPtr->SpeciesID == UR_QUAN_ID
-							  || FleetPtr->SpeciesID == KOHR_AH_ID)))
+					if (!(CurStarDescPtr->Index == ZOQFOT_DEFINED && (FleetPtr->SpeciesID == UR_QUAN_ID || FleetPtr->SpeciesID == KOHR_AH_ID)))
 						BestPercent = i;
-					
+
 					BestIndex = Index;
 				}
 			}
@@ -418,7 +381,7 @@ FoundHome:
 }
 
 static void
-FlushGroupInfo (GROUP_HEADER* pGH, DWORD offset, BYTE which_group, void *fp)
+FlushGroupInfo (GROUP_HEADER* pGH, DWORD offset, BYTE which_group, GAME_STATE_FILE *fp)
 {
 	if (which_group == GROUP_LIST)
 	{
@@ -554,7 +517,7 @@ FlushGroupInfo (GROUP_HEADER* pGH, DWORD
 BOOLEAN
 GetGroupInfo (DWORD offset, BYTE which_group)
 {
-	void *fp;
+	GAME_STATE_FILE *fp;
 	GROUP_HEADER GH;
 
 	if (offset != GROUPS_RANDOM && which_group != GROUP_LIST)
@@ -833,7 +796,7 @@ GetGroupInfo (DWORD offset, BYTE which_g
 DWORD
 PutGroupInfo (DWORD offset, BYTE which_group)
 {
-	void *fp;
+	GAME_STATE_FILE *fp;
 	GROUP_HEADER GH;
 
 	if (offset != GROUPS_RANDOM && which_group != GROUP_LIST)
diff -ruNp src.hd/uqm/grpinfo.h src/uqm/grpinfo.h
--- src.hd/uqm/grpinfo.h	2017-12-29 02:25:52 -0800
+++ src/uqm/grpinfo.h	2017-12-29 00:57:46 -0800
@@ -24,6 +24,10 @@
 		// for POINT
 #include <assert.h>
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 // XXX: Needed to maintain savegame compatibility
 #define NUM_SAVED_BATTLE_GROUPS 64
 
@@ -56,7 +60,6 @@ typedef struct
 	
 	// JMS: direction memory prevents jittering of battle group icons when they change direction they're flying to.
 	BYTE lastDirection;
-	
 } IP_GROUP;
 
 enum
@@ -86,4 +89,8 @@ LockIpGroup (const QUEUE *pq, HIPGROUP h
 
 extern HIPGROUP BuildGroup (QUEUE *pDstQueue, BYTE race_id);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _GRPINFO_H */
diff -ruNp src.hd/uqm/grpintrn.h src/uqm/grpintrn.h
--- src.hd/uqm/grpintrn.h	1969-12-31 16:00:00 -0800
+++ src/uqm/grpintrn.h	2017-12-29 00:57:46 -0800
@@ -0,0 +1,56 @@
+#ifndef _GRPINTRN_H
+#define _GRPINTRN_H
+
+// For IPGROUP
+#include "grpinfo.h"
+
+// For SHIP_FRAGMENT
+#include "races.h"
+
+// For GAME_STATE_FILE
+#include "state.h"
+
+//#define DEBUG_GROUPS
+
+// A group header describes battle groups present in a star system. There is
+//    at most 1 group header per system.
+// 'Random' group info file (RANDGRPINFO_FILE) always contains only one
+//    group header record, which describes the last-visited star system,
+//    (which may be the current system). Thus the randomly generated groups
+//    are valid for 7 days (set in PutGroupInfo) after the player leaves 
+//    the system, or until the player enters another star system.
+typedef struct
+{
+	BYTE NumGroups;
+	BYTE day_index, month_index;
+	COUNT star_index, year_index;
+			// day_index, month_index, year_index specify when
+			//   random groups expire (if you were to leave the system
+			//   by going to HSpace and stay there till such time)
+			// star_index is the index of a star this group header
+			//   applies to; ~0 means uninited
+	DWORD GroupOffset[NUM_SAVED_BATTLE_GROUPS + 1];
+			// Absolute offsets of group definitions in a state file
+			// Group 0 is a list of groups present in solarsys
+			//    (RANDGRPINFO_FILE only)
+			// Groups 1..max are definitions of actual battle groups
+			//    containing ship makeup and status
+
+	// Each group has the following format:
+	// 1 byte, RaceType (LastEncGroup in Group 0)
+	// 1 byte, NumShips (NumGroups in Group 0)
+	// Ships follow:
+	// 1 byte, RaceType
+	// 16 bytes, part of SHIP_FRAGMENT struct 
+        //                  (part of IP_GROUP struct in Group 0)
+
+} GROUP_HEADER;
+
+void ReadGroupHeader (GAME_STATE_FILE *fp, GROUP_HEADER *pGH);
+void WriteGroupHeader (GAME_STATE_FILE *fp, const GROUP_HEADER *pGH);
+void ReadShipFragment (GAME_STATE_FILE *fp, SHIP_FRAGMENT *FragPtr);
+void WriteShipFragment (GAME_STATE_FILE *fp, const SHIP_FRAGMENT *FragPtr);
+void ReadIpGroup (GAME_STATE_FILE *fp, IP_GROUP *GroupPtr);
+void WriteIpGroup (GAME_STATE_FILE *fp, const IP_GROUP *GroupPtr);
+
+#endif
diff -ruNp src.hd/uqm/hyper.c src/uqm/hyper.c
--- src.hd/uqm/hyper.c	2017-12-29 02:25:52 -0800
+++ src/uqm/hyper.c	2017-12-29 00:57:46 -0800
@@ -26,6 +26,7 @@
 #include "menustat.h"
 		// for DrawMenuStateStrings()
 #include "encount.h"
+#include "starmap.h"
 #include "ship.h"
 #include "shipcont.h"
 #include "process.h"
@@ -38,15 +39,18 @@
 #include "setup.h"
 #include "sounds.h"
 #include "options.h"
+#include "libs/gfxlib.h"
 #include "libs/graphics/gfx_common.h"
+#include "libs/graphics/drawable.h"
 #include "libs/mathlib.h"
 #include "libs/log.h"
 
-
 #define XOFFS ((RADAR_SCAN_WIDTH + (UNIT_SCREEN_WIDTH << 2)) >> 1)
 #define YOFFS ((RADAR_SCAN_HEIGHT + (UNIT_SCREEN_HEIGHT << 2)) >> 1)
 
 static FRAME npcbubble;			// BW: animated bubble
+static FRAME quasiportal;       // JMS: animated quasispace portal in hyperspace
+static FRAME Falayalaralfali;        // JMS: Arilou homeworld in quasispace
 static FRAME hyperholes[3];		// BW: One for each flavour of space
 static FRAME hyperstars[4];
 static COLORMAP hypercmaps[2];
@@ -65,11 +69,12 @@ enum HyperMenuItems
 	NAVIGATION,
 };
 
+
 void
 MoveSIS (SDWORD *pdx, SDWORD *pdy)
 {
 	SDWORD new_dx, new_dy;
-	
+
 	new_dx = *pdx;
 	GLOBAL_SIS (log_x) -= new_dx;
 	if (GLOBAL_SIS (log_x) < 0)
@@ -82,7 +87,7 @@ MoveSIS (SDWORD *pdx, SDWORD *pdy)
 		new_dx += (SIZE)(GLOBAL_SIS (log_x) - MAX_X_LOGICAL);
 		GLOBAL_SIS (log_x) = MAX_X_LOGICAL;
 	}
-	
+
 	new_dy = *pdy;
 	GLOBAL_SIS (log_y) -= new_dy;
 	if (GLOBAL_SIS (log_y) < 0)
@@ -95,21 +100,21 @@ MoveSIS (SDWORD *pdx, SDWORD *pdy)
 		new_dy += (SIZE)(GLOBAL_SIS (log_y) - MAX_Y_LOGICAL);
 		GLOBAL_SIS (log_y) = MAX_Y_LOGICAL;
 	}
-	
+
 	if (new_dx != *pdx || new_dy != *pdy)
 	{
 		HELEMENT hElement, hNextElement;
-		
+
 		*pdx = new_dx;
 		*pdy = new_dy;
-		
+
 		for (hElement = GetTailElement ();
-			 hElement != 0; hElement = hNextElement)
+				hElement != 0; hElement = hNextElement)
 		{
 			ELEMENT *ElementPtr;
-			
+
 			LockElement (hElement, &ElementPtr);
-			
+
 			if (!(ElementPtr->state_flags & PLAYER_SHIP))
 				hNextElement = GetPredElement (ElementPtr);
 			else
@@ -118,36 +123,38 @@ MoveSIS (SDWORD *pdx, SDWORD *pdy)
 				ElementPtr->next.location.y = (LOG_SPACE_HEIGHT >> 1) - new_dy;
 				hNextElement = 0;
 			}
-			
+
 			UnlockElement (hElement);
 		}
 	}
-	
+
 	if (GLOBAL_SIS (FuelOnBoard) && GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
 	{
 		COUNT cur_fuel_ticks;
 		COUNT hyper_dist;
 		DWORD adj_dx, adj_dy;
-		
+
 		if (new_dx < 0)
 			new_dx = -new_dx;
 		hyper_dx += new_dx;
 		if (new_dy < 0)
 			new_dy = -new_dy;
 		hyper_dy += new_dy;
-		
+
 		/* These macros are also used in the fuel estimate on the starmap. */
 		adj_dx = LOGX_TO_UNIVERSE(16 * hyper_dx);
 		adj_dy = MAX_Y_UNIVERSE - LOGY_TO_UNIVERSE(16 * hyper_dy);
-		
+
 		hyper_dist = square_root (adj_dx * adj_dx + adj_dy * adj_dy) 
-		+ hyper_extra;
+					+ hyper_extra;
 		cur_fuel_ticks = hyper_dist >> 4;
-		
+
 		if (cur_fuel_ticks > (COUNT)fuel_ticks)
 		{
 #ifndef TESTING
-			DeltaSISGauges (0, fuel_ticks - cur_fuel_ticks, 0);
+			if (!optInfiniteFuel)
+				DeltaSISGauges (0, fuel_ticks - cur_fuel_ticks, 0);
+			
 #endif /* TESTING */
 			if (cur_fuel_ticks > 0x00FF)
 			{
@@ -156,7 +163,7 @@ MoveSIS (SDWORD *pdx, SDWORD *pdy)
 				hyper_dy = 0;
 				cur_fuel_ticks = 0;
 			}
-			
+
 			fuel_ticks = (BYTE)cur_fuel_ticks;
 		}
 	}
@@ -227,13 +234,13 @@ check_hyperspace_encounter (void)
 					encounter_flags = ONE_SHOT_ENCOUNTER;
 				}
 
-
+				// There can be only one! (of either Slylandro or Melnorme)
 				for (hEncounter = GetHeadEncounter ();
 						hEncounter; hEncounter = hNextEncounter)
 				{
 					LockEncounter (hEncounter, &EncounterPtr);
 					hNextEncounter = GetSuccEncounter (EncounterPtr);
-					if (EncounterPtr->SD.Type == Type)
+					if (EncounterPtr->race_id == Type)
 					{
 						percent = 0;
 						hNextEncounter = 0;
@@ -268,8 +275,8 @@ check_hyperspace_encounter (void)
 					memset (EncounterPtr, 0, sizeof (*EncounterPtr));
 					EncounterPtr->origin = FleetPtr->loc;
 					EncounterPtr->radius = encounter_radius;
-					EncounterPtr->SD.Index = encounter_flags;
-					EncounterPtr->SD.Type = Type;
+					EncounterPtr->flags = encounter_flags;
+					EncounterPtr->race_id = Type;
 					UnlockEncounter (hEncounter);
 
 					PutEncounter (hEncounter);
@@ -286,8 +293,7 @@ check_hyperspace_encounter (void)
 void
 FreeHyperData (void)
 {
-	if (RESOLUTION_FACTOR > 0)
-	{
+	if (RESOLUTION_FACTOR > 0) {
 		DestroyDrawable (ReleaseDrawable (hyperholes[1]));
 		hyperholes[1] = 0;
 		DestroyDrawable (ReleaseDrawable (hyperholes[2]));
@@ -297,6 +303,10 @@ FreeHyperData (void)
 		// hyperspacesuns = 0;
 		DestroyDrawable (ReleaseDrawable (npcbubble));
 		npcbubble = 0;
+		DestroyDrawable (ReleaseDrawable (quasiportal));
+		quasiportal = 0;
+		DestroyDrawable (ReleaseDrawable (Falayalaralfali));
+		Falayalaralfali = 0;
 	}
 	
 	DestroyDrawable (ReleaseDrawable (hyperstars[0]));
@@ -317,10 +327,8 @@ FreeHyperData (void)
 static void
 LoadHyperData (void)
 {
-	if (RESOLUTION_FACTOR > 0)
-	{
-		if (hyperholes[1] == 0)
-		{
+	if (RESOLUTION_FACTOR > 0) {
+		if (hyperholes[1] == 0) {
 			hyperholes[1] = CaptureDrawable (
 				LoadGraphic (HYPERHOLES_MASK_PMAP_ANIM));
 			hyperholes[2] = CaptureDrawable (
@@ -329,10 +337,11 @@ LoadHyperData (void)
 				LoadGraphic (ARI_AMBIENT_MASK_PMAP_ANIM));
 		}
 		npcbubble = CaptureDrawable (LoadGraphic (NPCBUBBLE_MASK_PMAP_ANIM));
+		quasiportal = CaptureDrawable (LoadGraphic (QUASIPORTAL_MASK_PMAP_ANIM));
+        Falayalaralfali  = CaptureDrawable (LoadGraphic (FALAYALARALFALI_MASK_PMAP_ANIM));
 	}
 	
-	if (hyperstars[0] == 0)
-	{
+	if (hyperstars[0] == 0) {
 		hyperstars[0] = CaptureDrawable (
 				LoadGraphic (AMBIENT_MASK_PMAP_ANIM));
 		hyperstars[1] = CaptureDrawable (
@@ -363,9 +372,8 @@ LoadHyperspace (void)
 		F = hyperstars[0];
 		hyperstars[0] = stars_in_space;
 		stars_in_space = F;
-		
-		if (RESOLUTION_FACTOR > 0)
-		{
+
+		if (RESOLUTION_FACTOR > 0) {
 			FQ = hyperstars[3];
 			hyperstars[3] = stars_in_quasispace;
 			stars_in_quasispace = FQ;
@@ -423,9 +431,8 @@ FreeHyperspace (void)
 		F = hyperstars[0];
 		hyperstars[0] = stars_in_space;
 		stars_in_space = F;
-		
-		if (RESOLUTION_FACTOR > 0)
-		{
+
+		if (RESOLUTION_FACTOR > 0) {
 			FQ = hyperstars[3];
 			hyperstars[3] = stars_in_quasispace;
 			stars_in_quasispace = FQ;
@@ -510,7 +517,7 @@ InterplanetaryTransition (ELEMENT *Eleme
 		GLOBAL (autopilot.y) = ~0;
 
 		ElementToUniverse (ElementPtr, &pt);
-		CurStarDescPtr = FindStar (NULL, &pt, 5,5);
+		CurStarDescPtr = FindStar (NULL, &pt, 5, 5);
 
 		// JMS: Debugging helpers
 		/*{
@@ -520,13 +527,13 @@ InterplanetaryTransition (ELEMENT *Eleme
 			log_add(log_Debug, "SDPtr.x %d, SDPtr.y %d SDPtr2.x %d, SDPtr2.y %d, pt.x %d pt.y %d", 
 				SDPtr->star_pt.x, SDPtr->star_pt.y, SDPtr2->star_pt.x, SDPtr2->star_pt.y, pt.x, pt.y);
 		}*/
-			
+
 		if (CurStarDescPtr->star_pt.x == ARILOU_HOME_X
 				&& CurStarDescPtr->star_pt.y == ARILOU_HOME_Y)
 		{
 			// Meet the Arilou.
 			GLOBAL (CurrentActivity) |= START_ENCOUNTER;
-			
+
 			// JMS: The arilou homeworld name can now be shown on QS map.
 			SET_GAME_STATE (KNOW_QS_PORTAL_15, 1);
 		}
@@ -536,7 +543,7 @@ InterplanetaryTransition (ELEMENT *Eleme
 			// one of the permanent portals.
 			COUNT index;
 			const POINT portal_pt[] = QUASISPACE_PORTALS_HYPERSPACE_ENDPOINTS;
-			
+
 			index = CurStarDescPtr - &star_array[NUM_SOLAR_SYSTEMS + 1];
 			GLOBAL_SIS (log_x) = UNIVERSE_TO_LOGX (portal_pt[index].x);
 			GLOBAL_SIS (log_y) = UNIVERSE_TO_LOGY (portal_pt[index].y);
@@ -544,7 +551,7 @@ InterplanetaryTransition (ELEMENT *Eleme
 			// JMS: This QS portal's HS coordinates are revealed on QS map
 			// the next time the player visits QS.
 			SET_QS_PORTAL_KNOWN(index);
-			
+
 			SET_GAME_STATE (ARILOU_SPACE_SIDE, 0);
 		}
 	}
@@ -592,6 +599,25 @@ unhyper_transition (ELEMENT *ElementPtr)
 {
 	COUNT frame_index;
 
+	// JMS: If leaving interplanetary on autopilot, always arrive HS with
+	// the ship's nose pointed into correct direction.
+	if ((GLOBAL (autopilot)).x != ~0 && (GLOBAL (autopilot)).y != ~0) {
+		STARSHIP *StarShipPtr;
+		POINT universe;
+		SIZE facing;
+		SDWORD udx = 0, udy = 0;
+			
+		GetElementStarShip (ElementPtr, &StarShipPtr);
+		universe.x = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x));
+		universe.y = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
+		udx = (GLOBAL (autopilot)).x - universe.x;
+		udy = -((GLOBAL (autopilot)).y - universe.y);
+			
+		facing = NORMALIZE_FACING (ANGLE_TO_FACING (ARCTAN (udx, udy)));
+		StarShipPtr->ShipFacing = facing;
+		SetElementStarShip(ElementPtr, StarShipPtr);
+	}
+
 	ElementPtr->state_flags |= CHANGING;
 
 	frame_index = GetFrameIndex (ElementPtr->current.image.frame);
@@ -651,7 +677,7 @@ init_transition (ELEMENT *ElementPtr0, E
 			- StarShipPtr->ShipFacing);
 	if (num_turns == 0)
 		num_turns = 1;
-	
+
 	SetVelocityComponents (&ElementPtr1->velocity,
 			dx / num_turns, dy / num_turns);
 }
@@ -686,11 +712,10 @@ hyper_transition (ELEMENT *ElementPtr)
 	else
 	{
 		COUNT frame_index;
-
+		
 		// JMS: If leaving interplanetary on autopilot, always arrive HS with
 		// the ship's nose pointed into correct direction.
-		if ((GLOBAL (autopilot)).x != ~0 && (GLOBAL (autopilot)).y != ~0)
-		{
+		if ((GLOBAL (autopilot)).x != ~0 && (GLOBAL (autopilot)).y != ~0) {
 			STARSHIP *StarShipPtr;
 			POINT universe;
 			SIZE facing;
@@ -756,8 +781,9 @@ hyper_collision (ELEMENT *ElementPtr0, P
 		STARSHIP *StarShipPtr;
 
 		ElementToUniverse (ElementPtr0, &pt);
+
 		SDPtr = FindStar (NULL, &pt, 5, 5);
-		
+
 		GetElementStarShip (ElementPtr1, &StarShipPtr);
 		GetCurrentVelocityComponents (&ElementPtr1->velocity, &dx, &dy);
 		if (SDPtr == CurStarDescPtr
@@ -776,7 +802,7 @@ hyper_collision (ELEMENT *ElementPtr0, P
 		{
 			CurStarDescPtr = SDPtr;
 			ElementPtr0->state_flags |= COLLISION;
-			
+
 			init_transition (ElementPtr0, ElementPtr1,
 					INTERPLANETARY_TRANSITION);
 		}
@@ -839,7 +865,7 @@ arilou_space_collision (ELEMENT *Element
 }
 
 static HELEMENT
-AllocHyperElement (STAR_DESC *SDPtr)
+AllocHyperElement (const POINT *elem_pt)
 {
 	HELEMENT hHyperSpaceElement;
 
@@ -857,11 +883,11 @@ AllocHyperElement (STAR_DESC *SDPtr)
 		{
 			long lx, ly;
 
-			lx = UNIVERSE_TO_LOGX (SDPtr->star_pt.x)
+			lx = UNIVERSE_TO_LOGX (elem_pt->x)
 					+ (LOG_SPACE_WIDTH >> 1) - GLOBAL_SIS (log_x);
 			HyperSpaceElementPtr->current.location.x = WRAP_X (lx);
 
-			ly = UNIVERSE_TO_LOGY (SDPtr->star_pt.y)
+			ly = UNIVERSE_TO_LOGY (elem_pt->y)
 					+ (LOG_SPACE_HEIGHT >> 1) - GLOBAL_SIS (log_y);
 			HyperSpaceElementPtr->current.location.y = WRAP_Y (ly);
 		}
@@ -891,22 +917,21 @@ AddAmbientElement (void)
 
 		LockElement (hHyperSpaceElement, &HyperSpaceElementPtr);
 		HyperSpaceElementPtr->playerNr = NEUTRAL_PLAYER_NUM;
-		HyperSpaceElementPtr->state_flags = APPEARING | FINITE_LIFE | NONSOLID;
-		SetPrimType (&DisplayArray[HyperSpaceElementPtr->PrimIndex], STAMP_PRIM);
+		HyperSpaceElementPtr->state_flags =
+				APPEARING | FINITE_LIFE | NONSOLID;
+		SetPrimType (&DisplayArray[HyperSpaceElementPtr->PrimIndex],
+				STAMP_PRIM);
 		HyperSpaceElementPtr->preprocess_func = animation_preprocess;
 
 		rand_val = TFB_Random ();
 		dy = LOWORD (rand_val);
 		
 		// JMS_GFX
-		if (RESOLUTION_FACTOR == 0)
-		{
+		if (RESOLUTION_FACTOR == 0) {
 			dx = (SIZE)(LOBYTE (dy) % SPACE_WIDTH) - (SPACE_WIDTH >> 1);
 			dy = (SIZE)(HIBYTE (dy) % SPACE_HEIGHT) - (SPACE_HEIGHT >> 1);
 			HyperSpaceElementPtr->current.image.farray = &stars_in_space;
-		}
-		else
-		{
+		} else {
 			dx = (SIZE)((HIWORD (rand_val)) % SPACE_WIDTH) - (SPACE_WIDTH >> 1);
 			dy = (SIZE)(dy % SPACE_HEIGHT) - (SPACE_HEIGHT >> 1);
 			
@@ -968,12 +993,10 @@ encounter_transition (ELEMENT *ElementPt
 			f = IncFrameIndex (ElementPtr->current.image.frame);
 			if (f != ElementPtr->current.image.farray[0])
 				ElementPtr->next.image.frame = f;
-			else
-			{
-				ElementPtr->death_func = NULL;
+			else {
+ 				ElementPtr->death_func = NULL;
 				// BW: the bubble has reached full size so we start animation
-				if (RESOLUTION_FACTOR > 0)
-				{
+				if (RESOLUTION_FACTOR > 0) {
 					ElementPtr->current.image.farray = &npcbubble;
 					ElementPtr->next.image.farray = &npcbubble;
 					ElementPtr->current.image.frame = SetAbsFrameIndex(npcbubble, 0);
@@ -1059,25 +1082,25 @@ AddEncounterElement (ENCOUNTER *Encounte
 {
 	BOOLEAN NewEncounter;
 	HELEMENT hElement;
-	STAR_DESC SD;
+	POINT enc_pt;
 	
 	if (GET_GAME_STATE (ARILOU_SPACE_SIDE) >= 2)
 		return 0;
 
-	if (EncounterPtr->SD.Index & ENCOUNTER_REFORMING)
+	if (EncounterPtr->flags & ENCOUNTER_REFORMING)
 	{
-		EncounterPtr->SD.Index &= ~ENCOUNTER_REFORMING;
+		EncounterPtr->flags &= ~ENCOUNTER_REFORMING;
 
 		EncounterPtr->transition_state = 100;
-		if ((EncounterPtr->SD.Index & ONE_SHOT_ENCOUNTER)
-				|| LONIBBLE (EncounterPtr->SD.Index) == 0)
+		if ((EncounterPtr->flags & ONE_SHOT_ENCOUNTER)
+				|| EncounterPtr->num_ships == 0)
 			return 0;
 	}
 
-	if (LONIBBLE (EncounterPtr->SD.Index))
+	if (EncounterPtr->num_ships)
 	{
 		NewEncounter = FALSE;
-		SD.star_pt = EncounterPtr->SD.star_pt;
+		enc_pt = EncounterPtr->loc_pt;
 	}
 	else
 	{
@@ -1095,7 +1118,7 @@ AddEncounterElement (ENCOUNTER *Encounte
 
 		radius_squared = (DWORD)EncounterPtr->radius * EncounterPtr->radius;
 
-		Type = EncounterPtr->SD.Type;
+		Type = EncounterPtr->race_id;
 		NumShips = LONIBBLE (EncounterMakeup[Type]);
 		for (i = HINIBBLE (EncounterMakeup[Type]) - NumShips; i; --i)
 		{
@@ -1106,9 +1129,7 @@ AddEncounterElement (ENCOUNTER *Encounte
 		if (NumShips > MAX_HYPER_SHIPS)
 			NumShips = MAX_HYPER_SHIPS;
 
-
-		EncounterPtr->SD.Index =
-				MAKE_BYTE (NumShips, HINIBBLE (EncounterPtr->SD.Index));
+		EncounterPtr->num_ships = NumShips;
 		for (i = 0; i < NumShips; ++i)
 		{
 			BRIEF_SHIP_INFO *BSIPtr = &EncounterPtr->ShipList[i];
@@ -1129,29 +1150,29 @@ AddEncounterElement (ENCOUNTER *Encounte
 
 			rand_val = TFB_Random ();
 
-			SD.star_pt.x = puniverse->x
+			enc_pt.x = puniverse->x
 					+ (LOWORD (rand_val) % (XOFFS << 1)) - XOFFS;
-			if (SD.star_pt.x < 0)
-				SD.star_pt.x = 0;
-			else if (SD.star_pt.x > MAX_X_UNIVERSE)
-				SD.star_pt.x = MAX_X_UNIVERSE;
-			SD.star_pt.y = puniverse->y
+			if (enc_pt.x < 0)
+				enc_pt.x = 0;
+			else if (enc_pt.x > MAX_X_UNIVERSE)
+				enc_pt.x = MAX_X_UNIVERSE;
+			enc_pt.y = puniverse->y
 					+ (HIWORD (rand_val) % (YOFFS << 1)) - YOFFS;
-			if (SD.star_pt.y < 0)
-				SD.star_pt.y = 0;
-			else if (SD.star_pt.y > MAX_Y_UNIVERSE)
-				SD.star_pt.y = MAX_Y_UNIVERSE;
+			if (enc_pt.y < 0)
+				enc_pt.y = 0;
+			else if (enc_pt.y > MAX_Y_UNIVERSE)
+				enc_pt.y = MAX_Y_UNIVERSE;
 
-			dx = SD.star_pt.x - EncounterPtr->origin.x;
-			dy = SD.star_pt.y - EncounterPtr->origin.y;
+			dx = enc_pt.x - EncounterPtr->origin.x;
+			dy = enc_pt.y - EncounterPtr->origin.y;
 		} while ((DWORD)((long)dx * dx + (long)dy * dy) > radius_squared);
 
-		EncounterPtr->SD.star_pt = SD.star_pt;
-		EncounterPtr->log_x = UNIVERSE_TO_LOGX (SD.star_pt.x);
-		EncounterPtr->log_y = UNIVERSE_TO_LOGY (SD.star_pt.y);
+		EncounterPtr->loc_pt = enc_pt;
+		EncounterPtr->log_x = UNIVERSE_TO_LOGX (enc_pt.x);
+		EncounterPtr->log_y = UNIVERSE_TO_LOGY (enc_pt.y);
 	}
 
-	hElement = AllocHyperElement (&SD);
+	hElement = AllocHyperElement (&enc_pt);
 	if (hElement)
 	{
 		SIZE i;
@@ -1176,22 +1197,19 @@ AddEncounterElement (ENCOUNTER *Encounte
 		}
 		else
 		{
-			if (RESOLUTION_FACTOR > 0)
-			{
+			if (RESOLUTION_FACTOR > 0) {
 				ElementPtr->current.image.farray = &npcbubble;
 				ElementPtr->next.image.farray = &npcbubble;
 				ElementPtr->current.image.frame = SetAbsFrameIndex(npcbubble, 0);
 				ElementPtr->next.image.frame = SetAbsFrameIndex(npcbubble, 0);
-			}
-			else
-			{
+			} else {
 				ElementPtr->current.image.frame = DecFrameIndex (ElementPtr->current.image.farray[0]);
 			}
 		}
 
 		ElementPtr->turn_wait = VORTEX_WAIT;
 		ElementPtr->preprocess_func = NULL;
-		ElementPtr->postprocess_func = NULL;
+		ElementPtr->postprocess_func = NULL; // decorate_vortex;
 		ElementPtr->collision_func = encounter_collision;
 
 		SetUpElement (ElementPtr);
@@ -1263,7 +1281,7 @@ DrawHyperGrid (COORD ux, COORD uy, COORD
 	}
 }
 
-// Returns false if the encounter is to be removed.
+// Returns false iff the encounter is to be removed.
 static bool
 ProcessEncounter (ENCOUNTER *EncounterPtr, POINT *puniverse,
 		COORD ox, COORD oy, STAMP *stamp)
@@ -1314,8 +1332,8 @@ ProcessEncounter (ENCOUNTER *EncounterPt
 			cur_facing = ANGLE_TO_FACING (
 					GetVelocityTravelAngle (&ElementPtr->velocity));
 			delta_facing = NORMALIZE_FACING (cur_facing - ANGLE_TO_FACING (
-					ARCTAN (puniverse->x - EncounterPtr->SD.star_pt.x,
-					puniverse->y - EncounterPtr->SD.star_pt.y)));
+					ARCTAN (puniverse->x - EncounterPtr->loc_pt.x,
+					puniverse->y - EncounterPtr->loc_pt.y)));
 			if (delta_facing || (delta_x == 0 && delta_y == 0))
 			{
 				SIZE speed;
@@ -1325,7 +1343,7 @@ ProcessEncounter (ENCOUNTER *EncounterPt
 				};
 
 #define ENCOUNTER_TRACK_WAIT 3
-				speed = RaceHyperSpeed[EncounterPtr->SD.Type];
+				speed = RaceHyperSpeed[EncounterPtr->race_id];
 				if (delta_facing < ANGLE_TO_FACING (HALF_CIRCLE))
 					--cur_facing;
 				else
@@ -1350,18 +1368,18 @@ ProcessEncounter (ENCOUNTER *EncounterPt
 		}
 		EncounterPtr->log_x += delta_x;
 		EncounterPtr->log_y -= delta_y;
-		EncounterPtr->SD.star_pt.x = LOGX_TO_UNIVERSE (EncounterPtr->log_x);
-		EncounterPtr->SD.star_pt.y = LOGY_TO_UNIVERSE (EncounterPtr->log_y);
+		EncounterPtr->loc_pt.x = LOGX_TO_UNIVERSE (EncounterPtr->log_x);
+		EncounterPtr->loc_pt.y = LOGY_TO_UNIVERSE (EncounterPtr->log_y);
 
 		// BW: Animate the NPC bubble in hi-res modes.
 		if (RESOLUTION_FACTOR > 0)
 			ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->current.image.frame);
-		
+
 		encounter_radius = EncounterPtr->radius + (GRID_OFFSET >> 1);
-		delta_x = EncounterPtr->SD.star_pt.x - EncounterPtr->origin.x;
+		delta_x = EncounterPtr->loc_pt.x - EncounterPtr->origin.x;
 		if (delta_x < 0)
 			delta_x = -delta_x;
-		delta_y = EncounterPtr->SD.star_pt.y - EncounterPtr->origin.y;
+		delta_y = EncounterPtr->loc_pt.y - EncounterPtr->origin.y;
 		if (delta_y < 0)
 			delta_y = -delta_y;
 		if ((COUNT)delta_x >= encounter_radius
@@ -1369,6 +1387,7 @@ ProcessEncounter (ENCOUNTER *EncounterPt
 				|| (DWORD)delta_x * delta_x + (DWORD)delta_y * delta_y >=
 				(DWORD)encounter_radius * encounter_radius)
 		{
+			// Encounter globe traveled outside the SoI and now disappears
 			ElementPtr->state_flags |= NONSOLID;
 			ElementPtr->life_span = 0;
 
@@ -1387,8 +1406,8 @@ ProcessEncounter (ENCOUNTER *EncounterPt
 		}
 	}
 
-	ex = EncounterPtr->SD.star_pt.x;
-	ey = EncounterPtr->SD.star_pt.y;
+	ex = EncounterPtr->loc_pt.x;
+	ey = EncounterPtr->loc_pt.y;
 	if (ex - puniverse->x >= -UNIT_SCREEN_WIDTH
 			&& ex - puniverse->x <= UNIT_SCREEN_WIDTH
 			&& ey - puniverse->y >= -UNIT_SCREEN_HEIGHT
@@ -1416,10 +1435,8 @@ ProcessEncounter (ENCOUNTER *EncounterPt
 	else
 	{
 		ElementPtr->state_flags |= NONSOLID;
-		if (ex - puniverse->x < -XOFFS 
-				|| ex - puniverse->x > XOFFS
-				|| ey - puniverse->y < -YOFFS 
-				|| ey - puniverse->y > YOFFS)
+		if (ex - puniverse->x < -XOFFS || ex - puniverse->x > XOFFS
+				|| ey - puniverse->y < -YOFFS || ey - puniverse->y > YOFFS)
 		{
 			ElementPtr->life_span = 0;
 			ElementPtr->death_func = NULL;
@@ -1433,7 +1450,8 @@ ProcessEncounter (ENCOUNTER *EncounterPt
 	UnlockElement (EncounterPtr->hElement);
 		
 	stamp->origin.x = (COORD)((long)ex * RADAR_WIDTH / RADAR_SCAN_WIDTH) - ox;
-	stamp->origin.y = (COORD)((long)(MAX_Y_UNIVERSE - ey) * RADAR_HEIGHT / RADAR_SCAN_HEIGHT) - oy;
+	stamp->origin.y = (COORD)((long)(MAX_Y_UNIVERSE - ey) * RADAR_HEIGHT
+			/ RADAR_SCAN_HEIGHT) - oy;
 	DrawStamp (stamp);
 
 	return true;
@@ -1468,6 +1486,7 @@ ProcessEncounters (POINT *puniverse, COO
 
 #define NUM_HOLES_FRAMES 32 // BW
 #define NUM_SUNS_FRAMES 32 // BW
+#define NUM_QUASIPORTAL_IN_HS_FRAMES 30 // JMS
 
 void
 SeedUniverse (void)
@@ -1481,6 +1500,7 @@ SeedUniverse (void)
 	STAR_DESC *SDPtr;
 	HELEMENT hHyperSpaceElement;
 	ELEMENT *HyperSpaceElementPtr;
+
 	static COUNT frameCounter; // BW
 	
 	frameCounter++; // BW
@@ -1607,17 +1627,34 @@ SeedUniverse (void)
 				ey = -ey;
 
 			if (ex > (XOFFS / NUM_RADAR_SCREENS)
-					|| ey > (YOFFS / NUM_RADAR_SCREENS))
-				continue;
+				|| ey > (YOFFS / NUM_RADAR_SCREENS))
+			continue;
 
-			hHyperSpaceElement = AllocHyperElement (&SD[i]);
+			hHyperSpaceElement = AllocHyperElement (&SD[i].star_pt);
 			if (hHyperSpaceElement == 0)
 				continue;
 
 			LockElement (hHyperSpaceElement, &HyperSpaceElementPtr);
-			HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (
+			if (RESOLUTION_FACTOR == 0
+				|| (SD[i].Index < 22 && arilouSpaceSide <= 1)
+				|| (SD[i].Index < 4 && arilouSpaceSide > 1))
+			{
+				// The QS portal is still growing (Or when playing in 1x resolution).
+				HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (
 					hyperstars[1 + (GET_GAME_STATE (ARILOU_SPACE_SIDE) >> 1)],
 					SD[i].Index);
+			} else if (arilouSpaceSide > 1) {
+				// QS. The QS portal has done its growing animation: in 2x and 4x res switch to the full-size anim.
+				HyperSpaceElementPtr->current.image.frame =
+					SetAbsFrameIndex (quasiportal, frameCounter % NUM_HOLES_FRAMES);
+				HyperSpaceElementPtr->current.image.farray = &hyperholes[2];
+			} else {
+				// HS. The QS portal has done its growing animation: in 2x and 4x res switch to the full-size anim.
+				HyperSpaceElementPtr->current.image.frame =
+					SetAbsFrameIndex (quasiportal, frameCounter % NUM_QUASIPORTAL_IN_HS_FRAMES);
+				HyperSpaceElementPtr->current.image.farray = &quasiportal;
+			}
+
 			HyperSpaceElementPtr->preprocess_func = NULL;
 			HyperSpaceElementPtr->postprocess_func = NULL;
 			HyperSpaceElementPtr->collision_func = arilou_space_collision;
@@ -1645,7 +1682,7 @@ SeedUniverse (void)
 		{
 			BYTE star_type;
 			int which_spaces_star_gfx;
-			
+
 			ex = SDPtr->star_pt.x - universe.x;
 			if (ex < 0)
 				ex = -ex;
@@ -1653,14 +1690,13 @@ SeedUniverse (void)
 			if (ey < 0)
 				ey = -ey;
 			if (ex > (XOFFS / NUM_RADAR_SCREENS)
-				|| ey > (YOFFS / NUM_RADAR_SCREENS))
+					|| ey > (YOFFS / NUM_RADAR_SCREENS))
 				continue;
-			
+
 			star_type = SDPtr->Type;
-			
-			if (RESOLUTION_FACTOR == 0)
-			{
-				hHyperSpaceElement = AllocHyperElement (SDPtr);
+
+			if (RESOLUTION_FACTOR == 0) {
+				hHyperSpaceElement = AllocHyperElement (&SDPtr->star_pt);
 				if (hHyperSpaceElement == 0)
 					continue;
 				
@@ -1670,7 +1706,7 @@ SeedUniverse (void)
 				HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (
 					hyperstars[which_spaces_star_gfx],
 					STAR_TYPE (star_type) * NUM_STAR_COLORS
-					 + STAR_COLOR (star_type));
+					+ STAR_COLOR (star_type));
 				
 				HyperSpaceElementPtr->preprocess_func = NULL;
 				HyperSpaceElementPtr->postprocess_func = NULL;
@@ -1690,16 +1726,14 @@ SeedUniverse (void)
 				UnlockElement (hHyperSpaceElement);
 				
 				InsertElement (hHyperSpaceElement, GetHeadElement ());
-			}
-			else
-			{
+			} else {
 				// BW: first the actual star
 				if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1 
 					|| ((GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1) && STAR_COLOR (star_type) == YELLOW_BODY))
 				{
-					hHyperSpaceElement = AllocHyperElement (SDPtr);
+					hHyperSpaceElement = AllocHyperElement (&SDPtr->star_pt);
 					if (hHyperSpaceElement == 0)
-					continue;
+						continue;
 				
 					LockElement (hHyperSpaceElement, &HyperSpaceElementPtr);
 				
@@ -1719,13 +1753,11 @@ SeedUniverse (void)
 					// JMS_GFX: Draw Arilou homeworld in quasispace.
 					else if ((GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1) && STAR_COLOR (star_type) == YELLOW_BODY)
 					{
-						HyperSpaceElementPtr->current.image.frame = 
-						SetAbsFrameIndex (hyperstars[2], 5);
-					
-						HyperSpaceElementPtr->current.image.farray = &hyperstars[2];
-						HyperSpaceElementPtr->death_func = hyper_death;
+						// JMS_GFX: Draw Arilou homeworld in quasispace | Serosis: Draw *animated* Arilou homeworld
+						HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (Falayalaralfali, frameCounter % NUM_HOLES_FRAMES);
+						HyperSpaceElementPtr->current.image.farray = &Falayalaralfali;
 					}
-				
+					HyperSpaceElementPtr->death_func = NULL;
 					HyperSpaceElementPtr->preprocess_func = NULL;
 					HyperSpaceElementPtr->postprocess_func = NULL;
 					HyperSpaceElementPtr->collision_func = hyper_collision;
@@ -1739,13 +1771,13 @@ SeedUniverse (void)
 					InsertElement (hHyperSpaceElement, GetHeadElement ());
 				
 					// JMS_GFX: Don't draw hole for arilou homeworld - it already has a nice planet gfx.
-					if ((GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1) && STAR_COLOR (star_type) == YELLOW_BODY)
+					if ((GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1) && STAR_COLOR (star_type) == YELLOW_BODY && RESOLUTION_FACTOR == 0)
 						continue;
 				
 				}
 				
 				// BW: and then the animated hyperspace portal
-				hHyperSpaceElement = AllocHyperElement (SDPtr);
+				hHyperSpaceElement = AllocHyperElement (&SDPtr->star_pt);
 				if (hHyperSpaceElement == 0)
 					continue;
 				
@@ -1776,7 +1808,7 @@ SeedUniverse (void)
 				HyperSpaceElementPtr->current.image.frame = SetRelFrameIndex (
 					HyperSpaceElementPtr->current.image.frame,
 					frameCounter % NUM_HOLES_FRAMES);
-				
+
 				HyperSpaceElementPtr->current.image.farray = &hyperholes[which_spaces_star_gfx];
 				HyperSpaceElementPtr->preprocess_func = NULL;
 				HyperSpaceElementPtr->postprocess_func = NULL;
@@ -1784,21 +1816,18 @@ SeedUniverse (void)
 				
 				SetUpElement (HyperSpaceElementPtr);
 				
-				if (SDPtr == CurStarDescPtr
-					&& GET_GAME_STATE (PORTAL_COUNTER) == 0)
+				if ((SDPtr == CurStarDescPtr && GET_GAME_STATE (PORTAL_COUNTER) == 0)) {
 					HyperSpaceElementPtr->death_func = hyper_death;
-				else
-				{
+				} else {
 					HyperSpaceElementPtr->death_func = NULL;
 					HyperSpaceElementPtr->IntersectControl.IntersectStamp.frame =
 					DecFrameIndex (stars_in_space);
 				}
 				UnlockElement (hHyperSpaceElement);
 				
-				InsertElement (hHyperSpaceElement, GetHeadElement ());				
+				InsertElement (hHyperSpaceElement, GetHeadElement ());	
 			}
 		}
-		
 		ProcessEncounters (&universe, ox, oy);
 	}
 
@@ -1850,7 +1879,8 @@ SeedUniverse (void)
 	if (!(LOWORD (TFB_Random ()) & 7))
 		AddAmbientElement ();
 
-	if (universe.x != GLOBAL (ShipStamp.origin.x) || universe.y != GLOBAL (ShipStamp.origin.y))
+	if (universe.x != GLOBAL (ShipStamp.origin.x)
+			|| universe.y != GLOBAL (ShipStamp.origin.y))
 	{
 		GLOBAL (ShipStamp.origin) = universe;
 		DrawHyperCoords (universe);
@@ -1874,9 +1904,7 @@ DoHyperspaceMenu (MENU_STATE *pMS)
 	if (!select)
 		return TRUE;
 
-	LockMutex (GraphicsLock);
 	SetFlashRect (NULL);
-	UnlockMutex (GraphicsLock);
 
 	switch (pMS->CurState)
 	{
@@ -1905,6 +1933,8 @@ DoHyperspaceMenu (MENU_STATE *pMS)
 			StarMap ();
 			return FALSE;
 		case NAVIGATION:
+			if(RESOLUTION_FACTOR == 1)				
+				DrawSubmenu (0);
 			return FALSE;
 	}
 
@@ -1916,9 +1946,7 @@ DoHyperspaceMenu (MENU_STATE *pMS)
 				pMS->CurState = NAVIGATION;
 			DrawMenuStateStrings (PM_STARMAP, pMS->CurState);
 		}
-		LockMutex (GraphicsLock);
 		SetFlashRect (SFR_MENU_3DO);
-		UnlockMutex (GraphicsLock);
 	}
 
 	return TRUE;
@@ -1936,7 +1964,6 @@ UnbatchGraphics ();
 	OldContext = SetContext (SpaceContext);
 	OldColor = SetContextBackGroundColor (BLACK_COLOR);
 
-	UnlockMutex (GraphicsLock);
 
 	memset (&MenuState, 0, sizeof (MenuState));
 	MenuState.InputFunc = DoHyperspaceMenu;
@@ -1944,14 +1971,11 @@ UnbatchGraphics ();
 	MenuState.CurState = STARMAP;
 
 	DrawMenuStateStrings (PM_STARMAP, STARMAP);
-	LockMutex (GraphicsLock);
 	SetFlashRect (SFR_MENU_3DO);
-	UnlockMutex (GraphicsLock);
 
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
 	DoInput (&MenuState, TRUE);
 
-	LockMutex (GraphicsLock);
 	SetFlashRect (NULL);
 
 	SetContext (SpaceContext);
@@ -1959,9 +1983,7 @@ UnbatchGraphics ();
 	if (!(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD)))
 	{
 		ClearSISRect (CLEAR_SIS_RADAR);
-		UnlockMutex (GraphicsLock);
 		WaitForNoInput (ONE_SECOND / 2, FALSE);
-		LockMutex (GraphicsLock);
 	}
 
 	SetContextBackGroundColor (OldColor);
diff -ruNp src.hd/uqm/hyper.h src/uqm/hyper.h
--- src.hd/uqm/hyper.h	2017-12-29 02:25:52 -0800
+++ src/uqm/hyper.h	2017-12-29 00:57:46 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #ifndef _HYPER_H
 #define _HYPER_H
 
@@ -25,6 +23,10 @@
 #include "units.h"
 		// for UNIT_SCREEN_WIDTH/HEIGHT
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #define NUM_RADAR_SCREENS 12
 
 #define RADAR_SCAN_WIDTH ((UNIT_SCREEN_WIDTH * NUM_RADAR_SCREENS) >> RESOLUTION_FACTOR)
@@ -39,8 +41,8 @@
 #define QUASI_SPACE_Y  5000
 
 // QuasiSpace coordinates of the Arilou home world
-#define ARILOU_HOME_X  6134
-#define ARILOU_HOME_Y  5900
+#define ARILOU_HOME_X 6134 // (QUASI_SPACE_X + ((RADAR_SCAN_WIDTH >> 1) * 3))
+#define ARILOU_HOME_Y 5900 // (QUASI_SPACE_Y + ((RADAR_SCAN_HEIGHT >> 1) * 3))
 
 // HyperSpace coordinates of the locations where the QuasiSpace portals
 // take you.
@@ -81,5 +83,9 @@ extern BOOLEAN hyper_transition (ELEMENT
 extern void HyperspaceMenu (void);
 extern void SaveSisHyperState (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _HYPER_H */
 
diff -ruNp src.hd/uqm/ifontres.h src/uqm/ifontres.h
--- src.hd/uqm/ifontres.h	2017-12-29 02:25:52 -0800
+++ src/uqm/ifontres.h	2017-12-29 00:57:46 -0800
@@ -2,9 +2,6 @@
    should not be edited directly.  Modify the master resource list
    instead and regenerate. */
 
-#define FALLBACK_TO1X_FONT "font.fallbackto1x"
-#define FALLBACK_TO2X_FONT "font.fallbackto2x"
-#define FALLBACK_TO4X_FONT "font.fallbackto4x"
 #define LANDER_FONT "font.lander"
 #define MICRO_FONT "font.micro"
 #define NANO_FONT "font.nano"
@@ -17,4 +14,10 @@
 #define TINY_FALLBACK_TO1X_FONT "font.tinyfallbackto1x"
 #define TINY_FALLBACK_TO2X_FONT "font.tinyfallbackto2x"
 #define TINY_FALLBACK_TO4X_FONT "font.tinyfallbackto4x"
+#define PLYR_FALLBACK_TO1X_FONT "font.plyrfallbackto1x"
+#define PLYR_FALLBACK_TO2X_FONT "font.plyrfallbackto2x"
+#define PLYR_FALLBACK_TO4X_FONT "font.plyrfallbackto4x"
+#define SCON_FALLBACK_TO1X_FONT "font.sconfallbackto1x"
+#define SCON_FALLBACK_TO2X_FONT "font.sconfallbackto2x"
+#define SCON_FALLBACK_TO4X_FONT "font.sconfallbackto4x"
 #define COMPUTER_FONT "comm.computer.font"
diff -ruNp src.hd/uqm/igfxres.h src/uqm/igfxres.h
--- src.hd/uqm/igfxres.h	2017-12-29 02:25:52 -0800
+++ src/uqm/igfxres.h	2017-12-29 00:57:46 -0800
@@ -20,12 +20,16 @@
 #define BOOM_SML_MASK_PMAP_ANIM "graphics.boom.small"
 #define BURV_BCS_MASK_PMAP_ANIM "graphics.burvixcaster"
 #define CALLISTO_MASK_ANIM "graphics.callistomask"
-#define CONSTELLATIONS_MASK_PMAP_ANIM "graphics.constellations"
 #define CANNISTER_MASK_PMAP_ANIM "graphics.lifecan"
+#define CONSTELLATIONS_MASK_PMAP_ANIM "graphics.constellations"
 #define CREDITS_BACK_ANIM "credits.background"
+#define CREW_BIG_MASK_PMAP_ANIM "graphics.crew.large"
+#define CREW_MED_MASK_PMAP_ANIM "graphics.crew.medium"
+#define CREW_SML_MASK_PMAP_ANIM "graphics.crew.small"
 #define EARTH_MASK_ANIM "graphics.earthmask"
 #define EGG_CASE_MASK_PMAP_ANIM "graphics.eggcase"
 #define EUROPA_MASK_ANIM "graphics.europamask"
+#define FALAYALARALFALI_MASK_PMAP_ANIM "graphics.falayalaralfali"
 #define FLAGSTAT_MASK_PMAP_ANIM "graphics.flagshipstatus"
 #define FONTGRAD_PMAP_ANIM "graphics.fontgradient"
 #define GANYMEDE_MASK_ANIM "graphics.ganymedemask"
@@ -33,6 +37,9 @@
 #define HYPERSTARS_MASK_PMAP_ANIM "graphics.hyperstars"
 #define HYPERSUNS_MASK_PMAP_ANIM "graphics.hypersuns"
 #define IO_MASK_ANIM "graphics.iomask"
+#define IONS_BIG_MASK_PMAP_ANIM "graphics.ions.large"
+#define IONS_MED_MASK_PMAP_ANIM "graphics.ions.medium"
+#define IONS_SML_MASK_PMAP_ANIM "graphics.ions.small"
 #define IPBKGND_MASK_PMAP_ANIM "graphics.orbitbackground"
 #define IP_CALLISTO_MASK_ANIM "graphics.ipcallistomask"
 #define IP_EARTH_MASK_ANIM "graphics.ipearthmask"
@@ -283,6 +290,7 @@
 #define PLAYMENU_ANIM "graphics.playmenu"
 #define PLUTO_MASK_ANIM "graphics.plutomask"
 #define QUAKE_MASK_PMAP_ANIM "graphics.quake"
+#define QUASIPORTAL_MASK_PMAP_ANIM "graphics.quasiportal"
 #define RESTART_PMAP_ANIM "graphics.newgame"
 #define RESTART_PMAP_ANIM2x "graphics.newgame2x"
 #define RESTART_PMAP_ANIM4x "graphics.newgame4x"
@@ -302,9 +310,9 @@
 #define SPAPLUTO_MASK_PMAP_ANIM "graphics.fwiffo"
 #define STARBASE_ANIM "graphics.starbase"
 #define STAR_MASK_PMAP_ANIM "graphics.stars"
+#define STARPOINT_MASK_PMAP_ANIM "graphics.starpoints"
 #define STATUS_MASK_PMAP_ANIM "graphics.status"
-#define SUBMENUMINERALS_MASK_PMAP_ANIM "graphics.submenu.minerals"
-#define SUBMENUSTARMAPKEYS_MASK_PMAP_ANIM "graphics.submenu.starmapkeys"
+#define SUBMENU_MASK_PMAP_ANIM "graphics.submenu"
 #define SUNBLUE_MASK_PMAP_ANIM "graphics.truespacesunblue"
 #define SUNGREEN_MASK_PMAP_ANIM "graphics.truespacesungreen"
 #define SUNORANGE_MASK_PMAP_ANIM "graphics.truespacesunorange"
diff -ruNp src.hd/uqm/imusicre.h src/uqm/imusicre.h
--- src.hd/uqm/imusicre.h	2017-12-29 02:25:52 -0800
+++ src/uqm/imusicre.h	2017-12-29 00:57:46 -0800
@@ -6,7 +6,9 @@
 #define CREDITS_MUSIC "music.credits"
 #define HYPERSPACE_MUSIC "music.hyperspace"
 #define IP_MUSIC "music.space"
-#define MAINMENU_MUSIC "music.mainmenu"
+#define MAINMENU1_MUSIC "music.mainmenu1"
+#define MAINMENU2_MUSIC "music.mainmenu2"
+#define MAINMENU3_MUSIC "music.mainmenu3"
 #define MELEE_MUSIC "music.meleemenu"
 #define ORBIT1_MUSIC "music.orbit1"
 #define ORBIT2_MUSIC "music.orbit2"
diff -ruNp src.hd/uqm/init.c src/uqm/init.c
--- src.hd/uqm/init.c	2017-12-29 02:25:52 -0800
+++ src/uqm/init.c	2017-12-29 00:57:46 -0800
@@ -37,7 +37,10 @@
 
 
 FRAME stars_in_space;
+FRAME StarPoints;
 FRAME stars_in_quasispace; // JMS_GFX
+FRAME crew_dots[NUM_VIEWS]; // JMS_GFX
+FRAME ion_trails[NUM_VIEWS]; // JMS_GFX
 FRAME asteroid[NUM_VIEWS];
 FRAME blast[NUM_VIEWS];
 FRAME explosion[NUM_VIEWS];
@@ -122,6 +125,27 @@ InitSpace (void)
 		if (stars_in_space == NULL)
 			return FALSE;
 
+		if(RESOLUTION_FACTOR > 0){
+			StarPoints = CaptureDrawable (
+					LoadGraphic (STARPOINT_MASK_PMAP_ANIM));
+			if (StarPoints == NULL)
+				return FALSE;
+		}
+
+		// JMS_GFX
+		if (!load_animation (crew_dots,
+								CREW_BIG_MASK_PMAP_ANIM,
+								CREW_MED_MASK_PMAP_ANIM,
+								CREW_SML_MASK_PMAP_ANIM))
+			return FALSE;
+        
+		// JMS_GFX
+		if (!load_animation (ion_trails,
+							IONS_BIG_MASK_PMAP_ANIM,
+							IONS_MED_MASK_PMAP_ANIM,
+							IONS_SML_MASK_PMAP_ANIM))
+			return FALSE;
+
 		if (!load_animation (explosion,
 				BOOM_BIG_MASK_PMAP_ANIM,
 				BOOM_MED_MASK_PMAP_ANIM,
@@ -153,8 +177,14 @@ UninitSpace (void)
 		free_image (explosion);
 		free_image (asteroid);
 
+		// JMS_GFX
+		free_image (crew_dots);
+		free_image (ion_trails);
+
 		DestroyDrawable (ReleaseDrawable (stars_in_space));
+		DestroyDrawable (ReleaseDrawable (StarPoints));
 		stars_in_space = 0;
+		StarPoints = 0;
 	}
 }
 
@@ -188,7 +218,7 @@ InitShips (void)
 	InitDisplayList ();
 	InitGalaxy ();
 
-	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+	if (inHQSpace ())
 	{
 		ReinitQueue (&race_q[0]);
 		ReinitQueue (&race_q[1]);
@@ -312,9 +342,6 @@ UninitShips (void)
 							crew_retrieved;
 			}
 
-			if (StarShipPtr->RaceDescPtr->uninit_func != NULL)
-				(*StarShipPtr->RaceDescPtr->uninit_func) (
-						StarShipPtr->RaceDescPtr);
 			/* Record crew left after battle */
 			StarShipPtr->crew_level =
 					StarShipPtr->RaceDescPtr->ship_info.crew_level;
@@ -347,7 +374,7 @@ UninitShips (void)
 		for (i = 0; i < NUM_PLAYERS; i++)
 			ReinitQueue (&race_q[i]);
 
-		if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+		if (inHQSpace ())
 			FreeHyperspace ();
 	}
 }
diff -ruNp src.hd/uqm/init.h src/uqm/init.h
--- src.hd/uqm/init.h	2017-12-29 02:25:52 -0800
+++ src/uqm/init.h	2017-12-29 00:57:46 -0800
@@ -19,12 +19,20 @@
 
 #include "libs/gfxlib.h"
 #include "libs/reslib.h"
+#include "units.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
 #define NUM_PLAYERS 2
 #define NUM_SIDES 2
 
 extern FRAME stars_in_space;
+extern FRAME StarPoints;
 extern FRAME stars_in_quasispace; // JMS_GFX
+extern FRAME crew_dots[NUM_VIEWS]; // JMS_GFX
+extern FRAME ion_trails[NUM_VIEWS]; // JMS_GFX
 
 extern BOOLEAN InitSpace (void);
 extern void UninitSpace (void);
@@ -36,5 +44,9 @@ extern BOOLEAN load_animation (FRAME *pi
 		RESOURCE med_res, RESOURCE sml_res);
 extern BOOLEAN free_image (FRAME *pixarray);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _INIT_H */
 
diff -ruNp src.hd/uqm/intel.h src/uqm/intel.h
--- src.hd/uqm/intel.h	2017-12-29 02:25:52 -0800
+++ src/uqm/intel.h	2017-12-29 00:57:46 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
- // JMS_GFX: Added definitions for hi-res modes.
-
 #ifndef _INTEL_H
 #define _INTEL_H
 
@@ -26,6 +24,10 @@
 #include "element.h"
 #include "races.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #define MANEUVERABILITY(pi) ((pi)->ManeuverabilityIndex)
 #define WEAPON_RANGE(pi) ((pi)->WeaponRange)
 
@@ -99,6 +101,10 @@ extern BOOLEAN ThrustShip (ELEMENT *Ship
 #define AWESOME_RATING (BYTE)(1 << 6)
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _INTEL_H */
 
 
diff -ruNp src.hd/uqm/intro.c src/uqm/intro.c
--- src.hd/uqm/intro.c	2017-12-29 02:25:52 -0800
+++ src/uqm/intro.c	2017-12-29 00:57:46 -0800
@@ -160,7 +160,6 @@ Present_BatchGraphics (PRESENTATION_INPU
 	if (!pPIS->Batched)
 	{
 		pPIS->Batched = TRUE;
-		LockMutex (GraphicsLock);
 		BatchGraphics ();
 	}
 }
@@ -171,7 +170,6 @@ Present_UnbatchGraphics (PRESENTATION_IN
 	if (pPIS->Batched)
 	{
 		UnbatchGraphics ();
-		UnlockMutex (GraphicsLock);
 		pPIS->Batched = FALSE;
 		if (bYield)
 			TaskSwitch ();
@@ -198,7 +196,6 @@ Present_GenerateSIS (PRESENTATION_INPUT_
 	COUNT piece;
 	Color SisBack;
 
-	LockMutex (GraphicsLock);
 	OldContext = SetContext (OffScreenContext);
 
 	SkelFrame = CaptureDrawable (LoadGraphic (SISSKEL_MASK_PMAP_ANIM));
@@ -266,7 +263,6 @@ Present_GenerateSIS (PRESENTATION_INPUT_
 
 	SetContext (OldContext);
 	FlushGraphics ();
-	UnlockMutex (GraphicsLock);
 
 	pPIS->SisFrame = SisFrame;
 }
@@ -279,9 +275,7 @@ Present_DrawMovieFrame (PRESENTATION_INP
 	s.origin.x = 0;
 	s.origin.y = 0;
 	s.frame = SetAbsFrameIndex (pPIS->Frame, pPIS->MovieFrame);
-	LockMutex (GraphicsLock);
 	DrawStamp (&s);
-	UnlockMutex (GraphicsLock);
 }
 
 static BOOLEAN
@@ -361,15 +355,13 @@ DoPresentation (void *pIS)
 			{
 				w <<= RESOLUTION_FACTOR; // JMS_GFX
 				h <<= RESOLUTION_FACTOR; // JMS_GFX
-				
+
 				pPIS->clip_r.extent.width = w;
 				pPIS->clip_r.extent.height = h;
 				/* center on screen */
 				pPIS->clip_r.corner.x = (SCREEN_WIDTH - w) / 2;
 				pPIS->clip_r.corner.y = (SCREEN_HEIGHT - h) / 2;
-				LockMutex (GraphicsLock);
 				SetContextClipRect (&pPIS->clip_r);
-				UnlockMutex (GraphicsLock);
 			}
 		}
 		else if (strcmp (Opcode, "FONT") == 0)
@@ -395,12 +387,8 @@ DoPresentation (void *pIS)
 				*pFont = LoadFontFile (pPIS->Buffer);
 			}
 
-			if (!pPIS->Batched)
-				LockMutex (GraphicsLock);
 			SetContextFont (*pFont);
-			if (!pPIS->Batched)
-				UnlockMutex (GraphicsLock);
-		}
+		}		
 		else if (strcmp (Opcode, "FONT1X") == 0 && RESOLUTION_FACTOR == 0)
 		{	/* set and/or load a font */
 			int index;
@@ -423,12 +411,7 @@ DoPresentation (void *pIS)
 					DestroyFont (*pFont);
 				*pFont = LoadFontFile (pPIS->Buffer);
 			}
-			
-			if (!pPIS->Batched)
-				LockMutex (GraphicsLock);
 			SetContextFont (*pFont);
-			if (!pPIS->Batched)
-				UnlockMutex (GraphicsLock);
 		}
 		else if (strcmp (Opcode, "FONT2X") == 0 && RESOLUTION_FACTOR == 1)
 		{	/* set and/or load a font */
@@ -452,12 +435,7 @@ DoPresentation (void *pIS)
 					DestroyFont (*pFont);
 				*pFont = LoadFontFile (pPIS->Buffer);
 			}
-			
-			if (!pPIS->Batched)
-				LockMutex (GraphicsLock);
-			SetContextFont (*pFont);
-			if (!pPIS->Batched)
-				UnlockMutex (GraphicsLock);
+			SetContextFont (*pFont);;
 		}
 		else if (strcmp (Opcode, "FONT4X") == 0 && RESOLUTION_FACTOR == 2)
 		{	/* set and/or load a font */
@@ -481,12 +459,7 @@ DoPresentation (void *pIS)
 					DestroyFont (*pFont);
 				*pFont = LoadFontFile (pPIS->Buffer);
 			}
-			
-			if (!pPIS->Batched)
-				LockMutex (GraphicsLock);
 			SetContextFont (*pFont);
-			if (!pPIS->Batched)
-				UnlockMutex (GraphicsLock);
 		}
 		else if (strcmp (Opcode, "ANI") == 0)
 		{	/* set ani */
@@ -597,7 +570,7 @@ DoPresentation (void *pIS)
 			if (3 == sscanf (pStr, "%d %d %255[^\n]", &x, &y, pPIS->Buffer))
 			{
 				TEXT t;
-				
+
 				x <<= RESOLUTION_FACTOR; // JMS_GFX
 				y <<= RESOLUTION_FACTOR; // JMS_GFX
 
@@ -606,12 +579,8 @@ DoPresentation (void *pIS)
 				t.CharCount = (COUNT)~0;
 				t.baseline.x = x;
 				t.baseline.y = y;
-				if (!pPIS->Batched)
-					LockMutex (GraphicsLock);
 				DrawTextEffect (&t, pPIS->TextColor, pPIS->TextBackColor,
 						pPIS->TextEffect);
-				if (!pPIS->Batched)
-					UnlockMutex (GraphicsLock);
 			}
 		}
 		else if (strcmp (Opcode, "TFI") == 0)
@@ -626,9 +595,7 @@ DoPresentation (void *pIS)
 			
 			Present_UnbatchGraphics (pPIS, TRUE);
 
-			LockMutex (GraphicsLock);
 			GetContextFontLeading (&leading);
-			UnlockMutex (GraphicsLock);
 
 			switch (pPIS->TextVPos)
 			{
@@ -652,7 +619,6 @@ DoPresentation (void *pIS)
 				pPIS->TextLines[i].baseline.y = y;
 			}
 
-			LockMutex (GraphicsLock);
 			for (i = 0; i < pPIS->LinesCount; ++i)
 				DrawTextEffect (pPIS->TextLines + i, pPIS->TextFadeColor,
 						pPIS->TextFadeColor, pPIS->TextEffect);
@@ -666,7 +632,6 @@ DoPresentation (void *pIS)
 			ScreenTransition (3, &pPIS->tfade_r);
 			UnbatchGraphics ();
 			
-			UnlockMutex (GraphicsLock);
 		}
 		else if (strcmp (Opcode, "TFO") == 0)
 		{	/* text fade-out */
@@ -674,7 +639,6 @@ DoPresentation (void *pIS)
 			
 			Present_UnbatchGraphics (pPIS, TRUE);
 
-			LockMutex (GraphicsLock);
 			/* do transition */
 			SetTransitionSource (&pPIS->tfade_r);
 			BatchGraphics ();
@@ -683,7 +647,6 @@ DoPresentation (void *pIS)
 						pPIS->TextFadeColor, pPIS->TextEffect);
 			ScreenTransition (3, &pPIS->tfade_r);
 			UnbatchGraphics ();
-			UnlockMutex (GraphicsLock);
 		}
 		else if (strcmp (Opcode, "SAVEBG") == 0)
 		{	/* save background */
@@ -740,7 +703,7 @@ DoPresentation (void *pIS)
 				x = 0;
 				y = 0;
 			}
-			
+
 			x <<= RESOLUTION_FACTOR; // JMS_GFX
 			y <<= RESOLUTION_FACTOR; // JMS_GFX
 
@@ -771,15 +734,11 @@ DoPresentation (void *pIS)
 			}
 			s.origin.x = x;
 			s.origin.y = y;
-			if (!pPIS->Batched)
-				LockMutex (GraphicsLock);
 			old_mode = SetGraphicScaleMode (scale_mode);
 			old_scale = SetGraphicScale (scale);
 			DrawStamp (&s);
 			SetGraphicScale (old_scale);
 			SetGraphicScaleMode (old_mode);
-			if (!pPIS->Batched)
-				UnlockMutex (GraphicsLock);
 		}
 		else if (strcmp (Opcode, "BATCH") == 0)
 		{	/* batch graphics */
@@ -808,9 +767,7 @@ DoPresentation (void *pIS)
 		{	/* clear screen */
 			Present_UnbatchGraphics (pPIS, TRUE);
 
-			LockMutex (GraphicsLock);
 			ClearDrawable ();	
-			UnlockMutex (GraphicsLock);
 		}
 		else if (strcmp (Opcode, "CALL") == 0)
 		{	/* call another script */
@@ -825,7 +782,7 @@ DoPresentation (void *pIS)
 			if (4 == sscanf (pStr, "%d %d %d %d", &x1, &y1, &x2, &y2))
 			{
 				LINE l;
-				
+
 				x1 <<= RESOLUTION_FACTOR; // JMS_GFX
 				y1 <<= RESOLUTION_FACTOR; // JMS_GFX
 				x2 <<= RESOLUTION_FACTOR; // JMS_GFX
@@ -836,12 +793,8 @@ DoPresentation (void *pIS)
 				l.second.x = x2;
 				l.second.y = y2;
 				
-				if (!pPIS->Batched)
-					LockMutex (GraphicsLock);
 				SetContextForeGroundColor (pPIS->TextColor);
 				DrawLine (&l);
-				if (!pPIS->Batched)
-					UnlockMutex (GraphicsLock);
 			}
 			else
 			{
@@ -895,12 +848,10 @@ ShowSlidePresentation (STRING PresStr)
 	pis.SlideShow = SetAbsStringTableIndex (pis.SlideShow, 0);
 	pis.OperIndex = 0;
 
-	LockMutex (GraphicsLock);
 	OldContext = SetContext (ScreenContext);
 	GetContextClipRect (&OldRect);
 	OldFont = SetContextFont (NULL);
 	SetContextBackGroundColor (BLACK_COLOR);
-	UnlockMutex (GraphicsLock);
 
 	SetMenuSounds (MENU_SOUND_NONE, MENU_SOUND_NONE);
 	pis.InputFunc = DoPresentation;
@@ -921,11 +872,9 @@ ShowSlidePresentation (STRING PresStr)
 	for (i = 0; i < MAX_FONTS; ++i)
 		DestroyFont (pis.Fonts[i]);
 
-	LockMutex (GraphicsLock);
 	SetContextFont (OldFont);
 	SetContextClipRect (&OldRect);
 	SetContext (OldContext);
-	UnlockMutex (GraphicsLock);
 
 	return TRUE;
 }
@@ -977,11 +926,9 @@ FadeClearScreen (void)
 	SleepThreadUntil (FadeScreen (FadeAllToBlack, ONE_SECOND / 2));
 	
 	// clear the screen with black
-	LockMutex (GraphicsLock);
 	SetContext (ScreenContext);
 	SetContextBackGroundColor (BLACK_COLOR);
 	ClearDrawable ();
-	UnlockMutex (GraphicsLock);
 
 	FadeScreen (FadeAllToColor, 0);
 }
diff -ruNp src.hd/uqm/ipdisp.c src/uqm/ipdisp.c
--- src.hd/uqm/ipdisp.c	2017-12-29 02:25:52 -0800
+++ src/uqm/ipdisp.c	2017-12-29 00:57:46 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "ipdisp.h"
 
 #include "collide.h"
@@ -247,7 +245,6 @@ ip_group_preprocess (ELEMENT *ElementPtr
 
 		Transition = FALSE;
 		isOrbiting = FALSE;
-		
 		if (task == FLEE)
 		{
 			dest_pt.x = GroupPtr->loc.x << 1;
@@ -262,7 +259,6 @@ ip_group_preprocess (ELEMENT *ElementPtr
 		{
 			if (GroupPtr->dest_loc == IPNL_INTERCEPT_PLAYER)
 				dest_pt = GLOBAL (ip_location);
-			
 			// ship is circling around a planet.
 			else
 			{
diff -ruNp src.hd/uqm/ipdisp.h src/uqm/ipdisp.h
--- src.hd/uqm/ipdisp.h	2017-12-29 02:25:52 -0800
+++ src/uqm/ipdisp.h	2017-12-29 00:57:46 -0800
@@ -19,6 +19,10 @@
 
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern void NotifyOthers (COUNT which_race, BYTE target_loc);
 // Special target locations for NotifyOthers()
 #define IPNL_INTERCEPT_PLAYER   0
@@ -26,4 +30,8 @@ extern void NotifyOthers (COUNT which_ra
 
 extern void DoMissions (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* UQM_IPDISP_H_INCL_ */
diff -ruNp src.hd/uqm/iscriptres.h src/uqm/iscriptres.h
--- src.hd/uqm/iscriptres.h	1969-12-31 16:00:00 -0800
+++ src/uqm/iscriptres.h	2017-12-29 00:57:46 -0800
@@ -0,0 +1,6 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
+#define EVENT_SCRIPT "event.script"
+#define SCRIPT_DIR_INITGAME "script.dir.initgame"
diff -ruNp src.hd/uqm/istrtab.h src/uqm/istrtab.h
--- src.hd/uqm/istrtab.h	2017-12-29 02:25:52 -0800
+++ src/uqm/istrtab.h	2017-12-29 00:57:46 -0800
@@ -78,12 +78,12 @@
 #define LUNA_COLOR_TAB "planet.luna.colortable"
 #define MAGMA_COLOR_TAB "planet.magma.colortable"
 #define MAGMA_XLAT_TAB "planet.magma.translatetable"
-#define MARS_COLOR_TAB "planet.mars.colortable"
 #define MAGNETIC_COLOR_TAB "planet.magnetic.colortable"
 #define MAGNETIC_XLAT_TAB "planet.magnetic.translatetable"
 #define MAIDENS_STRTAB "text.maidens"
 #define MAROON_COLOR_TAB "planet.maroon.colortable"
 #define MAROON_XLAT_TAB "planet.maroon.translatetable"
+#define MARS_COLOR_TAB "planet.mars.colortable"
 #define MERCURY_COLOR_TAB "planet.mercury.colortable"
 #define METAL_COLOR_TAB "planet.metal.colortable"
 #define METAL_XLAT_TAB "planet.metal.translatetable"
@@ -134,8 +134,8 @@
 #define SETUP_MENU_STRTAB "text.setupmenu"
 #define SHATTERED_COLOR_TAB "planet.shattered.colortable"
 #define SHATTERED_XLAT_TAB "planet.shattered.translatetable"
-#define SPECIAL_CMAP_XLAT_TAB "planet.specialcolormap.translatetable"
 #define SPAPLUTO_STRTAB "text.fwiffo"
+#define SPECIAL_CMAP_XLAT_TAB "planet.specialcolormap.translatetable"
 #define STARCON_COLOR_MAP "colortable.main"
 #define STARCON_GAME_STRINGS "text.starcon"
 #define SUN_DEVICE_STRTAB "text.sundevice"
@@ -143,9 +143,9 @@
 #define SUPER_DENSE_XLAT_TAB "planet.superdense.translatetable"
 #define SUPOX_RUINS_STRTAB "text.ultron"
 #define TAALO_DEVICE_STRTAB "text.taalodevice"
-#define TITAN_COLOR_TAB "planet.titan.colortable"
 #define TELLURIC_COLOR_TAB "planet.telluric.colortable"
 #define TELLURIC_XLAT_TAB "planet.telluric.translatetable"
+#define TITAN_COLOR_TAB "planet.titan.colortable"
 #define TREASURE_COLOR_TAB "planet.treasure.colortable"
 #define TREASURE_XLAT_TAB "planet.treasure.translatetable"
 #define TRITON_COLOR_TAB "planet.triton.colortable"
@@ -153,8 +153,8 @@
 #define ULTRAMARINE_XLAT_TAB "planet.ultramarine.translatetable"
 #define ULTRAVIOLET_COLOR_TAB "planet.ultraviolet.colortable"
 #define ULTRAVIOLET_XLAT_TAB "planet.ultraviolet.translatetable"
-#define URANUS_COLOR_TAB "planet.uranus.colortable"
 #define UMGAH_BCS_STRTAB "text.umgahcaster"
+#define URANUS_COLOR_TAB "planet.uranus.colortable"
 #define UREA_COLOR_TAB "planet.urea.colortable"
 #define UREA_XLAT_TAB "planet.urea.translatetable"
 #define VAULT_STRTAB "text.syreenvault"
@@ -172,5 +172,3 @@
 #define YEL_GAS_XLAT_TAB "planet.yellowgas.translatetable"
 #define YTTRIC_COLOR_TAB "planet.yttric.colortable"
 #define YTTRIC_XLAT_TAB "planet.yttric.translatetable"
-#define ZOQCOLONY_RUINS1_STRTAB "text.zoqfotcolonyruins1"
-#define ZOQCOLONY_RUINS2_STRTAB "text.zoqfotcolonyruins2"
diff -ruNp src.hd/uqm/load.c src/uqm/load.c
--- src.hd/uqm/load.c	2017-12-29 02:25:52 -0800
+++ src/uqm/load.c	2017-12-29 00:57:46 -0800
@@ -16,150 +16,85 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS 2011: - Added loading res_factor to summary_desc. It'll help making saves between different resolutions compatible.
-
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include <assert.h>
 
-#include "load.h"
-
 #include "build.h"
-#include "libs/declib.h"
 #include "encount.h"
+#include "gameev.h"
+#include "starmap.h"
 #include "libs/file.h"
 #include "globdata.h"
-#include "load.h"
 #include "options.h"
+#include "save.h"
 #include "setup.h"
 #include "state.h"
-#include "grpinfo.h"
+#include "grpintrn.h"
 
 #include "libs/tasklib.h"
 #include "libs/log.h"
 #include "libs/misc.h"
 
-#include "util.h"
-
-#include "gamestr.h" // JMS: For GAME_STRING
-
 //#define DEBUG_LOAD
 
 ACTIVITY NextActivity;
 
-// XXX: these should handle endian conversions later
-static inline COUNT
-cread_8 (DECODE_REF fh, BYTE *v)
+static inline size_t
+read_8 (void *fp, BYTE *v)
 {
 	BYTE t;
 	if (!v) /* read value ignored */
 		v = &t;
-	return cread (v, 1, 1, fh);
-}
-
-static inline COUNT
-cread_16 (DECODE_REF fh, UWORD *v)
-{
-	UWORD t;
-	if (!v) /* read value ignored */
-		v = &t;
-	return cread (v, 2, 1, fh);
-}
-
-static inline COUNT
-cread_16s (DECODE_REF fh, SWORD *v)
-{
-	UWORD t;
-	COUNT ret;
-	// value was converted to unsigned when saved
-	ret = cread_16 (fh, &t);
-	// unsigned to signed conversion
-	if (v)
-		*v = t;
-	return ret;
+	return ReadResFile (v, 1, 1, fp);
 }
 
-static inline COUNT
-cread_32 (DECODE_REF fh, DWORD *v)
+static inline size_t
+read_16 (void *fp, UWORD *v)
 {
-	DWORD t;
-	if (!v) /* read value ignored */
-		v = &t;
-	return cread (v, 4, 1, fh);
-}
+	UWORD t = 0;
+	int shift, i;
+	for (i = 0, shift = 0; i < 2; ++i, shift += 8)
+	{
+		BYTE b;
+		if (read_8 (fp, &b) != 1)
+			return 0;
+		t |= ((UWORD)b) << shift;
+	}
 
-static inline COUNT
-cread_32s (DECODE_REF fh, SDWORD *v)
-{
-	DWORD t;
-	COUNT ret;
-	// value was converted to unsigned when saved
-	ret = cread_32 (fh, &t);
-	// unsigned to signed conversion
 	if (v)
 		*v = t;
-	return ret;
-}
 
-static inline COUNT
-cread_ptr (DECODE_REF fh)
-{
-	DWORD t;
-	return cread_32 (fh, &t); /* ptrs are useless in saves */
-}
-
-static inline COUNT
-cread_a8 (DECODE_REF fh, BYTE *ar, COUNT count)
-{
-	assert (ar != NULL);
-	return cread (ar, 1, count, fh) == count;
-}
-
-static inline size_t
-read_8 (void *fp, BYTE *v)
-{
-	BYTE t;
-	if (!v) /* read value ignored */
-		v = &t;
-	return ReadResFile (v, 1, 1, fp);
+	return 1;
 }
 
 static inline size_t
-read_16 (void *fp, UWORD *v)
+read_16s (void *fp, SWORD *v)
 {
-	UWORD t;
-	if (!v) /* read value ignored */
-		v = &t;
-	return ReadResFile (v, 2, 1, fp);
+	return read_16 (fp, v);
 }
 
 static inline size_t
 read_32 (void *fp, DWORD *v)
 {
-	DWORD t;
-	if (!v) /* read value ignored */
-		v = &t;
-	return ReadResFile (v, 4, 1, fp);
-}
+	DWORD t = 0;
+	int shift, i;
+	for (i = 0, shift = 0; i < 4; ++i, shift += 8)
+	{
+		BYTE b;
+		if (read_8 (fp, &b) != 1)
+			return 0;
+		t |= ((DWORD)b) << shift;
+	}
 
-static inline size_t
-read_32s (void *fp, SDWORD *v)
-{
-	DWORD t;
-	COUNT ret;
-	// value was converted to unsigned when saved
-	ret = read_32 (fp, &t);
-	// unsigned to signed conversion
 	if (v)
 		*v = t;
-	return ret;
+
+	return 1;
 }
 
 static inline size_t
-read_ptr (void *fp)
+read_32s (void *fp, SDWORD *v)
 {
-	DWORD t;
-	return read_32 (fp, &t); /* ptrs are useless in saves */
+	return read_32 (fp, v);
 }
 
 static inline size_t
@@ -170,6 +105,18 @@ read_a8 (void *fp, BYTE *ar, COUNT count
 }
 
 static inline size_t
+skip_8 (void *fp, COUNT count)
+{
+	int i;
+	for (i = 0; i < count; ++i)
+	{
+		if (read_8(fp, NULL) != 1)
+			return 0;
+	}
+	return 1;
+}
+
+static inline size_t
 read_str (void *fp, char *str, COUNT count)
 {
 	// no type conversion needed for strings
@@ -190,260 +137,180 @@ read_a16 (void *fp, UWORD *ar, COUNT cou
 }
 
 static void
-LoadEmptyQueue (DECODE_REF fh)
+LoadShipQueue (void *fh, QUEUE *pQueue, DWORD size)
 {
-	COUNT num_links;
-
-	cread_16 (fh, &num_links);
-	if (num_links)
-	{
-		log_add (log_Error, "LoadEmptyQueue(): BUG: the queue is not empty!");
-#ifdef DEBUG
-		explode ();
-#endif
-	}
-}
-
-static void
-LoadShipQueue (DECODE_REF fh, QUEUE *pQueue)
-{
-	COUNT num_links;
-
-	cread_16 (fh, &num_links);
+	COUNT num_links = size / 11;
 
 	while (num_links--)
 	{
 		HSHIPFRAG hStarShip;
 		SHIP_FRAGMENT *FragPtr;
 		COUNT Index;
-		BYTE tmpb;
 
-		cread_16 (fh, &Index);
+		read_16 (fh, &Index);
 
 		hStarShip = CloneShipFragment (Index, pQueue, 0);
 		FragPtr = LockShipFrag (pQueue, hStarShip);
 
 		// Read SHIP_FRAGMENT elements
-		cread_16 (fh, NULL); /* unused: was which_side */
-		cread_8  (fh, &FragPtr->captains_name_index);
-		cread_8  (fh, NULL); /* padding */
-		cread_16 (fh, NULL); /* unused: was ship_flags */
-		cread_8  (fh, &FragPtr->race_id);
-		cread_8  (fh, &FragPtr->index);
-		// XXX: reading crew as BYTE to maintain savegame compatibility
-		cread_8  (fh, &tmpb);
-		FragPtr->crew_level = tmpb;
-		cread_8  (fh, &tmpb);
-		FragPtr->max_crew = tmpb;
-		cread_8  (fh, &FragPtr->energy_level);
-		cread_8  (fh, &FragPtr->max_energy);
-		cread_16 (fh, NULL); /* unused; was loc.x */
-		cread_16 (fh, NULL); /* unused; was loc.y */
+		read_8  (fh, &FragPtr->captains_name_index);
+		read_8  (fh, &FragPtr->race_id);
+		read_8  (fh, &FragPtr->index);
+		read_16 (fh, &FragPtr->crew_level);
+		read_16 (fh, &FragPtr->max_crew);
+		read_8  (fh, &FragPtr->energy_level);
+		read_8  (fh, &FragPtr->max_energy);
 
 		UnlockShipFrag (pQueue, hStarShip);
 	}
 }
 
 static void
-LoadRaceQueue (DECODE_REF fh, QUEUE *pQueue)
+LoadRaceQueue (void *fh, QUEUE *pQueue, DWORD size)
 {
-	COUNT num_links;
-	cread_16 (fh, &num_links);
-	
+	COUNT num_links = size / 30;
+
 	while (num_links--)
 	{
 		HFLEETINFO hStarShip;
 		FLEET_INFO *FleetPtr;
 		COUNT Index;
-		BYTE tmpb;
 
-		cread_16 (fh, &Index);
+		read_16 (fh, &Index);
 
 		hStarShip = GetStarShipFromIndex (pQueue, Index);
 		FleetPtr = LockFleetInfo (pQueue, hStarShip);
 
 		// Read FLEET_INFO elements
-		cread_16 (fh, &FleetPtr->allied_state);
-		cread_8  (fh, &FleetPtr->days_left);
-		cread_8  (fh, &FleetPtr->growth_fract);
-		cread_8  (fh, &tmpb);
-		FleetPtr->crew_level = tmpb;
-		cread_8  (fh, &tmpb);
-		FleetPtr->max_crew = tmpb;
-		cread_8  (fh, &FleetPtr->growth);
-		cread_8  (fh, &FleetPtr->max_energy);
-		cread_16s(fh, &FleetPtr->loc.x);
-		cread_16s(fh, &FleetPtr->loc.y);
-
-		cread_16 (fh, &FleetPtr->actual_strength);
-		cread_16 (fh, &FleetPtr->known_strength);
-		cread_16s(fh, &FleetPtr->known_loc.x);
-		cread_16s(fh, &FleetPtr->known_loc.y);
-		cread_8  (fh, &FleetPtr->growth_err_term);
-		cread_8  (fh, &FleetPtr->func_index);
-		cread_16s(fh, &FleetPtr->dest_loc.x);
-		cread_16s(fh, &FleetPtr->dest_loc.y);
-		cread_16 (fh, NULL); /* alignment padding */
+		read_16 (fh, &FleetPtr->allied_state);
+		read_8  (fh, &FleetPtr->days_left);
+		read_8  (fh, &FleetPtr->growth_fract);
+		read_16 (fh, &FleetPtr->crew_level);
+		read_16 (fh, &FleetPtr->max_crew);
+		read_8  (fh, &FleetPtr->growth);
+		read_8  (fh, &FleetPtr->max_energy);
+		read_16s(fh, &FleetPtr->loc.x);
+		read_16s(fh, &FleetPtr->loc.y);
+
+		read_16 (fh, &FleetPtr->actual_strength);
+		read_16 (fh, &FleetPtr->known_strength);
+		read_16s(fh, &FleetPtr->known_loc.x);
+		read_16s(fh, &FleetPtr->known_loc.y);
+		read_8  (fh, &FleetPtr->growth_err_term);
+		read_8  (fh, &FleetPtr->func_index);
+		read_16s(fh, &FleetPtr->dest_loc.x);
+		read_16s(fh, &FleetPtr->dest_loc.y);
 
 		UnlockFleetInfo (pQueue, hStarShip);
 	}
 }
 
 static void
-LoadGroupQueue (DECODE_REF fh, QUEUE *pQueue)
+LoadGroupQueue (void *fh, QUEUE *pQueue, DWORD size)
 {
-	COUNT num_links;
-
-	cread_16 (fh, &num_links);
+	COUNT num_links = size / 13;
 
 	while (num_links--)
 	{
 		HIPGROUP hGroup;
 		IP_GROUP *GroupPtr;
-		BYTE tmpb;
-
-		cread_16 (fh, NULL); /* unused; was race_id */
 
 		hGroup = BuildGroup (pQueue, 0);
 		GroupPtr = LockIpGroup (pQueue, hGroup);
 
-		cread_16 (fh, NULL); /* unused; was which_side */
-		cread_8  (fh, NULL); /* unused; was captains_name_index */
-		cread_8  (fh, NULL); /* padding; for savegame compat */
-		cread_16 (fh, &GroupPtr->group_counter);
-		cread_8  (fh, &GroupPtr->race_id);
-		cread_8  (fh, &tmpb); /* was var2 */
-		GroupPtr->sys_loc = LONIBBLE (tmpb);
-		GroupPtr->task = HINIBBLE (tmpb);
-		cread_8  (fh, &GroupPtr->in_system); /* was crew_level */
-		cread_8  (fh, NULL); /* unused; was max_crew */
-		cread_8  (fh, &tmpb); /* was energy_level */
-		GroupPtr->dest_loc = LONIBBLE (tmpb);
-		GroupPtr->orbit_pos = HINIBBLE (tmpb);
-		cread_8  (fh, &GroupPtr->group_id); /* was max_energy */
-		cread_16s(fh, &GroupPtr->loc.x);
-		cread_16s(fh, &GroupPtr->loc.y);
+		read_16 (fh, &GroupPtr->group_counter);
+		read_8  (fh, &GroupPtr->race_id);
+		read_8  (fh, &GroupPtr->sys_loc);
+		read_8  (fh, &GroupPtr->task);
+		read_8  (fh, &GroupPtr->in_system); /* was crew_level */
+		read_8  (fh, &GroupPtr->dest_loc);
+		read_8  (fh, &GroupPtr->orbit_pos);
+		read_8  (fh, &GroupPtr->group_id); /* was max_energy */
+		read_16s(fh, &GroupPtr->loc.x);
+		read_16s(fh, &GroupPtr->loc.y);
 
 		UnlockIpGroup (pQueue, hGroup);
 	}
 }
 
 static void
-LoadEncounter (ENCOUNTER *EncounterPtr, DECODE_REF fh)
+LoadEncounter (ENCOUNTER *EncounterPtr, void *fh)
 {
 	COUNT i;
 
-	cread_ptr (fh); /* useless ptr; HENCOUNTER pred */
 	EncounterPtr->pred = 0;
-	cread_ptr (fh); /* useless ptr; HENCOUNTER succ */
 	EncounterPtr->succ = 0;
-	cread_ptr (fh); /* useless ptr; HELEMENT hElement */
 	EncounterPtr->hElement = 0;
-	cread_16s (fh, &EncounterPtr->transition_state);
-	cread_16s (fh, &EncounterPtr->origin.x);
-	cread_16s (fh, &EncounterPtr->origin.y);
-	cread_16  (fh, &EncounterPtr->radius);
-	// STAR_DESC fields
-	cread_16s (fh, &EncounterPtr->SD.star_pt.x);
-	cread_16s (fh, &EncounterPtr->SD.star_pt.y);
-	cread_8   (fh, &EncounterPtr->SD.Type);
-	cread_8   (fh, &EncounterPtr->SD.Index);
-	cread_16  (fh, NULL); /* alignment padding */
+	read_16s (fh, &EncounterPtr->transition_state);
+	read_16s (fh, &EncounterPtr->origin.x);
+	read_16s (fh, &EncounterPtr->origin.y);
+	read_16  (fh, &EncounterPtr->radius);
+	// former STAR_DESC fields
+	read_16s (fh, &EncounterPtr->loc_pt.x);
+	read_16s (fh, &EncounterPtr->loc_pt.y);
+	read_8   (fh, &EncounterPtr->race_id);
+	read_8   (fh, &EncounterPtr->num_ships);
+	read_8   (fh, &EncounterPtr->flags);
 
 	// Load each entry in the BRIEF_SHIP_INFO array
 	for (i = 0; i < MAX_HYPER_SHIPS; i++)
 	{
 		BRIEF_SHIP_INFO *ShipInfo = &EncounterPtr->ShipList[i];
-		BYTE tmpb;
 
-		cread_16  (fh, NULL); /* useless; was SHIP_INFO.ship_flags */
-		cread_8   (fh, &ShipInfo->race_id);
-		cread_8   (fh, NULL); /* useless; was SHIP_INFO.var2 */
-		// XXX: reading crew as BYTE to maintain savegame compatibility
-		cread_8   (fh, &tmpb);
-		ShipInfo->crew_level = tmpb;
-		cread_8   (fh, &tmpb);
-		ShipInfo->max_crew = tmpb;
-		cread_8   (fh, NULL); /* useless; was SHIP_INFO.energy_level */
-		cread_8   (fh, &ShipInfo->max_energy);
-		cread_16  (fh, NULL); /* useless; was SHIP_INFO.loc.x */
-		cread_16  (fh, NULL); /* useless; was SHIP_INFO.loc.y */
-		cread_32  (fh, NULL); /* useless val; STRING race_strings */
-		cread_ptr (fh); /* useless ptr; FRAME icons */
-		cread_ptr (fh); /* useless ptr; FRAME melee_icon */
+		read_8   (fh, &ShipInfo->race_id);
+		read_16  (fh, &ShipInfo->crew_level);
+		read_16  (fh, &ShipInfo->max_crew);
+		read_8   (fh, &ShipInfo->max_energy);
 	}
-	
+
 	// Load the stuff after the BRIEF_SHIP_INFO array
-	cread_32s (fh, &EncounterPtr->log_x);
-	cread_32s (fh, &EncounterPtr->log_y);
-	
-	// JMS: Let's make savegames work even between different resolution modes.
+	read_32s (fh, &EncounterPtr->log_x);
+	read_32s (fh, &EncounterPtr->log_y);
+
 	EncounterPtr->log_x <<= RESOLUTION_FACTOR;
 	EncounterPtr->log_y <<= RESOLUTION_FACTOR;
 }
 
 static void
-LoadEvent (EVENT *EventPtr, DECODE_REF fh)
+LoadEvent (EVENT *EventPtr, void *fh)
 {
-	cread_ptr (fh); /* useless ptr; HEVENT pred */
 	EventPtr->pred = 0;
-	cread_ptr (fh); /* useless ptr; HEVENT succ */
 	EventPtr->succ = 0;
-	cread_8   (fh, &EventPtr->day_index);
-	cread_8   (fh, &EventPtr->month_index);
-	cread_16  (fh, &EventPtr->year_index);
-	cread_8   (fh, &EventPtr->func_index);
-	cread_8   (fh, NULL); /* padding */
-	cread_16  (fh, NULL); /* padding */
+	read_8   (fh, &EventPtr->day_index);
+	read_8   (fh, &EventPtr->month_index);
+	read_16  (fh, &EventPtr->year_index);
+	read_8   (fh, &EventPtr->func_index);
 }
 
 static void
-DummyLoadQueue (QUEUE *QueuePtr, DECODE_REF fh)
-{
-	/* QUEUE should never actually be loaded since it contains
-	 * purely internal representation and the lists
-	 * involved are actually loaded separately */
-	(void)QueuePtr; /* silence compiler */
-
-	/* QUEUE format with QUEUE_TABLE defined -- UQM default */
-	cread_ptr (fh); /* HLINK head */
-	cread_ptr (fh); /* HLINK tail */
-	cread_ptr (fh); /* BYTE* pq_tab */
-	cread_ptr (fh); /* HLINK free_list */
-	cread_16  (fh, NULL); /* MEM_HANDLE hq_tab */
-	cread_16  (fh, NULL); /* COUNT object_size */
-	cread_8   (fh, NULL); /* BYTE num_objects */
-	
-	cread_8   (fh, NULL); /* padding */
-	cread_16  (fh, NULL); /* padding */
-}
-
-static void
-LoadClockState (CLOCK_STATE *ClockPtr, DECODE_REF fh)
+LoadClockState (CLOCK_STATE *ClockPtr, void *fh)
 {
-	cread_8   (fh, &ClockPtr->day_index);
-	cread_8   (fh, &ClockPtr->month_index);
-	cread_16  (fh, &ClockPtr->year_index);
-	cread_16s (fh, &ClockPtr->tick_count);
-	cread_16s (fh, &ClockPtr->day_in_ticks);
-	cread_ptr (fh); /* not loading ptr; Semaphore clock_sem */
-	cread_ptr (fh); /* not loading ptr; Task clock_task */
-	cread_32  (fh, NULL); /* not loading; DWORD TimeCounter */
-
-	DummyLoadQueue (&ClockPtr->event_q, fh);
+	read_8   (fh, &ClockPtr->day_index);
+	read_8   (fh, &ClockPtr->month_index);
+	read_16  (fh, &ClockPtr->year_index);
+	read_16s (fh, &ClockPtr->tick_count);
+	read_16s (fh, &ClockPtr->day_in_ticks);
 }
 
 static BOOLEAN
-LoadGameState (GAME_STATE *GSPtr, DECODE_REF fh, BOOLEAN vanilla)
+LoadGameState (GAME_STATE *GSPtr, void *fh)
 {
-	BYTE dummy8;
+	DWORD magic;
 	BYTE res_scale; // JMS
-
-	cread_8   (fh, &dummy8); /* obsolete */
-	cread_8   (fh, &GSPtr->glob_flags);
-	cread_8   (fh, &GSPtr->CrewCost);
-	cread_8   (fh, &GSPtr->FuelCost);
-	
+	read_32 (fh, &magic);
+	if (magic != GLOBAL_STATE_TAG)
+	{
+		return FALSE;
+	}
+	read_32 (fh, &magic);
+	if (magic != 75)
+	{
+		/* Chunk is the wrong size. */
+		return FALSE;
+	}
+	read_8   (fh, &GSPtr->glob_flags);
+	read_8   (fh, &GSPtr->CrewCost);
+	read_8   (fh, &GSPtr->FuelCost);
 	// JMS: Now that we have read the fuelcost, we can compare it
 	// to the correct value. Fuel cost is always FUEL_COST_RU, and if
 	// the savefile tells otherwise, we have read it with the wrong method
@@ -454,74 +321,93 @@ LoadGameState (GAME_STATE *GSPtr, DECODE
 	// and re-open it again, this time using the vanilla-reading method.
 	if (GSPtr->FuelCost != FUEL_COST_RU)
 		return FALSE;
-	
-	cread_a8  (fh, GSPtr->ModuleCost, NUM_MODULES);
-	cread_a8  (fh, GSPtr->ElementWorth, NUM_ELEMENT_CATEGORIES);
-	cread_ptr (fh); /* not loading ptr; PRIMITIVE *DisplayArray */
-	cread_16  (fh, &GSPtr->CurrentActivity);
-	
+	read_a8  (fh, GSPtr->ModuleCost, NUM_MODULES);
+	read_a8  (fh, GSPtr->ElementWorth, NUM_ELEMENT_CATEGORIES);
+	read_16  (fh, &GSPtr->CurrentActivity);
+
 	// JMS
 	if (LOBYTE (GSPtr->CurrentActivity) != IN_INTERPLANETARY)
 		res_scale = RESOLUTION_FACTOR;
 	else
 		res_scale = 0;
-	
-	cread_16  (fh, NULL); /* CLOCK_STATE alignment padding */
+
 	LoadClockState (&GSPtr->GameClock, fh);
 
-	cread_16s (fh, &GSPtr->autopilot.x);
-	cread_16s (fh, &GSPtr->autopilot.y);
-	cread_16s (fh, &GSPtr->ip_location.x);
-	cread_16s (fh, &GSPtr->ip_location.y);
+	read_16s (fh, &GSPtr->autopilot.x);
+	read_16s (fh, &GSPtr->autopilot.y);
+	read_16s (fh, &GSPtr->ip_location.x);
+	read_16s (fh, &GSPtr->ip_location.y);
 	/* STAMP ShipStamp */
-	cread_16s (fh, &GSPtr->ShipStamp.origin.x);
-	cread_16s (fh, &GSPtr->ShipStamp.origin.y);
-	cread_16  (fh, &GSPtr->ShipFacing);
-	cread_8   (fh, &GSPtr->ip_planet);
-	cread_8   (fh, &GSPtr->in_orbit);
-	
-	GSPtr->ShipStamp.origin.x <<= RESOLUTION_FACTOR; // JMS: Let's make savegames work even between different resolution modes.
-	GSPtr->ShipStamp.origin.y <<= RESOLUTION_FACTOR; // JMS: Let's make savegames work even between different resolution modes.
+	read_16s (fh, &GSPtr->ShipStamp.origin.x);
+	read_16s (fh, &GSPtr->ShipStamp.origin.y);
+	read_16  (fh, &GSPtr->ShipFacing);
+	read_8   (fh, &GSPtr->ip_planet);
+	read_8   (fh, &GSPtr->in_orbit);
 
+	// JMS: Let's make savegames work even between different resolution modes.
+	GSPtr->ShipStamp.origin.x <<= RESOLUTION_FACTOR; 
+	GSPtr->ShipStamp.origin.y <<= RESOLUTION_FACTOR; 
 	/* VELOCITY_DESC velocity */
-	cread_16  (fh, &GSPtr->velocity.TravelAngle);
-	cread_16s (fh, &GSPtr->velocity.vector.width);
-	cread_16s (fh, &GSPtr->velocity.vector.height);
-	cread_16s (fh, &GSPtr->velocity.fract.width);
-	cread_16s (fh, &GSPtr->velocity.fract.height);
-	cread_16s (fh, &GSPtr->velocity.error.width);
-	cread_16s (fh, &GSPtr->velocity.error.height);
-	cread_16s (fh, &GSPtr->velocity.incr.width);
-	cread_16s (fh, &GSPtr->velocity.incr.height);
-	cread_16  (fh, NULL); /* VELOCITY_DESC padding */
-	
-	GSPtr->velocity.vector.width  <<= res_scale; // JMS: Let's make savegames work even between different resolution modes.
-	GSPtr->velocity.vector.height <<= res_scale; // JMS: Let's make savegames work even between different resolution modes.
-	GSPtr->velocity.fract.width	  <<= res_scale; // JMS: Let's make savegames work even between different resolution modes.
-	GSPtr->velocity.fract.height  <<= res_scale; // JMS: Let's make savegames work even between different resolution modes.
-	GSPtr->velocity.error.width	  <<= res_scale; // JMS: Let's make savegames work even between different resolution modes.
-	GSPtr->velocity.error.height  <<= res_scale; // JMS: Let's make savegames work even between different resolution modes.
-	GSPtr->velocity.incr.width	  <<= res_scale; // JMS: Let's make savegames work even between different resolution modes.
-	GSPtr->velocity.incr.height	  <<= res_scale; // JMS: Let's make savegames work even between different resolution modes.
+	read_16  (fh, &GSPtr->velocity.TravelAngle);
+	read_16s (fh, &GSPtr->velocity.vector.width);
+	read_16s (fh, &GSPtr->velocity.vector.height);
+	read_16s (fh, &GSPtr->velocity.fract.width);
+	read_16s (fh, &GSPtr->velocity.fract.height);
+	read_16s (fh, &GSPtr->velocity.error.width);
+	read_16s (fh, &GSPtr->velocity.error.height);
+	read_16s (fh, &GSPtr->velocity.incr.width);
+	read_16s (fh, &GSPtr->velocity.incr.height);
 
-	cread_32  (fh, &GSPtr->BattleGroupRef);
-	
-	DummyLoadQueue (&GSPtr->avail_race_q, fh);
-	DummyLoadQueue (&GSPtr->npc_built_ship_q, fh);
-	// Not loading ip_group_q, was not there originally
-	DummyLoadQueue (&GSPtr->encounter_q, fh);
-	DummyLoadQueue (&GSPtr->built_ship_q, fh);
-
-	// JMS: Let's not read the 'autopilot ok' and QS portal
-	// coord bits for vanilla UQM saves.
-	if (vanilla)
-		cread_a8  (fh, GSPtr->GameState, (sizeof (GSPtr->GameState) - 2));
-	else
-		cread_a8  (fh, GSPtr->GameState, sizeof (GSPtr->GameState));
+	// JMS: Let's make savegames work even between different resolution modes.
+	GSPtr->velocity.vector.width  <<= res_scale; 
+	GSPtr->velocity.vector.height <<= res_scale; 
+	GSPtr->velocity.fract.width	  <<= res_scale; 
+	GSPtr->velocity.fract.height  <<= res_scale; 
+	GSPtr->velocity.error.width	  <<= res_scale; 
+	GSPtr->velocity.error.height  <<= res_scale; 
+	GSPtr->velocity.incr.width	  <<= res_scale; 
+	GSPtr->velocity.incr.height	  <<= res_scale; 
+	read_32 (fh, &magic);
+	if (magic != GAME_STATE_TAG)
+	{
+		return FALSE;
+	}
+	{
+		size_t gameStateByteCount = (NUM_GAME_STATE_BITS + 7) >> 3;
+		BYTE *buf;
+		BOOLEAN result;
 
-	//assert (sizeof (GSPtr->GameState) % 4 == 1);
-	cread_8  (fh, NULL); /* GAME_STATE alignment padding */
-	
+		read_32 (fh, &magic);
+		if (magic < gameStateByteCount)
+		{
+			log_add (log_Error, "Warning: Savegame is corrupt: saved game "
+					"state is too small.");
+			return FALSE;
+		}
+
+		buf = HMalloc (gameStateByteCount);
+		if (buf == NULL)
+		{
+			log_add (log_Error, "Warning: Cannot allocate enough bytes for "
+					"the saved game state (%zu bytes).", gameStateByteCount);
+			return FALSE;
+		}
+
+		read_a8 (fh, buf, gameStateByteCount);
+		result = deserialiseGameState (gameStateBitMap, buf,
+				gameStateByteCount);
+		HFree(buf);
+		if (result == FALSE)
+		{
+			// An error message is already printed.
+			return FALSE;
+		}
+
+		if (magic > gameStateByteCount)
+		{
+			skip_8 (fh, magic - gameStateByteCount);
+		}
+	}
 	return TRUE;
 }
 
@@ -544,13 +430,10 @@ LoadSisState (SIS_STATE *SSPtr, void *fp
 
 			read_str (fp, SSPtr->ShipName, SIS_NAME_SIZE) != 1 ||
 			read_str (fp, SSPtr->CommanderName, SIS_NAME_SIZE) != 1 ||
-			read_str (fp, SSPtr->PlanetName, SIS_NAME_SIZE) != 1 ||
-
-			read_16  (fp, NULL) != 1 /* padding */
+			read_str (fp, SSPtr->PlanetName, SIS_NAME_SIZE) != 1
 		)
 		return FALSE;
-	else
-	{
+ 	else {
 		// JMS: Let's make savegames work even between different resolution modes.
 		SSPtr->log_x <<= RESOLUTION_FACTOR;
 		SSPtr->log_y <<= RESOLUTION_FACTOR;
@@ -558,135 +441,29 @@ LoadSisState (SIS_STATE *SSPtr, void *fp
 	}
 }
 
-void
-LoadProblemMessage ()
+static BOOLEAN
+LoadSummary (SUMMARY_DESC *SummPtr, void *fp)
 {
-#define MAX_MSG_LINES 2
-	COUNT i;
-	RECT r;
-	TEXT t;
-	UNICODE *ppStr[MAX_MSG_LINES];
-	ppStr[0] = GAME_STRING (SAVEGAME_STRING_BASE + 7);
-	ppStr[1] = GAME_STRING (SAVEGAME_STRING_BASE + 8);
-	
-	SetContextFont (StarConFont);
-	
-	t.baseline.x = t.baseline.y = 0;
-	t.align = ALIGN_CENTER;
-	
-	for (i = 0; i < MAX_MSG_LINES; ++i)
-	{
-		RECT tr;
-
-		t.pStr = ppStr[i];
-		if (*t.pStr == '\0')
-			break;
-		t.CharCount = (COUNT)~0;
-		TextRect (&t, &tr, NULL);
-		if (i == 0)
-			r = tr;
-		else
-			BoxUnion (&tr, &r, &r);
-		t.baseline.y += (11 << RESOLUTION_FACTOR);
-	}
-		
-	t.baseline.x = ((SIS_SCREEN_WIDTH >> 1) - (r.extent.width >> 1))
-		- r.corner.x;
-	t.baseline.y = ((SIS_SCREEN_HEIGHT >> 1) - (r.extent.height >> 1))
-		- r.corner.y;
-	
-	r.corner.x += t.baseline.x - (4 << RESOLUTION_FACTOR);
-	r.corner.y += t.baseline.y - (4 << RESOLUTION_FACTOR);
-	r.extent.width += (8 << RESOLUTION_FACTOR);
-	r.extent.height += (8 << RESOLUTION_FACTOR);
-	
-	BatchGraphics ();
-	DrawStarConBox (&r, 2,
-					BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19),
-					BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F),
-					TRUE, BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
-	SetContextForeGroundColor (
-		BUILD_COLOR (MAKE_RGB15 (0x14, 0x14, 0x14), 0x0F));
-	
-	for (i = 0; i < MAX_MSG_LINES; ++i)
+	SDWORD magic;
+	DWORD nameSize = 0;
+	if (!read_32s (fp, &magic))
+		return FALSE;
+	if (magic == SAVEFILE_TAG)
 	{
-		t.pStr = ppStr[i];
-		if (*t.pStr == '\0')
-			break;
-		t.CharCount = (COUNT)~0;
-		font_DrawText (&t);
-		t.baseline.y += (11 << RESOLUTION_FACTOR);
+		if (read_32 (fp, &magic) != 1 || magic != SUMMARY_TAG)
+			return FALSE;
+		if (read_32 (fp, &magic) != 1 || magic < 160)
+			return FALSE;
+		nameSize = magic - 160;
 	}
-	
-	UnbatchGraphics ();
-}
-
-static BOOLEAN
-LoadSummary (SUMMARY_DESC *SummPtr, void *fp, BOOLEAN try_vanilla)
-{
-	// JMS: New variables required for compatibility between
-	// old, unnamed saves and the new, named ones.
-	SDWORD  temp_log_x = 0;
-	SDWORD  temp_log_y = 0;
-	DWORD   temp_ru    = 0;
-	DWORD   temp_fuel  = 0;
-	BOOLEAN no_savename = FALSE;
-	
-	// First we check if there is a savegamename identifier.
-	// The identifier tells us whether the name exists at all.
-	read_str (fp, SummPtr->SaveNameChecker, SAVE_CHECKER_SIZE);
-		
-	// If the name doesn't exist (because this most probably
-	// is a savegame from an older version), we have to rewind the
-	// savefile to be able to read the saved variables into their
-	// correct places.
-	if (strncmp(SummPtr->SaveNameChecker, SAVE_NAME_CHECKER, SAVE_CHECKER_SIZE))
-	{
-		COUNT i;
-			
-		// Apparently the bytes read to SummPtr->SaveNameChecker with
-		// read_str are destroyed from fp, so we must copy these bytes
-		// to temp variables at this point to preserve them.
-		no_savename = TRUE;
-		memcpy(&temp_log_x, SummPtr->SaveNameChecker, sizeof(SDWORD));
-		memcpy(&temp_log_y, &(SummPtr->SaveNameChecker[sizeof(SDWORD)]), sizeof(SDWORD));
-		memcpy(&temp_ru, &(SummPtr->SaveNameChecker[2 * sizeof(SDWORD)]), sizeof(DWORD));
-		memcpy(&temp_fuel, &(SummPtr->SaveNameChecker[2 * sizeof(SDWORD)+ sizeof(DWORD)]), sizeof(DWORD));
-			
-		// Rewind the position in savefile.
-		for (i = 0; i < SAVE_CHECKER_SIZE; i++)
-			uio_backtrack (1, (uio_Stream *) fp);
-			
-		// Zero the bogus savenamechecker.
-		for (i = 0; i < SAVE_CHECKER_SIZE; i++)
-			SummPtr->SaveNameChecker[i] = 0;
-			
-		// Make sure the save's name is empty.
-		for (i = 0; i < SAVE_NAME_SIZE; i++)
-			SummPtr->SaveName[i] = 0;
-		}
 	else
 	{
-		// If the name identifier exists, let's also read
-		// the savegame's actual name, which is situated right
-		// after the identifier.
-		read_str (fp, SummPtr->SaveName, SAVE_NAME_SIZE);
+		return FALSE;
 	}
-		
-	//log_add (log_Debug, "fp: %d Check:%s Name:%s", fp, SummPtr->SaveNameChecker, SummPtr->SaveName);
-	
+
 	if (!LoadSisState (&SummPtr->SS, fp))
 		return FALSE;
-		
-	// JMS: Now we'll put those temp variables into action.
-	if (no_savename)
-	{
-		SummPtr->SS.log_x = temp_log_x;
-		SummPtr->SS.log_y = temp_log_y;
-		SummPtr->SS.ResUnits = temp_ru;
-		SummPtr->SS.FuelOnBoard = temp_fuel;
-	}
-	
+
 	if (
 			read_8  (fp, &SummPtr->Activity) != 1 ||
 			read_8  (fp, &SummPtr->Flags) != 1 ||
@@ -699,56 +476,248 @@ LoadSummary (SUMMARY_DESC *SummPtr, void
 			read_8  (fp, &SummPtr->NumDevices) != 1 ||
 			read_a8 (fp, SummPtr->ShipList, MAX_BUILT_SHIPS) != 1 ||
 			read_a8 (fp, SummPtr->DeviceList, MAX_EXCLUSIVE_DEVICES) != 1 ||
-			read_8  (fp, &SummPtr->res_factor) != 1 || // JMS: This'll help making saves between different resolutions compatible.
-		
-			read_8  (fp, NULL) != 1 /* padding */
+			read_8  (fp, &SummPtr->res_factor) != 1 // JMS: This'll help making saves between different resolutions compatible.		
 		)
 		return FALSE;
+	
+	if (nameSize < SAVE_NAME_SIZE)
+	{
+		if (read_a8 (fp, SummPtr->SaveName, nameSize) != 1)
+			return FALSE;
+		SummPtr->SaveName[nameSize] = 0;
+	}
 	else
 	{
-		// JMS: UQM-HD saves have an extra piece of padding to compensate for the
-		// added res_factor in SummPtr.
-		if (!try_vanilla)
-			read_8 (fp, NULL); /* padding */
-	
-		return TRUE;
+		DWORD remaining = nameSize - SAVE_NAME_SIZE + 1;
+		if (read_a8 (fp, SummPtr->SaveName, SAVE_NAME_SIZE-1) != 1)
+			return FALSE;
+		SummPtr->SaveName[SAVE_NAME_SIZE-1] = 0;
+		if (skip_8 (fp, remaining) != 1)
+			return FALSE;
 	}
+
+	// JMS: UQM-HD saves have an extra piece of padding to compensate for the
+	// added res_factor in SummPtr.
+	//read_8 (fp, NULL); /* padding */
+
+	return TRUE;
 }
 
 static void
-LoadStarDesc (STAR_DESC *SDPtr, DECODE_REF fh)
+LoadStarDesc (STAR_DESC *SDPtr, void *fh)
 {
-	cread_16s(fh, &SDPtr->star_pt.x);
-	cread_16s(fh, &SDPtr->star_pt.y);
-	cread_8  (fh, &SDPtr->Type);
-	cread_8  (fh, &SDPtr->Index);
-	cread_8  (fh, &SDPtr->Prefix);
-	cread_8  (fh, &SDPtr->Postfix);
+	read_16s(fh, &SDPtr->star_pt.x);
+	read_16s(fh, &SDPtr->star_pt.y);
+	read_8  (fh, &SDPtr->Type);
+	read_8  (fh, &SDPtr->Index);
+	read_8  (fh, &SDPtr->Prefix);
+	read_8  (fh, &SDPtr->Postfix);
+}
+
+static void
+LoadScanInfo (uio_Stream *fh, DWORD flen)
+{
+	GAME_STATE_FILE *fp = OpenStateFile (STARINFO_FILE, "wb");
+	if (fp)
+	{
+		while (flen)
+		{
+			DWORD val;
+			read_32 (fh, &val);
+			swrite_32 (fp, val);
+			flen -= 4;
+		}
+		CloseStateFile (fp);
+	}
+}
+
+static void
+LoadGroupList (uio_Stream *fh, DWORD chunksize)
+{
+	GAME_STATE_FILE *fp = OpenStateFile (RANDGRPINFO_FILE, "rb");
+	if (fp)
+	{
+		GROUP_HEADER h;
+		BYTE LastEnc, NumGroups;
+		int i;
+		ReadGroupHeader (fp, &h);
+		/* There's only supposed to be one of these, so group 0 should be
+		 * zero here whenever we're here. We add the group list to the
+		 * end here. */
+		h.GroupOffset[0] = LengthStateFile (fp);
+		SeekStateFile (fp, 0, SEEK_SET);
+		WriteGroupHeader (fp, &h);
+		SeekStateFile (fp, h.GroupOffset[0], SEEK_SET);
+		read_8 (fh, &LastEnc);
+		NumGroups = (chunksize - 1) / 14;
+		swrite_8 (fp, LastEnc);
+		swrite_8 (fp, NumGroups);
+		for (i = 0; i < NumGroups; ++i)
+		{
+			BYTE race_outer;
+			IP_GROUP ip;
+			read_8  (fh, &race_outer);
+			read_16 (fh, &ip.group_counter);
+			read_8  (fh, &ip.race_id);
+			read_8  (fh, &ip.sys_loc);
+			read_8  (fh, &ip.task);
+			read_8  (fh, &ip.in_system);
+			read_8  (fh, &ip.dest_loc);
+			read_8  (fh, &ip.orbit_pos);
+			read_8  (fh, &ip.group_id);
+			read_16 (fh, &ip.loc.x);
+			read_16 (fh, &ip.loc.y);
+
+			swrite_8 (fp, race_outer);
+			WriteIpGroup (fp, &ip);
+		}
+		CloseStateFile (fp);
+	}
+}
+
+static void
+SetBattleGroupOffset (int encounterIndex, DWORD offset)
+{
+	// The reason for this switch, even though the group offsets are
+	// successive, is because SET_GAME_STATE is a #define, which stringizes
+	// its first argument.
+	switch (encounterIndex)
+	{
+		case  1: SET_GAME_STATE (SHOFIXTI_GRPOFFS,     offset); break;
+		case  2: SET_GAME_STATE (ZOQFOT_GRPOFFS,       offset); break;
+		case  3: SET_GAME_STATE (MELNORME0_GRPOFFS,    offset); break;
+		case  4: SET_GAME_STATE (MELNORME1_GRPOFFS,    offset); break;
+		case  5: SET_GAME_STATE (MELNORME2_GRPOFFS,    offset); break;
+		case  6: SET_GAME_STATE (MELNORME3_GRPOFFS,    offset); break;
+		case  7: SET_GAME_STATE (MELNORME4_GRPOFFS,    offset); break;
+		case  8: SET_GAME_STATE (MELNORME5_GRPOFFS,    offset); break;
+		case  9: SET_GAME_STATE (MELNORME6_GRPOFFS,    offset); break;
+		case 10: SET_GAME_STATE (MELNORME7_GRPOFFS,    offset); break;
+		case 11: SET_GAME_STATE (MELNORME8_GRPOFFS,    offset); break;
+		case 12: SET_GAME_STATE (URQUAN_PROBE_GRPOFFS, offset); break;
+		case 13: SET_GAME_STATE (COLONY_GRPOFFS,       offset); break;
+		case 14: SET_GAME_STATE (SAMATRA_GRPOFFS,      offset); break;
+		default:
+			log_add (log_Warning, "SetBattleGroupOffset: invalid encounter "
+					"index.\n");
+			break;
+	}
+}
+
+static void
+LoadBattleGroup (uio_Stream *fh, DWORD chunksize)
+{
+	GAME_STATE_FILE *fp;
+	GROUP_HEADER h;
+	DWORD encounter, offset;
+	BYTE current;
+	int i;
+
+	read_32 (fh, &encounter);
+	read_8 (fh, &current);
+	chunksize -= 5;
+	if (encounter)
+	{
+		/* This is a defined group, so it's new */
+		fp = OpenStateFile (DEFGRPINFO_FILE, "rb");
+		offset = LengthStateFile (fp);
+		memset (&h, 0, sizeof (GROUP_HEADER));
+	}
+	else
+	{
+		/* This is the random group. Load in what was there,
+		 * as we might have already seen the Group List. */
+		fp = OpenStateFile (RANDGRPINFO_FILE, "rb");
+		current = FALSE;
+		offset = 0;
+		ReadGroupHeader (fp, &h);
+	}
+	if (!fp)
+	{
+		skip_8 (fh, chunksize);
+		return;
+	}
+	read_16 (fh, &h.star_index);
+	read_8  (fh, &h.day_index);
+	read_8  (fh, &h.month_index);
+	read_16 (fh, &h.year_index);
+	read_8  (fh, &h.NumGroups);
+	chunksize -= 7;
+	/* Write out the half-finished state file so that we can use
+	 * the file size to compute group offsets */
+	SeekStateFile (fp, offset, SEEK_SET);
+	WriteGroupHeader (fp, &h);
+	for (i = 1; i <= h.NumGroups; ++i)
+	{
+		int j;
+		BYTE icon, NumShips;
+		read_8 (fh, &icon);
+		read_8 (fh, &NumShips);
+		chunksize -= 2;
+		h.GroupOffset[i] = LengthStateFile (fp);
+		SeekStateFile (fp, h.GroupOffset[i], SEEK_SET);
+		swrite_8 (fp, icon);
+		swrite_8 (fp, NumShips);
+		for (j = 0; j < NumShips; ++j)
+		{
+			BYTE race_outer;
+			SHIP_FRAGMENT sf;
+			read_8  (fh, &race_outer);
+			read_8  (fh, &sf.captains_name_index);
+			read_8  (fh, &sf.race_id);
+			read_8  (fh, &sf.index);
+			read_16 (fh, &sf.crew_level);
+			read_16 (fh, &sf.max_crew);
+			read_8  (fh, &sf.energy_level);
+			read_8  (fh, &sf.max_energy);
+			chunksize -= 10;
+
+			swrite_8 (fp, race_outer);
+			WriteShipFragment (fp, &sf);
+		}
+	}
+	/* Now that the GroupOffset array is properly initialized,
+	 * write the header back out. */
+	SeekStateFile (fp, offset, SEEK_SET);
+	WriteGroupHeader (fp, &h);
+	CloseStateFile (fp);
+	/* And update the gamestate accordingly, if we're a defined group. */
+	if (encounter)
+	{
+		SetBattleGroupOffset (encounter, offset);
+		if (current)
+		{
+			GLOBAL (BattleGroupRef) = offset;
+		}
+	}
+	/* Consistency check. */
+	if (chunksize)
+	{
+		log_add (log_Warning, "BattleGroup chunk mis-sized!");
+	}
 }
 
 BOOLEAN
-LoadGame (COUNT which_game, SUMMARY_DESC *SummPtr, BOOLEAN try_vanilla)
+LoadGame (COUNT which_game, SUMMARY_DESC *SummPtr)
 {
 	uio_Stream *in_fp;
 	char file[PATH_MAX];
-	char buf[256];
 	SUMMARY_DESC loc_sd;
-	GAME_STATE_FILE *fp;
-	DECODE_REF fh;
 	COUNT num_links;
 	STAR_DESC SD;
 	ACTIVITY Activity;
+	DWORD chunk, chunkSize;
+	BOOLEAN first_group_spec = TRUE;
 
-	sprintf (file, "starcon2.%02u", which_game);
+	sprintf (file, "uqmsave.%02u", which_game);
 	in_fp = res_OpenResFile (saveDir, file, "rb");
 	if (!in_fp)
-		return FALSE;
+		return LoadLegacyGame (which_game, SummPtr);
 
-	if (!LoadSummary (&loc_sd, in_fp, try_vanilla))
+	if (!LoadSummary (&loc_sd, in_fp))
 	{
-		log_add (log_Error, "Warning: Savegame is corrupt");
 		res_CloseResFile (in_fp);
-		return FALSE;
+		return LoadLegacyGame (which_game, SummPtr);
 	}
 
 	if (!SummPtr)
@@ -762,232 +731,131 @@ LoadGame (COUNT which_game, SUMMARY_DESC
 		return TRUE;
 	}
 
-	// Crude check for big-endian/little-endian incompatibilities.
-	// year_index is suitable as it's a multi-byte value within
-	// a specific recognisable range.
-	if (SummPtr->year_index < START_YEAR ||
-			SummPtr->year_index >= START_YEAR +
-			YEARS_TO_KOHRAH_VICTORY + 1 /* Utwig intervention */ +
-			1 /* time to destroy all races, plenty */ +
-			25 /* for cheaters */)
-	{
-		log_add (log_Error, "Warning: Savegame corrupt or from "
-				"an incompatible platform.");
-		res_CloseResFile (in_fp);
-		return FALSE;
-	}
-
 	GlobData.SIS_state = SummPtr->SS;
 
-	if ((fh = copen (in_fp, FILE_STREAM, STREAM_READ)) == 0)
-	{
-		res_CloseResFile (in_fp);
-		return FALSE;
-	}
-
 	ReinitQueue (&GLOBAL (GameClock.event_q));
 	ReinitQueue (&GLOBAL (encounter_q));
 	ReinitQueue (&GLOBAL (ip_group_q));
 	ReinitQueue (&GLOBAL (npc_built_ship_q));
 	ReinitQueue (&GLOBAL (built_ship_q));
+	
+	uninitEventSystem ();
+	luaUqm_uninitState();
+	luaUqm_initState();
+	initEventSystem ();
 
-	memset (&GLOBAL (GameState[0]), 0, sizeof (GLOBAL (GameState)));
 	Activity = GLOBAL (CurrentActivity);
-	
-	// JMS: We can decide whether the current savefile is vanilla UQM or UQM-HD
-	// only at this point, when reading the game states. If this turns out to be a 
-	// vanilla UQM save, we must close the file and re-open it for reading
-	// with the vanilla method.
-	if (!(LoadGameState (&GlobData.Game_state, fh, try_vanilla)))
+	if (!LoadGameState (&GlobData.Game_state, in_fp))
 	{
 		res_CloseResFile (in_fp);
-		
-		if (!try_vanilla)
-		{
-			LoadGame (which_game, NULL, TRUE);
-			return TRUE;
-		}
-		else
-			return FALSE;
+		return FALSE;
 	}
-	
 	NextActivity = GLOBAL (CurrentActivity);
 	GLOBAL (CurrentActivity) = Activity;
 
-	LoadRaceQueue (fh, &GLOBAL (avail_race_q));
-	// START_INTERPLANETARY is only set when saving from Homeworld
-	//   encounter screen. When the game is loaded, the
-	//   GenerateOrbitalFunction for the current star system will
-	//   create the encounter anew and populate the npc queue.
-	if (!(NextActivity & START_INTERPLANETARY))
-	{
-		if (NextActivity & START_ENCOUNTER)
-			LoadShipQueue (fh, &GLOBAL (npc_built_ship_q));
-		else if (LOBYTE (NextActivity) == IN_INTERPLANETARY)
-			// XXX: Technically, this queue does not need to be
-			//   saved/loaded at all. IP groups will be reloaded
-			//   from group state files. But the original code did,
-			//   and so will we until we can prove we do not need to.
-			LoadGroupQueue (fh, &GLOBAL (ip_group_q));
-		else
-			// XXX: The empty queue read is only needed to maintain
-			//   the savegame compatibility
-			LoadEmptyQueue (fh);
-	}
-	LoadShipQueue (fh, &GLOBAL (built_ship_q));
-
-	// Load the game events (compressed)
-	cread_16 (fh, &num_links);
-	{
-#ifdef DEBUG_LOAD
-		log_add (log_Debug, "EVENTS:");
-#endif /* DEBUG_LOAD */
-		while (num_links--)
-		{
-			HEVENT hEvent;
-			EVENT *EventPtr;
-
-			hEvent = AllocEvent ();
-			LockEvent (hEvent, &EventPtr);
-
-			LoadEvent (EventPtr, fh);
-
-#ifdef DEBUG_LOAD
-		log_add (log_Debug, "\t%u/%u/%u -- %u",
-				EventPtr->month_index,
-				EventPtr->day_index,
-				EventPtr->year_index,
-				EventPtr->func_index);
-#endif /* DEBUG_LOAD */
-			UnlockEvent (hEvent);
-			PutEvent (hEvent);
-		}
-	}
-
-	// Load the encounters (black globes in HS/QS (compressed))
-	cread_16 (fh, &num_links);
+	chunk = 0;
+	while (TRUE)
 	{
-		while (num_links--)
+		if (read_32(in_fp, &chunk) != 1)
 		{
-			HENCOUNTER hEncounter;
-			ENCOUNTER *EncounterPtr;
-
-			hEncounter = AllocEncounter ();
-			LockEncounter (hEncounter, &EncounterPtr);
-
-			LoadEncounter (EncounterPtr, fh);
-
-			UnlockEncounter (hEncounter);
-			PutEncounter (hEncounter);
+			break;
 		}
-	}
-
-	// Copy the star info file from the compressed stream
-	fp = OpenStateFile (STARINFO_FILE, "wb");
-	if (fp)
-	{
-		DWORD flen;
-
-		cread_32 (fh, &flen);
-		while (flen)
+		if (read_32(in_fp, &chunkSize) != 1)
 		{
-			COUNT num_bytes;
-
-			num_bytes = flen >= sizeof (buf) ? sizeof (buf) : (COUNT)flen;
-			cread (buf, num_bytes, 1, fh);
-			WriteStateFile (buf, num_bytes, 1, fp);
-
-			flen -= num_bytes;
+			res_CloseResFile (in_fp);
+			return FALSE;
 		}
-		CloseStateFile (fp);
-	}
-
-	// Copy the defined groupinfo file from the compressed stream
-	fp = OpenStateFile (DEFGRPINFO_FILE, "wb");
-	if (fp)
-	{
-		DWORD flen;
-
-		cread_32 (fh, &flen);
-		while (flen)
+		switch (chunk)
 		{
-			COUNT num_bytes;
-
-			num_bytes = flen >= sizeof (buf) ? sizeof (buf) : (COUNT)flen;
-			cread (buf, num_bytes, 1, fh);
-			WriteStateFile (buf, num_bytes, 1, fp);
-
-			flen -= num_bytes;
-		}
-		CloseStateFile (fp);
-	}
-
-	// Copy the random groupinfo file from the compressed stream
-	fp = OpenStateFile (RANDGRPINFO_FILE, "wb");
-	if (fp)
-	{
-		DWORD flen;
+		case RACE_Q_TAG:
+			LoadRaceQueue (in_fp, &GLOBAL (avail_race_q), chunkSize);
+			break;
+		case IP_GRP_Q_TAG:
+			LoadGroupQueue (in_fp, &GLOBAL (ip_group_q), chunkSize);
+			break;
+		case ENCOUNTERS_TAG:
+			num_links = chunkSize / 65;
+			while (num_links--)
+			{
+				HENCOUNTER hEncounter;
+				ENCOUNTER *EncounterPtr;
+
+				hEncounter = AllocEncounter ();
+				LockEncounter (hEncounter, &EncounterPtr);
+
+				LoadEncounter (EncounterPtr, in_fp);
+
+				UnlockEncounter (hEncounter);
+				PutEncounter (hEncounter);
+			}
+			break;
+		case EVENTS_TAG:
+			num_links = chunkSize / 5;
+#ifdef DEBUG_LOAD
+			log_add (log_Debug, "EVENTS:");
+#endif /* DEBUG_LOAD */
+			while (num_links--)
+			{
+				HEVENT hEvent;
+				EVENT *EventPtr;
 
-		cread_32 (fh, &flen);
-		while (flen)
-		{
-			COUNT num_bytes;
+				hEvent = AllocEvent ();
+				LockEvent (hEvent, &EventPtr);
 
-			num_bytes = flen >= sizeof (buf) ? sizeof (buf) : (COUNT)flen;
-			cread (buf, num_bytes, 1, fh);
-			WriteStateFile (buf, num_bytes, 1, fp);
+				LoadEvent (EventPtr, in_fp);
 
-			flen -= num_bytes;
+#ifdef DEBUG_LOAD
+				log_add (log_Debug, "\t%u/%u/%u -- %u",
+						 EventPtr->month_index,
+						 EventPtr->day_index,
+						 EventPtr->year_index,
+						 EventPtr->func_index);
+#endif /* DEBUG_LOAD */
+				UnlockEvent (hEvent);
+				PutEvent (hEvent);
+			}
+			break;
+		case STAR_TAG:
+			LoadStarDesc (&SD, in_fp);			
+			loadGameCheats();
+			break;
+		case NPC_SHIP_Q_TAG:
+			LoadShipQueue (in_fp, &GLOBAL (npc_built_ship_q), chunkSize);
+			break;
+		case SHIP_Q_TAG:
+			LoadShipQueue (in_fp, &GLOBAL (built_ship_q), chunkSize);
+			break;
+		case SCAN_TAG:
+			LoadScanInfo (in_fp, chunkSize);
+			break;
+		case GROUP_LIST_TAG:
+			if (first_group_spec)
+			{
+				InitGroupInfo (TRUE);
+				GLOBAL (BattleGroupRef) = 0;
+				first_group_spec = FALSE;
+			}
+			LoadGroupList (in_fp, chunkSize);
+			break;
+		case BATTLE_GROUP_TAG:
+			if (first_group_spec)
+			{
+				InitGroupInfo (TRUE);
+				GLOBAL (BattleGroupRef) = 0;
+				first_group_spec = FALSE;
+			}
+			LoadBattleGroup (in_fp, chunkSize);
+			break;
+		default:
+			log_add (log_Debug, "Skipping chunk of tag %08X (size %u)", chunk, chunkSize);
+			if (skip_8(in_fp, chunkSize) != 1)
+			{
+				res_CloseResFile (in_fp);
+				return FALSE;
+			}
+			break;
 		}
-		CloseStateFile (fp);
-	}
-
-	LoadStarDesc (&SD, fh);	
-	
-	if(optInfiniteRU){
-		oldRU = GlobData.SIS_state.ResUnits;
-	} else {
-		oldRU = 0;
-	}			
-	if (optUnlockShips){
-		ActivateStarShip (ARILOU_SHIP, ALLOW_BUILD);
-		ActivateStarShip (CHMMR_SHIP, ALLOW_BUILD);
-		ActivateStarShip (ORZ_SHIP, ALLOW_BUILD);
-		ActivateStarShip (PKUNK_SHIP, ALLOW_BUILD);
-		ActivateStarShip (SHOFIXTI_SHIP, ALLOW_BUILD);
-		ActivateStarShip (SPATHI_SHIP, ALLOW_BUILD);
-		ActivateStarShip (SUPOX_SHIP, ALLOW_BUILD);
-		ActivateStarShip (THRADDASH_SHIP, ALLOW_BUILD);
-		ActivateStarShip (UTWIG_SHIP, ALLOW_BUILD);
-		ActivateStarShip (VUX_SHIP, ALLOW_BUILD);
-		ActivateStarShip (YEHAT_SHIP, ALLOW_BUILD);
-		ActivateStarShip (MELNORME_SHIP, ALLOW_BUILD);
-		ActivateStarShip (DRUUGE_SHIP, ALLOW_BUILD);
-		ActivateStarShip (ILWRATH_SHIP, ALLOW_BUILD);
-		ActivateStarShip (MYCON_SHIP, ALLOW_BUILD);
-		ActivateStarShip (SLYLANDRO_SHIP, ALLOW_BUILD);
-		ActivateStarShip (UMGAH_SHIP, ALLOW_BUILD);
-		ActivateStarShip (URQUAN_SHIP, ALLOW_BUILD);
-		ActivateStarShip (ZOQFOTPIK_SHIP, ALLOW_BUILD);
-		ActivateStarShip (SYREEN_SHIP, ALLOW_BUILD);
-		ActivateStarShip (BLACK_URQUAN_SHIP, ALLOW_BUILD);
-	}
-	if (optUnlockUpgrades){
-		SET_GAME_STATE (IMPROVED_LANDER_SPEED, 1);
-		SET_GAME_STATE (IMPROVED_LANDER_CARGO, 1);
-		SET_GAME_STATE (IMPROVED_LANDER_SHOT, 1);
-		SET_GAME_STATE (LANDER_SHIELDS, (1 << EARTHQUAKE_DISASTER) | (1 << BIOLOGICAL_DISASTER) |
-			(1 << LIGHTNING_DISASTER) | (1 << LAVASPOT_DISASTER));				
-		GLOBAL (ModuleCost[ANTIMISSILE_DEFENSE]) = 4000 / MODULE_COST_SCALE;				
-		GLOBAL (ModuleCost[BLASTER_WEAPON]) = 4000 / MODULE_COST_SCALE;
-		GLOBAL (ModuleCost[HIGHEFF_FUELSYS]) = 1000 / MODULE_COST_SCALE;
-		GLOBAL (ModuleCost[TRACKING_SYSTEM]) = 5000 / MODULE_COST_SCALE;
-		GLOBAL (ModuleCost[CANNON_WEAPON]) = 6000 / MODULE_COST_SCALE;
-		GLOBAL (ModuleCost[SHIVA_FURNACE]) = 4000 / MODULE_COST_SCALE;
-		SET_GAME_STATE (MELNORME_TECH_STACK, 13);
 	}
-
-	cclose (fh);
 	res_CloseResFile (in_fp);
 
 	EncounterGroup = 0;
@@ -1001,6 +869,4 @@ LoadGame (COUNT which_game, SUMMARY_DESC
 		NextActivity |= START_INTERPLANETARY;
 
 	return TRUE;
-}
-
-
+}
\ No newline at end of file
diff -ruNp src.hd/uqm/load.h src/uqm/load.h
--- src.hd/uqm/load.h	2017-12-29 02:25:52 -0800
+++ src/uqm/load.h	1969-12-31 16:00:00 -0800
@@ -1,32 +0,0 @@
-/*
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _LOAD_H
-#define _LOAD_H
-
-#include "sis.h"
-		// for SUMMARY_DESC
-#include "libs/compiler.h"
-#include "globdata.h"
-
-extern ACTIVITY NextActivity;
-
-extern BOOLEAN LoadGame (COUNT which_game, SUMMARY_DESC *summary_desc, BOOLEAN try_vanilla);
-extern void LoadProblemMessage ();
-
-
-#endif  /* _LOAD_H */
-
diff -ruNp src.hd/uqm/load_legacy.c src/uqm/load_legacy.c
--- src.hd/uqm/load_legacy.c	1969-12-31 16:00:00 -0800
+++ src/uqm/load_legacy.c	2017-12-29 00:57:46 -0800
@@ -0,0 +1,1189 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <assert.h>
+
+#include "build.h"
+#include "libs/declib.h"
+#include "encount.h"
+#include "gameev.h"
+#include "starmap.h"
+#include "libs/file.h"
+#include "globdata.h"
+#include "options.h"
+#include "save.h"
+#include "setup.h"
+#include "state.h"
+#include "grpinfo.h"
+
+#include "libs/tasklib.h"
+#include "libs/log.h"
+#include "libs/misc.h"
+#include "libs/scriptlib.h"
+
+//#define DEBUG_LOAD
+
+
+// This defines the order and the number of bits in which the game state
+// properties are saved.
+static const GameStateBitMap legacyGameStateBitMap[] = {
+	{ "SHOFIXTI_VISITS", 3 },
+	{ "SHOFIXTI_STACK1", 2 },
+	{ "SHOFIXTI_STACK2", 3 },
+	{ "SHOFIXTI_STACK3", 2 },
+	{ "SHOFIXTI_KIA", 1 },
+	{ "SHOFIXTI_BRO_KIA", 1 },
+	{ "SHOFIXTI_RECRUITED", 1 },
+	{ "SHOFIXTI_MAIDENS", 1 },
+	{ "MAIDENS_ON_SHIP", 1 },
+	{ "BATTLE_SEGUE", 1 },
+	{ "PLANETARY_LANDING", 1 },
+	{ "PLANETARY_CHANGE", 1 },
+	{ "SPATHI_VISITS", 3 },
+	{ "SPATHI_HOME_VISITS", 3 },
+	{ "FOUND_PLUTO_SPATHI", 2 },
+	{ "SPATHI_SHIELDED_SELVES", 1 },
+	{ "SPATHI_CREATURES_EXAMINED", 1 },
+	{ "SPATHI_CREATURES_ELIMINATED", 1 },
+	{ "UMGAH_BROADCASTERS", 1 },
+	{ "SPATHI_MANNER", 2 },
+	{ "SPATHI_QUEST", 1 },
+	{ "LIED_ABOUT_CREATURES", 2 },
+	{ "SPATHI_PARTY", 1 },
+	{ "KNOW_SPATHI_PASSWORD", 1 },
+	{ "ILWRATH_HOME_VISITS", 3 },
+	{ "ILWRATH_CHMMR_VISITS", 1 },
+	{ "ARILOU_SPACE", 1 },
+	{ "ARILOU_SPACE_SIDE", 2 },
+	{ "ARILOU_SPACE_COUNTER", 4 },
+	{ "LANDER_SHIELDS", 4 },
+	{ "SHOFIXTI_GRPOFFS", 32 },
+	{ "ZOQFOT_GRPOFFS", 32 },
+	{ "MELNORME0_GRPOFFS", 32 },
+	{ "MELNORME1_GRPOFFS", 32 },
+	{ "MELNORME2_GRPOFFS", 32 },
+	{ "MELNORME3_GRPOFFS", 32 },
+	{ "MELNORME4_GRPOFFS", 32 },
+	{ "MELNORME5_GRPOFFS", 32 },
+	{ "MELNORME6_GRPOFFS", 32 },
+	{ "MELNORME7_GRPOFFS", 32 },
+	{ "MELNORME8_GRPOFFS", 32 },
+	{ "MET_MELNORME", 1 },
+	{ "MELNORME_RESCUE_REFUSED", 1 },
+	{ "MELNORME_RESCUE_COUNT", 3 },
+	{ "TRADED_WITH_MELNORME", 1 },
+	{ "WHY_MELNORME_PURPLE", 1 },
+	{ "MELNORME_CREDIT0", 8 },
+	{ "MELNORME_CREDIT1", 8 },
+	{ "MELNORME_BUSINESS_COUNT", 2 },
+	{ "MELNORME_YACK_STACK0", 2 },
+	{ "MELNORME_YACK_STACK1", 2 },
+	{ "MELNORME_YACK_STACK2", 4 },
+	{ "MELNORME_YACK_STACK3", 3 },
+	{ "MELNORME_YACK_STACK4", 2 },
+	{ "WHY_MELNORME_BLUE", 1 },
+	{ "MELNORME_ANGER", 2 },
+	{ "MELNORME_MIFFED_COUNT", 2 },
+	{ "MELNORME_PISSED_COUNT", 2 },
+	{ "MELNORME_HATE_COUNT", 2 },
+	{ "URQUAN_PROBE_GRPOFFS", 32 },
+	{ "PROBE_MESSAGE_DELIVERED", 1 },
+	{ "PROBE_ILWRATH_ENCOUNTER", 1 },
+	{ "STARBASE_AVAILABLE", 1 },
+	{ "STARBASE_VISITED", 1 },
+	{ "RADIOACTIVES_PROVIDED", 1 },
+	{ "LANDERS_LOST", 1 },
+	{ "GIVEN_FUEL_BEFORE", 1 },
+	{ "AWARE_OF_SAMATRA", 1 },
+	{ "YEHAT_CAVALRY_ARRIVED", 1 },
+	{ "URQUAN_MESSED_UP", 1 },
+	{ "MOONBASE_DESTROYED", 1 },
+	{ "WILL_DESTROY_BASE", 1 },
+	{ "WIMBLIS_TRIDENT_ON_SHIP", 1 },
+	{ "GLOWING_ROD_ON_SHIP", 1 },
+	{ "KOHR_AH_KILLED_ALL", 1 },
+	{ "STARBASE_YACK_STACK1", 1 },
+	{ "DISCUSSED_PORTAL_SPAWNER", 1 },
+	{ "DISCUSSED_TALKING_PET", 1 },
+	{ "DISCUSSED_UTWIG_BOMB", 1 },
+	{ "DISCUSSED_SUN_EFFICIENCY", 1 },
+	{ "DISCUSSED_ROSY_SPHERE", 1 },
+	{ "DISCUSSED_AQUA_HELIX", 1 },
+	{ "DISCUSSED_CLEAR_SPINDLE", 1 },
+	{ "DISCUSSED_ULTRON", 1 },
+	{ "DISCUSSED_MAIDENS", 1 },
+	{ "DISCUSSED_UMGAH_HYPERWAVE", 1 },
+	{ "DISCUSSED_BURVIX_HYPERWAVE", 1 },
+	{ "SYREEN_WANT_PROOF", 1 },
+	{ "PLAYER_HAVING_SEX", 1 },
+	{ "MET_ARILOU", 1 },
+	{ "DISCUSSED_TAALO_PROTECTOR", 1 },
+	{ "DISCUSSED_EGG_CASING0", 1 },
+	{ "DISCUSSED_EGG_CASING1", 1 },
+	{ "DISCUSSED_EGG_CASING2", 1 },
+	{ "DISCUSSED_SYREEN_SHUTTLE", 1 },
+	{ "DISCUSSED_VUX_BEAST", 1 },
+	{ "DISCUSSED_DESTRUCT_CODE", 1 },
+	{ "DISCUSSED_URQUAN_WARP", 1 },
+	{ "DISCUSSED_ARTIFACT_2", 1 },
+	{ "DISCUSSED_ARTIFACT_3", 1 },
+	{ "ATTACKED_DRUUGE", 1 },
+	{ "NEW_ALLIANCE_NAME", 2 },
+	{ "PORTAL_COUNTER", 4 },
+	{ "BURVIXESE_BROADCASTERS", 1 },
+	{ "BURV_BROADCASTERS_ON_SHIP", 1 },
+	{ "UTWIG_BOMB", 1 },
+	{ "UTWIG_BOMB_ON_SHIP", 1 },
+	{ "AQUA_HELIX", 1 },
+	{ "AQUA_HELIX_ON_SHIP", 1 },
+	{ "SUN_DEVICE", 1 },
+	{ "SUN_DEVICE_ON_SHIP", 1 },
+	{ "TAALO_PROTECTOR", 1 },
+	{ "TAALO_PROTECTOR_ON_SHIP", 1 },
+	{ "SHIP_VAULT_UNLOCKED", 1 },
+	{ "SYREEN_SHUTTLE", 1 },
+	{ "PORTAL_KEY", 1 },
+	{ "PORTAL_KEY_ON_SHIP", 1 },
+	{ "VUX_BEAST", 1 },
+	{ "VUX_BEAST_ON_SHIP", 1 },
+	{ "TALKING_PET", 1 },
+	{ "TALKING_PET_ON_SHIP", 1 },
+	{ "MOONBASE_ON_SHIP", 1 },
+	{ "KOHR_AH_FRENZY", 1 },
+	{ "KOHR_AH_VISITS", 2 },
+	{ "KOHR_AH_BYES", 1 },
+	{ "SLYLANDRO_HOME_VISITS", 3 },
+	{ "DESTRUCT_CODE_ON_SHIP", 1 },
+	{ "ILWRATH_VISITS", 3 },
+	{ "ILWRATH_DECEIVED", 1 },
+	{ "FLAGSHIP_CLOAKED", 1 },
+	{ "MYCON_VISITS", 3 },
+	{ "MYCON_HOME_VISITS", 3 },
+	{ "MYCON_AMBUSH", 1 },
+	{ "MYCON_FELL_FOR_AMBUSH", 1 },
+	{ "GLOBAL_FLAGS_AND_DATA", 8 },
+	{ "ORZ_VISITS", 3 },
+	{ "TAALO_VISITS", 3 },
+	{ "ORZ_MANNER", 2 },
+	{ "PROBE_EXHIBITED_BUG", 1 },
+	{ "CLEAR_SPINDLE_ON_SHIP", 1 },
+	{ "URQUAN_VISITS", 3 },
+	{ "PLAYER_HYPNOTIZED", 1 },
+	{ "VUX_VISITS", 3 },
+	{ "VUX_HOME_VISITS", 3 },
+	{ "ZEX_VISITS", 3 },
+	{ "ZEX_IS_DEAD", 1 },
+	{ "KNOW_ZEX_WANTS_MONSTER", 1 },
+	{ "UTWIG_VISITS", 3 },
+	{ "UTWIG_HOME_VISITS", 3 },
+	{ "BOMB_VISITS", 3 },
+	{ "ULTRON_CONDITION", 3 },
+	{ "UTWIG_HAVE_ULTRON", 1 },
+	{ "BOMB_UNPROTECTED", 1 },
+	{ "TAALO_UNPROTECTED", 1 },
+	{ "TALKING_PET_VISITS", 3 },
+	{ "TALKING_PET_HOME_VISITS", 3 },
+	{ "UMGAH_ZOMBIE_BLOBBIES", 1 },
+	{ "KNOW_UMGAH_ZOMBIES", 1 },
+	{ "ARILOU_VISITS", 3 },
+	{ "ARILOU_HOME_VISITS", 3 },
+	{ "KNOW_ARILOU_WANT_WRECK", 1 },
+	{ "ARILOU_CHECKED_UMGAH", 2 },
+	{ "PORTAL_SPAWNER", 1 },
+	{ "PORTAL_SPAWNER_ON_SHIP", 1 },
+	{ "UMGAH_VISITS", 3 },
+	{ "UMGAH_HOME_VISITS", 3 },
+	{ "MET_NORMAL_UMGAH", 1 },
+	{ "SYREEN_HOME_VISITS", 3 },
+	{ "SYREEN_SHUTTLE_ON_SHIP", 1 },
+	{ "KNOW_SYREEN_VAULT", 1 },
+	{ "EGG_CASE0_ON_SHIP", 1 },
+	{ "SUN_DEVICE_UNGUARDED", 1 },
+	{ "ROSY_SPHERE_ON_SHIP", 1 },
+	{ "CHMMR_HOME_VISITS", 3 },
+	{ "CHMMR_EMERGING", 1 },
+	{ "CHMMR_UNLEASHED", 1 },
+	{ "CHMMR_BOMB_STATE", 2 },
+	{ "DRUUGE_DISCLAIMER", 1 },
+	{ "YEHAT_VISITS", 3 },
+	{ "YEHAT_REBEL_VISITS", 3 },
+	{ "YEHAT_HOME_VISITS", 3 },
+	{ "YEHAT_CIVIL_WAR", 1 },
+	{ "YEHAT_ABSORBED_PKUNK", 1 },
+	{ "YEHAT_SHIP_MONTH", 4 },
+	{ "YEHAT_SHIP_DAY", 5 },
+	{ "YEHAT_SHIP_YEAR", 5 },
+	{ "CLEAR_SPINDLE", 1 },
+	{ "PKUNK_VISITS", 3 },
+	{ "PKUNK_HOME_VISITS", 3 },
+	{ "PKUNK_SHIP_MONTH", 4 },
+	{ "PKUNK_SHIP_DAY", 5 },
+	{ "PKUNK_SHIP_YEAR", 5 },
+	{ "PKUNK_MISSION", 3 },
+	{ "SUPOX_VISITS", 3 },
+	{ "SUPOX_HOME_VISITS", 3 },
+	{ "THRADD_VISITS", 3 },
+	{ "THRADD_HOME_VISITS", 3 },
+	{ "HELIX_VISITS", 3 },
+	{ "HELIX_UNPROTECTED", 1 },
+	{ "THRADD_CULTURE", 2 },
+	{ "THRADD_MISSION", 3 },
+	{ "DRUUGE_VISITS", 3 },
+	{ "DRUUGE_HOME_VISITS", 3 },
+	{ "ROSY_SPHERE", 1 },
+	{ "SCANNED_MAIDENS", 1 },
+	{ "SCANNED_FRAGMENTS", 1 },
+	{ "SCANNED_CASTER", 1 },
+	{ "SCANNED_SPAWNER", 1 },
+	{ "SCANNED_ULTRON", 1 },
+	{ "ZOQFOT_INFO", 2 },
+	{ "ZOQFOT_HOSTILE", 1 },
+	{ "ZOQFOT_HOME_VISITS", 3 },
+	{ "MET_ZOQFOT", 1 },
+	{ "ZOQFOT_DISTRESS", 2 },
+	{ "EGG_CASE1_ON_SHIP", 1 },
+	{ "EGG_CASE2_ON_SHIP", 1 },
+	{ "MYCON_SUN_VISITS", 3 },
+	{ "ORZ_HOME_VISITS", 3 },
+	{ "MELNORME_FUEL_PROCEDURE", 1 },
+	{ "MELNORME_TECH_PROCEDURE", 1 },
+	{ "MELNORME_INFO_PROCEDURE", 1 },
+	{ "MELNORME_TECH_STACK", 4 },
+	{ "MELNORME_EVENTS_INFO_STACK", 5 },
+	{ "MELNORME_ALIEN_INFO_STACK", 5 },
+	{ "MELNORME_HISTORY_INFO_STACK", 5 },
+	{ "RAINBOW_WORLD0", 8 },
+	{ "RAINBOW_WORLD1", 2 },
+	{ "MELNORME_RAINBOW_COUNT", 4 },
+	{ "USED_BROADCASTER", 1 },
+	{ "BROADCASTER_RESPONSE", 1 },
+	{ "IMPROVED_LANDER_SPEED", 1 },
+	{ "IMPROVED_LANDER_CARGO", 1 },
+	{ "IMPROVED_LANDER_SHOT", 1 },
+	{ "MET_ORZ_BEFORE", 1 },
+	{ "YEHAT_REBEL_TOLD_PKUNK", 1 },
+	{ "PLAYER_HAD_SEX", 1 },
+	{ "UMGAH_BROADCASTERS_ON_SHIP", 1 },
+	{ "LIGHT_MINERAL_LOAD", 3 },
+	{ "MEDIUM_MINERAL_LOAD", 3 },
+	{ "HEAVY_MINERAL_LOAD", 3 },
+	{ "STARBASE_BULLETS", 32 },
+	{ "STARBASE_MONTH", 4 },
+	{ "STARBASE_DAY", 5 },
+	{ "CREW_SOLD_TO_DRUUGE0", 8 },
+	{ "CREW_PURCHASED0", 8 },
+	{ "CREW_PURCHASED1", 8 },
+	{ "URQUAN_PROTECTING_SAMATRA", 1 },
+	{ "COLONY_GRPOFFS", 32 },
+	{ "THRADDASH_BODY_COUNT", 5 },
+	{ "UTWIG_SUPOX_MISSION", 3 },
+	{ "SPATHI_INFO", 3 },
+	{ "ILWRATH_INFO", 2 },
+	{ "ILWRATH_GODS_SPOKEN", 4 },
+	{ "ILWRATH_WORSHIP", 2 },
+	{ "ILWRATH_FIGHT_THRADDASH", 1 },
+	{ "SAMATRA_GRPOFFS", 32 },
+	{ "READY_TO_CONFUSE_URQUAN", 1 },
+	{ "URQUAN_HYPNO_VISITS", 1 },
+	{ "MENTIONED_PET_COMPULSION", 1 },
+	{ "URQUAN_INFO", 2 },
+	{ "KNOW_URQUAN_STORY", 2 },
+	{ "MYCON_INFO", 4 },
+	{ "MYCON_RAMBLE", 5 },
+	{ "KNOW_ABOUT_SHATTERED", 2 },
+	{ "MYCON_INSULTS", 3 },
+	{ "MYCON_KNOW_AMBUSH", 1 },
+	{ "SYREEN_INFO", 2 },
+	{ "KNOW_SYREEN_WORLD_SHATTERED", 1 },
+	{ "SYREEN_KNOW_ABOUT_MYCON", 1 },
+	{ "TALKING_PET_INFO", 3 },
+	{ "TALKING_PET_SUGGESTIONS", 3 },
+	{ "LEARNED_TALKING_PET", 1 },
+	{ "DNYARRI_LIED", 1 },
+	{ "SHIP_TO_COMPEL", 1 },
+	{ "ORZ_GENERAL_INFO", 2 },
+	{ "ORZ_PERSONAL_INFO", 3 },
+	{ "ORZ_ANDRO_STATE", 2 },
+	{ "REFUSED_ORZ_ALLIANCE", 1 },
+	{ "PKUNK_MANNER", 2 },
+	{ "PKUNK_ON_THE_MOVE", 1 },
+	{ "PKUNK_FLEET", 2 },
+	{ "PKUNK_MIGRATE", 2 },
+	{ "PKUNK_RETURN", 1 },
+	{ "PKUNK_WORRY", 2 },
+	{ "PKUNK_INFO", 3 },
+	{ "PKUNK_WAR", 2 },
+	{ "PKUNK_FORTUNE", 3 },
+	{ "PKUNK_MIGRATE_VISITS", 3 },
+	{ "PKUNK_REASONS", 4 },
+	{ "PKUNK_SWITCH", 1 },
+	{ "PKUNK_SENSE_VICTOR", 1 },
+	{ "KOHR_AH_REASONS", 2 },
+	{ "KOHR_AH_PLEAD", 2 },
+	{ "KOHR_AH_INFO", 2 },
+	{ "KNOW_KOHR_AH_STORY", 2 },
+	{ "KOHR_AH_SENSES_EVIL", 1 },
+	{ "URQUAN_SENSES_EVIL", 1 },
+	{ "SLYLANDRO_PROBE_VISITS", 3 },
+	{ "SLYLANDRO_PROBE_THREAT", 2 },
+	{ "SLYLANDRO_PROBE_WRONG", 2 },
+	{ "SLYLANDRO_PROBE_ID", 2 },
+	{ "SLYLANDRO_PROBE_INFO", 2 },
+	{ "SLYLANDRO_PROBE_EXIT", 2 },
+	{ "UMGAH_HOSTILE", 1 },
+	{ "UMGAH_EVIL_BLOBBIES", 1 },
+	{ "UMGAH_MENTIONED_TRICKS", 2 },
+	{ "BOMB_CARRIER", 1 },
+	{ "THRADD_MANNER", 1 },
+	{ "THRADD_INTRO", 2 },
+	{ "THRADD_DEMEANOR", 3 },
+	{ "THRADD_INFO", 2 },
+	{ "THRADD_BODY_LEVEL", 2 },
+	{ "THRADD_MISSION_VISITS", 1 },
+	{ "THRADD_STACK_1", 3 },
+	{ "THRADD_HOSTILE_STACK_2", 1 },
+	{ "THRADD_HOSTILE_STACK_3", 1 },
+	{ "THRADD_HOSTILE_STACK_4", 1 },
+	{ "THRADD_HOSTILE_STACK_5", 1 },
+	{ "CHMMR_STACK", 2 },
+	{ "ARILOU_MANNER", 2 },
+	{ "NO_PORTAL_VISITS", 1 },
+	{ "ARILOU_STACK_1", 2 },
+	{ "ARILOU_STACK_2", 1 },
+	{ "ARILOU_STACK_3", 2 },
+	{ "ARILOU_STACK_4", 1 },
+	{ "ARILOU_STACK_5", 2 },
+	{ "ARILOU_INFO", 2 },
+	{ "ARILOU_HINTS", 2 },
+	{ "DRUUGE_MANNER", 1 },
+	{ "DRUUGE_SPACE_INFO", 2 },
+	{ "DRUUGE_HOME_INFO", 2 },
+	{ "DRUUGE_SALVAGE", 1 },
+	{ "KNOW_DRUUGE_SLAVERS", 2 },
+	{ "FRAGMENTS_BOUGHT", 2 },
+	{ "ZEX_STACK_1", 2 },
+	{ "ZEX_STACK_2", 2 },
+	{ "ZEX_STACK_3", 2 },
+	{ "VUX_INFO", 2 },
+	{ "VUX_STACK_1", 4 },
+	{ "VUX_STACK_2", 2 },
+	{ "VUX_STACK_3", 2 },
+	{ "VUX_STACK_4", 2 },
+	{ "SHOFIXTI_STACK4", 2 },
+	{ "YEHAT_REBEL_INFO", 3 },
+	{ "YEHAT_ROYALIST_INFO", 1 },
+	{ "YEHAT_ROYALIST_TOLD_PKUNK", 1 },
+	{ "NO_YEHAT_ALLY_HOME", 1 },
+	{ "NO_YEHAT_HELP_HOME", 1 },
+	{ "NO_YEHAT_INFO", 1 },
+	{ "NO_YEHAT_ALLY_SPACE", 2 },
+	{ "NO_YEHAT_HELP_SPACE", 2 },
+	{ "ZOQFOT_KNOW_MASK", 4 },
+	{ "SUPOX_HOSTILE", 1 },
+	{ "SUPOX_INFO", 1 },
+	{ "SUPOX_WAR_NEWS", 2 },
+	{ "SUPOX_ULTRON_HELP", 1 },
+	{ "SUPOX_STACK1", 3 },
+	{ "SUPOX_STACK2", 2 },
+	{ "UTWIG_HOSTILE", 1 },
+	{ "UTWIG_INFO", 1 },
+	{ "UTWIG_WAR_NEWS", 2 },
+	{ "UTWIG_STACK1", 3 },
+	{ "UTWIG_STACK2", 2 },
+	{ "BOMB_INFO", 1 },
+	{ "BOMB_STACK1", 2 },
+	{ "BOMB_STACK2", 2 },
+	{ "SLYLANDRO_KNOW_BROKEN", 1 },
+	{ "PLAYER_KNOWS_PROBE", 1 },
+	{ "PLAYER_KNOWS_PROGRAM", 1 },
+	{ "PLAYER_KNOWS_EFFECTS", 1 },
+	{ "PLAYER_KNOWS_PRIORITY", 1 },
+	{ "SLYLANDRO_STACK1", 3 },
+	{ "SLYLANDRO_STACK2", 1 },
+	{ "SLYLANDRO_STACK3", 2 },
+	{ "SLYLANDRO_STACK4", 2 },
+	{ "SLYLANDRO_STACK5", 1 },
+	{ "SLYLANDRO_STACK6", 1 },
+	{ "SLYLANDRO_STACK7", 2 },
+	{ "SLYLANDRO_STACK8", 2 },
+	{ "SLYLANDRO_STACK9", 2 },
+	{ "SLYLANDRO_KNOW_EARTH", 1 },
+	{ "SLYLANDRO_KNOW_EXPLORE", 1 },
+	{ "SLYLANDRO_KNOW_GATHER", 1 },
+	{ "SLYLANDRO_KNOW_URQUAN", 2 },
+	{ "RECALL_VISITS", 2 },
+	{ "SLYLANDRO_MULTIPLIER", 3 },
+	{ "KNOW_SPATHI_QUEST", 1 },
+	{ "KNOW_SPATHI_EVIL", 1 },
+	{ "BATTLE_PLANET", 8 },
+	{ "ESCAPE_COUNTER", 8 },
+	{ "CREW_SOLD_TO_DRUUGE1", 8 },
+	{ "PKUNK_DONE_WAR", 1 },
+	{ "SYREEN_STACK0", 2 },
+	{ "SYREEN_STACK1", 2 },
+	{ "SYREEN_STACK2", 2 },
+	{ "REFUSED_ULTRON_AT_BOMB", 1 },
+	{ "NO_TRICK_AT_SUN", 1 },
+	{ "SPATHI_STACK0", 2 },
+	{ "SPATHI_STACK1", 1 },
+	{ "SPATHI_STACK2", 1 },
+	{ "ORZ_STACK0", 1 },
+	{ "ORZ_STACK1", 1 },
+	{ NULL, 0 },
+};
+
+
+// XXX: these should handle endian conversions later
+static inline COUNT
+cread_8 (DECODE_REF fh, BYTE *v)
+{
+	BYTE t;
+	if (!v) /* read value ignored */
+		v = &t;
+	return cread (v, 1, 1, fh);
+}
+
+static inline COUNT
+cread_16 (DECODE_REF fh, UWORD *v)
+{
+	UWORD t;
+	if (!v) /* read value ignored */
+		v = &t;
+	return cread (v, 2, 1, fh);
+}
+
+static inline COUNT
+cread_16s (DECODE_REF fh, SWORD *v)
+{
+	UWORD t;
+	COUNT ret;
+	// value was converted to unsigned when saved
+	ret = cread_16 (fh, &t);
+	// unsigned to signed conversion
+	if (v)
+		*v = t;
+	return ret;
+}
+
+static inline COUNT
+cread_32 (DECODE_REF fh, DWORD *v)
+{
+	DWORD t;
+	if (!v) /* read value ignored */
+		v = &t;
+	return cread (v, 4, 1, fh);
+}
+
+static inline COUNT
+cread_32s (DECODE_REF fh, SDWORD *v)
+{
+	DWORD t;
+	COUNT ret;
+	// value was converted to unsigned when saved
+	ret = cread_32 (fh, &t);
+	// unsigned to signed conversion
+	if (v)
+		*v = t;
+	return ret;
+}
+
+static inline COUNT
+cread_ptr (DECODE_REF fh)
+{
+	DWORD t;
+	return cread_32 (fh, &t); /* ptrs are useless in saves */
+}
+
+static inline COUNT
+cread_a8 (DECODE_REF fh, BYTE *ar, COUNT count)
+{
+	assert (ar != NULL);
+	return cread (ar, 1, count, fh) == count;
+}
+
+static inline size_t
+read_8 (void *fp, BYTE *v)
+{
+	BYTE t;
+	if (!v) /* read value ignored */
+		v = &t;
+	return ReadResFile (v, 1, 1, fp);
+}
+
+static inline size_t
+read_16 (void *fp, UWORD *v)
+{
+	UWORD t;
+	if (!v) /* read value ignored */
+		v = &t;
+	return ReadResFile (v, 2, 1, fp);
+}
+
+static inline size_t
+read_32 (void *fp, DWORD *v)
+{
+	DWORD t;
+	if (!v) /* read value ignored */
+		v = &t;
+	return ReadResFile (v, 4, 1, fp);
+}
+
+static inline size_t
+read_32s (void *fp, SDWORD *v)
+{
+	DWORD t;
+	COUNT ret;
+	// value was converted to unsigned when saved
+	ret = read_32 (fp, &t);
+	// unsigned to signed conversion
+	if (v)
+		*v = t;
+	return ret;
+}
+
+static inline size_t
+read_ptr (void *fp)
+{
+	DWORD t;
+	return read_32 (fp, &t); /* ptrs are useless in saves */
+}
+
+static inline size_t
+read_a8 (void *fp, BYTE *ar, COUNT count)
+{
+	assert (ar != NULL);
+	return ReadResFile (ar, 1, count, fp) == count;
+}
+
+static inline size_t
+read_str (void *fp, char *str, COUNT count)
+{
+	// no type conversion needed for strings
+	return read_a8 (fp, (BYTE *)str, count);
+}
+
+static inline size_t
+read_a16 (void *fp, UWORD *ar, COUNT count)
+{
+	assert (ar != NULL);
+
+	for ( ; count > 0; --count, ++ar)
+	{
+		if (read_16 (fp, ar) != 1)
+			return 0;
+	}
+	return 1;
+}
+
+static void
+LoadEmptyQueue (DECODE_REF fh)
+{
+	COUNT num_links;
+
+	cread_16 (fh, &num_links);
+	if (num_links)
+	{
+		log_add (log_Error, "LoadEmptyQueue(): BUG: the queue is not empty!");
+#ifdef DEBUG
+		explode ();
+#endif
+	}
+}
+
+static void
+LoadShipQueue (DECODE_REF fh, QUEUE *pQueue)
+{
+	COUNT num_links;
+
+	cread_16 (fh, &num_links);
+
+	while (num_links--)
+	{
+		HSHIPFRAG hStarShip;
+		SHIP_FRAGMENT *FragPtr;
+		COUNT Index;
+		BYTE tmpb;
+
+		cread_16 (fh, &Index);
+
+		hStarShip = CloneShipFragment (Index, pQueue, 0);
+		FragPtr = LockShipFrag (pQueue, hStarShip);
+
+		// Read SHIP_FRAGMENT elements
+		cread_16 (fh, NULL); /* unused: was which_side */
+		cread_8  (fh, &FragPtr->captains_name_index);
+		cread_8  (fh, NULL); /* padding */
+		cread_16 (fh, NULL); /* unused: was ship_flags */
+		cread_8  (fh, &FragPtr->race_id);
+		cread_8  (fh, &FragPtr->index);
+		// XXX: reading crew as BYTE to maintain savegame compatibility
+		cread_8  (fh, &tmpb);
+		FragPtr->crew_level = tmpb;
+		cread_8  (fh, &tmpb);
+		FragPtr->max_crew = tmpb;
+		cread_8  (fh, &FragPtr->energy_level);
+		cread_8  (fh, &FragPtr->max_energy);
+		cread_16 (fh, NULL); /* unused; was loc.x */
+		cread_16 (fh, NULL); /* unused; was loc.y */
+
+		UnlockShipFrag (pQueue, hStarShip);
+	}
+}
+
+static void
+LoadRaceQueue (DECODE_REF fh, QUEUE *pQueue)
+{
+	COUNT num_links;
+
+	cread_16 (fh, &num_links);
+
+	while (num_links--)
+	{
+		HFLEETINFO hStarShip;
+		FLEET_INFO *FleetPtr;
+		COUNT Index;
+		BYTE tmpb;
+
+		cread_16 (fh, &Index);
+
+		hStarShip = GetStarShipFromIndex (pQueue, Index);
+		FleetPtr = LockFleetInfo (pQueue, hStarShip);
+
+		// Read FLEET_INFO elements
+		cread_16 (fh, &FleetPtr->allied_state);
+		cread_8  (fh, &FleetPtr->days_left);
+		cread_8  (fh, &FleetPtr->growth_fract);
+		cread_8  (fh, &tmpb);
+		FleetPtr->crew_level = tmpb;
+		cread_8  (fh, &tmpb);
+		FleetPtr->max_crew = tmpb;
+		cread_8  (fh, &FleetPtr->growth);
+		cread_8  (fh, &FleetPtr->max_energy);
+		cread_16s(fh, &FleetPtr->loc.x);
+		cread_16s(fh, &FleetPtr->loc.y);
+
+		cread_16 (fh, &FleetPtr->actual_strength);
+		cread_16 (fh, &FleetPtr->known_strength);
+		cread_16s(fh, &FleetPtr->known_loc.x);
+		cread_16s(fh, &FleetPtr->known_loc.y);
+		cread_8  (fh, &FleetPtr->growth_err_term);
+		cread_8  (fh, &FleetPtr->func_index);
+		cread_16s(fh, &FleetPtr->dest_loc.x);
+		cread_16s(fh, &FleetPtr->dest_loc.y);
+		cread_16 (fh, NULL); /* alignment padding */
+
+		UnlockFleetInfo (pQueue, hStarShip);
+	}
+}
+
+static void
+LoadGroupQueue (DECODE_REF fh, QUEUE *pQueue)
+{
+	COUNT num_links;
+
+	cread_16 (fh, &num_links);
+
+	while (num_links--)
+	{
+		HIPGROUP hGroup;
+		IP_GROUP *GroupPtr;
+		BYTE tmpb;
+
+		cread_16 (fh, NULL); /* unused; was race_id */
+
+		hGroup = BuildGroup (pQueue, 0);
+		GroupPtr = LockIpGroup (pQueue, hGroup);
+
+		cread_16 (fh, NULL); /* unused; was which_side */
+		cread_8  (fh, NULL); /* unused; was captains_name_index */
+		cread_8  (fh, NULL); /* padding; for savegame compat */
+		cread_16 (fh, &GroupPtr->group_counter);
+		cread_8  (fh, &GroupPtr->race_id);
+		cread_8  (fh, &tmpb); /* was var2 */
+		GroupPtr->sys_loc = LONIBBLE (tmpb);
+		GroupPtr->task = HINIBBLE (tmpb);
+		cread_8  (fh, &GroupPtr->in_system); /* was crew_level */
+		cread_8  (fh, NULL); /* unused; was max_crew */
+		cread_8  (fh, &tmpb); /* was energy_level */
+		GroupPtr->dest_loc = LONIBBLE (tmpb);
+		GroupPtr->orbit_pos = HINIBBLE (tmpb);
+		cread_8  (fh, &GroupPtr->group_id); /* was max_energy */
+		cread_16s(fh, &GroupPtr->loc.x);
+		cread_16s(fh, &GroupPtr->loc.y);
+
+		UnlockIpGroup (pQueue, hGroup);
+	}
+}
+
+static void
+LoadEncounter (ENCOUNTER *EncounterPtr, DECODE_REF fh)
+{
+	COUNT i;
+	BYTE tmpb;
+
+	cread_ptr (fh); /* useless ptr; HENCOUNTER pred */
+	EncounterPtr->pred = 0;
+	cread_ptr (fh); /* useless ptr; HENCOUNTER succ */
+	EncounterPtr->succ = 0;
+	cread_ptr (fh); /* useless ptr; HELEMENT hElement */
+	EncounterPtr->hElement = 0;
+	cread_16s (fh, &EncounterPtr->transition_state);
+	cread_16s (fh, &EncounterPtr->origin.x);
+	cread_16s (fh, &EncounterPtr->origin.y);
+	cread_16  (fh, &EncounterPtr->radius);
+	// former STAR_DESC fields
+	cread_16s (fh, &EncounterPtr->loc_pt.x);
+	cread_16s (fh, &EncounterPtr->loc_pt.y);
+	cread_8   (fh, &EncounterPtr->race_id);
+	cread_8   (fh, &tmpb);
+	EncounterPtr->num_ships = tmpb & ENCOUNTER_SHIPS_MASK;
+	EncounterPtr->flags = tmpb & ENCOUNTER_FLAGS_MASK;
+	cread_16  (fh, NULL); /* alignment padding */
+
+	// Load each entry in the BRIEF_SHIP_INFO array
+	for (i = 0; i < MAX_HYPER_SHIPS; i++)
+	{
+		BRIEF_SHIP_INFO *ShipInfo = &EncounterPtr->ShipList[i];
+
+		cread_16  (fh, NULL); /* useless; was SHIP_INFO.ship_flags */
+		cread_8   (fh, &ShipInfo->race_id);
+		cread_8   (fh, NULL); /* useless; was SHIP_INFO.var2 */
+		// XXX: reading crew as BYTE to maintain savegame compatibility
+		cread_8   (fh, &tmpb);
+		ShipInfo->crew_level = tmpb;
+		cread_8   (fh, &tmpb);
+		ShipInfo->max_crew = tmpb;
+		cread_8   (fh, NULL); /* useless; was SHIP_INFO.energy_level */
+		cread_8   (fh, &ShipInfo->max_energy);
+		cread_16  (fh, NULL); /* useless; was SHIP_INFO.loc.x */
+		cread_16  (fh, NULL); /* useless; was SHIP_INFO.loc.y */
+		cread_32  (fh, NULL); /* useless val; STRING race_strings */
+		cread_ptr (fh); /* useless ptr; FRAME icons */
+		cread_ptr (fh); /* useless ptr; FRAME melee_icon */
+	}
+	
+	// Load the stuff after the BRIEF_SHIP_INFO array
+	cread_32s (fh, &EncounterPtr->log_x);
+	cread_32s (fh, &EncounterPtr->log_y);
+}
+
+static void
+LoadEvent (EVENT *EventPtr, DECODE_REF fh)
+{
+	cread_ptr (fh); /* useless ptr; HEVENT pred */
+	EventPtr->pred = 0;
+	cread_ptr (fh); /* useless ptr; HEVENT succ */
+	EventPtr->succ = 0;
+	cread_8   (fh, &EventPtr->day_index);
+	cread_8   (fh, &EventPtr->month_index);
+	cread_16  (fh, &EventPtr->year_index);
+	cread_8   (fh, &EventPtr->func_index);
+	cread_8   (fh, NULL); /* padding */
+	cread_16  (fh, NULL); /* padding */
+}
+
+static void
+DummyLoadQueue (QUEUE *QueuePtr, DECODE_REF fh)
+{
+	/* QUEUE should never actually be loaded since it contains
+	 * purely internal representation and the lists
+	 * involved are actually loaded separately */
+	(void)QueuePtr; /* silence compiler */
+
+	/* QUEUE format with QUEUE_TABLE defined -- UQM default */
+	cread_ptr (fh); /* HLINK head */
+	cread_ptr (fh); /* HLINK tail */
+	cread_ptr (fh); /* BYTE* pq_tab */
+	cread_ptr (fh); /* HLINK free_list */
+	cread_16  (fh, NULL); /* MEM_HANDLE hq_tab */
+	cread_16  (fh, NULL); /* COUNT object_size */
+	cread_8   (fh, NULL); /* BYTE num_objects */
+	
+	cread_8   (fh, NULL); /* padding */
+	cread_16  (fh, NULL); /* padding */
+}
+
+static void
+LoadClockState (CLOCK_STATE *ClockPtr, DECODE_REF fh)
+{
+	cread_8   (fh, &ClockPtr->day_index);
+	cread_8   (fh, &ClockPtr->month_index);
+	cread_16  (fh, &ClockPtr->year_index);
+	cread_16s (fh, &ClockPtr->tick_count);
+	cread_16s (fh, &ClockPtr->day_in_ticks);
+	cread_ptr (fh); /* not loading ptr; Semaphore clock_sem */
+	cread_ptr (fh); /* not loading ptr; Task clock_task */
+	cread_32  (fh, NULL); /* not loading; DWORD TimeCounter */
+
+	DummyLoadQueue (&ClockPtr->event_q, fh);
+}
+
+static void
+LoadGameState (GAME_STATE *GSPtr, DECODE_REF fh)
+{
+	BYTE dummy8;
+
+	cread_8   (fh, &dummy8); /* obsolete */
+	cread_8   (fh, &GSPtr->glob_flags);
+	cread_8   (fh, &GSPtr->CrewCost);
+	cread_8   (fh, &GSPtr->FuelCost);
+	cread_a8  (fh, GSPtr->ModuleCost, NUM_MODULES);
+	cread_a8  (fh, GSPtr->ElementWorth, NUM_ELEMENT_CATEGORIES);
+	cread_ptr (fh); /* not loading ptr; PRIMITIVE *DisplayArray */
+	cread_16  (fh, &GSPtr->CurrentActivity);
+	
+	cread_16  (fh, NULL); /* CLOCK_STATE alignment padding */
+	LoadClockState (&GSPtr->GameClock, fh);
+
+	cread_16s (fh, &GSPtr->autopilot.x);
+	cread_16s (fh, &GSPtr->autopilot.y);
+	cread_16s (fh, &GSPtr->ip_location.x);
+	cread_16s (fh, &GSPtr->ip_location.y);
+	/* STAMP ShipStamp */
+	cread_16s (fh, &GSPtr->ShipStamp.origin.x);
+	cread_16s (fh, &GSPtr->ShipStamp.origin.y);
+	cread_16  (fh, &GSPtr->ShipFacing);
+	cread_8   (fh, &GSPtr->ip_planet);
+	cread_8   (fh, &GSPtr->in_orbit);
+
+	/* VELOCITY_DESC velocity */
+	cread_16  (fh, &GSPtr->velocity.TravelAngle);
+	cread_16s (fh, &GSPtr->velocity.vector.width);
+	cread_16s (fh, &GSPtr->velocity.vector.height);
+	cread_16s (fh, &GSPtr->velocity.fract.width);
+	cread_16s (fh, &GSPtr->velocity.fract.height);
+	cread_16s (fh, &GSPtr->velocity.error.width);
+	cread_16s (fh, &GSPtr->velocity.error.height);
+	cread_16s (fh, &GSPtr->velocity.incr.width);
+	cread_16s (fh, &GSPtr->velocity.incr.height);
+	cread_16  (fh, NULL); /* VELOCITY_DESC padding */
+
+	cread_32  (fh, &GSPtr->BattleGroupRef);
+	
+	DummyLoadQueue (&GSPtr->avail_race_q, fh);
+	DummyLoadQueue (&GSPtr->npc_built_ship_q, fh);
+	// Not loading ip_group_q, was not there originally
+	DummyLoadQueue (&GSPtr->encounter_q, fh);
+	DummyLoadQueue (&GSPtr->built_ship_q, fh);
+
+	{
+		size_t numBytes = ((NUM_GAME_STATE_BITS - 17) + 7) >> 3;
+		BYTE *buf;
+
+		// assert (numBytes % 4 == 3);
+				// We should have one byte padding.
+		buf = HMalloc (numBytes);
+		if (buf != NULL)
+		{
+			cread_a8  (fh, buf, numBytes);
+			deserialiseGameState (legacyGameStateBitMap, buf, numBytes);
+			HFree(buf);
+		}
+	}
+
+	cread_8  (fh, NULL); /* GAME_STATE alignment padding */
+}
+
+static BOOLEAN
+LoadSisState (SIS_STATE *SSPtr, void *fp)
+{
+	if (
+			read_32s (fp, &SSPtr->log_x) != 1 ||
+			read_32s (fp, &SSPtr->log_y) != 1 ||
+			read_32  (fp, &SSPtr->ResUnits) != 1 ||
+			read_32  (fp, &SSPtr->FuelOnBoard) != 1 ||
+			read_16  (fp, &SSPtr->CrewEnlisted) != 1 ||
+			read_16  (fp, &SSPtr->TotalElementMass) != 1 ||
+			read_16  (fp, &SSPtr->TotalBioMass) != 1 ||
+			read_a8  (fp, SSPtr->ModuleSlots, NUM_MODULE_SLOTS) != 1 ||
+			read_a8  (fp, SSPtr->DriveSlots, NUM_DRIVE_SLOTS) != 1 ||
+			read_a8  (fp, SSPtr->JetSlots, NUM_JET_SLOTS) != 1 ||
+			read_8   (fp, &SSPtr->NumLanders) != 1 ||
+			read_a16 (fp, SSPtr->ElementAmounts, NUM_ELEMENT_CATEGORIES) != 1 ||
+
+			read_str (fp, SSPtr->ShipName, SIS_NAME_SIZE) != 1 ||
+			read_str (fp, SSPtr->CommanderName, SIS_NAME_SIZE) != 1 ||
+			read_str (fp, SSPtr->PlanetName, SIS_NAME_SIZE) != 1 ||
+
+			read_16  (fp, NULL) != 1 /* padding */
+		)
+		return FALSE;
+	else
+		return TRUE;
+}
+
+static BOOLEAN
+LoadSummary (SUMMARY_DESC *SummPtr, void *fp)
+{
+	if (!LoadSisState (&SummPtr->SS, fp))
+		return FALSE;
+
+	if (
+			read_8  (fp, &SummPtr->Activity) != 1 ||
+			read_8  (fp, &SummPtr->Flags) != 1 ||
+			read_8  (fp, &SummPtr->day_index) != 1 ||
+			read_8  (fp, &SummPtr->month_index) != 1 ||
+			read_16 (fp, &SummPtr->year_index) != 1 ||
+			read_8  (fp, &SummPtr->MCreditLo) != 1 ||
+			read_8  (fp, &SummPtr->MCreditHi) != 1 ||
+			read_8  (fp, &SummPtr->NumShips) != 1 ||
+			read_8  (fp, &SummPtr->NumDevices) != 1 ||
+			read_a8 (fp, SummPtr->ShipList, MAX_BUILT_SHIPS) != 1 ||
+			read_a8 (fp, SummPtr->DeviceList, MAX_EXCLUSIVE_DEVICES) != 1 ||
+
+			read_16  (fp, NULL) != 1 /* padding */
+		)
+		return FALSE;
+	else
+		return TRUE;
+}
+
+static void
+LoadStarDesc (STAR_DESC *SDPtr, DECODE_REF fh)
+{
+	cread_16s(fh, &SDPtr->star_pt.x);
+	cread_16s(fh, &SDPtr->star_pt.y);
+	cread_8  (fh, &SDPtr->Type);
+	cread_8  (fh, &SDPtr->Index);
+	cread_8  (fh, &SDPtr->Prefix);
+	cread_8  (fh, &SDPtr->Postfix);
+}
+
+BOOLEAN
+LoadLegacyGame (COUNT which_game, SUMMARY_DESC *SummPtr)
+{
+	uio_Stream *in_fp;
+	char file[PATH_MAX];
+	char buf[256];
+	SUMMARY_DESC loc_sd;
+	GAME_STATE_FILE *fp;
+	DECODE_REF fh;
+	COUNT num_links;
+	STAR_DESC SD;
+	ACTIVITY Activity;
+
+	sprintf (file, "starcon2.%02u", which_game);
+	in_fp = res_OpenResFile (saveDir, file, "rb");
+	if (!in_fp)
+		return FALSE;
+
+	loc_sd.SaveName[0] = '\0';
+	if (!LoadSummary (&loc_sd, in_fp))
+	{
+		log_add (log_Error, "Warning: Savegame is corrupt");
+		res_CloseResFile (in_fp);
+		return FALSE;
+	}
+
+	if (!SummPtr)
+	{
+		SummPtr = &loc_sd;
+	}
+	else
+	{	// only need summary for displaying to user
+		memcpy (SummPtr, &loc_sd, sizeof (*SummPtr));
+		res_CloseResFile (in_fp);
+		return TRUE;
+	}
+
+	// Crude check for big-endian/little-endian incompatibilities.
+	// year_index is suitable as it's a multi-byte value within
+	// a specific recognisable range.
+	if (SummPtr->year_index < START_YEAR ||
+			SummPtr->year_index >= START_YEAR +
+			YEARS_TO_KOHRAH_VICTORY + 1 /* Utwig intervention */ +
+			1 /* time to destroy all races, plenty */ +
+			25 /* for cheaters */)
+	{
+		log_add (log_Error, "Warning: Savegame corrupt or from "
+				"an incompatible platform.");
+		res_CloseResFile (in_fp);
+		return FALSE;
+	}
+
+	GlobData.SIS_state = SummPtr->SS;
+
+	if ((fh = copen (in_fp, FILE_STREAM, STREAM_READ)) == 0)
+	{
+		res_CloseResFile (in_fp);
+		return FALSE;
+	}
+
+	ReinitQueue (&GLOBAL (GameClock.event_q));
+	ReinitQueue (&GLOBAL (encounter_q));
+	ReinitQueue (&GLOBAL (ip_group_q));
+	ReinitQueue (&GLOBAL (npc_built_ship_q));
+	ReinitQueue (&GLOBAL (built_ship_q));
+
+	uninitEventSystem ();
+	luaUqm_uninitState();
+	luaUqm_initState();
+	initEventSystem ();
+
+	Activity = GLOBAL (CurrentActivity);
+	LoadGameState (&GlobData.Game_state, fh);
+	NextActivity = GLOBAL (CurrentActivity);
+	GLOBAL (CurrentActivity) = Activity;
+
+	LoadRaceQueue (fh, &GLOBAL (avail_race_q));
+	// START_INTERPLANETARY is only set when saving from Homeworld
+	//   encounter screen. When the game is loaded, the
+	//   GenerateOrbitalFunction for the current star system will
+	//   create the encounter anew and populate the npc queue.
+	if (!(NextActivity & START_INTERPLANETARY))
+	{
+		if (NextActivity & START_ENCOUNTER)
+			LoadShipQueue (fh, &GLOBAL (npc_built_ship_q));
+		else if (LOBYTE (NextActivity) == IN_INTERPLANETARY)
+			// XXX: Technically, this queue does not need to be
+			//   saved/loaded at all. IP groups will be reloaded
+			//   from group state files. But the original code did,
+			//   and so will we until we can prove we do not need to.
+			LoadGroupQueue (fh, &GLOBAL (ip_group_q));
+		else
+			// XXX: The empty queue read is only needed to maintain
+			//   the savegame compatibility
+			LoadEmptyQueue (fh);
+	}
+	LoadShipQueue (fh, &GLOBAL (built_ship_q));
+
+	// Load the game events (compressed)
+	cread_16 (fh, &num_links);
+	{
+#ifdef DEBUG_LOAD
+		log_add (log_Debug, "EVENTS:");
+#endif /* DEBUG_LOAD */
+		while (num_links--)
+		{
+			HEVENT hEvent;
+			EVENT *EventPtr;
+
+			hEvent = AllocEvent ();
+			LockEvent (hEvent, &EventPtr);
+
+			LoadEvent (EventPtr, fh);
+
+#ifdef DEBUG_LOAD
+		log_add (log_Debug, "\t%u/%u/%u -- %u",
+				EventPtr->month_index,
+				EventPtr->day_index,
+				EventPtr->year_index,
+				EventPtr->func_index);
+#endif /* DEBUG_LOAD */
+			UnlockEvent (hEvent);
+			PutEvent (hEvent);
+		}
+	}
+
+	// Load the encounters (black globes in HS/QS (compressed))
+	cread_16 (fh, &num_links);
+	{
+		while (num_links--)
+		{
+			HENCOUNTER hEncounter;
+			ENCOUNTER *EncounterPtr;
+
+			hEncounter = AllocEncounter ();
+			LockEncounter (hEncounter, &EncounterPtr);
+
+			LoadEncounter (EncounterPtr, fh);
+
+			UnlockEncounter (hEncounter);
+			PutEncounter (hEncounter);
+		}
+	}
+
+	// Copy the star info file from the compressed stream
+	fp = OpenStateFile (STARINFO_FILE, "wb");
+	if (fp)
+	{
+		DWORD flen;
+
+		cread_32 (fh, &flen);
+		while (flen)
+		{
+			COUNT num_bytes;
+
+			num_bytes = flen >= sizeof (buf) ? sizeof (buf) : (COUNT)flen;
+			cread (buf, num_bytes, 1, fh);
+			WriteStateFile (buf, num_bytes, 1, fp);
+
+			flen -= num_bytes;
+		}
+		CloseStateFile (fp);
+	}
+
+	// Copy the defined groupinfo file from the compressed stream
+	fp = OpenStateFile (DEFGRPINFO_FILE, "wb");
+	if (fp)
+	{
+		DWORD flen;
+
+		cread_32 (fh, &flen);
+		while (flen)
+		{
+			COUNT num_bytes;
+
+			num_bytes = flen >= sizeof (buf) ? sizeof (buf) : (COUNT)flen;
+			cread (buf, num_bytes, 1, fh);
+			WriteStateFile (buf, num_bytes, 1, fp);
+
+			flen -= num_bytes;
+		}
+		CloseStateFile (fp);
+	}
+
+	// Copy the random groupinfo file from the compressed stream
+	fp = OpenStateFile (RANDGRPINFO_FILE, "wb");
+	if (fp)
+	{
+		DWORD flen;
+
+		cread_32 (fh, &flen);
+		while (flen)
+		{
+			COUNT num_bytes;
+
+			num_bytes = flen >= sizeof (buf) ? sizeof (buf) : (COUNT)flen;
+			cread (buf, num_bytes, 1, fh);
+			WriteStateFile (buf, num_bytes, 1, fp);
+
+			flen -= num_bytes;
+		}
+		CloseStateFile (fp);
+	}
+
+	LoadStarDesc (&SD, fh);
+	loadGameCheats();
+	cclose (fh);
+	res_CloseResFile (in_fp);
+
+	EncounterGroup = 0;
+	EncounterRace = -1;
+
+	ReinitQueue (&race_q[0]);
+	ReinitQueue (&race_q[1]);
+	CurStarDescPtr = FindStar (NULL, &SD.star_pt, 0, 0);
+	if (!(NextActivity & START_ENCOUNTER)
+			&& LOBYTE (NextActivity) == IN_INTERPLANETARY)
+		NextActivity |= START_INTERPLANETARY;
+
+	return TRUE;
+}
+
+
diff -ruNp src.hd/uqm/loadship.c src/uqm/loadship.c
--- src.hd/uqm/loadship.c	2017-12-29 02:25:52 -0800
+++ src/uqm/loadship.c	2017-12-29 00:57:46 -0800
@@ -170,6 +170,9 @@ void
 free_ship (RACE_DESC *raceDescPtr, BOOLEAN FreeIconData,
 		BOOLEAN FreeBattleData)
 {
+	if (raceDescPtr->uninit_func != NULL)
+		(*raceDescPtr->uninit_func) (raceDescPtr);
+
 	if (FreeBattleData)
 	{
 		DATA_STUFF *shipData = &raceDescPtr->ship_data;
diff -ruNp src.hd/uqm/lua/Makeinfo src/uqm/lua/Makeinfo
--- src.hd/uqm/lua/Makeinfo	1969-12-31 16:00:00 -0800
+++ src/uqm/lua/Makeinfo	2017-12-29 00:57:46 -0800
@@ -0,0 +1,9 @@
+uqm_SUBDIRS="luafuncs"
+uqm_CFILES="luacomm.c luaevent.c luainit.c luastate.c"
+uqm_HFILES="luacomm.h luaevent.h luainit.h luastate.h"
+
+if [ -n "$DEBUG" ]; then
+	uqm_CFILES="$uqm_CFILES luadebug.c"
+	uqm_HFILES="$uqm_HFILES luadebug.h"
+fi
+
diff -ruNp src.hd/uqm/lua/luacomm.c src/uqm/lua/luacomm.c
--- src.hd/uqm/lua/luacomm.c	1969-12-31 16:00:00 -0800
+++ src/uqm/lua/luacomm.c	2017-12-29 00:57:46 -0800
@@ -0,0 +1,288 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * This file contains code for using Lua with the game conversations.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+
+#define LUAUQM_INTERNAL
+#include "port.h"
+#include "luacomm.h"
+
+#include "options.h"
+		// For contentDir
+#include "libs/scriptlib.h"
+#include "uqm/lua/luastate.h"
+#include "luafuncs/commfuncs.h"
+#include "luafuncs/customfuncs.h"
+#include "luafuncs/eventfuncs.h"
+#include "luafuncs/logfuncs.h"
+#include "luafuncs/statefuncs.h"
+#include "libs/log.h"
+
+lua_State *luaUqm_commState = NULL;
+	
+static const luaL_Reg commLibs[] = {
+	{ "comm",  luaUqm_comm_open },
+	{ "event", luaUqm_event_open },
+	{ "log",   luaUqm_log_open },
+	{ "state", luaUqm_state_open },
+	{ NULL, NULL }
+};
+
+// Not reentrant.
+// If 'customFuncs' is NULL, no 'custom' table is added to the Lua environment.
+// If 'scriptRes' is NULL_RESOURCE, then no script is loaded. Lua is only
+// available for string interpolation in this case.
+BOOLEAN
+luaUqm_comm_init(const luaUqm_custom_Function *customFuncs,
+		RESOURCE scriptRes) {
+	assert(luaUqm_commState == NULL);
+
+	luaUqm_commState = luaUqm_globalState;
+
+	// Prepare the global environment.
+	luaUqm_prepareEnvironment(luaUqm_commState);
+	luaUqm_loadLibs(luaUqm_commState, commLibs);
+	if (customFuncs != NULL) {
+		luaUqm_custom_init(luaUqm_commState, customFuncs);
+		lua_pop(luaUqm_commState, 1);
+	}
+
+	if (scriptRes != NULL_RESOURCE) {
+		// Load the script.
+		char *scriptFileName;
+		BOOLEAN loadOk;
+
+		// Get the name of the script.
+		scriptFileName = LoadScriptInstance(scriptRes);
+		if (scriptFileName == NULL)
+			return FALSE;
+
+		// Load the script.
+		loadOk = luaUqm_loadScript(luaUqm_commState, contentDir,
+				scriptFileName);
+		ReleaseScriptResData(scriptFileName);
+		if (!loadOk)
+			return FALSE;
+
+		// Call the script.
+		luaUqm_callStackFunction(luaUqm_commState);
+	}
+
+	return TRUE;
+}
+
+void
+luaUqm_comm_uninit(void) {
+	assert(luaUqm_commState != NULL);
+	luaUqm_commState = NULL;
+}
+
+// Use as LOCDATA.init_encounter_func
+void
+luaUqm_comm_genericInit(void) {
+	assert(luaUqm_commState != NULL);
+	luaUqm_callFunction(luaUqm_commState, "init");
+}
+
+// Use as LOCDATA.post_encounter_func
+void
+luaUqm_comm_genericPost(void) {
+	assert(luaUqm_commState != NULL);
+	luaUqm_callFunction(luaUqm_commState, "post");
+}
+
+// Use as LOCDATA.uninit_encounter_func
+void
+luaUqm_comm_genericUninit(void) {
+	assert(luaUqm_commState != NULL);
+	luaUqm_callFunction(luaUqm_commState, "uninit");
+
+	luaUqm_comm_uninit();
+}
+
+BOOLEAN
+luaUqm_comm_stringNeedsInterpolate (const char *str)
+{
+	return strstr (str, "<%") != NULL;
+}
+
+// Resizes *buf if necessary. Makes sure that there is always enough
+// space for a final '\0' to be added.
+static void
+luaUqm_comm_addToBuffer  (char **buf, size_t *bufLen, char **bufPtr,
+		const char *add, size_t addLen)
+{
+	size_t bufFill = *bufPtr - *buf;
+	size_t newLen = *bufLen;
+
+	while ((size_t) (bufFill + addLen >= newLen)) {
+			// Need enough space for the terminating '\0' too.
+		newLen = newLen * 2;
+	}
+
+	if (newLen != *bufLen) {
+		char *newBuf = HRealloc (*buf, newLen);
+		if (newBuf == NULL)
+		{
+			log_add (log_Error, "Error: luaUqm_addToBuffer(): could not "
+					"allocate memory.\n");
+			return;
+					// We continue, without adding 'add' to the buffer.
+		}
+
+		*bufLen = newLen;
+		*buf = newBuf;
+		*bufPtr = newBuf + bufFill;
+	}
+
+	memcpy (*bufPtr, add, addLen);
+	*bufPtr += addLen;
+}
+
+// Pre: *bufLen contains the space available in buf.
+// Post: *bufLen contains the size of the string in *buf.
+char *
+luaUqm_comm_stringInterpolate (const char *str)
+{
+	const char *strPtr;
+	size_t interI;
+			// Interpolation counter.
+	char *buf;
+			//
+	char *bufPtr;
+	size_t bufLen;
+	const char *part;
+	size_t partLen;
+	
+	assert(luaUqm_commState != NULL);
+
+	bufLen = 2048;
+	buf = HMalloc (bufLen);
+	if (buf == NULL)
+		return NULL;
+
+	strPtr = str;
+	bufPtr = buf;
+
+	// We go through the string and put all the parts into a Lua table.
+	for (interI = 0; ; interI++) {
+		const char *startTag;
+		const char *endTag;
+		const char *luaStart;
+
+		startTag = strstr (strPtr, "<%");
+		if (startTag == NULL)
+			break;
+		luaStart = startTag + 2;
+
+		// Store the string before the '<%'.
+		luaUqm_comm_addToBuffer (&buf, &bufLen, &bufPtr,
+				strPtr, startTag - strPtr);
+		
+		endTag = strstr (startTag + 2, "%>");
+		if (endTag == NULL) {
+			log_add (log_Error, "luaUqm_stringInterpolate(): Unterminated "
+					"'<%% .. %%>' sequence in string '%s'.", str);
+			// We ignore the rest of the string.
+			goto out;
+		}
+
+		strPtr = endTag + 2;
+		interI++;
+
+		// Compile the string to a Lua function.
+		{
+			size_t exprLen = endTag - luaStart;
+#define LUAEXPR_START "return "
+			char *exprBuf = HMalloc(sizeof LUAEXPR_START + exprLen);
+					// 'sizeof LUAEXPR_START' includes a null byte
+			char *exprBufPtr = exprBuf;
+			strcpy(exprBuf, LUAEXPR_START);
+			exprBufPtr += sizeof LUAEXPR_START - 1;
+			memcpy(exprBufPtr, luaStart, exprLen);
+			exprBufPtr += exprLen;
+			*exprBufPtr = '\0';
+
+			if (luaL_loadstring (luaUqm_commState, exprBuf) != LUA_OK) {
+				log_add (log_Error, "luaUqm_stringInterpolate(): "
+						"lua_loadstring() failed: %s",
+						lua_tostring (luaUqm_commState, -1));
+				lua_pop (luaUqm_commState, 1);
+						// Pop the error.
+				continue;
+			}
+		}
+	
+		// Call the Lua function.
+		if (lua_pcall (luaUqm_commState, 0, 1, 0) != 0) {
+			log_add (log_Error, "[script] luaUqm_stringInterpolate(): A "
+					"script error occurred in interpolation %d in string "
+					"'%s': %s.", interI, str,
+					lua_tostring (luaUqm_commState, -1));
+			lua_pop (luaUqm_commState, 1);
+					// Pop the error.
+			continue;
+		}
+		// Success. Result is on the stack.
+
+		// Convert the result to a string, and get the length.
+		part = lua_tolstring (luaUqm_commState, -1, &partLen);
+		if (part == NULL) {
+			// Not a string and not convertable to a string.
+			log_add (log_Error, "[script] luaUqm_stringInterpolate(): Value "
+					"returned by interpolation %d has type %s, which can not "
+					"be converted to a string, in string " "'%s'.",
+					interI, lua_typename(luaUqm_commState,
+					lua_type(luaUqm_commState, -1)), str);
+			lua_pop (luaUqm_commState, 1);
+			continue;
+		}
+
+		// Store the result of the Lua expression in '<% .. %>'.
+		luaUqm_comm_addToBuffer (&buf, &bufLen, &bufPtr, part, partLen);
+
+		// Pop the result from the stack.
+		lua_pop (luaUqm_commState, 1);
+	}
+
+	// Store the part of the string after the last '<% .. %>'.
+	luaUqm_comm_addToBuffer (&buf, &bufLen, &bufPtr,
+			strPtr, strlen (strPtr));
+
+out:
+	*bufPtr = '\0';
+			// luaUqm_addToBuffer() always leaves one byte for the '\0'.
+
+	{
+		char *newBuf = HRealloc (buf, bufPtr - buf + 1);
+		if (newBuf == NULL)
+		{
+			// If we can't shorten 'newBuf', we'll just keep using the
+			// unnecessarilly long 'buf', and let the next allocating
+			// function worry about the impending memory shortage.
+		}
+		else
+			buf = newBuf;
+	}
+
+	return buf;
+}
+
diff -ruNp src.hd/uqm/lua/luacomm.h src/uqm/lua/luacomm.h
--- src.hd/uqm/lua/luacomm.h	1969-12-31 16:00:00 -0800
+++ src/uqm/lua/luacomm.h	2017-12-29 00:57:46 -0800
@@ -0,0 +1,46 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _LUACOMM_H
+#define _LUACOMM_H
+
+#include "libs/compiler.h"
+#include "libs/reslib.h"
+#include "luafuncs/customfuncs.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+BOOLEAN luaUqm_comm_init(const luaUqm_custom_Function *customFuncs,
+		RESOURCE scriptRes);
+void luaUqm_comm_uninit(void);
+
+void luaUqm_comm_genericInit(void);
+void luaUqm_comm_genericPost(void);
+void luaUqm_comm_genericUninit(void);
+
+BOOLEAN luaUqm_comm_stringNeedsInterpolate(const char *str);
+char *luaUqm_comm_stringInterpolate(const char *str);
+
+extern lua_State *luaUqm_commState;
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif  /* _LUACOMM_H */
+
diff -ruNp src.hd/uqm/lua/luadebug.c src/uqm/lua/luadebug.c
--- src.hd/uqm/lua/luadebug.c	1969-12-31 16:00:00 -0800
+++ src/uqm/lua/luadebug.c	2017-12-29 00:57:46 -0800
@@ -0,0 +1,207 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+//#include <stdlib.h>
+//#include <lauxlib.h>
+#include <string.h>
+
+#define LUAUQM_INTERNAL
+#include "port.h"
+#include "luadebug.h"
+
+//#include "libs/scriptlib.h"
+//#include "libs/misc.h"
+#include "uqm/lua/luastate.h"
+#include "luafuncs/commfuncs.h"
+#include "luafuncs/eventfuncs.h"
+#include "luafuncs/logfuncs.h"
+#include "luafuncs/statefuncs.h"
+
+
+#define LINEBUFLEN 2048
+		// Maximum size of one input line.
+		// Long enough for long oneliners.
+
+typedef struct luaUqm_DebugContext {
+	FILE *in;
+	FILE *out;
+	FILE *err;
+	lua_State *debugState;
+} luaUqm_DebugContext;
+
+
+static void luaUqm_debug_interactive(FILE *in, FILE *out, FILE *err);
+static void luaUqm_debug_outputCallback(void *extra,
+		const char *format, ...);
+static void luaUqm_debug_errorCallback(void *extra,
+		const char *format, ...);
+
+
+lua_State *luaUqm_debugState = NULL;
+	
+static const luaL_Reg debugLibs[] = {
+	{ "comm",    luaUqm_comm_open },
+	{ "event",   luaUqm_event_open },
+	{ "log",     luaUqm_log_open },
+	//{ "package", luaUqm_package_open },
+	{ "state",   luaUqm_state_open },
+	{ NULL, NULL }
+};
+
+// Not reentrant.
+// If 'customFuncs' is NULL, no 'custom' table is added to the Lua environment.
+// If 'scriptRes' is NULL_RESOURCE, then no script is loaded. Lua is only
+// available for string interpolation in this case.
+void
+luaUqm_debug_init(void) {
+	assert(luaUqm_debugState == NULL);
+
+	luaUqm_debugState = luaUqm_globalState;
+
+	// Prepare the global environment.
+	luaUqm_prepareEnvironment(luaUqm_debugState);
+	luaUqm_loadLibs(luaUqm_debugState, debugLibs);
+}
+
+void
+luaUqm_debug_uninit(void) {
+	assert(luaUqm_debugState != NULL);
+	luaUqm_debugState = NULL;
+}
+
+void
+luaUqm_debug_run(void) {
+	luaUqm_debug_init();
+
+	luaUqm_debug_interactive(stdin, stdout, stderr);
+
+	luaUqm_debug_uninit();
+}
+
+static void
+luaUqm_debug_interactive(FILE *in, FILE *out, FILE *err) {
+	char lineBuf[LINEBUFLEN];
+	size_t lineLen;
+	luaUqm_DebugContext debugContext;
+	memset(&debugContext, '\0', sizeof (luaUqm_DebugContext));
+	debugContext.in = in;
+	debugContext.out = out;
+	debugContext.err = err;
+	debugContext.debugState = luaUqm_debugState;
+
+	for (;;) {
+		fprintf(out, "> ");
+
+		if (fgets(lineBuf, LINEBUFLEN, in) == NULL) {
+			if (feof(in)) {
+				// user pressed ^D
+				break;
+			}
+			// error occured
+			clearerr(in);
+			continue;
+		}
+		lineLen = strlen(lineBuf);
+		if (lineBuf[lineLen - 1] != '\n' && lineBuf[lineLen - 1] != '\r') {
+			fprintf(err, "Error: Too long command line.\n");
+			// TODO: read until EOL
+			continue;
+		}
+
+		luaUqm_debug_runLine(lineBuf,
+				luaUqm_debug_outputCallback,
+				luaUqm_debug_errorCallback,
+				(void *) &debugContext);
+	}
+}
+
+// Run a Lua command.
+// This function is currently used by luaUqm_debug_interactive, but should
+// also be suitable if we have some graphical console, when different
+// callback functions than luaUqm_debug_outputCallback() and
+// luaUqm_debug_errorCallback are used.
+void
+luaUqm_debug_runLine(const char *exprBuf,
+		void (*outputCallback)(void *extra, const char *format, ...),
+		void (*errorCallback)(void *extra, const char *format, ...),
+		void *extra) {
+	int resultType;
+	const char *resultStr;
+	const char *resultTypeStr;
+
+	// Compile the string to a Lua function.
+	{
+		if (luaL_loadstring (luaUqm_debugState, exprBuf) != LUA_OK) {
+			// An error occurred during parsing.
+			errorCallback(extra, "Syntax error: %s\n",
+					lua_tostring (luaUqm_debugState, -1));
+			lua_pop(luaUqm_debugState, 1);
+					// Pop the error.
+			return;
+		}
+	}
+
+	// Call the Lua function.
+	if (lua_pcall (luaUqm_debugState, 0, 1, 0) != 0) {
+		// An error occurred during execution.
+		errorCallback(extra, "Runtime error: %s\n",
+				lua_tostring (luaUqm_debugState, -1));
+		lua_pop(luaUqm_debugState, 1);
+				// Pop the error.
+		return;
+	}
+	// Success. Result is on the stack.
+
+	// Convert the result to a string.
+	resultType = lua_type(luaUqm_debugState, -1);
+	resultTypeStr = lua_typename(luaUqm_debugState, resultType);
+	resultStr = lua_tolstring (luaUqm_debugState, -1, NULL);
+			// Memory for 'resultStr' lasts until the lua_pop().
+	if (resultStr == NULL) {
+		// Not a string and not convertable to a string.
+		// The command was executed ok though, and we treat this as such.
+		outputCallback(extra, "(%s)\n", resultTypeStr);
+	} else {
+		outputCallback(extra, "(%s) %s\n", resultTypeStr, resultStr);
+	}
+
+	// Pop the result from the stack.
+	lua_pop (luaUqm_debugState, 1);
+}
+
+// Called to output regular output messages.
+static void
+luaUqm_debug_outputCallback(void *extra, const char *format, ...) {
+	va_list args;
+	luaUqm_DebugContext *debugContext = (luaUqm_DebugContext *) extra;
+
+	va_start(args, format);
+	vfprintf(debugContext->out, format, args);
+	va_end(args);
+}
+
+// Called to output error messages.
+static void
+luaUqm_debug_errorCallback(void *extra, const char *format, ...) {
+	va_list args;
+	luaUqm_DebugContext *debugContext = (luaUqm_DebugContext *) extra;
+
+	va_start(args, format);
+	vfprintf(debugContext->err, format, args);
+	va_end(args);
+}
+
+
diff -ruNp src.hd/uqm/lua/luadebug.h src/uqm/lua/luadebug.h
--- src.hd/uqm/lua/luadebug.h	1969-12-31 16:00:00 -0800
+++ src/uqm/lua/luadebug.h	2017-12-29 00:57:46 -0800
@@ -0,0 +1,30 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef LUADEBUG_H
+#define LUADEBUG_H
+
+void luaUqm_debug_init(void);
+void luaUqm_debug_uninit(void);
+void luaUqm_debug_run(void);
+void luaUqm_debug_runLine(const char *exprBuf,
+		void (*outputCallback)(void *extra, const char *format, ...),
+		void (*errorCallback)(void *extra, const char *format, ...),
+		void *extra);
+
+#endif  /* LUADEBUG_H */
+
+
diff -ruNp src.hd/uqm/lua/luaevent.c src/uqm/lua/luaevent.c
--- src.hd/uqm/lua/luaevent.c	1969-12-31 16:00:00 -0800
+++ src/uqm/lua/luaevent.c	2017-12-29 00:57:46 -0800
@@ -0,0 +1,126 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * This file contains code for using Lua for game event scripts.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+
+#define LUAUQM_INTERNAL
+#include "port.h"
+#include "luaevent.h"
+
+#include "options.h"
+		// For contentDir
+#include "libs/scriptlib.h"
+#include "uqm/lua/luastate.h"
+#include "luafuncs/customfuncs.h"
+#include "luafuncs/eventfuncs.h"
+#include "luafuncs/logfuncs.h"
+#include "luafuncs/statefuncs.h"
+#include "libs/log.h"
+
+lua_State *luaUqm_eventState = NULL;
+	
+static const luaL_Reg eventLibs[] = {
+	{ "event", luaUqm_event_open },
+	{ "log",   luaUqm_log_open },
+	{ "state", luaUqm_state_open },
+	{ NULL, NULL }
+};
+
+// Not reentrant.
+BOOLEAN
+luaUqm_event_init(const luaUqm_custom_Function *customFuncs,
+		RESOURCE scriptRes) {
+	char *scriptFileName;
+	BOOLEAN loadOk;
+
+	assert(luaUqm_eventState == NULL);
+
+#ifdef EVENT_DEBUG
+	log_add(log_Debug, "[script] Calling luaUqm_event_init()");
+#endif
+
+	luaUqm_eventState = luaUqm_globalState;
+
+	// Prepare the global environment.
+	luaUqm_prepareEnvironment(luaUqm_eventState);
+	luaUqm_loadLibs(luaUqm_eventState, eventLibs);
+	luaUqm_custom_init(luaUqm_eventState, customFuncs);
+	lua_pop(luaUqm_eventState, 1);
+
+	// Get the name of the script.
+	scriptFileName = LoadScriptInstance(scriptRes);
+	if (scriptFileName == NULL)
+		return FALSE;
+
+	// Load the script.
+	loadOk = luaUqm_loadScript(luaUqm_eventState, contentDir, scriptFileName);
+	ReleaseScriptResData(scriptFileName);
+	if (!loadOk)
+		return FALSE;
+
+	// Call the script.
+	luaUqm_callStackFunction(luaUqm_eventState);
+	return TRUE;
+}
+
+void
+luaUqm_event_uninit(void) {
+	assert(luaUqm_eventState != NULL);
+
+#ifdef EVENT_DEBUG
+	log_add(log_Debug, "[script] Calling luaUqm_event_uninit()");
+#endif
+
+	luaUqm_eventState = NULL;
+}
+
+void
+luaUqm_event_callEvent(const char *eventIdStr) {
+	assert(luaUqm_eventState != NULL);
+
+#ifdef EVENT_DEBUG
+	log_add(log_Debug, "[script] Calling luaUqm_event_callEvent(\"%s\")",
+			eventIdStr);
+#endif
+
+	luaUqm_getEventTable(luaUqm_eventState);
+	lua_pushstring(luaUqm_eventState, eventIdStr);
+	// [-2] -> table eventTable
+	// [-1] -> string eventIdStr
+	lua_gettable(luaUqm_eventState, -2);
+
+	// [-2] -> table eventTable
+	// [-1] -> function eventFun
+	if (lua_isnil(luaUqm_eventState, -1)) {
+		log_add(log_Warning, "[script] Warning: luaUqm_event_callEvent(): "
+				"Event '%s' is not registered.", eventIdStr);
+		lua_pop(luaUqm_eventState, 2);
+		return;
+	}
+
+	// [-2] -> table eventTable
+	// [-1] -> function eventFun
+	lua_replace(luaUqm_eventState, -2);
+
+	// [-1] -> function eventFun
+	luaUqm_callStackFunction(luaUqm_eventState);
+}
+
diff -ruNp src.hd/uqm/lua/luaevent.h src/uqm/lua/luaevent.h
--- src.hd/uqm/lua/luaevent.h	1969-12-31 16:00:00 -0800
+++ src/uqm/lua/luaevent.h	2017-12-29 00:57:46 -0800
@@ -0,0 +1,43 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _LUAEVENT_H
+#define _LUAEVENT_H
+
+//#define EVENT_DEBUG
+
+#include "libs/compiler.h"
+#include "libs/reslib.h"
+#include "luafuncs/customfuncs.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+BOOLEAN luaUqm_event_init(const luaUqm_custom_Function *customFuncs,
+		RESOURCE scriptRes);
+void luaUqm_event_uninit(void);
+
+void luaUqm_event_callEvent(const char *eventIdStr);
+
+extern lua_State *luaUqm_commState;
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif  /* _LUAEVENT_H */
+
diff -ruNp src.hd/uqm/lua/luafuncs/Makeinfo src/uqm/lua/luafuncs/Makeinfo
--- src.hd/uqm/lua/luafuncs/Makeinfo	1969-12-31 16:00:00 -0800
+++ src/uqm/lua/luafuncs/Makeinfo	2017-12-29 00:57:46 -0800
@@ -0,0 +1,2 @@
+uqm_CFILES="commfuncs.c customfuncs.c eventfuncs.c logfuncs.c statefuncs.c"
+uqm_HFILES="commfuncs.h customfuncs.h eventfuncs.h logfuncs.h statefuncs.h"
diff -ruNp src.hd/uqm/lua/luafuncs/README.txt src/uqm/lua/luafuncs/README.txt
--- src.hd/uqm/lua/luafuncs/README.txt	1969-12-31 16:00:00 -0800
+++ src/uqm/lua/luafuncs/README.txt	2017-12-29 00:57:46 -0800
@@ -0,0 +1 @@
+This directory contains bindings exposing UQM functionality to Lua scripts.
diff -ruNp src.hd/uqm/lua/luafuncs/commfuncs.c src/uqm/lua/luafuncs/commfuncs.c
--- src.hd/uqm/lua/luafuncs/commfuncs.c	1969-12-31 16:00:00 -0800
+++ src/uqm/lua/luafuncs/commfuncs.c	2017-12-29 00:57:46 -0800
@@ -0,0 +1,339 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * Right now, the functions to call as a callback for responses are stored
+ * in the Lua registry. This could however also be handled in Lua code
+ * itself: one generic Lua function which is called after a response, which
+ * then calls the appropriate function which was registered for the response
+ * in Lua code.
+ */
+
+#include <stdlib.h>
+
+#define LUAUQM_INTERNAL
+#include "commfuncs.h"
+#include "libs/scriptlib.h"
+#include "libs/log.h"
+
+#include "uqm/lua/luacomm.h"
+#include "uqm/commglue.h"
+#include "uqm/battle.h"
+		// For instantVictory
+
+
+static const char npcPhraseCallbackRegistryKey[] =
+		"uqm_comm_npcPhraseCallback";
+		// Key in the registry storing the callback function for
+		// after an NPC phrase is complete.
+static const char responseCallbackRegistryKey[] =
+		"uqm_comm_responseCallback";
+		// Key in the registry storing a table callback function for
+		// after an NPC phrase is complete.
+
+
+static int luaUqm_comm_isPhraseEnabled(lua_State *luaState);
+static int luaUqm_comm_disablePhrase(lua_State *luaState);
+static int luaUqm_comm_doNpcPhrase(lua_State *luaState);
+static int luaUqm_comm_addResponse(lua_State *luaState);
+static int luaUqm_comm_getPhrase(lua_State *luaState);
+static int luaUqm_comm_getSegue(lua_State *luaState);
+static int luaUqm_comm_setSegue(lua_State *luaState);
+static int luaUqm_comm_isInOuttakes(lua_State *luaState);
+
+static const luaL_Reg commFuncs[] = {
+	{ "addResponse",     luaUqm_comm_addResponse },
+	{ "disablePhrase",   luaUqm_comm_disablePhrase },
+	{ "doNpcPhrase",     luaUqm_comm_doNpcPhrase },
+	{ "getPhrase",       luaUqm_comm_getPhrase },
+	{ "getSegue",        luaUqm_comm_getSegue },
+	{ "isInOuttakes",    luaUqm_comm_isInOuttakes },
+	{ "isPhraseEnabled", luaUqm_comm_isPhraseEnabled },
+	{ "setSegue",        luaUqm_comm_setSegue },
+	{ NULL,              NULL },
+};
+
+static const luaUqm_EnumValue segueEnum[] = {
+	{ /* .name = */ "peace",   /* .value = */ Segue_peace  },
+	{ /* .name = */ "hostile", /* .value = */ Segue_hostile  },
+	{ /* .name = */ "victory", /* .value = */ Segue_victory },
+	{ /* .name = */ "defeat",  /* .value = */ Segue_defeat  },
+	{ /* .name = */ NULL,      /* .value = */ 0             },
+};
+
+int
+luaUqm_comm_open(lua_State *luaState) {
+	luaL_newlib(luaState, commFuncs);
+
+	luaUqm_makeEnum(luaState, segueEnum);
+	// [-2] -> table commTable
+	// [-1] -> table segueEnum
+	lua_setfield(luaState, -2, "segue");
+			// comm.segue = segueEnum
+	
+	// Prepare a table to store the callback functions for each response in.
+	lua_newtable(luaState);
+    lua_setfield(luaState, LUA_REGISTRYINDEX, responseCallbackRegistryKey);
+
+	return 1;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+
+// Helper function. Returns the value of the RESPONSE_REF for the
+// phrase given as a string on stack position [1].
+// If it does not exist, -1 is returned and a warning is printed.
+// [1] -> string phraseIdStr
+static int
+testPhraseId(lua_State *luaState, int argn) {
+	const char *phraseIdStr = luaL_checkstring(luaState, argn);
+	RESPONSE_REF phraseId = phraseIdStrToNum(phraseIdStr);
+	if (phraseId == (RESPONSE_REF) -1) {
+		// TODO: print script file name.
+		log_add(log_Error, "[script] Warning: testPhraseId(): No phrase "
+				"exists with id '%s'.", phraseIdStr);
+		return -1;
+	}
+
+	return (int) phraseId;
+}
+
+// Pushes the string, or nil if the string is not known.
+static void
+pushPhraseId(lua_State *luaState, RESPONSE_REF response) {
+	const char *phraseIdStr = phraseIdNumToStr(response);
+	if (phraseIdStr != NULL) {
+		lua_pushstring(luaState, phraseIdStr);
+	} else {
+		lua_pushnil(luaState);
+	}
+}
+
+// Store a Lua callback function to be called from npcPhraseCallback(),
+// which is used as a callback for NPCPhrase_cb().
+// [n] -> function callback
+static void
+setNpcPhraseCallback(lua_State *luaState, int argn) {
+	lua_pushvalue(luaState, argn);
+    lua_setfield(luaState, LUA_REGISTRYINDEX, npcPhraseCallbackRegistryKey);
+}
+
+// The callback function is pushed on the stack.
+static void
+pushNpcPhraseCallback(lua_State *luaState) {
+    lua_getfield(luaState, LUA_REGISTRYINDEX, npcPhraseCallbackRegistryKey);
+}
+
+static void
+pushResponseCallbackRegistry(lua_State *luaState) {
+    lua_getfield(luaState, LUA_REGISTRYINDEX, responseCallbackRegistryKey);
+}
+
+// [n] -> function callback
+// Store a Lua callback function to be called from responseCallback(),
+// which is used as a callback for Response().
+static void
+setResponseCallback(lua_State *luaState, int responseArgN,
+		int callbackArgN) {
+	pushResponseCallbackRegistry(luaState);
+	// [-1] -> table responseCallbackRegistry
+
+	lua_pushvalue(luaState, responseArgN);
+	lua_pushvalue(luaState, callbackArgN);
+	// [-3] -> table responseCallbackRegistry
+	// [-2] -> string response
+	// [-1] -> function callback
+    lua_settable(luaState, -3);
+	
+	// [-3] -> table responseCallbackRegistry
+	lua_pop(luaState, 1);
+}
+
+// The callback function is pushed on the stack.
+static void
+pushResponseCallback(lua_State *luaState, RESPONSE_REF response) {
+	pushResponseCallbackRegistry(luaState);
+	pushPhraseId(luaState, response);
+	// [-2] -> table responseCallbackRegistry
+	// [-1] -> string response
+	lua_gettable(luaState, -2);
+
+	// [-2] -> table responseCallbackRegistry
+	// [-1] -> function callback
+	lua_replace(luaState, -2);
+	// [-1] -> function callback
+}
+
+// Used as a callback function for NPCPhrase_cb().
+// It in turn calls the registered Lua callback function.
+static void
+npcPhraseCallback(CallbackArg extra) {
+	pushNpcPhraseCallback(luaUqm_commState);
+	if (lua_pcall(luaUqm_commState, 0, 0, 0) != 0) {
+		// An error occurred. We continue nonetheless.
+		log_add(log_Error, "[script] An error occurred during a "
+				"doNpcPhrase() callback: %s",
+				lua_tostring(luaUqm_commState, -1));
+		lua_pop(luaUqm_commState, 1);
+	}
+	(void) extra;
+}
+
+// Used as a callback function for Response().
+// It in turn calls the registered Lua callback function.
+static void
+responseCallback(RESPONSE_REF response) {
+	pushResponseCallback(luaUqm_commState, response);
+	pushPhraseId(luaUqm_commState, response);
+	if (lua_pcall(luaUqm_commState, 1, 0, 0) != 0) {
+		// An error occurred. We continue nonetheless.
+		log_add(log_Error, "[script] An error occurred during an "
+				"addResponse() callback: %s",
+				lua_tostring(luaUqm_commState, -1));
+		lua_pop(luaUqm_commState, 1);
+	}
+}
+
+/////////////////////////////////////////////////////////////////////////////
+
+// [1] -> string phraseIdStr
+static int
+luaUqm_comm_isPhraseEnabled(lua_State *luaState) {
+	int phraseId = testPhraseId(luaState, 1);
+	if (phraseId == -1) {
+		lua_pushboolean(luaState, FALSE);
+		return 1;
+	}
+
+	lua_pushboolean(luaState, PHRASE_ENABLED(phraseId));
+	return 1;
+}
+
+// [1] -> string phraseIdStr
+static int
+luaUqm_comm_disablePhrase(lua_State *luaState) {
+	int phraseId = testPhraseId(luaState, 1);
+	if (phraseId == -1)
+		return 0;
+
+	DISABLE_PHRASE(phraseId);
+	return 0;
+}
+
+// [1] -> string phraseIdStr
+static int
+luaUqm_comm_doNpcPhrase(lua_State *luaState) {
+	CallbackFunction callback;
+	int phraseId = testPhraseId(luaState, 1);
+	if (phraseId == -1)
+		return 0;
+
+	if (lua_gettop(luaState) >= 2) {
+		// Callback function specified in second argument.
+		setNpcPhraseCallback(luaState, 2);
+		callback = npcPhraseCallback;
+	} else {
+		callback = NULL;
+	}
+
+	NPCPhrase_cb(phraseId, callback);
+	return 0;
+}
+
+// [1] -> string phraseIdStr
+// [2] -> function callback
+static int
+luaUqm_comm_addResponse(lua_State *luaState) {
+	int phraseId = testPhraseId(luaState, 1);
+	if (phraseId == -1)
+		return 0;
+
+	luaL_checktype(luaState, 2, LUA_TFUNCTION);
+
+	setResponseCallback(luaState, 1, 2);
+	Response(phraseId, responseCallback);
+	return 0;
+}
+
+// [1] -> string phraseIdStr
+static int
+luaUqm_comm_getPhrase(lua_State *luaState) {
+	int phraseId;
+	STRING str;
+	const char *strBuf;
+
+	phraseId = testPhraseId(luaState, 1);
+	if (phraseId == -1) {
+		// A warning is already printed in testPhraseId().
+		lua_pushnil(luaState);
+		return 1;
+	}
+
+	// Find the string.
+	str = SetAbsStringTableIndex(CommData.ConversationPhrases,
+			phraseId - 1);
+	strBuf = GetStringAddress(str);
+
+	if (luaUqm_comm_stringNeedsInterpolate(strBuf))
+	{
+		char *interpolated = luaUqm_comm_stringInterpolate(strBuf);
+		lua_pushstring(luaState, interpolated);  // This makes a copy.
+		HFree(interpolated);
+	}
+	else
+	{
+		// No interpolation is necessary.
+		lua_pushstring(luaState, strBuf);
+	}
+
+	// [1] -> string phrase
+	return 1;
+}
+
+static int
+luaUqm_comm_getSegue(lua_State *luaState) {
+	int result = getSegue();
+	lua_pushinteger(luaState, result);
+	return 1;
+}
+
+// [1] -> string phraseIdStr
+static int
+luaUqm_comm_setSegue(lua_State *luaState) {
+	int what = luaL_checkint(luaState, 1);
+	switch ((Segue) what) {
+		case Segue_peace:
+		case Segue_hostile:
+		case Segue_victory:
+		case Segue_defeat:
+			break;
+		default:
+			log_add(log_Error, "[script] Warning: setSegue(): Invalid "
+					"parameter value (%d).", what);
+			break;
+	};
+	setSegue((Segue) what);
+
+	return 0;
+}
+
+static int
+luaUqm_comm_isInOuttakes(lua_State *luaState) {
+	BOOLEAN result = (LOBYTE(GLOBAL(CurrentActivity)) == WON_LAST_BATTLE);
+	lua_pushboolean(luaState, result);
+	return 1;
+}
+
diff -ruNp src.hd/uqm/lua/luafuncs/commfuncs.h src/uqm/lua/luafuncs/commfuncs.h
--- src.hd/uqm/lua/luafuncs/commfuncs.h	1969-12-31 16:00:00 -0800
+++ src/uqm/lua/luafuncs/commfuncs.h	2017-12-29 00:57:46 -0800
@@ -0,0 +1,33 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _COMMFUNCS_H
+#define _COMMFUNCS_H
+
+#include "libs/scriptlib.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+int luaUqm_comm_open(lua_State *luaState);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif  /* _COMMFUNCS_H */
+
diff -ruNp src.hd/uqm/lua/luafuncs/customfuncs.c src/uqm/lua/luafuncs/customfuncs.c
--- src.hd/uqm/lua/luafuncs/customfuncs.c	1969-12-31 16:00:00 -0800
+++ src/uqm/lua/luafuncs/customfuncs.c	2017-12-29 00:57:46 -0800
@@ -0,0 +1,92 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <stdlib.h>
+
+#define LUAUQM_INTERNAL
+#include "customfuncs.h"
+#include "libs/scriptlib.h"
+#include "libs/log.h"
+
+
+// We use a wrapper, so that we can call the custom function with the
+// arguments of our choice (i.e. no arguments).
+static int
+luaFunctionWrapper(lua_State *luaState) {
+	int arg;
+	int result;
+	int isNum;
+	int (*fun)(int) = lua_topointer(luaState, lua_upvalueindex(1));
+
+	if (lua_gettop(luaState) == 0) {
+		arg = 0;
+	} else {
+		arg = lua_tointegerx (luaState, -1, &isNum);
+		if (!isNum) {
+			log_add(log_Error, "[script] Warning: luaFunctionWrapper(): "
+					"Invalid type of argument to custom function (%s).",
+					lua_typename(luaState, lua_type(luaState, -1)));
+			// arg will be 0
+		}
+	}
+	
+	result = (*fun)(arg);
+	lua_pushinteger(luaState, result);
+	return 1;
+}
+
+// [-1]  -> table t
+// We keep the actual pointer as an upvalue in the closure.
+static int
+luaUqm_custom_addFunction(lua_State *luaState,
+		const luaUqm_custom_Function *fun) {
+	lua_pushlightuserdata (luaState, (void *) fun->fun);
+	lua_pushcclosure(luaState, luaFunctionWrapper, 1);
+	// [-2] -> table t
+	// [-1] -> function fun
+	lua_setfield(luaState, -2, fun->name);
+	return 1;
+}
+
+// Returns with the new table on the stack.
+int
+luaUqm_custom_init(lua_State *luaState,
+		const luaUqm_custom_Function *funs) {
+	// Count the number of functions.
+	size_t funCount = 0;
+	const luaUqm_custom_Function *ptr;
+
+	for (ptr = funs; ptr->name != NULL; ptr++)
+		funCount++;
+
+	lua_pushglobaltable(luaState);
+
+	// Create a table for 'custom'.
+	lua_createtable(luaState, 0, funCount);
+
+	// Fill the 'custom' table.
+	for (ptr = funs; ptr->name != NULL; ptr++)
+		luaUqm_custom_addFunction(luaState, ptr);
+
+	// Set 'custom' to the custom table.
+	// [-2] -> table globalTable
+	// [-1] -> table custom
+	lua_setfield(luaState, -2, "custom");
+	
+	// [-1] -> table custom
+	return 0;
+}
+
diff -ruNp src.hd/uqm/lua/luafuncs/customfuncs.h src/uqm/lua/luafuncs/customfuncs.h
--- src.hd/uqm/lua/luafuncs/customfuncs.h	1969-12-31 16:00:00 -0800
+++ src/uqm/lua/luafuncs/customfuncs.h	2017-12-29 00:57:46 -0800
@@ -0,0 +1,50 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _CUSTOMFUNCS_H
+#define _CUSTOMFUNCS_H
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+typedef struct luaUqm_custom_Function luaUqm_custom_Function;
+
+#if defined(__cplusplus)
+}
+#endif
+
+#include "libs/scriptlib.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+struct
+luaUqm_custom_Function {
+	const char *name;
+	int (*fun)(int);
+};
+
+int luaUqm_custom_init(lua_State *luaState,
+		const luaUqm_custom_Function *funs);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif  /* CUSTOMFUNCS_H */
+
diff -ruNp src.hd/uqm/lua/luafuncs/eventfuncs.c src/uqm/lua/luafuncs/eventfuncs.c
--- src.hd/uqm/lua/luafuncs/eventfuncs.c	1969-12-31 16:00:00 -0800
+++ src/uqm/lua/luafuncs/eventfuncs.c	2017-12-29 00:57:46 -0800
@@ -0,0 +1,194 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <stdlib.h>
+
+#define LUAUQM_INTERNAL
+#include "eventfuncs.h"
+#include "uqm/clock.h"
+#include "uqm/gameev.h"
+#include "uqm/lua/luastate.h"
+#include "libs/scriptlib.h"
+#include "libs/log.h"
+
+
+static int luaUqm_event_addAbsolute(lua_State *luaState);
+static int luaUqm_event_addRelative(lua_State *luaState);
+static int luaUqm_event_register(lua_State *luaState);
+static int luaUqm_event_unregister(lua_State *luaState);
+
+static const luaL_Reg eventFuncs[] = {
+	{ "addAbsolute", luaUqm_event_addAbsolute },
+	{ "addRelative", luaUqm_event_addRelative },
+	{ "register",    luaUqm_event_register },
+	{ "unregister",  luaUqm_event_unregister },
+	{ NULL,          NULL },
+};
+
+int
+luaUqm_event_open(lua_State *luaState) {
+	luaL_newlib(luaState, eventFuncs);
+
+	return 1;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+
+// argn -> the relative index on the lua stack which contains the Lua
+//         string identifying the event.
+// Returns true if and only if an event is registered.
+static BOOLEAN
+isEventRegistered(lua_State *luaState, int argn)
+{
+	BOOLEAN result;
+	argn = lua_absindex(luaState, argn);
+
+	luaUqm_getEventTable(luaState);
+	lua_pushvalue(luaState, argn);
+	// [-2] -> table eventTable
+	// [-1] -> string eventIdStr
+	lua_gettable(luaState, -2);
+
+	// [-2] -> table eventTable
+	// [-1] -> function eventFun
+	result = !lua_isnil(luaState, -1);
+
+	// [-2] -> table eventTable
+	// [-1] -> function eventFun
+	lua_pop(luaState, 2);
+
+	return result;
+}
+
+// [1] -> int year
+// [2] -> int month
+// [3] -> int day
+// [4] -> string eventIdStr
+// Returns -1 on error, and a different value otherwise (currently 0, but
+// don't rely on this).
+// TODO: make this function return an identifier for the event, so that it
+// can be removed.
+static int
+addEvent(lua_State *luaState, EVENT_TYPE type) {
+	int year = luaL_checkint(luaState, 1);
+	int month = luaL_checkint(luaState, 2);
+	int day = luaL_checkint(luaState, 3);
+	const char *eventIdStr = luaL_checkstring(luaState, 4);
+	int eventNum;
+	HEVENT event;
+
+	if (!isEventRegistered(luaState, 4)) {
+		log_add(log_Warning, "[script] event.%s(): Event '%s' is "
+				"not registered.",
+				(type == RELATIVE_EVENT) ? "addRelative" : "addAbsolute",
+				lua_tostring(luaState, 1));
+		lua_pushinteger(luaState, -1);
+		return 1;
+	}
+	
+	eventNum = eventIdStrToNum(eventIdStr);
+	if (eventNum == -1) {
+		log_add(log_Warning, "[script] event.%s(): Event '%s' is "
+				"not known. It must currently be one of the hard-coded "
+				"strings.",
+				(type == RELATIVE_EVENT) ? "addRelative" : "addAbsolute",
+				lua_tostring(luaState, 1));
+		lua_pushinteger(luaState, -1);
+		return 1;
+	}
+
+	event = AddEvent(type, month, day, year, eventNum);
+	lua_pushinteger(luaState, (event == NULL) ? -1 : 0);
+	return 1;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+
+// [1] -> int year
+// [2] -> int month
+// [3] -> int day
+// [4] -> string eventIdStr
+// TODO: make this function return an identifier for the event, so that it
+// can be removed.
+static int
+luaUqm_event_addAbsolute(lua_State *luaState) {
+	return addEvent(luaState, ABSOLUTE_EVENT);
+}
+
+// [1] -> int years
+// [2] -> int months
+// [3] -> int days
+// [4] -> string eventIdStr
+// Returns -1 on error, and 0 otherwise.
+// TODO: make this function return an identifier for the event, so that it
+// can be removed.
+static int
+luaUqm_event_addRelative(lua_State *luaState) {
+	return addEvent(luaState, RELATIVE_EVENT);
+}
+
+// [1] -> string eventIdStr
+// [2] -> function eventFun
+static int
+luaUqm_event_register(lua_State *luaState) {
+	(void) luaL_checkstring(luaState, 1);
+	luaL_checktype(luaState, 2, LUA_TFUNCTION);
+
+	if (isEventRegistered(luaState, 1)) {
+		log_add(log_Warning, "[script] event.register(): Event '%s' is "
+				"already registered.", lua_tostring(luaState, 1));
+		return 0;
+	}
+	
+	luaUqm_getEventTable(luaState);
+	lua_pushvalue(luaState, 1);
+	lua_pushvalue(luaState, 2);
+	// [-3] -> table eventTable
+	// [-2] -> string eventIdStr
+	// [-1] -> function eventFun
+	lua_settable(luaState, -3);
+
+	// [-1] -> table eventTable
+	lua_pop(luaState, 1);
+
+	return 0;
+}
+
+// [1] -> string eventIdStr
+static int
+luaUqm_event_unregister(lua_State *luaState) {
+	(void) luaL_checkstring(luaState, 1);
+
+	if (!isEventRegistered(luaState, 1)) {
+		log_add(log_Warning, "[script] event.unregister(): Event '%s' was "
+				"not registered.", lua_tostring(luaState, 1));
+		return 0;
+	}
+	
+	luaUqm_getEventTable(luaState);
+	lua_pushvalue(luaState, 1);
+	lua_pushnil(luaState);
+	// [-3] -> table eventTable
+	// [-2] -> string eventIdStr
+	// [-1] -> nil
+	lua_settable(luaState, -3);
+
+	// [-1] -> table eventTable
+	lua_pop(luaState, 1);
+
+	return 0;
+}
+
diff -ruNp src.hd/uqm/lua/luafuncs/eventfuncs.h src/uqm/lua/luafuncs/eventfuncs.h
--- src.hd/uqm/lua/luafuncs/eventfuncs.h	1969-12-31 16:00:00 -0800
+++ src/uqm/lua/luafuncs/eventfuncs.h	2017-12-29 00:57:46 -0800
@@ -0,0 +1,33 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _EVENTFUNCS_H
+#define _EVENTFUNCS_H
+
+#include "libs/scriptlib.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+int luaUqm_event_open(lua_State *luaState);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif  /* _EVENTFUNCS_H */
+
diff -ruNp src.hd/uqm/lua/luafuncs/logfuncs.c src/uqm/lua/luafuncs/logfuncs.c
--- src.hd/uqm/lua/luafuncs/logfuncs.c	1969-12-31 16:00:00 -0800
+++ src/uqm/lua/luafuncs/logfuncs.c	2017-12-29 00:57:46 -0800
@@ -0,0 +1,82 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define LUAUQM_INTERNAL
+#include "logfuncs.h"
+#include "libs/scriptlib.h"
+#include "libs/log.h"
+
+static int luaUqm_log_debug (lua_State *luaState);
+static int luaUqm_log_error (lua_State *luaState);
+static int luaUqm_log_fatal (lua_State *luaState);
+static int luaUqm_log_info (lua_State *luaState);
+static int luaUqm_log_warn (lua_State *luaState);
+
+static const luaL_Reg logFuncs[] = {
+	{ "debug", luaUqm_log_debug },
+	{ "error", luaUqm_log_error },
+	{ "fatal", luaUqm_log_fatal },
+	{ "info",  luaUqm_log_info },
+	{ "warn",  luaUqm_log_warn },
+	{ NULL,    NULL },
+};
+
+int
+luaUqm_log_open(lua_State *luaState) {
+	luaL_newlib(luaState, logFuncs);
+	return 1;
+}
+
+// [1] -> string logMessage
+static int
+logHelper(lua_State *luaState, log_Level level) {
+	//const char *str = luaL_checkstring(luaState, 1);
+	const char *str = lua_tostring(luaState, 1);
+	// TODO: print the file name of the Lua script being executed.
+	log_add(level, "Lua: %s", str);
+	return 0;
+}
+
+// [1] -> string logMessage
+static int
+luaUqm_log_debug (lua_State *luaState) {
+	return logHelper(luaState, log_Debug);
+}
+
+// [1] -> string logMessage
+static int
+luaUqm_log_error (lua_State *luaState) {
+	return logHelper(luaState, log_Error);
+}
+
+// [1] -> string logMessage
+static int
+luaUqm_log_fatal (lua_State *luaState) {
+	return logHelper(luaState, log_Fatal);
+}
+
+// [1] -> string logMessage
+static int
+luaUqm_log_info (lua_State *luaState) {
+	return logHelper(luaState, log_Info);
+}
+
+// [1] -> string logMessage
+static int
+luaUqm_log_warn (lua_State *luaState) {
+	return logHelper(luaState, log_Warning);
+}
+
diff -ruNp src.hd/uqm/lua/luafuncs/logfuncs.h src/uqm/lua/luafuncs/logfuncs.h
--- src.hd/uqm/lua/luafuncs/logfuncs.h	1969-12-31 16:00:00 -0800
+++ src/uqm/lua/luafuncs/logfuncs.h	2017-12-29 00:57:46 -0800
@@ -0,0 +1,32 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _LOGFUNCS_H
+#define _LOGFUNCS_H
+
+#include "libs/scriptlib.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+int luaUqm_log_open(lua_State *luaState);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif  /* _LOGFUNCS_H */
diff -ruNp src.hd/uqm/lua/luafuncs/statefuncs.c src/uqm/lua/luafuncs/statefuncs.c
--- src.hd/uqm/lua/luafuncs/statefuncs.c	1969-12-31 16:00:00 -0800
+++ src/uqm/lua/luafuncs/statefuncs.c	2017-12-29 00:57:46 -0800
@@ -0,0 +1,545 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <stdlib.h>
+
+#define LUAUQM_INTERNAL
+#include "statefuncs.h"
+#include "libs/scriptlib.h"
+#include "libs/log.h"
+
+#include "uqm/build.h"
+#include "uqm/globdata.h"
+#include "uqm/lua/luastate.h"
+
+
+static int luaUqm_state_clock_getDate(lua_State *luaState);
+static int luaUqm_state_escort_addShips(lua_State *luaState);
+static int luaUqm_state_escort_canAddShips(lua_State *luaState);
+static int luaUqm_state_escort_removeShips (lua_State *luaState);
+static int luaUqm_state_escort_shipCount(lua_State *luaState);
+static int luaUqm_state_escort_totalValue(lua_State *luaState);
+static int luaUqm_state_race_isAlive(lua_State *luaState);
+static int luaUqm_state_race_isAllied(lua_State *luaState);
+static int luaUqm_state_race_isKnown(lua_State *luaState);
+static int luaUqm_state_race_setAlive(lua_State *luaState);
+static int luaUqm_state_race_setAllied(lua_State *luaState);
+static int luaUqm_state_race_setKnown(lua_State *luaState);
+static int luaUqm_state_sis_addCrew(lua_State *luaState);
+static int luaUqm_state_sis_addFuel(lua_State *luaState);
+static int luaUqm_state_sis_addLanders(lua_State *luaState);
+static int luaUqm_state_sis_addResUnits(lua_State *luaState);
+static int luaUqm_state_sis_getCaptainName(lua_State *luaState);
+static int luaUqm_state_sis_getCrew(lua_State *luaState);
+static int luaUqm_state_sis_getFuel(lua_State *luaState);
+static int luaUqm_state_sis_getLanders(lua_State *luaState);
+static int luaUqm_state_sis_getResUnits(lua_State *luaState);
+static int luaUqm_state_sis_getShipName(lua_State *luaState);
+static int luaUqm_state_prop_get(lua_State *luaState);
+static int luaUqm_state_prop_set(lua_State *luaState);
+
+static const luaL_Reg stateClockFuncs[] = {
+	{ "getDate",         luaUqm_state_clock_getDate },
+	{ NULL,              NULL },
+};
+
+static const luaL_Reg stateEscortFuncs[] = {
+	{ "addShips",        luaUqm_state_escort_addShips },
+	{ "canAddShips",     luaUqm_state_escort_canAddShips },
+	{ "removeShips",     luaUqm_state_escort_removeShips },
+	{ "shipCount",       luaUqm_state_escort_shipCount },
+	{ "totalValue",      luaUqm_state_escort_totalValue },
+	{ NULL,              NULL },
+};
+
+static const luaL_Reg statePropFuncs[] = {
+	{ "get",             luaUqm_state_prop_get },
+	{ "set",             luaUqm_state_prop_set },
+	{ NULL,              NULL },
+};
+
+static const luaL_Reg stateRaceFuncs[] = {
+	{ "isAlive",         luaUqm_state_race_isAlive },
+	{ "isAllied",        luaUqm_state_race_isAllied },
+	{ "isKnown",         luaUqm_state_race_isKnown },
+	{ "setAlive",        luaUqm_state_race_setAlive },
+	{ "setAllied",       luaUqm_state_race_setAllied },
+	{ "setKnown",        luaUqm_state_race_setKnown },
+	{ NULL,              NULL },
+};
+
+static const luaL_Reg stateSisFuncs[] = {
+	{ "addCrew",         luaUqm_state_sis_addCrew },
+	{ "addFuel",         luaUqm_state_sis_addFuel },
+	{ "addLanders",      luaUqm_state_sis_addLanders },
+	{ "addResUnits",     luaUqm_state_sis_addResUnits },
+	{ "getCaptainName",  luaUqm_state_sis_getCaptainName },
+	{ "getCrew",         luaUqm_state_sis_getCrew },
+	{ "getFuel",         luaUqm_state_sis_getFuel },
+	{ "getLanders",      luaUqm_state_sis_getLanders },
+	{ "getResUnits",     luaUqm_state_sis_getResUnits },
+	{ "getShipName",     luaUqm_state_sis_getShipName },
+	{ NULL,              NULL },
+};
+
+int
+luaUqm_state_open(lua_State *luaState) {
+	// Create a table on the stack with space reserved for five fields.
+	lua_createtable(luaState, 0, 5);
+
+	luaL_newlib(luaState, stateClockFuncs);
+	lua_setfield(luaState, -2, "clock");
+	
+	luaL_newlib(luaState, stateEscortFuncs);
+	lua_setfield(luaState, -2, "escort");
+	
+	luaL_newlib(luaState, statePropFuncs);
+	lua_setfield(luaState, -2, "prop");
+
+	luaL_newlib(luaState, stateRaceFuncs);
+	lua_setfield(luaState,  -2,"race");
+
+	luaL_newlib(luaState, stateSisFuncs);
+	lua_setfield(luaState, -2, "sis");
+
+	return 1;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+
+// Helper function. Returns an index for the race in the avail_race_q
+// for the race given as a string on stack position [1].
+// If it does not exist, -1 is returned and a warning is printed.
+// [1] -> string raceIdStr
+static COUNT
+testRaceId(lua_State *luaState, int argn) {
+	const char *raceIdStr = luaL_checkstring(luaState, argn);
+	COUNT raceId = RaceIdStrToIndex(raceIdStr);
+	if (raceId == (COUNT) -1) {
+		// TODO: print script file name.
+		log_add(log_Error, "[script] Warning: testRaceId(): No race exists "
+				"with id '%s'.", raceIdStr);
+		return (COUNT) -1;
+	}
+
+	return (COUNT) raceId;
+}
+
+// Helper function. Returns an index for the ship in the avail_race_q
+// for the ship given as a string on stack position [1].
+// If it does not exist, -1 is returned and a warning is printed.
+// [1] -> string shipIdStr
+static COUNT
+testShipId(lua_State *luaState, int argn) {
+	const char *shipIdStr = luaL_checkstring(luaState, argn);
+	COUNT shipId = ShipIdStrToIndex(shipIdStr);
+	if (shipId == (COUNT) -1) {
+		// TODO: print script file name.
+		log_add(log_Error, "[script] Warning: testShipId(): No ship exists "
+				"with id '%s'.", shipIdStr);
+		return (COUNT) -1;
+	}
+
+	return (COUNT) shipId;
+}
+
+#if 0
+// Pushes the string, or nil if the string is not known.
+static void
+pushRaceId(lua_State *luaState, COUNT raceId) {
+	const char *raceIdStr = raceIdNumToStr(raceId);
+	if (raceIdStr != NULL) {
+		lua_pushstring(luaState, raceIdStr);
+	} else {
+		lua_pushnil(luaState);
+	}
+}
+#endif
+
+/////////////////////////////////////////////////////////////////////////////
+
+// Returns a table with the fields 'year', 'month', and 'day'.
+static int
+luaUqm_state_clock_getDate(lua_State *luaState) {
+	// Create a table on the stack with space reserved for 3 fields.
+	lua_createtable(luaState, 0, 3);
+
+	lua_pushinteger(luaState, GLOBAL(GameClock.year_index));
+	lua_setfield(luaState, -2, "year");
+	
+	lua_pushinteger(luaState, GLOBAL(GameClock.month_index));
+	lua_setfield(luaState, -2, "month");
+
+	lua_pushinteger(luaState, GLOBAL(GameClock.day_index));
+	lua_setfield(luaState, -2, "day");
+
+	return 1;
+}
+
+// [1] -> string shipIdStr
+// [2] -> int count
+static int
+luaUqm_state_escort_addShips(lua_State *luaState) {
+	COUNT shipId;
+	int count;
+	int numAdded;
+
+	shipId = testShipId(luaState, 1);
+	if (shipId == (COUNT) -1) {
+		lua_pushboolean(luaState, FALSE);
+		return 1;
+	}
+
+	count = luaL_checkint(luaState, 2);
+
+	numAdded = AddEscortShips(shipId, count);
+	lua_pushinteger(luaState, numAdded);
+	return 1;
+}
+
+// [1] -> string shipIdStr
+static int
+luaUqm_state_escort_canAddShips(lua_State *luaState) {
+	COUNT shipId;
+	int result;
+
+	shipId = testShipId(luaState, 1);
+	if (shipId == (COUNT) -1) {
+		lua_pushboolean(luaState, FALSE);
+		return 1;
+	}
+
+	result = EscortFeasibilityStudy(shipId);
+	lua_pushinteger(luaState, result);
+	return 1;
+}
+
+// [1] -> string shipIdStr
+// [2] -> int count
+static int
+luaUqm_state_escort_removeShips(lua_State *luaState) {
+	COUNT shipId;
+	int numRemoved;
+
+	shipId = testShipId(luaState, 1);
+	if (shipId == (COUNT) -1) {
+		lua_pushboolean(luaState, FALSE);
+		return 1;
+	}
+
+	if (lua_isnil(luaState, 2)) {
+		numRemoved = RemoveEscortShips(shipId);
+	} else {
+		int count = luaL_checkint(luaState, 2);
+		numRemoved = RemoveSomeEscortShips(shipId, count);
+	}
+
+	lua_pushinteger(luaState, numRemoved);
+	return 1;
+}
+
+// [1] -> string shipIdStr
+static int
+luaUqm_state_escort_shipCount(lua_State *luaState) {
+	COUNT shipId;
+	int result;
+
+	shipId = testShipId(luaState, 1);
+	if (shipId == (COUNT) -1) {
+		lua_pushboolean(luaState, FALSE);
+		return 1;
+	}
+
+	result = CountEscortShips(shipId);
+	lua_pushinteger(luaState, result);
+	return 1;
+}
+
+// No arguments
+static int
+luaUqm_state_escort_totalValue(lua_State *luaState) {
+	COUNT result = CalculateEscortsWorth();
+	lua_pushinteger(luaState, result);
+	return 1;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+
+// [1] -> string raceIdStr
+static int
+luaUqm_state_race_isAlive(lua_State *luaState) {
+	COUNT raceId;
+	BOOLEAN result;
+
+	raceId = testRaceId(luaState, 1);
+	if (raceId == (COUNT) -1) {
+		lua_pushboolean(luaState, FALSE);
+		return 1;
+	}
+
+	result = (CheckAlliance(raceId) != DEAD_GUY);
+	lua_pushboolean(luaState, result);
+	return 1;
+}
+
+// [1] -> string raceIdStr
+static int
+luaUqm_state_race_isAllied(lua_State *luaState) {
+	COUNT raceId;
+	BOOLEAN result;
+
+	raceId = testRaceId(luaState, 1);
+	if (raceId == (COUNT) -1) {
+		lua_pushboolean(luaState, FALSE);
+		return 1;
+	}
+
+	result = (CheckAlliance(raceId) == GOOD_GUY);
+	lua_pushboolean(luaState, result);
+	return 1;
+}
+
+// [1] -> string raceIdStr
+// Note that if a race has no SoI, this function will return false.
+static int
+luaUqm_state_race_isKnown(lua_State *luaState) {
+	COUNT raceId;
+	BOOLEAN result;
+
+	raceId = testRaceId(luaState, 1);
+	if (raceId == (COUNT) -1) {
+		lua_pushboolean(luaState, FALSE);
+		return 1;
+	}
+
+	result = CheckSphereTracking(raceId);
+	lua_pushboolean(luaState, result);
+	return 1;
+}
+
+// [1] -> string raceIdStr
+// [2] -> boolean flag
+static int
+luaUqm_state_race_setAlive(lua_State *luaState) {
+	COUNT raceId;
+	int flag;
+	BOOLEAN result;
+
+	raceId = testRaceId(luaState, 1);
+	if (raceId == (COUNT) -1) {
+		lua_pushboolean(luaState, FALSE);
+		return 1;
+	}
+
+	flag = lua_toboolean(luaState, 2);
+	if (flag != 0) {
+		log_add(log_Error, "[script] Warning: luaUqm_state_race_setAlive(): "
+				"setAlive(true) is not implemented.");
+		lua_pushboolean(luaState, FALSE);
+		return 1;
+	}
+
+	result = KillRace(raceId);
+	lua_pushboolean(luaState, result);
+	return 1;
+}
+
+// [1] -> string raceIdStr
+// [2] -> boolean flag
+static int
+luaUqm_state_race_setAllied(lua_State *luaState) {
+	COUNT raceId;
+	int flag;
+	BOOLEAN result;
+
+	raceId = testRaceId(luaState, 1);
+	if (raceId == (COUNT) -1) {
+		lua_pushboolean(luaState, FALSE);
+		return 1;
+	}
+
+	flag = lua_toboolean(luaState, 2);
+
+	result = SetRaceAllied(raceId, flag);
+	lua_pushboolean(luaState, result);
+	return 1;
+}
+
+// [1] -> string raceIdStr
+// [2] -> boolean flag
+static int
+luaUqm_state_race_setKnown(lua_State *luaState) {
+	COUNT raceId;
+	int flag;
+	BOOLEAN result;
+
+	raceId = testRaceId(luaState, 1);
+	if (raceId == (COUNT) -1) {
+		lua_pushboolean(luaState, FALSE);
+		return 1;
+	}
+
+	flag = lua_toboolean(luaState, 2);
+	if (flag == 0) {
+		log_add(log_Error, "[script] Warning: luaUqm_state_race_setKnown(): "
+				"setKnown(false) is not implemented.");
+		lua_pushboolean(luaState, FALSE);
+		return 1;
+	}
+
+	result = (StartSphereTracking(raceId) != 0);
+	lua_pushboolean(luaState, result);
+	return 1;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+
+// [1] -> int delta
+static int
+luaUqm_state_sis_addCrew(lua_State *luaState) {
+	int delta;
+	COUNT oldCrew;
+	COUNT newCrew;
+	
+	delta = luaL_checkint(luaState, 1);
+
+	oldCrew = GLOBAL_SIS(CrewEnlisted);
+	DeltaSISGauges(delta, 0, 0);
+	newCrew = GLOBAL_SIS(CrewEnlisted);
+
+	lua_pushinteger(luaState, newCrew - oldCrew);
+	return 1;
+}
+
+// [1] -> int delta
+static int
+luaUqm_state_sis_addFuel(lua_State *luaState) {
+	int delta;
+	COUNT oldFuel;
+	COUNT newFuel;
+	
+	delta = luaL_checkint(luaState, 1);
+
+	oldFuel = GLOBAL_SIS(FuelOnBoard);
+	DeltaSISGauges(0, delta, 0);
+	newFuel = GLOBAL_SIS(FuelOnBoard);
+
+	lua_pushinteger(luaState, newFuel - oldFuel);
+	return 1;
+}
+
+// [1] -> int delta
+static int
+luaUqm_state_sis_addLanders(lua_State *luaState) {
+	int delta;
+	int oldCount;
+	int newCount;
+	
+	delta = luaL_checkint(luaState, 1);
+
+	oldCount = GLOBAL_SIS(NumLanders);
+	newCount = oldCount + delta;
+	if (newCount < 0) {
+		newCount = 0;
+	} else if (newCount > MAX_LANDERS) {
+		newCount = MAX_LANDERS;
+	}
+
+	if (newCount != oldCount)
+	{
+		GLOBAL_SIS(NumLanders) = newCount;
+		DrawLanders();
+	}
+
+	lua_pushinteger(luaState, newCount - oldCount);
+	return 1;
+}
+
+// [1] -> int delta
+static int
+luaUqm_state_sis_addResUnits(lua_State *luaState) {
+	int delta;
+	COUNT oldResUnits;
+	COUNT newResUnits;
+	
+	delta = luaL_checkint(luaState, 1);
+
+	oldResUnits = GLOBAL_SIS(ResUnits);
+	DeltaSISGauges(0, delta, 0);
+	newResUnits = GLOBAL_SIS(ResUnits);
+
+	lua_pushinteger(luaState, newResUnits - oldResUnits);
+	return 1;
+}
+
+static int
+luaUqm_state_sis_getCaptainName(lua_State *luaState) {
+	lua_pushstring(luaState, GLOBAL_SIS (CommanderName));
+	return 1;
+}
+
+static int
+luaUqm_state_sis_getCrew(lua_State *luaState) {
+	lua_pushinteger(luaState, GLOBAL_SIS (CrewEnlisted));
+	return 1;
+}
+
+static int
+luaUqm_state_sis_getFuel(lua_State *luaState) {
+	lua_pushinteger(luaState, GLOBAL_SIS (FuelOnBoard));
+	return 1;
+}
+
+static int
+luaUqm_state_sis_getResUnits(lua_State *luaState) {
+	lua_pushinteger(luaState, GLOBAL_SIS (ResUnits));
+	return 1;
+}
+
+static int
+luaUqm_state_sis_getLanders(lua_State *luaState) {
+	lua_pushinteger(luaState, GLOBAL_SIS (NumLanders));
+	return 1;
+}
+
+static int
+luaUqm_state_sis_getShipName(lua_State *luaState) {
+	lua_pushstring(luaState, GLOBAL_SIS (ShipName));
+	return 1;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+
+// [1] -> int name
+static int
+luaUqm_state_prop_get(lua_State *luaState) {
+	luaL_checktype(luaState, 1, LUA_TSTRING);
+
+	luaUqm_getProp(luaState, 1);
+	return 1;
+}
+
+// [1] -> int name
+// [2] -> int|bool|string value
+static int
+luaUqm_state_prop_set(lua_State *luaState) {
+	luaL_checktype(luaState, 1, LUA_TSTRING);
+	luaUqm_checkPropValueType(luaState, "state.prop.set", 2);
+
+	luaUqm_setProp(luaState, 1, 2);
+	return 0;
+}
+
diff -ruNp src.hd/uqm/lua/luafuncs/statefuncs.h src/uqm/lua/luafuncs/statefuncs.h
--- src.hd/uqm/lua/luafuncs/statefuncs.h	1969-12-31 16:00:00 -0800
+++ src/uqm/lua/luafuncs/statefuncs.h	2017-12-29 00:57:46 -0800
@@ -0,0 +1,32 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _STATEUNCS_H
+#define _STATEUNCS_H
+
+#include "libs/scriptlib.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+int luaUqm_state_open(lua_State *luaState);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif  /* _STATEUNCS_H */
diff -ruNp src.hd/uqm/lua/luainit.c src/uqm/lua/luainit.c
--- src.hd/uqm/lua/luainit.c	1969-12-31 16:00:00 -0800
+++ src/uqm/lua/luainit.c	2017-12-29 00:57:46 -0800
@@ -0,0 +1,61 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * This file contains code for running scripts when a new game is started
+ * or an old game is loaded.
+ */
+
+#define LUAUQM_INTERNAL
+#include "port.h"
+#include "luacomm.h"
+
+#include "luainit.h"
+#include "options.h"
+		// for contentDir
+#include "uqm/resinst.h"
+#include "uqm/lua/luastate.h"
+#include "luafuncs/eventfuncs.h"
+#include "luafuncs/logfuncs.h"
+#include "luafuncs/statefuncs.h"
+#include "libs/log.h"
+
+static const luaL_Reg initLibs[] = {
+	{ "event",  luaUqm_event_open },
+	{ "log",    luaUqm_log_open },
+	{ "state",  luaUqm_state_open },
+	{ NULL, NULL }
+};
+
+void
+luaUqm_runInitScripts(void) {
+	const char *scriptDir;
+
+	// Set up an environment and run the init scripts in this environment.
+	// Note that the environment will not be used after this; when a script
+	// is run for eg. communication, a new environment will be set up.
+	luaUqm_prepareEnvironment(luaUqm_globalState);
+	luaUqm_loadLibs(luaUqm_globalState, initLibs);
+
+	scriptDir = res_GetString (SCRIPT_DIR_INITGAME);
+	if (scriptDir == NULL) {
+		log_add(log_Warning, "Location of game initialisation scripts ('%s')"
+				" was not specified.", SCRIPT_DIR_INITGAME);
+	} else {
+		luaUqm_runLuaDir(luaUqm_globalState, contentDir, scriptDir);
+	}
+}
+
diff -ruNp src.hd/uqm/lua/luainit.h src/uqm/lua/luainit.h
--- src.hd/uqm/lua/luainit.h	1969-12-31 16:00:00 -0800
+++ src/uqm/lua/luainit.h	2017-12-29 00:57:46 -0800
@@ -0,0 +1,33 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _LUAINIT_H
+#define _LUAINIT_H
+
+#include "libs/compiler.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+void luaUqm_runInitScripts(void);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif  /* _LUAINIT_H */
+
diff -ruNp src.hd/uqm/lua/luastate.c src/uqm/lua/luastate.c
--- src.hd/uqm/lua/luastate.c	1969-12-31 16:00:00 -0800
+++ src/uqm/lua/luastate.c	2017-12-29 00:57:46 -0800
@@ -0,0 +1,217 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * This file contains code for connecting storing the game state in Lua.
+ */
+
+#include "luastate.h"
+#include "luainit.h"
+#include "uqm/globdata.h"
+#include "libs/log.h"
+#include "libs/scriptlib.h"
+
+
+// We store the game state in the global Lua context, in the Lua registry.
+
+static void luaUqm_initStatePropertyTable(lua_State *luaState);
+static void luaUqm_initEventTable(lua_State *luaState);
+
+lua_State *luaUqm_globalState = NULL;
+static const char statePropRegistryKey[] =
+		"uqm_state_prop_registryKey";
+static const char eventRegistryKey[] =
+		"uqm_event_registryKey";
+
+
+// Init the global Lua state. Called at the start of the main loop.
+void
+luaUqm_initState(void) {
+	if (luaUqm_globalState != NULL) {
+		log_add(log_Warning, "Lua state multiply uninitialized");
+		luaUqm_uninitState ();
+	}
+	luaUqm_globalState = luaL_newstate();
+	luaUqm_initStatePropertyTable(luaUqm_globalState);
+	luaUqm_initEventTable(luaUqm_globalState);
+
+	// XXX TODO: set up an alternative to the Lua 'require' function,
+	// which makes use of uio.
+
+	luaUqm_runInitScripts();
+}
+
+// Uninit the global Lua state.
+void
+luaUqm_uninitState(void) {
+	if (luaUqm_globalState != NULL) {
+		lua_close(luaUqm_globalState);
+		luaUqm_globalState = NULL;
+	} else {
+		log_add(log_Warning, "Lua state multiply uninitialized");
+	}
+}
+
+// Reinit the global Lua state. This does nothing that initState doesn't
+// do, but unlike initState it warns only if you call it without having
+// old data to dispose of. Called at the start of a new game, or when a
+// game is loaded.
+
+void
+luaUqm_reinitState(void) {
+	if (luaUqm_globalState == NULL) {
+		log_add(log_Warning, "Lua state reinitialized while NULL");
+	} else {
+		luaUqm_uninitState ();
+	}
+	luaUqm_initState ();
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Game state
+/////////////////////////////////////////////////////////////////////////////
+
+static void
+luaUqm_initStatePropertyTable(lua_State *luaState)
+{
+	lua_pushstring(luaState, statePropRegistryKey);
+	lua_newtable(luaState);
+	lua_settable(luaState, LUA_REGISTRYINDEX);
+}
+
+// Check whether a lua value has a type acceptable as a property value.
+int
+luaUqm_checkPropValueType(lua_State *luaState, const char *funName,
+		int nameIndex) {
+	int type = lua_type(luaState, nameIndex);
+	switch (type) {
+		case LUA_TNUMBER:
+		case LUA_TBOOLEAN:
+		case LUA_TSTRING:
+			// Ok
+			return 0;
+		default: {
+			const char *typeName = lua_typename(luaState, nameIndex);
+			return luaL_error(luaState, "Property value has an invalid "
+					"type, in parameter to %s() (%s)", funName, typeName);
+		}
+	}
+}
+
+// Set the value of the property with the name on the stack on position
+// 'nameIndex' to the value on the stack with index 'valueIndex'.
+// Pre: nameIndex points to a string, and valueIndex points to a valid
+// value.
+void
+luaUqm_setProp(lua_State *luaState, int nameIndex, int valueIndex) {
+	nameIndex = lua_absindex(luaState, nameIndex);
+	valueIndex = lua_absindex(luaState, valueIndex);
+
+	lua_getfield(luaState, LUA_REGISTRYINDEX, statePropRegistryKey);
+	lua_pushvalue(luaState, nameIndex);
+	lua_pushvalue(luaState, valueIndex);
+	// [-3] -> registry[statePropRegistrykey]
+	// [-2] -> name
+	// [-1] -> value
+	lua_settable(luaState, -3);
+	// [-1] -> registry[statePropRegistrykey]
+	lua_pop(luaState, 1);
+}
+
+// Get the value of the property with the name on the stack on position
+// 'nameIndex'.
+// Pushes the property value on the stack.
+// Pre: nameIndex points to a string.
+void
+luaUqm_getProp(lua_State *luaState, int nameIndex) {
+	nameIndex = lua_absindex(luaState, nameIndex);
+
+	lua_getfield(luaState, LUA_REGISTRYINDEX, statePropRegistryKey);
+	// [-1] -> registry[statePropRegistrykey]
+	lua_pushvalue(luaState, nameIndex);
+	// [-2] -> registry[statePropRegistrykey]
+	// [-1] -> name
+	lua_gettable(luaState, -2);
+	// [-2] -> registry[statePropRegistrykey]
+	// [-1] -> registry[statePropRegistrykey][name]
+	lua_replace(luaState, -2);
+	// [-1] -> registry[statePropRegistrykey][name]
+}
+
+void
+setGameStateUint(const char *name, DWORD val)
+{
+	lua_pushstring(luaUqm_globalState, name);
+	lua_pushinteger(luaUqm_globalState, val);
+	luaUqm_setProp(luaUqm_globalState, -2, -1);
+	lua_pop(luaUqm_globalState, 2);
+
+#ifdef STATE_DEBUG
+	log_add(log_Debug, "State '%s' set to %u.", name, val);
+#endif
+}
+
+DWORD
+getGameStateUint(const char *name)
+{
+	DWORD result;
+	int resultType;
+
+	lua_pushstring(luaUqm_globalState, name);
+	luaUqm_getProp(luaUqm_globalState, -1);
+	// [-2] -> name
+	// [-1] -> propValue
+
+	resultType = lua_type(luaUqm_globalState, -1);
+	switch (resultType) {
+		case LUA_TNIL:
+			// Unitialised properties are 0.
+			lua_pop(luaUqm_globalState, 2);
+			return 0;
+		case LUA_TNUMBER:
+			// Ok.
+			break;
+		default:
+			log_add(log_Error, "Warning: getGameState(): property '%s' has "
+					"a non-number value (%s).", name,
+					lua_typename(luaUqm_globalState, -1));
+			lua_pop(luaUqm_globalState, 2);
+			return 0;
+	}
+
+	result = (DWORD) lua_tointeger(luaUqm_globalState, -1);
+	lua_pop(luaUqm_globalState, 2);
+	return result;
+}
+
+/////////////////////////////////////////////////////////////////////////////
+// Game events
+/////////////////////////////////////////////////////////////////////////////
+
+static void
+luaUqm_initEventTable(lua_State *luaState)
+{
+	lua_pushstring(luaState, eventRegistryKey);
+	lua_newtable(luaState);
+	lua_settable(luaState, LUA_REGISTRYINDEX);
+}
+
+void
+luaUqm_getEventTable(lua_State *luaState)
+{
+	lua_getfield(luaState, LUA_REGISTRYINDEX, eventRegistryKey);
+}
+
diff -ruNp src.hd/uqm/lua/luastate.h src/uqm/lua/luastate.h
--- src.hd/uqm/lua/luastate.h	1969-12-31 16:00:00 -0800
+++ src/uqm/lua/luastate.h	2017-12-29 00:57:46 -0800
@@ -0,0 +1,47 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _LUASTATE_H
+#define _LUASTATE_H
+
+#include "libs/compiler.h"
+#include "libs/scriptlib.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+extern lua_State *luaUqm_globalState;
+
+void luaUqm_initState(void);
+void luaUqm_uninitState(void);
+void luaUqm_reinitState(void);
+void luaUqm_getProp(lua_State *luaState, int nameIndex);
+void luaUqm_setProp(lua_State *luaState, int nameIndex, int valueIndex);
+int luaUqm_checkPropValueType (lua_State *luaState, const char *funName,
+		int nameIndex);
+
+void setGameStateUint (const char *name, DWORD val);
+DWORD getGameStateUint (const char *name);
+
+void luaUqm_getEventTable (lua_State *luaState);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif  /* _LUASTATE_H */
+
diff -ruNp src.hd/uqm/master.h src/uqm/master.h
--- src.hd/uqm/master.h	2017-12-29 02:25:52 -0800
+++ src/uqm/master.h	2017-12-29 00:57:47 -0800
@@ -20,6 +20,10 @@
 #include "races.h"
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef HLINK HMASTERSHIP;
 
 typedef struct
@@ -58,5 +62,9 @@ COUNT GetShipCostFromIndex (unsigned Ind
 FRAME GetShipIconsFromIndex (unsigned Index);
 FRAME GetShipMeleeIconsFromIndex (unsigned Index);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _MASTER_H */
 
diff -ruNp src.hd/uqm/menu.c src/uqm/menu.c
--- src.hd/uqm/menu.c	2017-12-29 02:25:52 -0800
+++ src/uqm/menu.c	2017-12-29 00:57:47 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "menustat.h"
 
 #include "colors.h"
@@ -30,9 +28,6 @@
 #include "libs/tasklib.h"
 #include "libs/log.h"
 
-extern Task flash_task;
-extern RECT flash_rect;
-
 static BYTE GetEndMenuState (BYTE BaseState);
 static BYTE GetBeginMenuState (BYTE BaseState);
 static BYTE FixMenuState (BYTE BadState);
@@ -120,7 +115,7 @@ DrawPCMenu (BYTE beg_index, BYTE end_ind
 			
 			// Draw the background of the selection.
 			SetContextForeGroundColor (PCMENU_SELECTION_BACKGROUND_COLOR);
-			r->corner.y = t.baseline.y - PC_MENU_HEIGHT + RES_STAT_SCALE(2);// + RESOLUTION_FACTOR; // JMS_GFX
+			r->corner.y = t.baseline.y - PC_MENU_HEIGHT + RES_STAT_SCALE(2); // + RESOLUTION_FACTOR; // JMS_GFX
 			r->extent.height = PC_MENU_HEIGHT - 1;
 			DrawFilledRectangle (r);
 
@@ -502,7 +497,7 @@ DrawMenuStateStrings (BYTE beg_index, SW
 	if (NewState <= end_index - beg_index)
 		s.frame = SetAbsFrameIndex (PlayFrame, beg_index + NewState);
 
-	LockMutex (GraphicsLock);
+	PreUpdateFlashRect ();
 	OldContext = SetContext (StatusContext);
 	GetContextClipRect (&r);
 	s.origin.x = RADAR_X - r.corner.x;
@@ -554,15 +549,14 @@ DrawMenuStateStrings (BYTE beg_index, SW
 			}
 		}
 		r.extent.height = RADAR_HEIGHT + (11 << RESOLUTION_FACTOR); // JMS_GFX
-		
+
 		// JMS_GFX: This is to fix the two-line high outfit module texts.
 		// They weren't completely erased in 640x480 when exiting module selection.
-		if (RESOLUTION_FACTOR == 1)
-		{
+		if (RESOLUTION_FACTOR == 1) {
 			r.corner.y -= 7;
 			r.extent.height += 7;
 		}
-		
+
 		DrawPCMenu (beg_index, end_index, (BYTE)NewState, hilite, &r);
 		s.frame = 0;
 	}
@@ -576,7 +570,6 @@ DrawMenuStateStrings (BYTE beg_index, SW
 		}
 		else
 			r.extent.height = 11 << RESOLUTION_FACTOR;
-			
 		DrawFilledRectangle (&r);
 	}
 	if (s.frame)
@@ -612,13 +605,35 @@ DrawMenuStateStrings (BYTE beg_index, SW
 		}
 	}
 	UnbatchGraphics ();
-	if (flash_task
-			&& flash_rect.corner.x == RADAR_X
-			&& flash_rect.corner.y == RADAR_Y
-			&& flash_rect.extent.width == RADAR_WIDTH
-			&& flash_rect.extent.height == RADAR_HEIGHT)
-		SetFlashRect (SFR_MENU_3DO);
 	SetContext (OldContext);
-	UnlockMutex (GraphicsLock);
+	PostUpdateFlashRect ();
+}
+
+void
+DrawSubmenu (BYTE Visible)
+{
+	STAMP s;
+	CONTEXT OldContext;
+	
+	OldContext = SetContext (ScreenContext);
+
+	s.origin.x = 0;
+	s.origin.y = 0;
+
+	switch (Visible){
+		case 1: 
+			s.frame = SetAbsFrameIndex (SubmenuFrame, 1);
+			break;
+		case 2:
+			s.frame = SetAbsFrameIndex (SubmenuFrame, 2);
+			break;
+		case 0:
+		default:
+			s.frame = SetAbsFrameIndex (SubmenuFrame, 0);
+	}
+
+	DrawStamp (&s);
+	
+	SetContext (OldContext);
 }
 
diff -ruNp src.hd/uqm/menustat.h src/uqm/menustat.h
--- src.hd/uqm/menustat.h	2017-12-29 02:25:52 -0800
+++ src/uqm/menustat.h	2017-12-29 00:57:47 -0800
@@ -23,6 +23,10 @@
 #include "libs/sndlib.h"
 #include "flash.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef struct menu_state
 {
 	// Standard field required by DoInput()
@@ -119,6 +123,11 @@ enum
 
 extern BOOLEAN DoMenuChooser (MENU_STATE *pMS, BYTE BaseState);
 extern void DrawMenuStateStrings (BYTE beg_index, SWORD NewState);
+extern void DrawSubmenu (BYTE Visible);
+
+#if defined(__cplusplus)
+}
+#endif
 
 #endif /* _MENUSTAT_H */
 
diff -ruNp src.hd/uqm/misc.c src/uqm/misc.c
--- src.hd/uqm/misc.c	2017-12-29 02:25:52 -0800
+++ src/uqm/misc.c	2017-12-29 00:57:48 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "element.h"
 #include "init.h"
 #include "races.h"
@@ -27,8 +25,6 @@
 #include "sounds.h"
 #include "weapon.h"
 #include "libs/mathlib.h"
-
-#include "uqmdebug.h" // JMS: For debug invincibility
 #include "options.h" // For God Mode invincibility
 #include "settings.h"
 #include "intel.h"
@@ -98,7 +94,7 @@ spawn_rubble (ELEMENT *AsteroidElementPt
 			RubbleElementPtr->current.image.frame = SetAbsFrameIndex (asteroid[0], ANGLE_TO_FACING (FULL_CIRCLE));
 		else
 			RubbleElementPtr->current.image.frame = SetAbsFrameIndex (asteroid[0], 29);
-		
+
 		RubbleElementPtr->current.location = AsteroidElementPtr->current.location;
 		RubbleElementPtr->preprocess_func = animation_preprocess;
 		RubbleElementPtr->death_func = spawn_asteroid;
@@ -126,8 +122,9 @@ asteroid_preprocess (ELEMENT *ElementPtr
 			ElementPtr->next.image.frame = SetAbsFrameIndex (ElementPtr->current.image.frame, NORMALIZE_FACING (frame_index));
 		else
 			ElementPtr->next.image.frame = SetAbsFrameIndex (ElementPtr->current.image.frame, frame_index % 30);
-		
+
 		ElementPtr->state_flags |= CHANGING;
+
 		ElementPtr->turn_wait = (unsigned char)(ElementPtr->thrust_wait & ((1 << 7) - 1));
 	}
 }
@@ -208,14 +205,13 @@ spawn_asteroid (ELEMENT *ElementPtr)
 void
 do_damage (ELEMENT *ElementPtr, SIZE damage)
 {
-	// God Mode, borrowed from the debug invincibility code	
+	// God Mode, borrowed from the UQM-HD debug invincibility code
 	if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
 		(((PlayerControl[0] & COMPUTER_CONTROL) && ElementPtr->playerNr == 1) || 
 		((PlayerControl[1] & COMPUTER_CONTROL) && ElementPtr->playerNr == 0))))
 	{
-			damage = 0;
+		damage = 0;
 	}
-
 	if (ElementPtr->state_flags & PLAYER_SHIP)
 	{
 		if (!DeltaCrew (ElementPtr, -damage))
@@ -364,11 +360,19 @@ AbandonShip (ELEMENT *ShipPtr, ELEMENT *
 		CrewPtr->hit_points = 1;
 		CrewPtr->state_flags = APPEARING | FINITE_LIFE | CREW_OBJECT;
 		CrewPtr->life_span = CREW_LIFE;
-		SetPrimType (&DisplayArray[CrewPtr->PrimIndex], POINT_PRIM_HD);
+		if (RESOLUTION_FACTOR == 0) {
+			SetPrimType (&DisplayArray[CrewPtr->PrimIndex], POINT_PRIM);
+			CrewPtr->current.image.frame = DecFrameIndex (stars_in_space);
+			CrewPtr->current.image.farray = &stars_in_space;
+		} else {
+			SetPrimType (&DisplayArray[CrewPtr->PrimIndex], STAMPFILL_PRIM);
+			CrewPtr->current.image.frame = SetAbsFrameIndex (crew_dots[0], 0);
+			CrewPtr->current.image.farray = crew_dots;
+		}
 		SetPrimColor (&DisplayArray[CrewPtr->PrimIndex],
 				BUILD_COLOR (MAKE_RGB15 (0x00, 0x14, 0x00), 0x02));
-		CrewPtr->current.image.frame = DecFrameIndex (stars_in_space);
-		CrewPtr->current.image.farray = &stars_in_space;
+		/*CrewPtr->current.image.frame = DecFrameIndex (stars_in_space);
+		CrewPtr->current.image.farray = &stars_in_space;*/
 		CrewPtr->preprocess_func = crew_preprocess;
 		CrewPtr->collision_func = crew_collision;
 
diff -ruNp src.hd/uqm/oscill.c src/uqm/oscill.c
--- src.hd/uqm/oscill.c	2017-12-29 02:25:52 -0800
+++ src/uqm/oscill.c	2017-12-29 00:57:48 -0800
@@ -26,7 +26,6 @@
 #include "libs/sound/trackplayer.h"
 #include "libs/log.h"
 
-
 static FRAME scope_frame;
 static int scope_init = 0;
 static FRAME scopeWork;
@@ -87,7 +86,8 @@ DrawOscilloscope (void)
 	// less than 256. This "fix" messes up how the oscilloscope looks, but it works for now
 	// (doesn't get caught in asserts). We need to fix this later.
 
-	if (GraphForegroundStream (scope_data, scopeSize.width, scopeSize.height))
+	if (GraphForegroundStream (scope_data, scopeSize.width, scopeSize.height,
+			usingSpeech))
 	{
 		int i;
 		CONTEXT oldContext;
diff -ruNp src.hd/uqm/oscill.h src/uqm/oscill.h
--- src.hd/uqm/oscill.h	2017-12-29 02:25:52 -0800
+++ src/uqm/oscill.h	2017-12-29 00:57:48 -0800
@@ -20,6 +20,10 @@
 #include "libs/compiler.h"
 #include "libs/gfxlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern BOOLEAN sliderDisabled;
 extern BOOLEAN oscillDisabled;
 
@@ -32,5 +36,9 @@ extern void InitSlider (int x, int y, in
 extern void SetSliderImage (FRAME f);
 void DrawSlider (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _OSCILL_H */
 
diff -ruNp src.hd/uqm/outfit.c src/uqm/outfit.c
--- src.hd/uqm/outfit.c	2017-12-29 02:25:52 -0800
+++ src/uqm/outfit.c	2017-12-29 00:57:48 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "options.h"
 #include "colors.h"
 #include "controls.h"
@@ -90,16 +88,14 @@ DrawModuleStrings (MENU_STATE *pMS, BYTE
 		t.align = ALIGN_RIGHT;
 		t.CharCount = (COUNT)~0;
 		t.pStr = buf;
-		sprintf (buf, "%u", GLOBAL (ModuleCost[NewModule]) * MODULE_COST_SCALE);
+		sprintf (buf, "%u",
+				GLOBAL (ModuleCost[NewModule]) * MODULE_COST_SCALE);
 
-		if ((GLOBAL_SIS (ResUnits)) > (DWORD)((GLOBAL (ModuleCost[NewModule]) * MODULE_COST_SCALE)))
-		{
+		if ((GLOBAL_SIS (ResUnits)) > (DWORD)((GLOBAL (ModuleCost[NewModule]) * MODULE_COST_SCALE))) {
 			sprintf (buf, "%u", GLOBAL (ModuleCost[NewModule]) * MODULE_COST_SCALE);
 			SetContextForeGroundColor (
 					BUILD_COLOR (MAKE_RGB15 (0x00, 0x1F, 0x00), 0x02));
-		}
-		else /* We don't have enough RUs to purchase this module, draw the price in red */
-		{
+		} else {
 			sprintf (buf, "(%u)", GLOBAL (ModuleCost[NewModule]) * MODULE_COST_SCALE);
 			SetContextForeGroundColor (
 					BUILD_COLOR (MAKE_RGB15 (0x1F, 0x00, 0x00), 0x02));
@@ -115,42 +111,38 @@ DrawModuleStrings (MENU_STATE *pMS, BYTE
 static void
 RedistributeFuel (void)
 {
-	COUNT m;
-	DWORD FuelVolume;
+	const DWORD FuelVolume = GLOBAL_SIS (FuelOnBoard);
+	const CONTEXT OldContext = SetContext (SpaceContext);
 	RECT r;
-
-	FuelVolume = GLOBAL_SIS (FuelOnBoard);
-	if (FuelVolume <= FUEL_RESERVE)
-		return;
-
-	GLOBAL_SIS (FuelOnBoard) = 0;
-	m = FUEL_VOLUME_PER_ROW;
-
-	r.extent.width = (3 << RESOLUTION_FACTOR) + RES_CASE(0,2,6); // JMS_GFX
 	r.extent.height = 1;
-	while (FuelVolume -= m)
-	{
-		GLOBAL_SIS (FuelOnBoard) += FUEL_VOLUME_PER_ROW;
-		GetFTankCapacity (&r.corner);
-		DrawPoint (&r.corner);
-		r.corner.x += r.extent.width + 1;
-		DrawPoint (&r.corner);
-		r.corner.x -= r.extent.width;
-		SetContextForeGroundColor (SetContextBackGroundColor (BLACK_COLOR));
-		DrawFilledRectangle (&r);
-		if (FuelVolume < FUEL_VOLUME_PER_ROW)
-			m = (COUNT)FuelVolume;
-	}
-
-	FuelVolume = GLOBAL_SIS (FuelOnBoard) + m;
 
-	r.extent.width = 5 << RESOLUTION_FACTOR; // JMS_GFX
-	while ((GLOBAL_SIS (FuelOnBoard) += FUEL_VOLUME_PER_ROW) < GetFTankCapacity (&r.corner))
-	{
-		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x0B, 0x00, 0x00), 0x2E));
+	// Loop through all the rows to draw
+	BatchGraphics ();
+	for (GLOBAL_SIS (FuelOnBoard) = FUEL_RESERVE;
+			GLOBAL_SIS (FuelOnBoard) < GetFTankCapacity (&r.corner);
+			GLOBAL_SIS (FuelOnBoard) += FUEL_VOLUME_PER_ROW)
+	{
+		// If we're less than the fuel level, draw fuel.
+		if (GLOBAL_SIS (FuelOnBoard) < FuelVolume)
+		{
+			r.extent.width = (3 << RESOLUTION_FACTOR) + RES_CASE(0,2,6); // JMS_GFX
+			DrawPoint (&r.corner);
+			r.corner.x += r.extent.width + 1;
+			DrawPoint (&r.corner);
+			r.corner.x -= r.extent.width;
+			SetContextForeGroundColor (
+					SetContextBackGroundColor (BLACK_COLOR));
+		}
+		else // Otherwise, draw an empty bar.
+		{
+			r.extent.width = 5 << RESOLUTION_FACTOR; // JMS_GFX
+			SetContextForeGroundColor (
+					BUILD_COLOR (MAKE_RGB15 (0x0B, 0x00, 0x00), 0x2E));
+		}
 		DrawFilledRectangle (&r);
 	}
+	UnbatchGraphics ();
+	SetContext (OldContext);
 
 	GLOBAL_SIS (FuelOnBoard) = FuelVolume;
 }
@@ -168,7 +160,6 @@ DisplayLanders (MENU_STATE *pMS)
 	if (GET_GAME_STATE (CHMMR_BOMB_STATE) == 3)
 	{
 		s.origin.x = s.origin.y = 0;
-		//s.frame = DecFrameIndex (s.frame);
 		s.frame = SetAbsFrameIndex (pMS->ModuleFrame,
 			GetFrameCount (pMS->ModuleFrame) - SHIELD_LOCATION_IN_MODULE_ANI + 4);
 		DrawStamp (&s);
@@ -256,7 +247,6 @@ DoInstallModule (MENU_STATE *pMS)
 
 		pMS->InputFunc = DoInstallModule;
 
-		LockMutex (GraphicsLock);
 
 		SetContext (SpaceContext);
 		ClearSISRect (CLEAR_SIS_RADAR);
@@ -266,13 +256,13 @@ DoInstallModule (MENU_STATE *pMS)
 	else if (select || cancel)
 	{
 		new_slot_piece = pMS->CurState;
+
 		if (select)
 		{
 			if (new_slot_piece < EMPTY_SLOT)
 			{
-				if (GLOBAL_SIS (ResUnits) <
-						(DWORD)(GLOBAL (ModuleCost[new_slot_piece])
-						* MODULE_COST_SCALE))
+
+				if (GLOBAL_SIS (ResUnits) < (DWORD)(GLOBAL (ModuleCost[new_slot_piece]) * MODULE_COST_SCALE))
 				{	// not enough RUs to build
 					PlayMenuSound (MENU_SOUND_FAILURE);
 					return (TRUE);
@@ -302,8 +292,15 @@ DoInstallModule (MENU_STATE *pMS)
 							? FUEL_TANK_CAPACITY : HEFUEL_TANK_CAPACITY);
 					if (GLOBAL_SIS (FuelOnBoard) > volume + FUEL_RESERVE)
 					{	// fuel tank still needed for the fuel on board
-						PlayMenuSound (MENU_SOUND_FAILURE);
-						return (TRUE);
+						if(!optInfiniteFuel){
+							PlayMenuSound (MENU_SOUND_FAILURE);
+							return (TRUE);
+						} else {
+							if (old_slot_piece == FUEL_TANK)
+								DeltaSISGauges(0,-FUEL_TANK_CAPACITY,0);
+							else
+								DeltaSISGauges(0,-HEFUEL_TANK_CAPACITY,0);
+						}
 					}
 				}
 				else if (old_slot_piece == STORAGE_BAY)
@@ -318,7 +315,6 @@ DoInstallModule (MENU_STATE *pMS)
 			}
 		}
 
-		LockMutex (GraphicsLock);
 		SetContext (SpaceContext);
 
 		SetFlashRect (NULL);
@@ -366,7 +362,8 @@ DoInstallModule (MENU_STATE *pMS)
 							GLOBAL (ModuleCost[old_slot_piece])
 							* MODULE_COST_SCALE);
 
-				if (pMS->CurState == PLANET_LANDER || pMS->CurState == EMPTY_SLOT + 3)
+				if (pMS->CurState == PLANET_LANDER ||
+						pMS->CurState == EMPTY_SLOT + 3)
 					DisplayLanders (pMS);
 				else
 				{
@@ -403,15 +400,12 @@ DoInstallModule (MENU_STATE *pMS)
 		else
 		{
 			SetContext (StatusContext);
-			UnlockMutex (GraphicsLock);
 			DrawMenuStateStrings (PM_FUEL, pMS->CurState = OUTFIT_MODULES);
-			LockMutex (GraphicsLock);
 			SetFlashRect (SFR_MENU_3DO);
 
 			pMS->InputFunc = DoOutfit;
 			ClearSISRect (DRAW_SIS_DISPLAY);
 		}
-		UnlockMutex (GraphicsLock);
 	}
 	else if (motion)
 	{
@@ -420,7 +414,8 @@ DoInstallModule (MENU_STATE *pMS)
 		NewItem = NewState < EMPTY_SLOT ? pMS->CurState : pMS->delta_item;
 		do
 		{
-			if (NewState >= EMPTY_SLOT && (PulsedInputState.menu[KEY_MENU_UP] || PulsedInputState.menu[KEY_MENU_DOWN]))
+			if (NewState >= EMPTY_SLOT && (PulsedInputState.menu[KEY_MENU_UP]
+					|| PulsedInputState.menu[KEY_MENU_DOWN]))
 			{
 				if (PulsedInputState.menu[KEY_MENU_UP])
 				{
@@ -460,15 +455,14 @@ DoInstallModule (MENU_STATE *pMS)
 				|| (NewItem >= GUN_WEAPON && NewItem <= CANNON_WEAPON
 				&& pMS->delta_item > 0 && pMS->delta_item < 13)));
 
-		LockMutex (GraphicsLock);
 		if (NewState < EMPTY_SLOT)
 		{
 			if (NewItem != pMS->CurState)
 			{
 				pMS->CurState = NewItem;
+				PreUpdateFlashRect ();
 				DrawModuleStrings (pMS, NewItem);
-				// flash with PC menus too
-				SetFlashRect (SFR_MENU_ANY);
+				PostUpdateFlashRect ();
 			}
 		}
 		else if (NewItem != pMS->delta_item || NewState != pMS->CurState)
@@ -503,7 +497,7 @@ DoInstallModule (MENU_STATE *pMS)
 					w = LANDER_WIDTH;
 				else
 					w = SHIP_PIECE_OFFSET;
-				
+
 				// JMS_GFX
 				if (NewState != PLANET_LANDER && NewState != FUSION_THRUSTER 
 					&& NewState != TURNING_JETS && NewState != EMPTY_SLOT + 0
@@ -544,7 +538,7 @@ InitFlash:
 						pMS->flash_rect0.corner.y = JET_TOP_Y - 1 + RES_CASE(0,90,185);
 						pMS->flash_rect0.extent.width = 9 << RESOLUTION_FACTOR; // JMS_GFX;
 						pMS->flash_rect0.extent.height = (10 << RESOLUTION_FACTOR) + RES_CASE(0,0,4); // JMS_GFX;
-						
+
 						break;
 					default:
 						pMS->flash_rect0.corner.x = MODULE_TOP_X - 1 + RES_CASE(0,0,2);
@@ -552,7 +546,6 @@ InitFlash:
 						pMS->flash_rect0.extent.width = SHIP_PIECE_OFFSET + 2 - RES_CASE(0,1,1);
 						pMS->flash_rect0.extent.height = (34 << RESOLUTION_FACTOR) + RES_CASE(0,0,9); // JMS_GFX;
 						w += RES_CASE(0,1,1);
-						
 						break;
 				}
 
@@ -567,8 +560,10 @@ InitFlash:
 			else
 				SetFlashRect (&pMS->flash_rect0);
 		}
-		UnlockMutex (GraphicsLock);
-	}
+	}	
+
+	if(optInfiniteFuel)
+		DeltaSISGauges(0,GetFuelTankCapacity(),0);
 
 	return (TRUE);
 }
@@ -576,73 +571,55 @@ InitFlash:
 static void
 ChangeFuelQuantity (void)
 {
-	RECT r;
-	
-	r.extent.height = 1;
+	int incr = 0; // Fuel increment in fuel points (not units).
 	
-	if (PulsedInputState.menu[KEY_MENU_UP])
+	if      (PulsedInputState.menu[KEY_MENU_UP])
+		incr = FUEL_TANK_SCALE;  // +1 Unit
+	else if (PulsedInputState.menu[KEY_MENU_DOWN])
+		incr = -FUEL_TANK_SCALE; // -1 Unit
+	else if (PulsedInputState.menu[KEY_MENU_PAGE_UP])
+		incr = FUEL_VOLUME_PER_ROW;  // +1 Bar
+	else if (PulsedInputState.menu[KEY_MENU_PAGE_DOWN])
+		incr = -FUEL_VOLUME_PER_ROW; // -1 Bar
+	else
+		return;
+
+	// Clamp incr to what we can afford/hold/have.
 	{
-		LockMutex (GraphicsLock);
-		SetContext (SpaceContext);
-		if (GetFTankCapacity (&r.corner) > GLOBAL_SIS (FuelOnBoard)
-			&& GLOBAL_SIS (ResUnits) >= (DWORD)GLOBAL (FuelCost))
-		{
-			if (GLOBAL_SIS (FuelOnBoard) >= FUEL_RESERVE)
-			{
-				r.extent.width = (3 << RESOLUTION_FACTOR) + RES_CASE(0,2,6); // JMS_GFX
-				DrawPoint (&r.corner);
-				r.corner.x += r.extent.width + 1;
-				DrawPoint (&r.corner);
-				r.corner.x -= r.extent.width;
-				SetContextForeGroundColor (
-						SetContextBackGroundColor (BLACK_COLOR));
-				DrawFilledRectangle (&r);
-			}
-			DeltaSISGauges (0, FUEL_TANK_SCALE, -GLOBAL (FuelCost));
-			SetContext (StatusContext);
-			GetGaugeRect (&r, FALSE);
-			SetFlashRect (&r);
-		}
-		else
-		{	// no more room for fuel or not enough RUs
-			PlayMenuSound (MENU_SOUND_FAILURE);
-		}
-		UnlockMutex (GraphicsLock);
+		const int maxFit = GetFuelTankCapacity () - GLOBAL_SIS (FuelOnBoard);
+		const int maxAfford = GLOBAL_SIS (ResUnits) / GLOBAL (FuelCost);
+		const int minFit = - (int) GLOBAL_SIS (FuelOnBoard);
+
+		if (incr > maxFit)
+			incr = maxFit; // All we can hold.
+
+		if (incr > maxAfford * FUEL_TANK_SCALE)
+			incr = maxAfford * FUEL_TANK_SCALE; // All we can afford.
+
+		if (incr < minFit)
+			incr = minFit; // All we have.
 	}
-	else if (PulsedInputState.menu[KEY_MENU_DOWN])
+
+	if (!incr)
 	{
-		LockMutex (GraphicsLock);
-		SetContext (SpaceContext);
-		if (GLOBAL_SIS (FuelOnBoard))
-		{
-			DeltaSISGauges (0, -FUEL_TANK_SCALE, GLOBAL (FuelCost));
-			
-			if ((((GLOBAL_SIS (FuelOnBoard) % FUEL_VOLUME_PER_ROW == 0) && RESOLUTION_FACTOR == 0)
-				  || (RESOLUTION_FACTOR > 0)) 
-					&&
-					GLOBAL_SIS (FuelOnBoard) >= FUEL_RESERVE)
-			{
-				GetFTankCapacity (&r.corner);
-				SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x0B, 0x00, 0x00), 0x2E));
-				r.extent.width = (5 << RESOLUTION_FACTOR);// JMS_GFX
-				DrawFilledRectangle (&r);
-				
-				// JMS_GFX: Crude fix to remove intermittent residual fuel lines left hanging mid-tank.
-				if (RESOLUTION_FACTOR == 2)
-				{
-					r.corner.y -= 1;
-					DrawFilledRectangle (&r);
-				}
-			}
-		}
-		else
-		{	// no fuel left to drain
-			PlayMenuSound (MENU_SOUND_FAILURE);
-		}
-		SetContext (StatusContext);
+		// No more room, not enough RUs, or no fuel left to drain.
+		PlayMenuSound (MENU_SOUND_FAILURE);
+	}
+	else
+	{
+		const int cost = (incr / FUEL_TANK_SCALE) * GLOBAL (FuelCost);
+		PreUpdateFlashRect ();
+		DeltaSISGauges (0, incr, -cost);
+		PostUpdateFlashRect ();
+		RedistributeFuel ();
+	}
+
+	{   // Make fuel gauge flash.
+		RECT r;
+		CONTEXT oldContext = SetContext (StatusContext);
 		GetGaugeRect (&r, FALSE);
 		SetFlashRect (&r);
-		UnlockMutex (GraphicsLock);
+		SetContext (oldContext);
 	}
 }
 
@@ -650,10 +627,8 @@ static void
 onNamingDone (void)
 {
 	// In case player just named a ship, redraw it
-	LockMutex (GraphicsLock);
 	DrawFlagshipName (FALSE);
-	UnlockMutex (GraphicsLock);
-} 
+}
 
 BOOLEAN
 DoOutfit (MENU_STATE *pMS)
@@ -682,7 +657,6 @@ DoOutfit (MENU_STATE *pMS)
 			s.frame = CaptureDrawable (
 					LoadGraphic (OUTFIT_PMAP_ANIM));
 
-			LockMutex (GraphicsLock);
 			SetTransitionSource (NULL);
 			BatchGraphics ();
 			DrawSISFrame ();
@@ -744,21 +718,16 @@ DoOutfit (MENU_STATE *pMS)
 					DrawStamp (&s);
 			}
 
-			UnlockMutex (GraphicsLock);
 			DrawMenuStateStrings (PM_FUEL, pMS->CurState);
-			LockMutex (GraphicsLock);
 			DrawFlagshipName (FALSE);
 			if (optWhichFonts == OPT_PC)
 				DrawFlagshipStats ();
-			UnlockMutex (GraphicsLock);
 
 			ScreenTransition (3, NULL);
 			PlayMusic (pMS->hMusic, TRUE, 1);
 			UnbatchGraphics ();
 			
-			LockMutex (GraphicsLock);
 			SetFlashRect (SFR_MENU_3DO);
-			UnlockMutex (GraphicsLock);
 
 			GLOBAL_SIS (FuelOnBoard) =
 					(GLOBAL_SIS (FuelOnBoard)
@@ -775,9 +744,7 @@ DoOutfit (MENU_STATE *pMS)
 		if (pMS->CurState == OUTFIT_DOFUEL)
 		{
 			pMS->CurState = OUTFIT_FUEL;
-			LockMutex (GraphicsLock);
 			SetFlashRect (SFR_MENU_3DO);
-			UnlockMutex (GraphicsLock);
 		}
 		else
 		{
@@ -801,18 +768,14 @@ ExitOutfit:
 				RECT r;
 
 				pMS->CurState = OUTFIT_DOFUEL;
-				LockMutex (GraphicsLock);
 				SetContext (StatusContext);
 				GetGaugeRect (&r, FALSE);
 				SetFlashRect (&r);
-				UnlockMutex (GraphicsLock);
 				break;
 			}
 			case OUTFIT_DOFUEL:
 				pMS->CurState = OUTFIT_FUEL;
-				LockMutex (GraphicsLock);
 				SetFlashRect (SFR_MENU_3DO);
-				UnlockMutex (GraphicsLock);
 				break;
 			case OUTFIT_MODULES:
 				pMS->CurState = EMPTY_SLOT + 2;
@@ -829,9 +792,7 @@ ExitOutfit:
 				if (!GameOptions ())
 					goto ExitOutfit;
 				DrawMenuStateStrings (PM_FUEL, pMS->CurState);
-				LockMutex (GraphicsLock);
 				SetFlashRect (SFR_MENU_3DO);
-				UnlockMutex (GraphicsLock);
 				break;
 		}
 	}
@@ -840,7 +801,9 @@ ExitOutfit:
 		switch (pMS->CurState)
 		{
 			case OUTFIT_DOFUEL:
-				SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
+				SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN |
+						MENU_SOUND_PAGEUP | MENU_SOUND_PAGEDOWN,
+						MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
 				break;
 			default:
 				SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
@@ -849,7 +812,9 @@ ExitOutfit:
 
 		if (pMS->CurState == OUTFIT_DOFUEL)
 		{
-			ChangeFuelQuantity ();
+			if(!optInfiniteFuel)
+				ChangeFuelQuantity ();
+
 			SleepThread (ONE_SECOND / 30);
 		}
 		else
diff -ruNp src.hd/uqm/pickship.c src/uqm/pickship.c
--- src.hd/uqm/pickship.c	2017-12-29 02:25:52 -0800
+++ src/uqm/pickship.c	2017-12-29 00:57:48 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "pickship.h"
 
 #include "build.h"
@@ -35,7 +33,6 @@
 #include "sounds.h"
 #include "libs/mathlib.h"
 
-
 #define NUM_PICK_SHIP_ROWS 2
 #define NUM_PICK_SHIP_COLUMNS 6
 
@@ -63,7 +60,6 @@ DoPickBattleShip (MENU_STATE *pMS)
 		pMS->Initialized = TRUE;
 		pMS->InputFunc = DoPickBattleShip;
 
-		LockMutex (GraphicsLock);
 
 		goto ChangeSelection;
 	}
@@ -108,7 +104,6 @@ DoPickBattleShip (MENU_STATE *pMS)
 
 			PlayMenuSound (MENU_SOUND_MOVE);
 
-			LockMutex (GraphicsLock);
 
 #ifdef NEVER
 			SetContextForeGroundColor (
@@ -122,9 +117,9 @@ ChangeSelection:
 			if (pMS->first_item.x == (NUM_PICK_SHIP_COLUMNS >> 1))
 			{
 				pMS->flash_rect0.corner.x =
-					pMS->flash_rect1.corner.x - 2 + FLAGSHIP_X_OFFS;
+						pMS->flash_rect1.corner.x - 2 + FLAGSHIP_X_OFFS;
 				pMS->flash_rect0.corner.y =
-					pMS->flash_rect1.corner.y - 2 + FLAGSHIP_Y_OFFS;
+						pMS->flash_rect1.corner.y - 2 + FLAGSHIP_Y_OFFS;
 				pMS->flash_rect0.extent.width = FLAGSHIP_WIDTH + 4;
 				pMS->flash_rect0.extent.height = FLAGSHIP_HEIGHT + 4;
 
@@ -134,7 +129,7 @@ ChangeSelection:
 			{
 				new_col = pMS->first_item.x;
 				pMS->flash_rect0.corner.x = (5 << RESOLUTION_FACTOR) + pMS->flash_rect1.corner.x - 2
-					+ ((ICON_WIDTH + (4 << RESOLUTION_FACTOR)) * new_col); // JMS_GFX
+						+ ((ICON_WIDTH + (4 << RESOLUTION_FACTOR)) * new_col); // JMS_GFX
 				if (new_col > (NUM_PICK_SHIP_COLUMNS >> 1))
 				{
 					--new_col;
@@ -243,7 +238,6 @@ ChangeSelection:
 
 			SetFlashRect (NULL);
 			SetFlashRect (&pMS->flash_rect0);
-			UnlockMutex (GraphicsLock);
 		}
 	}
 
@@ -281,10 +275,8 @@ OldContext = SetContext (SpaceContext);
 		MenuState.flash_rect1.corner = pick_r.corner;
 		MenuState.flash_rect1.extent.width = 0;
 
-		UnlockMutex (GraphicsLock);
 		SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
 		DoInput (&MenuState, FALSE);
-		LockMutex (GraphicsLock);
 
 		SetFlashRect (NULL);
 
@@ -312,7 +304,7 @@ SetContext (OldContext);
 HSTARSHIP
 GetEncounterStarShip (STARSHIP *LastStarShipPtr, COUNT which_player)
 {
-	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+	if (inHQSpace ())
 	{
 		assert (which_player == RPG_PLAYER_NUM);
 		// SIS for the Hyperspace flight
@@ -356,10 +348,10 @@ GetEncounterStarShip (STARSHIP *LastStar
 				}
 				else
 				{	// Player ran away
-					if (GLOBAL_SIS (FuelOnBoard) > RUN_AWAY_FUEL_COST)
+					if (GLOBAL_SIS (FuelOnBoard) > RUN_AWAY_FUEL_COST && !optInfiniteFuel)
 						GLOBAL_SIS (FuelOnBoard) -= RUN_AWAY_FUEL_COST;
 					else
-						GLOBAL_SIS (FuelOnBoard) = 0;
+						GLOBAL_SIS (FuelOnBoard) = (optInfiniteFuel ? GLOBAL_SIS (FuelOnBoard) : 0);
 				}
 			}
 			return 0;
@@ -442,7 +434,6 @@ DrawArmadaPickShip (BOOLEAN draw_salvage
 
 	t.baseline.x = pick_r.corner.x + (pick_r.extent.width >> 1);
 	t.baseline.y = pick_r.corner.y + pick_r.extent.height - (5 << RESOLUTION_FACTOR) - 2 * RESOLUTION_FACTOR; // JMS_GFX
-	
 	t.align = ALIGN_CENTER;
 	t.pStr = GLOBAL_SIS (ShipName);
 	t.CharCount = (COUNT)~0;
@@ -465,13 +456,13 @@ DrawArmadaPickShip (BOOLEAN draw_salvage
 			ship_index = StarShipPtr->index;
 
 			s.origin.x = pick_r.corner.x
-				+ ((5 << RESOLUTION_FACTOR) + ((ICON_WIDTH + (4 << RESOLUTION_FACTOR))
+					+ ((5 << RESOLUTION_FACTOR) + ((ICON_WIDTH + (4 << RESOLUTION_FACTOR))
 				       * (ship_index % NUM_PICK_SHIP_COLUMNS))); // JMS_GFX
 			if ((ship_index % NUM_PICK_SHIP_COLUMNS) >=
 					(NUM_PICK_SHIP_COLUMNS >> 1))
 				s.origin.x += FLAGSHIP_WIDTH + (4 << RESOLUTION_FACTOR); // JMS_GFX
 			s.origin.y = pick_r.corner.y
-				+ ((16 << RESOLUTION_FACTOR) + ((ICON_HEIGHT + (4 << RESOLUTION_FACTOR))
+					+ ((16 << RESOLUTION_FACTOR) + ((ICON_HEIGHT + (4 << RESOLUTION_FACTOR))
 					* (ship_index / NUM_PICK_SHIP_COLUMNS))); // JMS_GFX
 			s.frame = StarShipPtr->icons;
 			r.corner = s.origin;
@@ -488,7 +479,7 @@ DrawArmadaPickShip (BOOLEAN draw_salvage
 					// JMS_GFX
 					if (RESOLUTION_FACTOR > 0)
 						s.origin.y -= (1 << RESOLUTION_FACTOR);
-					
+
 					s.frame = SetAbsFrameIndex (StatusFrame, 3);
 					DrawStamp (&s);
 				}
diff -ruNp src.hd/uqm/pickship.h src/uqm/pickship.h
--- src.hd/uqm/pickship.h	2017-12-29 02:25:52 -0800
+++ src/uqm/pickship.h	2017-12-29 00:57:48 -0800
@@ -20,8 +20,16 @@
 #include "libs/compiler.h"
 #include "races.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern HSTARSHIP GetEncounterStarShip (STARSHIP *LastStarShipPtr,
 		COUNT which_player);
 extern void DrawArmadaPickShip (BOOLEAN draw_salvage_frame, RECT *pPickRect);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* UQM_PICKSHIP_H_INCL_ */
diff -ruNp src.hd/uqm/plandata.c src/uqm/plandata.c
--- src.hd/uqm/plandata.c	2017-12-29 02:25:52 -0800
+++ src/uqm/plandata.c	2017-12-29 00:57:48 -0800
@@ -16,10 +16,9 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// XXX: for XXX_DEFINED constants
-#include "encount.h"
-#include "hyper.h" // JMS: For ARILOU_HOME_X and Y
+#include "gendef.h"
 #include "resinst.h"
+#include "hyper.h" // JMS: For ARILOU_HOME_X and Y
 #include "planets/planets.h"
 #include "planets/elemdata.h"
 
@@ -307,7 +306,7 @@ STAR_DESC starmap_array[] =
 	{{9062, 5083}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 67},
 	{{7416, 5083}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), RAINBOW_DEFINED, 3, 68},
 	{{5155, 5122}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 11},
-	{{3875, 5145}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), ZOQ_COLONY0_DEFINED, 4, 17},
+	{{3875, 5145}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 4, 17},
 	{{4937, 5145}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 11},
 	{{2979, 5166}, MAKE_STAR (GIANT_STAR, ORANGE_BODY, -1), 0, 1, 15},
 	{{3035, 5178}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 15},
@@ -326,7 +325,7 @@ STAR_DESC starmap_array[] =
 	{{3416, 5437}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 16},
 	{{4000, 5437}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), ZOQFOT_DEFINED, 1, 18},
 	{{6270, 5479}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 102},
-	{{3583, 5479}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), ZOQ_COLONY1_DEFINED, 3, 16},
+	{{3583, 5479}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 16},
 	{{4083, 5513}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 18},
 	{{2159, 5614}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 6, 55},
 	{{3937, 5625}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 18},
@@ -1180,25 +1179,6 @@ const PlanetFrame planet_array[NUMBER_OF
 		DUST_XLAT_TAB,
 		250, 2, 80, 200,
 	},
-	// 	{ /* EARTH_WORLD */
-	// 	MAKE_BYTE (LARGE_ROCKY_WORLD + CRATERED_ALGO,
-	// 			BLUE_BODY), /* Color and type/size of planet */
-	// 	LOW_TECTONICS, /* Tectonics - Scaled with Earth at 82    */
-	// 	MAKE_BYTE (NORMAL_DENSITY, MEDIUM), /* Atmosphere and density */
-	// 	{
-	// 		{IRON, LIGHT_USEFUL},
-	// 		{ALUMINUM, LIGHT_USEFUL},
-	// 		{TIN, LIGHT_USEFUL},
-	// 		{LEAD, LIGHT_USEFUL},
-	// 		{URANIUM, TRACE_USEFUL},
-	// 		{MOLYBDENUM, TRACE_USEFUL},
-	// 		{NOTHING, NO_DEPOSIT},
-	// 		{NOTHING, NO_DEPOSIT},
-	// 	},
-	// 	WATER_COLOR_TAB,
-	// 	WATER_XLAT_TAB,
-	// 	500, 1, 0, 190,
-	// },	
 	{ /* CRIMSON_WORLD */
 		MAKE_BYTE (SMALL_ROCKY_WORLD + CRATERED_ALGO,
 				RED_BODY), /* Color and type/size of planet */
diff -ruNp src.hd/uqm/planets/Makeinfo src/uqm/planets/Makeinfo
--- src.hd/uqm/planets/Makeinfo	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/Makeinfo	2017-12-29 00:57:49 -0800
@@ -2,3 +2,6 @@ uqm_SUBDIRS="generate"
 uqm_CFILES="calc.c cargo.c devices.c gentopo.c lander.c orbits.c
 		oval.c pl_stuff.c planets.c plangen.c pstarmap.c report.c
 		roster.c scan.c solarsys.c surface.c"
+uqm_HFILES="elemdata.h generate.h lander.h lifeform.h plandata.h planets.h
+		scan.h solarsys.h sundata.h"
+
diff -ruNp src.hd/uqm/planets/calc.c src/uqm/planets/calc.c
--- src.hd/uqm/planets/calc.c	2017-12-29 02:25:52 -0800
+++ src/uqm/planets/calc.c	2017-12-29 00:57:48 -0800
@@ -17,7 +17,8 @@
  */
 
 /* ----------------------------- INCLUDES ---------------------------- */
-#include "../encount.h"
+#include "planets.h"
+#include "uqm/starmap.h"
 #include "libs/mathlib.h"
 #include "libs/log.h"
 /* -------------------------------- DATA -------------------------------- */
@@ -26,9 +27,6 @@
 
 //#define DEBUG_PLANET_CALC
 
-#define CalcMass(b) CalcFromBase (b, b)
-#define CalcRadius(b) CalcFromBase (b, ((b) >> 1) + 1)
-
 #define LOW_TEMP 0
 #define MED_TEMP 500
 #define HIGH_TEMP 1500
@@ -36,15 +34,6 @@
 #define MED_TEMP_BONUS 25
 #define HIGH_TEMP_BONUS 50
 #define MAX_TECTONICS 255
-#ifdef OLD
-#define CalcTectonics(b,t) (CalcFromBase(b, 3 << 5) \
-										+ (UWORD)((t) < LOW_TEMP ? 0 : \
-										((t) < MED_TEMP ? LOW_TEMP_BONUS : \
-										((t) < HIGH_TEMP ? MED_TEMP_BONUS : \
-										HIGH_TEMP_BONUS))))
-#else /* OLD */
-#define CalcTectonics(b,t) CalcFromBase(b, 3 << 5)
-#endif /* OLD */
 
 enum
 {
@@ -56,6 +45,18 @@ enum
 	WHITE_SUN_INTENSITY
 };
 
+static UWORD
+CalcFromBase (UWORD base, UWORD variance)
+{
+	return base + LOWORD (RandomContext_Random (SysGenRNG)) % variance;
+}
+
+static inline UWORD
+CalcHalfBaseVariance (UWORD base)
+{
+	return CalcFromBase (base, (base >> 1) + 1);
+}
+
 static void
 CalcSysInfo (SYSTEM_INFO *SysInfoPtr)
 {
@@ -149,7 +150,7 @@ GeneratePlanetComposition (PLANET_INFO *
 					PlanetInfoPtr->Weather += 1 << 5;
 				else if (radius > 10)
 					PlanetInfoPtr->Weather -= 1 << 5;
-				atmo = CalcFromBase (atmo, (atmo >> 1) + 1);
+				atmo = CalcHalfBaseVariance (atmo);
 			}
 		}
 
@@ -165,6 +166,11 @@ GeneratePlanetComposition (PLANET_INFO *
 // have the colour you'd expect based on the true temperature.
 // (eg. Beta Corvi I). I don't know what the idea behind this is,
 // but the if statement must be there for a reason. -- SvdB
+// Update 2013-03-28: The contents of the if() block is probably there to
+// model a greenhouse effect. It seems that it is taken into account when
+// calculating the actual temperature (when landing or scanning), but not
+// when determining the colors of the drawn orbits. (Thanks to James Scott
+// for this insight.)
 static SIZE
 CalcTemp (SYSTEM_INFO *SysInfoPtr, SIZE radius)
 {
@@ -194,7 +200,7 @@ CalcTemp (SYSTEM_INFO *SysInfoPtr, SIZE
 			bonus = COLD_BONUS;
 
 		bonus <<= HINIBBLE (SysInfoPtr->PlanetInfo.PlanDataPtr->AtmoAndDensity);
-		bonus = CalcFromBase (bonus, (bonus >> 1) + 1);
+		bonus = CalcHalfBaseVariance (bonus);
 	}
 
 	return (centigrade + bonus);
@@ -204,15 +210,16 @@ static COUNT
 CalcRotation (PLANET_INFO *PlanetInfoPtr, PLANET_DESC *planet)
 {
 	COUNT period;
-	if (PLANSIZE (PlanetInfoPtr->PlanDataPtr->Type) == GAS_GIANT)
+	if (PLANSIZE (PlanetInfoPtr->PlanDataPtr->Type) == GAS_GIANT) {
 		period = ((COUNT)CalcFromBase (80, 80));
-	else if (((BYTE)TFB_Random () % 10) == 0)
+	} else if (LOBYTE (RandomContext_Random (SysGenRNG)) % 10 == 0) {
 		period = ((COUNT)CalcFromBase ((UWORD)50 * 240, (UWORD)200 * 240));
-	else
+	} else {
 		period = ((COUNT)CalcFromBase (150, 150));
-	// BW 2011: Research shows that most major moons have a synchronous rotation
-	if (planet->pPrevDesc != pSolarSysState->SunDesc)
+	} // BW 2011: Research shows that most major moons have a synchronous rotation
+	if (planet->pPrevDesc != pSolarSysState->SunDesc) {
 		period = ((COUNT)(FULL_CIRCLE * 240 / planet->orb_speed));
+	}
 	return period;
 }
 
@@ -228,22 +235,138 @@ CalcTilt (void)
 	i = NUM_TOSSES;
 	do /* Using added Randomom values to give bell curve */
 	{
-		tilt += (UWORD)TFB_Random () % ((TILT_RANGE / NUM_TOSSES) + 1);
+		tilt += LOWORD (RandomContext_Random (SysGenRNG))
+				% ((TILT_RANGE / NUM_TOSSES) + 1);
 	} while (--i);
 
 	return (tilt);
 }
 
-// NB. Returns the RNG to the state it found it in.
-DWORD
-DoPlanetaryAnalysis (SYSTEM_INFO *SysInfoPtr, PLANET_DESC *pPlanetDesc)
+UWORD
+CalcGravity (const PLANET_INFO *PlanetInfoPtr)
 {
-	DWORD old_seed;
+	return (DWORD)PlanetInfoPtr->PlanetDensity * PlanetInfoPtr->PlanetRadius
+				/ 100;
+}
 
-	if (pPlanetDesc->data_index == HIERARCHY_STARBASE)
-		return (0);
+static UWORD
+CalcTectonics (UWORD base, UWORD temp)
+{
+	UWORD tect = CalcFromBase (base, 3 << 5);
+#ifdef OLD
+	if (temp >= HIGH_TEMP)
+		tect += HIGH_TEMP_BONUS;
+	else if (temp >= MED_TEMP)
+		tect += MED_TEMP_BONUS;
+	else if (temp >= LOW_TEMP)
+		tect += LOW_TEMP_BONUS;
+#else /* !OLD */
+	(void) temp; /* silence compiler whining */
+#endif /* OLD */
+	return tect;
+}
 
-	old_seed = TFB_SeedRandom (pPlanetDesc->rand_seed);
+// This code moved from planets/surface.c:CalcLifeForms()
+static int
+CalcLifeChance (const PLANET_INFO *PlanetInfoPtr)
+{
+	SIZE life_var = 0;
+
+	if (PLANSIZE (PlanetInfoPtr->PlanDataPtr->Type) == GAS_GIANT)
+		return -1;
+
+	if (PlanetInfoPtr->SurfaceTemperature < -151)
+		life_var -= 300;
+	else if (PlanetInfoPtr->SurfaceTemperature < -51)
+		life_var -= 100;
+	else if (PlanetInfoPtr->SurfaceTemperature < 0)
+		life_var += 100;
+	else if (PlanetInfoPtr->SurfaceTemperature < 50)
+		life_var += 300;
+	else if (PlanetInfoPtr->SurfaceTemperature < 150)
+		life_var += 50;
+	else if (PlanetInfoPtr->SurfaceTemperature < 250)
+		life_var -= 100;
+	else if (PlanetInfoPtr->SurfaceTemperature < 500)
+		life_var -= 400;
+	else
+		life_var -= 800;
+
+	if (PlanetInfoPtr->AtmoDensity == 0)
+		life_var -= 1000;
+	else if (PlanetInfoPtr->AtmoDensity < 15)
+		life_var += 100;
+	else if (PlanetInfoPtr->AtmoDensity < 30)
+		life_var += 200;
+	else if (PlanetInfoPtr->AtmoDensity < 100)
+		life_var += 300;
+	else if (PlanetInfoPtr->AtmoDensity < 1000)
+		life_var += 150;
+	else if (PlanetInfoPtr->AtmoDensity < 2500)
+		;
+	else
+		life_var -= 100;
+
+#ifndef NOTYET
+	life_var += 200 + 80 + 80;
+#else /* NOTYET */
+	if (PlanetInfoPtr->SurfaceGravity < 10)
+		;
+	else if (PlanetInfoPtr->SurfaceGravity < 35)
+		life_var += 50;
+	else if (PlanetInfoPtr->SurfaceGravity < 75)
+		life_var += 100;
+	else if (PlanetInfoPtr->SurfaceGravity < 150)
+		life_var += 200;
+	else if (PlanetInfoPtr->SurfaceGravity < 400)
+		life_var += 50;
+	else if (PlanetInfoPtr->SurfaceGravity < 800)
+		;
+	else
+		life_var -= 100;
+
+	if (PlanetInfoPtr->Tectonics < 1)
+		life_var += 80;
+	else if (PlanetInfoPtr->Tectonics < 2)
+		life_var += 70;
+	else if (PlanetInfoPtr->Tectonics < 3)
+		life_var += 60;
+	else if (PlanetInfoPtr->Tectonics < 4)
+		life_var += 50;
+	else if (PlanetInfoPtr->Tectonics < 5)
+		life_var += 25;
+	else if (PlanetInfoPtr->Tectonics < 6)
+		;
+	else
+		life_var -= 100;
+
+	if (PlanetInfoPtr->Weather < 1)
+		life_var += 80;
+	else if (PlanetInfoPtr->Weather < 2)
+		life_var += 70;
+	else if (PlanetInfoPtr->Weather < 3)
+		life_var += 60;
+	else if (PlanetInfoPtr->Weather < 4)
+		life_var += 50;
+	else if (PlanetInfoPtr->Weather < 5)
+		life_var += 25;
+	else if (PlanetInfoPtr->Weather < 6)
+		;
+	else
+		life_var -= 100;
+#endif /* NOTYET */
+
+	return life_var;
+}
+
+// Sets the SysGenRNG to the required state first.
+void
+DoPlanetaryAnalysis (SYSTEM_INFO *SysInfoPtr, PLANET_DESC *pPlanetDesc)
+{
+	assert ((pPlanetDesc->data_index & ~WORLD_TYPE_SPECIAL)
+			< NUMBER_OF_PLANET_TYPES);
+
+	RandomContext_SeedRandom (SysGenRNG, pPlanetDesc->rand_seed);
 
 	CalcSysInfo (SysInfoPtr);
 
@@ -308,18 +431,18 @@ DoPlanetaryAnalysis (SYSTEM_INFO *SysInf
 		}
 		SysInfoPtr->PlanetInfo.PlanetDensity +=
 				(SysInfoPtr->PlanetInfo.PlanetDensity / 20)
-				- ((COUNT)TFB_Random ()
+				- (LOWORD (RandomContext_Random (SysGenRNG))
 				% (SysInfoPtr->PlanetInfo.PlanetDensity / 10));
 
 		switch (PLANSIZE (SysInfoPtr->PlanetInfo.PlanDataPtr->Type))
 		{
 			case SMALL_ROCKY_WORLD:
 #define SMALL_RADIUS 25
-				SysInfoPtr->PlanetInfo.PlanetRadius = CalcRadius (SMALL_RADIUS);
+				SysInfoPtr->PlanetInfo.PlanetRadius = CalcHalfBaseVariance (SMALL_RADIUS);
 				break;
 			case LARGE_ROCKY_WORLD:
 #define LARGE_RADIUS 75
-				SysInfoPtr->PlanetInfo.PlanetRadius = CalcRadius (LARGE_RADIUS);
+				SysInfoPtr->PlanetInfo.PlanetRadius = CalcHalfBaseVariance (LARGE_RADIUS);
 				break;
 			case GAS_GIANT:
 #define MIN_GAS_RADIUS 300
@@ -330,9 +453,7 @@ DoPlanetaryAnalysis (SYSTEM_INFO *SysInf
 		}
 
 		SysInfoPtr->PlanetInfo.RotationPeriod = CalcRotation (&SysInfoPtr->PlanetInfo, pPlanetDesc);
-		SysInfoPtr->PlanetInfo.SurfaceGravity =
-				CalcGravity (SysInfoPtr->PlanetInfo.PlanetDensity,
-				SysInfoPtr->PlanetInfo.PlanetRadius);
+		SysInfoPtr->PlanetInfo.SurfaceGravity = CalcGravity (&SysInfoPtr->PlanetInfo);
 		SysInfoPtr->PlanetInfo.AxialTilt = CalcTilt ();
 		if ((SysInfoPtr->PlanetInfo.Tectonics =
 				CalcTectonics (SysInfoPtr->PlanetInfo.PlanDataPtr->BaseTectonics,
@@ -346,6 +467,8 @@ DoPlanetaryAnalysis (SYSTEM_INFO *SysInf
 		SysInfoPtr->PlanetInfo.Tectonics >>= 5;
 		SysInfoPtr->PlanetInfo.Weather >>= 5;
 
+		SysInfoPtr->PlanetInfo.LifeChance = CalcLifeChance (&SysInfoPtr->PlanetInfo);
+
 #ifdef DEBUG_PLANET_CALC
 		radius = (SIZE)((DWORD)UNSCALE_RADIUS (radius) * 100 / UNSCALE_RADIUS (EARTH_RADIUS));
 		log_add (log_Debug, "\tOrbital Distance   : %d.%02d AU", radius / 100, radius % 100);
@@ -409,7 +532,5 @@ DoPlanetaryAnalysis (SYSTEM_INFO *SysInf
 		}
 #endif /* DEBUG_PLANET_CALC */
 	}
-
-	return (TFB_SeedRandom (old_seed));
 }
 
diff -ruNp src.hd/uqm/planets/cargo.c src/uqm/planets/cargo.c
--- src.hd/uqm/planets/cargo.c	2017-12-29 02:25:52 -0800
+++ src/uqm/planets/cargo.c	2017-12-29 00:57:48 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "../colors.h"
 #include "../controls.h"
 #include "../gamestr.h"
@@ -170,7 +168,7 @@ DrawCargoDisplay (void)
 			(NUM_SCANDOT_TRANSITIONS * 2) + 3);
 	if (RESOLUTION_FACTOR == 2)
 		s.frame = SetRelFrameIndex (s.frame, -1); // JMS_GFX
-	
+
 	r.corner.x = ELEMENT_COL_0;
 	r.extent = GetFrameBounds (s.frame);
 	r.extent.width -= RES_CASE(0,5,7); // JMS_GFX
@@ -197,7 +195,7 @@ DrawCargoDisplay (void)
 	for (i = 0; i < NUM_ELEMENT_CATEGORIES; ++i, cy += ELEMENT_SPACING_Y)
 	{
 		// erase background under an element icon
-		SetContextForeGroundColor (BLACK_COLOR);
+		SetContextForeGroundColor (CARGO_BACK_COLOR); // Serosis: Was actually supposed to be black
 		r.corner.y = cy;
 		DrawFilledRectangle (&r);
 
@@ -210,7 +208,7 @@ DrawCargoDisplay (void)
 	}
 
 	// erase background under the Bio icon
-	SetContextForeGroundColor (BLACK_COLOR);
+	SetContextForeGroundColor (CARGO_BACK_COLOR); // Serosis: Was actually supposed to be black
 	r.corner.y = BIO_ORG_Y;
 	DrawFilledRectangle (&r);
 
@@ -246,8 +244,6 @@ DrawCargoStrings (BYTE OldElement, BYTE
 {
 	CONTEXT OldContext;
 
-	LockMutex (GraphicsLock);
-
 	OldContext = SetContext (StatusContext);
 	SetContextFont (TinyFont);
 
@@ -273,15 +269,12 @@ DrawCargoStrings (BYTE OldElement, BYTE
 
 	UnbatchGraphics ();
 	SetContext (OldContext);
-	UnlockMutex (GraphicsLock);
 }
 
 static void
 DrawElementDescription (COUNT element)
 {
-	LockMutex (GraphicsLock);
 	DrawStatusMessage (GAME_STRING (element + (CARGO_STRING_BASE + 2)));
-	UnlockMutex (GraphicsLock);
 }
 
 static BOOLEAN
@@ -309,10 +302,8 @@ DoDiscardCargo (MENU_STATE *pMS)
 			--GLOBAL_SIS (ElementAmounts[pMS->CurState]);
 			DrawCargoStrings (pMS->CurState, pMS->CurState);
 
-			LockMutex (GraphicsLock);
 			--GLOBAL_SIS (TotalElementMass);
 			ShowRemainingCapacity ();
-			UnlockMutex (GraphicsLock);
 		}
 		else
 		{	// no element left in cargo hold
@@ -365,8 +356,6 @@ CargoMenu (void)
 	DoInput (&MenuState, TRUE);
 
 	// erase the cargo display
-	LockMutex (GraphicsLock);
 	ClearSISRect (DRAW_SIS_DISPLAY);
-	UnlockMutex (GraphicsLock);
 }
 
diff -ruNp src.hd/uqm/planets/devices.c src/uqm/planets/devices.c
--- src.hd/uqm/planets/devices.c	2017-12-29 02:25:52 -0800
+++ src/uqm/planets/devices.c	2017-12-29 00:57:48 -0800
@@ -16,16 +16,16 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "../build.h"
 #include "../colors.h"
+#include "../gendef.h"
+#include "../starmap.h"
 #include "../encount.h"
 #include "../gamestr.h"
 #include "../controls.h"
+#include "../save.h"
 #include "../settings.h"
 #include "../shipcont.h"
-#include "../load.h"
 #include "../setup.h"
 #include "../state.h"
 #include "../sis.h"
@@ -38,9 +38,11 @@
 #include "planets.h"
 		// for SaveSolarSysLocation() and tests
 #include "libs/strlib.h"
+#include "../../options.h"
 #include "libs/graphics/gfx_common.h"
                 // for scaling down devices in 4x
 
+
 // If DEBUG_DEVICES is defined, the device list shown in the game will
 // include the pictures of all devices defined, regardless of which
 // devices the player actually possesses.
@@ -177,12 +179,10 @@ DrawDevicesDisplay (DEVICES_STATE *devSt
 		s.origin.y = cy + ICON_OFS_Y;
 		s.frame = SetAbsFrameIndex (MiscDataFrame,
 				77 + devState->list[devIndex]);
-		if (RESOLUTION_FACTOR < 2)
-		{
+		
+		if (RESOLUTION_FACTOR < 2) {
 			DrawStamp (&s);			
-		}
-		else
-		{
+		} else {
 			int oldMode, oldScale;
 			oldMode = SetGraphicScaleMode (TFB_SCALE_BILINEAR);
 			oldScale = SetGraphicScale ((int)(GSCALE_IDENTITY / 2));
@@ -190,7 +190,7 @@ DrawDevicesDisplay (DEVICES_STATE *devSt
 			SetGraphicScale (oldScale);
 			SetGraphicScaleMode (oldMode);
 		}
-		
+
 		DrawDevice (devState->list[devIndex], i, false);
 	}
 }
@@ -198,7 +198,6 @@ DrawDevicesDisplay (DEVICES_STATE *devSt
 static void
 DrawDevices (DEVICES_STATE *devState, COUNT OldDevice, COUNT NewDevice)
 {
-	LockMutex (GraphicsLock);
 	BatchGraphics ();
 
 	SetContext (StatusContext);
@@ -224,7 +223,6 @@ DrawDevices (DEVICES_STATE *devState, CO
 	}
 
 	UnbatchGraphics ();
-	UnlockMutex (GraphicsLock);
 }
 
 // Returns TRUE if the broadcaster has been successfully activated,
@@ -232,7 +230,7 @@ DrawDevices (DEVICES_STATE *devState, CO
 static BOOLEAN
 UseCaster (void)
 {
-	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+	if (inHQSpace ())
 	{
 		if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
 		{
@@ -271,7 +269,7 @@ UseCaster (void)
 		HIPGROUP hGroup;
 
 		FoundIlwrath = (CurStarDescPtr->Index == ILWRATH_DEFINED)
-				&& ActivateStarShip (ILWRATH_SHIP, SPHERE_TRACKING);
+				&& StartSphereTracking (ILWRATH_SHIP);
 				// In the Ilwrath home system and they are alive?
 
 		if (!FoundIlwrath &&
@@ -387,7 +385,7 @@ InvokeDevice (BYTE which_device)
 			NextActivity |= CHECK_LOAD; /* fake a load game */
 			GLOBAL (CurrentActivity) |= START_ENCOUNTER;
 			SET_GAME_STATE (GLOBAL_FLAGS_AND_DATA, 0);
-			if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+			if (inHQSpace ())
 			{
 				if (GetHeadEncounter ())
 				{
@@ -458,14 +456,15 @@ InvokeDevice (BYTE which_device)
 			break;
 		case PORTAL_SPAWNER_DEVICE:
 #define PORTAL_FUEL_COST (10 * FUEL_TANK_SCALE)
-			if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE
-					&& GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1
+			if (inHyperSpace ()
 					&& GLOBAL_SIS (FuelOnBoard) >= PORTAL_FUEL_COST)
 			{
 				/* No DeltaSISGauges because the flagship picture
 				 * is currently obscured.
 				 */
-				GLOBAL_SIS (FuelOnBoard) -= PORTAL_FUEL_COST;
+				if (!optInfiniteFuel)
+					GLOBAL_SIS (FuelOnBoard) -= PORTAL_FUEL_COST;
+
 				SET_GAME_STATE (PORTAL_COUNTER, 1);
 				return DEVICE_SUCCESS;
 			}
@@ -506,13 +505,11 @@ DoManipulateDevices (MENU_STATE *pMS)
 	{
 		DeviceStatus status;
 
-		LockMutex (GraphicsLock);
 		status = InvokeDevice (devState->list[pMS->CurState]);
 		if (status == DEVICE_FAILURE)
 			PlayMenuSound (MENU_SOUND_FAILURE);
 		else if (status == DEVICE_SUCCESS)
 			PlayMenuSound (MENU_SOUND_INVOKED);
-		UnlockMutex (GraphicsLock);
 
 		return (status == DEVICE_FAILURE);
 	}
@@ -579,10 +576,10 @@ InventoryDevices (BYTE *pDeviceMap, COUN
 				DeviceState = GET_GAME_STATE (ROSY_SPHERE_ON_SHIP);
 				break;
 			case ARTIFACT_2_DEVICE:
-				DeviceState = GET_GAME_STATE (ARTIFACT_2_ON_SHIP);
+				DeviceState = GET_GAME_STATE (WIMBLIS_TRIDENT_ON_SHIP);
 				break;
 			case ARTIFACT_3_DEVICE:
-				DeviceState = GET_GAME_STATE (ARTIFACT_3_ON_SHIP);
+				DeviceState = GET_GAME_STATE (GLOWING_ROD_ON_SHIP);
 				break;
 			case SUN_EFFICIENCY_DEVICE:
 				DeviceState = GET_GAME_STATE (SUN_DEVICE_ON_SHIP);
@@ -695,9 +692,7 @@ DevicesMenu (void)
 	if (GLOBAL_SIS (CrewEnlisted) != (COUNT)~0
 			&& !(GLOBAL (CurrentActivity) & CHECK_ABORT))
 	{
-		LockMutex (GraphicsLock);
 		ClearSISRect (DRAW_SIS_DISPLAY);
-		UnlockMutex (GraphicsLock);
 
 		if (!GET_GAME_STATE (PORTAL_COUNTER)
 				&& !(GLOBAL (CurrentActivity) & START_ENCOUNTER)
diff -ruNp src.hd/uqm/planets/elemdata.h src/uqm/planets/elemdata.h
--- src.hd/uqm/planets/elemdata.h	2017-12-29 02:25:52 -0800
+++ src/uqm/planets/elemdata.h	2017-12-29 00:57:48 -0800
@@ -21,6 +21,9 @@
 
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
 /*------------------------------ Type Defines ----------------------------- */
 enum
@@ -205,5 +208,9 @@ enum
 
 extern const BYTE *Elements;
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _ELEMDATA_H */
 
diff -ruNp src.hd/uqm/planets/generate/Makeinfo src/uqm/planets/generate/Makeinfo
--- src.hd/uqm/planets/generate/Makeinfo	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/generate/Makeinfo	2017-12-29 00:57:48 -0800
@@ -2,4 +2,5 @@ uqm_CFILES="gendefault.c genand.c genbur
 		genilw.c genmel.c genmyc.c genorz.c genpet.c genpku.c genrain.c
 		gensam.c genshof.c gensly.c gensol.c genspa.c gensup.c gensyr.c
 		genthrad.c gentrap.c genutw.c genvault.c genvux.c genwreck.c
-		genyeh.c genzfpscout.c genzoq.c genzoqcolony.c"
+		genyeh.c genzfpscout.c genzoq.c"
+uqm_HFILES="genall.h gendefault.h"
diff -ruNp src.hd/uqm/planets/generate/genand.c src/uqm/planets/generate/genand.c
--- src.hd/uqm/planets/generate/genand.c	2017-12-29 02:25:52 -0800
+++ src/uqm/planets/generate/genand.c	2017-12-29 00:57:48 -0800
@@ -30,8 +30,8 @@
 static bool GenerateAndrosynth_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateAndrosynth_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateAndrosynth_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateAndrosynth_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateAndrosynth_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -153,12 +153,12 @@ GenerateAndrosynth_pickupEnergy (SOLARSY
 }
 
 static COUNT
-GenerateAndrosynth_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateAndrosynth_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 1, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
+		return GenerateDefault_generateRuins (solarSys, whichNode, info);
 	}
 
 	return 0;
diff -ruNp src.hd/uqm/planets/generate/genburv.c src/uqm/planets/generate/genburv.c
--- src.hd/uqm/planets/generate/genburv.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/generate/genburv.c	2017-12-29 00:57:48 -0800
@@ -30,8 +30,8 @@ static bool GenerateBurvixese_generateMo
 		PLANET_DESC *planet);
 static bool GenerateBurvixese_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateBurvixese_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateBurvixese_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateBurvixese_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -86,7 +86,7 @@ GenerateBurvixese_generateMoons (SOLARSY
 		solarSys->MoonDesc[0].data_index = SELENIC_WORLD;
 		solarSys->MoonDesc[0].radius = MIN_MOON_RADIUS
 				+ (MAX_MOONS - 1) * MOON_DELTA;
-		rand_val = TFB_Random ();
+		rand_val = RandomContext_Random (SysGenRNG);
 		angle = NORMALIZE_ANGLE (LOWORD (rand_val));
 		solarSys->MoonDesc[0].location.x =
 				COSINE (angle, solarSys->MoonDesc[0].radius);
@@ -100,18 +100,17 @@ GenerateBurvixese_generateMoons (SOLARSY
 static bool
 GenerateBurvixese_generateOrbital (SOLARSYS_STATE *solarSys, PLANET_DESC *world)
 {
-	COUNT i;
 	DWORD rand_val;
 
-	rand_val = DoPlanetaryAnalysis (&solarSys->SysInfo, world);
+	DoPlanetaryAnalysis (&solarSys->SysInfo, world);
+	rand_val = RandomContext_GetSeed (SysGenRNG);
 
 	solarSys->SysInfo.PlanetInfo.ScanSeed[BIOLOGICAL_SCAN] = rand_val;
-	i = (COUNT)~0;
-	rand_val = GenerateLifeForms (&solarSys->SysInfo, &i);
+	GenerateLifeForms (&solarSys->SysInfo, GENERATE_ALL, NULL);
+	rand_val = RandomContext_GetSeed (SysGenRNG);
 
 	solarSys->SysInfo.PlanetInfo.ScanSeed[MINERAL_SCAN] = rand_val;
-	i = (COUNT)~0;
-	GenerateMineralDeposits (&solarSys->SysInfo, &i);
+	GenerateMineralDeposits (&solarSys->SysInfo, GENERATE_ALL, NULL);
 
 	solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN] = rand_val;
 
@@ -143,12 +142,12 @@ GenerateBurvixese_generateOrbital (SOLAR
 }
 
 static COUNT
-GenerateBurvixese_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateBurvixese_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
+		return GenerateDefault_generateRuins (solarSys, whichNode, info);
 	}
 
 	if (matchWorld (solarSys, world, 0, 0))
@@ -160,7 +159,7 @@ GenerateBurvixese_generateEnergy (SOLARS
 			return 0;
 		}
 		
-		return GenerateDefault_generateArtifact (solarSys, whichNode);
+		return GenerateDefault_generateArtifact (solarSys, whichNode, info);
 	}
 
 	return 0;
diff -ruNp src.hd/uqm/planets/generate/genchmmr.c src/uqm/planets/generate/genchmmr.c
--- src.hd/uqm/planets/generate/genchmmr.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/generate/genchmmr.c	2017-12-29 00:57:48 -0800
@@ -77,7 +77,7 @@ GenerateChmmr_generateMoons (SOLARSYS_ST
 
 		solarSys->MoonDesc[0].data_index = HIERARCHY_STARBASE;
 		solarSys->MoonDesc[0].radius = MIN_MOON_RADIUS;
-		rand_val = TFB_Random ();
+		rand_val = RandomContext_Random (SysGenRNG);
 		angle = NORMALIZE_ANGLE (LOWORD (rand_val));
 		solarSys->MoonDesc[0].location.x =
 				COSINE (angle, solarSys->MoonDesc[0].radius);
@@ -108,7 +108,7 @@ GenerateChmmr_generateOrbital (SOLARSYS_
 		}
 		else if (GET_GAME_STATE (SUN_DEVICE_ON_SHIP)
 				&& !GET_GAME_STATE (ILWRATH_DECEIVED)
-				&& ActivateStarShip (ILWRATH_SHIP, SPHERE_TRACKING))
+				&& StartSphereTracking (ILWRATH_SHIP))
 		{
 			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
 			ReinitQueue (&GLOBAL (ip_group_q));
@@ -134,8 +134,6 @@ GenerateChmmr_generateOrbital (SOLARSYS_
 	else if (matchWorld (solarSys, world, 1, 0))
 	{
 		/* Starbase */
-		LockMutex (GraphicsLock);
-
 		LoadStdLanderFont (&solarSys->SysInfo.PlanetInfo);
 		solarSys->SysInfo.PlanetInfo.DiscoveryString =
 				CaptureStringTable (LoadStringTable (CHMMR_BASE_STRTAB));
@@ -147,8 +145,6 @@ GenerateChmmr_generateOrbital (SOLARSYS_
 		solarSys->SysInfo.PlanetInfo.DiscoveryString = 0;
 		FreeLanderFont (&solarSys->SysInfo.PlanetInfo);
 
-		UnlockMutex (GraphicsLock);
-
 		return true;
 	}
 
diff -ruNp src.hd/uqm/planets/generate/gencol.c src/uqm/planets/generate/gencol.c
--- src.hd/uqm/planets/generate/gencol.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/generate/gencol.c	2017-12-29 00:57:48 -0800
@@ -53,14 +53,14 @@ GenerateColony_initNpcs (SOLARSYS_STATE
 {
 	HIPGROUP hGroup;
 
-	GLOBAL (BattleGroupRef) = GET_GAME_STATE_32 (COLONY_GRPOFFS0);
+	GLOBAL (BattleGroupRef) = GET_GAME_STATE (COLONY_GRPOFFS);
 	if (GLOBAL (BattleGroupRef) == 0)
 	{
 		CloneShipFragment (URQUAN_SHIP,
 				&GLOBAL (npc_built_ship_q), 0);
 		GLOBAL (BattleGroupRef) = PutGroupInfo (GROUPS_ADD_NEW, 1);
 		ReinitQueue (&GLOBAL (npc_built_ship_q));
-		SET_GAME_STATE_32 (COLONY_GRPOFFS0, GLOBAL (BattleGroupRef));
+		SET_GAME_STATE (COLONY_GRPOFFS, GLOBAL (BattleGroupRef));
 	}
 
 	GenerateDefault_initNpcs (solarSys);
diff -ruNp src.hd/uqm/planets/generate/gendefault.c src/uqm/planets/generate/gendefault.c
--- src.hd/uqm/planets/generate/gendefault.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/generate/gendefault.c	2017-12-29 00:57:48 -0800
@@ -27,17 +27,6 @@
 #include "libs/mathlib.h"
 
 
-bool GenerateDefault_initNpcs (SOLARSYS_STATE *solarSys);
-bool GenerateDefault_reinitNpcs (SOLARSYS_STATE *solarSys);
-bool GenerateDefault_uninitNpcs (SOLARSYS_STATE *solarSys);
-bool GenerateDefault_generatePlanets (SOLARSYS_STATE *solarSys);
-bool GenerateDefault_generateMoons (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *planet);
-bool GenerateDefault_generateName (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world);
-bool GenerateDefault_generateOrbital (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world);
-
 static void GeneratePlanets (SOLARSYS_STATE *system);
 static void check_yehat_rebellion (void);
 
@@ -113,7 +102,8 @@ GenerateDefault_generateMoons (SOLARSYS_
 }
 
 bool
-GenerateDefault_generateName (SOLARSYS_STATE *solarSys, PLANET_DESC *world)
+GenerateDefault_generateName (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world)
 {
 	COUNT i = planetIndex (solarSys, world);
 	utf8StringCopy (GLOBAL_SIS (PlanetName), sizeof (GLOBAL_SIS (PlanetName)),
@@ -126,7 +116,6 @@ GenerateDefault_generateName (SOLARSYS_S
 bool
 GenerateDefault_generateOrbital (SOLARSYS_STATE *solarSys, PLANET_DESC *world)
 {
-	COUNT i;
 	DWORD rand_val;
 	SYSTEM_INFO *sysInfo;
 
@@ -146,15 +135,15 @@ GenerateDefault_generateOrbital (SOLARSY
 
 	sysInfo = &solarSys->SysInfo;
 
-	rand_val = DoPlanetaryAnalysis (sysInfo, world);
+	DoPlanetaryAnalysis (sysInfo, world);
+	rand_val = RandomContext_GetSeed (SysGenRNG);
 
 	sysInfo->PlanetInfo.ScanSeed[BIOLOGICAL_SCAN] = rand_val;
-	i = (COUNT)~0;
-	rand_val = GenerateLifeForms (sysInfo, &i);
+	GenerateLifeForms (sysInfo, GENERATE_ALL, NULL);
+	rand_val = RandomContext_GetSeed (SysGenRNG);
 
 	sysInfo->PlanetInfo.ScanSeed[MINERAL_SCAN] = rand_val;
-	i = (COUNT)~0;
-	GenerateMineralDeposits (sysInfo, &i);
+	GenerateMineralDeposits (sysInfo, GENERATE_ALL, NULL);
 
 	sysInfo->PlanetInfo.ScanSeed[ENERGY_SCAN] = rand_val;
 	LoadPlanet (NULL);
@@ -163,12 +152,11 @@ GenerateDefault_generateOrbital (SOLARSY
 }
 
 COUNT
-GenerateDefault_generateMinerals (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode)
+GenerateDefault_generateMinerals (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
-	GenerateMineralDeposits (&solarSys->SysInfo, &whichNode);
+	return GenerateMineralDeposits (&solarSys->SysInfo, whichNode, info);
 	(void) world;
-	return whichNode;
 }
 
 bool
@@ -183,12 +171,13 @@ GenerateDefault_pickupMinerals (SOLARSYS
 }
 
 COUNT
-GenerateDefault_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateDefault_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	(void) whichNode;
 	(void) solarSys;
 	(void) world;
+	(void) info;
 	return 0;
 }
 
@@ -206,12 +195,11 @@ GenerateDefault_pickupEnergy (SOLARSYS_S
 }
 
 COUNT
-GenerateDefault_generateLife (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateDefault_generateLife (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
-	GenerateLifeForms (&solarSys->SysInfo, &whichNode);
+	return GenerateLifeForms (&solarSys->SysInfo, whichNode, info);
 	(void) world;
-	return whichNode;
 }
 
 bool
@@ -226,20 +214,21 @@ GenerateDefault_pickupLife (SOLARSYS_STA
 }
 
 COUNT
-GenerateDefault_generateArtifact (SOLARSYS_STATE *solarSys, COUNT whichNode)
+GenerateDefault_generateArtifact (const SOLARSYS_STATE *solarSys,
+		COUNT whichNode, NODE_INFO *info)
 {
 	// Generate an energy node at a random location
-	GenerateRandomNodes (&solarSys->SysInfo, ENERGY_SCAN, 1, 0, &whichNode);
-	return whichNode;
+	return GenerateRandomNodes (&solarSys->SysInfo, ENERGY_SCAN, 1, 0,
+			whichNode, info);
 }
 
 COUNT
-GenerateDefault_generateRuins (SOLARSYS_STATE *solarSys, COUNT whichNode)
+GenerateDefault_generateRuins (const SOLARSYS_STATE *solarSys,
+		COUNT whichNode, NODE_INFO *info)
 {
 	// Generate a standard spread of city ruins of a destroyed civilization
-	GenerateRandomNodes (&solarSys->SysInfo, ENERGY_SCAN, NUM_RACE_RUINS,
-			0, &whichNode);
-	return whichNode;
+	return GenerateRandomNodes (&solarSys->SysInfo, ENERGY_SCAN, NUM_RACE_RUINS,
+			0, whichNode, info);
 }
 
 static inline void
@@ -309,7 +298,7 @@ GeneratePlanets (SOLARSYS_STATE *solarSy
 		BYTE num_moons;
 		BYTE type;
 
-		rand_val = TFB_Random ();
+		rand_val = RandomContext_Random (SysGenRNG);
 		byte_val = LOBYTE (rand_val);
 
 		num_moons = 0;
diff -ruNp src.hd/uqm/planets/generate/gendefault.h src/uqm/planets/generate/gendefault.h
--- src.hd/uqm/planets/generate/gendefault.h	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/generate/gendefault.h	2017-12-29 00:57:48 -0800
@@ -21,22 +21,26 @@
 #include "../planets.h"
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 bool GenerateDefault_initNpcs (SOLARSYS_STATE *solarSys);
 bool GenerateDefault_reinitNpcs (SOLARSYS_STATE *solarSys);
 bool GenerateDefault_uninitNpcs (SOLARSYS_STATE *solarSys);
 bool GenerateDefault_generatePlanets (SOLARSYS_STATE *solarSys);
 bool GenerateDefault_generateMoons (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *planet);
-bool GenerateDefault_generateName (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world);
+bool GenerateDefault_generateName (const SOLARSYS_STATE *,
+		const PLANET_DESC *world);
 bool GenerateDefault_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-COUNT GenerateDefault_generateMinerals (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-COUNT GenerateDefault_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-COUNT GenerateDefault_generateLife (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+COUNT GenerateDefault_generateMinerals (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
+COUNT GenerateDefault_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
+COUNT GenerateDefault_generateLife (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 bool GenerateDefault_pickupMinerals (SOLARSYS_STATE *, PLANET_DESC *world,
 		COUNT whichNode);
 bool GenerateDefault_pickupEnergy (SOLARSYS_STATE *, PLANET_DESC *world,
@@ -44,13 +48,19 @@ bool GenerateDefault_pickupEnergy (SOLAR
 bool GenerateDefault_pickupLife (SOLARSYS_STATE *, PLANET_DESC *world,
 		COUNT whichNode);
 
-COUNT GenerateDefault_generateArtifact (SOLARSYS_STATE *, COUNT whichNode);
-COUNT GenerateDefault_generateRuins (SOLARSYS_STATE *, COUNT whichNode);
+COUNT GenerateDefault_generateArtifact (const SOLARSYS_STATE *,
+		COUNT whichNode, NODE_INFO *info);
+COUNT GenerateDefault_generateRuins (const SOLARSYS_STATE *,
+		COUNT whichNode, NODE_INFO *info);
 bool GenerateDefault_landerReport (SOLARSYS_STATE *);
 bool GenerateDefault_landerReportCycle (SOLARSYS_STATE *);
 
 
 extern const GenerateFunctions generateDefaultFunctions;
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* GENDEFAULT_H */
 
diff -ruNp src.hd/uqm/planets/generate/gendru.c src/uqm/planets/generate/gendru.c
--- src.hd/uqm/planets/generate/gendru.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/generate/gendru.c	2017-12-29 00:57:48 -0800
@@ -33,8 +33,8 @@
 static bool GenerateDruuge_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateDruuge_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateDruuge_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateDruuge_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateDruuge_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -90,7 +90,7 @@ GenerateDruuge_generateOrbital (SOLARSYS
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		if (ActivateStarShip (DRUUGE_SHIP, SPHERE_TRACKING))
+		if (StartSphereTracking (DRUUGE_SHIP))
 		{
 			NotifyOthers (DRUUGE_SHIP, IPNL_ALL_CLEAR);
 			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
@@ -158,12 +158,12 @@ GenerateDruuge_pickupEnergy (SOLARSYS_ST
 }
 
 static COUNT
-GenerateDruuge_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateDruuge_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
+		return GenerateDefault_generateRuins (solarSys, whichNode, info);
 	}
 
 	return 0;
diff -ruNp src.hd/uqm/planets/generate/genilw.c src/uqm/planets/generate/genilw.c
--- src.hd/uqm/planets/generate/genilw.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/generate/genilw.c	2017-12-29 00:57:48 -0800
@@ -30,8 +30,8 @@
 static bool GenerateIlwrath_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateIlwrath_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateIlwrath_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateIlwrath_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateIlwrath_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -79,7 +79,7 @@ GenerateIlwrath_generateOrbital (SOLARSY
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		if (ActivateStarShip (ILWRATH_SHIP, SPHERE_TRACKING))
+		if (StartSphereTracking (ILWRATH_SHIP))
 		{
 			NotifyOthers (ILWRATH_SHIP, IPNL_ALL_CLEAR);
 			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
@@ -124,12 +124,12 @@ GenerateIlwrath_generateOrbital (SOLARSY
 }
 
 static COUNT
-GenerateIlwrath_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateIlwrath_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
+		return GenerateDefault_generateRuins (solarSys, whichNode, info);
 	}
 
 	return 0;
diff -ruNp src.hd/uqm/planets/generate/genmel.c src/uqm/planets/generate/genmel.c
--- src.hd/uqm/planets/generate/genmel.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/generate/genmel.c	2017-12-29 00:57:48 -0800
@@ -18,7 +18,8 @@
 
 #include "genall.h"
 #include "../../build.h"
-#include "../../encount.h"
+#include "../../gendef.h"
+#include "../../starmap.h"
 #include "../../globdata.h"
 #include "../../state.h"
 #include "libs/log.h"
@@ -26,7 +27,6 @@
 
 static bool GenerateMelnorme_initNpcs (SOLARSYS_STATE *solarSys);
 
-static int SelectMelnormeRefVar (void);
 static DWORD GetMelnormeRef (void);
 static void SetMelnormeRef (DWORD Ref);
 
@@ -65,49 +65,43 @@ GenerateMelnorme_initNpcs (SOLARSYS_STAT
 	return true;
 }
 
-
-static int
-SelectMelnormeRefVar (void)
-{
-	switch (CurStarDescPtr->Index)
-	{
-		case MELNORME0_DEFINED: return MELNORME0_GRPOFFS0;
-		case MELNORME1_DEFINED: return MELNORME1_GRPOFFS0;
-		case MELNORME2_DEFINED: return MELNORME2_GRPOFFS0;
-		case MELNORME3_DEFINED: return MELNORME3_GRPOFFS0;
-		case MELNORME4_DEFINED: return MELNORME4_GRPOFFS0;
-		case MELNORME5_DEFINED: return MELNORME5_GRPOFFS0;
-		case MELNORME6_DEFINED: return MELNORME6_GRPOFFS0;
-		case MELNORME7_DEFINED: return MELNORME7_GRPOFFS0;
-		case MELNORME8_DEFINED: return MELNORME8_GRPOFFS0;
-		default:
-			return -1;
-	}
-}
-
 static DWORD
 GetMelnormeRef (void)
 {
-	int RefVar = SelectMelnormeRefVar ();
-	if (RefVar < 0)
+	switch (CurStarDescPtr->Index)
 	{
-		log_add (log_Warning, "GetMelnormeRef(): reference unknown");
-		return 0;
+		case MELNORME0_DEFINED: return GET_GAME_STATE (MELNORME0_GRPOFFS);
+		case MELNORME1_DEFINED: return GET_GAME_STATE (MELNORME1_GRPOFFS);
+		case MELNORME2_DEFINED: return GET_GAME_STATE (MELNORME2_GRPOFFS);
+		case MELNORME3_DEFINED: return GET_GAME_STATE (MELNORME3_GRPOFFS);
+		case MELNORME4_DEFINED: return GET_GAME_STATE (MELNORME4_GRPOFFS);
+		case MELNORME5_DEFINED: return GET_GAME_STATE (MELNORME5_GRPOFFS);
+		case MELNORME6_DEFINED: return GET_GAME_STATE (MELNORME6_GRPOFFS);
+		case MELNORME7_DEFINED: return GET_GAME_STATE (MELNORME7_GRPOFFS);
+		case MELNORME8_DEFINED: return GET_GAME_STATE (MELNORME8_GRPOFFS);
+		default:
+			log_add (log_Warning, "GetMelnormeRef(): reference unknown");
+			return 0;
 	}
-
-	return GET_GAME_STATE_32 (RefVar);
 }
 
 static void
 SetMelnormeRef (DWORD Ref)
 {
-	int RefVar = SelectMelnormeRefVar ();
-	if (RefVar < 0)
+	switch (CurStarDescPtr->Index)
 	{
-		log_add (log_Warning, "SetMelnormeRef(): reference unknown");
-		return;
+		case MELNORME0_DEFINED: SET_GAME_STATE (MELNORME0_GRPOFFS, Ref); break;
+		case MELNORME1_DEFINED: SET_GAME_STATE (MELNORME1_GRPOFFS, Ref); break;
+		case MELNORME2_DEFINED: SET_GAME_STATE (MELNORME2_GRPOFFS, Ref); break;
+		case MELNORME3_DEFINED: SET_GAME_STATE (MELNORME3_GRPOFFS, Ref); break;
+		case MELNORME4_DEFINED: SET_GAME_STATE (MELNORME4_GRPOFFS, Ref); break;
+		case MELNORME5_DEFINED: SET_GAME_STATE (MELNORME5_GRPOFFS, Ref); break;
+		case MELNORME6_DEFINED: SET_GAME_STATE (MELNORME6_GRPOFFS, Ref); break;
+		case MELNORME7_DEFINED: SET_GAME_STATE (MELNORME7_GRPOFFS, Ref); break;
+		case MELNORME8_DEFINED: SET_GAME_STATE (MELNORME8_GRPOFFS, Ref); break;
+		default:
+			log_add (log_Warning, "SetMelnormeRef(): reference unknown");
+			return;
 	}
-
-	SET_GAME_STATE_32 (RefVar, Ref);
 }
 
diff -ruNp src.hd/uqm/planets/generate/genmyc.c src/uqm/planets/generate/genmyc.c
--- src.hd/uqm/planets/generate/genmyc.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/generate/genmyc.c	2017-12-29 00:57:48 -0800
@@ -22,7 +22,8 @@
 #include "../scan.h"
 #include "../../build.h"
 #include "../../comm.h"
-#include "../../encount.h"
+#include "../../gendef.h"
+#include "../../starmap.h"
 #include "../../globdata.h"
 #include "../../ipdisp.h"
 #include "../../nameref.h"
@@ -34,10 +35,10 @@
 static bool GenerateMycon_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateMycon_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateMycon_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static COUNT GenerateMycon_generateLife (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateMycon_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
+static COUNT GenerateMycon_generateLife (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateMycon_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -89,7 +90,7 @@ GenerateMycon_generateOrbital (SOLARSYS_
 	{
 		if ((CurStarDescPtr->Index == MYCON_DEFINED
 				|| CurStarDescPtr->Index == SUN_DEVICE_DEFINED)
-				&& ActivateStarShip (MYCON_SHIP, SPHERE_TRACKING))
+				&& StartSphereTracking (MYCON_SHIP))
 		{
 			if (CurStarDescPtr->Index == MYCON_DEFINED
 					|| !GET_GAME_STATE (SUN_DEVICE_UNGUARDED))
@@ -142,9 +143,7 @@ GenerateMycon_generateOrbital (SOLARSYS_
 						return true;
 
 					SET_GAME_STATE (SUN_DEVICE_UNGUARDED, 1);
-					LockMutex (GraphicsLock);
 					RepairSISBorder ();
-					UnlockMutex (GraphicsLock);
 				}
 			}
 		}
@@ -189,8 +188,8 @@ GenerateMycon_generateOrbital (SOLARSYS_
 }
 
 static COUNT
-GenerateMycon_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateMycon_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (CurStarDescPtr->Index == SUN_DEVICE_DEFINED
 			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
@@ -202,7 +201,7 @@ GenerateMycon_generateEnergy (SOLARSYS_S
 			return 0;
 		}
 
-		return GenerateDefault_generateArtifact (solarSys, whichNode);
+		return GenerateDefault_generateArtifact (solarSys, whichNode, info);
 	}
 
 	if ((CurStarDescPtr->Index == EGG_CASE0_DEFINED
@@ -219,7 +218,7 @@ GenerateMycon_generateEnergy (SOLARSYS_S
 			return 0;
 		}
 
-		return GenerateDefault_generateArtifact (solarSys, whichNode);
+		return GenerateDefault_generateArtifact (solarSys, whichNode, info);
 	}
 
 	return 0;
@@ -275,12 +274,14 @@ GenerateMycon_pickupEnergy (SOLARSYS_STA
 }
 
 static COUNT
-GenerateMycon_generateLife (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateMycon_generateLife (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
+	// Gee, I wonder why there isn't any life in Mycon systems...
 	(void) whichNode;
 	(void) solarSys;
 	(void) world;
+	(void) info;
 	return 0;
 }
 
diff -ruNp src.hd/uqm/planets/generate/genorz.c src/uqm/planets/generate/genorz.c
--- src.hd/uqm/planets/generate/genorz.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/generate/genorz.c	2017-12-29 00:57:48 -0800
@@ -21,7 +21,8 @@
 #include "../planets.h"
 #include "../../build.h"
 #include "../../comm.h"
-#include "../../encount.h"
+#include "../../gendef.h"
+#include "../../starmap.h"
 #include "../../globdata.h"
 #include "../../ipdisp.h"
 #include "../../nameref.h"
@@ -33,8 +34,8 @@
 static bool GenerateOrz_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateOrz_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateOrz_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateOrz_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateOrz_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -94,7 +95,7 @@ GenerateOrz_generateOrbital (SOLARSYS_ST
 
 		if ((CurStarDescPtr->Index == ORZ_DEFINED
 				|| !GET_GAME_STATE (TAALO_UNPROTECTED))
-				&& ActivateStarShip (ORZ_SHIP, SPHERE_TRACKING))
+				&& StartSphereTracking (ORZ_SHIP))
 		{
 			NotifyOthers (ORZ_SHIP, IPNL_ALL_CLEAR);
 			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
@@ -136,9 +137,7 @@ GenerateOrz_generateOrbital (SOLARSYS_ST
 				if (OrzSurvivors)
 					return true;
 
-				LockMutex (GraphicsLock);
 				RepairSISBorder ();
-				UnlockMutex (GraphicsLock);
 			}
 		}
 
@@ -169,8 +168,8 @@ GenerateOrz_generateOrbital (SOLARSYS_ST
 }
 
 static COUNT
-GenerateOrz_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateOrz_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (CurStarDescPtr->Index == TAALO_PROTECTOR_DEFINED
 			&& matchWorld (solarSys, world, 1, 2))
@@ -182,13 +181,13 @@ GenerateOrz_generateEnergy (SOLARSYS_STA
 			return 0;
 		}
 
-		return GenerateDefault_generateArtifact (solarSys, whichNode);
+		return GenerateDefault_generateArtifact (solarSys, whichNode, info);
 	}
 
 	if (CurStarDescPtr->Index == ORZ_DEFINED
 			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
+		return GenerateDefault_generateRuins (solarSys, whichNode, info);
 	}
 
 	return 0;
diff -ruNp src.hd/uqm/planets/generate/genpet.c src/uqm/planets/generate/genpet.c
--- src.hd/uqm/planets/generate/genpet.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/generate/genpet.c	2017-12-29 00:57:48 -0800
@@ -21,19 +21,21 @@
 #include "../../build.h"
 #include "../../comm.h"
 #include "../../encount.h"
+#include "../../starmap.h"
 #include "../../globdata.h"
 #include "../../ipdisp.h"
 #include "../../nameref.h"
 #include "../../setup.h"
 #include "../../state.h"
 #include "libs/mathlib.h"
+#include "../../../options.h"
 
 
 static bool GenerateTalkingPet_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateTalkingPet_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateTalkingPet_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateTalkingPet_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateTalkingPet_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -83,14 +85,14 @@ GenerateTalkingPet_generateOrbital (SOLA
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET)
 			&& (GET_GAME_STATE (UMGAH_ZOMBIE_BLOBBIES)
 			|| !GET_GAME_STATE (TALKING_PET)
-			|| ActivateStarShip (UMGAH_SHIP, SPHERE_TRACKING)))
+			|| StartSphereTracking (UMGAH_SHIP)))
 	{
 		NotifyOthers (UMGAH_SHIP, IPNL_ALL_CLEAR);
 		PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
 		ReinitQueue (&GLOBAL (ip_group_q));
 		assert (CountLinks (&GLOBAL (npc_built_ship_q)) == 0);
 
-		if (ActivateStarShip (UMGAH_SHIP, SPHERE_TRACKING))
+		if (StartSphereTracking (UMGAH_SHIP))
 		{
 			GLOBAL (CurrentActivity) |= START_INTERPLANETARY;
 			SET_GAME_STATE (GLOBAL_FLAGS_AND_DATA, 1 << 7);
@@ -129,7 +131,7 @@ GenerateTalkingPet_generateOrbital (SOLA
 				// Defeated the zombie fleet.
 				InitCommunication (TALKING_PET_CONVERSATION);
 			}
-			else if (!(ActivateStarShip (UMGAH_SHIP, SPHERE_TRACKING)))
+			else if (!(StartSphereTracking (UMGAH_SHIP)))
 			{
 				// The Kohr-Ah have destroyed the Umgah, but the
 				// talking pet survived.
@@ -161,12 +163,12 @@ GenerateTalkingPet_generateOrbital (SOLA
 }
 
 static COUNT
-GenerateTalkingPet_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateTalkingPet_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
+		return GenerateDefault_generateRuins (solarSys, whichNode, info);
 	}
 
 	return 0;
@@ -212,17 +214,18 @@ ZapToUrquanEncounter (void)
 		TemplatePtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
 		EncounterPtr->origin = TemplatePtr->loc;
 		EncounterPtr->radius = TemplatePtr->actual_strength;
-		EncounterPtr->SD.Type = URQUAN_SHIP;
-		EncounterPtr->SD.Index = MAKE_BYTE (1, 0) | ONE_SHOT_ENCOUNTER;
+		EncounterPtr->race_id = URQUAN_SHIP;
+		EncounterPtr->num_ships = 1;
+		EncounterPtr->flags = ONE_SHOT_ENCOUNTER;
 		BSIPtr = &EncounterPtr->ShipList[0];
 		BSIPtr->race_id = URQUAN_SHIP;
 		BSIPtr->crew_level = TemplatePtr->crew_level;
 		BSIPtr->max_crew = TemplatePtr->max_crew;
 		BSIPtr->max_energy = TemplatePtr->max_energy;
-		EncounterPtr->SD.star_pt.x = 5288;
-		EncounterPtr->SD.star_pt.y = 4892;
-		EncounterPtr->log_x = UNIVERSE_TO_LOGX (EncounterPtr->SD.star_pt.x);
-		EncounterPtr->log_y = UNIVERSE_TO_LOGY (EncounterPtr->SD.star_pt.y);
+		EncounterPtr->loc_pt.x = 5288;
+		EncounterPtr->loc_pt.y = 4892;
+		EncounterPtr->log_x = UNIVERSE_TO_LOGX (EncounterPtr->loc_pt.x);
+		EncounterPtr->log_y = UNIVERSE_TO_LOGY (EncounterPtr->loc_pt.y);
 		GLOBAL_SIS (log_x) = EncounterPtr->log_x;
 		GLOBAL_SIS (log_y) = EncounterPtr->log_y;
 		UnlockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
@@ -230,20 +233,19 @@ ZapToUrquanEncounter (void)
 		{
 #define LOST_DAYS 15
 			SleepThreadUntil (FadeScreen (FadeAllToBlack, ONE_SECOND * 2));
-			LockMutex (GraphicsLock);
 			MoveGameClockDays (LOST_DAYS);
-			UnlockMutex (GraphicsLock);
 		}
 
 		GLOBAL (CurrentActivity) = MAKE_WORD (IN_HYPERSPACE, 0) | START_ENCOUNTER;
 
-		dx = CurStarDescPtr->star_pt.x - EncounterPtr->SD.star_pt.x;
-		dy = CurStarDescPtr->star_pt.y - EncounterPtr->SD.star_pt.y;
+		dx = CurStarDescPtr->star_pt.x - EncounterPtr->loc_pt.x;
+		dy = CurStarDescPtr->star_pt.y - EncounterPtr->loc_pt.y;
 		dx = (SIZE)square_root ((long)dx * dx + (long)dy * dy)
 				+ (FUEL_TANK_SCALE >> 1);
 
-		LockMutex (GraphicsLock);
-		DeltaSISGauges (0, -dx, 0);
+		if (!optInfiniteFuel)
+			DeltaSISGauges (0, -dx, 0);
+
 		if (GLOBAL_SIS (FuelOnBoard) < 5 * FUEL_TANK_SCALE)
 		{
 			dx = ((5 + ((COUNT)TFB_Random () % 5)) * FUEL_TANK_SCALE)
@@ -251,8 +253,7 @@ ZapToUrquanEncounter (void)
 			DeltaSISGauges (0, dx, 0);
 		}
 		DrawSISMessage (NULL);
-		DrawHyperCoords (EncounterPtr->SD.star_pt);
-		UnlockMutex (GraphicsLock);
+		DrawHyperCoords (EncounterPtr->loc_pt);
 
 		UnlockEncounter (hEncounter);
 	}
diff -ruNp src.hd/uqm/planets/generate/genpku.c src/uqm/planets/generate/genpku.c
--- src.hd/uqm/planets/generate/genpku.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/generate/genpku.c	2017-12-29 00:57:48 -0800
@@ -31,8 +31,8 @@
 static bool GeneratePkunk_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GeneratePkunk_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GeneratePkunk_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GeneratePkunk_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GeneratePkunk_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -81,7 +81,7 @@ GeneratePkunk_generateOrbital (SOLARSYS_
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		if (ActivateStarShip (PKUNK_SHIP, SPHERE_TRACKING))
+		if (StartSphereTracking (PKUNK_SHIP))
 		{
 			NotifyOthers (PKUNK_SHIP, IPNL_ALL_CLEAR);
 			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
@@ -148,12 +148,12 @@ GeneratePkunk_pickupEnergy (SOLARSYS_STA
 }
 
 static COUNT
-GeneratePkunk_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GeneratePkunk_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
+		return GenerateDefault_generateRuins (solarSys, whichNode, info);
 	}
 
 	return 0;
diff -ruNp src.hd/uqm/planets/generate/genrain.c src/uqm/planets/generate/genrain.c
--- src.hd/uqm/planets/generate/genrain.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/generate/genrain.c	2017-12-29 00:57:48 -0800
@@ -18,7 +18,8 @@
 
 #include "genall.h"
 #include "../planets.h"
-#include "../../encount.h"
+#include "../../gendef.h"
+#include "../../starmap.h"
 #include "../../globdata.h"
 #include "libs/mathlib.h"
 
diff -ruNp src.hd/uqm/planets/generate/gensam.c src/uqm/planets/generate/gensam.c
--- src.hd/uqm/planets/generate/gensam.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/generate/gensam.c	2017-12-29 00:57:48 -0800
@@ -150,7 +150,7 @@ GenerateSaMatra_generateMoons (SOLARSYS_
 
 		solarSys->MoonDesc[0].data_index = SA_MATRA;
 		solarSys->MoonDesc[0].radius = MIN_MOON_RADIUS + (2 * MOON_DELTA);
-		rand_val = TFB_Random ();
+		rand_val = RandomContext_Random (SysGenRNG);
 		angle = NORMALIZE_ANGLE (LOWORD (rand_val));
 		solarSys->MoonDesc[0].location.x =
 				COSINE (angle, solarSys->MoonDesc[0].radius);
@@ -216,9 +216,8 @@ GenerateSaMatra_generateOrbital (SOLARSY
 				EncounterRace = -1;
 				GLOBAL (CurrentActivity) = IN_LAST_BATTLE | START_ENCOUNTER;
 				if (GET_GAME_STATE (YEHAT_CIVIL_WAR)
-						&& ActivateStarShip (YEHAT_SHIP, SPHERE_TRACKING)
-						&& ActivateStarShip (YEHAT_REBEL_SHIP,
-						FEASIBILITY_STUDY))
+						&& StartSphereTracking (YEHAT_SHIP)
+						&& EscortFeasibilityStudy (YEHAT_REBEL_SHIP))
 					InitCommunication (YEHAT_REBEL_CONVERSATION);
 			}
 		}
@@ -237,7 +236,7 @@ BuildUrquanGuard (SOLARSYS_STATE *solarS
 	POINT org;
 	HIPGROUP hGroup, hNextGroup;
 
-	GLOBAL (BattleGroupRef) = GET_GAME_STATE_32 (SAMATRA_GRPOFFS0);
+	GLOBAL (BattleGroupRef) = GET_GAME_STATE (SAMATRA_GRPOFFS);
 
 	if (!GET_GAME_STATE (KOHR_AH_FRENZY))
 	{
@@ -258,7 +257,7 @@ BuildUrquanGuard (SOLARSYS_STATE *solarS
 	if (GLOBAL (BattleGroupRef) == 0)
 	{
 		GLOBAL (BattleGroupRef) = PutGroupInfo (GROUPS_ADD_NEW, 1);
-		SET_GAME_STATE_32 (SAMATRA_GRPOFFS0, GLOBAL (BattleGroupRef));
+		SET_GAME_STATE (SAMATRA_GRPOFFS, GLOBAL (BattleGroupRef));
 	}
 
 #define NUM_URQUAN_GUARDS0 12
diff -ruNp src.hd/uqm/planets/generate/genshof.c src/uqm/planets/generate/genshof.c
--- src.hd/uqm/planets/generate/genshof.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/generate/genshof.c	2017-12-29 00:57:48 -0800
@@ -57,7 +57,7 @@ GenerateShofixti_initNpcs (SOLARSYS_STAT
 			|| (!GET_GAME_STATE (SHOFIXTI_BRO_KIA)
 			&& GET_GAME_STATE (MAIDENS_ON_SHIP))))
 	{
-		GLOBAL (BattleGroupRef) = GET_GAME_STATE_32 (SHOFIXTI_GRPOFFS0);
+		GLOBAL (BattleGroupRef) = GET_GAME_STATE (SHOFIXTI_GRPOFFS);
 		if (GLOBAL (BattleGroupRef) == 0
 				|| !GetGroupInfo (GLOBAL (BattleGroupRef), GROUP_INIT_IP))
 		{
@@ -82,7 +82,7 @@ GenerateShofixti_initNpcs (SOLARSYS_STAT
 			GLOBAL (BattleGroupRef) = PutGroupInfo (
 					GLOBAL (BattleGroupRef), 1);
 			ReinitQueue (&GLOBAL (npc_built_ship_q));
-			SET_GAME_STATE_32 (SHOFIXTI_GRPOFFS0, GLOBAL (BattleGroupRef));
+			SET_GAME_STATE (SHOFIXTI_GRPOFFS, GLOBAL (BattleGroupRef));
 		}
 	}
 
diff -ruNp src.hd/uqm/planets/generate/gensol.c src/uqm/planets/generate/gensol.c
--- src.hd/uqm/planets/generate/gensol.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/generate/gensol.c	2017-12-29 00:57:48 -0800
@@ -29,7 +29,7 @@
 #include "../../state.h"
 #include "libs/mathlib.h"
 #include "options.h"
-
+#include "../../setup.h"
 #include <math.h>
 
 static bool GenerateSol_initNpcs (SOLARSYS_STATE *solarSys);
@@ -37,14 +37,14 @@ static bool GenerateSol_reinitNpcs (SOLA
 static bool GenerateSol_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateSol_generateMoons (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *planet);
-static bool GenerateSol_generateName (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world);
+static bool GenerateSol_generateName (const SOLARSYS_STATE *,
+		const PLANET_DESC *world);
 static bool GenerateSol_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateSol_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static COUNT GenerateSol_generateLife (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateSol_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
+static COUNT GenerateSol_generateLife (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateSol_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -72,13 +72,13 @@ const GenerateFunctions generateSolFunct
 static bool
 GenerateSol_initNpcs (SOLARSYS_STATE *solarSys)
 {
-	GLOBAL (BattleGroupRef) = GET_GAME_STATE_32 (URQUAN_PROBE_GRPOFFS0);
+	GLOBAL (BattleGroupRef) = GET_GAME_STATE (URQUAN_PROBE_GRPOFFS);
 	if (GLOBAL (BattleGroupRef) == 0)
 	{
 		CloneShipFragment (URQUAN_DRONE_SHIP, &GLOBAL (npc_built_ship_q), 0);
 		GLOBAL (BattleGroupRef) = PutGroupInfo (GROUPS_ADD_NEW, 1);
 		ReinitQueue (&GLOBAL (npc_built_ship_q));
-		SET_GAME_STATE_32 (URQUAN_PROBE_GRPOFFS0, GLOBAL (BattleGroupRef));
+		SET_GAME_STATE (URQUAN_PROBE_GRPOFFS, GLOBAL (BattleGroupRef));
 	}
 
 	if (!init_probe ())
@@ -110,73 +110,84 @@ GenerateSol_generatePlanets (SOLARSYS_ST
 	COUNT planetI;
 
 #define SOL_SEED 334241042L
-	TFB_SeedRandom (SOL_SEED);
+	RandomContext_SeedRandom (SysGenRNG, SOL_SEED);
 
 	solarSys->SunDesc[0].NumPlanets = 9;
 	for (planetI = 0; planetI < 9; ++planetI)
 	{
+		//COUNT angle;
 		DWORD rand_val;
 		UWORD word_val;
 		PLANET_DESC *pCurDesc = &solarSys->PlanetDesc[planetI];
 
-		pCurDesc->rand_seed = rand_val = TFB_Random ();
+		pCurDesc->rand_seed = RandomContext_Random (SysGenRNG);
+		rand_val = pCurDesc->rand_seed;
 		word_val = LOWORD (rand_val);
+		//angle = NORMALIZE_ANGLE ((COUNT)HIBYTE (word_val));
 		pCurDesc->angle = NORMALIZE_ANGLE ((COUNT)HIBYTE (word_val));
 
 		switch (planetI)
 		{
 			case 0: /* MERCURY */
 				pCurDesc->data_index = METAL_WORLD;
-				pCurDesc->alternate_colormap = MERCURY_COLOR_TAB;
+				if (solTexturesPresent)
+					pCurDesc->alternate_colormap = MERCURY_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 39L / 100;
 				pCurDesc->NumPlanets = 0;
 				break;
 			case 1: /* VENUS */
 				pCurDesc->data_index = PRIMORDIAL_WORLD;
-				pCurDesc->alternate_colormap = VENUS_COLOR_TAB;
+				if (solTexturesPresent)
+					pCurDesc->alternate_colormap = VENUS_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 72L / 100;
 				pCurDesc->NumPlanets = 0;
 				pCurDesc->angle = NORMALIZE_ANGLE (FULL_CIRCLE - pCurDesc->angle);
 				break;
 			case 2: /* EARTH */
-				pCurDesc->data_index = WATER_WORLD | PLANET_SHIELDED; // EARTH_WORLD
+				pCurDesc->data_index = WATER_WORLD | PLANET_SHIELDED;
 				pCurDesc->alternate_colormap = NULL;
 				pCurDesc->radius = EARTH_RADIUS;
 				pCurDesc->NumPlanets = 2;
 				break;
 			case 3: /* MARS */
 				pCurDesc->data_index = DUST_WORLD;
-				pCurDesc->alternate_colormap = MARS_COLOR_TAB;
+				if (solTexturesPresent)
+					pCurDesc->alternate_colormap = MARS_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 152L / 100;
 				pCurDesc->NumPlanets = 0;
 				break;
 			case 4: /* JUPITER */
 				pCurDesc->data_index = RED_GAS_GIANT;
-				pCurDesc->alternate_colormap = JUPITER_COLOR_TAB;
+				if (solTexturesPresent)
+					pCurDesc->alternate_colormap = JUPITER_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 500L /* 520L */ / 100;
 				pCurDesc->NumPlanets = 4;
 				break;
 			case 5: /* SATURN */
 				pCurDesc->data_index = ORA_GAS_GIANT;
-				pCurDesc->alternate_colormap = SATURN_COLOR_TAB;
+				if (solTexturesPresent)
+					pCurDesc->alternate_colormap = SATURN_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 750L /* 952L */ / 100;
 				pCurDesc->NumPlanets = 1;
 				break;
 			case 6: /* URANUS */
 				pCurDesc->data_index = GRN_GAS_GIANT;
-				pCurDesc->alternate_colormap = URANUS_COLOR_TAB;
+				if (solTexturesPresent)
+					pCurDesc->alternate_colormap = URANUS_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 1000L /* 1916L */ / 100;
 				pCurDesc->NumPlanets = 0;
 				break;
 			case 7: /* NEPTUNE */
 				pCurDesc->data_index = BLU_GAS_GIANT;
-				pCurDesc->alternate_colormap = NEPTUNE_COLOR_TAB;
+				if (solTexturesPresent)
+					pCurDesc->alternate_colormap = NEPTUNE_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 1250L /* 2999L */ / 100;
 				pCurDesc->NumPlanets = 1;
 				break;
 			case 8: /* PLUTO */
 				pCurDesc->data_index = PELLUCID_WORLD;
-				pCurDesc->alternate_colormap = PLUTO_COLOR_TAB;
+				if (solTexturesPresent)
+					pCurDesc->alternate_colormap = PLUTO_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 1550L /* 3937L */ / 100;
 				pCurDesc->NumPlanets = 0;
 				pCurDesc->angle = FULL_CIRCLE - OCTANT;
@@ -218,10 +229,11 @@ GenerateSol_generateMoons (SOLARSYS_STAT
 
 			/* Luna: */
 			solarSys->MoonDesc[1].data_index = SELENIC_WORLD;
-			solarSys->MoonDesc[1].alternate_colormap = LUNA_COLOR_TAB;
+			if (solTexturesPresent)
+				solarSys->MoonDesc[1].alternate_colormap = LUNA_COLOR_TAB;
 			solarSys->MoonDesc[1].radius = MIN_MOON_RADIUS
 					+ (MAX_MOONS - 1) * MOON_DELTA;
-			rand_val = TFB_Random ();
+			rand_val = RandomContext_Random (SysGenRNG);
 			angle = NORMALIZE_ANGLE (LOWORD (rand_val));
 			solarSys->MoonDesc[1].location.x =
 					COSINE (angle, solarSys->MoonDesc[1].radius);
@@ -232,25 +244,30 @@ GenerateSol_generateMoons (SOLARSYS_STAT
 		}
 		case 4: /* moons of JUPITER */
 			solarSys->MoonDesc[0].data_index = RADIOACTIVE_WORLD;
-			solarSys->MoonDesc[0].alternate_colormap = IO_COLOR_TAB;
+			if (solTexturesPresent)
+				solarSys->MoonDesc[0].alternate_colormap = IO_COLOR_TAB;
 			solarSys->MoonDesc[0].orb_speed = FULL_CIRCLE / 1.77;
 					/* Io */
 			solarSys->MoonDesc[1].data_index = HALIDE_WORLD;
-			solarSys->MoonDesc[1].alternate_colormap = EUROPA_COLOR_TAB;
+			if (solTexturesPresent)
+				solarSys->MoonDesc[1].alternate_colormap = EUROPA_COLOR_TAB;
 			solarSys->MoonDesc[1].orb_speed = FULL_CIRCLE / 3.55;
 					/* Europa */
 			solarSys->MoonDesc[2].data_index = CYANIC_WORLD;
-			solarSys->MoonDesc[2].alternate_colormap = GANYMEDE_COLOR_TAB;
+			if (solTexturesPresent)
+				solarSys->MoonDesc[2].alternate_colormap = GANYMEDE_COLOR_TAB;
 			solarSys->MoonDesc[2].orb_speed = FULL_CIRCLE / 7.16;
 					/* Ganymede */
 			solarSys->MoonDesc[3].data_index = PELLUCID_WORLD;
-			solarSys->MoonDesc[3].alternate_colormap = CALLISTO_COLOR_TAB;
+			if (solTexturesPresent)
+				solarSys->MoonDesc[3].alternate_colormap = CALLISTO_COLOR_TAB;
 			solarSys->MoonDesc[3].orb_speed = FULL_CIRCLE / 16.69;
 					/* Callisto */
 			break;
 		case 5: /* moons of SATURN */
 			solarSys->MoonDesc[0].data_index = ALKALI_WORLD;
-			solarSys->MoonDesc[0].alternate_colormap = TITAN_COLOR_TAB;
+			if (solTexturesPresent)
+				solarSys->MoonDesc[0].alternate_colormap = TITAN_COLOR_TAB;
 			solarSys->MoonDesc[0].radius = MIN_MOON_RADIUS
 					+ (MAX_MOONS - 1) * MOON_DELTA;
 			solarSys->MoonDesc[0].orb_speed = FULL_CIRCLE / 15.95;
@@ -258,7 +275,8 @@ GenerateSol_generateMoons (SOLARSYS_STAT
 			break;
 		case 7: /* moons of NEPTUNE */
 			solarSys->MoonDesc[0].data_index = VINYLOGOUS_WORLD;
-			solarSys->MoonDesc[0].alternate_colormap = TRITON_COLOR_TAB;
+			if (solTexturesPresent)
+				solarSys->MoonDesc[0].alternate_colormap = TRITON_COLOR_TAB;
 			solarSys->MoonDesc[0].orb_speed = FULL_CIRCLE / -5.88;
 					/* Triton */
 			break;
@@ -268,7 +286,8 @@ GenerateSol_generateMoons (SOLARSYS_STAT
 }
 
 static bool
-GenerateSol_generateName (SOLARSYS_STATE *solarSys, PLANET_DESC *world)
+GenerateSol_generateName (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world)
 {
 	COUNT planetNr = planetIndex (solarSys, world);
 	utf8StringCopy (GLOBAL_SIS (PlanetName), sizeof (GLOBAL_SIS (PlanetName)),
@@ -297,15 +316,12 @@ GenerateSol_generateOrbital (SOLARSYS_ST
 		return true;
 	}
 
-	rand_val = DoPlanetaryAnalysis (&solarSys->SysInfo, world);
-	if (rand_val)
-	{
-		COUNT i;
+	DoPlanetaryAnalysis (&solarSys->SysInfo, world);
+	rand_val = RandomContext_GetSeed (SysGenRNG);
 
-		solarSys->SysInfo.PlanetInfo.ScanSeed[MINERAL_SCAN] = rand_val;
-		i = (COUNT)~0;
-		rand_val = GenerateMineralDeposits (&solarSys->SysInfo, &i);
-	}
+	solarSys->SysInfo.PlanetInfo.ScanSeed[MINERAL_SCAN] = rand_val;
+	GenerateMineralDeposits (&solarSys->SysInfo, GENERATE_ALL, NULL);
+	rand_val = RandomContext_GetSeed (SysGenRNG);
 
 	planetNr = planetIndex (solarSys, world);
 	if (worldIsPlanet (solarSys, world))
@@ -433,42 +449,45 @@ GenerateSol_generateOrbital (SOLARSYS_ST
 		}
 
 		solarSys->SysInfo.PlanetInfo.SurfaceGravity =
-				CalcGravity (solarSys->SysInfo.PlanetInfo.PlanetDensity,
-				solarSys->SysInfo.PlanetInfo.PlanetRadius);
-
-		switch (planetNr)
-			{
-			case 0: /* MERCURY */
-				LoadPlanet (CaptureDrawable (LoadGraphic (MERCURY_MASK_ANIM)));
-				break;
-			case 1: /* VENUS */
-				LoadPlanet (CaptureDrawable (LoadGraphic (VENUS_MASK_ANIM)));
-				break;
-			case 2: /* EARTH */
-				LoadPlanet (CaptureDrawable (LoadGraphic (EARTH_MASK_ANIM)));
-				break;
-			case 3: /* MARS */
-				LoadPlanet (CaptureDrawable (LoadGraphic (MARS_MASK_ANIM)));
-				break;
-			case 4: /* JUPITER*/
-				LoadPlanet (CaptureDrawable (LoadGraphic (JUPITER_MASK_ANIM)));
-				break;
-			case 5: /* SATURN*/
-				LoadPlanet (CaptureDrawable (LoadGraphic (SATURN_MASK_ANIM)));
-				break;
-			case 6: /* URANUS */
-				LoadPlanet (CaptureDrawable (LoadGraphic (URANUS_MASK_ANIM)));
-				break;
-			case 7: /* NEPTUNE */
-				LoadPlanet (CaptureDrawable (LoadGraphic (NEPTUNE_MASK_ANIM)));
-				break;
-			case 8: /* PLUTO */
-				LoadPlanet (CaptureDrawable (LoadGraphic (PLUTO_MASK_ANIM)));
-				break;
-			default:
-				LoadPlanet (NULL);
-				break;
+				CalcGravity (&solarSys->SysInfo.PlanetInfo);
+		
+		if (solTexturesPresent){
+			switch (planetNr) {
+				case 0: /* MERCURY */
+					LoadPlanet (CaptureDrawable (LoadGraphic (MERCURY_MASK_ANIM)));
+					break;
+				case 1: /* VENUS */
+					LoadPlanet (CaptureDrawable (LoadGraphic (VENUS_MASK_ANIM)));
+					break;
+				case 2: /* EARTH */
+					LoadPlanet (CaptureDrawable (LoadGraphic (EARTH_MASK_ANIM)));
+					break;
+				case 3: /* MARS */
+					LoadPlanet (CaptureDrawable (LoadGraphic (MARS_MASK_ANIM)));
+					break;
+				case 4: /* JUPITER*/
+					LoadPlanet (CaptureDrawable (LoadGraphic (JUPITER_MASK_ANIM)));
+					break;
+				case 5: /* SATURN*/
+					LoadPlanet (CaptureDrawable (LoadGraphic (SATURN_MASK_ANIM)));
+					break;
+				case 6: /* URANUS */
+					LoadPlanet (CaptureDrawable (LoadGraphic (URANUS_MASK_ANIM)));
+					break;
+				case 7: /* NEPTUNE */
+					LoadPlanet (CaptureDrawable (LoadGraphic (NEPTUNE_MASK_ANIM)));
+					break;
+				case 8: /* PLUTO */
+					LoadPlanet (CaptureDrawable (LoadGraphic (PLUTO_MASK_ANIM)));
+					break;
+				default:
+					LoadPlanet (NULL);
+					break;
 			}
+		} else {
+			LoadPlanet (planetNr == 2 ?
+					CaptureDrawable (LoadGraphic (EARTH_MASK_ANIM)) : NULL);			
+		}
 	}
 	else
 	{
@@ -481,6 +500,10 @@ GenerateSol_generateOrbital (SOLARSYS_ST
 		switch (planetNr)
 		{
 			case 2: /* moons of EARTH */
+				// NOTE: Even though we save the seed here, it is irrelevant.
+				//   The seed will be used to randomly place the tractors, but
+				//   since they are mobile, they will be moved to different
+				//   locations not governed by this seed.
 				solarSys->SysInfo.PlanetInfo.ScanSeed[BIOLOGICAL_SCAN] =
 						rand_val;
 
@@ -565,50 +588,49 @@ GenerateSol_generateOrbital (SOLARSYS_ST
 		}
 
 		solarSys->SysInfo.PlanetInfo.SurfaceGravity =
-				CalcGravity (solarSys->SysInfo.PlanetInfo.PlanetDensity,
-				solarSys->SysInfo.PlanetInfo.PlanetRadius);
+				CalcGravity (&solarSys->SysInfo.PlanetInfo);
 		
-		switch (planetNr)
-			{
-			case 2: /* moons of EARTH */
-				if (moonNr == 1)
-					LoadPlanet (CaptureDrawable (LoadGraphic (LUNA_MASK_ANIM)));
-				else
-					LoadPlanet (NULL);
-				break;
-			case 4: /* moons of JUPITER */
-				switch (moonNr)
-				{
-					case 0: /* Io */
-						LoadPlanet (CaptureDrawable (LoadGraphic (IO_MASK_ANIM)));
-						break;
-					case 1: /* Europa */
-						LoadPlanet (CaptureDrawable (LoadGraphic (EUROPA_MASK_ANIM)));
-						break;
-					case 2: /* Ganymede */
-						LoadPlanet (CaptureDrawable (LoadGraphic (GANYMEDE_MASK_ANIM)));
-						break;
-					case 3: /* Callisto */
-						LoadPlanet (CaptureDrawable (LoadGraphic (CALLISTO_MASK_ANIM)));
-						break;
-				}
-				break;
-			case 5: /* moon of Saturn: Titan */
-				LoadPlanet (CaptureDrawable (LoadGraphic (TITAN_MASK_ANIM)));
-				break;
-			case 7: /* moon of NEPTUNE: Triton */
-			default:
-				LoadPlanet (CaptureDrawable (LoadGraphic (TRITON_MASK_ANIM)));
-				break;
+		if (solTexturesPresent){
+			switch (planetNr) {
+				case 2: /* moons of EARTH */
+					if (moonNr == 1)
+						LoadPlanet (CaptureDrawable (LoadGraphic (LUNA_MASK_ANIM)));
+					else
+						LoadPlanet (NULL);
+					break;
+				case 4: /* moons of JUPITER */
+					switch (moonNr) {
+						case 0: /* Io */
+							LoadPlanet (CaptureDrawable (LoadGraphic (IO_MASK_ANIM)));
+							break;
+						case 1: /* Europa */
+							LoadPlanet (CaptureDrawable (LoadGraphic (EUROPA_MASK_ANIM)));
+							break;
+						case 2: /* Ganymede */
+							LoadPlanet (CaptureDrawable (LoadGraphic (GANYMEDE_MASK_ANIM)));
+							break;
+						case 3: /* Callisto */
+							LoadPlanet (CaptureDrawable (LoadGraphic (CALLISTO_MASK_ANIM)));
+							break;
+					}
+					break;
+				case 5: /* moon of Saturn: Titan */
+					LoadPlanet (CaptureDrawable (LoadGraphic (TITAN_MASK_ANIM)));
+					break;
+				case 7: /* moon of NEPTUNE: Triton */
+				default:
+					LoadPlanet (CaptureDrawable (LoadGraphic (TRITON_MASK_ANIM)));
+					break;
 			}
+		}
 	}
 
 	return true;
 }
 
 static COUNT
-GenerateSol_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateSol_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 8, MATCH_PLANET))
 	{
@@ -620,8 +642,11 @@ GenerateSol_generateEnergy (SOLARSYS_STA
 			return 0;
 		}
 
-		solarSys->SysInfo.PlanetInfo.CurPt.x = (20 << RESOLUTION_FACTOR); // JMS_GFX
-		solarSys->SysInfo.PlanetInfo.CurPt.y = MAP_HEIGHT - (8 << RESOLUTION_FACTOR); // JMS_GFX
+		if (info)
+		{
+			info->loc_pt.x = 20 << RESOLUTION_FACTOR;
+			info->loc_pt.y = MAP_HEIGHT - (8 << RESOLUTION_FACTOR);
+		}
 
 		return 1; // only matters when count is requested
 	}
@@ -636,8 +661,11 @@ GenerateSol_generateEnergy (SOLARSYS_STA
 			return 0;
 		}
 
-		solarSys->SysInfo.PlanetInfo.CurPt.x = MAP_WIDTH * 3 / 4;
-		solarSys->SysInfo.PlanetInfo.CurPt.y = MAP_HEIGHT * 1 / 4;
+		if (info)
+		{
+			info->loc_pt.x = MAP_WIDTH * 3 / 4;
+			info->loc_pt.y = MAP_HEIGHT * 1 / 4;
+		}
 
 		return 1; // only matters when count is requested
 	}
@@ -688,15 +716,14 @@ GenerateSol_pickupEnergy (SOLARSYS_STATE
 }
 
 static COUNT
-GenerateSol_generateLife (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateSol_generateLife (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 2, 1))
 	{
 		/* Earth Moon */
-		GenerateRandomNodes (&solarSys->SysInfo, BIOLOGICAL_SCAN, 10,
-				NUM_CREATURE_TYPES + 1, &whichNode);
-		return whichNode;
+		return GenerateRandomNodes (&solarSys->SysInfo, BIOLOGICAL_SCAN, 10,
+				NUM_CREATURE_TYPES + 1, whichNode, info);
 	}
 
 	return 0;
diff -ruNp src.hd/uqm/planets/generate/genspa.c src/uqm/planets/generate/genspa.c
--- src.hd/uqm/planets/generate/genspa.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/generate/genspa.c	2017-12-29 00:57:48 -0800
@@ -35,10 +35,10 @@ static bool GenerateSpathi_generateMoons
 		PLANET_DESC *planet);
 static bool GenerateSpathi_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateSpathi_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static COUNT GenerateSpathi_generateLife (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateSpathi_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
+static COUNT GenerateSpathi_generateLife (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateSpathi_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 static bool GenerateSpathi_pickupLife (SOLARSYS_STATE *solarSys,
@@ -104,7 +104,7 @@ GenerateSpathi_generateMoons (SOLARSYS_S
 		solarSys->MoonDesc[0].data_index = PELLUCID_WORLD;
 		solarSys->MoonDesc[0].alternate_colormap = NULL;
 		solarSys->MoonDesc[0].radius = MIN_MOON_RADIUS + MOON_DELTA;
-		angle = NORMALIZE_ANGLE (LOWORD (TFB_Random ()));
+		angle = NORMALIZE_ANGLE (LOWORD (RandomContext_Random (SysGenRNG)));
 		solarSys->MoonDesc[0].location.x =
 				COSINE (angle, solarSys->MoonDesc[0].radius);
 		solarSys->MoonDesc[0].location.y =
@@ -119,13 +119,12 @@ static bool
 GenerateSpathi_generateOrbital (SOLARSYS_STATE *solarSys, PLANET_DESC *world)
 {
 	DWORD rand_val;
-	COUNT i;
 
 	if (matchWorld (solarSys, world, 0, 0))
 	{
 		/* Spathiwa's moon */
 		if (!GET_GAME_STATE (SPATHI_SHIELDED_SELVES)
-				&& ActivateStarShip (SPATHI_SHIP, SPHERE_TRACKING))
+				&& StartSphereTracking (SPATHI_SHIP))
 		{
 			NotifyOthers (SPATHI_SHIP, IPNL_ALL_CLEAR);
 			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
@@ -147,15 +146,16 @@ GenerateSpathi_generateOrbital (SOLARSYS
 			}
 			return true;
 		}
-		rand_val = DoPlanetaryAnalysis (&solarSys->SysInfo, world);
+		
+		DoPlanetaryAnalysis (&solarSys->SysInfo, world);
+		rand_val = RandomContext_GetSeed (SysGenRNG);
 
 		solarSys->SysInfo.PlanetInfo.ScanSeed[BIOLOGICAL_SCAN] = rand_val;
-		i = (COUNT)~0;
-		rand_val = GenerateLifeForms (&solarSys->SysInfo, &i);
+		GenerateLifeForms (&solarSys->SysInfo, GENERATE_ALL, NULL);
+		rand_val = RandomContext_GetSeed (SysGenRNG);
 
 		solarSys->SysInfo.PlanetInfo.ScanSeed[MINERAL_SCAN] = rand_val;
-		i = (COUNT)~0;
-		GenerateMineralDeposits (&solarSys->SysInfo, &i);
+		GenerateMineralDeposits (&solarSys->SysInfo, GENERATE_ALL, NULL);
 
 		solarSys->SysInfo.PlanetInfo.ScanSeed[ENERGY_SCAN] = rand_val;
 
@@ -184,18 +184,18 @@ GenerateSpathi_generateOrbital (SOLARSYS
 	else if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
 		/* visiting Spathiwa */
-		rand_val = DoPlanetaryAnalysis (&solarSys->SysInfo, world);
+		DoPlanetaryAnalysis (&solarSys->SysInfo, world);
+		rand_val = RandomContext_GetSeed (SysGenRNG);
 
 		solarSys->SysInfo.PlanetInfo.ScanSeed[MINERAL_SCAN] = rand_val;
-		i = (COUNT)~0;
-		rand_val = GenerateMineralDeposits (&solarSys->SysInfo, &i);
+		GenerateMineralDeposits (&solarSys->SysInfo, GENERATE_ALL, NULL);
+		rand_val = RandomContext_GetSeed (SysGenRNG);
 
 		solarSys->SysInfo.PlanetInfo.ScanSeed[BIOLOGICAL_SCAN] = rand_val;
 
 		solarSys->SysInfo.PlanetInfo.PlanetRadius = 120;
 		solarSys->SysInfo.PlanetInfo.SurfaceGravity =
-				CalcGravity (solarSys->SysInfo.PlanetInfo.PlanetDensity,
-				solarSys->SysInfo.PlanetInfo.PlanetRadius);
+				CalcGravity (&solarSys->SysInfo.PlanetInfo);
 		solarSys->SysInfo.PlanetInfo.Weather = 0;
 		solarSys->SysInfo.PlanetInfo.Tectonics = 0;
 		solarSys->SysInfo.PlanetInfo.SurfaceTemperature = 31;
@@ -210,8 +210,8 @@ GenerateSpathi_generateOrbital (SOLARSYS
 }
 
 static COUNT
-GenerateSpathi_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateSpathi_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 0, 0))
 	{
@@ -222,7 +222,7 @@ GenerateSpathi_generateEnergy (SOLARSYS_
 			return 0;
 		}
 
-		return GenerateDefault_generateArtifact (solarSys, whichNode);
+		return GenerateDefault_generateArtifact (solarSys, whichNode, info);
 	}
 
 	return 0;
@@ -250,15 +250,14 @@ GenerateSpathi_pickupEnergy (SOLARSYS_ST
 }
 
 static COUNT
-GenerateSpathi_generateLife (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateSpathi_generateLife (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
 		#define NUM_EVIL_ONES  32
-		GenerateRandomNodes (&solarSys->SysInfo, BIOLOGICAL_SCAN, NUM_EVIL_ONES,
-				NUM_CREATURE_TYPES, &whichNode);
-		return whichNode;
+		return GenerateRandomNodes (&solarSys->SysInfo, BIOLOGICAL_SCAN, NUM_EVIL_ONES,
+				NUM_CREATURE_TYPES, whichNode, info);
 	}
 
 	return 0;
diff -ruNp src.hd/uqm/planets/generate/gensup.c src/uqm/planets/generate/gensup.c
--- src.hd/uqm/planets/generate/gensup.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/generate/gensup.c	2017-12-29 00:57:48 -0800
@@ -31,8 +31,8 @@
 static bool GenerateSupox_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateSupox_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateSupox_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateSupox_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateSupox_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -81,7 +81,7 @@ GenerateSupox_generateOrbital (SOLARSYS_
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		if (ActivateStarShip (SUPOX_SHIP, SPHERE_TRACKING))
+		if (StartSphereTracking (SUPOX_SHIP))
 		{
 			NotifyOthers (SUPOX_SHIP, IPNL_ALL_CLEAR);
 			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
@@ -148,12 +148,12 @@ GenerateSupox_pickupEnergy (SOLARSYS_STA
 }
 
 static COUNT
-GenerateSupox_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateSupox_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
+		return GenerateDefault_generateRuins (solarSys, whichNode, info);
 	}
 
 	return 0;
diff -ruNp src.hd/uqm/planets/generate/genthrad.c src/uqm/planets/generate/genthrad.c
--- src.hd/uqm/planets/generate/genthrad.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/generate/genthrad.c	2017-12-29 00:57:48 -0800
@@ -21,20 +21,22 @@
 #include "../planets.h"
 #include "../../build.h"
 #include "../../comm.h"
-#include "../../encount.h"
+#include "../../gendef.h"
+#include "../../starmap.h"
 #include "../../globdata.h"
 #include "../../ipdisp.h"
 #include "../../nameref.h"
 #include "../../setup.h"
 #include "../../state.h"
 #include "libs/mathlib.h"
+#include "../../../options.h"
 
 
 static bool GenerateThraddash_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateThraddash_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateThraddash_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateThraddash_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateThraddash_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -99,7 +101,10 @@ GenerateThraddash_generateOrbital (SOLAR
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		if (ActivateStarShip (THRADDASH_SHIP, SPHERE_TRACKING) && (CurStarDescPtr->Index == THRADD_DEFINED || (!GET_GAME_STATE (HELIX_UNPROTECTED) && (BYTE)(GET_GAME_STATE (THRADD_MISSION) - 1) >= 3)))
+		if (StartSphereTracking (THRADDASH_SHIP)
+				&& (CurStarDescPtr->Index == THRADD_DEFINED
+				|| (!GET_GAME_STATE (HELIX_UNPROTECTED)
+				&& (BYTE)(GET_GAME_STATE (THRADD_MISSION) - 1) >= 3)))
 		{
 			NotifyOthers (THRADDASH_SHIP, IPNL_ALL_CLEAR);
 			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
@@ -132,9 +137,7 @@ GenerateThraddash_generateOrbital (SOLAR
 					&& (BYTE)(GET_GAME_STATE (THRADD_MISSION) - 1) >= 3))
 				return true;
 
-			LockMutex (GraphicsLock);
 			RepairSISBorder ();
-			UnlockMutex (GraphicsLock);
 		}
 
 		if (CurStarDescPtr->Index == AQUA_HELIX_DEFINED
@@ -161,13 +164,13 @@ GenerateThraddash_generateOrbital (SOLAR
 }
 
 static COUNT
-GenerateThraddash_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode)
+GenerateThraddash_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (CurStarDescPtr->Index == THRADD_DEFINED
 			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
+		return GenerateDefault_generateRuins (solarSys, whichNode, info);
 	}
 
 	if (CurStarDescPtr->Index == AQUA_HELIX_DEFINED
@@ -180,7 +183,7 @@ GenerateThraddash_generateEnergy (SOLARS
 			return 0;
 		}
 
-		return GenerateDefault_generateArtifact (solarSys, whichNode);
+		return GenerateDefault_generateArtifact (solarSys, whichNode, info);
 	}
 
 	return 0;
@@ -214,9 +217,9 @@ GenerateThraddash_pickupEnergy (SOLARSYS
 		SET_GAME_STATE (AQUA_HELIX, 1);
 		SET_GAME_STATE (AQUA_HELIX_ON_SHIP, 1);
 		SET_GAME_STATE (HELIX_UNPROTECTED, 1);
-		if (GET_GAME_STATE (ILWRATH_FIGHT_THRADDASH)){
-			ActivateStarShip (THRADDASH_SHIP, SET_NOT_ALLIED);
-			ActivateStarShip (THRADDASH_SHIP, REMOVE_BUILT);
+		if (GET_GAME_STATE (ILWRATH_FIGHT_THRADDASH) && optThraddStory){
+			SetRaceAllied (THRADDASH_SHIP, FALSE);
+			RemoveEscortShips (THRADDASH_SHIP);
 			strength_loss = (SIZE)(ThraddPtr->actual_strength);
 			ThraddPtr->growth = (BYTE)(-strength_loss / ThraddPtr->days_left);
 			ThraddPtr->growth_fract = (BYTE)(((strength_loss % ThraddPtr->days_left) << 8) / ThraddPtr->days_left);
diff -ruNp src.hd/uqm/planets/generate/genutw.c src/uqm/planets/generate/genutw.c
--- src.hd/uqm/planets/generate/genutw.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/generate/genutw.c	2017-12-29 00:57:48 -0800
@@ -21,7 +21,8 @@
 #include "../planets.h"
 #include "../../build.h"
 #include "../../comm.h"
-#include "../../encount.h"
+#include "../../gendef.h"
+#include "../../starmap.h"
 #include "../../globdata.h"
 #include "../../ipdisp.h"
 #include "../../nameref.h"
@@ -34,8 +35,8 @@ static bool GenerateUtwig_initNpcs (SOLA
 static bool GenerateUtwig_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateUtwig_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateUtwig_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateUtwig_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateUtwig_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -110,7 +111,7 @@ GenerateUtwig_generateOrbital (SOLARSYS_
 	{
 		if ((CurStarDescPtr->Index == UTWIG_DEFINED
 				|| !GET_GAME_STATE (UTWIG_HAVE_ULTRON))
-				&& ActivateStarShip (UTWIG_SHIP, SPHERE_TRACKING))
+				&& StartSphereTracking (UTWIG_SHIP))
 		{
 			NotifyOthers (UTWIG_SHIP, IPNL_ALL_CLEAR);
 			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
@@ -142,7 +143,7 @@ GenerateUtwig_generateOrbital (SOLARSYS_
 
 		if (CurStarDescPtr->Index == BOMB_DEFINED
 				&& !GET_GAME_STATE (BOMB_UNPROTECTED)
-				&& ActivateStarShip (DRUUGE_SHIP, SPHERE_TRACKING))
+				&& StartSphereTracking (DRUUGE_SHIP))
 		{
 			COUNT i;
 
@@ -175,9 +176,7 @@ GenerateUtwig_generateOrbital (SOLARSYS_
 				if (DruugeSurvivors)
 					return true;
 
-				LockMutex (GraphicsLock);
 				RepairSISBorder ();
-				UnlockMutex (GraphicsLock);
 				SET_GAME_STATE (BOMB_UNPROTECTED, 1);
 			}
 		}
@@ -213,13 +212,13 @@ GenerateUtwig_generateOrbital (SOLARSYS_
 }
 
 static COUNT
-GenerateUtwig_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateUtwig_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (CurStarDescPtr->Index == UTWIG_DEFINED
 			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
+		return GenerateDefault_generateRuins (solarSys, whichNode, info);
 	}
 
 	if (CurStarDescPtr->Index == BOMB_DEFINED
@@ -232,7 +231,7 @@ GenerateUtwig_generateEnergy (SOLARSYS_S
 			return 0;
 		}
 
-		return GenerateDefault_generateArtifact (solarSys, whichNode);
+		return GenerateDefault_generateArtifact (solarSys, whichNode, info);
 	}
 
 	return 0;
diff -ruNp src.hd/uqm/planets/generate/genvault.c src/uqm/planets/generate/genvault.c
--- src.hd/uqm/planets/generate/genvault.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/generate/genvault.c	2017-12-29 00:57:48 -0800
@@ -27,8 +27,8 @@
 
 static bool GenerateVault_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateVault_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateVault_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateVault_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -79,12 +79,12 @@ GenerateVault_generateOrbital (SOLARSYS_
 }
 
 static COUNT
-GenerateVault_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateVault_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 0, 0))
 	{
-		return GenerateDefault_generateArtifact (solarSys, whichNode);
+		return GenerateDefault_generateArtifact (solarSys, whichNode, info);
 	}
 
 	return 0;
diff -ruNp src.hd/uqm/planets/generate/genvux.c src/uqm/planets/generate/genvux.c
--- src.hd/uqm/planets/generate/genvux.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/generate/genvux.c	2017-12-29 00:57:48 -0800
@@ -22,7 +22,8 @@
 #include "../planets.h"
 #include "../../build.h"
 #include "../../comm.h"
-#include "../../encount.h"
+#include "../../gendef.h"
+#include "../../starmap.h"
 #include "../../globdata.h"
 #include "../../ipdisp.h"
 #include "../../nameref.h"
@@ -35,10 +36,10 @@
 static bool GenerateVux_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateVux_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateVux_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static COUNT GenerateVux_generateLife (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateVux_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
+static COUNT GenerateVux_generateLife (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateVux_pickupEnergy (SOLARSYS_STATE *, PLANET_DESC *world,
 		COUNT whichNode);
 static bool GenerateVux_pickupLife (SOLARSYS_STATE *, PLANET_DESC *world,
@@ -130,7 +131,7 @@ GenerateVux_generateOrbital (SOLARSYS_ST
 			&& (CurStarDescPtr->Index == VUX_DEFINED
 			|| (CurStarDescPtr->Index == MAIDENS_DEFINED
 			&& !GET_GAME_STATE (ZEX_IS_DEAD))))
-			&& ActivateStarShip (VUX_SHIP, SPHERE_TRACKING))
+			&& StartSphereTracking (VUX_SHIP))
 	{
 		NotifyOthers (VUX_SHIP, IPNL_ALL_CLEAR);
 		PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
@@ -163,9 +164,7 @@ GenerateVux_generateOrbital (SOLARSYS_ST
 					|| !GET_GAME_STATE (ZEX_IS_DEAD))
 				return true;
 
-			LockMutex (GraphicsLock);
 			RepairSISBorder ();
-			UnlockMutex (GraphicsLock);
 		}
 	}
 
@@ -216,8 +215,8 @@ GenerateVux_generateOrbital (SOLARSYS_ST
 }
 
 static COUNT
-GenerateVux_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateVux_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (CurStarDescPtr->Index == MAIDENS_DEFINED
 			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
@@ -229,8 +228,11 @@ GenerateVux_generateEnergy (SOLARSYS_STA
 			return 0;
 		}
 
-		solarSys->SysInfo.PlanetInfo.CurPt.x = MAP_WIDTH / 3;
-		solarSys->SysInfo.PlanetInfo.CurPt.y = MAP_HEIGHT * 5 / 8;
+		if (info)
+		{
+			info->loc_pt.x = MAP_WIDTH / 3;
+			info->loc_pt.y = MAP_HEIGHT * 5 / 8;
+		}
 		
 		return 1; // only matters when count is requested
 	}
@@ -238,7 +240,7 @@ GenerateVux_generateEnergy (SOLARSYS_STA
 	if (CurStarDescPtr->Index == VUX_DEFINED
 			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
+		return GenerateDefault_generateRuins (solarSys, whichNode, info);
 	}
 
 	return 0;
@@ -275,62 +277,37 @@ GenerateVux_pickupEnergy (SOLARSYS_STATE
 }
 
 static COUNT
-GenerateVux_generateLife (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateVux_generateLife (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (CurStarDescPtr->Index == MAIDENS_DEFINED
 			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		COUNT i;
-		DWORD old_rand;
-
-		old_rand = TFB_SeedRandom (
-				solarSys->SysInfo.PlanetInfo.ScanSeed[BIOLOGICAL_SCAN]);
-
-		for (i = 0; i <= whichNode && i < 12; ++i)
+		static const SBYTE life[] =
 		{
-			GenerateRandomLocation (&solarSys->SysInfo);
-			if (i < 4)
-				solarSys->SysInfo.PlanetInfo.CurType = 9;
-			else if (i < 8)
-				solarSys->SysInfo.PlanetInfo.CurType = 14;
-			else /* if (i < 12) */
-				solarSys->SysInfo.PlanetInfo.CurType = 18;
-		}
-		
-		TFB_SeedRandom (old_rand);
-
-		return 12; // only matters when count is requested
+			 9,  9,  9,  9, /* Carousel Beast */
+			14, 14, 14, 14, /* Amorphous Trandicula */
+			18, 18, 18, 18, /* Penguin Cyclops */
+			-1 /* term */
+		};
+		return GeneratePresetLife (&solarSys->SysInfo, life, whichNode, info);
 	}
 
 	if (CurStarDescPtr->Index == VUX_BEAST_DEFINED
 			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		COUNT i;
-		DWORD old_rand;
-
-		old_rand = TFB_SeedRandom (
-				solarSys->SysInfo.PlanetInfo.ScanSeed[BIOLOGICAL_SCAN]);
-
-		for (i = 0; i <= whichNode && i < 11; ++i)
+		static const SBYTE life[] =
 		{
-			GenerateRandomLocation (&solarSys->SysInfo);
-			if (i == 0) /* VUX Beast */
-				solarSys->SysInfo.PlanetInfo.CurType = NUM_CREATURE_TYPES + 2;
-			else if (i <= 5)
-					/* {SPEED_MOTIONLESS | DANGER_NORMAL, MAKE_BYTE (5, 3)}, */
-				solarSys->SysInfo.PlanetInfo.CurType = 3;
-			else /* if (i <= 10) */
-					/* {BEHAVIOR_UNPREDICTABLE | SPEED_SLOW | DANGER_NORMAL, MAKE_BYTE (3, 8)}, */
-				solarSys->SysInfo.PlanetInfo.CurType = 8;
-		}
-		
-		TFB_SeedRandom (old_rand);
-
-		return  11; // only matters when count is requested
+			NUM_CREATURE_TYPES + 2, /* VUX Beast */
+					// Must be the first node, see pickupLife() below
+			3, 3, 3, 3, 3, /* Whackin' Bush */
+			8, 8, 8, 8, 8, /* Glowing Medusa */
+			-1 /* term */
+		};
+		return GeneratePresetLife (&solarSys->SysInfo, life, whichNode, info);
 	}
 
-	return GenerateDefault_generateLife (solarSys, world, whichNode);
+	return GenerateDefault_generateLife (solarSys, world, whichNode, info);
 }
 
 static bool
diff -ruNp src.hd/uqm/planets/generate/genwreck.c src/uqm/planets/generate/genwreck.c
--- src.hd/uqm/planets/generate/genwreck.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/generate/genwreck.c	2017-12-29 00:57:48 -0800
@@ -27,8 +27,8 @@
 
 static bool GenerateWreck_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateWreck_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateWreck_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateWreck_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -73,12 +73,12 @@ GenerateWreck_generateOrbital (SOLARSYS_
 }
 
 static COUNT
-GenerateWreck_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateWreck_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 6, MATCH_PLANET))
 	{
-		return GenerateDefault_generateArtifact (solarSys, whichNode);
+		return GenerateDefault_generateArtifact (solarSys, whichNode, info);
 	}
 
 	return 0;
diff -ruNp src.hd/uqm/planets/generate/genyeh.c src/uqm/planets/generate/genyeh.c
--- src.hd/uqm/planets/generate/genyeh.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/generate/genyeh.c	2017-12-29 00:57:48 -0800
@@ -30,8 +30,8 @@
 static bool GenerateYehat_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateYehat_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateYehat_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateYehat_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateYehat_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -78,7 +78,7 @@ GenerateYehat_generateOrbital (SOLARSYS_
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		if (ActivateStarShip (YEHAT_SHIP, SPHERE_TRACKING))
+		if (StartSphereTracking (YEHAT_SHIP))
 		{
 			NotifyOthers (YEHAT_SHIP, IPNL_ALL_CLEAR);
 			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
@@ -114,12 +114,12 @@ GenerateYehat_generateOrbital (SOLARSYS_
 }
 
 static COUNT
-GenerateYehat_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateYehat_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
+		return GenerateDefault_generateRuins (solarSys, whichNode, info);
 	}
 
 	return 0;
diff -ruNp src.hd/uqm/planets/generate/genzfpscout.c src/uqm/planets/generate/genzfpscout.c
--- src.hd/uqm/planets/generate/genzfpscout.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/generate/genzfpscout.c	2017-12-29 00:57:48 -0800
@@ -49,14 +49,14 @@ GenerateZoqFotPikScout_initNpcs (SOLARSY
 {
 	if (!GET_GAME_STATE (MET_ZOQFOT))
 	{
-		GLOBAL (BattleGroupRef) = GET_GAME_STATE_32 (ZOQFOT_GRPOFFS0);
+		GLOBAL (BattleGroupRef) = GET_GAME_STATE (ZOQFOT_GRPOFFS);
 		if (GLOBAL (BattleGroupRef) == 0)
 		{
 			CloneShipFragment (ZOQFOTPIK_SHIP,
 					&GLOBAL (npc_built_ship_q), 0);
 			GLOBAL (BattleGroupRef) = PutGroupInfo (GROUPS_ADD_NEW, 1);
 			ReinitQueue (&GLOBAL (npc_built_ship_q));
-			SET_GAME_STATE_32 (ZOQFOT_GRPOFFS0, GLOBAL (BattleGroupRef));
+			SET_GAME_STATE (ZOQFOT_GRPOFFS, GLOBAL (BattleGroupRef));
 		}
 	}
 
diff -ruNp src.hd/uqm/planets/generate/genzoq.c src/uqm/planets/generate/genzoq.c
--- src.hd/uqm/planets/generate/genzoq.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/generate/genzoq.c	2017-12-29 00:57:48 -0800
@@ -30,8 +30,8 @@ static bool GenerateZoqFotPik_initNpcs (
 static bool GenerateZoqFotPik_generatePlanets (SOLARSYS_STATE *solarSys);
 static bool GenerateZoqFotPik_generateOrbital (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-static COUNT GenerateZoqFotPik_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateZoqFotPik_generateEnergy (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 static bool GenerateZoqFotPik_pickupEnergy (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT whichNode);
 
@@ -89,7 +89,7 @@ GenerateZoqFotPik_generateOrbital (SOLAR
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		if (ActivateStarShip (ZOQFOTPIK_SHIP, SPHERE_TRACKING))
+		if (StartSphereTracking (ZOQFOTPIK_SHIP))
 		{
 			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
 			ReinitQueue (&GLOBAL (ip_group_q));
@@ -145,12 +145,12 @@ GenerateZoqFotPik_generateOrbital (SOLAR
 }
 
 static COUNT
-GenerateZoqFotPik_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
+GenerateZoqFotPik_generateEnergy (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *info)
 {
 	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
+		return GenerateDefault_generateRuins (solarSys, whichNode, info);
 	}
 
 	return 0;
diff -ruNp src.hd/uqm/planets/generate/genzoqcolony.c src/uqm/planets/generate/genzoqcolony.c
--- src.hd/uqm/planets/generate/genzoqcolony.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/generate/genzoqcolony.c	1969-12-31 16:00:00 -0800
@@ -1,190 +0,0 @@
-//Copyright Paul Reiche, Fred Ford. 1992-2002
-
-/*
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include "genall.h"
-#include "../planets.h"
-#include "../../build.h"
-#include "../../comm.h"
-#include "../../globdata.h"
-#include "../../nameref.h"
-#include "../../state.h"
-#include "libs/mathlib.h"
-
-static bool GenerateZoqColony0_generatePlanets (SOLARSYS_STATE *solarSys);
-static bool GenerateZoqColony0_generateOrbital (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world);
-static bool GenerateZoqColony1_generateOrbital (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world);
-static COUNT GenerateZoqColony0_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static COUNT GenerateZoqColony1_generateEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static bool GenerateZoqColony0_pickupEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-static bool GenerateZoqColony1_pickupEnergy (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-
-
-const GenerateFunctions generateZoqFotPikColony0Functions = {
-	/* .initNpcs         = */ GenerateDefault_initNpcs,
-	/* .reinitNpcs       = */ GenerateDefault_reinitNpcs,
-	/* .uninitNpcs       = */ GenerateDefault_uninitNpcs,
-	/* .generatePlanets  = */ GenerateZoqColony0_generatePlanets,
-	/* .generateMoons    = */ GenerateDefault_generateMoons,
-	/* .generateName     = */ GenerateDefault_generateName,
-	/* .generateOrbital  = */ GenerateZoqColony0_generateOrbital,
-	/* .generateMinerals = */ GenerateDefault_generateMinerals,
-	/* .generateEnergy   = */ GenerateZoqColony0_generateEnergy,
-	/* .generateLife     = */ GenerateDefault_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GenerateZoqColony0_pickupEnergy,
-	/* .pickupLife       = */ GenerateDefault_pickupLife,
-};
-
-const GenerateFunctions generateZoqFotPikColony1Functions = {
-	/* .initNpcs         = */ GenerateDefault_initNpcs,
-	/* .reinitNpcs       = */ GenerateDefault_reinitNpcs,
-	/* .uninitNpcs       = */ GenerateDefault_uninitNpcs,
-	/* .generatePlanets  = */ GenerateDefault_generatePlanets,
-	/* .generateMoons    = */ GenerateDefault_generateMoons,
-	/* .generateName     = */ GenerateDefault_generateName,
-	/* .generateOrbital  = */ GenerateZoqColony1_generateOrbital,
-	/* .generateMinerals = */ GenerateDefault_generateMinerals,
-	/* .generateEnergy   = */ GenerateZoqColony1_generateEnergy,
-	/* .generateLife     = */ GenerateDefault_generateLife,
-	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
-	/* .pickupEnergy     = */ GenerateZoqColony1_pickupEnergy,
-	/* .pickupLife       = */ GenerateDefault_pickupLife,
-};
-
-static bool
-GenerateZoqColony0_generatePlanets (SOLARSYS_STATE *solarSys)
-{
-	COUNT angle;
-
-	GenerateDefault_generatePlanets (solarSys);
-
-	solarSys->PlanetDesc[0].data_index = REDUX_WORLD;
-	solarSys->PlanetDesc[0].NumPlanets = 0;
-	solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 125L / 100;
-	angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
-			solarSys->PlanetDesc[0].location.y);
-	solarSys->PlanetDesc[0].location.x =
-			COSINE (angle, solarSys->PlanetDesc[0].radius);
-	solarSys->PlanetDesc[0].location.y =
-			SINE (angle, solarSys->PlanetDesc[0].radius);
-	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
-
-	return true;
-}
-
-static bool
-GenerateZoqColony0_generateOrbital (SOLARSYS_STATE *solarSys, PLANET_DESC *world)
-{
-	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
-	{
-		LoadStdLanderFont (&solarSys->SysInfo.PlanetInfo);
-		solarSys->PlanetSideFrame[1] =
-				CaptureDrawable (LoadGraphic (RUINS_MASK_PMAP_ANIM));
-		
-		if ((GET_GAME_STATE(MET_ZOQFOT)) == 1)
-			solarSys->SysInfo.PlanetInfo.DiscoveryString =
-				CaptureStringTable (LoadStringTable (ZOQCOLONY_RUINS2_STRTAB));
-		else
-			solarSys->SysInfo.PlanetInfo.DiscoveryString =
-				CaptureStringTable (LoadStringTable (ZOQCOLONY_RUINS1_STRTAB));
-	}
-
-	GenerateDefault_generateOrbital (solarSys, world);
-	return true;
-}
-
-static bool
-GenerateZoqColony1_generateOrbital (SOLARSYS_STATE *solarSys, PLANET_DESC *world)
-{
-	if (matchWorld (solarSys, world, 0, 1))
-	{
-		LoadStdLanderFont (&solarSys->SysInfo.PlanetInfo);
-		solarSys->PlanetSideFrame[1] =
-			CaptureDrawable (LoadGraphic (RUINS_MASK_PMAP_ANIM));
-		
-		if ((GET_GAME_STATE(MET_ZOQFOT)) == 1)
-			solarSys->SysInfo.PlanetInfo.DiscoveryString =
-			CaptureStringTable (LoadStringTable (ZOQCOLONY_RUINS2_STRTAB));
-		else
-			solarSys->SysInfo.PlanetInfo.DiscoveryString =
-			CaptureStringTable (LoadStringTable (ZOQCOLONY_RUINS1_STRTAB));
-	}
-	
-	GenerateDefault_generateOrbital (solarSys, world);
-	return true;
-}
-
-static COUNT
-GenerateZoqColony0_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
-{
-	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
-	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
-	}
-
-	return 0;
-}
-
-static COUNT
-GenerateZoqColony1_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-								   COUNT whichNode)
-{
-	if (matchWorld (solarSys, world, 0, 1))
-	{
-		return GenerateDefault_generateRuins (solarSys, whichNode);
-	}
-	
-	return 0;
-}
-
-static bool
-GenerateZoqColony0_pickupEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT whichNode)
-{
-	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
-	{
-		// Standard ruins report
-		GenerateDefault_landerReportCycle (solarSys);
-		return false;
-	}
-
-	(void) whichNode;
-	return false;
-}
-
-static bool
-GenerateZoqColony1_pickupEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-								 COUNT whichNode)
-{
-	if (matchWorld (solarSys, world, 0, 1))
-	{
-		// Standard ruins report
-		GenerateDefault_landerReportCycle (solarSys);
-		return false;
-	}
-	
-	(void) whichNode;
-	return false;
-}
diff -ruNp src.hd/uqm/planets/generate.h src/uqm/planets/generate.h
--- src.hd/uqm/planets/generate.h	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/generate.h	2017-12-29 00:57:49 -0800
@@ -23,6 +23,10 @@ typedef struct GenerateFunctions Generat
 #include "planets.h"
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 /*
  * To do (for further cleanups):
  * - split off generateOrbital in a calculation and an activation
@@ -52,16 +56,16 @@ typedef bool (*GenerateMoonsFunction)(SO
 		PLANET_DESC *planet);
 typedef bool (*GenerateOrbitalFunction)(SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world);
-typedef bool (*GenerateNameFunction)(SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world);
+typedef bool (*GenerateNameFunction)(const SOLARSYS_STATE *,
+		const PLANET_DESC *world);
 // The following functions return the number of objects being generated
 // (or the index of the current object in some cases)
-typedef COUNT (*GenerateMineralsFunction)(SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-typedef COUNT (*GenerateEnergyFunction)(SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
-typedef COUNT (*GenerateLifeFunction)(SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT whichNode);
+typedef COUNT (*GenerateMineralsFunction)(const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
+typedef COUNT (*GenerateEnergyFunction)(const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
+typedef COUNT (*GenerateLifeFunction)(const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT whichNode, NODE_INFO *);
 // The following functions return true if the node should be removed
 // from the surface, i.e. picked up.
 typedef bool (*PickupMineralsFunction)(SOLARSYS_STATE *solarSys,
@@ -98,6 +102,9 @@ struct GenerateFunctions {
 	PickupLifeFunction pickupLife;
 };
 
+#if defined(__cplusplus)
+}
+#endif
 
 #endif  /* GENERATE_H */
 
diff -ruNp src.hd/uqm/planets/gentopo.c src/uqm/planets/gentopo.c
--- src.hd/uqm/planets/gentopo.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/gentopo.c	2017-12-29 00:57:49 -0800
@@ -18,8 +18,6 @@
 
 // See doc/devel/planettopo for details.
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "libs/gfxlib.h"
 #include "libs/mathlib.h"
 #include "planets.h"
@@ -45,21 +43,21 @@ DeltaTopography (COUNT num_iterations, S
 		DWORD rand_val;
 		SBYTE *lpDst;
 
-		depth_delta = ((((SIZE)TFB_Random () & 1) << 1) - 1) * depth_delta;
+		if ((RandomContext_Random (SysGenRNG) & 1) == 0)
+			depth_delta = -depth_delta;
 
-		rand_val = TFB_Random ();
+		rand_val = RandomContext_Random (SysGenRNG);
 		w1 = LOWORD (rand_val);
 		w2 = HIWORD (rand_val);
 
 		LineDDA0.x_top = (LOBYTE (w1) % ORIGINAL_MAP_WIDTH) * width / ORIGINAL_MAP_WIDTH;
 		LineDDA0.x_bot = (HIBYTE (w1) % ORIGINAL_MAP_WIDTH) * width / ORIGINAL_MAP_WIDTH;
-		
 		//LineDDA0.x_top = w1 % width; // JMS_GFX: Replaced previous lines with these: BYTE is too small for 640x480 sized maps.
 		//LineDDA0.x_bot = w2 % width; // Using w1 and w2 to get difference between top and bottom.
 		// BW: reinstate previous method and adapt it for higher res.
 		// Overusing w1 and w2 was hampering randomness.
 		// Now planets will look the same no matter what the res is.
-		
+
 		LineDDA0.delta_x = (LineDDA0.x_bot - LineDDA0.x_top) << 1;
 		if (LineDDA0.delta_x >= 0)
 			LineDDA0.x_incr = 1;
@@ -75,12 +73,6 @@ DeltaTopography (COUNT num_iterations, S
 
 		LineDDA1.x_top = (LOBYTE (w2) % (ORIGINAL_MAP_WIDTH - 1)) * width / ORIGINAL_MAP_WIDTH + LineDDA0.x_top + 1;
 		LineDDA1.x_bot = (HIBYTE (w2) % (ORIGINAL_MAP_WIDTH - 1)) * width / ORIGINAL_MAP_WIDTH + LineDDA0.x_bot + 1;
-		
-		// JMS_GFX: Replaced previous lines with these: BYTE is too small for 640x480 sized maps.
-		// LineDDA1.x_top = (w2 % (width - 1)) + LineDDA0.x_top + 1;
-		// LineDDA1.x_bot = (w1 % (width - 1)) + LineDDA0.x_bot + 1;
-		// BW: the same as above
-		
 		LineDDA1.delta_x = (LineDDA1.x_bot - LineDDA1.x_top) << 1;
 		if (LineDDA1.delta_x >= 0)
 			LineDDA1.x_incr = 1;
@@ -100,8 +92,6 @@ DeltaTopography (COUNT num_iterations, S
 		{
 			COUNT w;
 
-			// Add depth_delta between DDA0.x_top and DDA1.x_top
-			// wrapping around if needed
 			w1 = LineDDA1.x_top - LineDDA0.x_top;
 			w2 = width - w1;
 
@@ -141,8 +131,6 @@ DeltaTopography (COUNT num_iterations, S
 				} while (--w1);
 			}
 
-			// Substract depth_delta between DDA0.x_top and
-			//  DDA1.x_top wrapping around if needed
 			if ((int)(LineDDA0.x_top + w2) > (int)width)
 				w = width - LineDDA0.x_top;
 			else
@@ -179,8 +167,6 @@ DeltaTopography (COUNT num_iterations, S
 				} while (--w2);
 			}
 
-			// Prepare next line
-			// slowly shifting to x_bot values
 			lpDst += pRect->extent.width;
 
 			if (delta_y >= LineDDA0.delta_x)
diff -ruNp src.hd/uqm/planets/lander.c src/uqm/planets/lander.c
--- src.hd/uqm/planets/lander.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/lander.c	2017-12-29 00:57:49 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "lander.h"
 
 #include "lifeform.h"
@@ -25,8 +23,6 @@
 #include "../cons_res.h"
 #include "../controls.h"
 #include "../colors.h"
-// XXX: for CurStarDescPtr and XXX_DEFINED
-#include "../encount.h"
 #include "../process.h"
 #include "../units.h"
 #include "../gamestr.h"
@@ -35,11 +31,11 @@
 #include "../setup.h"
 #include "../sounds.h"
 #include "../element.h"
-#include "options.h" // JMS: For optMineralSubmenu
 #include "libs/graphics/gfx_common.h"
 #include "libs/mathlib.h"
 #include "libs/log.h"
-
+#include "options.h"
+#include "uqm/menustat.h"
 
 //define SPIN_ON_LAUNCH to let the planet spin while
 // the lander animation is playing
@@ -66,12 +62,8 @@ struct LanderInputState {
 };
 
 FRAME LanderFrame[8];
-FRAME SubmenuMineralsFrame; // JMS
-
 static SOUND LanderSounds;
 MUSIC_REF LanderMusic;
-#define NUM_ORBIT_THEMES 5
-static MUSIC_REF OrbitMusic[NUM_ORBIT_THEMES];
 
 const LIFEFORM_DESC CreatureData[] =
 {
@@ -121,10 +113,9 @@ const LIFEFORM_DESC CreatureData[] =
 			// Bug-Eyed Bait
 	{SPEED_MOTIONLESS | DANGER_WEAK, MAKE_BYTE (8, 5)},
 			// Goo Burger
-
 	{SPEED_MOTIONLESS | DANGER_MONSTROUS, MAKE_BYTE (1, 1)},
 			// Evil One
-	{BEHAVIOR_UNPREDICTABLE | SPEED_SLOW | DANGER_HARMLESS, MAKE_BYTE (1, 1)},
+	{BEHAVIOR_UNPREDICTABLE | SPEED_SLOW | DANGER_HARMLESS, MAKE_BYTE (1, 1)}, // ? was 0, 1
 			// Brainbox Bulldozers
 	{BEHAVIOR_HUNT | AWARENESS_HIGH | SPEED_FAST | DANGER_MONSTROUS, MAKE_BYTE (15, 15)},
 			// Zex's Beauty
@@ -270,10 +261,8 @@ object_animation (ELEMENT *ElementPtr)
 			else if (ElementPtr->mass_points == EARTHQUAKE_DISASTER)
 			{
 				SIZE s;
-				SIZE frame_amount; // JMS_GFX
+				SIZE frame_amount = 14; // JMS_GFX
 
-				frame_amount = 14;
-				
 				if (frame_index >= (frame_amount-1))
 					s = 0;
 				else
@@ -283,7 +272,7 @@ object_animation (ELEMENT *ElementPtr)
 				SetPrimColor (pPrim, BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x1F), s));
 				if (frame_index == (frame_amount - 1))
 					PlaySound (SetAbsSoundIndex (LanderSounds, EARTHQUAKE_DISASTER),
-							   NotPositional (), NULL, GAME_SOUND_PRIORITY);
+							NotPositional (), NULL, GAME_SOUND_PRIORITY);
 			}
 			
 			if (ElementPtr->mass_points == LAVASPOT_DISASTER
@@ -462,8 +451,12 @@ DeltaLanderCrew (SIZE crew_delta, COUNT
 		shieldHit &= 1 << which_disaster;
 		if (!shieldHit || TFB_Random () % 100 >= 95)
 		{	// No shield, or it did not help
-			if (!optGodMode){ shieldHit=0; --crew_left; }
-			else { shieldHit=1; }
+			if (!optGodMode) {
+				shieldHit = 0; 
+				--crew_left; 
+			}
+			else 
+				shieldHit = 1; 
 		}
 
 		damage_index = DAMAGE_CYCLE;
@@ -477,18 +470,13 @@ DeltaLanderCrew (SIZE crew_delta, COUNT
 				NotPositional (), NULL, GAME_SOUND_PRIORITY);
 	}
 
-	if (RESOLUTION_FACTOR == 0)
-	{
+	if (RESOLUTION_FACTOR == 0) {
 		s.origin.x = ((11 + ((6 << RESOLUTION_FACTOR) * (crew_delta % NUM_CREW_COLS)))); // JMS_GFX
 		s.origin.y = (35 - (6 * (crew_delta / NUM_CREW_COLS))) << RESOLUTION_FACTOR; // JMS_GFX
-	}
-	else if (RESOLUTION_FACTOR == 1)
-	{
+	} else if (RESOLUTION_FACTOR == 1) {
 		s.origin.x = ((23 + ((6 << RESOLUTION_FACTOR) * (crew_delta % NUM_CREW_COLS)))); // JMS_GFX
 		s.origin.y = 1 + ((35 - (6 * (crew_delta / NUM_CREW_COLS))) << RESOLUTION_FACTOR); // JMS_GFX
-	}
-	else
-	{
+	} else {
 		s.origin.x = 32 + ((9 * RESOLUTION_FACTOR) * (crew_delta % NUM_CREW_COLS)); // JMS_GFX
 		s.origin.y = (52 * RESOLUTION_FACTOR - (9 * RESOLUTION_FACTOR * (crew_delta / NUM_CREW_COLS))); // JMS_GFX
 	}
@@ -501,7 +489,7 @@ DeltaLanderCrew (SIZE crew_delta, COUNT
 static void
 FillLanderHold (PLANETSIDE_DESC *pPSD, COUNT scan, COUNT NumRetrieved)
 {
-	COUNT start_count;
+	COUNT start_count, tmpholdint;
 	STAMP s;
 	CONTEXT OldContext;
 	SIZE  rounding_error_startcount = 0; // JMS_GFX
@@ -517,22 +505,24 @@ FillLanderHold (PLANETSIDE_DESC *pPSD, C
 		s.frame = SetAbsFrameIndex (LanderFrame[0], 41);
 
 		pPSD->BiologicalLevel += NumRetrieved;
-	}
-	else
-	{
+	} else {
 		start_count = pPSD->ElementLevel;
 		pPSD->ElementLevel += NumRetrieved;
-		
+
 		rounding_error_startcount = (start_count % 2);
 		rounding_error_numretrieved = (pPSD->ElementLevel % 2);
-		
+
 		if (GET_GAME_STATE (IMPROVED_LANDER_CARGO))
 			NumRetrieved = (pPSD->ElementLevel >> 1) - (start_count >> 1);
 
 		s.frame = SetAbsFrameIndex (LanderFrame[0], 43);
 	}
-	
-	//log_add(log_Warning, "sc %d, ellevel %d, numr %d, ", start_count, scan == BIOLOGICAL_SCAN ? pPSD->BiologicalLevel : pPSD->ElementLevel, NumRetrieved);
+
+	tmpholdint = ((start_count + NumRetrieved) * MAX_HOLD_BARS / MAX_SCROUNGED)
+			- ((start_count * MAX_HOLD_BARS / MAX_SCROUNGED) + (NumRetrieved *
+			MAX_HOLD_BARS / MAX_SCROUNGED));
+	start_count = start_count * MAX_HOLD_BARS / MAX_SCROUNGED;
+	NumRetrieved = (NumRetrieved * MAX_HOLD_BARS / MAX_SCROUNGED) + tmpholdint;
 
 	start_count *= RES_STAT_SCALE(1); // JMS_GFX
 	
@@ -544,13 +534,13 @@ FillLanderHold (PLANETSIDE_DESC *pPSD, C
 		if (RESOLUTION_FACTOR == 1)
 			start_count += rounding_error_startcount;
 	}
-	
+
 	s.origin.x = 0;
-	s.origin.y =  -(int)start_count + RESOLUTION_FACTOR; // JMS_GFX
+	s.origin.y = -(int)start_count;
 	if (!(start_count & 1))
 		s.frame = IncFrameIndex (s.frame);
 
-	OldContext = SetContext (RadarContext);
+	OldContext = SetContext (RadarContext);	
 	
 	// JMS_GFX
 	if (scan == MINERAL_SCAN && GET_GAME_STATE (IMPROVED_LANDER_CARGO) && RESOLUTION_FACTOR > 0)
@@ -561,9 +551,7 @@ FillLanderHold (PLANETSIDE_DESC *pPSD, C
 		if (RESOLUTION_FACTOR == 1)
 			NumRetrieved += rounding_error_numretrieved;
 	}
-		
-	//log_add(log_Warning, "SCALED: sc %d, ellevel %d, numr %d, ", start_count, scan == BIOLOGICAL_SCAN ? pPSD->BiologicalLevel : pPSD->ElementLevel, NumRetrieved);
-	
+
 	while (NumRetrieved--)
 	{
 		if (start_count++ & 1)
@@ -578,96 +566,106 @@ FillLanderHold (PLANETSIDE_DESC *pPSD, C
 
 // returns true iff the node was picked up.
 static bool
-pickupMineralNode (PLANETSIDE_DESC *pPSD, COUNT NumRetrieved,
+pickupNode (PLANETSIDE_DESC *pPSD, COUNT NumRetrieved,
 		ELEMENT *ElementPtr, const INTERSECT_CONTROL *LanderControl,
-		const INTERSECT_CONTROL *ElementControl)
+		const INTERSECT_CONTROL *ElementControl, COUNT Scan)
 {
 	BYTE EType;
-	UNICODE ch;
-	UNICODE *pStr;
-	
+	UNICODE ch, *pStr;
+	COUNT *Amount, Max, Offset;
+	BOOLEAN PartialPickup;
+
+	Amount = &pPSD->BiologicalLevel;
+	Max = MAX_SCROUNGED;
+	EType = ElementPtr->thrust_wait;
+	Offset = BIOLOGICAL_STRING_BASE;
+
+	if (Scan != BIOLOGICAL_SCAN){
+		Amount = &pPSD->ElementLevel;
+		Max = pPSD->MaxElementLevel;
+		EType = ElementPtr->turn_wait;
+		Offset = ELEMENTS_STRING_BASE;
+	}
+
 	// JMS: The rest of partially scavenged minerals stay on the surface.
-	bool partialPickup = false;
+	PartialPickup = FALSE;
 
-	if (pPSD->ElementLevel >= pPSD->MaxElementLevel)
-	{
+	if (*Amount >= Max) {
 		// Lander full
 		PlaySound (SetAbsSoundIndex (LanderSounds, LANDER_FULL),
 				NotPositional (), NULL, GAME_SOUND_PRIORITY);
 		return false;
 	}
 
-	if (pPSD->ElementLevel + NumRetrieved > pPSD->MaxElementLevel)
-	{
+	if (*Amount + NumRetrieved > Max) {
 		SIZE which_node;
 		COUNT oldsize = ElementPtr->mass_points;
-		
+
 		// Deposit could only be picked up partially.
-		NumRetrieved = (COUNT)(pPSD->MaxElementLevel - pPSD->ElementLevel);
-		
-		// JMS: Subtract the scavenged kilotons from the mineral deposit.
-		// The rest will stay on the surface.
-		ElementPtr->mass_points -= NumRetrieved;
-		
-		// JMS: This makes the mineral deposit subtraction keep  
-		// in effect even after leaving & re-entering the planet.
-		which_node = HIBYTE (ElementPtr->scan_node) - 1;
-		pSolarSysState->SysInfo.PlanetInfo.PartiallyScavengedList[MINERAL_SCAN][which_node] = NumRetrieved;
-		
-		// JMS: If the deposit was large and its amount now equates to a smaller
-		// deposit, change its graphics.
-		if ((oldsize > 22 && ElementPtr->mass_points <= 22)
-			|| (oldsize > 15 && ElementPtr->mass_points <= 15))
-		{
-			PRIMITIVE *pPrim = &DisplayArray[ElementPtr->PrimIndex];
-			BYTE gfx_index_change = 0;
+		NumRetrieved = (COUNT)(Max - *Amount);
+
+		if (Scan != BIOLOGICAL_SCAN && optPartialPickup){
+			// JMS: Subtract the scavenged kilotons from the mineral deposit.
+			// The rest will stay on the surface.
+			ElementPtr->mass_points -= NumRetrieved;
+		
+			// JMS: This makes the mineral deposit subtraction keep  
+			// in effect even after leaving & re-entering the planet.
+			which_node = HIBYTE (ElementPtr->scan_node) - 1;
+			pSolarSysState->SysInfo.PlanetInfo.PartiallyScavengedList[MINERAL_SCAN][which_node] = NumRetrieved;
+		
+			// JMS: If the deposit was large and its amount now equates to a smaller
+			// deposit, change its graphics.
+			if ((oldsize > 22 && ElementPtr->mass_points <= 22)
+				|| (oldsize > 15 && ElementPtr->mass_points <= 15))
+			{
+				PRIMITIVE *pPrim = &DisplayArray[ElementPtr->PrimIndex];
+				BYTE gfx_index_change = 0;
 			
-			if (oldsize > 22 && ElementPtr->mass_points <= 15)
-				gfx_index_change = 2;
-			else
-				gfx_index_change = 1;
+				if (oldsize > 22 && ElementPtr->mass_points <= 15)
+					gfx_index_change = 2;
+				else
+					gfx_index_change = 1;
 			
-			// Change the scan screen gfx.
-			ElementPtr->current.image.frame = SetRelFrameIndex (
-				ElementPtr->current.image.frame, (2 - gfx_index_change));
-			ElementPtr->next.image.frame = ElementPtr->current.image.frame;
-
-			// Notify the engine that the scan screen gfx should be updated.
-			ElementPtr->state_flags |= CHANGING;
-			SET_GAME_STATE (PLANETARY_CHANGE, 1);
+				// Change the scan screen gfx.
+				ElementPtr->current.image.frame = SetRelFrameIndex (
+					ElementPtr->current.image.frame, (2 - gfx_index_change));
+				ElementPtr->next.image.frame = ElementPtr->current.image.frame;
+
+				// Notify the engine that the scan screen gfx should be updated.
+				ElementPtr->state_flags |= CHANGING;
+				SET_GAME_STATE (PLANETARY_CHANGE, 1);
 			
-			// Change the surface screen gfx.
-			pPrim->Object.Stamp.frame = SetRelFrameIndex (pPrim->Object.Stamp.frame, -gfx_index_change);
-		}
+				// Change the surface screen gfx.
+				pPrim->Object.Stamp.frame = SetRelFrameIndex (pPrim->Object.Stamp.frame, -gfx_index_change);
+			}
 		
-		partialPickup = true;
+			PartialPickup = TRUE;
+		}
 	}
 
-	FillLanderHold (pPSD, MINERAL_SCAN, NumRetrieved);
+	FillLanderHold (pPSD, Scan, NumRetrieved);
 
-	EType = ElementPtr->turn_wait;
-	pPSD->ElementAmounts[ElementCategory (EType)] += NumRetrieved;
+	if (Scan != BIOLOGICAL_SCAN)
+		pPSD->ElementAmounts[ElementCategory (EType)] += NumRetrieved;
 
 	pPSD->NumFrames = NUM_TEXT_FRAMES;
 	sprintf (pPSD->AmountBuf, "%u", NumRetrieved);
-	pStr = GAME_STRING (EType + ELEMENTS_STRING_BASE);
+	pStr = GAME_STRING (EType + Offset);
 
 	pPSD->MineralText[0].baseline.x = (SURFACE_WIDTH >> 1)
 			+ (ElementControl->EndPoint.x - LanderControl->EndPoint.x);
 	pPSD->MineralText[0].baseline.y = (SURFACE_HEIGHT >> 1)
-            + (ElementControl->EndPoint.y - LanderControl->EndPoint.y);
+			+ (ElementControl->EndPoint.y - LanderControl->EndPoint.y);
 	pPSD->MineralText[0].CharCount = (COUNT)~0;
 	pPSD->MineralText[1].pStr = pStr;
 
 	while ((ch = *pStr++) && ch != ' ')
 		;
-	if (ch == '\0')
-	{
+	if (ch == '\0') {
 		pPSD->MineralText[1].CharCount = (COUNT)~0;
 		pPSD->MineralText[2].CharCount = 0;
-	}
-	else  /* ch == ' ' */
-	{
+	} else {  /* ch == ' ' */
 		// Name contains a space. Print over
 		// two lines.
 		pPSD->MineralText[1].CharCount = utf8StringCountN(
@@ -677,63 +675,7 @@ pickupMineralNode (PLANETSIDE_DESC *pPSD
 	}
 
 	// JMS
-	if (partialPickup)
-		return false;
-	else
-		return true;
-}
-
-static bool
-pickupBioNode (PLANETSIDE_DESC *pPSD, COUNT NumRetrieved,
-	const INTERSECT_CONTROL *LanderControl, const INTERSECT_CONTROL *ElementControl)
-{
-	UNICODE *pStr; // JMS
-	UNICODE ch; // JMS
-	if (pPSD->BiologicalLevel >= MAX_SCROUNGED)
-	{
-		// Lander is full.
-		PlaySound (SetAbsSoundIndex (LanderSounds, LANDER_FULL),
-				NotPositional (), NULL, GAME_SOUND_PRIORITY);
-		return false;
-	}
-
-	if (pPSD->BiologicalLevel + NumRetrieved > MAX_SCROUNGED)
-	{
-		// Node could only be picked up partially.
-		NumRetrieved = (COUNT)(MAX_SCROUNGED - pPSD->BiologicalLevel);
-	}
-	
-	// JMS: Print biodata amount.
-	pPSD->NumFrames = NUM_TEXT_FRAMES;
-	sprintf (pPSD->AmountBuf, "%u", NumRetrieved);
-	pStr = GAME_STRING (ELEMENTS_STRING_BASE + ELEMENTS_STRING_COUNT - 1);
-	pPSD->MineralText[0].baseline.x = (SURFACE_WIDTH >> 1)
-		+ (ElementControl->EndPoint.x - LanderControl->EndPoint.x);
-	pPSD->MineralText[0].baseline.y = (SURFACE_HEIGHT >> 1)
-		+ (ElementControl->EndPoint.y - LanderControl->EndPoint.y);
-	pPSD->MineralText[0].CharCount = (COUNT)~0;
-	pPSD->MineralText[1].pStr = pStr;
-	
-	while ((ch = *pStr++) && ch != ' ')
-		;
-	if (ch == '\0')
-	{
-		pPSD->MineralText[1].CharCount = (COUNT)~0;
-		pPSD->MineralText[2].CharCount = 0;
-	}
-	else  /* ch == ' ' */
-	{
-		// Name contains a space. Print over
-		// two lines.
-		pPSD->MineralText[1].CharCount = utf8StringCountN(
-			pPSD->MineralText[1].pStr, pStr - 1);
-		pPSD->MineralText[2].pStr = pStr;
-		pPSD->MineralText[2].CharCount = (COUNT)~0;
-	}
-
-	FillLanderHold (pPSD, BIOLOGICAL_SCAN, NumRetrieved);
-
-	return true;
+	return (PartialPickup ? false : true);
 }
 
 static void
@@ -803,6 +745,10 @@ shotCreature (ELEMENT *ElementPtr, BYTE
 		// Can other creatures.
 		else
 		{
+			// stash the type of creature in the
+			// thrust_wait field.  It seems to be unused
+			// by the game for anything at this point
+			ElementPtr->thrust_wait = ElementPtr->mass_points & ~CREATURE_AWARE;
 			ElementPtr->mass_points = value;
 			DisplayArray[ElementPtr->PrimIndex].Object.Stamp.frame =
 			pSolarSysState->PlanetSideFrame[0];
@@ -817,8 +763,8 @@ shotCreature (ELEMENT *ElementPtr, BYTE
 				LanderControl->IntersectStamp.frame) -
 				ANGLE_TO_FACING (FULL_CIRCLE));
 		DeltaVelocityComponents (&ElementPtr->velocity,
-				COSINE (angle, WORLD_TO_VELOCITY (1<<RESOLUTION_FACTOR)),
-				SINE (angle, WORLD_TO_VELOCITY (1<<RESOLUTION_FACTOR))); // JMS_GFX
+				COSINE (angle, WORLD_TO_VELOCITY (1 << RESOLUTION_FACTOR)),
+				SINE (angle, WORLD_TO_VELOCITY (1 << RESOLUTION_FACTOR))); // JMS_GFX
 		ElementPtr->thrust_wait = 0;
 		ElementPtr->mass_points |= CREATURE_AWARE;
 	}
@@ -999,14 +945,8 @@ CheckObjectCollision (COUNT index)
 						case ENERGY_SCAN:
 							break;
 						case MINERAL_SCAN:
-							if (!pickupMineralNode (pPSD, NumRetrieved,
-									ElementPtr, &LanderControl,
-									&ElementControl))
-								continue;
-							break;
 						case BIOLOGICAL_SCAN:
-							if (!pickupBioNode (pPSD, NumRetrieved, &LanderControl,
-									&ElementControl))
+							if (!pickupNode (pPSD, NumRetrieved, ElementPtr, &LanderControl, &ElementControl, scan))
 								continue;
 							break;
 					}
@@ -1049,6 +989,8 @@ lightning_process (ELEMENT *ElementPtr)
 		}
 		else
 		{
+			SIZE s;
+#define NUM_CYCLES 8
 			static const Color color_tab[] =
 			{
 				BUILD_COLOR (MAKE_RGB15_INIT (0x11, 0x11, 0x11), 0x18),
@@ -1060,18 +1002,12 @@ lightning_process (ELEMENT *ElementPtr)
 				BUILD_COLOR (MAKE_RGB15_INIT (0x1D, 0x1D, 0x1D), 0x10),
 				BUILD_COLOR (MAKE_RGB15_INIT (0x1F, 0x1F, 0x1F), 0x0f),
 			};
-			
-			SIZE s;
-			
-			s = 7 - ((SIZE)ElementPtr->cycle - (SIZE)ElementPtr->life_span);
-			if (s < 0)
-				s = 0;
-			
-			// XXX: Was 0x8000 the background flag on 3DO?
-			//SetPrimColor (pPrim, BUILD_COLOR (0x8000 | MAKE_RGB15 (0x1F, 0x1F, 0x1F), s));
-			//SetPrimColor (pPrim, BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x1F), s));
+
+			s = ElementPtr->life_span;
+			if (s > NUM_CYCLES - 1)
+				s = NUM_CYCLES - 1;
 			SetPrimColor (pPrim, color_tab[s]);
-			
+
 			if (ElementPtr->mass_points == LIGHTNING_DISASTER)
 			{
 				/* This one always strikes the lander and can hurt */
@@ -1117,9 +1053,8 @@ AddLightning (void)
 
 		rand_val = TFB_Random ();
 		LightningElementPtr->life_span = 10 + (HIWORD (rand_val) % 10) + 1;
-		
-		if (RESOLUTION_FACTOR == 0)
-		{
+
+		if (RESOLUTION_FACTOR == 0) {
 			LightningElementPtr->next.location.x = (curLanderLoc.x
 				+ ((MAP_WIDTH << MAG_SHIFT) - ((SURFACE_WIDTH >> 1) - 6))
 				+ (LOBYTE (rand_val) % (SURFACE_WIDTH - 12))
@@ -1128,9 +1063,7 @@ AddLightning (void)
 				+ ((MAP_HEIGHT << MAG_SHIFT) - ((SURFACE_HEIGHT >> 1) - 6))
 				+ (HIBYTE (rand_val) % (SURFACE_HEIGHT - 12))
 				) % (MAP_HEIGHT << MAG_SHIFT);
-		}
-		else
-		{
+		} else {
 			LightningElementPtr->next.location.x = (curLanderLoc.x
 				+ ((MAP_WIDTH << MAG_SHIFT) - ((SURFACE_WIDTH >> 1) - 6))
 				+ (rand_val % (SURFACE_WIDTH - (12 << RESOLUTION_FACTOR)))
@@ -1205,7 +1138,7 @@ AddGroundDisaster (COUNT which_disaster)
 		GroundDisasterElementPtr->life_span =
 				GetFrameCount (pPrim->Object.Stamp.frame)
 				* (LONIBBLE (GroundDisasterElementPtr->turn_wait) + 1) - 1;
-		
+
 		UnlockElement (hGroundDisasterElement);
 
 		PutElement (hGroundDisasterElement);
@@ -1358,7 +1291,6 @@ ScrollPlanetSide (SIZE dx, SIZE dy, int
 	
 	curLanderLoc = new_pt;
 
-	LockMutex (GraphicsLock);
 	OldContext = SetContext (PlanetContext);
 
 	BatchGraphics ();
@@ -1464,28 +1396,6 @@ ScrollPlanetSide (SIZE dx, SIZE dy, int
 	UnbatchGraphics ();
 
 	SetContext (OldContext);
-	UnlockMutex (GraphicsLock);
-}
-
-static void
-DrawSubmenuMineralValues (bool menu_visible)
-{
-	STAMP s;
-	CONTEXT OldContext;
-	
-	OldContext = SetContext (ScreenContext);
-
-	s.origin.x = 0;
-	s.origin.y = 0;
-		
-	if (menu_visible)
-		s.frame = SetAbsFrameIndex (SubmenuMineralsFrame, 1);
-	else
-		s.frame = SetAbsFrameIndex (SubmenuMineralsFrame, 0);
-
-	DrawStamp (&s);
-	
-	SetContext (OldContext);
 }
 
 static void
@@ -1495,9 +1405,7 @@ animationInterframe (TimeCount *TimeIn,
 
 	for ( ; periods; --periods)
 	{
-		LockMutex (GraphicsLock);
 		RotatePlanetSphere (TRUE);
-		UnlockMutex (GraphicsLock);
 
 		SleepThreadUntil (*TimeIn + ANIM_FRAME_RATE);
 		*TimeIn = GetTimeCounter ();
@@ -1512,12 +1420,12 @@ AnimateLaunch (FRAME farray, BOOLEAN lan
 	COUNT num_frames;
 	TimeCount NextTime;
 
-	LockMutex (GraphicsLock);
 	SetContext (PlanetContext);
 
 	r.corner.x = 0;
 	r.corner.y = 0;
 	r.extent.width = 0;
+	r.extent.height = 0;
 	s.origin.x = 0;
 	s.origin.y = 0;
 	s.frame = farray;
@@ -1535,21 +1443,16 @@ AnimateLaunch (FRAME farray, BOOLEAN lan
 #endif
 		DrawStamp (&s);
 		UnbatchGraphics ();
-		UnlockMutex (GraphicsLock);
 
 		GetFrameRect (s.frame, &r);
 		s.frame = IncFrameIndex (s.frame);
 
 		SleepThreadUntil (NextTime);
-
-		LockMutex (GraphicsLock);
 	}
 
 	// This clears the last lander return / launch) anim frame from the planet window.
 	if (RESOLUTION_FACTOR == 0 || !landing)
 		RepairBackRect (&r, FALSE);
-	
-	UnlockMutex (GraphicsLock);
 }
 
 static void
@@ -1560,18 +1463,14 @@ AnimateLanderWarmup (void)
 	CONTEXT OldContext;
 	TimeCount TimeIn = GetTimeCounter ();
 
-	LockMutex (GraphicsLock);
 	OldContext = SetContext (RadarContext);
-	UnlockMutex (GraphicsLock);
 
 	s.origin.x = 0;
 	s.origin.y = 0;
 	s.frame = SetAbsFrameIndex (LanderFrame[0],
 			(ANGLE_TO_FACING (FULL_CIRCLE) << 1) + 1);
 
-	LockMutex (GraphicsLock);
 	DrawStamp (&s);
-	UnlockMutex (GraphicsLock);
 
 	animationInterframe (&TimeIn, 2);
 
@@ -1580,10 +1479,8 @@ AnimateLanderWarmup (void)
 	{
 		animationInterframe (&TimeIn, 1);
 		
-		LockMutex (GraphicsLock);
 		DeltaSISGauges (-1, 0, 0);
 		DeltaLanderCrew (1, 0);
-		UnlockMutex (GraphicsLock);
 	}
 
 	animationInterframe (&TimeIn, 2);
@@ -1593,9 +1490,7 @@ AnimateLanderWarmup (void)
 	else
 		s.frame = SetAbsFrameIndex (s.frame,
 				(ANGLE_TO_FACING (FULL_CIRCLE) << 1) + 2);
-	LockMutex (GraphicsLock);
 	DrawStamp (&s);
-	UnlockMutex (GraphicsLock);
 
 	animationInterframe (&TimeIn, 2);
 
@@ -1605,26 +1500,20 @@ AnimateLanderWarmup (void)
 	{
 		s.frame = SetAbsFrameIndex (s.frame,
 				(ANGLE_TO_FACING (FULL_CIRCLE) << 1) + 3);
-		LockMutex (GraphicsLock);
 		DrawStamp (&s);
-		UnlockMutex (GraphicsLock);
 
 		animationInterframe (&TimeIn, 2);
 
 		s.frame = IncFrameIndex (s.frame);
 	}
-	LockMutex (GraphicsLock);
 	DrawStamp (&s);
-	UnlockMutex (GraphicsLock);
 
 	if (GET_GAME_STATE (IMPROVED_LANDER_CARGO))
 	{
 		animationInterframe (&TimeIn, 2);
 
 		s.frame = SetAbsFrameIndex (s.frame, 59);
-		LockMutex (GraphicsLock);
 		DrawStamp (&s);
-		UnlockMutex (GraphicsLock);
 	}
 
 	animationInterframe (&TimeIn, 2);
@@ -1659,7 +1548,6 @@ InitPlanetSide (POINT pt)
 
 	curLanderLoc = pt;
 
-	LockMutex (GraphicsLock);
 	SetContext (PlanetContext);
 	SetContextFont (TinyFont);
 
@@ -1692,7 +1580,6 @@ InitPlanetSide (POINT pt)
 		UnbatchGraphics ();
 	}
 
-	UnlockMutex (GraphicsLock);
 
 	SET_GAME_STATE (PLANETARY_LANDING, 1);
 }
@@ -1809,7 +1696,7 @@ DoPlanetSide (LanderInputState *pMS)
 		landerSpeedNumer = GET_GAME_STATE (IMPROVED_LANDER_SPEED) ?
 			WORLD_TO_VELOCITY (2 * (16 << RESOLUTION_FACTOR)) :
 			WORLD_TO_VELOCITY (2 * (8 << RESOLUTION_FACTOR));
-		
+
 #ifdef FAST_FAST
 landerSpeedNumer = WORLD_TO_VELOCITY (48 << RESOLUTION_FACTOR); // JMS
 #endif
@@ -1874,8 +1761,8 @@ landerSpeedNumer = WORLD_TO_VELOCITY (48
 
 				angle = FACING_TO_ANGLE (index);
 				landerSpeedNumer = GET_GAME_STATE (IMPROVED_LANDER_SPEED) ?
-						WORLD_TO_VELOCITY ((2 * 16) << RESOLUTION_FACTOR) :
-						WORLD_TO_VELOCITY ((2 * 8) << RESOLUTION_FACTOR);
+					WORLD_TO_VELOCITY ((2 * 16) << RESOLUTION_FACTOR) :
+					WORLD_TO_VELOCITY ((2 * 8) << RESOLUTION_FACTOR);
 
 #ifdef FAST_FAST
 landerSpeedNumer = WORLD_TO_VELOCITY (48 << RESOLUTION_FACTOR);
@@ -1975,9 +1862,6 @@ LoadLanderData (void)
 		for (i = 0; i < NUM_ORBIT_THEMES; ++i)
 			OrbitMusic[i] = load_orbit_theme (i);
 	}
-	
-	// JMS: This is a table of mineral values that will be shown on the status bar.
-	SubmenuMineralsFrame = CaptureDrawable (LoadGraphic (SUBMENUMINERALS_MASK_PMAP_ANIM));
 }
 
 void
@@ -1992,7 +1876,6 @@ ReturnToOrbit (void)
 	CONTEXT OldContext;
 	RECT r;
 
-	LockMutex (GraphicsLock);
 	OldContext = SetContext (PlanetContext);
 	GetContextClipRect (&r);
 
@@ -2000,9 +1883,9 @@ ReturnToOrbit (void)
 	BatchGraphics ();
 	
 	// JMS: This will hide the table of mineral values on the status bar.
-	if (optMineralSubmenu)
-		DrawSubmenuMineralValues (FALSE);
-		
+	if (optSubmenu)
+		DrawSubmenu (0);
+
 	DrawStarBackGround ();
 	DrawPlanetSurfaceBorder ();
 	RedrawSurfaceScan (NULL);
@@ -2010,7 +1893,6 @@ ReturnToOrbit (void)
 	UnbatchGraphics ();
 
 	SetContext (OldContext);
-	UnlockMutex (GraphicsLock);
 }
 
 static void
@@ -2032,7 +1914,7 @@ static void
 LandingTakeoffSequence (LanderInputState *inputState, BOOLEAN landing)
 {
 // We cannot solve a quadratic equation in a macro, so use a sensible max
-#define MAX_OFFSETS 20
+#define MAX_OFFSETS  20
 #define MAX_OFFSETS_4X 400 // JMS_GFX
 // 10 << RESOLUTION_FACTOR to clear the lander off of the screen
 #define DISTANCE_COVERED  (SURFACE_HEIGHT / 2 + (10 << RESOLUTION_FACTOR))
@@ -2043,19 +1925,17 @@ LandingTakeoffSequence (LanderInputState
 	int index;
 	int max_offsets; // JMS_GFX
 	int landingOfs4x[MAX_OFFSETS_4X]; // JMS_GFX
-	
+
 	// Produce smooth acceleration deltas from a simple 1..x progression
 	delta = 0;
-	
 	// JMS_GFX: At 4x resolution we run out of default offsets. -> Use larger offset value.
 	max_offsets = MAX_OFFSETS;
 	if (RESOLUTION_FACTOR == 2) 
 		max_offsets = MAX_OFFSETS_4X;
-	
+
 	for (index = 0; index < max_offsets && delta < DISTANCE_COVERED; ++index)
 	{
 		delta += index + 1;
-		
 		// JMS_GFX
 		if (RESOLUTION_FACTOR == 2)
 			landingOfs4x[index] = -delta;
@@ -2088,7 +1968,7 @@ LandingTakeoffSequence (LanderInputState
 			ScrollPlanetSide (0, 0, landingOfs4x[index]);
 		else
 			ScrollPlanetSide (0, 0, landingOfs[index]);
-		
+
 		SleepThreadUntil (inputState->NextTime);
 		inputState->NextTime += PLANET_SIDE_RATE;
 	}
@@ -2123,39 +2003,65 @@ KillLanderCrewSeq (COUNT numKilled, DWOR
 	return crew_left > 0;
 }
 
+// Maps a temperature to a (0-7) hazard rating.
+// Thermal hazards aren't exposed to the user as a hazard number,
+// but the code still works with them that way.
+#define ARRAY_SIZE(array) (sizeof(array) / sizeof (*array))
+unsigned
+GetThermalHazardRating (int temp)
+{
+	static const int tempBreakpoints[] = { 50, 100, 150, 250, 350, 550, 800 };
+	const size_t numBreakpoints = ARRAY_SIZE (tempBreakpoints);
+	unsigned i;
+
+	for (i = 0; i < numBreakpoints; ++i)
+	{
+		if (temp < tempBreakpoints[i])
+			return i;
+	}
+
+	return numBreakpoints;
+}
+
+// Given a hazard type and rating, return the chance (out of 256) of the hazard
+// being generated.
+static BYTE
+GetHazardChance (int hazardType, unsigned HazardRating)
+{
+	static const BYTE TectonicsChanceTab[] = {0*3, 0*3, 1*3, 2*3, 4*3,  8*3, 16*3, 32*3};
+	static const BYTE WeatherChanceTab  [] = {0*3, 0*3, 1*3, 2*3, 3*3,  6*3, 12*3, 24*3};
+	static const BYTE FireChanceTab     [] = {0*3, 0*3, 1*3, 2*3, 4*3, 12*3, 24*3, 48*3};
+
+	switch (hazardType)
+	{
+		case EARTHQUAKE_DISASTER:
+			return TectonicsChanceTab[HazardRating];
+		case LIGHTNING_DISASTER:
+			return WeatherChanceTab[HazardRating];
+		case LAVASPOT_DISASTER:
+			return FireChanceTab[HazardRating];
+	}
+
+	return 0;
+}
+
 void
 PlanetSide (POINT planetLoc)
 {
 	SIZE index;
 	LanderInputState landerInputState;
 	PLANETSIDE_DESC PSD;
-	BYTE TectonicsChanceTab[] = {0*3, 0*3, 1*3, 2*3, 4*3, 8*3, 16*3, 32*3};
-	BYTE WeatherChanceTab[] = {0*3, 0*3, 1*3, 2*3, 3*3, 6*3, 12*3, 24*3};
-	BYTE FireChanceTab[] = {0*3, 0*3, 1*3, 2*3, 4*3, 12*3, 24*3, 48*3};
+
 	memset (&PSD, 0, sizeof (PSD));
 	PSD.InTransit = TRUE;
 
-	PSD.TectonicsChance =
-			TectonicsChanceTab[pSolarSysState->SysInfo.PlanetInfo.Tectonics];
-	PSD.WeatherChance =
-			WeatherChanceTab[pSolarSysState->SysInfo.PlanetInfo.Weather];
-	index = pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature;
-	if (index < 50)
-		PSD.FireChance = FireChanceTab[0];
-	else if (index < 100)
-		PSD.FireChance = FireChanceTab[1];
-	else if (index < 150)
-		PSD.FireChance = FireChanceTab[2];
-	else if (index < 250)
-		PSD.FireChance = FireChanceTab[3];
-	else if (index < 350)
-		PSD.FireChance = FireChanceTab[4];
-	else if (index < 550)
-		PSD.FireChance = FireChanceTab[5];
-	else if (index < 800)
-		PSD.FireChance = FireChanceTab[6];
-	else
-		PSD.FireChance = FireChanceTab[7];
+	// Set our chances of hazards occurring.
+	PSD.TectonicsChance = GetHazardChance (EARTHQUAKE_DISASTER,
+			pSolarSysState->SysInfo.PlanetInfo.Tectonics);
+	PSD.WeatherChance = GetHazardChance (LIGHTNING_DISASTER,
+			pSolarSysState->SysInfo.PlanetInfo.Weather);
+	PSD.FireChance = GetHazardChance (LAVASPOT_DISASTER, GetThermalHazardRating (
+			pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature));
 
 	PSD.ElementLevel = GetStorageBayCapacity () - GLOBAL_SIS (TotalElementMass);
 	PSD.MaxElementLevel = MAX_SCROUNGED;
@@ -2198,14 +2104,9 @@ PlanetSide (POINT planetLoc)
 	AnimateLanderWarmup ();
 	AnimateLaunch (LanderFrame[5], TRUE);
 
-	// JMS: This will show the table of mineral values on the status bar.
-	if (optMineralSubmenu)
-	{
-		LockMutex (GraphicsLock);
-		DrawSubmenuMineralValues (TRUE);
-		UnlockMutex (GraphicsLock);
-	}
-	
+	if (optSubmenu)
+		DrawSubmenu (1);
+
 	InitPlanetSide (planetLoc);
 
 	landerInputState.NextTime = GetTimeCounter () + PLANET_SIDE_RATE;
@@ -2222,9 +2123,7 @@ PlanetSide (POINT planetLoc)
 		if (crew_left == 0)
 		{
 			--GLOBAL_SIS (NumLanders);
-			LockMutex (GraphicsLock);
 			DrawLanders ();
-			UnlockMutex (GraphicsLock);
 
 			ReturnToOrbit ();
 		}
@@ -2238,7 +2137,6 @@ PlanetSide (POINT planetLoc)
 			ReturnToOrbit ();
 			AnimateLaunch (LanderFrame[6], FALSE);
 			
-			LockMutex (GraphicsLock);
 			DeltaSISGauges (crew_left, 0, 0);
 
 			if (PSD.ElementLevel)
@@ -2252,7 +2150,6 @@ PlanetSide (POINT planetLoc)
 				}
 				DrawStorageBays (FALSE);
 			}
-			UnlockMutex (GraphicsLock);
 
 			GLOBAL_SIS (TotalBioMass) += PSD.BiologicalLevel;
 		}
@@ -2291,10 +2188,8 @@ void
 InitLander (BYTE LanderFlags)
 {
 	RECT r;
-	LockMutex (GraphicsLock);
 
 	SetContext (RadarContext);
-	
 	BatchGraphics ();
 	
 	r.corner.x = 0;
@@ -2360,7 +2255,7 @@ InitLander (BYTE LanderFlags)
 		{
 			r.corner.x = 1;
 			r.extent.width = RES_STAT_SCALE(4) + RESOLUTION_FACTOR; // JMS_GFX
-			r.extent.height = RES_STAT_SCALE(MAX_SCROUNGED - (free_space >> capacity_shift) + 1);
+			r.extent.height = RES_STAT_SCALE(MAX_HOLD_BARS - ((free_space >> capacity_shift) * MAX_HOLD_BARS / MAX_SCROUNGED) + 2);
 			SetContextForeGroundColor (BLACK_COLOR);
 			DrawFilledRectangle (&r);
 		}
@@ -2380,6 +2275,4 @@ InitLander (BYTE LanderFlags)
 	}
 
 	UnbatchGraphics ();
-
-	UnlockMutex (GraphicsLock);
 }
diff -ruNp src.hd/uqm/planets/lander.h src/uqm/planets/lander.h
--- src.hd/uqm/planets/lander.h	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/lander.h	2017-12-29 00:57:49 -0800
@@ -26,6 +26,9 @@
 #include "libs/timelib.h"
 #include "../element.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
 // Surface magnification shift (x4)
 #define MAG_SHIFT 2
@@ -69,6 +72,8 @@ extern void object_animation (ELEMENT *E
 extern void SetLanderTakeoff (void);
 extern bool KillLanderCrewSeq (COUNT numKilled, DWORD period);
 
+extern unsigned GetThermalHazardRating (int temp);
+
 // ELEMENT.playerNr constants
 enum
 {
@@ -76,5 +81,9 @@ enum
 	PS_NON_PLAYER,
 };
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _LANDER_H */
 
diff -ruNp src.hd/uqm/planets/lifeform.h src/uqm/planets/lifeform.h
--- src.hd/uqm/planets/lifeform.h	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/lifeform.h	2017-12-29 00:57:49 -0800
@@ -21,6 +21,9 @@
 
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
 #define BEHAVIOR_HUNT (0 << 0)
 #define BEHAVIOR_FLEE (1 << 0)
@@ -65,5 +68,9 @@ typedef struct
 
 extern const LIFEFORM_DESC CreatureData[];
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _LIFEFORM_H */
 
diff -ruNp src.hd/uqm/planets/orbits.c src/uqm/planets/orbits.c
--- src.hd/uqm/planets/orbits.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/orbits.c	2017-12-29 00:57:49 -0800
@@ -16,15 +16,12 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "planets.h"
-// XXX: for CurStarDescPtr
-#include "../encount.h"
-#include "../clock.h"
+#include "../starmap.h"
 #include "libs/compiler.h"
 #include "libs/mathlib.h"
 #include "libs/log.h"
+#include "../clock.h"
 #include <math.h>
 
 //#define DEBUG_ORBITS
@@ -465,7 +462,7 @@ YellowDistribution (BYTE which_world)
 }
 
 #define DWARF_ROCK_DIST MIN_PLANET_RADIUS
-#define DWARF_GASG_DIST SCALE_RADIUS (12) 
+#define DWARF_GASG_DIST SCALE_RADIUS (12)
 
 #define GIANT_ROCK_DIST SCALE_RADIUS (8)
 #define GIANT_GASG_DIST SCALE_RADIUS (13)
@@ -477,18 +474,15 @@ void ComputeSpeed(PLANET_DESC *planet, B
 {
 	//BW : empiric values, which would give roughly correct
 	// rotation periods for most moons in the solar system
-	if (GeneratingMoons)
-		{
-			planet->orb_speed = FULL_CIRCLE / (29 * pow((double)planet->radius / (MIN_MOON_RADIUS + (MAX_MOONS - 1) * MOON_DELTA), 1.5));
-			if ((planet->pPrevDesc->data_index & ~PLANET_SHIELDED) >= FIRST_GAS_GIANT)
-				planet->orb_speed *= 2;
-			if (!(rand_val % 7))
-				planet->orb_speed = - planet->orb_speed;
-		}
-		else
-		{
-			planet->orb_speed = FULL_CIRCLE / (ONE_YEAR * pow((double)planet->radius / EARTH_RADIUS, 1.5));
-		}
+	if (GeneratingMoons) {
+		planet->orb_speed = FULL_CIRCLE / (29 * pow((double)planet->radius / (MIN_MOON_RADIUS + (MAX_MOONS - 1) * MOON_DELTA), 1.5));
+		if ((planet->pPrevDesc->data_index & ~PLANET_SHIELDED) >= FIRST_GAS_GIANT)
+			planet->orb_speed *= 2;
+		if (!(rand_val % 7))
+			planet->orb_speed = - planet->orb_speed;
+	} else {
+		planet->orb_speed = FULL_CIRCLE / (ONE_YEAR * pow((double)planet->radius / EARTH_RADIUS, 1.5));
+	}
 }
 
 void
@@ -520,10 +514,15 @@ char scolor[] = {'B', 'G', 'O', 'R', 'W'
 
 	if (NumPlanets == (BYTE)~0)
 	{
-#define MAX_GENERATED_PLANETS 10
-		while ((NumPlanets = (BYTE)(LOWORD (TFB_Random())
-				% MAX_GENERATED_PLANETS)) == 0)
-			;
+#define MAX_GENERATED_PLANETS 9
+		// XXX: This is pretty funny. Instead of calling RNG once, like so:
+		//     1 + Random % MAX_GENERATED_PLANETS
+		//   we spin in a loop until the result > 0.
+		//   Note that this behavior must be kept to preserve the universe.
+		do
+			NumPlanets = LOWORD (RandomContext_Random (SysGenRNG))
+					% (MAX_GENERATED_PLANETS + 1);
+		while (NumPlanets == 0);
 		system->SunDesc[0].NumPlanets = NumPlanets;
 	}
 
@@ -542,14 +541,13 @@ char scolor[] = {'B', 'G', 'O', 'R', 'W'
 	while (NumPlanets--)
 	{
 		BYTE chance;
-		DWORD rand_val;
-		DWORD min_radius; //, angle; // JMS_GFX: Was COUNT. Changed to avoid overflows in 1280x960.
+		DWORD rand_val, min_radius, angle;
 		SIZE delta_r;
 		PLANET_DESC *pLocPD;
 
 		do
 		{
-			rand_val = TFB_Random ();
+			rand_val = RandomContext_Random (SysGenRNG);
 			if (TypesDefined)
 				rand_val = 0;
 			else
@@ -588,7 +586,7 @@ char scolor[] = {'B', 'G', 'O', 'R', 'W'
 		else
 			min_radius = Suns[StarSize].MinGasGDist;
 RelocatePlanet:
-		rand_val = TFB_Random ();
+		rand_val = RandomContext_Random (SysGenRNG);
 		if (GeneratingMoons)
 		{
 			pPD->radius = MIN_MOON_RADIUS
@@ -616,21 +614,18 @@ RelocatePlanet:
 			}
 		}
 
-		rand_val = TFB_Random ();
+		rand_val = RandomContext_Random (SysGenRNG);
 		// Initial angle & coordinates as in Vanilla UQM
 		// Still used to compute rand_seed and the position
 		// of the planet at the start of the game
 		pPD->angle = NORMALIZE_ANGLE (LOWORD (rand_val));
 		pPD->location.x = COSINE (pPD->angle, pPD->radius);
 		pPD->location.y = SINE (pPD->angle, pPD->radius);
-		if (GeneratingMoons)
-		{
+		if (GeneratingMoons) {
 		pPD->rand_seed = MAKE_DWORD (
 		     COSINE (pPD->angle, pPD->radius >> RESOLUTION_FACTOR),
 		     SINE (pPD->angle, pPD->radius >> RESOLUTION_FACTOR));
-		}
-		else
-		{
+		} else {
 			pPD->rand_seed = MAKE_DWORD (pPD->location.x, pPD->location.y);
 		}
 		// Angle is kept for reference but location will be adjusted
diff -ruNp src.hd/uqm/planets/oval.c src/uqm/planets/oval.c
--- src.hd/uqm/planets/oval.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/oval.c	2017-12-29 00:57:49 -0800
@@ -21,6 +21,7 @@
 #include "libs/graphics/context.h"
 #include "libs/graphics/drawable.h"
 
+#include "planets.h"
 
 #define NUM_QUADS 4
 
@@ -132,7 +133,7 @@ DrawOval (RECT *pRect, BYTE num_off_pixe
 		if (quad_visible & (1 << x))
 		{
 			SetPrimNextLink (&prim[x], StartPrim);
-			SetPrimType (&prim[x], POINT_PRIM);
+			SetPrimType (&prim[x], POINT_PRIM); // Orbit dots
 			SetPrimColor (&prim[x], _get_context_fg_color ());
 
 			StartPrim = x;
diff -ruNp src.hd/uqm/planets/pl_stuff.c src/uqm/planets/pl_stuff.c
--- src.hd/uqm/planets/pl_stuff.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/pl_stuff.c	2017-12-29 00:57:49 -0800
@@ -25,7 +25,6 @@
 #include "scan.h"
 #include "options.h"
 #include "libs/log.h"
-
 #include <math.h>
 
 
@@ -80,7 +79,7 @@ InitSphereRotation (int direction, BOOLE
 
 	rotwidth = width;
 	rotheight = height;
-	
+
 	rotDirection = direction;
 	rotPointIndex = 0;
 	throbShield = shielded && optWhichShield == OPT_3DO;
@@ -100,7 +99,7 @@ InitSphereRotation (int direction, BOOLE
 	// Render the first sphere/shield frame
 	// Prepare will set the next one
 	rotFrameIndex = 1;
-	PrepareNextRotationFrame ();
+	PrepareNextRotationFrame (NULL, NULL, TRUE);
 }
 
 void
@@ -117,90 +116,75 @@ UninitSphereRotation (void)
 }
 
 void
-PrepareNextRotationFrame (void)
-{
-	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
-
-	// Generate the next rotation frame
-	// We alternate between the frames because we do not call FlushGraphics()
-	// The frame we just drew may not have made it to the screen yet
-	rotFrameIndex ^= 1;
-
-	// Go to next point, taking care of wraparounds
-	rotPointIndex += rotDirection;
-	if (rotPointIndex < 0)
-		rotPointIndex = rotwidth - 1;
-	else if (rotPointIndex >= rotwidth)
-		rotPointIndex = 0;
-
-	// prepare the next sphere frame
-	Orbit->SphereFrame = SetAbsFrameIndex (Orbit->SphereFrame, rotFrameIndex);
-	RenderPlanetSphere (Orbit, Orbit->SphereFrame, rotPointIndex, pSolarSysState->pOrbitalDesc->data_index & PLANET_SHIELDED, throbShield, rotwidth, rotheight, (rotheight >> 1) - RESOLUTION_FACTOR); // RADIUS
-	
-	if (throbShield)
-	{	// prepare the next shield throb frame
-		Orbit->ObjectFrame = SetAbsFrameIndex (Orbit->ObjectFrame,
-				rotFrameIndex);
-		SetShieldThrobEffect (Orbit->WorkFrame, rotPointIndex,
-				Orbit->ObjectFrame);
+PrepareNextRotationFrame (PLANET_DESC *pPlanetDesc, SIZE frameCounter, BOOLEAN inOrbit)
+{		
+	PLANET_ORBIT *Orbit = inOrbit ? &pSolarSysState->Orbit : &pPlanetDesc->orbit;
+
+	if (!inOrbit){
+		COUNT framerate;
+		int oldPointIndex = pPlanetDesc->rotPointIndex;
+		// Go to next point, taking care of wraparounds
+
+		// No need to rotate planets that are off screen
+		if (pPlanetDesc->radius > 4 * pSolarSysState->SunDesc[0].radius)
+			return;
+
+		// Optimization : the smallest worlds are rotated only once in a while
+		// The framerate is fine-tuned so that the planet is updated
+		// when the landscape has moved 1 pixel approximately
+		switch (pPlanetDesc->size) {
+			case 3: framerate = 15;
+				break;
+			case 4: framerate = 10;
+				break;
+			case 7: framerate = 4;
+				break;
+			case 11: framerate = 2;
+				break;
+			default: framerate = 1;
+				break;
+		}
+		if ((frameCounter % framerate) != 0)
+			return;
+
+		// BW: account for rotation period
+		pPlanetDesc->rotPointIndex = (int)(fmod(pPlanetDesc->rot_speed * daysElapsed(), pPlanetDesc->rotwidth));
+		if (pPlanetDesc->rotPointIndex < 0)
+			pPlanetDesc->rotPointIndex += pPlanetDesc->rotwidth;
+
+		// Nothing to do if there has been no visible rotation
+		if (pPlanetDesc->rotPointIndex == oldPointIndex)
+			return;
 	}
-}
-
-void
-PrepareNextRotationFrameForIP (PLANET_DESC *pPlanetDesc, SIZE frameCounter)
-{
-	PLANET_ORBIT *Orbit = &pPlanetDesc->orbit;
-	COUNT framerate;
-	int oldPointIndex = pPlanetDesc->rotPointIndex;
-	// Go to next point, taking care of wraparounds
-
-	// No need to rotate planets that are off screen
-	if (pPlanetDesc->radius > 4 * pSolarSysState->SunDesc[0].radius)
-		return;
-
-	// Optimization : the smallest worlds are rotated only once in a while
-	// The framerate is fine-tuned so that the planet is updated
-	// when the landscape has moved 1 pixel approximately
-	switch (pPlanetDesc->size)
-	{
-	case 3: framerate = 15;
-		break;
-	case 4: framerate = 10;
-		break;
-	case 7: framerate = 4;
-		break;
-	case 11: framerate = 2;
-		break;
-	default: framerate = 1;
-		break;
-	}
-	if ((frameCounter % framerate) != 0)
-		return;
-
-	// BW: account for rotation period
-	pPlanetDesc->rotPointIndex = (int)(fmod(pPlanetDesc->rot_speed * daysElapsed(), pPlanetDesc->rotwidth));
-	if (pPlanetDesc->rotPointIndex < 0)
-		pPlanetDesc->rotPointIndex += pPlanetDesc->rotwidth;
-
-	// Nothing to do if there has been no visible rotation
-	if (pPlanetDesc->rotPointIndex == oldPointIndex)
-		return;
-
 	// Generate the next rotation frame
 	// We alternate between the frames because we do not call FlushGraphics()
 	// The frame we just drew may not have made it to the screen yet
-	pPlanetDesc->rotFrameIndex ^= 1;
-
-	// pPlanetDesc->rotPointIndex += pPlanetDesc->rotDirection;
-	// if (pPlanetDesc->rotPointIndex < 0)
-	//	pPlanetDesc->rotPointIndex = pPlanetDesc->rotwidth - 1;
-	// else if (pPlanetDesc->rotPointIndex >= pPlanetDesc->rotwidth)
-	//	pPlanetDesc->rotPointIndex = 0;
+	if (inOrbit){
+		rotPointIndex += rotDirection;
+		if (rotPointIndex < 0)
+			rotPointIndex = rotwidth - 1;
+		else if (rotPointIndex >= rotwidth)
+			rotPointIndex = 0;
+	} else {
+		pPlanetDesc->rotFrameIndex ^= 1;
+	}
 
 	// prepare the next sphere frame
-	Orbit->SphereFrame = SetAbsFrameIndex (Orbit->SphereFrame, pPlanetDesc->rotFrameIndex);
-	RenderPlanetSphere (Orbit, Orbit->SphereFrame, pPlanetDesc->rotPointIndex, pPlanetDesc->data_index & PLANET_SHIELDED, FALSE, pPlanetDesc->rotwidth, pPlanetDesc->rotheight, (pPlanetDesc->rotheight >> 1) - RESOLUTION_FACTOR); // RADIUS
-	Orbit->SphereFrame->image->dirty = TRUE;
+	if(inOrbit){
+		Orbit->SphereFrame = SetAbsFrameIndex (Orbit->SphereFrame, rotFrameIndex);
+		RenderPlanetSphere (Orbit, Orbit->SphereFrame, rotPointIndex, pSolarSysState->pOrbitalDesc->data_index & PLANET_SHIELDED, throbShield, rotwidth, rotheight, (rotheight >> 1) - RESOLUTION_FACTOR); // RADIUS
+		if (throbShield)
+		{	// prepare the next shield throb frame
+			Orbit->ObjectFrame = SetAbsFrameIndex (Orbit->ObjectFrame,
+					rotFrameIndex);
+			SetShieldThrobEffect (Orbit->WorkFrame, rotPointIndex,
+					Orbit->ObjectFrame);
+		}	
+	} else {		
+		Orbit->SphereFrame = SetAbsFrameIndex (Orbit->SphereFrame, pPlanetDesc->rotFrameIndex);
+		RenderPlanetSphere (Orbit, Orbit->SphereFrame, pPlanetDesc->rotPointIndex, pPlanetDesc->data_index & PLANET_SHIELDED, FALSE, pPlanetDesc->rotwidth, pPlanetDesc->rotheight, (pPlanetDesc->rotheight >> 1) - RESOLUTION_FACTOR); // RADIUS
+		Orbit->SphereFrame->image->dirty = TRUE;
+	}
 	// BW: slightly hacky but, in DrawTexturedBody, the call
 	// to DrawStamp won't re-blit the frame unless scale has changed.
 }
@@ -258,7 +242,6 @@ ZoomInPlanetSphere (void)
 		pt.y = PLANET_ORG_Y + (int) (dy * (1.0 - scale)
 				* (SCAN_SCREEN_HEIGHT * 6 / 10) + 0.5);
 
-		LockMutex (GraphicsLock);
 		SetContext (PlanetContext);
 
 		BatchGraphics ();
@@ -272,12 +255,11 @@ ZoomInPlanetSphere (void)
 		SetGraphicScaleMode (oldMode);
 
 		UnbatchGraphics ();
-		UnlockMutex (GraphicsLock);
 
 		repairRect.corner.x = pt.x + frameRect.corner.x;
 		repairRect.corner.y = pt.y + frameRect.corner.y;
 
-		PrepareNextRotationFrame ();
+		PrepareNextRotationFrame (NULL, NULL, TRUE);
 
 		SleepThreadUntil (NextTime);
 	}
@@ -295,7 +277,7 @@ RotatePlanetSphere (BOOLEAN keepRate)
 	NextTime = Now + PLANET_ROTATION_RATE;
 	DrawDefaultPlanetSphere ();
 
-	PrepareNextRotationFrame ();
+	PrepareNextRotationFrame (NULL, NULL, TRUE);
 }
 
 static void
diff -ruNp src.hd/uqm/planets/plandata.h src/uqm/planets/plandata.h
--- src.hd/uqm/planets/plandata.h	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/plandata.h	2017-12-29 00:57:49 -0800
@@ -21,6 +21,9 @@
 
 #include "libs/reslib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
 /*------------------------------ Type Defines ----------------------------- */
 #define NUMBER_OF_ORBITS 16
@@ -137,7 +140,6 @@ enum
 	SUPER_DENSE_WORLD,
 	PELLUCID_WORLD,
 	DUST_WORLD,
-	//	EARTH_WORLD,
 	CRIMSON_WORLD,
 	CIMMERIAN_WORLD,
 	INFRARED_WORLD,
@@ -286,25 +288,6 @@ typedef struct
 	//
 	// This can be later made to support also partially scavenged biodata.
 	BYTE  PartiallyScavengedList[NUM_SCAN_TYPES][32];
-	
-	// The CurPt, CurDensity and CurType fields are filled in
-	// when a GENERATE_MINERAL, GENERATE_ENERGY, or GENERATE_LIFE
-	// call is made.
-	POINT CurPt;
-			// Position of the mineral/bio/energy node on the planet.
-	COUNT CurDensity;
-			// For bio and energy: undefined
-			// For minerals the low byte is the gross size of the
-			// deposit (this determines the image), and the high
-			// byte is the fine size (the actual quantity).
-	COUNT CurType;
-			// For minerals: the type of element
-			// For bio: the type of the creature.
-			//          0 through NUM_CREATURE_TYPES - 1 are normal creatures,
-			//          NUM_CREATURE_TYPES     is an Evil One
-			//          NUM_CREATURE_TYPES + 1 is a Brainbox Bulldozer
-			//          NUM_CREATURE_TYPES + 2 is Zex' Beauty
-			// For energy: undefined
 
 	STRING DiscoveryString;
 	FONT LanderFont;
@@ -321,8 +304,7 @@ enum
 	SUPER_DENSITY
 };
 
-#define CalcGravity(d,r) (UWORD)((DWORD)(d) * (r) / 100)
-#define CalcFromBase(b,v) ((UWORD)(b) + ((UWORD)TFB_Random () % (v)))
+extern UWORD CalcGravity (const PLANET_INFO*);
 
 #define EARTH_ATMOSPHERE 50
 
@@ -338,7 +320,7 @@ enum
 	SATURN_COLOR_TAB, \
 	URANUS_COLOR_TAB, \
 	NEPTUNE_COLOR_TAB, \
-	PLUTO_COLOR_TAB,
+	PLUTO_COLOR_TAB
 
 /*------------------------------ Global Data ------------------------------ */
 
@@ -350,5 +332,9 @@ enum
 
 extern const PlanetFrame *PlanData;
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _PLANDATA_H */
 
diff -ruNp src.hd/uqm/planets/planets.c src/uqm/planets/planets.c
--- src.hd/uqm/planets/planets.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/planets.c	2017-12-29 00:57:49 -0800
@@ -34,6 +34,7 @@
 #include "options.h"
 #include "libs/graphics/gfx_common.h"
 
+
 // PlanetOrbitMenu() items
 enum PlanetMenuItems
 {
@@ -58,8 +59,6 @@ CreatePlanetContext (void)
 
 	assert (PlanetContext == NULL);
 
-	LockMutex (GraphicsLock);
-
 	// PlanetContext rect is relative to SpaceContext
 	oldContext = SetContext (SpaceContext);
 	GetContextClipRect (&r);
@@ -71,7 +70,6 @@ CreatePlanetContext (void)
 	SetContextClipRect (&r);
 
 	SetContext (oldContext);
-	UnlockMutex (GraphicsLock);
 }
 
 static void
@@ -266,15 +264,13 @@ LoadPlanet (FRAME SurfDefFrame)
 
 	if (WaitMode)
 	{
-		LockMutex (GraphicsLock);
 		DrawOrbitalDisplay (DRAW_ORBITAL_WAIT);
-		UnlockMutex (GraphicsLock);
 	}
 
 	StopMusic ();
 
 	pPlanetDesc = pSolarSysState->pOrbitalDesc;
-	GeneratePlanetSurface (pPlanetDesc, SurfDefFrame);
+	GeneratePlanetSurface (pPlanetDesc, SurfDefFrame, MAP_WIDTH, MAP_HEIGHT, TRUE);
 	SetPlanetMusic (pPlanetDesc->data_index & ~PLANET_SHIELDED);
 	GeneratePlanetSide ();
 
@@ -284,15 +280,11 @@ LoadPlanet (FRAME SurfDefFrame)
 	if (WaitMode)
 	{
 		ZoomInPlanetSphere ();
-		LockMutex (GraphicsLock);
 		DrawOrbitalDisplay (DRAW_ORBITAL_UPDATE);
-		UnlockMutex (GraphicsLock);
 	}
 	else
 	{
-		LockMutex (GraphicsLock);
 		DrawOrbitalDisplay (DRAW_ORBITAL_FULL);
-		UnlockMutex (GraphicsLock);
 	}
 }
 
@@ -305,7 +297,6 @@ FreePlanet (void)
 	UninitSphereRotation ();
 
 	StopMusic ();
-	LockMutex (GraphicsLock);
 
 	for (i = 0; i < sizeof (pSolarSysState->PlanetSideFrame)
 			/ sizeof (pSolarSysState->PlanetSideFrame[0]); ++i)
@@ -369,7 +360,6 @@ FreePlanet (void)
 	DestroyPlanetContext ();
 	DestroyScanContext ();
 
-	UnlockMutex (GraphicsLock);
 }
 
 void
@@ -407,9 +397,7 @@ DoPlanetOrbit (MENU_STATE *pMS)
 	if (!select)
 		return TRUE;
 
-	LockMutex (GraphicsLock);
 	SetFlashRect (NULL);
-	UnlockMutex (GraphicsLock);
 
 	switch (pMS->CurState)
 	{
@@ -447,9 +435,7 @@ DoPlanetOrbit (MENU_STATE *pMS)
 			// Deactivate planet rotation
 			oldCallback = SetInputCallback (NULL);
 
-			LockMutex (GraphicsLock);
 			RepairSISBorder ();
-			UnlockMutex (GraphicsLock);
 
 			AutoPilotSet = StarMap ();
 			if (GLOBAL (CurrentActivity) & CHECK_ABORT)
@@ -460,9 +446,7 @@ DoPlanetOrbit (MENU_STATE *pMS)
 
 			if (!AutoPilotSet)
 			{	// Redraw the orbital display
-				LockMutex (GraphicsLock);
 				DrawOrbitalDisplay (DRAW_ORBITAL_FULL);
-				UnlockMutex (GraphicsLock);
 				break;
 			}
 			// Fall through !!!
@@ -479,9 +463,7 @@ DoPlanetOrbit (MENU_STATE *pMS)
 				pMS->CurState = NAVIGATION;
 			DrawMenuStateStrings (PM_SCAN, pMS->CurState);
 		}
-		LockMutex (GraphicsLock);
 		SetFlashRect (SFR_MENU_3DO);
-		UnlockMutex (GraphicsLock);
 	}
 
 	return TRUE;
@@ -490,9 +472,7 @@ DoPlanetOrbit (MENU_STATE *pMS)
 static void
 on_input_frame (void)
 {
-	LockMutex (GraphicsLock);
 	RotatePlanetSphere (TRUE);
-	UnlockMutex (GraphicsLock);
 }
 
 void
@@ -504,9 +484,7 @@ PlanetOrbitMenu (void)
 	memset (&MenuState, 0, sizeof MenuState);
 
 	DrawMenuStateStrings (PM_SCAN, SCAN);
-	LockMutex (GraphicsLock);
 	SetFlashRect (SFR_MENU_3DO);
-	UnlockMutex (GraphicsLock);
 
 	MenuState.CurState = SCAN;
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
@@ -517,8 +495,6 @@ PlanetOrbitMenu (void)
 
 	SetInputCallback (oldCallback);
 
-	LockMutex (GraphicsLock);
 	SetFlashRect (NULL);
-	UnlockMutex (GraphicsLock);
 	DrawMenuStateStrings (PM_STARMAP, -NAVIGATION);
 }
diff -ruNp src.hd/uqm/planets/planets.h src/uqm/planets/planets.h
--- src.hd/uqm/planets/planets.h	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/planets.h	2017-12-29 00:57:49 -0800
@@ -16,17 +16,17 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #ifndef _PLANETS_H
 #define _PLANETS_H
 
+#include "libs/mathlib.h"
+
 #define END_INTERPLANETARY START_INTERPLANETARY
 
-#define ORBITING_PLANETS TRUE
-#define ROTATING_PLANETS optRotatingIpPlanets
-#define TEXTURED_PLANETS (optTexturedIpPlanets || ROTATING_PLANETS)
-// TEXTURED_PLANETS should always be defined TRUE if ROTATING_PLANETS is.
+#define ORBITING_PLANETS optOrbitingPlanets
+#define TEXTURED_PLANETS optTexturedPlanets
+#define ROTATING_PLANETS TEXTURED_PLANETS
+// ROTATING_PLANETS should always be defined TRUE if TEXTURED_PLANETS is.
 #define ONE_YEAR 365.25
 #ifndef M_PI
 #define M_PI 3.141592653589
@@ -65,7 +65,8 @@ enum
 	LANDER_DESTROYED
 };
 
-#define MAX_SCROUNGED 50 /* max lander can hold */
+#define MAX_SCROUNGED 50 /* max units lander can hold (was 64 in SC2 DOS) */
+#define MAX_HOLD_BARS 50 /* number of bars on the lander screen */
 
 #define SCALE_RADIUS(r) ((r) << 6)
 #define UNSCALE_RADIUS(r) ((r) >> 6)
@@ -99,6 +100,7 @@ enum
 
 typedef struct planet_desc PLANET_DESC;
 typedef struct star_desc STAR_DESC;
+typedef struct node_info NODE_INFO;
 typedef struct planet_orbit PLANET_ORBIT;
 typedef struct solarsys_state SOLARSYS_STATE;
 
@@ -111,7 +113,7 @@ typedef struct solarsys_state SOLARSYS_S
 #include "lifeform.h"
 #include "plandata.h"
 #include "sundata.h"
-
+ 
 typedef struct 
 {
 	POINT p[4];
@@ -147,6 +149,10 @@ struct planet_orbit
 	// doubly dynamically allocated depending on map size
 };
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 struct planet_desc
 {
 	DWORD rand_seed;
@@ -182,7 +188,26 @@ struct star_desc
 	BYTE Postfix;
 };
 
-typedef void (*PLAN_GEN_FUNC) (BYTE control);
+struct node_info
+{
+	// This structire is filled in when a generateMinerals, generateEnergy,
+	// or generateLife call is made.
+	POINT loc_pt;
+			// Position of the mineral/bio/energy node on the planet.
+	COUNT density;
+			// For bio and energy: undefined
+			// For minerals the low byte is the gross size of the
+			// deposit (this determines the image), and the high
+			// byte is the fine size (the actual quantity).
+	COUNT type;
+			// For minerals: the type of element
+			// For bio: the type of the creature.
+			//          0 through NUM_CREATURE_TYPES - 1 are normal creatures,
+			//          NUM_CREATURE_TYPES     is an Evil One
+			//          NUM_CREATURE_TYPES + 1 is a Brainbox Bulldozer
+			//          NUM_CREATURE_TYPES + 2 is Zex' Beauty
+			// For energy: undefined
+};
 
 // See doc/devel/generate for information on how this structure is
 // filled.
@@ -261,6 +286,9 @@ extern SOLARSYS_STATE *pSolarSysState;
 extern MUSIC_REF SpaceMusic;
 extern CONTEXT PlanetContext;
 
+// Random context used for all solar system, planets and surfaces generation
+extern RandomContext *SysGenRNG;
+
 bool playerInSolarSystem (void);
 bool playerInPlanetOrbit (void);
 bool playerInInnerSystem (void);
@@ -272,6 +300,8 @@ COUNT moonIndex (const SOLARSYS_STATE *s
 bool matchWorld (const SOLARSYS_STATE *solarSys, const PLANET_DESC *world,
 		BYTE planetI, BYTE moonI);
 
+DWORD GetRandomSeedForStar (const STAR_DESC *star);
+
 POINT locationToDisplay (POINT pt, SIZE scaleRadius);
 POINT displayToLocation (POINT pt, SIZE scaleRadius);
 POINT planetOuterLocation (COUNT planetI);
@@ -285,7 +315,6 @@ extern void FreeLanderFont (PLANET_INFO
 extern void ExploreSolarSys (void);
 extern void DrawStarBackGround (void);
 extern void XFormIPLoc (POINT *pIn, POINT *pOut, BOOLEAN ToDisplay);
-extern PLAN_GEN_FUNC GenerateIP (BYTE Index);
 extern void DrawOval (RECT *pRect, BYTE num_off_pixels);
 extern void DrawFilledOval (RECT *pRect);
 extern void ComputeSpeed(PLANET_DESC *planet, BOOLEAN GeneratingMoons, UWORD rand_val);
@@ -295,8 +324,7 @@ extern void InitLander (BYTE LanderFlags
 
 extern void InitSphereRotation (int direction, BOOLEAN shielded, COUNT width, COUNT height);
 extern void UninitSphereRotation (void);
-extern void PrepareNextRotationFrame (void);
-extern void PrepareNextRotationFrameForIP (PLANET_DESC *pPlanetDesc, SIZE frameCounter);
+extern void PrepareNextRotationFrame (PLANET_DESC *pPlanetDesc, SIZE frameCounter, BOOLEAN inOrbit);
 extern void DrawPlanetSphere (int x, int y);
 extern void DrawDefaultPlanetSphere (void);
 extern void RenderPlanetSphere (PLANET_ORBIT *Orbit, FRAME Frame, int offset, BOOLEAN shielded, BOOLEAN doThrob, COUNT width, COUNT height, COUNT radius);
@@ -307,9 +335,7 @@ extern void RotatePlanetSphere (BOOLEAN
 
 extern void DrawScannedObjects (BOOLEAN Reversed);
 extern void GeneratePlanetSurface (PLANET_DESC *pPlanetDesc,
-		FRAME SurfDefFrame);
-extern void GeneratePlanetSurfaceForIP (PLANET_DESC *pPlanetDesc,
-		FRAME SurfDefFrame, COUNT width, COUNT height);
+		FRAME SurfDefFrame, COUNT width, COUNT height, BOOLEAN inOrbit);
 extern void DeltaTopography (COUNT num_iterations, SBYTE *DepthArray,
 		RECT *pRect, SIZE depth_delta);
 
@@ -321,5 +347,9 @@ extern void GetPlanetOrMoonName (UNICODE
 extern void PlanetOrbitMenu (void);
 extern void SaveSolarSysLocation (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _PLANETS_H */
 
diff -ruNp src.hd/uqm/planets/plangen.c src/uqm/planets/plangen.c
--- src.hd/uqm/planets/plangen.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/plangen.c	2017-12-29 00:57:49 -0800
@@ -35,6 +35,7 @@
 #include <math.h>
 #include <time.h>
 
+
 #undef PROFILE_ROTATION
 
 // define USE_ALPHA_SHIELD to use an aloha overlay instead of
@@ -98,20 +99,15 @@ typedef struct
 	double x, y, z;
 } POINT3;
 
-// BW : changed rendering method to direct SDL routines like in
-// RenderPlanetSphere to improve performance at 4x
 static void
 RenderTopography (FRAME DstFrame, SBYTE *pTopoData, int w, int h, BOOLEAN SurfDef)
 {
-	if (pSolarSysState->XlatRef == 0)
-	{
+	if (pSolarSysState->XlatRef == 0) {
 		// There is currently nothing we can do w/o an xlat table
 		// This is still called for Earth for 4x scaled topo, but we
 		// do not need it because we cannot land on Earth.
 		log_add(log_Warning, "No xlat table -- could not generate surface.\n");
-	}
-	else
-	{
+	} else {
 		BYTE AlgoType;
 		SIZE base, d;
 		const XLAT_DESC *xlatDesc;
@@ -127,19 +123,14 @@ RenderTopography (FRAME DstFrame, SBYTE
 		map = HMalloc (sizeof (Color) * w * h);
 		pix = map;
 
-		PlanDataPtr = &PlanData[
-				pSolarSysState->pOrbitalDesc->data_index & ~PLANET_SHIELDED
-				];
+		PlanDataPtr = &PlanData[pSolarSysState->pOrbitalDesc->data_index & ~PLANET_SHIELDED];
 		AlgoType = PLANALGO (PlanDataPtr->Type);
-		if (SurfDef)
-			{
-				// Planets given by a pixmap have elevations between -128 and +128
-				base = 256;
-			}
-		else
-			{
-				base = PlanDataPtr->base_elevation;
-			}
+		if (SurfDef) {
+			// Planets given by a pixmap have elevations between -128 and +128
+			base = 256;
+		} else {
+			base = PlanDataPtr->base_elevation;
+		}
 		xlatDesc = (const XLAT_DESC *) pSolarSysState->XlatPtr;
 		xlat_tab = (const BYTE *) xlatDesc->xlat_tab;
 		cbase = GetColorMapAddress (pSolarSysState->OrbitalCMap);
@@ -151,24 +142,21 @@ RenderTopography (FRAME DstFrame, SBYTE
 			ColorShift = 1;
 
 		pSrc = pTopoData;
-		for (pt.y = 0; pt.y < h; ++pt.y)
-		{
-			for (pt.x = 0; pt.x < w; ++pt.x, ++pSrc, ++pix)
-			{
+		for (pt.y = 0; pt.y < h; ++pt.y) {
+			for (pt.x = 0; pt.x < w; ++pt.x, ++pSrc, ++pix) {
 				BYTE *ctab;
 
 				d = *pSrc;
-				if (AlgoType == GAS_GIANT_ALGO)
-				{	// make elevation value non-negative
+				if (AlgoType == GAS_GIANT_ALGO) {	
+					// make elevation value non-negative
 					d &= 255;
-				}
-				else
-				{
+				} else {
 					d += base;
-					if (d < 0)
+					if (d < 0){
 						d = 0;
-					else if (d > 255)
+					} else if (d > 255) {
 						d = 255;
+					}
 				}
 
 				d = xlat_tab[d] - cbase[0];
@@ -177,10 +165,9 @@ RenderTopography (FRAME DstFrame, SBYTE
 				// fixed planet surfaces being too dark
 				// ctab shifts were previously >> 3 .. -Mika
 				*pix = BUILD_COLOR (MAKE_RGB15 (ctab[0] >> ColorShift, 
-					ctab[1] >> ColorShift, ctab[2] >> ColorShift), d);				
+					ctab[1] >> ColorShift, ctab[2] >> ColorShift), d);		
 			}
 		}
-
 		WriteFramePixelColors (DstFrame, map, w, h);
 		HFree(map);
 	}
@@ -500,38 +487,36 @@ CreateSphereTiltMap (int angle, COUNT he
 // this routine, but a filter can be applied if desired too.
 
 // HALO rim size
-#define SHIELD_HALO          (7 << RESOLUTION_FACTOR) // JMS_GFX
+#define SHIELD_HALO          (6 << RESOLUTION_FACTOR) // JMS_GFX
 #define SHIELD_RADIUS        (RADIUS + SHIELD_HALO)
-#define SHIELD_DIAM          ((SHIELD_RADIUS << 1) + 1)
-#define SHIELD_RADIUS_2      (SHIELD_RADIUS * SHIELD_RADIUS)
-#define SHIELD_RADIUS_THRES  ((SHIELD_RADIUS + (1 << RESOLUTION_FACTOR)) * (SHIELD_RADIUS + (1 << RESOLUTION_FACTOR))) // JMS_GFX
 #define SHIELD_HALO_GLOW     (SHIELD_GLOW_COMP + SHIELD_REFLECT_COMP)
 #define SHIELD_HALO_GLOW_MIN (SHIELD_HALO_GLOW >> 2)
 
 static FRAME
-CreateShieldMask (COUNT radius)
+CreateShieldMask (COUNT Radius)
 {
-	Color clear;
-	Color *pix;
+	Color clear, *pix;
 	int x, y;
 	FRAME ShieldFrame;
+
 	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
-	COUNT shieldradius = SHIELD_RADIUS * radius / RADIUS;
-	COUNT shielddiam = (shieldradius << 1) + 1;
-	COUNT radius_2 = radius * radius;
-	COUNT shieldradius_thres = (shieldradius + 1) * (shieldradius + 1);
 	
+	COUNT ShieldRadius = SHIELD_RADIUS * Radius / RADIUS;
+	COUNT ShieldDiam = (ShieldRadius << 1) + 1;
+	COUNT RadiusSquared = Radius * Radius;
+	COUNT ShieldRadiusThreshold = (ShieldRadius + 1) * (ShieldRadius + 1);
+
 	ShieldFrame = CaptureDrawable (
 			CreateDrawable (WANT_PIXMAP | WANT_ALPHA,
-				shielddiam, shielddiam, 1));
+				ShieldDiam, ShieldDiam, 1));
 
 	pix = Orbit->ScratchArray;
 	//  This is 100% transparent.
 	clear = BUILD_COLOR_RGBA (0, 0, 0, 0);
 
-	for (y = -shieldradius; y <= shieldradius; y++)
+	for (y = -ShieldRadius; y <= ShieldRadius; y++)
 	{
-		for (x = -shieldradius; x <= shieldradius; ++x, ++pix)
+		for (x = -ShieldRadius; x <= ShieldRadius; ++x, ++pix)
 		{
 			int rad_2 = x * x + y * y;
 			// This is a non-transparent red for the halo
@@ -539,13 +524,13 @@ CreateShieldMask (COUNT radius)
 			int alpha = 255;
 			double rad;
 			
-			if (rad_2 >= shieldradius_thres)
+			if (rad_2 >= ShieldRadiusThreshold)
 			{	// outside all bounds
 				*pix = clear;
 				continue;
 			}
 			// Inside the halo
-			if (rad_2 <= radius_2)
+			if (rad_2 <= RadiusSquared)
 			{	// planet's pixels, ours transparent
 				*pix = clear;
 				continue;
@@ -554,16 +539,16 @@ CreateShieldMask (COUNT radius)
 			// The halo itself
 			rad = sqrt (rad_2);
 
-			if (rad <= radius + 0.8)
+			if (rad <= Radius + 0.8)
 			{	// pixels common between the shield and planet
 				// do antialiasing using alpha
-				alpha = (int) (red * (rad - radius));
+				alpha = (int) (red * (rad - Radius));
 				red = 255;
 			}
 			else
 			{	// shield pixels
-				red -= (int) ((red - SHIELD_HALO_GLOW_MIN) * (rad - radius)
-					      / (SHIELD_HALO * radius / RADIUS));
+				red -= (int) ((red - SHIELD_HALO_GLOW_MIN) * (rad - Radius) / (SHIELD_HALO * Radius / RADIUS));
+				
 				if (red < 0)
 					red = 0;
 			}
@@ -573,9 +558,9 @@ CreateShieldMask (COUNT radius)
 	}
 	
 	WriteFramePixelColors (ShieldFrame, Orbit->ScratchArray,
-			shielddiam, shielddiam);
-	SetFrameHot (ShieldFrame, MAKE_HOT_SPOT (shieldradius + 1,
-				shieldradius + 1));
+			ShieldDiam, ShieldDiam);
+	SetFrameHot (ShieldFrame, MAKE_HOT_SPOT (ShieldRadius + 1,
+				ShieldRadius + 1));
 	
 	return ShieldFrame;
 }
@@ -592,15 +577,13 @@ CreateShieldMask (COUNT radius)
 #define THROB_D_LEVEL   (THROB_MAX_LEVEL - THROB_MIN_LEVEL)
 
 static inline int
-shield_level (int offset, int width)
+shield_level (int offset)
 {
 	int level;
-	int throb_cycle = ((width << 8) / SHIELD_THROBS);
-	int throb_half_cycle = throb_cycle >> 1;
-	
-	offset = (offset << 8) % throb_cycle;
-	level = abs (offset - throb_half_cycle);
-	level = THROB_MIN_LEVEL + level * THROB_D_LEVEL / throb_half_cycle;
+
+	offset = (offset << 8) % THROB_CYCLE;
+	level = abs (offset - THROB_HALF_CYCLE);
+	level = THROB_MIN_LEVEL + level * THROB_D_LEVEL / THROB_HALF_CYCLE;
 
 	return level;
 }
@@ -617,9 +600,9 @@ SetShieldThrobEffect (FRAME ShieldFrame,
 	int level;
 
 	width = GetFrameWidth (ShieldFrame);
-	height = GetFrameHeight (ShieldFrame);
+	height = GetFrameHeight (ShieldFrame);	
 
-	level = shield_level (offset, width);
+	level = shield_level (offset);
 
 	ReadFramePixelColors (ShieldFrame, Orbit->ScratchArray, width, height);
 	
@@ -717,6 +700,7 @@ RenderPlanetSphere (PLANET_ORBIT *Orbit,
 	Color *pixels;
 	SBYTE *elevs;
 	int shLevel;
+
 	COUNT spherespanx = height;
 	COUNT tworadius = radius << 1;
 	COUNT diameter = tworadius + 1;
@@ -729,7 +713,7 @@ RenderPlanetSphere (PLANET_ORBIT *Orbit,
 #endif
 
 
-	shLevel = shield_level (offset, width);
+	shLevel = shield_level (offset);
 
 	pix = Orbit->ScratchArray;
 	clear = BUILD_COLOR_RGBA (0, 0, 0, 0);
@@ -863,13 +847,14 @@ DitherMap (SBYTE *DepthArray, COUNT widt
 
 static void
 MakeCrater (RECT *pRect, SBYTE *DepthArray, SIZE rim_delta, SIZE
-	    crater_delta, BOOLEAN SetDepth, COUNT width)
+		crater_delta, BOOLEAN SetDepth, COUNT width)
 {
 	COORD x, y, lf_x, rt_x;
 	SIZE A, B;
 	SDWORD Asquared, TwoAsquared, Bsquared, TwoBsquared;	// JMS_GFX: Was 'long' - type changed to conform to UQM's own types
 	SDWORD d, dx, dy;									// JMS_GFX: Was 'long' - type changed to conform to UQM's own types
-	DWORD TopIndex, BotIndex, rim_pixels;				// JMS_GFX: Was COUNT - type changed because of overflow at 4x
+	DWORD TopIndex, BotIndex, rim_pixels; // JMS_GFX: Was COUNT - type changed because of overflow at 4x
+ 
 
 	A = pRect->extent.width >> 1;
 	B = pRect->extent.height >> 1;
@@ -1075,11 +1060,10 @@ MakeStorms (COUNT storm_count, SBYTE *De
 
 			intersect = FALSE;
 
-			rand_val = TFB_Random ();
+			rand_val = RandomContext_Random (SysGenRNG);
 			loword = LOWORD (rand_val);
 			hiword = HIWORD (rand_val);
-			switch (HIBYTE (hiword) & 31)
-			{
+			switch (HIBYTE (hiword) & 31) {
 				case 0:
 					pstorm_r->extent.height = (LOBYTE (hiword) % (ORIGINAL_MAP_HEIGHT >> 2)) + (ORIGINAL_MAP_HEIGHT >> 2);
 					break;
@@ -1097,20 +1081,20 @@ MakeStorms (COUNT storm_count, SBYTE *De
 			if (pstorm_r->extent.height <= 4)
 				pstorm_r->extent.height += 4;
 
-			rand_val = TFB_Random ();
+			rand_val = RandomContext_Random (SysGenRNG);
 			loword = LOWORD (rand_val);
 			hiword = HIWORD (rand_val);
 
 			pstorm_r->extent.width = pstorm_r->extent.height + (LOBYTE (loword) % pstorm_r->extent.height);
 
-			pstorm_r->corner.x = HIBYTE (loword) % (ORIGINAL_MAP_WIDTH - pstorm_r->extent.width);			
+			pstorm_r->corner.x = HIBYTE (loword) % (ORIGINAL_MAP_WIDTH - pstorm_r->extent.width);
 			pstorm_r->corner.y = LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT - pstorm_r->extent.height);
 
 			pstorm_r->corner.x = pstorm_r->corner.x * width / ORIGINAL_MAP_WIDTH;
 			pstorm_r->extent.width = pstorm_r->extent.width * width / ORIGINAL_MAP_WIDTH;
 			pstorm_r->corner.y = pstorm_r->corner.y * height / ORIGINAL_MAP_HEIGHT;
 			pstorm_r->extent.height = pstorm_r->extent.height * height / ORIGINAL_MAP_HEIGHT;
-			
+
 			for (j = i + 1; j < storm_count; ++j)
 			{
 				COORD x, y;
@@ -1186,13 +1170,13 @@ MakeGasGiant (COUNT num_bands, SBYTE *De
 	band_error = num_bands >> 1;
 	lpDst = DepthArray;
 
-	band_delta = ((LOWORD (TFB_Random ()) & (NUM_BAND_COLORS - 1)) << RANGE_SHIFT) + (1 << (RANGE_SHIFT - 1));
+	band_delta = ((LOWORD (RandomContext_Random (SysGenRNG)) & (NUM_BAND_COLORS - 1)) << RANGE_SHIFT) + (1 << (RANGE_SHIFT - 1));
 	last_y = next_y = 0;
 	for (i = num_bands; i > 0; --i)
 	{
 		COORD cur_y;
 
-		rand_val = TFB_Random ();
+		rand_val = RandomContext_Random (SysGenRNG);
 		loword = LOWORD (rand_val);
 		hiword = HIWORD (rand_val);
 
@@ -1203,7 +1187,7 @@ MakeGasGiant (COUNT num_bands, SBYTE *De
 			band_error += num_bands;
 		}
 		if (i == 1)
-		        cur_y = pRect->extent.height;
+			cur_y = pRect->extent.height;
 		else
 		{
 			RECT r;
@@ -1212,19 +1196,18 @@ MakeGasGiant (COUNT num_bands, SBYTE *De
 			cur_y = cur_y * pRect->extent.height / ORIGINAL_MAP_HEIGHT;
 			r.corner.x = r.corner.y = 0;
 			r.extent.width = pRect->extent.width;
-			// r.extent.height = 5;
 			r.extent.height = 5 * pRect->extent.height / ORIGINAL_MAP_HEIGHT;
 			DeltaTopography (50,
-					 &DepthArray[(cur_y - (r.extent.height >>1)) * r.extent.width],
+					&DepthArray[(cur_y - (r.extent.height >>1)) * r.extent.width],
 					&r, depth_delta);
 		}
 
-		for (j = cur_y - last_y; j > 0; --j)
-		{
+		for (j = cur_y - last_y; j > 0; --j) {
 			COUNT k;
 
-			for (k = pRect->extent.width; k > 0; --k)
+			for (k = pRect->extent.width; k > 0; --k){
 				*lpDst++ += band_delta;
+			}
 		}
 
 		last_y = cur_y;
@@ -1244,7 +1227,7 @@ ValidateMap (SBYTE *DepthArray, COUNT wi
 	BYTE state;
 	BYTE pixel_count[2], lb[2];
 	SBYTE last_byte;
-	DWORD i;  // JMS_GFX: changed from COUNT to avoid overflow at higher resolutions.
+	DWORD i;
 	SBYTE *lpDst;
 
 	i = width - 1;
@@ -1292,35 +1275,33 @@ ValidateMap (SBYTE *DepthArray, COUNT wi
 }
 
 static void
-planet_orbit_init (COUNT width, COUNT height, BOOLEAN forOrbit)
+PlanetOrbitInit (COUNT width, COUNT height, BOOLEAN inOrbit)
 {
 	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
-	COUNT spherespanx = height;
-	COUNT shieldradius = (height >> 1) * SHIELD_RADIUS / RADIUS;
-	COUNT shielddiam = (shieldradius << 1) + 1;
-	COUNT diameter = height + 1;
+	COUNT ShieldRadius = (height >> 1) * SHIELD_RADIUS / RADIUS;
+	COUNT ShieldDiam = (ShieldRadius << 1) + 1;
+	COUNT Diameter = height + 1;	
+	COUNT SphereSpanX = height;
 	COUNT i;
-	
+
+
 	Orbit->SphereFrame = CaptureDrawable (CreateDrawable (
-			WANT_PIXMAP | WANT_ALPHA, diameter, diameter, 2));
+			WANT_PIXMAP | WANT_ALPHA, Diameter, Diameter, 2));
 	Orbit->ObjectFrame = 0;
 	Orbit->WorkFrame = 0;
 	Orbit->lpTopoData = HCalloc (width * height);
-	Orbit->TopoColors = HMalloc (sizeof (Orbit->TopoColors[0])
-			* (height * (width + spherespanx)));
+	Orbit->TopoColors = HMalloc (sizeof (Orbit->TopoColors[0]) 
+		* (height * (width + SphereSpanX)));
 	// always allocate the scratch array to largest needed size
-	Orbit->ScratchArray = HMalloc (sizeof (Orbit->ScratchArray[0])
-			* (shielddiam) * (shielddiam));
-	Orbit->light_diff = HMalloc (sizeof (DWORD *) * diameter);
-	Orbit->map_rotate = HMalloc (sizeof (MAP3D_POINT *) * diameter);
-	for (i=0 ; i < diameter ; i++)
-	{
-		Orbit->light_diff[i] = HMalloc (sizeof (DWORD)* diameter);
-		Orbit->map_rotate[i] = HMalloc (sizeof (MAP3D_POINT) * diameter);
+	Orbit->ScratchArray = HMalloc (sizeof (Orbit->ScratchArray[0]) * (ShieldDiam) * (ShieldDiam));
+	Orbit->light_diff = HMalloc (sizeof (DWORD *) * Diameter);
+	Orbit->map_rotate = HMalloc (sizeof (MAP3D_POINT *) * Diameter);
+	for (i=0 ; i < Diameter ; i++) {
+		Orbit->light_diff[i] = HMalloc (sizeof (DWORD)* Diameter);
+		Orbit->map_rotate[i] = HMalloc (sizeof (MAP3D_POINT) * Diameter);
 	}
 
-	if (forOrbit)
-	{
+	if (inOrbit){
 		Orbit->TintFrame = CaptureDrawable (CreateDrawable (
 				WANT_PIXMAP, width, height, 1));
 		Orbit->TopoZoomFrame = CaptureDrawable (CreateDrawable (
@@ -1559,7 +1540,7 @@ TopoScale4x (SBYTE *pDstTopo, SBYTE *pSr
 // Lots of pure Voodoo here ;)
 //  the goal is a 3D illusion, not mathematically correct lighting
 
-#define LMAP_AVG_BLOCK    ((75 + 4) / 5) // BW: hacky but this shouldn't really depend on the size of the original map
+#define LMAP_AVG_BLOCK     ((75 + 4) / 5) // BW: hacky but this shouldn't really depend on the size of the original map
 #define LMAP_MAX_DIST     ((LMAP_AVG_BLOCK + 1) >> 1)
 #define LMAP_WEIGHT_THRES (LMAP_MAX_DIST * 2 / 3)
 
@@ -1621,17 +1602,16 @@ static void
 GenerateLightMap (SBYTE *pTopo, int w, int h)
 {
 #define LMAP_BLOCKS       (2 * LMAP_MAX_DIST + 1)
-	
 	int x, y;
-	
+
 	SBYTE *elev;
 	int min, max, med;
 	int sfact, spread;
-	
+
 	elev_block_t vblocks[LMAP_BLOCKS];
 	// we use a running block average to reduce the amount of work
 	// where a block is a vertical line of map points
-	
+
 	// normalize the topo data
 	min = 127;
 	max = -128;
@@ -1739,26 +1719,31 @@ GenerateLightMap (SBYTE *pTopo, int w, i
 }
 
 void
-GeneratePlanetSurface (PLANET_DESC *pPlanetDesc, FRAME SurfDefFrame)
-{
+GeneratePlanetSurface (PLANET_DESC *pPlanetDesc, FRAME SurfDefFrame, COUNT Width, COUNT Height, BOOLEAN inOrbit) {
 	RECT r;
-	DWORD old_seed;
 	const PlanetFrame *PlanDataPtr;
 	PLANET_INFO *PlanetInfo = &pSolarSysState->SysInfo.PlanetInfo;
-	DWORD i, y;  // JMS_GFX: changed from COUNT to avoid overflow at higher resolutions.
+	DWORD i, y; 
 	POINT loc;
-	CONTEXT OldContext;
-	CONTEXT TopoContext;
+	COUNT SphereSpanX, Radius;
+	CONTEXT OldContext, TopoContext;
 	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
 	BOOLEAN SurfDef = FALSE;
 	BOOLEAN shielded = (pPlanetDesc->data_index & PLANET_SHIELDED) != 0;
 
-	old_seed = TFB_SeedRandom (pPlanetDesc->rand_seed);
+	/*if(!inOrbit){
+		Width = Width << RESOLUTION_FACTOR;
+		Height = Height << RESOLUTION_FACTOR;
+	}*/
+	
+	SphereSpanX = (inOrbit ? SPHERE_SPAN_X : Height);
+	Radius = (inOrbit ? RADIUS : ((SphereSpanX >> 1) - RESOLUTION_FACTOR)) ;
+
+	RandomContext_SeedRandom (SysGenRNG, pPlanetDesc->rand_seed);
 
 	TopoContext = CreateContext ("Plangen.TopoContext");
-	LockMutex (GraphicsLock);
 	OldContext = SetContext (TopoContext);
-	planet_orbit_init (MAP_WIDTH, (MAP_HEIGHT+1), TRUE); // JMS_GFX: Was MAP_HEIGHT without the +1. Added this to avoid overflows.
+	PlanetOrbitInit (Width, Height, inOrbit);
 
 	PlanDataPtr = &PlanData[pPlanetDesc->data_index & ~PLANET_SHIELDED];
 
@@ -1772,11 +1757,11 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 		// surface pixmap
 		SurfDef = TRUE;
 		SurfDefFrame = SetAbsFrameIndex (SurfDefFrame, 0);
-		if (GetFrameWidth (SurfDefFrame) != MAP_WIDTH
-				|| GetFrameHeight (SurfDefFrame) != MAP_HEIGHT)
+		if (GetFrameWidth (SurfDefFrame) != Width
+				|| GetFrameHeight (SurfDefFrame) != Height)
 		{
 			pSolarSysState->TopoFrame = CaptureDrawable (RescaleFrame (
-					SurfDefFrame, MAP_WIDTH, MAP_HEIGHT, FALSE));
+					SurfDefFrame, Width, Height, FALSE));
 			// will not need the passed FRAME anymore
 			DeleteDef = TRUE;
 		}
@@ -1789,55 +1774,45 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 			SBYTE* elev;
 
 			ElevFrame = SetAbsFrameIndex (SurfDefFrame, 1);
-			if (GetFrameWidth (ElevFrame) != MAP_WIDTH
-					|| GetFrameHeight (ElevFrame) != MAP_HEIGHT)
+			if (GetFrameWidth (ElevFrame) != Width
+					|| GetFrameHeight (ElevFrame) != Height)
 			{
 				ElevFrame = CaptureDrawable (RescaleFrame (ElevFrame,
-						MAP_WIDTH, MAP_HEIGHT, TRUE));
+						Width, Height, TRUE));
 				DeleteElev = TRUE;
 			}
 
 			// grab the elevation data in 1 byte per pixel format
 			ReadFramePixelIndexes (ElevFrame, (BYTE *)Orbit->lpTopoData,
-					MAP_WIDTH, MAP_HEIGHT, TRUE);
+					Width, Height, inOrbit);
 			// the supplied data is in unsigned format, must convert
-			for (i = 0, elev = Orbit->lpTopoData;
-					i < MAP_WIDTH * MAP_HEIGHT;
-					++i, ++elev)
-			{
+			for (i = 0, elev = Orbit->lpTopoData; i < Width * Height; ++i, ++elev) {
 				*elev = *(BYTE *)elev - 128;
 			}
 		}
 		else
 		{	// no elevation data -- planet flat as a pancake
-			memset (Orbit->lpTopoData, 0, MAP_WIDTH * MAP_HEIGHT);
+			memset (Orbit->lpTopoData, 0, Width * Height);
 		}
-		
+
 		// JMS: Planets with special colormaps
-		if (pPlanetDesc->alternate_colormap)
-		{
+		if (pPlanetDesc->alternate_colormap) {
 			pSolarSysState->OrbitalCMap = CaptureColorMap (
 				LoadColorMap (pPlanetDesc->alternate_colormap));
 			pSolarSysState->XlatRef = CaptureStringTable (
 				LoadStringTable (SPECIAL_CMAP_XLAT_TAB));
-		}
-		// JMS: Normal planets
-		else
-		{
+		} else { // JMS: Normal planets
 			pSolarSysState->OrbitalCMap = CaptureColorMap (
 				LoadColorMap (PlanDataPtr->CMapInstance));
 			pSolarSysState->XlatRef = CaptureStringTable (
 				LoadStringTable (PlanDataPtr->XlatTabInstance));
 
-			if (PlanetInfo->SurfaceTemperature > HOT_THRESHOLD)
-			{
+			if (PlanetInfo->SurfaceTemperature > HOT_THRESHOLD) {
 				pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
 						pSolarSysState->OrbitalCMap, 2);
 				pSolarSysState->XlatRef = SetAbsStringTableIndex (
 						pSolarSysState->XlatRef, 2);
-			}
-			else if (PlanetInfo->SurfaceTemperature > COLD_THRESHOLD)
-			{
+			} else if (PlanetInfo->SurfaceTemperature > COLD_THRESHOLD) {
 				pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
 						pSolarSysState->OrbitalCMap, 1);
 				pSolarSysState->XlatRef = SetAbsStringTableIndex (
@@ -1855,14 +1830,15 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 	{	// Generate planet surface elevation data and look
 
 		r.corner.x = r.corner.y = 0;
-		r.extent.width = MAP_WIDTH;
-		r.extent.height = MAP_HEIGHT;
+		r.extent.width = Width;
+		r.extent.height = Height;
 		{
-			memset (Orbit->lpTopoData, 0, MAP_WIDTH * MAP_HEIGHT);
+			memset (Orbit->lpTopoData, 0, Width * Height);
 			switch (PLANALGO (PlanDataPtr->Type))
 			{
 				case GAS_GIANT_ALGO:
-					MakeGasGiant (PlanDataPtr->num_faults, Orbit->lpTopoData, &r, PlanDataPtr->fault_depth);
+					MakeGasGiant (PlanDataPtr->num_faults,
+							Orbit->lpTopoData, &r, PlanDataPtr->fault_depth);
 					break;
 				case TOPO_ALGO:
 				case CRATERED_ALGO:
@@ -1874,353 +1850,32 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 					for (i = 0; i < PlanDataPtr->num_blemishes; ++i)
 					{
 						RECT crater_r;
-						DWORD random_value; // JMS_GFX
 						UWORD loword;
-						// UWORD hiword; // JMS_GFX
-						// BW: reinstate original values...
-						
-						random_value = TFB_Random(); // JMS_GFX
-						loword = LOWORD (random_value); // JMS_GFX: Was loword = LOWORD (TFB_Random ());
-						switch (HIBYTE (loword) & 31)
-						{
-							case 0:
-								// if (RESOLUTION_FACTOR == 0)
-								crater_r.extent.width = (LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT >> 2)) + (ORIGINAL_MAP_HEIGHT >> 2);
-								// else
-								// 	crater_r.extent.width = (loword % (MAP_HEIGHT >> 2)) + (MAP_HEIGHT >> 2);
-								
-								break;
-							case 1:
-							case 2:
-							case 3:
-							case 4:
-								// if (RESOLUTION_FACTOR == 0)
-								crater_r.extent.width = (LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT >> 3)) + (ORIGINAL_MAP_HEIGHT >> 3);
-								// else
-								// 	crater_r.extent.width = (loword % (MAP_HEIGHT >> 3)) + (MAP_HEIGHT >> 3);
-								break;
-							default:
-								// if (RESOLUTION_FACTOR == 0)
-								crater_r.extent.width = (LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT >> 4)) + 4;
-								// else
-								// 	crater_r.extent.width = (loword % (MAP_HEIGHT >> 4)) + 4;
-								break;
-						}
-					
-						random_value = TFB_Random(); // JMS_GFX
-						loword = LOWORD (random_value); // JMS_GFX: Was loword = LOWORD (TFB_Random ());
-						// hiword = HIWORD (random_value); 
-						// JMS_GFX
-						crater_r.extent.height = crater_r.extent.width;	
-						crater_r.corner.x = HIBYTE (loword) % (ORIGINAL_MAP_WIDTH - crater_r.extent.width);
-						// crater_r.corner.x = loword % (MAP_WIDTH - crater_r.extent.width); // JMS_GFX: changed the previous line to this. BYTE was too small for 4x resolution
-						crater_r.corner.y = LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT - crater_r.extent.height);
-						// crater_r.corner.y = hiword % (MAP_HEIGHT - crater_r.extent.height); // JMS_GFX: The same
-						// BW: ... then scale them up
-						crater_r.extent.width = crater_r.extent.width * MAP_WIDTH / ORIGINAL_MAP_WIDTH;
-						crater_r.extent.height = crater_r.extent.width;
-						crater_r.corner.x = crater_r.corner.x * MAP_WIDTH / ORIGINAL_MAP_WIDTH;
-						crater_r.corner.y = crater_r.corner.y * MAP_HEIGHT / ORIGINAL_MAP_HEIGHT;
-						
-						MakeCrater (&crater_r, Orbit->lpTopoData,
-								PlanDataPtr->fault_depth << 2,
-								-(PlanDataPtr->fault_depth << 2),
-							    FALSE, MAP_WIDTH);
-					}
-
-					if (PLANALGO (PlanDataPtr->Type) == CRATERED_ALGO)
-						DitherMap (Orbit->lpTopoData, MAP_WIDTH, MAP_HEIGHT);
-					ValidateMap (Orbit->lpTopoData, MAP_WIDTH, MAP_HEIGHT);
-					break;
-			}
-		}
-		pSolarSysState->TopoFrame = CaptureDrawable (
-				CreateDrawable (WANT_PIXMAP, (SIZE)MAP_WIDTH,
-				(SIZE)MAP_HEIGHT, 1));
 				
-		// JMS: Planets with special colormaps
-		if (pPlanetDesc->alternate_colormap)
-		{
-			pSolarSysState->OrbitalCMap = CaptureColorMap (
-				LoadColorMap (pPlanetDesc->alternate_colormap));
-			pSolarSysState->XlatRef = CaptureStringTable (
-				LoadStringTable (SPECIAL_CMAP_XLAT_TAB));
-		}
-		// JMS: Normal planets
-		else
-		{
-			pSolarSysState->OrbitalCMap = CaptureColorMap (
-				LoadColorMap (PlanDataPtr->CMapInstance));
-			pSolarSysState->XlatRef = CaptureStringTable (
-				LoadStringTable (PlanDataPtr->XlatTabInstance));
-		}
-
-		if (PlanetInfo->SurfaceTemperature > HOT_THRESHOLD)
-		{
-			pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
-					pSolarSysState->OrbitalCMap, 2);
-			pSolarSysState->XlatRef = SetAbsStringTableIndex (
-					pSolarSysState->XlatRef, 2);
-		}
-		else if (PlanetInfo->SurfaceTemperature > COLD_THRESHOLD)
-		{
-			pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
-					pSolarSysState->OrbitalCMap, 1);
-			pSolarSysState->XlatRef = SetAbsStringTableIndex (
-					pSolarSysState->XlatRef, 1);
-		}
-		pSolarSysState->XlatPtr = GetStringAddress (pSolarSysState->XlatRef);
-		RenderTopography (pSolarSysState->TopoFrame, Orbit->lpTopoData, MAP_WIDTH, MAP_HEIGHT, FALSE);
-
-	}
-
-	if (!shielded && PlanetInfo->AtmoDensity != GAS_GIANT_ATMOSPHERE)
-	{	// produce 4x scaled topo image for Planetside
-		// for the planets that we can land on
-		SBYTE *pScaledTopo = HMalloc (MAP_WIDTH * 4 * MAP_HEIGHT * 4);
-		if (pScaledTopo)
-		{
-			TopoScale4x (pScaledTopo, Orbit->lpTopoData,
-					PlanDataPtr->num_faults, PlanDataPtr->fault_depth
-					* (PLANALGO (PlanDataPtr->Type) == CRATERED_ALGO ? 2 : 1  ));
-			RenderTopography (Orbit->TopoZoomFrame, pScaledTopo,
-					  MAP_WIDTH * 4, MAP_HEIGHT * 4, SurfDef);
-
-			HFree (pScaledTopo);
-		}
-	}
-
-	// Generate a pixel array from the Topography map.
-	// We use this instead of lpTopoData because it needs to be
-	// WAP_WIDTH+SPHERE_SPAN_X wide and we need this method for Earth anyway.
-	// It may be more efficient to build it from lpTopoData instead of the
-	// FRAMPTR though.
-	ReadFramePixelColors (pSolarSysState->TopoFrame, Orbit->TopoColors,
-			MAP_WIDTH + SPHERE_SPAN_X, MAP_HEIGHT);
-	// Extend the width from MAP_WIDTH to MAP_WIDTH+SPHERE_SPAN_X
-	for (y = 0; y < (DWORD)(MAP_HEIGHT * (MAP_WIDTH + SPHERE_SPAN_X));
-			y += MAP_WIDTH + SPHERE_SPAN_X)
-		memcpy (Orbit->TopoColors + y + MAP_WIDTH, Orbit->TopoColors + y,
-				SPHERE_SPAN_X * sizeof (Orbit->TopoColors[0]));
-
-	if (PLANALGO (PlanDataPtr->Type) != GAS_GIANT_ALGO)
-	{	// convert topo data to a light map, based on relative
-		// map point elevations
-		GenerateLightMap (Orbit->lpTopoData, MAP_WIDTH, MAP_HEIGHT);
-	}
-	else
-	{	// gas giants are pretty much flat
-		memset (Orbit->lpTopoData, 0, MAP_WIDTH * MAP_HEIGHT);
-	}
-			
-	if (pSolarSysState->pOrbitalDesc->pPrevDesc ==
-			&pSolarSysState->SunDesc[0])
-	{	// this is a planet -- get its location
-		loc = pSolarSysState->pOrbitalDesc->location;
-	}
-	else
-	{	// this is a moon -- get its planet's location
-		loc = pSolarSysState->pOrbitalDesc->pPrevDesc->location;
-	}
-	
-	// Rotating planet sphere initialization
-	GenerateSphereMask (loc, RADIUS);
-	CreateSphereTiltMap (PlanetInfo->AxialTilt, MAP_HEIGHT, RADIUS);
-	if (shielded)
-		Orbit->ObjectFrame = CreateShieldMask (RADIUS);
-	InitSphereRotation (1 - 2 * (PlanetInfo->AxialTilt & 1), shielded, MAP_WIDTH, MAP_HEIGHT);
-
-	if (shielded)
-	{	// This overwrites pSolarSysState->TopoFrame, so everything that
-		// needs it has to come before
-		ApplyShieldTint ();
-	}
-
-	SetContext (OldContext);
-	UnlockMutex (GraphicsLock);
-	DestroyContext (TopoContext);
-
-	TFB_SeedRandom (old_seed);
-}
-
-
-
-void
-GeneratePlanetSurfaceForIP (PLANET_DESC *pPlanetDesc, FRAME SurfDefFrame, COUNT width, COUNT height)
-{
-	RECT r;
-	DWORD old_seed;
-	const PlanetFrame *PlanDataPtr;
-	PLANET_INFO *PlanetInfo = &pSolarSysState->SysInfo.PlanetInfo;
-	DWORD i, y;  // JMS_GFX: changed from COUNT to avoid overflow at higher resolutions.
-	POINT loc;
-	CONTEXT OldContext;
-	CONTEXT TopoContext;
-	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
-	BOOLEAN SurfDef = FALSE;
-	BOOLEAN shielded = (pPlanetDesc->data_index & PLANET_SHIELDED) != 0;
-	COUNT spherespanx = height;
-	COUNT radius = (height >> 1) - RESOLUTION_FACTOR;
-	
-	old_seed = TFB_SeedRandom (pPlanetDesc->rand_seed);
-
-	TopoContext = CreateContext ("Plangen.TopoContext");
-	LockMutex (GraphicsLock);
-	OldContext = SetContext (TopoContext);
-	planet_orbit_init (width, height, FALSE);
-
-	PlanDataPtr = &PlanData[pPlanetDesc->data_index & ~PLANET_SHIELDED];
-
-	if (SurfDefFrame)
-	{	// This is a defined planet; pixmap for the topography and
-		// elevation data is supplied in Surface Definition frame
-		BOOLEAN DeleteDef = FALSE;
-		BOOLEAN DeleteElev = FALSE;
-		FRAME ElevFrame;
-
-		// surface pixmap
-		SurfDef = TRUE;
-		SurfDefFrame = SetAbsFrameIndex (SurfDefFrame, 0);
-		if (GetFrameWidth (SurfDefFrame) != width
-				|| GetFrameHeight (SurfDefFrame) != height)
-		{
-			pSolarSysState->TopoFrame = CaptureDrawable (RescaleFrame (
-					SurfDefFrame, width, height, FALSE));
-			// will not need the passed FRAME anymore
-			DeleteDef = TRUE;
-		}
-		else
-			pSolarSysState->TopoFrame = SurfDefFrame;
-
-		if (GetFrameCount (SurfDefFrame) > 1)
-		{	// 2nd frame is elevation data 
-			int i;
-			SBYTE* elev;
-
-			ElevFrame = SetAbsFrameIndex (SurfDefFrame, 1);
-			if (GetFrameWidth (ElevFrame) != width
-					|| GetFrameHeight (ElevFrame) != height)
-			{
-				ElevFrame = CaptureDrawable (RescaleFrame (ElevFrame,
-						width, height, TRUE));
-				DeleteElev = TRUE;
-			}
-
-			// grab the elevation data in 1 byte per pixel format
-			ReadFramePixelIndexes (ElevFrame, (BYTE *)Orbit->lpTopoData,
-					width, height, FALSE);
-			// the supplied data is in unsigned format, must convert
-			for (i = 0, elev = Orbit->lpTopoData;
-					i < width * height;
-					++i, ++elev)
-			{
-				*elev = *(BYTE *)elev - 128;
-			}
-		}
-		else
-		{	// no elevation data -- planet flat as a pancake
-			memset (Orbit->lpTopoData, 0, width * height);
-		}
-
-		// JMS: Planets with special colormaps
-		if (pPlanetDesc->alternate_colormap)
-		{
-			pSolarSysState->OrbitalCMap = CaptureColorMap (
-				LoadColorMap (pPlanetDesc->alternate_colormap));
-			pSolarSysState->XlatRef = CaptureStringTable (
-				LoadStringTable (SPECIAL_CMAP_XLAT_TAB));
-		}
-		// JMS: Normal planets
-		else
-		{
-			pSolarSysState->OrbitalCMap = CaptureColorMap (
-				LoadColorMap (PlanDataPtr->CMapInstance));
-			pSolarSysState->XlatRef = CaptureStringTable (
-				LoadStringTable (PlanDataPtr->XlatTabInstance));
-		}
-
-		if (PlanetInfo->SurfaceTemperature > HOT_THRESHOLD)
-		{
-			pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
-					pSolarSysState->OrbitalCMap, 2);
-			pSolarSysState->XlatRef = SetAbsStringTableIndex (
-					pSolarSysState->XlatRef, 2);
-		}
-		else if (PlanetInfo->SurfaceTemperature > COLD_THRESHOLD)
-		{
-			pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
-					pSolarSysState->OrbitalCMap, 1);
-			pSolarSysState->XlatRef = SetAbsStringTableIndex (
-					pSolarSysState->XlatRef, 1);
-		}
-		pSolarSysState->XlatPtr = GetStringAddress (pSolarSysState->XlatRef);
-
-		if (DeleteDef)
-			DestroyDrawable (ReleaseDrawable (SurfDefFrame));
-		if (DeleteElev)
-			DestroyDrawable (ReleaseDrawable (ElevFrame));
-	}
-	else
-	{	// Generate planet surface elevation data and look
-
-		r.corner.x = r.corner.y = 0;
-		r.extent.width = width;
-		r.extent.height = height;
-		{
-			memset (Orbit->lpTopoData, 0, width * height);
-			switch (PLANALGO (PlanDataPtr->Type))
-			{
-				case GAS_GIANT_ALGO:
-					MakeGasGiant (PlanDataPtr->num_faults, Orbit->lpTopoData, &r, PlanDataPtr->fault_depth);
-					break;
-				case TOPO_ALGO:
-				case CRATERED_ALGO:
-					if (PlanDataPtr->num_faults)
-						DeltaTopography (PlanDataPtr->num_faults,
-								Orbit->lpTopoData, &r,
-								PlanDataPtr->fault_depth);
-
-					for (i = 0; i < PlanDataPtr->num_blemishes; ++i)
-					{
-						RECT crater_r;
-						DWORD random_value; // JMS_GFX
-						UWORD loword;
-						// UWORD hiword; // JMS_GFX
-						// BW: reinstate original values...
-						
-						random_value = TFB_Random(); // JMS_GFX
-						loword = LOWORD (random_value); // JMS_GFX: Was loword = LOWORD (TFB_Random ());
+						loword = LOWORD (RandomContext_Random (SysGenRNG));
 						switch (HIBYTE (loword) & 31)
 						{
 							case 0:
-								// if (RESOLUTION_FACTOR == 0)
-								crater_r.extent.width = (LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT >> 2)) + (ORIGINAL_MAP_HEIGHT >> 2);
-								// else
-								// 	crater_r.extent.width = (loword % (MAP_HEIGHT >> 2)) + (MAP_HEIGHT >> 2);
-								
+								crater_r.extent.width = (LOBYTE (loword) 
+									% (ORIGINAL_MAP_HEIGHT >> 2)) 
+									+ (ORIGINAL_MAP_HEIGHT >> 2);
 								break;
 							case 1:
 							case 2:
 							case 3:
 							case 4:
-								// if (RESOLUTION_FACTOR == 0)
-								crater_r.extent.width = (LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT >> 3)) + (ORIGINAL_MAP_HEIGHT >> 3);
-								// else
-								// 	crater_r.extent.width = (loword % (MAP_HEIGHT >> 3)) + (MAP_HEIGHT >> 3);
+								crater_r.extent.width = (LOBYTE (loword) 
+									% (ORIGINAL_MAP_HEIGHT >> 3)) 
+									+ (ORIGINAL_MAP_HEIGHT >> 3);
 								break;
 							default:
-								// if (RESOLUTION_FACTOR == 0)
-								crater_r.extent.width = (LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT >> 4)) + 4;
-								// else
-								// 	crater_r.extent.width = (loword % (MAP_HEIGHT >> 4)) + 4;
+								crater_r.extent.width = (LOBYTE (loword) 
+									% (ORIGINAL_MAP_HEIGHT >> 4)) + 4;
 								break;
 						}
 
-						random_value = TFB_Random(); // JMS_GFX
-						loword = LOWORD (random_value); // JMS_GFX: Was loword = LOWORD (TFB_Random ());
-						// hiword = HIWORD (random_value); 
-						// JMS_GFX
-	
+						loword = LOWORD (RandomContext_Random (SysGenRNG));
+
 						crater_r.extent.height = crater_r.extent.width;
 						crater_r.corner.x = HIBYTE (loword) % (ORIGINAL_MAP_WIDTH - crater_r.extent.width);
 						// crater_r.corner.x = loword % (MAP_WIDTH - crater_r.extent.width); // JMS_GFX: changed the previous line to this. BYTE was too small for 4x resolution
@@ -2228,32 +1883,55 @@ GeneratePlanetSurfaceForIP (PLANET_DESC
 						// crater_r.corner.y = hiword % (MAP_HEIGHT - crater_r.extent.height); // JMS_GFX: The same
 
 						// BW: ... then scale them up
-						crater_r.extent.width = crater_r.extent.width * height / ORIGINAL_MAP_HEIGHT;
+						crater_r.extent.width = crater_r.extent.width * Height / ORIGINAL_MAP_HEIGHT;
 						crater_r.extent.height = crater_r.extent.width;
-						crater_r.corner.x = crater_r.corner.x * width / ORIGINAL_MAP_WIDTH;					
-						crater_r.corner.y = crater_r.corner.y * height / ORIGINAL_MAP_HEIGHT;
-						
+						crater_r.corner.x = crater_r.corner.x * Width / ORIGINAL_MAP_WIDTH;					
+						crater_r.corner.y = crater_r.corner.y * Height / ORIGINAL_MAP_HEIGHT;
+
 						MakeCrater (&crater_r, Orbit->lpTopoData,
 								PlanDataPtr->fault_depth << 2,
 								-(PlanDataPtr->fault_depth << 2),
-							    FALSE, width);
+								FALSE, Width);
 					}
+
 					if (PLANALGO (PlanDataPtr->Type) == CRATERED_ALGO)
-						DitherMap (Orbit->lpTopoData, width, height);
-					ValidateMap (Orbit->lpTopoData, width, height);
+						DitherMap (Orbit->lpTopoData, Width, Height);
+					ValidateMap (Orbit->lpTopoData, Width, Height);
 					break;
 			}
 		}
 		pSolarSysState->TopoFrame = CaptureDrawable (
-				CreateDrawable (WANT_PIXMAP, (SIZE)width,
-				(SIZE)height, 1));
-		
-		{
+				CreateDrawable (WANT_PIXMAP, (SIZE)Width,
+				(SIZE)Height, 1));
+		if (inOrbit){
+			// JMS: Planets with special colormaps
+			if (pPlanetDesc->alternate_colormap) {
+				pSolarSysState->OrbitalCMap = CaptureColorMap (
+					LoadColorMap (pPlanetDesc->alternate_colormap));
+				pSolarSysState->XlatRef = CaptureStringTable (
+					LoadStringTable (SPECIAL_CMAP_XLAT_TAB));
+			} else { // JMS: Normal planets
+				pSolarSysState->OrbitalCMap = CaptureColorMap (
+					LoadColorMap (PlanDataPtr->CMapInstance));
+				pSolarSysState->XlatRef = CaptureStringTable (
+					LoadStringTable (PlanDataPtr->XlatTabInstance));
+			}
+			if (PlanetInfo->SurfaceTemperature > HOT_THRESHOLD) {
+				pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
+						pSolarSysState->OrbitalCMap, 2);
+				pSolarSysState->XlatRef = SetAbsStringTableIndex (
+						pSolarSysState->XlatRef, 2);
+			} else if (PlanetInfo->SurfaceTemperature > COLD_THRESHOLD) {
+				pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
+						pSolarSysState->OrbitalCMap, 1);
+				pSolarSysState->XlatRef = SetAbsStringTableIndex (
+						pSolarSysState->XlatRef, 1);
+			}
+		} else {
 			pSolarSysState->OrbitalCMap = CaptureColorMap (
 				LoadColorMap (PlanDataPtr->CMapInstance));
 			pSolarSysState->XlatRef = CaptureStringTable (
 				LoadStringTable (PlanDataPtr->XlatTabInstance));
-
 			if (PlanetInfo->SurfaceTemperature > HOT_THRESHOLD)
 			{
 				pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
@@ -2269,10 +1947,24 @@ GeneratePlanetSurfaceForIP (PLANET_DESC
 						pSolarSysState->XlatRef, 1);
 			}
 		}
-			
 		pSolarSysState->XlatPtr = GetStringAddress (pSolarSysState->XlatRef);
-		RenderTopography (pSolarSysState->TopoFrame, Orbit->lpTopoData, width, height, FALSE);
+		RenderTopography (pSolarSysState->TopoFrame, Orbit->lpTopoData, Width, Height, FALSE);
+	}
+
+	if (!shielded && PlanetInfo->AtmoDensity != GAS_GIANT_ATMOSPHERE && inOrbit)
+	{	// produce 4x scaled topo image for Planetside
+		// for the planets that we can land on
+		SBYTE *pScaledTopo = HMalloc (Width * 4 * Height * 4);
+		if (pScaledTopo)
+		{
+			TopoScale4x (pScaledTopo, Orbit->lpTopoData,
+					PlanDataPtr->num_faults, PlanDataPtr->fault_depth
+					* (PLANALGO (PlanDataPtr->Type) == CRATERED_ALGO ? 2 : 1  ));
+			RenderTopography (Orbit->TopoZoomFrame, pScaledTopo,
+					Width * 4, Height * 4, SurfDef);
 
+			HFree (pScaledTopo);
+		}
 	}
 
 	// Generate a pixel array from the Topography map.
@@ -2281,23 +1973,23 @@ GeneratePlanetSurfaceForIP (PLANET_DESC
 	// It may be more efficient to build it from lpTopoData instead of the
 	// FRAMPTR though.
 	ReadFramePixelColors (pSolarSysState->TopoFrame, Orbit->TopoColors,
-			width + spherespanx, height);
-	// Extend the width from MAP_WIDTH to MAP_WIDTH+SPHERE_SPAN_X
-	for (y = 0; y < (DWORD)(height * (width + spherespanx));
-			y += width + spherespanx)
-		memcpy (Orbit->TopoColors + y + width, Orbit->TopoColors + y,
-				spherespanx * sizeof (Orbit->TopoColors[0]));
+			Width + SphereSpanX, Height);
+	// Extend the Width from MAP_WIDTH to MAP_WIDTH+SPHERE_SPAN_X
+	for (y = 0; y < (DWORD)(Height * (Width + SphereSpanX));
+			y += Width + SphereSpanX)
+		memcpy (Orbit->TopoColors + y + Width, Orbit->TopoColors + y,
+				SphereSpanX * sizeof (Orbit->TopoColors[0]));
 
 	if (PLANALGO (PlanDataPtr->Type) != GAS_GIANT_ALGO)
 	{	// convert topo data to a light map, based on relative
 		// map point elevations
-		GenerateLightMap (Orbit->lpTopoData, width, height);
+		GenerateLightMap (Orbit->lpTopoData, Width, Height);
 	}
 	else
 	{	// gas giants are pretty much flat
-		memset (Orbit->lpTopoData, 0, width * height);
+		memset (Orbit->lpTopoData, 0, Width * Height);
 	}
-
+			
 	if (pSolarSysState->pOrbitalDesc->pPrevDesc ==
 			&pSolarSysState->SunDesc[0])
 	{	// this is a planet -- get its location
@@ -2309,27 +2001,26 @@ GeneratePlanetSurfaceForIP (PLANET_DESC
 	}
 	
 	// Rotating planet sphere initialization
-	GenerateSphereMask (loc, radius);
-	CreateSphereTiltMap (PlanetInfo->AxialTilt, height, radius);
+	GenerateSphereMask (loc, Radius);
+	CreateSphereTiltMap (PlanetInfo->AxialTilt, Height, Radius);
 	if (shielded)
-		Orbit->ObjectFrame = CreateShieldMask (radius);
-	InitSphereRotation (1 - 2 * (PlanetInfo->AxialTilt & 1), shielded, width, height);
-	pPlanetDesc->rotDirection = 1 - 2 * (PlanetInfo->AxialTilt & 1);
-	pPlanetDesc->rotwidth = width;
-	pPlanetDesc->rotheight = height;
-	pPlanetDesc->rotFrameIndex = 0;
-	pPlanetDesc->rotPointIndex = 0;
-	pPlanetDesc->rot_speed = ((double)(pPlanetDesc->rotwidth * pPlanetDesc->rotDirection * 240)) / PlanetInfo->RotationPeriod;
-	
-	if (shielded)
-	{	// This overwrites pSolarSysState->TopoFrame, so everything that
+		Orbit->ObjectFrame = CreateShieldMask (Radius);
+	InitSphereRotation (1 - 2 * (PlanetInfo->AxialTilt & 1), shielded, Width, Height);
+
+	if (!inOrbit){
+		pPlanetDesc->rotDirection = 1 - 2 * (PlanetInfo->AxialTilt & 1);
+		pPlanetDesc->rotwidth = Width;
+		pPlanetDesc->rotheight = Height;
+		pPlanetDesc->rotFrameIndex = 0;
+		pPlanetDesc->rotPointIndex = 0; 
+		pPlanetDesc->rot_speed = ((double)(pPlanetDesc->rotwidth * pPlanetDesc->rotDirection * 240)) / PlanetInfo->RotationPeriod;
+	}
+
+	if (shielded) {	// This overwrites pSolarSysState->TopoFrame, so everything that
 		// needs it has to come before
 		ApplyShieldTint ();
 	}
 
 	SetContext (OldContext);
-	UnlockMutex (GraphicsLock);
 	DestroyContext (TopoContext);
-
-	TFB_SeedRandom (old_seed);
-}
+}
\ No newline at end of file
diff -ruNp src.hd/uqm/planets/pstarmap.c src/uqm/planets/pstarmap.c
--- src.hd/uqm/planets/pstarmap.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/pstarmap.c	2017-12-29 00:57:49 -0800
@@ -20,8 +20,7 @@
 #include "../colors.h"
 #include "../controls.h"
 #include "../menustat.h"
-// XXX: for stuff that does not belong there
-#include "../encount.h"
+#include "../starmap.h"
 #include "../races.h"
 #include "../gameopt.h"
 #include "../gamestr.h"
@@ -36,16 +35,14 @@
 #include "../sounds.h"
 #include "../state.h"
 #include "../uqmdebug.h"
-#include "../util.h"
-		/* For get_fuel_to_sol() */
-
 #include "options.h"
 #include "libs/inplib.h"
 #include "libs/strlib.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/mathlib.h"
 #include "libs/memlib.h"
-
+#include "../util.h"
+		// For get_fuel_to_sol()
 #include <stdlib.h>
 
 typedef enum {
@@ -55,10 +52,12 @@ typedef enum {
 	NUM_STARMAPS
 } CURRENT_STARMAP_SHOWN;
 
+
 static POINT cursorLoc;
 static POINT mapOrigin;
 static int zoomLevel;
 static FRAME StarMapFrame;
+
 static BOOLEAN show_prewar_situation; // JMS
 static CURRENT_STARMAP_SHOWN which_starmap; // JMS
 
@@ -78,18 +77,18 @@ signedDivWithError (long val, long divis
 #define MAP_FIT_X ((MAX_X_UNIVERSE + 1) / SIS_SCREEN_WIDTH + 1)
 
 static inline COORD
-universeToDispx (COORD ux)
+universeToDispx (long ux)
 {
-	return signedDivWithError ((((long)ux - mapOrigin.x) << zoomLevel)
+	return signedDivWithError (((ux - mapOrigin.x) << zoomLevel)
 			* SIS_SCREEN_WIDTH, MAX_X_UNIVERSE + MAP_FIT_X)
 			+ ((SIS_SCREEN_WIDTH - 1) >> 1);
 }
 #define UNIVERSE_TO_DISPX(ux)  universeToDispx(ux)
 
 static inline COORD
-universeToDispy (COORD uy)
+universeToDispy (long uy)
 {
-	return signedDivWithError ((((long)mapOrigin.y - uy) << zoomLevel)
+	return signedDivWithError (((mapOrigin.y - uy) << zoomLevel)
 			* SIS_SCREEN_HEIGHT, MAX_Y_UNIVERSE + 2)
 			+ ((SIS_SCREEN_HEIGHT - 1) >> 1);
 }
@@ -134,7 +133,6 @@ flashCurrentLocation (POINT *where)
 
 		NextTime = GetTimeCounter () + (ONE_SECOND / 16);
 		
-		LockMutex (GraphicsLock);
 		OldContext = SetContext (SpaceContext);
 
 		if (c == 0x00 || c == 0x1A)
@@ -149,7 +147,6 @@ flashCurrentLocation (POINT *where)
 		SetContextForeGroundColor (OldColor);
 
 		SetContext (OldContext);
-		UnlockMutex (GraphicsLock);
 	}
 }
 
@@ -174,7 +171,7 @@ DrawAutoPilot (POINT *pDstPt)
 				cycle, delta;
 	POINT pt;
 
-	if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
+	if (!inHQSpace ())
 		pt = CurStarDescPtr->star_pt;
 	else
 	{
@@ -289,6 +286,7 @@ GetSphereRect (FLEET_INFO *FleetPtr, REC
 	}
 }
 
+
 // JMS: For showing the SC1-era situation in starmap
 static void
 GetPrewarSphereRect (COUNT index, FLEET_INFO *FleetPtr, RECT *pRect, RECT *pRepairRect)
@@ -378,21 +376,22 @@ DrawFuelCircles ()
 	long diameter_no_return;
 	POINT corner;
 	Color OldColor;
+	DWORD OnBoardFuel = !optInfiniteFuel ? GLOBAL_SIS (FuelOnBoard) : 0;
 
-	diameter = (long) GLOBAL_SIS (FuelOnBoard) << 1;
+	diameter = OnBoardFuel << 1;
 
 	/* Terribly ugly hack to keep this from being assigned
 	 * a negative value, and also to make sure the inner circle
 	 * is not drawn if we don't have enough fuel to get to Sol at
 	 * all.
 	 */
-	if ((((long)GLOBAL_SIS (FuelOnBoard)) - (long)get_fuel_to_sol() < 0) ||
-		(get_fuel_to_sol () > GLOBAL_SIS (FuelOnBoard)))
+	if (((OnBoardFuel) - (long)get_fuel_to_sol() < 0) ||
+		(get_fuel_to_sol () > OnBoardFuel))
 	{
 		diameter_no_return = 0;
 	} else
 	{
-		diameter_no_return = GLOBAL_SIS (FuelOnBoard) - get_fuel_to_sol();
+		diameter_no_return = OnBoardFuel - get_fuel_to_sol();
 	}
 
 	if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
@@ -459,9 +458,10 @@ DrawStarMap (COUNT race_update, RECT *pC
 #define GRID_DELTA 500
 	SIZE i;
 	COUNT which_space;
+	// long diameter;
 	RECT r, old_r;
 	POINT oldOrigin = {0, 0};
-	STAMP s;
+	STAMP s, nebula;
 	FRAME star_frame;
 	STAR_DESC *SDPtr;
 	BOOLEAN draw_cursor;
@@ -473,7 +473,6 @@ DrawStarMap (COUNT race_update, RECT *pC
 	}
 	else
 	{
-		LockMutex (GraphicsLock);
 		draw_cursor = TRUE;
 	}
 
@@ -516,8 +515,8 @@ DrawStarMap (COUNT race_update, RECT *pC
 	}
 	ClearDrawable ();
 
-	if (race_update == 0 && which_space < 2)
-	{
+	// Draw the fuel range circle
+	if (race_update == 0 && which_space < 2) {
 		DrawFuelCircles ();
 	}
 
@@ -582,7 +581,7 @@ DrawStarMap (COUNT race_update, RECT *pC
 					GetPrewarSphereRect (index, FleetPtr, &r, &repair_r);
 				else
 					GetSphereRect (FleetPtr, &r, &repair_r);
-				
+
 				if (r.corner.x < SIS_SCREEN_WIDTH
 						&& r.corner.y < SIS_SCREEN_HEIGHT
 						&& r.corner.x + r.extent.width > 0
@@ -609,7 +608,6 @@ DrawStarMap (COUNT race_update, RECT *pC
 					t.baseline.x = r.corner.x + (r.extent.width >> 1);
 					t.baseline.y = r.corner.y + (r.extent.height >> 1) - 1;
 					t.align = ALIGN_CENTER;
-					
 					// JMS: For drawing SC1-era starmap.
 					if (show_prewar_situation && prewar_name_unknown[index])
 					{
@@ -643,8 +641,6 @@ DrawStarMap (COUNT race_update, RECT *pC
 						t.CharCount = GetStringLength (locString);
 						t.pStr = (UNICODE *)GetStringAddress (locString);
 					}
-					
-					TextRect (&t, &r, NULL);
 
 					if (r.corner.x <= 0)
 						t.baseline.x -= r.corner.x - 1;
@@ -667,7 +663,6 @@ DrawStarMap (COUNT race_update, RECT *pC
 							0xff : c.b + CC5TO8 (0x03);
 
 					SetContextForeGroundColor (c);
-					
 					if ((!show_prewar_situation) ||
 						(show_prewar_situation && prewar_strengths[index]))
 						font_DrawText (&t);
@@ -702,7 +697,15 @@ DrawStarMap (COUNT race_update, RECT *pC
 
 		++SDPtr;
 	} while (SDPtr->star_pt.x <= MAX_X_UNIVERSE
-			&& SDPtr->star_pt.y <= MAX_Y_UNIVERSE);
+			&& SDPtr->star_pt.y <= MAX_Y_UNIVERSE);	
+	
+	// JMS: Draw a sexy nebula on the map's background (Only in Hyperspace, not in Quasispace).
+	if (which_space <= 1)
+	{
+		nebula.origin.x = nebula.origin.y = 0;
+		nebula.frame = SetAbsFrameIndex (NebulaeFrame, 16);
+		DrawStamp(&nebula);
+	}
 
 	// JMS: This draws the constellation lines on the constellation starmap.
 	if (which_space <= 1 && which_starmap == CONSTELLATION_STARMAP)
@@ -765,9 +768,6 @@ DrawStarMap (COUNT race_update, RECT *pC
 					UNIVERSE_TO_DISPY (cursorLoc.y));
 		}
 	}
-
-	if (draw_cursor)
-		UnlockMutex (GraphicsLock);
 }
 
 static void
@@ -797,9 +797,7 @@ EraseCursor (COORD curs_x, COORD curs_y)
 #else /* NEW */
 	r.extent.height += r.corner.y & 1;
 	r.corner.y &= ~1;
-	UnlockMutex (GraphicsLock);
 	DrawStarMap (0, &r);
-	LockMutex (GraphicsLock);
 #endif /* OLD */
 }
 
@@ -809,7 +807,7 @@ ZoomStarMap (SIZE dir)
 #define MAX_ZOOM_SHIFT (BYTE)(4 - RESOLUTION_FACTOR)
 	if (dir > 0)
 	{
-		if (zoomLevel < MAX_ZOOM_SHIFT) // JMS_GFX
+		if (zoomLevel < MAX_ZOOM_SHIFT)
 		{
 			++zoomLevel;
 			mapOrigin = cursorLoc;
@@ -885,8 +883,7 @@ UpdateCursorLocation (int sx, int sy, co
 			cursorLoc.y = MAX_Y_UNIVERSE;
 
 		s.origin.y = UNIVERSE_TO_DISPY (cursorLoc.y);
-		if (s.origin.y < 0)
-		{
+		if (s.origin.y < 0) {
 			s.origin.y = 0;
 			cursorLoc.y = DISP_TO_UNIVERSEY (0);
 		}
@@ -904,16 +901,13 @@ UpdateCursorLocation (int sx, int sy, co
 	}
 	else
 	{
-		LockMutex (GraphicsLock);
 		EraseCursor (pt.x, pt.y);
 		// ClearDrawable ();
 		DrawCursor (s.origin.x, s.origin.y);
-		UnlockMutex (GraphicsLock);
 	}
 }
 
 #define CURSOR_INFO_BUFSIZE 256
-
 // JMS: How close to a star the cursor has to be to 'snap' into it.
 // Don't make this larger than 1 for lo-res(1x). Otherwise the cursor gets stuck on stars.
 #define CURSOR_SNAP_AREA (RES_CASE(0,1,2)) // MB: Fixed cursor snap area so that trying to autopilot to sol no longer selects sirius all the damn time unless you zoom in.
@@ -925,7 +919,7 @@ UpdateCursorInfo (UNICODE *prevbuf)
 	POINT pt;
 	STAR_DESC *SDPtr;
 	STAR_DESC *BestSDPtr;
-	
+
 	// JMS: Display star map title.
 	if (which_starmap == CONSTELLATION_STARMAP)
 	{	
@@ -939,7 +933,7 @@ UpdateCursorInfo (UNICODE *prevbuf)
 	}
 	else
 	{	
-		// "(Star search:F6 Toggle maps:F7)"
+		// "(Star Search: F6 | Toggle Maps: F7)"
 		utf8StringCopy (buf, sizeof (buf), GAME_STRING (FEEDBACK_STRING_BASE + 2));
 	}
 
@@ -947,7 +941,6 @@ UpdateCursorInfo (UNICODE *prevbuf)
 	pt.y = UNIVERSE_TO_DISPY (cursorLoc.y);
 
 	SDPtr = BestSDPtr = 0;
-	
 	while ((SDPtr = FindStar (SDPtr, &cursorLoc, 75, 75)))
 	{
 		if ((UNIVERSE_TO_DISPX (SDPtr->star_pt.x) >= pt.x - CURSOR_SNAP_AREA && UNIVERSE_TO_DISPX (SDPtr->star_pt.x) <= pt.x + CURSOR_SNAP_AREA)
@@ -1015,12 +1008,10 @@ UpdateCursorInfo (UNICODE *prevbuf)
 		}
 	}
 
-	LockMutex (GraphicsLock);
 	DrawHyperCoords (cursorLoc);
 	if (strcmp (buf, prevbuf) != 0)
 	{
 		strcpy (prevbuf, buf);
-		
 		// Cursor is on top of a star. Display its name.
 		if (BestSDPtr)
 			DrawSISMessage (buf);
@@ -1051,18 +1042,15 @@ UpdateCursorInfo (UNICODE *prevbuf)
 			}
 		}
 	}
-	UnlockMutex (GraphicsLock);
 }
 
-static void
-UpdateFuelRequirement (void)
-{
-	UNICODE buf[80];
+static int
+FuelRequired (void){
 	COUNT fuel_required;
 	DWORD f;
 	POINT pt;
 
-	if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
+	if (!inHQSpace ())
 		pt = CurStarDescPtr->star_pt;
 	else
 	{
@@ -1078,14 +1066,21 @@ UpdateFuelRequirement (void)
 	else
 		fuel_required = square_root (f) + (FUEL_TANK_SCALE / 20);
 
+	return fuel_required;
+}
+
+static void
+UpdateFuelRequirement (void)
+{
+	UNICODE buf[80];
+	COUNT fuel_required = FuelRequired();
+
 	sprintf (buf, "%s %u.%u",
 			GAME_STRING (NAVIGATION_STRING_BASE + 4),
 			fuel_required / FUEL_TANK_SCALE,
 			(fuel_required % FUEL_TANK_SCALE) / 10);
 
-	LockMutex (GraphicsLock);
 	DrawStatusMessage (buf);
-	UnlockMutex (GraphicsLock);
 }
 
 #define STAR_SEARCH_BUFSIZE 256
@@ -1336,10 +1331,8 @@ DrawMatchedStarName (TEXTENTRY_STATE *pT
 			flags |= DSME_BLOCKCUR;
 	}
 	
-	LockMutex (GraphicsLock);
 	DrawSISMessageEx (buf, CurPos, ExPos, flags);
 	DrawHyperCoords (cursorLoc);
-	UnlockMutex (GraphicsLock);
 }
 
 static void
@@ -1410,9 +1403,7 @@ OnStarNameChange (TEXTENTRY_STATE *pTES)
 		if (pTES->JoystickMode)
 			flags |= DSME_BLOCKCUR;
 
-		LockMutex (GraphicsLock);
 		ret = DrawSISMessageEx (pSS->Text, pTES->CursorPos, -1, flags);
-		UnlockMutex (GraphicsLock);
 	}
 	else
 	{
@@ -1473,9 +1464,7 @@ DoStarSearch (MENU_STATE *pMS)
 	if (!pss)
 		return FALSE;
 
-	LockMutex (GraphicsLock);
 	DrawSISMessageEx ("", 0, 0, DSME_SETFR);
-	UnlockMutex (GraphicsLock);
 
 	pss->pMS = pMS;
 	pss->LastChangeTime = 0;
@@ -1497,9 +1486,7 @@ DoStarSearch (MENU_STATE *pMS)
 	SetDefaultMenuRepeatDelay ();
 	success = DoTextEntry (&tes);
 
-	LockMutex (GraphicsLock);
 	DrawSISMessageEx (pss->Text, -1, -1, DSME_CLEARFR);
-	UnlockMutex (GraphicsLock);
 
 	HFree (pss);
 
@@ -1525,7 +1512,7 @@ DoMoveCursor (MENU_STATE *pMS)
 		pMS->Initialized = TRUE;
 		pMS->InputFunc = DoMoveCursor;
 
-		if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
+		if (!inHQSpace ())
 			universe = CurStarDescPtr->star_pt;
 		else
 		{
@@ -1573,31 +1560,33 @@ DoMoveCursor (MENU_STATE *pMS)
 				UpdateCursorLocation (0, 0, &BestSDPtr->star_pt);
 			}
 		}
-		
-		GLOBAL (autopilot) = cursorLoc;
-		// Un-#if'ed this for use as a cheat
-		if (optBubbleWarp)
-		{
-			PlayMenuSound (MENU_SOUND_INVOKED);
-
-			if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
-			{
-				// Move to the new location immediately.
-				doInstantMove ();
-			}
-			else if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY)
-			{
-				// We're in a solar system; exit it.
-				GLOBAL (CurrentActivity) |= END_INTERPLANETARY;
-			
-				// Set a hook to move to the new location:
-				debugHook = doInstantMove;
-			}
 
-			return FALSE;
-		} // Serosis
+		// printf("Fuel Available: %d | Fuel Requirement: %d\n", GLOBAL_SIS (FuelOnBoard), FuelRequired());
 
-		DrawStarMap (0, NULL);
+		if (optBubbleWarp) {
+			if (GLOBAL_SIS (FuelOnBoard) >= FuelRequired() || optInfiniteFuel){
+				GLOBAL (autopilot) = cursorLoc;
+				PlayMenuSound (MENU_SOUND_BUBBLEWARP);
+				if (inHQSpace ()) {
+					// Move to the new location immediately.
+					doInstantMove ();
+				} else if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY) {
+					// We're in a solar system; exit it.
+					GLOBAL (CurrentActivity) |= END_INTERPLANETARY;			
+					// Set a hook to move to the new location:
+					debugHook = doInstantMove;
+				}
+				if(!optInfiniteFuel)
+					DeltaSISGauges (0, -FuelRequired(), 0);
+				
+				return FALSE;
+			} else { 
+				PlayMenuSound (MENU_SOUND_FAILURE);
+			}
+		} else {
+			GLOBAL (autopilot) = cursorLoc;
+			DrawStarMap (0, NULL);
+		}
 	}
 	else if (PulsedInputState.menu[KEY_MENU_SEARCH])
 	{
@@ -1924,27 +1913,6 @@ DoneSphereGrowth:
 	}
 }
 
-static void
-DrawSubmenuStarmapKeys (bool menu_visible)
-{
-	STAMP s;
-	CONTEXT OldContext;
-	
-	OldContext = SetContext (ScreenContext);
-
-	s.origin.x = 0;
-	s.origin.y = 0;
-		
-	if (menu_visible)
-		s.frame = SetAbsFrameIndex (SubmenuStarmapKeysFrame, 1);
-	else
-		s.frame = SetAbsFrameIndex (SubmenuStarmapKeysFrame, 0);
-
-	DrawStamp (&s);
-	
-	SetContext (OldContext);
-}
-
 BOOLEAN
 StarMap (void)
 {
@@ -1965,7 +1933,7 @@ StarMap (void)
 	mapOrigin.y = MAX_Y_UNIVERSE >> 1;
 	StarMapFrame = SetAbsFrameIndex (MiscDataFrame, 48);
 
-	if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
+	if (!inHQSpace ())
 		universe = CurStarDescPtr->star_pt;
 	else
 	{
@@ -1983,13 +1951,16 @@ StarMap (void)
 	transition_pending = TRUE;
 	if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
 		UpdateMap ();
-
-	LockMutex (GraphicsLock);
-	
-	// JMS: This will show the table of mineral values on the status bar.
-	if (optMineralSubmenu)
-		DrawSubmenuStarmapKeys (TRUE);
+	else
+	{	// This zooms the Quasi map in by 2 if within the local Quasi star cluster.
+		if ((universe.x <= ARILOU_HOME_X && universe.y <= ARILOU_HOME_Y) 
+			&& (universe.x >= 4480 && universe.y >= 4580))
+			zoomLevel = 2;
+	}
 	
+	if(optSubmenu)
+		DrawSubmenu (2);
+
 	DrawStarMap (0, (RECT*)-1);
 	transition_pending = FALSE;
 	
@@ -2001,7 +1972,6 @@ StarMap (void)
 	DrawCursor (UNIVERSE_TO_DISPX (cursorLoc.x),
 			UNIVERSE_TO_DISPY (cursorLoc.y));
 	UnbatchGraphics ();
-	UnlockMutex (GraphicsLock);
 
 	SetMenuSounds (MENU_SOUND_NONE, MENU_SOUND_NONE);
 	SetMenuRepeatDelay (MIN_ACCEL_DELAY, MAX_ACCEL_DELAY, STEP_ACCEL_DELAY,
@@ -2010,16 +1980,12 @@ StarMap (void)
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
 	SetDefaultMenuRepeatDelay ();
 
-	LockMutex (GraphicsLock);
 	DrawHyperCoords (universe);
 	DrawSISMessage (NULL);
 	DrawStatusMessage (NULL);
-	
-	// JMS: This will hide the table of mineral values on the status bar.
-	if (optMineralSubmenu)
-		DrawSubmenuStarmapKeys (FALSE);
-		
-	UnlockMutex (GraphicsLock);
+
+	if (optSubmenu)
+		DrawSubmenu (0);
 
 	if (GLOBAL (autopilot.x) == universe.x
 			&& GLOBAL (autopilot.y) == universe.y)
diff -ruNp src.hd/uqm/planets/report.c src/uqm/planets/report.c
--- src.hd/uqm/planets/report.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/report.c	2017-12-29 00:57:49 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "lander.h"
 #include "scan.h"
 #include "planets.h"
@@ -49,15 +47,12 @@ ClearReportArea (void)
 	RECT r;
 	STAMP s;
 	COORD startx;
-	
+
 	// JMS_GFX
-	if (RESOLUTION_FACTOR > 0)
-	{
+	if (RESOLUTION_FACTOR > 0) {
 		emptycols = NUM_CELL_COLS + 1;
 		emptyrows = NUM_CELL_ROWS + 1;
-	}
-	else
-	{
+	} else {
 		emptycols = NUM_CELL_COLS;
 		emptyrows = NUM_CELL_ROWS;
 	}
@@ -117,7 +112,6 @@ MakeReport (SOUND ReadOutSounds, UNICODE
 	t.pStr = pStr;
 
 	Sleepy = TRUE;
-	UnlockMutex (GraphicsLock);
 
 	FlushInput ();
 	// XXX: this is a pretty ugly goto
@@ -148,7 +142,9 @@ MakeReport (SOUND ReadOutSounds, UNICODE
 			t.pStr = end_page_buf;
 			StrLen += end_page_len;
 		}
-		t.baseline.x = 1 + (r.extent.width >> 1) + (col_cells * (r.extent.width + 1)) - 1 - 3 * RESOLUTION_FACTOR; // JMS_GFX
+		t.baseline.x = 1 + (r.extent.width >> 1) 
+			+ (col_cells * (r.extent.width + 1)) 
+			- 1 - 3 * RESOLUTION_FACTOR; // JMS_GFX
 		do
 		{
 			COUNT word_chars;
@@ -177,19 +173,25 @@ MakeReport (SOUND ReadOutSounds, UNICODE
 						font_DrawText (&t);
 					else
 					{
-						LockMutex (GraphicsLock);
 						font_DrawText (&t);
-						UnlockMutex (GraphicsLock);
 
 						PlaySound (ReadOutSounds, NotPositional (), NULL,
 								GAME_SOUND_PRIORITY);
 
-						if (c == ',')
-							TimeOut += ONE_SECOND / 4;
-						if (c == '.' || c == '!' || c == '?')
-							TimeOut += ONE_SECOND / 2;
+						if (last_c && last_c != ' ' && last_c != ',' &&
+								last_c != '.' && last_c != '!' && last_c != '?')
+						{
+							if (c == ',')
+								TimeOut += ONE_SECOND / 4;
+							if (c == '.' || c == '!' || c == '?')
+								TimeOut += ONE_SECOND / 2;
+							else
+								TimeOut += ONE_SECOND / 20;
+						}
 						else
 							TimeOut += ONE_SECOND / 20;
+						last_c = c;
+
 						if (word_chars == 0)
 							TimeOut += ONE_SECOND / 20;
 
@@ -197,7 +199,6 @@ MakeReport (SOUND ReadOutSounds, UNICODE
 						{
 							Sleepy = FALSE;
 							// We draw the whole thing at once after this
-							LockMutex (GraphicsLock);
 							BatchGraphics ();
 						}
 					}
@@ -218,7 +219,6 @@ MakeReport (SOUND ReadOutSounds, UNICODE
 			if (!Sleepy)
 			{
 				UnbatchGraphics ();
-				UnlockMutex (GraphicsLock);
 			}
 
 			if (!WaitForAnyButton (TRUE, WAIT_INFINITE, FALSE))
@@ -230,18 +230,14 @@ InitPageCell:
 			row_cells = 0;
 			if (StrLen)
 			{
-				LockMutex (GraphicsLock);
 				if (!Sleepy)
 					BatchGraphics ();
 				ClearReportArea();
 				SetContextForeGroundColor (
 						BUILD_COLOR (MAKE_RGB15 (0x00, 0x1F, 0x00), 0xFF));
-				if (Sleepy)
-					UnlockMutex (GraphicsLock);
 			}
 		}
 	}
-	LockMutex (GraphicsLock);
 }
 
 void
@@ -288,9 +284,7 @@ DoDiscoveryReport (SOUND ReadOutSounds)
 
 	DestroyDrawable (ReleaseDrawable (saveStamp.frame));
 
-	UnlockMutex (GraphicsLock);
 	WaitForNoInput (WAIT_INFINITE, TRUE);
-	LockMutex (GraphicsLock);
 }
 
 
diff -ruNp src.hd/uqm/planets/roster.c src/uqm/planets/roster.c
--- src.hd/uqm/planets/roster.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/roster.c	2017-12-29 00:57:49 -0800
@@ -67,7 +67,7 @@ static void
 drawSupportShip (ROSTER_STATE *rosterState, bool filled, bool saveFrame)
 {
 	STAMP s;
-	
+
 	if (!rosterState->curShipFrame)
 		return;
 
@@ -77,8 +77,7 @@ drawSupportShip (ROSTER_STATE *rosterSta
 	s.frame = rosterState->curShipFrame;
 	
 	// JMS: 
-	if (saveFrame)
-	{
+	if (saveFrame) {
 		savedShipFrame_r.corner.x = s.origin.x;
 		savedShipFrame_r.corner.y = s.origin.y;
 		savedShipFrame_r.extent.width  = 16 << RESOLUTION_FACTOR;
@@ -87,9 +86,7 @@ drawSupportShip (ROSTER_STATE *rosterSta
 		savedShipFrame = SaveContextFrame (&savedShipFrame_r);
 		
 		log_add (log_Debug,"Saved x:%u, y:%u", savedShipFrame_r.corner.x ,savedShipFrame_r.corner.y);
-	}
-	else
-	{
+	} else {
 		if (filled)
 			DrawFilledStamp (&s);
 		else
@@ -223,7 +220,9 @@ DeltaSupportCrew (ROSTER_STATE *rosterSt
 					StarShipPtr->crew_level,
 					TemplatePtr->crew_level);
 
+		PreUpdateFlashRect ();
 		DrawStatusMessage (buf);
+		PostUpdateFlashRect ();
 		DeltaSISGauges (-crew_delta, 0, 0);
 		if (crew_delta)
 		{
@@ -258,7 +257,7 @@ static BOOLEAN
 DoModifyRoster (MENU_STATE *pMS)
 {
 	ROSTER_STATE *rosterState = pMS->privData;
-	BOOLEAN select, cancel, up, down, horiz;
+	BOOLEAN select, cancel, up, down, pgup, pgdn, horiz;
 
 	if (GLOBAL (CurrentActivity) & CHECK_ABORT)
 		return FALSE;
@@ -270,6 +269,8 @@ DoModifyRoster (MENU_STATE *pMS)
 	// Left or right produces the same effect because there are 2 columns
 	horiz = PulsedInputState.menu[KEY_MENU_LEFT] ||
 			PulsedInputState.menu[KEY_MENU_RIGHT];
+	pgup = PulsedInputState.menu[KEY_MENU_PAGE_UP];
+	pgdn = PulsedInputState.menu[KEY_MENU_PAGE_DOWN];
 
 	if (cancel && !rosterState->modifyingCrew)
 	{
@@ -277,47 +278,44 @@ DoModifyRoster (MENU_STATE *pMS)
 	}
 	else if (select || cancel)
 	{
-		LockMutex (GraphicsLock);
 		rosterState->modifyingCrew ^= true;
 		if (!rosterState->modifyingCrew)
 		{
 			SetFlashRect (NULL);
-			SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
+			SetMenuSounds (MENU_SOUND_ARROWS | MENU_SOUND_PAGEUP |
+				MENU_SOUND_PAGEDOWN, MENU_SOUND_SELECT);
 		}
 		else
 		{
 			drawModifiedSupportShip (rosterState);
 			flashSupportShipCrew ();
-			SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN,
-					MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
+			SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN | MENU_SOUND_PAGEUP |
+				MENU_SOUND_PAGEDOWN, MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
 		}
-		UnlockMutex (GraphicsLock);
 	}
 	else if (rosterState->modifyingCrew)
 	{
 		SIZE delta = 0;
 		BOOLEAN failed = FALSE;
 
-		if (up)
+		if (up || pgup)
 		{
 			if (GLOBAL_SIS (CrewEnlisted))
-				delta = 1;
+				delta = pgup ? 10 : 1;
 			else
 				failed = TRUE;
 		}
-		else if (down)
+		else if (down || pgdn)
 		{
 			if (GLOBAL_SIS (CrewEnlisted) < GetCrewPodCapacity ())
-				delta = -1;
+				delta = pgdn ? -10 : -1;
 			else
 				failed = TRUE;
 		}
 		
 		if (delta != 0)
 		{
-			LockMutex (GraphicsLock);
 			failed = !DeltaSupportCrew (rosterState, delta);
-			UnlockMutex (GraphicsLock);
 		}
 
 		if (failed)
@@ -373,7 +371,6 @@ DoModifyRoster (MENU_STATE *pMS)
 				--NewState;
 		}
 
-		LockMutex (GraphicsLock);
 		BatchGraphics ();
 		SetContext (StatusContext);
 
@@ -386,23 +383,21 @@ DoModifyRoster (MENU_STATE *pMS)
 				DrawStamp (&savedShipFrame);
 			else // In 1x mode we just draw the icon.
 				drawSupportShip (rosterState, FALSE, FALSE);
-			
 			// Select the new one
 			selectSupportShip (rosterState, NewState);
 			pMS->CurState = NewState;
-			
+
 			// JMS_GFX: In 2x and 4x modes we now have to capture the
 			// location of this new rectangle.
 			if (RESOLUTION_FACTOR > 0)
 				flashSupportShip (rosterState, TRUE);
 			else
 				flashSupportShip (rosterState, FALSE);
-		}
+		} 
 		else
 			flashSupportShip (rosterState, FALSE);
 
 		UnbatchGraphics ();
-		UnlockMutex (GraphicsLock);
 	}
 
 	SleepThread (ONE_SECOND / 30);
@@ -452,7 +447,6 @@ RosterMenu (void)
 	qsort (RosterState.shipPos, RosterState.count,
 			sizeof (RosterState.shipPos[0]), compShipPos);
 
-	LockMutex (GraphicsLock);
 	SetContext (StatusContext);
 	selectSupportShip (&RosterState, MenuState.CurState);
 
@@ -460,15 +454,12 @@ RosterMenu (void)
 	// the red junk from around it after rostering.
 	if (RESOLUTION_FACTOR > 0)
 		drawSupportShip (&RosterState, TRUE, TRUE);
-		
-	UnlockMutex (GraphicsLock);
 
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
 
 	MenuState.InputFunc = DoModifyRoster;
 	DoInput (&MenuState, TRUE);
 
-	LockMutex (GraphicsLock);
 	SetContext (StatusContext);
 	
 	// Draw the last escort in unselected state.
@@ -478,9 +469,8 @@ RosterMenu (void)
 		DrawStamp (&savedShipFrame);
 	else // In 1x mode we just draw the icon.
 		drawSupportShip (&RosterState, FALSE, FALSE);
-	
+
 	DrawStatusMessage (NULL);
-	UnlockMutex (GraphicsLock);
 
 	return TRUE;
 }
diff -ruNp src.hd/uqm/planets/scan.c src/uqm/planets/scan.c
--- src.hd/uqm/planets/scan.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/scan.c	2017-12-29 00:57:49 -0800
@@ -16,14 +16,9 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "lander.h"
 #include "lifeform.h"
 #include "scan.h"
-
-#include "../util.h"
-		/* for get_fuel_to_sol() */
 #include "../build.h"
 #include "../colors.h"
 #include "../cons_res.h"
@@ -35,13 +30,13 @@
 #include "../nameref.h"
 #include "../resinst.h"
 #include "../settings.h"
-#include "../load.h"
-#include "../util.h"
+#include "../util.h" // for get_fuel_to_sol()
 #include "../process.h"
 #include "../setup.h"
 #include "../sounds.h"
 #include "../state.h"
 #include "../sis.h"
+#include "../save.h"
 #include "options.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/graphics/drawable.h"
@@ -78,12 +73,12 @@ void
 RepairBackRect (RECT *pRect, BOOLEAN Fullscreen)
 {
 	RECT new_r, old_r;
-	
+
 	GetContextClipRect (&old_r);
 	new_r.corner.x = pRect->corner.x + old_r.corner.x;
 	new_r.corner.y = pRect->corner.y + old_r.corner.y;
 	new_r.extent = pRect->extent;
-	
+
 	new_r.extent.height += new_r.corner.y & 1;
 	new_r.corner.y &= ~1;
 	
@@ -96,15 +91,12 @@ RepairBackRect (RECT *pRect, BOOLEAN Ful
 static void
 EraseCoarseScan (void)
 {
-	LockMutex (GraphicsLock);
 	SetContext (PlanetContext);
 	
 	BatchGraphics ();
 	DrawStarBackGround ();
 	DrawDefaultPlanetSphere ();
 	UnbatchGraphics ();
-	
-	UnlockMutex (GraphicsLock);
 }
 
 static void
@@ -179,7 +171,6 @@ PrintCoarseScanPC (void)
 
 	GetPlanetTitle (buf, sizeof (buf));
 
-	LockMutex (GraphicsLock);
 	SetContext (PlanetContext);
 
 	t.align = ALIGN_CENTER;
@@ -193,7 +184,6 @@ PrintCoarseScanPC (void)
 	font_DrawText (&t);
 
 	SetContextFont (TinyFont);
-	UnlockMutex (GraphicsLock);
 
 #define LEFT_SIDE_BASELINE_X_PC (5 << RESOLUTION_FACTOR) // JMS_GFX
 #define RIGHT_SIDE_BASELINE_X_PC (SIS_SCREEN_WIDTH - (75 << RESOLUTION_FACTOR)) // JMS_GFX
@@ -202,7 +192,6 @@ PrintCoarseScanPC (void)
 	t.baseline.y = SCAN_BASELINE_Y_PC;
 	t.align = ALIGN_LEFT;
 
-	LockMutex (GraphicsLock);
 	PrintScanTitlePC (&t, &r, GAME_STRING (ORBITSCAN_STRING_BASE),
 			LEFT_SIDE_BASELINE_X_PC); // "Orbit: "
 	val = ((pSolarSysState->SysInfo.PlanetInfo.PlanetToSunDist * 100L
@@ -213,9 +202,7 @@ PrintCoarseScanPC (void)
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING_PC;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	PrintScanTitlePC (&t, &r, GAME_STRING (ORBITSCAN_STRING_BASE + 2),
 			LEFT_SIDE_BASELINE_X_PC); // "Atmo: "
 	if (pSolarSysState->SysInfo.PlanetInfo.AtmoDensity == GAS_GIANT_ATMOSPHERE)
@@ -231,14 +218,11 @@ PrintCoarseScanPC (void)
 		MakeScanValue (buf, val,
 				GAME_STRING (ORBITSCAN_STRING_BASE + 5)); // " atm"
 	}
-
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING_PC;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	PrintScanTitlePC (&t, &r, GAME_STRING (ORBITSCAN_STRING_BASE + 6),
 			LEFT_SIDE_BASELINE_X_PC); // "Temp: "
 	sprintf (buf, "%d" STR_DEGREE_SIGN " c",
@@ -260,9 +244,7 @@ PrintCoarseScanPC (void)
 	font_DrawText (&t);
 	SetContextForeGroundColor (OldColor);
 	t.baseline.y += SCAN_LEADING_PC;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	PrintScanTitlePC (&t, &r, GAME_STRING (ORBITSCAN_STRING_BASE + 7),
 			LEFT_SIDE_BASELINE_X_PC); // "Weather: "
 	if (pSolarSysState->SysInfo.PlanetInfo.AtmoDensity == 0)
@@ -291,9 +273,7 @@ PrintCoarseScanPC (void)
 	font_DrawText (&t);
 	SetContextForeGroundColor (OldColor);
 	t.baseline.y += SCAN_LEADING_PC;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	PrintScanTitlePC (&t, &r, GAME_STRING (ORBITSCAN_STRING_BASE + 10),
 			LEFT_SIDE_BASELINE_X_PC); // "Tectonics: "
 	if (PLANSIZE (pSolarSysState->SysInfo.PlanetInfo.PlanDataPtr->Type) ==
@@ -322,11 +302,8 @@ PrintCoarseScanPC (void)
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	SetContextForeGroundColor (OldColor);
-	UnlockMutex (GraphicsLock);
-
 	t.baseline.y = SCAN_BASELINE_Y_PC;
 
-	LockMutex (GraphicsLock);
 	PrintScanTitlePC (&t, &r, GAME_STRING (ORBITSCAN_STRING_BASE + 11),
 			RIGHT_SIDE_BASELINE_X_PC); // "Mass: "
 	val = pSolarSysState->SysInfo.PlanetInfo.PlanetRadius;
@@ -341,9 +318,7 @@ PrintCoarseScanPC (void)
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING_PC;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	PrintScanTitlePC (&t, &r, GAME_STRING (ORBITSCAN_STRING_BASE + 13),
 			RIGHT_SIDE_BASELINE_X_PC); // "Radius: "
 	val = pSolarSysState->SysInfo.PlanetInfo.PlanetRadius;
@@ -353,9 +328,7 @@ PrintCoarseScanPC (void)
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING_PC;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	PrintScanTitlePC (&t, &r, GAME_STRING (ORBITSCAN_STRING_BASE + 14),
 			RIGHT_SIDE_BASELINE_X_PC); // "Gravity: "
 	val = pSolarSysState->SysInfo.PlanetInfo.SurfaceGravity;
@@ -367,9 +340,7 @@ PrintCoarseScanPC (void)
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING_PC;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	PrintScanTitlePC (&t, &r, GAME_STRING (ORBITSCAN_STRING_BASE + 16),
 			RIGHT_SIDE_BASELINE_X_PC); // "Day: "
 	val = (SDWORD)pSolarSysState->SysInfo.PlanetInfo.RotationPeriod
@@ -380,9 +351,7 @@ PrintCoarseScanPC (void)
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING_PC;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	PrintScanTitlePC (&t, &r, GAME_STRING (ORBITSCAN_STRING_BASE + 18),
 			RIGHT_SIDE_BASELINE_X_PC); // "Tilt: "
 	val = pSolarSysState->SysInfo.PlanetInfo.AxialTilt;
@@ -392,7 +361,6 @@ PrintCoarseScanPC (void)
 	sprintf (buf, "%d" STR_DEGREE_SIGN, val);
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
-	UnlockMutex (GraphicsLock);
 }
 
 static void
@@ -414,7 +382,6 @@ PrintCoarseScan3DO (void)
 
 	GetPlanetTitle (buf, sizeof (buf));
 
-	LockMutex (GraphicsLock);
 	SetContext (PlanetContext);
 
 	t.align = ALIGN_CENTER;
@@ -432,8 +399,6 @@ PrintCoarseScan3DO (void)
 	s.frame = SetAbsFrameIndex (SpaceJunkFrame, 20);
 	DrawStamp (&s);
 
-	UnlockMutex (GraphicsLock);
-
 #define LEFT_SIDE_BASELINE_X ((27 + (16 - SAFE_X)) << RESOLUTION_FACTOR) // JMS_GFX
 #define RIGHT_SIDE_BASELINE_X (SIS_SCREEN_WIDTH - LEFT_SIDE_BASELINE_X)
 #define SCAN_BASELINE_Y (25 << RESOLUTION_FACTOR) // JMS_GFX
@@ -442,7 +407,6 @@ PrintCoarseScan3DO (void)
 	t.baseline.y = SCAN_BASELINE_Y;
 	t.align = ALIGN_LEFT;
 
-	LockMutex (GraphicsLock);
 	t.pStr = buf;
 	val = ((pSolarSysState->SysInfo.PlanetInfo.PlanetToSunDist * 100L
 			+ (EARTH_RADIUS >> 1)) / EARTH_RADIUS);
@@ -451,9 +415,7 @@ PrintCoarseScan3DO (void)
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	t.pStr = buf;
 	if (pSolarSysState->SysInfo.PlanetInfo.AtmoDensity == GAS_GIANT_ATMOSPHERE)
 		strcpy (buf, STR_INFINITY_SIGN);
@@ -467,13 +429,10 @@ PrintCoarseScan3DO (void)
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	t.pStr = buf;
 	sprintf (buf, "%d" STR_DEGREE_SIGN " c",
 			pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature);
-
 #ifdef HAZARD_COLORS
 	if ((pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature) >= (100) &&
 	    (pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature) <= (400))
@@ -486,14 +445,11 @@ PrintCoarseScan3DO (void)
 		OldColor = SetContextForeGroundColor (BRIGHT_RED_COLOR);
 	}
 #endif
-
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	SetContextForeGroundColor (OldColor);
 	t.baseline.y += SCAN_LEADING;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	t.pStr = buf;
 	sprintf (buf, "%s %u", GAME_STRING (ORBITSCAN_STRING_BASE + 9), // Class
 			pSolarSysState->SysInfo.PlanetInfo.AtmoDensity == 0
@@ -515,8 +471,7 @@ PrintCoarseScan3DO (void)
 	font_DrawText (&t);
 	SetContextForeGroundColor (OldColor);
 	t.baseline.y += SCAN_LEADING;
-	UnlockMutex (GraphicsLock);
-	LockMutex (GraphicsLock);
+
 	t.pStr = buf;
 	sprintf (buf, "%s %u", GAME_STRING (ORBITSCAN_STRING_BASE + 9), // Class
 			PLANSIZE (
@@ -539,13 +494,11 @@ PrintCoarseScan3DO (void)
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	SetContextForeGroundColor (OldColor);
-	UnlockMutex (GraphicsLock);
 
 	t.baseline.x = RIGHT_SIDE_BASELINE_X;
 	t.baseline.y = SCAN_BASELINE_Y;
 	t.align = ALIGN_RIGHT;
 
-	LockMutex (GraphicsLock);
 	t.pStr = buf;
 	val = pSolarSysState->SysInfo.PlanetInfo.PlanetRadius;
 	val = ((DWORD) val * (DWORD) val * (DWORD) val / 100L
@@ -558,32 +511,26 @@ PrintCoarseScan3DO (void)
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	t.pStr = buf;
 	val = pSolarSysState->SysInfo.PlanetInfo.PlanetRadius;
 	MakeScanValue (buf, val,
-			GAME_STRING (ORBITSCAN_STRING_BASE + 12)); // " e.s."
+			GAME_STRING (ORBITSCAN_STRING_BASE + 15)); // " g."
 
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	t.pStr = buf;
 	val = pSolarSysState->SysInfo.PlanetInfo.SurfaceGravity;
 	if (val == 0)
 		val = 1;
 	MakeScanValue (buf, val,
-			GAME_STRING (ORBITSCAN_STRING_BASE + 15)); // " g."
+			GAME_STRING (ORBITSCAN_STRING_BASE + 17)); // " days"
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	t.pStr = buf;
 	val = pSolarSysState->SysInfo.PlanetInfo.AxialTilt;
 	if (val < 0)
@@ -592,9 +539,7 @@ PrintCoarseScan3DO (void)
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING;
-	UnlockMutex (GraphicsLock);
 
-	LockMutex (GraphicsLock);
 	t.pStr = buf;
 	val = (SDWORD)pSolarSysState->SysInfo.PlanetInfo.RotationPeriod
 			* 10 / 24;
@@ -602,7 +547,6 @@ PrintCoarseScan3DO (void)
 			GAME_STRING (ORBITSCAN_STRING_BASE + 17)); // " days"
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
-	UnlockMutex (GraphicsLock);
 }
 
 static void
@@ -785,11 +729,11 @@ DispatchLander (void)
 	// Deactivate planet rotation callback
 	oldCallback = SetInputCallback (NULL);
 
-	LockMutex (GraphicsLock);
-	DeltaSISGauges (0, -landingFuel, 0);
+	if (!optInfiniteFuel)
+		DeltaSISGauges (0, -landingFuel, 0);
+
 	SetContext (ScanContext);
 	drawPlanetCursor (FALSE);
-	UnlockMutex (GraphicsLock);
 
 	PlanetSide (planetLoc);
 	if (GLOBAL (CurrentActivity) & CHECK_ABORT)
@@ -830,8 +774,9 @@ DoPickPlanetSide (MENU_STATE *pMS)
 	PICK_PLANET_STATE *pickState = pMS->privData;
 	DWORD TimeIn = GetTimeCounter ();
 	BOOLEAN select, cancel;
+
 	POINT	new_pt;
-	
+
 	select = PulsedInputState.menu[KEY_MENU_SELECT];
 	cancel = PulsedInputState.menu[KEY_MENU_CANCEL];
 	
@@ -840,7 +785,7 @@ DoPickPlanetSide (MENU_STATE *pMS)
 		pickState->success = false;
 		return FALSE;
 	}
-	
+
 	if (cancel)
 	{
 		pickState->success = false;
@@ -856,9 +801,9 @@ DoPickPlanetSide (MENU_STATE *pMS)
 		COUNT	i, j = 0; // JMS_GFX
 		SIZE	dx = 0;
 		SIZE	dy = 0;
-		
+
 		new_pt = planetLoc;
-		
+
 		if (CurrentInputState.menu[KEY_MENU_LEFT])
 			dx = -1;
 		if (CurrentInputState.menu[KEY_MENU_RIGHT])
@@ -867,10 +812,12 @@ DoPickPlanetSide (MENU_STATE *pMS)
 			dy = -1;
 		if (CurrentInputState.menu[KEY_MENU_DOWN])
 			dy = 1;
-		
+
+		// BatchGraphics ();
+
 		dx = dx << MAG_SHIFT;
 		dy = dy << MAG_SHIFT;
-		
+
 		// JMS_GFX: 1 for 320x240, 3 for 640x480, 7 for 1280x960
 		// XXX: This was good for debugging build, but too fast on opitmized release build.
 		//j = (1 << (RESOLUTION_FACTOR + 1)) - 1;
@@ -882,7 +829,6 @@ DoPickPlanetSide (MENU_STATE *pMS)
 		// (Originally there was no loop, just the contents.)
 		for (i = 0; i < j; i++)
 		{
-			LockMutex (GraphicsLock);
 			BatchGraphics ();
 			
 			if (dx)
@@ -919,28 +865,8 @@ DoPickPlanetSide (MENU_STATE *pMS)
 				SleepThreadUntil (TimeIn + ONE_SECOND / 40);
 			
 			UnbatchGraphics ();
-			UnlockMutex (GraphicsLock);
 		}
 	}
-	
-	// JMS_GFX: For some reason, 1280x960 is choppy, no matter how many iterations
-	// the loop has or how short the sleepthread is. This final redraw makes things
-	// a bit smoother.
-	// XXX: This was good at debugging build but mad the cursor blink too fast in optimized release build.
-	/*if (RESOLUTION_FACTOR == 2)
-	 {
-	 LockMutex (GraphicsLock);
-	 BatchGraphics ();
-	 
-	 if (!pointsEqual (new_pt, planetLoc))
-	 setPlanetLoc (new_pt, TRUE);
-	 
-	 flashPlanetLocation ();
-	 
-	 UnbatchGraphics ();
-	 UnlockMutex (GraphicsLock);
-	 }*/
-	
 	return TRUE;
 }
 
@@ -951,7 +877,6 @@ drawLandingFuelUsage (COUNT fuel)
 	 * and fix it when we're done.
 	 */
 	StatMsgMode old_status_message_mode;
-
 	UNICODE buf[100];
 
 	if (((SDWORD) (GLOBAL_SIS (FuelOnBoard)) - fuel) <= (SDWORD)(get_fuel_to_sol ()))
@@ -973,9 +898,7 @@ drawLandingFuelUsage (COUNT fuel)
 static void
 eraseLandingFuelUsage (void)
 {
-	LockMutex (GraphicsLock);
 	DrawStatusMessage (NULL);
-	UnlockMutex (GraphicsLock);
 }
 
 static BOOLEAN
@@ -989,7 +912,6 @@ PickPlanetSide (void)
 	memset (&MenuState, 0, sizeof MenuState);
 	MenuState.privData = &PickState;
 
-	LockMutex (GraphicsLock);
 	ClearSISRect (CLEAR_SIS_RADAR);
 	SetContext (ScanContext);
 	BatchGraphics ();
@@ -1001,7 +923,6 @@ PickPlanetSide (void)
 	// Set the current flash location
 	setPlanetCursorLoc (planetLoc);
 	savePlanetLocationImage ();
-	UnlockMutex (GraphicsLock);
 
 	InitLander (0);
 
@@ -1018,9 +939,7 @@ PickPlanetSide (void)
 	}
 	else
 	{	// player bailed out
-		LockMutex (GraphicsLock);
 		restorePlanetLocationImage ();
-		UnlockMutex (GraphicsLock);
 	}
 
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
@@ -1109,20 +1028,20 @@ DrawScannedStuff (COUNT y, COUNT scan)
 }
 
 COUNT
-callGenerateForScanType (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
-		COUNT node, BYTE scanType)
+callGenerateForScanType (const SOLARSYS_STATE *solarSys,
+		const PLANET_DESC *world, COUNT node, BYTE scanType, NODE_INFO *info)
 {
 	switch (scanType)
 	{
 		case MINERAL_SCAN:
 			return (*solarSys->genFuncs->generateMinerals) (
-					solarSys, world, node);
+					solarSys, world, node, info);
 		case ENERGY_SCAN:
 			return (*solarSys->genFuncs->generateEnergy) (
-					solarSys, world, node);
+					solarSys, world, node, info);
 		case BIOLOGICAL_SCAN:
 			return (*solarSys->genFuncs->generateLife) (
-					solarSys, world, node);
+					solarSys, world, node, info);
 	}
 
 	assert (false);
@@ -1153,9 +1072,6 @@ callPickupForScanType (SOLARSYS_STATE *s
 static void
 ScanPlanet (COUNT scanType)
 {
-// BW: picked up experimentally ; any value that results into
-// SCAN_LINE_WAIT below 6 makes scanning hang up badly
-// Is this specific to my machine ?
 #define SCAN_DURATION   RES_CASE(ONE_SECOND * 7 / 4, ONE_SECOND * 7 / 4, ONE_SECOND * 12 / 4)
 // NUM_FLASH_COLORS for flashing blips; 1 for the final frame
 #define SCAN_LINES      (MAP_HEIGHT + NUM_FLASH_COLORS - 8)
@@ -1203,7 +1119,6 @@ ScanPlanet (COUNT scanType)
 
 		t.pStr = GAME_STRING (SCAN_STRING_BASE + scan);
 
-		LockMutex (GraphicsLock);
 		SetContext (PlanetContext);
 		r.corner.x = 0;
 		r.corner.y = t.baseline.y - (10 << RESOLUTION_FACTOR); // JMS_GFX
@@ -1218,14 +1133,11 @@ ScanPlanet (COUNT scanType)
 		font_DrawText (&t);
 
 		SetContext (ScanContext);
-		UnlockMutex (GraphicsLock);
 
 		// Draw a virgin surface
-		LockMutex (GraphicsLock);
 		BatchGraphics ();
 		DrawPlanet (0, BLACK_COLOR);
 		UnbatchGraphics ();
-		UnlockMutex (GraphicsLock);
 
 		tintColor = tintColors[scan];
 
@@ -1237,7 +1149,6 @@ ScanPlanet (COUNT scanType)
 			if (WaitForAnyButtonUntil (TRUE, TimeOut, FALSE))
 				break;
 
-			LockMutex (GraphicsLock);
 			BatchGraphics ();
 			DrawPlanet (i, tintColor);
 			DrawScannedStuff (i, scan);
@@ -1245,21 +1156,17 @@ ScanPlanet (COUNT scanType)
 #ifdef SPIN_ON_SCAN
 			RotatePlanetSphere (TRUE);
 #endif
-			UnlockMutex (GraphicsLock);
 		}
 
 		if (i < (SWORD)SCAN_LINES)
 		{	// Aborted by a keypress; draw in finished state
-			LockMutex (GraphicsLock);
 			BatchGraphics ();
 			DrawPlanet (SCAN_LINES - 1, tintColor);
 			DrawScannedStuff (SCAN_LINES - 1, scan);
 			UnbatchGraphics ();
-			UnlockMutex (GraphicsLock);
 		}
 	}
 
-	LockMutex (GraphicsLock);
 	SetContext (PlanetContext);
 	RepairBackRect (&r, FALSE);
 
@@ -1270,7 +1177,6 @@ ScanPlanet (COUNT scanType)
 		DrawScannedObjects (FALSE);
 	}
 
-	UnlockMutex (GraphicsLock);
 	FlushInput ();
 }
 
@@ -1312,17 +1218,13 @@ DoScan (MENU_STATE *pMS)
 				return TRUE;
 			}
 
-			LockMutex (GraphicsLock);
 			SetFlashRect (NULL);
-			UnlockMutex (GraphicsLock);
 
 			if (!PickPlanetSide ())
 				return FALSE;
 
 			DrawMenuStateStrings (PM_MIN_SCAN, pMS->CurState);
-			LockMutex (GraphicsLock);
 			SetFlashRect (SFR_MENU_3DO);
-			UnlockMutex (GraphicsLock);
 
 			return TRUE;
 		}
@@ -1412,9 +1314,7 @@ ScanSystem (void)
 
 	memset (&MenuState, 0, sizeof MenuState);
 
-	LockMutex (GraphicsLock);
 	GetScanContext (NULL);
-	UnlockMutex (GraphicsLock);
 
 	if (optWhichMenu == OPT_3DO &&
 			((pSolarSysState->pOrbitalDesc->data_index & PLANET_SHIELDED)
@@ -1429,17 +1329,13 @@ ScanSystem (void)
 		planetLoc.x = (MAP_WIDTH >> 1) << MAG_SHIFT;
 		planetLoc.y = (MAP_HEIGHT >> 1) << MAG_SHIFT;
 
-		LockMutex (GraphicsLock);
 		initPlanetLocationImage ();
 		SetContext (ScanContext);
 		DrawScannedObjects (FALSE);
-		UnlockMutex (GraphicsLock);
 	}
 
 	DrawMenuStateStrings (PM_MIN_SCAN, MenuState.CurState);
-	LockMutex (GraphicsLock);
 	SetFlashRect (SFR_MENU_3DO);
-	UnlockMutex (GraphicsLock);
 
 	if (optWhichCoarseScan == OPT_PC)
 		PrintCoarseScanPC ();
@@ -1451,18 +1347,14 @@ ScanSystem (void)
 	MenuState.InputFunc = DoScan;
 	DoInput (&MenuState, FALSE);
 
-	LockMutex (GraphicsLock);
 	SetFlashRect (NULL);
-	UnlockMutex (GraphicsLock);
 
 	// cleanup scan graphics
-	LockMutex (GraphicsLock);
 	BatchGraphics ();
 	SetContext (ScanContext);
 	DrawPlanet (0, BLACK_COLOR);
 	EraseCoarseScan ();
 	UnbatchGraphics ();
-	UnlockMutex (GraphicsLock);
 
 	DestroyDrawable (ReleaseDrawable (eraseFrame));
 	eraseFrame = NULL;
@@ -1470,27 +1362,23 @@ ScanSystem (void)
 
 static void
 generateBioNode (SOLARSYS_STATE *system, ELEMENT *NodeElementPtr,
-		BYTE *life_init_tab)
+		BYTE *life_init_tab, COUNT creatureType)
 {
 	COUNT i;
-	COUNT creatureType;
 	DWORD j;
 
-	creatureType = system->SysInfo.PlanetInfo.CurType;
-
+	// NOTE: TFB_Random() calls here are NOT part of the deterministic planet
+	//   generation PRNG flow.
 	if (CreatureData[creatureType].Attributes & SPEED_MASK)
 	{
 		// Place moving creatures at a random location.
-		i = (COUNT)TFB_Random ();
+		i = TFB_Random ();
 		j = (DWORD)TFB_Random ();
 		
-		if (RESOLUTION_FACTOR == 0)
-		{
+		if (RESOLUTION_FACTOR == 0) {
 			NodeElementPtr->current.location.x = (LOBYTE (i) % (MAP_WIDTH - (8 << 1))) + 8;
 			NodeElementPtr->current.location.y = (HIBYTE (i) % (MAP_HEIGHT - (8 << 1))) + 8;
-		}
-		else 
-		{
+		} else {
 			NodeElementPtr->current.location.x = (LOWORD (j) % (MAP_WIDTH - (8 << 1))) + 8;	// JMS_GFX: Replaced previous line with this line (BYTE was too small for 640x480 maps.)
 			NodeElementPtr->current.location.y = (HIWORD (j) % (MAP_HEIGHT - (8 << 1))) + 8;  // JMS_GFX: Replaced previous line with this line (BYTE was too small for 1280x960 maps.)
 		}
@@ -1529,6 +1417,7 @@ GeneratePlanetSide (void)
 			// life_init_tab is filled with the creature types of already
 			// selected creatures. If an entry is 0, none has been selected
 			// yet, otherwise, it is 1 more than the creature type.
+
 	InitDisplayList ();
 	if (pSolarSysState->pOrbitalDesc->data_index & PLANET_SHIELDED)
 		return;
@@ -1544,12 +1433,13 @@ GeneratePlanetSide (void)
 				NUM_SCANDOT_TRANSITIONS * (scan - ENERGY_SCAN));
 
 		num_nodes = callGenerateForScanType (pSolarSysState,
-				pSolarSysState->pOrbitalDesc, ~0, scan);
+				pSolarSysState->pOrbitalDesc, GENERATE_ALL, scan, NULL);
 
 		while (num_nodes--)
 		{
 			HELEMENT hNodeElement;
 			ELEMENT *NodeElementPtr;
+			NODE_INFO info;
 
 			if (isNodeRetrieved (&pSolarSysState->SysInfo.PlanetInfo,
 					scan, num_nodes))
@@ -1563,33 +1453,28 @@ GeneratePlanetSide (void)
 
 			callGenerateForScanType (pSolarSysState,
 					pSolarSysState->pOrbitalDesc, num_nodes,
-					scan);
+					scan, &info);
 
 			NodeElementPtr->scan_node = MAKE_WORD (scan, num_nodes + 1);
 			NodeElementPtr->playerNr = PS_NON_PLAYER;
-			NodeElementPtr->current.location.x =
-					pSolarSysState->SysInfo.PlanetInfo.CurPt.x;
-			NodeElementPtr->current.location.y =
-					pSolarSysState->SysInfo.PlanetInfo.CurPt.y;
+			NodeElementPtr->current.location.x = info.loc_pt.x;
+			NodeElementPtr->current.location.y = info.loc_pt.y;
 
 			SetPrimType (&DisplayArray[NodeElementPtr->PrimIndex], STAMP_PRIM);
 			if (scan == MINERAL_SCAN)
 			{
-				COUNT EType;
+				NodeElementPtr->turn_wait = info.type;
 
-				EType = pSolarSysState->SysInfo.PlanetInfo.CurType;
-				NodeElementPtr->turn_wait = (BYTE)EType;
-				
 				// JMS: Partially scavenged energy blips won't return anymore to original size after leaving planet.
-				NodeElementPtr->mass_points = HIBYTE (pSolarSysState->SysInfo.PlanetInfo.CurDensity)
+				NodeElementPtr->mass_points = HIBYTE (info.density)
 				- pSolarSysState->SysInfo.PlanetInfo.PartiallyScavengedList[scan][num_nodes];
-				
+
 				NodeElementPtr->current.image.frame = SetAbsFrameIndex (
 						MiscDataFrame, (NUM_SCANDOT_TRANSITIONS * 2)
-						+ ElementCategory (EType) * 5);
+						+ ElementCategory (info.type) * 5);
 				NodeElementPtr->next.image.frame = SetRelFrameIndex (
-						NodeElementPtr->current.image.frame, LOBYTE (
-						pSolarSysState->SysInfo.PlanetInfo.CurDensity) + 1);
+						NodeElementPtr->current.image.frame,
+						LOBYTE (info.density) + 1);
 				DisplayArray[NodeElementPtr->PrimIndex].Object.Stamp.frame =
 						IncFrameIndex (NodeElementPtr->next.image.frame);
 			}
@@ -1609,7 +1494,7 @@ GeneratePlanetSide (void)
 				else /* (scan == BIOLOGICAL_SCAN) */
 				{
 					generateBioNode (pSolarSysState, NodeElementPtr,
-							life_init_tab);
+							life_init_tab, info.type);
 				}
 			}
 
diff -ruNp src.hd/uqm/planets/scan.h src/uqm/planets/scan.h
--- src.hd/uqm/planets/scan.h	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/scan.h	2017-12-29 00:57:49 -0800
@@ -26,6 +26,9 @@ typedef struct scan_block SCAN_BLOCK;
 #include "libs/gfxlib.h"
 #include "planets.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
 struct scan_desc
 {
@@ -47,8 +50,8 @@ extern void ScanSystem (void);
 
 extern void RepairBackRect (RECT *pRect, BOOLEAN Fullscreen);
 extern void GeneratePlanetSide (void);
-extern COUNT callGenerateForScanType (SOLARSYS_STATE *solarSys,
-		PLANET_DESC *world, COUNT node, BYTE scanType);
+extern COUNT callGenerateForScanType (const SOLARSYS_STATE *,
+		const PLANET_DESC *world, COUNT node, BYTE scanType, NODE_INFO *);
 // Returns true if the node should be removed from the surface
 extern bool callPickupForScanType (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT node, BYTE scanType);
@@ -62,5 +65,9 @@ COUNT countNodesRetrieved (PLANET_INFO *
 void setNodeRetrieved (PLANET_INFO *planetInfo, BYTE scanType, BYTE nodeNr);
 void setNodeNotRetrieved (PLANET_INFO *planetInfo, BYTE scanType, BYTE nodeNr);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _SCAN_H */
 
diff -ruNp src.hd/uqm/planets/solarsys.c src/uqm/planets/solarsys.c
--- src.hd/uqm/planets/solarsys.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/solarsys.c	2017-12-29 00:57:49 -0800
@@ -16,15 +16,13 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
+#include "solarsys.h"
 #include "lander.h"
-#include "scan.h"
 #include "../colors.h"
 #include "../controls.h"
 #include "../menustat.h"
 		// for DrawMenuStateStrings()
-#include "../encount.h"
+#include "../starmap.h"
 #include "../races.h"
 #include "../gamestr.h"
 #include "../gendef.h"
@@ -39,22 +37,23 @@
 #include "../ipdisp.h"
 #include "../grpinfo.h"
 #include "../process.h"
-#include "../load.h"
 #include "../setup.h"
 #include "../sounds.h"
 #include "../state.h"
 #include "../uqmdebug.h"
+#include "../save.h"
 #include "options.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/mathlib.h"
 #include "libs/log.h"
 #include "libs/misc.h"
+#include "scan.h"
 
 #include <math.h>
 #include <time.h>
 
-//#define DEBUG_SOLARSYS
-//#define SMOOTH_SYSTEM_ZOOM  1
+// #define DEBUG_SOLARSYS
+#define SMOOTH_SYSTEM_ZOOM  1
 
 #define IP_FRAME_RATE  (ONE_SECOND / 30)
 
@@ -109,6 +108,7 @@ static FRAME SolarSysFrame;
 static RECT scaleRect;
 		// system zooms in when the flagship enters this rect
 
+RandomContext *SysGenRNG;
 
 #define DISPLAY_TO_LOC  (DISPLAY_FACTOR >> 1)
 
@@ -225,14 +225,43 @@ playerInInnerSystem (void)
 	return pSolarSysState->pBaseDesc != pSolarSysState->PlanetDesc;
 }
 
-void GenerateTexturedMoons (SOLARSYS_STATE *system, PLANET_DESC *planet)
+// Sets the SysGenRNG to the required state first.
+static void
+GenerateMoons (SOLARSYS_STATE *system, PLANET_DESC *planet)
+{
+	COUNT i;
+	COUNT facing;
+	PLANET_DESC *pMoonDesc;
+
+	RandomContext_SeedRandom (SysGenRNG, planet->rand_seed);
+
+	for (i = 0, pMoonDesc = &system->MoonDesc[0];
+			i < MAX_MOONS; ++i, ++pMoonDesc)
+	{
+		pMoonDesc->pPrevDesc = planet;
+		if (i >= planet->NumPlanets)
+			continue;
+		
+		pMoonDesc->temp_color = planet->temp_color;
+	}
+
+	(*system->genFuncs->generateName) (system, planet);
+	(*system->genFuncs->generateMoons) (system, planet);
+
+	facing = NORMALIZE_FACING (ANGLE_TO_FACING (
+			ARCTAN (planet->location.x, planet->location.y)));
+}
+
+static void
+GenerateTexturedMoons (SOLARSYS_STATE *system, PLANET_DESC *planet)
 {
 	COUNT i;
 	FRAME SurfFrame;
 	PLANET_DESC *pMoonDesc;
+
 	PLANET_DESC *previousOrbitalDesc;
 	previousOrbitalDesc = pSolarSysState->pOrbitalDesc;
-	
+
 	for (i = 0, pMoonDesc = &system->MoonDesc[0];
 			i < planet->NumPlanets; ++i, ++pMoonDesc)
 	{
@@ -253,111 +282,76 @@ void GenerateTexturedMoons (SOLARSYS_STA
 			
 				COUNT curr_planet_index = planetIndex (pSolarSysState, planet);
 		
-				if (curr_planet_index == 2)
-				{
+				if (curr_planet_index == 2) {
 					// EARTH
-					switch (i)
-					{
+					switch (i) {
 						case 1: /* LUNA */
-							SurfFrame = CaptureDrawable (LoadGraphic (IP_LUNA_MASK_ANIM));
+							if (solTexturesPresent)
+								SurfFrame = CaptureDrawable (LoadGraphic (IP_LUNA_MASK_ANIM));
+							pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 0;
+							pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 240 * 29;
 							break;
 					}
-				}
-				else if (curr_planet_index == 4)
-				{
+				} else if (curr_planet_index == 4) {
 					// JUPITER
-					switch (i)
-					{
+					switch (i) {
 						case 0: /* IO */
-							SurfFrame = CaptureDrawable (LoadGraphic (IP_IO_MASK_ANIM));
+							if (solTexturesPresent)
+								SurfFrame = CaptureDrawable (LoadGraphic (IP_IO_MASK_ANIM));
+							pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 390;
 							break;
 						case 1: /* EUROPA */
-							SurfFrame = CaptureDrawable (LoadGraphic (IP_EUROPA_MASK_ANIM));
+							if (solTexturesPresent)
+								SurfFrame = CaptureDrawable (LoadGraphic (IP_EUROPA_MASK_ANIM));
+							pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 840;
 							break;
 						case 2: /* GANYMEDE */
-							SurfFrame = CaptureDrawable (LoadGraphic (IP_GANYMEDE_MASK_ANIM));
+							if (solTexturesPresent)
+								SurfFrame = CaptureDrawable (LoadGraphic (IP_GANYMEDE_MASK_ANIM));
+							pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 1728;
 							break;
 						case 3: /* CALLISTO */
-							SurfFrame = CaptureDrawable (LoadGraphic (IP_CALLISTO_MASK_ANIM));
+							if (solTexturesPresent)
+								SurfFrame = CaptureDrawable (LoadGraphic (IP_CALLISTO_MASK_ANIM));
+							pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 4008;
 							break;
 					}
-				}
-				else if (curr_planet_index == 5)
-				{
+				} else if (curr_planet_index == 5) {
 					// SATURN
-					switch (i)
-					{
+					switch (i) {
 						case 0: /* TITAN */
-							SurfFrame = CaptureDrawable (LoadGraphic (IP_TITAN_MASK_ANIM));
+							if (solTexturesPresent)
+								SurfFrame = CaptureDrawable (LoadGraphic (IP_TITAN_MASK_ANIM));
+							pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 3816;
 							break;
 					}
-				}
-				else if (curr_planet_index == 7)
-				{
+				} else if (curr_planet_index == 7) {
 					// NEPTUNE
-					switch (i)
-					{
+					switch (i) {
 						case 0: /* TRITON */
-							SurfFrame = CaptureDrawable (LoadGraphic (IP_TRITON_MASK_ANIM));
+							if (solTexturesPresent)
+								SurfFrame = CaptureDrawable (LoadGraphic (IP_TRITON_MASK_ANIM));
+							pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 4300;
 							break;
 					}
 				}
 			}
 
-			GeneratePlanetSurfaceForIP (pMoonDesc, SurfFrame, GENERATE_MOON_PERIMETER, GENERATE_MOON_DIAMETER);
+			GeneratePlanetSurface (pMoonDesc, SurfFrame, GENERATE_MOON_PERIMETER, GENERATE_MOON_DIAMETER, FALSE);
 			pMoonDesc->orbit = pSolarSysState->Orbit;
-			PrepareNextRotationFrameForIP (pMoonDesc, 0);
+			PrepareNextRotationFrame (pMoonDesc, 0, FALSE);
 
-			// Clean up some parasitic use of pSolarSysState
-			LockMutex (GraphicsLock);
-			// DestroyDrawable (ReleaseDrawable (pSolarSysState->Orbit.TintFrame));
-			// pSolarSysState->Orbit.TintFrame = 0;
-			// pSolarSysState->Orbit.TintColor = BLACK_COLOR;
-		
-			// DestroyDrawable (ReleaseDrawable (pSolarSysState->Orbit.TopoZoomFrame));
-			// pSolarSysState->Orbit.TopoZoomFrame = 0;
 			DestroyStringTable (ReleaseStringTable (pSolarSysState->XlatRef));
 			pSolarSysState->XlatRef = 0;
 			DestroyDrawable (ReleaseDrawable (pSolarSysState->TopoFrame));
 			pSolarSysState->TopoFrame = 0;
 			DestroyColorMap (ReleaseColorMap (pSolarSysState->OrbitalCMap));
 			pSolarSysState->OrbitalCMap = 0;
-			UnlockMutex (GraphicsLock);
-			// End clean up
 		}
 	}
 	pSolarSysState->pOrbitalDesc = previousOrbitalDesc;
 }
 
-static void
-GenerateMoons (SOLARSYS_STATE *system, PLANET_DESC *planet)
-{
-	COUNT i;
-	COUNT facing;
-	PLANET_DESC *pMoonDesc;
-	DWORD old_seed;
-
-	old_seed = TFB_SeedRandom (planet->rand_seed);
-
-	for (i = 0, pMoonDesc = &system->MoonDesc[0];
-			i < MAX_MOONS; ++i, ++pMoonDesc)
-	{
-		pMoonDesc->pPrevDesc = planet;
-		if (i >= planet->NumPlanets)
-			continue;
-		
-		pMoonDesc->temp_color = planet->temp_color;
-	}
-
-	(*system->genFuncs->generateName) (system, planet);
-	(*system->genFuncs->generateMoons) (system, planet);
-
-	facing = NORMALIZE_FACING (ANGLE_TO_FACING (
-			ARCTAN (planet->location.x, planet->location.y)));
-
-	TFB_SeedRandom (old_seed);
-}
-
 void
 FreeIPData (void)
 {
@@ -375,18 +369,17 @@ FreeIPData (void)
 	SpaceJunkFrame = 0;
 	DestroyMusic (SpaceMusic);
 	SpaceMusic = 0;
+
+	RandomContext_Delete (SysGenRNG);
+	SysGenRNG = NULL;
 }
 
 void
 LoadIPData (void)
 {
-	if (RESOLUTION_FACTOR == 0)
-	{
+	if (RESOLUTION_FACTOR == 0) {
 		SunFrame = CaptureDrawable (LoadGraphic (SUN_MASK_PMAP_ANIM));
-	}
-	// JMS: In hi-res separate animations are used for each star color.
-	else 
-	{
+	} else {
 		if (STAR_COLOR(CurStarDescPtr->Type) == BLUE_BODY)
 			SunFrame = CaptureDrawable (LoadGraphic (SUNBLUE_MASK_PMAP_ANIM));
 		else if (STAR_COLOR(CurStarDescPtr->Type) == GREEN_BODY)
@@ -400,20 +393,23 @@ LoadIPData (void)
 		else if (STAR_COLOR(CurStarDescPtr->Type) == YELLOW_BODY)
 			SunFrame = CaptureDrawable (LoadGraphic (SUNYELLOW_MASK_PMAP_ANIM));
 	}
-	
+
 	if (SpaceJunkFrame == 0)
 	{
-		SpaceJunkFrame = CaptureDrawable (
-				LoadGraphic (IPBKGND_MASK_PMAP_ANIM));
+		SpaceJunkFrame = CaptureDrawable (LoadGraphic (IPBKGND_MASK_PMAP_ANIM));
 		SISIPFrame = CaptureDrawable (LoadGraphic (SISIP_MASK_PMAP_ANIM));
 
 		OrbitalCMap = CaptureColorMap (LoadColorMap (ORBPLAN_COLOR_MAP));
-		OrbitalFrame = CaptureDrawable (
-				LoadGraphic (ORBPLAN_MASK_PMAP_ANIM));
+		OrbitalFrame = CaptureDrawable (LoadGraphic (ORBPLAN_MASK_PMAP_ANIM));
 		SunCMap = CaptureColorMap (LoadColorMap (IPSUN_COLOR_MAP));
 
 		SpaceMusic = LoadMusic (IP_MUSIC);
 	}
+
+	if (!SysGenRNG)
+	{
+		SysGenRNG = RandomContext_New ();
+	}
 }
 	
 
@@ -489,11 +485,10 @@ initSolarSysSISCharacteristics (void)
 	}
 }
 
-static DWORD
-seedRandomForSolarSys (void)
+DWORD
+GetRandomSeedForStar (const STAR_DESC *star)
 {
-	return TFB_SeedRandom (MAKE_DWORD (CurStarDescPtr->star_pt.x,
-			CurStarDescPtr->star_pt.y));
+	return MAKE_DWORD (star->star_pt.x, star->star_pt.y);
 }
 
 void GenerateTexturedPlanets (void)
@@ -513,83 +508,83 @@ void GenerateTexturedPlanets (void)
 		
 		// BW : precompute the generated texture to display it in IP
 		pSolarSysState->pOrbitalDesc = pCurDesc;
-		if (CurStarDescPtr->Index == SOL_DEFINED)
-		{	// png defined planets in Sol
-			switch (i)
-			{
-			case 0: /* MERCURY */
-				SurfFrame = CaptureDrawable (LoadGraphic (IP_MERCURY_MASK_ANIM));
-				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 3;
-				pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 59 * 240;
-				break;
-			case 1: /* VENUS */
-				SurfFrame = CaptureDrawable (LoadGraphic (IP_VENUS_MASK_ANIM));
-				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 177;
-				pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 243 * 240;
-				break;
-			case 2: // EARTH
-				SurfFrame = CaptureDrawable (LoadGraphic (IP_EARTH_MASK_ANIM));
-				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 23;
-				pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 240;
-				break;
-			case 3: // MARS
-				SurfFrame = CaptureDrawable (LoadGraphic (IP_MARS_MASK_ANIM));
-				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 24;
-				pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 246;
-				break;
-			case 4: /* JUPITER */
-				SurfFrame = CaptureDrawable (LoadGraphic (IP_JUPITER_MASK_ANIM));
-				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 3;
-				pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 98;
-				break;
-			case 5: /* SATURN */
-				SurfFrame = CaptureDrawable (LoadGraphic (IP_SATURN_MASK_ANIM));
-				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 27;
-				pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 102;
-				break;
-			case 6: /* URANUS */
-				SurfFrame = CaptureDrawable (LoadGraphic (IP_URANUS_MASK_ANIM));
-				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 98;
-				pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 172;
-				break;
-			case 7: /* NEPTUNE */
-				SurfFrame = CaptureDrawable (LoadGraphic (IP_NEPTUNE_MASK_ANIM));
-				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 30;
-				pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 182;
-				break;
-			case 8: /* PLUTO */
-				SurfFrame = CaptureDrawable (LoadGraphic (IP_PLUTO_MASK_ANIM));
-				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 119;
-				pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 1533;
-				break;
+		if (CurStarDescPtr->Index == SOL_DEFINED){
+			switch (i) {
+				case 0: /* MERCURY */
+					if (solTexturesPresent)
+						SurfFrame = CaptureDrawable (LoadGraphic (IP_MERCURY_MASK_ANIM));
+					pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 3;
+					pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 59 * 240;
+					break;
+				case 1: /* VENUS */
+					if (solTexturesPresent)
+						SurfFrame = CaptureDrawable (LoadGraphic (IP_VENUS_MASK_ANIM));
+					pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 177;
+					pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 243 * 240;
+					break;
+				case 2: // EARTH
+					if (solTexturesPresent)
+						SurfFrame = CaptureDrawable (LoadGraphic (IP_EARTH_MASK_ANIM));
+					else
+						SurfFrame = CaptureDrawable (LoadGraphic (EARTH_MASK_ANIM));
+					pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 23;
+					pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 240;
+					break;
+				case 3: // MARS
+					if (solTexturesPresent)
+						SurfFrame = CaptureDrawable (LoadGraphic (IP_MARS_MASK_ANIM));
+					pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 24;
+					pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 246;
+					break;
+				case 4: /* JUPITER */
+					if (solTexturesPresent)
+						SurfFrame = CaptureDrawable (LoadGraphic (IP_JUPITER_MASK_ANIM));
+					pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 3;
+					pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 98;
+					break;
+				case 5: /* SATURN */
+					if (solTexturesPresent)
+						SurfFrame = CaptureDrawable (LoadGraphic (IP_SATURN_MASK_ANIM));
+					pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 27;
+					pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 102;
+					break;
+				case 6: /* URANUS */
+					if (solTexturesPresent)
+						SurfFrame = CaptureDrawable (LoadGraphic (IP_URANUS_MASK_ANIM));
+					pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 98;
+					pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 172;
+					break;
+				case 7: /* NEPTUNE */
+					if (solTexturesPresent)
+						SurfFrame = CaptureDrawable (LoadGraphic (IP_NEPTUNE_MASK_ANIM));
+					pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 30;
+					pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 182;
+					break;
+				case 8: /* PLUTO */
+					if (solTexturesPresent)
+						SurfFrame = CaptureDrawable (LoadGraphic (IP_PLUTO_MASK_ANIM));
+					pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 119;
+					pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 1533;
+					break;
 			}
 		}
 		
-		GeneratePlanetSurfaceForIP (pCurDesc, SurfFrame, GENERATE_PLANET_PERIMETER, GENERATE_PLANET_DIAMETER);
+		GeneratePlanetSurface (pCurDesc, SurfFrame, GENERATE_PLANET_PERIMETER, GENERATE_PLANET_DIAMETER, FALSE);
 		pCurDesc->orbit = pSolarSysState->Orbit;
-		PrepareNextRotationFrameForIP (pCurDesc, 0);
+		PrepareNextRotationFrame (pCurDesc, 0, FALSE);
 		
 		// Clean up some parasitic use of pSolarSysState
-		LockMutex (GraphicsLock);
-		// DestroyDrawable (ReleaseDrawable (pSolarSysState->Orbit.TintFrame));
-		// pSolarSysState->Orbit.TintFrame = 0;
-		// pSolarSysState->Orbit.TintColor = BLACK_COLOR;
-		
-		// DestroyDrawable (ReleaseDrawable (pSolarSysState->Orbit.TopoZoomFrame));
-		// pSolarSysState->Orbit.TopoZoomFrame = 0;
 		DestroyStringTable (ReleaseStringTable (pSolarSysState->XlatRef));
 		pSolarSysState->XlatRef = 0;
 		DestroyDrawable (ReleaseDrawable (pSolarSysState->TopoFrame));
 		pSolarSysState->TopoFrame = 0;
 		DestroyColorMap (ReleaseColorMap (pSolarSysState->OrbitalCMap));
 		pSolarSysState->OrbitalCMap = 0;
-		UnlockMutex (GraphicsLock);
 		// End clean up
 	}
 	pSolarSysState->pOrbitalDesc = previousOrbitalDesc;
 }
 
-
 // Returns an orbital PLANET_DESC when player is in orbit
 static PLANET_DESC *
 LoadSolarSys (void)
@@ -597,9 +592,7 @@ LoadSolarSys (void)
 	COUNT i;
 	PLANET_DESC *orbital = NULL;
 	PLANET_DESC *pCurDesc;
-	DWORD old_seed;
 #define NUM_TEMP_RANGES 5
-
 	// JMS_GFX: Let's make the dark blue planet orbit dots a little
 	// more visible in 640x480 and 1280x960.
 	static const Color temp_color_array_1x[NUM_TEMP_RANGES] =
@@ -619,7 +612,7 @@ LoadSolarSys (void)
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x08, 0x00), 0x75),
 	};
 
-	old_seed = seedRandomForSolarSys ();
+	RandomContext_SeedRandom (SysGenRNG, GetRandomSeedForStar (CurStarDescPtr));
 
 	// JMS: Animating IP sun in hi-res...
 	if (RESOLUTION_FACTOR == 0)
@@ -629,7 +622,7 @@ LoadSolarSys (void)
 
 	pCurDesc = &pSolarSysState->SunDesc[0];
 	pCurDesc->pPrevDesc = 0;
-	pCurDesc->rand_seed = TFB_Random ();
+	pCurDesc->rand_seed = RandomContext_Random (SysGenRNG);
 
 	pCurDesc->data_index = STAR_TYPE (CurStarDescPtr->Type);
 	pCurDesc->location.x = 0;
@@ -662,7 +655,6 @@ LoadSolarSys (void)
 			index = (SysInfo.PlanetInfo.SurfaceTemperature + 250) / 100;
 			if (index >= NUM_TEMP_RANGES)
 				index = NUM_TEMP_RANGES - 1;
-				
 			// JMS_GFX: Let's make the dark blue planet orbit dots a little
 			// more visible in 640x480 and 1280x960.
 			if (RESOLUTION_FACTOR == 0)
@@ -721,9 +713,6 @@ LoadSolarSys (void)
 		GLOBAL (ShipStamp.frame) = SetAbsFrameIndex (SISIPFrame, i - 1);
 	}
 
-	// Restore RNG state:
-	TFB_SeedRandom (old_seed);
-
 	return orbital;
 }
 
@@ -752,125 +741,115 @@ FreeSolarSys (void)
 	COUNT i, j;
 	PLANET_DESC *pCurDesc;
 
-	if (pSolarSysState->InIpFlight)
-		{
-			pSolarSysState->InIpFlight = FALSE;
+	if (pSolarSysState->InIpFlight) {
+		pSolarSysState->InIpFlight = FALSE;
 			
-			if (!(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD)))
-				saveNonOrbitalLocation ();
-		}
+		if (!(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD)))
+			saveNonOrbitalLocation ();
+	}
 	
 	DestroyDrawable (ReleaseDrawable (SolarSysFrame));
 	SolarSysFrame = NULL;
 	
 	if (TEXTURED_PLANETS)
 	{
-	// BW: clean up data generated for textured IP planets
-	for (i = 0, pCurDesc = pSolarSysState->PlanetDesc;
-	     i < pSolarSysState->SunDesc[0].NumPlanets; ++i, ++pCurDesc)
-	{
-		PLANET_ORBIT *Orbit = &pCurDesc->orbit;
-		
-		LockMutex (GraphicsLock);
-
-		HFree (Orbit->lpTopoData);
-		Orbit->lpTopoData = 0;
-		DestroyDrawable (ReleaseDrawable (Orbit->SphereFrame));
-		Orbit->SphereFrame = NULL;
+		// BW: clean up data generated for textured IP planets
+		for (i = 0, pCurDesc = pSolarSysState->PlanetDesc;
+			 i < pSolarSysState->SunDesc[0].NumPlanets; ++i, ++pCurDesc)
+		{
+			PLANET_ORBIT *Orbit = &pCurDesc->orbit;
+			HFree (Orbit->lpTopoData);
+			Orbit->lpTopoData = 0;
+			DestroyDrawable (ReleaseDrawable (Orbit->SphereFrame));
+			Orbit->SphereFrame = NULL;
 		
-		DestroyDrawable (ReleaseDrawable (Orbit->ObjectFrame));
-		Orbit->ObjectFrame = 0;
-		DestroyDrawable (ReleaseDrawable (Orbit->WorkFrame));
-		Orbit->WorkFrame = 0;
+			DestroyDrawable (ReleaseDrawable (Orbit->ObjectFrame));
+			Orbit->ObjectFrame = 0;
+			DestroyDrawable (ReleaseDrawable (Orbit->WorkFrame));
+			Orbit->WorkFrame = 0;
 		
-		// JMS: Not sure if these do any good...
-		DestroyDrawable (ReleaseDrawable (pSolarSysState->Orbit.TintFrame));
-		pSolarSysState->Orbit.TintFrame = 0;
-		pSolarSysState->Orbit.TintColor = BLACK_COLOR;
-		DestroyDrawable (ReleaseDrawable (pSolarSysState->Orbit.TopoZoomFrame));
-		pSolarSysState->Orbit.TopoZoomFrame = 0;
-		DestroyStringTable (ReleaseStringTable (pSolarSysState->XlatRef));
-		pSolarSysState->XlatRef = 0;
-		DestroyDrawable (ReleaseDrawable (pSolarSysState->TopoFrame));
-		pSolarSysState->TopoFrame = 0;
-		DestroyColorMap (ReleaseColorMap (pSolarSysState->OrbitalCMap));
-		pSolarSysState->OrbitalCMap = 0;
-		// JMS ends.
+			// JMS: Not sure if these do any good...
+			DestroyDrawable (ReleaseDrawable (pSolarSysState->Orbit.TintFrame));
+			pSolarSysState->Orbit.TintFrame = 0;
+			pSolarSysState->Orbit.TintColor = BLACK_COLOR;
+			DestroyDrawable (ReleaseDrawable (pSolarSysState->Orbit.TopoZoomFrame));
+			pSolarSysState->Orbit.TopoZoomFrame = 0;
+			DestroyStringTable (ReleaseStringTable (pSolarSysState->XlatRef));
+			pSolarSysState->XlatRef = 0;
+			DestroyDrawable (ReleaseDrawable (pSolarSysState->TopoFrame));
+			pSolarSysState->TopoFrame = 0;
+			DestroyColorMap (ReleaseColorMap (pSolarSysState->OrbitalCMap));
+			pSolarSysState->OrbitalCMap = 0;
+			// JMS ends.
 		
-		HFree (Orbit->TopoColors);
-		Orbit->TopoColors = NULL;
-		HFree (Orbit->ScratchArray);
-		Orbit->ScratchArray = NULL;
-		if (Orbit->map_rotate && Orbit->light_diff)
-		{
-			for (j=0 ; j < GENERATE_PLANET_DIAMETER+1 ; j++)
+			HFree (Orbit->TopoColors);
+			Orbit->TopoColors = NULL;
+			HFree (Orbit->ScratchArray);
+			Orbit->ScratchArray = NULL;
+			if (Orbit->map_rotate && Orbit->light_diff)
 			{
-				HFree (Orbit->map_rotate[j]);
-				HFree (Orbit->light_diff[j]);
+				for (j=0 ; j < GENERATE_PLANET_DIAMETER+1 ; j++)
+				{
+					HFree (Orbit->map_rotate[j]);
+					HFree (Orbit->light_diff[j]);
+				}
 			}
-		}
-
-		HFree (Orbit->map_rotate);
-		Orbit->map_rotate = NULL;
-		HFree (Orbit->light_diff);
-		Orbit->light_diff = NULL;
-
-		UnlockMutex (GraphicsLock);
-	}	
+ 
+			HFree (Orbit->map_rotate);
+			Orbit->map_rotate = NULL;
+			HFree (Orbit->light_diff);
+			Orbit->light_diff = NULL;
+		}	
 
-	// BW: if we were in Inner System, clean up data for textured IP moons
-	if (playerInInnerSystem())
-	{
-		COUNT numMoons;
-		if (worldIsMoon (pSolarSysState, pSolarSysState->pOrbitalDesc))
-			numMoons = pSolarSysState->pOrbitalDesc->pPrevDesc->NumPlanets;
-		else
-			numMoons = pSolarSysState->pOrbitalDesc->NumPlanets;
-		
-		for (i = 0, pCurDesc = pSolarSysState->MoonDesc;
-		     i < numMoons; ++i, ++pCurDesc)
+		// BW: if we were in Inner System, clean up data for textured IP moons
+		if (playerInInnerSystem())
 		{
-			if (!(pCurDesc->data_index & WORLD_TYPE_SPECIAL))
+			COUNT numMoons;
+			if (worldIsMoon (pSolarSysState, pSolarSysState->pOrbitalDesc))
+				numMoons = pSolarSysState->pOrbitalDesc->pPrevDesc->NumPlanets;
+			else
+				numMoons = pSolarSysState->pOrbitalDesc->NumPlanets;
+		
+			for (i = 0, pCurDesc = pSolarSysState->MoonDesc;
+				 i < numMoons; ++i, ++pCurDesc)
 			{
-				PLANET_ORBIT *Orbit = &pCurDesc->orbit;
-			
-				LockMutex (GraphicsLock);
+				if (!(pCurDesc->data_index & WORLD_TYPE_SPECIAL))
+				{
+					PLANET_ORBIT *Orbit = &pCurDesc->orbit;
 			
-				HFree (Orbit->lpTopoData);
-				Orbit->lpTopoData = 0;
-				DestroyDrawable (ReleaseDrawable (Orbit->SphereFrame));
-				Orbit->SphereFrame = NULL;
+					HFree (Orbit->lpTopoData);
+					Orbit->lpTopoData = 0;
+					DestroyDrawable (ReleaseDrawable (Orbit->SphereFrame));
+					Orbit->SphereFrame = NULL;
 			
-				DestroyDrawable (ReleaseDrawable (Orbit->ObjectFrame));
-				Orbit->ObjectFrame = 0;
-				DestroyDrawable (ReleaseDrawable (Orbit->WorkFrame));
-				Orbit->WorkFrame = 0;
+					DestroyDrawable (ReleaseDrawable (Orbit->ObjectFrame));
+					Orbit->ObjectFrame = 0;
+					DestroyDrawable (ReleaseDrawable (Orbit->WorkFrame));
+					Orbit->WorkFrame = 0;
 			
-				HFree (Orbit->TopoColors);
-				Orbit->TopoColors = NULL;
-				HFree (Orbit->ScratchArray);
-				Orbit->ScratchArray = NULL;
-				if (Orbit->map_rotate && Orbit->light_diff)
-				{
-					for (j=0 ; j < GENERATE_MOON_DIAMETER+1 ; j++)
+					HFree (Orbit->TopoColors);
+					Orbit->TopoColors = NULL;
+					HFree (Orbit->ScratchArray);
+					Orbit->ScratchArray = NULL;
+					if (Orbit->map_rotate && Orbit->light_diff)
 					{
-						HFree (Orbit->map_rotate[j]);
-						HFree (Orbit->light_diff[j]);
+						for (j=0 ; j < GENERATE_MOON_DIAMETER+1 ; j++)
+						{
+							HFree (Orbit->map_rotate[j]);
+							HFree (Orbit->light_diff[j]);
+						}
 					}
-				}
 				
-				HFree (Orbit->map_rotate);
-				Orbit->map_rotate = NULL;
-				HFree (Orbit->light_diff);
-				Orbit->light_diff = NULL;
-
-				UnlockMutex (GraphicsLock);
+					HFree (Orbit->map_rotate);
+					Orbit->map_rotate = NULL;
+					HFree (Orbit->light_diff);
+					Orbit->light_diff = NULL;
+				}
 			}
 		}
-	}
 	// End clean up
 	}
-	
+
 	StopMusic ();
 
 //    FreeIPData ();
@@ -893,7 +872,7 @@ getCollisionFrame (PLANET_DESC *planet,
 
 // Returns the planet with which the flagship is colliding
 static PLANET_DESC *
-CheckIntersect (BOOLEAN just_checking)
+CheckIntersect (void)
 {
 	COUNT i;
 	PLANET_DESC *pCurDesc;
@@ -914,12 +893,10 @@ CheckIntersect (BOOLEAN just_checking)
 	PlanetIntersect.IntersectStamp.origin.x = SIS_SCREEN_WIDTH >> 1;
 	PlanetIntersect.IntersectStamp.origin.y = SIS_SCREEN_HEIGHT >> 1;
 	PlanetIntersect.EndPoint = PlanetIntersect.IntersectStamp.origin;
-	
+
 	PlanetIntersect.IntersectStamp.frame = getCollisionFrame (pCurDesc,
 			MAKE_WORD (PlanetOffset, MoonOffset));
 
-	//log_add (log_Debug,"Nyt: x:%d, y:%d", PlanetIntersect.IntersectStamp.origin.x, PlanetIntersect.IntersectStamp.origin.y);
-	
 	// Start with no collisions
 	NewWaitPlanet = 0;
 
@@ -967,8 +944,6 @@ CheckIntersect (BOOLEAN just_checking)
 		PlanetIntersect.IntersectStamp.frame = getCollisionFrame (pCurDesc,
 				MAKE_WORD (PlanetOffset, MoonOffset));
 
-		//log_add (log_Debug, "Ship x:%d y:%d. Planet x:%d, y:%d", ShipIntersect.IntersectStamp.origin.x, ShipIntersect.IntersectStamp.origin.y, PlanetIntersect.IntersectStamp.origin.x, PlanetIntersect.IntersectStamp.origin.y);
-		
 		if (DrawablesIntersect (&ShipIntersect,
 				&PlanetIntersect, MAX_TIME_VALUE))
 		{
@@ -988,16 +963,9 @@ CheckIntersect (BOOLEAN just_checking)
 				continue;
 			}
 			
-			if (playerInInnerSystem ())
-			{	// Collision in the inner system (starts orbital)
-				pSolarSysState->WaitIntersect = NewWaitPlanet;
-			}
-			else
-			{	// Going into an inner system
-				// So there is now no existing collision
-				if (!just_checking)
-					pSolarSysState->WaitIntersect = 0;
-			}
+			// Collision with a new planet/moon. This may cause a transition
+			// to an inner system or start an orbital view.
+			pSolarSysState->WaitIntersect = NewWaitPlanet;
 			return pCurDesc;
 		}
 	}
@@ -1042,9 +1010,8 @@ static void
 ValidateOrbit (PLANET_DESC *planet, int sizeNumer, int dyNumer, int denom)
 {
 	COUNT index;
-	
-	if (ORBITING_PLANETS)
-	{
+
+	if (ORBITING_PLANETS) {
 		// BW: recompute planet position to account for orbiting
 		// COUNT newAngle;
 		// newAngle = NORMALIZE_ANGLE(planet->angle + (COUNT)(daysElapsed() * planet->orb_speed));
@@ -1090,8 +1057,8 @@ ValidateOrbit (PLANET_DESC *planet, int
 		else if (worldIsMoon (pSolarSysState, planet))
 		{
 			Size = 2; // += 2;
-			// BW: Force moons to size 2 to avoid issues with
-			//     Triton (the one and only large rocky moon)
+			// BW:	Force moons to size 2 to avoid issues with
+			//		Triton (the one and only large rocky moon)
 		}
 		else if (denom <= (MAX_ZOOM_RADIUS >> 2))
 		{
@@ -1109,11 +1076,9 @@ ValidateOrbit (PLANET_DESC *planet, int
 			angle = ARCTAN (planet->pPrevDesc->location.x,
 					planet->pPrevDesc->location.y);
 		}
-		if (TEXTURED_PLANETS)
-		{
+		if (TEXTURED_PLANETS) {
 			// Those match the sizes of the png planets
-			switch (Size)
-			{
+			switch (Size) {
 			case 0: planet->size = 3;
 				break;
 			case 1: planet->size = 4;
@@ -1314,7 +1279,7 @@ enterInnerSystem (PLANET_DESC *planet)
 	else if (GLOBAL (ShipStamp.origin.y) >= SIS_SCREEN_HEIGHT)
 		GLOBAL (ShipStamp.origin.y) =
 				(SIS_SCREEN_HEIGHT - 1) - 1;
-	
+
 	GLOBAL (ip_location) = displayToLocation (
 			GLOBAL (ShipStamp.origin), MAX_ZOOM_RADIUS);
 	
@@ -1351,57 +1316,49 @@ leaveInnerSystem (PLANET_DESC *planet)
 
 	// Now the ship is in outer system (as per game logic)
 
-	if (TEXTURED_PLANETS)
-	{
-	// BW: clean up data generated for textured IP moons
-	for (i = 0, pMoonDesc = pSolarSysState->MoonDesc;
-	     i < planet->NumPlanets; ++i, ++pMoonDesc)
-	{
-		if (!(pMoonDesc->data_index & WORLD_TYPE_SPECIAL))
+	if (TEXTURED_PLANETS) {
+		// BW: clean up data generated for textured IP moons
+		for (i = 0, pMoonDesc = pSolarSysState->MoonDesc;
+			 i < planet->NumPlanets; ++i, ++pMoonDesc)
 		{
-			PLANET_ORBIT *Orbit = &pMoonDesc->orbit;
-		
-			LockMutex (GraphicsLock);
+			if (!(pMoonDesc->data_index & WORLD_TYPE_SPECIAL)) {
+				PLANET_ORBIT *Orbit = &pMoonDesc->orbit;
 
-			HFree (Orbit->lpTopoData);
-			Orbit->lpTopoData = 0;
-			DestroyDrawable (ReleaseDrawable (Orbit->SphereFrame));
-			Orbit->SphereFrame = NULL;
+				HFree (Orbit->lpTopoData);
+				Orbit->lpTopoData = 0;
+				DestroyDrawable (ReleaseDrawable (Orbit->SphereFrame));
+				Orbit->SphereFrame = NULL;
 		
-			DestroyDrawable (ReleaseDrawable (Orbit->ObjectFrame));
-			Orbit->ObjectFrame = 0;
-			DestroyDrawable (ReleaseDrawable (Orbit->WorkFrame));
-			Orbit->WorkFrame = 0;
+				DestroyDrawable (ReleaseDrawable (Orbit->ObjectFrame));
+				Orbit->ObjectFrame = 0;
+				DestroyDrawable (ReleaseDrawable (Orbit->WorkFrame));
+				Orbit->WorkFrame = 0;
 
-			HFree (Orbit->TopoColors);
-			Orbit->TopoColors = NULL;
-			HFree (Orbit->ScratchArray);
-			Orbit->ScratchArray = NULL;
-			if (Orbit->map_rotate && Orbit->light_diff)
-			{
-				for (j=0 ; j < GENERATE_MOON_DIAMETER+1 ; j++)
-				{
-					HFree (Orbit->map_rotate[j]);
-					HFree (Orbit->light_diff[j]);
+				HFree (Orbit->TopoColors);
+				Orbit->TopoColors = NULL;
+				HFree (Orbit->ScratchArray);
+				Orbit->ScratchArray = NULL;
+				if (Orbit->map_rotate && Orbit->light_diff) {
+					for (j=0 ; j < GENERATE_MOON_DIAMETER+1 ; j++) {
+						HFree (Orbit->map_rotate[j]);
+						HFree (Orbit->light_diff[j]);
+					}
 				}
-			}
-
-			HFree (Orbit->map_rotate);
-			Orbit->map_rotate = NULL;
-			HFree (Orbit->light_diff);
-			Orbit->light_diff = NULL;
 
-			UnlockMutex (GraphicsLock);
+				HFree (Orbit->map_rotate);
+				Orbit->map_rotate = NULL;
+				HFree (Orbit->light_diff);
+				Orbit->light_diff = NULL;
+			}
 		}
+		// End clean up
 	}
-	// End clean up
-	}
-	
+
 	pSolarSysState->WaitIntersect = outerPlanetWait;
 	// See if we also intersect with another planet, and if we do,
 	// disable collisions comletely until we stop intersecting
 	// with any planet at all.
-	CheckIntersect (TRUE);
+	CheckIntersect ();
 	if (pSolarSysState->WaitIntersect != outerPlanetWait)
 		pSolarSysState->WaitIntersect = (COUNT)~0;
 }
@@ -1456,13 +1413,10 @@ CheckShipLocation (SIZE *newRadius)
 		return TRUE;
 	}
 
-	// JMS: Added the escape counter check to prevent transitting back
-	// to planet close-up view after encounter near the planet in outer
-	// system view
 	if (GLOBAL (autopilot.x) == ~0 && GLOBAL (autopilot.y) == ~0
 		&& (ec < 60 || RESOLUTION_FACTOR == 0))
 	{	// Not on autopilot -- may collide with a planet
-		PLANET_DESC *planet = CheckIntersect (FALSE);
+		PLANET_DESC *planet = CheckIntersect ();
 		if (planet)
 		{	// Collision with a planet
 			if (playerInInnerSystem ())
@@ -1498,16 +1452,14 @@ DrawSystemTransition (BOOLEAN inner)
 static void
 TransitionSystemIn (void)
 {
-	LockMutex (GraphicsLock);
 	SetContext (SpaceContext);
 	DrawSystemTransition (playerInInnerSystem ());
-	UnlockMutex (GraphicsLock);
 }
 
 static void
 ScaleSystem (SIZE new_radius)
 {
-#ifdef SMOOTH_SYSTEM_ZOOM
+#ifdef SMOOTH_SYSTEM_ZOOM // Enabled this for shits 'n gigs.
 	// XXX: This appears to have been an attempt to zoom the system view
 	//   in a different way. This code zooms gradually instead of
 	//   doing a crossfade from one zoom level to the other.
@@ -1516,7 +1468,7 @@ ScaleSystem (SIZE new_radius)
 	//   controls are not handled in the loop, and the flagship
 	//   can collide with a group while zooming, and that is not handled
 	//   100% correctly.
-#define NUM_STEPS 10
+#define NUM_STEPS 1
 	COUNT i;
 	SIZE old_radius;
 	SIZE d, step;
@@ -1578,7 +1530,6 @@ RestoreSystemView (void)
 	DrawStamp (&s);
 }
 
-
 // JMS: This animates the truespace suns!
 #define SUN_ANIMFRAMES_NUM 32
 static void
@@ -1654,16 +1605,13 @@ DrawTexturedBody (PLANET_DESC* planet, S
 {
 	int oldScale;
 	int oldMode;
-
-	//LockMutex (GraphicsLock);
-	//SetContext (SpaceContext);
 	
 	BatchGraphics ();
 	oldMode = SetGraphicScaleMode (TFB_SCALE_BILINEAR);
 	if (worldIsMoon(pSolarSysState, planet))
-		oldScale = SetGraphicScale (GSCALE_IDENTITY * (planet->size << RESOLUTION_FACTOR) / GENERATE_MOON_DIAMETER);
+		oldScale = SetGraphicScale (GSCALE_IDENTITY * (optScalePlanets ? RES_SCALE(planet->size) : planet->size) / GENERATE_MOON_DIAMETER);
 	else
-		oldScale = SetGraphicScale (GSCALE_IDENTITY * (planet->size << RESOLUTION_FACTOR) / GENERATE_PLANET_DIAMETER);
+		oldScale = SetGraphicScale (GSCALE_IDENTITY * (optScalePlanets ? RES_SCALE(planet->size) : planet->size) / GENERATE_PLANET_DIAMETER);
 	s.frame = planet->orbit.SphereFrame;
 	DrawStamp (&s);
 	if (planet->orbit.ObjectFrame)
@@ -1675,7 +1623,6 @@ DrawTexturedBody (PLANET_DESC* planet, S
 	SetGraphicScaleMode (oldMode);
 	
 	UnbatchGraphics ();
-	//UnlockMutex (GraphicsLock);
 }
 
 static void
@@ -1688,8 +1635,7 @@ DrawInnerPlanets (PLANET_DESC *planet)
 	s.origin.x = SIS_SCREEN_WIDTH >> 1;
 	s.origin.y = SIS_SCREEN_HEIGHT >> 1;
 
-	if (TEXTURED_PLANETS)
-	{
+	if (TEXTURED_PLANETS) {
 		// Draw the planet image
 		DrawTexturedBody (planet, s);
 		
@@ -1702,9 +1648,7 @@ DrawInnerPlanets (PLANET_DESC *planet)
 			else
 				DrawTexturedBody(moon, moon->image);
 		}
-	}
-	else
-	{
+	} else {
 		// Draw the planet image
 		SetPlanetColorMap (planet);
 		s.frame = planet->image.frame;
@@ -1783,22 +1727,18 @@ void RotatePlanets (BOOLEAN IsInnerSyste
 	if (!pSolarSysState->PlanetDesc->orbit.lpTopoData)
 		return;
 	
-	if (IsInnerSystem)
-	{
+	if (IsInnerSystem) {
 		planet = pSolarSysState->pOrbitalDesc;
-		PrepareNextRotationFrameForIP (planet, frameCounter);
-		for (i = 0; i < planet->NumPlanets; ++i)
-		{
+		PrepareNextRotationFrame (planet, frameCounter, FALSE);
+		for (i = 0; i < planet->NumPlanets; ++i) {
 			moon = &pSolarSysState->MoonDesc[i];
 			if (!(moon->data_index & WORLD_TYPE_SPECIAL))
-				PrepareNextRotationFrameForIP (moon, frameCounter);
+				PrepareNextRotationFrame (moon, frameCounter, FALSE);
 		}
-	}
-	else
-	{
+	} else {
 		for (i = pSolarSysState->SunDesc[0].NumPlanets,
 			     planet = &pSolarSysState->PlanetDesc[0]; i; --i, ++planet)
-			PrepareNextRotationFrameForIP (planet, frameCounter);
+			PrepareNextRotationFrame (planet, frameCounter, FALSE);
 	}
 }
 
@@ -1809,71 +1749,57 @@ IP_frame (void)
 	BOOLEAN locChange;
 	SIZE newRadius;
 	static SIZE frameCounter;
-	
-	LockMutex (GraphicsLock);
+
 	SetContext (SpaceContext);
 
 	GameClockTick ();
 	++frameCounter;
-	//frameCounter = frameCounter % 5; // (ONE_SECOND/IP_FRAME_RATE); // % 30
 	ProcessShipControls ();
 	
 	locChange = CheckShipLocation (&newRadius);
-	if (locChange)
-	{
-		if (playerInInnerSystem ())
-		{	// Entering inner system
+	if (locChange) {
+		if (playerInInnerSystem ()) {	// Entering inner system
 			DrawSystemTransition (TRUE);
-		}
-		else if (pSolarSysState->SunDesc[0].radius == newRadius)
-		{	// Leaving inner system to outer
+		} else if (pSolarSysState->SunDesc[0].radius == newRadius) {	
+			// Leaving inner system to outer
 			DrawSystemTransition (FALSE);
-		}
-		else
-		{	// Zooming outer system
+		} else {	// Zooming outer system
 			ScaleSystem (newRadius);
 		}
-	}
-	else if (!pSolarSysState->InOrbit)
-	{	// Just flying around, minding own business..
+	} else if (!pSolarSysState->InOrbit) {
+		// Just flying around, minding own business..
 		BatchGraphics ();
 		RestoreSystemView ();
 
-		if (ORBITING_PLANETS)
-		{	// BW: recompute planet position to account for orbiting
-			if (playerInInnerSystem ())
-			{	// Draw the inner system view
+		if (ORBITING_PLANETS) {
+			// BW: recompute planet position to account for orbiting
+			if (playerInInnerSystem ()) {
+				// Draw the inner system view
 				ValidateInnerOrbits ();
-			}
-			else
-			{	// Draw the outer system view
+			} else {
+				// Draw the outer system view
 				ValidateOrbits ();
 			}
 		}
 		
-		if (ROTATING_PLANETS)
-		{
+		if (ROTATING_PLANETS) {
 		// BW: rotate planets
 		// every frame in Inner (not much CPU required)
 		// depending on planet size and speed in Outer
-			if (playerInInnerSystem ())
-			{
+			if (playerInInnerSystem ()) {
 				RotatePlanets (TRUE, frameCounter);
-			}
-			else
-			{
+			} else {
 				RotatePlanets (FALSE, frameCounter);
 			}
 		}
 
-		if (ORBITING_PLANETS || ROTATING_PLANETS)
-		{ // Planets have probably moved or changed
-			if (playerInInnerSystem ())
-			{	// Draw the inner system view
+		if (ORBITING_PLANETS || ROTATING_PLANETS) { 
+			// Planets have probably moved or changed
+			if (playerInInnerSystem ()) {	
+				// Draw the inner system view
 				DrawInnerPlanets (pSolarSysState->pOrbitalDesc);
-			}
-			else
-			{	// Draw the outer system view
+			} else {
+				// Draw the outer system view
 				DrawOuterPlanets (pSolarSysState->SunDesc[0].radius);
 			}
 		}
@@ -1881,13 +1807,12 @@ IP_frame (void)
 		// JMS: Animating IP sun in hi-res modes...
 		if (!playerInInnerSystem () && RESOLUTION_FACTOR != 0)
 			AnimateSun (newRadius);
-		
+
 		RedrawQueue (FALSE);
 		DrawAutoPilotMessage (FALSE);
 		UnbatchGraphics ();
 	}
 	
-	UnlockMutex (GraphicsLock);
 }
 
 static BOOLEAN
@@ -1974,7 +1899,7 @@ ResetSolarSys (void)
 	// where flash_task could be set at the time of call. The test was
 	// probably needed on 3DO when IP_frame() was a task.
 	assert (!pSolarSysState->InIpFlight);
-	
+
 	DrawMenuStateStrings (PM_STARMAP, -(PM_NAVIGATE - PM_SCAN));
 
 	InitDisplayList ();
@@ -1982,7 +1907,12 @@ ResetSolarSys (void)
 	DoMissions ();
 
 	// Figure out and note which planet/moon we just left, if any
-	CheckIntersect (TRUE);
+	// This records any existing collision and prevents the ship
+	// from entering planets until a new collision occurs.
+	// TODO: this may need logic similar to one in leaveInnerSystem()
+	//   for when the ship collides with more than one planet at
+	//   the same time. While quite rare, it's still possible.
+	CheckIntersect ();
 	
 	pSolarSysState->InIpFlight = TRUE;
 
@@ -2007,14 +1937,11 @@ EnterPlanetOrbit (void)
 		if (worldIsMoon (pSolarSysState, pSolarSysState->pOrbitalDesc))
 		{	
 			int moon;
-			
 			// Moon -- use its origin
 			// XXX: The conversion functions do not error-correct, so the
 			//   point we set here will change once flag_ship_preprocess()
 			//   in ipdisp.c starts over again.
-			GLOBAL (ShipStamp.origin) =
-				pSolarSysState->pOrbitalDesc->image.origin;
-				
+			GLOBAL (ShipStamp.origin) = pSolarSysState->pOrbitalDesc->image.origin;
 			// JMS_GFX: Draw the moon letter when orbiting a moon in 1280x960
 			// and 640x480 modes. Do not draw it in 320x240 since there's no room!
 			if (RESOLUTION_FACTOR > 0 && !(GetNamedPlanetaryBody()) && pSolarSysState->pOrbitalDesc->data_index != HIERARCHY_STARBASE)
@@ -2023,13 +1950,11 @@ EnterPlanetOrbit (void)
 				snprintf ((GLOBAL_SIS (PlanetName)) + strlen(GLOBAL_SIS (PlanetName)), 3, "-%c%c", 'A' + moon, '\0');
 				DrawSISTitle (GLOBAL_SIS (PlanetName));
 			}
-		}
-		else
-		{	// Planet -- its origin is for the outer view, so use mid-screen
+		} else {	
+			// Planet -- its origin is for the outer view, so use mid-screen
 			GLOBAL (ShipStamp.origin.x) = SIS_SCREEN_WIDTH >> 1;
 			GLOBAL (ShipStamp.origin.y) = SIS_SCREEN_HEIGHT >> 1;
 		}
-		//	}
 
 	GetPlanetInfo ();
 	(*pSolarSysState->genFuncs->generateOrbital) (pSolarSysState,
@@ -2065,20 +1990,15 @@ EnterPlanetOrbit (void)
 		ValidateOrbits ();
 		ValidateInnerOrbits ();
 		ResetSolarSys ();
-		if (TEXTURED_PLANETS)
-		{
-			if (worldIsMoon (pSolarSysState, pSolarSysState->pOrbitalDesc))
-			{
+		if (TEXTURED_PLANETS) {
+			if (worldIsMoon (pSolarSysState, pSolarSysState->pOrbitalDesc)) {
 				GenerateTexturedMoons(pSolarSysState, pSolarSysState->pOrbitalDesc->pPrevDesc);
-			}
-			else
-			{
+			} else {
 				GenerateTexturedMoons(pSolarSysState, pSolarSysState->pOrbitalDesc);
 			}
 		}
-		LockMutex (GraphicsLock);
+
 		RepairSISBorder ();
-		UnlockMutex (GraphicsLock);
 		TransitionSystemIn ();
 	}
 }
@@ -2090,11 +2010,9 @@ InitSolarSys (void)
 	BOOLEAN Reentry;
 	PLANET_DESC *orbital;
 
-	LockMutex (GraphicsLock);
 
 	LoadIPData ();
 	LoadLanderData ();
-	UnlockMutex (GraphicsLock);
 
 	Reentry = (GLOBAL (ShipFacing) != 0);
 	if (!Reentry)
@@ -2109,7 +2027,6 @@ InitSolarSys (void)
 				MAX_ZOOM_RADIUS);
 	}
 
-	LockMutex (GraphicsLock);
 
 	StarsFrame = CreateStarBackGround ();
 	
@@ -2117,7 +2034,6 @@ InitSolarSys (void)
 	SetContextFGFrame (Screen);
 	SetContextBackGroundColor (BLACK_COLOR);
 	
-	UnlockMutex (GraphicsLock);
 
 	orbital = LoadSolarSys ();
 	InnerSystem = CheckZoomLevel ();
@@ -2145,7 +2061,6 @@ InitSolarSys (void)
 	}
 	else
 	{	// Draw the borders, the system (inner or outer) and fade/transition
-		LockMutex (GraphicsLock);
 		SetContext (SpaceContext);
 
 		SetTransitionSource (NULL);
@@ -2177,13 +2092,11 @@ InitSolarSys (void)
 		}
 		else
 		{	// Entered a new system, or loaded into inner or outer
-			if (InnerSystem)
-			{
-				if (TEXTURED_PLANETS)
-				{
+			if (InnerSystem) {
+				if (TEXTURED_PLANETS) {
 					GenerateTexturedMoons(pSolarSysState, pSolarSysState->pOrbitalDesc);
 				}
-				DrawInnerSystem ();
+ 				DrawInnerSystem ();
 			}
 			else
 				DrawOuterSystem ();
@@ -2192,9 +2105,8 @@ InitSolarSys (void)
 			UnbatchGraphics ();
 
 			LastActivity &= ~CHECK_LOAD;
-		}				
+		}
 		IP_frame(); // MB: To fix planet texture and sun corona 'pop-in'
-		UnlockMutex (GraphicsLock);
 	}
 }
 
@@ -2248,7 +2160,8 @@ static void
 UninitSolarSys (void)
 {
 	FreeSolarSys ();
-	//FreeLanderData (); // JMS: This is not needed since the landerframes won't reload if they're already loaded once.
+
+	// FreeLanderData (); // JMS: This is not needed since the landerframes won't reload if they're already loaded once.
 	FreeIPData (); // JMS This IS necessary.
 
 	DestroyDrawable (ReleaseDrawable (StarsFrame));
@@ -2285,13 +2198,12 @@ DrawSystem (SIZE radius, BOOLEAN IsInner
 	CONTEXT oldContext;
 	STAMP s;
 
-	if (TEXTURED_PLANETS)
-	{
+	if (TEXTURED_PLANETS) {
 		// BW: This to test if we have already rendered 
 		if (!pSolarSysState->PlanetDesc->orbit.lpTopoData)
 			GenerateTexturedPlanets();
 	}
-	
+
 	if (!SolarSysFrame)
 	{	// Create the saved view graphic
 		RECT clipRect;
@@ -2313,7 +2225,7 @@ DrawSystem (SIZE radius, BOOLEAN IsInner
 		pCurDesc = pSolarSysState->pOrbitalDesc;
 		DrawOrbit (pCurDesc, DISPLAY_FACTOR * 4, DISPLAY_FACTOR, radius);
 	}
-	
+
 	// Draw the planet orbits or moon orbits
 	for (i = pBaseDesc->pPrevDesc->NumPlanets, pCurDesc = pBaseDesc;
 			i; --i, ++pCurDesc)
@@ -2325,14 +2237,12 @@ DrawSystem (SIZE radius, BOOLEAN IsInner
 					radius);
 	}
 
-	if (!ORBITING_PLANETS && !ROTATING_PLANETS)
-	{
-		if (IsInnerSystem)
-		{	// Draw the inner system view
+	if (!ORBITING_PLANETS && !ROTATING_PLANETS) {
+		if (IsInnerSystem) {	
+			// Draw the inner system view
 			DrawInnerPlanets (pSolarSysState->pOrbitalDesc);
-		}
-		else
-		{	// Draw the outer system view
+		} else {	
+			// Draw the outer system view
 			DrawOuterPlanets (radius);
 		}
 	}
@@ -2362,15 +2272,16 @@ static FRAME
 CreateStarBackGround (void)
 {
 	COUNT i, j;
-	COUNT num_brt_drawn;
 	DWORD rand_val;
 	STAMP s, nebula; // JMS (added that nebula there)
-	DWORD old_seed;
 	CONTEXT oldContext;
 	RECT clipRect;
 	FRAME frame;
-	BYTE num_nebulae = 17;
-	
+	BYTE numNebulae = 44;
+	COUNT NebulaePercentX = CurStarDescPtr->star_pt.x % numNebulae;
+	COUNT NebulaePercentY = CurStarDescPtr->star_pt.y % (numNebulae + 6);
+
+	// Use SpaceContext to find out the dimensions of the background
 	oldContext = SetContext (SpaceContext);
 	GetContextClipRect (&clipRect);
 
@@ -2384,13 +2295,8 @@ CreateStarBackGround (void)
 
 	ClearDrawable ();
 
-	old_seed = seedRandomForSolarSys ();
+	RandomContext_SeedRandom (SysGenRNG, GetRandomSeedForStar (CurStarDescPtr));
 
-	// JMS, BW: The beautiful nebula background.
-	if(rmxGraphicsPresent){ // Less ugly content checks
-		num_nebulae = 22; // MB: correction to number of nebulae
-	}
-	
 #define NUM_DIM_PIECES 8
 	s.frame = SpaceJunkFrame;
 	for (i = 0; i < NUM_DIM_PIECES; ++i)
@@ -2398,7 +2304,7 @@ CreateStarBackGround (void)
 #define NUM_DIM_DRAWN 5
 		for (j = 0; j < NUM_DIM_DRAWN; ++j)
 		{
-			rand_val = TFB_Random ();
+			rand_val = RandomContext_Random (SysGenRNG);
 			s.origin.x = LOWORD (rand_val) % SIS_SCREEN_WIDTH;
 			s.origin.y = HIWORD (rand_val) % SIS_SCREEN_HEIGHT;
 
@@ -2406,20 +2312,13 @@ CreateStarBackGround (void)
 		}
 		s.frame = IncFrameIndex (s.frame);
 	}
-	
-	// JMS
-	if (optNebulae && (CurStarDescPtr->star_pt.y % (num_nebulae + 4)) < num_nebulae) { // MB: Make some system not have nebulae
-		num_brt_drawn = RES_CASE(30, 98, 230); // JMS_GFX - Altered MB
-	} else {
-		num_brt_drawn = RES_CASE(30, 121, 312); // JMS_GFX - Altered MB
-	}
-		
 #define NUM_BRT_PIECES 8
 	for (i = 0; i < NUM_BRT_PIECES; ++i)
 	{
-		for (j = 0; j < num_brt_drawn; ++j)
+#define NUM_BRT_DRAWN (optNebulae && NebulaePercentY < numNebulae ? RES_CASE(30, 90, 270) : RES_CASE(30, 120, 480))
+		for (j = 0; j < NUM_BRT_DRAWN; ++j)
 		{
-			rand_val = TFB_Random ();
+			rand_val = RandomContext_Random (SysGenRNG);
 			s.origin.x = LOWORD (rand_val) % SIS_SCREEN_WIDTH;
 			s.origin.y = HIWORD (rand_val) % SIS_SCREEN_HEIGHT;
 
@@ -2427,15 +2326,17 @@ CreateStarBackGround (void)
 		}
 		s.frame = IncFrameIndex (s.frame);
 	}
-
-	if (optNebulae && (CurStarDescPtr->star_pt.y % (num_nebulae + 4)) < num_nebulae){ // MB: Make some solar systems not have nebulae
+	
+	if (optNebulae && NebulaePercentY < numNebulae){ // MB: Make some solar systems not have nebulae
 		nebula.origin.x = nebula.origin.y = 0;
-		nebula.frame = SetAbsFrameIndex (NebulaeFrame, CurStarDescPtr->star_pt.x % num_nebulae);
+		nebula.frame = SetAbsFrameIndex (NebulaeFrame, NebulaePercentX);
 		DrawStamp(&nebula);
+#ifdef DEBUG
+		// Prints out the frame number of the current system's nebula
+		printf("Nebula Frame: %d\n", NebulaePercentX);
+#endif	
 	}
 
-	TFB_SeedRandom (old_seed);
-
 	SetContext (oldContext);
 
 	return frame;
@@ -2594,18 +2495,15 @@ GetPlanetOrMoonName (UNICODE *buf, COUNT
 	bufsize -= i;
 	moon = moonIndex (pSolarSysState, pSolarSysState->pOrbitalDesc);
 	
-	
-log_add (log_Debug,"last %02d, i %d", tempbuf[i-1], i);	
+	log_add (log_Debug,"last %02d, i %d", tempbuf[i-1], i);	
 	// JMS: Prevent printing something like 'planet II-A-A' in summary screen.
-	if (i > 0)
-	{
+	if (i > 0) {
 		if(tempbuf[i-1] == 'A' || tempbuf[i-1] == 'B' 
 			|| tempbuf[i-1] == 'C' || tempbuf[i-1] == 'D')
 			name_has_suffix = TRUE;
 	}
 	
-	if (bufsize >= 3 && !name_has_suffix)
-	{
+	if (bufsize >= 3 && !name_has_suffix) {
 		snprintf (buf, bufsize, "-%c", 'A' + moon);
 		buf[bufsize - 1] = '\0';
 	}
@@ -2670,9 +2568,7 @@ DoSolarSysMenu (MENU_STATE *pMS)
 	if (!select)
 		return TRUE;
 
-	LockMutex (GraphicsLock);
 	SetFlashRect (NULL);
-	UnlockMutex (GraphicsLock);
 
 	switch (pMS->CurState)
 	{
@@ -2713,9 +2609,7 @@ DoSolarSysMenu (MENU_STATE *pMS)
 				pMS->CurState = NAVIGATION;
 			DrawMenuStateStrings (PM_STARMAP, pMS->CurState);
 		}
-		LockMutex (GraphicsLock);
 		SetFlashRect (SFR_MENU_3DO);
-		UnlockMutex (GraphicsLock);
 	}
 
 	return TRUE;
@@ -2738,10 +2632,8 @@ SolarSysMenu (void)
 		MenuState.CurState = STARMAP;
 	}
 
-	LockMutex (GraphicsLock);
 	DrawStatusMessage (NULL);
 	SetFlashRect (SFR_MENU_3DO);
-	UnlockMutex (GraphicsLock);
 
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
 	MenuState.InputFunc = DoSolarSysMenu;
diff -ruNp src.hd/uqm/planets/solarsys.h src/uqm/planets/solarsys.h
--- src.hd/uqm/planets/solarsys.h	1969-12-31 16:00:00 -0800
+++ src/uqm/planets/solarsys.h	2017-12-29 00:57:49 -0800
@@ -0,0 +1,34 @@
+//Copyright (C) 2011, Scott A. Colcord
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef SOLARSYS_H
+#define SOLARSYS_H
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+extern void LoadIPData (void);
+extern void FreeIPData (void);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif /* SOLARSYS_H */
+
diff -ruNp src.hd/uqm/planets/sundata.h src/uqm/planets/sundata.h
--- src.hd/uqm/planets/sundata.h	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/sundata.h	2017-12-29 00:57:50 -0800
@@ -22,6 +22,9 @@
 #include "plandata.h"
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
 /*------------------------------ Global Data ------------------------------ */
 
@@ -39,13 +42,19 @@ typedef struct
 
 	PLANET_INFO PlanetInfo;
 } SYSTEM_INFO;
+
+#define GENERATE_ALL  ((COUNT)~0)
 		
-extern DWORD GenerateMineralDeposits (SYSTEM_INFO *SysInfoPtr,
-		COUNT *pwhich_deposit);
-extern DWORD GenerateLifeForms (SYSTEM_INFO *SysInfoPtr, COUNT *pwhich_life);
-extern void GenerateRandomLocation (SYSTEM_INFO *);
-extern DWORD GenerateRandomNodes (SYSTEM_INFO *, COUNT scan, COUNT numNodes,
-		COUNT type, COUNT *whichNode);
+extern COUNT GenerateMineralDeposits (const SYSTEM_INFO *, COUNT whichDeposit,
+		NODE_INFO *info);
+extern COUNT GenerateLifeForms (const SYSTEM_INFO *, COUNT whichLife,
+		NODE_INFO *info);
+extern void GenerateRandomLocation (POINT *loc);
+extern COUNT GenerateRandomNodes (const SYSTEM_INFO *, COUNT scan, COUNT numNodes,
+		COUNT type, COUNT whichNode, NODE_INFO *info);
+// Generate lifeforms from a preset lifeTypes[] array
+extern COUNT GeneratePresetLife (const SYSTEM_INFO *,
+		const SBYTE *lifeTypes, COUNT whichLife, NODE_INFO *info);
 
 #define DWARF_ELEMENT_DENSITY  1
 #define GIANT_ELEMENT_DENSITY 3
@@ -53,10 +62,12 @@ extern DWORD GenerateRandomNodes (SYSTEM
 
 #define MAX_ELEMENT_DENSITY ((MAX_ELEMENT_UNITS * SUPERGIANT_ELEMENT_DENSITY) << 1)
 
-extern DWORD DoPlanetaryAnalysis (SYSTEM_INFO *SysInfoPtr,
+extern void DoPlanetaryAnalysis (SYSTEM_INFO *SysInfoPtr,
 		PLANET_DESC *pPlanetDesc);
 
-extern SYSTEM_INFO CurSysInfo;
+#if defined(__cplusplus)
+}
+#endif
 
 #endif /* _SUNDATA_H */
 
diff -ruNp src.hd/uqm/planets/surface.c src/uqm/planets/surface.c
--- src.hd/uqm/planets/surface.c	2017-12-29 02:25:53 -0800
+++ src/uqm/planets/surface.c	2017-12-29 00:57:50 -0800
@@ -28,7 +28,8 @@ const BYTE *Elements;
 const PlanetFrame *PlanData;
 
 static COUNT
-CalcMineralDeposits (SYSTEM_INFO *SysInfoPtr, COUNT which_deposit)
+CalcMineralDeposits (const SYSTEM_INFO *SysInfoPtr, COUNT which_deposit,
+		NODE_INFO *info)
 {
 	BYTE j;
 	COUNT num_deposits;
@@ -41,24 +42,24 @@ CalcMineralDeposits (SYSTEM_INFO *SysInf
 	{
 		BYTE num_possible;
 
-		num_possible = (BYTE)((BYTE)TFB_Random ()
-				% (DEPOSIT_QUANTITY (eptr->Density) + 1));
+		num_possible = LOBYTE (RandomContext_Random (SysGenRNG))
+				% (DEPOSIT_QUANTITY (eptr->Density) + 1);
 		while (num_possible--)
 		{
 #define MEDIUM_DEPOSIT_THRESHOLD 150
 #define LARGE_DEPOSIT_THRESHOLD 220
-			COUNT deposit_quality_fine,
-						deposit_quality_gross;
-			
+			COUNT deposit_quality_fine;
+			COUNT deposit_quality_gross;
+
 			// JMS: For making the mineral blip smaller in case it is partially scavenged.
 			SDWORD temp_deposit_quality;
 
-			deposit_quality_fine = ((COUNT)TFB_Random () % 100)
+			deposit_quality_fine = (LOWORD (RandomContext_Random (SysGenRNG)) % 100)
 					+ (
 					DEPOSIT_QUALITY (eptr->Density)
 					+ SysInfoPtr->StarSize
 					) * 50;
-			
+
 			// JMS: This makes the mineral blip smaller in case it is partially scavenged.
 			if (which_deposit < 32)
 				temp_deposit_quality = deposit_quality_fine - ((SysInfoPtr->PlanetInfo.PartiallyScavengedList[MINERAL_SCAN][which_deposit]) * 10);
@@ -80,240 +81,211 @@ CalcMineralDeposits (SYSTEM_INFO *SysInf
 			else
 				deposit_quality_gross = 2;
 
-			GenerateRandomLocation (SysInfoPtr);
+			GenerateRandomLocation (&info->loc_pt);
 
-			SysInfoPtr->PlanetInfo.CurDensity =
-					MAKE_WORD (
-					deposit_quality_gross, deposit_quality_fine / 10 + 1
-					);
-			SysInfoPtr->PlanetInfo.CurType = eptr->ElementType;
+			info->density = MAKE_WORD (
+					deposit_quality_gross, deposit_quality_fine / 10 + 1);
+			info->type = eptr->ElementType;
 #ifdef DEBUG_SURFACE
 			log_add (log_Debug, "\t\t%d units of %Fs",
-					SysInfoPtr->PlanetInfo.CurDensity,
+					info->density,
 					Elements[eptr->ElementType].name);
 #endif /* DEBUG_SURFACE */
 			if (num_deposits >= which_deposit
 					|| ++num_deposits == sizeof (DWORD) * 8)
-				goto ExitCalcMinerals;
+			{	// reached the maximum or the requested node
+				return num_deposits;
+			}
 		}
 		++eptr;
 	} while (--j);
 
-ExitCalcMinerals:
-	return (num_deposits);
+	return num_deposits;
 }
 
-DWORD
-GenerateMineralDeposits (SYSTEM_INFO *SysInfoPtr, COUNT *pwhich_deposit)
+// Returns:
+//   for whichLife==~0 : the number of nodes generated
+//   for whichLife<32  : the index of the last node (no known usage exists)
+// Sets the SysGenRNG to the required state first.
+COUNT
+GenerateMineralDeposits (const SYSTEM_INFO *SysInfoPtr, COUNT whichDeposit,
+		NODE_INFO *info)
 {
-	DWORD old_rand;
-
-	old_rand = TFB_SeedRandom (SysInfoPtr->PlanetInfo.ScanSeed[MINERAL_SCAN]);
-	*pwhich_deposit = CalcMineralDeposits (SysInfoPtr, *pwhich_deposit);
-	return (TFB_SeedRandom (old_rand));
+	NODE_INFO temp_info;
+	if (!info) // user not interested in info but we need space for it
+		info = &temp_info;
+	RandomContext_SeedRandom (SysGenRNG,
+			SysInfoPtr->PlanetInfo.ScanSeed[MINERAL_SCAN]);
+	return CalcMineralDeposits (SysInfoPtr, whichDeposit, info);
 }
 
 static COUNT
-CalcLifeForms (SYSTEM_INFO *SysInfoPtr, COUNT which_life)
+CalcLifeForms (const SYSTEM_INFO *SysInfoPtr, COUNT which_life,
+		NODE_INFO *info)
 {
 	COUNT num_life_forms;
 
 	num_life_forms = 0;
-	if (PLANSIZE (SysInfoPtr->PlanetInfo.PlanDataPtr->Type) == GAS_GIANT)
-		SysInfoPtr->PlanetInfo.LifeChance = -1;
-	else
+	if (PLANSIZE (SysInfoPtr->PlanetInfo.PlanDataPtr->Type) != GAS_GIANT)
 	{
 #define MIN_LIFE_CHANCE 10
 		SIZE life_var;
 
-		life_var = 0;
-
-		if (SysInfoPtr->PlanetInfo.SurfaceTemperature < -151)
-			life_var -= 300;
-		else if (SysInfoPtr->PlanetInfo.SurfaceTemperature < -51)
-			life_var -= 100;
-		else if (SysInfoPtr->PlanetInfo.SurfaceTemperature < 0)
-			life_var += 100;
-		else if (SysInfoPtr->PlanetInfo.SurfaceTemperature < 50)
-			life_var += 300;
-		else if (SysInfoPtr->PlanetInfo.SurfaceTemperature < 150)
-			life_var += 50;
-		else if (SysInfoPtr->PlanetInfo.SurfaceTemperature < 250)
-			life_var -= 100;
-		else if (SysInfoPtr->PlanetInfo.SurfaceTemperature < 500)
-			life_var -= 400;
-		else
-			life_var -= 800;
-
-		if (SysInfoPtr->PlanetInfo.AtmoDensity == 0)
-			life_var -= 1000;
-		else if (SysInfoPtr->PlanetInfo.AtmoDensity < 15)
-			life_var += 100;
-		else if (SysInfoPtr->PlanetInfo.AtmoDensity < 30)
-			life_var += 200;
-		else if (SysInfoPtr->PlanetInfo.AtmoDensity < 100)
-			life_var += 300;
-		else if (SysInfoPtr->PlanetInfo.AtmoDensity < 1000)
-			life_var += 150;
-		else if (SysInfoPtr->PlanetInfo.AtmoDensity < 2500)
-			;
-		else
-			life_var -= 100;
-
-#ifndef NOTYET
-		life_var += 200 + 80 + 80;
-#else /* NOTYET */
-		if (SysInfoPtr->PlanetInfo.SurfaceGravity < 10)
-			;
-		else if (SysInfoPtr->PlanetInfo.SurfaceGravity < 35)
-			life_var += 50;
-		else if (SysInfoPtr->PlanetInfo.SurfaceGravity < 75)
-			life_var += 100;
-		else if (SysInfoPtr->PlanetInfo.SurfaceGravity < 150)
-			life_var += 200;
-		else if (SysInfoPtr->PlanetInfo.SurfaceGravity < 400)
-			life_var += 50;
-		else if (SysInfoPtr->PlanetInfo.SurfaceGravity < 800)
-			;
-		else
-			life_var -= 100;
-
-		if (SysInfoPtr->PlanetInfo.Tectonics < 1)
-			life_var += 80;
-		else if (SysInfoPtr->PlanetInfo.Tectonics < 2)
-			life_var += 70;
-		else if (SysInfoPtr->PlanetInfo.Tectonics < 3)
-			life_var += 60;
-		else if (SysInfoPtr->PlanetInfo.Tectonics < 4)
-			life_var += 50;
-		else if (SysInfoPtr->PlanetInfo.Tectonics < 5)
-			life_var += 25;
-		else if (SysInfoPtr->PlanetInfo.Tectonics < 6)
-			;
-		else
-			life_var -= 100;
-
-		if (SysInfoPtr->PlanetInfo.Weather < 1)
-			life_var += 80;
-		else if (SysInfoPtr->PlanetInfo.Weather < 2)
-			life_var += 70;
-		else if (SysInfoPtr->PlanetInfo.Weather < 3)
-			life_var += 60;
-		else if (SysInfoPtr->PlanetInfo.Weather < 4)
-			life_var += 50;
-		else if (SysInfoPtr->PlanetInfo.Weather < 5)
-			life_var += 25;
-		else if (SysInfoPtr->PlanetInfo.Weather < 6)
-			;
-		else
-			life_var -= 100;
-#endif /* NOTYET */
-
-		SysInfoPtr->PlanetInfo.LifeChance = life_var;
-
-		life_var = (COUNT)TFB_Random () & 1023;
+		life_var = RandomContext_Random (SysGenRNG) & 1023;
 		if (life_var < SysInfoPtr->PlanetInfo.LifeChance
 				|| (SysInfoPtr->PlanetInfo.LifeChance < MIN_LIFE_CHANCE
 				&& life_var < MIN_LIFE_CHANCE))
 		{
 			BYTE num_types;
 
-			num_types = (BYTE)(((BYTE)TFB_Random () % MAX_LIFE_VARIATION) + 1);
+			num_types = 1 + LOBYTE (RandomContext_Random (SysGenRNG))
+					% MAX_LIFE_VARIATION;
 			do
 			{
 				BYTE index, num_creatures;
-				DWORD rand_val; // JMS_GFX: Was UWORD
-				
-				rand_val = (UWORD)TFB_Random ();
-				index = LOBYTE ((UWORD)rand_val) % NUM_CREATURE_TYPES; // JMS_GFX
-				num_creatures = (BYTE)((HIBYTE ((UWORD)rand_val) % 10) + 1); // JMS_GFX
+				UWORD rand_val;
+
+				rand_val = RandomContext_Random (SysGenRNG);
+				index = LOBYTE (rand_val) % NUM_CREATURE_TYPES;
+				num_creatures = 1 + HIBYTE (rand_val) % 10;
 				do
 				{
-					GenerateRandomLocation (SysInfoPtr);
-					
-					
-					SysInfoPtr->PlanetInfo.CurType = index;
+					GenerateRandomLocation (&info->loc_pt);
+					info->type = index;
+					info->density = 0;
 
 					if (num_life_forms >= which_life
 							|| ++num_life_forms == sizeof (DWORD) * 8)
-					{
-						num_types = 1;
-						break;
+					{	// reached the maximum or the requested node
+						return num_life_forms;
 					}
 				} while (--num_creatures);
 			} while (--num_types);
 		}
 #ifdef DEBUG_SURFACE
 		else
+		{
 			log_add (log_Debug, "It's dead, Jim! (%d >= %d)", life_var,
 				SysInfoPtr->PlanetInfo.LifeChance);
+		}
 #endif /* DEBUG_SURFACE */
 	}
 
-	return (num_life_forms);
+	return num_life_forms;
+}
+
+// Returns:
+//   for whichLife==~0 : the number of lifeforms generated
+//   for whichLife<32  : the index of the last lifeform (no known usage exists)
+// Sets the SysGenRNG to the required state first.
+COUNT
+GenerateLifeForms (const SYSTEM_INFO *SysInfoPtr, COUNT whichLife,
+		NODE_INFO *info)
+{
+	NODE_INFO temp_info;
+	if (!info) // user not interested in info but we need space for it
+		info = &temp_info;
+	RandomContext_SeedRandom (SysGenRNG,
+			SysInfoPtr->PlanetInfo.ScanSeed[BIOLOGICAL_SCAN]);
+	return CalcLifeForms (SysInfoPtr, whichLife, info);
 }
 
-DWORD
-GenerateLifeForms (SYSTEM_INFO *SysInfoPtr, COUNT *pwhich_life)
+// Returns:
+//   for whichLife==~0 : the number of lifeforms generated
+//   for whichLife<32  : the index of the last lifeform (no known usage exists)
+// Sets the SysGenRNG to the required state first.
+// lifeTypes[] is terminated with -1
+COUNT
+GeneratePresetLife (const SYSTEM_INFO *SysInfoPtr, const SBYTE *lifeTypes,
+		COUNT whichLife, NODE_INFO *info)
 {
-	DWORD old_rand;
+	COUNT i;
+	NODE_INFO temp_info;
+
+	if (!info) // user not interested in info but we need space for it
+		info = &temp_info;
+
+	// This function may look unnecessarily complicated, but it must be
+	// kept this way to preserve the universe. That is done by preserving
+	// the order and number of Random() calls.
 
-	old_rand = TFB_SeedRandom (
+	RandomContext_SeedRandom (SysGenRNG,
 			SysInfoPtr->PlanetInfo.ScanSeed[BIOLOGICAL_SCAN]);
-	*pwhich_life = CalcLifeForms (SysInfoPtr, *pwhich_life);
-	return (TFB_SeedRandom (old_rand));
+
+	for (i = 0; lifeTypes[i] >= 0; ++i)
+	{
+		GenerateRandomLocation (&info->loc_pt);
+		info->type = lifeTypes[i];
+		// density is irrelevant for bio nodes
+		info->density = 0;
+
+		if (i >= whichLife)
+			break;
+	}
+	
+	return i;
 }
 
 void
-GenerateRandomLocation (SYSTEM_INFO *SysInfoPtr)
+GenerateRandomLocation (POINT *loc)
 {
-	UWORD rand_val = (UWORD)TFB_Random ();
+	UWORD rand_val;
 	UWORD x, y; // JMS_GFX: Helpers.
-	
+
+	rand_val = RandomContext_Random (SysGenRNG);
+	// loc->x = 8 + LOBYTE (rand_val) % (MAP_WIDTH - (8 << 1));
+	// loc->y = 8 + HIBYTE (rand_val) % (MAP_HEIGHT - (8 << 1));
+
 	x = (LOBYTE (rand_val) % (ORIGINAL_MAP_WIDTH - (8 << 1)));
 	y = (HIBYTE (rand_val) % (ORIGINAL_MAP_HEIGHT - (8 << 1)));
 	
 	// JMS_GFX
 	x <<= RESOLUTION_FACTOR;
 	y <<= RESOLUTION_FACTOR;
-	SysInfoPtr->PlanetInfo.CurPt.x = x;
-	SysInfoPtr->PlanetInfo.CurPt.y = y;
+	loc->x = x;
+	loc->y = y;
 	
-	SysInfoPtr->PlanetInfo.CurPt.x += 8 << RESOLUTION_FACTOR; // JMS_GFX
-	SysInfoPtr->PlanetInfo.CurPt.y += 8 << RESOLUTION_FACTOR; // JMS_GFX
+	loc->x += 8 << RESOLUTION_FACTOR; // JMS_GFX
+	loc->y += 8 << RESOLUTION_FACTOR; // JMS_GFX
 	
 	// JMS_GFX: Compensate for 1280x960's different aspect ratio
 	if (RESOLUTION_FACTOR == 2)
 	{
-		DWORD xx = (DWORD)SysInfoPtr->PlanetInfo.CurPt.x;
+		DWORD xx = (DWORD)loc->x;
 		xx *= 111;
 		xx /= 100;
-		SysInfoPtr->PlanetInfo.CurPt.x = (COUNT)xx;
+		loc->x = (COUNT)xx;
 	}
 }
 
-DWORD
-GenerateRandomNodes (SYSTEM_INFO *SysInfoPtr, COUNT scan, COUNT numNodes,
-		COUNT type, COUNT *whichNode)
+// Returns:
+//   for whichNode==~0 : the number of nodes generated
+//   for whichNode<32  : the index of the last node (no known usage exists)
+// Sets the SysGenRNG to the required state first.
+COUNT
+GenerateRandomNodes (const SYSTEM_INFO *SysInfoPtr, COUNT scan, COUNT numNodes,
+		COUNT type, COUNT whichNode, NODE_INFO *info)
 {
-	DWORD old_rand;
 	COUNT i;
+	NODE_INFO temp_info;
 
-	old_rand = TFB_SeedRandom (SysInfoPtr->PlanetInfo.ScanSeed[scan]);
+	if (!info) // user not interested in info but we need space for it
+		info = &temp_info;
+
+	RandomContext_SeedRandom (SysGenRNG,
+			SysInfoPtr->PlanetInfo.ScanSeed[scan]);
 
 	for (i = 0; i < numNodes; ++i)
 	{
-		GenerateRandomLocation (SysInfoPtr);
-		// CurType is irrelevant for energy nodes
-		SysInfoPtr->PlanetInfo.CurType = type;
-		// CurDensity is irrelevant for energy and bio nodes
-		SysInfoPtr->PlanetInfo.CurDensity = 0;
+		GenerateRandomLocation (&info->loc_pt);
+		// type is irrelevant for energy nodes
+		info->type = type;
+		// density is irrelevant for energy and bio nodes
+		info->density = 0;
 
-		if (i >= *whichNode)
+		if (i >= whichNode)
 			break;
 	}
 	
-	*whichNode = i; // only matters when count is requested
-
-	return (TFB_SeedRandom (old_rand));
+	return i;
 }
diff -ruNp src.hd/uqm/process.c src/uqm/process.c
--- src.hd/uqm/process.c	2017-12-29 02:25:53 -0800
+++ src/uqm/process.c	2017-12-29 00:57:50 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "process.h"
 
 #include "races.h"
@@ -41,7 +39,7 @@
 
 COUNT DisplayFreeList;
 PRIMITIVE DisplayArray[MAX_DISPLAY_PRIMS];
-extern DPOINT SpaceOrg; // JMS: Changed to DPOINT from POINT
+extern DPOINT SpaceOrg;
 
 COUNT zoom_out = 1 << ZOOM_SHIFT;
 static SIZE opt_max_zoom_out;
@@ -205,93 +203,90 @@ PostProcess (ELEMENT *ElementPtr)
 			| POST_PROCESS;
 }
 
-// JMS: Changed a shitload of POINTs to DPOINTs and SIZEs to SDWORDs to
-// avoid overflows in hi-res.
 static COUNT
 CalcReduction (SDWORD dx, SDWORD dy)
 {
 	COUNT next_reduction;
-	
+
 #ifdef KDEBUG
 	log_add (log_Debug, "CalcReduction:");
 #endif
-	
+
 	if (optMeleeScale == TFB_SCALE_STEP)
 	{
 		SDWORD sdx, sdy;
-		
+
 		if (LOBYTE (GLOBAL (CurrentActivity)) > IN_ENCOUNTER)
 			return (0);
-		
+
 		sdx = dx;
 		sdy = dy;
 		for (next_reduction = MAX_VIS_REDUCTION;
-			 (dx <<= REDUCTION_SHIFT) <= TRANSITION_WIDTH
-			 && (dy <<= REDUCTION_SHIFT) <= TRANSITION_HEIGHT
-			 && next_reduction > 0;
-			 next_reduction -= REDUCTION_SHIFT)
+				(dx <<= REDUCTION_SHIFT) <= TRANSITION_WIDTH
+				&& (dy <<= REDUCTION_SHIFT) <= TRANSITION_HEIGHT
+				&& next_reduction > 0;
+				next_reduction -= REDUCTION_SHIFT)
 			;
-		
-		/* check for "real" zoom in */
+
+				/* check for "real" zoom in */
 		if (next_reduction < zoom_out
-			&& zoom_out <= MAX_VIS_REDUCTION)
+				&& zoom_out <= MAX_VIS_REDUCTION)
 		{
 #define HYSTERESIS_X DISPLAY_TO_WORLD(24 << RESOLUTION_FACTOR) // JMS_GFX
 #define HYSTERESIS_Y DISPLAY_TO_WORLD(20 << RESOLUTION_FACTOR) // JMS_GFX
-			if (((sdx + HYSTERESIS_X)
-				 << (MAX_VIS_REDUCTION - next_reduction)) > TRANSITION_WIDTH
+		if (((sdx + HYSTERESIS_X)
+				<< (MAX_VIS_REDUCTION - next_reduction)) > TRANSITION_WIDTH
 				|| ((sdy + HYSTERESIS_Y)
-					<< (MAX_VIS_REDUCTION - next_reduction)) > TRANSITION_HEIGHT)
-			/* if we don't zoom in, we want to stay at next+1 */
-				next_reduction += REDUCTION_SHIFT;
+				<< (MAX_VIS_REDUCTION - next_reduction)) > TRANSITION_HEIGHT)
+		   /* if we don't zoom in, we want to stay at next+1 */
+		   next_reduction += REDUCTION_SHIFT;
 		}
-		
-		if (next_reduction == 0 && LOBYTE (GLOBAL (CurrentActivity)) == IN_LAST_BATTLE)
+
+		if (next_reduction == 0
+				&& LOBYTE (GLOBAL (CurrentActivity)) == IN_LAST_BATTLE)
 			next_reduction += REDUCTION_SHIFT;
 	}
 	else
 	{
 		if (LOBYTE (GLOBAL (CurrentActivity)) > IN_ENCOUNTER)
 			return (1 << ZOOM_SHIFT);
-		
+			
 		dx = (dx * MAX_ZOOM_OUT) / (LOG_SPACE_WIDTH >> 2);
 		if (dx < (1 << ZOOM_SHIFT))
 			dx = 1 << ZOOM_SHIFT;
 		else if (dx > MAX_ZOOM_OUT)
 			dx = MAX_ZOOM_OUT;
-		
+			
 		dy = (dy * MAX_ZOOM_OUT) / (LOG_SPACE_HEIGHT >> 2);
 		if (dy < (1 << ZOOM_SHIFT))
 			dy = 1 << ZOOM_SHIFT;
 		else if (dy > MAX_ZOOM_OUT)
 			dy = MAX_ZOOM_OUT;
-		
+			
 		if (dy > dx)
 			next_reduction = dy;
 		else
 			next_reduction = dx;
-		
+
 		if (next_reduction < (2 << ZOOM_SHIFT)
-			&& LOBYTE (GLOBAL (CurrentActivity)) == IN_LAST_BATTLE)
+				&& LOBYTE (GLOBAL (CurrentActivity)) == IN_LAST_BATTLE)
 			next_reduction = (2 << ZOOM_SHIFT);
 	}
-	
+
 #ifdef KDEBUG
 	log_add (log_Debug, "CalcReduction: exit");
 #endif
-	
+
 	return (next_reduction);
 }
 
-// JMS: Changed a shitload of POINTs to DPOINTs and SIZEs to SDWORDs to
-// avoid overflows in hi-res.
 static VIEW_STATE
 CalcView (DPOINT *pNewScrollPt, SIZE next_reduction,
-		  SDWORD *pdx, SDWORD *pdy, COUNT ships_alive)
+		SDWORD *pdx, SDWORD *pdy, COUNT ships_alive)
 {
 	SDWORD dx, dy;
 	VIEW_STATE view_state;
-	
+
 #ifdef KDEBUG
 	log_add (log_Debug, "CalcView:");
 #endif
@@ -304,9 +299,7 @@ CalcView (DPOINT *pNewScrollPt, SIZE nex
 #define ORG_JUMP_X ((SDWORD)DISPLAY_ALIGN(LOG_SPACE_WIDTH / 75))
 #define ORG_JUMP_Y ((SDWORD)DISPLAY_ALIGN(LOG_SPACE_HEIGHT / 75))
 		if (dx > ORG_JUMP_X)
-		{
 			dx = ORG_JUMP_X;
-		}
 		else if (dx < -ORG_JUMP_X)
 			dx = -ORG_JUMP_X;
 		if (dy > ORG_JUMP_Y)
@@ -314,14 +307,13 @@ CalcView (DPOINT *pNewScrollPt, SIZE nex
 		else if (dy < -ORG_JUMP_Y)
 			dy = -ORG_JUMP_Y;
 	}
-	
-	if ((dx || dy) && LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+
+	if ((dx || dy) && inHQSpace ())
 		MoveSIS (&dx, &dy);
-	
+
 	if (zoom_out == next_reduction)
-		view_state = dx == 0 && dy == 0
-		&& LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE
-		? VIEW_STABLE : VIEW_SCROLL;
+		view_state = dx == 0 && dy == 0 && !inHQSpace ()
+				? VIEW_STABLE : VIEW_SCROLL;
 	else
 	{
 		if (optMeleeScale == TFB_SCALE_STEP)
@@ -333,32 +325,34 @@ CalcView (DPOINT *pNewScrollPt, SIZE nex
 		{
 #define ZOOM_JUMP ((1 << ZOOM_SHIFT) >> 3)
 			if (ships_alive == 1
-				&& zoom_out > next_reduction
-				&& zoom_out <= MAX_ZOOM_OUT
-				&& zoom_out - next_reduction > ZOOM_JUMP)
+					&& zoom_out > next_reduction
+					&& zoom_out <= MAX_ZOOM_OUT
+					&& zoom_out - next_reduction > ZOOM_JUMP)
 				next_reduction = zoom_out - ZOOM_JUMP;
-			
+				
 			// Always align the origin on a whole pixel to reduce the
 			// amount of object positioning jitter
 			SpaceOrg.x = DISPLAY_ALIGN((int)(LOG_SPACE_WIDTH >> 1) - (LOG_SPACE_WIDTH * next_reduction / (MAX_ZOOM_OUT << 2)));
 			SpaceOrg.y = DISPLAY_ALIGN((int)(LOG_SPACE_HEIGHT >> 1) - (LOG_SPACE_HEIGHT * next_reduction / (MAX_ZOOM_OUT << 2)));
+ 		
 		}
 		zoom_out = next_reduction;
 		view_state = VIEW_CHANGE;
 	}
-	
+
 	if (LOBYTE (GLOBAL (CurrentActivity)) <= IN_HYPERSPACE)
 		MoveGalaxy (view_state, dx, dy);
-	
+
 	*pdx = dx;
 	*pdy = dy;
-	
+
 #ifdef KDEBUG
 	log_add (log_Debug, "CalcView: exit");
 #endif
 	return (view_state);
 }
 
+
 static ELEMENT_FLAGS
 ProcessCollisions (HELEMENT hSuccElement, ELEMENT *ElementPtr,
 		TIME_VALUE min_time, ELEMENT_FLAGS process_flags)
@@ -627,8 +621,6 @@ ProcessCollisions (HELEMENT hSuccElement
 	return (ElementPtr->state_flags & COLLISION);
 }
 
-// JMS: Changed a shitload of POINTs to DPOINTs and SIZEs to SDWORDs to
-// avoid overflows in hi-res.
 static VIEW_STATE
 PreProcessQueue (SDWORD *pscroll_x, SDWORD *pscroll_y)
 {
@@ -637,60 +629,61 @@ PreProcessQueue (SDWORD *pscroll_x, SDWO
 	DPOINT Origin;
 	HELEMENT hElement;
 	COUNT ships_alive;
-	
+
 #ifdef KDEBUG
 	log_add (log_Debug, "PreProcess:");
 #endif
 	sides_active = (battle_counter[0] ? 1 : 0)
-	+ (battle_counter[1] ? 1 : 0);
-	
+			+ (battle_counter[1] ? 1 : 0);
+
 	if (optMeleeScale == TFB_SCALE_STEP)
 		min_reduction = max_reduction = MAX_VIS_REDUCTION + 1;
 	else
 		min_reduction = max_reduction = MAX_ZOOM_OUT + (1 << ZOOM_SHIFT);
-	
+
 	Origin.x = (SDWORD)(LOG_SPACE_WIDTH >> 1);
 	Origin.y = (SDWORD)(LOG_SPACE_HEIGHT >> 1);
-	
+
 	hElement = GetHeadElement ();
 	ships_alive = 0;
 	while (hElement != 0)
 	{
 		ELEMENT *ElementPtr;
 		HELEMENT hNextElement;
-		
+
 		LockElement (hElement, &ElementPtr);
-		
+
 		if (!(ElementPtr->state_flags & PRE_PROCESS))
 			PreProcess (ElementPtr);
 		hNextElement = GetSuccElement (ElementPtr);
-		
-		if (CollidingElement (ElementPtr) && !(ElementPtr->state_flags & COLLISION))
-			ProcessCollisions (hNextElement, ElementPtr, MAX_TIME_VALUE, PRE_PROCESS);
-		
+
+		if (CollidingElement (ElementPtr)
+				&& !(ElementPtr->state_flags & COLLISION))
+			ProcessCollisions (hNextElement, ElementPtr,
+					MAX_TIME_VALUE, PRE_PROCESS);
+
 		if (ElementPtr->state_flags & PLAYER_SHIP)
 		{
 			SDWORD dx, dy;
-			
+
 			ships_alive++;
-			
 			if (max_reduction > opt_max_zoom_out
-				&& min_reduction > opt_max_zoom_out)
+					&& min_reduction > opt_max_zoom_out)
 			{
 				Origin.x = DISPLAY_ALIGN (ElementPtr->next.location.x);
 				Origin.y = DISPLAY_ALIGN (ElementPtr->next.location.y);
 			}
-			
+
 			dx = DISPLAY_ALIGN (ElementPtr->next.location.x) - Origin.x;
 			dx = WRAP_DELTA_X (dx);
 			dy = DISPLAY_ALIGN (ElementPtr->next.location.y) - Origin.y;
 			dy = WRAP_DELTA_Y (dy);
-			
+
 			if (sides_active <= 2 || ElementPtr->playerNr == 0)
 			{
 				Origin.x = DISPLAY_ALIGN (Origin.x + (dx >> 1));
 				Origin.y = DISPLAY_ALIGN (Origin.y + (dy >> 1));
-				
+
 				if (dx < 0)
 					dx = -dx;
 				if (dy < 0)
@@ -698,11 +691,11 @@ PreProcessQueue (SDWORD *pscroll_x, SDWO
 				max_reduction = CalcReduction (dx, dy);
 			}
 			else if (max_reduction > opt_max_zoom_out
-					 && min_reduction <= opt_max_zoom_out)
+					&& min_reduction <= opt_max_zoom_out)
 			{
 				Origin.x = DISPLAY_ALIGN (Origin.x + (dx >> 1));
 				Origin.y = DISPLAY_ALIGN (Origin.y + (dy >> 1));
-				
+
 				if (dx < 0)
 					dx = -dx;
 				if (dy < 0)
@@ -712,33 +705,35 @@ PreProcessQueue (SDWORD *pscroll_x, SDWO
 			else
 			{
 				SIZE reduction;
-				
+
 				if (dx < 0)
 					dx = -dx;
 				if (dy < 0)
 					dy = -dy;
 				reduction = CalcReduction (dx << 1, dy << 1);
-				
+
 				if (min_reduction > opt_max_zoom_out
-					|| reduction < min_reduction)
+						|| reduction < min_reduction)
 					min_reduction = reduction;
 			}
+//			log_add (log_Debug, "dx = %d dy = %d min_red = %d max_red = %d",
+//					dx, dy, min_reduction, max_reduction);
 		}
-		
+
 		UnlockElement (hElement);
 		hElement = hNextElement;
 	}
-	
+
 	if ((min_reduction > opt_max_zoom_out || min_reduction <= max_reduction)
-		&& (min_reduction = max_reduction) > opt_max_zoom_out
-		&& (min_reduction = zoom_out) > opt_max_zoom_out)
+			&& (min_reduction = max_reduction) > opt_max_zoom_out
+			&& (min_reduction = zoom_out) > opt_max_zoom_out)
 	{
 		if (optMeleeScale == TFB_SCALE_STEP)
 			min_reduction = 0;
 		else
 			min_reduction = 1 << ZOOM_SHIFT;
 	}
-	
+
 #ifdef KDEBUG
 	log_add (log_Debug, "PreProcess: exit");
 #endif
@@ -782,9 +777,7 @@ InsertPrim (PRIM_LINKS *pLinks, COUNT pr
 
 PRIM_LINKS DisplayLinks;
 
-// JMS: Changed a shitload of POINTs to DPOINTs and SIZEs to SDWORDs to
-// avoid overflows in hi-res.
-static inline SDWORD
+static inline COORD
 CalcDisplayCoord (SDWORD c, SDWORD orgc, SIZE reduction)
 {
 	if (optMeleeScale == TFB_SCALE_STEP)
@@ -797,15 +790,13 @@ CalcDisplayCoord (SDWORD c, SDWORD orgc,
 	}
 }
 
-// JMS: Changed a shitload of POINTs to DPOINTs and SIZEs to SDWORDs to
-// avoid overflows in hi-res.
 static void
 PostProcessQueue (VIEW_STATE view_state, SDWORD scroll_x, SDWORD scroll_y)
 {
 	DPOINT delta;
 	SIZE reduction;
 	HELEMENT hElement;
-	
+
 #ifdef KDEBUG
 	log_add (log_Debug, "PostProcess:");
 #endif
@@ -813,16 +804,16 @@ PostProcessQueue (VIEW_STATE view_state,
 		reduction = zoom_out + ONE_SHIFT;
 	else
 		reduction = zoom_out << ONE_SHIFT;
-	
+
 	hElement = GetHeadElement ();
 	while (hElement != 0)
 	{
 		ELEMENT_FLAGS state_flags;
 		ELEMENT *ElementPtr;
 		HELEMENT hNextElement;
-		
+
 		LockElement (hElement, &ElementPtr);
-		
+
 		state_flags = ElementPtr->state_flags;
 		if (state_flags & PRE_PROCESS)
 		{
@@ -830,7 +821,7 @@ PostProcessQueue (VIEW_STATE view_state,
 				ElementPtr->state_flags &= ~DEFY_PHYSICS;
 			else
 				ElementPtr->state_flags &= ~COLLISION;
-			
+
 			if (state_flags & POST_PROCESS)
 			{
 				delta.x = 0;
@@ -845,34 +836,34 @@ PostProcessQueue (VIEW_STATE view_state,
 		else
 		{
 			HELEMENT hPostElement;
-			
+
 			hPostElement = hElement;
 			do
 			{
 				ELEMENT *PostElementPtr;
-				
+
 				LockElement (hPostElement, &PostElementPtr);
 				if (!(PostElementPtr->state_flags & PRE_PROCESS))
 					PreProcess (PostElementPtr);
 				hNextElement = GetSuccElement (PostElementPtr);
-				
+
 				if (CollidingElement (PostElementPtr)
-					&& !(PostElementPtr->state_flags & COLLISION))
+						&& !(PostElementPtr->state_flags & COLLISION))
 					ProcessCollisions (GetHeadElement (), PostElementPtr,
-									   MAX_TIME_VALUE, PRE_PROCESS | POST_PROCESS);
+							MAX_TIME_VALUE, PRE_PROCESS | POST_PROCESS);
 				UnlockElement (hPostElement);
 				hPostElement = hNextElement;
 			} while (hPostElement != 0);
-			
+
 			scroll_x = 0;
 			scroll_y = 0;
 			delta.x = 0;
 			delta.y = 0;
-			/* because these are newly added elements that are
-			 * already in adjusted coordinates */
+					/* because these are newly added elements that are
+					 * already in adjusted coordinates */
 			state_flags = ElementPtr->state_flags;
 		}
-		
+
 		if (state_flags & DISAPPEARING)
 		{
 			hNextElement = GetSuccElement (ElementPtr);
@@ -883,13 +874,13 @@ PostProcessQueue (VIEW_STATE view_state,
 		else
 		{
 			GRAPHICS_PRIM ObjType;
-			
+
 			ObjType = GetPrimType (&DisplayArray[ElementPtr->PrimIndex]);
 			if (view_state != VIEW_STABLE
-				|| (state_flags & (APPEARING | CHANGING)))
+					|| (state_flags & (APPEARING | CHANGING)))
 			{
 				POINT next;
-				
+
 				if (ObjType == LINE_PRIM)
 				{
 					SDWORD dx, dy;
@@ -901,7 +892,7 @@ PostProcessQueue (VIEW_STATE view_state,
 					next.y = WRAP_Y ((SDWORD)ElementPtr->current.location.y + (SDWORD)delta.y);
 					DisplayArray[ElementPtr->PrimIndex].Object.Line.first.x = CalcDisplayCoord (next.x, SpaceOrg.x, reduction);
 					DisplayArray[ElementPtr->PrimIndex].Object.Line.first.y = CalcDisplayCoord (next.y, SpaceOrg.y, reduction);
-					
+
 					next.x += dx;
 					next.y += dy;
 					DisplayArray[ElementPtr->PrimIndex].Object.Line.second.x = CalcDisplayCoord (next.x, SpaceOrg.x, reduction);
@@ -914,35 +905,35 @@ PostProcessQueue (VIEW_STATE view_state,
 					
 					DisplayArray[ElementPtr->PrimIndex].Object.Point.x = CalcDisplayCoord (next.x, SpaceOrg.x, reduction);
 					DisplayArray[ElementPtr->PrimIndex].Object.Point.y = CalcDisplayCoord (next.y, SpaceOrg.y, reduction);
-					
+
 					if (ObjType == STAMP_PRIM || ObjType == STAMPFILL_PRIM)
 					{
 						if (view_state == VIEW_CHANGE
-							|| (state_flags & (APPEARING | CHANGING)))
+								|| (state_flags & (APPEARING | CHANGING)))
 						{
 							COUNT index, scale = GSCALE_IDENTITY;
-							
+						
 							if (optMeleeScale == TFB_SCALE_STEP)
 								index = zoom_out;
 							else
 								CALC_ZOOM_STUFF (&index, &scale);
-							
+
 							ElementPtr->next.image.frame = SetEquFrameIndex (
-								ElementPtr->next.image.farray[index],
-								ElementPtr->next.image.frame);
-							
+									ElementPtr->next.image.farray[index],
+									ElementPtr->next.image.frame);
+
 							if (optMeleeScale == TFB_SCALE_TRILINEAR &&
-								index < 2 && scale != GSCALE_IDENTITY)
+									index < 2 && scale != GSCALE_IDENTITY)
 							{
 								// enqueues drawcommand to assign next
 								// (smaller) zoom level image as mipmap,
 								// needed for trilinear scaling
-								
+
 								FRAME frame = ElementPtr->next.image.frame;
 								FRAME mmframe = SetEquFrameIndex (
-									ElementPtr->next.image.farray[
-									index + 1], frame);
-								
+										ElementPtr->next.image.farray[
+										index + 1], frame);
+
 								// TODO: This is currently hacky, this code
 								//   really should not dereference FRAME.
 								//   Perhaps make mipmap part of STAMP prim?
@@ -950,27 +941,27 @@ PostProcessQueue (VIEW_STATE view_state,
 								{
 									HOT_SPOT mmhs = GetFrameHot (mmframe);
 									TFB_DrawScreen_SetMipmap (frame->image,
-										mmframe->image, mmhs.x, mmhs.y);
+											mmframe->image, mmhs.x, mmhs.y);
 								}
 							}
 						}
 						DisplayArray[ElementPtr->PrimIndex].Object.Stamp.frame =
-						ElementPtr->next.image.frame;
+								ElementPtr->next.image.frame;
 					}
 				}
-				
+
 				ElementPtr->next.location = next;
 			}
-			
+
 			PostProcess (ElementPtr);
-			
+
 			if (ObjType < NUM_PRIMS)
 				InsertPrim (&DisplayLinks, ElementPtr->PrimIndex, END_OF_LIST);
-			
+
 			hNextElement = GetSuccElement (ElementPtr);
 			UnlockElement (hElement);
 		}
-		
+
 		hElement = hNextElement;
 	}
 #ifdef KDEBUG
@@ -1005,28 +996,26 @@ InitDisplayList (void)
 
 UWORD nth_frame = 0;
 
-// JMS: Changed a shitload of POINTs to DPOINTs and SIZEs to SDWORDs to
-// avoid overflows in hi-res.
 void
 RedrawQueue (BOOLEAN clear)
 {
 	SDWORD scroll_x, scroll_y;
 	VIEW_STATE view_state;
-	
+
 	SetContext (StatusContext);
-	
+
 	view_state = PreProcessQueue (&scroll_x, &scroll_y);
 	PostProcessQueue (view_state, scroll_x, scroll_y);
-	
+
 	if (optStereoSFX)
 		UpdateSoundPositions ();
-	
+
 	SetContext (SpaceContext);
 	if (LOBYTE (GLOBAL (CurrentActivity)) == SUPER_MELEE
 		|| !(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD)))
 	{
 		BYTE skip_frames;
-		
+
 		skip_frames = HIBYTE (nth_frame);
 		if (skip_frames != (BYTE)~0
 			&& (skip_frames == 0 || (--nth_frame & 0x00FF) == 0))
@@ -1034,19 +1023,19 @@ RedrawQueue (BOOLEAN clear)
 			nth_frame += skip_frames;
 			if (clear)
 				ClearDrawable (); // this is for BATCH_BUILD_PAGE effect, but not scaled by SetGraphicScale
-			
+
 			if (optMeleeScale != TFB_SCALE_STEP)
 			{
 				COUNT index, scale;
-				
+
 				CALC_ZOOM_STUFF (&index, &scale);
 				SetGraphicScale (scale);
 			}
-			
+
 			DrawBatch (DisplayArray, DisplayLinks, 0);//BATCH_BUILD_PAGE);
 			SetGraphicScale (0);
 		}
-		
+
 		FlushSounds ();
 	}
 	else
@@ -1054,7 +1043,7 @@ RedrawQueue (BOOLEAN clear)
 		ProcessSound ((SOUND)~0, NULL);
 		FlushSounds ();
 	}
-	
+
 	DisplayLinks = MakeLinks (END_OF_LIST, END_OF_LIST);
 }
 
diff -ruNp src.hd/uqm/process.h src/uqm/process.h
--- src.hd/uqm/process.h	2017-12-29 02:25:53 -0800
+++ src/uqm/process.h	2017-12-29 00:57:50 -0800
@@ -21,9 +21,17 @@
 #include "libs/gfxlib.h"
 #include "element.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern void RedrawQueue (BOOLEAN clear);
 extern void InitDisplayList (void);
 extern void SetUpElement (ELEMENT *ElementPtr);
 extern void InsertPrim (PRIM_LINKS *pLinks, COUNT primIndex, COUNT iPI);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* UQM_PROCESS_H_INCL_ */
diff -ruNp src.hd/uqm/races.h src/uqm/races.h
--- src.hd/uqm/races.h	2017-12-29 02:25:53 -0800
+++ src/uqm/races.h	2017-12-29 00:57:50 -0800
@@ -16,9 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
-
 #ifndef _RACES_H
 #define _RACES_H
 
@@ -34,6 +31,10 @@ typedef HLINK HSTARSHIP;
 #include "libs/sndlib.h"
 #include "libs/reslib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 
 // TODO: remove RACES_PER_PLAYER remnant of SC1
 #define RACES_PER_PLAYER 7
@@ -41,19 +42,19 @@ typedef HLINK HSTARSHIP;
 
 /* SHIP_INFO.ship_flags - ship specific flags */
 /* bits 0 and 1 are now available */
-#define SEEKING_WEAPON      (1 << 2)
-#define SEEKING_SPECIAL     (1 << 3)
-#define POINT_DEFENSE       (1 << 4)
+#define SEEKING_WEAPON    (1 << 2)
+#define SEEKING_SPECIAL   (1 << 3)
+#define POINT_DEFENSE     (1 << 4)
 		/* Ship has some point-defense capabilities */
-#define IMMEDIATE_WEAPON    (1 << 5)
-#define CREW_IMMUNE         (1 << 6)
-#define FIRES_FORE          (1 << 7)
-#define FIRES_RIGHT         (1 << 8)
-#define FIRES_AFT           (1 << 9)
-#define FIRES_LEFT          (1 << 10)
-#define SHIELD_DEFENSE      (1 << 11)
-#define DONT_CHASE          (1 << 12)
-#define PLAYER_CAPTAIN      (1 << 13)
+#define IMMEDIATE_WEAPON  (1 << 5)
+#define CREW_IMMUNE       (1 << 6)
+#define FIRES_FORE        (1 << 7)
+#define FIRES_RIGHT       (1 << 8)
+#define FIRES_AFT         (1 << 9)
+#define FIRES_LEFT        (1 << 10)
+#define SHIELD_DEFENSE    (1 << 11)
+#define DONT_CHASE        (1 << 12)
+#define PLAYER_CAPTAIN    (1 << 13)
 		/* The protagonist himself is on board. He gets a different color. */
 #define LIGHT_POINT_DEFENSE (1 << 14)
 #define HEAVY_POINT_DEFENSE (1 << 15)
@@ -160,6 +161,7 @@ typedef struct
 
 typedef struct
 {
+	const char *idStr;
 	UWORD ship_flags;
 	BYTE ship_cost;
 	
@@ -222,7 +224,7 @@ struct race_desc
 	POSTPROCESS_FUNC *postprocess_func;
 	INIT_WEAPON_FUNC *init_weapon_func;
 
-	intptr_t data;  // private ship data, ship code owns this
+	void* data;  // private ship data, ship code owns this
 
 	void *CodeRef;
 };
@@ -344,6 +346,7 @@ typedef struct
 	HFLEETINFO succ;
 
 	SPECIES_ID SpeciesID;
+	const char *shipIdStr;
 
 	UWORD allied_state; /* GOOD_GUY, BAD_GUY or DEAD_GUY */
 	BYTE days_left;   /* Days left before the fleet reachers 'dest_loc'. */
@@ -385,10 +388,10 @@ typedef struct
 // Values for FLEET_INFO.allied_state
 enum
 {
-	DEAD_GUY = 0,
-	GOOD_GUY,
-	BAD_GUY,
-	CAN_BUILD,
+	DEAD_GUY = 0,  // Race is extinct
+	GOOD_GUY,      // Race is allied with the player
+	BAD_GUY,       // Race is not allied with the player
+	CAN_BUILD,	   // Ships can be built regardless
 };
 
 static inline FLEET_INFO *
@@ -400,7 +403,8 @@ LockFleetInfo (const QUEUE *pq, HFLEETIN
 
 #define UnlockFleetInfo(pq, h) UnlockLink (pq, h)
 
-enum
+// Used as index into avail_race_q.
+typedef enum
 {
 	ARILOU_SHIP,
 	CHMMR_SHIP,
@@ -430,7 +434,7 @@ enum
 	SAMATRA_SHIP = URQUAN_DRONE_SHIP,
 
 	NUM_AVAILABLE_RACES
-};
+} RACE_ID;
 
 #define RACE_COMMUNICATION \
 		ARILOU_CONVERSATION,       /* ARILOU_SHIP */ \
@@ -748,5 +752,9 @@ enum
 		FALSE,	/* BLACK_URQUAN_SHIP */ \
 		FALSE,	/* YEHAT_REBEL_SHIP */
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _RACES_H */
 
diff -ruNp src.hd/uqm/resinst.h src/uqm/resinst.h
--- src.hd/uqm/resinst.h	2017-12-29 02:25:53 -0800
+++ src/uqm/resinst.h	2017-12-29 00:57:50 -0800
@@ -22,3 +22,4 @@
 #include "istrtab.h"
 #include "isndres.h"
 #include "imusicre.h"
+#include "iscriptres.h"
diff -ruNp src.hd/uqm/restart.c src/uqm/restart.c
--- src.hd/uqm/restart.c	2017-12-29 02:25:53 -0800
+++ src/uqm/restart.c	2017-12-29 00:57:50 -0800
@@ -16,15 +16,12 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "restart.h"
- 
+
 #include "colors.h"
 #include "controls.h"
 #include "credits.h"
-// XXX: for star_array[]
-#include "encount.h"
+#include "starmap.h"
 #include "fmv.h"
 #include "menustat.h"
 #include "gamestr.h"
@@ -33,28 +30,20 @@
 #include "supermelee/melee.h"
 #include "resinst.h"
 #include "nameref.h"
+#include "save.h"
 #include "settings.h"
-#include "load.h"
 #include "setup.h"
 #include "sounds.h"
 #include "setupmenu.h"
 #include "util.h"
 #include "starcon.h"
 #include "uqmversion.h"
-#include "svnversion.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/inplib.h"
-
-#include "libs/log.h"
-
 #include "libs/graphics/sdl/pure.h"
-
-#include "options.h" // JMS: To make the game recognize resFactorWasChanged even without network support.
-
-
-// TODO: This entire module fails to uphold the GraphicsLock semantics
-//   This either has to be fixed, or GraphicsLock completely ignored,
-//   or will become irrelevant if GraphicsLock completely removed.
+#include "libs/log.h"
+#include "options.h"
+#include "cons_res.h"
 
 enum
 {
@@ -71,41 +60,48 @@ DrawRestartMenuGraphic (MENU_STATE *pMS)
 {
 	RECT r;
 	STAMP s;
-	TEXT t;
+	TEXT t; 
+	char *Credit;
 	UNICODE buf[64];
-	COUNT svn_revision = 0; // JMS
 
-	//DC: Load the different menus depending on the resolution factor
-	if (resolutionFactor < 1)
-		s.frame = CaptureDrawable (LoadGraphic (RESTART_PMAP_ANIM));
-	if (resolutionFactor == 1)
-		s.frame = CaptureDrawable (LoadGraphic (RESTART_PMAP_ANIM2x));
-	if (resolutionFactor > 1)
-		s.frame = CaptureDrawable (LoadGraphic (RESTART_PMAP_ANIM4x));
-
-	// Re-load the info box font so the text shows in correct size after changing the resolution.
-	if (resFactorWasChanged)
-	{	
-		DestroyFont (StarConFont);
-		
-		if (resolutionFactor < 1)
-			StarConFont = LoadFont (FALLBACK_TO1X_FONT);
-		if (resolutionFactor == 1)
-			StarConFont = LoadFont (FALLBACK_TO2X_FONT);
-		if (resolutionFactor > 1)
-			StarConFont = LoadFont (FALLBACK_TO4X_FONT);
-		
+	// Re-load all of the restart menu fonts so the text shows in correct size after changing the resolution.
+	if (resFactorWasChanged) {	
 		DestroyFont (TinyFont);
-		
-		if (resolutionFactor < 1)
-			TinyFont = LoadFont (TINY_FALLBACK_TO1X_FONT);
-		if (resolutionFactor == 1)
-			TinyFont = LoadFont (TINY_FALLBACK_TO2X_FONT);
-		if (resolutionFactor > 1)
-			TinyFont = LoadFont (TINY_FALLBACK_TO4X_FONT);
+		DestroyFont (PlyrFont);
+		DestroyFont (StarConFont);
 	}
 	
-	pMS->CurFrame = s.frame;
+
+	// DC: Load the different menus and fonts depending on the resolution factor	
+	switch (resolutionFactor){
+		case 1:
+			if (resFactorWasChanged) {
+				TinyFont = LoadFont (TINY_FALLBACK_TO2X_FONT);
+				PlyrFont = LoadFont (PLYR_FALLBACK_TO2X_FONT);
+				StarConFont = LoadFont (SCON_FALLBACK_TO2X_FONT);
+			}
+			pMS->CurFrame = CaptureDrawable (LoadGraphic (RESTART_PMAP_ANIM2x));
+			break;
+		case 2:
+			if (resFactorWasChanged) {
+				TinyFont = LoadFont (TINY_FALLBACK_TO4X_FONT);
+				PlyrFont = LoadFont (PLYR_FALLBACK_TO4X_FONT);
+				StarConFont = LoadFont (SCON_FALLBACK_TO4X_FONT);
+			}
+			pMS->CurFrame = CaptureDrawable (LoadGraphic (RESTART_PMAP_ANIM4x));
+			break;
+		case 0:
+		default:
+			if (resFactorWasChanged) {
+				TinyFont = LoadFont (TINY_FALLBACK_TO1X_FONT);
+				PlyrFont = LoadFont (PLYR_FALLBACK_TO1X_FONT);
+				StarConFont = LoadFont (SCON_FALLBACK_TO1X_FONT);
+			}
+			pMS->CurFrame = CaptureDrawable (LoadGraphic (RESTART_PMAP_ANIM));
+			break;
+	}
+
+	s.frame = pMS->CurFrame;
 	GetFrameRect (s.frame, &r);
 	s.origin.x = (SCREEN_WIDTH - r.extent.width) >> 1;
 	s.origin.y = (SCREEN_HEIGHT - r.extent.height) >> 1;
@@ -114,48 +110,37 @@ DrawRestartMenuGraphic (MENU_STATE *pMS)
 	BatchGraphics ();
 	ClearDrawable ();
 	FlushColorXForms ();
-	LockMutex (GraphicsLock);
 	DrawStamp (&s);
 
-	// JMS: Hack for printing out the correct SVN revision number.
-	{
-		UNICODE svn_buf[64] = {0};
-		char *colonPtr;
-		
-		strcpy(svn_buf, UQMHD_SVN_REVISION);
-		colonPtr = strchr(svn_buf, ':');
-		
-		// The revision number is in format rXXX
-		if (colonPtr == NULL)
-		{
-			// Let's just take the only number and be happy.
-			svn_revision = atoi(svn_buf);
-		}
-		// the revision number is in format rXXX:ZZZ
-		else
-		{
-			// Now we need to extract only the ZZZ number.
-			UNICODE svn_buf2[10];
-			strcpy(svn_buf2, colonPtr+1);
-			svn_revision = atoi(svn_buf2);
-		}
-		
-		// Think about this for a while ;)
-		++svn_revision;
-	}
-	
 	// Put the version number in the bottom right corner.
 	SetContextFont (TinyFont);
 	t.pStr = buf;
-	t.baseline.x = SCREEN_WIDTH - 3;
-	t.baseline.y = SCREEN_HEIGHT - 2;
+	t.baseline.x = SCREEN_WIDTH - RES_SCALE(2);
+	t.baseline.y = SCREEN_HEIGHT - RES_SCALE(2);
 	t.align = ALIGN_RIGHT;
 	t.CharCount = (COUNT)~0;
-	sprintf (buf, "v%d.%d.%d%s - SVN r%d", UQM_MAJOR_VERSION, UQM_MINOR_VERSION, UQM_PATCH_VERSION, UQM_EXTRA_VERSION, svn_revision);
+	sprintf (buf, "v%d.%d.%d%s", UQM_MAJOR_VERSION, UQM_MINOR_VERSION, UQM_PATCH_VERSION, UQM_EXTRA_VERSION);
 	SetContextForeGroundColor (WHITE_COLOR);
 	font_DrawText (&t);
-
-	UnlockMutex (GraphicsLock);
+	// Put the main menu music credit in the bottom left corner.
+	memset(&buf[0], 0, sizeof(buf));
+	t.baseline.x = RES_SCALE(2);
+	t.baseline.y = SCREEN_HEIGHT - RES_SCALE(2);
+	t.align = ALIGN_LEFT;
+	switch (Rando){
+		case 1:
+			Credit = "Main Menu Music by Rush AX";
+			break;
+		case 2:
+			Credit = "Main Menu Music by Mark Vera";
+			break;
+		case 0:
+		default:
+			Credit = "Main Menu Music by Saibuster";
+			break;
+	}
+	sprintf (buf, "%s", Credit);
+	font_DrawText (&t);
 	UnbatchGraphics ();
 }
 
@@ -169,6 +154,24 @@ DrawRestartMenu (MENU_STATE *pMS, BYTE N
 	Flash_setOverlay (pMS->flashContext, &origin, SetAbsFrameIndex (f, NewState + 1), cleanup);
 }
 
+static void
+ResChanged (MENU_STATE *pMS) {	
+	SetFlashRect (NULL);
+	DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35));
+	// Got to restart -message
+	SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
+	SetTransitionSource (NULL);
+	BatchGraphics ();
+	DrawRestartMenuGraphic (pMS);
+	DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
+	ScreenTransition (3, NULL);
+	UnbatchGraphics ();
+	//fade_buf[0] = FadeAllToBlack;
+	//SleepThreadUntil (XFormColorMap ((COLORMAPPTR)fade_buf, ONE_SECOND / 2));
+	SleepThreadUntil (FadeScreen(FadeAllToBlack, ONE_SECOND / 2));
+	GLOBAL (CurrentActivity) = CHECK_ABORT;
+}
+
 static BOOLEAN
 DoRestart (MENU_STATE *pMS)
 {
@@ -184,15 +187,16 @@ DoRestart (MENU_STATE *pMS)
 
 	if (!pMS->Initialized)
 	{
-		if (pMS->hMusic)
+		if (pMS->hMusic && !comingFromInit)
 		{
 			StopMusic ();
 			DestroyMusic (pMS->hMusic);
 			pMS->hMusic = 0;
 		}
 		
-		pMS->hMusic = LoadMusic (MAINMENU_MUSIC);
-		InactTimeOut = (pMS->hMusic && optMainmenuMusic ? 86 : 20) * ONE_SECOND;
+		pMS->hMusic = loadMainMenuMusic (Rando);
+		InactTimeOut = (optMainMenuMusic ? 90 : 20) * ONE_SECOND;
+
 		pMS->flashContext = Flash_createOverlay (ScreenContext,
 				NULL, NULL);
 		Flash_setMergeFactors (pMS->flashContext, -3, 3, 16);
@@ -201,17 +205,23 @@ DoRestart (MENU_STATE *pMS)
 		Flash_setFrameTime (pMS->flashContext, ONE_SECOND / 16);
 		Flash_setState(pMS->flashContext, FlashState_fadeIn,
 				(3 * ONE_SECOND) / 16);
+
+		if(optSuperMelee)
+			goto MELEE; // A really shitty way to start Super Melee without using the menu.
+
 		DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
 		Flash_start (pMS->flashContext);
 		LastInputTime = GetTimeCounter ();
 		pMS->Initialized = TRUE;
 
 		SleepThreadUntil (FadeScreen (FadeAllToColor, ONE_SECOND / 2));
-		FadeMusic(0,0);
-		PlayMusic (pMS->hMusic, TRUE, 1);
+		if (!comingFromInit){
+			FadeMusic(0,0);
+			PlayMusic (pMS->hMusic, TRUE, 1);
 		
-		if (optMainmenuMusic)
-			FadeMusic (NORMAL_VOLUME+70, ONE_SECOND * 3);
+			if (optMainMenuMusic)
+				FadeMusic (NORMAL_VOLUME+70, ONE_SECOND * 3);
+		}
 	}
 	else if (GLOBAL (CurrentActivity) & CHECK_ABORT)
 	{
@@ -231,15 +241,12 @@ DoRestart (MENU_STATE *pMS)
 			packsInstalled = TRUE;
 		else
 			packsInstalled = FALSE;
-		
+
 		switch (pMS->CurState)
 		{
 			case LOAD_SAVED_GAME:
-				if (resFactorWasChanged)
-				{
-					LockMutex (GraphicsLock);
+				if (resFactorWasChanged) {
 					SetFlashRect (NULL);
-					UnlockMutex (GraphicsLock);
 					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35));
 					// Got to restart -message
 					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
@@ -253,11 +260,9 @@ DoRestart (MENU_STATE *pMS)
 					//SleepThreadUntil (XFormColorMap ((COLORMAPPTR)fade_buf, ONE_SECOND / 2));
 					SleepThreadUntil (FadeScreen(FadeAllToBlack, ONE_SECOND / 2));
 					GLOBAL (CurrentActivity) = CHECK_ABORT;
-				}
-				else if (!packsInstalled)
-				{
+				} else if (!packsInstalled) {
 					Flash_pause(pMS->flashContext);
-					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35 + resolutionFactor));
+					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35 + RESOLUTION_FACTOR));
 					// Could not find graphics pack - message
 					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
 					SetTransitionSource (NULL);
@@ -269,19 +274,14 @@ DoRestart (MENU_STATE *pMS)
 					Flash_continue(pMS->flashContext);
 					SleepThreadUntil (TimeIn + ONE_SECOND / 30);
 					return TRUE;
-				}
-				else
-				{
+				} else {
 					LastActivity = CHECK_LOAD;
 					GLOBAL (CurrentActivity) = IN_INTERPLANETARY;
 				}
 				break;
 			case START_NEW_GAME:
-				if (resFactorWasChanged)
-				{
-					LockMutex (GraphicsLock);
+				if (resFactorWasChanged) {
 					SetFlashRect (NULL);
-					UnlockMutex (GraphicsLock);
 					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35));
 					// Got to restart -message
 					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
@@ -295,11 +295,9 @@ DoRestart (MENU_STATE *pMS)
 					//SleepThreadUntil (XFormColorMap ((COLORMAPPTR)fade_buf, ONE_SECOND / 2));
 					SleepThreadUntil (FadeScreen(FadeAllToBlack, ONE_SECOND / 2));
 					GLOBAL (CurrentActivity) = CHECK_ABORT;
-				}
-				else if (!packsInstalled)
-				{
+				} else if (!packsInstalled) {
 					Flash_pause(pMS->flashContext);
-					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35 + resolutionFactor));
+					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35 + RESOLUTION_FACTOR));
 					// Could not find graphics pack - message
 					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
 					SetTransitionSource (NULL);
@@ -316,14 +314,14 @@ DoRestart (MENU_STATE *pMS)
 				{
 					LastActivity = CHECK_LOAD | CHECK_RESTART;
 					GLOBAL (CurrentActivity) = IN_INTERPLANETARY;
-				}				
+				}	
 				break;
 			case PLAY_SUPER_MELEE:
-				if (resFactorWasChanged)
-				{
-					LockMutex (GraphicsLock);
+				MELEE:
+				if(optSuperMelee)
+					optSuperMelee = FALSE;
+				if (resFactorWasChanged) {
 					SetFlashRect (NULL);
-					UnlockMutex (GraphicsLock);
 					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35));
 					// Got to restart -message
 					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
@@ -337,11 +335,9 @@ DoRestart (MENU_STATE *pMS)
 					//SleepThreadUntil (XFormColorMap ((COLORMAPPTR)fade_buf, ONE_SECOND / 2));
 					SleepThreadUntil (FadeScreen(FadeAllToBlack, ONE_SECOND / 2));
 					GLOBAL (CurrentActivity) = CHECK_ABORT;
-				}
-				else if (!packsInstalled)
-				{
+				} else if (!packsInstalled) {
 					Flash_pause(pMS->flashContext);
-					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35 + resolutionFactor));
+					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35 + RESOLUTION_FACTOR));
 					// Could not find graphics pack - message
 					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
 					SetTransitionSource (NULL);
@@ -353,11 +349,8 @@ DoRestart (MENU_STATE *pMS)
 					Flash_continue(pMS->flashContext);
 					SleepThreadUntil (TimeIn + ONE_SECOND / 30);
 					return TRUE;
-				}
-				else
-				{
+				} else
 					GLOBAL (CurrentActivity) = SUPER_MELEE;
-				}
 				break;
 			case SETUP_GAME:
 				oldresfactor = resolutionFactor;
@@ -367,13 +360,14 @@ DoRestart (MENU_STATE *pMS)
 				SetupMenu ();
 				SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN,
 						MENU_SOUND_SELECT);
-				InactTimeOut = (pMS->hMusic && optMainmenuMusic ? 86 : 20) * ONE_SECOND;
+
+				InactTimeOut = (optMainMenuMusic ? 90 : 20) * ONE_SECOND;
+
 				LastInputTime = GetTimeCounter ();
 				SetTransitionSource (NULL);
 				BatchGraphics ();
 				DrawRestartMenuGraphic (pMS);
 				ScreenTransition (3, NULL);
-				
 				// JMS_GFX: This prevents drawing an annoying wrong-sized "Setup" frame when changing resolution. 
 				if (oldresfactor < resolutionFactor)
 					DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, TRUE);
@@ -445,7 +439,6 @@ DoRestart (MENU_STATE *pMS)
 	}
 	else
 	{	// No input received, check if timed out
-		//
 		// JMS: After changing resolution mode, prevent displaying credits
 		// (until the next time the game is restarted). This is to prevent
 		// showing the credits with the wrong resolution mode's font&background.
@@ -460,7 +453,7 @@ DoRestart (MENU_STATE *pMS)
 			return FALSE;
 		}
 	}
-
+	comingFromInit = FALSE;
 	SleepThreadUntil (TimeIn + ONE_SECOND / 30);
 
 	return TRUE;
@@ -516,28 +509,30 @@ RestartMenu (MENU_STATE *pMS)
 	SleepThreadUntil (FadeScreen (FadeAllToBlack, TimeOut));
 	if (TimeOut == ONE_SECOND / 8)
 		SleepThread (ONE_SECOND * 3);
-	
+
 	DrawRestartMenuGraphic (pMS);
 	GLOBAL (CurrentActivity) &= ~CHECK_ABORT;
 	SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);
 	SetDefaultMenuRepeatDelay ();
 	DoInput (pMS, TRUE);
 	
-	if (optMainmenuMusic)
+	if (optMainMenuMusic)
 		SleepThreadUntil (FadeMusic (0, ONE_SECOND));
-	
+
 	StopMusic ();
 	if (pMS->hMusic)
 	{
 		DestroyMusic (pMS->hMusic);
 		pMS->hMusic = 0;
-		
-		if (optMainmenuMusic)
+
+		if (optMainMenuMusic)
 			FadeMusic (NORMAL_VOLUME, 0);
 	}
 
 	Flash_terminate (pMS->flashContext);
+	pMS->flashContext = 0;
 	DestroyDrawable (ReleaseDrawable (pMS->CurFrame));
+	pMS->CurFrame = 0;
 
 	if (GLOBAL (CurrentActivity) == (ACTIVITY)~0)
 		return (FALSE); // timed out
@@ -610,9 +605,10 @@ StartGame (void)
 				return (FALSE); // quit
 		}
 
-		if (LastActivity & CHECK_RESTART) { // starting a new game
-            FadeMusic (NORMAL_VOLUME, 0);
-			if (!optSkipIntro){
+		if (LastActivity & CHECK_RESTART)
+		{	// starting a new game
+			FadeMusic (NORMAL_VOLUME, 0);
+			if(!optSkipIntro){
 				Introduction ();
 			}
 		}
diff -ruNp src.hd/uqm/restart.h src/uqm/restart.h
--- src.hd/uqm/restart.h	2017-12-29 02:25:53 -0800
+++ src/uqm/restart.h	2017-12-29 00:57:50 -0800
@@ -19,8 +19,16 @@
 
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 
 extern BOOLEAN StartGame (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _RESTART_H */
 
diff -ruNp src.hd/uqm/save.c src/uqm/save.c
--- src.hd/uqm/save.c	2017-12-29 02:25:53 -0800
+++ src/uqm/save.c	2017-12-29 00:57:50 -0800
@@ -16,16 +16,13 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS 2011: - Added saving res_factor to summary_desc. It'll help making saves between different resolutions compatible.
-
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include <assert.h>
 
 #include "save.h"
 
 #include "build.h"
 #include "controls.h"
+#include "starmap.h"
 #include "encount.h"
 #include "libs/file.h"
 #include "gamestr.h"
@@ -35,7 +32,7 @@
 #include "shipcont.h"
 #include "setup.h"
 #include "state.h"
-#include "grpinfo.h"
+#include "grpintrn.h"
 #include "util.h"
 #include "hyper.h"
 		// for SaveSisHyperState()
@@ -44,106 +41,748 @@
 #include "libs/inplib.h"
 #include "libs/log.h"
 #include "libs/memlib.h"
-#include "libs/declib.h"
-
-
-// XXX: these should handle endian conversions later
-static inline COUNT
-cwrite_8 (DECODE_REF fh, BYTE v)
-{
-	return cwrite (&v, 1, 1, fh);
-}
-
-static inline COUNT
-cwrite_16 (DECODE_REF fh, UWORD v)
-{
-	return cwrite (&v, 2, 1, fh);
-}
-
-static inline COUNT
-cwrite_32 (DECODE_REF fh, DWORD v)
-{
-	return cwrite (&v, 4, 1, fh);
-}
 
-static inline COUNT
-cwrite_ptr (DECODE_REF fh)
-{
-	return cwrite_32 (fh, 0); /* ptrs are useless in saves */
-}
+// Status boolean. If for some insane reason you need to
+// save games in different threads, you'll need to
+// protect your calls to SaveGame with a mutex.
+
+// It's arguably over-paranoid to check for error on
+// every single write, but this preserves the older
+// behavior.
+
+static BOOLEAN io_ok = TRUE;
+
+// This defines the order and the number of bits in which the game state
+// properties are saved.
+const GameStateBitMap gameStateBitMap[] = {
+		/* Shofixti states */
+	{ "SHOFIXTI_VISITS", 3 },
+	{ "SHOFIXTI_STACK1", 2 },
+	{ "SHOFIXTI_STACK2", 3 },
+	{ "SHOFIXTI_STACK3", 2 },
+	{ "SHOFIXTI_KIA", 1 },
+	{ "SHOFIXTI_BRO_KIA", 1 },
+	{ "SHOFIXTI_RECRUITED", 1 },
+
+	{ "SHOFIXTI_MAIDENS", 1 }, /* Did you find the babes yet? */
+	{ "MAIDENS_ON_SHIP", 1 },
+	{ "BATTLE_SEGUE", 1 },
+			/* Set to 0 in init_xxx_comm() if communications directly
+			 * follows an encounter.
+			 * Set to 1 in init_xxx_comm() if the player gets to decide
+			 * whether to attack or talk.
+			 * Set to 1 in communication when battle follows the
+			 * communication. It is still valid when uninit_xxx_comm() gets
+			 * called after combat or communication.
+			 */
+	{ "PLANETARY_LANDING", 1 },
+	{ "PLANETARY_CHANGE", 1 },
+			/* Flag set to 1 when the planet information for the current
+			 * world is changed since it was last saved to the starinfo.dat
+			 * file. Set when picking up bio, mineral, or energy nodes.
+			 * When there's no current world, it should be 0.
+			 */
+
+		/* Spathi states */
+	{ "SPATHI_VISITS", 3 },
+	{ "SPATHI_HOME_VISITS", 3 },
+	{ "FOUND_PLUTO_SPATHI", 2 },
+			/* 0 - Haven't met Fwiffo.
+			 * 1 - Met Fwiffo on Pluto, now talking to him.
+			 * 2 - Met Fwiffo on Pluto, after dialog.
+			 * 3 - Met Fwiffo, and have reported to the Safe Ones on
+			 *     the Spathi moon that he was either killed, or that
+			 *     you have him on board.
+			 */
+	{ "SPATHI_SHIELDED_SELVES", 1 },
+	{ "SPATHI_CREATURES_EXAMINED", 1 },
+	{ "SPATHI_CREATURES_ELIMINATED", 1 },
+	{ "UMGAH_BROADCASTERS", 1 },
+	{ "SPATHI_MANNER", 2 },
+	{ "SPATHI_QUEST", 1 },
+	{ "LIED_ABOUT_CREATURES", 2 },
+	{ "SPATHI_PARTY", 1 },
+	{ "KNOW_SPATHI_PASSWORD", 1 },
+
+	{ "ILWRATH_HOME_VISITS", 3 },
+	{ "ILWRATH_CHMMR_VISITS", 1 },
+
+	{ "ARILOU_SPACE", 1 },
+			/* 0 if the periodically opening QuasiSpace portal is
+			 * closed or closing.
+			 * 1 if the periodically opening QuasiSpace portal is
+			 * open or opening.
+			 */
+	{ "ARILOU_SPACE_SIDE", 2 },
+			/* 0 if in HyperSpace and not just emerged from the periodically
+			 * opening QuasiSpace portal.
+			 * 1 if in HyperSpace and just emerged from the periodically
+			 * QuasiSpace portal (still on the portal).
+			 * 2 if in QuasiSpace and just emerged from the periodically
+			 * opening portal (still on the portal).
+			 * 3 if in QuasiSpace and not just emerged from the
+			 * periodically opening portal.
+			 */
+	{ "ARILOU_SPACE_COUNTER", 4 },
+			/* Keeps track of how far the periodically opening QuasiSpace
+			 * portal is open. (This determines the image)
+			 * 0 <= ARILOU_SPACE_COUNTER <= 9
+			 * 0 means totally closed.
+			 * 9 means completely open.
+			 */
+
+	{ "LANDER_SHIELDS", 4 },
+
+	{ "MET_MELNORME", 1 },
+	{ "MELNORME_RESCUE_REFUSED", 1 },
+	{ "MELNORME_RESCUE_COUNT", 3 },
+	{ "TRADED_WITH_MELNORME", 1 },
+	{ "WHY_MELNORME_PURPLE", 1 },
+	{ "MELNORME_CREDIT0", 8 },
+	{ "MELNORME_CREDIT1", 8 },
+	{ "MELNORME_BUSINESS_COUNT", 2 },
+	{ "MELNORME_YACK_STACK0", 2 },
+	{ "MELNORME_YACK_STACK1", 2 },
+	{ "MELNORME_YACK_STACK2", 4 },
+	{ "MELNORME_YACK_STACK3", 3 },
+	{ "MELNORME_YACK_STACK4", 2 },
+	{ "WHY_MELNORME_BLUE", 1 },
+	{ "MELNORME_ANGER", 2 },
+	{ "MELNORME_MIFFED_COUNT", 2 },
+	{ "MELNORME_PISSED_COUNT", 2 },
+	{ "MELNORME_HATE_COUNT", 2 },
+
+	{ "PROBE_MESSAGE_DELIVERED", 1 },
+	{ "PROBE_ILWRATH_ENCOUNTER", 1 },
+
+	{ "STARBASE_AVAILABLE", 1 },
+	{ "STARBASE_VISITED", 1 },
+	{ "RADIOACTIVES_PROVIDED", 1 },
+	{ "LANDERS_LOST", 1 },
+	{ "GIVEN_FUEL_BEFORE", 1 },
+
+	{ "AWARE_OF_SAMATRA", 1 },
+	{ "YEHAT_CAVALRY_ARRIVED", 1 },
+	{ "URQUAN_MESSED_UP", 1 },
+
+	{ "MOONBASE_DESTROYED", 1 },
+	{ "WILL_DESTROY_BASE", 1 },
+
+	{ "WIMBLIS_TRIDENT_ON_SHIP", 1 },
+	{ "GLOWING_ROD_ON_SHIP", 1 },
+
+	{ "KOHR_AH_KILLED_ALL", 1 },
+
+	{ "STARBASE_YACK_STACK1", 1 },
+
+	{ "DISCUSSED_PORTAL_SPAWNER", 1 },
+	{ "DISCUSSED_TALKING_PET", 1 },
+	{ "DISCUSSED_UTWIG_BOMB", 1 },
+	{ "DISCUSSED_SUN_EFFICIENCY", 1 },
+	{ "DISCUSSED_ROSY_SPHERE", 1 },
+	{ "DISCUSSED_AQUA_HELIX", 1 },
+	{ "DISCUSSED_CLEAR_SPINDLE", 1 },
+	{ "DISCUSSED_ULTRON", 1 },
+	{ "DISCUSSED_MAIDENS", 1 },
+	{ "DISCUSSED_UMGAH_HYPERWAVE", 1 },
+	{ "DISCUSSED_BURVIX_HYPERWAVE", 1 },
+	{ "SYREEN_WANT_PROOF", 1 },
+	{ "PLAYER_HAVING_SEX", 1 },
+	{ "MET_ARILOU", 1 },
+	{ "DISCUSSED_TAALO_PROTECTOR", 1 },
+	{ "DISCUSSED_EGG_CASING0", 1 },
+	{ "DISCUSSED_EGG_CASING1", 1 },
+	{ "DISCUSSED_EGG_CASING2", 1 },
+	{ "DISCUSSED_SYREEN_SHUTTLE", 1 },
+	{ "DISCUSSED_VUX_BEAST", 1 },
+	{ "DISCUSSED_DESTRUCT_CODE", 1 },
+	{ "DISCUSSED_URQUAN_WARP", 1 },
+	{ "DISCUSSED_ARTIFACT_2", 1 },
+	{ "DISCUSSED_ARTIFACT_3", 1 },
+
+	{ "ATTACKED_DRUUGE", 1 },
+
+	{ "NEW_ALLIANCE_NAME", 2 },
+
+	{ "PORTAL_COUNTER", 4 },
+			/* Set to 1 when the player opens a QuasiSpace portal.
+			 * It will then be increased to 10, at which time
+			 * the portal is completely open. (This determines the image).
+			 */
+
+	{ "BURVIXESE_BROADCASTERS", 1 },
+	{ "BURV_BROADCASTERS_ON_SHIP", 1 },
+
+	{ "UTWIG_BOMB", 1 },
+	{ "UTWIG_BOMB_ON_SHIP", 1 },
+
+	{ "AQUA_HELIX", 1 },
+	{ "AQUA_HELIX_ON_SHIP", 1 },
+
+	{ "SUN_DEVICE", 1 },
+	{ "SUN_DEVICE_ON_SHIP", 1 },
+
+	{ "TAALO_PROTECTOR", 1 },
+	{ "TAALO_PROTECTOR_ON_SHIP", 1 },
+
+	{ "SHIP_VAULT_UNLOCKED", 1 },
+	{ "SYREEN_SHUTTLE", 1 },
+
+	{ "PORTAL_KEY", 1 },
+	{ "PORTAL_KEY_ON_SHIP", 1 },
+
+	{ "VUX_BEAST", 1 },
+	{ "VUX_BEAST_ON_SHIP", 1 },
+
+	{ "TALKING_PET", 1 },
+	{ "TALKING_PET_ON_SHIP", 1 },
+
+	{ "MOONBASE_ON_SHIP", 1 },
+
+	{ "KOHR_AH_FRENZY", 1 },
+	{ "KOHR_AH_VISITS", 2 },
+	{ "KOHR_AH_BYES", 1 },
+
+	{ "SLYLANDRO_HOME_VISITS", 3 },
+	{ "DESTRUCT_CODE_ON_SHIP", 1 },
+
+	{ "ILWRATH_VISITS", 3 },
+	{ "ILWRATH_DECEIVED", 1 },
+	{ "FLAGSHIP_CLOAKED", 1 },
+
+	{ "MYCON_VISITS", 3 },
+	{ "MYCON_HOME_VISITS", 3 },
+	{ "MYCON_AMBUSH", 1 },
+	{ "MYCON_FELL_FOR_AMBUSH", 1 },
+			/* Set to 1 when the Mycon have been told about Organon
+			 * and are moving towards it.
+			 */
+
+	{ "GLOBAL_FLAGS_AND_DATA", 8 },
+			/* This state seems to be used to distinguish between different
+			 * places where one may have an conversation with an alien.
+			 * Like home world, other world, space.
+			 * Why this needs 8 bits I don't know. Only specific
+			 * combinations of bits seem to be used (0, 1, or all bits).
+			 * A closer investigation is desirable. - SvdB
+			 * Bit 4 is set when initiating communication with the Ilwrath
+			 * 		homeworld by means of a HyperWave Broadcaster.
+			 * Bit 5 is set when initiating communication with an Ilwrath
+			 * 		ship by means of a HyperWave Broadcaster.
+			 * All bits are cleared when communication is over.
+			 */
+
+	{ "ORZ_VISITS", 3 },
+	{ "TAALO_VISITS", 3 },
+	{ "ORZ_MANNER", 2 },
+
+	{ "PROBE_EXHIBITED_BUG", 1 },
+	{ "CLEAR_SPINDLE_ON_SHIP", 1 },
+
+	{ "URQUAN_VISITS", 3 },
+	{ "PLAYER_HYPNOTIZED", 1 },
+
+	{ "VUX_VISITS", 3 },
+	{ "VUX_HOME_VISITS", 3 },
+	{ "ZEX_VISITS", 3 },
+	{ "ZEX_IS_DEAD", 1 },
+	{ "KNOW_ZEX_WANTS_MONSTER", 1 },
+
+	{ "UTWIG_VISITS", 3 },
+	{ "UTWIG_HOME_VISITS", 3 },
+	{ "BOMB_VISITS", 3 },
+	{ "ULTRON_CONDITION", 3 },
+			/* 0 if the Supox still have the Ultron
+			 * 1 if the Captain has the Ultron, completely broken
+			 * 2 if the Captain has the Ultron, with 1 fix
+			 * 3 if the Captain has the Ultron, with 2 fixes
+			 * 4 if the Captain has the Ultron, completely restored
+			 * 5 if the Ultron has been returned to the Utwig
+			 */
+	{ "UTWIG_HAVE_ULTRON", 1 },
+	{ "BOMB_UNPROTECTED", 1 },
+
+	{ "TAALO_UNPROTECTED", 1 },
+
+	{ "TALKING_PET_VISITS", 3 },
+	{ "TALKING_PET_HOME_VISITS", 3 },
+	{ "UMGAH_ZOMBIE_BLOBBIES", 1 },
+			/* The Umgah have come under the influence of the Talking Pet */
+	{ "KNOW_UMGAH_ZOMBIES", 1 },
+			/* The Captain is aware that something is up with the Umgah */
+
+	{ "ARILOU_VISITS", 3 },
+	{ "ARILOU_HOME_VISITS", 3 },
+	{ "KNOW_ARILOU_WANT_WRECK", 1 },
+	{ "ARILOU_CHECKED_UMGAH", 2 },
+	{ "PORTAL_SPAWNER", 1 },
+	{ "PORTAL_SPAWNER_ON_SHIP", 1 },
+
+	{ "UMGAH_VISITS", 3 },
+	{ "UMGAH_HOME_VISITS", 3 },
+	{ "MET_NORMAL_UMGAH", 1 },
+
+	{ "SYREEN_HOME_VISITS", 3 },
+	{ "SYREEN_SHUTTLE_ON_SHIP", 1 },
+	{ "KNOW_SYREEN_VAULT", 1 },
+
+	{ "EGG_CASE0_ON_SHIP", 1 },
+	{ "SUN_DEVICE_UNGUARDED", 1 },
+
+	{ "ROSY_SPHERE_ON_SHIP", 1 },
+			/* The Rosy Sphere is aboard the flagship, i.e. It has been
+			 * acquired from the Druuge, but not yet inserted in the broken
+			 * Ultron. cf. ROSY_SPHERE */
+
+	{ "CHMMR_HOME_VISITS", 3 },
+	{ "CHMMR_EMERGING", 1 },
+	{ "CHMMR_UNLEASHED", 1 },
+	{ "CHMMR_BOMB_STATE", 2 },
+			/* 0 - Nothing is known about the Precursor Bomb.
+			 * 1 - The captain knows from the Chmmr that some extremely
+			 *     powerful weapon is needed to destroy the Sa-Matra.
+			 * 2 - Installation of the precursor bomb has started.
+			 * 3 - Left the starbase after installation of the Precursor bomb.
+			 */
+
+	{ "DRUUGE_DISCLAIMER", 1 },
+
+	{ "YEHAT_VISITS", 3 },
+	{ "YEHAT_REBEL_VISITS", 3 },
+	{ "YEHAT_HOME_VISITS", 3 },
+	{ "YEHAT_CIVIL_WAR", 1 },
+	{ "YEHAT_ABSORBED_PKUNK", 1 },
+	{ "YEHAT_SHIP_MONTH", 4 },
+	{ "YEHAT_SHIP_DAY", 5 },
+	{ "YEHAT_SHIP_YEAR", 5 },
+
+	{ "CLEAR_SPINDLE", 1 },
+	{ "PKUNK_VISITS", 3 },
+	{ "PKUNK_HOME_VISITS", 3 },
+	{ "PKUNK_SHIP_MONTH", 4 },
+			/* The month in PKUNK_SHIP_YEAR that new ships are available
+			 * from the Pkunk. */
+	{ "PKUNK_SHIP_DAY", 5 },
+			/* The day of the month in PKUNK_SHIP_MONTH in PKUNK_SHIP_YEAR
+			 * that new ships are available. */
+	{ "PKUNK_SHIP_YEAR", 5 },
+			/* The year that new ships are available from the Pkunk
+			 * (stored as an offset from the year the game starts). */
+	{ "PKUNK_MISSION", 3 },
+
+	{ "SUPOX_VISITS", 3 },
+	{ "SUPOX_HOME_VISITS", 3 },
+
+	{ "THRADD_VISITS", 3 },
+	{ "THRADD_HOME_VISITS", 3 },
+	{ "HELIX_VISITS", 3 },
+	{ "HELIX_UNPROTECTED", 1 },
+	{ "THRADD_CULTURE", 2 },
+	{ "THRADD_MISSION", 3 },
+			/* 0 if the Thraddash fleet hasn't left the Thraddash home world.
+			 * 1 if the Thraddash are heading towards Kohr-Ah territory.
+			 * 2 if the Thraddash are fighting the Kohr-Ah.
+			 * 3 if the Thraddash are returning from Kohr-Ah territory.
+			 * 4 if the Thraddash fleet is back at the Thraddash home world.
+			 */
+
+	{ "DRUUGE_VISITS", 3 },
+	{ "DRUUGE_HOME_VISITS", 3 },
+	{ "ROSY_SPHERE", 1 },
+			/* The play has or has had the Rosy Sphere.
+			 * cf. ROSY_SHERE_ON_SHIP */
+	{ "SCANNED_MAIDENS", 1 },
+	{ "SCANNED_FRAGMENTS", 1 },
+	{ "SCANNED_CASTER", 1 },
+	{ "SCANNED_SPAWNER", 1 },
+	{ "SCANNED_ULTRON", 1 },
+
+	{ "ZOQFOT_INFO", 2 },
+	{ "ZOQFOT_HOSTILE", 1 },
+	{ "ZOQFOT_HOME_VISITS", 3 },
+	{ "MET_ZOQFOT", 1 },
+	{ "ZOQFOT_DISTRESS", 2 },
+			/* 0 if the Zoq-Fot-Pik aren't in distress
+			 * 1 if the Zoq-Fot-Pik are under attack by the Kohr-Ah
+			 * 2 if the Zoq-Fot-Pik have been destroyed because of this
+			 *   attack (not by the Kohr-Ah final victory cleansing)
+			 */
+
+	{ "EGG_CASE1_ON_SHIP", 1 },
+	{ "EGG_CASE2_ON_SHIP", 1 },
+	{ "MYCON_SUN_VISITS", 3 },
+	{ "ORZ_HOME_VISITS", 3 },
+
+	{ "MELNORME_FUEL_PROCEDURE", 1 },
+	{ "MELNORME_TECH_PROCEDURE", 1 },
+	{ "MELNORME_INFO_PROCEDURE", 1 },
+
+	{ "MELNORME_TECH_STACK", 4 },
+			/* MELNORME_TECH_STACK is now unused */
+	{ "MELNORME_EVENTS_INFO_STACK", 5 },
+	{ "MELNORME_ALIEN_INFO_STACK", 5 },
+	{ "MELNORME_HISTORY_INFO_STACK", 5 },
+
+	{ "RAINBOW_WORLD0", 8 },
+			/* Low byte of a bit array, one bit per rainbow world.
+			 * Each bit is set if the rainbow world has been visited.
+			 * The lowest bit is for the first star in the star_array
+			 * with RAINBOW_DEFINED, and so on.
+			 */
+	{ "RAINBOW_WORLD1", 2 },
+			/* High 2 bits of the bit array of which RAINBOW_WORLD0
+			 * is the low byte.
+			 */
+	{ "MELNORME_RAINBOW_COUNT", 4 },
+			/* The number of rainbow world locations sold to the Melnorme. */
+
+	{ "USED_BROADCASTER", 1 },
+	{ "BROADCASTER_RESPONSE", 1 },
+
+	{ "IMPROVED_LANDER_SPEED", 1 },
+	{ "IMPROVED_LANDER_CARGO", 1 },
+	{ "IMPROVED_LANDER_SHOT", 1 },
+
+	{ "MET_ORZ_BEFORE", 1 },
+	{ "YEHAT_REBEL_TOLD_PKUNK", 1 },
+	{ "PLAYER_HAD_SEX", 1 },
+	{ "UMGAH_BROADCASTERS_ON_SHIP", 1 },
+
+	{ "LIGHT_MINERAL_LOAD", 3 },
+	{ "MEDIUM_MINERAL_LOAD", 3 },
+	{ "HEAVY_MINERAL_LOAD", 3 },
+
+	{ "STARBASE_BULLETS", 32 },
+
+	{ "STARBASE_MONTH", 4 },
+	{ "STARBASE_DAY", 5 },
+
+	{ "CREW_SOLD_TO_DRUUGE0", 8 },
+	{ "CREW_PURCHASED0", 8 },
+	{ "CREW_PURCHASED1", 8 },
+
+	{ "URQUAN_PROTECTING_SAMATRA", 1 },
+
+	{ "THRADDASH_BODY_COUNT", 5 },
+
+	{ "UTWIG_SUPOX_MISSION", 3 },
+			/* 0 if the Utwig and Supox fleet haven't left their home world.
+			 * 1 if the U&S are on their way towards the Kohr-Ah
+			 * 2 if the U&S are fighting the Kohr-Ah (first 80 days)
+			 * 3 does not occur
+             * 4 if the U&S are fighting the Kohr-Ah (second 80 days)
+			 * 5 if the U&S are returning home.
+			 * 6 if the U&S are back at their home world.
+			 */
+	{ "SPATHI_INFO", 3 },
+
+	{ "ILWRATH_INFO", 2 },
+	{ "ILWRATH_GODS_SPOKEN", 4 },
+	{ "ILWRATH_WORSHIP", 2 },
+	{ "ILWRATH_FIGHT_THRADDASH", 1 },
+
+	{ "READY_TO_CONFUSE_URQUAN", 1 },
+	{ "URQUAN_HYPNO_VISITS", 1 },
+	{ "MENTIONED_PET_COMPULSION", 1 },
+	{ "URQUAN_INFO", 2 },
+	{ "KNOW_URQUAN_STORY", 2 },
+
+	{ "MYCON_INFO", 4 },
+	{ "MYCON_RAMBLE", 5 },
+	{ "KNOW_ABOUT_SHATTERED", 2 },
+			/* 0 if the player doesn't known about shattered worlds
+			 * 1 if the player has encountered a shattered world
+			 * 2 if the player knows that shatterred worlds are caused
+			 *   by Mycon deep children.
+			 * 3 if the player has told the Syreen that Mycon Deep Children
+			 *   cause shattered worlds. Proof doesn't have to be presented
+			 *   yet at this time.
+			 */
+	{ "MYCON_INSULTS", 3 },
+	{ "MYCON_KNOW_AMBUSH", 1 },
+			/* Set to 1 when the Mycon have been butchered at Organon,
+			 * just before the remaining Mycon head back home.
+			 */
+
+	{ "SYREEN_INFO", 2 },
+	{ "KNOW_SYREEN_WORLD_SHATTERED", 1 },
+	{ "SYREEN_KNOW_ABOUT_MYCON", 1 },
+
+	{ "TALKING_PET_INFO", 3 },
+	{ "TALKING_PET_SUGGESTIONS", 3 },
+	{ "LEARNED_TALKING_PET", 1 },
+	{ "DNYARRI_LIED", 1 },
+			/* Set when the Talking Pet tells you his version of their
+			 * race's history with the Ur-Quan.
+			 * Cleared once you confront him about this lie.
+			 */
+	{ "SHIP_TO_COMPEL", 1 },
+
+	{ "ORZ_GENERAL_INFO", 2 },
+	{ "ORZ_PERSONAL_INFO", 3 },
+	{ "ORZ_ANDRO_STATE", 2 },
+	{ "REFUSED_ORZ_ALLIANCE", 1 },
+
+	{ "PKUNK_MANNER", 2 },
+			/* 0 not met the Pkunk
+			 * 1 fought the Pkunk, but relations are still salvagable.
+			 * 2 hostile relations with the Pkunk, no way back.
+			 * 3 friendly relations with the Pkunk
+			 */
+	{ "PKUNK_ON_THE_MOVE", 1 },
+	{ "PKUNK_FLEET", 2 },
+	{ "PKUNK_MIGRATE", 2 },
+	{ "PKUNK_RETURN", 1 },
+	{ "PKUNK_WORRY", 2 },
+	{ "PKUNK_INFO", 3 },
+	{ "PKUNK_WAR", 2 },
+	{ "PKUNK_FORTUNE", 3 },
+	{ "PKUNK_MIGRATE_VISITS", 3 },
+	{ "PKUNK_REASONS", 4 },
+	{ "PKUNK_SWITCH", 1 },
+	{ "PKUNK_SENSE_VICTOR", 1 },
+
+	{ "KOHR_AH_REASONS", 2 },
+	{ "KOHR_AH_PLEAD", 2 },
+	{ "KOHR_AH_INFO", 2 },
+	{ "KNOW_KOHR_AH_STORY", 2 },
+	{ "KOHR_AH_SENSES_EVIL", 1 },
+	{ "URQUAN_SENSES_EVIL", 1 },
+
+	{ "SLYLANDRO_PROBE_VISITS", 3 },
+	{ "SLYLANDRO_PROBE_THREAT", 2 },
+	{ "SLYLANDRO_PROBE_WRONG", 2 },
+	{ "SLYLANDRO_PROBE_ID", 2 },
+	{ "SLYLANDRO_PROBE_INFO", 2 },
+	{ "SLYLANDRO_PROBE_EXIT", 2 },
+
+	{ "UMGAH_HOSTILE", 1 },
+	{ "UMGAH_EVIL_BLOBBIES", 1 },
+	{ "UMGAH_MENTIONED_TRICKS", 2 },
+
+	{ "BOMB_CARRIER", 1 },
+			/* 0 when the flagship is not in battle, or it doesn't have the
+			 *   enhanced precursor bomb installed.
+			 * 1 when the flagship is in battle and the bomb is installed.
+			 * This determines whether you can flee (if the warp escape unit
+			 * is installed at all), and whether taking the ship into the
+			 * Sa-Matra defense structure will trigger the end of the game.
+			 */
+	
+	{ "THRADD_MANNER", 1 },
+	{ "THRADD_INTRO", 2 },
+	{ "THRADD_DEMEANOR", 3 },
+	{ "THRADD_INFO", 2 },
+	{ "THRADD_BODY_LEVEL", 2 },
+	{ "THRADD_MISSION_VISITS", 1 },
+	{ "THRADD_STACK_1", 3 },
+	{ "THRADD_HOSTILE_STACK_2", 1 },
+	{ "THRADD_HOSTILE_STACK_3", 1 },
+	{ "THRADD_HOSTILE_STACK_4", 1 },
+	{ "THRADD_HOSTILE_STACK_5", 1 },
+
+	{ "CHMMR_STACK", 2 },
+
+	{ "ARILOU_MANNER", 2 },
+	{ "NO_PORTAL_VISITS", 1 },
+	{ "ARILOU_STACK_1", 2 },
+	{ "ARILOU_STACK_2", 1 },
+	{ "ARILOU_STACK_3", 2 },
+	{ "ARILOU_STACK_4", 1 },
+	{ "ARILOU_STACK_5", 2 },
+	{ "ARILOU_INFO", 2 },
+	{ "ARILOU_HINTS", 2 },
+
+	{ "DRUUGE_MANNER", 1 },
+	{ "DRUUGE_SPACE_INFO", 2 },
+	{ "DRUUGE_HOME_INFO", 2 },
+	{ "DRUUGE_SALVAGE", 1 },
+	{ "KNOW_DRUUGE_SLAVERS", 2 },
+	{ "FRAGMENTS_BOUGHT", 2 },
+
+	{ "ZEX_STACK_1", 2 },
+	{ "ZEX_STACK_2", 2 },
+	{ "ZEX_STACK_3", 2 },
+
+	{ "VUX_INFO", 2 },
+	{ "VUX_STACK_1", 4 },
+	{ "VUX_STACK_2", 2 },
+	{ "VUX_STACK_3", 2 },
+	{ "VUX_STACK_4", 2 },
+
+	{ "SHOFIXTI_STACK4", 2 },
+
+	{ "YEHAT_REBEL_INFO", 3 },
+	{ "YEHAT_ROYALIST_INFO", 1 },
+	{ "YEHAT_ROYALIST_TOLD_PKUNK", 1 },
+	{ "NO_YEHAT_ALLY_HOME", 1 },
+	{ "NO_YEHAT_HELP_HOME", 1 },
+	{ "NO_YEHAT_INFO", 1 },
+	{ "NO_YEHAT_ALLY_SPACE", 2 },
+	{ "NO_YEHAT_HELP_SPACE", 2 },
+
+	{ "ZOQFOT_KNOW_MASK", 4 },
+
+	{ "SUPOX_HOSTILE", 1 },
+	{ "SUPOX_INFO", 1 },
+	{ "SUPOX_WAR_NEWS", 2 },
+	{ "SUPOX_ULTRON_HELP", 1 },
+	{ "SUPOX_STACK1", 3 },
+	{ "SUPOX_STACK2", 2 },
+
+	{ "UTWIG_HOSTILE", 1 },
+	{ "UTWIG_INFO", 1 },
+	{ "UTWIG_WAR_NEWS", 2 },
+	{ "UTWIG_STACK1", 3 },
+	{ "UTWIG_STACK2", 2 },
+	{ "BOMB_INFO", 1 },
+	{ "BOMB_STACK1", 2 },
+	{ "BOMB_STACK2", 2 },
+
+	{ "SLYLANDRO_KNOW_BROKEN", 1 },
+	{ "PLAYER_KNOWS_PROBE", 1 },
+	{ "PLAYER_KNOWS_PROGRAM", 1 },
+	{ "PLAYER_KNOWS_EFFECTS", 1 },
+	{ "PLAYER_KNOWS_PRIORITY", 1 },
+	{ "SLYLANDRO_STACK1", 3 },
+	{ "SLYLANDRO_STACK2", 1 },
+	{ "SLYLANDRO_STACK3", 2 },
+	{ "SLYLANDRO_STACK4", 2 },
+	{ "SLYLANDRO_STACK5", 1 },
+	{ "SLYLANDRO_STACK6", 1 },
+	{ "SLYLANDRO_STACK7", 2 },
+	{ "SLYLANDRO_STACK8", 2 },
+	{ "SLYLANDRO_STACK9", 2 },
+	{ "SLYLANDRO_KNOW_EARTH", 1 },
+	{ "SLYLANDRO_KNOW_EXPLORE", 1 },
+	{ "SLYLANDRO_KNOW_GATHER", 1 },
+	{ "SLYLANDRO_KNOW_URQUAN", 2 },
+	{ "RECALL_VISITS", 2 },
+
+	{ "SLYLANDRO_MULTIPLIER", 3 },
+	{ "KNOW_SPATHI_QUEST", 1 },
+	{ "KNOW_SPATHI_EVIL", 1 },
+
+	{ "BATTLE_PLANET", 8 },
+	{ "ESCAPE_COUNTER", 8 },
+
+	{ "CREW_SOLD_TO_DRUUGE1", 8 },
+	{ "PKUNK_DONE_WAR", 1 },
+
+	{ "SYREEN_STACK0", 2 },
+	{ "SYREEN_STACK1", 2 },
+	{ "SYREEN_STACK2", 2 },
+
+	{ "REFUSED_ULTRON_AT_BOMB", 1 },
+	{ "NO_TRICK_AT_SUN", 1 },
+
+	{ "SPATHI_STACK0", 2 },
+	{ "SPATHI_STACK1", 1 },
+	{ "SPATHI_STACK2", 1 },
+
+	{ "ORZ_STACK0", 1 },
+	{ "ORZ_STACK1", 1 },
+
+	{ "SHOFIXTI_GRPOFFS", 32 },
+	{ "ZOQFOT_GRPOFFS", 32 },
+	{ "MELNORME0_GRPOFFS", 32 },
+	{ "MELNORME1_GRPOFFS", 32 },
+	{ "MELNORME2_GRPOFFS", 32 },
+	{ "MELNORME3_GRPOFFS", 32 },
+	{ "MELNORME4_GRPOFFS", 32 },
+	{ "MELNORME5_GRPOFFS", 32 },
+	{ "MELNORME6_GRPOFFS", 32 },
+	{ "MELNORME7_GRPOFFS", 32 },
+	{ "MELNORME8_GRPOFFS", 32 },
+	{ "URQUAN_PROBE_GRPOFFS", 32 },
+	{ "COLONY_GRPOFFS", 32 },
+	{ "SAMATRA_GRPOFFS", 32 },
+	
+	{ "AUTOPILOT_OK", 1 },
+	
+	{ "KNOW_QS_PORTAL_0", 1 },
+	{ "KNOW_QS_PORTAL_1", 1 },
+	{ "KNOW_QS_PORTAL_2", 1 },
+	{ "KNOW_QS_PORTAL_3", 1 },
+	{ "KNOW_QS_PORTAL_4", 1 },
+	{ "KNOW_QS_PORTAL_5", 1 },
+	{ "KNOW_QS_PORTAL_6", 1 },
+	{ "KNOW_QS_PORTAL_7", 1 },
+	{ "KNOW_QS_PORTAL_8", 1 },
+	{ "KNOW_QS_PORTAL_9", 1 },
+	{ "KNOW_QS_PORTAL_10", 1 },
+	{ "KNOW_QS_PORTAL_11", 1 },
+	{ "KNOW_QS_PORTAL_12", 1 },
+	{ "KNOW_QS_PORTAL_13", 1 },
+	{ "KNOW_QS_PORTAL_14", 1 },
+	{ "KNOW_QS_PORTAL_15", 1 },
+	
+	{ NULL, 0 },
+};
 
-static inline COUNT
-cwrite_a8 (DECODE_REF fh, const BYTE *ar, COUNT count)
-{
-	return cwrite (ar, 1, count, fh) == count;
-}
 
-static inline size_t
+// XXX: these should handle endian conversions later
+static inline void
 write_8 (void *fp, BYTE v)
 {
-	return WriteResFile (&v, 1, 1, fp);
+	if (io_ok)
+		if (WriteResFile (&v, 1, 1, fp) != 1)
+			io_ok = FALSE;
 }
 
-static inline size_t
+static inline void
 write_16 (void *fp, UWORD v)
 {
-	return WriteResFile (&v, 2, 1, fp);
+	write_8 (fp, (BYTE)( v        & 0xff));
+	write_8 (fp, (BYTE)((v >>  8) & 0xff));
 }
 
-static inline size_t
+static inline void
 write_32 (void *fp, DWORD v)
 {
-	return WriteResFile (&v, 4, 1, fp);
-}
-
-static inline size_t
-write_ptr (void *fp)
-{
-	return write_32 (fp, 0); /* ptrs are useless in saves */
+	write_8 (fp, (BYTE)( v        & 0xff));
+	write_8 (fp, (BYTE)((v >>  8) & 0xff));
+	write_8 (fp, (BYTE)((v >> 16) & 0xff));
+	write_8 (fp, (BYTE)((v >> 24) & 0xff));
 }
 
-static inline size_t
+static inline void
 write_a8 (void *fp, const BYTE *ar, COUNT count)
 {
-	return WriteResFile (ar, 1, count, fp) == count;
+	if (io_ok)
+		if (WriteResFile (ar, 1, count, fp) != count)
+			io_ok = FALSE;
 }
 
-static inline size_t
+static inline void
 write_str (void *fp, const char *str, COUNT count)
 {
 	// no type conversion needed for strings
-	return write_a8 (fp, (const BYTE *)str, count);
+	write_a8 (fp, (const BYTE *)str, count);
 }
 
-static inline size_t
+static inline void
 write_a16 (void *fp, const UWORD *ar, COUNT count)
 {
 	for ( ; count > 0; --count, ++ar)
 	{
-		if (write_16 (fp, *ar) != 1)
-			return 0;
+		if (!io_ok)
+			break;
+		write_16 (fp, *ar);
 	}
-	return 1;
-}
-
-static void
-SaveEmptyQueue (DECODE_REF fh)
-{
-	COUNT num_links = 0;
-
-	// Write the number of entries in the queue.
-	cwrite_16 (fh, num_links);
 }
 
 static void
-SaveShipQueue (DECODE_REF fh, QUEUE *pQueue)
+SaveShipQueue (uio_Stream *fh, QUEUE *pQueue, DWORD tag)
 {
 	COUNT num_links;
 	HSHIPFRAG hStarShip;
 
-	// Write the number of entries in the queue.
 	num_links = CountLinks (pQueue);
-	cwrite_16 (fh, num_links);
+	if (num_links == 0)
+		return;
+	write_32 (fh, tag);
+	write_32 (fh, num_links * 11); // Size of chunk: each entry is 11 bytes long.
 
 	hStarShip = GetHeadLink (pQueue);
 	while (num_links--)
@@ -158,22 +797,16 @@ SaveShipQueue (DECODE_REF fh, QUEUE *pQu
 		Index = FragPtr->race_id;
 		// Write the number identifying this ship type.
 		// See races.h; look for the enum containing NUM_AVAILABLE_RACES.
-		cwrite_16 (fh, Index);
+		write_16 (fh, Index);
 
 		// Write SHIP_FRAGMENT elements
-		cwrite_16 (fh, 0); /* unused; was which_side */
-		cwrite_8  (fh, FragPtr->captains_name_index);
-		cwrite_8  (fh, 0); /* padding */
-		cwrite_16 (fh, 0); /* unused: was ship_flags */
-		cwrite_8  (fh, FragPtr->race_id);
-		cwrite_8  (fh, FragPtr->index);
-		// XXX: writing crew as BYTE to maintain savegame compatibility
-		cwrite_8  (fh, FragPtr->crew_level);
-		cwrite_8  (fh, FragPtr->max_crew);
-		cwrite_8  (fh, FragPtr->energy_level);
-		cwrite_8  (fh, FragPtr->max_energy);
-		cwrite_16 (fh, 0); /* unused; was loc.x */
-		cwrite_16 (fh, 0); /* unused; was loc.y */
+		write_8  (fh, FragPtr->captains_name_index);
+		write_8  (fh, FragPtr->race_id);
+		write_8  (fh, FragPtr->index);
+		write_16 (fh, FragPtr->crew_level);
+		write_16 (fh, FragPtr->max_crew);
+		write_8  (fh, FragPtr->energy_level);
+		write_8  (fh, FragPtr->max_energy);
 
 		UnlockShipFrag (pQueue, hStarShip);
 		hStarShip = hNextShip;
@@ -181,14 +814,17 @@ SaveShipQueue (DECODE_REF fh, QUEUE *pQu
 }
 
 static void
-SaveRaceQueue (DECODE_REF fh, QUEUE *pQueue)
+SaveRaceQueue (uio_Stream *fh, QUEUE *pQueue)
 {
 	COUNT num_links;
 	HFLEETINFO hFleet;
 
-	// Write the number of entries in the queue.
 	num_links = CountLinks (pQueue);
-	cwrite_16 (fh, num_links);
+	if (num_links == 0)
+		return;
+	write_32 (fh, RACE_Q_TAG);
+	// Write chunk size: 30 bytes per entry
+	write_32 (fh, num_links * 30);
 
 	hFleet = GetHeadLink (pQueue);
 	while (num_links--)
@@ -202,28 +838,27 @@ SaveRaceQueue (DECODE_REF fh, QUEUE *pQu
 
 		Index = GetIndexFromStarShip (pQueue, hFleet);
 		// The index is the position in the queue.
-		cwrite_16 (fh, Index);
+		write_16 (fh, Index);
 
 		// Write FLEET_INFO elements
-		cwrite_16 (fh, FleetPtr->allied_state);
-		cwrite_8  (fh, FleetPtr->days_left);
-		cwrite_8  (fh, FleetPtr->growth_fract);
-		cwrite_8  (fh, FleetPtr->crew_level);
-		cwrite_8  (fh, FleetPtr->max_crew);
-		cwrite_8  (fh, FleetPtr->growth);
-		cwrite_8  (fh, FleetPtr->max_energy);
-		cwrite_16 (fh, FleetPtr->loc.x);
-		cwrite_16 (fh, FleetPtr->loc.y);
-
-		cwrite_16 (fh, FleetPtr->actual_strength);
-		cwrite_16 (fh, FleetPtr->known_strength);
-		cwrite_16 (fh, FleetPtr->known_loc.x);
-		cwrite_16 (fh, FleetPtr->known_loc.y);
-		cwrite_8  (fh, FleetPtr->growth_err_term);
-		cwrite_8  (fh, FleetPtr->func_index);
-		cwrite_16 (fh, FleetPtr->dest_loc.x);
-		cwrite_16 (fh, FleetPtr->dest_loc.y);
-		cwrite_16 (fh, 0); /* alignment padding */
+		write_16 (fh, FleetPtr->allied_state);
+		write_8  (fh, FleetPtr->days_left);
+		write_8  (fh, FleetPtr->growth_fract);
+		write_16 (fh, FleetPtr->crew_level);
+		write_16 (fh, FleetPtr->max_crew);
+		write_8  (fh, FleetPtr->growth);
+		write_8  (fh, FleetPtr->max_energy);
+		write_16 (fh, FleetPtr->loc.x);
+		write_16 (fh, FleetPtr->loc.y);
+
+		write_16 (fh, FleetPtr->actual_strength);
+		write_16 (fh, FleetPtr->known_strength);
+		write_16 (fh, FleetPtr->known_loc.x);
+		write_16 (fh, FleetPtr->known_loc.y);
+		write_8  (fh, FleetPtr->growth_err_term);
+		write_8  (fh, FleetPtr->func_index);
+		write_16 (fh, FleetPtr->dest_loc.x);
+		write_16 (fh, FleetPtr->dest_loc.y);
 
 		UnlockFleetInfo (pQueue, hFleet);
 		hFleet = hNextFleet;
@@ -231,12 +866,16 @@ SaveRaceQueue (DECODE_REF fh, QUEUE *pQu
 }
 
 static void
-SaveGroupQueue (DECODE_REF fh, QUEUE *pQueue)
+SaveGroupQueue (uio_Stream *fh, QUEUE *pQueue)
 {
 	HIPGROUP hGroup, hNextGroup;
+	COUNT num_links;
 
-	// Write the number of entries in the queue.
-	cwrite_16 (fh, CountLinks (pQueue));
+	num_links = CountLinks (pQueue);
+	if (num_links == 0)
+		return;
+	write_32 (fh, IP_GRP_Q_TAG);
+	write_32 (fh, num_links * 13); // 13 bytes per element right now
 
 	for (hGroup = GetHeadLink (pQueue); hGroup; hGroup = hNextGroup)
 	{
@@ -245,264 +884,243 @@ SaveGroupQueue (DECODE_REF fh, QUEUE *pQ
 		GroupPtr = LockIpGroup (pQueue, hGroup);
 		hNextGroup = _GetSuccLink (GroupPtr);
 
-		cwrite_16 (fh, GroupPtr->race_id); /* unused; for old versions */
-
-		cwrite_16 (fh, 0); /* unused; was which_side */
-		cwrite_8  (fh, 0); /* unused; was captains_name_index */
-		cwrite_8  (fh, 0); /* padding; for savegame compat */
-		cwrite_16 (fh, GroupPtr->group_counter);
-		cwrite_8  (fh, GroupPtr->race_id);
-		assert (GroupPtr->sys_loc < 0x10 && GroupPtr->task < 0x10);
-		cwrite_8  (fh, MAKE_BYTE (GroupPtr->sys_loc, GroupPtr->task));
-				/* was var2 */
-		cwrite_8  (fh, GroupPtr->in_system); /* was crew_level */
-		cwrite_8  (fh, 0); /* unused; was max_crew */
-		assert (GroupPtr->dest_loc < 0x10 && GroupPtr->orbit_pos < 0x10);
-		cwrite_8  (fh, MAKE_BYTE (GroupPtr->dest_loc, GroupPtr->orbit_pos));
-				/* was energy_level */
-		cwrite_8  (fh, GroupPtr->group_id); /* was max_energy */
-		cwrite_16 (fh, GroupPtr->loc.x);
-		cwrite_16 (fh, GroupPtr->loc.y);
+		write_16 (fh, GroupPtr->group_counter);
+		write_8  (fh, GroupPtr->race_id);
+		write_8  (fh, GroupPtr->sys_loc);
+		write_8  (fh, GroupPtr->task);
+		write_8  (fh, GroupPtr->in_system); /* was crew_level */
+		write_8  (fh, GroupPtr->dest_loc);
+		write_8  (fh, GroupPtr->orbit_pos);
+		write_8  (fh, GroupPtr->group_id); /* was max_energy */
+		write_16 (fh, GroupPtr->loc.x);
+		write_16 (fh, GroupPtr->loc.y);
 
 		UnlockIpGroup (pQueue, hGroup);
 	}
 }
 
 static void
-SaveEncounter (const ENCOUNTER *EncounterPtr, DECODE_REF fh)
+SaveEncounters (uio_Stream *fh)
 {
-	COUNT i;
+	COUNT num_links;
+	HENCOUNTER hEncounter;
+	num_links = CountLinks (&GLOBAL (encounter_q));
+	if (num_links == 0)
+		return;
+	write_32 (fh, ENCOUNTERS_TAG);
+	write_32 (fh, 65 * num_links);
 
-	cwrite_ptr (fh); /* useless ptr; HENCOUNTER pred */
-	cwrite_ptr (fh); /* useless ptr; HENCOUNTER succ */
-	cwrite_ptr (fh); /* useless ptr; HELEMENT hElement */
-	cwrite_16  (fh, EncounterPtr->transition_state);
-	cwrite_16  (fh, EncounterPtr->origin.x);
-	cwrite_16  (fh, EncounterPtr->origin.y);
-	cwrite_16  (fh, EncounterPtr->radius);
-	// STAR_DESC fields
-	cwrite_16  (fh, EncounterPtr->SD.star_pt.x);
-	cwrite_16  (fh, EncounterPtr->SD.star_pt.y);
-	cwrite_8   (fh, EncounterPtr->SD.Type);
-	cwrite_8   (fh, EncounterPtr->SD.Index);
-	cwrite_16  (fh, 0); /* alignment padding */
-
-	// Save each entry in the BRIEF_SHIP_INFO array
-	for (i = 0; i < MAX_HYPER_SHIPS; i++)
-	{
-		const BRIEF_SHIP_INFO *ShipInfo = &EncounterPtr->ShipList[i];
-
-		cwrite_16  (fh, 0); /* useless; was SHIP_INFO.ship_flags */
-		cwrite_8   (fh, ShipInfo->race_id);
-		cwrite_8   (fh, 0); /* useless; was SHIP_INFO.var2 */
-		// XXX: writing crew as BYTE to maintain savegame compatibility
-		cwrite_8   (fh, ShipInfo->crew_level);
-		cwrite_8   (fh, ShipInfo->max_crew);
-		cwrite_8   (fh, 0); /* useless; was SHIP_INFO.energy_level */
-		cwrite_8   (fh, ShipInfo->max_energy);
-		cwrite_16  (fh, 0); /* useless; was SHIP_INFO.loc.x */
-		cwrite_16  (fh, 0); /* useless; was SHIP_INFO.loc.y */
-		cwrite_32  (fh, 0); /* useless val; STRING race_strings */
-		cwrite_ptr (fh); /* useless ptr; FRAME icons */
-		cwrite_ptr (fh); /* useless ptr; FRAME melee_icon */
+	hEncounter = GetHeadLink (&GLOBAL (encounter_q));
+	while (num_links--)
+	{
+		HENCOUNTER hNextEncounter;
+		ENCOUNTER *EncounterPtr;
+		COUNT i;
+
+		LockEncounter (hEncounter, &EncounterPtr);
+		hNextEncounter = GetSuccEncounter (EncounterPtr);
+
+		write_16  (fh, EncounterPtr->transition_state);
+		write_16  (fh, EncounterPtr->origin.x);
+		write_16  (fh, EncounterPtr->origin.y);
+		write_16  (fh, EncounterPtr->radius);
+		// former STAR_DESC fields
+		write_16  (fh, EncounterPtr->loc_pt.x);
+		write_16  (fh, EncounterPtr->loc_pt.y);
+		write_8   (fh, EncounterPtr->race_id);
+		write_8   (fh, EncounterPtr->num_ships);
+		write_8   (fh, EncounterPtr->flags);
+
+		// Save each entry in the BRIEF_SHIP_INFO array
+		for (i = 0; i < MAX_HYPER_SHIPS; i++)
+		{
+			const BRIEF_SHIP_INFO *ShipInfo = &EncounterPtr->ShipList[i];
+
+			write_8   (fh, ShipInfo->race_id);
+			write_16  (fh, ShipInfo->crew_level);
+			write_16  (fh, ShipInfo->max_crew);
+			write_8   (fh, ShipInfo->max_energy);
+		}
+
+		// Save the stuff after the BRIEF_SHIP_INFO array
+		write_32  (fh, ((EncounterPtr->log_x) >> RESOLUTION_FACTOR));
+		write_32  (fh, ((EncounterPtr->log_y) >> RESOLUTION_FACTOR));
+
+		UnlockEncounter (hEncounter);
+		hEncounter = hNextEncounter;
 	}
-	
-	// Save the stuff after the BRIEF_SHIP_INFO array
-	// JMS: Let's make savegames work even between different resolution modes.
-	cwrite_32  (fh, ((EncounterPtr->log_x) >> RESOLUTION_FACTOR));
-	cwrite_32  (fh, ((EncounterPtr->log_y) >> RESOLUTION_FACTOR));
 }
 
 static void
-SaveEvent (const EVENT *EventPtr, DECODE_REF fh)
+SaveEvents (uio_Stream *fh)
 {
-	cwrite_ptr (fh); /* useless ptr; HEVENT pred */
-	cwrite_ptr (fh); /* useless ptr; HEVENT succ */
-	cwrite_8   (fh, EventPtr->day_index);
-	cwrite_8   (fh, EventPtr->month_index);
-	cwrite_16  (fh, EventPtr->year_index);
-	cwrite_8   (fh, EventPtr->func_index);
-	cwrite_8   (fh, 0); /* padding */
-	cwrite_16  (fh, 0); /* padding */
-}
+	COUNT num_links;
+	HEVENT hEvent;
+	num_links = CountLinks (&GLOBAL (GameClock.event_q));
+	if (num_links == 0)
+		return;
+	write_32 (fh, EVENTS_TAG);
+	write_32 (fh, num_links * 5); /* Event chunks are five bytes each */
 
-static void
-DummySaveQueue (const QUEUE *QueuePtr, DECODE_REF fh)
-{
-	/* QUEUE should never actually be saved since it contains
-	 * purely internal representation and the lists
-	 * involved are actually saved separately */
-	(void)QueuePtr; /* silence compiler */
+	hEvent = GetHeadLink (&GLOBAL (GameClock.event_q));
+	while (num_links--)
+	{
+		HEVENT hNextEvent;
+		EVENT *EventPtr;
 
-	/* QUEUE format with QUEUE_TABLE defined -- UQM default */
-	cwrite_ptr (fh); /* HLINK head */
-	cwrite_ptr (fh); /* HLINK tail */
-	cwrite_ptr (fh); /* BYTE* pq_tab */
-	cwrite_ptr (fh); /* HLINK free_list */
-	cwrite_16  (fh, 0); /* MEM_HANDLE hq_tab */
-	cwrite_16  (fh, 0); /* COUNT object_size */
-	cwrite_8   (fh, 0); /* BYTE num_objects */
-	
-	cwrite_8   (fh, 0); /* padding */
-	cwrite_16  (fh, 0); /* padding */
+		LockEvent (hEvent, &EventPtr);
+		hNextEvent = GetSuccEvent (EventPtr);
+
+		write_8   (fh, EventPtr->day_index);
+		write_8   (fh, EventPtr->month_index);
+		write_16  (fh, EventPtr->year_index);
+		write_8   (fh, EventPtr->func_index);
+
+		UnlockEvent (hEvent);
+		hEvent = hNextEvent;
+	}
 }
 
+/* The clock state is folded in with the game state chunk. */
 static void
-SaveClockState (const CLOCK_STATE *ClockPtr, DECODE_REF fh)
+SaveClockState (const CLOCK_STATE *ClockPtr, uio_Stream *fh)
 {
-	cwrite_8   (fh, ClockPtr->day_index);
-	cwrite_8   (fh, ClockPtr->month_index);
-	cwrite_16  (fh, ClockPtr->year_index);
-	cwrite_16  (fh, ClockPtr->tick_count);
-	cwrite_16  (fh, ClockPtr->day_in_ticks);
-	cwrite_ptr (fh); /* useless ptr; Semaphore clock_sem */
-	cwrite_ptr (fh); /* useless ptr; Task clock_task */
-	cwrite_32  (fh, 0); /* useless value; DWORD TimeCounter */
-
-	DummySaveQueue (&ClockPtr->event_q, fh);
+	write_8   (fh, ClockPtr->day_index);
+	write_8   (fh, ClockPtr->month_index);
+	write_16  (fh, ClockPtr->year_index);
+	write_16  (fh, ClockPtr->tick_count);
+	write_16  (fh, ClockPtr->day_in_ticks);
 }
 
-static void
-SaveGameState (const GAME_STATE *GSPtr, DECODE_REF fh)
+/* Save out the game state chunks. There are two of these; the Global
+ * State chunk is fixed size, but the Game State tag can be extended
+ * by modders. */
+static BOOLEAN
+SaveGameState (const GAME_STATE *GSPtr, uio_Stream *fh)
 {
 	BYTE res_scale; // JMS
-	
-	// JMS
+
 	if (LOBYTE (GSPtr->CurrentActivity) != IN_INTERPLANETARY)
 		res_scale = RESOLUTION_FACTOR; 
 	else
 		res_scale = 0;
-	
-	cwrite_8   (fh, 0); /* obsolete; BYTE cur_state */
-	cwrite_8   (fh, GSPtr->glob_flags);
-	cwrite_8   (fh, GSPtr->CrewCost);
-	cwrite_8   (fh, GSPtr->FuelCost);
-	cwrite_a8  (fh, GSPtr->ModuleCost, NUM_MODULES);
-	cwrite_a8  (fh, GSPtr->ElementWorth, NUM_ELEMENT_CATEGORIES);
-	cwrite_ptr (fh); /* useless ptr; PRIMITIVE *DisplayArray */
-	cwrite_16  (fh, GSPtr->CurrentActivity);
-	
-	cwrite_16  (fh, 0); /* CLOCK_STATE alignment padding */
+
+	write_32  (fh, GLOBAL_STATE_TAG);
+	write_32  (fh, 75);
+	write_8   (fh, GSPtr->glob_flags);
+	write_8   (fh, GSPtr->CrewCost);
+	write_8   (fh, GSPtr->FuelCost);
+	write_a8  (fh, GSPtr->ModuleCost, NUM_MODULES);
+	write_a8  (fh, GSPtr->ElementWorth, NUM_ELEMENT_CATEGORIES);
+	write_16  (fh, GSPtr->CurrentActivity);
+
 	SaveClockState (&GSPtr->GameClock, fh);
 
-	cwrite_16  (fh, GSPtr->autopilot.x);
-	cwrite_16  (fh, GSPtr->autopilot.y);
-	cwrite_16  (fh, GSPtr->ip_location.x);
-	cwrite_16  (fh, GSPtr->ip_location.y);
+	write_16  (fh, GSPtr->autopilot.x);
+	write_16  (fh, GSPtr->autopilot.y);
+	write_16  (fh, GSPtr->ip_location.x);
+	write_16  (fh, GSPtr->ip_location.y);
 	/* STAMP ShipStamp */
-	cwrite_16  (fh, (GSPtr->ShipStamp.origin.x >> RESOLUTION_FACTOR)); // JMS: Let's make savegames work even between different resolution modes.
-	cwrite_16  (fh, (GSPtr->ShipStamp.origin.y >> RESOLUTION_FACTOR)); // JMS: Let's make savegames work even between different resolution modes.
-	cwrite_16  (fh, GSPtr->ShipFacing);
-	cwrite_8   (fh, GSPtr->ip_planet);
-	cwrite_8   (fh, GSPtr->in_orbit);
+	write_16  (fh, (GSPtr->ShipStamp.origin.x >> RESOLUTION_FACTOR));
+	write_16  (fh, (GSPtr->ShipStamp.origin.y >> RESOLUTION_FACTOR));
+	write_16  (fh, GSPtr->ShipFacing);
+	write_8   (fh, GSPtr->ip_planet);
+	write_8   (fh, GSPtr->in_orbit);
 
 	/* VELOCITY_DESC velocity */
-	cwrite_16  (fh, GSPtr->velocity.TravelAngle);
-	cwrite_16  (fh, GSPtr->velocity.vector.width >> res_scale); // JMS: Let's make savegames work even between different resolution modes.
-	cwrite_16  (fh, GSPtr->velocity.vector.height >> res_scale);// JMS: Let's make savegames work even between different resolution modes.
-	cwrite_16  (fh, GSPtr->velocity.fract.width >> res_scale);	// JMS: Let's make savegames work even between different resolution modes.
-	cwrite_16  (fh, GSPtr->velocity.fract.height >> res_scale); // JMS: Let's make savegames work even between different resolution modes.
-	cwrite_16  (fh, GSPtr->velocity.error.width >> res_scale);	// JMS: Let's make savegames work even between different resolution modes.
-	cwrite_16  (fh, GSPtr->velocity.error.height >> res_scale);	// JMS: Let's make savegames work even between different resolution modes.
-	cwrite_16  (fh, GSPtr->velocity.incr.width >> res_scale);	// JMS: Let's make savegames work even between different resolution modes.
-	cwrite_16  (fh, GSPtr->velocity.incr.height >> res_scale);	// JMS: Let's make savegames work even between different resolution modes.
-	cwrite_16  (fh, 0); /* VELOCITY_DESC padding */
-	
-	cwrite_32  (fh, GSPtr->BattleGroupRef);
-	
-	DummySaveQueue (&GSPtr->avail_race_q, fh);
-	DummySaveQueue (&GSPtr->npc_built_ship_q, fh);
-	// Not saving ip_group_q, was not there originally
-	DummySaveQueue (&GSPtr->encounter_q, fh);
-	DummySaveQueue (&GSPtr->built_ship_q, fh);
-
-	cwrite_a8  (fh, GSPtr->GameState, sizeof (GSPtr->GameState));
-
-	//log_add (log_Debug, "Size:%lu, divided:%lu", sizeof (GSPtr->GameState), sizeof (GSPtr->GameState) % 4);
-	
-	//assert (sizeof (GSPtr->GameState) % 4 == 1);
-	cwrite_8  (fh, 0); /* GAME_STATE alignment padding */
+	write_16  (fh, GSPtr->velocity.TravelAngle >> res_scale);
+	write_16  (fh, GSPtr->velocity.vector.width >> res_scale);
+	write_16  (fh, GSPtr->velocity.vector.height >> res_scale);
+	write_16  (fh, GSPtr->velocity.fract.width >> res_scale);
+	write_16  (fh, GSPtr->velocity.fract.height >> res_scale);
+	write_16  (fh, GSPtr->velocity.error.width >> res_scale);
+	write_16  (fh, GSPtr->velocity.error.height >> res_scale);
+	write_16  (fh, GSPtr->velocity.incr.width >> res_scale);
+	write_16  (fh, GSPtr->velocity.incr.height >> res_scale);
+
+	/* The Game state bits. Vanilla UQM uses 155 bytes here at
+	 * present. Only the first 99 bytes are significant, though;
+	 * the rest will be overwritten by the BtGp chunks. */
+	write_32  (fh, GAME_STATE_TAG);
+	{
+		uint8 *buf = NULL;
+		size_t bufSize;
+		if (serialiseGameState (gameStateBitMap, &buf, &bufSize))
+		{
+			write_32  (fh, bufSize);
+			write_a8  (fh, buf, bufSize);
+			HFree(buf);
+		}
+		else
+			return FALSE;
+	}
+	return TRUE;
 }
 
-static BOOLEAN
+/* This is folded into the Summary chunk */
+static void
 SaveSisState (const SIS_STATE *SSPtr, void *fp)
 {
-	if (
-		write_32  (fp, ((SSPtr->log_x) >> RESOLUTION_FACTOR)) != 1 || // JMS: Let's make savegames work even between different resolution modes.
-		write_32  (fp, ((SSPtr->log_y) >> RESOLUTION_FACTOR)) != 1 || // JMS: Let's make savegames work even between different resolution modes.
-			write_32  (fp, SSPtr->ResUnits) != 1 ||
-			write_32  (fp, SSPtr->FuelOnBoard) != 1 ||
-			write_16  (fp, SSPtr->CrewEnlisted) != 1 ||
-			write_16  (fp, SSPtr->TotalElementMass) != 1 ||
-			write_16  (fp, SSPtr->TotalBioMass) != 1 ||
-			write_a8  (fp, SSPtr->ModuleSlots, NUM_MODULE_SLOTS) != 1 ||
-			write_a8  (fp, SSPtr->DriveSlots, NUM_DRIVE_SLOTS) != 1 ||
-			write_a8  (fp, SSPtr->JetSlots, NUM_JET_SLOTS) != 1 ||
-			write_8   (fp, SSPtr->NumLanders) != 1 ||
-			write_a16 (fp, SSPtr->ElementAmounts, NUM_ELEMENT_CATEGORIES) != 1 ||
-
-			write_str (fp, SSPtr->ShipName, SIS_NAME_SIZE) != 1 ||
-			write_str (fp, SSPtr->CommanderName, SIS_NAME_SIZE) != 1 ||
-			write_str (fp, SSPtr->PlanetName, SIS_NAME_SIZE) != 1 ||
-
-			write_16  (fp, 0) != 1 /* padding */
-		)
-		return FALSE;
-	else
-		return TRUE;
+	write_32  (fp, ((SSPtr->log_x) >> RESOLUTION_FACTOR));
+	write_32  (fp, ((SSPtr->log_y) >> RESOLUTION_FACTOR));
+	write_32  (fp, SSPtr->ResUnits);
+	write_32  (fp, SSPtr->FuelOnBoard);
+	write_16  (fp, SSPtr->CrewEnlisted);
+	write_16  (fp, SSPtr->TotalElementMass);
+	write_16  (fp, SSPtr->TotalBioMass);
+	write_a8  (fp, SSPtr->ModuleSlots, NUM_MODULE_SLOTS);
+	write_a8  (fp, SSPtr->DriveSlots, NUM_DRIVE_SLOTS);
+	write_a8  (fp, SSPtr->JetSlots, NUM_JET_SLOTS);
+	write_8   (fp, SSPtr->NumLanders);
+	write_a16 (fp, SSPtr->ElementAmounts, NUM_ELEMENT_CATEGORIES);
+
+	write_str (fp, SSPtr->ShipName, SIS_NAME_SIZE);
+	write_str (fp, SSPtr->CommanderName, SIS_NAME_SIZE);
+	write_str (fp, SSPtr->PlanetName, SIS_NAME_SIZE);
 }
 
-static BOOLEAN
+/* Write out the Summary Chunk. This is variable length because of the
+   savegame name */
+static void
 SaveSummary (const SUMMARY_DESC *SummPtr, void *fp)
 {
-	UNICODE SaveNameCheck[SAVE_CHECKER_SIZE] = {0};
-	strncpy(SaveNameCheck, SAVE_NAME_CHECKER, SAVE_CHECKER_SIZE);
-	
-	// JMS: First we store the savegamename identifier (which tells the code
-	// that this savegame has an user-given name) and the name itself.
-	if (
-		write_str (fp, SaveNameCheck, SAVE_CHECKER_SIZE) != 1 ||
-		write_str (fp, Global_save_name, SAVE_NAME_SIZE) != 1
-		)
-		return FALSE;
-	
-	if (!SaveSisState (&SummPtr->SS, fp))
-		return FALSE;
-
-	if (
-			write_8  (fp, SummPtr->Activity) != 1 ||
-			write_8  (fp, SummPtr->Flags) != 1 ||
-			write_8  (fp, SummPtr->day_index) != 1 ||
-			write_8  (fp, SummPtr->month_index) != 1 ||
-			write_16 (fp, SummPtr->year_index) != 1 ||
-			write_8  (fp, SummPtr->MCreditLo) != 1 ||
-			write_8  (fp, SummPtr->MCreditHi) != 1 ||
-			write_8  (fp, SummPtr->NumShips) != 1 ||
-			write_8  (fp, SummPtr->NumDevices) != 1 ||
-			write_a8 (fp, SummPtr->ShipList, MAX_BUILT_SHIPS) != 1 ||
-			write_a8 (fp, SummPtr->DeviceList, MAX_EXCLUSIVE_DEVICES) != 1 ||
-			write_8  (fp, SummPtr->res_factor) != 1 || // JMS: This'll help making saves in different resolutions compatible.
-		
-			write_16  (fp, 0) != 1 /* padding */
-		)
-		return FALSE;
-	else
-		return TRUE;
-}
-
+	write_32 (fp, SUMMARY_TAG);
+	write_32 (fp, 160 + strlen(SummPtr->SaveName));
+	SaveSisState (&SummPtr->SS, fp);
+
+	write_8  (fp, SummPtr->Activity);
+	write_8  (fp, SummPtr->Flags);
+	write_8  (fp, SummPtr->day_index);
+	write_8  (fp, SummPtr->month_index);
+	write_16 (fp, SummPtr->year_index);
+	write_8  (fp, SummPtr->MCreditLo);
+	write_8  (fp, SummPtr->MCreditHi);
+	write_8  (fp, SummPtr->NumShips);
+	write_8  (fp, SummPtr->NumDevices);
+	write_a8 (fp, SummPtr->ShipList, MAX_BUILT_SHIPS);
+	write_a8 (fp, SummPtr->DeviceList, MAX_EXCLUSIVE_DEVICES);
+	write_8  (fp, SummPtr->res_factor);
+	write_a8 (fp, SummPtr->SaveName, strlen(SummPtr->SaveName));
+}
+
+/* Save the Star Description chunk. This is not to be confused with
+ * the Star *Info* chunk, which records which planetary features you
+ * have exploited with your lander */
 static void
-SaveStarDesc (const STAR_DESC *SDPtr, DECODE_REF fh)
+SaveStarDesc (const STAR_DESC *SDPtr, uio_Stream *fh)
 {
-	cwrite_16 (fh, SDPtr->star_pt.x);
-	cwrite_16 (fh, SDPtr->star_pt.y);
-	cwrite_8  (fh, SDPtr->Type);
-	cwrite_8  (fh, SDPtr->Index);
-	cwrite_8  (fh, SDPtr->Prefix);
-	cwrite_8  (fh, SDPtr->Postfix);
+	write_32 (fh, STAR_TAG);
+	write_32 (fh, 8);
+	write_16 (fh, SDPtr->star_pt.x);
+	write_16 (fh, SDPtr->star_pt.y);
+	write_8  (fh, SDPtr->Type);
+	write_8  (fh, SDPtr->Index);
+	write_8  (fh, SDPtr->Prefix);
+	write_8  (fh, SDPtr->Postfix);
 }
 
 static void
-PrepareSummary (SUMMARY_DESC *SummPtr)
+PrepareSummary (SUMMARY_DESC *SummPtr, const char *name)
 {
 	SummPtr->SS = GlobData.SIS_state;
 
@@ -510,7 +1128,7 @@ PrepareSummary (SUMMARY_DESC *SummPtr)
 	switch (SummPtr->Activity)
 	{
 		case IN_HYPERSPACE:
-			if (GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1)
+			if (inQuasiSpace ())
 				SummPtr->Activity = IN_QUASISPACE;
 			break;
 		case IN_INTERPLANETARY:
@@ -559,8 +1177,9 @@ PrepareSummary (SUMMARY_DESC *SummPtr)
 	SummPtr->day_index = GLOBAL (GameClock.day_index);
 	SummPtr->month_index = GLOBAL (GameClock.month_index);
 	SummPtr->year_index = GLOBAL (GameClock.year_index);
-	
-	SummPtr->res_factor = RESOLUTION_FACTOR; // JMS: This'll help making saves in different resolutions compatible.
+	SummPtr->SaveName[SAVE_NAME_SIZE-1] = 0;
+	strncpy (SummPtr->SaveName, name, SAVE_NAME_SIZE-1);
+	SummPtr->res_factor = RESOLUTION_FACTOR;
 }
 
 static void
@@ -575,7 +1194,7 @@ SaveProblemMessage (STAMP *MsgStamp)
 	// TODO: This should probably just use DoPopupWindow()
 
 	ppStr[0] = GAME_STRING (SAVEGAME_STRING_BASE + 2);
- 
+
 	SetContextFont (StarConFont);
 
 	t.baseline.x = t.baseline.y = 0;
@@ -605,7 +1224,7 @@ SaveProblemMessage (STAMP *MsgStamp)
 	r.extent.height += (8 << RESOLUTION_FACTOR);
 
 	*MsgStamp = SaveContextFrame (&r);
-	
+
 	BatchGraphics ();
 	DrawStarConBox (&r, 2,
 			BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19),
@@ -631,27 +1250,23 @@ SaveProblem (void)
 {
 	STAMP s;
 	CONTEXT OldContext;
-	
-	LockMutex (GraphicsLock);
+
 	OldContext = SetContext (SpaceContext);
 	SaveProblemMessage (&s);
 	FlushGraphics ();
-	UnlockMutex (GraphicsLock);
 
 	WaitForAnyButton (TRUE, WAIT_INFINITE, FALSE);
 
-	LockMutex (GraphicsLock);
 	// Restore the screen under the message
 	DrawStamp (&s);
 	SetContext (OldContext);
 	DestroyDrawable (ReleaseDrawable (s.frame));
-	UnlockMutex (GraphicsLock);
 }
 
 static void
 SaveFlagshipState (void)
 {
-	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+	if (inHQSpace ())
 	{
 		// Player is in HyperSpace or QuasiSpace.
 		SaveSisHyperState ();
@@ -662,68 +1277,212 @@ SaveFlagshipState (void)
 	}
 }
 
-// This function first writes to a memory file, and then writes the whole
-// lot to the actual save file at once.
-BOOLEAN
-SaveGame (COUNT which_game, SUMMARY_DESC *SummPtr)
+static void
+SaveStarInfo (uio_Stream *fh)
 {
-	BOOLEAN success, made_room;
-	void *out_fp, *h;
-	DECODE_REF fh;
-
-	success = TRUE;
-	made_room = FALSE;
-RetrySave:
-	h = HMalloc (32 * 1024); // Serosis: Increased the size from 30kB to 32kB
-	if (h == 0
-			|| (fh = copen (h, MEMORY_STREAM, STREAM_WRITE)) == 0)
+	GAME_STATE_FILE *fp;
+	fp = OpenStateFile (STARINFO_FILE, "rb");
+	if (fp)
 	{
-		if (success)
+		DWORD flen = LengthStateFile (fp);
+		if (flen % 4)
 		{
-			success = FALSE;
-			made_room = TRUE;
-			HFree (h);
-
-			FreeSC2Data ();
-			log_add (log_Debug, "Insufficient room for save buffers"
-					" -- RETRYING");
-			goto RetrySave;
+			log_add (log_Warning, "Unexpected Star Info length! Expected an integral number of DWORDS.\n");
 		}
 		else
-			log_add (log_Debug, "Insufficient room for save buffers"
-					" -- GIVING UP!");
+		{
+			write_32 (fh, SCAN_TAG);
+			write_32 (fh, flen);
+			while (flen)
+			{
+				DWORD val;
+				sread_32 (fp, &val);
+				write_32 (fh, val);
+				flen -= 4;
+			}
+		}
+		CloseStateFile (fp);
+	}
+}
+
+static void
+SaveBattleGroup (GAME_STATE_FILE *fp, DWORD encounter_id, DWORD grpoffs, uio_Stream *fh)
+{
+	GROUP_HEADER h;
+	DWORD size = 12;
+	int i;
+	SeekStateFile (fp, grpoffs, SEEK_SET);
+	ReadGroupHeader (fp, &h);
+	for (i = 1; i <= h.NumGroups; ++i)
+	{
+		BYTE NumShips;
+		SeekStateFile (fp, h.GroupOffset[i], SEEK_SET);
+		sread_8 (fp, NULL);
+		sread_8 (fp, &NumShips);
+		size += 2 + 10 * NumShips;
+	}
+	write_32 (fh, BATTLE_GROUP_TAG);
+	write_32 (fh, size);
+	write_32 (fh, encounter_id);
+	write_8  (fh, (grpoffs && (GLOBAL (BattleGroupRef) == grpoffs)) ? 1 : 0); // current
+	write_16 (fh, h.star_index);
+	write_8  (fh, h.day_index);
+	write_8  (fh, h.month_index);
+	write_16 (fh, h.year_index);
+	write_8  (fh, h.NumGroups);
+	for (i = 1; i <= h.NumGroups; ++i)
+	{
+		int j;
+		BYTE b;
+		SeekStateFile (fp, h.GroupOffset[i], SEEK_SET);
+		sread_8 (fp, &b); // Group race icon
+		write_8 (fh, b);
+		sread_8 (fp, &b); // NumShips
+		write_8 (fh, b);
+		for (j = 0; j < b; ++j)
+		{
+			BYTE race_outer;
+			SHIP_FRAGMENT sf;
+			sread_8 (fp, &race_outer);
+			ReadShipFragment (fp, &sf);
+			write_8  (fh, race_outer);
+			write_8  (fh, sf.captains_name_index);
+			write_8  (fh, sf.race_id);
+			write_8  (fh, sf.index);
+			write_16 (fh, sf.crew_level);
+			write_16 (fh, sf.max_crew);
+			write_8  (fh, sf.energy_level);
+			write_8  (fh, sf.max_energy);
+		}
+	}
+}
+
+static DWORD
+GetBattleGroupOffset (int encounterIndex)
+{
+	// The reason for this switch, even though the group offsets are
+	// successive, is because GET_GAME_STATE is a #define, which stringizes
+	// its argument.
+	switch (encounterIndex)
+	{
+		case  1: return GET_GAME_STATE (SHOFIXTI_GRPOFFS);
+		case  2: return GET_GAME_STATE (ZOQFOT_GRPOFFS);
+		case  3: return GET_GAME_STATE (MELNORME0_GRPOFFS);
+		case  4: return GET_GAME_STATE (MELNORME1_GRPOFFS);
+		case  5: return GET_GAME_STATE (MELNORME2_GRPOFFS);
+		case  6: return GET_GAME_STATE (MELNORME3_GRPOFFS);
+		case  7: return GET_GAME_STATE (MELNORME4_GRPOFFS);
+		case  8: return GET_GAME_STATE (MELNORME5_GRPOFFS);
+		case  9: return GET_GAME_STATE (MELNORME6_GRPOFFS);
+		case 10: return GET_GAME_STATE (MELNORME7_GRPOFFS);
+		case 11: return GET_GAME_STATE (MELNORME8_GRPOFFS);
+		case 12: return GET_GAME_STATE (URQUAN_PROBE_GRPOFFS);
+		case 13: return GET_GAME_STATE (COLONY_GRPOFFS);
+		case 14: return GET_GAME_STATE (SAMATRA_GRPOFFS);
+		default:
+			log_add (log_Warning, "SetBattleGroupOffset: invalid encounter "
+					"index.\n");
+			return 0;
+	}
+}
+
+static void
+SaveGroups (uio_Stream *fh)
+{
+	GAME_STATE_FILE *fp;
+	fp = OpenStateFile (RANDGRPINFO_FILE, "rb");
+	if (fp && LengthStateFile (fp) > 0)
+	{
+		GROUP_HEADER h;
+		BYTE lastenc, count;
+		int i;
+		ReadGroupHeader (fp, &h);
+		/* Group List */
+		SeekStateFile (fp, h.GroupOffset[0], SEEK_SET);	
+		sread_8 (fp, &lastenc);
+		sread_8 (fp, &count);
+		write_32 (fh, GROUP_LIST_TAG);
+		write_32 (fh, 1 + 14 * count); // Chunk size
+		write_8 (fh, lastenc);
+		for (i = 0; i < count; ++i)
+		{
+			BYTE race_outer;
+			IP_GROUP ip;
+			sread_8 (fp, &race_outer);
+			ReadIpGroup (fp, &ip);
+
+			write_8  (fh, race_outer);
+			write_16 (fh, ip.group_counter);
+			write_8  (fh, ip.race_id);
+			write_8  (fh, ip.sys_loc);
+			write_8  (fh, ip.task);
+			write_8  (fh, ip.in_system);
+			write_8  (fh, ip.dest_loc);
+			write_8  (fh, ip.orbit_pos);
+			write_8  (fh, ip.group_id);
+			write_16 (fh, ip.loc.x);
+			write_16 (fh, ip.loc.y);
+		}
+		SaveBattleGroup (fp, 0, 0, fh);
+		CloseStateFile (fp);
+	}
+	fp = OpenStateFile (DEFGRPINFO_FILE, "rb");
+	if (fp && LengthStateFile (fp) > 0)
+	{
+		int encounter_index;
+		for (encounter_index = 1; encounter_index < 15; encounter_index++)
+		{
+			DWORD grpoffs = GetBattleGroupOffset (encounter_index);
+			if (grpoffs)
+			{
+				SaveBattleGroup (fp, encounter_index, grpoffs, fh);
+			}
+		}
+		CloseStateFile (fp);
 	}
+}
+
+// This function first writes to a memory file, and then writes the whole
+// lot to the actual save file at once.
+BOOLEAN
+SaveGame (COUNT which_game, SUMMARY_DESC *SummPtr, const char *name)
+{
+	uio_Stream *out_fp;
+	POINT pt;
+	STAR_DESC SD;
+	char file[PATH_MAX];
+	if (CurStarDescPtr)
+		SD = *CurStarDescPtr;
 	else
+		memset (&SD, 0, sizeof (SD));
+
+	// XXX: Backup: SaveFlagshipState() overwrites ip_location
+	pt = GLOBAL (ip_location);
+	SaveFlagshipState ();
+	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
+			&& !(GLOBAL (CurrentActivity)
+			& (START_ENCOUNTER | START_INTERPLANETARY)))
+		PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
+
+	// Write the memory file to the actual savegame file.
+	sprintf (file, "uqmsave.%02u", which_game);
+	if ((out_fp = res_OpenResFile (saveDir, file, "wb")))
 	{
-		GAME_STATE_FILE *fp;
-		DWORD flen;
-		COUNT num_links;
-		POINT pt;
-		STAR_DESC SD;
-		char buf[256], file[PATH_MAX];
-
-		success = TRUE;
-		if (CurStarDescPtr)
-			SD = *CurStarDescPtr;
-		else
-			memset (&SD, 0, sizeof (SD));
+		io_ok = TRUE;
+		write_32 (out_fp, SAVEFILE_TAG);
 
-		// XXX: Backup: SaveFlagshipState() overwrites ip_location
-		pt = GLOBAL (ip_location);
-		SaveFlagshipState ();
-		if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY
-				&& !(GLOBAL (CurrentActivity)
-				& (START_ENCOUNTER | START_INTERPLANETARY)))
-			PutGroupInfo (GROUPS_RANDOM, GROUP_SAVE_IP);
+		PrepareSummary (SummPtr, name);
+		SaveSummary (SummPtr, out_fp);
 
-		SaveGameState (&GlobData.Game_state, fh);
+		if (!SaveGameState (&GlobData.Game_state, out_fp))
+			io_ok = FALSE;
 
 		// XXX: Restore
 		GLOBAL (ip_location) = pt;
 		// Only relevant when loading a game and must be cleaned
 		GLOBAL (in_orbit) = 0;
 
-		SaveRaceQueue (fh, &GLOBAL (avail_race_q));
+		SaveRaceQueue (out_fp, &GLOBAL (avail_race_q));
 		// START_INTERPLANETARY is only set when saving from Homeworld
 		//   encounter screen. When the game is loaded, the
 		//   GenerateOrbitalFunction for the current star system
@@ -731,161 +1490,40 @@ RetrySave:
 		if (!(GLOBAL (CurrentActivity) & START_INTERPLANETARY))
 		{
 			if (GLOBAL (CurrentActivity) & START_ENCOUNTER)
-				SaveShipQueue (fh, &GLOBAL (npc_built_ship_q));
+				SaveShipQueue (out_fp, &GLOBAL (npc_built_ship_q), NPC_SHIP_Q_TAG);
 			else if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY)
 				// XXX: Technically, this queue does not need to be
 				//   saved/loaded at all. IP groups will be reloaded
 				//   from group state files. But the original code did,
 				//   and so will we until we can prove we do not need to.
-				SaveGroupQueue (fh, &GLOBAL (ip_group_q));
-				//SaveEmptyQueue (fh);
-			else
-				// XXX: empty queue write-out is only needed to maintain
-				//   the savegame compatibility
-				SaveEmptyQueue (fh);
+				SaveGroupQueue (out_fp, &GLOBAL (ip_group_q));
 		}
-		SaveShipQueue (fh, &GLOBAL (built_ship_q));
-
-		// Save the number of game events (compressed).
-		num_links = CountLinks (&GLOBAL (GameClock.event_q));
-		cwrite_16 (fh, num_links);
-		// Save the game events themselves (compressed):
-		{
-			HEVENT hEvent;
+		SaveShipQueue (out_fp, &GLOBAL (built_ship_q), SHIP_Q_TAG);
 
-			hEvent = GetHeadLink (&GLOBAL (GameClock.event_q));
-			while (num_links--)
-			{
-				HEVENT hNextEvent;
-				EVENT *EventPtr;
+		// Save the game event chunk
+		SaveEvents (out_fp);
 
-				LockEvent (hEvent, &EventPtr);
-				hNextEvent = GetSuccEvent (EventPtr);
+		// Save the encounter chunk (black globes in HS/QS)
+		SaveEncounters (out_fp);
 
-				SaveEvent (EventPtr, fh);
+		// Save out the data that used to be in state files
+		SaveStarInfo (out_fp);
+		SaveGroups (out_fp);
 
-				UnlockEvent (hEvent);
-				hEvent = hNextEvent;
-			}
-		}
-
-		// Save the number of encounters (black globes in HS/QS (compressed))
-		num_links = CountLinks (&GLOBAL (encounter_q));
-		// Save the encounters themselves (compressed):
-		cwrite_16 (fh, num_links);
-		{
-			HENCOUNTER hEncounter;
-
-			hEncounter = GetHeadLink (&GLOBAL (encounter_q));
-			while (num_links--)
-			{
-				HENCOUNTER hNextEncounter;
-				ENCOUNTER *EncounterPtr;
-
-				LockEncounter (hEncounter, &EncounterPtr);
-				hNextEncounter = GetSuccEncounter (EncounterPtr);
-
-				SaveEncounter (EncounterPtr, fh);
-
-				UnlockEncounter (hEncounter);
-				hEncounter = hNextEncounter;
-			}
-		}
-
-		// Copy the star info file to the memory file (compressed).
-		fp = OpenStateFile (STARINFO_FILE, "rb");
-		if (fp)
-		{
-			flen = LengthStateFile (fp);
-			// Write the uncompressed size.
-			cwrite_32 (fh, flen);
-			while (flen)
-			{
-				COUNT num_bytes;
-
-				num_bytes = flen >= sizeof (buf) ? sizeof (buf) : (COUNT)flen;
-				ReadStateFile (buf, num_bytes, 1, fp);
-				cwrite (buf, num_bytes, 1, fh);
-
-				flen -= num_bytes;
-			}
-			CloseStateFile (fp);
-		}
-
-		// Copy the defined groupinfo file into the memory file (compressed)
-		fp = OpenStateFile (DEFGRPINFO_FILE, "rb");
-		if (fp)
-		{
-			flen = LengthStateFile (fp);
-			// Write the uncompressed size.
-			cwrite_32 (fh, flen);
-			while (flen)
-			{
-				COUNT num_bytes;
-
-				num_bytes = flen >= sizeof (buf) ? sizeof (buf) : (COUNT)flen;
-				ReadStateFile (buf, num_bytes, 1, fp);
-				cwrite (buf, num_bytes, 1, fh);
-
-				flen -= num_bytes;
-			}
-			CloseStateFile (fp);
-		}
-
-		// Copy the random groupinfo file into the memory file (compressed)
-		fp = OpenStateFile (RANDGRPINFO_FILE, "rb");
-		if (fp)
-		{
-			flen = LengthStateFile (fp);
-			// Write the uncompressed size.
-			cwrite_32 (fh, flen);
-			while (flen)
-			{
-				COUNT num_bytes;
-
-				num_bytes = flen >= sizeof (buf) ? sizeof (buf) : (COUNT)flen;
-				ReadStateFile (buf, num_bytes, 1, fp);
-				cwrite (buf, num_bytes, 1, fh);
-
-				flen -= num_bytes;
-			}
-			CloseStateFile (fp);
-		}
-
-		// Write the current star desc into the memory file (compressed).
-		SaveStarDesc (&SD, fh);
-
-		flen = cclose (fh);
-
-		// Write the memory file to the actual savegame file.
-		sprintf (file, "starcon2.%02u", which_game);
-		log_add (log_Debug, "'%s' is %lu bytes long", file,
-				flen + sizeof (*SummPtr));
-		if (flen && (out_fp = res_OpenResFile (saveDir, file, "wb")))
+		// Save out the Star Descriptor
+		SaveStarDesc (&SD, out_fp);
+		
+		res_CloseResFile (out_fp);
+		if (!io_ok)
 		{
-			PrepareSummary (SummPtr);
-
-			success = SaveSummary (SummPtr, out_fp);
-			// Then write the rest of the data.
-			if (success && WriteResFile (h, flen, 1, out_fp) != 1)
-				success = FALSE;
-
-			if (res_CloseResFile ((uio_Stream *)out_fp) == 0)
-				success = FALSE;
-
+			DeleteResFile(saveDir, file);
+			return FALSE;
 		}
-		else
-			success = FALSE;
-			
-		if (!success)
-			DeleteResFile (saveDir, file);
+	}
+	else
+	{
+		return FALSE;
 	}
 
-	HFree (h);
-
-	if (made_room)
-		LoadSC2Data ();
-
-	return (success);
+	return TRUE;
 }
-
diff -ruNp src.hd/uqm/save.h src/uqm/save.h
--- src.hd/uqm/save.h	2017-12-29 02:25:53 -0800
+++ src/uqm/save.h	2017-12-29 00:57:50 -0800
@@ -17,12 +17,66 @@
 #ifndef _SAVE_H
 #define _SAVE_H
 
-#include "sis.h"
-		// for SUMMARY_DESC
+#include "sis.h" // SUMMARY_DESC includes SIS_STATE in it
+#include "globdata.h"
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+// XXX: Theoretically, a player can have 17 devices on board without
+//   cheating. We only provide
+//   room for 16 below, which is not really a problem since this
+//   is only used for displaying savegame summaries. There is also
+//   room for only 16 devices on screen.
+#define MAX_EXCLUSIVE_DEVICES 16
+#define SAVE_NAME_SIZE 64
+
+// The savefile tag numbers.
+#define SAVEFILE_TAG     0x01534d55 // "UMS\x01": UQM Save version 1
+#define SUMMARY_TAG      0x6d6d7553 // "Summ": Summary. Must be first!
+#define GLOBAL_STATE_TAG 0x74536c47 // "GlSt": Global State. Must be 2nd!
+#define GAME_STATE_TAG   0x74536d47 // "GmSt": Game State Bits. Must be 3rd!
+#define EVENTS_TAG       0x73747645 // "Evts": Events
+#define ENCOUNTERS_TAG   0x74636e45 // "Enct": Encounters
+#define RACE_Q_TAG       0x51636152 // "RacQ": avail_race_q
+#define IP_GRP_Q_TAG     0x51704749 // "IGpQ": ip_group_q
+#define NPC_SHIP_Q_TAG   0x5163704e // "NpcQ": npc_built_ship_q
+#define SHIP_Q_TAG       0x51706853 // "ShpQ": built_ship_q
+#define STAR_TAG         0x72617453 // "Star": STAR_DESC
+#define SCAN_TAG         0x6e616353 // "Scan": Scan Masks (stuff picked up)
+#define BATTLE_GROUP_TAG 0x70477442 // "BtGp": Battle Group definition
+#define GROUP_LIST_TAG   0x73707247 // "Grps": Group List
+
+typedef struct
+{
+	SIS_STATE SS;
+	BYTE Activity;
+	BYTE Flags;
+	BYTE day_index, month_index;
+	COUNT year_index;
+	BYTE MCreditLo, MCreditHi;
+	BYTE NumShips, NumDevices;
+	BYTE ShipList[MAX_BUILT_SHIPS];
+	BYTE DeviceList[MAX_EXCLUSIVE_DEVICES];
+	UNICODE SaveName[SAVE_NAME_SIZE];
+	BYTE res_factor;	// JMS: Stores resolution factor to enable saving/loading from different res modes.
+} SUMMARY_DESC;
+
+extern ACTIVITY NextActivity;
+
+extern BOOLEAN LoadGame (COUNT which_game, SUMMARY_DESC *summary_desc);
+extern BOOLEAN LoadLegacyGame (COUNT which_game, SUMMARY_DESC *summary_desc);
+
 extern void SaveProblem (void);
-extern BOOLEAN SaveGame (COUNT which_game, SUMMARY_DESC *summary_desc);
+extern BOOLEAN SaveGame (COUNT which_game, SUMMARY_DESC *summary_desc, const char *name);
+
+extern const GameStateBitMap gameStateBitMap[];
+
+#if defined(__cplusplus)
+}
+#endif
 
 #endif  /* _SAVE_H */
 
diff -ruNp src.hd/uqm/settings.h src/uqm/settings.h
--- src.hd/uqm/settings.h	2017-12-29 02:25:53 -0800
+++ src/uqm/settings.h	2017-12-29 00:57:50 -0800
@@ -19,6 +19,10 @@
 
 #include "libs/sndlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern void ToggleMusic (void);
 extern void StopMusic (void);
 extern void ResumeMusic (void);
@@ -30,5 +34,9 @@ extern void PlaySoundEffect (SOUND S, CO
 		void *PositionalObject, BYTE Priority);
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _SETTINGS_H */
 
diff -ruNp src.hd/uqm/setup.c src/uqm/setup.c
--- src.hd/uqm/setup.c	2017-12-29 02:25:53 -0800
+++ src/uqm/setup.c	2017-12-29 00:57:50 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "setup.h"
 
 #include "coderes.h"
@@ -61,28 +59,35 @@ FRAME Screen;
 FONT StarConFont;
 FONT MicroFont;
 FONT TinyFont;
+FONT PlyrFont;
 QUEUE race_q[NUM_PLAYERS];
 FRAME ActivityFrame;
 FRAME StatusFrame;
-FRAME SubmenuStarmapKeysFrame;
+FRAME SubmenuFrame;
 FRAME ConstellationsFrame; // JMS
 FRAME hyperspacesuns; // BW
 FRAME NebulaeFrame; // JMS
 FRAME FlagStatFrame;
 FRAME MiscDataFrame;
 FRAME FontGradFrame;
-Mutex GraphicsLock;
 STRING GameStrings;
 QUEUE disp_q;
-BOOLEAN hires2xPackPresent; // JMS_GFX
-BOOLEAN hires4xPackPresent; // JMS_GFX
-BOOLEAN rmxGraphicsPresent; // Serosis
-BOOLEAN seroSetupPresent; // Serosis
-BOOLEAN seroMenuPresent; // Serosis
+// Serosis
+BOOLEAN solTexturesPresent;
+BOOLEAN seroNebulaePresent;
+BOOLEAN seroMenuPresent;
+// JMS_GFX
+BOOLEAN hires2xPackPresent;
+BOOLEAN hires4xPackPresent;
+BOOLEAN comingFromInit;
+BYTE Rando;
 
 uio_Repository *repository;
 uio_DirHandle *rootDir;
 
+BOOLEAN usingSpeech;
+
+
 static void
 InitPlayerInput (void)
 {
@@ -116,95 +121,73 @@ LoadKernel (int argc, char *argv[])
 	SetContextOrigin (MAKE_POINT (0, 0));
 
 	hResIndex = (RESOURCE_INDEX) InitResourceSystem ();
-	if (hResIndex == 0){
+	if (hResIndex == 0)
 		return FALSE;
-	}
+	
 	/* Load base content. */
-	if (loadIndices (contentDir) == 0){
+	if (loadIndices (contentDir) == 0)
 		return FALSE; // Must have at least one index in content dir
-	}
+
 	/* Load addons demanded by the current configuration. */
-	if (opt3doMusic){
-		loadAddon ("3domusic");
-	}
-	/* Always try to use voice data */
-	if (!loadAddon ("3dovoice")){
-		speechVolumeScale = 0.0f; // XXX: need better no-speech indicator
-	} else {		
-		loadAddon("rmx-shofixti");
-		loadAddon("rmx-subtitle");
-		loadAddon("rmx-utwig");
-		loadAddon("MelnormeVoiceFix"); // Autoload support for Soul Reaver's Melnorme dialog fix
-	}
-	if (optRemixMusic){
-		loadAddon ("remix");
-	}
 
-	// A neat 'switch' instead of a boring if, then, else pyramid - Serosis
 	switch (resolutionFactor) {
 		case 1:
 			if(loadAddon ("hires2x")){
 				hires2xPackPresent = TRUE;
 				log_add (log_Debug, "loading addon hires2x");
-				if(loadAddon("rmx-graphics-2x")){
-					rmxGraphicsPresent = TRUE;
-					printf("Loading RMX-Graphics 2x\n");
-					log_add (log_Debug, "loading rmx-graphics-2x");
-				}
-				if(loadAddon("sero-menu-2x")){
-					seroMenuPresent = TRUE;
-					printf("Loading Sero-Menu 2x\n");
-					log_add (log_Debug, "loading sero-menu-2x");
+				if(loadAddon("sol-textures-2x")){
+					solTexturesPresent = TRUE;
+					printf("Loading Sol Textures \n");
+					log_add (log_Debug, "loading sol-textures-2x");
 				}
-				loadAddon("Syreen2xVideoFix"); // Autoload support for Soul Reaver's Syreen video fix
+				loadAddon("alt-kohr-2x");
 			}
 			break;
 		case 2:
 			if(loadAddon ("hires4x")){
 				hires4xPackPresent = TRUE;
 				log_add (log_Debug, "loading addon hires4x");
-				if(loadAddon("rmx-graphics-4x")){
-					rmxGraphicsPresent = TRUE;
-					printf("Loading RMX-Graphics 4x\n");
-					log_add (log_Debug, "loading rmx-graphics-4x");
+				if(loadAddon("sol-textures-4x")){
+					solTexturesPresent = TRUE;
+					printf("Loading Sol Textures \n");
+					log_add (log_Debug, "loading sol-textures-4x");
 				}
-				if(loadAddon("sero-menu-4x")){
-					seroMenuPresent = TRUE;
-					printf("Loading Sero-Menu 4x\n");
-					log_add (log_Debug, "loading sero-menu-4x");
-				}
-				loadAddon("Syreen4xVideoFix"); // Autoload support for Soul Reaver's Syreen video fix
+				loadAddon("alt-kohr-4x");
 			}
 			break;
+		case 0:
 		default:
-			if(loadAddon("vux-fix-1x")){
-				printf("Loading Vux-Fix 1x\n");
-				log_add (log_Debug, "loading vux-fix-1x");
-			}
-			if(loadAddon("rmx-graphics-1x")){
-				rmxGraphicsPresent = TRUE;
-				printf("Loading RMX-Graphics 1x\n");
-				log_add (log_Debug, "loading rmx-graphics-1x");
-			}
-			if(loadAddon("sero-menu-1x")){
-				seroMenuPresent = TRUE;
-				printf("Loading Sero-Menu 1x\n");
-				log_add (log_Debug, "loading sero-menu-1x");
+			if(loadAddon("sol-textures-1x")){
+				solTexturesPresent = TRUE;
+				printf("Loading Sol Textures \n");
+				log_add (log_Debug, "loading sol-textures-1x");
 			}
 			break;
 	}
 
-	if (optWhichIntro == OPT_3DO){
-		loadAddon ("3dovideo"); // Put this here to override the PC slides if enabled
+	if (opt3doMusic)
+	{
+		loadAddon ("3domusic");
 	}
 
-	if(loadAddon("sero-setup-hd")){
-		seroSetupPresent = TRUE;
-		printf("Loading Sero Setup HD\n");
-		log_add (log_Debug, "loading sero-setup-hd\n");
+	usingSpeech = optSpeech;
+	if (optSpeech && !loadAddon ("3dovoice")) {
+		usingSpeech = FALSE;
 	} else {
-		log_add (log_Fatal, "\nPANIC: Sero Setup HD not found in addons directory!\n");
-		exit (EXIT_FAILURE);
+		loadAddon("rmx-shofixti");
+		loadAddon("rmx-utwig");
+		// Autoload support for Soul Reaver's dialog fixes
+		loadAddon("MelnormeVoiceFix");
+	}
+
+	if (optRemixMusic)
+	{
+		loadAddon ("remix");
+	}
+
+	if (optWhichIntro == OPT_3DO)
+	{
+		loadAddon ("3dovideo");
 	}
 
 	/* Now load the rest of the addons, in order. */
@@ -273,6 +256,10 @@ InitKernel (void)
 	if (TinyFont == NULL)
 		return FALSE;
 
+	PlyrFont = LoadFont (PLAYER_FONT);
+	if (PlyrFont == NULL)
+		return FALSE;
+
 	ActivityFrame = CaptureDrawable (LoadGraphic (ACTIVITY_ANIM));
 	if (ActivityFrame == NULL)
 		return FALSE;
@@ -282,14 +269,14 @@ InitKernel (void)
 		return FALSE;
 	
 	// JMS: Animated hyperspace suns.
-	hyperspacesuns = CaptureDrawable (LoadGraphic (HYPERSUNS_MASK_PMAP_ANIM));
-	if (hyperspacesuns == NULL)
-		return FALSE;
+	if (hires4xPackPresent || hires2xPackPresent) { 
+		hyperspacesuns = CaptureDrawable (LoadGraphic (HYPERSUNS_MASK_PMAP_ANIM));
+		if (hyperspacesuns == NULL)
+			return FALSE;
+	}
 
-	// No longer have to do an ugly content check here, yay!
-	printf("Loading Nebulae\n"); // JMS: Background nebulae in IP.
 	NebulaeFrame = CaptureDrawable (LoadGraphic (NEBULAE_PMAP_ANIM));
-	if (NebulaeFrame == NULL)
+	if (NebulaeFrame == NULL || !NebulaeFrame)
 		return FALSE;
 		
 	// JMS: Constellation lines for the constellation starmap.
@@ -298,8 +285,8 @@ InitKernel (void)
 		return FALSE;
 		
 	// JMS: This is a table of mineral values that will be shown on the status bar.
-	SubmenuStarmapKeysFrame = CaptureDrawable (LoadGraphic (SUBMENUSTARMAPKEYS_MASK_PMAP_ANIM));
-	if (SubmenuStarmapKeysFrame == NULL)
+	SubmenuFrame = CaptureDrawable (LoadGraphic (SUBMENU_MASK_PMAP_ANIM));
+	if (SubmenuFrame == NULL)
 		return FALSE;
 
 	GameStrings = CaptureStringTable (LoadStringTable (STARCON_GAME_STRINGS));
diff -ruNp src.hd/uqm/setup.h src/uqm/setup.h
--- src.hd/uqm/setup.h	2017-12-29 02:25:53 -0800
+++ src/uqm/setup.h	2017-12-29 00:57:50 -0800
@@ -14,8 +14,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #ifndef _SETUP_H
 #define _SETUP_H
 
@@ -26,12 +24,16 @@
 #include "libs/gfxlib.h"
 #include "libs/threadlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern RESOURCE_INDEX hResIndex;
 
 extern FRAME Screen;
 extern FRAME ActivityFrame;
 extern FRAME StatusFrame;
-extern FRAME SubmenuStarmapKeysFrame; // JMS
+extern FRAME SubmenuFrame; // JMS
 extern FRAME ConstellationsFrame; // JMS
 extern FRAME NebulaeFrame;	// JMS
 extern FRAME hyperspacesuns;	// BW
@@ -52,24 +54,30 @@ extern SIZE screen_width, screen_height;
 extern FONT StarConFont;
 extern FONT MicroFont;
 extern FONT TinyFont;
+extern FONT PlyrFont;
 
-extern Mutex GraphicsLock;
 extern CondVar RenderingCond;
 
 extern QUEUE race_q[];
 		/* Array of lists of ships involved in a battle, one queue per side;
 		 * queue element is STARSHIP */
 
+// Serosis
+extern BOOLEAN solTexturesPresent;
+extern BOOLEAN seroNebulaePresent;
 extern BOOLEAN hires2xPackPresent; // JMS
 extern BOOLEAN hires4xPackPresent; // JMS
-extern BOOLEAN rmxGraphicsPresent; // Serosis
-extern BOOLEAN seroSetupPresent; // Serosis
-extern BOOLEAN seroMenuPresent; // Serosis
+extern BOOLEAN comingFromInit;
+extern BYTE Rando;
 
 extern ACTIVITY LastActivity;
 
 extern BYTE PlayerControl[];
 
+extern BOOLEAN usingSpeech;
+		// Actual speech presence indicator which decouples reality from
+		// the user option, thus the user option remains as pure intent
+
 BOOLEAN InitContexts (void);
 void UninitPlayerInput (void);
 BOOLEAN InitGameKernel (void);
@@ -87,6 +95,10 @@ void ClearPlayerInput (COUNT playerI);
 void ClearPlayerInputAll (void);
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _SETUP_H */
 
 
diff -ruNp src.hd/uqm/setupmenu.c src/uqm/setupmenu.c
--- src.hd/uqm/setupmenu.c	2017-12-29 02:25:53 -0800
+++ src/uqm/setupmenu.c	2017-12-29 00:57:50 -0800
@@ -16,12 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS 2011: Originally, the smooth zoom was TFB_SCALE_TRILINEAR instead of bilinear.
-// Using bilinear alleviates the smooth zoom performance choppiness problems in 2x and 4x, but
-// is kinda hacky solution...
-
-// JMS_GFX 2012: Merged resolution Factor stuff from P6014.
-
 #include "setupmenu.h"
 
 #include "controls.h"
@@ -43,16 +37,16 @@
 #include "libs/memlib.h"
 #include "resinst.h"
 #include "nameref.h"
-
+#include <math.h>
 #include "gamestr.h"
-
 #include "libs/graphics/bbox.h"
 
+
 static STRING SetupTab;
 
 typedef struct setup_menu_state {
 	BOOLEAN (*InputFunc) (struct setup_menu_state *pInputState);
-	
+
 	BOOLEAN initialized;
 	int anim_frame_count;
 	DWORD NextTime;
@@ -67,7 +61,7 @@ static int quit_sub_menu (WIDGET *self,
 static int do_graphics (WIDGET *self, int event);
 static int do_audio (WIDGET *self, int event);
 static int do_engine (WIDGET *self, int event);
-static int do_resources (WIDGET *self, int event);
+static int do_cheats (WIDGET *self, int event);
 static int do_keyconfig (WIDGET *self, int event);
 static int do_advanced (WIDGET *self, int event);
 static int do_editkeys (WIDGET *self, int event);
@@ -77,14 +71,14 @@ static void rebind_control (WIDGET_CONTR
 static void clear_control (WIDGET_CONTROLENTRY *widget);
 
 #ifdef HAVE_OPENGL
-#define RES_OPTS 3 // JMS_GFX was 4
+#define RES_OPTS 3
 #else
-#define RES_OPTS 3 // JMS_GFX was 2
+#define RES_OPTS 3
 #endif
 
 #define MENU_COUNT          8
-#define CHOICE_COUNT       38 // JMS: New options added.
-#define SLIDER_COUNT        3
+#define CHOICE_COUNT       46
+#define SLIDER_COUNT        4
 #define BUTTON_COUNT       10
 #define LABEL_COUNT         4
 #define TEXTENTRY_COUNT     1
@@ -103,91 +97,110 @@ static WIDGET_CONTROLENTRY controlentrie
 
 typedef int (*HANDLER)(WIDGET *, int);
 
+// Each number corresponds to a choice widget in order starting from choices[0]
+// The value determines how many columns the choice has.
 static int choice_widths[CHOICE_COUNT] = {
 	3, 2, 3, 2, 2, 2, 2, 2, 2, 2, 
 	2, 2, 2, 2, 2, 3, 3, 2,	3, 3, 
-	3, 2, 3, 2, 2, 2, 2, 2, 2, 2,
-	3, 2, 2, 2, 2, 2, 2, 2};
+	3, 2, 2, 2, 
+	2, 2, 3, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 3, 2, 2, 2, 2, 3,
+	2, 2 };
 
 static HANDLER button_handlers[BUTTON_COUNT] = {
 	quit_main_menu, quit_sub_menu, do_graphics, do_engine,
-	do_audio, do_resources, do_keyconfig, do_advanced, do_editkeys, 
+	do_audio, do_cheats, do_keyconfig, do_advanced, do_editkeys, 
 	do_keyconfig };
 
-// JMS: The second 8 was 9 - removed one since the pulsating slave shield is removed.
-// JMS: The first 8 was 7 (sound options.) Added mainmenumusic on/off.
-// JMS: The HAVE_OPENGL options were 5 and 4. Added cheatMode, mineralSubmenu, nebulae and planet options.
-static int menu_sizes[MENU_COUNT] = {
-	7, 6, 8, 8, 11, 5,
-#ifdef HAVE_OPENGL
-	9,
-#else
-	8,
-#endif
-	11
-};
-
-static int menu_bgs[MENU_COUNT] = { 0, 1, 1, 2, 3, 1, 2, 1 };
-
 /* These refer to uninitialized widgets, but that's OK; we'll fill
  * them in before we touch them */
 static WIDGET *main_widgets[] = {
-	(WIDGET *)(&buttons[2]),
-	(WIDGET *)(&buttons[3]),
-	(WIDGET *)(&buttons[4]),
-	(WIDGET *)(&buttons[5]),
-	(WIDGET *)(&buttons[6]),
-	(WIDGET *)(&buttons[7]),
-	(WIDGET *)(&buttons[0]) };
+	(WIDGET *)(&buttons[2]),	// Graphics
+	(WIDGET *)(&buttons[3]),	// PC/3DO Compat Options
+	(WIDGET *)(&buttons[4]),	// Sound
+	(WIDGET *)(&buttons[5]),	// Cheats
+	(WIDGET *)(&buttons[6]),	// Controls
+	(WIDGET *)(&buttons[7]),	// Advanced
+	(WIDGET *)(&buttons[0]),	// Quit Setup Menu
+	NULL };
 
 static WIDGET *graphics_widgets[] = {
-	(WIDGET *)(&choices[0]),
-	(WIDGET *)(&choices[22]), // JMS: lores blowup
-	(WIDGET *)(&choices[10]),
-	(WIDGET *)(&choices[2]),
-	(WIDGET *)(&choices[3]),
-	(WIDGET *)(&buttons[1]) };
-
-static WIDGET *audio_widgets[] = {
-	(WIDGET *)(&sliders[0]),
-	(WIDGET *)(&sliders[1]),
-	(WIDGET *)(&sliders[2]),
-	(WIDGET *)(&choices[14]),
-	(WIDGET *)(&choices[9]),
-	(WIDGET *)(&choices[21]),
-	(WIDGET *)(&choices[23]), // JMS: Mainmenumusic on/off
-	(WIDGET *)(&buttons[1]) };
-
-static WIDGET *engine_widgets[] = {
-	(WIDGET *)(&choices[4]),
-	(WIDGET *)(&choices[5]),
-	(WIDGET *)(&choices[6]),
-	(WIDGET *)(&choices[7]),
-	(WIDGET *)(&choices[8]),
-	(WIDGET *)(&choices[13]),
-	(WIDGET *)(&choices[11]),
-	//(WIDGET *)(&choices[17]), // JMS: Removed the pulsating shield
-	(WIDGET *)(&buttons[1]) };
-
-static WIDGET *advanced_widgets[] = {
+	(WIDGET *)(&choices[0]),	// Resolution
+	(WIDGET *)(&choices[43]),	// Scale GFX
 #ifdef HAVE_OPENGL
-	(WIDGET *)(&choices[1]),
+	(WIDGET *)(&choices[1]),	// Use Framebuffer
 #endif
-	(WIDGET *)(&choices[12]),
-	(WIDGET *)(&choices[15]),
-	(WIDGET *)(&choices[16]),
-	(WIDGET *)(&choices[24]), // JMS: mineralSubmenu on/off
-	(WIDGET *)(&choices[25]), // JMS: IP nebulae on/off
-	(WIDGET *)(&choices[26]), // JMS: rotatingIpPlanets on/off
-	(WIDGET *)(&choices[27]), // JMS: texturedIpPlanets on/off
-	(WIDGET *)(&buttons[1]) };
+	(WIDGET *)(&choices[23]),	// Aspect Ratio
+	(WIDGET *)(&choices[10]),	// Display
+	(WIDGET *)(&sliders[3]),	// Gamma Correction
+	(WIDGET *)(&choices[2]),	// Scaler
+	(WIDGET *)(&choices[3]),	// Scanlines	
+	(WIDGET *)(&choices[12]),	// Show FPS
+	(WIDGET *)(&buttons[1]),
+	NULL };
+
+static WIDGET *engine_widgets[] = {
+	(WIDGET *)(&choices[4]),	// Menu Style
+	(WIDGET *)(&choices[5]),	// Font Style
+	(WIDGET *)(&choices[6]),	// Scan Style
+	(WIDGET *)(&choices[7]),	// Scroll Style
+	(WIDGET *)(&choices[8]),	// Subtitles
+	(WIDGET *)(&choices[13]),	// Melee Zoom
+	(WIDGET *)(&choices[11]),	// Cutscenes
+	(WIDGET *)(&choices[33]),	// Extra Cutscenes
+	(WIDGET *)(&choices[17]),	// Slave Shields
+	(WIDGET *)(&choices[32]),	// Skip Intro
+	(WIDGET *)(&buttons[1]),
+	NULL };
 
+static WIDGET *audio_widgets[] = {
+	(WIDGET *)(&sliders[0]),	// Music Volume
+	(WIDGET *)(&sliders[1]),	// SFX Volume
+	(WIDGET *)(&sliders[2]),	// Speech Volume
+	(WIDGET *)(&choices[14]),	// Positional Audio	
+	(WIDGET *)(&choices[15]),	// Sound Driver
+	(WIDGET *)(&choices[16]),	// Sound Quality
+	(WIDGET *)(&choices[9]),	// 3DO Remixes
+	(WIDGET *)(&choices[21]),	// Precursor's Remixes
+	(WIDGET *)(&choices[22]),	// Speech
+	(WIDGET *)(&choices[34]),	// JMS: Main Menu Music
+	(WIDGET *)(&buttons[1]),
+	NULL };
+
+static WIDGET *cheat_widgets[] = {
+	(WIDGET *)(&choices[24]), // JMS: cheatMode on/off
+	// Serosis
+	(WIDGET *)(&choices[25]),	// God Mode
+	(WIDGET *)(&choices[26]),	// Time Dilation
+	(WIDGET *)(&choices[27]),	// Bubble Warp
+	(WIDGET *)(&choices[28]),	// Unlock Ships
+	(WIDGET *)(&choices[29]),	// Head Start
+	(WIDGET *)(&choices[30]),	// Unlock Upgrades
+	(WIDGET *)(&choices[31]),	// Infinite RU
+	(WIDGET *)(&choices[39]),	// Infinite Fuel
+	(WIDGET *)(&choices[44]),	// Add Devices
+	(WIDGET *)(&buttons[1]),	// Exit to Menu
+	NULL };
+	
 static WIDGET *keyconfig_widgets[] = {
-	(WIDGET *)(&choices[18]),
-	(WIDGET *)(&choices[19]),
+	(WIDGET *)(&choices[18]),	// Bottom Player
+	(WIDGET *)(&choices[19]),	// Top Player
 	(WIDGET *)(&labels[1]),
-	(WIDGET *)(&buttons[8]),
-	(WIDGET *)(&buttons[1]) };
+	(WIDGET *)(&buttons[8]),	// Edit Controls
+	(WIDGET *)(&buttons[1]),
+	NULL };
+
+static WIDGET *advanced_widgets[] = {
+	(WIDGET *)(&choices[35]),	// JMS: IP nebulae on/off
+	(WIDGET *)(&choices[36]),	// JMS: orbitingPlanets on/off
+	(WIDGET *)(&choices[37]),	// JMS: texturedPlanets on/off
+	(WIDGET *)(&choices[45]),	// Serosis: Scaled Planets
+	(WIDGET *)(&choices[38]),	// Nic: Switch date formats
+	(WIDGET *)(&choices[40]),	// Serosis: Thraddash Story switch
+	(WIDGET *)(&choices[41]),	// Serosis: Partial Pickup switch
+	(WIDGET *)(&choices[42]),	// Serosis: Submenu switch
+	(WIDGET *)(&buttons[1]),
+	NULL };
 
 static WIDGET *editkeys_widgets[] = {
 	(WIDGET *)(&choices[20]),
@@ -200,24 +213,38 @@ static WIDGET *editkeys_widgets[] = {
 	(WIDGET *)(&controlentries[4]),
 	(WIDGET *)(&controlentries[5]),
 	(WIDGET *)(&controlentries[6]),
-	(WIDGET *)(&buttons[9]) };
+	(WIDGET *)(&buttons[9]),
+	NULL };
+
+static const struct
+{
+	WIDGET **widgets;
+	int bgIndex;
+}
+menu_defs[] =
+{
+	{main_widgets, 0},
+	{graphics_widgets, 1},
+	{audio_widgets, 2},
+	{engine_widgets, 3},
+	{cheat_widgets, 4},
+	{keyconfig_widgets, 5},
+	{advanced_widgets, 6},
+	{editkeys_widgets, 7},
+	{NULL, 0}
+};
+
+// Start with reasonable gamma bounds. These will get updated
+// as we find out the actual bounds.
+static float minGamma = 0.4f;
+static float maxGamma = 2.5f;
+// The gamma slider uses an exponential curve
+// We use y = e^(2.1972*(x-1)) curve to give us a nice spread of
+// gamma values 0.11 < g < 9.0 centered at g=1.0
+#define GAMMA_CURVE_B  2.1972f
+static float minGammaX;
+static float maxGammaX;
 
-static WIDGET *incomplete_widgets[] = {
-	(WIDGET *)(&choices[28]), // JMS: cheatMode on/off
-	(WIDGET *)(&choices[29]), // God Mode
-	(WIDGET *)(&choices[30]), // Time Dilation
-	(WIDGET *)(&choices[31]), // Bubble Warp
-	(WIDGET *)(&choices[32]), // Unlock Ships
-	(WIDGET *)(&choices[33]), // Head Start
-	(WIDGET *)(&choices[34]), // Unlock Upgrades
-	(WIDGET *)(&choices[35]), // Infinite RU
-	(WIDGET *)(&choices[36]), // Skip Intro
-	(WIDGET *)(&choices[37]), // FMV
-	(WIDGET *)(&buttons[1]) };
-
-static WIDGET **menu_widgets[MENU_COUNT] = {
-	main_widgets, graphics_widgets, audio_widgets, engine_widgets, 
-	incomplete_widgets, keyconfig_widgets, advanced_widgets, editkeys_widgets };
 
 static int
 quit_main_menu (WIDGET *self, int event)
@@ -284,7 +311,7 @@ do_engine (WIDGET *self, int event)
 }
 
 static int
-do_resources (WIDGET *self, int event)
+do_cheats (WIDGET *self, int event)
 {
 	if (event == WIDGET_EVENT_SELECT)
 	{
@@ -323,18 +350,18 @@ do_advanced (WIDGET *self, int event)
 }
 
 static void
-populate_editkeys (int templates)
+populate_editkeys (int templat)
 {
 	int i, j;
 	
-	strncpy (textentries[0].value, input_templates[templates].name, textentries[0].maxlen);
+	strncpy (textentries[0].value, input_templates[templat].name, textentries[0].maxlen);
 	textentries[0].value[textentries[0].maxlen-1] = 0;
 	
 	for (i = 0; i < NUM_KEYS; i++)
 	{
 		for (j = 0; j < 2; j++)
 		{
-			InterrogateInputState (templates, i, j, controlentries[i].controlname[j], WIDGET_CONTROLENTRY_WIDTH);
+			InterrogateInputState (templat, i, j, controlentries[i].controlname[j], WIDGET_CONTROLENTRY_WIDTH);
 		}
 	}
 }
@@ -367,10 +394,10 @@ static void
 rename_template (WIDGET_TEXTENTRY *self)
 {
 	/* TODO: This will have to change if the size of the
-	 input_templates name is changed.  It would probably be nice
-	 to track this symbolically or ensure that self->value's
-	 buffer is always at least this big; this will require some
-	 reworking of widgets */
+	   input_templates name is changed.  It would probably be nice
+	   to track this symbolically or ensure that self->value's
+	   buffer is always at least this big; this will require some
+	   reworking of widgets */
 	strncpy (input_templates[choices[20].selected].name, self->value, 30);
 	input_templates[choices[20].selected].name[29] = 0;
 }
@@ -386,15 +413,15 @@ SetDefaults (void)
 	GLOBALOPTS opts;
 	
 	GetGlobalOptions (&opts);
-	/*if (opts.res == OPTVAL_CUSTOM)
-	 {
-	 choices[0].numopts = RES_OPTS + 1;
-	 }
-	 else
-	 {*/
-	choices[0].numopts = RES_OPTS;
+	/*if (opts.screenResolution == OPTVAL_CUSTOM)
+	{
+		choices[0].numopts = RES_OPTS + 1;
+	}
+	else
+	{*/
+		choices[0].numopts = RES_OPTS;
 	//}
-	choices[0].selected = opts.res;
+	choices[0].selected = opts.screenResolution;
 	choices[1].selected = opts.driver;
 	choices[2].selected = opts.scaler;
 	choices[3].selected = opts.scanlines;
@@ -416,32 +443,47 @@ SetDefaults (void)
 	choices[19].selected = opts.player2;
 	choices[20].selected = 0;
 	choices[21].selected = opts.musicremix;
-	choices[22].selected = opts.loresBlowup; // JMS
-	choices[23].selected = opts.mainmenuMusic; // JMS
-	choices[24].selected = opts.mineralSubmenu; // JMS
-	choices[25].selected = opts.nebulae; // JMS
-	choices[26].selected = opts.rotatingIpPlanets; // JMS
-	choices[27].selected = opts.texturedIpPlanets || opts.rotatingIpPlanets; // JMS
-	choices[28].selected = opts.cheatMode; // JMS
-	choices[29].selected = opts.godMode; // Serosis
-	choices[30].selected = opts.tdType; // Serosis
-	choices[31].selected = opts.bubbleWarp; // Serosis
-	choices[32].selected = opts.unlockShips; // Serosis
-	choices[33].selected = opts.headStart; // Serosis
-	choices[34].selected = opts.unlockUpgrades; // Serosis
-	choices[35].selected = opts.infiniteRU; // Serosis
-	choices[36].selected = opts.skipIntro; // Serosis
-	choices[37].selected = opts.FMV; // Serosis
+	choices[22].selected = opts.speech;
+	choices[23].selected = opts.keepaspect;
+
+ 	choices[24].selected = opts.cheatMode; // JMS	
+	// Serosis
+	choices[25].selected = opts.godMode;
+	choices[26].selected = opts.tdType;
+	choices[27].selected = opts.bubbleWarp;
+	choices[28].selected = opts.unlockShips;
+	choices[29].selected = opts.headStart;
+	choices[30].selected = opts.unlockUpgrades;
+	choices[31].selected = opts.infiniteRU;
+	choices[32].selected = opts.skipIntro;
+	choices[33].selected = opts.FMV;
+	// JMS
+	choices[34].selected = opts.mainMenuMusic;
+	choices[35].selected = opts.nebulae;
+	choices[36].selected = opts.orbitingPlanets;
+	choices[37].selected = opts.texturedPlanets;
+	// Nic
+	choices[38].selected = opts.dateType;
+	 // Serosis
+	choices[39].selected = opts.infiniteFuel;
+	choices[40].selected = opts.thraddStory;
+	choices[41].selected = opts.partialPickup;
+	choices[42].selected = opts.submenu;
+	choices[43].selected = opts.loresBlowup; // JMS
+	choices[44].selected = opts.addDevices;
+	choices[45].selected = opts.scalePlanets;
+
 	sliders[0].value = opts.musicvol;
 	sliders[1].value = opts.sfxvol;
 	sliders[2].value = opts.speechvol;
+	sliders[3].value = opts.gamma;
 }
 
 static void
 PropagateResults (void)
 {
 	GLOBALOPTS opts;
-	opts.res = choices[0].selected;
+	opts.screenResolution = choices[0].selected;
 	opts.driver = choices[1].selected;
 	opts.scaler = choices[2].selected;
 	opts.scanlines = choices[3].selected;
@@ -462,26 +504,40 @@ PropagateResults (void)
 	opts.player1 = choices[18].selected;
 	opts.player2 = choices[19].selected;
 	opts.musicremix = choices[21].selected;
-	opts.loresBlowup = choices[22].selected; // JMS
-	opts.mainmenuMusic = choices[23].selected; // JMS
-	opts.mineralSubmenu = choices[24].selected; // JMS
-	opts.nebulae = choices[25].selected; // JMS
-	opts.rotatingIpPlanets = choices[26].selected; // JMS
-	opts.texturedIpPlanets = choices[27].selected || opts.rotatingIpPlanets; // JMS
-	opts.cheatMode = choices[28].selected; // JMS
-	opts.godMode = choices[29].selected; // Serosis
-	opts.tdType = choices[30].selected; // Serosis
-	opts.bubbleWarp = choices[31].selected; // Serosis
-	opts.unlockShips = choices[32].selected; // Serosis
-	opts.headStart = choices[33].selected; // Serosis
-	opts.unlockUpgrades = choices[34].selected; // Serosis
-	opts.infiniteRU = choices[35].selected; // Serosis
-	opts.skipIntro = choices[36].selected; // Serosis
-	opts.FMV = choices[37].selected; // Serosis
-	
+	opts.speech = choices[22].selected;
+	opts.keepaspect = choices[23].selected;
+
+ 	opts.cheatMode = choices[24].selected; // JMS
+	// Serosis
+	opts.godMode = choices[25].selected;
+	opts.tdType = choices[26].selected;
+	opts.bubbleWarp = choices[27].selected;
+	opts.unlockShips = choices[28].selected;
+	opts.headStart = choices[29].selected;
+	opts.unlockUpgrades = choices[30].selected;
+	opts.infiniteRU = choices[31].selected;
+	opts.skipIntro = choices[32].selected;
+	opts.FMV = choices[33].selected;
+	 // JMS
+	opts.mainMenuMusic = choices[34].selected;
+	opts.nebulae = choices[35].selected;
+	opts.orbitingPlanets = choices[36].selected;
+	opts.texturedPlanets = choices[37].selected;
+	// Nic
+	opts.dateType = choices[38].selected;
+	// Serosis
+	opts.infiniteFuel = choices[39].selected;
+	opts.thraddStory = choices[40].selected;
+	opts.partialPickup = choices[41].selected;
+	opts.submenu = choices[42].selected;
+	opts.loresBlowup = choices[43].selected; // JMS
+	opts.addDevices = choices[44].selected;
+	opts.scalePlanets = choices[45].selected;
+
 	opts.musicvol = sliders[0].value;
 	opts.sfxvol = sliders[1].value;
 	opts.speechvol = sliders[2].value;
+	opts.gamma = sliders[3].value;
 	SetGlobalOptions (&opts);
 }
 
@@ -490,16 +546,16 @@ DoSetupMenu (SETUP_MENU_STATE *pInputSta
 {
 	/* Cancel any presses of the Pause key. */
 	GamePaused = FALSE;
-	
+
 	if (!pInputState->initialized) 
 	{
 		SetDefaultMenuRepeatDelay ();
 		pInputState->NextTime = GetTimeCounter ();
 		SetDefaults ();
-		Widget_SetFont (StarConFont);
+		Widget_SetFont (PlyrFont); // Was StarConFont: Switched for better readability
 		Widget_SetWindowColors (SHADOWBOX_BACKGROUND_COLOR,
 				SHADOWBOX_DARK_COLOR, SHADOWBOX_MEDIUM_COLOR);
-		
+
 		current = NULL;
 		next = (WIDGET *)(&menus[0]);
 		(*next->receiveFocus) (next, WIDGET_EVENT_DOWN);
@@ -513,15 +569,15 @@ DoSetupMenu (SETUP_MENU_STATE *pInputSta
 	
 	BatchGraphics ();
 	(*next->draw)(next, 0, 0);
-	
+
 	if (current != next)
 	{
 		ScreenTransition (3, NULL);
 		current = next;
 	}
-	
+
 	UnbatchGraphics ();
-	
+
 	if (PulsedInputState.menu[KEY_MENU_UP])
 	{
 		Widget_Event (WIDGET_EVENT_UP);
@@ -550,11 +606,11 @@ DoSetupMenu (SETUP_MENU_STATE *pInputSta
 	{
 		Widget_Event (WIDGET_EVENT_DELETE);
 	}
-	
+
 	SleepThreadUntil (pInputState->NextTime + MENU_FRAME_RATE);
 	pInputState->NextTime = GetTimeCounter ();
 	return !((GLOBAL (CurrentActivity) & CHECK_ABORT) || 
-			 (next == NULL));
+		 (next == NULL));
 }
 
 static void
@@ -569,7 +625,7 @@ static BOOLEAN
 OnTextEntryChange (TEXTENTRY_STATE *pTES)
 {
 	WIDGET_TEXTENTRY *widget = (WIDGET_TEXTENTRY *) pTES->CbParam;
-	
+
 	widget->cursor_pos = pTES->CursorPos;
 	if (pTES->JoystickMode)
 		widget->state |= WTE_BLOCKCUR;
@@ -587,10 +643,10 @@ static BOOLEAN
 OnTextEntryFrame (TEXTENTRY_STATE *pTES)
 {
 	redraw_menu ();
-	
+
 	SleepThreadUntil (pTES->NextTime);
 	pTES->NextTime = GetTimeCounter () + MENU_FRAME_RATE;
-	
+
 	return TRUE; // continue
 }
 
@@ -599,15 +655,15 @@ OnTextEntryEvent (WIDGET_TEXTENTRY *widg
 {	// Going to edit the text
 	TEXTENTRY_STATE tes;
 	UNICODE revert_buf[256];
-	
+
 	// position cursor at the end of text
 	widget->cursor_pos = utf8StringCount (widget->value);
 	widget->state = WTE_EDITING;
 	redraw_menu ();
-	
+
 	// make a backup copy for revert on cancel
 	utf8StringCopy (revert_buf, sizeof (revert_buf), widget->value);
-	
+
 	// text entry setup
 	tes.Initialized = FALSE;
 	tes.NextTime = GetTimeCounter () + MENU_FRAME_RATE;
@@ -617,7 +673,7 @@ OnTextEntryEvent (WIDGET_TEXTENTRY *widg
 	tes.CbParam = widget;
 	tes.ChangeCallback = OnTextEntryChange;
 	tes.FrameCallback = OnTextEntryFrame;
-	
+
 	SetMenuSounds (MENU_SOUND_NONE, MENU_SOUND_SELECT);
 	if (!DoTextEntry (&tes))
 	{	// editing failed (canceled) -- revert the changes
@@ -631,38 +687,177 @@ OnTextEntryEvent (WIDGET_TEXTENTRY *widg
 		}
 	}
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
-	
+
 	widget->state = WTE_NORMAL;
 	redraw_menu ();
-	
+
 	return TRUE; // event handled
 }
 
+static inline float
+gammaCurve (float x)
+{
+	// The slider uses an exponential curve
+	return exp ((x - 1) * GAMMA_CURVE_B);
+}
+
+static inline float
+solveGammaCurve (float y)
+{
+	return log (y) / GAMMA_CURVE_B + 1;
+}
+
+static int
+gammaToSlider (float gamma)
+{
+	const float x = solveGammaCurve (gamma);
+	const float step = (maxGammaX - minGammaX) / 100;
+	return (int) ((x - minGammaX) / step + 0.5);
+}
+
+static float
+sliderToGamma (int value)
+{
+	const float step = (maxGammaX - minGammaX) / 100;
+	const float x = minGammaX + step * value;
+	const float g = gammaCurve (x);
+	// report any value that is close enough as 1.0
+	return (fabs (g - 1.0f) < 0.001f) ? 1.0f : g;
+}
+
+static void
+updateGammaBounds (bool useUpper)
+{
+	float g, x;
+	int slider;
+	
+	// The slider uses an exponential curve.
+	// Calculate where on the curve the min and max gamma values are
+	minGammaX = solveGammaCurve (minGamma);
+	maxGammaX = solveGammaCurve (maxGamma);
+
+	// We have 100 discrete steps through the range, so the slider may
+	// skip over a 1.0 gamma. We need to ensure that there always is
+	// a 1.0 on the slider by tweaking the range (expanding/contracting).
+	slider = gammaToSlider (1.0f);
+	g = sliderToGamma (slider);
+	if (g == 1.0f)
+		return; // no adjustment needed
+
+	x = solveGammaCurve (g);
+	if (useUpper)
+	{	// Move the upper bound up or down to land on 1.0
+		const float d = (x - 1.0f) * 100 / slider;
+		maxGammaX -= d;
+		maxGamma = gammaCurve (maxGammaX);
+	}
+	else
+	{	// Move the lower bound up or down to land on 1.0
+		const float d = (x - 1.0f) * 100 / (100 - slider);
+		minGammaX -= d;
+		minGamma = gammaCurve (minGammaX);
+	}
+}
+
+static int
+gamma_HandleEventSlider (WIDGET *_self, int event)
+{
+	WIDGET_SLIDER *self = (WIDGET_SLIDER *)_self;
+	int prevValue = self->value;
+	float gamma;
+	bool set;
+
+	switch (event)
+	{
+	case WIDGET_EVENT_LEFT:
+		self->value -= self->step;
+		break;
+	case WIDGET_EVENT_RIGHT:
+		self->value += self->step;
+		break;
+	default:
+		return FALSE;
+	}
+
+	// Limit the slider to values accepted by gfx subsys
+	gamma = sliderToGamma (self->value);
+	set = TFB_SetGamma (gamma);
+	if (!set)
+	{	// revert
+		self->value = prevValue;
+		gamma = sliderToGamma (self->value);
+	}
+
+	// Grow or shrink the range based on accepted values
+	if (gamma < minGamma || (!set && event == WIDGET_EVENT_LEFT))
+	{
+		minGamma = gamma;
+		updateGammaBounds (true);
+		// at the lowest end
+		self->value = 0;
+	}
+	else if (gamma > maxGamma || (!set && event == WIDGET_EVENT_RIGHT))
+	{
+		maxGamma = gamma;
+		updateGammaBounds (false);
+		// at the highest end
+		self->value = 100;
+	}
+	return TRUE;
+}
+
+static void
+gamma_DrawValue (WIDGET_SLIDER *self, int x, int y)
+{
+	TEXT t;
+	char buf[16];
+	float gamma = sliderToGamma (self->value);
+	snprintf (buf, sizeof buf, "%.4f", gamma);
+
+	t.baseline.x = x;
+	t.baseline.y = y;
+	t.align = ALIGN_CENTER;
+	t.CharCount = ~0;
+	t.pStr = buf;
+
+	font_DrawText (&t);
+}
+
 static void
 rebind_control (WIDGET_CONTROLENTRY *widget)
 {
-	int templates = choices[20].selected;
+	int templat = choices[20].selected;
 	int control = widget->controlindex;
 	int index = widget->highlighted;
-	
+
 	FlushInput ();
 	DrawLabelAsWindow (&labels[3], NULL);
-	RebindInputState (templates, control, index);
-	populate_editkeys (templates);
+	RebindInputState (templat, control, index);
+	populate_editkeys (templat);
 	FlushInput ();
 }
 
 static void
 clear_control (WIDGET_CONTROLENTRY *widget)
 {
-	int templates = choices[20].selected;
+	int templat = choices[20].selected;
 	int control = widget->controlindex;
 	int index = widget->highlighted;
-	
-	RemoveInputState (templates, control, index);
-	populate_editkeys (templates);
+      
+	RemoveInputState (templat, control, index);
+	populate_editkeys (templat);
 }	
 
+static int
+count_widgets (WIDGET **widgets)
+{
+	int count;
+
+	for (count = 0; *widgets != NULL; ++widgets, ++count)
+		;
+	return count;
+}
+
 static stringbank *bank = NULL;
 static FRAME setup_frame = NULL;
 
@@ -671,7 +866,7 @@ init_widgets (void)
 {
 	const char *buffer[100], *str, *title;
 	int count, i, index;
-	
+
 	if (bank == NULL)
 	{
 		bank = StringBank_Create ();
@@ -687,24 +882,24 @@ init_widgets (void)
 		if (resolutionFactor > 1)
 			setup_frame = CaptureDrawable (LoadGraphic (MENUBKG_PMAP_ANIM4X));
 	}
-	
+
 	count = GetStringTableCount (SetupTab);
-	
+
 	if (count < 3)
 	{
 		log_add (log_Fatal, "PANIC: Setup string table too short to even hold all indices!");
 		exit (EXIT_FAILURE);
 	}
-	
+
 	/* Menus */
 	title = StringBank_AddOrFindString (bank, GetStringAddress (SetAbsStringTableIndex (SetupTab, 0)));
 	if (SplitString (GetStringAddress (SetAbsStringTableIndex (SetupTab, 1)), '\n', 100, buffer, bank) != MENU_COUNT)
 	{
 		/* TODO: Ignore extras instead of dying. */
-		log_add (log_Fatal, "PANIC: Incorrect number of Menu Subtitles:");
+		log_add (log_Fatal, "PANIC: Incorrect number of Menu Subtitles");
 		exit (EXIT_FAILURE);
 	}
-	
+
 	for (i = 0; i < MENU_COUNT; i++)
 	{
 		menus[i].tag = WIDGET_TYPE_MENU_SCREEN;
@@ -718,19 +913,23 @@ init_widgets (void)
 		menus[i].subtitle = buffer[i];
 		menus[i].bgStamp.origin.x = 0;
 		menus[i].bgStamp.origin.y = 0;
-		menus[i].bgStamp.frame = SetAbsFrameIndex (setup_frame, menu_bgs[i]);
-		menus[i].num_children = menu_sizes[i];
-		menus[i].child = menu_widgets[i];
+		menus[i].bgStamp.frame = SetAbsFrameIndex (setup_frame, menu_defs[i].bgIndex);
+		menus[i].num_children = count_widgets (menu_defs[i].widgets);
+		menus[i].child = menu_defs[i].widgets;
 		menus[i].highlighted = 0;
 	}
-	
+	if (menu_defs[i].widgets != NULL)
+	{
+		log_add (log_Error, "Menu definition array has more items!");
+	}
+		
 	/* Options */
 	if (SplitString (GetStringAddress (SetAbsStringTableIndex (SetupTab, 2)), '\n', 100, buffer, bank) != CHOICE_COUNT)
 	{
 		log_add (log_Fatal, "PANIC: Incorrect number of Choice Options: %d. Should be %d", CHOICE_COUNT, SplitString (GetStringAddress (SetAbsStringTableIndex (SetupTab, 2)), '\n', 100, buffer, bank));
 		exit (EXIT_FAILURE);
 	}
-	
+
 	for (i = 0; i < CHOICE_COUNT; i++)
 	{
 		choices[i].tag = WIDGET_TYPE_CHOICE;
@@ -748,13 +947,13 @@ init_widgets (void)
 		choices[i].maxcolumns = choice_widths[i];
 		choices[i].onChange = NULL;
 	}
-	
+
 	/* Fill in the options now */
 	index = 3;  /* Index into string table */
 	for (i = 0; i < CHOICE_COUNT; i++)
 	{
 		int j, optcount;
-		
+
 		if (index >= count)
 		{
 			log_add (log_Fatal, "PANIC: String table cut short while reading choices");
@@ -774,7 +973,7 @@ init_widgets (void)
 		for (j = 0; j < optcount; j++)
 		{
 			int k, tipcount;
-			
+
 			if (index >= count)
 			{
 				log_add (log_Fatal, "PANIC: String table cut short while reading choices");
@@ -792,10 +991,10 @@ init_widgets (void)
 			}
 		}
 	}
-	
+
 	/* The first choice is resolution, and is handled specially */
 	choices[0].numopts = RES_OPTS;
-	
+
 	/* Choices 18-20 are also special, being the names of the key configurations */
 	for (i = 0; i < 6; i++)
 	{
@@ -803,24 +1002,24 @@ init_widgets (void)
 		choices[19].options[i].optname = input_templates[i].name;
 		choices[20].options[i].optname = input_templates[i].name;
 	}
-	
+
 	/* Choice 20 has a special onChange handler, too. */
 	choices[20].onChange = change_template;
-	
+
 	/* Sliders */
 	if (index >= count)
 	{
 		log_add (log_Fatal, "PANIC: String table cut short while reading sliders");
 		exit (EXIT_FAILURE);
 	}
-	
+
 	if (SplitString (GetStringAddress (SetAbsStringTableIndex (SetupTab, index++)), '\n', 100, buffer, bank) != SLIDER_COUNT)
 	{
 		/* TODO: Ignore extras instead of dying. */
 		log_add (log_Fatal, "PANIC: Incorrect number of Slider Options");
 		exit (EXIT_FAILURE);
 	}
-	
+
 	for (i = 0; i < SLIDER_COUNT; i++)
 	{
 		sliders[i].tag = WIDGET_TYPE_SLIDER;
@@ -840,7 +1039,11 @@ init_widgets (void)
 		sliders[i].tooltip[1] = "";
 		sliders[i].tooltip[2] = "";
 	}
-	
+	// gamma is a special case
+	sliders[3].step = 1;
+	sliders[3].handleEvent = gamma_HandleEventSlider;
+	sliders[3].draw_value = gamma_DrawValue;
+
 	for (i = 0; i < SLIDER_COUNT; i++)
 	{
 		int j, tipcount;
@@ -861,21 +1064,21 @@ init_widgets (void)
 			sliders[i].tooltip[j] = buffer[j];
 		}
 	}
-	
+
 	/* Buttons */
 	if (index >= count)
 	{
 		log_add (log_Fatal, "PANIC: String table cut short while reading buttons");
 		exit (EXIT_FAILURE);
 	}
-	
+
 	if (SplitString (GetStringAddress (SetAbsStringTableIndex (SetupTab, index++)), '\n', 100, buffer, bank) != BUTTON_COUNT)
 	{
 		/* TODO: Ignore extras instead of dying. */
 		log_add (log_Fatal, "PANIC: Incorrect number of Button Options");
 		exit (EXIT_FAILURE);
 	}
-	
+
 	for (i = 0; i < BUTTON_COUNT; i++)
 	{
 		buttons[i].tag = WIDGET_TYPE_BUTTON;
@@ -890,7 +1093,7 @@ init_widgets (void)
 		buttons[i].tooltip[1] = "";
 		buttons[i].tooltip[2] = "";
 	}
-	
+
 	for (i = 0; i < BUTTON_COUNT; i++)
 	{
 		int j, tipcount;
@@ -911,21 +1114,21 @@ init_widgets (void)
 			buttons[i].tooltip[j] = buffer[j];
 		}
 	}
-	
+
 	/* Labels */
 	if (index >= count)
 	{
 		log_add (log_Fatal, "PANIC: String table cut short while reading labels");
 		exit (EXIT_FAILURE);
 	}
-	
+
 	if (SplitString (GetStringAddress (SetAbsStringTableIndex (SetupTab, index++)), '\n', 100, buffer, bank) != LABEL_COUNT)
 	{
 		/* TODO: Ignore extras instead of dying. */
 		log_add (log_Fatal, "PANIC: Incorrect number of Label Options");
 		exit (EXIT_FAILURE);
 	}
-	
+
 	for (i = 0; i < LABEL_COUNT; i++)
 	{
 		labels[i].tag = WIDGET_TYPE_LABEL;
@@ -938,7 +1141,7 @@ init_widgets (void)
 		labels[i].line_count = 0;
 		labels[i].lines = NULL;
 	}
-	
+
 	for (i = 0; i < LABEL_COUNT; i++)
 	{
 		int j, linecount;
@@ -957,14 +1160,14 @@ init_widgets (void)
 			labels[i].lines[j] = buffer[j];
 		}
 	}
-	
+
 	/* Text Entry boxes */
 	if (index >= count)
 	{
 		log_add (log_Fatal, "PANIC: String table cut short while reading text entries");
 		exit (EXIT_FAILURE);
 	}
-	
+
 	if (SplitString (GetStringAddress (SetAbsStringTableIndex (SetupTab, index++)), '\n', 100, buffer, bank) != TEXTENTRY_COUNT)
 	{
 		log_add (log_Fatal, "PANIC: Incorrect number of Text Entries");
@@ -986,13 +1189,13 @@ init_widgets (void)
 		textentries[i].state = WTE_NORMAL;
 		textentries[i].cursor_pos = 0;
 	}
-	
+
 	if (index >= count)
 	{
 		log_add (log_Fatal, "PANIC: String table cut short while reading text entries");
 		exit (EXIT_FAILURE);
 	}
-	
+
 	if (SplitString (GetStringAddress (SetAbsStringTableIndex (SetupTab, index++)), '\n', 100, buffer, bank) != TEXTENTRY_COUNT)
 	{
 		/* TODO: Ignore extras instead of dying. */
@@ -1005,14 +1208,14 @@ init_widgets (void)
 		textentries[i].value[textentries[i].maxlen] = 0;
 	}
 	textentries[0].onChange = rename_template;
-	
+
 	/* Control Entry boxes */
 	if (index >= count)
 	{
 		log_add (log_Fatal, "PANIC: String table cut short while reading control entries");
 		exit (EXIT_FAILURE);
 	}
-	
+
 	if (SplitString (GetStringAddress (SetAbsStringTableIndex (SetupTab, index++)), '\n', 100, buffer, bank) != CONTROLENTRY_COUNT)
 	{
 		log_add (log_Fatal, "PANIC: Incorrect number of Control Entries");
@@ -1035,12 +1238,12 @@ init_widgets (void)
 		controlentries[i].onChange = rebind_control;
 		controlentries[i].onDelete = clear_control;
 	}
-	
+
 	/* Check for garbage at the end */
 	if (index < count)
 	{
 		log_add (log_Warning, "WARNING: Setup strings had %d garbage entries at the end.",
-				 count - index);
+				count - index);
 	}
 }
 
@@ -1048,7 +1251,7 @@ static void
 clean_up_widgets (void)
 {
 	int i;
-	
+
 	for (i = 0; i < CHOICE_COUNT; i++)
 	{
 		if (choices[i].options)
@@ -1056,7 +1259,7 @@ clean_up_widgets (void)
 			HFree (choices[i].options);
 		}
 	}
-	
+
 	for (i = 0; i < LABEL_COUNT; i++)
 	{
 		if (labels[i].lines)
@@ -1064,7 +1267,7 @@ clean_up_widgets (void)
 			HFree ((void *)labels[i].lines);
 		}
 	}
-	
+
 	/* Clear out the master tables */
 	
 	if (SetupTab)
@@ -1088,7 +1291,7 @@ void
 SetupMenu (void)
 {
 	SETUP_MENU_STATE s;
-	
+
 	s.InputFunc = DoSetupMenu;
 	s.initialized = FALSE;
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
@@ -1103,7 +1306,7 @@ SetupMenu (void)
 		exit (EXIT_FAILURE);
 	}
 	done = FALSE;
-	
+
 	DoInput (&s, TRUE);
 	GLOBAL (CurrentActivity) &= ~CHECK_ABORT;
 	PropagateResults ();
@@ -1116,6 +1319,8 @@ SetupMenu (void)
 void
 GetGlobalOptions (GLOBALOPTS *opts)
 {
+	bool whichBound;
+
 	if (GfxFlags & TFB_GFXFLAGS_SCALE_BILINEAR) 
 	{
 		opts->scaler = OPTVAL_BILINEAR_SCALE;
@@ -1141,10 +1346,10 @@ GetGlobalOptions (GLOBALOPTS *opts)
 		opts->scaler = OPTVAL_NO_SCALE;
 	}
 	opts->fullscreen = (GfxFlags & TFB_GFXFLAGS_FULLSCREEN) ?
-	OPTVAL_ENABLED : OPTVAL_DISABLED;
+			OPTVAL_ENABLED : OPTVAL_DISABLED;
 	opts->subtitles = optSubtitles ? OPTVAL_ENABLED : OPTVAL_DISABLED;
 	opts->scanlines = (GfxFlags & TFB_GFXFLAGS_SCANLINES) ? 
-	OPTVAL_ENABLED : OPTVAL_DISABLED;
+		OPTVAL_ENABLED : OPTVAL_DISABLED;
 	opts->menu = (optWhichMenu == OPT_3DO) ? OPTVAL_3DO : OPTVAL_PC;
 	opts->text = (optWhichFonts == OPT_3DO) ? OPTVAL_3DO : OPTVAL_PC;
 	opts->cscan = (optWhichCoarseScan == OPT_3DO) ? OPTVAL_3DO : OPTVAL_PC;
@@ -1152,23 +1357,25 @@ GetGlobalOptions (GLOBALOPTS *opts)
 	opts->intro = (optWhichIntro == OPT_3DO) ? OPTVAL_3DO : OPTVAL_PC;
 	opts->shield = (optWhichShield == OPT_3DO) ? OPTVAL_3DO : OPTVAL_PC;
 	opts->fps = (GfxFlags & TFB_GFXFLAGS_SHOWFPS) ? 
-	OPTVAL_ENABLED : OPTVAL_DISABLED;
+			OPTVAL_ENABLED : OPTVAL_DISABLED;
 	opts->meleezoom = (optMeleeScale == TFB_SCALE_STEP) ? 
-	OPTVAL_PC : OPTVAL_3DO;
+			OPTVAL_PC : OPTVAL_3DO;
 	opts->stereo = optStereoSFX ? OPTVAL_ENABLED : OPTVAL_DISABLED;
 	/* These values are read in, but won't change during a run. */
 	opts->music3do = opt3doMusic ? OPTVAL_ENABLED : OPTVAL_DISABLED;
 	opts->musicremix = optRemixMusic ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->speech = optSpeech ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->keepaspect = optKeepAspectRatio ? OPTVAL_ENABLED : OPTVAL_DISABLED;
 	switch (snddriver) {
-		case audio_DRIVER_OPENAL:
-			opts->adriver = OPTVAL_OPENAL;
-			break;
-		case audio_DRIVER_MIXSDL:
-			opts->adriver = OPTVAL_MIXSDL;
-			break;
-		default:
-			opts->adriver = OPTVAL_SILENCE;
-			break;
+	case audio_DRIVER_OPENAL:
+		opts->adriver = OPTVAL_OPENAL;
+		break;
+	case audio_DRIVER_MIXSDL:
+		opts->adriver = OPTVAL_MIXSDL;
+		break;
+	default:
+		opts->adriver = OPTVAL_SILENCE;
+		break;
 	}
 	if (soundflags & audio_QUALITY_HIGH)
 	{
@@ -1182,16 +1389,44 @@ GetGlobalOptions (GLOBALOPTS *opts)
 	{
 		opts->aquality = OPTVAL_MEDIUM;
 	}
-	
-	// JMS
-	opts->mainmenuMusic = optMainmenuMusic ? OPTVAL_ENABLED : OPTVAL_DISABLED;
-	opts->mineralSubmenu = optMineralSubmenu ? OPTVAL_ENABLED : OPTVAL_DISABLED;
-	opts->nebulae = optNebulae ? OPTVAL_ENABLED : OPTVAL_DISABLED;
-	opts->rotatingIpPlanets = optRotatingIpPlanets ? OPTVAL_ENABLED : OPTVAL_DISABLED;
-	opts->texturedIpPlanets = (optTexturedIpPlanets ? OPTVAL_ENABLED : OPTVAL_DISABLED) || opts->rotatingIpPlanets;
-	opts->cheatMode = optCheatMode ? OPTVAL_ENABLED : OPTVAL_DISABLED;
-	opts->godMode = optGodMode ? OPTVAL_ENABLED : OPTVAL_DISABLED; //Serosis
-	opts->tdType = res_GetInteger ("config.timeDilation");
+
+	/* Work out resolution.  On the way, try to guess a good default
+	 * for config.alwaysgl, then overwrite it if it was set previously. */
+	opts->driver = OPTVAL_PURE_IF_POSSIBLE;
+
+	if (res_IsBoolean ("config.alwaysgl"))
+	{
+		if (res_GetBoolean ("config.alwaysgl"))
+		{
+			opts->driver = OPTVAL_ALWAYS_GL;
+		}
+		else
+		{
+			opts->driver = OPTVAL_PURE_IF_POSSIBLE;
+		}
+	}
+
+	whichBound = (optGamma < maxGamma);
+	// The option supplied by the user may be beyond our starting range
+	// but valid nonetheless. We need to account for that.
+	if (optGamma <= minGamma)
+		minGamma = optGamma - 0.03f;
+	else if (optGamma >= maxGamma)
+		maxGamma = optGamma + 0.3f;
+	updateGammaBounds (whichBound);
+	opts->gamma = gammaToSlider (optGamma);
+
+	opts->player1 = PlayerControls[0];
+	opts->player2 = PlayerControls[1];
+
+	opts->musicvol = (((int)(musicVolumeScale * 100.0f) + 2) / 5) * 5;
+	opts->sfxvol = (((int)(sfxVolumeScale * 100.0f) + 2) / 5) * 5;
+	opts->speechvol = (((int)(speechVolumeScale * 100.0f) + 2) / 5) * 5;
+
+ 	opts->cheatMode = optCheatMode ? OPTVAL_ENABLED : OPTVAL_DISABLED; // JMS
+	// Serosis
+	opts->godMode = optGodMode ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->tdType = res_GetInteger ("cheat.timeDilation");
 	opts->bubbleWarp = optBubbleWarp ? OPTVAL_ENABLED : OPTVAL_DISABLED;
 	opts->unlockShips = optUnlockShips ? OPTVAL_ENABLED : OPTVAL_DISABLED;
 	opts->headStart = optHeadStart ? OPTVAL_ENABLED : OPTVAL_DISABLED;
@@ -1199,22 +1434,32 @@ GetGlobalOptions (GLOBALOPTS *opts)
 	opts->infiniteRU = optInfiniteRU ? OPTVAL_ENABLED : OPTVAL_DISABLED;
 	opts->skipIntro = optSkipIntro ? OPTVAL_ENABLED : OPTVAL_DISABLED;
 	opts->FMV = optFMV ? OPTVAL_ENABLED : OPTVAL_DISABLED;
-	
-	/* Work out resolution.  On the way, try to guess a good default
-	 * for config.alwaysgl, then overwrite it if it was set previously. */
+	// JMS
+	opts->mainMenuMusic = optMainMenuMusic ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->nebulae = optNebulae ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->orbitingPlanets = optOrbitingPlanets ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->texturedPlanets = optTexturedPlanets ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	// Nic
+	opts->dateType = res_GetInteger ("config.dateFormat");
+	// Serosis
+	opts->infiniteFuel = optInfiniteFuel ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->thraddStory = optThraddStory ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->partialPickup = optPartialPickup ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->submenu = optSubmenu ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->addDevices = optAddDevices ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->scalePlanets = optScalePlanets ? OPTVAL_ENABLED : OPTVAL_DISABLED;
 	opts->loresBlowup = res_GetInteger ("config.loresBlowupScale");
-	opts->driver = OPTVAL_PURE_IF_POSSIBLE;
-	
+
 	// JMS_GFX: 1280x960
 	if (resolutionFactor == 2)
 	{
-		opts->res = OPTVAL_REAL_1280_960;
+		opts->screenResolution = OPTVAL_REAL_1280_960;
 		opts->loresBlowup = NO_BLOWUP;	
 	}
 	// JMS_GFX: 640x480
 	else if (resolutionFactor == 1)
 	{
-		opts->res = OPTVAL_REAL_640_480;
+		opts->screenResolution = OPTVAL_REAL_640_480;
 		opts->loresBlowup = NO_BLOWUP;
 	}
 	// JMS_GFX: 320x240
@@ -1225,60 +1470,41 @@ GetGlobalOptions (GLOBALOPTS *opts)
 			case 320:
 				if (GraphicsDriver == TFB_GFXDRIVER_SDL_PURE)
 				{
-					opts->res = OPTVAL_320_240;
+					opts->screenResolution = OPTVAL_320_240;
 				}
 				else
 				{
-					opts->res = OPTVAL_320_240;
+					opts->screenResolution = OPTVAL_320_240;
 					opts->driver = OPTVAL_ALWAYS_GL;
 				}
 				break;
 			case 640:
 				if (GraphicsDriver == TFB_GFXDRIVER_SDL_PURE)
 				{
-					opts->res = OPTVAL_320_240;
+					opts->screenResolution = OPTVAL_320_240;
 					opts->loresBlowup = OPTVAL_320_TO_640;
 				}
 				else
 				{
-					opts->res = OPTVAL_320_240;
+					opts->screenResolution = OPTVAL_320_240;
 					opts->loresBlowup = OPTVAL_320_TO_640;
 					opts->driver = OPTVAL_ALWAYS_GL;
 				}
 				break;
 			case 960:
-				opts->res = OPTVAL_320_240;
+				opts->screenResolution = OPTVAL_320_240;
 				opts->loresBlowup = OPTVAL_320_TO_960;
 				break;
 			case 1280:
-				opts->res = OPTVAL_320_240;
+				opts->screenResolution = OPTVAL_320_240;
 				opts->loresBlowup = OPTVAL_320_TO_1280;	
 				break;
 			default:
-				opts->res = OPTVAL_320_240;
+				opts->screenResolution = OPTVAL_320_240;
 				opts->loresBlowup = NO_BLOWUP;
 				break;
 		}
 	}
-	
-	if (res_IsBoolean ("config.alwaysgl"))
-	{
-		if (res_GetBoolean ("config.alwaysgl"))
-		{
-			opts->driver = OPTVAL_ALWAYS_GL;
-		}
-		else
-		{
-			opts->driver = OPTVAL_PURE_IF_POSSIBLE;
-		}
-	}
-	
-	opts->player1 = PlayerControls[0];
-	opts->player2 = PlayerControls[1];
-	
-	opts->musicvol = (((int)(musicVolumeScale * 100.0f) + 2) / 5) * 5;
-	opts->sfxvol = (((int)(sfxVolumeScale * 100.0f) + 2) / 5) * 5;
-	opts->speechvol = (((int)(speechVolumeScale * 100.0f) + 2) / 5) * 5;
 }
 
 void
@@ -1290,11 +1516,11 @@ SetGlobalOptions (GLOBALOPTS *opts)
 	int NewDriver = GraphicsDriver;
 	
 	unsigned int oldResFactor = resolutionFactor; // JMS_GFX
-	
+
 	NewGfxFlags &= ~TFB_GFXFLAGS_SCALE_ANY;
 	
 	// JMS_GFX
-	switch (opts->res) {
+	switch (opts->screenResolution) {
 		case OPTVAL_320_240:
 			NewWidth = 320;
 			NewHeight = 240;
@@ -1303,8 +1529,7 @@ SetGlobalOptions (GLOBALOPTS *opts)
 #else
 			NewDriver = TFB_GFXDRIVER_SDL_PURE;
 #endif
-			resolutionFactor = 0;				
-			forceAspectRatio = FALSE;
+			resolutionFactor = 0;
 			break;
 		case OPTVAL_REAL_640_480:
 			NewWidth = 640;	
@@ -1315,7 +1540,6 @@ SetGlobalOptions (GLOBALOPTS *opts)
 			NewDriver = TFB_GFXDRIVER_SDL_PURE;
 #endif
 			resolutionFactor = 1;
-			forceAspectRatio = FALSE;
 			break;
 		case OPTVAL_REAL_1280_960:
 			NewWidth = 1280;
@@ -1326,16 +1550,17 @@ SetGlobalOptions (GLOBALOPTS *opts)
 			NewDriver = TFB_GFXDRIVER_SDL_PURE;
 #endif
 			resolutionFactor = 2;
-			forceAspectRatio = FALSE;
 			break;
 		default:
 			/* Don't mess with the custom value */
 			resolutionFactor = 0; // JMS_GFX
 			break;
 	}
-	
-	if (NewWidth == 320 && NewHeight == 240) {
-		switch (opts->scaler) {
+
+	if (NewWidth == 320 && NewHeight == 240) // MB: Moved code to here to make it work with 320x240 resolutions before opts->loresBlowup switch after
+	{
+		switch (opts->scaler)
+		{
 			case OPTVAL_BILINEAR_SCALE:
 				NewGfxFlags |= TFB_GFXFLAGS_SCALE_BILINEAR;
 				res_PutString ("config.scaler", "bilinear");
@@ -1361,7 +1586,9 @@ SetGlobalOptions (GLOBALOPTS *opts)
 				res_PutString ("config.scaler", "no");
 				break;
 		}
-	} else {
+	}
+	else
+	{
 		// JMS: For now, only bilinear works in 1280x960 and 640x480.
 		switch (opts->scaler)
 		{
@@ -1380,7 +1607,6 @@ SetGlobalOptions (GLOBALOPTS *opts)
 		}
 	}
 
-
 	if (NewWidth == 320 && NewHeight == 240)
 	{	
 		switch (opts->loresBlowup) {
@@ -1418,83 +1644,57 @@ SetGlobalOptions (GLOBALOPTS *opts)
 	
  	if (oldResFactor != resolutionFactor || (opts->music3do != (opt3doMusic ? OPTVAL_ENABLED : OPTVAL_DISABLED)) || (opts->musicremix != (optRemixMusic ? OPTVAL_ENABLED : OPTVAL_DISABLED))) // MB: To force the game to restart when changing music options (otherwise music will not be changed) or resfactor 
  		resFactorWasChanged = TRUE;
+
 	res_PutInteger ("config.reswidth", NewWidth);
 	res_PutInteger ("config.resheight", NewHeight);
 	res_PutBoolean ("config.alwaysgl", opts->driver == OPTVAL_ALWAYS_GL);
-	res_PutBoolean ("config.usegl", NewDriver == TFB_GFXDRIVER_SDL_OPENGL);
+	res_PutBoolean ("config.usegl", NewDriver == TFB_GFXDRIVER_SDL_OPENGL);	
 	
 	// JMS_GFX
 	res_PutInteger ("config.resolutionfactor", resolutionFactor);
-	res_PutBoolean ("config.forceaspectratio", forceAspectRatio);
 	res_PutInteger ("config.loresBlowupScale", opts->loresBlowup);
-	
-	// JMS: Main menu music
-	res_PutBoolean ("config.mainmenuMusic", opts->mainmenuMusic == OPTVAL_ENABLED);
-	optMainmenuMusic = opts->mainmenuMusic == OPTVAL_ENABLED;
-	if(!optMainmenuMusic)
-		FadeMusic (0,ONE_SECOND);
-	else
-		FadeMusic (NORMAL_VOLUME+70, ONE_SECOND);
-		
-	// JMS: A list of mineral values can be displayed upon landing on a planet.
-	res_PutBoolean ("config.mineralSubmenu", opts->mineralSubmenu == OPTVAL_ENABLED);
-	optMineralSubmenu = opts->mineralSubmenu == OPTVAL_ENABLED;
-	
-	// JMS: Is a beautiful nebula background shown as the background of solarsystems.
-	res_PutBoolean ("config.nebulae", opts->nebulae == OPTVAL_ENABLED);
-	optNebulae = opts->nebulae == OPTVAL_ENABLED;
-	
-	// JMS: Rotating planets in IP.
-	res_PutBoolean ("config.rotatingIpPlanets", opts->rotatingIpPlanets == OPTVAL_ENABLED);
-	optRotatingIpPlanets = opts->rotatingIpPlanets == OPTVAL_ENABLED;
-	
-	// JMS: Textured or plain(==vanilla UQM style) planets in IP.
-	res_PutBoolean ("config.texturedIpPlanets", (opts->texturedIpPlanets == OPTVAL_ENABLED) || opts->rotatingIpPlanets == OPTVAL_ENABLED);
-	optTexturedIpPlanets = opts->texturedIpPlanets == OPTVAL_ENABLED
-		|| opts->rotatingIpPlanets == OPTVAL_ENABLED;
-	
+
 	// JMS: Cheat Mode: Kohr-Ah move at zero speed when trying to cleanse the galaxy
-	res_PutBoolean ("config.kohrStahp", opts->cheatMode == OPTVAL_ENABLED);
+	res_PutBoolean ("cheat.kohrStahp", opts->cheatMode == OPTVAL_ENABLED);
 	optCheatMode = opts->cheatMode == OPTVAL_ENABLED;
 
 	// Serosis: God Mode: Health and Energy does not deplete in battle.
-	res_PutBoolean ("config.godMode", opts->godMode == OPTVAL_ENABLED);
+	res_PutBoolean ("cheat.godMode", opts->godMode == OPTVAL_ENABLED);
 	optGodMode = opts->godMode == OPTVAL_ENABLED;
 
 	// Serosis: Time Dilation: Increases and divides time in IP and HS by a factor of 12
-	switch (opts->tdType) {
-		case OPTVAL_NORMAL:
-			timeDilationScale = 0;
-			break;
+	switch (opts->tdType){
 		case OPTVAL_SLOW:
-			timeDilationScale = 1;
-			break;
+			timeDilationScale=1;
+		break;
 		case OPTVAL_FAST:
-			timeDilationScale = 2;
-			break;
+			timeDilationScale=2;
+		break;
+		case OPTVAL_NORMAL:
 		default:
-			break;
+			timeDilationScale=0;
+		break;
 	}
-	res_PutInteger ("config.timeDilation", opts->tdType);
+	res_PutInteger ("cheat.timeDilation", opts->tdType);
 
 	// Serosis: Bubble Warp: Warp instantly to your destination
-	res_PutBoolean ("config.bubbleWarp", opts->bubbleWarp == OPTVAL_ENABLED);
+	res_PutBoolean ("cheat.bubbleWarp", opts->bubbleWarp == OPTVAL_ENABLED);
 	optBubbleWarp = opts->bubbleWarp == OPTVAL_ENABLED;
 
 	// Serosis: Unlocks ships that you can not unlock under normal conditions
-	res_PutBoolean ("config.unlockShips", opts->unlockShips == OPTVAL_ENABLED);
+	res_PutBoolean ("cheat.unlockShips", opts->unlockShips == OPTVAL_ENABLED);
 	optUnlockShips = opts->unlockShips == OPTVAL_ENABLED;
 
 	// Serosis: Gives you 1000 Radioactives and a better outfitted ship on a a new game
-	res_PutBoolean ("config.headStart", opts->headStart == OPTVAL_ENABLED);
+	res_PutBoolean ("cheat.headStart", opts->headStart == OPTVAL_ENABLED);
 	optHeadStart = opts->headStart == OPTVAL_ENABLED;
 
 	// Serosis: Unlocks all upgrades
-	res_PutBoolean ("config.unlockUpgrades", opts->unlockUpgrades == OPTVAL_ENABLED);
+	res_PutBoolean ("cheat.unlockUpgrades", opts->unlockUpgrades == OPTVAL_ENABLED);
 	optUnlockUpgrades = opts->unlockUpgrades == OPTVAL_ENABLED;
 
 	// Serosis: Virtually Infinite RU
-	res_PutBoolean ("config.infiniteRU", opts->infiniteRU == OPTVAL_ENABLED);
+	res_PutBoolean ("cheat.infiniteRU", opts->infiniteRU == OPTVAL_ENABLED);
 	optInfiniteRU = opts->infiniteRU == OPTVAL_ENABLED;
 
 	// Serosis: Skip the intro
@@ -1505,37 +1705,78 @@ SetGlobalOptions (GLOBALOPTS *opts)
 	res_PutBoolean ("config.FMV", opts->FMV == OPTVAL_ENABLED);
 	optFMV = opts->FMV == OPTVAL_ENABLED;
 	
-	if (opts->scanlines) {
+	// JMS: Main menu music
+	res_PutBoolean ("config.mainMenuMusic", opts->mainMenuMusic == OPTVAL_ENABLED);
+	optMainMenuMusic = opts->mainMenuMusic == OPTVAL_ENABLED;
+	if(!optMainMenuMusic)
+		FadeMusic (0,ONE_SECOND);
+	else
+		FadeMusic (NORMAL_VOLUME+70, ONE_SECOND);
+	
+	// JMS: Is a beautiful nebula background shown as the background of solarsystems.
+	res_PutBoolean ("config.nebulae", opts->nebulae == OPTVAL_ENABLED);
+	optNebulae = opts->nebulae == OPTVAL_ENABLED;
+	
+	// JMS: Rotating planets in IP.
+	res_PutBoolean ("config.orbitingPlanets", opts->orbitingPlanets == OPTVAL_ENABLED);
+	optOrbitingPlanets = opts->orbitingPlanets == OPTVAL_ENABLED;
+	
+	// JMS: Textured or plain(==vanilla UQM style) planets in IP.
+	res_PutBoolean ("config.texturedPlanets", opts->texturedPlanets == OPTVAL_ENABLED);
+	optTexturedPlanets = opts->texturedPlanets == OPTVAL_ENABLED;	
+
+	// Nic: Date Format: Switch the displayed date format
+	switch (opts->dateType){
+		case OPTVAL_MMDDYYYY:
+			optDateFormat=1;
+		break;
+		case OPTVAL_DDMMMYYYY:
+			optDateFormat=2;
+		break;
+		case OPTVAL_DDMMYYYY:
+			optDateFormat=3;
+		break;
+		case OPTVAL_MMMDDYYYY:
+		default:
+			optDateFormat=0;
+		break;
+	}
+	res_PutInteger ("config.dateFormat", opts->dateType);	
+	
+	// Serosis: Infinite Fuel
+	res_PutBoolean ("cheat.infiniteFuel", opts->infiniteFuel == OPTVAL_ENABLED);
+	optInfiniteFuel = opts->infiniteFuel == OPTVAL_ENABLED;
+	
+	// Serosis: Optionalized the alt Thraddash story
+	res_PutBoolean ("config.thraddStory", opts->thraddStory == OPTVAL_ENABLED);
+	optThraddStory = opts->thraddStory == OPTVAL_ENABLED;
+	
+	// Serosis: Partial mineral pickup when enabled.
+	res_PutBoolean ("config.partialPickup", opts->partialPickup == OPTVAL_ENABLED);
+	optPartialPickup = opts->partialPickup == OPTVAL_ENABLED;
+	
+	// Serosis: Show submenu
+	res_PutBoolean ("config.submenu", opts->submenu == OPTVAL_ENABLED);
+	optSubmenu = opts->submenu == OPTVAL_ENABLED;
+	
+	// Serosis: get all devices
+	res_PutBoolean ("cheat.addDevices", opts->addDevices == OPTVAL_ENABLED);
+	optAddDevices = opts->addDevices == OPTVAL_ENABLED;
+	
+	// Serosis: Scale Planets in HD
+	res_PutBoolean ("config.scalePlanets", opts->scalePlanets == OPTVAL_ENABLED);
+	optScalePlanets = opts->scalePlanets == OPTVAL_ENABLED;
+
+	if (opts->scanlines && RESOLUTION_FACTOR == 0) {
 		NewGfxFlags |= TFB_GFXFLAGS_SCANLINES;
 	} else {
 		NewGfxFlags &= ~TFB_GFXFLAGS_SCANLINES;
 	}
 	if (opts->fullscreen)
-	{
 		NewGfxFlags |= TFB_GFXFLAGS_FULLSCREEN;
-		
-		// JMS: Force the usage of bilinear scaler in 1280x960 and 640x480 fullscreen.
-		if ((NewWidth == 1280 || NewWidth == 640) && resolutionFactor > 0)
-		{
-			NewGfxFlags |= TFB_GFXFLAGS_SCALE_BILINEAR;
-			res_PutString ("config.scaler", "bilinear");
-		}
-	}
 	else
-	{
 		NewGfxFlags &= ~TFB_GFXFLAGS_FULLSCREEN;
-		
-		// JMS: Force the usage of no scaler in 1280x960 and 640x480 windowed modes.
-		// When running in windowed mode, the image isn't stretched,
-		// thus using a scaler would yield no benefits.
-		// Not using a scaler should make the performance a little better.
-		if (NewWidth == 1280 || NewWidth == 640 && resolutionFactor > 0)
-		{
-			NewGfxFlags &= ~TFB_GFXFLAGS_SCALE_BILINEAR;
-			res_PutString ("config.scaler", "no");
-		}
-	}
-	
+
 	res_PutBoolean ("config.scanlines", opts->scanlines);
 	res_PutBoolean ("config.fullscreen", opts->fullscreen);
 	
@@ -1574,39 +1815,49 @@ SetGlobalOptions (GLOBALOPTS *opts)
 		FlushGraphics ();
 		InitVideoPlayer (TRUE);
 	}
+
+	// Avoid setting gamma when it is not necessary
+	if (optGamma != 1.0f || sliderToGamma (opts->gamma) != 1.0f)
+	{
+		optGamma = sliderToGamma (opts->gamma);
+		setGammaCorrection (optGamma);
+	}
+
 	optSubtitles = (opts->subtitles == OPTVAL_ENABLED) ? TRUE : FALSE;
-	// optWhichMusic = (opts->music == OPTVAL_3DO) ? OPT_3DO : OPT_PC;
 	optWhichMenu = (opts->menu == OPTVAL_3DO) ? OPT_3DO : OPT_PC;
 	optWhichFonts = (opts->text == OPTVAL_3DO) ? OPT_3DO : OPT_PC;
 	optWhichCoarseScan = (opts->cscan == OPTVAL_3DO) ? OPT_3DO : OPT_PC;
 	optSmoothScroll = (opts->scroll == OPTVAL_3DO) ? OPT_3DO : OPT_PC;
 	optWhichShield = (opts->shield == OPTVAL_3DO) ? OPT_3DO : OPT_PC;
-	
-	// JMS: Originally, the smooth zoom was TFB_SCALE_TRILINEAR instead of bilinear.
-	// Using bilinear alleviates the smooth zoom performance choppiness problems in 2x and 4x, but
-	// is kinda hacky solution...
-	optMeleeScale = (opts->meleezoom == OPTVAL_3DO) ? TFB_SCALE_BILINEAR : TFB_SCALE_STEP;
-	
+	optMeleeScale = (opts->meleezoom == OPTVAL_3DO) ? TFB_SCALE_TRILINEAR : TFB_SCALE_STEP;
+	opt3doMusic = (opts->music3do == OPTVAL_ENABLED);
+	optRemixMusic = (opts->musicremix == OPTVAL_ENABLED);
+	optSpeech = (opts->speech == OPTVAL_ENABLED);
 	optWhichIntro = (opts->intro == OPTVAL_3DO) ? OPT_3DO : OPT_PC;
+	optStereoSFX = (opts->stereo == OPTVAL_ENABLED);
+	optKeepAspectRatio = (opts->keepaspect == OPTVAL_ENABLED);
 	PlayerControls[0] = opts->player1;
 	PlayerControls[1] = opts->player2;
-	
+
 	res_PutBoolean ("config.subtitles", opts->subtitles == OPTVAL_ENABLED);
 	res_PutBoolean ("config.textmenu", opts->menu == OPTVAL_PC);
 	res_PutBoolean ("config.textgradients", opts->text == OPTVAL_PC);
 	res_PutBoolean ("config.iconicscan", opts->cscan == OPTVAL_3DO);
 	res_PutBoolean ("config.smoothscroll", opts->scroll == OPTVAL_3DO);
-	
+
 	res_PutBoolean ("config.3domusic", opts->music3do == OPTVAL_ENABLED);
 	res_PutBoolean ("config.remixmusic", opts->musicremix == OPTVAL_ENABLED);
+	res_PutBoolean ("config.speech", opts->speech == OPTVAL_ENABLED);
 	res_PutBoolean ("config.3domovies", opts->intro == OPTVAL_3DO);
 	res_PutBoolean ("config.showfps", opts->fps == OPTVAL_ENABLED);
 	res_PutBoolean ("config.smoothmelee", opts->meleezoom == OPTVAL_3DO);
 	res_PutBoolean ("config.positionalsfx", opts->stereo == OPTVAL_ENABLED); 
 	res_PutBoolean ("config.pulseshield", opts->shield == OPTVAL_3DO);
+	res_PutBoolean ("config.keepaspectratio", opts->keepaspect == OPTVAL_ENABLED);
+	res_PutInteger ("config.gamma", (int) (optGamma * GAMMA_SCALE + 0.5));
 	res_PutInteger ("config.player1control", opts->player1);
 	res_PutInteger ("config.player2control", opts->player2);
-	
+
 	switch (opts->adriver) {
 		case OPTVAL_SILENCE:
 			res_PutString ("config.audiodriver", "none");
@@ -1620,7 +1871,7 @@ SetGlobalOptions (GLOBALOPTS *opts)
 			/* Shouldn't happen; leave config untouched */
 			break;
 	}
-	
+
 	switch (opts->aquality) {
 		case OPTVAL_LOW:
 			res_PutString ("config.audioquality", "low");
@@ -1635,7 +1886,7 @@ SetGlobalOptions (GLOBALOPTS *opts)
 			/* Shouldn't happen; leave config untouched */
 			break;
 	}
-	
+
 	res_PutInteger ("config.musicvol", opts->musicvol);
 	res_PutInteger ("config.sfxvol", opts->sfxvol);
 	res_PutInteger ("config.speechvol", opts->speechvol);
@@ -1645,14 +1896,17 @@ SetGlobalOptions (GLOBALOPTS *opts)
 	// update actual volumes
 	SetMusicVolume (musicVolume);
 	SetSpeechVolume (speechVolumeScale);
-	
+
 	res_PutString ("keys.1.name", input_templates[0].name);
 	res_PutString ("keys.2.name", input_templates[1].name);
 	res_PutString ("keys.3.name", input_templates[2].name);
 	res_PutString ("keys.4.name", input_templates[3].name);
 	res_PutString ("keys.5.name", input_templates[4].name);
 	res_PutString ("keys.6.name", input_templates[5].name);
-	
+
 	SaveResourceIndex (configDir, "uqm.cfg", "config.", TRUE);
+
 	SaveKeyConfiguration (configDir, "flight.cfg");
+	
+	SaveResourceIndex (configDir, "cheats.cfg", "cheat.", TRUE);
 }
diff -ruNp src.hd/uqm/setupmenu.h src/uqm/setupmenu.h
--- src.hd/uqm/setupmenu.h	2017-12-29 02:25:53 -0800
+++ src/uqm/setupmenu.h	2017-12-29 00:57:50 -0800
@@ -16,13 +16,15 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged resolution Factor stuff from P6014.
-
 #ifndef _SETUPMENU_H
 #define _SETUPMENU_H
 
 #include "controls.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef enum {
 	OPTVAL_DISABLED,
 	OPTVAL_ENABLED
@@ -71,31 +73,40 @@ typedef enum {
 	OPTVAL_MEDIUM,
 	OPTVAL_HIGH
 } OPT_AQUALITYTYPE;
-
+ 
 typedef enum {
 	OPTVAL_NORMAL,
 	OPTVAL_SLOW,
 	OPTVAL_FAST
 } OPT_TDTYPE;
+ 
+typedef enum {
+	OPTVAL_MMMDDYYYY,
+	OPTVAL_MMDDYYYY,
+	OPTVAL_DDMMMYYYY,
+	OPTVAL_DDMMYYYY
+} OPT_DATETYPE;
 
 /* At the moment, CONTROL_TEMPLATE is directly in this structure.  If
  * CONTROL_TEMPLATE and the options available diverge, this will need
  * to change */
 typedef struct globalopts_struct {
 	OPT_SCALETYPE scaler;
-	OPT_RESTYPE res;
+	OPT_RESTYPE screenResolution;
 	OPT_LORESBLOWUPTYPE loresBlowup;
 	OPT_DRIVERTYPE driver;
 	OPT_ADRIVERTYPE adriver;
 	OPT_AQUALITYTYPE aquality;
-	OPT_TDTYPE tdType;
-	OPT_ENABLABLE fullscreen, subtitles, scanlines, fps, stereo, music3do, musicremix, 
-		mainmenuMusic, mineralSubmenu, nebulae, rotatingIpPlanets, texturedIpPlanets, cheatMode, // JMS
-		godMode, bubbleWarp, unlockShips, headStart, unlockUpgrades, infiniteRU, // Serosis
-		skipIntro, FMV;
+	OPT_TDTYPE tdType; // Serosis
+	OPT_DATETYPE dateType; //
+	OPT_ENABLABLE fullscreen, subtitles, scanlines, fps, stereo, music3do, musicremix, speech, keepaspect,
+		cheatMode, godMode, bubbleWarp, unlockShips, headStart, unlockUpgrades, infiniteRU, skipIntro, FMV, // Serosis: except for cheatMode = JMS
+		mainMenuMusic, nebulae, orbitingPlanets, texturedPlanets, // JMS
+		infiniteFuel, thraddStory, partialPickup, submenu, addDevices, scalePlanets; // Serosis
 	OPT_CONSOLETYPE menu, text, cscan, scroll, intro, meleezoom, shield;
 	CONTROL_TEMPLATE player1, player2;
 	int speechvol, musicvol, sfxvol;
+	int gamma;
 } GLOBALOPTS;
 
 void SetupMenu (void);
@@ -103,4 +114,8 @@ void SetupMenu (void);
 void GetGlobalOptions (GLOBALOPTS *opts);
 void SetGlobalOptions (GLOBALOPTS *opts);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif // _SETUPMENU_H
diff -ruNp src.hd/uqm/ship.c src/uqm/ship.c
--- src.hd/uqm/ship.c	2017-12-29 02:25:53 -0800
+++ src/uqm/ship.c	2017-12-29 00:57:50 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "ship.h"
 
 #include "build.h"
@@ -195,6 +193,9 @@ ship_preprocess (ELEMENT *ElementPtr)
 			if (RDPtr->preprocess_func)
 				(*RDPtr->preprocess_func) (ElementPtr);
 
+			// XXX: Hack: Pkunk sets hTarget!=0 when it reincarnates. In that
+			//   case there is no ship_transition() but a Phoenix transition
+			//   instead.
 			if (ElementPtr->hTarget == 0)
 			{
 				ship_transition (ElementPtr);
@@ -270,7 +271,7 @@ ship_preprocess (ELEMENT *ElementPtr)
 		if (!OBJECT_CLOAKED (ElementPtr)
 				&& LOBYTE (GLOBAL (CurrentActivity)) <= IN_ENCOUNTER)
 		{
-			spawn_ion_trail (ElementPtr);
+			spawn_ion_trail (ElementPtr, 0, 0);
 		}
 	}
 
@@ -453,7 +454,7 @@ spawn_ship (STARSHIP *StarShipPtr)
 		else
 		{
 			StarShipPtr->ShipFacing = NORMALIZE_FACING (TFB_Random ());
-			if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+			if (inHQSpace ())
 			{	// Only one ship is ever spawned in HyperSpace -- flagship
 				COUNT facing = GLOBAL (ShipFacing);
 				// XXX: Solar system reentry test depends on ShipFacing != 0
diff -ruNp src.hd/uqm/ship.h src/uqm/ship.h
--- src.hd/uqm/ship.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ship.h	2017-12-29 00:57:50 -0800
@@ -21,6 +21,10 @@
 #include "races.h"
 #include "element.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern BOOLEAN GetNextStarShip (STARSHIP *LastStarShipPtr, COUNT which_side);
 extern BOOLEAN GetInitialStarShips (void);
 
@@ -32,4 +36,8 @@ extern void collision (ELEMENT *ElementP
 
 extern STATUS_FLAGS inertial_thrust (ELEMENT *ElementPtr);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* UQM_SHIP_H_INCL_ */
diff -ruNp src.hd/uqm/shipcont.h src/uqm/shipcont.h
--- src.hd/uqm/shipcont.h	2017-12-29 02:25:53 -0800
+++ src/uqm/shipcont.h	2017-12-29 00:57:50 -0800
@@ -16,13 +16,15 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #ifndef _SHIPCONT_H
 #define _SHIPCONT_H
 
 #include "menustat.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #define FIELD_WIDTH (STATUS_WIDTH - RES_CASE(5,5,7)) // JMS_GFX
 
 extern void CargoMenu (void);
@@ -35,5 +37,9 @@ extern void ShowRemainingCapacity (void)
 
 extern SIZE InventoryDevices (BYTE *pDeviceMap, COUNT Size);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _SHIPCONT_H */
 
diff -ruNp src.hd/uqm/ships/Makeinfo src/uqm/ships/Makeinfo
--- src.hd/uqm/ships/Makeinfo	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/Makeinfo	2017-12-29 00:57:52 -0800
@@ -2,3 +2,4 @@ uqm_SUBDIRS="androsyn arilou blackurq ch
 		lastbat melnorme mmrnmhrm mycon orz pkunk probe shofixti sis_ship
 		slylandr spathi supox syreen thradd umgah urquan utwig vux yehat
 		zoqfot"
+uqm_HFILES="ship.h"
diff -ruNp src.hd/uqm/ships/androsyn/Makeinfo src/uqm/ships/androsyn/Makeinfo
--- src.hd/uqm/ships/androsyn/Makeinfo	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/androsyn/Makeinfo	2017-12-29 00:57:51 -0800
@@ -1 +1,2 @@
 uqm_CFILES="androsyn.c"
+uqm_HFILES="androsyn.h icode.h resinst.h"
diff -ruNp src.hd/uqm/ships/androsyn/androsyn.c src/uqm/ships/androsyn/androsyn.c
--- src.hd/uqm/ships/androsyn/androsyn.c	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/androsyn/androsyn.c	2017-12-29 00:57:50 -0800
@@ -19,28 +19,50 @@
 #include "../ship.h"
 #include "androsyn.h"
 #include "resinst.h"
+#include "../../units.h"
 
 #include "libs/mathlib.h"
 
-
+// Core characteristics
 #define MAX_CREW 20
 #define MAX_ENERGY 24
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 3
-#define SPECIAL_ENERGY_COST 2
 #define ENERGY_WAIT 8
 #define MAX_THRUST 24
 #define THRUST_INCREMENT 3
+#define MAX_THRUST_2X 48
+#define THRUST_INCREMENT_2X 6
+#define MAX_THRUST_4X 96
+#define THRUST_INCREMENT_4X 12
 #define TURN_WAIT 4
 #define THRUST_WAIT 0
+#define SHIP_MASS 6
+
+// Bubbles
+#define WEAPON_ENERGY_COST 3
 #define WEAPON_WAIT 0
-#define SPECIAL_WAIT 0
+#define ANDROSYNTH_OFFSET (14 << RESOLUTION_FACTOR)
+#define MISSILE_OFFSET (3 << RESOLUTION_FACTOR)
+#define MISSILE_SPEED DISPLAY_TO_WORLD (8 << RESOLUTION_FACTOR)
+#define MISSILE_LIFE 200
+#define MISSILE_HITS 3
+#define MISSILE_DAMAGE 2
+#define TRACK_WAIT 2
 
-#define SHIP_MASS 6
+// Blazer
+#define SPECIAL_ENERGY_COST 2
+#define BLAZER_DEGENERATION (-1)
+#define SPECIAL_WAIT 0
+#define BLAZER_OFFSET (10 << RESOLUTION_FACTOR)
+#define BLAZER_THRUST (60 << RESOLUTION_FACTOR)
+#define BLAZER_TURN_WAIT 1
+#define BLAZER_DAMAGE 3
+#define BLAZER_MASS 1
 
-static RACE_DESC androsynth_desc =
+static RACE_DESC androsynth_desc1x =
 {
 	{ /* SHIP_INFO */
+		"guardian",
 		FIRES_FORE | SEEKING_WEAPON,
 		15, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -52,6 +74,7 @@ static RACE_DESC androsynth_desc =
 	},
 	{ /* FLEET_STUFF */
 		INFINITE_RADIUS, /* Initial sphere of influence radius */
+				// XXX: Why infinite radius? Bug?
 		{ /* Known location (center of SoI) */
 			MAX_X_UNIVERSE >> 1, MAX_Y_UNIVERSE >> 1,
 		},
@@ -109,13 +132,10 @@ static RACE_DESC androsynth_desc =
 	0, /* CodeRef */
 };
 
-#define MAX_THRUST_2XRES 48  // JMS_GFX
-#define THRUST_INCREMENT_2XRES 6 // JMS_GFX
-
- // JMS_GFX
-static RACE_DESC androsynth_desc_2xres =
+static RACE_DESC androsynth_desc2x =
 {
 	{ /* SHIP_INFO */
+		"guardian",
 		FIRES_FORE | SEEKING_WEAPON,
 		15, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -132,8 +152,8 @@ static RACE_DESC androsynth_desc_2xres =
 		},
 	},
 	{
-		MAX_THRUST_2XRES,
-		THRUST_INCREMENT_2XRES,
+		MAX_THRUST_2X,
+		THRUST_INCREMENT_2X,
 		ENERGY_REGENERATION,
 		WEAPON_ENERGY_COST,
 		SPECIAL_ENERGY_COST,
@@ -184,13 +204,11 @@ static RACE_DESC androsynth_desc_2xres =
 	0, /* CodeRef */
 };
 
-#define MAX_THRUST_4XRES 96  // JMS_GFX
-#define THRUST_INCREMENT_4XRES 12 // JMS_GFX
-
 // JMS_GFX
-static RACE_DESC androsynth_desc_4xres =
+static RACE_DESC androsynth_desc4x =
 {
 	{ /* SHIP_INFO */
+		"guardian",
 		FIRES_FORE | SEEKING_WEAPON,
 		15, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -207,8 +225,8 @@ static RACE_DESC androsynth_desc_4xres =
 		},
 	},
 	{
-		MAX_THRUST_4XRES,
-		THRUST_INCREMENT_4XRES,
+		MAX_THRUST_4X,
+		THRUST_INCREMENT_4X,
 		ENERGY_REGENERATION,
 		WEAPON_ENERGY_COST,
 		SPECIAL_ENERGY_COST,
@@ -259,18 +277,52 @@ static RACE_DESC androsynth_desc_4xres =
 	0, /* CodeRef */
 };
 
-#define BLAZER_DAMAGE 3
-#define BLAZER_MASS 1
+// Private per-instance ship data
+typedef struct
+{
+	ElementCollisionFunc* collision_func;
+} ANDROSYNTH_DATA;
+
+// Local typedef
+typedef ANDROSYNTH_DATA CustomShipData_t;
+
+// Retrieve race-specific ship data from a race desc
+static CustomShipData_t *
+GetCustomShipData (RACE_DESC *pRaceDesc)
+{
+	return pRaceDesc->data;
+}
+
+// Set the race-specific data in a race desc
+// (Re)Allocates its own storage for the data.
+static void
+SetCustomShipData (RACE_DESC *pRaceDesc, const CustomShipData_t *data)
+{
+	if (pRaceDesc->data == data) 
+		return;  // no-op
+
+	if (pRaceDesc->data) // Out with the old
+	{
+		HFree (pRaceDesc->data);
+		pRaceDesc->data = NULL;
+	}
+
+	if (data) // In with the new
+	{
+		CustomShipData_t* newData = HMalloc (sizeof (*data));
+		*newData = *data;
+		pRaceDesc->data = newData;
+	}
+}
 
 static void
 blazer_collision (ELEMENT *ElementPtr0, POINT *pPt0,
 		ELEMENT *ElementPtr1, POINT *pPt1)
 {
-#define BLAZER_OFFSET (10 << RESOLUTION_FACTOR) // JMS_GFX
 	BYTE old_offs;
 	COUNT old_crew_level;
 	COUNT old_life;
-	
+
 	old_crew_level = ElementPtr0->crew_level;
 	old_life = ElementPtr0->life_span;
 	old_offs = ElementPtr0->blast_offset;
@@ -281,13 +333,11 @@ blazer_collision (ELEMENT *ElementPtr0,
 	ElementPtr0->blast_offset = old_offs;
 	ElementPtr0->life_span = old_life;
 	ElementPtr0->crew_level = old_crew_level;
-	
+
 	ElementPtr0->state_flags &= ~(DISAPPEARING | NONSOLID);
 	collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
 }
 
-#define MISSILE_SPEED DISPLAY_TO_WORLD (8 << RESOLUTION_FACTOR) // JMS_GFX
-
 static void
 bubble_preprocess (ELEMENT *ElementPtr)
 {
@@ -323,23 +373,15 @@ bubble_preprocess (ELEMENT *ElementPtr)
 			facing -= (COUNT)TFB_Random () & (ANGLE_TO_FACING (HALF_CIRCLE) - 1);
 		SetVelocityVector (&ElementPtr->velocity,
 				MISSILE_SPEED, facing);
-
-#define TRACK_WAIT 2
 		turn_wait = TRACK_WAIT;
 	}
 
 	ElementPtr->turn_wait = MAKE_BYTE (turn_wait, thrust_wait);
 }
 
-#define MISSILE_DAMAGE 2
-#define MISSILE_LIFE 200
-
 static COUNT
 initialize_bubble (ELEMENT *ShipPtr, HELEMENT BubbleArray[])
 {
-#define ANDROSYNTH_OFFSET (14 << RESOLUTION_FACTOR) // JMS_GFX
-#define MISSILE_OFFSET (3 << RESOLUTION_FACTOR) // JMS_GFX
-#define MISSILE_HITS 3
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -405,7 +447,6 @@ androsynth_intelligence (ELEMENT *ShipPt
 		if (lpEvalDesc->ObjectPtr)
 		{
 			GetElementStarShip (lpEvalDesc->ObjectPtr, &pEnemyStarShip);
-			// JMS_GFX
 			if (lpEvalDesc->which_turn <= 16
 					&& (StarShipPtr->special_counter > 0
 					|| StarShipPtr->RaceDescPtr->ship_info.energy_level < MAX_ENERGY / 3
@@ -421,7 +462,6 @@ androsynth_intelligence (ELEMENT *ShipPt
 		if (StarShipPtr->special_counter == 0)
 		{
 			StarShipPtr->ship_input_state &= ~SPECIAL;
-			// JMS_GFX
 			if ((ObjectsOfConcern[ENEMY_WEAPON_INDEX].ObjectPtr
 					&& ObjectsOfConcern[ENEMY_WEAPON_INDEX].which_turn <= 4)
 					|| (lpEvalDesc->ObjectPtr
@@ -475,8 +515,6 @@ androsynth_intelligence (ELEMENT *ShipPt
 	}
 }
 
-#define BLAZER_TURN_WAIT 1
-
 static void
 androsynth_postprocess (ELEMENT *ElementPtr)
 {
@@ -486,7 +524,6 @@ androsynth_postprocess (ELEMENT *Element
 			/* take care of blazer effect */
 	if (ElementPtr->next.image.farray == StarShipPtr->RaceDescPtr->ship_data.special)
 	{
-#define BLAZER_DEGENERATION (-1)
 		if ((StarShipPtr->cur_status_flags & SPECIAL)
 				|| StarShipPtr->RaceDescPtr->ship_info.energy_level == 0)
 		{
@@ -506,11 +543,14 @@ androsynth_postprocess (ELEMENT *Element
 				ElementPtr->mass_points = BLAZER_MASS;
 				StarShipPtr->RaceDescPtr->characteristics.turn_wait
 						= BLAZER_TURN_WAIT;
+
 				/* Save the current collision func because we were not the
 				 * ones who set it */
-				StarShipPtr->RaceDescPtr->data = (intptr_t)
-						ElementPtr->collision_func;
-				ElementPtr->collision_func = blazer_collision;
+				{
+					const ANDROSYNTH_DATA shipData = { ElementPtr->collision_func };
+					SetCustomShipData (StarShipPtr->RaceDescPtr, &shipData);
+					ElementPtr->collision_func = blazer_collision;
+				}
 			}
 		}
 
@@ -577,8 +617,8 @@ androsynth_preprocess (ELEMENT *ElementP
 					StarShipPtr->RaceDescPtr->characteristics.special_wait;
 			StarShipPtr->RaceDescPtr->characteristics.energy_regeneration = ENERGY_REGENERATION;
 			ElementPtr->mass_points = SHIP_MASS;
-			ElementPtr->collision_func = (CollisionFunc *)
-					StarShipPtr->RaceDescPtr->data;
+			ElementPtr->collision_func = 
+					GetCustomShipData (StarShipPtr->RaceDescPtr)->collision_func;
 			ElementPtr->next.image.farray =
 					StarShipPtr->RaceDescPtr->ship_data.ship;
 			ElementPtr->next.image.frame =
@@ -592,7 +632,6 @@ androsynth_preprocess (ELEMENT *ElementP
 				--ElementPtr->thrust_wait;
 			else
 			{
-#define BLAZER_THRUST (60 << RESOLUTION_FACTOR) // JMS_GFX
 				COUNT facing;
 
 				facing = StarShipPtr->ShipFacing;
@@ -614,36 +653,26 @@ androsynth_preprocess (ELEMENT *ElementP
 	StarShipPtr->cur_status_flags = cur_status_flags;
 }
 
+static void
+uninit_androsynth (RACE_DESC *pRaceDesc)
+{
+	SetCustomShipData (pRaceDesc, NULL);
+}
+
+
 RACE_DESC*
 init_androsynth (void)
 {
+	static RACE_DESC androsynth_desc;
 	RACE_DESC *RaceDescPtr;
+	
+	androsynth_desc = (RESOLUTION_FACTOR == 0 ? androsynth_desc1x : (RESOLUTION_FACTOR == 1 ? androsynth_desc2x : androsynth_desc4x));
 
-	// JMS_GFX: A rather clumsy way of giving ship correct stats at hi-res modes.
-	if (RESOLUTION_FACTOR == 0)
-	{
-		androsynth_desc.preprocess_func = androsynth_preprocess;
-		androsynth_desc.postprocess_func = androsynth_postprocess;
-		androsynth_desc.init_weapon_func = initialize_bubble;
-		androsynth_desc.cyborg_control.intelligence_func = androsynth_intelligence;
-		RaceDescPtr = &androsynth_desc;
-	}
-	else if (RESOLUTION_FACTOR == 1)
-	{
-		androsynth_desc_2xres.preprocess_func = androsynth_preprocess;
-		androsynth_desc_2xres.postprocess_func = androsynth_postprocess;
-		androsynth_desc_2xres.init_weapon_func = initialize_bubble;
-		androsynth_desc_2xres.cyborg_control.intelligence_func = androsynth_intelligence;
-		RaceDescPtr = &androsynth_desc_2xres;
-	}
-	else
-	{
-		androsynth_desc_4xres.preprocess_func = androsynth_preprocess;
-		androsynth_desc_4xres.postprocess_func = androsynth_postprocess;
-		androsynth_desc_4xres.init_weapon_func = initialize_bubble;
-		androsynth_desc_4xres.cyborg_control.intelligence_func = androsynth_intelligence;
-		RaceDescPtr = &androsynth_desc_4xres;
-	}
+	androsynth_desc.preprocess_func = androsynth_preprocess;
+	androsynth_desc.postprocess_func = androsynth_postprocess;
+	androsynth_desc.init_weapon_func = initialize_bubble;
+	androsynth_desc.cyborg_control.intelligence_func = androsynth_intelligence;
+	RaceDescPtr = &androsynth_desc;
 
 	return (RaceDescPtr);
 }
diff -ruNp src.hd/uqm/ships/androsyn/androsyn.h src/uqm/ships/androsyn/androsyn.h
--- src.hd/uqm/ships/androsyn/androsyn.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/androsyn/androsyn.h	2017-12-29 00:57:51 -0800
@@ -17,7 +17,15 @@
 #ifndef ANDROSYN_H
 #define ANDROSYN_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_androsynth (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* ANDROSYN_H */
 
diff -ruNp src.hd/uqm/ships/androsyn/icode.h src/uqm/ships/androsyn/icode.h
--- src.hd/uqm/ships/androsyn/icode.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/androsyn/icode.h	2017-12-29 00:57:51 -0800
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define ANDROSYNTH_CODE "ship.androsynth.code"
diff -ruNp src.hd/uqm/ships/androsyn/resinst.h src/uqm/ships/androsyn/resinst.h
--- src.hd/uqm/ships/androsyn/resinst.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/androsyn/resinst.h	2017-12-29 00:57:51 -0800
@@ -1,17 +1,19 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define ANDROSYNTH_BIG_MASK_PMAP_ANIM "ship.androsynth.graphics.guardian.large"
 #define ANDROSYNTH_CAPT_MASK_PMAP_ANIM "ship.androsynth.graphics.captain"
 #define ANDROSYNTH_ICON_MASK_PMAP_ANIM "ship.androsynth.icons"
 #define ANDROSYNTH_MED_MASK_PMAP_ANIM "ship.androsynth.graphics.guardian.medium"
 #define ANDROSYNTH_MICON_MASK_PMAP_ANIM "ship.androsynth.meleeicons"
+#define ANDROSYNTH_RACE_STRINGS "ship.androsynth.text"
+#define ANDROSYNTH_SHIP_SOUNDS "ship.androsynth.sounds"
 #define ANDROSYNTH_SML_MASK_PMAP_ANIM "ship.androsynth.graphics.guardian.small"
+#define ANDROSYNTH_VICTORY_SONG "ship.androsynth.ditty"
 #define BLAZER_BIG_MASK_PMAP_ANIM "ship.androsynth.graphics.blazer.large"
 #define BLAZER_MED_MASK_PMAP_ANIM "ship.androsynth.graphics.blazer.medium"
 #define BLAZER_SML_MASK_PMAP_ANIM "ship.androsynth.graphics.blazer.small"
 #define BUBBLE_BIG_MASK_PMAP_ANIM "ship.androsynth.graphics.bubble.large"
 #define BUBBLE_MED_MASK_PMAP_ANIM "ship.androsynth.graphics.bubble.medium"
 #define BUBBLE_SML_MASK_PMAP_ANIM "ship.androsynth.graphics.bubble.small"
-#define ANDROSYNTH_RACE_STRINGS "ship.androsynth.text"
-#define ANDROSYNTH_SHIP_SOUNDS "ship.androsynth.sounds"
-#define ANDROSYNTH_VICTORY_SONG "ship.androsynth.ditty"
-
-#include "icode.h"
diff -ruNp src.hd/uqm/ships/arilou/Makeinfo src/uqm/ships/arilou/Makeinfo
--- src.hd/uqm/ships/arilou/Makeinfo	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/arilou/Makeinfo	2017-12-29 00:57:51 -0800
@@ -1 +1,2 @@
 uqm_CFILES="arilou.c"
+uqm_HFILES="arilou.h icode.h resinst.h"
diff -ruNp src.hd/uqm/ships/arilou/arilou.c src/uqm/ships/arilou/arilou.c
--- src.hd/uqm/ships/arilou/arilou.c	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/arilou/arilou.c	2017-12-29 00:57:51 -0800
@@ -24,27 +24,44 @@
 #include "uqm/globdata.h"
 #include <math.h>
 
-
+// Core characteristics
 #define MAX_CREW 6
 #define MAX_ENERGY 20
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 2
-#define SPECIAL_ENERGY_COST 3
 #define ENERGY_WAIT 6
 #define MAX_THRUST /* DISPLAY_TO_WORLD (10) */ 40
 #define THRUST_INCREMENT MAX_THRUST
-#define TURN_WAIT 0
 #define THRUST_WAIT 0
-#define WEAPON_WAIT 1
-#define SPECIAL_WAIT 2
-
+#define TURN_WAIT 0
 #define SHIP_MASS 1
+
+// Tracking Laser
+#define WEAPON_ENERGY_COST 2
+#define WEAPON_WAIT 1
 #define ARILOU_OFFSET 9
 #define LASER_RANGE DISPLAY_TO_WORLD (100 + ARILOU_OFFSET)
 
-static RACE_DESC arilou_desc =
+// Teleporter
+#define SPECIAL_ENERGY_COST 3
+#define SPECIAL_WAIT 2
+#define HYPER_LIFE 5
+
+// HD Values
+// 2x
+#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (20) */ 80					// JMS_GFX
+#define THRUST_INCREMENT_2XRES MAX_THRUST_2XRES							// JMS_GFX
+#define ARILOU_OFFSET_2XRES 18											// JMS_GFX
+#define LASER_RANGE_2XRES DISPLAY_TO_WORLD (200 + ARILOU_OFFSET_2XRES)	// JMS_GFX
+// 4x
+#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (20) */ 160				// JMS_GFX
+#define THRUST_INCREMENT_4XRES MAX_THRUST_4XRES							// JMS_GFX
+#define ARILOU_OFFSET_4XRES 36											// JMS_GFX
+#define LASER_RANGE_4XRES DISPLAY_TO_WORLD (400 + ARILOU_OFFSET_4XRES)	// JMS_GFX
+
+static RACE_DESC arilou_desc1x =
 {
 	{ /* SHIP_INFO */
+		"skiff",
 		/* FIRES_FORE | */ IMMEDIATE_WEAPON,
 		16, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -113,15 +130,11 @@ static RACE_DESC arilou_desc =
 	0, /* CodeRef */
 };
 
-#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (20) */ 80					// JMS_GFX
-#define THRUST_INCREMENT_2XRES MAX_THRUST_2XRES							// JMS_GFX
-#define ARILOU_OFFSET_2XRES 18											// JMS_GFX
-#define LASER_RANGE_2XRES DISPLAY_TO_WORLD (200 + ARILOU_OFFSET_2XRES)	// JMS_GFX
-
 // JMS_GFX
-static RACE_DESC arilou_desc_2xres =
+static RACE_DESC arilou_desc2x =
 {
 	{ /* SHIP_INFO */
+		"skiff",
 		/* FIRES_FORE | */ IMMEDIATE_WEAPON,
 		16, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -190,15 +203,11 @@ static RACE_DESC arilou_desc_2xres =
 	0, /* CodeRef */
 };
 
-#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (20) */ 160				// JMS_GFX
-#define THRUST_INCREMENT_4XRES MAX_THRUST_4XRES							// JMS_GFX
-#define ARILOU_OFFSET_4XRES 36											// JMS_GFX
-#define LASER_RANGE_4XRES DISPLAY_TO_WORLD (400 + ARILOU_OFFSET_4XRES)	// JMS_GFX
-
 // JMS_GFX
-static RACE_DESC arilou_desc_4xres =
+static RACE_DESC arilou_desc4x =
 {
 	{ /* SHIP_INFO */
+		"skiff",
 		/* FIRES_FORE | */ IMMEDIATE_WEAPON,
 		16, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -267,8 +276,6 @@ static RACE_DESC arilou_desc_4xres =
 	0, /* CodeRef */
 };
 
-
-
 static COUNT
 initialize_autoaim_laser (ELEMENT *ShipPtr, HELEMENT LaserArray[])
 {
@@ -276,16 +283,9 @@ initialize_autoaim_laser (ELEMENT *ShipP
 	SIZE delta_facing;
 	STARSHIP *StarShipPtr;
 	LASER_BLOCK LaserBlock;
-	
-	COUNT laser_range_resscaled; // JMS_GFX
-	
-	// JMS_GFX
-	if (RESOLUTION_FACTOR == 0)
-		laser_range_resscaled = LASER_RANGE;
-	else if (RESOLUTION_FACTOR == 1)
-		laser_range_resscaled = LASER_RANGE_2XRES;
-	else
-		laser_range_resscaled = LASER_RANGE_4XRES;
+	COUNT LaserRange; // JMS_GFX
+
+	LaserRange = RESOLUTION_FACTOR == 0 ? LASER_RANGE : (RESOLUTION_FACTOR == 1 ? LASER_RANGE_2XRES : LASER_RANGE_4XRES );
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	LaserBlock.face = orig_facing = StarShipPtr->ShipFacing;
@@ -295,11 +295,11 @@ initialize_autoaim_laser (ELEMENT *ShipP
 
 	LaserBlock.cx = ShipPtr->next.location.x;
 	LaserBlock.cy = ShipPtr->next.location.y;
-	LaserBlock.ex = COSINE (FACING_TO_ANGLE (LaserBlock.face), laser_range_resscaled);
-	LaserBlock.ey = SINE (FACING_TO_ANGLE (LaserBlock.face), laser_range_resscaled);
+	LaserBlock.ex = COSINE (FACING_TO_ANGLE (LaserBlock.face), LaserRange);
+	LaserBlock.ey = SINE (FACING_TO_ANGLE (LaserBlock.face), LaserRange);
 	LaserBlock.sender = ShipPtr->playerNr;
 	LaserBlock.flags = IGNORE_SIMILAR;
-	LaserBlock.pixoffs = ARILOU_OFFSET << RESOLUTION_FACTOR; // JMS_GFX
+	LaserBlock.pixoffs = RES_SCALE(ARILOU_OFFSET);
 	LaserBlock.color = BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x0A), 0x0E);
 	LaserArray[0] = initialize_laser (&LaserBlock);
 
@@ -315,7 +315,7 @@ arilou_intelligence (ELEMENT *ShipPtr, E
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	StarShipPtr->ship_input_state |= THRUST;
 
-	ObjectsOfConcern[ENEMY_SHIP_INDEX].MoveState = ENTICE;
+	 ObjectsOfConcern[ENEMY_SHIP_INDEX].MoveState = ENTICE;
 	ship_intelligence (ShipPtr, ObjectsOfConcern, ConcernCounter);
 
 	if (StarShipPtr->special_counter == 0)
@@ -344,10 +344,10 @@ arilou_intelligence (ELEMENT *ShipPtr, E
 				IsTrackingWeapon = FALSE;
 
 			if (((lpEvalDesc->ObjectPtr->state_flags & PLAYER_SHIP) /* means IMMEDIATE WEAPON */
-				 || (IsTrackingWeapon && (lpEvalDesc->which_turn == 1
-										  || (lpEvalDesc->ObjectPtr->state_flags & CREW_OBJECT))) /* FIGHTERS!!! */
-				 || PlotIntercept (lpEvalDesc->ObjectPtr, ShipPtr, 3, 0))
-				&& !(TFB_Random () & 3))
+					|| (IsTrackingWeapon && (lpEvalDesc->which_turn == 1
+					|| (lpEvalDesc->ObjectPtr->state_flags & CREW_OBJECT))) /* FIGHTERS!!! */
+					|| PlotIntercept (lpEvalDesc->ObjectPtr, ShipPtr, 3, 0))
+					&& !(TFB_Random () & 3))
 			{
 				StarShipPtr->ship_input_state &= ~(LEFT | RIGHT | THRUST | WEAPON);
 				StarShipPtr->ship_input_state |= SPECIAL;
@@ -377,7 +377,6 @@ arilou_preprocess (ELEMENT *ElementPtr)
 				&& DeltaEnergy (ElementPtr, -SPECIAL_ENERGY_COST))
 		{
 			/* Special key is pressed; start teleport */
-#define HYPER_LIFE 5
 			ZeroVelocityComponents (&ElementPtr->velocity);
 			StarShipPtr->cur_status_flags &=
 					~(SHIP_AT_MAX_SPEED | LEFT | RIGHT | THRUST | WEAPON);
@@ -438,31 +437,24 @@ arilou_preprocess (ELEMENT *ElementPtr)
 				else
 					ElementPtr->next.image.frame =
 							IncFrameIndex (ElementPtr->next.image.frame);
-			}
-			else
-			{ // JMS: Reduce the odds of teleporting into Sa-Matra.
-                if (LOBYTE (GLOBAL (CurrentActivity)) == IN_LAST_BATTLE) {
-                    SDWORD dist = 0;
+			} else { // JMS: Reduce the odds of teleporting into Sa-Matra.
+				if (LOBYTE (GLOBAL (CurrentActivity)) == IN_LAST_BATTLE) {
+					SDWORD dist = 0;
 					SDWORD dx, dy;
-                    
                     do {
-                        ElementPtr->next.location.x =
-                            WRAP_X (DISPLAY_ALIGN_X (TFB_Random ()));
-                        ElementPtr->next.location.y =
-                            WRAP_Y (DISPLAY_ALIGN_Y (TFB_Random ()));
+                        ElementPtr->next.location.x = WRAP_X (DISPLAY_ALIGN_X (TFB_Random ()));
+                        ElementPtr->next.location.y = WRAP_Y (DISPLAY_ALIGN_Y (TFB_Random ()));
                         
                         dx = ((SDWORD)ElementPtr->next.location.x - (LOG_SPACE_WIDTH >> 1));
                         dy = ((SDWORD)ElementPtr->next.location.y - (LOG_SPACE_HEIGHT >> 1));
                         
-                        dist = sqrt(dx*dx + dy*dy);
-                        
-                    } while (dist < (2800 << RESOLUTION_FACTOR));
+                        dist = sqrt(dx*dx + dy*dy);                        
+                    } 
+					while (dist < (RES_SCALE(2800)));
                 } else {
-                    ElementPtr->next.location.x =
-						WRAP_X (DISPLAY_ALIGN_X (TFB_Random ()));
-                    ElementPtr->next.location.y =
-						WRAP_Y (DISPLAY_ALIGN_Y (TFB_Random ()));
-                }
+                    ElementPtr->next.location.x = WRAP_X (DISPLAY_ALIGN_X (TFB_Random ()));
+					ElementPtr->next.location.y = WRAP_Y (DISPLAY_ALIGN_Y (TFB_Random ()));
+				}
 			}
 		}
 
@@ -473,30 +465,17 @@ arilou_preprocess (ELEMENT *ElementPtr)
 RACE_DESC*
 init_arilou (void)
 {
+	
+	static RACE_DESC arilou_desc;
 	RACE_DESC *RaceDescPtr;
+	
+	arilou_desc = (RESOLUTION_FACTOR == 0 ? arilou_desc1x : (RESOLUTION_FACTOR == 1 ? arilou_desc2x : arilou_desc4x));
+
+	arilou_desc.preprocess_func = arilou_preprocess;
+	arilou_desc.init_weapon_func = initialize_autoaim_laser;
+	arilou_desc.cyborg_control.intelligence_func = arilou_intelligence;
+	RaceDescPtr = &arilou_desc;
 
-	// JMS_GFX: A rather clumsy way of giving ship correct stats at hi-res mode
-	if (RESOLUTION_FACTOR == 0)
-	{
-		arilou_desc.preprocess_func = arilou_preprocess;
-		arilou_desc.init_weapon_func = initialize_autoaim_laser;
-		arilou_desc.cyborg_control.intelligence_func = arilou_intelligence;
-		RaceDescPtr = &arilou_desc;
-	}
-	else if (RESOLUTION_FACTOR == 1)
-	{
-		arilou_desc_2xres.preprocess_func = arilou_preprocess;
-		arilou_desc_2xres.init_weapon_func = initialize_autoaim_laser;
-		arilou_desc_2xres.cyborg_control.intelligence_func = arilou_intelligence;
-		RaceDescPtr = &arilou_desc_2xres;
-	}
-	else
-	{
-		arilou_desc_4xres.preprocess_func = arilou_preprocess;
-		arilou_desc_4xres.init_weapon_func = initialize_autoaim_laser;
-		arilou_desc_4xres.cyborg_control.intelligence_func = arilou_intelligence;
-		RaceDescPtr = &arilou_desc_4xres;
-	}
 	return (RaceDescPtr);
 }
 
diff -ruNp src.hd/uqm/ships/arilou/arilou.h src/uqm/ships/arilou/arilou.h
--- src.hd/uqm/ships/arilou/arilou.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/arilou/arilou.h	2017-12-29 00:57:51 -0800
@@ -17,7 +17,15 @@
 #ifndef ARILOU_H
 #define ARILOU_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_arilou (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* ARILOU_H */
 
diff -ruNp src.hd/uqm/ships/arilou/icode.h src/uqm/ships/arilou/icode.h
--- src.hd/uqm/ships/arilou/icode.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/arilou/icode.h	2017-12-29 00:57:51 -0800
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define ARILOU_CODE "ship.arilou.code"
diff -ruNp src.hd/uqm/ships/arilou/resinst.h src/uqm/ships/arilou/resinst.h
--- src.hd/uqm/ships/arilou/resinst.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/arilou/resinst.h	2017-12-29 00:57:51 -0800
@@ -1,14 +1,16 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define ARILOU_BIG_MASK_PMAP_ANIM "ship.arilou.graphics.skiff.large"
 #define ARILOU_CAPTAIN_MASK_PMAP_ANIM "ship.arilou.graphics.captain"
 #define ARILOU_ICON_MASK_PMAP_ANIM "ship.arilou.icons"
 #define ARILOU_MED_MASK_PMAP_ANIM "ship.arilou.graphics.skiff.medium"
 #define ARILOU_MICON_MASK_PMAP_ANIM "ship.arilou.meleeicons"
+#define ARILOU_RACE_STRINGS "ship.arilou.text"
+#define ARILOU_SHIP_SOUNDS "ship.arilou.sounds"
 #define ARILOU_SML_MASK_PMAP_ANIM "ship.arilou.graphics.skiff.small"
+#define ARILOU_VICTORY_SONG "ship.arilou.ditty"
 #define WARP_BIG_MASK_PMAP_ANIM "ship.arilou.graphics.warp.large"
 #define WARP_MED_MASK_PMAP_ANIM "ship.arilou.graphics.warp.medium"
 #define WARP_SML_MASK_PMAP_ANIM "ship.arilou.graphics.warp.small"
-#define ARILOU_RACE_STRINGS "ship.arilou.text"
-#define ARILOU_SHIP_SOUNDS "ship.arilou.sounds"
-#define ARILOU_VICTORY_SONG "ship.arilou.ditty"
-
-#include "icode.h"
diff -ruNp src.hd/uqm/ships/blackurq/Makeinfo src/uqm/ships/blackurq/Makeinfo
--- src.hd/uqm/ships/blackurq/Makeinfo	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/blackurq/Makeinfo	2017-12-29 00:57:51 -0800
@@ -1 +1,2 @@
 uqm_CFILES="blackurq.c"
+uqm_HFILES="blackurq.h icode.h resinst.h"
diff -ruNp src.hd/uqm/ships/blackurq/blackurq.c src/uqm/ships/blackurq/blackurq.c
--- src.hd/uqm/ships/blackurq/blackurq.c	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/blackurq/blackurq.c	2017-12-29 00:57:51 -0800
@@ -22,28 +22,59 @@
 
 #include "uqm/globdata.h"
 
-//remove me -jpw
-
+// Core characteristics
 #define MAX_CREW MAX_CREW_SIZE
 #define MAX_ENERGY MAX_ENERGY_SIZE
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 6
-#define SPECIAL_ENERGY_COST (MAX_ENERGY_SIZE / 2)
 #define ENERGY_WAIT 4
 #define MAX_THRUST 30
 #define THRUST_INCREMENT 6
 #define TURN_WAIT 4
 #define THRUST_WAIT 6
+#define SHIP_MASS 10
+
+// Buzzsaw
+#define WEAPON_ENERGY_COST 6
 #define WEAPON_WAIT 6
+#define MISSILE_OFFSET RES_SCALE(9)
+#define KOHR_AH_OFFSET RES_SCALE(28)
+#define MISSILE_SPEED RES_SCALE(64)
+#define MISSILE_LIFE 64
+		/* actually, it's as long as you hold the button down.*/
+#define MISSILE_HITS 10
+#define MISSILE_DAMAGE 4
+#define SAW_RATE 0
+#define MAX_SAWS 8
+#define ACTIVATE_RANGE RES_SCALE(224)
+		/* Originally SPACE_WIDTH - the distance within which
+		 * stationary sawblades will home */
+#define TRACK_WAIT 4
+#define FRAGMENT_SPEED MISSILE_SPEED
+#define FRAGMENT_LIFE 10
+#define FRAGMENT_RANGE (FRAGMENT_LIFE * FRAGMENT_SPEED)
+
+// F.R.I.E.D.
+#define SPECIAL_ENERGY_COST (MAX_ENERGY_SIZE / 2)
 #define SPECIAL_WAIT 9
+#define GAS_OFFSET RES_SCALE(2)
+#define GAS_SPEED RES_SCALE(16)
+#define GAS_RATE 2 /* Controls animation of the gas cloud decay - the decay
+                    * animation advances one frame every GAS_RATE frames. */
+#define GAS_HITS 100
+#define GAS_DAMAGE 3
+#define GAS_ALT_DAMAGE 50
+#define NUM_GAS_CLOUDS 16
 
-#define SHIP_MASS 10
-#define MISSILE_SPEED (64 << RESOLUTION_FACTOR) // JMS_GFX
-#define MISSILE_LIFE 64 /* actually, it's as long as you hold the button down.*/
+// HD
+#define MAX_THRUST_2XRES 60			// JMS_GFX
+#define THRUST_INCREMENT_2XRES 12	// JMS_GFX
+#define MAX_THRUST_4XRES 120		// JMS_GFX
+#define THRUST_INCREMENT_4XRES 24	// JMS_GFX
 
-static RACE_DESC black_urquan_desc =
+static RACE_DESC black_urquan_desc1x =
 {
 	{ /* SHIP_INFO */
+		"marauder",
 		FIRES_FORE,
 		30, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -112,13 +143,11 @@ static RACE_DESC black_urquan_desc =
 	0, /* CodeRef */
 };
 
-#define MAX_THRUST_2XRES 60			// JMS_GFX
-#define THRUST_INCREMENT_2XRES 12	// JMS_GFX
-
 // JMS_GFX
-static RACE_DESC black_urquan_desc_2xres =
+static RACE_DESC black_urquan_desc2x =
 {
 	{ /* SHIP_INFO */
+		"marauder",
 		FIRES_FORE,
 		30, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -187,13 +216,11 @@ static RACE_DESC black_urquan_desc_2xres
 	0, /* CodeRef */
 };
 
-#define MAX_THRUST_4XRES 120		// JMS_GFX
-#define THRUST_INCREMENT_4XRES 24	// JMS_GFX
-
 // JMS_GFX
-static RACE_DESC black_urquan_desc_4xres =
+static RACE_DESC black_urquan_desc4x =
 {
 	{ /* SHIP_INFO */
+		"marauder",
 		FIRES_FORE,
 		30, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -262,9 +289,6 @@ static RACE_DESC black_urquan_desc_4xres
 	0, /* CodeRef */
 };
 
-#define SAW_RATE 0
-#define MAX_SAWS 8
-
 static void
 spin_preprocess (ELEMENT *ElementPtr)
 {
@@ -303,8 +327,6 @@ spin_preprocess (ELEMENT *ElementPtr)
 	UnlockElement (StarShipPtr->hShip);
 }
 
-#define TRACK_WAIT 4
-
 static void
 buzztrack_preprocess (ELEMENT *ElementPtr)
 {
@@ -321,8 +343,7 @@ buzztrack_preprocess (ELEMENT *ElementPt
 		}
 		else
 		{
-#define ACTIVATE_RANGE (224 << RESOLUTION_FACTOR) /* Originally SPACE_WIDTH */ // JMS_GFX
-			SDWORD delta_x, delta_y;
+			SIZE delta_x, delta_y;
 			ELEMENT *eptr;
 
 			LockElement (ElementPtr->hTarget, &eptr);
@@ -355,7 +376,7 @@ buzztrack_preprocess (ELEMENT *ElementPt
 			{
 				ElementPtr->thrust_wait = TRACK_WAIT;
 				SetVelocityVector (&ElementPtr->velocity,
-						DISPLAY_TO_WORLD (2 << RESOLUTION_FACTOR), facing); // JMS_GFX
+						DISPLAY_TO_WORLD (RES_SCALE(2)), facing);
 			}
 		}
 	}
@@ -383,7 +404,8 @@ decelerate_preprocess (ELEMENT *ElementP
 static void
 splinter_preprocess (ELEMENT *ElementPtr)
 {
-	ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->current.image.frame);
+	ElementPtr->next.image.frame =
+			IncFrameIndex (ElementPtr->current.image.frame);
 	ElementPtr->state_flags |= CHANGING;
 }
 
@@ -398,7 +420,8 @@ buzzsaw_collision (ELEMENT *ElementPtr0,
 		ElementPtr0->state_flags &= ~DISAPPEARING;
 		ElementPtr0->state_flags |= NONSOLID | CHANGING;
 		ElementPtr0->life_span = 5;
-		ElementPtr0->next.image.frame = SetAbsFrameIndex (ElementPtr0->current.image.frame, 2);
+		ElementPtr0->next.image.frame =
+				SetAbsFrameIndex (ElementPtr0->current.image.frame, 2);
 
 		ElementPtr0->preprocess_func = splinter_preprocess;
 	}
@@ -436,7 +459,8 @@ buzzsaw_postprocess (ELEMENT *ElementPtr
 		primIndex = ListElementPtr->PrimIndex;
 		*ListElementPtr = *ElementPtr;
 		ListElementPtr->PrimIndex = primIndex;
-		(GLOBAL (DisplayArray))[primIndex] = (GLOBAL (DisplayArray))[ElementPtr->PrimIndex];
+		(GLOBAL (DisplayArray))[primIndex] =
+				(GLOBAL (DisplayArray))[ElementPtr->PrimIndex];
 		ListElementPtr->current = ListElementPtr->next;
 		InitIntersectStartPoint (ListElementPtr);
 		InitIntersectEndPoint (ListElementPtr);
@@ -457,10 +481,6 @@ buzzsaw_postprocess (ELEMENT *ElementPtr
 static COUNT
 initialize_buzzsaw (ELEMENT *ShipPtr, HELEMENT SawArray[])
 {
-#define MISSILE_HITS 10
-#define MISSILE_DAMAGE 4
-#define MISSILE_OFFSET (9 << RESOLUTION_FACTOR) // JMS_GFX
-#define KOHR_AH_OFFSET (28 << RESOLUTION_FACTOR) // JMS_GFX
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -473,7 +493,7 @@ initialize_buzzsaw (ELEMENT *ShipPtr, HE
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = KOHR_AH_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED; // JMS_GFX
+	MissileBlock.speed = MISSILE_SPEED;
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -502,7 +522,7 @@ black_urquan_intelligence (ELEMENT *Ship
 {
 	EVALUATE_DESC *lpEvalDesc;
 	STARSHIP *StarShipPtr;
-	
+
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_WEAPON_INDEX];
 	if (lpEvalDesc->ObjectPtr
 			&& lpEvalDesc->MoveState == ENTICE
@@ -510,7 +530,8 @@ black_urquan_intelligence (ELEMENT *Ship
 			&& lpEvalDesc->which_turn <= 8)
 		lpEvalDesc->MoveState = PURSUE;
 
-	ship_intelligence (ShipPtr, ObjectsOfConcern, ConcernCounter);
+	ship_intelligence (ShipPtr,
+			ObjectsOfConcern, ConcernCounter);
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	StarShipPtr->ship_input_state &= ~SPECIAL;
@@ -524,9 +545,6 @@ black_urquan_intelligence (ELEMENT *Ship
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
 	if (lpEvalDesc->ObjectPtr)
 	{
-#define FRAGMENT_LIFE 10
-#define FRAGMENT_SPEED MISSILE_SPEED
-#define FRAGMENT_RANGE (FRAGMENT_LIFE * FRAGMENT_SPEED)
 		HELEMENT h, hNext;
 		ELEMENT *BuzzSawPtr;
 
@@ -578,8 +596,6 @@ black_urquan_intelligence (ELEMENT *Ship
 	}
 }
 
-#define GAS_RATE 2
-
 static void
 gas_cloud_preprocess (ELEMENT *ElementPtr)
 {
@@ -595,8 +611,6 @@ gas_cloud_preprocess (ELEMENT *ElementPt
 	}
 }
 
-#define GAS_DAMAGE 3
-
 static void
 gas_cloud_collision (ELEMENT *ElementPtr0, POINT *pPt0,
 		ELEMENT *ElementPtr1, POINT *pPt1)
@@ -604,7 +618,7 @@ gas_cloud_collision (ELEMENT *ElementPtr
 	if (ElementPtr1->state_flags & PLAYER_SHIP)
 		ElementPtr0->mass_points = GAS_DAMAGE;
 	else
-		ElementPtr0->mass_points = 50;
+		ElementPtr0->mass_points = GAS_ALT_DAMAGE;
 
 	weapon_collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
 }
@@ -612,10 +626,6 @@ gas_cloud_collision (ELEMENT *ElementPtr
 static void
 spawn_gas_cloud (ELEMENT *ElementPtr)
 {
-#define GAS_SPEED (16 << RESOLUTION_FACTOR) // JMS_GFX
-#define GAS_HITS 100
-#define GAS_OFFSET (2 << RESOLUTION_FACTOR) // JMS_GFX
-#define NUM_GAS_CLOUDS 16
 	SDWORD dx, dy;
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
@@ -627,7 +637,7 @@ spawn_gas_cloud (ELEMENT *ElementPtr)
 	MissileBlock.index = 0;
 	MissileBlock.sender = ElementPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
-	MissileBlock.pixoffs = 20 << RESOLUTION_FACTOR; // JMS_GFX
+	MissileBlock.pixoffs = RES_SCALE(20);
 	MissileBlock.speed = GAS_SPEED;
 	MissileBlock.hit_points = GAS_HITS;
 	MissileBlock.damage = GAS_DAMAGE;
@@ -697,32 +707,16 @@ black_urquan_preprocess (ELEMENT *Elemen
 RACE_DESC*
 init_black_urquan (void)
 {
+	static RACE_DESC black_urquan_desc;
 	RACE_DESC *RaceDescPtr;
 
-	// JMS_GFX: A rather clumsy way of giving ship correct stats at hi-res mode
-	if (RESOLUTION_FACTOR == 0)
-	{
-		black_urquan_desc.preprocess_func = black_urquan_preprocess;
-		black_urquan_desc.postprocess_func = black_urquan_postprocess;
-		black_urquan_desc.init_weapon_func = initialize_buzzsaw;
-		black_urquan_desc.cyborg_control.intelligence_func = black_urquan_intelligence;
-		RaceDescPtr = &black_urquan_desc;
-	}
-	else if (RESOLUTION_FACTOR == 1)
-	{
-		black_urquan_desc_2xres.preprocess_func = black_urquan_preprocess;
-		black_urquan_desc_2xres.postprocess_func = black_urquan_postprocess;
-		black_urquan_desc_2xres.init_weapon_func = initialize_buzzsaw;
-		black_urquan_desc_2xres.cyborg_control.intelligence_func = black_urquan_intelligence;
-		RaceDescPtr = &black_urquan_desc_2xres;
-	}
-	else
-	{
-		black_urquan_desc_4xres.preprocess_func = black_urquan_preprocess;
-		black_urquan_desc_4xres.postprocess_func = black_urquan_postprocess;
-		black_urquan_desc_4xres.init_weapon_func = initialize_buzzsaw;
-		black_urquan_desc_4xres.cyborg_control.intelligence_func = black_urquan_intelligence;
-		RaceDescPtr = &black_urquan_desc_4xres;
-	}
+	black_urquan_desc = (RESOLUTION_FACTOR == 0 ? black_urquan_desc1x : (RESOLUTION_FACTOR == 1 ? black_urquan_desc2x : black_urquan_desc4x));
+
+	black_urquan_desc.preprocess_func = black_urquan_preprocess;
+	black_urquan_desc.postprocess_func = black_urquan_postprocess;
+	black_urquan_desc.init_weapon_func = initialize_buzzsaw;
+	black_urquan_desc.cyborg_control.intelligence_func = black_urquan_intelligence;
+	RaceDescPtr = &black_urquan_desc;
+
 	return (RaceDescPtr);
 }
diff -ruNp src.hd/uqm/ships/blackurq/blackurq.h src/uqm/ships/blackurq/blackurq.h
--- src.hd/uqm/ships/blackurq/blackurq.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/blackurq/blackurq.h	2017-12-29 00:57:51 -0800
@@ -17,7 +17,15 @@
 #ifndef BLACKURQ_H
 #define BLACKURQ_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_black_urquan (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* BLACKURQ_H */
 
diff -ruNp src.hd/uqm/ships/blackurq/icode.h src/uqm/ships/blackurq/icode.h
--- src.hd/uqm/ships/blackurq/icode.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/blackurq/icode.h	2017-12-29 00:57:51 -0800
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define KOHR_AH_CODE "ship.kohrah.code"
diff -ruNp src.hd/uqm/ships/blackurq/resinst.h src/uqm/ships/blackurq/resinst.h
--- src.hd/uqm/ships/blackurq/resinst.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/blackurq/resinst.h	2017-12-29 00:57:51 -0800
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define BUZZSAW_BIG_MASK_PMAP_ANIM "ship.kohrah.graphics.buzzsaw.large"
 #define BUZZSAW_MED_MASK_PMAP_ANIM "ship.kohrah.graphics.buzzsaw.medium"
 #define BUZZSAW_SML_MASK_PMAP_ANIM "ship.kohrah.graphics.buzzsaw.small"
@@ -9,9 +13,7 @@
 #define KOHR_AH_ICON_MASK_PMAP_ANIM "ship.kohrah.icons"
 #define KOHR_AH_MED_MASK_PMAP_ANIM "ship.kohrah.graphics.marauder.medium"
 #define KOHR_AH_MICON_MASK_PMAP_ANIM "ship.kohrah.meleeicons"
-#define KOHR_AH_SML_MASK_PMAP_ANIM "ship.kohrah.graphics.marauder.small"
 #define KOHR_AH_RACE_STRINGS "ship.kohrah.text"
 #define KOHR_AH_SHIP_SOUNDS "ship.kohrah.sounds"
+#define KOHR_AH_SML_MASK_PMAP_ANIM "ship.kohrah.graphics.marauder.small"
 #define KOHR_AH_VICTORY_SONG "ship.kohrah.ditty"
-
-#include "icode.h"
diff -ruNp src.hd/uqm/ships/chenjesu/Makeinfo src/uqm/ships/chenjesu/Makeinfo
--- src.hd/uqm/ships/chenjesu/Makeinfo	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/chenjesu/Makeinfo	2017-12-29 00:57:51 -0800
@@ -1 +1,2 @@
 uqm_CFILES="chenjesu.c"
+uqm_HFILES="chenjesu.h icode.h resinst.h"
diff -ruNp src.hd/uqm/ships/chenjesu/chenjesu.c src/uqm/ships/chenjesu/chenjesu.c
--- src.hd/uqm/ships/chenjesu/chenjesu.c	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/chenjesu/chenjesu.c	2017-12-29 00:57:51 -0800
@@ -22,31 +22,60 @@
 
 #include "uqm/globdata.h"
 #include "libs/mathlib.h"
-#include "libs/log.h"
-
 
+// Core characteristics
 #define MAX_CREW 36
 #define MAX_ENERGY 30
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 5
-#define SPECIAL_ENERGY_COST MAX_ENERGY
 #define ENERGY_WAIT 4
 #define MAX_THRUST /* DISPLAY_TO_WORLD (7) */ 27
 #define THRUST_INCREMENT /* DISPLAY_TO_WORLD (2) */ 3
-#define TURN_WAIT 6
 #define THRUST_WAIT 4
+#define TURN_WAIT 6
+#define SHIP_MASS 10
+
+// Photon Shard
+#define WEAPON_ENERGY_COST 5
 #define WEAPON_WAIT 0
-#define SPECIAL_WAIT 0
+#define CHENJESU_OFFSET RES_SCALE(16)
+#define MISSILE_OFFSET 0
+#define MISSILE_SPEED DISPLAY_TO_WORLD (RES_SCALE(16))
+#define MISSILE_LIFE 90
+		/* actually, it's as long as you hold the button down. */
+#define MISSILE_HITS 10
+#define MISSILE_DAMAGE 6
+#define NUM_SPARKLES 8
+
+// Shrapnel
+#define FRAGMENT_OFFSET RES_SCALE(2)
+#define NUM_FRAGMENTS 8
+#define FRAGMENT_LIFE 10
+#define FRAGMENT_SPEED MISSILE_SPEED
+#define FRAGMENT_RANGE (FRAGMENT_LIFE * FRAGMENT_SPEED)
+		/* This bit is for the cyborg only. */
+#define FRAGMENT_HITS 1
+#define FRAGMENT_DAMAGE 2
 
+// DOGI
+#define SPECIAL_ENERGY_COST MAX_ENERGY
+#define SPECIAL_WAIT 0
+#define DOGGY_OFFSET RES_SCALE(18) + 5 * RESOLUTION_FACTOR
+#define DOGGY_SPEED DISPLAY_TO_WORLD (RES_SCALE(8))
+#define ENERGY_DRAIN 10
 #define MAX_DOGGIES 4
+#define DOGGY_HITS 3
+#define DOGGY_MASS 4
 
-#define SHIP_MASS 10
-#define MISSILE_SPEED DISPLAY_TO_WORLD (16 << RESOLUTION_FACTOR)
-#define MISSILE_LIFE (90) /* actually, it's as long as you hold the button down. */
+// HD
+#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (14) */ 54 // JMS_GFX
+#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (4) */ 6 // JMS_GFX
+#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (28) */ 108 // JMS_GFX
+#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (8) */ 12 // JMS_GFX
 
-static RACE_DESC chenjesu_desc =
+static RACE_DESC chenjesu_desc1x =
 {
 	{ /* SHIP_INFO */
+		"broodhome",
 		FIRES_FORE | SEEKING_SPECIAL | SEEKING_WEAPON,
 		28, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -115,13 +144,11 @@ static RACE_DESC chenjesu_desc =
 	0, /* CodeRef */
 };
 
-#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (14) */ 54 // JMS_GFX
-#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (4) */ 6 // JMS_GFX
-
 // JMS_GFX
-static RACE_DESC chenjesu_desc_2xres =
+static RACE_DESC chenjesu_desc2x =
 {
 	{ /* SHIP_INFO */
+		"broodhome",
 		FIRES_FORE | SEEKING_SPECIAL | SEEKING_WEAPON,
 		28, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -190,13 +217,11 @@ static RACE_DESC chenjesu_desc_2xres =
 	0, /* CodeRef */
 };
 
-#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (28) */ 108 // JMS_GFX
-#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (8) */ 12 // JMS_GFX
-
 // JMS_GFX
-static RACE_DESC chenjesu_desc_4xres =
+static RACE_DESC chenjesu_desc4x =
 {
 	{ /* SHIP_INFO */
+		"broodhome",
 		FIRES_FORE | SEEKING_SPECIAL | SEEKING_WEAPON,
 		28, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -265,17 +290,9 @@ static RACE_DESC chenjesu_desc_4xres =
 	0, /* CodeRef */
 };
 
-#define FRAGMENT_LIFE (10) // JMS_GFX
-#define FRAGMENT_SPEED MISSILE_SPEED
-#define FRAGMENT_RANGE (FRAGMENT_LIFE * FRAGMENT_SPEED)
-
 static void
 crystal_postprocess (ELEMENT *ElementPtr)
 {
-#define FRAGMENT_HITS 1
-#define FRAGMENT_DAMAGE 2
-#define FRAGMENT_OFFSET (2 << RESOLUTION_FACTOR) // JMS_GFX
-#define NUM_FRAGMENTS 8
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -287,7 +304,7 @@ crystal_postprocess (ELEMENT *ElementPtr
 	MissileBlock.sender = ElementPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = 0;
-	MissileBlock.speed = FRAGMENT_SPEED; // JMS_GFX
+	MissileBlock.speed = FRAGMENT_SPEED;
 	MissileBlock.hit_points = FRAGMENT_HITS;
 	MissileBlock.damage = FRAGMENT_DAMAGE;
 	MissileBlock.life = FRAGMENT_LIFE;
@@ -361,7 +378,6 @@ crystal_collision (ELEMENT *ElementPtr0,
 	{
 		ELEMENT *BlastElementPtr;
 
-#define NUM_SPARKLES 8
 		LockElement (hBlastElement, &BlastElementPtr);
 		BlastElementPtr->current.location = ElementPtr1->current.location;
 
@@ -380,11 +396,6 @@ crystal_collision (ELEMENT *ElementPtr0,
 	}
 }
 
-// JMS_GFX: Let's ensure the doggy doesn't spawn on top of Chenjesu ship and die.
-#define DOGGY_OFFSET ((18 << RESOLUTION_FACTOR) + 5 * RESOLUTION_FACTOR)
-
-#define DOGGY_SPEED DISPLAY_TO_WORLD (8 << RESOLUTION_FACTOR) // JMS_GFX
-
 static void
 doggy_preprocess (ELEMENT *ElementPtr)
 {
@@ -399,8 +410,10 @@ doggy_preprocess (ELEMENT *ElementPtr)
 		COUNT facing, orig_facing;
 		SIZE delta_facing;
 
-		facing = orig_facing = NORMALIZE_FACING (ANGLE_TO_FACING (GetVelocityTravelAngle (&ElementPtr->velocity)));
-		
+		facing = orig_facing =
+				NORMALIZE_FACING (ANGLE_TO_FACING (
+				GetVelocityTravelAngle (&ElementPtr->velocity)
+				));
 		if ((delta_facing = TrackShip (ElementPtr, &facing)) < 0)
 			facing = NORMALIZE_FACING (TFB_Random ());
 		else
@@ -414,7 +427,8 @@ doggy_preprocess (ELEMENT *ElementPtr)
 					ShipPtr->current.location.y -
 					ElementPtr->current.location.y)
 					));
-			delta_facing = NORMALIZE_FACING (facing - GetFrameIndex (ShipPtr->current.image.frame));
+			delta_facing = NORMALIZE_FACING (facing -
+					GetFrameIndex (ShipPtr->current.image.frame));
 			UnlockElement (ElementPtr->hTarget);
 
 			if (delta_facing > ANGLE_TO_FACING (HALF_CIRCLE - OCTANT) &&
@@ -430,9 +444,10 @@ doggy_preprocess (ELEMENT *ElementPtr)
 		}
 
 		if (facing != orig_facing)
-			SetVelocityVector (&ElementPtr->velocity, DOGGY_SPEED, facing);
+			SetVelocityVector (&ElementPtr->velocity,
+					DOGGY_SPEED, facing);
 	}
-	
+
 	// JMS_GFX: Doggy is animated in hi-res modes
 	if (RESOLUTION_FACTOR != 0)
 	{
@@ -451,7 +466,7 @@ doggy_preprocess (ELEMENT *ElementPtr)
 
 			ElementPtr->turn_wait = 1;
 		}
-	}
+ 	}
 }
 
 static void
@@ -466,14 +481,11 @@ doggy_death (ELEMENT *ElementPtr)
 
 	ElementPtr->state_flags &= ~DISAPPEARING;
 	ElementPtr->state_flags |= NONSOLID | FINITE_LIFE;
-	
 	// JMS_GFX: Doggy's dying animation starts at different frame in hi-res modes.
-	if (RESOLUTION_FACTOR != 0)
-	{
+	if (RESOLUTION_FACTOR != 0){
 		ElementPtr->current.image.frame = SetRelFrameIndex (
 			ElementPtr->current.image.frame, 12);
 	}
-	
 	ElementPtr->life_span = 6;
 	ElementPtr->preprocess_func = animate;
 	ElementPtr->death_func = NULL;
@@ -487,7 +499,6 @@ static void
 doggy_collision (ELEMENT *ElementPtr0, POINT *pPt0,
 		ELEMENT *ElementPtr1, POINT *pPt1)
 {
-#define ENERGY_DRAIN 10
 	collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
 	if ((ElementPtr1->state_flags & PLAYER_SHIP)
 			&& !elementsOfSamePlayer (ElementPtr0, ElementPtr1))
@@ -508,8 +519,6 @@ doggy_collision (ELEMENT *ElementPtr0, P
 		ElementPtr0->thrust_wait += COLLISION_THRUST_WAIT << 1;
 }
 
-#define CHENJESU_OFFSET (16 << RESOLUTION_FACTOR) // JMS_GFX
-
 static void
 spawn_doggy (ELEMENT *ElementPtr)
 {
@@ -525,8 +534,8 @@ spawn_doggy (ELEMENT *ElementPtr)
 
 		PutElement (hDoggyElement);
 		LockElement (hDoggyElement, &DoggyElementPtr);
-		DoggyElementPtr->hit_points = 3;
-		DoggyElementPtr->mass_points = 4;
+		DoggyElementPtr->hit_points = DOGGY_HITS;
+		DoggyElementPtr->mass_points = DOGGY_MASS;
 		DoggyElementPtr->thrust_wait = 0;
 		DoggyElementPtr->playerNr = ElementPtr->playerNr;
 		DoggyElementPtr->state_flags = APPEARING;
@@ -549,7 +558,8 @@ spawn_doggy (ELEMENT *ElementPtr)
 		DoggyElementPtr->current.image.farray = StarShipPtr->RaceDescPtr->ship_data.special;
 		DoggyElementPtr->current.image.frame = StarShipPtr->RaceDescPtr->ship_data.special[0];
 
-		SetVelocityVector (&DoggyElementPtr->velocity, DOGGY_SPEED, NORMALIZE_FACING (ANGLE_TO_FACING (angle)));
+		SetVelocityVector (&DoggyElementPtr->velocity,
+				DOGGY_SPEED, NORMALIZE_FACING (ANGLE_TO_FACING (angle)));
 
 		SetElementStarShip (DoggyElementPtr, StarShipPtr);
 
@@ -567,7 +577,7 @@ chenjesu_intelligence (ELEMENT *ShipPtr,
 {
 	EVALUATE_DESC *lpEvalDesc;
 	STARSHIP *StarShipPtr;
-	
+
 	static DWORD old_dist[NUM_SIDES] = {(DWORD)~0, (DWORD)~0};
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
@@ -577,7 +587,7 @@ chenjesu_intelligence (ELEMENT *ShipPtr,
 	if (lpEvalDesc->ObjectPtr)
 	{
 		STARSHIP *EnemyStarShipPtr;
-		
+
 		GetElementStarShip (lpEvalDesc->ObjectPtr, &EnemyStarShipPtr);
 		if ((lpEvalDesc->which_turn <= 16
 				&& MANEUVERABILITY (
@@ -588,7 +598,7 @@ chenjesu_intelligence (ELEMENT *ShipPtr,
 				) <= RESOLUTION_COMPENSATED(SLOW_SHIP) // JMS_GFX
 				&& WEAPON_RANGE (
 				&EnemyStarShipPtr->RaceDescPtr->cyborg_control
-				) >= (LONG_RANGE_WEAPON << RESOLUTION_FACTOR) * 3 / 4 // JMS_GFX
+				) >= RES_SCALE(LONG_RANGE_WEAPON) * 3 / 4 // JMS_GFX
 				&& (EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags & SEEKING_WEAPON)))
 			lpEvalDesc->MoveState = PURSUE;
 	}
@@ -634,9 +644,7 @@ chenjesu_intelligence (ELEMENT *ShipPtr,
 							 && PlotIntercept (CrystalPtr,
 								ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr,
 								CrystalPtr->life_span, 0) == 0));
-					}
-					else
-					{
+					} else {
 						DWORD curr_dist = 0;
 						SDWORD dx, dy;
 						
@@ -650,15 +658,12 @@ chenjesu_intelligence (ELEMENT *ShipPtr,
 						/*which_turn = PlotIntercept (CrystalPtr,
 							ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr,
 							CrystalPtr->life_span, FRAGMENT_RANGE / 3);*/
-					
 						crystal_would_miss = ((PlotIntercept (CrystalPtr,
 							ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr,
 							CrystalPtr->life_span, FRAGMENT_RANGE * 8) == 0)
 							|| curr_dist > old_dist[ShipPtr->playerNr]);
-							
 						old_dist[ShipPtr->playerNr] = curr_dist;
 					}
-					
 					if (crystal_would_miss)
 					{
 						StarShipPtr->ship_input_state &= ~WEAPON;
@@ -692,7 +697,6 @@ chenjesu_intelligence (ELEMENT *ShipPtr,
 			{
 				StarShipPtr->ship_input_state &= ~WEAPON;
 				old_dist[ShipPtr->playerNr] = (DWORD)~0;
-				
 				if (lpEvalDesc == &ObjectsOfConcern[ENEMY_WEAPON_INDEX])
 					StarShipPtr->weapon_counter = 3;
 			}
@@ -754,9 +758,6 @@ chenjesu_intelligence (ELEMENT *ShipPtr,
 static COUNT
 initialize_crystal (ELEMENT *ShipPtr, HELEMENT CrystalArray[])
 {
-#define MISSILE_HITS 10
-#define MISSILE_DAMAGE 6
-#define MISSILE_OFFSET 0
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -769,7 +770,7 @@ initialize_crystal (ELEMENT *ShipPtr, HE
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = CHENJESU_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED; // JMS_GFX
+	MissileBlock.speed = MISSILE_SPEED;
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -825,35 +826,18 @@ chenjesu_preprocess (ELEMENT *ElementPtr
 
 RACE_DESC*
 init_chenjesu (void)
-{
+{	
+	static RACE_DESC chenjesu_desc;
 	RACE_DESC *RaceDescPtr;
-
-	// JMS_GFX: A rather clumsy way of giving ship correct stats at hi-res mode
-	if (RESOLUTION_FACTOR == 0)
-	{
-		chenjesu_desc.preprocess_func = chenjesu_preprocess;
-		chenjesu_desc.postprocess_func = chenjesu_postprocess;
-		chenjesu_desc.init_weapon_func = initialize_crystal;
-		chenjesu_desc.cyborg_control.intelligence_func = chenjesu_intelligence;
-		RaceDescPtr = &chenjesu_desc;
-	}
-	else if (RESOLUTION_FACTOR == 1)
-	{
-		chenjesu_desc_2xres.preprocess_func = chenjesu_preprocess;
-		chenjesu_desc_2xres.postprocess_func = chenjesu_postprocess;
-		chenjesu_desc_2xres.init_weapon_func = initialize_crystal;
-		chenjesu_desc_2xres.cyborg_control.intelligence_func = chenjesu_intelligence;
-		RaceDescPtr = &chenjesu_desc_2xres;
-	}
-	else
-	{
-		chenjesu_desc_4xres.preprocess_func = chenjesu_preprocess;
-		chenjesu_desc_4xres.postprocess_func = chenjesu_postprocess;
-		chenjesu_desc_4xres.init_weapon_func = initialize_crystal;
-		chenjesu_desc_4xres.cyborg_control.intelligence_func = chenjesu_intelligence;
-		RaceDescPtr = &chenjesu_desc_4xres;
-	}
 	
+	chenjesu_desc = (RESOLUTION_FACTOR == 0 ? chenjesu_desc1x : (RESOLUTION_FACTOR == 1 ? chenjesu_desc2x : chenjesu_desc4x));
+
+	chenjesu_desc.preprocess_func = chenjesu_preprocess;
+	chenjesu_desc.postprocess_func = chenjesu_postprocess;
+	chenjesu_desc.init_weapon_func = initialize_crystal;
+	chenjesu_desc.cyborg_control.intelligence_func = chenjesu_intelligence;
+	RaceDescPtr = &chenjesu_desc;
+
 	return (RaceDescPtr);
 }
 
diff -ruNp src.hd/uqm/ships/chenjesu/chenjesu.h src/uqm/ships/chenjesu/chenjesu.h
--- src.hd/uqm/ships/chenjesu/chenjesu.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/chenjesu/chenjesu.h	2017-12-29 00:57:51 -0800
@@ -17,7 +17,15 @@
 #ifndef CHENJESU_H
 #define CHENJESU_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_chenjesu (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* CHENJESU_H */
 
diff -ruNp src.hd/uqm/ships/chenjesu/icode.h src/uqm/ships/chenjesu/icode.h
--- src.hd/uqm/ships/chenjesu/icode.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/chenjesu/icode.h	2017-12-29 00:57:51 -0800
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define CHENJESU_CODE "ship.chenjesu.code"
diff -ruNp src.hd/uqm/ships/chenjesu/resinst.h src/uqm/ships/chenjesu/resinst.h
--- src.hd/uqm/ships/chenjesu/resinst.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/chenjesu/resinst.h	2017-12-29 00:57:51 -0800
@@ -1,17 +1,19 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define CHENJESU_BIG_MASK_PMAP_ANIM "ship.chenjesu.graphics.broodhome.large"
 #define CHENJESU_CAPTAIN_MASK_PMAP_ANIM "ship.chenjesu.graphics.captain"
 #define CHENJESU_ICON_MASK_PMAP_ANIM "ship.chenjesu.icons"
 #define CHENJESU_MED_MASK_PMAP_ANIM "ship.chenjesu.graphics.broodhome.medium"
 #define CHENJESU_MICON_MASK_PMAP_ANIM "ship.chenjesu.meleeicons"
+#define CHENJESU_RACE_STRINGS "ship.chenjesu.text"
+#define CHENJESU_SHIP_SOUNDS "ship.chenjesu.sounds"
 #define CHENJESU_SML_MASK_PMAP_ANIM "ship.chenjesu.graphics.broodhome.small"
+#define CHENJESU_VICTORY_SONG "ship.chenjesu.ditty"
 #define DOGGY_BIG_MASK_PMAP_ANIM "ship.chenjesu.graphics.doggy.large"
 #define DOGGY_MED_MASK_PMAP_ANIM "ship.chenjesu.graphics.doggy.medium"
 #define DOGGY_SML_MASK_PMAP_ANIM "ship.chenjesu.graphics.doggy.small"
 #define SPARK_BIG_MASK_PMAP_ANIM "ship.chenjesu.graphics.spark.large"
 #define SPARK_MED_MASK_PMAP_ANIM "ship.chenjesu.graphics.spark.medium"
 #define SPARK_SML_MASK_PMAP_ANIM "ship.chenjesu.graphics.spark.small"
-#define CHENJESU_RACE_STRINGS "ship.chenjesu.text"
-#define CHENJESU_SHIP_SOUNDS "ship.chenjesu.sounds"
-#define CHENJESU_VICTORY_SONG "ship.chenjesu.ditty"
-
-#include "icode.h"
diff -ruNp src.hd/uqm/ships/chmmr/Makeinfo src/uqm/ships/chmmr/Makeinfo
--- src.hd/uqm/ships/chmmr/Makeinfo	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/chmmr/Makeinfo	2017-12-29 00:57:51 -0800
@@ -1 +1,2 @@
 uqm_CFILES="chmmr.c"
+uqm_HFILES="chmmr.h icode.h resinst.h"
diff -ruNp src.hd/uqm/ships/chmmr/chmmr.c src/uqm/ships/chmmr/chmmr.c
--- src.hd/uqm/ships/chmmr/chmmr.c	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/chmmr/chmmr.c	2017-12-29 00:57:51 -0800
@@ -24,27 +24,47 @@
 #include "uqm/globdata.h"
 #include "libs/mathlib.h"
 
-
+// Core characteristics
 #define MAX_CREW MAX_CREW_SIZE
 #define MAX_ENERGY MAX_ENERGY_SIZE
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 2
-#define SPECIAL_ENERGY_COST 1
 #define ENERGY_WAIT 1
 #define MAX_THRUST 35
 #define THRUST_INCREMENT 7
-#define TURN_WAIT 3
 #define THRUST_WAIT 5
-#define WEAPON_WAIT 0
-#define SPECIAL_WAIT 0
-
+#define TURN_WAIT 3
 #define SHIP_MASS 10
+
+// Laser
+#define WEAPON_ENERGY_COST 2
+#define WEAPON_WAIT 0
 #define CHMMR_OFFSET 18
 #define LASER_RANGE DISPLAY_TO_WORLD (150)
+#define NUM_CYCLES 4
+
+// Tractor Beam
+#define SPECIAL_ENERGY_COST 1
+#define SPECIAL_WAIT 0
+#define NUM_SHADOWS 5
 
-static RACE_DESC chmmr_desc =
+// Satellites
+#define NUM_SATELLITES 3
+#define SATELLITE_OFFSET DISPLAY_TO_WORLD (64 << RESOLUTION_FACTOR)
+#define SATELLITE_HITPOINTS 10
+#define SATELLITE_MASS 10
+#define DEFENSE_RANGE (UWORD)(64 << RESOLUTION_FACTOR)
+#define DEFENSE_WAIT 2
+
+// HD
+#define MAX_THRUST_2XRES 70
+#define THRUST_INCREMENT_2XRES 14
+#define MAX_THRUST_4XRES 140
+#define THRUST_INCREMENT_4XRES 28
+
+static RACE_DESC chmmr_desc1x =
 {
 	{ /* SHIP_INFO */
+		"avatar",
 		FIRES_FORE | IMMEDIATE_WEAPON | SEEKING_SPECIAL | POINT_DEFENSE,
 		30, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -114,13 +134,10 @@ static RACE_DESC chmmr_desc =
 };
 
 // JMS_GFX
-#define MAX_THRUST_2XRES 70
-#define THRUST_INCREMENT_2XRES 14
-
-// JMS_GFX
-static RACE_DESC chmmr_desc_2xres =
+static RACE_DESC chmmr_desc2x =
 {
 	{ /* SHIP_INFO */
+		"avatar",
 		FIRES_FORE | IMMEDIATE_WEAPON | SEEKING_SPECIAL | HEAVY_POINT_DEFENSE,
 		30, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -190,13 +207,10 @@ static RACE_DESC chmmr_desc_2xres =
 };
 
 // JMS_GFX
-#define MAX_THRUST_4XRES 140
-#define THRUST_INCREMENT_4XRES 28
-
-// JMS_GFX
-static RACE_DESC chmmr_desc_4xres =
+static RACE_DESC chmmr_desc4x =
 {
 	{ /* SHIP_INFO */
+		"avatar",
 		FIRES_FORE | IMMEDIATE_WEAPON | SEEKING_SPECIAL | HEAVY_POINT_DEFENSE,
 		30, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -272,8 +286,10 @@ animate (ELEMENT *ElementPtr)
 		--ElementPtr->turn_wait;
 	else
 	{
-		ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->current.image.frame);
+		ElementPtr->next.image.frame =
+				IncFrameIndex (ElementPtr->current.image.frame);
 		ElementPtr->state_flags |= CHANGING;
+
 		ElementPtr->turn_wait = ElementPtr->next_turn;
 	}
 }
@@ -295,9 +311,10 @@ laser_death (ELEMENT *ElementPtr)
 
 		LockElement (StarShipPtr->hShip, &ShipPtr);
 
-		dx = ElementPtr->current.location.x - ShipPtr->current.location.x;
-		dy = ElementPtr->current.location.y - ShipPtr->current.location.y;
-		
+		dx = ElementPtr->current.location.x
+				- ShipPtr->current.location.x;
+		dy = ElementPtr->current.location.y
+				- ShipPtr->current.location.y;
 		if (((BYTE)TFB_Random () & 0x07)
 				&& (dist = (long)dx * dx + (long)dy * dy) >=
 				(long)DISPLAY_TO_WORLD ((CHMMR_OFFSET + 10) << RESOLUTION_FACTOR) // JMS_GFX
@@ -309,10 +326,10 @@ laser_death (ELEMENT *ElementPtr)
 
 			LockElement (hIonSpots, &IonSpotsPtr);
 			IonSpotsPtr->playerNr = ElementPtr->playerNr;
-			IonSpotsPtr->state_flags = FINITE_LIFE | NONSOLID | IGNORE_SIMILAR | APPEARING;
+			IonSpotsPtr->state_flags = FINITE_LIFE | NONSOLID
+					| IGNORE_SIMILAR | APPEARING;
 			IonSpotsPtr->turn_wait = IonSpotsPtr->next_turn = 0;
 			IonSpotsPtr->life_span = RES_CASE(9,9,14);
-			// BW: account for the extra frames in the hires version
 
 			angle = ARCTAN (dx, dy);
 			magnitude = ((COUNT)TFB_Random ()
@@ -336,7 +353,9 @@ laser_death (ELEMENT *ElementPtr)
 
 			SetElementStarShip (IonSpotsPtr, StarShipPtr);
 
-			SetPrimType (&(GLOBAL (DisplayArray))[IonSpotsPtr->PrimIndex], STAMP_PRIM);
+			SetPrimType (&(GLOBAL (DisplayArray))[
+					IonSpotsPtr->PrimIndex
+					], STAMP_PRIM);
 
 			UnlockElement (hIonSpots);
 			PutElement (hIonSpots);
@@ -349,7 +368,6 @@ laser_death (ELEMENT *ElementPtr)
 static COUNT
 initialize_megawatt_laser (ELEMENT *ShipPtr, HELEMENT LaserArray[])
 {
-#define NUM_CYCLES 4
 	RECT r;
 	STARSHIP *StarShipPtr;
 	LASER_BLOCK LaserBlock;
@@ -363,11 +381,13 @@ initialize_megawatt_laser (ELEMENT *Ship
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	LaserBlock.face = StarShipPtr->ShipFacing;
-	GetFrameRect (SetAbsFrameIndex (StarShipPtr->RaceDescPtr->ship_data.weapon[0], LaserBlock.face), &r);
-	
-	LaserBlock.cx = DISPLAY_ALIGN (ShipPtr->next.location.x) + DISPLAY_TO_WORLD (r.corner.x);
-	LaserBlock.cy = DISPLAY_ALIGN (ShipPtr->next.location.y) + DISPLAY_TO_WORLD (r.corner.y);
-	
+	GetFrameRect (SetAbsFrameIndex (
+			StarShipPtr->RaceDescPtr->ship_data.weapon[0], LaserBlock.face
+			), &r);
+	LaserBlock.cx = DISPLAY_ALIGN (ShipPtr->next.location.x)
+			+ DISPLAY_TO_WORLD (r.corner.x);
+	LaserBlock.cy = DISPLAY_ALIGN (ShipPtr->next.location.y)
+			+ DISPLAY_TO_WORLD (r.corner.y);
 	LaserBlock.ex = COSINE (FACING_TO_ANGLE (LaserBlock.face), (LASER_RANGE << RESOLUTION_FACTOR)); // JMS_GFX
 	LaserBlock.ey = SINE (FACING_TO_ANGLE (LaserBlock.face), (LASER_RANGE << RESOLUTION_FACTOR)); // JMS_GFX
 	LaserBlock.sender = ShipPtr->playerNr;
@@ -384,7 +404,8 @@ initialize_megawatt_laser (ELEMENT *Ship
 
 		LaserPtr->mass_points = 2;
 		LaserPtr->death_func = laser_death;
-		LaserPtr->turn_wait = (BYTE)((StarShipPtr->special_counter + 1) % NUM_CYCLES);
+		LaserPtr->turn_wait = (BYTE)((StarShipPtr->special_counter + 1)
+				% NUM_CYCLES);
 
 		UnlockElement (LaserArray[0]);
 	}
@@ -393,7 +414,8 @@ initialize_megawatt_laser (ELEMENT *Ship
 }
 
 static void
-chmmr_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern, COUNT ConcernCounter)
+chmmr_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+		COUNT ConcernCounter)
 {
 	STARSHIP *StarShipPtr;
 	EVALUATE_DESC *lpEvalDesc;
@@ -419,8 +441,6 @@ static void
 chmmr_postprocess (ELEMENT *ElementPtr)
 {
 	STARSHIP *StarShipPtr;
-	COUNT NUM_SHADOWS = 5;
-
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 
 	if (StarShipPtr->cur_status_flags & WEAPON)
@@ -440,11 +460,13 @@ chmmr_postprocess (ELEMENT *ElementPtr)
 		{
 			LockElement (hMuzzleFlash, &MuzzleFlashPtr);
 			MuzzleFlashPtr->playerNr = ElementPtr->playerNr;
-			MuzzleFlashPtr->state_flags = FINITE_LIFE | NONSOLID | IGNORE_SIMILAR | APPEARING;
+			MuzzleFlashPtr->state_flags = FINITE_LIFE | NONSOLID
+					| IGNORE_SIMILAR | APPEARING;
 			MuzzleFlashPtr->life_span = 1;
 
 			MuzzleFlashPtr->current = ElementPtr->next;
-			MuzzleFlashPtr->current.image.farray = StarShipPtr->RaceDescPtr->ship_data.weapon;
+			MuzzleFlashPtr->current.image.farray =
+					StarShipPtr->RaceDescPtr->ship_data.weapon;
 			MuzzleFlashPtr->current.image.frame = SetAbsFrameIndex (
 					StarShipPtr->RaceDescPtr->ship_data.weapon[0],
 					StarShipPtr->ShipFacing + ANGLE_TO_FACING (FULL_CIRCLE)
@@ -462,24 +484,29 @@ chmmr_postprocess (ELEMENT *ElementPtr)
 		UnlockElement (GetTailElement ());
 	}
 
-	if ((StarShipPtr->cur_status_flags & SPECIAL) && DeltaEnergy (ElementPtr, -SPECIAL_ENERGY_COST))
+	if ((StarShipPtr->cur_status_flags & SPECIAL)
+			&& DeltaEnergy (ElementPtr, -SPECIAL_ENERGY_COST))
 	{
 		COUNT facing;
 		ELEMENT *ShipElementPtr;
 
 		LockElement (ElementPtr->hTarget, &ShipElementPtr);
-		ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 1), ShipElementPtr);
+		
+		ProcessSound (SetAbsSoundIndex (
+				StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 1),
+				ShipElementPtr);
+
 		UnlockElement (ElementPtr->hTarget);
 
 		facing = 0;
 		if (TrackShip (ElementPtr, &facing) >= 0)
-		{					
+		{
 			ELEMENT *ShipElementPtr;
 
 			LockElement (ElementPtr->hTarget, &ShipElementPtr);
 			if (!GRAVITY_MASS (ShipElementPtr->mass_points + 1))
 			{
-				SDWORD i, dx, dy;
+				SIZE i, dx, dy;
 				COUNT angle, magnitude;
 				STARSHIP *EnemyStarShipPtr;
 				static const SIZE shadow_offs[] =
@@ -528,18 +555,23 @@ chmmr_postprocess (ELEMENT *ElementPtr)
 						- ShipElementPtr->next.location.y;
 				angle = ARCTAN (dx, dy);
 				magnitude = WORLD_TO_VELOCITY (12 << RESOLUTION_FACTOR) / ShipElementPtr->mass_points; // JMS_GFX
-				DeltaVelocityComponents (&ShipElementPtr->velocity, COSINE (angle, magnitude), SINE (angle, magnitude));
+				DeltaVelocityComponents (&ShipElementPtr->velocity,
+						COSINE (angle, magnitude), SINE (angle, magnitude));
 
-				GetCurrentVelocityComponentsSdword (&ShipElementPtr->velocity,&dx, &dy);
+				GetCurrentVelocityComponents (&ShipElementPtr->velocity,
+						&dx, &dy);
 				GetElementStarShip (ShipElementPtr, &EnemyStarShipPtr);
 
 				// set the effected ship's speed flags
 				current_speed = VelocitySquared (dx, dy);
-				max_speed = VelocitySquared (WORLD_TO_VELOCITY (EnemyStarShipPtr->RaceDescPtr->characteristics.max_thrust),0);
-				
-				EnemyStarShipPtr->cur_status_flags &= ~(SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED);
+				max_speed = VelocitySquared (WORLD_TO_VELOCITY (
+						EnemyStarShipPtr->RaceDescPtr->characteristics.max_thrust),
+						0);
+				EnemyStarShipPtr->cur_status_flags &= ~(SHIP_AT_MAX_SPEED
+						| SHIP_BEYOND_MAX_SPEED);
 				if (current_speed > max_speed)
-					EnemyStarShipPtr->cur_status_flags |= (SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED);
+					EnemyStarShipPtr->cur_status_flags |= (SHIP_AT_MAX_SPEED
+							| SHIP_BEYOND_MAX_SPEED);
 				else if (current_speed == max_speed)
 					EnemyStarShipPtr->cur_status_flags |= SHIP_AT_MAX_SPEED;
 
@@ -553,7 +585,7 @@ chmmr_postprocess (ELEMENT *ElementPtr)
 					{
 						ELEMENT *ShadowElementPtr;
 						COUNT shadow_magnitude; // JMS_GFX
-						
+
 						// JMS_GFX
 						if (RESOLUTION_FACTOR == 0)
 							shadow_magnitude = shadow_offs[i];
@@ -564,16 +596,20 @@ chmmr_postprocess (ELEMENT *ElementPtr)
 
 						LockElement (hShadow, &ShadowElementPtr);
 						ShadowElementPtr->playerNr = ShipElementPtr->playerNr;
-						ShadowElementPtr->state_flags = FINITE_LIFE | NONSOLID | IGNORE_SIMILAR | POST_PROCESS;
+						ShadowElementPtr->state_flags = FINITE_LIFE | NONSOLID
+								| IGNORE_SIMILAR | POST_PROCESS;
 						ShadowElementPtr->life_span = 1;
 
 						ShadowElementPtr->current = ShipElementPtr->next;
-						ShadowElementPtr->current.location.x += COSINE (angle, shadow_magnitude); // JMS_GFX: replaced shadow_offs[i] with shadow_magnitude
-						ShadowElementPtr->current.location.y += SINE (angle, shadow_magnitude);   // JMS_GFX
+						ShadowElementPtr->current.location.x +=
+								COSINE (angle, shadow_magnitude);
+						ShadowElementPtr->current.location.y +=
+								SINE (angle, shadow_magnitude);
 						ShadowElementPtr->next = ShadowElementPtr->current;
 
 						SetElementStarShip (ShadowElementPtr, EnemyStarShipPtr);
-						SetVelocityComponents (&ShadowElementPtr->velocity, dx, dy);
+						SetVelocityComponents (&ShadowElementPtr->velocity,
+								dx, dy);
 
 						SetPrimType (&(GLOBAL (DisplayArray))[
 								ShadowElementPtr->PrimIndex
@@ -594,8 +630,6 @@ chmmr_postprocess (ELEMENT *ElementPtr)
 	StarShipPtr->special_counter = 0;
 }
 
-#define SATELLITE_OFFSET DISPLAY_TO_WORLD (64 << RESOLUTION_FACTOR) // JMS_GFX
-
 static void
 satellite_preprocess (ELEMENT *ElementPtr)
 {
@@ -631,7 +665,7 @@ satellite_preprocess (ELEMENT *ElementPt
 		dx = WRAP_DELTA_X (dx);
 		dy = WRAP_DELTA_Y (dy);
 		if ((long)dx * dx + (long)dy * dy
-				<= DISPLAY_TO_WORLD (20L << RESOLUTION_FACTOR) * DISPLAY_TO_WORLD (20L << RESOLUTION_FACTOR)) // JMS_GFX
+				<= DISPLAY_TO_WORLD (20L << RESOLUTION_FACTOR) * DISPLAY_TO_WORLD (20L << RESOLUTION_FACTOR))
 			SetVelocityComponents (&ElementPtr->velocity,
 					WORLD_TO_VELOCITY (dx),
 					WORLD_TO_VELOCITY (dy));
@@ -642,7 +676,7 @@ satellite_preprocess (ELEMENT *ElementPt
 			angle = ARCTAN (dx, dy);
 			SetVelocityComponents (&ElementPtr->velocity,
 					COSINE (angle, WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (20 << RESOLUTION_FACTOR))),
-					SINE (angle, WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (20 << RESOLUTION_FACTOR)))); // JMS_GFX
+					SINE (angle, WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (20 << RESOLUTION_FACTOR))));
 		}
 
 		UnlockElement (StarShipPtr->hShip);
@@ -652,8 +686,6 @@ satellite_preprocess (ELEMENT *ElementPt
 static void
 spawn_point_defense (ELEMENT *ElementPtr)
 {
-	UWORD DEFENSE_RANGE = (UWORD)(64 << RESOLUTION_FACTOR); // JMS_GFX
-	COUNT DEFENSE_WAIT = 2;
 	BYTE weakest;
 	UWORD best_dist;
 	STARSHIP *StarShipPtr;
@@ -664,7 +696,7 @@ spawn_point_defense (ELEMENT *ElementPtr
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	hBestObject = 0;
-	best_dist = DEFENSE_RANGE + (1 << RESOLUTION_FACTOR); // JMS_GFX
+	best_dist = DEFENSE_RANGE + (1 << RESOLUTION_FACTOR);
 	weakest = 255;
 	LockElement (StarShipPtr->hShip, &ShipPtr);
 	LockElement (ElementPtr->hTarget, &SattPtr);
@@ -824,20 +856,22 @@ satellite_death (ELEMENT *ElementPtr)
 static void
 spawn_satellites (ELEMENT *ElementPtr)
 {
-	COUNT NUM_SATELLITES = 3;
 	COUNT i;
 	STARSHIP *StarShipPtr;
+	BYTE NumSatellites = NUM_SATELLITES;
+
 	if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
 		(((PlayerControl[0] & COMPUTER_CONTROL) && ElementPtr->playerNr == 1) || 
 		((PlayerControl[1] & COMPUTER_CONTROL) && ElementPtr->playerNr == 0))))
 	{
-		NUM_SATELLITES = 5;
+		NumSatellites = NUM_SATELLITES + 2;
 	}
+
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (StarShipPtr->hShip)
 	{
 		LockElement (StarShipPtr->hShip, &ElementPtr);
-		for (i = 0; i < NUM_SATELLITES; ++i)
+		for (i = 0; i < NumSatellites; ++i)
 		{
 			HELEMENT hSatellite;
 
@@ -852,11 +886,11 @@ spawn_satellites (ELEMENT *ElementPtr)
 				SattPtr->state_flags = IGNORE_SIMILAR | APPEARING
 						| FINITE_LIFE;
 				SattPtr->life_span = NORMAL_LIFE + 1;
-				SattPtr->hit_points = 10;
-				SattPtr->mass_points = 10;
+				SattPtr->hit_points = SATELLITE_HITPOINTS;
+				SattPtr->mass_points = SATELLITE_MASS;
 
-				angle = (i * FULL_CIRCLE + (NUM_SATELLITES >> 1))
-						/ NUM_SATELLITES;
+				angle = (i * FULL_CIRCLE + (NumSatellites >> 1))
+						/ NumSatellites;
 				SattPtr->turn_wait = (BYTE)angle;
 				SattPtr->current.location.x = ElementPtr->next.location.x
 						+ COSINE (angle, SATELLITE_OFFSET);
@@ -926,33 +960,17 @@ chmmr_preprocess (ELEMENT *ElementPtr)
 RACE_DESC*
 init_chmmr (void)
 {
+	static RACE_DESC chmmr_desc;
 	RACE_DESC *RaceDescPtr;
+	
+	chmmr_desc = (RESOLUTION_FACTOR == 0 ? chmmr_desc1x : (RESOLUTION_FACTOR == 1 ? chmmr_desc2x : chmmr_desc4x));
 
-	// JMS_GFX: A rather clumsy way of giving ship correct stats at hi-res mode
-	if (RESOLUTION_FACTOR == 0)
-	{
-		chmmr_desc.preprocess_func = chmmr_preprocess;
-		chmmr_desc.postprocess_func = chmmr_postprocess;
-		chmmr_desc.init_weapon_func = initialize_megawatt_laser;
-		chmmr_desc.cyborg_control.intelligence_func = chmmr_intelligence;
-		RaceDescPtr = &chmmr_desc;
-	}
-	else if (RESOLUTION_FACTOR == 1)
-	{
-		chmmr_desc_2xres.preprocess_func = chmmr_preprocess;
-		chmmr_desc_2xres.postprocess_func = chmmr_postprocess;
-		chmmr_desc_2xres.init_weapon_func = initialize_megawatt_laser;
-		chmmr_desc_2xres.cyborg_control.intelligence_func = chmmr_intelligence;
-		RaceDescPtr = &chmmr_desc_2xres;
-	}
-	else
-	{
-		chmmr_desc_4xres.preprocess_func = chmmr_preprocess;
-		chmmr_desc_4xres.postprocess_func = chmmr_postprocess;
-		chmmr_desc_4xres.init_weapon_func = initialize_megawatt_laser;
-		chmmr_desc_4xres.cyborg_control.intelligence_func = chmmr_intelligence;
-		RaceDescPtr = &chmmr_desc_4xres;
-	}
+	chmmr_desc.preprocess_func = chmmr_preprocess;
+	chmmr_desc.postprocess_func = chmmr_postprocess;
+	chmmr_desc.init_weapon_func = initialize_megawatt_laser;
+	chmmr_desc.cyborg_control.intelligence_func = chmmr_intelligence;
+
+	RaceDescPtr = &chmmr_desc;
 
 	return (RaceDescPtr);
 }
diff -ruNp src.hd/uqm/ships/chmmr/chmmr.h src/uqm/ships/chmmr/chmmr.h
--- src.hd/uqm/ships/chmmr/chmmr.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/chmmr/chmmr.h	2017-12-29 00:57:51 -0800
@@ -17,7 +17,15 @@
 #ifndef CHMMR_H
 #define CHMMR_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_chmmr (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* CHMMR_H */
 
diff -ruNp src.hd/uqm/ships/chmmr/icode.h src/uqm/ships/chmmr/icode.h
--- src.hd/uqm/ships/chmmr/icode.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/chmmr/icode.h	2017-12-29 00:57:51 -0800
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define CHMMR_CODE "ship.chmmr.code"
diff -ruNp src.hd/uqm/ships/chmmr/resinst.h src/uqm/ships/chmmr/resinst.h
--- src.hd/uqm/ships/chmmr/resinst.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/chmmr/resinst.h	2017-12-29 00:57:51 -0800
@@ -1,17 +1,19 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define CHMMR_BIG_MASK_PMAP_ANIM "ship.chmmr.graphics.avatar.large"
 #define CHMMR_CAPTAIN_MASK_PMAP_ANIM "ship.chmmr.graphics.captain"
 #define CHMMR_ICON_MASK_PMAP_ANIM "ship.chmmr.icons"
 #define CHMMR_MED_MASK_PMAP_ANIM "ship.chmmr.graphics.avatar.medium"
 #define CHMMR_MICON_MASK_PMAP_ANIM "ship.chmmr.meleeicons"
+#define CHMMR_RACE_STRINGS "ship.chmmr.text"
+#define CHMMR_SHIP_SOUNDS "ship.chmmr.sounds"
 #define CHMMR_SML_MASK_PMAP_ANIM "ship.chmmr.graphics.avatar.small"
+#define CHMMR_VICTORY_SONG "ship.chmmr.ditty"
 #define MUZZLE_BIG_MASK_PMAP_ANIM "ship.chmmr.graphics.muzzle.large"
 #define MUZZLE_MED_MASK_PMAP_ANIM "ship.chmmr.graphics.muzzle.medium"
 #define MUZZLE_SML_MASK_PMAP_ANIM "ship.chmmr.graphics.muzzle.small"
 #define SATELLITE_BIG_MASK_PMAP_ANIM "ship.chmmr.graphics.satellite.large"
 #define SATELLITE_MED_MASK_PMAP_ANIM "ship.chmmr.graphics.satellite.medium"
 #define SATELLITE_SML_MASK_PMAP_ANIM "ship.chmmr.graphics.satellite.small"
-#define CHMMR_RACE_STRINGS "ship.chmmr.text"
-#define CHMMR_SHIP_SOUNDS "ship.chmmr.sounds"
-#define CHMMR_VICTORY_SONG "ship.chmmr.ditty"
-
-#include "icode.h"
diff -ruNp src.hd/uqm/ships/druuge/Makeinfo src/uqm/ships/druuge/Makeinfo
--- src.hd/uqm/ships/druuge/Makeinfo	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/druuge/Makeinfo	2017-12-29 00:57:51 -0800
@@ -1 +1,2 @@
 uqm_CFILES="druuge.c"
+uqm_HFILES="druuge.h icode.h resinst.h"
diff -ruNp src.hd/uqm/ships/druuge/druuge.c src/uqm/ships/druuge/druuge.c
--- src.hd/uqm/ships/druuge/druuge.c	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/druuge/druuge.c	2017-12-29 00:57:51 -0800
@@ -20,27 +20,49 @@
 #include "druuge.h"
 #include "resinst.h"
 
+// Core characteristics
 #define MAX_CREW 14
 #define MAX_ENERGY 32
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 4
-#define SPECIAL_ENERGY_COST 16
 #define ENERGY_WAIT 50
 #define MAX_THRUST 20
 #define THRUST_INCREMENT 2
-#define TURN_WAIT 4
 #define THRUST_WAIT 1
-#define WEAPON_WAIT 10
-#define SPECIAL_WAIT 30
-
+#define TURN_WAIT 4
 #define SHIP_MASS 5
+
+// Mass Driver
+#define WEAPON_ENERGY_COST 4
+#define WEAPON_WAIT 10
+#define DRUUGE_OFFSET RES_SCALE(24)
+#define MISSILE_OFFSET RES_SCALE(6)
 #define MISSILE_SPEED DISPLAY_TO_WORLD (30)
 #define MISSILE_LIFE 20
 #define MISSILE_RANGE (MISSILE_SPEED * MISSILE_LIFE)
+#define MISSILE_HITS 4
+#define MISSILE_DAMAGE 6
+#define RECOIL_VELOCITY WORLD_TO_VELOCITY (DISPLAY_TO_WORLD RES_SCALE(6))
+#define MAX_RECOIL_VELOCITY (RECOIL_VELOCITY * 4)
+
+// Furnace
+#define SPECIAL_ENERGY_COST 16
+#define SPECIAL_WAIT 30
+
+// HD
+#define MAX_THRUST_2XRES 40
+#define THRUST_INCREMENT_2XRES 4
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
+#define MISSILE_RANGE_2XRES (MISSILE_SPEED_2XRES * MISSILE_LIFE)
+
+#define MAX_THRUST_4XRES 80
+#define THRUST_INCREMENT_4XRES 8
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
+#define MISSILE_RANGE_4XRES (MISSILE_SPEED_4XRES * MISSILE_LIFE)
 
-static RACE_DESC druuge_desc =
+static RACE_DESC druuge_desc1x =
 {
 	{ /* SHIP_INFO */
+		"mauler",
 		FIRES_FORE,
 		17, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -110,15 +132,10 @@ static RACE_DESC druuge_desc =
 };
 
 // JMS_GFX
-#define MAX_THRUST_2XRES 40
-#define THRUST_INCREMENT_2XRES 4
-#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
-#define MISSILE_RANGE_2XRES (MISSILE_SPEED_2XRES * MISSILE_LIFE)
-
-// JMS_GFX
-static RACE_DESC druuge_desc_2xres =
+static RACE_DESC druuge_desc2x =
 {
 	{ /* SHIP_INFO */
+		"mauler",
 		FIRES_FORE,
 		17, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -188,15 +205,10 @@ static RACE_DESC druuge_desc_2xres =
 };
 
 // JMS_GFX
-#define MAX_THRUST_4XRES 80
-#define THRUST_INCREMENT_4XRES 8
-#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
-#define MISSILE_RANGE_4XRES (MISSILE_SPEED_4XRES * MISSILE_LIFE)
-
-// JMS_GFX
-static RACE_DESC druuge_desc_4xres =
+static RACE_DESC druuge_desc4x =
 {
 	{ /* SHIP_INFO */
+		"mauler",
 		FIRES_FORE,
 		17, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -265,9 +277,6 @@ static RACE_DESC druuge_desc_4xres =
 	0, /* CodeRef */
 };
 
-#define RECOIL_VELOCITY WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (6 << RESOLUTION_FACTOR)) // JMS_GFX
-#define MAX_RECOIL_VELOCITY (RECOIL_VELOCITY * 4)
-
 static void
 cannon_collision (ELEMENT *ElementPtr0, POINT *pPt0,
 		ELEMENT *ElementPtr1, POINT *pPt1)
@@ -279,11 +288,12 @@ cannon_collision (ELEMENT *ElementPtr0,
 			&& !GRAVITY_MASS (ElementPtr1->mass_points + 1))
 	{
 		COUNT angle;
-		SDWORD cur_delta_x, cur_delta_y;
+		SIZE cur_delta_x, cur_delta_y;
 		STARSHIP *StarShipPtr;
 
 		GetElementStarShip (ElementPtr1, &StarShipPtr);
-		StarShipPtr->cur_status_flags &= ~(SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED);
+		StarShipPtr->cur_status_flags &=
+				~(SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED);
 
 		angle = FACING_TO_ANGLE (
 				GetFrameIndex (ElementPtr0->next.image.frame)
@@ -291,7 +301,7 @@ cannon_collision (ELEMENT *ElementPtr0,
 		DeltaVelocityComponents (&ElementPtr1->velocity,
 				COSINE (angle, RECOIL_VELOCITY),
 				SINE (angle, RECOIL_VELOCITY));
-		GetCurrentVelocityComponentsSdword (&ElementPtr1->velocity,
+		GetCurrentVelocityComponents (&ElementPtr1->velocity,
 				&cur_delta_x, &cur_delta_y);
 		if ((long)cur_delta_x * (long)cur_delta_x
 				+ (long)cur_delta_y * (long)cur_delta_y
@@ -308,10 +318,6 @@ cannon_collision (ELEMENT *ElementPtr0,
 static COUNT
 initialize_cannon (ELEMENT *ShipPtr, HELEMENT CannonArray[])
 {
-#define DRUUGE_OFFSET (24 << RESOLUTION_FACTOR) // JMS_GFX
-#define MISSILE_OFFSET (6 << RESOLUTION_FACTOR) // JMS_GFX
-#define MISSILE_HITS 4
-#define MISSILE_DAMAGE 6
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -324,7 +330,7 @@ initialize_cannon (ELEMENT *ShipPtr, HEL
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = DRUUGE_OFFSET;
-	MissileBlock.speed = (MISSILE_SPEED << RESOLUTION_FACTOR); // JMS_GFX
+	MissileBlock.speed = MISSILE_SPEED;
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -359,7 +365,7 @@ druuge_intelligence (ELEMENT *ShipPtr, E
 	if (StarShipPtr->cur_status_flags & SHIP_BEYOND_MAX_SPEED)
 		lpEvalDesc->MoveState = ENTICE;
 	else if (lpEvalDesc->ObjectPtr
-			 && lpEvalDesc->which_turn <= (WORLD_TO_TURN ((MISSILE_RANGE << RESOLUTION_FACTOR) * 3 / 4)) >> RESOLUTION_FACTOR) // JMS_GFX
+			&& lpEvalDesc->which_turn <= WORLD_TO_TURN (RES_SCALE(MISSILE_RANGE) * 3 / 4))
 	{
 		GetElementStarShip (lpEvalDesc->ObjectPtr, &EnemyStarShipPtr);
 		ship_flags = EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags;
@@ -462,32 +468,17 @@ druuge_preprocess (ELEMENT *ElementPtr)
 RACE_DESC*
 init_druuge (void)
 {
+	static RACE_DESC druuge_desc;
 	RACE_DESC *RaceDescPtr;
 
-	if (RESOLUTION_FACTOR == 0)
-	{
-		druuge_desc.preprocess_func = druuge_preprocess;
-		druuge_desc.postprocess_func = druuge_postprocess;
-		druuge_desc.init_weapon_func = initialize_cannon;
-		druuge_desc.cyborg_control.intelligence_func = druuge_intelligence;
-		RaceDescPtr = &druuge_desc;
-	}
-	else if (RESOLUTION_FACTOR == 1)
-	{
-		druuge_desc_2xres.preprocess_func = druuge_preprocess;
-		druuge_desc_2xres.postprocess_func = druuge_postprocess;
-		druuge_desc_2xres.init_weapon_func = initialize_cannon;
-		druuge_desc_2xres.cyborg_control.intelligence_func = druuge_intelligence;
-		RaceDescPtr = &druuge_desc_2xres;
-	}
-	else
-	{
-		druuge_desc_4xres.preprocess_func = druuge_preprocess;
-		druuge_desc_4xres.postprocess_func = druuge_postprocess;
-		druuge_desc_4xres.init_weapon_func = initialize_cannon;
-		druuge_desc_4xres.cyborg_control.intelligence_func = druuge_intelligence;
-		RaceDescPtr = &druuge_desc_4xres;
-	}
+	druuge_desc = (RESOLUTION_FACTOR == 0 ? druuge_desc1x : (RESOLUTION_FACTOR == 1 ? druuge_desc2x : druuge_desc4x));
+
+	druuge_desc.preprocess_func = druuge_preprocess;
+	druuge_desc.postprocess_func = druuge_postprocess;
+	druuge_desc.init_weapon_func = initialize_cannon;
+	druuge_desc.cyborg_control.intelligence_func = druuge_intelligence;
+
+	RaceDescPtr = &druuge_desc;
 
 	return (RaceDescPtr);
 }
diff -ruNp src.hd/uqm/ships/druuge/druuge.h src/uqm/ships/druuge/druuge.h
--- src.hd/uqm/ships/druuge/druuge.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/druuge/druuge.h	2017-12-29 00:57:51 -0800
@@ -17,7 +17,15 @@
 #ifndef DRUUGE_H
 #define DRUUGE_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_druuge (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* DRUUGE_H */
 
diff -ruNp src.hd/uqm/ships/druuge/icode.h src/uqm/ships/druuge/icode.h
--- src.hd/uqm/ships/druuge/icode.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/druuge/icode.h	2017-12-29 00:57:51 -0800
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define DRUUGE_CODE "ship.druuge.code"
diff -ruNp src.hd/uqm/ships/druuge/resinst.h src/uqm/ships/druuge/resinst.h
--- src.hd/uqm/ships/druuge/resinst.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/druuge/resinst.h	2017-12-29 00:57:51 -0800
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define DRUUGE_BIG_MASK_PMAP_ANIM "ship.druuge.graphics.mauler.large"
 #define DRUUGE_CANNON_BIG_MASK_PMAP_ANIM "ship.druuge.graphics.cannon.large"
 #define DRUUGE_CANNON_MED_MASK_PMAP_ANIM "ship.druuge.graphics.cannon.medium"
@@ -6,9 +10,7 @@
 #define DRUUGE_ICON_MASK_PMAP_ANIM "ship.druuge.icons"
 #define DRUUGE_MED_MASK_PMAP_ANIM "ship.druuge.graphics.mauler.medium"
 #define DRUUGE_MICON_MASK_PMAP_ANIM "ship.druuge.meleeicons"
-#define DRUUGE_SML_MASK_PMAP_ANIM "ship.druuge.graphics.mauler.small"
 #define DRUUGE_RACE_STRINGS "ship.druuge.text"
 #define DRUUGE_SHIP_SOUNDS "ship.druuge.sounds"
+#define DRUUGE_SML_MASK_PMAP_ANIM "ship.druuge.graphics.mauler.small"
 #define DRUUGE_VICTORY_SONG "ship.druuge.ditty"
-
-#include "icode.h"
diff -ruNp src.hd/uqm/ships/human/Makeinfo src/uqm/ships/human/Makeinfo
--- src.hd/uqm/ships/human/Makeinfo	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/human/Makeinfo	2017-12-29 00:57:51 -0800
@@ -1 +1,2 @@
 uqm_CFILES="human.c"
+uqm_HFILES="human.h icode.h resinst.h"
diff -ruNp src.hd/uqm/ships/human/human.c src/uqm/ships/human/human.c
--- src.hd/uqm/ships/human/human.c	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/human/human.c	2017-12-29 00:57:51 -0800
@@ -23,28 +23,46 @@
 #include "uqm/colors.h"
 #include "uqm/globdata.h"
 
-
+// Core characteristics
 #define MAX_CREW 18
 #define MAX_ENERGY 18
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 9
-#define SPECIAL_ENERGY_COST 4
 #define ENERGY_WAIT 8
 #define MAX_THRUST /* DISPLAY_TO_WORLD (6) */ 24
 #define THRUST_INCREMENT /* DISPLAY_TO_WORLD (2) */ 3
-#define TURN_WAIT 1
 #define THRUST_WAIT 4
+#define TURN_WAIT 1
+#define SHIP_MASS 6
+
+// Nuke
+#define WEAPON_ENERGY_COST 9
 #define WEAPON_WAIT 10
+#define HUMAN_OFFSET RES_SCALE(42)
+#define NUKE_OFFSET RES_SCALE(8)
+#define MIN_MISSILE_SPEED DISPLAY_TO_WORLD RES_SCALE(10)
+#define MAX_MISSILE_SPEED DISPLAY_TO_WORLD RES_SCALE(20)
+#define MISSILE_SPEED ((MAX_THRUST << RESOLUTION_FACTOR) >= MIN_MISSILE_SPEED ? (MAX_THRUST << RESOLUTION_FACTOR) : MIN_MISSILE_SPEED)
+#define THRUST_SCALE DISPLAY_TO_WORLD RES_SCALE(1)
+#define MISSILE_LIFE 60
+#define MISSILE_HITS 1
+#define MISSILE_DAMAGE 4
+#define TRACK_WAIT 3
+
+// Point-Defense Laser
+#define SPECIAL_ENERGY_COST 4
 #define SPECIAL_WAIT 9
+#define LASER_RANGE (UWORD)RES_SCALE(100)
 
-#define SHIP_MASS 6
-#define MISSILE_LIFE 60
-#define MIN_MISSILE_SPEED DISPLAY_TO_WORLD (10 << RESOLUTION_FACTOR) // JMS_GFX
-#define MAX_MISSILE_SPEED DISPLAY_TO_WORLD (20 << RESOLUTION_FACTOR) // JMS_GFX
+// HD
+#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (12) */ 48
+#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (4) */ 6
+#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (24) */ 96
+#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (8) */ 12
 
-static RACE_DESC human_desc =
+static RACE_DESC human_desc1x =
 {
 	{ /* SHIP_INFO */
+		"cruiser",
 		FIRES_FORE | SEEKING_WEAPON | POINT_DEFENSE,
 		11, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -114,13 +132,10 @@ static RACE_DESC human_desc =
 };
 
 // JMS_GFX
-#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (12) */ 48
-#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (4) */ 6
-
-// JMS_GFX
-static RACE_DESC human_desc_2xres =
+static RACE_DESC human_desc2x =
 {
 	{ /* SHIP_INFO */
+		"cruiser",
 		FIRES_FORE | SEEKING_WEAPON | LIGHT_POINT_DEFENSE,
 		11, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -190,13 +205,10 @@ static RACE_DESC human_desc_2xres =
 };
 
 // JMS_GFX
-#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (24) */ 96
-#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (8) */ 12
-
-// JMS_GFX
-static RACE_DESC human_desc_4xres =
+static RACE_DESC human_desc4x =
 {
 	{ /* SHIP_INFO */
+		"cruiser",
 		FIRES_FORE | SEEKING_WEAPON | LIGHT_POINT_DEFENSE,
 		11, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -265,9 +277,6 @@ static RACE_DESC human_desc_4xres =
 	0, /* CodeRef */
 };
 
-#define MISSILE_SPEED ((MAX_THRUST << RESOLUTION_FACTOR) >= MIN_MISSILE_SPEED ? (MAX_THRUST << RESOLUTION_FACTOR) : MIN_MISSILE_SPEED) // JMS_GFX
-#define TRACK_WAIT 3
-
 static void
 nuke_preprocess (ELEMENT *ElementPtr)
 {
@@ -292,8 +301,9 @@ nuke_preprocess (ELEMENT *ElementPtr)
 	{
 		SDWORD speed;
 
-#define THRUST_SCALE DISPLAY_TO_WORLD (1 << RESOLUTION_FACTOR) // JMS_GFX
-		if ((speed = MISSILE_SPEED + ((MISSILE_LIFE - ElementPtr->life_span) * THRUST_SCALE)) > MAX_MISSILE_SPEED)
+		if ((speed = MISSILE_SPEED +
+				((MISSILE_LIFE - ElementPtr->life_span) *
+				THRUST_SCALE)) > MAX_MISSILE_SPEED)
 			speed = MAX_MISSILE_SPEED;
 		SetVelocityVector (&ElementPtr->velocity,
 				speed, facing);
@@ -345,7 +355,6 @@ spawn_point_defense (ELEMENT *ElementPtr
 			if (ObjectPtr != ShipPtr && CollidingElement (ObjectPtr) &&
 					!OBJECT_CLOAKED (ObjectPtr))
 			{
-#define LASER_RANGE (UWORD)(100 << RESOLUTION_FACTOR) // JMS_GFX
 				SIZE delta_x, delta_y;
 
 				delta_x = ObjectPtr->next.location.x -
@@ -414,10 +423,6 @@ spawn_point_defense (ELEMENT *ElementPtr
 static COUNT
 initialize_nuke (ELEMENT *ShipPtr, HELEMENT NukeArray[])
 {
-#define HUMAN_OFFSET (42 << RESOLUTION_FACTOR) // JMS_GFX
-#define MISSILE_DAMAGE 4
-#define MISSILE_HITS 1
-#define NUKE_OFFSET (8 << RESOLUTION_FACTOR) // JMS_GFX
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -429,7 +434,7 @@ initialize_nuke (ELEMENT *ShipPtr, HELEM
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = 0;
 	MissileBlock.pixoffs = HUMAN_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
+	MissileBlock.speed = RES_SCALE(MISSILE_SPEED);
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -494,29 +499,16 @@ human_postprocess (ELEMENT *ElementPtr)
 RACE_DESC*
 init_human (void)
 {
+	static RACE_DESC human_desc;
 	RACE_DESC *RaceDescPtr;
 
-	if (RESOLUTION_FACTOR == 0)
-	{
-		human_desc.postprocess_func = human_postprocess;
-		human_desc.init_weapon_func = initialize_nuke;
-		human_desc.cyborg_control.intelligence_func = human_intelligence;
-		RaceDescPtr = &human_desc;
-	}
-	else if (RESOLUTION_FACTOR == 1)
-	{
-		human_desc_2xres.postprocess_func = human_postprocess;
-		human_desc_2xres.init_weapon_func = initialize_nuke;
-		human_desc_2xres.cyborg_control.intelligence_func = human_intelligence;
-		RaceDescPtr = &human_desc_2xres;
-	}
-	else
-	{
-		human_desc_4xres.postprocess_func = human_postprocess;
-		human_desc_4xres.init_weapon_func = initialize_nuke;
-		human_desc_4xres.cyborg_control.intelligence_func = human_intelligence;
-		RaceDescPtr = &human_desc_4xres;
-	}
+	human_desc = (RESOLUTION_FACTOR == 0 ? human_desc1x : (RESOLUTION_FACTOR == 1 ? human_desc2x : human_desc4x));
+
+	human_desc.postprocess_func = human_postprocess;
+	human_desc.init_weapon_func = initialize_nuke;
+	human_desc.cyborg_control.intelligence_func = human_intelligence;
+
+	RaceDescPtr = &human_desc;
 
 	return (RaceDescPtr);
 }
diff -ruNp src.hd/uqm/ships/human/human.h src/uqm/ships/human/human.h
--- src.hd/uqm/ships/human/human.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/human/human.h	2017-12-29 00:57:51 -0800
@@ -17,7 +17,15 @@
 #ifndef HUMAN_H
 #define HUMAN_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_human (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* HUMAN_H */
 
diff -ruNp src.hd/uqm/ships/human/icode.h src/uqm/ships/human/icode.h
--- src.hd/uqm/ships/human/icode.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/human/icode.h	2017-12-29 00:57:51 -0800
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define HUMAN_CODE "ship.earthling.code"
diff -ruNp src.hd/uqm/ships/human/resinst.h src/uqm/ships/human/resinst.h
--- src.hd/uqm/ships/human/resinst.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/human/resinst.h	2017-12-29 00:57:51 -0800
@@ -1,14 +1,16 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define HUMAN_BIG_MASK_PMAP_ANIM "ship.earthling.graphics.human.large"
 #define HUMAN_CAPTAIN_MASK_PMAP_ANIM "ship.earthling.graphics.captain"
 #define HUMAN_ICON_MASK_PMAP_ANIM "ship.earthling.icons"
 #define HUMAN_MED_MASK_PMAP_ANIM "ship.earthling.graphics.human.medium"
 #define HUMAN_MICON_MASK_PMAP_ANIM "ship.earthling.meleeicons"
+#define HUMAN_RACE_STRINGS "ship.earthling.text"
+#define HUMAN_SHIP_SOUNDS "ship.earthling.sounds"
 #define HUMAN_SML_MASK_PMAP_ANIM "ship.earthling.graphics.human.small"
+#define HUMAN_VICTORY_SONG "ship.earthling.ditty"
 #define SATURN_BIG_MASK_PMAP_ANIM "ship.earthling.graphics.saturn.large"
 #define SATURN_MED_MASK_PMAP_ANIM "ship.earthling.graphics.saturn.medium"
 #define SATURN_SML_MASK_PMAP_ANIM "ship.earthling.graphics.saturn.small"
-#define HUMAN_RACE_STRINGS "ship.earthling.text"
-#define HUMAN_SHIP_SOUNDS "ship.earthling.sounds"
-#define HUMAN_VICTORY_SONG "ship.earthling.ditty"
-
-#include "icode.h"
diff -ruNp src.hd/uqm/ships/ilwrath/Makeinfo src/uqm/ships/ilwrath/Makeinfo
--- src.hd/uqm/ships/ilwrath/Makeinfo	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/ilwrath/Makeinfo	2017-12-29 00:57:51 -0800
@@ -1 +1,2 @@
 uqm_CFILES="ilwrath.c"
+uqm_HFILES="icode.h ilwrath.h resinst.h"
diff -ruNp src.hd/uqm/ships/ilwrath/icode.h src/uqm/ships/ilwrath/icode.h
--- src.hd/uqm/ships/ilwrath/icode.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/ilwrath/icode.h	2017-12-29 00:57:51 -0800
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define ILWRATH_CODE "ship.ilwrath.code"
diff -ruNp src.hd/uqm/ships/ilwrath/ilwrath.c src/uqm/ships/ilwrath/ilwrath.c
--- src.hd/uqm/ships/ilwrath/ilwrath.c	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/ilwrath/ilwrath.c	2017-12-29 00:57:51 -0800
@@ -24,25 +24,44 @@
 #include "uqm/globdata.h"
 
 
+// Core characteristics
 #define MAX_CREW 22
 #define MAX_ENERGY 16
 #define ENERGY_REGENERATION 4
-#define WEAPON_ENERGY_COST 1
-#define SPECIAL_ENERGY_COST 3
 #define ENERGY_WAIT 4
 #define MAX_THRUST 25
 #define THRUST_INCREMENT 5
-#define TURN_WAIT 2
 #define THRUST_WAIT 0
+#define TURN_WAIT 2
+#define SHIP_MASS 7
+#define LOOK_AHEAD 4
+		/* Controls how much the auto-turn will attempt to "lead"
+		 * its target. */
+
+// Hellfire Spout
+#define WEAPON_ENERGY_COST 1
 #define WEAPON_WAIT 0
+#define MISSILE_LIFE 8
+#define ILWRATH_OFFSET RES_SCALE(29)
+#define MISSILE_SPEED RES_SCALE(MAX_THRUST)
+#define MISSILE_HITS 1
+#define MISSILE_DAMAGE 1
+#define MISSILE_OFFSET 0
+
+// Cloaking Device
+#define SPECIAL_ENERGY_COST 3
 #define SPECIAL_WAIT 13
 
-#define SHIP_MASS 7
-#define MISSILE_LIFE 8
+// HD
+#define MAX_THRUST_2XRES 50
+#define THRUST_INCREMENT_2XRES 10
+#define MAX_THRUST_4XRES 100
+#define THRUST_INCREMENT_4XRES 20
 
-static RACE_DESC ilwrath_desc =
+static RACE_DESC ilwrath_desc1x =
 {
 	{ /* SHIP_INFO */
+		"avenger",
 		FIRES_FORE,
 		10, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -112,13 +131,10 @@ static RACE_DESC ilwrath_desc =
 };
 
 // JMS_GFX
-#define MAX_THRUST_2XRES 50
-#define THRUST_INCREMENT_2XRES 10
-
-// JMS_GFX
-static RACE_DESC ilwrath_desc_2xres =
+static RACE_DESC ilwrath_desc2x =
 {
 	{ /* SHIP_INFO */
+		"avenger",
 		FIRES_FORE,
 		10, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -188,13 +204,10 @@ static RACE_DESC ilwrath_desc_2xres =
 };
 
 // JMS_GFX
-#define MAX_THRUST_4XRES 100
-#define THRUST_INCREMENT_4XRES 20
-
-// JMS_GFX
-static RACE_DESC ilwrath_desc_4xres =
+static RACE_DESC ilwrath_desc4x =
 {
 	{ /* SHIP_INFO */
+		"avenger",
 		FIRES_FORE,
 		10, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -270,8 +283,10 @@ flame_preprocess (ELEMENT *ElementPtr)
 		--ElementPtr->turn_wait;
 	else
 	{
-		ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->current.image.frame);
+		ElementPtr->next.image.frame =
+				IncFrameIndex (ElementPtr->current.image.frame);
 		ElementPtr->state_flags |= CHANGING;
+
 		ElementPtr->turn_wait = ElementPtr->next_turn;
 	}
 }
@@ -286,14 +301,14 @@ flame_collision (ELEMENT *ElementPtr0, P
 }
 
 static void
-ilwrath_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern, COUNT ConcernCounter)
+ilwrath_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+		COUNT ConcernCounter)
 {
 	EVALUATE_DESC *lpEvalDesc;
 	STARSHIP *StarShipPtr;
 
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
-	lpEvalDesc->MoveState = PURSUE;
-	
+	 lpEvalDesc->MoveState = PURSUE;
 	if (lpEvalDesc->ObjectPtr && lpEvalDesc->which_turn <= 10)
 				/* don't want to dodge when you could be flaming */
 		ObjectsOfConcern[ENEMY_WEAPON_INDEX].ObjectPtr = 0;
@@ -328,11 +343,6 @@ ilwrath_intelligence (ELEMENT *ShipPtr,
 static COUNT
 initialize_flame (ELEMENT *ShipPtr, HELEMENT FlameArray[])
 {
-#define ILWRATH_OFFSET (29 << RESOLUTION_FACTOR)		// JMS_GFX
-#define MISSILE_SPEED (MAX_THRUST << RESOLUTION_FACTOR) // JMS_GFX
-#define MISSILE_HITS 1
-#define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET 0
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -419,9 +429,8 @@ ilwrath_preprocess (ELEMENT *ElementPtr)
 				ProcessSound (SetAbsSoundIndex (
 								/* CLOAKING_OFF */
 						StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 2), ElementPtr);
-				
-				SetPrimColor (lpPrim, BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01));
-				
+				SetPrimColor (lpPrim,
+						BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01));
 				if (weapon_discharge)
 				{
 					COUNT facing;
@@ -429,7 +438,6 @@ ilwrath_preprocess (ELEMENT *ElementPtr)
 					facing = StarShipPtr->ShipFacing;
 					if (TrackShip (ElementPtr, &facing) >= 0)
 					{
-#define LOOK_AHEAD 4
 						ELEMENT *eptr;
 						SIZE dx0, dy0, dx1, dy1;
 						VELOCITY_DESC v;
@@ -540,30 +548,17 @@ ilwrath_preprocess (ELEMENT *ElementPtr)
 
 RACE_DESC*
 init_ilwrath (void)
-{
+{	
+	static RACE_DESC ilwrath_desc;
 	RACE_DESC *RaceDescPtr;
 
-	if (RESOLUTION_FACTOR == 0)
-	{
-		ilwrath_desc.preprocess_func = ilwrath_preprocess;
-		ilwrath_desc.init_weapon_func = initialize_flame;
-		ilwrath_desc.cyborg_control.intelligence_func = ilwrath_intelligence;
-		RaceDescPtr = &ilwrath_desc;
-	}
-	else if (RESOLUTION_FACTOR == 1)
-	{
-		ilwrath_desc_2xres.preprocess_func = ilwrath_preprocess;
-		ilwrath_desc_2xres.init_weapon_func = initialize_flame;
-		ilwrath_desc_2xres.cyborg_control.intelligence_func = ilwrath_intelligence;
-		RaceDescPtr = &ilwrath_desc_2xres;
-	}
-	else
-	{
-		ilwrath_desc_4xres.preprocess_func = ilwrath_preprocess;
-		ilwrath_desc_4xres.init_weapon_func = initialize_flame;
-		ilwrath_desc_4xres.cyborg_control.intelligence_func = ilwrath_intelligence;
-		RaceDescPtr = &ilwrath_desc_4xres;
-	}
+	ilwrath_desc = (RESOLUTION_FACTOR == 0 ? ilwrath_desc1x : (RESOLUTION_FACTOR == 1 ? ilwrath_desc2x : ilwrath_desc4x));
+
+	ilwrath_desc.preprocess_func = ilwrath_preprocess;
+	ilwrath_desc.init_weapon_func = initialize_flame;
+	ilwrath_desc.cyborg_control.intelligence_func = ilwrath_intelligence;
+
+	RaceDescPtr = &ilwrath_desc;
 
 	return (RaceDescPtr);
 }
diff -ruNp src.hd/uqm/ships/ilwrath/ilwrath.h src/uqm/ships/ilwrath/ilwrath.h
--- src.hd/uqm/ships/ilwrath/ilwrath.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/ilwrath/ilwrath.h	2017-12-29 00:57:51 -0800
@@ -17,7 +17,15 @@
 #ifndef ILWRATH_H
 #define ILWRATH_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_ilwrath (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* ILWRATH_H */
 
diff -ruNp src.hd/uqm/ships/ilwrath/resinst.h src/uqm/ships/ilwrath/resinst.h
--- src.hd/uqm/ships/ilwrath/resinst.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/ilwrath/resinst.h	2017-12-29 00:57:51 -0800
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define FIRE_BIG_MASK_PMAP_ANIM "ship.ilwrath.graphics.fire.large"
 #define FIRE_MED_MASK_PMAP_ANIM "ship.ilwrath.graphics.fire.medium"
 #define FIRE_SML_MASK_PMAP_ANIM "ship.ilwrath.graphics.fire.small"
@@ -6,9 +10,7 @@
 #define ILWRATH_ICON_MASK_PMAP_ANIM "ship.ilwrath.icons"
 #define ILWRATH_MED_MASK_PMAP_ANIM "ship.ilwrath.graphics.avenger.medium"
 #define ILWRATH_MICON_MASK_PMAP_ANIM "ship.ilwrath.meleeicons"
-#define ILWRATH_SML_MASK_PMAP_ANIM "ship.ilwrath.graphics.avenger.small"
 #define ILWRATH_RACE_STRINGS "ship.ilwrath.text"
 #define ILWRATH_SHIP_SOUNDS "ship.ilwrath.sounds"
+#define ILWRATH_SML_MASK_PMAP_ANIM "ship.ilwrath.graphics.avenger.small"
 #define ILWRATH_VICTORY_SONG "ship.ilwrath.ditty"
-
-#include "icode.h"
diff -ruNp src.hd/uqm/ships/lastbat/Makeinfo src/uqm/ships/lastbat/Makeinfo
--- src.hd/uqm/ships/lastbat/Makeinfo	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/lastbat/Makeinfo	2017-12-29 00:57:52 -0800
@@ -1 +1,2 @@
 uqm_CFILES="lastbat.c"
+uqm_HFILES="icode.h lastbat.h resinst.h"
diff -ruNp src.hd/uqm/ships/lastbat/icode.h src/uqm/ships/lastbat/icode.h
--- src.hd/uqm/ships/lastbat/icode.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/lastbat/icode.h	2017-12-29 00:57:51 -0800
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SAMATRA_CODE "ship.samatra.code"
diff -ruNp src.hd/uqm/ships/lastbat/lastbat.c src/uqm/ships/lastbat/lastbat.c
--- src.hd/uqm/ships/lastbat/lastbat.c	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/lastbat/lastbat.c	2017-12-29 00:57:52 -0800
@@ -27,29 +27,63 @@
 #include "libs/mathlib.h"
 #include "libs/timelib.h"
 
-
 #define num_generators characteristics.max_thrust
 
+// Core characteristics
 #define MAX_CREW 1
 #define MAX_ENERGY MAX_ENERGY_SIZE
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 2
-#define SPECIAL_ENERGY_COST 3
 #define ENERGY_WAIT 6
 #define MAX_THRUST 0
 #define THRUST_INCREMENT 0
 #define TURN_WAIT 0
 #define THRUST_WAIT 0
+#define SHIP_MASS (MAX_SHIP_MASS * 10)
+#define TURRET_WAIT 0 /* Controls animation of the Sa-Matra's central
+                       * 'furnace', a new frame is displayed once every
+                       * TURRET_WAIT frames. */
+
+// Yellow comet
 #define WEAPON_WAIT ((ONE_SECOND / BATTLE_FRAME_RATE) * 10)
+#define COMET_DAMAGE 2
+#define COMET_OFFSET 0
+#define COMET_HITS 12
+#define COMET_SPEED DISPLAY_TO_WORLD RES_SCALE(12)
+#define COMET_LIFE 2
+#define COMET_TURN_WAIT 3
+#define MAX_COMETS 3
+#define WEAPON_ENERGY_COST 2
+		/* Used for samatra_desc.weapon_energy_cost, but the value isn't
+		 * actually used. */
+
+// Green sentinel
 #define SPECIAL_WAIT ((ONE_SECOND / BATTLE_FRAME_RATE) * 3)
+#define SENTINEL_SPEED DISPLAY_TO_WORLD RES_SCALE(8)
+#define SENTINEL_LIFE 2
+#define SENTINEL_OFFSET 0
+#define SENTINEL_HITS 10
+#define SENTINEL_DAMAGE 1
+#define TRACK_WAIT 1
+#define ANIMATION_WAIT 1
+#define RECOIL_VELOCITY WORLD_TO_VELOCITY (DISPLAY_TO_WORLD RES_SCALE(10))
+#define MAX_RECOIL_VELOCITY (RECOIL_VELOCITY * 4)
+#define MAX_SENTINELS 4
+#define SPECIAL_ENERGY_COST 3
+		/* Used for samatra_desc.special_energy_cost, but the value isn't
+		 * actually used. */
 
-#define SHIP_MASS (MAX_SHIP_MASS * 10)
-#define SAMATRA_OFFSET (9 << RESOLUTION_FACTOR) // JMS_GFX
-#define MISSILE_SPEED DISPLAY_TO_WORLD (8 << RESOLUTION_FACTOR) // JMS_GFX
+// Blue force field
+#define GATE_DAMAGE 1
+#define GATE_HITS 100
+
+// Red generators
+#define GENERATOR_HITS 15
+#define MAX_GENERATORS 8
 
 static RACE_DESC samatra_desc =
 {
 	{ /* SHIP_INFO */
+		"samatra",
 		/* FIRES_FORE | */ IMMEDIATE_WEAPON | CREW_IMMUNE,
 		16, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -153,8 +187,6 @@ comet_preprocess (ELEMENT *ElementPtr)
 	ElementPtr->state_flags |= CHANGING;
 }
 
-#define COMET_DAMAGE 2
-
 static void
 comet_collision (ELEMENT *ElementPtr0, POINT *pPt0,
 		ELEMENT *ElementPtr1, POINT *pPt1)
@@ -199,10 +231,6 @@ comet_collision (ELEMENT *ElementPtr0, P
 static HELEMENT
 spawn_comet (ELEMENT *ElementPtr)
 {
-#define COMET_OFFSET 0
-#define COMET_HITS 12
-#define COMET_SPEED DISPLAY_TO_WORLD (12 << RESOLUTION_FACTOR) // JMS_GFX
-#define COMET_LIFE 2
 	MISSILE_BLOCK MissileBlock;
 	HELEMENT hComet;
 	STARSHIP *StarShipPtr;
@@ -258,12 +286,11 @@ spawn_comet (ELEMENT *ElementPtr)
 				--CometPtr->turn_wait;
 			else
 			{
-#define COMET_WAIT 3
 				facing = NORMALIZE_FACING (facing);
 				if (TrackShip (CometPtr, &facing) > 0)
 					SetVelocityVector (&CometPtr->velocity,
 							COMET_SPEED, facing);
-				CometPtr->turn_wait = COMET_WAIT;
+				CometPtr->turn_wait = COMET_TURN_WAIT;
 			}
 		}
 		UnlockElement (hComet);
@@ -279,7 +306,6 @@ turret_preprocess (ELEMENT *ElementPtr)
 		--ElementPtr->turn_wait;
 	else
 	{
-#define TURRET_WAIT 0
 		ElementPtr->next.image.frame =
 				SetAbsFrameIndex (ElementPtr->current.image.frame,
 				(GetFrameIndex (ElementPtr->current.image.frame) % 10) + 1);
@@ -289,9 +315,6 @@ turret_preprocess (ELEMENT *ElementPtr)
 	}
 }
 
-#define GATE_DAMAGE 1
-#define GATE_HITS 100
-
 static void
 gate_collision (ELEMENT *ElementPtr0, POINT *pPt0,
 		ELEMENT *ElementPtr1, POINT *pPt1)
@@ -413,8 +436,6 @@ generator_death (ELEMENT *ElementPtr)
 	}
 }
 
-#define GENERATOR_HITS 15
-
 static void
 generator_preprocess (ELEMENT *ElementPtr)
 {
@@ -443,8 +464,6 @@ generator_collision (ELEMENT *ElementPtr
 	(void) pPt1;  /* Satisfying compiler (unused parameter) */
 }
 
-#define TRACK_WAIT 1
-
 static void
 sentinel_preprocess (ELEMENT *ElementPtr)
 {
@@ -458,7 +477,6 @@ sentinel_preprocess (ELEMENT *ElementPtr
 		--ElementPtr->thrust_wait;
 	else
 	{
-#define ANIMATION_WAIT 1
 		ElementPtr->next.image.frame =
 				SetAbsFrameIndex (ElementPtr->current.image.frame,
 				(GetFrameIndex (ElementPtr->current.image.frame) + 1) % 6);
@@ -483,7 +501,7 @@ sentinel_preprocess (ELEMENT *ElementPtr
 			ElementPtr->state_flags &= ~NONSOLID;
 			facing = (COUNT)TFB_Random ();
 			SetVelocityVector (&ElementPtr->velocity,
-					MISSILE_SPEED, facing);
+					SENTINEL_SPEED, facing);
 		}
 		facing = NORMALIZE_FACING (facing);
 		if (ElementPtr->hTarget == 0)
@@ -577,16 +595,13 @@ sentinel_preprocess (ELEMENT *ElementPtr
 			}
 
 			SetVelocityVector (&ElementPtr->velocity,
-					MISSILE_SPEED, facing);
+					SENTINEL_SPEED, facing);
 		}
 
 		ElementPtr->turn_wait = TRACK_WAIT;
 	}
 }
 
-#define RECOIL_VELOCITY WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (10 << RESOLUTION_FACTOR)) // JMS_GFX
-#define MAX_RECOIL_VELOCITY (RECOIL_VELOCITY * 4)
-
 static void
 sentinel_collision (ELEMENT *ElementPtr0, POINT *pPt0,
 		ELEMENT *ElementPtr1, POINT *pPt1)
@@ -604,8 +619,8 @@ sentinel_collision (ELEMENT *ElementPtr0
 			angle = ARCTAN (pPt0->x - pPt1->x, pPt0->y - pPt1->y);
 
 			SetVelocityComponents (&ElementPtr0->velocity,
-					COSINE (angle, WORLD_TO_VELOCITY (MISSILE_SPEED)),
-					SINE (angle, WORLD_TO_VELOCITY (MISSILE_SPEED)));
+					COSINE (angle, WORLD_TO_VELOCITY (SENTINEL_SPEED)),
+					SINE (angle, WORLD_TO_VELOCITY (SENTINEL_SPEED)));
 			ElementPtr0->turn_wait = TRACK_WAIT;
 			ElementPtr0->state_flags |= COLLISION | DEFY_PHYSICS;
 		}
@@ -688,9 +703,6 @@ samatra_intelligence (ELEMENT *ShipPtr,
 	ship_intelligence (ShipPtr, ObjectsOfConcern, ConcernCounter);
 }
 
-#define MAX_COMETS 3
-#define MAX_SENTINELS 4
-
 static void
 samatra_postprocess (ELEMENT *ElementPtr)
 {
@@ -709,10 +721,6 @@ samatra_postprocess (ELEMENT *ElementPtr
 		if (StarShipPtr->special_counter == 0
 				&& StarShipPtr->RaceDescPtr->characteristics.special_wait < MAX_SENTINELS)
 		{
-#define MISSILE_LIFE 2
-#define MISSILE_OFFSET 0
-#define MISSILE_HITS 10
-#define MISSILE_DAMAGE 1
 			MISSILE_BLOCK MissileBlock;
 			HELEMENT hSentinel;
 
@@ -724,12 +732,12 @@ samatra_postprocess (ELEMENT *ElementPtr
 			MissileBlock.sender = ElementPtr->playerNr;
 			MissileBlock.flags = 0;
 			MissileBlock.pixoffs = 0;
-			MissileBlock.speed = MISSILE_SPEED;
-			MissileBlock.hit_points = MISSILE_HITS;
-			MissileBlock.damage = MISSILE_DAMAGE;
-			MissileBlock.life = MISSILE_LIFE;
+			MissileBlock.speed = SENTINEL_SPEED;
+			MissileBlock.hit_points = SENTINEL_HITS;
+			MissileBlock.damage = SENTINEL_DAMAGE;
+			MissileBlock.life = SENTINEL_LIFE;
 			MissileBlock.preprocess_func = sentinel_preprocess;
-			MissileBlock.blast_offs = MISSILE_OFFSET;
+			MissileBlock.blast_offs = SENTINEL_OFFSET;
 			hSentinel = initialize_missile (&MissileBlock);
 
 			if (hSentinel)
@@ -765,20 +773,19 @@ samatra_preprocess (ELEMENT *ElementPtr)
 	}
 	else
 	{
-#define MAX_GENERATORS 8
-		POINT offs_1x[] =
+		POINT offs1x[] =
 		{
-			{-127-9,  -53+18}, // Top left generator
-			{ -38-9,  -88+18}, // The one below the top left generator
+			{-127-9,  -53+18},
+			{ -38-9,  -88+18},
 			{  44-9,  -85+18},
 			{ 127-9,  -60+18},
 			{ 124-9,   28+18},
 			{  73-9,   61+18},
 			{ -87-9,   58+18},
-			{-136-9,   29+18}, // Top right generator
+			{-136-9,   29+18},
 		};
 		
-		POINT offs_2x[] =
+		POINT offs2x[] =
 		{
 			{-153, -116}, // Top left generator
 			{-208, -49 }, // The one below the top left generator
@@ -790,7 +797,7 @@ samatra_preprocess (ELEMENT *ElementPtr)
 			{165,  -107}, // Top right generator
 		};
 		
-		POINT offs_4x[] =
+		POINT offs4x[] =
 		{
 			{-305, -234}, // Top left generator
 			{-414, -96 }, // The one below the top left generator
@@ -803,14 +810,8 @@ samatra_preprocess (ELEMENT *ElementPtr)
 		};
 		
 		POINT *offs;
-		
-		// JMS_GFX
-		if (RESOLUTION_FACTOR == 2)
-			offs = offs_4x;
-		else if (RESOLUTION_FACTOR == 1)
-			offs = offs_2x;
-		else
-			offs = offs_1x;
+
+		offs = (RESOLUTION_FACTOR == 0 ? offs1x : (RESOLUTION_FACTOR == 1 ? offs2x : offs4x));
 
 		for (StarShipPtr->RaceDescPtr->num_generators = 0;
 				StarShipPtr->RaceDescPtr->num_generators < MAX_GENERATORS;
@@ -822,7 +823,7 @@ samatra_preprocess (ELEMENT *ElementPtr)
 			if (hGenerator)
 			{
 				ELEMENT *GeneratorPtr;
-				
+
 				LockElement (hGenerator, &GeneratorPtr);
 				GeneratorPtr->hit_points = GENERATOR_HITS;
 				GeneratorPtr->mass_points = MAX_SHIP_MASS * 10;
@@ -836,11 +837,11 @@ samatra_preprocess (ELEMENT *ElementPtr)
 				GeneratorPtr->current.location.x =
 						((LOG_SPACE_WIDTH >> 1)
 						+ DISPLAY_TO_WORLD ((offs[StarShipPtr->RaceDescPtr->num_generators].x)))
-						& ~((SCALED_ONE << MAX_VIS_REDUCTION) - 1); // JMS_GFX
+						& ~((SCALED_ONE << MAX_VIS_REDUCTION) - 1);
 				GeneratorPtr->current.location.y =
 						((LOG_SPACE_HEIGHT >> 1)
 						+ DISPLAY_TO_WORLD ((offs[StarShipPtr->RaceDescPtr->num_generators].y)))
-						& ~((SCALED_ONE << MAX_VIS_REDUCTION) - 1); // JMS_GFX
+						& ~((SCALED_ONE << MAX_VIS_REDUCTION) - 1);
 				GeneratorPtr->current.image.farray =
 						StarShipPtr->RaceDescPtr->ship_data.special;
 				GeneratorPtr->current.image.frame =
diff -ruNp src.hd/uqm/ships/lastbat/lastbat.h src/uqm/ships/lastbat/lastbat.h
--- src.hd/uqm/ships/lastbat/lastbat.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/lastbat/lastbat.h	2017-12-29 00:57:52 -0800
@@ -17,7 +17,15 @@
 #ifndef LASTBAT_H
 #define LASTBAT_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_samatra (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* LASTBAT_H */
 
diff -ruNp src.hd/uqm/ships/lastbat/resinst.h src/uqm/ships/lastbat/resinst.h
--- src.hd/uqm/ships/lastbat/resinst.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/lastbat/resinst.h	2017-12-29 00:57:52 -0800
@@ -1,14 +1,16 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define GENERATOR_BIG_MASK_ANIM "ship.samatra.graphics.generator.large"
 #define GENERATOR_MED_MASK_PMAP_ANIM "ship.samatra.graphics.generator.medium"
 #define GENERATOR_SML_MASK_PMAP_ANIM "ship.samatra.graphics.generator.small"
 #define SAMATRA_BIG_MASK_ANIM "ship.samatra.graphics.samatra.large"
 #define SAMATRA_CAPTAIN_MASK_PMAP_ANIM "ship.samatra.graphics.captain"
 #define SAMATRA_MED_MASK_PMAP_ANIM "ship.samatra.graphics.samatra.medium"
+#define SAMATRA_SHIP_SOUNDS "ship.samatra.sounds"
 #define SAMATRA_SML_MASK_PMAP_ANIM "ship.samatra.graphics.samatra.small"
+#define SAMATRA_VICTORY_SONG "ship.samatra.ditty"
 #define SENTINEL_BIG_MASK_ANIM "ship.samatra.graphics.sentinel.large"
 #define SENTINEL_MED_MASK_PMAP_ANIM "ship.samatra.graphics.sentinel.medium"
 #define SENTINEL_SML_MASK_PMAP_ANIM "ship.samatra.graphics.sentinel.small"
-#define SAMATRA_SHIP_SOUNDS "ship.samatra.sounds"
-#define SAMATRA_VICTORY_SONG "ship.samatra.ditty"
-
-#include "icode.h"
diff -ruNp src.hd/uqm/ships/melnorme/Makeinfo src/uqm/ships/melnorme/Makeinfo
--- src.hd/uqm/ships/melnorme/Makeinfo	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/melnorme/Makeinfo	2017-12-29 00:57:52 -0800
@@ -1 +1,2 @@
 uqm_CFILES="melnorme.c"
+uqm_HFILES="icode.h melnorme.h resinst.h"
diff -ruNp src.hd/uqm/ships/melnorme/icode.h src/uqm/ships/melnorme/icode.h
--- src.hd/uqm/ships/melnorme/icode.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/melnorme/icode.h	2017-12-29 00:57:52 -0800
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define MELNORME_CODE "ship.melnorme.code"
diff -ruNp src.hd/uqm/ships/melnorme/melnorme.c src/uqm/ships/melnorme/melnorme.c
--- src.hd/uqm/ships/melnorme/melnorme.c	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/melnorme/melnorme.c	2017-12-29 00:57:52 -0800
@@ -23,27 +23,51 @@
 #include "uqm/globdata.h"
 #include "libs/mathlib.h"
 
-
+// Core characteristics
 #define MAX_CREW 20
 #define MAX_ENERGY MAX_ENERGY_SIZE
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 5
-#define SPECIAL_ENERGY_COST 20
 #define ENERGY_WAIT 4
 #define MAX_THRUST 36
 #define THRUST_INCREMENT 6
-#define TURN_WAIT 4
 #define THRUST_WAIT 4
-#define WEAPON_WAIT 1
-#define SPECIAL_WAIT 20
-
+#define TURN_WAIT 4
 #define SHIP_MASS 7
+
+// Blaster Pulse
+#define WEAPON_ENERGY_COST 5
+#define WEAPON_WAIT 1
+#define MELNORME_OFFSET RES_SCALE(24)
+#define LEVEL_COUNTER 72
+#define MAX_PUMP 4
 #define PUMPUP_SPEED DISPLAY_TO_WORLD (45)
 #define PUMPUP_LIFE 10
+#define PUMPUP_DAMAGE 2
+#define MIN_PUMPITUDE_ANIMS 3
+#define NUM_PUMP_ANIMS 5
+#define REVERSE_DIR (BYTE)(1 << 7)
+
+// Confusion Pulse
+#define SPECIAL_ENERGY_COST 20
+#define SPECIAL_WAIT 20
+#define CMISSILE_SPEED DISPLAY_TO_WORLD RES_SCALE(30)
+#define CMISSILE_LIFE 20
+#define CMISSILE_HITS 200
+#define CMISSILE_DAMAGE 0
+#define CMISSILE_OFFSET RES_SCALE(4)
+
+// HD
+#define MAX_THRUST_2XRES 72
+#define THRUST_INCREMENT_2XRES 12
+#define PUMPUP_SPEED_2XRES DISPLAY_TO_WORLD (90)
+#define MAX_THRUST_4XRES 144
+#define THRUST_INCREMENT_4XRES 24
+#define PUMPUP_SPEED_4XRES DISPLAY_TO_WORLD (180)
 
-static RACE_DESC melnorme_desc =
+static RACE_DESC melnorme_desc1x =
 {
 	{ /* SHIP_INFO */
+		"trader",
 		FIRES_FORE,
 		18, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -113,14 +137,10 @@ static RACE_DESC melnorme_desc =
 };
 
 // JMS_GFX
-#define MAX_THRUST_2XRES 72
-#define THRUST_INCREMENT_2XRES 12
-#define PUMPUP_SPEED_2XRES DISPLAY_TO_WORLD (90)
-
-// JMS_GFX
-static RACE_DESC melnorme_desc_2xres =
+static RACE_DESC melnorme_desc2x =
 {
 	{ /* SHIP_INFO */
+		"trader",
 		FIRES_FORE,
 		18, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -190,14 +210,10 @@ static RACE_DESC melnorme_desc_2xres =
 };
 
 // JMS_GFX
-#define MAX_THRUST_4XRES 144
-#define THRUST_INCREMENT_4XRES 24
-#define PUMPUP_SPEED_4XRES DISPLAY_TO_WORLD (180)
-
-// JMS_GFX
-static RACE_DESC melnorme_desc_4xres =
+static RACE_DESC melnorme_desc4x =
 {
 	{ /* SHIP_INFO */
+		"trader",
 		FIRES_FORE,
 		18, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -266,9 +282,6 @@ static RACE_DESC melnorme_desc_4xres =
 	0, /* CodeRef */
 };
 
-#define NUM_PUMP_ANIMS 5
-#define REVERSE_DIR (BYTE)(1 << 7)
-
 static void
 pump_up_preprocess (ELEMENT *ElementPtr)
 {
@@ -300,11 +313,6 @@ pump_up_preprocess (ELEMENT *ElementPtr)
 
 static COUNT initialize_pump_up (ELEMENT *ShipPtr, HELEMENT PumpUpArray[]);
 
-#define MELNORME_OFFSET (24 << RESOLUTION_FACTOR) // JMS_GFX
-#define LEVEL_COUNTER 72
-#define MAX_PUMP 4
-#define PUMPUP_DAMAGE 2
-
 static void
 pump_up_postprocess (ELEMENT *ElementPtr)
 {
@@ -386,8 +394,8 @@ pump_up_postprocess (ELEMENT *ElementPtr
 
 			angle = FACING_TO_ANGLE (StarShipPtr->ShipFacing);
 			SetVelocityComponents (&EPtr->velocity,
-					COSINE (angle, WORLD_TO_VELOCITY (PUMPUP_SPEED << RESOLUTION_FACTOR)), // JMS_GFX
-					SINE (angle, WORLD_TO_VELOCITY (PUMPUP_SPEED << RESOLUTION_FACTOR))); // JMS_GFX
+					COSINE (angle, WORLD_TO_VELOCITY (RES_SCALE(PUMPUP_SPEED))),
+					SINE (angle, WORLD_TO_VELOCITY (RES_SCALE(PUMPUP_SPEED))));
 
 			ProcessSound (SetAbsSoundIndex (
 					StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 3), EPtr);
@@ -436,7 +444,6 @@ pump_up_collision (ELEMENT *ElementPtr0,
 	{
 		ELEMENT *BlastElementPtr;
 
-#define MIN_PUMPITUDE_ANIMS 3
 		LockElement (hBlastElement, &BlastElementPtr);
 
 		BlastElementPtr->life_span =
@@ -609,12 +616,13 @@ confusion_collision (ELEMENT *ElementPtr
 				GetElementStarShip (ElementPtr1, &StarShipPtr);
 				ConfusionPtr->hTarget = StarShipPtr->hShip;
 			}
+
 			if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
-				(((PlayerControl[0] & COMPUTER_CONTROL) && ElementPtr1->playerNr == 1) || 
-				((PlayerControl[1] & COMPUTER_CONTROL) && ElementPtr1->playerNr == 0))))
+				(((PlayerControl[0] & COMPUTER_CONTROL) && ElementPtr0->playerNr == 0) || 
+				((PlayerControl[1] & COMPUTER_CONTROL) && ElementPtr0->playerNr == 1))))
 			{
 				ConfusionPtr->life_span = 0;
-			} else {				
+			} else {
 				ConfusionPtr->life_span = 400;
 			}
 			ConfusionPtr->turn_wait =
@@ -634,11 +642,6 @@ confusion_collision (ELEMENT *ElementPtr
 static COUNT
 initialize_confusion (ELEMENT *ShipPtr, HELEMENT ConfusionArray[])
 {
-#define CMISSILE_SPEED DISPLAY_TO_WORLD (30 << RESOLUTION_FACTOR) // JMS_GFX
-#define CMISSILE_HITS 200
-#define CMISSILE_DAMAGE 0
-#define CMISSILE_LIFE 20
-#define CMISSILE_OFFSET (4 << RESOLUTION_FACTOR) // JMS_GFX
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK ConfusionBlock;
 
@@ -687,7 +690,7 @@ initialize_test_pump_up (ELEMENT *ShipPt
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = MELNORME_OFFSET;
-	MissileBlock.speed = (PUMPUP_SPEED << RESOLUTION_FACTOR); // JMS_GFX
+	MissileBlock.speed = RES_SCALE(PUMPUP_SPEED);
 	MissileBlock.hit_points = PUMPUP_DAMAGE;
 	MissileBlock.damage = PUMPUP_DAMAGE;
 	MissileBlock.life = PUMPUP_LIFE;
@@ -804,29 +807,16 @@ melnorme_postprocess (ELEMENT *ElementPt
 RACE_DESC*
 init_melnorme (void)
 {
+	static RACE_DESC melnorme_desc;
 	RACE_DESC *RaceDescPtr;
 
-	if (RESOLUTION_FACTOR == 0)
-	{
-		melnorme_desc.postprocess_func = melnorme_postprocess;
-		melnorme_desc.init_weapon_func = initialize_pump_up;
-		melnorme_desc.cyborg_control.intelligence_func = melnorme_intelligence;
-		RaceDescPtr = &melnorme_desc;
-	}
-	else if (RESOLUTION_FACTOR == 1)
-	{
-		melnorme_desc_2xres.postprocess_func = melnorme_postprocess;
-		melnorme_desc_2xres.init_weapon_func = initialize_pump_up;
-		melnorme_desc_2xres.cyborg_control.intelligence_func = melnorme_intelligence;
-		RaceDescPtr = &melnorme_desc_2xres;
-	}
-	else
-	{
-		melnorme_desc_4xres.postprocess_func = melnorme_postprocess;
-		melnorme_desc_4xres.init_weapon_func = initialize_pump_up;
-		melnorme_desc_4xres.cyborg_control.intelligence_func = melnorme_intelligence;
-		RaceDescPtr = &melnorme_desc_4xres;
-	}
+	melnorme_desc = (RESOLUTION_FACTOR == 0 ? melnorme_desc1x : (RESOLUTION_FACTOR == 1 ? melnorme_desc2x : melnorme_desc4x));
+
+	melnorme_desc.postprocess_func = melnorme_postprocess;
+	melnorme_desc.init_weapon_func = initialize_pump_up;
+	melnorme_desc.cyborg_control.intelligence_func = melnorme_intelligence;
+
+	RaceDescPtr = &melnorme_desc;
 
 	return (RaceDescPtr);
 }
diff -ruNp src.hd/uqm/ships/melnorme/melnorme.h src/uqm/ships/melnorme/melnorme.h
--- src.hd/uqm/ships/melnorme/melnorme.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/melnorme/melnorme.h	2017-12-29 00:57:52 -0800
@@ -17,7 +17,15 @@
 #ifndef MELNORME_H
 #define MELNORME_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_melnorme (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* MELNORME_H */
 
diff -ruNp src.hd/uqm/ships/melnorme/resinst.h src/uqm/ships/melnorme/resinst.h
--- src.hd/uqm/ships/melnorme/resinst.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/melnorme/resinst.h	2017-12-29 00:57:52 -0800
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define CONFUSE_BIG_MASK_PMAP_ANIM "ship.melnorme.graphics.confuse.large"
 #define CONFUSE_MED_MASK_PMAP_ANIM "ship.melnorme.graphics.confuse.medium"
 #define CONFUSE_SML_MASK_PMAP_ANIM "ship.melnorme.graphics.confuse.small"
@@ -6,12 +10,10 @@
 #define MELNORME_ICON_MASK_PMAP_ANIM "ship.melnorme.icons"
 #define MELNORME_MED_MASK_PMAP_ANIM "ship.melnorme.graphics.trader.medium"
 #define MELNORME_MICON_MASK_PMAP_ANIM "ship.melnorme.meleeicons"
+#define MELNORME_RACE_STRINGS "ship.melnorme.text"
+#define MELNORME_SHIP_SOUNDS "ship.melnorme.sounds"
 #define MELNORME_SML_MASK_PMAP_ANIM "ship.melnorme.graphics.trader.small"
+#define MELNORME_VICTORY_SONG "ship.melnorme.ditty"
 #define PUMPUP_BIG_MASK_PMAP_ANIM "ship.melnorme.graphics.pumpup.large"
 #define PUMPUP_MED_MASK_PMAP_ANIM "ship.melnorme.graphics.pumpup.medium"
 #define PUMPUP_SML_MASK_PMAP_ANIM "ship.melnorme.graphics.pumpup.small"
-#define MELNORME_RACE_STRINGS "ship.melnorme.text"
-#define MELNORME_SHIP_SOUNDS "ship.melnorme.sounds"
-#define MELNORME_VICTORY_SONG "ship.melnorme.ditty"
-
-#include "icode.h"
diff -ruNp src.hd/uqm/ships/mmrnmhrm/Makeinfo src/uqm/ships/mmrnmhrm/Makeinfo
--- src.hd/uqm/ships/mmrnmhrm/Makeinfo	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/mmrnmhrm/Makeinfo	2017-12-29 00:57:52 -0800
@@ -1 +1,2 @@
 uqm_CFILES="mmrnmhrm.c"
+uqm_HFILES="icode.h mmrnmhrm.h resinst.h"
diff -ruNp src.hd/uqm/ships/mmrnmhrm/icode.h src/uqm/ships/mmrnmhrm/icode.h
--- src.hd/uqm/ships/mmrnmhrm/icode.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/mmrnmhrm/icode.h	2017-12-29 00:57:52 -0800
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define MMRNMHRM_CODE "ship.mmrnmhrm.code"
diff -ruNp src.hd/uqm/ships/mmrnmhrm/mmrnmhrm.c src/uqm/ships/mmrnmhrm/mmrnmhrm.c
--- src.hd/uqm/ships/mmrnmhrm/mmrnmhrm.c	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/mmrnmhrm/mmrnmhrm.c	2017-12-29 00:57:52 -0800
@@ -20,39 +20,62 @@
 #include "mmrnmhrm.h"
 #include "resinst.h"
 
-
+// Core characteristics
 #define MAX_CREW 20
 #define MAX_ENERGY 10
+#define SHIP_MASS 3
+
+// X-Wing characteristics
 #define ENERGY_REGENERATION 2
-#define WEAPON_ENERGY_COST 1
-#define SPECIAL_ENERGY_COST MAX_ENERGY
 #define ENERGY_WAIT 6
 #define MAX_THRUST 20
 #define THRUST_INCREMENT 5
-#define TURN_WAIT 2
 #define THRUST_WAIT 1
-#define WEAPON_WAIT 0
-#define SPECIAL_WAIT 0
+#define TURN_WAIT 2
 
+// Y-Wing characteristics
 #define YWING_ENERGY_REGENERATION 1
-#define YWING_WEAPON_ENERGY_COST 1
 #define YWING_SPECIAL_ENERGY_COST MAX_ENERGY
 #define YWING_ENERGY_WAIT 6
-#define YWING_MAX_THRUST (50 << RESOLUTION_FACTOR) // JMS_GFX
-#define YWING_THRUST_INCREMENT (10 << RESOLUTION_FACTOR) // JMS_GFX
-#define YWING_TURN_WAIT 14
+#define YWING_MAX_THRUST RES_SCALE(50)
+#define YWING_THRUST_INCREMENT RES_SCALE(10)
 #define YWING_THRUST_WAIT 0
+#define YWING_TURN_WAIT 14
+
+// X-Wing Lasers
+#define MMRNMHRM_OFFSET RES_SCALE(16)
+#define WEAPON_ENERGY_COST 1
+#define WEAPON_WAIT 0
+#define CENTER_OFFS DISPLAY_TO_WORLD RES_SCALE(4)
+#define WING_OFFS DISPLAY_TO_WORLD (10)
+#define LASER_RANGE DISPLAY_TO_WORLD (RES_SCALE(125) + MMRNMHRM_OFFSET)
+
+// Y-Wing Missiles
+#define YWING_WEAPON_ENERGY_COST 1
 #define YWING_WEAPON_WAIT 20
-#define YWING_SPECIAL_WAIT 0
+#define LAUNCH_OFFS DISPLAY_TO_WORLD RES_SCALE(4)
+#define MISSILE_OFFSET 0
+#define MISSILE_SPEED DISPLAY_TO_WORLD RES_SCALE(20)
+#define MISSILE_LIFE 40
+#define MISSILE_HITS 1
+#define MISSILE_DAMAGE 1
+#define TRACK_WAIT 5
 
-#define SHIP_MASS 3
-#define MMRNMHRM_OFFSET (16 << RESOLUTION_FACTOR) // JMS_GFX
-#define LASER_RANGE DISPLAY_TO_WORLD ((125 << RESOLUTION_FACTOR) + MMRNMHRM_OFFSET) // JMS_GFX
+// Transform
+#define SPECIAL_ENERGY_COST MAX_ENERGY
+#define SPECIAL_WAIT 0
+#define YWING_SPECIAL_WAIT 0
 
+// HD
+#define MAX_THRUST_2XRES 40
+#define THRUST_INCREMENT_2XRES 10
+#define MAX_THRUST_4XRES 80
+#define THRUST_INCREMENT_4XRES 20
 
-static RACE_DESC mmrnmhrm_desc =
+static RACE_DESC mmrnmhrm_desc1x =
 {
 	{ /* SHIP_INFO */
+		"xform",
 		FIRES_FORE | IMMEDIATE_WEAPON,
 		19, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -122,13 +145,10 @@ static RACE_DESC mmrnmhrm_desc =
 };
 
 // JMS_GFX
-#define MAX_THRUST_2XRES 40
-#define THRUST_INCREMENT_2XRES 10
-
-// JMS_GFX
-static RACE_DESC mmrnmhrm_desc_2xres =
+static RACE_DESC mmrnmhrm_desc2x =
 {
 	{ /* SHIP_INFO */
+		"xform",
 		FIRES_FORE | IMMEDIATE_WEAPON,
 		19, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -198,13 +218,10 @@ static RACE_DESC mmrnmhrm_desc_2xres =
 };
 
 // JMS_GFX
-#define MAX_THRUST_4XRES 80
-#define THRUST_INCREMENT_4XRES 20
-
-// JMS_GFX
-static RACE_DESC mmrnmhrm_desc_4xres =
+static RACE_DESC mmrnmhrm_desc4x =
 {
 	{ /* SHIP_INFO */
+		"xform",
 		FIRES_FORE | IMMEDIATE_WEAPON,
 		19, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -273,8 +290,40 @@ static RACE_DESC mmrnmhrm_desc_4xres =
 	0, /* CodeRef */
 };
 
-#define MISSILE_SPEED DISPLAY_TO_WORLD (20 << RESOLUTION_FACTOR) // JMS_GFX
-#define TRACK_WAIT 5
+// Private per-instance ship data
+typedef CHARACTERISTIC_STUFF MMRNMHRM_DATA;
+
+// Local typedef
+typedef MMRNMHRM_DATA CustomShipData_t;
+
+// Retrieve race-specific ship data from a race desc
+static CustomShipData_t *
+GetCustomShipData (RACE_DESC *pRaceDesc)
+{
+	return pRaceDesc->data;
+}
+
+// Set the race-specific data in a race desc
+// (Re)Allocates its own storage for the data.
+static void
+SetCustomShipData (RACE_DESC *pRaceDesc, const CustomShipData_t *data)
+{
+	if (pRaceDesc->data == data) 
+		return;  // no-op
+
+	if (pRaceDesc->data) // Out with the old
+	{
+		HFree (pRaceDesc->data);
+		pRaceDesc->data = NULL;
+	}
+
+	if (data) // In with the new
+	{
+		CustomShipData_t* newData = HMalloc (sizeof (*data));
+		*newData = *data;
+		pRaceDesc->data = newData;
+	}
+}
 
 static void
 missile_preprocess (ELEMENT *ElementPtr)
@@ -405,7 +454,6 @@ twin_laser_collision (ELEMENT *ElementPt
 static COUNT
 initialize_dual_weapons (ELEMENT *ShipPtr, HELEMENT WeaponArray[])
 {
-#define CENTER_OFFS DISPLAY_TO_WORLD (4 << RESOLUTION_FACTOR) // JMS_GFX
 	COORD cx, cy;
 	COUNT facing, angle;
 	SDWORD offs_x, offs_y;
@@ -419,7 +467,6 @@ initialize_dual_weapons (ELEMENT *ShipPt
 
 	if (ShipPtr->next.image.farray == StarShipPtr->RaceDescPtr->ship_data.ship)
 	{
-#define WING_OFFS DISPLAY_TO_WORLD (10 << RESOLUTION_FACTOR) // JMS_GFX
 		COORD ex, ey;
 		LASER_BLOCK LaserBlock;
 		ELEMENT *LaserPtr;
@@ -459,11 +506,6 @@ initialize_dual_weapons (ELEMENT *ShipPt
 	}
 	else
 	{
-#define MISSILE_HITS 1
-#define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET 0
-#define MISSILE_LIFE 40
-#define LAUNCH_OFFS DISPLAY_TO_WORLD (4 << RESOLUTION_FACTOR) // JMS_GFX
 		MISSILE_BLOCK TorpBlock;
 		ELEMENT *TorpPtr;
 
@@ -515,8 +557,8 @@ mmrnmhrm_postprocess (ELEMENT *ElementPt
 			/* take care of transform effect */
 	if (ElementPtr->next.image.farray != ElementPtr->current.image.farray)
 	{
-		CHARACTERISTIC_STUFF t;
-		CHARACTERISTIC_STUFF *otherwing_desc;
+		MMRNMHRM_DATA tempShipData;
+		MMRNMHRM_DATA *otherwing_desc;
 
 		ProcessSound (SetAbsSoundIndex (
 						/* TRANSFORM */
@@ -525,15 +567,18 @@ mmrnmhrm_postprocess (ELEMENT *ElementPt
 		StarShipPtr->weapon_counter = 0;
 
 		/* Swap characteristics descriptors around */
-		otherwing_desc = (CHARACTERISTIC_STUFF *)StarShipPtr->RaceDescPtr->data;
-		t = *otherwing_desc;
-		*otherwing_desc = StarShipPtr->RaceDescPtr->characteristics;
-		StarShipPtr->RaceDescPtr->characteristics = t;
+		otherwing_desc = GetCustomShipData (StarShipPtr->RaceDescPtr);
+		if (!otherwing_desc)
+			return;  // No ship data (?!)
+
+		tempShipData = *otherwing_desc;
+		SetCustomShipData (StarShipPtr->RaceDescPtr, &StarShipPtr->RaceDescPtr->characteristics);
+		StarShipPtr->RaceDescPtr->characteristics = tempShipData;
 		StarShipPtr->RaceDescPtr->cyborg_control.ManeuverabilityIndex = 0;
 
 		if (ElementPtr->next.image.farray == StarShipPtr->RaceDescPtr->ship_data.special)
 		{
-			StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = (LONG_RANGE_WEAPON - 1) << RESOLUTION_FACTOR; // JMS_GFX
+			StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = RES_SCALE(LONG_RANGE_WEAPON - 1);
 			StarShipPtr->RaceDescPtr->ship_info.ship_flags &= ~IMMEDIATE_WEAPON;
 			StarShipPtr->RaceDescPtr->ship_info.ship_flags |= SEEKING_WEAPON;
 			StarShipPtr->RaceDescPtr->ship_data.ship_sounds =
@@ -544,7 +589,7 @@ mmrnmhrm_postprocess (ELEMENT *ElementPt
 		}
 		else
 		{
-			StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = CLOSE_RANGE_WEAPON << RESOLUTION_FACTOR; // JMS_GFX
+			StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = RES_SCALE(CLOSE_RANGE_WEAPON);
 			StarShipPtr->RaceDescPtr->ship_info.ship_flags &= ~SEEKING_WEAPON;
 			StarShipPtr->RaceDescPtr->ship_info.ship_flags |= IMMEDIATE_WEAPON;
 			StarShipPtr->RaceDescPtr->ship_data.ship_sounds =
@@ -571,7 +616,8 @@ mmrnmhrm_preprocess (ELEMENT *ElementPtr
 				&& StarShipPtr->special_counter == 0)
 		{
 			/* Either we transform or text will flash */
-			if (DeltaEnergy (ElementPtr, -StarShipPtr->RaceDescPtr->characteristics.special_energy_cost))
+			if (DeltaEnergy (ElementPtr,
+					-StarShipPtr->RaceDescPtr->characteristics.special_energy_cost))
 			{
 				if (ElementPtr->next.image.farray == StarShipPtr->RaceDescPtr->ship_data.ship)
 					ElementPtr->next.image.farray =
@@ -594,59 +640,43 @@ mmrnmhrm_preprocess (ELEMENT *ElementPtr
 static void
 uninit_mmrnmhrm (RACE_DESC *pRaceDesc)
 {
-	HFree ((void *)pRaceDesc->data);
-	pRaceDesc->data = 0;
+	SetCustomShipData (pRaceDesc, NULL);
 }
 
 RACE_DESC*
 init_mmrnmhrm (void)
 {
+	static RACE_DESC mmrnmhrm_desc;
 	RACE_DESC *RaceDescPtr;
+
+	// The caller of this func will copy the struct
 	static RACE_DESC new_mmrnmhrm_desc;
-	CHARACTERISTIC_STUFF *otherwing_desc;
-	
-	if (RESOLUTION_FACTOR == 0)
-	{
-		mmrnmhrm_desc.uninit_func = uninit_mmrnmhrm;
-		mmrnmhrm_desc.preprocess_func = mmrnmhrm_preprocess;
-		mmrnmhrm_desc.postprocess_func = mmrnmhrm_postprocess;
-		mmrnmhrm_desc.init_weapon_func = initialize_dual_weapons;
-		mmrnmhrm_desc.cyborg_control.intelligence_func = mmrnmhrm_intelligence;
-		new_mmrnmhrm_desc = mmrnmhrm_desc;
-	}
-	else if (RESOLUTION_FACTOR == 1)
-	{
-		mmrnmhrm_desc_2xres.uninit_func = uninit_mmrnmhrm;
-		mmrnmhrm_desc_2xres.preprocess_func = mmrnmhrm_preprocess;
-		mmrnmhrm_desc_2xres.postprocess_func = mmrnmhrm_postprocess;
-		mmrnmhrm_desc_2xres.init_weapon_func = initialize_dual_weapons;
-		mmrnmhrm_desc_2xres.cyborg_control.intelligence_func = mmrnmhrm_intelligence;
-		new_mmrnmhrm_desc = mmrnmhrm_desc_2xres;
-	}
-	else
-	{
-		mmrnmhrm_desc_4xres.uninit_func = uninit_mmrnmhrm;
-		mmrnmhrm_desc_4xres.preprocess_func = mmrnmhrm_preprocess;
-		mmrnmhrm_desc_4xres.postprocess_func = mmrnmhrm_postprocess;
-		mmrnmhrm_desc_4xres.init_weapon_func = initialize_dual_weapons;
-		mmrnmhrm_desc_4xres.cyborg_control.intelligence_func = mmrnmhrm_intelligence;
-		new_mmrnmhrm_desc = mmrnmhrm_desc_4xres;
-	}
-	
-	otherwing_desc = HMalloc (sizeof (*otherwing_desc));
-	otherwing_desc->max_thrust = YWING_MAX_THRUST;
-	otherwing_desc->thrust_increment = YWING_THRUST_INCREMENT;
-	otherwing_desc->energy_regeneration = YWING_ENERGY_REGENERATION;
-	otherwing_desc->weapon_energy_cost = YWING_WEAPON_ENERGY_COST;
-	otherwing_desc->special_energy_cost = YWING_SPECIAL_ENERGY_COST;
-	otherwing_desc->energy_wait = YWING_ENERGY_WAIT;
-	otherwing_desc->turn_wait = YWING_TURN_WAIT;
-	otherwing_desc->thrust_wait = YWING_THRUST_WAIT;
-	otherwing_desc->weapon_wait = YWING_WEAPON_WAIT;
-	otherwing_desc->special_wait = YWING_SPECIAL_WAIT;
-	otherwing_desc->ship_mass = SHIP_MASS;
-	new_mmrnmhrm_desc.data = (intptr_t) otherwing_desc;
-	
+	MMRNMHRM_DATA otherwing_desc;
+
+	mmrnmhrm_desc = (RESOLUTION_FACTOR == 0 ? mmrnmhrm_desc1x : (RESOLUTION_FACTOR == 1 ? mmrnmhrm_desc2x : mmrnmhrm_desc4x));
+
+	mmrnmhrm_desc.uninit_func = uninit_mmrnmhrm;
+	mmrnmhrm_desc.preprocess_func = mmrnmhrm_preprocess;
+	mmrnmhrm_desc.postprocess_func = mmrnmhrm_postprocess;
+	mmrnmhrm_desc.init_weapon_func = initialize_dual_weapons;
+	mmrnmhrm_desc.cyborg_control.intelligence_func = mmrnmhrm_intelligence;
+
+	new_mmrnmhrm_desc = mmrnmhrm_desc;
+
+	otherwing_desc.max_thrust = YWING_MAX_THRUST;
+	otherwing_desc.thrust_increment = YWING_THRUST_INCREMENT;
+	otherwing_desc.energy_regeneration = YWING_ENERGY_REGENERATION;
+	otherwing_desc.weapon_energy_cost = YWING_WEAPON_ENERGY_COST;
+	otherwing_desc.special_energy_cost = YWING_SPECIAL_ENERGY_COST;
+	otherwing_desc.energy_wait = YWING_ENERGY_WAIT;
+	otherwing_desc.turn_wait = YWING_TURN_WAIT;
+	otherwing_desc.thrust_wait = YWING_THRUST_WAIT;
+	otherwing_desc.weapon_wait = YWING_WEAPON_WAIT;
+	otherwing_desc.special_wait = YWING_SPECIAL_WAIT;
+	otherwing_desc.ship_mass = SHIP_MASS;
+
+	SetCustomShipData (&new_mmrnmhrm_desc, &otherwing_desc);
+
 	RaceDescPtr = &new_mmrnmhrm_desc;
 
 	return (RaceDescPtr);
diff -ruNp src.hd/uqm/ships/mmrnmhrm/mmrnmhrm.h src/uqm/ships/mmrnmhrm/mmrnmhrm.h
--- src.hd/uqm/ships/mmrnmhrm/mmrnmhrm.h	2017-12-29 02:25:53 -0800
+++ src/uqm/ships/mmrnmhrm/mmrnmhrm.h	2017-12-29 00:57:52 -0800
@@ -17,7 +17,15 @@
 #ifndef MMRNMHRM_H
 #define MMRNMHRM_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_mmrnmhrm (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* MMRNMHRM_H */
 
diff -ruNp src.hd/uqm/ships/mmrnmhrm/resinst.h src/uqm/ships/mmrnmhrm/resinst.h
--- src.hd/uqm/ships/mmrnmhrm/resinst.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/mmrnmhrm/resinst.h	2017-12-29 00:57:52 -0800
@@ -1,17 +1,19 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define MMRNMHRM_BIG_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.xform.large"
 #define MMRNMHRM_CAPTAIN_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.captain"
 #define MMRNMHRM_ICON_MASK_PMAP_ANIM "ship.mmrnmhrm.icons"
 #define MMRNMHRM_MED_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.xform.medium"
 #define MMRNMHRM_MICON_MASK_PMAP_ANIM "ship.mmrnmhrm.meleeicons"
+#define MMRNMHRM_RACE_STRINGS "ship.mmrnmhrm.text"
+#define MMRNMHRM_SHIP_SOUNDS "ship.mmrnmhrm.sounds"
 #define MMRNMHRM_SML_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.xform.small"
+#define MMRNMHRM_VICTORY_SONG "ship.mmrnmhrm.ditty"
 #define TORP_BIG_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.torpedo.large"
 #define TORP_MED_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.torpedo.medium"
 #define TORP_SML_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.torpedo.small"
 #define YWING_BIG_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.ywing.large"
 #define YWING_MED_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.ywing.medium"
 #define YWING_SML_MASK_PMAP_ANIM "ship.mmrnmhrm.graphics.ywing.small"
-#define MMRNMHRM_RACE_STRINGS "ship.mmrnmhrm.text"
-#define MMRNMHRM_SHIP_SOUNDS "ship.mmrnmhrm.sounds"
-#define MMRNMHRM_VICTORY_SONG "ship.mmrnmhrm.ditty"
-
-#include "icode.h"
diff -ruNp src.hd/uqm/ships/mycon/Makeinfo src/uqm/ships/mycon/Makeinfo
--- src.hd/uqm/ships/mycon/Makeinfo	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/mycon/Makeinfo	2017-12-29 00:57:52 -0800
@@ -1 +1,2 @@
 uqm_CFILES="mycon.c"
+uqm_HFILES="icode.h mycon.h resinst.h"
diff -ruNp src.hd/uqm/ships/mycon/icode.h src/uqm/ships/mycon/icode.h
--- src.hd/uqm/ships/mycon/icode.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/mycon/icode.h	2017-12-29 00:57:52 -0800
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define MYCON_CODE "ship.mycon.code"
diff -ruNp src.hd/uqm/ships/mycon/mycon.c src/uqm/ships/mycon/mycon.c
--- src.hd/uqm/ships/mycon/mycon.c	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/mycon/mycon.c	2017-12-29 00:57:52 -0800
@@ -20,35 +20,48 @@
 #include "mycon.h"
 #include "resinst.h"
 
+// Core characteristics
 #define MAX_CREW 20
 #define MAX_ENERGY 40
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 20
-#define SPECIAL_ENERGY_COST MAX_ENERGY
 #define ENERGY_WAIT 4
-
- 
-#define MAX_THRUST /* DISPLAY_TO_WORLD (7) */ 27    
-#define MAX_THRUST_HIRES /* DISPLAY_TO_WORLD (20) */ 108 // DC_GFX
-#define THRUST_INCREMENT_HIRES MAX_THRUST_HIRES // DC_GFX
-
+#define MAX_THRUST /* DISPLAY_TO_WORLD (7) */ 27
 #define THRUST_INCREMENT /* DISPLAY_TO_WORLD (2) */ 9
-#define TURN_WAIT 6
 #define THRUST_WAIT 6
-#define WEAPON_WAIT 5
-#define SPECIAL_WAIT 0
-
+#define TURN_WAIT 6
 #define SHIP_MASS 7
 
+// Plasmoid
+#define WEAPON_ENERGY_COST 20
+#define WEAPON_WAIT 5
+#define MYCON_OFFSET RES_SCALE(24)
+#define MISSILE_OFFSET 0
 #define NUM_PLASMAS 11
 #define NUM_GLOBALLS 8
 #define PLASMA_DURATION 13
 #define MISSILE_LIFE (NUM_PLASMAS * PLASMA_DURATION)
-#define MISSILE_SPEED DISPLAY_TO_WORLD (8 << RESOLUTION_FACTOR) // JMS_GFX
+#define MISSILE_SPEED DISPLAY_TO_WORLD RES_SCALE(8)
+#define MISSILE_DAMAGE 10
+#define TRACK_WAIT 1
+
+// Regenerate
+#define SPECIAL_ENERGY_COST MAX_ENERGY
+#define SPECIAL_WAIT 0
+#define REGENERATION_AMOUNT 4
+
+// HD
+#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (14) */ 54
+#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (4) */ 18
+#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (28) */ 108
+#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (8) */ 36
+
+#define MAX_THRUST_HIRES /* DISPLAY_TO_WORLD (20) */ 108 // DC_GFX
+#define THRUST_INCREMENT_HIRES MAX_THRUST_HIRES // DC_GFX
 
-static RACE_DESC mycon_desc =
+static RACE_DESC mycon_desc1x =
 {
 	{ /* SHIP_INFO */
+		"podship",
 		FIRES_FORE | SEEKING_WEAPON,
 		21, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -65,8 +78,6 @@ static RACE_DESC mycon_desc =
 		},
 	},
 	{
-		//MAX_THRUST_HIRES,
-		//THRUST_INCREMENT_HIRES,
 		MAX_THRUST,
 		THRUST_INCREMENT,
 		ENERGY_REGENERATION,
@@ -120,13 +131,10 @@ static RACE_DESC mycon_desc =
 };
 
 // JMS_GFX
-#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (14) */ 54
-#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (4) */ 18
-
-// JMS_GFX
-static RACE_DESC mycon_desc_2xres =
+static RACE_DESC mycon_desc2x =
 {
 	{ /* SHIP_INFO */
+		"podship",
 		FIRES_FORE | SEEKING_WEAPON,
 		21, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -196,13 +204,10 @@ static RACE_DESC mycon_desc_2xres =
 };
 
 // JMS_GFX
-#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (28) */ 108
-#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (8) */ 36
-
-// JMS_GFX
-static RACE_DESC mycon_desc_4xres =
+static RACE_DESC mycon_desc4x =
 {
 	{ /* SHIP_INFO */
+		"podship",
 		FIRES_FORE | SEEKING_WEAPON,
 		21, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -271,9 +276,6 @@ static RACE_DESC mycon_desc_4xres =
 	0, /* CodeRef */
 };
 
-#define MISSILE_DAMAGE 10
-#define TRACK_WAIT 1
-
 static void
 plasma_preprocess (ELEMENT *ElementPtr)
 {
@@ -282,14 +284,16 @@ plasma_preprocess (ELEMENT *ElementPtr)
 	if (ElementPtr->mass_points > ElementPtr->hit_points)
 		ElementPtr->life_span = ElementPtr->hit_points * PLASMA_DURATION;
 	else
-		ElementPtr->hit_points = (BYTE)((ElementPtr->life_span * MISSILE_DAMAGE + (MISSILE_LIFE - 1)) / MISSILE_LIFE);
-	
+		ElementPtr->hit_points = (BYTE)((ElementPtr->life_span *
+				MISSILE_DAMAGE + (MISSILE_LIFE - 1)) / MISSILE_LIFE);
 	ElementPtr->mass_points = ElementPtr->hit_points;
-	plasma_index = NUM_PLASMAS - ((ElementPtr->life_span + (PLASMA_DURATION - 1)) / PLASMA_DURATION);
-	
+	plasma_index = NUM_PLASMAS - ((ElementPtr->life_span +
+			(PLASMA_DURATION - 1)) / PLASMA_DURATION);
 	if (plasma_index != GetFrameIndex (ElementPtr->next.image.frame))
 	{
-		ElementPtr->next.image.frame = SetAbsFrameIndex (ElementPtr->next.image.frame, plasma_index);
+		ElementPtr->next.image.frame =
+				SetAbsFrameIndex (ElementPtr->next.image.frame,
+				plasma_index);
 		ElementPtr->state_flags |= CHANGING;
 	}
 
@@ -299,10 +303,12 @@ plasma_preprocess (ELEMENT *ElementPtr)
 	{
 		COUNT facing;
 
-		facing = NORMALIZE_FACING (ANGLE_TO_FACING ( GetVelocityTravelAngle (&ElementPtr->velocity)));
-		
+		facing = NORMALIZE_FACING (ANGLE_TO_FACING (
+				GetVelocityTravelAngle (&ElementPtr->velocity)
+				));
 		if (TrackShip (ElementPtr, &facing) > 0)
-			SetVelocityVector (&ElementPtr->velocity, MISSILE_SPEED, facing);
+			SetVelocityVector (&ElementPtr->velocity,
+					MISSILE_SPEED, facing);
 
 		ElementPtr->turn_wait = TRACK_WAIT;
 	}
@@ -437,7 +443,7 @@ mycon_intelligence (ELEMENT *ShipPtr, EV
 	if (StarShipPtr->special_counter == 0)
 	{
 		StarShipPtr->ship_input_state &= ~SPECIAL;
-		StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = DISPLAY_TO_WORLD (800 << RESOLUTION_FACTOR); // JMS_GFX
+		StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = DISPLAY_TO_WORLD (RES_SCALE(800));
 		if (ShipPtr->crew_level < StarShipPtr->RaceDescPtr->ship_info.max_crew)
 		{
 			StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = MISSILE_SPEED * MISSILE_LIFE;
@@ -451,8 +457,6 @@ mycon_intelligence (ELEMENT *ShipPtr, EV
 static COUNT
 initialize_plasma (ELEMENT *ShipPtr, HELEMENT PlasmaArray[])
 {
-#define MYCON_OFFSET (24 << RESOLUTION_FACTOR) // JMS_GFX
-#define MISSILE_OFFSET 0
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -497,7 +501,6 @@ mycon_postprocess (ELEMENT *ElementPtr)
 			&& ElementPtr->crew_level != StarShipPtr->RaceDescPtr->ship_info.max_crew
 			&& DeltaEnergy (ElementPtr, -SPECIAL_ENERGY_COST))
 	{
-#define REGENERATION_AMOUNT 4
 		SIZE add_crew;
 
 		ProcessSound (SetAbsSoundIndex (
@@ -516,29 +519,16 @@ mycon_postprocess (ELEMENT *ElementPtr)
 RACE_DESC*
 init_mycon (void)
 {
+	static RACE_DESC mycon_desc;
 	RACE_DESC *RaceDescPtr;
 
-	if (RESOLUTION_FACTOR == 0)
-	{
-		mycon_desc.postprocess_func = mycon_postprocess;
-		mycon_desc.init_weapon_func = initialize_plasma;
-		mycon_desc.cyborg_control.intelligence_func = mycon_intelligence;
-		RaceDescPtr = &mycon_desc;
-	}
-	else if (RESOLUTION_FACTOR == 1)
-	{
-		mycon_desc_2xres.postprocess_func = mycon_postprocess;
-		mycon_desc_2xres.init_weapon_func = initialize_plasma;
-		mycon_desc_2xres.cyborg_control.intelligence_func = mycon_intelligence;
-		RaceDescPtr = &mycon_desc_2xres;
-	}
-	else
-	{
-		mycon_desc_4xres.postprocess_func = mycon_postprocess;
-		mycon_desc_4xres.init_weapon_func = initialize_plasma;
-		mycon_desc_4xres.cyborg_control.intelligence_func = mycon_intelligence;
-		RaceDescPtr = &mycon_desc_4xres;
-	}
+	mycon_desc = (RESOLUTION_FACTOR == 0 ? mycon_desc1x : (RESOLUTION_FACTOR == 1 ? mycon_desc2x : mycon_desc4x));
+
+	mycon_desc.postprocess_func = mycon_postprocess;
+	mycon_desc.init_weapon_func = initialize_plasma;
+	mycon_desc.cyborg_control.intelligence_func = mycon_intelligence;
+
+	RaceDescPtr = &mycon_desc;
 
 	return (RaceDescPtr);
 }
diff -ruNp src.hd/uqm/ships/mycon/mycon.h src/uqm/ships/mycon/mycon.h
--- src.hd/uqm/ships/mycon/mycon.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/mycon/mycon.h	2017-12-29 00:57:52 -0800
@@ -17,7 +17,15 @@
 #ifndef MYCON_H
 #define MYCON_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_mycon (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* MYCON_H */
 
diff -ruNp src.hd/uqm/ships/mycon/resinst.h src/uqm/ships/mycon/resinst.h
--- src.hd/uqm/ships/mycon/resinst.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/mycon/resinst.h	2017-12-29 00:57:52 -0800
@@ -1,14 +1,16 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define MYCON_BIG_MASK_PMAP_ANIM "ship.mycon.graphics.podship.large"
 #define MYCON_CAPTAIN_MASK_PMAP_ANIM "ship.mycon.graphics.captain"
 #define MYCON_ICON_MASK_PMAP_ANIM "ship.mycon.icons"
 #define MYCON_MED_MASK_PMAP_ANIM "ship.mycon.graphics.podship.medium"
 #define MYCON_MICON_MASK_PMAP_ANIM "ship.mycon.meleeicons"
+#define MYCON_RACE_STRINGS "ship.mycon.text"
+#define MYCON_SHIP_SOUNDS "ship.mycon.sounds"
 #define MYCON_SML_MASK_PMAP_ANIM "ship.mycon.graphics.podship.small"
+#define MYCON_VICTORY_SONG "ship.mycon.ditty"
 #define PLASMA_BIG_MASK_PMAP_ANIM "ship.mycon.graphics.plasma.large"
 #define PLASMA_MED_MASK_PMAP_ANIM "ship.mycon.graphics.plasma.medium"
 #define PLASMA_SML_MASK_PMAP_ANIM "ship.mycon.graphics.plasma.small"
-#define MYCON_RACE_STRINGS "ship.mycon.text"
-#define MYCON_SHIP_SOUNDS "ship.mycon.sounds"
-#define MYCON_VICTORY_SONG "ship.mycon.ditty"
-
-#include "icode.h"
diff -ruNp src.hd/uqm/ships/orz/Makeinfo src/uqm/ships/orz/Makeinfo
--- src.hd/uqm/ships/orz/Makeinfo	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/orz/Makeinfo	2017-12-29 00:57:52 -0800
@@ -1 +1,2 @@
 uqm_CFILES="orz.c"
+uqm_HFILES="icode.h orz.h resinst.h"
diff -ruNp src.hd/uqm/ships/orz/icode.h src/uqm/ships/orz/icode.h
--- src.hd/uqm/ships/orz/icode.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/orz/icode.h	2017-12-29 00:57:52 -0800
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define ORZ_CODE "ship.orz.code"
diff -ruNp src.hd/uqm/ships/orz/orz.c src/uqm/ships/orz/orz.c
--- src.hd/uqm/ships/orz/orz.c	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/orz/orz.c	2017-12-29 00:57:52 -0800
@@ -24,28 +24,55 @@
 #include "uqm/globdata.h"
 #include "libs/mathlib.h"
 
-
+// Core characteristics
 #define MAX_CREW 16
 #define MAX_ENERGY 20
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST (MAX_ENERGY / 3)
-#define SPECIAL_ENERGY_COST 0
 #define ENERGY_WAIT 6
 #define MAX_THRUST 35
 #define THRUST_INCREMENT 5
-#define TURN_WAIT 1
 #define THRUST_WAIT 0
-#define WEAPON_WAIT 4
-#define SPECIAL_WAIT 12
-
+#define TURN_WAIT 1
 #define SHIP_MASS 4
+
+// Howitzer
+#define WEAPON_ENERGY_COST (MAX_ENERGY / 3)
+#define WEAPON_WAIT 4
 #define ORZ_OFFSET 9
 #define MISSILE_SPEED DISPLAY_TO_WORLD (30)
 #define MISSILE_LIFE 12
+#define MISSILE_HITS 2
+#define MISSILE_DAMAGE 3
+#define MISSILE_OFFSET 1
+
+// Marine
+#define SPECIAL_ENERGY_COST 0
+#define SPECIAL_WAIT 12
+#define MARINE_MAX_THRUST RES_SCALE(32)
+#define MARINE_THRUST_INCREMENT RES_SCALE(8)
+#define MARINE_HIT_POINTS 3
+#define MARINE_MASS_POINTS 1
+#define MAX_MARINES 8
+#define MARINE_WAIT 12
+#define ION_LIFE 1
+#define START_ION_COLOR BUILD_COLOR (MAKE_RGB15 (0x1F, 0x15, 0x00), 0x7A)
+
+// Rotating Turret
+#define TURRET_OFFSET RES_SCALE(14)
+#define TURRET_WAIT 3
 
-static RACE_DESC orz_desc =
+// HD
+#define MAX_THRUST_2XRES 70
+#define THRUST_INCREMENT_2XRES 10
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
+#define MAX_THRUST_4XRES 140
+#define THRUST_INCREMENT_4XRES 20
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
+
+static RACE_DESC orz_desc1x =
 {
 	{ /* SHIP_INFO */
+		"nemesis",
 		FIRES_FORE | SEEKING_SPECIAL,
 		23, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -115,14 +142,10 @@ static RACE_DESC orz_desc =
 };
 
 // JMS_GFX
-#define MAX_THRUST_2XRES 70
-#define THRUST_INCREMENT_2XRES 10
-#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
-
-// JMS_GFX
-static RACE_DESC orz_desc_2xres =
+static RACE_DESC orz_desc2x =
 {
 	{ /* SHIP_INFO */
+		"nemesis",
 		FIRES_FORE | SEEKING_SPECIAL,
 		23, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -192,14 +215,10 @@ static RACE_DESC orz_desc_2xres =
 };
 
 // JMS_GFX
-#define MAX_THRUST_4XRES 140
-#define THRUST_INCREMENT_4XRES 20
-#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
-
-// JMS_GFX
-static RACE_DESC orz_desc_4xres =
+static RACE_DESC orz_desc4x =
 {
 	{ /* SHIP_INFO */
+		"nemesis",
 		FIRES_FORE | SEEKING_SPECIAL,
 		23, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -276,15 +295,9 @@ howitzer_collision (ELEMENT *ElementPtr0
 		weapon_collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
 }
 
-#define TURRET_OFFSET (14 << RESOLUTION_FACTOR) // JMS_GFX
-#define TURRET_WAIT 3
-
 static COUNT
 initialize_turret_missile (ELEMENT *ShipPtr, HELEMENT MissileArray[])
 {
-#define MISSILE_HITS 2
-#define MISSILE_DAMAGE 3
-#define MISSILE_OFFSET (1 << RESOLUTION_FACTOR) // JMS_GFX
 	ELEMENT *TurretPtr;
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
@@ -314,7 +327,7 @@ initialize_turret_missile (ELEMENT *Ship
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = TURRET_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
+	MissileBlock.speed = RES_SCALE(MISSILE_SPEED);
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -334,8 +347,6 @@ initialize_turret_missile (ELEMENT *Ship
 	return (1);
 }
 
-#define MAX_MARINES 8
-
 static BYTE
 count_marines (STARSHIP *StarShipPtr, BOOLEAN FindSpot)
 {
@@ -383,7 +394,8 @@ count_marines (STARSHIP *StarShipPtr, BO
 }
 
 static void
-orz_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern, COUNT ConcernCounter)
+orz_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+		COUNT ConcernCounter)
 {
 	ELEMENT *TurretPtr;
 	STARSHIP *StarShipPtr;
@@ -463,8 +475,6 @@ orz_intelligence (ELEMENT *ShipPtr, EVAL
 	UnlockElement (GetSuccElement (ShipPtr));
 }
 
-#define START_ION_COLOR BUILD_COLOR (MAKE_RGB15 (0x1F, 0x15, 0x00), 0x7A)
-
 static void
 ion_preprocess (ELEMENT *ElementPtr)
 {
@@ -505,8 +515,6 @@ ion_preprocess (ELEMENT *ElementPtr)
 
 static void marine_preprocess (ELEMENT *ElementPtr);
 
-#define MARINE_WAIT 12
-
 void
 intruder_preprocess (ELEMENT *ElementPtr)
 {
@@ -541,17 +549,15 @@ intruder_preprocess (ELEMENT *ElementPtr
 			{
 				--ElementPtr->thrust_wait;
 
-				if (RESOLUTION_FACTOR < 2)
-				{
+				if (RESOLUTION_FACTOR < 2) {
 					s.origin.x = (16 << RESOLUTION_FACTOR) + (ElementPtr->turn_wait & 3) * ((9 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
 					s.origin.y = (14 << RESOLUTION_FACTOR) + (ElementPtr->turn_wait >> 2) * ((11 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
-				}
-				else
-				{
+				} else {
 					s.origin.x = (16 - (RESOLUTION_FACTOR * 3 / 2) + (ElementPtr->turn_wait & 3) * (9 + RESOLUTION_FACTOR * 3 / 2)) << RESOLUTION_FACTOR; // JMS_GFX
 					s.origin.y = (14 + (ElementPtr->turn_wait >> 2) * (11 + RESOLUTION_FACTOR)) << RESOLUTION_FACTOR; // JMS_GFX
 				}
 				s.frame = SetAbsFrameIndex (ElementPtr->next.image.farray[0], GetFrameCount (ElementPtr->next.image.farray[0]) - 2);
+
 				ModifySilhouette (ShipPtr, &s, 0);
 			}
 
@@ -563,13 +569,10 @@ intruder_preprocess (ELEMENT *ElementPtr
 				UnlockElement (hElement);
 				hElement = 0;
 LeftShip:
-				if (RESOLUTION_FACTOR < 2)
-				{
+				if (RESOLUTION_FACTOR < 2) {
 					s.origin.x = (16 << RESOLUTION_FACTOR) + (ElementPtr->turn_wait & 3) * ((9 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
 					s.origin.y = (14 << RESOLUTION_FACTOR) + (ElementPtr->turn_wait >> 2) * ((11 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
-				}
-				else
-				{
+				} else {
 					s.origin.x = (16 - (RESOLUTION_FACTOR * 3 / 2) + (ElementPtr->turn_wait & 3) * (9 + RESOLUTION_FACTOR * 3 / 2)) << RESOLUTION_FACTOR; // JMS_GFX
 					s.origin.y = (14 + (ElementPtr->turn_wait >> 2) * (11 + RESOLUTION_FACTOR)) << RESOLUTION_FACTOR; // JMS_GFX
 				}
@@ -588,11 +591,12 @@ LeftShip:
 					ElementPtr->life_span = 0;
 					ElementPtr->state_flags |= DISAPPEARING;
 
-					ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 4), ElementPtr);
+					ProcessSound (SetAbsSoundIndex (
+							StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 4), ElementPtr);
 					goto LeftShip;
 				}
 				else if (randval < (0x0100 / 2 + 0x0100 / 16))
-				{		
+				{
 					if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
 						(((PlayerControl[0] & COMPUTER_CONTROL) && ElementPtr->playerNr == 0) || 
 						((PlayerControl[1] & COMPUTER_CONTROL) && ElementPtr->playerNr == 1))))
@@ -604,19 +608,18 @@ LeftShip:
 					}
 
 					++ElementPtr->thrust_wait;
-					if (RESOLUTION_FACTOR < 2)
-					{
+					if (RESOLUTION_FACTOR < 2) {
 						s.origin.x = (16 << RESOLUTION_FACTOR) + (ElementPtr->turn_wait & 3) * ((9 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
 						s.origin.y = (14 << RESOLUTION_FACTOR) + (ElementPtr->turn_wait >> 2) * ((11 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
-					}
-					else
-					{
+					} else {
 						s.origin.x = (16 - (RESOLUTION_FACTOR * 3 / 2) + (ElementPtr->turn_wait & 3) * (9 + RESOLUTION_FACTOR * 3 / 2)) << RESOLUTION_FACTOR; // JMS_GFX
 						s.origin.y = (14 + (ElementPtr->turn_wait >> 2) * (11 + RESOLUTION_FACTOR)) << RESOLUTION_FACTOR; // JMS_GFX
 					}
 					s.frame = SetAbsFrameIndex (ElementPtr->next.image.farray[0], GetFrameCount (ElementPtr->next.image.farray[0]) - 1);
+
 					ModifySilhouette (ShipPtr, &s, 0);
-					ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 3), ElementPtr);
+					ProcessSound (SetAbsSoundIndex (
+							StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 3), ElementPtr);
 				}
 			}
 
@@ -631,7 +634,8 @@ LeftShip:
 	{
 		ElementPtr->state_flags &= ~NONSOLID;
 		ElementPtr->state_flags |= CHANGING | CREW_OBJECT;
-		SetPrimType (&(GLOBAL (DisplayArray))[ElementPtr->PrimIndex], STAMP_PRIM);
+		SetPrimType (&(GLOBAL (DisplayArray))[ElementPtr->PrimIndex],
+				STAMP_PRIM);
 
 		ElementPtr->current.image.frame =
 				ElementPtr->next.image.frame =
@@ -654,7 +658,6 @@ spawn_marine_ion_trail (ELEMENT *Element
 	hIonElement = AllocElement ();
 	if (hIonElement)
 	{
-#define ION_LIFE 1
 		COUNT angle;
 		ELEMENT *IonElementPtr;
 
@@ -670,13 +673,15 @@ spawn_marine_ion_trail (ELEMENT *Element
 				// 'cycle_ion_trail', it is given new life a number of
 				// times, by setting life_span to thrust_wait.
 		SetPrimType (&(GLOBAL (DisplayArray))[IonElementPtr->PrimIndex],
-				POINT_PRIM);
+				POINT_PRIM); // Actual marine ion trail
 		SetPrimColor (&(GLOBAL (DisplayArray))[IonElementPtr->PrimIndex],
 				START_ION_COLOR);
 		IonElementPtr->colorCycleIndex = 0;
 		IonElementPtr->current.location = ElementPtr->current.location;
-		IonElementPtr->current.location.x += (COORD)COSINE (angle, DISPLAY_TO_WORLD (2 << RESOLUTION_FACTOR)); // JMS_GFX
-		IonElementPtr->current.location.y += (COORD)SINE (angle, DISPLAY_TO_WORLD (2 << RESOLUTION_FACTOR));   // JMS_GFX
+		IonElementPtr->current.location.x +=
+				(COORD)COSINE (angle, DISPLAY_TO_WORLD RES_SCALE(2));
+		IonElementPtr->current.location.y +=
+				(COORD)SINE (angle, DISPLAY_TO_WORLD RES_SCALE(2));
 		IonElementPtr->death_func = ion_preprocess;
 
 		SetElementStarShip (IonElementPtr, StarShipPtr);
@@ -806,7 +811,7 @@ marine_preprocess (ELEMENT *ElementPtr)
 			}
 			else
 			{
-				DWORD num_frames; // JMS_GFX: Was COUNT
+				DWORD num_frames;
 				VELOCITY_DESC ShipVelocity;
 
 				if (elementsOfSamePlayer (ObjectPtr, ElementPtr)
@@ -819,8 +824,10 @@ marine_preprocess (ELEMENT *ElementPtr)
 					ElementPtr->state_flags |= CHANGING;
 				}
 
-				num_frames = (WORLD_TO_TURN (square_root ((long)delta_x * delta_x + (long)delta_y * delta_y))) >> RESOLUTION_FACTOR; // JMS_GFX
-				
+				num_frames = (WORLD_TO_TURN (
+						square_root ((long)delta_x * delta_x
+						+ (long)delta_y * delta_y))) >> RESOLUTION_FACTOR;
+
 				if (num_frames == 0)
 					num_frames = 1;
 
@@ -828,9 +835,10 @@ marine_preprocess (ELEMENT *ElementPtr)
 				GetNextVelocityComponentsSdword (&ShipVelocity,
 						&delta_x, &delta_y, num_frames);
 
-				// JMS_GFX: Made the calculations use SDWORD to avoid overflows.
-				delta_x = ((SDWORD)ObjectPtr->current.location.x + delta_x) - (SDWORD)ElementPtr->current.location.x;
-				delta_y = ((SDWORD)ObjectPtr->current.location.y + delta_y) - (SDWORD)ElementPtr->current.location.y;
+				delta_x = ((SDWORD)ObjectPtr->current.location.x + delta_x)
+						- (SDWORD)ElementPtr->current.location.x;
+				delta_y = ((SDWORD)ObjectPtr->current.location.y + delta_y)
+						- (SDWORD)ElementPtr->current.location.y;
 
 				delta_facing = NORMALIZE_FACING (
 						ANGLE_TO_FACING (ARCTAN (delta_x, delta_y)) - facing);
@@ -873,8 +881,10 @@ marine_preprocess (ELEMENT *ElementPtr)
 			// XXX: thrust_wait is abused to store marine speed and
 			//   gravity well flags
 			StarShipPtr->cur_status_flags = ElementPtr->thrust_wait << 6;
-			StarShipPtr->RaceDescPtr->characteristics.thrust_increment = 8 << RESOLUTION_FACTOR; // JMS_GFX
-			StarShipPtr->RaceDescPtr->characteristics.max_thrust = 32 << RESOLUTION_FACTOR; // JMS_GFX
+			StarShipPtr->RaceDescPtr->characteristics.thrust_increment =
+					MARINE_THRUST_INCREMENT;
+			StarShipPtr->RaceDescPtr->characteristics.max_thrust =
+					MARINE_MAX_THRUST;
 
 			thrust_status = inertial_thrust (ElementPtr);
 
@@ -908,7 +918,7 @@ marine_collision (ELEMENT *ElementPtr0,
 		if (!elementsOfSamePlayer (ElementPtr0, ElementPtr1)) {
 			ElementPtr0->turn_wait = MAKE_BYTE (5, HINIBBLE (ElementPtr0->turn_wait));
 			ElementPtr0->thrust_wait &= ~((SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED) >> 6);
-			ElementPtr0->state_flags |= COLLISION; // Marines Disappear on collision if removed
+			ElementPtr0->state_flags |= COLLISION;
 		}
 		if (GRAVITY_MASS (ElementPtr1->mass_points)) {
 			ElementPtr0->state_flags |= NONSOLID | FINITE_LIFE;
@@ -923,66 +933,38 @@ marine_collision (ELEMENT *ElementPtr0,
 				ElementPtr0->life_span = 0;
 			} else if ((ElementPtr0->state_flags & IGNORE_SIMILAR) && ElementPtr1->crew_level) {
 				if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
-					(((PlayerControl[0] & COMPUTER_CONTROL) && ElementPtr1->playerNr == 1) || 
-					((PlayerControl[1] & COMPUTER_CONTROL) && ElementPtr1->playerNr == 0))))
-				{					
+				(((PlayerControl[0] & COMPUTER_CONTROL) && ElementPtr1->playerNr == 1) || 
+				((PlayerControl[1] & COMPUTER_CONTROL) && ElementPtr1->playerNr == 0))))
+				{
 					if (!DeltaCrew (ElementPtr1, 0)){ // Marines won't damage player while boarding
 						ElementPtr1->life_span = 0;
-					} else {
-						ElementPtr0->turn_wait = count_marines (StarShipPtr, TRUE);
-						ElementPtr0->thrust_wait = MARINE_WAIT;
-						ElementPtr0->next.image.frame = SetAbsFrameIndex (ElementPtr0->next.image.farray[0], 22 + ElementPtr0->turn_wait);
-						ElementPtr0->state_flags |= NONSOLID;
-						ElementPtr0->state_flags &= ~CREW_OBJECT;
-						SetPrimType (&(GLOBAL (DisplayArray))[ElementPtr0->PrimIndex], NO_PRIM);
-						ElementPtr0->preprocess_func = intruder_preprocess;
-						if (RESOLUTION_FACTOR < 2) {
-							s.origin.x = (16 << RESOLUTION_FACTOR) + (ElementPtr0->turn_wait & 3) * ((9 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
-							s.origin.y = (14 << RESOLUTION_FACTOR) + (ElementPtr0->turn_wait >> 2) * ((11 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
-						} else {
-							s.origin.x = (16 - (RESOLUTION_FACTOR * 3 / 2) + (ElementPtr0->turn_wait & 3) * (9 + RESOLUTION_FACTOR * 3 / 2)) << RESOLUTION_FACTOR; // JMS_GFX
-							s.origin.y = (14 + (ElementPtr0->turn_wait >> 2) * (11 + RESOLUTION_FACTOR)) << RESOLUTION_FACTOR; // JMS_GFX
-						}					
-						// JMS: Draw the shadow.
-						s.frame = ElementPtr0->next.image.frame;
-						ModifySilhouette (ElementPtr1, &s, 0);					
-						// JMS: Draw the marine.
-						ElementPtr0->next.image.frame = SetAbsFrameIndex (ElementPtr0->next.image.farray[0], 22 + ElementPtr0->turn_wait);
-						s.frame = ElementPtr0->next.image.frame;
-						ModifySilhouette (ElementPtr1, &s, 0);
 					}
-					ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 2), ElementPtr1);
 				} else {
 					if (!DeltaCrew (ElementPtr1, -1)){
 						ElementPtr1->life_span = 0;
-					} else {
-						ElementPtr0->turn_wait = count_marines (StarShipPtr, TRUE);
-						ElementPtr0->thrust_wait = MARINE_WAIT;
-						ElementPtr0->next.image.frame = SetAbsFrameIndex (ElementPtr0->next.image.farray[0], 22 + ElementPtr0->turn_wait);
-						ElementPtr0->state_flags |= NONSOLID;
-						ElementPtr0->state_flags &= ~CREW_OBJECT;
-						SetPrimType (&(GLOBAL (DisplayArray))[ElementPtr0->PrimIndex], NO_PRIM);
-						ElementPtr0->preprocess_func = intruder_preprocess;
-						if (RESOLUTION_FACTOR < 2) {
-							s.origin.x = (16 << RESOLUTION_FACTOR) + (ElementPtr0->turn_wait & 3) * ((9 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
-							s.origin.y = (14 << RESOLUTION_FACTOR) + (ElementPtr0->turn_wait >> 2) * ((11 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
-						} else {
-							s.origin.x = (16 - (RESOLUTION_FACTOR * 3 / 2) + (ElementPtr0->turn_wait & 3) * (9 + RESOLUTION_FACTOR * 3 / 2)) << RESOLUTION_FACTOR; // JMS_GFX
-							s.origin.y = (14 + (ElementPtr0->turn_wait >> 2) * (11 + RESOLUTION_FACTOR)) << RESOLUTION_FACTOR; // JMS_GFX
-						}					
-						// JMS: Draw the shadow.
-						s.frame = ElementPtr0->next.image.frame;
-						ModifySilhouette (ElementPtr1, &s, 0);					
-						// JMS: Draw the marine.
-						ElementPtr0->next.image.frame = SetAbsFrameIndex (ElementPtr0->next.image.farray[0], 22 + ElementPtr0->turn_wait);
-						s.frame = ElementPtr0->next.image.frame;
-						ModifySilhouette (ElementPtr1, &s, 0);
-					}
-					ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 2), ElementPtr1);
+					}					
 				}
+				ElementPtr0->turn_wait = count_marines (StarShipPtr, TRUE);
+				ElementPtr0->thrust_wait = MARINE_WAIT;
+				ElementPtr0->next.image.frame = SetAbsFrameIndex (ElementPtr0->next.image.farray[0], 22 + ElementPtr0->turn_wait);
+				ElementPtr0->state_flags |= NONSOLID;
+				ElementPtr0->state_flags &= ~CREW_OBJECT;
+				SetPrimType (&(GLOBAL (DisplayArray))[ElementPtr0->PrimIndex], NO_PRIM);
+				ElementPtr0->preprocess_func = intruder_preprocess;
+				if (RESOLUTION_FACTOR < 2) {
+					s.origin.x = (16 << RESOLUTION_FACTOR) + (ElementPtr0->turn_wait & 3) * ((9 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
+					s.origin.y = (14 << RESOLUTION_FACTOR) + (ElementPtr0->turn_wait >> 2) * ((11 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
+				} else {
+					s.origin.x = (16 - (RESOLUTION_FACTOR * 3 / 2) + (ElementPtr0->turn_wait & 3) * (9 + RESOLUTION_FACTOR * 3 / 2)) << RESOLUTION_FACTOR; // JMS_GFX
+					s.origin.y = (14 + (ElementPtr0->turn_wait >> 2) * (11 + RESOLUTION_FACTOR)) << RESOLUTION_FACTOR; // JMS_GFX
+				}
+				s.frame = ElementPtr0->next.image.frame;
+				ModifySilhouette (ElementPtr1, &s, 0);
+				ElementPtr0->next.image.frame = SetAbsFrameIndex (ElementPtr0->next.image.farray[0], 22 + ElementPtr0->turn_wait);
+				ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 2), ElementPtr1);
 			}
 			ElementPtr0->state_flags &= ~COLLISION;
-		}
+		}			
 	}
 	(void) pPt0;  /* Satisfying compiler (unused parameter) */
 	(void) pPt1;  /* Satisfying compiler (unused parameter) */
@@ -1145,16 +1127,16 @@ turret_postprocess (ELEMENT *ElementPtr)
 				SpaceMarinePtr->state_flags = IGNORE_SIMILAR | APPEARING
 						| CREW_OBJECT;
 				SpaceMarinePtr->life_span = NORMAL_LIFE;
-				SpaceMarinePtr->hit_points = 3;
-				SpaceMarinePtr->mass_points = 1;
+				SpaceMarinePtr->hit_points = MARINE_HIT_POINTS;
+				SpaceMarinePtr->mass_points = MARINE_MASS_POINTS;
 
 				facing = FACING_TO_ANGLE (StarShipPtr->ShipFacing);
 				SpaceMarinePtr->current.location.x =
-				ShipPtr->current.location.x
-				- COSINE (facing, DISPLAY_TO_WORLD (TURRET_OFFSET << ((RESOLUTION_FACTOR + 1)/2))); // JMS_GFX
+						ShipPtr->current.location.x
+						- COSINE (facing, DISPLAY_TO_WORLD (TURRET_OFFSET << ((RESOLUTION_FACTOR + 1)/2))); // JMS_GFX
 				SpaceMarinePtr->current.location.y =
-				ShipPtr->current.location.y
-				- SINE (facing, DISPLAY_TO_WORLD (TURRET_OFFSET << ((RESOLUTION_FACTOR + 1)/2))); // JMS_GFX
+						ShipPtr->current.location.y
+						- SINE (facing, DISPLAY_TO_WORLD (TURRET_OFFSET << ((RESOLUTION_FACTOR + 1)/2))); // JMS_GFX
 				SpaceMarinePtr->current.image.farray =
 						StarShipPtr->RaceDescPtr->ship_data.special;
 				SpaceMarinePtr->current.image.frame = SetAbsFrameIndex (
@@ -1173,8 +1155,7 @@ turret_postprocess (ELEMENT *ElementPtr)
 
 				UnlockElement (hSpaceMarine);
 				PutElement (hSpaceMarine);
-				
-		
+
 				if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
 					(((PlayerControl[0] & COMPUTER_CONTROL) && ElementPtr->playerNr == 1) || 
 					((PlayerControl[1] & COMPUTER_CONTROL) && ElementPtr->playerNr == 0))))
@@ -1251,29 +1232,16 @@ orz_preprocess (ELEMENT *ElementPtr)
 RACE_DESC*
 init_orz (void)
 {
+	static RACE_DESC orz_desc;
 	RACE_DESC *RaceDescPtr;
 
-	if (RESOLUTION_FACTOR == 0)
-	{
-		orz_desc.preprocess_func = orz_preprocess;
-		orz_desc.init_weapon_func = initialize_turret_missile;
-		orz_desc.cyborg_control.intelligence_func = orz_intelligence;
-		RaceDescPtr = &orz_desc;
-	}
-	else if (RESOLUTION_FACTOR == 1)
-	{
-		orz_desc_2xres.preprocess_func = orz_preprocess;
-		orz_desc_2xres.init_weapon_func = initialize_turret_missile;
-		orz_desc_2xres.cyborg_control.intelligence_func = orz_intelligence;
-		RaceDescPtr = &orz_desc_2xres;
-	}
-	else
-	{
-		orz_desc_4xres.preprocess_func = orz_preprocess;
-		orz_desc_4xres.init_weapon_func = initialize_turret_missile;
-		orz_desc_4xres.cyborg_control.intelligence_func = orz_intelligence;
-		RaceDescPtr = &orz_desc_4xres;
-	}
+	orz_desc = (RESOLUTION_FACTOR == 0 ? orz_desc1x : (RESOLUTION_FACTOR == 1 ? orz_desc2x : orz_desc4x));
+
+	orz_desc.preprocess_func = orz_preprocess;
+	orz_desc.init_weapon_func = initialize_turret_missile;
+	orz_desc.cyborg_control.intelligence_func = orz_intelligence;
+
+	RaceDescPtr = &orz_desc;
 
 	return (RaceDescPtr);
 }
diff -ruNp src.hd/uqm/ships/orz/orz.h src/uqm/ships/orz/orz.h
--- src.hd/uqm/ships/orz/orz.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/orz/orz.h	2017-12-29 00:57:52 -0800
@@ -17,11 +17,19 @@
 #ifndef ORZ_H
 #define ORZ_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_orz (void);
 
 void intruder_preprocess (ELEMENT *ElementPtr);
 void marine_collision (ELEMENT *ElementPtr0, POINT *pPt0,
 		ELEMENT *ElementPtr1, POINT *pPt1);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* ORZ_H */
 
diff -ruNp src.hd/uqm/ships/orz/resinst.h src/uqm/ships/orz/resinst.h
--- src.hd/uqm/ships/orz/resinst.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/orz/resinst.h	2017-12-29 00:57:52 -0800
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define HOWITZER_BIG_MASK_PMAP_ANIM "ship.orz.graphics.howitzer.large"
 #define HOWITZER_MED_MASK_PMAP_ANIM "ship.orz.graphics.howitzer.medium"
 #define HOWITZER_SML_MASK_PMAP_ANIM "ship.orz.graphics.howitzer.small"
@@ -6,12 +10,10 @@
 #define ORZ_ICON_MASK_PMAP_ANIM "ship.orz.icons"
 #define ORZ_MED_MASK_PMAP_ANIM "ship.orz.graphics.nemesis.medium"
 #define ORZ_MICON_MASK_PMAP_ANIM "ship.orz.meleeicons"
+#define ORZ_RACE_STRINGS "ship.orz.text"
+#define ORZ_SHIP_SOUNDS "ship.orz.sounds"
 #define ORZ_SML_MASK_PMAP_ANIM "ship.orz.graphics.nemesis.small"
+#define ORZ_VICTORY_SONG "ship.orz.ditty"
 #define TURRET_BIG_MASK_PMAP_ANIM "ship.orz.graphics.turret.large"
 #define TURRET_MED_MASK_PMAP_ANIM "ship.orz.graphics.turret.medium"
 #define TURRET_SML_MASK_PMAP_ANIM "ship.orz.graphics.turret.small"
-#define ORZ_RACE_STRINGS "ship.orz.text"
-#define ORZ_SHIP_SOUNDS "ship.orz.sounds"
-#define ORZ_VICTORY_SONG "ship.orz.ditty"
-
-#include "icode.h"
diff -ruNp src.hd/uqm/ships/pkunk/Makeinfo src/uqm/ships/pkunk/Makeinfo
--- src.hd/uqm/ships/pkunk/Makeinfo	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/pkunk/Makeinfo	2017-12-29 00:57:52 -0800
@@ -1 +1,2 @@
 uqm_CFILES="pkunk.c"
+uqm_HFILES="icode.h pkunk.h resinst.h"
diff -ruNp src.hd/uqm/ships/pkunk/icode.h src/uqm/ships/pkunk/icode.h
--- src.hd/uqm/ships/pkunk/icode.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/pkunk/icode.h	2017-12-29 00:57:52 -0800
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define PKUNK_CODE "ship.pkunk.code"
diff -ruNp src.hd/uqm/ships/pkunk/pkunk.c src/uqm/ships/pkunk/pkunk.c
--- src.hd/uqm/ships/pkunk/pkunk.c	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/pkunk/pkunk.c	2017-12-29 00:57:52 -0800
@@ -19,33 +19,52 @@
 #include "../ship.h"
 #include "pkunk.h"
 #include "resinst.h"
-
 #include "uqm/globdata.h"
+#include "uqm/tactrans.h"
 #include "libs/mathlib.h"
-#include "../../setup.h"
 #include "../../settings.h" // JMS: For StopMusic
 
-
+// Core characteristics
 #define MAX_CREW 8
 #define MAX_ENERGY 12
 #define ENERGY_REGENERATION 0
-#define WEAPON_ENERGY_COST 1
-#define SPECIAL_ENERGY_COST 2
 #define ENERGY_WAIT 0
 #define MAX_THRUST 64
 #define THRUST_INCREMENT 16
-#define TURN_WAIT 0
 #define THRUST_WAIT 0
-#define WEAPON_WAIT 0
-#define SPECIAL_WAIT 16
-
+#define TURN_WAIT 0
 #define SHIP_MASS 1
+
+// Triple Miniguns
+#define WEAPON_ENERGY_COST 1
+#define WEAPON_WAIT 0
+#define PKUNK_OFFSET RES_SCALE(15)
+#define MISSILE_OFFSET RES_SCALE(1)
 #define MISSILE_SPEED DISPLAY_TO_WORLD (24)
 #define MISSILE_LIFE 5
+#define MISSILE_HITS 1
+#define MISSILE_DAMAGE 1
+
+// Taunt
+#define SPECIAL_ENERGY_COST 2
+#define SPECIAL_WAIT 16
+
+// Respawn
+#define PHOENIX_LIFE 12
+#define START_PHOENIX_COLOR BUILD_COLOR (MAKE_RGB15 (0x1F, 0x15, 0x00), 0x7A)
+#define TRANSITION_LIFE 1
+#define TRANSITION_SPEED DISPLAY_TO_WORLD RES_SCALE(20)
+
+// HD
+#define MAX_THRUST_2XRES 128
+#define THRUST_INCREMENT_2XRES 32
+#define MAX_THRUST_4XRES 256
+#define THRUST_INCREMENT_4XRES 64
 
-static RACE_DESC pkunk_desc =
+static RACE_DESC pkunk_desc1x =
 {
 	{ /* SHIP_INFO */
+		"fury",
 		FIRES_FORE | FIRES_LEFT | FIRES_RIGHT,
 		20, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -115,13 +134,10 @@ static RACE_DESC pkunk_desc =
 };
 
 // JMS_GFX
-#define MAX_THRUST_2XRES 128
-#define THRUST_INCREMENT_2XRES 32
-
-// JMS_GFX
-static RACE_DESC pkunk_desc_2xres =
+static RACE_DESC pkunk_desc2x =
 {
 	{ /* SHIP_INFO */
+		"fury",
 		FIRES_FORE | FIRES_LEFT | FIRES_RIGHT,
 		20, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -191,13 +207,10 @@ static RACE_DESC pkunk_desc_2xres =
 };
 
 // JMS_GFX
-#define MAX_THRUST_4XRES 256
-#define THRUST_INCREMENT_4XRES 64
-
-// JMS_GFX
-static RACE_DESC pkunk_desc_4xres =
+static RACE_DESC pkunk_desc4x =
 {
 	{ /* SHIP_INFO */
+		"fury",
 		FIRES_FORE | FIRES_LEFT | FIRES_RIGHT,
 		20, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -266,6 +279,48 @@ static RACE_DESC pkunk_desc_4xres =
 	0, /* CodeRef */
 };
 
+// Private per-instance ship data
+typedef struct
+{
+	HELEMENT hPhoenix;
+	ElementProcessFunc *saved_preprocess_func;
+	ElementProcessFunc *saved_postprocess_func;
+	ElementProcessFunc *saved_death_func;
+	
+} PKUNK_DATA;
+
+// Local typedef
+typedef PKUNK_DATA CustomShipData_t;
+
+// Retrieve race-specific ship data from a race desc
+static CustomShipData_t *
+GetCustomShipData (RACE_DESC *pRaceDesc)
+{
+	return pRaceDesc->data;
+}
+
+// Set the race-specific data in a race desc
+// (Re)Allocates its own storage for the data.
+static void
+SetCustomShipData (RACE_DESC *pRaceDesc, const CustomShipData_t *data)
+{
+	if (pRaceDesc->data == data) 
+		return;  // no-op
+
+	if (pRaceDesc->data) // Out with the old
+	{
+		HFree (pRaceDesc->data);
+		pRaceDesc->data = NULL;
+	}
+
+	if (data) // In with the new
+	{
+		CustomShipData_t* newData = HMalloc (sizeof (*data));
+		*newData = *data;
+		pRaceDesc->data = newData;
+	}
+}
+
 static void
 animate (ELEMENT *ElementPtr)
 {
@@ -273,8 +328,10 @@ animate (ELEMENT *ElementPtr)
 		--ElementPtr->turn_wait;
 	else
 	{
-		ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->current.image.frame);
+		ElementPtr->next.image.frame =
+				IncFrameIndex (ElementPtr->current.image.frame);
 		ElementPtr->state_flags |= CHANGING;
+
 		ElementPtr->turn_wait = ElementPtr->next_turn;
 	}
 }
@@ -282,10 +339,6 @@ animate (ELEMENT *ElementPtr)
 static COUNT
 initialize_bug_missile (ELEMENT *ShipPtr, HELEMENT MissileArray[])
 {
-#define PKUNK_OFFSET (15 << RESOLUTION_FACTOR) // JMS_GFX
-#define MISSILE_HITS 1
-#define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET (1 << RESOLUTION_FACTOR) // JMS_GFX
 	COUNT i;
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
@@ -298,7 +351,7 @@ initialize_bug_missile (ELEMENT *ShipPtr
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = PKUNK_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
+	MissileBlock.speed = RES_SCALE(MISSILE_SPEED);
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -307,11 +360,11 @@ initialize_bug_missile (ELEMENT *ShipPtr
 
 	for (i = 0; i < 3; ++i)
 	{
-		MissileBlock.face = StarShipPtr->ShipFacing + (ANGLE_TO_FACING (QUADRANT) * i);
-		
+		MissileBlock.face =
+				StarShipPtr->ShipFacing
+				+ (ANGLE_TO_FACING (QUADRANT) * i);
 		if (i == 2)
 			MissileBlock.face += ANGLE_TO_FACING (QUADRANT);
-		
 		MissileBlock.face = NORMALIZE_FACING (MissileBlock.face);
 
 		if ((MissileArray[i] = initialize_missile (&MissileBlock)))
@@ -338,15 +391,15 @@ pkunk_intelligence (ELEMENT *ShipPtr, EV
 		COUNT ConcernCounter)
 {
 	STARSHIP *StarShipPtr;
-	HELEMENT hPhoenix;
+	PKUNK_DATA *PkunkData;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
-	hPhoenix = (HELEMENT) StarShipPtr->RaceDescPtr->data;
-	if (hPhoenix && (StarShipPtr->control & STANDARD_RATING))
+	PkunkData = GetCustomShipData (StarShipPtr->RaceDescPtr);
+	if (PkunkData->hPhoenix && (StarShipPtr->control & STANDARD_RATING))
 	{
-		RemoveElement (hPhoenix);
-		FreeElement (hPhoenix);
-		StarShipPtr->RaceDescPtr->data = 0;
+		RemoveElement (PkunkData->hPhoenix);
+		FreeElement (PkunkData->hPhoenix);
+		PkunkData->hPhoenix = 0;
 	}
 
 	if (StarShipPtr->RaceDescPtr->ship_info.energy_level <
@@ -360,111 +413,118 @@ pkunk_intelligence (ELEMENT *ShipPtr, EV
 }
 
 static void pkunk_preprocess (ELEMENT *ElementPtr);
-static void pkunk_postprocess (ELEMENT *ElementPtr);
 
 static void
 new_pkunk (ELEMENT *ElementPtr)
 {
 	STARSHIP *StarShipPtr;
+	PKUNK_DATA *PkunkData;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
-	if (!(ElementPtr->state_flags & PLAYER_SHIP))
-	{
-		ELEMENT *ShipPtr;
+	PkunkData = GetCustomShipData (StarShipPtr->RaceDescPtr);
 
-		LockElement (StarShipPtr->hShip, &ShipPtr);
-		ShipPtr->death_func = new_pkunk;
-		UnlockElement (StarShipPtr->hShip);
-	}
-	else
-	{
-		ElementPtr->state_flags = APPEARING | PLAYER_SHIP | IGNORE_SIMILAR;
-		ElementPtr->mass_points = SHIP_MASS;
-		ElementPtr->preprocess_func = StarShipPtr->RaceDescPtr->preprocess_func;
-		ElementPtr->postprocess_func = StarShipPtr->RaceDescPtr->postprocess_func;
-		ElementPtr->death_func =
-				(void (*) (ELEMENT *ElementPtr))
-						StarShipPtr->RaceDescPtr->init_weapon_func;
-		StarShipPtr->RaceDescPtr->preprocess_func = pkunk_preprocess;
-		StarShipPtr->RaceDescPtr->postprocess_func = pkunk_postprocess;
-		StarShipPtr->RaceDescPtr->init_weapon_func = initialize_bug_missile;
-		StarShipPtr->RaceDescPtr->ship_info.crew_level = MAX_CREW;
-		StarShipPtr->RaceDescPtr->ship_info.energy_level = MAX_ENERGY;
-					/* fix vux impairment */
-		StarShipPtr->RaceDescPtr->characteristics.max_thrust = MAX_THRUST << RESOLUTION_FACTOR; // JMS_GFX
-		StarShipPtr->RaceDescPtr->characteristics.thrust_increment = THRUST_INCREMENT << RESOLUTION_FACTOR; // JMS_GFX
-		StarShipPtr->RaceDescPtr->characteristics.turn_wait = TURN_WAIT;
-		StarShipPtr->RaceDescPtr->characteristics.thrust_wait = THRUST_WAIT;
-		StarShipPtr->RaceDescPtr->characteristics.special_wait = 0;
-
-		StarShipPtr->ship_input_state = 0;
-		StarShipPtr->cur_status_flags = 0;
-		StarShipPtr->old_status_flags = 0;
-		StarShipPtr->energy_counter = 0;
-		StarShipPtr->weapon_counter = 0;
-		StarShipPtr->special_counter = 0;
-		ElementPtr->crew_level = 0;
-		ElementPtr->turn_wait = 0;
-		ElementPtr->thrust_wait = 0;
-		ElementPtr->life_span = NORMAL_LIFE;
-
-		StarShipPtr->ShipFacing = NORMALIZE_FACING (TFB_Random ());
-		ElementPtr->current.image.farray = StarShipPtr->RaceDescPtr->ship_data.ship;
-		ElementPtr->current.image.frame =
-				SetAbsFrameIndex (StarShipPtr->RaceDescPtr->ship_data.ship[0],
-				StarShipPtr->ShipFacing);
-		SetPrimType (&(GLOBAL (DisplayArray))[ElementPtr->PrimIndex], STAMP_PRIM);
-
-		do
-		{
-			ElementPtr->current.location.x =
-					WRAP_X (DISPLAY_ALIGN_X (TFB_Random ()));
-			ElementPtr->current.location.y =
-					WRAP_Y (DISPLAY_ALIGN_Y (TFB_Random ()));
-		} while (CalculateGravity (ElementPtr)
-				|| TimeSpaceMatterConflict (ElementPtr));
+	ElementPtr->state_flags = APPEARING | PLAYER_SHIP | IGNORE_SIMILAR;
+	ElementPtr->mass_points = SHIP_MASS;
+	// Restore the element processing callbacks after the explosion.
+	// The callbacks were changed for the explosion sequence
+	ElementPtr->preprocess_func = PkunkData->saved_preprocess_func;
+	ElementPtr->postprocess_func = PkunkData->saved_postprocess_func;
+	ElementPtr->death_func = PkunkData->saved_death_func;
+	// preprocess_func() is called during the phoenix transition and
+	// then cleared, so we need to restore it
+	StarShipPtr->RaceDescPtr->preprocess_func = pkunk_preprocess;
+	StarShipPtr->RaceDescPtr->ship_info.crew_level = MAX_CREW;
+	StarShipPtr->RaceDescPtr->ship_info.energy_level = MAX_ENERGY;
+				/* fix vux impairment */
+	StarShipPtr->RaceDescPtr->characteristics.max_thrust = RES_SCALE(MAX_THRUST);
+	StarShipPtr->RaceDescPtr->characteristics.thrust_increment = RES_SCALE(THRUST_INCREMENT);
+	StarShipPtr->RaceDescPtr->characteristics.turn_wait = TURN_WAIT;
+	StarShipPtr->RaceDescPtr->characteristics.thrust_wait = THRUST_WAIT;
+	StarShipPtr->RaceDescPtr->characteristics.special_wait = 0;
+
+	StarShipPtr->ship_input_state = 0;
+	// Pkunk wins in a simultaneous destruction if it reincarnates
+	StarShipPtr->cur_status_flags &= PLAY_VICTORY_DITTY;
+	StarShipPtr->old_status_flags = 0;
+	StarShipPtr->energy_counter = 0;
+	StarShipPtr->weapon_counter = 0;
+	StarShipPtr->special_counter = 0;
+	ElementPtr->crew_level = 0;
+	ElementPtr->turn_wait = 0;
+	ElementPtr->thrust_wait = 0;
+	ElementPtr->life_span = NORMAL_LIFE;
+
+	StarShipPtr->ShipFacing = NORMALIZE_FACING (TFB_Random ());
+	ElementPtr->current.image.farray = StarShipPtr->RaceDescPtr->ship_data.ship;
+	ElementPtr->current.image.frame = SetAbsFrameIndex (
+			StarShipPtr->RaceDescPtr->ship_data.ship[0],
+			StarShipPtr->ShipFacing);
+	SetPrimType (&(GLOBAL (DisplayArray))[ElementPtr->PrimIndex], STAMP_PRIM);
+
+	do
+	{
+		ElementPtr->current.location.x =
+				WRAP_X (DISPLAY_ALIGN_X (TFB_Random ()));
+		ElementPtr->current.location.y =
+				WRAP_Y (DISPLAY_ALIGN_Y (TFB_Random ()));
+	} while (CalculateGravity (ElementPtr)
+			|| TimeSpaceMatterConflict (ElementPtr));
+
+	// XXX: Hack: Set hTarget!=0 so that ship_preprocess() does not
+	//   call ship_transition() for us.
+	ElementPtr->hTarget = StarShipPtr->hShip;
+}
 
-		ElementPtr->hTarget = StarShipPtr->hShip;
-	}
+// This function is called when the ship dies but reincarnates.
+// The generic ship_death() function is not called for the ship in this case.
+static void
+pkunk_reincarnation_death (ELEMENT *ShipPtr)
+{
+	// Simulate ship death
+	StopAllBattleMusic ();
+	StartShipExplosion (ShipPtr, true);
+	// Once the explosion ends, we will get a brand new ship
+	ShipPtr->death_func = new_pkunk;
 }
 
 static void
 intercept_pkunk_death (ELEMENT *ElementPtr)
 {
 	STARSHIP *StarShipPtr;
-
-	ElementPtr->state_flags &= ~DISAPPEARING;
-	ElementPtr->life_span = 1;
+	PKUNK_DATA *PkunkData;
+	ELEMENT *ShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
-	if (StarShipPtr->RaceDescPtr->ship_info.crew_level == 0)
-	{
-		ELEMENT *ShipPtr;
+	PkunkData = GetCustomShipData (StarShipPtr->RaceDescPtr);
+	
+	if (StarShipPtr->RaceDescPtr->ship_info.crew_level != 0)
+	{	// Ship not dead yet.
+		// Keep the Phoenix element alive.
+		ElementPtr->state_flags &= ~DISAPPEARING;
+		ElementPtr->life_span = 1;
+		return;
+	}
 
-		LockElement (StarShipPtr->hShip, &ShipPtr);
-		if (GRAVITY_MASS (ShipPtr->mass_points + 1))
-		{
-			ElementPtr->state_flags |= DISAPPEARING;
-			ElementPtr->life_span = 0;
-		}
-		else
-		{
-			ShipPtr->mass_points = MAX_SHIP_MASS + 1;
-			StarShipPtr->RaceDescPtr->preprocess_func = ShipPtr->preprocess_func;
-			StarShipPtr->RaceDescPtr->postprocess_func = ShipPtr->postprocess_func;
-			StarShipPtr->RaceDescPtr->init_weapon_func =
-					(COUNT (*) (ELEMENT *ElementPtr, HELEMENT Weapon[]))
-							ShipPtr->death_func;
+	LockElement (StarShipPtr->hShip, &ShipPtr);
+	// GRAVITY_MASS() indicates a warp-out here. If Pkunk dies while warping
+	// out, there is no reincarnation.
+	if (!GRAVITY_MASS (ShipPtr->mass_points + 1))
+	{
+		// XXX: Hack: Set mass_points to indicate a reincarnation to
+		//   FindAliveStarShip()
+		ShipPtr->mass_points = MAX_SHIP_MASS + 1;
+		// Save the various element processing callbacks before the
+		// explosion happens, because we were not the ones who set
+		// these callbacks and they are about to be changed.
+		PkunkData->saved_preprocess_func = ShipPtr->preprocess_func;
+		PkunkData->saved_postprocess_func = ShipPtr->postprocess_func;
+		PkunkData->saved_death_func = ShipPtr->death_func;
 
-			ElementPtr->death_func = new_pkunk;
-		}
-		UnlockElement (StarShipPtr->hShip);
+		ShipPtr->death_func = pkunk_reincarnation_death;
 	}
+	UnlockElement (StarShipPtr->hShip);
 }
 
-#define START_PHOENIX_COLOR BUILD_COLOR (MAKE_RGB15 (0x1F, 0x15, 0x00), 0x7A)
-#define TRANSITION_LIFE 1
-
 static void
 spawn_phoenix_trail (ELEMENT *ElementPtr)
 {
@@ -498,8 +558,6 @@ spawn_phoenix_trail (ELEMENT *ElementPtr
 	} // else, the element disappears.
 }
 
-#define PHOENIX_LIFE 12
-
 static void
 phoenix_transition (ELEMENT *ElementPtr)
 {
@@ -516,7 +574,6 @@ phoenix_transition (ELEMENT *ElementPtr)
 	}
 	else if ((hShipImage = AllocElement ()))
 	{
-#define TRANSITION_SPEED DISPLAY_TO_WORLD (20 << RESOLUTION_FACTOR) // JMS_GFX
 		COUNT angle;
 
 		PutElement (hShipImage);
@@ -548,13 +605,12 @@ phoenix_transition (ELEMENT *ElementPtr)
 			SDWORD temp_x, temp_y;
 			angle = FACING_TO_ANGLE (StarShipPtr->ShipFacing);
 
-            // JMS_GFX: Circumventing overflows by using temp variables
-            // instead of subtracting straight from the POINT sized
-            // ShipImagePtr->current.location.
-            temp_x = (SDWORD)ShipImagePtr->current.location.x -
-                COSINE (angle, TRANSITION_SPEED) * (ElementPtr->life_span - 1);
-            temp_y = (SDWORD)ShipImagePtr->current.location.y -
-                SINE (angle, TRANSITION_SPEED) * (ElementPtr->life_span - 1);
+            // JMS_GFX: Circumventing overflows by using temp variables instead of
+            // subtracting straight from the POINT sized ShipImagePtr->current.location.
+            temp_x = (SDWORD)ShipImagePtr->current.location.x - 
+				COSINE (angle, TRANSITION_SPEED) * (ElementPtr->life_span - 1);
+            temp_y = (SDWORD)ShipImagePtr->current.location.y - 
+				SINE (angle, TRANSITION_SPEED) * (ElementPtr->life_span - 1);
             
             ShipImagePtr->current.location.x = WRAP_X (temp_x);
             ShipImagePtr->current.location.y = WRAP_Y (temp_y);
@@ -575,15 +631,22 @@ static void
 pkunk_preprocess (ELEMENT *ElementPtr)
 {
 	STARSHIP *StarShipPtr;
+	PKUNK_DATA *PkunkData;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
+	PkunkData = GetCustomShipData (StarShipPtr->RaceDescPtr);
 	if (ElementPtr->state_flags & APPEARING)
 	{
 		HELEMENT hPhoenix = 0;
-		
-		if ((BYTE)TFB_Random () & 1)
+
+		if (TFB_Random () & 1)
 			hPhoenix = AllocElement ();
 
+		// The hPhoenix element is created and placed at the head of the
+		// queue so that it is preprocessed before any of the ships' elements
+		// are, and so before death_func() is called for the dead Pkunk.
+		// hPhoenix detects when the Pkunk ship dies and tweaks the ship,
+		// starting the death + reincarnation sequence.
 		if (hPhoenix)
 		{
 			ELEMENT *PhoenixPtr;
@@ -600,18 +663,19 @@ pkunk_preprocess (ELEMENT *ElementPtr)
 			UnlockElement (hPhoenix);
 			InsertElement (hPhoenix, GetHeadElement ());
 		}
-		StarShipPtr->RaceDescPtr->data = (intptr_t) hPhoenix;
+		PkunkData->hPhoenix = hPhoenix;
 
+		// XXX: Hack: new_pkunk() sets hTarget!=0 which indicates a
+		//   reincarnation to us.
 		if (ElementPtr->hTarget == 0)
+		{
+			// A brand new ship is preprocessed only once
 			StarShipPtr->RaceDescPtr->preprocess_func = 0;
+		}
 		else
-		{
+		{	// Start the reincarnation sequence
 			COUNT angle, facing;
 
-			// JMS: Kill Shofixti victory ditty if the this ship was reborn.
-			// Then play Pkunk's victory music.
-			StopMusic ();
-			
 			ProcessSound (SetAbsSoundIndex (
 					StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 1
 					), ElementPtr);
@@ -692,35 +756,36 @@ pkunk_postprocess (ELEMENT *ElementPtr)
 	}
 }
 
+static void
+uninit_pkunk (RACE_DESC *pRaceDesc)
+{
+	SetCustomShipData (pRaceDesc, NULL);
+}
+
 RACE_DESC*
 init_pkunk (void)
 {
+	static RACE_DESC pkunk_desc;
+	static RACE_DESC new_pkunk_desc;
 	RACE_DESC *RaceDescPtr;
+	PKUNK_DATA empty_data;
 
-	if (RESOLUTION_FACTOR == 0)
-	{
-		pkunk_desc.preprocess_func = pkunk_preprocess;
-		pkunk_desc.postprocess_func = pkunk_postprocess;
-		pkunk_desc.init_weapon_func = initialize_bug_missile;
-		pkunk_desc.cyborg_control.intelligence_func = pkunk_intelligence;
-		RaceDescPtr = &pkunk_desc;
-	}
-	else if (RESOLUTION_FACTOR == 1)
-	{
-		pkunk_desc_2xres.preprocess_func = pkunk_preprocess;
-		pkunk_desc_2xres.postprocess_func = pkunk_postprocess;
-		pkunk_desc_2xres.init_weapon_func = initialize_bug_missile;
-		pkunk_desc_2xres.cyborg_control.intelligence_func = pkunk_intelligence;
-		RaceDescPtr = &pkunk_desc_2xres;
-	}
-	else
-	{
-		pkunk_desc_4xres.preprocess_func = pkunk_preprocess;
-		pkunk_desc_4xres.postprocess_func = pkunk_postprocess;
-		pkunk_desc_4xres.init_weapon_func = initialize_bug_missile;
-		pkunk_desc_4xres.cyborg_control.intelligence_func = pkunk_intelligence;
-		RaceDescPtr = &pkunk_desc_4xres;
-	}
+	pkunk_desc = (RESOLUTION_FACTOR == 0 ? pkunk_desc1x : (RESOLUTION_FACTOR == 1 ? pkunk_desc2x : pkunk_desc4x));
+
+	// The caller of this func will copy the struct
+	memset (&empty_data, 0, sizeof (empty_data));
+
+	pkunk_desc.uninit_func = uninit_pkunk;
+	pkunk_desc.preprocess_func = pkunk_preprocess;
+	pkunk_desc.postprocess_func = pkunk_postprocess;
+	pkunk_desc.init_weapon_func = initialize_bug_missile;
+	pkunk_desc.cyborg_control.intelligence_func = pkunk_intelligence;
+
+	/* copy initial ship settings to the new descriptor */
+	new_pkunk_desc = pkunk_desc;
+	SetCustomShipData (&new_pkunk_desc, &empty_data);
+
+	RaceDescPtr = &new_pkunk_desc;
 
 	LastSound = 0;
 			// We need to reinitialise it at least each battle, to ensure
@@ -729,4 +794,3 @@ init_pkunk (void)
 
 	return (RaceDescPtr);
 }
-
diff -ruNp src.hd/uqm/ships/pkunk/pkunk.h src/uqm/ships/pkunk/pkunk.h
--- src.hd/uqm/ships/pkunk/pkunk.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/pkunk/pkunk.h	2017-12-29 00:57:52 -0800
@@ -17,7 +17,15 @@
 #ifndef PKUNK_H
 #define PKUNK_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_pkunk (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* PKUNK_H */
 
diff -ruNp src.hd/uqm/ships/pkunk/resinst.h src/uqm/ships/pkunk/resinst.h
--- src.hd/uqm/ships/pkunk/resinst.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/pkunk/resinst.h	2017-12-29 00:57:52 -0800
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define BUG_BIG_MASK_PMAP_ANIM "ship.pkunk.graphics.bug.large"
 #define BUG_MED_MASK_PMAP_ANIM "ship.pkunk.graphics.bug.medium"
 #define BUG_SML_MASK_PMAP_ANIM "ship.pkunk.graphics.bug.small"
@@ -6,9 +10,7 @@
 #define PKUNK_ICON_MASK_PMAP_ANIM "ship.pkunk.icons"
 #define PKUNK_MED_MASK_PMAP_ANIM "ship.pkunk.graphics.fury.medium"
 #define PKUNK_MICON_MASK_PMAP_ANIM "ship.pkunk.meleeicons"
-#define PKUNK_SML_MASK_PMAP_ANIM "ship.pkunk.graphics.fury.small"
 #define PKUNK_RACE_STRINGS "ship.pkunk.text"
 #define PKUNK_SHIP_SOUNDS "ship.pkunk.sounds"
+#define PKUNK_SML_MASK_PMAP_ANIM "ship.pkunk.graphics.fury.small"
 #define PKUNK_VICTORY_SONG "ship.pkunk.ditty"
-
-#include "icode.h"
diff -ruNp src.hd/uqm/ships/probe/Makeinfo src/uqm/ships/probe/Makeinfo
--- src.hd/uqm/ships/probe/Makeinfo	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/probe/Makeinfo	2017-12-29 00:57:52 -0800
@@ -1 +1,2 @@
 uqm_CFILES="probe.c"
+uqm_HFILES="icode.h probe.h resinst.h"
diff -ruNp src.hd/uqm/ships/probe/icode.h src/uqm/ships/probe/icode.h
--- src.hd/uqm/ships/probe/icode.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/probe/icode.h	2017-12-29 00:57:52 -0800
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define URQUAN_DRONE_CODE "ship.drone.code"
diff -ruNp src.hd/uqm/ships/probe/probe.c src/uqm/ships/probe/probe.c
--- src.hd/uqm/ships/probe/probe.c	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/probe/probe.c	2017-12-29 00:57:52 -0800
@@ -38,6 +38,7 @@
 static RACE_DESC probe_desc =
 {
 	{ /* SHIP_INFO */
+		"urquanprobe",
 		0,
 		0, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
diff -ruNp src.hd/uqm/ships/probe/probe.h src/uqm/ships/probe/probe.h
--- src.hd/uqm/ships/probe/probe.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/probe/probe.h	2017-12-29 00:57:52 -0800
@@ -17,7 +17,15 @@
 #ifndef PROBE_H
 #define PROBE_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_probe (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* PROBE_H */
 
diff -ruNp src.hd/uqm/ships/probe/resinst.h src/uqm/ships/probe/resinst.h
--- src.hd/uqm/ships/probe/resinst.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/probe/resinst.h	2017-12-29 00:57:52 -0800
@@ -1,3 +1,5 @@
-#define URQUAN_DRONE_MICON_MASK_PMAP_ANIM "ship.drone.meleeicons"
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
 
-#include "icode.h"
+#define URQUAN_DRONE_MICON_MASK_PMAP_ANIM "ship.drone.meleeicons"
diff -ruNp src.hd/uqm/ships/shofixti/Makeinfo src/uqm/ships/shofixti/Makeinfo
--- src.hd/uqm/ships/shofixti/Makeinfo	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/shofixti/Makeinfo	2017-12-29 00:57:52 -0800
@@ -1 +1,2 @@
 uqm_CFILES="shofixti.c"
+uqm_HFILES="icode.h resinst.h shofixti.h"
diff -ruNp src.hd/uqm/ships/shofixti/icode.h src/uqm/ships/shofixti/icode.h
--- src.hd/uqm/ships/shofixti/icode.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/shofixti/icode.h	2017-12-29 00:57:52 -0800
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SHOFIXTI_CODE "ship.shofixti.code"
diff -ruNp src.hd/uqm/ships/shofixti/resinst.h src/uqm/ships/shofixti/resinst.h
--- src.hd/uqm/ships/shofixti/resinst.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/shofixti/resinst.h	2017-12-29 00:57:52 -0800
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define DART_BIG_MASK_PMAP_ANIM "ship.shofixti.graphics.missile.large"
 #define DART_MED_MASK_PMAP_ANIM "ship.shofixti.graphics.missile.medium"
 #define DART_SML_MASK_PMAP_ANIM "ship.shofixti.graphics.missile.small"
@@ -14,9 +18,7 @@
 #define SHOFIXTI_ICON_MASK_PMAP_ANIM "ship.shofixti.icons"
 #define SHOFIXTI_MED_MASK_PMAP_ANIM "ship.shofixti.graphics.scout.medium"
 #define SHOFIXTI_MICON_MASK_PMAP_ANIM "ship.shofixti.meleeicons"
-#define SHOFIXTI_SML_MASK_PMAP_ANIM "ship.shofixti.graphics.scout.small"
 #define SHOFIXTI_RACE_STRINGS "ship.shofixti.text"
 #define SHOFIXTI_SHIP_SOUNDS "ship.shofixti.sounds"
+#define SHOFIXTI_SML_MASK_PMAP_ANIM "ship.shofixti.graphics.scout.small"
 #define SHOFIXTI_VICTORY_SONG "ship.shofixti.ditty"
-
-#include "icode.h"
diff -ruNp src.hd/uqm/ships/shofixti/shofixti.c src/uqm/ships/shofixti/shofixti.c
--- src.hd/uqm/ships/shofixti/shofixti.c	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/shofixti/shofixti.c	2017-12-29 00:57:52 -0800
@@ -21,14 +21,13 @@
 #include "resinst.h"
 
 #include "uqm/globdata.h"
+#include "uqm/tactrans.h"
 #include "libs/mathlib.h"
 
- 
+// Core characteristics
 #define MAX_CREW 6
 #define MAX_ENERGY 4
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 1
-#define SPECIAL_ENERGY_COST 0
 #define ENERGY_WAIT 9
 #define MAX_THRUST 35
 #define THRUST_INCREMENT 5
@@ -36,14 +35,37 @@
 #define THRUST_WAIT 0
 #define WEAPON_WAIT 3
 #define SPECIAL_WAIT 0
-
 #define SHIP_MASS 1
+
+// Dart Gun
+#define WEAPON_ENERGY_COST 1
+#define SHOFIXTI_OFFSET RES_SCALE(15)
+#define MISSILE_OFFSET RES_SCALE(1)
 #define MISSILE_SPEED DISPLAY_TO_WORLD (24)
 #define MISSILE_LIFE 10
+#define MISSILE_HITS 1
+#define MISSILE_DAMAGE 1
+
+// Glory Device
+#define SPECIAL_ENERGY_COST 0
+#define DESTRUCT_RANGE RES_SCALE(180)
+#define MAX_DESTRUCTION (RES_SCALE(DESTRUCT_RANGE) / 10)
 
-static RACE_DESC shofixti_desc =
+// Full game: Tanaka/Katana's damaged ships
+#define NUM_LIMPETS 3
+
+// HD
+#define MAX_THRUST_2XRES 70
+#define THRUST_INCREMENT_2XRES 10
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (48)
+#define MAX_THRUST_4XRES 140
+#define THRUST_INCREMENT_4XRES 20
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (96)
+
+static RACE_DESC shofixti_desc1x =
 {
 	{ /* SHIP_INFO */
+		"scout",
 		FIRES_FORE,
 		5, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -113,14 +135,10 @@ static RACE_DESC shofixti_desc =
 };
 
 // JMS_GFX
-#define MAX_THRUST_2XRES 70
-#define THRUST_INCREMENT_2XRES 10
-#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (48)
-
-// JMS_GFX
-static RACE_DESC shofixti_desc_2xres =
+static RACE_DESC shofixti_desc2x =
 {
 	{ /* SHIP_INFO */
+		"scout",
 		FIRES_FORE,
 		5, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -190,14 +208,10 @@ static RACE_DESC shofixti_desc_2xres =
 };
 
 // JMS_GFX
-#define MAX_THRUST_4XRES 140
-#define THRUST_INCREMENT_4XRES 20
-#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (96)
-
-// JMS_GFX
-static RACE_DESC shofixti_desc_4xres =
+static RACE_DESC shofixti_desc4x =
 {
 	{ /* SHIP_INFO */
+		"scout",
 		FIRES_FORE,
 		5, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -269,10 +283,7 @@ static RACE_DESC shofixti_desc_4xres =
 static COUNT
 initialize_standard_missile (ELEMENT *ShipPtr, HELEMENT MissileArray[])
 {
-#define SHOFIXTI_OFFSET (15 << RESOLUTION_FACTOR) // JMS_GFX
-#define MISSILE_HITS 1
-#define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET (1 << RESOLUTION_FACTOR) // JMS_GFX
+
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -284,7 +295,7 @@ initialize_standard_missile (ELEMENT *Sh
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = SHOFIXTI_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
+	MissileBlock.speed = RES_SCALE(MISSILE_SPEED);
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -366,10 +377,10 @@ destruct_preprocess (ELEMENT *ElementPtr
 			PutElement (hDestruct);
 			LockElement (hDestruct, &DestructPtr);
 			SetElementStarShip (DestructPtr, StarShipPtr);
-			DestructPtr->hit_points = DestructPtr->mass_points = 0;
+			DestructPtr->hit_points = 0;
+			DestructPtr->mass_points = 0;
 			DestructPtr->playerNr = NEUTRAL_PLAYER_NUM;
 			DestructPtr->state_flags = APPEARING | FINITE_LIFE | NONSOLID;
-			DestructPtr->life_span = (NUM_EXPLOSION_FRAMES - 3) - 1;
 			SetPrimType (&(GLOBAL (DisplayArray))[DestructPtr->PrimIndex],
 					STAMPFILL_PRIM);
 			SetPrimColor (&(GLOBAL (DisplayArray))[DestructPtr->PrimIndex],
@@ -378,6 +389,8 @@ destruct_preprocess (ELEMENT *ElementPtr
 					StarShipPtr->RaceDescPtr->ship_data.special;
 			DestructPtr->current.image.frame =
 					StarShipPtr->RaceDescPtr->ship_data.special[0];
+			DestructPtr->life_span = GetFrameCount (
+					DestructPtr->current.image.frame);
 			DestructPtr->current.location = ElementPtr->current.location;
 			DestructPtr->preprocess_func = destruct_preprocess;
 			DestructPtr->postprocess_func = NULL;
@@ -394,110 +407,145 @@ destruct_preprocess (ELEMENT *ElementPtr
 #define ORZ_MARINE(ptr) (ptr->preprocess_func == intruder_preprocess && \
 		ptr->collision_func == marine_collision)
 
-// XXX: This function should be split into two
 static void
-self_destruct (ELEMENT *ElementPtr)
+self_destruct_kill_objects (ELEMENT *ElementPtr)
 {
-	STARSHIP *StarShipPtr;
+	// This is called during PostProcessQueue(), close to or at the end,
+	// for the temporary destruct element to apply the effects of glory
+	// explosion. The effects are not seen until the next frame.
+	HELEMENT hElement, hNextElement;
 
-	GetElementStarShip (ElementPtr, &StarShipPtr);
-	if (ElementPtr->state_flags & PLAYER_SHIP)
+	for (hElement = GetHeadElement (); hElement != 0; hElement = hNextElement)
 	{
-		HELEMENT hDestruct;
-		
-		// Spawn a temporary element, which dies in this same frame, in order
-		// to defer the effects of the glory explosion.
-		// It will be the last element (or one of the last) for which the
-		// death_func will be called from PostProcessQueue() in this frame.
-		hDestruct = AllocElement ();
-		if (hDestruct)
-		{
-			ELEMENT *DestructPtr;
+		ELEMENT *ObjPtr;
+		SDWORD delta_x, delta_y;
+		DWORD dist;
 
-			LockElement (hDestruct, &DestructPtr);
-			DestructPtr->playerNr = ElementPtr->playerNr;
-			DestructPtr->state_flags = APPEARING | NONSOLID | FINITE_LIFE;
-			DestructPtr->next.location = ElementPtr->next.location;
-			DestructPtr->life_span = 0;
-			DestructPtr->pParent = ElementPtr->pParent;
-			DestructPtr->hTarget = 0;
+		LockElement (hElement, &ObjPtr);
+		hNextElement = GetSuccElement (ObjPtr);
 
-			DestructPtr->death_func = self_destruct;
+		if (!CollidingElement (ObjPtr) && !ORZ_MARINE (ObjPtr))
+		{
+			UnlockElement (hElement);
+			continue;
+		}
 
-			UnlockElement (hDestruct);
+		delta_x = ObjPtr->next.location.x - ElementPtr->next.location.x;
+		if (delta_x < 0)
+			delta_x = -delta_x;
+		delta_y = ObjPtr->next.location.y - ElementPtr->next.location.y;
+		if (delta_y < 0)
+			delta_y = -delta_y;
+		delta_x = WORLD_TO_DISPLAY (delta_x);
+		delta_y = WORLD_TO_DISPLAY (delta_y);
+		dist = delta_x * delta_x + delta_y * delta_y;
+		if (delta_x <= DESTRUCT_RANGE && delta_y <= DESTRUCT_RANGE
+				&& dist <= DESTRUCT_RANGE * DESTRUCT_RANGE)
+		{
+			int destruction = 1 + MAX_DESTRUCTION *
+					(DESTRUCT_RANGE - square_root (dist)) / DESTRUCT_RANGE;
 
-			PutElement (hDestruct);
+			// XXX: Why not simply call do_damage()?
+			if (ObjPtr->state_flags & PLAYER_SHIP)
+			{
+				if (!DeltaCrew (ObjPtr, -destruction))
+					ObjPtr->life_span = 0;
+			}
+			else if (!GRAVITY_MASS (ObjPtr->mass_points))
+			{
+				if (destruction < ObjPtr->hit_points)
+					ObjPtr->hit_points -= destruction;
+				else
+				{
+					ObjPtr->hit_points = 0;
+					ObjPtr->life_span = 0;
+				}
+			}
 		}
 
-		ElementPtr->state_flags |= NONSOLID;
-		// The ship is now dead. It's death_func, i.e. ship_death(), will be
-		// called the next frame.
-		ElementPtr->life_span = 0;
+		UnlockElement (hElement);
+	}
+}
+
+// This function is called when the ship dies via Glory Device.
+// The generic ship_death() function is not called for the ship in this case.
+static void
+shofixti_destruct_death (ELEMENT *ShipPtr)
+{
+	STARSHIP *StarShip;
+	STARSHIP *winner;
 
-		ElementPtr->preprocess_func = destruct_preprocess;
+	GetElementStarShip (ShipPtr, &StarShip);
+
+	StopAllBattleMusic ();
+
+	StartShipExplosion (ShipPtr, false);
+	// We process the explosion ourselves because it is different
+	ShipPtr->preprocess_func = destruct_preprocess;
+	
+	PlaySound (SetAbsSoundIndex (StarShip->RaceDescPtr->ship_data.ship_sounds,
+			1), CalcSoundPosition (ShipPtr), ShipPtr, GAME_SOUND_PRIORITY + 1);
+
+	winner = GetWinnerStarShip ();
+	if (winner == NULL)
+	{	// No winner determined yet
+		winner = FindAliveStarShip (ShipPtr);
+		if (winner == NULL)
+		{	// No ships left alive after the Glory Device thus Shofixti wins
+			winner = StarShip;
+		}
+		SetWinnerStarShip (winner);
 	}
-	else
-	{
-		// This is called during PostProcessQueue(), close to or at the end,
-		// for the temporary destruct element to apply the effects of glory
-		// explosion. The effects are not seen until the next frame.
-		HELEMENT hElement, hNextElement;
+	else if (winner == StarShip)
+	{	// This ship is the winner
+		// It may have self-destructed before the ditty started playing,
+		// and in that case, there should be no ditty
+		StarShip->cur_status_flags &= ~PLAY_VICTORY_DITTY;
+	}
+	RecordShipDeath (ShipPtr);
+}
 
-		for (hElement = GetHeadElement ();
-				hElement != 0; hElement = hNextElement)
-		{
-			ELEMENT *ObjPtr;
+static void
+self_destruct (ELEMENT *ElementPtr)
+{
+	STARSHIP *StarShipPtr;
+	HELEMENT hDestruct;
 
-			LockElement (hElement, &ObjPtr);
-			hNextElement = GetSuccElement (ObjPtr);
+	GetElementStarShip (ElementPtr, &StarShipPtr);
+		
+	// Spawn a temporary element, which dies in this same frame, in order
+	// to defer the effects of the glory explosion.
+	// It will be the last element (or one of the last) for which the
+	// death_func() will be called from PostProcessQueue() in this frame.
+	// XXX: Why at the end? Why not just do it now?
+	hDestruct = AllocElement ();
+	if (hDestruct)
+	{
+		ELEMENT *DestructPtr;
+
+		LockElement (hDestruct, &DestructPtr);
+		DestructPtr->playerNr = ElementPtr->playerNr;
+		DestructPtr->state_flags = APPEARING | NONSOLID | FINITE_LIFE;
+		DestructPtr->next.location = ElementPtr->next.location;
+		DestructPtr->life_span = 0;
+		DestructPtr->pParent = ElementPtr->pParent;
+		DestructPtr->hTarget = 0;
 
-			if (CollidingElement (ObjPtr) || ORZ_MARINE (ObjPtr))
-			{
-#define DESTRUCT_RANGE (180 << RESOLUTION_FACTOR) // JMS_GFX
-				SDWORD delta_x, delta_y;
-				DWORD dist;
-
-				if ((delta_x = ObjPtr->next.location.x
-						- ElementPtr->next.location.x) < 0)
-					delta_x = -delta_x;
-				if ((delta_y = ObjPtr->next.location.y
-						- ElementPtr->next.location.y) < 0)
-					delta_y = -delta_y;
-				delta_x = WORLD_TO_DISPLAY (delta_x);
-				delta_y = WORLD_TO_DISPLAY (delta_y);
-				if (delta_x <= DESTRUCT_RANGE && delta_y <= DESTRUCT_RANGE
-						&& (dist = (DWORD)(delta_x * delta_x)
-						+ (DWORD)(delta_y * delta_y)) <=
-						(DWORD)(DESTRUCT_RANGE * DESTRUCT_RANGE))
-				{
-#define MAX_DESTRUCTION ((DESTRUCT_RANGE >> RESOLUTION_FACTOR) / 10) // JMS_GFX
-					SIZE destruction;
+		DestructPtr->death_func = self_destruct_kill_objects;
 
-					destruction = ((MAX_DESTRUCTION
-							* (DESTRUCT_RANGE - square_root (dist)))
-							/ DESTRUCT_RANGE) + 1;
-
-					if (ObjPtr->state_flags & PLAYER_SHIP)
-					{
-						if (!DeltaCrew (ObjPtr, -destruction))
-							ObjPtr->life_span = 0;
-					}
-					else if (!GRAVITY_MASS (ObjPtr->mass_points))
-					{
-						if ((BYTE)destruction < ObjPtr->hit_points)
-							ObjPtr->hit_points -= (BYTE)destruction;
-						else
-						{
-							ObjPtr->hit_points = 0;
-							ObjPtr->life_span = 0;
-						}
-					}
-				}
-			}
+		UnlockElement (hDestruct);
 
-			UnlockElement (hElement);
-		}
+		PutElement (hDestruct);
 	}
+
+	// Must kill off the remaining crew ourselves
+	DeltaCrew (ElementPtr, -(int)ElementPtr->crew_level);
+
+	ElementPtr->state_flags |= NONSOLID;
+	ElementPtr->life_span = 0;
+	// The ship is now dead. It's death_func, i.e. shofixti_destruct_death(),
+	// will be called the next frame.
+	ElementPtr->death_func = shofixti_destruct_death;
 }
 
 static void
@@ -563,37 +611,22 @@ shofixti_postprocess (ELEMENT *ElementPt
 RACE_DESC*
 init_shofixti (void)
 {
+	static RACE_DESC shofixti_desc;
 	RACE_DESC *RaceDescPtr;
-
+	// The caller of this func will copy the struct
 	static RACE_DESC new_shofixti_desc;
 
-	if (RESOLUTION_FACTOR == 0)
-	{
-		shofixti_desc.postprocess_func = shofixti_postprocess;
-		shofixti_desc.init_weapon_func = initialize_standard_missile;
-		shofixti_desc.cyborg_control.intelligence_func = shofixti_intelligence;
-		new_shofixti_desc = shofixti_desc;
-	}
-	else if (RESOLUTION_FACTOR == 1)
-	{
-		shofixti_desc_2xres.postprocess_func = shofixti_postprocess;
-		shofixti_desc_2xres.init_weapon_func = initialize_standard_missile;
-		shofixti_desc_2xres.cyborg_control.intelligence_func = shofixti_intelligence;
-		new_shofixti_desc = shofixti_desc_2xres;
-	}
-	else
-	{
-		shofixti_desc_4xres.postprocess_func = shofixti_postprocess;
-		shofixti_desc_4xres.init_weapon_func = initialize_standard_missile;
-		shofixti_desc_4xres.cyborg_control.intelligence_func = shofixti_intelligence;
-		new_shofixti_desc = shofixti_desc_4xres;
-	}
+	shofixti_desc = (RESOLUTION_FACTOR == 0 ? shofixti_desc1x : (RESOLUTION_FACTOR == 1 ? shofixti_desc2x : shofixti_desc4x));
+
+	shofixti_desc.postprocess_func = shofixti_postprocess;
+	shofixti_desc.init_weapon_func = initialize_standard_missile;
+	shofixti_desc.cyborg_control.intelligence_func = shofixti_intelligence;
 
+	new_shofixti_desc = shofixti_desc;
 	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_ENCOUNTER
 			&& !GET_GAME_STATE (SHOFIXTI_RECRUITED))
 	{
 		// Tanaka/Katana flies in a damaged ship.
-#define NUM_LIMPETS 3
 		COUNT i;
 
 		new_shofixti_desc.ship_data.ship_rsc[0] = OLDSHOF_BIG_MASK_PMAP_ANIM;
@@ -617,7 +650,10 @@ init_shofixti (void)
 				--new_shofixti_desc.characteristics.turn_wait;
 			if (++new_shofixti_desc.characteristics.thrust_wait == 0)
 				--new_shofixti_desc.characteristics.thrust_wait;
-#define MIN_THRUST_INCREMENT DISPLAY_TO_WORLD (1 << RESOLUTION_FACTOR)
+
+/* This should be the same as MIN_THRUST_INCREMENT in vux.c */
+#define MIN_THRUST_INCREMENT DISPLAY_TO_WORLD RES_SCALE(1)
+
 			if (new_shofixti_desc.characteristics.thrust_increment <=
 					MIN_THRUST_INCREMENT)
 			{
@@ -630,7 +666,7 @@ init_shofixti (void)
 
 				num_thrusts = new_shofixti_desc.characteristics.max_thrust /
 						new_shofixti_desc.characteristics.thrust_increment;
-				new_shofixti_desc.characteristics.thrust_increment -= 1 << RESOLUTION_FACTOR; // JMS_GFX
+				new_shofixti_desc.characteristics.thrust_increment -= RES_SCALE(1); // JMS_GFX
 				new_shofixti_desc.characteristics.max_thrust =
 						new_shofixti_desc.characteristics.thrust_increment *
 						num_thrusts;
diff -ruNp src.hd/uqm/ships/shofixti/shofixti.h src/uqm/ships/shofixti/shofixti.h
--- src.hd/uqm/ships/shofixti/shofixti.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/shofixti/shofixti.h	2017-12-29 00:57:52 -0800
@@ -17,7 +17,15 @@
 #ifndef SHOFIXTI_H
 #define SHOFIXTI_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_shofixti (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* SHOFIXTI_H */
 
diff -ruNp src.hd/uqm/ships/sis_ship/Makeinfo src/uqm/ships/sis_ship/Makeinfo
--- src.hd/uqm/ships/sis_ship/Makeinfo	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/sis_ship/Makeinfo	2017-12-29 00:57:52 -0800
@@ -1 +1,2 @@
 uqm_CFILES="sis_ship.c"
+uqm_HFILES="icode.h resinst.h sis_ship.h"
diff -ruNp src.hd/uqm/ships/sis_ship/icode.h src/uqm/ships/sis_ship/icode.h
--- src.hd/uqm/ships/sis_ship/icode.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/sis_ship/icode.h	2017-12-29 00:57:52 -0800
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SIS_CODE "ship.flagship.code"
diff -ruNp src.hd/uqm/ships/sis_ship/resinst.h src/uqm/ships/sis_ship/resinst.h
--- src.hd/uqm/ships/sis_ship/resinst.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/sis_ship/resinst.h	2017-12-29 00:57:52 -0800
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define BLASTER_BIG_MASK_PMAP_ANIM "ship.flagship.graphics.blaster.large"
 #define BLASTER_MED_MASK_PMAP_ANIM "ship.flagship.graphics.blaster.medium"
 #define BLASTER_SML_MASK_PMAP_ANIM "ship.flagship.graphics.blaster.small"
@@ -7,8 +11,6 @@
 #define SIS_QUASI_MASK_PMAP_ANIM "ship.flagship.graphics.quasispace"
 #define SIS_ICON_MASK_PMAP_ANIM "ship.flagship.icons"
 #define SIS_MED_MASK_PMAP_ANIM "ship.flagship.graphics.flagship.medium"
-#define SIS_SML_MASK_PMAP_ANIM "ship.flagship.graphics.flagship.small"
 #define SIS_SHIP_SOUNDS "ship.flagship.sounds"
+#define SIS_SML_MASK_PMAP_ANIM "ship.flagship.graphics.flagship.small"
 #define SIS_VICTORY_SONG "ship.flagship.ditty"
-
-#include "icode.h"
diff -ruNp src.hd/uqm/ships/sis_ship/sis_ship.c src/uqm/ships/sis_ship/sis_ship.c
--- src.hd/uqm/ships/sis_ship/sis_ship.c	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/sis_ship/sis_ship.c	2017-12-29 00:57:52 -0800
@@ -26,31 +26,85 @@
 #include "uqm/hyper.h"
 #include "libs/mathlib.h"
 
-
-#define MAX_TRACKING 3
-#define MAX_DEFENSE 8
+/* Core characteristics.
+ * All of these are changed at init time by some module, except for
+ * MAX_ENERGY, THRUST_INCREMENT, and SHIP_MASS. */
 
 #define MAX_CREW MAX_CREW_SIZE
+		/* This value gets thrown out - actual max crew is determined by the
+		 * number of crew pods. The minimum value is 1 (just the Captain). */
+
 #define MAX_ENERGY MAX_ENERGY_SIZE
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 1
-#define SPECIAL_ENERGY_COST 0
+		/* Shiva furnaces increase this by 1 each. */
+#define SHIVA_ENERGY_REGEN_INC 1
+
 #define ENERGY_WAIT 10
+		/* Dynamos decrease this by 2 each, to a minimum of 4. */
+#define MIN_ENERGY_WAIT 4
+#define DYNAMO_UNIT_ENERGY_WAIT_DEC 2
+
 #define MAX_THRUST 10
+		/* Thrusters increase this and decrease THRUST_WAIT based on
+		 * THRUST_INCREMENT, see InitDriveSlots near the bottom of this file
+		 * for details. */
 #define THRUST_INCREMENT 4
-#define TURN_WAIT 17
 #define THRUST_WAIT 6
-#define WEAPON_WAIT 6
-#define SPECIAL_WAIT 9
-
+#define TURN_WAIT 17
+		/* Turning jets decrease by 2 each */
 #define SHIP_MASS MAX_SHIP_MASS
 
+
+/* Primary weapon - energy cost and damage change at init time based on
+ * the number and type of weapon modules installed. */
+
+#define BLASTER_DAMAGE 2
+		/* This is the damage value for the basic ion bolt guns. Fusion
+		 * blasters and hellbore cannons end up doing (BLASTER_DAMAGE * 2)
+		 * and (BLASTER_DAMAGE * 3) damage, respectively, but this depends
+		 * on enum values. */
+
+#define BLASTER_HITS 2 /* Hitpoints for ion bolt guns, see BLASTER_DAMAGE */
+
+#define WEAPON_ENERGY_COST 1
+		/* This value gets thrown out and reset in an ugly manner based on
+		 * the enum that is used for module IDs. Bigger gun = higher value.
+		 */
+#define WEAPON_WAIT 6
 #define BLASTER_SPEED DISPLAY_TO_WORLD (24)
 #define BLASTER_LIFE 12
+		/* This value is greatly increased, based in part on the enum used
+		 * for module IDs (bigger gun == longer life). See the first half of
+		 * InitWeaponSlots */
+#define MAX_TRACKING 3
+#define TRACKER_ENERGY_COST 3
+#define BLASTER_OFFSET RES_SCALE(8)
+#define SIS_VERT_OFFSET RES_SCALE(28)
+		/* Used for foward, spread, and rear slots */
+#define SIS_HORZ_OFFSET RES_SCALE(20)
+		/* Used for side slot */
+
+/* Secondary weapon */
+#define SPECIAL_ENERGY_COST 0
+		/* Increased by 1 for each point defense module */
+#define ANTIMISSILE_ENERGY_INC 1
+#define SPECIAL_WAIT 9
+#define LASER_RANGE (UWORD)RES_SCALE(100)
+#define MAX_DEFENSE 8
 
-static RACE_DESC sis_desc =
+// HD
+#define MAX_THRUST_2XRES 20
+#define THRUST_INCREMENT_2XRES 8
+#define BLASTER_SPEED_2XRES DISPLAY_TO_WORLD (48)
+#define MAX_THRUST_4XRES 40
+#define THRUST_INCREMENT_4XRES 16
+#define BLASTER_SPEED_4XRES DISPLAY_TO_WORLD (96)
+
+
+static RACE_DESC sis_desc1x =
 {
 	{ /* SHIP_INFO */
+		"flagship",
 		0,
 		16, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -120,14 +174,10 @@ static RACE_DESC sis_desc =
 };
 
 // JMS_GFX
-#define MAX_THRUST_2XRES 20
-#define THRUST_INCREMENT_2XRES 8
-#define BLASTER_SPEED_2XRES DISPLAY_TO_WORLD (48)
-
-// JMS_GFX
-static RACE_DESC sis_desc_2xres =
+static RACE_DESC sis_desc2x =
 {
 	{ /* SHIP_INFO */
+		"flagship",
 		0,
 		16, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -197,14 +247,10 @@ static RACE_DESC sis_desc_2xres =
 };
 
 // JMS_GFX
-#define MAX_THRUST_4XRES 40
-#define THRUST_INCREMENT_4XRES 16
-#define BLASTER_SPEED_4XRES DISPLAY_TO_WORLD (96)
-
-// JMS_GFX
-static RACE_DESC sis_desc_4xres =
+static RACE_DESC sis_desc4x =
 {
 	{ /* SHIP_INFO */
+		"flagship",
 		0,
 		16, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -290,17 +336,49 @@ static void InitDriveSlots (RACE_DESC *R
 		const BYTE *DriveSlots);
 static void InitJetSlots (RACE_DESC *RaceDescPtr,
 		const BYTE *JetSlots);
-void uninit_sis (RACE_DESC *pRaceDesc);
+static void uninit_sis (RACE_DESC *pRaceDesc);
+
 
+// Local typedef
+typedef SIS_DATA CustomShipData_t;
+
+// Retrieve race-specific ship data from a race desc
+static CustomShipData_t *
+GetCustomShipData (RACE_DESC *pRaceDesc)
+{
+	return pRaceDesc->data;
+}
+
+// Set the race-specific data in a race desc
+// (Re)Allocates its own storage for the data.
+static void
+SetCustomShipData (RACE_DESC *pRaceDesc, const CustomShipData_t *data)
+{
+	if (pRaceDesc->data == data)
+		return;  // no-op
+
+	if (pRaceDesc->data) // Out with the old
+	{
+		HFree (pRaceDesc->data);
+		pRaceDesc->data = NULL;
+	}
+
+	if (data) // In with the new
+	{
+		CustomShipData_t* newData = HMalloc (sizeof (*data));
+		*newData = *data;
+		pRaceDesc->data = newData;
+	}
+}
 
 static void
 sis_hyper_preprocess (ELEMENT *ElementPtr)
 {
 	SIZE dx = 0, dy = 0;
+	SDWORD udx = 0, udy = 0, dtempx, dtempy;
 	SIZE AccelerateDirection;
 	STARSHIP *StarShipPtr;
-	SDWORD udx = 0, udy = 0, dtempx, dtempy;	// JMS_GFX: These babies help to make the hyperspace speed calculations not overflow in hires.
-	
+
 	if (ElementPtr->state_flags & APPEARING)
 		ElementPtr->velocity = GLOBAL (velocity);
 	
@@ -345,7 +423,7 @@ sis_hyper_preprocess (ELEMENT *ElementPt
 	{
 		SIZE facing;
 		POINT universe;
-		
+
 		universe.x = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x));
 		universe.y = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
 		udx = (GLOBAL (autopilot)).x - universe.x;
@@ -354,26 +432,29 @@ sis_hyper_preprocess (ELEMENT *ElementPt
 			dx = -dx;
 		if ((dy = (SIZE)udy) < 0)
 			dy = -dy;
-        
 		if (dx <= (1 << RESOLUTION_FACTOR) && dy <= (1 << RESOLUTION_FACTOR))
 			goto LeaveAutoPilot;
-		
+
 		facing = NORMALIZE_FACING (ANGLE_TO_FACING (ARCTAN (udx, udy)));
-		
+
 		/* This prevents ship from flying backwards on auto-pilot.
 		 * It could also theoretically abort autopilot in a bad savegame */
 		if ((StarShipPtr->cur_status_flags & SHIP_AT_MAX_SPEED)
-			/*|| (ElementPtr->state_flags & APPEARING)*/ )
+				/*|| (ElementPtr->state_flags & APPEARING)*/ )
 		{
-			if (NORMALIZE_FACING (StarShipPtr->ShipFacing + ANGLE_TO_FACING (QUADRANT) - facing) > ANGLE_TO_FACING (HALF_CIRCLE))
+			if (NORMALIZE_FACING (StarShipPtr->ShipFacing
+					+ ANGLE_TO_FACING (QUADRANT)
+					- facing) > ANGLE_TO_FACING (HALF_CIRCLE))
 				goto LeaveAutoPilot;
-			
+
 			facing = StarShipPtr->ShipFacing;
 		}
 		else if ((int)facing != (int)StarShipPtr->ShipFacing
-				 && ElementPtr->turn_wait == 0)
+				&& ElementPtr->turn_wait == 0)
 		{
-			if (NORMALIZE_FACING (StarShipPtr->ShipFacing - facing) >= ANGLE_TO_FACING (HALF_CIRCLE))
+			if (NORMALIZE_FACING (
+					StarShipPtr->ShipFacing - facing
+					) >= ANGLE_TO_FACING (HALF_CIRCLE))
 			{
 				facing = NORMALIZE_FACING (facing - 1);
 				StarShipPtr->cur_status_flags |= RIGHT;
@@ -383,16 +464,17 @@ sis_hyper_preprocess (ELEMENT *ElementPt
 				facing = NORMALIZE_FACING (facing + 1);
 				StarShipPtr->cur_status_flags |= LEFT;
 			}
-			
+
 			if ((int)facing == (int)StarShipPtr->ShipFacing)
+			{
 				ZeroVelocityComponents (&ElementPtr->velocity);
+			}
 		}
-		
+
 		GetCurrentVelocityComponents (&ElementPtr->velocity, &dx, &dy);
-		
 		if ((GLOBAL_SIS (FuelOnBoard)
-			 || GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1) // JMS: Orz space check.
-			&& (int)facing == (int)StarShipPtr->ShipFacing)
+				|| GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1)
+				&& (int)facing == (int)StarShipPtr->ShipFacing)
 		{
 			StarShipPtr->cur_status_flags |= SHIP_AT_MAX_SPEED;
 			AccelerateDirection = 1;
@@ -404,48 +486,47 @@ sis_hyper_preprocess (ELEMENT *ElementPt
 			udy = dy;// << 4;
 		}
 	}
-	
+
 	if (ElementPtr->thrust_wait == 0 && AccelerateDirection)
 	{
 		COUNT dist;
 		SIZE speed, velocity_increment;
-		
-		velocity_increment = WORLD_TO_VELOCITY (StarShipPtr->RaceDescPtr->characteristics.thrust_increment);
-		
+
+		velocity_increment = WORLD_TO_VELOCITY (
+				StarShipPtr->RaceDescPtr->characteristics.thrust_increment);
+
 		if ((dist = square_root ((long)udx * udx + (long)udy * udy)) == 0)
 			dist = 1; /* prevent divide by zero */
-		
+
 		speed = square_root ((long)dx * dx + (long)dy * dy);
-		
 		if (AccelerateDirection < 0)
 		{
 			dy = (speed / velocity_increment - 1) * velocity_increment;
-			
 			if (dy < speed - velocity_increment)
 				dy = speed - velocity_increment;
 			if ((speed = dy) < 0)
 				speed = 0;
-			
+
 			StarShipPtr->cur_status_flags &= ~SHIP_AT_MAX_SPEED;
 		}
 		else
 		{
 			SIZE max_velocity;
-			
+
 			AccelerateDirection = 0;
+
 			max_velocity = WORLD_TO_VELOCITY (StarShipPtr->RaceDescPtr->characteristics.max_thrust);
 			dy = (speed / velocity_increment + 1) * velocity_increment;
-			
+
 			if (dy < speed + velocity_increment)
 				dy = speed + velocity_increment;
-			
 			if ((speed = dy) > max_velocity)
 			{
 				speed = max_velocity;
 				StarShipPtr->cur_status_flags |= SHIP_AT_MAX_SPEED;
 			}
 		}
-		
+
 		dtempx = (SDWORD)((long)udx * speed / (long)dist);
 		dtempy = (SDWORD)((long)udy * speed / (long)dist);
 		
@@ -533,7 +614,6 @@ spawn_point_defense (ELEMENT *ElementPtr
 			if (ObjectPtr != ShipPtr && CollidingElement (ObjectPtr) &&
 					!OBJECT_CLOAKED (ObjectPtr))
 			{
-#define LASER_RANGE (UWORD)(100 << RESOLUTION_FACTOR) // JMS_GFX
 				SDWORD delta_x, delta_y;
 
 				delta_x = ObjectPtr->next.location.x -
@@ -636,8 +716,6 @@ sis_battle_postprocess (ELEMENT *Element
 	}
 }
 
-#define BLASTER_DAMAGE 2
-
 static void
 blaster_collision (ELEMENT *ElementPtr0, POINT *pPt0,
 		ELEMENT *ElementPtr1, POINT *pPt1)
@@ -708,7 +786,7 @@ blaster_preprocess (ELEMENT *ElementPtr)
 		facing = NORMALIZE_FACING (ANGLE_TO_FACING (
 				GetVelocityTravelAngle (&ElementPtr->velocity)));
 		if (TrackShip (ElementPtr, &facing) > 0)
-			SetVelocityVector (&ElementPtr->velocity, BLASTER_SPEED << RESOLUTION_FACTOR, facing); // JMS_GFX
+			SetVelocityVector (&ElementPtr->velocity, RES_SCALE(BLASTER_SPEED), facing);
 
 		ElementPtr->turn_wait = MAKE_BYTE (wait, wait);
 	}
@@ -717,17 +795,13 @@ blaster_preprocess (ELEMENT *ElementPtr)
 static COUNT
 initialize_blasters (ELEMENT *ShipPtr, HELEMENT BlasterArray[])
 {
-#define SIS_VERT_OFFSET (28 << RESOLUTION_FACTOR) // JMS_GFX
-#define SIS_HORZ_OFFSET (20 << RESOLUTION_FACTOR) // JMS_GFX
-#define BLASTER_HITS 2
-#define BLASTER_OFFSET (8 << RESOLUTION_FACTOR) // JMS_GFX
 	BYTE nt;
 	COUNT i;
 	STARSHIP *StarShipPtr;
 	SIS_DATA *SisData;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
-	SisData = (SIS_DATA *) StarShipPtr->RaceDescPtr->data;
+	SisData = GetCustomShipData (StarShipPtr->RaceDescPtr);
 
 	nt = (BYTE)((4 - SisData->num_trackers) & 3);
 
@@ -767,7 +841,7 @@ sis_intelligence (ELEMENT *ShipPtr, EVAL
 	SIS_DATA *SisData;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
-	SisData = (SIS_DATA *) StarShipPtr->RaceDescPtr->data;
+	SisData = GetCustomShipData (StarShipPtr->RaceDescPtr);
 
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_WEAPON_INDEX];
 	if (lpEvalDesc->ObjectPtr)
@@ -837,7 +911,7 @@ static void
 InitWeaponSlots (RACE_DESC *RaceDescPtr, const BYTE *ModuleSlots)
 {
 	COUNT i;
-	SIS_DATA *SisData = (SIS_DATA *) RaceDescPtr->data;
+	SIS_DATA *SisData = GetCustomShipData (RaceDescPtr);
 	MISSILE_BLOCK *lpMB = SisData->MissileBlock;
 
 	SisData->num_blasters = 0;
@@ -859,7 +933,7 @@ InitWeaponSlots (RACE_DESC *RaceDescPtr,
 		
 		lpMB->flags = IGNORE_SIMILAR;
 		lpMB->blast_offs = BLASTER_OFFSET;
-		lpMB->speed = BLASTER_SPEED << RESOLUTION_FACTOR; // JMS_GFX
+		lpMB->speed = RES_SCALE(BLASTER_SPEED);
 		lpMB->preprocess_func = blaster_preprocess;
 		lpMB->hit_points = BLASTER_HITS * which_gun;
 		lpMB->damage = BLASTER_DAMAGE * which_gun;
@@ -917,7 +991,7 @@ InitModuleSlots (RACE_DESC *RaceDescPtr,
 {
 	COUNT i;
 	COUNT num_trackers;
-	SIS_DATA *SisData = (SIS_DATA *) RaceDescPtr->data;
+	SIS_DATA *SisData = GetCustomShipData (RaceDescPtr);
 
 	RaceDescPtr->ship_info.max_crew = 0;
 	num_trackers = 0;
@@ -935,22 +1009,26 @@ InitModuleSlots (RACE_DESC *RaceDescPtr,
 				++num_trackers;
 				break;
 			case ANTIMISSILE_DEFENSE:
-				++RaceDescPtr->characteristics.special_energy_cost;
+				RaceDescPtr->characteristics.special_energy_cost +=
+						ANTIMISSILE_ENERGY_INC;
 				break;
 			case SHIVA_FURNACE:
-				++RaceDescPtr->characteristics.energy_regeneration;
+				RaceDescPtr->characteristics.energy_regeneration +=
+						SHIVA_ENERGY_REGEN_INC;
 				break;
 			case DYNAMO_UNIT:
-				RaceDescPtr->characteristics.energy_wait -= 2;
-				if (RaceDescPtr->characteristics.energy_wait < 4)
-					RaceDescPtr->characteristics.energy_wait = 4;
+				RaceDescPtr->characteristics.energy_wait -=
+						DYNAMO_UNIT_ENERGY_WAIT_DEC;
+				if (RaceDescPtr->characteristics.energy_wait < MIN_ENERGY_WAIT)
+					RaceDescPtr->characteristics.energy_wait = MIN_ENERGY_WAIT;
 				break;
 		}
 	}
 
 	if (num_trackers > MAX_TRACKING)
 		num_trackers = MAX_TRACKING;
-	RaceDescPtr->characteristics.weapon_energy_cost += num_trackers * 3;
+	RaceDescPtr->characteristics.weapon_energy_cost +=
+			num_trackers * TRACKER_ENERGY_COST;
 	SisData->num_trackers = num_trackers;
 	if (RaceDescPtr->characteristics.special_energy_cost)
 	{
@@ -972,7 +1050,7 @@ InitDriveSlots (RACE_DESC *RaceDescPtr,
 		switch (DriveSlots[i])
 		{
 			case FUSION_THRUSTER:
-				RaceDescPtr->characteristics.max_thrust += (2 << RESOLUTION_FACTOR); // JMS_GFX
+				RaceDescPtr->characteristics.max_thrust += RES_SCALE(2);
 				++RaceDescPtr->characteristics.thrust_wait;
 				break;
 		}
@@ -1005,21 +1083,18 @@ RACE_DESC*
 init_sis (void)
 {
 	RACE_DESC *RaceDescPtr;
-
 	COUNT i;
+	// The caller of this func will copy the struct
 	static RACE_DESC new_sis_desc;
+	SIS_DATA empty_data;
+	memset (&empty_data, 0, sizeof (empty_data));
 
 	/* copy initial ship settings to new_sis_desc */
-	if (RESOLUTION_FACTOR == 0)
-		new_sis_desc = sis_desc;
-	else if (RESOLUTION_FACTOR == 1)
-		new_sis_desc = sis_desc_2xres;
-	else
-		new_sis_desc = sis_desc_4xres;
+	new_sis_desc = (RESOLUTION_FACTOR == 0 ? sis_desc1x : (RESOLUTION_FACTOR == 1 ? sis_desc2x : sis_desc4x));
 	
 	new_sis_desc.uninit_func = uninit_sis;
 
-	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+	if (inHQSpace ())
 	{
 		for (i = 0; i < NUM_VIEWS; ++i)
 		{
@@ -1040,7 +1115,7 @@ init_sis (void)
 		new_sis_desc.preprocess_func = sis_hyper_preprocess;
 		new_sis_desc.postprocess_func = sis_hyper_postprocess;
 
-		new_sis_desc.characteristics.max_thrust -= 4 << RESOLUTION_FACTOR; // JMS_GFX
+		new_sis_desc.characteristics.max_thrust -= RES_SCALE(4);
 	}
 	else
 	{
@@ -1053,7 +1128,7 @@ init_sis (void)
 			SET_GAME_STATE (BOMB_CARRIER, 1);
 	}
 
-	new_sis_desc.data = (intptr_t) HCalloc (sizeof (SIS_DATA));
+	SetCustomShipData (&new_sis_desc, &empty_data);
 	InitModuleSlots (&new_sis_desc, GLOBAL_SIS (ModuleSlots));
 	InitWeaponSlots (&new_sis_desc, GLOBAL_SIS (ModuleSlots));
 	InitDriveSlots (&new_sis_desc, GLOBAL_SIS (DriveSlots));
@@ -1078,18 +1153,17 @@ init_sis (void)
 	return (RaceDescPtr);
 }
 
-void
+static void
 uninit_sis (RACE_DESC *pRaceDesc)
 {
-	if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
+	if (!inHQSpace ())
 	{
 		GLOBAL_SIS (CrewEnlisted) = pRaceDesc->ship_info.crew_level;
 		if (pRaceDesc->ship_info.ship_flags & PLAYER_CAPTAIN)
 			GLOBAL_SIS (CrewEnlisted)--;
 	}
 
-	HFree ((void *)pRaceDesc->data);
-	pRaceDesc->data = 0;
+	SetCustomShipData (pRaceDesc, NULL);
 }
 
 
diff -ruNp src.hd/uqm/ships/sis_ship/sis_ship.h src/uqm/ships/sis_ship/sis_ship.h
--- src.hd/uqm/ships/sis_ship/sis_ship.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/sis_ship/sis_ship.h	2017-12-29 00:57:52 -0800
@@ -17,7 +17,15 @@
 #ifndef SIS_SHIP_H
 #define SIS_SHIP_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_sis (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* SIS_SHIP_H */
 
diff -ruNp src.hd/uqm/ships/slylandr/Makeinfo src/uqm/ships/slylandr/Makeinfo
--- src.hd/uqm/ships/slylandr/Makeinfo	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/slylandr/Makeinfo	2017-12-29 00:57:52 -0800
@@ -1 +1,2 @@
 uqm_CFILES="slylandr.c"
+uqm_HFILES="icode.h resinst.h slylandr.h"
diff -ruNp src.hd/uqm/ships/slylandr/icode.h src/uqm/ships/slylandr/icode.h
--- src.hd/uqm/ships/slylandr/icode.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/slylandr/icode.h	2017-12-29 00:57:52 -0800
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SLYLANDRO_CODE "ship.slylandro.code"
diff -ruNp src.hd/uqm/ships/slylandr/resinst.h src/uqm/ships/slylandr/resinst.h
--- src.hd/uqm/ships/slylandr/resinst.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/slylandr/resinst.h	2017-12-29 00:57:52 -0800
@@ -1,11 +1,13 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SLYLANDRO_BIG_MASK_PMAP_ANIM "ship.slylandro.graphics.probe.large"
 #define SLYLANDRO_CAPTAIN_MASK_PMAP_ANIM "ship.slylandro.graphics.captain"
 #define SLYLANDRO_ICON_MASK_PMAP_ANIM "ship.slylandro.icons"
 #define SLYLANDRO_MED_MASK_PMAP_ANIM "ship.slylandro.graphics.probe.medium"
 #define SLYLANDRO_MICON_MASK_PMAP_ANIM "ship.slylandro.meleeicons"
-#define SLYLANDRO_SML_MASK_PMAP_ANIM "ship.slylandro.graphics.probe.small"
 #define SLYLANDRO_RACE_STRINGS "ship.slylandro.text"
 #define SLYLANDRO_SHIP_SOUNDS "ship.slylandro.sounds"
+#define SLYLANDRO_SML_MASK_PMAP_ANIM "ship.slylandro.graphics.probe.small"
 #define SLYLANDRO_VICTORY_SONG "ship.slylandro.ditty"
-
-#include "icode.h"
diff -ruNp src.hd/uqm/ships/slylandr/slylandr.c src/uqm/ships/slylandr/slylandr.c
--- src.hd/uqm/ships/slylandr/slylandr.c	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/slylandr/slylandr.c	2017-12-29 00:57:52 -0800
@@ -23,26 +23,41 @@
 #include "uqm/globdata.h"
 #include "libs/mathlib.h"
 
-
+// Core characteristics
 #define MAX_CREW 12
 #define MAX_ENERGY 20
 #define ENERGY_REGENERATION 0
-#define WEAPON_ENERGY_COST 2
-#define SPECIAL_ENERGY_COST 0
 #define ENERGY_WAIT 10
 #define MAX_THRUST 60
 #define THRUST_INCREMENT MAX_THRUST
-#define TURN_WAIT 0
 #define THRUST_WAIT 0
+#define TURN_WAIT 0
+#define SHIP_MASS 1
+
+// Lightning weapon
+#define WEAPON_ENERGY_COST 2
 #define WEAPON_WAIT 17
+#define SLYLANDRO_OFFSET 9
+#define LASER_LENGTH RES_SCALE(32)
+		/* Total length of lighting bolts. Actual range is usually less than
+		 * this, since the lightning rarely is straight. */
+
+// Harvester
+#define SPECIAL_ENERGY_COST 0
 #define SPECIAL_WAIT 20
+#define HARVEST_RANGE ((208 * 3 / 8) << RESOLUTION_FACTOR)
+		/* Was originally (SPACE_HEIGHT * 3 / 8) */
 
-#define SHIP_MASS 1
-#define SLYLANDRO_OFFSET 9
+// HD
+#define MAX_THRUST_2XRES 120
+#define THRUST_INCREMENT_2XRES MAX_THRUST_2XRES
+#define MAX_THRUST_4XRES 240
+#define THRUST_INCREMENT_4XRES MAX_THRUST_4XRES
 
-static RACE_DESC slylandro_desc =
+static RACE_DESC slylandro_desc1x =
 {
 	{ /* SHIP_INFO */
+		"probe",
 		SEEKING_WEAPON | CREW_IMMUNE,
 		17, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -112,13 +127,10 @@ static RACE_DESC slylandro_desc =
 };
 
 // JMS_GFX
-#define MAX_THRUST_2XRES 120
-#define THRUST_INCREMENT_2XRES MAX_THRUST_2XRES
-
-// JMS_GFX
-static RACE_DESC slylandro_desc_2xres =
+static RACE_DESC slylandro_desc2x =
 {
 	{ /* SHIP_INFO */
+		"probe",
 		SEEKING_WEAPON | CREW_IMMUNE,
 		17, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -188,13 +200,10 @@ static RACE_DESC slylandro_desc_2xres =
 };
 
 // JMS_GFX
-#define MAX_THRUST_4XRES 240
-#define THRUST_INCREMENT_4XRES MAX_THRUST_4XRES
-
-// JMS_GFX
-static RACE_DESC slylandro_desc_4xres =
+static RACE_DESC slylandro_desc4x =
 {
 	{ /* SHIP_INFO */
+		"probe",
 		SEEKING_WEAPON | CREW_IMMUNE,
 		17, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -263,7 +272,8 @@ static RACE_DESC slylandro_desc_4xres =
 	0, /* CodeRef */
 };
 
-static COUNT initialize_lightning (ELEMENT *ElementPtr, HELEMENT LaserArray[]);
+static COUNT initialize_lightning (ELEMENT *ElementPtr,
+		HELEMENT LaserArray[]);
 
 static void
 lightning_postprocess (ELEMENT *ElementPtr)
@@ -389,8 +399,9 @@ initialize_lightning (ELEMENT *ElementPt
 			angle += LOWORD (rand_val) & (QUADRANT - 1);
 		else
 			angle -= LOWORD (rand_val) & (QUADRANT - 1);
-#define LASER_RANGE (32 << RESOLUTION_FACTOR) // JMS_GFX
-		delta = WORLD_TO_VELOCITY (DISPLAY_TO_WORLD ((HIWORD (rand_val) & (LASER_RANGE - 1)) + 4));
+		delta = WORLD_TO_VELOCITY (
+				DISPLAY_TO_WORLD ((HIWORD (rand_val) & (LASER_LENGTH - 1)) + 4)
+				);
 		SetVelocityComponents (&LaserPtr->velocity,
 				COSINE (angle, delta), SINE (angle, delta));
 
@@ -408,8 +419,11 @@ slylandro_intelligence (ELEMENT *ShipPtr
 	EVALUATE_DESC *lpEvalDesc;
 	STARSHIP *StarShipPtr;
 
-	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_ENCOUNTER)
-			/* no dodging in role playing game */
+	// no dodging in role playing game, unless you haven't
+	// visited the starbase yet
+	if ((LOBYTE (GLOBAL (CurrentActivity)) == IN_ENCOUNTER) &&
+			GET_GAME_STATE (STARBASE_AVAILABLE))
+
 		ObjectsOfConcern[ENEMY_WEAPON_INDEX].ObjectPtr = 0;
 
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
@@ -462,8 +476,6 @@ harvest_space_junk (ELEMENT *ElementPtr)
 				&& !GRAVITY_MASS (ObjPtr->mass_points)
 				&& CollisionPossible (ObjPtr, ElementPtr))
 		{
-//HARVEST_RANGE was originally (SPACE_HEIGHT * 3 / 8)
-#define HARVEST_RANGE ((208 * 3 / 8) << RESOLUTION_FACTOR) // JMS_GFX
 			SDWORD dx, dy;
 
 			if ((dx = ObjPtr->next.location.x
@@ -569,32 +581,17 @@ slylandro_preprocess (ELEMENT *ElementPt
 RACE_DESC*
 init_slylandro (void)
 {
+	static RACE_DESC slylandro_desc;
 	RACE_DESC *RaceDescPtr;
 
-	if (RESOLUTION_FACTOR == 0)
-	{
-		slylandro_desc.preprocess_func = slylandro_preprocess;
-		slylandro_desc.postprocess_func = slylandro_postprocess;
-		slylandro_desc.init_weapon_func = initialize_lightning;
-		slylandro_desc.cyborg_control.intelligence_func = slylandro_intelligence;
-		RaceDescPtr = &slylandro_desc;
-	}
-	else if (RESOLUTION_FACTOR == 1)
-	{
-		slylandro_desc_2xres.preprocess_func = slylandro_preprocess;
-		slylandro_desc_2xres.postprocess_func = slylandro_postprocess;
-		slylandro_desc_2xres.init_weapon_func = initialize_lightning;
-		slylandro_desc_2xres.cyborg_control.intelligence_func = slylandro_intelligence;
-		RaceDescPtr = &slylandro_desc_2xres;
-	}
-	else
-	{
-		slylandro_desc_4xres.preprocess_func = slylandro_preprocess;
-		slylandro_desc_4xres.postprocess_func = slylandro_postprocess;
-		slylandro_desc_4xres.init_weapon_func = initialize_lightning;
-		slylandro_desc_4xres.cyborg_control.intelligence_func = slylandro_intelligence;
-		RaceDescPtr = &slylandro_desc_4xres;
-	}
+	slylandro_desc = (RESOLUTION_FACTOR == 0 ? slylandro_desc1x : (RESOLUTION_FACTOR == 1 ? slylandro_desc2x : slylandro_desc4x));
+
+	slylandro_desc.preprocess_func = slylandro_preprocess;
+	slylandro_desc.postprocess_func = slylandro_postprocess;
+	slylandro_desc.init_weapon_func = initialize_lightning;
+	slylandro_desc.cyborg_control.intelligence_func = slylandro_intelligence;
+
+	RaceDescPtr = &slylandro_desc;
 
 	return (RaceDescPtr);
 }
diff -ruNp src.hd/uqm/ships/slylandr/slylandr.h src/uqm/ships/slylandr/slylandr.h
--- src.hd/uqm/ships/slylandr/slylandr.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/slylandr/slylandr.h	2017-12-29 00:57:52 -0800
@@ -17,7 +17,15 @@
 #ifndef SLYLANDR_H
 #define SLYLANDR_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_slylandro (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* SLYLANDR_H */
 
diff -ruNp src.hd/uqm/ships/spathi/Makeinfo src/uqm/ships/spathi/Makeinfo
--- src.hd/uqm/ships/spathi/Makeinfo	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/spathi/Makeinfo	2017-12-29 00:57:52 -0800
@@ -1 +1,2 @@
 uqm_CFILES="spathi.c"
+uqm_HFILES="icode.h resinst.h spathi.h"
diff -ruNp src.hd/uqm/ships/spathi/icode.h src/uqm/ships/spathi/icode.h
--- src.hd/uqm/ships/spathi/icode.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/spathi/icode.h	2017-12-29 00:57:52 -0800
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SPATHI_CODE "ship.spathi.code"
diff -ruNp src.hd/uqm/ships/spathi/resinst.h src/uqm/ships/spathi/resinst.h
--- src.hd/uqm/ships/spathi/resinst.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/spathi/resinst.h	2017-12-29 00:57:52 -0800
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define DISCRIM_BIG_MASK_PMAP_ANIM "ship.spathi.graphics.butt.large"
 #define DISCRIM_MED_MASK_PMAP_ANIM "ship.spathi.graphics.butt.medium"
 #define DISCRIM_SML_MASK_PMAP_ANIM "ship.spathi.graphics.butt.small"
@@ -9,9 +13,7 @@
 #define SPATHI_ICON_MASK_PMAP_ANIM "ship.spathi.icons"
 #define SPATHI_MED_MASK_PMAP_ANIM "ship.spathi.graphics.eluder.medium"
 #define SPATHI_MICON_MASK_PMAP_ANIM "ship.spathi.meleeicons"
-#define SPATHI_SML_MASK_PMAP_ANIM "ship.spathi.graphics.eluder.small"
 #define SPATHI_RACE_STRINGS "ship.spathi.text"
 #define SPATHI_SHIP_SOUNDS "ship.spathi.sounds"
+#define SPATHI_SML_MASK_PMAP_ANIM "ship.spathi.graphics.eluder.small"
 #define SPATHI_VICTORY_SONG "ship.spathi.ditty"
-
-#include "icode.h"
diff -ruNp src.hd/uqm/ships/spathi/spathi.c src/uqm/ships/spathi/spathi.c
--- src.hd/uqm/ships/spathi/spathi.c	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/spathi/spathi.c	2017-12-29 00:57:53 -0800
@@ -20,27 +20,54 @@
 #include "spathi.h"
 #include "resinst.h"
 
+// Core characteristics
 #define MAX_CREW 30
 #define MAX_ENERGY 10
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 2
-#define SPECIAL_ENERGY_COST 3
 #define ENERGY_WAIT 10
 #define MAX_THRUST 48
 #define THRUST_INCREMENT 12
-#define TURN_WAIT 1
 #define THRUST_WAIT 1
-#define WEAPON_WAIT 0
-#define SPECIAL_WAIT 7
-
+#define TURN_WAIT 1
 #define SHIP_MASS 5
+
+// Forward gun
+#define WEAPON_ENERGY_COST 2
+#define WEAPON_WAIT 0
+#define SPATHI_FORWARD_OFFSET RES_SCALE(16)
 #define MISSILE_SPEED DISPLAY_TO_WORLD (30)
 #define MISSILE_LIFE 10
+#define MISSILE_HITS 1
+#define MISSILE_DAMAGE 1
+#define MISSILE_OFFSET RES_SCALE(1)
 #define MISSILE_RANGE (MISSILE_SPEED * MISSILE_LIFE)
+		/* This is for the cyborg only. */
+
+// B.U.T.T.
+#define SPECIAL_ENERGY_COST 3
+#define SPECIAL_WAIT 7
+#define SPATHI_REAR_OFFSET RES_SCALE(20)
+#define DISCRIMINATOR_SPEED DISPLAY_TO_WORLD RES_SCALE(8)
+#define DISCRIMINATOR_LIFE 30
+#define DISCRIMINATOR_HITS 1
+#define DISCRIMINATOR_DAMAGE 2
+#define DISCRIMINATOR_OFFSET RES_SCALE(4)
+#define TRACK_WAIT 1
+
+// HD
+#define MAX_THRUST_2XRES 96
+#define THRUST_INCREMENT_2XRES 24
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
+#define MISSILE_RANGE_2XRES (MISSILE_SPEED_2XRES * MISSILE_LIFE)
+#define MAX_THRUST_4XRES 192
+#define THRUST_INCREMENT_4XRES 48
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
+#define MISSILE_RANGE_4XRES (MISSILE_SPEED_2XRES * MISSILE_LIFE)
 
-static RACE_DESC spathi_desc =
+static RACE_DESC spathi_desc1x =
 {
 	{ /* SHIP_INFO */
+		"eluder",
 		FIRES_FORE | FIRES_AFT | SEEKING_SPECIAL | DONT_CHASE,
 		18, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -110,15 +137,10 @@ static RACE_DESC spathi_desc =
 };
 
 // JMS_GFX
-#define MAX_THRUST_2XRES 96
-#define THRUST_INCREMENT_2XRES 24
-#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
-#define MISSILE_RANGE_2XRES (MISSILE_SPEED_2XRES * MISSILE_LIFE)
-
-// JMS_GFX
-static RACE_DESC spathi_desc_2xres =
+static RACE_DESC spathi_desc2x =
 {
 	{ /* SHIP_INFO */
+		"eluder",
 		FIRES_FORE | FIRES_AFT | SEEKING_SPECIAL | DONT_CHASE,
 		18, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -188,15 +210,10 @@ static RACE_DESC spathi_desc_2xres =
 };
 
 // JMS_GFX
-#define MAX_THRUST_4XRES 192
-#define THRUST_INCREMENT_4XRES 48
-#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
-#define MISSILE_RANGE_4XRES (MISSILE_SPEED_2XRES * MISSILE_LIFE)
-
-// JMS_GFX
-static RACE_DESC spathi_desc_4xres =
+static RACE_DESC spathi_desc4x =
 {
 	{ /* SHIP_INFO */
+		"eluder",
 		FIRES_FORE | FIRES_AFT | SEEKING_SPECIAL | DONT_CHASE,
 		18, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -265,9 +282,6 @@ static RACE_DESC spathi_desc_4xres =
 	0, /* CodeRef */
 };
 
-#define DISCRIMINATOR_SPEED DISPLAY_TO_WORLD (8 << RESOLUTION_FACTOR) // JMS_GFX
-#define TRACK_WAIT 1
-
 static void
 butt_missile_preprocess (ELEMENT *ElementPtr)
 {
@@ -296,11 +310,6 @@ butt_missile_preprocess (ELEMENT *Elemen
 static void
 spawn_butt_missile (ELEMENT *ShipPtr)
 {
-#define SPATHI_REAR_OFFSET (20 << RESOLUTION_FACTOR) // JMS_GFX
-#define DISCRIMINATOR_LIFE 30
-#define DISCRIMINATOR_HITS 1
-#define DISCRIMINATOR_DAMAGE 2
-#define DISCRIMINATOR_OFFSET (4 << RESOLUTION_FACTOR) // JMS_GFX
 	HELEMENT ButtMissile;
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK ButtMissileBlock;
@@ -395,10 +404,6 @@ spathi_intelligence (ELEMENT *ShipPtr, E
 static COUNT
 initialize_standard_missile (ELEMENT *ShipPtr, HELEMENT MissileArray[])
 {
-#define SPATHI_FORWARD_OFFSET (16 << RESOLUTION_FACTOR) // JMS_GFX
-#define MISSILE_HITS 1
-#define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET (1 << RESOLUTION_FACTOR) // JMS_GFX
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -410,7 +415,7 @@ initialize_standard_missile (ELEMENT *Sh
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = SPATHI_FORWARD_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
+	MissileBlock.speed = RES_SCALE(MISSILE_SPEED);
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -441,29 +446,16 @@ spathi_postprocess (ELEMENT *ElementPtr)
 RACE_DESC*
 init_spathi (void)
 {
+	static RACE_DESC spathi_desc;
 	RACE_DESC *RaceDescPtr;
 
-	if (RESOLUTION_FACTOR == 0)
-	{
-		spathi_desc.postprocess_func = spathi_postprocess;
-		spathi_desc.init_weapon_func = initialize_standard_missile;
-		spathi_desc.cyborg_control.intelligence_func = spathi_intelligence;
-		RaceDescPtr = &spathi_desc;
-	}
-	else if (RESOLUTION_FACTOR == 1)
-	{
-		spathi_desc_2xres.postprocess_func = spathi_postprocess;
-		spathi_desc_2xres.init_weapon_func = initialize_standard_missile;
-		spathi_desc_2xres.cyborg_control.intelligence_func = spathi_intelligence;
-		RaceDescPtr = &spathi_desc_2xres;
-	}
-	else
-	{
-		spathi_desc_4xres.postprocess_func = spathi_postprocess;
-		spathi_desc_4xres.init_weapon_func = initialize_standard_missile;
-		spathi_desc_4xres.cyborg_control.intelligence_func = spathi_intelligence;
-		RaceDescPtr = &spathi_desc_4xres;
-	}
+	spathi_desc = (RESOLUTION_FACTOR == 0 ? spathi_desc1x : (RESOLUTION_FACTOR == 1 ? spathi_desc2x : spathi_desc4x));
+
+	spathi_desc.postprocess_func = spathi_postprocess;
+	spathi_desc.init_weapon_func = initialize_standard_missile;
+	spathi_desc.cyborg_control.intelligence_func = spathi_intelligence;
+
+	RaceDescPtr = &spathi_desc;
 
 	return (RaceDescPtr);
 }
diff -ruNp src.hd/uqm/ships/spathi/spathi.h src/uqm/ships/spathi/spathi.h
--- src.hd/uqm/ships/spathi/spathi.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/spathi/spathi.h	2017-12-29 00:57:53 -0800
@@ -17,7 +17,15 @@
 #ifndef SPATHI_H
 #define SPATHI_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_spathi (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* SPATHI_H */
 
diff -ruNp src.hd/uqm/ships/supox/Makeinfo src/uqm/ships/supox/Makeinfo
--- src.hd/uqm/ships/supox/Makeinfo	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/supox/Makeinfo	2017-12-29 00:57:53 -0800
@@ -1 +1,2 @@
 uqm_CFILES="supox.c"
+uqm_HFILES="icode.h resinst.h supox.h"
diff -ruNp src.hd/uqm/ships/supox/icode.h src/uqm/ships/supox/icode.h
--- src.hd/uqm/ships/supox/icode.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/supox/icode.h	2017-12-29 00:57:53 -0800
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SUPOX_CODE "ship.supox.code"
diff -ruNp src.hd/uqm/ships/supox/resinst.h src/uqm/ships/supox/resinst.h
--- src.hd/uqm/ships/supox/resinst.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/supox/resinst.h	2017-12-29 00:57:53 -0800
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define GOB_BIG_MASK_PMAP_ANIM "ship.supox.graphics.glob.large"
 #define GOB_MED_MASK_PMAP_ANIM "ship.supox.graphics.glob.medium"
 #define GOB_SML_MASK_PMAP_ANIM "ship.supox.graphics.glob.small"
@@ -6,9 +10,7 @@
 #define SUPOX_ICON_MASK_PMAP_ANIM "ship.supox.icons"
 #define SUPOX_MED_MASK_PMAP_ANIM "ship.supox.graphics.blade.medium"
 #define SUPOX_MICON_MASK_PMAP_ANIM "ship.supox.meleeicons"
-#define SUPOX_SML_MASK_PMAP_ANIM "ship.supox.graphics.blade.small"
 #define SUPOX_RACE_STRINGS "ship.supox.text"
 #define SUPOX_SHIP_SOUNDS "ship.supox.sounds"
+#define SUPOX_SML_MASK_PMAP_ANIM "ship.supox.graphics.blade.small"
 #define SUPOX_VICTORY_SONG "ship.supox.ditty"
-
-#include "icode.h"
diff -ruNp src.hd/uqm/ships/supox/supox.c src/uqm/ships/supox/supox.c
--- src.hd/uqm/ships/supox/supox.c	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/supox/supox.c	2017-12-29 00:57:53 -0800
@@ -22,27 +22,45 @@
 
 #include "libs/mathlib.h"
 
-
+// Core characteristics
 #define MAX_CREW 12
 #define MAX_ENERGY 16
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 1
-#define SPECIAL_ENERGY_COST 1
 #define ENERGY_WAIT 4
 #define MAX_THRUST 40
 #define THRUST_INCREMENT 8
-#define TURN_WAIT 1
 #define THRUST_WAIT 0
-#define WEAPON_WAIT 2
-#define SPECIAL_WAIT 0
-
+#define TURN_WAIT 1
 #define SHIP_MASS 4
+
+// Gob launcher
+#define WEAPON_ENERGY_COST 1
+#define WEAPON_WAIT 2
+#define SUPOX_OFFSET RES_SCALE(23)
+#define MISSILE_OFFSET 2
 #define MISSILE_SPEED DISPLAY_TO_WORLD (30)
 #define MISSILE_LIFE 10
+#define MISSILE_HITS 1
+#define MISSILE_DAMAGE 1
+
+// Lateral/reverse thrust
+#define SPECIAL_ENERGY_COST 1
+		/* Unused - uncomment below to enable. */
+#define SPECIAL_WAIT 0
+		/* Unused except to initialize supox_desc.special_wait */
+
+// HD
+#define MAX_THRUST_2XRES 80
+#define THRUST_INCREMENT_2XRES 16
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
+#define MAX_THRUST_4XRES 160
+#define THRUST_INCREMENT_4XRES 16
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
 
-static RACE_DESC supox_desc =
+static RACE_DESC supox_desc1x =
 {
 	{ /* SHIP_INFO */
+		"blade",
 		FIRES_FORE,
 		16, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -112,14 +130,10 @@ static RACE_DESC supox_desc =
 };
 
 // JMS_GFX
-#define MAX_THRUST_2XRES 80
-#define THRUST_INCREMENT_2XRES 16
-#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
-
-// JMS_GFX
-static RACE_DESC supox_desc_2xres =
+static RACE_DESC supox_desc2x =
 {
 	{ /* SHIP_INFO */
+		"blade",
 		FIRES_FORE,
 		16, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -189,14 +203,10 @@ static RACE_DESC supox_desc_2xres =
 };
 
 // JMS_GFX
-#define MAX_THRUST_4XRES 160
-#define THRUST_INCREMENT_4XRES 16
-#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
-
-// JMS_GFX
-static RACE_DESC supox_desc_4xres =
+static RACE_DESC supox_desc4x =
 {
 	{ /* SHIP_INFO */
+		"blade",
 		FIRES_FORE,
 		16, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -266,7 +276,8 @@ static RACE_DESC supox_desc_4xres =
 };
 
 static void
-supox_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern, COUNT ConcernCounter)
+supox_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+		COUNT ConcernCounter)
 {
 	STARSHIP *StarShipPtr;
 	EVALUATE_DESC *lpEvalDesc;
@@ -332,10 +343,6 @@ supox_intelligence (ELEMENT *ShipPtr, EV
 static COUNT
 initialize_horn (ELEMENT *ShipPtr, HELEMENT HornArray[])
 {
-#define MISSILE_HITS 1
-#define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET 2
-#define SUPOX_OFFSET (23 << RESOLUTION_FACTOR) // JMS_GFX
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -347,7 +354,7 @@ initialize_horn (ELEMENT *ShipPtr, HELEM
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = SUPOX_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
+	MissileBlock.speed = RES_SCALE(MISSILE_SPEED);
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -423,29 +430,16 @@ supox_preprocess (ELEMENT *ElementPtr)
 RACE_DESC*
 init_supox (void)
 {
+	static RACE_DESC supox_desc;
 	RACE_DESC *RaceDescPtr;
 
-	if (RESOLUTION_FACTOR == 0)
-	{
-		supox_desc.preprocess_func = supox_preprocess;
-		supox_desc.init_weapon_func = initialize_horn;
-		supox_desc.cyborg_control.intelligence_func = supox_intelligence;
-		RaceDescPtr = &supox_desc;
-	}
-	else if (RESOLUTION_FACTOR == 1)
-	{
-		supox_desc_2xres.preprocess_func = supox_preprocess;
-		supox_desc_2xres.init_weapon_func = initialize_horn;
-		supox_desc_2xres.cyborg_control.intelligence_func = supox_intelligence;
-		RaceDescPtr = &supox_desc_2xres;
-	}
-	else
-	{
-		supox_desc_4xres.preprocess_func = supox_preprocess;
-		supox_desc_4xres.init_weapon_func = initialize_horn;
-		supox_desc_4xres.cyborg_control.intelligence_func = supox_intelligence;
-		RaceDescPtr = &supox_desc_4xres;
-	}
+	supox_desc = (RESOLUTION_FACTOR == 0 ? supox_desc1x : (RESOLUTION_FACTOR == 1 ? supox_desc2x : supox_desc4x));
+
+	supox_desc.preprocess_func = supox_preprocess;
+	supox_desc.init_weapon_func = initialize_horn;
+	supox_desc.cyborg_control.intelligence_func = supox_intelligence;
+
+	RaceDescPtr = &supox_desc;
 
 	return (RaceDescPtr);
 }
diff -ruNp src.hd/uqm/ships/supox/supox.h src/uqm/ships/supox/supox.h
--- src.hd/uqm/ships/supox/supox.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/supox/supox.h	2017-12-29 00:57:53 -0800
@@ -17,7 +17,15 @@
 #ifndef SUPOX_H
 #define SUPOX_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_supox (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* SUPOX_H */
 
diff -ruNp src.hd/uqm/ships/syreen/Makeinfo src/uqm/ships/syreen/Makeinfo
--- src.hd/uqm/ships/syreen/Makeinfo	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/syreen/Makeinfo	2017-12-29 00:57:53 -0800
@@ -1 +1,2 @@
 uqm_CFILES="syreen.c"
+uqm_HFILES="icode.h resinst.h syreen.h"
diff -ruNp src.hd/uqm/ships/syreen/icode.h src/uqm/ships/syreen/icode.h
--- src.hd/uqm/ships/syreen/icode.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/syreen/icode.h	2017-12-29 00:57:53 -0800
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SYREEN_CODE "ship.syreen.code"
diff -ruNp src.hd/uqm/ships/syreen/resinst.h src/uqm/ships/syreen/resinst.h
--- src.hd/uqm/ships/syreen/resinst.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/syreen/resinst.h	2017-12-29 00:57:53 -0800
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define DAGGER_BIG_MASK_PMAP_ANIM "ship.syreen.graphics.dagger.large"
 #define DAGGER_MED_MASK_PMAP_ANIM "ship.syreen.graphics.dagger.medium"
 #define DAGGER_SML_MASK_PMAP_ANIM "ship.syreen.graphics.dagger.small"
@@ -6,9 +10,7 @@
 #define SYREEN_ICON_MASK_PMAP_ANIM "ship.syreen.icons"
 #define SYREEN_MED_MASK_PMAP_ANIM "ship.syreen.graphics.penetrator.medium"
 #define SYREEN_MICON_MASK_PMAP_ANIM "ship.syreen.meleeicons"
-#define SYREEN_SML_MASK_PMAP_ANIM "ship.syreen.graphics.penetrator.small"
 #define SYREEN_RACE_STRINGS "ship.syreen.text"
 #define SYREEN_SHIP_SOUNDS "ship.syreen.sounds"
+#define SYREEN_SML_MASK_PMAP_ANIM "ship.syreen.graphics.penetrator.small"
 #define SYREEN_VICTORY_SONG "ship.syreen.ditty"
-
-#include "icode.h"
diff -ruNp src.hd/uqm/ships/syreen/syreen.c src/uqm/ships/syreen/syreen.c
--- src.hd/uqm/ships/syreen/syreen.c	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/syreen/syreen.c	2017-12-29 00:57:53 -0800
@@ -22,28 +22,47 @@
 #include "../../setup.h"
 #include "libs/mathlib.h"
 
-
+// Core characteristics
 #define SYREEN_MAX_CREW_SIZE MAX_CREW_SIZE
 #define MAX_CREW 12
 #define MAX_ENERGY 16
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 1
-#define SPECIAL_ENERGY_COST 5
 #define ENERGY_WAIT 6
 #define MAX_THRUST /* DISPLAY_TO_WORLD (8) */ 36
 #define THRUST_INCREMENT /* DISPLAY_TO_WORLD (2) */ 9
-#define TURN_WAIT 1
 #define THRUST_WAIT 1
-#define WEAPON_WAIT 8
-#define SPECIAL_WAIT 20
-
+#define TURN_WAIT 1
 #define SHIP_MASS 2
+
+// Particle Beam Stiletto
+#define WEAPON_ENERGY_COST 1
+#define WEAPON_WAIT 8
+#define SYREEN_OFFSET RES_SCALE(30)
 #define MISSILE_SPEED DISPLAY_TO_WORLD (30)
 #define MISSILE_LIFE 10
+#define MISSILE_HITS 1
+#define MISSILE_DAMAGE 2
+#define MISSILE_OFFSET RES_SCALE(3)
+
+// Syreen song
+#define SPECIAL_ENERGY_COST 5
+#define SPECIAL_WAIT 20
+#define ABANDONER_RANGE RES_SCALE(208) /* originally SPACE_HEIGHT */
+#define MAX_ABANDONERS 8
+
+// HD
+#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (8) */ 72
+#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (2) */ 18
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
+
+#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (8) */ 144
+#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (2) */ 36
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
 
-static RACE_DESC syreen_desc =
+static RACE_DESC syreen_desc1x =
 {
 	{ /* SHIP_INFO */
+		"penetrator",
 		FIRES_FORE,
 		13, /* Super Melee cost */
 		MAX_CREW, SYREEN_MAX_CREW_SIZE,
@@ -112,15 +131,12 @@ static RACE_DESC syreen_desc =
 	0, /* CodeRef */
 };
 
-// JMS_GFX
-#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (8) */ 72
-#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (2) */ 18
-#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
 
 // JMS_GFX
-static RACE_DESC syreen_desc_2xres =
+static RACE_DESC syreen_desc2x =
 {
 	{ /* SHIP_INFO */
+		"penetrator",
 		FIRES_FORE,
 		13, /* Super Melee cost */
 		MAX_CREW, SYREEN_MAX_CREW_SIZE,
@@ -190,14 +206,10 @@ static RACE_DESC syreen_desc_2xres =
 };
 
 // JMS_GFX
-#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (8) */ 144
-#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (2) */ 36
-#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
-
-// JMS_GFX
-static RACE_DESC syreen_desc_4xres =
+static RACE_DESC syreen_desc4x =
 {
 	{ /* SHIP_INFO */
+		"penetrator",
 		FIRES_FORE,
 		13, /* Super Melee cost */
 		MAX_CREW, SYREEN_MAX_CREW_SIZE,
@@ -269,10 +281,6 @@ static RACE_DESC syreen_desc_4xres =
 static COUNT
 initialize_dagger (ELEMENT *ShipPtr, HELEMENT DaggerArray[])
 {
-#define SYREEN_OFFSET (30 << RESOLUTION_FACTOR) // JMS_GFX
-#define MISSILE_HITS 1
-#define MISSILE_DAMAGE 2
-#define MISSILE_OFFSET (3 << RESOLUTION_FACTOR) // JMS_GFX
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -284,7 +292,7 @@ initialize_dagger (ELEMENT *ShipPtr, HEL
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = SYREEN_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
+	MissileBlock.speed = RES_SCALE(MISSILE_SPEED);
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -348,14 +356,13 @@ spawn_crew (ELEMENT *ElementPtr)
 
 				dx = WORLD_TO_DISPLAY (dx);
 				dy = WORLD_TO_DISPLAY (dy);
-#define ABANDONER_RANGE (208 << RESOLUTION_FACTOR) // JMS_GFX /* originally SPACE_HEIGHT */
 				if (dx <= ABANDONER_RANGE && dy <= ABANDONER_RANGE
 						&& (d_squared = (DWORD)((UWORD)dx * (UWORD)dx)
 						+ (DWORD)((UWORD)dy * (UWORD)dy)) <=
 						(DWORD)((UWORD)ABANDONER_RANGE * (UWORD)ABANDONER_RANGE))
 				{
-#define MAX_ABANDONERS 8
 					COUNT crew_loss;
+
 					if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
 						(((PlayerControl[0] & COMPUTER_CONTROL) && ElementPtr->playerNr == 0) || 
 						((PlayerControl[1] & COMPUTER_CONTROL) && ElementPtr->playerNr == 1))))
@@ -426,30 +433,17 @@ syreen_postprocess (ELEMENT *ElementPtr)
 RACE_DESC*
 init_syreen (void)
 {
+	
+	static RACE_DESC syreen_desc;
 	RACE_DESC *RaceDescPtr;
 
-	if (RESOLUTION_FACTOR == 0)
-	{
-		syreen_desc.postprocess_func = syreen_postprocess;
-		syreen_desc.init_weapon_func = initialize_dagger;
-		syreen_desc.cyborg_control.intelligence_func = syreen_intelligence;
-		RaceDescPtr = &syreen_desc;
-	}
-	else if (RESOLUTION_FACTOR == 1)
-	{
-		syreen_desc_2xres.postprocess_func = syreen_postprocess;
-		syreen_desc_2xres.init_weapon_func = initialize_dagger;
-		syreen_desc_2xres.cyborg_control.intelligence_func = syreen_intelligence;
-		RaceDescPtr = &syreen_desc_2xres;
-	}
-	else
-	{
-		syreen_desc_4xres.postprocess_func = syreen_postprocess;
-		syreen_desc_4xres.init_weapon_func = initialize_dagger;
-		syreen_desc_4xres.cyborg_control.intelligence_func = syreen_intelligence;
-		RaceDescPtr = &syreen_desc_4xres;
-	}
-	
+	syreen_desc = (RESOLUTION_FACTOR == 0 ? syreen_desc1x : (RESOLUTION_FACTOR == 1 ? syreen_desc2x : syreen_desc4x));
+
+	syreen_desc.postprocess_func = syreen_postprocess;
+	syreen_desc.init_weapon_func = initialize_dagger;
+	syreen_desc.cyborg_control.intelligence_func = syreen_intelligence;
+	RaceDescPtr = &syreen_desc;
+
 	return (RaceDescPtr);
 }
 
diff -ruNp src.hd/uqm/ships/syreen/syreen.h src/uqm/ships/syreen/syreen.h
--- src.hd/uqm/ships/syreen/syreen.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/syreen/syreen.h	2017-12-29 00:57:53 -0800
@@ -17,7 +17,15 @@
 #ifndef SYREEN_H
 #define SYREEN_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_syreen (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* SYREEN_H */
 
diff -ruNp src.hd/uqm/ships/thradd/Makeinfo src/uqm/ships/thradd/Makeinfo
--- src.hd/uqm/ships/thradd/Makeinfo	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/thradd/Makeinfo	2017-12-29 00:57:53 -0800
@@ -1 +1,2 @@
 uqm_CFILES="thradd.c"
+uqm_HFILES="icode.h resinst.h thradd.h"
diff -ruNp src.hd/uqm/ships/thradd/icode.h src/uqm/ships/thradd/icode.h
--- src.hd/uqm/ships/thradd/icode.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/thradd/icode.h	2017-12-29 00:57:53 -0800
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define THRADDASH_CODE "ship.thraddash.code"
diff -ruNp src.hd/uqm/ships/thradd/resinst.h src/uqm/ships/thradd/resinst.h
--- src.hd/uqm/ships/thradd/resinst.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/thradd/resinst.h	2017-12-29 00:57:53 -0800
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define HORN_BIG_MASK_PMAP_ANIM "ship.thraddash.graphics.horn.large"
 #define HORN_MED_MASK_PMAP_ANIM "ship.thraddash.graphics.horn.medium"
 #define HORN_SML_MASK_PMAP_ANIM "ship.thraddash.graphics.horn.small"
@@ -9,9 +13,7 @@
 #define THRADDASH_ICON_MASK_PMAP_ANIM "ship.thraddash.icons"
 #define THRADDASH_MED_MASK_PMAP_ANIM "ship.thraddash.graphics.torch.medium"
 #define THRADDASH_MICON_MASK_PMAP_ANIM "ship.thraddash.meleeicons"
-#define THRADDASH_SML_MASK_PMAP_ANIM "ship.thraddash.graphics.torch.small"
 #define THRADDASH_RACE_STRINGS "ship.thraddash.text"
 #define THRADDASH_SHIP_SOUNDS "ship.thraddash.sounds"
+#define THRADDASH_SML_MASK_PMAP_ANIM "ship.thraddash.graphics.torch.small"
 #define THRADDASH_VICTORY_SONG "ship.thraddash.ditty"
-
-#include "icode.h"
diff -ruNp src.hd/uqm/ships/thradd/thradd.c src/uqm/ships/thradd/thradd.c
--- src.hd/uqm/ships/thradd/thradd.c	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/thradd/thradd.c	2017-12-29 00:57:53 -0800
@@ -22,28 +22,56 @@
 
 #include "uqm/globdata.h"
 
-
+// Core characteristics
 #define MAX_CREW 8
 #define MAX_ENERGY 24
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 2
-#define SPECIAL_ENERGY_COST 1
 #define ENERGY_WAIT 6
 #define MAX_THRUST 28
 #define THRUST_INCREMENT 7
-#define TURN_WAIT 1
 #define THRUST_WAIT 0
-#define WEAPON_WAIT 12
-#define SPECIAL_WAIT 0
-
+#define TURN_WAIT 1
 #define SHIP_MASS 7
-#define THRADDASH_OFFSET (9 << RESOLUTION_FACTOR) // JMS_GFX
+
+// Ion Blasters
+#define WEAPON_ENERGY_COST 2
+#define WEAPON_WAIT 12
 #define MISSILE_SPEED DISPLAY_TO_WORLD (30)
 #define MISSILE_LIFE 15
+#define MISSILE_OFFSET RES_SCALE(3)
+#define THRADDASH_OFFSET RES_SCALE(9)
+#define MISSILE_HITS 2
+#define MISSILE_DAMAGE 1
+
+// Afterburner
+#define SPECIAL_ENERGY_COST 1
+#define SPECIAL_WAIT 0
+#define SPECIAL_THRUST_INCREMENT RES_SCALE(12)
+#define SPECIAL_MAX_THRUST RES_SCALE(72)
+#define NAPALM_LIFE 48
+#define NAPALM_OFFSET 0
+#define NAPALM_HITS 1
+#define NAPALM_DAMAGE 2
+#define NAPALM_DECAY_RATE 5
+		/* Controls the speed of the afterburner "decay" animation; it will
+		 * decay one step (one animation frame) per NAPALM_DECAY_RATE
+		 * frames. */
+#define NUM_NAPALM_FADES 6
+#define STATIONARY_SPEED WORLD_TO_VELOCITY (DISPLAY_TO_WORLD RES_SCALE(4))
+
+// HD
+#define MAX_THRUST_2XRES 56
+#define THRUST_INCREMENT_2XRES 14
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
+#define MAX_THRUST_4XRES 112
+#define THRUST_INCREMENT_4XRES 28
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
+
 
-static RACE_DESC thraddash_desc =
+static RACE_DESC thraddash_desc1x =
 {
 	{ /* SHIP_INFO */
+		"torch",
 		FIRES_FORE,
 		10, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -113,14 +141,10 @@ static RACE_DESC thraddash_desc =
 };
 
 // JMS_GFX
-#define MAX_THRUST_2XRES 56
-#define THRUST_INCREMENT_2XRES 14
-#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
-
-// JMS_GFX
-static RACE_DESC thraddash_desc_2xres =
+static RACE_DESC thraddash_desc2x =
 {
 	{ /* SHIP_INFO */
+		"torch",
 		FIRES_FORE,
 		10, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -190,14 +214,10 @@ static RACE_DESC thraddash_desc_2xres =
 };
 
 // JMS_GFX
-#define MAX_THRUST_4XRES 112
-#define THRUST_INCREMENT_4XRES 28
-#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
-
-// JMS_GFX
-static RACE_DESC thraddash_desc_4xres =
+static RACE_DESC thraddash_desc4x =
 {
 	{ /* SHIP_INFO */
+		"torch",
 		FIRES_FORE,
 		10, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -277,7 +297,6 @@ thraddash_intelligence (ELEMENT *ShipPtr
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
 	if (lpEvalDesc->ObjectPtr)
 	{
-#define STATIONARY_SPEED WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (4 << RESOLUTION_FACTOR)) // JMS_GFX
 		SDWORD dx, dy;
 
 		GetCurrentVelocityComponentsSdword (
@@ -356,8 +375,6 @@ thraddash_intelligence (ELEMENT *ShipPtr
 	}
 }
 
-#define NAPALM_WAIT 1
-
 static void
 flame_napalm_preprocess (ELEMENT *ElementPtr)
 {
@@ -374,24 +391,26 @@ flame_napalm_preprocess (ELEMENT *Elemen
 		InitIntersectEndPoint (ElementPtr);
 		InitIntersectFrame (ElementPtr);
 	}
+	/* turn_wait is abused here to store the speed of the decay animation */
 	else if (ElementPtr->turn_wait > 0)
 		--ElementPtr->turn_wait;
 	else
 	{
-#define NUM_NAPALM_FADES 6
-		if (ElementPtr->life_span <= NUM_NAPALM_FADES * (NAPALM_WAIT + 1)
+		if (ElementPtr->life_span <= NUM_NAPALM_FADES * (NAPALM_DECAY_RATE + 1)
 				|| GetFrameIndex (
 				ElementPtr->current.image.frame
 				) != NUM_NAPALM_FADES)
 			ElementPtr->next.image.frame =
 					DecFrameIndex (ElementPtr->current.image.frame);
-		else if (ElementPtr->life_span > NUM_NAPALM_FADES * (NAPALM_WAIT + 1))
+		else if (ElementPtr->life_span > NUM_NAPALM_FADES * (NAPALM_DECAY_RATE + 1))
 			ElementPtr->next.image.frame = SetAbsFrameIndex (
 					ElementPtr->current.image.frame,
 					GetFrameCount (ElementPtr->current.image.frame) - 1
 					);
 
-		ElementPtr->turn_wait = NAPALM_WAIT;
+		/* turn_wait is abused here to store the speed of the decay
+		 * animation. */
+		ElementPtr->turn_wait = NAPALM_DECAY_RATE;
 		ElementPtr->state_flags |= CHANGING;
 	}
 }
@@ -399,9 +418,6 @@ flame_napalm_preprocess (ELEMENT *Elemen
 static COUNT
 initialize_horn (ELEMENT *ShipPtr, HELEMENT HornArray[])
 {
-#define MISSILE_HITS 2
-#define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET (3 << RESOLUTION_FACTOR) // JMS_GFX
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -413,7 +429,7 @@ initialize_horn (ELEMENT *ShipPtr, HELEM
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = THRADDASH_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
+	MissileBlock.speed = RES_SCALE(MISSILE_SPEED);
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -438,8 +454,6 @@ thraddash_preprocess (ELEMENT *ElementPt
 	}
 	else if (DeltaEnergy (ElementPtr, -SPECIAL_ENERGY_COST))
 	{
-#define SPECIAL_THRUST_INCREMENT (12 << RESOLUTION_FACTOR) // JMS_GFX
-#define SPECIAL_MAX_THRUST (72 << RESOLUTION_FACTOR) // JMS_GFX
 		COUNT max_thrust, thrust_increment;
 		STATUS_FLAGS thrust_status;
 		HELEMENT hTrailElement;
@@ -471,10 +485,6 @@ thraddash_preprocess (ELEMENT *ElementPt
 		StarShipPtr->RaceDescPtr->characteristics.max_thrust = max_thrust;
 
 		{
-#define NAPALM_HITS 1
-#define NAPALM_DAMAGE 2
-#define NAPALM_LIFE 48
-#define NAPALM_OFFSET 0
 			MISSILE_BLOCK MissileBlock;
 
 			MissileBlock.cx = ElementPtr->next.location.x;
@@ -502,7 +512,10 @@ thraddash_preprocess (ELEMENT *ElementPt
 				LockElement (hTrailElement, &TrailElementPtr);
 				SetElementStarShip (TrailElementPtr, StarShipPtr);
 				TrailElementPtr->hTarget = 0;
-				TrailElementPtr->turn_wait = NAPALM_WAIT;
+
+				/* turn_wait is abused here to store the speed of the decay
+				 * animation */
+				TrailElementPtr->turn_wait = NAPALM_DECAY_RATE;
 
 				TrailElementPtr->state_flags |= NONSOLID;
 				SetPrimType (
@@ -530,29 +543,16 @@ thraddash_preprocess (ELEMENT *ElementPt
 RACE_DESC*
 init_thraddash (void)
 {
+	static RACE_DESC thraddash_desc;
 	RACE_DESC *RaceDescPtr;
 
-	if (RESOLUTION_FACTOR == 0)
-	{
-		thraddash_desc.preprocess_func = thraddash_preprocess;
-		thraddash_desc.init_weapon_func = initialize_horn;
-		thraddash_desc.cyborg_control.intelligence_func = thraddash_intelligence;
-		RaceDescPtr = &thraddash_desc;
-	}
-	else if (RESOLUTION_FACTOR == 1)
-	{
-		thraddash_desc_2xres.preprocess_func = thraddash_preprocess;
-		thraddash_desc_2xres.init_weapon_func = initialize_horn;
-		thraddash_desc_2xres.cyborg_control.intelligence_func = thraddash_intelligence;
-		RaceDescPtr = &thraddash_desc_2xres;
-	}
-	else
-	{
-		thraddash_desc_4xres.preprocess_func = thraddash_preprocess;
-		thraddash_desc_4xres.init_weapon_func = initialize_horn;
-		thraddash_desc_4xres.cyborg_control.intelligence_func = thraddash_intelligence;
-		RaceDescPtr = &thraddash_desc_4xres;
-	}
+	thraddash_desc = (RESOLUTION_FACTOR == 0 ? thraddash_desc1x : (RESOLUTION_FACTOR == 1 ? thraddash_desc2x : thraddash_desc4x));
+
+	thraddash_desc.preprocess_func = thraddash_preprocess;
+	thraddash_desc.init_weapon_func = initialize_horn;
+	thraddash_desc.cyborg_control.intelligence_func = thraddash_intelligence;
+
+	RaceDescPtr = &thraddash_desc;
 
 	return (RaceDescPtr);
 }
diff -ruNp src.hd/uqm/ships/thradd/thradd.h src/uqm/ships/thradd/thradd.h
--- src.hd/uqm/ships/thradd/thradd.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/thradd/thradd.h	2017-12-29 00:57:53 -0800
@@ -17,7 +17,15 @@
 #ifndef THRADD_H
 #define THRADD_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_thraddash (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* THRADD_H */
 
diff -ruNp src.hd/uqm/ships/umgah/Makeinfo src/uqm/ships/umgah/Makeinfo
--- src.hd/uqm/ships/umgah/Makeinfo	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/umgah/Makeinfo	2017-12-29 00:57:53 -0800
@@ -1 +1,2 @@
 uqm_CFILES="umgah.c"
+uqm_HFILES="icode.h resinst.h umgah.h"
diff -ruNp src.hd/uqm/ships/umgah/icode.h src/uqm/ships/umgah/icode.h
--- src.hd/uqm/ships/umgah/icode.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/umgah/icode.h	2017-12-29 00:57:53 -0800
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define UMGAH_CODE "ship.umgah.code"
diff -ruNp src.hd/uqm/ships/umgah/resinst.h src/uqm/ships/umgah/resinst.h
--- src.hd/uqm/ships/umgah/resinst.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/umgah/resinst.h	2017-12-29 00:57:53 -0800
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define CONE_BIG_MASK_ANIM "ship.umgah.graphics.cone.large"
 #define CONE_MED_MASK_ANIM "ship.umgah.graphics.cone.medium"
 #define CONE_SML_MASK_ANIM "ship.umgah.graphics.cone.small"
@@ -7,9 +11,7 @@
 #define UMGAH_ICON_MASK_PMAP_ANIM "ship.umgah.icons"
 #define UMGAH_MED_MASK_PMAP_ANIM "ship.umgah.graphics.drone.medium"
 #define UMGAH_MICON_MASK_PMAP_ANIM "ship.umgah.meleeicons"
-#define UMGAH_SML_MASK_PMAP_ANIM "ship.umgah.graphics.drone.small"
 #define UMGAH_RACE_STRINGS "ship.umgah.text"
 #define UMGAH_SHIP_SOUNDS "ship.umgah.sounds"
+#define UMGAH_SML_MASK_PMAP_ANIM "ship.umgah.graphics.drone.small"
 #define UMGAH_VICTORY_SONG "ship.umgah.ditty"
-
-#include "icode.h"
diff -ruNp src.hd/uqm/ships/umgah/umgah.c src/uqm/ships/umgah/umgah.c
--- src.hd/uqm/ships/umgah/umgah.c	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/umgah/umgah.c	2017-12-29 00:57:53 -0800
@@ -22,25 +22,42 @@
 
 #include "libs/mathlib.h"
 
-
+// Core characteristics
 #define MAX_CREW 10
 #define MAX_ENERGY 30
 #define ENERGY_REGENERATION MAX_ENERGY
-#define WEAPON_ENERGY_COST 0
-#define SPECIAL_ENERGY_COST 1
 #define ENERGY_WAIT 150
 #define MAX_THRUST /* DISPLAY_TO_WORLD (5) */ 18
 #define THRUST_INCREMENT /* DISPLAY_TO_WORLD (2) */ 6
-#define TURN_WAIT 4
 #define THRUST_WAIT 3
+#define TURN_WAIT 4
+#define SHIP_MASS 1
+
+// Antimatter cone
+#define WEAPON_ENERGY_COST 0
 #define WEAPON_WAIT 0
+#define UMGAH_OFFSET 0
+#define CONE_OFFSET 0
+#define CONE_SPEED 0
+#define CONE_HITS 100
+#define CONE_DAMAGE 1
+#define CONE_LIFE 1
+
+// Retropropulsion
+#define SPECIAL_ENERGY_COST 1
 #define SPECIAL_WAIT 2
+#define JUMP_DIST DISPLAY_TO_WORLD RES_SCALE(40)
 
-#define SHIP_MASS 1
+// HD
+#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (5) */ 36
+#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (2) */ 12
+#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (5) */ 72
+#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (2) */ 24
 
-static RACE_DESC umgah_desc =
+static RACE_DESC umgah_desc1x =
 {
 	{ /* SHIP_INFO */
+		"drone",
 		FIRES_FORE | IMMEDIATE_WEAPON,
 		7, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -110,13 +127,10 @@ static RACE_DESC umgah_desc =
 };
 
 // JMS_GFX
-#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (5) */ 36
-#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (2) */ 12
-
-// JMS_GFX
-static RACE_DESC umgah_desc_2xres =
+static RACE_DESC umgah_desc2x =
 {
 	{ /* SHIP_INFO */
+		"drone",
 		FIRES_FORE | IMMEDIATE_WEAPON,
 		7, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -186,13 +200,10 @@ static RACE_DESC umgah_desc_2xres =
 };
 
 // JMS_GFX
-#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (5) */ 72
-#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (2) */ 24
-
-// JMS_GFX
-static RACE_DESC umgah_desc_4xres =
+static RACE_DESC umgah_desc4x =
 {
 	{ /* SHIP_INFO */
+		"drone",
 		FIRES_FORE | IMMEDIATE_WEAPON,
 		7, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -261,6 +272,46 @@ static RACE_DESC umgah_desc_4xres =
 	0, /* CodeRef */
 };
 
+
+// Private per-instance ship data
+typedef struct
+{
+	UWORD prevFacing;
+} UMGAH_DATA;
+
+// Local typedef
+typedef UMGAH_DATA CustomShipData_t;
+
+// Retrieve race-specific ship data from a race desc
+static CustomShipData_t *
+GetCustomShipData (RACE_DESC *pRaceDesc)
+{
+	return pRaceDesc->data;
+}
+
+// Set the race-specific data in a race desc
+// (Re)Allocates its own storage for the data.
+static void
+SetCustomShipData (RACE_DESC *pRaceDesc, const CustomShipData_t *data)
+{
+	if (pRaceDesc->data == data) 
+		return;  // no-op
+
+	if (pRaceDesc->data) // Out with the old
+	{
+		HFree (pRaceDesc->data);
+		pRaceDesc->data = NULL;
+	}
+
+	if (data) // In with the new
+	{
+		CustomShipData_t* newData = HMalloc (sizeof (*data));
+		*newData = *data;
+		pRaceDesc->data = newData;
+	}
+}
+
+
 static void
 cone_preprocess (ELEMENT *ElementPtr)
 {
@@ -290,8 +341,6 @@ cone_collision (ELEMENT *ElementPtr0, PO
 	}
 }
 
-#define JUMP_DIST DISPLAY_TO_WORLD (40 << RESOLUTION_FACTOR) // JMS_GFX
-
 static void
 umgah_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
 		COUNT ConcernCounter)
@@ -410,13 +459,8 @@ umgah_intelligence (ELEMENT *ShipPtr, EV
 static COUNT
 initialize_cone (ELEMENT *ShipPtr, HELEMENT ConeArray[])
 {
-#define UMGAH_OFFSET 0
-#define MISSILE_SPEED 0
-#define MISSILE_HITS 100
-#define MISSILE_DAMAGE 1
-#define MISSILE_LIFE 1
-#define MISSILE_OFFSET 0
 	STARSHIP *StarShipPtr;
+	UMGAH_DATA* UmgahData;
 	MISSILE_BLOCK MissileBlock;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
@@ -427,24 +471,26 @@ initialize_cone (ELEMENT *ShipPtr, HELEM
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = UMGAH_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
-	MissileBlock.hit_points = MISSILE_HITS;
-	MissileBlock.damage = MISSILE_DAMAGE;
-	MissileBlock.life = MISSILE_LIFE;
+	MissileBlock.speed = CONE_SPEED;
+	MissileBlock.hit_points = CONE_HITS;
+	MissileBlock.damage = CONE_DAMAGE;
+	MissileBlock.life = CONE_LIFE;
 	MissileBlock.preprocess_func = cone_preprocess;
-	MissileBlock.blast_offs = MISSILE_OFFSET;
+	MissileBlock.blast_offs = CONE_OFFSET;
 
 	// This func is called every frame while the player is holding down WEAPON
 	// Don't reset the cone FRAME to the first image every time
-	if (ShipPtr->next.image.frame != (FRAME) StarShipPtr->RaceDescPtr->data)
+	UmgahData = GetCustomShipData (StarShipPtr->RaceDescPtr);
+	if (!UmgahData || StarShipPtr->ShipFacing != UmgahData->prevFacing)
 	{
-		StarShipPtr->RaceDescPtr->data = (intptr_t) ShipPtr->next.image.frame;
+		const UMGAH_DATA shipData = {StarShipPtr->ShipFacing};
+
+		SetCustomShipData (StarShipPtr->RaceDescPtr, &shipData);
 
 		StarShipPtr->RaceDescPtr->ship_data.special[0] =
 				SetAbsFrameIndex (
 				StarShipPtr->RaceDescPtr->ship_data.special[0],
-				StarShipPtr->ShipFacing
-				);
+				StarShipPtr->ShipFacing);
 	}
 	
 	MissileBlock.index = GetFrameIndex (StarShipPtr->RaceDescPtr->ship_data.special[0]);
@@ -460,7 +506,8 @@ initialize_cone (ELEMENT *ShipPtr, HELEM
 		ConePtr->next = ConePtr->current;
 		InitIntersectStartPoint (ConePtr);
 		InitIntersectEndPoint (ConePtr);
-		ConePtr->IntersectControl.IntersectStamp.frame = StarShipPtr->RaceDescPtr->ship_data.special[0];
+		ConePtr->IntersectControl.IntersectStamp.frame =
+				StarShipPtr->RaceDescPtr->ship_data.special[0];
 		UnlockElement (ConeArray[0]);
 	}
 
@@ -491,7 +538,7 @@ umgah_preprocess (ELEMENT *ElementPtr)
 	if (ElementPtr->state_flags & APPEARING)
 	{
 		// Reset the value just in case
-		StarShipPtr->RaceDescPtr->data = 0;
+		SetCustomShipData (StarShipPtr->RaceDescPtr, NULL);
 	}
 	else
 	{
@@ -516,35 +563,27 @@ umgah_preprocess (ELEMENT *ElementPtr)
 	}
 }
 
+static void
+uninit_umgah (RACE_DESC *pRaceDesc)
+{
+	SetCustomShipData (pRaceDesc, NULL);
+}
+
 RACE_DESC*
 init_umgah (void)
 {
+	static RACE_DESC umgah_desc;
 	RACE_DESC *RaceDescPtr;
 
-	if (RESOLUTION_FACTOR == 0)
-	{
-		umgah_desc.preprocess_func = umgah_preprocess;
-		umgah_desc.postprocess_func = umgah_postprocess;
-		umgah_desc.init_weapon_func = initialize_cone;
-		umgah_desc.cyborg_control.intelligence_func = umgah_intelligence;
-		RaceDescPtr = &umgah_desc;
-	}
-	else if (RESOLUTION_FACTOR == 1)
-	{
-		umgah_desc_2xres.preprocess_func = umgah_preprocess;
-		umgah_desc_2xres.postprocess_func = umgah_postprocess;
-		umgah_desc_2xres.init_weapon_func = initialize_cone;
-		umgah_desc_2xres.cyborg_control.intelligence_func = umgah_intelligence;
-		RaceDescPtr = &umgah_desc_2xres;
-	}
-	else
-	{
-		umgah_desc_4xres.preprocess_func = umgah_preprocess;
-		umgah_desc_4xres.postprocess_func = umgah_postprocess;
-		umgah_desc_4xres.init_weapon_func = initialize_cone;
-		umgah_desc_4xres.cyborg_control.intelligence_func = umgah_intelligence;
-		RaceDescPtr = &umgah_desc_4xres;
-	}
+	umgah_desc = (RESOLUTION_FACTOR == 0 ? umgah_desc1x : (RESOLUTION_FACTOR == 1 ? umgah_desc2x : umgah_desc4x));
+
+	umgah_desc.uninit_func = uninit_umgah;
+	umgah_desc.preprocess_func = umgah_preprocess;
+	umgah_desc.postprocess_func = umgah_postprocess;
+	umgah_desc.init_weapon_func = initialize_cone;
+	umgah_desc.cyborg_control.intelligence_func = umgah_intelligence;
+
+	RaceDescPtr = &umgah_desc;
 
 	return (RaceDescPtr);
 }
diff -ruNp src.hd/uqm/ships/umgah/umgah.h src/uqm/ships/umgah/umgah.h
--- src.hd/uqm/ships/umgah/umgah.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/umgah/umgah.h	2017-12-29 00:57:53 -0800
@@ -17,7 +17,15 @@
 #ifndef UMGAH_H
 #define UMGAH_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_umgah (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* UMGAH_H */
 
diff -ruNp src.hd/uqm/ships/urquan/Makeinfo src/uqm/ships/urquan/Makeinfo
--- src.hd/uqm/ships/urquan/Makeinfo	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/urquan/Makeinfo	2017-12-29 00:57:53 -0800
@@ -1 +1,2 @@
 uqm_CFILES="urquan.c"
+uqm_HFILES="icode.h resinst.h urquan.h"
diff -ruNp src.hd/uqm/ships/urquan/icode.h src/uqm/ships/urquan/icode.h
--- src.hd/uqm/ships/urquan/icode.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/urquan/icode.h	2017-12-29 00:57:53 -0800
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define URQUAN_CODE "ship.urquan.code"
diff -ruNp src.hd/uqm/ships/urquan/resinst.h src/uqm/ships/urquan/resinst.h
--- src.hd/uqm/ships/urquan/resinst.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/urquan/resinst.h	2017-12-29 00:57:53 -0800
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define FIGHTER_BIG_MASK_PMAP_ANIM "ship.urquan.graphics.fighter.large"
 #define FIGHTER_MED_MASK_PMAP_ANIM "ship.urquan.graphics.fighter.medium"
 #define FIGHTER_SML_MASK_PMAP_ANIM "ship.urquan.graphics.fighter.small"
@@ -9,9 +13,7 @@
 #define URQUAN_ICON_MASK_PMAP_ANIM "ship.urquan.icons"
 #define URQUAN_MED_MASK_PMAP_ANIM "ship.urquan.graphics.dreadnought.medium"
 #define URQUAN_MICON_MASK_PMAP_ANIM "ship.urquan.meleeicons"
-#define URQUAN_SML_MASK_PMAP_ANIM "ship.urquan.graphics.dreadnought.small"
 #define URQUAN_RACE_STRINGS "ship.urquan.text"
 #define URQUAN_SHIP_SOUNDS "ship.urquan.sounds"
+#define URQUAN_SML_MASK_PMAP_ANIM "ship.urquan.graphics.dreadnought.small"
 #define URQUAN_VICTORY_SONG "ship.urquan.ditty"
-
-#include "icode.h"
diff -ruNp src.hd/uqm/ships/urquan/urquan.c src/uqm/ships/urquan/urquan.c
--- src.hd/uqm/ships/urquan/urquan.c	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/urquan/urquan.c	2017-12-29 00:57:53 -0800
@@ -20,32 +20,57 @@
 #include "urquan.h"
 #include "resinst.h"
 #include "../../intel.h"
-#include "uqm/colors.h"
 #include "uqm/globdata.h"
 #include "../../setup.h"
+#include "uqm/colors.h"
 #include <stdlib.h>
 
-
+// Core characteristics
 #define MAX_CREW MAX_CREW_SIZE
 #define MAX_ENERGY MAX_ENERGY_SIZE
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 6
-#define SPECIAL_ENERGY_COST 8
 #define ENERGY_WAIT 4
 #define MAX_THRUST 30
 #define THRUST_INCREMENT 6
-#define TURN_WAIT 4
 #define THRUST_WAIT 6
-#define WEAPON_WAIT 6
-#define SPECIAL_WAIT 9
-
+#define TURN_WAIT 4
 #define SHIP_MASS 10
+
+// Fusion blast
+#define WEAPON_ENERGY_COST 6
+#define WEAPON_WAIT 6
 #define MISSILE_SPEED DISPLAY_TO_WORLD (20)
 #define MISSILE_LIFE 20
+#define MISSILE_HITS 10
+#define MISSILE_DAMAGE 6
+#define MISSILE_OFFSET RES_SCALE(8)
+#define URQUAN_OFFSET RES_SCALE(32)
+
+// Fighters
+#define SPECIAL_ENERGY_COST 8
+#define SPECIAL_WAIT 9
+#define FIGHTER_OFFSET RES_SCALE(4)
+#define FIGHTER_SPEED DISPLAY_TO_WORLD RES_SCALE(8)
+#define ONE_WAY_FLIGHT 125
+#define TRACK_THRESHOLD 6
+#define FIGHTER_LIFE (ONE_WAY_FLIGHT + ONE_WAY_FLIGHT + 150)
+#define FIGHTER_HITS 1
+#define FIGHTER_MASS 0
+#define FIGHTER_WEAPON_WAIT 8
+#define FIGHTER_LASER_RANGE DISPLAY_TO_WORLD (RES_SCALE(40) + FIGHTER_OFFSET)
+
+// HD
+#define MAX_THRUST_2XRES 60
+#define THRUST_INCREMENT_2XRES 12
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (40)
+#define MAX_THRUST_4XRES 120
+#define THRUST_INCREMENT_4XRES 24
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (80)
 
-static RACE_DESC urquan_desc =
+static RACE_DESC urquan_desc1x =
 {
 	{ /* SHIP_INFO */
+		"dreadnought",
 		FIRES_FORE | SEEKING_SPECIAL,
 		30, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -115,14 +140,10 @@ static RACE_DESC urquan_desc =
 };
 
 // JMS_GFX
-#define MAX_THRUST_2XRES 60
-#define THRUST_INCREMENT_2XRES 12
-#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (40)
-
-// JMS_GFX
-static RACE_DESC urquan_desc_2xres =
+static RACE_DESC urquan_desc2x =
 {
 	{ /* SHIP_INFO */
+		"dreadnought",
 		FIRES_FORE | SEEKING_SPECIAL,
 		30, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -192,14 +213,10 @@ static RACE_DESC urquan_desc_2xres =
 };
 
 // JMS_GFX
-#define MAX_THRUST_4XRES 120
-#define THRUST_INCREMENT_4XRES 24
-#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (80)
-
-// JMS_GFX
-static RACE_DESC urquan_desc_4xres =
+static RACE_DESC urquan_desc4x =
 {
 	{ /* SHIP_INFO */
+		"dreadnought",
 		FIRES_FORE | SEEKING_SPECIAL,
 		30, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -271,10 +288,6 @@ static RACE_DESC urquan_desc_4xres =
 static COUNT
 initialize_fusion (ELEMENT *ShipPtr, HELEMENT FusionArray[])
 {
-#define MISSILE_HITS 10
-#define MISSILE_DAMAGE 6
-#define MISSILE_OFFSET (8 << RESOLUTION_FACTOR) // JMS_GFX
-#define URQUAN_OFFSET (32 << RESOLUTION_FACTOR) // JMS_GFX
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -286,7 +299,7 @@ initialize_fusion (ELEMENT *ShipPtr, HEL
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = URQUAN_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
+	MissileBlock.speed = RES_SCALE(MISSILE_SPEED);
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -297,15 +310,6 @@ initialize_fusion (ELEMENT *ShipPtr, HEL
 	return (1);
 }
 
-#define TRACK_THRESHOLD 6
-#define FIGHTER_SPEED DISPLAY_TO_WORLD (8 << RESOLUTION_FACTOR) // JMS_GFX
-#define ONE_WAY_FLIGHT 125
-#define FIGHTER_LIFE (ONE_WAY_FLIGHT + ONE_WAY_FLIGHT + 150)
-
-#define FIGHTER_WEAPON_WAIT 8
-#define FIGHTER_OFFSET (4 << RESOLUTION_FACTOR) // JMS_GFX
-#define LASER_RANGE DISPLAY_TO_WORLD ((40 << RESOLUTION_FACTOR) + FIGHTER_OFFSET) // JMS_GFX
-
 static void
 fighter_postprocess (ELEMENT *ElementPtr)
 {
@@ -317,8 +321,8 @@ fighter_postprocess (ELEMENT *ElementPtr
 	LaserBlock.cx = ElementPtr->next.location.x;
 	LaserBlock.cy = ElementPtr->next.location.y;
 	LaserBlock.face = ElementPtr->thrust_wait;
-	LaserBlock.ex = COSINE (FACING_TO_ANGLE (LaserBlock.face), LASER_RANGE);
-	LaserBlock.ey = SINE (FACING_TO_ANGLE (LaserBlock.face), LASER_RANGE);
+	LaserBlock.ex = COSINE (FACING_TO_ANGLE (LaserBlock.face), FIGHTER_LASER_RANGE);
+	LaserBlock.ey = SINE (FACING_TO_ANGLE (LaserBlock.face), FIGHTER_LASER_RANGE);
 	LaserBlock.sender = ElementPtr->playerNr;
 	LaserBlock.flags = IGNORE_SIMILAR;
 	LaserBlock.pixoffs = FIGHTER_OFFSET;
@@ -411,10 +415,10 @@ fighter_preprocess (ELEMENT *ElementPtr)
 			delta_y = WRAP_DELTA_Y (delta_y);
 
 			if (ElementPtr->thrust_wait == 0
-					&& abs (delta_x) < LASER_RANGE * 3 / 4
-					&& abs (delta_y) < LASER_RANGE * 3 / 4
+					&& abs (delta_x) < FIGHTER_LASER_RANGE * 3 / 4
+					&& abs (delta_y) < FIGHTER_LASER_RANGE * 3 / 4
 					&& delta_x * delta_x + delta_y * delta_y <
-					(LASER_RANGE * 3 / 4) * (LASER_RANGE * 3 / 4))
+					(FIGHTER_LASER_RANGE * 3 / 4) * (FIGHTER_LASER_RANGE * 3 / 4))
 			{
 				ElementPtr->thrust_wait =
 						(BYTE)NORMALIZE_FACING (
@@ -429,16 +433,16 @@ fighter_preprocess (ELEMENT *ElementPtr)
 				if (ElementPtr->turn_wait & LEFT)
 				{
 					delta_x += COSINE (FACING_TO_ANGLE (facing - 4),
-							DISPLAY_TO_WORLD (30 << RESOLUTION_FACTOR)); // JMS_GFX
+							DISPLAY_TO_WORLD RES_SCALE(30));
 					delta_y += SINE (FACING_TO_ANGLE (facing - 4),
-							DISPLAY_TO_WORLD (30 << RESOLUTION_FACTOR));
+							DISPLAY_TO_WORLD RES_SCALE(30));
 				}
 				else
 				{
 					delta_x += COSINE (FACING_TO_ANGLE (facing + 4),
-							DISPLAY_TO_WORLD (30 << RESOLUTION_FACTOR)); // JMS_GFX
+							DISPLAY_TO_WORLD RES_SCALE(30));
 					delta_y += SINE (FACING_TO_ANGLE (facing + 4),
-							DISPLAY_TO_WORLD (30 << RESOLUTION_FACTOR));
+							DISPLAY_TO_WORLD RES_SCALE(30));
 				}
 				facing = NORMALIZE_FACING (
 						ANGLE_TO_FACING (ARCTAN (delta_x, delta_y))
@@ -555,8 +559,8 @@ spawn_fighters (ELEMENT *ElementPtr)
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	facing = StarShipPtr->ShipFacing + ANGLE_TO_FACING (HALF_CIRCLE);
-	delta_x = COSINE (FACING_TO_ANGLE (facing), DISPLAY_TO_WORLD (14 << RESOLUTION_FACTOR)); // JMS_GFX
-	delta_y = SINE (FACING_TO_ANGLE (facing), DISPLAY_TO_WORLD (14 << RESOLUTION_FACTOR));
+	delta_x = COSINE (FACING_TO_ANGLE (facing), DISPLAY_TO_WORLD RES_SCALE(14));
+	delta_y = SINE (FACING_TO_ANGLE (facing), DISPLAY_TO_WORLD RES_SCALE(14));
 
 	i = ElementPtr->crew_level > 2 ? 2 : 1;
 	while (i-- && (hFighterElement = AllocElement ()))
@@ -564,7 +568,7 @@ spawn_fighters (ELEMENT *ElementPtr)
 		SDWORD sx, sy;
 		COUNT fighter_facing;
 		ELEMENT *FighterElementPtr;
-		
+
 		if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
 			(((PlayerControl[0] & COMPUTER_CONTROL) && ElementPtr->playerNr == 1) || 
 			((PlayerControl[1] & COMPUTER_CONTROL) && ElementPtr->playerNr == 0))))
@@ -576,8 +580,8 @@ spawn_fighters (ELEMENT *ElementPtr)
 
 		PutElement (hFighterElement);
 		LockElement (hFighterElement, &FighterElementPtr);
-		FighterElementPtr->hit_points = 1;
-		FighterElementPtr->mass_points = 0;
+		FighterElementPtr->hit_points = FIGHTER_HITS;
+		FighterElementPtr->mass_points = FIGHTER_MASS;
 		FighterElementPtr->thrust_wait = TRACK_THRESHOLD + 1;
 		FighterElementPtr->playerNr = ElementPtr->playerNr;
 		FighterElementPtr->state_flags = APPEARING | FINITE_LIFE
@@ -633,18 +637,16 @@ urquan_intelligence (ELEMENT *ShipPtr, E
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 
-	ObjectsOfConcern[ENEMY_SHIP_INDEX].MoveState = PURSUE;
-	
+	 ObjectsOfConcern[ENEMY_SHIP_INDEX].MoveState = PURSUE;
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_WEAPON_INDEX];
-	
 	if (lpEvalDesc->ObjectPtr
 			&& lpEvalDesc->MoveState == ENTICE
-			&& (!(lpEvalDesc->ObjectPtr->state_flags & CREW_OBJECT) || lpEvalDesc->which_turn <= 8)
+			&& (!(lpEvalDesc->ObjectPtr->state_flags & CREW_OBJECT)
+			|| lpEvalDesc->which_turn <= 8)
 			&& (!(lpEvalDesc->ObjectPtr->state_flags & FINITE_LIFE)
-				|| (lpEvalDesc->ObjectPtr->mass_points >= 4
-				&& lpEvalDesc->which_turn == 2
-				&& ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn > 16))
-		)
+			|| (lpEvalDesc->ObjectPtr->mass_points >= 4
+			&& lpEvalDesc->which_turn == 2
+			&& ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn > 16)))
 		lpEvalDesc->MoveState = PURSUE;
 
 	ship_intelligence (ShipPtr,
@@ -659,19 +661,19 @@ urquan_intelligence (ELEMENT *ShipPtr, E
 		if (StarShipPtr->special_counter == 0
 				&& lpEvalDesc->ObjectPtr
 				&& StarShipPtr->RaceDescPtr->ship_info.crew_level >
-					(StarShipPtr->RaceDescPtr->ship_info.max_crew >> 2)
+				(StarShipPtr->RaceDescPtr->ship_info.max_crew >> 2)
 				&& !(EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags
-					 & POINT_DEFENSE)
+				& POINT_DEFENSE)
 				&& (StarShipPtr->RaceDescPtr->characteristics.special_wait < 6
 				|| (MANEUVERABILITY (
 						&EnemyStarShipPtr->RaceDescPtr->cyborg_control
-						) <= RESOLUTION_COMPENSATED(SLOW_SHIP) // JMS_GFX
+						) <= RESOLUTION_COMPENSATED(SLOW_SHIP)
 				&& !(EnemyStarShipPtr->cur_status_flags & SHIP_BEYOND_MAX_SPEED))
 				|| (lpEvalDesc->which_turn <= 12
 				&& (StarShipPtr->ship_input_state & (LEFT | RIGHT))
 				&& StarShipPtr->RaceDescPtr->ship_info.energy_level >=
 				(BYTE)(StarShipPtr->RaceDescPtr->ship_info.max_energy >> 1)))
-				&& !OBJECT_CLOAKED (lpEvalDesc->ObjectPtr)) // JMS
+				&& !OBJECT_CLOAKED (lpEvalDesc->ObjectPtr))
 			StarShipPtr->ship_input_state |= SPECIAL;
 		else
 			StarShipPtr->ship_input_state &= ~SPECIAL;
@@ -703,29 +705,16 @@ urquan_postprocess (ELEMENT *ElementPtr)
 RACE_DESC*
 init_urquan (void)
 {
+	static RACE_DESC urquan_desc;
 	RACE_DESC *RaceDescPtr;
 
-	if (RESOLUTION_FACTOR == 0)
-	{
-		urquan_desc.postprocess_func = urquan_postprocess;
-		urquan_desc.init_weapon_func = initialize_fusion;
-		urquan_desc.cyborg_control.intelligence_func = urquan_intelligence;
-		RaceDescPtr = &urquan_desc;
-	}
-	else if (RESOLUTION_FACTOR == 1)
-	{
-		urquan_desc_2xres.postprocess_func = urquan_postprocess;
-		urquan_desc_2xres.init_weapon_func = initialize_fusion;
-		urquan_desc_2xres.cyborg_control.intelligence_func = urquan_intelligence;
-		RaceDescPtr = &urquan_desc_2xres;
-	}
-	else
-	{
-		urquan_desc_4xres.postprocess_func = urquan_postprocess;
-		urquan_desc_4xres.init_weapon_func = initialize_fusion;
-		urquan_desc_4xres.cyborg_control.intelligence_func = urquan_intelligence;
-		RaceDescPtr = &urquan_desc_4xres;
-	}
+	urquan_desc = (RESOLUTION_FACTOR == 0 ? urquan_desc1x : (RESOLUTION_FACTOR == 1 ? urquan_desc2x : urquan_desc4x));
+
+	urquan_desc.postprocess_func = urquan_postprocess;
+	urquan_desc.init_weapon_func = initialize_fusion;
+	urquan_desc.cyborg_control.intelligence_func = urquan_intelligence;
+
+	RaceDescPtr = &urquan_desc;
 
 	return (RaceDescPtr);
 }
diff -ruNp src.hd/uqm/ships/urquan/urquan.h src/uqm/ships/urquan/urquan.h
--- src.hd/uqm/ships/urquan/urquan.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/urquan/urquan.h	2017-12-29 00:57:53 -0800
@@ -17,7 +17,15 @@
 #ifndef URQUAN_H
 #define URQUAN_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_urquan (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* URQUAN_H */
 
diff -ruNp src.hd/uqm/ships/utwig/Makeinfo src/uqm/ships/utwig/Makeinfo
--- src.hd/uqm/ships/utwig/Makeinfo	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/utwig/Makeinfo	2017-12-29 00:57:53 -0800
@@ -1 +1,2 @@
 uqm_CFILES="utwig.c"
+uqm_HFILES="icode.h resinst.h utwig.h"
diff -ruNp src.hd/uqm/ships/utwig/icode.h src/uqm/ships/utwig/icode.h
--- src.hd/uqm/ships/utwig/icode.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/utwig/icode.h	2017-12-29 00:57:53 -0800
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define UTWIG_CODE "ship.utwig.code"
diff -ruNp src.hd/uqm/ships/utwig/resinst.h src/uqm/ships/utwig/resinst.h
--- src.hd/uqm/ships/utwig/resinst.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/utwig/resinst.h	2017-12-29 00:57:53 -0800
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define LANCE_BIG_MASK_PMAP_ANIM "ship.utwig.graphics.lance.large"
 #define LANCE_MED_MASK_PMAP_ANIM "ship.utwig.graphics.lance.medium"
 #define LANCE_SML_MASK_PMAP_ANIM "ship.utwig.graphics.lance.small"
@@ -6,9 +10,7 @@
 #define UTWIG_ICON_MASK_PMAP_ANIM "ship.utwig.icons"
 #define UTWIG_MED_MASK_PMAP_ANIM "ship.utwig.graphics.jugger.medium"
 #define UTWIG_MICON_MASK_PMAP_ANIM "ship.utwig.meleeicons"
-#define UTWIG_SML_MASK_PMAP_ANIM "ship.utwig.graphics.jugger.small"
 #define UTWIG_RACE_STRINGS "ship.utwig.text"
 #define UTWIG_SHIP_SOUNDS "ship.utwig.sounds"
+#define UTWIG_SML_MASK_PMAP_ANIM "ship.utwig.graphics.jugger.small"
 #define UTWIG_VICTORY_SONG "ship.utwig.ditty"
-
-#include "icode.h"
diff -ruNp src.hd/uqm/ships/utwig/utwig.c src/uqm/ships/utwig/utwig.c
--- src.hd/uqm/ships/utwig/utwig.c	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/utwig/utwig.c	2017-12-29 00:57:53 -0800
@@ -23,28 +23,47 @@
 #include "uqm/globdata.h"
 #include "libs/mathlib.h"
 
-
+// Core characteristics
 #define MAX_CREW 20
 #define MAX_ENERGY 20
 #define ENERGY_REGENERATION 0
-#define WEAPON_ENERGY_COST 0
-#define SPECIAL_ENERGY_COST 1
 #define ENERGY_WAIT 255
 #define MAX_THRUST 36
 #define THRUST_INCREMENT 6
-#define TURN_WAIT 1
 #define THRUST_WAIT 6
-#define WEAPON_WAIT 7
-#define SPECIAL_WAIT 12
-
+#define TURN_WAIT 1
 #define SHIP_MASS 8
+
+// Weapon
+#define WEAPON_ENERGY_COST 0
+#define WEAPON_WAIT 7
 #define UTWIG_OFFSET 9
-#define MISSILE_SPEED DISPLAY_TO_WORLD (30 << RESOLUTION_FACTOR)
+#define MISSILE_SPEED DISPLAY_TO_WORLD RES_SCALE(30)
 #define MISSILE_LIFE 10
+#define MISSILE_HITS 1
+#define MISSILE_DAMAGE 1
+#define MISSILE_OFFSET RES_SCALE(1)
+#define LAUNCH_XOFFS0 DISPLAY_TO_WORLD RES_SCALE(5)
+#define LAUNCH_YOFFS0 -DISPLAY_TO_WORLD RES_SCALE(18)
+#define LAUNCH_XOFFS1 DISPLAY_TO_WORLD RES_SCALE(13)
+#define LAUNCH_YOFFS1 -DISPLAY_TO_WORLD RES_SCALE(9)
+#define LAUNCH_XOFFS2 DISPLAY_TO_WORLD RES_SCALE(17)
+#define LAUNCH_YOFFS2 -DISPLAY_TO_WORLD RES_SCALE(4)
+
+// Shield
+#define SPECIAL_ENERGY_COST 1
+#define SPECIAL_WAIT 12
+
+// HD
+#define MAX_THRUST_2XRES 72
+#define THRUST_INCREMENT_2XRES 12
+#define MAX_THRUST_4XRES 144
+#define THRUST_INCREMENT_4XRES 24
 
-static RACE_DESC utwig_desc =
+static RACE_DESC utwig_desc1x =
 {
 	{ /* SHIP_INFO */
+		"jugger",
 		FIRES_FORE | POINT_DEFENSE | SHIELD_DEFENSE,
 		22, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -114,13 +133,10 @@ static RACE_DESC utwig_desc =
 };
 
 // JMS_GFX
-#define MAX_THRUST_2XRES 72
-#define THRUST_INCREMENT_2XRES 12
-
-// JMS_GFX
-static RACE_DESC utwig_desc_2xres =
+static RACE_DESC utwig_desc2x =
 {
 	{ /* SHIP_INFO */
+		"jugger",
 		FIRES_FORE | SHIELD_DEFENSE | LIGHT_POINT_DEFENSE,
 		22, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -190,13 +206,10 @@ static RACE_DESC utwig_desc_2xres =
 };
 
 // JMS_GFX
-#define MAX_THRUST_4XRES 144
-#define THRUST_INCREMENT_4XRES 24
-
-// JMS_GFX
-static RACE_DESC utwig_desc_4xres =
+static RACE_DESC utwig_desc4x =
 {
 	{ /* SHIP_INFO */
+		"jugger",
 		FIRES_FORE | SHIELD_DEFENSE | LIGHT_POINT_DEFENSE,
 		22, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -268,15 +281,6 @@ static RACE_DESC utwig_desc_4xres =
 static COUNT
 initialize_lance (ELEMENT *ShipPtr, HELEMENT WeaponArray[])
 {
-#define LAUNCH_XOFFS0 DISPLAY_TO_WORLD (5 << RESOLUTION_FACTOR) // JMS_GFX
-#define LAUNCH_YOFFS0 -DISPLAY_TO_WORLD (18 << RESOLUTION_FACTOR) // JMS_GFX
-#define LAUNCH_XOFFS1 DISPLAY_TO_WORLD (13 << RESOLUTION_FACTOR) // JMS_GFX
-#define LAUNCH_YOFFS1 -DISPLAY_TO_WORLD (9 << RESOLUTION_FACTOR) // JMS_GFX
-#define LAUNCH_XOFFS2 DISPLAY_TO_WORLD (17 << RESOLUTION_FACTOR) // JMS_GFX
-#define LAUNCH_YOFFS2 -DISPLAY_TO_WORLD (4 << RESOLUTION_FACTOR) // JMS_GFX
-#define MISSILE_HITS 1
-#define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET (1 << RESOLUTION_FACTOR) // JMS_GFX
 	COUNT i;
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
@@ -463,7 +467,8 @@ utwig_preprocess (ELEMENT *ElementPtr)
 	if (StarShipPtr->special_counter == 0)
 	{
 		// The shield is off.
-		SetPrimColor (lpPrim, BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1C, 0x00), 0x78));
+		SetPrimColor (lpPrim,
+				BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1C, 0x00), 0x78));
 		ElementPtr->colorCycleIndex = 0;
 		ElementPtr->life_span = NORMAL_LIFE;
 		SetPrimType (lpPrim, STAMP_PRIM);
@@ -515,29 +520,16 @@ utwig_preprocess (ELEMENT *ElementPtr)
 RACE_DESC*
 init_utwig (void)
 {
+	static RACE_DESC utwig_desc;
 	RACE_DESC *RaceDescPtr;
 
-	if (RESOLUTION_FACTOR == 0)
-	{
-		utwig_desc.preprocess_func = utwig_preprocess;
-		utwig_desc.init_weapon_func = initialize_lance;
-		utwig_desc.cyborg_control.intelligence_func = utwig_intelligence;
-		RaceDescPtr = &utwig_desc;
-	}
-	else if (RESOLUTION_FACTOR == 1)
-	{
-		utwig_desc_2xres.preprocess_func = utwig_preprocess;
-		utwig_desc_2xres.init_weapon_func = initialize_lance;
-		utwig_desc_2xres.cyborg_control.intelligence_func = utwig_intelligence;
-		RaceDescPtr = &utwig_desc_2xres;
-	}
-	else
-	{
-		utwig_desc_4xres.preprocess_func = utwig_preprocess;
-		utwig_desc_4xres.init_weapon_func = initialize_lance;
-		utwig_desc_4xres.cyborg_control.intelligence_func = utwig_intelligence;
-		RaceDescPtr = &utwig_desc_4xres;
-	}
+	utwig_desc = (RESOLUTION_FACTOR == 0 ? utwig_desc1x : (RESOLUTION_FACTOR == 1 ? utwig_desc2x : utwig_desc4x));
+
+	utwig_desc.preprocess_func = utwig_preprocess;
+	utwig_desc.init_weapon_func = initialize_lance;
+	utwig_desc.cyborg_control.intelligence_func = utwig_intelligence;
+
+	RaceDescPtr = &utwig_desc;
 
 	return (RaceDescPtr);
 }
diff -ruNp src.hd/uqm/ships/utwig/utwig.h src/uqm/ships/utwig/utwig.h
--- src.hd/uqm/ships/utwig/utwig.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/utwig/utwig.h	2017-12-29 00:57:53 -0800
@@ -17,7 +17,15 @@
 #ifndef UTWIG_H
 #define UTWIG_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_utwig (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* UTWIG_H */
 
diff -ruNp src.hd/uqm/ships/vux/Makeinfo src/uqm/ships/vux/Makeinfo
--- src.hd/uqm/ships/vux/Makeinfo	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/vux/Makeinfo	2017-12-29 00:57:53 -0800
@@ -1 +1,2 @@
 uqm_CFILES="vux.c"
+uqm_HFILES="icode.h resinst.h vux.h"
diff -ruNp src.hd/uqm/ships/vux/icode.h src/uqm/ships/vux/icode.h
--- src.hd/uqm/ships/vux/icode.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/vux/icode.h	2017-12-29 00:57:53 -0800
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define VUX_CODE "ship.vux.code"
diff -ruNp src.hd/uqm/ships/vux/resinst.h src/uqm/ships/vux/resinst.h
--- src.hd/uqm/ships/vux/resinst.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/vux/resinst.h	2017-12-29 00:57:53 -0800
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define LIMPETS_BIG_MASK_PMAP_ANIM "ship.vux.graphics.limpets.large"
 #define LIMPETS_MED_MASK_PMAP_ANIM "ship.vux.graphics.limpets.medium"
 #define LIMPETS_SML_MASK_PMAP_ANIM "ship.vux.graphics.limpets.small"
@@ -7,9 +11,7 @@
 #define VUX_ICON_MASK_PMAP_ANIM "ship.vux.icons"
 #define VUX_MED_MASK_PMAP_ANIM "ship.vux.graphics.intruder.medium"
 #define VUX_MICON_MASK_PMAP_ANIM "ship.vux.meleeicons"
-#define VUX_SML_MASK_PMAP_ANIM "ship.vux.graphics.intruder.small"
 #define VUX_RACE_STRINGS "ship.vux.text"
 #define VUX_SHIP_SOUNDS "ship.vux.sounds"
+#define VUX_SML_MASK_PMAP_ANIM "ship.vux.graphics.intruder.small"
 #define VUX_VICTORY_SONG "ship.vux.ditty"
-
-#include "icode.h"
diff -ruNp src.hd/uqm/ships/vux/vux.c src/uqm/ships/vux/vux.c
--- src.hd/uqm/ships/vux/vux.c	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/vux/vux.c	2017-12-29 00:57:53 -0800
@@ -23,30 +23,54 @@
 #include "uqm/globdata.h"
 #include "libs/mathlib.h"
 
-
+// Core characteristics
 #define MAX_CREW 20
 #define MAX_ENERGY 40
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 1
-#define SPECIAL_ENERGY_COST 2
 #define ENERGY_WAIT 8
 #define MAX_THRUST /* DISPLAY_TO_WORLD (5) */ 21
 #define THRUST_INCREMENT /* DISPLAY_TO_WORLD (2) */ 7
-#define TURN_WAIT 6
 #define THRUST_WAIT 4
+#define TURN_WAIT 6
+#define SHIP_MASS 6
+
+// Laser
+#define WEAPON_ENERGY_COST 1
 #define WEAPON_WAIT 0
+#define VUX_OFFSET RES_SCALE(12)
+#define LASER_BASE RES_SCALE(150)
+#define LASER_RANGE DISPLAY_TO_WORLD (LASER_BASE + VUX_OFFSET)
+
+// Limpet
+#define SPECIAL_ENERGY_COST 2
 #define SPECIAL_WAIT 7
+#define LIMPET_SPEED RES_SCALE(25)
+#define LIMPET_OFFSET RES_SCALE(8)
+#define LIMPET_LIFE 80
+#define LIMPET_HITS 1
+#define LIMPET_DAMAGE 0
+#define MIN_THRUST_INCREMENT DISPLAY_TO_WORLD RES_SCALE(1)
 
-#define SHIP_MASS 6
-#define WARP_OFFSET (46 << RESOLUTION_FACTOR) // JMS_GFX /* How far outside of laser-range ship can warp in */
-#define VUX_OFFSET (12 << RESOLUTION_FACTOR) // JMS_GFX
-#define LASER_BASE (150 << RESOLUTION_FACTOR) // JMS_GFX
-#define LASER_RANGE DISPLAY_TO_WORLD (LASER_BASE + VUX_OFFSET)
-#define MIN_THRUST_INCREMENT DISPLAY_TO_WORLD (1 << RESOLUTION_FACTOR) // JMS_GFX
+// Aggressive Entry
+#define WARP_OFFSET RES_SCALE(46)
+		/* How far outside of the laser range can the ship warp in. */
+#define MAXX_ENTRY_DIST DISPLAY_TO_WORLD ((LASER_BASE + VUX_OFFSET + WARP_OFFSET) << 1)
+#define MAXY_ENTRY_DIST DISPLAY_TO_WORLD ((LASER_BASE + VUX_OFFSET + WARP_OFFSET) << 1)
+		/* Originally, the warp distance was:
+		 * DISPLAY_TO_WORLD (SPACE_HEIGHT << 1)
+		 * where SPACE_HEIGHT = SCREEN_HEIGHT - (SAFE_Y * 2)
+		 * But in reality this should be relative to the laser-range. */
+
+// HD
+#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (5) */ 42
+#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (2) */ 14
+#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (5) */ 84
+#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (2) */ 28
 
-static RACE_DESC vux_desc =
+static RACE_DESC vux_desc1x =
 {
 	{ /* SHIP_INFO */
+		"intruder",
 		FIRES_FORE | SEEKING_SPECIAL | IMMEDIATE_WEAPON,
 		12, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -116,13 +140,10 @@ static RACE_DESC vux_desc =
 };
 
 // JMS_GFX
-#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (5) */ 42
-#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (2) */ 14
-
-// JMS_GFX
-static RACE_DESC vux_desc_2xres =
+static RACE_DESC vux_desc2x =
 {
 	{ /* SHIP_INFO */
+		"intruder",
 		FIRES_FORE | SEEKING_SPECIAL | IMMEDIATE_WEAPON,
 		12, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -192,13 +213,10 @@ static RACE_DESC vux_desc_2xres =
 };
 
 // JMS_GFX
-#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (5) */ 84
-#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (2) */ 28
-
-// JMS_GFX
-static RACE_DESC vux_desc_4xres =
+static RACE_DESC vux_desc4x =
 {
 	{ /* SHIP_INFO */
+		"intruder",
 		FIRES_FORE | SEEKING_SPECIAL | IMMEDIATE_WEAPON,
 		12, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -267,7 +285,6 @@ static RACE_DESC vux_desc_4xres =
 	0, /* CodeRef */
 };
 
-#define LIMPET_SPEED (25 << RESOLUTION_FACTOR) // JMS_GFX
 
 static void
 limpet_preprocess (ELEMENT *ElementPtr)
@@ -275,27 +292,26 @@ limpet_preprocess (ELEMENT *ElementPtr)
 	COUNT facing, orig_facing;
 	SIZE delta_facing;
 
-	facing = orig_facing = NORMALIZE_FACING (ANGLE_TO_FACING (GetVelocityTravelAngle (&ElementPtr->velocity)));
-	
+	facing = orig_facing = NORMALIZE_FACING (ANGLE_TO_FACING (
+			GetVelocityTravelAngle (&ElementPtr->velocity)
+			));
 	if ((delta_facing = TrackShip (ElementPtr, &facing)) > 0)
 	{
 		facing = orig_facing + delta_facing;
 		SetVelocityVector (&ElementPtr->velocity, LIMPET_SPEED, facing);
 	}
-	
-	ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->next.image.frame);
+	ElementPtr->next.image.frame =
+			 IncFrameIndex (ElementPtr->next.image.frame);
+
 	ElementPtr->state_flags |= CHANGING;
 }
 
 static void
-limpet_collision (ELEMENT *ElementPtr0, POINT *pPt0,
-		ELEMENT *ElementPtr1, POINT *pPt1)
-{
+limpet_collision (ELEMENT *ElementPtr0, POINT *pPt0, ELEMENT *ElementPtr1, POINT *pPt1) {
 	STAMP s;
 	STARSHIP *StarShipPtr;
 	RACE_DESC *RDPtr;
-	if (ElementPtr1->state_flags & PLAYER_SHIP)
-	{
+	if (ElementPtr1->state_flags & PLAYER_SHIP) {
 		GetElementStarShip (ElementPtr1, &StarShipPtr);
 		RDPtr = StarShipPtr->RaceDescPtr;
 		if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
@@ -307,7 +323,7 @@ limpet_collision (ELEMENT *ElementPtr0,
 			ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 2), ElementPtr1); // LIMPET_AFFIXES
 			s.frame = SetAbsFrameIndex (StarShipPtr->RaceDescPtr->ship_data.weapon[0], (COUNT)TFB_Random ());
 			ModifySilhouette (ElementPtr1, &s, MODIFY_IMAGE);
-		} else {			
+		} else {
 			if (++RDPtr->characteristics.turn_wait == 0)
 				--RDPtr->characteristics.turn_wait;
 			if (++RDPtr->characteristics.thrust_wait == 0)
@@ -316,15 +332,11 @@ limpet_collision (ELEMENT *ElementPtr0,
 				RDPtr->characteristics.max_thrust = RDPtr->characteristics.thrust_increment << 1;
 			} else {
 				COUNT num_thrusts;
-
-				num_thrusts = RDPtr->characteristics.max_thrust /
-						RDPtr->characteristics.thrust_increment;
-				RDPtr->characteristics.thrust_increment -= 1 << RESOLUTION_FACTOR; // JMS_GFX
-				RDPtr->characteristics.max_thrust =
-						RDPtr->characteristics.thrust_increment * num_thrusts;
+				num_thrusts = RDPtr->characteristics.max_thrust / RDPtr->characteristics.thrust_increment;
+				RDPtr->characteristics.thrust_increment -= RES_SCALE(1);
+				RDPtr->characteristics.max_thrust = RDPtr->characteristics.thrust_increment * num_thrusts;
 			}
 			RDPtr->cyborg_control.ManeuverabilityIndex = 0;
-
 			GetElementStarShip (ElementPtr0, &StarShipPtr);
 			ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 2), ElementPtr1); // LIMPET_AFFIXES
 			s.frame = SetAbsFrameIndex (StarShipPtr->RaceDescPtr->ship_data.weapon[0], (COUNT)TFB_Random ());
@@ -343,10 +355,6 @@ limpet_collision (ELEMENT *ElementPtr0,
 static void
 spawn_limpets (ELEMENT *ElementPtr)
 {
-#define LIMPET_OFFSET (8 << RESOLUTION_FACTOR) // JMS_GFX
-#define LIMPET_LIFE 80
-#define LIMPET_HITS 1
-#define LIMPET_DAMAGE 0
 	HELEMENT Limpet;
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
@@ -473,27 +481,18 @@ vux_preprocess (ELEMENT *ElementPtr)
 		{
 			ELEMENT *OtherShipPtr;
 			SDWORD SA_MATRA_EXTRA_DIST = 0;
-
 			LockElement (ElementPtr->hTarget, &OtherShipPtr);
-            // JMS: Not REALLY necessary as VUX can ordinarily never be
-            // played against Sa-Matra. But handy in debugging as a single
-            // VUX limpet incapacitates Sa-Matra completely.
-            if (LOBYTE (GLOBAL (CurrentActivity)) == IN_LAST_BATTLE) {
-                SA_MATRA_EXTRA_DIST += 1000 << RESOLUTION_FACTOR;
-            }
 
-			do
-			{
-				// Originally, the warp distance was:
-				// DISPLAY_TO_WORLD (SPACE_HEIGHT << 1)
-				// where SPACE_HEIGHT = SCREEN_HEIGHT - (SAFE_Y * 2)
-				// But in reality this should be relative to the laser-range
-#define MAXX_ENTRY_DIST DISPLAY_TO_WORLD ((LASER_BASE + VUX_OFFSET + WARP_OFFSET) << 1)
-#define MAXY_ENTRY_DIST DISPLAY_TO_WORLD ((LASER_BASE + VUX_OFFSET + WARP_OFFSET) << 1)
-                // JMS_GFX: Circumventing overflows by using temp variables
-                // instead of subtracting straight from the POINT sized
-                // ShipImagePtr->current.location.
+			// JMS: Not REALLY necessary as VUX can ordinarily never be played against Sa-Matra. 
+            // But handy in debugging as a single VUX limpet incapacitates Sa-Matra completely.
+            if (LOBYTE (GLOBAL (CurrentActivity)) == IN_LAST_BATTLE) {
+				SA_MATRA_EXTRA_DIST += RES_SCALE(1000);
+			}
+			do {
+                // JMS_GFX: Circumventing overflows by using temp variables instead of
+                // subtracting straight from the POINT sized ShipImagePtr->current.location.
 				SDWORD dx, dy;
+
 				SDWORD temp_x =
 						((SDWORD)OtherShipPtr->current.location.x -
 						(MAXX_ENTRY_DIST >> 1)) +
@@ -502,23 +501,16 @@ vux_preprocess (ELEMENT *ElementPtr)
 						((SDWORD)OtherShipPtr->current.location.y -
 						(MAXY_ENTRY_DIST >> 1)) +
 						((COUNT)TFB_Random () % MAXY_ENTRY_DIST);
-                
-                temp_x += temp_x > 0 ? SA_MATRA_EXTRA_DIST : -SA_MATRA_EXTRA_DIST;
-                temp_y += temp_y > 0 ? SA_MATRA_EXTRA_DIST : -SA_MATRA_EXTRA_DIST;
+				temp_x += temp_x > 0 ? SA_MATRA_EXTRA_DIST : -SA_MATRA_EXTRA_DIST;
+				temp_y += temp_y > 0 ? SA_MATRA_EXTRA_DIST : -SA_MATRA_EXTRA_DIST;
                 
 				dx = OtherShipPtr->current.location.x - temp_x;
 				dy = OtherShipPtr->current.location.y - temp_y;
-				facing = NORMALIZE_FACING (
-						ANGLE_TO_FACING (ARCTAN (dx, dy))
-						);
-				ElementPtr->current.image.frame =
-						SetAbsFrameIndex (ElementPtr->current.image.frame,
-						facing);
-
-				ElementPtr->current.location.x =
-						WRAP_X (DISPLAY_ALIGN (temp_x));
-				ElementPtr->current.location.y =
-						WRAP_Y (DISPLAY_ALIGN (temp_y));
+				facing = NORMALIZE_FACING ( ANGLE_TO_FACING (ARCTAN (dx, dy)) );
+				ElementPtr->current.image.frame = SetAbsFrameIndex (ElementPtr->current.image.frame, facing);
+
+				ElementPtr->current.location.x = WRAP_X (DISPLAY_ALIGN (temp_x));
+				ElementPtr->current.location.y = WRAP_Y (DISPLAY_ALIGN (temp_y));
 			} while (CalculateGravity (ElementPtr)
 					|| TimeSpaceMatterConflict (ElementPtr));
 
@@ -540,32 +532,17 @@ vux_preprocess (ELEMENT *ElementPtr)
 RACE_DESC*
 init_vux (void)
 {
+	static RACE_DESC vux_desc;
 	RACE_DESC *RaceDescPtr;
 
-	if (RESOLUTION_FACTOR == 0)
-	{
-		vux_desc.preprocess_func = vux_preprocess;
-		vux_desc.postprocess_func = vux_postprocess;
-		vux_desc.init_weapon_func = initialize_horrific_laser;
-		vux_desc.cyborg_control.intelligence_func = vux_intelligence;
-		RaceDescPtr = &vux_desc;
-	}
-	else if (RESOLUTION_FACTOR == 1)
-	{
-		vux_desc_2xres.preprocess_func = vux_preprocess;
-		vux_desc_2xres.postprocess_func = vux_postprocess;
-		vux_desc_2xres.init_weapon_func = initialize_horrific_laser;
-		vux_desc_2xres.cyborg_control.intelligence_func = vux_intelligence;
-		RaceDescPtr = &vux_desc_2xres;
-	}
-	else
-	{
-		vux_desc_4xres.preprocess_func = vux_preprocess;
-		vux_desc_4xres.postprocess_func = vux_postprocess;
-		vux_desc_4xres.init_weapon_func = initialize_horrific_laser;
-		vux_desc_4xres.cyborg_control.intelligence_func = vux_intelligence;
-		RaceDescPtr = &vux_desc_4xres;
-	}
+	vux_desc = (RESOLUTION_FACTOR == 0 ? vux_desc1x : (RESOLUTION_FACTOR == 1 ? vux_desc2x : vux_desc4x));
+
+	vux_desc.preprocess_func = vux_preprocess;
+	vux_desc.postprocess_func = vux_postprocess;
+	vux_desc.init_weapon_func = initialize_horrific_laser;
+	vux_desc.cyborg_control.intelligence_func = vux_intelligence;
+
+	RaceDescPtr = &vux_desc;
 
 	return (RaceDescPtr);
 }
diff -ruNp src.hd/uqm/ships/vux/vux.h src/uqm/ships/vux/vux.h
--- src.hd/uqm/ships/vux/vux.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/vux/vux.h	2017-12-29 00:57:53 -0800
@@ -17,7 +17,15 @@
 #ifndef VUX_H
 #define VUX_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_vux (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* VUX_H */
 
diff -ruNp src.hd/uqm/ships/yehat/Makeinfo src/uqm/ships/yehat/Makeinfo
--- src.hd/uqm/ships/yehat/Makeinfo	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/yehat/Makeinfo	2017-12-29 00:57:53 -0800
@@ -1 +1,2 @@
 uqm_CFILES="yehat.c"
+uqm_HFILES="icode.h resinst.h yehat.h"
diff -ruNp src.hd/uqm/ships/yehat/icode.h src/uqm/ships/yehat/icode.h
--- src.hd/uqm/ships/yehat/icode.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/yehat/icode.h	2017-12-29 00:57:53 -0800
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define YEHAT_CODE "ship.yehat.code"
diff -ruNp src.hd/uqm/ships/yehat/resinst.h src/uqm/ships/yehat/resinst.h
--- src.hd/uqm/ships/yehat/resinst.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/yehat/resinst.h	2017-12-29 00:57:53 -0800
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SHIELD_BIG_MASK_ANIM "ship.yehat.graphics.shield.large"
 #define SHIELD_MED_MASK_ANIM "ship.yehat.graphics.shield.medium"
 #define SHIELD_SML_MASK_ANIM "ship.yehat.graphics.shield.small"
@@ -9,9 +13,7 @@
 #define YEHAT_ICON_MASK_PMAP_ANIM "ship.yehat.icons"
 #define YEHAT_MED_MASK_PMAP_ANIM "ship.yehat.graphics.terminator.medium"
 #define YEHAT_MICON_MASK_PMAP_ANIM "ship.yehat.meleeicons"
-#define YEHAT_SML_MASK_PMAP_ANIM "ship.yehat.graphics.terminator.small"
 #define YEHAT_RACE_STRINGS "ship.yehat.text"
 #define YEHAT_SHIP_SOUNDS "ship.yehat.sounds"
+#define YEHAT_SML_MASK_PMAP_ANIM "ship.yehat.graphics.terminator.small"
 #define YEHAT_VICTORY_SONG "ship.yehat.ditty"
-
-#include "icode.h"
diff -ruNp src.hd/uqm/ships/yehat/yehat.c src/uqm/ships/yehat/yehat.c
--- src.hd/uqm/ships/yehat/yehat.c	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/yehat/yehat.c	2017-12-29 00:57:53 -0800
@@ -22,27 +22,45 @@
 
 #include "libs/mathlib.h"
 
-
+// Core characteristics
 #define MAX_CREW 20
 #define MAX_ENERGY 10
 #define ENERGY_REGENERATION 2
-#define WEAPON_ENERGY_COST 1
-#define SPECIAL_ENERGY_COST 3
 #define ENERGY_WAIT 6
 #define MAX_THRUST 30
 #define THRUST_INCREMENT 6
-#define TURN_WAIT 2
 #define THRUST_WAIT 2
-#define WEAPON_WAIT 0
-#define SPECIAL_WAIT 2
-
+#define TURN_WAIT 2
 #define SHIP_MASS 3
+
+// Twin Pulse Cannon
+#define WEAPON_ENERGY_COST 1
+#define WEAPON_WAIT 0
+#define YEHAT_OFFSET RES_SCALE(16)
+#define LAUNCH_OFFS DISPLAY_TO_WORLD RES_SCALE(8)
 #define MISSILE_SPEED DISPLAY_TO_WORLD (20)
 #define MISSILE_LIFE 10
+#define MISSILE_HITS 1
+#define MISSILE_DAMAGE 1
+#define MISSILE_OFFSET RES_SCALE(1)
+
+// Force Shield
+#define SPECIAL_ENERGY_COST 3
+#define SPECIAL_WAIT 2
+#define SHIELD_LIFE 10
 
-static RACE_DESC yehat_desc =
+// HD
+#define MAX_THRUST_2XRES 60
+#define THRUST_INCREMENT_2XRES 12
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (40)
+#define MAX_THRUST_4XRES 120
+#define THRUST_INCREMENT_4XRES 24
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (80)
+
+static RACE_DESC yehat_desc1x =
 {
 	{ /* SHIP_INFO */
+		"terminator",
 		FIRES_FORE | SHIELD_DEFENSE,
 		23, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -112,14 +130,10 @@ static RACE_DESC yehat_desc =
 };
 
 // JMS_GFX
-#define MAX_THRUST_2XRES 60
-#define THRUST_INCREMENT_2XRES 12
-#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (40)
-
-// JMS_GFX
-static RACE_DESC yehat_desc_2xres =
+static RACE_DESC yehat_desc2x =
 {
 	{ /* SHIP_INFO */
+		"terminator",
 		FIRES_FORE | SHIELD_DEFENSE,
 		23, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -189,14 +203,10 @@ static RACE_DESC yehat_desc_2xres =
 };
 
 // JMS_GFX
-#define MAX_THRUST_4XRES 120
-#define THRUST_INCREMENT_4XRES 24
-#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (80)
-
-// JMS_GFX
-static RACE_DESC yehat_desc_4xres =
+static RACE_DESC yehat_desc4x =
 {
 	{ /* SHIP_INFO */
+		"terminator",
 		FIRES_FORE | SHIELD_DEFENSE,
 		23, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -268,11 +278,6 @@ static RACE_DESC yehat_desc_4xres =
 static COUNT
 initialize_standard_missiles (ELEMENT *ShipPtr, HELEMENT MissileArray[])
 {
-#define YEHAT_OFFSET (16 << RESOLUTION_FACTOR) // JMS_GFX
-#define LAUNCH_OFFS DISPLAY_TO_WORLD (8 << RESOLUTION_FACTOR) // JMS_GFX
-#define MISSILE_HITS 1
-#define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET (1 << RESOLUTION_FACTOR) // JMS_GFX
 	SDWORD offs_x, offs_y;
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
@@ -283,7 +288,7 @@ initialize_standard_missiles (ELEMENT *S
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = YEHAT_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
+	MissileBlock.speed = RES_SCALE(MISSILE_SPEED);
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -305,7 +310,8 @@ initialize_standard_missiles (ELEMENT *S
 }
 
 static void
-yehat_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern, COUNT ConcernCounter)
+yehat_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
+		COUNT ConcernCounter)
 {
 	SIZE ShieldStatus;
 	STARSHIP *StarShipPtr;
@@ -467,7 +473,10 @@ yehat_preprocess (ELEMENT *ElementPtr)
 						== StarShipPtr->RaceDescPtr->ship_data.special))
 		{
 #ifdef NEVER
-			SetPrimType (&(GLOBAL (DisplayArray))[ElementPtr->PrimIndex], STAMP_PRIM);
+			SetPrimType (
+					&(GLOBAL (DisplayArray))[ElementPtr->PrimIndex],
+					STAMP_PRIM
+					);
 #endif /* NEVER */
 
 			ElementPtr->next.image.farray = StarShipPtr->RaceDescPtr->ship_data.ship;
@@ -484,7 +493,6 @@ yehat_preprocess (ELEMENT *ElementPtr)
 				DeltaEnergy (ElementPtr, -SPECIAL_ENERGY_COST); /* so text will flash */
 			else
 			{
-#define SHIELD_LIFE 10
 				ElementPtr->life_span = SHIELD_LIFE + NORMAL_LIFE;
 
 				ElementPtr->next.image.farray = StarShipPtr->RaceDescPtr->ship_data.special;
@@ -503,32 +511,17 @@ yehat_preprocess (ELEMENT *ElementPtr)
 RACE_DESC*
 init_yehat (void)
 {
+	static RACE_DESC yehat_desc;
 	RACE_DESC *RaceDescPtr;
 
-	if (RESOLUTION_FACTOR == 0)
-	{
-		yehat_desc.preprocess_func = yehat_preprocess;
-		yehat_desc.postprocess_func = yehat_postprocess;
-		yehat_desc.init_weapon_func = initialize_standard_missiles;
-		yehat_desc.cyborg_control.intelligence_func = yehat_intelligence;
-		RaceDescPtr = &yehat_desc;
-	}
-	else if (RESOLUTION_FACTOR == 1)
-	{
-		yehat_desc_2xres.preprocess_func = yehat_preprocess;
-		yehat_desc_2xres.postprocess_func = yehat_postprocess;
-		yehat_desc_2xres.init_weapon_func = initialize_standard_missiles;
-		yehat_desc_2xres.cyborg_control.intelligence_func = yehat_intelligence;
-		RaceDescPtr = &yehat_desc_2xres;
-	}
-	else
-	{
-		yehat_desc_4xres.preprocess_func = yehat_preprocess;
-		yehat_desc_4xres.postprocess_func = yehat_postprocess;
-		yehat_desc_4xres.init_weapon_func = initialize_standard_missiles;
-		yehat_desc_4xres.cyborg_control.intelligence_func = yehat_intelligence;
-		RaceDescPtr = &yehat_desc_4xres;
-	}
+	yehat_desc = (RESOLUTION_FACTOR == 0 ? yehat_desc1x : (RESOLUTION_FACTOR == 1 ? yehat_desc2x : yehat_desc4x));
+
+	yehat_desc.preprocess_func = yehat_preprocess;
+	yehat_desc.postprocess_func = yehat_postprocess;
+	yehat_desc.init_weapon_func = initialize_standard_missiles;
+	yehat_desc.cyborg_control.intelligence_func = yehat_intelligence;
+
+	RaceDescPtr = &yehat_desc;
 
 	return (RaceDescPtr);
 }
diff -ruNp src.hd/uqm/ships/yehat/yehat.h src/uqm/ships/yehat/yehat.h
--- src.hd/uqm/ships/yehat/yehat.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/yehat/yehat.h	2017-12-29 00:57:53 -0800
@@ -17,7 +17,15 @@
 #ifndef YEHAT_H
 #define YEHAT_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_yehat (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* YEHAT_H */
 
diff -ruNp src.hd/uqm/ships/zoqfot/Makeinfo src/uqm/ships/zoqfot/Makeinfo
--- src.hd/uqm/ships/zoqfot/Makeinfo	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/zoqfot/Makeinfo	2017-12-29 00:57:53 -0800
@@ -1 +1,2 @@
 uqm_CFILES="zoqfot.c"
+uqm_HFILES="icode.h resinst.h zoqfot.h"
diff -ruNp src.hd/uqm/ships/zoqfot/icode.h src/uqm/ships/zoqfot/icode.h
--- src.hd/uqm/ships/zoqfot/icode.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/zoqfot/icode.h	2017-12-29 00:57:53 -0800
@@ -1 +1,5 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define ZOQFOTPIK_CODE "ship.zoqfotpik.code"
diff -ruNp src.hd/uqm/ships/zoqfot/resinst.h src/uqm/ships/zoqfot/resinst.h
--- src.hd/uqm/ships/zoqfot/resinst.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/zoqfot/resinst.h	2017-12-29 00:57:53 -0800
@@ -1,3 +1,7 @@
+/* This file was auto-generated by the gen_resfiles utility and
+   should not be edited directly.  Modify the master resource list
+   instead and regenerate. */
+
 #define SPIT_BIG_MASK_PMAP_ANIM "ship.zoqfotpik.graphics.spit.large"
 #define SPIT_MED_MASK_PMAP_ANIM "ship.zoqfotpik.graphics.spit.medium"
 #define SPIT_SML_MASK_PMAP_ANIM "ship.zoqfotpik.graphics.spit.small"
@@ -9,9 +13,7 @@
 #define ZOQFOTPIK_ICON_MASK_PMAP_ANIM "ship.zoqfotpik.icons"
 #define ZOQFOTPIK_MED_MASK_PMAP_ANIM "ship.zoqfotpik.graphics.stinger.medium"
 #define ZOQFOTPIK_MICON_MASK_PMAP_ANIM "ship.zoqfotpik.meleeicons"
-#define ZOQFOTPIK_SML_MASK_PMAP_ANIM "ship.zoqfotpik.graphics.stinger.small"
 #define ZOQFOTPIK_RACE_STRINGS "ship.zoqfotpik.text"
 #define ZOQFOTPIK_SHIP_SOUNDS "ship.zoqfotpik.sounds"
+#define ZOQFOTPIK_SML_MASK_PMAP_ANIM "ship.zoqfotpik.graphics.stinger.small"
 #define ZOQFOTPIK_VICTORY_SONG "ship.zoqfotpik.ditty"
-
-#include "icode.h"
diff -ruNp src.hd/uqm/ships/zoqfot/zoqfot.c src/uqm/ships/zoqfot/zoqfot.c
--- src.hd/uqm/ships/zoqfot/zoqfot.c	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/zoqfot/zoqfot.c	2017-12-29 00:57:53 -0800
@@ -22,28 +22,54 @@
 
 #include "libs/mathlib.h"
 
-
+// Core characteristics
 #define MAX_CREW 10
 #define MAX_ENERGY 10
 #define ENERGY_REGENERATION 1
-#define WEAPON_ENERGY_COST 1
-#define SPECIAL_ENERGY_COST (MAX_ENERGY * 3 / 4)
 #define ENERGY_WAIT 4
 #define MAX_THRUST 40
 #define THRUST_INCREMENT 10
-#define TURN_WAIT 1
 #define THRUST_WAIT 0
-#define WEAPON_WAIT 0
-#define SPECIAL_WAIT 6
-
+#define TURN_WAIT 1
 #define SHIP_MASS 5
+
+// Main weapon
+#define WEAPON_ENERGY_COST 1
+#define WEAPON_WAIT 0
+#define ZOQFOTPIK_OFFSET RES_SCALE(13)
+#define MISSILE_OFFSET 0
 #define MISSILE_SPEED DISPLAY_TO_WORLD (10)
+		/* Used by the cyborg only. */
 #define MISSILE_LIFE 10
 #define MISSILE_RANGE (MISSILE_SPEED * MISSILE_LIFE)
+#define MISSILE_DAMAGE 1
+#define MISSILE_HITS 1
+#define SPIT_WAIT 2
+		/* Controls the main weapon color change animation's speed.
+		 * The animation advances one frame every SPIT_WAIT frames. */
+
+// Tongue
+#define SPECIAL_ENERGY_COST (MAX_ENERGY * 3 / 4)
+#define SPECIAL_WAIT 6
+#define TONGUE_SPEED 0
+#define TONGUE_HITS 1
+#define TONGUE_DAMAGE 12
+#define TONGUE_OFFSET RES_SCALE(4)
+
+// HD
+#define MAX_THRUST_2XRES 80
+#define THRUST_INCREMENT_2XRES 20
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (20)
+#define MISSILE_RANGE_2XRES (MISSILE_SPEED_2XRES * MISSILE_LIFE)
+#define MAX_THRUST_4XRES 160
+#define THRUST_INCREMENT_4XRES 40
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (40)
+#define MISSILE_RANGE_4XRES (MISSILE_SPEED_4XRES * MISSILE_LIFE)
 
-static RACE_DESC zoqfotpik_desc =
+static RACE_DESC zoqfotpik_desc1x =
 {
 	{ /* SHIP_INFO */
+		"stinger",
 		FIRES_FORE,
 		6, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -113,15 +139,10 @@ static RACE_DESC zoqfotpik_desc =
 };
 
 // JMS_GFX
-#define MAX_THRUST_2XRES 80
-#define THRUST_INCREMENT_2XRES 20
-#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (20)
-#define MISSILE_RANGE_2XRES (MISSILE_SPEED_2XRES * MISSILE_LIFE)
-
-// JMS_GFX
-static RACE_DESC zoqfotpik_desc_2xres =
+static RACE_DESC zoqfotpik_desc2x =
 {
 	{ /* SHIP_INFO */
+		"stinger",
 		FIRES_FORE,
 		6, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -191,15 +212,10 @@ static RACE_DESC zoqfotpik_desc_2xres =
 };
 
 // JMS_GFX
-#define MAX_THRUST_4XRES 160
-#define THRUST_INCREMENT_4XRES 40
-#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (40)
-#define MISSILE_RANGE_4XRES (MISSILE_SPEED_4XRES * MISSILE_LIFE)
-
-// JMS_GFX
-static RACE_DESC zoqfotpik_desc_4xres =
+static RACE_DESC zoqfotpik_desc4x =
 {
 	{ /* SHIP_INFO */
+		"stinger",
 		FIRES_FORE,
 		6, /* Super Melee cost */
 		MAX_CREW, MAX_CREW,
@@ -268,28 +284,29 @@ static RACE_DESC zoqfotpik_desc_4xres =
 	0, /* CodeRef */
 };
 
-#define ZOQFOTPIK_OFFSET (13 << RESOLUTION_FACTOR) // JMS_GFX
-#define SPIT_WAIT 2
-
 static void
 spit_preprocess (ELEMENT *ElementPtr)
 {
+	/* turn_wait is abused here to control the animation speed. */
 	if (ElementPtr->turn_wait > 0)
 		--ElementPtr->turn_wait;
 	else
 	{
 		COUNT index, angle, speed;
 
-		ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->next.image.frame);
+		ElementPtr->next.image.frame =
+				IncFrameIndex (ElementPtr->next.image.frame);
 		angle = GetVelocityTravelAngle (&ElementPtr->velocity);
-		
 		if ((index = GetFrameIndex (ElementPtr->next.image.frame)) == 1)
 			angle = angle + (((COUNT)TFB_Random () % 3) - 1);
 
-		speed = WORLD_TO_VELOCITY (DISPLAY_TO_WORLD ((GetFrameCount (ElementPtr->next.image.frame) - index) << RESOLUTION_FACTOR) << 1); // JMS_GFX
-		
-		SetVelocityComponents (&ElementPtr->velocity, (SIZE)COSINE (angle, speed), (SIZE)SINE (angle, speed));
+		speed = WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (
+				(GetFrameCount (ElementPtr->next.image.frame) << RESOLUTION_FACTOR )- index) << 1);
+		SetVelocityComponents (&ElementPtr->velocity,
+				(SIZE)COSINE (angle, speed),
+				(SIZE)SINE (angle, speed));
 
+		/* turn_wait is abused here to control the animation speed. */
 		ElementPtr->turn_wait = SPIT_WAIT;
 		ElementPtr->state_flags |= CHANGING;
 	}
@@ -298,9 +315,6 @@ spit_preprocess (ELEMENT *ElementPtr)
 static COUNT
 initialize_spit (ELEMENT *ShipPtr, HELEMENT SpitArray[])
 {
-#define MISSILE_DAMAGE 1
-#define MISSILE_HITS 1
-#define MISSILE_OFFSET 0
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -313,7 +327,8 @@ initialize_spit (ELEMENT *ShipPtr, HELEM
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = ZOQFOTPIK_OFFSET;
-	MissileBlock.speed = DISPLAY_TO_WORLD ((GetFrameCount (StarShipPtr->RaceDescPtr->ship_data.weapon[0])) << RESOLUTION_FACTOR) << 1; // JMS_GFX
+	MissileBlock.speed = DISPLAY_TO_WORLD (
+			(GetFrameCount (StarShipPtr->RaceDescPtr->ship_data.weapon[0])) << RESOLUTION_FACTOR) << 1;
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -340,7 +355,8 @@ tongue_collision (ELEMENT *ElementPtr0,
 	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr0, &StarShipPtr);
-	if (StarShipPtr->special_counter == StarShipPtr->RaceDescPtr->characteristics.special_wait)
+	if (StarShipPtr->special_counter ==
+			StarShipPtr->RaceDescPtr->characteristics.special_wait)
 		weapon_collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
 
 	StarShipPtr->special_counter -= ElementPtr0->turn_wait;
@@ -351,10 +367,6 @@ tongue_collision (ELEMENT *ElementPtr0,
 static void
 spawn_tongue (ELEMENT *ElementPtr)
 {
-#define TONGUE_SPEED 0
-#define TONGUE_HITS 1
-#define TONGUE_DAMAGE 12
-#define TONGUE_OFFSET (4 << RESOLUTION_FACTOR) // JMS_GFX
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK TongueBlock;
 	HELEMENT Tongue;
@@ -474,7 +486,7 @@ zoqfotpik_intelligence (ELEMENT *ShipPtr
 #endif /* NEVER */
 						))
 						&& ship_weapons (ShipPtr,
-						ObjectsOfConcern->ObjectPtr, DISPLAY_TO_WORLD (20 << RESOLUTION_FACTOR))) // JMS_GFX
+						ObjectsOfConcern->ObjectPtr, DISPLAY_TO_WORLD (RES_SCALE(20))))
 				{
 					StarShipPtr->ship_input_state |= WEAPON;
 					break;
@@ -498,7 +510,8 @@ zoqfotpik_postprocess (ELEMENT *ElementP
 					/* STICK_OUT_TONGUE */
 				StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 1), ElementPtr);
 
-		StarShipPtr->special_counter = StarShipPtr->RaceDescPtr->characteristics.special_wait;
+		StarShipPtr->special_counter =
+				StarShipPtr->RaceDescPtr->characteristics.special_wait;
 	}
 
 	if (StarShipPtr->special_counter)
@@ -508,29 +521,16 @@ zoqfotpik_postprocess (ELEMENT *ElementP
 RACE_DESC*
 init_zoqfotpik (void)
 {
+	static RACE_DESC zoqfotpik_desc;
 	RACE_DESC *RaceDescPtr;
 
-	if (RESOLUTION_FACTOR == 0)
-	{
-		zoqfotpik_desc.postprocess_func = zoqfotpik_postprocess;
-		zoqfotpik_desc.init_weapon_func = initialize_spit;
-		zoqfotpik_desc.cyborg_control.intelligence_func = zoqfotpik_intelligence;
-		RaceDescPtr = &zoqfotpik_desc;
-	}
-	else if (RESOLUTION_FACTOR == 1)
-	{
-		zoqfotpik_desc_2xres.postprocess_func = zoqfotpik_postprocess;
-		zoqfotpik_desc_2xres.init_weapon_func = initialize_spit;
-		zoqfotpik_desc_2xres.cyborg_control.intelligence_func = zoqfotpik_intelligence;
-		RaceDescPtr = &zoqfotpik_desc_2xres;
-	}
-	else
-	{
-		zoqfotpik_desc_4xres.postprocess_func = zoqfotpik_postprocess;
-		zoqfotpik_desc_4xres.init_weapon_func = initialize_spit;
-		zoqfotpik_desc_4xres.cyborg_control.intelligence_func = zoqfotpik_intelligence;
-		RaceDescPtr = &zoqfotpik_desc_4xres;
-	}
+	zoqfotpik_desc = (RESOLUTION_FACTOR == 0 ? zoqfotpik_desc1x : (RESOLUTION_FACTOR == 1 ? zoqfotpik_desc2x : zoqfotpik_desc4x));
+
+	zoqfotpik_desc.postprocess_func = zoqfotpik_postprocess;
+	zoqfotpik_desc.init_weapon_func = initialize_spit;
+	zoqfotpik_desc.cyborg_control.intelligence_func = zoqfotpik_intelligence;
+
+	RaceDescPtr = &zoqfotpik_desc;
 
 	return (RaceDescPtr);
 }
diff -ruNp src.hd/uqm/ships/zoqfot/zoqfot.h src/uqm/ships/zoqfot/zoqfot.h
--- src.hd/uqm/ships/zoqfot/zoqfot.h	2017-12-29 02:25:54 -0800
+++ src/uqm/ships/zoqfot/zoqfot.h	2017-12-29 00:57:53 -0800
@@ -17,7 +17,15 @@
 #ifndef ZOQFOT_H
 #define ZOQFOT_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 RACE_DESC *init_zoqfotpik (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* ZOQFOT_H */
 
diff -ruNp src.hd/uqm/shipstat.c src/uqm/shipstat.c
--- src.hd/uqm/shipstat.c	2017-12-29 02:25:54 -0800
+++ src/uqm/shipstat.c	2017-12-29 00:57:53 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "colors.h"
 #include "globdata.h"
 #include "options.h"
@@ -32,7 +30,6 @@ DrawCrewFuelString (COORD y, SIZE state)
 	STAMP Stamp;
 
 	Stamp.origin.y = y + GAUGE_YOFFS + STARCON_TEXT_HEIGHT - RES_CASE(0,6,12);
-	
 	if (state == 0)
 	{
 		Stamp.origin.x = CREW_XOFFS + (STAT_WIDTH >> 1) + RES_STAT_SCALE(6) - RES_CASE(0,8,8); // JMS_GFX
@@ -42,14 +39,12 @@ DrawCrewFuelString (COORD y, SIZE state)
 			Stamp.frame = SetAbsFrameIndex (StatusFrame, 0);
 		DrawStamp (&Stamp);
 	}
-	
-	Stamp.origin.x = ENERGY_XOFFS + (STAT_WIDTH >> 1) - RES_STAT_SCALE(5) + RES_CASE(0,10,10); // JMS_GFX
 
+	Stamp.origin.x = ENERGY_XOFFS + (STAT_WIDTH >> 1) - RES_STAT_SCALE(5) + RES_CASE(0,10,10); // JMS_GFX
 	if (optWhichMenu == OPT_PC)
 		Stamp.frame = SetAbsFrameIndex (StatusFrame, 5);
 	else
 		Stamp.frame = SetAbsFrameIndex (StatusFrame, 1);
-	
 	if (state >= 0)
 		DrawStamp (&Stamp);
 	else
@@ -89,8 +84,9 @@ void
 ClearShipStatus (COORD y, COORD w, BOOLEAN inMeleeMenu)
 {
 	RECT r;
-	
-	SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
+
+	SetContextForeGroundColor (
+			BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
 	r.corner.x = 2;
 	r.corner.y = 3 + y;
 	r.extent.width = w - 4;
@@ -102,8 +98,9 @@ void
 OutlineShipStatus (COORD y, COORD w, BOOLEAN inMeleeMenu)
 {
 	RECT r;
-	
-	SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
+
+	SetContextForeGroundColor (
+			BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
 	r.corner.x = 0;
 	r.corner.y = 1 + y;
 	r.extent.width = w;
@@ -113,18 +110,20 @@ OutlineShipStatus (COORD y, COORD w, BOO
 	--r.extent.width;
 	DrawFilledRectangle (&r);
 	r.extent.width = 1;
-	r.extent.height = SHIP_INFO_HEIGHT - RES_CASE(1,inMeleeMenu?-1:2,inMeleeMenu?5:0);
+	r.extent.height = SHIP_INFO_HEIGHT - RES_CASE((1), (inMeleeMenu ? -1 : 2), (inMeleeMenu ? 3 : 0));
 	DrawFilledRectangle (&r);
 	++r.corner.x;
 	DrawFilledRectangle (&r);
-	
-	SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
+
+	SetContextForeGroundColor (
+			BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
 	r.corner.x = w - 1;
 	DrawFilledRectangle (&r);
 	r.corner.x = w - 2;
 	++r.corner.y;
 	--r.extent.height;
 	DrawFilledRectangle (&r);
+
 	r.corner.x = 1;
 	r.corner.y = SHIP_INFO_HEIGHT + RES_CASE(2,3,-2);
 	r.extent.width = w - 2;
@@ -135,13 +134,15 @@ OutlineShipStatus (COORD y, COORD w, BOO
 	--r.corner.y;
 	if (inMeleeMenu)
 		DrawFilledRectangle (&r);
-	
-	SetContextForeGroundColor (BLACK_COLOR);
-	r.corner.x = 0;
-	r.corner.y = y;
-	r.extent.width = w;
-	r.extent.height = 1;
-	DrawFilledRectangle (&r);
+
+	if(RESOLUTION_FACTOR == 0){
+		SetContextForeGroundColor (BLACK_COLOR);
+		r.corner.x = 0;
+		r.corner.y = y;
+		r.extent.width = w;
+		r.extent.height = 1;
+		DrawFilledRectangle (&r);
+	}
 }
 
 void
@@ -154,13 +155,13 @@ InitShipStatus (SHIP_INFO *SIPtr, STARSH
 	CONTEXT OldContext;
 	RECT oldClipRect;
 	POINT oldOrigin = {0, 0};
-	
+
 	if (StarShipPtr) // set during battle
 	{
 		assert (StarShipPtr->playerNr >= 0);
 		y = status_y_offsets[StarShipPtr->playerNr];
 	}
-	
+
 	OldContext = SetContext (StatusContext);
 	if (pClipRect)
 	{
@@ -173,14 +174,14 @@ InitShipStatus (SHIP_INFO *SIPtr, STARSH
 		SetContextClipRect (&r);
 		// Offset the origin so that we draw into the cliprect
 		oldOrigin = SetContextOrigin (MAKE_POINT (-pClipRect->corner.x,
-												  -(pClipRect->corner.y & ~1)));
+				-(pClipRect->corner.y & ~1)));
 	}
-	
+
 	BatchGraphics ();
 	
 	OutlineShipStatus (y, width, inMeleeMenu);
 	ClearShipStatus (y, width, inMeleeMenu);
-	
+
 	Stamp.origin.x = (STATUS_WIDTH >> 1);
 	Stamp.origin.y = (31 << RESOLUTION_FACTOR) + y;
 	Stamp.frame = IncFrameIndex (SIPtr->icons);
@@ -190,56 +191,57 @@ InitShipStatus (SHIP_INFO *SIPtr, STARSH
 		SIZE crew_height, energy_height;
 		
 #define MIN(a, b) (((a) <= (b)) ? (a) : (b))
-		// At basic resolution.
-		if (RESOLUTION_FACTOR == 0)
-		{
+		if (RESOLUTION_FACTOR == 0) {
 			crew_height = ((MIN(SIPtr->max_crew, MAX_CREW_SIZE) + 1) & ~1) + 1;
 			energy_height = (((SIPtr->max_energy + 1) >> 1) << 1) + 1;
-		}
-		// At hi-res 2x.
-		else if (RESOLUTION_FACTOR == 1)
-		{
+		} else if (RESOLUTION_FACTOR == 1) {
 			crew_height = ((MIN(SIPtr->max_crew, MAX_CREW_SIZE) + 1) * 1.5);
 			energy_height = (((SIPtr->max_energy + 1) >> 1) * 3) + 1;
-		}
-		// At hi-res 4x.
-		else
-		{
+		} else {
 			crew_height = ((MIN(SIPtr->max_crew, MAX_CREW_SIZE) + 1) * 2.5) - 1;
 			energy_height = (((SIPtr->max_energy + 1) >> 1) * 5) + 1;
 		}
 #undef MIN
 		
+		// Dark gray line on the right of energy box
 		SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
 		r.corner.x = CREW_XOFFS - 1;
 		r.corner.y = GAUGE_YOFFS + 1 + y;
 		r.extent.width = STAT_WIDTH + 2;
 		r.extent.height = 1;
 		DrawFilledRectangle (&r);
+		// Dark gray line on the right of crew box
 		r.corner.x = ENERGY_XOFFS - 1;
 		DrawFilledRectangle (&r);
+		// Dark gray line on the right of energy box
 		r.corner.x = ENERGY_XOFFS + STAT_WIDTH;
 		r.corner.y -= energy_height;
 		r.extent.width = 1;
 		r.extent.height = energy_height;
 		DrawFilledRectangle (&r);
+		// Dark gray line on the right of crew box
 		r.corner.x = CREW_XOFFS + STAT_WIDTH;
 		r.corner.y = (GAUGE_YOFFS + 1 + y) - crew_height;
 		r.extent.width = 1;
 		r.extent.height = crew_height;
 		DrawFilledRectangle (&r);
+
+		// Light gray line on the top of crew box
 		SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
 		r.corner.x = CREW_XOFFS - 1;
 		r.corner.y = GAUGE_YOFFS - crew_height + y;
 		r.extent.width = STAT_WIDTH + 2;
 		r.extent.height = 1;
 		DrawFilledRectangle (&r);
+		// Light gray line on the top of energy box
 		r.corner.x = ENERGY_XOFFS - 1;
 		r.corner.y = GAUGE_YOFFS - energy_height + y;
 		DrawFilledRectangle (&r);
+		// Light gray line on the left of energy box
 		r.extent.width = 1;
 		r.extent.height = energy_height + 1;
 		DrawFilledRectangle (&r);
+		// Light gray line on the left of crew box
 		r.corner.x = CREW_XOFFS - 1;
 		r.corner.y = GAUGE_YOFFS - crew_height + y;
 		r.extent.height = crew_height + 1;
@@ -247,36 +249,38 @@ InitShipStatus (SHIP_INFO *SIPtr, STARSH
 		
 		SetContextForeGroundColor (BLACK_COLOR);
 		
+		// Black rectangle behind green crew boxes
 		r.extent.width = STAT_WIDTH;
 		r.corner.x = CREW_XOFFS;
 		r.extent.height = crew_height;
 		r.corner.y = y - r.extent.height + GAUGE_YOFFS + 1;
 		DrawFilledRectangle (&r);
+		// Black rectangle behind red energy boxes
 		r.corner.x = ENERGY_XOFFS;
 		r.extent.height = energy_height;
 		r.corner.y = y - r.extent.height + GAUGE_YOFFS + 1;
 		DrawFilledRectangle (&r);
 	}
-	
+
 	if (!StarShipPtr || StarShipPtr->captains_name_index)
 	{	// Any regular ship. SIS and Sa-Matra are separate.
 		// This includes Melee menu.
 		STRING locString;
-		
+
 		DrawCrewFuelString (y, 0);
-		
+
 		locString = SetAbsStringTableIndex (SIPtr->race_strings, 1);
 		DrawShipNameString (
-							(UNICODE *)GetStringAddress (locString),
-							GetStringLength (locString), y);
-		
+				(UNICODE *)GetStringAddress (locString),
+				GetStringLength (locString), y);
+
 		{
 			UNICODE buf[30];
 			TEXT Text;
 			FONT OldFont;
-			
+
 			OldFont = SetContextFont (TinyFont);
-			
+
 			if (!StarShipPtr)
 			{	// In Melee menu
 				sprintf (buf, "%d", SIPtr->ship_cost);
@@ -286,18 +290,18 @@ InitShipStatus (SHIP_INFO *SIPtr, STARSH
 			else
 			{
 				locString = SetAbsStringTableIndex (SIPtr->race_strings,
-													StarShipPtr->captains_name_index);
+						StarShipPtr->captains_name_index);
 				Text.pStr = (UNICODE *)GetStringAddress (locString);
 				Text.CharCount = GetStringLength (locString);
 			}
 			Text.align = ALIGN_CENTER;
-			
+
 			Text.baseline.x = STATUS_WIDTH >> 1;
-			Text.baseline.y = y + GAUGE_YOFFS + 3;
-			
+			Text.baseline.y = y + GAUGE_YOFFS + RES_CASE(3,3,7);
+
 			SetContextForeGroundColor (BLACK_COLOR);
 			font_DrawText (&Text);
-			
+
 			SetContextFont (OldFont);
 		}
 	}
@@ -306,10 +310,10 @@ InitShipStatus (SHIP_INFO *SIPtr, STARSH
 		DrawCrewFuelString (y, 0);
 		DrawShipNameString (GLOBAL_SIS (ShipName), (COUNT)~0, y);
 	}
-	
+
 	{
 		SIZE crew_delta, energy_delta;
-		
+
 		crew_delta = SIPtr->crew_level;
 		energy_delta = SIPtr->energy_level;
 		// DeltaStatistics() below will add specified values to these
@@ -317,15 +321,15 @@ InitShipStatus (SHIP_INFO *SIPtr, STARSH
 		SIPtr->energy_level = 0;
 		DeltaStatistics (SIPtr, y, crew_delta, energy_delta);
 	}
-	
+
 	UnbatchGraphics ();
-	
+
 	if (pClipRect)
 	{
 		SetContextOrigin (oldOrigin);
 		SetContextClipRect (&oldClipRect);
 	}
-	
+
 	SetContext (OldContext);
 }
 
@@ -342,6 +346,7 @@ DeltaStatistics (SHIP_INFO *ShipInfoPtr,
 		return;
 
 	x = 0;
+	// Y coordinates for the crew and energy rectangles
 	y = GAUGE_YOFFS + y_offs;
 
 	r.extent.width = UNIT_WIDTH;
diff -ruNp src.hd/uqm/shipyard.c src/uqm/shipyard.c
--- src.hd/uqm/shipyard.c	2017-12-29 02:25:54 -0800
+++ src/uqm/shipyard.c	2017-12-29 00:57:53 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "build.h"
 #include "colors.h"
 #include "controls.h"
@@ -39,10 +37,8 @@
 #include "sounds.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/inplib.h"
-#include "libs/log.h"
-
+#include "uqmdebug.h"
 
-// Don't worry about the 3DO doors. We never want to use the 3DO hangar view.
 #ifdef USE_3DO_HANGAR
 // 3DO 4x3 hangar layout
 #	define HANGAR_SHIPS_ROW  4
@@ -54,10 +50,9 @@ static const COORD hangar_x_coords[HANGA
 	19, 60, 116, 157
 };
 
-// We always wanna use the PC hangar view.
 #else // use PC hangar
 // modified PC 6x2 hangar layout
-# define HANGAR_SHIPS_ROW  6
+#	define HANGAR_SHIPS_ROW  6
 
 // The Y position of the upper line of hangar bay doors.
 # define HANGAR_Y          ((88 << RESOLUTION_FACTOR) - RES_CASE(0,3,2)) // JMS_GFX
@@ -68,16 +63,13 @@ static const COORD hangar_x_coords[HANGA
 
 // The X positions of the hangar bay doors for each resolution mode.
 // Calculated from the right edge of the left grey border bar on the screen.
-static const COORD hangar_x_coords_1x[HANGAR_SHIPS_ROW] =
-{
+static const COORD hangar_x_coords_1x[HANGAR_SHIPS_ROW] = {
 	0, 38, 76, 131, 169, 207
 };
-static const COORD hangar_x_coords_2x[HANGAR_SHIPS_ROW] =
-{
+static const COORD hangar_x_coords_2x[HANGAR_SHIPS_ROW] = {
 	2, 79, 157, 268, 346, 424
 };
-static const COORD hangar_x_coords_4x[HANGAR_SHIPS_ROW] =
-{
+static const COORD hangar_x_coords_4x[HANGAR_SHIPS_ROW] = {
 	3, 171, 339, 578, 746, 914
 };
 #endif // USE_3DO_HANGAR
@@ -93,6 +85,20 @@ enum
 	SHIPYARD_EXIT
 };
 
+// Editing mode for DoModifyShips()
+typedef enum {
+	DMS_Mode_navigate,   // Navigating the ship slots.
+	DMS_Mode_addEscort,  // Selecting a ship to add to an empty slot.
+	DMS_Mode_editCrew,   // Hiring or dismissing crew.
+	DMS_Mode_exit,       // Leaving DoModifyShips() mode.
+} DMS_Mode;
+
+static COUNT ShipCost[] =
+{
+	RACE_SHIP_COST
+};
+
+
 static void
 animatePowerLines (MENU_STATE *pMS)
 {
@@ -105,11 +111,7 @@ animatePowerLines (MENU_STATE *pMS)
 	{	// Init animation
 		s.origin.x = 0;
 		s.origin.y = 0;
-		if(!seroMenuPresent){
-			s.frame = SetAbsFrameIndex (pMS->ModuleFrame, 24);
-		} else {
-			s.frame = SetAbsFrameIndex (pMS->ModuleFrame, 25); // This shifts the animation over one so the Kohr-Ah could have a ship label
-		}
+		s.frame = SetAbsFrameIndex (pMS->ModuleFrame, 25);
 		ColorMap = SetAbsColorMapIndex (pMS->CurString, 0);
 	}
 
@@ -129,14 +131,11 @@ on_input_frame (void)
 {
 	CONTEXT oldContext;
 
-	LockMutex (GraphicsLock);
 	oldContext = SetContext (SpaceContext);
 	animatePowerLines (NULL);
 	SetContext (oldContext);
-	UnlockMutex (GraphicsLock);
 }
 
-#ifdef WANT_SHIP_SPINS
 static void
 SpinStarShip (MENU_STATE *pMS, HFLEETINFO hStarShip)
 {
@@ -149,12 +148,9 @@ SpinStarShip (MENU_STATE *pMS, HFLEETINF
 				
 	if (Index >= 0 && Index < NUM_MELEE_SHIPS)
 	{
-		UnlockMutex (GraphicsLock);
 		DoShipSpin (Index, pMS->hMusic);
-		LockMutex (GraphicsLock);
 	}
 }
-#endif
 
 // Count the ships which can be built by the player.
 static COUNT
@@ -211,7 +207,6 @@ DrawRaceStrings (MENU_STATE *pMS, BYTE N
 	STAMP s;
 	CONTEXT OldContext;
 	
-	LockMutex (GraphicsLock);
 
 	OldContext = SetContext (StatusContext);
 	GetContextClipRect (&r);
@@ -229,8 +224,7 @@ DrawRaceStrings (MENU_STATE *pMS, BYTE N
 	r.corner = s.origin;
 	r.extent.width = RADAR_WIDTH;
 	r.extent.height = RADAR_HEIGHT;
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x00), 0x00));
+	SetContextForeGroundColor (BLACK_COLOR);
 	DrawFilledRectangle (&r);
 	if (NewRaceItem != (BYTE)~0)
 	{
@@ -238,47 +232,42 @@ DrawRaceStrings (MENU_STATE *pMS, BYTE N
 		HFLEETINFO hStarShip;
 		FLEET_INFO *FleetPtr;
 		UNICODE buf[30];
-		COUNT ShipCost[] =
-		{
-			RACE_SHIP_COST
-		};
 
 		hStarShip = GetAvailableRaceFromIndex (NewRaceItem);
 		NewRaceItem = GetIndexFromStarShip (&GLOBAL (avail_race_q),
 				hStarShip);
+
+		// Draw the ship name, above the ship image.
 		s.frame = SetAbsFrameIndex (pMS->ModuleFrame, 3 + NewRaceItem);
 		DrawStamp (&s);
+
+		// Draw the ship image.
 		FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
 		s.frame = FleetPtr->melee_icon;
 		UnlockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
-
 		t.baseline.x = s.origin.x + RADAR_WIDTH - 2;
 		t.baseline.y = s.origin.y + RADAR_HEIGHT - 2;
 		s.origin.x += (RADAR_WIDTH >> 1);
 		s.origin.y += (RADAR_HEIGHT >> 1);
 		DrawStamp (&s);
+
+		// Print the ship cost.
 		t.align = ALIGN_RIGHT;
 		t.CharCount = (COUNT)~0;
 		t.pStr = buf;
 		sprintf (buf, "%u", ShipCost[NewRaceItem]);
 		SetContextFont (TinyFont);
-
-		if ((ShipCost[NewRaceItem]) <= (GLOBAL_SIS (ResUnits)))
-		{
+		if ((ShipCost[NewRaceItem]) <= (GLOBAL_SIS (ResUnits))) {
 			SetContextForeGroundColor (BRIGHT_GREEN_COLOR);
 		} else if ((ShipCost[NewRaceItem]) > (GLOBAL_SIS (ResUnits)))
 		{ /* We don't have enough to purchase this ship. */
 			SetContextForeGroundColor (BRIGHT_RED_COLOR);
 		}
-
 		font_DrawText (&t);
 	}
 	UnbatchGraphics ();
 	SetContext (OldContext);
 
-	// Flash the ship purchase menu even when optMenu == OPT_PC
-	SetFlashRect (SFR_MENU_ANY);
-	UnlockMutex (GraphicsLock);
 }
 
 // Width of an escort ship window.
@@ -292,28 +281,33 @@ DrawRaceStrings (MENU_STATE *pMS, BYTE N
 // enough, part of the doors are left visible upon opening.
 #define SHIP_WIN_FRAMES ((SHIP_WIN_WIDTH >> 1) + RES_CASE(1,1,2))
 
+// Print the crew count of an escort ship on top of its (already drawn)
+// image, either as '30' (full), '28/30' (partially full), or 'SCRAP'
+// (empty).
+// pRect is the rectangle of the ship image.
 static void
-ShowShipCrew (SHIP_FRAGMENT *StarShipPtr, RECT *pRect)
+ShowShipCrew (SHIP_FRAGMENT *StarShipPtr, const RECT *pRect)
 {
 	RECT r;
 	TEXT t;
 	UNICODE buf[80];
 	HFLEETINFO hTemplate;
 	FLEET_INFO *TemplatePtr;
+	COUNT maxCrewLevel;
 
 	hTemplate = GetStarShipFromIndex (&GLOBAL (avail_race_q),
 			StarShipPtr->race_id);
 	TemplatePtr = LockFleetInfo (&GLOBAL (avail_race_q), hTemplate);
-	if (StarShipPtr->crew_level >= TemplatePtr->crew_level)
+	maxCrewLevel = TemplatePtr->crew_level;
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hTemplate);
+
+	if (StarShipPtr->crew_level >= maxCrewLevel)
 		sprintf (buf, "%u", StarShipPtr->crew_level);
 	else if (StarShipPtr->crew_level == 0)
 		// XXX: "SCRAP" needs to be moved to starcon.txt
 		utf8StringCopy (buf, sizeof (buf), "SCRAP");
 	else
-		sprintf (buf, "%u/%u",
-				StarShipPtr->crew_level,
-				TemplatePtr->crew_level);
-	UnlockFleetInfo (&GLOBAL (avail_race_q), hTemplate);
+		sprintf (buf, "%u/%u", StarShipPtr->crew_level, maxCrewLevel);
 
 	r = *pRect;
 	t.baseline.x = r.corner.x + (r.extent.width >> 1);
@@ -339,7 +333,8 @@ static void
 ShowCombatShip (MENU_STATE *pMS, COUNT which_window,
 		SHIP_FRAGMENT *YankedStarShipPtr)
 {
-	COUNT i, num_ships;
+	COUNT i;
+	COUNT num_ships;
 	HSHIPFRAG hStarShip, hNextShip;
 	SHIP_FRAGMENT *StarShipPtr;
 	static const COORD *hangar_x_coords;
@@ -347,11 +342,12 @@ ShowCombatShip (MENU_STATE *pMS, COUNT w
 	{
 		SHIP_FRAGMENT *StarShipPtr;
 		POINT finished_s;
-		STAMP ship_s, lfdoor_s, rtdoor_s;
+		STAMP ship_s;
+		STAMP lfdoor_s;
+		STAMP rtdoor_s;
 	} ship_win_info[MAX_BUILT_SHIPS], *pship_win_info;
 
-	switch (RESOLUTION_FACTOR) // JMS_GFX
-	{
+	switch (RESOLUTION_FACTOR) {
 		case 2:
 			hangar_x_coords = hangar_x_coords_4x;
 			break;
@@ -363,7 +359,7 @@ ShowCombatShip (MENU_STATE *pMS, COUNT w
 			hangar_x_coords = hangar_x_coords_1x;
 			break;
 	}
-	
+
 	num_ships = 1;
 	pship_win_info = &ship_win_info[0];
 	if (YankedStarShipPtr)
@@ -382,7 +378,8 @@ ShowCombatShip (MENU_STATE *pMS, COUNT w
 		pship_win_info->ship_s.origin.y = (SHIP_WIN_WIDTH >> 1);
 		pship_win_info->ship_s.frame = YankedStarShipPtr->melee_icon;
 
-		pship_win_info->finished_s.x = hangar_x_coords[which_window % HANGAR_SHIPS_ROW];
+		pship_win_info->finished_s.x = hangar_x_coords[
+				which_window % HANGAR_SHIPS_ROW];
 		pship_win_info->finished_s.y = HANGAR_Y + (HANGAR_DY *
 				(which_window / HANGAR_SHIPS_ROW));
 	}
@@ -428,6 +425,10 @@ ShowCombatShip (MENU_STATE *pMS, COUNT w
 			hNextShip = _GetSuccLink (StarShipPtr);
 
 			pship_win_info->StarShipPtr = StarShipPtr;
+					// XXX BUG: this looks wrong according to the original
+					// semantics of LockShipFrag(): StarShipPtr is not valid
+					// anymore after UnlockShipFrag() is called, but it is
+					// used thereafter.
 
 			pship_win_info->lfdoor_s.origin.x = -1;
 			pship_win_info->rtdoor_s.origin.x = 1;
@@ -442,7 +443,8 @@ ShowCombatShip (MENU_STATE *pMS, COUNT w
 			pship_win_info->ship_s.frame = StarShipPtr->melee_icon;
 
 			which_window = StarShipPtr->index;
-			pship_win_info->finished_s.x = hangar_x_coords[which_window % HANGAR_SHIPS_ROW];
+			pship_win_info->finished_s.x = hangar_x_coords[
+					which_window % HANGAR_SHIPS_ROW];
 			pship_win_info->finished_s.y = HANGAR_Y + (HANGAR_DY *
 					(which_window / HANGAR_SHIPS_ROW));
 			++pship_win_info;
@@ -482,7 +484,6 @@ ShowCombatShip (MENU_STATE *pMS, COUNT w
 				AllDoorsFinished = TRUE;
 			}
 
-			LockMutex (GraphicsLock);
 			OldContext = SetContext (SpaceContext);
 			GetContextClipRect (&OldClipRect);
 			SetContextBackGroundColor (BLACK_COLOR);
@@ -530,7 +531,6 @@ ShowCombatShip (MENU_STATE *pMS, COUNT w
 #endif
 			UnbatchGraphics ();
 			SetContext (OldContext);
-			UnlockMutex (GraphicsLock);
 		}
 	}
 }
@@ -558,10 +558,7 @@ CrewTransaction (SIZE crew_delta)
 					&& crew_bought - crew_delta < CREW_EXPENSE_THRESHOLD)
 			{
 				GLOBAL (CrewCost) += 2;
-
-				UnlockMutex (GraphicsLock);
 				DrawMenuStateStrings (PM_CREW, SHIPYARD_CREW);
-				LockMutex (GraphicsLock);
 			}
 		}
 		else
@@ -570,13 +567,10 @@ CrewTransaction (SIZE crew_delta)
 					&& crew_bought - crew_delta >= CREW_EXPENSE_THRESHOLD)
 			{
 				GLOBAL (CrewCost) -= 2;
-
-				UnlockMutex (GraphicsLock);
 				DrawMenuStateStrings (PM_CREW, SHIPYARD_CREW);
-				LockMutex (GraphicsLock);
 			}
 		}
-		if (ActivateStarShip (SHOFIXTI_SHIP, CHECK_ALLIANCE) != GOOD_GUY)
+		if (CheckAlliance (SHOFIXTI_SHIP) != GOOD_GUY)
 		{
 			SET_GAME_STATE (CREW_PURCHASED0, LOBYTE (crew_bought));
 			SET_GAME_STATE (CREW_PURCHASED1, HIBYTE (crew_bought));
@@ -584,29 +578,25 @@ CrewTransaction (SIZE crew_delta)
 	}
 }
 
-/* in this routine, the least significant byte of pMS->CurState is used
- * to store the current selected ship index
- * a special case for the row is hi-nibble == -1 (0xf), which specifies
- * SIS as the selected ship
- * some bitwise math is still done to scroll through ships, for it to work
- * ships per row number must divide 0xf0 without remainder
- */
-static BOOLEAN
-DoModifyShips (MENU_STATE *pMS)
+static void
+DMS_FlashFlagShip (void)
 {
-#define MODIFY_CREW_FLAG (1 << 8)
-	BOOLEAN select, cancel;
+	RECT r;
+	r.corner.x = 0;
+	r.corner.y = 0;
+	r.extent.width = SIS_SCREEN_WIDTH;
+	r.extent.height = RES_CASE(61, 122, 295); // JMS_GFX
+	SetFlashRect (&r);
+}
+
+static void
+DMS_GetEscortShipRect (RECT *rOut, BYTE slotNr)
+{
+	BYTE row = slotNr / HANGAR_SHIPS_ROW;
+	BYTE col = slotNr % HANGAR_SHIPS_ROW;
 	static const COORD *hangar_x_coords;
-#ifdef WANT_SHIP_SPINS
-	BOOLEAN special;
 
-	special = PulsedInputState.menu[KEY_MENU_SPECIAL];
-#endif /* WANT_SHIP_SPINS */
-	select = PulsedInputState.menu[KEY_MENU_SELECT];
-	cancel = PulsedInputState.menu[KEY_MENU_CANCEL];
-	
-	switch (RESOLUTION_FACTOR) // JMS_GFX
-	{
+	switch (RESOLUTION_FACTOR) {
 		case 2:
 			hangar_x_coords = hangar_x_coords_4x;
 			break;
@@ -619,513 +609,731 @@ DoModifyShips (MENU_STATE *pMS)
 			break;
 	}
 
-	if (GLOBAL (CurrentActivity) & CHECK_ABORT)
+	rOut->corner.x = hangar_x_coords[col];
+	rOut->corner.y = HANGAR_Y + (HANGAR_DY * row);
+	rOut->extent.width = SHIP_WIN_WIDTH;
+	rOut->extent.height = SHIP_WIN_HEIGHT;
+}
+
+static void
+DMS_FlashEscortShip (BYTE slotNr)
+{
+	RECT r;
+	DMS_GetEscortShipRect (&r, slotNr);
+	SetFlashRect (&r);
+}
+
+static void
+DMS_FlashFlagShipCrewCount (void)
+{
+	RECT r;
+	SetContext (StatusContext);
+	GetGaugeRect (&r, TRUE);
+	SetFlashRect (&r);
+	SetContext (SpaceContext);
+}
+
+static void
+DMS_FlashEscortShipCrewCount (BYTE slotNr)
+{
+	RECT r;
+	BYTE row = slotNr / HANGAR_SHIPS_ROW;
+	BYTE col = slotNr % HANGAR_SHIPS_ROW;
+	static const COORD *hangar_x_coords;
+
+	switch (RESOLUTION_FACTOR) {
+		case 2:
+			hangar_x_coords = hangar_x_coords_4x;
+			break;
+		case 1:
+			hangar_x_coords = hangar_x_coords_2x;
+			break;
+		case 0:
+		default:
+			hangar_x_coords = hangar_x_coords_1x;
+			break;
+	}
+
+	r.corner.x = hangar_x_coords[col];
+	r.corner.y = (HANGAR_Y + (HANGAR_DY * row)) + (SHIP_WIN_HEIGHT - (6 << RESOLUTION_FACTOR));
+	r.extent.width = SHIP_WIN_WIDTH;
+	r.extent.height = 5 << RESOLUTION_FACTOR; // JMS_GFX
+
+	SetContext (SpaceContext);
+	SetFlashRect (&r);
+}
+
+// Helper function for DoModifyShips(). Called to change the flash
+// rectangle to the currently selected ship (flagship or escort ship).
+static void
+DMS_FlashActiveShip (MENU_STATE *pMS)
+{
+	if (HINIBBLE (pMS->CurState))
 	{
-		pMS->InputFunc = DoShipyard;
-		return TRUE;
+		// Flash the flag ship.
+		DMS_FlashFlagShip ();
+	}
+	else
+	{
+		// Flash the current escort ship slot.
+		DMS_FlashEscortShip (pMS->CurState);
 	}
+}
 
-	if (!pMS->Initialized)
+// Helper function for DoModifyShips(). Called to switch between
+// the various edit modes.
+// XXX: right now, this only switches the sound and flash rectangle.
+// Perhaps we should move more of the code to modify other aspects
+// here too.
+static void
+DMS_SetMode (MENU_STATE *pMS, DMS_Mode mode)
+{
+	switch (mode) {
+		case DMS_Mode_navigate:
+			SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
+			DMS_FlashActiveShip (pMS);
+			break;
+		case DMS_Mode_addEscort:
+			SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
+			SetFlashRect (SFR_MENU_ANY);
+			break;
+		case DMS_Mode_editCrew:
+			SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN | MENU_SOUND_PAGEUP | MENU_SOUND_PAGEDOWN,
+					MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
+			if (HINIBBLE (pMS->CurState))
+			{
+				// Enter crew editing mode for the flagship.
+				DMS_FlashFlagShipCrewCount ();
+			}
+			else
+			{
+				// Enter crew editing mode for an escort ship.
+				DMS_FlashEscortShipCrewCount (pMS->CurState);
+			}
+			break;
+		case DMS_Mode_exit:
+			SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
+			SetFlashRect (SFR_MENU_3DO);
+			break;
+	}
+}
+
+#define MODIFY_CREW_FLAG (1 << 8)
+// Helper function for DoModifyShips(), called when the player presses the
+// special button.
+// It works both when the cursor is over an escort ship, while not editing
+// the crew, and when a new ship is added.
+// hStarShip is the ship in the slot under the cursor (or 0 if no such ship).
+static BOOLEAN
+DMS_SpinShip (MENU_STATE *pMS, HSHIPFRAG hStarShip)
+{
+	HFLEETINFO hSpinShip = 0;
+	CONTEXT OldContext;
+	RECT OldClipRect;
+	
+	// No spinning the flagship.
+	if (HINIBBLE (pMS->CurState) != 0)
+		return FALSE;
+
+	// We must either be hovering over a used ship slot, or adding a new
+	// ship to the fleet.
+	if ((hStarShip == 0) == !(pMS->delta_item & MODIFY_CREW_FLAG))
+		return FALSE;
+
+	if (!hStarShip)
 	{
-		pMS->InputFunc = DoModifyShips;
-		pMS->Initialized = TRUE;
-		pMS->CurState = MAKE_BYTE (0, 0xF);
-		pMS->delta_item = 0;
+		// Selecting a ship to build.
+		hSpinShip = GetAvailableRaceFromIndex (LOBYTE (pMS->delta_item));
+		if (!hSpinShip)
+			return FALSE;
+	}
+	else
+	{
+		// Hovering over an escort ship.
+		SHIP_FRAGMENT *FragPtr = LockShipFrag (
+				&GLOBAL (built_ship_q), hStarShip);
+		hSpinShip = GetStarShipFromIndex (
+				&GLOBAL (avail_race_q), FragPtr->race_id);
+		UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+	}
+	
+	SetFlashRect (NULL);
 
-		LockMutex (GraphicsLock);
-		SetContext (SpaceContext);
-		goto ChangeFlashRect;
+	OldContext = SetContext (ScreenContext);
+	GetContextClipRect (&OldClipRect);
+
+	SpinStarShip (pMS, hSpinShip);
+
+	SetContextClipRect (&OldClipRect);
+	SetContext (OldContext);
+
+	return TRUE;
+}
+
+// Helper function for DoModifyShips(), called when the player presses the
+// up button when modifying the crew of the flagship.
+// Buy crew for the flagship.
+// Returns the change in crew (1 on success, 0 on failure).
+static SIZE
+DMS_HireFlagShipCrew (void)
+{
+	RECT r;
+	
+	if (GetCPodCapacity (&r.corner) <= GetCrewCount ())
+	{
+		// At capacity.
+		return 0;
+	}
+		
+	if (GLOBAL_SIS (ResUnits) < (DWORD)GLOBAL (CrewCost))
+	{
+		// Not enough RUs.
+		return 0;
+	}
+
+	// Draw a crew member.
+	// Crew dots/rectangles for 1x and 2x resolutions.
+	if (RESOLUTION_FACTOR < 2) {
+		r.extent.width = 1 << RESOLUTION_FACTOR;
+		r.extent.height = r.extent.width;
+		DrawFilledRectangle (&r);
+	} else {
+		r.corner.x += 1;
+		r.extent.width = (1 << RESOLUTION_FACTOR) - 2;
+		r.extent.height = 1 << RESOLUTION_FACTOR;
+		DrawFilledRectangle (&r);
+									
+		r.corner.x -= 1;
+		r.corner.y += 1;
+		r.extent.width = 1 << RESOLUTION_FACTOR;
+		r.extent.height = (1 << RESOLUTION_FACTOR) - 2;
+		DrawFilledRectangle (&r);
+									
+		r.corner.y -= 1;
+	}
+
+	// Update the crew counter and RU. Note that the crew counter is
+	// flashing.
+	PreUpdateFlashRect ();
+	DeltaSISGauges (1, 0, -GLOBAL (CrewCost));
+	PostUpdateFlashRect ();
+
+	return 1;
+}
+
+// Helper function for DoModifyShips(), called when the player presses the
+// down button when modifying the crew of the flagship.
+// Dismiss crew from the flagship.
+// Returns the change in crew (-1 on success, 0 on failure).
+static SIZE
+DMS_DismissFlagShipCrew (void)
+{
+	SIZE crew_bought;
+	RECT r;
+
+	if (GetCrewCount () == 0)
+	{
+		// No crew to dismiss.
+		return 0;
+	}
+
+	crew_bought = (SIZE)MAKE_WORD (
+			GET_GAME_STATE (CREW_PURCHASED0),
+			GET_GAME_STATE (CREW_PURCHASED1));
+
+	// Update the crew counter and RU. Note that the crew counter is
+	// flashing.
+	PreUpdateFlashRect ();
+	DeltaSISGauges (-1, 0, GLOBAL (CrewCost) -
+			(crew_bought == CREW_EXPENSE_THRESHOLD ? 2 : 0));
+	PostUpdateFlashRect ();
+
+	// Remove the pixel representing the crew member.
+	GetCPodCapacity (&r.corner);
+	r.extent.width = 1 << RESOLUTION_FACTOR;
+	r.extent.height = r.extent.width;
+	SetContextForeGroundColor (BLACK_COLOR);
+	DrawFilledRectangle (&r);
+
+	return -1;
+}
+
+// Helper function for DoModifyShips(), called when the player presses the
+// up button when modifying the crew of an escort ship.
+// Buy crew for an escort ship
+// Returns the change in crew (1 on success, 0 on failure).
+static SIZE
+DMS_HireEscortShipCrew (SHIP_FRAGMENT *StarShipPtr)
+{
+	COUNT templateMaxCrew;
+	RECT r;
+
+	{
+		// XXX Split this off into a separate function?
+		HFLEETINFO hTemplate = GetStarShipFromIndex (&GLOBAL (avail_race_q),
+				StarShipPtr->race_id);
+		FLEET_INFO *TemplatePtr =
+				LockFleetInfo (&GLOBAL (avail_race_q), hTemplate);
+		templateMaxCrew = TemplatePtr->crew_level;
+		UnlockFleetInfo (&GLOBAL (avail_race_q), hTemplate);
+	}
+	
+	if (GLOBAL_SIS (ResUnits) < (DWORD)GLOBAL (CrewCost))
+	{
+		// Not enough money to hire a crew member.
+		return 0;
+	}
+
+	if (StarShipPtr->crew_level >= StarShipPtr->max_crew)
+	{
+		// This ship cannot handle more crew.
+		return 0;
+	}
+
+	if (StarShipPtr->crew_level >= templateMaxCrew)
+	{
+		// A ship of this type cannot handle more crew.
+		return 0;
+	}
+
+	if (StarShipPtr->crew_level > 0)
+	{
+		DeltaSISGauges (0, 0, -GLOBAL (CrewCost));
 	}
 	else
 	{
-		SBYTE dx = 0;
-		SBYTE dy = 0;
-		BYTE NewState;
+		// Buy a ship.
+		DeltaSISGauges (0, 0, -(COUNT)ShipCost[StarShipPtr->race_id]);
+	}
 
-		if (!(pMS->delta_item & MODIFY_CREW_FLAG))
-		{
-			SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
-		}
+	++StarShipPtr->crew_level;
+
+	PreUpdateFlashRect ();
+	DMS_GetEscortShipRect (&r, StarShipPtr->index);
+	ShowShipCrew (StarShipPtr, &r);
+	PostUpdateFlashRect ();
+
+	return 1;
+}
+
+// Helper function for DoModifyShips(), called when the player presses the
+// down button when modifying the crew of an escort ship.
+// Dismiss crew from an escort ship
+// Returns the change in crew (-1 on success, 0 on failure).
+static SIZE
+DMS_DismissEscortShipCrew (SHIP_FRAGMENT *StarShipPtr)
+{
+	SIZE crew_delta = 0;
+	RECT r;
 
-		if (PulsedInputState.menu[KEY_MENU_RIGHT]) dx = 1;
-		if (PulsedInputState.menu[KEY_MENU_LEFT]) dx = -1;
-		if (PulsedInputState.menu[KEY_MENU_UP]) dy = -1;
-		if (PulsedInputState.menu[KEY_MENU_DOWN]) dy = 1;
-		NewState = pMS->CurState;
-		if (pMS->delta_item & MODIFY_CREW_FLAG)
+	if (StarShipPtr->crew_level > 0)
+	{
+		if (StarShipPtr->crew_level > 1)
 		{
+			// The ship was not at 'scrap'.
+			// Give one crew member worth of RU.
+			SIZE crew_bought = (SIZE)MAKE_WORD (
+					GET_GAME_STATE (CREW_PURCHASED0),
+					GET_GAME_STATE (CREW_PURCHASED1));
+
+			DeltaSISGauges (0, 0, GLOBAL (CrewCost)
+					- (crew_bought == CREW_EXPENSE_THRESHOLD ? 2 : 0));
 		}
-		else if (dy)
+		else
 		{
-			if (HINIBBLE (NewState))
-				NewState = pMS->CurState % HANGAR_SHIPS_ROW;
-			else
-				NewState = (unsigned char)(pMS->CurState + HANGAR_SHIPS_ROW);
+			// With the last crew member, the ship will be scrapped.
+			// Give RU for the ship.
+			DeltaSISGauges (0, 0, (COUNT)ShipCost[StarShipPtr->race_id]);
+		}
+		crew_delta = -1;
+		--StarShipPtr->crew_level;
+	}
+	else
+	{	// no crew to dismiss
+		PlayMenuSound (MENU_SOUND_FAILURE);
+	}
 
-			NewState += dy * HANGAR_SHIPS_ROW;
-			if (NewState / HANGAR_SHIPS_ROW > 0
-					&& NewState / HANGAR_SHIPS_ROW <= HANGAR_ROWS)
-				NewState -= HANGAR_SHIPS_ROW;
-			else if (NewState / HANGAR_SHIPS_ROW > HANGAR_ROWS + 1)
-				/* negative number - select last row */
-				NewState = pMS->CurState % HANGAR_SHIPS_ROW
-						+ HANGAR_SHIPS_ROW * (HANGAR_ROWS - 1);
-			else
-				// select SIS
-				NewState = MAKE_BYTE (pMS->CurState, 0xF);
+	PreUpdateFlashRect ();
+	DMS_GetEscortShipRect (&r, StarShipPtr->index);
+	ShowShipCrew (StarShipPtr, &r);
+	PostUpdateFlashRect ();
+
+	return crew_delta;
+}
+
+// Helper function for DoModifyShips(), called when the player presses the
+// up or down button when modifying the crew of the flagship or of an escort
+// ship.
+// 'hStarShip' is the currently escort ship, or 0 if no ship is
+// selected.
+// 'dy' is -1 if the 'up' button was pressed, or '1' if the down button was
+// pressed.
+static void
+DMS_ModifyCrew (MENU_STATE *pMS, HSHIPFRAG hStarShip, SBYTE dy, SBYTE dx, SBYTE DoLoop)
+{
+	SIZE crew_delta = 0;
+	int loop;
+	SHIP_FRAGMENT *StarShipPtr = NULL;
+
+	if (hStarShip)
+		StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+
+	for (loop = 0; loop < (DoLoop ? 10 : 1); loop++) {
+		if (hStarShip == 0)
+		{
+			// Add/Dismiss crew for the flagship.
+			if (dy < 0 || dx > 0) {
+				// Add crew for the flagship.
+				crew_delta += DMS_HireFlagShipCrew ();
+			} else {
+				// Dismiss crew from the flagship.
+				crew_delta -= DMS_DismissFlagShipCrew ();
+			}
+
+			if (crew_delta != 0)
+				DMS_FlashFlagShipCrewCount ();
+		} else {
+			// Add/Dismiss crew for an escort ship.
+			if (dy < 0 || dx > 0) {
+				// Add crew for an escort ship.
+				crew_delta = DMS_HireEscortShipCrew (StarShipPtr);
+			} else {
+				// Dismiss crew from an escort ship.
+				crew_delta = DMS_DismissEscortShipCrew (StarShipPtr);
+			}
+		
+			if (crew_delta != 0)
+				DMS_FlashEscortShipCrewCount (StarShipPtr->index);
 		}
-		else if (dx && !HINIBBLE (NewState))
+
+		if (crew_delta == 0)
+			PlayMenuSound (MENU_SOUND_FAILURE);
+
+		if (hStarShip)
 		{
-			NewState = NewState % HANGAR_SHIPS_ROW;
-			if ((dx += NewState) < 0)
-				NewState = (BYTE)(pMS->CurState + (HANGAR_SHIPS_ROW - 1));
-			else if (dx > HANGAR_SHIPS_ROW - 1)
-				NewState = (BYTE)(pMS->CurState - (HANGAR_SHIPS_ROW - 1));
-			else
-				NewState = (BYTE)(pMS->CurState - NewState + dx);
+			UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+		
+			// Clear out the bought ship index so that flash rects work
+			// correctly.
+			pMS->delta_item &= MODIFY_CREW_FLAG;
 		}
 
-		if (select || cancel
-#ifdef WANT_SHIP_SPINS
-				|| special
-#endif
-				|| NewState != pMS->CurState
-				|| ((pMS->delta_item & MODIFY_CREW_FLAG) && (dx || dy)))
+		CrewTransaction (crew_delta);
+	}
+}
+
+// Helper function for DoModifyShips(), called when the player presses the
+// select button when the cursor is over an empty escort ship slot.
+// Try to add the currently selected ship as an escort ship.
+static void
+DMS_TryAddEscortShip (MENU_STATE *pMS)
+{
+	HFLEETINFO shipInfo = GetAvailableRaceFromIndex (
+			LOBYTE (pMS->delta_item));
+	COUNT Index = GetIndexFromStarShip (&GLOBAL (avail_race_q), shipInfo);
+
+	if (GLOBAL_SIS (ResUnits) >= (DWORD)ShipCost[Index]
+			&& CloneShipFragment (Index, &GLOBAL (built_ship_q), 1))
+	{
+		ShowCombatShip (pMS, pMS->CurState, NULL);
+				// Reset flash rectangle
+		DrawMenuStateStrings (PM_CREW, SHIPYARD_CREW);
+
+		DeltaSISGauges (UNDEFINED_DELTA, UNDEFINED_DELTA,
+				-((int)ShipCost[Index]));
+		DMS_SetMode (pMS, DMS_Mode_editCrew);
+	}
+	else
+	{
+		// not enough RUs to build, or cloning the ship failed.
+		PlayMenuSound (MENU_SOUND_FAILURE);
+	}
+}
+
+// Helper function for DoModifyShips(), called when the player is in the
+// mode to add a new escort ship to the fleet (after pressing select on an
+// empty slot).
+// LOBYTE (pMS->delta_item) is used to store the currently highlighted ship.
+// Returns FALSE if the flash rectangle needs to be updated.
+static void
+DMS_AddEscortShip (MENU_STATE *pMS, BOOLEAN special, BOOLEAN select,
+		BOOLEAN cancel, SBYTE dx, SBYTE dy)
+{
+	assert (pMS->delta_item & MODIFY_CREW_FLAG);
+
+	if (special)
+	{
+		HSHIPFRAG hStarShip = GetEscortByStarShipIndex (pMS->delta_item);
+		if (DMS_SpinShip (pMS, hStarShip))
+			DMS_SetMode (pMS, DMS_Mode_addEscort);
+		return;
+	}
+
+	if (cancel)
+	{
+		// Cancel selecting an escort ship.
+		pMS->delta_item &= ~MODIFY_CREW_FLAG;
+		SetFlashRect (NULL);
+		DrawMenuStateStrings (PM_CREW, SHIPYARD_CREW);
+		DMS_SetMode (pMS, DMS_Mode_navigate);
+	}
+	else if (select)
+	{
+		// Selected a ship to be inserted in an empty escort
+		// ship slot.
+		DMS_TryAddEscortShip (pMS);
+	}
+	else if (dx || dy)
+	{
+		// Motion key pressed while selecting a ship to be
+		// inserted in an empty escort ship slot.
+		COUNT availableCount = GetAvailableRaceCount ();
+		BYTE currentShip = LOBYTE (pMS->delta_item);
+		if (dx < 0 || dy < 0)
 		{
-			HSHIPFRAG hStarShip, hNextShip;
-			SHIP_FRAGMENT *StarShipPtr;
-			RECT r;
+			if (currentShip-- == 0)
+				currentShip = availableCount - 1;
+		}
+		else if (dx > 0 || dy > 0)
+		{
+			if (++currentShip == availableCount)
+				currentShip = 0;
+		}
+		
+		if (currentShip != LOBYTE (pMS->delta_item))
+		{
+			PreUpdateFlashRect ();
+			DrawRaceStrings (pMS, currentShip);
+			PostUpdateFlashRect ();
+			pMS->delta_item = currentShip | MODIFY_CREW_FLAG;
+		}
+	}
+}
 
-			for (hStarShip = GetHeadLink (&GLOBAL (built_ship_q));
-					hStarShip; hStarShip = hNextShip)
-			{
-				StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+// Helper function for DoModifyShips(), called when the player presses
+// 'select' or 'cancel' after selling all the crew.
+static void
+DMS_ScrapEscortShip (MENU_STATE *pMS, HSHIPFRAG hStarShip)
+{
+	SHIP_FRAGMENT *StarShipPtr =
+			LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+	BYTE slotNr;
+
+	SetFlashRect (NULL);
+	ShowCombatShip (pMS, pMS->CurState, StarShipPtr);
+
+	slotNr = StarShipPtr->index;
+	UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+
+	RemoveQueue (&GLOBAL (built_ship_q), hStarShip);
+	FreeShipFrag (&GLOBAL (built_ship_q), hStarShip);
+	// refresh SIS display
+	DeltaSISGauges (UNDEFINED_DELTA, UNDEFINED_DELTA, UNDEFINED_DELTA);
 
-				if (StarShipPtr->index == pMS->CurState)
-				{
-					UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
-					break;
-				}
+	SetContext (SpaceContext);
+	DMS_SetMode (pMS, DMS_Mode_navigate);
+}
 
-				hNextShip = _GetSuccLink (StarShipPtr);
-				UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
-			}
-			if ((pMS->delta_item & MODIFY_CREW_FLAG) && (hStarShip))
-			{
-				SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN,
-						MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
-			}
-			else
-			{
-				SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
-			}
+// Helper function for DoModifyShips(), called when the player presses
+// one of the motion keys when not in crew modification mode.
+static BYTE
+DMS_MoveCursor (BYTE curState, SBYTE dx, SBYTE dy)
+{
+	BYTE row = LONIBBLE(curState) / HANGAR_SHIPS_ROW;
+	BYTE col = LONIBBLE(curState) % HANGAR_SHIPS_ROW;
+	BOOLEAN isFlagShipSelected = (HINIBBLE(curState) != 0);
+
+	if (dy)
+	{
+		// Vertical motion.
 	
-			LockMutex (GraphicsLock);
+		// We consider the flagship an extra row (on the bottom),
+		// to ease operations.
+		if (isFlagShipSelected)
+			row = HANGAR_ROWS;
+
+		// Move up/down, wrapping around:
+		row = (row + (HANGAR_ROWS + 1) + dy) % (HANGAR_ROWS + 1);
+
+		// If we moved to the 'extra row', this means the flag ship.
+		isFlagShipSelected = (row == HANGAR_ROWS);
+		if (isFlagShipSelected)
+			row = 0;
+	}
+	else if (dx)
+	{
+		// Horizontal motion.
+		if (!isFlagShipSelected)
+		{
+			// Moving horizontally through the escort ship slots,
+			// wrapping around if necessary.
+			col = (col + HANGAR_SHIPS_ROW + dx) % HANGAR_SHIPS_ROW;
+		}
+	}
+		
+	return MAKE_BYTE(row * HANGAR_SHIPS_ROW + col,
+			isFlagShipSelected ? 0xf : 0);
+}
 
-#ifdef WANT_SHIP_SPINS
-			if (special)
-			{
-				HFLEETINFO hSpinShip = 0;
-				
-				if ((special && (((hStarShip == 0
-						   && HINIBBLE (pMS->CurState) == 0)
-						  && (pMS->delta_item & MODIFY_CREW_FLAG))
-						 || ((hStarShip != 0 &&
-						      HINIBBLE (pMS->CurState) == 0)
-						     && !(pMS->delta_item & MODIFY_CREW_FLAG))))
-				    && (hStarShip
-					|| (HINIBBLE (pMS->CurState) == 0
-					    && (hSpinShip = GetAvailableRaceFromIndex (
-							LOBYTE (pMS->delta_item))))))
-				{
-					CONTEXT OldContext;
-					RECT OldClipRect;
+// Helper function for DoModifyShips(), called every time DoModifyShip() is
+// called when we are in crew editing mode.
+static void
+DMS_EditCrewMode (MENU_STATE *pMS, HSHIPFRAG hStarShip,
+		BOOLEAN select, BOOLEAN cancel, SBYTE dy, SBYTE dx, SBYTE DoLoop)
+{
+	if (select || cancel)
+	{
+		// Leave crew editing mode.
+		if (hStarShip != 0)
+		{
+			// Exiting crew editing mode for an escort ship.
+			SHIP_FRAGMENT *StarShipPtr = LockShipFrag (
+					&GLOBAL (built_ship_q), hStarShip);
+			COUNT crew_level = StarShipPtr->crew_level;
+			UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 
-					if (!hSpinShip)
-					{	/* Get fleet info from selected escort */
-						SHIP_FRAGMENT *FragPtr = LockShipFrag (
-								&GLOBAL (built_ship_q), hStarShip);
-						hSpinShip = GetStarShipFromIndex (
-								&GLOBAL (avail_race_q), FragPtr->race_id);
-						UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
-					}
-					
-					SetFlashRect (NULL);
+			if (crew_level == 0)
+			{
+				// Scrapping the escort ship before exiting crew edit
+				// mode.
+				DMS_ScrapEscortShip (pMS, hStarShip);
+			}
+		}
 
-					OldContext = SetContext (ScreenContext);
-					GetContextClipRect (&OldClipRect);
+		pMS->delta_item &= ~MODIFY_CREW_FLAG;
+		DMS_SetMode (pMS, DMS_Mode_navigate);
+	}
+	else if (dy || DoLoop)
+	{
+		// Hire or dismiss crew for the flagship or an escort
+		// ship.
+		DMS_ModifyCrew (pMS, hStarShip, dy, dx, DoLoop);
+	}
+}
 
-					SpinStarShip (pMS, hSpinShip);
+// Helper function for DoModifyShips(), called every time DoModifyShip() is
+// called when we are in the mode where you can select a ship or empty slot.
+static void
+DMS_NavigateShipSlots (MENU_STATE *pMS, BOOLEAN special, BOOLEAN select,
+		BOOLEAN cancel, SBYTE dx, SBYTE dy)
+{
+	HSHIPFRAG hStarShip = GetEscortByStarShipIndex (pMS->CurState);
 
-					SetContextClipRect (&OldClipRect);
-					SetContext (OldContext);
+	if (dx || dy)
+	{
+		// Moving through the ship slots.
+		BYTE NewState = DMS_MoveCursor (pMS->CurState, dx, dy);
+		if (NewState != pMS->CurState)
+		{
+			pMS->CurState = NewState;
+			DMS_FlashActiveShip(pMS);
+		}
+	}
 
-					if (hStarShip)
-						goto ChangeFlashRect;
+	if (special)
+	{
+		if (DMS_SpinShip (pMS, hStarShip))
+			DMS_SetMode (pMS, DMS_Mode_navigate);
+	}
+	else if (select)
+	{
+		if (hStarShip == 0 && HINIBBLE (pMS->CurState) == 0)
+		{
+			// Select button was pressed over an empty escort
+			// ship slot. Switch to 'add escort ship' mode.
+			pMS->delta_item = MODIFY_CREW_FLAG;
+			DrawRaceStrings (pMS, 0);
+			DMS_SetMode (pMS, DMS_Mode_addEscort);
+		}
+		else
+		{
+			// Select button was pressed over an escort ship or
+			// the flagship. Entering crew editing mode
+			pMS->delta_item |= MODIFY_CREW_FLAG;
+			DMS_SetMode (pMS, DMS_Mode_editCrew);
+		}
+	}
+	else if (cancel) {
+		// Leave escort ship editor.
+		pMS->InputFunc = DoShipyard;
+		pMS->CurState = SHIPYARD_CREW;
+		DrawMenuStateStrings (PM_CREW, pMS->CurState);
+		DMS_SetMode (pMS, DMS_Mode_exit);
+	}
+}
 
-					SetFlashRect (SFR_MENU_3DO);
-				}
-			}
-			else
-#endif
-			if (select || ((pMS->delta_item & MODIFY_CREW_FLAG)
-					&& (dx || dy || cancel)))
-			{
-				COUNT ShipCost[] =
-				{
-					RACE_SHIP_COST
-				};
+/* In this routine, the least significant byte of pMS->CurState is used
+ * to store the current selected ship index
+ * a special case for the row is hi-nibble == -1 (0xf), which specifies
+ * SIS as the selected ship
+ * some bitwise math is still done to scroll through ships, for it to work
+ * ships per row number must divide 0xf0 without remainder
+ */
+static BOOLEAN
+DoModifyShips (MENU_STATE *pMS)
+{
+	if (GLOBAL (CurrentActivity) & CHECK_ABORT)
+	{
+		pMS->InputFunc = DoShipyard;
+		return TRUE;
+	}
 
-				if (hStarShip == 0 && HINIBBLE (pMS->CurState) == 0)
-				{
-					COUNT Index;
+	if (!pMS->Initialized)
+	{
+		pMS->InputFunc = DoModifyShips;
+		pMS->Initialized = TRUE;
+		pMS->CurState = MAKE_BYTE (0, 0xF);
+		pMS->delta_item = 0;
 
-// SetFlashRect (NULL);
-					UnlockMutex (GraphicsLock);
-					if (!(pMS->delta_item & MODIFY_CREW_FLAG))
-					{
-						pMS->delta_item = MODIFY_CREW_FLAG;
-						DrawRaceStrings (pMS, 0);
-						return TRUE;
-					}
-					else if (cancel)
-					{
-						pMS->delta_item ^= MODIFY_CREW_FLAG;
-						LockMutex (GraphicsLock);
-						SetFlashRect (SFR_MENU_3DO);
-						UnlockMutex (GraphicsLock);
-						DrawMenuStateStrings (PM_CREW, SHIPYARD_CREW);
-						SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
-					}
-					else if (select)
-					{
-						Index = GetIndexFromStarShip (&GLOBAL (avail_race_q),
-								GetAvailableRaceFromIndex (
-								LOBYTE (pMS->delta_item)));
-
-						if (GLOBAL_SIS (ResUnits) >= (DWORD)ShipCost[Index]
-								&& CloneShipFragment (Index,
-								&GLOBAL (built_ship_q), 1))
-						{
-							ShowCombatShip (pMS, pMS->CurState, NULL);
-							//Reset flash rectangle
-							LockMutex (GraphicsLock);
-							SetFlashRect (SFR_MENU_3DO);
-							UnlockMutex (GraphicsLock);
-							DrawMenuStateStrings (PM_CREW, SHIPYARD_CREW);
-
-							LockMutex (GraphicsLock);
-							DeltaSISGauges (UNDEFINED_DELTA, UNDEFINED_DELTA,
-									-((int)ShipCost[Index]));
-							r.corner.x = pMS->flash_rect0.corner.x;
-							r.corner.y = pMS->flash_rect0.corner.y + pMS->flash_rect0.extent.height - (6 << RESOLUTION_FACTOR); // JMS_GFX
-							r.extent.width = SHIP_WIN_WIDTH;
-							r.extent.height = 5 << RESOLUTION_FACTOR; // JMS_GFX
-							SetContext (SpaceContext);
-							SetFlashRect (&r);
-							UnlockMutex (GraphicsLock);
-						}
-						else
-						{	// not enough RUs to build
-							PlayMenuSound (MENU_SOUND_FAILURE);
-						}
-						SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN,
-								MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
-							
-						return TRUE;
-					}
-					else
-					{
-						Index = GetAvailableRaceCount ();
-						NewState = LOBYTE (pMS->delta_item);
-						if (dx < 0 || dy < 0)
-						{
-							if (NewState-- == 0)
-								NewState = Index - 1;
-						}
-						else if (dx > 0 || dy > 0)
-						{
-							if (++NewState == Index)
-								NewState = 0;
-						}
-						
-						if (NewState != LOBYTE (pMS->delta_item))
-						{
-							DrawRaceStrings (pMS, NewState);
-							pMS->delta_item = NewState | MODIFY_CREW_FLAG;
-						}
-						
-						return TRUE;
-					}
-					LockMutex (GraphicsLock);
-					goto ChangeFlashRect;
-				}
-				else if (select || cancel)
-				{
-					if ((pMS->delta_item & MODIFY_CREW_FLAG)
-							&& hStarShip != 0)
-					{
-						StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q),
-								hStarShip);
-						if (StarShipPtr->crew_level == 0)
-						{
-							SetFlashRect (NULL);
-							UnlockMutex (GraphicsLock);
-							ShowCombatShip (pMS, pMS->CurState, StarShipPtr);
-							LockMutex (GraphicsLock);
-							UnlockShipFrag (&GLOBAL (built_ship_q),
-									hStarShip);
-							RemoveQueue (&GLOBAL (built_ship_q), hStarShip);
-							FreeShipFrag (&GLOBAL (built_ship_q), hStarShip);
-							// refresh SIS display
-							DeltaSISGauges (UNDEFINED_DELTA, UNDEFINED_DELTA,
-									UNDEFINED_DELTA);
-							r.corner.x = pMS->flash_rect0.corner.x;
-							r.corner.y = pMS->flash_rect0.corner.y;
-							r.extent.width = SHIP_WIN_WIDTH;
-							r.extent.height = SHIP_WIN_HEIGHT;
-							SetContext (SpaceContext);
-							SetFlashRect (&r);
-						}
-						else
-						{
-							UnlockShipFrag (&GLOBAL (built_ship_q),
-									hStarShip);
-						}
-					}
-					
-					if (!(pMS->delta_item ^= MODIFY_CREW_FLAG))
-					{
-						goto ChangeFlashRect;
-					}
-					else if (hStarShip == 0)
-					{
-						SetContext (StatusContext);
-						GetGaugeRect (&r, TRUE);
-						SetFlashRect (&r);
-						SetContext (SpaceContext);
-						SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN,
-								MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
-					}
-					else
-					{
-						r.corner.x = pMS->flash_rect0.corner.x;
-						r.corner.y = pMS->flash_rect0.corner.y + pMS->flash_rect0.extent.height - (6 << RESOLUTION_FACTOR);
-						r.extent.width = SHIP_WIN_WIDTH;
-						r.extent.height = (5 << RESOLUTION_FACTOR); // JMS_GFX
-						SetContext (SpaceContext);
-						SetFlashRect (&r);
-						SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN,
-								MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
-					}
-				}
-				else if (pMS->delta_item & MODIFY_CREW_FLAG)
-				{
-					SIZE crew_delta, crew_bought;
+		SetContext (SpaceContext);
+		DMS_SetMode (pMS, DMS_Mode_navigate);
+	}
+	else
+	{
+		BOOLEAN special = (PulsedInputState.menu[KEY_MENU_SPECIAL] != 0);
+		BOOLEAN select = (PulsedInputState.menu[KEY_MENU_SELECT] != 0);
+		BOOLEAN cancel = (PulsedInputState.menu[KEY_MENU_CANCEL] != 0);
+		SBYTE dx = 0;
+		SBYTE dy = 0;
+		SBYTE DoLoop = 0;
 
-					if (hStarShip)
-						StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q),
-								hStarShip);
-					else
-						StarShipPtr = NULL;  // Keeping compiler quiet.
-
-					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN,
-							MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
-					crew_delta = 0;
-					if (dy < 0)
-					{
-						if (hStarShip == 0)
-						{
-							if (GetCPodCapacity (&r.corner) > GetCrewCount ()
-									&& GLOBAL_SIS (ResUnits) >=
-									(DWORD)GLOBAL (CrewCost))
-							{
-								// Crew dots/rectangles for 1x and 2x resolutions.
-								if (RESOLUTION_FACTOR < 2)
-								{
-									r.extent.width = 1 << RESOLUTION_FACTOR;
-									r.extent.height = r.extent.width;
-									DrawFilledRectangle (&r);
-								}
-								// Crew balls for 4x resolution.
-								else
-								{
-									r.corner.x += 1;
-									r.extent.width = (1 << RESOLUTION_FACTOR) - 2;
-									r.extent.height = 1 << RESOLUTION_FACTOR;
-									DrawFilledRectangle (&r);
-									
-									r.corner.x -= 1;
-									r.corner.y += 1;
-									r.extent.width = 1 << RESOLUTION_FACTOR;
-									r.extent.height = (1 << RESOLUTION_FACTOR) - 2;
-									DrawFilledRectangle (&r);
-									
-									r.corner.y -= 1;
-								}
-								
-								DeltaSISGauges (1, 0, -GLOBAL (CrewCost));
-								crew_delta = 1;
-
-								SetContext (StatusContext);
-								GetGaugeRect (&r, TRUE);
-								SetFlashRect (&r);
-								SetContext (SpaceContext);
-							}
-							else
-							{	// at capacity or not enough RUs
-								PlayMenuSound (MENU_SOUND_FAILURE);
-							}
-						}
-						else
-						{
-							HFLEETINFO hTemplate;
-							FLEET_INFO *TemplatePtr;
-
-							hTemplate = GetStarShipFromIndex (
-									&GLOBAL (avail_race_q),
-									StarShipPtr->race_id);
-							TemplatePtr = LockFleetInfo (
-									&GLOBAL (avail_race_q), hTemplate);
-							if (GLOBAL_SIS (ResUnits) >=
-									(DWORD)GLOBAL (CrewCost)
-									&& StarShipPtr->crew_level <
-									StarShipPtr->max_crew &&
-									StarShipPtr->crew_level <
-									TemplatePtr->crew_level)
-							{
-								if (StarShipPtr->crew_level > 0)
-									DeltaSISGauges (0, 0, -GLOBAL (CrewCost));
-								else
-									DeltaSISGauges (0, 0, -(COUNT)ShipCost[
-											StarShipPtr->race_id]);
-								++StarShipPtr->crew_level;
-								crew_delta = 1;
-								ShowShipCrew (StarShipPtr, &pMS->flash_rect0);
-								r.corner.x = pMS->flash_rect0.corner.x;
-								r.corner.y = pMS->flash_rect0.corner.y
-									+ pMS->flash_rect0.extent.height - (6 << RESOLUTION_FACTOR);
-								r.extent.width = SHIP_WIN_WIDTH;
-								r.extent.height = 5 << RESOLUTION_FACTOR; // JMS_GFX
-								SetContext (SpaceContext);
-								SetFlashRect (&r);
-							}
-							else
-							{	// at capacity or not enough RUs
-								PlayMenuSound (MENU_SOUND_FAILURE);
-							}
-							UnlockFleetInfo (&GLOBAL (avail_race_q),
-									hTemplate);
-						}
-					}
-					else if (dy > 0)
-					{
-						crew_bought = (SIZE)MAKE_WORD (
-								GET_GAME_STATE (CREW_PURCHASED0),
-								GET_GAME_STATE (CREW_PURCHASED1));
-						if (hStarShip == 0)
-						{
-							if (GetCrewCount ())
-							{
-								DeltaSISGauges (-1, 0, GLOBAL (CrewCost)
-										- (crew_bought ==
-										CREW_EXPENSE_THRESHOLD ? 2 : 0));
-								crew_delta = -1;
-
-								GetCPodCapacity (&r.corner);
-								r.extent.width = 1 << RESOLUTION_FACTOR;
-								r.extent.height = r.extent.width;
-								SetContextForeGroundColor (BLACK_COLOR);
-								
-								DrawFilledRectangle (&r);
-
-								SetContext (StatusContext);
-								GetGaugeRect (&r, TRUE);
-								SetFlashRect (&r);
-								SetContext (SpaceContext);
-							}
-							else
-							{	// no crew to dismiss
-								PlayMenuSound (MENU_SOUND_FAILURE);
-							}
-						}
-						else
-						{
-							if (StarShipPtr->crew_level > 0)
-							{
-								if (StarShipPtr->crew_level > 1)
-									DeltaSISGauges (0, 0, GLOBAL (CrewCost)
-											- (crew_bought ==
-											CREW_EXPENSE_THRESHOLD ? 2 : 0));
-								else
-									DeltaSISGauges (0, 0, (COUNT)ShipCost[
-											StarShipPtr->race_id]);
-								crew_delta = -1;
-								--StarShipPtr->crew_level;
-							}
-							else
-							{	// no crew to dismiss
-								PlayMenuSound (MENU_SOUND_FAILURE);
-							}
-							ShowShipCrew (StarShipPtr, &pMS->flash_rect0);
-							r.corner.x = pMS->flash_rect0.corner.x;
-							r.corner.y = pMS->flash_rect0.corner.y
-								+ pMS->flash_rect0.extent.height - (6 << RESOLUTION_FACTOR);
-							r.extent.width = SHIP_WIN_WIDTH;
-							r.extent.height = 5 << RESOLUTION_FACTOR; // JMS_GFX
-							SetContext (SpaceContext);
-							SetFlashRect (&r);
-						}
-					}
+		if (PulsedInputState.menu[KEY_MENU_RIGHT])
+			dx = 1;
+		if (PulsedInputState.menu[KEY_MENU_LEFT])
+			dx = -1;
+		if (PulsedInputState.menu[KEY_MENU_UP])
+			dy = -1;
+		if (PulsedInputState.menu[KEY_MENU_DOWN])
+			dy = 1;
+		if (PulsedInputState.menu[KEY_MENU_PAGE_UP]) 
+			DoLoop = dx = 1;
+		if (PulsedInputState.menu[KEY_MENU_PAGE_DOWN]) 
+			DoLoop = dx = -1;
 
-					if (hStarShip)
-					{
-						UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
-						
-						// clear out the bought ship index
-						// so that flash rects work correctly
-						pMS->delta_item &= MODIFY_CREW_FLAG;
-					}
-					CrewTransaction (crew_delta);
-				}
-			}
-			else if (cancel)
-			{
-				UnlockMutex (GraphicsLock);
 
-				pMS->InputFunc = DoShipyard;
-				pMS->CurState = SHIPYARD_CREW;
-				DrawMenuStateStrings (PM_CREW, pMS->CurState);
-				LockMutex (GraphicsLock);
-				SetFlashRect (SFR_MENU_3DO);
-				UnlockMutex (GraphicsLock);
+		if (!(pMS->delta_item & MODIFY_CREW_FLAG))
+		{
+			// Navigating through the ship slots.
+			DMS_NavigateShipSlots (pMS, special, select, cancel, dx, dy);
+		}
+		else
+		{
+			// Add an escort ship or edit the crew of a ship.
+			HSHIPFRAG hStarShip = GetEscortByStarShipIndex (pMS->CurState);
 
-				return TRUE;
+			if (hStarShip == 0 && HINIBBLE (pMS->CurState) == 0)
+			{
+				// Cursor is over an empty escort ship slot, while we're
+				// in 'add escort ship' mode.
+				DMS_AddEscortShip (pMS, special, select, cancel, dx, dy);
 			}
 			else
 			{
-				pMS->CurState = NewState;
-
-ChangeFlashRect:
-				if (HINIBBLE (pMS->CurState))
-				{
-					pMS->flash_rect0.corner.x =
-							pMS->flash_rect0.corner.y = 0;
-					pMS->flash_rect0.extent.width = SIS_SCREEN_WIDTH;
-					pMS->flash_rect0.extent.height = RES_CASE(61, 122, 295); // JMS_GFX
-				}
-				else
-				{
-					pMS->flash_rect0.corner.x = hangar_x_coords[pMS->CurState % HANGAR_SHIPS_ROW]; // JMS_GFX
-					pMS->flash_rect0.corner.y = HANGAR_Y + (HANGAR_DY *
-							(pMS->CurState / HANGAR_SHIPS_ROW));
-					pMS->flash_rect0.extent.width = SHIP_WIN_WIDTH;
-					pMS->flash_rect0.extent.height = SHIP_WIN_HEIGHT;
-				}
-				SetFlashRect (&pMS->flash_rect0);
+				// Crew editing mode.
+				DMS_EditCrewMode (pMS, hStarShip, select, cancel, dy, dx, DoLoop);
 			}
-			UnlockMutex (GraphicsLock);
 		}
+
 	}
 
 	SleepThread (ONE_SECOND / 30);
@@ -1169,12 +1377,9 @@ DrawBluePrint (MENU_STATE *pMS)
 			DrawShipPiece (ModuleFrame, which_piece, num_frames, TRUE);
 	}
 
-	// JMS_GFX: The lo-res crew pod blueprint retains the lighter color scheme.
-	// Normal blue for hi-res.
 	if (RESOLUTION_FACTOR == 0)
 		SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x1F), 0x09));
-	
+				BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x1F), 0x09));
 	for (num_frames = 0; num_frames < NUM_MODULE_SLOTS; ++num_frames)
 	{
 		BYTE which_piece;
@@ -1192,17 +1397,13 @@ DrawBluePrint (MENU_STATE *pMS)
 		{
 			RECT r;
 			// Crew dots/rectangles for 1x and 2x resolutions.
-			if (RESOLUTION_FACTOR < 2)
-			{
+			if (RESOLUTION_FACTOR < 2) {
 				r.extent.width = 1 << RESOLUTION_FACTOR;
 				r.extent.height = r.extent.width;
 				
 				GetCPodCapacity (&r.corner);
 				DrawFilledRectangle (&r);
-			}
-			// Crew balls for 4x resolution.
-			else
-			{
+			} else {
 				GetCPodCapacity (&r.corner);
 				
 				r.corner.x += 1;
@@ -1252,11 +1453,10 @@ DrawBluePrint (MENU_STATE *pMS)
 
 		r.extent.width = (3 << RESOLUTION_FACTOR) + RESOLUTION_FACTOR; // JMS_GFX
 		r.extent.height = 1; // JMS_GFX
-		
 		while (FuelVolume)
 		{
 			COUNT m;
-			
+
 			// JMS_GFX
 			COUNT slotNr = 0;
 			DWORD compartmentNr = 0;
@@ -1291,6 +1491,7 @@ DrawBluePrint (MENU_STATE *pMS)
 				moduleType = GLOBAL_SIS (ModuleSlots[slotNr]);
 				volume = GetModuleFuelCapacity (moduleType);
 			}
+
 				
 			GetFTankCapacity (&r.corner);
 			//log_add(log_Debug, "volume on %u, hefueltankcapacity %u", volume, HEFUEL_TANK_CAPACITY);
@@ -1340,7 +1541,6 @@ DoShipyard (MENU_STATE *pMS)
 
 			pMS->hMusic = LoadMusic (SHIPYARD_MUSIC);
 
-			LockMutex (GraphicsLock);
 			SetTransitionSource (NULL);
 			BatchGraphics ();
 			DrawSISFrame ();
@@ -1348,12 +1548,10 @@ DoShipyard (MENU_STATE *pMS)
 			DrawSISTitle (GAME_STRING (STARBASE_STRING_BASE));
 			SetContext (SpaceContext);
 			DrawBluePrint (pMS);
-			UnlockMutex (GraphicsLock);
 
 			pMS->CurState = SHIPYARD_CREW;
 			DrawMenuStateStrings (PM_CREW, pMS->CurState);
 
-			LockMutex (GraphicsLock);
 			SetContext (SpaceContext);
 			s.origin.x = 0;
 			s.origin.y = 0;
@@ -1378,7 +1576,6 @@ DoShipyard (MENU_STATE *pMS)
 
 			ScreenTransition (3, NULL);
 			UnbatchGraphics ();
-			UnlockMutex (GraphicsLock);
 
 			PlayMusic (pMS->hMusic, TRUE, 1);
 
@@ -1386,9 +1583,7 @@ DoShipyard (MENU_STATE *pMS)
 
 			SetInputCallback (on_input_frame);
 
-			LockMutex (GraphicsLock);
 			SetFlashRect (SFR_MENU_3DO);
-			UnlockMutex (GraphicsLock);
 		}
 
 		pMS->Initialized = TRUE;
@@ -1398,12 +1593,10 @@ DoShipyard (MENU_STATE *pMS)
 ExitShipyard:
 		SetInputCallback (NULL);
 
-		LockMutex (GraphicsLock);
 		DestroyDrawable (ReleaseDrawable (pMS->ModuleFrame));
 		pMS->ModuleFrame = 0;
 		DestroyColorMap (ReleaseColorMap (pMS->CurString));
 		pMS->CurString = 0;
-		UnlockMutex (GraphicsLock);
 
 		return FALSE;
 	}
@@ -1420,9 +1613,7 @@ ExitShipyard:
 			if (!GameOptions ())
 				goto ExitShipyard;
 			DrawMenuStateStrings (PM_CREW, pMS->CurState);
-			LockMutex (GraphicsLock);
 			SetFlashRect (SFR_MENU_3DO);
-			UnlockMutex (GraphicsLock);
 		}
 	}
 	else
diff -ruNp src.hd/uqm/sis.c src/uqm/sis.c
--- src.hd/uqm/sis.c	2017-12-29 02:25:54 -0800
+++ src/uqm/sis.c	2017-12-29 00:57:53 -0800
@@ -16,14 +16,11 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "sis.h"
 
 #include "colors.h"
 #include "races.h"
-// XXX: including encount.h for stuff that does not belong there
-#include "encount.h"
+#include "starmap.h"
 #include "units.h"
 #include "menustat.h"
 		// for DrawMenuStateStrings()
@@ -34,8 +31,10 @@
 #include "element.h"
 #include "setup.h"
 #include "state.h"
+#include "flash.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/tasklib.h"
+#include "libs/alarm.h"
 #include "libs/log.h"
 
 #include <stdio.h>
@@ -101,9 +100,7 @@ ClearSISRect (BYTE ClearFlags)
 
 	if (ClearFlags & CLEAR_SIS_RADAR)
 	{
-		UnlockMutex (GraphicsLock);
 		DrawMenuStateStrings ((BYTE)~0, 1);
-		LockMutex (GraphicsLock);
 #ifdef NEVER
 		r.corner.x = RADAR_X - 1;
 		r.corner.y = RADAR_Y - 1;
@@ -217,7 +214,7 @@ DrawSISMessageEx (const UNICODE *pStr, S
 				pStr = buf;
 				break;
 			case IN_HYPERSPACE:
-				if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
+				if (inHyperSpace ())
 				{
 					pStr = GAME_STRING (NAVIGATION_STRING_BASE);
 							// "HyperSpace"
@@ -350,9 +347,27 @@ void
 DateToString (char *buf, size_t bufLen,
 		BYTE month_index, BYTE day_index, COUNT year_index)
 {
-	snprintf (buf, bufLen, "%s %02d" STR_MIDDLE_DOT "%04d",
-			GAME_STRING (MONTHS_STRING_BASE + month_index - 1),
-			day_index, year_index);
+	switch (optDateFormat) {
+		case 1: /* MM.DD.YYYY */
+			snprintf (buf, bufLen, "%02d%s%02d%s%04d", month_index,
+					STR_MIDDLE_DOT, day_index, STR_MIDDLE_DOT, year_index);
+			break;
+		case 2: /* DD MMM YYYY */
+			snprintf (buf, bufLen, "%02d %s%s%04d", day_index,
+					GAME_STRING (MONTHS_STRING_BASE + month_index - 1),
+					STR_MIDDLE_DOT, year_index);
+			break;
+		case 3: /* DD.MM.YYYY */
+			snprintf (buf, bufLen, "%02d%s%02d%s%04d", day_index,
+					STR_MIDDLE_DOT, month_index, STR_MIDDLE_DOT, year_index);
+			break;
+		case 0:
+		default: /* MMM DD.YYYY */
+			snprintf (buf, bufLen, "%s %02d%s%04d",
+					GAME_STRING (MONTHS_STRING_BASE + month_index - 1),
+					day_index, STR_MIDDLE_DOT, year_index);
+			break;
+	}
 }
 
 void
@@ -399,16 +414,13 @@ DrawStatusMessage (const UNICODE *pStr)
 		}
 		else if (curMsgMode == SMM_RES_UNITS)
 		{
-			if (GET_GAME_STATE (CHMMR_BOMB_STATE) > 2 || GLOBAL_SIS (ResUnits) > 2000000L)
-			{
+			if (GET_GAME_STATE (CHMMR_BOMB_STATE) > 2 || GLOBAL_SIS (ResUnits) > 2000000L) {
 				snprintf (buf, sizeof buf, "%s %s",
 						(optWhichMenu == OPT_PC) ?
 							GAME_STRING (STATUS_STRING_BASE + 2)
 							: STR_INFINITY_SIGN, // "UNLIMITED"
 						GAME_STRING (STATUS_STRING_BASE + 1)); // "RU"
-			}
-			else
-			{
+			} else {
 				snprintf (buf, sizeof buf, "%u %s", GLOBAL_SIS (ResUnits),
 						GAME_STRING (STATUS_STRING_BASE + 1)); // "RU"
 			}
@@ -424,24 +436,21 @@ DrawStatusMessage (const UNICODE *pStr)
 	}
 
 	t.baseline.x = STATUS_MESSAGE_WIDTH >> 1;
-	t.baseline.y = STATUS_MESSAGE_HEIGHT - RES_CASE(1,4,6); // JMS_GFX
+	t.baseline.y = STATUS_MESSAGE_HEIGHT - RES_CASE(1,4,5); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.pStr = pStr;
 	t.CharCount = (COUNT)~0;
 
-	SetContextFont (TinyFont);
-
-	if (curMsgMode == SMM_WARNING)
-	{
+	if (curMsgMode == SMM_WARNING) {
 		SetContextForeGroundColor (STATUS_MESSAGE_WARNING_TEXT_COLOR);
-	} else if (curMsgMode == SMM_ALERT)
-	{
+	} else if (curMsgMode == SMM_ALERT) {
 		SetContextForeGroundColor (STATUS_MESSAGE_ALERT_TEXT_COLOR);
-	} else
-	{
+	} else {
 		SetContextForeGroundColor (STATUS_MESSAGE_TEXT_COLOR);
 	}
 
+	SetContextFont (TinyFont);
+	SetContextForeGroundColor (STATUS_MESSAGE_TEXT_COLOR);
 	font_DrawText (&t);
 	UnbatchGraphics ();
 
@@ -470,10 +479,10 @@ DrawCaptainsName (void)
 	OldContext = SetContext (StatusContext);
 	OldFont = SetContextFont (TinyFont);
 	OldColor = SetContextForeGroundColor (CAPTAIN_NAME_BACKGROUND_COLOR);
-	
-	r.corner.x = RES_STAT_SCALE(3) - RES_CASE(0,3,5);		// JMS_GFX
+
+	r.corner.x = RES_STAT_SCALE(3) - RES_CASE(0,2,5);		// JMS_GFX
 	r.corner.y = RES_CASE(10,20,32);						// JMS_GFX
-	r.extent.width = SHIP_NAME_WIDTH - RES_CASE(2,1,0);		// JMS_GFX
+	r.extent.width = SHIP_NAME_WIDTH - RES_CASE(2,2,0);		// JMS_GFX
 	r.extent.height = SHIP_NAME_HEIGHT + RESOLUTION_FACTOR;	// JMS_GFX
 	DrawFilledRectangle (&r);
 
@@ -518,7 +527,7 @@ DrawFlagshipName (BOOLEAN InStatusArea)
 		OldContext = SetContext (SpaceContext);
 		OldFont = SetContextFont (MicroFont);
 
-		r.corner.x = RES_CASE(0,24,0);						 // JMS_GFX
+		r.corner.x = RES_CASE(0,24,0);
 		r.corner.y = 1;
 		r.extent.width = SIS_SCREEN_WIDTH - RES_CASE(0,24,0); // JMS_GFX
 		r.extent.height = SHIP_NAME_HEIGHT + RES_CASE(0,1,6);// JMS_GFX
@@ -528,8 +537,8 @@ DrawFlagshipName (BOOLEAN InStatusArea)
 				GAME_STRING (NAMING_STRING_BASE + 1), GLOBAL_SIS (ShipName));
 		// XXX: this will not work with UTF-8 strings
 		strupr (buf);
-        
-        // JMS: Handling the a-umlaut and o-umlaut characters
+
+		// JMS: Handling the a-umlaut and o-umlaut characters
         {
             unsigned char *ptr;
             ptr = (unsigned char*)buf;
@@ -766,13 +775,12 @@ DrawLanders (void)
 	GetFrameRect (s.frame, &r);
 
 	i = GLOBAL_SIS (NumLanders);
-	r.corner.x = (STATUS_WIDTH >> 1) - r.corner.x;
-	s.origin.x = r.corner.x - (((r.extent.width * i) + (2 * (i - 1))) >> 1) + RES_CASE(0,1,0);
+	r.corner.x = (STATUS_WIDTH >> 1) - r.corner.x + RES_CASE(0,0,16);
+	s.origin.x = r.corner.x - (((r.extent.width * i) + (2 * (i - 1))) >> 1) + RES_CASE(0,1,-16);
 	s.origin.y = RES_STAT_SCALE(29) + RES_CASE(0,0,2); // JMS_GFX
 
 	width = r.extent.width + 2;
-	r.extent.width = (r.extent.width * MAX_LANDERS) + 
-		(2 * (MAX_LANDERS - 1)) + RES_CASE (2,2,-14); // JMS_GFX
+	r.extent.width = (r.extent.width * MAX_LANDERS) + (2 * (MAX_LANDERS - 1)) + RES_CASE(2,2,-16); // JMS_GFX
 	r.corner.x -= r.extent.width >> 1;
 	r.corner.y += s.origin.y;
 	SetContextForeGroundColor (BLACK_COLOR);
@@ -795,65 +803,54 @@ DrawStorageBays (BOOLEAN Refresh)
 	CONTEXT OldContext;
 
 	OldContext = SetContext (StatusContext);
+
 	r.extent.width  = RES_STAT_SCALE(2); // JMS_GFX
 	r.extent.height = RES_STAT_SCALE(4); // JMS_GFX
 	r.corner.y		= RES_STAT_SCALE(123) + RES_CASE(0,8,23); // JMS_GFX
-	
 	if (Refresh)
 	{
 		r.extent.width = NUM_MODULE_SLOTS * (r.extent.width + 1);
 		r.corner.x = (STATUS_WIDTH >> 1) - (r.extent.width >> 1) + RES_CASE(0,2,2);
-		
+
 		SetContextForeGroundColor (BLACK_COLOR);
 		DrawFilledRectangle (&r);
 		r.extent.width = RES_STAT_SCALE(2); // JMS_GFX
 	}
-	
+
 	i = (BYTE)CountSISPieces (STORAGE_BAY);
-	
 	if (i)
 	{
 		COUNT j;
-		
+
 		r.corner.x = (STATUS_WIDTH >> 1) - ((i * (r.extent.width + RES_STAT_SCALE(1))) >> 1) + RES_CASE(0,2,2);
-		
-		// Draw full bays.
 		SetContextForeGroundColor (STORAGE_BAY_FULL_COLOR);
-		for (j = GLOBAL_SIS (TotalElementMass); j >= STORAGE_BAY_CAPACITY; j -= STORAGE_BAY_CAPACITY)
+		for (j = GLOBAL_SIS (TotalElementMass);
+				j >= STORAGE_BAY_CAPACITY; j -= STORAGE_BAY_CAPACITY)
 		{
 			DrawFilledRectangle (&r);
 			r.corner.x += r.extent.width + RES_STAT_SCALE(1); // JMS_GFX;
-			
+
 			--i;
 		}
-		
-		// This sets how full a partially filled bay is.
+
 		r.extent.height = (RES_STAT_SCALE (4) * j + (STORAGE_BAY_CAPACITY - 1)) / STORAGE_BAY_CAPACITY;
-		
 		if (r.extent.height)
 		{
-			// Filled part of the bay.
 			r.corner.y += RES_STAT_SCALE (4) - r.extent.height;
-			//r.corner.y += 4 - r.extent.height;
 			DrawFilledRectangle (&r);
-			
-			//
 			r.extent.height = RES_STAT_SCALE(4) - r.extent.height;
-			// r.extent.height = 4 - r.extent.height;
 			if (r.extent.height)
 			{
 				r.corner.y = RES_STAT_SCALE(123) + RES_CASE(0,8,23);
 				SetContextForeGroundColor (STORAGE_BAY_EMPTY_COLOR);
 				DrawFilledRectangle (&r);
 			}
-			
 			r.corner.x += r.extent.width + RES_STAT_SCALE(1);
-			
+
 			--i;
 		}
-		
-		// Draw totally empty bays.
 		r.extent.height = RES_STAT_SCALE(4);
+
 		SetContextForeGroundColor (STORAGE_BAY_EMPTY_COLOR);
 		while (i--)
 		{
@@ -861,7 +858,7 @@ DrawStorageBays (BOOLEAN Refresh)
 			r.corner.x += r.extent.width + RES_STAT_SCALE(1);
 		}
 	}
-	
+
 	SetContext (OldContext);
 }
 
@@ -900,7 +897,7 @@ DrawPC_SIS (void)
 	font_DrawText (&t);
 
 	// Black rectangle behind "CREW" text and crew amount.
-	r.corner.y += RES_STAT_SCALE(79) + RES_CASE(0,12,18); // JMS_GFX
+	r.corner.y += RES_STAT_SCALE(79) + RES_CASE(0,12,19); // JMS_GFX
 	t.baseline.y += RES_STAT_SCALE(79) + RES_CASE(0,9,18); // JMS_GFX
 	DrawFilledRectangle (&r);
 
@@ -991,7 +988,6 @@ DrawModules (void)
 	}
 }
 
-// Pre: GraphicsLock is unlocked
 static void
 DrawSupportShips (void)
 {
@@ -1017,9 +1013,7 @@ DrawSupportShips (void)
 			+ ((pship_pos - ship_pos) % 2 ? RES_CASE(0,3,5) : RES_CASE(0,-2,-2)); // JMS_GFX
 		s.origin.y = RES_STAT_SCALE(pship_pos->y) + RES_CASE(0,5,0); // JMS_GFX
 		s.frame = SetAbsFrameIndex (StarShipPtr->icons, 2);
-		LockMutex (GraphicsLock);
 		DrawStamp (&s);
-		UnlockMutex (GraphicsLock);
 
 		UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 	}
@@ -1105,10 +1099,16 @@ DeltaSISGauges_fuelDelta (SIZE fuel_delt
 	if (new_coarse_fuel != old_coarse_fuel)
 	{
 		TEXT t;
-		UNICODE buf[60];
+		// buf from [60] to [4]: The max fuel anyone can ever get is 1610
+		// I.E. only 4 characters, we don't need that much extra padding.
+		UNICODE buf[4];
 		RECT r;
 
-		snprintf (buf, sizeof buf, "%u", new_coarse_fuel);
+		if(!optInfiniteFuel)
+			snprintf (buf, sizeof buf, "%u", new_coarse_fuel);
+		else
+			snprintf (buf, sizeof buf, "%s", STR_INFINITY_SIGN);
+
 
 		GetGaugeRect (&r, FALSE);
 		
@@ -1168,7 +1168,8 @@ DeltaSISGauges (SIZE crew_delta, SIZE fu
 	OldContext = SetContext (StatusContext);
 
 	BatchGraphics ();
-	if (crew_delta == UNDEFINED_DELTA) {
+	if (crew_delta == UNDEFINED_DELTA)
+	{
 		STAMP s;
 		s.origin.x = 0;
 		s.origin.y = 0;
@@ -1191,9 +1192,7 @@ DeltaSISGauges (SIZE crew_delta, SIZE fu
 		DrawTurningJets ();
 		DrawModules ();
 
-		UnlockMutex (GraphicsLock);
 		DrawSupportShips ();
-		LockMutex (GraphicsLock);
 		// JMS: In conjunction with the JMS lines above.
 		SetContextForeGroundColor (OldColor);
 	}
@@ -1290,12 +1289,7 @@ GetCrewPodForCrewMember (COUNT crewNr, C
 COUNT
 GetCPodCapacity (POINT *ppt)
 {
-	COUNT crewCount;
-	COUNT slotNr;
-	COUNT seatNr;
-
-	COUNT rowNr;
-	COUNT colNr;
+	COUNT crewCount, slotNr, seatNr, rowNr, colNr;
 	COUNT ship_piece_offset_scaled = SHIP_PIECE_OFFSET + RES_CASE(0,1,1);  // JMS_GFX
 				
 	static const Color crewRows[] = PC_CREW_COLOR_TABLE;
@@ -1394,12 +1388,7 @@ GetStorageCellForMineralUnit (COUNT unit
 COUNT
 GetSBayCapacity (POINT *ppt)
 {
-	COUNT massCount;
-	COUNT slotNr;
-	COUNT cellNr;
-
-	COUNT rowNr;
-	COUNT colNr;
+	COUNT massCount, slotNr, cellNr, rowNr, colNr;
 	COUNT ship_piece_offset_scaled = SHIP_PIECE_OFFSET + RES_CASE(0,1,1);  // JMS_GFX
 				
 	static const Color colorBars[] = STORAGE_BAY_COLOR_TABLE;
@@ -1505,15 +1494,9 @@ GetFuelTankForFuelUnit (DWORD unitNr, CO
 DWORD
 GetFTankCapacity (POINT *ppt)
 {
-	DWORD capacity;
-	DWORD fuelAmount;
+	DWORD capacity, rowNr, fuelAmount, compartmentNr, volume, volumehelper;
 	COUNT slotNr;
-	DWORD compartmentNr;
 	BYTE moduleType;
-	DWORD volume;
-	DWORD volumehelper;
-
-	DWORD rowNr;
 	COUNT ship_piece_offset_scaled = SHIP_PIECE_OFFSET + RES_CASE(0,1,1);  // JMS_GFX
 	
 	static const Color fuelColors[] = FUEL_COLOR_TABLE;
@@ -1535,8 +1518,7 @@ GetFTankCapacity (POINT *ppt)
 
 	moduleType = GLOBAL_SIS (ModuleSlots[slotNr]);
 	volume = GetModuleFuelCapacity (moduleType);
-	
-	// JMS_GFX
+
 	if (volume == FUEL_TANK_CAPACITY)
 		volumehelper = (volume * 10) / RES_CASE(10,22,22);
 	else
@@ -1544,20 +1526,17 @@ GetFTankCapacity (POINT *ppt)
 
 	rowNr = ((volumehelper - compartmentNr) * MAX_FUEL_BARS / HEFUEL_TANK_CAPACITY);
 	ppt->x = (21 << RESOLUTION_FACTOR) + (slotNr * ship_piece_offset_scaled);
-	if (volume == FUEL_TANK_CAPACITY)
-	{
+	if (volume == FUEL_TANK_CAPACITY) {
 		ppt->x += RES_CASE(0,20,54); // JMS_GFX
 		ppt->y = (27 << RESOLUTION_FACTOR) - rowNr + RES_CASE(0,11,27); // JMS_GFX
-	}
-	else
-	{
+	} else {
 		ppt->x += RES_CASE(0,20,53); // JMS_GFX
 		ppt->y = (30 << RESOLUTION_FACTOR) - rowNr + RES_CASE(0,21,43); // JMS_GFX
 	}
 	
 	rowNr = ((volume - compartmentNr) * 10 * MAX_FUEL_BARS / HEFUEL_TANK_CAPACITY) /
 		MAX_FUEL_BARS;
-	
+
 	assert (rowNr + 1 < (COUNT) (sizeof fuelColors / sizeof fuelColors[0]));
 	SetContextForeGroundColor (fuelColors[rowNr]);
 	SetContextBackGroundColor (fuelColors[rowNr + 1]);
@@ -1661,248 +1640,158 @@ DrawAutoPilotMessage (BOOLEAN Reset)
 }
 
 
-Task flash_task = 0;
-RECT flash_rect;
-static FRAME flash_screen_frame = 0;
-		// The original contents of the flash rectangle.
-static int flash_changed;
-Mutex flash_mutex = 0;
-
-static int
-flash_rect_func (void *data)
-{
-#define NORMAL_STRENGTH 4
-#define NORMAL_F_STRENGTH 0
-#define CACHE_SIZE 10
-	DWORD TimeIn;
-	const DWORD WaitTime = ONE_SECOND / 16;
-	SIZE strength;
-	RECT cached_rect = {{0, 0}, {0, 0}};
-	FRAME cached_screen_frame = 0;
-	Task task = (Task)data;
-	bool cached[CACHE_SIZE];
-	STAMP cached_stamp[CACHE_SIZE];
-	int i;
-
-	// Init cache
-	for (i = 0; i < CACHE_SIZE; i++)
-	{
-		cached[i] = false;
-		cached_stamp[i].frame = 0;
-	}
-
-	strength = NORMAL_STRENGTH;
-	TimeIn = GetTimeCounter ();
-	while (!Task_ReadState(task, TASK_EXIT))
-	{
-		CONTEXT OldContext;
-
-		LockMutex (flash_mutex);
-		if (flash_changed)
-		{
-			cached_rect = flash_rect;
-			if (cached_screen_frame)
-				DestroyDrawable (ReleaseDrawable (cached_screen_frame));
-			flash_changed = 0;
-			//  Wait for the  flash_screen_frame to get initialized
-			FlushGraphics ();
-			cached_screen_frame = CaptureDrawable (
-					CloneFrame (flash_screen_frame));
-			UnlockMutex (flash_mutex);
-
-			// Clear the cache.
-			for (i = 0; i < CACHE_SIZE; i++)
-			{
-				cached[i] = false;
-				if (cached_stamp[i].frame)
-					DestroyDrawable (ReleaseDrawable (cached_stamp[i].frame));
-				cached_stamp[i].frame = 0;
-			}
-		}
-		else
-			UnlockMutex (flash_mutex);
-		
-		if (cached_rect.extent.width)
-		{
-			STAMP *pStamp;
-
-#define MIN_STRENGTH 4
-#define MAX_STRENGTH 6
-			strength += 2;
-			if (strength > MAX_STRENGTH)
-				strength = MIN_STRENGTH;
-			if (cached[strength - MIN_STRENGTH])
-				pStamp = &cached_stamp[strength - MIN_STRENGTH];
-			else
-			{
-				pStamp = &cached_stamp[strength - MIN_STRENGTH];
-				cached[strength - MIN_STRENGTH] = true;
-				pStamp->frame = CaptureDrawable (
-						CloneFrame (cached_screen_frame));
-				pStamp->origin.x = 0;
-				pStamp->origin.y = 0;
-
-				if (strength != 4)
-				{	// brighten the frame with an additive
-					DrawMode oldMode;
-					STAMP s;
-					int factor;
-
-					s.origin.x = 0;
-					s.origin.y = 0;
-					s.frame = cached_screen_frame;
-
-					factor = (strength - MIN_STRENGTH) * DRAW_FACTOR_1 / 4;
-
-					LockMutex (GraphicsLock);
-					OldContext = SetContext (OffScreenContext);
-					SetContextFGFrame (pStamp->frame);
-					SetContextClipRect (NULL);
-					oldMode	= SetContextDrawMode (MAKE_DRAW_MODE (
-							DRAW_ADDITIVE, factor));
-					DrawStamp (&s);
-					SetContextDrawMode (oldMode);
-					SetContext (OldContext);
-					UnlockMutex (GraphicsLock);
-				}
-			}
+static FlashContext *flashContext = NULL;
+static RECT flash_rect;
+static Alarm *flashAlarm = NULL;
+static BOOLEAN flashPaused = FALSE;
 
-			LockMutex (GraphicsLock);
-			OldContext = SetContext (ScreenContext);
-			SetContextClipRect (&cached_rect);
-			// flash changed_can't be modified while GraphicSem is held
-			if (!flash_changed)
-				DrawStamp (pStamp);
-			// XXX: Shouldn't we save and restore the original cliprect?
-			SetContextClipRect (NULL);
-			SetContext (OldContext);
-			UnlockMutex (GraphicsLock);
-		}
-		FlushGraphics ();
-		SleepThreadUntil (TimeIn + WaitTime);
-		TimeIn = GetTimeCounter ();
-	}
+static void scheduleFlashAlarm (void);
 
-	// Clear cache
-	{
-		if (cached_screen_frame)
-			DestroyDrawable (ReleaseDrawable (cached_screen_frame));
+static void
+updateFlashRect (void *arg)
+{
+	if (flashContext == NULL)
+		return;
 
-		for (i = 0; i < CACHE_SIZE; i++)
-		{
-			if(cached_stamp[i].frame)
-				DestroyDrawable (ReleaseDrawable (cached_stamp[i].frame));
-		}
-	}
-	LockMutex (flash_mutex);
-	flash_task = 0;
-	UnlockMutex (flash_mutex);
+	Flash_process (flashContext);
+	scheduleFlashAlarm ();
+	(void) arg;
+}
 
-	FinishTask (task);
-	return 0;
+static void
+scheduleFlashAlarm (void)
+{
+	TimeCount nextTime = Flash_nextTime (flashContext);
+	DWORD nextTimeMs = (nextTime / ONE_SECOND) * 1000 +
+			((nextTime % ONE_SECOND) * 1000 / ONE_SECOND);
+			// Overflow-safe conversion.
+	flashAlarm = Alarm_addAbsoluteMs (nextTimeMs, updateFlashRect, NULL);
 }
 
 void
-SetFlashRect (RECT *pRect)
+SetFlashRect (const RECT *pRect)
 {
 	RECT clip_r = {{0, 0}, {0, 0}};
-	RECT temp_r, flash_rect1, old_r;
-	CONTEXT OldContext;
-	int create_flash = 0;
-
-	if (!flash_mutex)
-		flash_mutex = CreateMutex ("FlashRect Lock",
-				SYNC_CLASS_TOPLEVEL | SYNC_CLASS_VIDEO);
-
-	old_r = flash_rect;
-	flash_rect1 = flash_rect;
-		
+	RECT temp_r;
+	
 	if (pRect != SFR_MENU_3DO && pRect != SFR_MENU_ANY)
 	{
+		// The caller specified their own flash area, or NULL (stop flashing).
 		GetContextClipRect (&clip_r);
-		OldContext = SetContext (ScreenContext);
 	}
 	else
 	{
-		//Don't flash when using the PC menu
  		if (optWhichMenu == OPT_PC && pRect != SFR_MENU_ANY)
  		{
- 			OldContext = SetContext (ScreenContext);
+			// The player wants PC menus and this flash is not used
+			// for a PC menu.
+			// Don't flash.
  			pRect = 0;
  		}
  		else
  		{
- 			OldContext = SetContext (StatusContext);
+			// The player wants 3DO menus, or the flash is used in both
+			// 3DO and PC mode.
+			CONTEXT OldContext = SetContext (StatusContext);
  			GetContextClipRect (&clip_r);
  			pRect = &temp_r;
  			temp_r.corner.x = RADAR_X - clip_r.corner.x;
  			temp_r.corner.y = RADAR_Y - clip_r.corner.y;
  			temp_r.extent.width = RADAR_WIDTH;
  			temp_r.extent.height = RADAR_HEIGHT;
- 			SetContext (ScreenContext);
+ 			SetContext (OldContext);
 		}
 	}
 
-	if (pRect == 0 || pRect->extent.width == 0)
+	if (pRect != 0 && pRect->extent.width != 0)
 	{
-		// End the flashing.
-		flash_rect1.extent.width = 0;
-		if (flash_task)
+		// Flash rectangle is not empty, start or continue flashing.
+		flash_rect = *pRect;
+		flash_rect.corner.x += clip_r.corner.x;
+		flash_rect.corner.y += clip_r.corner.y;
+
+		if (flashContext == NULL)
 		{
-			UnlockMutex (GraphicsLock);
-			ConcludeTask (flash_task);
-			LockMutex (GraphicsLock);
+			// Create a new flash context.
+			flashContext = Flash_createHighlight (ScreenContext, &flash_rect);
+			Flash_setMergeFactors(flashContext, 3, 2, 2);
+			Flash_setSpeed (flashContext, 0, ONE_SECOND / 16, 0, ONE_SECOND / 16);
+			Flash_setFrameTime (flashContext, ONE_SECOND / 16);
+			Flash_start (flashContext);
+			scheduleFlashAlarm ();
+		}
+		else
+		{
+			// Reuse an existing flash context
+			Flash_setRect (flashContext, &flash_rect);
 		}
 	}
 	else
 	{
-		flash_rect1 = *pRect;
-		flash_rect1.corner.x += clip_r.corner.x;
-		flash_rect1.corner.y += clip_r.corner.y;
-		create_flash = 1;
+		// Flash rectangle is empty. Stop flashing.
+		if (flashContext != NULL)
+		{
+			Alarm_remove(flashAlarm);
+			flashAlarm = 0;
+			
+			Flash_terminate (flashContext);
+			flashContext = NULL;
+		}
 	}
-	
-	LockMutex (flash_mutex);
-	flash_rect = flash_rect1;
+}
 
-	if (old_r.extent.width && !rectsEqual (old_r, flash_rect))
+COUNT updateFlashRectRecursion = 0;
+// XXX This is necessary at least because DMS_AddEscortShip() calls
+// DrawRaceStrings() in an UpdateFlashRect block, which calls
+// ClearSISRect(), which calls DrawMenuStateStrings(), which starts its own
+// UpdateFlashRect block. This should probably be cleaned up.
+
+void
+PreUpdateFlashRect (void)
+{
+	if (flashAlarm)
 	{
-		// We had a flash rectangle, and now a different one is set.
-		if (flash_screen_frame)
-		{
-			// The screen contents may have changed; we grab a new copy.
-			STAMP old_s;
-			old_s.origin.x = old_r.corner.x;
-			old_s.origin.y = old_r.corner.y;
-			old_s.frame = flash_screen_frame;
-			DrawStamp (&old_s);
-			DestroyDrawable (ReleaseDrawable (flash_screen_frame));
-			flash_screen_frame = 0;
-		}
-		else
-			log_add (log_Debug, "Couldn't locate flash_screen_rect");
+		updateFlashRectRecursion++;
+		if (updateFlashRectRecursion > 1)
+			return;
+		Flash_preUpdate (flashContext);
 	}
-	
-	if (flash_rect.extent.width)
+}
+
+void
+PostUpdateFlashRect (void)
+{
+	if (flashAlarm)
 	{
-		// A new flash rectangle is set.
-		// Copy the original contents of the rectangle from the screen.
-		if (flash_screen_frame)
-			DestroyDrawable (ReleaseDrawable (flash_screen_frame));
-		flash_screen_frame =
-				CaptureDrawable (LoadDisplayPixmap (&flash_rect, (FRAME)0));
-	}
-	flash_changed = 1;
-	UnlockMutex (flash_mutex);
-	// we create the thread after the LoadDisplayPixmap()
-	// so there is no race between the FlushGraphics in flash_task
-	// and the Enqueue in LoadDisplayPixmap()
-	if (create_flash && flash_task == 0)
+		updateFlashRectRecursion--;
+		if (updateFlashRectRecursion > 0)
+			return;
+
+		Flash_postUpdate (flashContext);
+	}
+}
+
+// Stop flashing if flashing is active.
+void
+PauseFlash (void)
+{
+	if (flashContext != NULL)
 	{
-		flash_task = AssignTask (flash_rect_func, 2048,
-				"flash rectangle");
+		Alarm_remove(flashAlarm);
+		flashAlarm = 0;
+		flashPaused = TRUE;
 	}
+}
 
-	SetContext (OldContext);
+// Continue flashing after PauseFlash (), if flashing was active.
+void
+ContinueFlash (void)
+{
+	if (flashPaused)
+	{
+		scheduleFlashAlarm ();
+		flashPaused = FALSE;
+	}
 }
 
+
diff -ruNp src.hd/uqm/sis.h src/uqm/sis.h
--- src.hd/uqm/sis.h	2017-12-29 02:25:54 -0800
+++ src/uqm/sis.h	2017-12-29 00:57:53 -0800
@@ -14,8 +14,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #ifndef SIS_H_INCL__
 #define SIS_H_INCL__
 
@@ -26,6 +24,10 @@
 #include "units.h"
                 // for RESOLUTION_FACTOR
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #define CLEAR_SIS_RADAR (1 << 2)
 #define DRAW_SIS_DISPLAY (1 << 3)
 
@@ -50,7 +52,6 @@
 #define MAX_FUEL_BARS RES_CASE(10,40,80)
 #define FUEL_VOLUME_PER_ROW (HEFUEL_TANK_CAPACITY / MAX_FUEL_BARS)
 #define FUEL_RESERVE (10 * FUEL_TANK_SCALE) // JMS_GFX
-
 #define FUEL_COST_RU 20 // JMS
 
 #define IP_SHIP_THRUST_INCREMENT 8
@@ -78,7 +79,7 @@ enum
 	CANNON_WEAPON,
 	TRACKING_SYSTEM,
 	ANTIMISSILE_DEFENSE,
-	
+
 	NUM_PURCHASE_MODULES,
 
 	BOMB_MODULE_0 = NUM_PURCHASE_MODULES,
@@ -130,8 +131,7 @@ enum
 	{3 + 42, 30 + (5 * 16)},
 
 #define SIS_NAME_SIZE 16
-#define SAVE_NAME_SIZE 32 // JMS
-#define SAVE_NAME_CHECKER "superbutcherX !" // JMS
+#define SAVE_NAME_CHECKER "MegaMod" // JMS
 #define SAVE_CHECKER_SIZE SIS_NAME_SIZE
 
 typedef struct
@@ -159,29 +159,6 @@ typedef struct
 	UNICODE PlanetName[SIS_NAME_SIZE];
 } SIS_STATE;
 
-// XXX: Theoretically, a player can have 17 devices on board without
-//   cheating. We only provide
-//   room for 16 below, which is not really a problem since this
-//   is only used for displaying savegame summaries. There is also
-//   room for only 16 devices on screen.
-#define MAX_EXCLUSIVE_DEVICES 16
-
-typedef struct
-{
-	UNICODE SaveNameChecker[SAVE_CHECKER_SIZE]; // JMS
-	UNICODE SaveName[SAVE_NAME_SIZE]; // JMS
-	SIS_STATE SS;
-	BYTE Activity;
-	BYTE Flags;
-	BYTE day_index, month_index;
-	COUNT year_index;
-	BYTE MCreditLo, MCreditHi;
-	BYTE NumShips, NumDevices;
-	BYTE ShipList[MAX_BUILT_SHIPS];
-	BYTE DeviceList[MAX_EXCLUSIVE_DEVICES];
-	BYTE res_factor;	// JMS: Stores resolution factor to enable saving/loading from different res modes.
-} SUMMARY_DESC;
-
 #define OVERRIDE_LANDER_FLAGS (1 << 7)
 #define AFTER_BOMB_INSTALLED (1 << 7)
 
@@ -189,7 +166,12 @@ extern void RepairSISBorder (void);
 extern void InitSISContexts (void);
 extern void DrawSISFrame (void);
 extern void ClearSISRect (BYTE ClearFlags);
-extern void SetFlashRect (RECT *pRect);
+extern void SetFlashRect (const RECT *pRect);
+extern void PreUpdateFlashRect (void);
+extern void PostUpdateFlashRect (void);
+extern void PauseFlash (void);
+extern void ContinueFlash (void);
+
 #define SFR_MENU_3DO ((RECT*)~0L)
 #define SFR_MENU_ANY ((RECT*)~1L)
 extern void DrawHyperCoords (POINT puniverse);
@@ -258,5 +240,9 @@ extern COUNT CountSISPieces (BYTE piece_
 extern void DrawFlagshipName (BOOLEAN InStatusArea);
 extern void DrawCaptainsName (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* SIS_H_INCL__ */
 
diff -ruNp src.hd/uqm/sounds.h src/uqm/sounds.h
--- src.hd/uqm/sounds.h	2017-12-29 02:25:54 -0800
+++ src/uqm/sounds.h	2017-12-29 00:57:54 -0800
@@ -23,6 +23,10 @@
 #include "libs/compiler.h"
 #include "libs/sndlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef enum
 {
 	GRAB_CREW = 0,
@@ -39,6 +43,7 @@ typedef enum
 	MENU_SOUND_SUCCESS,
 	MENU_SOUND_FAILURE,
 	MENU_SOUND_INVOKED,
+	MENU_SOUND_BUBBLEWARP,
 } MENU_SOUND_EFFECT;
 
 extern SOUND MenuSounds;
@@ -74,6 +79,10 @@ extern void UpdateSoundPositions (void);
 extern void FlushSounds (void);
 extern void RemoveSoundsForObject (ELEMENT *PosObj);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _SOUNDS_H */
 
 
diff -ruNp src.hd/uqm/starbase.c src/uqm/starbase.c
--- src.hd/uqm/starbase.c	2017-12-29 02:25:54 -0800
+++ src/uqm/starbase.c	2017-12-29 00:57:54 -0800
@@ -16,16 +16,13 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "build.h"
 #include "colors.h"
 #include "controls.h"
-// XXX: for CurStarDescPtr
-#include "encount.h"
+#include "starmap.h"
 #include "comm.h"
 #include "gamestr.h"
-#include "load.h"
+#include "save.h"
 #include "starbase.h"
 #include "sis.h"
 #include "resinst.h"
@@ -106,13 +103,13 @@ DrawShipPiece (FRAME ModuleFrame, COUNT
 	STAMP Side, Top;
 	SBYTE RepairSlot;
 	COUNT ship_piece_offset_scaled = SHIP_PIECE_OFFSET;
-
+ 
 	// JMS_GFX
 	if (RESOLUTION_FACTOR != 0 &&
 		which_piece != FUSION_THRUSTER && which_piece != TURNING_JETS
 		 && which_piece != EMPTY_SLOT + 0 && which_piece != EMPTY_SLOT + 1)
 		ship_piece_offset_scaled += 1;
-	
+
 	RepairSlot = 0;
 	switch (which_piece)
 	{
@@ -136,7 +133,9 @@ DrawShipPiece (FRAME ModuleFrame, COUNT
 				RepairSlot = 1;
 				if (which_piece < EMPTY_SLOT
 						&& (which_slot == 0
-						|| GLOBAL_SIS (ModuleSlots[which_slot - 1]) < EMPTY_SLOT))
+						|| GLOBAL_SIS (ModuleSlots[
+								which_slot - 1
+								]) < EMPTY_SLOT))
 					++RepairSlot;
 			}
 			else if (!DrawBluePrint)
@@ -145,7 +144,9 @@ DrawShipPiece (FRAME ModuleFrame, COUNT
 					++which_piece;
 
 				if (which_slot < NUM_MODULE_SLOTS - 1
-						&& GLOBAL_SIS (ModuleSlots[which_slot + 1]) < EMPTY_SLOT)
+						&& GLOBAL_SIS (ModuleSlots[
+								which_slot + 1
+								]) < EMPTY_SLOT)
 				{
 					RepairSlot = -1;
 					if (which_piece == EMPTY_SLOT + 3
@@ -167,7 +168,6 @@ DrawShipPiece (FRAME ModuleFrame, COUNT
 		Side.frame = SetAbsFrameIndex (ModuleFrame,
 				((NUM_MODULES - 1) + (6 - 2)) + (NUM_MODULES + 6)
 				- (RepairSlot + 1));
-		
 		// JMS_GFX:
 		if (RESOLUTION_FACTOR == 0 ||
 			(which_piece != FUSION_THRUSTER && which_piece != TURNING_JETS
@@ -177,13 +177,14 @@ DrawShipPiece (FRAME ModuleFrame, COUNT
 	else if (RepairSlot && !(RESOLUTION_FACTOR > 0 && DrawBluePrint))
 	{
 		OldColor = SetContextForeGroundColor (BLACK_COLOR);
-	
+
 		r.corner = Side.origin;
 		r.corner.y += RES_CASE(0,0,8);
 		r.extent.width = ship_piece_offset_scaled;
 		r.extent.height = 1 << RESOLUTION_FACTOR;
+
 		DrawFilledRectangle (&r);
-		
+
 		r.corner.y += ((23 - 1) << RESOLUTION_FACTOR); // JMS_GFX
 		if (RESOLUTION_FACTOR != 0)
 			r.extent.height += RES_CASE(0,15,30); 
@@ -193,47 +194,35 @@ DrawShipPiece (FRAME ModuleFrame, COUNT
 		else if (which_slot == NUM_MODULE_SLOTS - 1 && RESOLUTION_FACTOR !=0)
 			r.extent.width -= RES_CASE(0,4,9); // JMS_GFX
 
-		DrawFilledRectangle (&r);
-		
-		r.extent.width = RES_CASE(1,5,12);
-		r.extent.height = (8 << RESOLUTION_FACTOR) + RES_CASE(0,13,30); // JMS_GFX
-		
 		if (RepairSlot == 2)
 		{
 			r.corner = Side.origin;
 			r.corner.y += RES_CASE(0,0,8);
 			DrawFilledRectangle (&r);
-			if (RESOLUTION_FACTOR > 0)
-			{
+			if (RESOLUTION_FACTOR > 0) {
 				r.corner.x += ship_piece_offset_scaled - r.extent.width;
-				if (which_slot == NUM_MODULE_SLOTS - 1 && RESOLUTION_FACTOR !=0)
-				{
+				if (which_slot == NUM_MODULE_SLOTS - 1 && RESOLUTION_FACTOR !=0) {
 					r.extent.height -= RES_CASE(0,8,16); // JMS_GFX
 					r.extent.width += RES_CASE(0,2,4); // JMS_GFX
 					DrawFilledRectangle (&r);
 					r.extent.width -= RES_CASE(0,2,4); // JMS_GFX
-				}
-				else
+				} else
 					DrawFilledRectangle (&r);
 				
 				r.corner.x -= ship_piece_offset_scaled - r.extent.width;
 			}
 			r.corner.y += 15 << RESOLUTION_FACTOR; // JMS_GFX
-			
 			DrawFilledRectangle (&r);
-			if (RESOLUTION_FACTOR > 0)
-			{
+			if (RESOLUTION_FACTOR > 0) {
 				r.corner.x += ship_piece_offset_scaled - r.extent.width;
-				if (which_slot == NUM_MODULE_SLOTS - 1 && RESOLUTION_FACTOR !=0)
-				{
+				if (which_slot == NUM_MODULE_SLOTS - 1 && RESOLUTION_FACTOR !=0) {
 					r.corner.y += RES_CASE(0,16,32);
 					r.extent.height -= RES_CASE(0,17,36); // JMS_GFX
 					r.extent.width += RES_CASE(0,1,3); // JMS_GFX
 					DrawFilledRectangle (&r);
 					r.extent.width -= RES_CASE(0,1,3); // JMS_GFX
 					r.extent.height += RES_CASE(0,17,36); // JMS_GFX
-				}
-				else
+				} else
 					DrawFilledRectangle (&r);
 				
 				r.corner.x -= ship_piece_offset_scaled - r.extent.width;
@@ -245,8 +234,7 @@ DrawShipPiece (FRAME ModuleFrame, COUNT
 			r.corner.y += RES_CASE(0,0,8);
 			r.corner.x += ship_piece_offset_scaled;
 			DrawFilledRectangle (&r);
-			if (RESOLUTION_FACTOR == 2)
-			{
+			if (RESOLUTION_FACTOR == 2) {
 				r.corner.x += ship_piece_offset_scaled - r.extent.width;
 				DrawFilledRectangle (&r);
 				r.corner.x -= ship_piece_offset_scaled - r.extent.width;
@@ -282,21 +270,18 @@ DrawShipPiece (FRAME ModuleFrame, COUNT
 
 			r.extent.width = (1 << RESOLUTION_FACTOR) + RESOLUTION_FACTOR;
 			r.extent.height = (12 << RESOLUTION_FACTOR) + RES_CASE(0,1,17); // JMS_GFX
-			
 			if (RepairSlot == 2)
 			{
 				r.corner = Top.origin;
 				DrawFilledRectangle (&r);
-				if (RESOLUTION_FACTOR == 2)
-				{
+				if (RESOLUTION_FACTOR == 2) {
 					r.corner.x += ship_piece_offset_scaled - r.extent.width;
 					DrawFilledRectangle (&r);
 					r.corner.x -= ship_piece_offset_scaled - r.extent.width;
 				}
 				r.corner.y += 20 << RESOLUTION_FACTOR; // JMS_GFX
-				DrawFilledRectangle (&r);
-				if (RESOLUTION_FACTOR == 2)
-				{
+ 				DrawFilledRectangle (&r);
+				if (RESOLUTION_FACTOR == 2) {
 					r.corner.x += ship_piece_offset_scaled - r.extent.width;
 					DrawFilledRectangle (&r);
 					r.corner.x -= ship_piece_offset_scaled - r.extent.width;
@@ -317,7 +302,6 @@ DrawShipPiece (FRAME ModuleFrame, COUNT
 		DrawStamp (&Top);
 
 		Side.frame = SetRelFrameIndex (Top.frame, (NUM_MODULES - 1) + 6);
-		
 		if (RESOLUTION_FACTOR != 0 
 			&& (which_piece == EMPTY_SLOT + 2 
 				|| which_piece == EMPTY_SLOT + 3))
@@ -349,7 +333,6 @@ DrawShipPiece (FRAME ModuleFrame, COUNT
 			s.origin = Side.origin;
 			s.origin.x -= ship_piece_offset_scaled;
 			s.frame = SetRelFrameIndex (s.frame, (NUM_MODULES - 1) + 6);
-			
 			DrawStamp (&s);
 		}
 
@@ -366,7 +349,6 @@ DrawShipPiece (FRAME ModuleFrame, COUNT
 			DrawStamp (&Top);
 
 			Side.frame = SetRelFrameIndex (Top.frame, (NUM_MODULES - 1) + 6);
-			
 			if (RESOLUTION_FACTOR != 0)
 			{
 				if (which_slot == 0 && which_piece == EMPTY_SLOT + 3)
@@ -439,7 +421,6 @@ DoStarBase (MENU_STATE *pMS)
 		LastActivity &= ~CHECK_LOAD;
 		pMS->InputFunc = DoStarBase;
 
-		LockMutex (GraphicsLock);
 		SetFlashRect (NULL);
 
 		if (pMS->hMusic)
@@ -450,12 +431,10 @@ DoStarBase (MENU_STATE *pMS)
 		}
 
 		pMS->Initialized = TRUE;
-		UnlockMutex (GraphicsLock);
 
 		pMS->CurFrame = CaptureDrawable (LoadGraphic (STARBASE_ANIM));
 		pMS->hMusic = LoadMusic (STARBASE_MUSIC);
 
-		LockMutex (GraphicsLock);
 		SetContext (ScreenContext);
 		SetTransitionSource (NULL);
 		BatchGraphics ();
@@ -466,7 +445,6 @@ DoStarBase (MENU_STATE *pMS)
 		ScreenTransition (3, NULL);
 		PlayMusic (pMS->hMusic, TRUE, 1);
 		UnbatchGraphics ();
-		UnlockMutex (GraphicsLock);
 	}
 	else if (PulsedInputState.menu[KEY_MENU_SELECT])
 	{
@@ -536,7 +514,6 @@ ExitStarBase:
 				NewState = TALK_COMMANDER;
 		}
 
-		LockMutex (GraphicsLock);
 		BatchGraphics ();
 		SetContext (ScreenContext);
 
@@ -549,7 +526,6 @@ ExitStarBase:
 		rotateStarbase (pMS, NULL);
 
 		UnbatchGraphics ();
-		UnlockMutex (GraphicsLock);
 
 		SleepThread (ONE_SECOND / 30);
 	}
@@ -562,10 +538,8 @@ DoTimePassage (void)
 {
 #define LOST_DAYS 14
 	SleepThreadUntil (FadeScreen (FadeAllToBlack, ONE_SECOND * 2));
-	LockMutex (GraphicsLock);
 	MoveGameClockDays (LOST_DAYS);
-	UnlockMutex (GraphicsLock);
-	
+
 	// JMS: Calculate flagship location in IP.
 	{
 		double newAngle;
@@ -668,7 +642,7 @@ VisitStarBase (void)
 		DoTimePassage ();
 		if (GLOBAL_SIS (CrewEnlisted) == (COUNT)~0)
 			return; // You are now dead! Thank you! (killed by Kohr-Ah)
-		
+
 		SetCommIntroMode (CIM_FADE_IN_SCREEN, ONE_SECOND * 2);
 		InitCommunication (COMMANDER_CONVERSATION);
 		if (GLOBAL (CurrentActivity) & CHECK_ABORT)
@@ -708,12 +682,10 @@ InstallBombAtEarth (void)
 {
 	DoTimePassage ();
 
-	LockMutex (GraphicsLock);
 	SetContext (ScreenContext);
 	SetTransitionSource (NULL);
 	SetContextBackGroundColor (BLACK_COLOR);
 	ClearDrawable ();
-	UnlockMutex (GraphicsLock);
 	
 	SleepThreadUntil (FadeScreen (FadeAllToColor, 0));
 	
diff -ruNp src.hd/uqm/starbase.h src/uqm/starbase.h
--- src.hd/uqm/starbase.h	2017-12-29 02:25:54 -0800
+++ src/uqm/starbase.h	2017-12-29 00:57:54 -0800
@@ -21,6 +21,10 @@
 
 #include "menustat.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 enum
 {
 	TALK_COMMANDER = 0,
@@ -44,5 +48,9 @@ extern COUNT WrapText (const UNICODE *pS
 		field_width);
 		// XXX: Doesn't really belong in this file.
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _STARBASE_H */
 
diff -ruNp src.hd/uqm/starcon.c src/uqm/starcon.c
--- src.hd/uqm/starcon.c	2017-12-29 02:25:54 -0800
+++ src/uqm/starcon.c	2017-12-29 00:57:54 -0800
@@ -24,10 +24,10 @@
 #include "gameev.h"
 #include "types.h"
 #include "globdata.h"
-#include "load.h"
 #include "resinst.h"
 #include "restart.h"
 #include "starbase.h"
+#include "save.h"
 #include "setup.h"
 #include "master.h"
 #include "controls.h"
@@ -39,19 +39,30 @@
 #include "planets/planets.h"
 		// for ExploreSolarSys()
 #include "uqmdebug.h"
+#include "uqm/lua/luastate.h"
 #include "libs/tasklib.h"
 #include "libs/log.h"
 #include "libs/gfxlib.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/graphics/tfb_draw.h"
 #include "libs/misc.h"
-
+#include "libs/scriptlib.h"
+#include "build.h"
 #include "uqmversion.h"
 #include "options.h"
+#include "setupmenu.h"
 #include "build.h"
 #include "gameopt.h" // JMS: For naming captain and ship at game start.
+#include "nameref.h"
+#include "settings.h"
+#include "cons_res.h"
+#include <time.h>//required to use 'srand(time(NULL))'
 
 volatile int MainExited = FALSE;
+#ifdef DEBUG_SLEEP
+uint32 mainThreadId;
+extern uint32 SDL_ThreadID(void);
+#endif
 
 // Open or close the periodically occuring QuasiSpace portal.
 // It changes the appearant portal size when necessary.
@@ -75,15 +86,17 @@ checkArilouGate (void)
 }
 
 // Battle frame callback function.
-// Called with GraphicsLock held
 static void
 on_battle_frame (void)
 {
 	GameClockTick ();
 	checkArilouGate ();
 
-	if (!(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD)))
+	if (!(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD))){		
+		if(RESOLUTION_FACTOR == 1)				
+			DrawSubmenu (0);
 		SeedUniverse ();
+	}
 
 	DrawAutoPilotMessage (FALSE);
 }
@@ -103,6 +116,7 @@ BackgroundInitKernel (DWORD TimeOut)
 	}
 }
 
+// Executes on the main() thread
 void
 SignalStopMainThread (void)
 {
@@ -111,6 +125,7 @@ SignalStopMainThread (void)
 	TaskSwitch ();
 }
 
+// Executes on the main() thread
 void
 ProcessUtilityKeys (void)
 {
@@ -123,13 +138,6 @@ ProcessUtilityKeys (void)
 	if (ImmediateInputState.menu[KEY_FULLSCREEN])
 	{
 		int flags = GfxFlags ^ TFB_GFXFLAGS_FULLSCREEN;
-		
-		// JMS: Force the usage of bilinear scaler in 1280x960 fullscreen.
-		if (resolutionFactor > 0)
-		{
-			flags |= TFB_GFXFLAGS_SCALE_BILINEAR;
-		}
-		
 		// clear ImmediateInputState so we don't repeat this next frame
 		FlushInput ();
 		TFB_DrawScreen_ReinitVideo (GraphicsDriver, flags, ScreenWidthActual,
@@ -137,35 +145,17 @@ ProcessUtilityKeys (void)
 	}
 
 #if defined(DEBUG) || defined(USE_DEBUG_KEY)
-	if (ImmediateInputState.menu[KEY_DEBUG])
-	{
-		// clear ImmediateInputState so we don't repeat this next frame
-		FlushInput ();
-		debugKeyPressed ();
-	}
-	
-	// JMS: The secondary debug key.
-	if (ImmediateInputState.menu[KEY_DEBUG_2])
-	{
-		// clear ImmediateInputState so we don't repeat this next frame
-		FlushInput ();
-		debugKey2Pressed ();
-	}
-	
-	// JMS: The tertiary debug key.
-	if (ImmediateInputState.menu[KEY_DEBUG_3])
-	{
-		// clear ImmediateInputState so we don't repeat this next frame
-		FlushInput ();
-		debugKey3Pressed ();
-	}
-	
-	// JMS: The quaternary debug key.
-	if (ImmediateInputState.menu[KEY_DEBUG_4])
-	{
-		// clear ImmediateInputState so we don't repeat this next frame
-		FlushInput ();
-		debugKey4Pressed ();
+	{	// Only call the debug func on the rising edge of
+		// ImmediateInputState[KEY_DEBUG] so it does not execute repeatedly.
+		// This duplicates the PulsedInputState somewhat, but we cannot
+		// use PulsedInputState here because it is meant for another thread.
+		static int debugKeyState;
+
+		if (ImmediateInputState.menu[KEY_DEBUG] && debugKeyState == 0)
+		{
+			debugKeyPressed ();
+		}
+		debugKeyState = ImmediateInputState.menu[KEY_DEBUG];
 	}
 #endif  /* DEBUG */
 }
@@ -176,6 +166,10 @@ extern int snddriver, soundflags;
 int
 Starcon2Main (void *threadArg)
 {
+#ifdef DEBUG_SLEEP
+	mainThreadId = SDL_ThreadID();
+#endif
+
 #if CREATE_JOURNAL
 {
 int ac = argc;
@@ -198,6 +192,7 @@ while (--ac > 0)
 }
 }
 #endif // CREATE_JOURNAL
+
 	{
 		/* TODO: Put initAudio back in main where it belongs once threading
 		 *       is gone.
@@ -218,12 +213,29 @@ while (--ac > 0)
 		return EXIT_FAILURE;
 	}
 	log_add (log_Info, "We've loaded the Kernel");
-	
+
 	GLOBAL (CurrentActivity) = 0;
+	luaUqm_initState ();
 	// show logo then splash and init the kernel in the meantime
-	if(optWhichIntro == OPT_3DO && optFMV && !optSkipIntro){
+	if(optFMV && !optSkipIntro){
 		Logo ();
 	}
+
+	{
+		srand(time(NULL));
+		
+		Rando = (rand() % NUM_MM_THEMES);
+
+		// printf("Random Music #: %d\n", Rando);
+
+		FadeMusic(0,0);
+		PlayMusic (loadMainMenuMusic(Rando), TRUE, 1);
+		
+		if (optMainMenuMusic)
+			FadeMusic (NORMAL_VOLUME+70, ONE_SECOND * 3);
+		comingFromInit = TRUE;
+	}
+
 	SplashScreen (BackgroundInitKernel);
 
 //	OpenJournal ();
@@ -234,25 +246,31 @@ while (--ac > 0)
 			log_add (log_Fatal, "Could not set player input.");
 			explode ();  // Does not return;
 		}
+
+		luaUqm_reinitState ();
 		InitGameStructures ();
 		InitGameClock ();
+		initEventSystem ();
 		AddInitialGameEvents();
-		
+
 		// JMS: Name Captain & Ship at start (not at loading old game).
 		if (LastActivity == (CHECK_LOAD | CHECK_RESTART))
 			AskNameForCaptainAndShip();
 
 		do
 		{
-			// Un-#if'ed to be used with bubblewarp.
-			if (debugHook != NULL){
+//#ifdef DEBUG
+			if (debugHook != NULL)
+			{
 				void (*saveDebugHook) (void);
 				saveDebugHook = debugHook;
-				debugHook = NULL; // No further debugHook calls unless the called function resets debugHook.
+				debugHook = NULL;
+						// No further debugHook calls unless the called
+						// function resets debugHook.
 				(*saveDebugHook) ();
 				continue;
-			} // Serosis
-
+			}
+//#endif
 			SetStatusMessageMode (SMM_DEFAULT);
 
 			if (!((GLOBAL (CurrentActivity) | NextActivity) & CHECK_LOAD))
@@ -306,9 +324,7 @@ while (--ac > 0)
 				Battle (&on_battle_frame);
 			}
 
-			LockMutex (GraphicsLock);
 			SetFlashRect (NULL);
-			UnlockMutex (GraphicsLock);
 
 			LastActivity = GLOBAL (CurrentActivity);
 
@@ -330,11 +346,13 @@ while (--ac > 0)
 		} while (!(GLOBAL (CurrentActivity) & CHECK_ABORT));
 
 		StopSound ();
+		uninitEventSystem ();
 		UninitGameClock ();
 		UninitGameStructures ();
 		ClearPlayerInputAll ();
 	}
 //	CloseJournal ();
+	luaUqm_uninitState ();
 
 	UninitGameKernel ();
 	FreeMasterShipList ();
diff -ruNp src.hd/uqm/starcon.h src/uqm/starcon.h
--- src.hd/uqm/starcon.h	2017-12-29 02:25:54 -0800
+++ src/uqm/starcon.h	2017-12-29 00:57:54 -0800
@@ -17,6 +17,10 @@
 #ifndef _STARCON_H
 #define _STARCON_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern volatile int MainExited;
 extern void SignalStopMainThread (void);
 extern void ProcessUtilityKeys (void);
@@ -24,5 +28,9 @@ extern void ProcessUtilityKeys (void);
 extern int Starcon2Main (void *threadArg);
 extern void FreeGameData (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _STARCON_H */
 
diff -ruNp src.hd/uqm/starmap.c src/uqm/starmap.c
--- src.hd/uqm/starmap.c	2017-12-29 02:25:54 -0800
+++ src/uqm/starmap.c	2017-12-29 00:57:54 -0800
@@ -16,10 +16,9 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-#include "encount.h"
+#include "starmap.h"
 #include "gamestr.h"
 #include "globdata.h"
-#include "libs/compiler.h"
 #include "libs/gfxlib.h"
 
 
diff -ruNp src.hd/uqm/starmap.h src/uqm/starmap.h
--- src.hd/uqm/starmap.h	1969-12-31 16:00:00 -0800
+++ src/uqm/starmap.h	2017-12-29 00:57:54 -0800
@@ -0,0 +1,42 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef STARMAP_H_INCL_
+#define STARMAP_H_INCL_
+
+#include "libs/compiler.h"
+#include "planets/planets.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+extern STAR_DESC *CurStarDescPtr;
+extern STAR_DESC *star_array;
+
+#define NUM_SOLAR_SYSTEMS 502
+
+extern STAR_DESC* FindStar (STAR_DESC *pLastStar, POINT *puniverse,
+		SIZE xbounds, SIZE ybounds);
+
+extern void GetClusterName (const STAR_DESC *pSD, UNICODE buf[]);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif  /* STARMAP_H_INCL_ */
+
diff -ruNp src.hd/uqm/state.c src/uqm/state.c
--- src.hd/uqm/state.c	2017-12-29 02:25:54 -0800
+++ src/uqm/state.c	2017-12-29 00:57:54 -0800
@@ -16,16 +16,15 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "state.h"
 
-#include "encount.h"
+#include "starmap.h"
 #include "libs/memlib.h"
 #include "libs/log.h"
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
+#include <memory.h>
 
 // in-memory file i/o
 struct GAME_STATE_FILE
@@ -125,6 +124,8 @@ DeleteStateFile (int stateFile)
 
 	fp->used = 0;
 	fp->ptr = 0;
+	HFree (fp->data);
+	fp->data = 0;
 }
 
 DWORD
@@ -235,14 +236,14 @@ UninitPlanetInfo (void)
 }
 
 #define OFFSET_SIZE       (sizeof (DWORD))
-
+//#define SCAN_RECORD_SIZE  (sizeof (DWORD) * NUM_SCAN_TYPES)
 // JMS: Increased the size of scan record to house partially scavenged minerals.
 #define SCAN_RECORD_SIZE  ((sizeof (DWORD) * NUM_SCAN_TYPES) + (sizeof(BYTE) * NUM_SCAN_TYPES * 32))
 
 void
 GetPlanetInfo (void)
 {
-	void *fp;
+	GAME_STATE_FILE *fp;
 	COUNT k,l;
 
 	pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[BIOLOGICAL_SCAN] = 0;
@@ -253,7 +254,7 @@ GetPlanetInfo (void)
 	for (l = MINERAL_SCAN; l < NUM_SCAN_TYPES; l++)
 		for (k = 0; k < 32; k++)
 			pSolarSysState->SysInfo.PlanetInfo.PartiallyScavengedList[l][k] = 0;
-	
+
 	fp = OpenStateFile (STARINFO_FILE, "rb");
 	if (fp)
 	{
@@ -287,7 +288,7 @@ GetPlanetInfo (void)
 			SeekStateFile (fp, offset, SEEK_SET);
 			sread_a32 (fp, pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask,
 					NUM_SCAN_TYPES);
-			
+
 			{
 				BYTE *ar = &(pSolarSysState->SysInfo.PlanetInfo.PartiallyScavengedList[0][0]); // JMS
 				
@@ -305,7 +306,7 @@ GetPlanetInfo (void)
 void
 PutPlanetInfo (void)
 {
-	void *fp;
+	GAME_STATE_FILE *fp;
 
 	fp = OpenStateFile (STARINFO_FILE, "r+b");
 	if (fp)
@@ -332,7 +333,7 @@ PutPlanetInfo (void)
 			{
 				0, 0, 0,
 			};
-			
+
 			// JMS: Init also the partially scavenged mineral deposit values.
 			BYTE PartiallyScavengedList[NUM_SCAN_TYPES][32];
 			for (l = MINERAL_SCAN; l < NUM_SCAN_TYPES; l++)
@@ -353,18 +354,17 @@ PutPlanetInfo (void)
 				BYTE *ar = &(PartiallyScavengedList[0][0]); // JMS
 
 				swrite_a32 (fp, ScanRetrieveMask, NUM_SCAN_TYPES);
-				
+
 				// JMS: Also init with zeroes the list of partially scavenged mineral amounts.
 				for (l = MINERAL_SCAN; l < NUM_SCAN_TYPES; l++)
 					for (k = 0; k < 32; k++, ar++)
 						swrite_8 (fp, *ar);
-				
+
 				// init moons
-				for (j = 0; j < pSolarSysState->PlanetDesc[i].NumPlanets; ++j)
-				{
+				for (j = 0; j < pSolarSysState->PlanetDesc[i].NumPlanets; ++j) {
 					BYTE *ar = &(PartiallyScavengedList[0][0]); // JMS
 					
-					swrite_a32 (fp, ScanRetrieveMask, NUM_SCAN_TYPES);
+ 					swrite_a32 (fp, ScanRetrieveMask, NUM_SCAN_TYPES);
 					
 					// JMS: Ditto for the moons.
 					for (l = MINERAL_SCAN; l < NUM_SCAN_TYPES; l++)
@@ -383,11 +383,11 @@ PutPlanetInfo (void)
 		offset += moon_index * SCAN_RECORD_SIZE;
 
 		SeekStateFile (fp, offset, SEEK_SET);
-		
+
 		// Store which mineral deposits we have already retrieved.
 		swrite_a32 (fp, pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask,
-					NUM_SCAN_TYPES);
-		
+				NUM_SCAN_TYPES);
+
 		{
 			BYTE *ar = &(pSolarSysState->SysInfo.PlanetInfo.PartiallyScavengedList[0][0]); // JMS
 			
diff -ruNp src.hd/uqm/state.h src/uqm/state.h
--- src.hd/uqm/state.h	2017-12-29 02:25:54 -0800
+++ src/uqm/state.h	2017-12-29 00:57:54 -0800
@@ -23,6 +23,10 @@
 #include "libs/compiler.h"
 #include <assert.h>
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern void InitPlanetInfo (void);
 extern void UninitPlanetInfo (void);
 extern void GetPlanetInfo (void);
@@ -75,7 +79,7 @@ int WriteStateFile (const void *lpBuf, C
 int SeekStateFile (GAME_STATE_FILE *fp, long offset, int whence);
 
 static inline COUNT
-sread_8 (void *fp, BYTE *v)
+sread_8 (GAME_STATE_FILE *fp, BYTE *v)
 {
 	BYTE t;
 	if (!v) /* read value ignored */
@@ -84,7 +88,7 @@ sread_8 (void *fp, BYTE *v)
 }
 
 static inline COUNT
-sread_16 (void *fp, UWORD *v)
+sread_16 (GAME_STATE_FILE *fp, UWORD *v)
 {
 	UWORD t;
 	if (!v) /* read value ignored */
@@ -93,7 +97,7 @@ sread_16 (void *fp, UWORD *v)
 }
 
 static inline COUNT
-sread_16s (void *fp, SWORD *v)
+sread_16s (GAME_STATE_FILE *fp, SWORD *v)
 {
 	UWORD t;
 	COUNT ret;
@@ -105,7 +109,7 @@ sread_16s (void *fp, SWORD *v)
 }
 
 static inline COUNT
-sread_32 (void *fp, DWORD *v)
+sread_32 (GAME_STATE_FILE *fp, DWORD *v)
 {
 	DWORD t;
 	if (!v) /* read value ignored */
@@ -114,7 +118,7 @@ sread_32 (void *fp, DWORD *v)
 }
 
 static inline COUNT
-sread_a32 (void *fp, DWORD *ar, COUNT count)
+sread_a32 (GAME_STATE_FILE *fp, DWORD *ar, COUNT count)
 {
 	assert (ar != NULL);
 
@@ -127,25 +131,25 @@ sread_a32 (void *fp, DWORD *ar, COUNT co
 }
 
 static inline COUNT
-swrite_8 (void *fp, BYTE v)
+swrite_8 (GAME_STATE_FILE *fp, BYTE v)
 {
 	return WriteStateFile (&v, 1, 1, fp);
 }
 
 static inline COUNT
-swrite_16 (void *fp, UWORD v)
+swrite_16 (GAME_STATE_FILE *fp, UWORD v)
 {
 	return WriteStateFile (&v, 2, 1, fp);
 }
 
 static inline COUNT
-swrite_32 (void *fp, DWORD v)
+swrite_32 (GAME_STATE_FILE *fp, DWORD v)
 {
 	return WriteStateFile (&v, 4, 1, fp);
 }
 
 static inline COUNT
-swrite_a32 (void *fp, const DWORD *ar, COUNT count)
+swrite_a32 (GAME_STATE_FILE *fp, const DWORD *ar, COUNT count)
 {
 	for ( ; count > 0; --count, ++ar)
 	{
@@ -155,5 +159,9 @@ swrite_a32 (void *fp, const DWORD *ar, C
 	return 1;
 }
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _STATE_H */
 
diff -ruNp src.hd/uqm/status.c src/uqm/status.c
--- src.hd/uqm/status.c	2017-12-29 02:25:54 -0800
+++ src/uqm/status.c	2017-12-29 00:57:54 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "status.h"
 #include "colors.h"
 #include "globdata.h"
@@ -193,6 +191,7 @@ DrawCaptainsWindow (STARSHIP *StarShipPt
 	// Grey area under and around captain's window.
 	assert (StarShipPtr->playerNr >= 0);
 	y_offs = status_y_offsets[StarShipPtr->playerNr];
+
 	r.corner.x = CAPTAIN_XOFFS - RES_STAT_SCALE(4); // JMS_GFX
 	r.corner.y = y_offs + SHIP_INFO_HEIGHT;
 	r.extent.width = STATUS_WIDTH - 2;
@@ -232,7 +231,7 @@ DrawCaptainsWindow (STARSHIP *StarShipPt
 	++r.extent.width;
 	++r.corner.y;
 	DrawFilledRectangle (&r);
-	
+
 	y = y_offs + CAPTAIN_YOFFS;
 
 	// Darker grey rectangle at bottom and right of captain's window
@@ -474,18 +473,18 @@ PostProcessStatus (ELEMENT *ShipPtr)
 						};
 
 						c = flash_tab1[i];
-						
+
 						// JMS_GFX
 						r.corner.x = CAPTAIN_XOFFS + RES_STAT_SCALE(i);
 						r.corner.y = y + CAPTAIN_YOFFS + RES_STAT_SCALE(i);
 						r.extent.width = CAPTAIN_WIDTH - RES_STAT_SCALE((i << 1));
 						r.extent.height = CAPTAIN_HEIGHT - RES_STAT_SCALE((i << 1));
+
 						if (r.extent.height == 2)
 							++r.extent.height;
 						
 						// JMS_GFX
-						for (j=0 ; j<RES_STAT_SCALE(1); j++)
-						{
+						for (j=0 ; j<RES_STAT_SCALE(1); j++) {
 							DrawRectangle (&r);
 							++r.corner.x;
 							++r.corner.y;
@@ -498,8 +497,6 @@ PostProcessStatus (ELEMENT *ShipPtr)
 						r.corner.y = y + (CAPTAIN_YOFFS + RES_STAT_SCALE(15)); // JMS_GFX
 						r.extent.width = RES_STAT_SCALE(i + 1); // JMS_GFX
 						r.extent.height = 1;
-						
-						// JMS_GFX
 						switch (i)
 						{
 							case 0:
diff -ruNp src.hd/uqm/status.h src/uqm/status.h
--- src.hd/uqm/status.h	2017-12-29 02:25:54 -0800
+++ src/uqm/status.h	2017-12-29 00:57:54 -0800
@@ -16,33 +16,37 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #ifndef UQM_STATUS_H_INCL_
 #define UQM_STATUS_H_INCL_
 
 #include "races.h"
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #define CREW_XOFFS RES_STAT_SCALE(4) // JMS_GFX
 #define ENERGY_XOFFS (RES_STAT_SCALE(52) + (3 * RESOLUTION_FACTOR) + (RESOLUTION_FACTOR / 2)) // JMS_GFX
-#define GAUGE_YOFFS (SHIP_INFO_HEIGHT - (10 << RESOLUTION_FACTOR) + 6 * RESOLUTION_FACTOR) // JMS_GFX
-#define UNIT_WIDTH RES_STAT_SCALE(2)
-#define UNIT_HEIGHT (1 << RESOLUTION_FACTOR)
-#define STAT_WIDTH (1 + UNIT_WIDTH + 1 + UNIT_WIDTH + 1) // JMS_GFX
+#define GAUGE_YOFFS ((SHIP_INFO_HEIGHT - (10 << RESOLUTION_FACTOR) + 6 * RESOLUTION_FACTOR) - RES_CASE(0,0,4)) // JMS_GFX
+#define UNIT_WIDTH RES_SCALE(2)
+#define UNIT_HEIGHT RES_SCALE(1)
+#define STAT_WIDTH (1 + UNIT_WIDTH + 1 + UNIT_WIDTH + 1)
 
 #define SHIP_INFO_HEIGHT (65 << RESOLUTION_FACTOR) // JMS_GFX
 #define CAPTAIN_WIDTH RES_STAT_SCALE(55) // JMS_GFX
 #define CAPTAIN_HEIGHT RES_STAT_SCALE(30) // JMS_GFX
 #define CAPTAIN_XOFFS ((STATUS_WIDTH - CAPTAIN_WIDTH) >> 1) // JMS_GFX
 #define CAPTAIN_YOFFS (SHIP_INFO_HEIGHT + (4 << RESOLUTION_FACTOR)) // JMS_GFX
+
 #define SHIP_STATUS_HEIGHT (STATUS_HEIGHT >> 1)
 #define BAD_GUY_YOFFS 0
 #define GOOD_GUY_YOFFS SHIP_STATUS_HEIGHT
+
 #define STARCON_TEXT_HEIGHT (7 << RESOLUTION_FACTOR) // JMS_GFX
 #define TINY_TEXT_HEIGHT (9 << RESOLUTION_FACTOR) // JMS_GFX
 #define BATTLE_CREW_X RES_STAT_SCALE(10) // JMS_GFX
-#define BATTLE_CREW_Y ((64 - SAFE_Y) << RESOLUTION_FACTOR) // JMS_GFX
+#define BATTLE_CREW_Y (((64 - SAFE_Y) << RESOLUTION_FACTOR) - RES_CASE(0,0,4))// JMS_GFX
 
 extern COORD status_y_offsets[];
 
@@ -64,4 +68,8 @@ extern BOOLEAN DeltaCrew (ELEMENT *Eleme
 extern void PreProcessStatus (ELEMENT *ShipPtr);
 extern void PostProcessStatus (ELEMENT *ShipPtr);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* UQM_STATUS_H_INCL_ */
diff -ruNp src.hd/uqm/supermelee/Makeinfo src/uqm/supermelee/Makeinfo
--- src.hd/uqm/supermelee/Makeinfo	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/Makeinfo	2017-12-29 00:57:54 -0800
@@ -1,4 +1,5 @@
 uqm_CFILES="buildpick.c loadmele.c melee.c meleesetup.c pickmele.c"
+uqm_HFILES="buildpick.h loadmele.h melee.h meleesetup.h meleeship.h pickmele.h"
 if [ -n "$uqm_NETPLAY" ]; then
 	uqm_SUBDIRS="$uqm_SUBDIRS netplay"
 fi
diff -ruNp src.hd/uqm/supermelee/buildpick.c src/uqm/supermelee/buildpick.c
--- src.hd/uqm/supermelee/buildpick.c	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/buildpick.c	2017-12-29 00:57:54 -0800
@@ -14,8 +14,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "buildpick.h"
 
 #include "../controls.h"
@@ -73,6 +71,7 @@ DrawPickIcon (MeleeShip ship, bool DrawE
 
 	s.origin.x = r.corner.x + (20 << RESOLUTION_FACTOR) + (ship % NUM_PICK_COLS) * (18 << RESOLUTION_FACTOR) - RES_CASE(0,0,2); // JMS_GFX
 	s.origin.y = r.corner.y + (5 << RESOLUTION_FACTOR) + (ship / NUM_PICK_COLS) * (18 << RESOLUTION_FACTOR); // JMS_GFX
+
 	s.frame = GetShipIconsFromIndex (ship);
 	if (DrawErase)
 	{	// draw icon
@@ -88,7 +87,6 @@ DrawPickIcon (MeleeShip ship, bool DrawE
 	}
 }
 
-// Pre: the called holds the GraphicsLock
 void
 DrawPickFrame (MELEE_STATE *pMS)
 {
@@ -189,11 +187,9 @@ DoPickShip (MELEE_STATE *pMS)
 		if (newSelectedShip != pMS->currentShip)
 		{
 			// A new ship has been selected.
-			LockMutex (GraphicsLock);
 			DrawPickIcon (pMS->currentShip, true);
 			pMS->currentShip = newSelectedShip;
 			DrawMeleeShipStrings (pMS, newSelectedShip);
-			UnlockMutex (GraphicsLock);
 		}
 	}
 
@@ -216,9 +212,7 @@ BuildPickShip (MELEE_STATE *pMS)
 	if (pMS->currentShip == MELEE_NONE)
 		pMS->currentShip = 0;
 
-	LockMutex (GraphicsLock);
 	DrawPickFrame (pMS);
-	UnlockMutex (GraphicsLock);
 
 	pMS->InputFunc = DoPickShip;
 	DoInput (pMS, FALSE);
diff -ruNp src.hd/uqm/supermelee/buildpick.h src/uqm/supermelee/buildpick.h
--- src.hd/uqm/supermelee/buildpick.h	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/buildpick.h	2017-12-29 00:57:54 -0800
@@ -4,6 +4,10 @@
 #include "types.h"
 #include "melee.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 void BuildBuildPickFrame (void);
 void DestroyBuildPickFrame (void);
 bool BuildPickShip (MELEE_STATE *pMS);
@@ -13,5 +17,9 @@ void DrawPickFrame (MELEE_STATE *pMS);
 void DrawPickIcon (MeleeShip ship, bool DrawErase);
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* BUILDPICK_H */
 
diff -ruNp src.hd/uqm/supermelee/loadmele.c src/uqm/supermelee/loadmele.c
--- src.hd/uqm/supermelee/loadmele.c	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/loadmele.c	2017-12-29 00:57:54 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 // This file handles loading of teams, but the UI and the actual loading.
 
 #define MELEESETUP_INTERNAL
@@ -47,6 +45,7 @@
 #define LOAD_MELEE_BOX_HEIGHT (34 << RESOLUTION_FACTOR) // JMS_GFX
 #define LOAD_MELEE_BOX_SPACE (1 << RESOLUTION_FACTOR) // JMS_GFX
 
+
 static void DrawFileStrings (MELEE_STATE *pMS);
 static bool FillFileView (MELEE_STATE *pMS);
 
@@ -193,7 +192,6 @@ DrawFileString (const MeleeTeam *team, c
 
 		s.origin.x = origin->x + (1 << RESOLUTION_FACTOR); // JMS_GFX
 		s.origin.y = origin->y + (RES_CASE(4,8,12)); // JMS_GFX
-
 		for (slotI = 0; slotI < MELEE_FLEET_SIZE; slotI++)
 		{
 			BYTE StarShip;
@@ -236,7 +234,6 @@ FillFileView (MELEE_STATE *pMS)
 #define FILE_STRING_ORIGIN_Y  ((34 << RESOLUTION_FACTOR) + (RESOLUTION_FACTOR * 23)) // JMS_GFX
 #define ENTRY_HEIGHT (RES_CASE(32,64,132)) // JMS_GFX
 
-
 static void
 SelectFileString (MELEE_STATE *pMS, bool hilite)
 {
@@ -314,11 +311,9 @@ flashSelectedTeam (MELEE_STATE *pMS)
 		NextTime = Now + FLASH_RATE;
 		hilite ^= 1;
 
-		LockMutex (GraphicsLock);
 		OldContext = SetContext (SpaceContext);
 		SelectFileString (pMS, hilite);
 		SetContext (OldContext);
-		UnlockMutex (GraphicsLock);
 	}
 }
 
@@ -338,12 +333,10 @@ DoLoadTeam (MELEE_STATE *pMS)
 
 	if (!pMS->Initialized)
 	{
-		LockMutex (GraphicsLock);
 		DrawFileStrings (pMS);
 		SelectFileString (pMS, true);
 		pMS->Initialized = TRUE;
 		pMS->InputFunc = DoLoadTeam;
-		UnlockMutex (GraphicsLock);
 		return TRUE;
 	}
 
@@ -363,9 +356,7 @@ DoLoadTeam (MELEE_STATE *pMS)
 			RECT r;
 			
 			GetFrameRect (SetAbsFrameIndex (MeleeFrame, 28), &r);
-			LockMutex (GraphicsLock);
 			RepairMeleeFrame (&r);
-			UnlockMutex (GraphicsLock);
 		}
 		return TRUE;
 	}
@@ -421,7 +412,6 @@ DoLoadTeam (MELEE_STATE *pMS)
 		if (newIndex != pMS->load.cur)
 		{
 			// The cursor has been moved.
-			LockMutex (GraphicsLock);
 			if (newTop == pMS->load.top)
 			{
 				// The view itself hasn't changed.
@@ -434,7 +424,6 @@ DoLoadTeam (MELEE_STATE *pMS)
 				DrawFileStrings (pMS);
 			}
 			pMS->load.cur = newIndex;
-			UnlockMutex (GraphicsLock);
 		}
 	}
 
@@ -485,11 +474,9 @@ DoSaveTeam (MELEE_STATE *pMS)
 	snprintf (file, sizeof file, "%s.mle",
 			MeleeSetup_getTeamName (pMS->meleeSetup, pMS->side));
 
-	LockMutex (GraphicsLock);
 	OldContext = SetContext (ScreenContext);
 	ConfirmSaveLoad (&MsgStamp);
 			// Show the "Saving . . ." message.
-	UnlockMutex (GraphicsLock);
 
 	stream = uio_fopen (meleeDir, file, "wb");
 	if (stream != NULL)
@@ -506,11 +493,9 @@ DoSaveTeam (MELEE_STATE *pMS)
 	pMS->load.cur = 0;
 
 	// Undo the screen damage done by the "Saving . . ." message.
-	LockMutex (GraphicsLock);
 	DrawStamp (&MsgStamp);
 	DestroyDrawable (ReleaseDrawable (MsgStamp.frame));
 	SetContext (OldContext);
-	UnlockMutex (GraphicsLock);
 
 	if (!saveOk)
 		SaveProblem ();
diff -ruNp src.hd/uqm/supermelee/loadmele.h src/uqm/supermelee/loadmele.h
--- src.hd/uqm/supermelee/loadmele.h	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/loadmele.h	2017-12-29 00:57:54 -0800
@@ -26,6 +26,10 @@ struct melee_load_state;
 #include "melee.h"
 #include "meleesetup.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 struct melee_load_state
 {
 	MeleeTeam **preBuiltList;
@@ -56,6 +60,10 @@ bool ReadTeamImage (MeleeTeam *pTI, uio_
 int WriteTeamImage (const MeleeTeam *pTI, uio_Stream *save_fp);
 void LoadTeamList (MELEE_STATE *pMS);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _LOADMELE_H */
 
 
diff -ruNp src.hd/uqm/supermelee/melee.c src/uqm/supermelee/melee.c
--- src.hd/uqm/supermelee/melee.c	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/melee.c	2017-12-29 00:57:54 -0800
@@ -16,14 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
-// JMS: Had to include some stuff that actually shouldn't be here in order to get the
-// melee team saving&loading after restart to work.
-#define MELEESETUP_INTERNAL
-#define MELEETEAM_INTERNAL
-#include "meleesetup.h"
-
 #include "melee.h"
 
 #include "options.h"
@@ -125,7 +117,7 @@ enum
 #define RACE_INFO_HEIGHT ((STATUS_HEIGHT - (3 << RESOLUTION_FACTOR)) - RACE_INFO_ORIGIN_Y) // JMS_GFX
 
 #define MELEE_STATUS_X_OFFS ((1 << RESOLUTION_FACTOR)) // JMS_GFX
-#define MELEE_STATUS_Y_OFFS ((201 << RESOLUTION_FACTOR) + RES_CASE(0,20,40)) // JMS_GFX
+#define MELEE_STATUS_Y_OFFS (RES_SCALE(201) + RES_CASE(0,20,40)) // JMS_GFX
 #define MELEE_STATUS_WIDTH  (NUM_MELEE_COLUMNS * \
 		(MELEE_BOX_WIDTH + MELEE_BOX_SPACE))
 #define MELEE_STATUS_HEIGHT (38 << RESOLUTION_FACTOR) // JMS_GFX
@@ -262,7 +254,6 @@ GetShipBox (RECT *pRect, COUNT side, COU
 	pRect->extent.height = MELEE_BOX_HEIGHT;
 }
 
-// The caller must hold the GraphicsLock.
 static void
 DrawShipBox (COUNT side, FleetShipIndex index, MeleeShip ship, BOOLEAN HiLite)
 {
@@ -298,7 +289,6 @@ DrawShipBox (COUNT side, FleetShipIndex
 	UnbatchGraphics ();
 }
 
-// The caller must hold the GraphicsLock.
 static void
 ClearShipBox (COUNT side, FleetShipIndex index)
 {
@@ -439,21 +429,23 @@ RedrawMeleeFrame (void)
 static void
 GetTeamStringRect (COUNT side, RECT *r)
 {
-	r->corner.x = MELEE_X_OFFS - 1; // JMS_GFX
+	r->corner.x = MELEE_X_OFFS - 1;
 	r->corner.y = (side + 1) * (MELEE_Y_OFFS
-			+ ((MELEE_BOX_HEIGHT + MELEE_BOX_SPACE) * NUM_MELEE_ROWS + 2)); // JMS_GFX
-	r->extent.width = NUM_MELEE_COLUMNS * (MELEE_BOX_WIDTH + MELEE_BOX_SPACE) - (29 << RESOLUTION_FACTOR); // JMS_GFX
-	r->extent.height = RES_CASE(13,16,32); // JMS_GFX
+			+ ((MELEE_BOX_HEIGHT + MELEE_BOX_SPACE) * NUM_MELEE_ROWS + 2));
+	r->extent.width = NUM_MELEE_COLUMNS * (MELEE_BOX_WIDTH + MELEE_BOX_SPACE)
+			- (29 << RESOLUTION_FACTOR);
+	r->extent.height = RES_CASE(13,16,32);
 }
 
 static void
 GetFleetValueRect (COUNT side, RECT *r)
 {
-	r->corner.x = MELEE_X_OFFS + NUM_MELEE_COLUMNS * (MELEE_BOX_WIDTH + MELEE_BOX_SPACE) - (30 << RESOLUTION_FACTOR); // JMS_GFX
+	r->corner.x = MELEE_X_OFFS
+			+ NUM_MELEE_COLUMNS * (MELEE_BOX_WIDTH + MELEE_BOX_SPACE) - (30 << RESOLUTION_FACTOR);
 	r->corner.y = (side + 1) * (MELEE_Y_OFFS
 			+ ((MELEE_BOX_HEIGHT + MELEE_BOX_SPACE) * NUM_MELEE_ROWS + 2));
-	r->extent.width = 29 << RESOLUTION_FACTOR; // JMS_GFX
-	r->extent.height = RES_CASE(13,16,32);  // JMS_GFX
+	r->extent.width = 29 << RESOLUTION_FACTOR;
+	r->extent.height = RES_CASE(13,16,32);
 }
 
 static void
@@ -507,7 +499,7 @@ DrawTeamString (MELEE_STATE *pMS, COUNT
 	lfText.pStr = (teamName != NULL) ? teamName :
 			MeleeSetup_getTeamName (pMS->meleeSetup, side);
 	lfText.baseline.y = r.corner.y + r.extent.height - 3;
-	lfText.baseline.x = r.corner.x + (1 << RESOLUTION_FACTOR); // JMS_GFX
+	lfText.baseline.x = r.corner.x + (1 << RESOLUTION_FACTOR);
 	lfText.align = ALIGN_LEFT;
 	lfText.CharCount = strlen (lfText.pStr);
 
@@ -526,7 +518,7 @@ DrawTeamString (MELEE_STATE *pMS, COUNT
 		BYTE *pchar_deltas;
 
 		TextRect (&lfText, &text_r, char_deltas);
-		if ((text_r.extent.width + (2 << RESOLUTION_FACTOR)) >= r.extent.width) // JMS_GFX
+		if ((text_r.extent.width + (2 << RESOLUTION_FACTOR)) >= r.extent.width)
 		{	// the text does not fit the input box size and so
 			// will not fit when displayed later
 			UnbatchGraphics ();
@@ -548,25 +540,25 @@ DrawTeamString (MELEE_STATE *pMS, COUNT
 		{	// Use block cursor for keyboardless systems
 			if (pMS->CurIndex == lfText.CharCount)
 			{	// cursor at end-line -- use insertion point
-				text_r.extent.width = (1 << RESOLUTION_FACTOR); // JMS_GFX
+				text_r.extent.width = (1 << RESOLUTION_FACTOR);
 			}
 			else if (pMS->CurIndex + 1 == lfText.CharCount)
 			{	// extra pixel for last char margin
-				text_r.extent.width = (SIZE)*pchar_deltas + (2 << RESOLUTION_FACTOR); // JMS_GFX
+				text_r.extent.width = (SIZE)*pchar_deltas + (2 << RESOLUTION_FACTOR);
 			}
 			else
 			{	// normal mid-line char
-				text_r.extent.width = (SIZE)*pchar_deltas + (1 << RESOLUTION_FACTOR); // JMS_GFX
+				text_r.extent.width = (SIZE)*pchar_deltas + (1 << RESOLUTION_FACTOR);
 			}
 		}
 		else
 		{	// Insertion point cursor
-			text_r.extent.width = 1 << RESOLUTION_FACTOR; // JMS_GFX;
+			text_r.extent.width = 1 << RESOLUTION_FACTOR;
 		}
 		// position cursor within input field rect
 		++text_r.corner.x;
 		++text_r.corner.y;
-		text_r.extent.height -= 2 << RESOLUTION_FACTOR; // JMS_GFX
+		text_r.extent.height -= 2 << RESOLUTION_FACTOR;
 		SetContextForeGroundColor (TEAM_NAME_EDIT_CURS_COLOR);
 		DrawFilledRectangle (&text_r);
 
@@ -580,7 +572,6 @@ DrawTeamString (MELEE_STATE *pMS, COUNT
 
 #ifdef NETPLAY
 // This function is generic. It should probably be moved to elsewhere.
-// The caller should hold the GraphicsLock.
 static void
 multiLineDrawText (TEXT *textIn, RECT *clipRect) {
 	RECT oldRect;
@@ -627,7 +618,6 @@ DrawMeleeStatusMessage (const char *mess
 	CONTEXT oldContext;
 	RECT r;
 
-	LockMutex (GraphicsLock);
 	oldContext = SetContext (SpaceContext);
 
 	r.corner.x = MELEE_STATUS_X_OFFS;
@@ -653,7 +643,6 @@ DrawMeleeStatusMessage (const char *mess
 	}
 
 	SetContext (oldContext);
-	UnlockMutex (GraphicsLock);
 }
 
 static void
@@ -707,7 +696,6 @@ UpdateMeleeStatusMessage (ssize_t player
 #endif  /* NETPLAY */
 
 // XXX: this function is called when the current selection is blinking off.
-// The caller should hold the GraphicsLock.
 static void
 Deselect (BYTE opt)
 {
@@ -770,7 +758,6 @@ Deselect (BYTE opt)
 }
 
 // XXX: this function is called when the current selection is blinking off.
-// The caller should hold the GraphicsLock.
 static void
 Select (BYTE opt)
 {
@@ -847,14 +834,12 @@ Melee_flashSelection (MELEE_STATE *pMS)
 		NextTime = Now + FLASH_RATE;
 		select = !select;
 
-		LockMutex (GraphicsLock);
 		OldContext = SetContext (SpaceContext);
 		if (select)
 			Select (pMS->MeleeOption);
 		else
 			Deselect (pMS->MeleeOption);
 		SetContext (OldContext);
-		UnlockMutex (GraphicsLock);
 	}
 }
 
@@ -880,7 +865,6 @@ InitMelee (MELEE_STATE *pMS)
 	(void) pMS;
 }
 
-// Pre: The caller holds the GraphicsLock.
 void
 DrawMeleeShipStrings (MELEE_STATE *pMS, MeleeShip NewStarShip)
 {
@@ -890,9 +874,9 @@ DrawMeleeShipStrings (MELEE_STATE *pMS,
 	OldContext = SetContext (StatusContext);
 	GetContextClipRect (&OldRect);
 	r = OldRect;
-	r.corner.x += ((SAFE_X << 1) - (32 << RESOLUTION_FACTOR)) + MENU_X_OFFS - RES_CASE(0,0,3); // JMS_GFX
-	r.corner.y += (76 << RESOLUTION_FACTOR) + RES_CASE(0,2,6); // JMS_GFX
-	r.extent.height = SHIP_INFO_HEIGHT + RES_CASE(3,6,3); // JMS_GFX
+	r.corner.x += ((SAFE_X << 1) - (32 << RESOLUTION_FACTOR)) + MENU_X_OFFS - RES_CASE(0,0,3);
+	r.corner.y += (76 << RESOLUTION_FACTOR) + RES_CASE(0,2,6);
+	r.extent.height = SHIP_INFO_HEIGHT + RES_CASE(3,6,3);
 	SetContextClipRect (&r);
 	BatchGraphics ();
 
@@ -915,7 +899,7 @@ DrawMeleeShipStrings (MELEE_STATE *pMS,
 		SetContextForeGroundColor (BLACK_COLOR);
 		DrawRectangle (&r);
 		t.baseline.x = STATUS_WIDTH >> 1;
-		t.baseline.y = 32 << RESOLUTION_FACTOR; // JMS_GFX
+		t.baseline.y = 32 << RESOLUTION_FACTOR; 
 		t.align = ALIGN_CENTER;
 		if (pMS->row < NUM_MELEE_ROWS)
 		{
@@ -972,9 +956,7 @@ UpdateCurrentShip (MELEE_STATE *pMS)
 				MeleeSetup_getShip (pMS->meleeSetup, pMS->side, slotNr);
 	}
 
-	LockMutex (GraphicsLock);
 	DrawMeleeShipStrings (pMS, pMS->currentShip);
-	UnlockMutex (GraphicsLock);
 }
 
 // returns (COUNT) ~0 for an invalid ship.
@@ -1040,9 +1022,7 @@ OnTeamNameChange (TEXTENTRY_STATE *pTES)
 	if (pTES->JoystickMode)
 		hl |= DTSHS_BLOCKCUR;
 
-	LockMutex (GraphicsLock);
 	ret = DrawTeamString (pMS, pMS->side, hl, pTES->BaseStr);
-	UnlockMutex (GraphicsLock);
 
 	return ret;
 }
@@ -1089,9 +1069,7 @@ BuildPickShipPopup (MELEE_STATE *pMS)
 		RECT r;
 			
 		GetBuildPickFrameRect (&r);
-		LockMutex (GraphicsLock);
 		RepairMeleeFrame (&r);
-		UnlockMutex (GraphicsLock);
 	}
 
 	UpdateCurrentShip (pMS);
@@ -1128,12 +1106,10 @@ DoEdit (MELEE_STATE *pMS)
 			|| pMS->row == NUM_MELEE_ROWS))))
 	{
 		// Done editing the teams.
-		LockMutex (GraphicsLock);
 		Deselect (EDIT_MELEE);
 		pMS->currentShip = MELEE_NONE;
 		pMS->MeleeOption = START_MELEE;
 		pMS->InputFunc = DoMelee;
-		UnlockMutex (GraphicsLock);
 		pMS->LastInputTime = GetTimeCounter ();
 	}
 	else if (pMS->row < NUM_MELEE_ROWS
@@ -1147,20 +1123,16 @@ DoEdit (MELEE_STATE *pMS)
 			&& PulsedInputState.menu[KEY_MENU_SPECIAL])
 	{
 		// TODO: this is a stub; Should we display a ship spin?
-		LockMutex (GraphicsLock);
 		Deselect (EDIT_MELEE);
 		if (pMS->currentShip != MELEE_NONE)
 		{
 			// Do something with pMS->currentShip here
 		}
-		UnlockMutex (GraphicsLock);
 	}
 	else if (pMS->row < NUM_MELEE_ROWS &&
-			(PulsedInputState.menu[KEY_MENU_BACKSPACE]
-			 || PulsedInputState.menu[KEY_MENU_DELETE]))
+			PulsedInputState.menu[KEY_MENU_DELETE])
 	{
 		// Remove the currently selected ship from the current team.
-		// JMS: Due to wishes from OSX community, KEY_MENU_BACKSPACE was added here.
 		Deselect (EDIT_MELEE);
 		DeleteCurrentShip (pMS);
 		AdvanceCursor (pMS);
@@ -1182,9 +1154,7 @@ DoEdit (MELEE_STATE *pMS)
 
 				// going to enter text
 				pMS->CurIndex = 0;
-				LockMutex (GraphicsLock);
 				DrawTeamString (pMS, pMS->side, DTSHS_EDIT, NULL);
-				UnlockMutex (GraphicsLock);
 
 				strncpy (buf, MeleeSetup_getTeamName (
 						pMS->meleeSetup, pMS->side), MAX_TEAM_CHARS);
@@ -1255,12 +1225,10 @@ DoEdit (MELEE_STATE *pMS)
 
 		if (col != pMS->col || row != pMS->row || side != pMS->side)
 		{
-			LockMutex (GraphicsLock);
 			Deselect (EDIT_MELEE);
 			pMS->side = side;
 			pMS->row = row;
 			pMS->col = col;
-			UnlockMutex (GraphicsLock);
 
 			UpdateCurrentShip (pMS);
 		}
@@ -1505,9 +1473,7 @@ StartMelee (MELEE_STATE *pMS)
 	{
 		if (!SetPlayerInputAll ())
 			break;
-		LockMutex (GraphicsLock);
 		BuildAndDrawShipList (pMS);
-		UnlockMutex (GraphicsLock);
 
 		WaitForSoundEnd (TFBSOUND_WAIT_ALL);
 
@@ -1655,15 +1621,15 @@ DoConnectingDialog (MELEE_STATE *pMS)
 		pMS->InputFunc = DoConnectingDialog;
 
 		/* Draw the dialog box here */
-		LockMutex (GraphicsLock);
 		oldfont = SetContextFont (StarConFont);
 		oldcolor = SetContextForeGroundColor (BLACK_COLOR);
 		BatchGraphics ();
-		r.extent.width = 200 << RESOLUTION_FACTOR; // JMS_GFX
-		r.extent.height = 30 << RESOLUTION_FACTOR; // JMS_GFX
+		r.extent.width = 200;
+		r.extent.height = 30;
 		r.corner.x = (SCREEN_WIDTH - r.extent.width) >> 1;
 		r.corner.y = (SCREEN_HEIGHT - r.extent.height) >> 1;
-		DrawShadowedBox (&r, SHADOWBOX_BACKGROUND_COLOR, SHADOWBOX_DARK_COLOR, SHADOWBOX_MEDIUM_COLOR);
+		DrawShadowedBox (&r, SHADOWBOX_BACKGROUND_COLOR, 
+				SHADOWBOX_DARK_COLOR, SHADOWBOX_MEDIUM_COLOR);
 
 		if (NetConnection_getPeerOptions (conn)->isServer)
 		{
@@ -1675,7 +1641,7 @@ DoConnectingDialog (MELEE_STATE *pMS)
 			t.pStr = GAME_STRING (NETMELEE_STRING_BASE + 2);
 					/* "Awaiting outgoing connection */
 		}
-		t.baseline.y = r.corner.y + (10 << RESOLUTION_FACTOR); // JMS_GFX
+		t.baseline.y = r.corner.y + (10 << RESOLUTION_FACTOR);
 		t.baseline.x = SCREEN_WIDTH >> 1;
 		t.align = ALIGN_CENTER;
 		t.CharCount = ~0;
@@ -1683,14 +1649,13 @@ DoConnectingDialog (MELEE_STATE *pMS)
 
 		t.pStr = GAME_STRING (NETMELEE_STRING_BASE + 18);
 				/* "Press SPACE to cancel" */
-		t.baseline.y += 16 << RESOLUTION_FACTOR; // JMS_GFX
+		t.baseline.y += 16 << RESOLUTION_FACTOR;
 		font_DrawText (&t);
 
 		// Restore original graphics
 		SetContextFont (oldfont);
 		SetContextForeGroundColor (oldcolor);
 		UnbatchGraphics ();
-		UnlockMutex (GraphicsLock);
 	}
 
 	netInput ();
@@ -1898,9 +1863,7 @@ DoMelee (MELEE_STATE *pMS)
 		
 		pMS->MeleeOption = START_MELEE;
 		PlayMusic (pMS->hMusic, TRUE, 1);
-		LockMutex (GraphicsLock);
 		InitMelee (pMS);
-		UnlockMutex (GraphicsLock);
 
 		FadeScreen (FadeAllToColor, ONE_SECOND / 2);
 		pMS->LastInputTime = GetTimeCounter ();
@@ -1915,10 +1878,8 @@ DoMelee (MELEE_STATE *pMS)
 			PulsedInputState.menu[KEY_MENU_LEFT])
 	{
 		// Start editing the teams.
-		LockMutex (GraphicsLock);
 		pMS->LastInputTime = GetTimeCounter ();
 		Deselect (pMS->MeleeOption);
-		UnlockMutex (GraphicsLock);
 		pMS->MeleeOption = EDIT_MELEE;
 		pMS->Initialized = FALSE;
 		if (PulsedInputState.menu[KEY_MENU_CANCEL])
@@ -1965,11 +1926,9 @@ DoMelee (MELEE_STATE *pMS)
 					pMS->MeleeOption == CONTROLS_BOT)
 				UpdateMeleeStatusMessage (-1);
 #endif
-			LockMutex (GraphicsLock);
 			Deselect (pMS->MeleeOption);
 			pMS->MeleeOption = NewMeleeOption;
 			Select (pMS->MeleeOption);
-			UnlockMutex (GraphicsLock);
 #ifdef NETPLAY
 			if (NewMeleeOption == CONTROLS_TOP ||
 					NewMeleeOption == CONTROLS_BOT)
@@ -2164,14 +2123,12 @@ updateRandomSeed (MELEE_STATE *pMS, COUN
 void
 confirmationCancelled (MELEE_STATE *pMS, COUNT side)
 {
-	LockMutex (GraphicsLock);
 	if (side == 0)
 		DrawMeleeStatusMessage (GAME_STRING (NETMELEE_STRING_BASE + 16));
 				// "Bottom player changed something -- need to reconfirm."
 	else
 		DrawMeleeStatusMessage (GAME_STRING (NETMELEE_STRING_BASE + 17));
 				// "Top player changed something -- need to reconfirm."
-	UnlockMutex (GraphicsLock);
 
 	if (pMS->InputFunc == DoConfirmSettings)
 		pMS->InputFunc = DoMelee;
@@ -2184,9 +2141,7 @@ connectionFeedback (NetConnection *conn,
 	if (bs == NULL && !forcePopup)
 	{
 		// bs == NULL means the game has not started yet.
-		LockMutex (GraphicsLock);
 		DrawMeleeStatusMessage (str);
-		UnlockMutex (GraphicsLock);
 	}
 	else
 	{
@@ -2330,10 +2285,8 @@ Melee_UpdateView_fleetValue (MELEE_STATE
 	if (pMS->meleeStarted)
 		return;
 
-	LockMutex (GraphicsLock);
 	DrawFleetValue (pMS, side, DTSHS_REPAIR);
 			// BUG: The fleet value is always drawn as deselected.
-	UnlockMutex (GraphicsLock);
 }
 
 static void
@@ -2346,7 +2299,6 @@ Melee_UpdateView_ship (MELEE_STATE *pMS,
 
 	ship = MeleeSetup_getShip (pMS->meleeSetup, side, index);
 
-	LockMutex (GraphicsLock);
 	if (ship == MELEE_NONE)
 	{
 		ClearShipBox (side, index);
@@ -2355,7 +2307,6 @@ Melee_UpdateView_ship (MELEE_STATE *pMS,
 	{
 		DrawShipBox (side, index, ship, FALSE);
 	}
-	UnlockMutex (GraphicsLock);
 }
 
 static void
@@ -2364,9 +2315,7 @@ Melee_UpdateView_teamName (MELEE_STATE *
 	if (pMS->meleeStarted)
 		return;
 
-	LockMutex (GraphicsLock);
 	DrawTeamString (pMS, side, DTSHS_REPAIR, NULL);
-	UnlockMutex (GraphicsLock);
 }
 
 ///////////////////////////////////////////////////////////////////////////
@@ -2394,9 +2343,7 @@ Melee_Change_ship (MELEE_STATE *pMS, COU
 	if (isShipSlotSelected (pMS, side, index))
 	{
 		pMS->currentShip = ship;
-		LockMutex (GraphicsLock);
 		DrawMeleeShipStrings (pMS, ship);
-		UnlockMutex (GraphicsLock);
 	}
 
 	return true;
diff -ruNp src.hd/uqm/supermelee/melee.h src/uqm/supermelee/melee.h
--- src.hd/uqm/supermelee/melee.h	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/melee.h	2017-12-29 00:57:54 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #ifndef _MELEE_H
 #define _MELEE_H
 
@@ -30,14 +28,18 @@
 #include "netplay/packet.h"
 		// for NetplayAbortReason and NetplayResetReason.
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef struct melee_state MELEE_STATE;
 
 #define NUM_MELEE_ROWS 2
 #define NUM_MELEE_COLUMNS 7
 //#define NUM_MELEE_COLUMNS 6
 #define MELEE_FLEET_SIZE (NUM_MELEE_ROWS * NUM_MELEE_COLUMNS)
-#define ICON_WIDTH (16 << RESOLUTION_FACTOR) // JMS_GFX
-#define ICON_HEIGHT (16 << RESOLUTION_FACTOR) // JMS_GFX
+#define ICON_WIDTH (16 << RESOLUTION_FACTOR)
+#define ICON_HEIGHT (16 << RESOLUTION_FACTOR)
 
 extern FRAME PickMeleeFrame;
 
@@ -52,10 +54,18 @@ extern FRAME PickMeleeFrame;
 
 typedef BYTE MELEE_OPTIONS;
 
+#if defined(__cplusplus)
+}
+#endif
+
 #include "loadmele.h"
 #include "meleesetup.h"
 #include "meleeship.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 struct melee_state
 {
 	BOOLEAN (*InputFunc) (struct melee_state *pInputState);
@@ -127,5 +137,9 @@ void Melee_RemoteChange_ship (MELEE_STAT
 void Melee_RemoteChange_teamName (MELEE_STATE *pMS, NetConnection *conn,
 		COUNT side, const char *name);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _MELEE_H */
 
diff -ruNp src.hd/uqm/supermelee/meleesetup.h src/uqm/supermelee/meleesetup.h
--- src.hd/uqm/supermelee/meleesetup.h	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/meleesetup.h	2017-12-29 00:57:54 -0800
@@ -32,6 +32,10 @@ typedef COUNT FleetShipIndex;
 #include "melee.h"
 #include "meleeship.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #ifdef MELEETEAM_INTERNAL
 struct MeleeTeam
 {
@@ -131,5 +135,9 @@ void MeleeState_setTeamName (MELEE_STATE
 void MeleeState_setTeam (MELEE_STATE *pMS, size_t teamNr,
 		const MeleeTeam *team);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* MELEESETUP_H */
 
diff -ruNp src.hd/uqm/supermelee/meleeship.h src/uqm/supermelee/meleeship.h
--- src.hd/uqm/supermelee/meleeship.h	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/meleeship.h	2017-12-29 00:57:54 -0800
@@ -3,6 +3,10 @@
 
 #include "types.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef enum MeleeShip {
 	MELEE_ANDROSYNTH,
 	MELEE_ARILOU,
@@ -43,5 +47,9 @@ MeleeShip_valid (MeleeShip ship)
 	return (ship < NUM_MELEE_SHIPS) || (ship == MELEE_NONE);
 }
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* MELEESHIP_H */
 
diff -ruNp src.hd/uqm/supermelee/netplay/Makeinfo src/uqm/supermelee/netplay/Makeinfo
--- src.hd/uqm/supermelee/netplay/Makeinfo	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/netplay/Makeinfo	2017-12-29 00:57:54 -0800
@@ -1,3 +1,4 @@
 uqm_SUBDIRS="proto"
 uqm_CFILES="checkbuf.c checksum.c crc.c netconnection.c netinput.c netmelee.c netmisc.c netoptions.c netrcv.c netsend.c netstate.c notify.c notifyall.c packet.c packethandlers.c packetsenders.c packetq.c"
+uqm_HFILES="checkbuf.h checksum.h crc.h netconnection.h netinput.h netmelee.h netmisc.h netoptions.h netplay.h netrcv.h netsend.h netstate.h notifyall.h notify.h packet.h packethandlers.h packetq.h packetsenders.h"
 
diff -ruNp src.hd/uqm/supermelee/netplay/checkbuf.h src/uqm/supermelee/netplay/checkbuf.h
--- src.hd/uqm/supermelee/netplay/checkbuf.h	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/netplay/checkbuf.h	2017-12-29 00:57:54 -0800
@@ -19,13 +19,25 @@
 #ifndef _CHECKBUF_H
 #define _CHECKBUF_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef struct ChecksumEntry ChecksumEntry;
 typedef struct ChecksumBuffer ChecksumBuffer;
 
+#if defined(__cplusplus)
+}
+#endif
+
 #include "../../battle.h"
 		// for BattleFrameCounter
 #include "checksum.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 
 struct ChecksumEntry {
 #ifdef NETPLAY_DEBUG
@@ -58,5 +70,9 @@ bool ChecksumBuffer_addChecksum(Checksum
 bool ChecksumBuffer_getChecksum(ChecksumBuffer *cb,
 		BattleFrameCounter frameNr, Checksum *result);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _CHECKBUF_H */
 
diff -ruNp src.hd/uqm/supermelee/netplay/checksum.h src/uqm/supermelee/netplay/checksum.h
--- src.hd/uqm/supermelee/netplay/checksum.h	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/netplay/checksum.h	2017-12-29 00:57:54 -0800
@@ -33,6 +33,10 @@ typedef uint32 Checksum;
 
 #include "netconnection.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 
 static inline void
 crc_processELEMENT_FLAGS(crc_State *state, ELEMENT_FLAGS val) {
@@ -88,6 +92,10 @@ void addRemoteChecksum(NetConnection *co
 		Checksum checksum);
 bool verifyChecksums(BattleFrameCounter frameNr);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _CHECKSUM_H */
 
 
diff -ruNp src.hd/uqm/supermelee/netplay/crc.h src/uqm/supermelee/netplay/crc.h
--- src.hd/uqm/supermelee/netplay/crc.h	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/netplay/crc.h	2017-12-29 00:57:54 -0800
@@ -25,6 +25,10 @@ typedef struct crc_State crc_State;
 
 #include <stddef.h>
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 struct crc_State {
 	uint32 crc;
 };
@@ -36,6 +40,9 @@ void crc_processUint16(crc_State *state,
 void crc_processUint32(crc_State *state, uint32 val);
 uint32 crc_finish(const crc_State *state);
 
+#if defined(__cplusplus)
+}
+#endif
 
 #ifdef DUMP_CRC_OPS
 #include "netconnection.h"
diff -ruNp src.hd/uqm/supermelee/netplay/netconnection.h src/uqm/supermelee/netplay/netconnection.h
--- src.hd/uqm/supermelee/netplay/netconnection.h	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/netplay/netconnection.h	2017-12-29 00:57:54 -0800
@@ -22,6 +22,10 @@
 #include "netplay.h"
 		// for NETPLAY_STATISTICS
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef struct NetConnection NetConnection;
 typedef struct NetConnectionError NetConnectionError;
 typedef struct ConnectStateData ConnectStateData;
@@ -38,6 +42,10 @@ typedef void (*NetConnection_DeleteCallb
 typedef void (*NetConnection_ReadyCallback)(NetConnection *conn, void *arg);
 typedef void (*NetConnection_ResetCallback)(NetConnection *conn, void *arg);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #include "netstate.h"
 #include "netoptions.h"
 #ifdef NETPLAY_CHECKSUM
@@ -50,6 +58,10 @@ typedef void (*NetConnection_ResetCallba
 #	include "libs/uio.h"
 #endif
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 struct NetConnectionError {
 	NetState state;
 	int err;
@@ -68,11 +80,18 @@ struct NetStatistics {
 };
 #endif
 
+#if defined(__cplusplus)
+}
+#endif
 
 #ifdef NETCONNECTION_INTERNAL
 #include "libs/net.h"
 #include "packetq.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef struct {
 	// For actions that require agreement by both parties.
 	bool localOk : 1;    /* Action confirmed by us */
@@ -232,6 +251,9 @@ void *NetConnection_getResetCallbackArg(
 extern uio_Stream *netplayDebugFile;
 #endif
 
+#if defined(__cplusplus)
+}
+#endif
 
 #endif  /* _NETCONNECTION_H */
 
diff -ruNp src.hd/uqm/supermelee/netplay/netinput.h src/uqm/supermelee/netplay/netinput.h
--- src.hd/uqm/supermelee/netplay/netinput.h	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/netplay/netinput.h	2017-12-29 00:57:54 -0800
@@ -22,6 +22,10 @@
 #include "../../controls.h"
 		// for BATTLE_INPUT_STATE
 #include "../../init.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
 		// for NUM_PLAYERS
 
 typedef struct BattleInputBuffer {
@@ -46,5 +50,9 @@ bool BattleInputBuffer_pop(BattleInputBu
 
 BattleInputBuffer *getBattleInputBuffer(size_t player);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _NETINPUT_H */
 
diff -ruNp src.hd/uqm/supermelee/netplay/netmelee.c src/uqm/supermelee/netplay/netmelee.c
--- src.hd/uqm/supermelee/netplay/netmelee.c	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/netplay/netmelee.c	2017-12-29 00:57:54 -0800
@@ -17,7 +17,7 @@
  */
 
 #include "netmelee.h"
-#include "libs/alarm.h"
+#include "libs/async.h"
 #include "libs/callback.h"
 #include "libs/log.h"
 #include "libs/net.h"
@@ -146,8 +146,7 @@ netInputAux(uint32 timeoutMs) {
 	NetManager_process(&timeoutMs);
 			// This may cause more packets to be queued, hence the
 			// flushPacketQueues().
-	Alarm_process();
-	Callback_process();
+	Async_process();
 	flushPacketQueues();
 			// During the flush, a disconnect may be noticed, which triggers
 			// another callback. It must be handled immediately, before
@@ -166,11 +165,11 @@ netInput(void) {
 
 void
 netInputBlocking(uint32 timeoutMs) {
-	uint32 nextAlarmMs;
+	uint32 nextAsyncMs;
 		
-	nextAlarmMs = Alarm_timeBeforeNextMs();
-	if (nextAlarmMs < timeoutMs)
-		timeoutMs = nextAlarmMs;
+	nextAsyncMs = Async_timeBeforeNextMs();
+	if (nextAsyncMs < timeoutMs)
+		timeoutMs = nextAsyncMs;
 
 	netInputAux(timeoutMs);
 }
diff -ruNp src.hd/uqm/supermelee/netplay/netmelee.h src/uqm/supermelee/netplay/netmelee.h
--- src.hd/uqm/supermelee/netplay/netmelee.h	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/netplay/netmelee.h	2017-12-29 00:57:54 -0800
@@ -31,6 +31,9 @@
 #include "../../races.h"
 		// for STARSHIP
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
 extern struct NetConnection *netConnections[];
 
@@ -80,6 +83,10 @@ bool waitReady(NetConnection *conn);
 bool waitReset(NetConnection *conn, NetState nextState);
 bool waitResetConnections(NetState nextState);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _NETMELEE_H */
 
 
diff -ruNp src.hd/uqm/supermelee/netplay/netmisc.h src/uqm/supermelee/netplay/netmisc.h
--- src.hd/uqm/supermelee/netplay/netmisc.h	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/netplay/netmisc.h	2017-12-29 00:57:54 -0800
@@ -28,6 +28,10 @@ typedef struct BattleStateData BattleSta
 #include "../../battle.h"
 		// for BattleFrameCounter, BATTLE_FRAME_RATE
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 struct BattleStateData {
 	NETCONNECTION_STATE_DATA_COMMON
 
@@ -66,6 +70,10 @@ readyFlagsMeaningful(NetState state) {
 }
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _NETMISC_H */
 
 
diff -ruNp src.hd/uqm/supermelee/netplay/netoptions.h src/uqm/supermelee/netplay/netoptions.h
--- src.hd/uqm/supermelee/netplay/netoptions.h	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/netplay/netoptions.h	2017-12-29 00:57:54 -0800
@@ -23,6 +23,10 @@
 
 #include <stddef.h>
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #define NETPLAY_NUM_PLAYERS 2
 		// Not using NUM_PLAYERS because that would mean we'd have
 		// to include init.h, and all that comes with it.
@@ -45,6 +49,10 @@ typedef struct {
 extern NetplayOptions netplayOptions;
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _NETOPTIONS_H */
 
 
diff -ruNp src.hd/uqm/supermelee/netplay/netrcv.h src/uqm/supermelee/netplay/netrcv.h
--- src.hd/uqm/supermelee/netplay/netrcv.h	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/netplay/netrcv.h	2017-12-29 00:57:55 -0800
@@ -21,7 +21,15 @@
 
 #include "libs/net.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 void dataReadyCallback(NetDescriptor *nd);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _NETRCV_H */
 
diff -ruNp src.hd/uqm/supermelee/netplay/netsend.h src/uqm/supermelee/netplay/netsend.h
--- src.hd/uqm/supermelee/netplay/netsend.h	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/netplay/netsend.h	2017-12-29 00:57:55 -0800
@@ -21,8 +21,16 @@
 
 #include "packet.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 int sendPacket(NetConnection *conn, Packet *packet);
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _NETSEND_H */
 
diff -ruNp src.hd/uqm/supermelee/netplay/netstate.h src/uqm/supermelee/netplay/netstate.h
--- src.hd/uqm/supermelee/netplay/netstate.h	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/netplay/netstate.h	2017-12-29 00:57:55 -0800
@@ -21,6 +21,9 @@
 
 #include "port.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
 typedef struct NetConnectionStateData NetConnectionStateData;
 
@@ -38,8 +41,16 @@ typedef enum {
 	NetState_endingBattle2,  /* Waiting for the final synchronisation */
 } NetState;
 
+#if defined(__cplusplus)
+}
+#endif
+
 #include "types.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef struct {
 	const char *name;
 } NetStateData;
@@ -65,5 +76,9 @@ NetState_battleActive(NetState state) {
 }
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _NETSTATE_H */
 
diff -ruNp src.hd/uqm/supermelee/netplay/notify.h src/uqm/supermelee/netplay/notify.h
--- src.hd/uqm/supermelee/netplay/notify.h	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/netplay/notify.h	2017-12-29 00:57:55 -0800
@@ -32,6 +32,10 @@
 #include "../meleesetup.h"
 		// for FleetShipIndex
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 void Netplay_Notify_shipSelected(NetConnection *conn, FleetShipIndex index);
 void Netplay_Notify_battleInput(NetConnection *conn,
 		BATTLE_INPUT_STATE input);
@@ -51,5 +55,9 @@ void Netplay_Notify_checksum(NetConnecti
 #endif
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _NOTIFY_H */
 
diff -ruNp src.hd/uqm/supermelee/netplay/notifyall.h src/uqm/supermelee/netplay/notifyall.h
--- src.hd/uqm/supermelee/netplay/notifyall.h	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/netplay/notifyall.h	2017-12-29 00:57:55 -0800
@@ -24,6 +24,10 @@
 #	include "checksum.h"
 #endif  /* NETPLAY_CHECKSUM */
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 void Netplay_NotifyAll_setTeamName (MELEE_STATE *pMS, size_t playerNr);
 void Netplay_NotifyAll_setFleet (MELEE_STATE *pMS, size_t playerNr);
 void Netplay_NotifyAll_setShip (MELEE_STATE *pMS, size_t playerNr,
@@ -37,5 +41,9 @@ void Netplay_NotifyAll_checksum(BattleFr
 void Netplay_NotifyAll_battleInput(BATTLE_INPUT_STATE input);
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* NOTIFYALL_H */
 
diff -ruNp src.hd/uqm/supermelee/netplay/packet.h src/uqm/supermelee/netplay/packet.h
--- src.hd/uqm/supermelee/netplay/packet.h	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/netplay/packet.h	2017-12-29 00:57:55 -0800
@@ -19,6 +19,10 @@
 #ifndef _PACKET_H
 #define _PACKET_H
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef struct Packet Packet;
 
 typedef enum PacketType {
@@ -60,12 +64,19 @@ typedef enum NetplayResetReason {
 	ResetReason_manualReset,
 } NetplayResetReason;
 
+#if defined(__cplusplus)
+}
+#endif
+
 #ifndef PACKET_H_STANDALONE
 #include "netconnection.h"
 
 #include "types.h"
 #include "libs/network/bytesex.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
 /* NB: These handlers are expected not to modify the state if an
  *     error occurs.
@@ -81,8 +92,16 @@ typedef struct {
 } PacketTypeData;
 
 extern PacketTypeData packetTypeData[];
+
+#if defined(__cplusplus)
+}
+#endif
+
 #endif
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
 // When adding new packets, be sure to have all the fields properly aligned,
 // and that the size of a packet is a multiple of 4 bytes in length.
@@ -272,6 +291,9 @@ Packet_Abort *Packet_Abort_create(uint16
 Packet_Reset *Packet_Reset_create(uint16 reason);
 #endif
 
+#if defined(__cplusplus)
+}
+#endif
 
 #endif  /* _PACKET_H */
 
diff -ruNp src.hd/uqm/supermelee/netplay/packethandlers.c src/uqm/supermelee/netplay/packethandlers.c
--- src.hd/uqm/supermelee/netplay/packethandlers.c	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/netplay/packethandlers.c	2017-12-29 00:57:55 -0800
@@ -199,8 +199,8 @@ PacketHandler_Fleet(NetConnection *conn,
 	if (sizeof packet + numShips * sizeof(packet->ships[0]) > len) {
 		// There is not enough room in the packet to contain all
 		// the ships it says it contains.
-		log_add(log_Warning, "Invalid fleet size. Specified size is %u, "
-				"actual size = %lu",
+		log_add(log_Warning, "Invalid fleet size. Specified size is %d, "
+				"actual size = %d",
 				numShips, (len - sizeof packet) / sizeof(packet->ships[0]));
 		errno = EBADMSG;
 		return -1;
@@ -577,7 +577,7 @@ PacketHandler_Checksum(NetConnection *co
 	if (frameNr % interval != 0) {
 		log_add(log_Warning, "NETPLAY: [%d] <== Received checksum "
 				"for frame %u, while we only expect checksums on frames "
-				"divisable by %lu -- discarding.", conn->player,
+				"divisable by %u -- discarding.", conn->player,
 				(unsigned int) frameNr, interval);
 		return 0;
 				// No need to close the connection; checksums are not
@@ -592,7 +592,7 @@ PacketHandler_Checksum(NetConnection *co
 	if (frameNr > battleFrameCount + delay + 1) {
 		log_add(log_Warning, "NETPLAY: [%d] <== Received checksum "
 				"for a frame too far in the future (frame %u, current "
-				"is %u, input delay is %lu) -- discarding.", conn->player,
+				"is %u, input delay is %u) -- discarding.", conn->player,
 				(unsigned int) frameNr, battleFrameCount, delay);
 		return 0;
 				// No need to close the connection; checksums are not
@@ -609,7 +609,7 @@ PacketHandler_Checksum(NetConnection *co
 	if (frameNr + delay < battleFrameCount) {
 		log_add(log_Warning, "NETPLAY: [%d] <== Received checksum "
 				"for a frame too far in the past (frame %u, current "
-				"is %u, input delay is %lu) -- discarding.", conn->player,
+				"is %u, input delay is %u) -- discarding.", conn->player,
 				(unsigned int) frameNr, battleFrameCount, delay);
 		return 0;
 				// No need to close the connection; checksums are not
diff -ruNp src.hd/uqm/supermelee/netplay/packethandlers.h src/uqm/supermelee/netplay/packethandlers.h
--- src.hd/uqm/supermelee/netplay/packethandlers.h	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/netplay/packethandlers.h	2017-12-29 00:57:55 -0800
@@ -21,9 +21,13 @@
 
 #include "packet.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #define DECLARE_PACKETHANDLER(type) \
 		int PacketHandler_##type(NetConnection *conn, \
-				const Packet_##type *packet);
+				const Packet_##type *packet)
 
 DECLARE_PACKETHANDLER(Init);
 DECLARE_PACKETHANDLER(Ping);
@@ -45,4 +49,8 @@ DECLARE_PACKETHANDLER(Abort);
 DECLARE_PACKETHANDLER(Reset);
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _PACKETHANDLERS_H */
diff -ruNp src.hd/uqm/supermelee/netplay/packetq.h src/uqm/supermelee/netplay/packetq.h
--- src.hd/uqm/supermelee/netplay/packetq.h	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/netplay/packetq.h	2017-12-29 00:57:55 -0800
@@ -26,6 +26,10 @@ typedef struct PacketQueue PacketQueue;
 
 #include <sys/types.h>
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef struct PacketQueueLink PacketQueueLink;
 struct PacketQueueLink {
 	PacketQueueLink *next;
@@ -47,5 +51,9 @@ void queuePacket(NetConnection *conn, Pa
 int flushPacketQueue(NetConnection *conn);
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif
 
diff -ruNp src.hd/uqm/supermelee/netplay/packetsenders.h src/uqm/supermelee/netplay/packetsenders.h
--- src.hd/uqm/supermelee/netplay/packetsenders.h	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/netplay/packetsenders.h	2017-12-29 00:57:55 -0800
@@ -31,6 +31,10 @@
 #include "../meleesetup.h"
 		// for FleetShipIndex
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 void sendInit(NetConnection *conn);
 void sendPing(NetConnection *conn, uint32 id);
 void sendAck(NetConnection *conn, uint32 id);
@@ -56,6 +60,10 @@ void sendAbort(NetConnection *conn, Netp
 void sendReset(NetConnection *conn, NetplayResetReason reason);
 
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _PACKETSENDERS_H */
 
 
diff -ruNp src.hd/uqm/supermelee/netplay/proto/Makeinfo src/uqm/supermelee/netplay/proto/Makeinfo
--- src.hd/uqm/supermelee/netplay/proto/Makeinfo	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/netplay/proto/Makeinfo	2017-12-29 00:57:55 -0800
@@ -1,2 +1,2 @@
 uqm_CFILES="npconfirm.c ready.c reset.c"
-
+uqm_HFILES="npconfirm.h ready.h reset.h"
diff -ruNp src.hd/uqm/supermelee/netplay/proto/npconfirm.h src/uqm/supermelee/netplay/proto/npconfirm.h
--- src.hd/uqm/supermelee/netplay/proto/npconfirm.h	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/netplay/proto/npconfirm.h	2017-12-29 00:57:55 -0800
@@ -22,9 +22,17 @@
 #include "../netplay.h"
 #include "../netconnection.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 int Netplay_confirm(NetConnection *conn);
 int Netplay_cancelConfirmation(NetConnection *conn);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _NPCONFIRM_H */
 
 
diff -ruNp src.hd/uqm/supermelee/netplay/proto/ready.h src/uqm/supermelee/netplay/proto/ready.h
--- src.hd/uqm/supermelee/netplay/proto/ready.h	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/netplay/proto/ready.h	2017-12-29 00:57:55 -0800
@@ -21,11 +21,19 @@
 
 #include "../netconnection.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 bool Netplay_localReady(NetConnection *conn,
 		NetConnection_ReadyCallback callback, void *arg, bool notifyRemote);
 bool Netplay_remoteReady(NetConnection *conn);
 bool Netplay_isLocalReady(const NetConnection *conn);
 bool Netplay_isRemoteReady(const NetConnection *conn);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _READY_H */
 
diff -ruNp src.hd/uqm/supermelee/netplay/proto/reset.h src/uqm/supermelee/netplay/proto/reset.h
--- src.hd/uqm/supermelee/netplay/proto/reset.h	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/netplay/proto/reset.h	2017-12-29 00:57:55 -0800
@@ -22,6 +22,10 @@
 #include "../netconnection.h"
 #include "../packet.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 void Netplay_setResetCallback(NetConnection *conn,
 		NetConnection_ResetCallback callback, void *resetArg);
 void Netplay_localReset(NetConnection *conn, NetplayResetReason reason);
@@ -29,6 +33,9 @@ void Netplay_remoteReset(NetConnection *
 bool Netplay_isLocalReset(const NetConnection *conn);
 bool Netplay_isRemoteReset(const NetConnection *conn);
 
+#if defined(__cplusplus)
+}
+#endif
 
 #endif  /* _RESET_H */
 
diff -ruNp src.hd/uqm/supermelee/pickmele.c src/uqm/supermelee/pickmele.c
--- src.hd/uqm/supermelee/pickmele.c	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/pickmele.c	2017-12-29 00:57:55 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #define PICKMELE_INTERNAL
 #include "pickmele.h"
 
@@ -39,6 +37,7 @@
 #include "../races.h"
 #include "../setup.h"
 #include "../sounds.h"
+#include "libs/async.h"
 #include "libs/log.h"
 #include "libs/mathlib.h"
 
@@ -50,7 +49,6 @@
 #define PICK_Y_OFFS (24 << RESOLUTION_FACTOR) // JMS_GFX
 #define PICK_SIDE_OFFS (100 << RESOLUTION_FACTOR) // JMS_GFX
 
-
 #define NAME_AREA_HEIGHT (7 << RESOLUTION_FACTOR) // JMS_GFX
 #define MELEE_WIDTH (149 << RESOLUTION_FACTOR) // JMS_GFX
 #define MELEE_HEIGHT ((48 << RESOLUTION_FACTOR) + NAME_AREA_HEIGHT)
@@ -153,8 +151,8 @@ PickMelee_ChangedSelection (GETMELEE_STA
 	r.corner.x = PICK_X_OFFS + ((ICON_WIDTH + (2 << RESOLUTION_FACTOR)) * gms->player[playerI].col); // JMS_GFX
 	r.corner.y = PICK_Y_OFFS + ((ICON_HEIGHT + (2 << RESOLUTION_FACTOR)) * gms->player[playerI].row) // JMS_GFX
 			+ ((1 - playerI) * PICK_SIDE_OFFS);
-	r.extent.width = (ICON_WIDTH + (2 << RESOLUTION_FACTOR)); // JMS_GFX
-	r.extent.height = (ICON_HEIGHT + (2 << RESOLUTION_FACTOR)); // JMS_GFX
+	r.extent.width = (ICON_WIDTH + (2 << RESOLUTION_FACTOR));
+	r.extent.height = (ICON_HEIGHT + (2 << RESOLUTION_FACTOR));
 	Flash_setRect (gms->player[playerI].flashContext, &r);
 }
 
@@ -453,7 +451,7 @@ UpdatePickMeleeFleetValue (FRAME frame,
 
 	// Erase the old value text.
 	GetFrameRect (frame, &r);
-	r.extent.width -= (4 << RESOLUTION_FACTOR); // JMS_GFX
+	r.extent.width -= (4 << RESOLUTION_FACTOR);
 	t.baseline.x = r.extent.width;
 	r.corner.x = r.extent.width - ((6 * 3) << RESOLUTION_FACTOR); // JMS_GFX
 	r.corner.y = 2 << RESOLUTION_FACTOR; // JMS_GFX
@@ -464,7 +462,7 @@ UpdatePickMeleeFleetValue (FRAME frame,
 
 	// Draw the new value text.
 	sprintf (buf, "%d", value);
-	t.baseline.y = 7 << RESOLUTION_FACTOR; // JMS_GFX
+	t.baseline.y = 7 << RESOLUTION_FACTOR;
 	t.align = ALIGN_RIGHT;
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
@@ -515,17 +513,17 @@ FillPickMeleeFrame (MeleeSetup *setup)
 
 	OldContext = SetContext (OffScreenContext);
 
-        for (i = 0; i < NUM_SIDES; ++i)
+	for (i = 0; i < NUM_SIDES; ++i)
 	{
 		COUNT side;
-                COUNT sideI;
+		COUNT sideI;
 		RECT r;
 		TEXT t;
 		STAMP s;
 		UNICODE buf[30];
 		FleetShipIndex index;
 
-                sideI = GetPlayerOrder (i);
+		sideI = GetPlayerOrder (i);
 		side = !sideI;
 
 		s.frame = SetAbsFrameIndex (PickMeleeFrame, side);
@@ -533,7 +531,7 @@ FillPickMeleeFrame (MeleeSetup *setup)
 
 		GetFrameRect (s.frame, &r);
 		t.baseline.x = r.extent.width >> 1;
-		t.baseline.y = r.extent.height - NAME_AREA_HEIGHT + (4 << RESOLUTION_FACTOR); // JMS_GFX
+		t.baseline.y = r.extent.height - NAME_AREA_HEIGHT + (4 << RESOLUTION_FACTOR);
 
 		r.corner.x += 2 << RESOLUTION_FACTOR;
 		r.corner.y += 2 << RESOLUTION_FACTOR;
@@ -558,8 +556,8 @@ FillPickMeleeFrame (MeleeSetup *setup)
 
 		// Total team value of the starting team:
 		sprintf (buf, "%u", MeleeSetup_getFleetValue (setup, sideI));
-		t.baseline.x = 4 << RESOLUTION_FACTOR; // JMS_GFX
-		t.baseline.y = 7 << RESOLUTION_FACTOR; // JMS_GFX
+		t.baseline.x = 4 << RESOLUTION_FACTOR;
+		t.baseline.y = 7 << RESOLUTION_FACTOR;
 		t.align = ALIGN_LEFT;
 		t.pStr = buf;
 		t.CharCount = (COUNT)~0;
@@ -596,7 +594,7 @@ FillPickMeleeFrame (MeleeSetup *setup)
 				row = PickMelee_GetShipRow (index);
 				col = PickMelee_GetShipColumn (index);
 				s.origin.x = (4 << RESOLUTION_FACTOR) + ((ICON_WIDTH + (2 << RESOLUTION_FACTOR)) * col); // JMS_GFX
-				s.origin.y = (10 << RESOLUTION_FACTOR) + ((ICON_HEIGHT + (2 << RESOLUTION_FACTOR)) * row); // JMS_GFX
+				s.origin.y = (10 << RESOLUTION_FACTOR) + ((ICON_HEIGHT + (2 << RESOLUTION_FACTOR)) * row);
 				s.frame = MasterPtr->ShipInfo.icons;
 				DrawStamp (&s);
 
@@ -639,7 +637,7 @@ DrawPickMeleeFrame (COUNT which_player)
 	oldContext = SetContext (SpaceContext);
 	s.frame = SetAbsFrameIndex (PickMeleeFrame, which_player);
 	s.origin.x = PICK_X_OFFS - (3 << RESOLUTION_FACTOR); // JMS_GFX
-	s.origin.y = PICK_Y_OFFS - (9 << RESOLUTION_FACTOR) + ((1 - which_player) * PICK_SIDE_OFFS); // JMS_GFX
+	s.origin.y = PICK_Y_OFFS - (9 << RESOLUTION_FACTOR) + ((1 - which_player) * PICK_SIDE_OFFS);
 	DrawStamp (&s);
 			// Draw the selection box to screen.
 	
@@ -658,7 +656,6 @@ MeleeGameOver (void)
 	for (playerI = 0; playerI < NUM_PLAYERS; playerI++)
 		DrawPickMeleeFrame (playerI);
 	
-	UnlockMutex (GraphicsLock);
 
 #ifdef NETPLAY
 	negotiateReadyConnections(true, NetState_inSetup);
@@ -679,12 +676,12 @@ MeleeGameOver (void)
 			ButtonState = FALSE;
 		}
 
+		Async_process ();
 		TaskSwitch ();
 	} while (!(GLOBAL (CurrentActivity) & CHECK_ABORT) && (!ButtonState
 			&& (!(PlayerControl[0] & PlayerControl[1] & PSYTRON_CONTROL)
 			|| GetTimeCounter () < TimeOut)));
 
-	LockMutex (GraphicsLock);
 }
 
 void
@@ -797,12 +794,10 @@ GetMeleeStarShips (COUNT playerMask, HST
 	
 	SetContext (OffScreenContext);
 
-	UnlockMutex (GraphicsLock);
 
 	DoInput (&gmstate, FALSE);
 	WaitForSoundEnd (0);
 
-	LockMutex (GraphicsLock);
 
 	for (playerI = 0; playerI < NUM_PLAYERS; playerI++)
 	{
diff -ruNp src.hd/uqm/supermelee/pickmele.h src/uqm/supermelee/pickmele.h
--- src.hd/uqm/supermelee/pickmele.h	2017-12-29 02:25:54 -0800
+++ src/uqm/supermelee/pickmele.h	2017-12-29 00:57:55 -0800
@@ -24,6 +24,10 @@ typedef struct getmelee_struct GETMELEE_
 #include "meleesetup.h"
 #include "libs/compiler.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 void MeleeShipDeath (STARSHIP *);
 void BuildPickMeleeFrame (void);
 void DestroyPickMeleeFrame (void);
@@ -41,12 +45,20 @@ BOOLEAN selectShipComputer (ComputerInpu
 BOOLEAN selectShipNetwork (NetworkInputContext *context, GETMELEE_STATE *gms);
 #endif  /* NETPLAY */
 
+#if defined(__cplusplus)
+}
+#endif
+
 #ifdef PICKMELE_INTERNAL
 
 #include "../flash.h"
 #include "libs/timelib.h"
 #include "../init.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 struct getmelee_struct {
 	BOOLEAN (*InputFunc) (struct getmelee_struct *pInputState);
 
@@ -80,6 +92,10 @@ struct getmelee_struct {
 bool setShipSelected(GETMELEE_STATE *gms, COUNT playerI, COUNT choice,
 		bool reportNetwork);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* PICKMELE_INTERNAL */
 
 #endif  /* _PICKMELE_H */
diff -ruNp src.hd/uqm/tactrans.c src/uqm/tactrans.c
--- src.hd/uqm/tactrans.c	2017-12-29 02:25:54 -0800
+++ src/uqm/tactrans.c	2017-12-29 00:57:56 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "tactrans.h"
 
 #include "battlecontrols.h"
@@ -49,6 +47,8 @@ static void cleanup_dead_ship (ELEMENT *
 
 static BOOLEAN dittyIsPlaying;
 static STARSHIP *winnerStarShip;
+		// Indicates which ship is the winner of the current battle.
+		// The winner will be last to pick the next ship.
 
 
 BOOLEAN
@@ -473,9 +473,6 @@ new_ship (ELEMENT *DeadShipPtr)
 		SetElementStarShip (DeadShipPtr, 0);
 		RestartMusic = OpponentAlive (DeadStarShipPtr);
 
-		if (DeadStarShipPtr->RaceDescPtr->uninit_func != NULL)
-			(*DeadStarShipPtr->RaceDescPtr->uninit_func) (
-					DeadStarShipPtr->RaceDescPtr);
 		free_ship (DeadStarShipPtr->RaceDescPtr, TRUE, TRUE);
 		DeadStarShipPtr->RaceDescPtr = 0;
 		
@@ -619,38 +616,37 @@ explosion_preprocess (ELEMENT *ShipPtr)
 }
 
 void
-ship_death (ELEMENT *ShipPtr)
+StopAllBattleMusic (void)
 {
-	STARSHIP *StarShipPtr;
-	STARSHIP *VictoriousStarShipPtr;
-	HELEMENT hElement, hNextElement;
-	ELEMENT *ElementPtr;
-
 	StopDitty ();
 	StopMusic ();
+}
 
-	GetElementStarShip (ShipPtr, &StarShipPtr);
-
-	if (ShipPtr->mass_points <= MAX_SHIP_MASS)
-	{	// Not running away and not reincarnating (Pkunk)
-		// When a ship tries to run away, it is (dis)counted in DoRunAway(),
-		// so when it dies while running away, we will not count it again
-		assert (StarShipPtr->playerNr >= 0);
-		battle_counter[StarShipPtr->playerNr]--;
-	}
+STARSHIP *
+FindAliveStarShip (ELEMENT *deadShip)
+{
+	STARSHIP *aliveShip = NULL;
+	HELEMENT hElement, hNextElement;
 
-	VictoriousStarShipPtr = NULL;
+	// Find the remaining ship, if any, and see if it is still alive.
 	for (hElement = GetHeadElement (); hElement; hElement = hNextElement)
 	{
+		ELEMENT *ElementPtr;
+
 		LockElement (hElement, &ElementPtr);
 		if ((ElementPtr->state_flags & PLAYER_SHIP)
-				&& ElementPtr != ShipPtr
+				&& ElementPtr != deadShip
 						/* and not running away */
-				&& ElementPtr->mass_points <= MAX_SHIP_MASS)
+				&& ElementPtr->mass_points <= MAX_SHIP_MASS + 1)
 		{
-			GetElementStarShip (ElementPtr, &VictoriousStarShipPtr);
-			if (VictoriousStarShipPtr->RaceDescPtr->ship_info.crew_level == 0)
-				VictoriousStarShipPtr = NULL;
+			GetElementStarShip (ElementPtr, &aliveShip);
+			assert (aliveShip != NULL);
+			if (aliveShip->RaceDescPtr->ship_info.crew_level == 0
+					/* reincarnating Pkunk is not actually dead */
+					&& ElementPtr->mass_points != MAX_SHIP_MASS + 1)
+			{
+				aliveShip = NULL;
+			}
 
 			UnlockElement (hElement);
 			break;
@@ -658,8 +654,59 @@ ship_death (ELEMENT *ShipPtr)
 		hNextElement = GetSuccElement (ElementPtr);
 		UnlockElement (hElement);
 	}
+	
+	return aliveShip;
+}
 
-	StarShipPtr->cur_status_flags &= ~PLAY_VICTORY_DITTY;
+STARSHIP *
+GetWinnerStarShip (void)
+{
+	return winnerStarShip;
+}
+
+void
+SetWinnerStarShip (STARSHIP *winner)
+{
+	if (winner == NULL)
+		return; // nothing to do
+	
+	winner->cur_status_flags |= PLAY_VICTORY_DITTY;
+
+	// The winner is set once per battle. If both ships die, this function is
+	// called twice, once for each ship. We need to preserve the winner
+	// determined on the first call.
+	if (winnerStarShip == NULL)
+		winnerStarShip = winner;
+}
+
+void
+RecordShipDeath (ELEMENT *deadShip)
+{
+	STARSHIP *deadStarShip;
+
+	GetElementStarShip (deadShip, &deadStarShip);
+	assert (deadStarShip != NULL);
+
+	if (deadShip->mass_points <= MAX_SHIP_MASS)
+	{	// Not running away.
+		// When a ship tries to run away, it is (dis)counted in DoRunAway(),
+		// so when it dies while running away, we will not count it again
+		assert (deadStarShip->playerNr >= 0);
+		battle_counter[deadStarShip->playerNr]--;
+	}
+
+	if (LOBYTE (GLOBAL (CurrentActivity)) == SUPER_MELEE)
+		MeleeShipDeath (deadStarShip);
+}
+
+void
+StartShipExplosion (ELEMENT *ShipPtr, bool playSound)
+{
+	STARSHIP *StarShipPtr;
+
+	GetElementStarShip (ShipPtr, &StarShipPtr);
+
+	ZeroVelocityComponents (&ShipPtr->velocity);
 
 	DeltaEnergy (ShipPtr,
 			-(SIZE)StarShipPtr->RaceDescPtr->ship_info.energy_level);
@@ -667,43 +714,38 @@ ship_death (ELEMENT *ShipPtr)
 	ShipPtr->life_span = NUM_EXPLOSION_FRAMES * 3;
 	ShipPtr->state_flags &= ~DISAPPEARING;
 	ShipPtr->state_flags |= FINITE_LIFE | NONSOLID;
+	ShipPtr->preprocess_func = explosion_preprocess;
 	ShipPtr->postprocess_func = PostProcessStatus;
 	ShipPtr->death_func = cleanup_dead_ship;
 	ShipPtr->hTarget = 0;
-	ZeroVelocityComponents (&ShipPtr->velocity);
-	if (ShipPtr->crew_level) /* only happens for shofixti self-destruct */
-	{
-		PlaySound (SetAbsSoundIndex (
-				StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 1),
-				CalcSoundPosition (ShipPtr), ShipPtr,
-				GAME_SOUND_PRIORITY + 1);
 
-		DeltaCrew (ShipPtr, -(SIZE)ShipPtr->crew_level);
-		if (VictoriousStarShipPtr == NULL)
-		{	// No ships left alive after a Shofixti Glory device,
-			// thus Shofixti wins
-			VictoriousStarShipPtr = StarShipPtr;
-		}
-	}
-	else
+	if (playSound)
 	{
-		ShipPtr->preprocess_func = explosion_preprocess;
-
 		PlaySound (SetAbsSoundIndex (GameSounds, SHIP_EXPLODES),
 				CalcSoundPosition (ShipPtr), ShipPtr, GAME_SOUND_PRIORITY + 1);
 	}
+}
 
-	if (VictoriousStarShipPtr != NULL)
-		VictoriousStarShipPtr->cur_status_flags |= PLAY_VICTORY_DITTY;
+void
+ship_death (ELEMENT *ShipPtr)
+{
+	STARSHIP *StarShipPtr;
+	STARSHIP *winner;
 
-	// The winner is set once per battle. If both ships die, this function is
-	// called twice, once for each ship. We need to preserve the winner
-	// determined on the first call.
-	if (winnerStarShip == NULL)
-		winnerStarShip = VictoriousStarShipPtr;
+	GetElementStarShip (ShipPtr, &StarShipPtr);
 
-	if (LOBYTE (GLOBAL (CurrentActivity)) == SUPER_MELEE)
-		MeleeShipDeath (StarShipPtr);
+	StopAllBattleMusic ();
+
+	// If the winning ship dies before the ditty starts, do not play it.
+	// e.g. a ship can die after the opponent begins exploding but
+	// before the explosion is over.
+	StarShipPtr->cur_status_flags &= ~PLAY_VICTORY_DITTY;
+
+	StartShipExplosion (ShipPtr, true);
+
+	winner = FindAliveStarShip (ShipPtr);
+	SetWinnerStarShip (winner);
+	RecordShipDeath (ShipPtr);
 }
 
 #define START_ION_COLOR BUILD_COLOR (MAKE_RGB15 (0x1F, 0x15, 0x00), 0x7A)
@@ -747,7 +789,7 @@ cycle_ion_trail (ELEMENT *ElementPtr)
 }
 
 void
-spawn_ion_trail (ELEMENT *ElementPtr)
+spawn_ion_trail (ELEMENT *ElementPtr, SIZE x_offset, SIZE y_offset)
 {
 	HELEMENT hIonElement;
 
@@ -776,20 +818,36 @@ spawn_ion_trail (ELEMENT *ElementPtr)
 				// When the element "dies", in the death_func
 				// 'cycle_ion_trail', it is given new life a number of
 				// times, by setting life_span to thrust_wait.
-		SetPrimType (&DisplayArray[IonElementPtr->PrimIndex], POINT_PRIM);
+
+		// JMS_GFX
+		if (RESOLUTION_FACTOR == 0) {
+			SetPrimType (&DisplayArray[IonElementPtr->PrimIndex], POINT_PRIM);
+			IonElementPtr->current.image.frame = DecFrameIndex (stars_in_space);
+			IonElementPtr->current.image.farray = &stars_in_space;
+		}
+		else {
+			SetPrimType (&DisplayArray[IonElementPtr->PrimIndex], STAMPFILL_PRIM);
+			IonElementPtr->current.image.frame = SetAbsFrameIndex (ion_trails[0], 0);
+			IonElementPtr->current.image.farray = ion_trails;
+		}
 		SetPrimColor (&DisplayArray[IonElementPtr->PrimIndex],
 				START_ION_COLOR);
 		IonElementPtr->colorCycleIndex = 0;
-		IonElementPtr->current.image.frame =
+		/*IonElementPtr->current.image.frame =
 				DecFrameIndex (stars_in_space);
-		IonElementPtr->current.image.farray = &stars_in_space;
+		IonElementPtr->current.image.farray = &stars_in_space;*/
 		IonElementPtr->current.location = ElementPtr->current.location;
 		IonElementPtr->current.location.x +=
-				(COORD)COSINE (angle, r.extent.height);
+				(COORD)COSINE (angle, r.extent.height) + x_offset;
 		IonElementPtr->current.location.y +=
-				(COORD)SINE (angle, r.extent.height);
+				(COORD)SINE (angle, r.extent.height) + y_offset;
 		IonElementPtr->death_func = cycle_ion_trail;
 
+		if (RESOLUTION_FACTOR > 0) {
+			IonElementPtr->next.image.frame = IonElementPtr->current.image.frame;
+			IonElementPtr->next.image.farray = IonElementPtr->current.image.farray;
+		}
+
 		SetElementStarShip (IonElementPtr, StarShipPtr);
 
 		{
@@ -895,13 +953,12 @@ ship_transition (ELEMENT *ElementPtr)
 			}
 			else if (ElementPtr->crew_level)
 			{
-                // JMS_GFX: Circumventing overflows by using temp variables
-                // instead of subtracting straight from the POINT sized
-                // ShipImagePtr->current.location.
-                SDWORD temp_x = (SDWORD)ShipImagePtr->current.location.x -
-                    COSINE (angle, TRANSITION_SPEED) * (ElementPtr->life_span - 1);
-                SDWORD temp_y = (SDWORD)ShipImagePtr->current.location.y -
-                    SINE (angle, TRANSITION_SPEED) * (ElementPtr->life_span - 1);
+				// JMS_GFX: Circumventing overflows by using temp variables instead of 
+				// subtracting straight from the POINT sized ShipImagePtr->current.location.
+				SDWORD temp_x = (SDWORD)ShipImagePtr->current.location.x -
+					COSINE (angle, TRANSITION_SPEED) * (ElementPtr->life_span - 1);
+				SDWORD temp_y = (SDWORD)ShipImagePtr->current.location.y -
+					SINE (angle, TRANSITION_SPEED) * (ElementPtr->life_span - 1);
                 
 				ShipImagePtr->current.location.x = WRAP_X (temp_x);
 				ShipImagePtr->current.location.y = WRAP_Y (temp_y);
diff -ruNp src.hd/uqm/tactrans.h src/uqm/tactrans.h
--- src.hd/uqm/tactrans.h	2017-12-29 02:25:54 -0800
+++ src/uqm/tactrans.h	2017-12-29 00:57:56 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #ifndef _TACTRANS_H
 #define _TACTRANS_H
 
@@ -26,6 +24,10 @@
 #include "element.h"
 #include "battlecontrols.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 bool battleEndReadyHuman (HumanInputContext *context);
 bool battleEndReadyComputer (ComputerInputContext *context);
 #ifdef NETPLAY
@@ -36,11 +38,21 @@ extern void ship_transition (ELEMENT *El
 extern BOOLEAN OpponentAlive (STARSHIP *TestStarShipPtr);
 extern void new_ship (ELEMENT *ElementPtr);
 extern void ship_death (ELEMENT *ShipPtr);
-extern void spawn_ion_trail (ELEMENT *ElementPtr);
+extern void spawn_ion_trail (ELEMENT *ElementPtr, SIZE x, SIZE y);
 extern void flee_preprocess (ELEMENT *ElementPtr);
 
 extern void StopDitty (void);
 extern void ResetWinnerStarShip (void);
+extern void StopAllBattleMusic (void);
+extern STARSHIP* FindAliveStarShip (ELEMENT *deadShip);
+extern STARSHIP* GetWinnerStarShip (void);
+extern void SetWinnerStarShip (STARSHIP *winner);
+extern void RecordShipDeath (ELEMENT *deadShip);
+extern void StartShipExplosion (ELEMENT *ShipPtr, bool playSound);
+
+#if defined(__cplusplus)
+}
+#endif
 
 #endif  /* _TACTRANS_H */
 
diff -ruNp src.hd/uqm/units.h src/uqm/units.h
--- src.hd/uqm/units.h	2017-12-29 02:25:55 -0800
+++ src/uqm/units.h	2017-12-29 00:57:56 -0800
@@ -16,16 +16,18 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #ifndef _UNITS_H
 #define _UNITS_H
 
 #include "libs/gfxlib.h"
+#include "options.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
 
 extern int ScreenWidth;
 extern int ScreenHeight;
-extern unsigned int resolutionFactor; // JMS_GFX
 
 		/* Most basic resolution units. */
 #define SCREEN_WIDTH ScreenWidth
@@ -33,6 +35,7 @@ extern unsigned int resolutionFactor; //
 #define RESOLUTION_FACTOR resolutionFactor														// JMS_GFX
 #define RES_CASE(a,b,c) (RESOLUTION_FACTOR == 0 ? (a) : (RESOLUTION_FACTOR == 1 ? (b) : (c)))	// JMS_GFX
 #define RES_STAT_SCALE(a) (RESOLUTION_FACTOR < 2 ? ((a) << RESOLUTION_FACTOR) : ((a) * 3))		// JMS_GFX
+#define RES_SCALE(a) ((a) << RESOLUTION_FACTOR)
 
 		/* Margins. */
 #define SAFE_X 0
@@ -59,14 +62,11 @@ extern unsigned int resolutionFactor; //
 /* Height of the usable part of the space "window": 3, 6, 6 for the grey bottom border and 10, 20, 30 for the title */
 #define RES_SIS_SCALE(a) ((SIZE)(a) * SIS_SCREEN_WIDTH / 242) // JMS_GFX
 
-
-
-
 		/* Radar. */
 #define RADAR_X (RES_STAT_SCALE(4) + (SCREEN_WIDTH - STATUS_WIDTH - SAFE_X))	// JMS_GFX
 #define RADAR_WIDTH (STATUS_WIDTH - RES_STAT_SCALE(8))							// JMS_GFX
 #define RADAR_HEIGHT RES_STAT_SCALE(53)											// JMS_GFX
-#define RADAR_Y (SIS_ORG_Y + SIS_SCREEN_HEIGHT - (53 << RESOLUTION_FACTOR))		// JMS_GFX
+#define RADAR_Y (SIS_ORG_Y + SIS_SCREEN_HEIGHT - RADAR_HEIGHT)		// JMS_GFX
 
 		/* Blue boxes which display messages and the green date box. */
 #define SIS_TITLE_BOX_WIDTH    (57 << RESOLUTION_FACTOR)						// JMS_GFX
@@ -155,106 +155,36 @@ static inline SDWORD
 logxToUniverse (SDWORD lx)
 {
 	return (SDWORD) ((lx * UNIVERSE_UNITS_X + ROUNDING_ERROR(LOG_UNITS_X))
-					 / LOG_UNITS_X);
+			/ LOG_UNITS_X);
 }
 #define LOGX_TO_UNIVERSE(lx) \
-logxToUniverse (lx)
+		logxToUniverse (lx)
 static inline SDWORD
 logyToUniverse (SDWORD ly)
 {
 	return (SDWORD) (MAX_Y_UNIVERSE -
-					 ((ly * UNIVERSE_UNITS_Y + ROUNDING_ERROR(LOG_UNITS_Y))
-					  / LOG_UNITS_Y));
+			((ly * UNIVERSE_UNITS_Y + ROUNDING_ERROR(LOG_UNITS_Y))
+			/ LOG_UNITS_Y));
 }
 #define LOGY_TO_UNIVERSE(ly) \
-logyToUniverse (ly)
+		logyToUniverse (ly)
 static inline SDWORD
 universeToLogx (COORD ux)
 {
 	return (ux * LOG_UNITS_X + ROUNDING_ERROR(UNIVERSE_UNITS_X))
-	/ UNIVERSE_UNITS_X;
+			/ UNIVERSE_UNITS_X;
 }
 #define UNIVERSE_TO_LOGX(ux) \
-universeToLogx (ux)
+		universeToLogx (ux)
 static inline SDWORD
 universeToLogy (COORD uy)
 {
 	return ((MAX_Y_UNIVERSE - uy) * LOG_UNITS_Y
 			+ ROUNDING_ERROR(UNIVERSE_UNITS_Y))
-	/ UNIVERSE_UNITS_Y;
+			/ UNIVERSE_UNITS_Y;
 }
 #define UNIVERSE_TO_LOGY(uy) \
-universeToLogy (uy)
-
-/* Here be old junk. */
-/*
- // Hyperspace speed factors (JMS: unused??)
- #define SECTOR_WIDTH (195)
- #define SECTOR_HEIGHT (25)
- 
- #define UNIT_SCREEN_WIDTH 63
- #define UNIT_SCREEN_HEIGHT 50
- 
- // Bug #945: Simplified, these set the speed of SIS in Hyperspace and
- //   Quasispace. The ratio between UNIVERSE_UNITS_ and LOG_UNITS_ is
- //   what sets the speed, and it should be 1:16 to match the original.
- //   The unit factors are reduced to keep the translation math within
- //   32 bits. The original math is unnecessarily complex and depends
- //   on the screen resolution when it should not.
- //   Using the new math will break old savegames.
- #ifdef NORMALIZED_HYPERSPACE_SPEED
- #define LOG_UNITS_X      ((SDWORD)(UNIVERSE_UNITS_X * 16))
- #define LOG_UNITS_Y      ((SDWORD)(UNIVERSE_UNITS_Y * 16))
- #define UNIVERSE_UNITS_X (((MAX_X_UNIVERSE + 1) >> 4))
- #define UNIVERSE_UNITS_Y (((MAX_Y_UNIVERSE + 1) >> 4))
- #else
- // Original (and now broken) Hyperspace speed factors
- #define SECTOR_WIDTH 195
- #define SECTOR_HEIGHT 25
- 
- #define LOG_UNITS_X      ((SDWORD)(LOG_SPACE_WIDTH >> 4) * SECTOR_WIDTH)
- #define LOG_UNITS_Y      ((SDWORD)(LOG_SPACE_HEIGHT >> 4) * SECTOR_HEIGHT)
- #define UNIVERSE_UNITS_X (((MAX_X_UNIVERSE + 1) >> 4) * 10)
- #define UNIVERSE_UNITS_Y (((MAX_Y_UNIVERSE + 1) >> 4))
- #endif
- 
- #define ROUNDING_ERROR(div)  ((div) >> 1)
- 
- static inline COORD
- logxToUniverse (SDWORD lx)
- {
- return (COORD) ((lx * UNIVERSE_UNITS_X + ROUNDING_ERROR(LOG_UNITS_X))
- / LOG_UNITS_X);
- }
- #define LOGX_TO_UNIVERSE(lx) \
- logxToUniverse (lx)
- static inline COORD
- logyToUniverse (SDWORD ly)
- {
- return (COORD) (MAX_Y_UNIVERSE -
- ((ly * UNIVERSE_UNITS_Y + ROUNDING_ERROR(LOG_UNITS_Y))
- / LOG_UNITS_Y));
- }
- #define LOGY_TO_UNIVERSE(ly) \
- logyToUniverse (ly)
- static inline SDWORD
- universeToLogx (COORD ux)
- {
- return (ux * LOG_UNITS_X + ROUNDING_ERROR(UNIVERSE_UNITS_X))
- / UNIVERSE_UNITS_X;
- }
- #define UNIVERSE_TO_LOGX(ux) \
- universeToLogx (ux)
- static inline SDWORD
- universeToLogy (COORD uy)
- {
- return ((MAX_Y_UNIVERSE - uy) * LOG_UNITS_Y
- + ROUNDING_ERROR(UNIVERSE_UNITS_Y))
- / UNIVERSE_UNITS_Y;
- }
- #define UNIVERSE_TO_LOGY(uy) \
- universeToLogy (uy)
- */
+		universeToLogy (uy)
 
 #define CIRCLE_SHIFT 6
 #define FULL_CIRCLE (1 << CIRCLE_SHIFT)
@@ -266,14 +196,14 @@ universeToLogy (uy)
 #define FACING_SHIFT 4
 
 #define ANGLE_TO_FACING(a) (((a)+(1<<(CIRCLE_SHIFT-FACING_SHIFT-1))) \
->>(CIRCLE_SHIFT-FACING_SHIFT))
+										>>(CIRCLE_SHIFT-FACING_SHIFT))
 #define FACING_TO_ANGLE(f) ((f)<<(CIRCLE_SHIFT-FACING_SHIFT))
 
 #define NORMALIZE_ANGLE(a) ((DWORD)((a)&(FULL_CIRCLE-1)))
 #define NORMALIZE_FACING(f) ((DWORD)((f)&((1 << FACING_SHIFT)-1)))
 
 #define DEGREES_TO_ANGLE(d) NORMALIZE_ANGLE((((d) % 360) * FULL_CIRCLE \
-+ HALF_CIRCLE) / 360)
+				+ HALF_CIRCLE) / 360)
 #define ANGLE_TO_DEGREES(d) (NORMALIZE_ANGLE(d) * 360 / FULL_CIRCLE)
 
 #define SIN_SHIFT 14
@@ -294,9 +224,15 @@ extern COUNT ARCTAN (SDWORD delta_x, SDW
 #define WRAP_X(x) WRAP_VAL(x,LOG_SPACE_WIDTH)
 #define WRAP_Y(y) WRAP_VAL(y,LOG_SPACE_HEIGHT)
 #define WRAP_DELTA_X(dx) ((dx)<0 ? \
-((-(dx)<=LOG_SPACE_WIDTH>>1)?(dx):(LOG_SPACE_WIDTH+(dx))) : \
-(((dx)<=LOG_SPACE_WIDTH>>1)?(dx):((dx)-LOG_SPACE_WIDTH)))
+				((-(dx)<=LOG_SPACE_WIDTH>>1)?(dx):(LOG_SPACE_WIDTH+(dx))) : \
+				(((dx)<=LOG_SPACE_WIDTH>>1)?(dx):((dx)-LOG_SPACE_WIDTH)))
 #define WRAP_DELTA_Y(dy) ((dy)<0 ? \
-((-(dy)<=LOG_SPACE_HEIGHT>>1)?(dy):(LOG_SPACE_HEIGHT+(dy))) : \
-(((dy)<=LOG_SPACE_HEIGHT>>1)?(dy):((dy)-LOG_SPACE_HEIGHT)))
-#endif /* _UNITS_H */
\ No newline at end of file
+				((-(dy)<=LOG_SPACE_HEIGHT>>1)?(dy):(LOG_SPACE_HEIGHT+(dy))) : \
+				(((dy)<=LOG_SPACE_HEIGHT>>1)?(dy):((dy)-LOG_SPACE_HEIGHT)))
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif /* _UNITS_H */
+
diff -ruNp src.hd/uqm/uqmdebug.c src/uqm/uqmdebug.c
--- src.hd/uqm/uqmdebug.c	2017-12-29 02:25:55 -0800
+++ src/uqm/uqmdebug.c	2017-12-29 00:57:56 -0800
@@ -13,13 +13,15 @@
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
+
+
 #include "uqmdebug.h"
 
 #include "build.h"
 #include "colors.h"
 #include "controls.h"
 #include "clock.h"
-#include "encount.h"
+#include "starmap.h"
 #include "intel.h"
 #include "sis.h"
 #include "status.h"
@@ -33,6 +35,7 @@
 #include "setup.h"
 #include "state.h"
 #include "libs/mathlib.h"
+#include "lua/luadebug.h"
 
 #include <stdio.h>
 #include <errno.h>
@@ -85,8 +88,6 @@ doInstantMove (void)
 	(GLOBAL (autopilot)).y = ~0;
 }
 
-////////////////////////////////////////////////////////////////////////////
-
 // playerNr should be 0 or 1
 STARSHIP*
 findPlayerShip (SIZE playerNr)
@@ -124,8 +125,9 @@ resetEnergyBattle (void)
 	CONTEXT OldContext;
 	
 	if (!(GLOBAL (CurrentActivity) & IN_BATTLE) ||
-			(LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE))
-		return;
+			inHQSpace())
+		return;	
+
 	if (PlayerControl[1] & HUMAN_CONTROL){
 		StarShipPtr = findPlayerShip (NPC_PLAYER_NUM);
 	} else if (PlayerControl[0] & HUMAN_CONTROL) {
@@ -147,7 +149,6 @@ resetEnergyBattle (void)
 
 #if defined(DEBUG) || defined(USE_DEBUG_KEY)
 
-
 static void dumpEventCallback (const EVENT *eventPtr, void *arg);
 
 static void starRecurse (STAR_DESC *star, void *arg);
@@ -177,105 +178,85 @@ static void dumpPlanetTypeCallback (int
 
 
 BOOLEAN instantMove = FALSE;
-BOOLEAN invincibility = FALSE; // JMS
 BOOLEAN disableInteractivity = FALSE;
-void (* volatile doInputDebugHook) (void) = NULL;
 
 
+// Must be called on the Starcon2Main thread.
+// This function is called synchronously wrt the game logic thread.
 void
-debugKeyPressed (void)
+debugKeyPressedSynchronous (void)
 {
-	// State modifying.
-	equipShip ();
-	giveDevices ();
+	// State modifying:
+//	equipShip ();
+//	giveDevices ();
 
 	// Give the player the ships you can't ally with under normal
 	// conditions.
-	clearEscorts ();
-	ActivateStarShip (ARILOU_SHIP, 1);
-	ActivateStarShip (HUMAN_SHIP, 1);
-	ActivateStarShip (PKUNK_SHIP, 1);
-	ActivateStarShip (YEHAT_SHIP, 1);
-	ActivateStarShip (PKUNK_SHIP, 1);
-	ActivateStarShip (DRUUGE_SHIP, 1);
-	ActivateStarShip (CHMMR_SHIP, 1);
-	ActivateStarShip (UTWIG_SHIP, 1);
-	ActivateStarShip (SLYLANDRO_SHIP, 1);
-	ActivateStarShip (VUX_SHIP, 1);
-	ActivateStarShip (UTWIG_SHIP, 1);
-	ActivateStarShip (BLACK_URQUAN_SHIP, 1);
-
-	resetCrewBattle ();
-	resetEnergyBattle ();
+	/*clearEscorts ();
+	AddEscortShips (ARILOU_SHIP, 1);
+	AddEscortShips (PKUNK_SHIP, 1);
+	AddEscortShips (VUX_SHIP, 1);
+	AddEscortShips (YEHAT_SHIP, 1);
+	AddEscortShips (MELNORME_SHIP, 1);
+	AddEscortShips (DRUUGE_SHIP, 1);
+	AddEscortShips (ILWRATH_SHIP, 1);
+	AddEscortShips (MYCON_SHIP, 1);
+	AddEscortShips (SLYLANDRO_SHIP, 1);
+	AddEscortShips (UMGAH_SHIP, 1);
+	AddEscortShips (URQUAN_SHIP, 1);
+	AddEscortShips (BLACK_URQUAN_SHIP, 1);*/
+
+//	resetCrewBattle ();
+//	resetEnergyBattle ();
+//	instantMove = !instantMove;
 	showSpheres ();
-	activateAllShips ();
-	
-	//instantMove = !instantMove;
+//	activateAllShips ();
+	forwardToNextEvent (TRUE);
+//	SET_GAME_STATE (MELNORME_CREDIT1, 100);
+//	GLOBAL_SIS (ResUnits) = 100000;
 
-  	//SET_GAME_STATE (MELNORME_CREDIT1, 100);
-	//GLOBAL_SIS (ResUnits) += 1000;
+	// Informational:
+//	dumpEvents (stderr);
 
-//	forwardToNextEvent (TRUE);
+	// Graphical and textual:
+//	debugContexts();
+}
 
+// Can be called on any thread, but usually on main()
+// This function is called asynchronously wrt the game logic thread,
+// which means locking applies. Use carefully.
+// TODO: Once game logic thread is purged of graphics and clock locks,
+//   this function may not call graphics and game clock functions at all.
+void
+debugKeyPressed (void)
+{
 	// Tests
 //	Scale_PerfTest ();
 
 	// Informational:
 //	dumpStrings (stdout);
-//	dumpEvents (stderr);
 //	dumpPlanetTypes(stderr);
 //	debugHook = dumpUniverseToFile;
 			// This will cause dumpUniverseToFile to be called from the
-			// main loop. Calling it from here would give threading
+			// Starcon2Main loop. Calling it from here would give threading
 			// problems.
 //	debugHook = tallyResourcesToFile;
 			// This will cause tallyResourcesToFile to be called from the
-			// main loop. Calling it from here would give threading
+			// Starcon2Main loop. Calling it from here would give threading
 			// problems.
 
-	// Graphical and textual:
-	//doInputDebugHook = debugContexts;
-			// This will cause debugContexts to be called from the
-			// Starcon2Main thread, from DoInput(). Calling it from here
-			// would give threading problems.
-
 	// Interactive:
 //	uio_debugInteractive(stdin, stdout, stderr);
-}
-
-void
-debugKey2Pressed (void)
-{
-	invincibility = !invincibility;
-}
-
-void
-debugKey3Pressed (void)
-{
-	instantMove = !instantMove;
-}
-
-void
-debugKey4Pressed (void)
-{
-	SET_GAME_STATE (MELNORME_CREDIT1, 0); 
-	SET_GAME_STATE (MELNORME_CREDIT0, 255);
-	GLOBAL_SIS (ResUnits) += 1000;
-	
-	// Make sure the RU/credit amount is redrawn:
-	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE ||
-			LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY)
-	{
-		LockMutex (GraphicsLock);
-		DrawStatusMessage (NULL);
-		UnlockMutex (GraphicsLock);
-	}
+//	luaUqm_debug_run();
 }
 
 ////////////////////////////////////////////////////////////////////////////
 
 // Fast forwards to the next event.
 // If skipHEE is set, HYPERSPACE_ENCOUNTER_EVENTs are skipped.
+// Must be called from the Starcon2Main thread.
+// TODO: LockGameClock may be removed since it is only
+//   supposed to be called synchronously wrt the game logic thread.
 void
 forwardToNextEvent (BOOLEAN skipHEE)
 {
@@ -288,9 +269,6 @@ forwardToNextEvent (BOOLEAN skipHEE)
 	if (!GameClockRunning ())
 		return;
 
-	// Must hold GraphicsLock for MoveGameClockDays()
-	// Must acquire GraphicsLock *before* the game clock lock
-	LockMutex (GraphicsLock);
 	LockGameClock ();
 
 	done = !skipHEE;
@@ -319,7 +297,6 @@ forwardToNextEvent (BOOLEAN skipHEE)
 	} while (!done);
 
 	UnlockGameClock ();
-	UnlockMutex (GraphicsLock);
 }
 
 const char *
@@ -430,11 +407,10 @@ equipShip (void)
 	{
 		// The Precursor bomb has not been installed.
 		// This is the original TFB testing layout.
-		// JMS: Ha ha, not anymore!
 		i = 0;
 		GLOBAL_SIS (ModuleSlots[i++]) = HIGHEFF_FUELSYS;
-		GLOBAL_SIS (ModuleSlots[i++]) = FUEL_TANK;
-		GLOBAL_SIS (ModuleSlots[i++]) = ANTIMISSILE_DEFENSE;
+		GLOBAL_SIS (ModuleSlots[i++]) = HIGHEFF_FUELSYS;
+		GLOBAL_SIS (ModuleSlots[i++]) = CREW_POD;
 		GLOBAL_SIS (ModuleSlots[i++]) = CREW_POD;
 		GLOBAL_SIS (ModuleSlots[i++]) = CREW_POD;
 		GLOBAL_SIS (ModuleSlots[i++]) = CREW_POD;
@@ -446,7 +422,7 @@ equipShip (void)
 		GLOBAL_SIS (ModuleSlots[i++]) = TRACKING_SYSTEM;
 		GLOBAL_SIS (ModuleSlots[i++]) = TRACKING_SYSTEM;
 		GLOBAL_SIS (ModuleSlots[i++]) = SHIVA_FURNACE;
-		GLOBAL_SIS (ModuleSlots[i++]) = BLASTER_WEAPON;
+		GLOBAL_SIS (ModuleSlots[i++]) = CANNON_WEAPON;
 		GLOBAL_SIS (ModuleSlots[i++]) = CANNON_WEAPON;
 		
 		// Landers:
@@ -501,12 +477,10 @@ equipShip (void)
 	}
 
 	// Make sure everything is redrawn:
-	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE ||
+	if (inHQSpace () ||
 			LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY)
 	{
-		LockMutex (GraphicsLock);
 		DeltaSISGauges (UNDEFINED_DELTA, UNDEFINED_DELTA, UNDEFINED_DELTA);
-		UnlockMutex (GraphicsLock);
 	}
 }
 
@@ -515,8 +489,8 @@ equipShip (void)
 void
 giveDevices (void) {
 	SET_GAME_STATE (ROSY_SPHERE_ON_SHIP, 1);
-	SET_GAME_STATE (ARTIFACT_2_ON_SHIP, 1);
-	SET_GAME_STATE (ARTIFACT_3_ON_SHIP, 1);
+	SET_GAME_STATE (WIMBLIS_TRIDENT_ON_SHIP, 1);
+	SET_GAME_STATE (GLOWING_ROD_ON_SHIP, 1);
 	SET_GAME_STATE (SUN_DEVICE_ON_SHIP, 1);
 	SET_GAME_STATE (UTWIG_BOMB_ON_SHIP, 1);
 	SET_GAME_STATE (ULTRON_CONDITION, 1);
@@ -563,9 +537,7 @@ clearEscorts (void)
 		FreeShipFrag (&GLOBAL (built_ship_q), hStarShip);
 	}
 
-	LockMutex (GraphicsLock);
 	DeltaSISGauges (UNDEFINED_DELTA, UNDEFINED_DELTA, UNDEFINED_DELTA);
-	UnlockMutex (GraphicsLock);
 }
 
 ////////////////////////////////////////////////////////////////////////////
@@ -599,6 +571,8 @@ findFlagshipElement (void)
 }
 #endif
 
+////////////////////////////////////////////////////////////////////////////
+
 void
 showSpheres (void)
 {
@@ -638,10 +612,10 @@ activateAllShips (void)
 		FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
 		hNextShip = _GetSuccLink (FleetPtr);
 
-		if (FleetPtr->icons != NULL && FleetPtr->allied_state != GOOD_GUY)
+		if (FleetPtr->icons != NULL)
 				// Skip the Ur-Quan probe.
 		{
-			FleetPtr->allied_state = CAN_BUILD;
+			FleetPtr->allied_state = GOOD_GUY;
 		}
 
 		UnlockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
@@ -688,6 +662,8 @@ forAllMoons (STAR_DESC *star, SOLARSYS_S
 
 ////////////////////////////////////////////////////////////////////////////
 
+// Must be called from the Starcon2Main thread.
+// TODO: LockGameClock may be removed
 void
 UniverseRecurse (UniverseRecurseArg *universeRecurseArg)
 {
@@ -719,15 +695,14 @@ starRecurse (STAR_DESC *star, void *arg)
 
 	SOLARSYS_STATE SolarSysState;
 	SOLARSYS_STATE *oldPSolarSysState = pSolarSysState;
-	DWORD oldSeed =
-			TFB_SeedRandom (MAKE_DWORD (star->star_pt.x, star->star_pt.y));
-
 	STAR_DESC *oldStarDescPtr = CurStarDescPtr;
 	CurStarDescPtr = star;
 
+	RandomContext_SeedRandom (SysGenRNG, GetRandomSeedForStar (star));
+
 	memset (&SolarSysState, 0, sizeof (SolarSysState));
 	SolarSysState.SunDesc[0].pPrevDesc = 0;
-	SolarSysState.SunDesc[0].rand_seed = TFB_Random ();
+	SolarSysState.SunDesc[0].rand_seed = RandomContext_Random (SysGenRNG);
 	SolarSysState.SunDesc[0].data_index = STAR_TYPE (star->Type);
 	SolarSysState.SunDesc[0].location.x = 0;
 	SolarSysState.SunDesc[0].location.y = 0;
@@ -759,7 +734,6 @@ starRecurse (STAR_DESC *star, void *arg)
 	
 	pSolarSysState = oldPSolarSysState;
 	CurStarDescPtr = oldStarDescPtr;
-	TFB_SeedRandom (oldSeed);
 }
 
 static void
@@ -787,14 +761,12 @@ planetRecurse (STAR_DESC *star, SOLARSYS
 
 	if (universeRecurseArg->moonFunc != NULL)
 	{
-		DWORD oldSeed = TFB_SeedRandom (planet->rand_seed);
+		RandomContext_SeedRandom (SysGenRNG, planet->rand_seed);
 		
 		(*system->genFuncs->generateMoons) (system, planet);
 
 		forAllMoons (star, system, planet, moonRecurse,
 				(void *) universeRecurseArg);
-
-		TFB_SeedRandom (oldSeed);
 	}
 	
 	if (universeRecurseArg->planetFuncPost != NULL)
@@ -824,10 +796,13 @@ moonRecurse (STAR_DESC *star, SOLARSYS_S
 	if (universeRecurseArg->moonFunc != NULL)
 	{
 		system->pOrbitalDesc = moon;
-		DoPlanetaryAnalysis (&system->SysInfo, moon);
+		if (moon->data_index != HIERARCHY_STARBASE && moon->data_index != SA_MATRA)
+		{
+			DoPlanetaryAnalysis (&system->SysInfo, moon);
 				// When GenerateDefaultFunctions is used as genFuncs,
 				// generateOrbital will also call DoPlanetaryAnalysis,
 				// but with other GenerateFunctions this is not guaranteed.
+		}
 		(*system->genFuncs->generateOrbital) (system, moon);
 		(*universeRecurseArg->moonFunc) (
 				moon, universeRecurseArg->arg);
@@ -841,6 +816,7 @@ typedef struct
 	FILE *out;
 } DumpUniverseArg;
 
+// Must be called from the Starcon2Main thread.
 void
 dumpUniverse (FILE *out)
 {
@@ -859,7 +835,7 @@ dumpUniverse (FILE *out)
 	UniverseRecurse (&universeRecurseArg);
 }
 
-// Must be called from the main thread.
+// Must be called from the Starcon2Main thread.
 void
 dumpUniverseToFile (void)
 {
@@ -1069,8 +1045,7 @@ dumpPlanetCallback (const PLANET_DESC *p
 void
 dumpPlanet (FILE *out, const PLANET_DESC *planet)
 {
-	(*pSolarSysState->genFuncs->generateName) (
-			pSolarSysState, (PLANET_DESC *) planet);
+	(*pSolarSysState->genFuncs->generateName) (pSolarSysState, planet);
 	fprintf (out, "- %-37s  %s\n", GLOBAL_SIS (PlanetName),
 			planetTypeString (planet->data_index & ~PLANET_SHIELDED));
 	dumpWorld (out, planet);
@@ -1151,16 +1126,16 @@ calculateBioValue (const SOLARSYS_STATE
 
 	assert (system->pOrbitalDesc == world);
 	
-	numBio = callGenerateForScanType ((SOLARSYS_STATE *) system,
-			(PLANET_DESC *) world, ~0, BIOLOGICAL_SCAN);
+	numBio = callGenerateForScanType (system, world, GENERATE_ALL,
+			BIOLOGICAL_SCAN, NULL);
 
 	result = 0;
 	for (i = 0; i < numBio; i++)
 	{
-		callGenerateForScanType ((SOLARSYS_STATE *) system,
-				(PLANET_DESC *) world, i, BIOLOGICAL_SCAN);
-		result += BIO_CREDIT_VALUE * LONIBBLE (CreatureData[
-				system->SysInfo.PlanetInfo.CurType].ValueAndHitPoints);
+		NODE_INFO info;
+		callGenerateForScanType (system, world, i, BIOLOGICAL_SCAN, &info);
+		result += BIO_CREDIT_VALUE *
+				LONIBBLE (CreatureData[info.type].ValueAndHitPoints);
 	}
 	return result;
 }
@@ -1174,17 +1149,17 @@ generateBioIndex(const SOLARSYS_STATE *s
 
 	assert (system->pOrbitalDesc == world);
 	
-	numBio = callGenerateForScanType ((SOLARSYS_STATE *) system,
-			(PLANET_DESC *) world, ~0, BIOLOGICAL_SCAN);
+	numBio = callGenerateForScanType (system, world, GENERATE_ALL,
+			BIOLOGICAL_SCAN, NULL);
 
 	for (i = 0; i < NUM_CREATURE_TYPES + NUM_SPECIAL_CREATURE_TYPES; i++)
 		bio[i] = 0;
 	
 	for (i = 0; i < numBio; i++)
 	{
-		callGenerateForScanType ((SOLARSYS_STATE *) system,
-				(PLANET_DESC *) world, i, BIOLOGICAL_SCAN);
-		bio[system->SysInfo.PlanetInfo.CurType]++;
+		NODE_INFO info;
+		callGenerateForScanType (system, world, i, BIOLOGICAL_SCAN, &info);
+		bio[info.type]++;
 	}
 }
 
@@ -1197,17 +1172,16 @@ calculateMineralValue (const SOLARSYS_ST
 
 	assert (system->pOrbitalDesc == world);
 	
-	numDeposits = callGenerateForScanType ((SOLARSYS_STATE *) system,
-			(PLANET_DESC *) world, ~0, MINERAL_SCAN);
+	numDeposits = callGenerateForScanType (system, world, GENERATE_ALL,
+			MINERAL_SCAN, NULL);
 
 	result = 0;
 	for (i = 0; i < numDeposits; i++)
 	{
-		callGenerateForScanType ((SOLARSYS_STATE *) system,
-				(PLANET_DESC *) world, i, MINERAL_SCAN);
-		result += HIBYTE (system->SysInfo.PlanetInfo.CurDensity) *
-				GLOBAL (ElementWorth[ElementCategory (
-				system->SysInfo.PlanetInfo.CurType)]);
+		NODE_INFO info;
+		callGenerateForScanType (system, world, i, MINERAL_SCAN, &info);
+		result += HIBYTE (info.density) *
+				GLOBAL (ElementWorth[ElementCategory (info.type)]);
 	}
 	return result;
 }
@@ -1221,18 +1195,17 @@ generateMineralIndex(const SOLARSYS_STAT
 
 	assert (system->pOrbitalDesc == world);
 	
-	numDeposits = callGenerateForScanType ((SOLARSYS_STATE *) system,
-			(PLANET_DESC *) world, ~0, MINERAL_SCAN);
+	numDeposits = callGenerateForScanType (system, world, GENERATE_ALL,
+			MINERAL_SCAN, NULL);
 
 	for (i = 0; i < NUM_ELEMENT_CATEGORIES; i++)
 		minerals[i] = 0;
 	
 	for (i = 0; i < numDeposits; i++)
 	{
-		callGenerateForScanType ((SOLARSYS_STATE *) system,
-				(PLANET_DESC *) world, i, MINERAL_SCAN);
-		minerals[ElementCategory(system->SysInfo.PlanetInfo.CurType)] +=
-				HIBYTE (system->SysInfo.PlanetInfo.CurDensity);
+		NODE_INFO info;
+		callGenerateForScanType (system, world, i, MINERAL_SCAN, &info);
+		minerals[ElementCategory (info.type)] += HIBYTE (info.density);
 	}
 }
 
@@ -1245,6 +1218,7 @@ struct TallyResourcesArg
 	COUNT bioCount;
 };
 
+// Must be called from the Starcon2Main thread.
 void
 tallyResources (FILE *out)
 {
@@ -1263,7 +1237,7 @@ tallyResources (FILE *out)
 	UniverseRecurse (&universeRecurseArg);
 }
 
-// Must be called from the main thread.
+// Must be called from the Starcon2Main thread.
 void
 tallyResourcesToFile (void)
 {
@@ -1567,7 +1541,7 @@ resetCrewBattle (void)
 	CONTEXT OldContext;
 	
 	if (!(GLOBAL (CurrentActivity) & IN_BATTLE) ||
-			(LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE))
+			(inHQSpace ()))
 		return;
 	
 	StarShipPtr = findPlayerShip (RPG_PLAYER_NUM);
@@ -1644,7 +1618,7 @@ dumpStrings (FILE *out)
 	
 	if (GAMESTR_COUNT != numStrings) {
 		fprintf(stderr, "Warning: GAMESTR_COUNT is %d, but GameStrings "
-				"contains %lu strings.\n", GAMESTR_COUNT, numStrings);
+				"contains %d strings.\n", GAMESTR_COUNT, numStrings);
 	}
 
 	categoryI = 0;
@@ -1652,7 +1626,7 @@ dumpStrings (FILE *out)
 		while (categoryI < numCategories &&
 				stringI >= categories[categoryI + 1].base)
 			categoryI++;
-		fprintf(out, "[ %s + %lu ]  %s\n", categories[categoryI].name,
+		fprintf(out, "[ %s + %d ]  %s\n", categories[categoryI].name,
 				stringI - categories[categoryI].base, GAME_STRING(stringI));
 	}
 }
@@ -1893,16 +1867,13 @@ debugContexts (void)
 		return;
 	inDebugContexts = true;
 
-	LockMutex (GraphicsLock);
 	contextCount = countVisibleContexts ();
 	if (contextCount == 0)
 	{
-		UnlockMutex (GraphicsLock);
 		goto out;
 	}
 	
 	savedScreen = getScreen ();
-	//UnlockMutex (GraphicsLock);
 	FlushGraphics ();
 			// Make sure that the screen has actually been captured,
 			// before we use the frame.
@@ -1916,7 +1887,6 @@ debugContexts (void)
 
 	hueIncrement = 360.0 / contextCount;
 
-	//LockMutex (GraphicsLock);
 	visibleContextI = 0;
 	for (context = GetFirstContext (); context != NULL;
 			context = GetNextContext (context))
@@ -1938,7 +1908,6 @@ debugContexts (void)
 
 	// Blit the final debugging frame to the screen.
 	putScreen (debugDrawFrame);
-	UnlockMutex (GraphicsLock);
 
 	// Wait for a key:
 	{
@@ -1947,9 +1916,7 @@ debugContexts (void)
 		DoInput(&state, TRUE);
 	}
 
-	LockMutex (GraphicsLock);
 	SetContext (orgContext);
-	UnlockMutex (GraphicsLock);
 
 	// Destroy the debugging frame and context.
 	DestroyContext (debugDrawContext);
@@ -1957,9 +1924,7 @@ debugContexts (void)
 			// SetContextFGFrame().
 	DestroyDrawable (ReleaseDrawable (debugDrawFrame));
 	
-	LockMutex (GraphicsLock);
 	putScreen (savedScreen);
-	UnlockMutex (GraphicsLock);
 
 	DestroyDrawable (ReleaseDrawable (savedScreen));
 
@@ -1967,4 +1932,5 @@ out:
 	inDebugContexts = false;
 }
 
-#endif  /* DEBUG */
\ No newline at end of file
+#endif  /* DEBUG */
+
diff -ruNp src.hd/uqm/uqmdebug.h src/uqm/uqmdebug.h
--- src.hd/uqm/uqmdebug.h	2017-12-29 02:25:55 -0800
+++ src/uqm/uqmdebug.h	2017-12-29 00:57:56 -0800
@@ -14,14 +14,13 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-
 #include "clock.h"
 #include "planets/planets.h"
 #include "races.h"
 #include "libs/compiler.h"
 
 #include <stdio.h>
-
+ 
 // If a function is assigned to this, it will be called from the
 // Starcon2Main thread, in the main game loop.
 extern void (* volatile debugHook) (void);
@@ -40,17 +39,17 @@ void resetEnergyBattle(void);
 #if !defined(_DEBUG_H) && (defined(DEBUG) || defined(USE_DEBUG_KEY))
 #define _DEBUG_H
 
+
 // If set to true, interactive routines that are called (indirectly) in debug
 // functions are a no-op.
 extern BOOLEAN disableInteractivity;
 
-// If a function is assigned to this, it will be called from the
-// Starcon2Main thread, in doInput().
-extern void (* volatile doInputDebugHook) (void);
-
-
-// Called when the debug key (symbol 'Debug' in the keys.cfg) is pressed.
+// Called on the main() thread when the debug key (symbol 'Debug' in the
+// keys.cfg) is pressed
 void debugKeyPressed (void);
+// Called on the Starcon2Main() thread when the debug key (symbol 'Debug'
+// in the keys.cfg) is pressed.
+void debugKeyPressedSynchronous (void);
 
 // JMS: Called when the debug key (symbol 'Debug_2' in the keys.cfg) is pressed.
 void debugKey2Pressed (void);
@@ -63,9 +62,10 @@ void debugKey4Pressed (void);
 
 // Forward time to the next event. If skipHEE is set, the event named
 // HYPERSPACE_ENCOUNTER_EVENT, which normally occurs every game day,
-// is skipped.
+// is skipped. Must be called on the Starcon2Main thread.
 void forwardToNextEvent (BOOLEAN skipHEE);
 // Generate a list of all events in the event queue.
+// Must be called on the Starcon2Main thread.
 void dumpEvents (FILE *out);
 // Describe one event.
 void dumpEvent (FILE *out, const EVENT *eventPtr);
@@ -86,7 +86,6 @@ void showSpheres (void);
 // Make the ships of all races available for building at the shipyard.
 void activateAllShips (void);
 
-
 // Call a function for all stars.
 void forAllStars (void (*callback) (STAR_DESC *, void *), void *arg);
 // Call a function for all planets in a star system.
@@ -117,11 +116,13 @@ typedef struct
 			// User data.
 } UniverseRecurseArg;
 // Recurse through all systems, planets, and moons in the universe.
+// Must be called on the Starcon2Main thread.
 void UniverseRecurse (UniverseRecurseArg *universeRecurseArg);
 
-// Describe the entire universe.
+// Describe the entire universe. Must be called on the Starcon2Main thread.
 void dumpUniverse (FILE *out);
 // Describe the entire universe, output to a file "./PlanetInfo".
+// Must be called on the Starcon2Main thread.
 void dumpUniverseToFile (void);
 // Describe one star system.
 void dumpSystem (FILE *out, const STAR_DESC *star,
@@ -152,9 +153,10 @@ void generateBioIndex(const SOLARSYS_STA
 		const PLANET_DESC *world, COUNT bio[]);
 
 // Tally the resources for each star system.
+// Must be called on the Starcon2Main thread.
 void tallyResources (FILE *out);
 // Tally the resources for each star system, output to a file
-// "./ResourceTally".
+// "./ResourceTally". Must be called on the Starcon2Main thread.
 void tallyResourcesToFile (void);
 
 
@@ -188,15 +190,12 @@ void resetCrewBattle(void);
 extern BOOLEAN instantMove;
 
 
-// IDDQD.
-extern BOOLEAN invincibility;
-
 // Dump all game strings.
 void dumpStrings(FILE *out);
 
 
 // Graphically and textually show all the contexts.
-// Should be called from debugHook.
+// Must be called on the Starcon2Main thread.
 void debugContexts (void);
 
 
diff -ruNp src.hd/uqm/util.c src/uqm/util.c
--- src.hd/uqm/util.c	2017-12-29 02:25:55 -0800
+++ src/uqm/util.c	2017-12-29 00:57:56 -0800
@@ -21,15 +21,11 @@
 #include "setup.h"
 #include "units.h"
 #include "settings.h"
-
-/* For SOL_X and SOL_Y */
-#include "hyper.h"
-
 #include "libs/inplib.h"
 #include "libs/sound/trackplayer.h"
 #include "libs/mathlib.h"
 #include "libs/log.h"
-
+#include "hyper.h"
 
 void
 DrawStarConBox (RECT *pRect, SIZE BorderWidth, Color TopLeftColor,
@@ -156,7 +152,6 @@ PauseGame (void)
 	if (PlayingTrack ())
 		PauseTrack ();
 
-	LockMutex (GraphicsLock);
 	OldContext = SetContext (ScreenContext);
 	oldOrigin = SetContextOrigin (MAKE_POINT (0, 0));
 	GetContextClipRect (&OldRect);
@@ -174,11 +169,7 @@ PauseGame (void)
 	SetSystemRect (&r);
 	DrawStamp (&s);
 
-	// It is safer to just not release the lock so any graphics tasks
-	// would be blocked
-	//UnlockMutex (GraphicsLock);
 	FlushGraphics ();
-	//LockMutex (GraphicsLock);
 
 	while (ImmediateInputState.menu[KEY_PAUSE] && GamePaused)
 	{
@@ -213,7 +204,6 @@ PauseGame (void)
 	if (PlayingTrack ())
 		ResumeTrack ();
 
-	UnlockMutex (GraphicsLock);
 
 	TaskSwitch ();
 	GLOBAL (CurrentActivity) &= ~CHECK_PAUSE;
@@ -304,7 +294,6 @@ SleepGame (void)
 		PauseTrack ();
 	PauseMusic ();
 
-	LockMutex (GraphicsLock);
 
 	while (!GameActive && !QuitPosted)
 		SleepThread (ONE_SECOND / 2);
@@ -318,7 +307,6 @@ SleepGame (void)
 	if (PlayingTrack ())
 		ResumeTrack ();
 
-	UnlockMutex (GraphicsLock);
 
 	TaskSwitch ();
 }
@@ -342,4 +330,4 @@ get_fuel_to_sol (void)
 		return 0;
 	else
 		return (square_root (f) + (FUEL_TANK_SCALE / 20));
-}
+}
\ No newline at end of file
diff -ruNp src.hd/uqm/util.h src/uqm/util.h
--- src.hd/uqm/util.h	2017-12-29 02:25:55 -0800
+++ src/uqm/util.h	2017-12-29 00:57:56 -0800
@@ -20,6 +20,10 @@
 #include "libs/compiler.h"
 #include "libs/gfxlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 extern void DrawStarConBox (RECT *pRect, SIZE BorderWidth,
 		Color TopLeftColor, Color BottomRightColor, BOOLEAN FillInterior,
 		Color InteriorColor);
@@ -30,5 +34,9 @@ extern STAMP SaveContextFrame (const REC
 
 extern DWORD get_fuel_to_sol (void);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif  /* _UTIL_H */
 
diff -ruNp src.hd/uqm/velocity.c src/uqm/velocity.c
--- src.hd/uqm/velocity.c	2017-12-29 02:25:55 -0800
+++ src/uqm/velocity.c	2017-12-29 00:57:56 -0800
@@ -16,15 +16,12 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #include "velocity.h"
 
 #include "units.h"
 #include "libs/compiler.h"
 #include "libs/log.h"
 
-
 #define VELOCITY_REMAINDER(v) ((v) & (VELOCITY_SCALE - 1))
 
 void
diff -ruNp src.hd/uqm/velocity.h src/uqm/velocity.h
--- src.hd/uqm/velocity.h	2017-12-29 02:25:55 -0800
+++ src/uqm/velocity.h	2017-12-29 00:57:56 -0800
@@ -22,6 +22,10 @@
 #include <string.h> /* for memset */
 #include "libs/gfxlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef struct velocity_desc
 {
 	COUNT TravelAngle;
@@ -50,7 +54,7 @@ extern void SetVelocityComponents (VELOC
 
 extern void DeltaVelocityComponents (VELOCITY_DESC *velocityptr, SDWORD dx, SDWORD dy); // JMS_GFX: Changed SIZE to SDWORD to prevent overflows
 
-static inline BOOLEAN
+static inline bool
 IsVelocityZero (VELOCITY_DESC *vptr)
 {
 	return vptr->vector.width == 0 && vptr->vector.height == 0 &&
@@ -70,5 +74,9 @@ VelocitySquared (SIZE dx, SIZE dy)
 #define VELOCITY_TO_WORLD(v) ((v)>>VELOCITY_SHIFT)
 #define WORLD_TO_VELOCITY(l) ((l)<<VELOCITY_SHIFT)
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _VELOCITY_H */
 
diff -ruNp src.hd/uqm/weapon.c src/uqm/weapon.c
--- src.hd/uqm/weapon.c	2017-12-29 02:25:55 -0800
+++ src/uqm/weapon.c	2017-12-29 00:57:56 -0800
@@ -16,9 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
-
 #include "weapon.h"
 
 #include "colors.h"
@@ -34,6 +31,15 @@
 
 #include <stdio.h>
 
+// A wrapper function for weapon_collision that discards the return value.
+// This makes its signature match ElementCollisionFunc.
+static void
+weapon_collision_cb (ELEMENT *WeaponElementPtr, POINT *pWPt,
+		ELEMENT *HitElementPtr, POINT *pHPt)
+{
+	weapon_collision (WeaponElementPtr, pWPt, HitElementPtr, pHPt);
+}
+
 
 HELEMENT
 initialize_laser (LASER_BLOCK *pLaserBlock)
@@ -50,9 +56,10 @@ initialize_laser (LASER_BLOCK *pLaserBlo
 		LaserElementPtr->playerNr = pLaserBlock->sender;
 		LaserElementPtr->hit_points = 1;
 		LaserElementPtr->mass_points = 1;
-		LaserElementPtr->state_flags = APPEARING | FINITE_LIFE | pLaserBlock->flags;
+		LaserElementPtr->state_flags = APPEARING | FINITE_LIFE
+				| pLaserBlock->flags;
 		LaserElementPtr->life_span = LASER_LIFE;
-		LaserElementPtr->collision_func = (CollisionFunc*)weapon_collision;
+		LaserElementPtr->collision_func = weapon_collision_cb;
 		LaserElementPtr->blast_offset = 1;
 
 		LaserElementPtr->current.location.x = pLaserBlock->cx
@@ -62,12 +69,15 @@ initialize_laser (LASER_BLOCK *pLaserBlo
 				+ SINE (FACING_TO_ANGLE (pLaserBlock->face),
 				DISPLAY_TO_WORLD (pLaserBlock->pixoffs));
 		SetPrimType (&DisplayArray[LaserElementPtr->PrimIndex], LINE_PRIM);
-		SetPrimColor (&DisplayArray[LaserElementPtr->PrimIndex], pLaserBlock->color);
+		SetPrimColor (&DisplayArray[LaserElementPtr->PrimIndex],
+				pLaserBlock->color);
 		LaserElementPtr->current.image.frame = DecFrameIndex (stars_in_space);
 		LaserElementPtr->current.image.farray = &stars_in_space;
-		SetVelocityComponents (&LaserElementPtr->velocity, 
-			WORLD_TO_VELOCITY ((pLaserBlock->cx + pLaserBlock->ex) - LaserElementPtr->current.location.x),
-			WORLD_TO_VELOCITY ((pLaserBlock->cy + pLaserBlock->ey) - LaserElementPtr->current.location.y));
+		SetVelocityComponents (&LaserElementPtr->velocity,
+				WORLD_TO_VELOCITY ((pLaserBlock->cx + pLaserBlock->ex)
+				- LaserElementPtr->current.location.x),
+				WORLD_TO_VELOCITY ((pLaserBlock->cy + pLaserBlock->ey)
+				- LaserElementPtr->current.location.y));
 		UnlockElement (hLaserElement);
 	}
 
@@ -99,7 +109,7 @@ initialize_missile (MISSILE_BLOCK *pMiss
 				SetAbsFrameIndex (pMissileBlock->farray[0],
 				pMissileBlock->index);
 		MissileElementPtr->preprocess_func = pMissileBlock->preprocess_func;
-		MissileElementPtr->collision_func = (CollisionFunc*)weapon_collision;
+		MissileElementPtr->collision_func = weapon_collision_cb;
 		MissileElementPtr->blast_offset = (BYTE)pMissileBlock->blast_offs;
 
 		angle = FACING_TO_ANGLE (pMissileBlock->face);
@@ -122,7 +132,8 @@ initialize_missile (MISSILE_BLOCK *pMiss
 }
 
 HELEMENT
-weapon_collision (ELEMENT *WeaponElementPtr, POINT *pWPt, ELEMENT *HitElementPtr, POINT *pHPt)
+weapon_collision (ELEMENT *WeaponElementPtr, POINT *pWPt,
+		ELEMENT *HitElementPtr, POINT *pHPt)
 {
 	SIZE damage;
 	HELEMENT hBlastElement;
@@ -131,7 +142,6 @@ weapon_collision (ELEMENT *WeaponElement
 		return ((HELEMENT)0);
 
 	damage = (SIZE)WeaponElementPtr->mass_points;
-	
 	if (damage
 			&& ((HitElementPtr->state_flags & FINITE_LIFE)
 			|| HitElementPtr->life_span == NORMAL_LIFE))
@@ -158,10 +168,12 @@ weapon_collision (ELEMENT *WeaponElement
 			damage = TARGET_DAMAGED_FOR_1_PT + (damage >> 1);
 			if (damage > TARGET_DAMAGED_FOR_6_PLUS_PT)
 				damage = TARGET_DAMAGED_FOR_6_PLUS_PT;
-			ProcessSound (SetAbsSoundIndex (GameSounds, damage), HitElementPtr);
+			ProcessSound (SetAbsSoundIndex (GameSounds, damage),
+					HitElementPtr);
 		}
 
-		if (GetPrimType (&DisplayArray[WeaponElementPtr->PrimIndex]) != LINE_PRIM)
+		if (GetPrimType (&DisplayArray[WeaponElementPtr->PrimIndex])
+				!= LINE_PRIM)
 			WeaponElementPtr->state_flags |= DISAPPEARING;
 
 		WeaponElementPtr->hit_points = 0;
@@ -206,16 +218,21 @@ weapon_collision (ELEMENT *WeaponElement
 			{
 				BlastElementPtr->life_span = 2;
 				BlastElementPtr->current.image.farray = blast;
-				BlastElementPtr->current.image.frame = SetAbsFrameIndex (blast[0], blast_index);
+				BlastElementPtr->current.image.frame =
+						SetAbsFrameIndex (blast[0], blast_index);
 			}
 			else
 			{
-				BlastElementPtr->life_span = num_blast_frames - ANGLE_TO_FACING (FULL_CIRCLE);
+				BlastElementPtr->life_span = num_blast_frames
+						- ANGLE_TO_FACING (FULL_CIRCLE);
 				BlastElementPtr->turn_wait = BlastElementPtr->next_turn = 0;
 				BlastElementPtr->preprocess_func = animation_preprocess;
-				BlastElementPtr->current.image.farray = WeaponElementPtr->next.image.farray;
+				BlastElementPtr->current.image.farray =
+						WeaponElementPtr->next.image.farray;
 				BlastElementPtr->current.image.frame =
-						SetAbsFrameIndex (BlastElementPtr->current.image.farray[0], ANGLE_TO_FACING (FULL_CIRCLE));
+						SetAbsFrameIndex (
+						BlastElementPtr->current.image.farray[0],
+						ANGLE_TO_FACING (FULL_CIRCLE));
 			}
 
 			UnlockElement (hBlastElement);
@@ -245,8 +262,8 @@ ModifySilhouette (ELEMENT *ElementPtr, S
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (modify_flags & MODIFY_IMAGE)
 	{
-		ShipIntersect.IntersectStamp.frame = SetAbsFrameIndex ( StarShipPtr->RaceDescPtr->ship_info.icons, 1);
-		
+		ShipIntersect.IntersectStamp.frame = SetAbsFrameIndex (
+				StarShipPtr->RaceDescPtr->ship_info.icons, 1);
 		if (ShipIntersect.IntersectStamp.frame == 0)
 			return (0);
 
@@ -255,7 +272,6 @@ ModifySilhouette (ELEMENT *ElementPtr, S
 		ShipIntersect.IntersectStamp.origin.x = 0;
 		ShipIntersect.IntersectStamp.origin.y = 0;
 		ShipIntersect.EndPoint = ShipIntersect.IntersectStamp.origin;
-		
 		do
 		{
 			ObjectIntersect.IntersectStamp.origin.x = ((COUNT)TFB_Random ()
@@ -279,7 +295,8 @@ ModifySilhouette (ELEMENT *ElementPtr, S
 	{
 		or.corner.x += ObjectIntersect.IntersectStamp.origin.x;
 		or.corner.y += ObjectIntersect.IntersectStamp.origin.y;
-		InitShipStatus (&StarShipPtr->RaceDescPtr->ship_info, StarShipPtr, &or, FALSE);
+		InitShipStatus (&StarShipPtr->RaceDescPtr->ship_info,
+				StarShipPtr, &or, FALSE);
 	}
 	else
 	{
diff -ruNp src.hd/uqm/weapon.h src/uqm/weapon.h
--- src.hd/uqm/weapon.h	2017-12-29 02:25:55 -0800
+++ src/uqm/weapon.h	2017-12-29 00:57:56 -0800
@@ -22,6 +22,10 @@
 #include "element.h"
 #include "libs/gfxlib.h"
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 typedef struct
 {
 	COORD cx, cy, ex, ey;
@@ -57,5 +61,9 @@ extern void Untarget (ELEMENT *ElementPt
 extern FRAME ModifySilhouette (ELEMENT *ElementPtr, STAMP *modify_stamp,
 		BYTE modify_flags);
 
+#if defined(__cplusplus)
+}
+#endif
+
 #endif /* _WEAPON_H */
 
diff -ruNp src.hd/uqm.c src/uqm.c
--- src.hd/uqm.c	2017-12-29 02:25:55 -0800
+++ src/uqm.c	2017-12-29 00:57:56 -0800
@@ -16,8 +16,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
-
 #ifdef HAVE_UNISTD_H
 #	include <unistd.h>
 #endif
@@ -29,12 +27,14 @@
 #endif
 
 #include <stdarg.h>
+#include <errno.h>
 #include "libs/graphics/gfx_common.h"
 #include "libs/graphics/cmap.h"
 #include "libs/sound/sound.h"
 #include "libs/input/input_common.h"
 #include "libs/inplib.h"
 #include "libs/tasklib.h"
+#include "libs/scriptlib.h"
 #include "uqm/controls.h"
 #include "uqm/battle.h"
 		// For BATTLE_FRAME_RATE
@@ -116,6 +116,7 @@ struct options_struct
 	DECL_CONFIG_OPTION(int, soundQuality);
 	DECL_CONFIG_OPTION(bool, use3doMusic);
 	DECL_CONFIG_OPTION(bool, useRemixMusic);
+	DECL_CONFIG_OPTION(bool, useSpeech);
 	DECL_CONFIG_OPTION(int, whichCoarseScan);
 	DECL_CONFIG_OPTION(int, whichMenu);
 	DECL_CONFIG_OPTION(int, whichFonts);
@@ -130,15 +131,10 @@ struct options_struct
 	DECL_CONFIG_OPTION(float, speechVolumeScale);
 	DECL_CONFIG_OPTION(bool, safeMode);
 	DECL_CONFIG_OPTION(int, resolutionFactor); // JMS_GFX
-	DECL_CONFIG_OPTION(bool, forceAspectRatio); // JMS_GFX
 	DECL_CONFIG_OPTION(int, loresBlowupScale); // JMS_GFX
-	DECL_CONFIG_OPTION(bool, mainmenuMusic); // JMS
-	DECL_CONFIG_OPTION(bool, mineralSubmenu); // JMS
-	DECL_CONFIG_OPTION(bool, nebulae); // JMS
-	DECL_CONFIG_OPTION(bool, rotatingIpPlanets); // JMS
-	DECL_CONFIG_OPTION(bool, texturedIpPlanets); // JMS
-	DECL_CONFIG_OPTION(bool, cheatMode); // JMS
-	DECL_CONFIG_OPTION(bool, godMode); // Serosis
+ 	DECL_CONFIG_OPTION(bool, cheatMode); // JMS
+	// Serosis
+	DECL_CONFIG_OPTION(bool, godMode);
 	DECL_CONFIG_OPTION(int, timeDilationScale);
 	DECL_CONFIG_OPTION(bool, bubbleWarp);
 	DECL_CONFIG_OPTION(bool, unlockShips);
@@ -147,6 +143,20 @@ struct options_struct
 	DECL_CONFIG_OPTION(bool, infiniteRU);
 	DECL_CONFIG_OPTION(bool, skipIntro);
 	DECL_CONFIG_OPTION(bool, FMV);
+	// JMS
+	DECL_CONFIG_OPTION(bool, mainMenuMusic);
+	DECL_CONFIG_OPTION(bool, nebulae);
+	DECL_CONFIG_OPTION(bool, orbitingPlanets);
+	DECL_CONFIG_OPTION(bool, texturedPlanets);
+	// Nic
+	DECL_CONFIG_OPTION(int, optDateFormat);
+	// Serosis
+	DECL_CONFIG_OPTION(bool, infiniteFuel);
+	DECL_CONFIG_OPTION(bool, thraddStory);
+	DECL_CONFIG_OPTION(bool, partialPickup);
+	DECL_CONFIG_OPTION(bool, submenu);
+	DECL_CONFIG_OPTION(bool, addDevices);
+	DECL_CONFIG_OPTION(bool, scalePlanets);
 
 #define INIT_CONFIG_OPTION(name, val) \
 	{ val, false }
@@ -175,8 +185,8 @@ static const struct option_list_value sc
 
 static const struct option_list_value meleeScaleList[] = 
 {
-	{"smooth",   TFB_SCALE_BILINEAR}, // JMS: Replaced trilinear with bilinear because of performance problems.
-	{"3do",      TFB_SCALE_BILINEAR}, // JMS: Replaced trilinear with bilinear because of performance problems.
+	{"smooth",   TFB_SCALE_TRILINEAR},
+	{"3do",      TFB_SCALE_TRILINEAR},
 	{"step",     TFB_SCALE_STEP},
 	{"pc",       TFB_SCALE_STEP},
 	{"bilinear", TFB_SCALE_BILINEAR},
@@ -256,40 +266,36 @@ main (int argc, char *argv[])
 		/* .numAddons = */          0,
 
 		INIT_CONFIG_OPTION(  opengl,            true ),
-		INIT_CONFIG_OPTION2( resolution,        1280, 960 ),
+		INIT_CONFIG_OPTION2( resolution,        640, 480 ),
 		INIT_CONFIG_OPTION(  fullscreen,        false ),
 		INIT_CONFIG_OPTION(  scanlines,         false ),
-		INIT_CONFIG_OPTION(  scaler,            TFB_GFXFLAGS_SCALE_BILINEAR),
+		INIT_CONFIG_OPTION(  scaler,            0 ),
 		INIT_CONFIG_OPTION(  showFps,           false ),
 		INIT_CONFIG_OPTION(  keepAspectRatio,   true ),
-		INIT_CONFIG_OPTION(  gamma,             0.0f ),
+		INIT_CONFIG_OPTION(  gamma,             1.0f ),
 		INIT_CONFIG_OPTION(  soundDriver,       audio_DRIVER_MIXSDL ),
-		INIT_CONFIG_OPTION(  soundQuality,      audio_QUALITY_MEDIUM ),
+		INIT_CONFIG_OPTION(  soundQuality,      audio_QUALITY_HIGH ),
 		INIT_CONFIG_OPTION(  use3doMusic,       true ),
 		INIT_CONFIG_OPTION(  useRemixMusic,     false ),
-		INIT_CONFIG_OPTION(  whichCoarseScan,   OPT_3DO ),
+		INIT_CONFIG_OPTION(  useSpeech,         true ),
+		INIT_CONFIG_OPTION(  whichCoarseScan,   OPT_PC ),
 		INIT_CONFIG_OPTION(  whichMenu,         OPT_3DO ),
 		INIT_CONFIG_OPTION(  whichFonts,        OPT_PC ),
-		INIT_CONFIG_OPTION(  whichIntro,        OPT_PC ),
+		INIT_CONFIG_OPTION(  whichIntro,        OPT_3DO ),
 		INIT_CONFIG_OPTION(  whichShield,       OPT_3DO ),
 		INIT_CONFIG_OPTION(  smoothScroll,      OPT_PC ),
-		INIT_CONFIG_OPTION(  meleeScale,        TFB_SCALE_BILINEAR ), // JMS: Replaced trilinear with bilinear because of performance problems.
+		INIT_CONFIG_OPTION(  meleeScale,        TFB_SCALE_TRILINEAR ),
 		INIT_CONFIG_OPTION(  subtitles,         true ),
-		INIT_CONFIG_OPTION(  stereoSFX,         false ),
+		INIT_CONFIG_OPTION(  stereoSFX,         true ),
 		INIT_CONFIG_OPTION(  musicVolumeScale,  1.0f ),
 		INIT_CONFIG_OPTION(  sfxVolumeScale,    1.0f ),
-		INIT_CONFIG_OPTION(  speechVolumeScale, 0.9f ),
+		INIT_CONFIG_OPTION(  speechVolumeScale, 0.8f ),
 		INIT_CONFIG_OPTION(  safeMode,          false ),
-		INIT_CONFIG_OPTION(  resolutionFactor,  2 ),
-		INIT_CONFIG_OPTION(  forceAspectRatio,  false ),
-		INIT_CONFIG_OPTION(  loresBlowupScale,  0 ),
-		INIT_CONFIG_OPTION(  mainmenuMusic,     true ),
-		INIT_CONFIG_OPTION(  mineralSubmenu,    true ),
-		INIT_CONFIG_OPTION(  nebulae,			true ),
-		INIT_CONFIG_OPTION(  rotatingIpPlanets,	true),
-		INIT_CONFIG_OPTION(  texturedIpPlanets,	true),
-		INIT_CONFIG_OPTION(  cheatMode,			false ),
-		INIT_CONFIG_OPTION(  godMode,			false ), //Serosis
+		INIT_CONFIG_OPTION(  resolutionFactor,  0 ),
+		INIT_CONFIG_OPTION(  loresBlowupScale,  1 ),
+		INIT_CONFIG_OPTION(  cheatMode,			false ), // JMS
+		//Serosis
+		INIT_CONFIG_OPTION(  godMode,			false ), 
 		INIT_CONFIG_OPTION(  timeDilationScale,	0 ),
 		INIT_CONFIG_OPTION(  bubbleWarp,		false ),
 		INIT_CONFIG_OPTION(  unlockShips,		false ),
@@ -298,6 +304,19 @@ main (int argc, char *argv[])
 		INIT_CONFIG_OPTION(  infiniteRU,		false ),
 		INIT_CONFIG_OPTION(  skipIntro,			false ),
 		INIT_CONFIG_OPTION(  FMV,				false ),
+		// JMS
+		INIT_CONFIG_OPTION(  mainMenuMusic,     true ),
+		INIT_CONFIG_OPTION(  nebulae,			true ),
+		INIT_CONFIG_OPTION(  orbitingPlanets,	false),
+		INIT_CONFIG_OPTION(  texturedPlanets,	false),
+		// Nic
+		INIT_CONFIG_OPTION(  optDateFormat,		0),
+		INIT_CONFIG_OPTION(  infiniteFuel,		false),
+		INIT_CONFIG_OPTION(  thraddStory,		false),
+		INIT_CONFIG_OPTION(  partialPickup,		false),
+		INIT_CONFIG_OPTION(  submenu,			true),
+		INIT_CONFIG_OPTION(  addDevices,		false),
+		INIT_CONFIG_OPTION(  scalePlanets,		true),
 	};
 	struct options_struct defaults = options;
 	int optionsResult;
@@ -315,12 +334,19 @@ main (int argc, char *argv[])
 	if (options.logFile != NULL)
 	{
 		int i;
-		freopen (options.logFile, "w", stderr);
+		if (!freopen (options.logFile, "w", stderr))
+		{
+			printf ("Error %d calling freopen() on stderr\n", errno);
+			return EXIT_FAILURE;
+		}
 #ifdef UNBUFFERED_LOGFILE
 		setbuf (stderr, NULL);
 #endif
 		for (i = 0; i < argc; ++i)
 			log_add (log_User, "argv[%d] = [%s]", i, argv[i]);
+	} else {
+		// MB: Output log to logfile by default, not console
+		freopen("uqm.log", "w", stderr);
 	}
 
 	if (options.runMode == runMode_version)
@@ -378,6 +404,7 @@ main (int argc, char *argv[])
 	if (!options.safeMode.value)
 	{
 		LoadResourceIndex (configDir, "uqm.cfg", "config.");
+		LoadResourceIndex (configDir, "cheats.cfg", "cheat.");
 		getUserConfigOptions (&options);
 	}
 
@@ -406,6 +433,7 @@ main (int argc, char *argv[])
 	// Fill in global variables:
 	opt3doMusic = options.use3doMusic.value;
 	optRemixMusic = options.useRemixMusic.value;
+	optSpeech = options.useSpeech.value;
 	optWhichCoarseScan = options.whichCoarseScan.value;
 	optWhichMenu = options.whichMenu.value;
 	optWhichFonts = options.whichFonts.value;
@@ -422,17 +450,11 @@ main (int argc, char *argv[])
 	optAddons = options.addons;
 	
 	resolutionFactor = (unsigned int) options.resolutionFactor.value; // JMS_GFX
-	forceAspectRatio = options.forceAspectRatio.value; // JMS_GFX
 	loresBlowupScale = (unsigned int) options.loresBlowupScale.value; // JMS_GFX
-	timeDilationScale = (unsigned int) options.timeDilationScale.value; // Serosis
-	resFactorWasChanged = FALSE; // JMS_GFX
-	optMainmenuMusic = options.mainmenuMusic.value; // JMS
-	optMineralSubmenu = options.mineralSubmenu.value; // JMS
-	optNebulae = options.nebulae.value; // JMS
-	optRotatingIpPlanets = options.rotatingIpPlanets.value; // JMS
-	optTexturedIpPlanets = options.texturedIpPlanets.value || optRotatingIpPlanets; // JMS
-	optCheatMode = options.cheatMode.value; // JMS
-	optGodMode = options.godMode.value; // Serosis
+	
+	optGodMode = options.godMode.value; // JMS
+	// Serosis
+	timeDilationScale = options.timeDilationScale.value;
 	optBubbleWarp = options.bubbleWarp.value;
 	optUnlockShips = options.unlockShips.value;
 	optHeadStart = options.headStart.value;
@@ -440,7 +462,23 @@ main (int argc, char *argv[])
 	optInfiniteRU = options.infiniteRU.value;
 	optSkipIntro = options.skipIntro.value;
 	optFMV = options.FMV.value;
-	
+	// JMS
+	optMainMenuMusic = options.mainMenuMusic.value;
+	optNebulae = options.nebulae.value;
+	optOrbitingPlanets = options.orbitingPlanets.value;
+	optTexturedPlanets = options.texturedPlanets.value;
+ 	optCheatMode = options.cheatMode.value;
+	// Nic
+	optDateFormat = options.optDateFormat.value;
+	// Serosis	
+	optInfiniteFuel = options.infiniteFuel.value;
+	optThraddStory = options.thraddStory.value;
+	optPartialPickup = options.partialPickup.value;
+	optSubmenu = options.submenu.value;
+	optAddDevices = options.addDevices.value;
+	optScalePlanets = options.scalePlanets.value;
+	resFactorWasChanged = FALSE; // JMS_GFX
+
 	prepareContentDir (options.contentDir, options.addonDir, argv[0]);
 	prepareMeleeDir ();
 	prepareSaveDir ();
@@ -451,17 +489,17 @@ main (int argc, char *argv[])
 
 	InitTimeSystem ();
 	InitTaskSystem ();
+	
+	luaUqm_init ();
 
-#ifdef NETPLAY
-	Network_init ();
 	Alarm_init ();
 	Callback_init ();
+
+#ifdef NETPLAY
+	Network_init ();
 	NetManager_init ();
 #endif
 
-	GraphicsLock = CreateMutex ("Graphics",
-			SYNC_CLASS_TOPLEVEL | SYNC_CLASS_VIDEO);
-
 	gfxDriver = options.opengl.value ?
 			TFB_GFXDRIVER_SDL_OPENGL : TFB_GFXDRIVER_SDL_PURE;
 	gfxFlags = options.scaler.value;
@@ -471,9 +509,13 @@ main (int argc, char *argv[])
 		gfxFlags |= TFB_GFXFLAGS_SCANLINES;
 	if (options.showFps.value)
 		gfxFlags |= TFB_GFXFLAGS_SHOWFPS;
-	TFB_InitGraphics (gfxDriver, gfxFlags, options.resolution.width, options.resolution.height, &resolutionFactor, forceAspectRatio); // JMS_GFX: added resolutionFactor
-	if (options.gamma.set)
-		TFB_SetGamma (options.gamma.value);
+	TFB_InitGraphics (gfxDriver, gfxFlags, options.resolution.width,
+			options.resolution.height, &resolutionFactor);
+	if (options.gamma.set && setGammaCorrection (options.gamma.value))
+		optGamma = options.gamma.value;
+	else
+		optGamma = 1.0f; // failed or default
+	
 	InitColorMaps ();
 	init_communication ();
 	/* TODO: Once threading is gone, restore initAudio here.
@@ -498,7 +540,7 @@ main (int argc, char *argv[])
 		}
 		else if (!GameActive)
 		{	// Throttle down the main loop when game is inactive
-			SleepThread (ONE_SECOND / 4);
+			HibernateThread (ONE_SECOND / 4);
 		}
 
 		TFB_ProcessEvents ();
@@ -512,27 +554,37 @@ main (int argc, char *argv[])
 	 *   tasks might still be using it */
 	if (MainExited)
 	{
-		// Not yet: TFB_UninitInput ();
+		TFB_UninitInput ();
 		unInitAudio ();
 		uninit_communication ();
+		
+		TFB_PurgeDanglingGraphics ();
+		// Purge above refers to colormaps which have to be still up
 		UninitColorMaps ();
-		// Not yet: TFB_UninitGraphics ();
+		TFB_UninitGraphics ();
 
 #ifdef NETPLAY
 		NetManager_uninit ();
-		Alarm_uninit ();
 		Network_uninit ();
 #endif
 
-		// Not yet: CleanupTaskSystem ();
+		Callback_uninit ();
+		Alarm_uninit ();
+		
+		luaUqm_uninit ();
+
+		CleanupTaskSystem ();
 		UnInitTimeSystem ();
 #if 0
 		unInitTempDir ();
 #endif
+		unprepareAllDirs ();
 		uninitIO ();
 		UnInitThreadSystem ();
 		mem_uninit ();
 	}
+
+	HFree (options.addons);
 	
 	return EXIT_SUCCESS;
 }
@@ -611,6 +663,25 @@ getVolumeConfigValue (struct float_optio
 	option->set = true;
 }
 
+static void
+getGammaConfigValue (struct float_option *option, const char *config_val)
+{
+	int val;
+
+	if (option->set || !res_IsInteger (config_val))
+		return;
+
+	val = res_GetInteger (config_val);
+	// gamma config option is a fixed-point number
+	// ignore ridiculously out-of-range values
+	if (val < (int)(0.03 * GAMMA_SCALE) || val > (int)(9.9 * GAMMA_SCALE))
+		return;
+	option->value = val / (float)GAMMA_SCALE;
+	// avoid setting gamma when not necessary
+	if (option->value != 1.0f)
+		option->set = true;
+}
+
 static bool
 getListConfigValue (struct int_option *option, const char *config_val,
 		const struct option_list_value *list)
@@ -659,6 +730,7 @@ getUserConfigOptions (struct options_str
 	getBoolConfigValue (&options->scanlines, "config.scanlines");
 	getBoolConfigValue (&options->showFps, "config.showfps");
 	getBoolConfigValue (&options->keepAspectRatio, "config.keepaspectratio");
+	getGammaConfigValue (&options->gamma, "config.gamma");
 
 	getBoolConfigValue (&options->subtitles, "config.subtitles");
 	
@@ -677,22 +749,13 @@ getUserConfigOptions (struct options_str
 
 	getBoolConfigValue (&options->use3doMusic, "config.3domusic");
 	getBoolConfigValue (&options->useRemixMusic, "config.remixmusic");
+	getBoolConfigValue (&options->useSpeech, "config.speech");
 
-	// JMS: Originally, the smooth zoom was TFB_SCALE_TRILINEAR instead of bilinear.
-	// Using bilinear alleviates the smooth zoom performance choppiness problems in 2x and 4x, but
-	// is kinda hacky solution...
 	getBoolConfigValueXlat (&options->meleeScale, "config.smoothmelee",
-							TFB_SCALE_BILINEAR, TFB_SCALE_STEP);
+			TFB_SCALE_TRILINEAR, TFB_SCALE_STEP);
 
-	if (getListConfigValue (&options->soundDriver, "config.audiodriver",
-			audioDriverList))
-	{
-		// XXX: I don't know if we should turn speech off in this case.
-		//   This affects which version of the alien script will be used.
-		if (options->soundDriver.value == audio_DRIVER_NOSOUND)
-			options->speechVolumeScale.value = 0.0f;
-	}
-	
+	getListConfigValue (&options->soundDriver, "config.audiodriver",
+			audioDriverList);
 	getListConfigValue (&options->soundQuality, "config.audioquality",
 			audioQualityList);
 	getBoolConfigValue (&options->stereoSFX, "config.positionalsfx");
@@ -708,32 +771,40 @@ getUserConfigOptions (struct options_str
 	}
 	
 	// JMS_GFX
-	getBoolConfigValue (&options->forceAspectRatio, "config.forceaspectratio");
-	
-	// JMS_GFX
 	if (res_IsInteger ("config.loresBlowupScale"))
 	{
 		options->loresBlowupScale.value = res_GetInteger ("config.loresBlowupScale");
 	}
-	
-	// JMS
-	getBoolConfigValue (&options->mainmenuMusic, "config.mainmenuMusic");
-	getBoolConfigValue (&options->mineralSubmenu, "config.mineralSubmenu");
-	getBoolConfigValue (&options->nebulae, "config.nebulae");
-	getBoolConfigValue (&options->rotatingIpPlanets, "config.rotatingIpPlanets");
-	getBoolConfigValue (&options->texturedIpPlanets, "config.texturedIpPlanets");
-	getBoolConfigValue (&options->cheatMode, "config.cheatMode");
-	getBoolConfigValue (&options->godMode, "config.godMode"); //Serosis
-	if (res_IsInteger ("config.timeDilation") && !options->timeDilationScale.set) {
-		options->timeDilationScale.value = res_GetInteger ("config.timeDilation");
-	}
-	getBoolConfigValue (&options->bubbleWarp, "config.bubbleWarp");
-	getBoolConfigValue (&options->unlockShips, "config.unlockShips");
-	getBoolConfigValue (&options->headStart, "config.headStart");
-	getBoolConfigValue (&options->unlockUpgrades, "config.unlockUpgrades");
-	getBoolConfigValue (&options->infiniteRU, "config.infiniteRU");
+
+	getBoolConfigValue (&options->cheatMode, "cheat.kohrStahp"); // JMS
+	// Serosis
+	getBoolConfigValue (&options->godMode, "cheat.godMode");
+	if (res_IsInteger ("cheat.timeDilation") && !options->timeDilationScale.set) {
+		options->timeDilationScale.value = res_GetInteger ("cheat.timeDilation");
+	}
+	getBoolConfigValue (&options->bubbleWarp, "cheat.bubbleWarp");
+	getBoolConfigValue (&options->unlockShips, "cheat.unlockShips");
+	getBoolConfigValue (&options->headStart, "cheat.headStart");
+	getBoolConfigValue (&options->unlockUpgrades, "cheat.unlockUpgrades");
+	getBoolConfigValue (&options->infiniteRU, "cheat.infiniteRU");
 	getBoolConfigValue (&options->skipIntro, "config.skipIntro");
 	getBoolConfigValue (&options->FMV, "config.FMV");
+	// JMS
+	getBoolConfigValue (&options->mainMenuMusic, "config.mainMenuMusic");
+	getBoolConfigValue (&options->nebulae, "config.nebulae");
+	getBoolConfigValue (&options->orbitingPlanets, "config.orbitingPlanets");
+	getBoolConfigValue (&options->texturedPlanets, "config.texturedPlanets");
+	// Nic	
+	if (res_IsInteger ("config.dateFormat") && !options->optDateFormat.set) {
+		options->optDateFormat.value = res_GetInteger ("config.dateFormat");
+	}
+	// Serosis	
+	getBoolConfigValue (&options->infiniteFuel, "cheat.infiniteFuel");
+	getBoolConfigValue (&options->thraddStory, "config.thraddStory");
+	getBoolConfigValue (&options->partialPickup, "config.partialPickup");
+	getBoolConfigValue (&options->submenu, "config.submenu");
+	getBoolConfigValue (&options->addDevices, "cheat.addDevices");
+	getBoolConfigValue (&options->scalePlanets, "config.scalePlanets");
 	
 	if (res_IsInteger ("config.player1control"))
 	{
@@ -777,14 +848,24 @@ enum
 	GODMODE_OPT,
 	TDM_OPT,
 	BWARP_OPT,
-	ROSEBUD_OPT,
 	UNLOCKSHIPS_OPT,
 	HEADSTART_OPT,
 	UPGRADES_OPT,
 	INFINITERU_OPT,
-	FASTFORWARD_OPT,
 	SKIPINTRO_OPT,
 	FMV_OPT,
+	MENUMUS_OPT,
+	NEBU_OPT,
+	ORBITS_OPT,
+	TEXTPLAN_OPT,
+	DATE_OPT,
+	INFFUEL_OPT,
+	THRADD_OPT,
+	PICKUP_OPT,
+	SUBMENU_OPT,
+	DEVICES_OPT,
+	SCALEPLAN_OPT,
+	MELEE_OPT,
 #ifdef NETPLAY
 	NETHOST1_OPT,
 	NETPORT1_OPT,
@@ -792,10 +873,9 @@ enum
 	NETPORT2_OPT,
 	NETDELAY_OPT,
 #endif
-	RESFACTOR_OPT, // JMS_GFX
 };
 
-static const char *optString = "+r:foc:b:spC:n:?hM:S:T:m:q:ug:l:i:vwxk";
+static const char *optString = "+r:foc:b:spC:n:?hM:S:T:q:ug:l:i:vwxk";
 static struct option longOptions[] = 
 {
 	{"res", 1, NULL, 'r'},
@@ -837,14 +917,24 @@ static struct option longOptions[] =
 	{"godmode", 0, NULL, GODMODE_OPT},
 	{"timedilation", 1, NULL, TDM_OPT},
 	{"bubblewarp", 0, NULL, BWARP_OPT},
-	{"rosebud", 0, NULL, ROSEBUD_OPT},
 	{"unlockships", 0, NULL, UNLOCKSHIPS_OPT},
 	{"headstart", 0, NULL, HEADSTART_OPT},
 	{"unlockupgrades", 0, NULL, UPGRADES_OPT},
 	{"infiniteru", 0, NULL, INFINITERU_OPT},
-	{"fastforward", 0, NULL, FASTFORWARD_OPT},
 	{"skipintro", 0, NULL, SKIPINTRO_OPT},
 	{"fmv", 0, NULL, FMV_OPT},
+	{"mainmenumusic", 0, NULL, MENUMUS_OPT},
+	{"nebulae", 0, NULL, NEBU_OPT},
+	{"orbitingplanets", 0, NULL, ORBITS_OPT},
+	{"texturedplanets", 0, NULL, TEXTPLAN_OPT},
+	{"dateformat", 0, NULL, DATE_OPT},
+	{"infinitefuel", 0, NULL, INFFUEL_OPT},
+	{"thraddstory", 0, NULL, THRADD_OPT},
+	{"partialpickup", 0, NULL, PICKUP_OPT},
+	{"submenu", 0, NULL, SUBMENU_OPT},
+	{"adddevices", 0, NULL, DEVICES_OPT},
+	{"scaledevices", 0, NULL, SCALEPLAN_OPT},
+	{"melee", 0, NULL, MELEE_OPT},
 #ifdef NETPLAY
 	{"nethost1", 1, NULL, NETHOST1_OPT},
 	{"netport1", 1, NULL, NETPORT1_OPT},
@@ -852,7 +942,6 @@ static struct option longOptions[] =
 	{"netport2", 1, NULL, NETPORT2_OPT},
 	{"netdelay", 1, NULL, NETDELAY_OPT},
 #endif
-	{"resfactor", 1, NULL, RESFACTOR_OPT}, // JMS_GFX
 	{0, 0, 0, 0}
 };
 
@@ -1092,17 +1181,9 @@ parseOptions (int argc, char *argv[], st
 				}
 				break;
 			case SOUND_OPT:
-				if (setListOption (&options->soundDriver, optarg,
+				if (!setListOption (&options->soundDriver, optarg,
 						audioDriverList))
 				{
-					// XXX: I don't know if we should turn speech off in
-					//   this case. This affects which version of the alien
-					//   script will be used.
-					if (options->soundDriver.value == audio_DRIVER_NOSOUND)
-						options->speechVolumeScale.value = 0.0f;
-				}
-				else
-				{
 					InvalidArgument (optarg, "--sound");
 					badArg = true;
 				}
@@ -1151,6 +1232,53 @@ parseOptions (int argc, char *argv[], st
 			case FMV_OPT:
 				setBoolOption (&options->FMV, true);
 				break;
+			case MENUMUS_OPT:
+				setBoolOption (&options->mainMenuMusic, true);
+				break;
+			case NEBU_OPT:
+				setBoolOption (&options->nebulae, true);
+				break;
+			case ORBITS_OPT:
+				setBoolOption (&options->orbitingPlanets, true);
+				break;
+			case TEXTPLAN_OPT:
+				setBoolOption (&options->texturedPlanets, true);
+				break;
+			case DATE_OPT:{
+				int temp;
+				if (parseIntOption (optarg, &temp, "Date Format") == -1) {
+					badArg = true;
+					break;
+				} else if (temp < 0 || temp > 3) {					
+					saveError ("\nDate Format has to be 0, 1, 2, or 3.\n");
+					badArg = true;
+				} else {
+					options->optDateFormat.value = temp;
+					options->optDateFormat.set = true;
+				}
+				break;
+			}
+			case INFFUEL_OPT:
+				setBoolOption (&options->infiniteFuel, true);
+				break;
+			case THRADD_OPT:
+				setBoolOption (&options->thraddStory, true);
+				break;
+			case PICKUP_OPT:
+				setBoolOption (&options->partialPickup, true);
+				break;
+			case SUBMENU_OPT:
+				setBoolOption (&options->submenu, true);
+				break;
+			case DEVICES_OPT:
+				setBoolOption (&options->addDevices, true);
+				break;
+			case SCALEPLAN_OPT:
+				setBoolOption (&options->scalePlanets, true);
+				break;
+			case MELEE_OPT:
+				optSuperMelee = TRUE;
+				break;
 			case ADDON_OPT:
 				options->numAddons++;
 				options->addons = HRealloc ((void *) options->addons,
@@ -1175,7 +1303,7 @@ parseOptions (int argc, char *argv[], st
 				}
 				break;
 			}
-	        case SAFEMODE_OPT:
+			case SAFEMODE_OPT:
 				setBoolOption (&options->safeMode, true);
 				break;
 #ifdef NETPLAY
@@ -1212,26 +1340,6 @@ parseOptions (int argc, char *argv[], st
 				break;
 			}
 #endif
-			// JMS_GFX: Added the whole following case. It checks whether the resolutionfactor value is sane.
-			case RESFACTOR_OPT:
-			{
-				int temp;
-				if (parseIntOption (optarg, &temp, "resolution factor")
-						== -1)
-				{
-					badArg = true;
-					break;
-				}
-				options->resolutionFactor.value = temp;
-
-				if (options->resolutionFactor.value > 2)
-				{
-					saveError ("Resolution factor has to be 0, 1 or 2.");
-					badArg = true;
-				}
-				options->resolutionFactor.set = true;
-				break;
-			}
 			default:
 				saveError ("Error: Unknown option '%s'",
 						optionIndex < 0 ? "<unknown>" :
@@ -1320,27 +1428,27 @@ usage (FILE *out, const struct options_s
 	log_captureLines (LOG_CAPTURE_ALL);
 	
 	log_add (log_User, "Options:");
-	log_add (log_User, "  -r, --res=WIDTHxHEIGHT (default 640x480, bigger "
+	log_add (log_User, "  -r, --res=WIDTHxHEIGHT (default: 640x480, bigger "
 			"works only with --opengl)");
-	log_add (log_User, "  -f, --fullscreen (default %s)",
+	log_add (log_User, "  -f, --fullscreen (default: %s)",
 			boolOptString (&defaults->fullscreen));
-	log_add (log_User, "  -w, --windowed (default %s)",
+	log_add (log_User, "  -w, --windowed (default: %s)",
 			boolNotOptString (&defaults->fullscreen));
-	log_add (log_User, "  -o, --opengl (default %s)",
+	log_add (log_User, "  -o, --opengl (default: %s)",
 			boolOptString (&defaults->opengl));
-	log_add (log_User, "  -x, --nogl (default %s)",
+	log_add (log_User, "  -x, --nogl (default: %s)",
 			boolNotOptString (&defaults->opengl));
-	log_add (log_User, "  -k, --keepaspectratio (default %s)",
+	log_add (log_User, "  -k, --keepaspectratio (default: %s)",
 			boolOptString (&defaults->keepAspectRatio));
 	log_add (log_User, "  -c, --scale=MODE (bilinear, biadapt, biadv, "
 			"triscan, hq or none (default) )");
 	log_add (log_User, "  -b, --meleezoom=MODE (step, aka pc, or smooth, "
 			"aka 3do; default is 3do)");
-	log_add (log_User, "  -s, --scanlines (default %s)",
+	log_add (log_User, "  -s, --scanlines (default: %s)",
 			boolOptString (&defaults->scanlines));
-	log_add (log_User, "  -p, --fps (default %s)",
+	log_add (log_User, "  -p, --fps (default: %s)",
 			boolOptString (&defaults->showFps));
-	log_add (log_User, "  -g, --gamma=CORRECTIONVALUE (default 1.0, which "
+	log_add (log_User, "  -g, --gamma=CORRECTIONVALUE (default: 1.0, which "
 			"causes no change)");
 	log_add (log_User, "  -C, --configdir=CONFIGDIR");
 	log_add (log_User, "  -n, --contentdir=CONTENTDIR");
@@ -1371,48 +1479,71 @@ usage (FILE *out, const struct options_s
 #endif
 	log_add (log_User, "The following options can take either '3do' or 'pc' "
 			"as an option:");
-	log_add (log_User, "  -i, --intro : Intro/ending version (default %s)",
+	log_add (log_User, "  -i, --intro : Intro/ending version (default: %s)",
 			choiceOptString (&defaults->whichIntro));
 	log_add (log_User, "  --cscan     : coarse-scan display, pc=text, "
-			"3do=hieroglyphs (default %s)",
+			"3do=hieroglyphs (default: %s)",
 			choiceOptString (&defaults->whichCoarseScan));
 	log_add (log_User, "  --menu      : menu type, pc=text, 3do=graphical "
-			"(default %s)", choiceOptString (&defaults->whichMenu));
-	log_add (log_User, "  --font      : font types and colors (default %s)",
+			"(default: %s)", choiceOptString (&defaults->whichMenu));
+	log_add (log_User, "  --font      : font types and colors (default: %s)",
 			choiceOptString (&defaults->whichFonts));
 	log_add (log_User, "  --shield    : slave shield type; pc=static, "
-			"3do=throbbing (default %s)",
+			"3do=throbbing (default: %s)",
 			choiceOptString (&defaults->whichShield));
 	log_add (log_User, "  --scroll    : ff/frev during comm.  pc=per-page, "
-			"3do=smooth (default normal)");
+			"3do=smooth (default: %s)",
+			choiceOptString (&defaults->smoothScroll));
+
 	log_add (log_User, "The following options are for the Mega Mod"); // Serosis
-	log_add (log_User, "  --kohrstahp : Stops Kohr-Ah advancing.    (default %s)",
+	log_add (log_User, "  --kohrstahp : Stops Kohr-Ah advancing.    (default: %s)",
 			boolOptString (&defaults->cheatMode));
 	log_add (log_User, "  --godmode : Player ships and lander invulnerable. "
-			"Also refills energy every shot during melee.    (default %s)",
+			"Also refills energy every shot during melee.    (default: %s)",
 			boolOptString (&defaults->godMode));
-	log_add (log_User, "  --timedilation : Increases and decreases time by a factor of 5. "
-			"(default 0)");
+	log_add (log_User, "  --timedilation : =1 Time is slowed down times 6. "
+			"=2 Time is sped up times 5    (default: 0)");
 	log_add (log_User, "  --bubblewarp : Instantaneous travel to any point on "
-			"the Starmap.    (default %s)",
+			"the Starmap.    (default: %s)",
 			boolOptString (&defaults->bubbleWarp));
 	log_add (log_User, "  --unlockships : Allows you to purchase ships that you can't "
-			"normally acquire in the main game.    (default %s)",
+			"normally acquire in the main game.    (default: %s)",
 			boolOptString (&defaults->unlockShips));
-	log_add (log_User, "  --headstart : Equips your ship with full thrusters and jets, "
-			"two ion bolt guns, two cargo bays, two crew pods, four dynamos, two full fuel tanks, "
-			"max landers, 1000 radioactives, and 1000 bio-units.    (default %s)",
+	log_add (log_User, "  --headstart : Gives you an extra storage bay full of minerals, Fwiffo, "
+			"and the Moonbase during a new game   (default: %s)",
 			boolOptString (&defaults->headStart));
 	log_add (log_User, "  --unlockupgrades : Unlocks every upgrade for your flagship "
-			"and landers.    (default %s)",
+			"and landers.    (default: %s)",
 			boolOptString (&defaults->unlockUpgrades));
-	log_add (log_User, "  --landermods : Makes your landers have pin-point accuracy "
-			"when landing and doubles storage capacity.   (default %s)",
+	log_add (log_User, "  --infiniteru : Gives you infinite R.U. as long as the cheat is on "
+			" (default: %s)",
 			boolOptString (&defaults->infiniteRU));
-	log_add (log_User, "  --skipintro : Skips the intro    (default %s)",
+	log_add (log_User, "  --skipintro : Skips the intro and Logo fmv    (default: %s)",
 			boolOptString (&defaults->skipIntro));
-	log_add (log_User, "  --fmv : Adds Logo and Commercial 3DO videos    (default %s)",
+	log_add (log_User, "  --fmv : Plays Logo and Commercial 3DO videos    (default: %s)",
 			boolOptString (&defaults->FMV));
+	log_add (log_User, "  --mainmenumusic : Switches the main menu music on/off    (default: %s)",
+			boolOptString (&defaults->mainMenuMusic));
+	log_add (log_User, "  --nebulae : Enables/Disables nebulae in star systems    (default: %s)",
+			boolOptString (&defaults->nebulae));
+	log_add (log_User, "  --orbitingplanets : Enables/Disables orbiting planets in star systems    (default: %s)",
+			boolOptString (&defaults->orbitingPlanets));
+	log_add (log_User, "  --texturedplanets : Enables/Disables textured planets in star systems    (default: %s)",
+			boolOptString (&defaults->texturedPlanets));
+	log_add (log_User, "  --infinitefuel : Infinite fuel in the main game    (default: %s)",
+			boolOptString (&defaults->infiniteFuel));
+	log_add (log_User, "  --thraddstory : Enables/Disables the Alt Thraddash Storyline    (default: %s)",
+			boolOptString (&defaults->thraddStory));
+	log_add (log_User, "  --partialpickup : Enables/Disables partial mineral pickup    (default: %s)",
+			boolOptString (&defaults->partialPickup));
+	log_add (log_User, "  --submenu : Enables/Disables mineral and star map keys submenu    (default: %s)",
+			boolOptString (&defaults->submenu));
+	log_add (log_User, "  --dateformat : 0: MMM DD.YYYY | 1: MM.DD.YYYY | "
+			"2: DD MMM.YYYY | 3: DD.MM.YYYY   (default: 0)");
+	log_add (log_User, "  --adddevices : Gives you all available devices    (default: %s)",
+			boolOptString (&defaults->addDevices));
+	log_add (log_User, "  --scaleplanets : Scales textured planets in HD    (default: %s)",
+			boolOptString (&defaults->scalePlanets));
 	log_setOutput (old);
 }
 
@@ -1448,3 +1579,4 @@ boolNotOptString (const struct bool_opti
 {
 	return option->value ? "off" : "on";
 }
+
diff -ruNp src.hd/uqmversion.h src/uqmversion.h
--- src.hd/uqmversion.h	2017-12-29 02:25:55 -0800
+++ src/uqmversion.h	2017-12-29 00:57:56 -0800
@@ -19,11 +19,11 @@
 
 #define UQM_MAJOR_VERSION     0
 #define UQM_MAJOR_VERSION_S  "0"
-#define UQM_MINOR_VERSION     7
-#define UQM_MINOR_VERSION_S  "7"
-#define UQM_PATCH_VERSION     3
-#define UQM_PATCH_VERSION_S  "3"
-#define UQM_EXTRA_VERSION    "b HD MegaMod"
+#define UQM_MINOR_VERSION     8
+#define UQM_MINOR_VERSION_S  "8"
+#define UQM_PATCH_VERSION     0
+#define UQM_PATCH_VERSION_S  "0"
+#define UQM_EXTRA_VERSION    "-HD MegaMod Beta"
 /* The final version is interpreted as:
  * printf ("%d.%d.%d%s", UQM_MAJOR_VERSION, UQM_MINOR_VERSION,
  * 		UQM_PATCH_VERSION, UQM_EXTRA_VERSION);
@@ -33,6 +33,4 @@
 		UQM_MAJOR_VERSION_S "." UQM_MINOR_VERSION_S "." UQM_PATCH_VERSION_S \
 		UQM_EXTRA_VERSION
 
-#define UQM_SVN_REVISION "$Revision: 3628 $"
-
 #endif
