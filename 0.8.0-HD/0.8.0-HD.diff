diff -ruNp src.mm/libs/gfxlib.h src/libs/gfxlib.h
--- src.mm/libs/gfxlib.h	2017-11-28 11:08:35 -0600
+++ src/libs/gfxlib.h	2017-11-28 11:09:22 -0600
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2011: Added DPOINT type - a coordinate point with larger values to avoid overflows in hires modes.
+
 #ifndef _GFXLIB_H
 #define _GFXLIB_H
 
@@ -153,11 +155,23 @@ typedef struct extent
 	COORD width, height;
 } EXTENT;
 
+// JMS: Extent with larger values to avoid overflows in hires modes.
+typedef struct dextent
+{
+	SDWORD width, height;
+} DEXTENT;
+
 typedef struct point
 {
 	COORD x, y;
 } POINT;
 
+// JMS: coordinate point with larger values to avoid overflows in hires modes.
+typedef struct dpoint
+{
+	SDWORD x, y;
+} DPOINT;
+
 typedef struct stamp
 {
 	POINT origin;
diff -ruNp src.mm/libs/graphics/dcqueue.c src/libs/graphics/dcqueue.c
--- src.mm/libs/graphics/dcqueue.c	2017-11-28 11:08:35 -0600
+++ src/libs/graphics/dcqueue.c	2017-11-28 11:09:22 -0600
@@ -589,13 +589,13 @@ TFB_FlushGraphics (void)
 				int oldWidth = ScreenWidthActual;
 				int oldHeight = ScreenHeightActual;
 				if (TFB_ReInitGraphics (cmd->driver, cmd->flags,
-						cmd->width, cmd->height))
+						cmd->width, cmd->height, &resolutionFactor))
 				{
 					log_add (log_Error, "Could not provide requested mode: "
 							"reverting to last known driver.");
 					// We don't know what exactly failed, so roll it all back
 					if (TFB_ReInitGraphics (oldDriver, oldFlags,
-							oldWidth, oldHeight))
+							oldWidth, oldHeight, &resolutionFactor))
 					{
 						log_add (log_Fatal,
 								"Couldn't reinit at that point either. "
diff -ruNp src.mm/libs/graphics/gfx_common.c src/libs/graphics/gfx_common.c
--- src.mm/libs/graphics/gfx_common.c	2017-11-28 11:08:35 -0600
+++ src/libs/graphics/gfx_common.c	2017-11-28 11:09:22 -0600
@@ -23,6 +23,11 @@
 #include "libs/misc.h"
 		// for TFB_DEBUG_HALT
 
+// JMS_GFX
+unsigned int resolutionFactor;
+int fs_height = 0; 
+int fs_width  = 0;
+// End JMS_GFX
 
 int ScreenWidth;
 int ScreenHeight;
@@ -44,12 +49,26 @@ DrawFromExtraScreen (RECT *r)
 	TFB_DrawScreen_Copy(r, TFB_SCREEN_EXTRA, TFB_SCREEN_MAIN);
 }
 
+// JMS_GFX
+void
+DrawFromExtraScreen_Fs (RECT *r)
+{
+	TFB_DrawScreen_Copy_Fs(r, TFB_SCREEN_EXTRA, TFB_SCREEN_MAIN);
+}
+
 void
 LoadIntoExtraScreen (RECT *r)
 {
 	TFB_DrawScreen_Copy(r, TFB_SCREEN_MAIN, TFB_SCREEN_EXTRA);
 }
 
+// JMS_GFX
+void
+LoadIntoExtraScreen_Fs (RECT *r)
+{
+	TFB_DrawScreen_Copy_Fs(r, TFB_SCREEN_MAIN, TFB_SCREEN_EXTRA);
+}
+
 int
 SetGraphicScale (int scale)
 {
diff -ruNp src.mm/libs/graphics/gfx_common.h src/libs/graphics/gfx_common.h
--- src.mm/libs/graphics/gfx_common.h	2017-11-28 11:08:35 -0600
+++ src/libs/graphics/gfx_common.h	2017-11-28 11:09:22 -0600
@@ -63,8 +63,8 @@ extern int GfxFlags;
 
 // The following functions are driver-defined
 void TFB_PreInit (void);
-int TFB_InitGraphics (int driver, int flags, int width, int height);
-int TFB_ReInitGraphics (int driver, int flags, int width, int height);
+int TFB_InitGraphics (int driver, int flags, int width, int height, unsigned int *resolutionFactor);
+int TFB_ReInitGraphics (int driver, int flags, int width, int height, unsigned int *resolutionFactor);
 void TFB_UninitGraphics (void);
 void TFB_ProcessEvents (void);
 bool TFB_SetGamma (float gamma);
@@ -82,7 +82,9 @@ typedef enum {
 } SCALE;
 
 void LoadIntoExtraScreen (RECT *r);
+void LoadIntoExtraScreen_Fs (RECT *r); // JMS_GFX
 void DrawFromExtraScreen (RECT *r);
+void DrawFromExtraScreen_Fs (RECT *r); // JMS_GFX
 int SetGraphicScale (int scale);
 int GetGraphicScale (void);
 int SetGraphicScaleMode (int mode /* enum SCALE */);
@@ -100,6 +102,13 @@ extern int FrameRateTickBase;
 void TFB_FlushGraphics (void); // Only call from main thread!!
 void TFB_PurgeDanglingGraphics (void); // Only call from main thread as part of shutdown.
 
+// JMS_GFX
+extern unsigned int resolutionFactor;
+extern BOOLEAN forceAspectRatio;
+extern int fs_height; 
+extern int fs_width;
+// END JMS_GFX
+
 extern int ScreenWidth;
 extern int ScreenHeight;
 extern int ScreenWidthActual;
diff -ruNp src.mm/libs/graphics/intersec.c src/libs/graphics/intersec.c
--- src.mm/libs/graphics/intersec.c	2017-11-28 11:08:35 -0600
+++ src/libs/graphics/intersec.c	2017-11-28 11:09:23 -0600
@@ -35,11 +35,11 @@ frame_intersect (INTERSECT_CONTROL *pCon
 		INTERSECT_CONTROL *pControl1, RECT *pr1, TIME_VALUE t0,
 		TIME_VALUE t1)
 {
-	SIZE time_error0, time_error1;
-	SIZE cycle0, cycle1;
-	SIZE dx_0, dy_0, dx_1, dy_1;
-	SIZE xincr0, yincr0, xincr1, yincr1;
-	SIZE xerror0, xerror1, yerror0, yerror1;
+	SDWORD time_error0, time_error1;
+	SDWORD cycle0, cycle1;
+	SDWORD dx_0, dy_0, dx_1, dy_1;
+	SDWORD xincr0, yincr0, xincr1, yincr1;
+	SDWORD xerror0, xerror1, yerror0, yerror1;
 	RECT r_intersect;
 	IMAGE_BOX IB0, IB1;
 	BOOLEAN check0, check1;
@@ -109,56 +109,56 @@ frame_intersect (INTERSECT_CONTROL *pCon
 	}
 	else
 	{
-		SIZE delta;
-		COUNT start;
+		SDWORD delta;
+		DWORD start;
 		long error;
 
-		start = (COUNT)cycle0 * (COUNT)(t0 - 1);
+		start = (DWORD)cycle0 * (DWORD)(t0 - 1);
 		time_error0 = start & ((1 << TIME_SHIFT) - 1);
-		if ((start >>= (COUNT)TIME_SHIFT) > 0)
+		if ((start >>= (DWORD)TIME_SHIFT) > 0)
 		{
 			if ((error = (long)xerror0
 					- (long)dx_0 * (long)start) > 0)
-				xerror0 = (SIZE)error;
+				xerror0 = (SDWORD)error;
 			else
 			{
-				delta = -(SIZE)(error / (long)cycle0) + 1;
+				delta = -(SDWORD)(error / (long)cycle0) + 1;
 				IB0.Box.corner.x += xincr0 * delta;
-				xerror0 = (SIZE)(error + (long)cycle0 * (long)delta);
+				xerror0 = (SDWORD)(error + (long)cycle0 * (long)delta);
 			}
 			if ((error = (long)yerror0
 					- (long)dy_0 * (long)start) > 0)
-				yerror0 = (SIZE)error;
+				yerror0 = (SDWORD)error;
 			else
 			{
-				delta = -(SIZE)(error / (long)cycle0) + 1;
+				delta = -(SDWORD)(error / (long)cycle0) + 1;
 				IB0.Box.corner.y += yincr0 * delta;
-				yerror0 = (SIZE)(error + (long)cycle0 * (long)delta);
+				yerror0 = (SDWORD)(error + (long)cycle0 * (long)delta);
 			}
 			pr0->corner = IB0.Box.corner;
 		}
 	
-		start = (COUNT)cycle1 * (COUNT)(t0 - 1);
+		start = (DWORD)cycle1 * (DWORD)(t0 - 1);
 		time_error1 = start & ((1 << TIME_SHIFT) - 1);
-		if ((start >>= (COUNT)TIME_SHIFT) > 0)
+		if ((start >>= (DWORD)TIME_SHIFT) > 0)
 		{
 			if ((error = (long)xerror1
 					- (long)dx_1 * (long)start) > 0)
-				xerror1 = (SIZE)error;
+				xerror1 = (SDWORD)error;
 			else
 			{
-				delta = -(SIZE)(error / (long)cycle1) + 1;
+				delta = -(SDWORD)(error / (long)cycle1) + 1;
 				IB1.Box.corner.x += xincr1 * delta;
-				xerror1 = (SIZE)(error + (long)cycle1 * (long)delta);
+				xerror1 = (SDWORD)(error + (long)cycle1 * (long)delta);
 			}
 			if ((error = (long)yerror1
 					- (long)dy_1 * (long)start) > 0)
-				yerror1 = (SIZE)error;
+				yerror1 = (SDWORD)error;
 			else
 			{
-				delta = -(SIZE)(error / (long)cycle1) + 1;
+				delta = -(SDWORD)(error / (long)cycle1) + 1;
 				IB1.Box.corner.y += yincr1 * delta;
-				yerror1 = (SIZE)(error + (long)cycle1 * (long)delta);
+				yerror1 = (SDWORD)(error + (long)cycle1 * (long)delta);
 			}
 			pr1->corner = IB1.Box.corner;
 		}
@@ -237,8 +237,8 @@ TIME_VALUE
 DrawablesIntersect (INTERSECT_CONTROL *pControl0,
 		INTERSECT_CONTROL *pControl1, TIME_VALUE max_time_val)
 {
-	SIZE dy;
-	SIZE time_y_0, time_y_1;
+	SDWORD dy;
+	SDWORD time_y_0, time_y_1;
 	RECT r0, r1;
 	FRAME FramePtr0, FramePtr1;
 
@@ -278,8 +278,8 @@ DrawablesIntersect (INTERSECT_CONTROL *p
 			|| (time_y_0 > 0 && dy >= time_y_0)
 			|| (time_y_1 < 0 && dy <= time_y_1))
 	{
-		SIZE dx;
-		SIZE time_x_0, time_x_1;
+		SDWORD dx;
+		SDWORD time_x_0, time_x_1;
 
 		dx = r1.corner.x - r0.corner.x;
 		time_x_0 = dx - GetFrameWidth (FramePtr0) + 1;
@@ -296,7 +296,7 @@ DrawablesIntersect (INTERSECT_CONTROL *p
 				time_y_0 = time_y_1 = 0;
 			else
 			{
-				SIZE t;
+				SDWORD t;
 				long time_beg, time_end, fract;
 
 				if (time_y_1 < 0)
@@ -379,14 +379,14 @@ DrawablesIntersect (INTERSECT_CONTROL *p
 				if ((time_beg <<= TIME_SHIFT) < fract)
 					time_y_0 = 0;
 				else
-					time_y_0 = (SIZE)(time_beg / fract);
+					time_y_0 = (SDWORD)(time_beg / fract);
 
 				if (time_end >= fract /* just in case of overflow */
 						|| (time_end <<= TIME_SHIFT) >=
 						fract * (long)max_time_val)
 					time_y_1 = max_time_val - 1;
 				else
-					time_y_1 = (SIZE)((time_end + fract - 1) / fract) - 1;
+					time_y_1 = (SDWORD)((time_end + fract - 1) / fract) - 1;
 			}
 
 #ifdef DEBUG_INTERSEC
diff -ruNp src.mm/libs/graphics/sdl/canvas.c src/libs/graphics/sdl/canvas.c
--- src.mm/libs/graphics/sdl/canvas.c	2017-11-28 11:08:35 -0600
+++ src/libs/graphics/sdl/canvas.c	2017-11-28 11:09:23 -0600
@@ -2119,7 +2119,7 @@ TFB_DrawCanvas_TransferIndexes (TFB_Canv
 	if (!TFB_DrawCanvas_IsPaletted (canvas) || fmt->BitsPerPixel != 8)
 	{
 		log_add (log_Warning, "ERROR: TFB_DrawCanvas_TransferIndexes "
-				"unimplemeted function: not an 8bpp indexed canvas");
+				"unimplemeted function: not an 8bpp indexed canvas", fmt->BitsPerPixel);
 		return FALSE;
 	}
 
diff -ruNp src.mm/libs/graphics/sdl/opengl.c src/libs/graphics/sdl/opengl.c
--- src.mm/libs/graphics/sdl/opengl.c	2017-11-28 11:08:36 -0600
+++ src/libs/graphics/sdl/opengl.c	2017-11-28 11:09:23 -0600
@@ -54,6 +54,8 @@ static void TFB_GL_Preprocess (int force
 static void TFB_GL_Postprocess (void);
 static void TFB_GL_Scaled_ScreenLayer (SCREEN screen, Uint8 a, SDL_Rect *rect);
 static void TFB_GL_Unscaled_ScreenLayer (SCREEN screen, Uint8 a, SDL_Rect *rect);
+static void TFB_GL_Unscaled_ScreenLayer_2x (SCREEN screen, Uint8 a, SDL_Rect *rect);
+static void TFB_GL_Unscaled_ScreenLayer_4x (SCREEN screen, Uint8 a, SDL_Rect *rect);
 static void TFB_GL_ColorLayer (Uint8 r, Uint8 g, Uint8 b, Uint8 a, SDL_Rect *rect);
 
 static TFB_GRAPHICS_BACKEND opengl_scaled_backend = {
@@ -68,9 +70,21 @@ static TFB_GRAPHICS_BACKEND opengl_unsca
 	TFB_GL_Unscaled_ScreenLayer,
 	TFB_GL_ColorLayer };
 
+static TFB_GRAPHICS_BACKEND opengl_unscaled_backend_2x = {
+	TFB_GL_Preprocess,
+	TFB_GL_Postprocess,
+	TFB_GL_Unscaled_ScreenLayer_2x,
+	TFB_GL_ColorLayer };
+
+static TFB_GRAPHICS_BACKEND opengl_unscaled_backend_4x = {
+	TFB_GL_Preprocess,
+	TFB_GL_Postprocess,
+	TFB_GL_Unscaled_ScreenLayer_4x,
+	TFB_GL_ColorLayer };
+
 
 static int
-AttemptColorDepth (int flags, int width, int height, int bpp)
+AttemptColorDepth (int flags, int width, int height, int bpp, unsigned int resolutionFactor)
 {
 	int videomode_flags;
 	ScreenColorDepth = bpp;
@@ -113,6 +127,17 @@ AttemptColorDepth (int flags, int width,
 		videomode_flags |= SDL_FULLSCREEN;
 	videomode_flags |= SDL_ANYFORMAT;
 
+	if (resolutionFactor > 0 && flags & TFB_GFXFLAGS_FULLSCREEN)
+	{
+		height = fs_height;
+		width  = fs_width;
+			
+		log_add (log_Debug,"X:%d y:%d", width, height);
+	}
+	
+	ScreenWidthActual = width;
+	ScreenHeightActual = height;
+
 	SDL_Video = SDL_SetVideoMode (ScreenWidthActual, ScreenHeightActual, 
 		bpp, videomode_flags);
 	if (SDL_Video == NULL)
@@ -120,31 +145,47 @@ AttemptColorDepth (int flags, int width,
 		log_add (log_Error, "Couldn't set OpenGL %ix%ix%i video mode: %s",
 				ScreenWidthActual, ScreenHeightActual, bpp,
 				SDL_GetError ());
+
+		if (flags & TFB_GFXFLAGS_FULLSCREEN)
+		{
+			videomode_flags &= ~SDL_FULLSCREEN;
+			log_add (log_Error, "Falling back to windowed mode!!");
+			SDL_Video = SDL_SetVideoMode (ScreenWidthActual, ScreenHeightActual, bpp, videomode_flags);
+			
+			if (SDL_Video != NULL)
+				goto successful_change;
+		}
+
 		return -1;
 	}
 	else
 	{
+		successful_change:
 		log_add (log_Info, "Set the resolution to: %ix%ix%i"
-				" (surface reports %ix%ix%i)",
+				" (surface reports %ix%ix%i) (res_cat %u)",
 				width, height, bpp,			 
 				SDL_GetVideoSurface()->w, SDL_GetVideoSurface()->h,
-				SDL_GetVideoSurface()->format->BitsPerPixel);
+				SDL_GetVideoSurface()->format->BitsPerPixel, resolutionFactor);
 
 		log_add (log_Info, "OpenGL renderer: %s version: %s",
 				glGetString (GL_RENDERER), glGetString (GL_VERSION));
+
+		// JMS: Now, this makes the game center horizontally
+		// between the black bars on the sides.
+		ScreenWidthActual = SDL_GetVideoSurface()->w;
 	}
 	return 0;
 }
 
 int
-TFB_GL_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen)
+TFB_GL_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen, unsigned int resolutionFactor)
 {
 	int i, texture_width, texture_height;
 	GraphicsDriver = driver;
 
-	if (AttemptColorDepth (flags, width, height, 32) &&
-			AttemptColorDepth (flags, width, height, 24) &&
-			AttemptColorDepth (flags, width, height, 16))
+	if (AttemptColorDepth (flags, width, height, 32, resolutionFactor) &&
+			AttemptColorDepth (flags, width, height, 24, resolutionFactor) &&
+			AttemptColorDepth (flags, width, height, 16, resolutionFactor))
 	{
 		log_add (log_Error, "Couldn't set any OpenGL %ix%i video mode!",
 			 width, height);
@@ -209,11 +250,26 @@ TFB_GL_ConfigureVideo (int driver, int f
 	}
 	else
 	{
-		texture_width = 512;
-		texture_height = 256;
+		if (resolutionFactor == 0)
+		{
+			texture_width = 512;
+			texture_height = 256;
+			graphics_backend = &opengl_unscaled_backend;
+		}
+		else if (resolutionFactor == 1)
+		{
+			texture_width = 1024;
+			texture_height = 512;
+			graphics_backend = &opengl_unscaled_backend_2x;
+		}
+		else if (resolutionFactor == 2)
+		{
+			texture_width = 2048;
+			texture_height = 1024;
+			graphics_backend = &opengl_unscaled_backend_4x;
+		}
 
 		scaler = NULL;
-		graphics_backend = &opengl_unscaled_backend;
 	}
 
 
@@ -247,7 +303,7 @@ TFB_GL_ConfigureVideo (int driver, int f
 }
 
 int
-TFB_GL_InitGraphics (int driver, int flags, int width, int height)
+TFB_GL_InitGraphics (int driver, int flags, int width, int height, unsigned int resolutionFactor)
 {
 	char VideoName[256];
 
@@ -258,10 +314,10 @@ TFB_GL_InitGraphics (int driver, int fla
 	log_add (log_Info, "SDL initialized.");
 	log_add (log_Info, "Initializing Screen.");
 
-	ScreenWidth = 320;
-	ScreenHeight = 240;
+	ScreenWidth = (320 << resolutionFactor); // JMS_GFX
+	ScreenHeight = (240 << resolutionFactor); // JMS_GFX
 
-	if (TFB_GL_ConfigureVideo (driver, flags, width, height, 0))
+	if (TFB_GL_ConfigureVideo (driver, flags, width, height, 0, resolutionFactor))
 	{
 		log_add (log_Fatal, "Could not initialize video: "
 				"no fallback at start of program!");
@@ -405,6 +461,172 @@ TFB_GL_DrawQuad (SDL_Rect *r)
 }
 
 static void
+TFB_GL_DrawQuad_2x (SDL_Rect *r)
+{
+	BOOLEAN keep_aspect_ratio = optKeepAspectRatio;
+	int x1 = 0, y1 = 0, x2 = ScreenWidthActual, y2 = ScreenHeightActual;
+	int sx = 0, sy = 0;
+	int sw, sh;
+	float sx_multiplier = 1;
+	float sy_multiplier = 1;
+	
+	if (keep_aspect_ratio)
+	{
+		float threshold = 0.75f;
+		float ratio = ScreenHeightActual / (float)ScreenWidthActual;
+		
+		if (ratio > threshold)
+		{
+			// screen is narrower than 4:3
+			int height = (int)(ScreenWidthActual * threshold);
+			y1 = (ScreenHeightActual - height) / 2;
+			y2 = ScreenHeightActual - y1;
+			
+			if (r != NULL)
+			{
+				sx_multiplier = ScreenWidthActual / (float)ScreenWidth;
+				sy_multiplier = height / (float)ScreenHeight;
+				sx = (int)(r->x * sx_multiplier);
+				sy = (int)(((ScreenHeight - (r->y + r->h)) * sy_multiplier) + y1);
+			}
+		}
+		else if (ratio < threshold)
+		{
+			// screen is wider than 4:3
+			int width = (int)(ScreenHeightActual / threshold);
+			x1 = (ScreenWidthActual - width) / 2;
+			x2 = ScreenWidthActual - x1;
+			
+			if (r != NULL)
+			{
+				sx_multiplier = width / (float)ScreenWidth;
+				sy_multiplier = ScreenHeightActual / (float)ScreenHeight;
+				sx = (int)((r->x * sx_multiplier) + x1);
+				sy = (int)((ScreenHeight - (r->y + r->h)) * sy_multiplier);
+			}
+		}
+		else
+		{
+			// screen is 4:3
+			keep_aspect_ratio = 0;
+		}
+	}
+	
+	if (r != NULL)
+	{
+		if (!keep_aspect_ratio)
+		{
+			sx_multiplier = ScreenWidthActual / (float)ScreenWidth;
+			sy_multiplier = ScreenHeightActual / (float)ScreenHeight;
+			sx = (int)(r->x * sx_multiplier);
+			sy = (int)((ScreenHeight - (r->y + r->h)) * sy_multiplier);
+		}
+		sw = (int)(r->w * sx_multiplier);
+		sh = (int)(r->h * sy_multiplier);
+		glScissor (sx, sy, sw, sh);
+		glEnable (GL_SCISSOR_TEST);
+	}
+	
+	glBegin (GL_TRIANGLE_FAN);
+	glTexCoord2f (0, 0);
+	glVertex2i (x1, y1);
+	glTexCoord2f (ScreenWidth / 1024.0f, 0);
+	glVertex2i (x2, y1);	
+	glTexCoord2f (ScreenWidth / 1024.0f, ScreenHeight / 512.0f);
+	glVertex2i (x2, y2);
+	glTexCoord2f (0, ScreenHeight / 512.0f);
+	glVertex2i (x1, y2);
+	glEnd ();
+	if (r != NULL)
+	{
+		glDisable (GL_SCISSOR_TEST);
+	}
+}
+
+static void
+TFB_GL_DrawQuad_4x (SDL_Rect *r)
+{
+	BOOLEAN keep_aspect_ratio = optKeepAspectRatio;
+	int x1 = 0, y1 = 0, x2 = ScreenWidthActual, y2 = ScreenHeightActual;
+	int sx = 0, sy = 0;
+	int sw, sh;
+	float sx_multiplier = 1;
+	float sy_multiplier = 1;
+	
+	if (keep_aspect_ratio)
+	{
+		float threshold = 0.75f;
+		float ratio = ScreenHeightActual / (float)ScreenWidthActual;
+		
+		if (ratio > threshold)
+		{
+			// screen is narrower than 4:3
+			int height = (int)(ScreenWidthActual * threshold);
+			y1 = (ScreenHeightActual - height) / 2;
+			y2 = ScreenHeightActual - y1;
+			
+			if (r != NULL)
+			{
+				sx_multiplier = ScreenWidthActual / (float)ScreenWidth;
+				sy_multiplier = height / (float)ScreenHeight;
+				sx = (int)(r->x * sx_multiplier);
+				sy = (int)(((ScreenHeight - (r->y + r->h)) * sy_multiplier) + y1);
+			}
+		}
+		else if (ratio < threshold)
+		{
+			// screen is wider than 4:3
+			int width = (int)(ScreenHeightActual / threshold);
+			x1 = (ScreenWidthActual - width) / 2;
+			x2 = ScreenWidthActual - x1;
+			
+			if (r != NULL)
+			{
+				sx_multiplier = width / (float)ScreenWidth;
+				sy_multiplier = ScreenHeightActual / (float)ScreenHeight;
+				sx = (int)((r->x * sx_multiplier) + x1);
+				sy = (int)((ScreenHeight - (r->y + r->h)) * sy_multiplier);
+			}
+		}
+		else
+		{
+			// screen is 4:3
+			keep_aspect_ratio = 0;
+		}
+	}
+	
+	if (r != NULL)
+	{
+		if (!keep_aspect_ratio)
+		{
+			sx_multiplier = ScreenWidthActual / (float)ScreenWidth;
+			sy_multiplier = ScreenHeightActual / (float)ScreenHeight;
+			sx = (int)(r->x * sx_multiplier);
+			sy = (int)((ScreenHeight - (r->y + r->h)) * sy_multiplier);
+		}
+		sw = (int)(r->w * sx_multiplier);
+		sh = (int)(r->h * sy_multiplier);
+		glScissor (sx, sy, sw, sh);
+		glEnable (GL_SCISSOR_TEST);
+	}
+	
+	glBegin (GL_TRIANGLE_FAN);
+	glTexCoord2f (0, 0);
+	glVertex2i (x1, y1);
+	glTexCoord2f (ScreenWidth / 2048.0f, 0);
+	glVertex2i (x2, y1);	
+	glTexCoord2f (ScreenWidth / 2048.0f, ScreenHeight / 1024.0f);
+	glVertex2i (x2, y2);
+	glTexCoord2f (0, ScreenHeight / 1024.0f);
+	glVertex2i (x1, y2);
+	glEnd ();
+	if (r != NULL)
+	{
+		glDisable (GL_SCISSOR_TEST);
+	}
+}
+
+static void
 TFB_GL_Preprocess (int force_full_redraw, int transition_amount, int fade_amount)
 {
 	glMatrixMode (GL_PROJECTION);
@@ -484,6 +706,100 @@ TFB_GL_Unscaled_ScreenLayer (SCREEN scre
 }
 
 static void
+TFB_GL_Unscaled_ScreenLayer_2x (SCREEN screen, Uint8 a, SDL_Rect *rect)
+{
+	glBindTexture (GL_TEXTURE_2D, GL_Screens[screen].texture);
+	glTexEnvf (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+	
+	if (GL_Screens[screen].dirty)
+	{
+		int PitchWords = SDL_Screens[screen]->pitch / 4;
+		glPixelStorei (GL_UNPACK_ROW_LENGTH, PitchWords);
+		/* Matrox OpenGL drivers do not handle GL_UNPACK_SKIP_*
+		 correctly */
+		glPixelStorei (GL_UNPACK_SKIP_ROWS, 0);
+		glPixelStorei (GL_UNPACK_SKIP_PIXELS, 0);
+		SDL_LockSurface (SDL_Screens[screen]);
+		glTexSubImage2D (GL_TEXTURE_2D, 0, GL_Screens[screen].updated.x, 
+						 GL_Screens[screen].updated.y,
+						 GL_Screens[screen].updated.w, 
+						 GL_Screens[screen].updated.h,
+						 GL_RGBA, GL_UNSIGNED_BYTE,
+						 (Uint32 *)SDL_Screens[screen]->pixels +
+						 (GL_Screens[screen].updated.y * PitchWords + 
+						  GL_Screens[screen].updated.x));
+		SDL_UnlockSurface (SDL_Screens[screen]);
+		GL_Screens[screen].dirty = FALSE;
+	}
+	
+	glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, ScreenFilterMode);
+	glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, ScreenFilterMode);
+	glEnable (GL_TEXTURE_2D);
+	
+	if (a == 255)
+	{
+		glDisable (GL_BLEND);
+		glColor4f (1, 1, 1, 1);
+	}
+	else
+	{
+		float a_f = a / 255.0f;
+		glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+		glEnable (GL_BLEND);
+		glColor4f (1, 1, 1, a_f);
+	}
+	
+	TFB_GL_DrawQuad_2x (rect);
+}
+
+static void
+TFB_GL_Unscaled_ScreenLayer_4x (SCREEN screen, Uint8 a, SDL_Rect *rect)
+{
+	glBindTexture (GL_TEXTURE_2D, GL_Screens[screen].texture);
+	glTexEnvf (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+	
+	if (GL_Screens[screen].dirty)
+	{
+		int PitchWords = SDL_Screens[screen]->pitch / 4;
+		glPixelStorei (GL_UNPACK_ROW_LENGTH, PitchWords);
+		/* Matrox OpenGL drivers do not handle GL_UNPACK_SKIP_*
+		 correctly */
+		glPixelStorei (GL_UNPACK_SKIP_ROWS, 0);
+		glPixelStorei (GL_UNPACK_SKIP_PIXELS, 0);
+		SDL_LockSurface (SDL_Screens[screen]);
+		glTexSubImage2D (GL_TEXTURE_2D, 0, GL_Screens[screen].updated.x, 
+						 GL_Screens[screen].updated.y,
+						 GL_Screens[screen].updated.w, 
+						 GL_Screens[screen].updated.h,
+						 GL_RGBA, GL_UNSIGNED_BYTE,
+						 (Uint32 *)SDL_Screens[screen]->pixels +
+						 (GL_Screens[screen].updated.y * PitchWords + 
+						  GL_Screens[screen].updated.x));
+		SDL_UnlockSurface (SDL_Screens[screen]);
+		GL_Screens[screen].dirty = FALSE;
+	}
+	
+	glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, ScreenFilterMode);
+	glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, ScreenFilterMode);
+	glEnable (GL_TEXTURE_2D);
+	
+	if (a == 255)
+	{
+		glDisable (GL_BLEND);
+		glColor4f (1, 1, 1, 1);
+	}
+	else
+	{
+		float a_f = a / 255.0f;
+		glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+		glEnable (GL_BLEND);
+		glColor4f (1, 1, 1, a_f);
+	}
+	
+	TFB_GL_DrawQuad_4x (rect);
+}
+
+static void
 TFB_GL_Scaled_ScreenLayer (SCREEN screen, Uint8 a, SDL_Rect *rect)
 {
 	glBindTexture (GL_TEXTURE_2D, GL_Screens[screen].texture);
diff -ruNp src.mm/libs/graphics/sdl/opengl.h src/libs/graphics/sdl/opengl.h
--- src.mm/libs/graphics/sdl/opengl.h	2017-11-28 11:08:36 -0600
+++ src/libs/graphics/sdl/opengl.h	2017-11-28 11:09:23 -0600
@@ -21,9 +21,9 @@
 
 #include "libs/graphics/sdl/sdl_common.h"
 
-int TFB_GL_InitGraphics (int driver, int flags, int width, int height);
+int TFB_GL_InitGraphics (int driver, int flags, int width, int height, unsigned int resolutionFactor);
 void TFB_GL_UninitGraphics (void);
-int TFB_GL_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen);
+int TFB_GL_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen, unsigned int resolutionFactor);
 void TFB_GL_UploadTransitionScreen (void);
 
 #ifdef HAVE_OPENGL
diff -ruNp src.mm/libs/graphics/sdl/pure.c src/libs/graphics/sdl/pure.c
--- src.mm/libs/graphics/sdl/pure.c	2017-11-28 11:08:36 -0600
+++ src/libs/graphics/sdl/pure.c	2017-11-28 11:09:23 -0600
@@ -100,7 +100,7 @@ CalcAlphaFormat (const SDL_PixelFormat*
 }
 
 int
-TFB_Pure_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen)
+TFB_Pure_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen, unsigned int resolutionFactor)
 {
 	int i, videomode_flags;
 	SDL_PixelFormat conv_fmt;
@@ -119,13 +119,30 @@ TFB_Pure_ConfigureVideo (int driver, int
 	else
 	{
 		videomode_flags = SDL_SWSURFACE;
-		ScreenWidthActual = 640;
-		ScreenHeightActual = 480;
-		graphics_backend = &pure_scaled_backend;
-
-		if (width != 640 || height != 480)
-			log_add (log_Error, "Screen resolution of %dx%d not supported "
-					"under pure SDL, using 640x480", width, height);
+		
+		// JMS_GFX: Resolution is calculated with the help of a Resolution factor.
+		if (resolutionFactor == 0)
+		{
+			// Check the sanity of resolution.
+			if (width != 640 || height != 480)
+			{
+				log_add (log_Error, "Screen resolution of %dx%d not supported "
+						 "under pure SDL, using 640x480", width, height);
+			
+				width = 640;
+				height = 480;
+			}
+			
+			ScreenWidthActual  = width;
+			ScreenHeightActual = height;
+			graphics_backend = &pure_scaled_backend;
+		}
+		else
+		{
+			ScreenWidthActual  = (320 << resolutionFactor);
+			ScreenHeightActual = (240 << resolutionFactor);
+			graphics_backend = &pure_unscaled_backend;
+		}
 	}
 
 	videomode_flags |= SDL_ANYFORMAT;
@@ -231,7 +248,7 @@ TFB_Pure_ConfigureVideo (int driver, int
 }
 
 int
-TFB_Pure_InitGraphics (int driver, int flags, int width, int height)
+TFB_Pure_InitGraphics (int driver, int flags, int width, int height, unsigned int resolutionFactor)
 {
 	char VideoName[256];
 
@@ -247,10 +264,10 @@ TFB_Pure_InitGraphics (int driver, int f
 	log_add (log_Info, "SDL initialized.");
 	log_add (log_Info, "Initializing Screen.");
 
-	ScreenWidth = 320;
-	ScreenHeight = 240;
+	ScreenWidth = (320 << resolutionFactor); // 320
+	ScreenHeight = (240 << resolutionFactor); // 240
 
-	if (TFB_Pure_ConfigureVideo (driver, flags, width, height, 0))
+	if (TFB_Pure_ConfigureVideo (driver, flags, width, height, 0, resolutionFactor))
 	{
 		log_add (log_Fatal, "Could not initialize video: "
 				"no fallback at start of program!");
diff -ruNp src.mm/libs/graphics/sdl/pure.h src/libs/graphics/sdl/pure.h
--- src.mm/libs/graphics/sdl/pure.h	2017-11-28 11:08:36 -0600
+++ src/libs/graphics/sdl/pure.h	2017-11-28 11:09:23 -0600
@@ -21,9 +21,9 @@
 
 #include "libs/graphics/sdl/sdl_common.h"
 
-int TFB_Pure_InitGraphics (int driver, int flags, int width, int height);
+int TFB_Pure_InitGraphics (int driver, int flags, int width, int height, unsigned int resolutionFactor);
 void TFB_Pure_UninitGraphics (void);
-int TFB_Pure_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen);
+int TFB_Pure_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen, unsigned int resolutionFactor);
 void Scale_PerfTest (void);
 
 #endif
diff -ruNp src.mm/libs/graphics/sdl/sdl_common.c src/libs/graphics/sdl/sdl_common.c
--- src.mm/libs/graphics/sdl/sdl_common.c	2017-11-28 11:08:36 -0600
+++ src/libs/graphics/sdl/sdl_common.c	2017-11-28 11:09:23 -0600
@@ -43,6 +43,8 @@ SDL_Surface *SDL_Screens[TFB_GFX_NUMSCRE
 
 SDL_Surface *format_conv_surf = NULL;
 
+const SDL_VideoInfo *SDL_screen_info; // JMS_GFX
+
 static volatile BOOLEAN abortFlag = FALSE;
 
 int GfxFlags = 0;
@@ -89,7 +91,7 @@ TFB_PreQuit (void)
 }
 
 int
-TFB_ReInitGraphics (int driver, int flags, int width, int height)
+TFB_ReInitGraphics (int driver, int flags, int width, int height, unsigned int *resolutionFactor) // JMS_GFX: Added resolutionFactor
 {
 	int result;
 	int togglefullscreen = 0;
@@ -108,19 +110,19 @@ TFB_ReInitGraphics (int driver, int flag
 	{
 #ifdef HAVE_OPENGL
 		result = TFB_GL_ConfigureVideo (driver, flags, width, height,
-				togglefullscreen);
+				togglefullscreen, *resolutionFactor);
 #else
 		driver = TFB_GFXDRIVER_SDL_PURE;
 		log_add (log_Warning, "OpenGL support not compiled in,"
 				" so using pure SDL driver");
 		result = TFB_Pure_ConfigureVideo (driver, flags, width, height,
-				togglefullscreen);
+				togglefullscreen, resolutionFactor);
 #endif
 	}
 	else
 	{
 		result = TFB_Pure_ConfigureVideo (driver, flags, width, height,
-				togglefullscreen);
+				togglefullscreen, *resolutionFactor);
 	}
 
 	sprintf (caption, "The Ur-Quan Masters v%d.%d.%d%s",
@@ -137,27 +139,67 @@ TFB_ReInitGraphics (int driver, int flag
 }
 
 int
-TFB_InitGraphics (int driver, int flags, int width, int height)
+TFB_InitGraphics (int driver, int flags, int width, int height, unsigned int *resolutionFactor)
 {
-	int result;
+	int result, i;
 	char caption[200];
 
+	/* Null out screen pointers the first time */
+	for (i = 0; i < TFB_GFX_NUMSCREENS; i++)
+	{
+		SDL_Screens[i] = NULL;
+	}
+
 	GfxFlags = flags;
+	
+	// JMS_GFX: Let's read the size of the desktop so we can scale the
+	// fullscreen game according to it.
+	SDL_screen_info = SDL_GetVideoInfo ();
+	
+	// JMS_GFX: Upon starting the game, let's find out the resolution
+	// of the desktop.
+	if (fs_height == 0)
+	{
+		int curr_h = SDL_screen_info->current_h;
+		int curr_w = SDL_screen_info->current_w;
+		
+		// JMS_GFX: This makes it sure on certain HD 16:9 monitors
+		// that a bogus stretched 1600x1200 mode isn't used.
+		if ((curr_w == 1920 && curr_h == 1080) || (curr_h == (curr_w / 16) * 10)) { // MB: fix for 16:10 resolutions
+			fs_height = curr_h;
+			fs_width  = curr_w;
+		} else if (curr_h > (curr_w / 4) * 3) { // MB: for monitors using 5:4 modes
+			fs_width = curr_w;
+			fs_height = (curr_w / 4) * 3;
+		} else {
+			fs_height = curr_h;
+			fs_width  = (4 * fs_height) / 3;
+		}
+
+		// MB: Sanitising resolution factor:
+		if (fs_height <= 600 && *resolutionFactor == 2) { // ie. probably netbook or otherwise
+			*resolutionFactor = 1; // drop down to 640x480. netbook won't be able to handle anything higher and quality difference is minimal
+ 		} else if (fs_height <= 300 && resolutionFactor > 0) { // People who like pixels I guess
+			*resolutionFactor = 0; // drop down to 320x240
+		}
+		
+		log_add (log_Debug, "fs_height %u, fs_width %u, current_w %u", fs_height, fs_width, SDL_screen_info->current_w);
+	}
 
 	if (driver == TFB_GFXDRIVER_SDL_OPENGL)
 	{
 #ifdef HAVE_OPENGL
-		result = TFB_GL_InitGraphics (driver, flags, width, height);
+		result = TFB_GL_InitGraphics (driver, flags, width, height, *resolutionFactor);
 #else
 		driver = TFB_GFXDRIVER_SDL_PURE;
 		log_add (log_Warning, "OpenGL support not compiled in,"
 				" so using pure SDL driver");
-		result = TFB_Pure_InitGraphics (driver, flags, width, height);
+		result = TFB_Pure_InitGraphics (driver, flags, width, height, *resolutionFactor);
 #endif
 	}
 	else
 	{
-		result = TFB_Pure_InitGraphics (driver, flags, width, height);
+		result = TFB_Pure_InitGraphics (driver, flags, width, height, *resolutionFactor);
 	}
 
 	sprintf (caption, "The Ur-Quan Masters v%d.%d.%d%s", 
diff -ruNp src.mm/libs/graphics/sdl/sdl_common.h src/libs/graphics/sdl/sdl_common.h
--- src.mm/libs/graphics/sdl/sdl_common.h	2017-11-28 11:08:36 -0600
+++ src/libs/graphics/sdl/sdl_common.h	2017-11-28 11:09:23 -0600
@@ -46,6 +46,8 @@ extern SDL_Surface *SDL_Screens[TFB_GFX_
 
 extern SDL_Surface *format_conv_surf;
 
+extern const SDL_VideoInfo *SDL_screen_info; // JMS_GFX
+
 SDL_Surface* TFB_DisplayFormatAlpha (SDL_Surface *surface);
 
 SDL_Surface* Create_Screen (SDL_Surface *templat, int w, int h);
diff -ruNp src.mm/libs/graphics/tfb_draw.c src/libs/graphics/tfb_draw.c
--- src.mm/libs/graphics/tfb_draw.c	2017-11-28 11:08:36 -0600
+++ src/libs/graphics/tfb_draw.c	2017-11-28 11:09:23 -0600
@@ -154,6 +154,28 @@ TFB_DrawScreen_Copy (const RECT *r, SCRE
 	TFB_EnqueueDrawCommand (&DC);
 }
 
+// JMS_GFX: This ensures the whole screen area is updated in screen transition.
+// Useful at least in hires when landing at planet and transitioning to planetside view.
+// (The planet is cut uglily in about half when using normal TFB_DrawScreen_Copy).
+void
+TFB_DrawScreen_Copy_Fs (RECT *r, SCREEN src, SCREEN dest)
+{
+	RECT locRect;
+	TFB_DrawCommand DC;
+	
+	locRect.corner.x = locRect.corner.y = 0;
+	locRect.extent.width = ScreenWidth;
+	locRect.extent.height = ScreenHeight;
+	r = &locRect;
+	
+	DC.Type = TFB_DRAWCOMMANDTYPE_COPY;
+	DC.data.copy.rect = locRect;
+	DC.data.copy.srcBuffer = src;
+	DC.data.copy.destBuffer = dest;
+	
+	TFB_EnqueueDrawCommand (&DC);
+}
+
 void
 TFB_DrawScreen_SetMipmap (TFB_Image *img, TFB_Image *mmimg, int hotx, int hoty)
 {
diff -ruNp src.mm/libs/graphics/tfb_draw.h src/libs/graphics/tfb_draw.h
--- src.mm/libs/graphics/tfb_draw.h	2017-11-28 11:08:36 -0600
+++ src/libs/graphics/tfb_draw.h	2017-11-28 11:09:23 -0600
@@ -84,6 +84,7 @@ void TFB_DrawScreen_Rect (RECT *rect, Co
 void TFB_DrawScreen_Image (TFB_Image *img, int x, int y, int scale,
 		int scaleMode, TFB_ColorMap *, DrawMode, SCREEN dest);
 void TFB_DrawScreen_Copy (const RECT *r, SCREEN src, SCREEN dest);
+void TFB_DrawScreen_Copy_Fs (RECT *r, SCREEN src, SCREEN dest); // JMS_GFX
 void TFB_DrawScreen_FilledImage (TFB_Image *img, int x, int y, int scale,
 		int scaleMode, Color, DrawMode, SCREEN dest);
 void TFB_DrawScreen_FontChar (TFB_Char *, TFB_Image *backing, int x, int y,
diff -ruNp src.mm/libs/graphics/widgets.c src/libs/graphics/widgets.c
--- src.mm/libs/graphics/widgets.c	2017-11-28 11:08:36 -0600
+++ src/libs/graphics/widgets.c	2017-11-28 11:09:23 -0600
@@ -18,6 +18,7 @@
 #include "widgets.h"
 #include "libs/strlib.h"
 #include "uqm/colors.h"
+#include "uqm/units.h"
 
 WIDGET *widget_focus = NULL;
 
@@ -112,7 +113,7 @@ DrawLabelAsWindow (WIDGET_LABEL *label,
 			win_w = len;
 		}
 	}
-	win_w = (win_w * 6) + 16;
+	win_w = (win_w * (6 << RES_CASE(0,1,1))) + 16; // JMS_GFX
 
 	BatchGraphics ();
 	r.corner.x = (ScreenWidth - win_w) >> 1;
@@ -122,14 +123,14 @@ DrawLabelAsWindow (WIDGET_LABEL *label,
 	DrawShadowedBox (&r, win_bg_clr, win_dark_clr, win_medium_clr);
 
 	t.baseline.x = r.corner.x + (r.extent.width >> 1);
-	t.baseline.y = r.corner.y + 16;
+	t.baseline.y = r.corner.y + (16 << RES_CASE(0,0,1)); // JMS_GFX
 	for (i = 0; i < label->line_count; i++)
 	{
 		t.pStr = label->lines[i];
 		t.align = ALIGN_CENTER;
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
-		t.baseline.y += 8;
+		t.baseline.y += (8 << RESOLUTION_FACTOR); // JMS_GFX
 	}
 
 	UnbatchGraphics ();
@@ -143,10 +144,10 @@ DrawLabelAsWindow (WIDGET_LABEL *label,
 		// Add the outer border added by DrawShadowedBox.
 		// XXX: It may be nicer to add a border size parameter to
 		// DrawShadowedBox, instead of assuming 2 here.
-		windowRect->corner.x = r.corner.x - 2;
-		windowRect->corner.y = r.corner.y - 2;
-		windowRect->extent.width = r.extent.width + 4;
-		windowRect->extent.height = r.extent.height + 4;
+		windowRect->corner.x = r.corner.x - 2 * (1 + RESOLUTION_FACTOR);
+		windowRect->corner.y = r.corner.y - 2 * (1 + RESOLUTION_FACTOR);
+		windowRect->extent.width = r.extent.width + 4 * (1 + RESOLUTION_FACTOR);
+		windowRect->extent.height = r.extent.height + 4 * (1 + RESOLUTION_FACTOR);
 	}
 }
 
@@ -169,6 +170,8 @@ Widget_SetFont (FONT newFont)
 static void
 Widget_DrawToolTips (int numlines, const char **tips)
 {
+	// This functions draws the text at the bottom of the screen
+	// which explains what the current option does.
 	RECT r;
 	FONT  oldfont = 0;
 	FRAME oldFontEffect = SetContextFontEffect (NULL);
@@ -179,21 +182,21 @@ Widget_DrawToolTips (int numlines, const
 	if (cur_font)
 		oldfont = SetContextFont (cur_font);
 
-	r.corner.x = 2;
-	r.corner.y = 2;
-	r.extent.width = ScreenWidth - 4;
-	r.extent.height = ScreenHeight + 2; // was '- 4'
+	r.corner.x = 2 << RESOLUTION_FACTOR; // JMS_GFX
+	r.corner.y = 2 << RESOLUTION_FACTOR; // JMS_GFX
+	r.extent.width = ScreenWidth - (4 << RESOLUTION_FACTOR); // JMS_GFX
+	r.extent.height = ScreenHeight + (2 << RESOLUTION_FACTOR); // JMS_GFX
 
 	t.align = ALIGN_CENTER;
 	t.CharCount = ~0;
 	t.baseline.x = r.corner.x + (r.extent.width >> 1);
-	t.baseline.y = r.corner.y + (r.extent.height - 8 - 8 * numlines);
+	t.baseline.y = r.corner.y + (r.extent.height - (8 << RESOLUTION_FACTOR) - (8 << RESOLUTION_FACTOR) * numlines); // JMS_GFX
 
 	for (i = 0; i < numlines; i++)
 	{
 		t.pStr = tips[i];
 		font_DrawText(&t);
-		t.baseline.y += 8;
+		t.baseline.y += (8 << RESOLUTION_FACTOR); // JMS_GFX
 	}
 
 	SetContextFontEffect (oldFontEffect);
@@ -218,10 +221,10 @@ Widget_DrawMenuScreen (WIDGET *_self, in
 	if (cur_font)
 		oldfont = SetContextFont (cur_font);
 	
-	r.corner.x = 2;
-	r.corner.y = 2;
-	r.extent.width = ScreenWidth - 4;
-	r.extent.height = ScreenHeight - 4;
+	r.corner.x = (2 << RESOLUTION_FACTOR) + 2 * RESOLUTION_FACTOR; // JMS_GFX
+	r.corner.y = (2 << RESOLUTION_FACTOR); // JMS_GFX
+	r.extent.width = ScreenWidth - (4 << RESOLUTION_FACTOR); // JMS_GFX
+	r.extent.height = ScreenHeight - (4 << RESOLUTION_FACTOR); // JMS_GFX
 	
 	title = WIDGET_INACTIVE_SELECTED_COLOR;
 	selected = WIDGET_ACTIVE_COLOR;
@@ -232,12 +235,12 @@ Widget_DrawMenuScreen (WIDGET *_self, in
 	
 	oldtext = SetContextForeGroundColor (title);
 	t.baseline.x = r.corner.x + (r.extent.width >> 1);
-	t.baseline.y = r.corner.y + 8;
+	t.baseline.y = r.corner.y + (8 << RESOLUTION_FACTOR); // JMS_GFX
 	t.pStr = self->title;
 	t.align = ALIGN_CENTER;
 	t.CharCount = ~0;
 	font_DrawText (&t);
-	t.baseline.y += 8;
+	t.baseline.y += 8 << RESOLUTION_FACTOR; // JMS_GFX
 	t.pStr = self->subtitle;
 	font_DrawText (&t);
 
@@ -246,17 +249,17 @@ Widget_DrawMenuScreen (WIDGET *_self, in
 	{
 		WIDGET *child = self->child[widget_index];
 		height += (*child->height)(child);
-		height += 8;  /* spacing */
+		height += 8 << RESOLUTION_FACTOR; // JMS_GFX  /* spacing */
 	}
 
-	height -= 8;
+	height -= 8 << RESOLUTION_FACTOR; // JMS_GFX
 
 	widget_y = (ScreenHeight - height) >> 1;
 	for (widget_index = 0; widget_index < self->num_children; widget_index++)
 	{
 		WIDGET *c = self->child[widget_index];
 		(*c->draw)(c, 0, widget_y);
-		widget_y += (*c->height)(c) + 8;
+		widget_y += (*c->height)(c) + (8 << RESOLUTION_FACTOR); // JMS_GFX
 	}
 	
 	SetContextFontEffect (oldFontEffect);
@@ -287,7 +290,7 @@ Widget_DrawChoice (WIDGET *_self, int x,
 	disabled = DKGRAY_COLOR;
 	selected = WIDGET_ACTIVE_COLOR;
 
-	t.baseline.x = 2; // Was 'x'.
+	t.baseline.x = 2 << RESOLUTION_FACTOR; // Was 'x'.
 	t.baseline.y = y;
 	t.align = ALIGN_LEFT;
 	t.CharCount = ~0;
@@ -302,6 +305,7 @@ Widget_DrawChoice (WIDGET *_self, int x,
 	}
 	font_DrawText (&t);
 
+	t.baseline.x -= 64 * RESOLUTION_FACTOR; // JMS_GFX
 	home_x = t.baseline.x + 3 * (ScreenWidth / ((self->maxcolumns + 1) * 2));
 	home_y = t.baseline.y;
 	t.align = ALIGN_CENTER;
@@ -309,7 +313,7 @@ Widget_DrawChoice (WIDGET *_self, int x,
 	{
 		t.baseline.x = home_x + ((i % 3) *
 				(ScreenWidth / (self->maxcolumns + 1)));
-		t.baseline.y = home_y + (10 * (i / 3)); // Was 8*(i/3): Changed for readability
+		t.baseline.y = home_y + ((10 * (i / 3)) << RESOLUTION_FACTOR); // JMS_GFX // Was 8*(i/3): Changed for readability
 		t.pStr = self->options[i].optname;
 		if ((widget_focus == _self) &&
 		    (self->highlighted == i))
@@ -349,7 +353,7 @@ Widget_DrawButton (WIDGET *_self, int x,
 	selected = WIDGET_ACTIVE_COLOR;
 	inactive = WIDGET_INACTIVE_COLOR;
 
-	t.baseline.x = 160;
+	t.baseline.x = 160 << RESOLUTION_FACTOR; // JMS_GFX
 	t.baseline.y = y;
 	t.align = ALIGN_CENTER;
 	t.CharCount = ~0;
@@ -384,7 +388,7 @@ Widget_DrawLabel (WIDGET *_self, int x,
 	if (cur_font)
 		oldfont = SetContextFont (cur_font);
 	
-	t.baseline.x = 160;
+	t.baseline.x = 160 << RESOLUTION_FACTOR; // JMS_GFX
 	t.baseline.y = y;
 	t.align = ALIGN_CENTER;
 	t.CharCount = ~0;
@@ -393,7 +397,7 @@ Widget_DrawLabel (WIDGET *_self, int x,
 	{
 		t.pStr = self->lines[i];
 		font_DrawText (&t);
-		t.baseline.y += 8;
+		t.baseline.y += (8 << RESOLUTION_FACTOR); // JMS_GFX
 	}
 	SetContextFontEffect (oldFontEffect);
 	if (oldfont)
@@ -421,7 +425,7 @@ Widget_DrawSlider(WIDGET *_self, int x,
 	selected = WIDGET_ACTIVE_COLOR;
 	inactive = WIDGET_INACTIVE_COLOR;
 
-	t.baseline.x = 2; // Was 'x'.
+	t.baseline.x = 2 << RESOLUTION_FACTOR; // + (64 * RESOLUTION_FACTOR); // JMS_GFX; // 2 was 'x'.
 	t.baseline.y = y;
 	t.align = ALIGN_LEFT;
 	t.CharCount = ~0;
@@ -437,6 +441,8 @@ Widget_DrawSlider(WIDGET *_self, int x,
 	}
 	font_DrawText (&t);
 
+	// t.baseline.x -= 64 * RESOLUTION_FACTOR; // JMS_GFX;
+
 	r.corner.x = t.baseline.x + 3 * tick;
 	r.corner.y = t.baseline.y - 4;
 	r.extent.height = 2;
@@ -494,7 +500,7 @@ Widget_DrawTextEntry (WIDGET *_self, int
 
 	BatchGraphics ();
 
-	t.baseline.x = 2; // Was 'x'.
+	t.baseline.x = 2 + (64 * RESOLUTION_FACTOR); // JMS_GFX // 2 was 'x'.
 	t.baseline.y = y;
 	t.align = ALIGN_LEFT;
 	t.CharCount = ~0;
@@ -509,6 +515,8 @@ Widget_DrawTextEntry (WIDGET *_self, int
 	}
 	font_DrawText (&t);
 
+	t.baseline.x -= 64 * RESOLUTION_FACTOR; // JMS_GFX
+
 	/* Force string termination */
 	self->value[WIDGET_TEXTENTRY_WIDTH-1] = 0;
 
@@ -518,7 +526,7 @@ Widget_DrawTextEntry (WIDGET *_self, int
 
 	if (!(self->state & WTE_EDITING))
 	{	// normal or selected state
-		t.baseline.x = 160;
+		t.baseline.x = 160 << RESOLUTION_FACTOR; // JMS_GFX
 		t.align = ALIGN_CENTER;
 
 		if (widget_focus == _self)
@@ -540,7 +548,7 @@ Widget_DrawTextEntry (WIDGET *_self, int
 		RECT r;
 		SIZE leading;
 
-		t.baseline.x = 90;
+		t.baseline.x = 90 << RESOLUTION_FACTOR; // JMS_GFX
 		t.align = ALIGN_LEFT;
 
 		// calc background box dimensions
@@ -630,7 +638,7 @@ Widget_DrawControlEntry (WIDGET *_self,
 	selected = WIDGET_ACTIVE_COLOR;
 	inactive = WIDGET_INACTIVE_COLOR;
 
-	t.baseline.x = 2; // Was 'x'.
+	t.baseline.x = 2 + (64 * RESOLUTION_FACTOR); // JMS_GFX // 2 was 'x'.
 	t.baseline.y = y;
 	t.align = ALIGN_LEFT;
 	t.CharCount = ~0;
@@ -645,6 +653,8 @@ Widget_DrawControlEntry (WIDGET *_self,
 	}
 	font_DrawText (&t);
 
+	t.baseline.x -= 64 * RESOLUTION_FACTOR; // JMS_GFX
+
         // 3 * ScreenWidth / ((self->maxcolumns + 1) * 2)) as per CHOICE, but only two options.
 	home_x = t.baseline.x + (ScreenWidth / 2); 
 	home_y = t.baseline.y;
@@ -652,7 +662,7 @@ Widget_DrawControlEntry (WIDGET *_self,
 	for (i = 0; i < 2; i++)
 	{
 		t.baseline.x = home_x + ((i % 3) * (ScreenWidth / 3));  // self->maxcolumns + 1 as per CHOICE.
-		t.baseline.y = home_y + (8 * (i / 3));
+		t.baseline.y = home_y + ((8 * (i / 3)) << RESOLUTION_FACTOR); // JMS_GFX;
 		t.pStr = self->controlname[i];
 		if (!t.pStr[0])
 		{
@@ -678,7 +688,7 @@ Widget_DrawControlEntry (WIDGET *_self,
 int
 Widget_HeightChoice (WIDGET *_self)
 {
-	return ((((WIDGET_CHOICE *)_self)->numopts + 2) / 3) * 8;
+	return ((((WIDGET_CHOICE *)_self)->numopts + 2) / 3) * (8 << RESOLUTION_FACTOR); // JMS_GFX;
 }
 
 int
@@ -692,7 +702,7 @@ int
 Widget_HeightOneLine (WIDGET *_self)
 {
 	(void)_self;
-	return 8;
+	return (8 << RESOLUTION_FACTOR); // JMS_GFX
 }
 
 int
diff -ruNp src.mm/libs/video/vidplayer.c src/libs/video/vidplayer.c
--- src.mm/libs/video/vidplayer.c	2017-11-28 11:08:44 -0600
+++ src/libs/video/vidplayer.c	2017-11-28 11:09:30 -0600
@@ -232,6 +232,15 @@ TFB_PlayVideo (VIDEO_REF vid, uint32 x,
 		return false; // drawing outside visible
 
 	sr = dr;
+    // JMS_GFX: Added this if-clause around the following lines to make the
+    // 3DO videos work also in 1280x960. They're still small though.
+    if (resolutionFactor < 2) {
+        sr.corner.x = -sr.corner.x;
+        sr.corner.y = -sr.corner.y;
+        if (!BoxIntersect (&clip_r, &sr, &sr))
+            return false; // drawing outside visible
+    }
+
 	sr.corner.x = -sr.corner.x;
 	sr.corner.y = -sr.corner.y;
 	if (!BoxIntersect (&clip_r, &sr, &sr))
diff -ruNp src.mm/options.c src/options.c
--- src.mm/options.c	2017-11-28 11:08:44 -0600
+++ src/options.c	2017-11-28 11:09:30 -0600
@@ -52,6 +52,12 @@ int optSmoothScroll;
 int optMeleeScale;
 const char **optAddons;
 
+// JMS_GFX
+unsigned int loresBlowupScale;
+unsigned int resolutionFactor;
+BOOLEAN forceAspectRatio;
+BOOLEAN resFactorWasChanged;
+
 BOOLEAN optCheatMode; // JMS
 // Serosis
 BOOLEAN optGodMode;
diff -ruNp src.mm/options.h src/options.h
--- src.mm/options.h	2017-11-28 11:08:44 -0600
+++ src/options.h	2017-11-28 11:09:30 -0600
@@ -42,6 +42,12 @@ extern int optWhichShield;
 extern int optSmoothScroll;
 extern int optMeleeScale;
 
+// JMS_GFX
+extern unsigned int loresBlowupScale;
+extern unsigned int resolutionFactor;
+extern BOOLEAN forceAspectRatio;
+extern BOOLEAN resFactorWasChanged;
+
 extern BOOLEAN optCheatMode; // JMS
 // Serosis
 extern BOOLEAN optGodMode;
Files src.mm/res/kohr-ah1.ico and src/res/kohr-ah1.ico differ
diff -ruNp src.mm/uqm/border.c src/uqm/border.c
--- src.mm/uqm/border.c	2017-11-28 11:08:44 -0600
+++ src/uqm/border.c	2017-11-28 11:09:31 -0600
@@ -52,29 +52,35 @@ DrawSISFrame (void)
 
 	BatchGraphics ();
 	{
+		// Middle grey rectangles around space window.
 		SetContextForeGroundColor (
 				BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
+			//
 		r.corner.x = 0;
 		r.corner.y = 0;
 		r.extent.width = SIS_ORG_X + SIS_SCREEN_WIDTH + 1;
 		r.extent.height = SIS_ORG_Y - 1;
 		DrawFilledRectangle (&r);
+			//
 		r.corner.x = 0;
 		r.corner.y = 0;
 		r.extent.width = SIS_ORG_X - 1;
 		r.extent.height = SIS_ORG_Y + SIS_SCREEN_HEIGHT + 1;
 		DrawFilledRectangle (&r);
+			//
 		r.corner.x = 0;
 		r.corner.y = r.extent.height;
 		r.extent.width = SIS_ORG_X + SIS_SCREEN_WIDTH + 1;
 		r.extent.height = SCREEN_HEIGHT - SIS_ORG_Y + SIS_SCREEN_HEIGHT;
 		DrawFilledRectangle (&r);
+			//
 		r.corner.x = SIS_ORG_X + SIS_SCREEN_WIDTH + 1;
 		r.corner.y = 0;
 		r.extent.width = SCREEN_WIDTH - r.corner.x;
 		r.extent.height = SCREEN_HEIGHT;
 		DrawFilledRectangle (&r);
-
+		
+		// Light and dark grey edges of the inner space window.
 		r.corner.x = SIS_ORG_X - 1;
 		r.corner.y = SIS_ORG_Y - 1;
 		r.extent.width = SIS_SCREEN_WIDTH + 2;
@@ -84,9 +90,9 @@ DrawSISFrame (void)
 				BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F),
 				TRUE, BLACK_COLOR);
 
+		// The big Blue box in the upper edge of screen containing the star system name.
 		r.corner.y = 0;
 		r.extent.height = SIS_ORG_Y;
-
 		r.corner.x = SIS_ORG_X;
 		r.extent.width = SIS_MESSAGE_BOX_WIDTH;
 		DrawStarConBox (&r, 1,
@@ -94,6 +100,7 @@ DrawSISFrame (void)
 				BUILD_COLOR (MAKE_RGB15 (0x00, 0x01, 0x1C), 0x4E),
 				TRUE, BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01));
 
+		// The smaller blue box.
 		r.extent.width = SIS_TITLE_BOX_WIDTH;
 		r.corner.x = SIS_ORG_X + SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH;
 		DrawStarConBox (&r, 1,
@@ -101,18 +108,22 @@ DrawSISFrame (void)
 				BUILD_COLOR (MAKE_RGB15 (0x00, 0x01, 0x1C), 0x4E),
 				TRUE, BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01));
 
+		// Black border between menu area and space window area
 		SetContextForeGroundColor (BLACK_COLOR);
 		r.corner.x = SAFE_X + SPACE_WIDTH - 1;
 		r.corner.y = 0;
-		r.extent.width = 1;
+		r.extent.width = 1; // JMS_GFX
 		r.extent.height = SCREEN_HEIGHT;
 		DrawFilledRectangle (&r);
+		
 		r.corner.x = SAFE_X + SPACE_WIDTH;
-		r.corner.y = SAFE_Y + 139;
+		r.corner.y = SAFE_Y + RES_STAT_SCALE(139); // JMS_GFX
 		DrawPoint (&r.corner);
-		r.corner.x = SCREEN_WIDTH - 1;
+		
+		r.corner.x = SCREEN_WIDTH - 1; // JMS_GFX
 		DrawPoint (&r.corner);
 
+		// Light grey border on the left side of big blue box.
 		SetContextForeGroundColor (
 				BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
 		r.corner.y = 1;
@@ -120,73 +131,93 @@ DrawSISFrame (void)
 		r.extent.height = SAFE_Y + SIS_TITLE_HEIGHT;
 		r.corner.x = SIS_ORG_X - 1;
 		DrawFilledRectangle (&r);
+		
+		// The same for small blue box
 		r.corner.x = SIS_ORG_X + SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH - 1;
 		DrawFilledRectangle (&r);
 
+		// Light grey horizontal line at the bottom of the screen, space window side
 		r.corner.x = 0;
 		r.corner.y = SCREEN_HEIGHT - 1;
 		r.extent.width = SAFE_X + SPACE_WIDTH - 1;
 		r.extent.height = 1;
 		DrawFilledRectangle (&r);
+		
+		// Light grey vertical line at the right side of space window
 		r.corner.x = SAFE_X + SPACE_WIDTH - 2;
 		r.corner.y = 0;
 		r.extent.width = 1;
 		r.extent.height = SCREEN_HEIGHT - 1;
 		DrawFilledRectangle (&r);
+		
+		// Vertical line at the right side of the menu window, upper part
 		r.corner.x = SCREEN_WIDTH - 1;
 		r.corner.y = 0;
 		r.extent.width = 1;
-		r.extent.height = SAFE_Y + 139;
+		r.extent.height = SAFE_Y + RES_STAT_SCALE(139); // JMS_GFX
 		DrawFilledRectangle (&r);
+		
+		// Horizontal line at the bottom of the screen, menu window side
 		r.corner.x = SAFE_X + SPACE_WIDTH;
 		r.corner.y = SCREEN_HEIGHT - 1;
 		r.extent.width = SCREEN_WIDTH - r.corner.x;
 		r.extent.height = 1;
 		DrawFilledRectangle (&r);
+		
+		// Vertical line at the right side of the menu window, lower part
 		r.corner.x = SCREEN_WIDTH - 1;
-		r.corner.y = SAFE_Y + 140;
+		r.corner.y = SAFE_Y + RES_STAT_SCALE(139) + RES_CASE(1,0,0);
 		r.extent.width = 1;
 		r.extent.height = (SCREEN_HEIGHT - 1) - r.corner.y;
 		DrawFilledRectangle (&r);
 
+		// Dark grey border around blue boxes.
 		SetContextForeGroundColor (
 				BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
-		r.corner.y = 1;
+		// Vertical line on the right side of the big blue box
+		r.corner.y = 0; // JMS_GFX
 		r.extent.width = 1;
 		r.extent.height = SAFE_Y + SIS_MESSAGE_HEIGHT;
 		r.corner.x = SIS_ORG_X + SIS_MESSAGE_BOX_WIDTH;
 		DrawFilledRectangle (&r);
+		// Vertical line on the right side of the small blue box
 		r.corner.x = SIS_ORG_X + SIS_SCREEN_WIDTH;
 		++r.extent.height;
 		DrawFilledRectangle (&r);
+		//
 		r.corner.y = 0;
 		r.extent.width = (SAFE_X + SPACE_WIDTH - 2) - r.corner.x;
 		r.extent.height = 1;
 		DrawFilledRectangle (&r);
+		//
 		r.corner.x = 0;
 		r.extent.width = SIS_ORG_X - r.corner.x;
 		DrawFilledRectangle (&r);
+		// Horizontal line between boxes
 		r.corner.x = SIS_ORG_X + SIS_MESSAGE_BOX_WIDTH;
 		r.extent.width = SIS_SPACER_BOX_WIDTH;
 		DrawFilledRectangle (&r);
-
+		//
 		r.corner.x = 0;
 		r.corner.y = 1;
 		r.extent.width = 1;
 		r.extent.height = (SCREEN_HEIGHT - 1) - r.corner.y;
 		DrawFilledRectangle (&r);
+		//
 		r.corner.x = SAFE_X + SPACE_WIDTH;
 		r.corner.y = 0;
 		r.extent.width = 1;
-		r.extent.height = SAFE_Y + 139;
+		r.extent.height = SAFE_Y + RES_STAT_SCALE(139); // JMS_GFX 
 		DrawFilledRectangle (&r);
+		//
 		r.corner.x = SAFE_X + SPACE_WIDTH + 1;
-		r.corner.y = SAFE_Y + 139;
+		r.corner.y = SAFE_Y + RES_STAT_SCALE(139); // JMS_GFX
 		r.extent.width = STATUS_WIDTH - 2;
 		r.extent.height = 1;
 		DrawFilledRectangle (&r);
+		//
 		r.corner.x = SAFE_X + SPACE_WIDTH;
-		r.corner.y = SAFE_Y + 140;
+		r.corner.y = SAFE_Y + RES_STAT_SCALE(140); // JMS_GFX
 		r.extent.width = 1;
 		r.extent.height = SCREEN_HEIGHT - r.corner.y;
 		DrawFilledRectangle (&r);
diff -ruNp src.mm/uqm/cleanup.c src/uqm/cleanup.c
--- src.mm/uqm/cleanup.c	2017-11-28 11:08:44 -0600
+++ src/uqm/cleanup.c	2017-11-28 11:09:31 -0600
@@ -69,6 +69,7 @@ UninitKernel (void)
 	DestroyDrawable (ReleaseDrawable (SubmenuFrame)); // JMS
 	DestroyDrawable (ReleaseDrawable (ConstellationsFrame)); // JMS
 	DestroyDrawable (ReleaseDrawable (NebulaeFrame));	// JMS
+	DestroyDrawable (ReleaseDrawable (hyperspacesuns));	// JMS
 	DestroyDrawable (ReleaseDrawable (ActivityFrame));
 	DestroyFont (TinyFont);
 	DestroyFont (StarConFont);
diff -ruNp src.mm/uqm/cnctdlg.c src/uqm/cnctdlg.c
--- src.mm/uqm/cnctdlg.c	2017-11-28 11:08:44 -0600
+++ src/uqm/cnctdlg.c	2017-11-28 11:09:31 -0600
@@ -29,8 +29,8 @@
 #include "libs/graphics/widgets.h"
 #include "supermelee/netplay/netoptions.h"
 
-#define MCD_WIDTH 260
-#define MCD_HEIGHT 110
+#define MCD_WIDTH (260 << RESOLUTION_FACTOR) // JMS_GFX
+#define MCD_HEIGHT (110 << RESOLUTION_FACTOR) // JMS_GFX
 
 #define MENU_FRAME_RATE (ONE_SECOND / 20)
 
@@ -80,12 +80,12 @@ MCD_DrawMenuScreen (WIDGET *_self, int x
 
 	WIDGET_MENU_SCREEN *self = (WIDGET_MENU_SCREEN *)_self;
 	
-	widget_y = y + 8;
+	widget_y = y + (8 << RESOLUTION_FACTOR); // JMS_GFX
 	for (widget_index = 0; widget_index < self->num_children; widget_index++)
 	{
 		WIDGET *c = self->child[widget_index];
 		(*c->draw)(c, x, widget_y);
-		widget_y += (*c->height)(c) + 8;
+		widget_y += (*c->height)(c) + (8 << RESOLUTION_FACTOR); // JMS_GFX
 	}
 }
 
@@ -102,7 +102,7 @@ MCD_DrawButton (WIDGET *_self, int x, in
 	selected = MENU_HIGHLIGHT_COLOR;
 	inactive = MENU_TEXT_COLOR;
 
-	t.baseline.x = 160;
+	t.baseline.x = 160 << RESOLUTION_FACTOR; // JMS_GFX
 	t.baseline.y = y;
 	t.align = ALIGN_CENTER;
 	t.CharCount = ~0;
@@ -212,7 +212,7 @@ MCD_DrawTextEntry (WIDGET *_self, int x,
 
 	if (!(self->state & WTE_EDITING))
 	{	// normal or selected state
-		t.baseline.x = 160;
+		t.baseline.x = 160 << RESOLUTION_FACTOR; // JMS_GFX
 		t.align = ALIGN_CENTER;
 
 		if (widget_focus == _self)
@@ -234,7 +234,7 @@ MCD_DrawTextEntry (WIDGET *_self, int x,
 		RECT r;
 		SIZE leading;
 
-		t.baseline.x = x + 90;
+		t.baseline.x = x + (90 << RESOLUTION_FACTOR); // JMS_GFX
 		t.align = ALIGN_LEFT;
 
 		// calc background box dimensions
diff -ruNp src.mm/uqm/colors.h src/uqm/colors.h
--- src.mm/uqm/colors.h	2017-11-28 11:08:45 -0600
+++ src/uqm/colors.h	2017-11-28 11:09:31 -0600
@@ -75,6 +75,13 @@
 #define BRIGHT_BLUE_COLOR \
 		BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x1F), 0x01)
 
+/* uqm-hd */
+#define BRIGHT_YELLOW_COLOR \
+		BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x00), 0x01)
+#define DULL_YELLOW_COLOR \
+		BUILD_COLOR (MAKE_RGB15 (0x0F, 0x0F, 0x00), 0x01)
+/* end uqm-hd */
+
 #define NORMAL_ILLUMINATED_COLOR \
 		WHITE_COLOR
 #define NORMAL_SHADOWED_COLOR \
diff -ruNp src.mm/uqm/comm/arilou/arilouc.c src/uqm/comm/arilou/arilouc.c
--- src.mm/uqm/comm/arilou/arilouc.c	2017-11-28 11:08:45 -0600
+++ src/uqm/comm/arilou/arilouc.c	2017-11-28 11:09:31 -0600
@@ -502,7 +502,9 @@ AngryHomeArilou (RESPONSE_REF R)
 	else if (PHRASE_ENABLED (what_about_interference))
 		Response (what_about_interference, AngryHomeArilou);
 	Response (ok_lets_be_friends, ArilouHome);
-	Response (i_just_like_to_leave, AngryHomeArilou);
+	if (PHRASE_ENABLED (i_just_like_to_leave)){
+		Response (i_just_like_to_leave, AngryHomeArilou);
+	}
 }
 
 static void
diff -ruNp src.mm/uqm/comm/chmmr/chmmrc.c src/uqm/comm/chmmr/chmmrc.c
--- src.mm/uqm/comm/chmmr/chmmrc.c	2017-11-28 11:08:45 -0600
+++ src/uqm/comm/chmmr/chmmrc.c	2017-11-28 11:09:31 -0600
@@ -24,6 +24,8 @@
 #include "uqm/build.h"
 #include "uqm/hyper.h"
 			// for SOL_X/SOL_Y
+#include "../../nameref.h"
+			// JMS_GFX: For LoadGraphic 
 
 
 static LOCDATA chmmr_desc =
@@ -180,8 +182,8 @@ ExitConversation (RESPONSE_REF R)
 
 			/* XXX : this should be unhardcoded eventually */
 			/* transport to Starbase */
-			GLOBAL (ShipStamp.origin.x) = STARBASE_INNER_X - SAFE_X;
-			GLOBAL (ShipStamp.origin.y) = STARBASE_INNER_Y - SAFE_Y;
+			GLOBAL (ShipStamp.origin.x) = SIS_SCREEN_WIDTH >> 1;
+			GLOBAL (ShipStamp.origin.y) = SIS_SCREEN_HEIGHT >> 1;
 		}
 		else
 		{	/* 'Beating Game Differently' mode - never visited Starbase,
@@ -560,6 +562,15 @@ Intro (void)
 			CommData.AlienColorMap = SetAbsColorMapIndex (
 					CommData.AlienColorMap, 1
 					);
+
+			// JMS_GFX: Use separate graphics in hires instead of colormap transform.
+			if (RESOLUTION_FACTOR > 0)
+			{
+				CommData.AlienFrameRes = CHMMR_RED_PMAP_ANIM;
+				CommData.AlienFrame = CaptureDrawable (
+					LoadGraphic (CommData.AlienFrameRes));
+			}
+
 			switch (NumVisits++)
 			{
 				case 0:
diff -ruNp src.mm/uqm/comm/chmmr/resinst.h src/uqm/comm/chmmr/resinst.h
--- src.mm/uqm/comm/chmmr/resinst.h	2017-11-28 11:08:45 -0600
+++ src/uqm/comm/chmmr/resinst.h	2017-11-28 11:09:31 -0600
@@ -7,4 +7,5 @@
 #define CHMMR_FONT "comm.chmmr.font"
 #define CHMMR_MUSIC "comm.chmmr.music"
 #define CHMMR_PMAP_ANIM "comm.chmmr.graphics"
+#define CHMMR_RED_PMAP_ANIM "comm.chmmr.red.graphics"
 #define CHMMR_SCRIPT "comm.chmmr.script"
diff -ruNp src.mm/uqm/comm/comandr/comandr.c src/uqm/comm/comandr/comandr.c
--- src.mm/uqm/comm/comandr/comandr.c	2017-11-28 11:08:45 -0600
+++ src/uqm/comm/comandr/comandr.c	2017-11-28 11:09:31 -0600
@@ -25,8 +25,9 @@
 		// for DeltaSISGauges(), DrawLanders()
 #include "libs/graphics/gfx_common.h"
 #include "uqm/lua/luacomm.h"
+#include "uqm/units.h" // JMS_GFX
 
-static LOCDATA commander_desc =
+static LOCDATA commander_desc_1x =
 {
 	COMMANDER_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
@@ -95,6 +96,75 @@ static LOCDATA commander_desc =
 	NULL,
 };
 
+static LOCDATA commander_desc_4x =
+{
+	COMMANDER_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	COMMANDER_PMAP_ANIM, /* AlienFrame */
+	COMMANDER_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_MIDDLE, /* AlienTextValign */
+	COMMANDER_COLOR_MAP, /* AlienColorMap */
+	COMMANDER_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	COMMANDER_CONVERSATION_PHRASES, /* PlayerPhrases */
+	3, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{ /* Blink */
+			1, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, 0, /* FrameRate */
+			0, ONE_SECOND * 8, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Running light */
+			10, /* StartIndex */
+			27, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 40, 0, /* FrameRate */
+			ONE_SECOND * 2, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Staticcy, noisy anim before radioactives arrive */
+			78, /* StartIndex */
+			6, /* NumFrames */
+			RANDOM_ANIM,/* AnimFlags */
+			0, ONE_SECOND / 5, /* FrameRate */
+			0, ONE_SECOND / 4, /* RestartRate */
+			0, /* BlockMask */
+		},
+	},
+	{ /* AlienTransitionDesc */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		4, /* StartIndex */
+		6, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 10, ONE_SECOND / 15, /* FrameRate */
+		ONE_SECOND * 7 / 60, ONE_SECOND / 12, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+};
+
 static void
 ByeBye (RESPONSE_REF R)
 {
@@ -219,7 +289,10 @@ NoRadioactives (RESPONSE_REF R)
 			NPCPhrase (WHAT_KIND_OF_IDIOT);
 		else if (PLAYER_SAID (R, i_lost_my_lander))
 		{
-			NPCPhrase (HERE_IS_A_NEW_LANDER);
+			if (GET_GAME_STATE (RADIOACTIVES_PROVIDED))
+				NPCPhrase (HERE_IS_A_NEW_LANDER_CLEAN);
+			else
+				NPCPhrase (HERE_IS_A_NEW_LANDER);
 			++GLOBAL_SIS (NumLanders);
 			DrawLanders ();
 			DeltaSISGauges (4, 0, 0);
@@ -228,7 +301,10 @@ NoRadioactives (RESPONSE_REF R)
 		}
 		else if (PLAYER_SAID (R, i_lost_another_lander))
 		{
-			NPCPhrase (HERE_IS_ANOTHER_LANDER);
+			if (GET_GAME_STATE (RADIOACTIVES_PROVIDED))
+				NPCPhrase (HERE_IS_ANOTHER_LANDER_CLEAN);
+			else
+				NPCPhrase (HERE_IS_ANOTHER_LANDER);
 			++GLOBAL_SIS (NumLanders);
 			DrawLanders ();
 			DeltaSISGauges (4, 0, 0);
@@ -281,7 +357,10 @@ AskAfterRadios (RESPONSE_REF R)
 {
 	if (PLAYER_SAID (R, i_lost_my_lander))
 	{
-		NPCPhrase (HERE_IS_A_NEW_LANDER);
+		if (GET_GAME_STATE (RADIOACTIVES_PROVIDED))
+			NPCPhrase (HERE_IS_A_NEW_LANDER_CLEAN);
+		else
+			NPCPhrase (HERE_IS_A_NEW_LANDER);
 		++GLOBAL_SIS (NumLanders);
 		DrawLanders ();
 		DeltaSISGauges (4, 0, 0);
@@ -290,7 +369,10 @@ AskAfterRadios (RESPONSE_REF R)
 	}
 	else if (PLAYER_SAID (R, i_lost_another_lander))
 	{
-		NPCPhrase (HERE_IS_ANOTHER_LANDER);
+		if (GET_GAME_STATE (RADIOACTIVES_PROVIDED))
+			NPCPhrase (HERE_IS_ANOTHER_LANDER_CLEAN);
+		else
+			NPCPhrase (HERE_IS_ANOTHER_LANDER);
 		++GLOBAL_SIS (NumLanders);
 		DrawLanders ();
 		DeltaSISGauges (4, 0, 0);
@@ -375,7 +457,10 @@ TellMoonBase (RESPONSE_REF R)
 	}
 	else if (PLAYER_SAID (R, i_lost_my_lander))
 	{
-		NPCPhrase (HERE_IS_A_NEW_LANDER);
+		if (GET_GAME_STATE (RADIOACTIVES_PROVIDED))
+			NPCPhrase (HERE_IS_A_NEW_LANDER_CLEAN);
+		else
+			NPCPhrase (HERE_IS_A_NEW_LANDER);
 		++GLOBAL_SIS (NumLanders);
 		DrawLanders ();
 		DeltaSISGauges (4, 0, 0);
@@ -384,7 +469,10 @@ TellMoonBase (RESPONSE_REF R)
 	}
 	else if (PLAYER_SAID (R, i_lost_another_lander))
 	{
-		NPCPhrase (HERE_IS_ANOTHER_LANDER);
+		if (GET_GAME_STATE (RADIOACTIVES_PROVIDED))
+			NPCPhrase (HERE_IS_ANOTHER_LANDER_CLEAN);
+		else
+			NPCPhrase (HERE_IS_ANOTHER_LANDER);
 		++GLOBAL_SIS (NumLanders);
 		DrawLanders ();
 		DeltaSISGauges (4, 0, 0);
@@ -554,7 +642,17 @@ GiveRadios (RESPONSE_REF R)
 		NPCPhrase (FUEL_UP1);		
 		AlienTalkSegue (1);
 
-		CommData.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
+		// JMS_GFX: Disable noisy static animation in hi-res.
+		if (RESOLUTION_FACTOR > 0)
+		{
+			CommData.AlienTalkDesc.AnimFlags &= ~PAUSE_TALKING;
+			CommData.AlienAmbientArray[0].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[1].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
+		}
+		// End color transform anim in lo-res.
+		else
+			CommData.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
 
 		XFormColorMap (GetColorMapAddress (
 				SetAbsColorMapIndex (CommData.AlienColorMap, 0)
@@ -643,8 +741,24 @@ post_commander_enc (void)
 LOCDATA*
 init_commander_comm ()
 {
+	static LOCDATA commander_desc;
 	LOCDATA *retval;
 
+	// JMS_GFX
+	switch (RESOLUTION_FACTOR)
+	{
+		case 2:
+			commander_desc = commander_desc_4x;
+			break;
+		case 1:
+			commander_desc = commander_desc_4x;
+			break;
+		case 0:
+		default:
+			commander_desc = commander_desc_1x;
+			break;
+	}
+
 	commander_desc.init_encounter_func = Intro;
 	commander_desc.post_encounter_func = post_commander_enc;
 	commander_desc.uninit_encounter_func = uninit_commander;
@@ -655,21 +769,36 @@ init_commander_comm ()
 
 	if (GET_GAME_STATE (RADIOACTIVES_PROVIDED))
 	{
+		// JMS_GFX: Disable noisy static animation in hi-res.
+		if (RESOLUTION_FACTOR > 0)
+		{
+			commander_desc.AlienTalkDesc.AnimFlags &= ~PAUSE_TALKING;
+			commander_desc.AlienAmbientArray[0].AnimFlags &= ~ANIM_DISABLED;
+			commander_desc.AlienAmbientArray[1].AnimFlags &= ~ANIM_DISABLED;
+		}
 		commander_desc.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
 		// regular track -- let's make sure
 		commander_desc.AlienSongFlags &= ~LDASF_USE_ALTERNATE;
 	}
 	else
 	{	
+		// JMS_GFX: Enable noisy static animation in hi-res.
+		if (RESOLUTION_FACTOR > 0)
+		{
+			commander_desc.AlienTalkDesc.AnimFlags |= PAUSE_TALKING;
+			commander_desc.AlienAmbientArray[0].AnimFlags |= ANIM_DISABLED;
+			commander_desc.AlienAmbientArray[1].AnimFlags |= ANIM_DISABLED;
+		}
 		commander_desc.AlienAmbientArray[2].AnimFlags &= ~ANIM_DISABLED;
 		// use alternate 'low-power' track if available
 		commander_desc.AlienAltSongRes = COMMANDER_LOWPOW_MUSIC;
 		commander_desc.AlienSongFlags |= LDASF_USE_ALTERNATE;
 	}
 
-	commander_desc.AlienTextWidth = 143;
-	commander_desc.AlienTextBaseline.x = 164;
-	commander_desc.AlienTextBaseline.y = 20;
+	// JMS_GFX
+	commander_desc.AlienTextWidth = RES_SIS_SCALE(143); // JMS_GFX
+	commander_desc.AlienTextBaseline.x = RES_SIS_SCALE(164); // JMS_GFX
+	commander_desc.AlienTextBaseline.y = RES_SIS_SCALE(20); // JMS_GFX
 
 	setSegue (Segue_peace);
 	retval = &commander_desc;
diff -ruNp src.mm/uqm/comm/comandr/strings.h src/uqm/comm/comandr/strings.h
--- src.mm/uqm/comm/comandr/strings.h	2017-11-28 11:08:45 -0600
+++ src/uqm/comm/comandr/strings.h	2017-11-28 11:09:31 -0600
@@ -28,11 +28,13 @@ enum
 	ARE_YOU_SUPPLY_SHIP,
 	DO_YOU_HAVE_RADIO_THIS_TIME,
 	HERE_IS_ANOTHER_LANDER,
+	HERE_IS_ANOTHER_LANDER_CLEAN,
 	THE_WHAT_FROM_WHERE,
 	ABOUT_TIME,
 	MESSAGE_GARBLED_1,
 	MESSAGE_GARBLED_2,
 	HERE_IS_A_NEW_LANDER,
+	HERE_IS_A_NEW_LANDER_CLEAN,
 	THIS_MAY_SEEM_SILLY,
 	OK_THE_NAFS,
 	OK_THE_CAN,
diff -ruNp src.mm/uqm/comm.c src/uqm/comm.c
--- src.mm/uqm/comm.c	2017-11-28 11:08:47 -0600
+++ src/uqm/comm.c	2017-11-28 11:09:33 -0600
@@ -56,13 +56,18 @@
 // XXX: was 32 picked experimentally?
 #define OSCILLOSCOPE_RATE   (ONE_SECOND / 32)
 
+// JMS_GFX
+#define RESPONSE_EXTRA_Y (RES_CASE(0,12,22))
+
 // Maximum comm animation frame rate (actual execution rate)
 // A gfx frame is not always produced during an execution frame,
 // and several animations are combined into one gfx frame.
 // The rate was originally 120fps which allowed for more animation
 // precision which is ultimately wasted on the human eye anyway.
 // The highest known stable animation rate is 40fps, so that's what we use.
-#define COMM_ANIM_RATE   (ONE_SECOND / 40)
+//
+// JMS: Changed this back to 120 fps since hires4x seems to like it... 
+#define COMM_ANIM_RATE   (ONE_SECOND / 120)
 
 static CONTEXT AnimContext;
 
@@ -108,8 +113,8 @@ static FRAME TextCacheFrame;
 
 RECT CommWndRect = {
 	// default values; actually inited by HailAlien()
-	{SIS_ORG_X, SIS_ORG_Y},
-	{0, 0}
+	{0, 0},
+	{0, 0}, //was {SIS_ORG_X, SIS_ORG_Y}, // JMS_GFX
 };
 
 static void ClearSubtitles (void);
@@ -196,13 +201,13 @@ add_text (int status, TEXT *pTextIn)
 	}
 	else if (GetContextFontLeading (&leading), status <= -4)
 	{
-		text_width = (SIZE) (SIS_SCREEN_WIDTH - 8 - (TEXT_X_OFFS << 2));
+		text_width = (SIZE) (SIS_SCREEN_WIDTH - (8 << RESOLUTION_FACTOR) - (TEXT_X_OFFS << 2)); // JMS_GFX
 
 		pText = pTextIn;
 	}
 	else
 	{
-		text_width = (SIZE) (SIS_SCREEN_WIDTH - 8 - (TEXT_X_OFFS << 2));
+		text_width = (SIZE) (SIS_SCREEN_WIDTH - (8 << RESOLUTION_FACTOR) - (TEXT_X_OFFS << 2)); // JMS_GFX
 
 		switch (status)
 		{
@@ -223,7 +228,7 @@ add_text (int status, TEXT *pTextIn)
 
 		maxchars = pTextIn->CharCount;
 		locText = *pTextIn;
-		locText.baseline.x -= 8;
+		locText.baseline.x -= (8 << RESOLUTION_FACTOR) - 4 * RESOLUTION_FACTOR; // JMS_GFX
 		locText.CharCount = (COUNT)~0;
 		locText.pStr = STR_BULLET;
 		font_DrawText (&locText);
@@ -518,21 +523,24 @@ static void
 RefreshResponses (ENCOUNTER_STATE *pES)
 {
 	COORD y;
-	BYTE response;
+	BYTE response, extra_y; // JMS_GFX
 	SIZE leading;
 	STAMP s;
 
+
 	SetContext (SpaceContext);
 	GetContextFontLeading (&leading);
 	BatchGraphics ();
 
 	DrawSISComWindow ();
-	y = SLIDER_Y + SLIDER_HEIGHT + 1;
+	y = SLIDER_Y + SLIDER_HEIGHT + (1 << RESOLUTION_FACTOR); // JMS_GFX
 	for (response = pES->top_response; response < pES->num_responses;
 			++response)
 	{
-		pES->response_list[response].response_text.baseline.x = TEXT_X_OFFS + 8;
-		pES->response_list[response].response_text.baseline.y = y + leading;
+		extra_y = (response == pES->top_response ? 0 : RESPONSE_EXTRA_Y); // JMS_GFX
+		
+		pES->response_list[response].response_text.baseline.x = TEXT_X_OFFS + (8 << RESOLUTION_FACTOR); // JMS_GFX
+		pES->response_list[response].response_text.baseline.y = y + leading + extra_y; // JMS_GFX
 		pES->response_list[response].response_text.align = ALIGN_LEFT;
 		if (response == pES->cur_response)
 			y = add_text (-1, &pES->response_list[response].response_text);
@@ -576,7 +584,7 @@ FeedbackPlayerPhrase (UNICODE *pStr)
 		TEXT ct;
 
 		ct.baseline.x = SIS_SCREEN_WIDTH >> 1;
-		ct.baseline.y = SLIDER_Y + SLIDER_HEIGHT + 13;
+		ct.baseline.y = SLIDER_Y + SLIDER_HEIGHT + (13 << RESOLUTION_FACTOR); // JMS_GFX
 		ct.align = ALIGN_CENTER;
 		ct.CharCount = (COUNT)~0;
 
@@ -585,7 +593,7 @@ FeedbackPlayerPhrase (UNICODE *pStr)
 		SetContextForeGroundColor (COMM_RESPONSE_INTRO_TEXT_COLOR);
 		font_DrawText (&ct);
 
-		ct.baseline.y += 16;
+		ct.baseline.y += (16 << RESOLUTION_FACTOR); // JMS_GFX
 		SetContextForeGroundColor (COMM_FEEDBACK_TEXT_COLOR);
 		ct.pStr = pStr;
 		add_text (-4, &ct);
@@ -912,9 +920,9 @@ static void remove_char_from_string(UNIC
 static BOOLEAN
 DoConvSummary (SUMMARY_STATE *pSS)
 {
-#define DELTA_Y_SUMMARY 8
-#define MAX_SUMM_ROWS ((SIS_SCREEN_HEIGHT - SLIDER_Y - SLIDER_HEIGHT) \
-			/ DELTA_Y_SUMMARY) - 1
+#define DELTA_Y_SUMMARY (8 << RESOLUTION_FACTOR) // JMS_GFX
+	//#define MAX_SUMM_ROWS ((SIS_SCREEN_HEIGHT - SLIDER_Y - SLIDER_HEIGHT) / DELTA_Y_SUMMARY
+#define MAX_SUMM_ROWS (SLIDER_Y	/ DELTA_Y_SUMMARY) - 1 // JMS_GFX
 
 	if (!pSS->Initialized)
 	{
@@ -951,7 +959,7 @@ DoConvSummary (SUMMARY_STATE *pSS)
 		r.corner.x = 0;
 		r.corner.y = 0;
 		r.extent.width = SIS_SCREEN_WIDTH;
-		r.extent.height = SIS_SCREEN_HEIGHT - SLIDER_Y - SLIDER_HEIGHT + 2;
+		r.extent.height = SLIDER_Y; //SIS_SCREEN_HEIGHT - SLIDER_Y - SLIDER_HEIGHT + (2 << RESOLUTION_FACTOR) + 16 * RESOLUTION_FACTOR; // JMS_GFX
 
 		SetContext (AnimContext);
 		SetContextForeGroundColor (COMM_HISTORY_BACKGROUND_COLOR);
@@ -960,7 +968,7 @@ DoConvSummary (SUMMARY_STATE *pSS)
 		SetContextForeGroundColor (COMM_HISTORY_TEXT_COLOR);
 
 		r.extent.width -= 2 + 2;
-		t.baseline.x = 2;
+		t.baseline.x = 2 << RESOLUTION_FACTOR; // JMS_GFX
 		t.align = ALIGN_LEFT;
 		t.baseline.y = DELTA_Y_SUMMARY;
 		SetContextFont (TinyFont);
@@ -1158,8 +1166,7 @@ PlayerResponseInput (ENCOUNTER_STATE *pE
 			COORD y;
 
 			BatchGraphics ();
-			add_text (-2,
-					&pES->response_list[pES->cur_response].response_text);
+			// add_text (-2, &pES->response_list[pES->cur_response].response_text);
 
 			pES->cur_response = response;
 
@@ -1168,12 +1175,12 @@ PlayerResponseInput (ENCOUNTER_STATE *pE
 			if (response < pES->top_response)
 			{
 				pES->top_response = 0;
-				RefreshResponses (pES);
+				// RefreshResponses (pES);
 			}
 			else if (y > SIS_SCREEN_HEIGHT)
 			{
 				pES->top_response = response;
-				RefreshResponses (pES);
+				// RefreshResponses (pES);
 			}
 			UnbatchGraphics ();
 		}
@@ -1354,9 +1361,12 @@ HailAlien (void)
 
 	// init subtitle cache context
 	TextCacheContext = CreateContext ("TextCacheContext");
-	TextCacheFrame = CaptureDrawable (
-			CreateDrawable (WANT_PIXMAP, SIS_SCREEN_WIDTH,
-			SIS_SCREEN_HEIGHT - SLIDER_Y - SLIDER_HEIGHT + 2, 1));
+	//TextCacheFrame = CaptureDrawable (
+	//		CreateDrawable (WANT_PIXMAP, SIS_SCREEN_WIDTH,
+	//		SIS_SCREEN_HEIGHT - SLIDER_Y - SLIDER_HEIGHT + 2, 1));
+	// BW: previous lines were just a complex and wrong way of obtaining 107
+ 	TextCacheFrame = CaptureDrawable (
+ 			CreateDrawable (WANT_PIXMAP, SIS_SCREEN_WIDTH, SLIDER_Y, 1));
 	SetContext (TextCacheContext);
 	SetContextFGFrame (TextCacheFrame);
 	TextBack = BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x10), 0x00);
@@ -1378,12 +1388,16 @@ HailAlien (void)
 		SetContextFGFrame (Screen);
 		GetFrameRect (CommData.AlienFrame, &r);
 		r.extent.width = SIS_SCREEN_WIDTH;
-		CommWndRect.extent = r.extent;
+		CommWndRect.corner.x = SIS_ORG_X; // JMS_GFX: Added these lines because of the 
+		CommWndRect.corner.y = SIS_ORG_Y; // changed init of CommWndRect in the beginning of comm.c
 		
 		SetTransitionSource (NULL);
 		BatchGraphics ();
 		if (LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 		{
+			// set the position of outtakes comm
+			CommWndRect.corner.x = ((SCREEN_WIDTH - CommWndRect.extent.width) / 2); // JMS_GFX
+			CommWndRect.corner.y = RES_CASE(5,0,0); // JMS_GFX
 			r.corner = CommWndRect.corner;
 			SetContextClipRect (&r);
 		}
diff -ruNp src.mm/uqm/comm.h src/uqm/comm.h
--- src.mm/uqm/comm.h	2017-11-28 11:08:47 -0600
+++ src/uqm/comm.h	2017-11-28 11:09:33 -0600
@@ -26,8 +26,8 @@
 
 #ifdef COMM_INTERNAL
 
-#define SLIDER_Y 107
-#define SLIDER_HEIGHT 15
+#define SLIDER_Y ((107 << RESOLUTION_FACTOR) + RES_CASE(0,6,46)) // JMS_GFX
+#define SLIDER_HEIGHT RES_CASE(15, 15, 30) // JMS_GFX
 
 #include "commanim.h"
 
@@ -105,8 +105,8 @@ signaledStopTalkingAnim (void)
 
 #endif
 
-#define TEXT_X_OFFS 1
-#define TEXT_Y_OFFS 1
+#define TEXT_X_OFFS (1 << RESOLUTION_FACTOR) // JMS_GFX
+#define TEXT_Y_OFFS (1 << RESOLUTION_FACTOR) // JMS_GFX
 #define SIS_TEXT_WIDTH (SIS_SCREEN_WIDTH - (TEXT_X_OFFS << 1))
 
 extern void init_communication (void);
diff -ruNp src.mm/uqm/commanim.c src/uqm/commanim.c
--- src.mm/uqm/commanim.c	2017-11-28 11:08:47 -0600
+++ src/uqm/commanim.c	2017-11-28 11:09:33 -0600
@@ -464,6 +464,36 @@ ProcessCommAnimations (BOOLEAN FullRedra
 				{	// Otherwise, let the animation run until it's safe
 					CanTalk = FALSE;
 				}
+			}			
+			
+			// BW: to be checked. I've tried to remove what's supposed to be removed while keeping the Syreen zoom-in feature.
+			// It may have to be re-programmed in the new commanim style.
+			if (pSeq->AnimType == PICTURE_ANIM
+				&& (ADPtr->AnimFlags & CommData.AlienTalkDesc.AnimFlags & WAIT_TALKING)
+				&& pSeq->Direction != NO_DIR)
+			{
+				// JMS: Cut marked animations short when starting talk.
+				// The animations are marked with FAST_STOP_AT_TALK_START in the races' comm source codes.
+				if (ADPtr->AnimFlags & FAST_STOP_AT_TALK_START)
+				{	CanTalk = TRUE;
+					//pSeq->AnimObj.CurFrame = SetAbsFrameIndex(pSeq->AnimObj.CurFrame, ADPtr->StartIndex);
+					pSeq->Direction = NO_DIR;
+				}
+			}
+			
+			// JMS: This handles ambient animations which should occur only during talk
+			// A lot of conditions are necessary to eliminate unwanted animations
+			// from the duration of talk transition!
+			if (pSeq->AnimType == PICTURE_ANIM
+				&& ADPtr->AnimFlags & WHEN_TALKING 
+				&& (!(CommData.AlienTalkDesc.AnimFlags & WAIT_TALKING) 
+					|| (CommData.AlienTalkDesc.AnimFlags & TALK_INTRO)
+					|| (CommData.AlienTalkDesc.AnimFlags & TALK_DONE))
+				&& !(CommData.AlienTransitionDesc.AnimFlags & PAUSE_TALKING)
+				&& pSeq->Direction != NO_DIR)
+			{
+				// Stop the anim if not talking
+				pSeq->Direction = NO_DIR;
 			}
 		}
 		// All ambient animations have been processed. Advance the mask.
diff -ruNp src.mm/uqm/commanim.h src/uqm/commanim.h
--- src.mm/uqm/commanim.h	2017-11-28 11:08:47 -0600
+++ src/uqm/commanim.h	2017-11-28 11:09:33 -0600
@@ -56,7 +56,11 @@ extern "C" {
 #define TALK_DONE (1 << 6)
 		// In AlienTransitionDesc: indicates a transition to silent state
 		// In AlienTalkDesc: signals the end of talking animation
-#define ANIM_DISABLED (1 << 7)
+#define WHEN_TALKING (1L << 7) // JMS
+#define ANIM_DISABLED (1L << 8) // BW (needed for news anchor and animated background)
+
+#define FAST_STOP_AT_TALK_START (TALK_DONE) // JMS: If there's a very loooong animation, it can be forced to stop when talking with this.
+// (otherwise there'll be nasty, unwanted pauses in the conversation.) 
 
 #define COLORXFORM_ANIM PAUSE_TALKING
 
@@ -72,9 +76,10 @@ typedef struct
 	BYTE NumFrames;
 			// Number of frames in the animation.
 
-	BYTE AnimFlags;
+	COUNT AnimFlags;
 			// One of RANDOM_ANIM, CIRCULAR_ANIM, or YOYO_ANIM
 			// plus flags (WAIT_TALKING, ANIM_DISABLED)
+			// JMS: Changed from BYTE to COUNT to house more possible flags
 
 	COUNT BaseFrameRate;
 			// Minimum interframe delay
@@ -93,7 +98,7 @@ typedef struct
 			// due to the image overlap conflicts.
 } ANIMATION_DESC;
 
-#define MAX_ANIMATIONS 20
+#define MAX_ANIMATIONS 30 // JMS: Was 20
 
 
 #ifdef COMM_INTERNAL
diff -ruNp src.mm/uqm/credits.c src/uqm/credits.c
--- src.mm/uqm/credits.c	2017-11-28 11:08:47 -0600
+++ src/uqm/credits.c	2017-11-28 11:09:33 -0600
@@ -32,10 +32,10 @@
 #include <math.h>
 
 // Rates in pixel lines per second
-#define CREDITS_BASE_RATE   9
-#define CREDITS_MAX_RATE    130
+#define CREDITS_BASE_RATE   (05 << RESOLUTION_FACTOR) // JMS_GFX - MB: tamed
+#define CREDITS_MAX_RATE    (35 << RESOLUTION_FACTOR) // JMS_GFX - MB: tamed
 // Maximum frame rate
-#define CREDITS_FRAME_RATE  36
+#define CREDITS_FRAME_RATE  (RES_CASE(26,32,36)) // JMS_GFX
 
 #define CREDITS_TIMEOUT   (ONE_SECOND * 5)
 
@@ -267,6 +267,8 @@ Credits_RenderTextFrame (CONTEXT TempCon
 			continue;
 		}
 
+		x <<= RESOLUTION_FACTOR; // JMS_GFX
+
 		switch (c)
 		{
 			case 'L':
@@ -792,9 +794,8 @@ Credits (BOOLEAN WithOuttakes)
 	FadeScreen (FadeAllToColor, ONE_SECOND / 2);
 
 	// set the position of outtakes comm
-	CommWndRect.corner.x = (screenRect.extent.width - CommWndRect.extent.width)
-			/ 2;
-	CommWndRect.corner.y = 5;
+	CommWndRect.corner.x = ((screenRect.extent.width - CommWndRect.extent.width) / 2); // JMS_GFX
+	CommWndRect.corner.y = RES_CASE(5,0,0); // JMS_GFX
 	
 	InitCredits ();
 	SetInputCallback (on_input_frame);
diff -ruNp src.mm/uqm/cyborg.c src/uqm/cyborg.c
--- src.mm/uqm/cyborg.c	2017-11-28 11:08:47 -0600
+++ src/uqm/cyborg.c	2017-11-28 11:09:33 -0600
@@ -31,17 +31,19 @@
 
 COUNT
 PlotIntercept (ELEMENT *ElementPtr0, ELEMENT *ElementPtr1,
-		COUNT max_turns, COUNT margin_of_error)
+			   COUNT max_turns, COUNT margin_of_error)
 {
-	SIZE dy;
-	SIZE time_y_0, time_y_1;
-	POINT dst[2];
+	SDWORD dy;
+	SDWORD time_y_0, time_y_1;
+	DPOINT dst[2];
 	RECT r0 = {{0, 0}, {0, 0}};
 	RECT r1 = {{0, 0}, {0, 0}};
-	SIZE dx_0, dy_0, dx_1, dy_1;
-
+	SDWORD dx_0, dy_0, dx_1, dy_1; // JMS:These were SIZE. No overflows now.
+	
 	if ((ElementPtr0->state_flags | ElementPtr1->state_flags) & FINITE_LIFE)
 	{
+		//log_add (log_Debug, "E0:%d, E1:%d, max:%d",ElementPtr0->life_span,ElementPtr1->life_span, max_turns);
+		
 		if (!(ElementPtr0->state_flags & FINITE_LIFE))
 		{
 			if (ElementPtr1->life_span < max_turns)
@@ -60,17 +62,19 @@ PlotIntercept (ELEMENT *ElementPtr0, ELE
 				max_turns = ElementPtr1->life_span;
 		}
 	}
-
-	dst[0] = ElementPtr0->current.location;
-	GetCurrentVelocityComponents (&ElementPtr0->velocity, &dx_0, &dy_0);
-	dx_0 = (SIZE)VELOCITY_TO_WORLD ((long)dx_0 * (long)max_turns);
-	dy_0 = (SIZE)VELOCITY_TO_WORLD ((long)dy_0 * (long)max_turns);
-
-	dst[1] = ElementPtr1->current.location;
-	GetCurrentVelocityComponents (&ElementPtr1->velocity, &dx_1, &dy_1);
-	dx_1 = (SIZE)VELOCITY_TO_WORLD ((long)dx_1 * (long)max_turns);
-	dy_1 = (SIZE)VELOCITY_TO_WORLD ((long)dy_1 * (long)max_turns);
-
+	
+	dst[0].x = (SDWORD)ElementPtr0->current.location.x;
+	dst[0].y = (SDWORD)ElementPtr0->current.location.y;
+	GetCurrentVelocityComponentsSdword (&ElementPtr0->velocity, &dx_0, &dy_0);
+	dx_0 = (SDWORD)VELOCITY_TO_WORLD ((long)dx_0 * (long)max_turns);
+	dy_0 = (SDWORD)VELOCITY_TO_WORLD ((long)dy_0 * (long)max_turns);
+	
+	dst[1].x = (SDWORD)ElementPtr1->current.location.x;
+	dst[1].y = (SDWORD)ElementPtr1->current.location.y;
+	GetCurrentVelocityComponentsSdword (&ElementPtr1->velocity, &dx_1, &dy_1);
+	dx_1 = (SDWORD)VELOCITY_TO_WORLD ((long)dx_1 * (long)max_turns);
+	dy_1 = (SDWORD)VELOCITY_TO_WORLD ((long)dy_1 * (long)max_turns);
+	
 	if (margin_of_error)
 	{
 		dst[1].y -= margin_of_error;
@@ -81,25 +85,25 @@ PlotIntercept (ELEMENT *ElementPtr0, ELE
 	{
 		GetFrameRect (ElementPtr0->IntersectControl.IntersectStamp.frame, &r0);
 		GetFrameRect (ElementPtr1->IntersectControl.IntersectStamp.frame, &r1);
-
+		
 		dst[0].y += DISPLAY_TO_WORLD (r0.corner.y);
 		dst[1].y += DISPLAY_TO_WORLD (r1.corner.y);
 		time_y_0 = DISPLAY_TO_WORLD (r0.extent.height);
 		time_y_1 = DISPLAY_TO_WORLD (r1.extent.height);
 	}
-
+	
 	dy = dst[1].y - dst[0].y;
 	time_y_0 = dy - time_y_0 + 1;
 	time_y_1 = dy + time_y_1 - 1;
 	dy = dy_0 - dy_1;
-
+	
 	if ((time_y_0 <= 0 && time_y_1 >= 0)
-			|| (time_y_0 > 0 && dy >= time_y_0)
-			|| (time_y_1 < 0 && dy <= time_y_1))
+		|| (time_y_0 > 0 && dy >= time_y_0)
+		|| (time_y_1 < 0 && dy <= time_y_1))
 	{
-		SIZE dx;
-		SIZE time_x_0, time_x_1;
-
+		SDWORD dx;
+		SDWORD time_x_0, time_x_1;
+		
 		if (margin_of_error)
 		{
 			dst[1].x -= margin_of_error;
@@ -113,23 +117,23 @@ PlotIntercept (ELEMENT *ElementPtr0, ELE
 			time_x_0 = DISPLAY_TO_WORLD (r0.extent.width);
 			time_x_1 = DISPLAY_TO_WORLD (r1.extent.width);
 		}
-
+		
 		dx = dst[1].x - dst[0].x;
 		time_x_0 = dx - time_x_0 + 1;
 		time_x_1 = dx + time_x_1 - 1;
 		dx = dx_0 - dx_1;
-
+		
 		if ((time_x_0 <= 0 && time_x_1 >= 0)
-				|| (time_x_0 > 0 && dx >= time_x_0)
-				|| (time_x_1 < 0 && dx <= time_x_1))
+			|| (time_x_0 > 0 && dx >= time_x_0)
+			|| (time_x_1 < 0 && dx <= time_x_1))
 		{
 			if (dx == 0 && dy == 0)
 				time_y_0 = time_y_1 = 0;
 			else
 			{
-				SIZE t;
+				SDWORD t;
 				long time_beg, time_end, fract;
-
+				
 				if (time_y_1 < 0)
 				{
 					t = time_y_0;
@@ -146,7 +150,7 @@ PlotIntercept (ELEMENT *ElementPtr0, ELE
 					dy = -dy;
 				if (dy < time_y_1)
 					time_y_1 = dy;
-
+				
 				if (time_x_1 < 0)
 				{
 					t = time_x_0;
@@ -163,7 +167,7 @@ PlotIntercept (ELEMENT *ElementPtr0, ELE
 					dx = -dx;
 				if (dx < time_x_1)
 					time_x_1 = dx;
-
+				
 				if (dx == 0)
 				{
 					time_beg = time_y_0;
@@ -179,100 +183,103 @@ PlotIntercept (ELEMENT *ElementPtr0, ELE
 				else
 				{
 					long time_x, time_y;
-
+					
 					time_x = (long)time_x_0 * (long)dy;
 					time_y = (long)time_y_0 * (long)dx;
 					time_beg = time_x < time_y ? time_y : time_x;
-
+					
 					time_x = (long)time_x_1 * (long)dy;
 					time_y = (long)time_y_1 * (long)dx;
 					time_end = time_x > time_y ? time_y : time_x;
-
+					
 					fract = (long)dx * (long)dy;
 				}
-
+				
 				if ((time_beg *= max_turns) < fract)
 					time_y_0 = 0;
 				else
-					time_y_0 = (SIZE)(time_beg / fract);
-
+					time_y_0 = (SDWORD)(time_beg / fract);
+				
 				if (time_end >= fract) /* just in case of overflow */
 					time_y_1 = max_turns - 1;
 				else
-					time_y_1 = (SIZE)((time_end * max_turns) / fract);
+					time_y_1 = (SDWORD)((time_end * max_turns) / fract);
 			}
-
+			
 			if (time_y_0 <= time_y_1)
 			{
 				if (margin_of_error != 0)
 					return ((COUNT)time_y_0 + 1);
 				else
 				{
-					POINT Pt0, Pt1;
+					DPOINT Pt0, Pt1;
 					VELOCITY_DESC Velocity0, Velocity1;
 					INTERSECT_CONTROL Control0, Control1;
-
-					Pt0 = ElementPtr0->current.location;
+					
+					Pt0.x = (SDWORD)ElementPtr0->current.location.x;
+					Pt0.y = (SDWORD)ElementPtr0->current.location.y;
 					Velocity0 = ElementPtr0->velocity;
 					Control0 = ElementPtr0->IntersectControl;
-
-					Pt1 = ElementPtr1->current.location;
+					
+					Pt1.x = (SDWORD)ElementPtr1->current.location.x;
+					Pt1.y = (SDWORD)ElementPtr1->current.location.y;
 					Velocity1 = ElementPtr1->velocity;
 					Control1 = ElementPtr1->IntersectControl;
-
+					
 					if (time_y_0)
 					{
-						GetNextVelocityComponents (&Velocity0, &dx_0, &dy_0, time_y_0);
+						GetNextVelocityComponentsSdword (&Velocity0, &dx_0, &dy_0, time_y_0);
 						Pt0.x += dx_0;
 						Pt0.y += dy_0;
 						Control0.EndPoint.x = WORLD_TO_DISPLAY (Pt0.x);
 						Control0.EndPoint.y = WORLD_TO_DISPLAY (Pt0.y);
 						
-						GetNextVelocityComponents (&Velocity1, &dx_1, &dy_1, time_y_0);
+						GetNextVelocityComponentsSdword (&Velocity1, &dx_1, &dy_1, time_y_0);
 						Pt1.x += dx_1;
 						Pt1.y += dy_1;
 						Control1.EndPoint.x = WORLD_TO_DISPLAY (Pt1.x);
 						Control1.EndPoint.y = WORLD_TO_DISPLAY (Pt1.y);
 					}
-
+					
 					do
 					{
 						TIME_VALUE when;
-
+						
 						++time_y_0;
-
-						GetNextVelocityComponents (&Velocity0, &dx_0, &dy_0, 1);
+						
+						GetNextVelocityComponentsSdword (&Velocity0, &dx_0, &dy_0, 1);
 						Pt0.x += dx_0;
 						Pt0.y += dy_0;
-
-						GetNextVelocityComponents (&Velocity1, &dx_1, &dy_1, 1);
+						
+						GetNextVelocityComponentsSdword (&Velocity1, &dx_1, &dy_1, 1);
 						Pt1.x += dx_1;
 						Pt1.y += dy_1;
-
+						
 						Control0.IntersectStamp.origin = Control0.EndPoint;
 						Control0.EndPoint.x = WORLD_TO_DISPLAY (Pt0.x);
 						Control0.EndPoint.y = WORLD_TO_DISPLAY (Pt0.y);
-
+						
 						Control1.IntersectStamp.origin = Control1.EndPoint;
 						Control1.EndPoint.x = WORLD_TO_DISPLAY (Pt1.x);
 						Control1.EndPoint.y = WORLD_TO_DISPLAY (Pt1.y);
-						when = DrawablesIntersect (&Control0,
-								&Control1, MAX_TIME_VALUE);
+						
+						when = DrawablesIntersect (&Control0, &Control1, MAX_TIME_VALUE);
+						
 						if (when)
 						{
 							if (when == 1
-									&& time_y_0 == 1
-									&& ((ElementPtr0->state_flags
-									| ElementPtr1->state_flags) & APPEARING))
+								&& time_y_0 == 1
+								&& ((ElementPtr0->state_flags
+									 | ElementPtr1->state_flags) & APPEARING))
 							{
 								when = 0;
 								Control0.EndPoint.x = WORLD_TO_DISPLAY (Pt0.x);
 								Control0.EndPoint.y = WORLD_TO_DISPLAY (Pt0.y);
-
+								
 								Control1.EndPoint.x = WORLD_TO_DISPLAY (Pt1.x);
 								Control1.EndPoint.y = WORLD_TO_DISPLAY (Pt1.y);
 							}
-
+							
 							if (when)
 								return ((COUNT)time_y_0);
 						}
@@ -281,7 +288,7 @@ PlotIntercept (ELEMENT *ElementPtr0, ELE
 			}
 		}
 	}
-
+	
 	return (0);
 }
 
@@ -289,24 +296,24 @@ static void
 InitCyborg (STARSHIP *StarShipPtr)
 {
 	COUNT Index, Divisor;
-
+	
 	Index = StarShipPtr->RaceDescPtr->characteristics.max_thrust
-			* StarShipPtr->RaceDescPtr->characteristics.thrust_increment;
+	* StarShipPtr->RaceDescPtr->characteristics.thrust_increment;
 	if ((Divisor = StarShipPtr->RaceDescPtr->characteristics.turn_wait
-			+ StarShipPtr->RaceDescPtr->characteristics.thrust_wait) > 0)
+		 + StarShipPtr->RaceDescPtr->characteristics.thrust_wait) > 0)
 		Index /= Divisor;
 	else
 		Index >>= 1;
 #ifdef PRINT_MI
 	{
 		char *shipName;
-
+		
 		shipName = GetStringAddress (
-				StarShipPtr->RaceDescPtr->ship_data.race_strings);
+									 StarShipPtr->RaceDescPtr->ship_data.race_strings);
 		log_add (log_Debug, "MI(%s) -- <%u:%u> = %u", shipName,
-				StarShipPtr->RaceDescPtr->characteristics.max_thrust *
-				StarShipPtr->RaceDescPtr->characteristics.thrust_increment,
-				Divisor, Index);
+				 StarShipPtr->RaceDescPtr->characteristics.max_thrust *
+				 StarShipPtr->RaceDescPtr->characteristics.thrust_increment,
+				 Divisor, Index);
 	}
 #endif /* PRINT_MI */
 	StarShipPtr->RaceDescPtr->cyborg_control.ManeuverabilityIndex = Index;
@@ -317,7 +324,7 @@ ship_movement (ELEMENT *ShipPtr, EVALUAT
 {
 	if (EvalDescPtr->which_turn == 0)
 		EvalDescPtr->which_turn = 1;
-
+	
 	switch (EvalDescPtr->MoveState)
 	{
 		case PURSUE:
@@ -336,37 +343,38 @@ ship_movement (ELEMENT *ShipPtr, EVALUAT
 	}
 }
 
+// JMS:GFX Made SIZEs SDWORDs and changed the GetNextVelocityComponents to GetNextVelocityComponentsSdword
 BOOLEAN
 ship_weapons (ELEMENT *ShipPtr, ELEMENT *OtherPtr, COUNT margin_of_error)
 {
-	SIZE delta_x, delta_y;
+	SDWORD delta_x, delta_y;
 	COUNT n, num_weapons;
 	ELEMENT Ship;
 	HELEMENT Weapon[6];
 	STARSHIP *StarShipPtr;
-
+	
 	if (OBJECT_CLOAKED (OtherPtr))
-		margin_of_error += DISPLAY_TO_WORLD (40);
-
+		margin_of_error += DISPLAY_TO_WORLD (40 << RESOLUTION_FACTOR); // JMS_GFX
+	
 	Ship = *ShipPtr;
-	GetNextVelocityComponents (&Ship.velocity,
-			&delta_x, &delta_y, 1);
+	GetNextVelocityComponentsSdword (&Ship.velocity, &delta_x, &delta_y, 1);
 	Ship.next.location.x =
-			Ship.current.location.x + delta_x;
+		Ship.current.location.x + delta_x;
 	Ship.next.location.y =
-			Ship.current.location.y + delta_y;
+		Ship.current.location.y + delta_y;
+	
 	Ship.current.location = Ship.next.location;
-
+	
 	GetElementStarShip (&Ship, &StarShipPtr);
 	num_weapons =
-			(*StarShipPtr->RaceDescPtr->init_weapon_func) (&Ship, Weapon);
-
+	(*StarShipPtr->RaceDescPtr->init_weapon_func) (&Ship, Weapon);
+	
 	if ((n = num_weapons))
 	{
 		HELEMENT *WeaponPtr, w;
 		//STARSHIP *StarShipPtr;
 		ELEMENT *EPtr;
-
+		
 		WeaponPtr = &Weapon[0];
 		do
 		{
@@ -381,20 +389,19 @@ ship_weapons (ELEMENT *ShipPtr, ELEMENT
 					InitIntersectEndPoint (EPtr);
 					InitIntersectFrame (EPtr);
 				}
-
-				if (PlotIntercept (EPtr, OtherPtr,
-						EPtr->life_span, margin_of_error))
+				
+				if (PlotIntercept (EPtr, OtherPtr, EPtr->life_span, margin_of_error))
 				{
 					UnlockElement (w);
 					break;
 				}
-
+				
 				UnlockElement (w);
 				FreeElement (w);
 			}
 			++WeaponPtr;
 		} while (--n);
-
+		
 		if ((num_weapons = n))
 		{
 			do
@@ -405,26 +412,30 @@ ship_weapons (ELEMENT *ShipPtr, ELEMENT
 			} while (--n);
 		}
 	}
-
+	
+	//if (num_weapons > 0)
+	//	log_add (log_Debug, "dx:%d, dy:%d, currx:%d, curry:%d, nextx:%d, nexty:%d", delta_x, delta_y, Ship.current.location.x, Ship.current.location.y, Ship.next.location.x, Ship.next.location.y);
+	
 	return (num_weapons > 0);
 }
 
 void
 ship_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
-		COUNT ConcernCounter)
+				   COUNT ConcernCounter)
 {
 	BOOLEAN ShipMoved, ShipFired;
 	COUNT margin_of_error;
 	STARSHIP *StarShipPtr;
-
+	EVALUATE_DESC *ObjectsOfConcernEWeapon;
+	
 	GetElementStarShip (ShipPtr, &StarShipPtr);
-
+	
 	ShipMoved = TRUE;
 	if (ShipPtr->turn_wait == 0)
 		ShipMoved = FALSE;
 	if (ShipPtr->thrust_wait == 0)
 		ShipMoved = FALSE;
-
+	
 	ShipFired = TRUE;
 	if (StarShipPtr->weapon_counter == 0)
 	{
@@ -432,42 +443,49 @@ ship_intelligence (ELEMENT *ShipPtr, EVA
 		if (!(StarShipPtr->RaceDescPtr->ship_info.ship_flags & SEEKING_WEAPON))
 			ShipFired = FALSE;
 	}
-
+	
 	if (StarShipPtr->control & AWESOME_RATING)
 		margin_of_error = 0;
 	else if (StarShipPtr->control & GOOD_RATING)
-		margin_of_error = DISPLAY_TO_WORLD (20);
+		margin_of_error = DISPLAY_TO_WORLD (20 << RESOLUTION_FACTOR); // JMS_GFX
 	else /* if (StarShipPtr->control & STANDARD_RATING) */
-		margin_of_error = DISPLAY_TO_WORLD (40);
-
+		margin_of_error = DISPLAY_TO_WORLD (40 << RESOLUTION_FACTOR); // JMS_GFX
+	
 	ObjectsOfConcern += ConcernCounter;
+	
+	ObjectsOfConcernEWeapon = ObjectsOfConcern - ConcernCounter + ENEMY_WEAPON_INDEX;
+	
 	while (ConcernCounter--)
 	{
 		--ObjectsOfConcern;
 		if (ObjectsOfConcern->ObjectPtr)
 		{
 			if (!ShipMoved
-					&& (ConcernCounter != ENEMY_WEAPON_INDEX
+				&& (ConcernCounter != ENEMY_WEAPON_INDEX
 					|| ObjectsOfConcern->MoveState == PURSUE
 					|| (ObjectsOfConcern->ObjectPtr->state_flags & CREW_OBJECT)
 					|| MANEUVERABILITY (
-							&StarShipPtr->RaceDescPtr->cyborg_control
-							) >= MEDIUM_SHIP))
+										&StarShipPtr->RaceDescPtr->cyborg_control
+										) >= RESOLUTION_COMPENSATED(MEDIUM_SHIP) // JMS_GFX
+					)
+				)
 			{
 				ship_movement (ShipPtr, ObjectsOfConcern);
 				ShipMoved = TRUE;
 			}
 			if (!ShipFired
-					&& (ConcernCounter == ENEMY_SHIP_INDEX
+				&& (ConcernCounter == ENEMY_SHIP_INDEX
 					|| (ConcernCounter == ENEMY_WEAPON_INDEX
-					&& ObjectsOfConcern->MoveState != AVOID
+						&& ObjectsOfConcern->MoveState != AVOID
 #ifdef NEVER
-					&& !(StarShipPtr->control & STANDARD_RATING)
-#endif /* NEVER */
-					)))
+						&& !(StarShipPtr->control & STANDARD_RATING)
+#endif /* NEVER */		
+						)
+					)
+				)
 			{
-				ShipFired = ship_weapons (ShipPtr,
-						ObjectsOfConcern->ObjectPtr, margin_of_error);
+				ShipFired = ship_weapons (ShipPtr,ObjectsOfConcern->ObjectPtr, margin_of_error);
+				
 				if (ShipFired)
 					StarShipPtr->ship_input_state |= WEAPON;
 			}
@@ -480,7 +498,7 @@ TurnShip (ELEMENT *ShipPtr, COUNT angle)
 {
 	COUNT f, ship_delta_facing;
 	STARSHIP *StarShipPtr;
-
+	
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	f = StarShipPtr->ShipFacing;
 	ship_delta_facing = NORMALIZE_FACING (ANGLE_TO_FACING (angle) - f);
@@ -488,39 +506,39 @@ TurnShip (ELEMENT *ShipPtr, COUNT angle)
 	{
 		if (ship_delta_facing == ANGLE_TO_FACING (HALF_CIRCLE))
 			ship_delta_facing =
-					NORMALIZE_FACING (ship_delta_facing +
-					(TFB_Random () & 1 ?
-					ANGLE_TO_FACING (OCTANT >> 1) :
-					-ANGLE_TO_FACING (OCTANT >> 1)));
-
+			NORMALIZE_FACING (ship_delta_facing +
+							  (TFB_Random () & 1 ?
+							   ANGLE_TO_FACING (OCTANT >> 1) :
+							   -ANGLE_TO_FACING (OCTANT >> 1)));
+		
 		if (ship_delta_facing < ANGLE_TO_FACING (HALF_CIRCLE))
 		{
 			StarShipPtr->ship_input_state |= RIGHT;
 			++f;
 			ShipPtr->next.image.frame =
-					IncFrameIndex (ShipPtr->current.image.frame);
+			IncFrameIndex (ShipPtr->current.image.frame);
 		}
 		else
 		{
 			StarShipPtr->ship_input_state |= LEFT;
 			--f;
 			ShipPtr->next.image.frame =
-					DecFrameIndex (ShipPtr->current.image.frame);
+			DecFrameIndex (ShipPtr->current.image.frame);
 		}
-
+		
 #ifdef NOTYET
 		if (((StarShipPtr->ship_input_state & (LEFT | RIGHT))
-				^ (StarShipPtr->cur_status_flags & (LEFT | RIGHT))) == (LEFT | RIGHT))
+			 ^ (StarShipPtr->cur_status_flags & (LEFT | RIGHT))) == (LEFT | RIGHT))
 			StarShipPtr->ship_input_state &= ~(LEFT | RIGHT);
 		else
 #endif /* NOTYET */
 		{
 			StarShipPtr->ShipFacing = NORMALIZE_FACING (f);
-
+			
 			return (TRUE);
 		}
 	}
-
+	
 	return (FALSE);
 }
 
@@ -529,224 +547,237 @@ ThrustShip (ELEMENT *ShipPtr, COUNT angl
 {
 	BOOLEAN ShouldThrust;
 	STARSHIP *StarShipPtr;
-
+	
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	if (StarShipPtr->ship_input_state & THRUST)
 		ShouldThrust = TRUE;
 	else if (NORMALIZE_FACING (ANGLE_TO_FACING (angle)
-			- ANGLE_TO_FACING (GetVelocityTravelAngle (&ShipPtr->velocity))) == 0
-			&& (StarShipPtr->cur_status_flags
-			& (SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED))
-			&& !(StarShipPtr->cur_status_flags & SHIP_IN_GRAVITY_WELL))
+							   - ANGLE_TO_FACING (GetVelocityTravelAngle (&ShipPtr->velocity))) == 0
+			 && (StarShipPtr->cur_status_flags
+				 & (SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED))
+			 && !(StarShipPtr->cur_status_flags & SHIP_IN_GRAVITY_WELL))
 		ShouldThrust = FALSE;
 	else
 	{
 		SIZE ship_delta_facing;
-
+		
 		ship_delta_facing =
-				NORMALIZE_FACING (ANGLE_TO_FACING (angle)
-				- StarShipPtr->ShipFacing + ANGLE_TO_FACING (QUADRANT));
+		NORMALIZE_FACING (ANGLE_TO_FACING (angle)
+						  - StarShipPtr->ShipFacing + ANGLE_TO_FACING (QUADRANT));
 		if (ship_delta_facing == ANGLE_TO_FACING (QUADRANT)
-				|| ((StarShipPtr->cur_status_flags & SHIP_BEYOND_MAX_SPEED)
+			|| ((StarShipPtr->cur_status_flags & SHIP_BEYOND_MAX_SPEED)
 				&& ship_delta_facing <= ANGLE_TO_FACING (HALF_CIRCLE)))
 			ShouldThrust = TRUE;
 		else
 			ShouldThrust = FALSE;
 	}
-
+	
 	if (ShouldThrust)
 	{
 		inertial_thrust (ShipPtr);
-
+		
 		StarShipPtr->ship_input_state |= THRUST;
 	}
-
+	
 	return (ShouldThrust);
 }
 
+// JMS:GFX Made SIZEs SDWORDs and changed the GetNextVelocityComponents to GetNextVelocityComponentsSdword
 void
 Pursue (ELEMENT *ShipPtr, EVALUATE_DESC *EvalDescPtr)
 {
 	BYTE maneuver_state;
 	COUNT desired_thrust_angle, desired_turn_angle;
-	SIZE delta_x, delta_y;
-	SIZE ship_delta_x, ship_delta_y;
-	SIZE other_delta_x, other_delta_y;
+	SDWORD delta_x, delta_y;
+	SDWORD ship_delta_x, ship_delta_y;
+	SDWORD other_delta_x, other_delta_y;
 	ELEMENT *OtherObjPtr;
 	VELOCITY_DESC ShipVelocity, OtherVelocity;
-
+	COUNT distance_to_give_up_and_turn; // JMS
+	
 	ShipVelocity = ShipPtr->velocity;
-	GetNextVelocityComponents (&ShipVelocity,
-			&ship_delta_x, &ship_delta_y, EvalDescPtr->which_turn);
+	GetNextVelocityComponentsSdword (&ShipVelocity,
+		&ship_delta_x, &ship_delta_y, EvalDescPtr->which_turn);
 	ShipPtr->next.location.x =
-			ShipPtr->current.location.x + ship_delta_x;
+		ShipPtr->current.location.x + ship_delta_x;
 	ShipPtr->next.location.y =
-			ShipPtr->current.location.y + ship_delta_y;
-
+		ShipPtr->current.location.y + ship_delta_y;
+	
 	OtherObjPtr = EvalDescPtr->ObjectPtr;
+	
 	OtherVelocity = OtherObjPtr->velocity;
-	GetNextVelocityComponents (&OtherVelocity,
-			&other_delta_x, &other_delta_y, EvalDescPtr->which_turn);
-
+	GetNextVelocityComponentsSdword (&OtherVelocity,
+							   &other_delta_x, &other_delta_y, EvalDescPtr->which_turn);
+	
 	delta_x = (OtherObjPtr->current.location.x + other_delta_x)
-			- ShipPtr->next.location.x;
+		- ShipPtr->next.location.x;
 	delta_y = (OtherObjPtr->current.location.y + other_delta_y)
-			- ShipPtr->next.location.y;
+		- ShipPtr->next.location.y;
 	delta_x = WRAP_DELTA_X (delta_x);
 	delta_y = WRAP_DELTA_Y (delta_y);
 	desired_thrust_angle = ARCTAN (delta_x, delta_y);
-
+	
 	maneuver_state = 0;
 	if (ShipPtr->turn_wait == 0)
 		maneuver_state |= LEFT | RIGHT;
 	if (ShipPtr->thrust_wait == 0
-			&& ((OtherObjPtr->state_flags & PLAYER_SHIP)
+		&& ((OtherObjPtr->state_flags & PLAYER_SHIP)
 			|| elementsOfSamePlayer (OtherObjPtr, ShipPtr)
-			|| OtherObjPtr->preprocess_func == crew_preprocess))
+			|| OtherObjPtr->preprocess_func == crew_preprocess
+			)
+		)
 		maneuver_state |= THRUST;
-
+	
 	desired_turn_angle = NORMALIZE_ANGLE (desired_thrust_angle + HALF_CIRCLE);
-		/* other player's ship */
+	/* other player's ship */
 	if ((OtherObjPtr->state_flags & PLAYER_SHIP)
-			&& OtherObjPtr->mass_points <= MAX_SHIP_MASS)
+		&& OtherObjPtr->mass_points <= MAX_SHIP_MASS)
 	{
 		STARSHIP *StarShipPtr;
 		STARSHIP *EnemyStarShipPtr;
-
+		
 		GetElementStarShip (ShipPtr, &StarShipPtr);
 		GetElementStarShip (OtherObjPtr, &EnemyStarShipPtr);
 		if ((MANEUVERABILITY (
-				&StarShipPtr->RaceDescPtr->cyborg_control
-				) >= FAST_SHIP
-				&& WEAPON_RANGE (&StarShipPtr->RaceDescPtr->cyborg_control)
-				> CLOSE_RANGE_WEAPON)
-				|| (EvalDescPtr->which_turn >= 24
+							  &StarShipPtr->RaceDescPtr->cyborg_control
+							  ) >= RESOLUTION_COMPENSATED(FAST_SHIP) // JMS_GFX
+			 && WEAPON_RANGE (&StarShipPtr->RaceDescPtr->cyborg_control)
+			 > (CLOSE_RANGE_WEAPON << RESOLUTION_FACTOR)) // JMS_GFX
+			|| (EvalDescPtr->which_turn >= 24
 				&& (StarShipPtr->RaceDescPtr->characteristics.max_thrust * 2 / 3 <
-				EnemyStarShipPtr->RaceDescPtr->characteristics.max_thrust
-				|| (EnemyStarShipPtr->cur_status_flags & SHIP_BEYOND_MAX_SPEED))))
+					EnemyStarShipPtr->RaceDescPtr->characteristics.max_thrust
+					|| (EnemyStarShipPtr->cur_status_flags & SHIP_BEYOND_MAX_SPEED))))
 		{
 			UWORD ship_flags;
-
+			
 			ship_flags = EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags;
-						/* you're maneuverable */
+			/* you're maneuverable */
 			if (MANEUVERABILITY (
-					&StarShipPtr->RaceDescPtr->cyborg_control
-					) >= MEDIUM_SHIP)
+				&StarShipPtr->RaceDescPtr->cyborg_control
+				) >= RESOLUTION_COMPENSATED(MEDIUM_SHIP)) // JMS_GFX
 			{
 				UWORD fire_flags;
 				COUNT facing;
-
+				
 				for (fire_flags = FIRES_FORE, facing = EvalDescPtr->facing;
-						fire_flags <= FIRES_LEFT;
-						fire_flags <<= 1, facing += QUADRANT)
+					 fire_flags <= FIRES_LEFT;
+					 fire_flags <<= 1, facing += QUADRANT)
 				{
 					if
-					(
-							/* he's dangerous in this direction */
-						(ship_flags & fire_flags)
-							/* he's facing direction you want to go */
-						&& NORMALIZE_ANGLE (
-						desired_turn_angle - facing + OCTANT
-						) <= QUADRANT
-						&& (
-							/* he's moving */
-						(other_delta_x != 0 || other_delta_y != 0)
-						&&
-							/* he's coasting backwards */
-						NORMALIZE_ANGLE (
-						(GetVelocityTravelAngle (&OtherVelocity) + HALF_CIRCLE)
-						- facing + (OCTANT + (OCTANT >> 1)))
-						<= ((OCTANT + (OCTANT >> 1)) << 1))
-					)
+						(
+						 /* he's dangerous in this direction */
+						 (ship_flags & fire_flags)
+						 /* he's facing direction you want to go */
+						 && NORMALIZE_ANGLE (
+							desired_turn_angle - facing + OCTANT) <= QUADRANT
+						 && (
+							 /* he's moving */
+							 (other_delta_x != 0 || other_delta_y != 0)
+							 &&
+							 /* he's coasting backwards */
+							 NORMALIZE_ANGLE (
+								(GetVelocityTravelAngle (&OtherVelocity) + HALF_CIRCLE)
+								- facing + (OCTANT + (OCTANT >> 1)))
+							 <= ((OCTANT + (OCTANT >> 1)) << 1))
+						 )
 					{
-							/* catch him on the back side */
+						/* catch him on the back side */
 						desired_thrust_angle = desired_turn_angle;
 						break;
 					}
 				}
 			}
-
+			
+			// This code prevents Kohr-Ah, Ur-Quan and ISD from turning around mid-chase while pursuing Earthling.
+			if (StarShipPtr->SpeciesID == (KOHR_AH_ID | UR_QUAN_ID)
+				&& EnemyStarShipPtr->SpeciesID == EARTHLING_ID 
+				&& !(EnemyStarShipPtr->cur_status_flags & (SHIP_BEYOND_MAX_SPEED | SHIP_IN_GRAVITY_WELL)))
+				distance_to_give_up_and_turn = 44;
+			else
+				distance_to_give_up_and_turn = 24;
+			
 			if (desired_thrust_angle != desired_turn_angle
-					&& (other_delta_x || other_delta_y)
-					&& EvalDescPtr->which_turn >= 24
-					&& NORMALIZE_ANGLE (desired_thrust_angle
-					- GetVelocityTravelAngle (&OtherVelocity)
-					+ OCTANT) <= QUADRANT
-					&& ((NORMALIZE_ANGLE (
-					GetVelocityTravelAngle (&OtherVelocity)
-					- GetVelocityTravelAngle (&ShipVelocity)
-					+ OCTANT) <= QUADRANT
-					&& (((StarShipPtr->cur_status_flags & SHIP_AT_MAX_SPEED)
-					&& !(StarShipPtr->cur_status_flags & SHIP_BEYOND_MAX_SPEED))
-					|| (ship_flags & DONT_CHASE)))
+				&& (other_delta_x || other_delta_y)
+				&& EvalDescPtr->which_turn >= distance_to_give_up_and_turn
+				&& NORMALIZE_ANGLE (desired_thrust_angle
+									- GetVelocityTravelAngle (&OtherVelocity)
+									+ OCTANT) <= QUADRANT
+				&& ((NORMALIZE_ANGLE (
+									  GetVelocityTravelAngle (&OtherVelocity)
+									  - GetVelocityTravelAngle (&ShipVelocity)
+									  + OCTANT) <= QUADRANT
+					 && (((StarShipPtr->cur_status_flags & SHIP_AT_MAX_SPEED)
+						  && !(StarShipPtr->cur_status_flags & SHIP_BEYOND_MAX_SPEED))
+						 || (ship_flags & DONT_CHASE)))
 					|| NORMALIZE_ANGLE (
-					desired_turn_angle
-					- FACING_TO_ANGLE (StarShipPtr->ShipFacing)
-					+ OCTANT) <= QUADRANT))
+										desired_turn_angle
+										- FACING_TO_ANGLE (StarShipPtr->ShipFacing)
+										+ OCTANT) <= QUADRANT))
 				desired_thrust_angle = desired_turn_angle;
 		}
 	}
-
+	
 	if (maneuver_state & (LEFT | RIGHT))
 		TurnShip (ShipPtr, desired_thrust_angle);
-
+	
 	if (maneuver_state & THRUST)
 		ThrustShip (ShipPtr, desired_thrust_angle);
 }
 
+// JMS:GFX Made SIZEs SDWORDs and changed the GetNextVelocityComponents to GetNextVelocityComponentsSdword
 void
 Entice (ELEMENT *ShipPtr, EVALUATE_DESC *EvalDescPtr)
 {
 	BYTE maneuver_state;
 	COUNT desired_thrust_angle, desired_turn_angle;
 	COUNT cone_of_fire, travel_angle;
-	SIZE delta_x, delta_y;
-	SIZE ship_delta_x, ship_delta_y;
-	SIZE other_delta_x, other_delta_y;
+	SDWORD delta_x, delta_y;
+	SDWORD ship_delta_x, ship_delta_y;
+	SDWORD other_delta_x, other_delta_y;
 	ELEMENT *OtherObjPtr;
 	VELOCITY_DESC ShipVelocity, OtherVelocity;
 	STARSHIP *StarShipPtr;
 	RACE_DESC *RDPtr;
-
+	
 	ShipVelocity = ShipPtr->velocity;
-	GetNextVelocityComponents (&ShipVelocity,
-			&ship_delta_x, &ship_delta_y, EvalDescPtr->which_turn);
+	GetNextVelocityComponentsSdword (&ShipVelocity,
+		&ship_delta_x, &ship_delta_y, EvalDescPtr->which_turn);
 	ShipPtr->next.location.x =
-			ShipPtr->current.location.x + ship_delta_x;
+		ShipPtr->current.location.x + ship_delta_x;
 	ShipPtr->next.location.y =
-			ShipPtr->current.location.y + ship_delta_y;
-
+		ShipPtr->current.location.y + ship_delta_y;
+	
 	OtherObjPtr = EvalDescPtr->ObjectPtr;
 	OtherVelocity = OtherObjPtr->velocity;
-	GetNextVelocityComponents (&OtherVelocity,
-			&other_delta_x, &other_delta_y, EvalDescPtr->which_turn);
-
+	GetNextVelocityComponentsSdword (&OtherVelocity,
+		&other_delta_x, &other_delta_y, EvalDescPtr->which_turn);
+	
 	delta_x = (OtherObjPtr->current.location.x + other_delta_x)
-			- ShipPtr->next.location.x;
+		- ShipPtr->next.location.x;
 	delta_y = (OtherObjPtr->current.location.y + other_delta_y)
-			- ShipPtr->next.location.y;
+		- ShipPtr->next.location.y;
 	delta_x = WRAP_DELTA_X (delta_x);
 	delta_y = WRAP_DELTA_Y (delta_y);
 	desired_thrust_angle = ARCTAN (delta_x, delta_y);
-
+	
 	maneuver_state = 0;
 	if (ShipPtr->turn_wait == 0)
 		maneuver_state |= LEFT | RIGHT;
 	if (ShipPtr->thrust_wait == 0)
 		maneuver_state |= THRUST;
-
+	
 	delta_x = ship_delta_x - other_delta_x;
 	delta_y = ship_delta_y - other_delta_y;
 	travel_angle = ARCTAN (delta_x, delta_y);
 	desired_turn_angle = NORMALIZE_ANGLE (desired_thrust_angle + HALF_CIRCLE);
-
+	
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	RDPtr = StarShipPtr->RaceDescPtr;
 	if (EvalDescPtr->MoveState == AVOID)
 	{
 		desired_turn_angle =
-				NORMALIZE_ANGLE (desired_turn_angle - EvalDescPtr->facing);
-
+		NORMALIZE_ANGLE (desired_turn_angle - EvalDescPtr->facing);
+		
 		if (NORMALIZE_FACING (ANGLE_TO_FACING (desired_turn_angle)))
 		{
 			if (desired_turn_angle <= HALF_CIRCLE)
@@ -757,162 +788,156 @@ Entice (ELEMENT *ShipPtr, EVALUATE_DESC
 		else
 		{
 			desired_turn_angle = NORMALIZE_ANGLE (
-					FACING_TO_ANGLE (StarShipPtr->ShipFacing)
-					- EvalDescPtr->facing
-					);
+				FACING_TO_ANGLE (StarShipPtr->ShipFacing)
+				- EvalDescPtr->facing);
 			if ((desired_turn_angle & (HALF_CIRCLE - 1)) == 0)
 				desired_thrust_angle = TFB_Random () & 1 ? RIGHT : LEFT;
 			else
 				desired_thrust_angle = desired_turn_angle < HALF_CIRCLE ? RIGHT : LEFT;
 		}
-
+		
 		if (desired_thrust_angle == LEFT)
 		{
 #define FLANK_LEFT -QUADRANT
 #define SHIP_LEFT -OCTANT
 			desired_thrust_angle = EvalDescPtr->facing
-					+ FLANK_LEFT - (SHIP_LEFT >> 1);
+			+ FLANK_LEFT - (SHIP_LEFT >> 1);
 		}
 		else
 		{
 #define FLANK_RIGHT QUADRANT
 #define SHIP_RIGHT OCTANT
 			desired_thrust_angle = EvalDescPtr->facing
-					+ FLANK_RIGHT - (SHIP_RIGHT >> 1);
+			+ FLANK_RIGHT - (SHIP_RIGHT >> 1);
 		}
-
+		
 		desired_thrust_angle = NORMALIZE_ANGLE (desired_thrust_angle);
 	}
 	else if (GRAVITY_MASS (OtherObjPtr->mass_points))
 	{
 		COUNT planet_facing;
-
+		
 		planet_facing = NORMALIZE_FACING (ANGLE_TO_FACING (desired_thrust_angle));
-		cone_of_fire = NORMALIZE_FACING (
-				planet_facing
-				- StarShipPtr->ShipFacing
-				+ ANGLE_TO_FACING (QUADRANT));
-
+		cone_of_fire = NORMALIZE_FACING (planet_facing - StarShipPtr->ShipFacing
+			+ ANGLE_TO_FACING (QUADRANT));
+		
 		if (RDPtr->characteristics.thrust_increment !=
-				RDPtr->characteristics.max_thrust)
+			RDPtr->characteristics.max_thrust)
 			maneuver_state &= ~THRUST;
-
-				/* if not pointing towards planet */
+		
+		/* if not pointing towards planet */
 		if (cone_of_fire > ANGLE_TO_FACING (QUADRANT << 1))
 			desired_turn_angle = desired_thrust_angle;
-				/* if pointing directly at planet */
+		/* if pointing directly at planet */
 		else if (cone_of_fire == ANGLE_TO_FACING (QUADRANT)
-				&& NORMALIZE_FACING (ANGLE_TO_FACING (travel_angle)) != planet_facing)
+				 && NORMALIZE_FACING (ANGLE_TO_FACING (travel_angle)) != planet_facing)
 			desired_turn_angle = travel_angle;
 		else if (cone_of_fire == 0
-				|| cone_of_fire == ANGLE_TO_FACING (QUADRANT << 1)
-				|| (!(maneuver_state & THRUST)
-				&& (cone_of_fire < ANGLE_TO_FACING (OCTANT)
-				|| cone_of_fire > ANGLE_TO_FACING ((QUADRANT << 1) - OCTANT))))
+				 || cone_of_fire == ANGLE_TO_FACING (QUADRANT << 1)
+				 || (!(maneuver_state & THRUST)
+					 && (cone_of_fire < ANGLE_TO_FACING (OCTANT)
+						 || cone_of_fire > ANGLE_TO_FACING ((QUADRANT << 1) - OCTANT))))
 		{
 			desired_turn_angle = FACING_TO_ANGLE (StarShipPtr->ShipFacing);
 			if (NORMALIZE_ANGLE (desired_turn_angle
-					- travel_angle + QUADRANT) > HALF_CIRCLE)
+								 - travel_angle + QUADRANT) > HALF_CIRCLE)
 				desired_turn_angle = travel_angle;
 			if (ShipPtr->thrust_wait == 0)
 				maneuver_state |= THRUST;
 		}
-
+		
 		desired_thrust_angle = desired_turn_angle;
 	}
 	else
 	{
 		COUNT WRange;
-
+		
 		WRange = WEAPON_RANGE (
-				&RDPtr->cyborg_control
-				);
-
+							   &RDPtr->cyborg_control
+							   );
+		
 		cone_of_fire = NORMALIZE_ANGLE (desired_turn_angle
-				- EvalDescPtr->facing + OCTANT);
+										- EvalDescPtr->facing + OCTANT);
 		if (OtherObjPtr->state_flags & PLAYER_SHIP)
 		{
 			UWORD fire_flags, ship_flags;
 			COUNT facing;
 			STARSHIP *EnemyStarShipPtr;
-
+			
 			GetElementStarShip (OtherObjPtr, &EnemyStarShipPtr);
 			ship_flags = EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags;
 			for (fire_flags = FIRES_FORE, facing = EvalDescPtr->facing;
-					fire_flags <= FIRES_LEFT;
-					fire_flags <<= 1, facing += QUADRANT)
+				 fire_flags <= FIRES_LEFT;
+				 fire_flags <<= 1, facing += QUADRANT)
 			{
 				if
-				(
-						/* he's dangerous in this direction */
-					(ship_flags & fire_flags)
-						/* he's facing direction you want to go */
-					&& (cone_of_fire = NORMALIZE_ANGLE (
-					desired_turn_angle - facing + OCTANT
-					)) <= QUADRANT
-						/* he's moving */
-					&& ((other_delta_x != 0 || other_delta_y != 0)
-						/* he's coasting backwards */
-					&& NORMALIZE_ANGLE (
-					(GetVelocityTravelAngle (&OtherVelocity) + HALF_CIRCLE)
-					- facing + OCTANT) <= QUADRANT)
-				)
-				{
-						/* need to be close for a kill */
-					if (WRange < LONG_RANGE_WEAPON
-							&& EvalDescPtr->which_turn <= 32)
+					(
+					 /* he's dangerous in this direction */
+					 (ship_flags & fire_flags)
+					 /* he's facing direction you want to go */
+					 && (cone_of_fire = NORMALIZE_ANGLE (
+						desired_turn_angle - facing + OCTANT)) <= QUADRANT
+					 /* he's moving */
+					 && ((other_delta_x != 0 || other_delta_y != 0)
+						 /* he's coasting backwards */
+						 && NORMALIZE_ANGLE (
+											 (GetVelocityTravelAngle (&OtherVelocity) + HALF_CIRCLE)
+											 - facing + OCTANT) <= QUADRANT)
+					 )
+				{
+					/* need to be close for a kill */
+					if (WRange < (LONG_RANGE_WEAPON << RESOLUTION_FACTOR)
+						&& EvalDescPtr->which_turn <= 32)
 					{
 						/* catch him on the back side */
 						desired_thrust_angle = desired_turn_angle;
 						goto DoManeuver;
 					}
-
+					
 					break;
 				}
 			}
-
+			
 			if (EvalDescPtr->which_turn <= 8
-					&& RDPtr->characteristics.max_thrust <=
-					EnemyStarShipPtr->RaceDescPtr->characteristics.max_thrust)
+				&& RDPtr->characteristics.max_thrust <=
+				EnemyStarShipPtr->RaceDescPtr->characteristics.max_thrust)
 				goto DoManeuver;
 		}
-
+		
 		if
-		(
+			(
 #ifdef NOTYET
-			WRange < LONG_RANGE_WEAPON
-			&&
+			 WRange < (LONG_RANGE_WEAPON << RESOLUTION_FACTOR)
+			 &&
 #endif /* NOTYET */
-					/* not at full speed */
-			!(StarShipPtr->cur_status_flags
-			& (SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED))
-			&& (PlotIntercept (
-					ShipPtr, OtherObjPtr, 40, CLOSE_RANGE_WEAPON << 1
-					)
+			 /* not at full speed */
+			 !(StarShipPtr->cur_status_flags
+			   & (SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED))
+			 && (PlotIntercept (ShipPtr, OtherObjPtr, 40, (CLOSE_RANGE_WEAPON << RESOLUTION_FACTOR) << 1) // JMS_GFX
 #ifdef NOTYET
-			||
-			(
-					/* object's facing direction you want to go */
-				cone_of_fire <= QUADRANT
-					/* and you're basically going in that direction */
-				&& (travel_angle == FULL_CIRCLE
-				|| NORMALIZE_ANGLE (travel_angle
-				- desired_thrust_angle + QUADRANT) <= HALF_CIRCLE)
-					/* and object's in range */
-				&& PlotIntercept (ShipPtr, OtherObjPtr, 1, WRange)
-			)
+				 ||
+				 (
+				  /* object's facing direction you want to go */
+				  cone_of_fire <= QUADRANT
+				  /* and you're basically going in that direction */
+				  && (travel_angle == FULL_CIRCLE
+					  || NORMALIZE_ANGLE (travel_angle
+										  - desired_thrust_angle + QUADRANT) <= HALF_CIRCLE)
+				  /* and object's in range */
+				  && PlotIntercept (ShipPtr, OtherObjPtr, 1, WRange)
+				  )
 #endif /* NOTYET */
-			)
-		)
+				 )
+			 )
 		{
 			if
-			(
-					/* pointed straight at him */
-				NORMALIZE_ANGLE (desired_thrust_angle
-				- FACING_TO_ANGLE (StarShipPtr->ShipFacing) + OCTANT) <= QUADRANT
-					/* or not exposed to business end */
-				|| cone_of_fire > QUADRANT
-			)
+				(
+				 /* pointed straight at him */
+				 NORMALIZE_ANGLE (desired_thrust_angle
+								  - FACING_TO_ANGLE (StarShipPtr->ShipFacing) + OCTANT) <= QUADRANT
+				 /* or not exposed to business end */
+				 || cone_of_fire > QUADRANT
+				 )
 			{
 				desired_thrust_angle = desired_turn_angle;
 			}
@@ -920,78 +945,76 @@ Entice (ELEMENT *ShipPtr, EVALUATE_DESC
 			{
 #ifdef NOTYET
 				if
-				(
-					travel_angle != FULL_CIRCLE
-					&& NORMALIZE_ANGLE (travel_angle
-					- desired_turn_angle + OCTANT) <= QUADRANT
-				)
+					(
+					 travel_angle != FULL_CIRCLE
+					 && NORMALIZE_ANGLE (travel_angle
+										 - desired_turn_angle + OCTANT) <= QUADRANT
+					 )
 				{
 					desired_turn_angle =
-							NORMALIZE_ANGLE ((EvalDescPtr->facing + HALF_CIRCLE)
-							+ (travel_angle - desired_turn_angle));
+					NORMALIZE_ANGLE ((EvalDescPtr->facing + HALF_CIRCLE)
+									 + (travel_angle - desired_turn_angle));
 					if (!(maneuver_state & (LEFT | RIGHT)))
 						maneuver_state &= ~THRUST;
 				}
-
+				
 				if (maneuver_state & (LEFT | RIGHT))
 				{
 					TurnShip (ShipPtr, desired_turn_angle);
 					maneuver_state &= ~(LEFT | RIGHT);
 				}
 #endif /* NOTYET */
-
+				
 				desired_thrust_angle = FACING_TO_ANGLE (StarShipPtr->ShipFacing);
-desired_turn_angle = desired_thrust_angle;
+				desired_turn_angle = desired_thrust_angle;
 			}
 		}
 		else if ((cone_of_fire = PlotIntercept (
-				ShipPtr, OtherObjPtr, 10, WRange
+												ShipPtr, OtherObjPtr, 10, WRange
 #ifdef OLD
-				- (WRange >> 3)
+												- (WRange >> 3)
 #else /* !OLD */
-				- (WRange >> 2)
+												- (WRange >> 2)
 #endif /* OLD */
-				)))
+												)))
 		{
 			if (RDPtr->characteristics.thrust_increment !=
-					RDPtr->characteristics.max_thrust
-							/* and already at full speed */
-					&& (StarShipPtr->cur_status_flags
+				RDPtr->characteristics.max_thrust
+				/* and already at full speed */
+				&& (StarShipPtr->cur_status_flags
 					& (SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED))
-							/* and facing away from enemy */
-					&& (NORMALIZE_ANGLE (desired_turn_angle
-					- ARCTAN (ship_delta_x, ship_delta_y)
-					+ (OCTANT + 2)) <= ((OCTANT + 2) << 1)
-							/* or not on collision course */
-					|| !PlotIntercept (
-							ShipPtr, OtherObjPtr, 30, CLOSE_RANGE_WEAPON << 1
-							)))
+				/* and facing away from enemy */
+				&& (NORMALIZE_ANGLE (desired_turn_angle
+									 - ARCTAN (ship_delta_x, ship_delta_y)
+									 + (OCTANT + 2)) <= ((OCTANT + 2) << 1)
+					/* or not on collision course */
+					|| !PlotIntercept (ShipPtr, OtherObjPtr, 30, (CLOSE_RANGE_WEAPON << RESOLUTION_FACTOR) << 1))) // JMS_GFX
 				maneuver_state &= ~THRUST;
-					/* veer off */
+			/* veer off */
 			else if (cone_of_fire == 1
-					|| RDPtr->characteristics.thrust_increment !=
-					RDPtr->characteristics.max_thrust)
+					 || RDPtr->characteristics.thrust_increment !=
+					 RDPtr->characteristics.max_thrust)
 			{
 				if (maneuver_state & (LEFT | RIGHT))
 				{
 					TurnShip (ShipPtr, desired_turn_angle);
 					maneuver_state &= ~(LEFT | RIGHT);
 				}
-
+				
 				if (NORMALIZE_ANGLE (desired_thrust_angle
-						- ARCTAN (ship_delta_x, ship_delta_y)
-						+ (OCTANT + 2)) <= ((OCTANT + 2) << 1))
+									 - ARCTAN (ship_delta_x, ship_delta_y)
+									 + (OCTANT + 2)) <= ((OCTANT + 2) << 1))
 					desired_thrust_angle = FACING_TO_ANGLE (StarShipPtr->ShipFacing);
 				else
 					desired_thrust_angle = desired_turn_angle;
 			}
 		}
 	}
-
+	
 DoManeuver:
 	if (maneuver_state & (LEFT | RIGHT))
 		TurnShip (ShipPtr, desired_thrust_angle);
-
+	
 	if (maneuver_state & THRUST)
 		ThrustShip (ShipPtr, desired_thrust_angle);
 }
@@ -1016,49 +1039,48 @@ tactical_intelligence (ComputerInputCont
 	STARSHIP *EnemyStarShipPtr;
 	RACE_DESC *RDPtr;
 	RACE_DESC *EnemyRDPtr;
-
+	
 	RDPtr = StarShipPtr->RaceDescPtr;
-
+	
 	if (RDPtr->cyborg_control.ManeuverabilityIndex == 0)
 		InitCyborg (StarShipPtr);
-
+	
 	LockElement (StarShipPtr->hShip, &ShipPtr);
 	if (RDPtr->ship_info.crew_level == 0
-			|| GetPrimType (&DisplayArray[ShipPtr->PrimIndex]) == NO_PRIM)
+		|| GetPrimType (&DisplayArray[ShipPtr->PrimIndex]) == NO_PRIM)
 	{
 		UnlockElement (StarShipPtr->hShip);
 		return (0);
 	}
-
+	
 	ShipMoved = TRUE;
 	/* Disable ship's special completely for the Standard AI */
 	if (StarShipPtr->control & STANDARD_RATING)
 		++StarShipPtr->special_counter;
-
+	
 #ifdef DEBUG_CYBORG
-if (!(ShipPtr->state_flags & FINITE_LIFE)
+	if (!(ShipPtr->state_flags & FINITE_LIFE)
 		&& ShipPtr->life_span == NORMAL_LIFE)
-	ShipPtr->life_span += 2; /* make ship invulnerable */
+		ShipPtr->life_span += 2; /* make ship invulnerable */
 #endif /* DEBUG_CYBORG */
 	Ship = *ShipPtr;
 	UnlockElement (StarShipPtr->hShip);
 	ShipFacing = StarShipPtr->ShipFacing;
-
+	
 	for (ConcernCounter = 0;
-			ConcernCounter <= FIRST_EMPTY_INDEX; ++ConcernCounter)
+		 ConcernCounter <= FIRST_EMPTY_INDEX; ++ConcernCounter)
 	{
 		ObjectsOfConcern[ConcernCounter].ObjectPtr = 0;
 		ObjectsOfConcern[ConcernCounter].MoveState = NO_MOVEMENT;
 		ObjectsOfConcern[ConcernCounter].which_turn = (COUNT)~0;
 	}
 	--ConcernCounter;
-
+	
 	UltraManeuverable = (BOOLEAN)(
-			RDPtr->characteristics.thrust_increment ==
-			RDPtr->characteristics.max_thrust
-			&& MANEUVERABILITY (&RDPtr->cyborg_control) >= MEDIUM_SHIP
-			);
-
+		RDPtr->characteristics.thrust_increment == RDPtr->characteristics.max_thrust
+		&& MANEUVERABILITY (&RDPtr->cyborg_control) >= RESOLUTION_COMPENSATED(MEDIUM_SHIP) // JMS_GFX
+		);
+	
 	if (Ship.turn_wait == 0)
 	{
 		ShipMoved = FALSE;
@@ -1069,65 +1091,65 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 		ShipMoved = FALSE;
 		StarShipPtr->ship_input_state &= ~THRUST;
 	}
-
+	
 	for (hElement = GetHeadElement ();
-			hElement != 0; hElement = hNextElement)
+		 hElement != 0; hElement = hNextElement)
 	{
 		EVALUATE_DESC ed;
-
+		
 		ed.MoveState = NO_MOVEMENT;
-
+		
 		LockElement (hElement, &ed.ObjectPtr);
 		hNextElement = GetSuccElement (ed.ObjectPtr);
 		if (CollisionPossible (ed.ObjectPtr, &Ship))
 		{
-			SIZE dx, dy;
-
+			SDWORD dx, dy;
+			
 			dx = ed.ObjectPtr->next.location.x
-					- Ship.next.location.x;
+				- Ship.next.location.x;
 			dy = ed.ObjectPtr->next.location.y
-					- Ship.next.location.y;
+				- Ship.next.location.y;
 			dx = WRAP_DELTA_X (dx);
 			dy = WRAP_DELTA_Y (dy);
 			if (GRAVITY_MASS (ed.ObjectPtr->mass_points))
 			{
 				COUNT maneuver_turn, ship_bounds;
-				RECT ship_footprint = {{0, 0}, {0, 0}};
-
+				RECT ship_footprint;
+				
 				if (UltraManeuverable)
 					maneuver_turn = 16;
-				else if (MANEUVERABILITY (&RDPtr->cyborg_control) <= MEDIUM_SHIP)
+				else if (MANEUVERABILITY (&RDPtr->cyborg_control) <= RESOLUTION_COMPENSATED(MEDIUM_SHIP)) // JMS_GFX
 					maneuver_turn = 48;
 				else
 					maneuver_turn = 32;
-
+				
 				GetFrameRect (SetAbsFrameIndex (
-						Ship.IntersectControl.IntersectStamp.frame, 0
-						), &ship_footprint);
+												Ship.IntersectControl.IntersectStamp.frame, 0
+												), &ship_footprint);
 				ship_bounds = (COUNT)(ship_footprint.extent.width
-						+ ship_footprint.extent.height);
-
+									  + ship_footprint.extent.height);
+				
 				if (!ShipMoved && (ed.which_turn =
-						PlotIntercept (ed.ObjectPtr, &Ship, maneuver_turn,
-						DISPLAY_TO_WORLD (30 + (ship_bounds * 3 /* << 2 */)))))
+								   PlotIntercept (ed.ObjectPtr, &Ship, maneuver_turn,
+												  DISPLAY_TO_WORLD ((30 << RESOLUTION_FACTOR) + (ship_bounds * 3 /* << 2 */))))) // JMS_GFX
 				{
 					if (ed.which_turn > 1
-							|| PlotIntercept (ed.ObjectPtr, &Ship, 1,
-							DISPLAY_TO_WORLD (35 + ship_bounds))
-							|| PlotIntercept (ed.ObjectPtr, &Ship,
-							maneuver_turn << 1,
-							DISPLAY_TO_WORLD (40 + ship_bounds)) > 1)
+						|| PlotIntercept (ed.ObjectPtr, &Ship, 1,
+										  DISPLAY_TO_WORLD ((35 << RESOLUTION_FACTOR) + ship_bounds)) // JMS_GFX
+						|| PlotIntercept (ed.ObjectPtr, &Ship,
+										  maneuver_turn << 1,
+										  DISPLAY_TO_WORLD ((40 << RESOLUTION_FACTOR) + ship_bounds)) > 1) // JMS_GFX
 					{
 						ed.facing = ARCTAN (-dx, -dy);
 						if (UltraManeuverable)
 							ed.MoveState = AVOID;
 						else // Try a gravity whip
 							ed.MoveState = ENTICE;
-
+						
 						ObjectsOfConcern[GRAVITY_MASS_INDEX] = ed;
 					}
 					else if (!UltraManeuverable &&
-							!IsVelocityZero (&Ship.velocity))
+							 !IsVelocityZero (&Ship.velocity))
 					{	// Try an orbital insertion, don't thrust
 						++Ship.thrust_wait;
 						if (Ship.turn_wait)
@@ -1141,54 +1163,56 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 				EnemyRDPtr = EnemyStarShipPtr->RaceDescPtr;
 				if (EnemyRDPtr->cyborg_control.ManeuverabilityIndex == 0)
 					InitCyborg (EnemyStarShipPtr);
-
-				ed.which_turn = WORLD_TO_TURN (
-						square_root ((long)dx * dx + (long)dy * dy));
-				if (ed.which_turn >
-						ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn)
+				
+				ed.which_turn = (WORLD_TO_TURN (square_root ((long)dx * dx + (long)dy * dy)));
+				
+				//log_add(log_Debug,"SQR:%d (dx:%d), (dy:%d), norm:%d rezzed:%d", square_root ((long)dx * dx + (long)dy * dy), dx, dy, (WORLD_TO_TURN (square_root ((long)dx * dx + (long)dy * dy))), ed.which_turn);
+				
+				if ((ed.which_turn >> RESOLUTION_FACTOR) > ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn)
 				{
 					UnlockElement (hElement);
 					continue;
 				}
 				else if (ed.which_turn == 0)
 					ed.which_turn = 1;
-
+				
+				ed.which_turn >>= RESOLUTION_FACTOR; // JMS_GFX
+				
 				ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr = ed.ObjectPtr;
 				ObjectsOfConcern[ENEMY_SHIP_INDEX].facing =
 #ifdef MAYBE
-						OBJECT_CLOAKED (ed.ObjectPtr) ?
-						GetVelocityTravelAngle (&ed.ObjectPtr->velocity) :
+				OBJECT_CLOAKED (ed.ObjectPtr) ? GetVelocityTravelAngle (&ed.ObjectPtr->velocity) :
 #endif /* MAYBE */
-						FACING_TO_ANGLE (EnemyStarShipPtr->ShipFacing);
+				FACING_TO_ANGLE (EnemyStarShipPtr->ShipFacing);
 				ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn = ed.which_turn;
-
+				
 				if (ShipMoved
-						|| ed.ObjectPtr->mass_points > MAX_SHIP_MASS
-						|| (WEAPON_RANGE (&RDPtr->cyborg_control) < LONG_RANGE_WEAPON
-						&& (WEAPON_RANGE (&RDPtr->cyborg_control) <= CLOSE_RANGE_WEAPON
-						|| (WEAPON_RANGE (&EnemyRDPtr->cyborg_control) >= LONG_RANGE_WEAPON
-						&& (EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags & SEEKING_WEAPON))
-						|| (
+					|| ed.ObjectPtr->mass_points > MAX_SHIP_MASS
+					|| (WEAPON_RANGE (&RDPtr->cyborg_control) < (LONG_RANGE_WEAPON << RESOLUTION_FACTOR)
+						&& (WEAPON_RANGE (&RDPtr->cyborg_control) <= (CLOSE_RANGE_WEAPON << RESOLUTION_FACTOR)
+							|| (WEAPON_RANGE (&EnemyRDPtr->cyborg_control) >= (LONG_RANGE_WEAPON << RESOLUTION_FACTOR)
+								&& (EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags & SEEKING_WEAPON))
+							|| (
 #ifdef OLD
-						MANEUVERABILITY (&RDPtr->cyborg_control) <
-						MANEUVERABILITY (&EnemyRDPtr->cyborg_control)
+								MANEUVERABILITY (&RDPtr->cyborg_control) <
+								MANEUVERABILITY (&EnemyRDPtr->cyborg_control)
 #else /* !OLD */
-						RDPtr->characteristics.max_thrust <
-						EnemyRDPtr->characteristics.max_thrust
+								RDPtr->characteristics.max_thrust <
+								EnemyRDPtr->characteristics.max_thrust
 #endif /* !OLD */
-						&& WEAPON_RANGE (&RDPtr->cyborg_control) <
-						WEAPON_RANGE (&EnemyRDPtr->cyborg_control)))))
+								&& WEAPON_RANGE (&RDPtr->cyborg_control) <
+								WEAPON_RANGE (&EnemyRDPtr->cyborg_control)))))
 					ObjectsOfConcern[ENEMY_SHIP_INDEX].MoveState = PURSUE;
 				else
 					ObjectsOfConcern[ENEMY_SHIP_INDEX].MoveState = ENTICE;
-
+				
 				if ((EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags & IMMEDIATE_WEAPON)
-						&& ship_weapons (ed.ObjectPtr, &Ship, 0))
+					&& ship_weapons (ed.ObjectPtr, &Ship, 0))
 				{
 					ed.which_turn = 1;
 					ed.MoveState = AVOID;
 					ed.facing = ObjectsOfConcern[ENEMY_SHIP_INDEX].facing;
-
+					
 					ObjectsOfConcern[ENEMY_WEAPON_INDEX] = ed;
 				}
 			}
@@ -1196,64 +1220,49 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 			{
 				if (!(ed.ObjectPtr->state_flags & FINITE_LIFE))
 				{
-					ed.which_turn = WORLD_TO_TURN (
-							square_root ((long)dx * dx + (long)dy * dy)
-							);
-
-					if (ed.which_turn <
-							ObjectsOfConcern[FIRST_EMPTY_INDEX].which_turn)
+					ed.which_turn = (WORLD_TO_TURN (square_root ((long)dx * dx + (long)dy * dy))) >> RESOLUTION_FACTOR; // JMS_GFX
+					
+					if (ed.which_turn < ObjectsOfConcern[FIRST_EMPTY_INDEX].which_turn)
 					{
 						ed.MoveState = PURSUE;
 						ed.facing = GetVelocityTravelAngle (
-								&ed.ObjectPtr->velocity
-								);
-
+									&ed.ObjectPtr->velocity);
+						
 						ObjectsOfConcern[FIRST_EMPTY_INDEX] = ed;
 					}
 				}
 			}
 			else if (!elementsOfSamePlayer (ed.ObjectPtr, &Ship)
-					&& ed.ObjectPtr->preprocess_func != crew_preprocess
-					&& ObjectsOfConcern[ENEMY_WEAPON_INDEX].which_turn > 1
-					&& ed.ObjectPtr->life_span > 0)
+					 && ed.ObjectPtr->preprocess_func != crew_preprocess
+					 && ObjectsOfConcern[ENEMY_WEAPON_INDEX].which_turn > 1
+					 && ed.ObjectPtr->life_span > 0)
 			{
 				GetElementStarShip (ed.ObjectPtr, &EnemyStarShipPtr);
 				EnemyRDPtr = EnemyStarShipPtr->RaceDescPtr;
 				if (((EnemyRDPtr->ship_info.ship_flags & SEEKING_WEAPON)
-						&& ed.ObjectPtr->next.image.farray !=
-						EnemyRDPtr->ship_data.special)
-						|| ((EnemyRDPtr->ship_info.ship_flags & SEEKING_SPECIAL)
+					 && ed.ObjectPtr->next.image.farray !=
+					 EnemyRDPtr->ship_data.special)
+					|| ((EnemyRDPtr->ship_info.ship_flags & SEEKING_SPECIAL)
 						&& ed.ObjectPtr->next.image.farray ==
 						EnemyRDPtr->ship_data.special))
 				{
 					if ((!(ed.ObjectPtr->state_flags & (FINITE_LIFE | CREW_OBJECT))
-							&& RDPtr->characteristics.max_thrust > DISPLAY_TO_WORLD (8))
-							|| NORMALIZE_ANGLE (GetVelocityTravelAngle (
-									&ed.ObjectPtr->velocity
-									) - ARCTAN (-dx, -dy)
-									+ QUADRANT) > HALF_CIRCLE)
+						 && RDPtr->characteristics.max_thrust > DISPLAY_TO_WORLD (8 << RESOLUTION_FACTOR)) // JMS_GFX
+						|| NORMALIZE_ANGLE (GetVelocityTravelAngle (
+							&ed.ObjectPtr->velocity
+							) - ARCTAN (-dx, -dy) + QUADRANT) > HALF_CIRCLE)
 						ed.which_turn = 0;
 					else
 					{
-						ed.which_turn = WORLD_TO_TURN (
-								square_root ((long)dx * dx + (long)dy * dy)
-								);
-
+						ed.which_turn = (WORLD_TO_TURN (square_root ((long)dx * dx + (long)dy * dy))) >> RESOLUTION_FACTOR; // JMS_GFX;
+						
 						ed.MoveState = ENTICE;
-						if (UltraManeuverable)
-						{
-							if (ed.which_turn == 0)
-								ed.which_turn = 1;
-							else if (ed.which_turn > 16)
-								ed.which_turn = 0;
-						}
-						else if (ed.which_turn == 0)
+						
+						if (ed.which_turn == 0)
 							ed.which_turn = 1;
-						else if (ed.which_turn > 16
-								|| (MANEUVERABILITY (
-								&RDPtr->cyborg_control
-								) > MEDIUM_SHIP
-								&& ed.which_turn > 8))
+						/* Shiver: The cap on which_turn for seeking weapons raised from 16 to 20.
+						 The horrible cap of 8 for above-medium speed ships has been obliterated. */
+						else if (ed.which_turn > 20)
 							ed.which_turn = 0;
 					}
 				}
@@ -1262,44 +1271,41 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 				else
 				{
 					ed.which_turn =
-							PlotIntercept (ed.ObjectPtr,
-							&Ship, ed.ObjectPtr->life_span,
-							DISPLAY_TO_WORLD (40));
+					PlotIntercept (ed.ObjectPtr,
+						&Ship, ed.ObjectPtr->life_span,
+						DISPLAY_TO_WORLD (40 << RESOLUTION_FACTOR)); // JMS_GFX
 					ed.MoveState = AVOID;
 				}
-
+				
 				if (ed.which_turn > 0
-						&& (ed.which_turn <
+					&& (ed.which_turn <
 						ObjectsOfConcern[ENEMY_WEAPON_INDEX].which_turn
 						|| (ed.which_turn ==
-						ObjectsOfConcern[ENEMY_WEAPON_INDEX].which_turn
-						&& ed.MoveState == AVOID)))
+							ObjectsOfConcern[ENEMY_WEAPON_INDEX].which_turn
+							&& ed.MoveState == AVOID)))
 				{
 					ed.facing = GetVelocityTravelAngle (
-							&ed.ObjectPtr->velocity
-							);
-
+									&ed.ObjectPtr->velocity);
+					
 					ObjectsOfConcern[ENEMY_WEAPON_INDEX] = ed;
 				}
 			}
 			else if ((ed.ObjectPtr->state_flags & CREW_OBJECT)
-					&& ((!(ed.ObjectPtr->state_flags & IGNORE_SIMILAR)
-					&& elementsOfSamePlayer (ed.ObjectPtr, &Ship))
-					|| ed.ObjectPtr->preprocess_func == crew_preprocess)
-					&& ObjectsOfConcern[CREW_OBJECT_INDEX].which_turn > 1)
+					 && ((!(ed.ObjectPtr->state_flags & IGNORE_SIMILAR)
+						  && elementsOfSamePlayer (ed.ObjectPtr, &Ship))
+						 || ed.ObjectPtr->preprocess_func == crew_preprocess)
+					 && ObjectsOfConcern[CREW_OBJECT_INDEX].which_turn > 1)
 			{
-				ed.which_turn = WORLD_TO_TURN (
-						square_root ((long)dx * dx + (long)dy * dy)
-						);
-
+				ed.which_turn = (WORLD_TO_TURN (square_root ((long)dx * dx + (long)dy * dy))) >> RESOLUTION_FACTOR; // JMS_GFX
+				
 				if (ed.which_turn == 0)
 					ed.which_turn = 1;
-
+				
 				if (ObjectsOfConcern[CREW_OBJECT_INDEX].which_turn >
-						ed.which_turn
-						&& (ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn > 32
+					ed.which_turn
+					&& (ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn > 32
 						|| (ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn > 8
-						&& StarShipPtr->hShip == ed.ObjectPtr->hTarget)))
+							&& StarShipPtr->hShip == ed.ObjectPtr->hTarget)))
 				{
 					ed.MoveState = PURSUE;
 					ed.facing = 0;
@@ -1309,17 +1315,17 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 		}
 		UnlockElement (hElement);
 	}
-
+	
 	RDPtr->cyborg_control.intelligence_func (&Ship, ObjectsOfConcern,
-			ConcernCounter);
+											 ConcernCounter);
 #ifdef DEBUG_CYBORG
-StarShipPtr->ship_input_state &= ~SPECIAL;
+	StarShipPtr->ship_input_state &= ~SPECIAL;
 #endif /* DEBUG_CYBORG */
-
+	
 	StarShipPtr->ShipFacing = ShipFacing;
 	{
 		BATTLE_INPUT_STATE InputState;
-
+		
 		InputState = 0;
 		if (StarShipPtr->ship_input_state & LEFT)
 			InputState |= BATTLE_LEFT;
@@ -1331,7 +1337,7 @@ StarShipPtr->ship_input_state &= ~SPECIA
 			InputState |= BATTLE_WEAPON;
 		if (StarShipPtr->ship_input_state & SPECIAL)
 			InputState |= BATTLE_SPECIAL;
-
+		
 		(void) context;
 		return (InputState);
 	}
diff -ruNp src.mm/uqm/element.h src/uqm/element.h
--- src.mm/uqm/element.h	2017-11-28 11:08:48 -0600
+++ src/uqm/element.h	2017-11-28 11:09:33 -0600
@@ -196,7 +196,7 @@ extern PRIMITIVE DisplayArray[MAX_DISPLA
 #define MAX_ENERGY_SIZE 42
 #define MAX_SHIP_MASS 10
 #define GRAVITY_MASS(m) ((m) > MAX_SHIP_MASS * 10)
-#define GRAVITY_THRESHOLD (COUNT)255
+#define GRAVITY_THRESHOLD (COUNT)(255 << RESOLUTION_FACTOR) // JMS_GFX
 
 #define OBJECT_CLOAKED(eptr) \
 		(GetPrimType (&GLOBAL (DisplayArray[(eptr)->PrimIndex])) >= NUM_PRIMS \
@@ -230,7 +230,7 @@ extern COUNT PlotIntercept (ELEMENT *Ele
 		ELEMENT *ElementPtr1, COUNT max_turns, COUNT margin_of_error);
 
 extern void InitGalaxy (void);
-extern void MoveGalaxy (VIEW_STATE view_state, SIZE dx, SIZE dy);
+extern void MoveGalaxy (VIEW_STATE view_state, SDWORD dx, SDWORD dy);
 
 extern BOOLEAN CalculateGravity (ELEMENT *ElementPtr);
 
diff -ruNp src.mm/uqm/encount.c src/uqm/encount.c
--- src.mm/uqm/encount.c	2017-11-28 11:08:48 -0600
+++ src/uqm/encount.c	2017-11-28 11:09:33 -0600
@@ -39,6 +39,7 @@
 #include "settings.h"
 #include "setup.h"
 #include "sounds.h"
+#include "util.h" // JMS: For SaveContextFrame()
 #include "libs/graphics/gfx_common.h"
 #include "libs/log.h"
 #include "libs/mathlib.h"
@@ -290,7 +291,7 @@ InitEncounter (void)
 
 //    t.baseline.x = SIS_SCREEN_WIDTH >> 1;
 	t.baseline.x = (SIS_SCREEN_WIDTH >> 1) + 1;
-	t.baseline.y = 10;
+	t.baseline.y = 10 << RESOLUTION_FACTOR; // JMS_GFX
 	t.align = ALIGN_CENTER;
 
 	SetContextFont (MicroFont);
@@ -302,7 +303,7 @@ InitEncounter (void)
 				// "ENCOUNTER IN"
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
-		t.baseline.y += 12;
+		t.baseline.y += 12 << RESOLUTION_FACTOR; // JMS_GFX
 		t.pStr = GAME_STRING (ENCOUNTER_STRING_BASE + 1);
 				// "DEEP SPACE"
 		t.CharCount = (COUNT)~0;
@@ -316,12 +317,12 @@ InitEncounter (void)
 				// "ENCOUNTER AT"
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
-		t.baseline.y += 12;
+		t.baseline.y += 12 << RESOLUTION_FACTOR; // JMS_GFX
 		GetClusterName (CurStarDescPtr, buf);
 		t.pStr = buf;
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
-		t.baseline.y += 12;
+		t.baseline.y += 12 << RESOLUTION_FACTOR; // JMS_GFX
 		t.pStr = GLOBAL_SIS (PlanetName);
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
@@ -371,9 +372,14 @@ InitEncounter (void)
 						+ (long)s.origin.y * s.origin.y)
 						+ ((i / NUM_DISPLAY_PTS) * 18);
 
+				radius <<= RESOLUTION_FACTOR; // JMS_GFX
+
 				angle = ARCTAN (s.origin.x, s.origin.y);
-				s.origin.x = COSINE (angle, radius);
-				s.origin.y = SINE (angle, radius);
+				s.origin.x = (COSINE (angle, radius));
+				s.origin.y = (SINE (angle, radius));
+			} else {
+				s.origin.x <<= RESOLUTION_FACTOR; // JMS_GFX
+				s.origin.y <<= RESOLUTION_FACTOR; // JMS_GFX
 			}
 			s.frame = SetAbsFrameIndex (FragPtr->icons, 0);
 			GetFrameRect (s.frame, &r);
@@ -414,6 +420,7 @@ DrawFadeText (const UNICODE *str1, const
 	SIZE i;
 	DWORD TimeIn;
 	TEXT t1, t2;
+	RECT r1, r2;
 	static const Color fade_cycle[] =
 	{
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0A, 0x0A, 0x0A), 0x1D),
@@ -426,13 +433,13 @@ DrawFadeText (const UNICODE *str1, const
 	};
 #define NUM_FADES (sizeof (fade_cycle) / sizeof (fade_cycle[0]))
 
-	t1.baseline.x = pRect->corner.x + 100;
-	t1.baseline.y = pRect->corner.y + 45;
+	t1.baseline.x = pRect->corner.x + (100 << RESOLUTION_FACTOR); // JMS_GFX
+	t1.baseline.y = pRect->corner.y + (45 << RESOLUTION_FACTOR); // JMS_GFX
 	t1.align = ALIGN_CENTER;
 	t1.pStr = str1;
 	t1.CharCount = (COUNT)~0;
 	t2 = t1;
-	t2.baseline.y += 11;
+	t2.baseline.y += 11 << RESOLUTION_FACTOR; // JMS_GFX
 	t2.pStr = str2;
 
 	FlushInput ();
@@ -465,9 +472,11 @@ DrawFadeText (const UNICODE *str1, const
 			TimeIn = GetTimeCounter ();
 		}
 		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
-		font_DrawText (&t1);
-		font_DrawText (&t2);
+				BUILD_COLOR_RGBA (0x50, 0x50, 0x50, 0xff));
+		TextRect(&t1, &r1, NULL);
+		TextRect(&t2, &r2, NULL);
+		DrawFilledRectangle (&r1);
+		DrawFilledRectangle (&r2);
 	}
 }
 
@@ -494,19 +503,19 @@ UninitEncounter (void)
 	else
 	{
 		BOOLEAN Sleepy;
-		SIZE VictoryState;
+		SIZE VictoryState, i;
 		COUNT RecycleAmount = 0;
-		SIZE i;
-		RECT r;
+		RECT r, save_r;
 		RECT scavenge_r = {{0, 0}, {0, 0}};
 		TEXT t;
-		STAMP ship_s;
+		STAMP ship_s, saveMetallicFrame;
 		const UNICODE *str1 = NULL;
 		const UNICODE *str2 = NULL;
 		StatMsgMode prevMsgMode;
 		UNICODE buf[80];
 		HSHIPFRAG hStarShip;
 		SHIP_FRAGMENT *FragPtr;
+
 		static const Color fade_ship_cycle[] =
 		{
 			BUILD_COLOR (MAKE_RGB15_INIT (0x07, 0x00, 0x00), 0x2F),
@@ -605,8 +614,8 @@ UninitEncounter (void)
 
 								DrawStatusMessage (NULL);
 								
-								ship_s.origin.x = scavenge_r.corner.x + 32;
-								ship_s.origin.y = scavenge_r.corner.y + 56;
+								ship_s.origin.x = scavenge_r.corner.x + (32 << RESOLUTION_FACTOR); // JMS_GFX
+								ship_s.origin.y = scavenge_r.corner.y + (56 << RESOLUTION_FACTOR); // JMS_GFX
 								ship_s.frame = IncFrameIndex (FragPtr->icons);
 								DrawStamp (&ship_s);
 								SetContextForeGroundColor (
@@ -633,13 +642,13 @@ UninitEncounter (void)
 									}
 								}
 
-								t.baseline.x = scavenge_r.corner.x + 100;
-								t.baseline.y = scavenge_r.corner.y + 68;
+								t.baseline.x = scavenge_r.corner.x + (100 << RESOLUTION_FACTOR); // JMS_GFX
+								t.baseline.y = scavenge_r.corner.y + (68 << RESOLUTION_FACTOR); // JMS_GFX
 								t.align = ALIGN_CENTER;
 								t.pStr = buf;
 								t.CharCount = (COUNT)~0;
 								font_DrawText (&t);
-								t.baseline.y += 6;
+								t.baseline.y += 6 << RESOLUTION_FACTOR; // JMS_GFX
 								t.pStr = GAME_STRING (
 										ENCOUNTER_STRING_BASE + 3);
 										// "BATTLE GROUP"
@@ -649,6 +658,24 @@ UninitEncounter (void)
 								ship_s.frame = FragPtr->icons;
 
 								SetContextFont (MicroFont);
+
+								// JMS: Let's store the rectangle behind "Enemy ships destroyed" (before drawing the text on it).
+								if (RESOLUTION_FACTOR != 0)
+								{
+									// These values are inferred from DrawFadeText.
+									// However, they're not the same (100 and 45) because the text there is centered,
+									// but these rect coords are for the upper-left corner, not center.
+									save_r.corner.x = scavenge_r.corner.x + (70 << RESOLUTION_FACTOR); // JMS_GFX
+									save_r.corner.y = scavenge_r.corner.y + (35 << RESOLUTION_FACTOR); // JMS_GFX
+									
+									// These are wild-assed guesses.
+									save_r.extent.width  = 60 << RESOLUTION_FACTOR;
+									save_r.extent.height = 30 << RESOLUTION_FACTOR; 
+									
+									// Now that we have the size and placement of the rectangle, let's store it.
+									saveMetallicFrame = SaveContextFrame (&save_r);
+								}
+
 								str1 = GAME_STRING (
 										ENCOUNTER_STRING_BASE + 4);
 										// "Enemy Ships"
@@ -658,23 +685,23 @@ UninitEncounter (void)
 								DrawFadeText (str1, str2, TRUE, &scavenge_r);
 							}
 
-							r.corner.y = scavenge_r.corner.y + 9;
-							r.extent.height = 22;
+							r.corner.y = scavenge_r.corner.y + (9 << RESOLUTION_FACTOR); // JMS_GFX
+							r.extent.height = 22 << RESOLUTION_FACTOR; // JMS_GFX
 
 							SetContextForeGroundColor (BLACK_COLOR);
 
-							r.extent.width = 34;
+							r.extent.width = 34 << RESOLUTION_FACTOR; // JMS_GFX
 							r.corner.x = scavenge_r.corner.x +
 									scavenge_r.extent.width
-									- (10 + r.extent.width);
+									- ((10 << RESOLUTION_FACTOR) + r.extent.width); // JMS_GFX
 							DrawFilledRectangle (&r);
 
 							/* collect bounty ResUnits */
 							j = race_bounty[EncounterRace] >> 3;
 							RecycleAmount += j;
 							sprintf (buf, "%u", RecycleAmount);
-							t.baseline.x = r.corner.x + r.extent.width - 1;
-							t.baseline.y = r.corner.y + 14;
+							t.baseline.x = r.corner.x + r.extent.width - 1 - 5 * RESOLUTION_FACTOR; // JMS_GFX;
+							t.baseline.y = r.corner.y + (14 << RESOLUTION_FACTOR); // JMS_GFX
 							t.align = ALIGN_RIGHT;
 							t.pStr = buf;
 							t.CharCount = (COUNT)~0;
@@ -684,17 +711,17 @@ UninitEncounter (void)
 							DeltaSISGauges (0, 0, j);
 
 							if ((VictoryState++ - 1) % MAX_DEAD_DISPLAYED)
-								ship_s.origin.x += 17;
+								ship_s.origin.x += (17 << RESOLUTION_FACTOR); // JMS_GFX
 							else
 							{
 								SetContextForeGroundColor (BLACK_COLOR);
 
-								r.corner.x = scavenge_r.corner.x + 10;
-								r.extent.width = 104;
+								r.corner.x = scavenge_r.corner.x + (10 << RESOLUTION_FACTOR); // JMS_GFX
+								r.extent.width = (104 << RESOLUTION_FACTOR); // JMS_GFX
 								DrawFilledRectangle (&r);
 
-								ship_s.origin.x = r.corner.x + 2;
-								ship_s.origin.y = scavenge_r.corner.y + 12;
+								ship_s.origin.x = r.corner.x + (2 << RESOLUTION_FACTOR); // JMS_GFX
+								ship_s.origin.y = scavenge_r.corner.y + (12 << RESOLUTION_FACTOR); // JMS_GFX
 							}
 
 							if (Sleepy)
@@ -714,6 +741,20 @@ UninitEncounter (void)
 									Time = GetTimeCounter ();
 								}
 							}
+
+							if (RESOLUTION_FACTOR > 0) {
+								SetContextForeGroundColor (BLACK_COLOR);
+								DrawFilledStamp (&ship_s);
+								DrawFilledStamp (&ship_s);
+								DrawFilledStamp (&ship_s);
+								DrawFilledStamp (&ship_s);
+								DrawFilledStamp (&ship_s);
+								DrawFilledStamp (&ship_s);
+								DrawFilledStamp (&ship_s);
+								DrawFilledStamp (&ship_s);
+								DrawFilledStamp (&ship_s);
+							}
+
 							DrawStamp (&ship_s);
 						}
 					}
@@ -743,13 +784,13 @@ UninitEncounter (void)
 				if (!CurrentInputState.key[PlayerControls[0]][KEY_ESCAPE])
 				{
 					SetContextForeGroundColor (BLACK_COLOR);
-					r.corner.x = scavenge_r.corner.x + 10;
-					r.extent.width = 132;
+					r.corner.x = scavenge_r.corner.x + (10 << RESOLUTION_FACTOR); // JMS_GFX
+					r.extent.width = 132 << RESOLUTION_FACTOR; // JMS_GFX
 					DrawFilledRectangle (&r);
 					sprintf (buf, "%u %s", RecycleAmount,
 							GAME_STRING (STATUS_STRING_BASE + 1)); // "RU"
 					t.baseline.x = r.corner.x + (r.extent.width >> 1);
-					t.baseline.y = r.corner.y + 14;
+					t.baseline.y = r.corner.y + (14 << RESOLUTION_FACTOR); // JMS_GFX
 					t.align = ALIGN_CENTER;
 					t.pStr = buf;
 					t.CharCount = (COUNT)~0;
@@ -761,10 +802,20 @@ UninitEncounter (void)
 							// "Debris"
 					str2 = GAME_STRING (ENCOUNTER_STRING_BASE + 7);
 							// "Scavenged"
+
+					// JMS: Now we draw the clean metallic frame to erase the "Enemy ships destroyed"
+					// text before drawing "debris scavenged."
+					if(RESOLUTION_FACTOR != 0)
+						DrawStamp (&saveMetallicFrame);
+
 					DrawFadeText (str1, str2, TRUE, &scavenge_r);
 					WaitForAnyButton (TRUE, ONE_SECOND * 2, FALSE);
 					if (!CurrentInputState.key[PlayerControls[0]][KEY_ESCAPE])
 						DrawFadeText (str1, str2, FALSE, &scavenge_r);
+
+					// JMS: The final cleanup of the "Debris scavenged". Without this, an ugly grey ghost-text would remain.
+					if(RESOLUTION_FACTOR != 0)
+						DrawStamp (&saveMetallicFrame);
 				}
 			}
 
diff -ruNp src.mm/uqm/flash.c src/uqm/flash.c
--- src.mm/uqm/flash.c	2017-11-28 11:08:48 -0600
+++ src/uqm/flash.c	2017-11-28 11:09:33 -0600
@@ -159,7 +159,7 @@ Flash_createOverlay (CONTEXT gfxContext,
 		context->rect.extent.width = 0;
 		context->rect.extent.height = 0;
 	} else
-		Flash_setOverlay (context, origin, overlay);
+		Flash_setOverlay (context, origin, overlay, FALSE);
 	
 	return context;
 }
@@ -453,18 +453,23 @@ Flash_getRect (FlashContext *context, RE
 	*rect = context->rect;
 }
 
+// JMS_GFX: The cleanup boolean can be used when changing between normal and hi-res modes.
+// It ensures that an ugly wrong-sized flash overlay from previous resolution is cleaned
+// from the flash process.
 void
-Flash_setOverlay (FlashContext *context, const POINT *origin, FRAME overlay)
+Flash_setOverlay (FlashContext *context, const POINT *origin, FRAME overlay, BOOLEAN cleanup)
 {
 	assert(context->type == FlashType_overlay);
 
-	if (context->started)
+	if (context->started && !cleanup)
 	{
 		Flash_drawFrame (context, context->original);
 		Flash_clearCache (context);
 	}
 	
-	context->u.overlay.frame = overlay;
+	if (!cleanup)
+		context->u.overlay.frame = overlay;
+
 	GetFrameRect (overlay, &context->rect);
 	context->rect.corner.x += origin->x;
 	context->rect.corner.y += origin->y;
diff -ruNp src.mm/uqm/flash.h src/uqm/flash.h
--- src.mm/uqm/flash.h	2017-11-28 11:08:48 -0600
+++ src/uqm/flash.h	2017-11-28 11:09:33 -0600
@@ -209,7 +209,7 @@ TimeCount Flash_nextTime (FlashContext *
 void Flash_setRect (FlashContext *context, const RECT *rect);
 void Flash_getRect (FlashContext *context, RECT *rect);
 void Flash_setOverlay(FlashContext *context, const POINT *origin,
-		FRAME overlay);
+		FRAME overlay, BOOLEAN cleanup); // JMS_GFX
 void Flash_preUpdate (FlashContext *context);
 void Flash_postUpdate (FlashContext *context);
 void Flash_setCacheSize (FlashContext *context, COUNT size);
diff -ruNp src.mm/uqm/galaxy.c src/uqm/galaxy.c
--- src.mm/uqm/galaxy.c	2017-11-28 11:08:48 -0600
+++ src/uqm/galaxy.c	2017-11-28 11:09:33 -0600
@@ -41,8 +41,8 @@ extern PRIM_LINKS DisplayLinks;
 			+ MED_STAR_COUNT \
 			+ SML_STAR_COUNT)
 
-POINT SpaceOrg;
-static POINT log_star_array[NUM_STARS];
+DPOINT SpaceOrg;
+static DPOINT log_star_array[NUM_STARS];
 
 #define NUM_STAR_PLANES 3
 
@@ -50,9 +50,9 @@ typedef struct
 {
 	COUNT min_star_index;
 	COUNT num_stars;
-	POINT *star_array;
-	POINT *pmin_star;
-	POINT *plast_star;
+	DPOINT *star_array;
+	DPOINT *pmin_star;
+	DPOINT *plast_star;
 } STAR_BLOCK;
 
 STAR_BLOCK StarBlock[NUM_STAR_PLANES] =
@@ -87,7 +87,7 @@ SortStarBlock (STAR_BLOCK *pStarBlock)
 		{
 			if (pStarBlock->star_array[i].y > pStarBlock->star_array[j].y)
 			{
-				POINT temp;
+				DPOINT temp;
 
 				temp = pStarBlock->star_array[i];
 				pStarBlock->star_array[i] = pStarBlock->star_array[j];
@@ -103,11 +103,11 @@ SortStarBlock (STAR_BLOCK *pStarBlock)
 }
 
 static void
-WrapStarBlock (SIZE plane, SIZE dx, SIZE dy)
+WrapStarBlock (SIZE plane, SDWORD dx, SDWORD dy)
 {
 	COUNT i;
-	POINT *ppt;
-	SIZE offs_y;
+	DPOINT *ppt;
+	SDWORD offs_y;
 	COUNT num_stars;
 	STAR_BLOCK *pStarBlock;
 
@@ -237,7 +237,7 @@ void
 InitGalaxy (void)
 {
 	COUNT i, factor;
-	POINT *ppt;
+	DPOINT *ppt;
 	PRIM_LINKS Links;
 
 	log_add (log_Debug, "InitGalaxy(): transition_width = %d, "
@@ -255,15 +255,19 @@ InitGalaxy (void)
 		if (i == BIG_STAR_COUNT || i == BIG_STAR_COUNT + MED_STAR_COUNT)
 			++factor;
 
-		ppt->x = (COORD)((UWORD)TFB_Random () % SPACE_WIDTH) << factor;
-		ppt->y = (COORD)((UWORD)TFB_Random () % SPACE_HEIGHT) << factor;
+		ppt->x = (SDWORD)((UWORD)TFB_Random () % SPACE_WIDTH) << factor;
+		ppt->y = (SDWORD)((UWORD)TFB_Random () % SPACE_HEIGHT) << factor;
 
 		if (i < BIG_STAR_COUNT + MED_STAR_COUNT)
 		{
 			SetPrimType (&DisplayArray[p], STAMP_PRIM);
 			SetPrimColor (&DisplayArray[p],
 					BUILD_COLOR (MAKE_RGB15 (0x0B, 0x0B, 0x1F), 0x09));
-			DisplayArray[p].Object.Stamp.frame = stars_in_space;
+			// JMS_GFX: This was originally only "DisplayArray[p].Object.Stamp.frame = stars_in_space;"
+			if (RESOLUTION_FACTOR == 0 || (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1))
+				DisplayArray[p].Object.Stamp.frame = stars_in_space;
+			else
+				DisplayArray[p].Object.Stamp.frame = stars_in_quasispace;
 		}
 		else
 		{
@@ -288,7 +292,7 @@ InitGalaxy (void)
 }
 
 static BOOLEAN
-CmpMovePoints (const POINT *pt1, const POINT *pt2, SIZE dx, SIZE dy,
+CmpMovePoints (const POINT *pt1, const DPOINT *pt2, SDWORD dx, SDWORD dy,
 			   SIZE reduction)
 {
 	if (optMeleeScale == TFB_SCALE_STEP)
@@ -304,7 +308,7 @@ CmpMovePoints (const POINT *pt1, const P
 }
 
 void
-MoveGalaxy (VIEW_STATE view_state, SIZE dx, SIZE dy)
+MoveGalaxy (VIEW_STATE view_state, SDWORD dx, SDWORD dy)
 {
 	PRIMITIVE *pprim;
 	static const COUNT star_counts[] =
@@ -317,14 +321,19 @@ MoveGalaxy (VIEW_STATE view_state, SIZE
 
 	if (view_state != VIEW_STABLE)
 	{
-		COUNT reduction;
-		COUNT i;
-		COUNT iss;
-		POINT *ppt;
+		COUNT reduction, i, iss;
+		DPOINT *ppt;
+		FRAME tempframe;
 		int wrap_around;
 
 		reduction = zoom_out;
 
+		// JMS_GFX
+		if (RESOLUTION_FACTOR == 0 || (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1))
+			tempframe = stars_in_space;
+		else
+			tempframe = stars_in_quasispace;
+
 		if (view_state == VIEW_CHANGE)
 		{
 			if (inHQSpace ())
@@ -334,7 +343,7 @@ MoveGalaxy (VIEW_STATE view_state, SIZE
 					for (i = star_counts[iss]; i > 0; --i, ++pprim)
 					{
 						pprim->Object.Stamp.frame =	SetAbsFrameIndex (
-								stars_in_space,
+								tempframe,
 									(COUNT)(TFB_Random () & 31)
 									+ star_frame_ofs[iss]);
 					}
@@ -343,7 +352,7 @@ MoveGalaxy (VIEW_STATE view_state, SIZE
 			else
 			{
 				GRAPHICS_PRIM star_object[2];
-				FRAME star_frame[2];
+				FRAME star_frame[9]; // JMS_GFX: was 2. Added extra frames for more star .pngs.
 
 				star_frame[0] = IncFrameIndex (stars_in_space);
 				star_frame[1] = stars_in_space;
@@ -366,20 +375,65 @@ MoveGalaxy (VIEW_STATE view_state, SIZE
 					star_object[1] = POINT_PRIM;
 					if (reduction > (1 << ZOOM_SHIFT))
 					{
-						star_object[0] = POINT_PRIM;
+						// JMS_GFX: In hi-res modes, Closest stars are images when zoomed out.
+						if (RESOLUTION_FACTOR == 0)
+							star_object[0] = POINT_PRIM;
+						else
+						{
+							star_object[0] = STAMP_PRIM;
+							star_object[1] = STAMP_PRIM;
+							star_frame[0] = stars_in_space;
+							star_frame[1] = IncFrameIndex (stars_in_space);
+							
+						}
 					}
 					else
 					{
 						star_object[0] = STAMP_PRIM;
+						star_object[1] = STAMP_PRIM;
 					}
 				}
 
-				for (iss = 0, pprim = DisplayArray; iss < 2; ++iss)
+				// Normal handling of stars in 320x240.
+				if (RESOLUTION_FACTOR == 0)
 				{
-					for (i = star_counts[iss]; i > 0; --i, ++pprim)
+					for (iss = 0, pprim = DisplayArray; iss < 2; ++iss)
+					{
+						for (i = star_counts[iss]; i > 0; --i, ++pprim)
+						{
+							SetPrimType (pprim, star_object[iss]);
+							pprim->Object.Stamp.frame = star_frame[iss];
+						}
+					}
+				}
+				
+				// JMS_GFX: Advanced handling of stars in hi-res modes.
+				// Basically, draw a BIG star .png when zoomed close in
+				// medium-sized when at med distance and a small .png when far away.
+				else
+				{
+					COUNT zoomlevel;
+					COUNT med_sml_zoom_limit = optMeleeScale == TFB_SCALE_STEP ? 0 : (1 << (ZOOM_SHIFT + 1));
+					
+					if (reduction == MAX_ZOOM_OUT)
+						zoomlevel = 0;
+					else if (reduction <= med_sml_zoom_limit)
+						zoomlevel = 6;
+					else
+						zoomlevel = 3;
+					
+					for (i = 3; i < 9; i++)
+					{
+						star_frame[i] = SetAbsFrameIndex (stars_in_space, i);
+					}
+				
+					for (iss = 0, pprim = DisplayArray; iss < 2; ++iss)
 					{
-						SetPrimType (pprim, star_object[iss]);
-						pprim->Object.Stamp.frame = star_frame[iss];
+						for (i = star_counts[iss]; i > 0; --i, ++pprim)
+						{
+							SetPrimType (pprim, star_object[iss]);
+							pprim->Object.Stamp.frame = star_frame[iss + zoomlevel];
+						}
 					}
 				}
 			}
@@ -417,10 +471,10 @@ MoveGalaxy (VIEW_STATE view_state, SIZE
 		}
 		else
 		{
-			dx = (COORD)(LOG_SPACE_WIDTH >> 1)
+			dx = (SDWORD)(LOG_SPACE_WIDTH >> 1)
 					- (LOG_SPACE_WIDTH >> ((MAX_REDUCTION + 1)
 					- MAX_VIS_REDUCTION));
-			dy = (COORD)(LOG_SPACE_HEIGHT >> 1)
+			dy = (SDWORD)(LOG_SPACE_HEIGHT >> 1)
 					- (LOG_SPACE_HEIGHT >> ((MAX_REDUCTION + 1)
 					- MAX_VIS_REDUCTION));
 			if (optMeleeScale == TFB_SCALE_STEP)
diff -ruNp src.mm/uqm/gameev.c src/uqm/gameev.c
--- src.mm/uqm/gameev.c	2017-11-28 11:08:48 -0600
+++ src/uqm/gameev.c	2017-11-28 11:09:33 -0600
@@ -31,7 +31,7 @@
 #include "libs/mathlib.h"
 #include "options.h"
 #include <stdlib.h>
-
+#include "setup.h"
 
 static int arilou_entrance_event (int arg);
 static int arilou_exit_event (int arg);
@@ -138,7 +138,7 @@ AddInitialGameEvents (void) {
 	COUNT kohrah_winning_years = optCheatMode ? YEARS_TO_KOHRAH_VICTORY + 25 : YEARS_TO_KOHRAH_VICTORY;
 	AddEvent (RELATIVE_EVENT, 0, 1, 0, HYPERSPACE_ENCOUNTER_EVENT);
 	AddEvent (ABSOLUTE_EVENT, 3, 17, START_YEAR, ARILOU_ENTRANCE_EVENT);
-	AddEvent (RELATIVE_EVENT, 0, 0, YEARS_TO_KOHRAH_VICTORY,
+	AddEvent (RELATIVE_EVENT, 0, 0, kohrah_winning_years,
 			KOHR_AH_VICTORIOUS_EVENT);
 	AddEvent (RELATIVE_EVENT, 0, 0, 0, SLYLANDRO_RAMP_UP);
 }
diff -ruNp src.mm/uqm/gameinp.c src/uqm/gameinp.c
--- src.mm/uqm/gameinp.c	2017-11-28 11:08:48 -0600
+++ src/uqm/gameinp.c	2017-11-28 11:09:33 -0600
@@ -34,8 +34,9 @@
 #include "libs/threadlib.h"
 #include "setup.h"
 
-#define ACCELERATION_INCREMENT (ONE_SECOND / 12)
-#define MENU_REPEAT_DELAY (ONE_SECOND / 2)
+// MB: Updated menu delay values so it no longer takes an age to (a) fill up your fuel tanks (b) fill up your crew (c) search through your saved games.
+#define ACCELERATION_INCREMENT (ONE_SECOND / 28)
+#define MENU_REPEAT_DELAY (ONE_SECOND / 3)
 
 
 typedef struct
diff -ruNp src.mm/uqm/gameopt.c src/uqm/gameopt.c
--- src.mm/uqm/gameopt.c	2017-11-28 11:08:48 -0600
+++ src/uqm/gameopt.c	2017-11-28 11:09:33 -0600
@@ -39,8 +39,8 @@
 extern FRAME PlayFrame;
 
 #define MAX_SAVED_GAMES 100
-#define SUMMARY_X_OFFS 14
-#define SUMMARY_SIDE_OFFS 7
+#define SUMMARY_X_OFFS (14 << RESOLUTION_FACTOR) // JMS_GFX
+#define SUMMARY_SIDE_OFFS (7 << RESOLUTION_FACTOR) // JMS_GFX
 #define SAVES_PER_PAGE 5
 
 #define MAX_NAME_SIZE  SIS_NAME_SIZE
@@ -59,7 +59,7 @@ ConfirmSaveLoad (STAMP *MsgStamp)
 	GetContextClipRect (&clip_r);
 
 	t.baseline.x = clip_r.extent.width >> 1;
-	t.baseline.y = (clip_r.extent.height >> 1) + 3;
+	t.baseline.y = (clip_r.extent.height >> 1) + (3 << RESOLUTION_FACTOR); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.CharCount = (COUNT)~0;
 	if (MsgStamp)
@@ -69,20 +69,27 @@ ConfirmSaveLoad (STAMP *MsgStamp)
 		t.pStr = GAME_STRING (SAVEGAME_STRING_BASE + 1);
 				// "Loading . . ."
 	TextRect (&t, &r, NULL);
-	r.corner.x -= 4;
-	r.corner.y -= 4;
-	r.extent.width += 8;
-	r.extent.height += 8;
+	r.corner.x -= 4 << RESOLUTION_FACTOR; // JMS_GFX
+	r.corner.y -= 4 << RESOLUTION_FACTOR; // JMS_GFX
+	r.extent.width += 8 << RESOLUTION_FACTOR; // JMS_GFX
+	r.extent.height += 8 << RESOLUTION_FACTOR; // JMS_GFX
 	if (MsgStamp)
 	{
 		*MsgStamp = SaveContextFrame (&r);
 	}
-	DrawStarConBox (&r, 2,
-			BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19),
-			BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F),
-			TRUE, BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x14, 0x14, 0x14), 0x0F));
+	if (RESOLUTION_FACTOR == 0) {
+		DrawStarConBox (&r, 2,
+						BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19),
+						BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F),
+						TRUE, BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
+		SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x14, 0x14, 0x14), 0x0F));
+	} else {
+		DrawStarConBox (&r, 2,
+						PCMENU_TOP_LEFT_BORDER_COLOR,
+						PCMENU_BOTTOM_RIGHT_BORDER_COLOR,
+						TRUE, PCMENU_BACKGROUND_COLOR);
+		SetContextForeGroundColor (PCMENU_SELECTION_TEXT_COLOR);
+	}
 	font_DrawText (&t);
 }
 
@@ -173,26 +180,6 @@ FeedbackSetting (BYTE which_setting)
 #define DDSHS_EDIT     1
 #define DDSHS_BLOCKCUR 2
 
-static const RECT captainNameRect = {
-	/* .corner = */ {
-		/* .x = */ 3,
-		/* .y = */ 10
-	}, /* .extent = */ {
-		/* .width = */ SHIP_NAME_WIDTH - 2,
-		/* .height = */ SHIP_NAME_HEIGHT
-	}
-};
-static const RECT shipNameRect = {
-	/* .corner = */ {
-		/* .x = */ 2,
-		/* .y = */ 20
-	}, /* .extent = */ {
-		/* .width = */ SHIP_NAME_WIDTH,
-		/* .height = */ SHIP_NAME_HEIGHT
-	}
-};
-
-
 static BOOLEAN
 DrawNameString (bool nameCaptain, UNICODE *Str, COUNT CursorPos,
 		COUNT state)
@@ -203,11 +190,17 @@ DrawNameString (bool nameCaptain, UNICOD
 	FONT Font;
 
 	{
+		r.extent.height = SHIP_NAME_HEIGHT;
+
 		if (nameCaptain)
 		{	// Naming the captain
 			Font = TinyFont;
-			r = captainNameRect;
-			lf.baseline.x = r.corner.x + (r.extent.width >> 1) - 1;
+			r.corner.x = RES_STAT_SCALE(3) - RES_CASE(0,3,5); // JMS_GFX
+			r.corner.y = RES_CASE(10,20,32); // JMS_GFX
+			r.extent.width = SHIP_NAME_WIDTH - RES_CASE(2,1,0);		// JMS_GFX
+			r.extent.height += RESOLUTION_FACTOR; // JMS_GFX
+			lf.baseline.x = (STATUS_WIDTH >> 1) - RES_CASE(1,0,-1);
+			lf.baseline.y = r.corner.y + r.extent.height - RES_CASE(1,4,3);
 
 			BackGround = BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x1F), 0x09);
 			ForeGround = BUILD_COLOR (MAKE_RGB15 (0x0A, 0x1F, 0x1F), 0x0B);
@@ -215,14 +208,18 @@ DrawNameString (bool nameCaptain, UNICOD
 		else
 		{	// Naming the flagship
 			Font = StarConFont;
-			r = shipNameRect;
+			r.corner.x = RES_CASE(2,3,5); // JMS_GFX
+			r.corner.y = RES_CASE(20,40,63); // JMS_GFX
+			r.extent.width = SHIP_NAME_WIDTH;
+			r.extent.height += RES_CASE(0,0,1); // JMS_GFX
 			lf.baseline.x = r.corner.x + (r.extent.width >> 1);
+			lf.baseline.y = r.corner.y + r.extent.height - RES_CASE(1,4,3); // JMS_GFX
 
 			BackGround = BUILD_COLOR (MAKE_RGB15 (0x0F, 0x00, 0x00), 0x2D);
 			ForeGround = BUILD_COLOR (MAKE_RGB15 (0x1F, 0x0A, 0x00), 0x7D);
 		}
 
-		lf.baseline.y = r.corner.y + r.extent.height - 1;
+		// lf.baseline.y = r.corner.y + r.extent.height - 1;
 		lf.align = ALIGN_CENTER;
 	}
 
@@ -314,11 +311,10 @@ static void
 NameCaptainOrShip (bool nameCaptain, bool gamestart)
 {
 	UNICODE buf[MAX_NAME_SIZE] = "";
-	UNICODE buff[32] = "";
 	TEXTENTRY_STATE tes;
 	UNICODE *Setting;
 	COUNT CursPos = 0; // JMS
-	RECT r; // J
+	RECT r; // JMS
 
 	// JMS: This should only be invoked when starting a new game.
 	// It prints a prompt window to the center of the screen, urging
@@ -333,28 +329,27 @@ NameCaptainOrShip (bool nameCaptain, boo
 		GetContextClipRect (&clip_r);
 		
 		t.baseline.x = clip_r.extent.width >> 1;
-		t.baseline.y = (clip_r.extent.height >> 1) + 3; // JMS_GFX
+		t.baseline.y = (clip_r.extent.height >> 1) + (3 << RESOLUTION_FACTOR); // JMS_GFX
 		t.align = ALIGN_CENTER;
 		t.CharCount = (COUNT)~0;
 		
 		if (nameCaptain) {
 			// "Captain, what is your name?"
-			t.pStr = strcpy (buff, "Captain, what is your name?");// GAME_STRING (NAMING_STRING_BASE + 4);
+			t.pStr = GAME_STRING (NAMING_STRING_BASE + 4);
 			strcpy (buf,  GAME_STRING (NAMING_STRING_BASE + 3)); // "Zelnick"
 			CursPos = strlen(GAME_STRING (NAMING_STRING_BASE + 3));
 		} else {
 			// "What is the name of your flagship?"
-			memset(&buff[0], 0, sizeof(buff));
-			t.pStr = strcpy (buff, "What is the name your flagship?"); // GAME_STRING (NAMING_STRING_BASE + 5);
+			t.pStr = GAME_STRING (NAMING_STRING_BASE + 5);
 			strcpy (buf, GAME_STRING (NAMING_STRING_BASE + 2)); // "Vindicator"
 			CursPos = strlen(GAME_STRING (NAMING_STRING_BASE + 2));
 		}
 		
 		TextRect (&t, &r, NULL);
-		r.corner.x -= 4; // JMS_GFX
-		r.corner.y -= 4; // JMS_GFX
-		r.extent.width += 8; // JMS_GFX
-		r.extent.height += 8; // JMS_GFX
+		r.corner.x -= 4 << RESOLUTION_FACTOR; // JMS_GFX
+		r.corner.y -= 4 << RESOLUTION_FACTOR; // JMS_GFX
+		r.extent.width += 8 << RESOLUTION_FACTOR; // JMS_GFX
+		r.extent.height += 8 << RESOLUTION_FACTOR; // JMS_GFX
 		
 		DrawStarConBox (&r, 2,
 						BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19),
@@ -365,7 +360,7 @@ NameCaptainOrShip (bool nameCaptain, boo
 		font_DrawText (&t);
 	}
 
-	SetFlashRect (nameCaptain ? &captainNameRect : &shipNameRect);
+	SetFlashRect (NULL);
 
 	DrawNameString (nameCaptain, buf, CursPos, DDSHS_EDIT);
 
@@ -429,21 +424,21 @@ DrawSaveNameString (UNICODE *Str, COUNT
 	snprintf (fullStr, sizeof fullStr, "%s%s", dateStr, Str);
 
 	SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x1B, 0x00, 0x1B), 0x33));
-	r.extent.width = 15;
+	r.extent.width = 15 << RESOLUTION_FACTOR; // JMS_GFX
 	if (MAX_SAVED_GAMES > 99)
-		r.extent.width += 5;
-	r.extent.height = 11;
-	r.corner.x = 8;
-	r.corner.y = (160 + ((gameIndex % SAVES_PER_PAGE) * 13));
+		r.extent.width += 5 << RESOLUTION_FACTOR; // JMS_GFX
+	r.extent.height = 11 << RESOLUTION_FACTOR; // JMS_GFX
+	r.corner.x = 8 << RESOLUTION_FACTOR; // JMS_GFX
+	r.corner.y = (160 + ((gameIndex % SAVES_PER_PAGE) * 13)) << RESOLUTION_FACTOR; // JMS_GFX
 	DrawRectangle (&r);
 
-	r.extent.width = (204 - SAFE_X);
-	r.corner.x = (30 + SAFE_X);
+	r.extent.width = (204 - SAFE_X) << RESOLUTION_FACTOR; // JMS_GFX
+	r.corner.x = (30 + SAFE_X) << RESOLUTION_FACTOR; // JMS_GFX
 	DrawRectangle (&r);
 
 	Font = TinyFont;
-	lf.baseline.x = r.corner.x + 3;
-	lf.baseline.y = r.corner.y + 8;
+	lf.baseline.x = r.corner.x + (3 << RESOLUTION_FACTOR); // JMS_GFX
+	lf.baseline.y = r.corner.y + RES_CASE(8,14,29); // JMS_GFX
 
 	BackGround = BUILD_COLOR (MAKE_RGB15 (0x1B, 0x00, 0x1B), 0x33);
 	ForeGround = BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01);
@@ -461,8 +456,8 @@ DrawSaveNameString (UNICODE *Str, COUNT
 		SetContextForeGroundColor (BLACK_COLOR);
 		DrawFilledRectangle (&r);
 
-		t.baseline.x = r.corner.x + 3;
-		t.baseline.y = r.corner.y + 8;
+		t.baseline.x = r.corner.x + (3 << RESOLUTION_FACTOR);
+		t.baseline.y = r.corner.y + (8 << RESOLUTION_FACTOR); // JMS_GFX
 		t.align = ALIGN_LEFT;
 		t.pStr = Str;
 		t.CharCount = (COUNT)~0;
@@ -712,7 +707,7 @@ DrawBlankSavegameDisplay (PICK_GAME_STAT
 {
 	STAMP s;
 
-	s.origin.x = 0;
+	s.origin.x = 0 - (RESOLUTION_FACTOR >> 1); // JMS_GFX
 	s.origin.y = 0;
 	s.frame = SetAbsFrameIndex (pickState->SummaryFrame,
 			GetFrameCount (pickState->SummaryFrame) - 1);
@@ -752,9 +747,9 @@ DrawSavegameCargo (SIS_STATE *sisState)
 		BUILD_COLOR (MAKE_RGB15_INIT (0x14, 0x00, 0x14), 0x05),
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x00, 0x19), 0x00),
 	};
-#define ELEMENT_ORG_Y      17
-#define ELEMENT_SPACING_Y  12
-#define ELEMENT_SPACING_X  36
+#define ELEMENT_ORG_Y      (17 << RESOLUTION_FACTOR) // JMS_GFX
+#define ELEMENT_SPACING_Y  (12 << RESOLUTION_FACTOR) // JMS_GFX
+#define ELEMENT_SPACING_X  (36 << RESOLUTION_FACTOR) // JMS_GFX
 
 	SetContext (SpaceContext);
 	BatchGraphics ();
@@ -763,11 +758,11 @@ DrawSavegameCargo (SIS_STATE *sisState)
 	// setup element icons
 	s.frame = SetAbsFrameIndex (MiscDataFrame,
 			(NUM_SCANDOT_TRANSITIONS << 1) + 3);
-	s.origin.x = 7 + SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS + 3;
+	s.origin.x = SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS + (10 << RESOLUTION_FACTOR); // JMS_GFX
 	s.origin.y = ELEMENT_ORG_Y;
 	// setup element amounts
-	t.baseline.x = 33 + SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS + 3;
-	t.baseline.y = ELEMENT_ORG_Y + 3;
+	t.baseline.x = SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS + ELEMENT_SPACING_X;
+	t.baseline.y = ELEMENT_ORG_Y + (3 << RESOLUTION_FACTOR); // JMS_GFX
 	t.align = ALIGN_RIGHT;
 	t.pStr = buf;
 
@@ -779,7 +774,7 @@ DrawSavegameCargo (SIS_STATE *sisState)
 			s.origin.x += ELEMENT_SPACING_X;
 			s.origin.y = ELEMENT_ORG_Y;
 			t.baseline.x += ELEMENT_SPACING_X;
-			t.baseline.y = ELEMENT_ORG_Y + 3;
+			t.baseline.y = ELEMENT_ORG_Y + (3 << RESOLUTION_FACTOR); // JMS_GFX
 		}
 		// draw element icon
 		DrawStamp (&s);
@@ -794,13 +789,13 @@ DrawSavegameCargo (SIS_STATE *sisState)
 	}
 
 	// draw Bio icon
-	s.origin.x = 24 + SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS;
-	s.origin.y = 68;
+	s.origin.x = (24 << RESOLUTION_FACTOR) + SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS; // JMS_GFX
+	s.origin.y = 68 << RESOLUTION_FACTOR; // JMS_GFX
 	s.frame = SetAbsFrameIndex (s.frame, 68);
 	DrawStamp (&s);
 	// print Bio amount
-	t.baseline.x = 50 + SUMMARY_X_OFFS;
-	t.baseline.y = s.origin.y + 3;
+	t.baseline.x = (50 << RESOLUTION_FACTOR) + SUMMARY_X_OFFS; // JMS_GFX
+	t.baseline.y = s.origin.y + (3 << RESOLUTION_FACTOR); // JMS_GFX
 	SetContextForeGroundColor (cargo_color[i]);
 	snprintf (buf, sizeof buf, "%u", sisState->TotalBioMass);
 	t.CharCount = (COUNT)~0;
@@ -847,10 +842,9 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 		// Hack StatusContext so we can use standard SIS display funcs
 		GetContextClipRect (&OldRect);
 		r.corner.x = SIS_ORG_X + ((SIS_SCREEN_WIDTH - STATUS_WIDTH) >> 1) +
-				SAFE_X - 16 + SUMMARY_X_OFFS;
-//		r.corner.x = SIS_ORG_X + ((SIS_SCREEN_WIDTH - STATUS_WIDTH) >> 1);
-		r.corner.y = SIS_ORG_Y;
-		r.extent.width = STATUS_WIDTH;
+				SAFE_X - (16 << RESOLUTION_FACTOR) + SUMMARY_X_OFFS + RES_CASE(0,0,6); // JMS_GFX
+		r.corner.y = SIS_ORG_Y; // JMS_GFX
+		r.extent.width = STATUS_WIDTH + 2 * RESOLUTION_FACTOR; // JMS_GFX
 		r.extent.height = STATUS_HEIGHT;
 		SetContextClipRect (&r);
 
@@ -870,12 +864,12 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 
 		SetContext (SpaceContext);
 		// draw devices
-		s.origin.y = 13;
+		s.origin.y = 13 << RESOLUTION_FACTOR; // JMS_GFX
 		for (i = 0; i < 4; ++i)
 		{
 			COUNT j;
 
-			s.origin.x = 140 + SUMMARY_X_OFFS + SUMMARY_SIDE_OFFS;
+			s.origin.x = (140 << RESOLUTION_FACTOR) + SUMMARY_X_OFFS + SUMMARY_SIDE_OFFS + RES_CASE(0,10,110); // JMS_GFX
 			for (j = 0; j < 4; ++j)
 			{
 				COUNT devIndex = (i * 4) + j;
@@ -885,20 +879,20 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 							+ pSD->DeviceList[devIndex]);
 					DrawStamp (&s);
 				}
-				s.origin.x += 18;
+				s.origin.x += 18 << RESOLUTION_FACTOR; // JMS_GFX
 			}
-			s.origin.y += 18;
+			s.origin.y += 18 << RESOLUTION_FACTOR; // JMS_GFX
 		}
 
 		SetContextFont (StarConFont);
-		t.baseline.x = 173 + SUMMARY_X_OFFS + SUMMARY_SIDE_OFFS;
+		t.baseline.x = (173 << RESOLUTION_FACTOR) + SUMMARY_X_OFFS + SUMMARY_SIDE_OFFS + RES_CASE(0,15,110); // JMS_GFX
 		t.align = ALIGN_CENTER;
 		t.CharCount = (COUNT)~0;
 		t.pStr = buf;
 		if (pSD->Flags & AFTER_BOMB_INSTALLED)
 		{
 			// draw the bomb and the escape pod
-			s.origin.x = SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS + 6;
+			s.origin.x = SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS + (6 << RESOLUTION_FACTOR); // JMS_GFX
 			s.origin.y = 0;
 			s.frame = SetRelFrameIndex (pickState->SummaryFrame, 0);
 			DrawStamp (&s);
@@ -914,8 +908,8 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 			SetContext (RadarContext);
 			// Hack RadarContext so we can use standard Lander display funcs
 			GetContextClipRect (&OldRect);
-			r.corner.x = SIS_ORG_X + 10 + SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS;
-			r.corner.y = SIS_ORG_Y + 84;
+			r.corner.x = SIS_ORG_X + RES_CASE(10,20,70) + SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS; // JMS_GFX
+			r.corner.y = SIS_ORG_Y + (84 << RESOLUTION_FACTOR); // JMS_GFX
 			r.extent = OldRect.extent;
 			SetContextClipRect (&r);
 			// draw the lander with upgrades
@@ -924,13 +918,13 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 			SetContext (SpaceContext);
 
 			snprintf (buf, sizeof buf, "%u", pSD->SS.ResUnits);
-			t.baseline.y = 102;
+			t.baseline.y = 102 << RESOLUTION_FACTOR; // JMS_GFX
 			SetContextForeGroundColor (
 					BUILD_COLOR (MAKE_RGB15 (0x10, 0x00, 0x10), 0x01));
 			font_DrawText (&t);
 			t.CharCount = (COUNT)~0;
 		}
-		t.baseline.y = 126;
+		t.baseline.y = 126 << RESOLUTION_FACTOR; // JMS_GFX
 		snprintf (buf, sizeof buf, "%u",
 				MAKE_WORD (pSD->MCreditLo, pSD->MCreditHi));
 		SetContextForeGroundColor (
@@ -938,8 +932,8 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 		font_DrawText (&t);
 
 		// print the location
-		t.baseline.x = 6;
-		t.baseline.y = 139 + 6;
+		t.baseline.x = 6 << RESOLUTION_FACTOR; // JMS_GFX
+		t.baseline.y = ((139 + 6) << RESOLUTION_FACTOR) + RES_CASE(0,3,0); // JMS_GFX;
 		t.align = ALIGN_LEFT;
 		t.pStr = buf;
 		starPt.x = LOGX_TO_UNIVERSE (pSD->SS.log_x);
@@ -984,8 +978,7 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
 		t.align = ALIGN_CENTER;
-		t.baseline.x = SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH - 4
-				+ (SIS_TITLE_WIDTH >> 1);
+		t.baseline.x = SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH - (4 << RESOLUTION_FACTOR) + (SIS_TITLE_WIDTH >> 1); // JMS_GFX
 		switch (pSD->Activity)
 		{
 			case IN_STARBASE:
@@ -1022,20 +1015,18 @@ DrawGameSelection (PICK_GAME_STATE *pick
 {
 	RECT r;
 	TEXT t;
-	COUNT i;
-	COUNT curSlot;
-	UNICODE buf[256];
-	UNICODE buf2[80];
+	COUNT i, curSlot;
+	UNICODE buf[256], buf2[80], *SaveName;
 
 	BatchGraphics ();
 
 	SetContextFont (TinyFont);
 
 	// Erase the selection menu
-	r.extent.width = 240;
-	r.extent.height = 65;
-	r.corner.x = 1;
-	r.corner.y = 160;
+	r.extent.width = 240 << RESOLUTION_FACTOR; // JMS_GFX
+	r.extent.height = 65 << RESOLUTION_FACTOR; // JMS_GFX
+	r.corner.x = 1 << RESOLUTION_FACTOR; // JMS_GFX
+	r.corner.y = 160 << RESOLUTION_FACTOR; // JMS_GFX
 	SetContextForeGroundColor (BLACK_COLOR);
 	DrawFilledRectangle (&r);
 
@@ -1050,28 +1041,31 @@ DrawGameSelection (PICK_GAME_STATE *pick
 	{
 		SUMMARY_DESC *desc = &pickState->summary[curSlot];
 
+		// JMS_GFX: In hi-res modes, the dark blue is brighter because otherwise
+		// the thinner lines/text would be hard to see.
 		SetContextForeGroundColor ((curSlot == selSlot) ?
-				(BUILD_COLOR (MAKE_RGB15 (0x1B, 0x00, 0x1B), 0x33)):
-				(BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01)));
-		r.extent.width = 15;
+				(BUILD_COLOR (MAKE_RGB15 (0x1B, 0x00, 0x1B), 0x33)): 
+				( RESOLUTION_FACTOR == 0 ?
+				(BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01)) : (BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x19), 0x01))));
+		r.extent.width = 15 << RESOLUTION_FACTOR; // JMS_GFX
 		if (MAX_SAVED_GAMES > 99)
-			r.extent.width += 5;
-		r.extent.height = 11;
-		r.corner.x = 8;
-		r.corner.y = 160 + (i * 13);
+			r.extent.width += 5 << RESOLUTION_FACTOR; // JMS_GFX
+		r.extent.height = 11 << RESOLUTION_FACTOR; // JMS_GFX
+		r.corner.x = 8 << RESOLUTION_FACTOR; // JMS_GFX
+		r.corner.y = (160 + (i * 13)) << RESOLUTION_FACTOR; // JMS_GFX
 		DrawRectangle (&r);
 
-		t.baseline.x = r.corner.x + 3;
-		t.baseline.y = r.corner.y + 8;
+		t.baseline.x = r.corner.x + RES_CASE(3,8,18); // JMS_GFX
+		t.baseline.y = r.corner.y + RES_CASE(8,14,29); // JMS_GFX
 		snprintf (buf, sizeof buf, (MAX_SAVED_GAMES > 99) ? "%03u" : "%02u",
 				curSlot);
 		font_DrawText (&t);
 
-		r.extent.width = 204 - SAFE_X;
-		r.corner.x = 30 + SAFE_X;
+		r.extent.width = (204 - SAFE_X) << RESOLUTION_FACTOR; // JMS_GFX
+		r.corner.x = (30 + SAFE_X) << RESOLUTION_FACTOR; // JMS_GFX
 		DrawRectangle (&r);
 
-		t.baseline.x = r.corner.x + 3;
+		t.baseline.x = r.corner.x + (3 << RESOLUTION_FACTOR); // JMS_GFX
 		if (desc->year_index == 0)
 		{
 			utf8StringCopy (buf, sizeof buf,
@@ -1106,7 +1100,7 @@ LoadGameDescriptions (SUMMARY_DESC *pSD)
 
 	for (i = 0; i < MAX_SAVED_GAMES; ++i, ++pSD)
 	{
-		if (!LoadGame (i, pSD))
+		if (!LoadGame (i, pSD, FALSE))
 			pSD->year_index = 0;
 	}
 }
@@ -1235,7 +1229,7 @@ SaveLoadGame (PICK_GAME_STATE *pickState
 	else
 	{
 		ConfirmSaveLoad (pickState->saving ? &saveStamp : NULL);
-		success = LoadGame (gameIndex, NULL);
+		success = LoadGame (gameIndex, NULL, FALSE);
 	}
 
 	// TODO: the same should be done for both save and load if we also
diff -ruNp src.mm/uqm/gamestr.h src/uqm/gamestr.h
--- src.mm/uqm/gamestr.h	2017-11-28 11:08:48 -0600
+++ src/uqm/gamestr.h	2017-11-28 11:09:33 -0600
@@ -29,7 +29,7 @@
 extern "C" {
 #endif
 
-#define STAR_STRING_COUNT       133
+#define STAR_STRING_COUNT       149
 #define DEVICE_STRING_COUNT      29
 #define CARGO_STRING_COUNT       10
 #define ELEMENTS_STRING_COUNT   133
@@ -37,11 +37,11 @@ extern "C" {
 #define STAR_NUMBER_COUNT        14
 #define PLANET_NUMBER_COUNT      33
 #define MONTHS_STRING_COUNT      12
-#define FEEDBACK_STRING_COUNT     2
+#define FEEDBACK_STRING_COUNT     5
 #define STARBASE_STRING_COUNT     5
 #define ENCOUNTER_STRING_COUNT    8
 #define NAVIGATION_STRING_COUNT   6
-#define NAMING_STRING_COUNT       4
+#define NAMING_STRING_COUNT       6
 #define MELEE_STRING_COUNT        9
 #define SAVEGAME_STRING_COUNT     5
 #define OPTION_STRING_COUNT       5
diff -ruNp src.mm/uqm/gendef.h src/uqm/gendef.h
--- src.mm/uqm/gendef.h	2017-11-28 11:08:48 -0600
+++ src/uqm/gendef.h	2017-11-28 11:09:33 -0600
@@ -58,7 +58,9 @@ enum
 	RAINBOW_DEFINED,
 	ILWRATH_DEFINED,
 	ANDROSYNTH_DEFINED,
-	MYCON_TRAP_DEFINED
+	MYCON_TRAP_DEFINED,
+	ZOQ_COLONY0_DEFINED,
+	ZOQ_COLONY1_DEFINED,
 };
 
 #define UMGAH_DEFINED TALKING_PET_DEFINED
diff -ruNp src.mm/uqm/globdata.c src/uqm/globdata.c
--- src.mm/uqm/globdata.c	2017-11-28 11:08:48 -0600
+++ src/uqm/globdata.c	2017-11-28 11:09:33 -0600
@@ -45,7 +45,6 @@ FRAME PlayFrame;
 
 GLOBDATA GlobData;
 
-
 // Pre: 0 <= bits <= 32
 // This function is necessary because expressions such as '(1 << bits) - 1'
 // or '~(~0 << bits)' may shift by 32 bits, which is undefined (for 32 bits
diff -ruNp src.mm/uqm/globdata.h src/uqm/globdata.h
--- src.mm/uqm/globdata.h	2017-11-28 11:08:48 -0600
+++ src/uqm/globdata.h	2017-11-28 11:09:33 -0600
@@ -861,9 +861,6 @@ START_GAME_STATE
 	ADD_GAME_STATE (ORZ_STACK0, 1)
 	ADD_GAME_STATE (ORZ_STACK1, 1)
 
-	// JMS: It is allowed for the autopilot to engage
-	ADD_GAME_STATE (AUTOPILOT_OK, 1)
-
 /* These state bits are actually offsets into defgrp.dat. They really
  * shouldn't be part of the serialized Game State array! --MCM */
 	ADD_GAME_STATE (SHOFIXTI_GRPOFFS, 32)
@@ -881,8 +878,104 @@ START_GAME_STATE
 	ADD_GAME_STATE (COLONY_GRPOFFS, 32)
 	ADD_GAME_STATE (SAMATRA_GRPOFFS, 32)
 
+	// JMS: It is allowed for the autopilot to engage
+	ADD_GAME_STATE (AUTOPILOT_OK, 1)
+
+	// JMS: Quasispace portal name flags
+	ADD_GAME_STATE (KNOW_QS_PORTAL_0, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_1, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_2, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_3, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_4, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_5, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_6, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_7, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_8, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_9, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_10, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_11, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_12, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_13, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_14, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_15, 1)
+
 END_GAME_STATE
 
+// JMS: For making array of Quasispace portal name flags
+#define QS_PORTALS_KNOWN \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_0)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_1)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_2)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_3)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_4)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_5)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_6)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_7)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_8)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_9)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_10)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_11)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_12)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_13)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_14)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_15)),
+
+// JMS: For making array of Quasispace portal name flags
+#define SET_QS_PORTAL_KNOWN(val) \
+	switch (val)	\
+	{				\
+	case 0:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_0, 1);\
+		break; \
+	case 1:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_1, 1);\
+		break; \
+	case 2:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_2, 1);\
+		break; \
+	case 3:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_3, 1);\
+		break; \
+	case 4:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_4, 1);\
+		break; \
+	case 5:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_5, 1);\
+		break; \
+	case 6:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_6, 1);\
+		break; \
+	case 7:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_7, 1);\
+		break; \
+	case 8:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_8, 1);\
+		break; \
+	case 9:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_9, 1);\
+		break; \
+	case 10:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_10, 1);\
+		break; \
+	case 11:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_11, 1);\
+		break; \
+	case 12:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_12, 1);\
+		break; \
+	case 13:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_13, 1);\
+		break; \
+	case 14:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_14, 1);\
+		break; \
+	case 15:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_15, 1);\
+		break; \
+	default: \
+	break;\
+	}
+
 // Values for GAME_STATE.glob_flags:
 #define COMBAT_SPEED_SHIFT 6
 #define COMBAT_SPEED_MASK (((1 << 2) - 1) << COMBAT_SPEED_SHIFT)
diff -ruNp src.mm/uqm/gravity.c src/uqm/gravity.c
--- src.mm/uqm/gravity.c	2017-11-28 11:08:48 -0600
+++ src/uqm/gravity.c	2017-11-28 11:09:34 -0600
@@ -96,7 +96,7 @@ CalculateGravity (ELEMENT *ElementPtr)
 #ifdef NEVER
 					COUNT magnitude;
 
-#define DIFUSE_GRAVITY 175
+#define DIFUSE_GRAVITY (175 << RESOLUTION_FACTOR) // JMS_GFX: Because of the ifdef NEVER this is actually never run. Well, changed it for consistency
 					dist_squared += (DWORD)abs_dx * (DIFUSE_GRAVITY << 1)
 							+ (DWORD)abs_dy * (DIFUSE_GRAVITY << 1)
 							+ ((DWORD)(DIFUSE_GRAVITY * DIFUSE_GRAVITY) << 1);
@@ -104,7 +104,7 @@ CalculateGravity (ELEMENT *ElementPtr)
 							* GRAVITY_THRESHOLD) / dist_squared)) == 0)
 						magnitude = 1;
 
-#define MAX_MAGNITUDE 6
+#define MAX_MAGNITUDE (6 << RESOLUTION_FACTOR) // JMS_GFX: Because of the ifdef NEVER this is actually never run. Well, changed it for consistency
 					else if (magnitude > MAX_MAGNITUDE)
 						magnitude = MAX_MAGNITUDE;
 					log_add (log_Debug, "magnitude = %u", magnitude);
@@ -126,8 +126,8 @@ CalculateGravity (ELEMENT *ElementPtr)
 
 						angle = ARCTAN (dx, dy);
 						DeltaVelocityComponents (&TestElementPtr->velocity,
-								COSINE (angle, WORLD_TO_VELOCITY (1)),
-								SINE (angle, WORLD_TO_VELOCITY (1)));
+								COSINE (angle, WORLD_TO_VELOCITY (1 << RESOLUTION_FACTOR)),
+								SINE (angle, WORLD_TO_VELOCITY (1 << RESOLUTION_FACTOR))); // JMS_GFX
 						if (TestElementPtr->state_flags & PLAYER_SHIP)
 						{
 							STARSHIP *StarShipPtr;
diff -ruNp src.mm/uqm/hyper.c src/uqm/hyper.c
--- src.mm/uqm/hyper.c	2017-11-28 11:08:48 -0600
+++ src/uqm/hyper.c	2017-11-28 11:09:34 -0600
@@ -43,12 +43,14 @@
 #include "libs/graphics/gfx_common.h"
 #include "libs/graphics/drawable.h"
 #include "libs/mathlib.h"
-
+#include "libs/log.h"
 
 #define XOFFS ((RADAR_SCAN_WIDTH + (UNIT_SCREEN_WIDTH << 2)) >> 1)
 #define YOFFS ((RADAR_SCAN_HEIGHT + (UNIT_SCREEN_HEIGHT << 2)) >> 1)
 
-static FRAME hyperstars[3];
+static FRAME npcbubble;			// BW: animated bubble
+static FRAME hyperholes[3];		// BW: One for each flavour of space
+static FRAME hyperstars[4];
 static COLORMAP hypercmaps[2];
 static BYTE fuel_ticks;
 static COUNT hyper_dx, hyper_dy, hyper_extra;
@@ -173,9 +175,9 @@ enum HyperMenuItems
 
 
 void
-MoveSIS (SIZE *pdx, SIZE *pdy)
+MoveSIS (SDWORD *pdx, SDWORD *pdy)
 {
-	SIZE new_dx, new_dy;
+	SDWORD new_dx, new_dy;
 
 	new_dx = *pdx;
 	GLOBAL_SIS (log_x) -= new_dx;
@@ -395,12 +397,26 @@ check_hyperspace_encounter (void)
 void
 FreeHyperData (void)
 {
+	if (RESOLUTION_FACTOR > 0) {
+		DestroyDrawable (ReleaseDrawable (hyperholes[1]));
+		hyperholes[1] = 0;
+		DestroyDrawable (ReleaseDrawable (hyperholes[2]));
+		hyperholes[2] = 0;
+		// BW: TODO left out for demo
+		// DestroyDrawable (ReleaseDrawable (hyperspacesuns));
+		// hyperspacesuns = 0;
+		DestroyDrawable (ReleaseDrawable (npcbubble));
+		npcbubble = 0;
+	}
+
 	DestroyDrawable (ReleaseDrawable (hyperstars[0]));
 	hyperstars[0] = 0;
 	DestroyDrawable (ReleaseDrawable (hyperstars[1]));
 	hyperstars[1] = 0;
 	DestroyDrawable (ReleaseDrawable (hyperstars[2]));
 	hyperstars[2] = 0;
+	DestroyDrawable (ReleaseDrawable (hyperstars[3]));
+	hyperstars[3] = 0;
 
 	DestroyColorMap (ReleaseColorMap (hypercmaps[0]));
 	hypercmaps[0] = 0;
@@ -411,16 +427,27 @@ FreeHyperData (void)
 static void
 LoadHyperData (void)
 {
-	if (hyperstars[0] == 0)
-	{
+	if (RESOLUTION_FACTOR > 0) {
+		if (hyperholes[1] == 0) {
+			hyperholes[1] = CaptureDrawable (
+				LoadGraphic (HYPERHOLES_MASK_PMAP_ANIM));
+			hyperholes[2] = CaptureDrawable (
+				LoadGraphic (ARIHOLES_MASK_PMAP_ANIM));
+			hyperstars[3] = CaptureDrawable (
+				LoadGraphic (ARI_AMBIENT_MASK_PMAP_ANIM));
+		}
+		npcbubble = CaptureDrawable (LoadGraphic (NPCBUBBLE_MASK_PMAP_ANIM));
+	}
+
+	if (hyperstars[0] == 0) {
 		hyperstars[0] = CaptureDrawable (
 				LoadGraphic (AMBIENT_MASK_PMAP_ANIM));
 		hyperstars[1] = CaptureDrawable (
 				LoadGraphic (HYPERSTARS_MASK_PMAP_ANIM));
-		hypercmaps[0] = CaptureColorMap (LoadColorMap (HYPER_COLOR_TAB));
-
 		hyperstars[2] = CaptureDrawable (
 				LoadGraphic (ARISPACE_MASK_PMAP_ANIM));
+
+		hypercmaps[0] = CaptureColorMap (LoadColorMap (HYPER_COLOR_TAB));
 		hypercmaps[1] = CaptureColorMap (LoadColorMap (ARISPACE_COLOR_TAB));
 	}
 }
@@ -438,11 +465,17 @@ LoadHyperspace (void)
 
 	LoadHyperData ();
 	{
-		FRAME F;
+		FRAME F, FQ;
 		
 		F = hyperstars[0];
 		hyperstars[0] = stars_in_space;
 		stars_in_space = F;
+
+		if (RESOLUTION_FACTOR > 0) {
+			FQ = hyperstars[3];
+			hyperstars[3] = stars_in_quasispace;
+			stars_in_quasispace = FQ;
+		}
 	}
 
 	if (!(LastActivity & CHECK_LOAD))
@@ -491,11 +524,17 @@ BOOLEAN
 FreeHyperspace (void)
 {
 	{
-		FRAME F;
+		FRAME F, FQ;
 		
 		F = hyperstars[0];
 		hyperstars[0] = stars_in_space;
 		stars_in_space = F;
+
+		if (RESOLUTION_FACTOR > 0) {
+			FQ = hyperstars[3];
+			hyperstars[3] = stars_in_quasispace;
+			stars_in_quasispace = FQ;
+		}
 	}
 //    FreeHyperData ();
 
@@ -577,11 +616,24 @@ InterplanetaryTransition (ELEMENT *Eleme
 
 		ElementToUniverse (ElementPtr, &pt);
 		CurStarDescPtr = FindStar (NULL, &pt, 5, 5);
+
+		// JMS: Debugging helpers
+		/*{
+			STAR_DESC *SDPtr, *SDPtr2;
+			SDPtr = CurStarDescPtr;
+			SDPtr2 = FindStar (NULL, &pt, 500, 500);
+			log_add(log_Debug, "SDPtr.x %d, SDPtr.y %d SDPtr2.x %d, SDPtr2.y %d, pt.x %d pt.y %d", 
+				SDPtr->star_pt.x, SDPtr->star_pt.y, SDPtr2->star_pt.x, SDPtr2->star_pt.y, pt.x, pt.y);
+		}*/
+
 		if (CurStarDescPtr->star_pt.x == ARILOU_HOME_X
 				&& CurStarDescPtr->star_pt.y == ARILOU_HOME_Y)
 		{
 			// Meet the Arilou.
 			GLOBAL (CurrentActivity) |= START_ENCOUNTER;
+
+			// JMS: The arilou homeworld name can now be shown on QS map.
+			SET_GAME_STATE (KNOW_QS_PORTAL_15, 1);
 		}
 		else
 		{
@@ -594,6 +646,10 @@ InterplanetaryTransition (ELEMENT *Eleme
 			GLOBAL_SIS (log_x) = UNIVERSE_TO_LOGX (portal_pt[index].x);
 			GLOBAL_SIS (log_y) = UNIVERSE_TO_LOGY (portal_pt[index].y);
 
+			// JMS: This QS portal's HS coordinates are revealed on QS map
+			// the next time the player visits QS.
+			SET_QS_PORTAL_KNOWN(index);
+
 			SET_GAME_STATE (ARILOU_SPACE_SIDE, 0);
 		}
 	}
@@ -754,6 +810,25 @@ hyper_transition (ELEMENT *ElementPtr)
 	else
 	{
 		COUNT frame_index;
+		
+		// JMS: If leaving interplanetary on autopilot, always arrive HS with
+		// the ship's nose pointed into correct direction.
+		if ((GLOBAL (autopilot)).x != ~0 && (GLOBAL (autopilot)).y != ~0) {
+			STARSHIP *StarShipPtr;
+			POINT universe;
+			SIZE facing;
+			SDWORD udx = 0, udy = 0;
+			
+			GetElementStarShip (ElementPtr, &StarShipPtr);
+			universe.x = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x));
+			universe.y = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
+			udx = (GLOBAL (autopilot)).x - universe.x;
+			udy = -((GLOBAL (autopilot)).y - universe.y);
+			
+			facing = NORMALIZE_FACING (ANGLE_TO_FACING (ARCTAN (udx, udy)));
+			StarShipPtr->ShipFacing = facing;
+			SetElementStarShip(ElementPtr, StarShipPtr);
+		}
 
 		frame_index = GetFrameIndex (ElementPtr->current.image.frame);
 		if (frame_index-- <= ANGLE_TO_FACING (FULL_CIRCLE))
@@ -948,24 +1023,40 @@ AddAmbientElement (void)
 
 		rand_val = TFB_Random ();
 		dy = LOWORD (rand_val);
-		dx = (SIZE)(LOBYTE (dy) % SPACE_WIDTH) - (SPACE_WIDTH >> 1);
-		dy = (SIZE)(HIBYTE (dy) % SPACE_HEIGHT) - (SPACE_HEIGHT >> 1);
-		HyperSpaceElementPtr->current.location.x = (LOG_SPACE_WIDTH >> 1)
-				+ DISPLAY_TO_WORLD (dx);
-		HyperSpaceElementPtr->current.location.y = (LOG_SPACE_HEIGHT >> 1)
-				+ DISPLAY_TO_WORLD (dy);
-		HyperSpaceElementPtr->current.image.farray = &stars_in_space;
+		
+		// JMS_GFX
+		if (RESOLUTION_FACTOR == 0) {
+			dx = (SIZE)(LOBYTE (dy) % SPACE_WIDTH) - (SPACE_WIDTH >> 1);
+			dy = (SIZE)(HIBYTE (dy) % SPACE_HEIGHT) - (SPACE_HEIGHT >> 1);
+			HyperSpaceElementPtr->current.image.farray = &stars_in_space;
+		} else {
+			dx = (SIZE)((HIWORD (rand_val)) % SPACE_WIDTH) - (SPACE_WIDTH >> 1);
+			dy = (SIZE)(dy % SPACE_HEIGHT) - (SPACE_HEIGHT >> 1);
+			
+			if ((GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1))
+				HyperSpaceElementPtr->current.image.farray = &stars_in_space;
+			else
+				HyperSpaceElementPtr->current.image.farray = &stars_in_quasispace;
+		}
+		
+		HyperSpaceElementPtr->current.location.x = (LOG_SPACE_WIDTH >> 1) + DISPLAY_TO_WORLD (dx);
+		HyperSpaceElementPtr->current.location.y = (LOG_SPACE_HEIGHT >> 1) + DISPLAY_TO_WORLD (dy);
 
 		if (HIWORD (rand_val) & 7)
 		{
 			HyperSpaceElementPtr->life_span = 14;
-			HyperSpaceElementPtr->current.image.frame = stars_in_space;
+			if (RESOLUTION_FACTOR == 0 || (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1))
+				HyperSpaceElementPtr->current.image.frame = stars_in_space;
+			else
+				HyperSpaceElementPtr->current.image.frame = stars_in_quasispace;
 		}
 		else
 		{
 			HyperSpaceElementPtr->life_span = 12;
-			HyperSpaceElementPtr->current.image.frame =
- 					SetAbsFrameIndex (stars_in_space, 14);
+			if (RESOLUTION_FACTOR == 0 || (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1))
+				HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (stars_in_space, 14);
+			else
+				HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (stars_in_quasispace, 14);
 		}
 
 		UnlockElement (hHyperSpaceElement);
@@ -1000,8 +1091,16 @@ encounter_transition (ELEMENT *ElementPt
 			f = IncFrameIndex (ElementPtr->current.image.frame);
 			if (f != ElementPtr->current.image.farray[0])
 				ElementPtr->next.image.frame = f;
-			else
-				ElementPtr->death_func = NULL;
+			else {
+ 				ElementPtr->death_func = NULL;
+				// BW: the bubble has reached full size so we start animation
+				if (RESOLUTION_FACTOR > 0) {
+					ElementPtr->current.image.farray = &npcbubble;
+					ElementPtr->next.image.farray = &npcbubble;
+					ElementPtr->current.image.frame = SetAbsFrameIndex(npcbubble, 0);
+					ElementPtr->next.image.frame = SetAbsFrameIndex(npcbubble, 0);
+				}
+			}
 		}
 
 		ElementPtr->turn_wait = VORTEX_WAIT;
@@ -1196,8 +1295,14 @@ AddEncounterElement (ENCOUNTER *Encounte
 		}
 		else
 		{
-			ElementPtr->current.image.frame =
-					DecFrameIndex (ElementPtr->current.image.farray[0]);
+			if (RESOLUTION_FACTOR > 0) {
+				ElementPtr->current.image.farray = &npcbubble;
+				ElementPtr->next.image.farray = &npcbubble;
+				ElementPtr->current.image.frame = SetAbsFrameIndex(npcbubble, 0);
+				ElementPtr->next.image.frame = SetAbsFrameIndex(npcbubble, 0);
+			} else {
+				ElementPtr->current.image.frame = DecFrameIndex (ElementPtr->current.image.farray[0]);
+			}
 		}
 
 		ElementPtr->turn_wait = VORTEX_WAIT;
@@ -1364,6 +1469,10 @@ ProcessEncounter (ENCOUNTER *EncounterPt
 		EncounterPtr->loc_pt.x = LOGX_TO_UNIVERSE (EncounterPtr->log_x);
 		EncounterPtr->loc_pt.y = LOGY_TO_UNIVERSE (EncounterPtr->log_y);
 
+		// BW: Animate the NPC bubble in hi-res modes.
+		if (RESOLUTION_FACTOR > 0)
+			ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->current.image.frame);
+
 		encounter_radius = EncounterPtr->radius + (GRID_OFFSET >> 1);
 		delta_x = EncounterPtr->loc_pt.x - EncounterPtr->origin.x;
 		if (delta_x < 0)
@@ -1473,6 +1582,9 @@ ProcessEncounters (POINT *puniverse, COO
 	}
 }
 
+#define NUM_HOLES_FRAMES 32 // BW
+#define NUM_SUNS_FRAMES 32 // BW
+
 void
 SeedUniverse (void)
 {
@@ -1486,6 +1598,10 @@ SeedUniverse (void)
 	HELEMENT hHyperSpaceElement;
 	ELEMENT *HyperSpaceElementPtr;
 
+	static COUNT frameCounter; // BW
+	
+	frameCounter++; // BW
+
 	universe.x = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x));
 	universe.y = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
 
@@ -1517,6 +1633,8 @@ SeedUniverse (void)
 			{
 				BYTE star_type;
 
+				int which_spaces_star_gfx;
+
 				ex = SDPtr->star_pt.x;
 				ey = SDPtr->star_pt.y;
 				star_type = STAR_TYPE (SDPtr->Type);
@@ -1608,12 +1726,8 @@ SeedUniverse (void)
 				ey = -ey;
 
 			if (ex > (XOFFS / NUM_RADAR_SCREENS)
-					|| ey > (YOFFS / NUM_RADAR_SCREENS))
-				continue;
-
-			hHyperSpaceElement = AllocHyperElement (&SD[i].star_pt);
-			if (hHyperSpaceElement == 0)
-				continue;
+				|| ey > (YOFFS / NUM_RADAR_SCREENS))
+			continue;
 
 			LockElement (hHyperSpaceElement, &HyperSpaceElementPtr);
 			HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (
@@ -1645,6 +1759,7 @@ SeedUniverse (void)
 		while ((SDPtr = FindStar (SDPtr, &universe, XOFFS, YOFFS)))
 		{
 			BYTE star_type;
+			int which_spaces_star_gfx;
 
 			ex = SDPtr->star_pt.x - universe.x;
 			if (ex < 0)
@@ -1662,29 +1777,142 @@ SeedUniverse (void)
 
 			star_type = SDPtr->Type;
 
-			LockElement (hHyperSpaceElement, &HyperSpaceElementPtr);
-			HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (
-					hyperstars[1 + (GET_GAME_STATE (ARILOU_SPACE_SIDE) >> 1)],
+			if (RESOLUTION_FACTOR == 0) {
+				hHyperSpaceElement = AllocHyperElement (SDPtr);
+				if (hHyperSpaceElement == 0)
+					continue;
+				
+				LockElement (hHyperSpaceElement, &HyperSpaceElementPtr);
+				which_spaces_star_gfx = 1 + (GET_GAME_STATE (ARILOU_SPACE_SIDE) >> 1);
+				
+				HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (
+					hyperstars[which_spaces_star_gfx],
 					STAR_TYPE (star_type) * NUM_STAR_COLORS
 					+ STAR_COLOR (star_type));
-			HyperSpaceElementPtr->preprocess_func = NULL;
-			HyperSpaceElementPtr->postprocess_func = NULL;
-			HyperSpaceElementPtr->collision_func = hyper_collision;
-
-			SetUpElement (HyperSpaceElementPtr);
-
-			if (SDPtr == CurStarDescPtr
+				
+				HyperSpaceElementPtr->preprocess_func = NULL;
+				HyperSpaceElementPtr->postprocess_func = NULL;
+				HyperSpaceElementPtr->collision_func = hyper_collision;
+				
+				SetUpElement (HyperSpaceElementPtr);
+				
+				if (SDPtr == CurStarDescPtr
+				    && GET_GAME_STATE (PORTAL_COUNTER) == 0)
+					HyperSpaceElementPtr->death_func = hyper_death;
+				else
+				{
+					HyperSpaceElementPtr->death_func = NULL;
+					HyperSpaceElementPtr->IntersectControl.IntersectStamp.frame =
+					DecFrameIndex (stars_in_space);
+				}
+				UnlockElement (hHyperSpaceElement);
+				
+				InsertElement (hHyperSpaceElement, GetHeadElement ());
+			} else {
+				// BW: first the actual star
+				if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1 
+					|| ((GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1) && STAR_COLOR (star_type) == YELLOW_BODY))
+				{
+					hHyperSpaceElement = AllocHyperElement (SDPtr);
+					if (hHyperSpaceElement == 0)
+					continue;
+				
+					LockElement (hHyperSpaceElement, &HyperSpaceElementPtr);
+				
+					// JMS_GFX: Draw stars in hyperspace.
+					if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
+					{
+						// The color, then the size and finally
+						// the frame offset for the actual animation
+						HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (
+						hyperspacesuns, STAR_COLOR (star_type) * NUM_STAR_TYPES * NUM_SUNS_FRAMES
+						+ STAR_TYPE (star_type) * NUM_SUNS_FRAMES
+						+ frameCounter % NUM_SUNS_FRAMES);
+					
+						HyperSpaceElementPtr->current.image.farray = &hyperspacesuns;
+						HyperSpaceElementPtr->death_func = NULL;
+					}
+					// JMS_GFX: Draw Arilou homeworld in quasispace.
+					else if ((GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1) && STAR_COLOR (star_type) == YELLOW_BODY)
+					{
+						HyperSpaceElementPtr->current.image.frame = 
+						SetAbsFrameIndex (hyperstars[2], 5);
+					
+						HyperSpaceElementPtr->current.image.farray = &hyperstars[2];
+						HyperSpaceElementPtr->death_func = hyper_death;
+					}
+				
+					HyperSpaceElementPtr->preprocess_func = NULL;
+					HyperSpaceElementPtr->postprocess_func = NULL;
+					HyperSpaceElementPtr->collision_func = hyper_collision;
+				
+					SetUpElement (HyperSpaceElementPtr);
+				
+					HyperSpaceElementPtr->IntersectControl.IntersectStamp.frame = DecFrameIndex (stars_in_space);
+				
+					UnlockElement (hHyperSpaceElement);
+				
+					InsertElement (hHyperSpaceElement, GetHeadElement ());
+				
+					// JMS_GFX: Don't draw hole for arilou homeworld - it already has a nice planet gfx.
+					if ((GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1) && STAR_COLOR (star_type) == YELLOW_BODY)
+						continue;
+				
+				}
+				
+				// BW: and then the animated hyperspace portal
+				hHyperSpaceElement = AllocHyperElement (SDPtr);
+				if (hHyperSpaceElement == 0)
+					continue;
+				
+				LockElement (hHyperSpaceElement, &HyperSpaceElementPtr);
+				which_spaces_star_gfx = 1 + (GET_GAME_STATE (ARILOU_SPACE_SIDE) >> 1);
+				
+				// Most holes go 100, 150, 200 or 150, 200, 250
+				HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (
+					hyperholes[which_spaces_star_gfx],
+					STAR_TYPE (star_type) * NUM_HOLES_FRAMES);
+				
+				// Green, orange and yellow need bigger holes
+				if (STAR_COLOR (star_type) == GREEN_BODY 
+					|| STAR_COLOR (star_type) == ORANGE_BODY 
+					|| STAR_COLOR (star_type) == YELLOW_BODY)
+					HyperSpaceElementPtr->current.image.frame = SetRelFrameIndex (
+						HyperSpaceElementPtr->current.image.frame,
+						NUM_HOLES_FRAMES);
+				
+				// Super giant blue needs a bigger hole
+				if (STAR_COLOR (star_type) == BLUE_BODY 
+					&& STAR_TYPE (star_type) == SUPER_GIANT_STAR)
+					HyperSpaceElementPtr->current.image.frame = SetRelFrameIndex (
+						HyperSpaceElementPtr->current.image.frame,
+						NUM_HOLES_FRAMES);
+				
+				// The actual animation
+				HyperSpaceElementPtr->current.image.frame = SetRelFrameIndex (
+					HyperSpaceElementPtr->current.image.frame,
+					frameCounter % NUM_HOLES_FRAMES);
+				
+				HyperSpaceElementPtr->current.image.farray = &hyperholes[which_spaces_star_gfx];
+				HyperSpaceElementPtr->preprocess_func = NULL;
+				HyperSpaceElementPtr->postprocess_func = NULL;
+				HyperSpaceElementPtr->collision_func = hyper_collision;
+				
+				SetUpElement (HyperSpaceElementPtr);
+				
+				if (SDPtr == CurStarDescPtr
 					&& GET_GAME_STATE (PORTAL_COUNTER) == 0)
-				HyperSpaceElementPtr->death_func = hyper_death;
-			else
-			{
-				HyperSpaceElementPtr->death_func = NULL;
-				HyperSpaceElementPtr->IntersectControl.IntersectStamp.frame =
-						DecFrameIndex (stars_in_space);
+					HyperSpaceElementPtr->death_func = hyper_death;
+				else
+				{
+					HyperSpaceElementPtr->death_func = NULL;
+					HyperSpaceElementPtr->IntersectControl.IntersectStamp.frame =
+					DecFrameIndex (stars_in_space);
+				}
+				UnlockElement (hHyperSpaceElement);
+				
+				InsertElement (hHyperSpaceElement, GetHeadElement ());	
 			}
-			UnlockElement (hHyperSpaceElement);
-
-			InsertElement (hHyperSpaceElement, GetHeadElement ());
 		}
 		ProcessEncounters (&universe, ox, oy);
 	}
diff -ruNp src.mm/uqm/hyper.h src/uqm/hyper.h
--- src.mm/uqm/hyper.h	2017-11-28 11:08:48 -0600
+++ src/uqm/hyper.h	2017-11-28 11:09:34 -0600
@@ -29,8 +29,8 @@ extern "C" {
 
 #define NUM_RADAR_SCREENS 12
 
-#define RADAR_SCAN_WIDTH (UNIT_SCREEN_WIDTH * NUM_RADAR_SCREENS)
-#define RADAR_SCAN_HEIGHT (UNIT_SCREEN_HEIGHT * NUM_RADAR_SCREENS)
+#define RADAR_SCAN_WIDTH ((UNIT_SCREEN_WIDTH * NUM_RADAR_SCREENS) >> RESOLUTION_FACTOR)
+#define RADAR_SCAN_HEIGHT ((UNIT_SCREEN_HEIGHT * NUM_RADAR_SCREENS) >> RESOLUTION_FACTOR)
 
 // Hyperspace coordinates of the naturally occuring portal into QuasiSpace
 #define ARILOU_SPACE_X   438
@@ -41,8 +41,8 @@ extern "C" {
 #define QUASI_SPACE_Y  5000
 
 // QuasiSpace coordinates of the Arilou home world
-#define ARILOU_HOME_X  (QUASI_SPACE_X + ((RADAR_SCAN_WIDTH >> 1) * 3))
-#define ARILOU_HOME_Y  (QUASI_SPACE_Y + ((RADAR_SCAN_HEIGHT >> 1) * 3))
+#define ARILOU_HOME_X 6134 // (QUASI_SPACE_X + ((RADAR_SCAN_WIDTH >> 1) * 3))
+#define ARILOU_HOME_Y 5900 // (QUASI_SPACE_Y + ((RADAR_SCAN_HEIGHT >> 1) * 3))
 
 // HyperSpace coordinates of the locations where the QuasiSpace portals
 // take you.
@@ -74,7 +74,7 @@ extern "C" {
 extern BOOLEAN LoadHyperspace (void);
 extern BOOLEAN FreeHyperspace (void);
 extern void SeedUniverse (void);
-extern void MoveSIS (SIZE *pdx, SIZE *pdy);
+extern void MoveSIS (SDWORD *pdx, SDWORD *pdy);
 
 extern void FreeHyperData (void);
 extern void check_hyperspace_encounter (void);
diff -ruNp src.mm/uqm/ifontres.h src/uqm/ifontres.h
--- src.mm/uqm/ifontres.h	2017-11-28 11:08:48 -0600
+++ src/uqm/ifontres.h	2017-11-28 11:09:34 -0600
@@ -2,12 +2,19 @@
    should not be edited directly.  Modify the master resource list
    instead and regenerate. */
 
+#define FALLBACK_TO1X_FONT "font.fallbackto1x"
+#define FALLBACK_TO2X_FONT "font.fallbackto2x"
+#define FALLBACK_TO4X_FONT "font.fallbackto4x"
 #define LANDER_FONT "font.lander"
 #define MICRO_FONT "font.micro"
+#define NANO_FONT "font.nano"
 #define PLAYER_FONT "font.player"
 #define PT13AA_FONT "credits.font.pt13"
 #define PT17AA_FONT "credits.font.pt17"
 #define PT45AA_FONT "credits.font.pt45"
 #define STARCON_FONT "font.starcon"
 #define TINY_FONT "font.tiny"
+#define TINY_FALLBACK_TO1X_FONT "font.tinyfallbackto1x"
+#define TINY_FALLBACK_TO2X_FONT "font.tinyfallbackto2x"
+#define TINY_FALLBACK_TO4X_FONT "font.tinyfallbackto4x"
 #define COMPUTER_FONT "comm.computer.font"
diff -ruNp src.mm/uqm/igfxres.h src/uqm/igfxres.h
--- src.mm/uqm/igfxres.h	2017-11-28 11:08:48 -0600
+++ src/uqm/igfxres.h	2017-11-28 11:09:34 -0600
@@ -5,6 +5,8 @@
 #define ACTIVITY_ANIM "graphics.activity"
 #define AMBIENT_MASK_PMAP_ANIM "graphics.ambient"
 #define AQUA_MASK_PMAP_ANIM "graphics.aquahelix"
+#define ARI_AMBIENT_MASK_PMAP_ANIM "graphics.ambientquasispace"
+#define ARIHOLES_MASK_PMAP_ANIM "graphics.quasiholes"
 #define ARISPACE_MASK_PMAP_ANIM "graphics.quasispace"
 #define ASTEROID_BIG_MASK_PMAP_ANIM "graphics.asteroid.large"
 #define ASTEROID_MED_MASK_PMAP_ANIM "graphics.asteroid.medium"
@@ -27,7 +29,9 @@
 #define FLAGSTAT_MASK_PMAP_ANIM "graphics.flagshipstatus"
 #define FONTGRAD_PMAP_ANIM "graphics.fontgradient"
 #define GANYMEDE_MASK_ANIM "graphics.ganymedemask"
+#define HYPERHOLES_MASK_PMAP_ANIM "graphics.hyperholes"
 #define HYPERSTARS_MASK_PMAP_ANIM "graphics.hyperstars"
+#define HYPERSUNS_MASK_PMAP_ANIM "graphics.hypersuns"
 #define IO_MASK_ANIM "graphics.iomask"
 #define IPBKGND_MASK_PMAP_ANIM "graphics.orbitbackground"
 #define IP_CALLISTO_MASK_ANIM "graphics.ipcallistomask"
@@ -86,6 +90,8 @@
 #define MELEE_PICK_MASK_PMAP_ANIM "graphics.meleepickship"
 #define MELEE_SCREEN_PMAP_ANIM "graphics.meleemenu"
 #define MENUBKG_PMAP_ANIM "graphics.setupmenu"
+#define MENUBKG_PMAP_ANIM2X "graphics.setupmenu2x"
+#define MENUBKG_PMAP_ANIM4X "graphics.setupmenu4x"
 #define MERCURY_MASK_ANIM "graphics.mercurymask"
 #define MISCDATA_MASK_PMAP_ANIM "graphics.miscdata"
 #define MODULES_PMAP_ANIM "graphics.modulesmenu"
@@ -278,6 +284,8 @@
 #define PLUTO_MASK_ANIM "graphics.plutomask"
 #define QUAKE_MASK_PMAP_ANIM "graphics.quake"
 #define RESTART_PMAP_ANIM "graphics.newgame"
+#define RESTART_PMAP_ANIM2x "graphics.newgame2x"
+#define RESTART_PMAP_ANIM4x "graphics.newgame4x"
 #define RUINS_MASK_PMAP_ANIM "graphics.ruins"
 #define SAMATRA_BIG_MASK_PMAP_ANIM "planet.samatra.large"
 #define SATURN_MASK_ANIM "graphics.saturnmask"
@@ -296,11 +304,19 @@
 #define STAR_MASK_PMAP_ANIM "graphics.stars"
 #define STATUS_MASK_PMAP_ANIM "graphics.status"
 #define SUBMENU_MASK_PMAP_ANIM "graphics.submenu"
+#define SUNBLUE_MASK_PMAP_ANIM "graphics.truespacesunblue"
+#define SUNGREEN_MASK_PMAP_ANIM "graphics.truespacesungreen"
+#define SUNORANGE_MASK_PMAP_ANIM "graphics.truespacesunorange"
+#define SUNRED_MASK_PMAP_ANIM "graphics.truespacesunred"
+#define SUNWHITE_MASK_PMAP_ANIM "graphics.truespacesunwhite"
+#define SUNYELLOW_MASK_PMAP_ANIM "graphics.truespacesunyellow"
 #define SUN_DEVICE_MASK_PMAP_ANIM "graphics.sundevice"
 #define SUN_MASK_PMAP_ANIM "graphics.truespacesun"
 #define TAALO_DEVICE_MASK_PMAP_ANIM "graphics.taalodevice"
 #define TITAN_MASK_ANIM "graphics.titanmask"
 #define TITLE_ANIM "graphics.title"
+#define TITLE_2X "graphics.title2x"
+#define TITLE_4X "graphics.title4x"
 #define TRITON_MASK_ANIM "graphics.tritonmask"
 #define UMGAH_BCS_MASK_PMAP_ANIM "graphics.umgahcaster"
 #define URANUS_MASK_ANIM "graphics.uranusmask"
diff -ruNp src.mm/uqm/init.c src/uqm/init.c
--- src.mm/uqm/init.c	2017-11-28 11:08:48 -0600
+++ src/uqm/init.c	2017-11-28 11:09:34 -0600
@@ -37,6 +37,7 @@
 
 
 FRAME stars_in_space;
+FRAME stars_in_quasispace; // JMS_GFX
 FRAME asteroid[NUM_VIEWS];
 FRAME blast[NUM_VIEWS];
 FRAME explosion[NUM_VIEWS];
diff -ruNp src.mm/uqm/init.h src/uqm/init.h
--- src.mm/uqm/init.h	2017-11-28 11:08:48 -0600
+++ src/uqm/init.h	2017-11-28 11:09:34 -0600
@@ -28,6 +28,7 @@ extern "C" {
 #define NUM_SIDES 2
 
 extern FRAME stars_in_space;
+extern FRAME stars_in_quasispace; // JMS_GFX
 
 extern BOOLEAN InitSpace (void);
 extern void UninitSpace (void);
diff -ruNp src.mm/uqm/intel.h src/uqm/intel.h
--- src.mm/uqm/intel.h	2017-11-28 11:08:48 -0600
+++ src/uqm/intel.h	2017-11-28 11:09:34 -0600
@@ -39,6 +39,29 @@ extern "C" {
 #define MEDIUM_SHIP 45
 #define SLOW_SHIP 25
 
+// JMS_GFX
+#define CLOSE_RANGE_WEAPON_2XRES DISPLAY_TO_WORLD (100)
+#define LONG_RANGE_WEAPON_2XRES DISPLAY_TO_WORLD (2000)
+
+// JMS_GFX: Multiplied by 2*2=4 because of the way the ManeuverabilityIndex
+// is calculated in InitCyborg () (cyborg.c).
+#define FAST_SHIP_2XRES 600
+#define MEDIUM_SHIP_2XRES 180
+#define SLOW_SHIP_2XRES 100
+
+// JMS_GFX
+#define CLOSE_RANGE_WEAPON_4XRES DISPLAY_TO_WORLD (200)
+#define LONG_RANGE_WEAPON_4XRES DISPLAY_TO_WORLD (4000)
+
+// JMS_GFX: Multiplied by 4*4=16 because of the way the ManeuverabilityIndex
+// is calculated in InitCyborg () (cyborg.c).
+#define FAST_SHIP_4XRES 2400
+#define MEDIUM_SHIP_4XRES 720
+#define SLOW_SHIP_4XRES 400
+
+// JMS_GFX
+#define RESOLUTION_COMPENSATED(speed) ((speed << RESOLUTION_FACTOR) << RESOLUTION_FACTOR)
+
 enum
 {
 	ENEMY_SHIP_INDEX = 0,
diff -ruNp src.mm/uqm/intro.c src/uqm/intro.c
--- src.mm/uqm/intro.c	2017-11-28 11:08:48 -0600
+++ src/uqm/intro.c	2017-11-28 11:09:34 -0600
@@ -179,10 +179,12 @@ Present_UnbatchGraphics (PRESENTATION_IN
 static void
 Present_GenerateSIS (PRESENTATION_INPUT_STATE* pPIS)
 {
-#define MODULE_YOFS_P  (-79)
+#define MODULE_YOFS_P  (((-79) << RESOLUTION_FACTOR) + RES_CASE(0,-34,-94)) // JMS_GFX
 #define DRIVE_TOP_Y_P  (DRIVE_TOP_Y + MODULE_YOFS_P)
 #define JET_TOP_Y_P    (JET_TOP_Y + MODULE_YOFS_P)
 #define MODULE_TOP_Y_P (MODULE_TOP_Y + MODULE_YOFS_P)
+#define MODULE_TOP_X_P (MODULE_TOP_X + RES_CASE(0,18,0))
+#define JET_DRIVE_EXTRA_X RES_CASE(0,5,-3)
 	CONTEXT	OldContext;
 	FRAME SisFrame;
 	FRAME ModuleFrame;
@@ -220,7 +222,7 @@ Present_GenerateSIS (PRESENTATION_INPUT_
 		piece = GLOBAL_SIS (DriveSlots[slot]);
 		if (piece < EMPTY_SLOT)
 		{
-			s.origin.x = DRIVE_TOP_X;
+			s.origin.x = DRIVE_TOP_X + JET_DRIVE_EXTRA_X;
 			s.origin.y = DRIVE_TOP_Y_P;
 			s.origin.x += slot * SHIP_PIECE_OFFSET;
 			s.frame = SetAbsFrameIndex (ModuleFrame, piece);
@@ -232,7 +234,7 @@ Present_GenerateSIS (PRESENTATION_INPUT_
 		piece = GLOBAL_SIS (JetSlots[slot]);
 		if (piece < EMPTY_SLOT)
 		{
-			s.origin.x = JET_TOP_X;
+			s.origin.x = JET_TOP_X + JET_DRIVE_EXTRA_X;
 			s.origin.y = JET_TOP_Y_P;
 			s.origin.x += slot * SHIP_PIECE_OFFSET;
 			s.frame = SetAbsFrameIndex (ModuleFrame, piece);
@@ -244,7 +246,7 @@ Present_GenerateSIS (PRESENTATION_INPUT_
 		piece = GLOBAL_SIS (ModuleSlots[slot]);
 		if (piece < EMPTY_SLOT)
 		{
-			s.origin.x = MODULE_TOP_X;
+			s.origin.x = MODULE_TOP_X_P;
 			s.origin.y = MODULE_TOP_Y_P;
 			s.origin.x += slot * SHIP_PIECE_OFFSET;
 			s.frame = SetAbsFrameIndex (ModuleFrame, piece);
@@ -351,6 +353,9 @@ DoPresentation (void *pIS)
 			int w, h;
 			if (2 == sscanf (pStr, "%d %d", &w, &h))
 			{
+				w <<= RESOLUTION_FACTOR; // JMS_GFX
+				h <<= RESOLUTION_FACTOR; // JMS_GFX
+
 				pPIS->clip_r.extent.width = w;
 				pPIS->clip_r.extent.height = h;
 				/* center on screen */
@@ -383,6 +388,78 @@ DoPresentation (void *pIS)
 			}
 
 			SetContextFont (*pFont);
+		}		
+		else if (strcmp (Opcode, "FONT1X") == 0 && RESOLUTION_FACTOR == 0)
+		{	/* set and/or load a font */
+			int index;
+			FONT *pFont;
+			
+			assert (sizeof (pPIS->Buffer) >= 256);
+			
+			pPIS->Buffer[0] = '\0';
+			if (1 > sscanf (pStr, "%d %255[^\n]", &index, pPIS->Buffer) ||
+				index < 0 || index >= MAX_FONTS)
+			{
+				log_add (log_Warning, "Bad FONT command '%s'", pStr);
+				continue;
+			}
+			pFont = &pPIS->Fonts[index];
+			
+			if (pPIS->Buffer[0])
+			{	/* asked to load a font */
+				if (*pFont)
+					DestroyFont (*pFont);
+				*pFont = LoadFontFile (pPIS->Buffer);
+			}
+			SetContextFont (*pFont);
+		}
+		else if (strcmp (Opcode, "FONT2X") == 0 && RESOLUTION_FACTOR == 1)
+		{	/* set and/or load a font */
+			int index;
+			FONT *pFont;
+			
+			assert (sizeof (pPIS->Buffer) >= 256);
+			
+			pPIS->Buffer[0] = '\0';
+			if (1 > sscanf (pStr, "%d %255[^\n]", &index, pPIS->Buffer) ||
+				index < 0 || index >= MAX_FONTS)
+			{
+				log_add (log_Warning, "Bad FONT command '%s'", pStr);
+				continue;
+			}
+			pFont = &pPIS->Fonts[index];
+			
+			if (pPIS->Buffer[0])
+			{	/* asked to load a font */
+				if (*pFont)
+					DestroyFont (*pFont);
+				*pFont = LoadFontFile (pPIS->Buffer);
+			}
+			SetContextFont (*pFont);;
+		}
+		else if (strcmp (Opcode, "FONT4X") == 0 && RESOLUTION_FACTOR == 2)
+		{	/* set and/or load a font */
+			int index;
+			FONT *pFont;
+			
+			assert (sizeof (pPIS->Buffer) >= 256);
+			
+			pPIS->Buffer[0] = '\0';
+			if (1 > sscanf (pStr, "%d %255[^\n]", &index, pPIS->Buffer) ||
+				index < 0 || index >= MAX_FONTS)
+			{
+				log_add (log_Warning, "Bad FONT command '%s'", pStr);
+				continue;
+			}
+			pFont = &pPIS->Fonts[index];
+			
+			if (pPIS->Buffer[0])
+			{	/* asked to load a font */
+				if (*pFont)
+					DestroyFont (*pFont);
+				*pFont = LoadFontFile (pPIS->Buffer);
+			}
+			SetContextFont (*pFont);
 		}
 		else if (strcmp (Opcode, "ANI") == 0)
 		{	/* set ani */
@@ -391,6 +468,27 @@ DoPresentation (void *pIS)
 				DestroyDrawable (ReleaseDrawable (pPIS->Frame));
 			pPIS->Frame = CaptureDrawable (LoadGraphicFile (pPIS->Buffer));
 		}
+		else if (strcmp (Opcode, "ANI1X") == 0 && RESOLUTION_FACTOR == 0)
+		{	/* set ani */
+			utf8StringCopy (pPIS->Buffer, sizeof (pPIS->Buffer), pStr);
+			if (pPIS->Frame)
+				DestroyDrawable (ReleaseDrawable (pPIS->Frame));
+			pPIS->Frame = CaptureDrawable (LoadGraphicFile (pPIS->Buffer));
+		}
+		else if (strcmp (Opcode, "ANI2X") == 0 && RESOLUTION_FACTOR == 1)
+		{	/* set ani */
+			utf8StringCopy (pPIS->Buffer, sizeof (pPIS->Buffer), pStr);
+			if (pPIS->Frame)
+				DestroyDrawable (ReleaseDrawable (pPIS->Frame));
+			pPIS->Frame = CaptureDrawable (LoadGraphicFile (pPIS->Buffer));
+		}
+		else if (strcmp (Opcode, "ANI4X") == 0 && RESOLUTION_FACTOR == 2)
+		{	/* set ani */
+			utf8StringCopy (pPIS->Buffer, sizeof (pPIS->Buffer), pStr);
+			if (pPIS->Frame)
+				DestroyDrawable (ReleaseDrawable (pPIS->Frame));
+			pPIS->Frame = CaptureDrawable (LoadGraphicFile (pPIS->Buffer));
+		}
 		else if (strcmp (Opcode, "MUSIC") == 0)
 		{	/* set music */
 			utf8StringCopy (pPIS->Buffer, sizeof (pPIS->Buffer), pStr);
@@ -473,6 +571,9 @@ DoPresentation (void *pIS)
 			{
 				TEXT t;
 
+				x <<= RESOLUTION_FACTOR; // JMS_GFX
+				y <<= RESOLUTION_FACTOR; // JMS_GFX
+
 				t.align = ALIGN_CENTER;
 				t.pStr = pPIS->Buffer;
 				t.CharCount = (COUNT)~0;
@@ -603,6 +704,9 @@ DoPresentation (void *pIS)
 				y = 0;
 			}
 
+			x <<= RESOLUTION_FACTOR; // JMS_GFX
+			y <<= RESOLUTION_FACTOR; // JMS_GFX
+
 			s.frame = NULL;
 			if (draw_what == PRES_DRAW_INDEX)
 			{	/* draw stamp by index */
@@ -679,6 +783,11 @@ DoPresentation (void *pIS)
 			{
 				LINE l;
 
+				x1 <<= RESOLUTION_FACTOR; // JMS_GFX
+				y1 <<= RESOLUTION_FACTOR; // JMS_GFX
+				x2 <<= RESOLUTION_FACTOR; // JMS_GFX
+				y2 <<= RESOLUTION_FACTOR; // JMS_GFX
+
 				l.first.x = x1;
 				l.first.y = y1;
 				l.second.x = x2;
diff -ruNp src.mm/uqm/load.c src/uqm/load.c
--- src.mm/uqm/load.c	2017-11-28 11:08:49 -0600
+++ src/uqm/load.c	2017-11-28 11:09:34 -0600
@@ -29,7 +29,8 @@
 #include "setup.h"
 #include "state.h"
 #include "grpintrn.h"
-
+#include "util.h"
+#include "gamestr.h" // JMS: For GAME_STRING
 #include "libs/tasklib.h"
 #include "libs/log.h"
 #include "libs/misc.h"
@@ -266,6 +267,9 @@ LoadEncounter (ENCOUNTER *EncounterPtr,
 	// Load the stuff after the BRIEF_SHIP_INFO array
 	read_32s (fh, &EncounterPtr->log_x);
 	read_32s (fh, &EncounterPtr->log_y);
+
+	EncounterPtr->log_x <<= RESOLUTION_FACTOR;
+	EncounterPtr->log_y <<= RESOLUTION_FACTOR;
 }
 
 static void
@@ -290,9 +294,11 @@ LoadClockState (CLOCK_STATE *ClockPtr, v
 }
 
 static BOOLEAN
-LoadGameState (GAME_STATE *GSPtr, void *fh)
+LoadGameState (GAME_STATE *GSPtr, void *fh, BOOLEAN TryVanilla)
 {
 	DWORD magic;
+	BYTE res_scale; // JMS
+
 	read_32 (fh, &magic);
 	if (magic != GLOBAL_STATE_TAG)
 	{
@@ -307,10 +313,28 @@ LoadGameState (GAME_STATE *GSPtr, void *
 	read_8   (fh, &GSPtr->glob_flags);
 	read_8   (fh, &GSPtr->CrewCost);
 	read_8   (fh, &GSPtr->FuelCost);
+
+	// JMS: Now that we have read the fuelcost, we can compare it
+	// to the correct value. Fuel cost is always FUEL_COST_RU, and if
+	// the savefile tells otherwise, we have read it with the wrong method
+	// (The savegame is from vanilla UQM and we've been reading it as if it
+	// were UQM-HD save.)
+	//
+	// At this point we must then cease reading the savefile, close it
+	// and re-open it again, this time using the vanilla-reading method.
+	if (GSPtr->FuelCost != 20)
+		return FALSE;
+
 	read_a8  (fh, GSPtr->ModuleCost, NUM_MODULES);
 	read_a8  (fh, GSPtr->ElementWorth, NUM_ELEMENT_CATEGORIES);
 	read_16  (fh, &GSPtr->CurrentActivity);
 
+	// JMS
+	if (LOBYTE (GSPtr->CurrentActivity) != IN_INTERPLANETARY)
+		res_scale = RESOLUTION_FACTOR;
+	else
+		res_scale = 0;
+
 	LoadClockState (&GSPtr->GameClock, fh);
 
 	read_16s (fh, &GSPtr->autopilot.x);
@@ -324,6 +348,10 @@ LoadGameState (GAME_STATE *GSPtr, void *
 	read_8   (fh, &GSPtr->ip_planet);
 	read_8   (fh, &GSPtr->in_orbit);
 
+	// JMS: Let's make savegames work even between different resolution modes.
+	GSPtr->ShipStamp.origin.x <<= RESOLUTION_FACTOR; 
+	GSPtr->ShipStamp.origin.y <<= RESOLUTION_FACTOR; 
+
 	/* VELOCITY_DESC velocity */
 	read_16  (fh, &GSPtr->velocity.TravelAngle);
 	read_16s (fh, &GSPtr->velocity.vector.width);
@@ -335,13 +363,24 @@ LoadGameState (GAME_STATE *GSPtr, void *
 	read_16s (fh, &GSPtr->velocity.incr.width);
 	read_16s (fh, &GSPtr->velocity.incr.height);
 
+	// JMS: Let's make savegames work even between different resolution modes.
+	GSPtr->velocity.vector.width  <<= res_scale; 
+	GSPtr->velocity.vector.height <<= res_scale; 
+	GSPtr->velocity.fract.width	  <<= res_scale; 
+	GSPtr->velocity.fract.height  <<= res_scale; 
+	GSPtr->velocity.error.width	  <<= res_scale; 
+	GSPtr->velocity.error.height  <<= res_scale; 
+	GSPtr->velocity.incr.width	  <<= res_scale; 
+	GSPtr->velocity.incr.height	  <<= res_scale; 
+ 
+
 	read_32 (fh, &magic);
 	if (magic != GAME_STATE_TAG)
 	{
 		return FALSE;
 	}
 	{
-		size_t gameStateByteCount = (NUM_GAME_STATE_BITS + 7) >> 3;
+		size_t gameStateByteCount = ((TryVanilla ? (NUM_GAME_STATE_BITS - 17) : NUM_GAME_STATE_BITS) + 7) >> 3;
 		BYTE *buf;
 		BOOLEAN result;
 
@@ -401,14 +440,20 @@ LoadSisState (SIS_STATE *SSPtr, void *fp
 			read_str (fp, SSPtr->PlanetName, SIS_NAME_SIZE) != 1
 		)
 		return FALSE;
-	return TRUE;
+ 	else {
+		// JMS: Let's make savegames work even between different resolution modes.
+		SSPtr->log_x <<= RESOLUTION_FACTOR;
+		SSPtr->log_y <<= RESOLUTION_FACTOR;
+		return TRUE;
+	}
 }
 
 static BOOLEAN
-LoadSummary (SUMMARY_DESC *SummPtr, void *fp)
+LoadSummary (SUMMARY_DESC *SummPtr, void *fp, BOOLEAN TryVanilla)
 {
 	SDWORD magic;
 	DWORD nameSize = 0;
+
 	if (!read_32s (fp, &magic))
 		return FALSE;
 	if (magic == SAVEFILE_TAG)
@@ -438,7 +483,8 @@ LoadSummary (SUMMARY_DESC *SummPtr, void
 			read_8  (fp, &SummPtr->NumShips) != 1 ||
 			read_8  (fp, &SummPtr->NumDevices) != 1 ||
 			read_a8 (fp, SummPtr->ShipList, MAX_BUILT_SHIPS) != 1 ||
-			read_a8 (fp, SummPtr->DeviceList, MAX_EXCLUSIVE_DEVICES) != 1
+			read_a8 (fp, SummPtr->DeviceList, MAX_EXCLUSIVE_DEVICES) != 1 ||
+			read_8  (fp, &SummPtr->res_factor) != 1 // JMS: This'll help making saves between different resolutions compatible.		
 		)
 		return FALSE;
 	
@@ -457,6 +503,12 @@ LoadSummary (SUMMARY_DESC *SummPtr, void
 		if (skip_8 (fp, remaining) != 1)
 			return FALSE;
 	}
+
+	// JMS: UQM-HD saves have an extra piece of padding to compensate for the
+	// added res_factor in SummPtr.
+	if (!TryVanilla)
+		read_8 (fp, NULL); /* padding */
+
 	return TRUE;
 }
 
@@ -655,7 +707,7 @@ LoadBattleGroup (uio_Stream *fh, DWORD c
 }
 
 BOOLEAN
-LoadGame (COUNT which_game, SUMMARY_DESC *SummPtr)
+LoadGame (COUNT which_game, SUMMARY_DESC *SummPtr, BOOLEAN TryVanilla)
 {
 	uio_Stream *in_fp;
 	char file[PATH_MAX];
@@ -669,9 +721,16 @@ LoadGame (COUNT which_game, SUMMARY_DESC
 	sprintf (file, "uqmsave.%02u", which_game);
 	in_fp = res_OpenResFile (saveDir, file, "rb");
 	if (!in_fp)
-		return LoadLegacyGame (which_game, SummPtr);
+		return LoadLegacyGame (which_game, SummPtr);	
 
-	if (!LoadSummary (&loc_sd, in_fp))
+	if (!LoadSummary (&loc_sd, in_fp, TryVanilla))
+	{
+		log_add (log_Error, "Warning: Savegame is corrupt");
+		res_CloseResFile (in_fp);
+		return FALSE;
+	}
+
+	if (!LoadSummary (&loc_sd, in_fp, TryVanilla))
 	{
 		res_CloseResFile (in_fp);
 		return LoadLegacyGame (which_game, SummPtr);
@@ -702,11 +761,22 @@ LoadGame (COUNT which_game, SUMMARY_DESC
 	initEventSystem ();
 
 	Activity = GLOBAL (CurrentActivity);
-	if (!LoadGameState (&GlobData.Game_state, in_fp))
+
+	// JMS: We can decide whether the current savefile is vanilla UQM or UQM-HD
+	// only at this point, when reading the game states. If this turns out to be a 
+	// vanilla UQM save, we must close the file and re-open it for reading
+	// with the vanilla method.
+	if (!LoadGameState (&GlobData.Game_state, in_fp, TryVanilla))
 	{
 		res_CloseResFile (in_fp);
-		return FALSE;
+		if (!TryVanilla) {
+			LoadGame (which_game, NULL, TRUE);
+			return TRUE;
+		}
+		else
+			return FALSE;
 	}
+
 	NextActivity = GLOBAL (CurrentActivity);
 	GLOBAL (CurrentActivity) = Activity;
 
diff -ruNp src.mm/uqm/load_legacy.c src/uqm/load_legacy.c
--- src.mm/uqm/load_legacy.c	2017-11-28 11:08:49 -0600
+++ src/uqm/load_legacy.c	2017-11-28 11:09:34 -0600
@@ -882,10 +882,10 @@ LoadGameState (GAME_STATE *GSPtr, DECODE
 	DummyLoadQueue (&GSPtr->built_ship_q, fh);
 
 	{
-		size_t numBytes = (NUM_GAME_STATE_BITS + 7) >> 3;
+		size_t numBytes = ((NUM_GAME_STATE_BITS - 17) + 7) >> 3;
 		BYTE *buf;
 
-		assert (numBytes % 4 == 3);
+		// assert (numBytes % 4 == 3);
 				// We should have one byte padding.
 		buf = HMalloc (numBytes);
 		if (buf != NULL)
diff -ruNp src.mm/uqm/menu.c src/uqm/menu.c
--- src.mm/uqm/menu.c	2017-11-28 11:08:49 -0600
+++ src/uqm/menu.c	2017-11-28 11:09:35 -0600
@@ -76,7 +76,7 @@ static UNICODE pm_fuel_str[128];
 static void
 DrawPCMenu (BYTE beg_index, BYTE end_index, BYTE NewState, BYTE hilite, RECT *r)
 {
-#define PC_MENU_HEIGHT 8
+#define PC_MENU_HEIGHT (RES_STAT_SCALE(8)) // JMS_GFX
 	BYTE pos;
 	COUNT i;
 	int num_items;
@@ -98,7 +98,7 @@ DrawPCMenu (BYTE beg_index, BYTE end_ind
 	OldFont = SetContextFont (StarConFont);
 	t.align = ALIGN_LEFT;
 	t.baseline.x = r->corner.x + 2;
-	t.baseline.y = r->corner.y + PC_MENU_HEIGHT -1;
+	t.baseline.y = r->corner.y + PC_MENU_HEIGHT - (1 << RESOLUTION_FACTOR);// - RESOLUTION_FACTOR; // JMS_GFX
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 	r->corner.x++;
@@ -115,7 +115,7 @@ DrawPCMenu (BYTE beg_index, BYTE end_ind
 			
 			// Draw the background of the selection.
 			SetContextForeGroundColor (PCMENU_SELECTION_BACKGROUND_COLOR);
-			r->corner.y = t.baseline.y - PC_MENU_HEIGHT + 2;
+			r->corner.y = t.baseline.y - PC_MENU_HEIGHT + RES_STAT_SCALE(2); // + RESOLUTION_FACTOR; // JMS_GFX
 			r->extent.height = PC_MENU_HEIGHT - 1;
 			DrawFilledRectangle (r);
 
@@ -503,7 +503,7 @@ DrawMenuStateStrings (BYTE beg_index, SW
 	s.origin.x = RADAR_X - r.corner.x;
 	s.origin.y = RADAR_Y - r.corner.y;
 	r.corner.x = s.origin.x - 1;
-	r.corner.y = s.origin.y - 11;
+	r.corner.y = s.origin.y - (11 << RESOLUTION_FACTOR); // JMS_GFX
 	r.extent.width = RADAR_WIDTH + 2;
 	BatchGraphics ();
 	SetContextForeGroundColor (
@@ -548,7 +548,15 @@ DrawMenuStateStrings (BYTE beg_index, SW
 					break;
 			}
 		}
-		r.extent.height = RADAR_HEIGHT + 11;
+		r.extent.height = RADAR_HEIGHT + (11 << RESOLUTION_FACTOR); // JMS_GFX
+
+		// JMS_GFX: This is to fix the two-line high outfit module texts.
+		// They weren't completely erased in 640x480 when exiting module selection.
+		if (RESOLUTION_FACTOR == 1) {
+			r.corner.y -= 7;
+			r.extent.height += 7;
+		}
+
 		DrawPCMenu (beg_index, end_index, (BYTE)NewState, hilite, &r);
 		s.frame = 0;
 	}
@@ -558,10 +566,10 @@ DrawMenuStateStrings (BYTE beg_index, SW
 		{
 			r.corner.x -= 1;
 			r.extent.width += 1;
-			r.extent.height = RADAR_HEIGHT + 11;
+			r.extent.height = RADAR_HEIGHT + (11 << RESOLUTION_FACTOR); // JMS_GFX
 		}
 		else
-			r.extent.height = 11;
+			r.extent.height = 11 << RESOLUTION_FACTOR;
 		DrawFilledRectangle (&r);
 	}
 	if (s.frame)
diff -ruNp src.mm/uqm/misc.c src/uqm/misc.c
--- src.mm/uqm/misc.c	2017-11-28 11:08:49 -0600
+++ src/uqm/misc.c	2017-11-28 11:09:35 -0600
@@ -88,8 +88,13 @@ spawn_rubble (ELEMENT *AsteroidElementPt
 		RubbleElementPtr->turn_wait = RubbleElementPtr->next_turn = 0;
 		SetPrimType (&DisplayArray[RubbleElementPtr->PrimIndex], STAMP_PRIM);
 		RubbleElementPtr->current.image.farray = asteroid;
-		RubbleElementPtr->current.image.frame =
-				SetAbsFrameIndex (asteroid[0], ANGLE_TO_FACING (FULL_CIRCLE));
+		
+		// JMS_GFX
+		if (RESOLUTION_FACTOR == 0)
+			RubbleElementPtr->current.image.frame = SetAbsFrameIndex (asteroid[0], ANGLE_TO_FACING (FULL_CIRCLE));
+		else
+			RubbleElementPtr->current.image.frame = SetAbsFrameIndex (asteroid[0], 29);
+
 		RubbleElementPtr->current.location = AsteroidElementPtr->current.location;
 		RubbleElementPtr->preprocess_func = animation_preprocess;
 		RubbleElementPtr->death_func = spawn_asteroid;
@@ -111,9 +116,13 @@ asteroid_preprocess (ELEMENT *ElementPtr
 			--frame_index;
 		else
 			++frame_index;
-		ElementPtr->next.image.frame =
-				SetAbsFrameIndex (ElementPtr->current.image.frame,
-				NORMALIZE_FACING (frame_index));
+		
+		// JMS_GFX
+		if (RESOLUTION_FACTOR == 0)
+			ElementPtr->next.image.frame = SetAbsFrameIndex (ElementPtr->current.image.frame, NORMALIZE_FACING (frame_index));
+		else
+			ElementPtr->next.image.frame = SetAbsFrameIndex (ElementPtr->current.image.frame, frame_index % 30);
+
 		ElementPtr->state_flags |= CHANGING;
 
 		ElementPtr->turn_wait = (unsigned char)(ElementPtr->thrust_wait & ((1 << 7) - 1));
@@ -260,7 +269,7 @@ crew_preprocess (ELEMENT *ElementPtr)
 
 	if (hTarget)
 	{
-#define CREW_DELTA SCALED_ONE
+#define CREW_DELTA (SCALED_ONE << RESOLUTION_FACTOR)
 		SIZE delta;
 		ELEMENT *ShipPtr;
 
@@ -332,7 +341,7 @@ AbandonShip (ELEMENT *ShipPtr, ELEMENT *
 		dx = dy = 0;
 	else
 	{
-#define MORE_THAN_ENOUGH 100
+#define MORE_THAN_ENOUGH (100 << RESOLUTION_FACTOR) // JMS_GFX
 		direction += HALF_CIRCLE;
 		dx = COSINE (direction, MORE_THAN_ENOUGH);
 		dy = SINE (direction, MORE_THAN_ENOUGH);
diff -ruNp src.mm/uqm/oscill.c src/uqm/oscill.c
--- src.mm/uqm/oscill.c	2017-11-28 11:08:49 -0600
+++ src/uqm/oscill.c	2017-11-28 11:09:35 -0600
@@ -24,7 +24,7 @@
 #include "libs/graphics/drawable.h"
 #include "libs/sound/sound.h"
 #include "libs/sound/trackplayer.h"
-
+#include "libs/log.h"
 
 static FRAME scope_frame;
 static int scope_init = 0;
@@ -71,13 +71,20 @@ void
 DrawOscilloscope (void)
 {
 	STAMP s;
-	BYTE scope_data[128];
+	BYTE scope_data[192]; // JMS_GFX: was 128... FIXME:This is a hack: GraphForeGroundStream would really require this to be
+							// less than 256. This "fix" messes up how the oscilloscope looks, but it works for now
+							// (doesn't get caught in asserts). We need to fix this later.
 
+	// BW: fixed. With narrow status panel at 4x, scope width (and data) are never more than 192.
 	if (oscillDisabled)
 		return;
 
-	assert ((size_t)scopeSize.width <= sizeof scope_data);
-	assert (scopeSize.height < 256);
+	//log_add(log_Debug, "(size_t)scopeSize.width %lu, sizeof(scope_data) %lu", (size_t)scopeSize.width, sizeof(scope_data));
+	
+	assert ((size_t)scopeSize.width <= sizeof(scope_data));
+	assert (scopeSize.height < 256); // JMS_GFX: Was 256. FIXME:This is a hack: GraphForeGroundStream would really require this to be
+	// less than 256. This "fix" messes up how the oscilloscope looks, but it works for now
+	// (doesn't get caught in asserts). We need to fix this later.
 
 	if (GraphForegroundStream (scope_data, scopeSize.width, scopeSize.height,
 			usingSpeech))
diff -ruNp src.mm/uqm/outfit.c src/uqm/outfit.c
--- src.mm/uqm/outfit.c	2017-11-28 11:08:49 -0600
+++ src/uqm/outfit.c	2017-11-28 11:09:35 -0600
@@ -34,6 +34,8 @@
 		// for xxx_DISASTER
 #include "libs/graphics/gfx_common.h"
 
+// How manyeth .png in the module.ani file is the first lander shield.
+#define SHIELD_LOCATION_IN_MODULE_ANI (RES_CASE(5,9,9))
 
 enum
 {
@@ -55,11 +57,11 @@ DrawModuleStrings (MENU_STATE *pMS, BYTE
 	OldContext = SetContext (StatusContext);
 	GetContextClipRect (&r);
 	s.origin.x = RADAR_X - r.corner.x;
-	s.origin.y = RADAR_Y - r.corner.y;
+	s.origin.y = RADAR_Y - r.corner.y - 19 * RESOLUTION_FACTOR; // JMS_GFX;
 	r.corner.x = s.origin.x - 1;
 	r.corner.y = s.origin.y - 11;
 	r.extent.width = RADAR_WIDTH + 2;
-	r.extent.height = 11;
+	r.extent.height = 11 + 20 * RESOLUTION_FACTOR; // JMS_GFX;
 	BatchGraphics ();
 	SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
@@ -67,6 +69,7 @@ DrawModuleStrings (MENU_STATE *pMS, BYTE
 	if (NewModule >= EMPTY_SLOT)
 	{
 		r.corner = s.origin;
+		r.corner.y += 19 * RESOLUTION_FACTOR; // JMS_GFX
 		r.extent.width = RADAR_WIDTH;
 		r.extent.height = RADAR_HEIGHT;
 		SetContextForeGroundColor (
@@ -80,16 +83,25 @@ DrawModuleStrings (MENU_STATE *pMS, BYTE
 
 		s.frame = SetAbsFrameIndex (pMS->CurFrame, NewModule);
 		DrawStamp (&s);
-		t.baseline.x = s.origin.x + RADAR_WIDTH - 2;
-		t.baseline.y = s.origin.y + RADAR_HEIGHT - 2;
+		t.baseline.x = s.origin.x + RADAR_WIDTH - RES_STAT_SCALE(2) - RESOLUTION_FACTOR;
+		t.baseline.y = s.origin.y + RADAR_HEIGHT - RES_STAT_SCALE(2) + 14 * RESOLUTION_FACTOR; // JMS_GFX;
 		t.align = ALIGN_RIGHT;
 		t.CharCount = (COUNT)~0;
 		t.pStr = buf;
 		sprintf (buf, "%u",
 				GLOBAL (ModuleCost[NewModule]) * MODULE_COST_SCALE);
+
+		if ((GLOBAL_SIS (ResUnits)) > (DWORD)((GLOBAL (ModuleCost[NewModule]) * MODULE_COST_SCALE))) {
+			sprintf (buf, "%u", GLOBAL (ModuleCost[NewModule]) * MODULE_COST_SCALE);
+			SetContextForeGroundColor (
+					BUILD_COLOR (MAKE_RGB15 (0x00, 0x1F, 0x00), 0x02));
+		} else {
+			sprintf (buf, "(%u)", GLOBAL (ModuleCost[NewModule]) * MODULE_COST_SCALE);
+			SetContextForeGroundColor (
+					BUILD_COLOR (MAKE_RGB15 (0x1F, 0x00, 0x00), 0x02));
+		}
+
 		SetContextFont (TinyFont);
-		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x00, 0x1F, 0x00), 0x02));
 		font_DrawText (&t);
 	}
 	UnbatchGraphics ();
@@ -113,7 +125,7 @@ RedistributeFuel (void)
 		// If we're less than the fuel level, draw fuel.
 		if (GLOBAL_SIS (FuelOnBoard) < FuelVolume)
 		{
-			r.extent.width = 3;
+			r.extent.width = (3 << RESOLUTION_FACTOR) + RES_CASE(0,2,6); // JMS_GFX
 			DrawPoint (&r.corner);
 			r.corner.x += r.extent.width + 1;
 			DrawPoint (&r.corner);
@@ -123,7 +135,7 @@ RedistributeFuel (void)
 		}
 		else // Otherwise, draw an empty bar.
 		{
-			r.extent.width = 5;
+			r.extent.width = 5 << RESOLUTION_FACTOR; // JMS_GFX
 			SetContextForeGroundColor (
 					BUILD_COLOR (MAKE_RGB15 (0x0B, 0x00, 0x00), 0x2E));
 		}
@@ -135,9 +147,9 @@ RedistributeFuel (void)
 	GLOBAL_SIS (FuelOnBoard) = FuelVolume;
 }
 
-#define LANDER_X 24
-#define LANDER_Y 67
-#define LANDER_WIDTH 15
+#define LANDER_X ((24 << RESOLUTION_FACTOR) + RES_CASE(0,2,0)) // JMS_GFX
+#define LANDER_Y (67 << RESOLUTION_FACTOR) // JMS_GFX
+#define LANDER_WIDTH ((15 << RESOLUTION_FACTOR) - RES_CASE(0,2,0)) // JMS_GFX
 
 static void
 DisplayLanders (MENU_STATE *pMS)
@@ -148,7 +160,8 @@ DisplayLanders (MENU_STATE *pMS)
 	if (GET_GAME_STATE (CHMMR_BOMB_STATE) == 3)
 	{
 		s.origin.x = s.origin.y = 0;
-		s.frame = DecFrameIndex (s.frame);
+		s.frame = SetAbsFrameIndex (pMS->ModuleFrame,
+			GetFrameCount (pMS->ModuleFrame) - SHIELD_LOCATION_IN_MODULE_ANI + 4);
 		DrawStamp (&s);
 	}
 	else
@@ -485,6 +498,12 @@ DoInstallModule (MENU_STATE *pMS)
 				else
 					w = SHIP_PIECE_OFFSET;
 
+				// JMS_GFX
+				if (NewState != PLANET_LANDER && NewState != FUSION_THRUSTER 
+					&& NewState != TURNING_JETS && NewState != EMPTY_SLOT + 0
+					 && NewState != EMPTY_SLOT + 1 && NewState != EMPTY_SLOT + 3)
+					w += RES_CASE(0,1,1);
+
 				w *= (NewItem - pMS->delta_item);
 				pMS->flash_rect0.corner.x += w;
 				pMS->delta_item = NewItem;
@@ -498,35 +517,35 @@ InitFlash:
 				{
 					case PLANET_LANDER:
 					case EMPTY_SLOT + 3:
-						pMS->flash_rect0.corner.x = LANDER_X - 1;
-						pMS->flash_rect0.corner.y = LANDER_Y - 1;
-						pMS->flash_rect0.extent.width = 11 + 2;
-						pMS->flash_rect0.extent.height = 13 + 2;
+						pMS->flash_rect0.corner.x = LANDER_X - 1 + RES_CASE(0,50,114); // JMS_GFX
+						pMS->flash_rect0.corner.y = LANDER_Y - 1 + RES_CASE(0,24,65); // JMS_GFX
+						pMS->flash_rect0.extent.width = (11 + 2) << RESOLUTION_FACTOR; // JMS_GFX
+						pMS->flash_rect0.extent.height = (13 + 2) << RESOLUTION_FACTOR; // JMS_GFX;
 
 						w = LANDER_WIDTH;
 						break;
 					case FUSION_THRUSTER:
 					case EMPTY_SLOT + 0:
-						pMS->flash_rect0.corner.x = DRIVE_TOP_X - 1;
-						pMS->flash_rect0.corner.y = DRIVE_TOP_Y - 1;
-						pMS->flash_rect0.extent.width = 8;
-						pMS->flash_rect0.extent.height = 6;
+						pMS->flash_rect0.corner.x = DRIVE_TOP_X - 1 - RES_CASE(0,4,5);
+						pMS->flash_rect0.corner.y = DRIVE_TOP_Y - 1 + RES_CASE(0,69,146);
+						pMS->flash_rect0.extent.width = 8 << RESOLUTION_FACTOR; // JMS_GFX;
+						pMS->flash_rect0.extent.height = (6 << RESOLUTION_FACTOR) - RES_CASE(0,0,2); // JMS_GFX;
 
 						break;
 					case TURNING_JETS:
 					case EMPTY_SLOT + 1:
-						pMS->flash_rect0.corner.x = JET_TOP_X - 1;
-						pMS->flash_rect0.corner.y = JET_TOP_Y - 1;
-						pMS->flash_rect0.extent.width = 9;
-						pMS->flash_rect0.extent.height = 10;
+						pMS->flash_rect0.corner.x = JET_TOP_X - 1 - RES_CASE(0,3,3);
+						pMS->flash_rect0.corner.y = JET_TOP_Y - 1 + RES_CASE(0,90,185);
+						pMS->flash_rect0.extent.width = 9 << RESOLUTION_FACTOR; // JMS_GFX;
+						pMS->flash_rect0.extent.height = (10 << RESOLUTION_FACTOR) + RES_CASE(0,0,4); // JMS_GFX;
 
 						break;
 					default:
-						pMS->flash_rect0.corner.x = MODULE_TOP_X - 1;
+						pMS->flash_rect0.corner.x = MODULE_TOP_X - 1 + RES_CASE(0,0,2);
 						pMS->flash_rect0.corner.y = MODULE_TOP_Y - 1;
-						pMS->flash_rect0.extent.width = SHIP_PIECE_OFFSET + 2;
-						pMS->flash_rect0.extent.height = 34;
-
+						pMS->flash_rect0.extent.width = SHIP_PIECE_OFFSET + 2 - RES_CASE(0,1,1);
+						pMS->flash_rect0.extent.height = (34 << RESOLUTION_FACTOR) + RES_CASE(0,0,9); // JMS_GFX;
+						w += RES_CASE(0,1,1);
 						break;
 				}
 
@@ -685,7 +704,7 @@ DoOutfit (MENU_STATE *pMS)
 				ShieldFlags = GET_GAME_STATE (LANDER_SHIELDS);
 
 				s.frame = SetAbsFrameIndex (pMS->ModuleFrame,
-						GetFrameCount (pMS->ModuleFrame) - 5);
+						GetFrameCount (pMS->ModuleFrame) - SHIELD_LOCATION_IN_MODULE_ANI);
 				if (ShieldFlags & (1 << EARTHQUAKE_DISASTER))
 					DrawStamp (&s);
 				s.frame = IncFrameIndex (s.frame);
diff -ruNp src.mm/uqm/pickship.c src/uqm/pickship.c
--- src.mm/uqm/pickship.c	2017-11-28 11:08:49 -0600
+++ src/uqm/pickship.c	2017-11-28 11:09:35 -0600
@@ -33,17 +33,16 @@
 #include "sounds.h"
 #include "libs/mathlib.h"
 
-
 #define NUM_PICK_SHIP_ROWS 2
 #define NUM_PICK_SHIP_COLUMNS 6
 
-#define ICON_WIDTH 16
-#define ICON_HEIGHT 16
+#define ICON_WIDTH (16 << RESOLUTION_FACTOR) // JMS_GFX
+#define ICON_HEIGHT (16 << RESOLUTION_FACTOR) // JMS_GFX
 
-#define FLAGSHIP_X_OFFS 65
-#define FLAGSHIP_Y_OFFS 4
-#define FLAGSHIP_WIDTH 22
-#define FLAGSHIP_HEIGHT 48
+#define FLAGSHIP_X_OFFS (65 << RESOLUTION_FACTOR) // JMS_GFX
+#define FLAGSHIP_Y_OFFS (4 << RESOLUTION_FACTOR) // JMS_GFX
+#define FLAGSHIP_WIDTH (22 << RESOLUTION_FACTOR) // JMS_GFX
+#define FLAGSHIP_HEIGHT (48 << RESOLUTION_FACTOR) // JMS_GFX
 
 static BOOLEAN
 DoPickBattleShip (MENU_STATE *pMS)
@@ -129,15 +128,15 @@ ChangeSelection:
 			else
 			{
 				new_col = pMS->first_item.x;
-				pMS->flash_rect0.corner.x = 5 + pMS->flash_rect1.corner.x - 2
-						+ ((ICON_WIDTH + 4) * new_col);
+				pMS->flash_rect0.corner.x = (5 << RESOLUTION_FACTOR) + pMS->flash_rect1.corner.x - 2
+						+ ((ICON_WIDTH + (4 << RESOLUTION_FACTOR)) * new_col); // JMS_GFX
 				if (new_col > (NUM_PICK_SHIP_COLUMNS >> 1))
 				{
 					--new_col;
 					pMS->flash_rect0.corner.x += FLAGSHIP_WIDTH - ICON_WIDTH;
 				}
-				pMS->flash_rect0.corner.y = 16 + pMS->flash_rect1.corner.y - 2
-						+ ((ICON_HEIGHT + 4) * pMS->first_item.y);
+				pMS->flash_rect0.corner.y = (16 << RESOLUTION_FACTOR) + pMS->flash_rect1.corner.y - 2
+					+ ((ICON_HEIGHT + (4 << RESOLUTION_FACTOR)) * pMS->first_item.y); // JMS_GFX
 				pMS->flash_rect0.extent.width = ICON_WIDTH + 4;
 				pMS->flash_rect0.extent.height = ICON_HEIGHT + 4;
 
@@ -167,10 +166,10 @@ ChangeSelection:
 			pMS->CurFrame = (FRAME)hBattleShip;
 
 			SetContextForeGroundColor (BLACK_COLOR);
-			r.corner.x = pMS->flash_rect1.corner.x + 6;
-			r.corner.y = pMS->flash_rect1.corner.y + 5;
-			r.extent.width = ((ICON_WIDTH + 4) * 3) - 4;
-			r.extent.height = 7;
+			r.corner.x = pMS->flash_rect1.corner.x + (6 << RESOLUTION_FACTOR) - 2*RESOLUTION_FACTOR; // JMS_GFX
+			r.corner.y = pMS->flash_rect1.corner.y + (5 << RESOLUTION_FACTOR) - 2*RESOLUTION_FACTOR; // JMS_GFX
+			r.extent.width = ((ICON_WIDTH + (4 << RESOLUTION_FACTOR)) * 3) - (4 << RESOLUTION_FACTOR) + 2*RESOLUTION_FACTOR;  // JMS_GFX
+			r.extent.height = 7 << RESOLUTION_FACTOR; // JMS_GFX
 			DrawFilledRectangle (&r);
 
 			if (hBattleShip == 0)
@@ -184,7 +183,7 @@ ChangeSelection:
 				SetContextFont (TinyFont);
 
 				t.baseline.x = r.corner.x + (r.extent.width >> 1);
-				t.baseline.y = r.corner.y + (r.extent.height - 1);
+				t.baseline.y = r.corner.y + (r.extent.height - (1 << RESOLUTION_FACTOR)) - 2*RESOLUTION_FACTOR; // JMS_GFX
 				t.align = ALIGN_CENTER;
 
 				StarShipPtr = LockStarShip (&race_q[0], hBattleShip);
@@ -215,9 +214,10 @@ ChangeSelection:
 				SetContextForeGroundColor (BLACK_COLOR);
 			}
 
-			r.corner.x += (ICON_WIDTH + 4)
-					* ((NUM_PICK_SHIP_COLUMNS >> 1) + 1)
-					+ FLAGSHIP_WIDTH - ICON_WIDTH;
+			r.extent.width -= 2*RESOLUTION_FACTOR; // JMS_GFX
+			r.corner.x += (ICON_WIDTH + (4 << RESOLUTION_FACTOR))
+				* ((NUM_PICK_SHIP_COLUMNS >> 1) + 1)
+					+ FLAGSHIP_WIDTH - ICON_WIDTH; // JMS_GFX
 			DrawFilledRectangle (&r);
 
 			if (crew_level)
@@ -388,7 +388,7 @@ GetEncounterStarShip (STARSHIP *LastStar
 void
 DrawArmadaPickShip (BOOLEAN draw_salvage_frame, RECT *pPickRect)
 {
-#define PICK_NAME_HEIGHT 6
+#define PICK_NAME_HEIGHT (6 << RESOLUTION_FACTOR); // JMS_GFX
 	//COUNT i;
 	HSTARSHIP hBattleShip, hNextShip;
 	STARSHIP *StarShipPtr;
@@ -433,7 +433,7 @@ DrawArmadaPickShip (BOOLEAN draw_salvage
 	DrawStamp (&s);
 
 	t.baseline.x = pick_r.corner.x + (pick_r.extent.width >> 1);
-	t.baseline.y = pick_r.corner.y + pick_r.extent.height - 5;
+	t.baseline.y = pick_r.corner.y + pick_r.extent.height - (5 << RESOLUTION_FACTOR) - 2 * RESOLUTION_FACTOR; // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.pStr = GLOBAL_SIS (ShipName);
 	t.CharCount = (COUNT)~0;
@@ -456,14 +456,14 @@ DrawArmadaPickShip (BOOLEAN draw_salvage
 			ship_index = StarShipPtr->index;
 
 			s.origin.x = pick_r.corner.x
-					+ (5 + ((ICON_WIDTH + 4)
-					* (ship_index % NUM_PICK_SHIP_COLUMNS)));
+					+ ((5 << RESOLUTION_FACTOR) + ((ICON_WIDTH + (4 << RESOLUTION_FACTOR))
+				       * (ship_index % NUM_PICK_SHIP_COLUMNS))); // JMS_GFX
 			if ((ship_index % NUM_PICK_SHIP_COLUMNS) >=
 					(NUM_PICK_SHIP_COLUMNS >> 1))
-				s.origin.x += FLAGSHIP_WIDTH + 4;
+				s.origin.x += FLAGSHIP_WIDTH + (4 << RESOLUTION_FACTOR); // JMS_GFX
 			s.origin.y = pick_r.corner.y
-					+ (16 + ((ICON_HEIGHT + 4)
-					* (ship_index / NUM_PICK_SHIP_COLUMNS)));
+					+ ((16 << RESOLUTION_FACTOR) + ((ICON_HEIGHT + (4 << RESOLUTION_FACTOR))
+					* (ship_index / NUM_PICK_SHIP_COLUMNS))); // JMS_GFX
 			s.frame = StarShipPtr->icons;
 			r.corner = s.origin;
 			SetContextForeGroundColor (BLACK_COLOR);
@@ -474,7 +474,12 @@ DrawArmadaPickShip (BOOLEAN draw_salvage
 				if (StarShipPtr->SpeciesID == NO_ID)
 				{
 					/* Dead ship - mark with an X. */
-					s.origin.x -= 1;
+					s.origin.x -= (1 << RESOLUTION_FACTOR); // JMS_GFX
+					
+					// JMS_GFX
+					if (RESOLUTION_FACTOR > 0)
+						s.origin.y -= (1 << RESOLUTION_FACTOR);
+
 					s.frame = SetAbsFrameIndex (StatusFrame, 3);
 					DrawStamp (&s);
 				}
diff -ruNp src.mm/uqm/plandata.c src/uqm/plandata.c
--- src.mm/uqm/plandata.c	2017-11-28 11:08:49 -0600
+++ src/uqm/plandata.c	2017-11-28 11:09:35 -0600
@@ -18,6 +18,7 @@
 
 #include "gendef.h"
 #include "resinst.h"
+#include "hyper.h" // JMS: For ARILOU_HOME_X and Y
 #include "planets/planets.h"
 #include "planets/elemdata.h"
 
@@ -537,37 +538,37 @@ STAR_DESC starmap_array[] =
 	// QuasiSpace locations
 #define VORTEX_SCALE 20
 	{{(-12* VORTEX_SCALE) + 5000, (-21 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 133},
 	{{( 1 * VORTEX_SCALE) + 5000, (-20 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 134},
 	{{(-16 * VORTEX_SCALE) + 5000, (-18 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 135},
 	{{( 8 * VORTEX_SCALE) + 5000, (-17 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 136},
 	{{( 3 * VORTEX_SCALE) + 5000, (-13 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 137},
 	{{(-21 * VORTEX_SCALE) + 5000, (-4 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 138},
 	{{(-4 * VORTEX_SCALE) + 5000, (-4 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 139},
 	{{(-12 * VORTEX_SCALE) + 5000, (-2 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 140},
 	{{(-26 * VORTEX_SCALE) + 5000, (2 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 141},
 	{{(-17 * VORTEX_SCALE) + 5000, (7 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 142},
 	{{(10 * VORTEX_SCALE) + 5000, (7 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 143},
 	{{(15 * VORTEX_SCALE) + 5000, (14 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 144},
 	{{(22 * VORTEX_SCALE) + 5000, (16 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 145},
 	{{(-6 * VORTEX_SCALE) + 5000, (19 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 146},
 	{{(10 * VORTEX_SCALE) + 5000, (20 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 147},
 
-	{{6134, 5900}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 0, 132},
+	{{ARILOU_HOME_X, ARILOU_HOME_Y}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 0, 148},
 
 	{{MAX_X_UNIVERSE << 1, MAX_Y_UNIVERSE << 1}, 0, 0, 0, 0},
 };
diff -ruNp src.mm/uqm/planets/cargo.c src/uqm/planets/cargo.c
--- src.mm/uqm/planets/cargo.c	2017-11-28 11:08:49 -0600
+++ src/uqm/planets/cargo.c	2017-11-28 11:09:35 -0600
@@ -30,20 +30,20 @@
 		// for GetFrameBounds()
 
 
-#define ELEMENT_ORG_Y      35
+#define ELEMENT_ORG_Y      RES_STAT_SCALE(35) // JMS_GFX
 #define FREE_ORG_Y         (ELEMENT_ORG_Y + (NUM_ELEMENT_CATEGORIES \
 							* ELEMENT_SPACING_Y))
-#define BIO_ORG_Y          119
-#define ELEMENT_SPACING_Y  9
+#define BIO_ORG_Y          RES_STAT_SCALE(119) // JMS_GFX
+#define ELEMENT_SPACING_Y  RES_STAT_SCALE(9) // JMS_GFX
 
-#define ELEMENT_COL_0      7
-#define ELEMENT_COL_1      32
-#define ELEMENT_COL_2      58
+#define ELEMENT_COL_0      RES_STAT_SCALE(7) // JMS_GFX
+#define ELEMENT_COL_1      RES_STAT_SCALE(32) // JMS_GFX
+#define ELEMENT_COL_2      RES_STAT_SCALE(58) // JMS_GFX
 
-#define ELEMENT_SEL_ORG_X  (ELEMENT_COL_0 + 7 + 5)
-#define ELEMENT_SEL_WIDTH  (ELEMENT_COL_2 - ELEMENT_SEL_ORG_X + 1)
+#define ELEMENT_SEL_ORG_X  (ELEMENT_COL_0 + RES_STAT_SCALE(7 + 5)) // JMS_GFX
+#define ELEMENT_SEL_WIDTH  (ELEMENT_COL_2 - ELEMENT_SEL_ORG_X + RES_STAT_SCALE(1)) // JMS_GFX
 
-#define TEXT_BASELINE      6
+#define TEXT_BASELINE      RES_STAT_SCALE(6) // JMS_GFX
 
 
 void
@@ -57,19 +57,19 @@ ShowRemainingCapacity (void)
 	OldContext = SetContext (StatusContext);
 	SetContextFont (TinyFont);
 
-	r.corner.x = 40;
+	r.corner.x = RES_STAT_SCALE(40); // JMS_GFX
 	r.corner.y = FREE_ORG_Y;
 
 	snprintf (buf, sizeof buf, "%u",
 			GetStorageBayCapacity () - GLOBAL_SIS (TotalElementMass));
-	t.baseline.x = ELEMENT_COL_2 + 1;
+	t.baseline.x = ELEMENT_COL_2 + RES_STAT_SCALE(1); // JMS_GFX
 	t.baseline.y = r.corner.y + TEXT_BASELINE;
 	t.align = ALIGN_RIGHT;
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 
-	r.extent.width = t.baseline.x - r.corner.x + 1;
-	r.extent.height = ELEMENT_SPACING_Y - 2;
+	r.extent.width = t.baseline.x - r.corner.x + RES_STAT_SCALE(1); // JMS_GFX
+	r.extent.height = ELEMENT_SPACING_Y - RES_STAT_SCALE(2); // JMS_GFX
 
 	BatchGraphics ();
 	// erase previous free amount
@@ -92,7 +92,7 @@ DrawElementAmount (COUNT element, bool s
 
 	r.corner.x = ELEMENT_SEL_ORG_X;
 	r.extent.width = ELEMENT_SEL_WIDTH;
-	r.extent.height = ELEMENT_SPACING_Y - 2;
+	r.extent.height = ELEMENT_SPACING_Y - RES_STAT_SCALE(2); // JMS_GFX
 
 	if (element == NUM_ELEMENT_CATEGORIES)
 		r.corner.y = BIO_ORG_Y;
@@ -142,20 +142,20 @@ DrawCargoDisplay (void)
 	COORD cy;
 	COUNT i;
 
-	r.corner.x = 2;
-	r.extent.width = FIELD_WIDTH + 1;
-	r.corner.y = 20;
+	r.corner.x = RES_CASE(2,2,3); // JMS_GFX
+	r.corner.y = RES_STAT_SCALE(20) - RES_CASE(0,1,0); // JMS_GFX
+	r.extent.width = FIELD_WIDTH + 1; // JMS_GFX
 	// XXX: Shouldn't the height be 1 less? This draws the bottom border
 	//   1 pixel too low. Or if not, why do we need another box anyway?
-	r.extent.height = 129 - r.corner.y;
+	r.extent.height = RES_STAT_SCALE(129) - r.corner.y + RES_CASE(0,6,19); // JMS_GFX
 	DrawStarConBox (&r, 1,
 			SHADOWBOX_MEDIUM_COLOR, SHADOWBOX_DARK_COLOR,
 			TRUE, CARGO_BACK_COLOR);
 
 	// draw the "CARGO" title
 	SetContextFont (StarConFont);
-	t.baseline.x = (STATUS_WIDTH >> 1) - 1;
-	t.baseline.y = 27;
+	t.baseline.x = (STATUS_WIDTH >> 1) - RES_STAT_SCALE(1); // JMS_GFX
+	t.baseline.y = RES_STAT_SCALE(27); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.pStr = GAME_STRING (CARGO_STRING_BASE);
 	t.CharCount = (COUNT)~0;
@@ -166,15 +166,20 @@ DrawCargoDisplay (void)
 
 	s.frame = SetAbsFrameIndex (MiscDataFrame,
 			(NUM_SCANDOT_TRANSITIONS * 2) + 3);
+	if (RESOLUTION_FACTOR == 2)
+		s.frame = SetRelFrameIndex (s.frame, -1); // JMS_GFX
+
 	r.corner.x = ELEMENT_COL_0;
 	r.extent = GetFrameBounds (s.frame);
-	s.origin.x = r.corner.x + (r.extent.width >> 1);
+	r.extent.width -= RES_CASE(0,5,7); // JMS_GFX
+	r.extent.height -= RES_CASE(0,5,8); // JMS_GFX
+	s.origin.x = r.corner.x + (r.extent.width >> 1) - RES_CASE(0,1,4); // JMS_GFX
 
 	cy = ELEMENT_ORG_Y;
 
 	// print element column headings
 	t.align = ALIGN_RIGHT;
-	t.baseline.y = cy - 1;
+	t.baseline.y = cy - RES_STAT_SCALE(1); // JMS_GFX
 	t.CharCount = (COUNT)~0;
 
 	SetContextForeGroundColor (CARGO_WORTH_COLOR);
@@ -195,7 +200,7 @@ DrawCargoDisplay (void)
 		DrawFilledRectangle (&r);
 
 		// draw an element icon
-		s.origin.y = r.corner.y + (r.extent.height >> 1);
+		s.origin.y = r.corner.y + (r.extent.height >> 1) - RES_CASE(0,1,5);
 		DrawStamp (&s);
 		s.frame = SetRelFrameIndex (s.frame, 5);
 
@@ -216,15 +221,15 @@ DrawCargoDisplay (void)
 	DrawElementAmount (NUM_ELEMENT_CATEGORIES, false);
 
 	// draw the line over the Bio amount
-	r.corner.x = 4;
-	r.corner.y = BIO_ORG_Y - 2;
-	r.extent.width = FIELD_WIDTH - 3;
+	r.corner.x = RES_STAT_SCALE(4); // JMS_GFX
+	r.corner.y = BIO_ORG_Y - RES_STAT_SCALE(2); // JMS_GFX
+	r.extent.width = FIELD_WIDTH - RES_CASE(3,10,17); // JMS_GFX
 	r.extent.height = 1;
 	SetContextForeGroundColor (CARGO_SELECTED_BACK_COLOR);
 	DrawFilledRectangle (&r);
 
 	// print "Free"
-	t.baseline.x = 5;
+	t.baseline.x = RES_STAT_SCALE(5); // JMS_GFX
 	t.baseline.y = FREE_ORG_Y + TEXT_BASELINE;
 	t.align = ALIGN_LEFT;
 	t.pStr = GAME_STRING (CARGO_STRING_BASE + 1);
diff -ruNp src.mm/uqm/planets/devices.c src/uqm/planets/devices.c
--- src.mm/uqm/planets/devices.c	2017-11-28 11:08:49 -0600
+++ src/uqm/planets/devices.c	2017-11-28 11:09:35 -0600
@@ -39,6 +39,8 @@
 		// for SaveSolarSysLocation() and tests
 #include "libs/strlib.h"
 #include "../../options.h"
+#include "libs/graphics/gfx_common.h"
+                // for scaling down devices in 4x
 
 
 // If DEBUG_DEVICES is defined, the device list shown in the game will
@@ -46,24 +48,24 @@
 // devices the player actually possesses.
 //#define DEBUG_DEVICES
 
-#define DEVICE_ICON_WIDTH  16
-#define DEVICE_ICON_HEIGHT 16
+#define DEVICE_ICON_WIDTH  RES_STAT_SCALE(16) // JMS_GFX
+#define DEVICE_ICON_HEIGHT RES_STAT_SCALE(16) // JMS_GFX
 
-#define DEVICE_ORG_Y       33
-#define DEVICE_SPACING_Y   (DEVICE_ICON_HEIGHT + 2)
+#define DEVICE_ORG_Y       RES_STAT_SCALE(33) // JMS_GFX
+#define DEVICE_SPACING_Y   (DEVICE_ICON_HEIGHT + RES_STAT_SCALE(2)) // JMS_GFX
 
-#define DEVICE_COL_0       4
-#define DEVICE_COL_1       40
+#define DEVICE_COL_0       RES_STAT_SCALE(4) // JMS_GFX
+#define DEVICE_COL_1       RES_STAT_SCALE(40) // JMS_GFX
 
 #define DEVICE_SEL_ORG_X  (DEVICE_COL_0 + DEVICE_ICON_WIDTH)
-#define DEVICE_SEL_WIDTH  (FIELD_WIDTH + 1 - DEVICE_SEL_ORG_X + 1)
+#define DEVICE_SEL_WIDTH  (FIELD_WIDTH + RES_CASE(2,0,6) - DEVICE_SEL_ORG_X) // JMS_GFX
 
-#define ICON_OFS_Y         1
-#define NAME_OFS_Y         2
-#define TEXT_BASELINE      6
-#define TEXT_SPACING_Y     7
+#define ICON_OFS_Y         RES_CASE(1,4,11) // JMS_GFX
+#define NAME_OFS_Y         RES_STAT_SCALE(2) // JMS_GFX
+#define TEXT_BASELINE      RES_STAT_SCALE(6) // JMS_GFX
+#define TEXT_SPACING_Y     RES_STAT_SCALE(7) // JMS_GFX
 
-#define MAX_VIS_DEVICES    ((129 - DEVICE_ORG_Y) / DEVICE_SPACING_Y)
+#define MAX_VIS_DEVICES    ((RES_STAT_SCALE(129) - DEVICE_ORG_Y) / DEVICE_SPACING_Y) // JMS_GFX
 
 
 typedef enum
@@ -90,8 +92,8 @@ EraseDevicesBackground (void)
 {
 	RECT r;
 
-	r.corner.x = 2 + 1;
-	r.extent.width = FIELD_WIDTH + 1 - 2;
+	r.corner.x = RES_STAT_SCALE(2 + 1); // JMS_GFX
+	r.extent.width = FIELD_WIDTH - RES_STAT_SCALE(1); // JMS_GFX
 	r.corner.y = DEVICE_ORG_Y;
 	r.extent.height = MAX_VIS_DEVICES * DEVICE_SPACING_Y;
 	SetContextForeGroundColor (DEVICES_BACK_COLOR);
@@ -109,8 +111,8 @@ DrawDevice (COUNT device, COUNT pos, boo
 	t.baseline.x = DEVICE_COL_1;
 
 	r.extent.width = DEVICE_SEL_WIDTH;
-	r.extent.height = TEXT_SPACING_Y * 2;
-	r.corner.x = DEVICE_SEL_ORG_X;
+	r.extent.height = (TEXT_SPACING_Y * 2) + RES_CASE(0,4,0);
+	r.corner.x = DEVICE_SEL_ORG_X - RES_CASE(0,0,8);
 
 	// draw line background
 	r.corner.y = DEVICE_ORG_Y + pos * DEVICE_SPACING_Y + NAME_OFS_Y;
@@ -142,20 +144,20 @@ DrawDevicesDisplay (DEVICES_STATE *devSt
 	COORD cy;
 	COUNT i;
 
-	r.corner.x = 2;
-	r.corner.y = 20;
-	r.extent.width = FIELD_WIDTH + 1;
+	r.corner.x = RES_CASE(2,2,3); // JMS_GFX
+	r.corner.y = RES_STAT_SCALE(20) - RES_CASE(0,1,0); // JMS_GFX
+	r.extent.width = FIELD_WIDTH + 1; // JMS_GFX
 	// XXX: Shouldn't the height be 1 less? This draws the bottom border
 	//   1 pixel too low. Or if not, why do we need another box anyway?
-	r.extent.height = 129 - r.corner.y;
+	r.extent.height = RES_STAT_SCALE(129) - r.corner.y + RES_CASE(0,6,19); // JMS_GFX
 	DrawStarConBox (&r, 1,
 			SHADOWBOX_MEDIUM_COLOR, SHADOWBOX_DARK_COLOR,
 			TRUE, DEVICES_BACK_COLOR);
 
 	// print the "DEVICES" title
 	SetContextFont (StarConFont);
-	t.baseline.x = (STATUS_WIDTH >> 1) - 1;
-	t.baseline.y = r.corner.y + 7;
+	t.baseline.x = (STATUS_WIDTH >> 1) - RES_STAT_SCALE(1); // JMS_GFX
+	t.baseline.y = r.corner.y + RES_STAT_SCALE(7); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.pStr = GAME_STRING (DEVICE_STRING_BASE);
 	t.CharCount = (COUNT)~0;
@@ -177,7 +179,17 @@ DrawDevicesDisplay (DEVICES_STATE *devSt
 		s.origin.y = cy + ICON_OFS_Y;
 		s.frame = SetAbsFrameIndex (MiscDataFrame,
 				77 + devState->list[devIndex]);
-		DrawStamp (&s);
+		
+		if (RESOLUTION_FACTOR < 2) {
+			DrawStamp (&s);			
+		} else {
+			int oldMode, oldScale;
+			oldMode = SetGraphicScaleMode (TFB_SCALE_BILINEAR);
+			oldScale = SetGraphicScale ((int)(GSCALE_IDENTITY / 2));
+			DrawStamp (&s);
+			SetGraphicScale (oldScale);
+			SetGraphicScaleMode (oldMode);
+		}
 
 		DrawDevice (devState->list[devIndex], i, false);
 	}
diff -ruNp src.mm/uqm/planets/gentopo.c src/uqm/planets/gentopo.c
--- src.mm/uqm/planets/gentopo.c	2017-11-28 11:08:50 -0600
+++ src/uqm/planets/gentopo.c	2017-11-28 11:09:36 -0600
@@ -50,8 +50,14 @@ DeltaTopography (COUNT num_iterations, S
 		w1 = LOWORD (rand_val);
 		w2 = HIWORD (rand_val);
 
-		LineDDA0.x_top = (LOBYTE (w1) % MAP_WIDTH) * width / MAP_WIDTH;
-		LineDDA0.x_bot = (HIBYTE (w1) % MAP_WIDTH) * width / MAP_WIDTH;
+		LineDDA0.x_top = (LOBYTE (w1) % ORIGINAL_MAP_WIDTH) * width / ORIGINAL_MAP_WIDTH;
+		LineDDA0.x_bot = (HIBYTE (w1) % ORIGINAL_MAP_WIDTH) * width / ORIGINAL_MAP_WIDTH;
+		//LineDDA0.x_top = w1 % width; // JMS_GFX: Replaced previous lines with these: BYTE is too small for 640x480 sized maps.
+		//LineDDA0.x_bot = w2 % width; // Using w1 and w2 to get difference between top and bottom.
+		// BW: reinstate previous method and adapt it for higher res.
+		// Overusing w1 and w2 was hampering randomness.
+		// Now planets will look the same no matter what the res is.
+
 		LineDDA0.delta_x = (LineDDA0.x_bot - LineDDA0.x_top) << 1;
 		if (LineDDA0.delta_x >= 0)
 			LineDDA0.x_incr = 1;
diff -ruNp src.mm/uqm/planets/lander.c src/uqm/planets/lander.c
--- src.mm/uqm/planets/lander.c	2017-11-28 11:08:50 -0600
+++ src/uqm/planets/lander.c	2017-11-28 11:09:36 -0600
@@ -149,7 +149,7 @@ extern PRIM_LINKS DisplayLinks;
 #define ADD_AT_END (1 << 4)
 #define REPAIR_COUNT (0xf)
 
-#define LANDER_SPEED_DENOM 10
+#define LANDER_SPEED_DENOM (10) // JMS_GFX
 
 static BYTE lander_flags;
 static POINT curLanderLoc;
@@ -263,15 +263,16 @@ object_animation (ELEMENT *ElementPtr)
 			else if (ElementPtr->mass_points == EARTHQUAKE_DISASTER)
 			{
 				SIZE s;
+				SIZE frame_amount = 14; // JMS_GFX
 
-				if (frame_index >= 13)
+				if (frame_index >= (frame_amount-1))
 					s = 0;
 				else
-					s = (14 - frame_index) >> 1;
+					s = (frame_amount - frame_index) >> 1;
 				// XXX: Was 0x8000 the background flag on 3DO?
 				//SetPrimColor (pPrim, BUILD_COLOR (0x8000 | MAKE_RGB15 (0x1F, 0x1F, 0x1F), s));
 				SetPrimColor (pPrim, BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x1F), s));
-				if (frame_index == 13)
+				if (frame_index == (frame_amount - 1))
 					PlaySound (SetAbsSoundIndex (LanderSounds, EARTHQUAKE_DISASTER),
 							NotPositional (), NULL, GAME_SOUND_PRIORITY);
 			}
@@ -291,8 +292,8 @@ object_animation (ELEMENT *ElementPtr)
 					angle = FACING_TO_ANGLE (ElementPtr->facing);
 					LockElement (hLavaElement, &LavaElementPtr);
 					LavaElementPtr->next.location = ElementPtr->next.location;
-					LavaElementPtr->next.location.x += COSINE (angle, 4);
-					LavaElementPtr->next.location.y += SINE (angle, 4);
+					LavaElementPtr->next.location.x += COSINE (angle, 4 << RESOLUTION_FACTOR); // JMS_GFX
+					LavaElementPtr->next.location.y += SINE (angle, 4 << RESOLUTION_FACTOR); // JMS_GFX
 					if (LavaElementPtr->next.location.y < 0)
 						LavaElementPtr->next.location.y = 0;
 					else if (LavaElementPtr->next.location.y >= (MAP_HEIGHT << MAG_SHIFT))
@@ -412,6 +413,7 @@ object_animation (ELEMENT *ElementPtr)
 						speed = WORLD_TO_VELOCITY (2 * 1) * 9 / 10;
 						break;
 				}
+				speed = speed << RESOLUTION_FACTOR; // JMS_GFX
 
 				SetVelocityComponents (&ElementPtr->velocity,
 						COSINE (angle, speed), SINE (angle, speed));
@@ -470,8 +472,16 @@ DeltaLanderCrew (SIZE crew_delta, COUNT
 				NotPositional (), NULL, GAME_SOUND_PRIORITY);
 	}
 
-	s.origin.x = 11 + (6 * (crew_delta % NUM_CREW_COLS));
-	s.origin.y = 35 - (6 * (crew_delta / NUM_CREW_COLS));
+	if (RESOLUTION_FACTOR == 0) {
+		s.origin.x = ((11 + ((6 << RESOLUTION_FACTOR) * (crew_delta % NUM_CREW_COLS)))); // JMS_GFX
+		s.origin.y = (35 - (6 * (crew_delta / NUM_CREW_COLS))) << RESOLUTION_FACTOR; // JMS_GFX
+	} else if (RESOLUTION_FACTOR == 1) {
+		s.origin.x = ((23 + ((6 << RESOLUTION_FACTOR) * (crew_delta % NUM_CREW_COLS)))); // JMS_GFX
+		s.origin.y = 1 + ((35 - (6 * (crew_delta / NUM_CREW_COLS))) << RESOLUTION_FACTOR); // JMS_GFX
+	} else {
+		s.origin.x = 32 + ((9 * RESOLUTION_FACTOR) * (crew_delta % NUM_CREW_COLS)); // JMS_GFX
+		s.origin.y = (52 * RESOLUTION_FACTOR - (9 * RESOLUTION_FACTOR * (crew_delta / NUM_CREW_COLS))); // JMS_GFX
+	}
 
 	OldContext = SetContext (RadarContext);
 	DrawStamp (&s);
@@ -484,6 +494,8 @@ FillLanderHold (PLANETSIDE_DESC *pPSD, C
 	COUNT start_count, tmpholdint;
 	STAMP s;
 	CONTEXT OldContext;
+	SIZE  rounding_error_startcount = 0; // JMS_GFX
+	SIZE  rounding_error_numretrieved = 0; // JMS_GFX
 
 	PlaySound (SetAbsSoundIndex (LanderSounds, LANDER_PICKUP),
 			NotPositional (), NULL, GAME_SOUND_PRIORITY);
@@ -495,16 +507,15 @@ FillLanderHold (PLANETSIDE_DESC *pPSD, C
 		s.frame = SetAbsFrameIndex (LanderFrame[0], 41);
 
 		pPSD->BiologicalLevel += NumRetrieved;
-	}
-	else
-	{
+	} else {
 		start_count = pPSD->ElementLevel;
 		pPSD->ElementLevel += NumRetrieved;
+
+		rounding_error_startcount = (start_count % 2);
+		rounding_error_numretrieved = (pPSD->ElementLevel % 2);
+
 		if (GET_GAME_STATE (IMPROVED_LANDER_CARGO))
-		{
-			start_count >>= 1;
-			NumRetrieved = (pPSD->ElementLevel >> 1) - start_count;
-		}
+			NumRetrieved = (pPSD->ElementLevel >> 1) - (start_count >> 1);
 
 		s.frame = SetAbsFrameIndex (LanderFrame[0], 43);
 	}
@@ -515,12 +526,34 @@ FillLanderHold (PLANETSIDE_DESC *pPSD, C
 	start_count = start_count * MAX_HOLD_BARS / MAX_SCROUNGED;
 	NumRetrieved = (NumRetrieved * MAX_HOLD_BARS / MAX_SCROUNGED) + tmpholdint;
 
+	start_count *= RES_STAT_SCALE(1); // JMS_GFX
+	
+	if (scan == MINERAL_SCAN && GET_GAME_STATE (IMPROVED_LANDER_CARGO))
+	{
+		start_count >>= 1;
+		
+		// JMS_GFX
+		if (RESOLUTION_FACTOR == 1)
+			start_count += rounding_error_startcount;
+	}
+
 	s.origin.x = 0;
 	s.origin.y = -(int)start_count;
 	if (!(start_count & 1))
 		s.frame = IncFrameIndex (s.frame);
 
-	OldContext = SetContext (RadarContext);
+	OldContext = SetContext (RadarContext);	
+	
+	// JMS_GFX
+	if (scan == MINERAL_SCAN && GET_GAME_STATE (IMPROVED_LANDER_CARGO) && RESOLUTION_FACTOR > 0)
+	{
+		NumRetrieved *= RES_STAT_SCALE(1);
+		NumRetrieved >>= 1;
+		
+		if (RESOLUTION_FACTOR == 1)
+			NumRetrieved += rounding_error_numretrieved;
+	}
+
 	while (NumRetrieved--)
 	{
 		if (start_count++ & 1)
@@ -528,7 +561,7 @@ FillLanderHold (PLANETSIDE_DESC *pPSD, C
 		else
 			s.frame = DecFrameIndex (s.frame);
 		DrawStamp (&s);
-		--s.origin.y;
+		s.origin.y -= RES_STAT_SCALE(1); // JMS_GFX
 	}
 	SetContext (OldContext);
 }
@@ -732,8 +765,8 @@ shotCreature (ELEMENT *ElementPtr, BYTE
 				LanderControl->IntersectStamp.frame) -
 				ANGLE_TO_FACING (FULL_CIRCLE));
 		DeltaVelocityComponents (&ElementPtr->velocity,
-				COSINE (angle, WORLD_TO_VELOCITY (1)),
-				SINE (angle, WORLD_TO_VELOCITY (1)));
+				COSINE (angle, WORLD_TO_VELOCITY (1<<RESOLUTION_FACTOR)),
+				SINE (angle, WORLD_TO_VELOCITY (1<<RESOLUTION_FACTOR))); // JMS_GFX
 		ElementPtr->thrust_wait = 0;
 		ElementPtr->mass_points |= CREATURE_AWARE;
 	}
@@ -832,7 +865,11 @@ CheckObjectCollision (COUNT index)
 						{
 							case EARTHQUAKE_DISASTER:
 							case LAVASPOT_DISASTER:
-								if (TFB_Random () % 100 < 25)
+								if (scan == LAVASPOT_DISASTER 
+									&& RESOLUTION_FACTOR == 2 
+									&& TFB_Random () % 100 < 9)
+									DeltaLanderCrew (-1, scan);
+								else if (TFB_Random () % 100 < 25)
 									DeltaLanderCrew (-1, scan);
 								break;
 						}
@@ -1018,14 +1055,26 @@ AddLightning (void)
 
 		rand_val = TFB_Random ();
 		LightningElementPtr->life_span = 10 + (HIWORD (rand_val) % 10) + 1;
-		LightningElementPtr->next.location.x = (curLanderLoc.x
+
+		if (RESOLUTION_FACTOR == 0) {
+			LightningElementPtr->next.location.x = (curLanderLoc.x
 				+ ((MAP_WIDTH << MAG_SHIFT) - ((SURFACE_WIDTH >> 1) - 6))
 				+ (LOBYTE (rand_val) % (SURFACE_WIDTH - 12))
 				) % (MAP_WIDTH << MAG_SHIFT);
-		LightningElementPtr->next.location.y = (curLanderLoc.y
+			LightningElementPtr->next.location.y = (curLanderLoc.y
 				+ ((MAP_HEIGHT << MAG_SHIFT) - ((SURFACE_HEIGHT >> 1) - 6))
 				+ (HIBYTE (rand_val) % (SURFACE_HEIGHT - 12))
 				) % (MAP_HEIGHT << MAG_SHIFT);
+		} else {
+			LightningElementPtr->next.location.x = (curLanderLoc.x
+				+ ((MAP_WIDTH << MAG_SHIFT) - ((SURFACE_WIDTH >> 1) - 6))
+				+ (rand_val % (SURFACE_WIDTH - (12 << RESOLUTION_FACTOR)))
+				) % (MAP_WIDTH << MAG_SHIFT);
+			LightningElementPtr->next.location.y = (curLanderLoc.y
+				+ ((MAP_HEIGHT << MAG_SHIFT) - ((SURFACE_HEIGHT >> 1) - 6))
+				+ (rand_val % (SURFACE_HEIGHT - (12 << RESOLUTION_FACTOR)))
+				) % (MAP_HEIGHT << MAG_SHIFT);
+		}
 
 		LightningElementPtr->cycle = LightningElementPtr->life_span;
 		
@@ -1076,7 +1125,7 @@ AddGroundDisaster (COUNT which_disaster)
 
 		if (which_disaster == EARTHQUAKE_DISASTER)
 		{
-			SetPrimType (pPrim, STAMPFILL_PRIM);
+			SetPrimType (pPrim, STAMP_PRIM); // JMS: was STAMPFILL_PRIM (this rendered it totally white).
 			pPrim->Object.Stamp.frame = LanderFrame[1];
 			GroundDisasterElementPtr->turn_wait = MAKE_BYTE (2, 2);
 		}
@@ -1332,15 +1381,11 @@ ScrollPlanetSide (SIZE dx, SIZE dy, int
 			pPSD->MineralText[0].baseline.x -= dx;
 			pPSD->MineralText[0].baseline.y -= dy;
 			font_DrawText (&pPSD->MineralText[0]);
-			pPSD->MineralText[1].baseline.x =
-					pPSD->MineralText[0].baseline.x;
-			pPSD->MineralText[1].baseline.y =
-					pPSD->MineralText[0].baseline.y + 7;
+			pPSD->MineralText[1].baseline.x = pPSD->MineralText[0].baseline.x;
+			pPSD->MineralText[1].baseline.y = pPSD->MineralText[0].baseline.y + (7 << RESOLUTION_FACTOR); // JMS_GFX
 			font_DrawText (&pPSD->MineralText[1]);
-			pPSD->MineralText[2].baseline.x =
-					pPSD->MineralText[1].baseline.x;
-			pPSD->MineralText[2].baseline.y =
-					pPSD->MineralText[1].baseline.y + 7;
+			pPSD->MineralText[2].baseline.x = pPSD->MineralText[1].baseline.x;
+			pPSD->MineralText[2].baseline.y = pPSD->MineralText[1].baseline.y + (7 << RESOLUTION_FACTOR); // JMS_GFX
 			font_DrawText (&pPSD->MineralText[2]);
 		}
 	}
@@ -1370,7 +1415,7 @@ animationInterframe (TimeCount *TimeIn,
 }
 
 static void
-AnimateLaunch (FRAME farray)
+AnimateLaunch (FRAME farray, BOOLEAN landing)
 {
 	RECT r;
 	STAMP s;
@@ -1392,7 +1437,7 @@ AnimateLaunch (FRAME farray)
 		NextTime = GetTimeCounter () + (ONE_SECOND / 22);
 
 		BatchGraphics ();
-		RepairBackRect (&r);
+		RepairBackRect (&r, TRUE);
 #ifdef SPIN_ON_LAUNCH
 		RotatePlanetSphere (FALSE);
 #else
@@ -1407,7 +1452,9 @@ AnimateLaunch (FRAME farray)
 		SleepThreadUntil (NextTime);
 	}
 
-	RepairBackRect (&r);
+	// This clears the last lander return / launch) anim frame from the planet window.
+	if (RESOLUTION_FACTOR == 0 || !landing)
+		RepairBackRect (&r, FALSE);
 }
 
 static void
@@ -1481,7 +1528,7 @@ static void
 InitPlanetSide (POINT pt)
 {
 	// Adjust landing location by a random jitter.
-#define RANDOM_MISS 64
+#define RANDOM_MISS (64 << RESOLUTION_FACTOR) // JMS_GFX
 	if(!optGodMode){
 		pt.x -= RANDOM_MISS - TFB_Random () % (RANDOM_MISS << 1);
 		pt.y -= RANDOM_MISS - TFB_Random () % (RANDOM_MISS << 1);
@@ -1578,9 +1625,9 @@ LanderFire (SIZE facing)
 
 	angle = FACING_TO_ANGLE (facing);
 	SetVelocityComponents (
-			&WeaponElementPtr->velocity,
-			COSINE (angle, WORLD_TO_VELOCITY (2 * 3)) + wdx,
-			SINE (angle, WORLD_TO_VELOCITY (2 * 3)) + wdy);
+		&WeaponElementPtr->velocity,
+		COSINE (angle, WORLD_TO_VELOCITY ((2 * 3) << RESOLUTION_FACTOR)) + wdx,
+		SINE (angle, WORLD_TO_VELOCITY ((2 * 3) << RESOLUTION_FACTOR)) + wdy); // JMS_GFX
 
 	UnlockElement (hWeaponElement);
 
@@ -1649,11 +1696,11 @@ DoPlanetSide (LanderInputState *pMS)
 
 		angle = FACING_TO_ANGLE (GetFrameIndex (LanderFrame[0]));
 		landerSpeedNumer = GET_GAME_STATE (IMPROVED_LANDER_SPEED) ?
-				WORLD_TO_VELOCITY (2 * 14) :
-				WORLD_TO_VELOCITY (2 * 8);
+			WORLD_TO_VELOCITY (2 * (16 << RESOLUTION_FACTOR)) :
+			WORLD_TO_VELOCITY (2 * (8 << RESOLUTION_FACTOR));
 
 #ifdef FAST_FAST
-landerSpeedNumer = WORLD_TO_VELOCITY (48);
+landerSpeedNumer = WORLD_TO_VELOCITY (48 << RESOLUTION_FACTOR); // JMS
 #endif
 
 		SetVelocityComponents (&GLOBAL (velocity),
@@ -1716,11 +1763,11 @@ landerSpeedNumer = WORLD_TO_VELOCITY (48
 
 				angle = FACING_TO_ANGLE (index);
 				landerSpeedNumer = GET_GAME_STATE (IMPROVED_LANDER_SPEED) ?
-						WORLD_TO_VELOCITY (2 * 14) :
-						WORLD_TO_VELOCITY (2 * 8);
+					WORLD_TO_VELOCITY ((2 * 16) << RESOLUTION_FACTOR) :
+					WORLD_TO_VELOCITY ((2 * 8) << RESOLUTION_FACTOR);
 
 #ifdef FAST_FAST
-landerSpeedNumer = WORLD_TO_VELOCITY (48);
+landerSpeedNumer = WORLD_TO_VELOCITY (48 << RESOLUTION_FACTOR);
 #endif
 
 				SetVelocityComponents (&GLOBAL (velocity),
@@ -1859,7 +1906,7 @@ IdlePlanetSide (LanderInputState *inputS
 	while (GetTimeCounter () < TimeOut)
 	{
 		// 10 to clear the lander off of the screen
-		ScrollPlanetSide (0, 0, -(SURFACE_HEIGHT / 2 + 10));
+		ScrollPlanetSide (0, 0, -(SURFACE_HEIGHT / 2 + (10 << RESOLUTION_FACTOR))); // JMS_GFX
 		SleepThreadUntil (inputState->NextTime);
 		inputState->NextTime += PLANET_SIDE_RATE;
 	}
@@ -1870,20 +1917,32 @@ LandingTakeoffSequence (LanderInputState
 {
 // We cannot solve a quadratic equation in a macro, so use a sensible max
 #define MAX_OFFSETS  20
-// 10 to clear the lander off of the screen
-#define DISTANCE_COVERED  (SURFACE_HEIGHT / 2 + 10)
+#define MAX_OFFSETS_4X 400 // JMS_GFX
+// 10 << RESOLUTION_FACTOR to clear the lander off of the screen
+#define DISTANCE_COVERED  (SURFACE_HEIGHT / 2 + (10 << RESOLUTION_FACTOR))
 	int landingOfs[MAX_OFFSETS];
 	int start;
 	int end;
 	int delta;
 	int index;
+	int max_offsets; // JMS_GFX
+	int landingOfs4x[MAX_OFFSETS_4X]; // JMS_GFX
 
 	// Produce smooth acceleration deltas from a simple 1..x progression
 	delta = 0;
-	for (index = 0; index < MAX_OFFSETS && delta < DISTANCE_COVERED; ++index)
+	// JMS_GFX: At 4x resolution we run out of default offsets. -> Use larger offset value.
+	max_offsets = MAX_OFFSETS;
+	if (RESOLUTION_FACTOR == 2) 
+		max_offsets = MAX_OFFSETS_4X;
+
+	for (index = 0; index < max_offsets && delta < DISTANCE_COVERED; ++index)
 	{
 		delta += index + 1;
-		landingOfs[index] = -delta;
+		// JMS_GFX
+		if (RESOLUTION_FACTOR == 2)
+			landingOfs4x[index] = -delta;
+		else
+			landingOfs[index] = -delta;
 	}
 	assert (delta >= DISTANCE_COVERED && "Increase MAX_OFFSETS!");
 
@@ -1906,7 +1965,12 @@ LandingTakeoffSequence (LanderInputState
 	// Draw the landing/takeoff lander positions
 	for (index = start; index != end; index += delta)
 	{
-		ScrollPlanetSide (0, 0, landingOfs[index]);
+		// JMS_GFX
+		if (RESOLUTION_FACTOR == 2)
+			ScrollPlanetSide (0, 0, landingOfs4x[index]);
+		else
+			ScrollPlanetSide (0, 0, landingOfs[index]);
+
 		SleepThreadUntil (inputState->NextTime);
 		inputState->NextTime += PLANET_SIDE_RATE;
 	}
@@ -2040,7 +2104,7 @@ PlanetSide (POINT planetLoc)
 	explosion_index = 0;
 
 	AnimateLanderWarmup ();
-	AnimateLaunch (LanderFrame[5]);
+	AnimateLaunch (LanderFrame[5], TRUE);
 
 	if (optSubmenu)
 		DrawSubmenu (1);
@@ -2073,7 +2137,7 @@ PlanetSide (POINT planetLoc)
 
 			LandingTakeoffSequence (&landerInputState, FALSE);
 			ReturnToOrbit ();
-			AnimateLaunch (LanderFrame[6]);
+			AnimateLaunch (LanderFrame[6], FALSE);
 			
 			DeltaSISGauges (crew_left, 0, 0);
 
@@ -2192,9 +2256,8 @@ InitLander (BYTE LanderFlags)
 		if ((int)free_space < (int)(MAX_SCROUNGED << capacity_shift))
 		{
 			r.corner.x = 1;
-			r.extent.width = 4;
-			r.extent.height = MAX_HOLD_BARS - ((free_space >> capacity_shift)
-					* MAX_HOLD_BARS / MAX_SCROUNGED) + 2;
+			r.extent.width = RES_STAT_SCALE(4) + RESOLUTION_FACTOR; // JMS_GFX
+			r.extent.height = RES_STAT_SCALE(MAX_HOLD_BARS - ((free_space >> capacity_shift) * MAX_HOLD_BARS / MAX_SCROUNGED) + 2);
 			SetContextForeGroundColor (BLACK_COLOR);
 			DrawFilledRectangle (&r);
 		}
diff -ruNp src.mm/uqm/planets/orbits.c src/uqm/planets/orbits.c
--- src.mm/uqm/planets/orbits.c	2017-11-28 11:08:50 -0600
+++ src/uqm/planets/orbits.c	2017-11-28 11:09:36 -0600
@@ -474,18 +474,15 @@ void ComputeSpeed(PLANET_DESC *planet, B
 {
 	//BW : empiric values, which would give roughly correct
 	// rotation periods for most moons in the solar system
-	if (GeneratingMoons)
-		{
-			planet->orb_speed = FULL_CIRCLE / (29 * pow((double)planet->radius / (MIN_MOON_RADIUS + (MAX_MOONS - 1) * MOON_DELTA), 1.5));
-			if ((planet->pPrevDesc->data_index & ~PLANET_SHIELDED) >= FIRST_GAS_GIANT)
-				planet->orb_speed *= 2;
-			if (!(rand_val % 7))
-				planet->orb_speed = - planet->orb_speed;
-		}
-		else
-		{
-			planet->orb_speed = FULL_CIRCLE / (ONE_YEAR * pow((double)planet->radius / EARTH_RADIUS, 1.5));
-		}
+	if (GeneratingMoons) {
+		planet->orb_speed = FULL_CIRCLE / (29 * pow((double)planet->radius / (MIN_MOON_RADIUS + (MAX_MOONS - 1) * MOON_DELTA), 1.5));
+		if ((planet->pPrevDesc->data_index & ~PLANET_SHIELDED) >= FIRST_GAS_GIANT)
+			planet->orb_speed *= 2;
+		if (!(rand_val % 7))
+			planet->orb_speed = - planet->orb_speed;
+	} else {
+		planet->orb_speed = FULL_CIRCLE / (ONE_YEAR * pow((double)planet->radius / EARTH_RADIUS, 1.5));
+	}
 }
 
 void
@@ -544,8 +541,7 @@ char scolor[] = {'B', 'G', 'O', 'R', 'W'
 	while (NumPlanets--)
 	{
 		BYTE chance;
-		DWORD rand_val;
-		COUNT min_radius, angle;
+		DWORD rand_val, min_radius, angle;
 		SIZE delta_r;
 		PLANET_DESC *pLocPD;
 
@@ -625,14 +621,11 @@ RelocatePlanet:
 		pPD->angle = NORMALIZE_ANGLE (LOWORD (rand_val));
 		pPD->location.x = COSINE (pPD->angle, pPD->radius);
 		pPD->location.y = SINE (pPD->angle, pPD->radius);
-		if (GeneratingMoons)
-		{
+		if (GeneratingMoons) {
 		pPD->rand_seed = MAKE_DWORD (
-		     COSINE (pPD->angle, pPD->radius),
-		     SINE (pPD->angle, pPD->radius));
-		}
-		else
-		{
+		     COSINE (pPD->angle, pPD->radius >> RESOLUTION_FACTOR),
+		     SINE (pPD->angle, pPD->radius >> RESOLUTION_FACTOR));
+		} else {
 			pPD->rand_seed = MAKE_DWORD (pPD->location.x, pPD->location.y);
 		}
 		// Angle is kept for reference but location will be adjusted
diff -ruNp src.mm/uqm/planets/pl_stuff.c src/uqm/planets/pl_stuff.c
--- src.mm/uqm/planets/pl_stuff.c	2017-11-28 11:08:50 -0600
+++ src/uqm/planets/pl_stuff.c	2017-11-28 11:09:36 -0600
@@ -174,7 +174,7 @@ PrepareNextRotationFrame (PLANET_DESC *p
 	if(inOrbit){
 		Orbit->SphereFrame = SetAbsFrameIndex (Orbit->SphereFrame, rotFrameIndex);
 		//RenderPlanetSphere (Orbit->SphereFrame, rotPointIndex, throbShield);
-		RenderPlanetSphere (Orbit, Orbit->SphereFrame, rotPointIndex, pSolarSysState->pOrbitalDesc->data_index & PLANET_SHIELDED, throbShield, rotwidth, rotheight, rotheight >> 1); // RADIUS
+		RenderPlanetSphere (Orbit, Orbit->SphereFrame, rotPointIndex, pSolarSysState->pOrbitalDesc->data_index & PLANET_SHIELDED, throbShield, rotwidth, rotheight, (rotheight >> 1) - RESOLUTION_FACTOR); // RADIUS
 	
 		if (throbShield)
 		{	// prepare the next shield throb frame
@@ -249,7 +249,7 @@ ZoomInPlanetSphere (void)
 
 		BatchGraphics ();
 		if (i > 0)
-			RepairBackRect (&repairRect);
+			RepairBackRect (&repairRect, FALSE);
 
 		oldMode = SetGraphicScaleMode (TFB_SCALE_BILINEAR);
 		oldScale = SetGraphicScale ((int)(base * scale + 0.5));
diff -ruNp src.mm/uqm/planets/planets.c src/uqm/planets/planets.c
--- src.mm/uqm/planets/planets.c	2017-11-28 11:08:50 -0600
+++ src/uqm/planets/planets.c	2017-11-28 11:09:36 -0600
@@ -233,7 +233,11 @@ DrawOrbitalDisplay (DRAW_ORBITAL_MODE Mo
 	UnbatchGraphics ();
 
 	// for later RepairBackRect()
-	LoadIntoExtraScreen (&r);
+	// JMS_GFX
+	if (RESOLUTION_FACTOR == 0)
+		LoadIntoExtraScreen (&r);
+	else
+		LoadIntoExtraScreen_Fs (&r);
 }
 
 // Initialise the surface graphics, and start the planet music.
diff -ruNp src.mm/uqm/planets/planets.h src/uqm/planets/planets.h
--- src.mm/uqm/planets/planets.h	2017-11-28 11:08:50 -0600
+++ src/uqm/planets/planets.h	2017-11-28 11:09:36 -0600
@@ -42,7 +42,9 @@ enum PlanetScanTypes
 };
 
 #define MAP_WIDTH SIS_SCREEN_WIDTH
-#define MAP_HEIGHT (75 - SAFE_Y)
+#define MAP_HEIGHT RES_CASE(75,150,330) // JMS_GFX
+#define ORIGINAL_MAP_WIDTH 242			// JMS_GFX
+#define ORIGINAL_MAP_HEIGHT 75			// JMS_GFX
 
 enum
 {
@@ -79,18 +81,18 @@ enum
 
 #define NUM_SCANDOT_TRANSITIONS 4
 
-#define MIN_MOON_RADIUS 35
-#define MOON_DELTA 20
+#define MIN_MOON_RADIUS (35 << RESOLUTION_FACTOR) // JMS_GFX
+#define MOON_DELTA (20 << RESOLUTION_FACTOR) // JMS_GFX
 
 #define MAX_SUNS 1
 #define MAX_PLANETS 16
 #define MAX_MOONS 4
 
-#define MAP_BORDER_HEIGHT  5
+#define MAP_BORDER_HEIGHT  RES_CASE(5,10,10) // JMS_GFX
 #define SCAN_SCREEN_HEIGHT (SIS_SCREEN_HEIGHT - MAP_HEIGHT - MAP_BORDER_HEIGHT)
 
 #define PLANET_ROTATION_TIME (ONE_SECOND * 12)
-#define PLANET_ROTATION_RATE (PLANET_ROTATION_TIME / MAP_WIDTH)
+#define PLANET_ROTATION_RATE (PLANET_ROTATION_TIME / ORIGINAL_MAP_WIDTH) // JMS_GFX
 // XXX: -9 to match the original, but why? I have no idea
 #define PLANET_ORG_Y ((SCAN_SCREEN_HEIGHT - 9) / 2)
 
diff -ruNp src.mm/uqm/planets/plangen.c src/uqm/planets/plangen.c
--- src.mm/uqm/planets/plangen.c	2017-11-28 11:08:50 -0600
+++ src/uqm/planets/plangen.c	2017-11-28 11:09:36 -0600
@@ -46,7 +46,7 @@
 #define SHIELD_REFLECT_COMP 100
 
 #define NUM_BATCH_POINTS 64
-#define RADIUS 37
+#define RADIUS RES_CASE(37,74,163) // JMS_GFX
 //2*RADIUS
 #define TWORADIUS (RADIUS << 1)
 //RADIUS^2
@@ -485,10 +485,11 @@ CreateSphereTiltMap (int angle, COUNT he
 // this routine, but a filter can be applied if desired too.
 
 // HALO rim size
-#define SHIELD_HALO          6
+#define SHIELD_HALO          (6 << RESOLUTION_FACTOR) // JMS_GFX
 #define SHIELD_RADIUS        (RADIUS + SHIELD_HALO)
 #define SHIELD_HALO_GLOW     (SHIELD_GLOW_COMP + SHIELD_REFLECT_COMP)
 #define SHIELD_HALO_GLOW_MIN (SHIELD_HALO_GLOW >> 2)
+#define SHIELD_RADIUS_THRES  ((SHIELD_RADIUS + (1 << RESOLUTION_FACTOR)) * (SHIELD_RADIUS + (1 << RESOLUTION_FACTOR))) // JMS_GFX
 
 static FRAME
 CreateShieldMask (COUNT Radius, BOOLEAN forOrbit)
@@ -502,13 +503,14 @@ CreateShieldMask (COUNT Radius, BOOLEAN
 
 	if (forOrbit){
 		ShieldHalo = SHIELD_HALO;
-		ShieldRadius = (Radius + ShieldHalo) * Radius / RADIUS;
+		ShieldRadius = SHIELD_RADIUS * Radius / RADIUS;
 		RadiusSquared = pow((double)Radius, 2); // Radius * Radius;
 	} else {
 		ShieldHalo = SHIELD_HALO << 1;
 		ShieldRadius = (RADIUS + ShieldHalo) * Radius / RADIUS;
 		RadiusSquared = pow((double)RADIUS, 2); // RADIUS * RADIUS;
-	}	
+	}
+
 	ShieldDiam = (ShieldRadius << 1) + 1;
 	ShieldRadiusThreshold = pow((double)(ShieldRadius + 1), 2); // (ShieldRadius + 1) * (ShieldRadius + 1);
 
@@ -858,7 +860,7 @@ MakeCrater (RECT *pRect, SBYTE *DepthArr
 	SIZE A, B;
 	SDWORD Asquared, TwoAsquared, Bsquared, TwoBsquared;	// JMS_GFX: Was 'long' - type changed to conform to UQM's own types
 	SDWORD d, dx, dy;									// JMS_GFX: Was 'long' - type changed to conform to UQM's own types
-	COUNT TopIndex, BotIndex, rim_pixels;
+	DWORD TopIndex, BotIndex, rim_pixels; // JMS_GFX: Was COUNT - type changed because of overflow at 4x
  
 
 	A = pRect->extent.width >> 1;
@@ -1043,7 +1045,7 @@ MakeCrater (RECT *pRect, SBYTE *DepthArr
 #define NUM_BAND_COLORS 4
 
 static void
-MakeStorms (COUNT storm_count, SBYTE *DepthArray, COUNT width)
+MakeStorms (COUNT storm_count, SBYTE *DepthArray, COUNT width, COUNT height)
 {
 #define MAX_STORMS 12 // JMS_GFX: was 8
 	COUNT i;
@@ -1070,16 +1072,16 @@ MakeStorms (COUNT storm_count, SBYTE *De
 			hiword = HIWORD (rand_val);
 			switch (HIBYTE (hiword) & 31) {
 				case 0:
-					pstorm_r->extent.height = (LOBYTE (hiword) % (MAP_HEIGHT >> 2)) + (MAP_HEIGHT >> 2);
+					pstorm_r->extent.height = (LOBYTE (hiword) % (ORIGINAL_MAP_HEIGHT >> 2)) + (ORIGINAL_MAP_HEIGHT >> 2);
 					break;
 				case 1:
 				case 2:
 				case 3:
 				case 4:
-					pstorm_r->extent.height = (LOBYTE (hiword) % (MAP_HEIGHT >> 3)) + (MAP_HEIGHT >> 3);
+					pstorm_r->extent.height = (LOBYTE (hiword) % (ORIGINAL_MAP_HEIGHT >> 3)) + (ORIGINAL_MAP_HEIGHT >> 3);
 					break;
 				default:
-					pstorm_r->extent.height = (LOBYTE (hiword) % (MAP_HEIGHT >> 4)) + 4;
+					pstorm_r->extent.height = (LOBYTE (hiword) % (ORIGINAL_MAP_HEIGHT >> 4)) + 4;
 					break;
 			}
 
@@ -1092,8 +1094,13 @@ MakeStorms (COUNT storm_count, SBYTE *De
 
 			pstorm_r->extent.width = pstorm_r->extent.height + (LOBYTE (loword) % pstorm_r->extent.height);
 
-			pstorm_r->corner.x = HIBYTE (loword) % (MAP_WIDTH - pstorm_r->extent.width);
-			pstorm_r->corner.y = LOBYTE (loword) % (MAP_HEIGHT - pstorm_r->extent.height);
+			pstorm_r->corner.x = HIBYTE (loword) % (ORIGINAL_MAP_WIDTH - pstorm_r->extent.width);
+			pstorm_r->corner.y = LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT - pstorm_r->extent.height);
+
+			pstorm_r->corner.x = pstorm_r->corner.x * width / ORIGINAL_MAP_WIDTH;
+			pstorm_r->extent.width = pstorm_r->extent.width * width / ORIGINAL_MAP_WIDTH;
+			pstorm_r->corner.y = pstorm_r->corner.y * height / ORIGINAL_MAP_HEIGHT;
+			pstorm_r->extent.height = pstorm_r->extent.height * height / ORIGINAL_MAP_HEIGHT;
 
 			for (j = i + 1; j < storm_count; ++j)
 			{
@@ -1164,9 +1171,9 @@ MakeGasGiant (COUNT num_bands, SBYTE *De
 	DWORD rand_val;
 
 	// band_height = pRect->extent.height / num_bands;
-	band_height = MAP_HEIGHT / num_bands;
+	band_height = ORIGINAL_MAP_HEIGHT / num_bands;
 	// band_bump = pRect->extent.height % num_bands;
-	band_bump = MAP_HEIGHT % num_bands;
+	band_bump = ORIGINAL_MAP_HEIGHT % num_bands;
 	band_error = num_bands >> 1;
 	lpDst = DepthArray;
 
@@ -1193,10 +1200,10 @@ MakeGasGiant (COUNT num_bands, SBYTE *De
 			RECT r;
 
 			cur_y = next_y + ((band_height - 2) >> 1) - ((LOBYTE (hiword) % (band_height - 2)) + 1);
-			cur_y = cur_y * pRect->extent.height / MAP_HEIGHT;
+			cur_y = cur_y * pRect->extent.height / ORIGINAL_MAP_HEIGHT;
 			r.corner.x = r.corner.y = 0;
 			r.extent.width = pRect->extent.width;
-			r.extent.height = 5 * pRect->extent.height / MAP_HEIGHT;
+			r.extent.height = 5 * pRect->extent.height / ORIGINAL_MAP_HEIGHT;
 			DeltaTopography (50,
 					&DepthArray[(cur_y - (r.extent.height >>1)) * r.extent.width],
 					&r, depth_delta);
@@ -1216,7 +1223,7 @@ MakeGasGiant (COUNT num_bands, SBYTE *De
 				& (((1 << RANGE_SHIFT) * NUM_BAND_COLORS) - 1);
 	}
 
-	MakeStorms (4 + (TFB_Random () & 7) + 1, DepthArray, pRect->extent.width);
+	MakeStorms (4 + (TFB_Random () & 7) + 1, DepthArray, pRect->extent.width, pRect->extent.height);
 
 	DitherMap (DepthArray, pRect->extent.width, pRect->extent.height);
 }
@@ -1227,7 +1234,7 @@ ValidateMap (SBYTE *DepthArray, COUNT wi
 	BYTE state;
 	BYTE pixel_count[2], lb[2];
 	SBYTE last_byte;
-	COUNT i;
+	DWORD i;
 	SBYTE *lpDst;
 
 	i = width - 1;
@@ -1546,7 +1553,7 @@ TopoScale4x (SBYTE *pDstTopo, SBYTE *pSr
 // Lots of pure Voodoo here ;)
 //  the goal is a 3D illusion, not mathematically correct lighting
 
-#define LMAP_AVG_BLOCK    ((MAP_HEIGHT + 4) / 5)
+#define LMAP_AVG_BLOCK     ((75 + 4) / 5) // BW: hacky but this shouldn't really depend on the size of the original map
 #define LMAP_MAX_DIST     ((LMAP_AVG_BLOCK + 1) >> 1)
 #define LMAP_WEIGHT_THRES (LMAP_MAX_DIST * 2 / 3)
 
@@ -1609,13 +1616,15 @@ GenerateLightMap (SBYTE *pTopo, int w, i
 {
 #define LMAP_BLOCKS       (2 * LMAP_MAX_DIST + 1)
 	int x, y;
-	elev_block_t vblocks[LMAP_BLOCKS];
-			// we use a running block average to reduce the amount of work
-			// where a block is a vertical line of map points
+
 	SBYTE *elev;
 	int min, max, med;
 	int sfact, spread;
 
+	elev_block_t vblocks[LMAP_BLOCKS];
+	// we use a running block average to reduce the amount of work
+	// where a block is a vertical line of map points
+
 	// normalize the topo data
 	min = 127;
 	max = -128;
@@ -1727,10 +1736,9 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 	RECT r;
 	const PlanetFrame *PlanDataPtr;
 	PLANET_INFO *PlanetInfo = &pSolarSysState->SysInfo.PlanetInfo;
-	COUNT i, y; 
+	DWORD i, y; 
 	POINT loc;
-	CONTEXT OldContext;
-	CONTEXT TopoContext;
+	CONTEXT OldContext, TopoContext;
 	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
 	BOOLEAN SurfDef = FALSE;
 	BOOLEAN shielded = (pPlanetDesc->data_index & PLANET_SHIELDED) != 0;	
@@ -1855,32 +1863,37 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 						switch (HIBYTE (loword) & 31)
 						{
 							case 0:
-								crater_r.extent.width =
-										(LOBYTE (loword) % (Height >> 2))
-										+ (Height >> 2);
+								crater_r.extent.width = (LOBYTE (loword) 
+									% (ORIGINAL_MAP_HEIGHT >> 2)) 
+									+ (ORIGINAL_MAP_HEIGHT >> 2);
 								break;
 							case 1:
 							case 2:
 							case 3:
 							case 4:
-								crater_r.extent.width =
-										(LOBYTE (loword) % (Height >> 3))
-										+ (Height >> 3);
+								crater_r.extent.width = (LOBYTE (loword) 
+									% (ORIGINAL_MAP_HEIGHT >> 3)) 
+									+ (ORIGINAL_MAP_HEIGHT >> 3);
 								break;
 							default:
-								crater_r.extent.width =
-										(LOBYTE (loword) % (Height >> 4))
-										+ 4;
+								crater_r.extent.width = (LOBYTE (loword) 
+									% (ORIGINAL_MAP_HEIGHT >> 4)) + 4;
 								break;
 						}
 
 						loword = LOWORD (RandomContext_Random (SysGenRNG));
 
 						crater_r.extent.height = crater_r.extent.width;
-						crater_r.corner.x = HIBYTE (loword)
-								% (Width - crater_r.extent.width);
-						crater_r.corner.y = LOBYTE (loword)
-								% (Height - crater_r.extent.height);
+						crater_r.corner.x = HIBYTE (loword) % (ORIGINAL_MAP_WIDTH - crater_r.extent.width);
+						// crater_r.corner.x = loword % (MAP_WIDTH - crater_r.extent.width); // JMS_GFX: changed the previous line to this. BYTE was too small for 4x resolution
+						crater_r.corner.y = LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT - crater_r.extent.height);
+						// crater_r.corner.y = hiword % (MAP_HEIGHT - crater_r.extent.height); // JMS_GFX: The same
+
+						// BW: ... then scale them up
+						crater_r.extent.width = crater_r.extent.width * Height / ORIGINAL_MAP_HEIGHT;
+						crater_r.extent.height = crater_r.extent.width;
+						crater_r.corner.x = crater_r.corner.x * Width / ORIGINAL_MAP_WIDTH;					
+						crater_r.corner.y = crater_r.corner.y * Height / ORIGINAL_MAP_HEIGHT;
 
 						MakeCrater (&crater_r, Orbit->lpTopoData,
 								PlanDataPtr->fault_depth << 2,
@@ -2017,7 +2030,4 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 
 	SetContext (OldContext);
 	DestroyContext (TopoContext);
-}
-
-void
-	newFunct (void) {}
\ No newline at end of file
+}
\ No newline at end of file
diff -ruNp src.mm/uqm/planets/pstarmap.c src/uqm/planets/pstarmap.c
--- src.mm/uqm/planets/pstarmap.c	2017-11-28 11:08:50 -0600
+++ src/uqm/planets/pstarmap.c	2017-11-28 11:09:36 -0600
@@ -57,10 +57,10 @@ static POINT cursorLoc;
 static POINT mapOrigin;
 static int zoomLevel;
 static FRAME StarMapFrame;
+
 static BOOLEAN show_prewar_situation; // JMS
 static CURRENT_STARMAP_SHOWN which_starmap; // JMS
 
-
 static inline long
 signedDivWithError (long val, long divisor)
 {
@@ -785,7 +785,7 @@ EraseCursor (COORD curs_x, COORD curs_y)
 		r.extent.height = SIS_SCREEN_HEIGHT - r.corner.y;
 
 #ifndef OLD
-	RepairBackRect (&r);
+	RepairBackRect (&r, FALSE);
 #else /* NEW */
 	r.extent.height += r.corner.y & 1;
 	r.corner.y &= ~1;
@@ -796,7 +796,7 @@ EraseCursor (COORD curs_x, COORD curs_y)
 static void
 ZoomStarMap (SIZE dir)
 {
-#define MAX_ZOOM_SHIFT 4
+#define MAX_ZOOM_SHIFT (BYTE)(4 - RESOLUTION_FACTOR)
 	if (dir > 0)
 	{
 		if (zoomLevel < MAX_ZOOM_SHIFT)
@@ -900,6 +900,9 @@ UpdateCursorLocation (int sx, int sy, co
 }
 
 #define CURSOR_INFO_BUFSIZE 256
+// JMS: How close to a star the cursor has to be to 'snap' into it.
+// Don't make this larger than 1 for lo-res(1x). Otherwise the cursor gets stuck on stars.
+#define CURSOR_SNAP_AREA (RES_CASE(0,1,2)) // MB: Fixed cursor snap area so that trying to autopilot to sol no longer selects sirius all the damn time unless you zoom in.
 
 static void
 UpdateCursorInfo (UNICODE *prevbuf)
@@ -922,7 +925,7 @@ UpdateCursorInfo (UNICODE *prevbuf)
 	}
 	else
 	{	
-		// "(Star search:F6 Toggle maps:F7)"
+		// "(Star Search: F6 | Toggle Maps: F7)"
 		utf8StringCopy (buf, sizeof (buf), GAME_STRING (FEEDBACK_STRING_BASE + 2));
 	}
 
@@ -932,17 +935,32 @@ UpdateCursorInfo (UNICODE *prevbuf)
 	SDPtr = BestSDPtr = 0;
 	while ((SDPtr = FindStar (SDPtr, &cursorLoc, 75, 75)))
 	{
-		if (UNIVERSE_TO_DISPX (SDPtr->star_pt.x) == pt.x
-				&& UNIVERSE_TO_DISPY (SDPtr->star_pt.y) == pt.y
-				&& (BestSDPtr == 0
-				|| STAR_TYPE (SDPtr->Type) >= STAR_TYPE (BestSDPtr->Type)))
+		if ((UNIVERSE_TO_DISPX (SDPtr->star_pt.x) >= pt.x - CURSOR_SNAP_AREA && UNIVERSE_TO_DISPX (SDPtr->star_pt.x) <= pt.x + CURSOR_SNAP_AREA)
+			&& (UNIVERSE_TO_DISPY (SDPtr->star_pt.y) >= pt.y - CURSOR_SNAP_AREA && UNIVERSE_TO_DISPY (SDPtr->star_pt.y) <= pt.y + CURSOR_SNAP_AREA)
+			&& (BestSDPtr == 0 || STAR_TYPE (SDPtr->Type) >= STAR_TYPE (BestSDPtr->Type)))
 			BestSDPtr = SDPtr;
 	}
 
 	if (BestSDPtr)
 	{
-		cursorLoc = BestSDPtr->star_pt;
-		GetClusterName (BestSDPtr, buf);
+		// JMS: For masking the names of QS portals not yet entered.
+		BYTE QuasiPortalsKnown[] =
+		{
+			QS_PORTALS_KNOWN
+		};
+		
+		// A star is near the cursor:
+		// Snap cursor onto star only in 1x res. In hi-res modes,
+		// snapping is done when the star is selected as auto-pilot target.
+		if (RESOLUTION_FACTOR == 0)
+			cursorLoc = BestSDPtr->star_pt;
+		
+		if (GET_GAME_STATE(ARILOU_SPACE_SIDE) >= 2
+			&& !(QuasiPortalsKnown[BestSDPtr->Postfix - 133]))
+			utf8StringCopy (buf, sizeof (buf),
+				GAME_STRING (STAR_STRING_BASE + 132));
+		else
+			GetClusterName (BestSDPtr, buf);
 	}
 	else
 	{	// No star found. Reset the coordinates to the cursor's location
@@ -986,7 +1004,35 @@ UpdateCursorInfo (UNICODE *prevbuf)
 	if (strcmp (buf, prevbuf) != 0)
 	{
 		strcpy (prevbuf, buf);
-		DrawSISMessage (buf);
+		// Cursor is on top of a star. Display its name.
+		if (BestSDPtr)
+			DrawSISMessage (buf);
+		// Cursor is elsewhere.
+		else
+		{
+			// In HS, display default star search button name.
+			if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
+			{
+				CONTEXT OldContext;
+				OldContext = SetContext (OffScreenContext);
+				
+				if (show_prewar_situation)
+					SetContextForeGroundColor 
+						(BUILD_COLOR (MAKE_RGB15 (0x18, 0x00, 0x00), 0x00));
+				else
+					SetContextForeGroundColor 
+						(BUILD_COLOR (MAKE_RGB15 (0x0E, 0xA7, 0xD9), 0x00));
+						
+				DrawSISMessageEx (buf, -1, -1, DSME_MYCOLOR);
+				SetContext (OldContext);
+			}
+			// In QS, don't display star search button - the search is unusable.
+			else
+			{
+				strcpy (buf, "QuasiSpace");
+				DrawSISMessage (buf);
+			}
+		}
 	}
 }
 
@@ -1442,9 +1488,10 @@ DoStarSearch (MENU_STATE *pMS)
 static BOOLEAN
 DoMoveCursor (MENU_STATE *pMS)
 {
-#define MIN_ACCEL_DELAY (ONE_SECOND / 60)
-#define MAX_ACCEL_DELAY (ONE_SECOND / 8)
-#define STEP_ACCEL_DELAY (ONE_SECOND / 120)
+// MB: correcting previously-unusable acceleration values
+#define MIN_ACCEL_DELAY (ONE_SECOND / 50)
+#define MAX_ACCEL_DELAY (ONE_SECOND / 13)
+#define STEP_ACCEL_DELAY (ONE_SECOND / 180)
 	static UNICODE last_buf[CURSOR_INFO_BUFSIZE];
 	DWORD TimeIn = GetTimeCounter ();
 	static COUNT moveRepeats;
@@ -1478,6 +1525,34 @@ DoMoveCursor (MENU_STATE *pMS)
 	}
 	else if (PulsedInputState.menu[KEY_MENU_SELECT])
 	{
+		// JMS: The hi-res modes now have a user-friendly starmap cursor.
+		// The cursor finds a star even if the cursor is several pixels away from it (CURSOR_SNAP_AREA)
+		// The cursor centers on the star only when selected as an auto-pilot target.
+		if (RESOLUTION_FACTOR > 0)
+		{
+			STAR_DESC *SDPtr;
+			STAR_DESC *BestSDPtr;
+			POINT pt;
+			
+			pt.x = UNIVERSE_TO_DISPX (cursorLoc.x);
+			pt.y = UNIVERSE_TO_DISPY (cursorLoc.y);
+			SDPtr = BestSDPtr = 0;
+			
+			while ((SDPtr = FindStar (SDPtr, &cursorLoc, 75, 75)))
+			{
+				if ((UNIVERSE_TO_DISPX (SDPtr->star_pt.x) >= pt.x - CURSOR_SNAP_AREA && UNIVERSE_TO_DISPX (SDPtr->star_pt.x) <= pt.x + CURSOR_SNAP_AREA)
+					&& (UNIVERSE_TO_DISPY (SDPtr->star_pt.y) >= pt.y -CURSOR_SNAP_AREA && UNIVERSE_TO_DISPY (SDPtr->star_pt.y) <= pt.y + CURSOR_SNAP_AREA)
+					&& (BestSDPtr == 0 || STAR_TYPE (SDPtr->Type) >= STAR_TYPE (BestSDPtr->Type)))
+					BestSDPtr = SDPtr;
+			}
+			
+			if (BestSDPtr)
+			{
+				cursorLoc = BestSDPtr->star_pt;
+				UpdateCursorLocation (0, 0, &BestSDPtr->star_pt);
+			}
+		}
+
 		// printf("Fuel Available: %d | Fuel Requirement: %d\n", GLOBAL_SIS (FuelOnBoard), FuelRequired());
 
 		if (optBubbleWarp) {
@@ -1564,6 +1639,15 @@ DoMoveCursor (MENU_STATE *pMS)
 		if (PulsedInputState.menu[KEY_MENU_UP])      sy =   -1;
 		if (PulsedInputState.menu[KEY_MENU_DOWN])    sy =    1;
 
+		if (moveRepeats > 20)
+		{
+			sx *= 1 << RESOLUTION_FACTOR;
+			sy *= 1 << RESOLUTION_FACTOR;
+		}
+		// BW: we need to go through this because 4x only checks for
+		// input every ONE_SECOND/40 or so, thus reducing
+		// MIN_ACCEL_STEP is of no use. In practice it's similar.
+
 		if (sx != 0 || sy != 0)
 		{
 			UpdateCursorLocation (sx, sy, NULL);
diff -ruNp src.mm/uqm/planets/report.c src/uqm/planets/report.c
--- src.mm/uqm/planets/report.c	2017-11-28 11:08:50 -0600
+++ src/uqm/planets/report.c	2017-11-28 11:09:36 -0600
@@ -33,8 +33,8 @@
 #include <string.h>
 
 
-#define NUM_CELL_COLS MAP_WIDTH / 6
-#define NUM_CELL_ROWS MAP_HEIGHT / 6
+#define NUM_CELL_COLS (MAP_WIDTH / (6 << RESOLUTION_FACTOR) + RES_CASE(0,3,7) - (optWhichFonts == OPT_PC ? 0 : RES_CASE(0,0,1))) // JMS_GFX 
+#define NUM_CELL_ROWS (MAP_HEIGHT / (6 << RESOLUTION_FACTOR) + RES_CASE(0,1,2)) // JMS_GFX
 #define MAX_CELL_COLS 40
 
 extern FRAME SpaceJunkFrame;
@@ -43,10 +43,20 @@ static void
 ClearReportArea (void)
 {
 	COUNT x, y;
+	BYTE emptycols, emptyrows;  // JMS_GFX
 	RECT r;
 	STAMP s;
 	COORD startx;
 
+	// JMS_GFX
+	if (RESOLUTION_FACTOR > 0) {
+		emptycols = NUM_CELL_COLS + 1;
+		emptyrows = NUM_CELL_ROWS + 1;
+	} else {
+		emptycols = NUM_CELL_COLS;
+		emptyrows = NUM_CELL_ROWS;
+	}
+
 	if (optWhichFonts == OPT_PC)
 		s.frame = SetAbsFrameIndex (SpaceJunkFrame, 21);
 	else
@@ -60,12 +70,12 @@ ClearReportArea (void)
 	SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x00, 0x07, 0x00), 0x57));
 	
-	startx = 1 + (r.extent.width >> 1) - 1;
-	s.origin.y = 1;
-	for (y = 0; y < NUM_CELL_ROWS; ++y)
+	startx = 1 + (r.extent.width >> 1) - 1 - (4 * RESOLUTION_FACTOR) + RES_CASE(0,0,8);  // JMS_GFX
+	s.origin.y = 1 + RES_CASE(0,0,9);
+	for (y = 0; y < emptyrows; ++y)
 	{
 		s.origin.x = startx;
-		for (x = 0; x < NUM_CELL_COLS; ++x)
+		for (x = 0; x < emptycols; ++x)
 		{
 			if (optWhichFonts == OPT_PC)
 				DrawStamp (&s);
@@ -132,8 +142,9 @@ MakeReport (SOUND ReadOutSounds, UNICODE
 			t.pStr = end_page_buf;
 			StrLen += end_page_len;
 		}
-		t.baseline.x = 1 + (r.extent.width >> 1)
-				+ (col_cells * (r.extent.width + 1)) - 1;
+		t.baseline.x = 1 + (r.extent.width >> 1) 
+			+ (col_cells * (r.extent.width + 1)) 
+			- 1 - 3 * RESOLUTION_FACTOR; // JMS_GFX
 		do
 		{
 			COUNT word_chars;
@@ -215,7 +226,7 @@ MakeReport (SOUND ReadOutSounds, UNICODE
 
 InitPageCell:
 			ButtonState = 1;
-			t.baseline.y = r.extent.height + 1;
+			t.baseline.y = r.extent.height + (1 << RESOLUTION_FACTOR) + 3 * RESOLUTION_FACTOR; // JMS_GFX
 			row_cells = 0;
 			if (StrLen)
 			{
diff -ruNp src.mm/uqm/planets/roster.c src/uqm/planets/roster.c
--- src.mm/uqm/planets/roster.c	2017-11-28 11:08:50 -0600
+++ src/uqm/planets/roster.c	2017-11-28 11:09:36 -0600
@@ -21,16 +21,22 @@
 #include "../controls.h"
 #include "../races.h"
 #include "../units.h"
+#include "../util.h" // JMS: For SaveContextFrame()
 #include "../sis.h"
 #include "../shipcont.h"
 #include "../setup.h"
 #include "../sounds.h"
 #include "port.h"
 #include "libs/gfxlib.h"
+#include "libs/log.h"
 #include "libs/tasklib.h"
 
 #include <stdlib.h>
 
+// JMS_GFX: These exist to prevent the leftover red borders of the rostered ships in hi-res.
+static RECT  savedShipFrame_r;
+static STAMP savedShipFrame;
+
 // Ship icon positions in status display around the flagship
 static const POINT ship_pos[MAX_BUILT_SHIPS] =
 {
@@ -58,20 +64,34 @@ typedef struct
 static SHIP_FRAGMENT* LockSupportShip (ROSTER_STATE *, HSHIPFRAG *phFrag);
 
 static void
-drawSupportShip (ROSTER_STATE *rosterState, bool filled)
+drawSupportShip (ROSTER_STATE *rosterState, bool filled, bool saveFrame)
 {
 	STAMP s;
 
 	if (!rosterState->curShipFrame)
 		return;
 
-	s.origin = rosterState->curShipPt;
+	s.origin.x = RES_STAT_SCALE(rosterState->curShipPt.x)
+		+ (rosterState->curShipPt.x >= ship_pos[1].x ? RES_CASE(0,3,5) : RES_CASE(0,-2,-2)); // JMS_GFX
+	s.origin.y = RES_STAT_SCALE(rosterState->curShipPt.y) + RES_CASE(0,5,0);
 	s.frame = rosterState->curShipFrame;
 	
-	if (filled)
-		DrawFilledStamp (&s);
-	else
-		DrawStamp (&s);
+	// JMS: 
+	if (saveFrame) {
+		savedShipFrame_r.corner.x = s.origin.x;
+		savedShipFrame_r.corner.y = s.origin.y;
+		savedShipFrame_r.extent.width  = 16 << RESOLUTION_FACTOR;
+		savedShipFrame_r.extent.height = 16 << RESOLUTION_FACTOR; 
+	
+		savedShipFrame = SaveContextFrame (&savedShipFrame_r);
+		
+		log_add (log_Debug,"Saved x:%u, y:%u", savedShipFrame_r.corner.x ,savedShipFrame_r.corner.y);
+	} else {
+		if (filled)
+			DrawFilledStamp (&s);
+		else
+			DrawStamp (&s);
+	}
 }
 
 static void
@@ -85,16 +105,18 @@ getSupportShipIcon (ROSTER_STATE *roster
 	if (!ShipFragPtr)
 		return;
 
-	rosterState->curShipFrame = ShipFragPtr->icons;
+	rosterState->curShipFrame = SetAbsFrameIndex (ShipFragPtr->icons, 2);
 	UnlockShipFrag (&GLOBAL (built_ship_q), hShipFrag);
 }
 
 static void
-flashSupportShip (ROSTER_STATE *rosterState)
+flashSupportShip (ROSTER_STATE *rosterState, bool saveFrame)
 {
 	static Color c = BUILD_COLOR (MAKE_RGB15_INIT (0x1F, 0x00, 0x00), 0x24);
 	static TimeCount NextTime = 0;
 
+	drawSupportShip (rosterState, TRUE, saveFrame);
+
 	if (GetTimeCounter () >= NextTime)
 	{
 		NextTime = GetTimeCounter () + (ONE_SECOND / 15);
@@ -121,7 +143,7 @@ flashSupportShip (ROSTER_STATE *rosterSt
 		}
 		SetContextForeGroundColor (c);
 
-		drawSupportShip (rosterState, TRUE);
+		drawSupportShip (rosterState, TRUE, FALSE);
 	}
 }
 
@@ -220,7 +242,7 @@ drawModifiedSupportShip (ROSTER_STATE *r
 {
 	SetContext (StatusContext);
 	SetContextForeGroundColor (ROSTER_MODIFY_SHIP_COLOR);
-	drawSupportShip (rosterState, TRUE);
+	drawSupportShip (rosterState, TRUE, FALSE);
 }
 
 static void
@@ -354,14 +376,26 @@ DoModifyRoster (MENU_STATE *pMS)
 
 		if (NewState != pMS->CurState)
 		{
-			// Draw the previous escort in unselected state
-			drawSupportShip (rosterState, FALSE);
+			// Draw the previous escort in unselected state.
+			// JMS_GFX: In 4x and 2x modes we draw the rectangle of screen
+			// we captured earlier.
+			if (RESOLUTION_FACTOR > 0)
+				DrawStamp (&savedShipFrame);
+			else // In 1x mode we just draw the icon.
+				drawSupportShip (rosterState, FALSE, FALSE);
 			// Select the new one
 			selectSupportShip (rosterState, NewState);
 			pMS->CurState = NewState;
-		}
 
-		flashSupportShip (rosterState);
+			// JMS_GFX: In 2x and 4x modes we now have to capture the
+			// location of this new rectangle.
+			if (RESOLUTION_FACTOR > 0)
+				flashSupportShip (rosterState, TRUE);
+			else
+				flashSupportShip (rosterState, FALSE);
+		} 
+		else
+			flashSupportShip (rosterState, FALSE);
 
 		UnbatchGraphics ();
 	}
@@ -416,14 +450,26 @@ RosterMenu (void)
 	SetContext (StatusContext);
 	selectSupportShip (&RosterState, MenuState.CurState);
 
+	// JMS_GFX: Remember the location of the first ship to be able to erase
+	// the red junk from around it after rostering.
+	if (RESOLUTION_FACTOR > 0)
+		drawSupportShip (&RosterState, TRUE, TRUE);
+
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
 
 	MenuState.InputFunc = DoModifyRoster;
 	DoInput (&MenuState, TRUE);
 
 	SetContext (StatusContext);
-	// unselect the last ship
-	drawSupportShip (&RosterState, FALSE);
+	
+	// Draw the last escort in unselected state.
+	// JMS_GFX: In 4x and 2x modes we draw the rectangle of screen
+	// we captured earlier.
+	if (RESOLUTION_FACTOR > 0)
+		DrawStamp (&savedShipFrame);
+	else // In 1x mode we just draw the icon.
+		drawSupportShip (&RosterState, FALSE, FALSE);
+
 	DrawStatusMessage (NULL);
 
 	return TRUE;
diff -ruNp src.mm/uqm/planets/scan.c src/uqm/planets/scan.c
--- src.mm/uqm/planets/scan.c	2017-11-28 11:08:50 -0600
+++ src/uqm/planets/scan.c	2017-11-28 11:09:36 -0600
@@ -43,6 +43,8 @@
 #include "libs/inplib.h"
 #include "libs/mathlib.h"
 
+#define HAZARD_COLORS
+
 extern FRAME SpaceJunkFrame;
 
 // define SPIN_ON_SCAN to allow the planet to spin 
@@ -68,7 +70,7 @@ enum ScanMenuItems
 
 
 void
-RepairBackRect (RECT *pRect)
+RepairBackRect (RECT *pRect, BOOLEAN Fullscreen)
 {
 	RECT new_r, old_r;
 
@@ -79,7 +81,11 @@ RepairBackRect (RECT *pRect)
 
 	new_r.extent.height += new_r.corner.y & 1;
 	new_r.corner.y &= ~1;
-	DrawFromExtraScreen (&new_r);
+	
+	if (Fullscreen)
+		DrawFromExtraScreen_Fs (&new_r);
+	else
+		DrawFromExtraScreen (&new_r);
 }
 
 static void
@@ -149,19 +155,27 @@ GetPlanetTitle (UNICODE *buf, COUNT bufs
 static void
 PrintCoarseScanPC (void)
 {
-#define SCAN_LEADING_PC 14
+#define SCAN_LEADING_PC (14 << RESOLUTION_FACTOR) // JMS_GFX
 	SDWORD val;
 	TEXT t;
 	RECT r;
 	UNICODE buf[200];
 
+	/* We need this for the new color-changing hazard readouts.
+	 * We initialize it to SCAN_PC_TITLE_COLOR because we'll need
+	 * to reset the ContextForeGroundColor to this value whenever
+	 * we may have changed it - and having it always be set to a
+	 * sane value removes the need to only reset it conditionally.
+	 */
+	Color OldColor = (SCAN_PC_TITLE_COLOR);
+
 	GetPlanetTitle (buf, sizeof (buf));
 
 	SetContext (PlanetContext);
 
 	t.align = ALIGN_CENTER;
 	t.baseline.x = SIS_SCREEN_WIDTH >> 1;
-	t.baseline.y = 13;
+	t.baseline.y = (13 << RESOLUTION_FACTOR) + 4*RESOLUTION_FACTOR; // JMS_GFX
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 
@@ -171,9 +185,9 @@ PrintCoarseScanPC (void)
 
 	SetContextFont (TinyFont);
 
-#define LEFT_SIDE_BASELINE_X_PC 5
-#define RIGHT_SIDE_BASELINE_X_PC (SIS_SCREEN_WIDTH - 75)
-#define SCAN_BASELINE_Y_PC 40
+#define LEFT_SIDE_BASELINE_X_PC (5 << RESOLUTION_FACTOR) // JMS_GFX
+#define RIGHT_SIDE_BASELINE_X_PC (SIS_SCREEN_WIDTH - (75 << RESOLUTION_FACTOR)) // JMS_GFX
+#define SCAN_BASELINE_Y_PC (40 << RESOLUTION_FACTOR) // JMS_GFX
 
 	t.baseline.y = SCAN_BASELINE_Y_PC;
 	t.align = ALIGN_LEFT;
@@ -213,9 +227,22 @@ PrintCoarseScanPC (void)
 			LEFT_SIDE_BASELINE_X_PC); // "Temp: "
 	sprintf (buf, "%d" STR_DEGREE_SIGN " c",
 			pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature);
+#ifdef HAZARD_COLORS
+	if ((pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature) >= (100) &&
+	    (pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature) <= (400))
+	{ /* Between 100 and 400 temperature the planet is still explorable,
+	   * draw the readout in yellow */
+		OldColor = SetContextForeGroundColor (DULL_YELLOW_COLOR);
+	}
+	else if (pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature > 400)
+	{ /* Above 400 the planet is quite dangerous, draw the readout in red. */
+		OldColor = SetContextForeGroundColor (BRIGHT_RED_COLOR);
+	}
+#endif
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
+	SetContextForeGroundColor (OldColor);
 	t.baseline.y += SCAN_LEADING_PC;
 
 	PrintScanTitlePC (&t, &r, GAME_STRING (ORBITSCAN_STRING_BASE + 7),
@@ -229,8 +256,22 @@ PrintCoarseScanPC (void)
 				pSolarSysState->SysInfo.PlanetInfo.Weather + 1);
 		t.pStr = buf;
 	}
+#ifdef HAZARD_COLORS
+	if ((pSolarSysState->SysInfo.PlanetInfo.Weather + 1) >= (3) &&
+	    (pSolarSysState->SysInfo.PlanetInfo.Weather + 1) <= (4))
+	{ /* Weather values of 3 or 4 will unavoidably kill a few
+	   * crew, draw the readout in yellow. */
+		OldColor = SetContextForeGroundColor (DULL_YELLOW_COLOR);
+	}
+	else if ((pSolarSysState->SysInfo.PlanetInfo.Weather + 1) >= (5))
+	{ /* Weather values >= 5 will unavoidably kill many crew,
+	   * draw the readout in red. */
+		OldColor = SetContextForeGroundColor (BRIGHT_RED_COLOR);
+	}
+#endif
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
+	SetContextForeGroundColor (OldColor);
 	t.baseline.y += SCAN_LEADING_PC;
 
 	PrintScanTitlePC (&t, &r, GAME_STRING (ORBITSCAN_STRING_BASE + 10),
@@ -245,9 +286,22 @@ PrintCoarseScanPC (void)
 				pSolarSysState->SysInfo.PlanetInfo.Tectonics + 1);
 		t.pStr = buf;
 	}
+#ifdef HAZARD_COLORS
+	if ((pSolarSysState->SysInfo.PlanetInfo.Tectonics + 1) >= (3) &&
+	    (pSolarSysState->SysInfo.PlanetInfo.Tectonics + 1) <= (5))
+	{ /* Between class 3 and 5 tectonics the planet is still explorable,
+	   * draw the readout in yellow. */
+		OldColor = SetContextForeGroundColor (DULL_YELLOW_COLOR);
+	}
+	else if ((pSolarSysState->SysInfo.PlanetInfo.Tectonics + 1) > (5))
+	{ /* Above class 5 tectonics the planet is quite dangerous, draw the
+	   * readout in red. */
+		OldColor = SetContextForeGroundColor (BRIGHT_RED_COLOR);
+	}
+#endif
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
-
+	SetContextForeGroundColor (OldColor);
 	t.baseline.y = SCAN_BASELINE_Y_PC;
 
 	PrintScanTitlePC (&t, &r, GAME_STRING (ORBITSCAN_STRING_BASE + 11),
@@ -312,19 +366,27 @@ PrintCoarseScanPC (void)
 static void
 PrintCoarseScan3DO (void)
 {
-#define SCAN_LEADING 19
+#define SCAN_LEADING (19 << RESOLUTION_FACTOR) // JMS_GFX
 	SDWORD val;
 	TEXT t;
 	STAMP s;
 	UNICODE buf[200];
 
+	/* We need this for the new color-changing hazard readouts.
+	 * We initialize it to SCAN_PC_TITLE_COLOR because we'll need
+	 * to reset the ContextForeGroundColor to this value whenever
+	 * we may have changed it - and having it always be set to a
+	 * sane value removes the need to only reset it conditionally.
+	 */
+	Color OldColor = (SCAN_PC_TITLE_COLOR);
+
 	GetPlanetTitle (buf, sizeof (buf));
 
 	SetContext (PlanetContext);
 
 	t.align = ALIGN_CENTER;
 	t.baseline.x = SIS_SCREEN_WIDTH >> 1;
-	t.baseline.y = 13;
+	t.baseline.y = (13 << RESOLUTION_FACTOR); // JMS_GFX
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 
@@ -333,13 +395,13 @@ PrintCoarseScan3DO (void)
 	font_DrawText (&t);
 
 	s.origin.x = s.origin.y = 0;
-	s.origin.x = 16 - SAFE_X;
+	s.origin.x = ((16 - SAFE_X) << RESOLUTION_FACTOR); // JMS_GFX
 	s.frame = SetAbsFrameIndex (SpaceJunkFrame, 20);
 	DrawStamp (&s);
 
-#define LEFT_SIDE_BASELINE_X (27 + (16 - SAFE_X))
+#define LEFT_SIDE_BASELINE_X ((27 + (16 - SAFE_X)) << RESOLUTION_FACTOR) // JMS_GFX
 #define RIGHT_SIDE_BASELINE_X (SIS_SCREEN_WIDTH - LEFT_SIDE_BASELINE_X)
-#define SCAN_BASELINE_Y 25
+#define SCAN_BASELINE_Y (25 << RESOLUTION_FACTOR) // JMS_GFX
 
 	t.baseline.x = LEFT_SIDE_BASELINE_X;
 	t.baseline.y = SCAN_BASELINE_Y;
@@ -348,7 +410,8 @@ PrintCoarseScan3DO (void)
 	t.pStr = buf;
 	val = ((pSolarSysState->SysInfo.PlanetInfo.PlanetToSunDist * 100L
 			+ (EARTH_RADIUS >> 1)) / EARTH_RADIUS);
-	MakeScanValue (buf, val, STR_EARTH_SIGN);
+	MakeScanValue (buf, val,
+			GAME_STRING (ORBITSCAN_STRING_BASE + 1)); // " a.u."
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING;
@@ -360,34 +423,77 @@ PrintCoarseScan3DO (void)
 	{
 		val = (pSolarSysState->SysInfo.PlanetInfo.AtmoDensity * 100
 				+ (EARTH_ATMOSPHERE >> 1)) / EARTH_ATMOSPHERE;
-		MakeScanValue (buf, val, STR_EARTH_SIGN);
+		MakeScanValue (buf, val,
+				GAME_STRING (ORBITSCAN_STRING_BASE + 5)); // " atm"
 	}
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING;
 
 	t.pStr = buf;
-	sprintf (buf, "%d" STR_DEGREE_SIGN,
+	sprintf (buf, "%d" STR_DEGREE_SIGN " c",
 			pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature);
+#ifdef HAZARD_COLORS
+	if ((pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature) >= (100) &&
+	    (pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature) <= (400))
+	{ /* Between 100 and 400 temperature the planet is still explorable,
+	   * draw the readout in yellow */
+		OldColor = SetContextForeGroundColor (DULL_YELLOW_COLOR);
+	}
+	else if (pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature > 400)
+	{ /* Above 400 the planet is quite dangerous, draw the readout in red. */
+		OldColor = SetContextForeGroundColor (BRIGHT_RED_COLOR);
+	}
+#endif
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
+	SetContextForeGroundColor (OldColor);
 	t.baseline.y += SCAN_LEADING;
 
 	t.pStr = buf;
-	sprintf (buf, "<%u>", pSolarSysState->SysInfo.PlanetInfo.AtmoDensity == 0
+	sprintf (buf, "%s %u", GAME_STRING (ORBITSCAN_STRING_BASE + 9), // Class
+			pSolarSysState->SysInfo.PlanetInfo.AtmoDensity == 0
 			? 0 : (pSolarSysState->SysInfo.PlanetInfo.Weather + 1));
+#ifdef HAZARD_COLORS
+	if ((pSolarSysState->SysInfo.PlanetInfo.Weather + 1) >= (3) &&
+	    (pSolarSysState->SysInfo.PlanetInfo.Weather + 1) <= (4))
+	{ /* Weather values of 3 or 4 will unavoidably kill a few
+	   * crew, draw the readout in yellow. */
+		OldColor = SetContextForeGroundColor (DULL_YELLOW_COLOR);
+	}
+	else if ((pSolarSysState->SysInfo.PlanetInfo.Weather + 1) >= (5))
+	{ /* Weather values < 5 will unavoidably kill many crew,
+	   * draw the readout in red. */
+		OldColor = SetContextForeGroundColor (BRIGHT_RED_COLOR);
+	}
+#endif
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
+	SetContextForeGroundColor (OldColor);
 	t.baseline.y += SCAN_LEADING;
 
 	t.pStr = buf;
-	sprintf (buf, "<%u>",
+	sprintf (buf, "%s %u", GAME_STRING (ORBITSCAN_STRING_BASE + 9), // Class
 			PLANSIZE (
 			pSolarSysState->SysInfo.PlanetInfo.PlanDataPtr->Type
 			) == GAS_GIANT
 			? 0 : (pSolarSysState->SysInfo.PlanetInfo.Tectonics + 1));
+#ifdef HAZARD_COLORS
+	if ((pSolarSysState->SysInfo.PlanetInfo.Tectonics + 1) >= (3) &&
+	    (pSolarSysState->SysInfo.PlanetInfo.Tectonics + 1) <= (5))
+	{ /* Between class 3 and 5 tectonics the planet is still explorable,
+	   * draw the readout in yellow. */
+		OldColor = SetContextForeGroundColor (DULL_YELLOW_COLOR);
+	}
+	else if ((pSolarSysState->SysInfo.PlanetInfo.Tectonics + 1) > (5))
+	{ /* Above class 5 tectonics the planet is quite dangerous, draw the
+	   * readout in red. */
+		OldColor = SetContextForeGroundColor (BRIGHT_RED_COLOR);
+	}
+#endif
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
+	SetContextForeGroundColor (OldColor);
 
 	t.baseline.x = RIGHT_SIDE_BASELINE_X;
 	t.baseline.y = SCAN_BASELINE_Y;
@@ -400,14 +506,16 @@ PrintCoarseScan3DO (void)
 			+ ((100L * 100L) >> 1)) / (100L * 100L);
 	if (val == 0)
 		val = 1;
-	MakeScanValue (buf, val, STR_EARTH_SIGN);
+	MakeScanValue (buf, val,
+			GAME_STRING (ORBITSCAN_STRING_BASE + 12)); // " e.s."
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING;
 
 	t.pStr = buf;
 	val = pSolarSysState->SysInfo.PlanetInfo.PlanetRadius;
-	MakeScanValue (buf, val, STR_EARTH_SIGN);
+	MakeScanValue (buf, val,
+			GAME_STRING (ORBITSCAN_STRING_BASE + 15)); // " g."
 
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
@@ -417,7 +525,8 @@ PrintCoarseScan3DO (void)
 	val = pSolarSysState->SysInfo.PlanetInfo.SurfaceGravity;
 	if (val == 0)
 		val = 1;
-	MakeScanValue (buf, val, STR_EARTH_SIGN);
+	MakeScanValue (buf, val,
+			GAME_STRING (ORBITSCAN_STRING_BASE + 17)); // " days"
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING;
@@ -434,7 +543,8 @@ PrintCoarseScan3DO (void)
 	t.pStr = buf;
 	val = (SDWORD)pSolarSysState->SysInfo.PlanetInfo.RotationPeriod
 			* 10 / 24;
-	MakeScanValue (buf, val, STR_EARTH_SIGN);
+	MakeScanValue (buf, val,
+			GAME_STRING (ORBITSCAN_STRING_BASE + 17)); // " days"
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 }
@@ -665,6 +775,8 @@ DoPickPlanetSide (MENU_STATE *pMS)
 	DWORD TimeIn = GetTimeCounter ();
 	BOOLEAN select, cancel;
 
+	POINT	new_pt;
+
 	select = PulsedInputState.menu[KEY_MENU_SELECT];
 	cancel = PulsedInputState.menu[KEY_MENU_CANCEL];
 	
@@ -686,9 +798,9 @@ DoPickPlanetSide (MENU_STATE *pMS)
 	}
 	else
 	{
-		SIZE dx = 0;
-		SIZE dy = 0;
-		POINT new_pt;
+		COUNT	i, j = 0; // JMS_GFX
+		SIZE	dx = 0;
+		SIZE	dy = 0;
 
 		new_pt = planetLoc;
 
@@ -701,37 +813,60 @@ DoPickPlanetSide (MENU_STATE *pMS)
 		if (CurrentInputState.menu[KEY_MENU_DOWN])
 			dy = 1;
 
-		BatchGraphics ();
+		// BatchGraphics ();
 
 		dx = dx << MAG_SHIFT;
-		if (dx)
-		{
-			new_pt.x += dx;
-			if (new_pt.x < 0)
-				new_pt.x += (MAP_WIDTH << MAG_SHIFT);
-			else if (new_pt.x >= (MAP_WIDTH << MAG_SHIFT))
-				new_pt.x -= (MAP_WIDTH << MAG_SHIFT);
-		}
 		dy = dy << MAG_SHIFT;
-		if (dy)
-		{
-			new_pt.y += dy;
-			if (new_pt.y < 0 || new_pt.y >= (MAP_HEIGHT << MAG_SHIFT))
-				new_pt.y = planetLoc.y;
-		}
 
-		if (!pointsEqual (new_pt, planetLoc))
+		// JMS_GFX: 1 for 320x240, 3 for 640x480, 7 for 1280x960
+		// XXX: This was good for debugging build, but too fast on opitmized release build.
+		//j = (1 << (RESOLUTION_FACTOR + 1)) - 1;
+		
+		// JMS_GFX: 1 for 320x240, 2 for 640x480, 4 for 1280x960
+		j = 1 << RESOLUTION_FACTOR;
+		
+		// JMS_GFX: This makes the scan cursor faster in hi-res modes.
+		// (Originally there was no loop, just the contents.)
+		for (i = 0; i < j; i++)
 		{
-			setPlanetLoc (new_pt, TRUE);
+			BatchGraphics ();
+			
+			if (dx)
+			{
+				new_pt.x += dx;
+				if (new_pt.x < 0)
+					new_pt.x += (MAP_WIDTH << MAG_SHIFT);
+				else if (new_pt.x >= (MAP_WIDTH << MAG_SHIFT))
+					new_pt.x -= (MAP_WIDTH << MAG_SHIFT);
+			}
+			
+			if (dy)
+			{
+				new_pt.y += dy;
+				if (new_pt.y < 0 || new_pt.y >= (MAP_HEIGHT << MAG_SHIFT))
+					new_pt.y = planetLoc.y;
+			}
+			
+			if (!pointsEqual (new_pt, planetLoc))
+				setPlanetLoc (new_pt, TRUE);
+			
+			flashPlanetLocation ();
+			
+			// JMS_GFX: Just upping the denominator wouldn't do no good since
+			// something else limits entering this function to about once per 1/40 secs...
+			// Since I couldn't find that mysterious element, I had to do speed things up
+			// with a loop and this thing here.
+			// XXX: Actually, with the optimized release build the best solution now seems is to keep all at 1/40th, but keep the loop...
+			if (RESOLUTION_FACTOR == 0)
+				SleepThreadUntil (TimeIn + ONE_SECOND / 40);
+			else if (RESOLUTION_FACTOR == 1)
+				SleepThreadUntil (TimeIn + ONE_SECOND / 40);
+			else
+				SleepThreadUntil (TimeIn + ONE_SECOND / 40);
+			
+			UnbatchGraphics ();
 		}
-
-		flashPlanetLocation ();
-
-		UnbatchGraphics ();
-
-		SleepThreadUntil (TimeIn + ONE_SECOND / 40);
 	}
-
 	return TRUE;
 }
 
@@ -937,9 +1072,9 @@ callPickupForScanType (SOLARSYS_STATE *s
 static void
 ScanPlanet (COUNT scanType)
 {
-#define SCAN_DURATION   (ONE_SECOND * 7 / 4)
+#define SCAN_DURATION   RES_CASE(ONE_SECOND * 7 / 4, ONE_SECOND * 7 / 4, ONE_SECOND * 12 / 4)
 // NUM_FLASH_COLORS for flashing blips; 1 for the final frame
-#define SCAN_LINES      (MAP_HEIGHT + NUM_FLASH_COLORS + 1)
+#define SCAN_LINES      (MAP_HEIGHT + NUM_FLASH_COLORS - 8)
 #define SCAN_LINE_WAIT  (SCAN_DURATION / SCAN_LINES)
 
 	COUNT startScan, endScan;
@@ -978,7 +1113,7 @@ ScanPlanet (COUNT scanType)
 		TimeCount TimeOut;
 
 		t.baseline.x = SIS_SCREEN_WIDTH >> 1;
-		t.baseline.y = SIS_SCREEN_HEIGHT - MAP_HEIGHT - 7;
+		t.baseline.y = SIS_SCREEN_HEIGHT - MAP_HEIGHT - (7 << RESOLUTION_FACTOR); // JMS_GFX
 		t.align = ALIGN_CENTER;
 		t.CharCount = (COUNT)~0;
 
@@ -986,12 +1121,12 @@ ScanPlanet (COUNT scanType)
 
 		SetContext (PlanetContext);
 		r.corner.x = 0;
-		r.corner.y = t.baseline.y - 10;
+		r.corner.y = t.baseline.y - (10 << RESOLUTION_FACTOR); // JMS_GFX
 		r.extent.width = SIS_SCREEN_WIDTH;
-		r.extent.height = t.baseline.y - r.corner.y + 1;
+		r.extent.height = t.baseline.y - r.corner.y + (1 << RESOLUTION_FACTOR); // JMS_GFX
 		// XXX: I do not know why we are repairing it here, as there
 		//   should not be anything drawn over the stars at the moment
-		RepairBackRect (&r);
+		RepairBackRect (&r, FALSE);
 
 		SetContextFont (MicroFont);
 		SetContextForeGroundColor (textColors[scan]);
@@ -1008,7 +1143,7 @@ ScanPlanet (COUNT scanType)
 
 		// Draw the scan slowly line by line
 		TimeOut = GetTimeCounter ();
-		for (i = 0; i < SCAN_LINES; i++)
+		for (i = 0; i < (SWORD)SCAN_LINES; i++)
 		{
 			TimeOut += SCAN_LINE_WAIT;
 			if (WaitForAnyButtonUntil (TRUE, TimeOut, FALSE))
@@ -1023,7 +1158,7 @@ ScanPlanet (COUNT scanType)
 #endif
 		}
 
-		if (i < SCAN_LINES)
+		if (i < (SWORD)SCAN_LINES)
 		{	// Aborted by a keypress; draw in finished state
 			BatchGraphics ();
 			DrawPlanet (SCAN_LINES - 1, tintColor);
@@ -1033,7 +1168,7 @@ ScanPlanet (COUNT scanType)
 	}
 
 	SetContext (PlanetContext);
-	RepairBackRect (&r);
+	RepairBackRect (&r, FALSE);
 
 	SetContext (ScanContext);
 	if (scanType == AUTO_SCAN)
@@ -1230,6 +1365,7 @@ generateBioNode (SOLARSYS_STATE *system,
 		BYTE *life_init_tab, COUNT creatureType)
 {
 	COUNT i;
+	DWORD j;
 
 	// NOTE: TFB_Random() calls here are NOT part of the deterministic planet
 	//   generation PRNG flow.
@@ -1237,10 +1373,15 @@ generateBioNode (SOLARSYS_STATE *system,
 	{
 		// Place moving creatures at a random location.
 		i = TFB_Random ();
-		NodeElementPtr->current.location.x =
-				(LOBYTE (i) % (MAP_WIDTH - (8 << 1))) + 8;
-		NodeElementPtr->current.location.y =
-				(HIBYTE (i) % (MAP_HEIGHT - (8 << 1))) + 8;
+		j = (DWORD)TFB_Random ();
+		
+		if (RESOLUTION_FACTOR == 0) {
+			NodeElementPtr->current.location.x = (LOBYTE (i) % (MAP_WIDTH - (8 << 1))) + 8;
+			NodeElementPtr->current.location.y = (HIBYTE (i) % (MAP_HEIGHT - (8 << 1))) + 8;
+		} else {
+			NodeElementPtr->current.location.x = (LOWORD (j) % (MAP_WIDTH - (8 << 1))) + 8;	// JMS_GFX: Replaced previous line with this line (BYTE was too small for 640x480 maps.)
+			NodeElementPtr->current.location.y = (HIWORD (j) % (MAP_HEIGHT - (8 << 1))) + 8;  // JMS_GFX: Replaced previous line with this line (BYTE was too small for 1280x960 maps.)
+		}
 	}
 
 	if (system->PlanetSideFrame[0] == 0)
diff -ruNp src.mm/uqm/planets/scan.h src/uqm/planets/scan.h
--- src.mm/uqm/planets/scan.h	2017-11-28 11:08:50 -0600
+++ src/uqm/planets/scan.h	2017-11-28 11:09:36 -0600
@@ -48,7 +48,7 @@ struct scan_block
 
 extern void ScanSystem (void);
 
-extern void RepairBackRect (RECT *pRect);
+extern void RepairBackRect (RECT *pRect, BOOLEAN Fullscreen);
 extern void GeneratePlanetSide (void);
 extern COUNT callGenerateForScanType (const SOLARSYS_STATE *,
 		const PLANET_DESC *world, COUNT node, BYTE scanType, NODE_INFO *);
diff -ruNp src.mm/uqm/planets/solarsys.c src/uqm/planets/solarsys.c
--- src.mm/uqm/planets/solarsys.c	2017-11-28 11:08:50 -0600
+++ src/uqm/planets/solarsys.c	2017-11-28 11:09:36 -0600
@@ -57,11 +57,14 @@
 
 #define IP_FRAME_RATE  (ONE_SECOND / 30)
 
+// BW: those do not depend on the resolution because numbers too small
+// cause crashes in the generation and rendering
 #define GENERATE_PLANET_DIAMETER (29 << 2)
 #define GENERATE_MOON_DIAMETER (7 << 2)
-#define GENERATE_PLANET_PERIMETER (GENERATE_PLANET_DIAMETER * MAP_WIDTH / MAP_HEIGHT)
-#define GENERATE_MOON_PERIMETER (GENERATE_MOON_DIAMETER * MAP_WIDTH / MAP_HEIGHT)
+#define GENERATE_PLANET_PERIMETER (GENERATE_PLANET_DIAMETER * ORIGINAL_MAP_WIDTH / ORIGINAL_MAP_HEIGHT)
+#define GENERATE_MOON_PERIMETER (GENERATE_MOON_DIAMETER * ORIGINAL_MAP_WIDTH / ORIGINAL_MAP_HEIGHT)
 
+static void AnimateSun (SIZE radius); // JMS
 static BOOLEAN DoIpFlight (SOLARSYS_STATE *pSS);
 static void DrawSystem (SIZE radius, BOOLEAN IsInnerSystem);
 static FRAME CreateStarBackGround (void);
@@ -232,11 +235,6 @@ GenerateMoons (SOLARSYS_STATE *system, P
 
 	RandomContext_SeedRandom (SysGenRNG, planet->rand_seed);
 
-	/*(*system->genFuncs->generateName) (system, planet);
-	(*system->genFuncs->generateMoons) (system, planet);
-
-	facing = NORMALIZE_FACING (ANGLE_TO_FACING (
-			ARCTAN (planet->location.x, planet->location.y)));*/
 	for (i = 0, pMoonDesc = &system->MoonDesc[0];
 			i < MAX_MOONS; ++i, ++pMoonDesc)
 	{
@@ -261,8 +259,6 @@ GenerateTexturedMoons (SOLARSYS_STATE *s
 	FRAME SurfFrame;
 	PLANET_DESC *pMoonDesc;
 
-	// RandomContext_SeedRandom (SysGenRNG, planet->rand_seed);
-
 	PLANET_DESC *previousOrbitalDesc;
 	previousOrbitalDesc = pSolarSysState->pOrbitalDesc;
 
@@ -338,22 +334,12 @@ GenerateTexturedMoons (SOLARSYS_STATE *s
 			pMoonDesc->orbit = pSolarSysState->Orbit;
 			PrepareNextRotationFrame (pMoonDesc, 0, FALSE);
 
-			// Clean up some parasitic use of pSolarSysState
-			//LockMutex (GraphicsLock);
-			// DestroyDrawable (ReleaseDrawable (pSolarSysState->Orbit.TintFrame));
-			// pSolarSysState->Orbit.TintFrame = 0;
-			// pSolarSysState->Orbit.TintColor = BLACK_COLOR;
-		
-			// DestroyDrawable (ReleaseDrawable (pSolarSysState->Orbit.TopoZoomFrame));
-			// pSolarSysState->Orbit.TopoZoomFrame = 0;
 			DestroyStringTable (ReleaseStringTable (pSolarSysState->XlatRef));
 			pSolarSysState->XlatRef = 0;
 			DestroyDrawable (ReleaseDrawable (pSolarSysState->TopoFrame));
 			pSolarSysState->TopoFrame = 0;
 			DestroyColorMap (ReleaseColorMap (pSolarSysState->OrbitalCMap));
 			pSolarSysState->OrbitalCMap = 0;
-			//UnlockMutex (GraphicsLock);
-			// End clean up
 		}
 	}
 	pSolarSysState->pOrbitalDesc = previousOrbitalDesc;
@@ -384,7 +370,23 @@ FreeIPData (void)
 void
 LoadIPData (void)
 {
-	SunFrame = CaptureDrawable (LoadGraphic (SUN_MASK_PMAP_ANIM));
+	if (RESOLUTION_FACTOR == 0) {
+		SunFrame = CaptureDrawable (LoadGraphic (SUN_MASK_PMAP_ANIM));
+	} else {
+		if (STAR_COLOR(CurStarDescPtr->Type) == BLUE_BODY)
+			SunFrame = CaptureDrawable (LoadGraphic (SUNBLUE_MASK_PMAP_ANIM));
+		else if (STAR_COLOR(CurStarDescPtr->Type) == GREEN_BODY)
+			SunFrame = CaptureDrawable (LoadGraphic (SUNGREEN_MASK_PMAP_ANIM));
+		else if (STAR_COLOR(CurStarDescPtr->Type) == ORANGE_BODY)
+			SunFrame = CaptureDrawable (LoadGraphic (SUNORANGE_MASK_PMAP_ANIM));
+		else if (STAR_COLOR(CurStarDescPtr->Type) == RED_BODY)
+			SunFrame = CaptureDrawable (LoadGraphic (SUNRED_MASK_PMAP_ANIM));
+		else if (STAR_COLOR(CurStarDescPtr->Type)== WHITE_BODY)
+			SunFrame = CaptureDrawable (LoadGraphic (SUNWHITE_MASK_PMAP_ANIM));
+		else if (STAR_COLOR(CurStarDescPtr->Type) == YELLOW_BODY)
+			SunFrame = CaptureDrawable (LoadGraphic (SUNYELLOW_MASK_PMAP_ANIM));
+	}
+
 	if (SpaceJunkFrame == 0)
 	{
 		SpaceJunkFrame = CaptureDrawable (LoadGraphic (IPBKGND_MASK_PMAP_ANIM));
@@ -573,13 +575,18 @@ LoadSolarSys (void)
 	PLANET_DESC *orbital = NULL;
 	PLANET_DESC *pCurDesc;
 #define NUM_TEMP_RANGES 5
-	static const Color temp_color_array[NUM_TEMP_RANGES] =
+	// JMS_GFX: Let's make the dark blue planet orbit dots a little
+	// more visible in 640x480 and 1280x960.
+	static const Color temp_color_array_1x[NUM_TEMP_RANGES] =
+	{
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x0E), 0x54),
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x06, 0x08), 0x62),
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x0B, 0x00), 0x6D),
+		BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x00, 0x00), 0x2D),
+		BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x08, 0x00), 0x75),
+	};
+	static const Color temp_color_array_2x4x[NUM_TEMP_RANGES] =
 	{
-		// BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x0E), 0x54),
-		// BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x06, 0x08), 0x62),
-		// BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x0B, 0x00), 0x6D),
-		// BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x00, 0x00), 0x2D),
-		// BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x08, 0x00), 0x75),
 		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x12), 0x54),
 		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x06, 0x08), 0x62),
 		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x0B, 0x00), 0x6D),
@@ -626,7 +633,12 @@ LoadSolarSys (void)
 			index = (SysInfo.PlanetInfo.SurfaceTemperature + 250) / 100;
 			if (index >= NUM_TEMP_RANGES)
 				index = NUM_TEMP_RANGES - 1;
-			pCurDesc->temp_color = temp_color_array[index];
+			// JMS_GFX: Let's make the dark blue planet orbit dots a little
+			// more visible in 640x480 and 1280x960.
+			if (RESOLUTION_FACTOR == 0)
+				pCurDesc->temp_color = temp_color_array_1x[index];
+			else
+				pCurDesc->temp_color = temp_color_array_2x4x[index];
 		}
 	}
 
@@ -1379,7 +1391,8 @@ CheckShipLocation (SIZE *newRadius)
 		return TRUE;
 	}
 
-	if (GLOBAL (autopilot.x) == ~0 && GLOBAL (autopilot.y) == ~0 && (ec < 60))
+	if (GLOBAL (autopilot.x) == ~0 && GLOBAL (autopilot.y) == ~0
+		&& (ec < 60 || RESOLUTION_FACTOR == 0))
 	{	// Not on autopilot -- may collide with a planet
 		PLANET_DESC *planet = CheckIntersect ();
 		if (planet)
@@ -1495,6 +1508,46 @@ RestoreSystemView (void)
 	DrawStamp (&s);
 }
 
+// JMS: This animates the truespace suns!
+#define SUN_ANIMFRAMES_NUM 32
+static void
+AnimateSun (SIZE radius)
+{
+	PLANET_DESC *pSunDesc = &pSolarSysState->SunDesc[0];
+	PLANET_DESC *pNearestPlanetDesc = &pSolarSysState->PlanetDesc[0];
+	static COUNT sunAnimIndex = 0;
+	COUNT zoomLevelIndex = 0;
+	
+	// Advance to the next frame.
+	sunAnimIndex++;
+	
+	// Go back to start of the anim after advancing past the last frame.
+	if (sunAnimIndex % SUN_ANIMFRAMES_NUM == 0)
+		sunAnimIndex = 0;
+	
+	// Zoom according to how close we are to the sun.
+	if (radius <= (MAX_ZOOM_RADIUS >> 1))
+	{
+		zoomLevelIndex += SUN_ANIMFRAMES_NUM;
+		if (radius <= (MAX_ZOOM_RADIUS >> 2))
+			zoomLevelIndex += SUN_ANIMFRAMES_NUM;
+	}
+	
+	// Tell the imageset which frame it should use.
+	pSunDesc->image.frame = SetRelFrameIndex (SunFrame, zoomLevelIndex + sunAnimIndex);
+	
+	// Draw the image.
+	DrawStamp (&pSunDesc->image);
+	
+	// BW: temporary workaround, drawing order will have to be redone anyway
+	if (!TEXTURED_PLANETS)
+	{
+		// Re-draw the image of the nearest planet, so the sun won't obscure it.
+		SetPlanetColorMap (pNearestPlanetDesc);
+		DrawStamp (&pNearestPlanetDesc->image);
+	}
+}
+
 static void
 CalcSunSize (PLANET_DESC *pSunDesc, SIZE radius)
 {
@@ -1509,7 +1562,11 @@ CalcSunSize (PLANET_DESC *pSunDesc, SIZE
 
 	pSunDesc->image.origin.x = SIS_SCREEN_WIDTH >> 1;
 	pSunDesc->image.origin.y = SIS_SCREEN_HEIGHT >> 1;
-	pSunDesc->image.frame = SetRelFrameIndex (SunFrame, index);
+	// JMS: Animating IP sun in hi-res modes...
+	if (RESOLUTION_FACTOR == 0)
+		pSunDesc->image.frame = SetRelFrameIndex (SunFrame, index);
+	else
+		pSunDesc->image.frame = SetRelFrameIndex (SunFrame, index * SUN_ANIMFRAMES_NUM);
 }
 
 static void
@@ -1675,7 +1732,6 @@ IP_frame (void)
 
 	GameClockTick ();
 	++frameCounter;
-	//frameCounter = frameCounter % 5; // (ONE_SECOND/IP_FRAME_RATE); // % 30
 	ProcessShipControls ();
 	
 	locChange = CheckShipLocation (&newRadius);
@@ -1725,6 +1781,10 @@ IP_frame (void)
 				DrawOuterPlanets (pSolarSysState->SunDesc[0].radius);
 			}
 		}
+		
+		// JMS: Animating IP sun in hi-res modes...
+		if (!playerInInnerSystem () && RESOLUTION_FACTOR != 0)
+			AnimateSun (newRadius);
 
 		RedrawQueue (FALSE);
 		DrawAutoPilotMessage (FALSE);
@@ -1854,19 +1914,25 @@ EnterPlanetOrbit (void)
 
 		if (worldIsMoon (pSolarSysState, pSolarSysState->pOrbitalDesc))
 		{	
-			// int moon;
+			int moon;
 			// Moon -- use its origin
 			// XXX: The conversion functions do not error-correct, so the
 			//   point we set here will change once flag_ship_preprocess()
 			//   in ipdisp.c starts over again.
 			GLOBAL (ShipStamp.origin) = pSolarSysState->pOrbitalDesc->image.origin;
-		}
-		else
-		{	// Planet -- its origin is for the outer view, so use mid-screen
+			// JMS_GFX: Draw the moon letter when orbiting a moon in 1280x960
+			// and 640x480 modes. Do not draw it in 320x240 since there's no room!
+			if (RESOLUTION_FACTOR > 0 && !(GetNamedPlanetaryBody()) && pSolarSysState->pOrbitalDesc->data_index != HIERARCHY_STARBASE)
+			{
+				moon = moonIndex (pSolarSysState, pSolarSysState->pOrbitalDesc);
+				snprintf ((GLOBAL_SIS (PlanetName)) + strlen(GLOBAL_SIS (PlanetName)), 3, "-%c%c", 'A' + moon, '\0');
+				DrawSISTitle (GLOBAL_SIS (PlanetName));
+			}
+		} else {	
+			// Planet -- its origin is for the outer view, so use mid-screen
 			GLOBAL (ShipStamp.origin.x) = SIS_SCREEN_WIDTH >> 1;
 			GLOBAL (ShipStamp.origin.y) = SIS_SCREEN_HEIGHT >> 1;
 		}
-	// }
 
 	GetPlanetInfo ();
 	(*pSolarSysState->genFuncs->generateOrbital) (pSolarSysState,
@@ -2183,14 +2249,15 @@ DrawStarBackGround (void)
 static FRAME
 CreateStarBackGround (void)
 {
-	COUNT i, j;
+	COUNT i, j, NumBRTDrawn;
 	DWORD rand_val;
 	STAMP s, nebula; // JMS (added that nebula there)
 	CONTEXT oldContext;
 	RECT clipRect;
 	FRAME frame;
 	BYTE numNebulae = 44;
-	COUNT NebulaePercent = CurStarDescPtr->star_pt.x % numNebulae;
+	COUNT NebulaePercentX = CurStarDescPtr->star_pt.x % numNebulae;
+	COUNT NebulaePercentY = CurStarDescPtr->star_pt.y % (numNebulae + 6);
 
 	// Use SpaceContext to find out the dimensions of the background
 	oldContext = SetContext (SpaceContext);
@@ -2223,11 +2290,18 @@ CreateStarBackGround (void)
 		}
 		s.frame = IncFrameIndex (s.frame);
 	}
+
+	// JMS
+	if (optNebulae && NebulaePercentY < numNebulae) { // MB: Make some system not have nebulae
+		NumBRTDrawn = RES_CASE(30, 98, 230); // JMS_GFX - Altered MB
+	} else {
+		NumBRTDrawn = RES_CASE(30, 121, 312); // JMS_GFX - Altered MB
+	}
+
 #define NUM_BRT_PIECES 8
 	for (i = 0; i < NUM_BRT_PIECES; ++i)
 	{
-#define NUM_BRT_DRAWN 30
-		for (j = 0; j < NUM_BRT_DRAWN; ++j)
+		for (j = 0; j < NumBRTDrawn; ++j)
 		{
 			rand_val = RandomContext_Random (SysGenRNG);
 			s.origin.x = LOWORD (rand_val) % SIS_SCREEN_WIDTH;
@@ -2238,13 +2312,13 @@ CreateStarBackGround (void)
 		s.frame = IncFrameIndex (s.frame);
 	}
 	
-	if (optNebulae && seroNebulaePresent && (CurStarDescPtr->star_pt.y % (numNebulae + 6)) < numNebulae){ // MB: Make some solar systems not have nebulae
+	if (optNebulae && seroNebulaePresent && NebulaePercentY < numNebulae){ // MB: Make some solar systems not have nebulae
 		nebula.origin.x = nebula.origin.y = 0;
-		nebula.frame = SetAbsFrameIndex (NebulaeFrame, NebulaePercent);
+		nebula.frame = SetAbsFrameIndex (NebulaeFrame, NebulaePercentX);
 		DrawStamp(&nebula);
 #ifdef DEBUG
 		// Prints out the frame number of the current system's nebula
-		printf("Nebula Frame: %d\n", NebulaePercent);
+		printf("Nebula Frame: %d\n", NebulaePercentX);
 #endif	
 	}
 
diff -ruNp src.mm/uqm/planets/surface.c src/uqm/planets/surface.c
--- src.mm/uqm/planets/surface.c	2017-11-28 11:08:51 -0600
+++ src/uqm/planets/surface.c	2017-11-28 11:09:36 -0600
@@ -230,10 +230,32 @@ void
 GenerateRandomLocation (POINT *loc)
 {
 	UWORD rand_val;
+	UWORD x, y; // JMS_GFX: Helpers.
 
 	rand_val = RandomContext_Random (SysGenRNG);
-	loc->x = 8 + LOBYTE (rand_val) % (MAP_WIDTH - (8 << 1));
-	loc->y = 8 + HIBYTE (rand_val) % (MAP_HEIGHT - (8 << 1));
+	// loc->x = 8 + LOBYTE (rand_val) % (MAP_WIDTH - (8 << 1));
+	// loc->y = 8 + HIBYTE (rand_val) % (MAP_HEIGHT - (8 << 1));
+
+	x = (LOBYTE (rand_val) % (ORIGINAL_MAP_WIDTH - (8 << 1)));
+	y = (HIBYTE (rand_val) % (ORIGINAL_MAP_HEIGHT - (8 << 1)));
+	
+	// JMS_GFX
+	x <<= RESOLUTION_FACTOR;
+	y <<= RESOLUTION_FACTOR;
+	loc->x = x;
+	loc->y = y;
+	
+	loc->x += 8 << RESOLUTION_FACTOR; // JMS_GFX
+	loc->y += 8 << RESOLUTION_FACTOR; // JMS_GFX
+	
+	// JMS_GFX: Compensate for 1280x960's different aspect ratio
+	if (RESOLUTION_FACTOR == 2)
+	{
+		DWORD xx = (DWORD)loc->x;
+		xx *= 111;
+		xx /= 100;
+		loc->x = (COUNT)xx;
+	}
 }
 
 // Returns:
diff -ruNp src.mm/uqm/process.c src/uqm/process.c
--- src.mm/uqm/process.c	2017-11-28 11:08:51 -0600
+++ src/uqm/process.c	2017-11-28 11:09:36 -0600
@@ -39,9 +39,9 @@
 
 COUNT DisplayFreeList;
 PRIMITIVE DisplayArray[MAX_DISPLAY_PRIMS];
-extern POINT SpaceOrg;
+extern DPOINT SpaceOrg;
 
-SIZE zoom_out = 1 << ZOOM_SHIFT;
+COUNT zoom_out = 1 << ZOOM_SHIFT;
 static SIZE opt_max_zoom_out;
 
 #if 0
@@ -204,7 +204,7 @@ PostProcess (ELEMENT *ElementPtr)
 }
 
 static COUNT
-CalcReduction (SIZE dx, SIZE dy)
+CalcReduction (SDWORD dx, SDWORD dy)
 {
 	COUNT next_reduction;
 
@@ -214,7 +214,7 @@ CalcReduction (SIZE dx, SIZE dy)
 
 	if (optMeleeScale == TFB_SCALE_STEP)
 	{
-		SIZE sdx, sdy;
+		SDWORD sdx, sdy;
 
 		if (LOBYTE (GLOBAL (CurrentActivity)) > IN_ENCOUNTER)
 			return (0);
@@ -232,8 +232,8 @@ CalcReduction (SIZE dx, SIZE dy)
 		if (next_reduction < zoom_out
 				&& zoom_out <= MAX_VIS_REDUCTION)
 		{
-#define HYSTERESIS_X DISPLAY_TO_WORLD(24)
-#define HYSTERESIS_Y DISPLAY_TO_WORLD(20)
+#define HYSTERESIS_X DISPLAY_TO_WORLD(24 << RESOLUTION_FACTOR) // JMS_GFX
+#define HYSTERESIS_Y DISPLAY_TO_WORLD(20 << RESOLUTION_FACTOR) // JMS_GFX
 		if (((sdx + HYSTERESIS_X)
 				<< (MAX_VIS_REDUCTION - next_reduction)) > TRANSITION_WIDTH
 				|| ((sdy + HYSTERESIS_Y)
@@ -281,23 +281,23 @@ CalcReduction (SIZE dx, SIZE dy)
 }
 
 static VIEW_STATE
-CalcView (POINT *pNewScrollPt, SIZE next_reduction,
-		SIZE *pdx, SIZE *pdy, COUNT ships_alive)
+CalcView (DPOINT *pNewScrollPt, SIZE next_reduction,
+		SDWORD *pdx, SDWORD *pdy, COUNT ships_alive)
 {
-	SIZE dx, dy;
+	SDWORD dx, dy;
 	VIEW_STATE view_state;
 
 #ifdef KDEBUG
 	log_add (log_Debug, "CalcView:");
 #endif
-	dx = ((COORD)(LOG_SPACE_WIDTH >> 1) - pNewScrollPt->x);
-	dy = ((COORD)(LOG_SPACE_HEIGHT >> 1) - pNewScrollPt->y);
+	dx = ((SDWORD)(LOG_SPACE_WIDTH >> 1) - pNewScrollPt->x);
+	dy = ((SDWORD)(LOG_SPACE_HEIGHT >> 1) - pNewScrollPt->y);
 	dx = WRAP_DELTA_X (dx);
 	dy = WRAP_DELTA_Y (dy);
 	if (ships_alive == 1)
 	{
-#define ORG_JUMP_X ((SIZE)DISPLAY_ALIGN(LOG_SPACE_WIDTH / 75))
-#define ORG_JUMP_Y ((SIZE)DISPLAY_ALIGN(LOG_SPACE_HEIGHT / 75))
+#define ORG_JUMP_X ((SDWORD)DISPLAY_ALIGN(LOG_SPACE_WIDTH / 75))
+#define ORG_JUMP_Y ((SDWORD)DISPLAY_ALIGN(LOG_SPACE_HEIGHT / 75))
 		if (dx > ORG_JUMP_X)
 			dx = ORG_JUMP_X;
 		else if (dx < -ORG_JUMP_X)
@@ -318,12 +318,8 @@ CalcView (POINT *pNewScrollPt, SIZE next
 	{
 		if (optMeleeScale == TFB_SCALE_STEP)
 		{
-			SpaceOrg.x = (COORD)(LOG_SPACE_WIDTH >> 1)
-					- (LOG_SPACE_WIDTH >> ((MAX_REDUCTION + 1)
-					- next_reduction));
-			SpaceOrg.y = (COORD)(LOG_SPACE_HEIGHT >> 1)
-					- (LOG_SPACE_HEIGHT >> ((MAX_REDUCTION + 1)
-					- next_reduction));
+			SpaceOrg.x = (SDWORD)(LOG_SPACE_WIDTH >> 1) - (LOG_SPACE_WIDTH >> ((MAX_REDUCTION + 1) - next_reduction));
+			SpaceOrg.y = (SDWORD)(LOG_SPACE_HEIGHT >> 1) - (LOG_SPACE_HEIGHT >> ((MAX_REDUCTION + 1) - next_reduction));
 		}
 		else
 		{
@@ -336,10 +332,9 @@ CalcView (POINT *pNewScrollPt, SIZE next
 				
 			// Always align the origin on a whole pixel to reduce the
 			// amount of object positioning jitter
-			SpaceOrg.x = DISPLAY_ALIGN((int)(LOG_SPACE_WIDTH >> 1) -
-					(LOG_SPACE_WIDTH * next_reduction / (MAX_ZOOM_OUT << 2)));
-			SpaceOrg.y = DISPLAY_ALIGN((int)(LOG_SPACE_HEIGHT >> 1) -
-					(LOG_SPACE_HEIGHT * next_reduction / (MAX_ZOOM_OUT << 2)));
+			SpaceOrg.x = DISPLAY_ALIGN((int)(LOG_SPACE_WIDTH >> 1) - (LOG_SPACE_WIDTH * next_reduction / (MAX_ZOOM_OUT << 2)));
+			SpaceOrg.y = DISPLAY_ALIGN((int)(LOG_SPACE_HEIGHT >> 1) - (LOG_SPACE_HEIGHT * next_reduction / (MAX_ZOOM_OUT << 2)));
+ 		
 		}
 		zoom_out = next_reduction;
 		view_state = VIEW_CHANGE;
@@ -627,11 +622,11 @@ ProcessCollisions (HELEMENT hSuccElement
 }
 
 static VIEW_STATE
-PreProcessQueue (SIZE *pscroll_x, SIZE *pscroll_y)
+PreProcessQueue (SDWORD *pscroll_x, SDWORD *pscroll_y)
 {
 	SIZE min_reduction, max_reduction;
 	COUNT sides_active;
-	POINT Origin;
+	DPOINT Origin;
 	HELEMENT hElement;
 	COUNT ships_alive;
 
@@ -646,8 +641,8 @@ PreProcessQueue (SIZE *pscroll_x, SIZE *
 	else
 		min_reduction = max_reduction = MAX_ZOOM_OUT + (1 << ZOOM_SHIFT);
 
-	Origin.x = (COORD)(LOG_SPACE_WIDTH >> 1);
-	Origin.y = (COORD)(LOG_SPACE_HEIGHT >> 1);
+	Origin.x = (SDWORD)(LOG_SPACE_WIDTH >> 1);
+	Origin.y = (SDWORD)(LOG_SPACE_HEIGHT >> 1);
 
 	hElement = GetHeadElement ();
 	ships_alive = 0;
@@ -669,7 +664,7 @@ PreProcessQueue (SIZE *pscroll_x, SIZE *
 
 		if (ElementPtr->state_flags & PLAYER_SHIP)
 		{
-			SIZE dx, dy;
+			SDWORD dx, dy;
 
 			ships_alive++;
 			if (max_reduction > opt_max_zoom_out
@@ -783,7 +778,7 @@ InsertPrim (PRIM_LINKS *pLinks, COUNT pr
 PRIM_LINKS DisplayLinks;
 
 static inline COORD
-CalcDisplayCoord (COORD c, COORD orgc, SIZE reduction)
+CalcDisplayCoord (SDWORD c, SDWORD orgc, SIZE reduction)
 {
 	if (optMeleeScale == TFB_SCALE_STEP)
 	{	/* old fixed-step zoom style */
@@ -796,10 +791,9 @@ CalcDisplayCoord (COORD c, COORD orgc, S
 }
 
 static void
-PostProcessQueue (VIEW_STATE view_state, SIZE scroll_x,
-		SIZE scroll_y)
+PostProcessQueue (VIEW_STATE view_state, SDWORD scroll_x, SDWORD scroll_y)
 {
-	POINT delta;
+	DPOINT delta;
 	SIZE reduction;
 	HELEMENT hElement;
 
@@ -889,35 +883,28 @@ PostProcessQueue (VIEW_STATE view_state,
 
 				if (ObjType == LINE_PRIM)
 				{
-					SIZE dx, dy;
-
-					dx = ElementPtr->next.location.x
-							- ElementPtr->current.location.x;
-					dy = ElementPtr->next.location.y
-							- ElementPtr->current.location.y;
-
-					next.x = WRAP_X (ElementPtr->current.location.x + delta.x);
-					next.y = WRAP_Y (ElementPtr->current.location.y + delta.y);
-					DisplayArray[ElementPtr->PrimIndex].Object.Line.first.x =
-							CalcDisplayCoord (next.x, SpaceOrg.x, reduction);
-					DisplayArray[ElementPtr->PrimIndex].Object.Line.first.y =
-							CalcDisplayCoord (next.y, SpaceOrg.y, reduction);
+					SDWORD dx, dy;
+					
+					dx = (SDWORD)ElementPtr->next.location.x - (SDWORD)ElementPtr->current.location.x;
+					dy = (SDWORD)ElementPtr->next.location.y - (SDWORD)ElementPtr->current.location.y;
+					
+					next.x = WRAP_X ((SDWORD)ElementPtr->current.location.x + (SDWORD)delta.x);
+					next.y = WRAP_Y ((SDWORD)ElementPtr->current.location.y + (SDWORD)delta.y);
+					DisplayArray[ElementPtr->PrimIndex].Object.Line.first.x = CalcDisplayCoord (next.x, SpaceOrg.x, reduction);
+					DisplayArray[ElementPtr->PrimIndex].Object.Line.first.y = CalcDisplayCoord (next.y, SpaceOrg.y, reduction);
 
 					next.x += dx;
 					next.y += dy;
-					DisplayArray[ElementPtr->PrimIndex].Object.Line.second.x =
-							CalcDisplayCoord (next.x, SpaceOrg.x, reduction);
-					DisplayArray[ElementPtr->PrimIndex].Object.Line.second.y =
-							CalcDisplayCoord (next.y, SpaceOrg.y, reduction);
+					DisplayArray[ElementPtr->PrimIndex].Object.Line.second.x = CalcDisplayCoord (next.x, SpaceOrg.x, reduction);
+					DisplayArray[ElementPtr->PrimIndex].Object.Line.second.y = CalcDisplayCoord (next.y, SpaceOrg.y, reduction);
 				}
 				else
 				{
-					next.x = WRAP_X (ElementPtr->next.location.x + delta.x);
-					next.y = WRAP_Y (ElementPtr->next.location.y + delta.y);
-					DisplayArray[ElementPtr->PrimIndex].Object.Point.x =
-							CalcDisplayCoord (next.x, SpaceOrg.x, reduction);
-					DisplayArray[ElementPtr->PrimIndex].Object.Point.y =
-							CalcDisplayCoord (next.y, SpaceOrg.y, reduction);
+					next.x = WRAP_X ((SDWORD)ElementPtr->next.location.x + (SDWORD)delta.x);
+					next.y = WRAP_Y ((SDWORD)ElementPtr->next.location.y + (SDWORD)delta.y);
+					
+					DisplayArray[ElementPtr->PrimIndex].Object.Point.x = CalcDisplayCoord (next.x, SpaceOrg.x, reduction);
+					DisplayArray[ElementPtr->PrimIndex].Object.Point.y = CalcDisplayCoord (next.y, SpaceOrg.y, reduction);
 
 					if (ObjType == STAMP_PRIM || ObjType == STAMPFILL_PRIM)
 					{
@@ -1012,7 +999,7 @@ UWORD nth_frame = 0;
 void
 RedrawQueue (BOOLEAN clear)
 {
-	SIZE scroll_x, scroll_y;
+	SDWORD scroll_x, scroll_y;
 	VIEW_STATE view_state;
 
 	SetContext (StatusContext);
diff -ruNp src.mm/uqm/races.h src/uqm/races.h
--- src.mm/uqm/races.h	2017-11-28 11:08:51 -0600
+++ src/uqm/races.h	2017-11-28 11:09:36 -0600
@@ -545,29 +545,29 @@ typedef enum
 
 #define LOG_TO_HYPER(s) (WORLD_TO_VELOCITY (s) >> 1)
 #define RACE_HYPER_SPEED \
-		LOG_TO_HYPER (40),  /* ARILOU_SHIP */ \
-		LOG_TO_HYPER (27),  /* CHMMR_SHIP */ \
-		LOG_TO_HYPER (24),  /* HUMAN_SHIP */ \
-		LOG_TO_HYPER (40),  /* ORZ_SHIP */ \
-		LOG_TO_HYPER (40),  /* PKUNK_SHIP */ \
-		LOG_TO_HYPER (35),  /* SHOFIXTI_SHIP */ \
-		LOG_TO_HYPER (48),  /* SPATHI_SHIP */ \
-		LOG_TO_HYPER (40),  /* SUPOX_SHIP */ \
-		LOG_TO_HYPER (50),  /* THRADDASH_SHIP */ \
-		LOG_TO_HYPER (30),  /* UTWIG_SHIP */ \
-		LOG_TO_HYPER (21),  /* VUX_SHIP */ \
-		LOG_TO_HYPER (30),  /* YEHAT_SHIP */ \
-		LOG_TO_HYPER (40),  /* MELNORME_SHIP */ \
-		LOG_TO_HYPER (20),  /* DRUUGE_SHIP */ \
-		LOG_TO_HYPER (25),  /* ILWRATH_SHIP */ \
-		LOG_TO_HYPER (27),  /* MYCON_SHIP */ \
-		LOG_TO_HYPER (60),  /* SLYLANDRO_SHIP */ \
-		LOG_TO_HYPER (18),  /* UMGAH_SHIP */ \
-		LOG_TO_HYPER (30),  /* URQUAN_SHIP */ \
-		LOG_TO_HYPER (40),  /* ZOQFOTPIK_SHIP */ \
-		LOG_TO_HYPER (36),  /* SYREEN_SHIP */ \
-		LOG_TO_HYPER (30),  /* BLACK_URQUAN_SHIP */ \
-		LOG_TO_HYPER (30),  /* YEHAT_REBEL_SHIP */
+		LOG_TO_HYPER (40 << RESOLUTION_FACTOR),  /* ARILOU_SHIP */ \
+		LOG_TO_HYPER (27 << RESOLUTION_FACTOR),  /* CHMMR_SHIP */ \
+		LOG_TO_HYPER (24 << RESOLUTION_FACTOR),  /* HUMAN_SHIP */ \
+		LOG_TO_HYPER (40 << RESOLUTION_FACTOR),  /* ORZ_SHIP */ \
+		LOG_TO_HYPER (40 << RESOLUTION_FACTOR),  /* PKUNK_SHIP */ \
+		LOG_TO_HYPER (35 << RESOLUTION_FACTOR),  /* SHOFIXTI_SHIP */ \
+		LOG_TO_HYPER (48 << RESOLUTION_FACTOR),  /* SPATHI_SHIP */ \
+		LOG_TO_HYPER (40 << RESOLUTION_FACTOR),  /* SUPOX_SHIP */ \
+		LOG_TO_HYPER (50 << RESOLUTION_FACTOR),  /* THRADDASH_SHIP */ \
+		LOG_TO_HYPER (30 << RESOLUTION_FACTOR),  /* UTWIG_SHIP */ \
+		LOG_TO_HYPER (21 << RESOLUTION_FACTOR),  /* VUX_SHIP */ \
+		LOG_TO_HYPER (30 << RESOLUTION_FACTOR),  /* YEHAT_SHIP */ \
+		LOG_TO_HYPER (40 << RESOLUTION_FACTOR),  /* MELNORME_SHIP */ \
+		LOG_TO_HYPER (20 << RESOLUTION_FACTOR),  /* DRUUGE_SHIP */ \
+		LOG_TO_HYPER (25 << RESOLUTION_FACTOR),  /* ILWRATH_SHIP */ \
+		LOG_TO_HYPER (27 << RESOLUTION_FACTOR),  /* MYCON_SHIP */ \
+		LOG_TO_HYPER (60 << RESOLUTION_FACTOR),  /* SLYLANDRO_SHIP */ \
+		LOG_TO_HYPER (18 << RESOLUTION_FACTOR),  /* UMGAH_SHIP */ \
+		LOG_TO_HYPER (30 << RESOLUTION_FACTOR),  /* URQUAN_SHIP */ \
+		LOG_TO_HYPER (40 << RESOLUTION_FACTOR),  /* ZOQFOTPIK_SHIP */ \
+		LOG_TO_HYPER (36 << RESOLUTION_FACTOR),  /* SYREEN_SHIP */ \
+		LOG_TO_HYPER (30 << RESOLUTION_FACTOR),  /* BLACK_URQUAN_SHIP */ \
+		LOG_TO_HYPER (30 << RESOLUTION_FACTOR),  /* YEHAT_REBEL_SHIP */
 
 #define RACE_HYPERSPACE_PERCENT \
 		20,  /* ARILOU_SHIP */ \
diff -ruNp src.mm/uqm/restart.c src/uqm/restart.c
--- src.mm/uqm/restart.c	2017-11-28 11:08:51 -0600
+++ src/uqm/restart.c	2017-11-28 11:09:36 -0600
@@ -41,6 +41,7 @@
 #include "libs/graphics/gfx_common.h"
 #include "libs/inplib.h"
 #include "libs/graphics/sdl/pure.h"
+#include "libs/log.h"
 #include "options.h"
 
 enum
@@ -94,14 +95,32 @@ DrawRestartMenuGraphic (MENU_STATE *pMS)
 	UnbatchGraphics ();
 }
 
+// JMS_GFX: The cleanup boolean can be used to avoid drawing a wrong-sized "Setup" flash overlay.
 static void
-DrawRestartMenu (MENU_STATE *pMS, BYTE NewState, FRAME f)
+DrawRestartMenu (MENU_STATE *pMS, BYTE NewState, FRAME f, BOOLEAN cleanup)
 {
 	POINT origin;
 	origin.x = 0;
 	origin.y = 0;
-	Flash_setOverlay(pMS->flashContext,
-			&origin, SetAbsFrameIndex (f, NewState + 1));
+	Flash_setOverlay (pMS->flashContext, &origin, SetAbsFrameIndex (f, NewState + 1), cleanup);
+}
+
+static void
+ResChanged (MENU_STATE *pMS) {	
+	SetFlashRect (NULL);
+	DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35));
+	// Got to restart -message
+	SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
+	SetTransitionSource (NULL);
+	BatchGraphics ();
+	DrawRestartMenuGraphic (pMS);
+	DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
+	ScreenTransition (3, NULL);
+	UnbatchGraphics ();
+	//fade_buf[0] = FadeAllToBlack;
+	//SleepThreadUntil (XFormColorMap ((COLORMAPPTR)fade_buf, ONE_SECOND / 2));
+	SleepThreadUntil (FadeScreen(FadeAllToBlack, ONE_SECOND / 2));
+	GLOBAL (CurrentActivity) = CHECK_ABORT;
 }
 
 static BOOLEAN
@@ -135,7 +154,7 @@ DoRestart (MENU_STATE *pMS)
 		Flash_setFrameTime (pMS->flashContext, ONE_SECOND / 16);
 		Flash_setState(pMS->flashContext, FlashState_fadeIn,
 				(3 * ONE_SECOND) / 16);
-		DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame);
+		DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
 		Flash_start (pMS->flashContext);
 		LastInputTime = GetTimeCounter ();
 		pMS->Initialized = TRUE;
@@ -153,20 +172,128 @@ DoRestart (MENU_STATE *pMS)
 	}
 	else if (PulsedInputState.menu[KEY_MENU_SELECT])
 	{
+		//BYTE fade_buf[1];
+		COUNT oldresfactor;
+		BOOLEAN packsInstalled;
+		
+		if (resolutionFactor == 0)
+			packsInstalled = TRUE;
+		else if (resolutionFactor == 1 && hires2xPackPresent)
+			packsInstalled = TRUE;
+		else if (resolutionFactor == 2 && hires4xPackPresent)
+			packsInstalled = TRUE;
+		else
+			packsInstalled = FALSE;
+
 		switch (pMS->CurState)
 		{
 			case LOAD_SAVED_GAME:
-				LastActivity = CHECK_LOAD;
-				GLOBAL (CurrentActivity) = IN_INTERPLANETARY;
+				if (resFactorWasChanged) {
+					SetFlashRect (NULL);
+					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35));
+					// Got to restart -message
+					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
+					SetTransitionSource (NULL);
+					BatchGraphics ();
+					DrawRestartMenuGraphic (pMS);
+					DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
+					ScreenTransition (3, NULL);
+					UnbatchGraphics ();
+					//fade_buf[0] = FadeAllToBlack;
+					//SleepThreadUntil (XFormColorMap ((COLORMAPPTR)fade_buf, ONE_SECOND / 2));
+					SleepThreadUntil (FadeScreen(FadeAllToBlack, ONE_SECOND / 2));
+					GLOBAL (CurrentActivity) = CHECK_ABORT;
+				} else if (!packsInstalled) {
+					Flash_pause(pMS->flashContext);
+					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35 + resolutionFactor));
+					// Could not find graphics pack - message
+					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
+					SetTransitionSource (NULL);
+					BatchGraphics ();
+					DrawRestartMenuGraphic (pMS);
+					DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
+					ScreenTransition (3, NULL);
+					UnbatchGraphics ();
+					Flash_continue(pMS->flashContext);
+					SleepThreadUntil (TimeIn + ONE_SECOND / 30);
+					return TRUE;
+				} else {
+					LastActivity = CHECK_LOAD;
+					GLOBAL (CurrentActivity) = IN_INTERPLANETARY;
+				}
 				break;
 			case START_NEW_GAME:
-				LastActivity = CHECK_LOAD | CHECK_RESTART;
-				GLOBAL (CurrentActivity) = IN_INTERPLANETARY;
+				if (resFactorWasChanged) {
+					SetFlashRect (NULL);
+					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35));
+					// Got to restart -message
+					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
+					SetTransitionSource (NULL);
+					BatchGraphics ();
+					DrawRestartMenuGraphic (pMS);
+					DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
+					ScreenTransition (3, NULL);
+					UnbatchGraphics ();
+					//fade_buf[0] = FadeAllToBlack;
+					//SleepThreadUntil (XFormColorMap ((COLORMAPPTR)fade_buf, ONE_SECOND / 2));
+					SleepThreadUntil (FadeScreen(FadeAllToBlack, ONE_SECOND / 2));
+					GLOBAL (CurrentActivity) = CHECK_ABORT;
+				} else if (!packsInstalled) {
+					Flash_pause(pMS->flashContext);
+					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35 + resolutionFactor));
+					// Could not find graphics pack - message
+					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
+					SetTransitionSource (NULL);
+					BatchGraphics ();
+					DrawRestartMenuGraphic (pMS);
+					DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
+					ScreenTransition (3, NULL);
+					UnbatchGraphics ();
+					Flash_continue(pMS->flashContext);
+					SleepThreadUntil (TimeIn + ONE_SECOND / 30);
+					return TRUE;
+				}
+				else
+				{
+					LastActivity = CHECK_LOAD | CHECK_RESTART;
+					GLOBAL (CurrentActivity) = IN_INTERPLANETARY;
+				}	
 				break;
 			case PLAY_SUPER_MELEE:
-				GLOBAL (CurrentActivity) = SUPER_MELEE;
+				if (resFactorWasChanged) {
+					SetFlashRect (NULL);
+					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35));
+					// Got to restart -message
+					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
+					SetTransitionSource (NULL);
+					BatchGraphics ();
+					DrawRestartMenuGraphic (pMS);
+					DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
+					ScreenTransition (3, NULL);
+					UnbatchGraphics ();
+					//fade_buf[0] = FadeAllToBlack;
+					//SleepThreadUntil (XFormColorMap ((COLORMAPPTR)fade_buf, ONE_SECOND / 2));
+					SleepThreadUntil (FadeScreen(FadeAllToBlack, ONE_SECOND / 2));
+					GLOBAL (CurrentActivity) = CHECK_ABORT;
+				} else if (!packsInstalled) {
+					Flash_pause(pMS->flashContext);
+					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35 + resolutionFactor));
+					// Could not find graphics pack - message
+					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
+					SetTransitionSource (NULL);
+					BatchGraphics ();
+					DrawRestartMenuGraphic (pMS);
+					DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
+					ScreenTransition (3, NULL);
+					UnbatchGraphics ();
+					Flash_continue(pMS->flashContext);
+					SleepThreadUntil (TimeIn + ONE_SECOND / 30);
+					return TRUE;
+				} else
+					GLOBAL (CurrentActivity) = SUPER_MELEE;
 				break;
 			case SETUP_GAME:
+				oldresfactor = resolutionFactor;
 				Flash_pause(pMS->flashContext);
 				Flash_setState(pMS->flashContext, FlashState_fadeIn,
 						(3 * ONE_SECOND) / 16);
@@ -179,7 +306,11 @@ DoRestart (MENU_STATE *pMS)
 				BatchGraphics ();
 				DrawRestartMenuGraphic (pMS);
 				ScreenTransition (3, NULL);
-				DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame);
+				// JMS_GFX: This prevents drawing an annoying wrong-sized "Setup" frame when changing resolution. 
+				if (oldresfactor < resolutionFactor)
+					DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, TRUE);
+				
+				DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
 				Flash_continue(pMS->flashContext);
 				UnbatchGraphics ();
 				return TRUE;
@@ -216,7 +347,7 @@ DoRestart (MENU_STATE *pMS)
 		if (NewState != pMS->CurState)
 		{
 			BatchGraphics ();
-			DrawRestartMenu (pMS, NewState, pMS->CurFrame);
+			DrawRestartMenu (pMS, NewState, pMS->CurFrame, FALSE);
 			UnbatchGraphics ();
 			pMS->CurState = NewState;
 		}
@@ -237,7 +368,7 @@ DoRestart (MENU_STATE *pMS)
 		SetTransitionSource (NULL);
 		BatchGraphics ();
 		DrawRestartMenuGraphic (pMS);
-		DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame);
+		DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
 		ScreenTransition (3, NULL);
 		UnbatchGraphics ();
 		Flash_continue(pMS->flashContext);
@@ -246,9 +377,13 @@ DoRestart (MENU_STATE *pMS)
 	}
 	else
 	{	// No input received, check if timed out
-		if (GetTimeCounter () - LastInputTime > InactTimeOut)
+		// JMS: After changing resolution mode, prevent displaying credits
+		// (until the next time the game is restarted). This is to prevent
+		// showing the credits with the wrong resolution mode's font&background.
+		if (GetTimeCounter () - LastInputTime > InactTimeOut
+			&& !resFactorWasChanged)
 		{
-			SleepThreadUntil (FadeMusic (0, ONE_SECOND));
+			SleepThreadUntil (FadeMusic (0, ONE_SECOND/2));
 			StopMusic ();
 			FadeMusic (NORMAL_VOLUME, 0);
 
@@ -313,7 +448,35 @@ RestartMenu (MENU_STATE *pMS)
 	if (TimeOut == ONE_SECOND / 8)
 		SleepThread (ONE_SECOND * 3);
 
-	pMS->CurFrame = CaptureDrawable (LoadGraphic (RESTART_PMAP_ANIM));
+	//DC: Load the different menus depending on the resolution factor
+	if (resolutionFactor < 1)
+		pMS->CurFrame = CaptureDrawable (LoadGraphic (RESTART_PMAP_ANIM));
+	if (resolutionFactor == 1)
+		pMS->CurFrame = CaptureDrawable (LoadGraphic (RESTART_PMAP_ANIM2x));
+	if (resolutionFactor > 1)
+		pMS->CurFrame = CaptureDrawable (LoadGraphic (RESTART_PMAP_ANIM4x));
+
+	// Re-load the info box font so the text shows in correct size after changing the resolution.
+	if (resFactorWasChanged)
+	{	
+		DestroyFont (StarConFont);
+		
+		if (resolutionFactor < 1)
+			StarConFont = LoadFont (FALLBACK_TO1X_FONT);
+		if (resolutionFactor == 1)
+			StarConFont = LoadFont (FALLBACK_TO2X_FONT);
+		if (resolutionFactor > 1)
+			StarConFont = LoadFont (FALLBACK_TO4X_FONT);
+		
+		DestroyFont (TinyFont);
+		
+		if (resolutionFactor < 1)
+			TinyFont = LoadFont (TINY_FALLBACK_TO1X_FONT);
+		if (resolutionFactor == 1)
+			TinyFont = LoadFont (TINY_FALLBACK_TO2X_FONT);
+		if (resolutionFactor > 1)
+			TinyFont = LoadFont (TINY_FALLBACK_TO4X_FONT);
+	}
 
 	DrawRestartMenuGraphic (pMS);
 	GLOBAL (CurrentActivity) &= ~CHECK_ABORT;
diff -ruNp src.mm/uqm/save.c src/uqm/save.c
--- src.mm/uqm/save.c	2017-11-28 11:08:51 -0600
+++ src/uqm/save.c	2017-11-28 11:09:37 -0600
@@ -698,6 +698,25 @@ const GameStateBitMap gameStateBitMap[]
 	{ "COLONY_GRPOFFS", 32 },
 	{ "SAMATRA_GRPOFFS", 32 },
 	
+	{ "AUTOPILOT_OK", 1 },
+	
+	{ "KNOW_QS_PORTAL_0", 1 },
+	{ "KNOW_QS_PORTAL_1", 1 },
+	{ "KNOW_QS_PORTAL_2", 1 },
+	{ "KNOW_QS_PORTAL_3", 1 },
+	{ "KNOW_QS_PORTAL_4", 1 },
+	{ "KNOW_QS_PORTAL_5", 1 },
+	{ "KNOW_QS_PORTAL_6", 1 },
+	{ "KNOW_QS_PORTAL_7", 1 },
+	{ "KNOW_QS_PORTAL_8", 1 },
+	{ "KNOW_QS_PORTAL_9", 1 },
+	{ "KNOW_QS_PORTAL_10", 1 },
+	{ "KNOW_QS_PORTAL_11", 1 },
+	{ "KNOW_QS_PORTAL_12", 1 },
+	{ "KNOW_QS_PORTAL_13", 1 },
+	{ "KNOW_QS_PORTAL_14", 1 },
+	{ "KNOW_QS_PORTAL_15", 1 },
+	
 	{ NULL, 0 },
 };
 
@@ -924,8 +943,8 @@ SaveEncounters (uio_Stream *fh)
 		}
 
 		// Save the stuff after the BRIEF_SHIP_INFO array
-		write_32  (fh, EncounterPtr->log_x);
-		write_32  (fh, EncounterPtr->log_y);
+		write_32  (fh, ((EncounterPtr->log_x) >> RESOLUTION_FACTOR));
+		write_32  (fh, ((EncounterPtr->log_y) >> RESOLUTION_FACTOR));
 
 		UnlockEncounter (hEncounter);
 		hEncounter = hNextEncounter;
@@ -979,6 +998,13 @@ SaveClockState (const CLOCK_STATE *Clock
 static BOOLEAN
 SaveGameState (const GAME_STATE *GSPtr, uio_Stream *fh)
 {
+	BYTE res_scale; // JMS
+
+	if (LOBYTE (GSPtr->CurrentActivity) != IN_INTERPLANETARY)
+		res_scale = RESOLUTION_FACTOR; 
+	else
+		res_scale = 0;
+
 	write_32  (fh, GLOBAL_STATE_TAG);
 	write_32  (fh, 75);
 	write_8   (fh, GSPtr->glob_flags);
@@ -995,22 +1021,22 @@ SaveGameState (const GAME_STATE *GSPtr,
 	write_16  (fh, GSPtr->ip_location.x);
 	write_16  (fh, GSPtr->ip_location.y);
 	/* STAMP ShipStamp */
-	write_16  (fh, GSPtr->ShipStamp.origin.x);
-	write_16  (fh, GSPtr->ShipStamp.origin.y);
+	write_16  (fh, (GSPtr->ShipStamp.origin.x >> RESOLUTION_FACTOR));
+	write_16  (fh, (GSPtr->ShipStamp.origin.y >> RESOLUTION_FACTOR));
 	write_16  (fh, GSPtr->ShipFacing);
 	write_8   (fh, GSPtr->ip_planet);
 	write_8   (fh, GSPtr->in_orbit);
 
 	/* VELOCITY_DESC velocity */
-	write_16  (fh, GSPtr->velocity.TravelAngle);
-	write_16  (fh, GSPtr->velocity.vector.width);
-	write_16  (fh, GSPtr->velocity.vector.height);
-	write_16  (fh, GSPtr->velocity.fract.width);
-	write_16  (fh, GSPtr->velocity.fract.height);
-	write_16  (fh, GSPtr->velocity.error.width);
-	write_16  (fh, GSPtr->velocity.error.height);
-	write_16  (fh, GSPtr->velocity.incr.width);
-	write_16  (fh, GSPtr->velocity.incr.height);
+	write_16  (fh, GSPtr->velocity.TravelAngle >> res_scale);
+	write_16  (fh, GSPtr->velocity.vector.width >> res_scale);
+	write_16  (fh, GSPtr->velocity.vector.height >> res_scale);
+	write_16  (fh, GSPtr->velocity.fract.width >> res_scale);
+	write_16  (fh, GSPtr->velocity.fract.height >> res_scale);
+	write_16  (fh, GSPtr->velocity.error.width >> res_scale);
+	write_16  (fh, GSPtr->velocity.error.height >> res_scale);
+	write_16  (fh, GSPtr->velocity.incr.width >> res_scale);
+	write_16  (fh, GSPtr->velocity.incr.height >> res_scale);
 
 	/* The Game state bits. Vanilla UQM uses 155 bytes here at
 	 * present. Only the first 99 bytes are significant, though;
@@ -1035,8 +1061,8 @@ SaveGameState (const GAME_STATE *GSPtr,
 static void
 SaveSisState (const SIS_STATE *SSPtr, void *fp)
 {
-	write_32  (fp, SSPtr->log_x);
-	write_32  (fp, SSPtr->log_y);
+	write_32  (fp, ((SSPtr->log_x) >> RESOLUTION_FACTOR));
+	write_32  (fp, ((SSPtr->log_y) >> RESOLUTION_FACTOR));
 	write_32  (fp, SSPtr->ResUnits);
 	write_32  (fp, SSPtr->FuelOnBoard);
 	write_16  (fp, SSPtr->CrewEnlisted);
@@ -1074,6 +1100,7 @@ SaveSummary (const SUMMARY_DESC *SummPtr
 	write_a8 (fp, SummPtr->ShipList, MAX_BUILT_SHIPS);
 	write_a8 (fp, SummPtr->DeviceList, MAX_EXCLUSIVE_DEVICES);
 	write_a8 (fp, SummPtr->SaveName, strlen(SummPtr->SaveName));
+	write_8  (fp, SummPtr->res_factor);
 }
 
 /* Save the Star Description chunk. This is not to be confused with
@@ -1152,6 +1179,7 @@ PrepareSummary (SUMMARY_DESC *SummPtr, c
 	SummPtr->year_index = GLOBAL (GameClock.year_index);
 	SummPtr->SaveName[SAVE_NAME_SIZE-1] = 0;
 	strncpy (SummPtr->SaveName, name, SAVE_NAME_SIZE-1);
+	SummPtr->res_factor = RESOLUTION_FACTOR;
 }
 
 static void
@@ -1190,10 +1218,10 @@ SaveProblemMessage (STAMP *MsgStamp)
 			- r.corner.x;
 	t.baseline.y = ((SIS_SCREEN_HEIGHT >> 1) - (r.extent.height >> 1))
 			- r.corner.y;
-	r.corner.x += t.baseline.x - 4;
-	r.corner.y += t.baseline.y - 4;
-	r.extent.width += 8;
-	r.extent.height += 8;
+	r.corner.x += t.baseline.x - (4 << RESOLUTION_FACTOR);
+	r.corner.y += t.baseline.y - (4 << RESOLUTION_FACTOR);
+	r.extent.width += (8 << RESOLUTION_FACTOR);
+	r.extent.height += (8 << RESOLUTION_FACTOR);
 
 	*MsgStamp = SaveContextFrame (&r);
 
diff -ruNp src.mm/uqm/save.h src/uqm/save.h
--- src.mm/uqm/save.h	2017-11-28 11:08:51 -0600
+++ src/uqm/save.h	2017-11-28 11:09:37 -0600
@@ -61,12 +61,14 @@ typedef struct
 	BYTE ShipList[MAX_BUILT_SHIPS];
 	BYTE DeviceList[MAX_EXCLUSIVE_DEVICES];
 	UNICODE SaveName[SAVE_NAME_SIZE];
+	BYTE res_factor;	// JMS: Stores resolution factor to enable saving/loading from different res modes.
 } SUMMARY_DESC;
 
 extern ACTIVITY NextActivity;
 
-extern BOOLEAN LoadGame (COUNT which_game, SUMMARY_DESC *summary_desc);
+extern BOOLEAN LoadGame (COUNT which_game, SUMMARY_DESC *summary_desc, BOOLEAN TryVanilla);
 extern BOOLEAN LoadLegacyGame (COUNT which_game, SUMMARY_DESC *summary_desc);
+extern void LoadProblemMessage ();
 
 extern void SaveProblem (void);
 extern BOOLEAN SaveGame (COUNT which_game, SUMMARY_DESC *summary_desc, const char *name);
diff -ruNp src.mm/uqm/setup.c src/uqm/setup.c
--- src.mm/uqm/setup.c	2017-11-28 11:08:51 -0600
+++ src/uqm/setup.c	2017-11-28 11:09:37 -0600
@@ -64,6 +64,7 @@ FRAME ActivityFrame;
 FRAME StatusFrame;
 FRAME SubmenuFrame;
 FRAME ConstellationsFrame; // JMS
+FRAME hyperspacesuns; // BW
 FRAME NebulaeFrame; // JMS
 FRAME FlagStatFrame;
 FRAME MiscDataFrame;
@@ -73,6 +74,10 @@ QUEUE disp_q;
 // Serosis
 BOOLEAN solTexturesPresent;
 BOOLEAN seroNebulaePresent;
+BOOLEAN seroMenuPresent;
+// JMS_GFX
+BOOLEAN hires2xPackPresent;
+BOOLEAN hires4xPackPresent;
 
 uio_Repository *repository;
 uio_DirHandle *rootDir;
@@ -121,22 +126,56 @@ LoadKernel (int argc, char *argv[])
 		return FALSE; // Must have at least one index in content dir
 
 	/* Load addons demanded by the current configuration. */
-	if(loadAddon("sero-setup-080")){
+	if(loadAddon("sero-setup-080-hd")){
 		printf("Loading Sero-Setup \n");
 		log_add (log_Debug, "loading sero-setup-080\n");
 	} else {
 		log_add (log_Fatal, "\nPANIC: Sero Setup not found in addons directory!\n");
 		exit (EXIT_FAILURE);
  	}
-	if(loadAddon("sero-nebulae-1x")){
-		seroNebulaePresent = TRUE;
-		printf("Loading Sero-Nebulae \n");
-		log_add (log_Debug, "loading sero-nebulae-1x");
-	}
-	if(loadAddon("sol-textures-1x")){
-		solTexturesPresent = TRUE;
-		printf("Loading Sol Textures \n");
-		log_add (log_Debug, "loading sol-textures-1x");
+
+	switch (resolutionFactor) {
+		case 1:
+			if(loadAddon ("hires2x")){
+				hires2xPackPresent = TRUE;
+				log_add (log_Debug, "loading addon hires2x");
+				if(loadAddon("sero-menu-2x")){
+					seroMenuPresent = TRUE;
+					printf("Loading Sero-Menu 2x\n");
+					log_add (log_Debug, "loading sero-menu-2x");
+				}
+				loadAddon("Syreen2xVideoFix");
+			}
+			break;
+		case 2:
+			if(loadAddon ("hires4x")){
+				hires4xPackPresent = TRUE;
+				log_add (log_Debug, "loading addon hires4x");
+				if(loadAddon("sero-menu-4x")){
+					seroMenuPresent = TRUE;
+					printf("Loading Sero-Menu 4x\n");
+					log_add (log_Debug, "loading sero-menu-4x");
+				}
+				loadAddon("Syreen4xVideoFix");
+			}
+			break;
+		case 0:
+		default:
+			if(loadAddon("vux-fix-1x")){
+				printf("Loading Vux-Fix 1x\n");
+				log_add (log_Debug, "loading vux-fix-1x");
+			}
+			if(loadAddon("sero-content-1x")){
+				seroNebulaePresent = TRUE;
+				printf("Loading Sero-Content \n");
+				log_add (log_Debug, "loading sero-content-1x");
+			}
+			if(loadAddon("sol-textures-1x")){
+				solTexturesPresent = TRUE;
+				printf("Loading Sol Textures \n");
+				log_add (log_Debug, "loading sol-textures-1x");
+			}
+			break;
 	}
 
 	if (opt3doMusic)
@@ -239,8 +278,15 @@ InitKernel (void)
 	StatusFrame = CaptureDrawable (LoadGraphic (STATUS_MASK_PMAP_ANIM));
 	if (StatusFrame == NULL)
 		return FALSE;
+	
+	// JMS: Animated hyperspace suns.
+	if (hires4xPackPresent || hires2xPackPresent) { 
+		hyperspacesuns = CaptureDrawable (LoadGraphic (HYPERSUNS_MASK_PMAP_ANIM));
+		if (hyperspacesuns == NULL)
+			return FALSE;
+	}
 
-	if (optNebulae && seroNebulaePresent) {
+	if (optNebulae && (seroNebulaePresent || hires4xPackPresent || hires2xPackPresent)) {
 		NebulaeFrame = CaptureDrawable (LoadGraphic (NEBULAE_PMAP_ANIM));
 		if (NebulaeFrame == NULL)
 			return FALSE;
diff -ruNp src.mm/uqm/setup.h src/uqm/setup.h
--- src.mm/uqm/setup.h	2017-11-28 11:08:51 -0600
+++ src/uqm/setup.h	2017-11-28 11:09:37 -0600
@@ -36,6 +36,7 @@ extern FRAME StatusFrame;
 extern FRAME SubmenuFrame; // JMS
 extern FRAME ConstellationsFrame; // JMS
 extern FRAME NebulaeFrame;	// JMS
+extern FRAME hyperspacesuns;	// BW
 extern FRAME FlagStatFrame;
 extern FRAME MiscDataFrame;
 extern FRAME FontGradFrame;
@@ -63,6 +64,8 @@ extern QUEUE race_q[];
 // Serosis
 extern BOOLEAN solTexturesPresent;
 extern BOOLEAN seroNebulaePresent;
+extern BOOLEAN hires2xPackPresent; // JMS
+extern BOOLEAN hires4xPackPresent; // JMS
 
 extern ACTIVITY LastActivity;
 
diff -ruNp src.mm/uqm/setupmenu.c src/uqm/setupmenu.c
--- src.mm/uqm/setupmenu.c	2017-11-28 11:08:51 -0600
+++ src/uqm/setupmenu.c	2017-11-28 11:09:37 -0600
@@ -38,6 +38,8 @@
 #include "resinst.h"
 #include "nameref.h"
 #include <math.h>
+#include "gamestr.h"
+#include "libs/graphics/bbox.h"
 
 
 static STRING SetupTab;
@@ -69,13 +71,13 @@ static void rebind_control (WIDGET_CONTR
 static void clear_control (WIDGET_CONTROLENTRY *widget);
 
 #ifdef HAVE_OPENGL
-#define RES_OPTS 4
+#define RES_OPTS 3
 #else
-#define RES_OPTS 2
+#define RES_OPTS 3
 #endif
 
 #define MENU_COUNT          8
-#define CHOICE_COUNT       43
+#define CHOICE_COUNT       44
 #define SLIDER_COUNT        4
 #define BUTTON_COUNT       10
 #define LABEL_COUNT         4
@@ -100,7 +102,7 @@ static int choice_widths[CHOICE_COUNT] =
 	2, 2, 3, 2, 2, 3, 3, 2,	3, 3, 
 	3, 2, 2, 2, 
 	2, 2, 3, 2, 2, 2, 2, 2, 2, 2,
-	2, 2, 2, 2, 3, 2, 2, 2, 2 };
+	2, 2, 2, 2, 3, 2, 2, 2, 2, 3 };
 
 static HANDLER button_handlers[BUTTON_COUNT] = {
 	quit_main_menu, quit_sub_menu, do_graphics, do_engine,
@@ -121,6 +123,7 @@ static WIDGET *main_widgets[] = {
 
 static WIDGET *graphics_widgets[] = {
 	(WIDGET *)(&choices[0]),	// Resolution
+	(WIDGET *)(&choices[43]),	// Scale GFX
 #ifdef HAVE_OPENGL
 	(WIDGET *)(&choices[1]),	// Use Framebuffer
 #endif
@@ -405,14 +408,14 @@ SetDefaults (void)
 	GLOBALOPTS opts;
 	
 	GetGlobalOptions (&opts);
-	if (opts.screenResolution == OPTVAL_CUSTOM)
+	/*if (opts.screenResolution == OPTVAL_CUSTOM)
 	{
 		choices[0].numopts = RES_OPTS + 1;
 	}
 	else
-	{
+	{*/
 		choices[0].numopts = RES_OPTS;
-	}
+	//}
 	choices[0].selected = opts.screenResolution;
 	choices[1].selected = opts.driver;
 	choices[2].selected = opts.scaler;
@@ -460,7 +463,8 @@ SetDefaults (void)
 	choices[39].selected = opts.infiniteFuel;
 	choices[40].selected = opts.thraddStory;
 	choices[41].selected = opts.partialPickup;
-	choices[42].selected = opts.submenu;
+	choices[42].selected = opts.submenu;	
+	choices[43].selected = opts.loresBlowup; // JMS
 
 	sliders[0].value = opts.musicvol;
 	sliders[1].value = opts.sfxvol;
@@ -519,6 +523,7 @@ PropagateResults (void)
 	opts.thraddStory = choices[40].selected;
 	opts.partialPickup = choices[41].selected;
 	opts.submenu = choices[42].selected;
+	opts.loresBlowup = choices[43].selected; // JMS
 
 	opts.musicvol = sliders[0].value;
 	opts.sfxvol = sliders[1].value;
@@ -858,9 +863,15 @@ init_widgets (void)
 		bank = StringBank_Create ();
 	}
 	
-	if (setup_frame == NULL)
+	if (setup_frame == NULL || resFactorWasChanged)
 	{
-		setup_frame = CaptureDrawable (LoadGraphic (MENUBKG_PMAP_ANIM));
+		// JMS: Load the different menus depending on the resolution factor.
+		if (resolutionFactor < 1)
+			setup_frame = CaptureDrawable (LoadGraphic (MENUBKG_PMAP_ANIM));
+		if (resolutionFactor == 1)
+			setup_frame = CaptureDrawable (LoadGraphic (MENUBKG_PMAP_ANIM2X));
+		if (resolutionFactor > 1)
+			setup_frame = CaptureDrawable (LoadGraphic (MENUBKG_PMAP_ANIM4X));
 	}
 
 	count = GetStringTableCount (SetupTab);
@@ -1373,7 +1384,7 @@ GetGlobalOptions (GLOBALOPTS *opts)
 	/* Work out resolution.  On the way, try to guess a good default
 	 * for config.alwaysgl, then overwrite it if it was set previously. */
 	opts->driver = OPTVAL_PURE_IF_POSSIBLE;
-	switch (ScreenWidthActual)
+	/*switch (ScreenWidthActual)
 	{
 	case 320:
 		if (GraphicsDriver == TFB_GFXDRIVER_SDL_PURE)
@@ -1434,7 +1445,7 @@ GetGlobalOptions (GLOBALOPTS *opts)
 	default:
 		opts->screenResolution = OPTVAL_CUSTOM;
 		break;
-	}
+	}*/
 
 	if (res_IsBoolean ("config.alwaysgl"))
 	{
@@ -1488,6 +1499,63 @@ GetGlobalOptions (GLOBALOPTS *opts)
 	opts->thraddStory = optThraddStory ? OPTVAL_ENABLED : OPTVAL_DISABLED;
 	opts->partialPickup = optPartialPickup ? OPTVAL_ENABLED : OPTVAL_DISABLED;
 	opts->submenu = optSubmenu ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->loresBlowup = res_GetInteger ("config.loresBlowupScale");
+
+	// JMS_GFX: 1280x960
+	if (resolutionFactor == 2)
+	{
+		opts->screenResolution = OPTVAL_REAL_1280_960;
+		opts->loresBlowup = NO_BLOWUP;	
+	}
+	// JMS_GFX: 640x480
+	else if (resolutionFactor == 1)
+	{
+		opts->screenResolution = OPTVAL_REAL_640_480;
+		opts->loresBlowup = NO_BLOWUP;
+	}
+	// JMS_GFX: 320x240
+	else
+	{
+		switch (ScreenWidthActual)
+		{
+			case 320:
+				if (GraphicsDriver == TFB_GFXDRIVER_SDL_PURE)
+				{
+					opts->screenResolution = OPTVAL_320_240;
+				}
+				else
+				{
+					opts->screenResolution = OPTVAL_320_240;
+					opts->driver = OPTVAL_ALWAYS_GL;
+				}
+				break;
+			case 640:
+				if (GraphicsDriver == TFB_GFXDRIVER_SDL_PURE)
+				{
+					opts->screenResolution = OPTVAL_320_240;
+					opts->loresBlowup = OPTVAL_320_TO_640;
+				}
+				else
+				{
+					opts->screenResolution = OPTVAL_320_240;
+					opts->loresBlowup = OPTVAL_320_TO_640;
+					opts->driver = OPTVAL_ALWAYS_GL;
+				}
+				break;
+			case 960:
+				opts->screenResolution = OPTVAL_320_240;
+				opts->loresBlowup = OPTVAL_320_TO_960;
+				break;
+			case 1280:
+				opts->screenResolution = OPTVAL_320_240;
+				opts->loresBlowup = OPTVAL_320_TO_1280;	
+				break;
+			default:
+				opts->screenResolution = OPTVAL_320_240;
+				opts->loresBlowup = NO_BLOWUP;
+				break;
+		}
+	}
 }
 
 void
@@ -1497,47 +1565,99 @@ SetGlobalOptions (GLOBALOPTS *opts)
 	int NewWidth = ScreenWidthActual;
 	int NewHeight = ScreenHeightActual;
 	int NewDriver = GraphicsDriver;
+	
+	unsigned int oldResFactor = resolutionFactor; // JMS_GFX
 
 	NewGfxFlags &= ~TFB_GFXFLAGS_SCALE_ANY;
-
+	
+	// JMS_GFX
 	switch (opts->screenResolution) {
-	case OPTVAL_320_240:
-		NewWidth = 320;
-		NewHeight = 240;
+		case OPTVAL_320_240:
+			NewWidth = 320;
+			NewHeight = 240;
 #ifdef HAVE_OPENGL	       
-		NewDriver = (opts->driver == OPTVAL_ALWAYS_GL ? TFB_GFXDRIVER_SDL_OPENGL : TFB_GFXDRIVER_SDL_PURE);
+			NewDriver = (opts->driver == OPTVAL_ALWAYS_GL ? TFB_GFXDRIVER_SDL_OPENGL : TFB_GFXDRIVER_SDL_PURE);
 #else
-		NewDriver = TFB_GFXDRIVER_SDL_PURE;
+			NewDriver = TFB_GFXDRIVER_SDL_PURE;
 #endif
-		break;
-	case OPTVAL_640_480:
-		NewWidth = 640;
-		NewHeight = 480;
+			resolutionFactor = 0;				
+			forceAspectRatio = FALSE;
+			break;
+		case OPTVAL_REAL_640_480:
+			NewWidth = 640;	
+			NewHeight = 480;
 #ifdef HAVE_OPENGL	       
-		NewDriver = (opts->driver == OPTVAL_ALWAYS_GL ? TFB_GFXDRIVER_SDL_OPENGL : TFB_GFXDRIVER_SDL_PURE);
+			NewDriver = TFB_GFXDRIVER_SDL_OPENGL;
 #else
-		NewDriver = TFB_GFXDRIVER_SDL_PURE;
+			NewDriver = TFB_GFXDRIVER_SDL_PURE;
 #endif
-		break;
-	case OPTVAL_960_720:
-		NewWidth = 960;
-		NewHeight = 720;
-		NewDriver = TFB_GFXDRIVER_SDL_OPENGL;
-		break;
-	case OPTVAL_1280_960:
-		NewWidth = 1280;
-		NewHeight = 960;
-		NewDriver = TFB_GFXDRIVER_SDL_OPENGL;
-		break;
-	default:
-		/* Don't mess with the custom value */
-		break;
+			resolutionFactor = 1;
+			forceAspectRatio = FALSE;
+			break;
+		case OPTVAL_REAL_1280_960:
+			NewWidth = 1280;
+			NewHeight = 960;
+#ifdef HAVE_OPENGL	       
+			NewDriver = TFB_GFXDRIVER_SDL_OPENGL;
+#else
+			NewDriver = TFB_GFXDRIVER_SDL_PURE;
+#endif
+			resolutionFactor = 2;
+			forceAspectRatio = FALSE;
+			break;
+		default:
+			/* Don't mess with the custom value */
+			resolutionFactor = 0; // JMS_GFX
+			break;
 	}
 
+	if (NewWidth == 320 && NewHeight == 240)
+	{	
+		switch (opts->loresBlowup) {
+			case NO_BLOWUP:
+				// JMS: Default value: Don't do anything.
+				break;
+			case OPTVAL_320_TO_640:
+				NewWidth = 640;
+				NewHeight = 480;
+#ifdef HAVE_OPENGL	       
+				NewDriver = (opts->driver == OPTVAL_ALWAYS_GL ? TFB_GFXDRIVER_SDL_OPENGL : TFB_GFXDRIVER_SDL_PURE);
+#else
+				NewDriver = TFB_GFXDRIVER_SDL_PURE;
+#endif
+				resolutionFactor = 0;
+				break;
+			case OPTVAL_320_TO_960:
+				NewWidth = 960;
+				NewHeight = 720;
+				NewDriver = TFB_GFXDRIVER_SDL_OPENGL;
+				resolutionFactor = 0;
+				break;
+			case OPTVAL_320_TO_1280:
+				NewWidth = 1280;
+				NewHeight = 960;
+				NewDriver = TFB_GFXDRIVER_SDL_OPENGL;
+				resolutionFactor = 0;
+				break;
+			default:
+				break;
+		}
+	}
+	else
+		opts->loresBlowup = NO_BLOWUP;
+	
+ 	if (oldResFactor != resolutionFactor || (opts->music3do != (opt3doMusic ? OPTVAL_ENABLED : OPTVAL_DISABLED)) || (opts->musicremix != (optRemixMusic ? OPTVAL_ENABLED : OPTVAL_DISABLED))) // MB: To force the game to restart when changing music options (otherwise music will not be changed) or resfactor 
+ 		resFactorWasChanged = TRUE;
+
 	res_PutInteger ("config.reswidth", NewWidth);
 	res_PutInteger ("config.resheight", NewHeight);
 	res_PutBoolean ("config.alwaysgl", opts->driver == OPTVAL_ALWAYS_GL);
 	res_PutBoolean ("config.usegl", NewDriver == TFB_GFXDRIVER_SDL_OPENGL);	
+	
+	// JMS_GFX
+	res_PutInteger ("config.resolutionfactor", resolutionFactor);
+	res_PutBoolean ("config.forceaspectratio", forceAspectRatio);
+	res_PutInteger ("config.loresBlowupScale", opts->loresBlowup);
 
 	// JMS: Cheat Mode: Kohr-Ah move at zero speed when trying to cleanse the galaxy
 	res_PutBoolean ("config.kohrStahp", opts->cheatMode == OPTVAL_ENABLED);
@@ -1645,30 +1765,30 @@ SetGlobalOptions (GLOBALOPTS *opts)
 	optSubmenu = opts->submenu == OPTVAL_ENABLED;
 
 	switch (opts->scaler) {
-	case OPTVAL_BILINEAR_SCALE:
-		NewGfxFlags |= TFB_GFXFLAGS_SCALE_BILINEAR;
-		res_PutString ("config.scaler", "bilinear");
-		break;
-	case OPTVAL_BIADAPT_SCALE:
-		NewGfxFlags |= TFB_GFXFLAGS_SCALE_BIADAPT;
-		res_PutString ("config.scaler", "biadapt");
-		break;
-	case OPTVAL_BIADV_SCALE:
-		NewGfxFlags |= TFB_GFXFLAGS_SCALE_BIADAPTADV;
-		res_PutString ("config.scaler", "biadv");
-		break;
-	case OPTVAL_TRISCAN_SCALE:
-		NewGfxFlags |= TFB_GFXFLAGS_SCALE_TRISCAN;
-		res_PutString ("config.scaler", "triscan");
-		break;
-	case OPTVAL_HQXX_SCALE:
-		NewGfxFlags |= TFB_GFXFLAGS_SCALE_HQXX;
-		res_PutString ("config.scaler", "hq");
-		break;
-	default:
-		/* OPTVAL_NO_SCALE has no equivalent in gfxflags. */
-		res_PutString ("config.scaler", "no");
-		break;
+		case OPTVAL_BILINEAR_SCALE:
+			NewGfxFlags |= TFB_GFXFLAGS_SCALE_BILINEAR;
+			res_PutString ("config.scaler", "bilinear");
+			break;
+		case OPTVAL_BIADAPT_SCALE:
+			NewGfxFlags |= TFB_GFXFLAGS_SCALE_BIADAPT;
+			res_PutString ("config.scaler", "biadapt");
+			break;
+		case OPTVAL_BIADV_SCALE:
+			NewGfxFlags |= TFB_GFXFLAGS_SCALE_BIADAPTADV;
+			res_PutString ("config.scaler", "biadv");
+			break;
+		case OPTVAL_TRISCAN_SCALE:
+			NewGfxFlags |= TFB_GFXFLAGS_SCALE_TRISCAN;
+			res_PutString ("config.scaler", "triscan");
+			break;
+		case OPTVAL_HQXX_SCALE:
+			NewGfxFlags |= TFB_GFXFLAGS_SCALE_HQXX;
+			res_PutString ("config.scaler", "hq");
+			break;
+		default:
+			/* OPTVAL_NO_SCALE has no equivalent in gfxflags. */
+			res_PutString ("config.scaler", "no");
+			break;
 	}
 	if (opts->scanlines) {
 		NewGfxFlags |= TFB_GFXFLAGS_SCANLINES;
@@ -1682,15 +1802,38 @@ SetGlobalOptions (GLOBALOPTS *opts)
 
 	res_PutBoolean ("config.scanlines", opts->scanlines);
 	res_PutBoolean ("config.fullscreen", opts->fullscreen);
-
-
+	
 	if ((NewWidth != ScreenWidthActual) ||
 	    (NewHeight != ScreenHeightActual) ||
 	    (NewDriver != GraphicsDriver) ||
+		(resFactorWasChanged) || // JMS_GFX
 	    (NewGfxFlags != GfxFlags)) 
 	{
 		FlushGraphics ();
 		UninitVideoPlayer ();
+		
+		// JMS_GFX
+		if (resFactorWasChanged)
+		{
+			// Tell the game the new screen's size.
+			ScreenWidth  = 320 << resolutionFactor;
+			ScreenHeight = 240 << resolutionFactor;
+			
+			log_add (log_Debug, "ScreenWidth:%d, ScreenHeight:%d, Wactual:%d, Hactual:%d",
+				ScreenWidth, ScreenHeight, ScreenWidthActual, ScreenHeightActual);
+			
+			// These solve the context problem that plagued the setupmenu when changing to higher resolution.
+			TFB_BBox_Reset ();
+			TFB_BBox_Init (ScreenWidth, ScreenHeight);
+			
+			// Change how big area of the screen is update-able.
+			DestroyDrawable (ReleaseDrawable (Screen));
+			Screen = CaptureDrawable (CreateDisplay (WANT_MASK | WANT_PIXMAP, &screen_width, &screen_height));
+			SetContext (ScreenContext);
+			SetContextFGFrame ((FRAME)NULL);
+			SetContextFGFrame (Screen);
+		}
+		
 		TFB_DrawScreen_ReinitVideo (NewDriver, NewGfxFlags, NewWidth, NewHeight);
 		FlushGraphics ();
 		InitVideoPlayer (TRUE);
diff -ruNp src.mm/uqm/setupmenu.h src/uqm/setupmenu.h
--- src.mm/uqm/setupmenu.h	2017-11-28 11:08:51 -0600
+++ src/uqm/setupmenu.h	2017-11-28 11:09:37 -0600
@@ -46,12 +46,25 @@ typedef enum {
 
 typedef enum {
 	OPTVAL_320_240,
-	OPTVAL_640_480,
-	OPTVAL_960_720,
-	OPTVAL_1280_960,
-	OPTVAL_CUSTOM
+	OPTVAL_REAL_640_480, // JMS_GFX
+	OPTVAL_REAL_1280_960, // JMS_GFX
 } OPT_RESTYPE;
 
+//typedef enum {
+//	OPTVAL_320_240,
+//	OPTVAL_640_480,
+//	OPTVAL_960_720,
+//	OPTVAL_1280_960,
+//	OPTVAL_CUSTOM
+//} OPT_RESTYPE;
+
+typedef enum {
+	NO_BLOWUP,
+	OPTVAL_320_TO_640,
+	OPTVAL_320_TO_960,
+	OPTVAL_320_TO_1280,
+} OPT_LORESBLOWUPTYPE;
+
 typedef enum {
 	OPTVAL_PURE_IF_POSSIBLE,
 	OPTVAL_ALWAYS_GL
@@ -88,6 +101,7 @@ typedef enum {
 typedef struct globalopts_struct {
 	OPT_SCALETYPE scaler;
 	OPT_RESTYPE screenResolution;
+	OPT_LORESBLOWUPTYPE loresBlowup;
 	OPT_DRIVERTYPE driver;
 	OPT_ADRIVERTYPE adriver;
 	OPT_AQUALITYTYPE aquality;
diff -ruNp src.mm/uqm/ship.c src/uqm/ship.c
--- src.mm/uqm/ship.c	2017-11-28 11:08:51 -0600
+++ src/uqm/ship.c	2017-11-28 11:09:37 -0600
@@ -55,7 +55,7 @@ animation_preprocess (ELEMENT *ElementPt
 STATUS_FLAGS
 inertial_thrust (ELEMENT *ElementPtr)
 {
-#define MAX_ALLOWED_SPEED     WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (18))
+#define MAX_ALLOWED_SPEED     WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (18 << RESOLUTION_FACTOR)) // JMS_GFX
 #define MAX_ALLOWED_SPEED_SQR ((DWORD)MAX_ALLOWED_SPEED * MAX_ALLOWED_SPEED)
 
 	COUNT CurrentAngle, TravelAngle;
@@ -186,7 +186,7 @@ ship_preprocess (ELEMENT *ElementPtr)
 		{
 			CONTEXT OldContext;
 
-			InitShipStatus (&RDPtr->ship_info, StarShipPtr, NULL);
+			InitShipStatus (&RDPtr->ship_info, StarShipPtr, NULL, FALSE);
 			OldContext = SetContext (StatusContext);
 			DrawCaptainsWindow (StarShipPtr);
 			SetContext (OldContext);
diff -ruNp src.mm/uqm/shipcont.h src/uqm/shipcont.h
--- src.mm/uqm/shipcont.h	2017-11-28 11:08:51 -0600
+++ src/uqm/shipcont.h	2017-11-28 11:09:37 -0600
@@ -25,7 +25,7 @@
 extern "C" {
 #endif
 
-#define FIELD_WIDTH (STATUS_WIDTH - 5)
+#define FIELD_WIDTH (STATUS_WIDTH - RES_CASE(5,5,7)) // JMS_GFX
 
 extern void CargoMenu (void);
 extern BOOLEAN RosterMenu (void);
diff -ruNp src.mm/uqm/shipstat.c src/uqm/shipstat.c
--- src.mm/uqm/shipstat.c	2017-11-28 11:08:55 -0600
+++ src/uqm/shipstat.c	2017-11-28 11:09:40 -0600
@@ -29,10 +29,10 @@ DrawCrewFuelString (COORD y, SIZE state)
 {
 	STAMP Stamp;
 
-	Stamp.origin.y = y + GAUGE_YOFFS + STARCON_TEXT_HEIGHT;
+	Stamp.origin.y = y + GAUGE_YOFFS + STARCON_TEXT_HEIGHT - RES_CASE(0,6,12);
 	if (state == 0)
 	{
-		Stamp.origin.x = CREW_XOFFS + (STAT_WIDTH >> 1) + 6;
+		Stamp.origin.x = CREW_XOFFS + (STAT_WIDTH >> 1) + RES_STAT_SCALE(6) - RES_CASE(0,8,8); // JMS_GFX
 		if (optWhichMenu == OPT_PC)
 			Stamp.frame = SetAbsFrameIndex (StatusFrame, 4);
 		else
@@ -40,7 +40,7 @@ DrawCrewFuelString (COORD y, SIZE state)
 		DrawStamp (&Stamp);
 	}
 
-	Stamp.origin.x = ENERGY_XOFFS + (STAT_WIDTH >> 1) - 5;
+	Stamp.origin.x = ENERGY_XOFFS + (STAT_WIDTH >> 1) - RES_STAT_SCALE(5) + RES_CASE(0,10,10); // JMS_GFX
 	if (optWhichMenu == OPT_PC)
 		Stamp.frame = SetAbsFrameIndex (StatusFrame, 5);
 	else
@@ -67,7 +67,7 @@ DrawShipNameString (UNICODE *pStr, COUNT
 	Text.CharCount = CharCount;
 	Text.align = ALIGN_CENTER;
 
-	Text.baseline.y = STARCON_TEXT_HEIGHT + 3 + y;
+	Text.baseline.y = STARCON_TEXT_HEIGHT + y + (3 << RESOLUTION_FACTOR) - 6 * RESOLUTION_FACTOR; // JMS_GFX
 	Text.baseline.x = STATUS_WIDTH >> 1;
 
 	SetContextForeGroundColor (
@@ -81,7 +81,7 @@ DrawShipNameString (UNICODE *pStr, COUNT
 }
 
 void
-ClearShipStatus (COORD y)
+ClearShipStatus (COORD y, COORD w, BOOLEAN inMeleeMenu)
 {
 	RECT r;
 
@@ -89,13 +89,13 @@ ClearShipStatus (COORD y)
 			BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
 	r.corner.x = 2;
 	r.corner.y = 3 + y;
-	r.extent.width = STATUS_WIDTH - 4;
-	r.extent.height = SHIP_INFO_HEIGHT - 3;
+	r.extent.width = w - 4;
+	r.extent.height = SHIP_INFO_HEIGHT - (inMeleeMenu ? RES_CASE(3,1,6) : 3); // JMS_GFX
 	DrawFilledRectangle (&r);
 }
 
 void
-OutlineShipStatus (COORD y)
+OutlineShipStatus (COORD y, COORD w, BOOLEAN inMeleeMenu)
 {
 	RECT r;
 
@@ -103,40 +103,52 @@ OutlineShipStatus (COORD y)
 			BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
 	r.corner.x = 0;
 	r.corner.y = 1 + y;
-	r.extent.width = STATUS_WIDTH;
+	r.extent.width = w;
 	r.extent.height = 1;
 	DrawFilledRectangle (&r);
 	++r.corner.y;
 	--r.extent.width;
 	DrawFilledRectangle (&r);
 	r.extent.width = 1;
-	r.extent.height = SHIP_INFO_HEIGHT - 2;
+	r.extent.height = SHIP_INFO_HEIGHT - RES_CASE((1), (inMeleeMenu ? -1 : 2), (inMeleeMenu ? 5 : 0));
 	DrawFilledRectangle (&r);
 	++r.corner.x;
 	DrawFilledRectangle (&r);
 
 	SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
-	r.corner.x = STATUS_WIDTH - 1;
+	r.corner.x = w - 1;
 	DrawFilledRectangle (&r);
-	r.corner.x = STATUS_WIDTH - 2;
+	r.corner.x = w - 2;
 	++r.corner.y;
 	--r.extent.height;
 	DrawFilledRectangle (&r);
 
+	r.corner.x = 1;
+	r.corner.y = SHIP_INFO_HEIGHT + RES_CASE(2,3,-2);
+	r.extent.width = w - 2;
+	r.extent.height = 1;
+	if (inMeleeMenu)
+		DrawFilledRectangle (&r);
+	++r.corner.x;
+	--r.corner.y;
+	if (inMeleeMenu)
+		DrawFilledRectangle (&r);
+
 	SetContextForeGroundColor (BLACK_COLOR);
 	r.corner.x = 0;
 	r.corner.y = y;
-	r.extent.width = STATUS_WIDTH;
+	r.extent.width = w;
 	r.extent.height = 1;
 	DrawFilledRectangle (&r);
 }
 
 void
-InitShipStatus (SHIP_INFO *SIPtr, STARSHIP *StarShipPtr, RECT *pClipRect)
+InitShipStatus (SHIP_INFO *SIPtr, STARSHIP *StarShipPtr, RECT *pClipRect, BOOLEAN inMeleeMenu)
 {
 	RECT r;
 	COORD y = 0; // default, for Melee menu
+	COORD width = STATUS_WIDTH; // BW: ShipStatus has less space in 2x and 4x MeleeMenu
 	STAMP Stamp;
 	CONTEXT OldContext;
 	RECT oldClipRect;
@@ -165,11 +177,11 @@ InitShipStatus (SHIP_INFO *SIPtr, STARSH
 
 	BatchGraphics ();
 	
-	OutlineShipStatus (y);
-	ClearShipStatus (y);
+	OutlineShipStatus (y, width, inMeleeMenu);
+	ClearShipStatus (y, width, inMeleeMenu);
 
 	Stamp.origin.x = (STATUS_WIDTH >> 1);
-	Stamp.origin.y = 31 + y;
+	Stamp.origin.y = (31 << RESOLUTION_FACTOR) + y;
 	Stamp.frame = IncFrameIndex (SIPtr->icons);
 	DrawStamp (&Stamp);
 
@@ -177,7 +189,17 @@ InitShipStatus (SHIP_INFO *SIPtr, STARSH
 		SIZE crew_height, energy_height;
 
 #define MIN(a, b) (((a) <= (b)) ? (a) : (b))
-		crew_height = ((MIN(SIPtr->max_crew, MAX_CREW_SIZE) + 1) & ~1) + 1;
+		// At basic resolution.
+		if (RESOLUTION_FACTOR == 0) {
+			crew_height = ((MIN(SIPtr->max_crew, MAX_CREW_SIZE) + 1) & ~1) + 1;
+			energy_height = (((SIPtr->max_energy + 1) >> 1) << 1) + 1;
+		} else if (RESOLUTION_FACTOR == 1) {
+			crew_height = ((MIN(SIPtr->max_crew, MAX_CREW_SIZE) + 1) * 1.5);
+			energy_height = (((SIPtr->max_energy + 1) >> 1) * 3) + 1;
+		} else {
+			crew_height = ((MIN(SIPtr->max_crew, MAX_CREW_SIZE) + 1) * 2.5) - 1;
+			energy_height = (((SIPtr->max_energy + 1) >> 1) * 5) + 1;
+		}
 #undef MIN
 		energy_height = (((SIPtr->max_energy + 1) >> 1) << 1) + 1;
 
diff -ruNp src.mm/uqm/shipyard.c src/uqm/shipyard.c
--- src.mm/uqm/shipyard.c	2017-11-28 11:08:55 -0600
+++ src/uqm/shipyard.c	2017-11-28 11:09:40 -0600
@@ -53,12 +53,24 @@ static const COORD hangar_x_coords[HANGA
 #else // use PC hangar
 // modified PC 6x2 hangar layout
 #	define HANGAR_SHIPS_ROW  6
-#	define HANGAR_Y          88
-#	define HANGAR_DY         84
 
-static const COORD hangar_x_coords[HANGAR_SHIPS_ROW] =
-{
-	0, 38, 76,  131, 169, 207
+// The Y position of the upper line of hangar bay doors.
+# define HANGAR_Y          ((88 << RESOLUTION_FACTOR) - RES_CASE(0,3,2)) // JMS_GFX
+
+// The Y position of the lower line of hangar bay doors.
+# define HANGAR_DY         ((84 << RESOLUTION_FACTOR) + RES_CASE(0,1,2)) // JMS_GFX
+
+
+// The X positions of the hangar bay doors for each resolution mode.
+// Calculated from the right edge of the left grey border bar on the screen.
+static const COORD hangar_x_coords_1x[HANGAR_SHIPS_ROW] = {
+	0, 38, 76, 131, 169, 207
+};
+static const COORD hangar_x_coords_2x[HANGAR_SHIPS_ROW] = {
+	2, 79, 157, 268, 346, 424
+};
+static const COORD hangar_x_coords_4x[HANGAR_SHIPS_ROW] = {
+	3, 171, 339, 578, 746, 914
 };
 #endif // USE_3DO_HANGAR
 
@@ -201,9 +213,9 @@ DrawRaceStrings (MENU_STATE *pMS, BYTE N
 	s.origin.x = RADAR_X - r.corner.x;
 	s.origin.y = RADAR_Y - r.corner.y;
 	r.corner.x = s.origin.x - 1;
-	r.corner.y = s.origin.y - 11;
+	r.corner.y = s.origin.y - RES_CASE(11,24,33); // JMS_GFX
 	r.extent.width = RADAR_WIDTH + 2;
-	r.extent.height = 11;
+	r.extent.height = RES_CASE(11,24,33); // JMS_GFX
 	BatchGraphics ();
 	ClearSISRect (CLEAR_SIS_RADAR);
 	SetContextForeGroundColor (
@@ -258,9 +270,16 @@ DrawRaceStrings (MENU_STATE *pMS, BYTE N
 
 }
 
-#define SHIP_WIN_WIDTH 34
-#define SHIP_WIN_HEIGHT (SHIP_WIN_WIDTH + 6)
-#define SHIP_WIN_FRAMES ((SHIP_WIN_WIDTH >> 1) + 1)
+// Width of an escort ship window.
+#define SHIP_WIN_WIDTH RES_CASE(34, 72, 156) // JMS_GFX
+
+// Height of an escort ship window.
+#define SHIP_WIN_HEIGHT (SHIP_WIN_WIDTH + RES_CASE(6,6,11)) // JMS_GFX
+
+// For how many animation frames' time the escort ship bay doors
+// are slid left and right when opening them. If this number is not large
+// enough, part of the doors are left visible upon opening.
+#define SHIP_WIN_FRAMES ((SHIP_WIN_WIDTH >> 1) + RES_CASE(1,1,2))
 
 // Print the crew count of an escort ship on top of its (already drawn)
 // image, either as '30' (full), '28/30' (partially full), or 'SCRAP'
@@ -292,15 +311,15 @@ ShowShipCrew (SHIP_FRAGMENT *StarShipPtr
 
 	r = *pRect;
 	t.baseline.x = r.corner.x + (r.extent.width >> 1);
-	t.baseline.y = r.corner.y + r.extent.height - 1;
+	t.baseline.y = r.corner.y + r.extent.height - 1 - (RESOLUTION_FACTOR == 1 ? 1 : 0); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 	if (r.corner.y)
 	{
-		r.corner.y = t.baseline.y - 6;
+		r.corner.y = t.baseline.y - (6 << RESOLUTION_FACTOR); //JMS_GFX
 		r.extent.width = SHIP_WIN_WIDTH;
-		r.extent.height = 6;
+		r.extent.height = (6 << RESOLUTION_FACTOR) + (RESOLUTION_FACTOR == 1 ? 1 : 0); // JMS_GFX
 		SetContextForeGroundColor (BLACK_COLOR);
 		DrawFilledRectangle (&r);
 	}
@@ -318,6 +337,7 @@ ShowCombatShip (MENU_STATE *pMS, COUNT w
 	COUNT num_ships;
 	HSHIPFRAG hStarShip, hNextShip;
 	SHIP_FRAGMENT *StarShipPtr;
+	static const COORD *hangar_x_coords;
 	struct
 	{
 		SHIP_FRAGMENT *StarShipPtr;
@@ -327,6 +347,19 @@ ShowCombatShip (MENU_STATE *pMS, COUNT w
 		STAMP rtdoor_s;
 	} ship_win_info[MAX_BUILT_SHIPS], *pship_win_info;
 
+	switch (RESOLUTION_FACTOR) {
+		case 2:
+			hangar_x_coords = hangar_x_coords_4x;
+			break;
+		case 1:
+			hangar_x_coords = hangar_x_coords_2x;
+			break;
+		case 0:
+		default:
+			hangar_x_coords = hangar_x_coords_1x;
+			break;
+	}
+
 	num_ships = 1;
 	pship_win_info = &ship_win_info[0];
 	if (YankedStarShipPtr)
@@ -437,7 +470,7 @@ ShowCombatShip (MENU_STATE *pMS, COUNT w
 		FlushInput ();
 		TimeIn = GetTimeCounter ();
 
-		for (j = 0; (j < SHIP_WIN_FRAMES) && !AllDoorsFinished; j++)
+		for (j = 0; (j < (int)SHIP_WIN_FRAMES) && !AllDoorsFinished; j++)
 		{
 			SleepThreadUntil (TimeIn + ONE_SECOND / 24);
 			TimeIn = GetTimeCounter ();
@@ -552,7 +585,7 @@ DMS_FlashFlagShip (void)
 	r.corner.x = 0;
 	r.corner.y = 0;
 	r.extent.width = SIS_SCREEN_WIDTH;
-	r.extent.height = 61;
+	r.extent.height = RES_CASE(61, 122, 295); // JMS_GFX
 	SetFlashRect (&r);
 }
 
@@ -561,6 +594,20 @@ DMS_GetEscortShipRect (RECT *rOut, BYTE
 {
 	BYTE row = slotNr / HANGAR_SHIPS_ROW;
 	BYTE col = slotNr % HANGAR_SHIPS_ROW;
+	static const COORD *hangar_x_coords;
+
+	switch (RESOLUTION_FACTOR) {
+		case 2:
+			hangar_x_coords = hangar_x_coords_4x;
+			break;
+		case 1:
+			hangar_x_coords = hangar_x_coords_2x;
+			break;
+		case 0:
+		default:
+			hangar_x_coords = hangar_x_coords_1x;
+			break;
+	}
 
 	rOut->corner.x = hangar_x_coords[col];
 	rOut->corner.y = HANGAR_Y + (HANGAR_DY * row);
@@ -592,11 +639,25 @@ DMS_FlashEscortShipCrewCount (BYTE slotN
 	RECT r;
 	BYTE row = slotNr / HANGAR_SHIPS_ROW;
 	BYTE col = slotNr % HANGAR_SHIPS_ROW;
+	static const COORD *hangar_x_coords;
+
+	switch (RESOLUTION_FACTOR) {
+		case 2:
+			hangar_x_coords = hangar_x_coords_4x;
+			break;
+		case 1:
+			hangar_x_coords = hangar_x_coords_2x;
+			break;
+		case 0:
+		default:
+			hangar_x_coords = hangar_x_coords_1x;
+			break;
+	}
 
 	r.corner.x = hangar_x_coords[col];
-	r.corner.y = (HANGAR_Y + (HANGAR_DY * row)) + (SHIP_WIN_HEIGHT - 6);
+	r.corner.y = (HANGAR_Y + (HANGAR_DY * row)) + (SHIP_WIN_HEIGHT - (6 << RESOLUTION_FACTOR));
 	r.extent.width = SHIP_WIN_WIDTH;
-	r.extent.height = 5;
+	r.extent.height = 5 << RESOLUTION_FACTOR; // JMS_GFX
 
 	SetContext (SpaceContext);
 	SetFlashRect (&r);
@@ -731,7 +792,25 @@ DMS_HireFlagShipCrew (void)
 	}
 
 	// Draw a crew member.
-	DrawPoint (&r.corner);
+	// Crew dots/rectangles for 1x and 2x resolutions.
+	if (RESOLUTION_FACTOR < 2) {
+		r.extent.width = 1 << RESOLUTION_FACTOR;
+		r.extent.height = r.extent.width;
+		DrawFilledRectangle (&r);
+	} else {
+		r.corner.x += 1;
+		r.extent.width = (1 << RESOLUTION_FACTOR) - 2;
+		r.extent.height = 1 << RESOLUTION_FACTOR;
+		DrawFilledRectangle (&r);
+									
+		r.corner.x -= 1;
+		r.corner.y += 1;
+		r.extent.width = 1 << RESOLUTION_FACTOR;
+		r.extent.height = (1 << RESOLUTION_FACTOR) - 2;
+		DrawFilledRectangle (&r);
+									
+		r.corner.y -= 1;
+	}
 
 	// Update the crew counter and RU. Note that the crew counter is
 	// flashing.
@@ -771,8 +850,10 @@ DMS_DismissFlagShipCrew (void)
 
 	// Remove the pixel representing the crew member.
 	GetCPodCapacity (&r.corner);
+	r.extent.width = 1 << RESOLUTION_FACTOR;
+	r.extent.height = r.extent.width;
 	SetContextForeGroundColor (BLACK_COLOR);
-	DrawPoint (&r.corner);
+	DrawFilledRectangle (&r);
 
 	return -1;
 }
@@ -1296,8 +1377,9 @@ DrawBluePrint (MENU_STATE *pMS)
 			DrawShipPiece (ModuleFrame, which_piece, num_frames, TRUE);
 	}
 
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x1F), 0x09));
+	if (RESOLUTION_FACTOR == 0)
+		SetContextForeGroundColor (
+				BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x1F), 0x09));
 	for (num_frames = 0; num_frames < NUM_MODULE_SLOTS; ++num_frames)
 	{
 		BYTE which_piece;
@@ -1313,10 +1395,30 @@ DrawBluePrint (MENU_STATE *pMS)
 
 		while (num_frames--)
 		{
-			POINT pt;
-
-			GetCPodCapacity (&pt);
-			DrawPoint (&pt);
+			RECT r;
+			// Crew dots/rectangles for 1x and 2x resolutions.
+			if (RESOLUTION_FACTOR < 2) {
+				r.extent.width = 1 << RESOLUTION_FACTOR;
+				r.extent.height = r.extent.width;
+				
+				GetCPodCapacity (&r.corner);
+				DrawFilledRectangle (&r);
+			} else {
+				GetCPodCapacity (&r.corner);
+				
+				r.corner.x += 1;
+				r.extent.width = (1 << RESOLUTION_FACTOR) - 2;
+				r.extent.height = 1 << RESOLUTION_FACTOR;
+				DrawFilledRectangle (&r);
+				
+				r.corner.x -= 1;
+				r.corner.y += 1;
+				r.extent.width = 1 << RESOLUTION_FACTOR;
+				r.extent.height = (1 << RESOLUTION_FACTOR) - 2;
+				DrawFilledRectangle (&r);
+				
+				r.corner.y -= 1;
+			}
 
 			++GLOBAL_SIS (CrewEnlisted);
 		}
@@ -1327,8 +1429,8 @@ DrawBluePrint (MENU_STATE *pMS)
 		num_frames = GLOBAL_SIS (TotalElementMass);
 		GLOBAL_SIS (TotalElementMass) = 0;
 
-		r.extent.width = 9;
-		r.extent.height = 1;
+		r.extent.width = 9 << RESOLUTION_FACTOR; // JMS_GFX
+		r.extent.height = 1 << RESOLUTION_FACTOR; // JMS_GFX
 		while (num_frames)
 		{
 			COUNT m;
@@ -1349,8 +1451,8 @@ DrawBluePrint (MENU_STATE *pMS)
 		FuelVolume = GLOBAL_SIS (FuelOnBoard) - FUEL_RESERVE;
 		GLOBAL_SIS (FuelOnBoard) = FUEL_RESERVE;
 
-		r.extent.width = 3;
-		r.extent.height = 1;
+		r.extent.width = (3 << RESOLUTION_FACTOR) + RESOLUTION_FACTOR; // JMS_GFX
+		r.extent.height = 1; // JMS_GFX
 		while (FuelVolume)
 		{
 			COUNT m;
diff -ruNp src.mm/uqm/sis.c src/uqm/sis.c
--- src.mm/uqm/sis.c	2017-11-28 11:08:55 -0600
+++ src/uqm/sis.c	2017-11-28 11:09:40 -0600
@@ -130,16 +130,16 @@ DrawSISTitle (UNICODE *pStr)
 	RECT r;
 
 	t.baseline.x = SIS_TITLE_WIDTH >> 1;
-	t.baseline.y = SIS_TITLE_HEIGHT - 2;
+	t.baseline.y = SIS_TITLE_HEIGHT - RES_CASE(2,6,8); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.pStr = pStr;
 	t.CharCount = (COUNT)~0;
 
 	OldContext = SetContext (OffScreenContext);
-	r.corner.x = SIS_ORG_X + SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH + 1;
+	r.corner.x = SIS_ORG_X + SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH + (1 << RESOLUTION_FACTOR); // JMS_GFX
 	r.corner.y = SIS_ORG_Y - SIS_TITLE_HEIGHT;
 	r.extent.width = SIS_TITLE_WIDTH;
-	r.extent.height = SIS_TITLE_HEIGHT - 1;
+	r.extent.height = SIS_TITLE_HEIGHT - RES_STAT_SCALE(1); // JMS_GFX
 	SetContextFGFrame (Screen);
 	SetContextClipRect (&r);
 	SetContextFont (TinyFont);
@@ -232,7 +232,7 @@ DrawSISMessageEx (const UNICODE *pStr, S
 	if (!(flags & DSME_MYCOLOR))
 		SetContextForeGroundColor (SIS_MESSAGE_TEXT_COLOR);
 
-	t.baseline.y = SIS_MESSAGE_HEIGHT - 2;
+	t.baseline.y = SIS_MESSAGE_HEIGHT - RES_CASE(2,6,8); // JMS_GFX
 	t.pStr = pStr;
 	t.CharCount = (COUNT)~0;
 	SetContextFont (TinyFont);
@@ -256,7 +256,7 @@ DrawSISMessageEx (const UNICODE *pStr, S
 		BYTE char_deltas[128];
 		BYTE *pchar_deltas;
 
-		t.baseline.x = 3;
+		t.baseline.x = RES_STAT_SCALE(3); // JMS_GFX
 		t.align = ALIGN_LEFT;
 
 		TextRect (&t, &text_r, char_deltas);
@@ -373,8 +373,8 @@ DateToString (char *buf, size_t bufLen,
 void
 GetStatusMessageRect (RECT *r)
 {
-	r->corner.x = 2;
-	r->corner.y = 130;
+	r->corner.x = RES_STAT_SCALE(2) - RES_CASE(0,1,2); // JMS_GFX
+	r->corner.y = RES_STAT_SCALE(130) + RES_CASE(0,6,18); // JMS_GFX
 	r->extent.width = STATUS_MESSAGE_WIDTH;
 	r->extent.height = STATUS_MESSAGE_HEIGHT;
 }
@@ -436,7 +436,7 @@ DrawStatusMessage (const UNICODE *pStr)
 	}
 
 	t.baseline.x = STATUS_MESSAGE_WIDTH >> 1;
-	t.baseline.y = STATUS_MESSAGE_HEIGHT - 1;
+	t.baseline.y = STATUS_MESSAGE_HEIGHT - RES_CASE(1,4,6); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.pStr = pStr;
 	t.CharCount = (COUNT)~0;
@@ -480,14 +480,14 @@ DrawCaptainsName (void)
 	OldFont = SetContextFont (TinyFont);
 	OldColor = SetContextForeGroundColor (CAPTAIN_NAME_BACKGROUND_COLOR);
 
-	r.corner.x = 2 + 1;
-	r.corner.y = 10;
-	r.extent.width = SHIP_NAME_WIDTH - 2;
-	r.extent.height = SHIP_NAME_HEIGHT;
+	r.corner.x = RES_STAT_SCALE(3) - RES_CASE(0,3,5);		// JMS_GFX
+	r.corner.y = RES_CASE(10,20,32);						// JMS_GFX
+	r.extent.width = SHIP_NAME_WIDTH - RES_CASE(2,1,0);		// JMS_GFX
+	r.extent.height = SHIP_NAME_HEIGHT + RESOLUTION_FACTOR;	// JMS_GFX
 	DrawFilledRectangle (&r);
 
-	t.baseline.x = (STATUS_WIDTH >> 1) - 1;
-	t.baseline.y = r.corner.y + 6;
+	t.baseline.x = (STATUS_WIDTH >> 1) - RES_CASE(1,0,-1);
+	t.baseline.y = r.corner.y + RES_CASE(6,11,16); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.pStr = GLOBAL_SIS (CommanderName);
 	t.CharCount = (COUNT)~0;
@@ -515,10 +515,10 @@ DrawFlagshipName (BOOLEAN InStatusArea)
 		OldContext = SetContext (StatusContext);
 		OldFont = SetContextFont (StarConFont);
 
-		r.corner.x = 2;
-		r.corner.y = 20;
-		r.extent.width = SHIP_NAME_WIDTH;
-		r.extent.height = SHIP_NAME_HEIGHT;
+		r.corner.x = RES_CASE(2,3,5);		// JMS_GFX
+		r.corner.y = RES_CASE(20,40,63);	// JMS_GFX
+		r.extent.width = SHIP_NAME_WIDTH;	// JMS_GFX
+		r.extent.height = SHIP_NAME_HEIGHT + RES_CASE(0,0,1);
 
 		t.pStr = GLOBAL_SIS (ShipName);
 	}
@@ -527,23 +527,39 @@ DrawFlagshipName (BOOLEAN InStatusArea)
 		OldContext = SetContext (SpaceContext);
 		OldFont = SetContextFont (MicroFont);
 
-		r.corner.x = 0;
+		r.corner.x = RES_CASE(0,24,0);
 		r.corner.y = 1;
-		r.extent.width = SIS_SCREEN_WIDTH;
-		r.extent.height = SHIP_NAME_HEIGHT;
+		r.extent.width = SIS_SCREEN_WIDTH - RES_CASE(0,24,0); // JMS_GFX
+		r.extent.height = SHIP_NAME_HEIGHT + RES_CASE(0,1,6);// JMS_GFX
 
 		t.pStr = buf;
 		snprintf (buf, sizeof buf, "%s %s",
 				GAME_STRING (NAMING_STRING_BASE + 1), GLOBAL_SIS (ShipName));
 		// XXX: this will not work with UTF-8 strings
 		strupr (buf);
+
+		// JMS: Handling the a-umlaut and o-umlaut characters
+        {
+            unsigned char *ptr;
+            ptr = (unsigned char*)buf;
+            while (*ptr) {
+                if (*ptr == 0xc3) {
+                    ptr++;
+                    if (*ptr == 0xb6 || *ptr == 0xa4) {
+                        *ptr += 'A' - 'a';
+                    }
+                }
+                ptr++;
+            }
+        }
 	}
 	OldFontEffect = SetContextFontEffect (NULL);
 	OldColor = SetContextForeGroundColor (FLAGSHIP_NAME_BACKGROUND_COLOR);
 	DrawFilledRectangle (&r);
 
 	t.baseline.x = r.corner.x + (r.extent.width >> 1);
-	t.baseline.y = r.corner.y + (SHIP_NAME_HEIGHT - InStatusArea);
+	t.baseline.y = r.corner.y + (SHIP_NAME_HEIGHT -
+					(InStatusArea ? RES_CASE(1,4,2) : RES_CASE(0,-4,-8))); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.CharCount = (COUNT)~0;
 	if (optWhichFonts == OPT_PC)
@@ -623,9 +639,9 @@ DrawFlagshipStats (void)
 
 	/* we need room to play.  full screen width, 4 lines tall */
 	r.corner.x = 0;
-	r.corner.y = SIS_SCREEN_HEIGHT - (4 * leading);
+	r.corner.y = SIS_SCREEN_HEIGHT - (4 * leading) - RES_CASE(0, 30, 60); // JMS_GFX
 	r.extent.width = SIS_SCREEN_WIDTH;
-	r.extent.height = (4 * leading);
+	r.extent.height = (4 * leading) + RES_CASE(0, 30, 60);// JMS_GFX
 
 	OldColor = SetContextForeGroundColor (BLACK_COLOR);
 	DrawFilledRectangle (&r);
@@ -634,8 +650,8 @@ DrawFlagshipStats (void)
 	   now that we've cleared out our playground, compensate for the
 	   fact that the leading is way more than is generally needed.
 	*/
-	leading -= 3;
-	t.baseline.x = SIS_SCREEN_WIDTH / 6; //wild-assed guess, but it worked
+	leading -= RES_CASE(3, -3, -6);// JMS_GFX
+	t.baseline.x = SIS_SCREEN_WIDTH / RES_CASE(6, 10, 11); //JMS_GFX
 	t.baseline.y = r.corner.y + leading + 3;
 	t.align = ALIGN_RIGHT;
 	t.CharCount = (COUNT)~0;
@@ -675,7 +691,7 @@ DrawFlagshipStats (void)
 			"%-7.7s", describeWeapon (GLOBAL_SIS (ModuleSlots[0])));
 	font_DrawText (&t);
 
-	t.baseline.x = r.extent.width - 25;
+	t.baseline.x = r.extent.width - 25 - RES_CASE(0,15,60); // JMS_GFX
 	t.baseline.y = r.corner.y + leading + 3;
 	t.align = ALIGN_RIGHT;
 
@@ -693,7 +709,7 @@ DrawFlagshipStats (void)
 	t.pStr = GAME_STRING (FLAGSHIP_STRING_BASE + 7); // "maximum fuel:"
 	font_DrawText (&t);
 
-	t.baseline.x = r.extent.width - 2;
+	t.baseline.x = r.extent.width - RES_CASE(2, 10, 40); // JMS_GFX
 	t.baseline.y = r.corner.y + leading + 3;
 	t.pStr = buf;
 
@@ -760,12 +776,12 @@ DrawLanders (void)
 
 	i = GLOBAL_SIS (NumLanders);
 	r.corner.x = (STATUS_WIDTH >> 1) - r.corner.x;
-	s.origin.x = r.corner.x - (((r.extent.width * i) + (2 * (i - 1))) >> 1);
-	s.origin.y = 29;
+	s.origin.x = r.corner.x - (((r.extent.width * i) + (2 * (i - 1))) >> 1) + RES_CASE(0,1,0);
+	s.origin.y = RES_STAT_SCALE(29) + RES_CASE(0,0,2); // JMS_GFX
 
 	width = r.extent.width + 2;
-	r.extent.width = (r.extent.width * MAX_LANDERS)
-			+ (2 * (MAX_LANDERS - 1)) + 2;
+	r.extent.width = (r.extent.width * MAX_LANDERS) + 
+		(2 * (MAX_LANDERS - 1)) + RES_CASE (2,2,-14); // JMS_GFX
 	r.corner.x -= r.extent.width >> 1;
 	r.corner.y += s.origin.y;
 	SetContextForeGroundColor (BLACK_COLOR);
@@ -789,17 +805,17 @@ DrawStorageBays (BOOLEAN Refresh)
 
 	OldContext = SetContext (StatusContext);
 
-	r.extent.width = 2;
-	r.extent.height = 4;
-	r.corner.y = 123;
+	r.extent.width  = RES_STAT_SCALE(2); // JMS_GFX
+	r.extent.height = RES_STAT_SCALE(4); // JMS_GFX
+	r.corner.y		= RES_STAT_SCALE(123) + RES_CASE(0,8,23); // JMS_GFX
 	if (Refresh)
 	{
 		r.extent.width = NUM_MODULE_SLOTS * (r.extent.width + 1);
-		r.corner.x = (STATUS_WIDTH >> 1) - (r.extent.width >> 1);
+		r.corner.x = (STATUS_WIDTH >> 1) - (r.extent.width >> 1) + RES_CASE(0,2,2);
 
 		SetContextForeGroundColor (BLACK_COLOR);
 		DrawFilledRectangle (&r);
-		r.extent.width = 2;
+		r.extent.width = RES_STAT_SCALE(2); // JMS_GFX
 	}
 
 	i = (BYTE)CountSISPieces (STORAGE_BAY);
@@ -807,42 +823,40 @@ DrawStorageBays (BOOLEAN Refresh)
 	{
 		COUNT j;
 
-		r.corner.x = (STATUS_WIDTH >> 1)
-				- ((i * (r.extent.width + 1)) >> 1);
+		r.corner.x = (STATUS_WIDTH >> 1) - ((i * (r.extent.width + RES_STAT_SCALE(1))) >> 1) + RES_CASE(0,2,2);
 		SetContextForeGroundColor (STORAGE_BAY_FULL_COLOR);
 		for (j = GLOBAL_SIS (TotalElementMass);
 				j >= STORAGE_BAY_CAPACITY; j -= STORAGE_BAY_CAPACITY)
 		{
 			DrawFilledRectangle (&r);
-			r.corner.x += r.extent.width + 1;
+			r.corner.x += r.extent.width + RES_STAT_SCALE(1); // JMS_GFX;
 
 			--i;
 		}
 
-		r.extent.height = (4 * j + (STORAGE_BAY_CAPACITY - 1)) /
-				STORAGE_BAY_CAPACITY;
+		r.extent.height = (RES_STAT_SCALE (4) * j + (STORAGE_BAY_CAPACITY - 1)) / STORAGE_BAY_CAPACITY;
 		if (r.extent.height)
 		{
-			r.corner.y += 4 - r.extent.height;
+			r.corner.y += RES_STAT_SCALE (4) - r.extent.height;
 			DrawFilledRectangle (&r);
-			r.extent.height = 4 - r.extent.height;
+			r.extent.height = RES_STAT_SCALE(4) - r.extent.height;
 			if (r.extent.height)
 			{
-				r.corner.y = 123;
+				r.corner.y = RES_STAT_SCALE(123) + RES_CASE(0,8,23);
 				SetContextForeGroundColor (STORAGE_BAY_EMPTY_COLOR);
 				DrawFilledRectangle (&r);
 			}
-			r.corner.x += r.extent.width + 1;
+			r.corner.x += r.extent.width + RES_STAT_SCALE(1);
 
 			--i;
 		}
-		r.extent.height = 4;
+		r.extent.height = RES_STAT_SCALE(4);
 
 		SetContextForeGroundColor (STORAGE_BAY_EMPTY_COLOR);
 		while (i--)
 		{
 			DrawFilledRectangle (&r);
-			r.corner.x += r.extent.width + 1;
+			r.corner.x += r.extent.width + RES_STAT_SCALE(1);
 		}
 	}
 
@@ -852,10 +866,10 @@ DrawStorageBays (BOOLEAN Refresh)
 void
 GetGaugeRect (RECT *pRect, BOOLEAN IsCrewRect)
 {
-	pRect->extent.width = 24;
-	pRect->corner.x = (STATUS_WIDTH >> 1) - (pRect->extent.width >> 1);
-	pRect->extent.height = 5;
-	pRect->corner.y = IsCrewRect ? 117 : 38;
+	pRect->extent.width = RES_STAT_SCALE(24); // JMS_GFX
+	pRect->corner.x = (STATUS_WIDTH >> 1) - (pRect->extent.width >> 1) + RES_CASE(0,0,4);
+	pRect->extent.height = RES_STAT_SCALE(5); // JMS_GFX
+	pRect->corner.y = IsCrewRect ? RES_CASE(117,244,375) : RES_CASE(38,76,120); // JMS_GFX
 }
 
 static void
@@ -866,23 +880,26 @@ DrawPC_SIS (void)
 
 	GetGaugeRect (&r, FALSE);
 	t.baseline.x = STATUS_WIDTH >> 1;
-	t.baseline.y = r.corner.y - 1;
+	t.baseline.y = r.corner.y - RES_CASE(1,0,2);
 	t.align = ALIGN_CENTER;
 	t.CharCount = (COUNT)~0;
 	SetContextFont (TinyFont);
 	SetContextForeGroundColor (BLACK_COLOR);
 
-	r.corner.y -= 6;
-	r.corner.x--;
-	r.extent.width += 2;
+	// Black rectangle behind "FUEL" text and fuel amount.
+	r.corner.y -= RES_STAT_SCALE(6); // JMS_GFX
+	r.corner.x -= RES_STAT_SCALE(1); // JMS_GFX
+	r.extent.width += RES_STAT_SCALE(2);
+	r.extent.height += RES_CASE(0,2,2);
 	DrawFilledRectangle (&r);
 
 	SetContextFontEffect (SetAbsFrameIndex (FontGradFrame, 1));
 	t.pStr = GAME_STRING (STATUS_STRING_BASE + 3); // "FUEL"
 	font_DrawText (&t);
 
-	r.corner.y += 79;
-	t.baseline.y += 79;
+	// Black rectangle behind "CREW" text and crew amount.
+	r.corner.y += RES_STAT_SCALE(79) + RES_CASE(0,12,18); // JMS_GFX
+	t.baseline.y += RES_STAT_SCALE(79) + RES_CASE(0,9,18); // JMS_GFX
 	DrawFilledRectangle (&r);
 
 	SetContextFontEffect (SetAbsFrameIndex (FontGradFrame, 2));
@@ -891,16 +908,16 @@ DrawPC_SIS (void)
 	SetContextFontEffect (NULL);
 
 	// Background of text "CAPTAIN".
-	r.corner.x = 2 + 1;
-	r.corner.y = 3;
-	r.extent.width = 58;
-	r.extent.height = 7;
+	r.corner.x = (2 + 1) << RESOLUTION_FACTOR; // JMS_GFX;
+	r.corner.y = RES_STAT_SCALE(3); // JMS_GFX
+	r.extent.width = RES_STAT_SCALE(58); // JMS_GFX
+	r.extent.height = RES_STAT_SCALE(7); // JMS_GFX
 	SetContextForeGroundColor (PC_CAPTAIN_STRING_BACKGROUND_COLOR);
 	DrawFilledRectangle (&r);
 
 	// Text "CAPTAIN".
 	SetContextForeGroundColor (PC_CAPTAIN_STRING_TEXT_COLOR);
-	t.baseline.y = r.corner.y + 6;
+	t.baseline.y = r.corner.y + RES_CASE(6,10,18); // JMS_GFX
 	t.pStr = GAME_STRING (STATUS_STRING_BASE + 5); // "CAPTAIN"
 	font_DrawText (&t);
 }
@@ -911,7 +928,7 @@ DrawThrusters (void)
 	STAMP s;
 	COUNT i;
 
-	s.origin.x = 1;
+	s.origin.x = RES_STAT_SCALE(1); // JMS_GFX
 	s.origin.y = 0;
 	for (i = 0; i < NUM_DRIVE_SLOTS; ++i)
 	{
@@ -924,7 +941,7 @@ DrawThrusters (void)
 			DrawStamp (&s);
 		}
 
-		s.origin.y -= 3;
+		s.origin.y -= RES_STAT_SCALE(3); // JMS_GFX
 	}
 }
 
@@ -934,7 +951,7 @@ DrawTurningJets (void)
 	STAMP s;
 	COUNT i;
 
-	s.origin.x = 1;
+	s.origin.x = RES_STAT_SCALE(1); // JMS_GFX
 	s.origin.y = 0;
 	for (i = 0; i < NUM_JET_SLOTS; ++i)
 	{
@@ -947,7 +964,7 @@ DrawTurningJets (void)
 			DrawStamp (&s);
 		}
 
-		s.origin.y -= 3;
+		s.origin.y -= RES_STAT_SCALE(3); // JMS_GFX
 	}
 }
 
@@ -957,7 +974,7 @@ DrawModules (void)
 	STAMP s;
 	COUNT i;
 
-	s.origin.x = 1; // This properly centers the modules.
+	s.origin.x = RES_STAT_SCALE(1); // JMS_GFX // This properly centers the modules.
 	s.origin.y = 1;
 	for (i = 0; i < NUM_MODULE_SLOTS; ++i)
 	{
@@ -968,7 +985,7 @@ DrawModules (void)
 			DrawStamp (&s);
 		}
 
-		s.origin.y -= 3;
+		s.origin.y -= RES_STAT_SCALE(3); // JMS_GFX
 	}
 }
 
@@ -993,8 +1010,10 @@ DrawSupportShips (void)
 		StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 		hNextShip = _GetSuccLink (StarShipPtr);
 
-		s.origin = *pship_pos;
-		s.frame = StarShipPtr->icons;
+		s.origin.x = RES_STAT_SCALE(pship_pos->x) 
+			+ ((pship_pos - ship_pos) % 2 ? RES_CASE(0,3,5) : RES_CASE(0,-2,-2)); // JMS_GFX
+		s.origin.y = RES_STAT_SCALE(pship_pos->y) + RES_CASE(0,5,0); // JMS_GFX
+		s.frame = SetAbsFrameIndex (StarShipPtr->icons, 2);
 		DrawStamp (&s);
 
 		UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
@@ -1033,7 +1052,7 @@ DeltaSISGauges_crewDelta (SIZE crew_delt
 		GetGaugeRect (&r, TRUE);
 		
 		t.baseline.x = STATUS_WIDTH >> 1;
-		t.baseline.y = r.corner.y + r.extent.height;
+		t.baseline.y = r.corner.y + r.extent.height - (RESOLUTION_FACTOR == 1 ? 1 : 0); // JMS_GFX
 		t.align = ALIGN_CENTER;
 		t.pStr = buf;
 		t.CharCount = (COUNT)~0;
@@ -1095,7 +1114,7 @@ DeltaSISGauges_fuelDelta (SIZE fuel_delt
 		GetGaugeRect (&r, FALSE);
 		
 		t.baseline.x = STATUS_WIDTH >> 1;
-		t.baseline.y = r.corner.y + r.extent.height;
+		t.baseline.y = r.corner.y + r.extent.height - (RESOLUTION_FACTOR == 1 ? 1 : 0); // JMS_GFX
 		t.align = ALIGN_CENTER;
 		t.pStr = buf;
 		t.CharCount = (COUNT)~0;
@@ -1128,10 +1147,7 @@ DeltaSISGauges_resunitDelta (SIZE resuni
 	{
 		RECT r;
 
-		r.corner.x = 2;
-		r.corner.y = 130;
-		r.extent.width = STATUS_MESSAGE_WIDTH;
-		r.extent.height = STATUS_MESSAGE_HEIGHT;
+		GetStatusMessageRect (&r);
 		SetContextForeGroundColor (
 				BUILD_COLOR (MAKE_RGB15 (0x00, 0x08, 0x00), 0x6E));
 		DrawFilledRectangle (&r);
@@ -1274,12 +1290,8 @@ GetCrewPodForCrewMember (COUNT crewNr, C
 COUNT
 GetCPodCapacity (POINT *ppt)
 {
-	COUNT crewCount;
-	COUNT slotNr;
-	COUNT seatNr;
-
-	COUNT rowNr;
-	COUNT colNr;
+	COUNT crewCount, slotNr, seatNr, rowNr, colNr;
+	COUNT ship_piece_offset_scaled = SHIP_PIECE_OFFSET + RES_CASE(0,1,1);  // JMS_GFX
 				
 	static const Color crewRows[] = PC_CREW_COLOR_TABLE;
 
@@ -1298,8 +1310,9 @@ GetCPodCapacity (POINT *ppt)
 	else
 		SetContextForeGroundColor (THREEDO_CREW_COLOR);
 		
-	ppt->x = 27 + (slotNr * SHIP_PIECE_OFFSET) - (colNr * 2);
-	ppt->y = 34 - (rowNr * 2);
+	ppt->x = (27 << RESOLUTION_FACTOR) + (slotNr * ship_piece_offset_scaled) -
+				((colNr * 2) << RESOLUTION_FACTOR) + RES_CASE(0,19,53); // JMS_GFX
+	ppt->y = ((34 - (rowNr * 2)) << RESOLUTION_FACTOR) + RES_CASE(0,6,20); // JMS_GFX
 
 	return GetCrewPodCapacity ();
 }
@@ -1376,19 +1389,15 @@ GetStorageCellForMineralUnit (COUNT unit
 COUNT
 GetSBayCapacity (POINT *ppt)
 {
-	COUNT massCount;
-	COUNT slotNr;
-	COUNT cellNr;
-
-	COUNT rowNr;
-	COUNT colNr;
+	COUNT massCount, slotNr, cellNr, rowNr, colNr;
+	COUNT ship_piece_offset_scaled = SHIP_PIECE_OFFSET + RES_CASE(0,1,1);  // JMS_GFX
 				
 	static const Color colorBars[] = STORAGE_BAY_COLOR_TABLE;
 
 	massCount = GetElementMass ();
 	if (!GetStorageCellForMineralUnit (massCount, &slotNr, &cellNr))
 	{
-		// Crew does not fit. *ppt is unchanged.
+		// Mineral does not fit. *ppt is unchanged.
 		return GetStorageBayCapacity ();
 	}
 
@@ -1403,8 +1412,8 @@ GetSBayCapacity (POINT *ppt)
 		SetContextForeGroundColor (colorBars[rowNr]);
 	}
 		
-	ppt->x = 19 + (slotNr * SHIP_PIECE_OFFSET);
-	ppt->y = 34 - (rowNr * 2);
+	ppt->x = (19 << RESOLUTION_FACTOR) + (slotNr * ship_piece_offset_scaled) + RES_CASE(0,19,53); // JMS_GFX
+	ppt->y = ((34 - (rowNr * 2)) << RESOLUTION_FACTOR) - RES_CASE(0,0,9); // JMS_GFX
 
 	return GetStorageBayCapacity ();
 }
@@ -1486,14 +1495,10 @@ GetFuelTankForFuelUnit (DWORD unitNr, CO
 DWORD
 GetFTankCapacity (POINT *ppt)
 {
-	DWORD capacity;
-	DWORD fuelAmount;
+	DWORD capacity, rowNr, fuelAmount, compartmentNr, volume, volumehelper;
 	COUNT slotNr;
-	DWORD compartmentNr;
 	BYTE moduleType;
-	DWORD volume;
-
-	COUNT rowNr;
+	COUNT ship_piece_offset_scaled = SHIP_PIECE_OFFSET + RES_CASE(0,1,1);  // JMS_GFX
 	
 	static const Color fuelColors[] = FUEL_COLOR_TABLE;
 		
@@ -1515,13 +1520,23 @@ GetFTankCapacity (POINT *ppt)
 	moduleType = GLOBAL_SIS (ModuleSlots[slotNr]);
 	volume = GetModuleFuelCapacity (moduleType);
 
-	rowNr = ((volume - compartmentNr) * MAX_FUEL_BARS / HEFUEL_TANK_CAPACITY);
-		
-	ppt->x = 21 + (slotNr * SHIP_PIECE_OFFSET);
 	if (volume == FUEL_TANK_CAPACITY)
-		ppt->y = 27 - rowNr;
+		volumehelper = (volume * 10) / RES_CASE(10,22,22);
 	else
-		ppt->y = 30 - rowNr;
+		volumehelper = volume;
+
+	rowNr = ((volumehelper - compartmentNr) * MAX_FUEL_BARS / HEFUEL_TANK_CAPACITY);
+	ppt->x = (21 << RESOLUTION_FACTOR) + (slotNr * ship_piece_offset_scaled);
+	if (volume == FUEL_TANK_CAPACITY) {
+		ppt->x += RES_CASE(0,20,54); // JMS_GFX
+		ppt->y = (27 << RESOLUTION_FACTOR) - rowNr + RES_CASE(0,11,27); // JMS_GFX
+	} else {
+		ppt->x += RES_CASE(0,20,53); // JMS_GFX
+		ppt->y = (30 << RESOLUTION_FACTOR) - rowNr + RES_CASE(0,21,43); // JMS_GFX
+	}
+	
+	rowNr = ((volume - compartmentNr) * 10 * MAX_FUEL_BARS / HEFUEL_TANK_CAPACITY) /
+		MAX_FUEL_BARS;
 
 	assert (rowNr + 1 < (COUNT) (sizeof fuelColors / sizeof fuelColors[0]));
 	SetContextForeGroundColor (fuelColors[rowNr]);
diff -ruNp src.mm/uqm/sis.h src/uqm/sis.h
--- src.mm/uqm/sis.h	2017-11-28 11:08:55 -0600
+++ src/uqm/sis.h	2017-11-28 11:09:40 -0600
@@ -21,6 +21,8 @@
 #include "libs/gfxlib.h"
 #include "planets/elemdata.h"
 		// for NUM_ELEMENT_CATEGORIES
+#include "units.h"
+                // for RESOLUTION_FACTOR
 
 #if defined(__cplusplus)
 extern "C" {
@@ -47,9 +49,10 @@ extern "C" {
 #define CREW_PER_ROW 5
 #define SBAY_MASS_PER_ROW 50
 
-#define MAX_FUEL_BARS 10
+#define MAX_FUEL_BARS RES_CASE(10,40,80)
 #define FUEL_VOLUME_PER_ROW (HEFUEL_TANK_CAPACITY / MAX_FUEL_BARS)
-#define FUEL_RESERVE FUEL_VOLUME_PER_ROW
+#define FUEL_RESERVE (10 * FUEL_TANK_SCALE) // JMS_GFX
+#define FUEL_COST_RU 20 // JMS
 
 #define IP_SHIP_THRUST_INCREMENT 8
 #define IP_SHIP_TURN_WAIT 17
@@ -92,22 +95,22 @@ enum
 #define EMPTY_SLOT NUM_MODULES
 #define NUM_BOMB_MODULES 10
 
-#define DRIVE_SIDE_X 31
-#define DRIVE_SIDE_Y 56
-#define DRIVE_TOP_X 33
-#define DRIVE_TOP_Y (65 + 21)
-
-#define JET_SIDE_X 71
-#define JET_SIDE_Y 48
-#define JET_TOP_X 70
-#define JET_TOP_Y (73 + 21)
-
-#define MODULE_SIDE_X 17
-#define MODULE_SIDE_Y 14
-#define MODULE_TOP_X 17
-#define MODULE_TOP_Y (96 + 21)
+#define DRIVE_SIDE_X ((31 << RESOLUTION_FACTOR)) // JMS_GFX
+#define DRIVE_SIDE_Y ((56 << RESOLUTION_FACTOR)) // JMS_GFX
+#define DRIVE_TOP_X ((33 << RESOLUTION_FACTOR) + RES_CASE(0,42,100)) // JMS_GFX
+#define DRIVE_TOP_Y ((86 << RESOLUTION_FACTOR) - RES_CASE(0,45,73)) // JMS_GFX
+
+#define JET_SIDE_X ((71 << RESOLUTION_FACTOR)) // JMS_GFX
+#define JET_SIDE_Y ((48 << RESOLUTION_FACTOR)) // JMS_GFX
+#define JET_TOP_X ((70 << RESOLUTION_FACTOR) + RES_CASE(0,32,86)) // JMS_GFX
+#define JET_TOP_Y ((94 << RESOLUTION_FACTOR) - RES_CASE(0,69,120)) // JMS_GFX
+
+#define MODULE_SIDE_X ((17 << RESOLUTION_FACTOR) + RES_CASE(0,21,55)) // JMS_GFX
+#define MODULE_SIDE_Y ((14 << RESOLUTION_FACTOR) - RES_CASE(0,2,5)) // JMS_GFX
+#define MODULE_TOP_X ((17 << RESOLUTION_FACTOR) + RES_CASE(0,22,55)) // JMS_GFX
+#define MODULE_TOP_Y ((117 << RESOLUTION_FACTOR) + RES_CASE(0,14,59)) // JMS_GFX
 
-#define SHIP_PIECE_OFFSET 12
+#define SHIP_PIECE_OFFSET ((12 << RESOLUTION_FACTOR) - RES_CASE(0,3,2)) // JMS_GFX
 
 #define MAX_BUILT_SHIPS 12
 		/* Maximum number of ships escorting the SIS */
@@ -128,6 +131,8 @@ enum
 	{3 + 42, 30 + (5 * 16)},
 
 #define SIS_NAME_SIZE 16
+#define SAVE_NAME_CHECKER "MegaMod" // JMS
+#define SAVE_CHECKER_SIZE SIS_NAME_SIZE
 
 typedef struct
 {
diff -ruNp src.mm/uqm/starbase.c src/uqm/starbase.c
--- src.mm/uqm/starbase.c	2017-11-28 11:08:55 -0600
+++ src/uqm/starbase.c	2017-11-28 11:09:40 -0600
@@ -47,18 +47,21 @@ static void
 DrawBaseStateStrings (STARBASE_STATE OldState, STARBASE_STATE NewState)
 {
 	TEXT t;
+	RECT r;
+	COUNT text_base_y = 106 + 28 - RES_CASE (0,2,0);
+	COUNT text_spacing_y = 23 - 4;
 	//STRING locString;
 
 	SetContext (ScreenContext);
 	SetContextFont (StarConFont);
 	SetContextForeGroundColor (BLACK_COLOR);
 
-	t.baseline.x = 73 - 4 + SAFE_X;
+	t.baseline.x = (73 - 4 + SAFE_X) << RESOLUTION_FACTOR; // JMS_GFX
 	t.align = ALIGN_CENTER;
 
 	if (OldState == (STARBASE_STATE)~0)
 	{
-		t.baseline.y = 106 + 28 + (SAFE_Y + 4);
+		t.baseline.y = (text_base_y  << RESOLUTION_FACTOR) + (SAFE_Y + 4); // JMS_GFX;
 		for (OldState = TALK_COMMANDER; OldState < DEPART_BASE; ++OldState)
 		{
 			if (OldState != NewState)
@@ -67,18 +70,24 @@ DrawBaseStateStrings (STARBASE_STATE Old
 				t.CharCount = (COUNT)~0;
 				font_DrawText (&t);
 			}
-			t.baseline.y += (23 - 4);
+			t.baseline.y += text_spacing_y << RESOLUTION_FACTOR; // JMS_GFX
 		}
 	}
 
-	t.baseline.y = 106 + 28 + (SAFE_Y + 4) + ((23 - 4) * OldState);
+	t.baseline.y = ((text_base_y + (text_spacing_y * OldState)) << RESOLUTION_FACTOR) + (SAFE_Y + 4); // JMS_GFX
 	t.pStr = GAME_STRING (STARBASE_STRING_BASE + 1 + OldState);
+	// BW: erase previously selected string before redrawing it
+	TextRect(&t, &r, NULL);
+	SetContextForeGroundColor (
+			   BUILD_COLOR_RGBA (0x88, 0x88, 0x88, 0xff));
+	DrawFilledRectangle (&r);
+	SetContextForeGroundColor (BLACK_COLOR);
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 
 	SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x0A), 0x0E));
-	t.baseline.y = 106 + 28 + (SAFE_Y + 4) + ((23 - 4) * NewState);
+	t.baseline.y = ((text_base_y + (text_spacing_y * NewState)) << RESOLUTION_FACTOR) + (SAFE_Y + 4); // JMS_GFX
 	t.pStr = GAME_STRING (STARBASE_STRING_BASE + 1 + NewState);
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
@@ -93,6 +102,13 @@ DrawShipPiece (FRAME ModuleFrame, COUNT
 	RECT r;
 	STAMP Side, Top;
 	SBYTE RepairSlot;
+	COUNT ship_piece_offset_scaled = SHIP_PIECE_OFFSET;
+ 
+	// JMS_GFX
+	if (RESOLUTION_FACTOR != 0 &&
+		which_piece != FUSION_THRUSTER && which_piece != TURNING_JETS
+		 && which_piece != EMPTY_SLOT + 0 && which_piece != EMPTY_SLOT + 1)
+		ship_piece_offset_scaled += 1;
 
 	RepairSlot = 0;
 	switch (which_piece)
@@ -145,54 +161,99 @@ DrawShipPiece (FRAME ModuleFrame, COUNT
 			break;
 	}
 
-	Side.origin.x += which_slot * SHIP_PIECE_OFFSET;
+	Side.origin.x += which_slot * ship_piece_offset_scaled;
 	Side.frame = NULL;
 	if (RepairSlot < 0)
 	{
 		Side.frame = SetAbsFrameIndex (ModuleFrame,
 				((NUM_MODULES - 1) + (6 - 2)) + (NUM_MODULES + 6)
 				- (RepairSlot + 1));
-		DrawStamp (&Side);
+		// JMS_GFX:
+		if (RESOLUTION_FACTOR == 0 ||
+			(which_piece != FUSION_THRUSTER && which_piece != TURNING_JETS
+			 && which_piece != EMPTY_SLOT + 0 && which_piece != EMPTY_SLOT + 1))
+			DrawStamp (&Side);
 	}
-	else if (RepairSlot)
+	else if (RepairSlot && !(RESOLUTION_FACTOR > 0 && DrawBluePrint))
 	{
-		r.corner = Side.origin;
-		r.extent.width = SHIP_PIECE_OFFSET;
-		r.extent.height = 1;
 		OldColor = SetContextForeGroundColor (BLACK_COLOR);
-		DrawFilledRectangle (&r);
-		r.corner.y += 23 - 1;
+
+		r.corner = Side.origin;
+		r.corner.y += RES_CASE(0,0,8);
+		r.extent.width = ship_piece_offset_scaled;
+		r.extent.height = 1 << RESOLUTION_FACTOR;
+
 		DrawFilledRectangle (&r);
 
-		r.extent.width = 1;
-		r.extent.height = 8;
+		r.corner.y += ((23 - 1) << RESOLUTION_FACTOR); // JMS_GFX
+		if (RESOLUTION_FACTOR != 0)
+			r.extent.height += RES_CASE(0,15,30); 
+		
+		if (which_slot == 0 && RESOLUTION_FACTOR !=0)
+			r.corner.x += RES_CASE(0,2,4); // JMS_GFX
+		else if (which_slot == NUM_MODULE_SLOTS - 1 && RESOLUTION_FACTOR !=0)
+			r.extent.width -= RES_CASE(0,4,9); // JMS_GFX
+
 		if (RepairSlot == 2)
 		{
 			r.corner = Side.origin;
+			r.corner.y += RES_CASE(0,0,8);
 			DrawFilledRectangle (&r);
-			r.corner.y += 15;
+			if (RESOLUTION_FACTOR > 0) {
+				r.corner.x += ship_piece_offset_scaled - r.extent.width;
+				if (which_slot == NUM_MODULE_SLOTS - 1 && RESOLUTION_FACTOR !=0) {
+					r.extent.height -= RES_CASE(0,8,16); // JMS_GFX
+					r.extent.width += RES_CASE(0,2,4); // JMS_GFX
+					DrawFilledRectangle (&r);
+					r.extent.width -= RES_CASE(0,2,4); // JMS_GFX
+				} else
+					DrawFilledRectangle (&r);
+				
+				r.corner.x -= ship_piece_offset_scaled - r.extent.width;
+			}
+			r.corner.y += 15 << RESOLUTION_FACTOR; // JMS_GFX
 			DrawFilledRectangle (&r);
+			if (RESOLUTION_FACTOR > 0) {
+				r.corner.x += ship_piece_offset_scaled - r.extent.width;
+				if (which_slot == NUM_MODULE_SLOTS - 1 && RESOLUTION_FACTOR !=0) {
+					r.corner.y += RES_CASE(0,16,32);
+					r.extent.height -= RES_CASE(0,17,36); // JMS_GFX
+					r.extent.width += RES_CASE(0,1,3); // JMS_GFX
+					DrawFilledRectangle (&r);
+					r.extent.width -= RES_CASE(0,1,3); // JMS_GFX
+					r.extent.height += RES_CASE(0,17,36); // JMS_GFX
+				} else
+					DrawFilledRectangle (&r);
+				
+				r.corner.x -= ship_piece_offset_scaled - r.extent.width;
+			}
 		}
 		if (which_slot < (NUM_MODULE_SLOTS - 1))
 		{
 			r.corner = Side.origin;
-			r.corner.x += SHIP_PIECE_OFFSET;
+			r.corner.y += RES_CASE(0,0,8);
+			r.corner.x += ship_piece_offset_scaled;
 			DrawFilledRectangle (&r);
-			r.corner.y += 15;
+			if (RESOLUTION_FACTOR == 2) {
+				r.corner.x += ship_piece_offset_scaled - r.extent.width;
+				DrawFilledRectangle (&r);
+				r.corner.x -= ship_piece_offset_scaled - r.extent.width;
+			}
+			r.corner.y += 15 << RESOLUTION_FACTOR; // JMS_GFX
 			DrawFilledRectangle (&r);
 		}
 	}
 
 	if (DrawBluePrint)
 	{
-		if (RepairSlot)
+		if (RepairSlot && !(RESOLUTION_FACTOR > 0 && DrawBluePrint))
 			SetContextForeGroundColor (OldColor);
 		Side.frame = SetAbsFrameIndex (ModuleFrame, which_piece - 1);
 		DrawFilledStamp (&Side);
 	}
 	else
 	{
-		Top.origin.x += which_slot * SHIP_PIECE_OFFSET;
+		Top.origin.x += which_slot * ship_piece_offset_scaled;
 		if (RepairSlot < 0)
 		{
 			Top.frame = SetRelFrameIndex (Side.frame, -((NUM_MODULES - 1) + 6));
@@ -201,28 +262,38 @@ DrawShipPiece (FRAME ModuleFrame, COUNT
 		else if (RepairSlot)
 		{
 			r.corner = Top.origin;
-			r.extent.width = SHIP_PIECE_OFFSET;
-			r.extent.height = 1;
+			r.extent.width = ship_piece_offset_scaled;
+			r.extent.height = (1 << RESOLUTION_FACTOR) + RESOLUTION_FACTOR;
 			DrawFilledRectangle (&r);
-			r.corner.y += 32 - 1;
+			r.corner.y += ((32 - 1) << RESOLUTION_FACTOR) + RES_CASE(0,3,16);  // JMS_GFX
 			DrawFilledRectangle (&r);
 
-			r.extent.width = 1;
-			r.extent.height = 12;
+			r.extent.width = (1 << RESOLUTION_FACTOR) + RESOLUTION_FACTOR;
+			r.extent.height = (12 << RESOLUTION_FACTOR) + RES_CASE(0,1,17); // JMS_GFX
 			if (RepairSlot == 2)
 			{
 				r.corner = Top.origin;
 				DrawFilledRectangle (&r);
-				r.corner.y += 20;
-				DrawFilledRectangle (&r);
+				if (RESOLUTION_FACTOR == 2) {
+					r.corner.x += ship_piece_offset_scaled - r.extent.width;
+					DrawFilledRectangle (&r);
+					r.corner.x -= ship_piece_offset_scaled - r.extent.width;
+				}
+				r.corner.y += 20 << RESOLUTION_FACTOR; // JMS_GFX
+ 				DrawFilledRectangle (&r);
+				if (RESOLUTION_FACTOR == 2) {
+					r.corner.x += ship_piece_offset_scaled - r.extent.width;
+					DrawFilledRectangle (&r);
+					r.corner.x -= ship_piece_offset_scaled - r.extent.width;
+				}
 			}
 			RepairSlot = (which_slot < NUM_MODULE_SLOTS - 1);
 			if (RepairSlot)
 			{
 				r.corner = Top.origin;
-				r.corner.x += SHIP_PIECE_OFFSET;
+				r.corner.x += ship_piece_offset_scaled;
 				DrawFilledRectangle (&r);
-				r.corner.y += 20;
+				r.corner.y += 20 << RESOLUTION_FACTOR; // JMS_GFX
 				DrawFilledRectangle (&r);
 			}
 		}
@@ -231,26 +302,44 @@ DrawShipPiece (FRAME ModuleFrame, COUNT
 		DrawStamp (&Top);
 
 		Side.frame = SetRelFrameIndex (Top.frame, (NUM_MODULES - 1) + 6);
-		DrawStamp (&Side);
+		if (RESOLUTION_FACTOR != 0 
+			&& (which_piece == EMPTY_SLOT + 2 
+				|| which_piece == EMPTY_SLOT + 3))
+		{
+			if (which_slot == 0)
+				Side.frame = SetRelFrameIndex (Side.frame, 8);
+			if (which_slot == 1)
+				Side.frame = SetRelFrameIndex (Side.frame, 10);
+			if (which_slot == NUM_MODULE_SLOTS - 2)
+				Side.frame = SetRelFrameIndex (Side.frame, 10);
+			if (which_slot == NUM_MODULE_SLOTS - 1)
+				Side.frame = SetRelFrameIndex (Side.frame, 11);
+		}
+		
+		// JMS_GFX:
+		if (RESOLUTION_FACTOR == 0 ||
+			(which_piece != FUSION_THRUSTER && which_piece != TURNING_JETS
+			 && which_piece != EMPTY_SLOT + 0 && which_piece != EMPTY_SLOT + 1))
+			DrawStamp (&Side);
 
-		if (which_slot == 1 && which_piece == EMPTY_SLOT + 2)
+		if (which_slot == 1 && which_piece == EMPTY_SLOT + 2 && RESOLUTION_FACTOR == 0)
 		{
 			STAMP s;
 
 			s.origin = Top.origin;
-			s.origin.x -= SHIP_PIECE_OFFSET;
+			s.origin.x -= ship_piece_offset_scaled;
 			s.frame = SetAbsFrameIndex (ModuleFrame, NUM_MODULES + 5);
 			DrawStamp (&s);
 			s.origin = Side.origin;
-			s.origin.x -= SHIP_PIECE_OFFSET;
+			s.origin.x -= ship_piece_offset_scaled;
 			s.frame = SetRelFrameIndex (s.frame, (NUM_MODULES - 1) + 6);
 			DrawStamp (&s);
 		}
 
 		if (RepairSlot)
 		{
-			Top.origin.x += SHIP_PIECE_OFFSET;
-			Side.origin.x += SHIP_PIECE_OFFSET;
+			Top.origin.x += ship_piece_offset_scaled;
+			Side.origin.x += ship_piece_offset_scaled;
 			which_piece = GLOBAL_SIS (ModuleSlots[++which_slot]);
 			if (which_piece == EMPTY_SLOT + 2
 					&& which_slot >= NUM_MODULE_SLOTS - 3)
@@ -260,7 +349,25 @@ DrawShipPiece (FRAME ModuleFrame, COUNT
 			DrawStamp (&Top);
 
 			Side.frame = SetRelFrameIndex (Top.frame, (NUM_MODULES - 1) + 6);
-			DrawStamp (&Side);
+			if (RESOLUTION_FACTOR != 0)
+			{
+				if (which_slot == 0 && which_piece == EMPTY_SLOT + 3)
+					Side.frame = SetAbsFrameIndex (ModuleFrame, GetFrameCount (ModuleFrame)-4);
+				if (which_slot == 1 && which_piece == EMPTY_SLOT + 2)
+					Side.frame = SetAbsFrameIndex (ModuleFrame, GetFrameCount (ModuleFrame)-3);
+				if (which_slot == NUM_MODULE_SLOTS - 2 
+					&& which_piece == EMPTY_SLOT + 3)
+					Side.frame = SetAbsFrameIndex (ModuleFrame, GetFrameCount (ModuleFrame)-2);
+				if (which_slot == NUM_MODULE_SLOTS - 1 
+					&& which_piece == EMPTY_SLOT + 3)
+					Side.frame = SetAbsFrameIndex (ModuleFrame, GetFrameCount (ModuleFrame)-1);
+			}
+			
+			// JMS_GFX:
+			if (RESOLUTION_FACTOR == 0 ||
+				(which_piece != FUSION_THRUSTER && which_piece != TURNING_JETS
+				 && which_piece != EMPTY_SLOT + 0 && which_piece != EMPTY_SLOT + 1))
+				DrawStamp (&Side);
 		}
 	}
 }
diff -ruNp src.mm/uqm/status.c src/uqm/status.c
--- src.mm/uqm/status.c	2017-11-28 11:08:55 -0600
+++ src/uqm/status.c	2017-11-28 11:09:40 -0600
@@ -137,18 +137,18 @@ DrawBattleCrewAmount (SHIP_INFO *ShipInf
 	TEXT t;
 	UNICODE buf[40];
 
-	t.baseline.x = BATTLE_CREW_X + 2;
+	t.baseline.x = BATTLE_CREW_X + RES_STAT_SCALE(2) - RES_CASE(0,1,2); // JMS_GFX
 	if (optWhichMenu == OPT_PC)
-			t.baseline.x -= 8;
+			t.baseline.x -= RES_STAT_SCALE(8); // JMS_GFX
 	t.baseline.y = BATTLE_CREW_Y + y_offs;
 	t.align = ALIGN_LEFT;
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 
 	r.corner.x = t.baseline.x;
-	r.corner.y = t.baseline.y - 5;
-	r.extent.width = 6 * MAX_CREW_DIGITS + 6;
-	r.extent.height = 5;
+	r.corner.y = t.baseline.y - (5 << RESOLUTION_FACTOR); // JMS_GFX
+	r.extent.width = 6 * MAX_CREW_DIGITS + (6 << RESOLUTION_FACTOR) + RESOLUTION_FACTOR; // JMS_GFX
+	r.extent.height = (5 << RESOLUTION_FACTOR) + RES_CASE(0,2,3); // JMS_GFX
 
 	sprintf (buf, "%u", ShipInfoPtr->crew_level);
 	SetContextFont (StarConFont);
@@ -188,17 +188,19 @@ DrawCaptainsWindow (STARSHIP *StarShipPt
 
 	BatchGraphics ();
 	
+	// Grey area under and around captain's window.
 	assert (StarShipPtr->playerNr >= 0);
 	y_offs = status_y_offsets[StarShipPtr->playerNr];
 
-	r.corner.x = CAPTAIN_XOFFS - 2;
+	r.corner.x = CAPTAIN_XOFFS - RES_STAT_SCALE(4); // JMS_GFX
 	r.corner.y = y_offs + SHIP_INFO_HEIGHT;
-	r.extent.width = STATUS_WIDTH - CAPTAIN_XOFFS;
-	r.extent.height = SHIP_STATUS_HEIGHT - CAPTAIN_YOFFS + 2;
+	r.extent.width = STATUS_WIDTH - 2;
+	r.extent.height = SHIP_STATUS_HEIGHT - CAPTAIN_YOFFS + (4 << RESOLUTION_FACTOR); // JMS_GFX
 	SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
 	DrawFilledRectangle (&r);
 
+	// Left border of the status panel.
 	SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
 	r.corner.x = 1;
@@ -210,6 +212,7 @@ DrawCaptainsWindow (STARSHIP *StarShipPt
 	++r.extent.height;
 	DrawFilledRectangle (&r);
 
+	// Lower and right border of the status panel.
 	SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
 	r.corner.x = STATUS_WIDTH - 1;
@@ -231,30 +234,32 @@ DrawCaptainsWindow (STARSHIP *StarShipPt
 
 	y = y_offs + CAPTAIN_YOFFS;
 
+	// Darker grey rectangle at bottom and right of captain's window
 	SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
-	r.corner.x = 59;
+	r.corner.x = CAPTAIN_WIDTH + CAPTAIN_XOFFS;
 	r.corner.y = y;
 	r.extent.width = 1;
-	r.extent.height = 30;
+	r.extent.height = CAPTAIN_HEIGHT;
 	DrawFilledRectangle (&r);
-	r.corner.x = 3;
-	r.corner.y += 30;
-	r.extent.width = 57;
+	r.corner.x = CAPTAIN_XOFFS - 1;
+	r.corner.y += CAPTAIN_HEIGHT;
+	r.extent.width = CAPTAIN_WIDTH + 2;
 	r.extent.height = 1;
 	DrawFilledRectangle (&r);
 
+	// Light grey rectangle at top and left of captains window
 	SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
-	r.corner.x = 3;
-	r.extent.width = 57;
+	r.corner.x = CAPTAIN_XOFFS - 1;
+	r.extent.width = CAPTAIN_WIDTH + 2;
 	r.corner.y = y - 1;
 	r.extent.height = 1;
 	DrawFilledRectangle (&r);
-	r.corner.x = 3;
+	r.corner.x = CAPTAIN_XOFFS - 1;
 	r.extent.width = 1;
 	r.corner.y = y;
-	r.extent.height = 30;
+	r.extent.height = CAPTAIN_HEIGHT;
 	DrawFilledRectangle (&r);
 
 	s.frame = RDPtr->ship_data.captain_control.background;
@@ -268,12 +273,11 @@ DrawCaptainsWindow (STARSHIP *StarShipPt
 		TEXT t;
 
 		t.baseline.x = STATUS_WIDTH >> 1;
-		t.baseline.y = y + 6;
+		t.baseline.y = y + RES_CASE(6,-22,-44); // JMS_GFX
 		t.align = ALIGN_CENTER;
 		t.pStr = GLOBAL_SIS (CommanderName);
 		t.CharCount = (COUNT)~0;
-		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x00, 0x14, 0x00), 0x02));
+		SetContextForeGroundColor (RES_CASE(BUILD_COLOR (MAKE_RGB15 (0x00, 0x14, 0x00), 0x02), BLACK_COLOR, BLACK_COLOR));
 		SetContextFont (TinyFont);
 		font_DrawText (&t);
 	}
@@ -421,7 +425,7 @@ PostProcessStatus (ELEMENT *ShipPtr)
 
 			if (StarShipPtr->RaceDescPtr->ship_info.crew_level == 0)
 			{
-				BYTE i;
+				BYTE i, j;
 				Color c;
 				RECT r;
 
@@ -469,49 +473,56 @@ PostProcessStatus (ELEMENT *ShipPtr)
 						};
 
 						c = flash_tab1[i];
-						r.corner.x = CAPTAIN_XOFFS + i;
-						r.corner.y = y + CAPTAIN_YOFFS + i;
-						r.extent.width = CAPTAIN_WIDTH - (i << 1);
-						r.extent.height = CAPTAIN_HEIGHT - (i << 1);
+
+						// JMS_GFX
+						r.corner.x = CAPTAIN_XOFFS + RES_STAT_SCALE(i);
+						r.corner.y = y + CAPTAIN_YOFFS + RES_STAT_SCALE(i);
+						r.extent.width = CAPTAIN_WIDTH - RES_STAT_SCALE((i << 1));
+						r.extent.height = CAPTAIN_HEIGHT - RES_STAT_SCALE((i << 1));
+
 						if (r.extent.height == 2)
 							++r.extent.height;
-						DrawRectangle (&r);
-						++r.corner.x;
-						++r.corner.y;
-						r.extent.width -= 2;
-						r.extent.height -= 2;
+						
+						// JMS_GFX
+						for (j=0 ; j<RES_STAT_SCALE(1); j++) {
+							DrawRectangle (&r);
+							++r.corner.x;
+							++r.corner.y;
+							r.extent.width -= 2;
+							r.extent.height -= 2;
+						}
 					}
 					else if ((i -= 15) <= 4)
 					{
-						r.corner.y = y + (CAPTAIN_YOFFS + 15);
-						r.extent.width = i + 1;
+						r.corner.y = y + (CAPTAIN_YOFFS + RES_STAT_SCALE(15)); // JMS_GFX
+						r.extent.width = RES_STAT_SCALE(i + 1); // JMS_GFX
 						r.extent.height = 1;
 						switch (i)
 						{
 							case 0:
-								r.corner.x = CAPTAIN_XOFFS + 15;
-								i = CAPTAIN_WIDTH - ((15 + 1) << 1);
+								r.corner.x = CAPTAIN_XOFFS + RES_STAT_SCALE(15);
+								i = CAPTAIN_WIDTH - RES_STAT_SCALE((15 + 1) << 1);
 								c = BUILD_COLOR (MAKE_RGB15 (0x13, 0x00, 0x00), 0x2C);
 								break;
 							case 1:
-								r.corner.x = CAPTAIN_XOFFS + 16;
-								i = CAPTAIN_WIDTH - ((17 + 1) << 1);
+								r.corner.x = CAPTAIN_XOFFS + RES_STAT_SCALE(16);
+								i = CAPTAIN_WIDTH - RES_STAT_SCALE((17 + 1) << 1);
 								c = BUILD_COLOR (MAKE_RGB15 (0x07, 0x00, 0x00), 0x2F);
 								break;
 							case 2:
-								r.corner.x = CAPTAIN_XOFFS + 18;
-								i = CAPTAIN_WIDTH - ((20 + 1) << 1);
+								r.corner.x = CAPTAIN_XOFFS + RES_STAT_SCALE(18);
+								i = CAPTAIN_WIDTH - RES_STAT_SCALE((20 + 1) << 1);
 								c = BUILD_COLOR (MAKE_RGB15 (0x1B, 0x00, 0x00), 0x2A);
 								break;
 							case 3:
-								r.corner.x = CAPTAIN_XOFFS + 21;
-								i = CAPTAIN_WIDTH - ((24 + 1) << 1);
+								r.corner.x = CAPTAIN_XOFFS + RES_STAT_SCALE(21);
+								i = CAPTAIN_WIDTH - RES_STAT_SCALE((24 + 1) << 1);
 								c = BUILD_COLOR (MAKE_RGB15 (0x1F, 0x00, 0x00), 0x29);
 								break;
 							case 4:
-								r.corner.x = CAPTAIN_XOFFS + 25;
-								i = 1;
-								r.extent.width = 2;
+								r.corner.x = CAPTAIN_XOFFS + RES_STAT_SCALE(25);
+								i = RES_STAT_SCALE(1);
+								r.extent.width = RES_STAT_SCALE(2);
 								c = BUILD_COLOR (MAKE_RGB15 (0x1F, 0x50, 0x05), 0x28);
 								break;
 							default:
diff -ruNp src.mm/uqm/status.h src/uqm/status.h
--- src.mm/uqm/status.h	2017-11-28 11:08:55 -0600
+++ src/uqm/status.h	2017-11-28 11:09:40 -0600
@@ -26,36 +26,36 @@
 extern "C" {
 #endif
 
-#define CREW_XOFFS 4
-#define ENERGY_XOFFS 52
-#define GAUGE_YOFFS (SHIP_INFO_HEIGHT - 10)
-#define UNIT_WIDTH 2
-#define UNIT_HEIGHT 1
-#define STAT_WIDTH (1 + UNIT_WIDTH + 1 + UNIT_WIDTH + 1)
-
-#define SHIP_INFO_HEIGHT 65
-#define CAPTAIN_XOFFS 4
-#define CAPTAIN_YOFFS (SHIP_INFO_HEIGHT + 4)
-#define CAPTAIN_WIDTH 55
-#define CAPTAIN_HEIGHT 30
+#define CREW_XOFFS RES_STAT_SCALE(4) // JMS_GFX
+#define ENERGY_XOFFS (RES_STAT_SCALE(52) + (3 * RESOLUTION_FACTOR) + (RESOLUTION_FACTOR / 2)) // JMS_GFX
+#define GAUGE_YOFFS (SHIP_INFO_HEIGHT - (10 << RESOLUTION_FACTOR) + 6 * RESOLUTION_FACTOR) // JMS_GFX
+#define UNIT_WIDTH RES_STAT_SCALE(2)
+#define UNIT_HEIGHT (1 << RESOLUTION_FACTOR)
+#define STAT_WIDTH (1 + UNIT_WIDTH + 1 + UNIT_WIDTH + 1) // JMS_GFX
+
+#define SHIP_INFO_HEIGHT (65 << RESOLUTION_FACTOR) // JMS_GFX
+#define CAPTAIN_WIDTH RES_STAT_SCALE(55) // JMS_GFX
+#define CAPTAIN_HEIGHT RES_STAT_SCALE(30) // JMS_GFX
+#define CAPTAIN_XOFFS ((STATUS_WIDTH - CAPTAIN_WIDTH) >> 1) // JMS_GFX
+#define CAPTAIN_YOFFS (SHIP_INFO_HEIGHT + (4 << RESOLUTION_FACTOR)) // JMS_GFX
+
 #define SHIP_STATUS_HEIGHT (STATUS_HEIGHT >> 1)
 #define BAD_GUY_YOFFS 0
 #define GOOD_GUY_YOFFS SHIP_STATUS_HEIGHT
-#define STARCON_TEXT_HEIGHT 7
-#define TINY_TEXT_HEIGHT 9
 
-#define BATTLE_CREW_X 10
-#define BATTLE_CREW_Y (64 - SAFE_Y)
+#define STARCON_TEXT_HEIGHT (7 << RESOLUTION_FACTOR) // JMS_GFX
+#define TINY_TEXT_HEIGHT (9 << RESOLUTION_FACTOR) // JMS_GFX
+#define BATTLE_CREW_X RES_STAT_SCALE(10) // JMS_GFX
+#define BATTLE_CREW_Y ((64 - SAFE_Y) << RESOLUTION_FACTOR) // JMS_GFX
 
 extern COORD status_y_offsets[];
 
 extern void InitStatusOffsets (void);
 
 extern void DrawCrewFuelString (COORD y, SIZE state);
-extern void ClearShipStatus (COORD y);
-extern void OutlineShipStatus (COORD y);
-extern void InitShipStatus (SHIP_INFO *ShipInfoPtr, STARSHIP *StarShipPtr,
-		RECT *pClipRect);
+extern void ClearShipStatus (COORD y, COORD w, BOOLEAN inMeleeMenu);
+extern void OutlineShipStatus (COORD y, COORD w, BOOLEAN inMeleeMenu); // JMS: now is needed elsewhere
+extern void InitShipStatus (SHIP_INFO *ShipInfoPtr, STARSHIP *StarShipPtr, RECT *pClipRect, BOOLEAN inMeleeMenu);
 			// StarShipPtr or pClipRect can be NULL
 extern void DeltaStatistics (SHIP_INFO *ShipInfoPtr, COORD y_offs,
 		SIZE crew_delta, SIZE energy_delta);
diff -ruNp src.mm/uqm/supermelee/melee.c src/uqm/supermelee/melee.c
--- src.mm/uqm/supermelee/melee.c	2017-11-28 11:08:55 -0600
+++ src/uqm/supermelee/melee.c	2017-11-28 11:09:40 -0600
@@ -881,7 +881,12 @@ DrawMeleeShipStrings (MELEE_STATE *pMS,
 		RECT r;
 		TEXT t;
 
-		ClearShipStatus (0);
+		ClearShipStatus (0, STATUS_WIDTH, TRUE);
+		
+		// JMS_GFX
+		if (RESOLUTION_FACTOR > 0)
+			OutlineShipStatus (0, STATUS_WIDTH, TRUE);
+		
 		SetContextFont (StarConFont);
 		r.corner.x = 3;
 		r.corner.y = 4;
@@ -920,7 +925,7 @@ DrawMeleeShipStrings (MELEE_STATE *pMS,
 		hMasterShip = GetStarShipFromIndex (&master_q, NewStarShip);
 		MasterPtr = LockMasterShip (&master_q, hMasterShip);
 
-		InitShipStatus (&MasterPtr->ShipInfo, NULL, NULL);
+		InitShipStatus (&MasterPtr->ShipInfo, NULL, NULL, TRUE);
 
 		UnlockMasterShip (&master_q, hMasterShip);
 	}
diff -ruNp src.mm/uqm/tactrans.c src/uqm/tactrans.c
--- src.mm/uqm/tactrans.c	2017-11-28 11:08:57 -0600
+++ src/uqm/tactrans.c	2017-11-28 11:09:41 -0600
@@ -904,7 +904,7 @@ ship_transition (ELEMENT *ElementPtr)
 		}
 		else if ((hShipImage = AllocElement ()))
 		{
-#define TRANSITION_SPEED DISPLAY_TO_WORLD (40)
+#define TRANSITION_SPEED DISPLAY_TO_WORLD ((40 << RESOLUTION_FACTOR)) // JMS_GFX
 #define TRANSITION_LIFE 1
 			COUNT angle;
 
diff -ruNp src.mm/uqm/trans.c src/uqm/trans.c
--- src.mm/uqm/trans.c	2017-11-28 11:08:57 -0600
+++ src/uqm/trans.c	2017-11-28 11:09:41 -0600
@@ -89,9 +89,9 @@ SDWORD sinetab[] =
 };
 
 COUNT
-ARCTAN (SIZE delta_x, SIZE delta_y)
+ARCTAN (SDWORD delta_x, SDWORD delta_y)
 {
-	SIZE v1, v2;
+	SDWORD v1, v2;
 	static COUNT atantab[] =
 	{
 		0,
diff -ruNp src.mm/uqm/units.h src/uqm/units.h
--- src.mm/uqm/units.h	2017-11-28 11:08:57 -0600
+++ src/uqm/units.h	2017-11-28 11:09:41 -0600
@@ -27,47 +27,63 @@ extern "C" {
 
 extern int ScreenWidth;
 extern int ScreenHeight;
+extern unsigned int resolutionFactor; // JMS_GFX
 
+		/* Most basic resolution units. */
 #define SCREEN_WIDTH ScreenWidth
 #define SCREEN_HEIGHT ScreenHeight
+#define RESOLUTION_FACTOR resolutionFactor														// JMS_GFX
+#define RES_CASE(a,b,c) (RESOLUTION_FACTOR == 0 ? (a) : (RESOLUTION_FACTOR == 1 ? (b) : (c)))	// JMS_GFX
+#define RES_STAT_SCALE(a) (RESOLUTION_FACTOR < 2 ? ((a) << RESOLUTION_FACTOR) : ((a) * 3))		// JMS_GFX
+
+		/* Margins. */
 #define SAFE_X 0
-		/* Left and right screen margin to be left unused */
+/* Left and right screen margin to be left unused */
 #define SAFE_Y 0
-		/* Top and bottom screen margin to be left unused */
-#define SIS_ORG_X (7 + SAFE_X)
-#define SIS_ORG_Y (10 + SAFE_Y)
-#define STATUS_WIDTH 64
-		/* Width of the status "window" (the right part of the screen) */
+/* Top and bottom screen margin to be left unused */
+#define SIS_ORG_X (7 + SAFE_X)								// JMS_GFX
+//#define SIS_ORG_X (7 * RESOLUTION_FACTOR + SAFE_X)	// JMS_GFX
+#define SIS_ORG_Y RES_CASE(10, 20, 30)						// DC: top status window. Manually entered in for 4x mode.
+//#define SIS_ORG_Y (10 * RESOLUTION_FACTOR + SAFE_Y)	// JMS_GFX
+
+/* Status bar & play area sizes. */
+#define STATUS_WIDTH RES_STAT_SCALE(64)
+/* Width of the status "window" (the right part of the screen) */
 #define STATUS_HEIGHT (SCREEN_HEIGHT - (SAFE_Y * 2))
-		/* Height of the status "window" (the right part of the screen) */
+/* Height of the status "window" (the right part of the screen) */
 #define SPACE_WIDTH (SCREEN_WIDTH - STATUS_WIDTH - (SAFE_X * 2))
-		/* Width of the space "window" (the left part of the screen) */
+/* Width of the space "window" (the left part of the screen) */
 #define SPACE_HEIGHT (SCREEN_HEIGHT - (SAFE_Y * 2))
-		/* Height of the space "window" (the left part of the screen) */
-#define SIS_SCREEN_WIDTH (SPACE_WIDTH - 14)
-		/* Width of the usable part of the space "window" */
-#define SIS_SCREEN_HEIGHT (SPACE_HEIGHT - 13)
-		/* Height of the usable part of the space "window" */
-#define RADAR_X (4 + (SCREEN_WIDTH - STATUS_WIDTH - SAFE_X))
-#define RADAR_WIDTH (STATUS_WIDTH - 8)
-#define RADAR_HEIGHT 53
-#define RADAR_Y (SIS_ORG_Y + SIS_SCREEN_HEIGHT - RADAR_HEIGHT)
-
-#define SIS_TITLE_BOX_WIDTH    57
-#define SIS_TITLE_WIDTH        (SIS_TITLE_BOX_WIDTH - 2)
-#define SIS_TITLE_HEIGHT       8
-#define SIS_SPACER_BOX_WIDTH   12
-#define SIS_MESSAGE_BOX_WIDTH  (SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH \
-			- SIS_SPACER_BOX_WIDTH)
+/* Height of the space "window" (the left part of the screen) */
+#define SIS_SCREEN_WIDTH (SPACE_WIDTH - 2 * SIS_ORG_X) // DC: Gray area on the right. just a spacer box
+/* Width of the usable part of the space "window" */
+#define SIS_SCREEN_HEIGHT (SPACE_HEIGHT - RES_CASE(3,6,6) - RES_CASE(10,20,30)) // JMS_GFX
+/* Height of the usable part of the space "window": 3, 6, 6 for the grey bottom border and 10, 20, 30 for the title */
+#define RES_SIS_SCALE(a) ((SIZE)(a) * SIS_SCREEN_WIDTH / 242) // JMS_GFX
+
+		/* Radar. */
+#define RADAR_X (RES_STAT_SCALE(4) + (SCREEN_WIDTH - STATUS_WIDTH - SAFE_X))	// JMS_GFX
+#define RADAR_WIDTH (STATUS_WIDTH - RES_STAT_SCALE(8))							// JMS_GFX
+#define RADAR_HEIGHT RES_STAT_SCALE(53)											// JMS_GFX
+#define RADAR_Y (SIS_ORG_Y + SIS_SCREEN_HEIGHT - (53 << RESOLUTION_FACTOR))		// JMS_GFX
+
+		/* Blue boxes which display messages and the green date box. */
+#define SIS_TITLE_BOX_WIDTH    (57 << RESOLUTION_FACTOR)						// JMS_GFX
+#define SIS_TITLE_WIDTH        (SIS_TITLE_BOX_WIDTH - (2 << RESOLUTION_FACTOR)) // JMS_GFX
+#define SIS_TITLE_HEIGHT       RES_CASE(8,19,29)								// JMS_GFX
+#define SIS_SPACER_BOX_WIDTH   (12 << RESOLUTION_FACTOR)						// JMS_GFX
+
+#define SIS_MESSAGE_BOX_WIDTH  (SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH - SIS_SPACER_BOX_WIDTH)
 #define SIS_MESSAGE_WIDTH      (SIS_MESSAGE_BOX_WIDTH - 2)
 #define SIS_MESSAGE_HEIGHT     SIS_TITLE_HEIGHT
 
-#define STATUS_MESSAGE_WIDTH   (STATUS_WIDTH - 4)
-#define STATUS_MESSAGE_HEIGHT  7
+#define STATUS_MESSAGE_WIDTH   (STATUS_WIDTH - RES_CASE(4,6,7))	 // JMS_GFX
+#define STATUS_MESSAGE_HEIGHT  RES_CASE(7,14,24) // JMS_GFX
 
-#define SHIP_NAME_WIDTH        (STATUS_WIDTH - 4)
-#define SHIP_NAME_HEIGHT       7
+#define SHIP_NAME_WIDTH        (STATUS_WIDTH - RES_CASE(4,6,9))// JMS_GFX
+#define SHIP_NAME_HEIGHT       (RES_STAT_SCALE(7) - RES_CASE(0,0,4)) // JMS_GFX
 
+		/* A lot of other shit. */
 #define MAX_REDUCTION 3
 #define MAX_VIS_REDUCTION 2
 #define REDUCTION_SHIFT 1
@@ -81,42 +97,35 @@ extern int ScreenHeight;
 #define SCALED_ONE (1 << ONE_SHIFT)
 #define DISPLAY_TO_WORLD(x) ((x)<<ONE_SHIFT)
 #define WORLD_TO_DISPLAY(x) ((x)>>ONE_SHIFT)
+
 // JMS_GFX: Changed from COORD to SDWORD and from COUNT to DWORD
 #define DISPLAY_ALIGN(x) ((SDWORD)(x)&~(SCALED_ONE-1))
 #define DISPLAY_ALIGN_X(x) ((SDWORD)((DWORD)(x)%LOG_SPACE_WIDTH)&~(SCALED_ONE-1))
 #define DISPLAY_ALIGN_Y(y) ((SDWORD)((DWORD)(y)%LOG_SPACE_HEIGHT)&~(SCALED_ONE-1))
 
-#define LOG_SPACE_WIDTH \
-		(DISPLAY_TO_WORLD (SPACE_WIDTH) << MAX_REDUCTION)
-#define LOG_SPACE_HEIGHT \
-		(DISPLAY_TO_WORLD (SPACE_HEIGHT) << MAX_REDUCTION)
-#define TRANSITION_WIDTH \
-		(DISPLAY_TO_WORLD (SPACE_WIDTH) << MAX_VIS_REDUCTION)
-#define TRANSITION_HEIGHT \
-		(DISPLAY_TO_WORLD (SPACE_HEIGHT) << MAX_VIS_REDUCTION)
-		
+#define LOG_SPACE_WIDTH   (DISPLAY_TO_WORLD (SPACE_WIDTH) << MAX_REDUCTION)
+#define LOG_SPACE_HEIGHT  (DISPLAY_TO_WORLD (SPACE_HEIGHT) << MAX_REDUCTION)
+#define TRANSITION_WIDTH  (DISPLAY_TO_WORLD (SPACE_WIDTH) << MAX_VIS_REDUCTION)
+#define TRANSITION_HEIGHT (DISPLAY_TO_WORLD (SPACE_HEIGHT) << MAX_VIS_REDUCTION)
+
 #define MAX_X_UNIVERSE 9999
 #define MAX_Y_UNIVERSE 9999
-// Due to the added rounding error correction, the maximum logical X and Y
-// in Hyperspace cannot go past 999.94999, otherwise the values will be
-// rounded up to 1000.0. We do not want that so we subtract half a unit.
 #define MAX_X_LOGICAL \
-		(UNIVERSE_TO_LOGX (MAX_X_UNIVERSE + 1) - (UNIVERSE_TO_LOGX (1) >> 1) \
-			- 1L)
-// The Y axis is inverted with respect to the screen Y axis.
-// (MAX_Y_UNIVERSE - 1) is really 1 for our purposes.
+((UNIVERSE_TO_LOGX (MAX_X_UNIVERSE + 1) > UNIVERSE_TO_LOGX (-1) ? \
+UNIVERSE_TO_LOGX (MAX_X_UNIVERSE + 1) : UNIVERSE_TO_LOGX (-1)) - 1L)
 #define MAX_Y_LOGICAL \
-		(UNIVERSE_TO_LOGY (-1) - (UNIVERSE_TO_LOGY (MAX_Y_UNIVERSE - 1) >> 1) \
-			- 1L)
+((UNIVERSE_TO_LOGY (MAX_Y_UNIVERSE + 1) > UNIVERSE_TO_LOGY (-1) ? \
+UNIVERSE_TO_LOGY (MAX_Y_UNIVERSE + 1) : UNIVERSE_TO_LOGY (-1)) - 1L)
 
 #define SPHERE_RADIUS_INCREMENT 11
-
 #define MAX_FLEET_STRENGTH (254 * SPHERE_RADIUS_INCREMENT)
 
 // XXX: These corrected for the weird screen aspect ratio on DOS
 //   In part because of them, hyperflight is slower vertically
-#define UNIT_SCREEN_WIDTH 63
-#define UNIT_SCREEN_HEIGHT 50
+#define UNIT_SCREEN_WIDTH ((63 << (COUNT)RESOLUTION_FACTOR) + (COUNT)RESOLUTION_FACTOR * 10) // JMS_GFX
+#define UNIT_SCREEN_HEIGHT ((50 << (COUNT)RESOLUTION_FACTOR) + (COUNT)RESOLUTION_FACTOR * 10) // JMS_GFX
+
+#define NORMALIZED_HYPERSPACE_SPEED // JMS_GFX
 
 // Bug #945: Simplified, these set the speed of SIS in Hyperspace and
 //   Quasispace. The ratio between UNIVERSE_UNITS_ and LOG_UNITS_ is
@@ -126,14 +135,12 @@ extern int ScreenHeight;
 //   on the screen resolution when it should not.
 //   Using the new math will break old savegames.
 #ifdef NORMALIZED_HYPERSPACE_SPEED
-#define LOG_UNITS_X      ((SDWORD)(UNIVERSE_UNITS_X * 16))
-#define LOG_UNITS_Y      ((SDWORD)(UNIVERSE_UNITS_Y * 16))
+#define LOG_UNITS_X      ((SDWORD)(UNIVERSE_UNITS_X * (16 << RESOLUTION_FACTOR))) // JMS_GFX
+#define LOG_UNITS_Y      ((SDWORD)(UNIVERSE_UNITS_Y * (16 << RESOLUTION_FACTOR))) // JMS_GFX 
 #define UNIVERSE_UNITS_X (((MAX_X_UNIVERSE + 1) >> 4))
 #define UNIVERSE_UNITS_Y (((MAX_Y_UNIVERSE + 1) >> 4))
 #else
 // Original (and now broken) Hyperspace speed factors
-#define SECTOR_WIDTH 195
-#define SECTOR_HEIGHT 25
 
 #define LOG_UNITS_X      ((SDWORD)(LOG_SPACE_WIDTH >> 4) * SECTOR_WIDTH)
 #define LOG_UNITS_Y      ((SDWORD)(LOG_SPACE_HEIGHT >> 4) * SECTOR_HEIGHT)
@@ -143,18 +150,18 @@ extern int ScreenHeight;
 
 #define ROUNDING_ERROR(div)  ((div) >> 1)
 
-static inline COORD
+static inline SDWORD
 logxToUniverse (SDWORD lx)
 {
-	return (COORD) ((lx * UNIVERSE_UNITS_X + ROUNDING_ERROR(LOG_UNITS_X))
+	return (SDWORD) ((lx * UNIVERSE_UNITS_X + ROUNDING_ERROR(LOG_UNITS_X))
 			/ LOG_UNITS_X);
 }
 #define LOGX_TO_UNIVERSE(lx) \
 		logxToUniverse (lx)
-static inline COORD
+static inline SDWORD
 logyToUniverse (SDWORD ly)
 {
-	return (COORD) (MAX_Y_UNIVERSE -
+	return (SDWORD) (MAX_Y_UNIVERSE -
 			((ly * UNIVERSE_UNITS_Y + ROUNDING_ERROR(LOG_UNITS_Y))
 			/ LOG_UNITS_Y));
 }
@@ -208,11 +215,11 @@ universeToLogy (COORD uy)
 extern SDWORD sinetab[];
 #define SINVAL(a) sinetab[NORMALIZE_ANGLE(a)]
 #define COSVAL(a) SINVAL((a)+QUADRANT)
-#define SINE(a,m) ((SIZE)((((long)SINVAL(a))*(long)(m))>>SIN_SHIFT))
+#define SINE(a,m) ((SDWORD)((((long)SINVAL(a))*(long)(m))>>SIN_SHIFT)) // JMS: SDWORD was SIZE. Changed to avoid overflows in hires.
 #define COSINE(a,m) SINE((a)+QUADRANT,m)
-extern COUNT ARCTAN (SIZE delta_x, SIZE delta_y);
+extern COUNT ARCTAN (SDWORD delta_x, SDWORD delta_y); // JMS: SDWORD was SIZE. Changed to avoid overflows in hires.
 
-#define WRAP_VAL(v,w) ((COUNT)((v)<0?((v)+(w)):((v)>=(w)?((v)-(w)):(v))))
+#define WRAP_VAL(v,w) ((DWORD)((v)<0?((v)+(w)):((v)>=(w)?((v)-(w)):(v)))) // JMS: DWORD was COUNT. Changed to avoid overflows in hires.
 #define WRAP_X(x) WRAP_VAL(x,LOG_SPACE_WIDTH)
 #define WRAP_Y(y) WRAP_VAL(y,LOG_SPACE_HEIGHT)
 #define WRAP_DELTA_X(dx) ((dx)<0 ? \
diff -ruNp src.mm/uqm/velocity.c src/uqm/velocity.c
--- src.mm/uqm/velocity.c	2017-11-28 11:08:57 -0600
+++ src/uqm/velocity.c	2017-11-28 11:09:41 -0600
@@ -20,7 +20,7 @@
 
 #include "units.h"
 #include "libs/compiler.h"
-
+#include "libs/log.h"
 
 #define VELOCITY_REMAINDER(v) ((v) & (VELOCITY_SCALE - 1))
 
@@ -28,40 +28,78 @@ void
 GetCurrentVelocityComponents (VELOCITY_DESC *velocityptr, SIZE *pdx, SIZE *pdy)
 {
 	*pdx = WORLD_TO_VELOCITY (velocityptr->vector.width)
-			+ (velocityptr->fract.width - (SIZE)HIBYTE (velocityptr->incr.width));
+	+ (velocityptr->fract.width - (SIZE)HIBYTE (velocityptr->incr.width));
 	*pdy = WORLD_TO_VELOCITY (velocityptr->vector.height)
-			+ (velocityptr->fract.height - (SIZE)HIBYTE (velocityptr->incr.height));
+	+ (velocityptr->fract.height - (SIZE)HIBYTE (velocityptr->incr.height));
 }
 
 void
-GetNextVelocityComponents (VELOCITY_DESC *velocityptr, SIZE *pdx, SIZE *pdy,
-		COUNT num_frames)
+GetCurrentVelocityComponentsSdword (VELOCITY_DESC *velocityptr, SDWORD *pdx, SDWORD *pdy)
 {
-	COUNT e;
+	*pdx = WORLD_TO_VELOCITY (velocityptr->vector.width)
+	+ ((SDWORD)velocityptr->fract.width - (SDWORD)HIBYTE (velocityptr->incr.width));
+	*pdy = WORLD_TO_VELOCITY (velocityptr->vector.height)
+	+ ((SDWORD)velocityptr->fract.height - (SDWORD)HIBYTE (velocityptr->incr.height));
+}
 
+void
+GetNextVelocityComponents (VELOCITY_DESC *velocityptr, SIZE *pdx, SIZE *pdy, COUNT num_frames)
+{
+	COUNT e;
+	
 	e = (COUNT)((COUNT)velocityptr->error.width +
-			((COUNT)velocityptr->fract.width * num_frames));
+				((COUNT)velocityptr->fract.width * num_frames));
+	
 	*pdx = (velocityptr->vector.width * num_frames)
-			+ ((SIZE)((SBYTE)LOBYTE (velocityptr->incr.width))
-			* (e >> VELOCITY_SHIFT));
+	+ ((SIZE)((SBYTE)LOBYTE (velocityptr->incr.width))
+	   * (e >> VELOCITY_SHIFT));
+	
 	velocityptr->error.width = VELOCITY_REMAINDER (e);
-
+	
 	e = (COUNT)((COUNT)velocityptr->error.height +
-			((COUNT)velocityptr->fract.height * num_frames));
+				((COUNT)velocityptr->fract.height * num_frames));
+	
 	*pdy = (velocityptr->vector.height * num_frames)
-			+ ((SIZE)((SBYTE)LOBYTE (velocityptr->incr.height))
-			* (e >> VELOCITY_SHIFT));
+	+ ((SIZE)((SBYTE)LOBYTE (velocityptr->incr.height))
+	   * (e >> VELOCITY_SHIFT));
+	
 	velocityptr->error.height = VELOCITY_REMAINDER (e);
 }
 
+// JMS_GFX: New function to prevent overflows in hi-res.
+void
+GetNextVelocityComponentsSdword (VELOCITY_DESC *velocityptr, SDWORD *pdx, SDWORD *pdy, DWORD num_frames)
+{
+	DWORD e;
+	
+	e = (DWORD)((DWORD)velocityptr->error.width +
+				((DWORD)velocityptr->fract.width * num_frames));
+	
+	*pdx = ((SDWORD)velocityptr->vector.width * num_frames)
+	+ ((SDWORD)((SBYTE)LOBYTE (velocityptr->incr.width))
+	   * (e >> VELOCITY_SHIFT));
+	
+	velocityptr->error.width = (COUNT)(VELOCITY_REMAINDER (e));
+	
+	e = (DWORD)((DWORD)velocityptr->error.height +
+				((DWORD)velocityptr->fract.height * num_frames));
+	
+	*pdy = ((SDWORD)velocityptr->vector.height * num_frames)
+	+ ((SDWORD)((SBYTE)LOBYTE (velocityptr->incr.height))
+	   * (e >> VELOCITY_SHIFT));
+	
+	velocityptr->error.height = (COUNT)(VELOCITY_REMAINDER (e));
+}
+
+// JMS_GFX: Preventing overflows in hi-res: The SDWORD in this function's parameters was SIZE.
 void
-SetVelocityVector (VELOCITY_DESC *velocityptr, SIZE magnitude, COUNT facing)
+SetVelocityVector (VELOCITY_DESC *velocityptr, SDWORD magnitude, COUNT facing)
 {
 	COUNT angle;
 	SIZE dx, dy;
-
+	
 	angle = velocityptr->TravelAngle =
-			FACING_TO_ANGLE (NORMALIZE_FACING (facing));
+	FACING_TO_ANGLE (NORMALIZE_FACING (facing));
 	magnitude = WORLD_TO_VELOCITY (magnitude);
 	dx = COSINE (angle, magnitude);
 	dy = SINE (angle, magnitude);
@@ -75,7 +113,7 @@ SetVelocityVector (VELOCITY_DESC *veloci
 		dx = -dx;
 		velocityptr->vector.width = -VELOCITY_TO_WORLD (dx);
 		velocityptr->incr.width =
-				MAKE_WORD ((BYTE)0xFF, (BYTE)(VELOCITY_REMAINDER (dx) << 1));
+		MAKE_WORD ((BYTE)0xFF, (BYTE)(VELOCITY_REMAINDER (dx) << 1));
 	}
 	if (dy >= 0)
 	{
@@ -87,19 +125,20 @@ SetVelocityVector (VELOCITY_DESC *veloci
 		dy = -dy;
 		velocityptr->vector.height = -VELOCITY_TO_WORLD (dy);
 		velocityptr->incr.height =
-				MAKE_WORD ((BYTE)0xFF, (BYTE)(VELOCITY_REMAINDER (dy) << 1));
+		MAKE_WORD ((BYTE)0xFF, (BYTE)(VELOCITY_REMAINDER (dy) << 1));
 	}
-
+	
 	velocityptr->fract.width = VELOCITY_REMAINDER (dx);
 	velocityptr->fract.height = VELOCITY_REMAINDER (dy);
 	velocityptr->error.width = velocityptr->error.height = 0;
 }
 
+// JMS_GFX: Preventing overflows in hi-res: The SDWORDs in this function's parameters were SIZEs.
 void
-SetVelocityComponents (VELOCITY_DESC *velocityptr, SIZE dx, SIZE dy)
+SetVelocityComponents (VELOCITY_DESC *velocityptr, SDWORD dx, SDWORD dy)
 {
 	COUNT angle;
-
+	
 	if ((angle = ARCTAN (dx, dy)) == FULL_CIRCLE)
 	{
 		ZeroVelocityComponents (velocityptr);
@@ -115,8 +154,7 @@ SetVelocityComponents (VELOCITY_DESC *ve
 		{
 			dx = -dx;
 			velocityptr->vector.width = -VELOCITY_TO_WORLD (dx);
-			velocityptr->incr.width =
-					MAKE_WORD ((BYTE)0xFF, (BYTE)(VELOCITY_REMAINDER (dx) << 1));
+			velocityptr->incr.width = MAKE_WORD ((BYTE)0xFF, (BYTE)(VELOCITY_REMAINDER (dx) << 1));
 		}
 		if (dy >= 0)
 		{
@@ -127,27 +165,27 @@ SetVelocityComponents (VELOCITY_DESC *ve
 		{
 			dy = -dy;
 			velocityptr->vector.height = -VELOCITY_TO_WORLD (dy);
-			velocityptr->incr.height =
-					MAKE_WORD ((BYTE)0xFF, (BYTE)(VELOCITY_REMAINDER (dy) << 1));
+			velocityptr->incr.height = MAKE_WORD ((BYTE)0xFF, (BYTE)(VELOCITY_REMAINDER (dy) << 1));
 		}
-
+		
 		velocityptr->fract.width = VELOCITY_REMAINDER (dx);
 		velocityptr->fract.height = VELOCITY_REMAINDER (dy);
 		velocityptr->error.width = velocityptr->error.height = 0;
 	}
-
+	
 	velocityptr->TravelAngle = angle;
 }
 
+// JMS_GFX: Preventing overflows in hi-res: The SDWORDs in this function's parameters were SIZEs.
 void
-DeltaVelocityComponents (VELOCITY_DESC *velocityptr, SIZE dx, SIZE dy)
+DeltaVelocityComponents (VELOCITY_DESC *velocityptr, SDWORD dx, SDWORD dy)
 {
-
+	
 	dx += WORLD_TO_VELOCITY (velocityptr->vector.width)
-			+ (velocityptr->fract.width - (SIZE)HIBYTE (velocityptr->incr.width));
+	+ (velocityptr->fract.width - (SIZE)HIBYTE (velocityptr->incr.width));
 	dy += WORLD_TO_VELOCITY (velocityptr->vector.height)
-			+ (velocityptr->fract.height - (SIZE)HIBYTE (velocityptr->incr.height));
-
+	+ (velocityptr->fract.height - (SIZE)HIBYTE (velocityptr->incr.height));
+	
 	SetVelocityComponents (velocityptr, dx, dy);
 }
 
diff -ruNp src.mm/uqm/velocity.h src/uqm/velocity.h
--- src.mm/uqm/velocity.h	2017-11-28 11:08:57 -0600
+++ src/uqm/velocity.h	2017-11-28 11:09:41 -0600
@@ -38,16 +38,21 @@ typedef struct velocity_desc
 #define ZeroVelocityComponents(pv) memset(pv,0,sizeof (*(pv)))
 #define GetVelocityTravelAngle(pv) (pv)->TravelAngle
 
-extern void GetCurrentVelocityComponents (VELOCITY_DESC *velocityptr,
-		SIZE *pdx, SIZE *pdy);
-extern void GetNextVelocityComponents (VELOCITY_DESC *velocityptr,
-		SIZE *pdx, SIZE *pdy, COUNT num_frames);
-extern void SetVelocityVector (VELOCITY_DESC *velocityptr, SIZE magnitude,
-		COUNT facing);
-extern void SetVelocityComponents (VELOCITY_DESC *velocityptr, SIZE dx,
-		SIZE dy);
-extern void DeltaVelocityComponents (VELOCITY_DESC *velocityptr, SIZE dx,
-		SIZE dy);
+extern void GetCurrentVelocityComponents (VELOCITY_DESC *velocityptr, SIZE *pdx, SIZE *pdy);
+
+// JMS_GFX: New function to prevent overflows in hi-res.
+extern void GetCurrentVelocityComponentsSdword (VELOCITY_DESC *velocityptr, SDWORD *pdx, SDWORD *pdy);
+
+extern void GetNextVelocityComponents (VELOCITY_DESC *velocityptr, SIZE *pdx, SIZE *pdy, COUNT num_frames);
+
+// JMS_GFX: New function to prevent overflows in hi-res.
+extern void GetNextVelocityComponentsSdword (VELOCITY_DESC *velocityptr, SDWORD *pdx, SDWORD *pdy, DWORD num_frames);
+
+extern void SetVelocityVector (VELOCITY_DESC *velocityptr, SDWORD magnitude, COUNT facing); // JMS_GFX: Changed SIZE to SDWORD to prevent overflows
+
+extern void SetVelocityComponents (VELOCITY_DESC *velocityptr, SDWORD dx, SDWORD dy); // JMS_GFX: Changed SIZE to SDWORD to prevent overflows
+
+extern void DeltaVelocityComponents (VELOCITY_DESC *velocityptr, SDWORD dx, SDWORD dy); // JMS_GFX: Changed SIZE to SDWORD to prevent overflows
 
 static inline bool
 IsVelocityZero (VELOCITY_DESC *vptr)
diff -ruNp src.mm/uqm/weapon.c src/uqm/weapon.c
--- src.mm/uqm/weapon.c	2017-11-28 11:08:57 -0600
+++ src/uqm/weapon.c	2017-11-28 11:09:41 -0600
@@ -285,7 +285,7 @@ ModifySilhouette (ELEMENT *ElementPtr, S
 				&ShipIntersect, MAX_TIME_VALUE));
 
 		ObjectIntersect.IntersectStamp.origin.x += STATUS_WIDTH >> 1;
-		ObjectIntersect.IntersectStamp.origin.y += 31;
+		ObjectIntersect.IntersectStamp.origin.y += (31 << RESOLUTION_FACTOR); // JMS_GFX
 	}
 
 	ObjectIntersect.IntersectStamp.origin.y +=
@@ -296,7 +296,7 @@ ModifySilhouette (ELEMENT *ElementPtr, S
 		or.corner.x += ObjectIntersect.IntersectStamp.origin.x;
 		or.corner.y += ObjectIntersect.IntersectStamp.origin.y;
 		InitShipStatus (&StarShipPtr->RaceDescPtr->ship_info,
-				StarShipPtr, &or);
+				StarShipPtr, &or, FALSE);
 	}
 	else
 	{
diff -ruNp src.mm/uqm.c src/uqm.c
--- src.mm/uqm.c	2017-11-28 11:08:57 -0600
+++ src/uqm.c	2017-11-28 11:09:41 -0600
@@ -130,6 +130,9 @@ struct options_struct
 	DECL_CONFIG_OPTION(float, sfxVolumeScale);
 	DECL_CONFIG_OPTION(float, speechVolumeScale);
 	DECL_CONFIG_OPTION(bool, safeMode);
+	DECL_CONFIG_OPTION(int, resolutionFactor); // JMS_GFX
+	DECL_CONFIG_OPTION(bool, forceAspectRatio); // JMS_GFX
+	DECL_CONFIG_OPTION(int, loresBlowupScale); // JMS_GFX
  	DECL_CONFIG_OPTION(bool, cheatMode); // JMS
 	// Serosis
 	DECL_CONFIG_OPTION(bool, godMode);
@@ -287,6 +290,9 @@ main (int argc, char *argv[])
 		INIT_CONFIG_OPTION(  sfxVolumeScale,    1.0f ),
 		INIT_CONFIG_OPTION(  speechVolumeScale, 0.8f ),
 		INIT_CONFIG_OPTION(  safeMode,          false ),
+		INIT_CONFIG_OPTION(  resolutionFactor,  0 ),
+		INIT_CONFIG_OPTION(  forceAspectRatio,  false ),
+		INIT_CONFIG_OPTION(  loresBlowupScale,  0 ),
 		INIT_CONFIG_OPTION(  cheatMode,			false ), // JMS
 		//Serosis
 		INIT_CONFIG_OPTION(  godMode,			false ), 
@@ -437,6 +443,10 @@ main (int argc, char *argv[])
 	speechVolumeScale = options.speechVolumeScale.value;
 	optAddons = options.addons;
 	
+	resolutionFactor = (unsigned int) options.resolutionFactor.value; // JMS_GFX
+	forceAspectRatio = options.forceAspectRatio.value; // JMS_GFX
+	loresBlowupScale = (unsigned int) options.loresBlowupScale.value; // JMS_GFX
+	
 	optGodMode = options.godMode.value; // JMS
 	// Serosis
 	timeDilationScale = options.timeDilationScale.value;
@@ -492,7 +502,7 @@ main (int argc, char *argv[])
 	if (options.showFps.value)
 		gfxFlags |= TFB_GFXFLAGS_SHOWFPS;
 	TFB_InitGraphics (gfxDriver, gfxFlags, options.resolution.width,
-			options.resolution.height);
+			options.resolution.height, &resolutionFactor);
 	if (options.gamma.set && setGammaCorrection (options.gamma.value))
 		optGamma = options.gamma.value;
 	else
@@ -744,6 +754,22 @@ getUserConfigOptions (struct options_str
 	getVolumeConfigValue (&options->musicVolumeScale, "config.musicvol");
 	getVolumeConfigValue (&options->sfxVolumeScale, "config.sfxvol");
 	getVolumeConfigValue (&options->speechVolumeScale, "config.speechvol");
+	
+	// JMS_GFX
+	if (res_IsInteger ("config.resolutionfactor") && !options->resolutionFactor.set)
+	{
+		options->resolutionFactor.value = res_GetInteger ("config.resolutionfactor");
+		options->resolutionFactor.set = true;
+	}
+	
+	// JMS_GFX
+	getBoolConfigValue (&options->forceAspectRatio, "config.forceaspectratio");
+	
+	// JMS_GFX
+	if (res_IsInteger ("config.loresBlowupScale"))
+	{
+		options->loresBlowupScale.value = res_GetInteger ("config.loresBlowupScale");
+	}
 
 	getBoolConfigValue (&options->cheatMode, "config.kohrStahp"); // JMS
 	// Serosis
diff -ruNp src.mm/uqmversion.h src/uqmversion.h
--- src.mm/uqmversion.h	2017-11-28 11:08:57 -0600
+++ src/uqmversion.h	2017-11-28 11:09:41 -0600
@@ -23,7 +23,7 @@
 #define UQM_MINOR_VERSION_S  "8"
 #define UQM_PATCH_VERSION     0
 #define UQM_PATCH_VERSION_S  "0"
-#define UQM_EXTRA_VERSION    " MegaMod Beta"
+#define UQM_EXTRA_VERSION    "-HD MegaMod Beta"
 /* The final version is interpreted as:
  * printf ("%d.%d.%d%s", UQM_MAJOR_VERSION, UQM_MINOR_VERSION,
  * 		UQM_PATCH_VERSION, UQM_EXTRA_VERSION);
